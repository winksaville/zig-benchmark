
./zig-cache/test:     file format elf64-x86-64


Disassembly of section .text:

000000000020a000 <ThreadSafeFixedBufferAllocator_alloc>:
            .buffer = buffer,
            .end_index = 0,
        };
    }

    fn alloc(allocator: *Allocator, n: usize, alignment: u29) ![]u8 {
  20a000:	49 89 d0             	mov    r8,rdx
        const self = @fieldParentPtr(ThreadSafeFixedBufferAllocator, "allocator", allocator);
        var end_index = @atomicLoad(usize, &self.end_index, builtin.AtomicOrder.SeqCst);
  20a003:	4c 8b 4e 18          	mov    r9,QWORD PTR [rsi+0x18]
  20a007:	48 8b 46 20          	mov    rax,QWORD PTR [rsi+0x20]
        while (true) {
            const addr = @ptrToInt(self.buffer.ptr) + end_index;
  20a00b:	4c 01 c8             	add    rax,r9
            const rem = @rem(addr, alignment);
  20a00e:	81 e1 ff ff ff 1f    	and    ecx,0x1fffffff
  20a014:	48 89 c2             	mov    rdx,rax
  20a017:	48 c1 ea 20          	shr    rdx,0x20
  20a01b:	75 13                	jne    20a030 <ThreadSafeFixedBufferAllocator_alloc+0x30>
  20a01d:	eb 21                	jmp    20a040 <ThreadSafeFixedBufferAllocator_alloc+0x40>
  20a01f:	90                   	nop
  20a020:	48 8b 46 20          	mov    rax,QWORD PTR [rsi+0x20]
            const addr = @ptrToInt(self.buffer.ptr) + end_index;
  20a024:	4c 01 c8             	add    rax,r9
  20a027:	48 89 c2             	mov    rdx,rax
  20a02a:	48 c1 ea 20          	shr    rdx,0x20
  20a02e:	74 10                	je     20a040 <ThreadSafeFixedBufferAllocator_alloc+0x40>
  20a030:	31 d2                	xor    edx,edx
  20a032:	48 f7 f1             	div    rcx
  20a035:	eb 0d                	jmp    20a044 <ThreadSafeFixedBufferAllocator_alloc+0x44>
  20a037:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  20a03e:	00 00 
  20a040:	31 d2                	xor    edx,edx
  20a042:	f7 f1                	div    ecx
            const march_forward_bytes = if (rem == 0) 0 else (alignment - rem);
  20a044:	49 89 ca             	mov    r10,rcx
  20a047:	49 29 d2             	sub    r10,rdx
  20a04a:	48 85 d2             	test   rdx,rdx
  20a04d:	4c 0f 44 d2          	cmove  r10,rdx
            const adjusted_index = end_index + march_forward_bytes;
  20a051:	4d 01 ca             	add    r10,r9
            const new_end_index = adjusted_index + n;
  20a054:	4b 8d 14 02          	lea    rdx,[r10+r8*1]
            if (new_end_index > self.buffer.len) {
  20a058:	48 3b 56 28          	cmp    rdx,QWORD PTR [rsi+0x28]
  20a05c:	77 33                	ja     20a091 <ThreadSafeFixedBufferAllocator_alloc+0x91>
                return error.OutOfMemory;
            }
            end_index = @cmpxchgWeak(usize, &self.end_index, end_index, new_end_index, builtin.AtomicOrder.SeqCst, builtin.AtomicOrder.SeqCst) orelse return self.buffer[adjusted_index..new_end_index];
  20a05e:	4c 89 c8             	mov    rax,r9
  20a061:	f0 48 0f b1 56 18    	lock cmpxchg QWORD PTR [rsi+0x18],rdx
  20a067:	49 89 c1             	mov    r9,rax
  20a06a:	75 b4                	jne    20a020 <ThreadSafeFixedBufferAllocator_alloc+0x20>
  20a06c:	4c 03 56 20          	add    r10,QWORD PTR [rsi+0x20]
  20a070:	66 c7 07 00 00       	mov    WORD PTR [rdi],0x0
  20a075:	0f b7 44 24 fe       	movzx  eax,WORD PTR [rsp-0x2]
  20a07a:	66 89 47 06          	mov    WORD PTR [rdi+0x6],ax
  20a07e:	8b 44 24 fa          	mov    eax,DWORD PTR [rsp-0x6]
  20a082:	89 47 02             	mov    DWORD PTR [rdi+0x2],eax
  20a085:	4c 89 57 08          	mov    QWORD PTR [rdi+0x8],r10
  20a089:	4c 89 47 10          	mov    QWORD PTR [rdi+0x10],r8
  20a08d:	48 89 f8             	mov    rax,rdi
  20a090:	c3                   	ret    
                return error.OutOfMemory;
  20a091:	48 8b 05 00 f4 ff ff 	mov    rax,QWORD PTR [rip+0xfffffffffffff400]        # 209498 <__unnamed_1+0x10>
  20a098:	48 89 47 10          	mov    QWORD PTR [rdi+0x10],rax
  20a09c:	c5 f8 10 05 e4 f3 ff 	vmovups xmm0,XMMWORD PTR [rip+0xfffffffffffff3e4]        # 209488 <__unnamed_1>
  20a0a3:	ff 
  20a0a4:	c5 f8 11 07          	vmovups XMMWORD PTR [rdi],xmm0
  20a0a8:	48 89 f8             	mov    rax,rdi
  20a0ab:	c3                   	ret    
  20a0ac:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

000000000020a0b0 <ThreadSafeFixedBufferAllocator_realloc>:
        }
    }

    fn realloc(allocator: *Allocator, old_mem: []u8, new_size: usize, alignment: u29) ![]u8 {
  20a0b0:	53                   	push   rbx
  20a0b1:	48 83 ec 30          	sub    rsp,0x30
  20a0b5:	49 89 d1             	mov    r9,rdx
        if (new_size <= old_mem.len) {
  20a0b8:	49 39 49 08          	cmp    QWORD PTR [r9+0x8],rcx
  20a0bc:	0f 83 a9 00 00 00    	jae    20a16b <ThreadSafeFixedBufferAllocator_realloc+0xbb>
        var end_index = @atomicLoad(usize, &self.end_index, builtin.AtomicOrder.SeqCst);
  20a0c2:	4c 8b 56 18          	mov    r10,QWORD PTR [rsi+0x18]
  20a0c6:	48 8b 46 20          	mov    rax,QWORD PTR [rsi+0x20]
            const addr = @ptrToInt(self.buffer.ptr) + end_index;
  20a0ca:	4c 01 d0             	add    rax,r10
            const rem = @rem(addr, alignment);
  20a0cd:	41 81 e0 ff ff ff 1f 	and    r8d,0x1fffffff
  20a0d4:	48 89 c2             	mov    rdx,rax
  20a0d7:	48 c1 ea 20          	shr    rdx,0x20
  20a0db:	75 13                	jne    20a0f0 <ThreadSafeFixedBufferAllocator_realloc+0x40>
  20a0dd:	eb 21                	jmp    20a100 <ThreadSafeFixedBufferAllocator_realloc+0x50>
  20a0df:	90                   	nop
  20a0e0:	48 8b 46 20          	mov    rax,QWORD PTR [rsi+0x20]
            const addr = @ptrToInt(self.buffer.ptr) + end_index;
  20a0e4:	4c 01 d0             	add    rax,r10
  20a0e7:	48 89 c2             	mov    rdx,rax
  20a0ea:	48 c1 ea 20          	shr    rdx,0x20
  20a0ee:	74 10                	je     20a100 <ThreadSafeFixedBufferAllocator_realloc+0x50>
  20a0f0:	31 d2                	xor    edx,edx
  20a0f2:	49 f7 f0             	div    r8
  20a0f5:	eb 0e                	jmp    20a105 <ThreadSafeFixedBufferAllocator_realloc+0x55>
  20a0f7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  20a0fe:	00 00 
  20a100:	31 d2                	xor    edx,edx
  20a102:	41 f7 f0             	div    r8d
            const march_forward_bytes = if (rem == 0) 0 else (alignment - rem);
  20a105:	4d 89 c3             	mov    r11,r8
  20a108:	49 29 d3             	sub    r11,rdx
  20a10b:	48 85 d2             	test   rdx,rdx
  20a10e:	4c 0f 44 da          	cmove  r11,rdx
            const adjusted_index = end_index + march_forward_bytes;
  20a112:	4d 01 d3             	add    r11,r10
            const new_end_index = adjusted_index + n;
  20a115:	49 8d 14 0b          	lea    rdx,[r11+rcx*1]
            if (new_end_index > self.buffer.len) {
  20a119:	48 3b 56 28          	cmp    rdx,QWORD PTR [rsi+0x28]
  20a11d:	77 6d                	ja     20a18c <ThreadSafeFixedBufferAllocator_realloc+0xdc>
            end_index = @cmpxchgWeak(usize, &self.end_index, end_index, new_end_index, builtin.AtomicOrder.SeqCst, builtin.AtomicOrder.SeqCst) orelse return self.buffer[adjusted_index..new_end_index];
  20a11f:	4c 89 d0             	mov    rax,r10
  20a122:	f0 48 0f b1 56 18    	lock cmpxchg QWORD PTR [rsi+0x18],rdx
  20a128:	49 89 c2             	mov    r10,rax
  20a12b:	75 b3                	jne    20a0e0 <ThreadSafeFixedBufferAllocator_realloc+0x30>
pub fn copy(comptime T: type, dest: []T, source: []const T) void {
    // TODO instead of manually doing this check for the whole array
    // and turning off runtime safety, the compiler should detect loops like
    // this and automatically omit safety checks for loops
    @setRuntimeSafety(false);
    assert(dest.len >= source.len);
  20a12d:	4d 8b 51 08          	mov    r10,QWORD PTR [r9+0x8]
  20a131:	49 39 ca             	cmp    r10,rcx
/// In Debug and ReleaseSafe modes, calls to this function are always
/// generated, and the `unreachable` statement triggers a panic.
/// In ReleaseFast and ReleaseSmall modes, calls to this function can be
/// optimized away.
pub fn assert(ok: bool) void {
    if (!ok) {
  20a134:	0f 87 31 01 00 00    	ja     20a26b <ThreadSafeFixedBufferAllocator_realloc+0x1bb>
  20a13a:	48 8b 46 20          	mov    rax,QWORD PTR [rsi+0x20]
  20a13e:	4e 8d 04 18          	lea    r8,[rax+r11*1]
    for (source) |s, i|
  20a142:	4d 85 d2             	test   r10,r10
  20a145:	0f 84 fa 00 00 00    	je     20a245 <ThreadSafeFixedBufferAllocator_realloc+0x195>
  20a14b:	49 8d 72 ff          	lea    rsi,[r10-0x1]
  20a14f:	44 89 d3             	mov    ebx,r10d
  20a152:	83 e3 07             	and    ebx,0x7
  20a155:	48 83 fe 07          	cmp    rsi,0x7
  20a159:	73 53                	jae    20a1ae <ThreadSafeFixedBufferAllocator_realloc+0xfe>
  20a15b:	31 f6                	xor    esi,esi
  20a15d:	48 85 db             	test   rbx,rbx
  20a160:	0f 85 c6 00 00 00    	jne    20a22c <ThreadSafeFixedBufferAllocator_realloc+0x17c>
  20a166:	e9 da 00 00 00       	jmp    20a245 <ThreadSafeFixedBufferAllocator_realloc+0x195>
            return old_mem[0..new_size];
  20a16b:	49 8b 01             	mov    rax,QWORD PTR [r9]
  20a16e:	66 c7 07 00 00       	mov    WORD PTR [rdi],0x0
  20a173:	0f b7 54 24 18       	movzx  edx,WORD PTR [rsp+0x18]
  20a178:	66 89 57 06          	mov    WORD PTR [rdi+0x6],dx
  20a17c:	8b 54 24 14          	mov    edx,DWORD PTR [rsp+0x14]
  20a180:	89 57 02             	mov    DWORD PTR [rdi+0x2],edx
  20a183:	48 89 47 08          	mov    QWORD PTR [rdi+0x8],rax
  20a187:	e9 d2 00 00 00       	jmp    20a25e <ThreadSafeFixedBufferAllocator_realloc+0x1ae>
        } else {
            const result = try alloc(allocator, new_size, alignment);
  20a18c:	66 c7 07 01 00       	mov    WORD PTR [rdi],0x1
  20a191:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
  20a196:	48 89 47 10          	mov    QWORD PTR [rdi+0x10],rax
  20a19a:	c5 f8 10 44 24 1a    	vmovups xmm0,XMMWORD PTR [rsp+0x1a]
  20a1a0:	c5 f8 11 47 02       	vmovups XMMWORD PTR [rdi+0x2],xmm0
  20a1a5:	48 89 f8             	mov    rax,rdi
  20a1a8:	48 83 c4 30          	add    rsp,0x30
  20a1ac:	5b                   	pop    rbx
  20a1ad:	c3                   	ret    
  20a1ae:	49 29 da             	sub    r10,rbx
  20a1b1:	4c 01 d8             	add    rax,r11
  20a1b4:	48 83 c0 07          	add    rax,0x7
  20a1b8:	31 f6                	xor    esi,esi
  20a1ba:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  20a1c0:	49 8b 11             	mov    rdx,QWORD PTR [r9]
  20a1c3:	0f b6 14 32          	movzx  edx,BYTE PTR [rdx+rsi*1]
        dest[i] = s;
  20a1c7:	88 54 30 f9          	mov    BYTE PTR [rax+rsi*1-0x7],dl
    for (source) |s, i|
  20a1cb:	49 8b 11             	mov    rdx,QWORD PTR [r9]
  20a1ce:	0f b6 54 32 01       	movzx  edx,BYTE PTR [rdx+rsi*1+0x1]
        dest[i] = s;
  20a1d3:	88 54 30 fa          	mov    BYTE PTR [rax+rsi*1-0x6],dl
    for (source) |s, i|
  20a1d7:	49 8b 11             	mov    rdx,QWORD PTR [r9]
  20a1da:	0f b6 54 32 02       	movzx  edx,BYTE PTR [rdx+rsi*1+0x2]
        dest[i] = s;
  20a1df:	88 54 30 fb          	mov    BYTE PTR [rax+rsi*1-0x5],dl
    for (source) |s, i|
  20a1e3:	49 8b 11             	mov    rdx,QWORD PTR [r9]
  20a1e6:	0f b6 54 32 03       	movzx  edx,BYTE PTR [rdx+rsi*1+0x3]
        dest[i] = s;
  20a1eb:	88 54 30 fc          	mov    BYTE PTR [rax+rsi*1-0x4],dl
    for (source) |s, i|
  20a1ef:	49 8b 11             	mov    rdx,QWORD PTR [r9]
  20a1f2:	0f b6 54 32 04       	movzx  edx,BYTE PTR [rdx+rsi*1+0x4]
        dest[i] = s;
  20a1f7:	88 54 30 fd          	mov    BYTE PTR [rax+rsi*1-0x3],dl
    for (source) |s, i|
  20a1fb:	49 8b 11             	mov    rdx,QWORD PTR [r9]
  20a1fe:	0f b6 54 32 05       	movzx  edx,BYTE PTR [rdx+rsi*1+0x5]
        dest[i] = s;
  20a203:	88 54 30 fe          	mov    BYTE PTR [rax+rsi*1-0x2],dl
    for (source) |s, i|
  20a207:	49 8b 11             	mov    rdx,QWORD PTR [r9]
  20a20a:	0f b6 54 32 06       	movzx  edx,BYTE PTR [rdx+rsi*1+0x6]
        dest[i] = s;
  20a20f:	88 54 30 ff          	mov    BYTE PTR [rax+rsi*1-0x1],dl
    for (source) |s, i|
  20a213:	49 8b 11             	mov    rdx,QWORD PTR [r9]
  20a216:	0f b6 54 32 07       	movzx  edx,BYTE PTR [rdx+rsi*1+0x7]
        dest[i] = s;
  20a21b:	88 14 30             	mov    BYTE PTR [rax+rsi*1],dl
    for (source) |s, i|
  20a21e:	48 83 c6 08          	add    rsi,0x8
  20a222:	49 39 f2             	cmp    r10,rsi
  20a225:	75 99                	jne    20a1c0 <ThreadSafeFixedBufferAllocator_realloc+0x110>
  20a227:	48 85 db             	test   rbx,rbx
  20a22a:	74 19                	je     20a245 <ThreadSafeFixedBufferAllocator_realloc+0x195>
  20a22c:	48 f7 db             	neg    rbx
  20a22f:	90                   	nop
  20a230:	49 8b 01             	mov    rax,QWORD PTR [r9]
  20a233:	0f b6 04 30          	movzx  eax,BYTE PTR [rax+rsi*1]
        dest[i] = s;
  20a237:	41 88 04 30          	mov    BYTE PTR [r8+rsi*1],al
    for (source) |s, i|
  20a23b:	48 83 c6 01          	add    rsi,0x1
  20a23f:	48 83 c3 01          	add    rbx,0x1
  20a243:	75 eb                	jne    20a230 <ThreadSafeFixedBufferAllocator_realloc+0x180>
            mem.copy(u8, result, old_mem);
            return result;
  20a245:	66 c7 07 00 00       	mov    WORD PTR [rdi],0x0
  20a24a:	0f b7 44 24 12       	movzx  eax,WORD PTR [rsp+0x12]
  20a24f:	66 89 47 06          	mov    WORD PTR [rdi+0x6],ax
  20a253:	8b 44 24 0e          	mov    eax,DWORD PTR [rsp+0xe]
  20a257:	89 47 02             	mov    DWORD PTR [rdi+0x2],eax
  20a25a:	4c 89 47 08          	mov    QWORD PTR [rdi+0x8],r8
  20a25e:	48 89 4f 10          	mov    QWORD PTR [rdi+0x10],rcx
  20a262:	48 89 f8             	mov    rax,rdi
  20a265:	48 83 c4 30          	add    rsp,0x30
  20a269:	5b                   	pop    rbx
  20a26a:	c3                   	ret    
        // In ReleaseFast test mode, we still want assert(false) to crash, so
        // we insert an explicit call to @panic instead of unreachable.
        // TODO we should use `assertOrPanic` in tests and remove this logic.
        if (builtin.is_test) {
            @panic("assertion failure");
  20a26b:	e8 70 a3 00 00       	call   2145e0 <panic>

000000000020a270 <assert>:
    if (!ok) {
  20a270:	40 f6 c7 01          	test   dil,0x1
  20a274:	74 01                	je     20a277 <assert+0x7>
pub fn assert(ok: bool) void {
  20a276:	c3                   	ret    
            @panic("assertion failure");
  20a277:	50                   	push   rax
  20a278:	e8 63 a3 00 00       	call   2145e0 <panic>
  20a27d:	0f 1f 00             	nop    DWORD PTR [rax]

000000000020a280 <init_vdso_clock_gettime>:
const linux = std.os.linux;
const cstr = std.cstr;
const mem = std.mem;

pub fn lookup(vername: []const u8, name: []const u8) usize {
    const vdso_addr = std.os.linux_aux_raw[std.elf.AT_SYSINFO_EHDR];
  20a280:	55                   	push   rbp
  20a281:	41 57                	push   r15
  20a283:	41 56                	push   r14
  20a285:	41 55                	push   r13
  20a287:	41 54                	push   r12
  20a289:	53                   	push   rbx
  20a28a:	4c 8b 0d b7 be 03 00 	mov    r9,QWORD PTR [rip+0x3beb7]        # 246148 <linux_aux_raw+0x108>
    if (vdso_addr == 0) return 0;
  20a291:	4d 85 c9             	test   r9,r9
  20a294:	0f 84 53 05 00 00    	je     20a7ed <init_vdso_clock_gettime+0x56d>

    var maybe_dynv: ?[*]usize = null;
    var base: usize = @maxValue(usize);
    {
        var i: usize = 0;
        while (i < eh.e_phnum) : ({
  20a29a:	41 0f b7 51 38       	movzx  edx,WORD PTR [r9+0x38]
  20a29f:	48 85 d2             	test   rdx,rdx
  20a2a2:	0f 84 45 05 00 00    	je     20a7ed <init_vdso_clock_gettime+0x56d>
  20a2a8:	49 8b 59 20          	mov    rbx,QWORD PTR [r9+0x20]
    var ph_addr: usize = vdso_addr + eh.e_phoff;
  20a2ac:	4c 01 cb             	add    rbx,r9
  20a2af:	41 0f b7 49 36       	movzx  ecx,WORD PTR [r9+0x36]
        while (i < eh.e_phnum) : ({
  20a2b4:	48 8d 42 ff          	lea    rax,[rdx-0x1]
  20a2b8:	89 d5                	mov    ebp,edx
  20a2ba:	83 e5 03             	and    ebp,0x3
  20a2bd:	48 83 f8 03          	cmp    rax,0x3
  20a2c1:	73 18                	jae    20a2db <init_vdso_clock_gettime+0x5b>
  20a2c3:	49 c7 c0 ff ff ff ff 	mov    r8,0xffffffffffffffff
  20a2ca:	45 31 f6             	xor    r14d,r14d
            i += 1;
            ph_addr += eh.e_phentsize;
        }) {
            const this_ph = @intToPtr(*elf.Phdr, ph_addr);
            switch (this_ph.p_type) {
  20a2cd:	48 85 ed             	test   rbp,rbp
  20a2d0:	0f 85 ec 00 00 00    	jne    20a3c2 <init_vdso_clock_gettime+0x142>
  20a2d6:	e9 29 01 00 00       	jmp    20a404 <init_vdso_clock_gettime+0x184>
        while (i < eh.e_phnum) : ({
  20a2db:	48 89 e8             	mov    rax,rbp
  20a2de:	48 29 d0             	sub    rax,rdx
  20a2e1:	49 c7 c0 ff ff ff ff 	mov    r8,0xffffffffffffffff
  20a2e8:	45 31 f6             	xor    r14d,r14d
  20a2eb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  20a2f0:	48 89 da             	mov    rdx,rbx
            switch (this_ph.p_type) {
  20a2f3:	8b 1a                	mov    ebx,DWORD PTR [rdx]
  20a2f5:	83 fb 02             	cmp    ebx,0x2
  20a2f8:	74 66                	je     20a360 <init_vdso_clock_gettime+0xe0>
  20a2fa:	83 fb 01             	cmp    ebx,0x1
  20a2fd:	75 0b                	jne    20a30a <init_vdso_clock_gettime+0x8a>
  20a2ff:	4c 8b 42 08          	mov    r8,QWORD PTR [rdx+0x8]
                elf.PT_LOAD => base = vdso_addr + this_ph.p_offset - this_ph.p_vaddr,
  20a303:	4d 01 c8             	add    r8,r9
  20a306:	4c 2b 42 10          	sub    r8,QWORD PTR [rdx+0x10]
            switch (this_ph.p_type) {
  20a30a:	8b 1c 0a             	mov    ebx,DWORD PTR [rdx+rcx*1]
            ph_addr += eh.e_phentsize;
  20a30d:	48 01 ca             	add    rdx,rcx
            switch (this_ph.p_type) {
  20a310:	83 fb 01             	cmp    ebx,0x1
  20a313:	74 5d                	je     20a372 <init_vdso_clock_gettime+0xf2>
  20a315:	83 fb 02             	cmp    ebx,0x2
  20a318:	75 07                	jne    20a321 <init_vdso_clock_gettime+0xa1>
  20a31a:	4c 8b 72 08          	mov    r14,QWORD PTR [rdx+0x8]
                elf.PT_DYNAMIC => maybe_dynv = @intToPtr([*]usize, vdso_addr + this_ph.p_offset),
  20a31e:	4d 01 ce             	add    r14,r9
            switch (this_ph.p_type) {
  20a321:	8b 1c 11             	mov    ebx,DWORD PTR [rcx+rdx*1]
            ph_addr += eh.e_phentsize;
  20a324:	48 01 ca             	add    rdx,rcx
            switch (this_ph.p_type) {
  20a327:	83 fb 01             	cmp    ebx,0x1
  20a32a:	74 5c                	je     20a388 <init_vdso_clock_gettime+0x108>
  20a32c:	83 fb 02             	cmp    ebx,0x2
  20a32f:	75 07                	jne    20a338 <init_vdso_clock_gettime+0xb8>
  20a331:	4c 8b 72 08          	mov    r14,QWORD PTR [rdx+0x8]
                elf.PT_DYNAMIC => maybe_dynv = @intToPtr([*]usize, vdso_addr + this_ph.p_offset),
  20a335:	4d 01 ce             	add    r14,r9
            switch (this_ph.p_type) {
  20a338:	8b 1c 11             	mov    ebx,DWORD PTR [rcx+rdx*1]
            ph_addr += eh.e_phentsize;
  20a33b:	48 01 ca             	add    rdx,rcx
            switch (this_ph.p_type) {
  20a33e:	83 fb 01             	cmp    ebx,0x1
  20a341:	74 5b                	je     20a39e <init_vdso_clock_gettime+0x11e>
  20a343:	83 fb 02             	cmp    ebx,0x2
  20a346:	75 07                	jne    20a34f <init_vdso_clock_gettime+0xcf>
  20a348:	4c 8b 72 08          	mov    r14,QWORD PTR [rdx+0x8]
                elf.PT_DYNAMIC => maybe_dynv = @intToPtr([*]usize, vdso_addr + this_ph.p_offset),
  20a34c:	4d 01 ce             	add    r14,r9
        while (i < eh.e_phnum) : ({
  20a34f:	48 8d 1c 0a          	lea    rbx,[rdx+rcx*1]
  20a353:	48 83 c0 04          	add    rax,0x4
  20a357:	75 97                	jne    20a2f0 <init_vdso_clock_gettime+0x70>
  20a359:	eb 5c                	jmp    20a3b7 <init_vdso_clock_gettime+0x137>
  20a35b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  20a360:	4c 8b 72 08          	mov    r14,QWORD PTR [rdx+0x8]
                elf.PT_DYNAMIC => maybe_dynv = @intToPtr([*]usize, vdso_addr + this_ph.p_offset),
  20a364:	4d 01 ce             	add    r14,r9
            switch (this_ph.p_type) {
  20a367:	8b 1c 0a             	mov    ebx,DWORD PTR [rdx+rcx*1]
            ph_addr += eh.e_phentsize;
  20a36a:	48 01 ca             	add    rdx,rcx
            switch (this_ph.p_type) {
  20a36d:	83 fb 01             	cmp    ebx,0x1
  20a370:	75 a3                	jne    20a315 <init_vdso_clock_gettime+0x95>
  20a372:	4c 8b 42 08          	mov    r8,QWORD PTR [rdx+0x8]
                elf.PT_LOAD => base = vdso_addr + this_ph.p_offset - this_ph.p_vaddr,
  20a376:	4d 01 c8             	add    r8,r9
  20a379:	4c 2b 42 10          	sub    r8,QWORD PTR [rdx+0x10]
            switch (this_ph.p_type) {
  20a37d:	8b 1c 11             	mov    ebx,DWORD PTR [rcx+rdx*1]
            ph_addr += eh.e_phentsize;
  20a380:	48 01 ca             	add    rdx,rcx
            switch (this_ph.p_type) {
  20a383:	83 fb 01             	cmp    ebx,0x1
  20a386:	75 a4                	jne    20a32c <init_vdso_clock_gettime+0xac>
  20a388:	4c 8b 42 08          	mov    r8,QWORD PTR [rdx+0x8]
                elf.PT_LOAD => base = vdso_addr + this_ph.p_offset - this_ph.p_vaddr,
  20a38c:	4d 01 c8             	add    r8,r9
  20a38f:	4c 2b 42 10          	sub    r8,QWORD PTR [rdx+0x10]
            switch (this_ph.p_type) {
  20a393:	8b 1c 11             	mov    ebx,DWORD PTR [rcx+rdx*1]
            ph_addr += eh.e_phentsize;
  20a396:	48 01 ca             	add    rdx,rcx
            switch (this_ph.p_type) {
  20a399:	83 fb 01             	cmp    ebx,0x1
  20a39c:	75 a5                	jne    20a343 <init_vdso_clock_gettime+0xc3>
  20a39e:	4c 8b 42 08          	mov    r8,QWORD PTR [rdx+0x8]
                elf.PT_LOAD => base = vdso_addr + this_ph.p_offset - this_ph.p_vaddr,
  20a3a2:	4d 01 c8             	add    r8,r9
  20a3a5:	4c 2b 42 10          	sub    r8,QWORD PTR [rdx+0x10]
        while (i < eh.e_phnum) : ({
  20a3a9:	48 8d 1c 0a          	lea    rbx,[rdx+rcx*1]
  20a3ad:	48 83 c0 04          	add    rax,0x4
  20a3b1:	0f 85 39 ff ff ff    	jne    20a2f0 <init_vdso_clock_gettime+0x70>
  20a3b7:	48 01 ca             	add    rdx,rcx
  20a3ba:	48 89 d3             	mov    rbx,rdx
            switch (this_ph.p_type) {
  20a3bd:	48 85 ed             	test   rbp,rbp
  20a3c0:	74 42                	je     20a404 <init_vdso_clock_gettime+0x184>
  20a3c2:	48 f7 dd             	neg    rbp
  20a3c5:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20a3cc:	00 00 00 00 
  20a3d0:	8b 03                	mov    eax,DWORD PTR [rbx]
  20a3d2:	83 f8 01             	cmp    eax,0x1
  20a3d5:	74 19                	je     20a3f0 <init_vdso_clock_gettime+0x170>
  20a3d7:	83 f8 02             	cmp    eax,0x2
  20a3da:	75 07                	jne    20a3e3 <init_vdso_clock_gettime+0x163>
  20a3dc:	4c 8b 73 08          	mov    r14,QWORD PTR [rbx+0x8]
                elf.PT_DYNAMIC => maybe_dynv = @intToPtr([*]usize, vdso_addr + this_ph.p_offset),
  20a3e0:	4d 01 ce             	add    r14,r9
            ph_addr += eh.e_phentsize;
  20a3e3:	48 01 cb             	add    rbx,rcx
        while (i < eh.e_phnum) : ({
  20a3e6:	48 83 c5 01          	add    rbp,0x1
  20a3ea:	75 e4                	jne    20a3d0 <init_vdso_clock_gettime+0x150>
  20a3ec:	eb 16                	jmp    20a404 <init_vdso_clock_gettime+0x184>
  20a3ee:	66 90                	xchg   ax,ax
  20a3f0:	4c 8b 43 08          	mov    r8,QWORD PTR [rbx+0x8]
                elf.PT_LOAD => base = vdso_addr + this_ph.p_offset - this_ph.p_vaddr,
  20a3f4:	4d 01 c8             	add    r8,r9
  20a3f7:	4c 2b 43 10          	sub    r8,QWORD PTR [rbx+0x10]
            ph_addr += eh.e_phentsize;
  20a3fb:	48 01 cb             	add    rbx,rcx
        while (i < eh.e_phnum) : ({
  20a3fe:	48 83 c5 01          	add    rbp,0x1
  20a402:	75 cc                	jne    20a3d0 <init_vdso_clock_gettime+0x150>
                else => {},
            }
        }
    }
    const dynv = maybe_dynv orelse return 0;
    if (base == @maxValue(usize)) return 0;
  20a404:	49 83 f8 ff          	cmp    r8,0xffffffffffffffff
    const dynv = maybe_dynv orelse return 0;
  20a408:	0f 84 df 03 00 00    	je     20a7ed <init_vdso_clock_gettime+0x56d>
  20a40e:	4d 85 f6             	test   r14,r14
  20a411:	0f 84 d6 03 00 00    	je     20a7ed <init_vdso_clock_gettime+0x56d>
    var maybe_versym: ?[*]u16 = null;
    var maybe_verdef: ?*elf.Verdef = null;

    {
        var i: usize = 0;
        while (dynv[i] != 0) : (i += 2) {
  20a417:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  20a41a:	48 85 d2             	test   rdx,rdx
  20a41d:	0f 84 ca 03 00 00    	je     20a7ed <init_vdso_clock_gettime+0x56d>
            const p = base + dynv[i + 1];
  20a423:	49 83 c6 10          	add    r14,0x10
  20a427:	45 31 ff             	xor    r15d,r15d
  20a42a:	45 31 db             	xor    r11d,r11d
  20a42d:	45 31 d2             	xor    r10d,r10d
  20a430:	31 ed                	xor    ebp,ebp
  20a432:	45 31 ed             	xor    r13d,r13d
  20a435:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20a43c:	00 00 00 00 
  20a440:	49 8b 4e f8          	mov    rcx,QWORD PTR [r14-0x8]
  20a444:	4c 01 c1             	add    rcx,r8
            switch (dynv[i]) {
  20a447:	48 83 fa 05          	cmp    rdx,0x5
  20a44b:	7e 33                	jle    20a480 <init_vdso_clock_gettime+0x200>
  20a44d:	48 83 fa 06          	cmp    rdx,0x6
  20a451:	74 4b                	je     20a49e <init_vdso_clock_gettime+0x21e>
  20a453:	48 81 fa f0 ff ff 6f 	cmp    rdx,0x6ffffff0
  20a45a:	74 53                	je     20a4af <init_vdso_clock_gettime+0x22f>
  20a45c:	48 81 fa fc ff ff 6f 	cmp    rdx,0x6ffffffc
  20a463:	75 2b                	jne    20a490 <init_vdso_clock_gettime+0x210>
  20a465:	49 89 cb             	mov    r11,rcx
        while (dynv[i] != 0) : (i += 2) {
  20a468:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  20a46b:	49 83 c6 10          	add    r14,0x10
  20a46f:	48 85 d2             	test   rdx,rdx
  20a472:	75 cc                	jne    20a440 <init_vdso_clock_gettime+0x1c0>
  20a474:	eb 5d                	jmp    20a4d3 <init_vdso_clock_gettime+0x253>
  20a476:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  20a47d:	00 00 00 
            switch (dynv[i]) {
  20a480:	48 83 fa 04          	cmp    rdx,0x4
  20a484:	74 3a                	je     20a4c0 <init_vdso_clock_gettime+0x240>
  20a486:	48 83 fa 05          	cmp    rdx,0x5
  20a48a:	75 04                	jne    20a490 <init_vdso_clock_gettime+0x210>
  20a48c:	49 89 cf             	mov    r15,rcx
  20a48f:	90                   	nop
        while (dynv[i] != 0) : (i += 2) {
  20a490:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  20a493:	49 83 c6 10          	add    r14,0x10
  20a497:	48 85 d2             	test   rdx,rdx
  20a49a:	75 a4                	jne    20a440 <init_vdso_clock_gettime+0x1c0>
  20a49c:	eb 35                	jmp    20a4d3 <init_vdso_clock_gettime+0x253>
  20a49e:	49 89 cd             	mov    r13,rcx
  20a4a1:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  20a4a4:	49 83 c6 10          	add    r14,0x10
  20a4a8:	48 85 d2             	test   rdx,rdx
  20a4ab:	75 93                	jne    20a440 <init_vdso_clock_gettime+0x1c0>
  20a4ad:	eb 24                	jmp    20a4d3 <init_vdso_clock_gettime+0x253>
  20a4af:	49 89 ca             	mov    r10,rcx
  20a4b2:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  20a4b5:	49 83 c6 10          	add    r14,0x10
  20a4b9:	48 85 d2             	test   rdx,rdx
  20a4bc:	75 82                	jne    20a440 <init_vdso_clock_gettime+0x1c0>
  20a4be:	eb 13                	jmp    20a4d3 <init_vdso_clock_gettime+0x253>
  20a4c0:	48 89 cd             	mov    rbp,rcx
  20a4c3:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  20a4c6:	49 83 c6 10          	add    r14,0x10
  20a4ca:	48 85 d2             	test   rdx,rdx
  20a4cd:	0f 85 6d ff ff ff    	jne    20a440 <init_vdso_clock_gettime+0x1c0>
        }
    }

    const strings = maybe_strings orelse return 0;
    const syms = maybe_syms orelse return 0;
    const hashtab = maybe_hashtab orelse return 0;
  20a4d3:	48 85 ed             	test   rbp,rbp
    const strings = maybe_strings orelse return 0;
  20a4d6:	0f 84 11 03 00 00    	je     20a7ed <init_vdso_clock_gettime+0x56d>
  20a4dc:	4d 85 ed             	test   r13,r13
  20a4df:	0f 84 08 03 00 00    	je     20a7ed <init_vdso_clock_gettime+0x56d>
  20a4e5:	4d 85 ff             	test   r15,r15
  20a4e8:	0f 84 ff 02 00 00    	je     20a7ed <init_vdso_clock_gettime+0x56d>
    if (maybe_verdef == null) maybe_versym = null;
  20a4ee:	4d 85 db             	test   r11,r11
  20a4f1:	4d 0f 44 d3          	cmove  r10,r11

    const OK_TYPES = (1 << elf.STT_NOTYPE | 1 << elf.STT_OBJECT | 1 << elf.STT_FUNC | 1 << elf.STT_COMMON);
    const OK_BINDS = (1 << elf.STB_GLOBAL | 1 << elf.STB_WEAK | 1 << elf.STB_GNU_UNIQUE);

    var i: usize = 0;
    while (i < hashtab[1]) : (i += 1) {
  20a4f5:	44 8b 4d 04          	mov    r9d,DWORD PTR [rbp+0x4]
  20a4f9:	4d 85 c9             	test   r9,r9
  20a4fc:	0f 84 eb 02 00 00    	je     20a7ed <init_vdso_clock_gettime+0x56d>
  20a502:	31 d2                	xor    edx,edx
  20a504:	4d 85 d2             	test   r10,r10
  20a507:	0f 84 e5 01 00 00    	je     20a6f2 <init_vdso_clock_gettime+0x472>
  20a50d:	41 bc 27 00 00 00    	mov    r12d,0x27
  20a513:	41 be 06 04 00 00    	mov    r14d,0x406
  20a519:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
        if (0 == (u32(1) << @intCast(u5, syms[i].st_info & 0xf) & OK_TYPES)) continue;
  20a520:	48 8d 0c 52          	lea    rcx,[rdx+rdx*2]
  20a524:	41 8a 5c cd 04       	mov    bl,BYTE PTR [r13+rcx*8+0x4]
  20a529:	89 d8                	mov    eax,ebx
  20a52b:	24 0f                	and    al,0xf
  20a52d:	0f b6 c0             	movzx  eax,al
  20a530:	41 0f a3 c4          	bt     r12d,eax
  20a534:	0f 83 a6 01 00 00    	jae    20a6e0 <init_vdso_clock_gettime+0x460>
        if (0 == (u32(1) << @intCast(u5, syms[i].st_info >> 4) & OK_BINDS)) continue;
  20a53a:	c0 eb 04             	shr    bl,0x4
  20a53d:	0f b6 c3             	movzx  eax,bl
  20a540:	41 0f a3 c6          	bt     r14d,eax
  20a544:	0f 83 96 01 00 00    	jae    20a6e0 <init_vdso_clock_gettime+0x460>
        if (0 == syms[i].st_shndx) continue;
  20a54a:	66 41 83 7c cd 06 00 	cmp    WORD PTR [r13+rcx*8+0x6],0x0
  20a551:	0f 84 89 01 00 00    	je     20a6e0 <init_vdso_clock_gettime+0x460>
        if (!mem.eql(u8, name, cstr.toSliceConst(strings + syms[i].st_name))) continue;
  20a557:	41 8b 6c cd 00       	mov    ebp,DWORD PTR [r13+rcx*8+0x0]
  20a55c:	4c 01 fd             	add    rbp,r15
  20a55f:	48 c7 c1 eb ff ff ff 	mov    rcx,0xffffffffffffffeb
  20a566:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  20a56d:	00 00 00 
    return true;
}

pub fn len(comptime T: type, ptr: [*]const T) usize {
    var count: usize = 0;
    while (ptr[count] != 0) : (count += 1) {}
  20a570:	80 7c 0d 15 00       	cmp    BYTE PTR [rbp+rcx*1+0x15],0x0
  20a575:	48 8d 49 01          	lea    rcx,[rcx+0x1]
  20a579:	75 f5                	jne    20a570 <init_vdso_clock_gettime+0x2f0>
    if (a.len != b.len) return false;
  20a57b:	48 85 c9             	test   rcx,rcx
  20a57e:	0f 85 5c 01 00 00    	jne    20a6e0 <init_vdso_clock_gettime+0x460>
        if (b[index] != item) return false;
  20a584:	80 7d 00 5f          	cmp    BYTE PTR [rbp+0x0],0x5f
  20a588:	0f 85 52 01 00 00    	jne    20a6e0 <init_vdso_clock_gettime+0x460>
  20a58e:	80 7d 01 5f          	cmp    BYTE PTR [rbp+0x1],0x5f
  20a592:	0f 85 48 01 00 00    	jne    20a6e0 <init_vdso_clock_gettime+0x460>
  20a598:	80 7d 02 76          	cmp    BYTE PTR [rbp+0x2],0x76
  20a59c:	0f 85 3e 01 00 00    	jne    20a6e0 <init_vdso_clock_gettime+0x460>
  20a5a2:	80 7d 03 64          	cmp    BYTE PTR [rbp+0x3],0x64
  20a5a6:	0f 85 34 01 00 00    	jne    20a6e0 <init_vdso_clock_gettime+0x460>
  20a5ac:	80 7d 04 73          	cmp    BYTE PTR [rbp+0x4],0x73
  20a5b0:	0f 85 2a 01 00 00    	jne    20a6e0 <init_vdso_clock_gettime+0x460>
  20a5b6:	80 7d 05 6f          	cmp    BYTE PTR [rbp+0x5],0x6f
  20a5ba:	0f 85 20 01 00 00    	jne    20a6e0 <init_vdso_clock_gettime+0x460>
  20a5c0:	80 7d 06 5f          	cmp    BYTE PTR [rbp+0x6],0x5f
  20a5c4:	0f 85 16 01 00 00    	jne    20a6e0 <init_vdso_clock_gettime+0x460>
  20a5ca:	80 7d 07 63          	cmp    BYTE PTR [rbp+0x7],0x63
  20a5ce:	0f 85 0c 01 00 00    	jne    20a6e0 <init_vdso_clock_gettime+0x460>
  20a5d4:	80 7d 08 6c          	cmp    BYTE PTR [rbp+0x8],0x6c
  20a5d8:	0f 85 02 01 00 00    	jne    20a6e0 <init_vdso_clock_gettime+0x460>
  20a5de:	80 7d 09 6f          	cmp    BYTE PTR [rbp+0x9],0x6f
  20a5e2:	0f 85 f8 00 00 00    	jne    20a6e0 <init_vdso_clock_gettime+0x460>
  20a5e8:	80 7d 0a 63          	cmp    BYTE PTR [rbp+0xa],0x63
  20a5ec:	0f 85 ee 00 00 00    	jne    20a6e0 <init_vdso_clock_gettime+0x460>
  20a5f2:	80 7d 0b 6b          	cmp    BYTE PTR [rbp+0xb],0x6b
  20a5f6:	0f 85 e4 00 00 00    	jne    20a6e0 <init_vdso_clock_gettime+0x460>
  20a5fc:	80 7d 0c 5f          	cmp    BYTE PTR [rbp+0xc],0x5f
  20a600:	0f 85 da 00 00 00    	jne    20a6e0 <init_vdso_clock_gettime+0x460>
  20a606:	80 7d 0d 67          	cmp    BYTE PTR [rbp+0xd],0x67
  20a60a:	0f 85 d0 00 00 00    	jne    20a6e0 <init_vdso_clock_gettime+0x460>
  20a610:	80 7d 0e 65          	cmp    BYTE PTR [rbp+0xe],0x65
  20a614:	0f 85 c6 00 00 00    	jne    20a6e0 <init_vdso_clock_gettime+0x460>
  20a61a:	80 7d 0f 74          	cmp    BYTE PTR [rbp+0xf],0x74
  20a61e:	0f 85 bc 00 00 00    	jne    20a6e0 <init_vdso_clock_gettime+0x460>
  20a624:	80 7d 10 74          	cmp    BYTE PTR [rbp+0x10],0x74
  20a628:	0f 85 b2 00 00 00    	jne    20a6e0 <init_vdso_clock_gettime+0x460>
  20a62e:	80 7d 11 69          	cmp    BYTE PTR [rbp+0x11],0x69
  20a632:	0f 85 a8 00 00 00    	jne    20a6e0 <init_vdso_clock_gettime+0x460>
  20a638:	80 7d 12 6d          	cmp    BYTE PTR [rbp+0x12],0x6d
  20a63c:	0f 85 9e 00 00 00    	jne    20a6e0 <init_vdso_clock_gettime+0x460>
  20a642:	80 7d 13 65          	cmp    BYTE PTR [rbp+0x13],0x65
  20a646:	0f 85 94 00 00 00    	jne    20a6e0 <init_vdso_clock_gettime+0x460>
        if (maybe_versym) |versym| {
            if (!checkver(maybe_verdef.?, versym[i], vername, strings))
  20a64c:	41 0f b7 2c 52       	movzx  ebp,WORD PTR [r10+rdx*2]
  20a651:	4c 89 d9             	mov    rcx,r11

fn checkver(def_arg: *elf.Verdef, vsym_arg: i32, vername: []const u8, strings: [*]u8) bool {
    var def = def_arg;
    const vsym = @bitCast(u32, vsym_arg) & 0x7fff;
    while (true) {
        if (0 == (def.vd_flags & elf.VER_FLG_BASE) and (def.vd_ndx & 0x7fff) == vsym)
  20a654:	f6 41 02 01          	test   BYTE PTR [rcx+0x2],0x1
  20a658:	75 1c                	jne    20a676 <init_vdso_clock_gettime+0x3f6>
  20a65a:	eb 09                	jmp    20a665 <init_vdso_clock_gettime+0x3e5>
            break;
        if (def.vd_next == 0)
            return false;
        def = @intToPtr(*elf.Verdef, @ptrToInt(def) + def.vd_next);
  20a65c:	48 01 d9             	add    rcx,rbx
        if (0 == (def.vd_flags & elf.VER_FLG_BASE) and (def.vd_ndx & 0x7fff) == vsym)
  20a65f:	f6 41 02 01          	test   BYTE PTR [rcx+0x2],0x1
  20a663:	75 11                	jne    20a676 <init_vdso_clock_gettime+0x3f6>
  20a665:	0f b7 41 04          	movzx  eax,WORD PTR [rcx+0x4]
  20a669:	66 31 e8             	xor    ax,bp
  20a66c:	25 ff 7f 00 00       	and    eax,0x7fff
  20a671:	66 85 c0             	test   ax,ax
  20a674:	74 0a                	je     20a680 <init_vdso_clock_gettime+0x400>
        if (def.vd_next == 0)
  20a676:	8b 59 10             	mov    ebx,DWORD PTR [rcx+0x10]
  20a679:	48 85 db             	test   rbx,rbx
  20a67c:	75 de                	jne    20a65c <init_vdso_clock_gettime+0x3dc>
  20a67e:	eb 60                	jmp    20a6e0 <init_vdso_clock_gettime+0x460>
    }
    const aux = @intToPtr(*elf.Verdaux, @ptrToInt(def) + def.vd_aux);
  20a680:	8b 41 0c             	mov    eax,DWORD PTR [rcx+0xc]
    return mem.eql(u8, vername, cstr.toSliceConst(strings + aux.vda_name));
  20a683:	8b 2c 08             	mov    ebp,DWORD PTR [rax+rcx*1]
  20a686:	4c 01 fd             	add    rbp,r15
  20a689:	48 c7 c1 f6 ff ff ff 	mov    rcx,0xfffffffffffffff6
    while (ptr[count] != 0) : (count += 1) {}
  20a690:	80 7c 0d 0a 00       	cmp    BYTE PTR [rbp+rcx*1+0xa],0x0
  20a695:	48 8d 49 01          	lea    rcx,[rcx+0x1]
  20a699:	75 f5                	jne    20a690 <init_vdso_clock_gettime+0x410>
    if (a.len != b.len) return false;
  20a69b:	48 85 c9             	test   rcx,rcx
  20a69e:	75 40                	jne    20a6e0 <init_vdso_clock_gettime+0x460>
        if (b[index] != item) return false;
  20a6a0:	80 7d 00 4c          	cmp    BYTE PTR [rbp+0x0],0x4c
  20a6a4:	75 3a                	jne    20a6e0 <init_vdso_clock_gettime+0x460>
  20a6a6:	80 7d 01 49          	cmp    BYTE PTR [rbp+0x1],0x49
  20a6aa:	75 34                	jne    20a6e0 <init_vdso_clock_gettime+0x460>
  20a6ac:	80 7d 02 4e          	cmp    BYTE PTR [rbp+0x2],0x4e
  20a6b0:	75 2e                	jne    20a6e0 <init_vdso_clock_gettime+0x460>
  20a6b2:	80 7d 03 55          	cmp    BYTE PTR [rbp+0x3],0x55
  20a6b6:	75 28                	jne    20a6e0 <init_vdso_clock_gettime+0x460>
  20a6b8:	80 7d 04 58          	cmp    BYTE PTR [rbp+0x4],0x58
  20a6bc:	75 22                	jne    20a6e0 <init_vdso_clock_gettime+0x460>
  20a6be:	80 7d 05 5f          	cmp    BYTE PTR [rbp+0x5],0x5f
  20a6c2:	75 1c                	jne    20a6e0 <init_vdso_clock_gettime+0x460>
  20a6c4:	80 7d 06 32          	cmp    BYTE PTR [rbp+0x6],0x32
  20a6c8:	75 16                	jne    20a6e0 <init_vdso_clock_gettime+0x460>
  20a6ca:	80 7d 07 2e          	cmp    BYTE PTR [rbp+0x7],0x2e
  20a6ce:	75 10                	jne    20a6e0 <init_vdso_clock_gettime+0x460>
  20a6d0:	80 7d 08 36          	cmp    BYTE PTR [rbp+0x8],0x36
            if (!checkver(maybe_verdef.?, versym[i], vername, strings))
  20a6d4:	0f 84 37 01 00 00    	je     20a811 <init_vdso_clock_gettime+0x591>
  20a6da:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
    while (i < hashtab[1]) : (i += 1) {
  20a6e0:	48 83 c2 01          	add    rdx,0x1
  20a6e4:	4c 39 ca             	cmp    rdx,r9
  20a6e7:	0f 82 33 fe ff ff    	jb     20a520 <init_vdso_clock_gettime+0x2a0>
  20a6ed:	e9 fb 00 00 00       	jmp    20a7ed <init_vdso_clock_gettime+0x56d>
  20a6f2:	bd 27 00 00 00       	mov    ebp,0x27
  20a6f7:	41 ba 06 04 00 00    	mov    r10d,0x406
  20a6fd:	0f 1f 00             	nop    DWORD PTR [rax]
        if (0 == (u32(1) << @intCast(u5, syms[i].st_info & 0xf) & OK_TYPES)) continue;
  20a700:	48 8d 0c 52          	lea    rcx,[rdx+rdx*2]
  20a704:	41 8a 44 cd 04       	mov    al,BYTE PTR [r13+rcx*8+0x4]
  20a709:	89 c3                	mov    ebx,eax
  20a70b:	80 e3 0f             	and    bl,0xf
  20a70e:	0f b6 db             	movzx  ebx,bl
  20a711:	0f a3 dd             	bt     ebp,ebx
  20a714:	0f 83 c6 00 00 00    	jae    20a7e0 <init_vdso_clock_gettime+0x560>
        if (0 == (u32(1) << @intCast(u5, syms[i].st_info >> 4) & OK_BINDS)) continue;
  20a71a:	c0 e8 04             	shr    al,0x4
  20a71d:	0f b6 c0             	movzx  eax,al
  20a720:	41 0f a3 c2          	bt     r10d,eax
  20a724:	0f 83 b6 00 00 00    	jae    20a7e0 <init_vdso_clock_gettime+0x560>
        if (0 == syms[i].st_shndx) continue;
  20a72a:	66 41 83 7c cd 06 00 	cmp    WORD PTR [r13+rcx*8+0x6],0x0
  20a731:	0f 84 a9 00 00 00    	je     20a7e0 <init_vdso_clock_gettime+0x560>
        if (!mem.eql(u8, name, cstr.toSliceConst(strings + syms[i].st_name))) continue;
  20a737:	41 8b 5c cd 00       	mov    ebx,DWORD PTR [r13+rcx*8+0x0]
  20a73c:	4c 01 fb             	add    rbx,r15
  20a73f:	48 c7 c1 eb ff ff ff 	mov    rcx,0xffffffffffffffeb
  20a746:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  20a74d:	00 00 00 
    while (ptr[count] != 0) : (count += 1) {}
  20a750:	80 7c 0b 15 00       	cmp    BYTE PTR [rbx+rcx*1+0x15],0x0
  20a755:	48 8d 49 01          	lea    rcx,[rcx+0x1]
  20a759:	75 f5                	jne    20a750 <init_vdso_clock_gettime+0x4d0>
    if (a.len != b.len) return false;
  20a75b:	48 85 c9             	test   rcx,rcx
  20a75e:	0f 85 7c 00 00 00    	jne    20a7e0 <init_vdso_clock_gettime+0x560>
        if (b[index] != item) return false;
  20a764:	80 3b 5f             	cmp    BYTE PTR [rbx],0x5f
  20a767:	75 77                	jne    20a7e0 <init_vdso_clock_gettime+0x560>
  20a769:	80 7b 01 5f          	cmp    BYTE PTR [rbx+0x1],0x5f
  20a76d:	75 71                	jne    20a7e0 <init_vdso_clock_gettime+0x560>
  20a76f:	80 7b 02 76          	cmp    BYTE PTR [rbx+0x2],0x76
  20a773:	75 6b                	jne    20a7e0 <init_vdso_clock_gettime+0x560>
  20a775:	80 7b 03 64          	cmp    BYTE PTR [rbx+0x3],0x64
  20a779:	75 65                	jne    20a7e0 <init_vdso_clock_gettime+0x560>
  20a77b:	80 7b 04 73          	cmp    BYTE PTR [rbx+0x4],0x73
  20a77f:	75 5f                	jne    20a7e0 <init_vdso_clock_gettime+0x560>
  20a781:	80 7b 05 6f          	cmp    BYTE PTR [rbx+0x5],0x6f
  20a785:	75 59                	jne    20a7e0 <init_vdso_clock_gettime+0x560>
  20a787:	80 7b 06 5f          	cmp    BYTE PTR [rbx+0x6],0x5f
  20a78b:	75 53                	jne    20a7e0 <init_vdso_clock_gettime+0x560>
  20a78d:	80 7b 07 63          	cmp    BYTE PTR [rbx+0x7],0x63
  20a791:	75 4d                	jne    20a7e0 <init_vdso_clock_gettime+0x560>
  20a793:	80 7b 08 6c          	cmp    BYTE PTR [rbx+0x8],0x6c
  20a797:	75 47                	jne    20a7e0 <init_vdso_clock_gettime+0x560>
  20a799:	80 7b 09 6f          	cmp    BYTE PTR [rbx+0x9],0x6f
  20a79d:	75 41                	jne    20a7e0 <init_vdso_clock_gettime+0x560>
  20a79f:	80 7b 0a 63          	cmp    BYTE PTR [rbx+0xa],0x63
  20a7a3:	75 3b                	jne    20a7e0 <init_vdso_clock_gettime+0x560>
  20a7a5:	80 7b 0b 6b          	cmp    BYTE PTR [rbx+0xb],0x6b
  20a7a9:	75 35                	jne    20a7e0 <init_vdso_clock_gettime+0x560>
  20a7ab:	80 7b 0c 5f          	cmp    BYTE PTR [rbx+0xc],0x5f
  20a7af:	75 2f                	jne    20a7e0 <init_vdso_clock_gettime+0x560>
  20a7b1:	80 7b 0d 67          	cmp    BYTE PTR [rbx+0xd],0x67
  20a7b5:	75 29                	jne    20a7e0 <init_vdso_clock_gettime+0x560>
  20a7b7:	80 7b 0e 65          	cmp    BYTE PTR [rbx+0xe],0x65
  20a7bb:	75 23                	jne    20a7e0 <init_vdso_clock_gettime+0x560>
  20a7bd:	80 7b 0f 74          	cmp    BYTE PTR [rbx+0xf],0x74
  20a7c1:	75 1d                	jne    20a7e0 <init_vdso_clock_gettime+0x560>
  20a7c3:	80 7b 10 74          	cmp    BYTE PTR [rbx+0x10],0x74
  20a7c7:	75 17                	jne    20a7e0 <init_vdso_clock_gettime+0x560>
  20a7c9:	80 7b 11 69          	cmp    BYTE PTR [rbx+0x11],0x69
  20a7cd:	75 11                	jne    20a7e0 <init_vdso_clock_gettime+0x560>
  20a7cf:	80 7b 12 6d          	cmp    BYTE PTR [rbx+0x12],0x6d
  20a7d3:	75 0b                	jne    20a7e0 <init_vdso_clock_gettime+0x560>
  20a7d5:	80 7b 13 65          	cmp    BYTE PTR [rbx+0x13],0x65
  20a7d9:	74 36                	je     20a811 <init_vdso_clock_gettime+0x591>
  20a7db:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
    while (i < hashtab[1]) : (i += 1) {
  20a7e0:	48 83 c2 01          	add    rdx,0x1
  20a7e4:	4c 39 ca             	cmp    rdx,r9
  20a7e7:	0f 82 13 ff ff ff    	jb     20a700 <init_vdso_clock_gettime+0x480>
}
var vdso_clock_gettime = init_vdso_clock_gettime;
extern fn init_vdso_clock_gettime(clk: i32, ts: *timespec) usize {
    const addr = vdso.lookup(VDSO_CGT_VER, VDSO_CGT_SYM);
    var f = @intToPtr(@typeOf(init_vdso_clock_gettime), addr);
    _ = @cmpxchgStrong(@typeOf(init_vdso_clock_gettime), &vdso_clock_gettime, init_vdso_clock_gettime, f, builtin.AtomicOrder.Monotonic, builtin.AtomicOrder.Monotonic);
  20a7ed:	48 8d 05 8c fa ff ff 	lea    rax,[rip+0xfffffffffffffa8c]        # 20a280 <init_vdso_clock_gettime>
  20a7f4:	31 c9                	xor    ecx,ecx
  20a7f6:	f0 48 0f b1 0d 49 78 	lock cmpxchg QWORD PTR [rip+0x37849],rcx        # 242048 <vdso_clock_gettime>
  20a7fd:	03 00 
    if (@ptrToInt(f) == 0) return @bitCast(usize, isize(-ENOSYS));
  20a7ff:	48 c7 c0 da ff ff ff 	mov    rax,0xffffffffffffffda
  20a806:	5b                   	pop    rbx
  20a807:	41 5c                	pop    r12
  20a809:	41 5d                	pop    r13
  20a80b:	41 5e                	pop    r14
  20a80d:	41 5f                	pop    r15
  20a80f:	5d                   	pop    rbp
  20a810:	c3                   	ret    
        return base + syms[i].st_value;
  20a811:	48 8d 04 52          	lea    rax,[rdx+rdx*2]
  20a815:	4d 03 44 c5 08       	add    r8,QWORD PTR [r13+rax*8+0x8]
    _ = @cmpxchgStrong(@typeOf(init_vdso_clock_gettime), &vdso_clock_gettime, init_vdso_clock_gettime, f, builtin.AtomicOrder.Monotonic, builtin.AtomicOrder.Monotonic);
  20a81a:	48 8d 05 5f fa ff ff 	lea    rax,[rip+0xfffffffffffffa5f]        # 20a280 <init_vdso_clock_gettime>
  20a821:	f0 4c 0f b1 05 1e 78 	lock cmpxchg QWORD PTR [rip+0x3781e],r8        # 242048 <vdso_clock_gettime>
  20a828:	03 00 
    if (@ptrToInt(f) == 0) return @bitCast(usize, isize(-ENOSYS));
  20a82a:	4d 85 c0             	test   r8,r8
  20a82d:	74 d0                	je     20a7ff <init_vdso_clock_gettime+0x57f>
    return f(clk, ts);
  20a82f:	5b                   	pop    rbx
  20a830:	41 5c                	pop    r12
  20a832:	41 5d                	pop    r13
  20a834:	41 5e                	pop    r14
  20a836:	41 5f                	pop    r15
  20a838:	5d                   	pop    rbp
  20a839:	41 ff e0             	jmp    r8
  20a83c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

000000000020a840 <benchmark.add>:
        }
        return std_dev;
    }
};

test "benchmark.add" {
  20a840:	55                   	push   rbp
  20a841:	48 89 e5             	mov    rbp,rsp
            if (pSelf.r != u128(pSelf.a) + u128(pSelf.b)) return error.Failed;
        }
    };

    // Create an instance of the framework and optionally change min_runtime_ns
    var bf = BenchmarkFramework.init(std.debug.global_allocator);
  20a844:	41 57                	push   r15
  20a846:	41 56                	push   r14
  20a848:	41 55                	push   r13
  20a84a:	41 54                	push   r12
  20a84c:	53                   	push   rbx
  20a84d:	48 83 e4 e0          	and    rsp,0xffffffffffffffe0
  20a851:	48 81 ec c0 22 00 00 	sub    rsp,0x22c0
  20a858:	c5 f8 57 c0          	vxorps xmm0,xmm0,xmm0
  20a85c:	c5 f8 11 84 24 e8 01 	vmovups XMMWORD PTR [rsp+0x1e8],xmm0
  20a863:	00 00 
  20a865:	48 c7 84 24 f8 01 00 	mov    QWORD PTR [rsp+0x1f8],0x0
  20a86c:	00 00 00 00 00 
  20a871:	48 8d 05 88 77 03 00 	lea    rax,[rip+0x37788]        # 242000 <global_fixed_allocator>
  20a878:	c4 e1 f9 6e c0       	vmovq  xmm0,rax
  20a87d:	c4 e2 79 59 c0       	vpbroadcastq xmm0,xmm0
  20a882:	c5 fa 7f 84 24 00 02 	vmovdqu XMMWORD PTR [rsp+0x200],xmm0
  20a889:	00 00 
  20a88b:	c5 f8 10 05 7d 5a ff 	vmovups xmm0,XMMWORD PTR [rip+0xffffffffffff5a7d]        # 200310 <__unnamed_18>
  20a892:	ff 
  20a893:	c5 f8 11 84 24 10 02 	vmovups XMMWORD PTR [rsp+0x210],xmm0
  20a89a:	00 00 
    //bf.min_runtime_ns = ns_per_s * 3;
    bf.logl = 0;
  20a89c:	c5 fd 6f 05 5c 59 ff 	vmovdqa ymm0,YMMWORD PTR [rip+0xffffffffffff595c]        # 200200 <__unnamed_103+0x20>
  20a8a3:	ff 
  20a8a4:	c5 fe 7f 84 24 c8 01 	vmovdqu YMMWORD PTR [rsp+0x1c8],ymm0
  20a8ab:	00 00 
  20a8ad:	0f 1f 00             	nop    DWORD PTR [rax]
    pub fn init() Mutex {
        return Mutex{ .lock = 0 };
    }

    pub fn acquire(self: *Mutex) Held {
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20a8b0:	b0 01                	mov    al,0x1
  20a8b2:	86 05 58 b7 03 00    	xchg   BYTE PTR [rip+0x3b758],al        # 246010 <stderr_mutex>
  20a8b8:	84 c0                	test   al,al
  20a8ba:	75 f4                	jne    20a8b0 <benchmark.add+0x70>
    if (stderr_stream) |st| {
  20a8bc:	48 8b 3d 45 b7 03 00 	mov    rdi,QWORD PTR [rip+0x3b745]        # 246008 <stderr_stream>
  20a8c3:	48 85 ff             	test   rdi,rdi
  20a8c6:	74 09                	je     20a8d1 <benchmark.add+0x91>
        pub const Error = WriteError;

        writeFn: fn (self: *Self, bytes: []const u8) Error!void,

        pub fn print(self: *Self, comptime format: []const u8, args: ...) !void {
            return std.fmt.format(self, Error, self.writeFn, format, args);
  20a8c8:	48 8b 05 71 77 03 00 	mov    rax,QWORD PTR [rip+0x37771]        # 242040 <stderr_file_out_stream+0x8>
  20a8cf:	eb 34                	jmp    20a905 <benchmark.add+0xc5>
        stderr_file = try io.getStdErr();
  20a8d1:	48 8d 05 58 77 03 00 	lea    rax,[rip+0x37758]        # 242030 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20a8d8:	48 89 05 59 77 03 00 	mov    QWORD PTR [rip+0x37759],rax        # 242038 <stderr_file_out_stream>
  20a8df:	48 8d 05 6a c0 00 00 	lea    rax,[rip+0xc06a]        # 216950 <FileOutStream_writeFn>
  20a8e6:	48 89 05 53 77 03 00 	mov    QWORD PTR [rip+0x37753],rax        # 242040 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  20a8ed:	c7 05 39 77 03 00 02 	mov    DWORD PTR [rip+0x37739],0x2        # 242030 <stderr_file>
  20a8f4:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20a8f7:	48 8d 3d 42 77 03 00 	lea    rdi,[rip+0x37742]        # 242040 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  20a8fe:	48 89 3d 03 b7 03 00 	mov    QWORD PTR [rip+0x3b703],rdi        # 246008 <stderr_stream>
        if (state != State.Start) {
            @compileError("Incomplete format string: " ++ fmt);
        }
    }
    if (start_index < fmt.len) {
        try output(context, fmt[start_index..]);
  20a905:	48 8d 35 7c b3 03 00 	lea    rsi,[rip+0x3b37c]        # 245c88 <__unnamed_3>
  20a90c:	c5 f8 77             	vzeroupper 
  20a90f:	ff d0                	call   rax
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20a911:	31 c0                	xor    eax,eax
  20a913:	86 05 f7 b6 03 00    	xchg   BYTE PTR [rip+0x3b6f7],al        # 246010 <stderr_mutex>
  20a919:	3c 01                	cmp    al,0x1
    if (!ok) {
  20a91b:	0f 85 b5 9c 00 00    	jne    2145d6 <benchmark.add+0x9d96>
        if (pSelf.logl >= 1)
  20a921:	4c 8b ac 24 c8 01 00 	mov    r13,QWORD PTR [rsp+0x1c8]
  20a928:	00 
  20a929:	4d 85 ed             	test   r13,r13
  20a92c:	0f 84 a6 03 00 00    	je     20acd8 <benchmark.add+0x498>
                    pSelf.logl, pSelf.min_runtime_ns, pSelf.max_iterations);
  20a932:	4c 8b a4 24 d0 01 00 	mov    r12,QWORD PTR [rsp+0x1d0]
  20a939:	00 
  20a93a:	48 8b 8c 24 e0 01 00 	mov    rcx,QWORD PTR [rsp+0x1e0]
  20a941:	00 
  20a942:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20a949:	1f 84 00 00 00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20a950:	b0 01                	mov    al,0x1
  20a952:	86 05 b8 b6 03 00    	xchg   BYTE PTR [rip+0x3b6b8],al        # 246010 <stderr_mutex>
  20a958:	84 c0                	test   al,al
  20a95a:	75 f4                	jne    20a950 <benchmark.add+0x110>
    if (stderr_stream) |st| {
  20a95c:	4c 8b 35 a5 b6 03 00 	mov    r14,QWORD PTR [rip+0x3b6a5]        # 246008 <stderr_stream>
  20a963:	4d 85 f6             	test   r14,r14
  20a966:	48 89 4c 24 20       	mov    QWORD PTR [rsp+0x20],rcx
  20a96b:	74 09                	je     20a976 <benchmark.add+0x136>
  20a96d:	48 8b 1d cc 76 03 00 	mov    rbx,QWORD PTR [rip+0x376cc]        # 242040 <stderr_file_out_stream+0x8>
  20a974:	eb 34                	jmp    20a9aa <benchmark.add+0x16a>
        stderr_file = try io.getStdErr();
  20a976:	48 8d 05 b3 76 03 00 	lea    rax,[rip+0x376b3]        # 242030 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20a97d:	48 89 05 b4 76 03 00 	mov    QWORD PTR [rip+0x376b4],rax        # 242038 <stderr_file_out_stream>
  20a984:	48 8d 1d c5 bf 00 00 	lea    rbx,[rip+0xbfc5]        # 216950 <FileOutStream_writeFn>
  20a98b:	48 89 1d ae 76 03 00 	mov    QWORD PTR [rip+0x376ae],rbx        # 242040 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  20a992:	c7 05 94 76 03 00 02 	mov    DWORD PTR [rip+0x37694],0x2        # 242030 <stderr_file>
  20a999:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20a99c:	4c 8d 35 9d 76 03 00 	lea    r14,[rip+0x3769d]        # 242040 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  20a9a3:	4c 89 35 5e b6 03 00 	mov    QWORD PTR [rip+0x3b65e],r14        # 246008 <stderr_stream>
                        try output(context, fmt[start_index..i]);
  20a9aa:	48 8d 35 87 b1 03 00 	lea    rsi,[rip+0x3b187]        # 245b38 <__unnamed_4>
  20a9b1:	4c 89 f7             	mov    rdi,r14
  20a9b4:	ff d3                	call   rbx
  20a9b6:	66 85 c0             	test   ax,ax
  20a9b9:	0f 85 09 03 00 00    	jne    20acc8 <benchmark.add+0x488>
    comptime Errors: type,
    output: fn (@typeOf(context), []const u8) Errors!void,
) Errors!void {
    // max_int_digits accounts for the minus sign. when printing an unsigned
    // number we don't need to do that.
    var buf: [max_int_digits - 1]u8 = undefined;
  20a9bf:	c5 fc 10 05 f8 ea ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffffeaf8]        # 2094bf <__unnamed_5+0x1f>
  20a9c6:	ff 
  20a9c7:	c5 fc 11 84 24 bf 02 	vmovups YMMWORD PTR [rsp+0x2bf],ymm0
  20a9ce:	00 00 
  20a9d0:	c5 fe 6f 05 c8 ea ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffffeac8]        # 2094a0 <__unnamed_5>
  20a9d7:	ff 
  20a9d8:	c5 fe 7f 84 24 a0 02 	vmovdqu YMMWORD PTR [rsp+0x2a0],ymm0
  20a9df:	00 00 
    var a = if (@sizeOf(@typeOf(value)) == 1) u8(value) else value;
    var index: usize = buf.len;

    while (true) {
        const digit = a % base;
  20a9e1:	49 bf cd cc cc cc cc 	movabs r15,0xcccccccccccccccd
  20a9e8:	cc cc cc 
  20a9eb:	4c 89 ea             	mov    rdx,r13
  20a9ee:	c4 c2 fb f6 cf       	mulx   rcx,rax,r15
  20a9f3:	c1 e9 02             	shr    ecx,0x2
  20a9f6:	81 e1 fe ff ff 3f    	and    ecx,0x3ffffffe
  20a9fc:	8d 0c 89             	lea    ecx,[rcx+rcx*4]
  20a9ff:	44 89 e8             	mov    eax,r13d
  20aa02:	29 c8                	sub    eax,ecx
    return value;
}

fn digitToChar(digit: u8, uppercase: bool) u8 {
    return switch (digit) {
        0...9 => digit + '0',
  20aa04:	b1 30                	mov    cl,0x30
  20aa06:	3c 0a                	cmp    al,0xa
  20aa08:	72 02                	jb     20aa0c <benchmark.add+0x1cc>
  20aa0a:	b1 57                	mov    cl,0x57
  20aa0c:	48 8d 94 24 df 02 00 	lea    rdx,[rsp+0x2df]
  20aa13:	00 
  20aa14:	00 c1                	add    cl,al
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  20aa16:	88 8c 24 df 02 00 00 	mov    BYTE PTR [rsp+0x2df],cl
        if (a == 0) break;
  20aa1d:	49 83 fd 0a          	cmp    r13,0xa
  20aa21:	73 0a                	jae    20aa2d <benchmark.add+0x1ed>
  20aa23:	b8 40 00 00 00       	mov    eax,0x40
  20aa28:	48 89 d1             	mov    rcx,rdx
  20aa2b:	eb 61                	jmp    20aa8e <benchmark.add+0x24e>
  20aa2d:	48 89 df             	mov    rdi,rbx
  20aa30:	b8 40 00 00 00       	mov    eax,0x40
  20aa35:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20aa3c:	00 00 00 00 
        a /= base;
  20aa40:	4c 89 ea             	mov    rdx,r13
  20aa43:	c4 c2 f3 f6 d7       	mulx   rdx,rcx,r15
  20aa48:	48 c1 ea 03          	shr    rdx,0x3
        const digit = a % base;
  20aa4c:	c4 c2 f3 f6 f7       	mulx   rsi,rcx,r15
  20aa51:	c1 ee 02             	shr    esi,0x2
  20aa54:	81 e6 fe ff ff 3f    	and    esi,0x3ffffffe
  20aa5a:	8d 34 b6             	lea    esi,[rsi+rsi*4]
  20aa5d:	89 d1                	mov    ecx,edx
  20aa5f:	29 f1                	sub    ecx,esi
        0...9 => digit + '0',
  20aa61:	b3 30                	mov    bl,0x30
  20aa63:	80 f9 0a             	cmp    cl,0xa
  20aa66:	72 02                	jb     20aa6a <benchmark.add+0x22a>
  20aa68:	b3 57                	mov    bl,0x57
  20aa6a:	00 cb                	add    bl,cl
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  20aa6c:	88 9c 04 9e 02 00 00 	mov    BYTE PTR [rsp+rax*1+0x29e],bl
        if (a == 0) break;
  20aa73:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  20aa77:	49 83 fd 63          	cmp    r13,0x63
  20aa7b:	49 89 d5             	mov    r13,rdx
  20aa7e:	77 c0                	ja     20aa40 <benchmark.add+0x200>
        const padded_buf = buf[index - padding ..];
  20aa80:	48 8d 0c 04          	lea    rcx,[rsp+rax*1]
  20aa84:	48 81 c1 9f 02 00 00 	add    rcx,0x29f
  20aa8b:	48 89 fb             	mov    rbx,rdi
  20aa8e:	ba 41 00 00 00       	mov    edx,0x41
  20aa93:	48 29 c2             	sub    rdx,rax
  20aa96:	48 89 8c 24 80 00 00 	mov    QWORD PTR [rsp+0x80],rcx
  20aa9d:	00 
  20aa9e:	48 89 94 24 88 00 00 	mov    QWORD PTR [rsp+0x88],rdx
  20aaa5:	00 
  20aaa6:	48 8d b4 24 80 00 00 	lea    rsi,[rsp+0x80]
  20aaad:	00 
        return output(context, padded_buf);
  20aaae:	4c 89 f7             	mov    rdi,r14
  20aab1:	c5 f8 77             	vzeroupper 
  20aab4:	ff d3                	call   rbx
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  20aab6:	66 85 c0             	test   ax,ax
  20aab9:	0f 85 09 02 00 00    	jne    20acc8 <benchmark.add+0x488>
                        try output(context, fmt[start_index..i]);
  20aabf:	48 8d 35 82 b0 03 00 	lea    rsi,[rip+0x3b082]        # 245b48 <__unnamed_6>
  20aac6:	4c 89 f7             	mov    rdi,r14
  20aac9:	ff d3                	call   rbx
  20aacb:	66 85 c0             	test   ax,ax
  20aace:	0f 85 f4 01 00 00    	jne    20acc8 <benchmark.add+0x488>
    var buf: [max_int_digits - 1]u8 = undefined;
  20aad4:	c5 fc 10 05 e3 e9 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffffe9e3]        # 2094bf <__unnamed_5+0x1f>
  20aadb:	ff 
  20aadc:	c5 fc 11 84 24 bf 02 	vmovups YMMWORD PTR [rsp+0x2bf],ymm0
  20aae3:	00 00 
  20aae5:	c5 fe 6f 05 b3 e9 ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffffe9b3]        # 2094a0 <__unnamed_5>
  20aaec:	ff 
  20aaed:	c5 fe 7f 84 24 a0 02 	vmovdqu YMMWORD PTR [rsp+0x2a0],ymm0
  20aaf4:	00 00 
        const digit = a % base;
  20aaf6:	4c 89 e2             	mov    rdx,r12
  20aaf9:	c4 c2 fb f6 cf       	mulx   rcx,rax,r15
  20aafe:	c1 e9 02             	shr    ecx,0x2
  20ab01:	81 e1 fe ff ff 3f    	and    ecx,0x3ffffffe
  20ab07:	8d 0c 89             	lea    ecx,[rcx+rcx*4]
  20ab0a:	44 89 e0             	mov    eax,r12d
  20ab0d:	29 c8                	sub    eax,ecx
        0...9 => digit + '0',
  20ab0f:	b1 30                	mov    cl,0x30
  20ab11:	3c 0a                	cmp    al,0xa
  20ab13:	72 02                	jb     20ab17 <benchmark.add+0x2d7>
  20ab15:	b1 57                	mov    cl,0x57
  20ab17:	00 c1                	add    cl,al
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  20ab19:	88 8c 24 df 02 00 00 	mov    BYTE PTR [rsp+0x2df],cl
        if (a == 0) break;
  20ab20:	49 83 fc 0a          	cmp    r12,0xa
  20ab24:	73 0f                	jae    20ab35 <benchmark.add+0x2f5>
  20ab26:	b8 40 00 00 00       	mov    eax,0x40
  20ab2b:	48 8d 8c 24 df 02 00 	lea    rcx,[rsp+0x2df]
  20ab32:	00 
  20ab33:	eb 59                	jmp    20ab8e <benchmark.add+0x34e>
  20ab35:	48 89 df             	mov    rdi,rbx
  20ab38:	b8 40 00 00 00       	mov    eax,0x40
  20ab3d:	0f 1f 00             	nop    DWORD PTR [rax]
        a /= base;
  20ab40:	4c 89 e2             	mov    rdx,r12
  20ab43:	c4 c2 f3 f6 d7       	mulx   rdx,rcx,r15
  20ab48:	48 c1 ea 03          	shr    rdx,0x3
        const digit = a % base;
  20ab4c:	c4 c2 f3 f6 f7       	mulx   rsi,rcx,r15
  20ab51:	c1 ee 02             	shr    esi,0x2
  20ab54:	81 e6 fe ff ff 3f    	and    esi,0x3ffffffe
  20ab5a:	8d 34 b6             	lea    esi,[rsi+rsi*4]
  20ab5d:	89 d1                	mov    ecx,edx
  20ab5f:	29 f1                	sub    ecx,esi
        0...9 => digit + '0',
  20ab61:	b3 30                	mov    bl,0x30
  20ab63:	80 f9 0a             	cmp    cl,0xa
  20ab66:	72 02                	jb     20ab6a <benchmark.add+0x32a>
  20ab68:	b3 57                	mov    bl,0x57
  20ab6a:	00 cb                	add    bl,cl
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  20ab6c:	88 9c 04 9e 02 00 00 	mov    BYTE PTR [rsp+rax*1+0x29e],bl
        if (a == 0) break;
  20ab73:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  20ab77:	49 83 fc 63          	cmp    r12,0x63
  20ab7b:	49 89 d4             	mov    r12,rdx
  20ab7e:	77 c0                	ja     20ab40 <benchmark.add+0x300>
        const padded_buf = buf[index - padding ..];
  20ab80:	48 8d 0c 04          	lea    rcx,[rsp+rax*1]
  20ab84:	48 81 c1 9f 02 00 00 	add    rcx,0x29f
  20ab8b:	48 89 fb             	mov    rbx,rdi
  20ab8e:	ba 41 00 00 00       	mov    edx,0x41
  20ab93:	48 29 c2             	sub    rdx,rax
  20ab96:	48 89 8c 24 80 00 00 	mov    QWORD PTR [rsp+0x80],rcx
  20ab9d:	00 
  20ab9e:	48 89 94 24 88 00 00 	mov    QWORD PTR [rsp+0x88],rdx
  20aba5:	00 
  20aba6:	48 8d b4 24 80 00 00 	lea    rsi,[rsp+0x80]
  20abad:	00 
        return output(context, padded_buf);
  20abae:	4c 89 f7             	mov    rdi,r14
  20abb1:	c5 f8 77             	vzeroupper 
  20abb4:	ff d3                	call   rbx
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  20abb6:	66 85 c0             	test   ax,ax
  20abb9:	0f 85 09 01 00 00    	jne    20acc8 <benchmark.add+0x488>
                        try output(context, fmt[start_index..i]);
  20abbf:	48 8d 35 92 af 03 00 	lea    rsi,[rip+0x3af92]        # 245b58 <__unnamed_7>
  20abc6:	4c 89 f7             	mov    rdi,r14
  20abc9:	ff d3                	call   rbx
  20abcb:	66 85 c0             	test   ax,ax
  20abce:	0f 85 f4 00 00 00    	jne    20acc8 <benchmark.add+0x488>
    var buf: [max_int_digits - 1]u8 = undefined;
  20abd4:	c5 fc 10 05 e3 e8 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffffe8e3]        # 2094bf <__unnamed_5+0x1f>
  20abdb:	ff 
  20abdc:	c5 fc 11 84 24 bf 02 	vmovups YMMWORD PTR [rsp+0x2bf],ymm0
  20abe3:	00 00 
  20abe5:	c5 fe 6f 05 b3 e8 ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffffe8b3]        # 2094a0 <__unnamed_5>
  20abec:	ff 
  20abed:	c5 fe 7f 84 24 a0 02 	vmovdqu YMMWORD PTR [rsp+0x2a0],ymm0
  20abf4:	00 00 
  20abf6:	48 8b 7c 24 20       	mov    rdi,QWORD PTR [rsp+0x20]
        const digit = a % base;
  20abfb:	48 89 fa             	mov    rdx,rdi
  20abfe:	c4 c2 fb f6 cf       	mulx   rcx,rax,r15
  20ac03:	c1 e9 02             	shr    ecx,0x2
  20ac06:	81 e1 fe ff ff 3f    	and    ecx,0x3ffffffe
  20ac0c:	8d 0c 89             	lea    ecx,[rcx+rcx*4]
  20ac0f:	89 f8                	mov    eax,edi
  20ac11:	29 c8                	sub    eax,ecx
        0...9 => digit + '0',
  20ac13:	b1 30                	mov    cl,0x30
  20ac15:	3c 0a                	cmp    al,0xa
  20ac17:	72 02                	jb     20ac1b <benchmark.add+0x3db>
  20ac19:	b1 57                	mov    cl,0x57
  20ac1b:	00 c1                	add    cl,al
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  20ac1d:	88 8c 24 df 02 00 00 	mov    BYTE PTR [rsp+0x2df],cl
        if (a == 0) break;
  20ac24:	48 83 ff 0a          	cmp    rdi,0xa
  20ac28:	73 0f                	jae    20ac39 <benchmark.add+0x3f9>
  20ac2a:	b8 40 00 00 00       	mov    eax,0x40
  20ac2f:	48 8d 94 24 df 02 00 	lea    rdx,[rsp+0x2df]
  20ac36:	00 
  20ac37:	eb 56                	jmp    20ac8f <benchmark.add+0x44f>
  20ac39:	49 89 d8             	mov    r8,rbx
  20ac3c:	b8 40 00 00 00       	mov    eax,0x40
        a /= base;
  20ac41:	48 89 fa             	mov    rdx,rdi
  20ac44:	c4 c2 f3 f6 d7       	mulx   rdx,rcx,r15
  20ac49:	48 c1 ea 03          	shr    rdx,0x3
        const digit = a % base;
  20ac4d:	c4 c2 f3 f6 f7       	mulx   rsi,rcx,r15
  20ac52:	c1 ee 02             	shr    esi,0x2
  20ac55:	81 e6 fe ff ff 3f    	and    esi,0x3ffffffe
  20ac5b:	8d 34 b6             	lea    esi,[rsi+rsi*4]
  20ac5e:	89 d1                	mov    ecx,edx
  20ac60:	29 f1                	sub    ecx,esi
        0...9 => digit + '0',
  20ac62:	b3 30                	mov    bl,0x30
  20ac64:	80 f9 0a             	cmp    cl,0xa
  20ac67:	72 02                	jb     20ac6b <benchmark.add+0x42b>
  20ac69:	b3 57                	mov    bl,0x57
  20ac6b:	00 cb                	add    bl,cl
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  20ac6d:	88 9c 04 9e 02 00 00 	mov    BYTE PTR [rsp+rax*1+0x29e],bl
        if (a == 0) break;
  20ac74:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  20ac78:	48 83 ff 63          	cmp    rdi,0x63
  20ac7c:	48 89 d7             	mov    rdi,rdx
  20ac7f:	77 c0                	ja     20ac41 <benchmark.add+0x401>
        const padded_buf = buf[index - padding ..];
  20ac81:	48 8d 14 04          	lea    rdx,[rsp+rax*1]
  20ac85:	48 81 c2 9f 02 00 00 	add    rdx,0x29f
  20ac8c:	4c 89 c3             	mov    rbx,r8
  20ac8f:	b9 41 00 00 00       	mov    ecx,0x41
  20ac94:	48 29 c1             	sub    rcx,rax
  20ac97:	48 89 94 24 80 00 00 	mov    QWORD PTR [rsp+0x80],rdx
  20ac9e:	00 
  20ac9f:	48 89 8c 24 88 00 00 	mov    QWORD PTR [rsp+0x88],rcx
  20aca6:	00 
  20aca7:	48 8d b4 24 80 00 00 	lea    rsi,[rsp+0x80]
  20acae:	00 
        return output(context, padded_buf);
  20acaf:	4c 89 f7             	mov    rdi,r14
  20acb2:	c5 f8 77             	vzeroupper 
  20acb5:	ff d3                	call   rbx
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  20acb7:	66 85 c0             	test   ax,ax
  20acba:	75 0c                	jne    20acc8 <benchmark.add+0x488>
        try output(context, fmt[start_index..]);
  20acbc:	48 8d 35 a5 ae 03 00 	lea    rsi,[rip+0x3aea5]        # 245b68 <__unnamed_8>
  20acc3:	4c 89 f7             	mov    rdi,r14
  20acc6:	ff d3                	call   rbx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20acc8:	31 c0                	xor    eax,eax
  20acca:	86 05 40 b3 03 00    	xchg   BYTE PTR [rip+0x3b340],al        # 246010 <stderr_mutex>
  20acd0:	3c 01                	cmp    al,0x1
    if (!ok) {
  20acd2:	0f 85 fe 98 00 00    	jne    2145d6 <benchmark.add+0x9d96>
                //On Linux, seccomp can do arbitrary things to our ability to call
                //  syscalls, including return any errno value it wants and
                //  inconsistently throwing errors. Since we can't account for
                //  abuses of seccomp in a reasonable way, we'll assume that if
                //  seccomp is going to block us it will at least do so consistently
                var ts: posix.timespec = undefined;
  20acd8:	c5 f9 10 0d 30 56 ff 	vmovupd xmm1,XMMWORD PTR [rip+0xffffffffffff5630]        # 200310 <__unnamed_18>
  20acdf:	ff 
  20ace0:	c5 f9 29 8c 24 a0 02 	vmovapd XMMWORD PTR [rsp+0x2a0],xmm1
  20ace7:	00 00 
  20ace9:	48 8d b4 24 a0 02 00 	lea    rsi,[rsp+0x2a0]
  20acf0:	00 
        : "rcx", "r11"
    );
}

pub fn syscall2(number: usize, arg1: usize, arg2: usize) usize {
    return asm volatile ("syscall"
  20acf1:	b8 e5 00 00 00       	mov    eax,0xe5
  20acf6:	bf 01 00 00 00       	mov    edi,0x1
  20acfb:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  20acfd:	48 89 c2             	mov    rdx,rax
  20ad00:	48 f7 da             	neg    rdx
  20ad03:	31 c9                	xor    ecx,ecx
  20ad05:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  20ad0b:	48 0f 47 ca          	cmova  rcx,rdx
                var result = posix.clock_getres(monotonic_clock_id, &ts);
                var errno = posix.getErrno(result);
                switch (errno) {
  20ad0f:	48 85 c9             	test   rcx,rcx
  20ad12:	74 13                	je     20ad27 <benchmark.add+0x4e7>
  20ad14:	48 83 f9 16          	cmp    rcx,0x16
  20ad18:	0f 85 3c 0a 00 00    	jne    20b75a <benchmark.add+0xf1a>
  20ad1e:	66 b8 02 00          	mov    ax,0x2
  20ad22:	e9 37 0a 00 00       	jmp    20b75e <benchmark.add+0xf1e>
        const f = @atomicLoad(@typeOf(init_vdso_clock_gettime), &vdso_clock_gettime, builtin.AtomicOrder.Unordered);
  20ad27:	48 8b 05 1a 73 03 00 	mov    rax,QWORD PTR [rip+0x3731a]        # 242048 <vdso_clock_gettime>
        if (@ptrToInt(f) != 0) {
  20ad2e:	48 85 c0             	test   rax,rax
  20ad31:	74 26                	je     20ad59 <benchmark.add+0x519>
  20ad33:	48 8d b4 24 a0 02 00 	lea    rsi,[rsp+0x2a0]
  20ad3a:	00 
            const rc = f(clk_id, tp);
  20ad3b:	bf 01 00 00 00       	mov    edi,0x1
  20ad40:	ff d0                	call   rax
            switch (rc) {
  20ad42:	48 83 f8 ea          	cmp    rax,0xffffffffffffffea
  20ad46:	0f 84 fa 09 00 00    	je     20b746 <benchmark.add+0xf06>
  20ad4c:	48 85 c0             	test   rax,rax
  20ad4f:	c5 f9 10 0d b9 55 ff 	vmovupd xmm1,XMMWORD PTR [rip+0xffffffffffff55b9]        # 200310 <__unnamed_18>
  20ad56:	ff 
  20ad57:	74 14                	je     20ad6d <benchmark.add+0x52d>
  20ad59:	48 8d b4 24 a0 02 00 	lea    rsi,[rsp+0x2a0]
  20ad60:	00 
  20ad61:	b8 e4 00 00 00       	mov    eax,0xe4
  20ad66:	bf 01 00 00 00       	mov    edi,0x1
  20ad6b:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  20ad6d:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
                }
                self.resolution = @intCast(u64, ts.tv_sec) * u64(ns_per_s) + @intCast(u64, ts.tv_nsec);

                result = posix.clock_gettime(monotonic_clock_id, &ts);
                errno = posix.getErrno(result);
                if (errno != 0) return std.os.unexpectedErrorPosix(errno);
  20ad73:	0f 83 e1 09 00 00    	jae    20b75a <benchmark.add+0xf1a>
                self.start_time = @intCast(u64, ts.tv_sec) * u64(ns_per_s) + @intCast(u64, ts.tv_nsec);
  20ad79:	48 8b 9c 24 a0 02 00 	mov    rbx,QWORD PTR [rsp+0x2a0]
  20ad80:	00 
  20ad81:	4c 8b b4 24 a8 02 00 	mov    r14,QWORD PTR [rsp+0x2a8]
  20ad88:	00 
    fn clockDarwin() u64 {
        return darwin.mach_absolute_time();
    }

    fn clockLinux() u64 {
        var ts: posix.timespec = undefined;
  20ad89:	c5 f9 29 8c 24 a0 02 	vmovapd XMMWORD PTR [rsp+0x2a0],xmm1
  20ad90:	00 00 
        const f = @atomicLoad(@typeOf(init_vdso_clock_gettime), &vdso_clock_gettime, builtin.AtomicOrder.Unordered);
  20ad92:	48 8b 05 af 72 03 00 	mov    rax,QWORD PTR [rip+0x372af]        # 242048 <vdso_clock_gettime>
        if (@ptrToInt(f) != 0) {
  20ad99:	48 85 c0             	test   rax,rax
  20ad9c:	74 26                	je     20adc4 <benchmark.add+0x584>
  20ad9e:	48 8d b4 24 a0 02 00 	lea    rsi,[rsp+0x2a0]
  20ada5:	00 
            const rc = f(clk_id, tp);
  20ada6:	bf 01 00 00 00       	mov    edi,0x1
  20adab:	ff d0                	call   rax
            switch (rc) {
  20adad:	48 83 f8 ea          	cmp    rax,0xffffffffffffffea
  20adb1:	0f 84 ef 09 00 00    	je     20b7a6 <benchmark.add+0xf66>
  20adb7:	48 85 c0             	test   rax,rax
  20adba:	c5 f9 10 0d 4e 55 ff 	vmovupd xmm1,XMMWORD PTR [rip+0xffffffffffff554e]        # 200310 <__unnamed_18>
  20adc1:	ff 
  20adc2:	74 14                	je     20add8 <benchmark.add+0x598>
  20adc4:	48 8d b4 24 a0 02 00 	lea    rsi,[rsp+0x2a0]
  20adcb:	00 
  20adcc:	b8 e4 00 00 00       	mov    eax,0xe4
  20add1:	bf 01 00 00 00       	mov    edi,0x1
  20add6:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  20add8:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
  20adde:	0f 83 f2 97 00 00    	jae    2145d6 <benchmark.add+0x9d96>
        var result = posix.clock_gettime(monotonic_clock_id, &ts);
        debug.assert(posix.getErrno(result) == 0);
        return @intCast(u64, ts.tv_sec) * u64(ns_per_s) + @intCast(u64, ts.tv_nsec);
  20ade4:	48 8b 84 24 a0 02 00 	mov    rax,QWORD PTR [rsp+0x2a0]
  20adeb:	00 
  20adec:	48 29 d8             	sub    rax,rbx
  20adef:	48 8b 8c 24 a8 02 00 	mov    rcx,QWORD PTR [rsp+0x2a8]
  20adf6:	00 
  20adf7:	4c 29 f1             	sub    rcx,r14
  20adfa:	48 69 c0 00 ca 9a 3b 	imul   rax,rax,0x3b9aca00
        var clock = clockNative() - self.start_time;
  20ae01:	48 01 c8             	add    rax,rcx
    pub fn init(seed: u64) SplitMix64 {
        return SplitMix64{ .s = seed };
    }

    pub fn next(self: *SplitMix64) u64 {
        self.s +%= 0x9e3779b97f4a7c15;
  20ae04:	48 b9 15 7c 4a 7f b9 	movabs rcx,0x9e3779b97f4a7c15
  20ae0b:	79 37 9e 
  20ae0e:	48 01 c1             	add    rcx,rax

        var z = self.s;
        z = (z ^ (z >> 30)) *% 0xbf58476d1ce4e5b9;
  20ae11:	48 89 ca             	mov    rdx,rcx
  20ae14:	48 c1 ea 1e          	shr    rdx,0x1e
  20ae18:	48 31 ca             	xor    rdx,rcx
  20ae1b:	48 b9 b9 e5 e4 1c 6d 	movabs rcx,0xbf58476d1ce4e5b9
  20ae22:	47 58 bf 
  20ae25:	48 0f af d1          	imul   rdx,rcx
        z = (z ^ (z >> 27)) *% 0x94d049bb133111eb;
  20ae29:	48 89 d6             	mov    rsi,rdx
  20ae2c:	48 c1 ee 1b          	shr    rsi,0x1b
  20ae30:	48 31 d6             	xor    rsi,rdx
  20ae33:	48 ba eb 11 31 13 bb 	movabs rdx,0x94d049bb133111eb
  20ae3a:	49 d0 94 
  20ae3d:	48 0f af f2          	imul   rsi,rdx
        return z ^ (z >> 31);
  20ae41:	48 89 f7             	mov    rdi,rsi
  20ae44:	48 c1 ef 1f          	shr    rdi,0x1f
  20ae48:	48 31 f7             	xor    rdi,rsi
        self.s +%= 0x9e3779b97f4a7c15;
  20ae4b:	48 be 2a f8 94 fe 72 	movabs rsi,0x3c6ef372fe94f82a
  20ae52:	f3 6e 3c 
  20ae55:	48 01 c6             	add    rsi,rax
        z = (z ^ (z >> 30)) *% 0xbf58476d1ce4e5b9;
  20ae58:	48 89 f0             	mov    rax,rsi
  20ae5b:	48 c1 e8 1e          	shr    rax,0x1e
  20ae5f:	48 31 f0             	xor    rax,rsi
  20ae62:	48 0f af c1          	imul   rax,rcx
        z = (z ^ (z >> 27)) *% 0x94d049bb133111eb;
  20ae66:	48 89 c1             	mov    rcx,rax
  20ae69:	48 c1 e9 1b          	shr    rcx,0x1b
  20ae6d:	48 31 c1             	xor    rcx,rax
  20ae70:	48 0f af ca          	imul   rcx,rdx
        return z ^ (z >> 31);
  20ae74:	48 89 c8             	mov    rax,rcx
  20ae77:	48 c1 e8 1f          	shr    rax,0x1f
  20ae7b:	48 31 c8             	xor    rax,rcx
    }

    fn next(self: *Xoroshiro128) u64 {
        const s0 = self.s[0];
        var s1 = self.s[1];
        const r = s0 +% s1;
  20ae7e:	48 8d 0c 38          	lea    rcx,[rax+rdi*1]

        s1 ^= s0;
  20ae82:	48 31 f8             	xor    rax,rdi
pub fn rotl(comptime T: type, x: T, r: var) T {
    if (T.is_signed) {
        @compileError("cannot rotate signed integer");
    } else {
        const ar = @mod(r, T.bit_count);
        return shl(T, x, ar) | shr(T, x, T.bit_count - ar);
  20ae85:	c4 e3 fb f0 d7 09    	rorx   rdx,rdi,0x9
        self.s[0] = math.rotl(u64, s0, u8(55)) ^ s1 ^ (s1 << 14);
  20ae8b:	48 31 c2             	xor    rdx,rax
  20ae8e:	c4 e3 fb f0 f0 1c    	rorx   rsi,rax,0x1c
  20ae94:	48 c1 e0 0e          	shl    rax,0xe
  20ae98:	48 31 d0             	xor    rax,rdx
        const r = s0 +% s1;
  20ae9b:	48 01 f0             	add    rax,rsi
            pSelf.a = prng.random.scalar(u64);
  20ae9e:	48 89 8c 24 10 01 00 	mov    QWORD PTR [rsp+0x110],rcx
  20aea5:	00 
            pSelf.b = prng.random.scalar(u64);
  20aea6:	48 89 84 24 08 01 00 	mov    QWORD PTR [rsp+0x108],rax
  20aead:	00 
        while (rep < pSelf.repetitions) : (rep += 1) {
  20aeae:	48 83 bc 24 d8 01 00 	cmp    QWORD PTR [rsp+0x1d8],0x0
  20aeb5:	00 00 
  20aeb7:	0f 84 b0 08 00 00    	je     20b76d <benchmark.add+0xf2d>
  20aebd:	41 bf 01 00 00 00    	mov    r15d,0x1
  20aec3:	4c 8d a4 24 a0 02 00 	lea    r12,[rsp+0x2a0]
  20aeca:	00 
  20aecb:	31 c0                	xor    eax,eax
  20aecd:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
            while (iterations <= pSelf.max_iterations) {
  20aed2:	48 8b b4 24 e0 01 00 	mov    rsi,QWORD PTR [rsp+0x1e0]
  20aed9:	00 
  20aeda:	49 39 f7             	cmp    r15,rsi
  20aedd:	0f 86 8d 00 00 00    	jbe    20af70 <benchmark.add+0x730>
            if (pSelf.r != u128(pSelf.a) + u128(pSelf.b)) return error.Failed;
  20aee3:	48 8b 84 24 08 01 00 	mov    rax,QWORD PTR [rsp+0x108]
  20aeea:	00 
  20aeeb:	31 c9                	xor    ecx,ecx
  20aeed:	48 03 84 24 10 01 00 	add    rax,QWORD PTR [rsp+0x110]
  20aef4:	00 
  20aef5:	c4 e1 f9 6e c0       	vmovq  xmm0,rax
  20aefa:	0f 92 c1             	setb   cl
  20aefd:	c4 e1 f9 6e c9       	vmovq  xmm1,rcx
  20af02:	c5 f9 6c c1          	vpunpcklqdq xmm0,xmm0,xmm1
  20af06:	c5 f9 74 84 24 18 01 	vpcmpeqb xmm0,xmm0,XMMWORD PTR [rsp+0x118]
  20af0d:	00 00 
  20af0f:	c5 f9 d7 c0          	vpmovmskb eax,xmm0
  20af13:	3d ff ff 00 00       	cmp    eax,0xffff
                try bm.tearDown();
  20af18:	0f 85 83 0f 00 00    	jne    20bea1 <benchmark.add+0x1661>
            pSelf.report(pSelf.results.items[pSelf.results.len - 1]);
  20af1e:	48 8b 9c 24 e8 01 00 	mov    rbx,QWORD PTR [rsp+0x1e8]
  20af25:	00 
  20af26:	4c 8b b4 24 f8 01 00 	mov    r14,QWORD PTR [rsp+0x1f8]
  20af2d:	00 
  20af2e:	4c 89 f0             	mov    rax,r14
  20af31:	48 c1 e0 04          	shl    rax,0x4
  20af35:	48 8b 7c 03 f0       	mov    rdi,QWORD PTR [rbx+rax*1-0x10]
  20af3a:	48 8b 74 03 f8       	mov    rsi,QWORD PTR [rbx+rax*1-0x8]
  20af3f:	e8 cc b0 00 00       	call   216010 <BenchmarkFramework_report>
  20af44:	c5 f9 10 0d c4 53 ff 	vmovupd xmm1,XMMWORD PTR [rip+0xffffffffffff53c4]        # 200310 <__unnamed_18>
  20af4b:	ff 
  20af4c:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
        while (rep < pSelf.repetitions) : (rep += 1) {
  20af51:	48 83 c0 01          	add    rax,0x1
  20af55:	48 3b 84 24 d8 01 00 	cmp    rax,QWORD PTR [rsp+0x1d8]
  20af5c:	00 
  20af5d:	0f 82 6a ff ff ff    	jb     20aecd <benchmark.add+0x68d>
  20af63:	e9 15 08 00 00       	jmp    20b77d <benchmark.add+0xf3d>
  20af68:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  20af6f:	00 
  20af70:	48 89 74 24 20       	mov    QWORD PTR [rsp+0x20],rsi
                var ts: posix.timespec = undefined;
  20af75:	c5 f9 29 8c 24 a0 02 	vmovapd XMMWORD PTR [rsp+0x2a0],xmm1
  20af7c:	00 00 
  20af7e:	b8 e5 00 00 00       	mov    eax,0xe5
  20af83:	bf 01 00 00 00       	mov    edi,0x1
  20af88:	4c 89 e6             	mov    rsi,r12
  20af8b:	0f 05                	syscall 
  20af8d:	48 89 c1             	mov    rcx,rax
  20af90:	48 f7 d9             	neg    rcx
  20af93:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  20af99:	b8 00 00 00 00       	mov    eax,0x0
  20af9e:	48 0f 46 c8          	cmovbe rcx,rax
                switch (errno) {
  20afa2:	48 85 c9             	test   rcx,rcx
  20afa5:	0f 85 69 fd ff ff    	jne    20ad14 <benchmark.add+0x4d4>
        const f = @atomicLoad(@typeOf(init_vdso_clock_gettime), &vdso_clock_gettime, builtin.AtomicOrder.Unordered);
  20afab:	48 8b 05 96 70 03 00 	mov    rax,QWORD PTR [rip+0x37096]        # 242048 <vdso_clock_gettime>
        if (@ptrToInt(f) != 0) {
  20afb2:	48 85 c0             	test   rax,rax
  20afb5:	74 21                	je     20afd8 <benchmark.add+0x798>
            const rc = f(clk_id, tp);
  20afb7:	bf 01 00 00 00       	mov    edi,0x1
  20afbc:	4c 89 e6             	mov    rsi,r12
  20afbf:	ff d0                	call   rax
            switch (rc) {
  20afc1:	48 83 f8 ea          	cmp    rax,0xffffffffffffffea
  20afc5:	0f 84 75 03 00 00    	je     20b340 <benchmark.add+0xb00>
  20afcb:	48 85 c0             	test   rax,rax
  20afce:	c5 f9 10 0d 3a 53 ff 	vmovupd xmm1,XMMWORD PTR [rip+0xffffffffffff533a]        # 200310 <__unnamed_18>
  20afd5:	ff 
  20afd6:	74 0f                	je     20afe7 <benchmark.add+0x7a7>
  20afd8:	b8 e4 00 00 00       	mov    eax,0xe4
  20afdd:	bf 01 00 00 00       	mov    edi,0x1
  20afe2:	4c 89 e6             	mov    rsi,r12
  20afe5:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  20afe7:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
                if (errno != 0) return std.os.unexpectedErrorPosix(errno);
  20afed:	0f 83 67 07 00 00    	jae    20b75a <benchmark.add+0xf1a>
                self.start_time = @intCast(u64, ts.tv_sec) * u64(ns_per_s) + @intCast(u64, ts.tv_nsec);
  20aff3:	c5 f9 6f 94 24 a0 02 	vmovdqa xmm2,XMMWORD PTR [rsp+0x2a0]
  20affa:	00 00 
        while (iter > 0) : (iter -= 1) {
  20affc:	4d 85 ff             	test   r15,r15
  20afff:	0f 84 8d 01 00 00    	je     20b192 <benchmark.add+0x952>
            pR.* = u128(pA.*) + u128(pB.*);
  20b005:	49 8d 4f ff          	lea    rcx,[r15-0x1]
  20b009:	4c 89 fa             	mov    rdx,r15
  20b00c:	4c 89 f8             	mov    rax,r15
  20b00f:	48 83 e2 07          	and    rdx,0x7
  20b013:	74 3b                	je     20b050 <benchmark.add+0x810>
  20b015:	48 f7 da             	neg    rdx
  20b018:	4c 89 f8             	mov    rax,r15
  20b01b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  20b020:	48 8b b4 24 10 01 00 	mov    rsi,QWORD PTR [rsp+0x110]
  20b027:	00 
  20b028:	31 ff                	xor    edi,edi
  20b02a:	48 03 b4 24 08 01 00 	add    rsi,QWORD PTR [rsp+0x108]
  20b031:	00 
  20b032:	40 0f 92 c7          	setb   dil
  20b036:	48 89 b4 24 18 01 00 	mov    QWORD PTR [rsp+0x118],rsi
  20b03d:	00 
  20b03e:	48 89 bc 24 20 01 00 	mov    QWORD PTR [rsp+0x120],rdi
  20b045:	00 
        while (iter > 0) : (iter -= 1) {
  20b046:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  20b04a:	48 83 c2 01          	add    rdx,0x1
  20b04e:	75 d0                	jne    20b020 <benchmark.add+0x7e0>
            pR.* = u128(pA.*) + u128(pB.*);
  20b050:	48 83 f9 07          	cmp    rcx,0x7
  20b054:	0f 82 38 01 00 00    	jb     20b192 <benchmark.add+0x952>
  20b05a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  20b060:	48 8b 8c 24 10 01 00 	mov    rcx,QWORD PTR [rsp+0x110]
  20b067:	00 
  20b068:	31 d2                	xor    edx,edx
  20b06a:	48 03 8c 24 08 01 00 	add    rcx,QWORD PTR [rsp+0x108]
  20b071:	00 
  20b072:	0f 92 c2             	setb   dl
  20b075:	48 89 8c 24 18 01 00 	mov    QWORD PTR [rsp+0x118],rcx
  20b07c:	00 
  20b07d:	48 89 94 24 20 01 00 	mov    QWORD PTR [rsp+0x120],rdx
  20b084:	00 
  20b085:	31 c9                	xor    ecx,ecx
  20b087:	48 8b 94 24 10 01 00 	mov    rdx,QWORD PTR [rsp+0x110]
  20b08e:	00 
  20b08f:	48 03 94 24 08 01 00 	add    rdx,QWORD PTR [rsp+0x108]
  20b096:	00 
  20b097:	48 89 94 24 18 01 00 	mov    QWORD PTR [rsp+0x118],rdx
  20b09e:	00 
  20b09f:	0f 92 c1             	setb   cl
  20b0a2:	48 89 8c 24 20 01 00 	mov    QWORD PTR [rsp+0x120],rcx
  20b0a9:	00 
  20b0aa:	48 8b 8c 24 10 01 00 	mov    rcx,QWORD PTR [rsp+0x110]
  20b0b1:	00 
  20b0b2:	31 d2                	xor    edx,edx
  20b0b4:	48 03 8c 24 08 01 00 	add    rcx,QWORD PTR [rsp+0x108]
  20b0bb:	00 
  20b0bc:	0f 92 c2             	setb   dl
  20b0bf:	48 89 8c 24 18 01 00 	mov    QWORD PTR [rsp+0x118],rcx
  20b0c6:	00 
  20b0c7:	48 89 94 24 20 01 00 	mov    QWORD PTR [rsp+0x120],rdx
  20b0ce:	00 
  20b0cf:	48 8b 8c 24 10 01 00 	mov    rcx,QWORD PTR [rsp+0x110]
  20b0d6:	00 
  20b0d7:	31 d2                	xor    edx,edx
  20b0d9:	48 03 8c 24 08 01 00 	add    rcx,QWORD PTR [rsp+0x108]
  20b0e0:	00 
  20b0e1:	0f 92 c2             	setb   dl
  20b0e4:	48 89 8c 24 18 01 00 	mov    QWORD PTR [rsp+0x118],rcx
  20b0eb:	00 
  20b0ec:	48 89 94 24 20 01 00 	mov    QWORD PTR [rsp+0x120],rdx
  20b0f3:	00 
  20b0f4:	31 c9                	xor    ecx,ecx
  20b0f6:	48 8b 94 24 10 01 00 	mov    rdx,QWORD PTR [rsp+0x110]
  20b0fd:	00 
  20b0fe:	48 03 94 24 08 01 00 	add    rdx,QWORD PTR [rsp+0x108]
  20b105:	00 
  20b106:	48 89 94 24 18 01 00 	mov    QWORD PTR [rsp+0x118],rdx
  20b10d:	00 
  20b10e:	0f 92 c1             	setb   cl
  20b111:	48 89 8c 24 20 01 00 	mov    QWORD PTR [rsp+0x120],rcx
  20b118:	00 
  20b119:	48 8b 8c 24 10 01 00 	mov    rcx,QWORD PTR [rsp+0x110]
  20b120:	00 
  20b121:	31 d2                	xor    edx,edx
  20b123:	48 03 8c 24 08 01 00 	add    rcx,QWORD PTR [rsp+0x108]
  20b12a:	00 
  20b12b:	0f 92 c2             	setb   dl
  20b12e:	48 89 8c 24 18 01 00 	mov    QWORD PTR [rsp+0x118],rcx
  20b135:	00 
  20b136:	48 89 94 24 20 01 00 	mov    QWORD PTR [rsp+0x120],rdx
  20b13d:	00 
  20b13e:	48 8b 8c 24 10 01 00 	mov    rcx,QWORD PTR [rsp+0x110]
  20b145:	00 
  20b146:	31 d2                	xor    edx,edx
  20b148:	48 03 8c 24 08 01 00 	add    rcx,QWORD PTR [rsp+0x108]
  20b14f:	00 
  20b150:	0f 92 c2             	setb   dl
  20b153:	48 89 8c 24 18 01 00 	mov    QWORD PTR [rsp+0x118],rcx
  20b15a:	00 
  20b15b:	48 89 94 24 20 01 00 	mov    QWORD PTR [rsp+0x120],rdx
  20b162:	00 
  20b163:	31 c9                	xor    ecx,ecx
  20b165:	48 8b 94 24 10 01 00 	mov    rdx,QWORD PTR [rsp+0x110]
  20b16c:	00 
  20b16d:	48 03 94 24 08 01 00 	add    rdx,QWORD PTR [rsp+0x108]
  20b174:	00 
  20b175:	48 89 94 24 18 01 00 	mov    QWORD PTR [rsp+0x118],rdx
  20b17c:	00 
  20b17d:	0f 92 c1             	setb   cl
        while (iter > 0) : (iter -= 1) {
  20b180:	48 83 c0 f8          	add    rax,0xfffffffffffffff8
            pR.* = u128(pA.*) + u128(pB.*);
  20b184:	48 89 8c 24 20 01 00 	mov    QWORD PTR [rsp+0x120],rcx
  20b18b:	00 
        while (iter > 0) : (iter -= 1) {
  20b18c:	0f 85 ce fe ff ff    	jne    20b060 <benchmark.add+0x820>
        var ts: posix.timespec = undefined;
  20b192:	c5 f9 29 8c 24 a0 02 	vmovapd XMMWORD PTR [rsp+0x2a0],xmm1
  20b199:	00 00 
        const f = @atomicLoad(@typeOf(init_vdso_clock_gettime), &vdso_clock_gettime, builtin.AtomicOrder.Unordered);
  20b19b:	48 8b 05 a6 6e 03 00 	mov    rax,QWORD PTR [rip+0x36ea6]        # 242048 <vdso_clock_gettime>
        if (@ptrToInt(f) != 0) {
  20b1a2:	48 85 c0             	test   rax,rax
  20b1a5:	74 2d                	je     20b1d4 <benchmark.add+0x994>
  20b1a7:	c5 f9 7f 54 24 60    	vmovdqa XMMWORD PTR [rsp+0x60],xmm2
            const rc = f(clk_id, tp);
  20b1ad:	bf 01 00 00 00       	mov    edi,0x1
  20b1b2:	4c 89 e6             	mov    rsi,r12
  20b1b5:	ff d0                	call   rax
            switch (rc) {
  20b1b7:	48 83 f8 ea          	cmp    rax,0xffffffffffffffea
  20b1bb:	0f 84 98 01 00 00    	je     20b359 <benchmark.add+0xb19>
  20b1c1:	48 85 c0             	test   rax,rax
  20b1c4:	c5 f9 10 0d 44 51 ff 	vmovupd xmm1,XMMWORD PTR [rip+0xffffffffffff5144]        # 200310 <__unnamed_18>
  20b1cb:	ff 
  20b1cc:	c5 f9 6f 54 24 60    	vmovdqa xmm2,XMMWORD PTR [rsp+0x60]
  20b1d2:	74 0f                	je     20b1e3 <benchmark.add+0x9a3>
  20b1d4:	b8 e4 00 00 00       	mov    eax,0xe4
  20b1d9:	bf 01 00 00 00       	mov    edi,0x1
  20b1de:	4c 89 e6             	mov    rsi,r12
  20b1e1:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  20b1e3:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
  20b1e9:	0f 83 e7 93 00 00    	jae    2145d6 <benchmark.add+0x9d96>
        return @intCast(u64, ts.tv_sec) * u64(ns_per_s) + @intCast(u64, ts.tv_nsec);
  20b1ef:	c5 f9 6f 84 24 a0 02 	vmovdqa xmm0,XMMWORD PTR [rsp+0x2a0]
  20b1f6:	00 00 
  20b1f8:	c5 f9 fb c2          	vpsubq xmm0,xmm0,xmm2
  20b1fc:	c4 e1 f9 7e c0       	vmovq  rax,xmm0
        var clock = clockNative() - self.start_time;
  20b201:	c4 e3 f9 16 c3 01    	vpextrq rbx,xmm0,0x1
  20b207:	48 69 c0 00 ca 9a 3b 	imul   rax,rax,0x3b9aca00
  20b20e:	48 01 c3             	add    rbx,rax
                if ((run_time_ns >= pSelf.min_runtime_ns) or (iterations >= pSelf.max_iterations)) {
  20b211:	4c 8b b4 24 d0 01 00 	mov    r14,QWORD PTR [rsp+0x1d0]
  20b218:	00 
  20b219:	4c 39 f3             	cmp    rbx,r14
  20b21c:	48 8b 74 24 20       	mov    rsi,QWORD PTR [rsp+0x20]
  20b221:	0f 83 ef 04 00 00    	jae    20b716 <benchmark.add+0xed6>
  20b227:	49 39 f7             	cmp    r15,rsi
  20b22a:	0f 83 e6 04 00 00    	jae    20b716 <benchmark.add+0xed6>
                    if (pSelf.logl >= 1) {
  20b230:	4c 8b ac 24 c8 01 00 	mov    r13,QWORD PTR [rsp+0x1c8]
  20b237:	00 
  20b238:	4d 85 ed             	test   r13,r13
  20b23b:	74 18                	je     20b255 <benchmark.add+0xa15>
                        pSelf.report(Result {.run_time_ns = run_time_ns, .iterations = iterations});
  20b23d:	48 89 df             	mov    rdi,rbx
  20b240:	4c 89 fe             	mov    rsi,r15
  20b243:	e8 c8 ad 00 00       	call   216010 <BenchmarkFramework_report>
  20b248:	48 8b 74 24 20       	mov    rsi,QWORD PTR [rsp+0x20]
  20b24d:	c5 f9 10 0d bb 50 ff 	vmovupd xmm1,XMMWORD PTR [rip+0xffffffffffff50bb]        # 200310 <__unnamed_18>
  20b254:	ff 
                    if (run_time_ns < 1000) {
  20b255:	48 81 fb e8 03 00 00 	cmp    rbx,0x3e8
  20b25c:	73 52                	jae    20b2b0 <benchmark.add+0xa70>
  20b25e:	41 be 01 00 00 00    	mov    r14d,0x1
  20b264:	41 bc e8 03 00 00    	mov    r12d,0x3e8
                    iterations = (iterations * numer) / denom;
  20b26a:	4d 0f af fc          	imul   r15,r12
  20b26e:	4c 89 f8             	mov    rax,r15
  20b271:	48 c1 e8 20          	shr    rax,0x20
  20b275:	74 74                	je     20b2eb <benchmark.add+0xaab>
  20b277:	31 d2                	xor    edx,edx
  20b279:	4c 89 f8             	mov    rax,r15
  20b27c:	49 f7 f6             	div    r14
  20b27f:	49 89 c7             	mov    r15,rax
                    if (iterations > pSelf.max_iterations) {
  20b282:	49 39 f7             	cmp    r15,rsi
  20b285:	4c 0f 47 fe          	cmova  r15,rsi
                    if (pSelf.logl >= 2) warn("iteratons:{} numer:{} denom:{}\n", iterations, numer, denom);
  20b289:	49 83 fd 02          	cmp    r13,0x2
  20b28d:	0f 83 7d 00 00 00    	jae    20b310 <benchmark.add+0xad0>
            while (iterations <= pSelf.max_iterations) {
  20b293:	49 39 f7             	cmp    r15,rsi
  20b296:	4c 8d a4 24 a0 02 00 	lea    r12,[rsp+0x2a0]
  20b29d:	00 
  20b29e:	0f 86 cc fc ff ff    	jbe    20af70 <benchmark.add+0x730>
  20b2a4:	e9 3a fc ff ff       	jmp    20aee3 <benchmark.add+0x6a3>
  20b2a9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
                    } else if (run_time_ns < (pSelf.min_runtime_ns / 10)) {
  20b2b0:	4c 89 f2             	mov    rdx,r14
  20b2b3:	48 b8 cd cc cc cc cc 	movabs rax,0xcccccccccccccccd
  20b2ba:	cc cc cc 
  20b2bd:	c4 e2 fb f6 c8       	mulx   rcx,rax,rax
  20b2c2:	48 c1 e9 03          	shr    rcx,0x3
  20b2c6:	31 c0                	xor    eax,eax
  20b2c8:	48 39 cb             	cmp    rbx,rcx
  20b2cb:	0f 93 c0             	setae  al
  20b2ce:	4c 8d 34 c0          	lea    r14,[rax+rax*8]
  20b2d2:	49 83 c6 01          	add    r14,0x1
  20b2d6:	4c 8d 24 85 0a 00 00 	lea    r12,[rax*4+0xa]
  20b2dd:	00 
                    iterations = (iterations * numer) / denom;
  20b2de:	4d 0f af fc          	imul   r15,r12
  20b2e2:	4c 89 f8             	mov    rax,r15
  20b2e5:	48 c1 e8 20          	shr    rax,0x20
  20b2e9:	75 8c                	jne    20b277 <benchmark.add+0xa37>
  20b2eb:	31 d2                	xor    edx,edx
  20b2ed:	44 89 f8             	mov    eax,r15d
  20b2f0:	41 f7 f6             	div    r14d
  20b2f3:	41 89 c7             	mov    r15d,eax
                    if (iterations > pSelf.max_iterations) {
  20b2f6:	49 39 f7             	cmp    r15,rsi
  20b2f9:	4c 0f 47 fe          	cmova  r15,rsi
                    if (pSelf.logl >= 2) warn("iteratons:{} numer:{} denom:{}\n", iterations, numer, denom);
  20b2fd:	49 83 fd 02          	cmp    r13,0x2
  20b301:	72 90                	jb     20b293 <benchmark.add+0xa53>
  20b303:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20b30a:	84 00 00 00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20b310:	b0 01                	mov    al,0x1
  20b312:	86 05 f8 ac 03 00    	xchg   BYTE PTR [rip+0x3acf8],al        # 246010 <stderr_mutex>
  20b318:	84 c0                	test   al,al
  20b31a:	75 f4                	jne    20b310 <benchmark.add+0xad0>
    if (stderr_stream) |st| {
  20b31c:	4c 8b 2d e5 ac 03 00 	mov    r13,QWORD PTR [rip+0x3ace5]        # 246008 <stderr_stream>
  20b323:	4d 85 ed             	test   r13,r13
  20b326:	74 50                	je     20b378 <benchmark.add+0xb38>
  20b328:	48 8b 1d 11 6d 03 00 	mov    rbx,QWORD PTR [rip+0x36d11]        # 242040 <stderr_file_out_stream+0x8>
  20b32f:	eb 7e                	jmp    20b3af <benchmark.add+0xb6f>
  20b331:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20b338:	0f 1f 84 00 00 00 00 
  20b33f:	00 
  20b340:	c5 f9 10 0d c8 4f ff 	vmovupd xmm1,XMMWORD PTR [rip+0xffffffffffff4fc8]        # 200310 <__unnamed_18>
  20b347:	ff 
  20b348:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
                if (errno != 0) return std.os.unexpectedErrorPosix(errno);
  20b34e:	0f 82 9f fc ff ff    	jb     20aff3 <benchmark.add+0x7b3>
  20b354:	e9 01 04 00 00       	jmp    20b75a <benchmark.add+0xf1a>
  20b359:	c5 f9 10 0d af 4f ff 	vmovupd xmm1,XMMWORD PTR [rip+0xffffffffffff4faf]        # 200310 <__unnamed_18>
  20b360:	ff 
  20b361:	c5 f9 6f 54 24 60    	vmovdqa xmm2,XMMWORD PTR [rsp+0x60]
  20b367:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
    if (!ok) {
  20b36d:	0f 82 7c fe ff ff    	jb     20b1ef <benchmark.add+0x9af>
  20b373:	e9 5e 92 00 00       	jmp    2145d6 <benchmark.add+0x9d96>
        stderr_file = try io.getStdErr();
  20b378:	c7 05 ae 6c 03 00 02 	mov    DWORD PTR [rip+0x36cae],0x2        # 242030 <stderr_file>
  20b37f:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20b382:	48 8d 05 a7 6c 03 00 	lea    rax,[rip+0x36ca7]        # 242030 <stderr_file>
  20b389:	48 89 05 a8 6c 03 00 	mov    QWORD PTR [rip+0x36ca8],rax        # 242038 <stderr_file_out_stream>
  20b390:	48 8d 05 b9 b5 00 00 	lea    rax,[rip+0xb5b9]        # 216950 <FileOutStream_writeFn>
  20b397:	48 89 05 a2 6c 03 00 	mov    QWORD PTR [rip+0x36ca2],rax        # 242040 <stderr_file_out_stream+0x8>
  20b39e:	4c 8d 2d 9b 6c 03 00 	lea    r13,[rip+0x36c9b]        # 242040 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  20b3a5:	4c 89 2d 5c ac 03 00 	mov    QWORD PTR [rip+0x3ac5c],r13        # 246008 <stderr_stream>
  20b3ac:	48 89 c3             	mov    rbx,rax
                        try output(context, fmt[start_index..i]);
  20b3af:	4c 89 ef             	mov    rdi,r13
  20b3b2:	48 8d 35 bf a7 03 00 	lea    rsi,[rip+0x3a7bf]        # 245b78 <__unnamed_10>
  20b3b9:	ff d3                	call   rbx
  20b3bb:	66 85 c0             	test   ax,ax
  20b3be:	0f 85 1c 03 00 00    	jne    20b6e0 <benchmark.add+0xea0>
    var buf: [max_int_digits - 1]u8 = undefined;
  20b3c4:	c5 fc 10 05 f3 e0 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffffe0f3]        # 2094bf <__unnamed_5+0x1f>
  20b3cb:	ff 
  20b3cc:	c5 fc 11 84 24 bf 02 	vmovups YMMWORD PTR [rsp+0x2bf],ymm0
  20b3d3:	00 00 
  20b3d5:	c5 fe 6f 05 c3 e0 ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffffe0c3]        # 2094a0 <__unnamed_5>
  20b3dc:	ff 
  20b3dd:	c5 fe 7f 84 24 a0 02 	vmovdqu YMMWORD PTR [rsp+0x2a0],ymm0
  20b3e4:	00 00 
        const digit = a % base;
  20b3e6:	4c 89 fa             	mov    rdx,r15
  20b3e9:	48 b8 cd cc cc cc cc 	movabs rax,0xcccccccccccccccd
  20b3f0:	cc cc cc 
  20b3f3:	c4 e2 fb f6 c8       	mulx   rcx,rax,rax
  20b3f8:	c1 e9 02             	shr    ecx,0x2
  20b3fb:	81 e1 fe ff ff 3f    	and    ecx,0x3ffffffe
  20b401:	8d 0c 89             	lea    ecx,[rcx+rcx*4]
  20b404:	44 89 f8             	mov    eax,r15d
  20b407:	29 c8                	sub    eax,ecx
        0...9 => digit + '0',
  20b409:	b1 30                	mov    cl,0x30
  20b40b:	3c 0a                	cmp    al,0xa
  20b40d:	72 02                	jb     20b411 <benchmark.add+0xbd1>
  20b40f:	b1 57                	mov    cl,0x57
  20b411:	00 c1                	add    cl,al
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  20b413:	88 8c 24 df 02 00 00 	mov    BYTE PTR [rsp+0x2df],cl
        if (a == 0) break;
  20b41a:	49 83 ff 0a          	cmp    r15,0xa
  20b41e:	73 0f                	jae    20b42f <benchmark.add+0xbef>
  20b420:	b9 40 00 00 00       	mov    ecx,0x40
  20b425:	48 8d 84 24 df 02 00 	lea    rax,[rsp+0x2df]
  20b42c:	00 
  20b42d:	eb 6d                	jmp    20b49c <benchmark.add+0xc5c>
  20b42f:	49 89 d8             	mov    r8,rbx
  20b432:	b9 40 00 00 00       	mov    ecx,0x40
  20b437:	4c 89 f8             	mov    rax,r15
  20b43a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
        a /= base;
  20b440:	48 89 c2             	mov    rdx,rax
  20b443:	48 be cd cc cc cc cc 	movabs rsi,0xcccccccccccccccd
  20b44a:	cc cc cc 
  20b44d:	48 89 f7             	mov    rdi,rsi
  20b450:	c4 e2 cb f6 d7       	mulx   rdx,rsi,rdi
  20b455:	48 c1 ea 03          	shr    rdx,0x3
        const digit = a % base;
  20b459:	c4 e2 cb f6 ff       	mulx   rdi,rsi,rdi
  20b45e:	c1 ef 02             	shr    edi,0x2
  20b461:	81 e7 fe ff ff 3f    	and    edi,0x3ffffffe
  20b467:	8d 3c bf             	lea    edi,[rdi+rdi*4]
  20b46a:	89 d6                	mov    esi,edx
  20b46c:	29 fe                	sub    esi,edi
        0...9 => digit + '0',
  20b46e:	b3 30                	mov    bl,0x30
  20b470:	40 80 fe 0a          	cmp    sil,0xa
  20b474:	72 02                	jb     20b478 <benchmark.add+0xc38>
  20b476:	b3 57                	mov    bl,0x57
  20b478:	40 00 f3             	add    bl,sil
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  20b47b:	88 9c 0c 9e 02 00 00 	mov    BYTE PTR [rsp+rcx*1+0x29e],bl
        if (a == 0) break;
  20b482:	48 83 c1 ff          	add    rcx,0xffffffffffffffff
  20b486:	48 83 f8 63          	cmp    rax,0x63
  20b48a:	48 89 d0             	mov    rax,rdx
  20b48d:	77 b1                	ja     20b440 <benchmark.add+0xc00>
        const padded_buf = buf[index - padding ..];
  20b48f:	48 8d 04 0c          	lea    rax,[rsp+rcx*1]
  20b493:	48 05 9f 02 00 00    	add    rax,0x29f
  20b499:	4c 89 c3             	mov    rbx,r8
  20b49c:	ba 41 00 00 00       	mov    edx,0x41
  20b4a1:	48 29 ca             	sub    rdx,rcx
  20b4a4:	48 89 84 24 80 00 00 	mov    QWORD PTR [rsp+0x80],rax
  20b4ab:	00 
  20b4ac:	48 89 94 24 88 00 00 	mov    QWORD PTR [rsp+0x88],rdx
  20b4b3:	00 
        return output(context, padded_buf);
  20b4b4:	4c 89 ef             	mov    rdi,r13
  20b4b7:	48 8d b4 24 80 00 00 	lea    rsi,[rsp+0x80]
  20b4be:	00 
  20b4bf:	c5 f8 77             	vzeroupper 
  20b4c2:	ff d3                	call   rbx
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  20b4c4:	66 85 c0             	test   ax,ax
  20b4c7:	0f 85 13 02 00 00    	jne    20b6e0 <benchmark.add+0xea0>
                        try output(context, fmt[start_index..i]);
  20b4cd:	4c 89 ef             	mov    rdi,r13
  20b4d0:	48 8d 35 b1 a6 03 00 	lea    rsi,[rip+0x3a6b1]        # 245b88 <__unnamed_11>
  20b4d7:	ff d3                	call   rbx
  20b4d9:	66 85 c0             	test   ax,ax
  20b4dc:	0f 85 fe 01 00 00    	jne    20b6e0 <benchmark.add+0xea0>
  20b4e2:	48 89 5c 24 20       	mov    QWORD PTR [rsp+0x20],rbx
    var buf: [max_int_digits - 1]u8 = undefined;
  20b4e7:	c5 fc 10 05 d0 df ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffffdfd0]        # 2094bf <__unnamed_5+0x1f>
  20b4ee:	ff 
  20b4ef:	c5 fc 11 84 24 bf 02 	vmovups YMMWORD PTR [rsp+0x2bf],ymm0
  20b4f6:	00 00 
  20b4f8:	c5 fe 6f 05 a0 df ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffffdfa0]        # 2094a0 <__unnamed_5>
  20b4ff:	ff 
  20b500:	c5 fe 7f 84 24 a0 02 	vmovdqu YMMWORD PTR [rsp+0x2a0],ymm0
  20b507:	00 00 
        const digit = a % base;
  20b509:	44 89 e0             	mov    eax,r12d
  20b50c:	b9 cd cc cc cc       	mov    ecx,0xcccccccd
  20b511:	48 0f af c1          	imul   rax,rcx
  20b515:	48 c1 e8 23          	shr    rax,0x23
  20b519:	01 c0                	add    eax,eax
  20b51b:	8d 0c 80             	lea    ecx,[rax+rax*4]
  20b51e:	44 89 e0             	mov    eax,r12d
  20b521:	29 c8                	sub    eax,ecx
        0...9 => digit + '0',
  20b523:	b1 30                	mov    cl,0x30
  20b525:	3c 0a                	cmp    al,0xa
  20b527:	72 02                	jb     20b52b <benchmark.add+0xceb>
  20b529:	b1 57                	mov    cl,0x57
  20b52b:	00 c1                	add    cl,al
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  20b52d:	88 8c 24 df 02 00 00 	mov    BYTE PTR [rsp+0x2df],cl
  20b534:	48 8d 84 24 df 02 00 	lea    rax,[rsp+0x2df]
  20b53b:	00 
  20b53c:	b9 01 00 00 00       	mov    ecx,0x1
  20b541:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20b548:	0f 1f 84 00 00 00 00 
  20b54f:	00 
        a /= base;
  20b550:	4c 89 e2             	mov    rdx,r12
  20b553:	48 be cd cc cc cc cc 	movabs rsi,0xcccccccccccccccd
  20b55a:	cc cc cc 
  20b55d:	48 89 f7             	mov    rdi,rsi
  20b560:	c4 e2 cb f6 d7       	mulx   rdx,rsi,rdi
  20b565:	48 c1 ea 03          	shr    rdx,0x3
        const digit = a % base;
  20b569:	c4 e2 cb f6 ff       	mulx   rdi,rsi,rdi
  20b56e:	c1 ef 02             	shr    edi,0x2
  20b571:	81 e7 fe ff ff 3f    	and    edi,0x3ffffffe
  20b577:	8d 3c bf             	lea    edi,[rdi+rdi*4]
  20b57a:	89 d6                	mov    esi,edx
  20b57c:	29 fe                	sub    esi,edi
        0...9 => digit + '0',
  20b57e:	b3 30                	mov    bl,0x30
  20b580:	40 80 fe 0a          	cmp    sil,0xa
  20b584:	72 02                	jb     20b588 <benchmark.add+0xd48>
  20b586:	b3 57                	mov    bl,0x57
  20b588:	40 00 f3             	add    bl,sil
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  20b58b:	88 58 ff             	mov    BYTE PTR [rax-0x1],bl
  20b58e:	48 83 c0 ff          	add    rax,0xffffffffffffffff
        if (a == 0) break;
  20b592:	48 83 c1 01          	add    rcx,0x1
  20b596:	49 83 fc 63          	cmp    r12,0x63
  20b59a:	49 89 d4             	mov    r12,rdx
  20b59d:	77 b1                	ja     20b550 <benchmark.add+0xd10>
        const padded_buf = buf[index - padding ..];
  20b59f:	48 89 84 24 80 00 00 	mov    QWORD PTR [rsp+0x80],rax
  20b5a6:	00 
  20b5a7:	48 89 8c 24 88 00 00 	mov    QWORD PTR [rsp+0x88],rcx
  20b5ae:	00 
        return output(context, padded_buf);
  20b5af:	4c 89 ef             	mov    rdi,r13
  20b5b2:	48 8d b4 24 80 00 00 	lea    rsi,[rsp+0x80]
  20b5b9:	00 
  20b5ba:	48 8b 5c 24 20       	mov    rbx,QWORD PTR [rsp+0x20]
  20b5bf:	c5 f8 77             	vzeroupper 
  20b5c2:	ff d3                	call   rbx
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  20b5c4:	66 85 c0             	test   ax,ax
  20b5c7:	0f 85 13 01 00 00    	jne    20b6e0 <benchmark.add+0xea0>
                        try output(context, fmt[start_index..i]);
  20b5cd:	4c 89 ef             	mov    rdi,r13
  20b5d0:	48 8d 35 c1 a5 03 00 	lea    rsi,[rip+0x3a5c1]        # 245b98 <__unnamed_12>
  20b5d7:	ff d3                	call   rbx
  20b5d9:	66 85 c0             	test   ax,ax
  20b5dc:	0f 85 fe 00 00 00    	jne    20b6e0 <benchmark.add+0xea0>
    var buf: [max_int_digits - 1]u8 = undefined;
  20b5e2:	c5 fc 10 05 d5 de ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffffded5]        # 2094bf <__unnamed_5+0x1f>
  20b5e9:	ff 
  20b5ea:	c5 fc 11 84 24 bf 02 	vmovups YMMWORD PTR [rsp+0x2bf],ymm0
  20b5f1:	00 00 
  20b5f3:	c5 fe 6f 05 a5 de ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffffdea5]        # 2094a0 <__unnamed_5>
  20b5fa:	ff 
  20b5fb:	c5 fe 7f 84 24 a0 02 	vmovdqu YMMWORD PTR [rsp+0x2a0],ymm0
  20b602:	00 00 
        const digit = a % base;
  20b604:	44 89 f0             	mov    eax,r14d
  20b607:	b9 cd cc cc cc       	mov    ecx,0xcccccccd
  20b60c:	48 0f af c8          	imul   rcx,rax
  20b610:	48 c1 e9 23          	shr    rcx,0x23
  20b614:	01 c9                	add    ecx,ecx
  20b616:	8d 0c 89             	lea    ecx,[rcx+rcx*4]
  20b619:	44 89 f0             	mov    eax,r14d
  20b61c:	29 c8                	sub    eax,ecx
        0...9 => digit + '0',
  20b61e:	b1 30                	mov    cl,0x30
  20b620:	3c 0a                	cmp    al,0xa
  20b622:	72 02                	jb     20b626 <benchmark.add+0xde6>
  20b624:	b1 57                	mov    cl,0x57
  20b626:	00 c1                	add    cl,al
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  20b628:	88 8c 24 df 02 00 00 	mov    BYTE PTR [rsp+0x2df],cl
  20b62f:	b8 40 00 00 00       	mov    eax,0x40
        if (a == 0) break;
  20b634:	49 83 fe 0a          	cmp    r14,0xa
  20b638:	73 0a                	jae    20b644 <benchmark.add+0xe04>
  20b63a:	48 8d 8c 24 df 02 00 	lea    rcx,[rsp+0x2df]
  20b641:	00 
  20b642:	eb 5d                	jmp    20b6a1 <benchmark.add+0xe61>
        a /= base;
  20b644:	4c 89 f2             	mov    rdx,r14
  20b647:	48 b9 cd cc cc cc cc 	movabs rcx,0xcccccccccccccccd
  20b64e:	cc cc cc 
  20b651:	48 89 ce             	mov    rsi,rcx
  20b654:	c4 e2 f3 f6 d6       	mulx   rdx,rcx,rsi
  20b659:	48 c1 ea 03          	shr    rdx,0x3
        const digit = a % base;
  20b65d:	c4 e2 f3 f6 f6       	mulx   rsi,rcx,rsi
  20b662:	c1 ee 02             	shr    esi,0x2
  20b665:	81 e6 fe ff ff 3f    	and    esi,0x3ffffffe
  20b66b:	8d 34 b6             	lea    esi,[rsi+rsi*4]
  20b66e:	89 d1                	mov    ecx,edx
  20b670:	29 f1                	sub    ecx,esi
        0...9 => digit + '0',
  20b672:	b3 30                	mov    bl,0x30
  20b674:	80 f9 0a             	cmp    cl,0xa
  20b677:	72 02                	jb     20b67b <benchmark.add+0xe3b>
  20b679:	b3 57                	mov    bl,0x57
  20b67b:	00 cb                	add    bl,cl
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  20b67d:	88 9c 04 9e 02 00 00 	mov    BYTE PTR [rsp+rax*1+0x29e],bl
        if (a == 0) break;
  20b684:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  20b688:	49 83 fe 63          	cmp    r14,0x63
  20b68c:	49 89 d6             	mov    r14,rdx
  20b68f:	77 b3                	ja     20b644 <benchmark.add+0xe04>
        const padded_buf = buf[index - padding ..];
  20b691:	48 8d 0c 04          	lea    rcx,[rsp+rax*1]
  20b695:	48 81 c1 9f 02 00 00 	add    rcx,0x29f
  20b69c:	48 8b 5c 24 20       	mov    rbx,QWORD PTR [rsp+0x20]
  20b6a1:	ba 41 00 00 00       	mov    edx,0x41
  20b6a6:	48 29 c2             	sub    rdx,rax
  20b6a9:	48 89 8c 24 80 00 00 	mov    QWORD PTR [rsp+0x80],rcx
  20b6b0:	00 
  20b6b1:	48 89 94 24 88 00 00 	mov    QWORD PTR [rsp+0x88],rdx
  20b6b8:	00 
        return output(context, padded_buf);
  20b6b9:	4c 89 ef             	mov    rdi,r13
  20b6bc:	48 8d b4 24 80 00 00 	lea    rsi,[rsp+0x80]
  20b6c3:	00 
  20b6c4:	c5 f8 77             	vzeroupper 
  20b6c7:	ff d3                	call   rbx
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  20b6c9:	66 85 c0             	test   ax,ax
  20b6cc:	75 12                	jne    20b6e0 <benchmark.add+0xea0>
        try output(context, fmt[start_index..]);
  20b6ce:	4c 89 ef             	mov    rdi,r13
  20b6d1:	48 8d 35 d0 a4 03 00 	lea    rsi,[rip+0x3a4d0]        # 245ba8 <__unnamed_13>
  20b6d8:	ff d3                	call   rbx
  20b6da:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20b6e0:	31 c0                	xor    eax,eax
  20b6e2:	86 05 28 a9 03 00    	xchg   BYTE PTR [rip+0x3a928],al        # 246010 <stderr_mutex>
  20b6e8:	3c 01                	cmp    al,0x1
    if (!ok) {
  20b6ea:	0f 85 e6 8e 00 00    	jne    2145d6 <benchmark.add+0x9d96>
            while (iterations <= pSelf.max_iterations) {
  20b6f0:	48 8b b4 24 e0 01 00 	mov    rsi,QWORD PTR [rsp+0x1e0]
  20b6f7:	00 
  20b6f8:	c5 f9 10 0d 10 4c ff 	vmovupd xmm1,XMMWORD PTR [rip+0xffffffffffff4c10]        # 200310 <__unnamed_18>
  20b6ff:	ff 
  20b700:	49 39 f7             	cmp    r15,rsi
  20b703:	4c 8d a4 24 a0 02 00 	lea    r12,[rsp+0x2a0]
  20b70a:	00 
  20b70b:	0f 86 5f f8 ff ff    	jbe    20af70 <benchmark.add+0x730>
  20b711:	e9 cd f7 ff ff       	jmp    20aee3 <benchmark.add+0x6a3>
                    try pSelf.results.append(Result { .run_time_ns = run_time_ns, .iterations = iterations});
  20b716:	48 89 9c 24 70 02 00 	mov    QWORD PTR [rsp+0x270],rbx
  20b71d:	00 
  20b71e:	4c 89 bc 24 78 02 00 	mov    QWORD PTR [rsp+0x278],r15
  20b725:	00 
  20b726:	48 8d bc 24 e8 01 00 	lea    rdi,[rsp+0x1e8]
  20b72d:	00 
  20b72e:	48 8d b4 24 70 02 00 	lea    rsi,[rsp+0x270]
  20b735:	00 
  20b736:	e8 65 a7 00 00       	call   215ea0 <AlignedArrayList(Result,8)_append>
  20b73b:	66 85 c0             	test   ax,ax
  20b73e:	0f 84 9f f7 ff ff    	je     20aee3 <benchmark.add+0x6a3>
  20b744:	eb 18                	jmp    20b75e <benchmark.add+0xf1e>
  20b746:	c5 f9 10 0d c2 4b ff 	vmovupd xmm1,XMMWORD PTR [rip+0xffffffffffff4bc2]        # 200310 <__unnamed_18>
  20b74d:	ff 
  20b74e:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
  20b754:	0f 82 1f f6 ff ff    	jb     20ad79 <benchmark.add+0x539>
  20b75a:	66 b8 03 00          	mov    ax,0x3

    // Since this is a test print a \n before we run
    warn("\n");

    // Run the benchmark
    try bf.run(BmAdd);
  20b75e:	48 8d 65 d8          	lea    rsp,[rbp-0x28]
  20b762:	5b                   	pop    rbx
  20b763:	41 5c                	pop    r12
  20b765:	41 5d                	pop    r13
  20b767:	41 5e                	pop    r14
  20b769:	41 5f                	pop    r15
  20b76b:	5d                   	pop    rbp
  20b76c:	c3                   	ret    
        pub fn deinit(self: Self) void {
            self.allocator.free(self.items);
        }

        pub fn toSlice(self: Self) []align(A) T {
            return self.items[0..self.len];
  20b76d:	48 8b 9c 24 e8 01 00 	mov    rbx,QWORD PTR [rsp+0x1e8]
  20b774:	00 
  20b775:	4c 8b b4 24 f8 01 00 	mov    r14,QWORD PTR [rsp+0x1f8]
  20b77c:	00 
        for (results.toSlice()) |result, i| {
  20b77d:	4d 85 f6             	test   r14,r14
  20b780:	74 3d                	je     20b7bf <benchmark.add+0xf7f>
  20b782:	49 8d 4e ff          	lea    rcx,[r14-0x1]
  20b786:	44 89 f0             	mov    eax,r14d
  20b789:	83 e0 07             	and    eax,0x7
  20b78c:	48 83 f9 07          	cmp    rcx,0x7
  20b790:	73 36                	jae    20b7c8 <benchmark.add+0xf88>
  20b792:	c5 c9 57 f6          	vxorpd xmm6,xmm6,xmm6
  20b796:	31 c9                	xor    ecx,ecx
  20b798:	48 85 c0             	test   rax,rax
  20b79b:	0f 85 0c 01 00 00    	jne    20b8ad <benchmark.add+0x106d>
  20b7a1:	e9 4a 01 00 00       	jmp    20b8f0 <benchmark.add+0x10b0>
  20b7a6:	c5 f9 10 0d 62 4b ff 	vmovupd xmm1,XMMWORD PTR [rip+0xffffffffffff4b62]        # 200310 <__unnamed_18>
  20b7ad:	ff 
  20b7ae:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
  20b7b4:	0f 82 2a f6 ff ff    	jb     20ade4 <benchmark.add+0x5a4>
  20b7ba:	e9 17 8e 00 00       	jmp    2145d6 <benchmark.add+0x9d96>
  20b7bf:	c5 c9 57 f6          	vxorpd xmm6,xmm6,xmm6
  20b7c3:	e9 28 01 00 00       	jmp    20b8f0 <benchmark.add+0x10b0>
  20b7c8:	4c 89 f2             	mov    rdx,r14
  20b7cb:	48 29 c2             	sub    rdx,rax
  20b7ce:	48 8d 73 70          	lea    rsi,[rbx+0x70]
  20b7d2:	c5 c9 57 f6          	vxorpd xmm6,xmm6,xmm6
  20b7d6:	31 c9                	xor    ecx,ecx
  20b7d8:	c5 f9 28 05 40 4a ff 	vmovapd xmm0,XMMWORD PTR [rip+0xffffffffffff4a40]        # 200220 <__unnamed_103+0x40>
  20b7df:	ff 
  20b7e0:	c5 f9 28 0d 68 4f ff 	vmovapd xmm1,XMMWORD PTR [rip+0xffffffffffff4f68]        # 200750 <__unnamed_586+0x10>
  20b7e7:	ff 
  20b7e8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  20b7ef:	00 
            sum += @intToFloat(f64, result.run_time_ns);
  20b7f0:	c5 fb 10 56 90       	vmovsd xmm2,QWORD PTR [rsi-0x70]
  20b7f5:	c5 e8 14 d0          	vunpcklps xmm2,xmm2,xmm0
  20b7f9:	c5 e9 5c d1          	vsubpd xmm2,xmm2,xmm1
  20b7fd:	c5 e9 7c d2          	vhaddpd xmm2,xmm2,xmm2
  20b801:	c5 fb 10 5e a0       	vmovsd xmm3,QWORD PTR [rsi-0x60]
  20b806:	c5 e0 14 d8          	vunpcklps xmm3,xmm3,xmm0
  20b80a:	c5 e1 5c d9          	vsubpd xmm3,xmm3,xmm1
  20b80e:	c5 e1 7c db          	vhaddpd xmm3,xmm3,xmm3
  20b812:	c5 fb 10 66 b0       	vmovsd xmm4,QWORD PTR [rsi-0x50]
  20b817:	c5 d8 14 e0          	vunpcklps xmm4,xmm4,xmm0
  20b81b:	c5 d9 5c e1          	vsubpd xmm4,xmm4,xmm1
  20b81f:	c5 d9 7c e4          	vhaddpd xmm4,xmm4,xmm4
  20b823:	c5 fb 10 6e c0       	vmovsd xmm5,QWORD PTR [rsi-0x40]
  20b828:	c5 d0 14 e8          	vunpcklps xmm5,xmm5,xmm0
  20b82c:	c5 d1 5c e9          	vsubpd xmm5,xmm5,xmm1
  20b830:	c5 d1 7c ed          	vhaddpd xmm5,xmm5,xmm5
  20b834:	c5 cb 58 d2          	vaddsd xmm2,xmm6,xmm2
  20b838:	c5 fb 10 76 d0       	vmovsd xmm6,QWORD PTR [rsi-0x30]
  20b83d:	c5 c8 14 f0          	vunpcklps xmm6,xmm6,xmm0
  20b841:	c5 c9 5c f1          	vsubpd xmm6,xmm6,xmm1
  20b845:	c5 c9 7c f6          	vhaddpd xmm6,xmm6,xmm6
  20b849:	c5 eb 58 d3          	vaddsd xmm2,xmm2,xmm3
  20b84d:	c5 eb 58 d4          	vaddsd xmm2,xmm2,xmm4
  20b851:	c5 fb 10 5e e0       	vmovsd xmm3,QWORD PTR [rsi-0x20]
  20b856:	c5 e0 14 d8          	vunpcklps xmm3,xmm3,xmm0
  20b85a:	c5 e1 5c d9          	vsubpd xmm3,xmm3,xmm1
  20b85e:	c5 e1 7c db          	vhaddpd xmm3,xmm3,xmm3
  20b862:	c5 eb 58 d5          	vaddsd xmm2,xmm2,xmm5
  20b866:	c5 eb 58 d6          	vaddsd xmm2,xmm2,xmm6
  20b86a:	c5 fb 10 66 f0       	vmovsd xmm4,QWORD PTR [rsi-0x10]
  20b86f:	c5 d8 14 e0          	vunpcklps xmm4,xmm4,xmm0
  20b873:	c5 d9 5c e1          	vsubpd xmm4,xmm4,xmm1
  20b877:	c5 d9 7c e4          	vhaddpd xmm4,xmm4,xmm4
  20b87b:	c5 eb 58 d3          	vaddsd xmm2,xmm2,xmm3
  20b87f:	c5 eb 58 d4          	vaddsd xmm2,xmm2,xmm4
  20b883:	c5 fb 10 1e          	vmovsd xmm3,QWORD PTR [rsi]
  20b887:	c5 e0 14 d8          	vunpcklps xmm3,xmm3,xmm0
  20b88b:	c5 e1 5c d9          	vsubpd xmm3,xmm3,xmm1
  20b88f:	c5 e1 7c db          	vhaddpd xmm3,xmm3,xmm3
  20b893:	c5 eb 58 f3          	vaddsd xmm6,xmm2,xmm3
        for (results.toSlice()) |result, i| {
  20b897:	48 83 c1 08          	add    rcx,0x8
  20b89b:	48 83 ee 80          	sub    rsi,0xffffffffffffff80
  20b89f:	48 39 ca             	cmp    rdx,rcx
  20b8a2:	0f 85 48 ff ff ff    	jne    20b7f0 <benchmark.add+0xfb0>
  20b8a8:	48 85 c0             	test   rax,rax
  20b8ab:	74 43                	je     20b8f0 <benchmark.add+0x10b0>
  20b8ad:	48 c1 e1 04          	shl    rcx,0x4
  20b8b1:	48 01 cb             	add    rbx,rcx
  20b8b4:	48 f7 d8             	neg    rax
  20b8b7:	c5 f9 28 05 61 49 ff 	vmovapd xmm0,XMMWORD PTR [rip+0xffffffffffff4961]        # 200220 <__unnamed_103+0x40>
  20b8be:	ff 
  20b8bf:	c5 f9 28 0d 89 4e ff 	vmovapd xmm1,XMMWORD PTR [rip+0xffffffffffff4e89]        # 200750 <__unnamed_586+0x10>
  20b8c6:	ff 
  20b8c7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  20b8ce:	00 00 
            sum += @intToFloat(f64, result.run_time_ns);
  20b8d0:	c5 fb 10 13          	vmovsd xmm2,QWORD PTR [rbx]
  20b8d4:	c5 e8 14 d0          	vunpcklps xmm2,xmm2,xmm0
  20b8d8:	c5 e9 5c d1          	vsubpd xmm2,xmm2,xmm1
  20b8dc:	c5 e9 7c d2          	vhaddpd xmm2,xmm2,xmm2
  20b8e0:	c5 cb 58 f2          	vaddsd xmm6,xmm6,xmm2
        for (results.toSlice()) |result, i| {
  20b8e4:	48 83 c3 10          	add    rbx,0x10
  20b8e8:	48 83 c0 01          	add    rax,0x1
  20b8ec:	75 e2                	jne    20b8d0 <benchmark.add+0x1090>
  20b8ee:	66 90                	xchg   ax,ax
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20b8f0:	b0 01                	mov    al,0x1
  20b8f2:	86 05 18 a7 03 00    	xchg   BYTE PTR [rip+0x3a718],al        # 246010 <stderr_mutex>
  20b8f8:	84 c0                	test   al,al
  20b8fa:	75 f4                	jne    20b8f0 <benchmark.add+0x10b0>
    if (stderr_stream) |st| {
  20b8fc:	4c 8b 25 05 a7 03 00 	mov    r12,QWORD PTR [rip+0x3a705]        # 246008 <stderr_stream>
  20b903:	4d 85 e4             	test   r12,r12
  20b906:	c5 fb 11 b4 24 88 01 	vmovsd QWORD PTR [rsp+0x188],xmm6
  20b90d:	00 00 
  20b90f:	74 09                	je     20b91a <benchmark.add+0x10da>
  20b911:	4c 8b 3d 28 67 03 00 	mov    r15,QWORD PTR [rip+0x36728]        # 242040 <stderr_file_out_stream+0x8>
  20b918:	eb 34                	jmp    20b94e <benchmark.add+0x110e>
        stderr_file = try io.getStdErr();
  20b91a:	48 8d 05 0f 67 03 00 	lea    rax,[rip+0x3670f]        # 242030 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20b921:	48 89 05 10 67 03 00 	mov    QWORD PTR [rip+0x36710],rax        # 242038 <stderr_file_out_stream>
  20b928:	4c 8d 3d 21 b0 00 00 	lea    r15,[rip+0xb021]        # 216950 <FileOutStream_writeFn>
  20b92f:	4c 89 3d 0a 67 03 00 	mov    QWORD PTR [rip+0x3670a],r15        # 242040 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  20b936:	c7 05 f0 66 03 00 02 	mov    DWORD PTR [rip+0x366f0],0x2        # 242030 <stderr_file>
  20b93d:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20b940:	4c 8d 25 f9 66 03 00 	lea    r12,[rip+0x366f9]        # 242040 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  20b947:	4c 89 25 ba a6 03 00 	mov    QWORD PTR [rip+0x3a6ba],r12        # 246008 <stderr_stream>
                        try output(context, fmt[start_index..i]);
  20b94e:	48 8d 35 63 a2 03 00 	lea    rsi,[rip+0x3a263]        # 245bb8 <__unnamed_14>
  20b955:	4c 89 e7             	mov    rdi,r12
  20b958:	41 ff d7             	call   r15
  20b95b:	66 85 c0             	test   ax,ax
  20b95e:	0f 85 03 01 00 00    	jne    20ba67 <benchmark.add+0x1227>
    var buf: [max_int_digits - 1]u8 = undefined;
  20b964:	c5 fc 10 05 53 db ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffffdb53]        # 2094bf <__unnamed_5+0x1f>
  20b96b:	ff 
  20b96c:	c5 fc 11 84 24 bf 02 	vmovups YMMWORD PTR [rsp+0x2bf],ymm0
  20b973:	00 00 
  20b975:	c5 fe 6f 05 23 db ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffffdb23]        # 2094a0 <__unnamed_5>
  20b97c:	ff 
  20b97d:	c5 fe 7f 84 24 a0 02 	vmovdqu YMMWORD PTR [rsp+0x2a0],ymm0
  20b984:	00 00 
        const digit = a % base;
  20b986:	48 b8 cd cc cc cc cc 	movabs rax,0xcccccccccccccccd
  20b98d:	cc cc cc 
  20b990:	4c 89 f2             	mov    rdx,r14
  20b993:	c4 e2 f3 f6 d0       	mulx   rdx,rcx,rax
  20b998:	c1 ea 02             	shr    edx,0x2
  20b99b:	81 e2 fe ff ff 3f    	and    edx,0x3ffffffe
  20b9a1:	8d 14 92             	lea    edx,[rdx+rdx*4]
  20b9a4:	44 89 f1             	mov    ecx,r14d
  20b9a7:	29 d1                	sub    ecx,edx
        0...9 => digit + '0',
  20b9a9:	b2 30                	mov    dl,0x30
  20b9ab:	80 f9 0a             	cmp    cl,0xa
  20b9ae:	72 02                	jb     20b9b2 <benchmark.add+0x1172>
  20b9b0:	b2 57                	mov    dl,0x57
  20b9b2:	00 ca                	add    dl,cl
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  20b9b4:	88 94 24 df 02 00 00 	mov    BYTE PTR [rsp+0x2df],dl
        if (a == 0) break;
  20b9bb:	49 83 fe 0a          	cmp    r14,0xa
  20b9bf:	73 0f                	jae    20b9d0 <benchmark.add+0x1190>
  20b9c1:	48 8d 84 24 df 02 00 	lea    rax,[rsp+0x2df]
  20b9c8:	00 
  20b9c9:	b9 40 00 00 00       	mov    ecx,0x40
  20b9ce:	eb 5c                	jmp    20ba2c <benchmark.add+0x11ec>
  20b9d0:	b9 40 00 00 00       	mov    ecx,0x40
  20b9d5:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20b9dc:	00 00 00 00 
        a /= base;
  20b9e0:	4c 89 f2             	mov    rdx,r14
  20b9e3:	c4 e2 cb f6 d0       	mulx   rdx,rsi,rax
  20b9e8:	48 c1 ea 03          	shr    rdx,0x3
        const digit = a % base;
  20b9ec:	c4 e2 cb f6 f8       	mulx   rdi,rsi,rax
  20b9f1:	c1 ef 02             	shr    edi,0x2
  20b9f4:	81 e7 fe ff ff 3f    	and    edi,0x3ffffffe
  20b9fa:	8d 3c bf             	lea    edi,[rdi+rdi*4]
  20b9fd:	89 d6                	mov    esi,edx
  20b9ff:	29 fe                	sub    esi,edi
        0...9 => digit + '0',
  20ba01:	b3 30                	mov    bl,0x30
  20ba03:	40 80 fe 0a          	cmp    sil,0xa
  20ba07:	72 02                	jb     20ba0b <benchmark.add+0x11cb>
  20ba09:	b3 57                	mov    bl,0x57
  20ba0b:	40 00 f3             	add    bl,sil
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  20ba0e:	88 9c 0c 9e 02 00 00 	mov    BYTE PTR [rsp+rcx*1+0x29e],bl
        if (a == 0) break;
  20ba15:	48 83 c1 ff          	add    rcx,0xffffffffffffffff
  20ba19:	49 83 fe 63          	cmp    r14,0x63
  20ba1d:	49 89 d6             	mov    r14,rdx
  20ba20:	77 be                	ja     20b9e0 <benchmark.add+0x11a0>
        const padded_buf = buf[index - padding ..];
  20ba22:	48 8d 04 0c          	lea    rax,[rsp+rcx*1]
  20ba26:	48 05 9f 02 00 00    	add    rax,0x29f
  20ba2c:	ba 41 00 00 00       	mov    edx,0x41
  20ba31:	48 29 ca             	sub    rdx,rcx
  20ba34:	48 89 84 24 80 00 00 	mov    QWORD PTR [rsp+0x80],rax
  20ba3b:	00 
  20ba3c:	48 89 94 24 88 00 00 	mov    QWORD PTR [rsp+0x88],rdx
  20ba43:	00 
  20ba44:	48 8d b4 24 80 00 00 	lea    rsi,[rsp+0x80]
  20ba4b:	00 
        return output(context, padded_buf);
  20ba4c:	4c 89 e7             	mov    rdi,r12
  20ba4f:	c5 f8 77             	vzeroupper 
  20ba52:	41 ff d7             	call   r15
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  20ba55:	66 85 c0             	test   ax,ax
  20ba58:	75 0d                	jne    20ba67 <benchmark.add+0x1227>
        try output(context, fmt[start_index..]);
  20ba5a:	48 8d 35 67 a1 03 00 	lea    rsi,[rip+0x3a167]        # 245bc8 <__unnamed_15>
  20ba61:	4c 89 e7             	mov    rdi,r12
  20ba64:	41 ff d7             	call   r15
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20ba67:	31 c0                	xor    eax,eax
  20ba69:	86 05 a1 a5 03 00    	xchg   BYTE PTR [rip+0x3a5a1],al        # 246010 <stderr_mutex>
  20ba6f:	3c 01                	cmp    al,0x1
    if (!ok) {
  20ba71:	0f 85 5f 8b 00 00    	jne    2145d6 <benchmark.add+0x9d96>
  20ba77:	48 8b 84 24 e8 01 00 	mov    rax,QWORD PTR [rsp+0x1e8]
  20ba7e:	00 
  20ba7f:	48 8b 9c 24 f8 01 00 	mov    rbx,QWORD PTR [rsp+0x1f8]
  20ba86:	00 
            .run_time_ns = @floatToInt(u64, sum / @intToFloat(f64, results.len)),
  20ba87:	c4 e1 f9 6e c3       	vmovq  xmm0,rbx
  20ba8c:	c5 f9 62 05 8c 47 ff 	vpunpckldq xmm0,xmm0,XMMWORD PTR [rip+0xffffffffffff478c]        # 200220 <__unnamed_103+0x40>
  20ba93:	ff 
  20ba94:	c5 f9 5c 05 b4 4c ff 	vsubpd xmm0,xmm0,XMMWORD PTR [rip+0xffffffffffff4cb4]        # 200750 <__unnamed_586+0x10>
  20ba9b:	ff 
  20ba9c:	c5 f9 7c c0          	vhaddpd xmm0,xmm0,xmm0
  20baa0:	c5 fb 10 8c 24 88 01 	vmovsd xmm1,QWORD PTR [rsp+0x188]
  20baa7:	00 00 
  20baa9:	c5 f3 5e c0          	vdivsd xmm0,xmm1,xmm0
  20baad:	c5 fb 10 15 3b 52 ff 	vmovsd xmm2,QWORD PTR [rip+0xffffffffffff523b]        # 200cf0 <app_mask+0x10>
  20bab4:	ff 
  20bab5:	c5 fb 5c ca          	vsubsd xmm1,xmm0,xmm2
  20bab9:	c4 e1 fb 2c c9       	vcvttsd2si rcx,xmm1
  20babe:	48 8b 70 08          	mov    rsi,QWORD PTR [rax+0x8]
  20bac2:	48 b8 00 00 00 00 00 	movabs rax,0x8000000000000000
  20bac9:	00 00 80 
  20bacc:	c4 e1 fb 2c f8       	vcvttsd2si rdi,xmm0
  20bad1:	48 31 c1             	xor    rcx,rax
  20bad4:	c5 f9 2e c2          	vucomisd xmm0,xmm2
  20bad8:	48 0f 43 f9          	cmovae rdi,rcx
        pSelf.report(Result {
  20badc:	e8 2f a5 00 00       	call   216010 <BenchmarkFramework_report>
  20bae1:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20bae8:	0f 1f 84 00 00 00 00 
  20baef:	00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20baf0:	b0 01                	mov    al,0x1
  20baf2:	86 05 18 a5 03 00    	xchg   BYTE PTR [rip+0x3a518],al        # 246010 <stderr_mutex>
  20baf8:	84 c0                	test   al,al
  20bafa:	75 f4                	jne    20baf0 <benchmark.add+0x12b0>
    if (stderr_stream) |st| {
  20bafc:	4c 8b 35 05 a5 03 00 	mov    r14,QWORD PTR [rip+0x3a505]        # 246008 <stderr_stream>
  20bb03:	4d 85 f6             	test   r14,r14
  20bb06:	74 09                	je     20bb11 <benchmark.add+0x12d1>
  20bb08:	4c 8b 3d 31 65 03 00 	mov    r15,QWORD PTR [rip+0x36531]        # 242040 <stderr_file_out_stream+0x8>
  20bb0f:	eb 34                	jmp    20bb45 <benchmark.add+0x1305>
        stderr_file = try io.getStdErr();
  20bb11:	48 8d 05 18 65 03 00 	lea    rax,[rip+0x36518]        # 242030 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20bb18:	48 89 05 19 65 03 00 	mov    QWORD PTR [rip+0x36519],rax        # 242038 <stderr_file_out_stream>
  20bb1f:	4c 8d 3d 2a ae 00 00 	lea    r15,[rip+0xae2a]        # 216950 <FileOutStream_writeFn>
  20bb26:	4c 89 3d 13 65 03 00 	mov    QWORD PTR [rip+0x36513],r15        # 242040 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  20bb2d:	c7 05 f9 64 03 00 02 	mov    DWORD PTR [rip+0x364f9],0x2        # 242030 <stderr_file>
  20bb34:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20bb37:	4c 8d 35 02 65 03 00 	lea    r14,[rip+0x36502]        # 242040 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  20bb3e:	4c 89 35 c3 a4 03 00 	mov    QWORD PTR [rip+0x3a4c3],r14        # 246008 <stderr_stream>
                        try output(context, fmt[start_index..i]);
  20bb45:	48 8d 35 8c a0 03 00 	lea    rsi,[rip+0x3a08c]        # 245bd8 <__unnamed_16>
  20bb4c:	4c 89 f7             	mov    rdi,r14
  20bb4f:	41 ff d7             	call   r15
  20bb52:	66 85 c0             	test   ax,ax
  20bb55:	0f 85 fc 00 00 00    	jne    20bc57 <benchmark.add+0x1417>
    var buf: [max_int_digits - 1]u8 = undefined;
  20bb5b:	c5 fc 10 05 5c d9 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffffd95c]        # 2094bf <__unnamed_5+0x1f>
  20bb62:	ff 
  20bb63:	c5 fc 11 84 24 bf 02 	vmovups YMMWORD PTR [rsp+0x2bf],ymm0
  20bb6a:	00 00 
  20bb6c:	c5 fd 10 05 2c d9 ff 	vmovupd ymm0,YMMWORD PTR [rip+0xffffffffffffd92c]        # 2094a0 <__unnamed_5>
  20bb73:	ff 
  20bb74:	c5 fd 11 84 24 a0 02 	vmovupd YMMWORD PTR [rsp+0x2a0],ymm0
  20bb7b:	00 00 
        const digit = a % base;
  20bb7d:	48 bf cd cc cc cc cc 	movabs rdi,0xcccccccccccccccd
  20bb84:	cc cc cc 
  20bb87:	48 89 da             	mov    rdx,rbx
  20bb8a:	c4 e2 fb f6 cf       	mulx   rcx,rax,rdi
  20bb8f:	c1 e9 02             	shr    ecx,0x2
  20bb92:	81 e1 fe ff ff 3f    	and    ecx,0x3ffffffe
  20bb98:	8d 04 89             	lea    eax,[rcx+rcx*4]
  20bb9b:	89 d9                	mov    ecx,ebx
  20bb9d:	29 c1                	sub    ecx,eax
        0...9 => digit + '0',
  20bb9f:	b2 30                	mov    dl,0x30
  20bba1:	80 f9 0a             	cmp    cl,0xa
  20bba4:	72 02                	jb     20bba8 <benchmark.add+0x1368>
  20bba6:	b2 57                	mov    dl,0x57
  20bba8:	00 ca                	add    dl,cl
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  20bbaa:	88 94 24 df 02 00 00 	mov    BYTE PTR [rsp+0x2df],dl
        if (a == 0) break;
  20bbb1:	48 83 fb 0a          	cmp    rbx,0xa
  20bbb5:	73 0f                	jae    20bbc6 <benchmark.add+0x1386>
  20bbb7:	48 8d 84 24 df 02 00 	lea    rax,[rsp+0x2df]
  20bbbe:	00 
  20bbbf:	b9 40 00 00 00       	mov    ecx,0x40
  20bbc4:	eb 56                	jmp    20bc1c <benchmark.add+0x13dc>
  20bbc6:	b9 40 00 00 00       	mov    ecx,0x40
  20bbcb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
        a /= base;
  20bbd0:	48 89 da             	mov    rdx,rbx
  20bbd3:	c4 e2 fb f6 d7       	mulx   rdx,rax,rdi
  20bbd8:	48 c1 ea 03          	shr    rdx,0x3
        const digit = a % base;
  20bbdc:	c4 e2 fb f6 f7       	mulx   rsi,rax,rdi
  20bbe1:	c1 ee 02             	shr    esi,0x2
  20bbe4:	81 e6 fe ff ff 3f    	and    esi,0x3ffffffe
  20bbea:	8d 04 b6             	lea    eax,[rsi+rsi*4]
  20bbed:	89 d6                	mov    esi,edx
  20bbef:	29 c6                	sub    esi,eax
        0...9 => digit + '0',
  20bbf1:	b0 30                	mov    al,0x30
  20bbf3:	40 80 fe 0a          	cmp    sil,0xa
  20bbf7:	72 02                	jb     20bbfb <benchmark.add+0x13bb>
  20bbf9:	b0 57                	mov    al,0x57
  20bbfb:	40 00 f0             	add    al,sil
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  20bbfe:	88 84 0c 9e 02 00 00 	mov    BYTE PTR [rsp+rcx*1+0x29e],al
        if (a == 0) break;
  20bc05:	48 83 c1 ff          	add    rcx,0xffffffffffffffff
  20bc09:	48 83 fb 63          	cmp    rbx,0x63
  20bc0d:	48 89 d3             	mov    rbx,rdx
  20bc10:	77 be                	ja     20bbd0 <benchmark.add+0x1390>
        const padded_buf = buf[index - padding ..];
  20bc12:	48 8d 04 0c          	lea    rax,[rsp+rcx*1]
  20bc16:	48 05 9f 02 00 00    	add    rax,0x29f
  20bc1c:	ba 41 00 00 00       	mov    edx,0x41
  20bc21:	48 29 ca             	sub    rdx,rcx
  20bc24:	48 89 84 24 80 00 00 	mov    QWORD PTR [rsp+0x80],rax
  20bc2b:	00 
  20bc2c:	48 89 94 24 88 00 00 	mov    QWORD PTR [rsp+0x88],rdx
  20bc33:	00 
  20bc34:	48 8d b4 24 80 00 00 	lea    rsi,[rsp+0x80]
  20bc3b:	00 
        return output(context, padded_buf);
  20bc3c:	4c 89 f7             	mov    rdi,r14
  20bc3f:	c5 f8 77             	vzeroupper 
  20bc42:	41 ff d7             	call   r15
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  20bc45:	66 85 c0             	test   ax,ax
  20bc48:	75 0d                	jne    20bc57 <benchmark.add+0x1417>
        try output(context, fmt[start_index..]);
  20bc4a:	48 8d 35 97 9f 03 00 	lea    rsi,[rip+0x39f97]        # 245be8 <__unnamed_17>
  20bc51:	4c 89 f7             	mov    rdi,r14
  20bc54:	41 ff d7             	call   r15
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20bc57:	31 c0                	xor    eax,eax
  20bc59:	86 05 b1 a3 03 00    	xchg   BYTE PTR [rip+0x3a3b1],al        # 246010 <stderr_mutex>
  20bc5f:	3c 01                	cmp    al,0x1
    if (!ok) {
  20bc61:	0f 85 6f 89 00 00    	jne    2145d6 <benchmark.add+0x9d96>
        if (results.len < 3) {
  20bc67:	4c 8b a4 24 f8 01 00 	mov    r12,QWORD PTR [rsp+0x1f8]
  20bc6e:	00 
  20bc6f:	49 83 fc 02          	cmp    r12,0x2
  20bc73:	77 6b                	ja     20bce0 <benchmark.add+0x14a0>
            .run_time_ns = @floatToInt(u64, sum / @intToFloat(f64, results.len)),
  20bc75:	c4 c1 f9 6e c4       	vmovq  xmm0,r12
  20bc7a:	c5 f9 62 05 9e 45 ff 	vpunpckldq xmm0,xmm0,XMMWORD PTR [rip+0xffffffffffff459e]        # 200220 <__unnamed_103+0x40>
  20bc81:	ff 
  20bc82:	c5 f9 5c 05 c6 4a ff 	vsubpd xmm0,xmm0,XMMWORD PTR [rip+0xffffffffffff4ac6]        # 200750 <__unnamed_586+0x10>
  20bc89:	ff 
  20bc8a:	c5 f9 7c c0          	vhaddpd xmm0,xmm0,xmm0
  20bc8e:	48 8b 84 24 e8 01 00 	mov    rax,QWORD PTR [rsp+0x1e8]
  20bc95:	00 
  20bc96:	48 8b 70 08          	mov    rsi,QWORD PTR [rax+0x8]
  20bc9a:	c5 fb 10 8c 24 88 01 	vmovsd xmm1,QWORD PTR [rsp+0x188]
  20bca1:	00 00 
  20bca3:	c5 f3 5e c0          	vdivsd xmm0,xmm1,xmm0
  20bca7:	c5 fb 10 0d 41 50 ff 	vmovsd xmm1,QWORD PTR [rip+0xffffffffffff5041]        # 200cf0 <app_mask+0x10>
  20bcae:	ff 
  20bcaf:	c5 f9 28 d1          	vmovapd xmm2,xmm1
  20bcb3:	c5 fb 5c ca          	vsubsd xmm1,xmm0,xmm2
  20bcb7:	c4 e1 fb 2c c1       	vcvttsd2si rax,xmm1
  20bcbc:	c4 e1 fb 2c f8       	vcvttsd2si rdi,xmm0
  20bcc1:	48 b9 00 00 00 00 00 	movabs rcx,0x8000000000000000
  20bcc8:	00 00 80 
  20bccb:	48 31 c8             	xor    rax,rcx
  20bcce:	c5 f9 2e c2          	vucomisd xmm0,xmm2
  20bcd2:	48 0f 43 f8          	cmovae rdi,rax
        pSelf.report(Result {
  20bcd6:	e8 35 a3 00 00       	call   216010 <BenchmarkFramework_report>
  20bcdb:	e9 c0 85 00 00       	jmp    2142a0 <benchmark.add+0x9a60>
            return Self{
  20bce0:	c5 f9 57 c0          	vxorpd xmm0,xmm0,xmm0
  20bce4:	c5 f9 29 84 24 20 02 	vmovapd XMMWORD PTR [rsp+0x220],xmm0
  20bceb:	00 00 
        var copy = ArrayList(Result).init(pSelf.pAllocator);
  20bced:	48 8b 84 24 08 02 00 	mov    rax,QWORD PTR [rsp+0x208]
  20bcf4:	00 
  20bcf5:	48 c7 84 24 30 02 00 	mov    QWORD PTR [rsp+0x230],0x0
  20bcfc:	00 00 00 00 00 
  20bd01:	48 89 84 24 38 02 00 	mov    QWORD PTR [rsp+0x238],rax
  20bd08:	00 
        for (results.toSlice()) |result| {
  20bd09:	c5 fa 6f 05 ff 45 ff 	vmovdqu xmm0,XMMWORD PTR [rip+0xffffffffffff45ff]        # 200310 <__unnamed_18>
  20bd10:	ff 
  20bd11:	c5 f9 7f 84 24 60 02 	vmovdqa XMMWORD PTR [rsp+0x260],xmm0
  20bd18:	00 00 
            return self.items[0..self.len];
  20bd1a:	4c 8b ac 24 e8 01 00 	mov    r13,QWORD PTR [rsp+0x1e8]
  20bd21:	00 
  20bd22:	31 db                	xor    ebx,ebx
  20bd24:	4c 8d b4 24 20 02 00 	lea    r14,[rsp+0x220]
  20bd2b:	00 
  20bd2c:	4c 8d bc 24 60 02 00 	lea    r15,[rsp+0x260]
  20bd33:	00 
  20bd34:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20bd3b:	00 00 00 00 00 
  20bd40:	c4 c1 7a 6f 45 00    	vmovdqu xmm0,XMMWORD PTR [r13+0x0]
  20bd46:	c5 f9 7f 84 24 60 02 	vmovdqa XMMWORD PTR [rsp+0x260],xmm0
  20bd4d:	00 00 
            try copy.append(result);
  20bd4f:	4c 89 f7             	mov    rdi,r14
  20bd52:	4c 89 fe             	mov    rsi,r15
  20bd55:	e8 46 a1 00 00       	call   215ea0 <AlignedArrayList(Result,8)_append>
  20bd5a:	66 85 c0             	test   ax,ax
  20bd5d:	0f 85 fb f9 ff ff    	jne    20b75e <benchmark.add+0xf1e>
  20bd63:	48 83 c3 01          	add    rbx,0x1
        for (results.toSlice()) |result| {
  20bd67:	49 83 c5 10          	add    r13,0x10
  20bd6b:	4c 39 e3             	cmp    rbx,r12
  20bd6e:	72 d0                	jb     20bd40 <benchmark.add+0x1500>
  20bd70:	48 8b 9c 24 20 02 00 	mov    rbx,QWORD PTR [rsp+0x220]
  20bd77:	00 
  20bd78:	4c 8b b4 24 30 02 00 	mov    r14,QWORD PTR [rsp+0x230]
  20bd7f:	00 
  20bd80:	48 89 5c 24 48       	mov    QWORD PTR [rsp+0x48],rbx
  20bd85:	4c 89 74 24 50       	mov    QWORD PTR [rsp+0x50],r14

/// Stable in-place sort. O(n) best case, O(n*log(n)) worst case and average case. O(1) memory (no allocator required).
/// Currently implemented as block sort.
pub fn sort(comptime T: type, items: []T, lessThan: fn (lhs: T, rhs: T) bool) void {
    // Implementation ported from https://github.com/BonzaiThePenguin/WikiSort/blob/master/WikiSort.c
    var cache: [512]T = undefined;
  20bd8a:	48 8d 35 5f a0 ff ff 	lea    rsi,[rip+0xffffffffffffa05f]        # 205df0 <__unnamed_19>
  20bd91:	48 8d bc 24 a0 02 00 	lea    rdi,[rsp+0x2a0]
  20bd98:	00 
  20bd99:	ba 00 20 00 00       	mov    edx,0x2000
  20bd9e:	e8 3d 99 01 00       	call   2256e0 <memcpy>

    if (items.len < 4) {
  20bda3:	49 83 fe 03          	cmp    r14,0x3
  20bda7:	0f 87 96 00 00 00    	ja     20be43 <benchmark.add+0x1603>
        if (items.len == 3) {
  20bdad:	49 83 fe 02          	cmp    r14,0x2
  20bdb1:	0f 84 f5 83 00 00    	je     2141ac <benchmark.add+0x996c>
  20bdb7:	49 83 fe 03          	cmp    r14,0x3
  20bdbb:	0f 85 1a 84 00 00    	jne    2141db <benchmark.add+0x999b>
            // hard coded insertion sort
            if (lessThan(items[1], items[0])) mem.swap(T, &items[0], &items[1]);
  20bdc1:	48 8d 43 10          	lea    rax,[rbx+0x10]
  20bdc5:	48 8b 4b 10          	mov    rcx,QWORD PTR [rbx+0x10]
            return lhs.run_time_ns < rhs.run_time_ns;
  20bdc9:	48 3b 0b             	cmp    rcx,QWORD PTR [rbx]
  20bdcc:	73 26                	jae    20bdf4 <benchmark.add+0x15b4>
test "mem.max" {
    assert(max(u8, "abcdefg") == 'g');
}

pub fn swap(comptime T: type, a: *T, b: *T) void {
    const tmp = a.*;
  20bdce:	c5 f8 10 03          	vmovups xmm0,XMMWORD PTR [rbx]
  20bdd2:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  20bdd9:	00 00 
    a.* = b.*;
  20bddb:	c5 f8 10 00          	vmovups xmm0,XMMWORD PTR [rax]
  20bddf:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
    b.* = tmp;
  20bde3:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  20bdea:	00 00 
  20bdec:	c5 fa 7f 00          	vmovdqu XMMWORD PTR [rax],xmm0
  20bdf0:	48 8b 4b 10          	mov    rcx,QWORD PTR [rbx+0x10]
  20bdf4:	48 39 4b 20          	cmp    QWORD PTR [rbx+0x20],rcx
            if (lessThan(items[2], items[1])) {
  20bdf8:	0f 83 dd 83 00 00    	jae    2141db <benchmark.add+0x999b>
    const tmp = a.*;
  20bdfe:	c5 f8 10 00          	vmovups xmm0,XMMWORD PTR [rax]
  20be02:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  20be09:	00 00 
  20be0b:	48 8d 4b 20          	lea    rcx,[rbx+0x20]
    a.* = b.*;
  20be0f:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  20be13:	c5 f8 11 00          	vmovups XMMWORD PTR [rax],xmm0
    b.* = tmp;
  20be17:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  20be1e:	00 00 
  20be20:	c5 fa 7f 01          	vmovdqu XMMWORD PTR [rcx],xmm0
  20be24:	48 8b 4b 10          	mov    rcx,QWORD PTR [rbx+0x10]
  20be28:	48 3b 0b             	cmp    rcx,QWORD PTR [rbx]
                mem.swap(T, &items[1], &items[2]);
                if (lessThan(items[1], items[0])) mem.swap(T, &items[0], &items[1]);
  20be2b:	0f 83 aa 83 00 00    	jae    2141db <benchmark.add+0x999b>
    const tmp = a.*;
  20be31:	c5 f8 10 03          	vmovups xmm0,XMMWORD PTR [rbx]
  20be35:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  20be3c:	00 00 
  20be3e:	e9 83 83 00 00       	jmp    2141c6 <benchmark.add+0x9986>
pub fn floorPowerOfTwo(comptime T: type, value: T) T {
    var x = value;

    comptime var i = 1;
    inline while (T.bit_count > i) : (i *= 2) {
        x |= (x >> i);
  20be43:	4c 89 f0             	mov    rax,r14
  20be46:	48 d1 e8             	shr    rax,1
  20be49:	4c 09 f0             	or     rax,r14
  20be4c:	48 89 c1             	mov    rcx,rax
  20be4f:	48 c1 e9 02          	shr    rcx,0x2
  20be53:	48 09 c1             	or     rcx,rax
  20be56:	48 89 c8             	mov    rax,rcx
  20be59:	48 c1 e8 04          	shr    rax,0x4
  20be5d:	48 09 c8             	or     rax,rcx
  20be60:	48 89 c1             	mov    rcx,rax
  20be63:	48 c1 e9 08          	shr    rcx,0x8
  20be67:	48 09 c1             	or     rcx,rax
  20be6a:	48 89 c8             	mov    rax,rcx
  20be6d:	48 c1 e8 10          	shr    rax,0x10
  20be71:	48 09 c8             	or     rax,rcx
  20be74:	48 89 c6             	mov    rsi,rax
  20be77:	48 c1 ee 20          	shr    rsi,0x20
  20be7b:	48 09 c6             	or     rsi,rax
    }

    return x - (x >> 1);
  20be7e:	48 89 f0             	mov    rax,rsi
  20be81:	48 d1 e8             	shr    rax,1
  20be84:	48 29 c6             	sub    rsi,rax
        const denominator = power_of_two / min_level;
  20be87:	48 c1 ee 02          	shr    rsi,0x2
  20be8b:	4c 89 f0             	mov    rax,r14
  20be8e:	48 09 f0             	or     rax,rsi
  20be91:	48 c1 e8 20          	shr    rax,0x20
  20be95:	74 13                	je     20beaa <benchmark.add+0x166a>
  20be97:	31 d2                	xor    edx,edx
  20be99:	4c 89 f0             	mov    rax,r14
  20be9c:	48 f7 f6             	div    rsi
  20be9f:	eb 10                	jmp    20beb1 <benchmark.add+0x1671>
  20bea1:	66 b8 05 00          	mov    ax,0x5
  20bea5:	e9 b4 f8 ff ff       	jmp    20b75e <benchmark.add+0xf1e>
  20beaa:	31 d2                	xor    edx,edx
  20beac:	44 89 f0             	mov    eax,r14d
  20beaf:	f7 f6                	div    esi
  20beb1:	4c 89 b4 24 50 01 00 	mov    QWORD PTR [rsp+0x150],r14
  20beb8:	00 
  20beb9:	31 ff                	xor    edi,edi
  20bebb:	45 31 ff             	xor    r15d,r15d
  20bebe:	48 89 b4 24 38 01 00 	mov    QWORD PTR [rsp+0x138],rsi
  20bec5:	00 
  20bec6:	48 89 84 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],rax
  20becd:	00 
  20bece:	48 89 94 24 30 01 00 	mov    QWORD PTR [rsp+0x130],rdx
  20bed5:	00 
  20bed6:	eb 2b                	jmp    20bf03 <benchmark.add+0x16c3>
  20bed8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  20bedf:	00 
  20bee0:	4d 29 ef             	sub    r15,r13
    var iterator = Iterator.init(items.len, 4);
    while (!iterator.finished()) {
        var order = []u8{ 0, 1, 2, 3, 4, 5, 6, 7 };
        const range = iterator.nextRange();

        const sliced_items = items[range.start..];
  20bee3:	48 8b 5c 24 48       	mov    rbx,QWORD PTR [rsp+0x48]
  20bee8:	4c 89 d7             	mov    rdi,r10
  20beeb:	48 8b b4 24 38 01 00 	mov    rsi,QWORD PTR [rsp+0x138]
  20bef2:	00 
  20bef3:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  20befa:	00 
  20befb:	48 8b 94 24 30 01 00 	mov    rdx,QWORD PTR [rsp+0x130]
  20bf02:	00 
        self.decimal += self.decimal_step;
  20bf03:	48 8d 0c 07          	lea    rcx,[rdi+rax*1]
        self.numerator += self.numerator_step;
  20bf07:	49 01 d7             	add    r15,rdx
        if (self.numerator >= self.denominator) {
  20bf0a:	45 31 d2             	xor    r10d,r10d
  20bf0d:	49 39 f7             	cmp    r15,rsi
  20bf10:	41 0f 93 c2          	setae  r10b
  20bf14:	41 bd 00 00 00 00    	mov    r13d,0x0
  20bf1a:	4c 0f 43 ee          	cmovae r13,rsi
  20bf1e:	49 01 ca             	add    r10,rcx
        return self.end - self.start;
  20bf21:	4c 89 d1             	mov    rcx,r10
  20bf24:	48 29 f9             	sub    rcx,rdi
        switch (range.length()) {
  20bf27:	48 83 c1 fc          	add    rcx,0xfffffffffffffffc
  20bf2b:	48 83 f9 04          	cmp    rcx,0x4
  20bf2f:	0f 87 cb 12 00 00    	ja     20d200 <benchmark.add+0x29c0>
  20bf35:	48 c1 e7 04          	shl    rdi,0x4
  20bf39:	48 01 fb             	add    rbx,rdi
  20bf3c:	48 8d 05 fd 4d ff ff 	lea    rax,[rip+0xffffffffffff4dfd]        # 200d40 <app_mask+0x60>
  20bf43:	48 89 c2             	mov    rdx,rax
  20bf46:	48 63 04 8a          	movsxd rax,DWORD PTR [rdx+rcx*4]
  20bf4a:	48 01 d0             	add    rax,rdx
  20bf4d:	ff e0                	jmp    rax
    // copy the remainder of A into the final array
    mem.copy(T, items[insert_index..], cache[A_index..A_last]);
}

fn swap(comptime T: type, items: []T, lessThan: fn (lhs: T, rhs: T) bool, order: *[8]u8, x: usize, y: usize) void {
    if (lessThan(items[y], items[x]) or ((order.*)[x] > (order.*)[y] and !lessThan(items[x], items[y]))) {
  20bf4f:	48 8d 43 10          	lea    rax,[rbx+0x10]
  20bf53:	48 8b 4b 10          	mov    rcx,QWORD PTR [rbx+0x10]
  20bf57:	48 3b 0b             	cmp    rcx,QWORD PTR [rbx]
  20bf5a:	0f 83 4b 01 00 00    	jae    20c0ab <benchmark.add+0x186b>
  20bf60:	c5 f8 10 03          	vmovups xmm0,XMMWORD PTR [rbx]
  20bf64:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  20bf6b:	00 00 
    a.* = b.*;
  20bf6d:	c5 f8 10 00          	vmovups xmm0,XMMWORD PTR [rax]
  20bf71:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
    b.* = tmp;
  20bf75:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  20bf7c:	00 00 
  20bf7e:	c5 fa 7f 00          	vmovdqu XMMWORD PTR [rax],xmm0
  20bf82:	41 b3 01             	mov    r11b,0x1
  20bf85:	31 f6                	xor    esi,esi
  20bf87:	e9 25 01 00 00       	jmp    20c0b1 <benchmark.add+0x1871>
  20bf8c:	4c 8d 63 10          	lea    r12,[rbx+0x10]
  20bf90:	48 8b 43 10          	mov    rax,QWORD PTR [rbx+0x10]
  20bf94:	48 3b 03             	cmp    rax,QWORD PTR [rbx]
  20bf97:	4c 89 6c 24 20       	mov    QWORD PTR [rsp+0x20],r13
  20bf9c:	0f 83 03 02 00 00    	jae    20c1a5 <benchmark.add+0x1965>
    const tmp = a.*;
  20bfa2:	c5 f8 10 03          	vmovups xmm0,XMMWORD PTR [rbx]
  20bfa6:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  20bfad:	00 00 
    a.* = b.*;
  20bfaf:	c4 c1 78 10 04 24    	vmovups xmm0,XMMWORD PTR [r12]
  20bfb5:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
    b.* = tmp;
  20bfb9:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  20bfc0:	00 00 
  20bfc2:	c4 c1 7a 7f 04 24    	vmovdqu XMMWORD PTR [r12],xmm0
  20bfc8:	b0 01                	mov    al,0x1
  20bfca:	89 44 24 18          	mov    DWORD PTR [rsp+0x18],eax
  20bfce:	45 31 db             	xor    r11d,r11d
  20bfd1:	e9 da 01 00 00       	jmp    20c1b0 <benchmark.add+0x1970>
  20bfd6:	4c 8d 43 20          	lea    r8,[rbx+0x20]
  20bfda:	4c 8d 4b 10          	lea    r9,[rbx+0x10]
  20bfde:	48 8b 43 20          	mov    rax,QWORD PTR [rbx+0x20]
  20bfe2:	48 3b 43 10          	cmp    rax,QWORD PTR [rbx+0x10]
  20bfe6:	0f 83 0d 02 00 00    	jae    20c1f9 <benchmark.add+0x19b9>
    const tmp = a.*;
  20bfec:	c4 c1 78 10 01       	vmovups xmm0,XMMWORD PTR [r9]
  20bff1:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  20bff8:	00 00 
    a.* = b.*;
  20bffa:	c4 c1 78 10 00       	vmovups xmm0,XMMWORD PTR [r8]
  20bfff:	c4 c1 78 11 01       	vmovups XMMWORD PTR [r9],xmm0
    b.* = tmp;
  20c004:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  20c00b:	00 00 
  20c00d:	c4 c1 7a 7f 00       	vmovdqu XMMWORD PTR [r8],xmm0
  20c012:	41 b6 02             	mov    r14b,0x2
  20c015:	41 b3 01             	mov    r11b,0x1
  20c018:	e9 e2 01 00 00       	jmp    20c1ff <benchmark.add+0x19bf>
  20c01d:	4c 89 7c 24 60       	mov    QWORD PTR [rsp+0x60],r15
  20c022:	48 8d 7b 20          	lea    rdi,[rbx+0x20]
  20c026:	4c 8d 7b 10          	lea    r15,[rbx+0x10]
  20c02a:	48 8b 43 20          	mov    rax,QWORD PTR [rbx+0x20]
  20c02e:	48 3b 43 10          	cmp    rax,QWORD PTR [rbx+0x10]
  20c032:	0f 83 21 02 00 00    	jae    20c259 <benchmark.add+0x1a19>
    const tmp = a.*;
  20c038:	c4 c1 78 10 07       	vmovups xmm0,XMMWORD PTR [r15]
  20c03d:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  20c044:	00 00 
    a.* = b.*;
  20c046:	c5 f8 10 07          	vmovups xmm0,XMMWORD PTR [rdi]
  20c04a:	c4 c1 78 11 07       	vmovups XMMWORD PTR [r15],xmm0
    b.* = tmp;
  20c04f:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  20c056:	00 00 
  20c058:	c5 fa 7f 07          	vmovdqu XMMWORD PTR [rdi],xmm0
  20c05c:	b0 02                	mov    al,0x2
  20c05e:	41 b4 01             	mov    r12b,0x1
  20c061:	e9 f8 01 00 00       	jmp    20c25e <benchmark.add+0x1a1e>
  20c066:	4c 8d 63 10          	lea    r12,[rbx+0x10]
  20c06a:	48 8b 43 10          	mov    rax,QWORD PTR [rbx+0x10]
  20c06e:	48 3b 03             	cmp    rax,QWORD PTR [rbx]
  20c071:	0f 83 31 02 00 00    	jae    20c2a8 <benchmark.add+0x1a68>
    const tmp = a.*;
  20c077:	c5 f8 10 03          	vmovups xmm0,XMMWORD PTR [rbx]
  20c07b:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  20c082:	00 00 
    a.* = b.*;
  20c084:	c4 c1 78 10 04 24    	vmovups xmm0,XMMWORD PTR [r12]
  20c08a:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
    b.* = tmp;
  20c08e:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  20c095:	00 00 
  20c097:	c4 c1 7a 7f 04 24    	vmovdqu XMMWORD PTR [r12],xmm0
  20c09d:	b0 01                	mov    al,0x1
  20c09f:	89 44 24 18          	mov    DWORD PTR [rsp+0x18],eax
  20c0a3:	45 31 c9             	xor    r9d,r9d
  20c0a6:	e9 08 02 00 00       	jmp    20c2b3 <benchmark.add+0x1a73>
  20c0ab:	40 b6 01             	mov    sil,0x1
  20c0ae:	45 31 db             	xor    r11d,r11d
  20c0b1:	48 8d 53 30          	lea    rdx,[rbx+0x30]
  20c0b5:	48 8d 4b 20          	lea    rcx,[rbx+0x20]
  20c0b9:	48 8b 7b 20          	mov    rdi,QWORD PTR [rbx+0x20]
  20c0bd:	48 39 7b 30          	cmp    QWORD PTR [rbx+0x30],rdi
  20c0c1:	0f 83 38 02 00 00    	jae    20c2ff <benchmark.add+0x1abf>
    const tmp = a.*;
  20c0c7:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  20c0cb:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  20c0d2:	00 00 
    a.* = b.*;
  20c0d4:	c5 f8 10 02          	vmovups xmm0,XMMWORD PTR [rdx]
  20c0d8:	c5 f8 11 01          	vmovups XMMWORD PTR [rcx],xmm0
    b.* = tmp;
  20c0dc:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  20c0e3:	00 00 
  20c0e5:	c5 fa 7f 02          	vmovdqu XMMWORD PTR [rdx],xmm0
  20c0e9:	48 8b 39             	mov    rdi,QWORD PTR [rcx]
  20c0ec:	41 b0 03             	mov    r8b,0x3
  20c0ef:	41 b1 02             	mov    r9b,0x2
  20c0f2:	48 3b 3b             	cmp    rdi,QWORD PTR [rbx]
  20c0f5:	73 25                	jae    20c11c <benchmark.add+0x18dc>
    const tmp = a.*;
  20c0f7:	c5 f8 10 03          	vmovups xmm0,XMMWORD PTR [rbx]
  20c0fb:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  20c102:	00 00 
    a.* = b.*;
  20c104:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  20c108:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
    b.* = tmp;
  20c10c:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  20c113:	00 00 
  20c115:	c5 fa 7f 01          	vmovdqu XMMWORD PTR [rcx],xmm0
  20c119:	45 89 d8             	mov    r8d,r11d
  20c11c:	48 8b 38             	mov    rdi,QWORD PTR [rax]
  20c11f:	48 39 3a             	cmp    QWORD PTR [rdx],rdi
  20c122:	73 32                	jae    20c156 <benchmark.add+0x1916>
    const tmp = a.*;
  20c124:	c5 f8 10 00          	vmovups xmm0,XMMWORD PTR [rax]
  20c128:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  20c12f:	00 00 
    a.* = b.*;
  20c131:	c5 f8 10 02          	vmovups xmm0,XMMWORD PTR [rdx]
  20c135:	c5 f8 11 00          	vmovups XMMWORD PTR [rax],xmm0
    b.* = tmp;
  20c139:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  20c140:	00 00 
  20c142:	c5 fa 7f 02          	vmovdqu XMMWORD PTR [rdx],xmm0
  20c146:	48 8b 38             	mov    rdi,QWORD PTR [rax]
  20c149:	44 89 ce             	mov    esi,r9d
  20c14c:	48 8b 11             	mov    rdx,QWORD PTR [rcx]
  20c14f:	48 39 fa             	cmp    rdx,rdi
  20c152:	72 1c                	jb     20c170 <benchmark.add+0x1930>
  20c154:	eb 08                	jmp    20c15e <benchmark.add+0x191e>
  20c156:	48 8b 11             	mov    rdx,QWORD PTR [rcx]
  20c159:	48 39 fa             	cmp    rdx,rdi
  20c15c:	72 12                	jb     20c170 <benchmark.add+0x1930>
  20c15e:	44 38 c6             	cmp    sil,r8b
  20c161:	0f 86 99 10 00 00    	jbe    20d200 <benchmark.add+0x29c0>
  20c167:	48 39 d7             	cmp    rdi,rdx
  20c16a:	0f 82 90 10 00 00    	jb     20d200 <benchmark.add+0x29c0>
    const tmp = a.*;
  20c170:	c5 f8 10 00          	vmovups xmm0,XMMWORD PTR [rax]
  20c174:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  20c17b:	00 00 
    a.* = b.*;
  20c17d:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  20c181:	c5 f8 11 00          	vmovups XMMWORD PTR [rax],xmm0
    b.* = tmp;
  20c185:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  20c18c:	00 00 
  20c18e:	c5 fa 7f 01          	vmovdqu XMMWORD PTR [rcx],xmm0
        return self.decimal >= self.size;
  20c192:	4c 3b 94 24 50 01 00 	cmp    r10,QWORD PTR [rsp+0x150]
  20c199:	00 
  20c19a:	0f 82 40 fd ff ff    	jb     20bee0 <benchmark.add+0x16a0>
  20c1a0:	e9 9a 10 00 00       	jmp    20d23f <benchmark.add+0x29ff>
  20c1a5:	41 b3 01             	mov    r11b,0x1
  20c1a8:	c7 44 24 18 00 00 00 	mov    DWORD PTR [rsp+0x18],0x0
  20c1af:	00 
    if (lessThan(items[y], items[x]) or ((order.*)[x] > (order.*)[y] and !lessThan(items[x], items[y]))) {
  20c1b0:	48 8d 73 40          	lea    rsi,[rbx+0x40]
  20c1b4:	4c 8d 6b 30          	lea    r13,[rbx+0x30]
  20c1b8:	48 8b 4b 40          	mov    rcx,QWORD PTR [rbx+0x40]
  20c1bc:	48 3b 4b 30          	cmp    rcx,QWORD PTR [rbx+0x30]
  20c1c0:	0f 83 4d 01 00 00    	jae    20c313 <benchmark.add+0x1ad3>
    const tmp = a.*;
  20c1c6:	c4 c1 78 10 45 00    	vmovups xmm0,XMMWORD PTR [r13+0x0]
  20c1cc:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  20c1d3:	00 00 
    a.* = b.*;
  20c1d5:	c5 f8 10 06          	vmovups xmm0,XMMWORD PTR [rsi]
  20c1d9:	c4 c1 78 11 45 00    	vmovups XMMWORD PTR [r13+0x0],xmm0
    b.* = tmp;
  20c1df:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  20c1e6:	00 00 
  20c1e8:	c5 fa 7f 06          	vmovdqu XMMWORD PTR [rsi],xmm0
  20c1ec:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  20c1ef:	41 b1 04             	mov    r9b,0x4
  20c1f2:	b2 03                	mov    dl,0x3
  20c1f4:	e9 1f 01 00 00       	jmp    20c318 <benchmark.add+0x1ad8>
  20c1f9:	41 b6 01             	mov    r14b,0x1
  20c1fc:	41 b3 02             	mov    r11b,0x2
  20c1ff:	48 8d 4b 50          	lea    rcx,[rbx+0x50]
  20c203:	48 8d 7b 40          	lea    rdi,[rbx+0x40]
  20c207:	48 8b 43 50          	mov    rax,QWORD PTR [rbx+0x50]
  20c20b:	48 3b 43 40          	cmp    rax,QWORD PTR [rbx+0x40]
  20c20f:	0f 83 51 01 00 00    	jae    20c366 <benchmark.add+0x1b26>
    const tmp = a.*;
  20c215:	c5 f8 10 07          	vmovups xmm0,XMMWORD PTR [rdi]
  20c219:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  20c220:	00 00 
    a.* = b.*;
  20c222:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  20c226:	c5 f8 11 07          	vmovups XMMWORD PTR [rdi],xmm0
    b.* = tmp;
  20c22a:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  20c231:	00 00 
  20c233:	c5 fa 7f 01          	vmovdqu XMMWORD PTR [rcx],xmm0
  20c237:	c6 44 24 10 05       	mov    BYTE PTR [rsp+0x10],0x5
  20c23c:	41 b4 04             	mov    r12b,0x4
  20c23f:	48 8b 43 20          	mov    rax,QWORD PTR [rbx+0x20]
  20c243:	48 3b 03             	cmp    rax,QWORD PTR [rbx]
  20c246:	0f 82 2f 01 00 00    	jb     20c37b <benchmark.add+0x1b3b>
  20c24c:	c7 44 24 18 00 00 00 	mov    DWORD PTR [rsp+0x18],0x0
  20c253:	00 
  20c254:	e9 4e 01 00 00       	jmp    20c3a7 <benchmark.add+0x1b67>
  20c259:	b0 01                	mov    al,0x1
  20c25b:	41 b4 02             	mov    r12b,0x2
  20c25e:	88 44 24 38          	mov    BYTE PTR [rsp+0x38],al
  20c262:	4c 8d 5b 40          	lea    r11,[rbx+0x40]
  20c266:	4c 8d 4b 30          	lea    r9,[rbx+0x30]
  20c26a:	48 8b 43 40          	mov    rax,QWORD PTR [rbx+0x40]
  20c26e:	48 3b 43 30          	cmp    rax,QWORD PTR [rbx+0x30]
  20c272:	0f 83 70 01 00 00    	jae    20c3e8 <benchmark.add+0x1ba8>
    const tmp = a.*;
  20c278:	c4 c1 78 10 01       	vmovups xmm0,XMMWORD PTR [r9]
  20c27d:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  20c284:	00 00 
    a.* = b.*;
  20c286:	c4 c1 78 10 03       	vmovups xmm0,XMMWORD PTR [r11]
  20c28b:	c4 c1 78 11 01       	vmovups XMMWORD PTR [r9],xmm0
    b.* = tmp;
  20c290:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  20c297:	00 00 
  20c299:	c4 c1 7a 7f 03       	vmovdqu XMMWORD PTR [r11],xmm0
  20c29e:	41 b6 04             	mov    r14b,0x4
  20c2a1:	b0 03                	mov    al,0x3
  20c2a3:	e9 45 01 00 00       	jmp    20c3ed <benchmark.add+0x1bad>
  20c2a8:	41 b1 01             	mov    r9b,0x1
  20c2ab:	c7 44 24 18 00 00 00 	mov    DWORD PTR [rsp+0x18],0x0
  20c2b2:	00 
  20c2b3:	48 8d 7b 30          	lea    rdi,[rbx+0x30]
  20c2b7:	4c 8d 5b 20          	lea    r11,[rbx+0x20]
  20c2bb:	48 8b 43 30          	mov    rax,QWORD PTR [rbx+0x30]
  20c2bf:	48 3b 43 20          	cmp    rax,QWORD PTR [rbx+0x20]
  20c2c3:	4c 89 7c 24 60       	mov    QWORD PTR [rsp+0x60],r15
  20c2c8:	0f 83 80 01 00 00    	jae    20c44e <benchmark.add+0x1c0e>
    const tmp = a.*;
  20c2ce:	c4 c1 78 10 03       	vmovups xmm0,XMMWORD PTR [r11]
  20c2d3:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  20c2da:	00 00 
    a.* = b.*;
  20c2dc:	c5 f8 10 07          	vmovups xmm0,XMMWORD PTR [rdi]
  20c2e0:	c4 c1 78 11 03       	vmovups XMMWORD PTR [r11],xmm0
    b.* = tmp;
  20c2e5:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  20c2ec:	00 00 
  20c2ee:	c5 fa 7f 07          	vmovdqu XMMWORD PTR [rdi],xmm0
  20c2f2:	41 b0 03             	mov    r8b,0x3
  20c2f5:	c6 44 24 10 02       	mov    BYTE PTR [rsp+0x10],0x2
  20c2fa:	e9 57 01 00 00       	jmp    20c456 <benchmark.add+0x1c16>
  20c2ff:	41 b0 02             	mov    r8b,0x2
  20c302:	41 b1 03             	mov    r9b,0x3
  20c305:	48 3b 3b             	cmp    rdi,QWORD PTR [rbx]
  20c308:	0f 83 0e fe ff ff    	jae    20c11c <benchmark.add+0x18dc>
  20c30e:	e9 e4 fd ff ff       	jmp    20c0f7 <benchmark.add+0x18b7>
  20c313:	41 b1 03             	mov    r9b,0x3
  20c316:	b2 04                	mov    dl,0x4
  20c318:	4d 89 f8             	mov    r8,r15
  20c31b:	48 8d 7b 20          	lea    rdi,[rbx+0x20]
  20c31f:	48 8b 43 20          	mov    rax,QWORD PTR [rbx+0x20]
  20c323:	48 39 c1             	cmp    rcx,rax
  20c326:	0f 83 7a 01 00 00    	jae    20c4a6 <benchmark.add+0x1c66>
    const tmp = a.*;
  20c32c:	c5 f8 10 07          	vmovups xmm0,XMMWORD PTR [rdi]
  20c330:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  20c337:	00 00 
    a.* = b.*;
  20c339:	c5 f8 10 06          	vmovups xmm0,XMMWORD PTR [rsi]
  20c33d:	c5 f8 11 07          	vmovups XMMWORD PTR [rdi],xmm0
    b.* = tmp;
  20c341:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  20c348:	00 00 
  20c34a:	c5 fa 7f 06          	vmovdqu XMMWORD PTR [rsi],xmm0
  20c34e:	48 8b 07             	mov    rax,QWORD PTR [rdi]
  20c351:	41 b7 02             	mov    r15b,0x2
  20c354:	49 8b 4d 00          	mov    rcx,QWORD PTR [r13+0x0]
  20c358:	48 39 c1             	cmp    rcx,rax
  20c35b:	0f 83 53 01 00 00    	jae    20c4b4 <benchmark.add+0x1c74>
  20c361:	e9 60 01 00 00       	jmp    20c4c6 <benchmark.add+0x1c86>
  20c366:	c6 44 24 10 04       	mov    BYTE PTR [rsp+0x10],0x4
  20c36b:	41 b4 05             	mov    r12b,0x5
  20c36e:	48 8b 43 20          	mov    rax,QWORD PTR [rbx+0x20]
  20c372:	48 3b 03             	cmp    rax,QWORD PTR [rbx]
  20c375:	0f 83 d1 fe ff ff    	jae    20c24c <benchmark.add+0x1a0c>
    const tmp = a.*;
  20c37b:	c5 f8 10 03          	vmovups xmm0,XMMWORD PTR [rbx]
  20c37f:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  20c386:	00 00 
    a.* = b.*;
  20c388:	c4 c1 78 10 00       	vmovups xmm0,XMMWORD PTR [r8]
  20c38d:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
    b.* = tmp;
  20c391:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  20c398:	00 00 
  20c39a:	c4 c1 7a 7f 00       	vmovdqu XMMWORD PTR [r8],xmm0
  20c39f:	44 89 5c 24 18       	mov    DWORD PTR [rsp+0x18],r11d
  20c3a4:	45 31 db             	xor    r11d,r11d
  20c3a7:	4c 89 6c 24 20       	mov    QWORD PTR [rsp+0x20],r13
  20c3ac:	48 8d 73 30          	lea    rsi,[rbx+0x30]
  20c3b0:	48 8b 43 50          	mov    rax,QWORD PTR [rbx+0x50]
  20c3b4:	48 3b 43 30          	cmp    rax,QWORD PTR [rbx+0x30]
  20c3b8:	0f 83 46 01 00 00    	jae    20c504 <benchmark.add+0x1cc4>
    const tmp = a.*;
  20c3be:	c5 f8 10 06          	vmovups xmm0,XMMWORD PTR [rsi]
  20c3c2:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  20c3c9:	00 00 
    a.* = b.*;
  20c3cb:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  20c3cf:	c5 f8 11 06          	vmovups XMMWORD PTR [rsi],xmm0
    b.* = tmp;
  20c3d3:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  20c3da:	00 00 
  20c3dc:	c5 fa 7f 01          	vmovdqu XMMWORD PTR [rcx],xmm0
  20c3e0:	41 b5 03             	mov    r13b,0x3
  20c3e3:	e9 22 01 00 00       	jmp    20c50a <benchmark.add+0x1cca>
  20c3e8:	41 b6 03             	mov    r14b,0x3
  20c3eb:	b0 04                	mov    al,0x4
  20c3ed:	4c 89 6c 24 20       	mov    QWORD PTR [rsp+0x20],r13
  20c3f2:	4c 8d 43 60          	lea    r8,[rbx+0x60]
  20c3f6:	48 8d 4b 50          	lea    rcx,[rbx+0x50]
  20c3fa:	48 8b 53 60          	mov    rdx,QWORD PTR [rbx+0x60]
  20c3fe:	48 3b 53 50          	cmp    rdx,QWORD PTR [rbx+0x50]
  20c402:	0f 83 62 01 00 00    	jae    20c56a <benchmark.add+0x1d2a>
    const tmp = a.*;
  20c408:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  20c40c:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  20c413:	00 00 
    a.* = b.*;
  20c415:	c4 c1 78 10 00       	vmovups xmm0,XMMWORD PTR [r8]
  20c41a:	c5 f8 11 01          	vmovups XMMWORD PTR [rcx],xmm0
    b.* = tmp;
  20c41e:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  20c425:	00 00 
  20c427:	c4 c1 7a 7f 00       	vmovdqu XMMWORD PTR [r8],xmm0
  20c42c:	c6 44 24 18 06       	mov    BYTE PTR [rsp+0x18],0x6
  20c431:	41 b5 05             	mov    r13b,0x5
  20c434:	48 8b 53 20          	mov    rdx,QWORD PTR [rbx+0x20]
  20c438:	48 3b 13             	cmp    rdx,QWORD PTR [rbx]
  20c43b:	0f 82 3e 01 00 00    	jb     20c57f <benchmark.add+0x1d3f>
  20c441:	c7 44 24 10 00 00 00 	mov    DWORD PTR [rsp+0x10],0x0
  20c448:	00 
  20c449:	e9 5b 01 00 00       	jmp    20c5a9 <benchmark.add+0x1d69>
  20c44e:	41 b0 02             	mov    r8b,0x2
  20c451:	c6 44 24 10 03       	mov    BYTE PTR [rsp+0x10],0x3
  20c456:	4c 8d 7b 50          	lea    r15,[rbx+0x50]
  20c45a:	4c 8d 73 40          	lea    r14,[rbx+0x40]
  20c45e:	48 8b 43 50          	mov    rax,QWORD PTR [rbx+0x50]
  20c462:	48 3b 43 40          	cmp    rax,QWORD PTR [rbx+0x40]
  20c466:	4c 89 6c 24 20       	mov    QWORD PTR [rsp+0x20],r13
  20c46b:	0f 83 97 01 00 00    	jae    20c608 <benchmark.add+0x1dc8>
    const tmp = a.*;
  20c471:	c4 c1 78 10 06       	vmovups xmm0,XMMWORD PTR [r14]
  20c476:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  20c47d:	00 00 
    a.* = b.*;
  20c47f:	c4 c1 78 10 07       	vmovups xmm0,XMMWORD PTR [r15]
  20c484:	c4 c1 78 11 06       	vmovups XMMWORD PTR [r14],xmm0
    b.* = tmp;
  20c489:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  20c490:	00 00 
  20c492:	c4 c1 7a 7f 07       	vmovdqu XMMWORD PTR [r15],xmm0
  20c497:	c6 44 24 40 05       	mov    BYTE PTR [rsp+0x40],0x5
  20c49c:	c6 44 24 38 04       	mov    BYTE PTR [rsp+0x38],0x4
  20c4a1:	e9 6c 01 00 00       	jmp    20c612 <benchmark.add+0x1dd2>
  20c4a6:	41 89 d7             	mov    r15d,edx
  20c4a9:	b2 02                	mov    dl,0x2
  20c4ab:	49 8b 4d 00          	mov    rcx,QWORD PTR [r13+0x0]
  20c4af:	48 39 c1             	cmp    rcx,rax
  20c4b2:	72 12                	jb     20c4c6 <benchmark.add+0x1c86>
  20c4b4:	44 38 ca             	cmp    dl,r9b
  20c4b7:	0f 86 b1 03 00 00    	jbe    20c86e <benchmark.add+0x202e>
  20c4bd:	48 39 c8             	cmp    rax,rcx
  20c4c0:	0f 82 a8 03 00 00    	jb     20c86e <benchmark.add+0x202e>
    const tmp = a.*;
  20c4c6:	c5 f8 10 07          	vmovups xmm0,XMMWORD PTR [rdi]
  20c4ca:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  20c4d1:	00 00 
    a.* = b.*;
  20c4d3:	c4 c1 78 10 45 00    	vmovups xmm0,XMMWORD PTR [r13+0x0]
  20c4d9:	c5 f8 11 07          	vmovups XMMWORD PTR [rdi],xmm0
    b.* = tmp;
  20c4dd:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  20c4e4:	00 00 
  20c4e6:	c4 c1 7a 7f 45 00    	vmovdqu XMMWORD PTR [r13+0x0],xmm0
  20c4ec:	41 89 d6             	mov    r14d,edx
  20c4ef:	48 8b 06             	mov    rax,QWORD PTR [rsi]
  20c4f2:	49 8b 0c 24          	mov    rcx,QWORD PTR [r12]
  20c4f6:	48 39 c8             	cmp    rax,rcx
  20c4f9:	0f 83 81 03 00 00    	jae    20c880 <benchmark.add+0x2040>
  20c4ff:	e9 86 03 00 00       	jmp    20c88a <benchmark.add+0x204a>
  20c504:	45 89 e5             	mov    r13d,r12d
  20c507:	41 b4 03             	mov    r12b,0x3
  20c50a:	48 8b 13             	mov    rdx,QWORD PTR [rbx]
  20c50d:	48 8b 43 10          	mov    rax,QWORD PTR [rbx+0x10]
  20c511:	48 39 d0             	cmp    rax,rdx
  20c514:	4c 89 7c 24 60       	mov    QWORD PTR [rsp+0x60],r15
  20c519:	72 14                	jb     20c52f <benchmark.add+0x1cef>
  20c51b:	44 38 74 24 18       	cmp    BYTE PTR [rsp+0x18],r14b
  20c520:	0f 86 ef 03 00 00    	jbe    20c915 <benchmark.add+0x20d5>
  20c526:	48 39 c2             	cmp    rdx,rax
  20c529:	0f 82 e6 03 00 00    	jb     20c915 <benchmark.add+0x20d5>
    const tmp = a.*;
  20c52f:	c5 f8 10 03          	vmovups xmm0,XMMWORD PTR [rbx]
  20c533:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  20c53a:	00 00 
    a.* = b.*;
  20c53c:	c4 c1 78 10 01       	vmovups xmm0,XMMWORD PTR [r9]
  20c541:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
    b.* = tmp;
  20c545:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  20c54c:	00 00 
  20c54e:	c4 c1 7a 7f 01       	vmovdqu XMMWORD PTR [r9],xmm0
  20c553:	45 89 f7             	mov    r15d,r14d
  20c556:	48 8b 17             	mov    rdx,QWORD PTR [rdi]
  20c559:	48 8b 06             	mov    rax,QWORD PTR [rsi]
  20c55c:	48 39 c2             	cmp    rdx,rax
  20c55f:	0f 83 c9 03 00 00    	jae    20c92e <benchmark.add+0x20ee>
  20c565:	e9 d8 03 00 00       	jmp    20c942 <benchmark.add+0x2102>
  20c56a:	c6 44 24 18 05       	mov    BYTE PTR [rsp+0x18],0x5
  20c56f:	41 b5 06             	mov    r13b,0x6
  20c572:	48 8b 53 20          	mov    rdx,QWORD PTR [rbx+0x20]
  20c576:	48 3b 13             	cmp    rdx,QWORD PTR [rbx]
  20c579:	0f 83 c2 fe ff ff    	jae    20c441 <benchmark.add+0x1c01>
    const tmp = a.*;
  20c57f:	c5 f8 10 03          	vmovups xmm0,XMMWORD PTR [rbx]
  20c583:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  20c58a:	00 00 
    a.* = b.*;
  20c58c:	c5 f8 10 07          	vmovups xmm0,XMMWORD PTR [rdi]
  20c590:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
    b.* = tmp;
  20c594:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  20c59b:	00 00 
  20c59d:	c5 fa 7f 07          	vmovdqu XMMWORD PTR [rdi],xmm0
  20c5a1:	44 89 64 24 10       	mov    DWORD PTR [rsp+0x10],r12d
  20c5a6:	45 31 e4             	xor    r12d,r12d
  20c5a9:	48 8b 11             	mov    rdx,QWORD PTR [rcx]
  20c5ac:	49 8b 31             	mov    rsi,QWORD PTR [r9]
  20c5af:	48 39 f2             	cmp    rdx,rsi
  20c5b2:	44 89 64 24 28       	mov    DWORD PTR [rsp+0x28],r12d
  20c5b7:	72 14                	jb     20c5cd <benchmark.add+0x1d8d>
  20c5b9:	44 3a 74 24 18       	cmp    r14b,BYTE PTR [rsp+0x18]
  20c5be:	0f 86 bd 03 00 00    	jbe    20c981 <benchmark.add+0x2141>
  20c5c4:	48 39 d6             	cmp    rsi,rdx
  20c5c7:	0f 82 b4 03 00 00    	jb     20c981 <benchmark.add+0x2141>
    const tmp = a.*;
  20c5cd:	c4 c1 78 10 01       	vmovups xmm0,XMMWORD PTR [r9]
  20c5d2:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  20c5d9:	00 00 
    a.* = b.*;
  20c5db:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  20c5df:	c4 c1 78 11 01       	vmovups XMMWORD PTR [r9],xmm0
    b.* = tmp;
  20c5e4:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  20c5eb:	00 00 
  20c5ed:	c5 fa 7f 01          	vmovdqu XMMWORD PTR [rcx],xmm0
  20c5f1:	45 89 f4             	mov    r12d,r14d
  20c5f4:	49 8b 10             	mov    rdx,QWORD PTR [r8]
  20c5f7:	49 8b 33             	mov    rsi,QWORD PTR [r11]
  20c5fa:	48 39 f2             	cmp    rdx,rsi
  20c5fd:	0f 83 94 03 00 00    	jae    20c997 <benchmark.add+0x2157>
  20c603:	e9 a1 03 00 00       	jmp    20c9a9 <benchmark.add+0x2169>
  20c608:	c6 44 24 40 04       	mov    BYTE PTR [rsp+0x40],0x4
  20c60d:	c6 44 24 38 05       	mov    BYTE PTR [rsp+0x38],0x5
  20c612:	4c 8d 6b 70          	lea    r13,[rbx+0x70]
  20c616:	48 8d 73 60          	lea    rsi,[rbx+0x60]
  20c61a:	48 8b 53 70          	mov    rdx,QWORD PTR [rbx+0x70]
  20c61e:	48 3b 53 60          	cmp    rdx,QWORD PTR [rbx+0x60]
  20c622:	0f 83 ae 00 00 00    	jae    20c6d6 <benchmark.add+0x1e96>
    const tmp = a.*;
  20c628:	c5 f8 10 06          	vmovups xmm0,XMMWORD PTR [rsi]
  20c62c:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  20c633:	00 00 
    a.* = b.*;
  20c635:	c4 c1 78 10 45 00    	vmovups xmm0,XMMWORD PTR [r13+0x0]
  20c63b:	c5 f8 11 06          	vmovups XMMWORD PTR [rsi],xmm0
    b.* = tmp;
  20c63f:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  20c646:	00 00 
  20c648:	c4 c1 7a 7f 45 00    	vmovdqu XMMWORD PTR [r13+0x0],xmm0
  20c64e:	c6 44 24 28 07       	mov    BYTE PTR [rsp+0x28],0x7
  20c653:	b1 06                	mov    cl,0x6
  20c655:	48 8b 53 20          	mov    rdx,QWORD PTR [rbx+0x20]
  20c659:	48 3b 13             	cmp    rdx,QWORD PTR [rbx]
  20c65c:	0f 82 88 00 00 00    	jb     20c6ea <benchmark.add+0x1eaa>
  20c662:	8b 54 24 18          	mov    edx,DWORD PTR [rsp+0x18]
  20c666:	89 d0                	mov    eax,edx
  20c668:	88 44 24 58          	mov    BYTE PTR [rsp+0x58],al
  20c66c:	44 89 c2             	mov    edx,r8d
  20c66f:	89 54 24 18          	mov    DWORD PTR [rsp+0x18],edx
  20c673:	48 8b 17             	mov    rdx,QWORD PTR [rdi]
  20c676:	49 3b 14 24          	cmp    rdx,QWORD PTR [r12]
  20c67a:	0f 82 a0 00 00 00    	jb     20c720 <benchmark.add+0x1ee0>
  20c680:	0f b6 54 24 10       	movzx  edx,BYTE PTR [rsp+0x10]
  20c685:	44 89 c8             	mov    eax,r9d
  20c688:	88 44 24 10          	mov    BYTE PTR [rsp+0x10],al
  20c68c:	88 54 24 30          	mov    BYTE PTR [rsp+0x30],dl
  20c690:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  20c693:	49 3b 16             	cmp    rdx,QWORD PTR [r14]
  20c696:	0f 82 bd 00 00 00    	jb     20c759 <benchmark.add+0x1f19>
  20c69c:	44 0f b6 44 24 28    	movzx  r8d,BYTE PTR [rsp+0x28]
  20c6a2:	0f b6 44 24 40       	movzx  eax,BYTE PTR [rsp+0x40]
  20c6a7:	88 44 24 28          	mov    BYTE PTR [rsp+0x28],al
  20c6ab:	49 8b 45 00          	mov    rax,QWORD PTR [r13+0x0]
  20c6af:	49 3b 07             	cmp    rax,QWORD PTR [r15]
  20c6b2:	0f 82 d8 00 00 00    	jb     20c790 <benchmark.add+0x1f50>
  20c6b8:	88 4c 24 40          	mov    BYTE PTR [rsp+0x40],cl
  20c6bc:	0f b6 4c 24 38       	movzx  ecx,BYTE PTR [rsp+0x38]
  20c6c1:	49 8b 13             	mov    rdx,QWORD PTR [r11]
  20c6c4:	49 8b 04 24          	mov    rax,QWORD PTR [r12]
  20c6c8:	48 39 c2             	cmp    rdx,rax
  20c6cb:	0f 83 fc 00 00 00    	jae    20c7cd <benchmark.add+0x1f8d>
  20c6d1:	e9 17 01 00 00       	jmp    20c7ed <benchmark.add+0x1fad>
  20c6d6:	c6 44 24 28 06       	mov    BYTE PTR [rsp+0x28],0x6
  20c6db:	b1 07                	mov    cl,0x7
  20c6dd:	48 8b 53 20          	mov    rdx,QWORD PTR [rbx+0x20]
  20c6e1:	48 3b 13             	cmp    rdx,QWORD PTR [rbx]
  20c6e4:	0f 83 78 ff ff ff    	jae    20c662 <benchmark.add+0x1e22>
    const tmp = a.*;
  20c6ea:	c5 f8 10 03          	vmovups xmm0,XMMWORD PTR [rbx]
  20c6ee:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  20c6f5:	00 00 
    a.* = b.*;
  20c6f7:	c4 c1 78 10 03       	vmovups xmm0,XMMWORD PTR [r11]
  20c6fc:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
    b.* = tmp;
  20c700:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  20c707:	00 00 
  20c709:	c4 c1 7a 7f 03       	vmovdqu XMMWORD PTR [r11],xmm0
  20c70e:	44 88 44 24 58       	mov    BYTE PTR [rsp+0x58],r8b
  20c713:	48 8b 17             	mov    rdx,QWORD PTR [rdi]
  20c716:	49 3b 14 24          	cmp    rdx,QWORD PTR [r12]
  20c71a:	0f 83 60 ff ff ff    	jae    20c680 <benchmark.add+0x1e40>
    const tmp = a.*;
  20c720:	c4 c1 78 10 04 24    	vmovups xmm0,XMMWORD PTR [r12]
  20c726:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  20c72d:	00 00 
    a.* = b.*;
  20c72f:	c5 f8 10 07          	vmovups xmm0,XMMWORD PTR [rdi]
  20c733:	c4 c1 78 11 04 24    	vmovups XMMWORD PTR [r12],xmm0
    b.* = tmp;
  20c739:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  20c740:	00 00 
  20c742:	c5 fa 7f 07          	vmovdqu XMMWORD PTR [rdi],xmm0
  20c746:	44 89 ca             	mov    edx,r9d
  20c749:	88 54 24 30          	mov    BYTE PTR [rsp+0x30],dl
  20c74d:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  20c750:	49 3b 16             	cmp    rdx,QWORD PTR [r14]
  20c753:	0f 83 43 ff ff ff    	jae    20c69c <benchmark.add+0x1e5c>
    const tmp = a.*;
  20c759:	c4 c1 78 10 06       	vmovups xmm0,XMMWORD PTR [r14]
  20c75e:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  20c765:	00 00 
    a.* = b.*;
  20c767:	c5 f8 10 06          	vmovups xmm0,XMMWORD PTR [rsi]
  20c76b:	c4 c1 78 11 06       	vmovups XMMWORD PTR [r14],xmm0
    b.* = tmp;
  20c770:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  20c777:	00 00 
  20c779:	c5 fa 7f 06          	vmovdqu XMMWORD PTR [rsi],xmm0
  20c77d:	44 0f b6 44 24 40    	movzx  r8d,BYTE PTR [rsp+0x40]
  20c783:	49 8b 45 00          	mov    rax,QWORD PTR [r13+0x0]
  20c787:	49 3b 07             	cmp    rax,QWORD PTR [r15]
  20c78a:	0f 83 28 ff ff ff    	jae    20c6b8 <benchmark.add+0x1e78>
    const tmp = a.*;
  20c790:	c4 c1 78 10 07       	vmovups xmm0,XMMWORD PTR [r15]
  20c795:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  20c79c:	00 00 
    a.* = b.*;
  20c79e:	c4 c1 78 10 45 00    	vmovups xmm0,XMMWORD PTR [r13+0x0]
  20c7a4:	c4 c1 78 11 07       	vmovups XMMWORD PTR [r15],xmm0
    b.* = tmp;
  20c7a9:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  20c7b0:	00 00 
  20c7b2:	c4 c1 7a 7f 45 00    	vmovdqu XMMWORD PTR [r13+0x0],xmm0
  20c7b8:	0f b6 44 24 38       	movzx  eax,BYTE PTR [rsp+0x38]
  20c7bd:	88 44 24 40          	mov    BYTE PTR [rsp+0x40],al
  20c7c1:	49 8b 13             	mov    rdx,QWORD PTR [r11]
  20c7c4:	49 8b 04 24          	mov    rax,QWORD PTR [r12]
  20c7c8:	48 39 c2             	cmp    rdx,rax
  20c7cb:	72 20                	jb     20c7ed <benchmark.add+0x1fad>
  20c7cd:	45 89 c1             	mov    r9d,r8d
  20c7d0:	44 0f b6 44 24 10    	movzx  r8d,BYTE PTR [rsp+0x10]
  20c7d6:	44 3a 44 24 18       	cmp    r8b,BYTE PTR [rsp+0x18]
  20c7db:	0f 86 2f 0a 00 00    	jbe    20d210 <benchmark.add+0x29d0>
  20c7e1:	48 39 d0             	cmp    rax,rdx
  20c7e4:	45 89 c8             	mov    r8d,r9d
  20c7e7:	0f 82 3c 0a 00 00    	jb     20d229 <benchmark.add+0x29e9>
    const tmp = a.*;
  20c7ed:	c4 c1 78 10 04 24    	vmovups xmm0,XMMWORD PTR [r12]
  20c7f3:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  20c7fa:	00 00 
    a.* = b.*;
  20c7fc:	c4 c1 78 10 03       	vmovups xmm0,XMMWORD PTR [r11]
  20c801:	c4 c1 78 11 04 24    	vmovups XMMWORD PTR [r12],xmm0
    b.* = tmp;
  20c807:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  20c80e:	00 00 
  20c810:	c4 c1 7a 7f 03       	vmovdqu XMMWORD PTR [r11],xmm0
  20c815:	0f b6 44 24 10       	movzx  eax,BYTE PTR [rsp+0x10]
  20c81a:	88 44 24 38          	mov    BYTE PTR [rsp+0x38],al
  20c81e:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  20c821:	49 8b 07             	mov    rax,QWORD PTR [r15]
  20c824:	48 39 c2             	cmp    rdx,rax
  20c827:	44 0f b6 4c 24 28    	movzx  r9d,BYTE PTR [rsp+0x28]
  20c82d:	72 12                	jb     20c841 <benchmark.add+0x2001>
  20c82f:	44 38 c1             	cmp    cl,r8b
  20c832:	0f 86 9f 01 00 00    	jbe    20c9d7 <benchmark.add+0x2197>
  20c838:	48 39 d0             	cmp    rax,rdx
  20c83b:	0f 82 96 01 00 00    	jb     20c9d7 <benchmark.add+0x2197>
    const tmp = a.*;
  20c841:	c4 c1 78 10 07       	vmovups xmm0,XMMWORD PTR [r15]
  20c846:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  20c84d:	00 00 
    a.* = b.*;
  20c84f:	c5 f8 10 06          	vmovups xmm0,XMMWORD PTR [rsi]
  20c853:	c4 c1 78 11 07       	vmovups XMMWORD PTR [r15],xmm0
    b.* = tmp;
  20c858:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  20c85f:	00 00 
  20c861:	c5 fa 7f 06          	vmovdqu XMMWORD PTR [rsi],xmm0
  20c865:	88 4c 24 10          	mov    BYTE PTR [rsp+0x10],cl
  20c869:	e9 71 01 00 00       	jmp    20c9df <benchmark.add+0x219f>
  20c86e:	45 89 ce             	mov    r14d,r9d
  20c871:	41 89 d1             	mov    r9d,edx
  20c874:	48 8b 06             	mov    rax,QWORD PTR [rsi]
  20c877:	49 8b 0c 24          	mov    rcx,QWORD PTR [r12]
  20c87b:	48 39 c8             	cmp    rax,rcx
  20c87e:	72 0a                	jb     20c88a <benchmark.add+0x204a>
  20c880:	45 38 fb             	cmp    r11b,r15b
  20c883:	76 2e                	jbe    20c8b3 <benchmark.add+0x2073>
  20c885:	48 39 c1             	cmp    rcx,rax
  20c888:	72 29                	jb     20c8b3 <benchmark.add+0x2073>
    const tmp = a.*;
  20c88a:	c4 c1 78 10 04 24    	vmovups xmm0,XMMWORD PTR [r12]
  20c890:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  20c897:	00 00 
    a.* = b.*;
  20c899:	c5 f8 10 06          	vmovups xmm0,XMMWORD PTR [rsi]
  20c89d:	c4 c1 78 11 04 24    	vmovups XMMWORD PTR [r12],xmm0
    b.* = tmp;
  20c8a3:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  20c8aa:	00 00 
  20c8ac:	c5 fa 7f 06          	vmovdqu XMMWORD PTR [rsi],xmm0
  20c8b0:	45 89 fb             	mov    r11d,r15d
  20c8b3:	48 8b 13             	mov    rdx,QWORD PTR [rbx]
  20c8b6:	48 8b 43 30          	mov    rax,QWORD PTR [rbx+0x30]
  20c8ba:	48 39 d0             	cmp    rax,rdx
  20c8bd:	4d 89 c7             	mov    r15,r8
  20c8c0:	8b 74 24 18          	mov    esi,DWORD PTR [rsp+0x18]
  20c8c4:	72 12                	jb     20c8d8 <benchmark.add+0x2098>
  20c8c6:	44 38 f6             	cmp    sil,r14b
  20c8c9:	0f 86 06 02 00 00    	jbe    20cad5 <benchmark.add+0x2295>
  20c8cf:	48 39 c2             	cmp    rdx,rax
  20c8d2:	0f 82 fd 01 00 00    	jb     20cad5 <benchmark.add+0x2295>
    const tmp = a.*;
  20c8d8:	c5 f8 10 03          	vmovups xmm0,XMMWORD PTR [rbx]
  20c8dc:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  20c8e3:	00 00 
    a.* = b.*;
  20c8e5:	c4 c1 78 10 45 00    	vmovups xmm0,XMMWORD PTR [r13+0x0]
  20c8eb:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
    b.* = tmp;
  20c8ef:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  20c8f6:	00 00 
  20c8f8:	c4 c1 7a 7f 45 00    	vmovdqu XMMWORD PTR [r13+0x0],xmm0
  20c8fe:	48 8b 13             	mov    rdx,QWORD PTR [rbx]
  20c901:	44 89 f0             	mov    eax,r14d
  20c904:	48 8b 0f             	mov    rcx,QWORD PTR [rdi]
  20c907:	48 39 d1             	cmp    rcx,rdx
  20c90a:	0f 83 d2 01 00 00    	jae    20cae2 <benchmark.add+0x22a2>
  20c910:	e9 d7 01 00 00       	jmp    20caec <benchmark.add+0x22ac>
  20c915:	8b 44 24 18          	mov    eax,DWORD PTR [rsp+0x18]
  20c919:	41 89 c7             	mov    r15d,eax
  20c91c:	44 89 f0             	mov    eax,r14d
  20c91f:	89 44 24 18          	mov    DWORD PTR [rsp+0x18],eax
  20c923:	48 8b 17             	mov    rdx,QWORD PTR [rdi]
  20c926:	48 8b 06             	mov    rax,QWORD PTR [rsi]
  20c929:	48 39 c2             	cmp    rdx,rax
  20c92c:	72 14                	jb     20c942 <benchmark.add+0x2102>
  20c92e:	44 3a 64 24 10       	cmp    r12b,BYTE PTR [rsp+0x10]
  20c933:	0f 86 37 07 00 00    	jbe    20d070 <benchmark.add+0x2830>
  20c939:	48 39 d0             	cmp    rax,rdx
  20c93c:	0f 82 2e 07 00 00    	jb     20d070 <benchmark.add+0x2830>
    const tmp = a.*;
  20c942:	c5 f8 10 06          	vmovups xmm0,XMMWORD PTR [rsi]
  20c946:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  20c94d:	00 00 
    a.* = b.*;
  20c94f:	c5 f8 10 07          	vmovups xmm0,XMMWORD PTR [rdi]
  20c953:	c5 f8 11 06          	vmovups XMMWORD PTR [rsi],xmm0
    b.* = tmp;
  20c957:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  20c95e:	00 00 
  20c960:	c5 fa 7f 07          	vmovdqu XMMWORD PTR [rdi],xmm0
  20c964:	45 89 e6             	mov    r14d,r12d
  20c967:	44 0f b6 64 24 10    	movzx  r12d,BYTE PTR [rsp+0x10]
  20c96d:	48 8b 11             	mov    rdx,QWORD PTR [rcx]
  20c970:	49 8b 00             	mov    rax,QWORD PTR [r8]
  20c973:	48 39 c2             	cmp    rdx,rax
  20c976:	0f 82 0f 07 00 00    	jb     20d08b <benchmark.add+0x284b>
  20c97c:	e9 00 07 00 00       	jmp    20d081 <benchmark.add+0x2841>
  20c981:	44 0f b6 64 24 18    	movzx  r12d,BYTE PTR [rsp+0x18]
  20c987:	44 88 74 24 18       	mov    BYTE PTR [rsp+0x18],r14b
  20c98c:	49 8b 10             	mov    rdx,QWORD PTR [r8]
  20c98f:	49 8b 33             	mov    rsi,QWORD PTR [r11]
  20c992:	48 39 f2             	cmp    rdx,rsi
  20c995:	72 12                	jb     20c9a9 <benchmark.add+0x2169>
  20c997:	44 38 e8             	cmp    al,r13b
  20c99a:	0f 86 11 02 00 00    	jbe    20cbb1 <benchmark.add+0x2371>
  20c9a0:	48 39 d6             	cmp    rsi,rdx
  20c9a3:	0f 82 08 02 00 00    	jb     20cbb1 <benchmark.add+0x2371>
    const tmp = a.*;
  20c9a9:	c4 c1 78 10 03       	vmovups xmm0,XMMWORD PTR [r11]
  20c9ae:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  20c9b5:	00 00 
    a.* = b.*;
  20c9b7:	c4 c1 78 10 00       	vmovups xmm0,XMMWORD PTR [r8]
  20c9bc:	c4 c1 78 11 03       	vmovups XMMWORD PTR [r11],xmm0
    b.* = tmp;
  20c9c1:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  20c9c8:	00 00 
  20c9ca:	c4 c1 7a 7f 00       	vmovdqu XMMWORD PTR [r8],xmm0
  20c9cf:	41 89 c6             	mov    r14d,eax
  20c9d2:	e9 e0 01 00 00       	jmp    20cbb7 <benchmark.add+0x2377>
  20c9d7:	44 88 44 24 10       	mov    BYTE PTR [rsp+0x10],r8b
  20c9dc:	41 89 c8             	mov    r8d,ecx
  20c9df:	48 8b 13             	mov    rdx,QWORD PTR [rbx]
  20c9e2:	48 8b 43 40          	mov    rax,QWORD PTR [rbx+0x40]
  20c9e6:	48 39 d0             	cmp    rax,rdx
  20c9e9:	0f b6 4c 24 58       	movzx  ecx,BYTE PTR [rsp+0x58]
  20c9ee:	72 0a                	jb     20c9fa <benchmark.add+0x21ba>
  20c9f0:	44 38 c9             	cmp    cl,r9b
  20c9f3:	76 2c                	jbe    20ca21 <benchmark.add+0x21e1>
  20c9f5:	48 39 c2             	cmp    rdx,rax
  20c9f8:	72 27                	jb     20ca21 <benchmark.add+0x21e1>
    const tmp = a.*;
  20c9fa:	c5 f8 10 03          	vmovups xmm0,XMMWORD PTR [rbx]
  20c9fe:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  20ca05:	00 00 
    a.* = b.*;
  20ca07:	c4 c1 78 10 06       	vmovups xmm0,XMMWORD PTR [r14]
  20ca0c:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
    b.* = tmp;
  20ca10:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  20ca17:	00 00 
  20ca19:	c4 c1 7a 7f 06       	vmovdqu XMMWORD PTR [r14],xmm0
  20ca1e:	41 89 c9             	mov    r9d,ecx
  20ca21:	49 8b 55 00          	mov    rdx,QWORD PTR [r13+0x0]
  20ca25:	48 8b 07             	mov    rax,QWORD PTR [rdi]
  20ca28:	48 39 c2             	cmp    rdx,rax
  20ca2b:	0f b6 5c 24 38       	movzx  ebx,BYTE PTR [rsp+0x38]
  20ca30:	0f b6 4c 24 40       	movzx  ecx,BYTE PTR [rsp+0x40]
  20ca35:	72 0b                	jb     20ca42 <benchmark.add+0x2202>
  20ca37:	38 4c 24 30          	cmp    BYTE PTR [rsp+0x30],cl
  20ca3b:	76 2f                	jbe    20ca6c <benchmark.add+0x222c>
  20ca3d:	48 39 d0             	cmp    rax,rdx
  20ca40:	72 2a                	jb     20ca6c <benchmark.add+0x222c>
    const tmp = a.*;
  20ca42:	c5 f8 10 07          	vmovups xmm0,XMMWORD PTR [rdi]
  20ca46:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  20ca4d:	00 00 
    a.* = b.*;
  20ca4f:	c4 c1 78 10 45 00    	vmovups xmm0,XMMWORD PTR [r13+0x0]
  20ca55:	c5 f8 11 07          	vmovups XMMWORD PTR [rdi],xmm0
    b.* = tmp;
  20ca59:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  20ca60:	00 00 
  20ca62:	c4 c1 7a 7f 45 00    	vmovdqu XMMWORD PTR [r13+0x0],xmm0
  20ca68:	88 4c 24 30          	mov    BYTE PTR [rsp+0x30],cl
  20ca6c:	49 8b 17             	mov    rdx,QWORD PTR [r15]
  20ca6f:	49 8b 04 24          	mov    rax,QWORD PTR [r12]
  20ca73:	48 39 c2             	cmp    rdx,rax
  20ca76:	4c 8b 6c 24 20       	mov    r13,QWORD PTR [rsp+0x20]
  20ca7b:	72 14                	jb     20ca91 <benchmark.add+0x2251>
  20ca7d:	44 38 44 24 18       	cmp    BYTE PTR [rsp+0x18],r8b
  20ca82:	0f 86 7d 01 00 00    	jbe    20cc05 <benchmark.add+0x23c5>
  20ca88:	48 39 d0             	cmp    rax,rdx
  20ca8b:	0f 82 74 01 00 00    	jb     20cc05 <benchmark.add+0x23c5>
    const tmp = a.*;
  20ca91:	c4 c1 78 10 04 24    	vmovups xmm0,XMMWORD PTR [r12]
  20ca97:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  20ca9e:	00 00 
    a.* = b.*;
  20caa0:	c4 c1 78 10 07       	vmovups xmm0,XMMWORD PTR [r15]
  20caa5:	c4 c1 78 11 04 24    	vmovups XMMWORD PTR [r12],xmm0
    b.* = tmp;
  20caab:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  20cab2:	00 00 
  20cab4:	c4 c1 7a 7f 07       	vmovdqu XMMWORD PTR [r15],xmm0
  20cab9:	8b 44 24 18          	mov    eax,DWORD PTR [rsp+0x18]
  20cabd:	88 44 24 28          	mov    BYTE PTR [rsp+0x28],al
  20cac1:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  20cac4:	49 8b 03             	mov    rax,QWORD PTR [r11]
  20cac7:	48 39 c2             	cmp    rdx,rax
  20caca:	0f 83 4c 01 00 00    	jae    20cc1c <benchmark.add+0x23dc>
  20cad0:	e9 5a 01 00 00       	jmp    20cc2f <benchmark.add+0x23ef>
  20cad5:	89 f0                	mov    eax,esi
  20cad7:	44 89 f6             	mov    esi,r14d
  20cada:	48 8b 0f             	mov    rcx,QWORD PTR [rdi]
  20cadd:	48 39 d1             	cmp    rcx,rdx
  20cae0:	72 0a                	jb     20caec <benchmark.add+0x22ac>
  20cae2:	44 38 c8             	cmp    al,r9b
  20cae5:	76 2a                	jbe    20cb11 <benchmark.add+0x22d1>
  20cae7:	48 39 ca             	cmp    rdx,rcx
  20caea:	72 25                	jb     20cb11 <benchmark.add+0x22d1>
    const tmp = a.*;
  20caec:	c5 f8 10 03          	vmovups xmm0,XMMWORD PTR [rbx]
  20caf0:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  20caf7:	00 00 
    a.* = b.*;
  20caf9:	c5 f8 10 07          	vmovups xmm0,XMMWORD PTR [rdi]
  20cafd:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
    b.* = tmp;
  20cb01:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  20cb08:	00 00 
  20cb0a:	c5 fa 7f 07          	vmovdqu XMMWORD PTR [rdi],xmm0
  20cb0e:	41 89 c1             	mov    r9d,eax
  20cb11:	49 8b 45 00          	mov    rax,QWORD PTR [r13+0x0]
  20cb15:	49 8b 14 24          	mov    rdx,QWORD PTR [r12]
  20cb19:	48 39 d0             	cmp    rax,rdx
  20cb1c:	72 0a                	jb     20cb28 <benchmark.add+0x22e8>
  20cb1e:	41 38 f3             	cmp    r11b,sil
  20cb21:	76 36                	jbe    20cb59 <benchmark.add+0x2319>
  20cb23:	48 39 c2             	cmp    rdx,rax
  20cb26:	72 31                	jb     20cb59 <benchmark.add+0x2319>
    const tmp = a.*;
  20cb28:	c4 c1 78 10 04 24    	vmovups xmm0,XMMWORD PTR [r12]
  20cb2e:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  20cb35:	00 00 
    a.* = b.*;
  20cb37:	c4 c1 78 10 45 00    	vmovups xmm0,XMMWORD PTR [r13+0x0]
  20cb3d:	c4 c1 78 11 04 24    	vmovups XMMWORD PTR [r12],xmm0
    b.* = tmp;
  20cb43:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  20cb4a:	00 00 
  20cb4c:	c4 c1 7a 7f 45 00    	vmovdqu XMMWORD PTR [r13+0x0],xmm0
  20cb52:	49 8b 14 24          	mov    rdx,QWORD PTR [r12]
  20cb56:	41 89 f3             	mov    r11d,esi
  20cb59:	48 8b 07             	mov    rax,QWORD PTR [rdi]
  20cb5c:	48 39 d0             	cmp    rax,rdx
  20cb5f:	4c 8b 6c 24 20       	mov    r13,QWORD PTR [rsp+0x20]
  20cb64:	72 12                	jb     20cb78 <benchmark.add+0x2338>
  20cb66:	45 38 cb             	cmp    r11b,r9b
  20cb69:	0f 86 91 06 00 00    	jbe    20d200 <benchmark.add+0x29c0>
  20cb6f:	48 39 c2             	cmp    rdx,rax
  20cb72:	0f 82 88 06 00 00    	jb     20d200 <benchmark.add+0x29c0>
    const tmp = a.*;
  20cb78:	c4 c1 78 10 04 24    	vmovups xmm0,XMMWORD PTR [r12]
  20cb7e:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  20cb85:	00 00 
    a.* = b.*;
  20cb87:	c5 f8 10 07          	vmovups xmm0,XMMWORD PTR [rdi]
  20cb8b:	c4 c1 78 11 04 24    	vmovups XMMWORD PTR [r12],xmm0
    b.* = tmp;
  20cb91:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  20cb98:	00 00 
  20cb9a:	c5 fa 7f 07          	vmovdqu XMMWORD PTR [rdi],xmm0
        return self.decimal >= self.size;
  20cb9e:	4c 3b 94 24 50 01 00 	cmp    r10,QWORD PTR [rsp+0x150]
  20cba5:	00 
  20cba6:	0f 82 34 f3 ff ff    	jb     20bee0 <benchmark.add+0x16a0>
  20cbac:	e9 8e 06 00 00       	jmp    20d23f <benchmark.add+0x29ff>
  20cbb1:	45 89 ee             	mov    r14d,r13d
  20cbb4:	41 89 c5             	mov    r13d,eax
  20cbb7:	48 8b 13             	mov    rdx,QWORD PTR [rbx]
  20cbba:	48 8b 73 10          	mov    rsi,QWORD PTR [rbx+0x10]
  20cbbe:	48 39 d6             	cmp    rsi,rdx
  20cbc1:	0f b6 44 24 38       	movzx  eax,BYTE PTR [rsp+0x38]
    if (lessThan(items[y], items[x]) or ((order.*)[x] > (order.*)[y] and !lessThan(items[x], items[y]))) {
  20cbc6:	72 13                	jb     20cbdb <benchmark.add+0x239b>
  20cbc8:	38 44 24 10          	cmp    BYTE PTR [rsp+0x10],al
  20cbcc:	0f 86 91 00 00 00    	jbe    20cc63 <benchmark.add+0x2423>
  20cbd2:	48 39 f2             	cmp    rdx,rsi
  20cbd5:	0f 82 88 00 00 00    	jb     20cc63 <benchmark.add+0x2423>
    const tmp = a.*;
  20cbdb:	c5 f8 10 03          	vmovups xmm0,XMMWORD PTR [rbx]
  20cbdf:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  20cbe6:	00 00 
    a.* = b.*;
  20cbe8:	c4 c1 78 10 07       	vmovups xmm0,XMMWORD PTR [r15]
  20cbed:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
    b.* = tmp;
  20cbf1:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  20cbf8:	00 00 
  20cbfa:	c4 c1 7a 7f 07       	vmovdqu XMMWORD PTR [r15],xmm0
  20cbff:	88 44 24 30          	mov    BYTE PTR [rsp+0x30],al
  20cc03:	eb 6c                	jmp    20cc71 <benchmark.add+0x2431>
  20cc05:	44 88 44 24 28       	mov    BYTE PTR [rsp+0x28],r8b
  20cc0a:	8b 44 24 18          	mov    eax,DWORD PTR [rsp+0x18]
  20cc0e:	41 89 c0             	mov    r8d,eax
  20cc11:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  20cc14:	49 8b 03             	mov    rax,QWORD PTR [r11]
  20cc17:	48 39 c2             	cmp    rdx,rax
  20cc1a:	72 13                	jb     20cc2f <benchmark.add+0x23ef>
  20cc1c:	3a 5c 24 10          	cmp    bl,BYTE PTR [rsp+0x10]
  20cc20:	0f 86 97 00 00 00    	jbe    20ccbd <benchmark.add+0x247d>
  20cc26:	48 39 d0             	cmp    rax,rdx
  20cc29:	0f 82 8e 00 00 00    	jb     20ccbd <benchmark.add+0x247d>
    const tmp = a.*;
  20cc2f:	c4 c1 78 10 03       	vmovups xmm0,XMMWORD PTR [r11]
  20cc34:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  20cc3b:	00 00 
    a.* = b.*;
  20cc3d:	c5 f8 10 06          	vmovups xmm0,XMMWORD PTR [rsi]
  20cc41:	c4 c1 78 11 03       	vmovups XMMWORD PTR [r11],xmm0
    b.* = tmp;
  20cc46:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  20cc4d:	00 00 
  20cc4f:	c5 fa 7f 06          	vmovdqu XMMWORD PTR [rsi],xmm0
  20cc53:	89 da                	mov    edx,ebx
  20cc55:	49 8b 1e             	mov    rbx,QWORD PTR [r14]
  20cc58:	49 8b 04 24          	mov    rax,QWORD PTR [r12]
  20cc5c:	48 39 c3             	cmp    rbx,rax
  20cc5f:	73 71                	jae    20ccd2 <benchmark.add+0x2492>
  20cc61:	eb 79                	jmp    20ccdc <benchmark.add+0x249c>
  20cc63:	8b 54 24 10          	mov    edx,DWORD PTR [rsp+0x10]
  20cc67:	88 54 24 30          	mov    BYTE PTR [rsp+0x30],dl
  20cc6b:	89 c2                	mov    edx,eax
  20cc6d:	89 54 24 10          	mov    DWORD PTR [rsp+0x10],edx
  20cc71:	48 8b 11             	mov    rdx,QWORD PTR [rcx]
  20cc74:	49 8b 33             	mov    rsi,QWORD PTR [r11]
  20cc77:	48 39 f2             	cmp    rdx,rsi
  20cc7a:	44 89 f0             	mov    eax,r14d
  20cc7d:	72 12                	jb     20cc91 <benchmark.add+0x2451>
  20cc7f:	45 38 e5             	cmp    r13b,r12b
  20cc82:	0f 86 97 01 00 00    	jbe    20ce1f <benchmark.add+0x25df>
  20cc88:	48 39 d6             	cmp    rsi,rdx
  20cc8b:	0f 82 8e 01 00 00    	jb     20ce1f <benchmark.add+0x25df>
    const tmp = a.*;
  20cc91:	c4 c1 78 10 03       	vmovups xmm0,XMMWORD PTR [r11]
  20cc96:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  20cc9d:	00 00 
    a.* = b.*;
  20cc9f:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  20cca3:	c4 c1 78 11 03       	vmovups XMMWORD PTR [r11],xmm0
    b.* = tmp;
  20cca8:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  20ccaf:	00 00 
  20ccb1:	c5 fa 7f 01          	vmovdqu XMMWORD PTR [rcx],xmm0
  20ccb5:	45 89 ee             	mov    r14d,r13d
  20ccb8:	e9 68 01 00 00       	jmp    20ce25 <benchmark.add+0x25e5>
  20ccbd:	0f b6 54 24 10       	movzx  edx,BYTE PTR [rsp+0x10]
  20ccc2:	88 5c 24 10          	mov    BYTE PTR [rsp+0x10],bl
  20ccc6:	49 8b 1e             	mov    rbx,QWORD PTR [r14]
  20ccc9:	49 8b 04 24          	mov    rax,QWORD PTR [r12]
  20cccd:	48 39 c3             	cmp    rbx,rax
  20ccd0:	72 0a                	jb     20ccdc <benchmark.add+0x249c>
  20ccd2:	45 38 c8             	cmp    r8b,r9b
  20ccd5:	76 30                	jbe    20cd07 <benchmark.add+0x24c7>
  20ccd7:	48 39 d8             	cmp    rax,rbx
  20ccda:	72 2b                	jb     20cd07 <benchmark.add+0x24c7>
    const tmp = a.*;
  20ccdc:	c4 c1 78 10 04 24    	vmovups xmm0,XMMWORD PTR [r12]
  20cce2:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  20cce9:	00 00 
    a.* = b.*;
  20cceb:	c4 c1 78 10 06       	vmovups xmm0,XMMWORD PTR [r14]
  20ccf0:	c4 c1 78 11 04 24    	vmovups XMMWORD PTR [r12],xmm0
    b.* = tmp;
  20ccf6:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  20ccfd:	00 00 
  20ccff:	c4 c1 7a 7f 06       	vmovdqu XMMWORD PTR [r14],xmm0
  20cd04:	45 89 c1             	mov    r9d,r8d
  20cd07:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  20cd0a:	48 8b 07             	mov    rax,QWORD PTR [rdi]
  20cd0d:	48 39 c1             	cmp    rcx,rax
  20cd10:	0f b6 5c 24 30       	movzx  ebx,BYTE PTR [rsp+0x30]
  20cd15:	72 09                	jb     20cd20 <benchmark.add+0x24e0>
  20cd17:	38 d3                	cmp    bl,dl
  20cd19:	76 29                	jbe    20cd44 <benchmark.add+0x2504>
  20cd1b:	48 39 c8             	cmp    rax,rcx
  20cd1e:	72 24                	jb     20cd44 <benchmark.add+0x2504>
    const tmp = a.*;
  20cd20:	c5 f8 10 07          	vmovups xmm0,XMMWORD PTR [rdi]
  20cd24:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  20cd2b:	00 00 
    a.* = b.*;
  20cd2d:	c5 f8 10 06          	vmovups xmm0,XMMWORD PTR [rsi]
  20cd31:	c5 f8 11 07          	vmovups XMMWORD PTR [rdi],xmm0
    b.* = tmp;
  20cd35:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  20cd3c:	00 00 
  20cd3e:	c5 fa 7f 06          	vmovdqu XMMWORD PTR [rsi],xmm0
  20cd42:	89 d3                	mov    ebx,edx
  20cd44:	49 8b 0e             	mov    rcx,QWORD PTR [r14]
  20cd47:	49 8b 03             	mov    rax,QWORD PTR [r11]
  20cd4a:	48 39 c1             	cmp    rcx,rax
  20cd4d:	72 0c                	jb     20cd5b <benchmark.add+0x251b>
  20cd4f:	44 38 4c 24 10       	cmp    BYTE PTR [rsp+0x10],r9b
  20cd54:	76 31                	jbe    20cd87 <benchmark.add+0x2547>
  20cd56:	48 39 c8             	cmp    rax,rcx
  20cd59:	72 2c                	jb     20cd87 <benchmark.add+0x2547>
    const tmp = a.*;
  20cd5b:	c4 c1 78 10 03       	vmovups xmm0,XMMWORD PTR [r11]
  20cd60:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  20cd67:	00 00 
    a.* = b.*;
  20cd69:	c4 c1 78 10 06       	vmovups xmm0,XMMWORD PTR [r14]
  20cd6e:	c4 c1 78 11 03       	vmovups XMMWORD PTR [r11],xmm0
    b.* = tmp;
  20cd73:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  20cd7a:	00 00 
  20cd7c:	c4 c1 7a 7f 06       	vmovdqu XMMWORD PTR [r14],xmm0
  20cd81:	44 0f b6 4c 24 10    	movzx  r9d,BYTE PTR [rsp+0x10]
  20cd87:	49 8b 17             	mov    rdx,QWORD PTR [r15]
  20cd8a:	48 8b 0f             	mov    rcx,QWORD PTR [rdi]
  20cd8d:	48 39 ca             	cmp    rdx,rcx
  20cd90:	0f b6 44 24 28       	movzx  eax,BYTE PTR [rsp+0x28]
  20cd95:	72 09                	jb     20cda0 <benchmark.add+0x2560>
  20cd97:	38 c3                	cmp    bl,al
  20cd99:	76 2e                	jbe    20cdc9 <benchmark.add+0x2589>
  20cd9b:	48 39 d1             	cmp    rcx,rdx
  20cd9e:	72 29                	jb     20cdc9 <benchmark.add+0x2589>
    const tmp = a.*;
  20cda0:	c5 f8 10 07          	vmovups xmm0,XMMWORD PTR [rdi]
  20cda4:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  20cdab:	00 00 
    a.* = b.*;
  20cdad:	c4 c1 78 10 07       	vmovups xmm0,XMMWORD PTR [r15]
  20cdb2:	c5 f8 11 07          	vmovups XMMWORD PTR [rdi],xmm0
    b.* = tmp;
  20cdb6:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  20cdbd:	00 00 
  20cdbf:	c4 c1 7a 7f 07       	vmovdqu XMMWORD PTR [r15],xmm0
  20cdc4:	48 8b 0f             	mov    rcx,QWORD PTR [rdi]
  20cdc7:	89 c3                	mov    ebx,eax
  20cdc9:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  20cdcc:	48 39 ca             	cmp    rdx,rcx
  20cdcf:	4c 8b 7c 24 60       	mov    r15,QWORD PTR [rsp+0x60]
  20cdd4:	72 12                	jb     20cde8 <benchmark.add+0x25a8>
  20cdd6:	44 38 cb             	cmp    bl,r9b
  20cdd9:	0f 86 21 04 00 00    	jbe    20d200 <benchmark.add+0x29c0>
  20cddf:	48 39 d1             	cmp    rcx,rdx
  20cde2:	0f 82 18 04 00 00    	jb     20d200 <benchmark.add+0x29c0>
    const tmp = a.*;
  20cde8:	c5 f8 10 07          	vmovups xmm0,XMMWORD PTR [rdi]
  20cdec:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  20cdf3:	00 00 
    a.* = b.*;
  20cdf5:	c4 c1 78 10 06       	vmovups xmm0,XMMWORD PTR [r14]
  20cdfa:	c5 f8 11 07          	vmovups XMMWORD PTR [rdi],xmm0
    b.* = tmp;
  20cdfe:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  20ce05:	00 00 
  20ce07:	c4 c1 7a 7f 06       	vmovdqu XMMWORD PTR [r14],xmm0
        return self.decimal >= self.size;
  20ce0c:	4c 3b 94 24 50 01 00 	cmp    r10,QWORD PTR [rsp+0x150]
  20ce13:	00 
  20ce14:	0f 82 c6 f0 ff ff    	jb     20bee0 <benchmark.add+0x16a0>
  20ce1a:	e9 20 04 00 00       	jmp    20d23f <benchmark.add+0x29ff>
  20ce1f:	45 89 e6             	mov    r14d,r12d
  20ce22:	45 89 ec             	mov    r12d,r13d
  20ce25:	49 8b 10             	mov    rdx,QWORD PTR [r8]
  20ce28:	48 8b 37             	mov    rsi,QWORD PTR [rdi]
  20ce2b:	48 39 f2             	cmp    rdx,rsi
  20ce2e:	4c 8b 6c 24 20       	mov    r13,QWORD PTR [rsp+0x20]
    if (lessThan(items[y], items[x]) or ((order.*)[x] > (order.*)[y] and !lessThan(items[x], items[y]))) {
  20ce33:	72 0b                	jb     20ce40 <benchmark.add+0x2600>
  20ce35:	38 44 24 28          	cmp    BYTE PTR [rsp+0x28],al
  20ce39:	76 2d                	jbe    20ce68 <benchmark.add+0x2628>
  20ce3b:	48 39 d6             	cmp    rsi,rdx
  20ce3e:	72 28                	jb     20ce68 <benchmark.add+0x2628>
    const tmp = a.*;
  20ce40:	c5 f8 10 07          	vmovups xmm0,XMMWORD PTR [rdi]
  20ce44:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  20ce4b:	00 00 
    a.* = b.*;
  20ce4d:	c4 c1 78 10 00       	vmovups xmm0,XMMWORD PTR [r8]
  20ce52:	c5 f8 11 07          	vmovups XMMWORD PTR [rdi],xmm0
    b.* = tmp;
  20ce56:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  20ce5d:	00 00 
  20ce5f:	c4 c1 7a 7f 00       	vmovdqu XMMWORD PTR [r8],xmm0
  20ce64:	89 44 24 28          	mov    DWORD PTR [rsp+0x28],eax
  20ce68:	48 8b 03             	mov    rax,QWORD PTR [rbx]
  20ce6b:	48 8b 53 40          	mov    rdx,QWORD PTR [rbx+0x40]
  20ce6f:	48 39 c2             	cmp    rdx,rax
  20ce72:	45 89 f0             	mov    r8d,r14d
  20ce75:	72 0c                	jb     20ce83 <benchmark.add+0x2643>
  20ce77:	44 38 64 24 30       	cmp    BYTE PTR [rsp+0x30],r12b
  20ce7c:	76 2e                	jbe    20ceac <benchmark.add+0x266c>
  20ce7e:	48 39 d0             	cmp    rax,rdx
  20ce81:	72 29                	jb     20ceac <benchmark.add+0x266c>
    const tmp = a.*;
  20ce83:	c5 f8 10 03          	vmovups xmm0,XMMWORD PTR [rbx]
  20ce87:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  20ce8e:	00 00 
    a.* = b.*;
  20ce90:	c4 c1 78 10 03       	vmovups xmm0,XMMWORD PTR [r11]
  20ce95:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
    b.* = tmp;
  20ce99:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  20cea0:	00 00 
  20cea2:	c4 c1 7a 7f 03       	vmovdqu XMMWORD PTR [r11],xmm0
  20cea7:	45 89 e6             	mov    r14d,r12d
  20ceaa:	eb 0b                	jmp    20ceb7 <benchmark.add+0x2677>
  20ceac:	44 0f b6 74 24 30    	movzx  r14d,BYTE PTR [rsp+0x30]
  20ceb2:	44 88 64 24 30       	mov    BYTE PTR [rsp+0x30],r12b
  20ceb7:	48 8b 11             	mov    rdx,QWORD PTR [rcx]
  20ceba:	49 8b 07             	mov    rax,QWORD PTR [r15]
  20cebd:	48 39 c2             	cmp    rdx,rax
  20cec0:	44 8b 64 24 28       	mov    r12d,DWORD PTR [rsp+0x28]
  20cec5:	72 0c                	jb     20ced3 <benchmark.add+0x2693>
  20cec7:	44 38 44 24 10       	cmp    BYTE PTR [rsp+0x10],r8b
  20cecc:	76 3d                	jbe    20cf0b <benchmark.add+0x26cb>
  20cece:	48 39 d0             	cmp    rax,rdx
  20ced1:	72 38                	jb     20cf0b <benchmark.add+0x26cb>
    const tmp = a.*;
  20ced3:	c4 c1 78 10 07       	vmovups xmm0,XMMWORD PTR [r15]
  20ced8:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  20cedf:	00 00 
    a.* = b.*;
  20cee1:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  20cee5:	c4 c1 78 11 07       	vmovups XMMWORD PTR [r15],xmm0
    b.* = tmp;
  20ceea:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  20cef1:	00 00 
  20cef3:	c5 fa 7f 01          	vmovdqu XMMWORD PTR [rcx],xmm0
  20cef7:	8b 44 24 10          	mov    eax,DWORD PTR [rsp+0x10]
  20cefb:	89 c2                	mov    edx,eax
  20cefd:	48 8b 03             	mov    rax,QWORD PTR [rbx]
  20cf00:	48 8b 73 30          	mov    rsi,QWORD PTR [rbx+0x30]
  20cf04:	48 39 c6             	cmp    rsi,rax
  20cf07:	73 18                	jae    20cf21 <benchmark.add+0x26e1>
  20cf09:	eb 22                	jmp    20cf2d <benchmark.add+0x26ed>
  20cf0b:	44 89 c2             	mov    edx,r8d
  20cf0e:	8b 44 24 10          	mov    eax,DWORD PTR [rsp+0x10]
  20cf12:	41 89 c0             	mov    r8d,eax
  20cf15:	48 8b 03             	mov    rax,QWORD PTR [rbx]
  20cf18:	48 8b 73 30          	mov    rsi,QWORD PTR [rbx+0x30]
  20cf1c:	48 39 c6             	cmp    rsi,rax
  20cf1f:	72 0c                	jb     20cf2d <benchmark.add+0x26ed>
  20cf21:	44 3a 74 24 18       	cmp    r14b,BYTE PTR [rsp+0x18]
  20cf26:	76 2e                	jbe    20cf56 <benchmark.add+0x2716>
  20cf28:	48 39 f0             	cmp    rax,rsi
  20cf2b:	72 29                	jb     20cf56 <benchmark.add+0x2716>
    const tmp = a.*;
  20cf2d:	c5 f8 10 03          	vmovups xmm0,XMMWORD PTR [rbx]
  20cf31:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  20cf38:	00 00 
    a.* = b.*;
  20cf3a:	c4 c1 78 10 01       	vmovups xmm0,XMMWORD PTR [r9]
  20cf3f:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
    b.* = tmp;
  20cf43:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  20cf4a:	00 00 
  20cf4c:	c4 c1 7a 7f 01       	vmovdqu XMMWORD PTR [r9],xmm0
  20cf51:	44 88 74 24 18       	mov    BYTE PTR [rsp+0x18],r14b
  20cf56:	48 8b 01             	mov    rax,QWORD PTR [rcx]
  20cf59:	48 8b 37             	mov    rsi,QWORD PTR [rdi]
  20cf5c:	48 39 f0             	cmp    rax,rsi
  20cf5f:	72 0a                	jb     20cf6b <benchmark.add+0x272b>
  20cf61:	41 38 d4             	cmp    r12b,dl
  20cf64:	76 2a                	jbe    20cf90 <benchmark.add+0x2750>
  20cf66:	48 39 c6             	cmp    rsi,rax
  20cf69:	72 25                	jb     20cf90 <benchmark.add+0x2750>
    const tmp = a.*;
  20cf6b:	c5 f8 10 07          	vmovups xmm0,XMMWORD PTR [rdi]
  20cf6f:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  20cf76:	00 00 
    a.* = b.*;
  20cf78:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  20cf7c:	c5 f8 11 07          	vmovups XMMWORD PTR [rdi],xmm0
    b.* = tmp;
  20cf80:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  20cf87:	00 00 
  20cf89:	c5 fa 7f 01          	vmovdqu XMMWORD PTR [rcx],xmm0
  20cf8d:	41 89 d4             	mov    r12d,edx
  20cf90:	49 8b 01             	mov    rax,QWORD PTR [r9]
  20cf93:	49 8b 0f             	mov    rcx,QWORD PTR [r15]
  20cf96:	48 39 c8             	cmp    rax,rcx
  20cf99:	72 0c                	jb     20cfa7 <benchmark.add+0x2767>
  20cf9b:	44 3a 44 24 18       	cmp    r8b,BYTE PTR [rsp+0x18]
  20cfa0:	76 30                	jbe    20cfd2 <benchmark.add+0x2792>
  20cfa2:	48 39 c1             	cmp    rcx,rax
  20cfa5:	72 2b                	jb     20cfd2 <benchmark.add+0x2792>
    const tmp = a.*;
  20cfa7:	c4 c1 78 10 07       	vmovups xmm0,XMMWORD PTR [r15]
  20cfac:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  20cfb3:	00 00 
    a.* = b.*;
  20cfb5:	c4 c1 78 10 01       	vmovups xmm0,XMMWORD PTR [r9]
  20cfba:	c4 c1 78 11 07       	vmovups XMMWORD PTR [r15],xmm0
    b.* = tmp;
  20cfbf:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  20cfc6:	00 00 
  20cfc8:	c4 c1 7a 7f 01       	vmovdqu XMMWORD PTR [r9],xmm0
  20cfcd:	44 88 44 24 18       	mov    BYTE PTR [rsp+0x18],r8b
  20cfd2:	49 8b 0b             	mov    rcx,QWORD PTR [r11]
  20cfd5:	48 8b 07             	mov    rax,QWORD PTR [rdi]
  20cfd8:	48 39 c1             	cmp    rcx,rax
  20cfdb:	4c 8b 7c 24 60       	mov    r15,QWORD PTR [rsp+0x60]
  20cfe0:	72 0c                	jb     20cfee <benchmark.add+0x27ae>
  20cfe2:	44 3a 64 24 30       	cmp    r12b,BYTE PTR [rsp+0x30]
  20cfe7:	76 34                	jbe    20d01d <benchmark.add+0x27dd>
  20cfe9:	48 39 c8             	cmp    rax,rcx
  20cfec:	72 2f                	jb     20d01d <benchmark.add+0x27dd>
    const tmp = a.*;
  20cfee:	c5 f8 10 07          	vmovups xmm0,XMMWORD PTR [rdi]
  20cff2:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  20cff9:	00 00 
    a.* = b.*;
  20cffb:	c4 c1 78 10 03       	vmovups xmm0,XMMWORD PTR [r11]
  20d000:	c5 f8 11 07          	vmovups XMMWORD PTR [rdi],xmm0
    b.* = tmp;
  20d004:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  20d00b:	00 00 
  20d00d:	c4 c1 7a 7f 03       	vmovdqu XMMWORD PTR [r11],xmm0
  20d012:	48 8b 07             	mov    rax,QWORD PTR [rdi]
  20d015:	0f b6 4c 24 30       	movzx  ecx,BYTE PTR [rsp+0x30]
  20d01a:	41 89 cc             	mov    r12d,ecx
  20d01d:	49 8b 09             	mov    rcx,QWORD PTR [r9]
  20d020:	48 39 c1             	cmp    rcx,rax
  20d023:	72 14                	jb     20d039 <benchmark.add+0x27f9>
  20d025:	44 3a 64 24 18       	cmp    r12b,BYTE PTR [rsp+0x18]
  20d02a:	0f 86 d0 01 00 00    	jbe    20d200 <benchmark.add+0x29c0>
  20d030:	48 39 c8             	cmp    rax,rcx
  20d033:	0f 82 c7 01 00 00    	jb     20d200 <benchmark.add+0x29c0>
    const tmp = a.*;
  20d039:	c5 f8 10 07          	vmovups xmm0,XMMWORD PTR [rdi]
  20d03d:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  20d044:	00 00 
    a.* = b.*;
  20d046:	c4 c1 78 10 01       	vmovups xmm0,XMMWORD PTR [r9]
  20d04b:	c5 f8 11 07          	vmovups XMMWORD PTR [rdi],xmm0
    b.* = tmp;
  20d04f:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  20d056:	00 00 
  20d058:	c4 c1 7a 7f 01       	vmovdqu XMMWORD PTR [r9],xmm0
        return self.decimal >= self.size;
  20d05d:	4c 3b 94 24 50 01 00 	cmp    r10,QWORD PTR [rsp+0x150]
  20d064:	00 
  20d065:	0f 82 75 ee ff ff    	jb     20bee0 <benchmark.add+0x16a0>
  20d06b:	e9 cf 01 00 00       	jmp    20d23f <benchmark.add+0x29ff>
  20d070:	44 0f b6 74 24 10    	movzx  r14d,BYTE PTR [rsp+0x10]
  20d076:	48 8b 11             	mov    rdx,QWORD PTR [rcx]
  20d079:	49 8b 00             	mov    rax,QWORD PTR [r8]
  20d07c:	48 39 c2             	cmp    rdx,rax
    if (lessThan(items[y], items[x]) or ((order.*)[x] > (order.*)[y] and !lessThan(items[x], items[y]))) {
  20d07f:	72 0a                	jb     20d08b <benchmark.add+0x284b>
  20d081:	45 38 eb             	cmp    r11b,r13b
  20d084:	76 2c                	jbe    20d0b2 <benchmark.add+0x2872>
  20d086:	48 39 d0             	cmp    rax,rdx
  20d089:	72 27                	jb     20d0b2 <benchmark.add+0x2872>
    const tmp = a.*;
  20d08b:	c4 c1 78 10 00       	vmovups xmm0,XMMWORD PTR [r8]
  20d090:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  20d097:	00 00 
    a.* = b.*;
  20d099:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  20d09d:	c4 c1 78 11 00       	vmovups XMMWORD PTR [r8],xmm0
    b.* = tmp;
  20d0a2:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  20d0a9:	00 00 
  20d0ab:	c5 fa 7f 01          	vmovdqu XMMWORD PTR [rcx],xmm0
  20d0af:	45 89 eb             	mov    r11d,r13d
  20d0b2:	48 8b 0b             	mov    rcx,QWORD PTR [rbx]
  20d0b5:	48 8b 43 30          	mov    rax,QWORD PTR [rbx+0x30]
  20d0b9:	48 39 c8             	cmp    rax,rcx
  20d0bc:	4c 8b 6c 24 20       	mov    r13,QWORD PTR [rsp+0x20]
  20d0c1:	72 0a                	jb     20d0cd <benchmark.add+0x288d>
  20d0c3:	45 38 e7             	cmp    r15b,r12b
  20d0c6:	76 2a                	jbe    20d0f2 <benchmark.add+0x28b2>
  20d0c8:	48 39 c1             	cmp    rcx,rax
  20d0cb:	72 25                	jb     20d0f2 <benchmark.add+0x28b2>
    const tmp = a.*;
  20d0cd:	c5 f8 10 03          	vmovups xmm0,XMMWORD PTR [rbx]
  20d0d1:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  20d0d8:	00 00 
    a.* = b.*;
  20d0da:	c5 f8 10 06          	vmovups xmm0,XMMWORD PTR [rsi]
  20d0de:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
    b.* = tmp;
  20d0e2:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  20d0e9:	00 00 
  20d0eb:	c5 fa 7f 06          	vmovdqu XMMWORD PTR [rsi],xmm0
  20d0ef:	45 89 fc             	mov    r12d,r15d
  20d0f2:	48 8b 0f             	mov    rcx,QWORD PTR [rdi]
  20d0f5:	49 8b 01             	mov    rax,QWORD PTR [r9]
  20d0f8:	48 39 c1             	cmp    rcx,rax
  20d0fb:	4c 8b 7c 24 60       	mov    r15,QWORD PTR [rsp+0x60]
  20d100:	72 0c                	jb     20d10e <benchmark.add+0x28ce>
  20d102:	44 38 74 24 18       	cmp    BYTE PTR [rsp+0x18],r14b
  20d107:	76 3c                	jbe    20d145 <benchmark.add+0x2905>
  20d109:	48 39 c8             	cmp    rax,rcx
  20d10c:	72 37                	jb     20d145 <benchmark.add+0x2905>
    const tmp = a.*;
  20d10e:	c4 c1 78 10 01       	vmovups xmm0,XMMWORD PTR [r9]
  20d113:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  20d11a:	00 00 
    a.* = b.*;
  20d11c:	c5 f8 10 07          	vmovups xmm0,XMMWORD PTR [rdi]
  20d120:	c4 c1 78 11 01       	vmovups XMMWORD PTR [r9],xmm0
    b.* = tmp;
  20d125:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  20d12c:	00 00 
  20d12e:	c5 fa 7f 07          	vmovdqu XMMWORD PTR [rdi],xmm0
  20d132:	48 8b 0f             	mov    rcx,QWORD PTR [rdi]
  20d135:	8b 44 24 18          	mov    eax,DWORD PTR [rsp+0x18]
  20d139:	89 c2                	mov    edx,eax
  20d13b:	49 8b 00             	mov    rax,QWORD PTR [r8]
  20d13e:	48 39 c1             	cmp    rcx,rax
  20d141:	73 14                	jae    20d157 <benchmark.add+0x2917>
  20d143:	eb 1c                	jmp    20d161 <benchmark.add+0x2921>
  20d145:	44 89 f2             	mov    edx,r14d
  20d148:	8b 44 24 18          	mov    eax,DWORD PTR [rsp+0x18]
  20d14c:	41 89 c6             	mov    r14d,eax
  20d14f:	49 8b 00             	mov    rax,QWORD PTR [r8]
  20d152:	48 39 c1             	cmp    rcx,rax
  20d155:	72 0a                	jb     20d161 <benchmark.add+0x2921>
  20d157:	41 38 d3             	cmp    r11b,dl
  20d15a:	76 2c                	jbe    20d188 <benchmark.add+0x2948>
  20d15c:	48 39 c8             	cmp    rax,rcx
  20d15f:	72 27                	jb     20d188 <benchmark.add+0x2948>
    const tmp = a.*;
  20d161:	c4 c1 78 10 00       	vmovups xmm0,XMMWORD PTR [r8]
  20d166:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  20d16d:	00 00 
    a.* = b.*;
  20d16f:	c5 f8 10 07          	vmovups xmm0,XMMWORD PTR [rdi]
  20d173:	c4 c1 78 11 00       	vmovups XMMWORD PTR [r8],xmm0
    b.* = tmp;
  20d178:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  20d17f:	00 00 
  20d181:	c5 fa 7f 07          	vmovdqu XMMWORD PTR [rdi],xmm0
  20d185:	41 89 d3             	mov    r11d,edx
  20d188:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  20d18b:	49 8b 01             	mov    rax,QWORD PTR [r9]
  20d18e:	48 39 c1             	cmp    rcx,rax
  20d191:	72 0a                	jb     20d19d <benchmark.add+0x295d>
  20d193:	45 38 e6             	cmp    r14b,r12b
  20d196:	76 2f                	jbe    20d1c7 <benchmark.add+0x2987>
  20d198:	48 39 c8             	cmp    rax,rcx
  20d19b:	72 2a                	jb     20d1c7 <benchmark.add+0x2987>
    const tmp = a.*;
  20d19d:	c4 c1 78 10 01       	vmovups xmm0,XMMWORD PTR [r9]
  20d1a2:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  20d1a9:	00 00 
    a.* = b.*;
  20d1ab:	c5 f8 10 06          	vmovups xmm0,XMMWORD PTR [rsi]
  20d1af:	c4 c1 78 11 01       	vmovups XMMWORD PTR [r9],xmm0
    b.* = tmp;
  20d1b4:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  20d1bb:	00 00 
  20d1bd:	c5 fa 7f 06          	vmovdqu XMMWORD PTR [rsi],xmm0
  20d1c1:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  20d1c4:	45 89 f4             	mov    r12d,r14d
  20d1c7:	49 8b 10             	mov    rdx,QWORD PTR [r8]
  20d1ca:	48 39 d1             	cmp    rcx,rdx
  20d1cd:	72 0a                	jb     20d1d9 <benchmark.add+0x2999>
  20d1cf:	45 38 e3             	cmp    r11b,r12b
  20d1d2:	76 2c                	jbe    20d200 <benchmark.add+0x29c0>
  20d1d4:	48 39 ca             	cmp    rdx,rcx
  20d1d7:	72 27                	jb     20d200 <benchmark.add+0x29c0>
    const tmp = a.*;
  20d1d9:	c4 c1 78 10 00       	vmovups xmm0,XMMWORD PTR [r8]
  20d1de:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  20d1e5:	00 00 
    a.* = b.*;
  20d1e7:	c5 f8 10 06          	vmovups xmm0,XMMWORD PTR [rsi]
  20d1eb:	c4 c1 78 11 00       	vmovups XMMWORD PTR [r8],xmm0
    b.* = tmp;
  20d1f0:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  20d1f7:	00 00 
  20d1f9:	c5 fa 7f 06          	vmovdqu XMMWORD PTR [rsi],xmm0
  20d1fd:	0f 1f 00             	nop    DWORD PTR [rax]
        return self.decimal >= self.size;
  20d200:	4c 3b 94 24 50 01 00 	cmp    r10,QWORD PTR [rsp+0x150]
  20d207:	00 
    while (!iterator.finished()) {
  20d208:	0f 82 d2 ec ff ff    	jb     20bee0 <benchmark.add+0x16a0>
  20d20e:	eb 2f                	jmp    20d23f <benchmark.add+0x29ff>
  20d210:	8b 44 24 18          	mov    eax,DWORD PTR [rsp+0x18]
  20d214:	88 44 24 38          	mov    BYTE PTR [rsp+0x38],al
  20d218:	0f b6 44 24 10       	movzx  eax,BYTE PTR [rsp+0x10]
  20d21d:	89 44 24 18          	mov    DWORD PTR [rsp+0x18],eax
  20d221:	45 89 c8             	mov    r8d,r9d
  20d224:	e9 f5 f5 ff ff       	jmp    20c81e <benchmark.add+0x1fde>
  20d229:	8b 44 24 18          	mov    eax,DWORD PTR [rsp+0x18]
  20d22d:	88 44 24 38          	mov    BYTE PTR [rsp+0x38],al
  20d231:	0f b6 44 24 10       	movzx  eax,BYTE PTR [rsp+0x10]
  20d236:	89 44 24 18          	mov    DWORD PTR [rsp+0x18],eax
  20d23a:	e9 df f5 ff ff       	jmp    20c81e <benchmark.add+0x1fde>
    if (items.len < 8) return;
  20d23f:	48 83 7c 24 50 08    	cmp    QWORD PTR [rsp+0x50],0x8
  20d245:	48 8b 9c 24 38 01 00 	mov    rbx,QWORD PTR [rsp+0x138]
  20d24c:	00 
  20d24d:	4c 8b 84 24 f8 00 00 	mov    r8,QWORD PTR [rsp+0xf8]
  20d254:	00 
  20d255:	0f 82 80 6f 00 00    	jb     2141db <benchmark.add+0x999b>
  20d25b:	4c 8b 8c 24 30 01 00 	mov    r9,QWORD PTR [rsp+0x130]
  20d262:	00 
        if (iterator.length() < cache.len) {
  20d263:	49 81 f8 00 02 00 00 	cmp    r8,0x200
  20d26a:	4c 89 84 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],r8
  20d271:	00 
  20d272:	4c 89 8c 24 30 01 00 	mov    QWORD PTR [rsp+0x130],r9
  20d279:	00 
  20d27a:	0f 82 a9 49 00 00    	jb     211c29 <benchmark.add+0x73e9>
  20d280:	48 b9 00 00 00 00 00 	movabs rcx,0x4000000000000000
  20d287:	00 00 40 
  20d28a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  20d290:	48 89 c8             	mov    rax,rcx
    var res: T = 0;
    var one: T = 1 << (T.bit_count - 2);

    // "one" starts at the highest power of four <= than the argument.
    while (one > op) {
        one >>= 2;
  20d293:	48 c1 e9 02          	shr    rcx,0x2
    while (one > op) {
  20d297:	4c 39 c0             	cmp    rax,r8
  20d29a:	77 f4                	ja     20d290 <benchmark.add+0x2a50>
  20d29c:	31 c9                	xor    ecx,ecx
    }

    while (one != 0) {
  20d29e:	48 85 c0             	test   rax,rax
  20d2a1:	74 29                	je     20d2cc <benchmark.add+0x2a8c>
  20d2a3:	4c 89 c2             	mov    rdx,r8
  20d2a6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  20d2ad:	00 00 00 
        if (op >= res + one) {
  20d2b0:	48 8d 3c 01          	lea    rdi,[rcx+rax*1]
  20d2b4:	48 89 d6             	mov    rsi,rdx
  20d2b7:	48 29 fe             	sub    rsi,rdi
  20d2ba:	72 07                	jb     20d2c3 <benchmark.add+0x2a83>
            op -= res + one;
            res += 2 * one;
  20d2bc:	48 8d 0c 41          	lea    rcx,[rcx+rax*2]
  20d2c0:	48 89 f2             	mov    rdx,rsi
        }
        res >>= 1;
  20d2c3:	48 d1 e9             	shr    rcx,1
        one >>= 2;
  20d2c6:	48 c1 e8 02          	shr    rax,0x2
    while (one != 0) {
  20d2ca:	75 e4                	jne    20d2b0 <benchmark.add+0x2a70>
            var block_size: usize = math.sqrt(iterator.length());
  20d2cc:	89 c9                	mov    ecx,ecx
  20d2ce:	4c 89 c0             	mov    rax,r8
  20d2d1:	48 c1 e8 20          	shr    rax,0x20
  20d2d5:	74 0d                	je     20d2e4 <benchmark.add+0x2aa4>
  20d2d7:	31 d2                	xor    edx,edx
  20d2d9:	4c 89 c0             	mov    rax,r8
  20d2dc:	48 f7 f1             	div    rcx
  20d2df:	49 89 c3             	mov    r11,rax
  20d2e2:	eb 0a                	jmp    20d2ee <benchmark.add+0x2aae>
  20d2e4:	31 d2                	xor    edx,edx
  20d2e6:	44 89 c0             	mov    eax,r8d
  20d2e9:	f7 f1                	div    ecx
  20d2eb:	41 89 c3             	mov    r11d,eax
            if (block_size <= cache.len) {
  20d2ee:	81 f9 00 02 00 00    	cmp    ecx,0x200
  20d2f4:	41 0f 97 c2          	seta   r10b
            find = buffer_size + buffer_size;
  20d2f8:	4b 8d 3c 1b          	lea    rdi,[r11+r11*1]
  20d2fc:	48 83 c7 02          	add    rdi,0x2
            } else if (find > iterator.length()) {
  20d300:	4c 39 c7             	cmp    rdi,r8
  20d303:	0f 97 c0             	seta   al
            var buffer_size = iterator.length() / block_size + 1;
  20d306:	49 8d 53 01          	lea    rdx,[r11+0x1]
  20d30a:	48 89 7c 24 38       	mov    QWORD PTR [rsp+0x38],rdi
            if (block_size <= cache.len) {
  20d30f:	48 0f 47 fa          	cmova  rdi,rdx
  20d313:	48 89 8c 24 58 01 00 	mov    QWORD PTR [rsp+0x158],rcx
  20d31a:	00 
  20d31b:	81 f9 01 02 00 00    	cmp    ecx,0x201
  20d321:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
            var pull = []Pull{
  20d325:	c5 fe 7f 84 24 b0 00 	vmovdqu YMMWORD PTR [rsp+0xb0],ymm0
  20d32c:	00 00 
  20d32e:	c5 fd 7f 84 24 a0 00 	vmovdqa YMMWORD PTR [rsp+0xa0],ymm0
  20d335:	00 00 
  20d337:	c5 fd 7f 84 24 80 00 	vmovdqa YMMWORD PTR [rsp+0x80],ymm0
  20d33e:	00 00 
  20d340:	48 89 54 24 78       	mov    QWORD PTR [rsp+0x78],rdx
            if (block_size <= cache.len) {
  20d345:	48 0f 42 fa          	cmovb  rdi,rdx
  20d349:	44 20 d0             	and    al,r10b
  20d34c:	89 84 24 00 01 00 00 	mov    DWORD PTR [rsp+0x100],eax
  20d353:	31 c0                	xor    eax,eax
  20d355:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  20d35a:	45 31 ed             	xor    r13d,r13d
  20d35d:	31 f6                	xor    esi,esi
  20d35f:	31 c0                	xor    eax,eax
  20d361:	48 89 84 24 d8 00 00 	mov    QWORD PTR [rsp+0xd8],rax
  20d368:	00 
  20d369:	31 c0                	xor    eax,eax
  20d36b:	48 89 44 24 40       	mov    QWORD PTR [rsp+0x40],rax
  20d370:	4c 89 5c 24 18       	mov    QWORD PTR [rsp+0x18],r11
  20d375:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20d37c:	00 00 00 00 
        self.decimal += self.decimal_step;
  20d380:	4b 8d 04 28          	lea    rax,[r8+r13*1]
        self.numerator += self.numerator_step;
  20d384:	4c 01 ce             	add    rsi,r9
        if (self.numerator >= self.denominator) {
  20d387:	45 31 f6             	xor    r14d,r14d
  20d38a:	48 39 de             	cmp    rsi,rbx
  20d38d:	41 0f 93 c6          	setae  r14b
  20d391:	48 89 d9             	mov    rcx,rbx
  20d394:	ba 00 00 00 00       	mov    edx,0x0
  20d399:	48 0f 42 ca          	cmovb  rcx,rdx
  20d39d:	48 29 ce             	sub    rsi,rcx
  20d3a0:	49 01 c6             	add    r14,rax
        self.decimal += self.decimal_step;
  20d3a3:	4b 8d 04 06          	lea    rax,[r14+r8*1]
        self.numerator += self.numerator_step;
  20d3a7:	48 89 84 24 d0 00 00 	mov    QWORD PTR [rsp+0xd0],rax
  20d3ae:	00 
  20d3af:	4c 01 ce             	add    rsi,r9
        if (self.numerator >= self.denominator) {
  20d3b2:	31 c0                	xor    eax,eax
  20d3b4:	48 89 74 24 30       	mov    QWORD PTR [rsp+0x30],rsi
  20d3b9:	48 39 de             	cmp    rsi,rbx
  20d3bc:	0f 93 c0             	setae  al
  20d3bf:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  20d3c4:	48 0f 42 da          	cmovb  rbx,rdx
  20d3c8:	48 89 5c 24 28       	mov    QWORD PTR [rsp+0x28],rbx
                while (count < find) : ({
  20d3cd:	48 83 ff 02          	cmp    rdi,0x2
  20d3d1:	4c 89 e8             	mov    rax,r13
  20d3d4:	48 89 44 24 58       	mov    QWORD PTR [rsp+0x58],rax
  20d3d9:	0f 82 01 01 00 00    	jb     20d4e0 <benchmark.add+0x2ca0>
  20d3df:	48 8b 44 24 48       	mov    rax,QWORD PTR [rsp+0x48]
  20d3e4:	48 89 44 24 20       	mov    QWORD PTR [rsp+0x20],rax
  20d3e9:	4c 8d 7f ff          	lea    r15,[rdi-0x1]
  20d3ed:	41 bc 01 00 00 00    	mov    r12d,0x1
  20d3f3:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20d3fa:	84 00 00 00 00 00 
  20d400:	48 89 fb             	mov    rbx,rdi
                    index = findLastForward(T, items, items[last], Range.init(last + 1, A.end), lessThan, find - count);
  20d403:	4c 89 ee             	mov    rsi,r13
  20d406:	48 c1 e6 04          	shl    rsi,0x4
  20d40a:	48 03 74 24 20       	add    rsi,QWORD PTR [rsp+0x20]
  20d40f:	49 8d 55 01          	lea    rdx,[r13+0x1]
  20d413:	48 8d 7c 24 48       	lea    rdi,[rsp+0x48]
  20d418:	4c 89 f1             	mov    rcx,r14
  20d41b:	4d 89 f8             	mov    r8,r15
  20d41e:	c5 f8 77             	vzeroupper 
  20d421:	e8 0a 8e 00 00       	call   216230 <findLastForward>
                    if (index == A.end) break;
  20d426:	4c 39 f0             	cmp    rax,r14
  20d429:	0f 84 23 01 00 00    	je     20d552 <benchmark.add+0x2d12>
                    count += 1;
  20d42f:	49 83 c4 01          	add    r12,0x1
                while (count < find) : ({
  20d433:	49 83 c7 ff          	add    r15,0xffffffffffffffff
  20d437:	49 89 c5             	mov    r13,rax
  20d43a:	48 89 df             	mov    rdi,rbx
  20d43d:	4c 39 e7             	cmp    rdi,r12
  20d440:	77 be                	ja     20d400 <benchmark.add+0x2bc0>
  20d442:	48 8b 94 24 d0 00 00 	mov    rdx,QWORD PTR [rsp+0xd0]
  20d449:	00 
  20d44a:	48 03 54 24 10       	add    rdx,QWORD PTR [rsp+0x10]
                if (count >= buffer_size) {
  20d44f:	4c 3b 64 24 18       	cmp    r12,QWORD PTR [rsp+0x18]
  20d454:	0f 86 a7 00 00 00    	jbe    20d501 <benchmark.add+0x2cc1>
                    pull[pull_index] = Pull{
  20d45a:	48 8b 4c 24 60       	mov    rcx,QWORD PTR [rsp+0x60]
  20d45f:	48 8d 0c 89          	lea    rcx,[rcx+rcx*4]
  20d463:	48 89 84 cc 80 00 00 	mov    QWORD PTR [rsp+rcx*8+0x80],rax
  20d46a:	00 
  20d46b:	48 8b 44 24 58       	mov    rax,QWORD PTR [rsp+0x58]
  20d470:	48 89 84 cc 88 00 00 	mov    QWORD PTR [rsp+rcx*8+0x88],rax
  20d477:	00 
  20d478:	4c 89 a4 cc 90 00 00 	mov    QWORD PTR [rsp+rcx*8+0x90],r12
  20d47f:	00 
  20d480:	48 89 84 cc 98 00 00 	mov    QWORD PTR [rsp+rcx*8+0x98],rax
  20d487:	00 
  20d488:	48 89 94 cc a0 00 00 	mov    QWORD PTR [rsp+rcx*8+0xa0],rdx
  20d48f:	00 
  20d490:	48 8b 4c 24 38       	mov    rcx,QWORD PTR [rsp+0x38]
                    if (count == buffer_size + buffer_size) {
  20d495:	49 39 cc             	cmp    r12,rcx
  20d498:	0f 84 2e 05 00 00    	je     20d9cc <benchmark.add+0x318c>
  20d49e:	49 01 c4             	add    r12,rax
                    } else if (find == buffer_size + buffer_size) {
  20d4a1:	48 39 cf             	cmp    rdi,rcx
  20d4a4:	0f 85 c8 00 00 00    	jne    20d572 <benchmark.add+0x2d32>
  20d4aa:	48 89 84 24 d8 00 00 	mov    QWORD PTR [rsp+0xd8],rax
  20d4b1:	00 
  20d4b2:	b8 01 00 00 00       	mov    eax,0x1
  20d4b7:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  20d4bc:	48 8b 7c 24 78       	mov    rdi,QWORD PTR [rsp+0x78]
  20d4c1:	48 89 94 24 d0 00 00 	mov    QWORD PTR [rsp+0xd0],rdx
  20d4c8:	00 
  20d4c9:	48 8d 52 ff          	lea    rdx,[rdx-0x1]
                while (count < find) : ({
  20d4cd:	48 83 ff 02          	cmp    rdi,0x2
  20d4d1:	72 55                	jb     20d528 <benchmark.add+0x2ce8>
  20d4d3:	e9 4c 01 00 00       	jmp    20d624 <benchmark.add+0x2de4>
  20d4d8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  20d4df:	00 
  20d4e0:	41 bc 01 00 00 00    	mov    r12d,0x1
  20d4e6:	4c 89 e8             	mov    rax,r13
  20d4e9:	48 8b 94 24 d0 00 00 	mov    rdx,QWORD PTR [rsp+0xd0]
  20d4f0:	00 
  20d4f1:	48 03 54 24 10       	add    rdx,QWORD PTR [rsp+0x10]
                if (count >= buffer_size) {
  20d4f6:	4c 3b 64 24 18       	cmp    r12,QWORD PTR [rsp+0x18]
  20d4fb:	0f 87 59 ff ff ff    	ja     20d45a <benchmark.add+0x2c1a>
                } else if (pull_index == 0 and count > buffer1.length()) {
  20d501:	48 83 7c 24 60 00    	cmp    QWORD PTR [rsp+0x60],0x0
  20d507:	0f 84 a3 00 00 00    	je     20d5b0 <benchmark.add+0x2d70>
  20d50d:	4c 8b 64 24 40       	mov    r12,QWORD PTR [rsp+0x40]
  20d512:	48 89 94 24 d0 00 00 	mov    QWORD PTR [rsp+0xd0],rdx
  20d519:	00 
  20d51a:	48 8d 52 ff          	lea    rdx,[rdx-0x1]
                while (count < find) : ({
  20d51e:	48 83 ff 02          	cmp    rdi,0x2
  20d522:	0f 83 fc 00 00 00    	jae    20d624 <benchmark.add+0x2de4>
  20d528:	41 b8 01 00 00 00    	mov    r8d,0x1
  20d52e:	4c 8b 5c 24 18       	mov    r11,QWORD PTR [rsp+0x18]
                if (count >= buffer_size) {
  20d533:	4d 39 d8             	cmp    r8,r11
  20d536:	0f 87 d2 02 00 00    	ja     20d80e <benchmark.add+0x2fce>
                } else if (pull_index == 0 and count > buffer1.length()) {
  20d53c:	48 83 7c 24 60 00    	cmp    QWORD PTR [rsp+0x60],0x0
  20d542:	0f 84 82 03 00 00    	je     20d8ca <benchmark.add+0x308a>
  20d548:	4c 89 64 24 40       	mov    QWORD PTR [rsp+0x40],r12
  20d54d:	e9 40 04 00 00       	jmp    20d992 <benchmark.add+0x3152>
  20d552:	4c 89 e8             	mov    rax,r13
  20d555:	48 89 df             	mov    rdi,rbx
  20d558:	48 8b 94 24 d0 00 00 	mov    rdx,QWORD PTR [rsp+0xd0]
  20d55f:	00 
  20d560:	48 03 54 24 10       	add    rdx,QWORD PTR [rsp+0x10]
                if (count >= buffer_size) {
  20d565:	4c 3b 64 24 18       	cmp    r12,QWORD PTR [rsp+0x18]
  20d56a:	0f 87 ea fe ff ff    	ja     20d45a <benchmark.add+0x2c1a>
  20d570:	eb 8f                	jmp    20d501 <benchmark.add+0x2cc1>
            if (block_size <= cache.len) {
  20d572:	81 bc 24 58 01 00 00 	cmp    DWORD PTR [rsp+0x158],0x201
  20d579:	01 02 00 00 
                    } else if (block_size <= cache.len) {
  20d57d:	0f 82 99 04 00 00    	jb     20da1c <benchmark.add+0x31dc>
                    } else if (find_separately) {
  20d583:	f6 84 24 00 01 00 00 	test   BYTE PTR [rsp+0x100],0x1
  20d58a:	01 
  20d58b:	0f 84 e8 39 00 00    	je     210f79 <benchmark.add+0x6739>
  20d591:	c7 84 24 00 01 00 00 	mov    DWORD PTR [rsp+0x100],0x0
  20d598:	00 00 00 00 
  20d59c:	48 8b 44 24 58       	mov    rax,QWORD PTR [rsp+0x58]
  20d5a1:	48 89 84 24 d8 00 00 	mov    QWORD PTR [rsp+0xd8],rax
  20d5a8:	00 
  20d5a9:	b8 01 00 00 00       	mov    eax,0x1
  20d5ae:	eb 59                	jmp    20d609 <benchmark.add+0x2dc9>
  20d5b0:	48 89 d6             	mov    rsi,rdx
  20d5b3:	48 8b 54 24 40       	mov    rdx,QWORD PTR [rsp+0x40]
        return self.end - self.start;
  20d5b8:	48 89 d1             	mov    rcx,rdx
  20d5bb:	48 2b 8c 24 d8 00 00 	sub    rcx,QWORD PTR [rsp+0xd8]
  20d5c2:	00 
                } else if (pull_index == 0 and count > buffer1.length()) {
  20d5c3:	49 39 cc             	cmp    r12,rcx
  20d5c6:	0f 86 92 03 00 00    	jbe    20d95e <benchmark.add+0x311e>
                    pull[pull_index] = Pull{
  20d5cc:	48 89 84 24 80 00 00 	mov    QWORD PTR [rsp+0x80],rax
  20d5d3:	00 
  20d5d4:	48 8b 44 24 58       	mov    rax,QWORD PTR [rsp+0x58]
  20d5d9:	48 89 84 24 88 00 00 	mov    QWORD PTR [rsp+0x88],rax
  20d5e0:	00 
  20d5e1:	4c 89 a4 24 90 00 00 	mov    QWORD PTR [rsp+0x90],r12
  20d5e8:	00 
  20d5e9:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  20d5f0:	00 
                    buffer1 = Range.init(A.start, A.start + count);
  20d5f1:	49 01 c4             	add    r12,rax
  20d5f4:	48 89 f2             	mov    rdx,rsi
                    pull[pull_index] = Pull{
  20d5f7:	48 89 94 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rdx
  20d5fe:	00 
  20d5ff:	48 89 84 24 d8 00 00 	mov    QWORD PTR [rsp+0xd8],rax
  20d606:	00 
  20d607:	31 c0                	xor    eax,eax
  20d609:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  20d60e:	48 89 94 24 d0 00 00 	mov    QWORD PTR [rsp+0xd0],rdx
  20d615:	00 
  20d616:	48 8d 52 ff          	lea    rdx,[rdx-0x1]
                while (count < find) : ({
  20d61a:	48 83 ff 02          	cmp    rdi,0x2
  20d61e:	0f 82 04 ff ff ff    	jb     20d528 <benchmark.add+0x2ce8>
  20d624:	4c 8b 5c 24 48       	mov    r11,QWORD PTR [rsp+0x48]
  20d629:	49 89 d1             	mov    r9,rdx
  20d62c:	41 b8 01 00 00 00    	mov    r8d,0x1
  20d632:	eb 7c                	jmp    20d6b0 <benchmark.add+0x2e70>
  20d634:	48 89 ce             	mov    rsi,rcx
    if (range.start >= range.end) return range.end;
  20d637:	48 85 c0             	test   rax,rax
  20d63a:	0f 85 18 01 00 00    	jne    20d758 <benchmark.add+0x2f18>
  20d640:	e9 90 01 00 00       	jmp    20d7d5 <benchmark.add+0x2f95>
    while (start < end) {
  20d645:	4c 39 f7             	cmp    rdi,r14
  20d648:	0f 86 e1 02 00 00    	jbe    20d92f <benchmark.add+0x30ef>
  20d64e:	4c 89 f2             	mov    rdx,r14
  20d651:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20d658:	0f 1f 84 00 00 00 00 
  20d65f:	00 
        const mid = start + (end - start) / 2;
  20d660:	48 89 f8             	mov    rax,rdi
  20d663:	48 29 d0             	sub    rax,rdx
  20d666:	48 d1 e8             	shr    rax,1
  20d669:	48 8d 0c 10          	lea    rcx,[rax+rdx*1]
  20d66d:	48 89 ce             	mov    rsi,rcx
  20d670:	48 c1 e6 04          	shl    rsi,0x4
  20d674:	49 39 1c 33          	cmp    QWORD PTR [r11+rsi*1],rbx
        if (lessThan(items[mid], value)) {
  20d678:	72 16                	jb     20d690 <benchmark.add+0x2e50>
  20d67a:	48 89 cf             	mov    rdi,rcx
    while (start < end) {
  20d67d:	48 39 d7             	cmp    rdi,rdx
  20d680:	77 de                	ja     20d660 <benchmark.add+0x2e20>
  20d682:	e9 4e 01 00 00       	jmp    20d7d5 <benchmark.add+0x2f95>
  20d687:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  20d68e:	00 00 
  20d690:	48 01 c2             	add    rdx,rax
  20d693:	48 83 c2 01          	add    rdx,0x1
  20d697:	48 39 d7             	cmp    rdi,rdx
  20d69a:	77 c4                	ja     20d660 <benchmark.add+0x2e20>
  20d69c:	e9 34 01 00 00       	jmp    20d7d5 <benchmark.add+0x2f95>
  20d6a1:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20d6a8:	0f 1f 84 00 00 00 00 
  20d6af:	00 
    if (range.length() == 0) return range.start;
  20d6b0:	4c 89 c8             	mov    rax,r9
  20d6b3:	4c 29 f0             	sub    rax,r14
  20d6b6:	0f 84 8c 02 00 00    	je     20d948 <benchmark.add+0x3108>
  20d6bc:	4d 89 ca             	mov    r10,r9
  20d6bf:	49 c1 e2 04          	shl    r10,0x4
                    index = findFirstBackward(T, items, items[last], Range.init(B.start, last), lessThan, find - count);
  20d6c3:	48 89 f9             	mov    rcx,rdi
  20d6c6:	4c 29 c1             	sub    rcx,r8
  20d6c9:	48 89 c2             	mov    rdx,rax
  20d6cc:	48 09 ca             	or     rdx,rcx
  20d6cf:	48 c1 ea 20          	shr    rdx,0x20
  20d6d3:	74 0b                	je     20d6e0 <benchmark.add+0x2ea0>
  20d6d5:	31 d2                	xor    edx,edx
  20d6d7:	48 f7 f1             	div    rcx
  20d6da:	eb 08                	jmp    20d6e4 <benchmark.add+0x2ea4>
  20d6dc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  20d6e0:	31 d2                	xor    edx,edx
  20d6e2:	f7 f1                	div    ecx
  20d6e4:	49 89 fd             	mov    r13,rdi
  20d6e7:	4d 01 da             	add    r10,r11
    return if (x > y) x else y;
  20d6ea:	48 83 f8 01          	cmp    rax,0x1
  20d6ee:	b9 01 00 00 00       	mov    ecx,0x1
  20d6f3:	48 0f 46 c1          	cmovbe rax,rcx
  20d6f7:	4c 89 ce             	mov    rsi,r9
  20d6fa:	48 29 c6             	sub    rsi,rax
    while (index > range.start and !lessThan(items[index - 1], value)) : (index -= skip) {
  20d6fd:	4c 39 f6             	cmp    rsi,r14
  20d700:	76 4e                	jbe    20d750 <benchmark.add+0x2f10>
  20d702:	49 8b 1a             	mov    rbx,QWORD PTR [r10]
  20d705:	4e 8d 3c 30          	lea    r15,[rax+r14*1]
  20d709:	4c 89 ca             	mov    rdx,r9
  20d70c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  20d710:	48 89 f1             	mov    rcx,rsi
  20d713:	48 8d 79 ff          	lea    rdi,[rcx-0x1]
  20d717:	48 89 fe             	mov    rsi,rdi
  20d71a:	48 c1 e6 04          	shl    rsi,0x4
  20d71e:	49 39 1c 33          	cmp    QWORD PTR [r11+rsi*1],rbx
  20d722:	0f 82 0c ff ff ff    	jb     20d634 <benchmark.add+0x2df4>
        if (index < range.start + skip) {
  20d728:	4c 39 f9             	cmp    rcx,r15
  20d72b:	0f 82 14 ff ff ff    	jb     20d645 <benchmark.add+0x2e05>
  20d731:	48 89 ce             	mov    rsi,rcx
  20d734:	48 29 c6             	sub    rsi,rax
  20d737:	48 89 ca             	mov    rdx,rcx
    while (index > range.start and !lessThan(items[index - 1], value)) : (index -= skip) {
  20d73a:	4c 39 f6             	cmp    rsi,r14
  20d73d:	77 d1                	ja     20d710 <benchmark.add+0x2ed0>
  20d73f:	eb 12                	jmp    20d753 <benchmark.add+0x2f13>
  20d741:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20d748:	0f 1f 84 00 00 00 00 
  20d74f:	00 
  20d750:	4c 89 ca             	mov    rdx,r9
    if (range.start >= range.end) return range.end;
  20d753:	48 85 c0             	test   rax,rax
  20d756:	74 7d                	je     20d7d5 <benchmark.add+0x2f95>
    var end = range.end - 1;
  20d758:	48 83 c2 ff          	add    rdx,0xffffffffffffffff
    while (start < end) {
  20d75c:	48 39 f2             	cmp    rdx,rsi
  20d75f:	76 4b                	jbe    20d7ac <benchmark.add+0x2f6c>
  20d761:	4d 8b 3a             	mov    r15,QWORD PTR [r10]
  20d764:	48 89 d3             	mov    rbx,rdx
  20d767:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  20d76e:	00 00 
        const mid = start + (end - start) / 2;
  20d770:	48 89 d9             	mov    rcx,rbx
  20d773:	48 29 f1             	sub    rcx,rsi
  20d776:	48 d1 e9             	shr    rcx,1
  20d779:	48 8d 04 31          	lea    rax,[rcx+rsi*1]
  20d77d:	48 89 c7             	mov    rdi,rax
  20d780:	48 c1 e7 04          	shl    rdi,0x4
  20d784:	4d 39 3c 3b          	cmp    QWORD PTR [r11+rdi*1],r15
        if (lessThan(items[mid], value)) {
  20d788:	72 16                	jb     20d7a0 <benchmark.add+0x2f60>
  20d78a:	48 89 c3             	mov    rbx,rax
    while (start < end) {
  20d78d:	48 39 f3             	cmp    rbx,rsi
  20d790:	77 de                	ja     20d770 <benchmark.add+0x2f30>
  20d792:	eb 18                	jmp    20d7ac <benchmark.add+0x2f6c>
  20d794:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20d79b:	00 00 00 00 00 
  20d7a0:	48 01 ce             	add    rsi,rcx
  20d7a3:	48 83 c6 01          	add    rsi,0x1
  20d7a7:	48 39 f3             	cmp    rbx,rsi
  20d7aa:	77 c4                	ja     20d770 <benchmark.add+0x2f30>
    if (start == range.end - 1 and lessThan(items[start], value)) {
  20d7ac:	48 39 d6             	cmp    rsi,rdx
  20d7af:	75 1f                	jne    20d7d0 <benchmark.add+0x2f90>
  20d7b1:	48 c1 e2 04          	shl    rdx,0x4
  20d7b5:	49 8b 04 13          	mov    rax,QWORD PTR [r11+rdx*1]
  20d7b9:	31 d2                	xor    edx,edx
  20d7bb:	49 3b 02             	cmp    rax,QWORD PTR [r10]
  20d7be:	0f 92 c2             	setb   dl
  20d7c1:	eb 0f                	jmp    20d7d2 <benchmark.add+0x2f92>
  20d7c3:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20d7ca:	84 00 00 00 00 00 
  20d7d0:	31 d2                	xor    edx,edx
  20d7d2:	48 01 f2             	add    rdx,rsi
                    if (index == B.start) break;
  20d7d5:	4c 39 f2             	cmp    rdx,r14
  20d7d8:	0f 84 51 01 00 00    	je     20d92f <benchmark.add+0x30ef>
                    count += 1;
  20d7de:	49 83 c0 01          	add    r8,0x1
  20d7e2:	48 83 c2 ff          	add    rdx,0xffffffffffffffff
  20d7e6:	49 89 d1             	mov    r9,rdx
  20d7e9:	4c 89 ef             	mov    rdi,r13
                while (count < find) : ({
  20d7ec:	4c 39 c7             	cmp    rdi,r8
  20d7ef:	0f 87 bb fe ff ff    	ja     20d6b0 <benchmark.add+0x2e70>
  20d7f5:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20d7fc:	00 00 00 00 
  20d800:	4c 8b 5c 24 18       	mov    r11,QWORD PTR [rsp+0x18]
                if (count >= buffer_size) {
  20d805:	4d 39 d8             	cmp    r8,r11
  20d808:	0f 86 2e fd ff ff    	jbe    20d53c <benchmark.add+0x2cfc>
                    pull[pull_index] = Pull{
  20d80e:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
  20d813:	48 8d 04 80          	lea    rax,[rax+rax*4]
  20d817:	48 89 94 c4 80 00 00 	mov    QWORD PTR [rsp+rax*8+0x80],rdx
  20d81e:	00 
  20d81f:	4c 8b ac 24 d0 00 00 	mov    r13,QWORD PTR [rsp+0xd0]
  20d826:	00 
  20d827:	4c 89 ac c4 88 00 00 	mov    QWORD PTR [rsp+rax*8+0x88],r13
  20d82e:	00 
  20d82f:	4c 89 84 c4 90 00 00 	mov    QWORD PTR [rsp+rax*8+0x90],r8
  20d836:	00 
  20d837:	48 8b 4c 24 58       	mov    rcx,QWORD PTR [rsp+0x58]
  20d83c:	48 89 8c c4 98 00 00 	mov    QWORD PTR [rsp+rax*8+0x98],rcx
  20d843:	00 
  20d844:	4c 89 ac c4 a0 00 00 	mov    QWORD PTR [rsp+rax*8+0xa0],r13
  20d84b:	00 
  20d84c:	48 8b 4c 24 38       	mov    rcx,QWORD PTR [rsp+0x38]
                    if (count == buffer_size + buffer_size) {
  20d851:	49 39 c8             	cmp    r8,rcx
  20d854:	0f 84 a0 01 00 00    	je     20d9fa <benchmark.add+0x31ba>
                    } else if (find == buffer_size + buffer_size) {
  20d85a:	48 39 cf             	cmp    rdi,rcx
  20d85d:	75 27                	jne    20d886 <benchmark.add+0x3046>
                        buffer1 = Range.init(B.end - count, B.end);
  20d85f:	4c 89 e8             	mov    rax,r13
  20d862:	4c 29 c0             	sub    rax,r8
  20d865:	48 89 84 24 d8 00 00 	mov    QWORD PTR [rsp+0xd8],rax
  20d86c:	00 
  20d86d:	4c 89 6c 24 40       	mov    QWORD PTR [rsp+0x40],r13
  20d872:	b8 01 00 00 00       	mov    eax,0x1
  20d877:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  20d87c:	48 8b 7c 24 78       	mov    rdi,QWORD PTR [rsp+0x78]
  20d881:	e9 14 01 00 00       	jmp    20d99a <benchmark.add+0x315a>
            if (block_size <= cache.len) {
  20d886:	81 bc 24 58 01 00 00 	cmp    DWORD PTR [rsp+0x158],0x200
  20d88d:	00 02 00 00 
                    } else if (block_size <= cache.len) {
  20d891:	0f 86 99 01 00 00    	jbe    20da30 <benchmark.add+0x31f0>
                    } else if (find_separately) {
  20d897:	f6 84 24 00 01 00 00 	test   BYTE PTR [rsp+0x100],0x1
  20d89e:	01 
  20d89f:	0f 84 e1 36 00 00    	je     210f86 <benchmark.add+0x6746>
                        buffer1 = Range.init(B.end - count, B.end);
  20d8a5:	4c 89 e8             	mov    rax,r13
  20d8a8:	4c 29 c0             	sub    rax,r8
  20d8ab:	48 89 84 24 d8 00 00 	mov    QWORD PTR [rsp+0xd8],rax
  20d8b2:	00 
  20d8b3:	c7 84 24 00 01 00 00 	mov    DWORD PTR [rsp+0x100],0x0
  20d8ba:	00 00 00 00 
  20d8be:	4c 89 6c 24 40       	mov    QWORD PTR [rsp+0x40],r13
  20d8c3:	b8 01 00 00 00       	mov    eax,0x1
  20d8c8:	eb 5e                	jmp    20d928 <benchmark.add+0x30e8>
        return self.end - self.start;
  20d8ca:	4c 89 e0             	mov    rax,r12
  20d8cd:	48 2b 84 24 d8 00 00 	sub    rax,QWORD PTR [rsp+0xd8]
  20d8d4:	00 
                } else if (pull_index == 0 and count > buffer1.length()) {
  20d8d5:	49 39 c0             	cmp    r8,rax
  20d8d8:	0f 86 a8 00 00 00    	jbe    20d986 <benchmark.add+0x3146>
  20d8de:	4c 8b ac 24 d0 00 00 	mov    r13,QWORD PTR [rsp+0xd0]
  20d8e5:	00 
                    buffer1 = Range.init(B.end - count, B.end);
  20d8e6:	4c 89 e8             	mov    rax,r13
                    pull[pull_index] = Pull{
  20d8e9:	48 89 94 24 80 00 00 	mov    QWORD PTR [rsp+0x80],rdx
  20d8f0:	00 
  20d8f1:	4c 89 ac 24 88 00 00 	mov    QWORD PTR [rsp+0x88],r13
  20d8f8:	00 
  20d8f9:	4c 89 84 24 90 00 00 	mov    QWORD PTR [rsp+0x90],r8
  20d900:	00 
  20d901:	48 8b 4c 24 58       	mov    rcx,QWORD PTR [rsp+0x58]
  20d906:	48 89 8c 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rcx
  20d90d:	00 
                    buffer1 = Range.init(B.end - count, B.end);
  20d90e:	4c 29 c0             	sub    rax,r8
  20d911:	48 89 84 24 d8 00 00 	mov    QWORD PTR [rsp+0xd8],rax
  20d918:	00 
                    pull[pull_index] = Pull{
  20d919:	4c 89 ac 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],r13
  20d920:	00 
  20d921:	4c 89 6c 24 40       	mov    QWORD PTR [rsp+0x40],r13
  20d926:	31 c0                	xor    eax,eax
  20d928:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  20d92d:	eb 6b                	jmp    20d99a <benchmark.add+0x315a>
  20d92f:	4c 89 ca             	mov    rdx,r9
  20d932:	4c 89 ef             	mov    rdi,r13
  20d935:	4c 8b 5c 24 18       	mov    r11,QWORD PTR [rsp+0x18]
                if (count >= buffer_size) {
  20d93a:	4d 39 d8             	cmp    r8,r11
  20d93d:	0f 87 cb fe ff ff    	ja     20d80e <benchmark.add+0x2fce>
  20d943:	e9 f4 fb ff ff       	jmp    20d53c <benchmark.add+0x2cfc>
  20d948:	4c 89 ca             	mov    rdx,r9
  20d94b:	4c 8b 5c 24 18       	mov    r11,QWORD PTR [rsp+0x18]
  20d950:	4d 39 d8             	cmp    r8,r11
  20d953:	0f 87 b5 fe ff ff    	ja     20d80e <benchmark.add+0x2fce>
  20d959:	e9 de fb ff ff       	jmp    20d53c <benchmark.add+0x2cfc>
  20d95e:	49 89 d4             	mov    r12,rdx
  20d961:	31 c0                	xor    eax,eax
  20d963:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  20d968:	48 89 f2             	mov    rdx,rsi
  20d96b:	48 89 94 24 d0 00 00 	mov    QWORD PTR [rsp+0xd0],rdx
  20d972:	00 
  20d973:	48 8d 52 ff          	lea    rdx,[rdx-0x1]
                while (count < find) : ({
  20d977:	48 83 ff 02          	cmp    rdi,0x2
  20d97b:	0f 82 a7 fb ff ff    	jb     20d528 <benchmark.add+0x2ce8>
  20d981:	e9 9e fc ff ff       	jmp    20d624 <benchmark.add+0x2de4>
  20d986:	4c 89 64 24 40       	mov    QWORD PTR [rsp+0x40],r12
  20d98b:	31 c0                	xor    eax,eax
  20d98d:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  20d992:	4c 8b ac 24 d0 00 00 	mov    r13,QWORD PTR [rsp+0xd0]
  20d999:	00 
  20d99a:	48 8b 74 24 30       	mov    rsi,QWORD PTR [rsp+0x30]
  20d99f:	48 2b 74 24 28       	sub    rsi,QWORD PTR [rsp+0x28]
        return self.decimal >= self.size;
  20d9a4:	4c 3b ac 24 50 01 00 	cmp    r13,QWORD PTR [rsp+0x150]
  20d9ab:	00 
  20d9ac:	48 8b 9c 24 38 01 00 	mov    rbx,QWORD PTR [rsp+0x138]
  20d9b3:	00 
  20d9b4:	4c 8b 84 24 f8 00 00 	mov    r8,QWORD PTR [rsp+0xf8]
  20d9bb:	00 
  20d9bc:	4c 8b 8c 24 30 01 00 	mov    r9,QWORD PTR [rsp+0x130]
  20d9c3:	00 
            while (!iterator.finished()) {
  20d9c4:	0f 82 b6 f9 ff ff    	jb     20d380 <benchmark.add+0x2b40>
  20d9ca:	eb 77                	jmp    20da43 <benchmark.add+0x3203>
  20d9cc:	48 89 ce             	mov    rsi,rcx
  20d9cf:	48 8b 54 24 78       	mov    rdx,QWORD PTR [rsp+0x78]
                        buffer1 = Range.init(A.start, A.start + buffer_size);
  20d9d4:	48 01 c2             	add    rdx,rax
                        buffer2 = Range.init(A.start + buffer_size, A.start + count);
  20d9d7:	48 01 c6             	add    rsi,rax
  20d9da:	48 89 d1             	mov    rcx,rdx
  20d9dd:	48 89 4c 24 40       	mov    QWORD PTR [rsp+0x40],rcx
  20d9e2:	48 89 84 24 d8 00 00 	mov    QWORD PTR [rsp+0xd8],rax
  20d9e9:	00 
  20d9ea:	48 89 f0             	mov    rax,rsi
  20d9ed:	48 89 84 24 d0 00 00 	mov    QWORD PTR [rsp+0xd0],rax
  20d9f4:	00 
  20d9f5:	48 89 d0             	mov    rax,rdx
  20d9f8:	eb 55                	jmp    20da4f <benchmark.add+0x320f>
                        buffer1 = Range.init(B.end - count, B.end - buffer_size);
  20d9fa:	4c 89 e8             	mov    rax,r13
  20d9fd:	48 29 c8             	sub    rax,rcx
  20da00:	48 89 84 24 d8 00 00 	mov    QWORD PTR [rsp+0xd8],rax
  20da07:	00 
  20da08:	4c 2b 6c 24 78       	sub    r13,QWORD PTR [rsp+0x78]
  20da0d:	4c 89 e8             	mov    rax,r13
  20da10:	48 89 44 24 40       	mov    QWORD PTR [rsp+0x40],rax
                        break;
  20da15:	4c 89 6c 24 58       	mov    QWORD PTR [rsp+0x58],r13
  20da1a:	eb 38                	jmp    20da54 <benchmark.add+0x3214>
  20da1c:	4c 89 64 24 40       	mov    QWORD PTR [rsp+0x40],r12
  20da21:	48 8b 44 24 58       	mov    rax,QWORD PTR [rsp+0x58]
  20da26:	48 89 84 24 d8 00 00 	mov    QWORD PTR [rsp+0xd8],rax
  20da2d:	00 
  20da2e:	eb 13                	jmp    20da43 <benchmark.add+0x3203>
                        buffer1 = Range.init(B.end - count, B.end);
  20da30:	4c 89 e8             	mov    rax,r13
  20da33:	4c 29 c0             	sub    rax,r8
  20da36:	48 89 84 24 d8 00 00 	mov    QWORD PTR [rsp+0xd8],rax
  20da3d:	00 
  20da3e:	4c 89 6c 24 40       	mov    QWORD PTR [rsp+0x40],r13
  20da43:	31 c0                	xor    eax,eax
  20da45:	48 89 84 24 d0 00 00 	mov    QWORD PTR [rsp+0xd0],rax
  20da4c:	00 
  20da4d:	31 c0                	xor    eax,eax
  20da4f:	48 89 44 24 58       	mov    QWORD PTR [rsp+0x58],rax
  20da54:	31 c0                	xor    eax,eax
  20da56:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  20da5d:	00 00 00 
  20da60:	48 89 44 24 38       	mov    QWORD PTR [rsp+0x38],rax
                const length = pull[pull_index].count;
  20da65:	48 8d 04 80          	lea    rax,[rax+rax*4]
  20da69:	48 8d 0c c4          	lea    rcx,[rsp+rax*8]
  20da6d:	48 81 c1 80 00 00 00 	add    rcx,0x80
  20da74:	48 89 4c 24 18       	mov    QWORD PTR [rsp+0x18],rcx
  20da79:	48 8b 94 c4 90 00 00 	mov    rdx,QWORD PTR [rsp+rax*8+0x90]
  20da80:	00 
                if (pull[pull_index].to < pull[pull_index].from) {
  20da81:	4c 8b a4 c4 80 00 00 	mov    r12,QWORD PTR [rsp+rax*8+0x80]
  20da88:	00 
  20da89:	48 8b 8c c4 88 00 00 	mov    rcx,QWORD PTR [rsp+rax*8+0x88]
  20da90:	00 
  20da91:	4c 39 e1             	cmp    rcx,r12
  20da94:	48 89 54 24 10       	mov    QWORD PTR [rsp+0x10],rdx
  20da99:	0f 83 21 06 00 00    	jae    20e0c0 <benchmark.add+0x3880>
                    while (count < length) : (count += 1) {
  20da9f:	48 83 fa 02          	cmp    rdx,0x2
  20daa3:	0f 82 14 0b 00 00    	jb     20e5bd <benchmark.add+0x3d7d>
  20daa9:	49 c7 c2 ff ff ff ff 	mov    r10,0xffffffffffffffff
  20dab0:	49 c7 c1 fe ff ff ff 	mov    r9,0xfffffffffffffffe
  20dab7:	31 c0                	xor    eax,eax
  20dab9:	48 89 44 24 20       	mov    QWORD PTR [rsp+0x20],rax
  20dabe:	4d 89 e6             	mov    r14,r12
  20dac1:	41 bb 01 00 00 00    	mov    r11d,0x1
  20dac7:	eb 13                	jmp    20dadc <benchmark.add+0x329c>
  20dac9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
                        index = findFirstBackward(T, items, items[index - 1], Range.init(pull[pull_index].to, pull[pull_index].from - (count - 1)), lessThan, length - count);
  20dad0:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
                    while (count < length) : (count += 1) {
  20dad4:	49 83 c2 ff          	add    r10,0xffffffffffffffff
  20dad8:	49 83 c1 ff          	add    r9,0xffffffffffffffff
                        index = findFirstBackward(T, items, items[index - 1], Range.init(pull[pull_index].to, pull[pull_index].from - (count - 1)), lessThan, length - count);
  20dadc:	4c 8b 6c 24 48       	mov    r13,QWORD PTR [rsp+0x48]
  20dae1:	bf 01 00 00 00       	mov    edi,0x1
  20dae6:	4c 29 df             	sub    rdi,r11
  20dae9:	4c 01 e7             	add    rdi,r12
    if (range.length() == 0) return range.start;
  20daec:	48 89 f8             	mov    rax,rdi
  20daef:	48 29 c8             	sub    rax,rcx
  20daf2:	74 2c                	je     20db20 <benchmark.add+0x32e0>
  20daf4:	49 c1 e6 04          	shl    r14,0x4
                        index = findFirstBackward(T, items, items[index - 1], Range.init(pull[pull_index].to, pull[pull_index].from - (count - 1)), lessThan, length - count);
  20daf8:	48 89 d6             	mov    rsi,rdx
  20dafb:	4c 29 de             	sub    rsi,r11
  20dafe:	48 89 c2             	mov    rdx,rax
  20db01:	48 09 f2             	or     rdx,rsi
  20db04:	48 c1 ea 20          	shr    rdx,0x20
  20db08:	74 26                	je     20db30 <benchmark.add+0x32f0>
  20db0a:	31 d2                	xor    edx,edx
  20db0c:	48 f7 f6             	div    rsi
  20db0f:	eb 23                	jmp    20db34 <benchmark.add+0x32f4>
  20db11:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20db18:	0f 1f 84 00 00 00 00 
  20db1f:	00 
  20db20:	49 89 ce             	mov    r14,rcx
  20db23:	e9 48 01 00 00       	jmp    20dc70 <benchmark.add+0x3430>
  20db28:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  20db2f:	00 
  20db30:	31 d2                	xor    edx,edx
  20db32:	f7 f6                	div    esi
  20db34:	48 83 f8 01          	cmp    rax,0x1
  20db38:	ba 01 00 00 00       	mov    edx,0x1
  20db3d:	48 0f 46 c2          	cmovbe rax,rdx
  20db41:	4f 8d 3c 2e          	lea    r15,[r14+r13*1]
  20db45:	49 83 c7 f0          	add    r15,0xfffffffffffffff0
  20db49:	48 89 fe             	mov    rsi,rdi
  20db4c:	48 29 c6             	sub    rsi,rax
    while (index > range.start and !lessThan(items[index - 1], value)) : (index -= skip) {
  20db4f:	48 39 ce             	cmp    rsi,rcx
  20db52:	76 3c                	jbe    20db90 <benchmark.add+0x3350>
  20db54:	4d 8b 07             	mov    r8,QWORD PTR [r15]
  20db57:	4c 8d 34 08          	lea    r14,[rax+rcx*1]
  20db5b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  20db60:	48 89 f2             	mov    rdx,rsi
  20db63:	48 8d 5a ff          	lea    rbx,[rdx-0x1]
  20db67:	48 89 de             	mov    rsi,rbx
  20db6a:	48 c1 e6 04          	shl    rsi,0x4
  20db6e:	4d 39 44 35 00       	cmp    QWORD PTR [r13+rsi*1+0x0],r8
  20db73:	0f 82 95 00 00 00    	jb     20dc0e <benchmark.add+0x33ce>
        if (index < range.start + skip) {
  20db79:	4c 39 f2             	cmp    rdx,r14
  20db7c:	0f 82 9d 00 00 00    	jb     20dc1f <benchmark.add+0x33df>
  20db82:	48 89 d6             	mov    rsi,rdx
  20db85:	48 29 c6             	sub    rsi,rax
  20db88:	48 89 d7             	mov    rdi,rdx
    while (index > range.start and !lessThan(items[index - 1], value)) : (index -= skip) {
  20db8b:	48 39 ce             	cmp    rsi,rcx
  20db8e:	77 d0                	ja     20db60 <benchmark.add+0x3320>
    if (range.start >= range.end) return range.end;
  20db90:	48 85 c0             	test   rax,rax
  20db93:	0f 84 81 00 00 00    	je     20dc1a <benchmark.add+0x33da>
    var end = range.end - 1;
  20db99:	48 83 c7 ff          	add    rdi,0xffffffffffffffff
    while (start < end) {
  20db9d:	48 39 f7             	cmp    rdi,rsi
  20dba0:	76 4a                	jbe    20dbec <benchmark.add+0x33ac>
  20dba2:	4d 8b 07             	mov    r8,QWORD PTR [r15]
  20dba5:	48 89 f9             	mov    rcx,rdi
  20dba8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  20dbaf:	00 
        const mid = start + (end - start) / 2;
  20dbb0:	48 89 ca             	mov    rdx,rcx
  20dbb3:	48 29 f2             	sub    rdx,rsi
  20dbb6:	48 d1 ea             	shr    rdx,1
  20dbb9:	48 8d 04 32          	lea    rax,[rdx+rsi*1]
  20dbbd:	48 89 c3             	mov    rbx,rax
  20dbc0:	48 c1 e3 04          	shl    rbx,0x4
  20dbc4:	4d 39 44 1d 00       	cmp    QWORD PTR [r13+rbx*1+0x0],r8
        if (lessThan(items[mid], value)) {
  20dbc9:	72 15                	jb     20dbe0 <benchmark.add+0x33a0>
  20dbcb:	48 89 c1             	mov    rcx,rax
    while (start < end) {
  20dbce:	48 39 f1             	cmp    rcx,rsi
  20dbd1:	77 dd                	ja     20dbb0 <benchmark.add+0x3370>
  20dbd3:	eb 17                	jmp    20dbec <benchmark.add+0x33ac>
  20dbd5:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20dbdc:	00 00 00 00 
  20dbe0:	48 01 d6             	add    rsi,rdx
  20dbe3:	48 83 c6 01          	add    rsi,0x1
  20dbe7:	48 39 f1             	cmp    rcx,rsi
  20dbea:	77 c4                	ja     20dbb0 <benchmark.add+0x3370>
    if (start == range.end - 1 and lessThan(items[start], value)) {
  20dbec:	48 39 fe             	cmp    rsi,rdi
  20dbef:	75 15                	jne    20dc06 <benchmark.add+0x33c6>
  20dbf1:	48 c1 e7 04          	shl    rdi,0x4
  20dbf5:	49 8b 44 3d 00       	mov    rax,QWORD PTR [r13+rdi*1+0x0]
  20dbfa:	45 31 f6             	xor    r14d,r14d
  20dbfd:	49 3b 07             	cmp    rax,QWORD PTR [r15]
  20dc00:	41 0f 92 c6          	setb   r14b
  20dc04:	eb 03                	jmp    20dc09 <benchmark.add+0x33c9>
  20dc06:	45 31 f6             	xor    r14d,r14d
  20dc09:	49 01 f6             	add    r14,rsi
  20dc0c:	eb 62                	jmp    20dc70 <benchmark.add+0x3430>
  20dc0e:	48 89 d6             	mov    rsi,rdx
    if (range.start >= range.end) return range.end;
  20dc11:	48 85 c0             	test   rax,rax
  20dc14:	0f 85 7f ff ff ff    	jne    20db99 <benchmark.add+0x3359>
  20dc1a:	49 89 fe             	mov    r14,rdi
  20dc1d:	eb 51                	jmp    20dc70 <benchmark.add+0x3430>
  20dc1f:	49 89 ce             	mov    r14,rcx
    while (start < end) {
  20dc22:	48 39 cb             	cmp    rbx,rcx
  20dc25:	76 49                	jbe    20dc70 <benchmark.add+0x3430>
  20dc27:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  20dc2e:	00 00 
        const mid = start + (end - start) / 2;
  20dc30:	48 89 d8             	mov    rax,rbx
  20dc33:	4c 29 f0             	sub    rax,r14
  20dc36:	48 d1 e8             	shr    rax,1
  20dc39:	4a 8d 0c 30          	lea    rcx,[rax+r14*1]
  20dc3d:	48 89 ca             	mov    rdx,rcx
  20dc40:	48 c1 e2 04          	shl    rdx,0x4
  20dc44:	4d 39 44 15 00       	cmp    QWORD PTR [r13+rdx*1+0x0],r8
        if (lessThan(items[mid], value)) {
  20dc49:	72 15                	jb     20dc60 <benchmark.add+0x3420>
  20dc4b:	48 89 cb             	mov    rbx,rcx
    while (start < end) {
  20dc4e:	4c 39 f3             	cmp    rbx,r14
  20dc51:	77 dd                	ja     20dc30 <benchmark.add+0x33f0>
  20dc53:	eb 1b                	jmp    20dc70 <benchmark.add+0x3430>
  20dc55:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20dc5c:	00 00 00 00 
  20dc60:	49 01 c6             	add    r14,rax
  20dc63:	49 83 c6 01          	add    r14,0x1
  20dc67:	4c 39 f3             	cmp    rbx,r14
  20dc6a:	77 c4                	ja     20dc30 <benchmark.add+0x33f0>
  20dc6c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
                        const range = Range.init(index + 1, pull[pull_index].from + 1);
  20dc70:	4d 89 f7             	mov    r15,r14
  20dc73:	49 c1 e7 04          	shl    r15,0x4
  20dc77:	4c 89 f0             	mov    rax,r14
  20dc7a:	48 f7 d0             	not    rax
                        mem.rotate(T, items[range.start..range.end], range.length() - count);
  20dc7d:	4d 8d 04 04          	lea    r8,[r12+rax*1]
  20dc81:	49 83 c0 01          	add    r8,0x1
  20dc85:	4c 89 c2             	mov    rdx,r8
  20dc88:	4c 29 da             	sub    rdx,r11
}

/// In-place order reversal of a slice
pub fn reverse(comptime T: type, items: []T) void {
    var i: usize = 0;
    const end = items.len / 2;
  20dc8b:	48 d1 ea             	shr    rdx,1
    while (i < end) : (i += 1) {
  20dc8e:	0f 84 44 01 00 00    	je     20ddd8 <benchmark.add+0x3598>
        swap(T, &items[i], &items[items.len - i - 1]);
  20dc94:	48 8d 42 ff          	lea    rax,[rdx-0x1]
  20dc98:	48 83 f8 03          	cmp    rax,0x3
  20dc9c:	73 12                	jae    20dcb0 <benchmark.add+0x3470>
  20dc9e:	31 f6                	xor    esi,esi
    while (i < end) : (i += 1) {
  20dca0:	f6 c2 03             	test   dl,0x3
  20dca3:	0f 85 c5 00 00 00    	jne    20dd6e <benchmark.add+0x352e>
  20dca9:	e9 2a 01 00 00       	jmp    20ddd8 <benchmark.add+0x3598>
  20dcae:	66 90                	xchg   ax,ax
        swap(T, &items[i], &items[items.len - i - 1]);
  20dcb0:	4b 8d 0c 2f          	lea    rcx,[r15+r13*1]
  20dcb4:	48 83 c1 40          	add    rcx,0x40
  20dcb8:	4b 8d 3c 14          	lea    rdi,[r12+r10*1]
  20dcbc:	4c 29 f7             	sub    rdi,r14
  20dcbf:	48 d1 ef             	shr    rdi,1
  20dcc2:	89 f8                	mov    eax,edi
  20dcc4:	83 e0 03             	and    eax,0x3
  20dcc7:	48 29 c7             	sub    rdi,rax
  20dcca:	4b 8d 04 0c          	lea    rax,[r12+r9*1]
  20dcce:	48 c1 e0 04          	shl    rax,0x4
  20dcd2:	4c 01 e8             	add    rax,r13
  20dcd5:	48 83 c0 10          	add    rax,0x10
  20dcd9:	31 f6                	xor    esi,esi
  20dcdb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
    const tmp = a.*;
  20dce0:	c5 f8 10 41 d0       	vmovups xmm0,XMMWORD PTR [rcx-0x30]
  20dce5:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  20dcea:	c5 f8 10 00          	vmovups xmm0,XMMWORD PTR [rax]
  20dcee:	c5 f8 11 41 d0       	vmovups XMMWORD PTR [rcx-0x30],xmm0
    b.* = tmp;
  20dcf3:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  20dcf8:	c5 f8 11 00          	vmovups XMMWORD PTR [rax],xmm0
    const tmp = a.*;
  20dcfc:	c5 f8 10 41 e0       	vmovups xmm0,XMMWORD PTR [rcx-0x20]
  20dd01:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  20dd06:	c5 f8 10 40 f0       	vmovups xmm0,XMMWORD PTR [rax-0x10]
  20dd0b:	c5 f8 11 41 e0       	vmovups XMMWORD PTR [rcx-0x20],xmm0
    b.* = tmp;
  20dd10:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  20dd15:	c5 f8 11 40 f0       	vmovups XMMWORD PTR [rax-0x10],xmm0
    const tmp = a.*;
  20dd1a:	c5 f8 10 41 f0       	vmovups xmm0,XMMWORD PTR [rcx-0x10]
  20dd1f:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  20dd24:	c5 f8 10 40 e0       	vmovups xmm0,XMMWORD PTR [rax-0x20]
  20dd29:	c5 f8 11 41 f0       	vmovups XMMWORD PTR [rcx-0x10],xmm0
    b.* = tmp;
  20dd2e:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  20dd33:	c5 f8 11 40 e0       	vmovups XMMWORD PTR [rax-0x20],xmm0
    const tmp = a.*;
  20dd38:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  20dd3c:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  20dd41:	c5 f8 10 40 d0       	vmovups xmm0,XMMWORD PTR [rax-0x30]
  20dd46:	c5 f8 11 01          	vmovups XMMWORD PTR [rcx],xmm0
    b.* = tmp;
  20dd4a:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  20dd4f:	c5 fa 7f 40 d0       	vmovdqu XMMWORD PTR [rax-0x30],xmm0
    while (i < end) : (i += 1) {
  20dd54:	48 83 c6 04          	add    rsi,0x4
  20dd58:	48 83 c1 40          	add    rcx,0x40
  20dd5c:	48 83 c0 c0          	add    rax,0xffffffffffffffc0
  20dd60:	48 39 f7             	cmp    rdi,rsi
  20dd63:	0f 85 77 ff ff ff    	jne    20dce0 <benchmark.add+0x34a0>
  20dd69:	f6 c2 03             	test   dl,0x3
  20dd6c:	74 6a                	je     20ddd8 <benchmark.add+0x3598>
  20dd6e:	4b 8d 04 0c          	lea    rax,[r12+r9*1]
  20dd72:	48 29 f0             	sub    rax,rsi
  20dd75:	48 c1 e0 04          	shl    rax,0x4
  20dd79:	4c 01 e8             	add    rax,r13
  20dd7c:	48 83 c0 10          	add    rax,0x10
  20dd80:	4c 01 f6             	add    rsi,r14
  20dd83:	48 c1 e6 04          	shl    rsi,0x4
  20dd87:	4a 8d 0c 2e          	lea    rcx,[rsi+r13*1]
  20dd8b:	48 83 c1 10          	add    rcx,0x10
  20dd8f:	43 8d 14 14          	lea    edx,[r12+r10*1]
  20dd93:	44 29 f2             	sub    edx,r14d
  20dd96:	be 01 02 00 00       	mov    esi,0x201
  20dd9b:	c4 e2 48 f7 d2       	bextr  edx,edx,esi
  20dda0:	48 f7 da             	neg    rdx
  20dda3:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20ddaa:	84 00 00 00 00 00 
    const tmp = a.*;
  20ddb0:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  20ddb4:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  20ddb9:	c5 f8 10 00          	vmovups xmm0,XMMWORD PTR [rax]
  20ddbd:	c5 f8 11 01          	vmovups XMMWORD PTR [rcx],xmm0
    b.* = tmp;
  20ddc1:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  20ddc6:	c5 fa 7f 00          	vmovdqu XMMWORD PTR [rax],xmm0
    while (i < end) : (i += 1) {
  20ddca:	48 83 c0 f0          	add    rax,0xfffffffffffffff0
  20ddce:	48 83 c1 10          	add    rcx,0x10
  20ddd2:	48 83 c2 01          	add    rdx,0x1
  20ddd6:	75 d8                	jne    20ddb0 <benchmark.add+0x3570>
  20ddd8:	48 83 44 24 20 01    	add    QWORD PTR [rsp+0x20],0x1
  20ddde:	49 83 fb 02          	cmp    r11,0x2
  20dde2:	0f 82 40 01 00 00    	jb     20df28 <benchmark.add+0x36e8>
  20dde8:	4c 89 d9             	mov    rcx,r11
  20ddeb:	48 d1 e9             	shr    rcx,1
  20ddee:	89 ca                	mov    edx,ecx
  20ddf0:	83 e2 03             	and    edx,0x3
  20ddf3:	48 8b 5c 24 20       	mov    rbx,QWORD PTR [rsp+0x20]
  20ddf8:	48 d1 eb             	shr    rbx,1
  20ddfb:	48 8d 43 ff          	lea    rax,[rbx-0x1]
        swap(T, &items[i], &items[items.len - i - 1]);
  20ddff:	48 83 f8 03          	cmp    rax,0x3
  20de03:	73 1b                	jae    20de20 <benchmark.add+0x35e0>
  20de05:	31 ff                	xor    edi,edi
    while (i < end) : (i += 1) {
  20de07:	f6 c3 03             	test   bl,0x3
  20de0a:	0f 85 ce 00 00 00    	jne    20dede <benchmark.add+0x369e>
  20de10:	e9 13 01 00 00       	jmp    20df28 <benchmark.add+0x36e8>
  20de15:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20de1c:	00 00 00 00 
  20de20:	48 29 d1             	sub    rcx,rdx
        swap(T, &items[i], &items[items.len - i - 1]);
  20de23:	4b 8d 04 14          	lea    rax,[r12+r10*1]
  20de27:	48 c1 e0 04          	shl    rax,0x4
  20de2b:	4a 8d 34 28          	lea    rsi,[rax+r13*1]
  20de2f:	48 83 c6 40          	add    rsi,0x40
  20de33:	4c 89 e0             	mov    rax,r12
  20de36:	48 c1 e0 04          	shl    rax,0x4
  20de3a:	4c 01 e8             	add    rax,r13
  20de3d:	48 83 c0 f0          	add    rax,0xfffffffffffffff0
  20de41:	31 ff                	xor    edi,edi
  20de43:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20de4a:	84 00 00 00 00 00 
    const tmp = a.*;
  20de50:	c5 f8 10 46 d0       	vmovups xmm0,XMMWORD PTR [rsi-0x30]
  20de55:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  20de5a:	c5 f8 10 40 10       	vmovups xmm0,XMMWORD PTR [rax+0x10]
  20de5f:	c5 f8 11 46 d0       	vmovups XMMWORD PTR [rsi-0x30],xmm0
    b.* = tmp;
  20de64:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  20de69:	c5 f8 11 40 10       	vmovups XMMWORD PTR [rax+0x10],xmm0
    const tmp = a.*;
  20de6e:	c5 f8 10 46 e0       	vmovups xmm0,XMMWORD PTR [rsi-0x20]
  20de73:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  20de78:	c5 f8 10 00          	vmovups xmm0,XMMWORD PTR [rax]
  20de7c:	c5 f8 11 46 e0       	vmovups XMMWORD PTR [rsi-0x20],xmm0
    b.* = tmp;
  20de81:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  20de86:	c5 f8 11 00          	vmovups XMMWORD PTR [rax],xmm0
    const tmp = a.*;
  20de8a:	c5 f8 10 46 f0       	vmovups xmm0,XMMWORD PTR [rsi-0x10]
  20de8f:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  20de94:	c5 f8 10 40 f0       	vmovups xmm0,XMMWORD PTR [rax-0x10]
  20de99:	c5 f8 11 46 f0       	vmovups XMMWORD PTR [rsi-0x10],xmm0
    b.* = tmp;
  20de9e:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  20dea3:	c5 f8 11 40 f0       	vmovups XMMWORD PTR [rax-0x10],xmm0
    const tmp = a.*;
  20dea8:	c5 f8 10 06          	vmovups xmm0,XMMWORD PTR [rsi]
  20deac:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  20deb1:	c5 f8 10 40 e0       	vmovups xmm0,XMMWORD PTR [rax-0x20]
  20deb6:	c5 f8 11 06          	vmovups XMMWORD PTR [rsi],xmm0
    b.* = tmp;
  20deba:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  20debf:	c5 fa 7f 40 e0       	vmovdqu XMMWORD PTR [rax-0x20],xmm0
    while (i < end) : (i += 1) {
  20dec4:	48 83 c7 04          	add    rdi,0x4
  20dec8:	48 83 c6 40          	add    rsi,0x40
  20decc:	48 83 c0 c0          	add    rax,0xffffffffffffffc0
  20ded0:	48 39 f9             	cmp    rcx,rdi
  20ded3:	0f 85 77 ff ff ff    	jne    20de50 <benchmark.add+0x3610>
  20ded9:	f6 c3 03             	test   bl,0x3
  20dedc:	74 4a                	je     20df28 <benchmark.add+0x36e8>
  20dede:	48 f7 da             	neg    rdx
  20dee1:	4c 89 e0             	mov    rax,r12
  20dee4:	48 29 f8             	sub    rax,rdi
  20dee7:	48 c1 e0 04          	shl    rax,0x4
  20deeb:	4c 01 e8             	add    rax,r13
  20deee:	4c 01 e7             	add    rdi,r12
  20def1:	4c 01 d7             	add    rdi,r10
  20def4:	48 c1 e7 04          	shl    rdi,0x4
  20def8:	4a 8d 0c 2f          	lea    rcx,[rdi+r13*1]
  20defc:	48 83 c1 10          	add    rcx,0x10
    const tmp = a.*;
  20df00:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  20df04:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  20df09:	c5 f8 10 00          	vmovups xmm0,XMMWORD PTR [rax]
  20df0d:	c5 f8 11 01          	vmovups XMMWORD PTR [rcx],xmm0
    b.* = tmp;
  20df11:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  20df16:	c5 fa 7f 00          	vmovdqu XMMWORD PTR [rax],xmm0
    while (i < end) : (i += 1) {
  20df1a:	48 83 c0 f0          	add    rax,0xfffffffffffffff0
  20df1e:	48 83 c1 10          	add    rcx,0x10
  20df22:	48 83 c2 01          	add    rdx,0x1
  20df26:	75 d8                	jne    20df00 <benchmark.add+0x36c0>
    const end = items.len / 2;
  20df28:	49 d1 e8             	shr    r8,1
    while (i < end) : (i += 1) {
  20df2b:	0f 84 5f 01 00 00    	je     20e090 <benchmark.add+0x3850>
  20df31:	4b 8d 0c 2f          	lea    rcx,[r15+r13*1]
  20df35:	48 83 c1 10          	add    rcx,0x10
        swap(T, &items[i], &items[items.len - i - 1]);
  20df39:	4c 89 e0             	mov    rax,r12
    const tmp = a.*;
  20df3c:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  20df40:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  20df45:	48 c1 e0 04          	shl    rax,0x4
    a.* = b.*;
  20df49:	c4 c1 78 10 44 05 00 	vmovups xmm0,XMMWORD PTR [r13+rax*1+0x0]
  20df50:	c5 f8 11 01          	vmovups XMMWORD PTR [rcx],xmm0
    b.* = tmp;
  20df54:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  20df59:	c4 c1 7a 7f 44 05 00 	vmovdqu XMMWORD PTR [r13+rax*1+0x0],xmm0
    while (i < end) : (i += 1) {
  20df60:	49 83 f8 01          	cmp    r8,0x1
  20df64:	0f 84 26 01 00 00    	je     20e090 <benchmark.add+0x3850>
        swap(T, &items[i], &items[items.len - i - 1]);
  20df6a:	41 8d 50 ff          	lea    edx,[r8-0x1]
  20df6e:	49 8d 48 fe          	lea    rcx,[r8-0x2]
  20df72:	83 e2 03             	and    edx,0x3
  20df75:	48 83 f9 03          	cmp    rcx,0x3
  20df79:	73 13                	jae    20df8e <benchmark.add+0x374e>
  20df7b:	b9 01 00 00 00       	mov    ecx,0x1
    while (i < end) : (i += 1) {
  20df80:	48 85 d2             	test   rdx,rdx
  20df83:	0f 85 b5 00 00 00    	jne    20e03e <benchmark.add+0x37fe>
  20df89:	e9 02 01 00 00       	jmp    20e090 <benchmark.add+0x3850>
        swap(T, &items[i], &items[items.len - i - 1]);
  20df8e:	4a 8d 34 28          	lea    rsi,[rax+r13*1]
  20df92:	48 83 c6 f0          	add    rsi,0xfffffffffffffff0
  20df96:	4b 8d 3c 2f          	lea    rdi,[r15+r13*1]
  20df9a:	48 83 c7 50          	add    rdi,0x50
  20df9e:	49 29 d0             	sub    r8,rdx
  20dfa1:	b9 01 00 00 00       	mov    ecx,0x1
  20dfa6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  20dfad:	00 00 00 
    const tmp = a.*;
  20dfb0:	c5 f8 10 47 d0       	vmovups xmm0,XMMWORD PTR [rdi-0x30]
  20dfb5:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  20dfba:	c5 f8 10 06          	vmovups xmm0,XMMWORD PTR [rsi]
  20dfbe:	c5 f8 11 47 d0       	vmovups XMMWORD PTR [rdi-0x30],xmm0
    b.* = tmp;
  20dfc3:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  20dfc8:	c5 f8 11 06          	vmovups XMMWORD PTR [rsi],xmm0
    const tmp = a.*;
  20dfcc:	c5 f8 10 47 e0       	vmovups xmm0,XMMWORD PTR [rdi-0x20]
  20dfd1:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  20dfd6:	c5 f8 10 46 f0       	vmovups xmm0,XMMWORD PTR [rsi-0x10]
  20dfdb:	c5 f8 11 47 e0       	vmovups XMMWORD PTR [rdi-0x20],xmm0
    b.* = tmp;
  20dfe0:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  20dfe5:	c5 f8 11 46 f0       	vmovups XMMWORD PTR [rsi-0x10],xmm0
    const tmp = a.*;
  20dfea:	c5 f8 10 47 f0       	vmovups xmm0,XMMWORD PTR [rdi-0x10]
  20dfef:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  20dff4:	c5 f8 10 46 e0       	vmovups xmm0,XMMWORD PTR [rsi-0x20]
  20dff9:	c5 f8 11 47 f0       	vmovups XMMWORD PTR [rdi-0x10],xmm0
    b.* = tmp;
  20dffe:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  20e003:	c5 f8 11 46 e0       	vmovups XMMWORD PTR [rsi-0x20],xmm0
    const tmp = a.*;
  20e008:	c5 f8 10 07          	vmovups xmm0,XMMWORD PTR [rdi]
  20e00c:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  20e011:	c5 f8 10 46 d0       	vmovups xmm0,XMMWORD PTR [rsi-0x30]
  20e016:	c5 f8 11 07          	vmovups XMMWORD PTR [rdi],xmm0
    b.* = tmp;
  20e01a:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  20e01f:	c5 fa 7f 46 d0       	vmovdqu XMMWORD PTR [rsi-0x30],xmm0
    while (i < end) : (i += 1) {
  20e024:	48 83 c1 04          	add    rcx,0x4
  20e028:	48 83 c6 c0          	add    rsi,0xffffffffffffffc0
  20e02c:	48 83 c7 40          	add    rdi,0x40
  20e030:	49 39 c8             	cmp    r8,rcx
  20e033:	0f 85 77 ff ff ff    	jne    20dfb0 <benchmark.add+0x3770>
  20e039:	48 85 d2             	test   rdx,rdx
  20e03c:	74 52                	je     20e090 <benchmark.add+0x3850>
  20e03e:	49 29 cc             	sub    r12,rcx
  20e041:	49 c1 e4 04          	shl    r12,0x4
  20e045:	4d 01 ec             	add    r12,r13
  20e048:	4c 01 f1             	add    rcx,r14
  20e04b:	48 c1 e1 04          	shl    rcx,0x4
  20e04f:	4a 8d 04 29          	lea    rax,[rcx+r13*1]
  20e053:	48 83 c0 10          	add    rax,0x10
  20e057:	48 f7 da             	neg    rdx
  20e05a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
    const tmp = a.*;
  20e060:	c5 f8 10 00          	vmovups xmm0,XMMWORD PTR [rax]
  20e064:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  20e069:	c4 c1 78 10 04 24    	vmovups xmm0,XMMWORD PTR [r12]
  20e06f:	c5 f8 11 00          	vmovups XMMWORD PTR [rax],xmm0
    b.* = tmp;
  20e073:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  20e078:	c4 c1 7a 7f 04 24    	vmovdqu XMMWORD PTR [r12],xmm0
    while (i < end) : (i += 1) {
  20e07e:	49 83 c4 f0          	add    r12,0xfffffffffffffff0
  20e082:	48 83 c0 10          	add    rax,0x10
  20e086:	48 83 c2 01          	add    rdx,0x1
  20e08a:	75 d4                	jne    20e060 <benchmark.add+0x3820>
  20e08c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
                        pull[pull_index].from = index + count;
  20e090:	4f 8d 24 1e          	lea    r12,[r14+r11*1]
  20e094:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  20e099:	4c 89 20             	mov    QWORD PTR [rax],r12
                    while (count < length) : (count += 1) {
  20e09c:	49 83 c3 01          	add    r11,0x1
  20e0a0:	48 8b 54 24 10       	mov    rdx,QWORD PTR [rsp+0x10]
  20e0a5:	49 39 d3             	cmp    r11,rdx
  20e0a8:	0f 85 22 fa ff ff    	jne    20dad0 <benchmark.add+0x3290>
  20e0ae:	e9 0a 05 00 00       	jmp    20e5bd <benchmark.add+0x3d7d>
  20e0b3:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20e0ba:	84 00 00 00 00 00 
                    while (count < length) : (count += 1) {
  20e0c0:	48 83 fa 02          	cmp    rdx,0x2
                } else if (pull[pull_index].to > pull[pull_index].from) {
  20e0c4:	0f 82 f3 04 00 00    	jb     20e5bd <benchmark.add+0x3d7d>
  20e0ca:	4c 39 e1             	cmp    rcx,r12
  20e0cd:	0f 86 ea 04 00 00    	jbe    20e5bd <benchmark.add+0x3d7d>
                    index = pull[pull_index].from + 1;
  20e0d3:	49 8d 44 24 01       	lea    rax,[r12+0x1]
  20e0d8:	48 89 44 24 20       	mov    QWORD PTR [rsp+0x20],rax
  20e0dd:	49 c7 c7 ff ff ff ff 	mov    r15,0xffffffffffffffff
  20e0e4:	48 c7 44 24 30 fe ff 	mov    QWORD PTR [rsp+0x30],0xfffffffffffffffe
  20e0eb:	ff ff 
  20e0ed:	b8 02 00 00 00       	mov    eax,0x2
  20e0f2:	48 89 44 24 28       	mov    QWORD PTR [rsp+0x28],rax
  20e0f7:	45 31 f6             	xor    r14d,r14d
  20e0fa:	41 bd 01 00 00 00    	mov    r13d,0x1
  20e100:	eb 30                	jmp    20e132 <benchmark.add+0x38f2>
  20e102:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20e109:	1f 84 00 00 00 00 00 
                        index = findLastForward(T, items, items[index], Range.init(index, pull[pull_index].to), lessThan, length - count);
  20e110:	48 8b 49 08          	mov    rcx,QWORD PTR [rcx+0x8]
                    while (count < length) : (count += 1) {
  20e114:	49 83 c7 01          	add    r15,0x1
  20e118:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  20e11c:	48 89 44 24 30       	mov    QWORD PTR [rsp+0x30],rax
  20e121:	49 83 c6 01          	add    r14,0x1
  20e125:	4c 89 74 24 28       	mov    QWORD PTR [rsp+0x28],r14
  20e12a:	4c 8b 74 24 60       	mov    r14,QWORD PTR [rsp+0x60]
                        const range = Range.init(pull[pull_index].from, index - 1);
  20e12f:	4d 89 cc             	mov    r12,r9
                        index = findLastForward(T, items, items[index], Range.init(index, pull[pull_index].to), lessThan, length - count);
  20e132:	49 8d 46 01          	lea    rax,[r14+0x1]
  20e136:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  20e13b:	48 8b 5c 24 48       	mov    rbx,QWORD PTR [rsp+0x48]
  20e140:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
  20e145:	48 89 c6             	mov    rsi,rax
  20e148:	48 c1 e6 04          	shl    rsi,0x4
  20e14c:	48 01 de             	add    rsi,rbx
  20e14f:	49 89 d0             	mov    r8,rdx
  20e152:	4d 29 e8             	sub    r8,r13
  20e155:	48 8d 7c 24 48       	lea    rdi,[rsp+0x48]
  20e15a:	48 89 c2             	mov    rdx,rax
  20e15d:	c5 f8 77             	vzeroupper 
  20e160:	e8 cb 80 00 00       	call   216230 <findLastForward>
  20e165:	48 89 44 24 20       	mov    QWORD PTR [rsp+0x20],rax
                        const range = Range.init(pull[pull_index].from, index - 1);
  20e16a:	4c 8d 48 ff          	lea    r9,[rax-0x1]
                        mem.rotate(T, items[range.start..range.end], count);
  20e16e:	4d 89 e0             	mov    r8,r12
  20e171:	49 c1 e0 04          	shl    r8,0x4
  20e175:	4d 89 ca             	mov    r10,r9
  20e178:	4d 29 e2             	sub    r10,r12
  20e17b:	49 83 fd 02          	cmp    r13,0x2
  20e17f:	0f 82 45 01 00 00    	jb     20e2ca <benchmark.add+0x3a8a>
                        index = findLastForward(T, items, items[index], Range.init(index, pull[pull_index].to), lessThan, length - count);
  20e185:	4c 89 ee             	mov    rsi,r13
  20e188:	48 d1 ee             	shr    rsi,1
  20e18b:	89 f7                	mov    edi,esi
  20e18d:	83 e7 03             	and    edi,0x3
  20e190:	4c 8b 5c 24 60       	mov    r11,QWORD PTR [rsp+0x60]
  20e195:	49 d1 eb             	shr    r11,1
  20e198:	49 8d 4b ff          	lea    rcx,[r11-0x1]
        swap(T, &items[i], &items[items.len - i - 1]);
  20e19c:	48 83 f9 03          	cmp    rcx,0x3
  20e1a0:	73 1e                	jae    20e1c0 <benchmark.add+0x3980>
  20e1a2:	4c 89 f8             	mov    rax,r15
  20e1a5:	31 c9                	xor    ecx,ecx
    while (i < end) : (i += 1) {
  20e1a7:	41 f6 c3 03          	test   r11b,0x3
  20e1ab:	49 89 c7             	mov    r15,rax
  20e1ae:	0f 85 c6 00 00 00    	jne    20e27a <benchmark.add+0x3a3a>
  20e1b4:	e9 11 01 00 00       	jmp    20e2ca <benchmark.add+0x3a8a>
  20e1b9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  20e1c0:	48 29 fe             	sub    rsi,rdi
        swap(T, &items[i], &items[items.len - i - 1]);
  20e1c3:	4a 8d 14 03          	lea    rdx,[rbx+r8*1]
  20e1c7:	48 83 c2 30          	add    rdx,0x30
  20e1cb:	4c 89 f8             	mov    rax,r15
  20e1ce:	4f 8d 3c 3c          	lea    r15,[r12+r15*1]
  20e1d2:	49 c1 e7 04          	shl    r15,0x4
  20e1d6:	49 01 df             	add    r15,rbx
  20e1d9:	31 c9                	xor    ecx,ecx
  20e1db:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
    const tmp = a.*;
  20e1e0:	c5 f8 10 42 d0       	vmovups xmm0,XMMWORD PTR [rdx-0x30]
  20e1e5:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  20e1ea:	c4 c1 78 10 47 10    	vmovups xmm0,XMMWORD PTR [r15+0x10]
  20e1f0:	c5 f8 11 42 d0       	vmovups XMMWORD PTR [rdx-0x30],xmm0
    b.* = tmp;
  20e1f5:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  20e1fa:	c4 c1 78 11 47 10    	vmovups XMMWORD PTR [r15+0x10],xmm0
    const tmp = a.*;
  20e200:	c5 f8 10 42 e0       	vmovups xmm0,XMMWORD PTR [rdx-0x20]
  20e205:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  20e20a:	c4 c1 78 10 07       	vmovups xmm0,XMMWORD PTR [r15]
  20e20f:	c5 f8 11 42 e0       	vmovups XMMWORD PTR [rdx-0x20],xmm0
    b.* = tmp;
  20e214:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  20e219:	c4 c1 78 11 07       	vmovups XMMWORD PTR [r15],xmm0
    const tmp = a.*;
  20e21e:	c5 f8 10 42 f0       	vmovups xmm0,XMMWORD PTR [rdx-0x10]
  20e223:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  20e228:	c4 c1 78 10 47 f0    	vmovups xmm0,XMMWORD PTR [r15-0x10]
  20e22e:	c5 f8 11 42 f0       	vmovups XMMWORD PTR [rdx-0x10],xmm0
    b.* = tmp;
  20e233:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  20e238:	c4 c1 78 11 47 f0    	vmovups XMMWORD PTR [r15-0x10],xmm0
    const tmp = a.*;
  20e23e:	c5 f8 10 02          	vmovups xmm0,XMMWORD PTR [rdx]
  20e242:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  20e247:	c4 c1 78 10 47 e0    	vmovups xmm0,XMMWORD PTR [r15-0x20]
  20e24d:	c5 f8 11 02          	vmovups XMMWORD PTR [rdx],xmm0
    b.* = tmp;
  20e251:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  20e256:	c4 c1 7a 7f 47 e0    	vmovdqu XMMWORD PTR [r15-0x20],xmm0
    while (i < end) : (i += 1) {
  20e25c:	48 83 c1 04          	add    rcx,0x4
  20e260:	48 83 c2 40          	add    rdx,0x40
  20e264:	49 83 c7 c0          	add    r15,0xffffffffffffffc0
  20e268:	48 39 ce             	cmp    rsi,rcx
  20e26b:	0f 85 6f ff ff ff    	jne    20e1e0 <benchmark.add+0x39a0>
  20e271:	41 f6 c3 03          	test   r11b,0x3
  20e275:	49 89 c7             	mov    r15,rax
  20e278:	74 50                	je     20e2ca <benchmark.add+0x3a8a>
  20e27a:	48 f7 df             	neg    rdi
  20e27d:	4d 01 e6             	add    r14,r12
  20e280:	49 29 ce             	sub    r14,rcx
  20e283:	49 c1 e6 04          	shl    r14,0x4
  20e287:	49 01 de             	add    r14,rbx
  20e28a:	4c 01 e1             	add    rcx,r12
  20e28d:	48 c1 e1 04          	shl    rcx,0x4
  20e291:	48 01 d9             	add    rcx,rbx
  20e294:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20e29b:	00 00 00 00 00 
    const tmp = a.*;
  20e2a0:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  20e2a4:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  20e2a9:	c4 c1 78 10 06       	vmovups xmm0,XMMWORD PTR [r14]
  20e2ae:	c5 f8 11 01          	vmovups XMMWORD PTR [rcx],xmm0
    b.* = tmp;
  20e2b2:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  20e2b7:	c4 c1 7a 7f 06       	vmovdqu XMMWORD PTR [r14],xmm0
    while (i < end) : (i += 1) {
  20e2bc:	49 83 c6 f0          	add    r14,0xfffffffffffffff0
  20e2c0:	48 83 c1 10          	add    rcx,0x10
  20e2c4:	48 83 c7 01          	add    rdi,0x1
  20e2c8:	75 d6                	jne    20e2a0 <benchmark.add+0x3a60>

/// In-place rotation of the values in an array ([0 1 2 3] becomes [1 2 3 0] if we rotate by 1)
/// Assumes 0 <= amount <= items.len
pub fn rotate(comptime T: type, items: []T, amount: usize) void {
    reverse(T, items[0..amount]);
    reverse(T, items[amount..]);
  20e2ca:	4d 89 d3             	mov    r11,r10
  20e2cd:	4d 29 eb             	sub    r11,r13
    const end = items.len / 2;
  20e2d0:	49 d1 eb             	shr    r11,1
  20e2d3:	48 8b 44 24 30       	mov    rax,QWORD PTR [rsp+0x30]
  20e2d8:	4c 8b 74 24 28       	mov    r14,QWORD PTR [rsp+0x28]
    while (i < end) : (i += 1) {
  20e2dd:	0f 84 55 01 00 00    	je     20e438 <benchmark.add+0x3bf8>
        swap(T, &items[i], &items[items.len - i - 1]);
  20e2e3:	49 8d 4b ff          	lea    rcx,[r11-0x1]
  20e2e7:	48 83 f9 03          	cmp    rcx,0x3
  20e2eb:	73 13                	jae    20e300 <benchmark.add+0x3ac0>
  20e2ed:	31 ff                	xor    edi,edi
    while (i < end) : (i += 1) {
  20e2ef:	41 f6 c3 03          	test   r11b,0x3
  20e2f3:	0f 85 d6 00 00 00    	jne    20e3cf <benchmark.add+0x3b8f>
  20e2f9:	e9 3a 01 00 00       	jmp    20e438 <benchmark.add+0x3bf8>
  20e2fe:	66 90                	xchg   ax,ax
  20e300:	48 8b 74 24 20       	mov    rsi,QWORD PTR [rsp+0x20]
        swap(T, &items[i], &items[items.len - i - 1]);
  20e305:	48 8d 14 06          	lea    rdx,[rsi+rax*1]
  20e309:	4c 29 e2             	sub    rdx,r12
  20e30c:	48 d1 ea             	shr    rdx,1
  20e30f:	89 d1                	mov    ecx,edx
  20e311:	83 e1 03             	and    ecx,0x3
  20e314:	48 29 ca             	sub    rdx,rcx
  20e317:	48 89 f1             	mov    rcx,rsi
  20e31a:	48 c1 e1 04          	shl    rcx,0x4
  20e31e:	48 8d 34 0b          	lea    rsi,[rbx+rcx*1]
  20e322:	48 83 c6 b0          	add    rsi,0xffffffffffffffb0
  20e326:	4b 8d 0c 34          	lea    rcx,[r12+r14*1]
  20e32a:	48 c1 e1 04          	shl    rcx,0x4
  20e32e:	48 01 d9             	add    rcx,rbx
  20e331:	31 ff                	xor    edi,edi
  20e333:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20e33a:	84 00 00 00 00 00 
    const tmp = a.*;
  20e340:	c5 f8 10 41 f0       	vmovups xmm0,XMMWORD PTR [rcx-0x10]
  20e345:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  20e34a:	c5 f8 10 46 30       	vmovups xmm0,XMMWORD PTR [rsi+0x30]
  20e34f:	c5 f8 11 41 f0       	vmovups XMMWORD PTR [rcx-0x10],xmm0
    b.* = tmp;
  20e354:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  20e359:	c5 f8 11 46 30       	vmovups XMMWORD PTR [rsi+0x30],xmm0
    const tmp = a.*;
  20e35e:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  20e362:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  20e367:	c5 f8 10 46 20       	vmovups xmm0,XMMWORD PTR [rsi+0x20]
  20e36c:	c5 f8 11 01          	vmovups XMMWORD PTR [rcx],xmm0
    b.* = tmp;
  20e370:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  20e375:	c5 f8 11 46 20       	vmovups XMMWORD PTR [rsi+0x20],xmm0
    const tmp = a.*;
  20e37a:	c5 f8 10 41 10       	vmovups xmm0,XMMWORD PTR [rcx+0x10]
  20e37f:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  20e384:	c5 f8 10 46 10       	vmovups xmm0,XMMWORD PTR [rsi+0x10]
  20e389:	c5 f8 11 41 10       	vmovups XMMWORD PTR [rcx+0x10],xmm0
    b.* = tmp;
  20e38e:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  20e393:	c5 f8 11 46 10       	vmovups XMMWORD PTR [rsi+0x10],xmm0
    const tmp = a.*;
  20e398:	c5 f8 10 41 20       	vmovups xmm0,XMMWORD PTR [rcx+0x20]
  20e39d:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  20e3a2:	c5 f8 10 06          	vmovups xmm0,XMMWORD PTR [rsi]
  20e3a6:	c5 f8 11 41 20       	vmovups XMMWORD PTR [rcx+0x20],xmm0
    b.* = tmp;
  20e3ab:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  20e3b0:	c5 fa 7f 06          	vmovdqu XMMWORD PTR [rsi],xmm0
    while (i < end) : (i += 1) {
  20e3b4:	48 83 c7 04          	add    rdi,0x4
  20e3b8:	48 83 c6 c0          	add    rsi,0xffffffffffffffc0
  20e3bc:	48 83 c1 40          	add    rcx,0x40
  20e3c0:	48 39 fa             	cmp    rdx,rdi
  20e3c3:	0f 85 77 ff ff ff    	jne    20e340 <benchmark.add+0x3b00>
  20e3c9:	41 f6 c3 03          	test   r11b,0x3
  20e3cd:	74 69                	je     20e438 <benchmark.add+0x3bf8>
  20e3cf:	48 8b 54 24 20       	mov    rdx,QWORD PTR [rsp+0x20]
  20e3d4:	48 8d 4a fe          	lea    rcx,[rdx-0x2]
  20e3d8:	48 29 f9             	sub    rcx,rdi
  20e3db:	48 c1 e1 04          	shl    rcx,0x4
  20e3df:	48 01 d9             	add    rcx,rbx
  20e3e2:	4c 01 e7             	add    rdi,r12
  20e3e5:	4c 01 ef             	add    rdi,r13
  20e3e8:	48 c1 e7 04          	shl    rdi,0x4
  20e3ec:	48 01 df             	add    rdi,rbx
  20e3ef:	8d 14 02             	lea    edx,[rdx+rax*1]
  20e3f2:	44 29 e2             	sub    edx,r12d
  20e3f5:	be 01 02 00 00       	mov    esi,0x201
  20e3fa:	c4 e2 48 f7 d2       	bextr  edx,edx,esi
  20e3ff:	48 f7 da             	neg    rdx
  20e402:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20e409:	1f 84 00 00 00 00 00 
    const tmp = a.*;
  20e410:	c5 f8 10 07          	vmovups xmm0,XMMWORD PTR [rdi]
  20e414:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  20e419:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  20e41d:	c5 f8 11 07          	vmovups XMMWORD PTR [rdi],xmm0
    b.* = tmp;
  20e421:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  20e426:	c5 fa 7f 01          	vmovdqu XMMWORD PTR [rcx],xmm0
    while (i < end) : (i += 1) {
  20e42a:	48 83 c1 f0          	add    rcx,0xfffffffffffffff0
  20e42e:	48 83 c7 10          	add    rdi,0x10
  20e432:	48 83 c2 01          	add    rdx,0x1
  20e436:	75 d8                	jne    20e410 <benchmark.add+0x3bd0>
    const end = items.len / 2;
  20e438:	4d 89 d3             	mov    r11,r10
  20e43b:	49 d1 eb             	shr    r11,1
    while (i < end) : (i += 1) {
  20e43e:	0f 84 5c 01 00 00    	je     20e5a0 <benchmark.add+0x3d60>
  20e444:	4a 8d 0c 03          	lea    rcx,[rbx+r8*1]
    const tmp = a.*;
  20e448:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  20e44c:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  20e451:	49 c1 e2 04          	shl    r10,0x4
    a.* = b.*;
  20e455:	c4 a1 78 10 44 11 f0 	vmovups xmm0,XMMWORD PTR [rcx+r10*1-0x10]
  20e45c:	c5 f8 11 01          	vmovups XMMWORD PTR [rcx],xmm0
    b.* = tmp;
  20e460:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  20e465:	c4 a1 7a 7f 44 11 f0 	vmovdqu XMMWORD PTR [rcx+r10*1-0x10],xmm0
    while (i < end) : (i += 1) {
  20e46c:	49 83 fb 01          	cmp    r11,0x1
  20e470:	0f 84 2a 01 00 00    	je     20e5a0 <benchmark.add+0x3d60>
        swap(T, &items[i], &items[items.len - i - 1]);
  20e476:	41 8d 73 ff          	lea    esi,[r11-0x1]
  20e47a:	49 8d 4b fe          	lea    rcx,[r11-0x2]
  20e47e:	83 e6 03             	and    esi,0x3
  20e481:	48 83 f9 03          	cmp    rcx,0x3
  20e485:	73 13                	jae    20e49a <benchmark.add+0x3c5a>
  20e487:	ba 01 00 00 00       	mov    edx,0x1
    while (i < end) : (i += 1) {
  20e48c:	48 85 f6             	test   rsi,rsi
  20e48f:	0f 85 b9 00 00 00    	jne    20e54e <benchmark.add+0x3d0e>
  20e495:	e9 06 01 00 00       	jmp    20e5a0 <benchmark.add+0x3d60>
        swap(T, &items[i], &items[items.len - i - 1]);
  20e49a:	48 8b 4c 24 20       	mov    rcx,QWORD PTR [rsp+0x20]
  20e49f:	48 c1 e1 04          	shl    rcx,0x4
  20e4a3:	48 8d 3c 0b          	lea    rdi,[rbx+rcx*1]
  20e4a7:	48 83 c7 d0          	add    rdi,0xffffffffffffffd0
  20e4ab:	4a 8d 0c 03          	lea    rcx,[rbx+r8*1]
  20e4af:	48 83 c1 40          	add    rcx,0x40
  20e4b3:	49 29 f3             	sub    r11,rsi
  20e4b6:	ba 01 00 00 00       	mov    edx,0x1
  20e4bb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
    const tmp = a.*;
  20e4c0:	c5 f8 10 41 d0       	vmovups xmm0,XMMWORD PTR [rcx-0x30]
  20e4c5:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  20e4ca:	c5 f8 10 07          	vmovups xmm0,XMMWORD PTR [rdi]
  20e4ce:	c5 f8 11 41 d0       	vmovups XMMWORD PTR [rcx-0x30],xmm0
    b.* = tmp;
  20e4d3:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  20e4d8:	c5 f8 11 07          	vmovups XMMWORD PTR [rdi],xmm0
    const tmp = a.*;
  20e4dc:	c5 f8 10 41 e0       	vmovups xmm0,XMMWORD PTR [rcx-0x20]
  20e4e1:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  20e4e6:	c5 f8 10 47 f0       	vmovups xmm0,XMMWORD PTR [rdi-0x10]
  20e4eb:	c5 f8 11 41 e0       	vmovups XMMWORD PTR [rcx-0x20],xmm0
    b.* = tmp;
  20e4f0:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  20e4f5:	c5 f8 11 47 f0       	vmovups XMMWORD PTR [rdi-0x10],xmm0
    const tmp = a.*;
  20e4fa:	c5 f8 10 41 f0       	vmovups xmm0,XMMWORD PTR [rcx-0x10]
  20e4ff:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  20e504:	c5 f8 10 47 e0       	vmovups xmm0,XMMWORD PTR [rdi-0x20]
  20e509:	c5 f8 11 41 f0       	vmovups XMMWORD PTR [rcx-0x10],xmm0
    b.* = tmp;
  20e50e:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  20e513:	c5 f8 11 47 e0       	vmovups XMMWORD PTR [rdi-0x20],xmm0
    const tmp = a.*;
  20e518:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  20e51c:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  20e521:	c5 f8 10 47 d0       	vmovups xmm0,XMMWORD PTR [rdi-0x30]
  20e526:	c5 f8 11 01          	vmovups XMMWORD PTR [rcx],xmm0
    b.* = tmp;
  20e52a:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  20e52f:	c5 fa 7f 47 d0       	vmovdqu XMMWORD PTR [rdi-0x30],xmm0
    while (i < end) : (i += 1) {
  20e534:	48 83 c2 04          	add    rdx,0x4
  20e538:	48 83 c7 c0          	add    rdi,0xffffffffffffffc0
  20e53c:	48 83 c1 40          	add    rcx,0x40
  20e540:	49 39 d3             	cmp    r11,rdx
  20e543:	0f 85 77 ff ff ff    	jne    20e4c0 <benchmark.add+0x3c80>
  20e549:	48 85 f6             	test   rsi,rsi
  20e54c:	74 52                	je     20e5a0 <benchmark.add+0x3d60>
  20e54e:	48 8b 4c 24 20       	mov    rcx,QWORD PTR [rsp+0x20]
  20e553:	48 29 d1             	sub    rcx,rdx
  20e556:	48 c1 e1 04          	shl    rcx,0x4
  20e55a:	48 01 d9             	add    rcx,rbx
  20e55d:	48 83 c1 e0          	add    rcx,0xffffffffffffffe0
  20e561:	49 01 d4             	add    r12,rdx
  20e564:	49 c1 e4 04          	shl    r12,0x4
  20e568:	49 01 dc             	add    r12,rbx
  20e56b:	48 f7 de             	neg    rsi
  20e56e:	66 90                	xchg   ax,ax
    const tmp = a.*;
  20e570:	c4 c1 78 10 04 24    	vmovups xmm0,XMMWORD PTR [r12]
  20e576:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  20e57b:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  20e57f:	c4 c1 78 11 04 24    	vmovups XMMWORD PTR [r12],xmm0
    b.* = tmp;
  20e585:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  20e58a:	c5 fa 7f 01          	vmovdqu XMMWORD PTR [rcx],xmm0
    while (i < end) : (i += 1) {
  20e58e:	48 83 c1 f0          	add    rcx,0xfffffffffffffff0
  20e592:	49 83 c4 10          	add    r12,0x10
  20e596:	48 83 c6 01          	add    rsi,0x1
  20e59a:	75 d4                	jne    20e570 <benchmark.add+0x3d30>
  20e59c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
                        pull[pull_index].from = index - 1 - count;
  20e5a0:	4d 29 e9             	sub    r9,r13
  20e5a3:	48 8b 4c 24 18       	mov    rcx,QWORD PTR [rsp+0x18]
  20e5a8:	4c 89 09             	mov    QWORD PTR [rcx],r9
                    while (count < length) : (count += 1) {
  20e5ab:	49 83 c5 01          	add    r13,0x1
  20e5af:	48 8b 54 24 10       	mov    rdx,QWORD PTR [rsp+0x10]
  20e5b4:	49 39 d5             	cmp    r13,rdx
  20e5b7:	0f 85 53 fb ff ff    	jne    20e110 <benchmark.add+0x38d0>
  20e5bd:	48 8b 44 24 38       	mov    rax,QWORD PTR [rsp+0x38]
            while (pull_index < 2) : (pull_index += 1) {
  20e5c2:	48 83 c0 01          	add    rax,0x1
  20e5c6:	48 83 f8 02          	cmp    rax,0x2
  20e5ca:	0f 85 90 f4 ff ff    	jne    20da60 <benchmark.add+0x3220>
  20e5d0:	48 8b 74 24 40       	mov    rsi,QWORD PTR [rsp+0x40]
        return self.end - self.start;
  20e5d5:	48 2b b4 24 d8 00 00 	sub    rsi,QWORD PTR [rsp+0xd8]
  20e5dc:	00 
  20e5dd:	48 8b 8c 24 f8 00 00 	mov    rcx,QWORD PTR [rsp+0xf8]
  20e5e4:	00 
  20e5e5:	48 89 c8             	mov    rax,rcx
  20e5e8:	48 09 f0             	or     rax,rsi
  20e5eb:	48 c1 e8 20          	shr    rax,0x20
  20e5ef:	74 0d                	je     20e5fe <benchmark.add+0x3dbe>
  20e5f1:	31 d2                	xor    edx,edx
  20e5f3:	48 89 c8             	mov    rax,rcx
  20e5f6:	48 f7 f6             	div    rsi
  20e5f9:	48 89 c6             	mov    rsi,rax
  20e5fc:	eb 08                	jmp    20e606 <benchmark.add+0x3dc6>
  20e5fe:	31 d2                	xor    edx,edx
  20e600:	89 c8                	mov    eax,ecx
  20e602:	f7 f6                	div    esi
  20e604:	89 c6                	mov    esi,eax
  20e606:	48 8b 84 24 d0 00 00 	mov    rax,QWORD PTR [rsp+0xd0]
  20e60d:	00 
  20e60e:	48 8b 54 24 58       	mov    rdx,QWORD PTR [rsp+0x58]
  20e613:	48 89 74 24 78       	mov    QWORD PTR [rsp+0x78],rsi
            block_size = iterator.length() / buffer_size + 1;
  20e618:	48 8d 76 01          	lea    rsi,[rsi+0x1]
  20e61c:	48 29 d0             	sub    rax,rdx
  20e61f:	48 89 84 24 40 02 00 	mov    QWORD PTR [rsp+0x240],rax
  20e626:	00 
  20e627:	0f 95 c0             	setne  al
  20e62a:	48 81 fe 01 02 00 00 	cmp    rsi,0x201
  20e631:	0f 92 c3             	setb   bl
  20e634:	08 c3                	or     bl,al
  20e636:	88 9c 24 58 01 00 00 	mov    BYTE PTR [rsp+0x158],bl
        mem.swap(T, &items[start1 + index], &items[start2 + index]);
  20e63d:	48 8d 41 ff          	lea    rax,[rcx-0x1]
            while (!iterator.finished()) {
  20e641:	48 89 84 24 c0 01 00 	mov    QWORD PTR [rsp+0x1c0],rax
  20e648:	00 
  20e649:	48 89 f0             	mov    rax,rsi
  20e64c:	48 d1 e8             	shr    rax,1
  20e64f:	89 f1                	mov    ecx,esi
  20e651:	83 e1 03             	and    ecx,0x3
  20e654:	48 89 f7             	mov    rdi,rsi
  20e657:	48 89 4c 24 10       	mov    QWORD PTR [rsp+0x10],rcx
  20e65c:	48 29 cf             	sub    rdi,rcx
  20e65f:	48 89 bc 24 28 01 00 	mov    QWORD PTR [rsp+0x128],rdi
  20e666:	00 
  20e667:	89 f1                	mov    ecx,esi
  20e669:	83 e1 07             	and    ecx,0x7
  20e66c:	48 89 74 24 28       	mov    QWORD PTR [rsp+0x28],rsi
  20e671:	48 89 8c 24 60 01 00 	mov    QWORD PTR [rsp+0x160],rcx
  20e678:	00 
  20e679:	48 29 ce             	sub    rsi,rcx
  20e67c:	48 89 b4 24 98 01 00 	mov    QWORD PTR [rsp+0x198],rsi
  20e683:	00 
  20e684:	89 c1                	mov    ecx,eax
  20e686:	83 e1 03             	and    ecx,0x3
  20e689:	48 8d 70 ff          	lea    rsi,[rax-0x1]
  20e68d:	48 89 b4 24 a8 01 00 	mov    QWORD PTR [rsp+0x1a8],rsi
  20e694:	00 
  20e695:	48 89 8c 24 78 01 00 	mov    QWORD PTR [rsp+0x178],rcx
  20e69c:	00 
  20e69d:	48 29 c8             	sub    rax,rcx
  20e6a0:	48 89 84 24 a0 01 00 	mov    QWORD PTR [rsp+0x1a0],rax
  20e6a7:	00 
  20e6a8:	48 8b 84 24 d8 00 00 	mov    rax,QWORD PTR [rsp+0xd8]
  20e6af:	00 
  20e6b0:	48 c1 e0 04          	shl    rax,0x4
  20e6b4:	48 89 84 24 58 02 00 	mov    QWORD PTR [rsp+0x258],rax
  20e6bb:	00 
  20e6bc:	48 8d 40 10          	lea    rax,[rax+0x10]
  20e6c0:	48 89 84 24 48 02 00 	mov    QWORD PTR [rsp+0x248],rax
  20e6c7:	00 
  20e6c8:	48 c1 e2 04          	shl    rdx,0x4
  20e6cc:	48 89 94 24 40 01 00 	mov    QWORD PTR [rsp+0x140],rdx
  20e6d3:	00 
  20e6d4:	48 8d 42 20          	lea    rax,[rdx+0x20]
  20e6d8:	48 89 84 24 90 01 00 	mov    QWORD PTR [rsp+0x190],rax
  20e6df:	00 
  20e6e0:	31 c0                	xor    eax,eax
  20e6e2:	31 db                	xor    ebx,ebx
  20e6e4:	eb 1a                	jmp    20e700 <benchmark.add+0x3ec0>
  20e6e6:	45 31 d2             	xor    r10d,r10d
  20e6e9:	45 31 f6             	xor    r14d,r14d
    while (index < block_size) : (index += 1) {
  20e6ec:	49 89 f9             	mov    r9,rdi
  20e6ef:	4d 29 d1             	sub    r9,r10
  20e6f2:	0f 85 26 25 00 00    	jne    210c1e <benchmark.add+0x63de>
  20e6f8:	e9 a3 26 00 00       	jmp    210da0 <benchmark.add+0x6560>
  20e6fd:	0f 1f 00             	nop    DWORD PTR [rax]
  20e700:	49 89 c4             	mov    r12,rax
  20e703:	48 8b 94 24 f8 00 00 	mov    rdx,QWORD PTR [rsp+0xf8]
  20e70a:	00 
        self.decimal += self.decimal_step;
  20e70b:	4d 8d 2c 14          	lea    r13,[r12+rdx*1]
  20e70f:	48 8b b4 24 30 01 00 	mov    rsi,QWORD PTR [rsp+0x130]
  20e716:	00 
        self.numerator += self.numerator_step;
  20e717:	48 01 f3             	add    rbx,rsi
        if (self.numerator >= self.denominator) {
  20e71a:	45 31 c9             	xor    r9d,r9d
  20e71d:	48 8b 8c 24 38 01 00 	mov    rcx,QWORD PTR [rsp+0x138]
  20e724:	00 
  20e725:	48 39 cb             	cmp    rbx,rcx
  20e728:	41 0f 93 c1          	setae  r9b
  20e72c:	48 89 c8             	mov    rax,rcx
  20e72f:	bf 00 00 00 00       	mov    edi,0x0
  20e734:	48 0f 42 c7          	cmovb  rax,rdi
  20e738:	48 29 c3             	sub    rbx,rax
  20e73b:	4b 8d 04 29          	lea    rax,[r9+r13*1]
  20e73f:	49 89 c3             	mov    r11,rax
        self.decimal += self.decimal_step;
  20e742:	48 8d 04 10          	lea    rax,[rax+rdx*1]
        self.numerator += self.numerator_step;
  20e746:	48 01 f3             	add    rbx,rsi
        if (self.numerator >= self.denominator) {
  20e749:	31 d2                	xor    edx,edx
  20e74b:	48 89 9c 24 48 01 00 	mov    QWORD PTR [rsp+0x148],rbx
  20e752:	00 
  20e753:	48 39 cb             	cmp    rbx,rcx
  20e756:	48 0f 42 cf          	cmovb  rcx,rdi
  20e75a:	48 89 8c 24 80 01 00 	mov    QWORD PTR [rsp+0x180],rcx
  20e761:	00 
  20e762:	0f 93 c2             	setae  dl
  20e765:	48 01 c2             	add    rdx,rax
  20e768:	4d 89 e7             	mov    r15,r12
  20e76b:	48 89 94 24 e0 00 00 	mov    QWORD PTR [rsp+0xe0],rdx
  20e772:	00 
                if (start == pull[0].range.start) {
  20e773:	4c 3b a4 24 98 00 00 	cmp    r12,QWORD PTR [rsp+0x98]
  20e77a:	00 
  20e77b:	75 63                	jne    20e7e0 <benchmark.add+0x3fa0>
                    if (pull[0].from > pull[0].to) {
  20e77d:	48 8b 84 24 88 00 00 	mov    rax,QWORD PTR [rsp+0x88]
  20e784:	00 
  20e785:	48 39 84 24 80 00 00 	cmp    QWORD PTR [rsp+0x80],rax
  20e78c:	00 
  20e78d:	76 21                	jbe    20e7b0 <benchmark.add+0x3f70>
  20e78f:	4c 8b bc 24 90 00 00 	mov    r15,QWORD PTR [rsp+0x90]
  20e796:	00 
                        A.start += pull[0].count;
  20e797:	4d 01 e7             	add    r15,r12
  20e79a:	48 8b 94 24 e0 00 00 	mov    rdx,QWORD PTR [rsp+0xe0]
  20e7a1:	00 
                        if (A.length() == 0) continue;
  20e7a2:	4d 39 fb             	cmp    r11,r15
  20e7a5:	75 39                	jne    20e7e0 <benchmark.add+0x3fa0>
  20e7a7:	e9 f4 25 00 00       	jmp    210da0 <benchmark.add+0x6560>
  20e7ac:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  20e7b0:	4d 89 e7             	mov    r15,r12
  20e7b3:	48 8b 94 24 e0 00 00 	mov    rdx,QWORD PTR [rsp+0xe0]
  20e7ba:	00 
                    } else if (pull[0].from < pull[0].to) {
  20e7bb:	73 23                	jae    20e7e0 <benchmark.add+0x3fa0>
                        B.end -= pull[0].count;
  20e7bd:	48 8b 94 24 e0 00 00 	mov    rdx,QWORD PTR [rsp+0xe0]
  20e7c4:	00 
  20e7c5:	48 2b 94 24 90 00 00 	sub    rdx,QWORD PTR [rsp+0x90]
  20e7cc:	00 
  20e7cd:	4d 89 e7             	mov    r15,r12
                        if (B.length() == 0) continue;
  20e7d0:	4c 39 da             	cmp    rdx,r11
  20e7d3:	0f 84 c7 25 00 00    	je     210da0 <benchmark.add+0x6560>
  20e7d9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
                if (start == pull[1].range.start) {
  20e7e0:	4c 3b a4 24 c0 00 00 	cmp    r12,QWORD PTR [rsp+0xc0]
  20e7e7:	00 
  20e7e8:	75 46                	jne    20e830 <benchmark.add+0x3ff0>
                    if (pull[1].from > pull[1].to) {
  20e7ea:	48 8b 84 24 b0 00 00 	mov    rax,QWORD PTR [rsp+0xb0]
  20e7f1:	00 
  20e7f2:	48 39 84 24 a8 00 00 	cmp    QWORD PTR [rsp+0xa8],rax
  20e7f9:	00 
  20e7fa:	76 14                	jbe    20e810 <benchmark.add+0x3fd0>
                        A.start += pull[1].count;
  20e7fc:	4c 03 bc 24 b8 00 00 	add    r15,QWORD PTR [rsp+0xb8]
  20e803:	00 
                        if (A.length() == 0) continue;
  20e804:	4d 39 fb             	cmp    r11,r15
  20e807:	75 27                	jne    20e830 <benchmark.add+0x3ff0>
  20e809:	e9 92 25 00 00       	jmp    210da0 <benchmark.add+0x6560>
  20e80e:	66 90                	xchg   ax,ax
                    } else if (pull[1].from < pull[1].to) {
  20e810:	73 1e                	jae    20e830 <benchmark.add+0x3ff0>
                        B.end -= pull[1].count;
  20e812:	48 2b 94 24 b8 00 00 	sub    rdx,QWORD PTR [rsp+0xb8]
  20e819:	00 
                        if (B.length() == 0) continue;
  20e81a:	4c 39 da             	cmp    rdx,r11
  20e81d:	0f 84 7d 25 00 00    	je     210da0 <benchmark.add+0x6560>
  20e823:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20e82a:	84 00 00 00 00 00 
                if (lessThan(items[B.end - 1], items[A.start])) {
  20e830:	48 89 d1             	mov    rcx,rdx
  20e833:	48 c1 e1 04          	shl    rcx,0x4
  20e837:	4c 8b 54 24 48       	mov    r10,QWORD PTR [rsp+0x48]
  20e83c:	4d 89 f8             	mov    r8,r15
  20e83f:	49 c1 e0 04          	shl    r8,0x4
  20e843:	49 8b 44 0a f0       	mov    rax,QWORD PTR [r10+rcx*1-0x10]
  20e848:	4b 3b 04 02          	cmp    rax,QWORD PTR [r10+r8*1]
  20e84c:	73 52                	jae    20e8a0 <benchmark.add+0x4060>
  20e84e:	48 89 4c 24 20       	mov    QWORD PTR [rsp+0x20],rcx
  20e853:	48 89 94 24 e8 00 00 	mov    QWORD PTR [rsp+0xe8],rdx
  20e85a:	00 
                    mem.rotate(T, items[A.start..B.end], A.length());
  20e85b:	4c 29 fa             	sub    rdx,r15
  20e85e:	48 89 d7             	mov    rdi,rdx
        return self.end - self.start;
  20e861:	4d 89 de             	mov    r14,r11
  20e864:	4d 29 fe             	sub    r14,r15
    const end = items.len / 2;
  20e867:	4c 89 f3             	mov    rbx,r14
  20e86a:	48 d1 eb             	shr    rbx,1
    while (i < end) : (i += 1) {
  20e86d:	0f 84 75 01 00 00    	je     20e9e8 <benchmark.add+0x41a8>
        swap(T, &items[i], &items[items.len - i - 1]);
  20e873:	48 8d 43 ff          	lea    rax,[rbx-0x1]
  20e877:	89 da                	mov    edx,ebx
  20e879:	83 e2 03             	and    edx,0x3
  20e87c:	48 83 f8 03          	cmp    rax,0x3
  20e880:	73 69                	jae    20e8eb <benchmark.add+0x40ab>
  20e882:	31 c0                	xor    eax,eax
    while (i < end) : (i += 1) {
  20e884:	48 85 d2             	test   rdx,rdx
  20e887:	0f 85 11 01 00 00    	jne    20e99e <benchmark.add+0x415e>
  20e88d:	e9 56 01 00 00       	jmp    20e9e8 <benchmark.add+0x41a8>
  20e892:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20e899:	1f 84 00 00 00 00 00 
                } else if (lessThan(items[A.end], items[A.end - 1])) {
  20e8a0:	4c 89 d8             	mov    rax,r11
  20e8a3:	48 c1 e0 04          	shl    rax,0x4
  20e8a7:	49 8b 0c 02          	mov    rcx,QWORD PTR [r10+rax*1]
  20e8ab:	49 3b 4c 02 f0       	cmp    rcx,QWORD PTR [r10+rax*1-0x10]
  20e8b0:	0f 83 ea 24 00 00    	jae    210da0 <benchmark.add+0x6560>
        return self.end - self.start;
  20e8b6:	4c 89 d8             	mov    rax,r11
  20e8b9:	4c 29 f8             	sub    rax,r15
  20e8bc:	49 89 c5             	mov    r13,rax
  20e8bf:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  20e8c4:	49 09 cd             	or     r13,rcx
  20e8c7:	49 c1 ed 20          	shr    r13,0x20
  20e8cb:	48 89 94 24 e8 00 00 	mov    QWORD PTR [rsp+0xe8],rdx
  20e8d2:	00 
  20e8d3:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  20e8d8:	0f 84 ad 02 00 00    	je     20eb8b <benchmark.add+0x434b>
  20e8de:	31 d2                	xor    edx,edx
  20e8e0:	48 f7 f1             	div    rcx
  20e8e3:	48 89 d6             	mov    rsi,rdx
  20e8e6:	e9 a6 02 00 00       	jmp    20eb91 <benchmark.add+0x4351>
        swap(T, &items[i], &items[items.len - i - 1]);
  20e8eb:	48 29 d3             	sub    rbx,rdx
  20e8ee:	4b 8d 0c 02          	lea    rcx,[r10+r8*1]
  20e8f2:	48 83 c1 30          	add    rcx,0x30
  20e8f6:	4c 89 d8             	mov    rax,r11
  20e8f9:	48 c1 e0 04          	shl    rax,0x4
  20e8fd:	49 8d 34 02          	lea    rsi,[r10+rax*1]
  20e901:	48 83 c6 f0          	add    rsi,0xfffffffffffffff0
  20e905:	31 c0                	xor    eax,eax
  20e907:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  20e90e:	00 00 
    const tmp = a.*;
  20e910:	c5 f8 10 41 d0       	vmovups xmm0,XMMWORD PTR [rcx-0x30]
  20e915:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  20e91a:	c5 f8 10 06          	vmovups xmm0,XMMWORD PTR [rsi]
  20e91e:	c5 f8 11 41 d0       	vmovups XMMWORD PTR [rcx-0x30],xmm0
    b.* = tmp;
  20e923:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  20e928:	c5 f8 11 06          	vmovups XMMWORD PTR [rsi],xmm0
    const tmp = a.*;
  20e92c:	c5 f8 10 41 e0       	vmovups xmm0,XMMWORD PTR [rcx-0x20]
  20e931:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  20e936:	c5 f8 10 46 f0       	vmovups xmm0,XMMWORD PTR [rsi-0x10]
  20e93b:	c5 f8 11 41 e0       	vmovups XMMWORD PTR [rcx-0x20],xmm0
    b.* = tmp;
  20e940:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  20e945:	c5 f8 11 46 f0       	vmovups XMMWORD PTR [rsi-0x10],xmm0
    const tmp = a.*;
  20e94a:	c5 f8 10 41 f0       	vmovups xmm0,XMMWORD PTR [rcx-0x10]
  20e94f:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  20e954:	c5 f8 10 46 e0       	vmovups xmm0,XMMWORD PTR [rsi-0x20]
  20e959:	c5 f8 11 41 f0       	vmovups XMMWORD PTR [rcx-0x10],xmm0
    b.* = tmp;
  20e95e:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  20e963:	c5 f8 11 46 e0       	vmovups XMMWORD PTR [rsi-0x20],xmm0
    const tmp = a.*;
  20e968:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  20e96c:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  20e971:	c5 f8 10 46 d0       	vmovups xmm0,XMMWORD PTR [rsi-0x30]
  20e976:	c5 f8 11 01          	vmovups XMMWORD PTR [rcx],xmm0
    b.* = tmp;
  20e97a:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  20e97f:	c5 fa 7f 46 d0       	vmovdqu XMMWORD PTR [rsi-0x30],xmm0
    while (i < end) : (i += 1) {
  20e984:	48 83 c0 04          	add    rax,0x4
  20e988:	48 83 c1 40          	add    rcx,0x40
  20e98c:	48 83 c6 c0          	add    rsi,0xffffffffffffffc0
  20e990:	48 39 c3             	cmp    rbx,rax
  20e993:	0f 85 77 ff ff ff    	jne    20e910 <benchmark.add+0x40d0>
  20e999:	48 85 d2             	test   rdx,rdx
  20e99c:	74 4a                	je     20e9e8 <benchmark.add+0x41a8>
  20e99e:	4d 01 cd             	add    r13,r9
  20e9a1:	49 29 c5             	sub    r13,rax
  20e9a4:	49 c1 e5 04          	shl    r13,0x4
  20e9a8:	4b 8d 0c 2a          	lea    rcx,[r10+r13*1]
  20e9ac:	48 83 c1 f0          	add    rcx,0xfffffffffffffff0
  20e9b0:	4c 01 f8             	add    rax,r15
  20e9b3:	48 c1 e0 04          	shl    rax,0x4
  20e9b7:	4c 01 d0             	add    rax,r10
  20e9ba:	48 f7 da             	neg    rdx
  20e9bd:	0f 1f 00             	nop    DWORD PTR [rax]
    const tmp = a.*;
  20e9c0:	c5 f8 10 00          	vmovups xmm0,XMMWORD PTR [rax]
  20e9c4:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  20e9c9:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  20e9cd:	c5 f8 11 00          	vmovups XMMWORD PTR [rax],xmm0
    b.* = tmp;
  20e9d1:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  20e9d6:	c5 fa 7f 01          	vmovdqu XMMWORD PTR [rcx],xmm0
    while (i < end) : (i += 1) {
  20e9da:	48 83 c1 f0          	add    rcx,0xfffffffffffffff0
  20e9de:	48 83 c0 10          	add    rax,0x10
  20e9e2:	48 83 c2 01          	add    rdx,0x1
  20e9e6:	75 d8                	jne    20e9c0 <benchmark.add+0x4180>
    reverse(T, items[amount..]);
  20e9e8:	48 89 f8             	mov    rax,rdi
  20e9eb:	4c 29 f0             	sub    rax,r14
    const end = items.len / 2;
  20e9ee:	48 d1 e8             	shr    rax,1
  20e9f1:	4c 8b b4 24 e8 00 00 	mov    r14,QWORD PTR [rsp+0xe8]
  20e9f8:	00 
    while (i < end) : (i += 1) {
  20e9f9:	0f 84 29 01 00 00    	je     20eb28 <benchmark.add+0x42e8>
        swap(T, &items[i], &items[items.len - i - 1]);
  20e9ff:	48 8d 48 ff          	lea    rcx,[rax-0x1]
  20ea03:	89 c6                	mov    esi,eax
  20ea05:	83 e6 03             	and    esi,0x3
  20ea08:	48 83 f9 03          	cmp    rcx,0x3
  20ea0c:	73 10                	jae    20ea1e <benchmark.add+0x41de>
  20ea0e:	31 d2                	xor    edx,edx
    while (i < end) : (i += 1) {
  20ea10:	48 85 f6             	test   rsi,rsi
  20ea13:	0f 85 b5 00 00 00    	jne    20eace <benchmark.add+0x428e>
  20ea19:	e9 0a 01 00 00       	jmp    20eb28 <benchmark.add+0x42e8>
        swap(T, &items[i], &items[items.len - i - 1]);
  20ea1e:	48 29 f0             	sub    rax,rsi
  20ea21:	49 c1 e3 04          	shl    r11,0x4
  20ea25:	4b 8d 0c 1a          	lea    rcx,[r10+r11*1]
  20ea29:	48 83 c1 30          	add    rcx,0x30
  20ea2d:	48 8b 54 24 20       	mov    rdx,QWORD PTR [rsp+0x20]
  20ea32:	49 8d 1c 12          	lea    rbx,[r10+rdx*1]
  20ea36:	48 83 c3 f0          	add    rbx,0xfffffffffffffff0
  20ea3a:	31 d2                	xor    edx,edx
  20ea3c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
    const tmp = a.*;
  20ea40:	c5 f8 10 41 d0       	vmovups xmm0,XMMWORD PTR [rcx-0x30]
  20ea45:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  20ea4a:	c5 f8 10 03          	vmovups xmm0,XMMWORD PTR [rbx]
  20ea4e:	c5 f8 11 41 d0       	vmovups XMMWORD PTR [rcx-0x30],xmm0
    b.* = tmp;
  20ea53:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  20ea58:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
    const tmp = a.*;
  20ea5c:	c5 f8 10 41 e0       	vmovups xmm0,XMMWORD PTR [rcx-0x20]
  20ea61:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  20ea66:	c5 f8 10 43 f0       	vmovups xmm0,XMMWORD PTR [rbx-0x10]
  20ea6b:	c5 f8 11 41 e0       	vmovups XMMWORD PTR [rcx-0x20],xmm0
    b.* = tmp;
  20ea70:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  20ea75:	c5 f8 11 43 f0       	vmovups XMMWORD PTR [rbx-0x10],xmm0
    const tmp = a.*;
  20ea7a:	c5 f8 10 41 f0       	vmovups xmm0,XMMWORD PTR [rcx-0x10]
  20ea7f:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  20ea84:	c5 f8 10 43 e0       	vmovups xmm0,XMMWORD PTR [rbx-0x20]
  20ea89:	c5 f8 11 41 f0       	vmovups XMMWORD PTR [rcx-0x10],xmm0
    b.* = tmp;
  20ea8e:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  20ea93:	c5 f8 11 43 e0       	vmovups XMMWORD PTR [rbx-0x20],xmm0
    const tmp = a.*;
  20ea98:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  20ea9c:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  20eaa1:	c5 f8 10 43 d0       	vmovups xmm0,XMMWORD PTR [rbx-0x30]
  20eaa6:	c5 f8 11 01          	vmovups XMMWORD PTR [rcx],xmm0
    b.* = tmp;
  20eaaa:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  20eaaf:	c5 fa 7f 43 d0       	vmovdqu XMMWORD PTR [rbx-0x30],xmm0
    while (i < end) : (i += 1) {
  20eab4:	48 83 c2 04          	add    rdx,0x4
  20eab8:	48 83 c1 40          	add    rcx,0x40
  20eabc:	48 83 c3 c0          	add    rbx,0xffffffffffffffc0
  20eac0:	48 39 d0             	cmp    rax,rdx
  20eac3:	0f 85 77 ff ff ff    	jne    20ea40 <benchmark.add+0x4200>
  20eac9:	48 85 f6             	test   rsi,rsi
  20eacc:	74 5a                	je     20eb28 <benchmark.add+0x42e8>
  20eace:	4c 89 f0             	mov    rax,r14
  20ead1:	48 29 d0             	sub    rax,rdx
  20ead4:	48 c1 e0 04          	shl    rax,0x4
  20ead8:	4c 01 d0             	add    rax,r10
  20eadb:	48 83 c0 f0          	add    rax,0xfffffffffffffff0
  20eadf:	48 03 94 24 f8 00 00 	add    rdx,QWORD PTR [rsp+0xf8]
  20eae6:	00 
  20eae7:	4c 01 e2             	add    rdx,r12
  20eaea:	4c 01 ca             	add    rdx,r9
  20eaed:	48 c1 e2 04          	shl    rdx,0x4
  20eaf1:	4c 01 d2             	add    rdx,r10
  20eaf4:	48 f7 de             	neg    rsi
  20eaf7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  20eafe:	00 00 
    const tmp = a.*;
  20eb00:	c5 f8 10 02          	vmovups xmm0,XMMWORD PTR [rdx]
  20eb04:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  20eb09:	c5 f8 10 00          	vmovups xmm0,XMMWORD PTR [rax]
  20eb0d:	c5 f8 11 02          	vmovups XMMWORD PTR [rdx],xmm0
    b.* = tmp;
  20eb11:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  20eb16:	c5 fa 7f 00          	vmovdqu XMMWORD PTR [rax],xmm0
    while (i < end) : (i += 1) {
  20eb1a:	48 83 c0 f0          	add    rax,0xfffffffffffffff0
  20eb1e:	48 83 c2 10          	add    rdx,0x10
  20eb22:	48 83 c6 01          	add    rsi,0x1
  20eb26:	75 d8                	jne    20eb00 <benchmark.add+0x42c0>
    const end = items.len / 2;
  20eb28:	48 89 f8             	mov    rax,rdi
  20eb2b:	48 d1 e8             	shr    rax,1
    while (i < end) : (i += 1) {
  20eb2e:	0f 84 6c 22 00 00    	je     210da0 <benchmark.add+0x6560>
  20eb34:	4b 8d 0c 02          	lea    rcx,[r10+r8*1]
    const tmp = a.*;
  20eb38:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  20eb3c:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  20eb41:	48 c1 e7 04          	shl    rdi,0x4
    a.* = b.*;
  20eb45:	c5 f8 10 44 39 f0    	vmovups xmm0,XMMWORD PTR [rcx+rdi*1-0x10]
  20eb4b:	c5 f8 11 01          	vmovups XMMWORD PTR [rcx],xmm0
    b.* = tmp;
  20eb4f:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  20eb54:	c5 fa 7f 44 39 f0    	vmovdqu XMMWORD PTR [rcx+rdi*1-0x10],xmm0
    while (i < end) : (i += 1) {
  20eb5a:	48 83 f8 01          	cmp    rax,0x1
  20eb5e:	0f 84 3c 22 00 00    	je     210da0 <benchmark.add+0x6560>
        swap(T, &items[i], &items[items.len - i - 1]);
  20eb64:	8d 48 ff             	lea    ecx,[rax-0x1]
  20eb67:	48 8d 50 fe          	lea    rdx,[rax-0x2]
  20eb6b:	83 e1 03             	and    ecx,0x3
  20eb6e:	48 83 fa 03          	cmp    rdx,0x3
  20eb72:	0f 83 62 01 00 00    	jae    20ecda <benchmark.add+0x449a>
  20eb78:	ba 01 00 00 00       	mov    edx,0x1
    while (i < end) : (i += 1) {
  20eb7d:	48 85 c9             	test   rcx,rcx
  20eb80:	0f 85 0c 02 00 00    	jne    20ed92 <benchmark.add+0x4552>
  20eb86:	e9 15 22 00 00       	jmp    210da0 <benchmark.add+0x6560>
  20eb8b:	31 d2                	xor    edx,edx
  20eb8d:	f7 f1                	div    ecx
  20eb8f:	89 d6                	mov    esi,edx
                    var firstA = Range.init(A.start, A.start + blockA.length() % block_size);
  20eb91:	4a 8d 04 3e          	lea    rax,[rsi+r15*1]
  20eb95:	48 89 44 24 20       	mov    QWORD PTR [rsp+0x20],rax
                    while (index < blockA.end) : ({
  20eb9a:	4c 39 d8             	cmp    rax,r11
  20eb9d:	4c 8b 74 24 58       	mov    r14,QWORD PTR [rsp+0x58]
  20eba2:	48 8b 7c 24 28       	mov    rdi,QWORD PTR [rsp+0x28]
  20eba7:	0f 83 89 00 00 00    	jae    20ec36 <benchmark.add+0x43f6>
  20ebad:	48 8b 54 24 20       	mov    rdx,QWORD PTR [rsp+0x20]
                        mem.swap(T, &items[indexA], &items[index]);
  20ebb2:	48 89 d0             	mov    rax,rdx
  20ebb5:	48 c1 e0 04          	shl    rax,0x4
  20ebb9:	48 8b 8c 24 58 02 00 	mov    rcx,QWORD PTR [rsp+0x258]
  20ebc0:	00 
    const tmp = a.*;
  20ebc1:	c4 c1 78 10 04 0a    	vmovups xmm0,XMMWORD PTR [r10+rcx*1]
  20ebc7:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  20ebcc:	c4 c1 78 10 04 02    	vmovups xmm0,XMMWORD PTR [r10+rax*1]
  20ebd2:	c4 c1 78 11 04 0a    	vmovups XMMWORD PTR [r10+rcx*1],xmm0
    b.* = tmp;
  20ebd8:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  20ebdd:	c4 c1 7a 7f 04 02    	vmovdqu XMMWORD PTR [r10+rax*1],xmm0
                        index += block_size;
  20ebe3:	48 8d 1c 3a          	lea    rbx,[rdx+rdi*1]
                    while (index < blockA.end) : ({
  20ebe7:	4c 39 db             	cmp    rbx,r11
  20ebea:	73 4a                	jae    20ec36 <benchmark.add+0x43f6>
  20ebec:	48 8b 8c 24 48 02 00 	mov    rcx,QWORD PTR [rsp+0x248]
  20ebf3:	00 
  20ebf4:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20ebfb:	00 00 00 00 00 
                        mem.swap(T, &items[indexA], &items[index]);
  20ec00:	48 8b 54 24 48       	mov    rdx,QWORD PTR [rsp+0x48]
  20ec05:	48 89 d8             	mov    rax,rbx
    const tmp = a.*;
  20ec08:	c5 f8 10 04 0a       	vmovups xmm0,XMMWORD PTR [rdx+rcx*1]
  20ec0d:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
  20ec12:	48 c1 e0 04          	shl    rax,0x4
    a.* = b.*;
  20ec16:	c5 f8 10 04 02       	vmovups xmm0,XMMWORD PTR [rdx+rax*1]
  20ec1b:	c5 f8 11 04 0a       	vmovups XMMWORD PTR [rdx+rcx*1],xmm0
    b.* = tmp;
  20ec20:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  20ec25:	c5 fa 7f 04 02       	vmovdqu XMMWORD PTR [rdx+rax*1],xmm0
                        index += block_size;
  20ec2a:	48 01 fb             	add    rbx,rdi
                    while (index < blockA.end) : ({
  20ec2d:	48 83 c1 10          	add    rcx,0x10
  20ec31:	4c 39 db             	cmp    rbx,r11
  20ec34:	72 ca                	jb     20ec00 <benchmark.add+0x43c0>
                    var lastA = firstA;
  20ec36:	4c 89 bc 24 b0 01 00 	mov    QWORD PTR [rsp+0x1b0],r15
  20ec3d:	00 
  20ec3e:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
  20ec43:	48 89 84 24 b8 01 00 	mov    QWORD PTR [rsp+0x1b8],rax
  20ec4a:	00 
        return self.end - self.start;
  20ec4b:	48 8b 84 24 e8 00 00 	mov    rax,QWORD PTR [rsp+0xe8]
  20ec52:	00 
  20ec53:	4c 29 d8             	sub    rax,r11
    return if (x < y) x else y;
  20ec56:	48 39 c7             	cmp    rdi,rax
  20ec59:	48 0f 42 c7          	cmovb  rax,rdi
  20ec5d:	48 89 44 24 40       	mov    QWORD PTR [rsp+0x40],rax
                    if (lastA.length() <= cache.len) {
  20ec62:	48 81 fe 00 02 00 00 	cmp    rsi,0x200
  20ec69:	4d 89 da             	mov    r10,r11
  20ec6c:	77 36                	ja     20eca4 <benchmark.add+0x4464>
    for (source) |s, i|
  20ec6e:	48 85 f6             	test   rsi,rsi
  20ec71:	48 8b 7c 24 60       	mov    rdi,QWORD PTR [rsp+0x60]
  20ec76:	0f 84 b5 03 00 00    	je     20f031 <benchmark.add+0x47f1>
  20ec7c:	4c 03 44 24 48       	add    r8,QWORD PTR [rsp+0x48]
  20ec81:	4c 03 a4 24 c0 01 00 	add    r12,QWORD PTR [rsp+0x1c0]
  20ec88:	00 
  20ec89:	4d 01 cc             	add    r12,r9
  20ec8c:	4d 85 ed             	test   r13,r13
  20ec8f:	0f 84 4a 01 00 00    	je     20eddf <benchmark.add+0x459f>
  20ec95:	31 d2                	xor    edx,edx
  20ec97:	48 89 f8             	mov    rax,rdi
  20ec9a:	48 f7 74 24 28       	div    QWORD PTR [rsp+0x28]
  20ec9f:	e9 43 01 00 00       	jmp    20ede7 <benchmark.add+0x45a7>
  20eca4:	4c 39 b4 24 d0 00 00 	cmp    QWORD PTR [rsp+0xd0],r14
  20ecab:	00 
  20ecac:	48 8b 7c 24 60       	mov    rdi,QWORD PTR [rsp+0x60]
                    } else if (buffer2.length() > 0) {
  20ecb1:	0f 84 7a 03 00 00    	je     20f031 <benchmark.add+0x47f1>
        mem.swap(T, &items[start1 + index], &items[start2 + index]);
  20ecb7:	4c 03 a4 24 c0 01 00 	add    r12,QWORD PTR [rsp+0x1c0]
  20ecbe:	00 
  20ecbf:	4d 01 cc             	add    r12,r9
  20ecc2:	4d 85 ed             	test   r13,r13
  20ecc5:	0f 84 13 02 00 00    	je     20eede <benchmark.add+0x469e>
  20eccb:	31 d2                	xor    edx,edx
  20eccd:	48 89 f8             	mov    rax,rdi
  20ecd0:	48 f7 74 24 28       	div    QWORD PTR [rsp+0x28]
  20ecd5:	e9 0c 02 00 00       	jmp    20eee6 <benchmark.add+0x46a6>
        swap(T, &items[i], &items[items.len - i - 1]);
  20ecda:	48 8b 54 24 20       	mov    rdx,QWORD PTR [rsp+0x20]
  20ecdf:	49 8d 34 12          	lea    rsi,[r10+rdx*1]
  20ece3:	48 83 c6 e0          	add    rsi,0xffffffffffffffe0
  20ece7:	4b 8d 3c 02          	lea    rdi,[r10+r8*1]
  20eceb:	48 83 c7 40          	add    rdi,0x40
  20ecef:	48 29 c8             	sub    rax,rcx
  20ecf2:	ba 01 00 00 00       	mov    edx,0x1
  20ecf7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  20ecfe:	00 00 
    const tmp = a.*;
  20ed00:	c5 f8 10 47 d0       	vmovups xmm0,XMMWORD PTR [rdi-0x30]
  20ed05:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  20ed0a:	c5 f8 10 06          	vmovups xmm0,XMMWORD PTR [rsi]
  20ed0e:	c5 f8 11 47 d0       	vmovups XMMWORD PTR [rdi-0x30],xmm0
    b.* = tmp;
  20ed13:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  20ed18:	c5 f8 11 06          	vmovups XMMWORD PTR [rsi],xmm0
    const tmp = a.*;
  20ed1c:	c5 f8 10 47 e0       	vmovups xmm0,XMMWORD PTR [rdi-0x20]
  20ed21:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  20ed26:	c5 f8 10 46 f0       	vmovups xmm0,XMMWORD PTR [rsi-0x10]
  20ed2b:	c5 f8 11 47 e0       	vmovups XMMWORD PTR [rdi-0x20],xmm0
    b.* = tmp;
  20ed30:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  20ed35:	c5 f8 11 46 f0       	vmovups XMMWORD PTR [rsi-0x10],xmm0
    const tmp = a.*;
  20ed3a:	c5 f8 10 47 f0       	vmovups xmm0,XMMWORD PTR [rdi-0x10]
  20ed3f:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  20ed44:	c5 f8 10 46 e0       	vmovups xmm0,XMMWORD PTR [rsi-0x20]
  20ed49:	c5 f8 11 47 f0       	vmovups XMMWORD PTR [rdi-0x10],xmm0
    b.* = tmp;
  20ed4e:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  20ed53:	c5 f8 11 46 e0       	vmovups XMMWORD PTR [rsi-0x20],xmm0
    const tmp = a.*;
  20ed58:	c5 f8 10 07          	vmovups xmm0,XMMWORD PTR [rdi]
  20ed5c:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  20ed61:	c5 f8 10 46 d0       	vmovups xmm0,XMMWORD PTR [rsi-0x30]
  20ed66:	c5 f8 11 07          	vmovups XMMWORD PTR [rdi],xmm0
    b.* = tmp;
  20ed6a:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  20ed6f:	c5 fa 7f 46 d0       	vmovdqu XMMWORD PTR [rsi-0x30],xmm0
    while (i < end) : (i += 1) {
  20ed74:	48 83 c2 04          	add    rdx,0x4
  20ed78:	48 83 c6 c0          	add    rsi,0xffffffffffffffc0
  20ed7c:	48 83 c7 40          	add    rdi,0x40
  20ed80:	48 39 d0             	cmp    rax,rdx
  20ed83:	0f 85 77 ff ff ff    	jne    20ed00 <benchmark.add+0x44c0>
  20ed89:	48 85 c9             	test   rcx,rcx
  20ed8c:	0f 84 0e 20 00 00    	je     210da0 <benchmark.add+0x6560>
  20ed92:	49 29 d6             	sub    r14,rdx
  20ed95:	49 c1 e6 04          	shl    r14,0x4
  20ed99:	4b 8d 04 32          	lea    rax,[r10+r14*1]
  20ed9d:	48 83 c0 f0          	add    rax,0xfffffffffffffff0
  20eda1:	49 01 d7             	add    r15,rdx
  20eda4:	49 c1 e7 04          	shl    r15,0x4
  20eda8:	4d 01 d7             	add    r15,r10
  20edab:	48 f7 d9             	neg    rcx
  20edae:	66 90                	xchg   ax,ax
    const tmp = a.*;
  20edb0:	c4 c1 78 10 07       	vmovups xmm0,XMMWORD PTR [r15]
  20edb5:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  20edba:	c5 f8 10 00          	vmovups xmm0,XMMWORD PTR [rax]
  20edbe:	c4 c1 78 11 07       	vmovups XMMWORD PTR [r15],xmm0
    b.* = tmp;
  20edc3:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  20edc8:	c5 fa 7f 00          	vmovdqu XMMWORD PTR [rax],xmm0
    while (i < end) : (i += 1) {
  20edcc:	48 83 c0 f0          	add    rax,0xfffffffffffffff0
  20edd0:	49 83 c7 10          	add    r15,0x10
  20edd4:	48 83 c1 01          	add    rcx,0x1
  20edd8:	75 d6                	jne    20edb0 <benchmark.add+0x4570>
  20edda:	e9 c1 1f 00 00       	jmp    210da0 <benchmark.add+0x6560>
  20eddf:	31 d2                	xor    edx,edx
  20ede1:	89 f8                	mov    eax,edi
  20ede3:	f7 74 24 28          	div    DWORD PTR [rsp+0x28]
    for (source) |s, i|
  20ede7:	48 29 fa             	sub    rdx,rdi
  20edea:	49 01 d4             	add    r12,rdx
  20eded:	4d 29 fc             	sub    r12,r15
  20edf0:	89 f0                	mov    eax,esi
  20edf2:	83 e0 07             	and    eax,0x7
  20edf5:	49 83 fc 07          	cmp    r12,0x7
  20edf9:	73 10                	jae    20ee0b <benchmark.add+0x45cb>
  20edfb:	31 c9                	xor    ecx,ecx
  20edfd:	48 85 c0             	test   rax,rax
  20ee00:	0f 85 b4 00 00 00    	jne    20eeba <benchmark.add+0x467a>
  20ee06:	e9 26 02 00 00       	jmp    20f031 <benchmark.add+0x47f1>
  20ee0b:	48 29 c6             	sub    rsi,rax
  20ee0e:	ba 70 00 00 00       	mov    edx,0x70
  20ee13:	31 c9                	xor    ecx,ecx
  20ee15:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20ee1c:	00 00 00 00 
        dest[i] = s;
  20ee20:	c4 c1 78 10 44 10 90 	vmovups xmm0,XMMWORD PTR [r8+rdx*1-0x70]
  20ee27:	c5 f8 11 84 14 30 02 	vmovups XMMWORD PTR [rsp+rdx*1+0x230],xmm0
  20ee2e:	00 00 
  20ee30:	c4 c1 78 10 44 10 a0 	vmovups xmm0,XMMWORD PTR [r8+rdx*1-0x60]
  20ee37:	c5 f8 11 84 14 40 02 	vmovups XMMWORD PTR [rsp+rdx*1+0x240],xmm0
  20ee3e:	00 00 
  20ee40:	c4 c1 78 10 44 10 b0 	vmovups xmm0,XMMWORD PTR [r8+rdx*1-0x50]
  20ee47:	c5 f8 11 84 14 50 02 	vmovups XMMWORD PTR [rsp+rdx*1+0x250],xmm0
  20ee4e:	00 00 
  20ee50:	c4 c1 78 10 44 10 c0 	vmovups xmm0,XMMWORD PTR [r8+rdx*1-0x40]
  20ee57:	c5 f8 11 84 14 60 02 	vmovups XMMWORD PTR [rsp+rdx*1+0x260],xmm0
  20ee5e:	00 00 
  20ee60:	c4 c1 78 10 44 10 d0 	vmovups xmm0,XMMWORD PTR [r8+rdx*1-0x30]
  20ee67:	c5 f8 11 84 14 70 02 	vmovups XMMWORD PTR [rsp+rdx*1+0x270],xmm0
  20ee6e:	00 00 
  20ee70:	c4 c1 78 10 44 10 e0 	vmovups xmm0,XMMWORD PTR [r8+rdx*1-0x20]
  20ee77:	c5 f8 11 84 14 80 02 	vmovups XMMWORD PTR [rsp+rdx*1+0x280],xmm0
  20ee7e:	00 00 
  20ee80:	c4 c1 78 10 44 10 f0 	vmovups xmm0,XMMWORD PTR [r8+rdx*1-0x10]
  20ee87:	c5 f8 11 84 14 90 02 	vmovups XMMWORD PTR [rsp+rdx*1+0x290],xmm0
  20ee8e:	00 00 
  20ee90:	c4 c1 7a 6f 04 10    	vmovdqu xmm0,XMMWORD PTR [r8+rdx*1]
  20ee96:	c5 fa 7f 84 14 a0 02 	vmovdqu XMMWORD PTR [rsp+rdx*1+0x2a0],xmm0
  20ee9d:	00 00 
    for (source) |s, i|
  20ee9f:	48 83 c1 08          	add    rcx,0x8
  20eea3:	48 83 ea 80          	sub    rdx,0xffffffffffffff80
  20eea7:	48 83 c6 f8          	add    rsi,0xfffffffffffffff8
  20eeab:	0f 85 6f ff ff ff    	jne    20ee20 <benchmark.add+0x45e0>
  20eeb1:	48 85 c0             	test   rax,rax
  20eeb4:	0f 84 77 01 00 00    	je     20f031 <benchmark.add+0x47f1>
  20eeba:	48 c1 e1 04          	shl    rcx,0x4
  20eebe:	66 90                	xchg   ax,ax
        dest[i] = s;
  20eec0:	c4 c1 7a 6f 04 08    	vmovdqu xmm0,XMMWORD PTR [r8+rcx*1]
  20eec6:	c5 fa 7f 84 0c a0 02 	vmovdqu XMMWORD PTR [rsp+rcx*1+0x2a0],xmm0
  20eecd:	00 00 
    for (source) |s, i|
  20eecf:	48 83 c1 10          	add    rcx,0x10
  20eed3:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  20eed7:	75 e7                	jne    20eec0 <benchmark.add+0x4680>
  20eed9:	e9 53 01 00 00       	jmp    20f031 <benchmark.add+0x47f1>
  20eede:	31 d2                	xor    edx,edx
  20eee0:	89 f8                	mov    eax,edi
  20eee2:	f7 74 24 28          	div    DWORD PTR [rsp+0x28]
  20eee6:	49 89 fb             	mov    r11,rdi
  20eee9:	48 29 fa             	sub    rdx,rdi
  20eeec:	49 01 d4             	add    r12,rdx
  20eeef:	4d 29 fc             	sub    r12,r15
  20eef2:	89 f0                	mov    eax,esi
  20eef4:	83 e0 03             	and    eax,0x3
  20eef7:	49 83 fc 03          	cmp    r12,0x3
  20eefb:	73 13                	jae    20ef10 <benchmark.add+0x46d0>
  20eefd:	31 c9                	xor    ecx,ecx
    while (index < block_size) : (index += 1) {
  20eeff:	48 85 c0             	test   rax,rax
  20ef02:	4c 89 df             	mov    rdi,r11
  20ef05:	0f 85 e0 00 00 00    	jne    20efeb <benchmark.add+0x47ab>
  20ef0b:	e9 21 01 00 00       	jmp    20f031 <benchmark.add+0x47f1>
        mem.swap(T, &items[start1 + index], &items[start2 + index]);
  20ef10:	48 29 c6             	sub    rsi,rax
  20ef13:	31 d2                	xor    edx,edx
  20ef15:	31 c9                	xor    ecx,ecx
  20ef17:	4c 8b 8c 24 40 01 00 	mov    r9,QWORD PTR [rsp+0x140]
  20ef1e:	00 
  20ef1f:	90                   	nop
  20ef20:	48 8b 5c 24 48       	mov    rbx,QWORD PTR [rsp+0x48]
    const tmp = a.*;
  20ef25:	4a 8d 3c 03          	lea    rdi,[rbx+r8*1]
  20ef29:	c5 f8 10 04 3a       	vmovups xmm0,XMMWORD PTR [rdx+rdi*1]
  20ef2e:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  20ef33:	4c 01 cb             	add    rbx,r9
  20ef36:	c5 f8 10 04 1a       	vmovups xmm0,XMMWORD PTR [rdx+rbx*1]
  20ef3b:	c5 f8 11 04 3a       	vmovups XMMWORD PTR [rdx+rdi*1],xmm0
    b.* = tmp;
  20ef40:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  20ef45:	c5 f8 11 04 1a       	vmovups XMMWORD PTR [rdx+rbx*1],xmm0
  20ef4a:	48 8b 7c 24 48       	mov    rdi,QWORD PTR [rsp+0x48]
    const tmp = a.*;
  20ef4f:	4a 8d 5c 07 10       	lea    rbx,[rdi+r8*1+0x10]
  20ef54:	c5 f8 10 04 1a       	vmovups xmm0,XMMWORD PTR [rdx+rbx*1]
  20ef59:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  20ef5e:	4a 8d 7c 0f 10       	lea    rdi,[rdi+r9*1+0x10]
  20ef63:	c5 f8 10 04 3a       	vmovups xmm0,XMMWORD PTR [rdx+rdi*1]
  20ef68:	c5 f8 11 04 1a       	vmovups XMMWORD PTR [rdx+rbx*1],xmm0
    b.* = tmp;
  20ef6d:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  20ef72:	c5 f8 11 04 3a       	vmovups XMMWORD PTR [rdx+rdi*1],xmm0
  20ef77:	48 8b 7c 24 48       	mov    rdi,QWORD PTR [rsp+0x48]
    const tmp = a.*;
  20ef7c:	4a 8d 5c 07 20       	lea    rbx,[rdi+r8*1+0x20]
  20ef81:	c5 f8 10 04 1a       	vmovups xmm0,XMMWORD PTR [rdx+rbx*1]
  20ef86:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  20ef8b:	4a 8d 7c 0f 20       	lea    rdi,[rdi+r9*1+0x20]
  20ef90:	c5 f8 10 04 3a       	vmovups xmm0,XMMWORD PTR [rdx+rdi*1]
  20ef95:	c5 f8 11 04 1a       	vmovups XMMWORD PTR [rdx+rbx*1],xmm0
    b.* = tmp;
  20ef9a:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  20ef9f:	c5 f8 11 04 3a       	vmovups XMMWORD PTR [rdx+rdi*1],xmm0
  20efa4:	48 8b 7c 24 48       	mov    rdi,QWORD PTR [rsp+0x48]
    const tmp = a.*;
  20efa9:	4a 8d 5c 07 30       	lea    rbx,[rdi+r8*1+0x30]
  20efae:	c5 f8 10 04 1a       	vmovups xmm0,XMMWORD PTR [rdx+rbx*1]
  20efb3:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  20efb8:	4a 8d 7c 0f 30       	lea    rdi,[rdi+r9*1+0x30]
  20efbd:	c5 f8 10 04 3a       	vmovups xmm0,XMMWORD PTR [rdx+rdi*1]
  20efc2:	c5 f8 11 04 1a       	vmovups XMMWORD PTR [rdx+rbx*1],xmm0
    b.* = tmp;
  20efc7:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  20efcc:	c5 fa 7f 04 3a       	vmovdqu XMMWORD PTR [rdx+rdi*1],xmm0
    while (index < block_size) : (index += 1) {
  20efd1:	48 83 c1 04          	add    rcx,0x4
  20efd5:	48 83 c2 40          	add    rdx,0x40
  20efd9:	48 83 c6 fc          	add    rsi,0xfffffffffffffffc
  20efdd:	0f 85 3d ff ff ff    	jne    20ef20 <benchmark.add+0x46e0>
  20efe3:	48 85 c0             	test   rax,rax
  20efe6:	4c 89 df             	mov    rdi,r11
  20efe9:	74 46                	je     20f031 <benchmark.add+0x47f1>
  20efeb:	49 8d 14 0e          	lea    rdx,[r14+rcx*1]
  20efef:	48 c1 e2 04          	shl    rdx,0x4
  20eff3:	4c 01 f9             	add    rcx,r15
  20eff6:	48 c1 e1 04          	shl    rcx,0x4
  20effa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
        mem.swap(T, &items[start1 + index], &items[start2 + index]);
  20f000:	48 8b 74 24 48       	mov    rsi,QWORD PTR [rsp+0x48]
    const tmp = a.*;
  20f005:	c5 f8 10 04 0e       	vmovups xmm0,XMMWORD PTR [rsi+rcx*1]
  20f00a:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  20f00f:	c5 f8 10 04 16       	vmovups xmm0,XMMWORD PTR [rsi+rdx*1]
  20f014:	c5 f8 11 04 0e       	vmovups XMMWORD PTR [rsi+rcx*1],xmm0
    b.* = tmp;
  20f019:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  20f01e:	c5 fa 7f 04 16       	vmovdqu XMMWORD PTR [rsi+rdx*1],xmm0
    while (index < block_size) : (index += 1) {
  20f023:	48 83 c2 10          	add    rdx,0x10
  20f027:	48 83 c1 10          	add    rcx,0x10
  20f02b:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  20f02f:	75 cf                	jne    20f000 <benchmark.add+0x47c0>
  20f031:	48 8b 4c 24 20       	mov    rcx,QWORD PTR [rsp+0x20]
                    if (blockA.length() > 0) {
  20f036:	49 39 ca             	cmp    r10,rcx
  20f039:	0f 85 cc 00 00 00    	jne    20f10b <benchmark.add+0x48cb>
  20f03f:	4d 89 d5             	mov    r13,r10
  20f042:	4c 8b 84 24 e8 00 00 	mov    r8,QWORD PTR [rsp+0xe8]
  20f049:	00 
                    if (lastA.length() <= cache.len) {
  20f04a:	48 81 ff 00 02 00 00 	cmp    rdi,0x200
  20f051:	0f 87 95 1a 00 00    	ja     210aec <benchmark.add+0x62ac>
    if (B.length() > 0 and A.length() > 0) {
  20f057:	48 85 ff             	test   rdi,rdi
  20f05a:	0f 84 e8 00 00 00    	je     20f148 <benchmark.add+0x4908>
  20f060:	4d 39 e8             	cmp    r8,r13
  20f063:	0f 84 df 00 00 00    	je     20f148 <benchmark.add+0x4908>
  20f069:	49 89 fe             	mov    r14,rdi
            if (!lessThan(items[B_index], cache[A_index])) {
  20f06c:	49 89 fa             	mov    r10,rdi
  20f06f:	49 f7 da             	neg    r10
  20f072:	31 d2                	xor    edx,edx
  20f074:	49 89 d1             	mov    r9,rdx
  20f077:	4c 89 fb             	mov    rbx,r15
  20f07a:	48 c1 e3 04          	shl    rbx,0x4
  20f07e:	4f 8d 1c 0a          	lea    r11,[r10+r9*1]
  20f082:	4c 89 c8             	mov    rax,r9
  20f085:	48 c1 e0 04          	shl    rax,0x4
  20f089:	48 8d 0c 04          	lea    rcx,[rsp+rax*1]
  20f08d:	48 81 c1 a0 02 00 00 	add    rcx,0x2a0
  20f094:	31 f6                	xor    esi,esi
  20f096:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  20f09d:	00 00 00 
  20f0a0:	48 8b 54 24 48       	mov    rdx,QWORD PTR [rsp+0x48]
  20f0a5:	4c 89 e8             	mov    rax,r13
  20f0a8:	48 c1 e0 04          	shl    rax,0x4
  20f0ac:	48 8b 3c 02          	mov    rdi,QWORD PTR [rdx+rax*1]
  20f0b0:	48 3b 39             	cmp    rdi,QWORD PTR [rcx]
  20f0b3:	72 1c                	jb     20f0d1 <benchmark.add+0x4891>
                items[insert_index] = cache[A_index];
  20f0b5:	c5 fa 6f 01          	vmovdqu xmm0,XMMWORD PTR [rcx]
  20f0b9:	c5 fa 7f 04 1a       	vmovdqu XMMWORD PTR [rdx+rbx*1],xmm0
                if (A_index == A_last) break;
  20f0be:	48 83 c6 ff          	add    rsi,0xffffffffffffffff
  20f0c2:	48 83 c3 10          	add    rbx,0x10
  20f0c6:	48 83 c1 10          	add    rcx,0x10
  20f0ca:	49 39 f3             	cmp    r11,rsi
  20f0cd:	75 d1                	jne    20f0a0 <benchmark.add+0x4860>
  20f0cf:	eb 7c                	jmp    20f14d <benchmark.add+0x490d>
  20f0d1:	48 01 d0             	add    rax,rdx
                items[insert_index] = items[B_index];
  20f0d4:	c5 fa 6f 00          	vmovdqu xmm0,XMMWORD PTR [rax]
  20f0d8:	c5 fa 7f 04 1a       	vmovdqu XMMWORD PTR [rdx+rbx*1],xmm0
                B_index += 1;
  20f0dd:	49 83 c5 01          	add    r13,0x1
                if (B_index == B_last) break;
  20f0e1:	4c 89 f9             	mov    rcx,r15
  20f0e4:	48 83 c1 01          	add    rcx,0x1
  20f0e8:	49 89 cf             	mov    r15,rcx
  20f0eb:	49 29 f7             	sub    r15,rsi
  20f0ee:	4c 89 ca             	mov    rdx,r9
  20f0f1:	48 29 f2             	sub    rdx,rsi
  20f0f4:	4d 39 c5             	cmp    r13,r8
  20f0f7:	0f 85 77 ff ff ff    	jne    20f074 <benchmark.add+0x4834>
    mem.copy(T, items[insert_index..], cache[A_index..A_last]);
  20f0fd:	48 29 f1             	sub    rcx,rsi
  20f100:	49 29 f1             	sub    r9,rsi
  20f103:	49 89 cf             	mov    r15,rcx
  20f106:	4c 89 f7             	mov    rdi,r14
  20f109:	eb 4b                	jmp    20f156 <benchmark.add+0x4916>
  20f10b:	48 8b 5c 24 40       	mov    rbx,QWORD PTR [rsp+0x40]
  20f110:	4c 01 d3             	add    rbx,r10
  20f113:	48 8b 84 24 e8 00 00 	mov    rax,QWORD PTR [rsp+0xe8]
  20f11a:	00 
  20f11b:	4c 8b 5c 24 28       	mov    r11,QWORD PTR [rsp+0x28]
  20f120:	4c 29 d8             	sub    rax,r11
  20f123:	48 89 84 24 50 02 00 	mov    QWORD PTR [rsp+0x250],rax
  20f12a:	00 
  20f12b:	31 f6                	xor    esi,esi
  20f12d:	45 31 ff             	xor    r15d,r15d
  20f130:	4d 89 d4             	mov    r12,r10
  20f133:	48 8b 84 24 d8 00 00 	mov    rax,QWORD PTR [rsp+0xd8]
  20f13a:	00 
  20f13b:	48 89 c7             	mov    rdi,rax
  20f13e:	4c 8b 74 24 78       	mov    r14,QWORD PTR [rsp+0x78]
  20f143:	e9 64 01 00 00       	jmp    20f2ac <benchmark.add+0x4a6c>
  20f148:	45 31 c9             	xor    r9d,r9d
  20f14b:	eb 09                	jmp    20f156 <benchmark.add+0x4916>
  20f14d:	49 29 f7             	sub    r15,rsi
  20f150:	4c 89 f7             	mov    rdi,r14
  20f153:	49 89 f9             	mov    r9,rdi
  20f156:	48 8b 44 24 50       	mov    rax,QWORD PTR [rsp+0x50]
  20f15b:	4c 29 f8             	sub    rax,r15
  20f15e:	48 89 fe             	mov    rsi,rdi
  20f161:	4c 29 ce             	sub    rsi,r9
    assert(dest.len >= source.len);
  20f164:	48 39 f0             	cmp    rax,rsi
  20f167:	0f 82 69 54 00 00    	jb     2145d6 <benchmark.add+0x9d96>
    for (source) |s, i|
  20f16d:	48 85 f6             	test   rsi,rsi
  20f170:	0f 84 2a 1c 00 00    	je     210da0 <benchmark.add+0x6560>
  20f176:	4c 8b 54 24 48       	mov    r10,QWORD PTR [rsp+0x48]
  20f17b:	48 83 c7 ff          	add    rdi,0xffffffffffffffff
  20f17f:	4c 29 cf             	sub    rdi,r9
  20f182:	89 f2                	mov    edx,esi
  20f184:	83 e2 07             	and    edx,0x7
  20f187:	48 83 ff 07          	cmp    rdi,0x7
  20f18b:	73 10                	jae    20f19d <benchmark.add+0x495d>
  20f18d:	31 ff                	xor    edi,edi
  20f18f:	48 85 d2             	test   rdx,rdx
  20f192:	0f 85 ac 00 00 00    	jne    20f244 <benchmark.add+0x4a04>
  20f198:	e9 03 1c 00 00       	jmp    210da0 <benchmark.add+0x6560>
  20f19d:	4c 89 fb             	mov    rbx,r15
  20f1a0:	48 c1 e3 04          	shl    rbx,0x4
  20f1a4:	4c 01 d3             	add    rbx,r10
  20f1a7:	48 29 d6             	sub    rsi,rdx
  20f1aa:	4c 89 c8             	mov    rax,r9
  20f1ad:	48 c1 e0 04          	shl    rax,0x4
  20f1b1:	48 8d 0c 04          	lea    rcx,[rsp+rax*1]
  20f1b5:	48 81 c1 a0 02 00 00 	add    rcx,0x2a0
  20f1bc:	b8 70 00 00 00       	mov    eax,0x70
  20f1c1:	31 ff                	xor    edi,edi
  20f1c3:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20f1ca:	84 00 00 00 00 00 
        dest[i] = s;
  20f1d0:	c5 f8 10 44 01 90    	vmovups xmm0,XMMWORD PTR [rcx+rax*1-0x70]
  20f1d6:	c5 f8 11 44 03 90    	vmovups XMMWORD PTR [rbx+rax*1-0x70],xmm0
  20f1dc:	c5 f8 10 44 01 a0    	vmovups xmm0,XMMWORD PTR [rcx+rax*1-0x60]
  20f1e2:	c5 f8 11 44 03 a0    	vmovups XMMWORD PTR [rbx+rax*1-0x60],xmm0
  20f1e8:	c5 f8 10 44 01 b0    	vmovups xmm0,XMMWORD PTR [rcx+rax*1-0x50]
  20f1ee:	c5 f8 11 44 03 b0    	vmovups XMMWORD PTR [rbx+rax*1-0x50],xmm0
  20f1f4:	c5 f8 10 44 01 c0    	vmovups xmm0,XMMWORD PTR [rcx+rax*1-0x40]
  20f1fa:	c5 f8 11 44 03 c0    	vmovups XMMWORD PTR [rbx+rax*1-0x40],xmm0
  20f200:	c5 f8 10 44 01 d0    	vmovups xmm0,XMMWORD PTR [rcx+rax*1-0x30]
  20f206:	c5 f8 11 44 03 d0    	vmovups XMMWORD PTR [rbx+rax*1-0x30],xmm0
  20f20c:	c5 f8 10 44 01 e0    	vmovups xmm0,XMMWORD PTR [rcx+rax*1-0x20]
  20f212:	c5 f8 11 44 03 e0    	vmovups XMMWORD PTR [rbx+rax*1-0x20],xmm0
  20f218:	c5 f8 10 44 01 f0    	vmovups xmm0,XMMWORD PTR [rcx+rax*1-0x10]
  20f21e:	c5 f8 11 44 03 f0    	vmovups XMMWORD PTR [rbx+rax*1-0x10],xmm0
  20f224:	c5 fa 6f 04 01       	vmovdqu xmm0,XMMWORD PTR [rcx+rax*1]
  20f229:	c5 fa 7f 04 03       	vmovdqu XMMWORD PTR [rbx+rax*1],xmm0
    for (source) |s, i|
  20f22e:	48 83 c7 08          	add    rdi,0x8
  20f232:	48 83 e8 80          	sub    rax,0xffffffffffffff80
  20f236:	48 39 fe             	cmp    rsi,rdi
  20f239:	75 95                	jne    20f1d0 <benchmark.add+0x4990>
  20f23b:	48 85 d2             	test   rdx,rdx
  20f23e:	0f 84 5c 1b 00 00    	je     210da0 <benchmark.add+0x6560>
  20f244:	49 01 ff             	add    r15,rdi
  20f247:	49 c1 e7 04          	shl    r15,0x4
  20f24b:	4d 01 fa             	add    r10,r15
  20f24e:	49 01 f9             	add    r9,rdi
  20f251:	49 c1 e1 04          	shl    r9,0x4
  20f255:	4a 8d 04 0c          	lea    rax,[rsp+r9*1]
  20f259:	48 05 a0 02 00 00    	add    rax,0x2a0
  20f25f:	48 f7 da             	neg    rdx
  20f262:	31 c9                	xor    ecx,ecx
  20f264:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20f26b:	00 00 00 00 00 
        dest[i] = s;
  20f270:	c5 fa 6f 04 08       	vmovdqu xmm0,XMMWORD PTR [rax+rcx*1]
  20f275:	c4 c1 7a 7f 04 0a    	vmovdqu XMMWORD PTR [r10+rcx*1],xmm0
    for (source) |s, i|
  20f27b:	48 83 c1 10          	add    rcx,0x10
  20f27f:	48 83 c2 01          	add    rdx,0x1
  20f283:	75 eb                	jne    20f270 <benchmark.add+0x4a30>
  20f285:	e9 16 1b 00 00       	jmp    210da0 <benchmark.add+0x6560>
                                lastB = Range.init(blockA.start, blockA.start + block_size);
  20f28a:	4b 8d 0c 1f          	lea    rcx,[r15+r11*1]
                                blockA.end += block_size;
  20f28e:	4d 01 da             	add    r10,r11
                                blockB.start += block_size;
  20f291:	4d 01 dc             	add    r12,r11
                                if (blockB.end > B.end - block_size) {
  20f294:	48 3b 9c 24 50 02 00 	cmp    rbx,QWORD PTR [rsp+0x250]
  20f29b:	00 
                                    blockB.end += block_size;
  20f29c:	4a 8d 1c 1b          	lea    rbx,[rbx+r11*1]
                                if (blockB.end > B.end - block_size) {
  20f2a0:	48 0f 47 9c 24 e8 00 	cmova  rbx,QWORD PTR [rsp+0xe8]
  20f2a7:	00 00 
  20f2a9:	48 89 ce             	mov    rsi,rcx
  20f2ac:	4c 89 a4 24 00 01 00 	mov    QWORD PTR [rsp+0x100],r12
  20f2b3:	00 
  20f2b4:	eb 1a                	jmp    20f2d0 <benchmark.add+0x4a90>
  20f2b6:	48 8b 44 24 38       	mov    rax,QWORD PTR [rsp+0x38]
                                blockA.end += blockB.length();
  20f2bb:	4c 01 d0             	add    rax,r10
                                lastB = Range.init(blockA.start, blockA.start + blockB.length());
  20f2be:	4b 8d 0c 3a          	lea    rcx,[r10+r15*1]
  20f2c2:	49 89 c2             	mov    r10,rax
  20f2c5:	48 89 ce             	mov    rsi,rcx
  20f2c8:	4c 89 e3             	mov    rbx,r12
  20f2cb:	48 8b 7c 24 18       	mov    rdi,QWORD PTR [rsp+0x18]
  20f2d0:	4d 89 fd             	mov    r13,r15
  20f2d3:	4c 89 54 24 38       	mov    QWORD PTR [rsp+0x38],r10
  20f2d8:	48 89 5c 24 40       	mov    QWORD PTR [rsp+0x40],rbx
  20f2dd:	eb 21                	jmp    20f300 <benchmark.add+0x4ac0>
  20f2df:	45 31 d2             	xor    r10d,r10d
  20f2e2:	31 ff                	xor    edi,edi
    while (index < block_size) : (index += 1) {
  20f2e4:	4d 29 d1             	sub    r9,r10
  20f2e7:	4c 8b 74 24 78       	mov    r14,QWORD PTR [rsp+0x78]
  20f2ec:	0f 85 b7 06 00 00    	jne    20f9a9 <benchmark.add+0x5169>
  20f2f2:	e9 49 08 00 00       	jmp    20fb40 <benchmark.add+0x5300>
  20f2f7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  20f2fe:	00 00 
  20f300:	49 89 cf             	mov    r15,rcx
                            if ((lastB.length() > 0 and !lessThan(items[lastB.end - 1], items[indexA])) or blockB.length() == 0) {
  20f303:	4c 39 ee             	cmp    rsi,r13
  20f306:	48 89 7c 24 18       	mov    QWORD PTR [rsp+0x18],rdi
  20f30b:	75 13                	jne    20f320 <benchmark.add+0x4ae0>
  20f30d:	4c 39 e3             	cmp    rbx,r12
  20f310:	0f 85 92 11 00 00    	jne    2104a8 <benchmark.add+0x5c68>
                                const B_split = binaryFirst(T, items, items[indexA], lastB, lessThan);
  20f316:	48 8b 54 24 48       	mov    rdx,QWORD PTR [rsp+0x48]
  20f31b:	eb 2a                	jmp    20f347 <benchmark.add+0x4b07>
  20f31d:	0f 1f 00             	nop    DWORD PTR [rax]
                            if ((lastB.length() > 0 and !lessThan(items[lastB.end - 1], items[indexA])) or blockB.length() == 0) {
  20f320:	48 8b 54 24 48       	mov    rdx,QWORD PTR [rsp+0x48]
  20f325:	4c 39 e3             	cmp    rbx,r12
  20f328:	74 1d                	je     20f347 <benchmark.add+0x4b07>
  20f32a:	48 89 f0             	mov    rax,rsi
  20f32d:	48 c1 e0 04          	shl    rax,0x4
  20f331:	48 89 f9             	mov    rcx,rdi
  20f334:	48 c1 e1 04          	shl    rcx,0x4
  20f338:	48 8b 0c 0a          	mov    rcx,QWORD PTR [rdx+rcx*1]
  20f33c:	48 39 4c 02 f0       	cmp    QWORD PTR [rdx+rax*1-0x10],rcx
  20f341:	0f 82 61 11 00 00    	jb     2104a8 <benchmark.add+0x5c68>
                                const B_split = binaryFirst(T, items, items[indexA], lastB, lessThan);
  20f347:	49 89 f9             	mov    r9,rdi
  20f34a:	49 c1 e1 04          	shl    r9,0x4
  20f34e:	49 89 f4             	mov    r12,rsi
  20f351:	48 89 74 24 60       	mov    QWORD PTR [rsp+0x60],rsi
    if (range.start >= range.end) return range.end;
  20f356:	49 39 f5             	cmp    r13,rsi
  20f359:	0f 83 8c 00 00 00    	jae    20f3eb <benchmark.add+0x4bab>
  20f35f:	4e 8d 04 0a          	lea    r8,[rdx+r9*1]
    var end = range.end - 1;
  20f363:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
  20f368:	4c 8d 50 ff          	lea    r10,[rax-0x1]
    while (start < end) {
  20f36c:	4d 39 ea             	cmp    r10,r13
  20f36f:	76 4b                	jbe    20f3bc <benchmark.add+0x4b7c>
  20f371:	49 8b 18             	mov    rbx,QWORD PTR [r8]
  20f374:	4c 89 d1             	mov    rcx,r10
  20f377:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  20f37e:	00 00 
        const mid = start + (end - start) / 2;
  20f380:	48 89 ce             	mov    rsi,rcx
  20f383:	4c 29 ee             	sub    rsi,r13
  20f386:	48 d1 ee             	shr    rsi,1
  20f389:	4a 8d 3c 2e          	lea    rdi,[rsi+r13*1]
  20f38d:	48 89 f8             	mov    rax,rdi
  20f390:	48 c1 e0 04          	shl    rax,0x4
  20f394:	48 39 1c 02          	cmp    QWORD PTR [rdx+rax*1],rbx
        if (lessThan(items[mid], value)) {
  20f398:	72 16                	jb     20f3b0 <benchmark.add+0x4b70>
  20f39a:	48 89 f9             	mov    rcx,rdi
    while (start < end) {
  20f39d:	4c 39 e9             	cmp    rcx,r13
  20f3a0:	77 de                	ja     20f380 <benchmark.add+0x4b40>
  20f3a2:	eb 18                	jmp    20f3bc <benchmark.add+0x4b7c>
  20f3a4:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20f3ab:	00 00 00 00 00 
  20f3b0:	49 01 f5             	add    r13,rsi
  20f3b3:	49 83 c5 01          	add    r13,0x1
  20f3b7:	4c 39 e9             	cmp    rcx,r13
  20f3ba:	77 c4                	ja     20f380 <benchmark.add+0x4b40>
    if (start == range.end - 1 and lessThan(items[start], value)) {
  20f3bc:	4d 39 d5             	cmp    r13,r10
  20f3bf:	75 1f                	jne    20f3e0 <benchmark.add+0x4ba0>
  20f3c1:	49 c1 e2 04          	shl    r10,0x4
  20f3c5:	4a 8b 04 12          	mov    rax,QWORD PTR [rdx+r10*1]
  20f3c9:	45 31 e4             	xor    r12d,r12d
  20f3cc:	49 3b 00             	cmp    rax,QWORD PTR [r8]
  20f3cf:	41 0f 92 c4          	setb   r12b
  20f3d3:	eb 0e                	jmp    20f3e3 <benchmark.add+0x4ba3>
  20f3d5:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20f3dc:	00 00 00 00 
  20f3e0:	45 31 e4             	xor    r12d,r12d
  20f3e3:	4c 8b 54 24 38       	mov    r10,QWORD PTR [rsp+0x38]
  20f3e8:	4d 01 ec             	add    r12,r13
  20f3eb:	4f 8d 04 1f          	lea    r8,[r15+r11*1]
  20f3ef:	4c 89 f8             	mov    rax,r15
                                while (findA < blockA.end) : (findA += block_size) {
  20f3f2:	4d 39 d0             	cmp    r8,r10
  20f3f5:	73 32                	jae    20f429 <benchmark.add+0x4be9>
  20f3f7:	4c 89 c6             	mov    rsi,r8
  20f3fa:	4c 89 fb             	mov    rbx,r15
  20f3fd:	0f 1f 00             	nop    DWORD PTR [rax]
  20f400:	48 89 f0             	mov    rax,rsi
  20f403:	48 c1 e0 04          	shl    rax,0x4
  20f407:	48 8b 0c 02          	mov    rcx,QWORD PTR [rdx+rax*1]
  20f40b:	48 89 df             	mov    rdi,rbx
  20f40e:	48 c1 e7 04          	shl    rdi,0x4
                                    if (lessThan(items[findA], items[minA])) {
  20f412:	48 89 f0             	mov    rax,rsi
  20f415:	48 3b 0c 3a          	cmp    rcx,QWORD PTR [rdx+rdi*1]
  20f419:	72 03                	jb     20f41e <benchmark.add+0x4bde>
  20f41b:	48 89 d8             	mov    rax,rbx
  20f41e:	4c 01 de             	add    rsi,r11
  20f421:	48 89 c3             	mov    rbx,rax
                                while (findA < blockA.end) : (findA += block_size) {
  20f424:	4c 39 d6             	cmp    rsi,r10
  20f427:	72 d7                	jb     20f400 <benchmark.add+0x4bc0>
  20f429:	49 83 fe 03          	cmp    r14,0x3
    while (index < block_size) : (index += 1) {
  20f42d:	73 21                	jae    20f450 <benchmark.add+0x4c10>
  20f42f:	31 f6                	xor    esi,esi
  20f431:	48 83 7c 24 10 00    	cmp    QWORD PTR [rsp+0x10],0x0
  20f437:	0f 85 11 01 00 00    	jne    20f54e <benchmark.add+0x4d0e>
  20f43d:	e9 57 01 00 00       	jmp    20f599 <benchmark.add+0x4d59>
  20f442:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20f449:	1f 84 00 00 00 00 00 
  20f450:	48 89 c7             	mov    rdi,rax
  20f453:	48 c1 e7 04          	shl    rdi,0x4
  20f457:	48 83 c7 20          	add    rdi,0x20
  20f45b:	31 f6                	xor    esi,esi
  20f45d:	48 8b 9c 24 28 01 00 	mov    rbx,QWORD PTR [rsp+0x128]
  20f464:	00 
  20f465:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20f46c:	00 00 00 00 
        mem.swap(T, &items[start1 + index], &items[start2 + index]);
  20f470:	4a 8d 0c 3e          	lea    rcx,[rsi+r15*1]
  20f474:	48 c1 e1 04          	shl    rcx,0x4
    const tmp = a.*;
  20f478:	c5 f8 10 04 0a       	vmovups xmm0,XMMWORD PTR [rdx+rcx*1]
  20f47d:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  20f482:	c5 f8 10 44 3a e0    	vmovups xmm0,XMMWORD PTR [rdx+rdi*1-0x20]
  20f488:	c5 f8 11 04 0a       	vmovups XMMWORD PTR [rdx+rcx*1],xmm0
    b.* = tmp;
  20f48d:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  20f492:	c5 f8 11 44 3a e0    	vmovups XMMWORD PTR [rdx+rdi*1-0x20],xmm0
    while (index < block_size) : (index += 1) {
  20f498:	48 89 f1             	mov    rcx,rsi
  20f49b:	48 83 c9 01          	or     rcx,0x1
  20f49f:	48 8b 54 24 48       	mov    rdx,QWORD PTR [rsp+0x48]
        mem.swap(T, &items[start1 + index], &items[start2 + index]);
  20f4a4:	4c 01 f9             	add    rcx,r15
  20f4a7:	48 c1 e1 04          	shl    rcx,0x4
    const tmp = a.*;
  20f4ab:	c5 f8 10 04 0a       	vmovups xmm0,XMMWORD PTR [rdx+rcx*1]
  20f4b0:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  20f4b5:	c5 f8 10 44 3a f0    	vmovups xmm0,XMMWORD PTR [rdx+rdi*1-0x10]
  20f4bb:	c5 f8 11 04 0a       	vmovups XMMWORD PTR [rdx+rcx*1],xmm0
    b.* = tmp;
  20f4c0:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  20f4c5:	c5 f8 11 44 3a f0    	vmovups XMMWORD PTR [rdx+rdi*1-0x10],xmm0
    while (index < block_size) : (index += 1) {
  20f4cb:	48 89 f1             	mov    rcx,rsi
  20f4ce:	48 83 c9 02          	or     rcx,0x2
  20f4d2:	48 8b 54 24 48       	mov    rdx,QWORD PTR [rsp+0x48]
        mem.swap(T, &items[start1 + index], &items[start2 + index]);
  20f4d7:	4c 01 f9             	add    rcx,r15
  20f4da:	48 c1 e1 04          	shl    rcx,0x4
    const tmp = a.*;
  20f4de:	c5 f8 10 04 0a       	vmovups xmm0,XMMWORD PTR [rdx+rcx*1]
  20f4e3:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  20f4e8:	c5 f8 10 04 3a       	vmovups xmm0,XMMWORD PTR [rdx+rdi*1]
  20f4ed:	c5 f8 11 04 0a       	vmovups XMMWORD PTR [rdx+rcx*1],xmm0
    b.* = tmp;
  20f4f2:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  20f4f7:	c5 f8 11 04 3a       	vmovups XMMWORD PTR [rdx+rdi*1],xmm0
    while (index < block_size) : (index += 1) {
  20f4fc:	48 89 f1             	mov    rcx,rsi
  20f4ff:	48 83 c9 03          	or     rcx,0x3
  20f503:	48 8b 54 24 48       	mov    rdx,QWORD PTR [rsp+0x48]
        mem.swap(T, &items[start1 + index], &items[start2 + index]);
  20f508:	4c 01 f9             	add    rcx,r15
  20f50b:	48 c1 e1 04          	shl    rcx,0x4
    const tmp = a.*;
  20f50f:	c5 f8 10 04 0a       	vmovups xmm0,XMMWORD PTR [rdx+rcx*1]
  20f514:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  20f519:	c5 f8 10 44 3a 10    	vmovups xmm0,XMMWORD PTR [rdx+rdi*1+0x10]
  20f51f:	c5 f8 11 04 0a       	vmovups XMMWORD PTR [rdx+rcx*1],xmm0
    b.* = tmp;
  20f524:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  20f529:	c5 fa 7f 44 3a 10    	vmovdqu XMMWORD PTR [rdx+rdi*1+0x10],xmm0
    while (index < block_size) : (index += 1) {
  20f52f:	48 83 c6 04          	add    rsi,0x4
  20f533:	48 8b 54 24 48       	mov    rdx,QWORD PTR [rsp+0x48]
  20f538:	48 83 c7 40          	add    rdi,0x40
  20f53c:	48 83 c3 fc          	add    rbx,0xfffffffffffffffc
  20f540:	0f 85 2a ff ff ff    	jne    20f470 <benchmark.add+0x4c30>
  20f546:	48 83 7c 24 10 00    	cmp    QWORD PTR [rsp+0x10],0x0
  20f54c:	74 4b                	je     20f599 <benchmark.add+0x4d59>
  20f54e:	48 01 f0             	add    rax,rsi
  20f551:	48 c1 e0 04          	shl    rax,0x4
  20f555:	48 8b 7c 24 10       	mov    rdi,QWORD PTR [rsp+0x10]
  20f55a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
        mem.swap(T, &items[start1 + index], &items[start2 + index]);
  20f560:	4a 8d 0c 3e          	lea    rcx,[rsi+r15*1]
  20f564:	48 c1 e1 04          	shl    rcx,0x4
    const tmp = a.*;
  20f568:	c5 f8 10 04 0a       	vmovups xmm0,XMMWORD PTR [rdx+rcx*1]
  20f56d:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  20f572:	c5 f8 10 04 02       	vmovups xmm0,XMMWORD PTR [rdx+rax*1]
  20f577:	c5 f8 11 04 0a       	vmovups XMMWORD PTR [rdx+rcx*1],xmm0
    b.* = tmp;
  20f57c:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  20f581:	c5 fa 7f 04 02       	vmovdqu XMMWORD PTR [rdx+rax*1],xmm0
    while (index < block_size) : (index += 1) {
  20f586:	48 83 c6 01          	add    rsi,0x1
  20f58a:	48 8b 54 24 48       	mov    rdx,QWORD PTR [rsp+0x48]
  20f58f:	48 83 c0 10          	add    rax,0x10
  20f593:	48 83 c7 ff          	add    rdi,0xffffffffffffffff
  20f597:	75 c7                	jne    20f560 <benchmark.add+0x4d20>
                                mem.swap(T, &items[blockA.start], &items[indexA]);
  20f599:	4d 89 fd             	mov    r13,r15
  20f59c:	49 c1 e5 04          	shl    r13,0x4
    const tmp = a.*;
  20f5a0:	c4 a1 78 10 04 2a    	vmovups xmm0,XMMWORD PTR [rdx+r13*1]
  20f5a6:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  20f5ab:	c4 a1 78 10 04 0a    	vmovups xmm0,XMMWORD PTR [rdx+r9*1]
  20f5b1:	c4 a1 78 11 04 2a    	vmovups XMMWORD PTR [rdx+r13*1],xmm0
    b.* = tmp;
  20f5b7:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  20f5bc:	c4 a1 7a 7f 04 0a    	vmovdqu XMMWORD PTR [rdx+r9*1],xmm0
  20f5c2:	48 8b b4 24 b0 01 00 	mov    rsi,QWORD PTR [rsp+0x1b0]
  20f5c9:	00 
  20f5ca:	48 8b 9c 24 b8 01 00 	mov    rbx,QWORD PTR [rsp+0x1b8]
  20f5d1:	00 
        return self.end - self.start;
  20f5d2:	49 89 d9             	mov    r9,rbx
  20f5d5:	49 29 f1             	sub    r9,rsi
                                if (lastA.length() <= cache.len) {
  20f5d8:	49 81 f9 00 02 00 00 	cmp    r9,0x200
  20f5df:	4c 89 44 24 20       	mov    QWORD PTR [rsp+0x20],r8
  20f5e4:	0f 87 06 01 00 00    	ja     20f6f0 <benchmark.add+0x4eb0>
  20f5ea:	49 89 f0             	mov    r8,rsi
    if (B.length() > 0 and A.length() > 0) {
  20f5ed:	49 39 dc             	cmp    r12,rbx
  20f5f0:	0f 84 64 02 00 00    	je     20f85a <benchmark.add+0x501a>
  20f5f6:	41 ba 00 00 00 00    	mov    r10d,0x0
  20f5fc:	4d 85 c9             	test   r9,r9
  20f5ff:	0f 84 58 02 00 00    	je     20f85d <benchmark.add+0x501d>
            if (!lessThan(items[B_index], cache[A_index])) {
  20f605:	48 89 f1             	mov    rcx,rsi
  20f608:	48 29 d9             	sub    rcx,rbx
  20f60b:	48 89 74 24 30       	mov    QWORD PTR [rsp+0x30],rsi
  20f610:	49 89 f0             	mov    r8,rsi
  20f613:	48 89 9c 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rbx
  20f61a:	00 
  20f61b:	49 89 da             	mov    r10,rbx
  20f61e:	31 f6                	xor    esi,esi
  20f620:	48 89 8c 24 68 01 00 	mov    QWORD PTR [rsp+0x168],rcx
  20f627:	00 
  20f628:	4c 89 c7             	mov    rdi,r8
  20f62b:	48 c1 e7 04          	shl    rdi,0x4
  20f62f:	48 8d 04 31          	lea    rax,[rcx+rsi*1]
  20f633:	48 89 b4 24 70 01 00 	mov    QWORD PTR [rsp+0x170],rsi
  20f63a:	00 
  20f63b:	48 89 f1             	mov    rcx,rsi
  20f63e:	48 c1 e1 04          	shl    rcx,0x4
  20f642:	48 8d 34 0c          	lea    rsi,[rsp+rcx*1]
  20f646:	48 81 c6 a0 02 00 00 	add    rsi,0x2a0
  20f64d:	31 d2                	xor    edx,edx
  20f64f:	90                   	nop
  20f650:	48 8b 5c 24 48       	mov    rbx,QWORD PTR [rsp+0x48]
  20f655:	4c 89 d1             	mov    rcx,r10
  20f658:	48 c1 e1 04          	shl    rcx,0x4
  20f65c:	4c 8b 34 0b          	mov    r14,QWORD PTR [rbx+rcx*1]
  20f660:	4c 3b 36             	cmp    r14,QWORD PTR [rsi]
  20f663:	72 2b                	jb     20f690 <benchmark.add+0x4e50>
                items[insert_index] = cache[A_index];
  20f665:	c5 fa 6f 06          	vmovdqu xmm0,XMMWORD PTR [rsi]
  20f669:	c5 fa 7f 04 3b       	vmovdqu XMMWORD PTR [rbx+rdi*1],xmm0
                if (A_index == A_last) break;
  20f66e:	48 83 c2 ff          	add    rdx,0xffffffffffffffff
  20f672:	48 83 c7 10          	add    rdi,0x10
  20f676:	48 83 c6 10          	add    rsi,0x10
  20f67a:	48 39 d0             	cmp    rax,rdx
  20f67d:	75 d1                	jne    20f650 <benchmark.add+0x4e10>
  20f67f:	e9 bc 01 00 00       	jmp    20f840 <benchmark.add+0x5000>
  20f684:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20f68b:	00 00 00 00 00 
  20f690:	48 01 d9             	add    rcx,rbx
                items[insert_index] = items[B_index];
  20f693:	c5 fa 6f 01          	vmovdqu xmm0,XMMWORD PTR [rcx]
  20f697:	c5 fa 7f 04 3b       	vmovdqu XMMWORD PTR [rbx+rdi*1],xmm0
                B_index += 1;
  20f69c:	49 83 c2 01          	add    r10,0x1
                if (B_index == B_last) break;
  20f6a0:	4c 89 c0             	mov    rax,r8
  20f6a3:	48 83 c0 01          	add    rax,0x1
  20f6a7:	49 89 c0             	mov    r8,rax
  20f6aa:	49 29 d0             	sub    r8,rdx
  20f6ad:	48 8b bc 24 70 01 00 	mov    rdi,QWORD PTR [rsp+0x170]
  20f6b4:	00 
  20f6b5:	48 89 fe             	mov    rsi,rdi
  20f6b8:	48 29 d6             	sub    rsi,rdx
  20f6bb:	4d 39 e2             	cmp    r10,r12
  20f6be:	48 8b 8c 24 68 01 00 	mov    rcx,QWORD PTR [rsp+0x168]
  20f6c5:	00 
  20f6c6:	0f 85 5c ff ff ff    	jne    20f628 <benchmark.add+0x4de8>
    mem.copy(T, items[insert_index..], cache[A_index..A_last]);
  20f6cc:	48 29 d0             	sub    rax,rdx
  20f6cf:	48 29 d7             	sub    rdi,rdx
  20f6d2:	49 89 c0             	mov    r8,rax
  20f6d5:	4c 8b 74 24 78       	mov    r14,QWORD PTR [rsp+0x78]
  20f6da:	48 8b 74 24 30       	mov    rsi,QWORD PTR [rsp+0x30]
  20f6df:	48 8b 9c 24 f0 00 00 	mov    rbx,QWORD PTR [rsp+0xf0]
  20f6e6:	00 
  20f6e7:	49 89 fa             	mov    r10,rdi
  20f6ea:	e9 6e 01 00 00       	jmp    20f85d <benchmark.add+0x501d>
  20f6ef:	90                   	nop
  20f6f0:	48 8b 44 24 58       	mov    rax,QWORD PTR [rsp+0x58]
  20f6f5:	48 39 84 24 d0 00 00 	cmp    QWORD PTR [rsp+0xd0],rax
  20f6fc:	00 
                                } else if (buffer2.length() > 0) {
  20f6fd:	75 41                	jne    20f740 <benchmark.add+0x4f00>
        return Range{
  20f6ff:	48 89 9c 24 90 02 00 	mov    QWORD PTR [rsp+0x290],rbx
  20f706:	00 
  20f707:	4c 89 a4 24 98 02 00 	mov    QWORD PTR [rsp+0x298],r12
  20f70e:	00 
                                    mergeInPlace(T, items, lastA, Range.init(lastA.end, B_split), lessThan);
  20f70f:	48 8d 7c 24 48       	lea    rdi,[rsp+0x48]
  20f714:	48 8d b4 24 b0 01 00 	lea    rsi,[rsp+0x1b0]
  20f71b:	00 
  20f71c:	48 8d 94 24 90 02 00 	lea    rdx,[rsp+0x290]
  20f723:	00 
  20f724:	c5 f8 77             	vzeroupper 
  20f727:	e8 84 6c 00 00       	call   2163b0 <mergeInPlace>
  20f72c:	4c 8b 5c 24 28       	mov    r11,QWORD PTR [rsp+0x28]
  20f731:	e9 0a 04 00 00       	jmp    20fb40 <benchmark.add+0x5300>
  20f736:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  20f73d:	00 00 00 
    if (B.length() > 0 and A.length() > 0) {
  20f740:	4d 89 e6             	mov    r14,r12
  20f743:	49 29 de             	sub    r14,rbx
  20f746:	48 89 74 24 30       	mov    QWORD PTR [rsp+0x30],rsi
  20f74b:	0f 84 8e fb ff ff    	je     20f2df <benchmark.add+0x4a9f>
  20f751:	41 ba 00 00 00 00    	mov    r10d,0x0
  20f757:	bf 00 00 00 00       	mov    edi,0x0
  20f75c:	48 39 f3             	cmp    rbx,rsi
  20f75f:	0f 84 36 02 00 00    	je     20f99b <benchmark.add+0x515b>
  20f765:	45 31 d2             	xor    r10d,r10d
  20f768:	31 c9                	xor    ecx,ecx
  20f76a:	31 c0                	xor    eax,eax
  20f76c:	48 89 9c 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rbx
  20f773:	00 
  20f774:	48 8b 54 24 58       	mov    rdx,QWORD PTR [rsp+0x58]
  20f779:	4d 8d 04 12          	lea    r8,[r10+rdx*1]
            if (!lessThan(items[B.start + B_count], items[buffer.start + A_count])) {
  20f77d:	48 8d 1c 0b          	lea    rbx,[rbx+rcx*1]
  20f781:	48 c1 e3 04          	shl    rbx,0x4
  20f785:	48 8d 14 06          	lea    rdx,[rsi+rax*1]
  20f789:	48 c1 e2 04          	shl    rdx,0x4
  20f78d:	48 89 c7             	mov    rdi,rax
  20f790:	48 8b 44 24 48       	mov    rax,QWORD PTR [rsp+0x48]
  20f795:	4c 89 c6             	mov    rsi,r8
  20f798:	48 c1 e6 04          	shl    rsi,0x4
  20f79c:	4c 8b 1c 18          	mov    r11,QWORD PTR [rax+rbx*1]
  20f7a0:	4c 3b 1c 30          	cmp    r11,QWORD PTR [rax+rsi*1]
  20f7a4:	73 3a                	jae    20f7e0 <benchmark.add+0x4fa0>
    const tmp = a.*;
  20f7a6:	c5 f8 10 04 10       	vmovups xmm0,XMMWORD PTR [rax+rdx*1]
  20f7ab:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  20f7b0:	c5 f8 10 04 18       	vmovups xmm0,XMMWORD PTR [rax+rbx*1]
  20f7b5:	c5 f8 11 04 10       	vmovups XMMWORD PTR [rax+rdx*1],xmm0
    b.* = tmp;
  20f7ba:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  20f7bf:	c5 fa 7f 04 18       	vmovdqu XMMWORD PTR [rax+rbx*1],xmm0
                B_count += 1;
  20f7c4:	48 83 c1 01          	add    rcx,0x1
                insert += 1;
  20f7c8:	48 83 c7 01          	add    rdi,0x1
                if (B_count >= B.length()) break;
  20f7cc:	48 83 c3 10          	add    rbx,0x10
  20f7d0:	48 83 c2 10          	add    rdx,0x10
  20f7d4:	4c 39 f1             	cmp    rcx,r14
  20f7d7:	72 b7                	jb     20f790 <benchmark.add+0x4f50>
  20f7d9:	e9 ab 01 00 00       	jmp    20f989 <benchmark.add+0x5149>
  20f7de:	66 90                	xchg   ax,ax
    const tmp = a.*;
  20f7e0:	c5 f8 10 04 10       	vmovups xmm0,XMMWORD PTR [rax+rdx*1]
  20f7e5:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
  20f7ea:	48 01 c6             	add    rsi,rax
    a.* = b.*;
  20f7ed:	c5 f8 10 06          	vmovups xmm0,XMMWORD PTR [rsi]
  20f7f1:	c5 f8 11 04 10       	vmovups XMMWORD PTR [rax+rdx*1],xmm0
    b.* = tmp;
  20f7f6:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  20f7fb:	c5 fa 7f 06          	vmovdqu XMMWORD PTR [rsi],xmm0
                A_count += 1;
  20f7ff:	49 83 c2 01          	add    r10,0x1
                if (A_count >= A.length()) break;
  20f803:	48 8d 47 01          	lea    rax,[rdi+0x1]
  20f807:	4d 39 ca             	cmp    r10,r9
  20f80a:	48 8b 74 24 30       	mov    rsi,QWORD PTR [rsp+0x30]
  20f80f:	48 8b 9c 24 f0 00 00 	mov    rbx,QWORD PTR [rsp+0xf0]
  20f816:	00 
  20f817:	0f 82 57 ff ff ff    	jb     20f774 <benchmark.add+0x4f34>
    blockSwap(T, items, buffer.start + A_count, A.start + insert, A.length() - A_count);
  20f81d:	48 83 c7 01          	add    rdi,0x1
  20f821:	4c 8b 5c 24 28       	mov    r11,QWORD PTR [rsp+0x28]
    while (index < block_size) : (index += 1) {
  20f826:	4d 29 d1             	sub    r9,r10
  20f829:	4c 8b 74 24 78       	mov    r14,QWORD PTR [rsp+0x78]
  20f82e:	0f 85 75 01 00 00    	jne    20f9a9 <benchmark.add+0x5169>
  20f834:	e9 07 03 00 00       	jmp    20fb40 <benchmark.add+0x5300>
  20f839:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
    mem.copy(T, items[insert_index..], cache[A_index..A_last]);
  20f840:	49 29 d0             	sub    r8,rdx
  20f843:	4d 89 ca             	mov    r10,r9
  20f846:	4c 8b 74 24 78       	mov    r14,QWORD PTR [rsp+0x78]
  20f84b:	48 8b 74 24 30       	mov    rsi,QWORD PTR [rsp+0x30]
  20f850:	48 8b 9c 24 f0 00 00 	mov    rbx,QWORD PTR [rsp+0xf0]
  20f857:	00 
  20f858:	eb 03                	jmp    20f85d <benchmark.add+0x501d>
  20f85a:	45 31 d2             	xor    r10d,r10d
  20f85d:	48 8b 44 24 50       	mov    rax,QWORD PTR [rsp+0x50]
  20f862:	4c 29 c0             	sub    rax,r8
  20f865:	4d 29 d1             	sub    r9,r10
    assert(dest.len >= source.len);
  20f868:	4c 39 c8             	cmp    rax,r9
  20f86b:	0f 82 65 4d 00 00    	jb     2145d6 <benchmark.add+0x9d96>
    for (source) |s, i|
  20f871:	4d 85 c9             	test   r9,r9
  20f874:	0f 84 c6 02 00 00    	je     20fb40 <benchmark.add+0x5300>
  20f87a:	48 8b 44 24 48       	mov    rax,QWORD PTR [rsp+0x48]
  20f87f:	48 83 c3 ff          	add    rbx,0xffffffffffffffff
  20f883:	4c 29 d3             	sub    rbx,r10
  20f886:	48 29 f3             	sub    rbx,rsi
  20f889:	44 89 c9             	mov    ecx,r9d
  20f88c:	83 e1 07             	and    ecx,0x7
  20f88f:	48 83 fb 07          	cmp    rbx,0x7
  20f893:	73 10                	jae    20f8a5 <benchmark.add+0x5065>
  20f895:	31 d2                	xor    edx,edx
  20f897:	48 85 c9             	test   rcx,rcx
  20f89a:	0f 85 a4 00 00 00    	jne    20f944 <benchmark.add+0x5104>
  20f8a0:	e9 9b 02 00 00       	jmp    20fb40 <benchmark.add+0x5300>
  20f8a5:	4c 89 c7             	mov    rdi,r8
  20f8a8:	48 c1 e7 04          	shl    rdi,0x4
  20f8ac:	48 01 c7             	add    rdi,rax
  20f8af:	49 29 c9             	sub    r9,rcx
  20f8b2:	4c 89 d2             	mov    rdx,r10
  20f8b5:	48 c1 e2 04          	shl    rdx,0x4
  20f8b9:	48 8d 34 14          	lea    rsi,[rsp+rdx*1]
  20f8bd:	48 81 c6 a0 02 00 00 	add    rsi,0x2a0
  20f8c4:	bb 70 00 00 00       	mov    ebx,0x70
  20f8c9:	31 d2                	xor    edx,edx
  20f8cb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
        dest[i] = s;
  20f8d0:	c5 f8 10 44 1e 90    	vmovups xmm0,XMMWORD PTR [rsi+rbx*1-0x70]
  20f8d6:	c5 f8 11 44 1f 90    	vmovups XMMWORD PTR [rdi+rbx*1-0x70],xmm0
  20f8dc:	c5 f8 10 44 1e a0    	vmovups xmm0,XMMWORD PTR [rsi+rbx*1-0x60]
  20f8e2:	c5 f8 11 44 1f a0    	vmovups XMMWORD PTR [rdi+rbx*1-0x60],xmm0
  20f8e8:	c5 f8 10 44 1e b0    	vmovups xmm0,XMMWORD PTR [rsi+rbx*1-0x50]
  20f8ee:	c5 f8 11 44 1f b0    	vmovups XMMWORD PTR [rdi+rbx*1-0x50],xmm0
  20f8f4:	c5 f8 10 44 1e c0    	vmovups xmm0,XMMWORD PTR [rsi+rbx*1-0x40]
  20f8fa:	c5 f8 11 44 1f c0    	vmovups XMMWORD PTR [rdi+rbx*1-0x40],xmm0
  20f900:	c5 f8 10 44 1e d0    	vmovups xmm0,XMMWORD PTR [rsi+rbx*1-0x30]
  20f906:	c5 f8 11 44 1f d0    	vmovups XMMWORD PTR [rdi+rbx*1-0x30],xmm0
  20f90c:	c5 f8 10 44 1e e0    	vmovups xmm0,XMMWORD PTR [rsi+rbx*1-0x20]
  20f912:	c5 f8 11 44 1f e0    	vmovups XMMWORD PTR [rdi+rbx*1-0x20],xmm0
  20f918:	c5 f8 10 44 1e f0    	vmovups xmm0,XMMWORD PTR [rsi+rbx*1-0x10]
  20f91e:	c5 f8 11 44 1f f0    	vmovups XMMWORD PTR [rdi+rbx*1-0x10],xmm0
  20f924:	c5 fa 6f 04 1e       	vmovdqu xmm0,XMMWORD PTR [rsi+rbx*1]
  20f929:	c5 fa 7f 04 1f       	vmovdqu XMMWORD PTR [rdi+rbx*1],xmm0
    for (source) |s, i|
  20f92e:	48 83 c2 08          	add    rdx,0x8
  20f932:	48 83 eb 80          	sub    rbx,0xffffffffffffff80
  20f936:	49 39 d1             	cmp    r9,rdx
  20f939:	75 95                	jne    20f8d0 <benchmark.add+0x5090>
  20f93b:	48 85 c9             	test   rcx,rcx
  20f93e:	0f 84 fc 01 00 00    	je     20fb40 <benchmark.add+0x5300>
  20f944:	49 01 d0             	add    r8,rdx
  20f947:	49 c1 e0 04          	shl    r8,0x4
  20f94b:	4c 01 c0             	add    rax,r8
  20f94e:	49 01 d2             	add    r10,rdx
  20f951:	49 c1 e2 04          	shl    r10,0x4
  20f955:	4a 8d 14 14          	lea    rdx,[rsp+r10*1]
  20f959:	48 81 c2 a0 02 00 00 	add    rdx,0x2a0
  20f960:	48 f7 d9             	neg    rcx
  20f963:	31 f6                	xor    esi,esi
  20f965:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20f96c:	00 00 00 00 
        dest[i] = s;
  20f970:	c5 fa 6f 04 32       	vmovdqu xmm0,XMMWORD PTR [rdx+rsi*1]
  20f975:	c5 fa 7f 04 30       	vmovdqu XMMWORD PTR [rax+rsi*1],xmm0
    for (source) |s, i|
  20f97a:	48 83 c6 10          	add    rsi,0x10
  20f97e:	48 83 c1 01          	add    rcx,0x1
  20f982:	75 ec                	jne    20f970 <benchmark.add+0x5130>
  20f984:	e9 b7 01 00 00       	jmp    20fb40 <benchmark.add+0x5300>
  20f989:	4c 8b 5c 24 28       	mov    r11,QWORD PTR [rsp+0x28]
  20f98e:	48 8b 74 24 30       	mov    rsi,QWORD PTR [rsp+0x30]
  20f993:	48 8b 9c 24 f0 00 00 	mov    rbx,QWORD PTR [rsp+0xf0]
  20f99a:	00 
    while (index < block_size) : (index += 1) {
  20f99b:	4d 29 d1             	sub    r9,r10
  20f99e:	4c 8b 74 24 78       	mov    r14,QWORD PTR [rsp+0x78]
  20f9a3:	0f 84 97 01 00 00    	je     20fb40 <benchmark.add+0x5300>
        mem.swap(T, &items[start1 + index], &items[start2 + index]);
  20f9a9:	48 83 c3 ff          	add    rbx,0xffffffffffffffff
  20f9ad:	4c 29 d3             	sub    rbx,r10
  20f9b0:	48 29 f3             	sub    rbx,rsi
  20f9b3:	44 89 c8             	mov    eax,r9d
  20f9b6:	83 e0 03             	and    eax,0x3
  20f9b9:	48 83 fb 03          	cmp    rbx,0x3
  20f9bd:	48 89 f1             	mov    rcx,rsi
  20f9c0:	73 1a                	jae    20f9dc <benchmark.add+0x519c>
  20f9c2:	31 db                	xor    ebx,ebx
    while (index < block_size) : (index += 1) {
  20f9c4:	48 85 c0             	test   rax,rax
  20f9c7:	4c 8b 5c 24 28       	mov    r11,QWORD PTR [rsp+0x28]
  20f9cc:	48 8b 4c 24 30       	mov    rcx,QWORD PTR [rsp+0x30]
  20f9d1:	0f 85 0d 01 00 00    	jne    20fae4 <benchmark.add+0x52a4>
  20f9d7:	e9 64 01 00 00       	jmp    20fb40 <benchmark.add+0x5300>
        mem.swap(T, &items[start1 + index], &items[start2 + index]);
  20f9dc:	49 29 c1             	sub    r9,rax
  20f9df:	4d 89 d0             	mov    r8,r10
  20f9e2:	49 c1 e0 04          	shl    r8,0x4
  20f9e6:	4c 03 84 24 40 01 00 	add    r8,QWORD PTR [rsp+0x140]
  20f9ed:	00 
  20f9ee:	48 89 fe             	mov    rsi,rdi
  20f9f1:	48 c1 e6 04          	shl    rsi,0x4
  20f9f5:	49 89 cb             	mov    r11,rcx
  20f9f8:	49 c1 e3 04          	shl    r11,0x4
  20f9fc:	49 01 f3             	add    r11,rsi
  20f9ff:	31 f6                	xor    esi,esi
  20fa01:	31 db                	xor    ebx,ebx
  20fa03:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20fa0a:	84 00 00 00 00 00 
  20fa10:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
    const tmp = a.*;
  20fa15:	4a 8d 14 01          	lea    rdx,[rcx+r8*1]
  20fa19:	c5 f8 10 04 16       	vmovups xmm0,XMMWORD PTR [rsi+rdx*1]
  20fa1e:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  20fa23:	4c 01 d9             	add    rcx,r11
  20fa26:	c5 f8 10 04 0e       	vmovups xmm0,XMMWORD PTR [rsi+rcx*1]
  20fa2b:	c5 f8 11 04 16       	vmovups XMMWORD PTR [rsi+rdx*1],xmm0
    b.* = tmp;
  20fa30:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  20fa35:	c5 f8 11 04 0e       	vmovups XMMWORD PTR [rsi+rcx*1],xmm0
  20fa3a:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
    const tmp = a.*;
  20fa3f:	4a 8d 14 01          	lea    rdx,[rcx+r8*1]
  20fa43:	c5 f8 10 44 16 10    	vmovups xmm0,XMMWORD PTR [rsi+rdx*1+0x10]
  20fa49:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  20fa4e:	4c 01 d9             	add    rcx,r11
  20fa51:	c5 f8 10 44 0e 10    	vmovups xmm0,XMMWORD PTR [rsi+rcx*1+0x10]
  20fa57:	c5 f8 11 44 16 10    	vmovups XMMWORD PTR [rsi+rdx*1+0x10],xmm0
    b.* = tmp;
  20fa5d:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  20fa62:	c5 f8 11 44 0e 10    	vmovups XMMWORD PTR [rsi+rcx*1+0x10],xmm0
  20fa68:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
    const tmp = a.*;
  20fa6d:	4a 8d 14 01          	lea    rdx,[rcx+r8*1]
  20fa71:	c5 f8 10 44 16 20    	vmovups xmm0,XMMWORD PTR [rsi+rdx*1+0x20]
  20fa77:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  20fa7c:	4c 01 d9             	add    rcx,r11
  20fa7f:	c5 f8 10 44 0e 20    	vmovups xmm0,XMMWORD PTR [rsi+rcx*1+0x20]
  20fa85:	c5 f8 11 44 16 20    	vmovups XMMWORD PTR [rsi+rdx*1+0x20],xmm0
    b.* = tmp;
  20fa8b:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  20fa90:	c5 f8 11 44 0e 20    	vmovups XMMWORD PTR [rsi+rcx*1+0x20],xmm0
  20fa96:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
    const tmp = a.*;
  20fa9b:	4a 8d 14 01          	lea    rdx,[rcx+r8*1]
  20fa9f:	c5 f8 10 44 16 30    	vmovups xmm0,XMMWORD PTR [rsi+rdx*1+0x30]
  20faa5:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  20faaa:	4c 01 d9             	add    rcx,r11
  20faad:	c5 f8 10 44 0e 30    	vmovups xmm0,XMMWORD PTR [rsi+rcx*1+0x30]
  20fab3:	c5 f8 11 44 16 30    	vmovups XMMWORD PTR [rsi+rdx*1+0x30],xmm0
    b.* = tmp;
  20fab9:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  20fabe:	c5 fa 7f 44 0e 30    	vmovdqu XMMWORD PTR [rsi+rcx*1+0x30],xmm0
    while (index < block_size) : (index += 1) {
  20fac4:	48 83 c3 04          	add    rbx,0x4
  20fac8:	48 83 c6 40          	add    rsi,0x40
  20facc:	49 39 d9             	cmp    r9,rbx
  20facf:	0f 85 3b ff ff ff    	jne    20fa10 <benchmark.add+0x51d0>
  20fad5:	48 85 c0             	test   rax,rax
  20fad8:	4c 8b 5c 24 28       	mov    r11,QWORD PTR [rsp+0x28]
  20fadd:	48 8b 4c 24 30       	mov    rcx,QWORD PTR [rsp+0x30]
  20fae2:	74 5c                	je     20fb40 <benchmark.add+0x5300>
  20fae4:	48 01 df             	add    rdi,rbx
  20fae7:	48 01 cf             	add    rdi,rcx
  20faea:	48 c1 e7 04          	shl    rdi,0x4
  20faee:	4c 03 54 24 58       	add    r10,QWORD PTR [rsp+0x58]
  20faf3:	49 01 da             	add    r10,rbx
  20faf6:	49 c1 e2 04          	shl    r10,0x4
  20fafa:	48 f7 d8             	neg    rax
  20fafd:	0f 1f 00             	nop    DWORD PTR [rax]
        mem.swap(T, &items[start1 + index], &items[start2 + index]);
  20fb00:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
    const tmp = a.*;
  20fb05:	c4 a1 78 10 04 11    	vmovups xmm0,XMMWORD PTR [rcx+r10*1]
  20fb0b:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  20fb10:	c5 f8 10 04 39       	vmovups xmm0,XMMWORD PTR [rcx+rdi*1]
  20fb15:	c4 a1 78 11 04 11    	vmovups XMMWORD PTR [rcx+r10*1],xmm0
    b.* = tmp;
  20fb1b:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  20fb20:	c5 fa 7f 04 39       	vmovdqu XMMWORD PTR [rcx+rdi*1],xmm0
    while (index < block_size) : (index += 1) {
  20fb25:	48 83 c7 10          	add    rdi,0x10
  20fb29:	49 83 c2 10          	add    r10,0x10
  20fb2d:	48 83 c0 01          	add    rax,0x1
  20fb31:	75 cd                	jne    20fb00 <benchmark.add+0x52c0>
  20fb33:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20fb3a:	84 00 00 00 00 00 
  20fb40:	48 8b 5c 24 60       	mov    rbx,QWORD PTR [rsp+0x60]
  20fb45:	48 89 d8             	mov    rax,rbx
  20fb48:	4c 29 e0             	sub    rax,r12
  20fb4b:	48 89 44 24 30       	mov    QWORD PTR [rsp+0x30],rax
                                if (buffer2.length() > 0 or block_size <= cache.len) {
  20fb50:	80 bc 24 58 01 00 00 	cmp    BYTE PTR [rsp+0x158],0x0
  20fb57:	00 
  20fb58:	74 36                	je     20fb90 <benchmark.add+0x5350>
  20fb5a:	49 81 fb 01 02 00 00 	cmp    r11,0x201
                                    if (block_size <= cache.len) {
  20fb61:	73 7d                	jae    20fbe0 <benchmark.add+0x53a0>
                                        mem.copy(T, cache[0..], items[blockA.start .. blockA.start + block_size]);
  20fb63:	4c 03 6c 24 48       	add    r13,QWORD PTR [rsp+0x48]
  20fb68:	49 83 fe 07          	cmp    r14,0x7
  20fb6c:	4c 8b 54 24 38       	mov    r10,QWORD PTR [rsp+0x38]
    for (source) |s, i|
  20fb71:	0f 83 f4 01 00 00    	jae    20fd6b <benchmark.add+0x552b>
  20fb77:	31 c0                	xor    eax,eax
  20fb79:	48 83 bc 24 60 01 00 	cmp    QWORD PTR [rsp+0x160],0x0
  20fb80:	00 00 
  20fb82:	0f 85 ad 02 00 00    	jne    20fe35 <benchmark.add+0x55f5>
  20fb88:	e9 2c 04 00 00       	jmp    20ffb9 <benchmark.add+0x5779>
  20fb8d:	0f 1f 00             	nop    DWORD PTR [rax]
                                    mem.rotate(T, items[B_split .. blockA.start + block_size], blockA.start - B_split);
  20fb90:	4c 8b 5c 24 48       	mov    r11,QWORD PTR [rsp+0x48]
  20fb95:	4c 89 e2             	mov    rdx,r12
  20fb98:	48 c1 e2 04          	shl    rdx,0x4
  20fb9c:	4d 8d 0c 13          	lea    r9,[r11+rdx*1]
  20fba0:	4c 8b 44 24 20       	mov    r8,QWORD PTR [rsp+0x20]
  20fba5:	4d 29 e0             	sub    r8,r12
  20fba8:	4d 89 fe             	mov    r14,r15
  20fbab:	4d 29 e6             	sub    r14,r12
    const end = items.len / 2;
  20fbae:	4c 89 f3             	mov    rbx,r14
  20fbb1:	48 d1 eb             	shr    rbx,1
    while (i < end) : (i += 1) {
  20fbb4:	0f 84 6f 01 00 00    	je     20fd29 <benchmark.add+0x54e9>
        swap(T, &items[i], &items[items.len - i - 1]);
  20fbba:	48 8d 4b ff          	lea    rcx,[rbx-0x1]
  20fbbe:	89 d8                	mov    eax,ebx
  20fbc0:	83 e0 03             	and    eax,0x3
  20fbc3:	48 83 f9 03          	cmp    rcx,0x3
  20fbc7:	73 39                	jae    20fc02 <benchmark.add+0x53c2>
  20fbc9:	31 f6                	xor    esi,esi
    while (i < end) : (i += 1) {
  20fbcb:	48 85 c0             	test   rax,rax
  20fbce:	0f 85 11 01 00 00    	jne    20fce5 <benchmark.add+0x54a5>
  20fbd4:	e9 50 01 00 00       	jmp    20fd29 <benchmark.add+0x54e9>
  20fbd9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  20fbe0:	49 83 fe 03          	cmp    r14,0x3
  20fbe4:	4c 8b 54 24 38       	mov    r10,QWORD PTR [rsp+0x38]
        mem.swap(T, &items[start1 + index], &items[start2 + index]);
  20fbe9:	0f 83 86 02 00 00    	jae    20fe75 <benchmark.add+0x5635>
  20fbef:	31 c0                	xor    eax,eax
  20fbf1:	48 83 7c 24 10 00    	cmp    QWORD PTR [rsp+0x10],0x0
    while (index < block_size) : (index += 1) {
  20fbf7:	0f 85 71 03 00 00    	jne    20ff6e <benchmark.add+0x572e>
  20fbfd:	e9 b7 03 00 00       	jmp    20ffb9 <benchmark.add+0x5779>
        swap(T, &items[i], &items[items.len - i - 1]);
  20fc02:	48 29 c3             	sub    rbx,rax
  20fc05:	49 8d 0c 13          	lea    rcx,[r11+rdx*1]
  20fc09:	48 83 c1 30          	add    rcx,0x30
  20fc0d:	31 f6                	xor    esi,esi
  20fc0f:	90                   	nop
  20fc10:	48 89 f7             	mov    rdi,rsi
  20fc13:	48 f7 d7             	not    rdi
  20fc16:	4c 01 f7             	add    rdi,r14
  20fc19:	48 c1 e7 04          	shl    rdi,0x4
    const tmp = a.*;
  20fc1d:	c5 f8 10 41 d0       	vmovups xmm0,XMMWORD PTR [rcx-0x30]
  20fc22:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  20fc27:	c4 c1 78 10 04 39    	vmovups xmm0,XMMWORD PTR [r9+rdi*1]
  20fc2d:	c5 f8 11 41 d0       	vmovups XMMWORD PTR [rcx-0x30],xmm0
    b.* = tmp;
  20fc32:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  20fc37:	c4 c1 78 11 04 39    	vmovups XMMWORD PTR [r9+rdi*1],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  20fc3d:	48 c7 c7 fe ff ff ff 	mov    rdi,0xfffffffffffffffe
  20fc44:	48 29 f7             	sub    rdi,rsi
  20fc47:	4c 01 f7             	add    rdi,r14
    const tmp = a.*;
  20fc4a:	c5 f8 10 41 e0       	vmovups xmm0,XMMWORD PTR [rcx-0x20]
  20fc4f:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  20fc54:	48 c1 e7 04          	shl    rdi,0x4
    a.* = b.*;
  20fc58:	c4 c1 78 10 04 39    	vmovups xmm0,XMMWORD PTR [r9+rdi*1]
  20fc5e:	c5 f8 11 41 e0       	vmovups XMMWORD PTR [rcx-0x20],xmm0
    b.* = tmp;
  20fc63:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  20fc68:	c4 c1 78 11 04 39    	vmovups XMMWORD PTR [r9+rdi*1],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  20fc6e:	48 c7 c7 fd ff ff ff 	mov    rdi,0xfffffffffffffffd
  20fc75:	48 29 f7             	sub    rdi,rsi
  20fc78:	4c 01 f7             	add    rdi,r14
  20fc7b:	48 c1 e7 04          	shl    rdi,0x4
    const tmp = a.*;
  20fc7f:	c5 f8 10 41 f0       	vmovups xmm0,XMMWORD PTR [rcx-0x10]
  20fc84:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  20fc89:	c4 c1 78 10 04 39    	vmovups xmm0,XMMWORD PTR [r9+rdi*1]
  20fc8f:	c5 f8 11 41 f0       	vmovups XMMWORD PTR [rcx-0x10],xmm0
    b.* = tmp;
  20fc94:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  20fc99:	c4 c1 78 11 04 39    	vmovups XMMWORD PTR [r9+rdi*1],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  20fc9f:	48 c7 c7 fc ff ff ff 	mov    rdi,0xfffffffffffffffc
  20fca6:	48 29 f7             	sub    rdi,rsi
  20fca9:	4c 01 f7             	add    rdi,r14
    const tmp = a.*;
  20fcac:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  20fcb0:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  20fcb5:	48 c1 e7 04          	shl    rdi,0x4
    a.* = b.*;
  20fcb9:	c4 c1 78 10 04 39    	vmovups xmm0,XMMWORD PTR [r9+rdi*1]
  20fcbf:	c5 f8 11 01          	vmovups XMMWORD PTR [rcx],xmm0
    b.* = tmp;
  20fcc3:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  20fcc8:	c4 c1 7a 7f 04 39    	vmovdqu XMMWORD PTR [r9+rdi*1],xmm0
    while (i < end) : (i += 1) {
  20fcce:	48 83 c6 04          	add    rsi,0x4
  20fcd2:	48 83 c1 40          	add    rcx,0x40
  20fcd6:	48 83 c3 fc          	add    rbx,0xfffffffffffffffc
  20fcda:	0f 85 30 ff ff ff    	jne    20fc10 <benchmark.add+0x53d0>
  20fce0:	48 85 c0             	test   rax,rax
  20fce3:	74 44                	je     20fd29 <benchmark.add+0x54e9>
  20fce5:	49 8d 0c 34          	lea    rcx,[r12+rsi*1]
  20fce9:	48 c1 e1 04          	shl    rcx,0x4
  20fced:	4c 01 d9             	add    rcx,r11
        swap(T, &items[i], &items[items.len - i - 1]);
  20fcf0:	48 89 f7             	mov    rdi,rsi
  20fcf3:	48 f7 d7             	not    rdi
  20fcf6:	4c 01 f7             	add    rdi,r14
    const tmp = a.*;
  20fcf9:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  20fcfd:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  20fd02:	48 c1 e7 04          	shl    rdi,0x4
    a.* = b.*;
  20fd06:	c4 c1 78 10 04 39    	vmovups xmm0,XMMWORD PTR [r9+rdi*1]
  20fd0c:	c5 f8 11 01          	vmovups XMMWORD PTR [rcx],xmm0
    b.* = tmp;
  20fd10:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  20fd15:	c4 c1 7a 7f 04 39    	vmovdqu XMMWORD PTR [r9+rdi*1],xmm0
    while (i < end) : (i += 1) {
  20fd1b:	48 83 c6 01          	add    rsi,0x1
  20fd1f:	48 83 c1 10          	add    rcx,0x10
  20fd23:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  20fd27:	75 c7                	jne    20fcf0 <benchmark.add+0x54b0>
  20fd29:	48 89 54 24 60       	mov    QWORD PTR [rsp+0x60],rdx
    reverse(T, items[amount..]);
  20fd2e:	4d 89 c2             	mov    r10,r8
  20fd31:	4d 29 f2             	sub    r10,r14
    while (i < end) : (i += 1) {
  20fd34:	49 83 fa 02          	cmp    r10,0x2
  20fd38:	4c 8b 74 24 78       	mov    r14,QWORD PTR [rsp+0x78]
  20fd3d:	0f 82 71 05 00 00    	jb     2102b4 <benchmark.add+0x5a74>
  20fd43:	4d 01 dd             	add    r13,r11
  20fd46:	48 83 bc 24 a8 01 00 	cmp    QWORD PTR [rsp+0x1a8],0x3
  20fd4d:	00 03 
        swap(T, &items[i], &items[items.len - i - 1]);
  20fd4f:	0f 83 eb 03 00 00    	jae    210140 <benchmark.add+0x5900>
  20fd55:	31 ff                	xor    edi,edi
  20fd57:	48 83 bc 24 78 01 00 	cmp    QWORD PTR [rsp+0x178],0x0
  20fd5e:	00 00 
    while (i < end) : (i += 1) {
  20fd60:	0f 85 f4 04 00 00    	jne    21025a <benchmark.add+0x5a1a>
  20fd66:	e9 49 05 00 00       	jmp    2102b4 <benchmark.add+0x5a74>
  20fd6b:	48 8d 8c 24 10 03 00 	lea    rcx,[rsp+0x310]
  20fd72:	00 
  20fd73:	31 c0                	xor    eax,eax
  20fd75:	48 8b 94 24 98 01 00 	mov    rdx,QWORD PTR [rsp+0x198]
  20fd7c:	00 
  20fd7d:	0f 1f 00             	nop    DWORD PTR [rax]
    for (source) |s, i|
  20fd80:	48 89 c6             	mov    rsi,rax
  20fd83:	48 c1 e6 04          	shl    rsi,0x4
        dest[i] = s;
  20fd87:	c4 c1 78 10 44 35 00 	vmovups xmm0,XMMWORD PTR [r13+rsi*1+0x0]
  20fd8e:	c5 f8 11 41 90       	vmovups XMMWORD PTR [rcx-0x70],xmm0
    for (source) |s, i|
  20fd93:	48 89 f7             	mov    rdi,rsi
  20fd96:	48 83 cf 10          	or     rdi,0x10
        dest[i] = s;
  20fd9a:	c4 c1 78 10 44 3d 00 	vmovups xmm0,XMMWORD PTR [r13+rdi*1+0x0]
  20fda1:	c5 f8 11 41 a0       	vmovups XMMWORD PTR [rcx-0x60],xmm0
    for (source) |s, i|
  20fda6:	48 89 f7             	mov    rdi,rsi
  20fda9:	48 83 cf 20          	or     rdi,0x20
        dest[i] = s;
  20fdad:	c4 c1 78 10 44 3d 00 	vmovups xmm0,XMMWORD PTR [r13+rdi*1+0x0]
  20fdb4:	c5 f8 11 41 b0       	vmovups XMMWORD PTR [rcx-0x50],xmm0
    for (source) |s, i|
  20fdb9:	48 89 f7             	mov    rdi,rsi
  20fdbc:	48 83 cf 30          	or     rdi,0x30
        dest[i] = s;
  20fdc0:	c4 c1 78 10 44 3d 00 	vmovups xmm0,XMMWORD PTR [r13+rdi*1+0x0]
  20fdc7:	c5 f8 11 41 c0       	vmovups XMMWORD PTR [rcx-0x40],xmm0
    for (source) |s, i|
  20fdcc:	48 89 f7             	mov    rdi,rsi
  20fdcf:	48 83 cf 40          	or     rdi,0x40
        dest[i] = s;
  20fdd3:	c4 c1 78 10 44 3d 00 	vmovups xmm0,XMMWORD PTR [r13+rdi*1+0x0]
  20fdda:	c5 f8 11 41 d0       	vmovups XMMWORD PTR [rcx-0x30],xmm0
    for (source) |s, i|
  20fddf:	48 89 f7             	mov    rdi,rsi
  20fde2:	48 83 cf 50          	or     rdi,0x50
        dest[i] = s;
  20fde6:	c4 c1 78 10 44 3d 00 	vmovups xmm0,XMMWORD PTR [r13+rdi*1+0x0]
  20fded:	c5 f8 11 41 e0       	vmovups XMMWORD PTR [rcx-0x20],xmm0
    for (source) |s, i|
  20fdf2:	48 89 f7             	mov    rdi,rsi
  20fdf5:	48 83 cf 60          	or     rdi,0x60
        dest[i] = s;
  20fdf9:	c4 c1 78 10 44 3d 00 	vmovups xmm0,XMMWORD PTR [r13+rdi*1+0x0]
  20fe00:	c5 f8 11 41 f0       	vmovups XMMWORD PTR [rcx-0x10],xmm0
    for (source) |s, i|
  20fe05:	48 83 ce 70          	or     rsi,0x70
        dest[i] = s;
  20fe09:	c4 c1 7a 6f 44 35 00 	vmovdqu xmm0,XMMWORD PTR [r13+rsi*1+0x0]
  20fe10:	c5 fa 7f 01          	vmovdqu XMMWORD PTR [rcx],xmm0
    for (source) |s, i|
  20fe14:	48 83 c0 08          	add    rax,0x8
  20fe18:	48 83 e9 80          	sub    rcx,0xffffffffffffff80
  20fe1c:	48 83 c2 f8          	add    rdx,0xfffffffffffffff8
  20fe20:	0f 85 5a ff ff ff    	jne    20fd80 <benchmark.add+0x5540>
  20fe26:	48 83 bc 24 60 01 00 	cmp    QWORD PTR [rsp+0x160],0x0
  20fe2d:	00 00 
  20fe2f:	0f 84 84 01 00 00    	je     20ffb9 <benchmark.add+0x5779>
  20fe35:	48 89 c1             	mov    rcx,rax
  20fe38:	48 c1 e1 04          	shl    rcx,0x4
  20fe3c:	48 01 e1             	add    rcx,rsp
  20fe3f:	48 81 c1 a0 02 00 00 	add    rcx,0x2a0
  20fe46:	48 8b 94 24 60 01 00 	mov    rdx,QWORD PTR [rsp+0x160]
  20fe4d:	00 
  20fe4e:	66 90                	xchg   ax,ax
  20fe50:	48 89 c6             	mov    rsi,rax
  20fe53:	48 c1 e6 04          	shl    rsi,0x4
        dest[i] = s;
  20fe57:	c4 c1 7a 6f 44 35 00 	vmovdqu xmm0,XMMWORD PTR [r13+rsi*1+0x0]
  20fe5e:	c5 fa 7f 01          	vmovdqu XMMWORD PTR [rcx],xmm0
    for (source) |s, i|
  20fe62:	48 83 c0 01          	add    rax,0x1
  20fe66:	48 83 c1 10          	add    rcx,0x10
  20fe6a:	48 83 c2 ff          	add    rdx,0xffffffffffffffff
  20fe6e:	75 e0                	jne    20fe50 <benchmark.add+0x5610>
  20fe70:	e9 44 01 00 00       	jmp    20ffb9 <benchmark.add+0x5779>
  20fe75:	48 8b 8c 24 90 01 00 	mov    rcx,QWORD PTR [rsp+0x190]
  20fe7c:	00 
  20fe7d:	31 c0                	xor    eax,eax
  20fe7f:	48 8b 94 24 28 01 00 	mov    rdx,QWORD PTR [rsp+0x128]
  20fe86:	00 
  20fe87:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  20fe8e:	00 00 
        mem.swap(T, &items[start1 + index], &items[start2 + index]);
  20fe90:	4a 8d 34 38          	lea    rsi,[rax+r15*1]
  20fe94:	48 8b 7c 24 48       	mov    rdi,QWORD PTR [rsp+0x48]
  20fe99:	48 c1 e6 04          	shl    rsi,0x4
    const tmp = a.*;
  20fe9d:	c5 f8 10 04 37       	vmovups xmm0,XMMWORD PTR [rdi+rsi*1]
  20fea2:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  20fea7:	c5 f8 10 44 0f e0    	vmovups xmm0,XMMWORD PTR [rdi+rcx*1-0x20]
  20fead:	c5 f8 11 04 37       	vmovups XMMWORD PTR [rdi+rsi*1],xmm0
    b.* = tmp;
  20feb2:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  20feb7:	c5 f8 11 44 0f e0    	vmovups XMMWORD PTR [rdi+rcx*1-0x20],xmm0
    while (index < block_size) : (index += 1) {
  20febd:	48 89 c6             	mov    rsi,rax
  20fec0:	48 83 ce 01          	or     rsi,0x1
        mem.swap(T, &items[start1 + index], &items[start2 + index]);
  20fec4:	4c 01 fe             	add    rsi,r15
  20fec7:	48 8b 7c 24 48       	mov    rdi,QWORD PTR [rsp+0x48]
  20fecc:	48 c1 e6 04          	shl    rsi,0x4
    const tmp = a.*;
  20fed0:	c5 f8 10 04 37       	vmovups xmm0,XMMWORD PTR [rdi+rsi*1]
  20fed5:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  20feda:	c5 f8 10 44 0f f0    	vmovups xmm0,XMMWORD PTR [rdi+rcx*1-0x10]
  20fee0:	c5 f8 11 04 37       	vmovups XMMWORD PTR [rdi+rsi*1],xmm0
    b.* = tmp;
  20fee5:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  20feea:	c5 f8 11 44 0f f0    	vmovups XMMWORD PTR [rdi+rcx*1-0x10],xmm0
    while (index < block_size) : (index += 1) {
  20fef0:	48 89 c6             	mov    rsi,rax
  20fef3:	48 83 ce 02          	or     rsi,0x2
        mem.swap(T, &items[start1 + index], &items[start2 + index]);
  20fef7:	4c 01 fe             	add    rsi,r15
  20fefa:	48 8b 7c 24 48       	mov    rdi,QWORD PTR [rsp+0x48]
  20feff:	48 c1 e6 04          	shl    rsi,0x4
    const tmp = a.*;
  20ff03:	c5 f8 10 04 37       	vmovups xmm0,XMMWORD PTR [rdi+rsi*1]
  20ff08:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  20ff0d:	c5 f8 10 04 0f       	vmovups xmm0,XMMWORD PTR [rdi+rcx*1]
  20ff12:	c5 f8 11 04 37       	vmovups XMMWORD PTR [rdi+rsi*1],xmm0
    b.* = tmp;
  20ff17:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  20ff1c:	c5 f8 11 04 0f       	vmovups XMMWORD PTR [rdi+rcx*1],xmm0
    while (index < block_size) : (index += 1) {
  20ff21:	48 89 c6             	mov    rsi,rax
  20ff24:	48 83 ce 03          	or     rsi,0x3
        mem.swap(T, &items[start1 + index], &items[start2 + index]);
  20ff28:	4c 01 fe             	add    rsi,r15
  20ff2b:	48 8b 7c 24 48       	mov    rdi,QWORD PTR [rsp+0x48]
  20ff30:	48 c1 e6 04          	shl    rsi,0x4
    const tmp = a.*;
  20ff34:	c5 f8 10 04 37       	vmovups xmm0,XMMWORD PTR [rdi+rsi*1]
  20ff39:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  20ff3e:	c5 f8 10 44 0f 10    	vmovups xmm0,XMMWORD PTR [rdi+rcx*1+0x10]
  20ff44:	c5 f8 11 04 37       	vmovups XMMWORD PTR [rdi+rsi*1],xmm0
    b.* = tmp;
  20ff49:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  20ff4e:	c5 fa 7f 44 0f 10    	vmovdqu XMMWORD PTR [rdi+rcx*1+0x10],xmm0
    while (index < block_size) : (index += 1) {
  20ff54:	48 83 c0 04          	add    rax,0x4
  20ff58:	48 83 c1 40          	add    rcx,0x40
  20ff5c:	48 83 c2 fc          	add    rdx,0xfffffffffffffffc
  20ff60:	0f 85 2a ff ff ff    	jne    20fe90 <benchmark.add+0x5650>
  20ff66:	48 83 7c 24 10 00    	cmp    QWORD PTR [rsp+0x10],0x0
  20ff6c:	74 4b                	je     20ffb9 <benchmark.add+0x5779>
  20ff6e:	48 8b 4c 24 58       	mov    rcx,QWORD PTR [rsp+0x58]
  20ff73:	48 8d 0c 01          	lea    rcx,[rcx+rax*1]
  20ff77:	48 c1 e1 04          	shl    rcx,0x4
  20ff7b:	48 8b 54 24 10       	mov    rdx,QWORD PTR [rsp+0x10]
        mem.swap(T, &items[start1 + index], &items[start2 + index]);
  20ff80:	4a 8d 34 38          	lea    rsi,[rax+r15*1]
  20ff84:	48 8b 7c 24 48       	mov    rdi,QWORD PTR [rsp+0x48]
  20ff89:	48 c1 e6 04          	shl    rsi,0x4
    const tmp = a.*;
  20ff8d:	c5 f8 10 04 37       	vmovups xmm0,XMMWORD PTR [rdi+rsi*1]
  20ff92:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  20ff97:	c5 f8 10 04 0f       	vmovups xmm0,XMMWORD PTR [rdi+rcx*1]
  20ff9c:	c5 f8 11 04 37       	vmovups XMMWORD PTR [rdi+rsi*1],xmm0
    b.* = tmp;
  20ffa1:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  20ffa6:	c5 fa 7f 04 0f       	vmovdqu XMMWORD PTR [rdi+rcx*1],xmm0
    while (index < block_size) : (index += 1) {
  20ffab:	48 83 c0 01          	add    rax,0x1
  20ffaf:	48 83 c1 10          	add    rcx,0x10
  20ffb3:	48 83 c2 ff          	add    rdx,0xffffffffffffffff
  20ffb7:	75 c7                	jne    20ff80 <benchmark.add+0x5740>
  20ffb9:	4c 8b 6c 24 30       	mov    r13,QWORD PTR [rsp+0x30]
  20ffbe:	4d 85 ed             	test   r13,r13
  20ffc1:	0f 84 99 04 00 00    	je     210460 <benchmark.add+0x5c20>
  20ffc7:	48 8b 4c 24 20       	mov    rcx,QWORD PTR [rsp+0x20]
  20ffcc:	4c 29 e9             	sub    rcx,r13
        mem.swap(T, &items[start1 + index], &items[start2 + index]);
  20ffcf:	48 83 c3 ff          	add    rbx,0xffffffffffffffff
  20ffd3:	4c 29 e3             	sub    rbx,r12
  20ffd6:	44 89 e8             	mov    eax,r13d
  20ffd9:	83 e0 03             	and    eax,0x3
  20ffdc:	48 83 fb 03          	cmp    rbx,0x3
  20ffe0:	73 10                	jae    20fff2 <benchmark.add+0x57b2>
  20ffe2:	31 d2                	xor    edx,edx
    while (index < block_size) : (index += 1) {
  20ffe4:	48 85 c0             	test   rax,rax
  20ffe7:	0f 85 01 01 00 00    	jne    2100ee <benchmark.add+0x58ae>
  20ffed:	e9 6e 04 00 00       	jmp    210460 <benchmark.add+0x5c20>
        mem.swap(T, &items[start1 + index], &items[start2 + index]);
  20fff2:	4d 89 e9             	mov    r9,r13
  20fff5:	49 29 c1             	sub    r9,rax
  20fff8:	4c 89 e7             	mov    rdi,r12
  20fffb:	48 c1 e7 04          	shl    rdi,0x4
  20ffff:	48 83 c7 20          	add    rdi,0x20
  210003:	31 d2                	xor    edx,edx
  210005:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21000c:	00 00 00 00 
  210010:	48 8b 5c 24 48       	mov    rbx,QWORD PTR [rsp+0x48]
  210015:	48 8d 34 11          	lea    rsi,[rcx+rdx*1]
  210019:	48 c1 e6 04          	shl    rsi,0x4
    const tmp = a.*;
  21001d:	c5 f8 10 44 3b e0    	vmovups xmm0,XMMWORD PTR [rbx+rdi*1-0x20]
  210023:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  210028:	c5 f8 10 04 33       	vmovups xmm0,XMMWORD PTR [rbx+rsi*1]
  21002d:	c5 f8 11 44 3b e0    	vmovups XMMWORD PTR [rbx+rdi*1-0x20],xmm0
    b.* = tmp;
  210033:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  210038:	c5 f8 11 04 33       	vmovups XMMWORD PTR [rbx+rsi*1],xmm0
    while (index < block_size) : (index += 1) {
  21003d:	48 89 d6             	mov    rsi,rdx
  210040:	48 83 ce 01          	or     rsi,0x1
        mem.swap(T, &items[start1 + index], &items[start2 + index]);
  210044:	48 8b 5c 24 48       	mov    rbx,QWORD PTR [rsp+0x48]
  210049:	48 01 ce             	add    rsi,rcx
    const tmp = a.*;
  21004c:	c5 f8 10 44 3b f0    	vmovups xmm0,XMMWORD PTR [rbx+rdi*1-0x10]
  210052:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
  210057:	48 c1 e6 04          	shl    rsi,0x4
    a.* = b.*;
  21005b:	c5 f8 10 04 33       	vmovups xmm0,XMMWORD PTR [rbx+rsi*1]
  210060:	c5 f8 11 44 3b f0    	vmovups XMMWORD PTR [rbx+rdi*1-0x10],xmm0
    b.* = tmp;
  210066:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  21006b:	c5 f8 11 04 33       	vmovups XMMWORD PTR [rbx+rsi*1],xmm0
    while (index < block_size) : (index += 1) {
  210070:	48 89 d6             	mov    rsi,rdx
  210073:	48 83 ce 02          	or     rsi,0x2
        mem.swap(T, &items[start1 + index], &items[start2 + index]);
  210077:	48 8b 5c 24 48       	mov    rbx,QWORD PTR [rsp+0x48]
  21007c:	48 01 ce             	add    rsi,rcx
  21007f:	48 c1 e6 04          	shl    rsi,0x4
    const tmp = a.*;
  210083:	c5 f8 10 04 3b       	vmovups xmm0,XMMWORD PTR [rbx+rdi*1]
  210088:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21008d:	c5 f8 10 04 33       	vmovups xmm0,XMMWORD PTR [rbx+rsi*1]
  210092:	c5 f8 11 04 3b       	vmovups XMMWORD PTR [rbx+rdi*1],xmm0
    b.* = tmp;
  210097:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  21009c:	c5 f8 11 04 33       	vmovups XMMWORD PTR [rbx+rsi*1],xmm0
    while (index < block_size) : (index += 1) {
  2100a1:	48 89 d6             	mov    rsi,rdx
  2100a4:	48 83 ce 03          	or     rsi,0x3
        mem.swap(T, &items[start1 + index], &items[start2 + index]);
  2100a8:	48 8b 5c 24 48       	mov    rbx,QWORD PTR [rsp+0x48]
  2100ad:	48 01 ce             	add    rsi,rcx
    const tmp = a.*;
  2100b0:	c5 f8 10 44 3b 10    	vmovups xmm0,XMMWORD PTR [rbx+rdi*1+0x10]
  2100b6:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
  2100bb:	48 c1 e6 04          	shl    rsi,0x4
    a.* = b.*;
  2100bf:	c5 f8 10 04 33       	vmovups xmm0,XMMWORD PTR [rbx+rsi*1]
  2100c4:	c5 f8 11 44 3b 10    	vmovups XMMWORD PTR [rbx+rdi*1+0x10],xmm0
    b.* = tmp;
  2100ca:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  2100cf:	c5 fa 7f 04 33       	vmovdqu XMMWORD PTR [rbx+rsi*1],xmm0
    while (index < block_size) : (index += 1) {
  2100d4:	48 83 c2 04          	add    rdx,0x4
  2100d8:	48 83 c7 40          	add    rdi,0x40
  2100dc:	49 39 d1             	cmp    r9,rdx
  2100df:	0f 85 2b ff ff ff    	jne    210010 <benchmark.add+0x57d0>
  2100e5:	48 85 c0             	test   rax,rax
  2100e8:	0f 84 72 03 00 00    	je     210460 <benchmark.add+0x5c20>
  2100ee:	49 01 d4             	add    r12,rdx
  2100f1:	49 c1 e4 04          	shl    r12,0x4
  2100f5:	48 f7 d8             	neg    rax
  2100f8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  2100ff:	00 
        mem.swap(T, &items[start1 + index], &items[start2 + index]);
  210100:	48 8b 74 24 48       	mov    rsi,QWORD PTR [rsp+0x48]
  210105:	48 8d 3c 11          	lea    rdi,[rcx+rdx*1]
    const tmp = a.*;
  210109:	c4 a1 78 10 04 26    	vmovups xmm0,XMMWORD PTR [rsi+r12*1]
  21010f:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
  210114:	48 c1 e7 04          	shl    rdi,0x4
    a.* = b.*;
  210118:	c5 f8 10 04 3e       	vmovups xmm0,XMMWORD PTR [rsi+rdi*1]
  21011d:	c4 a1 78 11 04 26    	vmovups XMMWORD PTR [rsi+r12*1],xmm0
    b.* = tmp;
  210123:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  210128:	c5 fa 7f 04 3e       	vmovdqu XMMWORD PTR [rsi+rdi*1],xmm0
    while (index < block_size) : (index += 1) {
  21012d:	48 83 c2 01          	add    rdx,0x1
  210131:	49 83 c4 10          	add    r12,0x10
  210135:	48 83 c0 01          	add    rax,0x1
  210139:	75 c5                	jne    210100 <benchmark.add+0x58c0>
  21013b:	e9 20 03 00 00       	jmp    210460 <benchmark.add+0x5c20>
  210140:	31 ff                	xor    edi,edi
  210142:	48 8b 8c 24 a0 01 00 	mov    rcx,QWORD PTR [rsp+0x1a0]
  210149:	00 
  21014a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
        swap(T, &items[i], &items[items.len - i - 1]);
  210150:	48 89 fe             	mov    rsi,rdi
  210153:	48 c1 e6 04          	shl    rsi,0x4
  210157:	48 89 fb             	mov    rbx,rdi
  21015a:	48 f7 d3             	not    rbx
  21015d:	4c 01 d3             	add    rbx,r10
    const tmp = a.*;
  210160:	c4 c1 78 10 44 35 00 	vmovups xmm0,XMMWORD PTR [r13+rsi*1+0x0]
  210167:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  21016c:	48 c1 e3 04          	shl    rbx,0x4
    a.* = b.*;
  210170:	c4 c1 78 10 44 1d 00 	vmovups xmm0,XMMWORD PTR [r13+rbx*1+0x0]
  210177:	c4 c1 78 11 44 35 00 	vmovups XMMWORD PTR [r13+rsi*1+0x0],xmm0
    b.* = tmp;
  21017e:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
        swap(T, &items[i], &items[items.len - i - 1]);
  210183:	48 89 f0             	mov    rax,rsi
  210186:	48 83 c8 10          	or     rax,0x10
  21018a:	48 c7 c2 fe ff ff ff 	mov    rdx,0xfffffffffffffffe
  210191:	48 29 fa             	sub    rdx,rdi
  210194:	4c 01 d2             	add    rdx,r10
  210197:	48 c1 e2 04          	shl    rdx,0x4
    b.* = tmp;
  21019b:	c4 c1 78 11 44 1d 00 	vmovups XMMWORD PTR [r13+rbx*1+0x0],xmm0
    const tmp = a.*;
  2101a2:	c4 c1 78 10 44 05 00 	vmovups xmm0,XMMWORD PTR [r13+rax*1+0x0]
  2101a9:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  2101ae:	c4 c1 78 10 44 15 00 	vmovups xmm0,XMMWORD PTR [r13+rdx*1+0x0]
  2101b5:	c4 c1 78 11 44 05 00 	vmovups XMMWORD PTR [r13+rax*1+0x0],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  2101bc:	48 89 f0             	mov    rax,rsi
  2101bf:	48 83 c8 20          	or     rax,0x20
    b.* = tmp;
  2101c3:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
        swap(T, &items[i], &items[items.len - i - 1]);
  2101c8:	48 c7 c3 fd ff ff ff 	mov    rbx,0xfffffffffffffffd
  2101cf:	48 29 fb             	sub    rbx,rdi
    b.* = tmp;
  2101d2:	c4 c1 78 11 44 15 00 	vmovups XMMWORD PTR [r13+rdx*1+0x0],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  2101d9:	4c 01 d3             	add    rbx,r10
    const tmp = a.*;
  2101dc:	c4 c1 78 10 44 05 00 	vmovups xmm0,XMMWORD PTR [r13+rax*1+0x0]
  2101e3:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  2101e8:	48 c1 e3 04          	shl    rbx,0x4
    a.* = b.*;
  2101ec:	c4 c1 78 10 44 1d 00 	vmovups xmm0,XMMWORD PTR [r13+rbx*1+0x0]
  2101f3:	c4 c1 78 11 44 05 00 	vmovups XMMWORD PTR [r13+rax*1+0x0],xmm0
    b.* = tmp;
  2101fa:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
        swap(T, &items[i], &items[items.len - i - 1]);
  2101ff:	48 83 ce 30          	or     rsi,0x30
  210203:	48 c7 c0 fc ff ff ff 	mov    rax,0xfffffffffffffffc
  21020a:	48 29 f8             	sub    rax,rdi
  21020d:	4c 01 d0             	add    rax,r10
    b.* = tmp;
  210210:	c4 c1 78 11 44 1d 00 	vmovups XMMWORD PTR [r13+rbx*1+0x0],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  210217:	48 c1 e0 04          	shl    rax,0x4
    const tmp = a.*;
  21021b:	c4 c1 78 10 44 35 00 	vmovups xmm0,XMMWORD PTR [r13+rsi*1+0x0]
  210222:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  210227:	c4 c1 78 10 44 05 00 	vmovups xmm0,XMMWORD PTR [r13+rax*1+0x0]
  21022e:	c4 c1 78 11 44 35 00 	vmovups XMMWORD PTR [r13+rsi*1+0x0],xmm0
    b.* = tmp;
  210235:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
    while (i < end) : (i += 1) {
  21023a:	48 83 c7 04          	add    rdi,0x4
  21023e:	48 83 c1 fc          	add    rcx,0xfffffffffffffffc
    b.* = tmp;
  210242:	c4 c1 7a 7f 44 05 00 	vmovdqu XMMWORD PTR [r13+rax*1+0x0],xmm0
    while (i < end) : (i += 1) {
  210249:	0f 85 01 ff ff ff    	jne    210150 <benchmark.add+0x5910>
  21024f:	48 83 bc 24 78 01 00 	cmp    QWORD PTR [rsp+0x178],0x0
  210256:	00 00 
  210258:	74 5a                	je     2102b4 <benchmark.add+0x5a74>
  21025a:	48 8b 8c 24 78 01 00 	mov    rcx,QWORD PTR [rsp+0x178]
  210261:	00 
  210262:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  210269:	1f 84 00 00 00 00 00 
        swap(T, &items[i], &items[items.len - i - 1]);
  210270:	48 89 f8             	mov    rax,rdi
  210273:	48 c1 e0 04          	shl    rax,0x4
  210277:	48 89 fa             	mov    rdx,rdi
  21027a:	48 f7 d2             	not    rdx
  21027d:	4c 01 d2             	add    rdx,r10
  210280:	48 c1 e2 04          	shl    rdx,0x4
    const tmp = a.*;
  210284:	c4 c1 78 10 44 05 00 	vmovups xmm0,XMMWORD PTR [r13+rax*1+0x0]
  21028b:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  210290:	c4 c1 78 10 44 15 00 	vmovups xmm0,XMMWORD PTR [r13+rdx*1+0x0]
  210297:	c4 c1 78 11 44 05 00 	vmovups XMMWORD PTR [r13+rax*1+0x0],xmm0
    b.* = tmp;
  21029e:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  2102a3:	c4 c1 7a 7f 44 15 00 	vmovdqu XMMWORD PTR [r13+rdx*1+0x0],xmm0
    while (i < end) : (i += 1) {
  2102aa:	48 83 c7 01          	add    rdi,0x1
  2102ae:	48 83 c1 ff          	add    rcx,0xffffffffffffffff
  2102b2:	75 bc                	jne    210270 <benchmark.add+0x5a30>
    const end = items.len / 2;
  2102b4:	4c 89 c0             	mov    rax,r8
  2102b7:	48 d1 e8             	shr    rax,1
  2102ba:	4c 8b 54 24 38       	mov    r10,QWORD PTR [rsp+0x38]
  2102bf:	4c 8b 6c 24 30       	mov    r13,QWORD PTR [rsp+0x30]
    while (i < end) : (i += 1) {
  2102c4:	0f 84 96 01 00 00    	je     210460 <benchmark.add+0x5c20>
        swap(T, &items[i], &items[items.len - i - 1]);
  2102ca:	4c 89 c1             	mov    rcx,r8
    const tmp = a.*;
  2102cd:	c4 c1 78 10 01       	vmovups xmm0,XMMWORD PTR [r9]
  2102d2:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  2102d7:	48 c1 e1 04          	shl    rcx,0x4
    a.* = b.*;
  2102db:	c4 c1 78 10 44 09 f0 	vmovups xmm0,XMMWORD PTR [r9+rcx*1-0x10]
  2102e2:	c4 c1 78 11 01       	vmovups XMMWORD PTR [r9],xmm0
    b.* = tmp;
  2102e7:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  2102ec:	c4 c1 7a 7f 44 09 f0 	vmovdqu XMMWORD PTR [r9+rcx*1-0x10],xmm0
    while (i < end) : (i += 1) {
  2102f3:	48 83 f8 01          	cmp    rax,0x1
  2102f7:	0f 84 63 01 00 00    	je     210460 <benchmark.add+0x5c20>
        swap(T, &items[i], &items[items.len - i - 1]);
  2102fd:	48 8d 70 ff          	lea    rsi,[rax-0x1]
  210301:	48 83 c0 fe          	add    rax,0xfffffffffffffffe
  210305:	89 f3                	mov    ebx,esi
  210307:	83 e3 03             	and    ebx,0x3
  21030a:	48 83 f8 03          	cmp    rax,0x3
  21030e:	73 13                	jae    210323 <benchmark.add+0x5ae3>
  210310:	b8 01 00 00 00       	mov    eax,0x1
    while (i < end) : (i += 1) {
  210315:	48 85 db             	test   rbx,rbx
  210318:	0f 85 f7 00 00 00    	jne    210415 <benchmark.add+0x5bd5>
  21031e:	e9 3d 01 00 00       	jmp    210460 <benchmark.add+0x5c20>
        swap(T, &items[i], &items[items.len - i - 1]);
  210323:	48 29 de             	sub    rsi,rbx
  210326:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
  21032b:	49 8d 0c 03          	lea    rcx,[r11+rax*1]
  21032f:	48 83 c1 40          	add    rcx,0x40
  210333:	b8 01 00 00 00       	mov    eax,0x1
  210338:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  21033f:	00 
  210340:	48 89 c2             	mov    rdx,rax
  210343:	48 f7 d2             	not    rdx
  210346:	4c 01 c2             	add    rdx,r8
  210349:	48 c1 e2 04          	shl    rdx,0x4
    const tmp = a.*;
  21034d:	c5 f8 10 41 d0       	vmovups xmm0,XMMWORD PTR [rcx-0x30]
  210352:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  210357:	c4 c1 78 10 04 11    	vmovups xmm0,XMMWORD PTR [r9+rdx*1]
  21035d:	c5 f8 11 41 d0       	vmovups XMMWORD PTR [rcx-0x30],xmm0
    b.* = tmp;
  210362:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  210367:	c4 c1 78 11 04 11    	vmovups XMMWORD PTR [r9+rdx*1],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  21036d:	48 c7 c2 fe ff ff ff 	mov    rdx,0xfffffffffffffffe
  210374:	48 29 c2             	sub    rdx,rax
  210377:	4c 01 c2             	add    rdx,r8
    const tmp = a.*;
  21037a:	c5 f8 10 41 e0       	vmovups xmm0,XMMWORD PTR [rcx-0x20]
  21037f:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  210384:	48 c1 e2 04          	shl    rdx,0x4
    a.* = b.*;
  210388:	c4 c1 78 10 04 11    	vmovups xmm0,XMMWORD PTR [r9+rdx*1]
  21038e:	c5 f8 11 41 e0       	vmovups XMMWORD PTR [rcx-0x20],xmm0
    b.* = tmp;
  210393:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  210398:	c4 c1 78 11 04 11    	vmovups XMMWORD PTR [r9+rdx*1],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  21039e:	48 c7 c2 fd ff ff ff 	mov    rdx,0xfffffffffffffffd
  2103a5:	48 29 c2             	sub    rdx,rax
  2103a8:	4c 01 c2             	add    rdx,r8
  2103ab:	48 c1 e2 04          	shl    rdx,0x4
    const tmp = a.*;
  2103af:	c5 f8 10 41 f0       	vmovups xmm0,XMMWORD PTR [rcx-0x10]
  2103b4:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  2103b9:	c4 c1 78 10 04 11    	vmovups xmm0,XMMWORD PTR [r9+rdx*1]
  2103bf:	c5 f8 11 41 f0       	vmovups XMMWORD PTR [rcx-0x10],xmm0
    b.* = tmp;
  2103c4:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  2103c9:	c4 c1 78 11 04 11    	vmovups XMMWORD PTR [r9+rdx*1],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  2103cf:	48 c7 c2 fc ff ff ff 	mov    rdx,0xfffffffffffffffc
  2103d6:	48 29 c2             	sub    rdx,rax
  2103d9:	4c 01 c2             	add    rdx,r8
    const tmp = a.*;
  2103dc:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  2103e0:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  2103e5:	48 c1 e2 04          	shl    rdx,0x4
    a.* = b.*;
  2103e9:	c4 c1 78 10 04 11    	vmovups xmm0,XMMWORD PTR [r9+rdx*1]
  2103ef:	c5 f8 11 01          	vmovups XMMWORD PTR [rcx],xmm0
    b.* = tmp;
  2103f3:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  2103f8:	c4 c1 7a 7f 04 11    	vmovdqu XMMWORD PTR [r9+rdx*1],xmm0
    while (i < end) : (i += 1) {
  2103fe:	48 83 c0 04          	add    rax,0x4
  210402:	48 83 c1 40          	add    rcx,0x40
  210406:	48 83 c6 fc          	add    rsi,0xfffffffffffffffc
  21040a:	0f 85 30 ff ff ff    	jne    210340 <benchmark.add+0x5b00>
  210410:	48 85 db             	test   rbx,rbx
  210413:	74 4b                	je     210460 <benchmark.add+0x5c20>
  210415:	49 01 c4             	add    r12,rax
  210418:	49 c1 e4 04          	shl    r12,0x4
  21041c:	4d 01 e3             	add    r11,r12
  21041f:	90                   	nop
        swap(T, &items[i], &items[items.len - i - 1]);
  210420:	48 89 c1             	mov    rcx,rax
  210423:	48 f7 d1             	not    rcx
  210426:	4c 01 c1             	add    rcx,r8
    const tmp = a.*;
  210429:	c4 c1 78 10 03       	vmovups xmm0,XMMWORD PTR [r11]
  21042e:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  210433:	48 c1 e1 04          	shl    rcx,0x4
    a.* = b.*;
  210437:	c4 c1 78 10 04 09    	vmovups xmm0,XMMWORD PTR [r9+rcx*1]
  21043d:	c4 c1 78 11 03       	vmovups XMMWORD PTR [r11],xmm0
    b.* = tmp;
  210442:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  210447:	c4 c1 7a 7f 04 09    	vmovdqu XMMWORD PTR [r9+rcx*1],xmm0
    while (i < end) : (i += 1) {
  21044d:	48 83 c0 01          	add    rax,0x1
  210451:	49 83 c3 10          	add    r11,0x10
  210455:	48 83 c3 ff          	add    rbx,0xffffffffffffffff
  210459:	75 c5                	jne    210420 <benchmark.add+0x5be0>
  21045b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  210460:	48 8b 7c 24 18       	mov    rdi,QWORD PTR [rsp+0x18]
  210465:	48 83 c7 01          	add    rdi,0x1
                                lastA = Range.init(blockA.start - B_remaining, blockA.start - B_remaining + block_size);
  210469:	4d 29 ef             	sub    r15,r13
  21046c:	4c 89 bc 24 b0 01 00 	mov    QWORD PTR [rsp+0x1b0],r15
  210473:	00 
  210474:	4c 8b 5c 24 28       	mov    r11,QWORD PTR [rsp+0x28]
  210479:	4f 8d 2c 1f          	lea    r13,[r15+r11*1]
  21047d:	4c 89 ac 24 b8 01 00 	mov    QWORD PTR [rsp+0x1b8],r13
  210484:	00 
  210485:	48 8b 4c 24 20       	mov    rcx,QWORD PTR [rsp+0x20]
  21048a:	48 89 ce             	mov    rsi,rcx
                                if (blockA.length() == 0) break;
  21048d:	49 39 ca             	cmp    r10,rcx
  210490:	48 8b 5c 24 40       	mov    rbx,QWORD PTR [rsp+0x40]
  210495:	4c 8b a4 24 00 01 00 	mov    r12,QWORD PTR [rsp+0x100]
  21049c:	00 
  21049d:	0f 85 5d ee ff ff    	jne    20f300 <benchmark.add+0x4ac0>
  2104a3:	e9 2c 06 00 00       	jmp    210ad4 <benchmark.add+0x6294>
        return self.end - self.start;
  2104a8:	49 89 da             	mov    r10,rbx
  2104ab:	4d 29 e2             	sub    r10,r12
                            } else if (blockB.length() < block_size) {
  2104ae:	4d 39 f2             	cmp    r10,r14
  2104b1:	0f 87 b3 04 00 00    	ja     21096a <benchmark.add+0x612a>
                                mem.rotate(T, items[blockA.start..blockB.end], blockB.start - blockA.start);
  2104b7:	4c 8b 44 24 48       	mov    r8,QWORD PTR [rsp+0x48]
  2104bc:	4d 89 fd             	mov    r13,r15
  2104bf:	49 c1 e5 04          	shl    r13,0x4
  2104c3:	4d 01 c5             	add    r13,r8
  2104c6:	49 89 d9             	mov    r9,rbx
  2104c9:	4d 29 f9             	sub    r9,r15
  2104cc:	4d 89 e6             	mov    r14,r12
  2104cf:	4d 29 fe             	sub    r14,r15
    const end = items.len / 2;
  2104d2:	4d 89 f4             	mov    r12,r14
  2104d5:	49 d1 ec             	shr    r12,1
    while (i < end) : (i += 1) {
  2104d8:	0f 84 86 01 00 00    	je     210664 <benchmark.add+0x5e24>
        swap(T, &items[i], &items[items.len - i - 1]);
  2104de:	49 8d 54 24 ff       	lea    rdx,[r12-0x1]
  2104e3:	45 89 e3             	mov    r11d,r12d
  2104e6:	41 83 e3 03          	and    r11d,0x3
  2104ea:	48 83 fa 03          	cmp    rdx,0x3
  2104ee:	73 10                	jae    210500 <benchmark.add+0x5cc0>
  2104f0:	31 db                	xor    ebx,ebx
    while (i < end) : (i += 1) {
  2104f2:	4d 85 db             	test   r11,r11
  2104f5:	0f 85 25 01 00 00    	jne    210620 <benchmark.add+0x5de0>
  2104fb:	e9 64 01 00 00       	jmp    210664 <benchmark.add+0x5e24>
        swap(T, &items[i], &items[items.len - i - 1]);
  210500:	4d 29 dc             	sub    r12,r11
  210503:	31 db                	xor    ebx,ebx
  210505:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21050c:	00 00 00 00 
  210510:	48 89 de             	mov    rsi,rbx
  210513:	48 c1 e6 04          	shl    rsi,0x4
  210517:	48 89 da             	mov    rdx,rbx
  21051a:	48 f7 d2             	not    rdx
  21051d:	4c 01 f2             	add    rdx,r14
    const tmp = a.*;
  210520:	c4 c1 78 10 44 35 00 	vmovups xmm0,XMMWORD PTR [r13+rsi*1+0x0]
  210527:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  21052c:	48 c1 e2 04          	shl    rdx,0x4
    a.* = b.*;
  210530:	c4 c1 78 10 44 15 00 	vmovups xmm0,XMMWORD PTR [r13+rdx*1+0x0]
  210537:	c4 c1 78 11 44 35 00 	vmovups XMMWORD PTR [r13+rsi*1+0x0],xmm0
    b.* = tmp;
  21053e:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
        swap(T, &items[i], &items[items.len - i - 1]);
  210543:	48 89 f7             	mov    rdi,rsi
  210546:	48 83 cf 10          	or     rdi,0x10
  21054a:	48 c7 c0 fe ff ff ff 	mov    rax,0xfffffffffffffffe
  210551:	48 29 d8             	sub    rax,rbx
  210554:	4c 01 f0             	add    rax,r14
  210557:	48 c1 e0 04          	shl    rax,0x4
    b.* = tmp;
  21055b:	c4 c1 78 11 44 15 00 	vmovups XMMWORD PTR [r13+rdx*1+0x0],xmm0
    const tmp = a.*;
  210562:	c4 c1 78 10 44 3d 00 	vmovups xmm0,XMMWORD PTR [r13+rdi*1+0x0]
  210569:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21056e:	c4 c1 78 10 44 05 00 	vmovups xmm0,XMMWORD PTR [r13+rax*1+0x0]
  210575:	c4 c1 78 11 44 3d 00 	vmovups XMMWORD PTR [r13+rdi*1+0x0],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  21057c:	48 89 f2             	mov    rdx,rsi
  21057f:	48 83 ca 20          	or     rdx,0x20
    b.* = tmp;
  210583:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
        swap(T, &items[i], &items[items.len - i - 1]);
  210588:	48 c7 c7 fd ff ff ff 	mov    rdi,0xfffffffffffffffd
  21058f:	48 29 df             	sub    rdi,rbx
    b.* = tmp;
  210592:	c4 c1 78 11 44 05 00 	vmovups XMMWORD PTR [r13+rax*1+0x0],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  210599:	4c 01 f7             	add    rdi,r14
    const tmp = a.*;
  21059c:	c4 c1 78 10 44 15 00 	vmovups xmm0,XMMWORD PTR [r13+rdx*1+0x0]
  2105a3:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  2105a8:	48 c1 e7 04          	shl    rdi,0x4
    a.* = b.*;
  2105ac:	c4 c1 78 10 44 3d 00 	vmovups xmm0,XMMWORD PTR [r13+rdi*1+0x0]
  2105b3:	c4 c1 78 11 44 15 00 	vmovups XMMWORD PTR [r13+rdx*1+0x0],xmm0
    b.* = tmp;
  2105ba:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
        swap(T, &items[i], &items[items.len - i - 1]);
  2105bf:	48 83 ce 30          	or     rsi,0x30
  2105c3:	48 c7 c0 fc ff ff ff 	mov    rax,0xfffffffffffffffc
  2105ca:	48 29 d8             	sub    rax,rbx
  2105cd:	4c 01 f0             	add    rax,r14
    b.* = tmp;
  2105d0:	c4 c1 78 11 44 3d 00 	vmovups XMMWORD PTR [r13+rdi*1+0x0],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  2105d7:	48 c1 e0 04          	shl    rax,0x4
    const tmp = a.*;
  2105db:	c4 c1 78 10 44 35 00 	vmovups xmm0,XMMWORD PTR [r13+rsi*1+0x0]
  2105e2:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  2105e7:	c4 c1 78 10 44 05 00 	vmovups xmm0,XMMWORD PTR [r13+rax*1+0x0]
  2105ee:	c4 c1 78 11 44 35 00 	vmovups XMMWORD PTR [r13+rsi*1+0x0],xmm0
    b.* = tmp;
  2105f5:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
    while (i < end) : (i += 1) {
  2105fa:	48 83 c3 04          	add    rbx,0x4
  2105fe:	49 83 c4 fc          	add    r12,0xfffffffffffffffc
    b.* = tmp;
  210602:	c4 c1 7a 7f 44 05 00 	vmovdqu XMMWORD PTR [r13+rax*1+0x0],xmm0
    while (i < end) : (i += 1) {
  210609:	0f 85 01 ff ff ff    	jne    210510 <benchmark.add+0x5cd0>
  21060f:	4d 85 db             	test   r11,r11
  210612:	74 50                	je     210664 <benchmark.add+0x5e24>
  210614:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21061b:	00 00 00 00 00 
        swap(T, &items[i], &items[items.len - i - 1]);
  210620:	48 89 d8             	mov    rax,rbx
  210623:	48 c1 e0 04          	shl    rax,0x4
  210627:	48 89 da             	mov    rdx,rbx
  21062a:	48 f7 d2             	not    rdx
  21062d:	4c 01 f2             	add    rdx,r14
  210630:	48 c1 e2 04          	shl    rdx,0x4
    const tmp = a.*;
  210634:	c4 c1 78 10 44 05 00 	vmovups xmm0,XMMWORD PTR [r13+rax*1+0x0]
  21063b:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  210640:	c4 c1 78 10 44 15 00 	vmovups xmm0,XMMWORD PTR [r13+rdx*1+0x0]
  210647:	c4 c1 78 11 44 05 00 	vmovups XMMWORD PTR [r13+rax*1+0x0],xmm0
    b.* = tmp;
  21064e:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  210653:	c4 c1 7a 7f 44 15 00 	vmovdqu XMMWORD PTR [r13+rdx*1+0x0],xmm0
    while (i < end) : (i += 1) {
  21065a:	48 83 c3 01          	add    rbx,0x1
  21065e:	49 83 c3 ff          	add    r11,0xffffffffffffffff
  210662:	75 bc                	jne    210620 <benchmark.add+0x5de0>
    reverse(T, items[amount..]);
  210664:	4d 89 cb             	mov    r11,r9
  210667:	4d 29 f3             	sub    r11,r14
    const end = items.len / 2;
  21066a:	4d 89 dc             	mov    r12,r11
  21066d:	49 d1 ec             	shr    r12,1
    while (i < end) : (i += 1) {
  210670:	0f 84 66 01 00 00    	je     2107dc <benchmark.add+0x5f9c>
  210676:	48 8b 9c 24 00 01 00 	mov    rbx,QWORD PTR [rsp+0x100]
  21067d:	00 
  21067e:	48 c1 e3 04          	shl    rbx,0x4
  210682:	4c 01 c3             	add    rbx,r8
        swap(T, &items[i], &items[items.len - i - 1]);
  210685:	49 8d 44 24 ff       	lea    rax,[r12-0x1]
  21068a:	45 89 e6             	mov    r14d,r12d
  21068d:	41 83 e6 03          	and    r14d,0x3
  210691:	48 83 f8 03          	cmp    rax,0x3
  210695:	73 10                	jae    2106a7 <benchmark.add+0x5e67>
  210697:	31 d2                	xor    edx,edx
    while (i < end) : (i += 1) {
  210699:	4d 85 f6             	test   r14,r14
  21069c:	0f 85 fe 00 00 00    	jne    2107a0 <benchmark.add+0x5f60>
  2106a2:	e9 35 01 00 00       	jmp    2107dc <benchmark.add+0x5f9c>
        swap(T, &items[i], &items[items.len - i - 1]);
  2106a7:	4d 29 f4             	sub    r12,r14
  2106aa:	31 d2                	xor    edx,edx
  2106ac:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  2106b0:	48 89 d0             	mov    rax,rdx
  2106b3:	48 c1 e0 04          	shl    rax,0x4
  2106b7:	48 89 d6             	mov    rsi,rdx
  2106ba:	48 f7 d6             	not    rsi
  2106bd:	4c 01 de             	add    rsi,r11
    const tmp = a.*;
  2106c0:	c5 f8 10 04 03       	vmovups xmm0,XMMWORD PTR [rbx+rax*1]
  2106c5:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  2106ca:	48 c1 e6 04          	shl    rsi,0x4
    a.* = b.*;
  2106ce:	c5 f8 10 04 33       	vmovups xmm0,XMMWORD PTR [rbx+rsi*1]
  2106d3:	c5 f8 11 04 03       	vmovups XMMWORD PTR [rbx+rax*1],xmm0
    b.* = tmp;
  2106d8:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
        swap(T, &items[i], &items[items.len - i - 1]);
  2106dd:	48 89 c7             	mov    rdi,rax
  2106e0:	48 83 cf 10          	or     rdi,0x10
  2106e4:	48 c7 c1 fe ff ff ff 	mov    rcx,0xfffffffffffffffe
  2106eb:	48 29 d1             	sub    rcx,rdx
  2106ee:	4c 01 d9             	add    rcx,r11
  2106f1:	48 c1 e1 04          	shl    rcx,0x4
    b.* = tmp;
  2106f5:	c5 f8 11 04 33       	vmovups XMMWORD PTR [rbx+rsi*1],xmm0
    const tmp = a.*;
  2106fa:	c5 f8 10 04 3b       	vmovups xmm0,XMMWORD PTR [rbx+rdi*1]
  2106ff:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  210704:	c5 f8 10 04 0b       	vmovups xmm0,XMMWORD PTR [rbx+rcx*1]
  210709:	c5 f8 11 04 3b       	vmovups XMMWORD PTR [rbx+rdi*1],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  21070e:	48 89 c6             	mov    rsi,rax
  210711:	48 83 ce 20          	or     rsi,0x20
    b.* = tmp;
  210715:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
        swap(T, &items[i], &items[items.len - i - 1]);
  21071a:	48 c7 c7 fd ff ff ff 	mov    rdi,0xfffffffffffffffd
  210721:	48 29 d7             	sub    rdi,rdx
    b.* = tmp;
  210724:	c5 f8 11 04 0b       	vmovups XMMWORD PTR [rbx+rcx*1],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  210729:	4c 01 df             	add    rdi,r11
    const tmp = a.*;
  21072c:	c5 f8 10 04 33       	vmovups xmm0,XMMWORD PTR [rbx+rsi*1]
  210731:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  210736:	48 c1 e7 04          	shl    rdi,0x4
    a.* = b.*;
  21073a:	c5 f8 10 04 3b       	vmovups xmm0,XMMWORD PTR [rbx+rdi*1]
  21073f:	c5 f8 11 04 33       	vmovups XMMWORD PTR [rbx+rsi*1],xmm0
    b.* = tmp;
  210744:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
        swap(T, &items[i], &items[items.len - i - 1]);
  210749:	48 83 c8 30          	or     rax,0x30
  21074d:	48 c7 c1 fc ff ff ff 	mov    rcx,0xfffffffffffffffc
  210754:	48 29 d1             	sub    rcx,rdx
  210757:	4c 01 d9             	add    rcx,r11
    b.* = tmp;
  21075a:	c5 f8 11 04 3b       	vmovups XMMWORD PTR [rbx+rdi*1],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  21075f:	48 c1 e1 04          	shl    rcx,0x4
    const tmp = a.*;
  210763:	c5 f8 10 04 03       	vmovups xmm0,XMMWORD PTR [rbx+rax*1]
  210768:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21076d:	c5 f8 10 04 0b       	vmovups xmm0,XMMWORD PTR [rbx+rcx*1]
  210772:	c5 f8 11 04 03       	vmovups XMMWORD PTR [rbx+rax*1],xmm0
    b.* = tmp;
  210777:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
    while (i < end) : (i += 1) {
  21077c:	48 83 c2 04          	add    rdx,0x4
  210780:	49 83 c4 fc          	add    r12,0xfffffffffffffffc
    b.* = tmp;
  210784:	c5 fa 7f 04 0b       	vmovdqu XMMWORD PTR [rbx+rcx*1],xmm0
    while (i < end) : (i += 1) {
  210789:	0f 85 21 ff ff ff    	jne    2106b0 <benchmark.add+0x5e70>
  21078f:	4d 85 f6             	test   r14,r14
  210792:	74 48                	je     2107dc <benchmark.add+0x5f9c>
  210794:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21079b:	00 00 00 00 00 
        swap(T, &items[i], &items[items.len - i - 1]);
  2107a0:	48 89 d0             	mov    rax,rdx
  2107a3:	48 c1 e0 04          	shl    rax,0x4
  2107a7:	48 89 d1             	mov    rcx,rdx
  2107aa:	48 f7 d1             	not    rcx
  2107ad:	4c 01 d9             	add    rcx,r11
  2107b0:	48 c1 e1 04          	shl    rcx,0x4
    const tmp = a.*;
  2107b4:	c5 f8 10 04 03       	vmovups xmm0,XMMWORD PTR [rbx+rax*1]
  2107b9:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  2107be:	c5 f8 10 04 0b       	vmovups xmm0,XMMWORD PTR [rbx+rcx*1]
  2107c3:	c5 f8 11 04 03       	vmovups XMMWORD PTR [rbx+rax*1],xmm0
    b.* = tmp;
  2107c8:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  2107cd:	c5 fa 7f 04 0b       	vmovdqu XMMWORD PTR [rbx+rcx*1],xmm0
    while (i < end) : (i += 1) {
  2107d2:	48 83 c2 01          	add    rdx,0x1
  2107d6:	49 83 c6 ff          	add    r14,0xffffffffffffffff
  2107da:	75 c4                	jne    2107a0 <benchmark.add+0x5f60>
    const end = items.len / 2;
  2107dc:	4c 89 c8             	mov    rax,r9
  2107df:	48 d1 e8             	shr    rax,1
  2107e2:	4c 8b 74 24 78       	mov    r14,QWORD PTR [rsp+0x78]
  2107e7:	4c 8b 5c 24 28       	mov    r11,QWORD PTR [rsp+0x28]
  2107ec:	4c 8b a4 24 00 01 00 	mov    r12,QWORD PTR [rsp+0x100]
  2107f3:	00 
    while (i < end) : (i += 1) {
  2107f4:	0f 84 bc ea ff ff    	je     20f2b6 <benchmark.add+0x4a76>
    const tmp = a.*;
  2107fa:	c4 c1 78 10 45 00    	vmovups xmm0,XMMWORD PTR [r13+0x0]
  210800:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  210805:	49 c1 e1 04          	shl    r9,0x4
    a.* = b.*;
  210809:	c4 81 78 10 44 0d f0 	vmovups xmm0,XMMWORD PTR [r13+r9*1-0x10]
  210810:	c4 c1 78 11 45 00    	vmovups XMMWORD PTR [r13+0x0],xmm0
    b.* = tmp;
  210816:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  21081b:	c4 81 7a 7f 44 0d f0 	vmovdqu XMMWORD PTR [r13+r9*1-0x10],xmm0
    while (i < end) : (i += 1) {
  210822:	48 83 f8 01          	cmp    rax,0x1
  210826:	0f 84 8a ea ff ff    	je     20f2b6 <benchmark.add+0x4a76>
        swap(T, &items[i], &items[items.len - i - 1]);
  21082c:	48 8d 70 ff          	lea    rsi,[rax-0x1]
  210830:	48 83 c0 fe          	add    rax,0xfffffffffffffffe
  210834:	89 f2                	mov    edx,esi
  210836:	83 e2 03             	and    edx,0x3
  210839:	48 83 f8 03          	cmp    rax,0x3
  21083d:	73 13                	jae    210852 <benchmark.add+0x6012>
  21083f:	b8 01 00 00 00       	mov    eax,0x1
    while (i < end) : (i += 1) {
  210844:	48 85 d2             	test   rdx,rdx
  210847:	0f 85 cb 00 00 00    	jne    210918 <benchmark.add+0x60d8>
  21084d:	e9 64 ea ff ff       	jmp    20f2b6 <benchmark.add+0x4a76>
        swap(T, &items[i], &items[items.len - i - 1]);
  210852:	48 29 d6             	sub    rsi,rdx
  210855:	48 8b 44 24 40       	mov    rax,QWORD PTR [rsp+0x40]
  21085a:	48 c1 e0 04          	shl    rax,0x4
  21085e:	49 8d 3c 00          	lea    rdi,[r8+rax*1]
  210862:	48 83 c7 e0          	add    rdi,0xffffffffffffffe0
  210866:	b8 01 00 00 00       	mov    eax,0x1
  21086b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  210870:	48 89 c1             	mov    rcx,rax
  210873:	48 c1 e1 04          	shl    rcx,0x4
    const tmp = a.*;
  210877:	c4 c1 78 10 44 0d 00 	vmovups xmm0,XMMWORD PTR [r13+rcx*1+0x0]
  21087e:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  210883:	c5 f8 10 07          	vmovups xmm0,XMMWORD PTR [rdi]
  210887:	c4 c1 78 11 44 0d 00 	vmovups XMMWORD PTR [r13+rcx*1+0x0],xmm0
    b.* = tmp;
  21088e:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  210893:	c5 f8 11 07          	vmovups XMMWORD PTR [rdi],xmm0
    const tmp = a.*;
  210897:	c4 c1 78 10 44 0d 10 	vmovups xmm0,XMMWORD PTR [r13+rcx*1+0x10]
  21089e:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  2108a3:	c5 f8 10 47 f0       	vmovups xmm0,XMMWORD PTR [rdi-0x10]
  2108a8:	c4 c1 78 11 44 0d 10 	vmovups XMMWORD PTR [r13+rcx*1+0x10],xmm0
    b.* = tmp;
  2108af:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  2108b4:	c5 f8 11 47 f0       	vmovups XMMWORD PTR [rdi-0x10],xmm0
    const tmp = a.*;
  2108b9:	c4 c1 78 10 44 0d 20 	vmovups xmm0,XMMWORD PTR [r13+rcx*1+0x20]
  2108c0:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  2108c5:	c5 f8 10 47 e0       	vmovups xmm0,XMMWORD PTR [rdi-0x20]
  2108ca:	c4 c1 78 11 44 0d 20 	vmovups XMMWORD PTR [r13+rcx*1+0x20],xmm0
    b.* = tmp;
  2108d1:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  2108d6:	c5 f8 11 47 e0       	vmovups XMMWORD PTR [rdi-0x20],xmm0
    const tmp = a.*;
  2108db:	c4 c1 78 10 44 0d 30 	vmovups xmm0,XMMWORD PTR [r13+rcx*1+0x30]
  2108e2:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  2108e7:	c5 f8 10 47 d0       	vmovups xmm0,XMMWORD PTR [rdi-0x30]
  2108ec:	c4 c1 78 11 44 0d 30 	vmovups XMMWORD PTR [r13+rcx*1+0x30],xmm0
    b.* = tmp;
  2108f3:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  2108f8:	c5 fa 7f 47 d0       	vmovdqu XMMWORD PTR [rdi-0x30],xmm0
    while (i < end) : (i += 1) {
  2108fd:	48 83 c0 04          	add    rax,0x4
  210901:	48 83 c7 c0          	add    rdi,0xffffffffffffffc0
  210905:	48 83 c6 fc          	add    rsi,0xfffffffffffffffc
  210909:	0f 85 61 ff ff ff    	jne    210870 <benchmark.add+0x6030>
  21090f:	48 85 d2             	test   rdx,rdx
  210912:	0f 84 9e e9 ff ff    	je     20f2b6 <benchmark.add+0x4a76>
  210918:	48 8b 4c 24 40       	mov    rcx,QWORD PTR [rsp+0x40]
  21091d:	48 29 c1             	sub    rcx,rax
  210920:	48 c1 e1 04          	shl    rcx,0x4
  210924:	49 8d 34 08          	lea    rsi,[r8+rcx*1]
  210928:	48 83 c6 f0          	add    rsi,0xfffffffffffffff0
  21092c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
        swap(T, &items[i], &items[items.len - i - 1]);
  210930:	48 89 c1             	mov    rcx,rax
  210933:	48 c1 e1 04          	shl    rcx,0x4
    const tmp = a.*;
  210937:	c4 c1 78 10 44 0d 00 	vmovups xmm0,XMMWORD PTR [r13+rcx*1+0x0]
  21093e:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  210943:	c5 f8 10 06          	vmovups xmm0,XMMWORD PTR [rsi]
  210947:	c4 c1 78 11 44 0d 00 	vmovups XMMWORD PTR [r13+rcx*1+0x0],xmm0
    b.* = tmp;
  21094e:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  210953:	c5 fa 7f 06          	vmovdqu XMMWORD PTR [rsi],xmm0
    while (i < end) : (i += 1) {
  210957:	48 83 c0 01          	add    rax,0x1
  21095b:	48 83 c6 f0          	add    rsi,0xfffffffffffffff0
  21095f:	48 83 c2 ff          	add    rdx,0xffffffffffffffff
  210963:	75 cb                	jne    210930 <benchmark.add+0x60f0>
  210965:	e9 4c e9 ff ff       	jmp    20f2b6 <benchmark.add+0x4a76>
  21096a:	31 c0                	xor    eax,eax
  21096c:	49 83 fe 03          	cmp    r14,0x3
        mem.swap(T, &items[start1 + index], &items[start2 + index]);
  210970:	73 16                	jae    210988 <benchmark.add+0x6148>
  210972:	4c 8b 54 24 38       	mov    r10,QWORD PTR [rsp+0x38]
  210977:	48 83 7c 24 10 00    	cmp    QWORD PTR [rsp+0x10],0x0
  21097d:	0f 85 0a 01 00 00    	jne    210a8d <benchmark.add+0x624d>
  210983:	e9 02 e9 ff ff       	jmp    20f28a <benchmark.add+0x4a4a>
  210988:	4c 8b 84 24 28 01 00 	mov    r8,QWORD PTR [rsp+0x128]
  21098f:	00 
  210990:	4c 8b 54 24 38       	mov    r10,QWORD PTR [rsp+0x38]
  210995:	4a 8d 14 38          	lea    rdx,[rax+r15*1]
  210999:	48 8b 74 24 48       	mov    rsi,QWORD PTR [rsp+0x48]
  21099e:	48 c1 e2 04          	shl    rdx,0x4
  2109a2:	4a 8d 0c 20          	lea    rcx,[rax+r12*1]
    const tmp = a.*;
  2109a6:	c5 f8 10 04 16       	vmovups xmm0,XMMWORD PTR [rsi+rdx*1]
  2109ab:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
  2109b0:	48 c1 e1 04          	shl    rcx,0x4
    a.* = b.*;
  2109b4:	c5 f8 10 04 0e       	vmovups xmm0,XMMWORD PTR [rsi+rcx*1]
  2109b9:	c5 f8 11 04 16       	vmovups XMMWORD PTR [rsi+rdx*1],xmm0
    b.* = tmp;
  2109be:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
    while (index < block_size) : (index += 1) {
  2109c3:	48 89 c2             	mov    rdx,rax
  2109c6:	c5 f8 11 04 0e       	vmovups XMMWORD PTR [rsi+rcx*1],xmm0
  2109cb:	48 83 ca 01          	or     rdx,0x1
        mem.swap(T, &items[start1 + index], &items[start2 + index]);
  2109cf:	4a 8d 34 3a          	lea    rsi,[rdx+r15*1]
  2109d3:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  2109d8:	48 c1 e6 04          	shl    rsi,0x4
  2109dc:	4c 01 e2             	add    rdx,r12
    const tmp = a.*;
  2109df:	c5 f8 10 04 31       	vmovups xmm0,XMMWORD PTR [rcx+rsi*1]
  2109e4:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
  2109e9:	48 c1 e2 04          	shl    rdx,0x4
    a.* = b.*;
  2109ed:	c5 f8 10 04 11       	vmovups xmm0,XMMWORD PTR [rcx+rdx*1]
  2109f2:	c5 f8 11 04 31       	vmovups XMMWORD PTR [rcx+rsi*1],xmm0
    b.* = tmp;
  2109f7:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
    while (index < block_size) : (index += 1) {
  2109fc:	48 89 c6             	mov    rsi,rax
  2109ff:	c5 f8 11 04 11       	vmovups XMMWORD PTR [rcx+rdx*1],xmm0
  210a04:	48 83 ce 02          	or     rsi,0x2
        mem.swap(T, &items[start1 + index], &items[start2 + index]);
  210a08:	4a 8d 14 3e          	lea    rdx,[rsi+r15*1]
  210a0c:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  210a11:	48 c1 e2 04          	shl    rdx,0x4
  210a15:	4c 01 e6             	add    rsi,r12
    const tmp = a.*;
  210a18:	c5 f8 10 04 11       	vmovups xmm0,XMMWORD PTR [rcx+rdx*1]
  210a1d:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
  210a22:	48 c1 e6 04          	shl    rsi,0x4
    a.* = b.*;
  210a26:	c5 f8 10 04 31       	vmovups xmm0,XMMWORD PTR [rcx+rsi*1]
  210a2b:	c5 f8 11 04 11       	vmovups XMMWORD PTR [rcx+rdx*1],xmm0
    b.* = tmp;
  210a30:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
    while (index < block_size) : (index += 1) {
  210a35:	48 89 c2             	mov    rdx,rax
  210a38:	48 83 ca 03          	or     rdx,0x3
  210a3c:	c5 f8 11 04 31       	vmovups XMMWORD PTR [rcx+rsi*1],xmm0
        mem.swap(T, &items[start1 + index], &items[start2 + index]);
  210a41:	4a 8d 34 3a          	lea    rsi,[rdx+r15*1]
  210a45:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  210a4a:	48 c1 e6 04          	shl    rsi,0x4
  210a4e:	4c 01 e2             	add    rdx,r12
  210a51:	48 c1 e2 04          	shl    rdx,0x4
    const tmp = a.*;
  210a55:	c5 f8 10 04 31       	vmovups xmm0,XMMWORD PTR [rcx+rsi*1]
  210a5a:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  210a5f:	c5 f8 10 04 11       	vmovups xmm0,XMMWORD PTR [rcx+rdx*1]
  210a64:	c5 f8 11 04 31       	vmovups XMMWORD PTR [rcx+rsi*1],xmm0
    b.* = tmp;
  210a69:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
    while (index < block_size) : (index += 1) {
  210a6e:	48 83 c0 04          	add    rax,0x4
  210a72:	49 83 c0 fc          	add    r8,0xfffffffffffffffc
  210a76:	c5 fa 7f 04 11       	vmovdqu XMMWORD PTR [rcx+rdx*1],xmm0
  210a7b:	0f 85 14 ff ff ff    	jne    210995 <benchmark.add+0x6155>
  210a81:	48 83 7c 24 10 00    	cmp    QWORD PTR [rsp+0x10],0x0
  210a87:	0f 84 fd e7 ff ff    	je     20f28a <benchmark.add+0x4a4a>
  210a8d:	4c 8b 44 24 10       	mov    r8,QWORD PTR [rsp+0x10]
        mem.swap(T, &items[start1 + index], &items[start2 + index]);
  210a92:	4a 8d 14 38          	lea    rdx,[rax+r15*1]
  210a96:	48 8b 74 24 48       	mov    rsi,QWORD PTR [rsp+0x48]
  210a9b:	48 c1 e2 04          	shl    rdx,0x4
  210a9f:	4a 8d 0c 20          	lea    rcx,[rax+r12*1]
  210aa3:	48 c1 e1 04          	shl    rcx,0x4
    const tmp = a.*;
  210aa7:	c5 f8 10 04 16       	vmovups xmm0,XMMWORD PTR [rsi+rdx*1]
  210aac:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  210ab1:	c5 f8 10 04 0e       	vmovups xmm0,XMMWORD PTR [rsi+rcx*1]
  210ab6:	c5 f8 11 04 16       	vmovups XMMWORD PTR [rsi+rdx*1],xmm0
    b.* = tmp;
  210abb:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  210ac0:	c5 fa 7f 04 0e       	vmovdqu XMMWORD PTR [rsi+rcx*1],xmm0
    while (index < block_size) : (index += 1) {
  210ac5:	48 83 c0 01          	add    rax,0x1
  210ac9:	49 83 c0 ff          	add    r8,0xffffffffffffffff
  210acd:	75 c3                	jne    210a92 <benchmark.add+0x6252>
  210acf:	e9 b6 e7 ff ff       	jmp    20f28a <benchmark.add+0x4a4a>
        return self.end - self.start;
  210ad4:	4c 89 df             	mov    rdi,r11
  210ad7:	4c 8b 84 24 e8 00 00 	mov    r8,QWORD PTR [rsp+0xe8]
  210ade:	00 
                    if (lastA.length() <= cache.len) {
  210adf:	48 81 ff 00 02 00 00 	cmp    rdi,0x200
  210ae6:	0f 86 6b e5 ff ff    	jbe    20f057 <benchmark.add+0x4817>
  210aec:	48 8b 44 24 58       	mov    rax,QWORD PTR [rsp+0x58]
  210af1:	48 39 84 24 d0 00 00 	cmp    QWORD PTR [rsp+0xd0],rax
  210af8:	00 
                    } else if (buffer2.length() > 0) {
  210af9:	75 32                	jne    210b2d <benchmark.add+0x62ed>
        return Range{
  210afb:	4c 89 ac 24 80 02 00 	mov    QWORD PTR [rsp+0x280],r13
  210b02:	00 
  210b03:	4c 89 84 24 88 02 00 	mov    QWORD PTR [rsp+0x288],r8
  210b0a:	00 
                        mergeInPlace(T, items, lastA, Range.init(lastA.end, B.end), lessThan);
  210b0b:	48 8d 7c 24 48       	lea    rdi,[rsp+0x48]
  210b10:	48 8d b4 24 b0 01 00 	lea    rsi,[rsp+0x1b0]
  210b17:	00 
  210b18:	48 8d 94 24 80 02 00 	lea    rdx,[rsp+0x280]
  210b1f:	00 
  210b20:	c5 f8 77             	vzeroupper 
  210b23:	e8 88 58 00 00       	call   2163b0 <mergeInPlace>
  210b28:	e9 73 02 00 00       	jmp    210da0 <benchmark.add+0x6560>
    if (B.length() > 0 and A.length() > 0) {
  210b2d:	4d 29 e8             	sub    r8,r13
  210b30:	0f 84 b0 db ff ff    	je     20e6e6 <benchmark.add+0x3ea6>
  210b36:	41 ba 00 00 00 00    	mov    r10d,0x0
  210b3c:	41 be 00 00 00 00    	mov    r14d,0x0
  210b42:	4d 39 fd             	cmp    r13,r15
  210b45:	0f 84 c7 00 00 00    	je     210c12 <benchmark.add+0x63d2>
  210b4b:	45 31 d2             	xor    r10d,r10d
  210b4e:	31 f6                	xor    esi,esi
  210b50:	45 31 c9             	xor    r9d,r9d
  210b53:	49 89 fc             	mov    r12,rdi
  210b56:	48 8b 44 24 58       	mov    rax,QWORD PTR [rsp+0x58]
  210b5b:	4d 8d 1c 02          	lea    r11,[r10+rax*1]
            if (!lessThan(items[B.start + B_count], items[buffer.start + A_count])) {
  210b5f:	4a 8d 1c 2e          	lea    rbx,[rsi+r13*1]
  210b63:	48 c1 e3 04          	shl    rbx,0x4
  210b67:	4b 8d 0c 0f          	lea    rcx,[r15+r9*1]
  210b6b:	48 c1 e1 04          	shl    rcx,0x4
  210b6f:	4d 89 ce             	mov    r14,r9
  210b72:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  210b79:	1f 84 00 00 00 00 00 
  210b80:	48 8b 44 24 48       	mov    rax,QWORD PTR [rsp+0x48]
  210b85:	4c 89 da             	mov    rdx,r11
  210b88:	48 c1 e2 04          	shl    rdx,0x4
  210b8c:	48 8b 3c 18          	mov    rdi,QWORD PTR [rax+rbx*1]
  210b90:	48 3b 3c 10          	cmp    rdi,QWORD PTR [rax+rdx*1]
  210b94:	73 35                	jae    210bcb <benchmark.add+0x638b>
    const tmp = a.*;
  210b96:	c5 f8 10 04 08       	vmovups xmm0,XMMWORD PTR [rax+rcx*1]
  210b9b:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  210ba0:	c5 f8 10 04 18       	vmovups xmm0,XMMWORD PTR [rax+rbx*1]
  210ba5:	c5 f8 11 04 08       	vmovups XMMWORD PTR [rax+rcx*1],xmm0
    b.* = tmp;
  210baa:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  210baf:	c5 fa 7f 04 18       	vmovdqu XMMWORD PTR [rax+rbx*1],xmm0
                B_count += 1;
  210bb4:	48 83 c6 01          	add    rsi,0x1
                insert += 1;
  210bb8:	49 83 c6 01          	add    r14,0x1
                if (B_count >= B.length()) break;
  210bbc:	48 83 c3 10          	add    rbx,0x10
  210bc0:	48 83 c1 10          	add    rcx,0x10
  210bc4:	4c 39 c6             	cmp    rsi,r8
  210bc7:	72 b7                	jb     210b80 <benchmark.add+0x6340>
  210bc9:	eb 44                	jmp    210c0f <benchmark.add+0x63cf>
    const tmp = a.*;
  210bcb:	c5 f8 10 04 08       	vmovups xmm0,XMMWORD PTR [rax+rcx*1]
  210bd0:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
  210bd5:	48 01 c2             	add    rdx,rax
    a.* = b.*;
  210bd8:	c5 f8 10 02          	vmovups xmm0,XMMWORD PTR [rdx]
  210bdc:	c5 f8 11 04 08       	vmovups XMMWORD PTR [rax+rcx*1],xmm0
    b.* = tmp;
  210be1:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  210be6:	c5 fa 7f 02          	vmovdqu XMMWORD PTR [rdx],xmm0
                A_count += 1;
  210bea:	49 83 c2 01          	add    r10,0x1
                if (A_count >= A.length()) break;
  210bee:	4d 8d 4e 01          	lea    r9,[r14+0x1]
  210bf2:	4c 89 e7             	mov    rdi,r12
  210bf5:	49 39 fa             	cmp    r10,rdi
  210bf8:	0f 82 55 ff ff ff    	jb     210b53 <benchmark.add+0x6313>
    blockSwap(T, items, buffer.start + A_count, A.start + insert, A.length() - A_count);
  210bfe:	49 83 c6 01          	add    r14,0x1
    while (index < block_size) : (index += 1) {
  210c02:	49 89 f9             	mov    r9,rdi
  210c05:	4d 29 d1             	sub    r9,r10
  210c08:	75 14                	jne    210c1e <benchmark.add+0x63de>
  210c0a:	e9 91 01 00 00       	jmp    210da0 <benchmark.add+0x6560>
  210c0f:	4c 89 e7             	mov    rdi,r12
  210c12:	49 89 f9             	mov    r9,rdi
  210c15:	4d 29 d1             	sub    r9,r10
  210c18:	0f 84 82 01 00 00    	je     210da0 <benchmark.add+0x6560>
        mem.swap(T, &items[start1 + index], &items[start2 + index]);
  210c1e:	48 83 c7 ff          	add    rdi,0xffffffffffffffff
  210c22:	4c 29 d7             	sub    rdi,r10
  210c25:	44 89 c8             	mov    eax,r9d
  210c28:	83 e0 03             	and    eax,0x3
  210c2b:	48 83 ff 03          	cmp    rdi,0x3
  210c2f:	73 10                	jae    210c41 <benchmark.add+0x6401>
  210c31:	31 ff                	xor    edi,edi
    while (index < block_size) : (index += 1) {
  210c33:	48 85 c0             	test   rax,rax
  210c36:	0f 85 fe 00 00 00    	jne    210d3a <benchmark.add+0x64fa>
  210c3c:	e9 5f 01 00 00       	jmp    210da0 <benchmark.add+0x6560>
        mem.swap(T, &items[start1 + index], &items[start2 + index]);
  210c41:	49 29 c1             	sub    r9,rax
  210c44:	4d 89 d0             	mov    r8,r10
  210c47:	49 c1 e0 04          	shl    r8,0x4
  210c4b:	4c 03 84 24 40 01 00 	add    r8,QWORD PTR [rsp+0x140]
  210c52:	00 
  210c53:	4c 89 f2             	mov    rdx,r14
  210c56:	48 c1 e2 04          	shl    rdx,0x4
  210c5a:	4c 89 fe             	mov    rsi,r15
  210c5d:	48 c1 e6 04          	shl    rsi,0x4
  210c61:	48 01 d6             	add    rsi,rdx
  210c64:	31 db                	xor    ebx,ebx
  210c66:	31 ff                	xor    edi,edi
  210c68:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  210c6f:	00 
  210c70:	48 8b 54 24 48       	mov    rdx,QWORD PTR [rsp+0x48]
    const tmp = a.*;
  210c75:	4a 8d 0c 02          	lea    rcx,[rdx+r8*1]
  210c79:	c5 f8 10 04 0b       	vmovups xmm0,XMMWORD PTR [rbx+rcx*1]
  210c7e:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  210c83:	48 01 f2             	add    rdx,rsi
  210c86:	c5 f8 10 04 13       	vmovups xmm0,XMMWORD PTR [rbx+rdx*1]
  210c8b:	c5 f8 11 04 0b       	vmovups XMMWORD PTR [rbx+rcx*1],xmm0
    b.* = tmp;
  210c90:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  210c95:	c5 f8 11 04 13       	vmovups XMMWORD PTR [rbx+rdx*1],xmm0
  210c9a:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
    const tmp = a.*;
  210c9f:	4a 8d 14 01          	lea    rdx,[rcx+r8*1]
  210ca3:	c5 f8 10 44 13 10    	vmovups xmm0,XMMWORD PTR [rbx+rdx*1+0x10]
  210ca9:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  210cae:	48 01 f1             	add    rcx,rsi
  210cb1:	c5 f8 10 44 0b 10    	vmovups xmm0,XMMWORD PTR [rbx+rcx*1+0x10]
  210cb7:	c5 f8 11 44 13 10    	vmovups XMMWORD PTR [rbx+rdx*1+0x10],xmm0
    b.* = tmp;
  210cbd:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  210cc2:	c5 f8 11 44 0b 10    	vmovups XMMWORD PTR [rbx+rcx*1+0x10],xmm0
  210cc8:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
    const tmp = a.*;
  210ccd:	4a 8d 14 01          	lea    rdx,[rcx+r8*1]
  210cd1:	c5 f8 10 44 13 20    	vmovups xmm0,XMMWORD PTR [rbx+rdx*1+0x20]
  210cd7:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  210cdc:	48 01 f1             	add    rcx,rsi
  210cdf:	c5 f8 10 44 0b 20    	vmovups xmm0,XMMWORD PTR [rbx+rcx*1+0x20]
  210ce5:	c5 f8 11 44 13 20    	vmovups XMMWORD PTR [rbx+rdx*1+0x20],xmm0
    b.* = tmp;
  210ceb:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  210cf0:	c5 f8 11 44 0b 20    	vmovups XMMWORD PTR [rbx+rcx*1+0x20],xmm0
  210cf6:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
    const tmp = a.*;
  210cfb:	4a 8d 14 01          	lea    rdx,[rcx+r8*1]
  210cff:	c5 f8 10 44 13 30    	vmovups xmm0,XMMWORD PTR [rbx+rdx*1+0x30]
  210d05:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  210d0a:	48 01 f1             	add    rcx,rsi
  210d0d:	c5 f8 10 44 0b 30    	vmovups xmm0,XMMWORD PTR [rbx+rcx*1+0x30]
  210d13:	c5 f8 11 44 13 30    	vmovups XMMWORD PTR [rbx+rdx*1+0x30],xmm0
    b.* = tmp;
  210d19:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  210d1e:	c5 fa 7f 44 0b 30    	vmovdqu XMMWORD PTR [rbx+rcx*1+0x30],xmm0
    while (index < block_size) : (index += 1) {
  210d24:	48 83 c7 04          	add    rdi,0x4
  210d28:	48 83 c3 40          	add    rbx,0x40
  210d2c:	49 39 f9             	cmp    r9,rdi
  210d2f:	0f 85 3b ff ff ff    	jne    210c70 <benchmark.add+0x6430>
  210d35:	48 85 c0             	test   rax,rax
  210d38:	74 66                	je     210da0 <benchmark.add+0x6560>
  210d3a:	4d 01 fe             	add    r14,r15
  210d3d:	49 01 fe             	add    r14,rdi
  210d40:	49 c1 e6 04          	shl    r14,0x4
  210d44:	4c 03 54 24 58       	add    r10,QWORD PTR [rsp+0x58]
  210d49:	49 01 fa             	add    r10,rdi
  210d4c:	49 c1 e2 04          	shl    r10,0x4
  210d50:	48 f7 d8             	neg    rax
  210d53:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  210d5a:	84 00 00 00 00 00 
        mem.swap(T, &items[start1 + index], &items[start2 + index]);
  210d60:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
    const tmp = a.*;
  210d65:	c4 a1 78 10 04 11    	vmovups xmm0,XMMWORD PTR [rcx+r10*1]
  210d6b:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  210d70:	c4 a1 78 10 04 31    	vmovups xmm0,XMMWORD PTR [rcx+r14*1]
  210d76:	c4 a1 78 11 04 11    	vmovups XMMWORD PTR [rcx+r10*1],xmm0
    b.* = tmp;
  210d7c:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  210d81:	c4 a1 7a 7f 04 31    	vmovdqu XMMWORD PTR [rcx+r14*1],xmm0
    while (index < block_size) : (index += 1) {
  210d87:	49 83 c6 10          	add    r14,0x10
  210d8b:	49 83 c2 10          	add    r10,0x10
  210d8f:	48 83 c0 01          	add    rax,0x1
  210d93:	75 cb                	jne    210d60 <benchmark.add+0x6520>
  210d95:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  210d9c:	00 00 00 00 
  210da0:	48 8b 9c 24 48 01 00 	mov    rbx,QWORD PTR [rsp+0x148]
  210da7:	00 
  210da8:	48 2b 9c 24 80 01 00 	sub    rbx,QWORD PTR [rsp+0x180]
  210daf:	00 
  210db0:	48 8b 84 24 e0 00 00 	mov    rax,QWORD PTR [rsp+0xe0]
  210db7:	00 
        return self.decimal >= self.size;
  210db8:	48 3b 84 24 50 01 00 	cmp    rax,QWORD PTR [rsp+0x150]
  210dbf:	00 
            while (!iterator.finished()) {
  210dc0:	0f 82 3a d9 ff ff    	jb     20e700 <benchmark.add+0x3ec0>
        while (i < items.len) : (i += 1) {
  210dc6:	48 83 bc 24 40 02 00 	cmp    QWORD PTR [rsp+0x240],0x2
  210dcd:	00 02 
  210dcf:	0f 82 e9 01 00 00    	jb     210fbe <benchmark.add+0x677e>
  210dd5:	48 8b 44 24 48       	mov    rax,QWORD PTR [rsp+0x48]
  210dda:	48 8b b4 24 40 01 00 	mov    rsi,QWORD PTR [rsp+0x140]
  210de1:	00 
  210de2:	4c 8d 0c 30          	lea    r9,[rax+rsi*1]
  210de6:	48 8b 8c 24 d0 00 00 	mov    rcx,QWORD PTR [rsp+0xd0]
  210ded:	00 
            const x = items[i];
  210dee:	4c 8d 51 ff          	lea    r10,[rcx-0x1]
  210df2:	48 8b 54 24 58       	mov    rdx,QWORD PTR [rsp+0x58]
  210df7:	49 29 d2             	sub    r10,rdx
  210dfa:	48 83 c1 fe          	add    rcx,0xfffffffffffffffe
  210dfe:	45 89 d0             	mov    r8d,r10d
  210e01:	41 83 e0 01          	and    r8d,0x1
  210e05:	48 39 d1             	cmp    rcx,rdx
  210e08:	75 13                	jne    210e1d <benchmark.add+0x65dd>
  210e0a:	be 01 00 00 00       	mov    esi,0x1
            while (j > 0 and lessThan(x, items[j - 1])) : (j -= 1) {
  210e0f:	4d 85 c0             	test   r8,r8
  210e12:	0f 85 1f 01 00 00    	jne    210f37 <benchmark.add+0x66f7>
  210e18:	e9 a1 01 00 00       	jmp    210fbe <benchmark.add+0x677e>
            const x = items[i];
  210e1d:	4d 29 c2             	sub    r10,r8
  210e20:	4c 8d 3c 30          	lea    r15,[rax+rsi*1]
  210e24:	49 83 c7 10          	add    r15,0x10
  210e28:	4c 8d 1c 30          	lea    r11,[rax+rsi*1]
  210e2c:	49 83 c3 20          	add    r11,0x20
  210e30:	49 c7 c4 ff ff ff ff 	mov    r12,0xffffffffffffffff
  210e37:	49 c7 c6 fe ff ff ff 	mov    r14,0xfffffffffffffffe
  210e3e:	be 01 00 00 00       	mov    esi,0x1
  210e43:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  210e4a:	84 00 00 00 00 00 
  210e50:	48 89 f1             	mov    rcx,rsi
  210e53:	48 c1 e1 04          	shl    rcx,0x4
  210e57:	c4 c1 7a 6f 04 09    	vmovdqu xmm0,XMMWORD PTR [r9+rcx*1]
  210e5d:	c4 e1 f9 7e c0       	vmovq  rax,xmm0
  210e62:	4c 89 e2             	mov    rdx,r12
  210e65:	4c 89 ff             	mov    rdi,r15
  210e68:	49 3b 44 09 f0       	cmp    rax,QWORD PTR [r9+rcx*1-0x10]
            while (j > 0 and lessThan(x, items[j - 1])) : (j -= 1) {
  210e6d:	73 31                	jae    210ea0 <benchmark.add+0x6660>
  210e6f:	90                   	nop
  210e70:	48 89 fb             	mov    rbx,rdi
                items[j] = items[j - 1];
  210e73:	c5 f9 10 4b f0       	vmovupd xmm1,XMMWORD PTR [rbx-0x10]
  210e78:	c5 f9 11 0b          	vmovupd XMMWORD PTR [rbx],xmm1
            while (j > 0 and lessThan(x, items[j - 1])) : (j -= 1) {
  210e7c:	48 83 c2 01          	add    rdx,0x1
  210e80:	74 24                	je     210ea6 <benchmark.add+0x6666>
  210e82:	48 8d 7b f0          	lea    rdi,[rbx-0x10]
  210e86:	48 3b 43 e0          	cmp    rax,QWORD PTR [rbx-0x20]
  210e8a:	72 e4                	jb     210e70 <benchmark.add+0x6630>
  210e8c:	48 83 c3 f0          	add    rbx,0xfffffffffffffff0
  210e90:	eb 17                	jmp    210ea9 <benchmark.add+0x6669>
  210e92:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  210e99:	1f 84 00 00 00 00 00 
  210ea0:	49 8d 1c 09          	lea    rbx,[r9+rcx*1]
  210ea4:	eb 03                	jmp    210ea9 <benchmark.add+0x6669>
  210ea6:	4c 89 cb             	mov    rbx,r9
            items[j] = x;
  210ea9:	c5 fa 7f 03          	vmovdqu XMMWORD PTR [rbx],xmm0
            const x = items[i];
  210ead:	c4 c1 7a 6f 44 09 10 	vmovdqu xmm0,XMMWORD PTR [r9+rcx*1+0x10]
  210eb4:	c4 e1 f9 7e c3       	vmovq  rbx,xmm0
  210eb9:	49 3b 1c 09          	cmp    rbx,QWORD PTR [r9+rcx*1]
            while (j > 0 and lessThan(x, items[j - 1])) : (j -= 1) {
  210ebd:	73 41                	jae    210f00 <benchmark.add+0x66c0>
  210ebf:	4c 89 f0             	mov    rax,r14
  210ec2:	4c 89 da             	mov    rdx,r11
  210ec5:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  210ecc:	00 00 00 00 
  210ed0:	48 89 d1             	mov    rcx,rdx
                items[j] = items[j - 1];
  210ed3:	c5 f9 10 49 f0       	vmovupd xmm1,XMMWORD PTR [rcx-0x10]
  210ed8:	c5 f9 11 09          	vmovupd XMMWORD PTR [rcx],xmm1
            while (j > 0 and lessThan(x, items[j - 1])) : (j -= 1) {
  210edc:	48 83 c0 01          	add    rax,0x1
  210ee0:	74 27                	je     210f09 <benchmark.add+0x66c9>
  210ee2:	48 8d 51 f0          	lea    rdx,[rcx-0x10]
  210ee6:	48 3b 59 e0          	cmp    rbx,QWORD PTR [rcx-0x20]
  210eea:	72 e4                	jb     210ed0 <benchmark.add+0x6690>
  210eec:	48 83 c1 f0          	add    rcx,0xfffffffffffffff0
  210ef0:	eb 1a                	jmp    210f0c <benchmark.add+0x66cc>
  210ef2:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  210ef9:	1f 84 00 00 00 00 00 
  210f00:	4c 01 c9             	add    rcx,r9
  210f03:	48 83 c1 10          	add    rcx,0x10
  210f07:	eb 03                	jmp    210f0c <benchmark.add+0x66cc>
  210f09:	4c 89 c9             	mov    rcx,r9
            items[j] = x;
  210f0c:	c5 fa 7f 01          	vmovdqu XMMWORD PTR [rcx],xmm0
        while (i < items.len) : (i += 1) {
  210f10:	48 83 c6 02          	add    rsi,0x2
  210f14:	49 83 c7 20          	add    r15,0x20
  210f18:	49 83 c4 fe          	add    r12,0xfffffffffffffffe
  210f1c:	49 83 c3 20          	add    r11,0x20
  210f20:	49 83 c6 fe          	add    r14,0xfffffffffffffffe
  210f24:	49 83 c2 fe          	add    r10,0xfffffffffffffffe
  210f28:	0f 85 22 ff ff ff    	jne    210e50 <benchmark.add+0x6610>
            while (j > 0 and lessThan(x, items[j - 1])) : (j -= 1) {
  210f2e:	4d 85 c0             	test   r8,r8
  210f31:	0f 84 87 00 00 00    	je     210fbe <benchmark.add+0x677e>
            const x = items[i];
  210f37:	48 89 f2             	mov    rdx,rsi
  210f3a:	48 c1 e2 04          	shl    rdx,0x4
  210f3e:	49 8d 04 11          	lea    rax,[r9+rdx*1]
  210f42:	c4 c1 7a 6f 04 11    	vmovdqu xmm0,XMMWORD PTR [r9+rdx*1]
  210f48:	c4 e1 f9 7e c1       	vmovq  rcx,xmm0
  210f4d:	49 3b 4c 11 f0       	cmp    rcx,QWORD PTR [r9+rdx*1-0x10]
            while (j > 0 and lessThan(x, items[j - 1])) : (j -= 1) {
  210f52:	73 66                	jae    210fba <benchmark.add+0x677a>
  210f54:	48 89 c2             	mov    rdx,rax
                items[j] = items[j - 1];
  210f57:	c5 f9 10 4a f0       	vmovupd xmm1,XMMWORD PTR [rdx-0x10]
  210f5c:	c5 f9 11 0a          	vmovupd XMMWORD PTR [rdx],xmm1
            while (j > 0 and lessThan(x, items[j - 1])) : (j -= 1) {
  210f60:	48 83 c6 ff          	add    rsi,0xffffffffffffffff
  210f64:	74 51                	je     210fb7 <benchmark.add+0x6777>
  210f66:	48 8d 42 f0          	lea    rax,[rdx-0x10]
  210f6a:	48 3b 4a e0          	cmp    rcx,QWORD PTR [rdx-0x20]
  210f6e:	72 e4                	jb     210f54 <benchmark.add+0x6714>
  210f70:	48 83 c2 f0          	add    rdx,0xfffffffffffffff0
  210f74:	48 89 d0             	mov    rax,rdx
  210f77:	eb 41                	jmp    210fba <benchmark.add+0x677a>
  210f79:	4c 89 a4 24 d0 00 00 	mov    QWORD PTR [rsp+0xd0],r12
  210f80:	00 
  210f81:	e9 ce ca ff ff       	jmp    20da54 <benchmark.add+0x3214>
                        if (pull[0].range.start == A.start) pull[0].range.end -= pull[1].count;
  210f86:	48 8b 44 24 58       	mov    rax,QWORD PTR [rsp+0x58]
  210f8b:	48 39 84 24 98 00 00 	cmp    QWORD PTR [rsp+0x98],rax
  210f92:	00 
  210f93:	75 10                	jne    210fa5 <benchmark.add+0x6765>
  210f95:	48 8b 84 24 b8 00 00 	mov    rax,QWORD PTR [rsp+0xb8]
  210f9c:	00 
  210f9d:	48 29 84 24 a0 00 00 	sub    QWORD PTR [rsp+0xa0],rax
  210fa4:	00 
                        buffer2 = Range.init(B.end - count, B.end);
  210fa5:	4d 29 c5             	sub    r13,r8
  210fa8:	4c 89 6c 24 58       	mov    QWORD PTR [rsp+0x58],r13
  210fad:	4c 89 64 24 40       	mov    QWORD PTR [rsp+0x40],r12
  210fb2:	e9 9d ca ff ff       	jmp    20da54 <benchmark.add+0x3214>
  210fb7:	4c 89 c8             	mov    rax,r9
            items[j] = x;
  210fba:	c5 fa 7f 00          	vmovdqu XMMWORD PTR [rax],xmm0
  210fbe:	31 c0                	xor    eax,eax
  210fc0:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
                var unique = pull[pull_index].count * 2;
  210fc5:	48 8d 04 80          	lea    rax,[rax+rax*4]
  210fc9:	4c 8b 94 c4 90 00 00 	mov    r10,QWORD PTR [rsp+rax*8+0x90]
  210fd0:	00 
  210fd1:	4f 8d 34 12          	lea    r14,[r10+r10*1]
                if (pull[pull_index].from > pull[pull_index].to) {
  210fd5:	48 8b 8c c4 88 00 00 	mov    rcx,QWORD PTR [rsp+rax*8+0x88]
  210fdc:	00 
  210fdd:	48 39 8c c4 80 00 00 	cmp    QWORD PTR [rsp+rax*8+0x80],rcx
  210fe4:	00 
  210fe5:	76 29                	jbe    211010 <benchmark.add+0x67d0>
                    while (buffer.length() > 0) {
  210fe7:	4d 85 d2             	test   r10,r10
  210fea:	0f 84 d2 0b 00 00    	je     211bc2 <benchmark.add+0x7382>
  210ff0:	4c 8b a4 c4 98 00 00 	mov    r12,QWORD PTR [rsp+rax*8+0x98]
  210ff7:	00 
                    var buffer = Range.init(pull[pull_index].range.start, pull[pull_index].range.start + pull[pull_index].count);
  210ff8:	4b 8d 0c 14          	lea    rcx,[r12+r10*1]
  210ffc:	48 8d 04 c4          	lea    rax,[rsp+rax*8]
  211000:	48 05 a0 00 00 00    	add    rax,0xa0
  211006:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  21100b:	e9 e0 05 00 00       	jmp    2115f0 <benchmark.add+0x6db0>
                } else if (pull[pull_index].from < pull[pull_index].to) {
  211010:	0f 83 ac 0b 00 00    	jae    211bc2 <benchmark.add+0x7382>
                    while (buffer.length() > 0) {
  211016:	4d 85 d2             	test   r10,r10
  211019:	0f 84 a3 0b 00 00    	je     211bc2 <benchmark.add+0x7382>
  21101f:	4c 8b 9c c4 a0 00 00 	mov    r11,QWORD PTR [rsp+rax*8+0xa0]
  211026:	00 
                    var buffer = Range.init(pull[pull_index].range.end - pull[pull_index].count, pull[pull_index].range.end);
  211027:	4d 89 df             	mov    r15,r11
  21102a:	4d 29 d7             	sub    r15,r10
  21102d:	48 8d 04 c4          	lea    rax,[rsp+rax*8]
  211031:	48 05 98 00 00 00    	add    rax,0x98
  211037:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  21103c:	eb 12                	jmp    211050 <benchmark.add+0x6810>
  21103e:	48 89 d3             	mov    rbx,rdx
    if (range.start >= range.end) return range.end;
  211041:	48 85 c0             	test   rax,rax
  211044:	0f 85 af 00 00 00    	jne    2110f9 <benchmark.add+0x68b9>
  21104a:	e9 6d 01 00 00       	jmp    2111bc <benchmark.add+0x697c>
  21104f:	90                   	nop
  211050:	4c 89 fe             	mov    rsi,r15
                        index = findLastBackward(T, items, items[buffer.end - 1], Range.init(pull[pull_index].range.start, buffer.start), lessThan, unique);
  211053:	49 8d 4b ff          	lea    rcx,[r11-0x1]
  211057:	4c 8b 6c 24 48       	mov    r13,QWORD PTR [rsp+0x48]
  21105c:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
  211061:	4c 8b 38             	mov    r15,QWORD PTR [rax]
    if (range.length() == 0) return range.start;
  211064:	48 89 f0             	mov    rax,rsi
  211067:	4c 29 f8             	sub    rax,r15
  21106a:	48 89 4c 24 20       	mov    QWORD PTR [rsp+0x20],rcx
  21106f:	0f 84 52 01 00 00    	je     2111c7 <benchmark.add+0x6987>
  211075:	49 89 c8             	mov    r8,rcx
  211078:	49 c1 e0 04          	shl    r8,0x4
  21107c:	48 89 c1             	mov    rcx,rax
  21107f:	4c 09 f1             	or     rcx,r14
  211082:	48 c1 e9 20          	shr    rcx,0x20
  211086:	74 08                	je     211090 <benchmark.add+0x6850>
  211088:	31 d2                	xor    edx,edx
  21108a:	49 f7 f6             	div    r14
  21108d:	eb 06                	jmp    211095 <benchmark.add+0x6855>
  21108f:	90                   	nop
  211090:	31 d2                	xor    edx,edx
  211092:	41 f7 f6             	div    r14d
  211095:	4d 01 e8             	add    r8,r13
    return if (x > y) x else y;
  211098:	48 83 f8 01          	cmp    rax,0x1
  21109c:	b9 01 00 00 00       	mov    ecx,0x1
  2110a1:	48 0f 46 c1          	cmovbe rax,rcx
  2110a5:	48 89 f3             	mov    rbx,rsi
  2110a8:	48 29 c3             	sub    rbx,rax
    while (index > range.start and lessThan(value, items[index - 1])) : (index -= skip) {
  2110ab:	4c 39 fb             	cmp    rbx,r15
  2110ae:	0f 86 fc 00 00 00    	jbe    2111b0 <benchmark.add+0x6970>
  2110b4:	4d 8b 08             	mov    r9,QWORD PTR [r8]
  2110b7:	4a 8d 0c 38          	lea    rcx,[rax+r15*1]
  2110bb:	49 89 f2             	mov    r10,rsi
  2110be:	66 90                	xchg   ax,ax
  2110c0:	48 89 da             	mov    rdx,rbx
  2110c3:	48 8d 7a ff          	lea    rdi,[rdx-0x1]
  2110c7:	48 89 fb             	mov    rbx,rdi
  2110ca:	48 c1 e3 04          	shl    rbx,0x4
  2110ce:	4d 3b 4c 1d 00       	cmp    r9,QWORD PTR [r13+rbx*1+0x0]
  2110d3:	0f 83 65 ff ff ff    	jae    21103e <benchmark.add+0x67fe>
        if (index < range.start + skip) {
  2110d9:	48 39 ca             	cmp    rdx,rcx
  2110dc:	0f 82 95 00 00 00    	jb     211177 <benchmark.add+0x6937>
  2110e2:	48 89 d3             	mov    rbx,rdx
  2110e5:	48 29 c3             	sub    rbx,rax
  2110e8:	49 89 d2             	mov    r10,rdx
    while (index > range.start and lessThan(value, items[index - 1])) : (index -= skip) {
  2110eb:	4c 39 fb             	cmp    rbx,r15
  2110ee:	77 d0                	ja     2110c0 <benchmark.add+0x6880>
    if (range.start >= range.end) return range.end;
  2110f0:	48 85 c0             	test   rax,rax
  2110f3:	0f 84 c3 00 00 00    	je     2111bc <benchmark.add+0x697c>
    var end = range.end - 1;
  2110f9:	49 83 c2 ff          	add    r10,0xffffffffffffffff
    while (start < end) {
  2110fd:	49 39 da             	cmp    r10,rbx
  211100:	76 46                	jbe    211148 <benchmark.add+0x6908>
  211102:	4d 8b 08             	mov    r9,QWORD PTR [r8]
  211105:	4c 89 d1             	mov    rcx,r10
  211108:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  21110f:	00 
        const mid = start + (end - start) / 2;
  211110:	48 89 ca             	mov    rdx,rcx
  211113:	48 29 da             	sub    rdx,rbx
  211116:	48 d1 ea             	shr    rdx,1
  211119:	48 8d 04 1a          	lea    rax,[rdx+rbx*1]
  21111d:	48 89 c7             	mov    rdi,rax
  211120:	48 c1 e7 04          	shl    rdi,0x4
  211124:	4d 3b 4c 3d 00       	cmp    r9,QWORD PTR [r13+rdi*1+0x0]
        if (!lessThan(value, items[mid])) {
  211129:	72 15                	jb     211140 <benchmark.add+0x6900>
  21112b:	48 01 d3             	add    rbx,rdx
  21112e:	48 83 c3 01          	add    rbx,0x1
    while (start < end) {
  211132:	48 39 d9             	cmp    rcx,rbx
  211135:	77 d9                	ja     211110 <benchmark.add+0x68d0>
  211137:	eb 0f                	jmp    211148 <benchmark.add+0x6908>
  211139:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
        if (!lessThan(value, items[mid])) {
  211140:	48 89 c1             	mov    rcx,rax
    while (start < end) {
  211143:	48 39 d9             	cmp    rcx,rbx
  211146:	77 c8                	ja     211110 <benchmark.add+0x68d0>
    if (start == range.end - 1 and !lessThan(value, items[start])) {
  211148:	4c 39 d3             	cmp    rbx,r10
  21114b:	75 74                	jne    2111c1 <benchmark.add+0x6981>
  21114d:	49 8b 00             	mov    rax,QWORD PTR [r8]
  211150:	49 c1 e2 04          	shl    r10,0x4
  211154:	45 31 ff             	xor    r15d,r15d
  211157:	4b 3b 44 15 00       	cmp    rax,QWORD PTR [r13+r10*1+0x0]
  21115c:	41 0f 93 c7          	setae  r15b
  211160:	eb 62                	jmp    2111c4 <benchmark.add+0x6984>
  211162:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  211169:	1f 84 00 00 00 00 00 
  211170:	49 01 c7             	add    r15,rax
  211173:	49 83 c7 01          	add    r15,0x1
    while (start < end) {
  211177:	4c 39 ff             	cmp    rdi,r15
  21117a:	76 4b                	jbe    2111c7 <benchmark.add+0x6987>
        const mid = start + (end - start) / 2;
  21117c:	48 89 f8             	mov    rax,rdi
  21117f:	4c 29 f8             	sub    rax,r15
  211182:	48 d1 e8             	shr    rax,1
  211185:	4a 8d 0c 38          	lea    rcx,[rax+r15*1]
  211189:	48 89 ca             	mov    rdx,rcx
  21118c:	48 c1 e2 04          	shl    rdx,0x4
  211190:	4d 3b 4c 15 00       	cmp    r9,QWORD PTR [r13+rdx*1+0x0]
        if (!lessThan(value, items[mid])) {
  211195:	73 d9                	jae    211170 <benchmark.add+0x6930>
  211197:	48 89 cf             	mov    rdi,rcx
    while (start < end) {
  21119a:	4c 39 ff             	cmp    rdi,r15
  21119d:	77 dd                	ja     21117c <benchmark.add+0x693c>
  21119f:	eb 26                	jmp    2111c7 <benchmark.add+0x6987>
  2111a1:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  2111a8:	0f 1f 84 00 00 00 00 
  2111af:	00 
  2111b0:	49 89 f2             	mov    r10,rsi
    if (range.start >= range.end) return range.end;
  2111b3:	48 85 c0             	test   rax,rax
  2111b6:	0f 85 3d ff ff ff    	jne    2110f9 <benchmark.add+0x68b9>
  2111bc:	4d 89 d7             	mov    r15,r10
  2111bf:	eb 06                	jmp    2111c7 <benchmark.add+0x6987>
  2111c1:	45 31 ff             	xor    r15d,r15d
    if (start == range.end - 1 and !lessThan(value, items[start])) {
  2111c4:	49 01 df             	add    r15,rbx
                        const amount = buffer.start - index;
  2111c7:	49 89 f4             	mov    r12,rsi
  2111ca:	4d 29 fc             	sub    r12,r15
                        mem.rotate(T, items[index..buffer.end], amount);
  2111cd:	4d 89 fa             	mov    r10,r15
  2111d0:	49 c1 e2 04          	shl    r10,0x4
  2111d4:	4d 89 d8             	mov    r8,r11
  2111d7:	4d 29 f8             	sub    r8,r15
    const end = items.len / 2;
  2111da:	4c 89 e7             	mov    rdi,r12
  2111dd:	48 d1 ef             	shr    rdi,1
    while (i < end) : (i += 1) {
  2111e0:	0f 84 32 01 00 00    	je     211318 <benchmark.add+0x6ad8>
        swap(T, &items[i], &items[items.len - i - 1]);
  2111e6:	48 8d 47 ff          	lea    rax,[rdi-0x1]
  2111ea:	89 fa                	mov    edx,edi
  2111ec:	83 e2 03             	and    edx,0x3
  2111ef:	48 83 f8 03          	cmp    rax,0x3
  2111f3:	73 1b                	jae    211210 <benchmark.add+0x69d0>
  2111f5:	31 c0                	xor    eax,eax
    while (i < end) : (i += 1) {
  2111f7:	48 85 d2             	test   rdx,rdx
  2111fa:	0f 85 c6 00 00 00    	jne    2112c6 <benchmark.add+0x6a86>
  211200:	e9 13 01 00 00       	jmp    211318 <benchmark.add+0x6ad8>
  211205:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21120c:	00 00 00 00 
        swap(T, &items[i], &items[items.len - i - 1]);
  211210:	48 29 d7             	sub    rdi,rdx
  211213:	4b 8d 0c 2a          	lea    rcx,[r10+r13*1]
  211217:	48 83 c1 30          	add    rcx,0x30
  21121b:	48 89 f0             	mov    rax,rsi
  21121e:	48 c1 e0 04          	shl    rax,0x4
  211222:	4e 8d 0c 28          	lea    r9,[rax+r13*1]
  211226:	49 83 c1 f0          	add    r9,0xfffffffffffffff0
  21122a:	31 c0                	xor    eax,eax
  21122c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
    const tmp = a.*;
  211230:	c5 f8 10 41 d0       	vmovups xmm0,XMMWORD PTR [rcx-0x30]
  211235:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21123a:	c4 c1 78 10 01       	vmovups xmm0,XMMWORD PTR [r9]
  21123f:	c5 f8 11 41 d0       	vmovups XMMWORD PTR [rcx-0x30],xmm0
    b.* = tmp;
  211244:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  211249:	c4 c1 78 11 01       	vmovups XMMWORD PTR [r9],xmm0
    const tmp = a.*;
  21124e:	c5 f8 10 41 e0       	vmovups xmm0,XMMWORD PTR [rcx-0x20]
  211253:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  211258:	c4 c1 78 10 41 f0    	vmovups xmm0,XMMWORD PTR [r9-0x10]
  21125e:	c5 f8 11 41 e0       	vmovups XMMWORD PTR [rcx-0x20],xmm0
    b.* = tmp;
  211263:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  211268:	c4 c1 78 11 41 f0    	vmovups XMMWORD PTR [r9-0x10],xmm0
    const tmp = a.*;
  21126e:	c5 f8 10 41 f0       	vmovups xmm0,XMMWORD PTR [rcx-0x10]
  211273:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  211278:	c4 c1 78 10 41 e0    	vmovups xmm0,XMMWORD PTR [r9-0x20]
  21127e:	c5 f8 11 41 f0       	vmovups XMMWORD PTR [rcx-0x10],xmm0
    b.* = tmp;
  211283:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  211288:	c4 c1 78 11 41 e0    	vmovups XMMWORD PTR [r9-0x20],xmm0
    const tmp = a.*;
  21128e:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  211292:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  211297:	c4 c1 78 10 41 d0    	vmovups xmm0,XMMWORD PTR [r9-0x30]
  21129d:	c5 f8 11 01          	vmovups XMMWORD PTR [rcx],xmm0
    b.* = tmp;
  2112a1:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  2112a6:	c4 c1 7a 7f 41 d0    	vmovdqu XMMWORD PTR [r9-0x30],xmm0
    while (i < end) : (i += 1) {
  2112ac:	48 83 c0 04          	add    rax,0x4
  2112b0:	48 83 c1 40          	add    rcx,0x40
  2112b4:	49 83 c1 c0          	add    r9,0xffffffffffffffc0
  2112b8:	48 39 c7             	cmp    rdi,rax
  2112bb:	0f 85 6f ff ff ff    	jne    211230 <benchmark.add+0x69f0>
  2112c1:	48 85 d2             	test   rdx,rdx
  2112c4:	74 52                	je     211318 <benchmark.add+0x6ad8>
  2112c6:	48 89 f1             	mov    rcx,rsi
  2112c9:	48 29 c1             	sub    rcx,rax
  2112cc:	48 c1 e1 04          	shl    rcx,0x4
  2112d0:	4c 01 e9             	add    rcx,r13
  2112d3:	48 83 c1 f0          	add    rcx,0xfffffffffffffff0
  2112d7:	4c 01 f8             	add    rax,r15
  2112da:	48 c1 e0 04          	shl    rax,0x4
  2112de:	4c 01 e8             	add    rax,r13
  2112e1:	48 f7 da             	neg    rdx
  2112e4:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  2112eb:	00 00 00 00 00 
    const tmp = a.*;
  2112f0:	c5 f8 10 00          	vmovups xmm0,XMMWORD PTR [rax]
  2112f4:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  2112f9:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  2112fd:	c5 f8 11 00          	vmovups XMMWORD PTR [rax],xmm0
    b.* = tmp;
  211301:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  211306:	c5 fa 7f 01          	vmovdqu XMMWORD PTR [rcx],xmm0
    while (i < end) : (i += 1) {
  21130a:	48 83 c1 f0          	add    rcx,0xfffffffffffffff0
  21130e:	48 83 c0 10          	add    rax,0x10
  211312:	48 83 c2 01          	add    rdx,0x1
  211316:	75 d8                	jne    2112f0 <benchmark.add+0x6ab0>
    reverse(T, items[amount..]);
  211318:	4c 89 c0             	mov    rax,r8
  21131b:	4c 29 e0             	sub    rax,r12
    const end = items.len / 2;
  21131e:	48 d1 e8             	shr    rax,1
    while (i < end) : (i += 1) {
  211321:	0f 84 31 01 00 00    	je     211458 <benchmark.add+0x6c18>
        swap(T, &items[i], &items[items.len - i - 1]);
  211327:	48 8d 48 ff          	lea    rcx,[rax-0x1]
  21132b:	89 c2                	mov    edx,eax
  21132d:	83 e2 03             	and    edx,0x3
  211330:	48 83 f9 03          	cmp    rcx,0x3
  211334:	73 1a                	jae    211350 <benchmark.add+0x6b10>
  211336:	31 c9                	xor    ecx,ecx
    while (i < end) : (i += 1) {
  211338:	48 85 d2             	test   rdx,rdx
  21133b:	0f 85 cd 00 00 00    	jne    21140e <benchmark.add+0x6bce>
  211341:	e9 12 01 00 00       	jmp    211458 <benchmark.add+0x6c18>
  211346:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  21134d:	00 00 00 
        swap(T, &items[i], &items[items.len - i - 1]);
  211350:	48 29 d0             	sub    rax,rdx
  211353:	48 89 f1             	mov    rcx,rsi
  211356:	48 c1 e1 04          	shl    rcx,0x4
  21135a:	4a 8d 3c 29          	lea    rdi,[rcx+r13*1]
  21135e:	48 83 c7 30          	add    rdi,0x30
  211362:	4c 89 d9             	mov    rcx,r11
  211365:	48 c1 e1 04          	shl    rcx,0x4
  211369:	4a 8d 1c 29          	lea    rbx,[rcx+r13*1]
  21136d:	48 83 c3 f0          	add    rbx,0xfffffffffffffff0
  211371:	31 c9                	xor    ecx,ecx
  211373:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21137a:	84 00 00 00 00 00 
    const tmp = a.*;
  211380:	c5 f8 10 47 d0       	vmovups xmm0,XMMWORD PTR [rdi-0x30]
  211385:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21138a:	c5 f8 10 03          	vmovups xmm0,XMMWORD PTR [rbx]
  21138e:	c5 f8 11 47 d0       	vmovups XMMWORD PTR [rdi-0x30],xmm0
    b.* = tmp;
  211393:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  211398:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
    const tmp = a.*;
  21139c:	c5 f8 10 47 e0       	vmovups xmm0,XMMWORD PTR [rdi-0x20]
  2113a1:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  2113a6:	c5 f8 10 43 f0       	vmovups xmm0,XMMWORD PTR [rbx-0x10]
  2113ab:	c5 f8 11 47 e0       	vmovups XMMWORD PTR [rdi-0x20],xmm0
    b.* = tmp;
  2113b0:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  2113b5:	c5 f8 11 43 f0       	vmovups XMMWORD PTR [rbx-0x10],xmm0
    const tmp = a.*;
  2113ba:	c5 f8 10 47 f0       	vmovups xmm0,XMMWORD PTR [rdi-0x10]
  2113bf:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  2113c4:	c5 f8 10 43 e0       	vmovups xmm0,XMMWORD PTR [rbx-0x20]
  2113c9:	c5 f8 11 47 f0       	vmovups XMMWORD PTR [rdi-0x10],xmm0
    b.* = tmp;
  2113ce:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  2113d3:	c5 f8 11 43 e0       	vmovups XMMWORD PTR [rbx-0x20],xmm0
    const tmp = a.*;
  2113d8:	c5 f8 10 07          	vmovups xmm0,XMMWORD PTR [rdi]
  2113dc:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  2113e1:	c5 f8 10 43 d0       	vmovups xmm0,XMMWORD PTR [rbx-0x30]
  2113e6:	c5 f8 11 07          	vmovups XMMWORD PTR [rdi],xmm0
    b.* = tmp;
  2113ea:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  2113ef:	c5 fa 7f 43 d0       	vmovdqu XMMWORD PTR [rbx-0x30],xmm0
    while (i < end) : (i += 1) {
  2113f4:	48 83 c1 04          	add    rcx,0x4
  2113f8:	48 83 c7 40          	add    rdi,0x40
  2113fc:	48 83 c3 c0          	add    rbx,0xffffffffffffffc0
  211400:	48 39 c8             	cmp    rax,rcx
  211403:	0f 85 77 ff ff ff    	jne    211380 <benchmark.add+0x6b40>
  211409:	48 85 d2             	test   rdx,rdx
  21140c:	74 4a                	je     211458 <benchmark.add+0x6c18>
  21140e:	4c 89 d8             	mov    rax,r11
  211411:	48 29 c8             	sub    rax,rcx
  211414:	48 c1 e0 04          	shl    rax,0x4
  211418:	4c 01 e8             	add    rax,r13
  21141b:	48 83 c0 f0          	add    rax,0xfffffffffffffff0
  21141f:	48 01 ce             	add    rsi,rcx
  211422:	48 c1 e6 04          	shl    rsi,0x4
  211426:	4c 01 ee             	add    rsi,r13
  211429:	48 f7 da             	neg    rdx
  21142c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
    const tmp = a.*;
  211430:	c5 f8 10 06          	vmovups xmm0,XMMWORD PTR [rsi]
  211434:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  211439:	c5 f8 10 00          	vmovups xmm0,XMMWORD PTR [rax]
  21143d:	c5 f8 11 06          	vmovups XMMWORD PTR [rsi],xmm0
    b.* = tmp;
  211441:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  211446:	c5 fa 7f 00          	vmovdqu XMMWORD PTR [rax],xmm0
    while (i < end) : (i += 1) {
  21144a:	48 83 c0 f0          	add    rax,0xfffffffffffffff0
  21144e:	48 83 c6 10          	add    rsi,0x10
  211452:	48 83 c2 01          	add    rdx,0x1
  211456:	75 d8                	jne    211430 <benchmark.add+0x6bf0>
    const end = items.len / 2;
  211458:	4c 89 c2             	mov    rdx,r8
  21145b:	48 d1 ea             	shr    rdx,1
    while (i < end) : (i += 1) {
  21145e:	0f 84 5c 01 00 00    	je     2115c0 <benchmark.add+0x6d80>
  211464:	4b 8d 04 2a          	lea    rax,[r10+r13*1]
    const tmp = a.*;
  211468:	c5 f8 10 00          	vmovups xmm0,XMMWORD PTR [rax]
  21146c:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  211471:	49 c1 e0 04          	shl    r8,0x4
    a.* = b.*;
  211475:	c4 a1 78 10 44 00 f0 	vmovups xmm0,XMMWORD PTR [rax+r8*1-0x10]
  21147c:	c5 f8 11 00          	vmovups XMMWORD PTR [rax],xmm0
    b.* = tmp;
  211480:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  211485:	c4 a1 7a 7f 44 00 f0 	vmovdqu XMMWORD PTR [rax+r8*1-0x10],xmm0
    while (i < end) : (i += 1) {
  21148c:	48 83 fa 01          	cmp    rdx,0x1
  211490:	0f 84 2a 01 00 00    	je     2115c0 <benchmark.add+0x6d80>
        swap(T, &items[i], &items[items.len - i - 1]);
  211496:	8d 72 ff             	lea    esi,[rdx-0x1]
  211499:	48 8d 42 fe          	lea    rax,[rdx-0x2]
  21149d:	83 e6 03             	and    esi,0x3
  2114a0:	48 83 f8 03          	cmp    rax,0x3
  2114a4:	73 13                	jae    2114b9 <benchmark.add+0x6c79>
  2114a6:	b8 01 00 00 00       	mov    eax,0x1
    while (i < end) : (i += 1) {
  2114ab:	48 85 f6             	test   rsi,rsi
  2114ae:	0f 85 ba 00 00 00    	jne    21156e <benchmark.add+0x6d2e>
  2114b4:	e9 07 01 00 00       	jmp    2115c0 <benchmark.add+0x6d80>
        swap(T, &items[i], &items[items.len - i - 1]);
  2114b9:	4c 89 d8             	mov    rax,r11
  2114bc:	48 c1 e0 04          	shl    rax,0x4
  2114c0:	4a 8d 0c 28          	lea    rcx,[rax+r13*1]
  2114c4:	48 83 c1 e0          	add    rcx,0xffffffffffffffe0
  2114c8:	4b 8d 3c 2a          	lea    rdi,[r10+r13*1]
  2114cc:	48 83 c7 40          	add    rdi,0x40
  2114d0:	48 29 f2             	sub    rdx,rsi
  2114d3:	b8 01 00 00 00       	mov    eax,0x1
  2114d8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  2114df:	00 
    const tmp = a.*;
  2114e0:	c5 f8 10 47 d0       	vmovups xmm0,XMMWORD PTR [rdi-0x30]
  2114e5:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  2114ea:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  2114ee:	c5 f8 11 47 d0       	vmovups XMMWORD PTR [rdi-0x30],xmm0
    b.* = tmp;
  2114f3:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  2114f8:	c5 f8 11 01          	vmovups XMMWORD PTR [rcx],xmm0
    const tmp = a.*;
  2114fc:	c5 f8 10 47 e0       	vmovups xmm0,XMMWORD PTR [rdi-0x20]
  211501:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  211506:	c5 f8 10 41 f0       	vmovups xmm0,XMMWORD PTR [rcx-0x10]
  21150b:	c5 f8 11 47 e0       	vmovups XMMWORD PTR [rdi-0x20],xmm0
    b.* = tmp;
  211510:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  211515:	c5 f8 11 41 f0       	vmovups XMMWORD PTR [rcx-0x10],xmm0
    const tmp = a.*;
  21151a:	c5 f8 10 47 f0       	vmovups xmm0,XMMWORD PTR [rdi-0x10]
  21151f:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  211524:	c5 f8 10 41 e0       	vmovups xmm0,XMMWORD PTR [rcx-0x20]
  211529:	c5 f8 11 47 f0       	vmovups XMMWORD PTR [rdi-0x10],xmm0
    b.* = tmp;
  21152e:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  211533:	c5 f8 11 41 e0       	vmovups XMMWORD PTR [rcx-0x20],xmm0
    const tmp = a.*;
  211538:	c5 f8 10 07          	vmovups xmm0,XMMWORD PTR [rdi]
  21153c:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  211541:	c5 f8 10 41 d0       	vmovups xmm0,XMMWORD PTR [rcx-0x30]
  211546:	c5 f8 11 07          	vmovups XMMWORD PTR [rdi],xmm0
    b.* = tmp;
  21154a:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  21154f:	c5 fa 7f 41 d0       	vmovdqu XMMWORD PTR [rcx-0x30],xmm0
    while (i < end) : (i += 1) {
  211554:	48 83 c0 04          	add    rax,0x4
  211558:	48 83 c1 c0          	add    rcx,0xffffffffffffffc0
  21155c:	48 83 c7 40          	add    rdi,0x40
  211560:	48 39 c2             	cmp    rdx,rax
  211563:	0f 85 77 ff ff ff    	jne    2114e0 <benchmark.add+0x6ca0>
  211569:	48 85 f6             	test   rsi,rsi
  21156c:	74 52                	je     2115c0 <benchmark.add+0x6d80>
  21156e:	49 29 c3             	sub    r11,rax
  211571:	49 c1 e3 04          	shl    r11,0x4
  211575:	4b 8d 0c 2b          	lea    rcx,[r11+r13*1]
  211579:	48 83 c1 f0          	add    rcx,0xfffffffffffffff0
  21157d:	4c 01 f8             	add    rax,r15
  211580:	48 c1 e0 04          	shl    rax,0x4
  211584:	4c 01 e8             	add    rax,r13
  211587:	48 f7 de             	neg    rsi
  21158a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
    const tmp = a.*;
  211590:	c5 f8 10 00          	vmovups xmm0,XMMWORD PTR [rax]
  211594:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  211599:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  21159d:	c5 f8 11 00          	vmovups XMMWORD PTR [rax],xmm0
    b.* = tmp;
  2115a1:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  2115a6:	c5 fa 7f 01          	vmovdqu XMMWORD PTR [rcx],xmm0
    while (i < end) : (i += 1) {
  2115aa:	48 83 c1 f0          	add    rcx,0xfffffffffffffff0
  2115ae:	48 83 c0 10          	add    rax,0x10
  2115b2:	48 83 c6 01          	add    rsi,0x1
  2115b6:	75 d8                	jne    211590 <benchmark.add+0x6d50>
  2115b8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  2115bf:	00 
  2115c0:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
                        buffer.end -= (amount + 1);
  2115c5:	4c 29 e0             	sub    rax,r12
                        unique -= 2;
  2115c8:	49 83 c6 fe          	add    r14,0xfffffffffffffffe
  2115cc:	49 89 c3             	mov    r11,rax
                    while (buffer.length() > 0) {
  2115cf:	4c 39 f8             	cmp    rax,r15
  2115d2:	0f 85 78 fa ff ff    	jne    211050 <benchmark.add+0x6810>
  2115d8:	e9 e5 05 00 00       	jmp    211bc2 <benchmark.add+0x7382>
  2115dd:	31 c9                	xor    ecx,ecx
  2115df:	e9 29 01 00 00       	jmp    21170d <benchmark.add+0x6ecd>
  2115e4:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  2115eb:	00 00 00 00 00 
  2115f0:	49 89 cf             	mov    r15,rcx
                        index = findFirstForward(T, items, items[buffer.start], Range.init(buffer.end, pull[pull_index].range.end), lessThan, unique);
  2115f3:	4c 8b 5c 24 48       	mov    r11,QWORD PTR [rsp+0x48]
  2115f8:	4c 89 e0             	mov    rax,r12
  2115fb:	48 c1 e0 04          	shl    rax,0x4
  2115ff:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  211604:	49 8d 04 03          	lea    rax,[r11+rax*1]
  211608:	48 89 44 24 20       	mov    QWORD PTR [rsp+0x20],rax
  21160d:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  211612:	4c 8b 28             	mov    r13,QWORD PTR [rax]
    if (range.length() == 0) return range.start;
  211615:	4c 89 e8             	mov    rax,r13
  211618:	4c 29 f8             	sub    rax,r15
  21161b:	0f 84 7f 01 00 00    	je     2117a0 <benchmark.add+0x6f60>
  211621:	48 89 c1             	mov    rcx,rax
  211624:	4c 09 f1             	or     rcx,r14
  211627:	48 c1 e9 20          	shr    rcx,0x20
  21162b:	74 13                	je     211640 <benchmark.add+0x6e00>
  21162d:	31 d2                	xor    edx,edx
  21162f:	49 f7 f6             	div    r14
  211632:	eb 11                	jmp    211645 <benchmark.add+0x6e05>
  211634:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21163b:	00 00 00 00 00 
  211640:	31 d2                	xor    edx,edx
  211642:	41 f7 f6             	div    r14d
  211645:	48 83 f8 01          	cmp    rax,0x1
  211649:	b9 01 00 00 00       	mov    ecx,0x1
  21164e:	48 0f 46 c1          	cmovbe rax,rcx
  211652:	4a 8d 0c 38          	lea    rcx,[rax+r15*1]
    while (lessThan(items[index - 1], value)) : (index += skip) {
  211656:	4e 8d 04 38          	lea    r8,[rax+r15*1]
  21165a:	49 83 c0 ff          	add    r8,0xffffffffffffffff
  21165e:	4c 89 c2             	mov    rdx,r8
  211661:	48 c1 e2 04          	shl    rdx,0x4
  211665:	4d 8b 0c 13          	mov    r9,QWORD PTR [r11+rdx*1]
  211669:	48 8b 54 24 20       	mov    rdx,QWORD PTR [rsp+0x20]
  21166e:	48 8b 3a             	mov    rdi,QWORD PTR [rdx]
  211671:	49 39 f9             	cmp    r9,rdi
  211674:	0f 83 a6 00 00 00    	jae    211720 <benchmark.add+0x6ee0>
  21167a:	4c 89 ee             	mov    rsi,r13
  21167d:	48 29 c6             	sub    rsi,rax
  211680:	48 89 ca             	mov    rdx,rcx
        if (index >= range.end - skip) {
  211683:	48 39 f2             	cmp    rdx,rsi
  211686:	0f 83 9e 00 00 00    	jae    21172a <benchmark.add+0x6eea>
  21168c:	48 8d 0c 02          	lea    rcx,[rdx+rax*1]
    while (lessThan(items[index - 1], value)) : (index += skip) {
  211690:	4c 8d 04 02          	lea    r8,[rdx+rax*1]
  211694:	49 83 c0 ff          	add    r8,0xffffffffffffffff
  211698:	4c 89 c3             	mov    rbx,r8
  21169b:	48 c1 e3 04          	shl    rbx,0x4
  21169f:	4d 8b 0c 1b          	mov    r9,QWORD PTR [r11+rbx*1]
  2116a3:	49 39 f9             	cmp    r9,rdi
  2116a6:	72 d8                	jb     211680 <benchmark.add+0x6e40>
    if (range.start >= range.end) return range.end;
  2116a8:	48 85 c0             	test   rax,rax
  2116ab:	0f 84 ef 00 00 00    	je     2117a0 <benchmark.add+0x6f60>
    while (start < end) {
  2116b1:	49 39 d0             	cmp    r8,rdx
  2116b4:	76 46                	jbe    2116fc <benchmark.add+0x6ebc>
  2116b6:	4c 89 c0             	mov    rax,r8
  2116b9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
        const mid = start + (end - start) / 2;
  2116c0:	48 89 c1             	mov    rcx,rax
  2116c3:	48 29 d1             	sub    rcx,rdx
  2116c6:	48 d1 e9             	shr    rcx,1
  2116c9:	48 8d 34 11          	lea    rsi,[rcx+rdx*1]
  2116cd:	48 89 f3             	mov    rbx,rsi
  2116d0:	48 c1 e3 04          	shl    rbx,0x4
  2116d4:	49 39 3c 1b          	cmp    QWORD PTR [r11+rbx*1],rdi
        if (lessThan(items[mid], value)) {
  2116d8:	72 16                	jb     2116f0 <benchmark.add+0x6eb0>
  2116da:	48 89 f0             	mov    rax,rsi
    while (start < end) {
  2116dd:	48 39 d0             	cmp    rax,rdx
  2116e0:	77 de                	ja     2116c0 <benchmark.add+0x6e80>
  2116e2:	eb 18                	jmp    2116fc <benchmark.add+0x6ebc>
  2116e4:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  2116eb:	00 00 00 00 00 
  2116f0:	48 01 ca             	add    rdx,rcx
  2116f3:	48 83 c2 01          	add    rdx,0x1
  2116f7:	48 39 d0             	cmp    rax,rdx
  2116fa:	77 c4                	ja     2116c0 <benchmark.add+0x6e80>
    if (start == range.end - 1 and lessThan(items[start], value)) {
  2116fc:	4c 39 c2             	cmp    rdx,r8
  2116ff:	0f 94 c0             	sete   al
  211702:	49 39 f9             	cmp    r9,rdi
  211705:	0f 92 c1             	setb   cl
  211708:	20 c1                	and    cl,al
  21170a:	0f b6 c9             	movzx  ecx,cl
  21170d:	48 01 d1             	add    rcx,rdx
  211710:	e9 8b 00 00 00       	jmp    2117a0 <benchmark.add+0x6f60>
  211715:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21171c:	00 00 00 00 
  211720:	4c 89 fa             	mov    rdx,r15
    if (range.start >= range.end) return range.end;
  211723:	48 85 c0             	test   rax,rax
  211726:	75 89                	jne    2116b1 <benchmark.add+0x6e71>
  211728:	eb 76                	jmp    2117a0 <benchmark.add+0x6f60>
  21172a:	4c 39 ea             	cmp    rdx,r13
  21172d:	73 68                	jae    211797 <benchmark.add+0x6f57>
    var end = range.end - 1;
  21172f:	49 83 c5 ff          	add    r13,0xffffffffffffffff
    while (start < end) {
  211733:	49 39 d5             	cmp    r13,rdx
  211736:	76 44                	jbe    21177c <benchmark.add+0x6f3c>
  211738:	4c 89 e8             	mov    rax,r13
  21173b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
        const mid = start + (end - start) / 2;
  211740:	48 89 c1             	mov    rcx,rax
  211743:	48 29 d1             	sub    rcx,rdx
  211746:	48 d1 e9             	shr    rcx,1
  211749:	48 8d 1c 11          	lea    rbx,[rcx+rdx*1]
  21174d:	48 89 de             	mov    rsi,rbx
  211750:	48 c1 e6 04          	shl    rsi,0x4
  211754:	49 39 3c 33          	cmp    QWORD PTR [r11+rsi*1],rdi
        if (lessThan(items[mid], value)) {
  211758:	72 16                	jb     211770 <benchmark.add+0x6f30>
  21175a:	48 89 d8             	mov    rax,rbx
    while (start < end) {
  21175d:	48 39 d0             	cmp    rax,rdx
  211760:	77 de                	ja     211740 <benchmark.add+0x6f00>
  211762:	eb 18                	jmp    21177c <benchmark.add+0x6f3c>
  211764:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21176b:	00 00 00 00 00 
  211770:	48 01 ca             	add    rdx,rcx
  211773:	48 83 c2 01          	add    rdx,0x1
  211777:	48 39 d0             	cmp    rax,rdx
  21177a:	77 c4                	ja     211740 <benchmark.add+0x6f00>
    if (start == range.end - 1 and lessThan(items[start], value)) {
  21177c:	4c 39 ea             	cmp    rdx,r13
  21177f:	0f 85 58 fe ff ff    	jne    2115dd <benchmark.add+0x6d9d>
  211785:	49 c1 e5 04          	shl    r13,0x4
  211789:	31 c9                	xor    ecx,ecx
  21178b:	4b 39 3c 2b          	cmp    QWORD PTR [r11+r13*1],rdi
  21178f:	0f 92 c1             	setb   cl
  211792:	e9 76 ff ff ff       	jmp    21170d <benchmark.add+0x6ecd>
  211797:	4c 89 e9             	mov    rcx,r13
  21179a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
                        mem.rotate(T, items[buffer.start..index], buffer.length());
  2117a0:	49 89 c8             	mov    r8,rcx
  2117a3:	4d 29 e0             	sub    r8,r12
    const end = items.len / 2;
  2117a6:	4c 89 d0             	mov    rax,r10
  2117a9:	48 d1 e8             	shr    rax,1
    while (i < end) : (i += 1) {
  2117ac:	0f 84 36 01 00 00    	je     2118e8 <benchmark.add+0x70a8>
        swap(T, &items[i], &items[items.len - i - 1]);
  2117b2:	48 8d 70 ff          	lea    rsi,[rax-0x1]
  2117b6:	89 c2                	mov    edx,eax
  2117b8:	83 e2 03             	and    edx,0x3
  2117bb:	48 83 fe 03          	cmp    rsi,0x3
  2117bf:	73 1f                	jae    2117e0 <benchmark.add+0x6fa0>
  2117c1:	31 ff                	xor    edi,edi
    while (i < end) : (i += 1) {
  2117c3:	48 85 d2             	test   rdx,rdx
  2117c6:	0f 85 d2 00 00 00    	jne    21189e <benchmark.add+0x705e>
  2117cc:	e9 17 01 00 00       	jmp    2118e8 <benchmark.add+0x70a8>
  2117d1:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  2117d8:	0f 1f 84 00 00 00 00 
  2117df:	00 
        swap(T, &items[i], &items[items.len - i - 1]);
  2117e0:	48 29 d0             	sub    rax,rdx
  2117e3:	48 8b 74 24 60       	mov    rsi,QWORD PTR [rsp+0x60]
  2117e8:	49 8d 1c 33          	lea    rbx,[r11+rsi*1]
  2117ec:	48 83 c3 30          	add    rbx,0x30
  2117f0:	4b 8d 34 22          	lea    rsi,[r10+r12*1]
  2117f4:	48 c1 e6 04          	shl    rsi,0x4
  2117f8:	4c 01 de             	add    rsi,r11
  2117fb:	48 83 c6 f0          	add    rsi,0xfffffffffffffff0
  2117ff:	31 ff                	xor    edi,edi
  211801:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  211808:	0f 1f 84 00 00 00 00 
  21180f:	00 
    const tmp = a.*;
  211810:	c5 f8 10 43 d0       	vmovups xmm0,XMMWORD PTR [rbx-0x30]
  211815:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21181a:	c5 f8 10 06          	vmovups xmm0,XMMWORD PTR [rsi]
  21181e:	c5 f8 11 43 d0       	vmovups XMMWORD PTR [rbx-0x30],xmm0
    b.* = tmp;
  211823:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  211828:	c5 f8 11 06          	vmovups XMMWORD PTR [rsi],xmm0
    const tmp = a.*;
  21182c:	c5 f8 10 43 e0       	vmovups xmm0,XMMWORD PTR [rbx-0x20]
  211831:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  211836:	c5 f8 10 46 f0       	vmovups xmm0,XMMWORD PTR [rsi-0x10]
  21183b:	c5 f8 11 43 e0       	vmovups XMMWORD PTR [rbx-0x20],xmm0
    b.* = tmp;
  211840:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  211845:	c5 f8 11 46 f0       	vmovups XMMWORD PTR [rsi-0x10],xmm0
    const tmp = a.*;
  21184a:	c5 f8 10 43 f0       	vmovups xmm0,XMMWORD PTR [rbx-0x10]
  21184f:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  211854:	c5 f8 10 46 e0       	vmovups xmm0,XMMWORD PTR [rsi-0x20]
  211859:	c5 f8 11 43 f0       	vmovups XMMWORD PTR [rbx-0x10],xmm0
    b.* = tmp;
  21185e:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  211863:	c5 f8 11 46 e0       	vmovups XMMWORD PTR [rsi-0x20],xmm0
    const tmp = a.*;
  211868:	c5 f8 10 03          	vmovups xmm0,XMMWORD PTR [rbx]
  21186c:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  211871:	c5 f8 10 46 d0       	vmovups xmm0,XMMWORD PTR [rsi-0x30]
  211876:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
    b.* = tmp;
  21187a:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  21187f:	c5 fa 7f 46 d0       	vmovdqu XMMWORD PTR [rsi-0x30],xmm0
    while (i < end) : (i += 1) {
  211884:	48 83 c7 04          	add    rdi,0x4
  211888:	48 83 c3 40          	add    rbx,0x40
  21188c:	48 83 c6 c0          	add    rsi,0xffffffffffffffc0
  211890:	48 39 f8             	cmp    rax,rdi
  211893:	0f 85 77 ff ff ff    	jne    211810 <benchmark.add+0x6fd0>
  211899:	48 85 d2             	test   rdx,rdx
  21189c:	74 4a                	je     2118e8 <benchmark.add+0x70a8>
  21189e:	4b 8d 04 22          	lea    rax,[r10+r12*1]
  2118a2:	48 29 f8             	sub    rax,rdi
  2118a5:	48 c1 e0 04          	shl    rax,0x4
  2118a9:	4c 01 d8             	add    rax,r11
  2118ac:	48 83 c0 f0          	add    rax,0xfffffffffffffff0
  2118b0:	4c 01 e7             	add    rdi,r12
  2118b3:	48 c1 e7 04          	shl    rdi,0x4
  2118b7:	4c 01 df             	add    rdi,r11
  2118ba:	48 f7 da             	neg    rdx
  2118bd:	0f 1f 00             	nop    DWORD PTR [rax]
    const tmp = a.*;
  2118c0:	c5 f8 10 07          	vmovups xmm0,XMMWORD PTR [rdi]
  2118c4:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  2118c9:	c5 f8 10 00          	vmovups xmm0,XMMWORD PTR [rax]
  2118cd:	c5 f8 11 07          	vmovups XMMWORD PTR [rdi],xmm0
    b.* = tmp;
  2118d1:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  2118d6:	c5 fa 7f 00          	vmovdqu XMMWORD PTR [rax],xmm0
    while (i < end) : (i += 1) {
  2118da:	48 83 c0 f0          	add    rax,0xfffffffffffffff0
  2118de:	48 83 c7 10          	add    rdi,0x10
  2118e2:	48 83 c2 01          	add    rdx,0x1
  2118e6:	75 d8                	jne    2118c0 <benchmark.add+0x7080>
    reverse(T, items[amount..]);
  2118e8:	4c 89 c0             	mov    rax,r8
  2118eb:	4c 29 d0             	sub    rax,r10
    const end = items.len / 2;
  2118ee:	48 d1 e8             	shr    rax,1
    while (i < end) : (i += 1) {
  2118f1:	0f 84 41 01 00 00    	je     211a38 <benchmark.add+0x71f8>
        swap(T, &items[i], &items[items.len - i - 1]);
  2118f7:	48 8d 70 ff          	lea    rsi,[rax-0x1]
  2118fb:	89 c2                	mov    edx,eax
  2118fd:	83 e2 03             	and    edx,0x3
  211900:	48 83 fe 03          	cmp    rsi,0x3
  211904:	73 1a                	jae    211920 <benchmark.add+0x70e0>
  211906:	31 ff                	xor    edi,edi
    while (i < end) : (i += 1) {
  211908:	48 85 d2             	test   rdx,rdx
  21190b:	0f 85 cd 00 00 00    	jne    2119de <benchmark.add+0x719e>
  211911:	e9 22 01 00 00       	jmp    211a38 <benchmark.add+0x71f8>
  211916:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  21191d:	00 00 00 
        swap(T, &items[i], &items[items.len - i - 1]);
  211920:	48 29 d0             	sub    rax,rdx
  211923:	4c 89 fe             	mov    rsi,r15
  211926:	48 c1 e6 04          	shl    rsi,0x4
  21192a:	49 8d 1c 33          	lea    rbx,[r11+rsi*1]
  21192e:	48 83 c3 30          	add    rbx,0x30
  211932:	4a 8d 34 39          	lea    rsi,[rcx+r15*1]
  211936:	4b 8d 3c 22          	lea    rdi,[r10+r12*1]
  21193a:	48 29 fe             	sub    rsi,rdi
  21193d:	48 c1 e6 04          	shl    rsi,0x4
  211941:	4c 01 de             	add    rsi,r11
  211944:	48 83 c6 f0          	add    rsi,0xfffffffffffffff0
  211948:	31 ff                	xor    edi,edi
  21194a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
    const tmp = a.*;
  211950:	c5 f8 10 43 d0       	vmovups xmm0,XMMWORD PTR [rbx-0x30]
  211955:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21195a:	c5 f8 10 06          	vmovups xmm0,XMMWORD PTR [rsi]
  21195e:	c5 f8 11 43 d0       	vmovups XMMWORD PTR [rbx-0x30],xmm0
    b.* = tmp;
  211963:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  211968:	c5 f8 11 06          	vmovups XMMWORD PTR [rsi],xmm0
    const tmp = a.*;
  21196c:	c5 f8 10 43 e0       	vmovups xmm0,XMMWORD PTR [rbx-0x20]
  211971:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  211976:	c5 f8 10 46 f0       	vmovups xmm0,XMMWORD PTR [rsi-0x10]
  21197b:	c5 f8 11 43 e0       	vmovups XMMWORD PTR [rbx-0x20],xmm0
    b.* = tmp;
  211980:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  211985:	c5 f8 11 46 f0       	vmovups XMMWORD PTR [rsi-0x10],xmm0
    const tmp = a.*;
  21198a:	c5 f8 10 43 f0       	vmovups xmm0,XMMWORD PTR [rbx-0x10]
  21198f:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  211994:	c5 f8 10 46 e0       	vmovups xmm0,XMMWORD PTR [rsi-0x20]
  211999:	c5 f8 11 43 f0       	vmovups XMMWORD PTR [rbx-0x10],xmm0
    b.* = tmp;
  21199e:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  2119a3:	c5 f8 11 46 e0       	vmovups XMMWORD PTR [rsi-0x20],xmm0
    const tmp = a.*;
  2119a8:	c5 f8 10 03          	vmovups xmm0,XMMWORD PTR [rbx]
  2119ac:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  2119b1:	c5 f8 10 46 d0       	vmovups xmm0,XMMWORD PTR [rsi-0x30]
  2119b6:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
    b.* = tmp;
  2119ba:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  2119bf:	c5 fa 7f 46 d0       	vmovdqu XMMWORD PTR [rsi-0x30],xmm0
    while (i < end) : (i += 1) {
  2119c4:	48 83 c7 04          	add    rdi,0x4
  2119c8:	48 83 c3 40          	add    rbx,0x40
  2119cc:	48 83 c6 c0          	add    rsi,0xffffffffffffffc0
  2119d0:	48 39 f8             	cmp    rax,rdi
  2119d3:	0f 85 77 ff ff ff    	jne    211950 <benchmark.add+0x7110>
  2119d9:	48 85 d2             	test   rdx,rdx
  2119dc:	74 5a                	je     211a38 <benchmark.add+0x71f8>
  2119de:	4a 8d 04 39          	lea    rax,[rcx+r15*1]
  2119e2:	4d 01 e2             	add    r10,r12
  2119e5:	49 01 fa             	add    r10,rdi
  2119e8:	4c 29 d0             	sub    rax,r10
  2119eb:	48 c1 e0 04          	shl    rax,0x4
  2119ef:	4c 01 d8             	add    rax,r11
  2119f2:	48 83 c0 f0          	add    rax,0xfffffffffffffff0
  2119f6:	4c 01 ff             	add    rdi,r15
  2119f9:	48 c1 e7 04          	shl    rdi,0x4
  2119fd:	4c 01 df             	add    rdi,r11
  211a00:	48 f7 da             	neg    rdx
  211a03:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  211a0a:	84 00 00 00 00 00 
    const tmp = a.*;
  211a10:	c5 f8 10 07          	vmovups xmm0,XMMWORD PTR [rdi]
  211a14:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  211a19:	c5 f8 10 00          	vmovups xmm0,XMMWORD PTR [rax]
  211a1d:	c5 f8 11 07          	vmovups XMMWORD PTR [rdi],xmm0
    b.* = tmp;
  211a21:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  211a26:	c5 fa 7f 00          	vmovdqu XMMWORD PTR [rax],xmm0
    while (i < end) : (i += 1) {
  211a2a:	48 83 c0 f0          	add    rax,0xfffffffffffffff0
  211a2e:	48 83 c7 10          	add    rdi,0x10
  211a32:	48 83 c2 01          	add    rdx,0x1
  211a36:	75 d8                	jne    211a10 <benchmark.add+0x71d0>
    const end = items.len / 2;
  211a38:	4c 89 c6             	mov    rsi,r8
  211a3b:	48 d1 ee             	shr    rsi,1
    while (i < end) : (i += 1) {
  211a3e:	0f 84 5c 01 00 00    	je     211ba0 <benchmark.add+0x7360>
  211a44:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
    const tmp = a.*;
  211a49:	c5 f8 10 00          	vmovups xmm0,XMMWORD PTR [rax]
  211a4d:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  211a52:	49 c1 e0 04          	shl    r8,0x4
    a.* = b.*;
  211a56:	c4 a1 78 10 44 00 f0 	vmovups xmm0,XMMWORD PTR [rax+r8*1-0x10]
  211a5d:	c5 f8 11 00          	vmovups XMMWORD PTR [rax],xmm0
    b.* = tmp;
  211a61:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  211a66:	c4 a1 7a 7f 44 00 f0 	vmovdqu XMMWORD PTR [rax+r8*1-0x10],xmm0
    while (i < end) : (i += 1) {
  211a6d:	48 83 fe 01          	cmp    rsi,0x1
  211a71:	0f 84 29 01 00 00    	je     211ba0 <benchmark.add+0x7360>
        swap(T, &items[i], &items[items.len - i - 1]);
  211a77:	8d 46 ff             	lea    eax,[rsi-0x1]
  211a7a:	48 8d 56 fe          	lea    rdx,[rsi-0x2]
  211a7e:	83 e0 03             	and    eax,0x3
  211a81:	48 83 fa 03          	cmp    rdx,0x3
  211a85:	73 13                	jae    211a9a <benchmark.add+0x725a>
  211a87:	ba 01 00 00 00       	mov    edx,0x1
    while (i < end) : (i += 1) {
  211a8c:	48 85 c0             	test   rax,rax
  211a8f:	0f 85 b9 00 00 00    	jne    211b4e <benchmark.add+0x730e>
  211a95:	e9 06 01 00 00       	jmp    211ba0 <benchmark.add+0x7360>
        swap(T, &items[i], &items[items.len - i - 1]);
  211a9a:	48 89 ca             	mov    rdx,rcx
  211a9d:	48 c1 e2 04          	shl    rdx,0x4
  211aa1:	49 8d 3c 13          	lea    rdi,[r11+rdx*1]
  211aa5:	48 83 c7 e0          	add    rdi,0xffffffffffffffe0
  211aa9:	48 8b 54 24 60       	mov    rdx,QWORD PTR [rsp+0x60]
  211aae:	49 8d 1c 13          	lea    rbx,[r11+rdx*1]
  211ab2:	48 83 c3 40          	add    rbx,0x40
  211ab6:	48 29 c6             	sub    rsi,rax
  211ab9:	ba 01 00 00 00       	mov    edx,0x1
  211abe:	66 90                	xchg   ax,ax
    const tmp = a.*;
  211ac0:	c5 f8 10 43 d0       	vmovups xmm0,XMMWORD PTR [rbx-0x30]
  211ac5:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  211aca:	c5 f8 10 07          	vmovups xmm0,XMMWORD PTR [rdi]
  211ace:	c5 f8 11 43 d0       	vmovups XMMWORD PTR [rbx-0x30],xmm0
    b.* = tmp;
  211ad3:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  211ad8:	c5 f8 11 07          	vmovups XMMWORD PTR [rdi],xmm0
    const tmp = a.*;
  211adc:	c5 f8 10 43 e0       	vmovups xmm0,XMMWORD PTR [rbx-0x20]
  211ae1:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  211ae6:	c5 f8 10 47 f0       	vmovups xmm0,XMMWORD PTR [rdi-0x10]
  211aeb:	c5 f8 11 43 e0       	vmovups XMMWORD PTR [rbx-0x20],xmm0
    b.* = tmp;
  211af0:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  211af5:	c5 f8 11 47 f0       	vmovups XMMWORD PTR [rdi-0x10],xmm0
    const tmp = a.*;
  211afa:	c5 f8 10 43 f0       	vmovups xmm0,XMMWORD PTR [rbx-0x10]
  211aff:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  211b04:	c5 f8 10 47 e0       	vmovups xmm0,XMMWORD PTR [rdi-0x20]
  211b09:	c5 f8 11 43 f0       	vmovups XMMWORD PTR [rbx-0x10],xmm0
    b.* = tmp;
  211b0e:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  211b13:	c5 f8 11 47 e0       	vmovups XMMWORD PTR [rdi-0x20],xmm0
    const tmp = a.*;
  211b18:	c5 f8 10 03          	vmovups xmm0,XMMWORD PTR [rbx]
  211b1c:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  211b21:	c5 f8 10 47 d0       	vmovups xmm0,XMMWORD PTR [rdi-0x30]
  211b26:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
    b.* = tmp;
  211b2a:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  211b2f:	c5 fa 7f 47 d0       	vmovdqu XMMWORD PTR [rdi-0x30],xmm0
    while (i < end) : (i += 1) {
  211b34:	48 83 c2 04          	add    rdx,0x4
  211b38:	48 83 c7 c0          	add    rdi,0xffffffffffffffc0
  211b3c:	48 83 c3 40          	add    rbx,0x40
  211b40:	48 39 d6             	cmp    rsi,rdx
  211b43:	0f 85 77 ff ff ff    	jne    211ac0 <benchmark.add+0x7280>
  211b49:	48 85 c0             	test   rax,rax
  211b4c:	74 52                	je     211ba0 <benchmark.add+0x7360>
  211b4e:	48 89 ce             	mov    rsi,rcx
  211b51:	48 29 d6             	sub    rsi,rdx
  211b54:	48 c1 e6 04          	shl    rsi,0x4
  211b58:	4c 01 de             	add    rsi,r11
  211b5b:	48 83 c6 f0          	add    rsi,0xfffffffffffffff0
  211b5f:	4c 01 e2             	add    rdx,r12
  211b62:	48 c1 e2 04          	shl    rdx,0x4
  211b66:	4c 01 da             	add    rdx,r11
  211b69:	48 f7 d8             	neg    rax
  211b6c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
    const tmp = a.*;
  211b70:	c5 f8 10 02          	vmovups xmm0,XMMWORD PTR [rdx]
  211b74:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  211b79:	c5 f8 10 06          	vmovups xmm0,XMMWORD PTR [rsi]
  211b7d:	c5 f8 11 02          	vmovups XMMWORD PTR [rdx],xmm0
    b.* = tmp;
  211b81:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  211b86:	c5 fa 7f 06          	vmovdqu XMMWORD PTR [rsi],xmm0
    while (i < end) : (i += 1) {
  211b8a:	48 83 c6 f0          	add    rsi,0xfffffffffffffff0
  211b8e:	48 83 c2 10          	add    rdx,0x10
  211b92:	48 83 c0 01          	add    rax,0x1
  211b96:	75 d8                	jne    211b70 <benchmark.add+0x7330>
  211b98:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  211b9f:	00 
                        const amount = index - buffer.end;
  211ba0:	b8 01 00 00 00       	mov    eax,0x1
  211ba5:	4c 29 f8             	sub    rax,r15
                        buffer.start += (amount + 1);
  211ba8:	4c 01 e0             	add    rax,r12
  211bab:	4c 8d 24 01          	lea    r12,[rcx+rax*1]
                        unique -= 2;
  211baf:	49 83 c6 fe          	add    r14,0xfffffffffffffffe
        return self.end - self.start;
  211bb3:	49 89 c2             	mov    r10,rax
  211bb6:	49 f7 da             	neg    r10
                    while (buffer.length() > 0) {
  211bb9:	48 85 c0             	test   rax,rax
  211bbc:	0f 85 2e fa ff ff    	jne    2115f0 <benchmark.add+0x6db0>
  211bc2:	48 8b 44 24 10       	mov    rax,QWORD PTR [rsp+0x10]
            while (pull_index < 2) : (pull_index += 1) {
  211bc7:	48 83 c0 01          	add    rax,0x1
  211bcb:	48 83 f8 02          	cmp    rax,0x2
  211bcf:	0f 85 eb f3 ff ff    	jne    210fc0 <benchmark.add+0x6780>
  211bd5:	48 8b 84 24 30 01 00 	mov    rax,QWORD PTR [rsp+0x130]
  211bdc:	00 
  211bdd:	48 8b 94 24 50 01 00 	mov    rdx,QWORD PTR [rsp+0x150]
  211be4:	00 
  211be5:	48 8b 9c 24 38 01 00 	mov    rbx,QWORD PTR [rsp+0x138]
  211bec:	00 
  211bed:	4c 8b 84 24 f8 00 00 	mov    r8,QWORD PTR [rsp+0xf8]
  211bf4:	00 
  211bf5:	e9 98 25 00 00       	jmp    214192 <benchmark.add+0x9952>
        if (self.numerator_step >= self.denominator) {
  211bfa:	48 39 d8             	cmp    rax,rbx
  211bfd:	b9 00 00 00 00       	mov    ecx,0x0
  211c02:	48 0f 43 cb          	cmovae rcx,rbx
  211c06:	48 29 c8             	sub    rax,rcx
  211c09:	49 89 c1             	mov    r9,rax
        if (iterator.length() < cache.len) {
  211c0c:	49 81 f8 00 02 00 00 	cmp    r8,0x200
  211c13:	4c 89 84 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],r8
  211c1a:	00 
  211c1b:	4c 89 8c 24 30 01 00 	mov    QWORD PTR [rsp+0x130],r9
  211c22:	00 
  211c23:	0f 83 57 b6 ff ff    	jae    20d280 <benchmark.add+0x2a40>
            if ((iterator.length() + 1) * 4 <= cache.len and iterator.length() * 4 <= items.len) {
  211c29:	4a 8d 04 85 04 00 00 	lea    rax,[r8*4+0x4]
  211c30:	00 
    for (source) |s, i|
  211c31:	49 8d 48 ff          	lea    rcx,[r8-0x1]
  211c35:	48 89 4c 24 40       	mov    QWORD PTR [rsp+0x40],rcx
  211c3a:	48 3d 00 02 00 00    	cmp    rax,0x200
  211c40:	0f 87 27 1d 00 00    	ja     21396d <benchmark.add+0x912d>
  211c46:	4a 8d 0c 85 00 00 00 	lea    rcx,[r8*4+0x0]
  211c4d:	00 
  211c4e:	48 3b 4c 24 50       	cmp    rcx,QWORD PTR [rsp+0x50]
  211c53:	0f 87 14 1d 00 00    	ja     21396d <benchmark.add+0x912d>
        self.decimal += self.decimal_step;
  211c59:	4b 8d 04 00          	lea    rax,[r8+r8*1]
  211c5d:	48 89 84 24 e0 00 00 	mov    QWORD PTR [rsp+0xe0],rax
  211c64:	00 
  211c65:	4b 8d 04 00          	lea    rax,[r8+r8*1]
  211c69:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  211c6d:	48 89 84 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rax
  211c74:	00 
  211c75:	48 89 8c 24 90 01 00 	mov    QWORD PTR [rsp+0x190],rcx
  211c7c:	00 
  211c7d:	48 8d 41 ff          	lea    rax,[rcx-0x1]
  211c81:	48 89 84 24 a8 01 00 	mov    QWORD PTR [rsp+0x1a8],rax
  211c88:	00 
  211c89:	4b 8d 0c 40          	lea    rcx,[r8+r8*2]
  211c8d:	4b 8d 04 40          	lea    rax,[r8+r8*2]
  211c91:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  211c95:	48 89 84 24 a0 01 00 	mov    QWORD PTR [rsp+0x1a0],rax
  211c9c:	00 
  211c9d:	4c 89 c2             	mov    rdx,r8
  211ca0:	48 c1 e2 04          	shl    rdx,0x4
  211ca4:	48 8d 84 24 10 03 00 	lea    rax,[rsp+0x310]
  211cab:	00 
  211cac:	48 8d 34 10          	lea    rsi,[rax+rdx*1]
  211cb0:	48 89 b4 24 98 01 00 	mov    QWORD PTR [rsp+0x198],rsi
  211cb7:	00 
  211cb8:	48 89 94 24 e8 00 00 	mov    QWORD PTR [rsp+0xe8],rdx
  211cbf:	00 
  211cc0:	48 01 e2             	add    rdx,rsp
  211cc3:	48 81 c2 a0 02 00 00 	add    rdx,0x2a0
  211cca:	48 89 94 24 70 01 00 	mov    QWORD PTR [rsp+0x170],rdx
  211cd1:	00 
  211cd2:	4c 89 c2             	mov    rdx,r8
  211cd5:	48 c1 e2 05          	shl    rdx,0x5
  211cd9:	48 8d 34 10          	lea    rsi,[rax+rdx*1]
  211cdd:	48 89 b4 24 60 01 00 	mov    QWORD PTR [rsp+0x160],rsi
  211ce4:	00 
  211ce5:	48 8d 34 14          	lea    rsi,[rsp+rdx*1]
  211ce9:	48 81 c6 a0 02 00 00 	add    rsi,0x2a0
  211cf0:	48 89 b4 24 28 01 00 	mov    QWORD PTR [rsp+0x128],rsi
  211cf7:	00 
  211cf8:	48 89 8c 24 40 01 00 	mov    QWORD PTR [rsp+0x140],rcx
  211cff:	00 
  211d00:	48 89 ce             	mov    rsi,rcx
  211d03:	48 c1 e6 04          	shl    rsi,0x4
  211d07:	48 8d 0c 34          	lea    rcx,[rsp+rsi*1]
  211d0b:	48 81 c1 a0 02 00 00 	add    rcx,0x2a0
  211d12:	48 89 8c 24 68 01 00 	mov    QWORD PTR [rsp+0x168],rcx
  211d19:	00 
  211d1a:	48 8d 8c 24 b0 02 00 	lea    rcx,[rsp+0x2b0]
  211d21:	00 
  211d22:	48 01 ca             	add    rdx,rcx
  211d25:	48 89 94 24 d8 00 00 	mov    QWORD PTR [rsp+0xd8],rdx
  211d2c:	00 
  211d2d:	48 89 b4 24 48 01 00 	mov    QWORD PTR [rsp+0x148],rsi
  211d34:	00 
  211d35:	48 8d 04 30          	lea    rax,[rax+rsi*1]
  211d39:	48 89 84 24 78 01 00 	mov    QWORD PTR [rsp+0x178],rax
  211d40:	00 
  211d41:	31 c0                	xor    eax,eax
  211d43:	45 31 ed             	xor    r13d,r13d
  211d46:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  211d4d:	00 00 00 
  211d50:	49 89 c3             	mov    r11,rax
  211d53:	4f 8d 34 03          	lea    r14,[r11+r8*1]
        self.numerator += self.numerator_step;
  211d57:	4d 01 cd             	add    r13,r9
        if (self.numerator >= self.denominator) {
  211d5a:	31 f6                	xor    esi,esi
  211d5c:	49 39 dd             	cmp    r13,rbx
  211d5f:	48 89 d8             	mov    rax,rbx
  211d62:	41 ba 00 00 00 00    	mov    r10d,0x0
  211d68:	49 0f 42 c2          	cmovb  rax,r10
  211d6c:	40 0f 93 c6          	setae  sil
  211d70:	49 29 c5             	sub    r13,rax
  211d73:	49 01 f6             	add    r14,rsi
        self.decimal += self.decimal_step;
  211d76:	4b 8d 3c 06          	lea    rdi,[r14+r8*1]
        self.numerator += self.numerator_step;
  211d7a:	4d 01 cd             	add    r13,r9
        if (self.numerator >= self.denominator) {
  211d7d:	31 d2                	xor    edx,edx
  211d7f:	49 39 dd             	cmp    r13,rbx
  211d82:	0f 93 c2             	setae  dl
  211d85:	48 89 d8             	mov    rax,rbx
  211d88:	49 0f 42 c2          	cmovb  rax,r10
  211d8c:	49 29 c5             	sub    r13,rax
  211d8f:	48 89 d0             	mov    rax,rdx
  211d92:	48 89 44 24 30       	mov    QWORD PTR [rsp+0x30],rax
  211d97:	48 01 d7             	add    rdi,rdx
        self.decimal += self.decimal_step;
  211d9a:	4a 8d 0c 07          	lea    rcx,[rdi+r8*1]
        self.numerator += self.numerator_step;
  211d9e:	4d 01 cd             	add    r13,r9
        if (self.numerator >= self.denominator) {
  211da1:	31 d2                	xor    edx,edx
  211da3:	49 39 dd             	cmp    r13,rbx
  211da6:	0f 93 c2             	setae  dl
  211da9:	48 89 d8             	mov    rax,rbx
  211dac:	49 0f 42 c2          	cmovb  rax,r10
  211db0:	49 29 c5             	sub    r13,rax
  211db3:	48 89 54 24 38       	mov    QWORD PTR [rsp+0x38],rdx
  211db8:	48 01 d1             	add    rcx,rdx
  211dbb:	48 89 4c 24 18       	mov    QWORD PTR [rsp+0x18],rcx
        self.decimal += self.decimal_step;
  211dc0:	4a 8d 04 01          	lea    rax,[rcx+r8*1]
        self.numerator += self.numerator_step;
  211dc4:	4d 01 cd             	add    r13,r9
        if (self.numerator >= self.denominator) {
  211dc7:	31 d2                	xor    edx,edx
  211dc9:	49 39 dd             	cmp    r13,rbx
  211dcc:	0f 93 c2             	setae  dl
  211dcf:	49 89 d9             	mov    r9,rbx
  211dd2:	4d 0f 42 ca          	cmovb  r9,r10
  211dd6:	48 89 54 24 58       	mov    QWORD PTR [rsp+0x58],rdx
  211ddb:	48 01 d0             	add    rax,rdx
                    if (lessThan(items[B1.end - 1], items[A1.start])) {
  211dde:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  211de3:	48 89 fb             	mov    rbx,rdi
  211de6:	48 c1 e3 04          	shl    rbx,0x4
  211dea:	4c 8b 7c 24 48       	mov    r15,QWORD PTR [rsp+0x48]
  211def:	4c 89 d9             	mov    rcx,r11
  211df2:	48 c1 e1 04          	shl    rcx,0x4
  211df6:	49 8b 44 1f f0       	mov    rax,QWORD PTR [r15+rbx*1-0x10]
  211dfb:	49 8b 14 0f          	mov    rdx,QWORD PTR [r15+rcx*1]
  211dff:	48 39 d0             	cmp    rax,rdx
  211e02:	48 89 8c 24 58 01 00 	mov    QWORD PTR [rsp+0x158],rcx
  211e09:	00 
  211e0a:	4d 8d 24 0f          	lea    r12,[r15+rcx*1]
  211e0e:	4c 89 d9             	mov    rcx,r11
  211e11:	48 89 4c 24 10       	mov    QWORD PTR [rsp+0x10],rcx
  211e16:	48 89 74 24 28       	mov    QWORD PTR [rsp+0x28],rsi
  211e1b:	48 89 7c 24 20       	mov    QWORD PTR [rsp+0x20],rdi
  211e20:	4c 89 ac 24 d0 00 00 	mov    QWORD PTR [rsp+0xd0],r13
  211e27:	00 
  211e28:	4c 89 8c 24 00 01 00 	mov    QWORD PTR [rsp+0x100],r9
  211e2f:	00 
  211e30:	48 89 5c 24 78       	mov    QWORD PTR [rsp+0x78],rbx
  211e35:	73 59                	jae    211e90 <benchmark.add+0x7650>
        return self.end - self.start;
  211e37:	4c 29 f7             	sub    rdi,r14
                        mem.copy(T, cache[B1.length()..], items[A1.start..A1.end]);
  211e3a:	b8 00 02 00 00       	mov    eax,0x200
  211e3f:	48 29 f8             	sub    rax,rdi
  211e42:	4c 89 f2             	mov    rdx,r14
  211e45:	4c 29 da             	sub    rdx,r11
    assert(dest.len >= source.len);
  211e48:	48 39 d0             	cmp    rax,rdx
  211e4b:	0f 82 85 27 00 00    	jb     2145d6 <benchmark.add+0x9d96>
    for (source) |s, i|
  211e51:	48 85 d2             	test   rdx,rdx
  211e54:	0f 84 2a 02 00 00    	je     212084 <benchmark.add+0x7844>
  211e5a:	48 8b 44 24 40       	mov    rax,QWORD PTR [rsp+0x40]
  211e5f:	48 8d 0c 30          	lea    rcx,[rax+rsi*1]
  211e63:	89 d0                	mov    eax,edx
  211e65:	83 e0 07             	and    eax,0x7
  211e68:	48 83 f9 07          	cmp    rcx,0x7
  211e6c:	0f 83 34 01 00 00    	jae    211fa6 <benchmark.add+0x7766>
  211e72:	31 c9                	xor    ecx,ecx
  211e74:	48 85 c0             	test   rax,rax
  211e77:	0f 85 cb 01 00 00    	jne    212048 <benchmark.add+0x7808>
  211e7d:	e9 02 02 00 00       	jmp    212084 <benchmark.add+0x7844>
  211e82:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  211e89:	1f 84 00 00 00 00 00 
                    } else if (lessThan(items[B1.start], items[A1.end - 1])) {
  211e90:	4c 89 f1             	mov    rcx,r14
  211e93:	48 c1 e1 04          	shl    rcx,0x4
  211e97:	4d 8b 04 0f          	mov    r8,QWORD PTR [r15+rcx*1]
  211e9b:	4d 3b 44 0f f0       	cmp    r8,QWORD PTR [r15+rcx*1-0x10]
  211ea0:	0f 83 9a 00 00 00    	jae    211f40 <benchmark.add+0x7700>
  211ea6:	4c 89 f0             	mov    rax,r14
  211ea9:	4c 89 db             	mov    rbx,r11
  211eac:	31 ff                	xor    edi,edi
  211eae:	eb 0e                	jmp    211ebe <benchmark.add+0x767e>
  211eb0:	48 89 c1             	mov    rcx,rax
  211eb3:	48 c1 e1 04          	shl    rcx,0x4
  211eb7:	4d 8b 04 0f          	mov    r8,QWORD PTR [r15+rcx*1]
  211ebb:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
        if (!lessThan(from[B_index], from[A_index])) {
  211ebe:	48 89 c1             	mov    rcx,rax
  211ec1:	48 c1 e1 04          	shl    rcx,0x4
  211ec5:	4d 8d 1c 0f          	lea    r11,[r15+rcx*1]
  211ec9:	49 89 da             	mov    r10,rbx
  211ecc:	49 c1 e2 04          	shl    r10,0x4
  211ed0:	4b 8d 34 17          	lea    rsi,[r15+r10*1]
  211ed4:	49 89 f9             	mov    r9,rdi
  211ed7:	49 c1 e1 04          	shl    r9,0x4
  211edb:	4e 8d 2c 0c          	lea    r13,[rsp+r9*1]
  211edf:	49 81 c5 a0 02 00 00 	add    r13,0x2a0
  211ee6:	49 39 d0             	cmp    r8,rdx
  211ee9:	73 25                	jae    211f10 <benchmark.add+0x76d0>
            into[insert_index] = from[B_index];
  211eeb:	c4 c1 7a 6f 03       	vmovdqu xmm0,XMMWORD PTR [r11]
  211ef0:	c4 c1 7a 7f 45 00    	vmovdqu XMMWORD PTR [r13+0x0],xmm0
            B_index += 1;
  211ef6:	48 83 c0 01          	add    rax,0x1
            if (B_index == B_last) {
  211efa:	48 3b 44 24 20       	cmp    rax,QWORD PTR [rsp+0x20]
  211eff:	0f 84 a9 02 00 00    	je     2121ae <benchmark.add+0x796e>
  211f05:	48 83 c7 01          	add    rdi,0x1
  211f09:	eb a5                	jmp    211eb0 <benchmark.add+0x7670>
  211f0b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
            into[insert_index] = from[A_index];
  211f10:	c5 fa 6f 06          	vmovdqu xmm0,XMMWORD PTR [rsi]
  211f14:	c4 c1 7a 7f 45 00    	vmovdqu XMMWORD PTR [r13+0x0],xmm0
            A_index += 1;
  211f1a:	48 83 c3 01          	add    rbx,0x1
            if (A_index == A_last) {
  211f1e:	4c 39 f3             	cmp    rbx,r14
  211f21:	0f 84 da 02 00 00    	je     212201 <benchmark.add+0x79c1>
  211f27:	48 83 c7 01          	add    rdi,0x1
  211f2b:	48 89 de             	mov    rsi,rbx
  211f2e:	48 c1 e6 04          	shl    rsi,0x4
  211f32:	4c 01 fe             	add    rsi,r15
  211f35:	e9 76 ff ff ff       	jmp    211eb0 <benchmark.add+0x7670>
  211f3a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
                        if (!lessThan(items[B2.start], items[A2.end - 1]) and !lessThan(items[A2.start], items[B1.end - 1])) continue;
  211f40:	48 8b 4c 24 18       	mov    rcx,QWORD PTR [rsp+0x18]
  211f45:	48 c1 e1 04          	shl    rcx,0x4
  211f49:	49 8b 14 0f          	mov    rdx,QWORD PTR [r15+rcx*1]
  211f4d:	49 3b 54 0f f0       	cmp    rdx,QWORD PTR [r15+rcx*1-0x10]
  211f52:	72 0a                	jb     211f5e <benchmark.add+0x771e>
  211f54:	49 39 04 1f          	cmp    QWORD PTR [r15+rbx*1],rax
  211f58:	0f 83 b2 19 00 00    	jae    213910 <benchmark.add+0x90d0>
                        mem.copy(T, cache[0..], items[A1.start..A1.end]);
  211f5e:	4c 89 f0             	mov    rax,r14
  211f61:	4c 29 d8             	sub    rax,r11
    assert(dest.len >= source.len);
  211f64:	48 3d 01 02 00 00    	cmp    rax,0x201
  211f6a:	0f 83 66 26 00 00    	jae    2145d6 <benchmark.add+0x9d96>
    for (source) |s, i|
  211f70:	48 85 c0             	test   rax,rax
  211f73:	0f 84 d0 03 00 00    	je     212349 <benchmark.add+0x7b09>
  211f79:	48 8b 4c 24 40       	mov    rcx,QWORD PTR [rsp+0x40]
  211f7e:	48 8d 14 31          	lea    rdx,[rcx+rsi*1]
  211f82:	89 c1                	mov    ecx,eax
  211f84:	83 e1 07             	and    ecx,0x7
  211f87:	48 83 fa 07          	cmp    rdx,0x7
  211f8b:	0f 83 d6 02 00 00    	jae    212267 <benchmark.add+0x7a27>
  211f91:	31 d2                	xor    edx,edx
  211f93:	48 85 c9             	test   rcx,rcx
  211f96:	48 8b 7c 24 20       	mov    rdi,QWORD PTR [rsp+0x20]
  211f9b:	0f 85 79 03 00 00    	jne    21231a <benchmark.add+0x7ada>
  211fa1:	e9 a3 03 00 00       	jmp    212349 <benchmark.add+0x7b09>
  211fa6:	48 29 c2             	sub    rdx,rax
  211fa9:	48 8b 74 24 30       	mov    rsi,QWORD PTR [rsp+0x30]
  211fae:	48 c1 e6 04          	shl    rsi,0x4
  211fb2:	48 03 b4 24 70 01 00 	add    rsi,QWORD PTR [rsp+0x170]
  211fb9:	00 
  211fba:	bb 70 00 00 00       	mov    ebx,0x70
  211fbf:	31 c9                	xor    ecx,ecx
  211fc1:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  211fc8:	0f 1f 84 00 00 00 00 
  211fcf:	00 
        dest[i] = s;
  211fd0:	c4 c1 78 10 44 1c 90 	vmovups xmm0,XMMWORD PTR [r12+rbx*1-0x70]
  211fd7:	c5 f8 11 44 1e 90    	vmovups XMMWORD PTR [rsi+rbx*1-0x70],xmm0
  211fdd:	c4 c1 78 10 44 1c a0 	vmovups xmm0,XMMWORD PTR [r12+rbx*1-0x60]
  211fe4:	c5 f8 11 44 1e a0    	vmovups XMMWORD PTR [rsi+rbx*1-0x60],xmm0
  211fea:	c4 c1 78 10 44 1c b0 	vmovups xmm0,XMMWORD PTR [r12+rbx*1-0x50]
  211ff1:	c5 f8 11 44 1e b0    	vmovups XMMWORD PTR [rsi+rbx*1-0x50],xmm0
  211ff7:	c4 c1 78 10 44 1c c0 	vmovups xmm0,XMMWORD PTR [r12+rbx*1-0x40]
  211ffe:	c5 f8 11 44 1e c0    	vmovups XMMWORD PTR [rsi+rbx*1-0x40],xmm0
  212004:	c4 c1 78 10 44 1c d0 	vmovups xmm0,XMMWORD PTR [r12+rbx*1-0x30]
  21200b:	c5 f8 11 44 1e d0    	vmovups XMMWORD PTR [rsi+rbx*1-0x30],xmm0
  212011:	c4 c1 78 10 44 1c e0 	vmovups xmm0,XMMWORD PTR [r12+rbx*1-0x20]
  212018:	c5 f8 11 44 1e e0    	vmovups XMMWORD PTR [rsi+rbx*1-0x20],xmm0
  21201e:	c4 c1 78 10 44 1c f0 	vmovups xmm0,XMMWORD PTR [r12+rbx*1-0x10]
  212025:	c5 f8 11 44 1e f0    	vmovups XMMWORD PTR [rsi+rbx*1-0x10],xmm0
  21202b:	c4 c1 7a 6f 04 1c    	vmovdqu xmm0,XMMWORD PTR [r12+rbx*1]
  212031:	c5 fa 7f 04 1e       	vmovdqu XMMWORD PTR [rsi+rbx*1],xmm0
    for (source) |s, i|
  212036:	48 83 c1 08          	add    rcx,0x8
  21203a:	48 83 eb 80          	sub    rbx,0xffffffffffffff80
  21203e:	48 39 ca             	cmp    rdx,rcx
  212041:	75 8d                	jne    211fd0 <benchmark.add+0x7790>
  212043:	48 85 c0             	test   rax,rax
  212046:	74 3c                	je     212084 <benchmark.add+0x7844>
  212048:	48 8b 54 24 30       	mov    rdx,QWORD PTR [rsp+0x30]
  21204d:	48 8d 14 11          	lea    rdx,[rcx+rdx*1]
  212051:	48 c1 e2 04          	shl    rdx,0x4
  212055:	48 03 94 24 70 01 00 	add    rdx,QWORD PTR [rsp+0x170]
  21205c:	00 
  21205d:	4c 01 d9             	add    rcx,r11
  212060:	48 c1 e1 04          	shl    rcx,0x4
  212064:	4c 01 f9             	add    rcx,r15
  212067:	48 f7 d8             	neg    rax
  21206a:	31 f6                	xor    esi,esi
  21206c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
        dest[i] = s;
  212070:	c5 fa 6f 04 31       	vmovdqu xmm0,XMMWORD PTR [rcx+rsi*1]
  212075:	c5 fa 7f 04 32       	vmovdqu XMMWORD PTR [rdx+rsi*1],xmm0
    for (source) |s, i|
  21207a:	48 83 c6 10          	add    rsi,0x10
  21207e:	48 83 c0 01          	add    rax,0x1
  212082:	75 ec                	jne    212070 <benchmark.add+0x7830>
    assert(dest.len >= source.len);
  212084:	48 81 ff 01 02 00 00 	cmp    rdi,0x201
  21208b:	0f 83 45 25 00 00    	jae    2145d6 <benchmark.add+0x9d96>
    for (source) |s, i|
  212091:	48 85 ff             	test   rdi,rdi
  212094:	0f 84 b6 05 00 00    	je     212650 <benchmark.add+0x7e10>
  21209a:	48 8b 44 24 40       	mov    rax,QWORD PTR [rsp+0x40]
  21209f:	48 8b 4c 24 30       	mov    rcx,QWORD PTR [rsp+0x30]
  2120a4:	48 8d 0c 08          	lea    rcx,[rax+rcx*1]
  2120a8:	89 f8                	mov    eax,edi
  2120aa:	83 e0 07             	and    eax,0x7
  2120ad:	48 83 f9 07          	cmp    rcx,0x7
  2120b1:	73 10                	jae    2120c3 <benchmark.add+0x7883>
  2120b3:	31 c9                	xor    ecx,ecx
  2120b5:	48 85 c0             	test   rax,rax
  2120b8:	0f 85 c3 00 00 00    	jne    212181 <benchmark.add+0x7941>
  2120be:	e9 8d 05 00 00       	jmp    212650 <benchmark.add+0x7e10>
  2120c3:	48 29 c7             	sub    rdi,rax
  2120c6:	48 8b 8c 24 e8 00 00 	mov    rcx,QWORD PTR [rsp+0xe8]
  2120cd:	00 
  2120ce:	49 8d 0c 0f          	lea    rcx,[r15+rcx*1]
  2120d2:	48 8b 54 24 10       	mov    rdx,QWORD PTR [rsp+0x10]
  2120d7:	48 8b 74 24 28       	mov    rsi,QWORD PTR [rsp+0x28]
  2120dc:	48 8d 14 32          	lea    rdx,[rdx+rsi*1]
  2120e0:	48 c1 e2 04          	shl    rdx,0x4
  2120e4:	48 01 ca             	add    rdx,rcx
  2120e7:	be 70 00 00 00       	mov    esi,0x70
  2120ec:	31 c9                	xor    ecx,ecx
  2120ee:	66 90                	xchg   ax,ax
        dest[i] = s;
  2120f0:	c5 f8 10 44 32 90    	vmovups xmm0,XMMWORD PTR [rdx+rsi*1-0x70]
  2120f6:	c5 f8 11 84 34 30 02 	vmovups XMMWORD PTR [rsp+rsi*1+0x230],xmm0
  2120fd:	00 00 
  2120ff:	c5 f8 10 44 32 a0    	vmovups xmm0,XMMWORD PTR [rdx+rsi*1-0x60]
  212105:	c5 f8 11 84 34 40 02 	vmovups XMMWORD PTR [rsp+rsi*1+0x240],xmm0
  21210c:	00 00 
  21210e:	c5 f8 10 44 32 b0    	vmovups xmm0,XMMWORD PTR [rdx+rsi*1-0x50]
  212114:	c5 f8 11 84 34 50 02 	vmovups XMMWORD PTR [rsp+rsi*1+0x250],xmm0
  21211b:	00 00 
  21211d:	c5 f8 10 44 32 c0    	vmovups xmm0,XMMWORD PTR [rdx+rsi*1-0x40]
  212123:	c5 f8 11 84 34 60 02 	vmovups XMMWORD PTR [rsp+rsi*1+0x260],xmm0
  21212a:	00 00 
  21212c:	c5 f8 10 44 32 d0    	vmovups xmm0,XMMWORD PTR [rdx+rsi*1-0x30]
  212132:	c5 f8 11 84 34 70 02 	vmovups XMMWORD PTR [rsp+rsi*1+0x270],xmm0
  212139:	00 00 
  21213b:	c5 f8 10 44 32 e0    	vmovups xmm0,XMMWORD PTR [rdx+rsi*1-0x20]
  212141:	c5 f8 11 84 34 80 02 	vmovups XMMWORD PTR [rsp+rsi*1+0x280],xmm0
  212148:	00 00 
  21214a:	c5 f8 10 44 32 f0    	vmovups xmm0,XMMWORD PTR [rdx+rsi*1-0x10]
  212150:	c5 f8 11 84 34 90 02 	vmovups XMMWORD PTR [rsp+rsi*1+0x290],xmm0
  212157:	00 00 
  212159:	c5 fa 6f 04 32       	vmovdqu xmm0,XMMWORD PTR [rdx+rsi*1]
  21215e:	c5 fa 7f 84 34 a0 02 	vmovdqu XMMWORD PTR [rsp+rsi*1+0x2a0],xmm0
  212165:	00 00 
    for (source) |s, i|
  212167:	48 83 c1 08          	add    rcx,0x8
  21216b:	48 83 ee 80          	sub    rsi,0xffffffffffffff80
  21216f:	48 39 cf             	cmp    rdi,rcx
  212172:	0f 85 78 ff ff ff    	jne    2120f0 <benchmark.add+0x78b0>
  212178:	48 85 c0             	test   rax,rax
  21217b:	0f 84 cf 04 00 00    	je     212650 <benchmark.add+0x7e10>
  212181:	49 c1 e6 04          	shl    r14,0x4
  212185:	4d 01 fe             	add    r14,r15
  212188:	48 c1 e1 04          	shl    rcx,0x4
  21218c:	48 f7 d8             	neg    rax
  21218f:	90                   	nop
        dest[i] = s;
  212190:	c4 c1 7a 6f 04 0e    	vmovdqu xmm0,XMMWORD PTR [r14+rcx*1]
  212196:	c5 fa 7f 84 0c a0 02 	vmovdqu XMMWORD PTR [rsp+rcx*1+0x2a0],xmm0
  21219d:	00 00 
    for (source) |s, i|
  21219f:	48 83 c1 10          	add    rcx,0x10
  2121a3:	48 83 c0 01          	add    rax,0x1
  2121a7:	75 e7                	jne    212190 <benchmark.add+0x7950>
  2121a9:	e9 a2 04 00 00       	jmp    212650 <benchmark.add+0x7e10>
                mem.copy(T, into[insert_index..], from[A_index..A_last]);
  2121ae:	b8 ff 01 00 00       	mov    eax,0x1ff
  2121b3:	48 29 f8             	sub    rax,rdi
  2121b6:	49 29 de             	sub    r14,rbx
    assert(dest.len >= source.len);
  2121b9:	4c 39 f0             	cmp    rax,r14
  2121bc:	0f 82 14 24 00 00    	jb     2145d6 <benchmark.add+0x9d96>
    for (source) |s, i|
  2121c2:	4d 85 f6             	test   r14,r14
  2121c5:	0f 84 85 04 00 00    	je     212650 <benchmark.add+0x7e10>
  2121cb:	48 8b 44 24 40       	mov    rax,QWORD PTR [rsp+0x40]
  2121d0:	48 8b 4c 24 10       	mov    rcx,QWORD PTR [rsp+0x10]
  2121d5:	48 8d 0c 08          	lea    rcx,[rax+rcx*1]
  2121d9:	48 03 4c 24 28       	add    rcx,QWORD PTR [rsp+0x28]
  2121de:	48 29 d9             	sub    rcx,rbx
  2121e1:	44 89 f0             	mov    eax,r14d
  2121e4:	83 e0 07             	and    eax,0x7
  2121e7:	48 83 f9 07          	cmp    rcx,0x7
  2121eb:	0f 83 a8 02 00 00    	jae    212499 <benchmark.add+0x7c59>
  2121f1:	31 c9                	xor    ecx,ecx
  2121f3:	48 85 c0             	test   rax,rax
  2121f6:	0f 85 31 03 00 00    	jne    21252d <benchmark.add+0x7ced>
  2121fc:	e9 4f 04 00 00       	jmp    212650 <benchmark.add+0x7e10>
                mem.copy(T, into[insert_index..], from[B_index..B_last]);
  212201:	ba ff 01 00 00       	mov    edx,0x1ff
  212206:	48 29 fa             	sub    rdx,rdi
  212209:	48 8b 74 24 20       	mov    rsi,QWORD PTR [rsp+0x20]
  21220e:	48 29 c6             	sub    rsi,rax
    assert(dest.len >= source.len);
  212211:	48 39 f2             	cmp    rdx,rsi
  212214:	0f 82 bc 23 00 00    	jb     2145d6 <benchmark.add+0x9d96>
    for (source) |s, i|
  21221a:	48 85 f6             	test   rsi,rsi
  21221d:	0f 84 2d 04 00 00    	je     212650 <benchmark.add+0x7e10>
  212223:	48 8b 94 24 f0 00 00 	mov    rdx,QWORD PTR [rsp+0xf0]
  21222a:	00 
  21222b:	48 8b 7c 24 10       	mov    rdi,QWORD PTR [rsp+0x10]
  212230:	48 8d 14 3a          	lea    rdx,[rdx+rdi*1]
  212234:	48 8b 5c 24 28       	mov    rbx,QWORD PTR [rsp+0x28]
  212239:	49 89 d8             	mov    r8,rbx
  21223c:	4c 01 c2             	add    rdx,r8
  21223f:	48 8b 5c 24 30       	mov    rbx,QWORD PTR [rsp+0x30]
  212244:	48 01 da             	add    rdx,rbx
  212247:	48 29 c2             	sub    rdx,rax
  21224a:	83 e6 07             	and    esi,0x7
  21224d:	48 83 fa 07          	cmp    rdx,0x7
  212251:	0f 83 12 03 00 00    	jae    212569 <benchmark.add+0x7d29>
  212257:	31 c0                	xor    eax,eax
  212259:	48 85 f6             	test   rsi,rsi
  21225c:	0f 85 af 03 00 00    	jne    212611 <benchmark.add+0x7dd1>
  212262:	e9 e9 03 00 00       	jmp    212650 <benchmark.add+0x7e10>
  212267:	48 89 c6             	mov    rsi,rax
  21226a:	48 29 ce             	sub    rsi,rcx
  21226d:	bf 70 00 00 00       	mov    edi,0x70
  212272:	31 d2                	xor    edx,edx
  212274:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21227b:	00 00 00 00 00 
        dest[i] = s;
  212280:	c4 c1 78 10 44 3c 90 	vmovups xmm0,XMMWORD PTR [r12+rdi*1-0x70]
  212287:	c5 f8 11 84 3c 30 02 	vmovups XMMWORD PTR [rsp+rdi*1+0x230],xmm0
  21228e:	00 00 
  212290:	c4 c1 78 10 44 3c a0 	vmovups xmm0,XMMWORD PTR [r12+rdi*1-0x60]
  212297:	c5 f8 11 84 3c 40 02 	vmovups XMMWORD PTR [rsp+rdi*1+0x240],xmm0
  21229e:	00 00 
  2122a0:	c4 c1 78 10 44 3c b0 	vmovups xmm0,XMMWORD PTR [r12+rdi*1-0x50]
  2122a7:	c5 f8 11 84 3c 50 02 	vmovups XMMWORD PTR [rsp+rdi*1+0x250],xmm0
  2122ae:	00 00 
  2122b0:	c4 c1 78 10 44 3c c0 	vmovups xmm0,XMMWORD PTR [r12+rdi*1-0x40]
  2122b7:	c5 f8 11 84 3c 60 02 	vmovups XMMWORD PTR [rsp+rdi*1+0x260],xmm0
  2122be:	00 00 
  2122c0:	c4 c1 78 10 44 3c d0 	vmovups xmm0,XMMWORD PTR [r12+rdi*1-0x30]
  2122c7:	c5 f8 11 84 3c 70 02 	vmovups XMMWORD PTR [rsp+rdi*1+0x270],xmm0
  2122ce:	00 00 
  2122d0:	c4 c1 78 10 44 3c e0 	vmovups xmm0,XMMWORD PTR [r12+rdi*1-0x20]
  2122d7:	c5 f8 11 84 3c 80 02 	vmovups XMMWORD PTR [rsp+rdi*1+0x280],xmm0
  2122de:	00 00 
  2122e0:	c4 c1 78 10 44 3c f0 	vmovups xmm0,XMMWORD PTR [r12+rdi*1-0x10]
  2122e7:	c5 f8 11 84 3c 90 02 	vmovups XMMWORD PTR [rsp+rdi*1+0x290],xmm0
  2122ee:	00 00 
  2122f0:	c4 c1 7a 6f 04 3c    	vmovdqu xmm0,XMMWORD PTR [r12+rdi*1]
  2122f6:	c5 fa 7f 84 3c a0 02 	vmovdqu XMMWORD PTR [rsp+rdi*1+0x2a0],xmm0
  2122fd:	00 00 
    for (source) |s, i|
  2122ff:	48 83 c2 08          	add    rdx,0x8
  212303:	48 83 ef 80          	sub    rdi,0xffffffffffffff80
  212307:	48 39 d6             	cmp    rsi,rdx
  21230a:	0f 85 70 ff ff ff    	jne    212280 <benchmark.add+0x7a40>
  212310:	48 85 c9             	test   rcx,rcx
  212313:	48 8b 7c 24 20       	mov    rdi,QWORD PTR [rsp+0x20]
  212318:	74 2f                	je     212349 <benchmark.add+0x7b09>
  21231a:	48 c1 e2 04          	shl    rdx,0x4
  21231e:	48 f7 d9             	neg    rcx
  212321:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  212328:	0f 1f 84 00 00 00 00 
  21232f:	00 
        dest[i] = s;
  212330:	c4 c1 7a 6f 04 14    	vmovdqu xmm0,XMMWORD PTR [r12+rdx*1]
  212336:	c5 fa 7f 84 14 a0 02 	vmovdqu XMMWORD PTR [rsp+rdx*1+0x2a0],xmm0
  21233d:	00 00 
    for (source) |s, i|
  21233f:	48 83 c2 10          	add    rdx,0x10
  212343:	48 83 c1 01          	add    rcx,0x1
  212347:	75 e7                	jne    212330 <benchmark.add+0x7af0>
                        mem.copy(T, cache[A1.length()..], items[B1.start..B1.end]);
  212349:	b9 00 02 00 00       	mov    ecx,0x200
  21234e:	48 29 c1             	sub    rcx,rax
  212351:	48 89 fa             	mov    rdx,rdi
  212354:	4c 29 f2             	sub    rdx,r14
    assert(dest.len >= source.len);
  212357:	48 39 d1             	cmp    rcx,rdx
  21235a:	0f 82 76 22 00 00    	jb     2145d6 <benchmark.add+0x9d96>
    for (source) |s, i|
  212360:	48 85 d2             	test   rdx,rdx
  212363:	0f 84 e7 02 00 00    	je     212650 <benchmark.add+0x7e10>
  212369:	48 8b 44 24 40       	mov    rax,QWORD PTR [rsp+0x40]
  21236e:	48 8b 4c 24 30       	mov    rcx,QWORD PTR [rsp+0x30]
  212373:	48 8d 0c 08          	lea    rcx,[rax+rcx*1]
  212377:	89 d0                	mov    eax,edx
  212379:	83 e0 07             	and    eax,0x7
  21237c:	48 83 f9 07          	cmp    rcx,0x7
  212380:	73 10                	jae    212392 <benchmark.add+0x7b52>
  212382:	31 c9                	xor    ecx,ecx
  212384:	48 85 c0             	test   rax,rax
  212387:	0f 85 b7 00 00 00    	jne    212444 <benchmark.add+0x7c04>
  21238d:	e9 be 02 00 00       	jmp    212650 <benchmark.add+0x7e10>
  212392:	48 29 c2             	sub    rdx,rax
  212395:	48 8b 8c 24 e8 00 00 	mov    rcx,QWORD PTR [rsp+0xe8]
  21239c:	00 
  21239d:	49 8d 0c 0f          	lea    rcx,[r15+rcx*1]
  2123a1:	48 8b 74 24 10       	mov    rsi,QWORD PTR [rsp+0x10]
  2123a6:	48 8b 7c 24 28       	mov    rdi,QWORD PTR [rsp+0x28]
  2123ab:	48 8d 34 3e          	lea    rsi,[rsi+rdi*1]
  2123af:	48 c1 e6 04          	shl    rsi,0x4
  2123b3:	48 01 ce             	add    rsi,rcx
  2123b6:	48 83 c6 70          	add    rsi,0x70
  2123ba:	48 c1 e7 04          	shl    rdi,0x4
  2123be:	48 03 bc 24 98 01 00 	add    rdi,QWORD PTR [rsp+0x198]
  2123c5:	00 
  2123c6:	31 db                	xor    ebx,ebx
  2123c8:	31 c9                	xor    ecx,ecx
  2123ca:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
        dest[i] = s;
  2123d0:	c5 f8 10 44 1e 90    	vmovups xmm0,XMMWORD PTR [rsi+rbx*1-0x70]
  2123d6:	c5 f8 11 44 1f 90    	vmovups XMMWORD PTR [rdi+rbx*1-0x70],xmm0
  2123dc:	c5 f8 10 44 1e a0    	vmovups xmm0,XMMWORD PTR [rsi+rbx*1-0x60]
  2123e2:	c5 f8 11 44 1f a0    	vmovups XMMWORD PTR [rdi+rbx*1-0x60],xmm0
  2123e8:	c5 f8 10 44 1e b0    	vmovups xmm0,XMMWORD PTR [rsi+rbx*1-0x50]
  2123ee:	c5 f8 11 44 1f b0    	vmovups XMMWORD PTR [rdi+rbx*1-0x50],xmm0
  2123f4:	c5 f8 10 44 1e c0    	vmovups xmm0,XMMWORD PTR [rsi+rbx*1-0x40]
  2123fa:	c5 f8 11 44 1f c0    	vmovups XMMWORD PTR [rdi+rbx*1-0x40],xmm0
  212400:	c5 f8 10 44 1e d0    	vmovups xmm0,XMMWORD PTR [rsi+rbx*1-0x30]
  212406:	c5 f8 11 44 1f d0    	vmovups XMMWORD PTR [rdi+rbx*1-0x30],xmm0
  21240c:	c5 f8 10 44 1e e0    	vmovups xmm0,XMMWORD PTR [rsi+rbx*1-0x20]
  212412:	c5 f8 11 44 1f e0    	vmovups XMMWORD PTR [rdi+rbx*1-0x20],xmm0
  212418:	c5 f8 10 44 1e f0    	vmovups xmm0,XMMWORD PTR [rsi+rbx*1-0x10]
  21241e:	c5 f8 11 44 1f f0    	vmovups XMMWORD PTR [rdi+rbx*1-0x10],xmm0
  212424:	c5 fa 6f 04 1e       	vmovdqu xmm0,XMMWORD PTR [rsi+rbx*1]
  212429:	c5 fa 7f 04 1f       	vmovdqu XMMWORD PTR [rdi+rbx*1],xmm0
    for (source) |s, i|
  21242e:	48 83 c1 08          	add    rcx,0x8
  212432:	48 83 eb 80          	sub    rbx,0xffffffffffffff80
  212436:	48 39 ca             	cmp    rdx,rcx
  212439:	75 95                	jne    2123d0 <benchmark.add+0x7b90>
  21243b:	48 85 c0             	test   rax,rax
  21243e:	0f 84 0c 02 00 00    	je     212650 <benchmark.add+0x7e10>
  212444:	48 8b 7c 24 28       	mov    rdi,QWORD PTR [rsp+0x28]
  212449:	48 8d 14 39          	lea    rdx,[rcx+rdi*1]
  21244d:	48 c1 e2 04          	shl    rdx,0x4
  212451:	48 03 94 24 70 01 00 	add    rdx,QWORD PTR [rsp+0x170]
  212458:	00 
  212459:	48 8b b4 24 e8 00 00 	mov    rsi,QWORD PTR [rsp+0xe8]
  212460:	00 
  212461:	49 8d 34 37          	lea    rsi,[r15+rsi*1]
  212465:	48 03 4c 24 10       	add    rcx,QWORD PTR [rsp+0x10]
  21246a:	48 01 f9             	add    rcx,rdi
  21246d:	48 c1 e1 04          	shl    rcx,0x4
  212471:	48 01 f1             	add    rcx,rsi
  212474:	48 f7 d8             	neg    rax
  212477:	31 f6                	xor    esi,esi
  212479:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
        dest[i] = s;
  212480:	c5 fa 6f 04 31       	vmovdqu xmm0,XMMWORD PTR [rcx+rsi*1]
  212485:	c5 fa 7f 04 32       	vmovdqu XMMWORD PTR [rdx+rsi*1],xmm0
    for (source) |s, i|
  21248a:	48 83 c6 10          	add    rsi,0x10
  21248e:	48 83 c0 01          	add    rax,0x1
  212492:	75 ec                	jne    212480 <benchmark.add+0x7c40>
  212494:	e9 b7 01 00 00       	jmp    212650 <benchmark.add+0x7e10>
  212499:	49 29 c6             	sub    r14,rax
  21249c:	ba 70 00 00 00       	mov    edx,0x70
  2124a1:	31 c9                	xor    ecx,ecx
  2124a3:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  2124aa:	84 00 00 00 00 00 
        dest[i] = s;
  2124b0:	c5 f8 10 44 16 90    	vmovups xmm0,XMMWORD PTR [rsi+rdx*1-0x70]
  2124b6:	c4 c1 78 11 44 15 a0 	vmovups XMMWORD PTR [r13+rdx*1-0x60],xmm0
  2124bd:	c5 f8 10 44 16 a0    	vmovups xmm0,XMMWORD PTR [rsi+rdx*1-0x60]
  2124c3:	c4 c1 78 11 44 15 b0 	vmovups XMMWORD PTR [r13+rdx*1-0x50],xmm0
  2124ca:	c5 f8 10 44 16 b0    	vmovups xmm0,XMMWORD PTR [rsi+rdx*1-0x50]
  2124d0:	c4 c1 78 11 44 15 c0 	vmovups XMMWORD PTR [r13+rdx*1-0x40],xmm0
  2124d7:	c5 f8 10 44 16 c0    	vmovups xmm0,XMMWORD PTR [rsi+rdx*1-0x40]
  2124dd:	c4 c1 78 11 44 15 d0 	vmovups XMMWORD PTR [r13+rdx*1-0x30],xmm0
  2124e4:	c5 f8 10 44 16 d0    	vmovups xmm0,XMMWORD PTR [rsi+rdx*1-0x30]
  2124ea:	c4 c1 78 11 44 15 e0 	vmovups XMMWORD PTR [r13+rdx*1-0x20],xmm0
  2124f1:	c5 f8 10 44 16 e0    	vmovups xmm0,XMMWORD PTR [rsi+rdx*1-0x20]
  2124f7:	c4 c1 78 11 44 15 f0 	vmovups XMMWORD PTR [r13+rdx*1-0x10],xmm0
  2124fe:	c5 f8 10 44 16 f0    	vmovups xmm0,XMMWORD PTR [rsi+rdx*1-0x10]
  212504:	c4 c1 78 11 44 15 00 	vmovups XMMWORD PTR [r13+rdx*1+0x0],xmm0
  21250b:	c5 fa 6f 04 16       	vmovdqu xmm0,XMMWORD PTR [rsi+rdx*1]
  212510:	c4 c1 7a 7f 44 15 10 	vmovdqu XMMWORD PTR [r13+rdx*1+0x10],xmm0
    for (source) |s, i|
  212517:	48 83 c1 08          	add    rcx,0x8
  21251b:	48 83 ea 80          	sub    rdx,0xffffffffffffff80
  21251f:	49 39 ce             	cmp    r14,rcx
  212522:	75 8c                	jne    2124b0 <benchmark.add+0x7c70>
  212524:	48 85 c0             	test   rax,rax
  212527:	0f 84 23 01 00 00    	je     212650 <benchmark.add+0x7e10>
  21252d:	48 c1 e1 04          	shl    rcx,0x4
  212531:	48 8d 94 24 b0 02 00 	lea    rdx,[rsp+0x2b0]
  212538:	00 
  212539:	48 8d 14 0a          	lea    rdx,[rdx+rcx*1]
  21253d:	4c 01 ca             	add    rdx,r9
  212540:	4c 01 f9             	add    rcx,r15
  212543:	4c 01 d1             	add    rcx,r10
  212546:	48 f7 d8             	neg    rax
  212549:	31 f6                	xor    esi,esi
  21254b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
        dest[i] = s;
  212550:	c5 fa 6f 04 31       	vmovdqu xmm0,XMMWORD PTR [rcx+rsi*1]
  212555:	c5 fa 7f 04 32       	vmovdqu XMMWORD PTR [rdx+rsi*1],xmm0
    for (source) |s, i|
  21255a:	48 83 c6 10          	add    rsi,0x10
  21255e:	48 83 c0 01          	add    rax,0x1
  212562:	75 ec                	jne    212550 <benchmark.add+0x7d10>
  212564:	e9 e7 00 00 00       	jmp    212650 <benchmark.add+0x7e10>
  212569:	48 8b 94 24 e0 00 00 	mov    rdx,QWORD PTR [rsp+0xe0]
  212570:	00 
  212571:	48 8d 3c 3a          	lea    rdi,[rdx+rdi*1]
  212575:	48 01 df             	add    rdi,rbx
  212578:	4c 01 c7             	add    rdi,r8
  21257b:	48 29 f7             	sub    rdi,rsi
  21257e:	48 29 c7             	sub    rdi,rax
  212581:	ba 70 00 00 00       	mov    edx,0x70
  212586:	31 c0                	xor    eax,eax
  212588:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  21258f:	00 
        dest[i] = s;
  212590:	c4 c1 78 10 44 13 90 	vmovups xmm0,XMMWORD PTR [r11+rdx*1-0x70]
  212597:	c4 c1 78 11 44 15 a0 	vmovups XMMWORD PTR [r13+rdx*1-0x60],xmm0
  21259e:	c4 c1 78 10 44 13 a0 	vmovups xmm0,XMMWORD PTR [r11+rdx*1-0x60]
  2125a5:	c4 c1 78 11 44 15 b0 	vmovups XMMWORD PTR [r13+rdx*1-0x50],xmm0
  2125ac:	c4 c1 78 10 44 13 b0 	vmovups xmm0,XMMWORD PTR [r11+rdx*1-0x50]
  2125b3:	c4 c1 78 11 44 15 c0 	vmovups XMMWORD PTR [r13+rdx*1-0x40],xmm0
  2125ba:	c4 c1 78 10 44 13 c0 	vmovups xmm0,XMMWORD PTR [r11+rdx*1-0x40]
  2125c1:	c4 c1 78 11 44 15 d0 	vmovups XMMWORD PTR [r13+rdx*1-0x30],xmm0
  2125c8:	c4 c1 78 10 44 13 d0 	vmovups xmm0,XMMWORD PTR [r11+rdx*1-0x30]
  2125cf:	c4 c1 78 11 44 15 e0 	vmovups XMMWORD PTR [r13+rdx*1-0x20],xmm0
  2125d6:	c4 c1 78 10 44 13 e0 	vmovups xmm0,XMMWORD PTR [r11+rdx*1-0x20]
  2125dd:	c4 c1 78 11 44 15 f0 	vmovups XMMWORD PTR [r13+rdx*1-0x10],xmm0
  2125e4:	c4 c1 78 10 44 13 f0 	vmovups xmm0,XMMWORD PTR [r11+rdx*1-0x10]
  2125eb:	c4 c1 78 11 44 15 00 	vmovups XMMWORD PTR [r13+rdx*1+0x0],xmm0
  2125f2:	c4 c1 7a 6f 04 13    	vmovdqu xmm0,XMMWORD PTR [r11+rdx*1]
  2125f8:	c4 c1 7a 7f 44 15 10 	vmovdqu XMMWORD PTR [r13+rdx*1+0x10],xmm0
    for (source) |s, i|
  2125ff:	48 83 c0 08          	add    rax,0x8
  212603:	48 83 ea 80          	sub    rdx,0xffffffffffffff80
  212607:	48 39 c7             	cmp    rdi,rax
  21260a:	75 84                	jne    212590 <benchmark.add+0x7d50>
  21260c:	48 85 f6             	test   rsi,rsi
  21260f:	74 3f                	je     212650 <benchmark.add+0x7e10>
  212611:	48 c1 e0 04          	shl    rax,0x4
  212615:	48 8d 94 24 b0 02 00 	lea    rdx,[rsp+0x2b0]
  21261c:	00 
  21261d:	48 8d 14 02          	lea    rdx,[rdx+rax*1]
  212621:	4c 01 ca             	add    rdx,r9
  212624:	4c 01 f8             	add    rax,r15
  212627:	48 01 c8             	add    rax,rcx
  21262a:	48 f7 de             	neg    rsi
  21262d:	31 c9                	xor    ecx,ecx
  21262f:	90                   	nop
        dest[i] = s;
  212630:	c5 fa 6f 04 08       	vmovdqu xmm0,XMMWORD PTR [rax+rcx*1]
  212635:	c5 fa 7f 04 0a       	vmovdqu XMMWORD PTR [rdx+rcx*1],xmm0
    for (source) |s, i|
  21263a:	48 83 c1 10          	add    rcx,0x10
  21263e:	48 83 c6 01          	add    rsi,0x1
  212642:	75 ec                	jne    212630 <benchmark.add+0x7df0>
  212644:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21264b:	00 00 00 00 00 
  212650:	4c 8b 4c 24 60       	mov    r9,QWORD PTR [rsp+0x60]
                    if (lessThan(items[B2.end - 1], items[A2.start])) {
  212655:	4c 89 c8             	mov    rax,r9
  212658:	48 c1 e0 04          	shl    rax,0x4
  21265c:	48 8b 4c 24 78       	mov    rcx,QWORD PTR [rsp+0x78]
  212661:	4d 8b 14 0f          	mov    r10,QWORD PTR [r15+rcx*1]
  212665:	4d 39 54 07 f0       	cmp    QWORD PTR [r15+rax*1-0x10],r10
  21266a:	0f 83 90 00 00 00    	jae    212700 <benchmark.add+0x7ec0>
  212670:	48 8b 54 24 20       	mov    rdx,QWORD PTR [rsp+0x20]
        return self.end - self.start;
  212675:	48 89 d0             	mov    rax,rdx
  212678:	4c 8b 6c 24 10       	mov    r13,QWORD PTR [rsp+0x10]
  21267d:	4c 29 e8             	sub    rax,r13
  212680:	4c 89 cf             	mov    rdi,r9
  212683:	48 8b 5c 24 18       	mov    rbx,QWORD PTR [rsp+0x18]
  212688:	48 29 df             	sub    rdi,rbx
  21268b:	49 89 c2             	mov    r10,rax
                        mem.copy(T, cache[A1.length() + B2.length() ..], items[A2.start..A2.end]);
  21268e:	48 8d 04 07          	lea    rax,[rdi+rax*1]
  212692:	b9 00 02 00 00       	mov    ecx,0x200
  212697:	48 29 c1             	sub    rcx,rax
  21269a:	48 29 d3             	sub    rbx,rdx
    assert(dest.len >= source.len);
  21269d:	48 39 d9             	cmp    rcx,rbx
  2126a0:	4c 8b 5c 24 58       	mov    r11,QWORD PTR [rsp+0x58]
  2126a5:	4c 8b 74 24 38       	mov    r14,QWORD PTR [rsp+0x38]
  2126aa:	0f 82 26 1f 00 00    	jb     2145d6 <benchmark.add+0x9d96>
    for (source) |s, i|
  2126b0:	48 85 db             	test   rbx,rbx
  2126b3:	4c 8b 44 24 30       	mov    r8,QWORD PTR [rsp+0x30]
  2126b8:	0f 84 a6 02 00 00    	je     212964 <benchmark.add+0x8124>
  2126be:	48 8b 44 24 40       	mov    rax,QWORD PTR [rsp+0x40]
  2126c3:	4a 8d 0c 30          	lea    rcx,[rax+r14*1]
  2126c7:	89 d8                	mov    eax,ebx
  2126c9:	83 e0 07             	and    eax,0x7
  2126cc:	48 83 f9 07          	cmp    rcx,0x7
  2126d0:	0f 83 6a 01 00 00    	jae    212840 <benchmark.add+0x8000>
  2126d6:	4d 89 d9             	mov    r9,r11
  2126d9:	31 c9                	xor    ecx,ecx
  2126db:	48 85 c0             	test   rax,rax
  2126de:	4d 89 cb             	mov    r11,r9
  2126e1:	4c 8b 4c 24 60       	mov    r9,QWORD PTR [rsp+0x60]
  2126e6:	0f 85 1c 02 00 00    	jne    212908 <benchmark.add+0x80c8>
  2126ec:	e9 73 02 00 00       	jmp    212964 <benchmark.add+0x8124>
  2126f1:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  2126f8:	0f 1f 84 00 00 00 00 
  2126ff:	00 
  212700:	48 8b 5c 24 18       	mov    rbx,QWORD PTR [rsp+0x18]
                    } else if (lessThan(items[B2.start], items[A2.end - 1])) {
  212705:	48 89 d8             	mov    rax,rbx
  212708:	48 c1 e0 04          	shl    rax,0x4
  21270c:	4d 8b 1c 07          	mov    r11,QWORD PTR [r15+rax*1]
  212710:	48 8b 4c 24 20       	mov    rcx,QWORD PTR [rsp+0x20]
        return self.end - self.start;
  212715:	48 89 ca             	mov    rdx,rcx
  212718:	4c 8b 6c 24 10       	mov    r13,QWORD PTR [rsp+0x10]
  21271d:	4c 29 ea             	sub    rdx,r13
  212720:	be 00 02 00 00       	mov    esi,0x200
  212725:	48 29 d6             	sub    rsi,rdx
  212728:	4d 3b 5c 07 f0       	cmp    r11,QWORD PTR [r15+rax*1-0x10]
                    } else if (lessThan(items[B2.start], items[A2.end - 1])) {
  21272d:	48 89 54 24 78       	mov    QWORD PTR [rsp+0x78],rdx
  212732:	0f 83 b8 00 00 00    	jae    2127f0 <benchmark.add+0x7fb0>
  212738:	48 89 b4 24 80 01 00 	mov    QWORD PTR [rsp+0x180],rsi
  21273f:	00 
  212740:	48 89 d0             	mov    rax,rdx
  212743:	48 c1 e0 04          	shl    rax,0x4
  212747:	4c 8d 0c 04          	lea    r9,[rsp+rax*1]
  21274b:	49 81 c1 a0 02 00 00 	add    r9,0x2a0
  212752:	48 89 ca             	mov    rdx,rcx
  212755:	45 31 ed             	xor    r13d,r13d
  212758:	eb 14                	jmp    21276e <benchmark.add+0x7f2e>
  21275a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  212760:	48 89 d9             	mov    rcx,rbx
  212763:	48 c1 e1 04          	shl    rcx,0x4
  212767:	4d 8b 1c 0f          	mov    r11,QWORD PTR [r15+rcx*1]
  21276b:	4c 8b 10             	mov    r10,QWORD PTR [rax]
        if (!lessThan(from[B_index], from[A_index])) {
  21276e:	48 89 d9             	mov    rcx,rbx
  212771:	48 c1 e1 04          	shl    rcx,0x4
  212775:	4d 8d 04 0f          	lea    r8,[r15+rcx*1]
  212779:	48 89 d6             	mov    rsi,rdx
  21277c:	48 c1 e6 04          	shl    rsi,0x4
  212780:	49 8d 04 37          	lea    rax,[r15+rsi*1]
  212784:	4d 89 ee             	mov    r14,r13
  212787:	49 c1 e6 04          	shl    r14,0x4
  21278b:	4b 8d 3c 31          	lea    rdi,[r9+r14*1]
  21278f:	4d 39 d3             	cmp    r11,r10
  212792:	73 2c                	jae    2127c0 <benchmark.add+0x7f80>
            into[insert_index] = from[B_index];
  212794:	c4 c1 7a 6f 00       	vmovdqu xmm0,XMMWORD PTR [r8]
  212799:	c5 fa 7f 07          	vmovdqu XMMWORD PTR [rdi],xmm0
            B_index += 1;
  21279d:	48 83 c3 01          	add    rbx,0x1
            insert_index += 1;
  2127a1:	49 83 c5 01          	add    r13,0x1
            if (B_index == B_last) {
  2127a5:	48 3b 5c 24 60       	cmp    rbx,QWORD PTR [rsp+0x60]
  2127aa:	75 b4                	jne    212760 <benchmark.add+0x7f20>
  2127ac:	e9 0b 03 00 00       	jmp    212abc <benchmark.add+0x827c>
  2127b1:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  2127b8:	0f 1f 84 00 00 00 00 
  2127bf:	00 
            into[insert_index] = from[A_index];
  2127c0:	c5 fa 6f 00          	vmovdqu xmm0,XMMWORD PTR [rax]
  2127c4:	c5 fa 7f 07          	vmovdqu XMMWORD PTR [rdi],xmm0
            A_index += 1;
  2127c8:	48 83 c2 01          	add    rdx,0x1
            insert_index += 1;
  2127cc:	49 83 c5 01          	add    r13,0x1
            if (A_index == A_last) {
  2127d0:	48 3b 54 24 18       	cmp    rdx,QWORD PTR [rsp+0x18]
  2127d5:	0f 84 64 03 00 00    	je     212b3f <benchmark.add+0x82ff>
  2127db:	48 89 d0             	mov    rax,rdx
  2127de:	48 c1 e0 04          	shl    rax,0x4
  2127e2:	4c 01 f8             	add    rax,r15
  2127e5:	e9 76 ff ff ff       	jmp    212760 <benchmark.add+0x7f20>
  2127ea:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
                        mem.copy(T, cache[A1.length()..], items[A2.start..A2.end]);
  2127f0:	49 89 d8             	mov    r8,rbx
  2127f3:	49 29 c8             	sub    r8,rcx
    assert(dest.len >= source.len);
  2127f6:	4c 39 c6             	cmp    rsi,r8
  2127f9:	4c 8b 74 24 38       	mov    r14,QWORD PTR [rsp+0x38]
  2127fe:	0f 82 d2 1d 00 00    	jb     2145d6 <benchmark.add+0x9d96>
    for (source) |s, i|
  212804:	4d 85 c0             	test   r8,r8
  212807:	4c 8b 5c 24 58       	mov    r11,QWORD PTR [rsp+0x58]
  21280c:	0f 84 d2 04 00 00    	je     212ce4 <benchmark.add+0x84a4>
  212812:	48 8b 44 24 40       	mov    rax,QWORD PTR [rsp+0x40]
  212817:	4a 8d 0c 30          	lea    rcx,[rax+r14*1]
  21281b:	44 89 c0             	mov    eax,r8d
  21281e:	83 e0 07             	and    eax,0x7
  212821:	48 83 f9 07          	cmp    rcx,0x7
  212825:	0f 83 95 03 00 00    	jae    212bc0 <benchmark.add+0x8380>
  21282b:	31 d2                	xor    edx,edx
  21282d:	48 85 c0             	test   rax,rax
  212830:	48 8b 5c 24 18       	mov    rbx,QWORD PTR [rsp+0x18]
  212835:	0f 85 4a 04 00 00    	jne    212c85 <benchmark.add+0x8445>
  21283b:	e9 a4 04 00 00       	jmp    212ce4 <benchmark.add+0x84a4>
  212840:	48 29 c3             	sub    rbx,rax
  212843:	48 8b 8c 24 e0 00 00 	mov    rcx,QWORD PTR [rsp+0xe0]
  21284a:	00 
  21284b:	48 c1 e1 04          	shl    rcx,0x4
  21284f:	4c 01 f9             	add    rcx,r15
  212852:	48 8b 74 24 28       	mov    rsi,QWORD PTR [rsp+0x28]
  212857:	4a 8d 14 2e          	lea    rdx,[rsi+r13*1]
  21285b:	4c 01 c2             	add    rdx,r8
  21285e:	48 c1 e2 04          	shl    rdx,0x4
  212862:	48 01 ca             	add    rdx,rcx
  212865:	48 83 c2 70          	add    rdx,0x70
  212869:	49 8d 34 30          	lea    rsi,[r8+rsi*1]
  21286d:	4d 89 d9             	mov    r9,r11
  212870:	4c 01 de             	add    rsi,r11
  212873:	48 c1 e6 04          	shl    rsi,0x4
  212877:	48 03 b4 24 78 01 00 	add    rsi,QWORD PTR [rsp+0x178]
  21287e:	00 
  21287f:	49 89 db             	mov    r11,rbx
  212882:	31 db                	xor    ebx,ebx
  212884:	31 c9                	xor    ecx,ecx
  212886:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  21288d:	00 00 00 
        dest[i] = s;
  212890:	c5 f8 10 44 1a 90    	vmovups xmm0,XMMWORD PTR [rdx+rbx*1-0x70]
  212896:	c5 f8 11 44 1e 90    	vmovups XMMWORD PTR [rsi+rbx*1-0x70],xmm0
  21289c:	c5 f8 10 44 1a a0    	vmovups xmm0,XMMWORD PTR [rdx+rbx*1-0x60]
  2128a2:	c5 f8 11 44 1e a0    	vmovups XMMWORD PTR [rsi+rbx*1-0x60],xmm0
  2128a8:	c5 f8 10 44 1a b0    	vmovups xmm0,XMMWORD PTR [rdx+rbx*1-0x50]
  2128ae:	c5 f8 11 44 1e b0    	vmovups XMMWORD PTR [rsi+rbx*1-0x50],xmm0
  2128b4:	c5 f8 10 44 1a c0    	vmovups xmm0,XMMWORD PTR [rdx+rbx*1-0x40]
  2128ba:	c5 f8 11 44 1e c0    	vmovups XMMWORD PTR [rsi+rbx*1-0x40],xmm0
  2128c0:	c5 f8 10 44 1a d0    	vmovups xmm0,XMMWORD PTR [rdx+rbx*1-0x30]
  2128c6:	c5 f8 11 44 1e d0    	vmovups XMMWORD PTR [rsi+rbx*1-0x30],xmm0
  2128cc:	c5 f8 10 44 1a e0    	vmovups xmm0,XMMWORD PTR [rdx+rbx*1-0x20]
  2128d2:	c5 f8 11 44 1e e0    	vmovups XMMWORD PTR [rsi+rbx*1-0x20],xmm0
  2128d8:	c5 f8 10 44 1a f0    	vmovups xmm0,XMMWORD PTR [rdx+rbx*1-0x10]
  2128de:	c5 f8 11 44 1e f0    	vmovups XMMWORD PTR [rsi+rbx*1-0x10],xmm0
  2128e4:	c5 fa 6f 04 1a       	vmovdqu xmm0,XMMWORD PTR [rdx+rbx*1]
  2128e9:	c5 fa 7f 04 1e       	vmovdqu XMMWORD PTR [rsi+rbx*1],xmm0
    for (source) |s, i|
  2128ee:	48 83 c1 08          	add    rcx,0x8
  2128f2:	48 83 eb 80          	sub    rbx,0xffffffffffffff80
  2128f6:	49 39 cb             	cmp    r11,rcx
  2128f9:	75 95                	jne    212890 <benchmark.add+0x8050>
  2128fb:	48 85 c0             	test   rax,rax
  2128fe:	4d 89 cb             	mov    r11,r9
  212901:	4c 8b 4c 24 60       	mov    r9,QWORD PTR [rsp+0x60]
  212906:	74 5c                	je     212964 <benchmark.add+0x8124>
  212908:	4a 8d 14 01          	lea    rdx,[rcx+r8*1]
  21290c:	48 8b 74 24 28       	mov    rsi,QWORD PTR [rsp+0x28]
  212911:	48 89 f3             	mov    rbx,rsi
  212914:	48 01 da             	add    rdx,rbx
  212917:	4c 01 da             	add    rdx,r11
  21291a:	48 c1 e2 04          	shl    rdx,0x4
  21291e:	48 03 94 24 68 01 00 	add    rdx,QWORD PTR [rsp+0x168]
  212925:	00 
  212926:	48 8b b4 24 e0 00 00 	mov    rsi,QWORD PTR [rsp+0xe0]
  21292d:	00 
  21292e:	48 c1 e6 04          	shl    rsi,0x4
  212932:	4c 01 fe             	add    rsi,r15
  212935:	4c 01 e9             	add    rcx,r13
  212938:	48 01 d9             	add    rcx,rbx
  21293b:	4c 01 c1             	add    rcx,r8
  21293e:	48 c1 e1 04          	shl    rcx,0x4
  212942:	48 01 f1             	add    rcx,rsi
  212945:	48 f7 d8             	neg    rax
  212948:	31 f6                	xor    esi,esi
  21294a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
        dest[i] = s;
  212950:	c5 fa 6f 04 31       	vmovdqu xmm0,XMMWORD PTR [rcx+rsi*1]
  212955:	c5 fa 7f 04 32       	vmovdqu XMMWORD PTR [rdx+rsi*1],xmm0
    for (source) |s, i|
  21295a:	48 83 c6 10          	add    rsi,0x10
  21295e:	48 83 c0 01          	add    rax,0x1
  212962:	75 ec                	jne    212950 <benchmark.add+0x8110>
                        mem.copy(T, cache[A1.length()..], items[B2.start..B2.end]);
  212964:	b8 00 02 00 00       	mov    eax,0x200
  212969:	4c 89 d6             	mov    rsi,r10
  21296c:	48 29 f0             	sub    rax,rsi
    assert(dest.len >= source.len);
  21296f:	48 39 f8             	cmp    rax,rdi
  212972:	0f 82 5e 1c 00 00    	jb     2145d6 <benchmark.add+0x9d96>
    for (source) |s, i|
  212978:	48 85 ff             	test   rdi,rdi
  21297b:	0f 84 fd 06 00 00    	je     21307e <benchmark.add+0x883e>
  212981:	48 8b 44 24 40       	mov    rax,QWORD PTR [rsp+0x40]
  212986:	4a 8d 0c 18          	lea    rcx,[rax+r11*1]
  21298a:	89 f8                	mov    eax,edi
  21298c:	83 e0 07             	and    eax,0x7
  21298f:	48 83 f9 07          	cmp    rcx,0x7
  212993:	73 10                	jae    2129a5 <benchmark.add+0x8165>
  212995:	31 c9                	xor    ecx,ecx
  212997:	48 85 c0             	test   rax,rax
  21299a:	0f 85 c0 00 00 00    	jne    212a60 <benchmark.add+0x8220>
  2129a0:	e9 0f 01 00 00       	jmp    212ab4 <benchmark.add+0x8274>
  2129a5:	48 29 c7             	sub    rdi,rax
  2129a8:	48 8b 8c 24 48 01 00 	mov    rcx,QWORD PTR [rsp+0x148]
  2129af:	00 
  2129b0:	49 8d 0c 0f          	lea    rcx,[r15+rcx*1]
  2129b4:	4b 8d 14 28          	lea    rdx,[r8+r13*1]
  2129b8:	48 8b 74 24 28       	mov    rsi,QWORD PTR [rsp+0x28]
  2129bd:	48 01 f2             	add    rdx,rsi
  2129c0:	4c 01 f2             	add    rdx,r14
  2129c3:	48 c1 e2 04          	shl    rdx,0x4
  2129c7:	48 01 ca             	add    rdx,rcx
  2129ca:	48 83 c2 70          	add    rdx,0x70
  2129ce:	4a 8d 34 06          	lea    rsi,[rsi+r8*1]
  2129d2:	48 c1 e6 04          	shl    rsi,0x4
  2129d6:	48 03 b4 24 60 01 00 	add    rsi,QWORD PTR [rsp+0x160]
  2129dd:	00 
  2129de:	31 db                	xor    ebx,ebx
  2129e0:	31 c9                	xor    ecx,ecx
  2129e2:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  2129e9:	1f 84 00 00 00 00 00 
        dest[i] = s;
  2129f0:	c5 f8 10 44 1a 90    	vmovups xmm0,XMMWORD PTR [rdx+rbx*1-0x70]
  2129f6:	c5 f8 11 44 1e 90    	vmovups XMMWORD PTR [rsi+rbx*1-0x70],xmm0
  2129fc:	c5 f8 10 44 1a a0    	vmovups xmm0,XMMWORD PTR [rdx+rbx*1-0x60]
  212a02:	c5 f8 11 44 1e a0    	vmovups XMMWORD PTR [rsi+rbx*1-0x60],xmm0
  212a08:	c5 f8 10 44 1a b0    	vmovups xmm0,XMMWORD PTR [rdx+rbx*1-0x50]
  212a0e:	c5 f8 11 44 1e b0    	vmovups XMMWORD PTR [rsi+rbx*1-0x50],xmm0
  212a14:	c5 f8 10 44 1a c0    	vmovups xmm0,XMMWORD PTR [rdx+rbx*1-0x40]
  212a1a:	c5 f8 11 44 1e c0    	vmovups XMMWORD PTR [rsi+rbx*1-0x40],xmm0
  212a20:	c5 f8 10 44 1a d0    	vmovups xmm0,XMMWORD PTR [rdx+rbx*1-0x30]
  212a26:	c5 f8 11 44 1e d0    	vmovups XMMWORD PTR [rsi+rbx*1-0x30],xmm0
  212a2c:	c5 f8 10 44 1a e0    	vmovups xmm0,XMMWORD PTR [rdx+rbx*1-0x20]
  212a32:	c5 f8 11 44 1e e0    	vmovups XMMWORD PTR [rsi+rbx*1-0x20],xmm0
  212a38:	c5 f8 10 44 1a f0    	vmovups xmm0,XMMWORD PTR [rdx+rbx*1-0x10]
  212a3e:	c5 f8 11 44 1e f0    	vmovups XMMWORD PTR [rsi+rbx*1-0x10],xmm0
  212a44:	c5 fa 6f 04 1a       	vmovdqu xmm0,XMMWORD PTR [rdx+rbx*1]
  212a49:	c5 fa 7f 04 1e       	vmovdqu XMMWORD PTR [rsi+rbx*1],xmm0
    for (source) |s, i|
  212a4e:	48 83 c1 08          	add    rcx,0x8
  212a52:	48 83 eb 80          	sub    rbx,0xffffffffffffff80
  212a56:	48 39 cf             	cmp    rdi,rcx
  212a59:	75 95                	jne    2129f0 <benchmark.add+0x81b0>
  212a5b:	48 85 c0             	test   rax,rax
  212a5e:	74 54                	je     212ab4 <benchmark.add+0x8274>
  212a60:	48 8b 7c 24 28       	mov    rdi,QWORD PTR [rsp+0x28]
  212a65:	48 8d 14 39          	lea    rdx,[rcx+rdi*1]
  212a69:	4c 01 c2             	add    rdx,r8
  212a6c:	48 c1 e2 04          	shl    rdx,0x4
  212a70:	48 03 94 24 28 01 00 	add    rdx,QWORD PTR [rsp+0x128]
  212a77:	00 
  212a78:	48 8b b4 24 48 01 00 	mov    rsi,QWORD PTR [rsp+0x148]
  212a7f:	00 
  212a80:	49 8d 34 37          	lea    rsi,[r15+rsi*1]
  212a84:	4c 01 e9             	add    rcx,r13
  212a87:	4c 01 c1             	add    rcx,r8
  212a8a:	48 01 f9             	add    rcx,rdi
  212a8d:	4c 01 f1             	add    rcx,r14
  212a90:	48 c1 e1 04          	shl    rcx,0x4
  212a94:	48 01 f1             	add    rcx,rsi
  212a97:	48 f7 d8             	neg    rax
  212a9a:	31 f6                	xor    esi,esi
  212a9c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
        dest[i] = s;
  212aa0:	c5 fa 6f 04 31       	vmovdqu xmm0,XMMWORD PTR [rcx+rsi*1]
  212aa5:	c5 fa 7f 04 32       	vmovdqu XMMWORD PTR [rdx+rsi*1],xmm0
    for (source) |s, i|
  212aaa:	48 83 c6 10          	add    rsi,0x10
  212aae:	48 83 c0 01          	add    rax,0x1
  212ab2:	75 ec                	jne    212aa0 <benchmark.add+0x8260>
  212ab4:	4c 89 d6             	mov    rsi,r10
  212ab7:	e9 c2 05 00 00       	jmp    21307e <benchmark.add+0x883e>
  212abc:	48 8b 8c 24 80 01 00 	mov    rcx,QWORD PTR [rsp+0x180]
  212ac3:	00 
                mem.copy(T, into[insert_index..], from[A_index..A_last]);
  212ac4:	4c 29 e9             	sub    rcx,r13
  212ac7:	48 8b 7c 24 18       	mov    rdi,QWORD PTR [rsp+0x18]
  212acc:	48 29 d7             	sub    rdi,rdx
    assert(dest.len >= source.len);
  212acf:	48 39 f9             	cmp    rcx,rdi
  212ad2:	4c 8b 5c 24 58       	mov    r11,QWORD PTR [rsp+0x58]
  212ad7:	0f 82 f9 1a 00 00    	jb     2145d6 <benchmark.add+0x9d96>
    for (source) |s, i|
  212add:	48 85 ff             	test   rdi,rdi
  212ae0:	4c 8b 4c 24 60       	mov    r9,QWORD PTR [rsp+0x60]
  212ae5:	4c 8b 6c 24 10       	mov    r13,QWORD PTR [rsp+0x10]
  212aea:	0f 84 84 05 00 00    	je     213074 <benchmark.add+0x8834>
  212af0:	48 8b 8c 24 a0 01 00 	mov    rcx,QWORD PTR [rsp+0x1a0]
  212af7:	00 
  212af8:	4a 8d 0c 29          	lea    rcx,[rcx+r13*1]
  212afc:	4c 8b 54 24 28       	mov    r10,QWORD PTR [rsp+0x28]
  212b01:	4c 01 d1             	add    rcx,r10
  212b04:	4c 8b 44 24 30       	mov    r8,QWORD PTR [rsp+0x30]
  212b09:	4c 01 c1             	add    rcx,r8
  212b0c:	48 8b 5c 24 38       	mov    rbx,QWORD PTR [rsp+0x38]
  212b11:	48 01 d9             	add    rcx,rbx
  212b14:	48 29 d1             	sub    rcx,rdx
  212b17:	83 e7 07             	and    edi,0x7
  212b1a:	48 83 f9 07          	cmp    rcx,0x7
  212b1e:	49 89 fb             	mov    r11,rdi
  212b21:	0f 83 3c 03 00 00    	jae    212e63 <benchmark.add+0x8623>
  212b27:	4d 89 da             	mov    r10,r11
  212b2a:	31 c9                	xor    ecx,ecx
  212b2c:	4d 85 d2             	test   r10,r10
  212b2f:	4c 8b 5c 24 58       	mov    r11,QWORD PTR [rsp+0x58]
  212b34:	0f 85 df 03 00 00    	jne    212f19 <benchmark.add+0x86d9>
  212b3a:	e9 35 05 00 00       	jmp    213074 <benchmark.add+0x8834>
  212b3f:	48 8b 94 24 80 01 00 	mov    rdx,QWORD PTR [rsp+0x180]
  212b46:	00 
                mem.copy(T, into[insert_index..], from[B_index..B_last]);
  212b47:	4c 29 ea             	sub    rdx,r13
  212b4a:	4c 8b 4c 24 60       	mov    r9,QWORD PTR [rsp+0x60]
  212b4f:	4c 89 c8             	mov    rax,r9
  212b52:	48 29 d8             	sub    rax,rbx
    assert(dest.len >= source.len);
  212b55:	48 39 c2             	cmp    rdx,rax
  212b58:	4c 8b 5c 24 58       	mov    r11,QWORD PTR [rsp+0x58]
  212b5d:	48 8b 74 24 78       	mov    rsi,QWORD PTR [rsp+0x78]
  212b62:	0f 82 6e 1a 00 00    	jb     2145d6 <benchmark.add+0x9d96>
    for (source) |s, i|
  212b68:	48 85 c0             	test   rax,rax
  212b6b:	4c 8b 6c 24 10       	mov    r13,QWORD PTR [rsp+0x10]
  212b70:	0f 84 e3 02 00 00    	je     212e59 <benchmark.add+0x8619>
  212b76:	48 8b 94 24 a8 01 00 	mov    rdx,QWORD PTR [rsp+0x1a8]
  212b7d:	00 
  212b7e:	4a 8d 14 2a          	lea    rdx,[rdx+r13*1]
  212b82:	4c 8b 54 24 28       	mov    r10,QWORD PTR [rsp+0x28]
  212b87:	4c 89 d6             	mov    rsi,r10
  212b8a:	48 01 f2             	add    rdx,rsi
  212b8d:	4c 8b 54 24 30       	mov    r10,QWORD PTR [rsp+0x30]
  212b92:	4c 01 d2             	add    rdx,r10
  212b95:	48 8b 7c 24 38       	mov    rdi,QWORD PTR [rsp+0x38]
  212b9a:	48 01 fa             	add    rdx,rdi
  212b9d:	4c 01 da             	add    rdx,r11
  212ba0:	48 29 da             	sub    rdx,rbx
  212ba3:	83 e0 07             	and    eax,0x7
  212ba6:	48 83 fa 07          	cmp    rdx,0x7
  212baa:	0f 83 b9 03 00 00    	jae    212f69 <benchmark.add+0x8729>
  212bb0:	31 d2                	xor    edx,edx
  212bb2:	48 85 c0             	test   rax,rax
  212bb5:	0f 85 6d 04 00 00    	jne    213028 <benchmark.add+0x87e8>
  212bbb:	e9 b4 04 00 00       	jmp    213074 <benchmark.add+0x8834>
  212bc0:	4c 89 c6             	mov    rsi,r8
  212bc3:	48 29 c6             	sub    rsi,rax
  212bc6:	48 8b 8c 24 e0 00 00 	mov    rcx,QWORD PTR [rsp+0xe0]
  212bcd:	00 
  212bce:	48 c1 e1 04          	shl    rcx,0x4
  212bd2:	4c 01 f9             	add    rcx,r15
  212bd5:	48 8b 5c 24 28       	mov    rbx,QWORD PTR [rsp+0x28]
  212bda:	4a 8d 14 2b          	lea    rdx,[rbx+r13*1]
  212bde:	4c 8b 54 24 30       	mov    r10,QWORD PTR [rsp+0x30]
  212be3:	4c 01 d2             	add    rdx,r10
  212be6:	48 c1 e2 04          	shl    rdx,0x4
  212bea:	48 8d 3c 0a          	lea    rdi,[rdx+rcx*1]
  212bee:	48 83 c7 70          	add    rdi,0x70
  212bf2:	4a 8d 1c 13          	lea    rbx,[rbx+r10*1]
  212bf6:	48 c1 e3 04          	shl    rbx,0x4
  212bfa:	48 03 9c 24 60 01 00 	add    rbx,QWORD PTR [rsp+0x160]
  212c01:	00 
  212c02:	31 c9                	xor    ecx,ecx
  212c04:	31 d2                	xor    edx,edx
  212c06:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  212c0d:	00 00 00 
        dest[i] = s;
  212c10:	c5 f8 10 44 0f 90    	vmovups xmm0,XMMWORD PTR [rdi+rcx*1-0x70]
  212c16:	c5 f8 11 44 0b 90    	vmovups XMMWORD PTR [rbx+rcx*1-0x70],xmm0
  212c1c:	c5 f8 10 44 0f a0    	vmovups xmm0,XMMWORD PTR [rdi+rcx*1-0x60]
  212c22:	c5 f8 11 44 0b a0    	vmovups XMMWORD PTR [rbx+rcx*1-0x60],xmm0
  212c28:	c5 f8 10 44 0f b0    	vmovups xmm0,XMMWORD PTR [rdi+rcx*1-0x50]
  212c2e:	c5 f8 11 44 0b b0    	vmovups XMMWORD PTR [rbx+rcx*1-0x50],xmm0
  212c34:	c5 f8 10 44 0f c0    	vmovups xmm0,XMMWORD PTR [rdi+rcx*1-0x40]
  212c3a:	c5 f8 11 44 0b c0    	vmovups XMMWORD PTR [rbx+rcx*1-0x40],xmm0
  212c40:	c5 f8 10 44 0f d0    	vmovups xmm0,XMMWORD PTR [rdi+rcx*1-0x30]
  212c46:	c5 f8 11 44 0b d0    	vmovups XMMWORD PTR [rbx+rcx*1-0x30],xmm0
  212c4c:	c5 f8 10 44 0f e0    	vmovups xmm0,XMMWORD PTR [rdi+rcx*1-0x20]
  212c52:	c5 f8 11 44 0b e0    	vmovups XMMWORD PTR [rbx+rcx*1-0x20],xmm0
  212c58:	c5 f8 10 44 0f f0    	vmovups xmm0,XMMWORD PTR [rdi+rcx*1-0x10]
  212c5e:	c5 f8 11 44 0b f0    	vmovups XMMWORD PTR [rbx+rcx*1-0x10],xmm0
  212c64:	c5 fa 6f 04 0f       	vmovdqu xmm0,XMMWORD PTR [rdi+rcx*1]
  212c69:	c5 fa 7f 04 0b       	vmovdqu XMMWORD PTR [rbx+rcx*1],xmm0
    for (source) |s, i|
  212c6e:	48 83 c2 08          	add    rdx,0x8
  212c72:	48 83 e9 80          	sub    rcx,0xffffffffffffff80
  212c76:	48 39 d6             	cmp    rsi,rdx
  212c79:	75 95                	jne    212c10 <benchmark.add+0x83d0>
  212c7b:	48 85 c0             	test   rax,rax
  212c7e:	48 8b 5c 24 18       	mov    rbx,QWORD PTR [rsp+0x18]
  212c83:	74 5f                	je     212ce4 <benchmark.add+0x84a4>
  212c85:	48 8b 7c 24 28       	mov    rdi,QWORD PTR [rsp+0x28]
  212c8a:	48 8d 34 3a          	lea    rsi,[rdx+rdi*1]
  212c8e:	4c 8b 54 24 30       	mov    r10,QWORD PTR [rsp+0x30]
  212c93:	4c 01 d6             	add    rsi,r10
  212c96:	48 c1 e6 04          	shl    rsi,0x4
  212c9a:	48 03 b4 24 28 01 00 	add    rsi,QWORD PTR [rsp+0x128]
  212ca1:	00 
  212ca2:	48 8b 8c 24 e0 00 00 	mov    rcx,QWORD PTR [rsp+0xe0]
  212ca9:	00 
  212caa:	48 c1 e1 04          	shl    rcx,0x4
  212cae:	4c 01 f9             	add    rcx,r15
  212cb1:	4c 01 ea             	add    rdx,r13
  212cb4:	48 01 fa             	add    rdx,rdi
  212cb7:	4c 01 d2             	add    rdx,r10
  212cba:	48 c1 e2 04          	shl    rdx,0x4
  212cbe:	48 01 ca             	add    rdx,rcx
  212cc1:	48 f7 d8             	neg    rax
  212cc4:	31 c9                	xor    ecx,ecx
  212cc6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  212ccd:	00 00 00 
        dest[i] = s;
  212cd0:	c5 fa 6f 04 0a       	vmovdqu xmm0,XMMWORD PTR [rdx+rcx*1]
  212cd5:	c5 fa 7f 04 0e       	vmovdqu XMMWORD PTR [rsi+rcx*1],xmm0
    for (source) |s, i|
  212cda:	48 83 c1 10          	add    rcx,0x10
  212cde:	48 83 c0 01          	add    rax,0x1
  212ce2:	75 ec                	jne    212cd0 <benchmark.add+0x8490>
  212ce4:	48 8b 74 24 78       	mov    rsi,QWORD PTR [rsp+0x78]
                        mem.copy(T, cache[A1.length() + A2.length() ..], items[B2.start..B2.end]);
  212ce9:	49 01 f0             	add    r8,rsi
  212cec:	b8 00 02 00 00       	mov    eax,0x200
  212cf1:	4c 29 c0             	sub    rax,r8
  212cf4:	4c 89 ca             	mov    rdx,r9
  212cf7:	48 29 da             	sub    rdx,rbx
    assert(dest.len >= source.len);
  212cfa:	48 39 d0             	cmp    rax,rdx
  212cfd:	0f 82 d3 18 00 00    	jb     2145d6 <benchmark.add+0x9d96>
    for (source) |s, i|
  212d03:	48 85 d2             	test   rdx,rdx
  212d06:	0f 84 72 03 00 00    	je     21307e <benchmark.add+0x883e>
  212d0c:	48 8b 44 24 40       	mov    rax,QWORD PTR [rsp+0x40]
  212d11:	4a 8d 0c 18          	lea    rcx,[rax+r11*1]
  212d15:	89 d0                	mov    eax,edx
  212d17:	83 e0 07             	and    eax,0x7
  212d1a:	48 83 f9 07          	cmp    rcx,0x7
  212d1e:	73 10                	jae    212d30 <benchmark.add+0x84f0>
  212d20:	31 c9                	xor    ecx,ecx
  212d22:	48 85 c0             	test   rax,rax
  212d25:	0f 85 c9 00 00 00    	jne    212df4 <benchmark.add+0x85b4>
  212d2b:	e9 49 03 00 00       	jmp    213079 <benchmark.add+0x8839>
  212d30:	48 29 c2             	sub    rdx,rax
  212d33:	48 8b 8c 24 48 01 00 	mov    rcx,QWORD PTR [rsp+0x148]
  212d3a:	00 
  212d3b:	49 8d 0c 0f          	lea    rcx,[r15+rcx*1]
  212d3f:	48 8b 5c 24 30       	mov    rbx,QWORD PTR [rsp+0x30]
  212d44:	4a 8d 34 2b          	lea    rsi,[rbx+r13*1]
  212d48:	48 8b 7c 24 28       	mov    rdi,QWORD PTR [rsp+0x28]
  212d4d:	48 01 fe             	add    rsi,rdi
  212d50:	4c 01 f6             	add    rsi,r14
  212d53:	48 c1 e6 04          	shl    rsi,0x4
  212d57:	48 01 ce             	add    rsi,rcx
  212d5a:	48 8d 3c 3b          	lea    rdi,[rbx+rdi*1]
  212d5e:	4c 01 f7             	add    rdi,r14
  212d61:	48 c1 e7 04          	shl    rdi,0x4
  212d65:	48 03 bc 24 68 01 00 	add    rdi,QWORD PTR [rsp+0x168]
  212d6c:	00 
  212d6d:	bb 70 00 00 00       	mov    ebx,0x70
  212d72:	31 c9                	xor    ecx,ecx
  212d74:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  212d7b:	00 00 00 00 00 
        dest[i] = s;
  212d80:	c5 f8 10 44 1e 90    	vmovups xmm0,XMMWORD PTR [rsi+rbx*1-0x70]
  212d86:	c5 f8 11 44 1f 90    	vmovups XMMWORD PTR [rdi+rbx*1-0x70],xmm0
  212d8c:	c5 f8 10 44 1e a0    	vmovups xmm0,XMMWORD PTR [rsi+rbx*1-0x60]
  212d92:	c5 f8 11 44 1f a0    	vmovups XMMWORD PTR [rdi+rbx*1-0x60],xmm0
  212d98:	c5 f8 10 44 1e b0    	vmovups xmm0,XMMWORD PTR [rsi+rbx*1-0x50]
  212d9e:	c5 f8 11 44 1f b0    	vmovups XMMWORD PTR [rdi+rbx*1-0x50],xmm0
  212da4:	c5 f8 10 44 1e c0    	vmovups xmm0,XMMWORD PTR [rsi+rbx*1-0x40]
  212daa:	c5 f8 11 44 1f c0    	vmovups XMMWORD PTR [rdi+rbx*1-0x40],xmm0
  212db0:	c5 f8 10 44 1e d0    	vmovups xmm0,XMMWORD PTR [rsi+rbx*1-0x30]
  212db6:	c5 f8 11 44 1f d0    	vmovups XMMWORD PTR [rdi+rbx*1-0x30],xmm0
  212dbc:	c5 f8 10 44 1e e0    	vmovups xmm0,XMMWORD PTR [rsi+rbx*1-0x20]
  212dc2:	c5 f8 11 44 1f e0    	vmovups XMMWORD PTR [rdi+rbx*1-0x20],xmm0
  212dc8:	c5 f8 10 44 1e f0    	vmovups xmm0,XMMWORD PTR [rsi+rbx*1-0x10]
  212dce:	c5 f8 11 44 1f f0    	vmovups XMMWORD PTR [rdi+rbx*1-0x10],xmm0
  212dd4:	c5 fa 6f 04 1e       	vmovdqu xmm0,XMMWORD PTR [rsi+rbx*1]
  212dd9:	c5 fa 7f 04 1f       	vmovdqu XMMWORD PTR [rdi+rbx*1],xmm0
    for (source) |s, i|
  212dde:	48 83 c1 08          	add    rcx,0x8
  212de2:	48 83 eb 80          	sub    rbx,0xffffffffffffff80
  212de6:	48 39 ca             	cmp    rdx,rcx
  212de9:	75 95                	jne    212d80 <benchmark.add+0x8540>
  212deb:	48 85 c0             	test   rax,rax
  212dee:	0f 84 85 02 00 00    	je     213079 <benchmark.add+0x8839>
  212df4:	48 8b 5c 24 30       	mov    rbx,QWORD PTR [rsp+0x30]
  212df9:	48 8d 14 19          	lea    rdx,[rcx+rbx*1]
  212dfd:	48 8b 74 24 28       	mov    rsi,QWORD PTR [rsp+0x28]
  212e02:	48 89 f7             	mov    rdi,rsi
  212e05:	48 01 fa             	add    rdx,rdi
  212e08:	4c 01 f2             	add    rdx,r14
  212e0b:	48 c1 e2 04          	shl    rdx,0x4
  212e0f:	48 03 94 24 68 01 00 	add    rdx,QWORD PTR [rsp+0x168]
  212e16:	00 
  212e17:	48 8b b4 24 48 01 00 	mov    rsi,QWORD PTR [rsp+0x148]
  212e1e:	00 
  212e1f:	49 8d 34 37          	lea    rsi,[r15+rsi*1]
  212e23:	4c 01 e9             	add    rcx,r13
  212e26:	48 01 d9             	add    rcx,rbx
  212e29:	48 01 f9             	add    rcx,rdi
  212e2c:	4c 01 f1             	add    rcx,r14
  212e2f:	48 c1 e1 04          	shl    rcx,0x4
  212e33:	48 01 f1             	add    rcx,rsi
  212e36:	48 f7 d8             	neg    rax
  212e39:	31 f6                	xor    esi,esi
  212e3b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
        dest[i] = s;
  212e40:	c5 fa 6f 04 31       	vmovdqu xmm0,XMMWORD PTR [rcx+rsi*1]
  212e45:	c5 fa 7f 04 32       	vmovdqu XMMWORD PTR [rdx+rsi*1],xmm0
    for (source) |s, i|
  212e4a:	48 83 c6 10          	add    rsi,0x10
  212e4e:	48 83 c0 01          	add    rax,0x1
  212e52:	75 ec                	jne    212e40 <benchmark.add+0x8600>
  212e54:	e9 20 02 00 00       	jmp    213079 <benchmark.add+0x8839>
  212e59:	4c 8b 74 24 38       	mov    r14,QWORD PTR [rsp+0x38]
  212e5e:	e9 1b 02 00 00       	jmp    21307e <benchmark.add+0x883e>
  212e63:	4b 8d 3c 02          	lea    rdi,[r10+r8*1]
  212e67:	48 c1 e7 04          	shl    rdi,0x4
  212e6b:	48 03 bc 24 28 01 00 	add    rdi,QWORD PTR [rsp+0x128]
  212e72:	00 
  212e73:	4c 01 f7             	add    rdi,r14
  212e76:	48 8b 8c 24 40 01 00 	mov    rcx,QWORD PTR [rsp+0x140]
  212e7d:	00 
  212e7e:	4a 8d 1c 29          	lea    rbx,[rcx+r13*1]
  212e82:	48 03 5c 24 38       	add    rbx,QWORD PTR [rsp+0x38]
  212e87:	4c 01 d3             	add    rbx,r10
  212e8a:	4c 01 c3             	add    rbx,r8
  212e8d:	4d 89 da             	mov    r10,r11
  212e90:	4c 29 db             	sub    rbx,r11
  212e93:	48 29 d3             	sub    rbx,rdx
  212e96:	ba 70 00 00 00       	mov    edx,0x70
  212e9b:	31 c9                	xor    ecx,ecx
  212e9d:	0f 1f 00             	nop    DWORD PTR [rax]
        dest[i] = s;
  212ea0:	c5 f8 10 44 10 90    	vmovups xmm0,XMMWORD PTR [rax+rdx*1-0x70]
  212ea6:	c5 f8 11 44 17 a0    	vmovups XMMWORD PTR [rdi+rdx*1-0x60],xmm0
  212eac:	c5 f8 10 44 10 a0    	vmovups xmm0,XMMWORD PTR [rax+rdx*1-0x60]
  212eb2:	c5 f8 11 44 17 b0    	vmovups XMMWORD PTR [rdi+rdx*1-0x50],xmm0
  212eb8:	c5 f8 10 44 10 b0    	vmovups xmm0,XMMWORD PTR [rax+rdx*1-0x50]
  212ebe:	c5 f8 11 44 17 c0    	vmovups XMMWORD PTR [rdi+rdx*1-0x40],xmm0
  212ec4:	c5 f8 10 44 10 c0    	vmovups xmm0,XMMWORD PTR [rax+rdx*1-0x40]
  212eca:	c5 f8 11 44 17 d0    	vmovups XMMWORD PTR [rdi+rdx*1-0x30],xmm0
  212ed0:	c5 f8 10 44 10 d0    	vmovups xmm0,XMMWORD PTR [rax+rdx*1-0x30]
  212ed6:	c5 f8 11 44 17 e0    	vmovups XMMWORD PTR [rdi+rdx*1-0x20],xmm0
  212edc:	c5 f8 10 44 10 e0    	vmovups xmm0,XMMWORD PTR [rax+rdx*1-0x20]
  212ee2:	c5 f8 11 44 17 f0    	vmovups XMMWORD PTR [rdi+rdx*1-0x10],xmm0
  212ee8:	c5 f8 10 44 10 f0    	vmovups xmm0,XMMWORD PTR [rax+rdx*1-0x10]
  212eee:	c5 f8 11 04 17       	vmovups XMMWORD PTR [rdi+rdx*1],xmm0
  212ef3:	c5 fa 6f 04 10       	vmovdqu xmm0,XMMWORD PTR [rax+rdx*1]
  212ef8:	c5 fa 7f 44 17 10    	vmovdqu XMMWORD PTR [rdi+rdx*1+0x10],xmm0
    for (source) |s, i|
  212efe:	48 83 c1 08          	add    rcx,0x8
  212f02:	48 83 ea 80          	sub    rdx,0xffffffffffffff80
  212f06:	48 39 cb             	cmp    rbx,rcx
  212f09:	75 95                	jne    212ea0 <benchmark.add+0x8660>
  212f0b:	4d 85 d2             	test   r10,r10
  212f0e:	4c 8b 5c 24 58       	mov    r11,QWORD PTR [rsp+0x58]
  212f13:	0f 84 5b 01 00 00    	je     213074 <benchmark.add+0x8834>
  212f19:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
  212f1e:	48 8d 04 01          	lea    rax,[rcx+rax*1]
  212f22:	4c 01 c0             	add    rax,r8
  212f25:	48 c1 e0 04          	shl    rax,0x4
  212f29:	48 03 84 24 d8 00 00 	add    rax,QWORD PTR [rsp+0xd8]
  212f30:	00 
  212f31:	4c 01 f0             	add    rax,r14
  212f34:	48 c1 e1 04          	shl    rcx,0x4
  212f38:	4c 01 f9             	add    rcx,r15
  212f3b:	48 01 f1             	add    rcx,rsi
  212f3e:	49 f7 da             	neg    r10
  212f41:	31 d2                	xor    edx,edx
  212f43:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  212f4a:	84 00 00 00 00 00 
        dest[i] = s;
  212f50:	c5 fa 6f 04 11       	vmovdqu xmm0,XMMWORD PTR [rcx+rdx*1]
  212f55:	c5 fa 7f 04 10       	vmovdqu XMMWORD PTR [rax+rdx*1],xmm0
    for (source) |s, i|
  212f5a:	48 83 c2 10          	add    rdx,0x10
  212f5e:	49 83 c2 01          	add    r10,0x1
  212f62:	75 ec                	jne    212f50 <benchmark.add+0x8710>
  212f64:	e9 0b 01 00 00       	jmp    213074 <benchmark.add+0x8834>
  212f69:	4a 8d 34 16          	lea    rsi,[rsi+r10*1]
  212f6d:	48 c1 e6 04          	shl    rsi,0x4
  212f71:	48 03 b4 24 28 01 00 	add    rsi,QWORD PTR [rsp+0x128]
  212f78:	00 
  212f79:	4c 01 f6             	add    rsi,r14
  212f7c:	48 8b 94 24 90 01 00 	mov    rdx,QWORD PTR [rsp+0x190]
  212f83:	00 
  212f84:	4a 8d 3c 2a          	lea    rdi,[rdx+r13*1]
  212f88:	48 03 7c 24 38       	add    rdi,QWORD PTR [rsp+0x38]
  212f8d:	4c 01 df             	add    rdi,r11
  212f90:	48 03 7c 24 28       	add    rdi,QWORD PTR [rsp+0x28]
  212f95:	4c 01 d7             	add    rdi,r10
  212f98:	48 29 c7             	sub    rdi,rax
  212f9b:	48 29 df             	sub    rdi,rbx
  212f9e:	bb 70 00 00 00       	mov    ebx,0x70
  212fa3:	31 d2                	xor    edx,edx
  212fa5:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  212fac:	00 00 00 00 
        dest[i] = s;
  212fb0:	c4 c1 78 10 44 18 90 	vmovups xmm0,XMMWORD PTR [r8+rbx*1-0x70]
  212fb7:	c5 f8 11 44 1e a0    	vmovups XMMWORD PTR [rsi+rbx*1-0x60],xmm0
  212fbd:	c4 c1 78 10 44 18 a0 	vmovups xmm0,XMMWORD PTR [r8+rbx*1-0x60]
  212fc4:	c5 f8 11 44 1e b0    	vmovups XMMWORD PTR [rsi+rbx*1-0x50],xmm0
  212fca:	c4 c1 78 10 44 18 b0 	vmovups xmm0,XMMWORD PTR [r8+rbx*1-0x50]
  212fd1:	c5 f8 11 44 1e c0    	vmovups XMMWORD PTR [rsi+rbx*1-0x40],xmm0
  212fd7:	c4 c1 78 10 44 18 c0 	vmovups xmm0,XMMWORD PTR [r8+rbx*1-0x40]
  212fde:	c5 f8 11 44 1e d0    	vmovups XMMWORD PTR [rsi+rbx*1-0x30],xmm0
  212fe4:	c4 c1 78 10 44 18 d0 	vmovups xmm0,XMMWORD PTR [r8+rbx*1-0x30]
  212feb:	c5 f8 11 44 1e e0    	vmovups XMMWORD PTR [rsi+rbx*1-0x20],xmm0
  212ff1:	c4 c1 78 10 44 18 e0 	vmovups xmm0,XMMWORD PTR [r8+rbx*1-0x20]
  212ff8:	c5 f8 11 44 1e f0    	vmovups XMMWORD PTR [rsi+rbx*1-0x10],xmm0
  212ffe:	c4 c1 78 10 44 18 f0 	vmovups xmm0,XMMWORD PTR [r8+rbx*1-0x10]
  213005:	c5 f8 11 04 1e       	vmovups XMMWORD PTR [rsi+rbx*1],xmm0
  21300a:	c4 c1 7a 6f 04 18    	vmovdqu xmm0,XMMWORD PTR [r8+rbx*1]
  213010:	c5 fa 7f 44 1e 10    	vmovdqu XMMWORD PTR [rsi+rbx*1+0x10],xmm0
    for (source) |s, i|
  213016:	48 83 c2 08          	add    rdx,0x8
  21301a:	48 83 eb 80          	sub    rbx,0xffffffffffffff80
  21301e:	48 39 d7             	cmp    rdi,rdx
  213021:	75 8d                	jne    212fb0 <benchmark.add+0x8770>
  213023:	48 85 c0             	test   rax,rax
  213026:	74 4c                	je     213074 <benchmark.add+0x8834>
  213028:	48 8b 74 24 28       	mov    rsi,QWORD PTR [rsp+0x28]
  21302d:	48 8d 34 32          	lea    rsi,[rdx+rsi*1]
  213031:	4c 01 d6             	add    rsi,r10
  213034:	48 c1 e6 04          	shl    rsi,0x4
  213038:	48 03 b4 24 d8 00 00 	add    rsi,QWORD PTR [rsp+0xd8]
  21303f:	00 
  213040:	4c 01 f6             	add    rsi,r14
  213043:	48 c1 e2 04          	shl    rdx,0x4
  213047:	4c 01 fa             	add    rdx,r15
  21304a:	48 01 ca             	add    rdx,rcx
  21304d:	48 f7 d8             	neg    rax
  213050:	31 c9                	xor    ecx,ecx
  213052:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  213059:	1f 84 00 00 00 00 00 
        dest[i] = s;
  213060:	c5 fa 6f 04 0a       	vmovdqu xmm0,XMMWORD PTR [rdx+rcx*1]
  213065:	c5 fa 7f 04 0e       	vmovdqu XMMWORD PTR [rsi+rcx*1],xmm0
    for (source) |s, i|
  21306a:	48 83 c1 10          	add    rcx,0x10
  21306e:	48 83 c0 01          	add    rax,0x1
  213072:	75 ec                	jne    213060 <benchmark.add+0x8820>
  213074:	4c 8b 74 24 38       	mov    r14,QWORD PTR [rsp+0x38]
  213079:	48 8b 74 24 78       	mov    rsi,QWORD PTR [rsp+0x78]
        return self.end - self.start;
  21307e:	4c 89 cf             	mov    rdi,r9
  213081:	48 2b 7c 24 20       	sub    rdi,QWORD PTR [rsp+0x20]
                    const B3 = Range.init(A1.length(), A1.length() + A2.length());
  213086:	4c 8d 04 3e          	lea    r8,[rsi+rdi*1]
                    if (lessThan(cache[B3.end - 1], cache[A3.start])) {
  21308a:	4c 89 c0             	mov    rax,r8
  21308d:	48 c1 e0 04          	shl    rax,0x4
  213091:	48 8b 84 04 90 02 00 	mov    rax,QWORD PTR [rsp+rax*1+0x290]
  213098:	00 
  213099:	48 3b 84 24 a0 02 00 	cmp    rax,QWORD PTR [rsp+0x2a0]
  2130a0:	00 
  2130a1:	73 4d                	jae    2130f0 <benchmark.add+0x88b0>
                        mem.copy(T, items[A1.start + A2.length() ..], cache[A3.start..A3.end]);
  2130a3:	4e 8d 04 2f          	lea    r8,[rdi+r13*1]
  2130a7:	48 8b 44 24 50       	mov    rax,QWORD PTR [rsp+0x50]
  2130ac:	48 89 c1             	mov    rcx,rax
  2130af:	4c 29 c1             	sub    rcx,r8
    assert(dest.len >= source.len);
  2130b2:	48 39 f1             	cmp    rcx,rsi
  2130b5:	0f 82 1b 15 00 00    	jb     2145d6 <benchmark.add+0x9d96>
    for (source) |s, i|
  2130bb:	48 85 f6             	test   rsi,rsi
  2130be:	0f 84 99 01 00 00    	je     21325d <benchmark.add+0x8a1d>
  2130c4:	48 8d 46 ff          	lea    rax,[rsi-0x1]
  2130c8:	89 f1                	mov    ecx,esi
  2130ca:	83 e1 07             	and    ecx,0x7
  2130cd:	48 83 f8 07          	cmp    rax,0x7
  2130d1:	0f 83 d9 01 00 00    	jae    2132b0 <benchmark.add+0x8a70>
  2130d7:	49 89 f1             	mov    r9,rsi
  2130da:	31 f6                	xor    esi,esi
  2130dc:	48 85 c9             	test   rcx,rcx
  2130df:	0f 85 88 02 00 00    	jne    21336d <benchmark.add+0x8b2d>
  2130e5:	e9 af 02 00 00       	jmp    213399 <benchmark.add+0x8b59>
  2130ea:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
                    } else if (lessThan(cache[B3.start], cache[A3.end - 1])) {
  2130f0:	48 89 f1             	mov    rcx,rsi
  2130f3:	48 c1 e1 04          	shl    rcx,0x4
  2130f7:	48 8b 84 0c a0 02 00 	mov    rax,QWORD PTR [rsp+rcx*1+0x2a0]
  2130fe:	00 
  2130ff:	48 8b 5c 24 50       	mov    rbx,QWORD PTR [rsp+0x50]
  213104:	48 89 da             	mov    rdx,rbx
  213107:	4c 29 ea             	sub    rdx,r13
  21310a:	48 3b 84 0c 90 02 00 	cmp    rax,QWORD PTR [rsp+rcx*1+0x290]
  213111:	00 
  213112:	0f 83 08 01 00 00    	jae    213220 <benchmark.add+0x89e0>
  213118:	48 89 54 24 20       	mov    QWORD PTR [rsp+0x20],rdx
  21311d:	49 89 f2             	mov    r10,rsi
  213120:	48 89 f2             	mov    rdx,rsi
  213123:	31 f6                	xor    esi,esi
  213125:	31 c9                	xor    ecx,ecx
  213127:	eb 16                	jmp    21313f <benchmark.add+0x88ff>
  213129:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  213130:	48 89 d0             	mov    rax,rdx
  213133:	48 c1 e0 04          	shl    rax,0x4
  213137:	48 8b 84 04 a0 02 00 	mov    rax,QWORD PTR [rsp+rax*1+0x2a0]
  21313e:	00 
        if (!lessThan(from[B_index], from[A_index])) {
  21313f:	48 89 d3             	mov    rbx,rdx
  213142:	48 c1 e3 04          	shl    rbx,0x4
  213146:	4c 8d 0c 1c          	lea    r9,[rsp+rbx*1]
  21314a:	49 81 c1 a0 02 00 00 	add    r9,0x2a0
  213151:	48 89 f7             	mov    rdi,rsi
  213154:	48 c1 e7 04          	shl    rdi,0x4
  213158:	4c 8d 2c 3c          	lea    r13,[rsp+rdi*1]
  21315c:	49 81 c5 a0 02 00 00 	add    r13,0x2a0
  213163:	49 89 cb             	mov    r11,rcx
  213166:	49 c1 e3 04          	shl    r11,0x4
  21316a:	4f 8d 34 1c          	lea    r14,[r12+r11*1]
  21316e:	48 3b 84 3c a0 02 00 	cmp    rax,QWORD PTR [rsp+rdi*1+0x2a0]
  213175:	00 
  213176:	73 28                	jae    2131a0 <benchmark.add+0x8960>
            into[insert_index] = from[B_index];
  213178:	c4 c1 7a 6f 01       	vmovdqu xmm0,XMMWORD PTR [r9]
  21317d:	c4 c1 7a 7f 06       	vmovdqu XMMWORD PTR [r14],xmm0
            B_index += 1;
  213182:	48 83 c2 01          	add    rdx,0x1
            insert_index += 1;
  213186:	48 83 c1 01          	add    rcx,0x1
            if (B_index == B_last) {
  21318a:	4c 39 c2             	cmp    rdx,r8
  21318d:	75 a1                	jne    213130 <benchmark.add+0x88f0>
  21318f:	e9 16 03 00 00       	jmp    2134aa <benchmark.add+0x8c6a>
  213194:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21319b:	00 00 00 00 00 
            into[insert_index] = from[A_index];
  2131a0:	c4 c1 7a 6f 45 00    	vmovdqu xmm0,XMMWORD PTR [r13+0x0]
  2131a6:	c4 c1 7a 7f 06       	vmovdqu XMMWORD PTR [r14],xmm0
            A_index += 1;
  2131ab:	48 83 c6 01          	add    rsi,0x1
            insert_index += 1;
  2131af:	48 83 c1 01          	add    rcx,0x1
            if (A_index == A_last) {
  2131b3:	4c 39 d6             	cmp    rsi,r10
  2131b6:	0f 85 74 ff ff ff    	jne    213130 <benchmark.add+0x88f0>
  2131bc:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
                mem.copy(T, into[insert_index..], from[B_index..B_last]);
  2131c1:	48 29 c8             	sub    rax,rcx
  2131c4:	49 29 d0             	sub    r8,rdx
    assert(dest.len >= source.len);
  2131c7:	4c 39 c0             	cmp    rax,r8
  2131ca:	0f 82 06 14 00 00    	jb     2145d6 <benchmark.add+0x9d96>
    for (source) |s, i|
  2131d0:	4d 85 c0             	test   r8,r8
  2131d3:	0f 84 37 07 00 00    	je     213910 <benchmark.add+0x90d0>
  2131d9:	48 8b 84 24 f0 00 00 	mov    rax,QWORD PTR [rsp+0xf0]
  2131e0:	00 
  2131e1:	4a 8d 04 10          	lea    rax,[rax+r10*1]
  2131e5:	48 8b 74 24 38       	mov    rsi,QWORD PTR [rsp+0x38]
  2131ea:	48 01 f0             	add    rax,rsi
  2131ed:	48 8b 4c 24 58       	mov    rcx,QWORD PTR [rsp+0x58]
  2131f2:	48 01 c8             	add    rax,rcx
  2131f5:	48 29 d0             	sub    rax,rdx
  2131f8:	41 83 e0 07          	and    r8d,0x7
  2131fc:	48 83 f8 07          	cmp    rax,0x7
  213200:	0f 83 33 05 00 00    	jae    213739 <benchmark.add+0x8ef9>
  213206:	31 c0                	xor    eax,eax
  213208:	4d 85 c0             	test   r8,r8
  21320b:	48 8b 4c 24 10       	mov    rcx,QWORD PTR [rsp+0x10]
  213210:	0f 85 d3 05 00 00    	jne    2137e9 <benchmark.add+0x8fa9>
  213216:	e9 f5 06 00 00       	jmp    213910 <benchmark.add+0x90d0>
  21321b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
    assert(dest.len >= source.len);
  213220:	48 39 f2             	cmp    rdx,rsi
  213223:	0f 82 ad 13 00 00    	jb     2145d6 <benchmark.add+0x9d96>
    for (source) |s, i|
  213229:	48 85 f6             	test   rsi,rsi
  21322c:	4c 8b 4c 24 28       	mov    r9,QWORD PTR [rsp+0x28]
  213231:	0f 84 9f 03 00 00    	je     2135d6 <benchmark.add+0x8d96>
  213237:	48 8d 46 ff          	lea    rax,[rsi-0x1]
  21323b:	89 f2                	mov    edx,esi
  21323d:	83 e2 07             	and    edx,0x7
  213240:	48 83 f8 07          	cmp    rax,0x7
  213244:	0f 83 ab 02 00 00    	jae    2134f5 <benchmark.add+0x8cb5>
  21324a:	49 89 f0             	mov    r8,rsi
  21324d:	31 f6                	xor    esi,esi
  21324f:	48 85 d2             	test   rdx,rdx
  213252:	0f 85 4d 03 00 00    	jne    2135a5 <benchmark.add+0x8d65>
  213258:	e9 6c 03 00 00       	jmp    2135c9 <benchmark.add+0x8d89>
  21325d:	49 89 f1             	mov    r9,rsi
                        mem.copy(T, items[A1.start..], cache[B3.start..B3.end]);
  213260:	4c 29 e8             	sub    rax,r13
    assert(dest.len >= source.len);
  213263:	48 39 f8             	cmp    rax,rdi
  213266:	0f 82 6a 13 00 00    	jb     2145d6 <benchmark.add+0x9d96>
    for (source) |s, i|
  21326c:	48 85 ff             	test   rdi,rdi
  21326f:	0f 84 9b 06 00 00    	je     213910 <benchmark.add+0x90d0>
  213275:	48 8b 84 24 f0 00 00 	mov    rax,QWORD PTR [rsp+0xf0]
  21327c:	00 
  21327d:	48 8b 4c 24 38       	mov    rcx,QWORD PTR [rsp+0x38]
  213282:	48 8d 04 08          	lea    rax,[rax+rcx*1]
  213286:	48 8b 74 24 58       	mov    rsi,QWORD PTR [rsp+0x58]
  21328b:	48 01 f0             	add    rax,rsi
  21328e:	83 e7 07             	and    edi,0x7
  213291:	48 83 f8 07          	cmp    rax,0x7
  213295:	0f 83 19 01 00 00    	jae    2133b4 <benchmark.add+0x8b74>
  21329b:	31 c9                	xor    ecx,ecx
  21329d:	48 85 ff             	test   rdi,rdi
  2132a0:	48 8b 44 24 10       	mov    rax,QWORD PTR [rsp+0x10]
  2132a5:	0f 85 be 01 00 00    	jne    213469 <benchmark.add+0x8c29>
  2132ab:	e9 60 06 00 00       	jmp    213910 <benchmark.add+0x90d0>
  2132b0:	49 89 f1             	mov    r9,rsi
  2132b3:	48 89 f0             	mov    rax,rsi
  2132b6:	48 29 c8             	sub    rax,rcx
  2132b9:	48 8b 94 24 e0 00 00 	mov    rdx,QWORD PTR [rsp+0xe0]
  2132c0:	00 
  2132c1:	48 c1 e2 04          	shl    rdx,0x4
  2132c5:	4c 01 fa             	add    rdx,r15
  2132c8:	4b 8d 1c 2e          	lea    rbx,[r14+r13*1]
  2132cc:	4c 01 db             	add    rbx,r11
  2132cf:	48 c1 e3 04          	shl    rbx,0x4
  2132d3:	48 01 d3             	add    rbx,rdx
  2132d6:	ba 70 00 00 00       	mov    edx,0x70
  2132db:	31 f6                	xor    esi,esi
  2132dd:	0f 1f 00             	nop    DWORD PTR [rax]
        dest[i] = s;
  2132e0:	c5 f8 10 84 14 30 02 	vmovups xmm0,XMMWORD PTR [rsp+rdx*1+0x230]
  2132e7:	00 00 
  2132e9:	c5 f8 11 44 13 90    	vmovups XMMWORD PTR [rbx+rdx*1-0x70],xmm0
  2132ef:	c5 f8 10 84 14 40 02 	vmovups xmm0,XMMWORD PTR [rsp+rdx*1+0x240]
  2132f6:	00 00 
  2132f8:	c5 f8 11 44 13 a0    	vmovups XMMWORD PTR [rbx+rdx*1-0x60],xmm0
  2132fe:	c5 f8 10 84 14 50 02 	vmovups xmm0,XMMWORD PTR [rsp+rdx*1+0x250]
  213305:	00 00 
  213307:	c5 f8 11 44 13 b0    	vmovups XMMWORD PTR [rbx+rdx*1-0x50],xmm0
  21330d:	c5 f8 10 84 14 60 02 	vmovups xmm0,XMMWORD PTR [rsp+rdx*1+0x260]
  213314:	00 00 
  213316:	c5 f8 11 44 13 c0    	vmovups XMMWORD PTR [rbx+rdx*1-0x40],xmm0
  21331c:	c5 f8 10 84 14 70 02 	vmovups xmm0,XMMWORD PTR [rsp+rdx*1+0x270]
  213323:	00 00 
  213325:	c5 f8 11 44 13 d0    	vmovups XMMWORD PTR [rbx+rdx*1-0x30],xmm0
  21332b:	c5 f8 10 84 14 80 02 	vmovups xmm0,XMMWORD PTR [rsp+rdx*1+0x280]
  213332:	00 00 
  213334:	c5 f8 11 44 13 e0    	vmovups XMMWORD PTR [rbx+rdx*1-0x20],xmm0
  21333a:	c5 f8 10 84 14 90 02 	vmovups xmm0,XMMWORD PTR [rsp+rdx*1+0x290]
  213341:	00 00 
  213343:	c5 f8 11 44 13 f0    	vmovups XMMWORD PTR [rbx+rdx*1-0x10],xmm0
  213349:	c5 fa 6f 84 14 a0 02 	vmovdqu xmm0,XMMWORD PTR [rsp+rdx*1+0x2a0]
  213350:	00 00 
  213352:	c5 fa 7f 04 13       	vmovdqu XMMWORD PTR [rbx+rdx*1],xmm0
    for (source) |s, i|
  213357:	48 83 c6 08          	add    rsi,0x8
  21335b:	48 83 ea 80          	sub    rdx,0xffffffffffffff80
  21335f:	48 39 f0             	cmp    rax,rsi
  213362:	0f 85 78 ff ff ff    	jne    2132e0 <benchmark.add+0x8aa0>
  213368:	48 85 c9             	test   rcx,rcx
  21336b:	74 2c                	je     213399 <benchmark.add+0x8b59>
  21336d:	49 c1 e0 04          	shl    r8,0x4
  213371:	4d 01 c7             	add    r15,r8
  213374:	48 c1 e6 04          	shl    rsi,0x4
  213378:	48 f7 d9             	neg    rcx
  21337b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
        dest[i] = s;
  213380:	c5 fa 6f 84 34 a0 02 	vmovdqu xmm0,XMMWORD PTR [rsp+rsi*1+0x2a0]
  213387:	00 00 
  213389:	c4 c1 7a 7f 04 37    	vmovdqu XMMWORD PTR [r15+rsi*1],xmm0
    for (source) |s, i|
  21338f:	48 83 c6 10          	add    rsi,0x10
  213393:	48 83 c1 01          	add    rcx,0x1
  213397:	75 e7                	jne    213380 <benchmark.add+0x8b40>
  213399:	4c 8b 7c 24 48       	mov    r15,QWORD PTR [rsp+0x48]
  21339e:	48 8b 44 24 50       	mov    rax,QWORD PTR [rsp+0x50]
  2133a3:	4c 29 e8             	sub    rax,r13
    assert(dest.len >= source.len);
  2133a6:	48 39 f8             	cmp    rax,rdi
  2133a9:	0f 83 bd fe ff ff    	jae    21326c <benchmark.add+0x8a2c>
  2133af:	e9 22 12 00 00       	jmp    2145d6 <benchmark.add+0x9d96>
  2133b4:	48 8b 9c 24 58 01 00 	mov    rbx,QWORD PTR [rsp+0x158]
  2133bb:	00 
  2133bc:	4c 01 fb             	add    rbx,r15
    for (source) |s, i|
  2133bf:	4c 89 c8             	mov    rax,r9
  2133c2:	48 c1 e0 04          	shl    rax,0x4
  2133c6:	48 8d 14 04          	lea    rdx,[rsp+rax*1]
  2133ca:	48 81 c2 a0 02 00 00 	add    rdx,0x2a0
  2133d1:	48 03 b4 24 e0 00 00 	add    rsi,QWORD PTR [rsp+0xe0]
  2133d8:	00 
  2133d9:	48 01 ce             	add    rsi,rcx
  2133dc:	48 29 fe             	sub    rsi,rdi
  2133df:	b8 70 00 00 00       	mov    eax,0x70
  2133e4:	31 c9                	xor    ecx,ecx
  2133e6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  2133ed:	00 00 00 
        dest[i] = s;
  2133f0:	c5 f8 10 44 02 90    	vmovups xmm0,XMMWORD PTR [rdx+rax*1-0x70]
  2133f6:	c5 f8 11 44 03 90    	vmovups XMMWORD PTR [rbx+rax*1-0x70],xmm0
  2133fc:	c5 f8 10 44 02 a0    	vmovups xmm0,XMMWORD PTR [rdx+rax*1-0x60]
  213402:	c5 f8 11 44 03 a0    	vmovups XMMWORD PTR [rbx+rax*1-0x60],xmm0
  213408:	c5 f8 10 44 02 b0    	vmovups xmm0,XMMWORD PTR [rdx+rax*1-0x50]
  21340e:	c5 f8 11 44 03 b0    	vmovups XMMWORD PTR [rbx+rax*1-0x50],xmm0
  213414:	c5 f8 10 44 02 c0    	vmovups xmm0,XMMWORD PTR [rdx+rax*1-0x40]
  21341a:	c5 f8 11 44 03 c0    	vmovups XMMWORD PTR [rbx+rax*1-0x40],xmm0
  213420:	c5 f8 10 44 02 d0    	vmovups xmm0,XMMWORD PTR [rdx+rax*1-0x30]
  213426:	c5 f8 11 44 03 d0    	vmovups XMMWORD PTR [rbx+rax*1-0x30],xmm0
  21342c:	c5 f8 10 44 02 e0    	vmovups xmm0,XMMWORD PTR [rdx+rax*1-0x20]
  213432:	c5 f8 11 44 03 e0    	vmovups XMMWORD PTR [rbx+rax*1-0x20],xmm0
  213438:	c5 f8 10 44 02 f0    	vmovups xmm0,XMMWORD PTR [rdx+rax*1-0x10]
  21343e:	c5 f8 11 44 03 f0    	vmovups XMMWORD PTR [rbx+rax*1-0x10],xmm0
  213444:	c5 fa 6f 04 02       	vmovdqu xmm0,XMMWORD PTR [rdx+rax*1]
  213449:	c5 fa 7f 04 03       	vmovdqu XMMWORD PTR [rbx+rax*1],xmm0
    for (source) |s, i|
  21344e:	48 83 c1 08          	add    rcx,0x8
  213452:	48 83 e8 80          	sub    rax,0xffffffffffffff80
  213456:	48 39 ce             	cmp    rsi,rcx
  213459:	75 95                	jne    2133f0 <benchmark.add+0x8bb0>
  21345b:	48 85 ff             	test   rdi,rdi
  21345e:	48 8b 44 24 10       	mov    rax,QWORD PTR [rsp+0x10]
  213463:	0f 84 a7 04 00 00    	je     213910 <benchmark.add+0x90d0>
  213469:	48 01 c8             	add    rax,rcx
  21346c:	48 c1 e0 04          	shl    rax,0x4
  213470:	49 01 c7             	add    r15,rax
  213473:	49 01 c9             	add    r9,rcx
  213476:	49 c1 e1 04          	shl    r9,0x4
  21347a:	4a 8d 04 0c          	lea    rax,[rsp+r9*1]
  21347e:	48 05 a0 02 00 00    	add    rax,0x2a0
  213484:	48 f7 df             	neg    rdi
  213487:	31 c9                	xor    ecx,ecx
  213489:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
        dest[i] = s;
  213490:	c5 fa 6f 04 08       	vmovdqu xmm0,XMMWORD PTR [rax+rcx*1]
  213495:	c4 c1 7a 7f 04 0f    	vmovdqu XMMWORD PTR [r15+rcx*1],xmm0
    for (source) |s, i|
  21349b:	48 83 c1 10          	add    rcx,0x10
  21349f:	48 83 c7 01          	add    rdi,0x1
  2134a3:	75 eb                	jne    213490 <benchmark.add+0x8c50>
  2134a5:	e9 66 04 00 00       	jmp    213910 <benchmark.add+0x90d0>
  2134aa:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
                mem.copy(T, into[insert_index..], from[A_index..A_last]);
  2134af:	48 29 c8             	sub    rax,rcx
  2134b2:	4c 89 d1             	mov    rcx,r10
  2134b5:	48 29 f1             	sub    rcx,rsi
    assert(dest.len >= source.len);
  2134b8:	48 39 c8             	cmp    rax,rcx
  2134bb:	0f 82 15 11 00 00    	jb     2145d6 <benchmark.add+0x9d96>
    for (source) |s, i|
  2134c1:	48 85 c9             	test   rcx,rcx
  2134c4:	0f 84 46 04 00 00    	je     213910 <benchmark.add+0x90d0>
  2134ca:	49 83 c2 ff          	add    r10,0xffffffffffffffff
  2134ce:	49 29 f2             	sub    r10,rsi
  2134d1:	89 ca                	mov    edx,ecx
  2134d3:	83 e2 07             	and    edx,0x7
  2134d6:	49 83 fa 07          	cmp    r10,0x7
  2134da:	0f 83 49 03 00 00    	jae    213829 <benchmark.add+0x8fe9>
  2134e0:	31 f6                	xor    esi,esi
  2134e2:	48 85 d2             	test   rdx,rdx
  2134e5:	48 8b 44 24 10       	mov    rax,QWORD PTR [rsp+0x10]
  2134ea:	0f 85 d6 03 00 00    	jne    2138c6 <benchmark.add+0x9086>
  2134f0:	e9 1b 04 00 00       	jmp    213910 <benchmark.add+0x90d0>
  2134f5:	49 89 f0             	mov    r8,rsi
  2134f8:	48 89 f0             	mov    rax,rsi
  2134fb:	48 29 d0             	sub    rax,rdx
  2134fe:	bb 70 00 00 00       	mov    ebx,0x70
  213503:	31 f6                	xor    esi,esi
  213505:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21350c:	00 00 00 00 
        dest[i] = s;
  213510:	c5 f8 10 84 1c 30 02 	vmovups xmm0,XMMWORD PTR [rsp+rbx*1+0x230]
  213517:	00 00 
  213519:	c4 c1 78 11 44 1c 90 	vmovups XMMWORD PTR [r12+rbx*1-0x70],xmm0
  213520:	c5 f8 10 84 1c 40 02 	vmovups xmm0,XMMWORD PTR [rsp+rbx*1+0x240]
  213527:	00 00 
  213529:	c4 c1 78 11 44 1c a0 	vmovups XMMWORD PTR [r12+rbx*1-0x60],xmm0
  213530:	c5 f8 10 84 1c 50 02 	vmovups xmm0,XMMWORD PTR [rsp+rbx*1+0x250]
  213537:	00 00 
  213539:	c4 c1 78 11 44 1c b0 	vmovups XMMWORD PTR [r12+rbx*1-0x50],xmm0
  213540:	c5 f8 10 84 1c 60 02 	vmovups xmm0,XMMWORD PTR [rsp+rbx*1+0x260]
  213547:	00 00 
  213549:	c4 c1 78 11 44 1c c0 	vmovups XMMWORD PTR [r12+rbx*1-0x40],xmm0
  213550:	c5 f8 10 84 1c 70 02 	vmovups xmm0,XMMWORD PTR [rsp+rbx*1+0x270]
  213557:	00 00 
  213559:	c4 c1 78 11 44 1c d0 	vmovups XMMWORD PTR [r12+rbx*1-0x30],xmm0
  213560:	c5 f8 10 84 1c 80 02 	vmovups xmm0,XMMWORD PTR [rsp+rbx*1+0x280]
  213567:	00 00 
  213569:	c4 c1 78 11 44 1c e0 	vmovups XMMWORD PTR [r12+rbx*1-0x20],xmm0
  213570:	c5 f8 10 84 1c 90 02 	vmovups xmm0,XMMWORD PTR [rsp+rbx*1+0x290]
  213577:	00 00 
  213579:	c4 c1 78 11 44 1c f0 	vmovups XMMWORD PTR [r12+rbx*1-0x10],xmm0
  213580:	c5 fa 6f 84 1c a0 02 	vmovdqu xmm0,XMMWORD PTR [rsp+rbx*1+0x2a0]
  213587:	00 00 
  213589:	c4 c1 7a 7f 04 1c    	vmovdqu XMMWORD PTR [r12+rbx*1],xmm0
    for (source) |s, i|
  21358f:	48 83 c6 08          	add    rsi,0x8
  213593:	48 83 eb 80          	sub    rbx,0xffffffffffffff80
  213597:	48 39 f0             	cmp    rax,rsi
  21359a:	0f 85 70 ff ff ff    	jne    213510 <benchmark.add+0x8cd0>
  2135a0:	48 85 d2             	test   rdx,rdx
  2135a3:	74 24                	je     2135c9 <benchmark.add+0x8d89>
  2135a5:	48 c1 e6 04          	shl    rsi,0x4
  2135a9:	48 f7 da             	neg    rdx
  2135ac:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
        dest[i] = s;
  2135b0:	c5 fa 6f 84 34 a0 02 	vmovdqu xmm0,XMMWORD PTR [rsp+rsi*1+0x2a0]
  2135b7:	00 00 
  2135b9:	c4 c1 7a 7f 04 34    	vmovdqu XMMWORD PTR [r12+rsi*1],xmm0
    for (source) |s, i|
  2135bf:	48 83 c6 10          	add    rsi,0x10
  2135c3:	48 83 c2 01          	add    rdx,0x1
  2135c7:	75 e7                	jne    2135b0 <benchmark.add+0x8d70>
                        mem.copy(T, items[A1.start + A1.length() ..], cache[B3.start..B3.end]);
  2135c9:	4c 8b 7c 24 48       	mov    r15,QWORD PTR [rsp+0x48]
  2135ce:	48 8b 5c 24 50       	mov    rbx,QWORD PTR [rsp+0x50]
  2135d3:	4c 89 c6             	mov    rsi,r8
  2135d6:	49 89 f3             	mov    r11,rsi
  2135d9:	48 2b 5c 24 20       	sub    rbx,QWORD PTR [rsp+0x20]
    assert(dest.len >= source.len);
  2135de:	48 39 fb             	cmp    rbx,rdi
  2135e1:	0f 82 ef 0f 00 00    	jb     2145d6 <benchmark.add+0x9d96>
    for (source) |s, i|
  2135e7:	48 85 ff             	test   rdi,rdi
  2135ea:	0f 84 20 03 00 00    	je     213910 <benchmark.add+0x90d0>
  2135f0:	48 8b 84 24 f0 00 00 	mov    rax,QWORD PTR [rsp+0xf0]
  2135f7:	00 
  2135f8:	4c 8b 44 24 38       	mov    r8,QWORD PTR [rsp+0x38]
  2135fd:	4a 8d 04 00          	lea    rax,[rax+r8*1]
  213601:	48 8b 5c 24 58       	mov    rbx,QWORD PTR [rsp+0x58]
  213606:	48 01 d8             	add    rax,rbx
  213609:	83 e7 07             	and    edi,0x7
  21360c:	48 83 f8 07          	cmp    rax,0x7
  213610:	73 15                	jae    213627 <benchmark.add+0x8de7>
  213612:	31 c9                	xor    ecx,ecx
  213614:	48 85 ff             	test   rdi,rdi
  213617:	48 8b 54 24 10       	mov    rdx,QWORD PTR [rsp+0x10]
  21361c:	0f 85 c7 00 00 00    	jne    2136e9 <benchmark.add+0x8ea9>
  213622:	e9 e9 02 00 00       	jmp    213910 <benchmark.add+0x90d0>
  213627:	48 8d 14 0c          	lea    rdx,[rsp+rcx*1]
  21362b:	48 81 c2 a0 02 00 00 	add    rdx,0x2a0
  213632:	48 8b 8c 24 e0 00 00 	mov    rcx,QWORD PTR [rsp+0xe0]
  213639:	00 
  21363a:	48 89 c8             	mov    rax,rcx
  21363d:	48 c1 e0 04          	shl    rax,0x4
  213641:	4c 01 f8             	add    rax,r15
  213644:	48 8b 74 24 10       	mov    rsi,QWORD PTR [rsp+0x10]
  213649:	4a 8d 34 0e          	lea    rsi,[rsi+r9*1]
  21364d:	48 03 74 24 30       	add    rsi,QWORD PTR [rsp+0x30]
  213652:	48 c1 e6 04          	shl    rsi,0x4
  213656:	48 01 c6             	add    rsi,rax
  213659:	48 01 cb             	add    rbx,rcx
  21365c:	4c 01 c3             	add    rbx,r8
  21365f:	48 29 fb             	sub    rbx,rdi
  213662:	b8 70 00 00 00       	mov    eax,0x70
  213667:	31 c9                	xor    ecx,ecx
  213669:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
        dest[i] = s;
  213670:	c5 f8 10 44 02 90    	vmovups xmm0,XMMWORD PTR [rdx+rax*1-0x70]
  213676:	c5 f8 11 44 06 90    	vmovups XMMWORD PTR [rsi+rax*1-0x70],xmm0
  21367c:	c5 f8 10 44 02 a0    	vmovups xmm0,XMMWORD PTR [rdx+rax*1-0x60]
  213682:	c5 f8 11 44 06 a0    	vmovups XMMWORD PTR [rsi+rax*1-0x60],xmm0
  213688:	c5 f8 10 44 02 b0    	vmovups xmm0,XMMWORD PTR [rdx+rax*1-0x50]
  21368e:	c5 f8 11 44 06 b0    	vmovups XMMWORD PTR [rsi+rax*1-0x50],xmm0
  213694:	c5 f8 10 44 02 c0    	vmovups xmm0,XMMWORD PTR [rdx+rax*1-0x40]
  21369a:	c5 f8 11 44 06 c0    	vmovups XMMWORD PTR [rsi+rax*1-0x40],xmm0
  2136a0:	c5 f8 10 44 02 d0    	vmovups xmm0,XMMWORD PTR [rdx+rax*1-0x30]
  2136a6:	c5 f8 11 44 06 d0    	vmovups XMMWORD PTR [rsi+rax*1-0x30],xmm0
  2136ac:	c5 f8 10 44 02 e0    	vmovups xmm0,XMMWORD PTR [rdx+rax*1-0x20]
  2136b2:	c5 f8 11 44 06 e0    	vmovups XMMWORD PTR [rsi+rax*1-0x20],xmm0
  2136b8:	c5 f8 10 44 02 f0    	vmovups xmm0,XMMWORD PTR [rdx+rax*1-0x10]
  2136be:	c5 f8 11 44 06 f0    	vmovups XMMWORD PTR [rsi+rax*1-0x10],xmm0
  2136c4:	c5 fa 6f 04 02       	vmovdqu xmm0,XMMWORD PTR [rdx+rax*1]
  2136c9:	c5 fa 7f 04 06       	vmovdqu XMMWORD PTR [rsi+rax*1],xmm0
    for (source) |s, i|
  2136ce:	48 83 c1 08          	add    rcx,0x8
  2136d2:	48 83 e8 80          	sub    rax,0xffffffffffffff80
  2136d6:	48 39 cb             	cmp    rbx,rcx
  2136d9:	75 95                	jne    213670 <benchmark.add+0x8e30>
  2136db:	48 85 ff             	test   rdi,rdi
  2136de:	48 8b 54 24 10       	mov    rdx,QWORD PTR [rsp+0x10]
  2136e3:	0f 84 27 02 00 00    	je     213910 <benchmark.add+0x90d0>
  2136e9:	48 8b 84 24 e0 00 00 	mov    rax,QWORD PTR [rsp+0xe0]
  2136f0:	00 
  2136f1:	48 c1 e0 04          	shl    rax,0x4
  2136f5:	49 01 c7             	add    r15,rax
  2136f8:	48 01 ca             	add    rdx,rcx
  2136fb:	4c 01 ca             	add    rdx,r9
  2136fe:	48 03 54 24 30       	add    rdx,QWORD PTR [rsp+0x30]
  213703:	48 c1 e2 04          	shl    rdx,0x4
  213707:	4c 01 fa             	add    rdx,r15
  21370a:	49 01 cb             	add    r11,rcx
  21370d:	49 c1 e3 04          	shl    r11,0x4
  213711:	4a 8d 04 1c          	lea    rax,[rsp+r11*1]
  213715:	48 05 a0 02 00 00    	add    rax,0x2a0
  21371b:	48 f7 df             	neg    rdi
  21371e:	31 c9                	xor    ecx,ecx
        dest[i] = s;
  213720:	c5 fa 6f 04 08       	vmovdqu xmm0,XMMWORD PTR [rax+rcx*1]
  213725:	c5 fa 7f 04 0a       	vmovdqu XMMWORD PTR [rdx+rcx*1],xmm0
    for (source) |s, i|
  21372a:	48 83 c1 10          	add    rcx,0x10
  21372e:	48 83 c7 01          	add    rdi,0x1
  213732:	75 ec                	jne    213720 <benchmark.add+0x8ee0>
  213734:	e9 d7 01 00 00       	jmp    213910 <benchmark.add+0x90d0>
  213739:	4c 03 94 24 e0 00 00 	add    r10,QWORD PTR [rsp+0xe0]
  213740:	00 
  213741:	49 01 ca             	add    r10,rcx
  213744:	49 01 f2             	add    r10,rsi
  213747:	4d 29 c2             	sub    r10,r8
  21374a:	49 29 d2             	sub    r10,rdx
  21374d:	b9 70 00 00 00       	mov    ecx,0x70
  213752:	31 c0                	xor    eax,eax
  213754:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21375b:	00 00 00 00 00 
        dest[i] = s;
  213760:	c4 c1 78 10 44 09 90 	vmovups xmm0,XMMWORD PTR [r9+rcx*1-0x70]
  213767:	c4 c1 78 11 44 0e a0 	vmovups XMMWORD PTR [r14+rcx*1-0x60],xmm0
  21376e:	c4 c1 78 10 44 09 a0 	vmovups xmm0,XMMWORD PTR [r9+rcx*1-0x60]
  213775:	c4 c1 78 11 44 0e b0 	vmovups XMMWORD PTR [r14+rcx*1-0x50],xmm0
  21377c:	c4 c1 78 10 44 09 b0 	vmovups xmm0,XMMWORD PTR [r9+rcx*1-0x50]
  213783:	c4 c1 78 11 44 0e c0 	vmovups XMMWORD PTR [r14+rcx*1-0x40],xmm0
  21378a:	c4 c1 78 10 44 09 c0 	vmovups xmm0,XMMWORD PTR [r9+rcx*1-0x40]
  213791:	c4 c1 78 11 44 0e d0 	vmovups XMMWORD PTR [r14+rcx*1-0x30],xmm0
  213798:	c4 c1 78 10 44 09 d0 	vmovups xmm0,XMMWORD PTR [r9+rcx*1-0x30]
  21379f:	c4 c1 78 11 44 0e e0 	vmovups XMMWORD PTR [r14+rcx*1-0x20],xmm0
  2137a6:	c4 c1 78 10 44 09 e0 	vmovups xmm0,XMMWORD PTR [r9+rcx*1-0x20]
  2137ad:	c4 c1 78 11 44 0e f0 	vmovups XMMWORD PTR [r14+rcx*1-0x10],xmm0
  2137b4:	c4 c1 78 10 44 09 f0 	vmovups xmm0,XMMWORD PTR [r9+rcx*1-0x10]
  2137bb:	c4 c1 78 11 04 0e    	vmovups XMMWORD PTR [r14+rcx*1],xmm0
  2137c1:	c4 c1 7a 6f 04 09    	vmovdqu xmm0,XMMWORD PTR [r9+rcx*1]
  2137c7:	c4 c1 7a 7f 44 0e 10 	vmovdqu XMMWORD PTR [r14+rcx*1+0x10],xmm0
    for (source) |s, i|
  2137ce:	48 83 c0 08          	add    rax,0x8
  2137d2:	48 83 e9 80          	sub    rcx,0xffffffffffffff80
  2137d6:	49 39 c2             	cmp    r10,rax
  2137d9:	75 85                	jne    213760 <benchmark.add+0x8f20>
  2137db:	4d 85 c0             	test   r8,r8
  2137de:	48 8b 4c 24 10       	mov    rcx,QWORD PTR [rsp+0x10]
  2137e3:	0f 84 27 01 00 00    	je     213910 <benchmark.add+0x90d0>
  2137e9:	48 01 c1             	add    rcx,rax
  2137ec:	48 c1 e1 04          	shl    rcx,0x4
  2137f0:	49 01 cf             	add    r15,rcx
  2137f3:	4b 8d 0c 3b          	lea    rcx,[r11+r15*1]
  2137f7:	48 83 c1 10          	add    rcx,0x10
  2137fb:	48 c1 e0 04          	shl    rax,0x4
  2137ff:	48 01 e0             	add    rax,rsp
  213802:	48 05 a0 02 00 00    	add    rax,0x2a0
  213808:	48 01 d8             	add    rax,rbx
  21380b:	49 f7 d8             	neg    r8
  21380e:	31 d2                	xor    edx,edx
        dest[i] = s;
  213810:	c5 fa 6f 04 10       	vmovdqu xmm0,XMMWORD PTR [rax+rdx*1]
  213815:	c5 fa 7f 04 11       	vmovdqu XMMWORD PTR [rcx+rdx*1],xmm0
    for (source) |s, i|
  21381a:	48 83 c2 10          	add    rdx,0x10
  21381e:	49 83 c0 01          	add    r8,0x1
  213822:	75 ec                	jne    213810 <benchmark.add+0x8fd0>
  213824:	e9 e7 00 00 00       	jmp    213910 <benchmark.add+0x90d0>
  213829:	48 29 d1             	sub    rcx,rdx
  21382c:	b8 70 00 00 00       	mov    eax,0x70
  213831:	31 f6                	xor    esi,esi
  213833:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21383a:	84 00 00 00 00 00 
        dest[i] = s;
  213840:	c4 c1 78 10 44 05 90 	vmovups xmm0,XMMWORD PTR [r13+rax*1-0x70]
  213847:	c4 c1 78 11 44 06 a0 	vmovups XMMWORD PTR [r14+rax*1-0x60],xmm0
  21384e:	c4 c1 78 10 44 05 a0 	vmovups xmm0,XMMWORD PTR [r13+rax*1-0x60]
  213855:	c4 c1 78 11 44 06 b0 	vmovups XMMWORD PTR [r14+rax*1-0x50],xmm0
  21385c:	c4 c1 78 10 44 05 b0 	vmovups xmm0,XMMWORD PTR [r13+rax*1-0x50]
  213863:	c4 c1 78 11 44 06 c0 	vmovups XMMWORD PTR [r14+rax*1-0x40],xmm0
  21386a:	c4 c1 78 10 44 05 c0 	vmovups xmm0,XMMWORD PTR [r13+rax*1-0x40]
  213871:	c4 c1 78 11 44 06 d0 	vmovups XMMWORD PTR [r14+rax*1-0x30],xmm0
  213878:	c4 c1 78 10 44 05 d0 	vmovups xmm0,XMMWORD PTR [r13+rax*1-0x30]
  21387f:	c4 c1 78 11 44 06 e0 	vmovups XMMWORD PTR [r14+rax*1-0x20],xmm0
  213886:	c4 c1 78 10 44 05 e0 	vmovups xmm0,XMMWORD PTR [r13+rax*1-0x20]
  21388d:	c4 c1 78 11 44 06 f0 	vmovups XMMWORD PTR [r14+rax*1-0x10],xmm0
  213894:	c4 c1 78 10 44 05 f0 	vmovups xmm0,XMMWORD PTR [r13+rax*1-0x10]
  21389b:	c4 c1 78 11 04 06    	vmovups XMMWORD PTR [r14+rax*1],xmm0
  2138a1:	c4 c1 7a 6f 44 05 00 	vmovdqu xmm0,XMMWORD PTR [r13+rax*1+0x0]
  2138a8:	c4 c1 7a 7f 44 06 10 	vmovdqu XMMWORD PTR [r14+rax*1+0x10],xmm0
    for (source) |s, i|
  2138af:	48 83 c6 08          	add    rsi,0x8
  2138b3:	48 83 e8 80          	sub    rax,0xffffffffffffff80
  2138b7:	48 39 f1             	cmp    rcx,rsi
  2138ba:	75 84                	jne    213840 <benchmark.add+0x9000>
  2138bc:	48 85 d2             	test   rdx,rdx
  2138bf:	48 8b 44 24 10       	mov    rax,QWORD PTR [rsp+0x10]
  2138c4:	74 4a                	je     213910 <benchmark.add+0x90d0>
  2138c6:	48 01 f0             	add    rax,rsi
  2138c9:	48 c1 e0 04          	shl    rax,0x4
  2138cd:	49 01 c7             	add    r15,rax
  2138d0:	4b 8d 04 3b          	lea    rax,[r11+r15*1]
  2138d4:	48 83 c0 10          	add    rax,0x10
  2138d8:	48 c1 e6 04          	shl    rsi,0x4
  2138dc:	48 8d 0c 34          	lea    rcx,[rsp+rsi*1]
  2138e0:	48 81 c1 a0 02 00 00 	add    rcx,0x2a0
  2138e7:	48 01 f9             	add    rcx,rdi
  2138ea:	48 f7 da             	neg    rdx
  2138ed:	31 f6                	xor    esi,esi
  2138ef:	90                   	nop
        dest[i] = s;
  2138f0:	c5 fa 6f 04 31       	vmovdqu xmm0,XMMWORD PTR [rcx+rsi*1]
  2138f5:	c5 fa 7f 04 30       	vmovdqu XMMWORD PTR [rax+rsi*1],xmm0
    for (source) |s, i|
  2138fa:	48 83 c6 10          	add    rsi,0x10
  2138fe:	48 83 c2 01          	add    rdx,0x1
  213902:	75 ec                	jne    2138f0 <benchmark.add+0x90b0>
  213904:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21390b:	00 00 00 00 00 
  213910:	4c 8b ac 24 d0 00 00 	mov    r13,QWORD PTR [rsp+0xd0]
  213917:	00 
  213918:	4c 2b ac 24 00 01 00 	sub    r13,QWORD PTR [rsp+0x100]
  21391f:	00 
  213920:	48 8b 94 24 50 01 00 	mov    rdx,QWORD PTR [rsp+0x150]
  213927:	00 
  213928:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
        return self.decimal >= self.size;
  21392d:	48 39 d0             	cmp    rax,rdx
  213930:	48 8b 9c 24 38 01 00 	mov    rbx,QWORD PTR [rsp+0x138]
  213937:	00 
  213938:	4c 8b 84 24 f8 00 00 	mov    r8,QWORD PTR [rsp+0xf8]
  21393f:	00 
  213940:	4c 8b 8c 24 30 01 00 	mov    r9,QWORD PTR [rsp+0x130]
  213947:	00 
                while (!iterator.finished()) {
  213948:	0f 82 02 e4 ff ff    	jb     211d50 <benchmark.add+0x7510>
        self.numerator_step += self.numerator_step;
  21394e:	4d 01 c9             	add    r9,r9
        if (self.numerator_step >= self.denominator) {
  213951:	4c 89 c8             	mov    rax,r9
  213954:	48 29 d8             	sub    rax,rbx
  213957:	0f 83 29 08 00 00    	jae    214186 <benchmark.add+0x9946>
  21395d:	4c 8b 84 24 e0 00 00 	mov    r8,QWORD PTR [rsp+0xe0]
  213964:	00 
  213965:	4c 89 c8             	mov    rax,r9
  213968:	e9 25 08 00 00       	jmp    214192 <benchmark.add+0x9952>
        self.decimal += self.decimal_step;
  21396d:	4b 8d 04 00          	lea    rax,[r8+r8*1]
  213971:	48 89 44 24 30       	mov    QWORD PTR [rsp+0x30],rax
  213976:	45 31 f6             	xor    r14d,r14d
  213979:	45 31 db             	xor    r11d,r11d
  21397c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  213980:	4b 8d 04 06          	lea    rax,[r14+r8*1]
        self.numerator += self.numerator_step;
  213984:	4d 01 cb             	add    r11,r9
        if (self.numerator >= self.denominator) {
  213987:	31 f6                	xor    esi,esi
  213989:	49 39 db             	cmp    r11,rbx
  21398c:	40 0f 93 c6          	setae  sil
  213990:	48 89 d9             	mov    rcx,rbx
  213993:	bf 00 00 00 00       	mov    edi,0x0
  213998:	48 0f 42 cf          	cmovb  rcx,rdi
  21399c:	49 29 cb             	sub    r11,rcx
  21399f:	48 89 74 24 60       	mov    QWORD PTR [rsp+0x60],rsi
  2139a4:	4c 8d 2c 30          	lea    r13,[rax+rsi*1]
        self.decimal += self.decimal_step;
  2139a8:	4b 8d 34 28          	lea    rsi,[r8+r13*1]
        self.numerator += self.numerator_step;
  2139ac:	4d 01 cb             	add    r11,r9
        if (self.numerator >= self.denominator) {
  2139af:	31 d2                	xor    edx,edx
  2139b1:	49 39 db             	cmp    r11,rbx
  2139b4:	0f 93 c2             	setae  dl
  2139b7:	49 89 d9             	mov    r9,rbx
  2139ba:	4c 0f 42 cf          	cmovb  r9,rdi
  2139be:	48 01 d6             	add    rsi,rdx
                    if (lessThan(items[B.end - 1], items[A.start])) {
  2139c1:	48 89 f1             	mov    rcx,rsi
  2139c4:	48 c1 e1 04          	shl    rcx,0x4
  2139c8:	4c 8b 7c 24 48       	mov    r15,QWORD PTR [rsp+0x48]
  2139cd:	4d 89 f2             	mov    r10,r14
  2139d0:	49 c1 e2 04          	shl    r10,0x4
  2139d4:	49 8b 4c 0f f0       	mov    rcx,QWORD PTR [r15+rcx*1-0x10]
  2139d9:	4b 3b 0c 17          	cmp    rcx,QWORD PTR [r15+r10*1]
  2139dd:	4b 8d 3c 17          	lea    rdi,[r15+r10*1]
  2139e1:	48 89 74 24 20       	mov    QWORD PTR [rsp+0x20],rsi
  2139e6:	73 48                	jae    213a30 <benchmark.add+0x91f0>
  2139e8:	48 89 54 24 10       	mov    QWORD PTR [rsp+0x10],rdx
  2139ed:	4c 89 4c 24 18       	mov    QWORD PTR [rsp+0x18],r9
                        mem.rotate(T, items[A.start..B.end], A.length());
  2139f2:	49 89 f4             	mov    r12,rsi
  2139f5:	4d 29 f4             	sub    r12,r14
        return self.end - self.start;
  2139f8:	4c 89 eb             	mov    rbx,r13
  2139fb:	4c 29 f3             	sub    rbx,r14
    const end = items.len / 2;
  2139fe:	48 89 de             	mov    rsi,rbx
  213a01:	48 d1 ee             	shr    rsi,1
    while (i < end) : (i += 1) {
  213a04:	0f 84 90 01 00 00    	je     213b9a <benchmark.add+0x935a>
        swap(T, &items[i], &items[items.len - i - 1]);
  213a0a:	48 8d 4e ff          	lea    rcx,[rsi-0x1]
  213a0e:	41 89 f0             	mov    r8d,esi
  213a11:	41 83 e0 03          	and    r8d,0x3
  213a15:	48 83 f9 03          	cmp    rcx,0x3
  213a19:	73 75                	jae    213a90 <benchmark.add+0x9250>
  213a1b:	45 31 c9             	xor    r9d,r9d
    while (i < end) : (i += 1) {
  213a1e:	4d 85 c0             	test   r8,r8
  213a21:	0f 85 17 01 00 00    	jne    213b3e <benchmark.add+0x92fe>
  213a27:	e9 6e 01 00 00       	jmp    213b9a <benchmark.add+0x935a>
  213a2c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
                    } else if (lessThan(items[B.start], items[A.end - 1])) {
  213a30:	4c 89 e8             	mov    rax,r13
  213a33:	48 c1 e0 04          	shl    rax,0x4
  213a37:	49 8b 0c 07          	mov    rcx,QWORD PTR [r15+rax*1]
  213a3b:	49 3b 4c 07 f0       	cmp    rcx,QWORD PTR [r15+rax*1-0x10]
  213a40:	0f 83 0a 07 00 00    	jae    214150 <benchmark.add+0x9910>
                        mem.copy(T, cache[0..], items[A.start..A.end]);
  213a46:	4d 89 ea             	mov    r10,r13
  213a49:	4d 29 f2             	sub    r10,r14
    assert(dest.len >= source.len);
  213a4c:	49 81 fa 01 02 00 00 	cmp    r10,0x201
  213a53:	0f 83 7d 0b 00 00    	jae    2145d6 <benchmark.add+0x9d96>
    for (source) |s, i|
  213a59:	4d 85 d2             	test   r10,r10
  213a5c:	0f 84 e4 03 00 00    	je     213e46 <benchmark.add+0x9606>
  213a62:	48 8b 44 24 40       	mov    rax,QWORD PTR [rsp+0x40]
  213a67:	48 8b 4c 24 60       	mov    rcx,QWORD PTR [rsp+0x60]
  213a6c:	48 8d 04 08          	lea    rax,[rax+rcx*1]
  213a70:	44 89 d6             	mov    esi,r10d
  213a73:	83 e6 07             	and    esi,0x7
  213a76:	48 83 f8 07          	cmp    rax,0x7
  213a7a:	0f 83 e9 02 00 00    	jae    213d69 <benchmark.add+0x9529>
  213a80:	31 c9                	xor    ecx,ecx
  213a82:	48 85 f6             	test   rsi,rsi
  213a85:	0f 85 82 03 00 00    	jne    213e0d <benchmark.add+0x95cd>
  213a8b:	e9 a8 03 00 00       	jmp    213e38 <benchmark.add+0x95f8>
        swap(T, &items[i], &items[items.len - i - 1]);
  213a90:	4c 29 c6             	sub    rsi,r8
  213a93:	4b 8d 0c 17          	lea    rcx,[r15+r10*1]
  213a97:	48 83 c1 30          	add    rcx,0x30
  213a9b:	4c 89 ea             	mov    rdx,r13
  213a9e:	48 c1 e2 04          	shl    rdx,0x4
  213aa2:	4c 01 fa             	add    rdx,r15
  213aa5:	48 83 c2 f0          	add    rdx,0xfffffffffffffff0
  213aa9:	45 31 c9             	xor    r9d,r9d
  213aac:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
    const tmp = a.*;
  213ab0:	c5 f8 10 41 d0       	vmovups xmm0,XMMWORD PTR [rcx-0x30]
  213ab5:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  213aba:	c5 f8 10 02          	vmovups xmm0,XMMWORD PTR [rdx]
  213abe:	c5 f8 11 41 d0       	vmovups XMMWORD PTR [rcx-0x30],xmm0
    b.* = tmp;
  213ac3:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  213ac8:	c5 f8 11 02          	vmovups XMMWORD PTR [rdx],xmm0
    const tmp = a.*;
  213acc:	c5 f8 10 41 e0       	vmovups xmm0,XMMWORD PTR [rcx-0x20]
  213ad1:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  213ad6:	c5 f8 10 42 f0       	vmovups xmm0,XMMWORD PTR [rdx-0x10]
  213adb:	c5 f8 11 41 e0       	vmovups XMMWORD PTR [rcx-0x20],xmm0
    b.* = tmp;
  213ae0:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  213ae5:	c5 f8 11 42 f0       	vmovups XMMWORD PTR [rdx-0x10],xmm0
    const tmp = a.*;
  213aea:	c5 f8 10 41 f0       	vmovups xmm0,XMMWORD PTR [rcx-0x10]
  213aef:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  213af4:	c5 f8 10 42 e0       	vmovups xmm0,XMMWORD PTR [rdx-0x20]
  213af9:	c5 f8 11 41 f0       	vmovups XMMWORD PTR [rcx-0x10],xmm0
    b.* = tmp;
  213afe:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  213b03:	c5 f8 11 42 e0       	vmovups XMMWORD PTR [rdx-0x20],xmm0
    const tmp = a.*;
  213b08:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  213b0c:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  213b11:	c5 f8 10 42 d0       	vmovups xmm0,XMMWORD PTR [rdx-0x30]
  213b16:	c5 f8 11 01          	vmovups XMMWORD PTR [rcx],xmm0
    b.* = tmp;
  213b1a:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  213b1f:	c5 fa 7f 42 d0       	vmovdqu XMMWORD PTR [rdx-0x30],xmm0
    while (i < end) : (i += 1) {
  213b24:	49 83 c1 04          	add    r9,0x4
  213b28:	48 83 c1 40          	add    rcx,0x40
  213b2c:	48 83 c2 c0          	add    rdx,0xffffffffffffffc0
  213b30:	4c 39 ce             	cmp    rsi,r9
  213b33:	0f 85 77 ff ff ff    	jne    213ab0 <benchmark.add+0x9270>
  213b39:	4d 85 c0             	test   r8,r8
  213b3c:	74 5c                	je     213b9a <benchmark.add+0x935a>
  213b3e:	48 8b 4c 24 60       	mov    rcx,QWORD PTR [rsp+0x60]
  213b43:	48 8d 0c 08          	lea    rcx,[rax+rcx*1]
  213b47:	4c 29 c9             	sub    rcx,r9
  213b4a:	48 c1 e1 04          	shl    rcx,0x4
  213b4e:	4c 01 f9             	add    rcx,r15
  213b51:	48 83 c1 f0          	add    rcx,0xfffffffffffffff0
  213b55:	4d 01 f1             	add    r9,r14
  213b58:	49 c1 e1 04          	shl    r9,0x4
  213b5c:	4d 01 f9             	add    r9,r15
  213b5f:	49 f7 d8             	neg    r8
  213b62:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  213b69:	1f 84 00 00 00 00 00 
    const tmp = a.*;
  213b70:	c4 c1 78 10 01       	vmovups xmm0,XMMWORD PTR [r9]
  213b75:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  213b7a:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  213b7e:	c4 c1 78 11 01       	vmovups XMMWORD PTR [r9],xmm0
    b.* = tmp;
  213b83:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  213b88:	c5 fa 7f 01          	vmovdqu XMMWORD PTR [rcx],xmm0
    while (i < end) : (i += 1) {
  213b8c:	48 83 c1 f0          	add    rcx,0xfffffffffffffff0
  213b90:	49 83 c1 10          	add    r9,0x10
  213b94:	49 83 c0 01          	add    r8,0x1
  213b98:	75 d6                	jne    213b70 <benchmark.add+0x9330>
    reverse(T, items[amount..]);
  213b9a:	4d 89 e0             	mov    r8,r12
  213b9d:	49 29 d8             	sub    r8,rbx
    const end = items.len / 2;
  213ba0:	49 d1 e8             	shr    r8,1
  213ba3:	4c 8b 4c 24 18       	mov    r9,QWORD PTR [rsp+0x18]
    while (i < end) : (i += 1) {
  213ba8:	0f 84 5a 01 00 00    	je     213d08 <benchmark.add+0x94c8>
        swap(T, &items[i], &items[items.len - i - 1]);
  213bae:	49 8d 48 ff          	lea    rcx,[r8-0x1]
  213bb2:	44 89 c3             	mov    ebx,r8d
  213bb5:	83 e3 03             	and    ebx,0x3
  213bb8:	48 83 f9 03          	cmp    rcx,0x3
  213bbc:	73 10                	jae    213bce <benchmark.add+0x938e>
  213bbe:	31 c9                	xor    ecx,ecx
    while (i < end) : (i += 1) {
  213bc0:	48 85 db             	test   rbx,rbx
  213bc3:	0f 85 d5 00 00 00    	jne    213c9e <benchmark.add+0x945e>
  213bc9:	e9 3a 01 00 00       	jmp    213d08 <benchmark.add+0x94c8>
        swap(T, &items[i], &items[items.len - i - 1]);
  213bce:	49 29 d8             	sub    r8,rbx
  213bd1:	49 c1 e5 04          	shl    r13,0x4
  213bd5:	4b 8d 14 2f          	lea    rdx,[r15+r13*1]
  213bd9:	48 83 c2 30          	add    rdx,0x30
  213bdd:	48 8b 4c 24 30       	mov    rcx,QWORD PTR [rsp+0x30]
  213be2:	48 c1 e1 04          	shl    rcx,0x4
  213be6:	4c 01 f9             	add    rcx,r15
  213be9:	48 8b 74 24 60       	mov    rsi,QWORD PTR [rsp+0x60]
  213bee:	49 8d 34 36          	lea    rsi,[r14+rsi*1]
  213bf2:	48 03 74 24 10       	add    rsi,QWORD PTR [rsp+0x10]
  213bf7:	48 c1 e6 04          	shl    rsi,0x4
  213bfb:	48 01 ce             	add    rsi,rcx
  213bfe:	48 83 c6 f0          	add    rsi,0xfffffffffffffff0
  213c02:	31 c9                	xor    ecx,ecx
  213c04:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  213c0b:	00 00 00 00 00 
    const tmp = a.*;
  213c10:	c5 f8 10 42 d0       	vmovups xmm0,XMMWORD PTR [rdx-0x30]
  213c15:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  213c1a:	c5 f8 10 06          	vmovups xmm0,XMMWORD PTR [rsi]
  213c1e:	c5 f8 11 42 d0       	vmovups XMMWORD PTR [rdx-0x30],xmm0
    b.* = tmp;
  213c23:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  213c28:	c5 f8 11 06          	vmovups XMMWORD PTR [rsi],xmm0
    const tmp = a.*;
  213c2c:	c5 f8 10 42 e0       	vmovups xmm0,XMMWORD PTR [rdx-0x20]
  213c31:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  213c36:	c5 f8 10 46 f0       	vmovups xmm0,XMMWORD PTR [rsi-0x10]
  213c3b:	c5 f8 11 42 e0       	vmovups XMMWORD PTR [rdx-0x20],xmm0
    b.* = tmp;
  213c40:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  213c45:	c5 f8 11 46 f0       	vmovups XMMWORD PTR [rsi-0x10],xmm0
    const tmp = a.*;
  213c4a:	c5 f8 10 42 f0       	vmovups xmm0,XMMWORD PTR [rdx-0x10]
  213c4f:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  213c54:	c5 f8 10 46 e0       	vmovups xmm0,XMMWORD PTR [rsi-0x20]
  213c59:	c5 f8 11 42 f0       	vmovups XMMWORD PTR [rdx-0x10],xmm0
    b.* = tmp;
  213c5e:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  213c63:	c5 f8 11 46 e0       	vmovups XMMWORD PTR [rsi-0x20],xmm0
    const tmp = a.*;
  213c68:	c5 f8 10 02          	vmovups xmm0,XMMWORD PTR [rdx]
  213c6c:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  213c71:	c5 f8 10 46 d0       	vmovups xmm0,XMMWORD PTR [rsi-0x30]
  213c76:	c5 f8 11 02          	vmovups XMMWORD PTR [rdx],xmm0
    b.* = tmp;
  213c7a:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  213c7f:	c5 fa 7f 46 d0       	vmovdqu XMMWORD PTR [rsi-0x30],xmm0
    while (i < end) : (i += 1) {
  213c84:	48 83 c1 04          	add    rcx,0x4
  213c88:	48 83 c2 40          	add    rdx,0x40
  213c8c:	48 83 c6 c0          	add    rsi,0xffffffffffffffc0
  213c90:	49 39 c8             	cmp    r8,rcx
  213c93:	0f 85 77 ff ff ff    	jne    213c10 <benchmark.add+0x93d0>
  213c99:	48 85 db             	test   rbx,rbx
  213c9c:	74 6a                	je     213d08 <benchmark.add+0x94c8>
  213c9e:	48 8b 54 24 30       	mov    rdx,QWORD PTR [rsp+0x30]
  213ca3:	48 c1 e2 04          	shl    rdx,0x4
  213ca7:	4c 01 fa             	add    rdx,r15
  213caa:	4c 8b 44 24 60       	mov    r8,QWORD PTR [rsp+0x60]
  213caf:	4b 8d 34 06          	lea    rsi,[r14+r8*1]
  213cb3:	48 03 74 24 10       	add    rsi,QWORD PTR [rsp+0x10]
  213cb8:	48 29 ce             	sub    rsi,rcx
  213cbb:	48 c1 e6 04          	shl    rsi,0x4
  213cbf:	48 01 f2             	add    rdx,rsi
  213cc2:	48 83 c2 f0          	add    rdx,0xfffffffffffffff0
  213cc6:	48 01 c8             	add    rax,rcx
  213cc9:	4c 01 c0             	add    rax,r8
  213ccc:	48 c1 e0 04          	shl    rax,0x4
  213cd0:	4c 01 f8             	add    rax,r15
  213cd3:	48 f7 db             	neg    rbx
  213cd6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  213cdd:	00 00 00 
    const tmp = a.*;
  213ce0:	c5 f8 10 00          	vmovups xmm0,XMMWORD PTR [rax]
  213ce4:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  213ce9:	c5 f8 10 02          	vmovups xmm0,XMMWORD PTR [rdx]
  213ced:	c5 f8 11 00          	vmovups XMMWORD PTR [rax],xmm0
    b.* = tmp;
  213cf1:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  213cf6:	c5 fa 7f 02          	vmovdqu XMMWORD PTR [rdx],xmm0
    while (i < end) : (i += 1) {
  213cfa:	48 83 c2 f0          	add    rdx,0xfffffffffffffff0
  213cfe:	48 83 c0 10          	add    rax,0x10
  213d02:	48 83 c3 01          	add    rbx,0x1
  213d06:	75 d8                	jne    213ce0 <benchmark.add+0x94a0>
    const end = items.len / 2;
  213d08:	4c 89 e3             	mov    rbx,r12
  213d0b:	48 d1 eb             	shr    rbx,1
    while (i < end) : (i += 1) {
  213d0e:	0f 84 3c 04 00 00    	je     214150 <benchmark.add+0x9910>
    const tmp = a.*;
  213d14:	c5 f8 10 07          	vmovups xmm0,XMMWORD PTR [rdi]
  213d18:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  213d1d:	49 c1 e4 04          	shl    r12,0x4
    a.* = b.*;
  213d21:	c4 a1 78 10 44 27 f0 	vmovups xmm0,XMMWORD PTR [rdi+r12*1-0x10]
  213d28:	c5 f8 11 07          	vmovups XMMWORD PTR [rdi],xmm0
    b.* = tmp;
  213d2c:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  213d31:	c4 a1 7a 7f 44 27 f0 	vmovdqu XMMWORD PTR [rdi+r12*1-0x10],xmm0
    while (i < end) : (i += 1) {
  213d38:	48 83 fb 01          	cmp    rbx,0x1
  213d3c:	0f 84 0e 04 00 00    	je     214150 <benchmark.add+0x9910>
        swap(T, &items[i], &items[items.len - i - 1]);
  213d42:	8d 43 ff             	lea    eax,[rbx-0x1]
  213d45:	48 8d 4b fe          	lea    rcx,[rbx-0x2]
  213d49:	83 e0 03             	and    eax,0x3
  213d4c:	48 83 f9 03          	cmp    rcx,0x3
  213d50:	0f 83 f8 00 00 00    	jae    213e4e <benchmark.add+0x960e>
  213d56:	be 01 00 00 00       	mov    esi,0x1
    while (i < end) : (i += 1) {
  213d5b:	48 85 c0             	test   rax,rax
  213d5e:	0f 85 be 01 00 00    	jne    213f22 <benchmark.add+0x96e2>
  213d64:	e9 e7 03 00 00       	jmp    214150 <benchmark.add+0x9910>
    for (source) |s, i|
  213d69:	4c 89 d2             	mov    rdx,r10
  213d6c:	48 29 f2             	sub    rdx,rsi
  213d6f:	bb 70 00 00 00       	mov    ebx,0x70
  213d74:	31 c9                	xor    ecx,ecx
  213d76:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  213d7d:	00 00 00 
        dest[i] = s;
  213d80:	c5 f8 10 44 1f 90    	vmovups xmm0,XMMWORD PTR [rdi+rbx*1-0x70]
  213d86:	c5 f8 11 84 1c 30 02 	vmovups XMMWORD PTR [rsp+rbx*1+0x230],xmm0
  213d8d:	00 00 
  213d8f:	c5 f8 10 44 1f a0    	vmovups xmm0,XMMWORD PTR [rdi+rbx*1-0x60]
  213d95:	c5 f8 11 84 1c 40 02 	vmovups XMMWORD PTR [rsp+rbx*1+0x240],xmm0
  213d9c:	00 00 
  213d9e:	c5 f8 10 44 1f b0    	vmovups xmm0,XMMWORD PTR [rdi+rbx*1-0x50]
  213da4:	c5 f8 11 84 1c 50 02 	vmovups XMMWORD PTR [rsp+rbx*1+0x250],xmm0
  213dab:	00 00 
  213dad:	c5 f8 10 44 1f c0    	vmovups xmm0,XMMWORD PTR [rdi+rbx*1-0x40]
  213db3:	c5 f8 11 84 1c 60 02 	vmovups XMMWORD PTR [rsp+rbx*1+0x260],xmm0
  213dba:	00 00 
  213dbc:	c5 f8 10 44 1f d0    	vmovups xmm0,XMMWORD PTR [rdi+rbx*1-0x30]
  213dc2:	c5 f8 11 84 1c 70 02 	vmovups XMMWORD PTR [rsp+rbx*1+0x270],xmm0
  213dc9:	00 00 
  213dcb:	c5 f8 10 44 1f e0    	vmovups xmm0,XMMWORD PTR [rdi+rbx*1-0x20]
  213dd1:	c5 f8 11 84 1c 80 02 	vmovups XMMWORD PTR [rsp+rbx*1+0x280],xmm0
  213dd8:	00 00 
  213dda:	c5 f8 10 44 1f f0    	vmovups xmm0,XMMWORD PTR [rdi+rbx*1-0x10]
  213de0:	c5 f8 11 84 1c 90 02 	vmovups XMMWORD PTR [rsp+rbx*1+0x290],xmm0
  213de7:	00 00 
  213de9:	c5 fa 6f 04 1f       	vmovdqu xmm0,XMMWORD PTR [rdi+rbx*1]
  213dee:	c5 fa 7f 84 1c a0 02 	vmovdqu XMMWORD PTR [rsp+rbx*1+0x2a0],xmm0
  213df5:	00 00 
    for (source) |s, i|
  213df7:	48 83 c1 08          	add    rcx,0x8
  213dfb:	48 83 eb 80          	sub    rbx,0xffffffffffffff80
  213dff:	48 39 ca             	cmp    rdx,rcx
  213e02:	0f 85 78 ff ff ff    	jne    213d80 <benchmark.add+0x9540>
  213e08:	48 85 f6             	test   rsi,rsi
  213e0b:	74 2b                	je     213e38 <benchmark.add+0x95f8>
  213e0d:	48 c1 e1 04          	shl    rcx,0x4
  213e11:	48 f7 de             	neg    rsi
  213e14:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  213e1b:	00 00 00 00 00 
        dest[i] = s;
  213e20:	c5 fa 6f 04 0f       	vmovdqu xmm0,XMMWORD PTR [rdi+rcx*1]
  213e25:	c5 fa 7f 84 0c a0 02 	vmovdqu XMMWORD PTR [rsp+rcx*1+0x2a0],xmm0
  213e2c:	00 00 
    for (source) |s, i|
  213e2e:	48 83 c1 10          	add    rcx,0x10
  213e32:	48 83 c6 01          	add    rsi,0x1
  213e36:	75 e8                	jne    213e20 <benchmark.add+0x95e0>
  213e38:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
    if (B.length() > 0 and A.length() > 0) {
  213e3d:	4c 39 e8             	cmp    rax,r13
  213e40:	0f 85 49 01 00 00    	jne    213f8f <benchmark.add+0x974f>
  213e46:	45 31 c0             	xor    r8d,r8d
  213e49:	e9 ef 01 00 00       	jmp    21403d <benchmark.add+0x97fd>
        swap(T, &items[i], &items[items.len - i - 1]);
  213e4e:	48 8b 4c 24 30       	mov    rcx,QWORD PTR [rsp+0x30]
  213e53:	48 c1 e1 04          	shl    rcx,0x4
  213e57:	4c 01 f9             	add    rcx,r15
  213e5a:	48 8b 54 24 60       	mov    rdx,QWORD PTR [rsp+0x60]
  213e5f:	49 8d 14 16          	lea    rdx,[r14+rdx*1]
  213e63:	48 03 54 24 10       	add    rdx,QWORD PTR [rsp+0x10]
  213e68:	48 c1 e2 04          	shl    rdx,0x4
  213e6c:	48 01 d1             	add    rcx,rdx
  213e6f:	48 83 c1 e0          	add    rcx,0xffffffffffffffe0
  213e73:	4b 8d 14 17          	lea    rdx,[r15+r10*1]
  213e77:	48 83 c2 40          	add    rdx,0x40
  213e7b:	48 29 c3             	sub    rbx,rax
  213e7e:	be 01 00 00 00       	mov    esi,0x1
  213e83:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  213e8a:	84 00 00 00 00 00 
    const tmp = a.*;
  213e90:	c5 f8 10 42 d0       	vmovups xmm0,XMMWORD PTR [rdx-0x30]
  213e95:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  213e9a:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  213e9e:	c5 f8 11 42 d0       	vmovups XMMWORD PTR [rdx-0x30],xmm0
    b.* = tmp;
  213ea3:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  213ea8:	c5 f8 11 01          	vmovups XMMWORD PTR [rcx],xmm0
    const tmp = a.*;
  213eac:	c5 f8 10 42 e0       	vmovups xmm0,XMMWORD PTR [rdx-0x20]
  213eb1:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  213eb6:	c5 f8 10 41 f0       	vmovups xmm0,XMMWORD PTR [rcx-0x10]
  213ebb:	c5 f8 11 42 e0       	vmovups XMMWORD PTR [rdx-0x20],xmm0
    b.* = tmp;
  213ec0:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  213ec5:	c5 f8 11 41 f0       	vmovups XMMWORD PTR [rcx-0x10],xmm0
    const tmp = a.*;
  213eca:	c5 f8 10 42 f0       	vmovups xmm0,XMMWORD PTR [rdx-0x10]
  213ecf:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  213ed4:	c5 f8 10 41 e0       	vmovups xmm0,XMMWORD PTR [rcx-0x20]
  213ed9:	c5 f8 11 42 f0       	vmovups XMMWORD PTR [rdx-0x10],xmm0
    b.* = tmp;
  213ede:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  213ee3:	c5 f8 11 41 e0       	vmovups XMMWORD PTR [rcx-0x20],xmm0
    const tmp = a.*;
  213ee8:	c5 f8 10 02          	vmovups xmm0,XMMWORD PTR [rdx]
  213eec:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  213ef1:	c5 f8 10 41 d0       	vmovups xmm0,XMMWORD PTR [rcx-0x30]
  213ef6:	c5 f8 11 02          	vmovups XMMWORD PTR [rdx],xmm0
    b.* = tmp;
  213efa:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  213eff:	c5 fa 7f 41 d0       	vmovdqu XMMWORD PTR [rcx-0x30],xmm0
    while (i < end) : (i += 1) {
  213f04:	48 83 c6 04          	add    rsi,0x4
  213f08:	48 83 c1 c0          	add    rcx,0xffffffffffffffc0
  213f0c:	48 83 c2 40          	add    rdx,0x40
  213f10:	48 39 f3             	cmp    rbx,rsi
  213f13:	0f 85 77 ff ff ff    	jne    213e90 <benchmark.add+0x9650>
  213f19:	48 85 c0             	test   rax,rax
  213f1c:	0f 84 2e 02 00 00    	je     214150 <benchmark.add+0x9910>
  213f22:	48 8b 4c 24 30       	mov    rcx,QWORD PTR [rsp+0x30]
  213f27:	48 c1 e1 04          	shl    rcx,0x4
  213f2b:	4c 01 f9             	add    rcx,r15
  213f2e:	48 8b 54 24 60       	mov    rdx,QWORD PTR [rsp+0x60]
  213f33:	4c 01 f2             	add    rdx,r14
  213f36:	48 03 54 24 10       	add    rdx,QWORD PTR [rsp+0x10]
  213f3b:	48 29 f2             	sub    rdx,rsi
  213f3e:	48 c1 e2 04          	shl    rdx,0x4
  213f42:	48 01 d1             	add    rcx,rdx
  213f45:	48 83 c1 f0          	add    rcx,0xfffffffffffffff0
  213f49:	49 01 f6             	add    r14,rsi
  213f4c:	49 c1 e6 04          	shl    r14,0x4
  213f50:	4d 01 fe             	add    r14,r15
  213f53:	48 f7 d8             	neg    rax
  213f56:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  213f5d:	00 00 00 
    const tmp = a.*;
  213f60:	c4 c1 78 10 06       	vmovups xmm0,XMMWORD PTR [r14]
  213f65:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  213f6a:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  213f6e:	c4 c1 78 11 06       	vmovups XMMWORD PTR [r14],xmm0
    b.* = tmp;
  213f73:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  213f78:	c5 fa 7f 01          	vmovdqu XMMWORD PTR [rcx],xmm0
    while (i < end) : (i += 1) {
  213f7c:	48 83 c1 f0          	add    rcx,0xfffffffffffffff0
  213f80:	49 83 c6 10          	add    r14,0x10
  213f84:	48 83 c0 01          	add    rax,0x1
  213f88:	75 d6                	jne    213f60 <benchmark.add+0x9720>
  213f8a:	e9 c1 01 00 00       	jmp    214150 <benchmark.add+0x9910>
  213f8f:	4c 89 4c 24 18       	mov    QWORD PTR [rsp+0x18],r9
            if (!lessThan(items[B_index], cache[A_index])) {
  213f94:	49 89 c1             	mov    r9,rax
  213f97:	49 f7 d9             	neg    r9
  213f9a:	45 31 c0             	xor    r8d,r8d
  213f9d:	4c 89 c0             	mov    rax,r8
  213fa0:	48 c1 e0 04          	shl    rax,0x4
  213fa4:	4c 8d 24 04          	lea    r12,[rsp+rax*1]
  213fa8:	49 81 c4 a0 02 00 00 	add    r12,0x2a0
  213faf:	4c 89 f7             	mov    rdi,r14
  213fb2:	48 c1 e7 04          	shl    rdi,0x4
  213fb6:	4b 8d 1c 29          	lea    rbx,[r9+r13*1]
  213fba:	4c 89 e9             	mov    rcx,r13
  213fbd:	48 c1 e1 04          	shl    rcx,0x4
  213fc1:	4c 89 f8             	mov    rax,r15
  213fc4:	31 d2                	xor    edx,edx
  213fc6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  213fcd:	00 00 00 
  213fd0:	48 8b 34 08          	mov    rsi,QWORD PTR [rax+rcx*1]
  213fd4:	49 3b 34 24          	cmp    rsi,QWORD PTR [r12]
  213fd8:	73 19                	jae    213ff3 <benchmark.add+0x97b3>
                items[insert_index] = items[B_index];
  213fda:	c5 fa 6f 04 01       	vmovdqu xmm0,XMMWORD PTR [rcx+rax*1]
  213fdf:	c5 fa 7f 04 07       	vmovdqu XMMWORD PTR [rdi+rax*1],xmm0
                if (B_index == B_last) break;
  213fe4:	48 83 c2 ff          	add    rdx,0xffffffffffffffff
  213fe8:	48 83 c0 10          	add    rax,0x10
  213fec:	48 39 d3             	cmp    rbx,rdx
  213fef:	75 df                	jne    213fd0 <benchmark.add+0x9790>
  213ff1:	eb 38                	jmp    21402b <benchmark.add+0x97eb>
                items[insert_index] = cache[A_index];
  213ff3:	c4 c1 7a 6f 04 24    	vmovdqu xmm0,XMMWORD PTR [r12]
  213ff9:	c5 fa 7f 04 07       	vmovdqu XMMWORD PTR [rdi+rax*1],xmm0
                A_index += 1;
  213ffe:	49 83 c0 01          	add    r8,0x1
                if (A_index == A_last) break;
  214002:	4c 89 f0             	mov    rax,r14
  214005:	48 83 c0 01          	add    rax,0x1
  214009:	49 89 c6             	mov    r14,rax
  21400c:	49 29 d6             	sub    r14,rdx
  21400f:	4c 8b 7c 24 48       	mov    r15,QWORD PTR [rsp+0x48]
  214014:	49 29 d5             	sub    r13,rdx
  214017:	4d 39 d0             	cmp    r8,r10
  21401a:	0f 85 7d ff ff ff    	jne    213f9d <benchmark.add+0x975d>
    mem.copy(T, items[insert_index..], cache[A_index..A_last]);
  214020:	48 29 d0             	sub    rax,rdx
  214023:	49 89 c6             	mov    r14,rax
  214026:	4d 89 d0             	mov    r8,r10
  214029:	eb 03                	jmp    21402e <benchmark.add+0x97ee>
  21402b:	49 29 d6             	sub    r14,rdx
  21402e:	4c 89 f7             	mov    rdi,r14
  214031:	48 c1 e7 04          	shl    rdi,0x4
  214035:	4c 01 ff             	add    rdi,r15
  214038:	4c 8b 4c 24 18       	mov    r9,QWORD PTR [rsp+0x18]
  21403d:	48 8b 44 24 50       	mov    rax,QWORD PTR [rsp+0x50]
  214042:	4c 29 f0             	sub    rax,r14
  214045:	4d 29 c2             	sub    r10,r8
    assert(dest.len >= source.len);
  214048:	4c 39 d0             	cmp    rax,r10
  21404b:	0f 82 85 05 00 00    	jb     2145d6 <benchmark.add+0x9d96>
    for (source) |s, i|
  214051:	4d 85 d2             	test   r10,r10
  214054:	0f 84 f6 00 00 00    	je     214150 <benchmark.add+0x9910>
  21405a:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
  21405f:	48 03 44 24 40       	add    rax,QWORD PTR [rsp+0x40]
  214064:	4c 29 c0             	sub    rax,r8
  214067:	44 89 d2             	mov    edx,r10d
  21406a:	83 e2 07             	and    edx,0x7
  21406d:	48 83 f8 07          	cmp    rax,0x7
  214071:	73 10                	jae    214083 <benchmark.add+0x9843>
  214073:	31 c9                	xor    ecx,ecx
  214075:	48 85 d2             	test   rdx,rdx
  214078:	0f 85 92 00 00 00    	jne    214110 <benchmark.add+0x98d0>
  21407e:	e9 cd 00 00 00       	jmp    214150 <benchmark.add+0x9910>
  214083:	49 29 d2             	sub    r10,rdx
  214086:	4c 89 c0             	mov    rax,r8
  214089:	48 c1 e0 04          	shl    rax,0x4
  21408d:	48 8d 1c 04          	lea    rbx,[rsp+rax*1]
  214091:	48 81 c3 a0 02 00 00 	add    rbx,0x2a0
  214098:	be 70 00 00 00       	mov    esi,0x70
  21409d:	31 c9                	xor    ecx,ecx
  21409f:	90                   	nop
        dest[i] = s;
  2140a0:	c5 f8 10 44 33 90    	vmovups xmm0,XMMWORD PTR [rbx+rsi*1-0x70]
  2140a6:	c5 f8 11 44 37 90    	vmovups XMMWORD PTR [rdi+rsi*1-0x70],xmm0
  2140ac:	c5 f8 10 44 33 a0    	vmovups xmm0,XMMWORD PTR [rbx+rsi*1-0x60]
  2140b2:	c5 f8 11 44 37 a0    	vmovups XMMWORD PTR [rdi+rsi*1-0x60],xmm0
  2140b8:	c5 f8 10 44 33 b0    	vmovups xmm0,XMMWORD PTR [rbx+rsi*1-0x50]
  2140be:	c5 f8 11 44 37 b0    	vmovups XMMWORD PTR [rdi+rsi*1-0x50],xmm0
  2140c4:	c5 f8 10 44 33 c0    	vmovups xmm0,XMMWORD PTR [rbx+rsi*1-0x40]
  2140ca:	c5 f8 11 44 37 c0    	vmovups XMMWORD PTR [rdi+rsi*1-0x40],xmm0
  2140d0:	c5 f8 10 44 33 d0    	vmovups xmm0,XMMWORD PTR [rbx+rsi*1-0x30]
  2140d6:	c5 f8 11 44 37 d0    	vmovups XMMWORD PTR [rdi+rsi*1-0x30],xmm0
  2140dc:	c5 f8 10 44 33 e0    	vmovups xmm0,XMMWORD PTR [rbx+rsi*1-0x20]
  2140e2:	c5 f8 11 44 37 e0    	vmovups XMMWORD PTR [rdi+rsi*1-0x20],xmm0
  2140e8:	c5 f8 10 44 33 f0    	vmovups xmm0,XMMWORD PTR [rbx+rsi*1-0x10]
  2140ee:	c5 f8 11 44 37 f0    	vmovups XMMWORD PTR [rdi+rsi*1-0x10],xmm0
  2140f4:	c5 fa 6f 04 33       	vmovdqu xmm0,XMMWORD PTR [rbx+rsi*1]
  2140f9:	c5 fa 7f 04 37       	vmovdqu XMMWORD PTR [rdi+rsi*1],xmm0
    for (source) |s, i|
  2140fe:	48 83 c1 08          	add    rcx,0x8
  214102:	48 83 ee 80          	sub    rsi,0xffffffffffffff80
  214106:	49 39 ca             	cmp    r10,rcx
  214109:	75 95                	jne    2140a0 <benchmark.add+0x9860>
  21410b:	48 85 d2             	test   rdx,rdx
  21410e:	74 40                	je     214150 <benchmark.add+0x9910>
  214110:	48 c1 e1 04          	shl    rcx,0x4
  214114:	49 c1 e0 04          	shl    r8,0x4
  214118:	4a 8d 04 04          	lea    rax,[rsp+r8*1]
  21411c:	48 05 a0 02 00 00    	add    rax,0x2a0
  214122:	48 f7 da             	neg    rdx
  214125:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21412c:	00 00 00 00 
        dest[i] = s;
  214130:	c5 fa 6f 04 08       	vmovdqu xmm0,XMMWORD PTR [rax+rcx*1]
  214135:	c5 fa 7f 04 0f       	vmovdqu XMMWORD PTR [rdi+rcx*1],xmm0
    for (source) |s, i|
  21413a:	48 83 c1 10          	add    rcx,0x10
  21413e:	48 83 c2 01          	add    rdx,0x1
  214142:	75 ec                	jne    214130 <benchmark.add+0x98f0>
  214144:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21414b:	00 00 00 00 00 
  214150:	4d 29 cb             	sub    r11,r9
  214153:	48 8b 94 24 50 01 00 	mov    rdx,QWORD PTR [rsp+0x150]
  21415a:	00 
  21415b:	4c 8b 74 24 20       	mov    r14,QWORD PTR [rsp+0x20]
        return self.decimal >= self.size;
  214160:	49 39 d6             	cmp    r14,rdx
  214163:	48 8b 9c 24 38 01 00 	mov    rbx,QWORD PTR [rsp+0x138]
  21416a:	00 
  21416b:	4c 8b 84 24 f8 00 00 	mov    r8,QWORD PTR [rsp+0xf8]
  214172:	00 
  214173:	4c 8b 8c 24 30 01 00 	mov    r9,QWORD PTR [rsp+0x130]
  21417a:	00 
                while (!iterator.finished()) {
  21417b:	0f 82 ff f7 ff ff    	jb     213980 <benchmark.add+0x9140>
  214181:	4c 89 c8             	mov    rax,r9
  214184:	eb 0c                	jmp    214192 <benchmark.add+0x9952>
  214186:	4c 8b 84 24 e0 00 00 	mov    r8,QWORD PTR [rsp+0xe0]
  21418d:	00 
            self.decimal_step += 1;
  21418e:	49 83 c8 01          	or     r8,0x1
        self.numerator_step += self.numerator_step;
  214192:	48 01 c0             	add    rax,rax
        if (self.numerator_step >= self.denominator) {
  214195:	31 c9                	xor    ecx,ecx
  214197:	48 39 d8             	cmp    rax,rbx
  21419a:	0f 93 c1             	setae  cl
  21419d:	4e 8d 04 41          	lea    r8,[rcx+r8*2]
        return (self.decimal_step < self.size);
  2141a1:	49 39 d0             	cmp    r8,rdx
  2141a4:	0f 82 50 da ff ff    	jb     211bfa <benchmark.add+0x73ba>
  2141aa:	eb 2f                	jmp    2141db <benchmark.add+0x999b>
  2141ac:	48 8b 43 10          	mov    rax,QWORD PTR [rbx+0x10]
  2141b0:	48 3b 03             	cmp    rax,QWORD PTR [rbx]
            if (lessThan(items[1], items[0])) mem.swap(T, &items[0], &items[1]);
  2141b3:	73 26                	jae    2141db <benchmark.add+0x999b>
    const tmp = a.*;
  2141b5:	c5 f8 10 03          	vmovups xmm0,XMMWORD PTR [rbx]
  2141b9:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  2141c0:	00 00 
  2141c2:	48 8d 43 10          	lea    rax,[rbx+0x10]
    a.* = b.*;
  2141c6:	c5 f8 10 00          	vmovups xmm0,XMMWORD PTR [rax]
  2141ca:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
    b.* = tmp;
  2141ce:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  2141d5:	00 00 
  2141d7:	c5 fa 7f 00          	vmovdqu XMMWORD PTR [rax],xmm0
        var center = copy.len / 2;
  2141db:	48 8b 8c 24 30 02 00 	mov    rcx,QWORD PTR [rsp+0x230]
  2141e2:	00 
  2141e3:	48 89 c8             	mov    rax,rcx
  2141e6:	48 d1 e8             	shr    rax,1
        if ((copy.len & 1) == 1) {
  2141e9:	f6 c1 01             	test   cl,0x1
  2141ec:	75 38                	jne    214226 <benchmark.add+0x99e6>
            median = @intToFloat(f64, copy.items[center-1].run_time_ns + copy.items[center].run_time_ns) / 2;
  2141ee:	48 8b 8c 24 20 02 00 	mov    rcx,QWORD PTR [rsp+0x220]
  2141f5:	00 
  2141f6:	48 c1 e0 04          	shl    rax,0x4
  2141fa:	48 8b 14 01          	mov    rdx,QWORD PTR [rcx+rax*1]
  2141fe:	48 03 54 01 f0       	add    rdx,QWORD PTR [rcx+rax*1-0x10]
  214203:	c4 e1 f9 6e c2       	vmovq  xmm0,rdx
  214208:	c5 f9 62 05 10 c0 fe 	vpunpckldq xmm0,xmm0,XMMWORD PTR [rip+0xfffffffffffec010]        # 200220 <__unnamed_103+0x40>
  21420f:	ff 
  214210:	c5 f9 5c 05 38 c5 fe 	vsubpd xmm0,xmm0,XMMWORD PTR [rip+0xfffffffffffec538]        # 200750 <__unnamed_586+0x10>
  214217:	ff 
  214218:	c5 f9 7c c0          	vhaddpd xmm0,xmm0,xmm0
  21421c:	c5 fb 59 05 94 ca fe 	vmulsd xmm0,xmm0,QWORD PTR [rip+0xfffffffffffeca94]        # 200cb8 <__unnamed_456+0x68>
  214223:	ff 
  214224:	eb 25                	jmp    21424b <benchmark.add+0x9a0b>
            median = @intToFloat(f64, copy.items[center].run_time_ns);
  214226:	48 8b 8c 24 20 02 00 	mov    rcx,QWORD PTR [rsp+0x220]
  21422d:	00 
  21422e:	48 c1 e0 04          	shl    rax,0x4
  214232:	c5 fb 10 04 01       	vmovsd xmm0,QWORD PTR [rcx+rax*1]
  214237:	c5 f8 14 05 e1 bf fe 	vunpcklps xmm0,xmm0,XMMWORD PTR [rip+0xfffffffffffebfe1]        # 200220 <__unnamed_103+0x40>
  21423e:	ff 
  21423f:	c5 f9 5c 05 09 c5 fe 	vsubpd xmm0,xmm0,XMMWORD PTR [rip+0xfffffffffffec509]        # 200750 <__unnamed_586+0x10>
  214246:	ff 
  214247:	c5 f9 7c c0          	vhaddpd xmm0,xmm0,xmm0
  21424b:	c5 fb 10 0d 9d ca fe 	vmovsd xmm1,QWORD PTR [rip+0xfffffffffffeca9d]        # 200cf0 <app_mask+0x10>
  214252:	ff 
  214253:	c5 f9 28 d1          	vmovapd xmm2,xmm1
            .run_time_ns = @floatToInt(u64, try pSelf.statsMedian(sum, results)),
  214257:	c5 fb 5c ca          	vsubsd xmm1,xmm0,xmm2
  21425b:	c4 e1 fb 2c c1       	vcvttsd2si rax,xmm1
  214260:	48 b9 00 00 00 00 00 	movabs rcx,0x8000000000000000
  214267:	00 00 80 
  21426a:	48 31 c8             	xor    rax,rcx
  21426d:	c4 e1 fb 2c f8       	vcvttsd2si rdi,xmm0
  214272:	c5 f9 2e c2          	vucomisd xmm0,xmm2
  214276:	48 0f 43 f8          	cmovae rdi,rax
            .iterations = results.items[0].iterations}
  21427a:	48 8b 84 24 e8 01 00 	mov    rax,QWORD PTR [rsp+0x1e8]
  214281:	00 
  214282:	48 8b 70 08          	mov    rsi,QWORD PTR [rax+0x8]
        pSelf.report(Result {
  214286:	c5 f8 77             	vzeroupper 
  214289:	e8 82 1d 00 00       	call   216010 <BenchmarkFramework_report>
        warn("stddev: reps:{} ", results.len); pSelf.reportStatsStdDev(sum, pSelf.results);
  21428e:	4c 8b a4 24 f8 01 00 	mov    r12,QWORD PTR [rsp+0x1f8]
  214295:	00 
  214296:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  21429d:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  2142a0:	b0 01                	mov    al,0x1
  2142a2:	86 05 68 1d 03 00    	xchg   BYTE PTR [rip+0x31d68],al        # 246010 <stderr_mutex>
  2142a8:	84 c0                	test   al,al
  2142aa:	75 f4                	jne    2142a0 <benchmark.add+0x9a60>
    if (stderr_stream) |st| {
  2142ac:	4c 8b 35 55 1d 03 00 	mov    r14,QWORD PTR [rip+0x31d55]        # 246008 <stderr_stream>
  2142b3:	4d 85 f6             	test   r14,r14
  2142b6:	74 09                	je     2142c1 <benchmark.add+0x9a81>
  2142b8:	4c 8b 3d 81 dd 02 00 	mov    r15,QWORD PTR [rip+0x2dd81]        # 242040 <stderr_file_out_stream+0x8>
  2142bf:	eb 34                	jmp    2142f5 <benchmark.add+0x9ab5>
        stderr_file = try io.getStdErr();
  2142c1:	48 8d 05 68 dd 02 00 	lea    rax,[rip+0x2dd68]        # 242030 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  2142c8:	48 89 05 69 dd 02 00 	mov    QWORD PTR [rip+0x2dd69],rax        # 242038 <stderr_file_out_stream>
  2142cf:	4c 8d 3d 7a 26 00 00 	lea    r15,[rip+0x267a]        # 216950 <FileOutStream_writeFn>
  2142d6:	4c 89 3d 63 dd 02 00 	mov    QWORD PTR [rip+0x2dd63],r15        # 242040 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  2142dd:	c7 05 49 dd 02 00 02 	mov    DWORD PTR [rip+0x2dd49],0x2        # 242030 <stderr_file>
  2142e4:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  2142e7:	4c 8d 35 52 dd 02 00 	lea    r14,[rip+0x2dd52]        # 242040 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  2142ee:	4c 89 35 13 1d 03 00 	mov    QWORD PTR [rip+0x31d13],r14        # 246008 <stderr_stream>
                        try output(context, fmt[start_index..i]);
  2142f5:	48 8d 35 fc 18 03 00 	lea    rsi,[rip+0x318fc]        # 245bf8 <__unnamed_20>
  2142fc:	4c 89 f7             	mov    rdi,r14
  2142ff:	41 ff d7             	call   r15
  214302:	66 85 c0             	test   ax,ax
  214305:	0f 85 fc 00 00 00    	jne    214407 <benchmark.add+0x9bc7>
    var buf: [max_int_digits - 1]u8 = undefined;
  21430b:	c5 fc 10 05 ac 51 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffff51ac]        # 2094bf <__unnamed_5+0x1f>
  214312:	ff 
  214313:	c5 fc 11 84 24 bf 02 	vmovups YMMWORD PTR [rsp+0x2bf],ymm0
  21431a:	00 00 
  21431c:	c5 fd 10 05 7c 51 ff 	vmovupd ymm0,YMMWORD PTR [rip+0xffffffffffff517c]        # 2094a0 <__unnamed_5>
  214323:	ff 
  214324:	c5 fd 29 84 24 a0 02 	vmovapd YMMWORD PTR [rsp+0x2a0],ymm0
  21432b:	00 00 
        const digit = a % base;
  21432d:	48 b8 cd cc cc cc cc 	movabs rax,0xcccccccccccccccd
  214334:	cc cc cc 
  214337:	4c 89 e2             	mov    rdx,r12
  21433a:	c4 e2 f3 f6 d0       	mulx   rdx,rcx,rax
  21433f:	c1 ea 02             	shr    edx,0x2
  214342:	81 e2 fe ff ff 3f    	and    edx,0x3ffffffe
  214348:	8d 14 92             	lea    edx,[rdx+rdx*4]
  21434b:	44 89 e1             	mov    ecx,r12d
  21434e:	29 d1                	sub    ecx,edx
        0...9 => digit + '0',
  214350:	b2 30                	mov    dl,0x30
  214352:	80 f9 0a             	cmp    cl,0xa
  214355:	72 02                	jb     214359 <benchmark.add+0x9b19>
  214357:	b2 57                	mov    dl,0x57
  214359:	00 ca                	add    dl,cl
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  21435b:	88 94 24 df 02 00 00 	mov    BYTE PTR [rsp+0x2df],dl
        if (a == 0) break;
  214362:	49 83 fc 0a          	cmp    r12,0xa
  214366:	73 0f                	jae    214377 <benchmark.add+0x9b37>
  214368:	48 8d 84 24 df 02 00 	lea    rax,[rsp+0x2df]
  21436f:	00 
  214370:	b9 40 00 00 00       	mov    ecx,0x40
  214375:	eb 55                	jmp    2143cc <benchmark.add+0x9b8c>
  214377:	b9 40 00 00 00       	mov    ecx,0x40
  21437c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
        a /= base;
  214380:	4c 89 e2             	mov    rdx,r12
  214383:	c4 e2 cb f6 d0       	mulx   rdx,rsi,rax
  214388:	48 c1 ea 03          	shr    rdx,0x3
        const digit = a % base;
  21438c:	c4 e2 cb f6 f8       	mulx   rdi,rsi,rax
  214391:	c1 ef 02             	shr    edi,0x2
  214394:	81 e7 fe ff ff 3f    	and    edi,0x3ffffffe
  21439a:	8d 3c bf             	lea    edi,[rdi+rdi*4]
  21439d:	89 d6                	mov    esi,edx
  21439f:	29 fe                	sub    esi,edi
        0...9 => digit + '0',
  2143a1:	b3 30                	mov    bl,0x30
  2143a3:	40 80 fe 0a          	cmp    sil,0xa
  2143a7:	72 02                	jb     2143ab <benchmark.add+0x9b6b>
  2143a9:	b3 57                	mov    bl,0x57
  2143ab:	40 00 f3             	add    bl,sil
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  2143ae:	88 9c 0c 9e 02 00 00 	mov    BYTE PTR [rsp+rcx*1+0x29e],bl
        if (a == 0) break;
  2143b5:	48 83 c1 ff          	add    rcx,0xffffffffffffffff
  2143b9:	49 83 fc 63          	cmp    r12,0x63
  2143bd:	49 89 d4             	mov    r12,rdx
  2143c0:	77 be                	ja     214380 <benchmark.add+0x9b40>
        const padded_buf = buf[index - padding ..];
  2143c2:	48 8d 04 0c          	lea    rax,[rsp+rcx*1]
  2143c6:	48 05 9f 02 00 00    	add    rax,0x29f
  2143cc:	ba 41 00 00 00       	mov    edx,0x41
  2143d1:	48 29 ca             	sub    rdx,rcx
  2143d4:	48 89 84 24 80 00 00 	mov    QWORD PTR [rsp+0x80],rax
  2143db:	00 
  2143dc:	48 89 94 24 88 00 00 	mov    QWORD PTR [rsp+0x88],rdx
  2143e3:	00 
  2143e4:	48 8d b4 24 80 00 00 	lea    rsi,[rsp+0x80]
  2143eb:	00 
        return output(context, padded_buf);
  2143ec:	4c 89 f7             	mov    rdi,r14
  2143ef:	c5 f8 77             	vzeroupper 
  2143f2:	41 ff d7             	call   r15
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  2143f5:	66 85 c0             	test   ax,ax
  2143f8:	75 0d                	jne    214407 <benchmark.add+0x9bc7>
        try output(context, fmt[start_index..]);
  2143fa:	48 8d 35 07 18 03 00 	lea    rsi,[rip+0x31807]        # 245c08 <__unnamed_21>
  214401:	4c 89 f7             	mov    rdi,r14
  214404:	41 ff d7             	call   r15
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  214407:	31 c0                	xor    eax,eax
  214409:	86 05 01 1c 03 00    	xchg   BYTE PTR [rip+0x31c01],al        # 246010 <stderr_mutex>
  21440f:	3c 01                	cmp    al,0x1
    if (!ok) {
  214411:	0f 85 bf 01 00 00    	jne    2145d6 <benchmark.add+0x9d96>
        if (results.len <= 1) {
  214417:	48 8b bc 24 f8 01 00 	mov    rdi,QWORD PTR [rsp+0x1f8]
  21441e:	00 
  21441f:	48 83 ff 01          	cmp    rdi,0x1
  214423:	c5 fb 10 8c 24 88 01 	vmovsd xmm1,QWORD PTR [rsp+0x188]
  21442a:	00 00 
  21442c:	77 0f                	ja     21443d <benchmark.add+0x9bfd>
            .iterations = results.items[0].iterations}
  21442e:	48 8b 84 24 e8 01 00 	mov    rax,QWORD PTR [rsp+0x1e8]
  214435:	00 
  214436:	31 ff                	xor    edi,edi
  214438:	e9 89 01 00 00       	jmp    2145c6 <benchmark.add+0x9d86>
            return sum / @intToFloat(f64, results.len);
  21443d:	c4 e1 f9 6e c7       	vmovq  xmm0,rdi
  214442:	c5 f9 62 05 d6 bd fe 	vpunpckldq xmm0,xmm0,XMMWORD PTR [rip+0xfffffffffffebdd6]        # 200220 <__unnamed_103+0x40>
  214449:	ff 
  21444a:	c5 f9 5c 05 fe c2 fe 	vsubpd xmm0,xmm0,XMMWORD PTR [rip+0xfffffffffffec2fe]        # 200750 <__unnamed_586+0x10>
  214451:	ff 
  214452:	c5 f9 7c c0          	vhaddpd xmm0,xmm0,xmm0
  214456:	c5 f3 5e c0          	vdivsd xmm0,xmm1,xmm0
  21445a:	48 8b 84 24 e8 01 00 	mov    rax,QWORD PTR [rsp+0x1e8]
  214461:	00 
            for (results.toSlice()) |result| {
  214462:	48 8d 4f ff          	lea    rcx,[rdi-0x1]
  214466:	89 fa                	mov    edx,edi
  214468:	83 e2 03             	and    edx,0x3
  21446b:	48 83 f9 03          	cmp    rcx,0x3
  21446f:	73 14                	jae    214485 <benchmark.add+0x9c45>
  214471:	c5 f1 57 c9          	vxorpd xmm1,xmm1,xmm1
  214475:	31 f6                	xor    esi,esi
  214477:	48 85 d2             	test   rdx,rdx
  21447a:	0f 85 b5 00 00 00    	jne    214535 <benchmark.add+0x9cf5>
  214480:	e9 f1 00 00 00       	jmp    214576 <benchmark.add+0x9d36>
  214485:	48 29 d7             	sub    rdi,rdx
  214488:	48 8d 58 30          	lea    rbx,[rax+0x30]
  21448c:	c5 f1 57 c9          	vxorpd xmm1,xmm1,xmm1
  214490:	31 f6                	xor    esi,esi
  214492:	c5 f9 28 15 86 bd fe 	vmovapd xmm2,XMMWORD PTR [rip+0xfffffffffffebd86]        # 200220 <__unnamed_103+0x40>
  214499:	ff 
  21449a:	c5 f9 28 1d ae c2 fe 	vmovapd xmm3,XMMWORD PTR [rip+0xfffffffffffec2ae]        # 200750 <__unnamed_586+0x10>
  2144a1:	ff 
  2144a2:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  2144a9:	1f 84 00 00 00 00 00 
                var diff = @intToFloat(f64, result.run_time_ns) - mean;
  2144b0:	c5 fb 10 63 d0       	vmovsd xmm4,QWORD PTR [rbx-0x30]
  2144b5:	c5 d8 14 e2          	vunpcklps xmm4,xmm4,xmm2
  2144b9:	c5 d9 5c e3          	vsubpd xmm4,xmm4,xmm3
  2144bd:	c5 d9 7c e4          	vhaddpd xmm4,xmm4,xmm4
  2144c1:	c5 db 5c e0          	vsubsd xmm4,xmm4,xmm0
                var square = diff * diff;
  2144c5:	c5 db 59 e4          	vmulsd xmm4,xmm4,xmm4
                sum_of_squares += square;
  2144c9:	c5 f3 58 cc          	vaddsd xmm1,xmm1,xmm4
                var diff = @intToFloat(f64, result.run_time_ns) - mean;
  2144cd:	c5 fb 10 63 e0       	vmovsd xmm4,QWORD PTR [rbx-0x20]
  2144d2:	c5 d8 14 e2          	vunpcklps xmm4,xmm4,xmm2
  2144d6:	c5 d9 5c e3          	vsubpd xmm4,xmm4,xmm3
  2144da:	c5 d9 7c e4          	vhaddpd xmm4,xmm4,xmm4
  2144de:	c5 db 5c e0          	vsubsd xmm4,xmm4,xmm0
                var square = diff * diff;
  2144e2:	c5 db 59 e4          	vmulsd xmm4,xmm4,xmm4
                var diff = @intToFloat(f64, result.run_time_ns) - mean;
  2144e6:	c5 fb 10 6b f0       	vmovsd xmm5,QWORD PTR [rbx-0x10]
  2144eb:	c5 d0 14 ea          	vunpcklps xmm5,xmm5,xmm2
  2144ef:	c5 d1 5c eb          	vsubpd xmm5,xmm5,xmm3
  2144f3:	c5 d1 7c ed          	vhaddpd xmm5,xmm5,xmm5
                sum_of_squares += square;
  2144f7:	c5 f3 58 cc          	vaddsd xmm1,xmm1,xmm4
                var diff = @intToFloat(f64, result.run_time_ns) - mean;
  2144fb:	c5 d3 5c e0          	vsubsd xmm4,xmm5,xmm0
  2144ff:	c5 fb 10 2b          	vmovsd xmm5,QWORD PTR [rbx]
  214503:	c5 d0 14 ea          	vunpcklps xmm5,xmm5,xmm2
  214507:	c5 d1 5c eb          	vsubpd xmm5,xmm5,xmm3
  21450b:	c5 d1 7c ed          	vhaddpd xmm5,xmm5,xmm5
                var square = diff * diff;
  21450f:	c5 db 59 e4          	vmulsd xmm4,xmm4,xmm4
                sum_of_squares += square;
  214513:	c5 f3 58 cc          	vaddsd xmm1,xmm1,xmm4
                var diff = @intToFloat(f64, result.run_time_ns) - mean;
  214517:	c5 d3 5c e0          	vsubsd xmm4,xmm5,xmm0
                var square = diff * diff;
  21451b:	c5 db 59 e4          	vmulsd xmm4,xmm4,xmm4
                sum_of_squares += square;
  21451f:	c5 f3 58 cc          	vaddsd xmm1,xmm1,xmm4
            for (results.toSlice()) |result| {
  214523:	48 83 c6 04          	add    rsi,0x4
  214527:	48 83 c3 40          	add    rbx,0x40
  21452b:	48 39 f7             	cmp    rdi,rsi
  21452e:	75 80                	jne    2144b0 <benchmark.add+0x9c70>
  214530:	48 85 d2             	test   rdx,rdx
  214533:	74 41                	je     214576 <benchmark.add+0x9d36>
  214535:	48 c1 e6 04          	shl    rsi,0x4
  214539:	48 01 c6             	add    rsi,rax
  21453c:	48 f7 da             	neg    rdx
  21453f:	c5 f9 28 15 d9 bc fe 	vmovapd xmm2,XMMWORD PTR [rip+0xfffffffffffebcd9]        # 200220 <__unnamed_103+0x40>
  214546:	ff 
  214547:	c5 f9 28 1d 01 c2 fe 	vmovapd xmm3,XMMWORD PTR [rip+0xfffffffffffec201]        # 200750 <__unnamed_586+0x10>
  21454e:	ff 
  21454f:	90                   	nop
                var diff = @intToFloat(f64, result.run_time_ns) - mean;
  214550:	c5 fb 10 26          	vmovsd xmm4,QWORD PTR [rsi]
  214554:	c5 d8 14 e2          	vunpcklps xmm4,xmm4,xmm2
  214558:	c5 d9 5c e3          	vsubpd xmm4,xmm4,xmm3
  21455c:	c5 d9 7c e4          	vhaddpd xmm4,xmm4,xmm4
  214560:	c5 db 5c e0          	vsubsd xmm4,xmm4,xmm0
                var square = diff * diff;
  214564:	c5 db 59 e4          	vmulsd xmm4,xmm4,xmm4
                sum_of_squares += square;
  214568:	c5 f3 58 cc          	vaddsd xmm1,xmm1,xmm4
            for (results.toSlice()) |result| {
  21456c:	48 83 c6 10          	add    rsi,0x10
  214570:	48 83 c2 01          	add    rdx,0x1
  214574:	75 da                	jne    214550 <benchmark.add+0x9d10>
            std_dev = @sqrt(f64, sum_of_squares / @intToFloat(f64, results.len - 1));
  214576:	c4 e1 f9 6e c1       	vmovq  xmm0,rcx
  21457b:	c5 f9 62 05 9d bc fe 	vpunpckldq xmm0,xmm0,XMMWORD PTR [rip+0xfffffffffffebc9d]        # 200220 <__unnamed_103+0x40>
  214582:	ff 
  214583:	c5 f9 5c 05 c5 c1 fe 	vsubpd xmm0,xmm0,XMMWORD PTR [rip+0xfffffffffffec1c5]        # 200750 <__unnamed_586+0x10>
  21458a:	ff 
  21458b:	c5 f9 7c c0          	vhaddpd xmm0,xmm0,xmm0
  21458f:	c5 f3 5e c0          	vdivsd xmm0,xmm1,xmm0
  214593:	c5 fb 51 c0          	vsqrtsd xmm0,xmm0,xmm0
  214597:	c5 fb 10 0d 51 c7 fe 	vmovsd xmm1,QWORD PTR [rip+0xfffffffffffec751]        # 200cf0 <app_mask+0x10>
  21459e:	ff 
  21459f:	c5 f9 28 d1          	vmovapd xmm2,xmm1
        if (results.len <= 1) {
  2145a3:	c5 fb 5c ca          	vsubsd xmm1,xmm0,xmm2
  2145a7:	c4 e1 fb 2c c9       	vcvttsd2si rcx,xmm1
  2145ac:	c4 e1 fb 2c f8       	vcvttsd2si rdi,xmm0
  2145b1:	48 ba 00 00 00 00 00 	movabs rdx,0x8000000000000000
  2145b8:	00 00 80 
  2145bb:	48 31 d1             	xor    rcx,rdx
  2145be:	c5 f9 2e c2          	vucomisd xmm0,xmm2
  2145c2:	48 0f 43 f9          	cmovae rdi,rcx
            .iterations = results.items[0].iterations}
  2145c6:	48 8b 70 08          	mov    rsi,QWORD PTR [rax+0x8]
        pSelf.report(Result {
  2145ca:	e8 41 1a 00 00       	call   216010 <BenchmarkFramework_report>
  2145cf:	31 c0                	xor    eax,eax
  2145d1:	e9 88 71 ff ff       	jmp    20b75e <benchmark.add+0xf1e>
            @panic("assertion failure");
  2145d6:	c5 f8 77             	vzeroupper 
  2145d9:	e8 02 00 00 00       	call   2145e0 <panic>
  2145de:	66 90                	xchg   ax,ax

00000000002145e0 <panic>:
        // TODO: fix panic in zen.
        builtin.Os.freestanding, builtin.Os.zen => {
            while (true) {}
        },
        else => {
            const first_trace_addr = @ptrToInt(@returnAddress());
  2145e0:	48 83 ec 18          	sub    rsp,0x18
  2145e4:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
            std.debug.panicExtra(error_return_trace, first_trace_addr, "{}", msg);
  2145e9:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  2145ee:	c6 44 24 10 01       	mov    BYTE PTR [rsp+0x10],0x1
  2145f3:	48 8d 7c 24 08       	lea    rdi,[rsp+0x8]
  2145f8:	e8 03 00 00 00       	call   214600 <panicExtra>
  2145fd:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000214600 <panicExtra>:
    panicExtra(null, first_trace_addr, format, args);
}

var panicking: u8 = 0; // TODO make this a bool

pub fn panicExtra(trace: ?*const builtin.StackTrace, first_trace_addr: ?usize, comptime format: []const u8, args: ...) noreturn {
  214600:	41 57                	push   r15
  214602:	41 56                	push   r14
  214604:	53                   	push   rbx
  214605:	48 83 ec 10          	sub    rsp,0x10
  214609:	b0 01                	mov    al,0x1
    @setCold(true);

    if (@atomicRmw(u8, &panicking, builtin.AtomicRmwOp.Xchg, 1, builtin.AtomicOrder.SeqCst) == 1) {
  21460b:	86 05 ef 19 03 00    	xchg   BYTE PTR [rip+0x319ef],al        # 246000 <panicking>
  214611:	49 89 fe             	mov    r14,rdi
  214614:	3c 01                	cmp    al,0x1
  214616:	74 7e                	je     214696 <panicExtra+0x96>
    if (stderr_stream) |st| {
  214618:	48 8b 1d e9 19 03 00 	mov    rbx,QWORD PTR [rip+0x319e9]        # 246008 <stderr_stream>
  21461f:	48 85 db             	test   rbx,rbx
  214622:	75 36                	jne    21465a <panicExtra+0x5a>
        stderr_file = try io.getStdErr();
  214624:	48 8d 05 05 da 02 00 	lea    rax,[rip+0x2da05]        # 242030 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  21462b:	48 89 05 06 da 02 00 	mov    QWORD PTR [rip+0x2da06],rax        # 242038 <stderr_file_out_stream>
  214632:	4c 8d 3d 17 23 00 00 	lea    r15,[rip+0x2317]        # 216950 <FileOutStream_writeFn>
  214639:	4c 89 3d 00 da 02 00 	mov    QWORD PTR [rip+0x2da00],r15        # 242040 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  214640:	c7 05 e6 d9 02 00 02 	mov    DWORD PTR [rip+0x2d9e6],0x2        # 242030 <stderr_file>
  214647:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  21464a:	48 8d 1d ef d9 02 00 	lea    rbx,[rip+0x2d9ef]        # 242040 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  214651:	48 89 1d b0 19 03 00 	mov    QWORD PTR [rip+0x319b0],rbx        # 246008 <stderr_stream>
  214658:	eb 07                	jmp    214661 <panicExtra+0x61>
  21465a:	4c 8b 3d df d9 02 00 	mov    r15,QWORD PTR [rip+0x2d9df]        # 242040 <stderr_file_out_stream+0x8>
                const casted_value = ([]const u8)(value);
  214661:	c5 f8 10 05 af 14 03 	vmovups xmm0,XMMWORD PTR [rip+0x314af]        # 245b18 <__unnamed_22>
  214668:	00 
  214669:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
  21466e:	48 89 e6             	mov    rsi,rsp
                return output(context, casted_value);
  214671:	48 89 df             	mov    rdi,rbx
  214674:	41 ff d7             	call   r15
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  214677:	66 85 c0             	test   ax,ax
  21467a:	75 1a                	jne    214696 <panicExtra+0x96>
        try output(context, fmt[start_index..]);
  21467c:	48 8d 35 a5 14 03 00 	lea    rsi,[rip+0x314a5]        # 245b28 <__unnamed_23>
  214683:	48 89 df             	mov    rdi,rbx
  214686:	41 ff d7             	call   r15
        // we would want to return here instead of calling abort, so that the thread
        // which first called panic can finish printing a stack trace.
        os.abort();
    }
    const stderr = getStderrStream() catch os.abort();
    stderr.print(format ++ "\n", args) catch os.abort();
  214689:	66 85 c0             	test   ax,ax
  21468c:	75 08                	jne    214696 <panicExtra+0x96>
    if (trace) |t| {
        dumpStackTrace(t);
    }
    dumpCurrentStackTrace(first_trace_addr);
  21468e:	4c 89 f7             	mov    rdi,r14
  214691:	e8 0a 01 00 00       	call   2147a0 <dumpCurrentStackTrace>
  214696:	e8 05 00 00 00       	call   2146a0 <abort>
  21469b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

00000000002146a0 <abort>:
pub const SIG_DFL = @intToPtr(extern fn (i32) void, 0);
pub const SIG_IGN = @intToPtr(extern fn (i32) void, 1);
pub const empty_sigset = []usize{0} ** sigset_t.len;

pub fn raise(sig: i32) usize {
    var set: sigset_t = undefined;
  2146a0:	50                   	push   rax
  2146a1:	c5 fc 10 05 ff 37 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffff37ff]        # 207ea8 <__unnamed_24+0x60>
  2146a8:	ff 
  2146a9:	c5 fc 11 44 24 e0    	vmovups YMMWORD PTR [rsp-0x20],ymm0
  2146af:	c5 fc 10 0d d1 37 ff 	vmovups ymm1,YMMWORD PTR [rip+0xffffffffffff37d1]        # 207e88 <__unnamed_24+0x40>
  2146b6:	ff 
  2146b7:	c5 fc 11 4c 24 c0    	vmovups YMMWORD PTR [rsp-0x40],ymm1
  2146bd:	c5 fc 10 15 a3 37 ff 	vmovups ymm2,YMMWORD PTR [rip+0xffffffffffff37a3]        # 207e68 <__unnamed_24+0x20>
  2146c4:	ff 
  2146c5:	c5 fc 11 54 24 a0    	vmovups YMMWORD PTR [rsp-0x60],ymm2
  2146cb:	c5 fc 10 1d 75 37 ff 	vmovups ymm3,YMMWORD PTR [rip+0xffffffffffff3775]        # 207e48 <__unnamed_24>
  2146d2:	ff 
  2146d3:	c5 fc 11 5c 24 80    	vmovups YMMWORD PTR [rsp-0x80],ymm3
        : "rcx", "r11"
    );
}

pub fn syscall4(number: usize, arg1: usize, arg2: usize, arg3: usize, arg4: usize) usize {
    return asm volatile ("syscall"
  2146d9:	4c 8d 0d 00 c6 fe ff 	lea    r9,[rip+0xfffffffffffec600]        # 200ce0 <app_mask>
  2146e0:	4c 8d 44 24 80       	lea    r8,[rsp-0x80]
  2146e5:	b8 0e 00 00 00       	mov    eax,0xe
  2146ea:	bf 00 00 00 00       	mov    edi,0x0
  2146ef:	41 ba 08 00 00 00    	mov    r10d,0x8
  2146f5:	4c 89 ce             	mov    rsi,r9
  2146f8:	4c 89 c2             	mov    rdx,r8
  2146fb:	0f 05                	syscall 
    return asm volatile ("syscall"
  2146fd:	b8 ba 00 00 00       	mov    eax,0xba
  214702:	0f 05                	syscall 
    blockAppSignals(&set);
    const tid = @intCast(i32, syscall0(SYS_gettid));
    const ret = syscall2(SYS_tkill, @intCast(usize, tid), @intCast(usize, sig));
  214704:	48 63 f8             	movsxd rdi,eax
    return asm volatile ("syscall"
  214707:	b8 c8 00 00 00       	mov    eax,0xc8
  21470c:	be 06 00 00 00       	mov    esi,0x6
  214711:	0f 05                	syscall 
    return asm volatile ("syscall"
  214713:	b8 0e 00 00 00       	mov    eax,0xe
  214718:	bf 02 00 00 00       	mov    edi,0x2
  21471d:	ba 00 00 00 00       	mov    edx,0x0
  214722:	41 ba 08 00 00 00    	mov    r10d,0x8
  214728:	4c 89 c6             	mov    rsi,r8
  21472b:	0f 05                	syscall 
    var set: sigset_t = undefined;
  21472d:	c5 fc 11 44 24 e0    	vmovups YMMWORD PTR [rsp-0x20],ymm0
  214733:	c5 fc 11 4c 24 c0    	vmovups YMMWORD PTR [rsp-0x40],ymm1
  214739:	c5 fc 11 54 24 a0    	vmovups YMMWORD PTR [rsp-0x60],ymm2
  21473f:	c5 fc 11 5c 24 80    	vmovups YMMWORD PTR [rsp-0x80],ymm3
  214745:	b8 0e 00 00 00       	mov    eax,0xe
  21474a:	bf 00 00 00 00       	mov    edi,0x0
  21474f:	41 ba 08 00 00 00    	mov    r10d,0x8
  214755:	4c 89 ce             	mov    rsi,r9
  214758:	4c 89 c2             	mov    rdx,r8
  21475b:	0f 05                	syscall 
    return asm volatile ("syscall"
  21475d:	b8 ba 00 00 00       	mov    eax,0xba
  214762:	0f 05                	syscall 
    const ret = syscall2(SYS_tkill, @intCast(usize, tid), @intCast(usize, sig));
  214764:	48 63 f8             	movsxd rdi,eax
    return asm volatile ("syscall"
  214767:	b8 c8 00 00 00       	mov    eax,0xc8
  21476c:	be 09 00 00 00       	mov    esi,0x9
  214771:	0f 05                	syscall 
    return asm volatile ("syscall"
  214773:	b8 0e 00 00 00       	mov    eax,0xe
  214778:	bf 02 00 00 00       	mov    edi,0x2
  21477d:	31 d2                	xor    edx,edx
  21477f:	41 ba 08 00 00 00    	mov    r10d,0x8
  214785:	4c 89 c6             	mov    rsi,r8
  214788:	0f 05                	syscall 
  21478a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
    }
    switch (builtin.os) {
        Os.linux, Os.macosx, Os.ios => {
            _ = posix.raise(posix.SIGABRT);
            _ = posix.raise(posix.SIGKILL);
            while (true) {}
  214790:	eb fe                	jmp    214790 <abort+0xf0>
  214792:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  214799:	1f 84 00 00 00 00 00 

00000000002147a0 <dumpCurrentStackTrace>:
pub fn dumpCurrentStackTrace(start_addr: ?usize) void {
  2147a0:	55                   	push   rbp
  2147a1:	48 89 e5             	mov    rbp,rsp
  2147a4:	41 57                	push   r15
  2147a6:	41 56                	push   r14
  2147a8:	41 55                	push   r13
  2147aa:	41 54                	push   r12
  2147ac:	53                   	push   rbx
  2147ad:	48 83 e4 e0          	and    rsp,0xffffffffffffffe0
  2147b1:	48 81 ec a0 01 00 00 	sub    rsp,0x1a0
  2147b8:	49 89 fe             	mov    r14,rdi
    if (stderr_stream) |st| {
  2147bb:	48 8b 1d 46 18 03 00 	mov    rbx,QWORD PTR [rip+0x31846]        # 246008 <stderr_stream>
  2147c2:	48 85 db             	test   rbx,rbx
  2147c5:	74 39                	je     214800 <dumpCurrentStackTrace+0x60>
    if (self_debug_info) |info| {
  2147c7:	48 8b 05 4a 18 03 00 	mov    rax,QWORD PTR [rip+0x3184a]        # 246018 <self_debug_info>
  2147ce:	48 89 44 24 68       	mov    QWORD PTR [rsp+0x68],rax
  2147d3:	48 85 c0             	test   rax,rax
  2147d6:	74 6d                	je     214845 <dumpCurrentStackTrace+0xa5>
// TODO make thread safe
var debug_info_allocator: ?*mem.Allocator = null;
var debug_info_direct_allocator: std.heap.DirectAllocator = undefined;
var debug_info_arena_allocator: std.heap.ArenaAllocator = undefined;
fn getDebugInfoAllocator() *mem.Allocator {
    if (debug_info_allocator) |a| return a;
  2147d8:	48 83 3d 40 18 03 00 	cmp    QWORD PTR [rip+0x31840],0x0        # 246020 <debug_info_allocator>
  2147df:	00 
  2147e0:	0f 84 4e 01 00 00    	je     214934 <dumpCurrentStackTrace+0x194>
    }
}

/// TODO make this go through libc when we have it
pub fn getEnvPosix(key: []const u8) ?[]const u8 {
    for (posix_environ_raw) |ptr| {
  2147e6:	48 8b 05 cb d8 02 00 	mov    rax,QWORD PTR [rip+0x2d8cb]        # 2420b8 <posix_environ_raw+0x8>
  2147ed:	48 85 c0             	test   rax,rax
  2147f0:	48 89 5c 24 70       	mov    QWORD PTR [rsp+0x70],rbx
  2147f5:	0f 85 a4 01 00 00    	jne    21499f <dumpCurrentStackTrace+0x1ff>
  2147fb:	e9 5d 02 00 00       	jmp    214a5d <dumpCurrentStackTrace+0x2bd>
        stderr_file = try io.getStdErr();
  214800:	48 8d 05 29 d8 02 00 	lea    rax,[rip+0x2d829]        # 242030 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  214807:	48 89 05 2a d8 02 00 	mov    QWORD PTR [rip+0x2d82a],rax        # 242038 <stderr_file_out_stream>
  21480e:	48 8d 05 3b 21 00 00 	lea    rax,[rip+0x213b]        # 216950 <FileOutStream_writeFn>
  214815:	48 89 05 24 d8 02 00 	mov    QWORD PTR [rip+0x2d824],rax        # 242040 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  21481c:	c7 05 0a d8 02 00 02 	mov    DWORD PTR [rip+0x2d80a],0x2        # 242030 <stderr_file>
  214823:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  214826:	48 8d 1d 13 d8 02 00 	lea    rbx,[rip+0x2d813]        # 242040 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  21482d:	48 89 1d d4 17 03 00 	mov    QWORD PTR [rip+0x317d4],rbx        # 246008 <stderr_stream>
    if (self_debug_info) |info| {
  214834:	48 8b 05 dd 17 03 00 	mov    rax,QWORD PTR [rip+0x317dd]        # 246018 <self_debug_info>
  21483b:	48 89 44 24 68       	mov    QWORD PTR [rsp+0x68],rax
  214840:	48 85 c0             	test   rax,rax
  214843:	75 93                	jne    2147d8 <dumpCurrentStackTrace+0x38>
    if (debug_info_allocator) |a| return a;
  214845:	48 8b 35 d4 17 03 00 	mov    rsi,QWORD PTR [rip+0x317d4]        # 246020 <debug_info_allocator>
  21484c:	48 85 f6             	test   rsi,rsi
  21484f:	75 56                	jne    2148a7 <dumpCurrentStackTrace+0x107>

    debug_info_direct_allocator = std.heap.DirectAllocator.init();
  214851:	c5 fc 10 05 cf 15 03 	vmovups ymm0,YMMWORD PTR [rip+0x315cf]        # 245e28 <__unnamed_25>
  214858:	00 
  214859:	c5 fc 11 05 ef d7 02 	vmovups YMMWORD PTR [rip+0x2d7ef],ymm0        # 242050 <debug_info_direct_allocator>
  214860:	00 
    debug_info_arena_allocator = std.heap.ArenaAllocator.init(&debug_info_direct_allocator.allocator);
  214861:	c5 fa 6f 05 df 15 03 	vmovdqu xmm0,XMMWORD PTR [rip+0x315df]        # 245e48 <__unnamed_26>
  214868:	00 
  214869:	c5 fa 7f 05 ff d7 02 	vmovdqu XMMWORD PTR [rip+0x2d7ff],xmm0        # 242070 <debug_info_arena_allocator>
  214870:	00 
    debug_info_direct_allocator = std.heap.DirectAllocator.init();
  214871:	48 8d 05 d8 d7 02 00 	lea    rax,[rip+0x2d7d8]        # 242050 <debug_info_direct_allocator>
    debug_info_arena_allocator = std.heap.ArenaAllocator.init(&debug_info_direct_allocator.allocator);
  214878:	48 8b 0d d9 15 03 00 	mov    rcx,QWORD PTR [rip+0x315d9]        # 245e58 <__unnamed_26+0x10>
  21487f:	48 89 0d fa d7 02 00 	mov    QWORD PTR [rip+0x2d7fa],rcx        # 242080 <debug_info_arena_allocator+0x10>
  214886:	48 8d 35 e3 d7 02 00 	lea    rsi,[rip+0x2d7e3]        # 242070 <debug_info_arena_allocator>
  21488d:	48 89 05 f4 d7 02 00 	mov    QWORD PTR [rip+0x2d7f4],rax        # 242088 <debug_info_arena_allocator+0x18>
  214894:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  214898:	c5 fe 7f 05 f0 d7 02 	vmovdqu YMMWORD PTR [rip+0x2d7f0],ymm0        # 242090 <debug_info_arena_allocator+0x20>
  21489f:	00 
    debug_info_allocator = &debug_info_arena_allocator.allocator;
  2148a0:	48 89 35 79 17 03 00 	mov    QWORD PTR [rip+0x31779],rsi        # 246020 <debug_info_allocator>
  2148a7:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
        const info = try openSelfDebugInfo(getDebugInfoAllocator());
  2148ac:	c5 f8 77             	vzeroupper 
  2148af:	e8 8c 21 00 00       	call   216a40 <openSelfDebugInfo>
  2148b4:	4c 0f bf 7c 24 20    	movsx  r15,WORD PTR [rsp+0x20]
  2148ba:	4d 85 ff             	test   r15,r15
  2148bd:	74 56                	je     214915 <dumpCurrentStackTrace+0x175>
  2148bf:	4c 8b 33             	mov    r14,QWORD PTR [rbx]
                        try output(context, fmt[start_index..i]);
  2148c2:	48 8d 35 9f 13 03 00 	lea    rsi,[rip+0x3139f]        # 245c68 <__unnamed_27>
  2148c9:	48 89 df             	mov    rdi,rbx
  2148cc:	41 ff d6             	call   r14
  2148cf:	66 85 c0             	test   ax,ax
  2148d2:	0f 85 dd 14 00 00    	jne    215db5 <dumpCurrentStackTrace+0x1615>
        stderr.print("Unable to dump stack trace: Unable to open debug info: {}\n", @errorName(err)) catch return;
  2148d8:	49 c1 e7 04          	shl    r15,0x4
  2148dc:	48 8d 05 1d e7 02 00 	lea    rax,[rip+0x2e71d]        # 243000 <raw+0xf38>
                const casted_value = ([]const u8)(value);
  2148e3:	c4 c1 7a 6f 04 07    	vmovdqu xmm0,XMMWORD PTR [r15+rax*1]
  2148e9:	c5 f9 7f 44 24 20    	vmovdqa XMMWORD PTR [rsp+0x20],xmm0
  2148ef:	48 8d 74 24 20       	lea    rsi,[rsp+0x20]
                return output(context, casted_value);
  2148f4:	48 89 df             	mov    rdi,rbx
  2148f7:	41 ff d6             	call   r14
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  2148fa:	66 85 c0             	test   ax,ax
  2148fd:	0f 85 b2 14 00 00    	jne    215db5 <dumpCurrentStackTrace+0x1615>
        try output(context, fmt[start_index..]);
  214903:	48 8d 35 6e 13 03 00 	lea    rsi,[rip+0x3136e]        # 245c78 <__unnamed_28>
  21490a:	48 89 df             	mov    rdi,rbx
  21490d:	41 ff d6             	call   r14
  214910:	e9 a0 14 00 00       	jmp    215db5 <dumpCurrentStackTrace+0x1615>
        const info = try openSelfDebugInfo(getDebugInfoAllocator());
  214915:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
  21491a:	48 89 44 24 68       	mov    QWORD PTR [rsp+0x68],rax
        self_debug_info = info;
  21491f:	48 89 05 f2 16 03 00 	mov    QWORD PTR [rip+0x316f2],rax        # 246018 <self_debug_info>
    if (debug_info_allocator) |a| return a;
  214926:	48 83 3d f2 16 03 00 	cmp    QWORD PTR [rip+0x316f2],0x0        # 246020 <debug_info_allocator>
  21492d:	00 
  21492e:	0f 85 b2 fe ff ff    	jne    2147e6 <dumpCurrentStackTrace+0x46>
    debug_info_direct_allocator = std.heap.DirectAllocator.init();
  214934:	c5 fc 10 05 ec 14 03 	vmovups ymm0,YMMWORD PTR [rip+0x314ec]        # 245e28 <__unnamed_25>
  21493b:	00 
  21493c:	c5 fc 11 05 0c d7 02 	vmovups YMMWORD PTR [rip+0x2d70c],ymm0        # 242050 <debug_info_direct_allocator>
  214943:	00 
    debug_info_arena_allocator = std.heap.ArenaAllocator.init(&debug_info_direct_allocator.allocator);
  214944:	c5 fa 6f 05 fc 14 03 	vmovdqu xmm0,XMMWORD PTR [rip+0x314fc]        # 245e48 <__unnamed_26>
  21494b:	00 
  21494c:	c5 fa 7f 05 1c d7 02 	vmovdqu XMMWORD PTR [rip+0x2d71c],xmm0        # 242070 <debug_info_arena_allocator>
  214953:	00 
    debug_info_direct_allocator = std.heap.DirectAllocator.init();
  214954:	48 8d 05 f5 d6 02 00 	lea    rax,[rip+0x2d6f5]        # 242050 <debug_info_direct_allocator>
    debug_info_arena_allocator = std.heap.ArenaAllocator.init(&debug_info_direct_allocator.allocator);
  21495b:	48 8b 0d f6 14 03 00 	mov    rcx,QWORD PTR [rip+0x314f6]        # 245e58 <__unnamed_26+0x10>
  214962:	48 89 0d 17 d7 02 00 	mov    QWORD PTR [rip+0x2d717],rcx        # 242080 <debug_info_arena_allocator+0x10>
  214969:	48 8d 0d 00 d7 02 00 	lea    rcx,[rip+0x2d700]        # 242070 <debug_info_arena_allocator>
  214970:	48 89 05 11 d7 02 00 	mov    QWORD PTR [rip+0x2d711],rax        # 242088 <debug_info_arena_allocator+0x18>
  214977:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  21497b:	c5 fe 7f 05 0d d7 02 	vmovdqu YMMWORD PTR [rip+0x2d70d],ymm0        # 242090 <debug_info_arena_allocator+0x20>
  214982:	00 
    debug_info_allocator = &debug_info_arena_allocator.allocator;
  214983:	48 89 0d 96 16 03 00 	mov    QWORD PTR [rip+0x31696],rcx        # 246020 <debug_info_allocator>
  21498a:	48 8b 05 27 d7 02 00 	mov    rax,QWORD PTR [rip+0x2d727]        # 2420b8 <posix_environ_raw+0x8>
  214991:	48 85 c0             	test   rax,rax
  214994:	48 89 5c 24 70       	mov    QWORD PTR [rsp+0x70],rbx
  214999:	0f 84 be 00 00 00    	je     214a5d <dumpCurrentStackTrace+0x2bd>
  21499f:	48 8b 0d 0a d7 02 00 	mov    rcx,QWORD PTR [rip+0x2d70a]        # 2420b0 <posix_environ_raw>
  2149a6:	31 d2                	xor    edx,edx
  2149a8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  2149af:	00 
  2149b0:	48 8b 34 d1          	mov    rsi,QWORD PTR [rcx+rdx*8]
  2149b4:	48 c7 c7 f1 ff ff ff 	mov    rdi,0xfffffffffffffff1
        var line_i: usize = 0;
        while (ptr[line_i] != 0 and ptr[line_i] != '=') : (line_i += 1) {}
  2149bb:	8a 5c 3e 0f          	mov    bl,BYTE PTR [rsi+rdi*1+0xf]
  2149bf:	84 db                	test   bl,bl
  2149c1:	74 1f                	je     2149e2 <dumpCurrentStackTrace+0x242>
  2149c3:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  2149ca:	84 00 00 00 00 00 
  2149d0:	80 fb 3d             	cmp    bl,0x3d
  2149d3:	74 0d                	je     2149e2 <dumpCurrentStackTrace+0x242>
  2149d5:	48 83 c7 01          	add    rdi,0x1
  2149d9:	0f b6 5c 3e 0f       	movzx  ebx,BYTE PTR [rsi+rdi*1+0xf]
  2149de:	84 db                	test   bl,bl
  2149e0:	75 ee                	jne    2149d0 <dumpCurrentStackTrace+0x230>
    if (a.len != b.len) return false;
  2149e2:	48 85 ff             	test   rdi,rdi
  2149e5:	75 69                	jne    214a50 <dumpCurrentStackTrace+0x2b0>
        if (b[index] != item) return false;
  2149e7:	80 3e 5a             	cmp    BYTE PTR [rsi],0x5a
  2149ea:	75 64                	jne    214a50 <dumpCurrentStackTrace+0x2b0>
  2149ec:	80 7e 01 49          	cmp    BYTE PTR [rsi+0x1],0x49
  2149f0:	75 5e                	jne    214a50 <dumpCurrentStackTrace+0x2b0>
  2149f2:	80 7e 02 47          	cmp    BYTE PTR [rsi+0x2],0x47
  2149f6:	75 58                	jne    214a50 <dumpCurrentStackTrace+0x2b0>
  2149f8:	80 7e 03 5f          	cmp    BYTE PTR [rsi+0x3],0x5f
  2149fc:	75 52                	jne    214a50 <dumpCurrentStackTrace+0x2b0>
  2149fe:	80 7e 04 44          	cmp    BYTE PTR [rsi+0x4],0x44
  214a02:	75 4c                	jne    214a50 <dumpCurrentStackTrace+0x2b0>
  214a04:	80 7e 05 45          	cmp    BYTE PTR [rsi+0x5],0x45
  214a08:	75 46                	jne    214a50 <dumpCurrentStackTrace+0x2b0>
  214a0a:	80 7e 06 42          	cmp    BYTE PTR [rsi+0x6],0x42
  214a0e:	75 40                	jne    214a50 <dumpCurrentStackTrace+0x2b0>
  214a10:	80 7e 07 55          	cmp    BYTE PTR [rsi+0x7],0x55
  214a14:	75 3a                	jne    214a50 <dumpCurrentStackTrace+0x2b0>
  214a16:	80 7e 08 47          	cmp    BYTE PTR [rsi+0x8],0x47
  214a1a:	75 34                	jne    214a50 <dumpCurrentStackTrace+0x2b0>
  214a1c:	80 7e 09 5f          	cmp    BYTE PTR [rsi+0x9],0x5f
  214a20:	75 2e                	jne    214a50 <dumpCurrentStackTrace+0x2b0>
  214a22:	80 7e 0a 43          	cmp    BYTE PTR [rsi+0xa],0x43
  214a26:	75 28                	jne    214a50 <dumpCurrentStackTrace+0x2b0>
  214a28:	80 7e 0b 4f          	cmp    BYTE PTR [rsi+0xb],0x4f
  214a2c:	75 22                	jne    214a50 <dumpCurrentStackTrace+0x2b0>
  214a2e:	80 7e 0c 4c          	cmp    BYTE PTR [rsi+0xc],0x4c
  214a32:	75 1c                	jne    214a50 <dumpCurrentStackTrace+0x2b0>
  214a34:	80 7e 0d 4f          	cmp    BYTE PTR [rsi+0xd],0x4f
  214a38:	75 16                	jne    214a50 <dumpCurrentStackTrace+0x2b0>
  214a3a:	80 7e 0e 52          	cmp    BYTE PTR [rsi+0xe],0x52
  214a3e:	0f 84 28 14 00 00    	je     215e6c <dumpCurrentStackTrace+0x16cc>
  214a44:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  214a4b:	00 00 00 00 00 
    for (posix_environ_raw) |ptr| {
  214a50:	48 83 c2 01          	add    rdx,0x1
  214a54:	48 39 c2             	cmp    rdx,rax
  214a57:	0f 82 53 ff ff ff    	jb     2149b0 <dumpCurrentStackTrace+0x210>
    return syscall3(SYS_ioctl, @intCast(usize, fd), TIOCGWINSZ, @ptrToInt(&wsz)) == 0;
  214a5d:	48 63 3d cc d5 02 00 	movsxd rdi,DWORD PTR [rip+0x2d5cc]        # 242030 <stderr_file>
  214a64:	48 8d 54 24 20       	lea    rdx,[rsp+0x20]
    return asm volatile ("syscall"
  214a69:	b8 10 00 00 00       	mov    eax,0x10
  214a6e:	be 13 54 00 00       	mov    esi,0x5413
  214a73:	0f 05                	syscall 
  214a75:	48 85 c0             	test   rax,rax
  214a78:	0f 94 44 24 07       	sete   BYTE PTR [rsp+0x7]
    if (start_addr) |addr| {
  214a7d:	41 80 7e 08 01       	cmp    BYTE PTR [r14+0x8],0x1
  214a82:	48 8b 74 24 68       	mov    rsi,QWORD PTR [rsp+0x68]
  214a87:	75 0f                	jne    214a98 <dumpCurrentStackTrace+0x2f8>
  214a89:	49 8b 0e             	mov    rcx,QWORD PTR [r14]
  214a8c:	b0 01                	mov    al,0x1
    while (fp != 0) : (fp = @intToPtr(*const usize, fp).*) {
  214a8e:	48 85 ed             	test   rbp,rbp
  214a91:	75 10                	jne    214aa3 <dumpCurrentStackTrace+0x303>
  214a93:	e9 1d 13 00 00       	jmp    215db5 <dumpCurrentStackTrace+0x1615>
  214a98:	31 c0                	xor    eax,eax
  214a9a:	48 85 ed             	test   rbp,rbp
  214a9d:	0f 84 12 13 00 00    	je     215db5 <dumpCurrentStackTrace+0x1615>
  214aa3:	48 89 ea             	mov    rdx,rbp
  214aa6:	c4 62 7d 59 25 11 c2 	vpbroadcastq ymm12,QWORD PTR [rip+0xfffffffffffec211]        # 200cc0 <__unnamed_456+0x70>
  214aad:	fe ff 
  214aaf:	c4 62 7d 59 2d 78 c2 	vpbroadcastq ymm13,QWORD PTR [rip+0xfffffffffffec278]        # 200d30 <app_mask+0x50>
  214ab6:	fe ff 
  214ab8:	c5 7d 7f a4 24 00 01 	vmovdqa YMMWORD PTR [rsp+0x100],ymm12
  214abf:	00 00 
  214ac1:	c5 7d 7f ac 24 e0 00 	vmovdqa YMMWORD PTR [rsp+0xe0],ymm13
  214ac8:	00 00 
  214aca:	48 89 8c 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],rcx
  214ad1:	00 
  214ad2:	48 89 74 24 68       	mov    QWORD PTR [rsp+0x68],rsi
  214ad7:	e9 44 12 00 00       	jmp    215d20 <dumpCurrentStackTrace+0x1580>
  214adc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  214ae0:	48 89 94 24 b0 00 00 	mov    QWORD PTR [rsp+0xb0],rdx
  214ae7:	00 
    var in_file_stream = io.FileInStream.init(&st.self_exe_file);
  214ae8:	48 89 b4 24 c8 00 00 	mov    QWORD PTR [rsp+0xc8],rsi
  214aef:	00 
  214af0:	48 8d 05 49 71 00 00 	lea    rax,[rip+0x7149]        # 21bc40 <FileInStream_readFn>
  214af7:	48 89 84 24 d0 00 00 	mov    QWORD PTR [rsp+0xd0],rax
  214afe:	00 
  214aff:	48 8b 86 b8 00 00 00 	mov    rax,QWORD PTR [rsi+0xb8]
  214b06:	48 89 44 24 78       	mov    QWORD PTR [rsp+0x78],rax
    for (st.compile_unit_list.toSlice()) |*compile_unit| {
  214b0b:	48 85 c0             	test   rax,rax
  214b0e:	0f 84 6c 04 00 00    	je     214f80 <dumpCurrentStackTrace+0x7e0>
  214b14:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  214b19:	4c 8b 88 a8 00 00 00 	mov    r9,QWORD PTR [rax+0xa8]
  214b20:	45 31 e4             	xor    r12d,r12d
  214b23:	e9 08 02 00 00       	jmp    214d30 <dumpCurrentStackTrace+0x590>
            for (bytes) |b, index| {
  214b28:	48 89 c3             	mov    rbx,rax
  214b2b:	48 83 e3 f0          	and    rbx,0xfffffffffffffff0
  214b2f:	48 8d 73 f0          	lea    rsi,[rbx-0x10]
  214b33:	48 89 f7             	mov    rdi,rsi
  214b36:	48 c1 ef 04          	shr    rdi,0x4
  214b3a:	44 8d 47 01          	lea    r8d,[rdi+0x1]
  214b3e:	41 83 e0 01          	and    r8d,0x1
  214b42:	48 85 f6             	test   rsi,rsi
  214b45:	0f 84 bd 01 00 00    	je     214d08 <dumpCurrentStackTrace+0x568>
  214b4b:	49 8d 70 ff          	lea    rsi,[r8-0x1]
  214b4f:	48 29 fe             	sub    rsi,rdi
  214b52:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  214b56:	31 ff                	xor    edi,edi
  214b58:	c5 fd 6f 25 40 b6 fe 	vmovdqa ymm4,YMMWORD PTR [rip+0xfffffffffffeb640]        # 2001a0 <__unnamed_103-0x40>
  214b5f:	ff 
  214b60:	c5 f1 ef c9          	vpxor  xmm1,xmm1,xmm1
  214b64:	c5 e1 ef db          	vpxor  xmm3,xmm3,xmm3
  214b68:	c5 e9 ef d2          	vpxor  xmm2,xmm2,xmm2
  214b6c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  214b70:	c4 e2 7d 32 2c 39    	vpmovzxbq ymm5,DWORD PTR [rcx+rdi*1]
  214b76:	c4 e2 7d 32 74 39 04 	vpmovzxbq ymm6,DWORD PTR [rcx+rdi*1+0x4]
  214b7d:	c4 e2 7d 32 7c 39 08 	vpmovzxbq ymm7,DWORD PTR [rcx+rdi*1+0x8]
  214b84:	c4 62 7d 32 44 39 0c 	vpmovzxbq ymm8,DWORD PTR [rcx+rdi*1+0xc]
  214b8b:	c5 b5 73 f4 03       	vpsllq ymm9,ymm4,0x3
  214b90:	c4 41 35 d4 d4       	vpaddq ymm10,ymm9,ymm12
  214b95:	c4 41 35 db dd       	vpand  ymm11,ymm9,ymm13
  214b9a:	c4 41 2d db d5       	vpand  ymm10,ymm10,ymm13
  214b9f:	c4 c2 d5 47 eb       	vpsllvq ymm5,ymm5,ymm11
  214ba4:	c5 d5 eb c0          	vpor   ymm0,ymm5,ymm0
  214ba8:	c4 c2 cd 47 ea       	vpsllvq ymm5,ymm6,ymm10
  214bad:	c5 d5 eb c9          	vpor   ymm1,ymm5,ymm1
  214bb1:	c4 c2 c5 47 eb       	vpsllvq ymm5,ymm7,ymm11
  214bb6:	c5 d5 eb db          	vpor   ymm3,ymm5,ymm3
  214bba:	c4 c2 bd 47 ea       	vpsllvq ymm5,ymm8,ymm10
  214bbf:	c4 e2 7d 32 74 39 10 	vpmovzxbq ymm6,DWORD PTR [rcx+rdi*1+0x10]
  214bc6:	c4 e2 7d 32 7c 39 14 	vpmovzxbq ymm7,DWORD PTR [rcx+rdi*1+0x14]
  214bcd:	c4 62 7d 32 44 39 18 	vpmovzxbq ymm8,DWORD PTR [rcx+rdi*1+0x18]
  214bd4:	c5 d5 eb d2          	vpor   ymm2,ymm5,ymm2
  214bd8:	c4 e2 7d 32 6c 39 1c 	vpmovzxbq ymm5,DWORD PTR [rcx+rdi*1+0x1c]
  214bdf:	c4 62 7d 59 15 38 c1 	vpbroadcastq ymm10,QWORD PTR [rip+0xfffffffffffec138]        # 200d20 <app_mask+0x40>
  214be6:	fe ff 
  214be8:	c4 41 35 d4 d2       	vpaddq ymm10,ymm9,ymm10
  214bed:	c4 62 7d 59 1d 72 c0 	vpbroadcastq ymm11,QWORD PTR [rip+0xfffffffffffec072]        # 200c68 <__unnamed_456+0x18>
  214bf4:	fe ff 
  214bf6:	c4 41 35 d4 cb       	vpaddq ymm9,ymm9,ymm11
  214bfb:	c4 41 2d db d5       	vpand  ymm10,ymm10,ymm13
  214c00:	c4 41 35 db cd       	vpand  ymm9,ymm9,ymm13
  214c05:	c4 c2 cd 47 f2       	vpsllvq ymm6,ymm6,ymm10
  214c0a:	c5 cd eb c0          	vpor   ymm0,ymm6,ymm0
  214c0e:	c4 c2 c5 47 f1       	vpsllvq ymm6,ymm7,ymm9
  214c13:	c5 cd eb c9          	vpor   ymm1,ymm6,ymm1
  214c17:	c4 c2 bd 47 f2       	vpsllvq ymm6,ymm8,ymm10
  214c1c:	c5 cd eb db          	vpor   ymm3,ymm6,ymm3
  214c20:	c4 c2 d5 47 e9       	vpsllvq ymm5,ymm5,ymm9
  214c25:	c5 d5 eb d2          	vpor   ymm2,ymm5,ymm2
            for (bytes) |b, index| {
  214c29:	48 83 c7 20          	add    rdi,0x20
  214c2d:	c4 c1 5d d4 e4       	vpaddq ymm4,ymm4,ymm12
  214c32:	48 83 c6 02          	add    rsi,0x2
  214c36:	0f 85 34 ff ff ff    	jne    214b70 <dumpCurrentStackTrace+0x3d0>
  214c3c:	4d 85 c0             	test   r8,r8
  214c3f:	74 53                	je     214c94 <dumpCurrentStackTrace+0x4f4>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  214c41:	c4 e2 7d 32 6c 39 0c 	vpmovzxbq ymm5,DWORD PTR [rcx+rdi*1+0xc]
  214c48:	c5 dd 73 f4 03       	vpsllq ymm4,ymm4,0x3
  214c4d:	c4 c1 5d d4 f4       	vpaddq ymm6,ymm4,ymm12
  214c52:	c4 c1 4d db f5       	vpand  ymm6,ymm6,ymm13
  214c57:	c4 e2 d5 47 ee       	vpsllvq ymm5,ymm5,ymm6
  214c5c:	c4 e2 7d 32 7c 39 08 	vpmovzxbq ymm7,DWORD PTR [rcx+rdi*1+0x8]
  214c63:	c5 d5 eb d2          	vpor   ymm2,ymm5,ymm2
  214c67:	c4 c1 5d db e5       	vpand  ymm4,ymm4,ymm13
  214c6c:	c4 e2 c5 47 ec       	vpsllvq ymm5,ymm7,ymm4
  214c71:	c5 d5 eb db          	vpor   ymm3,ymm5,ymm3
  214c75:	c4 e2 7d 32 6c 39 04 	vpmovzxbq ymm5,DWORD PTR [rcx+rdi*1+0x4]
  214c7c:	c4 e2 d5 47 ee       	vpsllvq ymm5,ymm5,ymm6
  214c81:	c5 d5 eb c9          	vpor   ymm1,ymm5,ymm1
  214c85:	c4 e2 7d 32 2c 39    	vpmovzxbq ymm5,DWORD PTR [rcx+rdi*1]
  214c8b:	c4 e2 d5 47 e4       	vpsllvq ymm4,ymm5,ymm4
  214c90:	c5 dd eb c0          	vpor   ymm0,ymm4,ymm0
  214c94:	c5 f5 eb ca          	vpor   ymm1,ymm1,ymm2
  214c98:	c5 fd eb c3          	vpor   ymm0,ymm0,ymm3
  214c9c:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  214ca0:	c4 e3 7d 39 c1 01    	vextracti128 xmm1,ymm0,0x1
  214ca6:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  214caa:	c5 f9 70 c8 4e       	vpshufd xmm1,xmm0,0x4e
  214caf:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  214cb3:	c4 e1 f9 7e c6       	vmovq  rsi,xmm0
  214cb8:	48 39 d8             	cmp    rax,rbx
            for (bytes) |b, index| {
  214cbb:	74 31                	je     214cee <dumpCurrentStackTrace+0x54e>
  214cbd:	48 29 d8             	sub    rax,rbx
  214cc0:	48 01 d9             	add    rcx,rbx
  214cc3:	48 c1 e3 03          	shl    rbx,0x3
  214cc7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  214cce:	00 00 
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  214cd0:	0f b6 39             	movzx  edi,BYTE PTR [rcx]
  214cd3:	89 da                	mov    edx,ebx
  214cd5:	80 e2 38             	and    dl,0x38
  214cd8:	c4 e2 e9 f7 d7       	shlx   rdx,rdi,rdx
  214cdd:	48 09 d6             	or     rsi,rdx
            for (bytes) |b, index| {
  214ce0:	48 83 c3 08          	add    rbx,0x8
  214ce4:	48 83 c1 01          	add    rcx,0x1
  214ce8:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  214cec:	75 e2                	jne    214cd0 <dumpCurrentStackTrace+0x530>
            if (st.debug_ranges) |debug_ranges| {
  214cee:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  214cf3:	48 8b 80 80 00 00 00 	mov    rax,QWORD PTR [rax+0x80]
  214cfa:	48 85 c0             	test   rax,rax
  214cfd:	0f 85 fd 00 00 00    	jne    214e00 <dumpCurrentStackTrace+0x660>
  214d03:	e9 68 02 00 00       	jmp    214f70 <dumpCurrentStackTrace+0x7d0>
  214d08:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  214d0c:	31 ff                	xor    edi,edi
  214d0e:	c5 fd 6f 25 8a b4 fe 	vmovdqa ymm4,YMMWORD PTR [rip+0xfffffffffffeb48a]        # 2001a0 <__unnamed_103-0x40>
  214d15:	ff 
  214d16:	c5 f1 ef c9          	vpxor  xmm1,xmm1,xmm1
  214d1a:	c5 e1 ef db          	vpxor  xmm3,xmm3,xmm3
  214d1e:	c5 e9 ef d2          	vpxor  xmm2,xmm2,xmm2
  214d22:	4d 85 c0             	test   r8,r8
  214d25:	0f 85 16 ff ff ff    	jne    214c41 <dumpCurrentStackTrace+0x4a1>
  214d2b:	e9 64 ff ff ff       	jmp    214c94 <dumpCurrentStackTrace+0x4f4>
        if (compile_unit.pc_range) |range| {
  214d30:	4f 8d 34 64          	lea    r14,[r12+r12*2]
  214d34:	49 c1 e6 04          	shl    r14,0x4
  214d38:	43 80 7c 31 28 01    	cmp    BYTE PTR [r9+r14*1+0x28],0x1
  214d3e:	75 12                	jne    214d52 <dumpCurrentStackTrace+0x5b2>
            if (target_address >= range.start and target_address < range.end) return compile_unit;
  214d40:	4f 39 6c 31 18       	cmp    QWORD PTR [r9+r14*1+0x18],r13
  214d45:	77 0b                	ja     214d52 <dumpCurrentStackTrace+0x5b2>
  214d47:	4f 39 6c 31 20       	cmp    QWORD PTR [r9+r14*1+0x20],r13
  214d4c:	0f 87 4c 04 00 00    	ja     21519e <dumpCurrentStackTrace+0x9fe>
        if (compile_unit.die.getAttrSecOffset(DW.AT_ranges)) |ranges_offset| {
  214d52:	4b 8b 4c 31 08       	mov    rcx,QWORD PTR [r9+r14*1+0x8]
  214d57:	48 8b 41 20          	mov    rax,QWORD PTR [rcx+0x20]
        for (self.attrs.toSliceConst()) |*attr| {
  214d5b:	48 85 c0             	test   rax,rax
  214d5e:	0f 84 0c 02 00 00    	je     214f70 <dumpCurrentStackTrace+0x7d0>
  214d64:	4b 8d 14 31          	lea    rdx,[r9+r14*1]
  214d68:	48 83 c2 08          	add    rdx,0x8
  214d6c:	48 89 94 24 38 01 00 	mov    QWORD PTR [rsp+0x138],rdx
  214d73:	00 
  214d74:	48 8b 49 10          	mov    rcx,QWORD PTR [rcx+0x10]
            if (attr.id == id) return &attr.value;
  214d78:	48 83 c1 20          	add    rcx,0x20
  214d7c:	31 d2                	xor    edx,edx
  214d7e:	66 90                	xchg   ax,ax
  214d80:	48 83 79 e0 55       	cmp    QWORD PTR [rcx-0x20],0x55
  214d85:	74 19                	je     214da0 <dumpCurrentStackTrace+0x600>
        for (self.attrs.toSliceConst()) |*attr| {
  214d87:	48 83 c2 01          	add    rdx,0x1
  214d8b:	48 83 c1 28          	add    rcx,0x28
  214d8f:	48 39 c2             	cmp    rdx,rax
  214d92:	72 ec                	jb     214d80 <dumpCurrentStackTrace+0x5e0>
  214d94:	e9 d7 01 00 00       	jmp    214f70 <dumpCurrentStackTrace+0x7d0>
  214d99:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  214da0:	8a 01                	mov    al,BYTE PTR [rcx]
  214da2:	3c 05                	cmp    al,0x5
        return switch (form_value.*) {
  214da4:	74 41                	je     214de7 <dumpCurrentStackTrace+0x647>
  214da6:	3c 02                	cmp    al,0x2
  214da8:	0f 85 d2 01 00 00    	jne    214f80 <dumpCurrentStackTrace+0x7e0>
            FormValue.Const => |value| value.asUnsignedLe(),
  214dae:	48 8b 41 f0          	mov    rax,QWORD PTR [rcx-0x10]
        if (self.payload.len > @sizeOf(u64)) return error.InvalidDebugInfo;
  214db2:	48 83 f8 08          	cmp    rax,0x8
  214db6:	0f 87 c4 01 00 00    	ja     214f80 <dumpCurrentStackTrace+0x7e0>
            FormValue.Const => |value| value.asUnsignedLe(),
  214dbc:	8a 51 f8             	mov    dl,BYTE PTR [rcx-0x8]
        if (self.signed) return error.InvalidDebugInfo;
  214dbf:	84 d2                	test   dl,dl
  214dc1:	0f 85 b9 01 00 00    	jne    214f80 <dumpCurrentStackTrace+0x7e0>
  214dc7:	48 85 c0             	test   rax,rax
  214dca:	0f 84 7c 01 00 00    	je     214f4c <dumpCurrentStackTrace+0x7ac>
  214dd0:	48 8b 49 e8          	mov    rcx,QWORD PTR [rcx-0x18]
  214dd4:	48 83 f8 10          	cmp    rax,0x10
  214dd8:	0f 83 4a fd ff ff    	jae    214b28 <dumpCurrentStackTrace+0x388>
  214dde:	31 db                	xor    ebx,ebx
  214de0:	31 f6                	xor    esi,esi
  214de2:	e9 d6 fe ff ff       	jmp    214cbd <dumpCurrentStackTrace+0x51d>
            FormValue.SecOffset => |value| value,
  214de7:	48 8b 71 e8          	mov    rsi,QWORD PTR [rcx-0x18]
            if (st.debug_ranges) |debug_ranges| {
  214deb:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  214df0:	48 8b 80 80 00 00 00 	mov    rax,QWORD PTR [rax+0x80]
  214df7:	48 85 c0             	test   rax,rax
  214dfa:	0f 84 70 01 00 00    	je     214f70 <dumpCurrentStackTrace+0x7d0>
    if (@maxValue(@typeOf(x)) > @maxValue(T) and x > @maxValue(T)) {
  214e00:	48 03 70 18          	add    rsi,QWORD PTR [rax+0x18]
  214e04:	0f 88 76 01 00 00    	js     214f80 <dumpCurrentStackTrace+0x7e0>
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  214e0a:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  214e0f:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  214e12:	b8 08 00 00 00       	mov    eax,0x8
  214e17:	31 d2                	xor    edx,edx
  214e19:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  214e1b:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
        switch (builtin.os) {
            Os.linux, Os.macosx, Os.ios => {
                const ipos = try math.cast(isize, pos);
                const result = posix.lseek(self.handle, ipos, posix.SEEK_SET);
                const err = posix.getErrno(result);
                if (err > 0) {
  214e21:	0f 83 59 01 00 00    	jae    214f80 <dumpCurrentStackTrace+0x7e0>
  214e27:	4c 89 cb             	mov    rbx,r9
            try self.readNoEof(bytes[0..]);
  214e2a:	48 8d 84 24 b8 00 00 	lea    rax,[rsp+0xb8]
  214e31:	00 
  214e32:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  214e37:	48 c7 44 24 10 08 00 	mov    QWORD PTR [rsp+0x10],0x8
  214e3e:	00 00 
            return self.readFn(self, buffer);
  214e40:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  214e45:	48 8d b4 24 d0 00 00 	lea    rsi,[rsp+0xd0]
  214e4c:	00 
  214e4d:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
  214e52:	c5 f8 77             	vzeroupper 
  214e55:	ff 94 24 d0 00 00 00 	call   QWORD PTR [rsp+0xd0]
            const amt_read = try self.read(buf);
  214e5c:	66 83 7c 24 20 00    	cmp    WORD PTR [rsp+0x20],0x0
  214e62:	0f 85 18 01 00 00    	jne    214f80 <dumpCurrentStackTrace+0x7e0>
  214e68:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
  214e6d:	0f 1f 00             	nop    DWORD PTR [rax]
            if (amt_read < buf.len) return error.EndOfStream;
  214e70:	48 3b 44 24 10       	cmp    rax,QWORD PTR [rsp+0x10]
  214e75:	0f 82 05 01 00 00    	jb     214f80 <dumpCurrentStackTrace+0x7e0>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  214e7b:	4c 8b bc 24 b8 00 00 	mov    r15,QWORD PTR [rsp+0xb8]
  214e82:	00 
            try self.readNoEof(bytes[0..]);
  214e83:	48 8d 84 24 b8 00 00 	lea    rax,[rsp+0xb8]
  214e8a:	00 
  214e8b:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  214e90:	48 c7 44 24 10 08 00 	mov    QWORD PTR [rsp+0x10],0x8
  214e97:	00 00 
            return self.readFn(self, buffer);
  214e99:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  214e9e:	48 8d b4 24 d0 00 00 	lea    rsi,[rsp+0xd0]
  214ea5:	00 
  214ea6:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
  214eab:	ff 94 24 d0 00 00 00 	call   QWORD PTR [rsp+0xd0]
            const amt_read = try self.read(buf);
  214eb2:	66 83 7c 24 20 00    	cmp    WORD PTR [rsp+0x20],0x0
  214eb8:	0f 85 c2 00 00 00    	jne    214f80 <dumpCurrentStackTrace+0x7e0>
  214ebe:	48 8b 44 24 10       	mov    rax,QWORD PTR [rsp+0x10]
  214ec3:	48 39 44 24 28       	cmp    QWORD PTR [rsp+0x28],rax
  214ec8:	0f 82 b2 00 00 00    	jb     214f80 <dumpCurrentStackTrace+0x7e0>
  214ece:	48 8b 84 24 b8 00 00 	mov    rax,QWORD PTR [rsp+0xb8]
  214ed5:	00 
                    if (begin_addr == 0 and end_addr == 0) {
  214ed6:	48 89 c1             	mov    rcx,rax
  214ed9:	4c 09 f9             	or     rcx,r15
  214edc:	c5 7d 6f a4 24 00 01 	vmovdqa ymm12,YMMWORD PTR [rsp+0x100]
  214ee3:	00 00 
  214ee5:	c5 7d 6f ac 24 e0 00 	vmovdqa ymm13,YMMWORD PTR [rsp+0xe0]
  214eec:	00 00 
  214eee:	49 89 d9             	mov    r9,rbx
  214ef1:	74 7d                	je     214f70 <dumpCurrentStackTrace+0x7d0>
                    if (begin_addr == @maxValue(usize)) {
  214ef3:	49 83 ff ff          	cmp    r15,0xffffffffffffffff
  214ef7:	74 0e                	je     214f07 <dumpCurrentStackTrace+0x767>
                    if (target_address >= begin_addr and target_address < end_addr) {
  214ef9:	4d 39 ef             	cmp    r15,r13
  214efc:	77 09                	ja     214f07 <dumpCurrentStackTrace+0x767>
  214efe:	4c 39 e8             	cmp    rax,r13
  214f01:	0f 87 8d 02 00 00    	ja     215194 <dumpCurrentStackTrace+0x9f4>
            try self.readNoEof(bytes[0..]);
  214f07:	48 8d 84 24 b8 00 00 	lea    rax,[rsp+0xb8]
  214f0e:	00 
  214f0f:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  214f14:	48 c7 44 24 10 08 00 	mov    QWORD PTR [rsp+0x10],0x8
  214f1b:	00 00 
            return self.readFn(self, buffer);
  214f1d:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  214f22:	48 8d b4 24 d0 00 00 	lea    rsi,[rsp+0xd0]
  214f29:	00 
  214f2a:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
  214f2f:	c5 f8 77             	vzeroupper 
  214f32:	ff 94 24 d0 00 00 00 	call   QWORD PTR [rsp+0xd0]
  214f39:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  214f3e:	66 83 7c 24 20 00    	cmp    WORD PTR [rsp+0x20],0x0
  214f44:	0f 84 26 ff ff ff    	je     214e70 <dumpCurrentStackTrace+0x6d0>
  214f4a:	eb 34                	jmp    214f80 <dumpCurrentStackTrace+0x7e0>
        return switch (form_value.*) {
  214f4c:	31 f6                	xor    esi,esi
            if (st.debug_ranges) |debug_ranges| {
  214f4e:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  214f53:	48 8b 80 80 00 00 00 	mov    rax,QWORD PTR [rax+0x80]
  214f5a:	48 85 c0             	test   rax,rax
  214f5d:	0f 85 9d fe ff ff    	jne    214e00 <dumpCurrentStackTrace+0x660>
  214f63:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  214f6a:	84 00 00 00 00 00 
    for (st.compile_unit_list.toSlice()) |*compile_unit| {
  214f70:	49 83 c4 01          	add    r12,0x1
  214f74:	4c 3b 64 24 78       	cmp    r12,QWORD PTR [rsp+0x78]
  214f79:	0f 82 b1 fd ff ff    	jb     214d30 <dumpCurrentStackTrace+0x590>
  214f7f:	90                   	nop
  214f80:	4c 8b 64 24 70       	mov    r12,QWORD PTR [rsp+0x70]
            return std.fmt.format(self, Error, self.writeFn, format, args);
  214f85:	4d 8b 34 24          	mov    r14,QWORD PTR [r12]
                if (tty_color) {
  214f89:	80 7c 24 07 00       	cmp    BYTE PTR [rsp+0x7],0x0
  214f8e:	74 70                	je     215000 <dumpCurrentStackTrace+0x860>
                        try output(context, fmt[start_index..i]);
  214f90:	4c 89 e7             	mov    rdi,r12
  214f93:	48 8d 35 0e 0d 03 00 	lea    rsi,[rip+0x30d0e]        # 245ca8 <__unnamed_29>
  214f9a:	c5 f8 77             	vzeroupper 
  214f9d:	41 ff d6             	call   r14
  214fa0:	41 89 c7             	mov    r15d,eax
  214fa3:	66 45 85 ff          	test   r15w,r15w
  214fa7:	0f 85 a3 01 00 00    	jne    215150 <dumpCurrentStackTrace+0x9b0>
    var buf: [max_int_digits - 1]u8 = undefined;
  214fad:	c5 fc 10 05 0a 45 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffff450a]        # 2094bf <__unnamed_5+0x1f>
  214fb4:	ff 
  214fb5:	c5 fc 11 44 24 3f    	vmovups YMMWORD PTR [rsp+0x3f],ymm0
  214fbb:	c5 fe 6f 05 dd 44 ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffff44dd]        # 2094a0 <__unnamed_5>
  214fc2:	ff 
  214fc3:	c5 fe 7f 44 24 20    	vmovdqu YMMWORD PTR [rsp+0x20],ymm0
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  214fc9:	44 89 e8             	mov    eax,r13d
  214fcc:	24 0f                	and    al,0xf
        0...9 => digit + '0',
  214fce:	b1 30                	mov    cl,0x30
  214fd0:	3c 0a                	cmp    al,0xa
  214fd2:	72 02                	jb     214fd6 <dumpCurrentStackTrace+0x836>
  214fd4:	b1 57                	mov    cl,0x57
  214fd6:	00 c1                	add    cl,al
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  214fd8:	88 4c 24 5f          	mov    BYTE PTR [rsp+0x5f],cl
  214fdc:	b8 40 00 00 00       	mov    eax,0x40
        if (a == 0) break;
  214fe1:	49 83 fd 10          	cmp    r13,0x10
  214fe5:	73 7e                	jae    215065 <dumpCurrentStackTrace+0x8c5>
  214fe7:	48 8d 4c 24 5f       	lea    rcx,[rsp+0x5f]
  214fec:	e9 af 00 00 00       	jmp    2150a0 <dumpCurrentStackTrace+0x900>
  214ff1:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  214ff8:	0f 1f 84 00 00 00 00 
  214fff:	00 
                        try output(context, fmt[start_index..i]);
  215000:	4c 89 e7             	mov    rdi,r12
  215003:	48 8d 35 be 0c 03 00 	lea    rsi,[rip+0x30cbe]        # 245cc8 <__unnamed_30>
  21500a:	c5 f8 77             	vzeroupper 
  21500d:	41 ff d6             	call   r14
  215010:	41 89 c7             	mov    r15d,eax
  215013:	66 45 85 ff          	test   r15w,r15w
  215017:	0f 85 33 01 00 00    	jne    215150 <dumpCurrentStackTrace+0x9b0>
    var buf: [max_int_digits - 1]u8 = undefined;
  21501d:	c5 fc 10 05 9a 44 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffff449a]        # 2094bf <__unnamed_5+0x1f>
  215024:	ff 
  215025:	c5 fc 11 44 24 3f    	vmovups YMMWORD PTR [rsp+0x3f],ymm0
  21502b:	c5 fe 6f 05 6d 44 ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffff446d]        # 2094a0 <__unnamed_5>
  215032:	ff 
  215033:	c5 fe 7f 44 24 20    	vmovdqu YMMWORD PTR [rsp+0x20],ymm0
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  215039:	44 89 e8             	mov    eax,r13d
  21503c:	24 0f                	and    al,0xf
        0...9 => digit + '0',
  21503e:	b1 30                	mov    cl,0x30
  215040:	3c 0a                	cmp    al,0xa
  215042:	72 02                	jb     215046 <dumpCurrentStackTrace+0x8a6>
  215044:	b1 57                	mov    cl,0x57
  215046:	00 c1                	add    cl,al
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  215048:	88 4c 24 5f          	mov    BYTE PTR [rsp+0x5f],cl
  21504c:	b8 40 00 00 00       	mov    eax,0x40
        if (a == 0) break;
  215051:	49 83 fd 10          	cmp    r13,0x10
  215055:	0f 83 7e 00 00 00    	jae    2150d9 <dumpCurrentStackTrace+0x939>
  21505b:	48 8d 4c 24 5f       	lea    rcx,[rsp+0x5f]
  215060:	e9 ab 00 00 00       	jmp    215110 <dumpCurrentStackTrace+0x970>
        a /= base;
  215065:	4c 89 e9             	mov    rcx,r13
  215068:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  21506f:	00 
  215070:	48 c1 e9 04          	shr    rcx,0x4
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  215074:	89 ca                	mov    edx,ecx
  215076:	80 e2 0f             	and    dl,0xf
        0...9 => digit + '0',
  215079:	b3 30                	mov    bl,0x30
  21507b:	80 fa 0a             	cmp    dl,0xa
  21507e:	72 02                	jb     215082 <dumpCurrentStackTrace+0x8e2>
  215080:	b3 57                	mov    bl,0x57
  215082:	00 d3                	add    bl,dl
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  215084:	88 5c 04 1e          	mov    BYTE PTR [rsp+rax*1+0x1e],bl
        if (a == 0) break;
  215088:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  21508c:	49 81 fd ff 00 00 00 	cmp    r13,0xff
  215093:	49 89 cd             	mov    r13,rcx
  215096:	77 d8                	ja     215070 <dumpCurrentStackTrace+0x8d0>
        const padded_buf = buf[index - padding ..];
  215098:	48 8d 0c 04          	lea    rcx,[rsp+rax*1]
  21509c:	48 83 c1 1f          	add    rcx,0x1f
  2150a0:	ba 41 00 00 00       	mov    edx,0x41
  2150a5:	48 29 c2             	sub    rdx,rax
  2150a8:	48 89 4c 24 08       	mov    QWORD PTR [rsp+0x8],rcx
  2150ad:	48 89 54 24 10       	mov    QWORD PTR [rsp+0x10],rdx
        return output(context, padded_buf);
  2150b2:	4c 89 e7             	mov    rdi,r12
  2150b5:	48 8d 74 24 08       	lea    rsi,[rsp+0x8]
  2150ba:	c5 f8 77             	vzeroupper 
  2150bd:	41 ff d6             	call   r14
  2150c0:	41 89 c7             	mov    r15d,eax
                    try formatType(args[next_arg], fmt[s..i], context, Errors, output);
  2150c3:	66 45 85 ff          	test   r15w,r15w
  2150c7:	0f 85 83 00 00 00    	jne    215150 <dumpCurrentStackTrace+0x9b0>
        try output(context, fmt[start_index..]);
  2150cd:	4c 89 e7             	mov    rdi,r12
  2150d0:	48 8d 35 e1 0b 03 00 	lea    rsi,[rip+0x30be1]        # 245cb8 <__unnamed_31>
  2150d7:	eb 6a                	jmp    215143 <dumpCurrentStackTrace+0x9a3>
        a /= base;
  2150d9:	4c 89 e9             	mov    rcx,r13
  2150dc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  2150e0:	48 c1 e9 04          	shr    rcx,0x4
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  2150e4:	89 ca                	mov    edx,ecx
  2150e6:	80 e2 0f             	and    dl,0xf
        0...9 => digit + '0',
  2150e9:	b3 30                	mov    bl,0x30
  2150eb:	80 fa 0a             	cmp    dl,0xa
  2150ee:	72 02                	jb     2150f2 <dumpCurrentStackTrace+0x952>
  2150f0:	b3 57                	mov    bl,0x57
  2150f2:	00 d3                	add    bl,dl
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  2150f4:	88 5c 04 1e          	mov    BYTE PTR [rsp+rax*1+0x1e],bl
        if (a == 0) break;
  2150f8:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  2150fc:	49 81 fd ff 00 00 00 	cmp    r13,0xff
  215103:	49 89 cd             	mov    r13,rcx
  215106:	77 d8                	ja     2150e0 <dumpCurrentStackTrace+0x940>
        const padded_buf = buf[index - padding ..];
  215108:	48 8d 0c 04          	lea    rcx,[rsp+rax*1]
  21510c:	48 83 c1 1f          	add    rcx,0x1f
  215110:	ba 41 00 00 00       	mov    edx,0x41
  215115:	48 29 c2             	sub    rdx,rax
  215118:	48 89 4c 24 08       	mov    QWORD PTR [rsp+0x8],rcx
  21511d:	48 89 54 24 10       	mov    QWORD PTR [rsp+0x10],rdx
        return output(context, padded_buf);
  215122:	4c 89 e7             	mov    rdi,r12
  215125:	48 8d 74 24 08       	lea    rsi,[rsp+0x8]
  21512a:	c5 f8 77             	vzeroupper 
  21512d:	41 ff d6             	call   r14
  215130:	41 89 c7             	mov    r15d,eax
                    try formatType(args[next_arg], fmt[s..i], context, Errors, output);
  215133:	66 45 85 ff          	test   r15w,r15w
  215137:	75 17                	jne    215150 <dumpCurrentStackTrace+0x9b0>
        try output(context, fmt[start_index..]);
  215139:	4c 89 e7             	mov    rdi,r12
  21513c:	48 8d 35 95 0b 03 00 	lea    rsi,[rip+0x30b95]        # 245cd8 <__unnamed_32>
  215143:	41 ff d6             	call   r14
  215146:	41 89 c7             	mov    r15d,eax
  215149:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  215150:	c5 7d 6f a4 24 00 01 	vmovdqa ymm12,YMMWORD PTR [rsp+0x100]
  215157:	00 00 
  215159:	c5 7d 6f ac 24 e0 00 	vmovdqa ymm13,YMMWORD PTR [rsp+0xe0]
  215160:	00 00 
        try printSourceAtAddress(debug_info, out_stream, return_address, tty_color);
  215162:	66 45 85 ff          	test   r15w,r15w
  215166:	0f 85 fc 0b 00 00    	jne    215d68 <dumpCurrentStackTrace+0x15c8>
  21516c:	31 c0                	xor    eax,eax
  21516e:	48 8b 8c 24 a8 00 00 	mov    rcx,QWORD PTR [rsp+0xa8]
  215175:	00 
  215176:	48 8b 94 24 b0 00 00 	mov    rdx,QWORD PTR [rsp+0xb0]
  21517d:	00 
  21517e:	48 8b 74 24 68       	mov    rsi,QWORD PTR [rsp+0x68]
    while (fp != 0) : (fp = @intToPtr(*const usize, fp).*) {
  215183:	48 8b 12             	mov    rdx,QWORD PTR [rdx]
  215186:	48 85 d2             	test   rdx,rdx
  215189:	0f 85 91 0b 00 00    	jne    215d20 <dumpCurrentStackTrace+0x1580>
  21518f:	e9 21 0c 00 00       	jmp    215db5 <dumpCurrentStackTrace+0x1615>
  215194:	48 8b 84 24 38 01 00 	mov    rax,QWORD PTR [rsp+0x138]
  21519b:	00 
  21519c:	eb 08                	jmp    2151a6 <dumpCurrentStackTrace+0xa06>
            const compile_unit_name = try compile_unit.die.getAttrString(debug_info, DW.AT_name);
  21519e:	4b 8d 04 31          	lea    rax,[r9+r14*1]
  2151a2:	48 83 c0 08          	add    rax,0x8
  2151a6:	48 8b 00             	mov    rax,QWORD PTR [rax]
        }

        pub fn toSliceConst(self: Self) []align(A) const T {
            return self.items[0..self.len];
  2151a9:	48 8b 48 20          	mov    rcx,QWORD PTR [rax+0x20]
        for (self.attrs.toSliceConst()) |*attr| {
  2151ad:	48 85 c9             	test   rcx,rcx
  2151b0:	4c 8b 64 24 70       	mov    r12,QWORD PTR [rsp+0x70]
  2151b5:	0f 84 88 0b 00 00    	je     215d43 <dumpCurrentStackTrace+0x15a3>
  2151bb:	4d 01 f1             	add    r9,r14
  2151be:	48 8b 40 10          	mov    rax,QWORD PTR [rax+0x10]
  2151c2:	31 d2                	xor    edx,edx
  2151c4:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  2151cb:	00 00 00 00 00 
            if (attr.id == id) return &attr.value;
  2151d0:	48 83 38 03          	cmp    QWORD PTR [rax],0x3
  2151d4:	74 12                	je     2151e8 <dumpCurrentStackTrace+0xa48>
        for (self.attrs.toSliceConst()) |*attr| {
  2151d6:	48 83 c2 01          	add    rdx,0x1
  2151da:	48 83 c0 28          	add    rax,0x28
  2151de:	48 39 ca             	cmp    rdx,rcx
  2151e1:	72 ed                	jb     2151d0 <dumpCurrentStackTrace+0xa30>
  2151e3:	e9 5b 0b 00 00       	jmp    215d43 <dumpCurrentStackTrace+0x15a3>
  2151e8:	8a 50 20             	mov    dl,BYTE PTR [rax+0x20]
  2151eb:	80 fa 0a             	cmp    dl,0xa
        return switch (form_value.*) {
  2151ee:	74 2f                	je     21521f <dumpCurrentStackTrace+0xa7f>
  2151f0:	48 8d 0d 39 30 ff ff 	lea    rcx,[rip+0xffffffffffff3039]        # 208230 <__unnamed_33>
  2151f7:	80 fa 09             	cmp    dl,0x9
  2151fa:	0f 85 a4 00 00 00    	jne    2152a4 <dumpCurrentStackTrace+0xb04>
            FormValue.String => |value| value,
  215200:	66 c7 44 24 08 00 00 	mov    WORD PTR [rsp+0x8],0x0
  215207:	c5 fa 6f 40 08       	vmovdqu xmm0,XMMWORD PTR [rax+0x8]
  21520c:	48 8d 44 24 10       	lea    rax,[rsp+0x10]
  215211:	c5 fa 7f 00          	vmovdqu XMMWORD PTR [rax],xmm0
        return switch (form_value.*) {
  215215:	48 8d 4c 24 08       	lea    rcx,[rsp+0x8]
  21521a:	e9 85 00 00 00       	jmp    2152a4 <dumpCurrentStackTrace+0xb04>
            FormValue.StrPtr => |offset| getString(st, offset),
  21521f:	48 8b 70 08          	mov    rsi,QWORD PTR [rax+0x8]
  215223:	48 8b 4c 24 68       	mov    rcx,QWORD PTR [rsp+0x68]
    const pos = st.debug_str.offset + offset;
  215228:	48 8b 41 70          	mov    rax,QWORD PTR [rcx+0x70]
  21522c:	48 03 70 18          	add    rsi,QWORD PTR [rax+0x18]
  215230:	78 45                	js     215277 <dumpCurrentStackTrace+0xad7>
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  215232:	48 63 39             	movsxd rdi,DWORD PTR [rcx]
  215235:	b8 08 00 00 00       	mov    eax,0x8
  21523a:	31 d2                	xor    edx,edx
  21523c:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  21523e:	48 89 c1             	mov    rcx,rax
  215241:	48 f7 d9             	neg    rcx
  215244:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  21524a:	b8 00 00 00 00       	mov    eax,0x0
  21524f:	48 0f 46 c8          	cmovbe rcx,rax
  215253:	66 b8 03 00          	mov    ax,0x3
  215257:	48 83 f9 1d          	cmp    rcx,0x1d
  21525b:	0f 87 96 09 00 00    	ja     215bf7 <dumpCurrentStackTrace+0x1457>
  215261:	48 8d 15 ec ba fe ff 	lea    rdx,[rip+0xfffffffffffebaec]        # 200d54 <app_mask+0x74>
  215268:	48 63 0c 8a          	movsxd rcx,DWORD PTR [rdx+rcx*4]
  21526c:	48 01 d1             	add    rcx,rdx
  21526f:	ff e1                	jmp    rcx
  215271:	66 b8 21 00          	mov    ax,0x21
  215275:	eb 04                	jmp    21527b <dumpCurrentStackTrace+0xadb>
  215277:	66 b8 04 00          	mov    ax,0x4
    try st.self_exe_file.seekTo(pos);
  21527b:	66 89 44 24 20       	mov    WORD PTR [rsp+0x20],ax
  215280:	48 8b 84 24 d6 00 00 	mov    rax,QWORD PTR [rsp+0xd6]
  215287:	00 
  215288:	48 8d 4c 24 5f       	lea    rcx,[rsp+0x5f]
  21528d:	48 89 41 d1          	mov    QWORD PTR [rcx-0x2f],rax
  215291:	c5 fa 6f 84 24 c8 00 	vmovdqu xmm0,XMMWORD PTR [rsp+0xc8]
  215298:	00 00 
  21529a:	c5 fa 7f 41 c3       	vmovdqu XMMWORD PTR [rcx-0x3d],xmm0
        return switch (form_value.*) {
  21529f:	48 8d 4c 24 20       	lea    rcx,[rsp+0x20]
  2152a4:	44 0f b7 39          	movzx  r15d,WORD PTR [rcx]
  2152a8:	48 8b 41 10          	mov    rax,QWORD PTR [rcx+0x10]
  2152ac:	48 89 84 24 4e 01 00 	mov    QWORD PTR [rsp+0x14e],rax
  2152b3:	00 
  2152b4:	c5 fa 6f 41 02       	vmovdqu xmm0,XMMWORD PTR [rcx+0x2]
  2152b9:	c5 f9 7f 84 24 40 01 	vmovdqa XMMWORD PTR [rsp+0x140],xmm0
  2152c0:	00 00 
            const compile_unit_name = try compile_unit.die.getAttrString(debug_info, DW.AT_name);
  2152c2:	66 45 85 ff          	test   r15w,r15w
  2152c6:	0f 85 9c 0a 00 00    	jne    215d68 <dumpCurrentStackTrace+0x15c8>
  2152cc:	48 8d 84 24 46 01 00 	lea    rax,[rsp+0x146]
  2152d3:	00 
  2152d4:	c5 fa 6f 00          	vmovdqu xmm0,XMMWORD PTR [rax]
  2152d8:	c5 f9 7f 84 24 20 01 	vmovdqa XMMWORD PTR [rsp+0x120],xmm0
  2152df:	00 00 
            if (getLineNumberInfo(debug_info, compile_unit, address - 1)) |line_info| {
  2152e1:	49 8d 4d ff          	lea    rcx,[r13-0x1]
  2152e5:	48 8d bc 24 58 01 00 	lea    rdi,[rsp+0x158]
  2152ec:	00 
  2152ed:	48 8b 74 24 68       	mov    rsi,QWORD PTR [rsp+0x68]
  2152f2:	4c 89 ca             	mov    rdx,r9
  2152f5:	c5 f8 77             	vzeroupper 
  2152f8:	e8 13 a4 00 00       	call   21f710 <getLineNumberInfo>
  2152fd:	44 0f b7 bc 24 58 01 	movzx  r15d,WORD PTR [rsp+0x158]
  215304:	00 00 
  215306:	66 45 85 ff          	test   r15w,r15w
  21530a:	74 77                	je     215383 <dumpCurrentStackTrace+0xbe3>
            } else |err| switch (err) {
  21530c:	44 89 f8             	mov    eax,r15d
  21530f:	25 fe ff 00 00       	and    eax,0xfffe
  215314:	83 f8 22             	cmp    eax,0x22
  215317:	0f 85 4b 0a 00 00    	jne    215d68 <dumpCurrentStackTrace+0x15c8>
  21531d:	4d 8b 34 24          	mov    r14,QWORD PTR [r12]
                        try output(context, fmt[start_index..i]);
  215321:	4c 89 e7             	mov    rdi,r12
  215324:	48 8d 35 6d 0a 03 00 	lea    rsi,[rip+0x30a6d]        # 245d98 <__unnamed_34>
  21532b:	41 ff d6             	call   r14
  21532e:	41 89 c7             	mov    r15d,eax
  215331:	66 45 85 ff          	test   r15w,r15w
  215335:	0f 85 15 fe ff ff    	jne    215150 <dumpCurrentStackTrace+0x9b0>
    var buf: [max_int_digits - 1]u8 = undefined;
  21533b:	c5 fc 10 05 7c 41 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffff417c]        # 2094bf <__unnamed_5+0x1f>
  215342:	ff 
  215343:	c5 fc 11 44 24 3f    	vmovups YMMWORD PTR [rsp+0x3f],ymm0
  215349:	c5 fe 6f 05 4f 41 ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffff414f]        # 2094a0 <__unnamed_5>
  215350:	ff 
  215351:	c5 fe 7f 44 24 20    	vmovdqu YMMWORD PTR [rsp+0x20],ymm0
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  215357:	44 89 e8             	mov    eax,r13d
  21535a:	24 0f                	and    al,0xf
        0...9 => digit + '0',
  21535c:	b1 30                	mov    cl,0x30
  21535e:	3c 0a                	cmp    al,0xa
  215360:	72 02                	jb     215364 <dumpCurrentStackTrace+0xbc4>
  215362:	b1 57                	mov    cl,0x57
  215364:	00 c1                	add    cl,al
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  215366:	88 4c 24 5f          	mov    BYTE PTR [rsp+0x5f],cl
  21536a:	b8 40 00 00 00       	mov    eax,0x40
        if (a == 0) break;
  21536f:	49 83 fd 10          	cmp    r13,0x10
  215373:	0f 83 b8 04 00 00    	jae    215831 <dumpCurrentStackTrace+0x1091>
  215379:	48 8d 4c 24 5f       	lea    rcx,[rsp+0x5f]
  21537e:	e9 ed 04 00 00       	jmp    215870 <dumpCurrentStackTrace+0x10d0>
  215383:	48 8d 84 24 60 01 00 	lea    rax,[rsp+0x160]
  21538a:	00 
            if (getLineNumberInfo(debug_info, compile_unit, address - 1)) |line_info| {
  21538b:	c5 fe 6f 00          	vmovdqu ymm0,YMMWORD PTR [rax]
  21538f:	c5 fe 7f 84 24 80 00 	vmovdqu YMMWORD PTR [rsp+0x80],ymm0
  215396:	00 00 
  215398:	48 8b 40 20          	mov    rax,QWORD PTR [rax+0x20]
  21539c:	48 89 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rax
  2153a3:	00 
  2153a4:	4c 89 e3             	mov    rbx,r12
  2153a7:	4c 8b a4 24 80 00 00 	mov    r12,QWORD PTR [rsp+0x80]
  2153ae:	00 
  2153af:	48 8b 84 24 88 00 00 	mov    rax,QWORD PTR [rsp+0x88]
  2153b6:	00 
  2153b7:	48 89 44 24 78       	mov    QWORD PTR [rsp+0x78],rax
  2153bc:	4c 8b 33             	mov    r14,QWORD PTR [rbx]
                if (tty_color) {
  2153bf:	80 7c 24 07 00       	cmp    BYTE PTR [rsp+0x7],0x0
  2153c4:	0f 84 cb 01 00 00    	je     215595 <dumpCurrentStackTrace+0xdf5>
                        try output(context, fmt[start_index..i]);
  2153ca:	48 89 df             	mov    rdi,rbx
  2153cd:	48 8d 35 14 09 03 00 	lea    rsi,[rip+0x30914]        # 245ce8 <__unnamed_35>
  2153d4:	c5 f8 77             	vzeroupper 
  2153d7:	41 ff d6             	call   r14
  2153da:	41 89 c7             	mov    r15d,eax
  2153dd:	66 45 85 ff          	test   r15w,r15w
  2153e1:	0f 85 e0 09 00 00    	jne    215dc7 <dumpCurrentStackTrace+0x1627>
                const casted_value = ([]const u8)(value);
  2153e7:	48 8d 84 24 90 00 00 	lea    rax,[rsp+0x90]
  2153ee:	00 
  2153ef:	c5 fa 6f 00          	vmovdqu xmm0,XMMWORD PTR [rax]
  2153f3:	c5 f9 7f 44 24 20    	vmovdqa XMMWORD PTR [rsp+0x20],xmm0
                return output(context, casted_value);
  2153f9:	48 89 df             	mov    rdi,rbx
  2153fc:	48 8d 74 24 20       	lea    rsi,[rsp+0x20]
  215401:	41 ff d6             	call   r14
  215404:	41 89 c7             	mov    r15d,eax
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  215407:	66 45 85 ff          	test   r15w,r15w
  21540b:	0f 85 b6 09 00 00    	jne    215dc7 <dumpCurrentStackTrace+0x1627>
                        try output(context, fmt[start_index..i]);
  215411:	48 89 df             	mov    rdi,rbx
  215414:	48 8d 35 dd 08 03 00 	lea    rsi,[rip+0x308dd]        # 245cf8 <__unnamed_36>
  21541b:	41 ff d6             	call   r14
  21541e:	41 89 c7             	mov    r15d,eax
  215421:	66 45 85 ff          	test   r15w,r15w
  215425:	0f 85 c5 09 00 00    	jne    215df0 <dumpCurrentStackTrace+0x1650>
    var buf: [max_int_digits - 1]u8 = undefined;
  21542b:	c5 fc 10 05 8c 40 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffff408c]        # 2094bf <__unnamed_5+0x1f>
  215432:	ff 
  215433:	c5 fc 11 44 24 3f    	vmovups YMMWORD PTR [rsp+0x3f],ymm0
  215439:	c5 fe 6f 05 5f 40 ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffff405f]        # 2094a0 <__unnamed_5>
  215440:	ff 
  215441:	c5 fe 7f 44 24 20    	vmovdqu YMMWORD PTR [rsp+0x20],ymm0
        const digit = a % base;
  215447:	4c 89 e2             	mov    rdx,r12
  21544a:	48 b8 cd cc cc cc cc 	movabs rax,0xcccccccccccccccd
  215451:	cc cc cc 
  215454:	c4 e2 fb f6 c8       	mulx   rcx,rax,rax
  215459:	c1 e9 02             	shr    ecx,0x2
  21545c:	81 e1 fe ff ff 3f    	and    ecx,0x3ffffffe
  215462:	8d 0c 89             	lea    ecx,[rcx+rcx*4]
  215465:	44 89 e0             	mov    eax,r12d
  215468:	29 c8                	sub    eax,ecx
        0...9 => digit + '0',
  21546a:	b1 30                	mov    cl,0x30
  21546c:	3c 0a                	cmp    al,0xa
  21546e:	72 02                	jb     215472 <dumpCurrentStackTrace+0xcd2>
  215470:	b1 57                	mov    cl,0x57
  215472:	00 c1                	add    cl,al
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  215474:	88 4c 24 5f          	mov    BYTE PTR [rsp+0x5f],cl
  215478:	b8 40 00 00 00       	mov    eax,0x40
        if (a == 0) break;
  21547d:	49 83 fc 0a          	cmp    r12,0xa
  215481:	73 0d                	jae    215490 <dumpCurrentStackTrace+0xcf0>
  215483:	48 8d 4c 24 5f       	lea    rcx,[rsp+0x5f]
  215488:	eb 58                	jmp    2154e2 <dumpCurrentStackTrace+0xd42>
  21548a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
        a /= base;
  215490:	4c 89 e2             	mov    rdx,r12
  215493:	48 b9 cd cc cc cc cc 	movabs rcx,0xcccccccccccccccd
  21549a:	cc cc cc 
  21549d:	48 89 ce             	mov    rsi,rcx
  2154a0:	c4 e2 f3 f6 d6       	mulx   rdx,rcx,rsi
  2154a5:	48 c1 ea 03          	shr    rdx,0x3
        const digit = a % base;
  2154a9:	c4 e2 f3 f6 f6       	mulx   rsi,rcx,rsi
  2154ae:	c1 ee 02             	shr    esi,0x2
  2154b1:	81 e6 fe ff ff 3f    	and    esi,0x3ffffffe
  2154b7:	8d 34 b6             	lea    esi,[rsi+rsi*4]
  2154ba:	89 d1                	mov    ecx,edx
  2154bc:	29 f1                	sub    ecx,esi
        0...9 => digit + '0',
  2154be:	b3 30                	mov    bl,0x30
  2154c0:	80 f9 0a             	cmp    cl,0xa
  2154c3:	72 02                	jb     2154c7 <dumpCurrentStackTrace+0xd27>
  2154c5:	b3 57                	mov    bl,0x57
  2154c7:	00 cb                	add    bl,cl
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  2154c9:	88 5c 04 1e          	mov    BYTE PTR [rsp+rax*1+0x1e],bl
        if (a == 0) break;
  2154cd:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  2154d1:	49 83 fc 63          	cmp    r12,0x63
  2154d5:	49 89 d4             	mov    r12,rdx
  2154d8:	77 b6                	ja     215490 <dumpCurrentStackTrace+0xcf0>
        const padded_buf = buf[index - padding ..];
  2154da:	48 8d 0c 04          	lea    rcx,[rsp+rax*1]
  2154de:	48 83 c1 1f          	add    rcx,0x1f
  2154e2:	ba 41 00 00 00       	mov    edx,0x41
  2154e7:	48 29 c2             	sub    rdx,rax
  2154ea:	48 89 4c 24 08       	mov    QWORD PTR [rsp+0x8],rcx
  2154ef:	48 89 54 24 10       	mov    QWORD PTR [rsp+0x10],rdx
  2154f4:	4c 8b 64 24 70       	mov    r12,QWORD PTR [rsp+0x70]
        return output(context, padded_buf);
  2154f9:	4c 89 e7             	mov    rdi,r12
  2154fc:	48 8d 74 24 08       	lea    rsi,[rsp+0x8]
  215501:	c5 f8 77             	vzeroupper 
  215504:	41 ff d6             	call   r14
  215507:	41 89 c7             	mov    r15d,eax
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  21550a:	66 45 85 ff          	test   r15w,r15w
  21550e:	0f 85 e1 08 00 00    	jne    215df5 <dumpCurrentStackTrace+0x1655>
                        try output(context, fmt[start_index..i]);
  215514:	4c 89 e7             	mov    rdi,r12
  215517:	48 8d 35 ea 07 03 00 	lea    rsi,[rip+0x307ea]        # 245d08 <__unnamed_37>
  21551e:	41 ff d6             	call   r14
  215521:	41 89 c7             	mov    r15d,eax
  215524:	66 45 85 ff          	test   r15w,r15w
  215528:	0f 85 c7 08 00 00    	jne    215df5 <dumpCurrentStackTrace+0x1655>
    var buf: [max_int_digits - 1]u8 = undefined;
  21552e:	c5 fc 10 05 89 3f ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffff3f89]        # 2094bf <__unnamed_5+0x1f>
  215535:	ff 
  215536:	c5 fc 11 44 24 3f    	vmovups YMMWORD PTR [rsp+0x3f],ymm0
  21553c:	c5 fe 6f 05 5c 3f ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffff3f5c]        # 2094a0 <__unnamed_5>
  215543:	ff 
  215544:	c5 fe 7f 44 24 20    	vmovdqu YMMWORD PTR [rsp+0x20],ymm0
  21554a:	48 8b 54 24 78       	mov    rdx,QWORD PTR [rsp+0x78]
        const digit = a % base;
  21554f:	48 b8 cd cc cc cc cc 	movabs rax,0xcccccccccccccccd
  215556:	cc cc cc 
  215559:	c4 e2 fb f6 c8       	mulx   rcx,rax,rax
  21555e:	c1 e9 02             	shr    ecx,0x2
  215561:	81 e1 fe ff ff 3f    	and    ecx,0x3ffffffe
  215567:	8d 0c 89             	lea    ecx,[rcx+rcx*4]
  21556a:	89 d0                	mov    eax,edx
  21556c:	29 c8                	sub    eax,ecx
        0...9 => digit + '0',
  21556e:	b1 30                	mov    cl,0x30
  215570:	3c 0a                	cmp    al,0xa
  215572:	72 02                	jb     215576 <dumpCurrentStackTrace+0xdd6>
  215574:	b1 57                	mov    cl,0x57
  215576:	00 c1                	add    cl,al
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  215578:	88 4c 24 5f          	mov    BYTE PTR [rsp+0x5f],cl
  21557c:	b9 40 00 00 00       	mov    ecx,0x40
        if (a == 0) break;
  215581:	48 83 fa 0a          	cmp    rdx,0xa
  215585:	0f 83 62 03 00 00    	jae    2158ed <dumpCurrentStackTrace+0x114d>
  21558b:	48 8d 44 24 5f       	lea    rax,[rsp+0x5f]
  215590:	e9 af 03 00 00       	jmp    215944 <dumpCurrentStackTrace+0x11a4>
                const casted_value = ([]const u8)(value);
  215595:	48 8d 84 24 90 00 00 	lea    rax,[rsp+0x90]
  21559c:	00 
  21559d:	c5 fa 6f 00          	vmovdqu xmm0,XMMWORD PTR [rax]
  2155a1:	c5 f9 7f 44 24 20    	vmovdqa XMMWORD PTR [rsp+0x20],xmm0
                return output(context, casted_value);
  2155a7:	48 89 df             	mov    rdi,rbx
  2155aa:	48 8d 74 24 20       	lea    rsi,[rsp+0x20]
  2155af:	c5 f8 77             	vzeroupper 
  2155b2:	41 ff d6             	call   r14
  2155b5:	41 89 c7             	mov    r15d,eax
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  2155b8:	66 45 85 ff          	test   r15w,r15w
  2155bc:	0f 85 05 08 00 00    	jne    215dc7 <dumpCurrentStackTrace+0x1627>
                        try output(context, fmt[start_index..i]);
  2155c2:	48 89 df             	mov    rdi,rbx
  2155c5:	48 8d 35 7c 07 03 00 	lea    rsi,[rip+0x3077c]        # 245d48 <__unnamed_38>
  2155cc:	41 ff d6             	call   r14
  2155cf:	41 89 c7             	mov    r15d,eax
  2155d2:	66 45 85 ff          	test   r15w,r15w
  2155d6:	0f 85 fd 07 00 00    	jne    215dd9 <dumpCurrentStackTrace+0x1639>
    var buf: [max_int_digits - 1]u8 = undefined;
  2155dc:	c5 fc 10 05 db 3e ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffff3edb]        # 2094bf <__unnamed_5+0x1f>
  2155e3:	ff 
  2155e4:	c5 fc 11 44 24 3f    	vmovups YMMWORD PTR [rsp+0x3f],ymm0
  2155ea:	c5 fe 6f 05 ae 3e ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffff3eae]        # 2094a0 <__unnamed_5>
  2155f1:	ff 
  2155f2:	c5 fe 7f 44 24 20    	vmovdqu YMMWORD PTR [rsp+0x20],ymm0
        const digit = a % base;
  2155f8:	4c 89 e2             	mov    rdx,r12
  2155fb:	48 b8 cd cc cc cc cc 	movabs rax,0xcccccccccccccccd
  215602:	cc cc cc 
  215605:	c4 e2 fb f6 c8       	mulx   rcx,rax,rax
  21560a:	c1 e9 02             	shr    ecx,0x2
  21560d:	81 e1 fe ff ff 3f    	and    ecx,0x3ffffffe
  215613:	8d 0c 89             	lea    ecx,[rcx+rcx*4]
  215616:	44 89 e0             	mov    eax,r12d
  215619:	29 c8                	sub    eax,ecx
        0...9 => digit + '0',
  21561b:	b1 30                	mov    cl,0x30
  21561d:	3c 0a                	cmp    al,0xa
  21561f:	72 02                	jb     215623 <dumpCurrentStackTrace+0xe83>
  215621:	b1 57                	mov    cl,0x57
  215623:	00 c1                	add    cl,al
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  215625:	88 4c 24 5f          	mov    BYTE PTR [rsp+0x5f],cl
  215629:	b8 40 00 00 00       	mov    eax,0x40
        if (a == 0) break;
  21562e:	49 83 fc 0a          	cmp    r12,0xa
  215632:	73 0c                	jae    215640 <dumpCurrentStackTrace+0xea0>
  215634:	48 8d 4c 24 5f       	lea    rcx,[rsp+0x5f]
  215639:	eb 57                	jmp    215692 <dumpCurrentStackTrace+0xef2>
  21563b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
        a /= base;
  215640:	4c 89 e2             	mov    rdx,r12
  215643:	48 b9 cd cc cc cc cc 	movabs rcx,0xcccccccccccccccd
  21564a:	cc cc cc 
  21564d:	48 89 ce             	mov    rsi,rcx
  215650:	c4 e2 f3 f6 d6       	mulx   rdx,rcx,rsi
  215655:	48 c1 ea 03          	shr    rdx,0x3
        const digit = a % base;
  215659:	c4 e2 f3 f6 f6       	mulx   rsi,rcx,rsi
  21565e:	c1 ee 02             	shr    esi,0x2
  215661:	81 e6 fe ff ff 3f    	and    esi,0x3ffffffe
  215667:	8d 34 b6             	lea    esi,[rsi+rsi*4]
  21566a:	89 d1                	mov    ecx,edx
  21566c:	29 f1                	sub    ecx,esi
        0...9 => digit + '0',
  21566e:	b3 30                	mov    bl,0x30
  215670:	80 f9 0a             	cmp    cl,0xa
  215673:	72 02                	jb     215677 <dumpCurrentStackTrace+0xed7>
  215675:	b3 57                	mov    bl,0x57
  215677:	00 cb                	add    bl,cl
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  215679:	88 5c 04 1e          	mov    BYTE PTR [rsp+rax*1+0x1e],bl
        if (a == 0) break;
  21567d:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  215681:	49 83 fc 63          	cmp    r12,0x63
  215685:	49 89 d4             	mov    r12,rdx
  215688:	77 b6                	ja     215640 <dumpCurrentStackTrace+0xea0>
        const padded_buf = buf[index - padding ..];
  21568a:	48 8d 0c 04          	lea    rcx,[rsp+rax*1]
  21568e:	48 83 c1 1f          	add    rcx,0x1f
  215692:	ba 41 00 00 00       	mov    edx,0x41
  215697:	48 29 c2             	sub    rdx,rax
  21569a:	48 89 4c 24 08       	mov    QWORD PTR [rsp+0x8],rcx
  21569f:	48 89 54 24 10       	mov    QWORD PTR [rsp+0x10],rdx
  2156a4:	4c 8b 64 24 70       	mov    r12,QWORD PTR [rsp+0x70]
        return output(context, padded_buf);
  2156a9:	4c 89 e7             	mov    rdi,r12
  2156ac:	48 8d 74 24 08       	lea    rsi,[rsp+0x8]
  2156b1:	c5 f8 77             	vzeroupper 
  2156b4:	41 ff d6             	call   r14
  2156b7:	41 89 c7             	mov    r15d,eax
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  2156ba:	66 45 85 ff          	test   r15w,r15w
  2156be:	0f 85 31 07 00 00    	jne    215df5 <dumpCurrentStackTrace+0x1655>
                        try output(context, fmt[start_index..i]);
  2156c4:	4c 89 e7             	mov    rdi,r12
  2156c7:	48 8d 35 8a 06 03 00 	lea    rsi,[rip+0x3068a]        # 245d58 <__unnamed_39>
  2156ce:	41 ff d6             	call   r14
  2156d1:	41 89 c7             	mov    r15d,eax
  2156d4:	66 45 85 ff          	test   r15w,r15w
  2156d8:	0f 85 17 07 00 00    	jne    215df5 <dumpCurrentStackTrace+0x1655>
    var buf: [max_int_digits - 1]u8 = undefined;
  2156de:	c5 fc 10 05 d9 3d ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffff3dd9]        # 2094bf <__unnamed_5+0x1f>
  2156e5:	ff 
  2156e6:	c5 fc 11 44 24 3f    	vmovups YMMWORD PTR [rsp+0x3f],ymm0
  2156ec:	c5 fe 6f 05 ac 3d ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffff3dac]        # 2094a0 <__unnamed_5>
  2156f3:	ff 
  2156f4:	c5 fe 7f 44 24 20    	vmovdqu YMMWORD PTR [rsp+0x20],ymm0
  2156fa:	48 8b 7c 24 78       	mov    rdi,QWORD PTR [rsp+0x78]
        const digit = a % base;
  2156ff:	48 89 fa             	mov    rdx,rdi
  215702:	48 b8 cd cc cc cc cc 	movabs rax,0xcccccccccccccccd
  215709:	cc cc cc 
  21570c:	c4 e2 fb f6 c8       	mulx   rcx,rax,rax
  215711:	c1 e9 02             	shr    ecx,0x2
  215714:	81 e1 fe ff ff 3f    	and    ecx,0x3ffffffe
  21571a:	8d 0c 89             	lea    ecx,[rcx+rcx*4]
  21571d:	89 f8                	mov    eax,edi
  21571f:	29 c8                	sub    eax,ecx
        0...9 => digit + '0',
  215721:	b1 30                	mov    cl,0x30
  215723:	3c 0a                	cmp    al,0xa
  215725:	72 02                	jb     215729 <dumpCurrentStackTrace+0xf89>
  215727:	b1 57                	mov    cl,0x57
  215729:	00 c1                	add    cl,al
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  21572b:	88 4c 24 5f          	mov    BYTE PTR [rsp+0x5f],cl
  21572f:	b8 40 00 00 00       	mov    eax,0x40
        if (a == 0) break;
  215734:	48 83 ff 0a          	cmp    rdi,0xa
  215738:	73 16                	jae    215750 <dumpCurrentStackTrace+0xfb0>
  21573a:	48 8d 4c 24 5f       	lea    rcx,[rsp+0x5f]
  21573f:	eb 61                	jmp    2157a2 <dumpCurrentStackTrace+0x1002>
  215741:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  215748:	0f 1f 84 00 00 00 00 
  21574f:	00 
        a /= base;
  215750:	48 89 fa             	mov    rdx,rdi
  215753:	48 b9 cd cc cc cc cc 	movabs rcx,0xcccccccccccccccd
  21575a:	cc cc cc 
  21575d:	48 89 ce             	mov    rsi,rcx
  215760:	c4 e2 f3 f6 d6       	mulx   rdx,rcx,rsi
  215765:	48 c1 ea 03          	shr    rdx,0x3
        const digit = a % base;
  215769:	c4 e2 f3 f6 f6       	mulx   rsi,rcx,rsi
  21576e:	c1 ee 02             	shr    esi,0x2
  215771:	81 e6 fe ff ff 3f    	and    esi,0x3ffffffe
  215777:	8d 34 b6             	lea    esi,[rsi+rsi*4]
  21577a:	89 d1                	mov    ecx,edx
  21577c:	29 f1                	sub    ecx,esi
        0...9 => digit + '0',
  21577e:	b3 30                	mov    bl,0x30
  215780:	80 f9 0a             	cmp    cl,0xa
  215783:	72 02                	jb     215787 <dumpCurrentStackTrace+0xfe7>
  215785:	b3 57                	mov    bl,0x57
  215787:	00 cb                	add    bl,cl
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  215789:	88 5c 04 1e          	mov    BYTE PTR [rsp+rax*1+0x1e],bl
        if (a == 0) break;
  21578d:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  215791:	48 83 ff 63          	cmp    rdi,0x63
  215795:	48 89 d7             	mov    rdi,rdx
  215798:	77 b6                	ja     215750 <dumpCurrentStackTrace+0xfb0>
        const padded_buf = buf[index - padding ..];
  21579a:	48 8d 0c 04          	lea    rcx,[rsp+rax*1]
  21579e:	48 83 c1 1f          	add    rcx,0x1f
  2157a2:	ba 41 00 00 00       	mov    edx,0x41
  2157a7:	48 29 c2             	sub    rdx,rax
  2157aa:	48 89 4c 24 08       	mov    QWORD PTR [rsp+0x8],rcx
  2157af:	48 89 54 24 10       	mov    QWORD PTR [rsp+0x10],rdx
        return output(context, padded_buf);
  2157b4:	4c 89 e7             	mov    rdi,r12
  2157b7:	48 8d 74 24 08       	lea    rsi,[rsp+0x8]
  2157bc:	c5 f8 77             	vzeroupper 
  2157bf:	41 ff d6             	call   r14
  2157c2:	41 89 c7             	mov    r15d,eax
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  2157c5:	66 45 85 ff          	test   r15w,r15w
  2157c9:	0f 85 26 06 00 00    	jne    215df5 <dumpCurrentStackTrace+0x1655>
                        try output(context, fmt[start_index..i]);
  2157cf:	4c 89 e7             	mov    rdi,r12
  2157d2:	48 8d 35 8f 05 03 00 	lea    rsi,[rip+0x3058f]        # 245d68 <__unnamed_40>
  2157d9:	41 ff d6             	call   r14
  2157dc:	41 89 c7             	mov    r15d,eax
  2157df:	66 45 85 ff          	test   r15w,r15w
  2157e3:	0f 85 0c 06 00 00    	jne    215df5 <dumpCurrentStackTrace+0x1655>
    var buf: [max_int_digits - 1]u8 = undefined;
  2157e9:	c5 fc 10 05 ce 3c ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffff3cce]        # 2094bf <__unnamed_5+0x1f>
  2157f0:	ff 
  2157f1:	c5 fc 11 44 24 3f    	vmovups YMMWORD PTR [rsp+0x3f],ymm0
  2157f7:	c5 fe 6f 05 a1 3c ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffff3ca1]        # 2094a0 <__unnamed_5>
  2157fe:	ff 
  2157ff:	c5 fe 7f 44 24 20    	vmovdqu YMMWORD PTR [rsp+0x20],ymm0
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  215805:	44 89 e8             	mov    eax,r13d
  215808:	24 0f                	and    al,0xf
        0...9 => digit + '0',
  21580a:	b1 30                	mov    cl,0x30
  21580c:	3c 0a                	cmp    al,0xa
  21580e:	72 02                	jb     215812 <dumpCurrentStackTrace+0x1072>
  215810:	b1 57                	mov    cl,0x57
  215812:	00 c1                	add    cl,al
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  215814:	88 4c 24 5f          	mov    BYTE PTR [rsp+0x5f],cl
  215818:	b8 40 00 00 00       	mov    eax,0x40
        if (a == 0) break;
  21581d:	49 83 fd 10          	cmp    r13,0x10
  215821:	0f 83 ac 01 00 00    	jae    2159d3 <dumpCurrentStackTrace+0x1233>
  215827:	48 8d 4c 24 5f       	lea    rcx,[rsp+0x5f]
  21582c:	e9 df 01 00 00       	jmp    215a10 <dumpCurrentStackTrace+0x1270>
        a /= base;
  215831:	4c 89 e9             	mov    rcx,r13
  215834:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21583b:	00 00 00 00 00 
  215840:	48 c1 e9 04          	shr    rcx,0x4
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  215844:	89 ca                	mov    edx,ecx
  215846:	80 e2 0f             	and    dl,0xf
        0...9 => digit + '0',
  215849:	b3 30                	mov    bl,0x30
  21584b:	80 fa 0a             	cmp    dl,0xa
  21584e:	72 02                	jb     215852 <dumpCurrentStackTrace+0x10b2>
  215850:	b3 57                	mov    bl,0x57
  215852:	00 d3                	add    bl,dl
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  215854:	88 5c 04 1e          	mov    BYTE PTR [rsp+rax*1+0x1e],bl
        if (a == 0) break;
  215858:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  21585c:	49 81 fd ff 00 00 00 	cmp    r13,0xff
  215863:	49 89 cd             	mov    r13,rcx
  215866:	77 d8                	ja     215840 <dumpCurrentStackTrace+0x10a0>
        const padded_buf = buf[index - padding ..];
  215868:	48 8d 0c 04          	lea    rcx,[rsp+rax*1]
  21586c:	48 83 c1 1f          	add    rcx,0x1f
  215870:	ba 41 00 00 00       	mov    edx,0x41
  215875:	48 29 c2             	sub    rdx,rax
  215878:	48 89 4c 24 08       	mov    QWORD PTR [rsp+0x8],rcx
  21587d:	48 89 54 24 10       	mov    QWORD PTR [rsp+0x10],rdx
        return output(context, padded_buf);
  215882:	4c 89 e7             	mov    rdi,r12
  215885:	48 8d 74 24 08       	lea    rsi,[rsp+0x8]
  21588a:	c5 f8 77             	vzeroupper 
  21588d:	41 ff d6             	call   r14
  215890:	41 89 c7             	mov    r15d,eax
                    try formatType(args[next_arg], fmt[s..i], context, Errors, output);
  215893:	66 45 85 ff          	test   r15w,r15w
  215897:	0f 85 b3 f8 ff ff    	jne    215150 <dumpCurrentStackTrace+0x9b0>
                        try output(context, fmt[start_index..i]);
  21589d:	4c 89 e7             	mov    rdi,r12
  2158a0:	48 8d 35 01 05 03 00 	lea    rsi,[rip+0x30501]        # 245da8 <__unnamed_41>
  2158a7:	41 ff d6             	call   r14
  2158aa:	41 89 c7             	mov    r15d,eax
  2158ad:	66 45 85 ff          	test   r15w,r15w
  2158b1:	0f 85 99 f8 ff ff    	jne    215150 <dumpCurrentStackTrace+0x9b0>
                const casted_value = ([]const u8)(value);
  2158b7:	c5 f9 6f 84 24 20 01 	vmovdqa xmm0,XMMWORD PTR [rsp+0x120]
  2158be:	00 00 
  2158c0:	c5 f9 7f 44 24 20    	vmovdqa XMMWORD PTR [rsp+0x20],xmm0
                return output(context, casted_value);
  2158c6:	4c 89 e7             	mov    rdi,r12
  2158c9:	48 8d 74 24 20       	lea    rsi,[rsp+0x20]
  2158ce:	41 ff d6             	call   r14
  2158d1:	41 89 c7             	mov    r15d,eax
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  2158d4:	66 45 85 ff          	test   r15w,r15w
  2158d8:	0f 85 72 f8 ff ff    	jne    215150 <dumpCurrentStackTrace+0x9b0>
        try output(context, fmt[start_index..]);
  2158de:	4c 89 e7             	mov    rdi,r12
  2158e1:	48 8d 35 d0 04 03 00 	lea    rsi,[rip+0x304d0]        # 245db8 <__unnamed_42>
  2158e8:	e9 56 f8 ff ff       	jmp    215143 <dumpCurrentStackTrace+0x9a3>
  2158ed:	48 89 d0             	mov    rax,rdx
        a /= base;
  2158f0:	48 89 c2             	mov    rdx,rax
  2158f3:	48 be cd cc cc cc cc 	movabs rsi,0xcccccccccccccccd
  2158fa:	cc cc cc 
  2158fd:	48 89 f7             	mov    rdi,rsi
  215900:	c4 e2 cb f6 d7       	mulx   rdx,rsi,rdi
  215905:	48 c1 ea 03          	shr    rdx,0x3
        const digit = a % base;
  215909:	c4 e2 cb f6 ff       	mulx   rdi,rsi,rdi
  21590e:	c1 ef 02             	shr    edi,0x2
  215911:	81 e7 fe ff ff 3f    	and    edi,0x3ffffffe
  215917:	8d 3c bf             	lea    edi,[rdi+rdi*4]
  21591a:	89 d6                	mov    esi,edx
  21591c:	29 fe                	sub    esi,edi
        0...9 => digit + '0',
  21591e:	b3 30                	mov    bl,0x30
  215920:	40 80 fe 0a          	cmp    sil,0xa
  215924:	72 02                	jb     215928 <dumpCurrentStackTrace+0x1188>
  215926:	b3 57                	mov    bl,0x57
  215928:	40 00 f3             	add    bl,sil
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  21592b:	88 5c 0c 1e          	mov    BYTE PTR [rsp+rcx*1+0x1e],bl
        if (a == 0) break;
  21592f:	48 83 c1 ff          	add    rcx,0xffffffffffffffff
  215933:	48 83 f8 63          	cmp    rax,0x63
  215937:	48 89 d0             	mov    rax,rdx
  21593a:	77 b4                	ja     2158f0 <dumpCurrentStackTrace+0x1150>
        const padded_buf = buf[index - padding ..];
  21593c:	48 8d 04 0c          	lea    rax,[rsp+rcx*1]
  215940:	48 83 c0 1f          	add    rax,0x1f
  215944:	ba 41 00 00 00       	mov    edx,0x41
  215949:	48 29 ca             	sub    rdx,rcx
  21594c:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  215951:	48 89 54 24 10       	mov    QWORD PTR [rsp+0x10],rdx
        return output(context, padded_buf);
  215956:	4c 89 e7             	mov    rdi,r12
  215959:	48 8d 74 24 08       	lea    rsi,[rsp+0x8]
  21595e:	c5 f8 77             	vzeroupper 
  215961:	41 ff d6             	call   r14
  215964:	41 89 c7             	mov    r15d,eax
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  215967:	66 45 85 ff          	test   r15w,r15w
  21596b:	0f 85 84 04 00 00    	jne    215df5 <dumpCurrentStackTrace+0x1655>
                        try output(context, fmt[start_index..i]);
  215971:	4c 89 e7             	mov    rdi,r12
  215974:	48 8d 35 9d 03 03 00 	lea    rsi,[rip+0x3039d]        # 245d18 <__unnamed_43>
  21597b:	41 ff d6             	call   r14
  21597e:	41 89 c7             	mov    r15d,eax
  215981:	66 45 85 ff          	test   r15w,r15w
  215985:	0f 85 6a 04 00 00    	jne    215df5 <dumpCurrentStackTrace+0x1655>
    var buf: [max_int_digits - 1]u8 = undefined;
  21598b:	c5 fc 10 05 2c 3b ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffff3b2c]        # 2094bf <__unnamed_5+0x1f>
  215992:	ff 
  215993:	c5 fc 11 44 24 3f    	vmovups YMMWORD PTR [rsp+0x3f],ymm0
  215999:	c5 fe 6f 05 ff 3a ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffff3aff]        # 2094a0 <__unnamed_5>
  2159a0:	ff 
  2159a1:	c5 fe 7f 44 24 20    	vmovdqu YMMWORD PTR [rsp+0x20],ymm0
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  2159a7:	44 89 e8             	mov    eax,r13d
  2159aa:	24 0f                	and    al,0xf
        0...9 => digit + '0',
  2159ac:	b1 30                	mov    cl,0x30
  2159ae:	3c 0a                	cmp    al,0xa
  2159b0:	72 02                	jb     2159b4 <dumpCurrentStackTrace+0x1214>
  2159b2:	b1 57                	mov    cl,0x57
  2159b4:	00 c1                	add    cl,al
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  2159b6:	88 4c 24 5f          	mov    BYTE PTR [rsp+0x5f],cl
  2159ba:	b8 40 00 00 00       	mov    eax,0x40
        if (a == 0) break;
  2159bf:	49 83 fd 10          	cmp    r13,0x10
  2159c3:	0f 83 d4 00 00 00    	jae    215a9d <dumpCurrentStackTrace+0x12fd>
  2159c9:	48 8d 4c 24 5f       	lea    rcx,[rsp+0x5f]
  2159ce:	e9 fd 00 00 00       	jmp    215ad0 <dumpCurrentStackTrace+0x1330>
        a /= base;
  2159d3:	4c 89 e9             	mov    rcx,r13
  2159d6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  2159dd:	00 00 00 
  2159e0:	48 c1 e9 04          	shr    rcx,0x4
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  2159e4:	89 ca                	mov    edx,ecx
  2159e6:	80 e2 0f             	and    dl,0xf
        0...9 => digit + '0',
  2159e9:	b3 30                	mov    bl,0x30
  2159eb:	80 fa 0a             	cmp    dl,0xa
  2159ee:	72 02                	jb     2159f2 <dumpCurrentStackTrace+0x1252>
  2159f0:	b3 57                	mov    bl,0x57
  2159f2:	00 d3                	add    bl,dl
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  2159f4:	88 5c 04 1e          	mov    BYTE PTR [rsp+rax*1+0x1e],bl
        if (a == 0) break;
  2159f8:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  2159fc:	49 81 fd ff 00 00 00 	cmp    r13,0xff
  215a03:	49 89 cd             	mov    r13,rcx
  215a06:	77 d8                	ja     2159e0 <dumpCurrentStackTrace+0x1240>
        const padded_buf = buf[index - padding ..];
  215a08:	48 8d 0c 04          	lea    rcx,[rsp+rax*1]
  215a0c:	48 83 c1 1f          	add    rcx,0x1f
  215a10:	ba 41 00 00 00       	mov    edx,0x41
  215a15:	48 29 c2             	sub    rdx,rax
  215a18:	48 89 4c 24 08       	mov    QWORD PTR [rsp+0x8],rcx
  215a1d:	48 89 54 24 10       	mov    QWORD PTR [rsp+0x10],rdx
        return output(context, padded_buf);
  215a22:	4c 89 e7             	mov    rdi,r12
  215a25:	48 8d 74 24 08       	lea    rsi,[rsp+0x8]
  215a2a:	c5 f8 77             	vzeroupper 
  215a2d:	41 ff d6             	call   r14
  215a30:	41 89 c7             	mov    r15d,eax
                    try formatType(args[next_arg], fmt[s..i], context, Errors, output);
  215a33:	66 45 85 ff          	test   r15w,r15w
  215a37:	0f 85 b8 03 00 00    	jne    215df5 <dumpCurrentStackTrace+0x1655>
                        try output(context, fmt[start_index..i]);
  215a3d:	4c 89 e7             	mov    rdi,r12
  215a40:	48 8d 35 31 03 03 00 	lea    rsi,[rip+0x30331]        # 245d78 <__unnamed_44>
  215a47:	41 ff d6             	call   r14
  215a4a:	41 89 c7             	mov    r15d,eax
  215a4d:	66 45 85 ff          	test   r15w,r15w
  215a51:	0f 85 9e 03 00 00    	jne    215df5 <dumpCurrentStackTrace+0x1655>
                const casted_value = ([]const u8)(value);
  215a57:	c5 f9 6f 84 24 20 01 	vmovdqa xmm0,XMMWORD PTR [rsp+0x120]
  215a5e:	00 00 
  215a60:	c5 f9 7f 44 24 20    	vmovdqa XMMWORD PTR [rsp+0x20],xmm0
                return output(context, casted_value);
  215a66:	4c 89 e7             	mov    rdi,r12
  215a69:	48 8d 74 24 20       	lea    rsi,[rsp+0x20]
  215a6e:	41 ff d6             	call   r14
  215a71:	41 89 c7             	mov    r15d,eax
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  215a74:	66 45 85 ff          	test   r15w,r15w
  215a78:	0f 85 77 03 00 00    	jne    215df5 <dumpCurrentStackTrace+0x1655>
        try output(context, fmt[start_index..]);
  215a7e:	4c 89 e7             	mov    rdi,r12
  215a81:	48 8d 35 00 03 03 00 	lea    rsi,[rip+0x30300]        # 245d88 <__unnamed_45>
  215a88:	41 ff d6             	call   r14
  215a8b:	41 89 c7             	mov    r15d,eax
                    try out_stream.print(
  215a8e:	66 45 85 ff          	test   r15w,r15w
  215a92:	0f 84 29 02 00 00    	je     215cc1 <dumpCurrentStackTrace+0x1521>
  215a98:	e9 58 03 00 00       	jmp    215df5 <dumpCurrentStackTrace+0x1655>
        a /= base;
  215a9d:	4c 89 e9             	mov    rcx,r13
  215aa0:	48 c1 e9 04          	shr    rcx,0x4
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  215aa4:	89 ca                	mov    edx,ecx
  215aa6:	80 e2 0f             	and    dl,0xf
        0...9 => digit + '0',
  215aa9:	b3 30                	mov    bl,0x30
  215aab:	80 fa 0a             	cmp    dl,0xa
  215aae:	72 02                	jb     215ab2 <dumpCurrentStackTrace+0x1312>
  215ab0:	b3 57                	mov    bl,0x57
  215ab2:	00 d3                	add    bl,dl
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  215ab4:	88 5c 04 1e          	mov    BYTE PTR [rsp+rax*1+0x1e],bl
        if (a == 0) break;
  215ab8:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  215abc:	49 81 fd ff 00 00 00 	cmp    r13,0xff
  215ac3:	49 89 cd             	mov    r13,rcx
  215ac6:	77 d8                	ja     215aa0 <dumpCurrentStackTrace+0x1300>
        const padded_buf = buf[index - padding ..];
  215ac8:	48 8d 0c 04          	lea    rcx,[rsp+rax*1]
  215acc:	48 83 c1 1f          	add    rcx,0x1f
  215ad0:	ba 41 00 00 00       	mov    edx,0x41
  215ad5:	48 29 c2             	sub    rdx,rax
  215ad8:	48 89 4c 24 08       	mov    QWORD PTR [rsp+0x8],rcx
  215add:	48 89 54 24 10       	mov    QWORD PTR [rsp+0x10],rdx
        return output(context, padded_buf);
  215ae2:	4c 89 e7             	mov    rdi,r12
  215ae5:	48 8d 74 24 08       	lea    rsi,[rsp+0x8]
  215aea:	c5 f8 77             	vzeroupper 
  215aed:	41 ff d6             	call   r14
  215af0:	41 89 c7             	mov    r15d,eax
                    try formatType(args[next_arg], fmt[s..i], context, Errors, output);
  215af3:	66 45 85 ff          	test   r15w,r15w
  215af7:	0f 85 f8 02 00 00    	jne    215df5 <dumpCurrentStackTrace+0x1655>
                        try output(context, fmt[start_index..i]);
  215afd:	4c 89 e7             	mov    rdi,r12
  215b00:	48 8d 35 21 02 03 00 	lea    rsi,[rip+0x30221]        # 245d28 <__unnamed_46>
  215b07:	41 ff d6             	call   r14
  215b0a:	41 89 c7             	mov    r15d,eax
  215b0d:	66 45 85 ff          	test   r15w,r15w
  215b11:	0f 85 de 02 00 00    	jne    215df5 <dumpCurrentStackTrace+0x1655>
                const casted_value = ([]const u8)(value);
  215b17:	c5 f9 6f 84 24 20 01 	vmovdqa xmm0,XMMWORD PTR [rsp+0x120]
  215b1e:	00 00 
  215b20:	c5 f9 7f 44 24 20    	vmovdqa XMMWORD PTR [rsp+0x20],xmm0
                return output(context, casted_value);
  215b26:	4c 89 e7             	mov    rdi,r12
  215b29:	48 8d 74 24 20       	lea    rsi,[rsp+0x20]
  215b2e:	41 ff d6             	call   r14
  215b31:	41 89 c7             	mov    r15d,eax
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  215b34:	66 45 85 ff          	test   r15w,r15w
  215b38:	0f 85 b7 02 00 00    	jne    215df5 <dumpCurrentStackTrace+0x1655>
        try output(context, fmt[start_index..]);
  215b3e:	4c 89 e7             	mov    rdi,r12
  215b41:	48 8d 35 f0 01 03 00 	lea    rsi,[rip+0x301f0]        # 245d38 <__unnamed_47>
  215b48:	41 ff d6             	call   r14
  215b4b:	41 89 c7             	mov    r15d,eax
                    try out_stream.print(
  215b4e:	66 45 85 ff          	test   r15w,r15w
  215b52:	0f 85 9d 02 00 00    	jne    215df5 <dumpCurrentStackTrace+0x1655>
                    if (printLineFromFile(out_stream, line_info)) {
  215b58:	4c 89 e7             	mov    rdi,r12
  215b5b:	48 8d b4 24 80 00 00 	lea    rsi,[rsp+0x80]
  215b62:	00 
  215b63:	e8 98 bb 00 00       	call   221700 <printLineFromFile>
  215b68:	41 89 c7             	mov    r15d,eax
  215b6b:	41 0f b7 c7          	movzx  eax,r15w
  215b6f:	83 f8 24             	cmp    eax,0x24
  215b72:	0f 84 49 01 00 00    	je     215cc1 <dumpCurrentStackTrace+0x1521>
  215b78:	66 45 85 ff          	test   r15w,r15w
  215b7c:	0f 85 84 00 00 00    	jne    215c06 <dumpCurrentStackTrace+0x1466>
  215b82:	48 8b 44 24 78       	mov    rax,QWORD PTR [rsp+0x78]
                        if (line_info.column == 0) {
  215b87:	48 85 c0             	test   rax,rax
  215b8a:	0f 84 16 01 00 00    	je     215ca6 <dumpCurrentStackTrace+0x1506>
  215b90:	48 83 f8 01          	cmp    rax,0x1
  215b94:	74 41                	je     215bd7 <dumpCurrentStackTrace+0x1437>
  215b96:	bb 01 00 00 00       	mov    ebx,0x1
  215b9b:	c6 44 24 08 20       	mov    BYTE PTR [rsp+0x8],0x20
        pub fn write(self: *Self, bytes: []const u8) !void {
            return self.writeFn(self, bytes);
        }

        pub fn writeByte(self: *Self, byte: u8) !void {
            const slice = (*[1]u8)(&byte)[0..];
  215ba0:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  215ba5:	48 89 44 24 20       	mov    QWORD PTR [rsp+0x20],rax
  215baa:	48 c7 44 24 28 01 00 	mov    QWORD PTR [rsp+0x28],0x1
  215bb1:	00 00 
            return self.writeFn(self, slice);
  215bb3:	4c 89 e7             	mov    rdi,r12
  215bb6:	48 8d 74 24 20       	lea    rsi,[rsp+0x20]
  215bbb:	41 ff 14 24          	call   QWORD PTR [r12]
  215bbf:	41 89 c7             	mov    r15d,eax
                                    try out_stream.writeByte(' ');
  215bc2:	66 45 85 ff          	test   r15w,r15w
  215bc6:	0f 85 29 02 00 00    	jne    215df5 <dumpCurrentStackTrace+0x1655>
  215bcc:	48 83 c3 01          	add    rbx,0x1
                                while (col_i < line_info.column) : (col_i += 1) {
  215bd0:	48 3b 5c 24 78       	cmp    rbx,QWORD PTR [rsp+0x78]
  215bd5:	72 c4                	jb     215b9b <dumpCurrentStackTrace+0x13fb>
            return self.writeFn(self, bytes);
  215bd7:	4c 89 e7             	mov    rdi,r12
  215bda:	48 8d 35 b7 00 03 00 	lea    rsi,[rip+0x300b7]        # 245c98 <__unnamed_48>
  215be1:	41 ff 14 24          	call   QWORD PTR [r12]
  215be5:	41 89 c7             	mov    r15d,eax
  215be8:	66 45 85 ff          	test   r15w,r15w
  215bec:	0f 84 cf 00 00 00    	je     215cc1 <dumpCurrentStackTrace+0x1521>
  215bf2:	e9 39 02 00 00       	jmp    215e30 <dumpCurrentStackTrace+0x1690>
  215bf7:	48 83 f9 4b          	cmp    rcx,0x4b
  215bfb:	0f 85 7a f6 ff ff    	jne    21527b <dumpCurrentStackTrace+0xadb>
  215c01:	e9 6b f6 ff ff       	jmp    215271 <dumpCurrentStackTrace+0xad1>
        const bytes = @sliceToBytes(memory);
  215c06:	48 8b 84 24 98 00 00 	mov    rax,QWORD PTR [rsp+0x98]
  215c0d:	00 
        if (bytes.len == 0) return;
  215c0e:	48 85 c0             	test   rax,rax
  215c11:	0f 84 39 f5 ff ff    	je     215150 <dumpCurrentStackTrace+0x9b0>
  215c17:	48 8b bc 24 a0 00 00 	mov    rdi,QWORD PTR [rsp+0xa0]
  215c1e:	00 
        const bytes = @sliceToBytes(memory);
  215c1f:	48 8b 8c 24 90 00 00 	mov    rcx,QWORD PTR [rsp+0x90]
  215c26:	00 
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  215c27:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  215c2b:	48 89 4c 24 20       	mov    QWORD PTR [rsp+0x20],rcx
  215c30:	48 89 44 24 28       	mov    QWORD PTR [rsp+0x28],rax
  215c35:	48 8d 74 24 20       	lea    rsi,[rsp+0x20]
  215c3a:	ff d2                	call   rdx
  215c3c:	c5 7d 6f a4 24 00 01 	vmovdqa ymm12,YMMWORD PTR [rsp+0x100]
  215c43:	00 00 
  215c45:	c5 7d 6f ac 24 e0 00 	vmovdqa ymm13,YMMWORD PTR [rsp+0xe0]
  215c4c:	00 00 
        try printSourceAtAddress(debug_info, out_stream, return_address, tty_color);
  215c4e:	66 45 85 ff          	test   r15w,r15w
  215c52:	0f 84 14 f5 ff ff    	je     21516c <dumpCurrentStackTrace+0x9cc>
  215c58:	e9 0b 01 00 00       	jmp    215d68 <dumpCurrentStackTrace+0x15c8>
  215c5d:	48 8b 4c 24 68       	mov    rcx,QWORD PTR [rsp+0x68]
            var in_file_stream = io.FileInStream.init(&self.self_exe_file);
  215c62:	48 89 8c 24 b8 00 00 	mov    QWORD PTR [rsp+0xb8],rcx
  215c69:	00 
  215c6a:	48 8d 05 cf 5f 00 00 	lea    rax,[rip+0x5fcf]        # 21bc40 <FileInStream_readFn>
  215c71:	48 89 84 24 c0 00 00 	mov    QWORD PTR [rsp+0xc0],rax
  215c78:	00 
  215c79:	48 8b b1 a0 00 00 00 	mov    rsi,QWORD PTR [rcx+0xa0]
  215c80:	4c 8d 74 24 20       	lea    r14,[rsp+0x20]
            return readStringRaw(self.allocator(), in_stream);
  215c85:	4c 89 f7             	mov    rdi,r14
  215c88:	48 8d 94 24 c0 00 00 	lea    rdx,[rsp+0xc0]
  215c8f:	00 
  215c90:	4c 89 cb             	mov    rbx,r9
  215c93:	c5 f8 77             	vzeroupper 
  215c96:	e8 25 96 00 00       	call   21f2c0 <readStringRaw>
  215c9b:	49 89 d9             	mov    r9,rbx
        return switch (form_value.*) {
  215c9e:	4c 89 f1             	mov    rcx,r14
  215ca1:	e9 fe f5 ff ff       	jmp    2152a4 <dumpCurrentStackTrace+0xb04>
  215ca6:	4c 89 e7             	mov    rdi,r12
  215ca9:	48 8d 35 d8 ff 02 00 	lea    rsi,[rip+0x2ffd8]        # 245c88 <__unnamed_3>
  215cb0:	41 ff 14 24          	call   QWORD PTR [r12]
  215cb4:	41 89 c7             	mov    r15d,eax
  215cb7:	66 45 85 ff          	test   r15w,r15w
  215cbb:	0f 85 6f 01 00 00    	jne    215e30 <dumpCurrentStackTrace+0x1690>
        const bytes = @sliceToBytes(memory);
  215cc1:	48 8b 84 24 98 00 00 	mov    rax,QWORD PTR [rsp+0x98]
  215cc8:	00 
        if (bytes.len == 0) return;
  215cc9:	48 85 c0             	test   rax,rax
  215ccc:	74 25                	je     215cf3 <dumpCurrentStackTrace+0x1553>
  215cce:	48 8b bc 24 a0 00 00 	mov    rdi,QWORD PTR [rsp+0xa0]
  215cd5:	00 
        const bytes = @sliceToBytes(memory);
  215cd6:	48 8b 8c 24 90 00 00 	mov    rcx,QWORD PTR [rsp+0x90]
  215cdd:	00 
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  215cde:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  215ce2:	48 89 4c 24 20       	mov    QWORD PTR [rsp+0x20],rcx
  215ce7:	48 89 44 24 28       	mov    QWORD PTR [rsp+0x28],rax
  215cec:	48 8d 74 24 20       	lea    rsi,[rsp+0x20]
  215cf1:	ff d2                	call   rdx
  215cf3:	48 8b 8c 24 a8 00 00 	mov    rcx,QWORD PTR [rsp+0xa8]
  215cfa:	00 
  215cfb:	48 8b 94 24 b0 00 00 	mov    rdx,QWORD PTR [rsp+0xb0]
  215d02:	00 
  215d03:	c5 7d 6f a4 24 00 01 	vmovdqa ymm12,YMMWORD PTR [rsp+0x100]
  215d0a:	00 00 
  215d0c:	c5 7d 6f ac 24 e0 00 	vmovdqa ymm13,YMMWORD PTR [rsp+0xe0]
  215d13:	00 00 
  215d15:	31 c0                	xor    eax,eax
  215d17:	e9 62 f4 ff ff       	jmp    21517e <dumpCurrentStackTrace+0x9de>
  215d1c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
        const return_address = @intToPtr(*const usize, fp + @sizeOf(usize)).*;
  215d20:	4c 8b 6a 08          	mov    r13,QWORD PTR [rdx+0x8]
                if (return_address == addr) {
  215d24:	49 39 cd             	cmp    r13,rcx
        switch (addr_state) {
  215d27:	0f 84 b3 ed ff ff    	je     214ae0 <dumpCurrentStackTrace+0x340>
  215d2d:	f6 d0                	not    al
  215d2f:	a8 01                	test   al,0x1
  215d31:	b0 01                	mov    al,0x1
  215d33:	0f 85 a7 ed ff ff    	jne    214ae0 <dumpCurrentStackTrace+0x340>
    while (fp != 0) : (fp = @intToPtr(*const usize, fp).*) {
  215d39:	48 8b 12             	mov    rdx,QWORD PTR [rdx]
  215d3c:	48 85 d2             	test   rdx,rdx
  215d3f:	75 df                	jne    215d20 <dumpCurrentStackTrace+0x1580>
  215d41:	eb 72                	jmp    215db5 <dumpCurrentStackTrace+0x1615>
        const form_value = self.getAttr(id) orelse return error.MissingDebugInfo;
  215d43:	48 8b 05 de 24 ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffff24de]        # 208228 <__unnamed_49+0x10>
  215d4a:	48 89 84 24 4e 01 00 	mov    QWORD PTR [rsp+0x14e],rax
  215d51:	00 
  215d52:	c5 fa 6f 05 c0 24 ff 	vmovdqu xmm0,XMMWORD PTR [rip+0xffffffffffff24c0]        # 20821a <__unnamed_49+0x2>
  215d59:	ff 
  215d5a:	c5 f9 7f 84 24 40 01 	vmovdqa XMMWORD PTR [rsp+0x140],xmm0
  215d61:	00 00 
  215d63:	66 41 bf 22 00       	mov    r15w,0x22
            return std.fmt.format(self, Error, self.writeFn, format, args);
  215d68:	49 8b 1c 24          	mov    rbx,QWORD PTR [r12]
                        try output(context, fmt[start_index..i]);
  215d6c:	48 8d 35 55 00 03 00 	lea    rsi,[rip+0x30055]        # 245dc8 <__unnamed_50>
  215d73:	4c 89 e7             	mov    rdi,r12
  215d76:	c5 f8 77             	vzeroupper 
  215d79:	ff d3                	call   rbx
  215d7b:	66 85 c0             	test   ax,ax
  215d7e:	75 35                	jne    215db5 <dumpCurrentStackTrace+0x1615>
        stderr.print("Unable to dump stack trace: {}\n", @errorName(err)) catch return;
  215d80:	49 0f bf c7          	movsx  rax,r15w
  215d84:	48 c1 e0 04          	shl    rax,0x4
  215d88:	48 8d 0d 71 d2 02 00 	lea    rcx,[rip+0x2d271]        # 243000 <raw+0xf38>
                const casted_value = ([]const u8)(value);
  215d8f:	c5 f8 10 04 08       	vmovups xmm0,XMMWORD PTR [rax+rcx*1]
  215d94:	c5 f8 29 44 24 20    	vmovaps XMMWORD PTR [rsp+0x20],xmm0
  215d9a:	48 8d 74 24 20       	lea    rsi,[rsp+0x20]
                return output(context, casted_value);
  215d9f:	4c 89 e7             	mov    rdi,r12
  215da2:	ff d3                	call   rbx
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  215da4:	66 85 c0             	test   ax,ax
  215da7:	75 0c                	jne    215db5 <dumpCurrentStackTrace+0x1615>
        try output(context, fmt[start_index..]);
  215da9:	48 8d 35 28 00 03 00 	lea    rsi,[rip+0x30028]        # 245dd8 <__unnamed_51>
  215db0:	4c 89 e7             	mov    rdi,r12
  215db3:	ff d3                	call   rbx
    const stderr = getStderrStream() catch return;
  215db5:	48 8d 65 d8          	lea    rsp,[rbp-0x28]
  215db9:	5b                   	pop    rbx
  215dba:	41 5c                	pop    r12
  215dbc:	41 5d                	pop    r13
  215dbe:	41 5e                	pop    r14
  215dc0:	41 5f                	pop    r15
  215dc2:	5d                   	pop    rbp
  215dc3:	c5 f8 77             	vzeroupper 
  215dc6:	c3                   	ret    
  215dc7:	49 89 dc             	mov    r12,rbx
        const bytes = @sliceToBytes(memory);
  215dca:	48 8b 84 24 98 00 00 	mov    rax,QWORD PTR [rsp+0x98]
  215dd1:	00 
        if (bytes.len == 0) return;
  215dd2:	48 85 c0             	test   rax,rax
  215dd5:	75 2f                	jne    215e06 <dumpCurrentStackTrace+0x1666>
  215dd7:	eb 8f                	jmp    215d68 <dumpCurrentStackTrace+0x15c8>
  215dd9:	4c 8b 64 24 70       	mov    r12,QWORD PTR [rsp+0x70]
        const bytes = @sliceToBytes(memory);
  215dde:	48 8b 84 24 98 00 00 	mov    rax,QWORD PTR [rsp+0x98]
  215de5:	00 
        if (bytes.len == 0) return;
  215de6:	48 85 c0             	test   rax,rax
  215de9:	75 1b                	jne    215e06 <dumpCurrentStackTrace+0x1666>
  215deb:	e9 78 ff ff ff       	jmp    215d68 <dumpCurrentStackTrace+0x15c8>
  215df0:	4c 8b 64 24 70       	mov    r12,QWORD PTR [rsp+0x70]
        const bytes = @sliceToBytes(memory);
  215df5:	48 8b 84 24 98 00 00 	mov    rax,QWORD PTR [rsp+0x98]
  215dfc:	00 
        if (bytes.len == 0) return;
  215dfd:	48 85 c0             	test   rax,rax
  215e00:	0f 84 62 ff ff ff    	je     215d68 <dumpCurrentStackTrace+0x15c8>
  215e06:	48 8b bc 24 a0 00 00 	mov    rdi,QWORD PTR [rsp+0xa0]
  215e0d:	00 
        const bytes = @sliceToBytes(memory);
  215e0e:	48 8b 8c 24 90 00 00 	mov    rcx,QWORD PTR [rsp+0x90]
  215e15:	00 
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  215e16:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  215e1a:	48 89 4c 24 20       	mov    QWORD PTR [rsp+0x20],rcx
  215e1f:	48 89 44 24 28       	mov    QWORD PTR [rsp+0x28],rax
  215e24:	48 8d 74 24 20       	lea    rsi,[rsp+0x20]
  215e29:	ff d2                	call   rdx
  215e2b:	e9 38 ff ff ff       	jmp    215d68 <dumpCurrentStackTrace+0x15c8>
        const bytes = @sliceToBytes(memory);
  215e30:	48 8b 84 24 98 00 00 	mov    rax,QWORD PTR [rsp+0x98]
  215e37:	00 
        if (bytes.len == 0) return;
  215e38:	48 85 c0             	test   rax,rax
  215e3b:	74 25                	je     215e62 <dumpCurrentStackTrace+0x16c2>
  215e3d:	48 8b bc 24 a0 00 00 	mov    rdi,QWORD PTR [rsp+0xa0]
  215e44:	00 
        const bytes = @sliceToBytes(memory);
  215e45:	48 8b 8c 24 90 00 00 	mov    rcx,QWORD PTR [rsp+0x90]
  215e4c:	00 
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  215e4d:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  215e51:	48 89 4c 24 20       	mov    QWORD PTR [rsp+0x20],rcx
  215e56:	48 89 44 24 28       	mov    QWORD PTR [rsp+0x28],rax
  215e5b:	48 8d 74 24 20       	lea    rsi,[rsp+0x20]
  215e60:	ff d2                	call   rdx
  215e62:	4c 8b 64 24 70       	mov    r12,QWORD PTR [rsp+0x70]
  215e67:	e9 fc fe ff ff       	jmp    215d68 <dumpCurrentStackTrace+0x15c8>
  215e6c:	48 c7 c0 fe ff ff ff 	mov    rax,0xfffffffffffffffe
        const this_key = ptr[0..line_i];
        if (!mem.eql(u8, key, this_key)) continue;

        var end_i: usize = line_i;
        while (ptr[end_i] != 0) : (end_i += 1) {}
  215e73:	80 7c 06 11 00       	cmp    BYTE PTR [rsi+rax*1+0x11],0x0
  215e78:	48 8d 40 01          	lea    rax,[rax+0x1]
  215e7c:	75 f5                	jne    215e73 <dumpCurrentStackTrace+0x16d3>
  215e7e:	c6 44 24 07 01       	mov    BYTE PTR [rsp+0x7],0x1
        if (new_end_index > self.buffer.len) {
  215e83:	48 3d 81 00 00 00    	cmp    rax,0x81
        if (n == 0) {
  215e89:	0f 83 ce eb ff ff    	jae    214a5d <dumpCurrentStackTrace+0x2bd>
  215e8f:	e9 e9 eb ff ff       	jmp    214a7d <dumpCurrentStackTrace+0x2dd>
  215e94:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  215e9b:	00 00 00 00 00 

0000000000215ea0 <AlignedArrayList(Result,8)_append>:

            mem.copyBackwards(T, self.items[n + items.len .. self.len], self.items[n .. self.len - items.len]);
            mem.copy(T, self.items[n .. n + items.len], items);
        }

        pub fn append(self: *Self, item: T) !void {
  215ea0:	41 57                	push   r15
  215ea2:	41 56                	push   r14
  215ea4:	41 54                	push   r12
  215ea6:	53                   	push   rbx
  215ea7:	48 83 ec 58          	sub    rsp,0x58
  215eab:	49 89 f6             	mov    r14,rsi
  215eae:	49 89 fc             	mov    r12,rdi
            assert(new_len <= self.len);
            self.len = new_len;
        }

        pub fn ensureCapacity(self: *Self, new_capacity: usize) !void {
            var better_capacity = self.items.len;
  215eb1:	49 8b 4c 24 08       	mov    rcx,QWORD PTR [r12+0x8]
            }
            self.items = try self.allocator.alignedRealloc(T, A, self.items, better_capacity);
        }

        pub fn addOne(self: *Self) !*T {
            const new_length = self.len + 1;
  215eb6:	49 8b 5c 24 10       	mov    rbx,QWORD PTR [r12+0x10]
            if (better_capacity >= new_capacity) return;
  215ebb:	48 39 d9             	cmp    rcx,rbx
  215ebe:	76 25                	jbe    215ee5 <AlignedArrayList(Result,8)_append+0x45>
            try self.ensureCapacity(new_length);
            const result = &self.items[self.len];
  215ec0:	49 8b 04 24          	mov    rax,QWORD PTR [r12]
  215ec4:	48 89 d9             	mov    rcx,rbx
  215ec7:	48 83 c3 01          	add    rbx,0x1
  215ecb:	48 c1 e1 04          	shl    rcx,0x4
            self.len = new_length;
  215ecf:	49 89 5c 24 10       	mov    QWORD PTR [r12+0x10],rbx
            new_item_ptr.* = item;
  215ed4:	c4 c1 78 10 06       	vmovups xmm0,XMMWORD PTR [r14]
  215ed9:	c5 f8 11 04 08       	vmovups XMMWORD PTR [rax+rcx*1],xmm0
        pub fn append(self: *Self, item: T) !void {
  215ede:	31 c0                	xor    eax,eax
  215ee0:	e9 cf 00 00 00       	jmp    215fb4 <AlignedArrayList(Result,8)_append+0x114>
  215ee5:	48 89 c8             	mov    rax,rcx
  215ee8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  215eef:	00 
                better_capacity += better_capacity / 2 + 8;
  215ef0:	48 89 c2             	mov    rdx,rax
  215ef3:	48 d1 ea             	shr    rdx,1
  215ef6:	48 01 d0             	add    rax,rdx
  215ef9:	48 83 c0 08          	add    rax,0x8
                if (better_capacity >= new_capacity) break;
  215efd:	48 39 d8             	cmp    rax,rbx
  215f00:	76 ee                	jbe    215ef0 <AlignedArrayList(Result,8)_append+0x50>
            self.items = try self.allocator.alignedRealloc(T, A, self.items, better_capacity);
  215f02:	49 8b 74 24 18       	mov    rsi,QWORD PTR [r12+0x18]
        if (old_mem.len == 0) {
  215f07:	48 85 c9             	test   rcx,rcx
  215f0a:	74 2b                	je     215f37 <AlignedArrayList(Result,8)_append+0x97>
        const old_byte_slice = @sliceToBytes(old_mem);
  215f0c:	49 8b 14 24          	mov    rdx,QWORD PTR [r12]
  215f10:	48 c1 e1 04          	shl    rcx,0x4
  215f14:	48 89 54 24 20       	mov    QWORD PTR [rsp+0x20],rdx
  215f19:	48 89 4c 24 28       	mov    QWORD PTR [rsp+0x28],rcx
    return if (@mulWithOverflow(T, a, b, &answer)) error.Overflow else answer;
  215f1e:	b9 10 00 00 00       	mov    ecx,0x10
  215f23:	48 f7 e1             	mul    rcx
  215f26:	71 28                	jno    215f50 <AlignedArrayList(Result,8)_append+0xb0>
  215f28:	48 8d 0d d1 a5 fe ff 	lea    rcx,[rip+0xfffffffffffea5d1]        # 200500 <__unnamed_52>
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  215f2f:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  215f33:	75 7b                	jne    215fb0 <AlignedArrayList(Result,8)_append+0x110>
  215f35:	eb 30                	jmp    215f67 <AlignedArrayList(Result,8)_append+0xc7>
  215f37:	b9 10 00 00 00       	mov    ecx,0x10
  215f3c:	48 f7 e1             	mul    rcx
  215f3f:	71 58                	jno    215f99 <AlignedArrayList(Result,8)_append+0xf9>
  215f41:	48 8d 0d b8 a5 fe ff 	lea    rcx,[rip+0xfffffffffffea5b8]        # 200500 <__unnamed_52>
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  215f48:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  215f4c:	75 62                	jne    215fb0 <AlignedArrayList(Result,8)_append+0x110>
  215f4e:	eb 70                	jmp    215fc0 <AlignedArrayList(Result,8)_append+0x120>
  215f50:	48 8d 4c 24 08       	lea    rcx,[rsp+0x8]
  215f55:	66 c7 44 24 08 00 00 	mov    WORD PTR [rsp+0x8],0x0
  215f5c:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  215f61:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  215f65:	75 49                	jne    215fb0 <AlignedArrayList(Result,8)_append+0x110>
  215f67:	4c 8b 79 08          	mov    r15,QWORD PTR [rcx+0x8]
  215f6b:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  215f70:	48 8d 54 24 20       	lea    rdx,[rsp+0x20]
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  215f75:	41 b8 08 00 00 00    	mov    r8d,0x8
  215f7b:	4c 89 f9             	mov    rcx,r15
  215f7e:	ff 56 08             	call   QWORD PTR [rsi+0x8]
  215f81:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
  215f86:	66 85 c0             	test   ax,ax
  215f89:	75 29                	jne    215fb4 <AlignedArrayList(Result,8)_append+0x114>
        assert(byte_slice.len == byte_count);
  215f8b:	4c 39 7c 24 50       	cmp    QWORD PTR [rsp+0x50],r15
    if (!ok) {
  215f90:	75 6e                	jne    216000 <AlignedArrayList(Result,8)_append+0x160>
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  215f92:	48 8b 44 24 48       	mov    rax,QWORD PTR [rsp+0x48]
  215f97:	eb 50                	jmp    215fe9 <AlignedArrayList(Result,8)_append+0x149>
  215f99:	48 8d 4c 24 30       	lea    rcx,[rsp+0x30]
  215f9e:	66 c7 44 24 30 00 00 	mov    WORD PTR [rsp+0x30],0x0
  215fa5:	48 89 44 24 38       	mov    QWORD PTR [rsp+0x38],rax
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  215faa:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  215fae:	74 10                	je     215fc0 <AlignedArrayList(Result,8)_append+0x120>
  215fb0:	66 b8 01 00          	mov    ax,0x1
  215fb4:	48 83 c4 58          	add    rsp,0x58
  215fb8:	5b                   	pop    rbx
  215fb9:	41 5c                	pop    r12
  215fbb:	41 5e                	pop    r14
  215fbd:	41 5f                	pop    r15
  215fbf:	c3                   	ret    
  215fc0:	4c 8b 79 08          	mov    r15,QWORD PTR [rcx+0x8]
  215fc4:	48 8d 7c 24 08       	lea    rdi,[rsp+0x8]
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  215fc9:	b9 08 00 00 00       	mov    ecx,0x8
  215fce:	4c 89 fa             	mov    rdx,r15
  215fd1:	ff 16                	call   QWORD PTR [rsi]
  215fd3:	0f b7 44 24 08       	movzx  eax,WORD PTR [rsp+0x8]
  215fd8:	66 85 c0             	test   ax,ax
  215fdb:	75 d7                	jne    215fb4 <AlignedArrayList(Result,8)_append+0x114>
        assert(byte_slice.len == byte_count);
  215fdd:	4c 39 7c 24 18       	cmp    QWORD PTR [rsp+0x18],r15
  215fe2:	75 1c                	jne    216000 <AlignedArrayList(Result,8)_append+0x160>
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  215fe4:	48 8b 44 24 10       	mov    rax,QWORD PTR [rsp+0x10]
  215fe9:	49 89 04 24          	mov    QWORD PTR [r12],rax
  215fed:	49 c1 ef 04          	shr    r15,0x4
  215ff1:	4d 89 7c 24 08       	mov    QWORD PTR [r12+0x8],r15
            const result = &self.items[self.len];
  215ff6:	49 8b 4c 24 10       	mov    rcx,QWORD PTR [r12+0x10]
  215ffb:	e9 c7 fe ff ff       	jmp    215ec7 <AlignedArrayList(Result,8)_append+0x27>
            @panic("assertion failure");
  216000:	e8 db e5 ff ff       	call   2145e0 <panic>
  216005:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21600c:	00 00 00 00 

0000000000216010 <BenchmarkFramework_report>:
            @intToFloat(f64, result.run_time_ns)/@intToFloat(f64, ns_per_s),
  216010:	41 57                	push   r15
  216012:	41 56                	push   r14
  216014:	53                   	push   rbx
  216015:	48 83 ec 70          	sub    rsp,0x70
  216019:	c4 e1 f9 6e c7       	vmovq  xmm0,rdi
  21601e:	c5 f9 6f 0d fa a1 fe 	vmovdqa xmm1,XMMWORD PTR [rip+0xfffffffffffea1fa]        # 200220 <__unnamed_103+0x40>
  216025:	ff 
  216026:	c5 f9 62 c1          	vpunpckldq xmm0,xmm0,xmm1
  21602a:	c5 f9 28 15 1e a7 fe 	vmovapd xmm2,XMMWORD PTR [rip+0xfffffffffffea71e]        # 200750 <__unnamed_586+0x10>
  216031:	ff 
  216032:	c5 f9 5c c2          	vsubpd xmm0,xmm0,xmm2
  216036:	c5 f9 7c c0          	vhaddpd xmm0,xmm0,xmm0
  21603a:	c5 f9 29 04 24       	vmovapd XMMWORD PTR [rsp],xmm0
  21603f:	48 89 f3             	mov    rbx,rsi
            @intToFloat(f64, result.run_time_ns)/@intToFloat(f64, result.iterations),
  216042:	c4 e1 f9 6e c3       	vmovq  xmm0,rbx
  216047:	c5 f9 62 c1          	vpunpckldq xmm0,xmm0,xmm1
  21604b:	c5 f9 5c c2          	vsubpd xmm0,xmm0,xmm2
  21604f:	c5 f9 7c c0          	vhaddpd xmm0,xmm0,xmm0
  216053:	c5 f9 29 44 24 20    	vmovapd XMMWORD PTR [rsp+0x20],xmm0
  216059:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  216060:	b0 01                	mov    al,0x1
  216062:	86 05 a8 ff 02 00    	xchg   BYTE PTR [rip+0x2ffa8],al        # 246010 <stderr_mutex>
  216068:	84 c0                	test   al,al
  21606a:	75 f4                	jne    216060 <BenchmarkFramework_report+0x50>
    if (stderr_stream) |st| {
  21606c:	4c 8b 3d 95 ff 02 00 	mov    r15,QWORD PTR [rip+0x2ff95]        # 246008 <stderr_stream>
  216073:	4d 85 ff             	test   r15,r15
  216076:	74 09                	je     216081 <BenchmarkFramework_report+0x71>
  216078:	4c 8b 35 c1 bf 02 00 	mov    r14,QWORD PTR [rip+0x2bfc1]        # 242040 <stderr_file_out_stream+0x8>
  21607f:	eb 34                	jmp    2160b5 <BenchmarkFramework_report+0xa5>
        stderr_file = try io.getStdErr();
  216081:	48 8d 05 a8 bf 02 00 	lea    rax,[rip+0x2bfa8]        # 242030 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  216088:	48 89 05 a9 bf 02 00 	mov    QWORD PTR [rip+0x2bfa9],rax        # 242038 <stderr_file_out_stream>
  21608f:	4c 8d 35 ba 08 00 00 	lea    r14,[rip+0x8ba]        # 216950 <FileOutStream_writeFn>
  216096:	4c 89 35 a3 bf 02 00 	mov    QWORD PTR [rip+0x2bfa3],r14        # 242040 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  21609d:	c7 05 89 bf 02 00 02 	mov    DWORD PTR [rip+0x2bf89],0x2        # 242030 <stderr_file>
  2160a4:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  2160a7:	4c 8d 3d 92 bf 02 00 	lea    r15,[rip+0x2bf92]        # 242040 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  2160ae:	4c 89 3d 53 ff 02 00 	mov    QWORD PTR [rip+0x2ff53],r15        # 246008 <stderr_stream>
                        try output(context, fmt[start_index..i]);
  2160b5:	48 8d 35 2c fd 02 00 	lea    rsi,[rip+0x2fd2c]        # 245de8 <__unnamed_53>
  2160bc:	4c 89 ff             	mov    rdi,r15
  2160bf:	41 ff d6             	call   r14
  2160c2:	66 85 c0             	test   ax,ax
  2160c5:	0f 85 48 01 00 00    	jne    216213 <BenchmarkFramework_report+0x203>
    var buf: [max_int_digits - 1]u8 = undefined;
  2160cb:	c5 fc 10 05 ec 33 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffff33ec]        # 2094bf <__unnamed_5+0x1f>
  2160d2:	ff 
  2160d3:	c5 fc 11 44 24 4f    	vmovups YMMWORD PTR [rsp+0x4f],ymm0
  2160d9:	c5 fd 10 05 bf 33 ff 	vmovupd ymm0,YMMWORD PTR [rip+0xffffffffffff33bf]        # 2094a0 <__unnamed_5>
  2160e0:	ff 
  2160e1:	c5 fd 11 44 24 30    	vmovupd YMMWORD PTR [rsp+0x30],ymm0
        const digit = a % base;
  2160e7:	48 bf cd cc cc cc cc 	movabs rdi,0xcccccccccccccccd
  2160ee:	cc cc cc 
  2160f1:	48 89 da             	mov    rdx,rbx
  2160f4:	c4 e2 fb f6 cf       	mulx   rcx,rax,rdi
  2160f9:	c1 e9 02             	shr    ecx,0x2
  2160fc:	81 e1 fe ff ff 3f    	and    ecx,0x3ffffffe
  216102:	8d 04 89             	lea    eax,[rcx+rcx*4]
  216105:	89 d9                	mov    ecx,ebx
  216107:	29 c1                	sub    ecx,eax
        0...9 => digit + '0',
  216109:	b2 30                	mov    dl,0x30
  21610b:	80 f9 0a             	cmp    cl,0xa
  21610e:	72 02                	jb     216112 <BenchmarkFramework_report+0x102>
  216110:	b2 57                	mov    dl,0x57
  216112:	00 ca                	add    dl,cl
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  216114:	88 54 24 6f          	mov    BYTE PTR [rsp+0x6f],dl
        if (a == 0) break;
  216118:	48 83 fb 0a          	cmp    rbx,0xa
  21611c:	73 0c                	jae    21612a <BenchmarkFramework_report+0x11a>
  21611e:	48 8d 44 24 6f       	lea    rax,[rsp+0x6f]
  216123:	b9 40 00 00 00       	mov    ecx,0x40
  216128:	eb 4d                	jmp    216177 <BenchmarkFramework_report+0x167>
  21612a:	b9 40 00 00 00       	mov    ecx,0x40
  21612f:	90                   	nop
        a /= base;
  216130:	48 89 da             	mov    rdx,rbx
  216133:	c4 e2 fb f6 d7       	mulx   rdx,rax,rdi
  216138:	48 c1 ea 03          	shr    rdx,0x3
        const digit = a % base;
  21613c:	c4 e2 fb f6 f7       	mulx   rsi,rax,rdi
  216141:	c1 ee 02             	shr    esi,0x2
  216144:	81 e6 fe ff ff 3f    	and    esi,0x3ffffffe
  21614a:	8d 04 b6             	lea    eax,[rsi+rsi*4]
  21614d:	89 d6                	mov    esi,edx
  21614f:	29 c6                	sub    esi,eax
        0...9 => digit + '0',
  216151:	b0 30                	mov    al,0x30
  216153:	40 80 fe 0a          	cmp    sil,0xa
  216157:	72 02                	jb     21615b <BenchmarkFramework_report+0x14b>
  216159:	b0 57                	mov    al,0x57
  21615b:	40 00 f0             	add    al,sil
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  21615e:	88 44 0c 2e          	mov    BYTE PTR [rsp+rcx*1+0x2e],al
        if (a == 0) break;
  216162:	48 83 c1 ff          	add    rcx,0xffffffffffffffff
  216166:	48 83 fb 63          	cmp    rbx,0x63
  21616a:	48 89 d3             	mov    rbx,rdx
  21616d:	77 c1                	ja     216130 <BenchmarkFramework_report+0x120>
        const padded_buf = buf[index - padding ..];
  21616f:	48 8d 04 0c          	lea    rax,[rsp+rcx*1]
  216173:	48 83 c0 2f          	add    rax,0x2f
  216177:	ba 41 00 00 00       	mov    edx,0x41
  21617c:	48 29 ca             	sub    rdx,rcx
  21617f:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  216184:	48 89 54 24 18       	mov    QWORD PTR [rsp+0x18],rdx
  216189:	48 8d 74 24 10       	lea    rsi,[rsp+0x10]
        return output(context, padded_buf);
  21618e:	4c 89 ff             	mov    rdi,r15
  216191:	c5 f8 77             	vzeroupper 
  216194:	41 ff d6             	call   r14
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  216197:	66 85 c0             	test   ax,ax
  21619a:	75 77                	jne    216213 <BenchmarkFramework_report+0x203>
                        try output(context, fmt[start_index..i]);
  21619c:	48 8d 35 55 fc 02 00 	lea    rsi,[rip+0x2fc55]        # 245df8 <__unnamed_54>
  2161a3:	4c 89 ff             	mov    rdi,r15
  2161a6:	41 ff d6             	call   r14
  2161a9:	66 85 c0             	test   ax,ax
  2161ac:	75 65                	jne    216213 <BenchmarkFramework_report+0x203>
  2161ae:	c5 f9 28 04 24       	vmovapd xmm0,XMMWORD PTR [rsp]
  2161b3:	c5 fb 5e 05 b5 aa fe 	vdivsd xmm0,xmm0,QWORD PTR [rip+0xfffffffffffeaab5]        # 200c70 <__unnamed_456+0x20>
  2161ba:	ff 
        '.' => try formatFloatDecimal(value, width, context, Errors, output),
  2161bb:	48 8d 3d 2e a8 fe ff 	lea    rdi,[rip+0xfffffffffffea82e]        # 2009f0 <__unnamed_55>
  2161c2:	4c 89 fe             	mov    rsi,r15
  2161c5:	4c 89 f2             	mov    rdx,r14
  2161c8:	e8 43 d1 00 00       	call   223310 <formatFloatDecimal>
                    try formatType(args[next_arg], fmt[s..i], context, Errors, output);
  2161cd:	66 85 c0             	test   ax,ax
  2161d0:	75 41                	jne    216213 <BenchmarkFramework_report+0x203>
                        try output(context, fmt[start_index..i]);
  2161d2:	48 8d 35 2f fc 02 00 	lea    rsi,[rip+0x2fc2f]        # 245e08 <__unnamed_56>
  2161d9:	4c 89 ff             	mov    rdi,r15
  2161dc:	41 ff d6             	call   r14
  2161df:	66 85 c0             	test   ax,ax
  2161e2:	75 2f                	jne    216213 <BenchmarkFramework_report+0x203>
  2161e4:	c5 f9 28 04 24       	vmovapd xmm0,XMMWORD PTR [rsp]
  2161e9:	c5 fb 5e 44 24 20    	vdivsd xmm0,xmm0,QWORD PTR [rsp+0x20]
        '.' => try formatFloatDecimal(value, width, context, Errors, output),
  2161ef:	48 8d 3d fa a7 fe ff 	lea    rdi,[rip+0xfffffffffffea7fa]        # 2009f0 <__unnamed_55>
  2161f6:	4c 89 fe             	mov    rsi,r15
  2161f9:	4c 89 f2             	mov    rdx,r14
  2161fc:	e8 0f d1 00 00       	call   223310 <formatFloatDecimal>
                    try formatType(args[next_arg], fmt[s..i], context, Errors, output);
  216201:	66 85 c0             	test   ax,ax
  216204:	75 0d                	jne    216213 <BenchmarkFramework_report+0x203>
        try output(context, fmt[start_index..]);
  216206:	48 8d 35 0b fc 02 00 	lea    rsi,[rip+0x2fc0b]        # 245e18 <__unnamed_57>
  21620d:	4c 89 ff             	mov    rdi,r15
  216210:	41 ff d6             	call   r14
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  216213:	31 c0                	xor    eax,eax
  216215:	86 05 f5 fd 02 00    	xchg   BYTE PTR [rip+0x2fdf5],al        # 246010 <stderr_mutex>
  21621b:	3c 01                	cmp    al,0x1
    if (!ok) {
  21621d:	75 0a                	jne    216229 <BenchmarkFramework_report+0x219>
    fn report(pSelf: *Self, result: Result) void {
  21621f:	48 83 c4 70          	add    rsp,0x70
  216223:	5b                   	pop    rbx
  216224:	41 5e                	pop    r14
  216226:	41 5f                	pop    r15
  216228:	c3                   	ret    
            @panic("assertion failure");
  216229:	e8 b2 e3 ff ff       	call   2145e0 <panic>
  21622e:	66 90                	xchg   ax,ax

0000000000216230 <findLastForward>:
fn findLastForward(comptime T: type, items: []T, value: T, range: Range, lessThan: fn (T, T) bool, unique: usize) usize {
  216230:	41 56                	push   r14
  216232:	53                   	push   rbx
  216233:	49 89 d1             	mov    r9,rdx
    if (range.length() == 0) return range.start;
  216236:	48 89 c8             	mov    rax,rcx
  216239:	4c 29 c8             	sub    rax,r9
  21623c:	0f 84 eb 00 00 00    	je     21632d <findLastForward+0xfd>
  216242:	48 89 c2             	mov    rdx,rax
  216245:	4c 09 c2             	or     rdx,r8
  216248:	48 c1 ea 20          	shr    rdx,0x20
  21624c:	74 07                	je     216255 <findLastForward+0x25>
  21624e:	31 d2                	xor    edx,edx
  216250:	49 f7 f0             	div    r8
  216253:	eb 05                	jmp    21625a <findLastForward+0x2a>
  216255:	31 d2                	xor    edx,edx
  216257:	41 f7 f0             	div    r8d
    return if (x > y) x else y;
  21625a:	48 83 f8 01          	cmp    rax,0x1
  21625e:	41 ba 01 00 00 00    	mov    r10d,0x1
  216264:	4c 0f 47 d0          	cmova  r10,rax
  216268:	4b 8d 14 0a          	lea    rdx,[r10+r9*1]
    while (!lessThan(value, items[index - 1])) : (index += skip) {
  21626c:	4f 8d 5c 0a ff       	lea    r11,[r10+r9*1-0x1]
  216271:	4c 8b 37             	mov    r14,QWORD PTR [rdi]
  216274:	4c 8b 06             	mov    r8,QWORD PTR [rsi]
  216277:	4c 89 d8             	mov    rax,r11
  21627a:	48 c1 e0 04          	shl    rax,0x4
  21627e:	49 8b 34 06          	mov    rsi,QWORD PTR [r14+rax*1]
            return lhs.run_time_ns < rhs.run_time_ns;
  216282:	49 39 f0             	cmp    r8,rsi
  216285:	73 10                	jae    216297 <findLastForward+0x67>
  216287:	4c 89 c8             	mov    rax,r9
  21628a:	49 89 d1             	mov    r9,rdx
    if (range.start >= range.end) return range.end;
  21628d:	4d 85 d2             	test   r10,r10
  216290:	75 3e                	jne    2162d0 <findLastForward+0xa0>
  216292:	e9 96 00 00 00       	jmp    21632d <findLastForward+0xfd>
  216297:	48 89 cf             	mov    rdi,rcx
  21629a:	4c 29 d7             	sub    rdi,r10
  21629d:	0f 1f 00             	nop    DWORD PTR [rax]
  2162a0:	48 89 d0             	mov    rax,rdx
        if (index >= range.end - skip) {
  2162a3:	48 39 f8             	cmp    rax,rdi
  2162a6:	0f 83 88 00 00 00    	jae    216334 <findLastForward+0x104>
  2162ac:	4a 8d 14 10          	lea    rdx,[rax+r10*1]
    while (!lessThan(value, items[index - 1])) : (index += skip) {
  2162b0:	4e 8d 1c 10          	lea    r11,[rax+r10*1]
  2162b4:	49 83 c3 ff          	add    r11,0xffffffffffffffff
  2162b8:	4c 89 de             	mov    rsi,r11
  2162bb:	48 c1 e6 04          	shl    rsi,0x4
  2162bf:	49 8b 34 36          	mov    rsi,QWORD PTR [r14+rsi*1]
  2162c3:	49 39 f0             	cmp    r8,rsi
  2162c6:	73 d8                	jae    2162a0 <findLastForward+0x70>
  2162c8:	49 89 d1             	mov    r9,rdx
    if (range.start >= range.end) return range.end;
  2162cb:	4d 85 d2             	test   r10,r10
  2162ce:	74 5d                	je     21632d <findLastForward+0xfd>
    while (start < end) {
  2162d0:	49 39 c3             	cmp    r11,rax
  2162d3:	76 43                	jbe    216318 <findLastForward+0xe8>
  2162d5:	4c 89 d9             	mov    rcx,r11
  2162d8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  2162df:	00 
        const mid = start + (end - start) / 2;
  2162e0:	48 89 ca             	mov    rdx,rcx
  2162e3:	48 29 c2             	sub    rdx,rax
  2162e6:	48 d1 ea             	shr    rdx,1
  2162e9:	48 8d 1c 02          	lea    rbx,[rdx+rax*1]
  2162ed:	48 89 df             	mov    rdi,rbx
  2162f0:	48 c1 e7 04          	shl    rdi,0x4
  2162f4:	4d 3b 04 3e          	cmp    r8,QWORD PTR [r14+rdi*1]
        if (!lessThan(value, items[mid])) {
  2162f8:	72 16                	jb     216310 <findLastForward+0xe0>
  2162fa:	48 01 d0             	add    rax,rdx
  2162fd:	48 83 c0 01          	add    rax,0x1
    while (start < end) {
  216301:	48 39 c1             	cmp    rcx,rax
  216304:	77 da                	ja     2162e0 <findLastForward+0xb0>
  216306:	eb 10                	jmp    216318 <findLastForward+0xe8>
  216308:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  21630f:	00 
        if (!lessThan(value, items[mid])) {
  216310:	48 89 d9             	mov    rcx,rbx
    while (start < end) {
  216313:	48 39 c1             	cmp    rcx,rax
  216316:	77 c8                	ja     2162e0 <findLastForward+0xb0>
    if (start == range.end - 1 and !lessThan(value, items[start])) {
  216318:	4c 39 d8             	cmp    rax,r11
  21631b:	0f 94 c1             	sete   cl
  21631e:	49 39 f0             	cmp    r8,rsi
  216321:	0f 93 c2             	setae  dl
  216324:	20 ca                	and    dl,cl
  216326:	44 0f b6 ca          	movzx  r9d,dl
  21632a:	49 01 c1             	add    r9,rax
    if (range.length() == 0) return range.start;
  21632d:	4c 89 c8             	mov    rax,r9
  216330:	5b                   	pop    rbx
  216331:	41 5e                	pop    r14
  216333:	c3                   	ret    
    if (range.start >= range.end) return range.end;
  216334:	48 39 c8             	cmp    rax,rcx
  216337:	73 65                	jae    21639e <findLastForward+0x16e>
    var end = range.end - 1;
  216339:	48 83 c1 ff          	add    rcx,0xffffffffffffffff
    while (start < end) {
  21633d:	48 39 c1             	cmp    rcx,rax
  216340:	76 46                	jbe    216388 <findLastForward+0x158>
  216342:	49 89 c9             	mov    r9,rcx
  216345:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21634c:	00 00 00 00 
        const mid = start + (end - start) / 2;
  216350:	4c 89 ce             	mov    rsi,r9
  216353:	48 29 c6             	sub    rsi,rax
  216356:	48 d1 ee             	shr    rsi,1
  216359:	48 8d 14 06          	lea    rdx,[rsi+rax*1]
  21635d:	48 89 d7             	mov    rdi,rdx
  216360:	48 c1 e7 04          	shl    rdi,0x4
  216364:	4d 3b 04 3e          	cmp    r8,QWORD PTR [r14+rdi*1]
        if (!lessThan(value, items[mid])) {
  216368:	72 16                	jb     216380 <findLastForward+0x150>
  21636a:	48 01 f0             	add    rax,rsi
  21636d:	48 83 c0 01          	add    rax,0x1
    while (start < end) {
  216371:	49 39 c1             	cmp    r9,rax
  216374:	77 da                	ja     216350 <findLastForward+0x120>
  216376:	eb 10                	jmp    216388 <findLastForward+0x158>
  216378:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  21637f:	00 
        if (!lessThan(value, items[mid])) {
  216380:	49 89 d1             	mov    r9,rdx
    while (start < end) {
  216383:	49 39 c1             	cmp    r9,rax
  216386:	77 c8                	ja     216350 <findLastForward+0x120>
    if (start == range.end - 1 and !lessThan(value, items[start])) {
  216388:	48 39 c8             	cmp    rax,rcx
  21638b:	75 1b                	jne    2163a8 <findLastForward+0x178>
  21638d:	48 c1 e1 04          	shl    rcx,0x4
  216391:	45 31 c9             	xor    r9d,r9d
  216394:	4d 3b 04 0e          	cmp    r8,QWORD PTR [r14+rcx*1]
  216398:	41 0f 93 c1          	setae  r9b
  21639c:	eb 8c                	jmp    21632a <findLastForward+0xfa>
  21639e:	49 89 c9             	mov    r9,rcx
    if (range.length() == 0) return range.start;
  2163a1:	4c 89 c8             	mov    rax,r9
  2163a4:	5b                   	pop    rbx
  2163a5:	41 5e                	pop    r14
  2163a7:	c3                   	ret    
  2163a8:	45 31 c9             	xor    r9d,r9d
  2163ab:	e9 7a ff ff ff       	jmp    21632a <findLastForward+0xfa>

00000000002163b0 <mergeInPlace>:
fn mergeInPlace(comptime T: type, items: []T, A_arg: Range, B_arg: Range, lessThan: fn (T, T) bool) void {
  2163b0:	55                   	push   rbp
  2163b1:	41 57                	push   r15
  2163b3:	41 56                	push   r14
  2163b5:	41 55                	push   r13
  2163b7:	41 54                	push   r12
  2163b9:	53                   	push   rbx
  2163ba:	48 89 7c 24 f0       	mov    QWORD PTR [rsp-0x10],rdi
  2163bf:	4c 8b 3e             	mov    r15,QWORD PTR [rsi]
  2163c2:	4c 8b 76 08          	mov    r14,QWORD PTR [rsi+0x8]
    if (A_arg.length() == 0 or B_arg.length() == 0) return;
  2163c6:	4d 39 fe             	cmp    r14,r15
  2163c9:	0f 84 76 05 00 00    	je     216945 <mergeInPlace+0x595>
  2163cf:	48 8b 0a             	mov    rcx,QWORD PTR [rdx]
  2163d2:	4c 8b 4a 08          	mov    r9,QWORD PTR [rdx+0x8]
  2163d6:	49 39 c9             	cmp    r9,rcx
  2163d9:	0f 84 66 05 00 00    	je     216945 <mergeInPlace+0x595>
  2163df:	49 8d 41 ff          	lea    rax,[r9-0x1]
        const mid = binaryFirst(T, items, items[A.start], B, lessThan);
  2163e3:	48 89 44 24 f8       	mov    QWORD PTR [rsp-0x8],rax
  2163e8:	48 8b 44 24 f0       	mov    rax,QWORD PTR [rsp-0x10]
  2163ed:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  2163f0:	4d 89 fa             	mov    r10,r15
  2163f3:	49 c1 e2 04          	shl    r10,0x4
  2163f7:	4e 8d 1c 12          	lea    r11,[rdx+r10*1]
  2163fb:	4d 89 cc             	mov    r12,r9
    if (range.start >= range.end) return range.end;
  2163fe:	4c 39 c9             	cmp    rcx,r9
  216401:	0f 83 7f 00 00 00    	jae    216486 <mergeInPlace+0xd6>
  216407:	4c 8b 44 24 f8       	mov    r8,QWORD PTR [rsp-0x8]
    while (start < end) {
  21640c:	49 39 c8             	cmp    r8,rcx
  21640f:	76 4b                	jbe    21645c <mergeInPlace+0xac>
  216411:	49 8b 03             	mov    rax,QWORD PTR [r11]
  216414:	4c 89 c5             	mov    rbp,r8
  216417:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  21641e:	00 00 
        const mid = start + (end - start) / 2;
  216420:	48 89 ee             	mov    rsi,rbp
  216423:	48 29 ce             	sub    rsi,rcx
  216426:	48 d1 ee             	shr    rsi,1
  216429:	48 8d 1c 0e          	lea    rbx,[rsi+rcx*1]
  21642d:	48 89 df             	mov    rdi,rbx
  216430:	48 c1 e7 04          	shl    rdi,0x4
  216434:	48 39 04 3a          	cmp    QWORD PTR [rdx+rdi*1],rax
        if (lessThan(items[mid], value)) {
  216438:	72 16                	jb     216450 <mergeInPlace+0xa0>
  21643a:	48 89 dd             	mov    rbp,rbx
    while (start < end) {
  21643d:	48 39 cd             	cmp    rbp,rcx
  216440:	77 de                	ja     216420 <mergeInPlace+0x70>
  216442:	eb 18                	jmp    21645c <mergeInPlace+0xac>
  216444:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21644b:	00 00 00 00 00 
  216450:	48 01 f1             	add    rcx,rsi
  216453:	48 83 c1 01          	add    rcx,0x1
  216457:	48 39 cd             	cmp    rbp,rcx
  21645a:	77 c4                	ja     216420 <mergeInPlace+0x70>
    if (start == range.end - 1 and lessThan(items[start], value)) {
  21645c:	4c 39 c1             	cmp    rcx,r8
  21645f:	75 1f                	jne    216480 <mergeInPlace+0xd0>
  216461:	4c 89 c0             	mov    rax,r8
  216464:	48 c1 e0 04          	shl    rax,0x4
  216468:	48 8b 04 02          	mov    rax,QWORD PTR [rdx+rax*1]
  21646c:	45 31 e4             	xor    r12d,r12d
  21646f:	49 3b 03             	cmp    rax,QWORD PTR [r11]
  216472:	41 0f 92 c4          	setb   r12b
  216476:	eb 0b                	jmp    216483 <mergeInPlace+0xd3>
  216478:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  21647f:	00 
  216480:	45 31 e4             	xor    r12d,r12d
  216483:	49 01 cc             	add    r12,rcx
        mem.rotate(T, items[A.start..mid], A.length());
  216486:	4d 89 e5             	mov    r13,r12
  216489:	4d 29 fd             	sub    r13,r15
        return self.end - self.start;
  21648c:	4c 89 f3             	mov    rbx,r14
  21648f:	4c 29 fb             	sub    rbx,r15
    const end = items.len / 2;
  216492:	48 89 de             	mov    rsi,rbx
  216495:	48 d1 ee             	shr    rsi,1
    while (i < end) : (i += 1) {
  216498:	0f 84 2c 01 00 00    	je     2165ca <mergeInPlace+0x21a>
        swap(T, &items[i], &items[items.len - i - 1]);
  21649e:	48 8d 46 ff          	lea    rax,[rsi-0x1]
  2164a2:	89 f1                	mov    ecx,esi
  2164a4:	83 e1 03             	and    ecx,0x3
  2164a7:	48 83 f8 03          	cmp    rax,0x3
  2164ab:	73 13                	jae    2164c0 <mergeInPlace+0x110>
  2164ad:	31 c0                	xor    eax,eax
    while (i < end) : (i += 1) {
  2164af:	48 85 c9             	test   rcx,rcx
  2164b2:	0f 85 c8 00 00 00    	jne    216580 <mergeInPlace+0x1d0>
  2164b8:	e9 0d 01 00 00       	jmp    2165ca <mergeInPlace+0x21a>
  2164bd:	0f 1f 00             	nop    DWORD PTR [rax]
        swap(T, &items[i], &items[items.len - i - 1]);
  2164c0:	48 29 ce             	sub    rsi,rcx
  2164c3:	4a 8d 2c 12          	lea    rbp,[rdx+r10*1]
  2164c7:	48 83 c5 30          	add    rbp,0x30
  2164cb:	4c 89 f0             	mov    rax,r14
  2164ce:	48 c1 e0 04          	shl    rax,0x4
  2164d2:	4c 8d 04 02          	lea    r8,[rdx+rax*1]
  2164d6:	49 83 c0 f0          	add    r8,0xfffffffffffffff0
  2164da:	31 c0                	xor    eax,eax
  2164dc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
    const tmp = a.*;
  2164e0:	c5 f8 10 45 d0       	vmovups xmm0,XMMWORD PTR [rbp-0x30]
  2164e5:	c5 f8 29 44 24 d8    	vmovaps XMMWORD PTR [rsp-0x28],xmm0
    a.* = b.*;
  2164eb:	c4 c1 78 10 00       	vmovups xmm0,XMMWORD PTR [r8]
  2164f0:	c5 f8 11 45 d0       	vmovups XMMWORD PTR [rbp-0x30],xmm0
    b.* = tmp;
  2164f5:	c5 f8 28 44 24 d8    	vmovaps xmm0,XMMWORD PTR [rsp-0x28]
  2164fb:	c4 c1 78 11 00       	vmovups XMMWORD PTR [r8],xmm0
    const tmp = a.*;
  216500:	c5 f8 10 45 e0       	vmovups xmm0,XMMWORD PTR [rbp-0x20]
  216505:	c5 f8 29 44 24 d8    	vmovaps XMMWORD PTR [rsp-0x28],xmm0
    a.* = b.*;
  21650b:	c4 c1 78 10 40 f0    	vmovups xmm0,XMMWORD PTR [r8-0x10]
  216511:	c5 f8 11 45 e0       	vmovups XMMWORD PTR [rbp-0x20],xmm0
    b.* = tmp;
  216516:	c5 f8 28 44 24 d8    	vmovaps xmm0,XMMWORD PTR [rsp-0x28]
  21651c:	c4 c1 78 11 40 f0    	vmovups XMMWORD PTR [r8-0x10],xmm0
    const tmp = a.*;
  216522:	c5 f8 10 45 f0       	vmovups xmm0,XMMWORD PTR [rbp-0x10]
  216527:	c5 f8 29 44 24 d8    	vmovaps XMMWORD PTR [rsp-0x28],xmm0
    a.* = b.*;
  21652d:	c4 c1 78 10 40 e0    	vmovups xmm0,XMMWORD PTR [r8-0x20]
  216533:	c5 f8 11 45 f0       	vmovups XMMWORD PTR [rbp-0x10],xmm0
    b.* = tmp;
  216538:	c5 f8 28 44 24 d8    	vmovaps xmm0,XMMWORD PTR [rsp-0x28]
  21653e:	c4 c1 78 11 40 e0    	vmovups XMMWORD PTR [r8-0x20],xmm0
    const tmp = a.*;
  216544:	c5 f8 10 45 00       	vmovups xmm0,XMMWORD PTR [rbp+0x0]
  216549:	c5 f8 29 44 24 d8    	vmovaps XMMWORD PTR [rsp-0x28],xmm0
    a.* = b.*;
  21654f:	c4 c1 78 10 40 d0    	vmovups xmm0,XMMWORD PTR [r8-0x30]
  216555:	c5 f8 11 45 00       	vmovups XMMWORD PTR [rbp+0x0],xmm0
    b.* = tmp;
  21655a:	c5 f8 28 44 24 d8    	vmovaps xmm0,XMMWORD PTR [rsp-0x28]
  216560:	c4 c1 78 11 40 d0    	vmovups XMMWORD PTR [r8-0x30],xmm0
    while (i < end) : (i += 1) {
  216566:	48 83 c0 04          	add    rax,0x4
  21656a:	48 83 c5 40          	add    rbp,0x40
  21656e:	49 83 c0 c0          	add    r8,0xffffffffffffffc0
  216572:	48 39 c6             	cmp    rsi,rax
  216575:	0f 85 65 ff ff ff    	jne    2164e0 <mergeInPlace+0x130>
  21657b:	48 85 c9             	test   rcx,rcx
  21657e:	74 4a                	je     2165ca <mergeInPlace+0x21a>
  216580:	4c 89 f6             	mov    rsi,r14
  216583:	48 29 c6             	sub    rsi,rax
  216586:	48 c1 e6 04          	shl    rsi,0x4
  21658a:	48 01 d6             	add    rsi,rdx
  21658d:	48 83 c6 f0          	add    rsi,0xfffffffffffffff0
  216591:	4c 01 f8             	add    rax,r15
  216594:	48 c1 e0 04          	shl    rax,0x4
  216598:	48 01 d0             	add    rax,rdx
  21659b:	48 f7 d9             	neg    rcx
  21659e:	66 90                	xchg   ax,ax
    const tmp = a.*;
  2165a0:	c5 f8 10 00          	vmovups xmm0,XMMWORD PTR [rax]
  2165a4:	c5 f8 29 44 24 d8    	vmovaps XMMWORD PTR [rsp-0x28],xmm0
    a.* = b.*;
  2165aa:	c5 f8 10 06          	vmovups xmm0,XMMWORD PTR [rsi]
  2165ae:	c5 f8 11 00          	vmovups XMMWORD PTR [rax],xmm0
    b.* = tmp;
  2165b2:	c5 f8 28 44 24 d8    	vmovaps xmm0,XMMWORD PTR [rsp-0x28]
  2165b8:	c5 f8 11 06          	vmovups XMMWORD PTR [rsi],xmm0
    while (i < end) : (i += 1) {
  2165bc:	48 83 c6 f0          	add    rsi,0xfffffffffffffff0
  2165c0:	48 83 c0 10          	add    rax,0x10
  2165c4:	48 83 c1 01          	add    rcx,0x1
  2165c8:	75 d6                	jne    2165a0 <mergeInPlace+0x1f0>
    reverse(T, items[amount..]);
  2165ca:	4c 89 e9             	mov    rcx,r13
  2165cd:	48 29 d9             	sub    rcx,rbx
    const end = items.len / 2;
  2165d0:	48 d1 e9             	shr    rcx,1
    while (i < end) : (i += 1) {
  2165d3:	0f 84 41 01 00 00    	je     21671a <mergeInPlace+0x36a>
        swap(T, &items[i], &items[items.len - i - 1]);
  2165d9:	48 8d 41 ff          	lea    rax,[rcx-0x1]
  2165dd:	89 ce                	mov    esi,ecx
  2165df:	83 e6 03             	and    esi,0x3
  2165e2:	48 83 f8 03          	cmp    rax,0x3
  2165e6:	73 18                	jae    216600 <mergeInPlace+0x250>
  2165e8:	31 c0                	xor    eax,eax
    while (i < end) : (i += 1) {
  2165ea:	48 85 f6             	test   rsi,rsi
  2165ed:	0f 85 d5 00 00 00    	jne    2166c8 <mergeInPlace+0x318>
  2165f3:	e9 22 01 00 00       	jmp    21671a <mergeInPlace+0x36a>
  2165f8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  2165ff:	00 
        swap(T, &items[i], &items[items.len - i - 1]);
  216600:	48 29 f1             	sub    rcx,rsi
  216603:	4c 89 f0             	mov    rax,r14
  216606:	48 c1 e0 04          	shl    rax,0x4
  21660a:	48 8d 1c 02          	lea    rbx,[rdx+rax*1]
  21660e:	48 83 c3 30          	add    rbx,0x30
  216612:	4c 89 e0             	mov    rax,r12
  216615:	48 c1 e0 04          	shl    rax,0x4
  216619:	48 8d 2c 02          	lea    rbp,[rdx+rax*1]
  21661d:	48 83 c5 f0          	add    rbp,0xfffffffffffffff0
  216621:	31 c0                	xor    eax,eax
  216623:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21662a:	84 00 00 00 00 00 
    const tmp = a.*;
  216630:	c5 f8 10 43 d0       	vmovups xmm0,XMMWORD PTR [rbx-0x30]
  216635:	c5 f8 29 44 24 d8    	vmovaps XMMWORD PTR [rsp-0x28],xmm0
    a.* = b.*;
  21663b:	c5 f8 10 45 00       	vmovups xmm0,XMMWORD PTR [rbp+0x0]
  216640:	c5 f8 11 43 d0       	vmovups XMMWORD PTR [rbx-0x30],xmm0
    b.* = tmp;
  216645:	c5 f8 28 44 24 d8    	vmovaps xmm0,XMMWORD PTR [rsp-0x28]
  21664b:	c5 f8 11 45 00       	vmovups XMMWORD PTR [rbp+0x0],xmm0
    const tmp = a.*;
  216650:	c5 f8 10 43 e0       	vmovups xmm0,XMMWORD PTR [rbx-0x20]
  216655:	c5 f8 29 44 24 d8    	vmovaps XMMWORD PTR [rsp-0x28],xmm0
    a.* = b.*;
  21665b:	c5 f8 10 45 f0       	vmovups xmm0,XMMWORD PTR [rbp-0x10]
  216660:	c5 f8 11 43 e0       	vmovups XMMWORD PTR [rbx-0x20],xmm0
    b.* = tmp;
  216665:	c5 f8 28 44 24 d8    	vmovaps xmm0,XMMWORD PTR [rsp-0x28]
  21666b:	c5 f8 11 45 f0       	vmovups XMMWORD PTR [rbp-0x10],xmm0
    const tmp = a.*;
  216670:	c5 f8 10 43 f0       	vmovups xmm0,XMMWORD PTR [rbx-0x10]
  216675:	c5 f8 29 44 24 d8    	vmovaps XMMWORD PTR [rsp-0x28],xmm0
    a.* = b.*;
  21667b:	c5 f8 10 45 e0       	vmovups xmm0,XMMWORD PTR [rbp-0x20]
  216680:	c5 f8 11 43 f0       	vmovups XMMWORD PTR [rbx-0x10],xmm0
    b.* = tmp;
  216685:	c5 f8 28 44 24 d8    	vmovaps xmm0,XMMWORD PTR [rsp-0x28]
  21668b:	c5 f8 11 45 e0       	vmovups XMMWORD PTR [rbp-0x20],xmm0
    const tmp = a.*;
  216690:	c5 f8 10 03          	vmovups xmm0,XMMWORD PTR [rbx]
  216694:	c5 f8 29 44 24 d8    	vmovaps XMMWORD PTR [rsp-0x28],xmm0
    a.* = b.*;
  21669a:	c5 f8 10 45 d0       	vmovups xmm0,XMMWORD PTR [rbp-0x30]
  21669f:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
    b.* = tmp;
  2166a3:	c5 f8 28 44 24 d8    	vmovaps xmm0,XMMWORD PTR [rsp-0x28]
  2166a9:	c5 f8 11 45 d0       	vmovups XMMWORD PTR [rbp-0x30],xmm0
    while (i < end) : (i += 1) {
  2166ae:	48 83 c0 04          	add    rax,0x4
  2166b2:	48 83 c3 40          	add    rbx,0x40
  2166b6:	48 83 c5 c0          	add    rbp,0xffffffffffffffc0
  2166ba:	48 39 c1             	cmp    rcx,rax
  2166bd:	0f 85 6d ff ff ff    	jne    216630 <mergeInPlace+0x280>
  2166c3:	48 85 f6             	test   rsi,rsi
  2166c6:	74 52                	je     21671a <mergeInPlace+0x36a>
  2166c8:	4c 89 e1             	mov    rcx,r12
  2166cb:	48 29 c1             	sub    rcx,rax
  2166ce:	48 c1 e1 04          	shl    rcx,0x4
  2166d2:	48 01 d1             	add    rcx,rdx
  2166d5:	48 83 c1 f0          	add    rcx,0xfffffffffffffff0
  2166d9:	4c 01 f0             	add    rax,r14
  2166dc:	48 c1 e0 04          	shl    rax,0x4
  2166e0:	48 01 d0             	add    rax,rdx
  2166e3:	48 f7 de             	neg    rsi
  2166e6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  2166ed:	00 00 00 
    const tmp = a.*;
  2166f0:	c5 f8 10 00          	vmovups xmm0,XMMWORD PTR [rax]
  2166f4:	c5 f8 29 44 24 d8    	vmovaps XMMWORD PTR [rsp-0x28],xmm0
    a.* = b.*;
  2166fa:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  2166fe:	c5 f8 11 00          	vmovups XMMWORD PTR [rax],xmm0
    b.* = tmp;
  216702:	c5 f8 28 44 24 d8    	vmovaps xmm0,XMMWORD PTR [rsp-0x28]
  216708:	c5 f8 11 01          	vmovups XMMWORD PTR [rcx],xmm0
    while (i < end) : (i += 1) {
  21670c:	48 83 c1 f0          	add    rcx,0xfffffffffffffff0
  216710:	48 83 c0 10          	add    rax,0x10
  216714:	48 83 c6 01          	add    rsi,0x1
  216718:	75 d6                	jne    2166f0 <mergeInPlace+0x340>
    const end = items.len / 2;
  21671a:	4c 89 e9             	mov    rcx,r13
  21671d:	48 d1 e9             	shr    rcx,1
    while (i < end) : (i += 1) {
  216720:	0f 84 6a 01 00 00    	je     216890 <mergeInPlace+0x4e0>
    const tmp = a.*;
  216726:	c4 c1 78 10 03       	vmovups xmm0,XMMWORD PTR [r11]
  21672b:	c5 f8 29 44 24 d8    	vmovaps XMMWORD PTR [rsp-0x28],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  216731:	49 c1 e5 04          	shl    r13,0x4
    a.* = b.*;
  216735:	c4 81 78 10 44 2b f0 	vmovups xmm0,XMMWORD PTR [r11+r13*1-0x10]
  21673c:	c4 c1 78 11 03       	vmovups XMMWORD PTR [r11],xmm0
    b.* = tmp;
  216741:	c5 f8 28 44 24 d8    	vmovaps xmm0,XMMWORD PTR [rsp-0x28]
  216747:	c4 81 78 11 44 2b f0 	vmovups XMMWORD PTR [r11+r13*1-0x10],xmm0
    while (i < end) : (i += 1) {
  21674e:	48 83 f9 01          	cmp    rcx,0x1
  216752:	0f 84 38 01 00 00    	je     216890 <mergeInPlace+0x4e0>
        swap(T, &items[i], &items[items.len - i - 1]);
  216758:	8d 71 ff             	lea    esi,[rcx-0x1]
  21675b:	48 8d 41 fe          	lea    rax,[rcx-0x2]
  21675f:	83 e6 03             	and    esi,0x3
  216762:	48 83 f8 03          	cmp    rax,0x3
  216766:	73 13                	jae    21677b <mergeInPlace+0x3cb>
  216768:	b8 01 00 00 00       	mov    eax,0x1
    while (i < end) : (i += 1) {
  21676d:	48 85 f6             	test   rsi,rsi
  216770:	0f 85 c2 00 00 00    	jne    216838 <mergeInPlace+0x488>
  216776:	e9 15 01 00 00       	jmp    216890 <mergeInPlace+0x4e0>
        swap(T, &items[i], &items[items.len - i - 1]);
  21677b:	4c 89 e0             	mov    rax,r12
  21677e:	48 c1 e0 04          	shl    rax,0x4
  216782:	48 8d 2c 02          	lea    rbp,[rdx+rax*1]
  216786:	48 83 c5 e0          	add    rbp,0xffffffffffffffe0
  21678a:	4a 8d 1c 12          	lea    rbx,[rdx+r10*1]
  21678e:	48 83 c3 40          	add    rbx,0x40
  216792:	48 29 f1             	sub    rcx,rsi
  216795:	b8 01 00 00 00       	mov    eax,0x1
  21679a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
    const tmp = a.*;
  2167a0:	c5 f8 10 43 d0       	vmovups xmm0,XMMWORD PTR [rbx-0x30]
  2167a5:	c5 f8 29 44 24 d8    	vmovaps XMMWORD PTR [rsp-0x28],xmm0
    a.* = b.*;
  2167ab:	c5 f8 10 45 00       	vmovups xmm0,XMMWORD PTR [rbp+0x0]
  2167b0:	c5 f8 11 43 d0       	vmovups XMMWORD PTR [rbx-0x30],xmm0
    b.* = tmp;
  2167b5:	c5 f8 28 44 24 d8    	vmovaps xmm0,XMMWORD PTR [rsp-0x28]
  2167bb:	c5 f8 11 45 00       	vmovups XMMWORD PTR [rbp+0x0],xmm0
    const tmp = a.*;
  2167c0:	c5 f8 10 43 e0       	vmovups xmm0,XMMWORD PTR [rbx-0x20]
  2167c5:	c5 f8 29 44 24 d8    	vmovaps XMMWORD PTR [rsp-0x28],xmm0
    a.* = b.*;
  2167cb:	c5 f8 10 45 f0       	vmovups xmm0,XMMWORD PTR [rbp-0x10]
  2167d0:	c5 f8 11 43 e0       	vmovups XMMWORD PTR [rbx-0x20],xmm0
    b.* = tmp;
  2167d5:	c5 f8 28 44 24 d8    	vmovaps xmm0,XMMWORD PTR [rsp-0x28]
  2167db:	c5 f8 11 45 f0       	vmovups XMMWORD PTR [rbp-0x10],xmm0
    const tmp = a.*;
  2167e0:	c5 f8 10 43 f0       	vmovups xmm0,XMMWORD PTR [rbx-0x10]
  2167e5:	c5 f8 29 44 24 d8    	vmovaps XMMWORD PTR [rsp-0x28],xmm0
    a.* = b.*;
  2167eb:	c5 f8 10 45 e0       	vmovups xmm0,XMMWORD PTR [rbp-0x20]
  2167f0:	c5 f8 11 43 f0       	vmovups XMMWORD PTR [rbx-0x10],xmm0
    b.* = tmp;
  2167f5:	c5 f8 28 44 24 d8    	vmovaps xmm0,XMMWORD PTR [rsp-0x28]
  2167fb:	c5 f8 11 45 e0       	vmovups XMMWORD PTR [rbp-0x20],xmm0
    const tmp = a.*;
  216800:	c5 f8 10 03          	vmovups xmm0,XMMWORD PTR [rbx]
  216804:	c5 f8 29 44 24 d8    	vmovaps XMMWORD PTR [rsp-0x28],xmm0
    a.* = b.*;
  21680a:	c5 f8 10 45 d0       	vmovups xmm0,XMMWORD PTR [rbp-0x30]
  21680f:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
    b.* = tmp;
  216813:	c5 f8 28 44 24 d8    	vmovaps xmm0,XMMWORD PTR [rsp-0x28]
  216819:	c5 f8 11 45 d0       	vmovups XMMWORD PTR [rbp-0x30],xmm0
    while (i < end) : (i += 1) {
  21681e:	48 83 c0 04          	add    rax,0x4
  216822:	48 83 c5 c0          	add    rbp,0xffffffffffffffc0
  216826:	48 83 c3 40          	add    rbx,0x40
  21682a:	48 39 c1             	cmp    rcx,rax
  21682d:	0f 85 6d ff ff ff    	jne    2167a0 <mergeInPlace+0x3f0>
  216833:	48 85 f6             	test   rsi,rsi
  216836:	74 58                	je     216890 <mergeInPlace+0x4e0>
  216838:	4c 89 e1             	mov    rcx,r12
  21683b:	48 29 c1             	sub    rcx,rax
  21683e:	48 c1 e1 04          	shl    rcx,0x4
  216842:	48 01 d1             	add    rcx,rdx
  216845:	48 83 c1 f0          	add    rcx,0xfffffffffffffff0
  216849:	4c 01 f8             	add    rax,r15
  21684c:	48 c1 e0 04          	shl    rax,0x4
  216850:	48 01 d0             	add    rax,rdx
  216853:	48 f7 de             	neg    rsi
  216856:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  21685d:	00 00 00 
    const tmp = a.*;
  216860:	c5 f8 10 00          	vmovups xmm0,XMMWORD PTR [rax]
  216864:	c5 f8 29 44 24 d8    	vmovaps XMMWORD PTR [rsp-0x28],xmm0
    a.* = b.*;
  21686a:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  21686e:	c5 f8 11 00          	vmovups XMMWORD PTR [rax],xmm0
    b.* = tmp;
  216872:	c5 f8 28 44 24 d8    	vmovaps xmm0,XMMWORD PTR [rsp-0x28]
  216878:	c5 f8 11 01          	vmovups XMMWORD PTR [rcx],xmm0
    while (i < end) : (i += 1) {
  21687c:	48 83 c1 f0          	add    rcx,0xfffffffffffffff0
  216880:	48 83 c0 10          	add    rax,0x10
  216884:	48 83 c6 01          	add    rsi,0x1
  216888:	75 d6                	jne    216860 <mergeInPlace+0x4b0>
  21688a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
        if (B.end == mid) break;
  216890:	4d 39 e1             	cmp    r9,r12
  216893:	0f 84 ac 00 00 00    	je     216945 <mergeInPlace+0x595>
        const amount = mid - A.end;
  216899:	4c 89 e0             	mov    rax,r12
  21689c:	4c 29 f0             	sub    rax,r14
        A = Range.init(A.start + amount, B.start);
  21689f:	4c 01 f8             	add    rax,r15
        A.start = binaryLast(T, items, items[A.start], A, lessThan);
  2168a2:	48 8b 4c 24 f0       	mov    rcx,QWORD PTR [rsp-0x10]
  2168a7:	48 8b 11             	mov    rdx,QWORD PTR [rcx]
  2168aa:	4d 89 e7             	mov    r15,r12
    if (range.start >= range.end) return range.end;
  2168ad:	4c 39 e0             	cmp    rax,r12
  2168b0:	0f 83 80 00 00 00    	jae    216936 <mergeInPlace+0x586>
  2168b6:	49 89 c2             	mov    r10,rax
  2168b9:	49 c1 e2 04          	shl    r10,0x4
  2168bd:	49 01 d2             	add    r10,rdx
    var end = range.end - 1;
  2168c0:	4d 8d 44 24 ff       	lea    r8,[r12-0x1]
    while (start < end) {
  2168c5:	49 39 c0             	cmp    r8,rax
  2168c8:	76 3e                	jbe    216908 <mergeInPlace+0x558>
  2168ca:	49 8b 2a             	mov    rbp,QWORD PTR [r10]
  2168cd:	4c 89 c7             	mov    rdi,r8
        const mid = start + (end - start) / 2;
  2168d0:	48 89 fb             	mov    rbx,rdi
  2168d3:	48 29 c3             	sub    rbx,rax
  2168d6:	48 d1 eb             	shr    rbx,1
  2168d9:	48 8d 0c 03          	lea    rcx,[rbx+rax*1]
  2168dd:	48 89 ce             	mov    rsi,rcx
  2168e0:	48 c1 e6 04          	shl    rsi,0x4
  2168e4:	48 3b 2c 32          	cmp    rbp,QWORD PTR [rdx+rsi*1]
        if (!lessThan(value, items[mid])) {
  2168e8:	72 16                	jb     216900 <mergeInPlace+0x550>
  2168ea:	48 01 d8             	add    rax,rbx
  2168ed:	48 83 c0 01          	add    rax,0x1
    while (start < end) {
  2168f1:	48 39 c7             	cmp    rdi,rax
  2168f4:	77 da                	ja     2168d0 <mergeInPlace+0x520>
  2168f6:	eb 10                	jmp    216908 <mergeInPlace+0x558>
  2168f8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  2168ff:	00 
        if (!lessThan(value, items[mid])) {
  216900:	48 89 cf             	mov    rdi,rcx
    while (start < end) {
  216903:	48 39 c7             	cmp    rdi,rax
  216906:	77 c8                	ja     2168d0 <mergeInPlace+0x520>
    if (start == range.end - 1 and !lessThan(value, items[start])) {
  216908:	4c 39 c0             	cmp    rax,r8
  21690b:	75 23                	jne    216930 <mergeInPlace+0x580>
  21690d:	49 8b 0a             	mov    rcx,QWORD PTR [r10]
  216910:	49 c1 e0 04          	shl    r8,0x4
  216914:	45 31 ff             	xor    r15d,r15d
  216917:	4a 3b 0c 02          	cmp    rcx,QWORD PTR [rdx+r8*1]
  21691b:	41 0f 93 c7          	setae  r15b
  21691f:	eb 12                	jmp    216933 <mergeInPlace+0x583>
  216921:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  216928:	0f 1f 84 00 00 00 00 
  21692f:	00 
  216930:	45 31 ff             	xor    r15d,r15d
  216933:	49 01 c7             	add    r15,rax
  216936:	4d 89 e6             	mov    r14,r12
  216939:	4c 89 e1             	mov    rcx,r12
        if (A.length() == 0) break;
  21693c:	4d 39 fc             	cmp    r12,r15
  21693f:	0f 85 ab fa ff ff    	jne    2163f0 <mergeInPlace+0x40>
    if (A_arg.length() == 0 or B_arg.length() == 0) return;
  216945:	5b                   	pop    rbx
  216946:	41 5c                	pop    r12
  216948:	41 5d                	pop    r13
  21694a:	41 5e                	pop    r14
  21694c:	41 5f                	pop    r15
  21694e:	5d                   	pop    rbp
  21694f:	c3                   	ret    

0000000000216950 <FileOutStream_writeFn>:
    fn writeFn(out_stream: *Stream, bytes: []const u8) !void {
  216950:	53                   	push   rbx
  216951:	49 89 f0             	mov    r8,rsi
    while (index < bytes.len) {
  216954:	49 8b 50 08          	mov    rdx,QWORD PTR [r8+0x8]
  216958:	48 85 d2             	test   rdx,rdx
  21695b:	0f 84 98 00 00 00    	je     2169f9 <FileOutStream_writeFn+0xa9>
        return self.file.write(bytes);
  216961:	48 8b 47 f8          	mov    rax,QWORD PTR [rdi-0x8]
  216965:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  216968:	45 31 c9             	xor    r9d,r9d
  21696b:	41 ba 00 f0 ff 7f    	mov    r10d,0x7ffff000
  216971:	48 8d 1d 54 a4 fe ff 	lea    rbx,[rip+0xfffffffffffea454]        # 200dcc <app_mask+0xec>
  216978:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  21697f:	00 
        const amt_to_write = math.min(bytes.len - index, usize(max_bytes_len));
  216980:	4c 29 ca             	sub    rdx,r9
    return if (x < y) x else y;
  216983:	48 81 fa 00 f0 ff 7f 	cmp    rdx,0x7ffff000
  21698a:	49 0f 43 d2          	cmovae rdx,r10
  21698e:	49 8b 30             	mov    rsi,QWORD PTR [r8]
        const rc = posix.write(fd, bytes.ptr + index, amt_to_write);
  216991:	4c 01 ce             	add    rsi,r9
  216994:	b8 01 00 00 00       	mov    eax,0x1
  216999:	0f 05                	syscall 
  21699b:	48 89 c1             	mov    rcx,rax
  21699e:	48 81 f9 00 f0 ff ff 	cmp    rcx,0xfffffffffffff000
  2169a5:	77 39                	ja     2169e0 <FileOutStream_writeFn+0x90>
  2169a7:	31 d2                	xor    edx,edx
        if (write_err > 0) {
  2169a9:	48 83 fa 04          	cmp    rdx,0x4
  2169ad:	74 3d                	je     2169ec <FileOutStream_writeFn+0x9c>
  2169af:	48 83 fa 59          	cmp    rdx,0x59
  2169b3:	77 48                	ja     2169fd <FileOutStream_writeFn+0xad>
  2169b5:	66 b8 09 00          	mov    ax,0x9
  2169b9:	48 63 14 93          	movsxd rdx,DWORD PTR [rbx+rdx*4]
  2169bd:	48 01 da             	add    rdx,rbx
  2169c0:	ff e2                	jmp    rdx
        index += rc;
  2169c2:	49 01 c9             	add    r9,rcx
    while (index < bytes.len) {
  2169c5:	49 8b 50 08          	mov    rdx,QWORD PTR [r8+0x8]
  2169c9:	31 c0                	xor    eax,eax
  2169cb:	4c 39 ca             	cmp    rdx,r9
  2169ce:	77 b0                	ja     216980 <FileOutStream_writeFn+0x30>
  2169d0:	eb 25                	jmp    2169f7 <FileOutStream_writeFn+0xa7>
  2169d2:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  2169d9:	1f 84 00 00 00 00 00 
  2169e0:	48 89 ca             	mov    rdx,rcx
  2169e3:	48 f7 da             	neg    rdx
        if (write_err > 0) {
  2169e6:	48 83 fa 04          	cmp    rdx,0x4
  2169ea:	75 c3                	jne    2169af <FileOutStream_writeFn+0x5f>
    while (index < bytes.len) {
  2169ec:	49 8b 50 08          	mov    rdx,QWORD PTR [r8+0x8]
  2169f0:	4c 39 ca             	cmp    rdx,r9
  2169f3:	77 8b                	ja     216980 <FileOutStream_writeFn+0x30>
  2169f5:	31 c0                	xor    eax,eax
  2169f7:	5b                   	pop    rbx
  2169f8:	c3                   	ret    
  2169f9:	31 c0                	xor    eax,eax
  2169fb:	5b                   	pop    rbx
  2169fc:	c3                   	ret    
        if (write_err > 0) {
  2169fd:	48 83 fa 7a          	cmp    rdx,0x7a
  216a01:	75 06                	jne    216a09 <FileOutStream_writeFn+0xb9>
  216a03:	66 b8 0c 00          	mov    ax,0xc
  216a07:	5b                   	pop    rbx
  216a08:	c3                   	ret    
  216a09:	66 b8 03 00          	mov    ax,0x3
  216a0d:	5b                   	pop    rbx
  216a0e:	c3                   	ret    
  216a0f:	66 b8 10 00          	mov    ax,0x10
  216a13:	5b                   	pop    rbx
  216a14:	c3                   	ret    
  216a15:	66 b8 0e 00          	mov    ax,0xe
  216a19:	5b                   	pop    rbx
  216a1a:	c3                   	ret    
  216a1b:	66 b8 0a 00          	mov    ax,0xa
  216a1f:	5b                   	pop    rbx
  216a20:	c3                   	ret    
  216a21:	66 b8 0d 00          	mov    ax,0xd
  216a25:	5b                   	pop    rbx
  216a26:	c3                   	ret    
  216a27:	66 b8 0f 00          	mov    ax,0xf
  216a2b:	5b                   	pop    rbx
  216a2c:	c3                   	ret    
  216a2d:	66 b8 08 00          	mov    ax,0x8
  216a31:	5b                   	pop    rbx
  216a32:	c3                   	ret    
  216a33:	66 b8 0b 00          	mov    ax,0xb
  216a37:	5b                   	pop    rbx
  216a38:	c3                   	ret    
  216a39:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

0000000000216a40 <openSelfDebugInfo>:
            return Self{
  216a40:	55                   	push   rbp
  216a41:	41 57                	push   r15
  216a43:	41 56                	push   r14
  216a45:	41 55                	push   r13
  216a47:	41 54                	push   r12
  216a49:	53                   	push   rbx
  216a4a:	48 81 ec e8 05 00 00 	sub    rsp,0x5e8
  216a51:	c5 f8 57 c0          	vxorps xmm0,xmm0,xmm0
  216a55:	c5 f8 29 84 24 30 04 	vmovaps XMMWORD PTR [rsp+0x430],xmm0
  216a5c:	00 00 
  216a5e:	c5 f8 29 84 24 10 04 	vmovaps XMMWORD PTR [rsp+0x410],xmm0
  216a65:	00 00 
  216a67:	49 89 f4             	mov    r12,rsi
  216a6a:	49 89 fe             	mov    r14,rdi
            const st = try allocator.create(ElfStackTrace{
  216a6d:	c5 fc 10 05 53 14 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffff1453]        # 207ec8 <__unnamed_58>
  216a74:	ff 
  216a75:	c5 fc 11 84 24 70 05 	vmovups YMMWORD PTR [rsp+0x570],ymm0
  216a7c:	00 00 
  216a7e:	48 c7 84 24 40 04 00 	mov    QWORD PTR [rsp+0x440],0x0
  216a85:	00 00 00 00 00 
  216a8a:	c5 fc 10 05 56 14 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffff1456]        # 207ee8 <__unnamed_58+0x20>
  216a91:	ff 
  216a92:	c5 fc 11 84 24 90 05 	vmovups YMMWORD PTR [rsp+0x590],ymm0
  216a99:	00 00 
  216a9b:	48 c7 84 24 20 04 00 	mov    QWORD PTR [rsp+0x420],0x0
  216aa2:	00 00 00 00 00 
  216aa7:	c5 fe 6f 05 51 14 ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffff1451]        # 207f00 <__unnamed_58+0x38>
  216aae:	ff 
  216aaf:	c5 fe 7f 84 24 a8 05 	vmovdqu YMMWORD PTR [rsp+0x5a8],ymm0
  216ab6:	00 00 
  216ab8:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  216abf:	00 
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  216ac0:	ba c8 00 00 00       	mov    edx,0xc8
  216ac5:	b9 04 00 00 00       	mov    ecx,0x4
  216aca:	c5 f8 77             	vzeroupper 
  216acd:	41 ff 14 24          	call   QWORD PTR [r12]
  216ad1:	0f b7 84 24 f0 00 00 	movzx  eax,WORD PTR [rsp+0xf0]
  216ad8:	00 
  216ad9:	66 85 c0             	test   ax,ax
  216adc:	74 19                	je     216af7 <openSelfDebugInfo+0xb7>
  216ade:	66 41 89 06          	mov    WORD PTR [r14],ax
  216ae2:	48 8b 84 24 12 05 00 	mov    rax,QWORD PTR [rsp+0x512]
  216ae9:	00 
  216aea:	48 8b 8c 24 18 05 00 	mov    rcx,QWORD PTR [rsp+0x518]
  216af1:	00 
  216af2:	e9 60 0c 00 00       	jmp    217757 <openSelfDebugInfo+0xd17>
        assert(byte_slice.len == byte_count);
  216af7:	48 81 bc 24 00 01 00 	cmp    QWORD PTR [rsp+0x100],0xc8
  216afe:	00 c8 00 00 00 
    if (!ok) {
  216b03:	0f 85 9b 3f 00 00    	jne    21aaa4 <openSelfDebugInfo+0x4064>
  216b09:	48 8b ac 24 f8 00 00 	mov    rbp,QWORD PTR [rsp+0xf8]
  216b10:	00 
        ptr.* = init;
  216b11:	c5 fc 10 84 24 68 05 	vmovups ymm0,YMMWORD PTR [rsp+0x568]
  216b18:	00 00 
  216b1a:	c5 fe 6f 8c 24 88 05 	vmovdqu ymm1,YMMWORD PTR [rsp+0x588]
  216b21:	00 00 
  216b23:	c5 fe 6f 94 24 a8 05 	vmovdqu ymm2,YMMWORD PTR [rsp+0x5a8]
  216b2a:	00 00 
  216b2c:	c5 fe 6f 9c 24 c8 05 	vmovdqu ymm3,YMMWORD PTR [rsp+0x5c8]
  216b33:	00 00 
  216b35:	c5 fe 7f 5d 60       	vmovdqu YMMWORD PTR [rbp+0x60],ymm3
  216b3a:	c5 fe 7f 55 40       	vmovdqu YMMWORD PTR [rbp+0x40],ymm2
  216b3f:	c5 fe 7f 4d 20       	vmovdqu YMMWORD PTR [rbp+0x20],ymm1
  216b44:	c5 fc 11 45 00       	vmovups YMMWORD PTR [rbp+0x0],ymm0
  216b49:	48 c7 85 80 00 00 00 	mov    QWORD PTR [rbp+0x80],0x0
  216b50:	00 00 00 00 
  216b54:	48 8b 84 24 40 04 00 	mov    rax,QWORD PTR [rsp+0x440]
  216b5b:	00 
  216b5c:	48 89 85 98 00 00 00 	mov    QWORD PTR [rbp+0x98],rax
  216b63:	c5 f8 28 84 24 30 04 	vmovaps xmm0,XMMWORD PTR [rsp+0x430]
  216b6a:	00 00 
  216b6c:	c5 f8 11 85 88 00 00 	vmovups XMMWORD PTR [rbp+0x88],xmm0
  216b73:	00 
  216b74:	4c 89 a5 a0 00 00 00 	mov    QWORD PTR [rbp+0xa0],r12
  216b7b:	48 8b 84 24 20 04 00 	mov    rax,QWORD PTR [rsp+0x420]
  216b82:	00 
  216b83:	48 89 85 b8 00 00 00 	mov    QWORD PTR [rbp+0xb8],rax
  216b8a:	c5 f9 6f 84 24 10 04 	vmovdqa xmm0,XMMWORD PTR [rsp+0x410]
  216b91:	00 00 
  216b93:	c5 fa 7f 85 a8 00 00 	vmovdqu XMMWORD PTR [rbp+0xa8],xmm0
  216b9a:	00 
  216b9b:	4c 89 a5 c0 00 00 00 	mov    QWORD PTR [rbp+0xc0],r12
    return error.Unexpected;
}

pub fn openSelfExe() !os.File {
    switch (builtin.os) {
        Os.linux => return os.File.openReadC(c"/proc/self/exe"),
  216ba2:	48 8d 35 7d 29 ff ff 	lea    rsi,[rip+0xffffffffffff297d]        # 209526 <__unnamed_59>
  216ba9:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  216bb0:	00 
  216bb1:	c5 f8 77             	vzeroupper 
  216bb4:	e8 57 4d 00 00       	call   21b910 <File_openReadC>
  216bb9:	48 8b 9c 24 f0 00 00 	mov    rbx,QWORD PTR [rsp+0xf0]
  216bc0:	00 
            st.self_exe_file = try os.openSelfExe();
  216bc1:	66 85 db             	test   bx,bx
  216bc4:	74 3f                	je     216c05 <openSelfDebugInfo+0x1c5>
        self.freeFn(self, non_const_ptr[0..@sizeOf(@typeOf(ptr).Child)]);
  216bc6:	49 8b 44 24 10       	mov    rax,QWORD PTR [r12+0x10]
  216bcb:	48 89 ac 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rbp
  216bd2:	00 
  216bd3:	48 c7 84 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],0xc8
  216bda:	00 c8 00 00 00 
  216bdf:	48 8d b4 24 f0 00 00 	lea    rsi,[rsp+0xf0]
  216be6:	00 
  216be7:	4c 89 e7             	mov    rdi,r12
  216bea:	ff d0                	call   rax
  216bec:	66 41 89 1e          	mov    WORD PTR [r14],bx
  216bf0:	48 8b 84 24 04 05 00 	mov    rax,QWORD PTR [rsp+0x504]
  216bf7:	00 
  216bf8:	48 8b 8c 24 0a 05 00 	mov    rcx,QWORD PTR [rsp+0x50a]
  216bff:	00 
  216c00:	e9 52 0b 00 00       	jmp    217757 <openSelfDebugInfo+0xd17>
  216c05:	48 c1 eb 20          	shr    rbx,0x20
  216c09:	89 5d 00             	mov    DWORD PTR [rbp+0x0],ebx
            try st.elf.openFile(allocator, &st.self_exe_file);
  216c0c:	4c 8d 7d 08          	lea    r15,[rbp+0x8]
        elf.auto_close_stream = true;
    }

    /// Call close when done.
    pub fn openFile(elf: *Elf, allocator: *mem.Allocator, file: *os.File) !void {
        elf.allocator = allocator;
  216c10:	4c 89 65 50          	mov    QWORD PTR [rbp+0x50],r12
        elf.in_file = file;
  216c14:	48 89 6d 08          	mov    QWORD PTR [rbp+0x8],rbp
        elf.auto_close_stream = false;
  216c18:	c6 45 10 00          	mov    BYTE PTR [rbp+0x10],0x0

        var file_stream = io.FileInStream.init(elf.in_file);
  216c1c:	48 89 6c 24 50       	mov    QWORD PTR [rsp+0x50],rbp
  216c21:	48 8d 05 18 50 00 00 	lea    rax,[rip+0x5018]        # 21bc40 <FileInStream_readFn>
  216c28:	48 89 44 24 58       	mov    QWORD PTR [rsp+0x58],rax
  216c2d:	48 8d 84 24 70 02 00 	lea    rax,[rsp+0x270]
  216c34:	00 
        const in = &file_stream.stream;

        var magic: [4]u8 = undefined;
        try in.readNoEof(magic[0..]);
  216c35:	48 89 84 24 d8 03 00 	mov    QWORD PTR [rsp+0x3d8],rax
  216c3c:	00 
  216c3d:	48 c7 84 24 e0 03 00 	mov    QWORD PTR [rsp+0x3e0],0x4
  216c44:	00 04 00 00 00 
        return self.file.read(buffer);
  216c49:	48 8b 74 24 50       	mov    rsi,QWORD PTR [rsp+0x50]
  216c4e:	48 8d 9c 24 f0 00 00 	lea    rbx,[rsp+0xf0]
  216c55:	00 
  216c56:	48 8d 94 24 d8 03 00 	lea    rdx,[rsp+0x3d8]
  216c5d:	00 
  216c5e:	48 89 df             	mov    rdi,rbx
  216c61:	e8 aa 4e 00 00       	call   21bb10 <File_read>
  216c66:	44 0f b7 ac 24 f0 00 	movzx  r13d,WORD PTR [rsp+0xf0]
  216c6d:	00 00 
            const amt_read = try self.read(buf);
  216c6f:	66 45 85 ed          	test   r13w,r13w
  216c73:	75 17                	jne    216c8c <openSelfDebugInfo+0x24c>
  216c75:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  216c7c:	00 
  216c7d:	66 41 bd 1f 00       	mov    r13w,0x1f
            if (amt_read < buf.len) return error.EndOfStream;
  216c82:	48 3b 84 24 e0 03 00 	cmp    rax,QWORD PTR [rsp+0x3e0]
  216c89:	00 
  216c8a:	73 4e                	jae    216cda <openSelfDebugInfo+0x29a>
  216c8c:	66 45 85 ed          	test   r13w,r13w
  216c90:	0f 84 ec 06 00 00    	je     217382 <openSelfDebugInfo+0x942>
  216c96:	48 63 7d 00          	movsxd rdi,DWORD PTR [rbp+0x0]
  216c9a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
    return asm volatile ("syscall"
  216ca0:	b8 03 00 00 00       	mov    eax,0x3
  216ca5:	0f 05                	syscall 
            switch (err) {
  216ca7:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  216cab:	74 f3                	je     216ca0 <openSelfDebugInfo+0x260>
        /// Remove and return the first node in the list.
        ///
        /// Returns:
        ///     A pointer to the first node in the list.
        pub fn popFirst(list: *Self) ?*Node {
            const first = list.first orelse return null;
  216cad:	48 8b 05 74 f3 02 00 	mov    rax,QWORD PTR [rip+0x2f374]        # 246028 <emfile_promise_queue>
  216cb4:	48 85 c0             	test   rax,rax
  216cb7:	0f 84 3b 01 00 00    	je     216df8 <openSelfDebugInfo+0x3b8>
            if (node.prev) |prev_node| {
  216cbd:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  216cc0:	48 85 c9             	test   rcx,rcx
  216cc3:	0f 84 c4 00 00 00    	je     216d8d <openSelfDebugInfo+0x34d>
                prev_node.next = node.next;
  216cc9:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  216ccd:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  216cd1:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  216cd5:	e9 be 00 00 00       	jmp    216d98 <openSelfDebugInfo+0x358>
        if (b[index] != item) return false;
  216cda:	80 bc 24 70 02 00 00 	cmp    BYTE PTR [rsp+0x270],0x7f
  216ce1:	7f 
  216ce2:	0f 85 8b 06 00 00    	jne    217373 <openSelfDebugInfo+0x933>
  216ce8:	80 bc 24 71 02 00 00 	cmp    BYTE PTR [rsp+0x271],0x45
  216cef:	45 
  216cf0:	0f 85 7d 06 00 00    	jne    217373 <openSelfDebugInfo+0x933>
  216cf6:	80 bc 24 72 02 00 00 	cmp    BYTE PTR [rsp+0x272],0x4c
  216cfd:	4c 
  216cfe:	0f 85 6f 06 00 00    	jne    217373 <openSelfDebugInfo+0x933>
  216d04:	80 bc 24 73 02 00 00 	cmp    BYTE PTR [rsp+0x273],0x46
  216d0b:	46 
  216d0c:	0f 85 28 01 00 00    	jne    216e3a <openSelfDebugInfo+0x3fa>
  216d12:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  216d17:	48 8d 44 24 1f       	lea    rax,[rsp+0x1f]
            try self.readNoEof(result[0..]);
  216d1c:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  216d23:	00 
  216d24:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x1
  216d2b:	00 01 00 00 00 
  216d30:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  216d37:	00 
  216d38:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  216d3f:	00 
            return self.readFn(self, buffer);
  216d40:	ff 54 24 58          	call   QWORD PTR [rsp+0x58]
  216d44:	44 0f b7 ac 24 f0 00 	movzx  r13d,WORD PTR [rsp+0xf0]
  216d4b:	00 00 
            const amt_read = try self.read(buf);
  216d4d:	66 45 85 ed          	test   r13w,r13w
  216d51:	0f 85 35 ff ff ff    	jne    216c8c <openSelfDebugInfo+0x24c>
  216d57:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  216d5e:	00 
  216d5f:	66 41 bd 1f 00       	mov    r13w,0x1f
            if (amt_read < buf.len) return error.EndOfStream;
  216d64:	48 3b 84 24 a0 00 00 	cmp    rax,QWORD PTR [rsp+0xa0]
  216d6b:	00 
  216d6c:	0f 82 1a ff ff ff    	jb     216c8c <openSelfDebugInfo+0x24c>
            return result[0];
  216d72:	8a 44 24 1f          	mov    al,BYTE PTR [rsp+0x1f]
        if (!mem.eql(u8, magic, "\x7fELF")) return error.InvalidFormat;

        elf.is_64 = switch (try in.readByte()) {
  216d76:	3c 01                	cmp    al,0x1
  216d78:	0f 84 d0 00 00 00    	je     216e4e <openSelfDebugInfo+0x40e>
  216d7e:	3c 02                	cmp    al,0x2
  216d80:	0f 85 ed 05 00 00    	jne    217373 <openSelfDebugInfo+0x933>
  216d86:	b0 01                	mov    al,0x1
  216d88:	e9 c3 00 00 00       	jmp    216e50 <openSelfDebugInfo+0x410>
                list.first = node.next;
  216d8d:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  216d91:	48 89 0d 90 f2 02 00 	mov    QWORD PTR [rip+0x2f290],rcx        # 246028 <emfile_promise_queue>
            if (node.next) |next_node| {
  216d98:	48 85 c9             	test   rcx,rcx
  216d9b:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  216d9e:	48 8d 35 8b f2 02 00 	lea    rsi,[rip+0x2f28b]        # 246030 <emfile_promise_queue+0x8>
  216da5:	48 0f 45 f1          	cmovne rsi,rcx
  216da9:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  216dac:	48 83 05 84 f2 02 00 	add    QWORD PTR [rip+0x2f284],0xffffffffffffffff        # 246038 <emfile_promise_queue+0x10>
  216db3:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  216db4:	74 1e                	je     216dd4 <openSelfDebugInfo+0x394>
  216db6:	48 83 3d 6a f2 02 00 	cmp    QWORD PTR [rip+0x2f26a],0x0        # 246028 <emfile_promise_queue>
  216dbd:	00 
  216dbe:	0f 84 e0 3c 00 00    	je     21aaa4 <openSelfDebugInfo+0x4064>
  216dc4:	48 8b 0d 65 f2 02 00 	mov    rcx,QWORD PTR [rip+0x2f265]        # 246030 <emfile_promise_queue+0x8>
  216dcb:	48 85 c9             	test   rcx,rcx
  216dce:	0f 84 d0 3c 00 00    	je     21aaa4 <openSelfDebugInfo+0x4064>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  216dd4:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  216dd8:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  216ddc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  216de0:	48 89 c1             	mov    rcx,rax
  216de3:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  216de7:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  216ded:	75 f1                	jne    216de0 <openSelfDebugInfo+0x3a0>
  216def:	a8 01                	test   al,0x1
  216df1:	75 05                	jne    216df8 <openSelfDebugInfo+0x3b8>
  216df3:	c5 f8 77             	vzeroupper 
  216df6:	ff 17                	call   QWORD PTR [rdi]
        self.freeFn(self, non_const_ptr[0..@sizeOf(@typeOf(ptr).Child)]);
  216df8:	49 8b 44 24 10       	mov    rax,QWORD PTR [r12+0x10]
  216dfd:	48 89 ac 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rbp
  216e04:	00 
  216e05:	48 c7 84 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],0xc8
  216e0c:	00 c8 00 00 00 
  216e11:	48 8d b4 24 f0 00 00 	lea    rsi,[rsp+0xf0]
  216e18:	00 
  216e19:	4c 89 e7             	mov    rdi,r12
  216e1c:	c5 f8 77             	vzeroupper 
  216e1f:	ff d0                	call   rax
  216e21:	66 45 89 2e          	mov    WORD PTR [r14],r13w
  216e25:	48 8b 84 24 f6 04 00 	mov    rax,QWORD PTR [rsp+0x4f6]
  216e2c:	00 
  216e2d:	48 8b 8c 24 fc 04 00 	mov    rcx,QWORD PTR [rsp+0x4fc]
  216e34:	00 
  216e35:	e9 1d 09 00 00       	jmp    217757 <openSelfDebugInfo+0xd17>
  216e3a:	66 41 bd 20 00       	mov    r13w,0x20
  216e3f:	66 45 85 ed          	test   r13w,r13w
  216e43:	0f 85 4d fe ff ff    	jne    216c96 <openSelfDebugInfo+0x256>
  216e49:	e9 34 05 00 00       	jmp    217382 <openSelfDebugInfo+0x942>
  216e4e:	31 c0                	xor    eax,eax
  216e50:	88 45 11             	mov    BYTE PTR [rbp+0x11],al
            try self.readNoEof(result[0..]);
  216e53:	48 8d 44 24 1f       	lea    rax,[rsp+0x1f]
  216e58:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  216e5f:	00 
  216e60:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x1
  216e67:	00 01 00 00 00 
  216e6c:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  216e73:	00 
  216e74:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  216e7b:	00 
            return self.readFn(self, buffer);
  216e7c:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  216e81:	ff 54 24 58          	call   QWORD PTR [rsp+0x58]
  216e85:	44 0f b7 ac 24 f0 00 	movzx  r13d,WORD PTR [rsp+0xf0]
  216e8c:	00 00 
            const amt_read = try self.read(buf);
  216e8e:	66 45 85 ed          	test   r13w,r13w
  216e92:	0f 85 f4 fd ff ff    	jne    216c8c <openSelfDebugInfo+0x24c>
  216e98:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  216e9f:	00 
  216ea0:	66 41 bd 1f 00       	mov    r13w,0x1f
            if (amt_read < buf.len) return error.EndOfStream;
  216ea5:	48 3b 84 24 a0 00 00 	cmp    rax,QWORD PTR [rsp+0xa0]
  216eac:	00 
  216ead:	0f 82 d9 fd ff ff    	jb     216c8c <openSelfDebugInfo+0x24c>
            return result[0];
  216eb3:	8a 44 24 1f          	mov    al,BYTE PTR [rsp+0x1f]
            1 => false,
            2 => true,
            else => return error.InvalidFormat,
        };

        elf.endian = switch (try in.readByte()) {
  216eb7:	3c 01                	cmp    al,0x1
  216eb9:	74 0c                	je     216ec7 <openSelfDebugInfo+0x487>
  216ebb:	3c 02                	cmp    al,0x2
  216ebd:	0f 85 b0 04 00 00    	jne    217373 <openSelfDebugInfo+0x933>
  216ec3:	31 c0                	xor    eax,eax
  216ec5:	eb 02                	jmp    216ec9 <openSelfDebugInfo+0x489>
  216ec7:	b0 01                	mov    al,0x1
  216ec9:	48 8d 4d 12          	lea    rcx,[rbp+0x12]
  216ecd:	48 89 4c 24 68       	mov    QWORD PTR [rsp+0x68],rcx
  216ed2:	88 01                	mov    BYTE PTR [rcx],al
            try self.readNoEof(result[0..]);
  216ed4:	48 8d 44 24 1f       	lea    rax,[rsp+0x1f]
  216ed9:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  216ee0:	00 
  216ee1:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x1
  216ee8:	00 01 00 00 00 
  216eed:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  216ef4:	00 
  216ef5:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  216efc:	00 
            return self.readFn(self, buffer);
  216efd:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  216f02:	ff 54 24 58          	call   QWORD PTR [rsp+0x58]
  216f06:	44 0f b7 ac 24 f0 00 	movzx  r13d,WORD PTR [rsp+0xf0]
  216f0d:	00 00 
            const amt_read = try self.read(buf);
  216f0f:	66 45 85 ed          	test   r13w,r13w
  216f13:	0f 85 73 fd ff ff    	jne    216c8c <openSelfDebugInfo+0x24c>
  216f19:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  216f20:	00 
  216f21:	66 41 bd 1f 00       	mov    r13w,0x1f
            if (amt_read < buf.len) return error.EndOfStream;
  216f26:	48 3b 84 24 a0 00 00 	cmp    rax,QWORD PTR [rsp+0xa0]
  216f2d:	00 
  216f2e:	0f 82 58 fd ff ff    	jb     216c8c <openSelfDebugInfo+0x24c>
            2 => builtin.Endian.Big,
            else => return error.InvalidFormat,
        };

        const version_byte = try in.readByte();
        if (version_byte != 1) return error.InvalidFormat;
  216f34:	80 7c 24 1f 01       	cmp    BYTE PTR [rsp+0x1f],0x1
  216f39:	0f 85 34 04 00 00    	jne    217373 <openSelfDebugInfo+0x933>

        // skip over padding
        try elf.in_file.seekForward(9);
  216f3f:	49 8b 07             	mov    rax,QWORD PTR [r15]
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  216f42:	48 63 38             	movsxd rdi,DWORD PTR [rax]
    return asm volatile ("syscall"
  216f45:	b8 08 00 00 00       	mov    eax,0x8
  216f4a:	be 09 00 00 00       	mov    esi,0x9
  216f4f:	ba 01 00 00 00       	mov    edx,0x1
  216f54:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  216f56:	48 89 c2             	mov    rdx,rax
  216f59:	48 f7 da             	neg    rdx
  216f5c:	31 c9                	xor    ecx,ecx
  216f5e:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  216f64:	48 0f 47 ca          	cmova  rcx,rdx
                if (err > 0) {
  216f68:	48 83 f9 1d          	cmp    rcx,0x1d
  216f6c:	0f 87 1e 3b 00 00    	ja     21aa90 <openSelfDebugInfo+0x4050>
  216f72:	48 8d 05 bb 9f fe ff 	lea    rax,[rip+0xfffffffffffe9fbb]        # 200f34 <app_mask+0x254>
  216f79:	48 63 0c 88          	movsxd rcx,DWORD PTR [rax+rcx*4]
  216f7d:	48 01 c1             	add    rcx,rax
  216f80:	66 41 bd 03 00       	mov    r13w,0x3
  216f85:	ff e1                	jmp    rcx
  216f87:	66 41 bd 21 00       	mov    r13w,0x21
  216f8c:	66 45 85 ed          	test   r13w,r13w
  216f90:	0f 85 00 fd ff ff    	jne    216c96 <openSelfDebugInfo+0x256>
  216f96:	e9 e7 03 00 00       	jmp    217382 <openSelfDebugInfo+0x942>

        elf.file_type = switch (try in.readInt(elf.endian, u16)) {
  216f9b:	8a 45 12             	mov    al,BYTE PTR [rbp+0x12]
  216f9e:	88 44 24 40          	mov    BYTE PTR [rsp+0x40],al
  216fa2:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
            try self.readNoEof(bytes[0..]);
  216fa7:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  216fae:	00 
  216faf:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x2
  216fb6:	00 02 00 00 00 
  216fbb:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  216fc2:	00 
  216fc3:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  216fca:	00 
            return self.readFn(self, buffer);
  216fcb:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  216fd0:	ff 54 24 58          	call   QWORD PTR [rsp+0x58]
  216fd4:	44 0f b7 ac 24 f0 00 	movzx  r13d,WORD PTR [rsp+0xf0]
  216fdb:	00 00 
            const amt_read = try self.read(buf);
  216fdd:	66 45 85 ed          	test   r13w,r13w
  216fe1:	0f 85 a5 fc ff ff    	jne    216c8c <openSelfDebugInfo+0x24c>
  216fe7:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  216fee:	00 
  216fef:	66 41 bd 1f 00       	mov    r13w,0x1f
            if (amt_read < buf.len) return error.EndOfStream;
  216ff4:	48 3b 84 24 a0 00 00 	cmp    rax,QWORD PTR [rsp+0xa0]
  216ffb:	00 
  216ffc:	0f 82 8a fc ff ff    	jb     216c8c <openSelfDebugInfo+0x24c>
  217002:	0f b6 44 24 20       	movzx  eax,BYTE PTR [rsp+0x20]
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  217007:	0f b6 4c 24 21       	movzx  ecx,BYTE PTR [rsp+0x21]
  21700c:	89 ca                	mov    edx,ecx
  21700e:	c1 e2 08             	shl    edx,0x8
  217011:	09 c2                	or     edx,eax
                result = (result << 8) | b;
  217013:	c1 e0 08             	shl    eax,0x8
  217016:	09 c8                	or     eax,ecx
    switch (endian) {
  217018:	f6 44 24 40 01       	test   BYTE PTR [rsp+0x40],0x1
  21701d:	66 0f 45 c2          	cmovne ax,dx
  217021:	83 c0 ff             	add    eax,0xffffffff
  217024:	0f b7 c8             	movzx  ecx,ax
  217027:	83 f9 03             	cmp    ecx,0x3
  21702a:	0f 87 43 03 00 00    	ja     217373 <openSelfDebugInfo+0x933>
  217030:	24 03                	and    al,0x3
  217032:	88 45 13             	mov    BYTE PTR [rbp+0x13],al
            3 => FileType.Shared,
            4 => FileType.Core,
            else => return error.InvalidFormat,
        };

        elf.arch = switch (try in.readInt(elf.endian, u16)) {
  217035:	8a 45 12             	mov    al,BYTE PTR [rbp+0x12]
            try self.readNoEof(bytes[0..]);
  217038:	88 44 24 40          	mov    BYTE PTR [rsp+0x40],al
  21703c:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  217041:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  217048:	00 
  217049:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x2
  217050:	00 02 00 00 00 
  217055:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  21705c:	00 
  21705d:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  217064:	00 
            return self.readFn(self, buffer);
  217065:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  21706a:	ff 54 24 58          	call   QWORD PTR [rsp+0x58]
  21706e:	44 0f b7 ac 24 f0 00 	movzx  r13d,WORD PTR [rsp+0xf0]
  217075:	00 00 
            const amt_read = try self.read(buf);
  217077:	66 45 85 ed          	test   r13w,r13w
  21707b:	0f 85 0b fc ff ff    	jne    216c8c <openSelfDebugInfo+0x24c>
  217081:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  217088:	00 
  217089:	66 41 bd 1f 00       	mov    r13w,0x1f
            if (amt_read < buf.len) return error.EndOfStream;
  21708e:	48 3b 84 24 a0 00 00 	cmp    rax,QWORD PTR [rsp+0xa0]
  217095:	00 
  217096:	0f 82 f0 fb ff ff    	jb     216c8c <openSelfDebugInfo+0x24c>
  21709c:	0f b6 44 24 20       	movzx  eax,BYTE PTR [rsp+0x20]
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  2170a1:	0f b6 4c 24 21       	movzx  ecx,BYTE PTR [rsp+0x21]
  2170a6:	89 ca                	mov    edx,ecx
  2170a8:	c1 e2 08             	shl    edx,0x8
  2170ab:	09 c2                	or     edx,eax
                result = (result << 8) | b;
  2170ad:	c1 e0 08             	shl    eax,0x8
  2170b0:	09 c8                	or     eax,ecx
    switch (endian) {
  2170b2:	f6 44 24 40 01       	test   BYTE PTR [rsp+0x40],0x1
  2170b7:	66 0f 45 c2          	cmovne ax,dx
  2170bb:	8d 48 fe             	lea    ecx,[rax-0x2]
  2170be:	0f b7 c9             	movzx  ecx,cx
  2170c1:	83 f9 3c             	cmp    ecx,0x3c
  2170c4:	77 1b                	ja     2170e1 <openSelfDebugInfo+0x6a1>
  2170c6:	31 c0                	xor    eax,eax
  2170c8:	48 8d 15 dd 9e fe ff 	lea    rdx,[rip+0xfffffffffffe9edd]        # 200fac <app_mask+0x2cc>
  2170cf:	48 63 0c 8a          	movsxd rcx,DWORD PTR [rdx+rcx*4]
  2170d3:	48 01 d1             	add    rcx,rdx
  2170d6:	66 41 bd 20 00       	mov    r13w,0x20
  2170db:	ff e1                	jmp    rcx
  2170dd:	b0 01                	mov    al,0x1
  2170df:	eb 28                	jmp    217109 <openSelfDebugInfo+0x6c9>
  2170e1:	0f b7 c0             	movzx  eax,ax
  2170e4:	3d b7 00 00 00       	cmp    eax,0xb7
  2170e9:	0f 85 84 02 00 00    	jne    217373 <openSelfDebugInfo+0x933>
  2170ef:	b0 08                	mov    al,0x8
  2170f1:	eb 16                	jmp    217109 <openSelfDebugInfo+0x6c9>
  2170f3:	b0 07                	mov    al,0x7
  2170f5:	eb 12                	jmp    217109 <openSelfDebugInfo+0x6c9>
  2170f7:	b0 06                	mov    al,0x6
  2170f9:	eb 0e                	jmp    217109 <openSelfDebugInfo+0x6c9>
  2170fb:	b0 02                	mov    al,0x2
  2170fd:	eb 0a                	jmp    217109 <openSelfDebugInfo+0x6c9>
  2170ff:	b0 04                	mov    al,0x4
  217101:	eb 06                	jmp    217109 <openSelfDebugInfo+0x6c9>
  217103:	b0 03                	mov    al,0x3
  217105:	eb 02                	jmp    217109 <openSelfDebugInfo+0x6c9>
  217107:	b0 05                	mov    al,0x5
  217109:	24 0f                	and    al,0xf
  21710b:	88 45 14             	mov    BYTE PTR [rbp+0x14],al
            0x3E => Arch.x86_64,
            0xb7 => Arch.AArch64,
            else => return error.InvalidFormat,
        };

        const elf_version = try in.readInt(elf.endian, u32);
  21710e:	8a 45 12             	mov    al,BYTE PTR [rbp+0x12]
            try self.readNoEof(bytes[0..]);
  217111:	88 44 24 40          	mov    BYTE PTR [rsp+0x40],al
  217115:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  21711a:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  217121:	00 
  217122:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x4
  217129:	00 04 00 00 00 
  21712e:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  217135:	00 
  217136:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  21713d:	00 
            return self.readFn(self, buffer);
  21713e:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  217143:	ff 54 24 58          	call   QWORD PTR [rsp+0x58]
  217147:	44 0f b7 ac 24 f0 00 	movzx  r13d,WORD PTR [rsp+0xf0]
  21714e:	00 00 
            const amt_read = try self.read(buf);
  217150:	66 45 85 ed          	test   r13w,r13w
  217154:	0f 85 32 fb ff ff    	jne    216c8c <openSelfDebugInfo+0x24c>
  21715a:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  217161:	00 
  217162:	66 41 bd 1f 00       	mov    r13w,0x1f
            if (amt_read < buf.len) return error.EndOfStream;
  217167:	48 3b 84 24 a0 00 00 	cmp    rax,QWORD PTR [rsp+0xa0]
  21716e:	00 
  21716f:	0f 82 17 fb ff ff    	jb     216c8c <openSelfDebugInfo+0x24c>
  217175:	0f b6 44 24 20       	movzx  eax,BYTE PTR [rsp+0x20]
  21717a:	0f b6 4c 24 21       	movzx  ecx,BYTE PTR [rsp+0x21]
  21717f:	f6 44 24 40 01       	test   BYTE PTR [rsp+0x40],0x1
  217184:	74 23                	je     2171a9 <openSelfDebugInfo+0x769>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  217186:	c1 e1 08             	shl    ecx,0x8
  217189:	09 c1                	or     ecx,eax
  21718b:	0f b6 54 24 22       	movzx  edx,BYTE PTR [rsp+0x22]
  217190:	c1 e2 10             	shl    edx,0x10
  217193:	09 ca                	or     edx,ecx
  217195:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  21719a:	c1 e0 18             	shl    eax,0x18
  21719d:	09 d0                	or     eax,edx
        if (elf_version != 1) return error.InvalidFormat;
  21719f:	83 f8 01             	cmp    eax,0x1
  2171a2:	74 27                	je     2171cb <openSelfDebugInfo+0x78b>
  2171a4:	e9 ca 01 00 00       	jmp    217373 <openSelfDebugInfo+0x933>
                result = (result << 8) | b;
  2171a9:	c1 e0 08             	shl    eax,0x8
  2171ac:	09 c8                	or     eax,ecx
  2171ae:	c1 e0 08             	shl    eax,0x8
  2171b1:	0f b6 4c 24 22       	movzx  ecx,BYTE PTR [rsp+0x22]
  2171b6:	09 c1                	or     ecx,eax
  2171b8:	c1 e1 08             	shl    ecx,0x8
  2171bb:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  2171c0:	09 c8                	or     eax,ecx
  2171c2:	83 f8 01             	cmp    eax,0x1
  2171c5:	0f 85 a8 01 00 00    	jne    217373 <openSelfDebugInfo+0x933>
  2171cb:	8a 45 12             	mov    al,BYTE PTR [rbp+0x12]

        if (elf.is_64) {
  2171ce:	88 44 24 40          	mov    BYTE PTR [rsp+0x40],al
  2171d2:	80 7d 11 01          	cmp    BYTE PTR [rbp+0x11],0x1
  2171d6:	0f 85 e3 2b 00 00    	jne    219dbf <openSelfDebugInfo+0x337f>
            elf.entry_addr = try in.readInt(elf.endian, u64);
  2171dc:	0f b6 54 24 40       	movzx  edx,BYTE PTR [rsp+0x40]
  2171e1:	48 8d bc 24 68 04 00 	lea    rdi,[rsp+0x468]
  2171e8:	00 
  2171e9:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  2171ee:	e8 ed 47 00 00       	call   21b9e0 <InStream(ReadError)_readInt.45>
  2171f3:	44 0f b7 ac 24 68 04 	movzx  r13d,WORD PTR [rsp+0x468]
  2171fa:	00 00 
  2171fc:	66 45 85 ed          	test   r13w,r13w
  217200:	0f 85 86 fa ff ff    	jne    216c8c <openSelfDebugInfo+0x24c>
  217206:	48 8b 84 24 70 04 00 	mov    rax,QWORD PTR [rsp+0x470]
  21720d:	00 
  21720e:	48 89 45 18          	mov    QWORD PTR [rbp+0x18],rax
            elf.program_header_offset = try in.readInt(elf.endian, u64);
  217212:	0f b6 55 12          	movzx  edx,BYTE PTR [rbp+0x12]
  217216:	48 8d bc 24 c0 02 00 	lea    rdi,[rsp+0x2c0]
  21721d:	00 
  21721e:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  217223:	e8 b8 47 00 00       	call   21b9e0 <InStream(ReadError)_readInt.45>
  217228:	44 0f b7 ac 24 c0 02 	movzx  r13d,WORD PTR [rsp+0x2c0]
  21722f:	00 00 
  217231:	66 45 85 ed          	test   r13w,r13w
  217235:	0f 85 51 fa ff ff    	jne    216c8c <openSelfDebugInfo+0x24c>
  21723b:	48 8b 84 24 c8 02 00 	mov    rax,QWORD PTR [rsp+0x2c8]
  217242:	00 
  217243:	48 89 45 20          	mov    QWORD PTR [rbp+0x20],rax
            elf.section_header_offset = try in.readInt(elf.endian, u64);
  217247:	0f b6 55 12          	movzx  edx,BYTE PTR [rbp+0x12]
  21724b:	48 8d bc 24 88 02 00 	lea    rdi,[rsp+0x288]
  217252:	00 
  217253:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  217258:	e8 83 47 00 00       	call   21b9e0 <InStream(ReadError)_readInt.45>
  21725d:	44 0f b7 ac 24 88 02 	movzx  r13d,WORD PTR [rsp+0x288]
  217264:	00 00 
  217266:	66 45 85 ed          	test   r13w,r13w
  21726a:	0f 85 1c fa ff ff    	jne    216c8c <openSelfDebugInfo+0x24c>
  217270:	48 8b 84 24 90 02 00 	mov    rax,QWORD PTR [rsp+0x290]
  217277:	00 
  217278:	48 89 45 28          	mov    QWORD PTR [rbp+0x28],rax
            elf.program_header_offset = u64(try in.readInt(elf.endian, u32));
            elf.section_header_offset = u64(try in.readInt(elf.endian, u32));
        }

        // skip over flags
        try elf.in_file.seekForward(4);
  21727c:	49 8b 07             	mov    rax,QWORD PTR [r15]
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  21727f:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  217282:	b8 08 00 00 00       	mov    eax,0x8
  217287:	be 04 00 00 00       	mov    esi,0x4
  21728c:	ba 01 00 00 00       	mov    edx,0x1
  217291:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  217293:	48 89 c2             	mov    rdx,rax
  217296:	48 f7 da             	neg    rdx
  217299:	31 c9                	xor    ecx,ecx
  21729b:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  2172a1:	48 0f 47 ca          	cmova  rcx,rdx
  2172a5:	48 83 f9 1d          	cmp    rcx,0x1d
  2172a9:	0f 87 e1 37 00 00    	ja     21aa90 <openSelfDebugInfo+0x4050>
  2172af:	48 8d 05 ea 9d fe ff 	lea    rax,[rip+0xfffffffffffe9dea]        # 2010a0 <app_mask+0x3c0>
  2172b6:	48 63 0c 88          	movsxd rcx,DWORD PTR [rax+rcx*4]
  2172ba:	48 01 c1             	add    rcx,rax
  2172bd:	66 41 bd 03 00       	mov    r13w,0x3
  2172c2:	ff e1                	jmp    rcx

        const header_size = try in.readInt(elf.endian, u16);
  2172c4:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  2172c9:	8a 00                	mov    al,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  2172cb:	88 44 24 40          	mov    BYTE PTR [rsp+0x40],al
  2172cf:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  2172d4:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  2172db:	00 
  2172dc:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x2
  2172e3:	00 02 00 00 00 
  2172e8:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  2172ef:	00 
  2172f0:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  2172f7:	00 
            return self.readFn(self, buffer);
  2172f8:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  2172fd:	ff 54 24 58          	call   QWORD PTR [rsp+0x58]
  217301:	44 0f b7 ac 24 f0 00 	movzx  r13d,WORD PTR [rsp+0xf0]
  217308:	00 00 
            const amt_read = try self.read(buf);
  21730a:	66 45 85 ed          	test   r13w,r13w
  21730e:	0f 85 78 f9 ff ff    	jne    216c8c <openSelfDebugInfo+0x24c>
  217314:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  21731b:	00 
  21731c:	66 41 bd 1f 00       	mov    r13w,0x1f
            if (amt_read < buf.len) return error.EndOfStream;
  217321:	48 3b 84 24 a0 00 00 	cmp    rax,QWORD PTR [rsp+0xa0]
  217328:	00 
  217329:	0f 82 5d f9 ff ff    	jb     216c8c <openSelfDebugInfo+0x24c>
  21732f:	0f b6 44 24 20       	movzx  eax,BYTE PTR [rsp+0x20]
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  217334:	0f b6 4c 24 21       	movzx  ecx,BYTE PTR [rsp+0x21]
  217339:	89 ca                	mov    edx,ecx
  21733b:	c1 e2 08             	shl    edx,0x8
  21733e:	09 c2                	or     edx,eax
                result = (result << 8) | b;
  217340:	c1 e0 08             	shl    eax,0x8
  217343:	09 c8                	or     eax,ecx
    switch (endian) {
  217345:	f6 44 24 40 01       	test   BYTE PTR [rsp+0x40],0x1
  21734a:	66 0f 45 c2          	cmovne ax,dx
        if ((elf.is_64 and header_size != 64) or (!elf.is_64 and header_size != 52)) {
  21734e:	8a 4d 11             	mov    cl,BYTE PTR [rbp+0x11]
  217351:	80 f9 01             	cmp    cl,0x1
  217354:	75 08                	jne    21735e <openSelfDebugInfo+0x91e>
  217356:	0f b7 d0             	movzx  edx,ax
  217359:	83 fa 40             	cmp    edx,0x40
  21735c:	75 15                	jne    217373 <openSelfDebugInfo+0x933>
  21735e:	0f b7 c0             	movzx  eax,ax
  217361:	83 f8 34             	cmp    eax,0x34
  217364:	0f 84 65 2c 00 00    	je     219fcf <openSelfDebugInfo+0x358f>
  21736a:	80 f1 01             	xor    cl,0x1
  21736d:	0f 84 5c 2c 00 00    	je     219fcf <openSelfDebugInfo+0x358f>
  217373:	66 41 bd 20 00       	mov    r13w,0x20
  217378:	66 45 85 ed          	test   r13w,r13w
  21737c:	0f 85 14 f9 ff ff    	jne    216c96 <openSelfDebugInfo+0x256>
            st.debug_info = (try st.elf.findSection(".debug_info")) orelse return error.MissingDebugInfo;
  217382:	48 8d 15 8f e8 02 00 	lea    rdx,[rip+0x2e88f]        # 245c18 <__unnamed_60>
  217389:	48 8d bc 24 40 03 00 	lea    rdi,[rsp+0x340]
  217390:	00 
  217391:	4c 89 fe             	mov    rsi,r15
  217394:	c5 f8 77             	vzeroupper 
  217397:	e8 34 43 00 00       	call   21b6d0 <Elf_findSection>
  21739c:	66 83 bc 24 40 03 00 	cmp    WORD PTR [rsp+0x340],0x0
  2173a3:	00 00 
  2173a5:	0f 84 7f 00 00 00    	je     21742a <openSelfDebugInfo+0x9ea>
        const bytes = @sliceToBytes(memory);
  2173ab:	48 8b 45 48          	mov    rax,QWORD PTR [rbp+0x48]
  2173af:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  2173b3:	74 26                	je     2173db <openSelfDebugInfo+0x99b>
  2173b5:	48 8b 7d 50          	mov    rdi,QWORD PTR [rbp+0x50]
        const bytes = @sliceToBytes(memory);
  2173b9:	48 8b 4d 40          	mov    rcx,QWORD PTR [rbp+0x40]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  2173bd:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  2173c1:	48 89 8c 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rcx
  2173c8:	00 
  2173c9:	48 89 84 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],rax
  2173d0:	00 
  2173d1:	48 8d b4 24 f0 00 00 	lea    rsi,[rsp+0xf0]
  2173d8:	00 
  2173d9:	ff d2                	call   rdx
    }

    pub fn close(elf: *Elf) void {
        elf.allocator.free(elf.section_headers);

        if (elf.auto_close_stream) elf.in_file.close();
  2173db:	80 7d 10 01          	cmp    BYTE PTR [rbp+0x10],0x1
  2173df:	0f 85 90 02 00 00    	jne    217675 <openSelfDebugInfo+0xc35>
  2173e5:	49 8b 07             	mov    rax,QWORD PTR [r15]
  2173e8:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  2173eb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
    return asm volatile ("syscall"
  2173f0:	b8 03 00 00 00       	mov    eax,0x3
  2173f5:	0f 05                	syscall 
            switch (err) {
  2173f7:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  2173fb:	74 f3                	je     2173f0 <openSelfDebugInfo+0x9b0>
            const first = list.first orelse return null;
  2173fd:	48 8b 05 24 ec 02 00 	mov    rax,QWORD PTR [rip+0x2ec24]        # 246028 <emfile_promise_queue>
  217404:	48 85 c0             	test   rax,rax
  217407:	0f 84 68 02 00 00    	je     217675 <openSelfDebugInfo+0xc35>
            if (node.prev) |prev_node| {
  21740d:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  217410:	48 85 c9             	test   rcx,rcx
  217413:	0f 84 f5 01 00 00    	je     21760e <openSelfDebugInfo+0xbce>
                prev_node.next = node.next;
  217419:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  21741d:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  217421:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  217425:	e9 ef 01 00 00       	jmp    217619 <openSelfDebugInfo+0xbd9>
  21742a:	48 8b 84 24 48 03 00 	mov    rax,QWORD PTR [rsp+0x348]
  217431:	00 
  217432:	48 85 c0             	test   rax,rax
  217435:	0f 84 a4 00 00 00    	je     2174df <openSelfDebugInfo+0xa9f>
  21743b:	48 89 45 60          	mov    QWORD PTR [rbp+0x60],rax
            st.debug_abbrev = (try st.elf.findSection(".debug_abbrev")) orelse return error.MissingDebugInfo;
  21743f:	48 8d 15 e2 e7 02 00 	lea    rdx,[rip+0x2e7e2]        # 245c28 <__unnamed_61>
  217446:	48 8d bc 24 30 03 00 	lea    rdi,[rsp+0x330]
  21744d:	00 
  21744e:	4c 89 fe             	mov    rsi,r15
  217451:	e8 7a 42 00 00       	call   21b6d0 <Elf_findSection>
  217456:	66 83 bc 24 30 03 00 	cmp    WORD PTR [rsp+0x330],0x0
  21745d:	00 00 
  21745f:	0f 84 f4 00 00 00    	je     217559 <openSelfDebugInfo+0xb19>
        const bytes = @sliceToBytes(memory);
  217465:	48 8b 45 48          	mov    rax,QWORD PTR [rbp+0x48]
  217469:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  21746d:	74 26                	je     217495 <openSelfDebugInfo+0xa55>
  21746f:	48 8b 7d 50          	mov    rdi,QWORD PTR [rbp+0x50]
        const bytes = @sliceToBytes(memory);
  217473:	48 8b 4d 40          	mov    rcx,QWORD PTR [rbp+0x40]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  217477:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  21747b:	48 89 8c 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rcx
  217482:	00 
  217483:	48 89 84 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],rax
  21748a:	00 
  21748b:	48 8d b4 24 f0 00 00 	lea    rsi,[rsp+0xf0]
  217492:	00 
  217493:	ff d2                	call   rdx
  217495:	80 7d 10 01          	cmp    BYTE PTR [rbp+0x10],0x1
  217499:	0f 85 68 04 00 00    	jne    217907 <openSelfDebugInfo+0xec7>
  21749f:	49 8b 07             	mov    rax,QWORD PTR [r15]
  2174a2:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  2174a5:	b8 03 00 00 00       	mov    eax,0x3
  2174aa:	0f 05                	syscall 
  2174ac:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  2174b0:	74 f3                	je     2174a5 <openSelfDebugInfo+0xa65>
            const first = list.first orelse return null;
  2174b2:	48 8b 05 6f eb 02 00 	mov    rax,QWORD PTR [rip+0x2eb6f]        # 246028 <emfile_promise_queue>
  2174b9:	48 85 c0             	test   rax,rax
  2174bc:	0f 84 45 04 00 00    	je     217907 <openSelfDebugInfo+0xec7>
            if (node.prev) |prev_node| {
  2174c2:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  2174c5:	48 85 c9             	test   rcx,rcx
  2174c8:	0f 84 d5 03 00 00    	je     2178a3 <openSelfDebugInfo+0xe63>
                prev_node.next = node.next;
  2174ce:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  2174d2:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  2174d6:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  2174da:	e9 cf 03 00 00       	jmp    2178ae <openSelfDebugInfo+0xe6e>
        const bytes = @sliceToBytes(memory);
  2174df:	48 8b 45 48          	mov    rax,QWORD PTR [rbp+0x48]
  2174e3:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  2174e7:	74 26                	je     21750f <openSelfDebugInfo+0xacf>
  2174e9:	48 8b 7d 50          	mov    rdi,QWORD PTR [rbp+0x50]
        const bytes = @sliceToBytes(memory);
  2174ed:	48 8b 4d 40          	mov    rcx,QWORD PTR [rbp+0x40]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  2174f1:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  2174f5:	48 89 8c 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rcx
  2174fc:	00 
  2174fd:	48 89 84 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],rax
  217504:	00 
  217505:	48 8d b4 24 f0 00 00 	lea    rsi,[rsp+0xf0]
  21750c:	00 
  21750d:	ff d2                	call   rdx
  21750f:	80 7d 10 01          	cmp    BYTE PTR [rbp+0x10],0x1
  217513:	0f 85 35 05 00 00    	jne    217a4e <openSelfDebugInfo+0x100e>
  217519:	49 8b 07             	mov    rax,QWORD PTR [r15]
  21751c:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  21751f:	b8 03 00 00 00       	mov    eax,0x3
  217524:	0f 05                	syscall 
  217526:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  21752a:	74 f3                	je     21751f <openSelfDebugInfo+0xadf>
            const first = list.first orelse return null;
  21752c:	48 8b 05 f5 ea 02 00 	mov    rax,QWORD PTR [rip+0x2eaf5]        # 246028 <emfile_promise_queue>
  217533:	48 85 c0             	test   rax,rax
  217536:	0f 84 12 05 00 00    	je     217a4e <openSelfDebugInfo+0x100e>
            if (node.prev) |prev_node| {
  21753c:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  21753f:	48 85 c9             	test   rcx,rcx
  217542:	0f 84 a2 04 00 00    	je     2179ea <openSelfDebugInfo+0xfaa>
                prev_node.next = node.next;
  217548:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  21754c:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  217550:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  217554:	e9 9c 04 00 00       	jmp    2179f5 <openSelfDebugInfo+0xfb5>
  217559:	48 8b 84 24 38 03 00 	mov    rax,QWORD PTR [rsp+0x338]
  217560:	00 
  217561:	48 85 c0             	test   rax,rax
  217564:	0f 84 0a 02 00 00    	je     217774 <openSelfDebugInfo+0xd34>
  21756a:	48 89 45 68          	mov    QWORD PTR [rbp+0x68],rax
            st.debug_str = (try st.elf.findSection(".debug_str")) orelse return error.MissingDebugInfo;
  21756e:	48 8d 15 c3 e6 02 00 	lea    rdx,[rip+0x2e6c3]        # 245c38 <__unnamed_62>
  217575:	48 8d bc 24 20 03 00 	lea    rdi,[rsp+0x320]
  21757c:	00 
  21757d:	4c 89 fe             	mov    rsi,r15
  217580:	e8 4b 41 00 00       	call   21b6d0 <Elf_findSection>
  217585:	66 83 bc 24 20 03 00 	cmp    WORD PTR [rsp+0x320],0x0
  21758c:	00 00 
  21758e:	0f 84 5a 02 00 00    	je     2177ee <openSelfDebugInfo+0xdae>
        const bytes = @sliceToBytes(memory);
  217594:	48 8b 45 48          	mov    rax,QWORD PTR [rbp+0x48]
  217598:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  21759c:	74 26                	je     2175c4 <openSelfDebugInfo+0xb84>
  21759e:	48 8b 7d 50          	mov    rdi,QWORD PTR [rbp+0x50]
        const bytes = @sliceToBytes(memory);
  2175a2:	48 8b 4d 40          	mov    rcx,QWORD PTR [rbp+0x40]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  2175a6:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  2175aa:	48 89 8c 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rcx
  2175b1:	00 
  2175b2:	48 89 84 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],rax
  2175b9:	00 
  2175ba:	48 8d b4 24 f0 00 00 	lea    rsi,[rsp+0xf0]
  2175c1:	00 
  2175c2:	ff d2                	call   rdx
  2175c4:	80 7d 10 01          	cmp    BYTE PTR [rbp+0x10],0x1
  2175c8:	0f 85 f0 06 00 00    	jne    217cbe <openSelfDebugInfo+0x127e>
  2175ce:	49 8b 07             	mov    rax,QWORD PTR [r15]
  2175d1:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  2175d4:	b8 03 00 00 00       	mov    eax,0x3
  2175d9:	0f 05                	syscall 
  2175db:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  2175df:	74 f3                	je     2175d4 <openSelfDebugInfo+0xb94>
            const first = list.first orelse return null;
  2175e1:	48 8b 05 40 ea 02 00 	mov    rax,QWORD PTR [rip+0x2ea40]        # 246028 <emfile_promise_queue>
  2175e8:	48 85 c0             	test   rax,rax
  2175eb:	0f 84 cd 06 00 00    	je     217cbe <openSelfDebugInfo+0x127e>
            if (node.prev) |prev_node| {
  2175f1:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  2175f4:	48 85 c9             	test   rcx,rcx
  2175f7:	0f 84 5d 06 00 00    	je     217c5a <openSelfDebugInfo+0x121a>
                prev_node.next = node.next;
  2175fd:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  217601:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  217605:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  217609:	e9 57 06 00 00       	jmp    217c65 <openSelfDebugInfo+0x1225>
                list.first = node.next;
  21760e:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  217612:	48 89 0d 0f ea 02 00 	mov    QWORD PTR [rip+0x2ea0f],rcx        # 246028 <emfile_promise_queue>
            if (node.next) |next_node| {
  217619:	48 85 c9             	test   rcx,rcx
  21761c:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  21761f:	48 8d 35 0a ea 02 00 	lea    rsi,[rip+0x2ea0a]        # 246030 <emfile_promise_queue+0x8>
  217626:	48 0f 45 f1          	cmovne rsi,rcx
  21762a:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  21762d:	48 83 05 03 ea 02 00 	add    QWORD PTR [rip+0x2ea03],0xffffffffffffffff        # 246038 <emfile_promise_queue+0x10>
  217634:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  217635:	74 1e                	je     217655 <openSelfDebugInfo+0xc15>
  217637:	48 83 3d e9 e9 02 00 	cmp    QWORD PTR [rip+0x2e9e9],0x0        # 246028 <emfile_promise_queue>
  21763e:	00 
  21763f:	0f 84 5f 34 00 00    	je     21aaa4 <openSelfDebugInfo+0x4064>
  217645:	48 8b 0d e4 e9 02 00 	mov    rcx,QWORD PTR [rip+0x2e9e4]        # 246030 <emfile_promise_queue+0x8>
  21764c:	48 85 c9             	test   rcx,rcx
  21764f:	0f 84 4f 34 00 00    	je     21aaa4 <openSelfDebugInfo+0x4064>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  217655:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  217659:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  21765d:	0f 1f 00             	nop    DWORD PTR [rax]
  217660:	48 89 c1             	mov    rcx,rax
  217663:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  217667:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  21766d:	75 f1                	jne    217660 <openSelfDebugInfo+0xc20>
  21766f:	a8 01                	test   al,0x1
  217671:	75 02                	jne    217675 <openSelfDebugInfo+0xc35>
  217673:	ff 17                	call   QWORD PTR [rdi]
  217675:	48 63 7d 00          	movsxd rdi,DWORD PTR [rbp+0x0]
  217679:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  217680:	b8 03 00 00 00       	mov    eax,0x3
  217685:	0f 05                	syscall 
            switch (err) {
  217687:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  21768b:	74 f3                	je     217680 <openSelfDebugInfo+0xc40>
            const first = list.first orelse return null;
  21768d:	48 8b 05 94 e9 02 00 	mov    rax,QWORD PTR [rip+0x2e994]        # 246028 <emfile_promise_queue>
  217694:	48 85 c0             	test   rax,rax
  217697:	74 7c                	je     217715 <openSelfDebugInfo+0xcd5>
            if (node.prev) |prev_node| {
  217699:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  21769c:	48 85 c9             	test   rcx,rcx
  21769f:	74 0e                	je     2176af <openSelfDebugInfo+0xc6f>
                prev_node.next = node.next;
  2176a1:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  2176a5:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  2176a9:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  2176ad:	eb 0b                	jmp    2176ba <openSelfDebugInfo+0xc7a>
                list.first = node.next;
  2176af:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  2176b3:	48 89 0d 6e e9 02 00 	mov    QWORD PTR [rip+0x2e96e],rcx        # 246028 <emfile_promise_queue>
            if (node.next) |next_node| {
  2176ba:	48 85 c9             	test   rcx,rcx
  2176bd:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  2176c0:	48 8d 35 69 e9 02 00 	lea    rsi,[rip+0x2e969]        # 246030 <emfile_promise_queue+0x8>
  2176c7:	48 0f 45 f1          	cmovne rsi,rcx
  2176cb:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  2176ce:	48 83 05 62 e9 02 00 	add    QWORD PTR [rip+0x2e962],0xffffffffffffffff        # 246038 <emfile_promise_queue+0x10>
  2176d5:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  2176d6:	74 1e                	je     2176f6 <openSelfDebugInfo+0xcb6>
  2176d8:	48 83 3d 48 e9 02 00 	cmp    QWORD PTR [rip+0x2e948],0x0        # 246028 <emfile_promise_queue>
  2176df:	00 
  2176e0:	0f 84 be 33 00 00    	je     21aaa4 <openSelfDebugInfo+0x4064>
  2176e6:	48 8b 0d 43 e9 02 00 	mov    rcx,QWORD PTR [rip+0x2e943]        # 246030 <emfile_promise_queue+0x8>
  2176ed:	48 85 c9             	test   rcx,rcx
  2176f0:	0f 84 ae 33 00 00    	je     21aaa4 <openSelfDebugInfo+0x4064>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  2176f6:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  2176fa:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  2176fe:	66 90                	xchg   ax,ax
  217700:	48 89 c1             	mov    rcx,rax
  217703:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  217707:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  21770d:	75 f1                	jne    217700 <openSelfDebugInfo+0xcc0>
  21770f:	a8 01                	test   al,0x1
  217711:	75 02                	jne    217715 <openSelfDebugInfo+0xcd5>
  217713:	ff 17                	call   QWORD PTR [rdi]
        self.freeFn(self, non_const_ptr[0..@sizeOf(@typeOf(ptr).Child)]);
  217715:	49 8b 44 24 10       	mov    rax,QWORD PTR [r12+0x10]
  21771a:	48 89 ac 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rbp
  217721:	00 
  217722:	48 c7 84 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],0xc8
  217729:	00 c8 00 00 00 
  21772e:	48 8d b4 24 f0 00 00 	lea    rsi,[rsp+0xf0]
  217735:	00 
  217736:	4c 89 e7             	mov    rdi,r12
  217739:	ff d0                	call   rax
            st.debug_info = (try st.elf.findSection(".debug_info")) orelse return error.MissingDebugInfo;
  21773b:	0f b7 84 24 40 03 00 	movzx  eax,WORD PTR [rsp+0x340]
  217742:	00 
  217743:	66 41 89 06          	mov    WORD PTR [r14],ax
  217747:	48 8b 84 24 e8 04 00 	mov    rax,QWORD PTR [rsp+0x4e8]
  21774e:	00 
  21774f:	48 8b 8c 24 ee 04 00 	mov    rcx,QWORD PTR [rsp+0x4ee]
  217756:	00 
  217757:	49 89 4e 08          	mov    QWORD PTR [r14+0x8],rcx
  21775b:	49 89 46 02          	mov    QWORD PTR [r14+0x2],rax
  21775f:	48 81 c4 e8 05 00 00 	add    rsp,0x5e8
  217766:	5b                   	pop    rbx
  217767:	41 5c                	pop    r12
  217769:	41 5d                	pop    r13
  21776b:	41 5e                	pop    r14
  21776d:	41 5f                	pop    r15
  21776f:	5d                   	pop    rbp
  217770:	c5 f8 77             	vzeroupper 
  217773:	c3                   	ret    
        const bytes = @sliceToBytes(memory);
  217774:	48 8b 45 48          	mov    rax,QWORD PTR [rbp+0x48]
  217778:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  21777c:	74 26                	je     2177a4 <openSelfDebugInfo+0xd64>
  21777e:	48 8b 7d 50          	mov    rdi,QWORD PTR [rbp+0x50]
        const bytes = @sliceToBytes(memory);
  217782:	48 8b 4d 40          	mov    rcx,QWORD PTR [rbp+0x40]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  217786:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  21778a:	48 89 8c 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rcx
  217791:	00 
  217792:	48 89 84 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],rax
  217799:	00 
  21779a:	48 8d b4 24 f0 00 00 	lea    rsi,[rsp+0xf0]
  2177a1:	00 
  2177a2:	ff d2                	call   rdx
  2177a4:	80 7d 10 01          	cmp    BYTE PTR [rbp+0x10],0x1
  2177a8:	0f 85 52 06 00 00    	jne    217e00 <openSelfDebugInfo+0x13c0>
  2177ae:	49 8b 07             	mov    rax,QWORD PTR [r15]
  2177b1:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  2177b4:	b8 03 00 00 00       	mov    eax,0x3
  2177b9:	0f 05                	syscall 
            switch (err) {
  2177bb:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  2177bf:	74 f3                	je     2177b4 <openSelfDebugInfo+0xd74>
            const first = list.first orelse return null;
  2177c1:	48 8b 05 60 e8 02 00 	mov    rax,QWORD PTR [rip+0x2e860]        # 246028 <emfile_promise_queue>
  2177c8:	48 85 c0             	test   rax,rax
  2177cb:	0f 84 2f 06 00 00    	je     217e00 <openSelfDebugInfo+0x13c0>
            if (node.prev) |prev_node| {
  2177d1:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  2177d4:	48 85 c9             	test   rcx,rcx
  2177d7:	0f 84 bf 05 00 00    	je     217d9c <openSelfDebugInfo+0x135c>
                prev_node.next = node.next;
  2177dd:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  2177e1:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  2177e5:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  2177e9:	e9 b9 05 00 00       	jmp    217da7 <openSelfDebugInfo+0x1367>
            st.debug_str = (try st.elf.findSection(".debug_str")) orelse return error.MissingDebugInfo;
  2177ee:	48 8b 84 24 28 03 00 	mov    rax,QWORD PTR [rsp+0x328]
  2177f5:	00 
  2177f6:	48 85 c0             	test   rax,rax
  2177f9:	0f 84 2c 03 00 00    	je     217b2b <openSelfDebugInfo+0x10eb>
  2177ff:	48 89 45 70          	mov    QWORD PTR [rbp+0x70],rax
            st.debug_line = (try st.elf.findSection(".debug_line")) orelse return error.MissingDebugInfo;
  217803:	48 8d 15 3e e4 02 00 	lea    rdx,[rip+0x2e43e]        # 245c48 <__unnamed_63>
  21780a:	48 8d bc 24 10 03 00 	lea    rdi,[rsp+0x310]
  217811:	00 
  217812:	4c 89 fe             	mov    rsi,r15
  217815:	e8 b6 3e 00 00       	call   21b6d0 <Elf_findSection>
  21781a:	66 83 bc 24 10 03 00 	cmp    WORD PTR [rsp+0x310],0x0
  217821:	00 00 
  217823:	0f 84 7c 03 00 00    	je     217ba5 <openSelfDebugInfo+0x1165>
        const bytes = @sliceToBytes(memory);
  217829:	48 8b 45 48          	mov    rax,QWORD PTR [rbp+0x48]
  21782d:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  217831:	74 26                	je     217859 <openSelfDebugInfo+0xe19>
  217833:	48 8b 7d 50          	mov    rdi,QWORD PTR [rbp+0x50]
        const bytes = @sliceToBytes(memory);
  217837:	48 8b 4d 40          	mov    rcx,QWORD PTR [rbp+0x40]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  21783b:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  21783f:	48 89 8c 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rcx
  217846:	00 
  217847:	48 89 84 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],rax
  21784e:	00 
  21784f:	48 8d b4 24 f0 00 00 	lea    rsi,[rsp+0xf0]
  217856:	00 
  217857:	ff d2                	call   rdx
  217859:	80 7d 10 01          	cmp    BYTE PTR [rbp+0x10],0x1
  21785d:	0f 85 92 1c 00 00    	jne    2194f5 <openSelfDebugInfo+0x2ab5>
  217863:	49 8b 07             	mov    rax,QWORD PTR [r15]
  217866:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  217869:	b8 03 00 00 00       	mov    eax,0x3
  21786e:	0f 05                	syscall 
  217870:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  217874:	74 f3                	je     217869 <openSelfDebugInfo+0xe29>
            const first = list.first orelse return null;
  217876:	48 8b 05 ab e7 02 00 	mov    rax,QWORD PTR [rip+0x2e7ab]        # 246028 <emfile_promise_queue>
  21787d:	48 85 c0             	test   rax,rax
  217880:	0f 84 6f 1c 00 00    	je     2194f5 <openSelfDebugInfo+0x2ab5>
            if (node.prev) |prev_node| {
  217886:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  217889:	48 85 c9             	test   rcx,rcx
  21788c:	0f 84 ff 1b 00 00    	je     219491 <openSelfDebugInfo+0x2a51>
                prev_node.next = node.next;
  217892:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  217896:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  21789a:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  21789e:	e9 f9 1b 00 00       	jmp    21949c <openSelfDebugInfo+0x2a5c>
                list.first = node.next;
  2178a3:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  2178a7:	48 89 0d 7a e7 02 00 	mov    QWORD PTR [rip+0x2e77a],rcx        # 246028 <emfile_promise_queue>
            if (node.next) |next_node| {
  2178ae:	48 85 c9             	test   rcx,rcx
  2178b1:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  2178b4:	48 8d 35 75 e7 02 00 	lea    rsi,[rip+0x2e775]        # 246030 <emfile_promise_queue+0x8>
  2178bb:	48 0f 45 f1          	cmovne rsi,rcx
  2178bf:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  2178c2:	48 83 05 6e e7 02 00 	add    QWORD PTR [rip+0x2e76e],0xffffffffffffffff        # 246038 <emfile_promise_queue+0x10>
  2178c9:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  2178ca:	74 1e                	je     2178ea <openSelfDebugInfo+0xeaa>
  2178cc:	48 83 3d 54 e7 02 00 	cmp    QWORD PTR [rip+0x2e754],0x0        # 246028 <emfile_promise_queue>
  2178d3:	00 
  2178d4:	0f 84 ca 31 00 00    	je     21aaa4 <openSelfDebugInfo+0x4064>
  2178da:	48 8b 0d 4f e7 02 00 	mov    rcx,QWORD PTR [rip+0x2e74f]        # 246030 <emfile_promise_queue+0x8>
  2178e1:	48 85 c9             	test   rcx,rcx
  2178e4:	0f 84 ba 31 00 00    	je     21aaa4 <openSelfDebugInfo+0x4064>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  2178ea:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  2178ee:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  2178f2:	48 89 c1             	mov    rcx,rax
  2178f5:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  2178f9:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  2178ff:	75 f1                	jne    2178f2 <openSelfDebugInfo+0xeb2>
  217901:	a8 01                	test   al,0x1
  217903:	75 02                	jne    217907 <openSelfDebugInfo+0xec7>
  217905:	ff 17                	call   QWORD PTR [rdi]
  217907:	48 63 7d 00          	movsxd rdi,DWORD PTR [rbp+0x0]
  21790b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  217910:	b8 03 00 00 00       	mov    eax,0x3
  217915:	0f 05                	syscall 
            switch (err) {
  217917:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  21791b:	74 f3                	je     217910 <openSelfDebugInfo+0xed0>
            const first = list.first orelse return null;
  21791d:	48 8b 05 04 e7 02 00 	mov    rax,QWORD PTR [rip+0x2e704]        # 246028 <emfile_promise_queue>
  217924:	48 85 c0             	test   rax,rax
  217927:	74 7a                	je     2179a3 <openSelfDebugInfo+0xf63>
            if (node.prev) |prev_node| {
  217929:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  21792c:	48 85 c9             	test   rcx,rcx
  21792f:	74 0e                	je     21793f <openSelfDebugInfo+0xeff>
                prev_node.next = node.next;
  217931:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  217935:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  217939:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  21793d:	eb 0b                	jmp    21794a <openSelfDebugInfo+0xf0a>
                list.first = node.next;
  21793f:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  217943:	48 89 0d de e6 02 00 	mov    QWORD PTR [rip+0x2e6de],rcx        # 246028 <emfile_promise_queue>
            if (node.next) |next_node| {
  21794a:	48 85 c9             	test   rcx,rcx
  21794d:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  217950:	48 8d 35 d9 e6 02 00 	lea    rsi,[rip+0x2e6d9]        # 246030 <emfile_promise_queue+0x8>
  217957:	48 0f 45 f1          	cmovne rsi,rcx
  21795b:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  21795e:	48 83 05 d2 e6 02 00 	add    QWORD PTR [rip+0x2e6d2],0xffffffffffffffff        # 246038 <emfile_promise_queue+0x10>
  217965:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  217966:	74 1e                	je     217986 <openSelfDebugInfo+0xf46>
  217968:	48 83 3d b8 e6 02 00 	cmp    QWORD PTR [rip+0x2e6b8],0x0        # 246028 <emfile_promise_queue>
  21796f:	00 
  217970:	0f 84 2e 31 00 00    	je     21aaa4 <openSelfDebugInfo+0x4064>
  217976:	48 8b 0d b3 e6 02 00 	mov    rcx,QWORD PTR [rip+0x2e6b3]        # 246030 <emfile_promise_queue+0x8>
  21797d:	48 85 c9             	test   rcx,rcx
  217980:	0f 84 1e 31 00 00    	je     21aaa4 <openSelfDebugInfo+0x4064>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  217986:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  21798a:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  21798e:	48 89 c1             	mov    rcx,rax
  217991:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  217995:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  21799b:	75 f1                	jne    21798e <openSelfDebugInfo+0xf4e>
  21799d:	a8 01                	test   al,0x1
  21799f:	75 02                	jne    2179a3 <openSelfDebugInfo+0xf63>
  2179a1:	ff 17                	call   QWORD PTR [rdi]
        self.freeFn(self, non_const_ptr[0..@sizeOf(@typeOf(ptr).Child)]);
  2179a3:	49 8b 44 24 10       	mov    rax,QWORD PTR [r12+0x10]
  2179a8:	48 89 ac 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rbp
  2179af:	00 
  2179b0:	48 c7 84 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],0xc8
  2179b7:	00 c8 00 00 00 
  2179bc:	48 8d b4 24 f0 00 00 	lea    rsi,[rsp+0xf0]
  2179c3:	00 
  2179c4:	4c 89 e7             	mov    rdi,r12
  2179c7:	ff d0                	call   rax
            st.debug_abbrev = (try st.elf.findSection(".debug_abbrev")) orelse return error.MissingDebugInfo;
  2179c9:	0f b7 84 24 30 03 00 	movzx  eax,WORD PTR [rsp+0x330]
  2179d0:	00 
  2179d1:	66 41 89 06          	mov    WORD PTR [r14],ax
  2179d5:	48 8b 84 24 da 04 00 	mov    rax,QWORD PTR [rsp+0x4da]
  2179dc:	00 
  2179dd:	48 8b 8c 24 e0 04 00 	mov    rcx,QWORD PTR [rsp+0x4e0]
  2179e4:	00 
  2179e5:	e9 6d fd ff ff       	jmp    217757 <openSelfDebugInfo+0xd17>
                list.first = node.next;
  2179ea:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  2179ee:	48 89 0d 33 e6 02 00 	mov    QWORD PTR [rip+0x2e633],rcx        # 246028 <emfile_promise_queue>
            if (node.next) |next_node| {
  2179f5:	48 85 c9             	test   rcx,rcx
  2179f8:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  2179fb:	48 8d 35 2e e6 02 00 	lea    rsi,[rip+0x2e62e]        # 246030 <emfile_promise_queue+0x8>
  217a02:	48 0f 45 f1          	cmovne rsi,rcx
  217a06:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  217a09:	48 83 05 27 e6 02 00 	add    QWORD PTR [rip+0x2e627],0xffffffffffffffff        # 246038 <emfile_promise_queue+0x10>
  217a10:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  217a11:	74 1e                	je     217a31 <openSelfDebugInfo+0xff1>
  217a13:	48 83 3d 0d e6 02 00 	cmp    QWORD PTR [rip+0x2e60d],0x0        # 246028 <emfile_promise_queue>
  217a1a:	00 
  217a1b:	0f 84 83 30 00 00    	je     21aaa4 <openSelfDebugInfo+0x4064>
  217a21:	48 8b 0d 08 e6 02 00 	mov    rcx,QWORD PTR [rip+0x2e608]        # 246030 <emfile_promise_queue+0x8>
  217a28:	48 85 c9             	test   rcx,rcx
  217a2b:	0f 84 73 30 00 00    	je     21aaa4 <openSelfDebugInfo+0x4064>
  217a31:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  217a35:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  217a39:	48 89 c1             	mov    rcx,rax
  217a3c:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  217a40:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  217a46:	75 f1                	jne    217a39 <openSelfDebugInfo+0xff9>
  217a48:	a8 01                	test   al,0x1
  217a4a:	75 02                	jne    217a4e <openSelfDebugInfo+0x100e>
  217a4c:	ff 17                	call   QWORD PTR [rdi]
  217a4e:	48 63 7d 00          	movsxd rdi,DWORD PTR [rbp+0x0]
  217a52:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  217a59:	1f 84 00 00 00 00 00 
  217a60:	b8 03 00 00 00       	mov    eax,0x3
  217a65:	0f 05                	syscall 
            switch (err) {
  217a67:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  217a6b:	74 f3                	je     217a60 <openSelfDebugInfo+0x1020>
            const first = list.first orelse return null;
  217a6d:	48 8b 05 b4 e5 02 00 	mov    rax,QWORD PTR [rip+0x2e5b4]        # 246028 <emfile_promise_queue>
  217a74:	48 85 c0             	test   rax,rax
  217a77:	74 7a                	je     217af3 <openSelfDebugInfo+0x10b3>
            if (node.prev) |prev_node| {
  217a79:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  217a7c:	48 85 c9             	test   rcx,rcx
  217a7f:	74 0e                	je     217a8f <openSelfDebugInfo+0x104f>
                prev_node.next = node.next;
  217a81:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  217a85:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  217a89:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  217a8d:	eb 0b                	jmp    217a9a <openSelfDebugInfo+0x105a>
                list.first = node.next;
  217a8f:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  217a93:	48 89 0d 8e e5 02 00 	mov    QWORD PTR [rip+0x2e58e],rcx        # 246028 <emfile_promise_queue>
            if (node.next) |next_node| {
  217a9a:	48 85 c9             	test   rcx,rcx
  217a9d:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  217aa0:	48 8d 35 89 e5 02 00 	lea    rsi,[rip+0x2e589]        # 246030 <emfile_promise_queue+0x8>
  217aa7:	48 0f 45 f1          	cmovne rsi,rcx
  217aab:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  217aae:	48 83 05 82 e5 02 00 	add    QWORD PTR [rip+0x2e582],0xffffffffffffffff        # 246038 <emfile_promise_queue+0x10>
  217ab5:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  217ab6:	74 1e                	je     217ad6 <openSelfDebugInfo+0x1096>
  217ab8:	48 83 3d 68 e5 02 00 	cmp    QWORD PTR [rip+0x2e568],0x0        # 246028 <emfile_promise_queue>
  217abf:	00 
  217ac0:	0f 84 de 2f 00 00    	je     21aaa4 <openSelfDebugInfo+0x4064>
  217ac6:	48 8b 0d 63 e5 02 00 	mov    rcx,QWORD PTR [rip+0x2e563]        # 246030 <emfile_promise_queue+0x8>
  217acd:	48 85 c9             	test   rcx,rcx
  217ad0:	0f 84 ce 2f 00 00    	je     21aaa4 <openSelfDebugInfo+0x4064>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  217ad6:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  217ada:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  217ade:	48 89 c1             	mov    rcx,rax
  217ae1:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  217ae5:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  217aeb:	75 f1                	jne    217ade <openSelfDebugInfo+0x109e>
  217aed:	a8 01                	test   al,0x1
  217aef:	75 02                	jne    217af3 <openSelfDebugInfo+0x10b3>
  217af1:	ff 17                	call   QWORD PTR [rdi]
  217af3:	49 8b 44 24 10       	mov    rax,QWORD PTR [r12+0x10]
  217af8:	48 89 ac 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rbp
  217aff:	00 
  217b00:	48 c7 84 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],0xc8
  217b07:	00 c8 00 00 00 
  217b0c:	48 8d b4 24 f0 00 00 	lea    rsi,[rsp+0xf0]
  217b13:	00 
  217b14:	4c 89 e7             	mov    rdi,r12
  217b17:	ff d0                	call   rax
  217b19:	c5 fa 6f 05 af 8c fe 	vmovdqu xmm0,XMMWORD PTR [rip+0xfffffffffffe8caf]        # 2007d0 <__unnamed_64>
  217b20:	ff 
  217b21:	c4 c1 7a 7f 06       	vmovdqu XMMWORD PTR [r14],xmm0
  217b26:	e9 34 fc ff ff       	jmp    21775f <openSelfDebugInfo+0xd1f>
        const bytes = @sliceToBytes(memory);
  217b2b:	48 8b 45 48          	mov    rax,QWORD PTR [rbp+0x48]
  217b2f:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  217b33:	74 26                	je     217b5b <openSelfDebugInfo+0x111b>
  217b35:	48 8b 7d 50          	mov    rdi,QWORD PTR [rbp+0x50]
        const bytes = @sliceToBytes(memory);
  217b39:	48 8b 4d 40          	mov    rcx,QWORD PTR [rbp+0x40]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  217b3d:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  217b41:	48 89 8c 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rcx
  217b48:	00 
  217b49:	48 89 84 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],rax
  217b50:	00 
  217b51:	48 8d b4 24 f0 00 00 	lea    rsi,[rsp+0xf0]
  217b58:	00 
  217b59:	ff d2                	call   rdx
  217b5b:	80 7d 10 01          	cmp    BYTE PTR [rbp+0x10],0x1
  217b5f:	0f 85 d2 1a 00 00    	jne    219637 <openSelfDebugInfo+0x2bf7>
  217b65:	49 8b 07             	mov    rax,QWORD PTR [r15]
  217b68:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  217b6b:	b8 03 00 00 00       	mov    eax,0x3
  217b70:	0f 05                	syscall 
            switch (err) {
  217b72:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  217b76:	74 f3                	je     217b6b <openSelfDebugInfo+0x112b>
            const first = list.first orelse return null;
  217b78:	48 8b 05 a9 e4 02 00 	mov    rax,QWORD PTR [rip+0x2e4a9]        # 246028 <emfile_promise_queue>
  217b7f:	48 85 c0             	test   rax,rax
  217b82:	0f 84 af 1a 00 00    	je     219637 <openSelfDebugInfo+0x2bf7>
            if (node.prev) |prev_node| {
  217b88:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  217b8b:	48 85 c9             	test   rcx,rcx
  217b8e:	0f 84 3f 1a 00 00    	je     2195d3 <openSelfDebugInfo+0x2b93>
                prev_node.next = node.next;
  217b94:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  217b98:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  217b9c:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  217ba0:	e9 39 1a 00 00       	jmp    2195de <openSelfDebugInfo+0x2b9e>
            st.debug_line = (try st.elf.findSection(".debug_line")) orelse return error.MissingDebugInfo;
  217ba5:	48 8b 84 24 18 03 00 	mov    rax,QWORD PTR [rsp+0x318]
  217bac:	00 
  217bad:	48 85 c0             	test   rax,rax
  217bb0:	0f 84 e4 02 00 00    	je     217e9a <openSelfDebugInfo+0x145a>
  217bb6:	48 89 45 78          	mov    QWORD PTR [rbp+0x78],rax
            st.debug_ranges = (try st.elf.findSection(".debug_ranges"));
  217bba:	48 8d 15 97 e0 02 00 	lea    rdx,[rip+0x2e097]        # 245c58 <__unnamed_65>
  217bc1:	48 8d bc 24 00 03 00 	lea    rdi,[rsp+0x300]
  217bc8:	00 
  217bc9:	4c 89 fe             	mov    rsi,r15
  217bcc:	e8 ff 3a 00 00       	call   21b6d0 <Elf_findSection>
  217bd1:	66 83 bc 24 00 03 00 	cmp    WORD PTR [rsp+0x300],0x0
  217bd8:	00 00 
  217bda:	0f 84 34 03 00 00    	je     217f14 <openSelfDebugInfo+0x14d4>
        const bytes = @sliceToBytes(memory);
  217be0:	48 8b 45 48          	mov    rax,QWORD PTR [rbp+0x48]
  217be4:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  217be8:	74 26                	je     217c10 <openSelfDebugInfo+0x11d0>
  217bea:	48 8b 7d 50          	mov    rdi,QWORD PTR [rbp+0x50]
        const bytes = @sliceToBytes(memory);
  217bee:	48 8b 4d 40          	mov    rcx,QWORD PTR [rbp+0x40]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  217bf2:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  217bf6:	48 89 8c 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rcx
  217bfd:	00 
  217bfe:	48 89 84 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],rax
  217c05:	00 
  217c06:	48 8d b4 24 f0 00 00 	lea    rsi,[rsp+0xf0]
  217c0d:	00 
  217c0e:	ff d2                	call   rdx
  217c10:	80 7d 10 01          	cmp    BYTE PTR [rbp+0x10],0x1
  217c14:	0f 85 4f 1b 00 00    	jne    219769 <openSelfDebugInfo+0x2d29>
  217c1a:	49 8b 07             	mov    rax,QWORD PTR [r15]
  217c1d:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  217c20:	b8 03 00 00 00       	mov    eax,0x3
  217c25:	0f 05                	syscall 
  217c27:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  217c2b:	74 f3                	je     217c20 <openSelfDebugInfo+0x11e0>
            const first = list.first orelse return null;
  217c2d:	48 8b 05 f4 e3 02 00 	mov    rax,QWORD PTR [rip+0x2e3f4]        # 246028 <emfile_promise_queue>
  217c34:	48 85 c0             	test   rax,rax
  217c37:	0f 84 2c 1b 00 00    	je     219769 <openSelfDebugInfo+0x2d29>
            if (node.prev) |prev_node| {
  217c3d:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  217c40:	48 85 c9             	test   rcx,rcx
  217c43:	0f 84 bc 1a 00 00    	je     219705 <openSelfDebugInfo+0x2cc5>
                prev_node.next = node.next;
  217c49:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  217c4d:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  217c51:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  217c55:	e9 b6 1a 00 00       	jmp    219710 <openSelfDebugInfo+0x2cd0>
                list.first = node.next;
  217c5a:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  217c5e:	48 89 0d c3 e3 02 00 	mov    QWORD PTR [rip+0x2e3c3],rcx        # 246028 <emfile_promise_queue>
            if (node.next) |next_node| {
  217c65:	48 85 c9             	test   rcx,rcx
  217c68:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  217c6b:	48 8d 35 be e3 02 00 	lea    rsi,[rip+0x2e3be]        # 246030 <emfile_promise_queue+0x8>
  217c72:	48 0f 45 f1          	cmovne rsi,rcx
  217c76:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  217c79:	48 83 05 b7 e3 02 00 	add    QWORD PTR [rip+0x2e3b7],0xffffffffffffffff        # 246038 <emfile_promise_queue+0x10>
  217c80:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  217c81:	74 1e                	je     217ca1 <openSelfDebugInfo+0x1261>
  217c83:	48 83 3d 9d e3 02 00 	cmp    QWORD PTR [rip+0x2e39d],0x0        # 246028 <emfile_promise_queue>
  217c8a:	00 
  217c8b:	0f 84 13 2e 00 00    	je     21aaa4 <openSelfDebugInfo+0x4064>
  217c91:	48 8b 0d 98 e3 02 00 	mov    rcx,QWORD PTR [rip+0x2e398]        # 246030 <emfile_promise_queue+0x8>
  217c98:	48 85 c9             	test   rcx,rcx
  217c9b:	0f 84 03 2e 00 00    	je     21aaa4 <openSelfDebugInfo+0x4064>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  217ca1:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  217ca5:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  217ca9:	48 89 c1             	mov    rcx,rax
  217cac:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  217cb0:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  217cb6:	75 f1                	jne    217ca9 <openSelfDebugInfo+0x1269>
  217cb8:	a8 01                	test   al,0x1
  217cba:	75 02                	jne    217cbe <openSelfDebugInfo+0x127e>
  217cbc:	ff 17                	call   QWORD PTR [rdi]
  217cbe:	48 63 7d 00          	movsxd rdi,DWORD PTR [rbp+0x0]
  217cc2:	b8 03 00 00 00       	mov    eax,0x3
  217cc7:	0f 05                	syscall 
            switch (err) {
  217cc9:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  217ccd:	74 f3                	je     217cc2 <openSelfDebugInfo+0x1282>
            const first = list.first orelse return null;
  217ccf:	48 8b 05 52 e3 02 00 	mov    rax,QWORD PTR [rip+0x2e352]        # 246028 <emfile_promise_queue>
  217cd6:	48 85 c0             	test   rax,rax
  217cd9:	74 7a                	je     217d55 <openSelfDebugInfo+0x1315>
            if (node.prev) |prev_node| {
  217cdb:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  217cde:	48 85 c9             	test   rcx,rcx
  217ce1:	74 0e                	je     217cf1 <openSelfDebugInfo+0x12b1>
                prev_node.next = node.next;
  217ce3:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  217ce7:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  217ceb:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  217cef:	eb 0b                	jmp    217cfc <openSelfDebugInfo+0x12bc>
                list.first = node.next;
  217cf1:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  217cf5:	48 89 0d 2c e3 02 00 	mov    QWORD PTR [rip+0x2e32c],rcx        # 246028 <emfile_promise_queue>
            if (node.next) |next_node| {
  217cfc:	48 85 c9             	test   rcx,rcx
  217cff:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  217d02:	48 8d 35 27 e3 02 00 	lea    rsi,[rip+0x2e327]        # 246030 <emfile_promise_queue+0x8>
  217d09:	48 0f 45 f1          	cmovne rsi,rcx
  217d0d:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  217d10:	48 83 05 20 e3 02 00 	add    QWORD PTR [rip+0x2e320],0xffffffffffffffff        # 246038 <emfile_promise_queue+0x10>
  217d17:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  217d18:	74 1e                	je     217d38 <openSelfDebugInfo+0x12f8>
  217d1a:	48 83 3d 06 e3 02 00 	cmp    QWORD PTR [rip+0x2e306],0x0        # 246028 <emfile_promise_queue>
  217d21:	00 
  217d22:	0f 84 7c 2d 00 00    	je     21aaa4 <openSelfDebugInfo+0x4064>
  217d28:	48 8b 0d 01 e3 02 00 	mov    rcx,QWORD PTR [rip+0x2e301]        # 246030 <emfile_promise_queue+0x8>
  217d2f:	48 85 c9             	test   rcx,rcx
  217d32:	0f 84 6c 2d 00 00    	je     21aaa4 <openSelfDebugInfo+0x4064>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  217d38:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  217d3c:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  217d40:	48 89 c1             	mov    rcx,rax
  217d43:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  217d47:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  217d4d:	75 f1                	jne    217d40 <openSelfDebugInfo+0x1300>
  217d4f:	a8 01                	test   al,0x1
  217d51:	75 02                	jne    217d55 <openSelfDebugInfo+0x1315>
  217d53:	ff 17                	call   QWORD PTR [rdi]
        self.freeFn(self, non_const_ptr[0..@sizeOf(@typeOf(ptr).Child)]);
  217d55:	49 8b 44 24 10       	mov    rax,QWORD PTR [r12+0x10]
  217d5a:	48 89 ac 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rbp
  217d61:	00 
  217d62:	48 c7 84 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],0xc8
  217d69:	00 c8 00 00 00 
  217d6e:	48 8d b4 24 f0 00 00 	lea    rsi,[rsp+0xf0]
  217d75:	00 
  217d76:	4c 89 e7             	mov    rdi,r12
  217d79:	ff d0                	call   rax
            st.debug_str = (try st.elf.findSection(".debug_str")) orelse return error.MissingDebugInfo;
  217d7b:	0f b7 84 24 20 03 00 	movzx  eax,WORD PTR [rsp+0x320]
  217d82:	00 
  217d83:	66 41 89 06          	mov    WORD PTR [r14],ax
  217d87:	48 8b 84 24 cc 04 00 	mov    rax,QWORD PTR [rsp+0x4cc]
  217d8e:	00 
  217d8f:	48 8b 8c 24 d2 04 00 	mov    rcx,QWORD PTR [rsp+0x4d2]
  217d96:	00 
  217d97:	e9 bb f9 ff ff       	jmp    217757 <openSelfDebugInfo+0xd17>
                list.first = node.next;
  217d9c:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  217da0:	48 89 0d 81 e2 02 00 	mov    QWORD PTR [rip+0x2e281],rcx        # 246028 <emfile_promise_queue>
            if (node.next) |next_node| {
  217da7:	48 85 c9             	test   rcx,rcx
  217daa:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  217dad:	48 8d 35 7c e2 02 00 	lea    rsi,[rip+0x2e27c]        # 246030 <emfile_promise_queue+0x8>
  217db4:	48 0f 45 f1          	cmovne rsi,rcx
  217db8:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  217dbb:	48 83 05 75 e2 02 00 	add    QWORD PTR [rip+0x2e275],0xffffffffffffffff        # 246038 <emfile_promise_queue+0x10>
  217dc2:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  217dc3:	74 1e                	je     217de3 <openSelfDebugInfo+0x13a3>
  217dc5:	48 83 3d 5b e2 02 00 	cmp    QWORD PTR [rip+0x2e25b],0x0        # 246028 <emfile_promise_queue>
  217dcc:	00 
  217dcd:	0f 84 d1 2c 00 00    	je     21aaa4 <openSelfDebugInfo+0x4064>
  217dd3:	48 8b 0d 56 e2 02 00 	mov    rcx,QWORD PTR [rip+0x2e256]        # 246030 <emfile_promise_queue+0x8>
  217dda:	48 85 c9             	test   rcx,rcx
  217ddd:	0f 84 c1 2c 00 00    	je     21aaa4 <openSelfDebugInfo+0x4064>
  217de3:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  217de7:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  217deb:	48 89 c1             	mov    rcx,rax
  217dee:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  217df2:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  217df8:	75 f1                	jne    217deb <openSelfDebugInfo+0x13ab>
  217dfa:	a8 01                	test   al,0x1
  217dfc:	75 02                	jne    217e00 <openSelfDebugInfo+0x13c0>
  217dfe:	ff 17                	call   QWORD PTR [rdi]
  217e00:	48 63 7d 00          	movsxd rdi,DWORD PTR [rbp+0x0]
  217e04:	b8 03 00 00 00       	mov    eax,0x3
  217e09:	0f 05                	syscall 
            switch (err) {
  217e0b:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  217e0f:	74 f3                	je     217e04 <openSelfDebugInfo+0x13c4>
            const first = list.first orelse return null;
  217e11:	48 8b 05 10 e2 02 00 	mov    rax,QWORD PTR [rip+0x2e210]        # 246028 <emfile_promise_queue>
  217e18:	48 85 c0             	test   rax,rax
  217e1b:	0f 84 d2 fc ff ff    	je     217af3 <openSelfDebugInfo+0x10b3>
            if (node.prev) |prev_node| {
  217e21:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  217e24:	48 85 c9             	test   rcx,rcx
  217e27:	74 0e                	je     217e37 <openSelfDebugInfo+0x13f7>
                prev_node.next = node.next;
  217e29:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  217e2d:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  217e31:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  217e35:	eb 0b                	jmp    217e42 <openSelfDebugInfo+0x1402>
                list.first = node.next;
  217e37:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  217e3b:	48 89 0d e6 e1 02 00 	mov    QWORD PTR [rip+0x2e1e6],rcx        # 246028 <emfile_promise_queue>
            if (node.next) |next_node| {
  217e42:	48 85 c9             	test   rcx,rcx
  217e45:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  217e48:	48 8d 35 e1 e1 02 00 	lea    rsi,[rip+0x2e1e1]        # 246030 <emfile_promise_queue+0x8>
  217e4f:	48 0f 45 f1          	cmovne rsi,rcx
  217e53:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  217e56:	48 83 05 da e1 02 00 	add    QWORD PTR [rip+0x2e1da],0xffffffffffffffff        # 246038 <emfile_promise_queue+0x10>
  217e5d:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  217e5e:	74 1e                	je     217e7e <openSelfDebugInfo+0x143e>
  217e60:	48 83 3d c0 e1 02 00 	cmp    QWORD PTR [rip+0x2e1c0],0x0        # 246028 <emfile_promise_queue>
  217e67:	00 
  217e68:	0f 84 36 2c 00 00    	je     21aaa4 <openSelfDebugInfo+0x4064>
  217e6e:	48 8b 0d bb e1 02 00 	mov    rcx,QWORD PTR [rip+0x2e1bb]        # 246030 <emfile_promise_queue+0x8>
  217e75:	48 85 c9             	test   rcx,rcx
  217e78:	0f 84 26 2c 00 00    	je     21aaa4 <openSelfDebugInfo+0x4064>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  217e7e:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  217e82:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  217e86:	48 89 c1             	mov    rcx,rax
  217e89:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  217e8d:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  217e93:	75 f1                	jne    217e86 <openSelfDebugInfo+0x1446>
  217e95:	e9 53 fc ff ff       	jmp    217aed <openSelfDebugInfo+0x10ad>
        const bytes = @sliceToBytes(memory);
  217e9a:	48 8b 45 48          	mov    rax,QWORD PTR [rbp+0x48]
  217e9e:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  217ea2:	74 26                	je     217eca <openSelfDebugInfo+0x148a>
  217ea4:	48 8b 7d 50          	mov    rdi,QWORD PTR [rbp+0x50]
        const bytes = @sliceToBytes(memory);
  217ea8:	48 8b 4d 40          	mov    rcx,QWORD PTR [rbp+0x40]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  217eac:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  217eb0:	48 89 8c 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rcx
  217eb7:	00 
  217eb8:	48 89 84 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],rax
  217ebf:	00 
  217ec0:	48 8d b4 24 f0 00 00 	lea    rsi,[rsp+0xf0]
  217ec7:	00 
  217ec8:	ff d2                	call   rdx
  217eca:	80 7d 10 01          	cmp    BYTE PTR [rbp+0x10],0x1
  217ece:	0f 85 d7 19 00 00    	jne    2198ab <openSelfDebugInfo+0x2e6b>
  217ed4:	49 8b 07             	mov    rax,QWORD PTR [r15]
  217ed7:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  217eda:	b8 03 00 00 00       	mov    eax,0x3
  217edf:	0f 05                	syscall 
            switch (err) {
  217ee1:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  217ee5:	74 f3                	je     217eda <openSelfDebugInfo+0x149a>
            const first = list.first orelse return null;
  217ee7:	48 8b 05 3a e1 02 00 	mov    rax,QWORD PTR [rip+0x2e13a]        # 246028 <emfile_promise_queue>
  217eee:	48 85 c0             	test   rax,rax
  217ef1:	0f 84 b4 19 00 00    	je     2198ab <openSelfDebugInfo+0x2e6b>
            if (node.prev) |prev_node| {
  217ef7:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  217efa:	48 85 c9             	test   rcx,rcx
  217efd:	0f 84 44 19 00 00    	je     219847 <openSelfDebugInfo+0x2e07>
                prev_node.next = node.next;
  217f03:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  217f07:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  217f0b:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  217f0f:	e9 3e 19 00 00       	jmp    219852 <openSelfDebugInfo+0x2e12>
            st.debug_ranges = (try st.elf.findSection(".debug_ranges"));
  217f14:	48 8b 84 24 08 03 00 	mov    rax,QWORD PTR [rsp+0x308]
  217f1b:	00 
  217f1c:	48 89 85 80 00 00 00 	mov    QWORD PTR [rbp+0x80],rax
    const debug_info_end = st.debug_info.offset + st.debug_info.size;
  217f23:	48 8b 45 60          	mov    rax,QWORD PTR [rbp+0x60]
  217f27:	48 8b 48 18          	mov    rcx,QWORD PTR [rax+0x18]
  217f2b:	48 89 4c 24 68       	mov    QWORD PTR [rsp+0x68],rcx
  217f30:	48 8b 48 20          	mov    rcx,QWORD PTR [rax+0x20]
    var in_file_stream = io.FileInStream.init(&st.self_exe_file);
  217f34:	48 89 ac 24 b0 01 00 	mov    QWORD PTR [rsp+0x1b0],rbp
  217f3b:	00 
  217f3c:	48 8d 05 fd 3c 00 00 	lea    rax,[rip+0x3cfd]        # 21bc40 <FileInStream_readFn>
  217f43:	48 89 84 24 b8 01 00 	mov    QWORD PTR [rsp+0x1b8],rax
  217f4a:	00 
  217f4b:	48 89 8c 24 90 00 00 	mov    QWORD PTR [rsp+0x90],rcx
  217f52:	00 
    while (this_unit_offset < debug_info_end) {
  217f53:	48 85 c9             	test   rcx,rcx
  217f56:	0f 84 75 17 00 00    	je     2196d1 <openSelfDebugInfo+0x2c91>
  217f5c:	48 8d 85 88 00 00 00 	lea    rax,[rbp+0x88]
  217f63:	48 89 84 24 68 02 00 	mov    QWORD PTR [rsp+0x268],rax
  217f6a:	00 
  217f6b:	48 8d 85 a8 00 00 00 	lea    rax,[rbp+0xa8]
  217f72:	48 89 44 24 70       	mov    QWORD PTR [rsp+0x70],rax
  217f77:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  217f7c:	48 01 84 24 90 00 00 	add    QWORD PTR [rsp+0x90],rax
  217f83:	00 
  217f84:	c4 e2 7d 19 05 33 8d 	vbroadcastsd ymm0,QWORD PTR [rip+0xfffffffffffe8d33]        # 200cc0 <__unnamed_456+0x70>
  217f8b:	fe ff 
  217f8d:	c5 fc 11 84 24 40 05 	vmovups YMMWORD PTR [rsp+0x540],ymm0
  217f94:	00 00 
  217f96:	c4 e2 7d 59 05 91 8d 	vpbroadcastq ymm0,QWORD PTR [rip+0xfffffffffffe8d91]        # 200d30 <app_mask+0x50>
  217f9d:	fe ff 
  217f9f:	c5 fe 7f 84 24 20 05 	vmovdqu YMMWORD PTR [rsp+0x520],ymm0
  217fa6:	00 00 
  217fa8:	66 c7 84 24 c8 01 00 	mov    WORD PTR [rsp+0x1c8],0x21
  217faf:	00 21 00 
  217fb2:	31 c0                	xor    eax,eax
  217fb4:	48 89 84 24 80 01 00 	mov    QWORD PTR [rsp+0x180],rax
  217fbb:	00 
    if (@maxValue(@typeOf(x)) > @maxValue(T) and x > @maxValue(T)) {
  217fbc:	48 83 7c 24 68 00    	cmp    QWORD PTR [rsp+0x68],0x0
  217fc2:	0f 88 11 1a 00 00    	js     2199d9 <openSelfDebugInfo+0x2f99>
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  217fc8:	48 63 7d 00          	movsxd rdi,DWORD PTR [rbp+0x0]
    return asm volatile ("syscall"
  217fcc:	b8 08 00 00 00       	mov    eax,0x8
  217fd1:	31 d2                	xor    edx,edx
  217fd3:	48 8b 74 24 68       	mov    rsi,QWORD PTR [rsp+0x68]
  217fd8:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  217fda:	48 89 c1             	mov    rcx,rax
  217fdd:	48 f7 d9             	neg    rcx
  217fe0:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  217fe6:	b8 00 00 00 00       	mov    eax,0x0
  217feb:	48 0f 46 c8          	cmovbe rcx,rax
                if (err > 0) {
  217fef:	48 85 c9             	test   rcx,rcx
  217ff2:	0f 85 09 1a 00 00    	jne    219a01 <openSelfDebugInfo+0x2fc1>
            try self.readNoEof(bytes[0..]);
  217ff8:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  217ffd:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  218004:	00 
  218005:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x4
  21800c:	00 04 00 00 00 
            return self.readFn(self, buffer);
  218011:	48 89 df             	mov    rdi,rbx
  218014:	48 8d b4 24 b8 01 00 	lea    rsi,[rsp+0x1b8]
  21801b:	00 
  21801c:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  218023:	00 
  218024:	c5 f8 77             	vzeroupper 
  218027:	ff 94 24 b8 01 00 00 	call   QWORD PTR [rsp+0x1b8]
  21802e:	0f b7 8c 24 f0 00 00 	movzx  ecx,WORD PTR [rsp+0xf0]
  218035:	00 
  218036:	89 c8                	mov    eax,ecx
            const amt_read = try self.read(buf);
  218038:	66 85 c9             	test   cx,cx
  21803b:	0f 85 46 19 00 00    	jne    219987 <openSelfDebugInfo+0x2f47>
  218041:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  218048:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  218049:	48 3b 84 24 a0 00 00 	cmp    rax,QWORD PTR [rsp+0xa0]
  218050:	00 
  218051:	0f 82 2c 19 00 00    	jb     219983 <openSelfDebugInfo+0x2f43>
  218057:	0f b6 44 24 20       	movzx  eax,BYTE PTR [rsp+0x20]
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  21805c:	0f b6 4c 24 21       	movzx  ecx,BYTE PTR [rsp+0x21]
  218061:	48 c1 e1 08          	shl    rcx,0x8
  218065:	48 09 c1             	or     rcx,rax
  218068:	0f b6 44 24 22       	movzx  eax,BYTE PTR [rsp+0x22]
  21806d:	48 c1 e0 10          	shl    rax,0x10
  218071:	48 09 c8             	or     rax,rcx
  218074:	0f b6 4c 24 23       	movzx  ecx,BYTE PTR [rsp+0x23]
  218079:	48 c1 e1 18          	shl    rcx,0x18
  21807d:	48 09 c1             	or     rcx,rax
  218080:	48 89 4c 24 78       	mov    QWORD PTR [rsp+0x78],rcx
    is_64.* = (first_32_bits == 0xffffffff);
  218085:	83 f9 ff             	cmp    ecx,0xffffffff
    if (is_64.*) {
  218088:	74 27                	je     2180b1 <openSelfDebugInfo+0x1671>
        if (first_32_bits >= 0xfffffff0) return error.InvalidDebugInfo;
  21808a:	83 7c 24 78 ef       	cmp    DWORD PTR [rsp+0x78],0xffffffef
  21808f:	0f 87 58 19 00 00    	ja     2199ed <openSelfDebugInfo+0x2fad>
  218095:	c7 84 24 80 00 00 00 	mov    DWORD PTR [rsp+0x80],0x0
  21809c:	00 00 00 00 
        if (unit_length == 0) return;
  2180a0:	48 83 7c 24 78 00    	cmp    QWORD PTR [rsp+0x78],0x0
  2180a6:	0f 85 86 00 00 00    	jne    218132 <openSelfDebugInfo+0x16f2>
  2180ac:	e9 20 16 00 00       	jmp    2196d1 <openSelfDebugInfo+0x2c91>
            try self.readNoEof(bytes[0..]);
  2180b1:	48 8d 84 24 d8 03 00 	lea    rax,[rsp+0x3d8]
  2180b8:	00 
  2180b9:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  2180c0:	00 
  2180c1:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x8
  2180c8:	00 08 00 00 00 
            return self.readFn(self, buffer);
  2180cd:	48 89 df             	mov    rdi,rbx
  2180d0:	48 8d b4 24 b8 01 00 	lea    rsi,[rsp+0x1b8]
  2180d7:	00 
  2180d8:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  2180df:	00 
  2180e0:	ff 94 24 b8 01 00 00 	call   QWORD PTR [rsp+0x1b8]
  2180e7:	0f b7 8c 24 f0 00 00 	movzx  ecx,WORD PTR [rsp+0xf0]
  2180ee:	00 
  2180ef:	89 c8                	mov    eax,ecx
            const amt_read = try self.read(buf);
  2180f1:	66 85 c9             	test   cx,cx
  2180f4:	0f 85 8d 18 00 00    	jne    219987 <openSelfDebugInfo+0x2f47>
  2180fa:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  218101:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  218102:	48 3b 84 24 a0 00 00 	cmp    rax,QWORD PTR [rsp+0xa0]
  218109:	00 
  21810a:	0f 82 73 18 00 00    	jb     219983 <openSelfDebugInfo+0x2f43>
  218110:	48 8b 84 24 d8 03 00 	mov    rax,QWORD PTR [rsp+0x3d8]
  218117:	00 
  218118:	48 89 44 24 78       	mov    QWORD PTR [rsp+0x78],rax
  21811d:	b0 01                	mov    al,0x1
        const unit_length = try readInitialLength(@typeOf(in_stream.readFn).ReturnType.ErrorSet, in_stream, &is_64);
  21811f:	89 84 24 80 00 00 00 	mov    DWORD PTR [rsp+0x80],eax
        if (unit_length == 0) return;
  218126:	48 83 7c 24 78 00    	cmp    QWORD PTR [rsp+0x78],0x0
  21812c:	0f 84 9f 15 00 00    	je     2196d1 <openSelfDebugInfo+0x2c91>
        const version = try in_stream.readInt(st.elf.endian, u16);
  218132:	44 8a 6d 12          	mov    r13b,BYTE PTR [rbp+0x12]
            try self.readNoEof(bytes[0..]);
  218136:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  21813b:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  218142:	00 
  218143:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x2
  21814a:	00 02 00 00 00 
            return self.readFn(self, buffer);
  21814f:	48 89 df             	mov    rdi,rbx
  218152:	48 8d b4 24 b8 01 00 	lea    rsi,[rsp+0x1b8]
  218159:	00 
  21815a:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  218161:	00 
  218162:	ff 94 24 b8 01 00 00 	call   QWORD PTR [rsp+0x1b8]
  218169:	0f b7 8c 24 f0 00 00 	movzx  ecx,WORD PTR [rsp+0xf0]
  218170:	00 
  218171:	89 c8                	mov    eax,ecx
            const amt_read = try self.read(buf);
  218173:	66 85 c9             	test   cx,cx
  218176:	0f 85 0b 18 00 00    	jne    219987 <openSelfDebugInfo+0x2f47>
  21817c:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  218183:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  218184:	48 3b 84 24 a0 00 00 	cmp    rax,QWORD PTR [rsp+0xa0]
  21818b:	00 
  21818c:	0f 82 f1 17 00 00    	jb     219983 <openSelfDebugInfo+0x2f43>
  218192:	0f b6 54 24 20       	movzx  edx,BYTE PTR [rsp+0x20]
  218197:	0f b6 44 24 21       	movzx  eax,BYTE PTR [rsp+0x21]
  21819c:	89 c1                	mov    ecx,eax
  21819e:	c1 e1 08             	shl    ecx,0x8
  2181a1:	09 d1                	or     ecx,edx
                result = (result << 8) | b;
  2181a3:	c1 e2 08             	shl    edx,0x8
  2181a6:	09 c2                	or     edx,eax
    switch (endian) {
  2181a8:	41 f6 c5 01          	test   r13b,0x1
  2181ac:	66 0f 45 d1          	cmovne dx,cx
  2181b0:	48 89 94 24 f8 02 00 	mov    QWORD PTR [rsp+0x2f8],rdx
  2181b7:	00 
        if (version < 2 or version > 5) return error.InvalidDebugInfo;
  2181b8:	8d 42 fe             	lea    eax,[rdx-0x2]
  2181bb:	0f b7 c0             	movzx  eax,ax
  2181be:	83 f8 03             	cmp    eax,0x3
  2181c1:	0f 87 26 18 00 00    	ja     2199ed <openSelfDebugInfo+0x2fad>
  2181c7:	44 8a 6d 12          	mov    r13b,BYTE PTR [rbp+0x12]
        const debug_abbrev_offset = if (is_64) try in_stream.readInt(st.elf.endian, u64) else try in_stream.readInt(st.elf.endian, u32);
  2181cb:	80 bc 24 80 00 00 00 	cmp    BYTE PTR [rsp+0x80],0x0
  2181d2:	00 
  2181d3:	74 37                	je     21820c <openSelfDebugInfo+0x17cc>
  2181d5:	41 0f b6 d5          	movzx  edx,r13b
  2181d9:	48 8d bc 24 c8 03 00 	lea    rdi,[rsp+0x3c8]
  2181e0:	00 
  2181e1:	48 8d b4 24 b8 01 00 	lea    rsi,[rsp+0x1b8]
  2181e8:	00 
  2181e9:	e8 f2 37 00 00       	call   21b9e0 <InStream(ReadError)_readInt.45>
  2181ee:	0f b7 bc 24 c8 03 00 	movzx  edi,WORD PTR [rsp+0x3c8]
  2181f5:	00 
  2181f6:	66 85 ff             	test   di,di
  2181f9:	0f 85 c9 18 00 00    	jne    219ac8 <openSelfDebugInfo+0x3088>
  2181ff:	48 8b 84 24 d0 03 00 	mov    rax,QWORD PTR [rsp+0x3d0]
  218206:	00 
  218207:	e9 a2 00 00 00       	jmp    2182ae <openSelfDebugInfo+0x186e>
            try self.readNoEof(bytes[0..]);
  21820c:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  218211:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  218218:	00 
  218219:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x4
  218220:	00 04 00 00 00 
            return self.readFn(self, buffer);
  218225:	48 89 df             	mov    rdi,rbx
  218228:	48 8d b4 24 b8 01 00 	lea    rsi,[rsp+0x1b8]
  21822f:	00 
  218230:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  218237:	00 
  218238:	ff 94 24 b8 01 00 00 	call   QWORD PTR [rsp+0x1b8]
  21823f:	0f b7 8c 24 f0 00 00 	movzx  ecx,WORD PTR [rsp+0xf0]
  218246:	00 
  218247:	89 c8                	mov    eax,ecx
            const amt_read = try self.read(buf);
  218249:	66 85 c9             	test   cx,cx
  21824c:	0f 85 35 17 00 00    	jne    219987 <openSelfDebugInfo+0x2f47>
  218252:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  218259:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  21825a:	48 3b 84 24 a0 00 00 	cmp    rax,QWORD PTR [rsp+0xa0]
  218261:	00 
  218262:	0f 82 1b 17 00 00    	jb     219983 <openSelfDebugInfo+0x2f43>
  218268:	0f b6 44 24 20       	movzx  eax,BYTE PTR [rsp+0x20]
  21826d:	0f b6 4c 24 21       	movzx  ecx,BYTE PTR [rsp+0x21]
  218272:	41 f6 c5 01          	test   r13b,0x1
  218276:	74 1b                	je     218293 <openSelfDebugInfo+0x1853>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  218278:	c1 e1 08             	shl    ecx,0x8
  21827b:	09 c1                	or     ecx,eax
  21827d:	0f b6 54 24 22       	movzx  edx,BYTE PTR [rsp+0x22]
  218282:	c1 e2 10             	shl    edx,0x10
  218285:	09 ca                	or     edx,ecx
  218287:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  21828c:	c1 e0 18             	shl    eax,0x18
  21828f:	09 d0                	or     eax,edx
  218291:	eb 19                	jmp    2182ac <openSelfDebugInfo+0x186c>
                result = (result << 8) | b;
  218293:	c1 e0 08             	shl    eax,0x8
  218296:	09 c8                	or     eax,ecx
  218298:	c1 e0 08             	shl    eax,0x8
  21829b:	0f b6 4c 24 22       	movzx  ecx,BYTE PTR [rsp+0x22]
  2182a0:	09 c1                	or     ecx,eax
  2182a2:	c1 e1 08             	shl    ecx,0x8
  2182a5:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  2182aa:	09 c8                	or     eax,ecx
  2182ac:	89 c0                	mov    eax,eax
  2182ae:	48 89 44 24 48       	mov    QWORD PTR [rsp+0x48],rax
            try self.readNoEof(result[0..]);
  2182b3:	48 8d 44 24 1f       	lea    rax,[rsp+0x1f]
  2182b8:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  2182bf:	00 
  2182c0:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x1
  2182c7:	00 01 00 00 00 
            return self.readFn(self, buffer);
  2182cc:	48 89 df             	mov    rdi,rbx
  2182cf:	48 8d b4 24 b8 01 00 	lea    rsi,[rsp+0x1b8]
  2182d6:	00 
  2182d7:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  2182de:	00 
  2182df:	ff 94 24 b8 01 00 00 	call   QWORD PTR [rsp+0x1b8]
  2182e6:	0f b7 8c 24 f0 00 00 	movzx  ecx,WORD PTR [rsp+0xf0]
  2182ed:	00 
  2182ee:	89 c8                	mov    eax,ecx
            const amt_read = try self.read(buf);
  2182f0:	66 85 c9             	test   cx,cx
  2182f3:	0f 85 8e 16 00 00    	jne    219987 <openSelfDebugInfo+0x2f47>
  2182f9:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  218300:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  218301:	48 3b 84 24 a0 00 00 	cmp    rax,QWORD PTR [rsp+0xa0]
  218308:	00 
  218309:	0f 82 74 16 00 00    	jb     219983 <openSelfDebugInfo+0x2f43>
        if (address_size != @sizeOf(usize)) return error.InvalidDebugInfo;
  21830f:	80 7c 24 1f 08       	cmp    BYTE PTR [rsp+0x1f],0x8
  218314:	66 bf 23 00          	mov    di,0x23
  218318:	0f 85 aa 17 00 00    	jne    219ac8 <openSelfDebugInfo+0x3088>
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  21831e:	48 63 7d 00          	movsxd rdi,DWORD PTR [rbp+0x0]
  218322:	b8 08 00 00 00       	mov    eax,0x8
  218327:	be 00 00 00 00       	mov    esi,0x0
  21832c:	ba 01 00 00 00       	mov    edx,0x1
  218331:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  218333:	48 89 c6             	mov    rsi,rax
  218336:	48 f7 de             	neg    rsi
  218339:	48 89 84 24 88 00 00 	mov    QWORD PTR [rsp+0x88],rax
  218340:	00 
  218341:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  218347:	b9 00 00 00 00       	mov    ecx,0x0
  21834c:	48 0f 46 f1          	cmovbe rsi,rcx
    pub fn getPos(self: *File) !usize {
        switch (builtin.os) {
            Os.linux, Os.macosx, Os.ios => {
                const result = posix.lseek(self.handle, 0, posix.SEEK_CUR);
                const err = posix.getErrno(result);
                if (err > 0) {
  218350:	48 85 f6             	test   rsi,rsi
  218353:	0f 85 33 17 00 00    	jne    219a8c <openSelfDebugInfo+0x304c>
            return self.items[0..self.len];
  218359:	48 8b 85 98 00 00 00 	mov    rax,QWORD PTR [rbp+0x98]
    for (st.abbrev_table_list.toSlice()) |*header| {
  218360:	48 85 c0             	test   rax,rax
  218363:	48 8b 54 24 48       	mov    rdx,QWORD PTR [rsp+0x48]
  218368:	74 24                	je     21838e <openSelfDebugInfo+0x194e>
  21836a:	4c 8b ad 88 00 00 00 	mov    r13,QWORD PTR [rbp+0x88]
        if (header.offset == abbrev_offset) {
  218371:	49 83 c5 08          	add    r13,0x8
  218375:	31 c9                	xor    ecx,ecx
  218377:	49 39 55 f8          	cmp    QWORD PTR [r13-0x8],rdx
  21837b:	0f 84 7d 08 00 00    	je     218bfe <openSelfDebugInfo+0x21be>
    for (st.abbrev_table_list.toSlice()) |*header| {
  218381:	48 83 c1 01          	add    rcx,0x1
  218385:	49 83 c5 28          	add    r13,0x28
  218389:	48 39 c1             	cmp    rcx,rax
  21838c:	72 e9                	jb     218377 <openSelfDebugInfo+0x1937>
    try st.self_exe_file.seekTo(st.debug_abbrev.offset + abbrev_offset);
  21838e:	48 8b 45 68          	mov    rax,QWORD PTR [rbp+0x68]
  218392:	48 8b 70 18          	mov    rsi,QWORD PTR [rax+0x18]
  218396:	48 01 d6             	add    rsi,rdx
  218399:	0f 88 3a 16 00 00    	js     2199d9 <openSelfDebugInfo+0x2f99>
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  21839f:	48 63 7d 00          	movsxd rdi,DWORD PTR [rbp+0x0]
  2183a3:	b8 08 00 00 00       	mov    eax,0x8
  2183a8:	31 d2                	xor    edx,edx
  2183aa:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  2183ac:	48 89 c1             	mov    rcx,rax
  2183af:	48 f7 d9             	neg    rcx
  2183b2:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  2183b8:	b8 00 00 00 00       	mov    eax,0x0
  2183bd:	48 0f 46 c8          	cmovbe rcx,rax
                if (err > 0) {
  2183c1:	48 85 c9             	test   rcx,rcx
  2183c4:	0f 85 be 18 00 00    	jne    219c88 <openSelfDebugInfo+0x3248>
    var in_file_stream = io.FileInStream.init(in_file);
  2183ca:	48 89 ac 24 88 01 00 	mov    QWORD PTR [rsp+0x188],rbp
  2183d1:	00 
  2183d2:	48 8d 05 67 38 00 00 	lea    rax,[rip+0x3867]        # 21bc40 <FileInStream_readFn>
  2183d9:	48 89 84 24 90 01 00 	mov    QWORD PTR [rsp+0x190],rax
  2183e0:	00 
  2183e1:	48 8b 85 a0 00 00 00 	mov    rax,QWORD PTR [rbp+0xa0]
            return Self{
  2183e8:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  2183ec:	c5 f9 7f 84 24 10 02 	vmovdqa XMMWORD PTR [rsp+0x210],xmm0
  2183f3:	00 00 
  2183f5:	48 c7 84 24 20 02 00 	mov    QWORD PTR [rsp+0x220],0x0
  2183fc:	00 00 00 00 00 
  218401:	48 89 84 24 30 02 00 	mov    QWORD PTR [rsp+0x230],rax
  218408:	00 
    var result = AbbrevTable.init(st.allocator());
  218409:	48 89 84 24 28 02 00 	mov    QWORD PTR [rsp+0x228],rax
  218410:	00 
            try self.readNoEof(result[0..]);
  218411:	48 8d 44 24 1f       	lea    rax,[rsp+0x1f]
  218416:	48 89 84 24 00 02 00 	mov    QWORD PTR [rsp+0x200],rax
  21841d:	00 
  21841e:	48 c7 84 24 08 02 00 	mov    QWORD PTR [rsp+0x208],0x1
  218425:	00 01 00 00 00 
        return self.file.read(buffer);
  21842a:	48 8b b4 24 88 01 00 	mov    rsi,QWORD PTR [rsp+0x188]
  218431:	00 
  218432:	48 8d 7c 24 50       	lea    rdi,[rsp+0x50]
  218437:	48 8d 94 24 00 02 00 	lea    rdx,[rsp+0x200]
  21843e:	00 
  21843f:	e8 cc 36 00 00       	call   21bb10 <File_read>
  218444:	c5 fa 6f 44 24 50    	vmovdqu xmm0,XMMWORD PTR [rsp+0x50]
  21844a:	c5 f9 7f 84 24 d0 00 	vmovdqa XMMWORD PTR [rsp+0xd0],xmm0
  218451:	00 00 
            return self.readFn(self, buffer);
  218453:	0f b7 8c 24 d0 00 00 	movzx  ecx,WORD PTR [rsp+0xd0]
  21845a:	00 
            const amt_read = try self.read(buf);
  21845b:	66 85 c9             	test   cx,cx
  21845e:	0f 85 eb 14 00 00    	jne    21994f <openSelfDebugInfo+0x2f0f>
  218464:	48 8b 84 24 d8 00 00 	mov    rax,QWORD PTR [rsp+0xd8]
  21846b:	00 
  21846c:	31 c9                	xor    ecx,ecx
  21846e:	48 89 8c 24 c0 01 00 	mov    QWORD PTR [rsp+0x1c0],rcx
  218475:	00 
  218476:	31 c9                	xor    ecx,ecx
  218478:	48 89 8c 24 a0 01 00 	mov    QWORD PTR [rsp+0x1a0],rcx
  21847f:	00 
  218480:	31 c9                	xor    ecx,ecx
  218482:	48 89 4c 24 40       	mov    QWORD PTR [rsp+0x40],rcx
  218487:	45 31 ed             	xor    r13d,r13d
            if (amt_read < buf.len) return error.EndOfStream;
  21848a:	48 3b 84 24 08 02 00 	cmp    rax,QWORD PTR [rsp+0x208]
  218491:	00 
  218492:	0f 82 ad 14 00 00    	jb     219945 <openSelfDebugInfo+0x2f05>
            return result[0];
  218498:	0f b6 44 24 1f       	movzx  eax,BYTE PTR [rsp+0x1f]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  21849d:	89 c2                	mov    edx,eax
  21849f:	83 e2 7f             	and    edx,0x7f
  2184a2:	44 89 ee             	mov    esi,r13d
  2184a5:	83 e6 3f             	and    esi,0x3f
  2184a8:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  2184ad:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  2184b2:	48 39 d6             	cmp    rsi,rdx
  2184b5:	0f 85 90 14 00 00    	jne    21994b <openSelfDebugInfo+0x2f0b>
        result |= operand;
  2184bb:	48 09 4c 24 40       	or     QWORD PTR [rsp+0x40],rcx
        if ((byte & 0b10000000) == 0) return result;
  2184c0:	84 c0                	test   al,al
  2184c2:	79 5a                	jns    21851e <openSelfDebugInfo+0x1ade>
        shift += 7;
  2184c4:	49 83 c5 07          	add    r13,0x7
            try self.readNoEof(result[0..]);
  2184c8:	48 8d 44 24 1f       	lea    rax,[rsp+0x1f]
  2184cd:	48 89 84 24 00 02 00 	mov    QWORD PTR [rsp+0x200],rax
  2184d4:	00 
  2184d5:	48 c7 84 24 08 02 00 	mov    QWORD PTR [rsp+0x208],0x1
  2184dc:	00 01 00 00 00 
            return self.readFn(self, buffer);
  2184e1:	48 8d bc 24 d0 00 00 	lea    rdi,[rsp+0xd0]
  2184e8:	00 
  2184e9:	48 8d b4 24 90 01 00 	lea    rsi,[rsp+0x190]
  2184f0:	00 
  2184f1:	48 8d 94 24 00 02 00 	lea    rdx,[rsp+0x200]
  2184f8:	00 
  2184f9:	ff 94 24 90 01 00 00 	call   QWORD PTR [rsp+0x190]
  218500:	0f b7 8c 24 d0 00 00 	movzx  ecx,WORD PTR [rsp+0xd0]
  218507:	00 
  218508:	48 8b 84 24 d8 00 00 	mov    rax,QWORD PTR [rsp+0xd8]
  21850f:	00 
            const amt_read = try self.read(buf);
  218510:	66 85 c9             	test   cx,cx
  218513:	0f 84 71 ff ff ff    	je     21848a <openSelfDebugInfo+0x1a4a>
  218519:	e9 31 14 00 00       	jmp    21994f <openSelfDebugInfo+0x2f0f>
        if (abbrev_code == 0) return result;
  21851e:	48 83 7c 24 40 00    	cmp    QWORD PTR [rsp+0x40],0x0
  218524:	0f 84 ca 05 00 00    	je     218af4 <openSelfDebugInfo+0x20b4>
            try self.readNoEof(result[0..]);
  21852a:	48 8d 44 24 1f       	lea    rax,[rsp+0x1f]
  21852f:	48 89 84 24 d0 00 00 	mov    QWORD PTR [rsp+0xd0],rax
  218536:	00 
  218537:	48 c7 84 24 d8 00 00 	mov    QWORD PTR [rsp+0xd8],0x1
  21853e:	00 01 00 00 00 
            return self.readFn(self, buffer);
  218543:	48 8d 7c 24 50       	lea    rdi,[rsp+0x50]
  218548:	48 8d b4 24 90 01 00 	lea    rsi,[rsp+0x190]
  21854f:	00 
  218550:	48 8d 94 24 d0 00 00 	lea    rdx,[rsp+0xd0]
  218557:	00 
  218558:	ff 94 24 90 01 00 00 	call   QWORD PTR [rsp+0x190]
  21855f:	0f b7 44 24 50       	movzx  eax,WORD PTR [rsp+0x50]
  218564:	89 c1                	mov    ecx,eax
            const amt_read = try self.read(buf);
  218566:	66 85 c0             	test   ax,ax
  218569:	0f 85 ff 14 00 00    	jne    219a6e <openSelfDebugInfo+0x302e>
  21856f:	48 8b 44 24 58       	mov    rax,QWORD PTR [rsp+0x58]
  218574:	31 c9                	xor    ecx,ecx
  218576:	48 89 8c 24 98 01 00 	mov    QWORD PTR [rsp+0x198],rcx
  21857d:	00 
  21857e:	45 31 ed             	xor    r13d,r13d
            if (amt_read < buf.len) return error.EndOfStream;
  218581:	48 3b 84 24 d8 00 00 	cmp    rax,QWORD PTR [rsp+0xd8]
  218588:	00 
  218589:	0f 82 d5 14 00 00    	jb     219a64 <openSelfDebugInfo+0x3024>
            return result[0];
  21858f:	0f b6 44 24 1f       	movzx  eax,BYTE PTR [rsp+0x1f]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  218594:	89 c2                	mov    edx,eax
  218596:	83 e2 7f             	and    edx,0x7f
  218599:	44 89 ee             	mov    esi,r13d
  21859c:	83 e6 3f             	and    esi,0x3f
  21859f:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  2185a4:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  2185a9:	48 39 d6             	cmp    rsi,rdx
  2185ac:	0f 85 b8 14 00 00    	jne    219a6a <openSelfDebugInfo+0x302a>
        result |= operand;
  2185b2:	48 09 8c 24 98 01 00 	or     QWORD PTR [rsp+0x198],rcx
  2185b9:	00 
        if ((byte & 0b10000000) == 0) return result;
  2185ba:	84 c0                	test   al,al
  2185bc:	79 53                	jns    218611 <openSelfDebugInfo+0x1bd1>
        shift += 7;
  2185be:	49 83 c5 07          	add    r13,0x7
            try self.readNoEof(result[0..]);
  2185c2:	48 8d 44 24 1f       	lea    rax,[rsp+0x1f]
  2185c7:	48 89 84 24 d0 00 00 	mov    QWORD PTR [rsp+0xd0],rax
  2185ce:	00 
  2185cf:	48 c7 84 24 d8 00 00 	mov    QWORD PTR [rsp+0xd8],0x1
  2185d6:	00 01 00 00 00 
            return self.readFn(self, buffer);
  2185db:	48 8d 7c 24 50       	lea    rdi,[rsp+0x50]
  2185e0:	48 8d b4 24 90 01 00 	lea    rsi,[rsp+0x190]
  2185e7:	00 
  2185e8:	48 8d 94 24 d0 00 00 	lea    rdx,[rsp+0xd0]
  2185ef:	00 
  2185f0:	ff 94 24 90 01 00 00 	call   QWORD PTR [rsp+0x190]
  2185f7:	0f b7 54 24 50       	movzx  edx,WORD PTR [rsp+0x50]
  2185fc:	48 8b 44 24 58       	mov    rax,QWORD PTR [rsp+0x58]
  218601:	89 d1                	mov    ecx,edx
            const amt_read = try self.read(buf);
  218603:	66 85 d2             	test   dx,dx
  218606:	0f 84 75 ff ff ff    	je     218581 <openSelfDebugInfo+0x1b41>
  21860c:	e9 5d 14 00 00       	jmp    219a6e <openSelfDebugInfo+0x302e>
            try self.readNoEof(result[0..]);
  218611:	48 8d 44 24 1f       	lea    rax,[rsp+0x1f]
  218616:	48 89 84 24 d0 00 00 	mov    QWORD PTR [rsp+0xd0],rax
  21861d:	00 
  21861e:	48 c7 84 24 d8 00 00 	mov    QWORD PTR [rsp+0xd8],0x1
  218625:	00 01 00 00 00 
            return self.readFn(self, buffer);
  21862a:	48 8d 7c 24 50       	lea    rdi,[rsp+0x50]
  21862f:	48 8d b4 24 90 01 00 	lea    rsi,[rsp+0x190]
  218636:	00 
  218637:	48 8d 94 24 d0 00 00 	lea    rdx,[rsp+0xd0]
  21863e:	00 
  21863f:	ff 94 24 90 01 00 00 	call   QWORD PTR [rsp+0x190]
  218646:	0f b7 44 24 50       	movzx  eax,WORD PTR [rsp+0x50]
  21864b:	89 c1                	mov    ecx,eax
            const amt_read = try self.read(buf);
  21864d:	66 85 c0             	test   ax,ax
  218650:	0f 85 f8 16 00 00    	jne    219d4e <openSelfDebugInfo+0x330e>
  218656:	48 8b 44 24 58       	mov    rax,QWORD PTR [rsp+0x58]
            if (amt_read < buf.len) return error.EndOfStream;
  21865b:	48 3b 84 24 d8 00 00 	cmp    rax,QWORD PTR [rsp+0xd8]
  218662:	00 
  218663:	0f 82 e1 16 00 00    	jb     219d4a <openSelfDebugInfo+0x330a>
  218669:	48 8b 85 a0 00 00 00 	mov    rax,QWORD PTR [rbp+0xa0]
  218670:	48 89 84 24 a8 01 00 	mov    QWORD PTR [rsp+0x1a8],rax
  218677:	00 
  218678:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  21867c:	c5 f9 7f 44 24 20    	vmovdqa XMMWORD PTR [rsp+0x20],xmm0
            return result[0];
  218682:	8a 44 24 1f          	mov    al,BYTE PTR [rsp+0x1f]
  218686:	88 84 24 ef 00 00 00 	mov    BYTE PTR [rsp+0xef],al
  21868d:	48 c7 44 24 30 00 00 	mov    QWORD PTR [rsp+0x30],0x0
  218694:	00 00 
            var better_capacity = self.items.len;
  218696:	48 8b 8c 24 18 02 00 	mov    rcx,QWORD PTR [rsp+0x218]
  21869d:	00 
            if (better_capacity >= new_capacity) return;
  21869e:	48 3b 8c 24 a0 01 00 	cmp    rcx,QWORD PTR [rsp+0x1a0]
  2186a5:	00 
  2186a6:	77 63                	ja     21870b <openSelfDebugInfo+0x1ccb>
                better_capacity += better_capacity / 2 + 8;
  2186a8:	48 89 c8             	mov    rax,rcx
  2186ab:	48 d1 e8             	shr    rax,1
  2186ae:	48 01 c1             	add    rcx,rax
  2186b1:	48 83 c1 08          	add    rcx,0x8
                if (better_capacity >= new_capacity) break;
  2186b5:	48 3b 8c 24 a0 01 00 	cmp    rcx,QWORD PTR [rsp+0x1a0]
  2186bc:	00 
  2186bd:	76 e9                	jbe    2186a8 <openSelfDebugInfo+0x1c68>
            self.items = try self.allocator.alignedRealloc(T, A, self.items, better_capacity);
  2186bf:	48 8d 7c 24 50       	lea    rdi,[rsp+0x50]
  2186c4:	48 8b b4 24 30 02 00 	mov    rsi,QWORD PTR [rsp+0x230]
  2186cb:	00 
  2186cc:	48 8d 94 24 10 02 00 	lea    rdx,[rsp+0x210]
  2186d3:	00 
  2186d4:	e8 97 35 00 00       	call   21bc70 <Allocator_alignedRealloc.53>
  2186d9:	0f b7 44 24 50       	movzx  eax,WORD PTR [rsp+0x50]
  2186de:	89 c1                	mov    ecx,eax
  2186e0:	66 85 c0             	test   ax,ax
  2186e3:	0f 85 9a 16 00 00    	jne    219d83 <openSelfDebugInfo+0x3343>
  2186e9:	48 8d 44 24 58       	lea    rax,[rsp+0x58]
  2186ee:	c5 fa 6f 00          	vmovdqu xmm0,XMMWORD PTR [rax]
  2186f2:	c5 f9 7f 84 24 10 02 	vmovdqa XMMWORD PTR [rsp+0x210],xmm0
  2186f9:	00 00 
            const result = &self.items[self.len];
  2186fb:	48 8b 84 24 10 02 00 	mov    rax,QWORD PTR [rsp+0x210]
  218702:	00 
            try self.ensureCapacity(new_length);
  218703:	48 89 84 24 c0 01 00 	mov    QWORD PTR [rsp+0x1c0],rax
  21870a:	00 
  21870b:	48 8b 84 24 a0 01 00 	mov    rax,QWORD PTR [rsp+0x1a0]
  218712:	00 
  218713:	48 89 c1             	mov    rcx,rax
            const result = &self.items[self.len];
  218716:	4c 6b e9 38          	imul   r13,rcx,0x38
  21871a:	48 83 c1 01          	add    rcx,0x1
  21871e:	48 89 c8             	mov    rax,rcx
            self.len = new_length;
  218721:	48 89 84 24 a0 01 00 	mov    QWORD PTR [rsp+0x1a0],rax
  218728:	00 
  218729:	48 89 8c 24 20 02 00 	mov    QWORD PTR [rsp+0x220],rcx
  218730:	00 
            .has_children = (try in_stream.readByte()) == DW.CHILDREN_yes,
  218731:	80 bc 24 ef 00 00 00 	cmp    BYTE PTR [rsp+0xef],0x1
  218738:	01 
  218739:	48 8b 84 24 c0 01 00 	mov    rax,QWORD PTR [rsp+0x1c0]
  218740:	00 
  218741:	48 89 c1             	mov    rcx,rax
            new_item_ptr.* = item;
  218744:	42 0f 94 04 29       	sete   BYTE PTR [rcx+r13*1]
  218749:	8a 84 24 3f 02 00 00 	mov    al,BYTE PTR [rsp+0x23f]
  218750:	42 88 44 29 07       	mov    BYTE PTR [rcx+r13*1+0x7],al
  218755:	0f b7 84 24 3d 02 00 	movzx  eax,WORD PTR [rsp+0x23d]
  21875c:	00 
  21875d:	66 42 89 44 29 05    	mov    WORD PTR [rcx+r13*1+0x5],ax
  218763:	8b 84 24 39 02 00 00 	mov    eax,DWORD PTR [rsp+0x239]
  21876a:	42 89 44 29 01       	mov    DWORD PTR [rcx+r13*1+0x1],eax
  21876f:	48 8b 44 24 40       	mov    rax,QWORD PTR [rsp+0x40]
  218774:	4a 89 44 29 08       	mov    QWORD PTR [rcx+r13*1+0x8],rax
  218779:	48 8b 84 24 98 01 00 	mov    rax,QWORD PTR [rsp+0x198]
  218780:	00 
  218781:	4a 89 44 29 10       	mov    QWORD PTR [rcx+r13*1+0x10],rax
  218786:	48 8b 44 24 30       	mov    rax,QWORD PTR [rsp+0x30]
  21878b:	4a 89 44 29 28       	mov    QWORD PTR [rcx+r13*1+0x28],rax
  218790:	c5 f9 6f 44 24 20    	vmovdqa xmm0,XMMWORD PTR [rsp+0x20]
  218796:	c4 a1 7a 7f 44 29 18 	vmovdqu XMMWORD PTR [rcx+r13*1+0x18],xmm0
  21879d:	48 8b 84 24 a8 01 00 	mov    rax,QWORD PTR [rsp+0x1a8]
  2187a4:	00 
  2187a5:	4a 89 44 29 30       	mov    QWORD PTR [rcx+r13*1+0x30],rax
            try self.readNoEof(result[0..]);
  2187aa:	48 8d 44 24 1f       	lea    rax,[rsp+0x1f]
  2187af:	48 89 84 24 d0 00 00 	mov    QWORD PTR [rsp+0xd0],rax
  2187b6:	00 
  2187b7:	48 c7 84 24 d8 00 00 	mov    QWORD PTR [rsp+0xd8],0x1
  2187be:	00 01 00 00 00 
            return self.readFn(self, buffer);
  2187c3:	48 8d 7c 24 50       	lea    rdi,[rsp+0x50]
  2187c8:	48 8d b4 24 90 01 00 	lea    rsi,[rsp+0x190]
  2187cf:	00 
  2187d0:	48 8d 94 24 d0 00 00 	lea    rdx,[rsp+0xd0]
  2187d7:	00 
  2187d8:	ff 94 24 90 01 00 00 	call   QWORD PTR [rsp+0x190]
  2187df:	0f b7 44 24 50       	movzx  eax,WORD PTR [rsp+0x50]
  2187e4:	89 c1                	mov    ecx,eax
            const amt_read = try self.read(buf);
  2187e6:	66 85 c0             	test   ax,ax
  2187e9:	0f 85 3d 15 00 00    	jne    219d2c <openSelfDebugInfo+0x32ec>
  2187ef:	48 8b 84 24 c0 01 00 	mov    rax,QWORD PTR [rsp+0x1c0]
  2187f6:	00 
  2187f7:	4c 01 e8             	add    rax,r13
  2187fa:	48 83 c0 18          	add    rax,0x18
  2187fe:	48 89 84 24 a8 01 00 	mov    QWORD PTR [rsp+0x1a8],rax
  218805:	00 
  218806:	48 8b 44 24 58       	mov    rax,QWORD PTR [rsp+0x58]
  21880b:	31 c9                	xor    ecx,ecx
  21880d:	48 89 8c 24 98 01 00 	mov    QWORD PTR [rsp+0x198],rcx
  218814:	00 
  218815:	45 31 ed             	xor    r13d,r13d
            if (amt_read < buf.len) return error.EndOfStream;
  218818:	48 3b 84 24 d8 00 00 	cmp    rax,QWORD PTR [rsp+0xd8]
  21881f:	00 
  218820:	0f 82 fc 14 00 00    	jb     219d22 <openSelfDebugInfo+0x32e2>
            return result[0];
  218826:	0f b6 44 24 1f       	movzx  eax,BYTE PTR [rsp+0x1f]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  21882b:	89 c2                	mov    edx,eax
  21882d:	83 e2 7f             	and    edx,0x7f
  218830:	44 89 ee             	mov    esi,r13d
  218833:	83 e6 3f             	and    esi,0x3f
  218836:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  21883b:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  218840:	48 39 d6             	cmp    rsi,rdx
  218843:	0f 85 df 14 00 00    	jne    219d28 <openSelfDebugInfo+0x32e8>
        result |= operand;
  218849:	48 09 8c 24 98 01 00 	or     QWORD PTR [rsp+0x198],rcx
  218850:	00 
        if ((byte & 0b10000000) == 0) return result;
  218851:	84 c0                	test   al,al
  218853:	0f 88 e5 00 00 00    	js     21893e <openSelfDebugInfo+0x1efe>
            try self.readNoEof(result[0..]);
  218859:	48 8d 44 24 1f       	lea    rax,[rsp+0x1f]
  21885e:	48 89 84 24 d0 00 00 	mov    QWORD PTR [rsp+0xd0],rax
  218865:	00 
  218866:	48 c7 84 24 d8 00 00 	mov    QWORD PTR [rsp+0xd8],0x1
  21886d:	00 01 00 00 00 
            return self.readFn(self, buffer);
  218872:	48 8d 7c 24 50       	lea    rdi,[rsp+0x50]
  218877:	48 8d b4 24 90 01 00 	lea    rsi,[rsp+0x190]
  21887e:	00 
  21887f:	48 8d 94 24 d0 00 00 	lea    rdx,[rsp+0xd0]
  218886:	00 
  218887:	ff 94 24 90 01 00 00 	call   QWORD PTR [rsp+0x190]
  21888e:	0f b7 44 24 50       	movzx  eax,WORD PTR [rsp+0x50]
  218893:	89 c1                	mov    ecx,eax
            const amt_read = try self.read(buf);
  218895:	66 85 c0             	test   ax,ax
  218898:	0f 85 66 14 00 00    	jne    219d04 <openSelfDebugInfo+0x32c4>
  21889e:	48 8b 44 24 58       	mov    rax,QWORD PTR [rsp+0x58]
  2188a3:	31 c9                	xor    ecx,ecx
  2188a5:	48 89 4c 24 40       	mov    QWORD PTR [rsp+0x40],rcx
  2188aa:	45 31 ed             	xor    r13d,r13d
            if (amt_read < buf.len) return error.EndOfStream;
  2188ad:	48 3b 84 24 d8 00 00 	cmp    rax,QWORD PTR [rsp+0xd8]
  2188b4:	00 
  2188b5:	0f 82 3f 14 00 00    	jb     219cfa <openSelfDebugInfo+0x32ba>
            return result[0];
  2188bb:	0f b6 44 24 1f       	movzx  eax,BYTE PTR [rsp+0x1f]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  2188c0:	89 c2                	mov    edx,eax
  2188c2:	83 e2 7f             	and    edx,0x7f
  2188c5:	44 89 ee             	mov    esi,r13d
  2188c8:	83 e6 3f             	and    esi,0x3f
  2188cb:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  2188d0:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  2188d5:	48 39 d6             	cmp    rsi,rdx
  2188d8:	0f 85 22 14 00 00    	jne    219d00 <openSelfDebugInfo+0x32c0>
        result |= operand;
  2188de:	48 09 4c 24 40       	or     QWORD PTR [rsp+0x40],rcx
        if ((byte & 0b10000000) == 0) return result;
  2188e3:	84 c0                	test   al,al
  2188e5:	0f 89 a6 00 00 00    	jns    218991 <openSelfDebugInfo+0x1f51>
        shift += 7;
  2188eb:	49 83 c5 07          	add    r13,0x7
            try self.readNoEof(result[0..]);
  2188ef:	48 8d 44 24 1f       	lea    rax,[rsp+0x1f]
  2188f4:	48 89 84 24 d0 00 00 	mov    QWORD PTR [rsp+0xd0],rax
  2188fb:	00 
  2188fc:	48 c7 84 24 d8 00 00 	mov    QWORD PTR [rsp+0xd8],0x1
  218903:	00 01 00 00 00 
            return self.readFn(self, buffer);
  218908:	48 8d 7c 24 50       	lea    rdi,[rsp+0x50]
  21890d:	48 8d b4 24 90 01 00 	lea    rsi,[rsp+0x190]
  218914:	00 
  218915:	48 8d 94 24 d0 00 00 	lea    rdx,[rsp+0xd0]
  21891c:	00 
  21891d:	ff 94 24 90 01 00 00 	call   QWORD PTR [rsp+0x190]
  218924:	0f b7 54 24 50       	movzx  edx,WORD PTR [rsp+0x50]
  218929:	48 8b 44 24 58       	mov    rax,QWORD PTR [rsp+0x58]
  21892e:	89 d1                	mov    ecx,edx
            const amt_read = try self.read(buf);
  218930:	66 85 d2             	test   dx,dx
  218933:	0f 84 74 ff ff ff    	je     2188ad <openSelfDebugInfo+0x1e6d>
  218939:	e9 c6 13 00 00       	jmp    219d04 <openSelfDebugInfo+0x32c4>
  21893e:	49 83 c5 07          	add    r13,0x7
            try self.readNoEof(result[0..]);
  218942:	48 8d 44 24 1f       	lea    rax,[rsp+0x1f]
  218947:	48 89 84 24 d0 00 00 	mov    QWORD PTR [rsp+0xd0],rax
  21894e:	00 
  21894f:	48 c7 84 24 d8 00 00 	mov    QWORD PTR [rsp+0xd8],0x1
  218956:	00 01 00 00 00 
            return self.readFn(self, buffer);
  21895b:	48 8d 7c 24 50       	lea    rdi,[rsp+0x50]
  218960:	48 8d b4 24 90 01 00 	lea    rsi,[rsp+0x190]
  218967:	00 
  218968:	48 8d 94 24 d0 00 00 	lea    rdx,[rsp+0xd0]
  21896f:	00 
  218970:	ff 94 24 90 01 00 00 	call   QWORD PTR [rsp+0x190]
  218977:	0f b7 54 24 50       	movzx  edx,WORD PTR [rsp+0x50]
  21897c:	48 8b 44 24 58       	mov    rax,QWORD PTR [rsp+0x58]
  218981:	89 d1                	mov    ecx,edx
            const amt_read = try self.read(buf);
  218983:	66 85 d2             	test   dx,dx
  218986:	0f 84 8c fe ff ff    	je     218818 <openSelfDebugInfo+0x1dd8>
  21898c:	e9 9b 13 00 00       	jmp    219d2c <openSelfDebugInfo+0x32ec>
            if (attr_id == 0 and form_id == 0) break;
  218991:	48 8b 44 24 40       	mov    rax,QWORD PTR [rsp+0x40]
  218996:	48 0b 84 24 98 01 00 	or     rax,QWORD PTR [rsp+0x198]
  21899d:	00 
  21899e:	0f 84 fa 00 00 00    	je     218a9e <openSelfDebugInfo+0x205e>
  2189a4:	48 8b 84 24 a8 01 00 	mov    rax,QWORD PTR [rsp+0x1a8]
  2189ab:	00 
            const new_length = self.len + 1;
  2189ac:	4c 8b 68 10          	mov    r13,QWORD PTR [rax+0x10]
            var better_capacity = self.items.len;
  2189b0:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
            if (better_capacity >= new_capacity) return;
  2189b4:	4c 39 e9             	cmp    rcx,r13
  2189b7:	76 05                	jbe    2189be <openSelfDebugInfo+0x1f7e>
            const result = &self.items[self.len];
  2189b9:	4c 89 e8             	mov    rax,r13
  2189bc:	eb 51                	jmp    218a0f <openSelfDebugInfo+0x1fcf>
                better_capacity += better_capacity / 2 + 8;
  2189be:	48 89 c8             	mov    rax,rcx
  2189c1:	48 d1 e8             	shr    rax,1
  2189c4:	48 01 c1             	add    rcx,rax
  2189c7:	48 83 c1 08          	add    rcx,0x8
                if (better_capacity >= new_capacity) break;
  2189cb:	4c 39 e9             	cmp    rcx,r13
  2189ce:	76 ee                	jbe    2189be <openSelfDebugInfo+0x1f7e>
  2189d0:	48 8b 94 24 a8 01 00 	mov    rdx,QWORD PTR [rsp+0x1a8]
  2189d7:	00 
            self.items = try self.allocator.alignedRealloc(T, A, self.items, better_capacity);
  2189d8:	48 8b 72 18          	mov    rsi,QWORD PTR [rdx+0x18]
  2189dc:	48 8d 7c 24 50       	lea    rdi,[rsp+0x50]
  2189e1:	e8 1a 35 00 00       	call   21bf00 <Allocator_alignedRealloc.56>
  2189e6:	0f b7 44 24 50       	movzx  eax,WORD PTR [rsp+0x50]
  2189eb:	89 c1                	mov    ecx,eax
  2189ed:	66 85 c0             	test   ax,ax
  2189f0:	0f 85 ab 13 00 00    	jne    219da1 <openSelfDebugInfo+0x3361>
  2189f6:	48 8d 44 24 58       	lea    rax,[rsp+0x58]
  2189fb:	c5 fa 6f 00          	vmovdqu xmm0,XMMWORD PTR [rax]
  2189ff:	48 8b 84 24 a8 01 00 	mov    rax,QWORD PTR [rsp+0x1a8]
  218a06:	00 
  218a07:	c5 fa 7f 00          	vmovdqu XMMWORD PTR [rax],xmm0
            const result = &self.items[self.len];
  218a0b:	48 8b 40 10          	mov    rax,QWORD PTR [rax+0x10]
  218a0f:	49 83 c5 01          	add    r13,0x1
  218a13:	48 8b 94 24 a8 01 00 	mov    rdx,QWORD PTR [rsp+0x1a8]
  218a1a:	00 
  218a1b:	48 8b 0a             	mov    rcx,QWORD PTR [rdx]
            self.len = new_length;
  218a1e:	4c 89 6a 10          	mov    QWORD PTR [rdx+0x10],r13
            new_item_ptr.* = item;
  218a22:	48 c1 e0 04          	shl    rax,0x4
  218a26:	48 8b 94 24 98 01 00 	mov    rdx,QWORD PTR [rsp+0x198]
  218a2d:	00 
  218a2e:	48 89 14 01          	mov    QWORD PTR [rcx+rax*1],rdx
  218a32:	48 8b 54 24 40       	mov    rdx,QWORD PTR [rsp+0x40]
  218a37:	48 89 54 01 08       	mov    QWORD PTR [rcx+rax*1+0x8],rdx
            try self.readNoEof(result[0..]);
  218a3c:	48 8d 44 24 1f       	lea    rax,[rsp+0x1f]
  218a41:	48 89 84 24 d0 00 00 	mov    QWORD PTR [rsp+0xd0],rax
  218a48:	00 
  218a49:	48 c7 84 24 d8 00 00 	mov    QWORD PTR [rsp+0xd8],0x1
  218a50:	00 01 00 00 00 
            return self.readFn(self, buffer);
  218a55:	48 8d 7c 24 50       	lea    rdi,[rsp+0x50]
  218a5a:	48 8d b4 24 90 01 00 	lea    rsi,[rsp+0x190]
  218a61:	00 
  218a62:	48 8d 94 24 d0 00 00 	lea    rdx,[rsp+0xd0]
  218a69:	00 
  218a6a:	ff 94 24 90 01 00 00 	call   QWORD PTR [rsp+0x190]
  218a71:	0f b7 54 24 50       	movzx  edx,WORD PTR [rsp+0x50]
  218a76:	48 8b 44 24 58       	mov    rax,QWORD PTR [rsp+0x58]
  218a7b:	b9 00 00 00 00       	mov    ecx,0x0
  218a80:	48 89 8c 24 98 01 00 	mov    QWORD PTR [rsp+0x198],rcx
  218a87:	00 
  218a88:	41 bd 00 00 00 00    	mov    r13d,0x0
  218a8e:	89 d1                	mov    ecx,edx
            const amt_read = try self.read(buf);
  218a90:	66 85 d2             	test   dx,dx
  218a93:	0f 84 7f fd ff ff    	je     218818 <openSelfDebugInfo+0x1dd8>
  218a99:	e9 8e 12 00 00       	jmp    219d2c <openSelfDebugInfo+0x32ec>
            try self.readNoEof(result[0..]);
  218a9e:	48 8d 44 24 1f       	lea    rax,[rsp+0x1f]
  218aa3:	48 89 84 24 00 02 00 	mov    QWORD PTR [rsp+0x200],rax
  218aaa:	00 
  218aab:	48 c7 84 24 08 02 00 	mov    QWORD PTR [rsp+0x208],0x1
  218ab2:	00 01 00 00 00 
            return self.readFn(self, buffer);
  218ab7:	48 8d bc 24 d0 00 00 	lea    rdi,[rsp+0xd0]
  218abe:	00 
  218abf:	48 8d b4 24 90 01 00 	lea    rsi,[rsp+0x190]
  218ac6:	00 
  218ac7:	48 8d 94 24 00 02 00 	lea    rdx,[rsp+0x200]
  218ace:	00 
  218acf:	ff 94 24 90 01 00 00 	call   QWORD PTR [rsp+0x190]
  218ad6:	0f b7 8c 24 d0 00 00 	movzx  ecx,WORD PTR [rsp+0xd0]
  218add:	00 
  218ade:	48 8b 84 24 d8 00 00 	mov    rax,QWORD PTR [rsp+0xd8]
  218ae5:	00 
            const amt_read = try self.read(buf);
  218ae6:	66 85 c9             	test   cx,cx
  218ae9:	0f 84 91 f9 ff ff    	je     218480 <openSelfDebugInfo+0x1a40>
  218aef:	e9 5b 0e 00 00       	jmp    21994f <openSelfDebugInfo+0x2f0f>
        if (abbrev_code == 0) return result;
  218af4:	c5 fc 10 84 24 10 02 	vmovups ymm0,YMMWORD PTR [rsp+0x210]
  218afb:	00 00 
  218afd:	48 8d 84 24 9e 00 00 	lea    rax,[rsp+0x9e]
  218b04:	00 
  218b05:	c5 fc 11 00          	vmovups YMMWORD PTR [rax],ymm0
  218b09:	c5 fc 10 84 24 98 00 	vmovups ymm0,YMMWORD PTR [rsp+0x98]
  218b10:	00 00 
  218b12:	c5 fc 11 84 24 d0 01 	vmovups YMMWORD PTR [rsp+0x1d0],ymm0
  218b19:	00 00 
  218b1b:	48 8b 84 24 b6 00 00 	mov    rax,QWORD PTR [rsp+0xb6]
  218b22:	00 
  218b23:	48 89 84 24 ee 01 00 	mov    QWORD PTR [rsp+0x1ee],rax
  218b2a:	00 
    try st.abbrev_table_list.append(AbbrevTableHeader{
  218b2b:	48 8d 84 24 d6 01 00 	lea    rax,[rsp+0x1d6]
  218b32:	00 
  218b33:	c5 fe 6f 00          	vmovdqu ymm0,YMMWORD PTR [rax]
  218b37:	c5 fe 7f 84 24 40 02 	vmovdqu YMMWORD PTR [rsp+0x240],ymm0
  218b3e:	00 00 
            const new_length = self.len + 1;
  218b40:	4c 8b ad 98 00 00 00 	mov    r13,QWORD PTR [rbp+0x98]
            var better_capacity = self.items.len;
  218b47:	48 8b 8d 90 00 00 00 	mov    rcx,QWORD PTR [rbp+0x90]
            if (better_capacity >= new_capacity) return;
  218b4e:	4c 39 e9             	cmp    rcx,r13
  218b51:	76 05                	jbe    218b58 <openSelfDebugInfo+0x2118>
            const result = &self.items[self.len];
  218b53:	4c 89 e8             	mov    rax,r13
  218b56:	eb 5e                	jmp    218bb6 <openSelfDebugInfo+0x2176>
                better_capacity += better_capacity / 2 + 8;
  218b58:	48 89 c8             	mov    rax,rcx
  218b5b:	48 d1 e8             	shr    rax,1
  218b5e:	48 01 c1             	add    rcx,rax
  218b61:	48 83 c1 08          	add    rcx,0x8
                if (better_capacity >= new_capacity) break;
  218b65:	4c 39 e9             	cmp    rcx,r13
  218b68:	76 ee                	jbe    218b58 <openSelfDebugInfo+0x2118>
            self.items = try self.allocator.alignedRealloc(T, A, self.items, better_capacity);
  218b6a:	48 8b b5 a0 00 00 00 	mov    rsi,QWORD PTR [rbp+0xa0]
  218b71:	48 89 df             	mov    rdi,rbx
  218b74:	48 8b 94 24 68 02 00 	mov    rdx,QWORD PTR [rsp+0x268]
  218b7b:	00 
  218b7c:	c5 f8 77             	vzeroupper 
  218b7f:	e8 dc 35 00 00       	call   21c160 <Allocator_alignedRealloc.59>
  218b84:	0f b7 8c 24 f0 00 00 	movzx  ecx,WORD PTR [rsp+0xf0]
  218b8b:	00 
  218b8c:	89 c8                	mov    eax,ecx
  218b8e:	66 85 c9             	test   cx,cx
  218b91:	0f 85 f0 0d 00 00    	jne    219987 <openSelfDebugInfo+0x2f47>
  218b97:	48 8d 84 24 f8 00 00 	lea    rax,[rsp+0xf8]
  218b9e:	00 
  218b9f:	c5 fa 6f 00          	vmovdqu xmm0,XMMWORD PTR [rax]
  218ba3:	48 8b 84 24 68 02 00 	mov    rax,QWORD PTR [rsp+0x268]
  218baa:	00 
  218bab:	c5 fa 7f 00          	vmovdqu XMMWORD PTR [rax],xmm0
            const result = &self.items[self.len];
  218baf:	48 8b 85 98 00 00 00 	mov    rax,QWORD PTR [rbp+0x98]
  218bb6:	49 83 c5 01          	add    r13,0x1
  218bba:	48 8b 8d 88 00 00 00 	mov    rcx,QWORD PTR [rbp+0x88]
            self.len = new_length;
  218bc1:	4c 89 ad 98 00 00 00 	mov    QWORD PTR [rbp+0x98],r13
            new_item_ptr.* = item;
  218bc8:	48 8d 04 80          	lea    rax,[rax+rax*4]
  218bcc:	48 8b 54 24 48       	mov    rdx,QWORD PTR [rsp+0x48]
  218bd1:	48 89 14 c1          	mov    QWORD PTR [rcx+rax*8],rdx
  218bd5:	c5 fe 6f 84 24 40 02 	vmovdqu ymm0,YMMWORD PTR [rsp+0x240]
  218bdc:	00 00 
  218bde:	c5 fe 7f 44 c1 08    	vmovdqu YMMWORD PTR [rcx+rax*8+0x8],ymm0
    return &st.abbrev_table_list.items[st.abbrev_table_list.len - 1].table;
  218be4:	48 8b 85 88 00 00 00 	mov    rax,QWORD PTR [rbp+0x88]
  218beb:	48 8b 8d 98 00 00 00 	mov    rcx,QWORD PTR [rbp+0x98]
  218bf2:	48 8d 0c 89          	lea    rcx,[rcx+rcx*4]
  218bf6:	4c 8d 2c c8          	lea    r13,[rax+rcx*8]
  218bfa:	49 83 c5 e0          	add    r13,0xffffffffffffffe0
  218bfe:	66 bf 04 00          	mov    di,0x4
  218c02:	48 83 bc 24 88 00 00 	cmp    QWORD PTR [rsp+0x88],0x0
  218c09:	00 00 
  218c0b:	0f 88 b7 0e 00 00    	js     219ac8 <openSelfDebugInfo+0x3088>
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  218c11:	48 63 7d 00          	movsxd rdi,DWORD PTR [rbp+0x0]
  218c15:	b8 08 00 00 00       	mov    eax,0x8
  218c1a:	31 d2                	xor    edx,edx
  218c1c:	48 8b b4 24 88 00 00 	mov    rsi,QWORD PTR [rsp+0x88]
  218c23:	00 
  218c24:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  218c26:	48 89 c1             	mov    rcx,rax
  218c29:	48 f7 d9             	neg    rcx
  218c2c:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  218c32:	b8 00 00 00 00       	mov    eax,0x0
  218c37:	48 0f 46 c8          	cmovbe rcx,rax
  218c3b:	48 85 c9             	test   rcx,rcx
  218c3e:	0f 85 bd 0d 00 00    	jne    219a01 <openSelfDebugInfo+0x2fc1>
  218c44:	48 8b 85 a0 00 00 00 	mov    rax,QWORD PTR [rbp+0xa0]
    var in_file_stream = io.FileInStream.init(in_file);
  218c4b:	48 89 84 24 c0 01 00 	mov    QWORD PTR [rsp+0x1c0],rax
  218c52:	00 
  218c53:	48 89 6c 24 50       	mov    QWORD PTR [rsp+0x50],rbp
  218c58:	48 8d 05 e1 2f 00 00 	lea    rax,[rip+0x2fe1]        # 21bc40 <FileInStream_readFn>
  218c5f:	48 89 44 24 58       	mov    QWORD PTR [rsp+0x58],rax
            try self.readNoEof(result[0..]);
  218c64:	48 8d 44 24 1f       	lea    rax,[rsp+0x1f]
  218c69:	48 89 84 24 40 02 00 	mov    QWORD PTR [rsp+0x240],rax
  218c70:	00 
  218c71:	48 c7 84 24 48 02 00 	mov    QWORD PTR [rsp+0x248],0x1
  218c78:	00 01 00 00 00 
        return self.file.read(buffer);
  218c7d:	48 8b 74 24 50       	mov    rsi,QWORD PTR [rsp+0x50]
  218c82:	48 8d bc 24 d0 01 00 	lea    rdi,[rsp+0x1d0]
  218c89:	00 
  218c8a:	48 8d 94 24 40 02 00 	lea    rdx,[rsp+0x240]
  218c91:	00 
  218c92:	c5 f8 77             	vzeroupper 
  218c95:	e8 76 2e 00 00       	call   21bb10 <File_read>
  218c9a:	c5 fa 6f 84 24 d0 01 	vmovdqu xmm0,XMMWORD PTR [rsp+0x1d0]
  218ca1:	00 00 
  218ca3:	c5 f9 7f 84 24 10 02 	vmovdqa XMMWORD PTR [rsp+0x210],xmm0
  218caa:	00 00 
            return self.readFn(self, buffer);
  218cac:	0f b7 84 24 10 02 00 	movzx  eax,WORD PTR [rsp+0x210]
  218cb3:	00 
  218cb4:	89 c1                	mov    ecx,eax
            const amt_read = try self.read(buf);
  218cb6:	66 85 c0             	test   ax,ax
  218cb9:	0f 85 e4 0c 00 00    	jne    2199a3 <openSelfDebugInfo+0x2f63>
  218cbf:	0f b6 84 24 80 00 00 	movzx  eax,BYTE PTR [rsp+0x80]
  218cc6:	00 
  218cc7:	48 89 84 24 98 01 00 	mov    QWORD PTR [rsp+0x198],rax
  218cce:	00 
  218ccf:	48 8d 04 c5 04 00 00 	lea    rax,[rax*8+0x4]
  218cd6:	00 
  218cd7:	48 89 84 24 30 02 00 	mov    QWORD PTR [rsp+0x230],rax
  218cde:	00 
  218cdf:	48 8b 84 24 18 02 00 	mov    rax,QWORD PTR [rsp+0x218]
  218ce6:	00 
  218ce7:	31 c9                	xor    ecx,ecx
  218ce9:	48 89 4c 24 48       	mov    QWORD PTR [rsp+0x48],rcx
  218cee:	31 c9                	xor    ecx,ecx
            if (amt_read < buf.len) return error.EndOfStream;
  218cf0:	48 89 4c 24 40       	mov    QWORD PTR [rsp+0x40],rcx
  218cf5:	48 3b 84 24 48 02 00 	cmp    rax,QWORD PTR [rsp+0x248]
  218cfc:	00 
  218cfd:	0f 82 96 0c 00 00    	jb     219999 <openSelfDebugInfo+0x2f59>
            return result[0];
  218d03:	0f b6 44 24 1f       	movzx  eax,BYTE PTR [rsp+0x1f]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  218d08:	89 c2                	mov    edx,eax
  218d0a:	83 e2 7f             	and    edx,0x7f
  218d0d:	48 8b 74 24 40       	mov    rsi,QWORD PTR [rsp+0x40]
  218d12:	83 e6 3f             	and    esi,0x3f
  218d15:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  218d1a:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  218d1f:	48 39 d6             	cmp    rsi,rdx
  218d22:	0f 85 77 0c 00 00    	jne    21999f <openSelfDebugInfo+0x2f5f>
        result |= operand;
  218d28:	48 09 4c 24 48       	or     QWORD PTR [rsp+0x48],rcx
        if ((byte & 0b10000000) == 0) return result;
  218d2d:	84 c0                	test   al,al
  218d2f:	79 58                	jns    218d89 <openSelfDebugInfo+0x2349>
        shift += 7;
  218d31:	48 83 44 24 40 07    	add    QWORD PTR [rsp+0x40],0x7
            try self.readNoEof(result[0..]);
  218d37:	48 8d 44 24 1f       	lea    rax,[rsp+0x1f]
  218d3c:	48 89 84 24 40 02 00 	mov    QWORD PTR [rsp+0x240],rax
  218d43:	00 
  218d44:	48 c7 84 24 48 02 00 	mov    QWORD PTR [rsp+0x248],0x1
  218d4b:	00 01 00 00 00 
            return self.readFn(self, buffer);
  218d50:	48 8d bc 24 10 02 00 	lea    rdi,[rsp+0x210]
  218d57:	00 
  218d58:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  218d5d:	48 8d 94 24 40 02 00 	lea    rdx,[rsp+0x240]
  218d64:	00 
  218d65:	ff 54 24 58          	call   QWORD PTR [rsp+0x58]
  218d69:	0f b7 94 24 10 02 00 	movzx  edx,WORD PTR [rsp+0x210]
  218d70:	00 
  218d71:	48 8b 84 24 18 02 00 	mov    rax,QWORD PTR [rsp+0x218]
  218d78:	00 
  218d79:	89 d1                	mov    ecx,edx
            const amt_read = try self.read(buf);
  218d7b:	66 85 d2             	test   dx,dx
  218d7e:	0f 84 71 ff ff ff    	je     218cf5 <openSelfDebugInfo+0x22b5>
  218d84:	e9 1a 0c 00 00       	jmp    2199a3 <openSelfDebugInfo+0x2f63>
            return self.items[0..self.len];
  218d89:	49 8b 45 10          	mov    rax,QWORD PTR [r13+0x10]
    for (abbrev_table.toSliceConst()) |*table_entry| {
  218d8d:	48 85 c0             	test   rax,rax
  218d90:	0f 84 9c 0c 00 00    	je     219a32 <openSelfDebugInfo+0x2ff2>
  218d96:	4d 8b 6d 00          	mov    r13,QWORD PTR [r13+0x0]
  218d9a:	31 c9                	xor    ecx,ecx
        if (table_entry.abbrev_code == abbrev_code) return table_entry;
  218d9c:	48 8b 54 24 48       	mov    rdx,QWORD PTR [rsp+0x48]
  218da1:	49 39 55 08          	cmp    QWORD PTR [r13+0x8],rdx
  218da5:	74 12                	je     218db9 <openSelfDebugInfo+0x2379>
    for (abbrev_table.toSliceConst()) |*table_entry| {
  218da7:	48 83 c1 01          	add    rcx,0x1
  218dab:	49 83 c5 38          	add    r13,0x38
  218daf:	48 39 c1             	cmp    rcx,rax
  218db2:	72 e8                	jb     218d9c <openSelfDebugInfo+0x235c>
  218db4:	e9 79 0c 00 00       	jmp    219a32 <openSelfDebugInfo+0x2ff2>
    const table_entry = getAbbrevTableEntry(abbrev_table, abbrev_code) orelse return error.InvalidDebugInfo;
  218db9:	4d 85 ed             	test   r13,r13
  218dbc:	0f 84 70 0c 00 00    	je     219a32 <openSelfDebugInfo+0x2ff2>
        .tag_id = table_entry.tag_id,
  218dc2:	49 8b 45 10          	mov    rax,QWORD PTR [r13+0x10]
        .has_children = table_entry.has_children,
  218dc6:	41 8a 4d 00          	mov    cl,BYTE PTR [r13+0x0]
  218dca:	48 8b b5 a0 00 00 00 	mov    rsi,QWORD PTR [rbp+0xa0]
  218dd1:	48 8d 94 24 57 03 00 	lea    rdx,[rsp+0x357]
  218dd8:	00 
    var result = Die{
  218dd9:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  218ddd:	c5 fa 7f 02          	vmovdqu XMMWORD PTR [rdx],xmm0
  218de1:	48 c7 42 10 00 00 00 	mov    QWORD PTR [rdx+0x10],0x0
  218de8:	00 
  218de9:	48 89 84 24 88 02 00 	mov    QWORD PTR [rsp+0x288],rax
  218df0:	00 
  218df1:	88 8c 24 90 02 00 00 	mov    BYTE PTR [rsp+0x290],cl
  218df8:	c5 fa 6f 84 24 50 03 	vmovdqu xmm0,XMMWORD PTR [rsp+0x350]
  218dff:	00 00 
  218e01:	c5 fa 6f 8c 24 5f 03 	vmovdqu xmm1,XMMWORD PTR [rsp+0x35f]
  218e08:	00 00 
  218e0a:	48 8d 84 24 91 02 00 	lea    rax,[rsp+0x291]
  218e11:	00 
  218e12:	c5 fa 7f 48 0f       	vmovdqu XMMWORD PTR [rax+0xf],xmm1
  218e17:	c5 fa 7f 00          	vmovdqu XMMWORD PTR [rax],xmm0
  218e1b:	48 89 b4 24 b0 02 00 	mov    QWORD PTR [rsp+0x2b0],rsi
  218e22:	00 
    try result.attrs.resize(table_entry.attrs.len);
  218e23:	49 8b 45 28          	mov    rax,QWORD PTR [r13+0x28]
            var better_capacity = self.items.len;
  218e27:	48 8b 8c 24 a0 02 00 	mov    rcx,QWORD PTR [rsp+0x2a0]
  218e2e:	00 
  218e2f:	48 89 44 24 40       	mov    QWORD PTR [rsp+0x40],rax
            if (better_capacity >= new_capacity) return;
  218e34:	48 39 c1             	cmp    rcx,rax
  218e37:	73 5b                	jae    218e94 <openSelfDebugInfo+0x2454>
                better_capacity += better_capacity / 2 + 8;
  218e39:	48 89 c8             	mov    rax,rcx
  218e3c:	48 d1 e8             	shr    rax,1
  218e3f:	48 01 c1             	add    rcx,rax
  218e42:	48 83 c1 08          	add    rcx,0x8
                if (better_capacity >= new_capacity) break;
  218e46:	48 3b 4c 24 40       	cmp    rcx,QWORD PTR [rsp+0x40]
  218e4b:	72 ec                	jb     218e39 <openSelfDebugInfo+0x23f9>
            self.items = try self.allocator.alignedRealloc(T, A, self.items, better_capacity);
  218e4d:	48 8d bc 24 d0 01 00 	lea    rdi,[rsp+0x1d0]
  218e54:	00 
  218e55:	48 8d 94 24 98 02 00 	lea    rdx,[rsp+0x298]
  218e5c:	00 
  218e5d:	e8 8e 60 00 00       	call   21eef0 <Allocator_alignedRealloc.62>
  218e62:	0f b7 8c 24 d0 01 00 	movzx  ecx,WORD PTR [rsp+0x1d0]
  218e69:	00 
  218e6a:	89 c8                	mov    eax,ecx
  218e6c:	66 85 c9             	test   cx,cx
  218e6f:	0f 85 f7 0e 00 00    	jne    219d6c <openSelfDebugInfo+0x332c>
  218e75:	48 8d 84 24 d6 01 00 	lea    rax,[rsp+0x1d6]
  218e7c:	00 
  218e7d:	c5 fa 6f 40 02       	vmovdqu xmm0,XMMWORD PTR [rax+0x2]
  218e82:	48 8d 84 24 98 02 00 	lea    rax,[rsp+0x298]
  218e89:	00 
  218e8a:	c5 fa 7f 00          	vmovdqu XMMWORD PTR [rax],xmm0
            return self.items[0..self.len];
  218e8e:	49 8b 45 28          	mov    rax,QWORD PTR [r13+0x28]
  218e92:	eb 05                	jmp    218e99 <openSelfDebugInfo+0x2459>
  218e94:	48 8b 44 24 40       	mov    rax,QWORD PTR [rsp+0x40]
  218e99:	48 89 84 24 a0 01 00 	mov    QWORD PTR [rsp+0x1a0],rax
  218ea0:	00 
            self.len = new_len;
  218ea1:	48 8b 44 24 40       	mov    rax,QWORD PTR [rsp+0x40]
  218ea6:	48 89 84 24 a8 02 00 	mov    QWORD PTR [rsp+0x2a8],rax
  218ead:	00 
    for (table_entry.attrs.toSliceConst()) |attr, i| {
  218eae:	48 83 bc 24 a0 01 00 	cmp    QWORD PTR [rsp+0x1a0],0x0
  218eb5:	00 00 
  218eb7:	0f 84 c7 00 00 00    	je     218f84 <openSelfDebugInfo+0x2544>
  218ebd:	49 8b 45 18          	mov    rax,QWORD PTR [r13+0x18]
  218ec1:	4c 8b ac 24 98 02 00 	mov    r13,QWORD PTR [rsp+0x298]
  218ec8:	00 
  218ec9:	48 83 c0 08          	add    rax,0x8
  218ecd:	48 89 44 24 40       	mov    QWORD PTR [rsp+0x40],rax
  218ed2:	49 83 c5 08          	add    r13,0x8
  218ed6:	31 c0                	xor    eax,eax
  218ed8:	48 89 44 24 48       	mov    QWORD PTR [rsp+0x48],rax
  218edd:	48 8b 44 24 40       	mov    rax,QWORD PTR [rsp+0x40]
  218ee2:	48 8b 48 f8          	mov    rcx,QWORD PTR [rax-0x8]
  218ee6:	48 89 8c 24 88 00 00 	mov    QWORD PTR [rsp+0x88],rcx
  218eed:	00 
  218eee:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  218ef1:	48 8b b5 a0 00 00 00 	mov    rsi,QWORD PTR [rbp+0xa0]
            .value = try parseFormValue(st.allocator(), in_stream, attr.form_id, is_64),
  218ef8:	48 8d bc 24 78 03 00 	lea    rdi,[rsp+0x378]
  218eff:	00 
  218f00:	48 8d 54 24 58       	lea    rdx,[rsp+0x58]
  218f05:	4c 8b 84 24 98 01 00 	mov    r8,QWORD PTR [rsp+0x198]
  218f0c:	00 
  218f0d:	c5 f8 77             	vzeroupper 
  218f10:	e8 db 34 00 00       	call   21c3f0 <parseFormValue>
  218f15:	0f b7 8c 24 78 03 00 	movzx  ecx,WORD PTR [rsp+0x378]
  218f1c:	00 
  218f1d:	89 c8                	mov    eax,ecx
  218f1f:	66 85 c9             	test   cx,cx
  218f22:	0f 85 9c 0d 00 00    	jne    219cc4 <openSelfDebugInfo+0x3284>
        result.attrs.items[i] = Die.Attr{
  218f28:	48 8d 84 24 80 03 00 	lea    rax,[rsp+0x380]
  218f2f:	00 
  218f30:	c5 fc 10 00          	vmovups ymm0,YMMWORD PTR [rax]
  218f34:	c5 fc 11 84 24 a0 03 	vmovups YMMWORD PTR [rsp+0x3a0],ymm0
  218f3b:	00 00 
  218f3d:	48 8b 84 24 88 00 00 	mov    rax,QWORD PTR [rsp+0x88]
  218f44:	00 
  218f45:	49 89 45 f8          	mov    QWORD PTR [r13-0x8],rax
  218f49:	c5 fe 6f 84 24 a0 03 	vmovdqu ymm0,YMMWORD PTR [rsp+0x3a0]
  218f50:	00 00 
  218f52:	c4 c1 7e 7f 45 00    	vmovdqu YMMWORD PTR [r13+0x0],ymm0
  218f58:	48 8b 44 24 48       	mov    rax,QWORD PTR [rsp+0x48]
  218f5d:	48 89 c1             	mov    rcx,rax
    for (table_entry.attrs.toSliceConst()) |attr, i| {
  218f60:	48 83 c1 01          	add    rcx,0x1
  218f64:	48 83 44 24 40 10    	add    QWORD PTR [rsp+0x40],0x10
  218f6a:	49 83 c5 28          	add    r13,0x28
  218f6e:	48 89 c8             	mov    rax,rcx
  218f71:	48 89 44 24 48       	mov    QWORD PTR [rsp+0x48],rax
  218f76:	48 3b 8c 24 a0 01 00 	cmp    rcx,QWORD PTR [rsp+0x1a0]
  218f7d:	00 
  218f7e:	0f 82 59 ff ff ff    	jb     218edd <openSelfDebugInfo+0x249d>
    return result;
  218f84:	c5 fc 10 84 24 88 02 	vmovups ymm0,YMMWORD PTR [rsp+0x288]
  218f8b:	00 00 
  218f8d:	c5 fc 10 8c 24 98 02 	vmovups ymm1,YMMWORD PTR [rsp+0x298]
  218f94:	00 00 
  218f96:	48 8d 84 24 6e 04 00 	lea    rax,[rsp+0x46e]
  218f9d:	00 
  218f9e:	c5 fc 11 48 10       	vmovups YMMWORD PTR [rax+0x10],ymm1
  218fa3:	c5 fc 11 00          	vmovups YMMWORD PTR [rax],ymm0
  218fa7:	c5 fc 10 84 24 68 04 	vmovups ymm0,YMMWORD PTR [rsp+0x468]
  218fae:	00 00 
  218fb0:	c5 fc 10 8c 24 7e 04 	vmovups ymm1,YMMWORD PTR [rsp+0x47e]
  218fb7:	00 00 
  218fb9:	c5 fc 11 84 24 c0 02 	vmovups YMMWORD PTR [rsp+0x2c0],ymm0
  218fc0:	00 00 
  218fc2:	c5 fc 11 8c 24 d6 02 	vmovups YMMWORD PTR [rsp+0x2d6],ymm1
  218fc9:	00 00 
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  218fcb:	ba 30 00 00 00       	mov    edx,0x30
  218fd0:	b9 08 00 00 00       	mov    ecx,0x8
  218fd5:	48 89 df             	mov    rdi,rbx
  218fd8:	48 8b b4 24 c0 01 00 	mov    rsi,QWORD PTR [rsp+0x1c0]
  218fdf:	00 
  218fe0:	c5 f8 77             	vzeroupper 
  218fe3:	ff 16                	call   QWORD PTR [rsi]
  218fe5:	0f b7 8c 24 f0 00 00 	movzx  ecx,WORD PTR [rsp+0xf0]
  218fec:	00 
  218fed:	89 c8                	mov    eax,ecx
  218fef:	66 85 c9             	test   cx,cx
  218ff2:	0f 85 8f 09 00 00    	jne    219987 <openSelfDebugInfo+0x2f47>
        assert(byte_slice.len == byte_count);
  218ff8:	48 83 bc 24 00 01 00 	cmp    QWORD PTR [rsp+0x100],0x30
  218fff:	00 30 
    if (!ok) {
  219001:	0f 85 9d 1a 00 00    	jne    21aaa4 <openSelfDebugInfo+0x4064>
  219007:	48 8b 8c 24 f8 00 00 	mov    rcx,QWORD PTR [rsp+0xf8]
  21900e:	00 
  21900f:	48 8d 84 24 c6 02 00 	lea    rax,[rsp+0x2c6]
  219016:	00 
        ptr.* = init;
  219017:	c5 fe 6f 00          	vmovdqu ymm0,YMMWORD PTR [rax]
  21901b:	c5 fe 6f 48 10       	vmovdqu ymm1,YMMWORD PTR [rax+0x10]
  219020:	c5 fe 7f 01          	vmovdqu YMMWORD PTR [rcx],ymm0
  219024:	c5 fe 7f 49 10       	vmovdqu YMMWORD PTR [rcx+0x10],ymm1
  219029:	48 89 4c 24 40       	mov    QWORD PTR [rsp+0x40],rcx
        if (compile_unit_die.tag_id != DW.TAG_compile_unit) return error.InvalidDebugInfo;
  21902e:	48 83 39 11          	cmp    QWORD PTR [rcx],0x11
  219032:	0f 85 b5 09 00 00    	jne    2199ed <openSelfDebugInfo+0x2fad>
  219038:	48 8b 44 24 40       	mov    rax,QWORD PTR [rsp+0x40]
  21903d:	48 8b 40 20          	mov    rax,QWORD PTR [rax+0x20]
        for (self.attrs.toSliceConst()) |*attr| {
  219041:	48 85 c0             	test   rax,rax
  219044:	74 25                	je     21906b <openSelfDebugInfo+0x262b>
  219046:	48 8b 4c 24 40       	mov    rcx,QWORD PTR [rsp+0x40]
  21904b:	48 8b 51 10          	mov    rdx,QWORD PTR [rcx+0x10]
  21904f:	48 89 d1             	mov    rcx,rdx
  219052:	31 f6                	xor    esi,esi
            if (attr.id == id) return &attr.value;
  219054:	48 83 39 11          	cmp    QWORD PTR [rcx],0x11
  219058:	0f 84 52 01 00 00    	je     2191b0 <openSelfDebugInfo+0x2770>
        for (self.attrs.toSliceConst()) |*attr| {
  21905e:	48 83 c6 01          	add    rsi,0x1
  219062:	48 83 c1 28          	add    rcx,0x28
  219066:	48 39 c6             	cmp    rsi,rax
  219069:	72 e9                	jb     219054 <openSelfDebugInfo+0x2614>
        const pc_range = x: {
  21906b:	48 8d 0d 7e ef fe ff 	lea    rcx,[rip+0xfffffffffffeef7e]        # 207ff0 <__unnamed_66>
  219072:	48 8b 41 10          	mov    rax,QWORD PTR [rcx+0x10]
  219076:	48 89 84 24 60 04 00 	mov    QWORD PTR [rsp+0x460],rax
  21907d:	00 
  21907e:	c5 fa 6f 01          	vmovdqu xmm0,XMMWORD PTR [rcx]
  219082:	c5 f9 7f 84 24 50 04 	vmovdqa XMMWORD PTR [rsp+0x450],xmm0
  219089:	00 00 
            const new_length = self.len + 1;
  21908b:	4c 8b ad b8 00 00 00 	mov    r13,QWORD PTR [rbp+0xb8]
            var better_capacity = self.items.len;
  219092:	48 8b 8d b0 00 00 00 	mov    rcx,QWORD PTR [rbp+0xb0]
            if (better_capacity >= new_capacity) return;
  219099:	4c 39 e9             	cmp    rcx,r13
  21909c:	76 05                	jbe    2190a3 <openSelfDebugInfo+0x2663>
            const result = &self.items[self.len];
  21909e:	4c 89 e8             	mov    rax,r13
  2190a1:	eb 58                	jmp    2190fb <openSelfDebugInfo+0x26bb>
                better_capacity += better_capacity / 2 + 8;
  2190a3:	48 89 c8             	mov    rax,rcx
  2190a6:	48 d1 e8             	shr    rax,1
  2190a9:	48 01 c1             	add    rcx,rax
  2190ac:	48 83 c1 08          	add    rcx,0x8
                if (better_capacity >= new_capacity) break;
  2190b0:	4c 39 e9             	cmp    rcx,r13
  2190b3:	76 ee                	jbe    2190a3 <openSelfDebugInfo+0x2663>
            self.items = try self.allocator.alignedRealloc(T, A, self.items, better_capacity);
  2190b5:	48 8b b5 c0 00 00 00 	mov    rsi,QWORD PTR [rbp+0xc0]
  2190bc:	48 89 df             	mov    rdi,rbx
  2190bf:	48 8b 54 24 70       	mov    rdx,QWORD PTR [rsp+0x70]
  2190c4:	c5 f8 77             	vzeroupper 
  2190c7:	e8 b4 63 00 00       	call   21f480 <Allocator_alignedRealloc.69>
  2190cc:	0f b7 8c 24 f0 00 00 	movzx  ecx,WORD PTR [rsp+0xf0]
  2190d3:	00 
  2190d4:	89 c8                	mov    eax,ecx
  2190d6:	66 85 c9             	test   cx,cx
  2190d9:	0f 85 a8 08 00 00    	jne    219987 <openSelfDebugInfo+0x2f47>
  2190df:	48 8d 84 24 f8 00 00 	lea    rax,[rsp+0xf8]
  2190e6:	00 
  2190e7:	c5 fa 6f 00          	vmovdqu xmm0,XMMWORD PTR [rax]
  2190eb:	48 8b 44 24 70       	mov    rax,QWORD PTR [rsp+0x70]
  2190f0:	c5 fa 7f 00          	vmovdqu XMMWORD PTR [rax],xmm0
            const result = &self.items[self.len];
  2190f4:	48 8b 85 b8 00 00 00 	mov    rax,QWORD PTR [rbp+0xb8]
  2190fb:	49 83 c5 01          	add    r13,0x1
  2190ff:	48 8b 8d a8 00 00 00 	mov    rcx,QWORD PTR [rbp+0xa8]
  219106:	48 8d 04 40          	lea    rax,[rax+rax*2]
  21910a:	48 c1 e0 04          	shl    rax,0x4
            self.len = new_length;
  21910e:	4c 89 ad b8 00 00 00 	mov    QWORD PTR [rbp+0xb8],r13
            new_item_ptr.* = item;
  219115:	48 8b 94 24 f8 02 00 	mov    rdx,QWORD PTR [rsp+0x2f8]
  21911c:	00 
  21911d:	66 89 14 01          	mov    WORD PTR [rcx+rax*1],dx
  219121:	8b 94 24 80 00 00 00 	mov    edx,DWORD PTR [rsp+0x80]
  219128:	88 54 01 02          	mov    BYTE PTR [rcx+rax*1+0x2],dl
  21912c:	8a 94 24 67 02 00 00 	mov    dl,BYTE PTR [rsp+0x267]
  219133:	88 54 01 07          	mov    BYTE PTR [rcx+rax*1+0x7],dl
  219137:	8b 94 24 63 02 00 00 	mov    edx,DWORD PTR [rsp+0x263]
  21913e:	89 54 01 03          	mov    DWORD PTR [rcx+rax*1+0x3],edx
  219142:	48 8b 54 24 40       	mov    rdx,QWORD PTR [rsp+0x40]
  219147:	48 89 54 01 08       	mov    QWORD PTR [rcx+rax*1+0x8],rdx
  21914c:	48 8b 94 24 80 01 00 	mov    rdx,QWORD PTR [rsp+0x180]
  219153:	00 
  219154:	48 89 d6             	mov    rsi,rdx
  219157:	48 89 74 01 10       	mov    QWORD PTR [rcx+rax*1+0x10],rsi
  21915c:	48 8b 94 24 60 04 00 	mov    rdx,QWORD PTR [rsp+0x460]
  219163:	00 
  219164:	48 89 54 01 28       	mov    QWORD PTR [rcx+rax*1+0x28],rdx
  219169:	c5 f9 6f 84 24 50 04 	vmovdqa xmm0,XMMWORD PTR [rsp+0x450]
  219170:	00 00 
  219172:	c5 fa 7f 44 01 18    	vmovdqu XMMWORD PTR [rcx+rax*1+0x18],xmm0
  219178:	48 8b 44 24 78       	mov    rax,QWORD PTR [rsp+0x78]
        const next_offset = unit_length + (if (is_64) usize(12) else usize(4));
  21917d:	48 03 44 24 68       	add    rax,QWORD PTR [rsp+0x68]
        this_unit_offset += next_offset;
  219182:	48 03 84 24 30 02 00 	add    rax,QWORD PTR [rsp+0x230]
  219189:	00 
        cu_index += 1;
  21918a:	48 83 c6 01          	add    rsi,0x1
  21918e:	48 89 b4 24 80 01 00 	mov    QWORD PTR [rsp+0x180],rsi
  219195:	00 
  219196:	31 ff                	xor    edi,edi
  219198:	48 89 44 24 68       	mov    QWORD PTR [rsp+0x68],rax
    while (this_unit_offset < debug_info_end) {
  21919d:	48 3b 84 24 90 00 00 	cmp    rax,QWORD PTR [rsp+0x90]
  2191a4:	00 
  2191a5:	0f 82 11 ee ff ff    	jb     217fbc <openSelfDebugInfo+0x157c>
  2191ab:	e9 18 09 00 00       	jmp    219ac8 <openSelfDebugInfo+0x3088>
        return switch (form_value.*) {
  2191b0:	40 8a 79 20          	mov    dil,BYTE PTR [rcx+0x20]
  2191b4:	48 8d 35 a5 76 fe ff 	lea    rsi,[rip+0xfffffffffffe76a5]        # 200860 <__unnamed_67>
  2191bb:	40 84 ff             	test   dil,dil
  2191be:	75 19                	jne    2191d9 <openSelfDebugInfo+0x2799>
            FormValue.Address => |value| value,
  2191c0:	48 8b 49 08          	mov    rcx,QWORD PTR [rcx+0x8]
  2191c4:	66 c7 84 24 f0 00 00 	mov    WORD PTR [rsp+0xf0],0x0
  2191cb:	00 00 00 
  2191ce:	48 89 8c 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],rcx
  2191d5:	00 
  2191d6:	48 89 de             	mov    rsi,rbx
            if (compile_unit_die.getAttrAddr(DW.AT_low_pc)) |low_pc| {
  2191d9:	0f b7 3e             	movzx  edi,WORD PTR [rsi]
        const pc_range = x: {
  2191dc:	48 8d 0d 0d ee fe ff 	lea    rcx,[rip+0xfffffffffffeee0d]        # 207ff0 <__unnamed_66>
  2191e3:	41 89 f8             	mov    r8d,edi
            if (compile_unit_die.getAttrAddr(DW.AT_low_pc)) |low_pc| {
  2191e6:	83 ff 22             	cmp    edi,0x22
  2191e9:	0f 84 83 fe ff ff    	je     219072 <openSelfDebugInfo+0x2632>
  2191ef:	44 89 c7             	mov    edi,r8d
  2191f2:	66 85 ff             	test   di,di
  2191f5:	0f 85 cd 08 00 00    	jne    219ac8 <openSelfDebugInfo+0x3088>
  2191fb:	4c 8b 4e 08          	mov    r9,QWORD PTR [rsi+0x8]
            if (attr.id == id) return &attr.value;
  2191ff:	48 83 c2 20          	add    rdx,0x20
  219203:	31 c9                	xor    ecx,ecx
  219205:	48 83 7a e0 12       	cmp    QWORD PTR [rdx-0x20],0x12
  21920a:	74 12                	je     21921e <openSelfDebugInfo+0x27de>
        for (self.attrs.toSliceConst()) |*attr| {
  21920c:	48 83 c1 01          	add    rcx,0x1
  219210:	48 83 c2 28          	add    rdx,0x28
  219214:	48 39 c1             	cmp    rcx,rax
  219217:	72 ec                	jb     219205 <openSelfDebugInfo+0x27c5>
  219219:	e9 4d fe ff ff       	jmp    21906b <openSelfDebugInfo+0x262b>
  21921e:	8a 02                	mov    al,BYTE PTR [rdx]
  219220:	3c 02                	cmp    al,0x2
                    const pc_end = switch (high_pc_value.*) {
  219222:	74 15                	je     219239 <openSelfDebugInfo+0x27f9>
  219224:	66 bf 23 00          	mov    di,0x23
  219228:	84 c0                	test   al,al
  21922a:	0f 85 98 08 00 00    	jne    219ac8 <openSelfDebugInfo+0x3088>
                        FormValue.Address => |value| value,
  219230:	48 8b 42 e8          	mov    rax,QWORD PTR [rdx-0x18]
  219234:	e9 33 02 00 00       	jmp    21946c <openSelfDebugInfo+0x2a2c>
                        FormValue.Const => |value| b: {
  219239:	4c 8b 52 f0          	mov    r10,QWORD PTR [rdx-0x10]
        if (self.payload.len > @sizeOf(u64)) return error.InvalidDebugInfo;
  21923d:	49 83 fa 08          	cmp    r10,0x8
  219241:	0f 87 a6 07 00 00    	ja     2199ed <openSelfDebugInfo+0x2fad>
  219247:	f6 42 f8 01          	test   BYTE PTR [rdx-0x8],0x1
  21924b:	66 bf 23 00          	mov    di,0x23
  21924f:	0f 85 73 08 00 00    	jne    219ac8 <openSelfDebugInfo+0x3088>
  219255:	4d 85 d2             	test   r10,r10
            for (bytes) |b, index| {
  219258:	74 13                	je     21926d <openSelfDebugInfo+0x282d>
  21925a:	48 8b 52 e8          	mov    rdx,QWORD PTR [rdx-0x18]
  21925e:	49 83 fa 10          	cmp    r10,0x10
  219262:	73 10                	jae    219274 <openSelfDebugInfo+0x2834>
  219264:	31 c9                	xor    ecx,ecx
  219266:	31 c0                	xor    eax,eax
  219268:	e9 d3 01 00 00       	jmp    219440 <openSelfDebugInfo+0x2a00>
  21926d:	31 c0                	xor    eax,eax
  21926f:	e9 f5 01 00 00       	jmp    219469 <openSelfDebugInfo+0x2a29>
  219274:	4c 89 d1             	mov    rcx,r10
  219277:	48 83 e1 f0          	and    rcx,0xfffffffffffffff0
  21927b:	48 8d 41 f0          	lea    rax,[rcx-0x10]
  21927f:	48 89 c7             	mov    rdi,rax
  219282:	48 c1 ef 04          	shr    rdi,0x4
  219286:	44 8d 47 01          	lea    r8d,[rdi+0x1]
  21928a:	41 83 e0 01          	and    r8d,0x1
  21928e:	48 85 c0             	test   rax,rax
  219291:	0f 84 01 01 00 00    	je     219398 <openSelfDebugInfo+0x2958>
  219297:	49 8d 40 ff          	lea    rax,[r8-0x1]
  21929b:	48 29 f8             	sub    rax,rdi
  21929e:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  2192a2:	31 ff                	xor    edi,edi
  2192a4:	c5 fd 6f 25 f4 6e fe 	vmovdqa ymm4,YMMWORD PTR [rip+0xfffffffffffe6ef4]        # 2001a0 <__unnamed_103-0x40>
  2192ab:	ff 
  2192ac:	c5 f1 ef c9          	vpxor  xmm1,xmm1,xmm1
  2192b0:	c5 e1 ef db          	vpxor  xmm3,xmm3,xmm3
  2192b4:	c5 e9 ef d2          	vpxor  xmm2,xmm2,xmm2
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  2192b8:	c4 e2 7d 32 2c 3a    	vpmovzxbq ymm5,DWORD PTR [rdx+rdi*1]
  2192be:	c4 e2 7d 32 74 3a 04 	vpmovzxbq ymm6,DWORD PTR [rdx+rdi*1+0x4]
  2192c5:	c4 e2 7d 32 7c 3a 08 	vpmovzxbq ymm7,DWORD PTR [rdx+rdi*1+0x8]
  2192cc:	c4 62 7d 32 44 3a 0c 	vpmovzxbq ymm8,DWORD PTR [rdx+rdi*1+0xc]
  2192d3:	c5 b5 73 f4 03       	vpsllq ymm9,ymm4,0x3
  2192d8:	c5 7e 6f a4 24 40 05 	vmovdqu ymm12,YMMWORD PTR [rsp+0x540]
  2192df:	00 00 
  2192e1:	c4 41 35 d4 d4       	vpaddq ymm10,ymm9,ymm12
  2192e6:	c5 7e 6f ac 24 20 05 	vmovdqu ymm13,YMMWORD PTR [rsp+0x520]
  2192ed:	00 00 
  2192ef:	c4 41 35 db dd       	vpand  ymm11,ymm9,ymm13
  2192f4:	c4 41 2d db d5       	vpand  ymm10,ymm10,ymm13
  2192f9:	c4 c2 d5 47 eb       	vpsllvq ymm5,ymm5,ymm11
  2192fe:	c5 d5 eb c0          	vpor   ymm0,ymm5,ymm0
  219302:	c4 c2 cd 47 ea       	vpsllvq ymm5,ymm6,ymm10
  219307:	c5 d5 eb c9          	vpor   ymm1,ymm5,ymm1
  21930b:	c4 c2 c5 47 eb       	vpsllvq ymm5,ymm7,ymm11
  219310:	c5 d5 eb db          	vpor   ymm3,ymm5,ymm3
  219314:	c4 c2 bd 47 ea       	vpsllvq ymm5,ymm8,ymm10
  219319:	c4 e2 7d 32 74 3a 10 	vpmovzxbq ymm6,DWORD PTR [rdx+rdi*1+0x10]
  219320:	c4 e2 7d 32 7c 3a 14 	vpmovzxbq ymm7,DWORD PTR [rdx+rdi*1+0x14]
  219327:	c4 62 7d 32 44 3a 18 	vpmovzxbq ymm8,DWORD PTR [rdx+rdi*1+0x18]
  21932e:	c5 d5 eb d2          	vpor   ymm2,ymm5,ymm2
  219332:	c4 e2 7d 32 6c 3a 1c 	vpmovzxbq ymm5,DWORD PTR [rdx+rdi*1+0x1c]
  219339:	c4 62 7d 59 15 de 79 	vpbroadcastq ymm10,QWORD PTR [rip+0xfffffffffffe79de]        # 200d20 <app_mask+0x40>
  219340:	fe ff 
  219342:	c4 41 35 d4 d2       	vpaddq ymm10,ymm9,ymm10
  219347:	c4 62 7d 59 1d 18 79 	vpbroadcastq ymm11,QWORD PTR [rip+0xfffffffffffe7918]        # 200c68 <__unnamed_456+0x18>
  21934e:	fe ff 
  219350:	c4 41 35 d4 cb       	vpaddq ymm9,ymm9,ymm11
  219355:	c4 41 2d db d5       	vpand  ymm10,ymm10,ymm13
  21935a:	c4 41 35 db cd       	vpand  ymm9,ymm9,ymm13
  21935f:	c4 c2 cd 47 f2       	vpsllvq ymm6,ymm6,ymm10
  219364:	c5 cd eb c0          	vpor   ymm0,ymm6,ymm0
  219368:	c4 c2 c5 47 f1       	vpsllvq ymm6,ymm7,ymm9
  21936d:	c5 cd eb c9          	vpor   ymm1,ymm6,ymm1
  219371:	c4 c2 bd 47 f2       	vpsllvq ymm6,ymm8,ymm10
  219376:	c5 cd eb db          	vpor   ymm3,ymm6,ymm3
  21937a:	c4 c2 d5 47 e9       	vpsllvq ymm5,ymm5,ymm9
  21937f:	c5 d5 eb d2          	vpor   ymm2,ymm5,ymm2
            for (bytes) |b, index| {
  219383:	48 83 c7 20          	add    rdi,0x20
  219387:	c4 c1 5d d4 e4       	vpaddq ymm4,ymm4,ymm12
  21938c:	48 83 c0 02          	add    rax,0x2
  219390:	0f 85 22 ff ff ff    	jne    2192b8 <openSelfDebugInfo+0x2878>
  219396:	eb 1a                	jmp    2193b2 <openSelfDebugInfo+0x2972>
  219398:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  21939c:	31 ff                	xor    edi,edi
  21939e:	c5 fd 6f 25 fa 6d fe 	vmovdqa ymm4,YMMWORD PTR [rip+0xfffffffffffe6dfa]        # 2001a0 <__unnamed_103-0x40>
  2193a5:	ff 
  2193a6:	c5 f1 ef c9          	vpxor  xmm1,xmm1,xmm1
  2193aa:	c5 e1 ef db          	vpxor  xmm3,xmm3,xmm3
  2193ae:	c5 e9 ef d2          	vpxor  xmm2,xmm2,xmm2
  2193b2:	4d 85 c0             	test   r8,r8
  2193b5:	74 60                	je     219417 <openSelfDebugInfo+0x29d7>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  2193b7:	c4 e2 7d 32 6c 3a 0c 	vpmovzxbq ymm5,DWORD PTR [rdx+rdi*1+0xc]
  2193be:	c5 dd 73 f4 03       	vpsllq ymm4,ymm4,0x3
  2193c3:	c5 dd d4 b4 24 40 05 	vpaddq ymm6,ymm4,YMMWORD PTR [rsp+0x540]
  2193ca:	00 00 
  2193cc:	c5 7e 6f 84 24 20 05 	vmovdqu ymm8,YMMWORD PTR [rsp+0x520]
  2193d3:	00 00 
  2193d5:	c4 c1 4d db f0       	vpand  ymm6,ymm6,ymm8
  2193da:	c4 e2 d5 47 ee       	vpsllvq ymm5,ymm5,ymm6
  2193df:	c4 e2 7d 32 7c 3a 08 	vpmovzxbq ymm7,DWORD PTR [rdx+rdi*1+0x8]
  2193e6:	c5 d5 eb d2          	vpor   ymm2,ymm5,ymm2
  2193ea:	c4 c1 5d db e0       	vpand  ymm4,ymm4,ymm8
  2193ef:	c4 e2 c5 47 ec       	vpsllvq ymm5,ymm7,ymm4
  2193f4:	c5 d5 eb db          	vpor   ymm3,ymm5,ymm3
  2193f8:	c4 e2 7d 32 6c 3a 04 	vpmovzxbq ymm5,DWORD PTR [rdx+rdi*1+0x4]
  2193ff:	c4 e2 d5 47 ee       	vpsllvq ymm5,ymm5,ymm6
  219404:	c5 d5 eb c9          	vpor   ymm1,ymm5,ymm1
  219408:	c4 e2 7d 32 2c 3a    	vpmovzxbq ymm5,DWORD PTR [rdx+rdi*1]
  21940e:	c4 e2 d5 47 e4       	vpsllvq ymm4,ymm5,ymm4
  219413:	c5 dd eb c0          	vpor   ymm0,ymm4,ymm0
  219417:	c5 f5 eb ca          	vpor   ymm1,ymm1,ymm2
  21941b:	c5 fd eb c3          	vpor   ymm0,ymm0,ymm3
  21941f:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  219423:	c4 e3 7d 39 c1 01    	vextracti128 xmm1,ymm0,0x1
  219429:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  21942d:	c5 f9 70 c8 4e       	vpshufd xmm1,xmm0,0x4e
  219432:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  219436:	c4 e1 f9 7e c0       	vmovq  rax,xmm0
  21943b:	49 39 ca             	cmp    r10,rcx
            for (bytes) |b, index| {
  21943e:	74 29                	je     219469 <openSelfDebugInfo+0x2a29>
  219440:	49 29 ca             	sub    r10,rcx
  219443:	48 01 ca             	add    rdx,rcx
  219446:	48 c1 e1 03          	shl    rcx,0x3
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  21944a:	0f b6 3a             	movzx  edi,BYTE PTR [rdx]
  21944d:	89 ce                	mov    esi,ecx
  21944f:	40 80 e6 38          	and    sil,0x38
  219453:	c4 e2 c9 f7 f7       	shlx   rsi,rdi,rsi
  219458:	48 09 f0             	or     rax,rsi
            for (bytes) |b, index| {
  21945b:	48 83 c1 08          	add    rcx,0x8
  21945f:	48 83 c2 01          	add    rdx,0x1
  219463:	49 83 c2 ff          	add    r10,0xffffffffffffffff
  219467:	75 e1                	jne    21944a <openSelfDebugInfo+0x2a0a>
                            break :b (low_pc + offset);
  219469:	4c 01 c8             	add    rax,r9
                    break :x PcRange{
  21946c:	4c 89 8c 24 70 02 00 	mov    QWORD PTR [rsp+0x270],r9
  219473:	00 
  219474:	48 89 84 24 78 02 00 	mov    QWORD PTR [rsp+0x278],rax
  21947b:	00 
  21947c:	c6 84 24 80 02 00 00 	mov    BYTE PTR [rsp+0x280],0x1
  219483:	01 
        const pc_range = x: {
  219484:	48 8d 8c 24 70 02 00 	lea    rcx,[rsp+0x270]
  21948b:	00 
  21948c:	e9 e1 fb ff ff       	jmp    219072 <openSelfDebugInfo+0x2632>
                list.first = node.next;
  219491:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  219495:	48 89 0d 8c cb 02 00 	mov    QWORD PTR [rip+0x2cb8c],rcx        # 246028 <emfile_promise_queue>
            if (node.next) |next_node| {
  21949c:	48 85 c9             	test   rcx,rcx
  21949f:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  2194a2:	48 8d 35 87 cb 02 00 	lea    rsi,[rip+0x2cb87]        # 246030 <emfile_promise_queue+0x8>
  2194a9:	48 0f 45 f1          	cmovne rsi,rcx
  2194ad:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  2194b0:	48 83 05 80 cb 02 00 	add    QWORD PTR [rip+0x2cb80],0xffffffffffffffff        # 246038 <emfile_promise_queue+0x10>
  2194b7:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  2194b8:	74 1e                	je     2194d8 <openSelfDebugInfo+0x2a98>
  2194ba:	48 83 3d 66 cb 02 00 	cmp    QWORD PTR [rip+0x2cb66],0x0        # 246028 <emfile_promise_queue>
  2194c1:	00 
  2194c2:	0f 84 dc 15 00 00    	je     21aaa4 <openSelfDebugInfo+0x4064>
  2194c8:	48 8b 0d 61 cb 02 00 	mov    rcx,QWORD PTR [rip+0x2cb61]        # 246030 <emfile_promise_queue+0x8>
  2194cf:	48 85 c9             	test   rcx,rcx
  2194d2:	0f 84 cc 15 00 00    	je     21aaa4 <openSelfDebugInfo+0x4064>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  2194d8:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  2194dc:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  2194e0:	48 89 c1             	mov    rcx,rax
  2194e3:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  2194e7:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  2194ed:	75 f1                	jne    2194e0 <openSelfDebugInfo+0x2aa0>
  2194ef:	a8 01                	test   al,0x1
  2194f1:	75 02                	jne    2194f5 <openSelfDebugInfo+0x2ab5>
  2194f3:	ff 17                	call   QWORD PTR [rdi]
  2194f5:	48 63 7d 00          	movsxd rdi,DWORD PTR [rbp+0x0]
    return asm volatile ("syscall"
  2194f9:	b8 03 00 00 00       	mov    eax,0x3
  2194fe:	0f 05                	syscall 
            switch (err) {
  219500:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  219504:	74 f3                	je     2194f9 <openSelfDebugInfo+0x2ab9>
            const first = list.first orelse return null;
  219506:	48 8b 05 1b cb 02 00 	mov    rax,QWORD PTR [rip+0x2cb1b]        # 246028 <emfile_promise_queue>
  21950d:	48 85 c0             	test   rax,rax
  219510:	74 7a                	je     21958c <openSelfDebugInfo+0x2b4c>
            if (node.prev) |prev_node| {
  219512:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  219515:	48 85 c9             	test   rcx,rcx
  219518:	74 0e                	je     219528 <openSelfDebugInfo+0x2ae8>
                prev_node.next = node.next;
  21951a:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  21951e:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  219522:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  219526:	eb 0b                	jmp    219533 <openSelfDebugInfo+0x2af3>
                list.first = node.next;
  219528:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  21952c:	48 89 0d f5 ca 02 00 	mov    QWORD PTR [rip+0x2caf5],rcx        # 246028 <emfile_promise_queue>
            if (node.next) |next_node| {
  219533:	48 85 c9             	test   rcx,rcx
  219536:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  219539:	48 8d 35 f0 ca 02 00 	lea    rsi,[rip+0x2caf0]        # 246030 <emfile_promise_queue+0x8>
  219540:	48 0f 45 f1          	cmovne rsi,rcx
  219544:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  219547:	48 83 05 e9 ca 02 00 	add    QWORD PTR [rip+0x2cae9],0xffffffffffffffff        # 246038 <emfile_promise_queue+0x10>
  21954e:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  21954f:	74 1e                	je     21956f <openSelfDebugInfo+0x2b2f>
  219551:	48 83 3d cf ca 02 00 	cmp    QWORD PTR [rip+0x2cacf],0x0        # 246028 <emfile_promise_queue>
  219558:	00 
  219559:	0f 84 45 15 00 00    	je     21aaa4 <openSelfDebugInfo+0x4064>
  21955f:	48 8b 0d ca ca 02 00 	mov    rcx,QWORD PTR [rip+0x2caca]        # 246030 <emfile_promise_queue+0x8>
  219566:	48 85 c9             	test   rcx,rcx
  219569:	0f 84 35 15 00 00    	je     21aaa4 <openSelfDebugInfo+0x4064>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  21956f:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  219573:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  219577:	48 89 c1             	mov    rcx,rax
  21957a:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  21957e:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  219584:	75 f1                	jne    219577 <openSelfDebugInfo+0x2b37>
  219586:	a8 01                	test   al,0x1
  219588:	75 02                	jne    21958c <openSelfDebugInfo+0x2b4c>
  21958a:	ff 17                	call   QWORD PTR [rdi]
        self.freeFn(self, non_const_ptr[0..@sizeOf(@typeOf(ptr).Child)]);
  21958c:	49 8b 44 24 10       	mov    rax,QWORD PTR [r12+0x10]
  219591:	48 89 ac 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rbp
  219598:	00 
  219599:	48 c7 84 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],0xc8
  2195a0:	00 c8 00 00 00 
  2195a5:	48 8d b4 24 f0 00 00 	lea    rsi,[rsp+0xf0]
  2195ac:	00 
  2195ad:	4c 89 e7             	mov    rdi,r12
  2195b0:	ff d0                	call   rax
            st.debug_line = (try st.elf.findSection(".debug_line")) orelse return error.MissingDebugInfo;
  2195b2:	0f b7 84 24 10 03 00 	movzx  eax,WORD PTR [rsp+0x310]
  2195b9:	00 
  2195ba:	66 41 89 06          	mov    WORD PTR [r14],ax
  2195be:	48 8b 84 24 be 04 00 	mov    rax,QWORD PTR [rsp+0x4be]
  2195c5:	00 
  2195c6:	48 8b 8c 24 c4 04 00 	mov    rcx,QWORD PTR [rsp+0x4c4]
  2195cd:	00 
  2195ce:	e9 84 e1 ff ff       	jmp    217757 <openSelfDebugInfo+0xd17>
                list.first = node.next;
  2195d3:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  2195d7:	48 89 0d 4a ca 02 00 	mov    QWORD PTR [rip+0x2ca4a],rcx        # 246028 <emfile_promise_queue>
            if (node.next) |next_node| {
  2195de:	48 85 c9             	test   rcx,rcx
  2195e1:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  2195e4:	48 8d 35 45 ca 02 00 	lea    rsi,[rip+0x2ca45]        # 246030 <emfile_promise_queue+0x8>
  2195eb:	48 0f 45 f1          	cmovne rsi,rcx
  2195ef:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  2195f2:	48 83 05 3e ca 02 00 	add    QWORD PTR [rip+0x2ca3e],0xffffffffffffffff        # 246038 <emfile_promise_queue+0x10>
  2195f9:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  2195fa:	74 1e                	je     21961a <openSelfDebugInfo+0x2bda>
  2195fc:	48 83 3d 24 ca 02 00 	cmp    QWORD PTR [rip+0x2ca24],0x0        # 246028 <emfile_promise_queue>
  219603:	00 
  219604:	0f 84 9a 14 00 00    	je     21aaa4 <openSelfDebugInfo+0x4064>
  21960a:	48 8b 0d 1f ca 02 00 	mov    rcx,QWORD PTR [rip+0x2ca1f]        # 246030 <emfile_promise_queue+0x8>
  219611:	48 85 c9             	test   rcx,rcx
  219614:	0f 84 8a 14 00 00    	je     21aaa4 <openSelfDebugInfo+0x4064>
  21961a:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  21961e:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  219622:	48 89 c1             	mov    rcx,rax
  219625:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  219629:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  21962f:	75 f1                	jne    219622 <openSelfDebugInfo+0x2be2>
  219631:	a8 01                	test   al,0x1
  219633:	75 02                	jne    219637 <openSelfDebugInfo+0x2bf7>
  219635:	ff 17                	call   QWORD PTR [rdi]
  219637:	48 63 7d 00          	movsxd rdi,DWORD PTR [rbp+0x0]
  21963b:	b8 03 00 00 00       	mov    eax,0x3
  219640:	0f 05                	syscall 
            switch (err) {
  219642:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  219646:	74 f3                	je     21963b <openSelfDebugInfo+0x2bfb>
            const first = list.first orelse return null;
  219648:	48 8b 05 d9 c9 02 00 	mov    rax,QWORD PTR [rip+0x2c9d9]        # 246028 <emfile_promise_queue>
  21964f:	48 85 c0             	test   rax,rax
  219652:	0f 84 9b e4 ff ff    	je     217af3 <openSelfDebugInfo+0x10b3>
            if (node.prev) |prev_node| {
  219658:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  21965b:	48 85 c9             	test   rcx,rcx
  21965e:	74 0e                	je     21966e <openSelfDebugInfo+0x2c2e>
                prev_node.next = node.next;
  219660:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  219664:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  219668:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  21966c:	eb 0b                	jmp    219679 <openSelfDebugInfo+0x2c39>
                list.first = node.next;
  21966e:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  219672:	48 89 0d af c9 02 00 	mov    QWORD PTR [rip+0x2c9af],rcx        # 246028 <emfile_promise_queue>
            if (node.next) |next_node| {
  219679:	48 85 c9             	test   rcx,rcx
  21967c:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  21967f:	48 8d 35 aa c9 02 00 	lea    rsi,[rip+0x2c9aa]        # 246030 <emfile_promise_queue+0x8>
  219686:	48 0f 45 f1          	cmovne rsi,rcx
  21968a:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  21968d:	48 83 05 a3 c9 02 00 	add    QWORD PTR [rip+0x2c9a3],0xffffffffffffffff        # 246038 <emfile_promise_queue+0x10>
  219694:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  219695:	74 1e                	je     2196b5 <openSelfDebugInfo+0x2c75>
  219697:	48 83 3d 89 c9 02 00 	cmp    QWORD PTR [rip+0x2c989],0x0        # 246028 <emfile_promise_queue>
  21969e:	00 
  21969f:	0f 84 ff 13 00 00    	je     21aaa4 <openSelfDebugInfo+0x4064>
  2196a5:	48 8b 0d 84 c9 02 00 	mov    rcx,QWORD PTR [rip+0x2c984]        # 246030 <emfile_promise_queue+0x8>
  2196ac:	48 85 c9             	test   rcx,rcx
  2196af:	0f 84 ef 13 00 00    	je     21aaa4 <openSelfDebugInfo+0x4064>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  2196b5:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  2196b9:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  2196bd:	48 89 c1             	mov    rcx,rax
  2196c0:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  2196c4:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  2196ca:	75 f1                	jne    2196bd <openSelfDebugInfo+0x2c7d>
  2196cc:	e9 1c e4 ff ff       	jmp    217aed <openSelfDebugInfo+0x10ad>
  2196d1:	31 ff                	xor    edi,edi
  2196d3:	89 fb                	mov    ebx,edi
            try scanAllCompileUnits(st);
  2196d5:	66 85 ff             	test   di,di
  2196d8:	0f 85 f5 03 00 00    	jne    219ad3 <openSelfDebugInfo+0x3093>
            return st;
  2196de:	66 41 c7 06 00 00    	mov    WORD PTR [r14],0x0
  2196e4:	0f b7 84 24 be 02 00 	movzx  eax,WORD PTR [rsp+0x2be]
  2196eb:	00 
  2196ec:	66 41 89 46 06       	mov    WORD PTR [r14+0x6],ax
  2196f1:	8b 84 24 ba 02 00 00 	mov    eax,DWORD PTR [rsp+0x2ba]
  2196f8:	41 89 46 02          	mov    DWORD PTR [r14+0x2],eax
  2196fc:	49 89 6e 08          	mov    QWORD PTR [r14+0x8],rbp
  219700:	e9 5a e0 ff ff       	jmp    21775f <openSelfDebugInfo+0xd1f>
                list.first = node.next;
  219705:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  219709:	48 89 0d 18 c9 02 00 	mov    QWORD PTR [rip+0x2c918],rcx        # 246028 <emfile_promise_queue>
            if (node.next) |next_node| {
  219710:	48 85 c9             	test   rcx,rcx
  219713:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  219716:	48 8d 35 13 c9 02 00 	lea    rsi,[rip+0x2c913]        # 246030 <emfile_promise_queue+0x8>
  21971d:	48 0f 45 f1          	cmovne rsi,rcx
  219721:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  219724:	48 83 05 0c c9 02 00 	add    QWORD PTR [rip+0x2c90c],0xffffffffffffffff        # 246038 <emfile_promise_queue+0x10>
  21972b:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  21972c:	74 1e                	je     21974c <openSelfDebugInfo+0x2d0c>
  21972e:	48 83 3d f2 c8 02 00 	cmp    QWORD PTR [rip+0x2c8f2],0x0        # 246028 <emfile_promise_queue>
  219735:	00 
  219736:	0f 84 68 13 00 00    	je     21aaa4 <openSelfDebugInfo+0x4064>
  21973c:	48 8b 0d ed c8 02 00 	mov    rcx,QWORD PTR [rip+0x2c8ed]        # 246030 <emfile_promise_queue+0x8>
  219743:	48 85 c9             	test   rcx,rcx
  219746:	0f 84 58 13 00 00    	je     21aaa4 <openSelfDebugInfo+0x4064>
  21974c:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  219750:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  219754:	48 89 c1             	mov    rcx,rax
  219757:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  21975b:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  219761:	75 f1                	jne    219754 <openSelfDebugInfo+0x2d14>
  219763:	a8 01                	test   al,0x1
  219765:	75 02                	jne    219769 <openSelfDebugInfo+0x2d29>
  219767:	ff 17                	call   QWORD PTR [rdi]
  219769:	48 63 7d 00          	movsxd rdi,DWORD PTR [rbp+0x0]
  21976d:	b8 03 00 00 00       	mov    eax,0x3
  219772:	0f 05                	syscall 
            switch (err) {
  219774:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  219778:	74 f3                	je     21976d <openSelfDebugInfo+0x2d2d>
            const first = list.first orelse return null;
  21977a:	48 8b 05 a7 c8 02 00 	mov    rax,QWORD PTR [rip+0x2c8a7]        # 246028 <emfile_promise_queue>
  219781:	48 85 c0             	test   rax,rax
  219784:	74 7a                	je     219800 <openSelfDebugInfo+0x2dc0>
            if (node.prev) |prev_node| {
  219786:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  219789:	48 85 c9             	test   rcx,rcx
  21978c:	74 0e                	je     21979c <openSelfDebugInfo+0x2d5c>
                prev_node.next = node.next;
  21978e:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  219792:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  219796:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  21979a:	eb 0b                	jmp    2197a7 <openSelfDebugInfo+0x2d67>
                list.first = node.next;
  21979c:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  2197a0:	48 89 0d 81 c8 02 00 	mov    QWORD PTR [rip+0x2c881],rcx        # 246028 <emfile_promise_queue>
            if (node.next) |next_node| {
  2197a7:	48 85 c9             	test   rcx,rcx
  2197aa:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  2197ad:	48 8d 35 7c c8 02 00 	lea    rsi,[rip+0x2c87c]        # 246030 <emfile_promise_queue+0x8>
  2197b4:	48 0f 45 f1          	cmovne rsi,rcx
  2197b8:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  2197bb:	48 83 05 75 c8 02 00 	add    QWORD PTR [rip+0x2c875],0xffffffffffffffff        # 246038 <emfile_promise_queue+0x10>
  2197c2:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  2197c3:	74 1e                	je     2197e3 <openSelfDebugInfo+0x2da3>
  2197c5:	48 83 3d 5b c8 02 00 	cmp    QWORD PTR [rip+0x2c85b],0x0        # 246028 <emfile_promise_queue>
  2197cc:	00 
  2197cd:	0f 84 d1 12 00 00    	je     21aaa4 <openSelfDebugInfo+0x4064>
  2197d3:	48 8b 0d 56 c8 02 00 	mov    rcx,QWORD PTR [rip+0x2c856]        # 246030 <emfile_promise_queue+0x8>
  2197da:	48 85 c9             	test   rcx,rcx
  2197dd:	0f 84 c1 12 00 00    	je     21aaa4 <openSelfDebugInfo+0x4064>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  2197e3:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  2197e7:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  2197eb:	48 89 c1             	mov    rcx,rax
  2197ee:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  2197f2:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  2197f8:	75 f1                	jne    2197eb <openSelfDebugInfo+0x2dab>
  2197fa:	a8 01                	test   al,0x1
  2197fc:	75 02                	jne    219800 <openSelfDebugInfo+0x2dc0>
  2197fe:	ff 17                	call   QWORD PTR [rdi]
  219800:	49 8b 44 24 10       	mov    rax,QWORD PTR [r12+0x10]
  219805:	48 89 ac 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rbp
  21980c:	00 
  21980d:	48 c7 84 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],0xc8
  219814:	00 c8 00 00 00 
  219819:	48 8d b4 24 f0 00 00 	lea    rsi,[rsp+0xf0]
  219820:	00 
  219821:	4c 89 e7             	mov    rdi,r12
  219824:	ff d0                	call   rax
            st.debug_ranges = (try st.elf.findSection(".debug_ranges"));
  219826:	0f b7 84 24 00 03 00 	movzx  eax,WORD PTR [rsp+0x300]
  21982d:	00 
  21982e:	66 41 89 06          	mov    WORD PTR [r14],ax
  219832:	48 8b 84 24 b0 04 00 	mov    rax,QWORD PTR [rsp+0x4b0]
  219839:	00 
  21983a:	48 8b 8c 24 b6 04 00 	mov    rcx,QWORD PTR [rsp+0x4b6]
  219841:	00 
  219842:	e9 10 df ff ff       	jmp    217757 <openSelfDebugInfo+0xd17>
                list.first = node.next;
  219847:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  21984b:	48 89 0d d6 c7 02 00 	mov    QWORD PTR [rip+0x2c7d6],rcx        # 246028 <emfile_promise_queue>
            if (node.next) |next_node| {
  219852:	48 85 c9             	test   rcx,rcx
  219855:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  219858:	48 8d 35 d1 c7 02 00 	lea    rsi,[rip+0x2c7d1]        # 246030 <emfile_promise_queue+0x8>
  21985f:	48 0f 45 f1          	cmovne rsi,rcx
  219863:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  219866:	48 83 05 ca c7 02 00 	add    QWORD PTR [rip+0x2c7ca],0xffffffffffffffff        # 246038 <emfile_promise_queue+0x10>
  21986d:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  21986e:	74 1e                	je     21988e <openSelfDebugInfo+0x2e4e>
  219870:	48 83 3d b0 c7 02 00 	cmp    QWORD PTR [rip+0x2c7b0],0x0        # 246028 <emfile_promise_queue>
  219877:	00 
  219878:	0f 84 26 12 00 00    	je     21aaa4 <openSelfDebugInfo+0x4064>
  21987e:	48 8b 0d ab c7 02 00 	mov    rcx,QWORD PTR [rip+0x2c7ab]        # 246030 <emfile_promise_queue+0x8>
  219885:	48 85 c9             	test   rcx,rcx
  219888:	0f 84 16 12 00 00    	je     21aaa4 <openSelfDebugInfo+0x4064>
  21988e:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  219892:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  219896:	48 89 c1             	mov    rcx,rax
  219899:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  21989d:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  2198a3:	75 f1                	jne    219896 <openSelfDebugInfo+0x2e56>
  2198a5:	a8 01                	test   al,0x1
  2198a7:	75 02                	jne    2198ab <openSelfDebugInfo+0x2e6b>
  2198a9:	ff 17                	call   QWORD PTR [rdi]
  2198ab:	48 63 7d 00          	movsxd rdi,DWORD PTR [rbp+0x0]
  2198af:	b8 03 00 00 00       	mov    eax,0x3
  2198b4:	0f 05                	syscall 
            switch (err) {
  2198b6:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  2198ba:	74 f3                	je     2198af <openSelfDebugInfo+0x2e6f>
            const first = list.first orelse return null;
  2198bc:	48 8b 05 65 c7 02 00 	mov    rax,QWORD PTR [rip+0x2c765]        # 246028 <emfile_promise_queue>
  2198c3:	48 85 c0             	test   rax,rax
  2198c6:	0f 84 27 e2 ff ff    	je     217af3 <openSelfDebugInfo+0x10b3>
            if (node.prev) |prev_node| {
  2198cc:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  2198cf:	48 85 c9             	test   rcx,rcx
  2198d2:	74 0e                	je     2198e2 <openSelfDebugInfo+0x2ea2>
                prev_node.next = node.next;
  2198d4:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  2198d8:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  2198dc:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  2198e0:	eb 0b                	jmp    2198ed <openSelfDebugInfo+0x2ead>
                list.first = node.next;
  2198e2:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  2198e6:	48 89 0d 3b c7 02 00 	mov    QWORD PTR [rip+0x2c73b],rcx        # 246028 <emfile_promise_queue>
            if (node.next) |next_node| {
  2198ed:	48 85 c9             	test   rcx,rcx
  2198f0:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  2198f3:	48 8d 35 36 c7 02 00 	lea    rsi,[rip+0x2c736]        # 246030 <emfile_promise_queue+0x8>
  2198fa:	48 0f 45 f1          	cmovne rsi,rcx
  2198fe:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  219901:	48 83 05 2f c7 02 00 	add    QWORD PTR [rip+0x2c72f],0xffffffffffffffff        # 246038 <emfile_promise_queue+0x10>
  219908:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  219909:	74 1e                	je     219929 <openSelfDebugInfo+0x2ee9>
  21990b:	48 83 3d 15 c7 02 00 	cmp    QWORD PTR [rip+0x2c715],0x0        # 246028 <emfile_promise_queue>
  219912:	00 
  219913:	0f 84 8b 11 00 00    	je     21aaa4 <openSelfDebugInfo+0x4064>
  219919:	48 8b 0d 10 c7 02 00 	mov    rcx,QWORD PTR [rip+0x2c710]        # 246030 <emfile_promise_queue+0x8>
  219920:	48 85 c9             	test   rcx,rcx
  219923:	0f 84 7b 11 00 00    	je     21aaa4 <openSelfDebugInfo+0x4064>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  219929:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  21992d:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  219931:	48 89 c1             	mov    rcx,rax
  219934:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  219938:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  21993e:	75 f1                	jne    219931 <openSelfDebugInfo+0x2ef1>
  219940:	e9 a8 e1 ff ff       	jmp    217aed <openSelfDebugInfo+0x10ad>
  219945:	66 b9 1f 00          	mov    cx,0x1f
  219949:	eb 04                	jmp    21994f <openSelfDebugInfo+0x2f0f>
  21994b:	66 b9 23 00          	mov    cx,0x23
        const abbrev_code = try readULeb128(in_stream);
  21994f:	48 8b 84 24 0e 01 00 	mov    rax,QWORD PTR [rsp+0x10e]
  219956:	00 
  219957:	48 89 84 24 ee 01 00 	mov    QWORD PTR [rsp+0x1ee],rax
  21995e:	00 
  21995f:	c5 fe 6f 84 24 f0 00 	vmovdqu ymm0,YMMWORD PTR [rsp+0xf0]
  219966:	00 00 
  219968:	c5 fe 7f 84 24 d0 01 	vmovdqu YMMWORD PTR [rsp+0x1d0],ymm0
  21996f:	00 00 
  219971:	89 cf                	mov    edi,ecx
  219973:	89 fb                	mov    ebx,edi
            try scanAllCompileUnits(st);
  219975:	66 85 ff             	test   di,di
  219978:	0f 85 55 01 00 00    	jne    219ad3 <openSelfDebugInfo+0x3093>
  21997e:	e9 5b fd ff ff       	jmp    2196de <openSelfDebugInfo+0x2c9e>
  219983:	66 b8 1f 00          	mov    ax,0x1f
  219987:	89 c7                	mov    edi,eax
  219989:	89 fb                	mov    ebx,edi
  21998b:	66 85 ff             	test   di,di
  21998e:	0f 85 3f 01 00 00    	jne    219ad3 <openSelfDebugInfo+0x3093>
  219994:	e9 45 fd ff ff       	jmp    2196de <openSelfDebugInfo+0x2c9e>
  219999:	66 b9 1f 00          	mov    cx,0x1f
  21999d:	eb 04                	jmp    2199a3 <openSelfDebugInfo+0x2f63>
  21999f:	66 b9 23 00          	mov    cx,0x23
    const abbrev_code = try readULeb128(in_stream);
  2199a3:	c5 fe 6f 84 24 f0 00 	vmovdqu ymm0,YMMWORD PTR [rsp+0xf0]
  2199aa:	00 00 
  2199ac:	c5 fe 6f 8c 24 06 01 	vmovdqu ymm1,YMMWORD PTR [rsp+0x106]
  2199b3:	00 00 
  2199b5:	c5 fe 7f 8c 24 d6 02 	vmovdqu YMMWORD PTR [rsp+0x2d6],ymm1
  2199bc:	00 00 
  2199be:	c5 fe 7f 84 24 c0 02 	vmovdqu YMMWORD PTR [rsp+0x2c0],ymm0
  2199c5:	00 00 
  2199c7:	89 cf                	mov    edi,ecx
  2199c9:	89 fb                	mov    ebx,edi
            try scanAllCompileUnits(st);
  2199cb:	66 85 ff             	test   di,di
  2199ce:	0f 85 ff 00 00 00    	jne    219ad3 <openSelfDebugInfo+0x3093>
  2199d4:	e9 05 fd ff ff       	jmp    2196de <openSelfDebugInfo+0x2c9e>
  2199d9:	66 bf 04 00          	mov    di,0x4
  2199dd:	89 fb                	mov    ebx,edi
  2199df:	66 85 ff             	test   di,di
  2199e2:	0f 85 eb 00 00 00    	jne    219ad3 <openSelfDebugInfo+0x3093>
  2199e8:	e9 f1 fc ff ff       	jmp    2196de <openSelfDebugInfo+0x2c9e>
  2199ed:	66 bf 23 00          	mov    di,0x23
  2199f1:	89 fb                	mov    ebx,edi
  2199f3:	66 85 ff             	test   di,di
  2199f6:	0f 85 d7 00 00 00    	jne    219ad3 <openSelfDebugInfo+0x3093>
  2199fc:	e9 dd fc ff ff       	jmp    2196de <openSelfDebugInfo+0x2c9e>
  219a01:	48 8d 41 ea          	lea    rax,[rcx-0x16]
  219a05:	48 83 f8 35          	cmp    rax,0x35
  219a09:	77 14                	ja     219a1f <openSelfDebugInfo+0x2fdf>
  219a0b:	48 ba 81 00 00 00 00 	movabs rdx,0x20000000000081
  219a12:	00 20 00 
  219a15:	48 0f a3 c2          	bt     rdx,rax
  219a19:	0f 82 9f 00 00 00    	jb     219abe <openSelfDebugInfo+0x307e>
  219a1f:	66 bf 03 00          	mov    di,0x3
  219a23:	48 83 f9 06          	cmp    rcx,0x6
  219a27:	0f 84 91 00 00 00    	je     219abe <openSelfDebugInfo+0x307e>
  219a2d:	e9 96 00 00 00       	jmp    219ac8 <openSelfDebugInfo+0x3088>
    const table_entry = getAbbrevTableEntry(abbrev_table, abbrev_code) orelse return error.InvalidDebugInfo;
  219a32:	c5 fc 10 05 76 e6 fe 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffee676]        # 2080b0 <__unnamed_68+0x18>
  219a39:	ff 
  219a3a:	c5 fc 11 84 24 d6 02 	vmovups YMMWORD PTR [rsp+0x2d6],ymm0
  219a41:	00 00 
  219a43:	c5 fe 6f 05 4f e6 fe 	vmovdqu ymm0,YMMWORD PTR [rip+0xfffffffffffee64f]        # 20809a <__unnamed_68+0x2>
  219a4a:	ff 
  219a4b:	c5 fe 7f 84 24 c0 02 	vmovdqu YMMWORD PTR [rsp+0x2c0],ymm0
  219a52:	00 00 
  219a54:	66 bf 23 00          	mov    di,0x23
  219a58:	89 fb                	mov    ebx,edi
            try scanAllCompileUnits(st);
  219a5a:	66 85 ff             	test   di,di
  219a5d:	75 74                	jne    219ad3 <openSelfDebugInfo+0x3093>
  219a5f:	e9 7a fc ff ff       	jmp    2196de <openSelfDebugInfo+0x2c9e>
  219a64:	66 b9 1f 00          	mov    cx,0x1f
  219a68:	eb 04                	jmp    219a6e <openSelfDebugInfo+0x302e>
  219a6a:	66 b9 23 00          	mov    cx,0x23
            .tag_id = try readULeb128(in_stream),
  219a6e:	48 8b 84 24 f6 03 00 	mov    rax,QWORD PTR [rsp+0x3f6]
  219a75:	00 
  219a76:	48 89 84 24 ee 01 00 	mov    QWORD PTR [rsp+0x1ee],rax
  219a7d:	00 
  219a7e:	c5 fc 10 84 24 d8 03 	vmovups ymm0,YMMWORD PTR [rsp+0x3d8]
  219a85:	00 00 
  219a87:	e9 dc fe ff ff       	jmp    219968 <openSelfDebugInfo+0x2f28>
  219a8c:	48 8d 4e ea          	lea    rcx,[rsi-0x16]
  219a90:	48 83 f9 35          	cmp    rcx,0x35
  219a94:	77 14                	ja     219aaa <openSelfDebugInfo+0x306a>
  219a96:	48 ba 81 00 00 00 00 	movabs rdx,0x20000000000081
  219a9d:	00 20 00 
  219aa0:	48 0f a3 ca          	bt     rdx,rcx
  219aa4:	0f 82 06 02 00 00    	jb     219cb0 <openSelfDebugInfo+0x3270>
  219aaa:	66 c7 84 24 c8 01 00 	mov    WORD PTR [rsp+0x1c8],0x3
  219ab1:	00 03 00 
                if (err > 0) {
  219ab4:	48 83 fe 06          	cmp    rsi,0x6
  219ab8:	66 bf 21 00          	mov    di,0x21
  219abc:	74 0a                	je     219ac8 <openSelfDebugInfo+0x3088>
  219abe:	0f b7 84 24 c8 01 00 	movzx  eax,WORD PTR [rsp+0x1c8]
  219ac5:	00 
  219ac6:	89 c7                	mov    edi,eax
  219ac8:	89 fb                	mov    ebx,edi
            try scanAllCompileUnits(st);
  219aca:	66 85 ff             	test   di,di
  219acd:	0f 84 0b fc ff ff    	je     2196de <openSelfDebugInfo+0x2c9e>
        const bytes = @sliceToBytes(memory);
  219ad3:	48 8b 45 48          	mov    rax,QWORD PTR [rbp+0x48]
  219ad7:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  219adb:	74 29                	je     219b06 <openSelfDebugInfo+0x30c6>
  219add:	48 8b 7d 50          	mov    rdi,QWORD PTR [rbp+0x50]
        const bytes = @sliceToBytes(memory);
  219ae1:	48 8b 4d 40          	mov    rcx,QWORD PTR [rbp+0x40]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  219ae5:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  219ae9:	48 89 8c 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rcx
  219af0:	00 
  219af1:	48 89 84 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],rax
  219af8:	00 
  219af9:	48 8d b4 24 f0 00 00 	lea    rsi,[rsp+0xf0]
  219b00:	00 
  219b01:	c5 f8 77             	vzeroupper 
  219b04:	ff d2                	call   rdx
  219b06:	80 7d 10 01          	cmp    BYTE PTR [rbp+0x10],0x1
  219b0a:	0f 85 9c 00 00 00    	jne    219bac <openSelfDebugInfo+0x316c>
  219b10:	49 8b 07             	mov    rax,QWORD PTR [r15]
  219b13:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  219b16:	b8 03 00 00 00       	mov    eax,0x3
  219b1b:	0f 05                	syscall 
            switch (err) {
  219b1d:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  219b21:	74 f3                	je     219b16 <openSelfDebugInfo+0x30d6>
            const first = list.first orelse return null;
  219b23:	48 8b 05 fe c4 02 00 	mov    rax,QWORD PTR [rip+0x2c4fe]        # 246028 <emfile_promise_queue>
  219b2a:	48 85 c0             	test   rax,rax
  219b2d:	74 7d                	je     219bac <openSelfDebugInfo+0x316c>
            if (node.prev) |prev_node| {
  219b2f:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  219b32:	48 85 c9             	test   rcx,rcx
  219b35:	74 0e                	je     219b45 <openSelfDebugInfo+0x3105>
                prev_node.next = node.next;
  219b37:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  219b3b:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  219b3f:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  219b43:	eb 0b                	jmp    219b50 <openSelfDebugInfo+0x3110>
                list.first = node.next;
  219b45:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  219b49:	48 89 0d d8 c4 02 00 	mov    QWORD PTR [rip+0x2c4d8],rcx        # 246028 <emfile_promise_queue>
            if (node.next) |next_node| {
  219b50:	48 85 c9             	test   rcx,rcx
  219b53:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  219b56:	48 8d 35 d3 c4 02 00 	lea    rsi,[rip+0x2c4d3]        # 246030 <emfile_promise_queue+0x8>
  219b5d:	48 0f 45 f1          	cmovne rsi,rcx
  219b61:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  219b64:	48 83 05 cc c4 02 00 	add    QWORD PTR [rip+0x2c4cc],0xffffffffffffffff        # 246038 <emfile_promise_queue+0x10>
  219b6b:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  219b6c:	74 1e                	je     219b8c <openSelfDebugInfo+0x314c>
  219b6e:	48 83 3d b2 c4 02 00 	cmp    QWORD PTR [rip+0x2c4b2],0x0        # 246028 <emfile_promise_queue>
  219b75:	00 
  219b76:	0f 84 28 0f 00 00    	je     21aaa4 <openSelfDebugInfo+0x4064>
  219b7c:	48 8b 0d ad c4 02 00 	mov    rcx,QWORD PTR [rip+0x2c4ad]        # 246030 <emfile_promise_queue+0x8>
  219b83:	48 85 c9             	test   rcx,rcx
  219b86:	0f 84 18 0f 00 00    	je     21aaa4 <openSelfDebugInfo+0x4064>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  219b8c:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  219b90:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  219b94:	48 89 c1             	mov    rcx,rax
  219b97:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  219b9b:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  219ba1:	75 f1                	jne    219b94 <openSelfDebugInfo+0x3154>
  219ba3:	a8 01                	test   al,0x1
  219ba5:	75 05                	jne    219bac <openSelfDebugInfo+0x316c>
  219ba7:	c5 f8 77             	vzeroupper 
  219baa:	ff 17                	call   QWORD PTR [rdi]
  219bac:	48 63 7d 00          	movsxd rdi,DWORD PTR [rbp+0x0]
  219bb0:	b8 03 00 00 00       	mov    eax,0x3
  219bb5:	0f 05                	syscall 
            switch (err) {
  219bb7:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  219bbb:	74 f3                	je     219bb0 <openSelfDebugInfo+0x3170>
            const first = list.first orelse return null;
  219bbd:	48 8b 05 64 c4 02 00 	mov    rax,QWORD PTR [rip+0x2c464]        # 246028 <emfile_promise_queue>
  219bc4:	48 85 c0             	test   rax,rax
  219bc7:	74 7d                	je     219c46 <openSelfDebugInfo+0x3206>
            if (node.prev) |prev_node| {
  219bc9:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  219bcc:	48 85 c9             	test   rcx,rcx
  219bcf:	74 0e                	je     219bdf <openSelfDebugInfo+0x319f>
                prev_node.next = node.next;
  219bd1:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  219bd5:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  219bd9:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  219bdd:	eb 0b                	jmp    219bea <openSelfDebugInfo+0x31aa>
                list.first = node.next;
  219bdf:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  219be3:	48 89 0d 3e c4 02 00 	mov    QWORD PTR [rip+0x2c43e],rcx        # 246028 <emfile_promise_queue>
            if (node.next) |next_node| {
  219bea:	48 85 c9             	test   rcx,rcx
  219bed:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  219bf0:	48 8d 35 39 c4 02 00 	lea    rsi,[rip+0x2c439]        # 246030 <emfile_promise_queue+0x8>
  219bf7:	48 0f 45 f1          	cmovne rsi,rcx
  219bfb:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  219bfe:	48 83 05 32 c4 02 00 	add    QWORD PTR [rip+0x2c432],0xffffffffffffffff        # 246038 <emfile_promise_queue+0x10>
  219c05:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  219c06:	74 1e                	je     219c26 <openSelfDebugInfo+0x31e6>
  219c08:	48 83 3d 18 c4 02 00 	cmp    QWORD PTR [rip+0x2c418],0x0        # 246028 <emfile_promise_queue>
  219c0f:	00 
  219c10:	0f 84 8e 0e 00 00    	je     21aaa4 <openSelfDebugInfo+0x4064>
  219c16:	48 8b 0d 13 c4 02 00 	mov    rcx,QWORD PTR [rip+0x2c413]        # 246030 <emfile_promise_queue+0x8>
  219c1d:	48 85 c9             	test   rcx,rcx
  219c20:	0f 84 7e 0e 00 00    	je     21aaa4 <openSelfDebugInfo+0x4064>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  219c26:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  219c2a:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  219c2e:	48 89 c1             	mov    rcx,rax
  219c31:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  219c35:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  219c3b:	75 f1                	jne    219c2e <openSelfDebugInfo+0x31ee>
  219c3d:	a8 01                	test   al,0x1
  219c3f:	75 05                	jne    219c46 <openSelfDebugInfo+0x3206>
  219c41:	c5 f8 77             	vzeroupper 
  219c44:	ff 17                	call   QWORD PTR [rdi]
        self.freeFn(self, non_const_ptr[0..@sizeOf(@typeOf(ptr).Child)]);
  219c46:	49 8b 44 24 10       	mov    rax,QWORD PTR [r12+0x10]
  219c4b:	48 89 ac 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rbp
  219c52:	00 
  219c53:	48 c7 84 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],0xc8
  219c5a:	00 c8 00 00 00 
  219c5f:	48 8d b4 24 f0 00 00 	lea    rsi,[rsp+0xf0]
  219c66:	00 
  219c67:	4c 89 e7             	mov    rdi,r12
  219c6a:	c5 f8 77             	vzeroupper 
  219c6d:	ff d0                	call   rax
  219c6f:	66 41 89 1e          	mov    WORD PTR [r14],bx
  219c73:	48 8b 84 24 a2 04 00 	mov    rax,QWORD PTR [rsp+0x4a2]
  219c7a:	00 
  219c7b:	48 8b 8c 24 a8 04 00 	mov    rcx,QWORD PTR [rsp+0x4a8]
  219c82:	00 
  219c83:	e9 cf da ff ff       	jmp    217757 <openSelfDebugInfo+0xd17>
  219c88:	48 8d 41 ea          	lea    rax,[rcx-0x16]
  219c8c:	48 83 f8 35          	cmp    rax,0x35
  219c90:	77 10                	ja     219ca2 <openSelfDebugInfo+0x3262>
  219c92:	48 ba 81 00 00 00 00 	movabs rdx,0x20000000000081
  219c99:	00 20 00 
  219c9c:	48 0f a3 c2          	bt     rdx,rax
  219ca0:	72 0e                	jb     219cb0 <openSelfDebugInfo+0x3270>
  219ca2:	66 bf 03 00          	mov    di,0x3
                if (err > 0) {
  219ca6:	48 83 f9 06          	cmp    rcx,0x6
  219caa:	0f 85 18 fe ff ff    	jne    219ac8 <openSelfDebugInfo+0x3088>
  219cb0:	66 bf 21 00          	mov    di,0x21
  219cb4:	89 fb                	mov    ebx,edi
  219cb6:	66 85 ff             	test   di,di
  219cb9:	0f 85 14 fe ff ff    	jne    219ad3 <openSelfDebugInfo+0x3093>
  219cbf:	e9 1a fa ff ff       	jmp    2196de <openSelfDebugInfo+0x2c9e>
            .value = try parseFormValue(st.allocator(), in_stream, attr.form_id, is_64),
  219cc4:	c5 fc 10 84 24 d8 03 	vmovups ymm0,YMMWORD PTR [rsp+0x3d8]
  219ccb:	00 00 
  219ccd:	c5 fc 10 8c 24 ee 03 	vmovups ymm1,YMMWORD PTR [rsp+0x3ee]
  219cd4:	00 00 
  219cd6:	c5 fc 11 8c 24 d6 02 	vmovups YMMWORD PTR [rsp+0x2d6],ymm1
  219cdd:	00 00 
  219cdf:	c5 fc 11 84 24 c0 02 	vmovups YMMWORD PTR [rsp+0x2c0],ymm0
  219ce6:	00 00 
  219ce8:	89 c7                	mov    edi,eax
  219cea:	89 fb                	mov    ebx,edi
            try scanAllCompileUnits(st);
  219cec:	66 85 ff             	test   di,di
  219cef:	0f 85 de fd ff ff    	jne    219ad3 <openSelfDebugInfo+0x3093>
  219cf5:	e9 e4 f9 ff ff       	jmp    2196de <openSelfDebugInfo+0x2c9e>
  219cfa:	66 b9 1f 00          	mov    cx,0x1f
  219cfe:	eb 04                	jmp    219d04 <openSelfDebugInfo+0x32c4>
  219d00:	66 b9 23 00          	mov    cx,0x23
            const form_id = try readULeb128(in_stream);
  219d04:	48 8b 84 24 be 03 00 	mov    rax,QWORD PTR [rsp+0x3be]
  219d0b:	00 
  219d0c:	48 89 84 24 ee 01 00 	mov    QWORD PTR [rsp+0x1ee],rax
  219d13:	00 
  219d14:	c5 fc 10 84 24 a0 03 	vmovups ymm0,YMMWORD PTR [rsp+0x3a0]
  219d1b:	00 00 
  219d1d:	e9 46 fc ff ff       	jmp    219968 <openSelfDebugInfo+0x2f28>
  219d22:	66 b9 1f 00          	mov    cx,0x1f
  219d26:	eb 04                	jmp    219d2c <openSelfDebugInfo+0x32ec>
  219d28:	66 b9 23 00          	mov    cx,0x23
            const attr_id = try readULeb128(in_stream);
  219d2c:	48 8b 84 24 96 03 00 	mov    rax,QWORD PTR [rsp+0x396]
  219d33:	00 
  219d34:	48 89 84 24 ee 01 00 	mov    QWORD PTR [rsp+0x1ee],rax
  219d3b:	00 
  219d3c:	c5 fc 10 84 24 78 03 	vmovups ymm0,YMMWORD PTR [rsp+0x378]
  219d43:	00 00 
  219d45:	e9 1e fc ff ff       	jmp    219968 <openSelfDebugInfo+0x2f28>
  219d4a:	66 b9 1f 00          	mov    cx,0x1f
            .has_children = (try in_stream.readByte()) == DW.CHILDREN_yes,
  219d4e:	48 8b 84 24 86 04 00 	mov    rax,QWORD PTR [rsp+0x486]
  219d55:	00 
  219d56:	48 89 84 24 ee 01 00 	mov    QWORD PTR [rsp+0x1ee],rax
  219d5d:	00 
  219d5e:	c5 fc 10 84 24 68 04 	vmovups ymm0,YMMWORD PTR [rsp+0x468]
  219d65:	00 00 
  219d67:	e9 fc fb ff ff       	jmp    219968 <openSelfDebugInfo+0x2f28>
    try result.attrs.resize(table_entry.attrs.len);
  219d6c:	c5 fc 10 84 24 98 00 	vmovups ymm0,YMMWORD PTR [rsp+0x98]
  219d73:	00 00 
  219d75:	c5 fc 10 8c 24 ae 00 	vmovups ymm1,YMMWORD PTR [rsp+0xae]
  219d7c:	00 00 
  219d7e:	e9 53 ff ff ff       	jmp    219cd6 <openSelfDebugInfo+0x3296>
        try result.append(AbbrevTableEntry{
  219d83:	48 8b 84 24 a6 02 00 	mov    rax,QWORD PTR [rsp+0x2a6]
  219d8a:	00 
  219d8b:	48 89 84 24 ee 01 00 	mov    QWORD PTR [rsp+0x1ee],rax
  219d92:	00 
  219d93:	c5 fc 10 84 24 88 02 	vmovups ymm0,YMMWORD PTR [rsp+0x288]
  219d9a:	00 00 
  219d9c:	e9 c7 fb ff ff       	jmp    219968 <openSelfDebugInfo+0x2f28>
            try attrs.append(AbbrevAttr{
  219da1:	48 8b 84 24 6e 03 00 	mov    rax,QWORD PTR [rsp+0x36e]
  219da8:	00 
  219da9:	48 89 84 24 ee 01 00 	mov    QWORD PTR [rsp+0x1ee],rax
  219db0:	00 
  219db1:	c5 fc 10 84 24 50 03 	vmovups ymm0,YMMWORD PTR [rsp+0x350]
  219db8:	00 00 
  219dba:	e9 a9 fb ff ff       	jmp    219968 <openSelfDebugInfo+0x2f28>
            try self.readNoEof(bytes[0..]);
  219dbf:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  219dc4:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  219dcb:	00 
  219dcc:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x4
  219dd3:	00 04 00 00 00 
  219dd8:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  219ddf:	00 
  219de0:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  219de7:	00 
            return self.readFn(self, buffer);
  219de8:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  219ded:	ff 54 24 58          	call   QWORD PTR [rsp+0x58]
  219df1:	44 0f b7 ac 24 f0 00 	movzx  r13d,WORD PTR [rsp+0xf0]
  219df8:	00 00 
            const amt_read = try self.read(buf);
  219dfa:	66 45 85 ed          	test   r13w,r13w
  219dfe:	0f 85 88 ce ff ff    	jne    216c8c <openSelfDebugInfo+0x24c>
  219e04:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  219e0b:	00 
  219e0c:	66 41 bd 1f 00       	mov    r13w,0x1f
            if (amt_read < buf.len) return error.EndOfStream;
  219e11:	48 3b 84 24 a0 00 00 	cmp    rax,QWORD PTR [rsp+0xa0]
  219e18:	00 
  219e19:	0f 82 6d ce ff ff    	jb     216c8c <openSelfDebugInfo+0x24c>
  219e1f:	0f b6 44 24 20       	movzx  eax,BYTE PTR [rsp+0x20]
  219e24:	0f b6 4c 24 21       	movzx  ecx,BYTE PTR [rsp+0x21]
    switch (endian) {
  219e29:	f6 44 24 40 01       	test   BYTE PTR [rsp+0x40],0x1
  219e2e:	74 1b                	je     219e4b <openSelfDebugInfo+0x340b>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  219e30:	c1 e1 08             	shl    ecx,0x8
  219e33:	09 c1                	or     ecx,eax
  219e35:	0f b6 54 24 22       	movzx  edx,BYTE PTR [rsp+0x22]
  219e3a:	c1 e2 10             	shl    edx,0x10
  219e3d:	09 ca                	or     edx,ecx
  219e3f:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  219e44:	c1 e0 18             	shl    eax,0x18
  219e47:	09 d0                	or     eax,edx
  219e49:	eb 19                	jmp    219e64 <openSelfDebugInfo+0x3424>
                result = (result << 8) | b;
  219e4b:	c1 e0 08             	shl    eax,0x8
  219e4e:	09 c8                	or     eax,ecx
  219e50:	c1 e0 08             	shl    eax,0x8
  219e53:	0f b6 4c 24 22       	movzx  ecx,BYTE PTR [rsp+0x22]
  219e58:	09 c1                	or     ecx,eax
  219e5a:	c1 e1 08             	shl    ecx,0x8
  219e5d:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  219e62:	09 c8                	or     eax,ecx
            elf.entry_addr = u64(try in.readInt(elf.endian, u32));
  219e64:	89 c0                	mov    eax,eax
  219e66:	48 89 45 18          	mov    QWORD PTR [rbp+0x18],rax
            elf.program_header_offset = u64(try in.readInt(elf.endian, u32));
  219e6a:	8a 45 12             	mov    al,BYTE PTR [rbp+0x12]
            try self.readNoEof(bytes[0..]);
  219e6d:	88 44 24 40          	mov    BYTE PTR [rsp+0x40],al
  219e71:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  219e76:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  219e7d:	00 
  219e7e:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x4
  219e85:	00 04 00 00 00 
  219e8a:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  219e91:	00 
  219e92:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  219e99:	00 
            return self.readFn(self, buffer);
  219e9a:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  219e9f:	ff 54 24 58          	call   QWORD PTR [rsp+0x58]
  219ea3:	44 0f b7 ac 24 f0 00 	movzx  r13d,WORD PTR [rsp+0xf0]
  219eaa:	00 00 
            const amt_read = try self.read(buf);
  219eac:	66 45 85 ed          	test   r13w,r13w
  219eb0:	0f 85 d6 cd ff ff    	jne    216c8c <openSelfDebugInfo+0x24c>
  219eb6:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  219ebd:	00 
  219ebe:	66 41 bd 1f 00       	mov    r13w,0x1f
            if (amt_read < buf.len) return error.EndOfStream;
  219ec3:	48 3b 84 24 a0 00 00 	cmp    rax,QWORD PTR [rsp+0xa0]
  219eca:	00 
  219ecb:	0f 82 bb cd ff ff    	jb     216c8c <openSelfDebugInfo+0x24c>
  219ed1:	0f b6 44 24 20       	movzx  eax,BYTE PTR [rsp+0x20]
  219ed6:	0f b6 4c 24 21       	movzx  ecx,BYTE PTR [rsp+0x21]
    switch (endian) {
  219edb:	f6 44 24 40 01       	test   BYTE PTR [rsp+0x40],0x1
  219ee0:	74 1b                	je     219efd <openSelfDebugInfo+0x34bd>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  219ee2:	c1 e1 08             	shl    ecx,0x8
  219ee5:	09 c1                	or     ecx,eax
  219ee7:	0f b6 54 24 22       	movzx  edx,BYTE PTR [rsp+0x22]
  219eec:	c1 e2 10             	shl    edx,0x10
  219eef:	09 ca                	or     edx,ecx
  219ef1:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  219ef6:	c1 e0 18             	shl    eax,0x18
  219ef9:	09 d0                	or     eax,edx
  219efb:	eb 19                	jmp    219f16 <openSelfDebugInfo+0x34d6>
                result = (result << 8) | b;
  219efd:	c1 e0 08             	shl    eax,0x8
  219f00:	09 c8                	or     eax,ecx
  219f02:	c1 e0 08             	shl    eax,0x8
  219f05:	0f b6 4c 24 22       	movzx  ecx,BYTE PTR [rsp+0x22]
  219f0a:	09 c1                	or     ecx,eax
  219f0c:	c1 e1 08             	shl    ecx,0x8
  219f0f:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  219f14:	09 c8                	or     eax,ecx
  219f16:	89 c0                	mov    eax,eax
  219f18:	48 89 45 20          	mov    QWORD PTR [rbp+0x20],rax
            elf.section_header_offset = u64(try in.readInt(elf.endian, u32));
  219f1c:	8a 45 12             	mov    al,BYTE PTR [rbp+0x12]
            try self.readNoEof(bytes[0..]);
  219f1f:	88 44 24 40          	mov    BYTE PTR [rsp+0x40],al
  219f23:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  219f28:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  219f2f:	00 
  219f30:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x4
  219f37:	00 04 00 00 00 
  219f3c:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  219f43:	00 
  219f44:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  219f4b:	00 
            return self.readFn(self, buffer);
  219f4c:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  219f51:	ff 54 24 58          	call   QWORD PTR [rsp+0x58]
  219f55:	44 0f b7 ac 24 f0 00 	movzx  r13d,WORD PTR [rsp+0xf0]
  219f5c:	00 00 
            const amt_read = try self.read(buf);
  219f5e:	66 45 85 ed          	test   r13w,r13w
  219f62:	0f 85 24 cd ff ff    	jne    216c8c <openSelfDebugInfo+0x24c>
  219f68:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  219f6f:	00 
  219f70:	66 41 bd 1f 00       	mov    r13w,0x1f
            if (amt_read < buf.len) return error.EndOfStream;
  219f75:	48 3b 84 24 a0 00 00 	cmp    rax,QWORD PTR [rsp+0xa0]
  219f7c:	00 
  219f7d:	0f 82 09 cd ff ff    	jb     216c8c <openSelfDebugInfo+0x24c>
  219f83:	0f b6 44 24 20       	movzx  eax,BYTE PTR [rsp+0x20]
  219f88:	0f b6 4c 24 21       	movzx  ecx,BYTE PTR [rsp+0x21]
    switch (endian) {
  219f8d:	f6 44 24 40 01       	test   BYTE PTR [rsp+0x40],0x1
  219f92:	74 1b                	je     219faf <openSelfDebugInfo+0x356f>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  219f94:	c1 e1 08             	shl    ecx,0x8
  219f97:	09 c1                	or     ecx,eax
  219f99:	0f b6 54 24 22       	movzx  edx,BYTE PTR [rsp+0x22]
  219f9e:	c1 e2 10             	shl    edx,0x10
  219fa1:	09 ca                	or     edx,ecx
  219fa3:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  219fa8:	c1 e0 18             	shl    eax,0x18
  219fab:	09 d0                	or     eax,edx
  219fad:	eb 19                	jmp    219fc8 <openSelfDebugInfo+0x3588>
                result = (result << 8) | b;
  219faf:	c1 e0 08             	shl    eax,0x8
  219fb2:	09 c8                	or     eax,ecx
  219fb4:	c1 e0 08             	shl    eax,0x8
  219fb7:	0f b6 4c 24 22       	movzx  ecx,BYTE PTR [rsp+0x22]
  219fbc:	09 c1                	or     ecx,eax
  219fbe:	c1 e1 08             	shl    ecx,0x8
  219fc1:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  219fc6:	09 c8                	or     eax,ecx
  219fc8:	89 c0                	mov    eax,eax
  219fca:	e9 a9 d2 ff ff       	jmp    217278 <openSelfDebugInfo+0x838>
        const ph_entry_size = try in.readInt(elf.endian, u16);
  219fcf:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  219fd4:	8a 00                	mov    al,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  219fd6:	88 44 24 40          	mov    BYTE PTR [rsp+0x40],al
  219fda:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  219fdf:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  219fe6:	00 
  219fe7:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x2
  219fee:	00 02 00 00 00 
  219ff3:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  219ffa:	00 
  219ffb:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  21a002:	00 
            return self.readFn(self, buffer);
  21a003:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  21a008:	ff 54 24 58          	call   QWORD PTR [rsp+0x58]
  21a00c:	44 0f b7 ac 24 f0 00 	movzx  r13d,WORD PTR [rsp+0xf0]
  21a013:	00 00 
            const amt_read = try self.read(buf);
  21a015:	66 45 85 ed          	test   r13w,r13w
  21a019:	0f 85 6d cc ff ff    	jne    216c8c <openSelfDebugInfo+0x24c>
  21a01f:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  21a026:	00 
  21a027:	66 41 bd 1f 00       	mov    r13w,0x1f
            if (amt_read < buf.len) return error.EndOfStream;
  21a02c:	48 3b 84 24 a0 00 00 	cmp    rax,QWORD PTR [rsp+0xa0]
  21a033:	00 
  21a034:	0f 82 52 cc ff ff    	jb     216c8c <openSelfDebugInfo+0x24c>
  21a03a:	0f b6 54 24 20       	movzx  edx,BYTE PTR [rsp+0x20]
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  21a03f:	0f b6 44 24 21       	movzx  eax,BYTE PTR [rsp+0x21]
  21a044:	89 c1                	mov    ecx,eax
  21a046:	c1 e1 08             	shl    ecx,0x8
  21a049:	09 d1                	or     ecx,edx
                result = (result << 8) | b;
  21a04b:	c1 e2 08             	shl    edx,0x8
  21a04e:	09 c2                	or     edx,eax
    switch (endian) {
  21a050:	f6 44 24 40 01       	test   BYTE PTR [rsp+0x40],0x1
  21a055:	66 0f 45 d1          	cmovne dx,cx
  21a059:	89 54 24 78          	mov    DWORD PTR [rsp+0x78],edx
        const ph_entry_count = try in.readInt(elf.endian, u16);
  21a05d:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  21a062:	8a 00                	mov    al,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  21a064:	88 44 24 40          	mov    BYTE PTR [rsp+0x40],al
  21a068:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  21a06d:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  21a074:	00 
  21a075:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x2
  21a07c:	00 02 00 00 00 
  21a081:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  21a088:	00 
  21a089:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  21a090:	00 
            return self.readFn(self, buffer);
  21a091:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  21a096:	ff 54 24 58          	call   QWORD PTR [rsp+0x58]
  21a09a:	44 0f b7 ac 24 f0 00 	movzx  r13d,WORD PTR [rsp+0xf0]
  21a0a1:	00 00 
            const amt_read = try self.read(buf);
  21a0a3:	66 45 85 ed          	test   r13w,r13w
  21a0a7:	0f 85 df cb ff ff    	jne    216c8c <openSelfDebugInfo+0x24c>
  21a0ad:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  21a0b4:	00 
  21a0b5:	66 41 bd 1f 00       	mov    r13w,0x1f
            if (amt_read < buf.len) return error.EndOfStream;
  21a0ba:	48 3b 84 24 a0 00 00 	cmp    rax,QWORD PTR [rsp+0xa0]
  21a0c1:	00 
  21a0c2:	0f 82 c4 cb ff ff    	jb     216c8c <openSelfDebugInfo+0x24c>
  21a0c8:	0f b6 54 24 20       	movzx  edx,BYTE PTR [rsp+0x20]
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  21a0cd:	0f b6 44 24 21       	movzx  eax,BYTE PTR [rsp+0x21]
  21a0d2:	89 c1                	mov    ecx,eax
  21a0d4:	c1 e1 08             	shl    ecx,0x8
  21a0d7:	09 d1                	or     ecx,edx
                result = (result << 8) | b;
  21a0d9:	c1 e2 08             	shl    edx,0x8
  21a0dc:	09 c2                	or     edx,eax
    switch (endian) {
  21a0de:	f6 44 24 40 01       	test   BYTE PTR [rsp+0x40],0x1
  21a0e3:	66 0f 45 d1          	cmovne dx,cx
  21a0e7:	89 94 24 90 00 00 00 	mov    DWORD PTR [rsp+0x90],edx
        const sh_entry_size = try in.readInt(elf.endian, u16);
  21a0ee:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  21a0f3:	8a 00                	mov    al,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  21a0f5:	88 44 24 40          	mov    BYTE PTR [rsp+0x40],al
  21a0f9:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  21a0fe:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  21a105:	00 
  21a106:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x2
  21a10d:	00 02 00 00 00 
  21a112:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  21a119:	00 
  21a11a:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  21a121:	00 
            return self.readFn(self, buffer);
  21a122:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  21a127:	ff 54 24 58          	call   QWORD PTR [rsp+0x58]
  21a12b:	44 0f b7 ac 24 f0 00 	movzx  r13d,WORD PTR [rsp+0xf0]
  21a132:	00 00 
            const amt_read = try self.read(buf);
  21a134:	66 45 85 ed          	test   r13w,r13w
  21a138:	0f 85 4e cb ff ff    	jne    216c8c <openSelfDebugInfo+0x24c>
  21a13e:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  21a145:	00 
  21a146:	66 41 bd 1f 00       	mov    r13w,0x1f
            if (amt_read < buf.len) return error.EndOfStream;
  21a14b:	48 3b 84 24 a0 00 00 	cmp    rax,QWORD PTR [rsp+0xa0]
  21a152:	00 
  21a153:	0f 82 33 cb ff ff    	jb     216c8c <openSelfDebugInfo+0x24c>
  21a159:	0f b6 54 24 20       	movzx  edx,BYTE PTR [rsp+0x20]
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  21a15e:	0f b6 44 24 21       	movzx  eax,BYTE PTR [rsp+0x21]
  21a163:	89 c1                	mov    ecx,eax
  21a165:	c1 e1 08             	shl    ecx,0x8
  21a168:	09 d1                	or     ecx,edx
                result = (result << 8) | b;
  21a16a:	c1 e2 08             	shl    edx,0x8
  21a16d:	09 c2                	or     edx,eax
    switch (endian) {
  21a16f:	f6 44 24 40 01       	test   BYTE PTR [rsp+0x40],0x1
  21a174:	66 0f 45 d1          	cmovne dx,cx
  21a178:	89 54 24 48          	mov    DWORD PTR [rsp+0x48],edx
        const sh_entry_count = try in.readInt(elf.endian, u16);
  21a17c:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  21a181:	8a 00                	mov    al,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  21a183:	88 44 24 40          	mov    BYTE PTR [rsp+0x40],al
  21a187:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  21a18c:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  21a193:	00 
  21a194:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x2
  21a19b:	00 02 00 00 00 
  21a1a0:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  21a1a7:	00 
  21a1a8:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  21a1af:	00 
            return self.readFn(self, buffer);
  21a1b0:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  21a1b5:	ff 54 24 58          	call   QWORD PTR [rsp+0x58]
  21a1b9:	44 0f b7 ac 24 f0 00 	movzx  r13d,WORD PTR [rsp+0xf0]
  21a1c0:	00 00 
            const amt_read = try self.read(buf);
  21a1c2:	66 45 85 ed          	test   r13w,r13w
  21a1c6:	0f 85 c0 ca ff ff    	jne    216c8c <openSelfDebugInfo+0x24c>
  21a1cc:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  21a1d3:	00 
  21a1d4:	66 41 bd 1f 00       	mov    r13w,0x1f
            if (amt_read < buf.len) return error.EndOfStream;
  21a1d9:	48 3b 84 24 a0 00 00 	cmp    rax,QWORD PTR [rsp+0xa0]
  21a1e0:	00 
  21a1e1:	0f 82 a5 ca ff ff    	jb     216c8c <openSelfDebugInfo+0x24c>
  21a1e7:	0f b6 54 24 20       	movzx  edx,BYTE PTR [rsp+0x20]
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  21a1ec:	0f b6 44 24 21       	movzx  eax,BYTE PTR [rsp+0x21]
  21a1f1:	89 c1                	mov    ecx,eax
  21a1f3:	c1 e1 08             	shl    ecx,0x8
  21a1f6:	09 d1                	or     ecx,edx
                result = (result << 8) | b;
  21a1f8:	c1 e2 08             	shl    edx,0x8
  21a1fb:	09 c2                	or     edx,eax
    switch (endian) {
  21a1fd:	f6 44 24 40 01       	test   BYTE PTR [rsp+0x40],0x1
  21a202:	66 0f 45 d1          	cmovne dx,cx
  21a206:	89 54 24 40          	mov    DWORD PTR [rsp+0x40],edx
        elf.string_section_index = u64(try in.readInt(elf.endian, u16));
  21a20a:	8a 45 12             	mov    al,BYTE PTR [rbp+0x12]
            try self.readNoEof(bytes[0..]);
  21a20d:	88 84 24 80 00 00 00 	mov    BYTE PTR [rsp+0x80],al
  21a214:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  21a219:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  21a220:	00 
  21a221:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x2
  21a228:	00 02 00 00 00 
  21a22d:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  21a234:	00 
  21a235:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  21a23c:	00 
  21a23d:	48 89 bc 24 88 00 00 	mov    QWORD PTR [rsp+0x88],rdi
  21a244:	00 
            return self.readFn(self, buffer);
  21a245:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  21a24a:	ff 54 24 58          	call   QWORD PTR [rsp+0x58]
  21a24e:	44 0f b7 ac 24 f0 00 	movzx  r13d,WORD PTR [rsp+0xf0]
  21a255:	00 00 
            const amt_read = try self.read(buf);
  21a257:	66 45 85 ed          	test   r13w,r13w
  21a25b:	0f 85 2b ca ff ff    	jne    216c8c <openSelfDebugInfo+0x24c>
  21a261:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  21a268:	00 
  21a269:	66 41 bd 1f 00       	mov    r13w,0x1f
            if (amt_read < buf.len) return error.EndOfStream;
  21a26e:	48 3b 84 24 a0 00 00 	cmp    rax,QWORD PTR [rsp+0xa0]
  21a275:	00 
  21a276:	0f 82 10 ca ff ff    	jb     216c8c <openSelfDebugInfo+0x24c>
  21a27c:	0f b6 44 24 20       	movzx  eax,BYTE PTR [rsp+0x20]
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  21a281:	0f b6 4c 24 21       	movzx  ecx,BYTE PTR [rsp+0x21]
  21a286:	89 ca                	mov    edx,ecx
  21a288:	c1 e2 08             	shl    edx,0x8
  21a28b:	09 c2                	or     edx,eax
                result = (result << 8) | b;
  21a28d:	c1 e0 08             	shl    eax,0x8
  21a290:	09 c8                	or     eax,ecx
    switch (endian) {
  21a292:	f6 84 24 80 00 00 00 	test   BYTE PTR [rsp+0x80],0x1
  21a299:	01 
  21a29a:	66 0f 45 c2          	cmovne ax,dx
  21a29e:	0f b7 c0             	movzx  eax,ax
  21a2a1:	48 89 45 30          	mov    QWORD PTR [rbp+0x30],rax
        if (elf.string_section_index >= sh_entry_count) return error.InvalidFormat;
  21a2a5:	66 3b 44 24 40       	cmp    ax,WORD PTR [rsp+0x40]
  21a2aa:	0f 83 c3 d0 ff ff    	jae    217373 <openSelfDebugInfo+0x933>
  21a2b0:	0f b7 4c 24 40       	movzx  ecx,WORD PTR [rsp+0x40]
        const sh_byte_count = u64(sh_entry_size) * u64(sh_entry_count);
  21a2b5:	0f b7 44 24 48       	movzx  eax,WORD PTR [rsp+0x48]
  21a2ba:	48 89 44 24 48       	mov    QWORD PTR [rsp+0x48],rax
  21a2bf:	48 89 4c 24 40       	mov    QWORD PTR [rsp+0x40],rcx
  21a2c4:	48 0f af c1          	imul   rax,rcx
    return if (@addWithOverflow(T, a, b, &answer)) error.Overflow else answer;
  21a2c8:	48 03 45 28          	add    rax,QWORD PTR [rbp+0x28]
  21a2cc:	73 27                	jae    21a2f5 <openSelfDebugInfo+0x38b5>
  21a2ce:	48 8d 05 2b 62 fe ff 	lea    rax,[rip+0xfffffffffffe622b]        # 200500 <__unnamed_52>
  21a2d5:	48 89 84 24 88 00 00 	mov    QWORD PTR [rsp+0x88],rax
  21a2dc:	00 
  21a2dd:	48 8b 84 24 88 00 00 	mov    rax,QWORD PTR [rsp+0x88]
  21a2e4:	00 
  21a2e5:	44 0f b7 28          	movzx  r13d,WORD PTR [rax]
        const end_sh = try math.add(u64, elf.section_header_offset, sh_byte_count);
  21a2e9:	66 45 85 ed          	test   r13w,r13w
  21a2ed:	0f 85 99 c9 ff ff    	jne    216c8c <openSelfDebugInfo+0x24c>
  21a2f3:	eb 28                	jmp    21a31d <openSelfDebugInfo+0x38dd>
  21a2f5:	66 c7 84 24 f0 00 00 	mov    WORD PTR [rsp+0xf0],0x0
  21a2fc:	00 00 00 
  21a2ff:	48 89 84 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],rax
  21a306:	00 
  21a307:	48 8b 84 24 88 00 00 	mov    rax,QWORD PTR [rsp+0x88]
  21a30e:	00 
  21a30f:	44 0f b7 28          	movzx  r13d,WORD PTR [rax]
  21a313:	66 45 85 ed          	test   r13w,r13w
  21a317:	0f 85 6f c9 ff ff    	jne    216c8c <openSelfDebugInfo+0x24c>
  21a31d:	48 8b 84 24 88 00 00 	mov    rax,QWORD PTR [rsp+0x88]
  21a324:	00 
  21a325:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
        const ph_byte_count = u64(ph_entry_size) * u64(ph_entry_count);
  21a329:	0f b7 44 24 78       	movzx  eax,WORD PTR [rsp+0x78]
  21a32e:	0f b7 8c 24 90 00 00 	movzx  ecx,WORD PTR [rsp+0x90]
  21a335:	00 
  21a336:	48 0f af c8          	imul   rcx,rax
  21a33a:	48 03 4d 20          	add    rcx,QWORD PTR [rbp+0x20]
  21a33e:	73 17                	jae    21a357 <openSelfDebugInfo+0x3917>
  21a340:	48 8d 05 b9 61 fe ff 	lea    rax,[rip+0xfffffffffffe61b9]        # 200500 <__unnamed_52>
  21a347:	44 0f b7 28          	movzx  r13d,WORD PTR [rax]
        const end_ph = try math.add(u64, elf.program_header_offset, ph_byte_count);
  21a34b:	66 45 85 ed          	test   r13w,r13w
  21a34f:	0f 85 37 c9 ff ff    	jne    216c8c <openSelfDebugInfo+0x24c>
  21a355:	eb 28                	jmp    21a37f <openSelfDebugInfo+0x393f>
  21a357:	48 8d 84 24 f0 00 00 	lea    rax,[rsp+0xf0]
  21a35e:	00 
  21a35f:	66 c7 84 24 f0 00 00 	mov    WORD PTR [rsp+0xf0],0x0
  21a366:	00 00 00 
  21a369:	48 89 8c 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],rcx
  21a370:	00 
  21a371:	44 0f b7 28          	movzx  r13d,WORD PTR [rax]
  21a375:	66 45 85 ed          	test   r13w,r13w
  21a379:	0f 85 0d c9 ff ff    	jne    216c8c <openSelfDebugInfo+0x24c>
  21a37f:	4c 8b 40 08          	mov    r8,QWORD PTR [rax+0x8]
        const stream_end = try elf.in_file.getEndPos();
  21a383:	49 8b 07             	mov    rax,QWORD PTR [r15]
pub fn accept4(fd: i32, noalias addr: *sockaddr, noalias len: *socklen_t, flags: u32) usize {
    return syscall4(SYS_accept4, @intCast(usize, fd), @ptrToInt(addr), @ptrToInt(len), flags);
}

pub fn fstat(fd: i32, stat_buf: *Stat) usize {
    return syscall2(SYS_fstat, @intCast(usize, fd), @ptrToInt(stat_buf));
  21a386:	48 63 38             	movsxd rdi,DWORD PTR [rax]
        }
    }
}

pub fn posixFStat(fd: i32) !posix.Stat {
    var stat: posix.Stat = undefined;
  21a389:	c5 fc 10 05 3f dc fe 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffedc3f]        # 207fd0 <__unnamed_69+0x70>
  21a390:	ff 
  21a391:	c5 fc 11 84 24 60 01 	vmovups YMMWORD PTR [rsp+0x160],ymm0
  21a398:	00 00 
  21a39a:	c5 fc 10 05 1e dc fe 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffedc1e]        # 207fc0 <__unnamed_69+0x60>
  21a3a1:	ff 
  21a3a2:	c5 fc 11 84 24 50 01 	vmovups YMMWORD PTR [rsp+0x150],ymm0
  21a3a9:	00 00 
  21a3ab:	c5 fc 10 05 ed db fe 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffedbed]        # 207fa0 <__unnamed_69+0x40>
  21a3b2:	ff 
  21a3b3:	c5 fc 11 84 24 30 01 	vmovups YMMWORD PTR [rsp+0x130],ymm0
  21a3ba:	00 00 
  21a3bc:	c5 fc 10 05 bc db fe 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffedbbc]        # 207f80 <__unnamed_69+0x20>
  21a3c3:	ff 
  21a3c4:	c5 fc 11 84 24 10 01 	vmovups YMMWORD PTR [rsp+0x110],ymm0
  21a3cb:	00 00 
  21a3cd:	c5 fe 6f 05 8b db fe 	vmovdqu ymm0,YMMWORD PTR [rip+0xfffffffffffedb8b]        # 207f60 <__unnamed_69>
  21a3d4:	ff 
  21a3d5:	c5 fe 7f 84 24 f0 00 	vmovdqu YMMWORD PTR [rsp+0xf0],ymm0
  21a3dc:	00 00 
  21a3de:	48 8d b4 24 f0 00 00 	lea    rsi,[rsp+0xf0]
  21a3e5:	00 
    return asm volatile ("syscall"
  21a3e6:	b8 05 00 00 00       	mov    eax,0x5
  21a3eb:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  21a3ed:	48 89 c6             	mov    rsi,rax
  21a3f0:	48 f7 de             	neg    rsi
  21a3f3:	31 c9                	xor    ecx,ecx
  21a3f5:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  21a3fb:	48 0f 47 ce          	cmova  rcx,rsi
    const err = posix.getErrno(posix.fstat(fd, &stat));
    if (err > 0) {
  21a3ff:	48 85 c9             	test   rcx,rcx
  21a402:	74 23                	je     21a427 <openSelfDebugInfo+0x39e7>
  21a404:	66 41 bd 06 00       	mov    r13w,0x6
  21a409:	48 83 f9 0c          	cmp    rcx,0xc
  21a40d:	0f 84 79 c8 ff ff    	je     216c8c <openSelfDebugInfo+0x24c>
  21a413:	66 41 bd 03 00       	mov    r13w,0x3
            try st.elf.openFile(allocator, &st.self_exe_file);
  21a418:	66 45 85 ed          	test   r13w,r13w
  21a41c:	0f 85 74 c8 ff ff    	jne    216c96 <openSelfDebugInfo+0x256>
  21a422:	e9 5b cf ff ff       	jmp    217382 <openSelfDebugInfo+0x942>
            posix.ENOMEM => error.SystemResources,
            else => os.unexpectedErrorPosix(err),
        };
    }

    return stat;
  21a427:	48 8b 84 24 20 01 00 	mov    rax,QWORD PTR [rsp+0x120]
  21a42e:	00 
  21a42f:	48 89 84 24 c8 01 00 	mov    QWORD PTR [rsp+0x1c8],rax
  21a436:	00 
  21a437:	66 41 bd 20 00       	mov    r13w,0x20
        if (stream_end < end_sh or stream_end < end_ph) {
  21a43c:	48 39 d0             	cmp    rax,rdx
  21a43f:	0f 82 47 c8 ff ff    	jb     216c8c <openSelfDebugInfo+0x24c>
  21a445:	4c 39 84 24 c8 01 00 	cmp    QWORD PTR [rsp+0x1c8],r8
  21a44c:	00 
  21a44d:	0f 82 39 c8 ff ff    	jb     216c8c <openSelfDebugInfo+0x24c>
        try elf.in_file.seekTo(elf.section_header_offset);
  21a453:	48 8b 75 28          	mov    rsi,QWORD PTR [rbp+0x28]
    if (@maxValue(@typeOf(x)) > @maxValue(T) and x > @maxValue(T)) {
  21a457:	48 85 f6             	test   rsi,rsi
  21a45a:	0f 88 4c 06 00 00    	js     21aaac <openSelfDebugInfo+0x406c>
  21a460:	49 8b 07             	mov    rax,QWORD PTR [r15]
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  21a463:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  21a466:	45 31 c0             	xor    r8d,r8d
    return asm volatile ("syscall"
  21a469:	b8 08 00 00 00       	mov    eax,0x8
  21a46e:	31 d2                	xor    edx,edx
  21a470:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  21a472:	48 89 c1             	mov    rcx,rax
  21a475:	48 f7 d9             	neg    rcx
  21a478:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  21a47e:	49 0f 46 c8          	cmovbe rcx,r8
  21a482:	48 83 f9 1d          	cmp    rcx,0x1d
  21a486:	0f 87 04 06 00 00    	ja     21aa90 <openSelfDebugInfo+0x4050>
  21a48c:	48 8d 05 85 6c fe ff 	lea    rax,[rip+0xfffffffffffe6c85]        # 201118 <app_mask+0x438>
  21a493:	48 63 0c 88          	movsxd rcx,DWORD PTR [rax+rcx*4]
  21a497:	48 01 c1             	add    rcx,rax
  21a49a:	66 41 bd 03 00       	mov    r13w,0x3
  21a49f:	ff e1                	jmp    rcx
        elf.section_headers = try elf.allocator.alloc(SectionHeader, sh_entry_count);
  21a4a1:	48 8b 75 50          	mov    rsi,QWORD PTR [rbp+0x50]
    return if (@mulWithOverflow(T, a, b, &answer)) error.Overflow else answer;
  21a4a5:	48 8b 54 24 40       	mov    rdx,QWORD PTR [rsp+0x40]
  21a4aa:	48 c1 e2 06          	shl    rdx,0x6
  21a4ae:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  21a4b5:	00 
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  21a4b6:	b9 04 00 00 00       	mov    ecx,0x4
  21a4bb:	48 89 94 24 80 01 00 	mov    QWORD PTR [rsp+0x180],rdx
  21a4c2:	00 
  21a4c3:	c5 f8 77             	vzeroupper 
  21a4c6:	ff 16                	call   QWORD PTR [rsi]
  21a4c8:	44 0f b7 ac 24 f0 00 	movzx  r13d,WORD PTR [rsp+0xf0]
  21a4cf:	00 00 
  21a4d1:	66 45 85 ed          	test   r13w,r13w
  21a4d5:	0f 85 b1 c7 ff ff    	jne    216c8c <openSelfDebugInfo+0x24c>
        assert(byte_slice.len == byte_count);
  21a4db:	48 8b 84 24 80 01 00 	mov    rax,QWORD PTR [rsp+0x180]
  21a4e2:	00 
  21a4e3:	48 39 84 24 00 01 00 	cmp    QWORD PTR [rsp+0x100],rax
  21a4ea:	00 
    if (!ok) {
  21a4eb:	0f 85 b3 05 00 00    	jne    21aaa4 <openSelfDebugInfo+0x4064>
  21a4f1:	48 8d 45 50          	lea    rax,[rbp+0x50]
  21a4f5:	48 89 44 24 78       	mov    QWORD PTR [rsp+0x78],rax
  21a4fa:	48 8d 45 40          	lea    rax,[rbp+0x40]
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  21a4fe:	48 89 84 24 90 00 00 	mov    QWORD PTR [rsp+0x90],rax
  21a505:	00 
  21a506:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  21a50d:	00 
  21a50e:	48 89 84 24 80 00 00 	mov    QWORD PTR [rsp+0x80],rax
  21a515:	00 
  21a516:	48 89 45 40          	mov    QWORD PTR [rbp+0x40],rax
  21a51a:	48 8d 45 48          	lea    rax,[rbp+0x48]
  21a51e:	48 89 84 24 88 00 00 	mov    QWORD PTR [rsp+0x88],rax
  21a525:	00 
  21a526:	48 8b 44 24 40       	mov    rax,QWORD PTR [rsp+0x40]
  21a52b:	48 89 45 48          	mov    QWORD PTR [rbp+0x48],rax
        if (elf.is_64) {
  21a52f:	80 7d 11 01          	cmp    BYTE PTR [rbp+0x11],0x1
  21a533:	0f 85 87 05 00 00    	jne    21aac0 <openSelfDebugInfo+0x4080>
            if (sh_entry_size != 64) return error.InvalidFormat;
  21a539:	83 7c 24 48 40       	cmp    DWORD PTR [rsp+0x48],0x40
  21a53e:	0f 85 dd 0f 00 00    	jne    21b521 <openSelfDebugInfo+0x4ae1>
                elf_section.name = try in.readInt(elf.endian, u32);
  21a544:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  21a549:	8a 00                	mov    al,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  21a54b:	88 44 24 70          	mov    BYTE PTR [rsp+0x70],al
  21a54f:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  21a554:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  21a55b:	00 
  21a55c:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x4
  21a563:	00 04 00 00 00 
  21a568:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  21a56f:	00 
  21a570:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  21a577:	00 
            return self.readFn(self, buffer);
  21a578:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  21a57d:	ff 54 24 58          	call   QWORD PTR [rsp+0x58]
  21a581:	44 0f b7 ac 24 f0 00 	movzx  r13d,WORD PTR [rsp+0xf0]
  21a588:	00 00 
            const amt_read = try self.read(buf);
  21a58a:	66 45 85 ed          	test   r13w,r13w
  21a58e:	0f 85 cd 0f 00 00    	jne    21b561 <openSelfDebugInfo+0x4b21>
  21a594:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  21a59b:	00 
  21a59c:	31 c9                	xor    ecx,ecx
  21a59e:	48 89 8c 24 80 01 00 	mov    QWORD PTR [rsp+0x180],rcx
  21a5a5:	00 
  21a5a6:	b9 38 00 00 00       	mov    ecx,0x38
  21a5ab:	48 89 4c 24 48       	mov    QWORD PTR [rsp+0x48],rcx
            if (amt_read < buf.len) return error.EndOfStream;
  21a5b0:	48 3b 84 24 a0 00 00 	cmp    rax,QWORD PTR [rsp+0xa0]
  21a5b7:	00 
  21a5b8:	0f 82 9e 0f 00 00    	jb     21b55c <openSelfDebugInfo+0x4b1c>
  21a5be:	0f b6 44 24 20       	movzx  eax,BYTE PTR [rsp+0x20]
  21a5c3:	0f b6 4c 24 21       	movzx  ecx,BYTE PTR [rsp+0x21]
    switch (endian) {
  21a5c8:	f6 44 24 70 01       	test   BYTE PTR [rsp+0x70],0x1
  21a5cd:	74 1b                	je     21a5ea <openSelfDebugInfo+0x3baa>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  21a5cf:	c1 e1 08             	shl    ecx,0x8
  21a5d2:	09 c1                	or     ecx,eax
  21a5d4:	0f b6 54 24 22       	movzx  edx,BYTE PTR [rsp+0x22]
  21a5d9:	c1 e2 10             	shl    edx,0x10
  21a5dc:	09 ca                	or     edx,ecx
  21a5de:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  21a5e3:	c1 e0 18             	shl    eax,0x18
  21a5e6:	09 d0                	or     eax,edx
  21a5e8:	eb 19                	jmp    21a603 <openSelfDebugInfo+0x3bc3>
                result = (result << 8) | b;
  21a5ea:	c1 e0 08             	shl    eax,0x8
  21a5ed:	09 c8                	or     eax,ecx
  21a5ef:	c1 e0 08             	shl    eax,0x8
  21a5f2:	0f b6 4c 24 22       	movzx  ecx,BYTE PTR [rsp+0x22]
  21a5f7:	09 c1                	or     ecx,eax
  21a5f9:	c1 e1 08             	shl    ecx,0x8
  21a5fc:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  21a601:	09 c8                	or     eax,ecx
  21a603:	48 8b 8c 24 80 00 00 	mov    rcx,QWORD PTR [rsp+0x80]
  21a60a:	00 
  21a60b:	48 8b 54 24 48       	mov    rdx,QWORD PTR [rsp+0x48]
  21a610:	89 44 11 c8          	mov    DWORD PTR [rcx+rdx*1-0x38],eax
                elf_section.sh_type = try in.readInt(elf.endian, u32);
  21a614:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  21a619:	0f b6 00             	movzx  eax,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  21a61c:	88 44 24 70          	mov    BYTE PTR [rsp+0x70],al
  21a620:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  21a625:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  21a62c:	00 
  21a62d:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x4
  21a634:	00 04 00 00 00 
            return self.readFn(self, buffer);
  21a639:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  21a640:	00 
  21a641:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  21a646:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  21a64d:	00 
  21a64e:	ff 54 24 58          	call   QWORD PTR [rsp+0x58]
  21a652:	44 0f b7 ac 24 f0 00 	movzx  r13d,WORD PTR [rsp+0xf0]
  21a659:	00 00 
            const amt_read = try self.read(buf);
  21a65b:	66 45 85 ed          	test   r13w,r13w
  21a65f:	0f 85 fc 0e 00 00    	jne    21b561 <openSelfDebugInfo+0x4b21>
  21a665:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  21a66c:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  21a66d:	48 3b 84 24 a0 00 00 	cmp    rax,QWORD PTR [rsp+0xa0]
  21a674:	00 
  21a675:	0f 82 e1 0e 00 00    	jb     21b55c <openSelfDebugInfo+0x4b1c>
  21a67b:	0f b6 44 24 20       	movzx  eax,BYTE PTR [rsp+0x20]
  21a680:	0f b6 4c 24 21       	movzx  ecx,BYTE PTR [rsp+0x21]
    switch (endian) {
  21a685:	f6 44 24 70 01       	test   BYTE PTR [rsp+0x70],0x1
  21a68a:	74 1b                	je     21a6a7 <openSelfDebugInfo+0x3c67>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  21a68c:	c1 e1 08             	shl    ecx,0x8
  21a68f:	09 c1                	or     ecx,eax
  21a691:	0f b6 54 24 22       	movzx  edx,BYTE PTR [rsp+0x22]
  21a696:	c1 e2 10             	shl    edx,0x10
  21a699:	09 ca                	or     edx,ecx
  21a69b:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  21a6a0:	c1 e0 18             	shl    eax,0x18
  21a6a3:	09 d0                	or     eax,edx
  21a6a5:	eb 19                	jmp    21a6c0 <openSelfDebugInfo+0x3c80>
                result = (result << 8) | b;
  21a6a7:	c1 e0 08             	shl    eax,0x8
  21a6aa:	09 c8                	or     eax,ecx
  21a6ac:	c1 e0 08             	shl    eax,0x8
  21a6af:	0f b6 4c 24 22       	movzx  ecx,BYTE PTR [rsp+0x22]
  21a6b4:	09 c1                	or     ecx,eax
  21a6b6:	c1 e1 08             	shl    ecx,0x8
  21a6b9:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  21a6be:	09 c8                	or     eax,ecx
  21a6c0:	48 8b 8c 24 80 00 00 	mov    rcx,QWORD PTR [rsp+0x80]
  21a6c7:	00 
  21a6c8:	48 8b 54 24 48       	mov    rdx,QWORD PTR [rsp+0x48]
  21a6cd:	89 44 11 cc          	mov    DWORD PTR [rcx+rdx*1-0x34],eax
                elf_section.flags = try in.readInt(elf.endian, u64);
  21a6d1:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  21a6d6:	0f b6 10             	movzx  edx,BYTE PTR [rax]
  21a6d9:	48 8d bc 24 78 03 00 	lea    rdi,[rsp+0x378]
  21a6e0:	00 
  21a6e1:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  21a6e6:	e8 f5 12 00 00       	call   21b9e0 <InStream(ReadError)_readInt.45>
  21a6eb:	44 0f b7 ac 24 78 03 	movzx  r13d,WORD PTR [rsp+0x378]
  21a6f2:	00 00 
  21a6f4:	66 45 85 ed          	test   r13w,r13w
  21a6f8:	0f 85 ef 0b 00 00    	jne    21b2ed <openSelfDebugInfo+0x48ad>
  21a6fe:	48 8b 84 24 80 03 00 	mov    rax,QWORD PTR [rsp+0x380]
  21a705:	00 
  21a706:	48 8b 8c 24 80 00 00 	mov    rcx,QWORD PTR [rsp+0x80]
  21a70d:	00 
  21a70e:	48 8b 54 24 48       	mov    rdx,QWORD PTR [rsp+0x48]
  21a713:	48 89 44 11 d0       	mov    QWORD PTR [rcx+rdx*1-0x30],rax
                elf_section.addr = try in.readInt(elf.endian, u64);
  21a718:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  21a71d:	0f b6 10             	movzx  edx,BYTE PTR [rax]
  21a720:	48 8d bc 24 a0 03 00 	lea    rdi,[rsp+0x3a0]
  21a727:	00 
  21a728:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  21a72d:	e8 ae 12 00 00       	call   21b9e0 <InStream(ReadError)_readInt.45>
  21a732:	44 0f b7 ac 24 a0 03 	movzx  r13d,WORD PTR [rsp+0x3a0]
  21a739:	00 00 
  21a73b:	66 45 85 ed          	test   r13w,r13w
  21a73f:	0f 85 06 0c 00 00    	jne    21b34b <openSelfDebugInfo+0x490b>
  21a745:	48 8b 84 24 a8 03 00 	mov    rax,QWORD PTR [rsp+0x3a8]
  21a74c:	00 
  21a74d:	48 8b 8c 24 80 00 00 	mov    rcx,QWORD PTR [rsp+0x80]
  21a754:	00 
  21a755:	48 8b 54 24 48       	mov    rdx,QWORD PTR [rsp+0x48]
  21a75a:	48 89 44 11 d8       	mov    QWORD PTR [rcx+rdx*1-0x28],rax
                elf_section.offset = try in.readInt(elf.endian, u64);
  21a75f:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  21a764:	0f b6 10             	movzx  edx,BYTE PTR [rax]
  21a767:	48 8d bc 24 50 03 00 	lea    rdi,[rsp+0x350]
  21a76e:	00 
  21a76f:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  21a774:	e8 67 12 00 00       	call   21b9e0 <InStream(ReadError)_readInt.45>
  21a779:	44 0f b7 ac 24 50 03 	movzx  r13d,WORD PTR [rsp+0x350]
  21a780:	00 00 
  21a782:	66 45 85 ed          	test   r13w,r13w
  21a786:	0f 85 1d 0c 00 00    	jne    21b3a9 <openSelfDebugInfo+0x4969>
  21a78c:	48 8b 84 24 58 03 00 	mov    rax,QWORD PTR [rsp+0x358]
  21a793:	00 
  21a794:	48 8b 8c 24 80 00 00 	mov    rcx,QWORD PTR [rsp+0x80]
  21a79b:	00 
  21a79c:	48 8b 54 24 48       	mov    rdx,QWORD PTR [rsp+0x48]
  21a7a1:	48 89 44 11 e0       	mov    QWORD PTR [rcx+rdx*1-0x20],rax
                elf_section.size = try in.readInt(elf.endian, u64);
  21a7a6:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  21a7ab:	0f b6 10             	movzx  edx,BYTE PTR [rax]
  21a7ae:	48 8d bc 24 d0 01 00 	lea    rdi,[rsp+0x1d0]
  21a7b5:	00 
  21a7b6:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  21a7bb:	e8 20 12 00 00       	call   21b9e0 <InStream(ReadError)_readInt.45>
  21a7c0:	44 0f b7 ac 24 d0 01 	movzx  r13d,WORD PTR [rsp+0x1d0]
  21a7c7:	00 00 
  21a7c9:	66 45 85 ed          	test   r13w,r13w
  21a7cd:	0f 85 34 0c 00 00    	jne    21b407 <openSelfDebugInfo+0x49c7>
  21a7d3:	48 8b 84 24 d8 01 00 	mov    rax,QWORD PTR [rsp+0x1d8]
  21a7da:	00 
  21a7db:	48 8b 8c 24 80 00 00 	mov    rcx,QWORD PTR [rsp+0x80]
  21a7e2:	00 
  21a7e3:	48 8b 54 24 48       	mov    rdx,QWORD PTR [rsp+0x48]
  21a7e8:	48 89 44 11 e8       	mov    QWORD PTR [rcx+rdx*1-0x18],rax
                elf_section.link = try in.readInt(elf.endian, u32);
  21a7ed:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  21a7f2:	0f b6 00             	movzx  eax,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  21a7f5:	88 44 24 70          	mov    BYTE PTR [rsp+0x70],al
  21a7f9:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  21a7fe:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  21a805:	00 
  21a806:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x4
  21a80d:	00 04 00 00 00 
            return self.readFn(self, buffer);
  21a812:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  21a819:	00 
  21a81a:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  21a81f:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  21a826:	00 
  21a827:	ff 54 24 58          	call   QWORD PTR [rsp+0x58]
  21a82b:	44 0f b7 ac 24 f0 00 	movzx  r13d,WORD PTR [rsp+0xf0]
  21a832:	00 00 
            const amt_read = try self.read(buf);
  21a834:	66 45 85 ed          	test   r13w,r13w
  21a838:	0f 85 23 0d 00 00    	jne    21b561 <openSelfDebugInfo+0x4b21>
  21a83e:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  21a845:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  21a846:	48 3b 84 24 a0 00 00 	cmp    rax,QWORD PTR [rsp+0xa0]
  21a84d:	00 
  21a84e:	0f 82 08 0d 00 00    	jb     21b55c <openSelfDebugInfo+0x4b1c>
  21a854:	0f b6 44 24 20       	movzx  eax,BYTE PTR [rsp+0x20]
  21a859:	0f b6 4c 24 21       	movzx  ecx,BYTE PTR [rsp+0x21]
    switch (endian) {
  21a85e:	f6 44 24 70 01       	test   BYTE PTR [rsp+0x70],0x1
  21a863:	74 1b                	je     21a880 <openSelfDebugInfo+0x3e40>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  21a865:	c1 e1 08             	shl    ecx,0x8
  21a868:	09 c1                	or     ecx,eax
  21a86a:	0f b6 54 24 22       	movzx  edx,BYTE PTR [rsp+0x22]
  21a86f:	c1 e2 10             	shl    edx,0x10
  21a872:	09 ca                	or     edx,ecx
  21a874:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  21a879:	c1 e0 18             	shl    eax,0x18
  21a87c:	09 d0                	or     eax,edx
  21a87e:	eb 19                	jmp    21a899 <openSelfDebugInfo+0x3e59>
                result = (result << 8) | b;
  21a880:	c1 e0 08             	shl    eax,0x8
  21a883:	09 c8                	or     eax,ecx
  21a885:	c1 e0 08             	shl    eax,0x8
  21a888:	0f b6 4c 24 22       	movzx  ecx,BYTE PTR [rsp+0x22]
  21a88d:	09 c1                	or     ecx,eax
  21a88f:	c1 e1 08             	shl    ecx,0x8
  21a892:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  21a897:	09 c8                	or     eax,ecx
  21a899:	48 8b 8c 24 80 00 00 	mov    rcx,QWORD PTR [rsp+0x80]
  21a8a0:	00 
  21a8a1:	48 8b 54 24 48       	mov    rdx,QWORD PTR [rsp+0x48]
  21a8a6:	89 44 11 f0          	mov    DWORD PTR [rcx+rdx*1-0x10],eax
                elf_section.info = try in.readInt(elf.endian, u32);
  21a8aa:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  21a8af:	0f b6 00             	movzx  eax,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  21a8b2:	88 44 24 70          	mov    BYTE PTR [rsp+0x70],al
  21a8b6:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  21a8bb:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  21a8c2:	00 
  21a8c3:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x4
  21a8ca:	00 04 00 00 00 
            return self.readFn(self, buffer);
  21a8cf:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  21a8d6:	00 
  21a8d7:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  21a8dc:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  21a8e3:	00 
  21a8e4:	ff 54 24 58          	call   QWORD PTR [rsp+0x58]
  21a8e8:	44 0f b7 ac 24 f0 00 	movzx  r13d,WORD PTR [rsp+0xf0]
  21a8ef:	00 00 
            const amt_read = try self.read(buf);
  21a8f1:	66 45 85 ed          	test   r13w,r13w
  21a8f5:	0f 85 66 0c 00 00    	jne    21b561 <openSelfDebugInfo+0x4b21>
  21a8fb:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  21a902:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  21a903:	48 3b 84 24 a0 00 00 	cmp    rax,QWORD PTR [rsp+0xa0]
  21a90a:	00 
  21a90b:	0f 82 4b 0c 00 00    	jb     21b55c <openSelfDebugInfo+0x4b1c>
  21a911:	0f b6 44 24 20       	movzx  eax,BYTE PTR [rsp+0x20]
  21a916:	0f b6 4c 24 21       	movzx  ecx,BYTE PTR [rsp+0x21]
    switch (endian) {
  21a91b:	f6 44 24 70 01       	test   BYTE PTR [rsp+0x70],0x1
  21a920:	74 1b                	je     21a93d <openSelfDebugInfo+0x3efd>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  21a922:	c1 e1 08             	shl    ecx,0x8
  21a925:	09 c1                	or     ecx,eax
  21a927:	0f b6 54 24 22       	movzx  edx,BYTE PTR [rsp+0x22]
  21a92c:	c1 e2 10             	shl    edx,0x10
  21a92f:	09 ca                	or     edx,ecx
  21a931:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  21a936:	c1 e0 18             	shl    eax,0x18
  21a939:	09 d0                	or     eax,edx
  21a93b:	eb 19                	jmp    21a956 <openSelfDebugInfo+0x3f16>
                result = (result << 8) | b;
  21a93d:	c1 e0 08             	shl    eax,0x8
  21a940:	09 c8                	or     eax,ecx
  21a942:	c1 e0 08             	shl    eax,0x8
  21a945:	0f b6 4c 24 22       	movzx  ecx,BYTE PTR [rsp+0x22]
  21a94a:	09 c1                	or     ecx,eax
  21a94c:	c1 e1 08             	shl    ecx,0x8
  21a94f:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  21a954:	09 c8                	or     eax,ecx
  21a956:	48 8b 8c 24 80 00 00 	mov    rcx,QWORD PTR [rsp+0x80]
  21a95d:	00 
  21a95e:	48 8b 54 24 48       	mov    rdx,QWORD PTR [rsp+0x48]
  21a963:	89 44 11 f4          	mov    DWORD PTR [rcx+rdx*1-0xc],eax
                elf_section.addr_align = try in.readInt(elf.endian, u64);
  21a967:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  21a96c:	0f b6 10             	movzx  edx,BYTE PTR [rax]
  21a96f:	48 8d bc 24 10 02 00 	lea    rdi,[rsp+0x210]
  21a976:	00 
  21a977:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  21a97c:	e8 5f 10 00 00       	call   21b9e0 <InStream(ReadError)_readInt.45>
  21a981:	44 0f b7 ac 24 10 02 	movzx  r13d,WORD PTR [rsp+0x210]
  21a988:	00 00 
  21a98a:	66 45 85 ed          	test   r13w,r13w
  21a98e:	0f 85 d1 0a 00 00    	jne    21b465 <openSelfDebugInfo+0x4a25>
  21a994:	48 8b 84 24 18 02 00 	mov    rax,QWORD PTR [rsp+0x218]
  21a99b:	00 
  21a99c:	48 8b 8c 24 80 00 00 	mov    rcx,QWORD PTR [rsp+0x80]
  21a9a3:	00 
  21a9a4:	48 8b 54 24 48       	mov    rdx,QWORD PTR [rsp+0x48]
  21a9a9:	48 89 44 11 f8       	mov    QWORD PTR [rcx+rdx*1-0x8],rax
                elf_section.ent_size = try in.readInt(elf.endian, u64);
  21a9ae:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  21a9b3:	0f b6 10             	movzx  edx,BYTE PTR [rax]
  21a9b6:	48 8d bc 24 40 02 00 	lea    rdi,[rsp+0x240]
  21a9bd:	00 
  21a9be:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  21a9c3:	e8 18 10 00 00       	call   21b9e0 <InStream(ReadError)_readInt.45>
  21a9c8:	44 0f b7 ac 24 40 02 	movzx  r13d,WORD PTR [rsp+0x240]
  21a9cf:	00 00 
  21a9d1:	66 45 85 ed          	test   r13w,r13w
  21a9d5:	0f 85 e8 0a 00 00    	jne    21b4c3 <openSelfDebugInfo+0x4a83>
  21a9db:	48 8b 84 24 48 02 00 	mov    rax,QWORD PTR [rsp+0x248]
  21a9e2:	00 
  21a9e3:	48 8b 8c 24 80 00 00 	mov    rcx,QWORD PTR [rsp+0x80]
  21a9ea:	00 
  21a9eb:	48 8b 54 24 48       	mov    rdx,QWORD PTR [rsp+0x48]
  21a9f0:	48 89 04 11          	mov    QWORD PTR [rcx+rdx*1],rax
  21a9f4:	48 8b 84 24 80 01 00 	mov    rax,QWORD PTR [rsp+0x180]
  21a9fb:	00 
  21a9fc:	48 89 c1             	mov    rcx,rax
            for (elf.section_headers) |*elf_section| {
  21a9ff:	48 83 c1 01          	add    rcx,0x1
  21aa03:	48 89 c8             	mov    rax,rcx
  21aa06:	48 89 84 24 80 01 00 	mov    QWORD PTR [rsp+0x180],rax
  21aa0d:	00 
  21aa0e:	48 3b 4c 24 40       	cmp    rcx,QWORD PTR [rsp+0x40]
  21aa13:	0f 83 93 0b 00 00    	jae    21b5ac <openSelfDebugInfo+0x4b6c>
  21aa19:	48 83 44 24 48 40    	add    QWORD PTR [rsp+0x48],0x40
  21aa1f:	48 8b 84 24 90 00 00 	mov    rax,QWORD PTR [rsp+0x90]
  21aa26:	00 
  21aa27:	48 8b 00             	mov    rax,QWORD PTR [rax]
                elf_section.name = try in.readInt(elf.endian, u32);
  21aa2a:	48 89 84 24 80 00 00 	mov    QWORD PTR [rsp+0x80],rax
  21aa31:	00 
  21aa32:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  21aa37:	0f b6 00             	movzx  eax,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  21aa3a:	88 44 24 70          	mov    BYTE PTR [rsp+0x70],al
  21aa3e:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  21aa43:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  21aa4a:	00 
  21aa4b:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x4
  21aa52:	00 04 00 00 00 
            return self.readFn(self, buffer);
  21aa57:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  21aa5e:	00 
  21aa5f:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  21aa64:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  21aa6b:	00 
  21aa6c:	ff 54 24 58          	call   QWORD PTR [rsp+0x58]
  21aa70:	44 0f b7 ac 24 f0 00 	movzx  r13d,WORD PTR [rsp+0xf0]
  21aa77:	00 00 
  21aa79:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  21aa80:	00 
            const amt_read = try self.read(buf);
  21aa81:	66 45 85 ed          	test   r13w,r13w
  21aa85:	0f 84 25 fb ff ff    	je     21a5b0 <openSelfDebugInfo+0x3b70>
  21aa8b:	e9 d1 0a 00 00       	jmp    21b561 <openSelfDebugInfo+0x4b21>
  21aa90:	66 41 bd 03 00       	mov    r13w,0x3
  21aa95:	48 83 f9 4b          	cmp    rcx,0x4b
  21aa99:	0f 85 ed c1 ff ff    	jne    216c8c <openSelfDebugInfo+0x24c>
  21aa9f:	e9 e3 c4 ff ff       	jmp    216f87 <openSelfDebugInfo+0x547>
            @panic("assertion failure");
  21aaa4:	c5 f8 77             	vzeroupper 
  21aaa7:	e8 34 9b ff ff       	call   2145e0 <panic>
  21aaac:	66 41 bd 04 00       	mov    r13w,0x4
            try st.elf.openFile(allocator, &st.self_exe_file);
  21aab1:	66 45 85 ed          	test   r13w,r13w
  21aab5:	0f 85 db c1 ff ff    	jne    216c96 <openSelfDebugInfo+0x256>
  21aabb:	e9 c2 c8 ff ff       	jmp    217382 <openSelfDebugInfo+0x942>
            if (sh_entry_size != 40) return error.InvalidFormat;
  21aac0:	83 7c 24 48 28       	cmp    DWORD PTR [rsp+0x48],0x28
  21aac5:	0f 85 56 0a 00 00    	jne    21b521 <openSelfDebugInfo+0x4ae1>
                elf_section.name = try in.readInt(elf.endian, u32);
  21aacb:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  21aad0:	8a 00                	mov    al,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  21aad2:	88 44 24 70          	mov    BYTE PTR [rsp+0x70],al
  21aad6:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  21aadb:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  21aae2:	00 
  21aae3:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x4
  21aaea:	00 04 00 00 00 
  21aaef:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  21aaf6:	00 
  21aaf7:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  21aafe:	00 
            return self.readFn(self, buffer);
  21aaff:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  21ab04:	ff 54 24 58          	call   QWORD PTR [rsp+0x58]
  21ab08:	44 0f b7 ac 24 f0 00 	movzx  r13d,WORD PTR [rsp+0xf0]
  21ab0f:	00 00 
            const amt_read = try self.read(buf);
  21ab11:	66 45 85 ed          	test   r13w,r13w
  21ab15:	0f 85 46 0a 00 00    	jne    21b561 <openSelfDebugInfo+0x4b21>
  21ab1b:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  21ab22:	00 
  21ab23:	31 c9                	xor    ecx,ecx
  21ab25:	48 89 8c 24 80 01 00 	mov    QWORD PTR [rsp+0x180],rcx
  21ab2c:	00 
  21ab2d:	b9 38 00 00 00       	mov    ecx,0x38
  21ab32:	48 89 4c 24 48       	mov    QWORD PTR [rsp+0x48],rcx
            if (amt_read < buf.len) return error.EndOfStream;
  21ab37:	48 3b 84 24 a0 00 00 	cmp    rax,QWORD PTR [rsp+0xa0]
  21ab3e:	00 
  21ab3f:	0f 82 17 0a 00 00    	jb     21b55c <openSelfDebugInfo+0x4b1c>
  21ab45:	0f b6 44 24 20       	movzx  eax,BYTE PTR [rsp+0x20]
  21ab4a:	0f b6 4c 24 21       	movzx  ecx,BYTE PTR [rsp+0x21]
    switch (endian) {
  21ab4f:	f6 44 24 70 01       	test   BYTE PTR [rsp+0x70],0x1
  21ab54:	74 1b                	je     21ab71 <openSelfDebugInfo+0x4131>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  21ab56:	c1 e1 08             	shl    ecx,0x8
  21ab59:	09 c1                	or     ecx,eax
  21ab5b:	0f b6 54 24 22       	movzx  edx,BYTE PTR [rsp+0x22]
  21ab60:	c1 e2 10             	shl    edx,0x10
  21ab63:	09 ca                	or     edx,ecx
  21ab65:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  21ab6a:	c1 e0 18             	shl    eax,0x18
  21ab6d:	09 d0                	or     eax,edx
  21ab6f:	eb 19                	jmp    21ab8a <openSelfDebugInfo+0x414a>
                result = (result << 8) | b;
  21ab71:	c1 e0 08             	shl    eax,0x8
  21ab74:	09 c8                	or     eax,ecx
  21ab76:	c1 e0 08             	shl    eax,0x8
  21ab79:	0f b6 4c 24 22       	movzx  ecx,BYTE PTR [rsp+0x22]
  21ab7e:	09 c1                	or     ecx,eax
  21ab80:	c1 e1 08             	shl    ecx,0x8
  21ab83:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  21ab88:	09 c8                	or     eax,ecx
  21ab8a:	48 8b 8c 24 80 00 00 	mov    rcx,QWORD PTR [rsp+0x80]
  21ab91:	00 
  21ab92:	48 8b 54 24 48       	mov    rdx,QWORD PTR [rsp+0x48]
  21ab97:	89 44 11 c8          	mov    DWORD PTR [rcx+rdx*1-0x38],eax
                elf_section.sh_type = try in.readInt(elf.endian, u32);
  21ab9b:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  21aba0:	0f b6 00             	movzx  eax,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  21aba3:	88 44 24 70          	mov    BYTE PTR [rsp+0x70],al
  21aba7:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  21abac:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  21abb3:	00 
  21abb4:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x4
  21abbb:	00 04 00 00 00 
            return self.readFn(self, buffer);
  21abc0:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  21abc7:	00 
  21abc8:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  21abcd:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  21abd4:	00 
  21abd5:	ff 54 24 58          	call   QWORD PTR [rsp+0x58]
  21abd9:	44 0f b7 ac 24 f0 00 	movzx  r13d,WORD PTR [rsp+0xf0]
  21abe0:	00 00 
            const amt_read = try self.read(buf);
  21abe2:	66 45 85 ed          	test   r13w,r13w
  21abe6:	0f 85 75 09 00 00    	jne    21b561 <openSelfDebugInfo+0x4b21>
  21abec:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  21abf3:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  21abf4:	48 3b 84 24 a0 00 00 	cmp    rax,QWORD PTR [rsp+0xa0]
  21abfb:	00 
  21abfc:	0f 82 5a 09 00 00    	jb     21b55c <openSelfDebugInfo+0x4b1c>
  21ac02:	0f b6 44 24 20       	movzx  eax,BYTE PTR [rsp+0x20]
  21ac07:	0f b6 4c 24 21       	movzx  ecx,BYTE PTR [rsp+0x21]
    switch (endian) {
  21ac0c:	f6 44 24 70 01       	test   BYTE PTR [rsp+0x70],0x1
  21ac11:	74 1b                	je     21ac2e <openSelfDebugInfo+0x41ee>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  21ac13:	c1 e1 08             	shl    ecx,0x8
  21ac16:	09 c1                	or     ecx,eax
  21ac18:	0f b6 54 24 22       	movzx  edx,BYTE PTR [rsp+0x22]
  21ac1d:	c1 e2 10             	shl    edx,0x10
  21ac20:	09 ca                	or     edx,ecx
  21ac22:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  21ac27:	c1 e0 18             	shl    eax,0x18
  21ac2a:	09 d0                	or     eax,edx
  21ac2c:	eb 19                	jmp    21ac47 <openSelfDebugInfo+0x4207>
                result = (result << 8) | b;
  21ac2e:	c1 e0 08             	shl    eax,0x8
  21ac31:	09 c8                	or     eax,ecx
  21ac33:	c1 e0 08             	shl    eax,0x8
  21ac36:	0f b6 4c 24 22       	movzx  ecx,BYTE PTR [rsp+0x22]
  21ac3b:	09 c1                	or     ecx,eax
  21ac3d:	c1 e1 08             	shl    ecx,0x8
  21ac40:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  21ac45:	09 c8                	or     eax,ecx
  21ac47:	48 8b 8c 24 80 00 00 	mov    rcx,QWORD PTR [rsp+0x80]
  21ac4e:	00 
  21ac4f:	48 8b 54 24 48       	mov    rdx,QWORD PTR [rsp+0x48]
  21ac54:	89 44 11 cc          	mov    DWORD PTR [rcx+rdx*1-0x34],eax
                elf_section.flags = u64(try in.readInt(elf.endian, u32));
  21ac58:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  21ac5d:	0f b6 00             	movzx  eax,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  21ac60:	88 44 24 70          	mov    BYTE PTR [rsp+0x70],al
  21ac64:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  21ac69:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  21ac70:	00 
  21ac71:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x4
  21ac78:	00 04 00 00 00 
            return self.readFn(self, buffer);
  21ac7d:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  21ac84:	00 
  21ac85:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  21ac8a:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  21ac91:	00 
  21ac92:	ff 54 24 58          	call   QWORD PTR [rsp+0x58]
  21ac96:	44 0f b7 ac 24 f0 00 	movzx  r13d,WORD PTR [rsp+0xf0]
  21ac9d:	00 00 
            const amt_read = try self.read(buf);
  21ac9f:	66 45 85 ed          	test   r13w,r13w
  21aca3:	0f 85 b8 08 00 00    	jne    21b561 <openSelfDebugInfo+0x4b21>
  21aca9:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  21acb0:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  21acb1:	48 3b 84 24 a0 00 00 	cmp    rax,QWORD PTR [rsp+0xa0]
  21acb8:	00 
  21acb9:	0f 82 9d 08 00 00    	jb     21b55c <openSelfDebugInfo+0x4b1c>
  21acbf:	0f b6 44 24 20       	movzx  eax,BYTE PTR [rsp+0x20]
  21acc4:	0f b6 4c 24 21       	movzx  ecx,BYTE PTR [rsp+0x21]
    switch (endian) {
  21acc9:	f6 44 24 70 01       	test   BYTE PTR [rsp+0x70],0x1
  21acce:	74 1b                	je     21aceb <openSelfDebugInfo+0x42ab>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  21acd0:	c1 e1 08             	shl    ecx,0x8
  21acd3:	09 c1                	or     ecx,eax
  21acd5:	0f b6 54 24 22       	movzx  edx,BYTE PTR [rsp+0x22]
  21acda:	c1 e2 10             	shl    edx,0x10
  21acdd:	09 ca                	or     edx,ecx
  21acdf:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  21ace4:	c1 e0 18             	shl    eax,0x18
  21ace7:	09 d0                	or     eax,edx
  21ace9:	eb 19                	jmp    21ad04 <openSelfDebugInfo+0x42c4>
                result = (result << 8) | b;
  21aceb:	c1 e0 08             	shl    eax,0x8
  21acee:	09 c8                	or     eax,ecx
  21acf0:	c1 e0 08             	shl    eax,0x8
  21acf3:	0f b6 4c 24 22       	movzx  ecx,BYTE PTR [rsp+0x22]
  21acf8:	09 c1                	or     ecx,eax
  21acfa:	c1 e1 08             	shl    ecx,0x8
  21acfd:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  21ad02:	09 c8                	or     eax,ecx
  21ad04:	89 c0                	mov    eax,eax
  21ad06:	48 8b 8c 24 80 00 00 	mov    rcx,QWORD PTR [rsp+0x80]
  21ad0d:	00 
  21ad0e:	48 8b 54 24 48       	mov    rdx,QWORD PTR [rsp+0x48]
  21ad13:	48 89 44 11 d0       	mov    QWORD PTR [rcx+rdx*1-0x30],rax
                elf_section.addr = u64(try in.readInt(elf.endian, u32));
  21ad18:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  21ad1d:	0f b6 00             	movzx  eax,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  21ad20:	88 44 24 70          	mov    BYTE PTR [rsp+0x70],al
  21ad24:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  21ad29:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  21ad30:	00 
  21ad31:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x4
  21ad38:	00 04 00 00 00 
            return self.readFn(self, buffer);
  21ad3d:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  21ad44:	00 
  21ad45:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  21ad4a:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  21ad51:	00 
  21ad52:	ff 54 24 58          	call   QWORD PTR [rsp+0x58]
  21ad56:	44 0f b7 ac 24 f0 00 	movzx  r13d,WORD PTR [rsp+0xf0]
  21ad5d:	00 00 
            const amt_read = try self.read(buf);
  21ad5f:	66 45 85 ed          	test   r13w,r13w
  21ad63:	0f 85 f8 07 00 00    	jne    21b561 <openSelfDebugInfo+0x4b21>
  21ad69:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  21ad70:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  21ad71:	48 3b 84 24 a0 00 00 	cmp    rax,QWORD PTR [rsp+0xa0]
  21ad78:	00 
  21ad79:	0f 82 dd 07 00 00    	jb     21b55c <openSelfDebugInfo+0x4b1c>
  21ad7f:	0f b6 44 24 20       	movzx  eax,BYTE PTR [rsp+0x20]
  21ad84:	0f b6 4c 24 21       	movzx  ecx,BYTE PTR [rsp+0x21]
    switch (endian) {
  21ad89:	f6 44 24 70 01       	test   BYTE PTR [rsp+0x70],0x1
  21ad8e:	74 1b                	je     21adab <openSelfDebugInfo+0x436b>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  21ad90:	c1 e1 08             	shl    ecx,0x8
  21ad93:	09 c1                	or     ecx,eax
  21ad95:	0f b6 54 24 22       	movzx  edx,BYTE PTR [rsp+0x22]
  21ad9a:	c1 e2 10             	shl    edx,0x10
  21ad9d:	09 ca                	or     edx,ecx
  21ad9f:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  21ada4:	c1 e0 18             	shl    eax,0x18
  21ada7:	09 d0                	or     eax,edx
  21ada9:	eb 19                	jmp    21adc4 <openSelfDebugInfo+0x4384>
                result = (result << 8) | b;
  21adab:	c1 e0 08             	shl    eax,0x8
  21adae:	09 c8                	or     eax,ecx
  21adb0:	c1 e0 08             	shl    eax,0x8
  21adb3:	0f b6 4c 24 22       	movzx  ecx,BYTE PTR [rsp+0x22]
  21adb8:	09 c1                	or     ecx,eax
  21adba:	c1 e1 08             	shl    ecx,0x8
  21adbd:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  21adc2:	09 c8                	or     eax,ecx
  21adc4:	89 c0                	mov    eax,eax
  21adc6:	48 8b 8c 24 80 00 00 	mov    rcx,QWORD PTR [rsp+0x80]
  21adcd:	00 
  21adce:	48 8b 54 24 48       	mov    rdx,QWORD PTR [rsp+0x48]
  21add3:	48 89 44 11 d8       	mov    QWORD PTR [rcx+rdx*1-0x28],rax
                elf_section.offset = u64(try in.readInt(elf.endian, u32));
  21add8:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  21addd:	0f b6 00             	movzx  eax,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  21ade0:	88 44 24 70          	mov    BYTE PTR [rsp+0x70],al
  21ade4:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  21ade9:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  21adf0:	00 
  21adf1:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x4
  21adf8:	00 04 00 00 00 
            return self.readFn(self, buffer);
  21adfd:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  21ae04:	00 
  21ae05:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  21ae0a:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  21ae11:	00 
  21ae12:	ff 54 24 58          	call   QWORD PTR [rsp+0x58]
  21ae16:	44 0f b7 ac 24 f0 00 	movzx  r13d,WORD PTR [rsp+0xf0]
  21ae1d:	00 00 
            const amt_read = try self.read(buf);
  21ae1f:	66 45 85 ed          	test   r13w,r13w
  21ae23:	0f 85 38 07 00 00    	jne    21b561 <openSelfDebugInfo+0x4b21>
  21ae29:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  21ae30:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  21ae31:	48 3b 84 24 a0 00 00 	cmp    rax,QWORD PTR [rsp+0xa0]
  21ae38:	00 
  21ae39:	0f 82 1d 07 00 00    	jb     21b55c <openSelfDebugInfo+0x4b1c>
  21ae3f:	0f b6 44 24 20       	movzx  eax,BYTE PTR [rsp+0x20]
  21ae44:	0f b6 4c 24 21       	movzx  ecx,BYTE PTR [rsp+0x21]
    switch (endian) {
  21ae49:	f6 44 24 70 01       	test   BYTE PTR [rsp+0x70],0x1
  21ae4e:	74 1b                	je     21ae6b <openSelfDebugInfo+0x442b>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  21ae50:	c1 e1 08             	shl    ecx,0x8
  21ae53:	09 c1                	or     ecx,eax
  21ae55:	0f b6 54 24 22       	movzx  edx,BYTE PTR [rsp+0x22]
  21ae5a:	c1 e2 10             	shl    edx,0x10
  21ae5d:	09 ca                	or     edx,ecx
  21ae5f:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  21ae64:	c1 e0 18             	shl    eax,0x18
  21ae67:	09 d0                	or     eax,edx
  21ae69:	eb 19                	jmp    21ae84 <openSelfDebugInfo+0x4444>
                result = (result << 8) | b;
  21ae6b:	c1 e0 08             	shl    eax,0x8
  21ae6e:	09 c8                	or     eax,ecx
  21ae70:	c1 e0 08             	shl    eax,0x8
  21ae73:	0f b6 4c 24 22       	movzx  ecx,BYTE PTR [rsp+0x22]
  21ae78:	09 c1                	or     ecx,eax
  21ae7a:	c1 e1 08             	shl    ecx,0x8
  21ae7d:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  21ae82:	09 c8                	or     eax,ecx
  21ae84:	89 c0                	mov    eax,eax
  21ae86:	48 8b 8c 24 80 00 00 	mov    rcx,QWORD PTR [rsp+0x80]
  21ae8d:	00 
  21ae8e:	48 8b 54 24 48       	mov    rdx,QWORD PTR [rsp+0x48]
  21ae93:	48 89 44 11 e0       	mov    QWORD PTR [rcx+rdx*1-0x20],rax
                elf_section.size = u64(try in.readInt(elf.endian, u32));
  21ae98:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  21ae9d:	0f b6 00             	movzx  eax,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  21aea0:	88 44 24 70          	mov    BYTE PTR [rsp+0x70],al
  21aea4:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  21aea9:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  21aeb0:	00 
  21aeb1:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x4
  21aeb8:	00 04 00 00 00 
            return self.readFn(self, buffer);
  21aebd:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  21aec4:	00 
  21aec5:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  21aeca:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  21aed1:	00 
  21aed2:	ff 54 24 58          	call   QWORD PTR [rsp+0x58]
  21aed6:	44 0f b7 ac 24 f0 00 	movzx  r13d,WORD PTR [rsp+0xf0]
  21aedd:	00 00 
            const amt_read = try self.read(buf);
  21aedf:	66 45 85 ed          	test   r13w,r13w
  21aee3:	0f 85 78 06 00 00    	jne    21b561 <openSelfDebugInfo+0x4b21>
  21aee9:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  21aef0:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  21aef1:	48 3b 84 24 a0 00 00 	cmp    rax,QWORD PTR [rsp+0xa0]
  21aef8:	00 
  21aef9:	0f 82 5d 06 00 00    	jb     21b55c <openSelfDebugInfo+0x4b1c>
  21aeff:	0f b6 44 24 20       	movzx  eax,BYTE PTR [rsp+0x20]
  21af04:	0f b6 4c 24 21       	movzx  ecx,BYTE PTR [rsp+0x21]
    switch (endian) {
  21af09:	f6 44 24 70 01       	test   BYTE PTR [rsp+0x70],0x1
  21af0e:	74 1b                	je     21af2b <openSelfDebugInfo+0x44eb>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  21af10:	c1 e1 08             	shl    ecx,0x8
  21af13:	09 c1                	or     ecx,eax
  21af15:	0f b6 54 24 22       	movzx  edx,BYTE PTR [rsp+0x22]
  21af1a:	c1 e2 10             	shl    edx,0x10
  21af1d:	09 ca                	or     edx,ecx
  21af1f:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  21af24:	c1 e0 18             	shl    eax,0x18
  21af27:	09 d0                	or     eax,edx
  21af29:	eb 19                	jmp    21af44 <openSelfDebugInfo+0x4504>
                result = (result << 8) | b;
  21af2b:	c1 e0 08             	shl    eax,0x8
  21af2e:	09 c8                	or     eax,ecx
  21af30:	c1 e0 08             	shl    eax,0x8
  21af33:	0f b6 4c 24 22       	movzx  ecx,BYTE PTR [rsp+0x22]
  21af38:	09 c1                	or     ecx,eax
  21af3a:	c1 e1 08             	shl    ecx,0x8
  21af3d:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  21af42:	09 c8                	or     eax,ecx
  21af44:	89 c0                	mov    eax,eax
  21af46:	48 8b 8c 24 80 00 00 	mov    rcx,QWORD PTR [rsp+0x80]
  21af4d:	00 
  21af4e:	48 8b 54 24 48       	mov    rdx,QWORD PTR [rsp+0x48]
  21af53:	48 89 44 11 e8       	mov    QWORD PTR [rcx+rdx*1-0x18],rax
                elf_section.link = try in.readInt(elf.endian, u32);
  21af58:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  21af5d:	0f b6 00             	movzx  eax,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  21af60:	88 44 24 70          	mov    BYTE PTR [rsp+0x70],al
  21af64:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  21af69:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  21af70:	00 
  21af71:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x4
  21af78:	00 04 00 00 00 
            return self.readFn(self, buffer);
  21af7d:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  21af84:	00 
  21af85:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  21af8a:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  21af91:	00 
  21af92:	ff 54 24 58          	call   QWORD PTR [rsp+0x58]
  21af96:	44 0f b7 ac 24 f0 00 	movzx  r13d,WORD PTR [rsp+0xf0]
  21af9d:	00 00 
            const amt_read = try self.read(buf);
  21af9f:	66 45 85 ed          	test   r13w,r13w
  21afa3:	0f 85 b8 05 00 00    	jne    21b561 <openSelfDebugInfo+0x4b21>
  21afa9:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  21afb0:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  21afb1:	48 3b 84 24 a0 00 00 	cmp    rax,QWORD PTR [rsp+0xa0]
  21afb8:	00 
  21afb9:	0f 82 9d 05 00 00    	jb     21b55c <openSelfDebugInfo+0x4b1c>
  21afbf:	0f b6 44 24 20       	movzx  eax,BYTE PTR [rsp+0x20]
  21afc4:	0f b6 4c 24 21       	movzx  ecx,BYTE PTR [rsp+0x21]
    switch (endian) {
  21afc9:	f6 44 24 70 01       	test   BYTE PTR [rsp+0x70],0x1
  21afce:	74 1b                	je     21afeb <openSelfDebugInfo+0x45ab>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  21afd0:	c1 e1 08             	shl    ecx,0x8
  21afd3:	09 c1                	or     ecx,eax
  21afd5:	0f b6 54 24 22       	movzx  edx,BYTE PTR [rsp+0x22]
  21afda:	c1 e2 10             	shl    edx,0x10
  21afdd:	09 ca                	or     edx,ecx
  21afdf:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  21afe4:	c1 e0 18             	shl    eax,0x18
  21afe7:	09 d0                	or     eax,edx
  21afe9:	eb 19                	jmp    21b004 <openSelfDebugInfo+0x45c4>
                result = (result << 8) | b;
  21afeb:	c1 e0 08             	shl    eax,0x8
  21afee:	09 c8                	or     eax,ecx
  21aff0:	c1 e0 08             	shl    eax,0x8
  21aff3:	0f b6 4c 24 22       	movzx  ecx,BYTE PTR [rsp+0x22]
  21aff8:	09 c1                	or     ecx,eax
  21affa:	c1 e1 08             	shl    ecx,0x8
  21affd:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  21b002:	09 c8                	or     eax,ecx
  21b004:	48 8b 8c 24 80 00 00 	mov    rcx,QWORD PTR [rsp+0x80]
  21b00b:	00 
  21b00c:	48 8b 54 24 48       	mov    rdx,QWORD PTR [rsp+0x48]
  21b011:	89 44 11 f0          	mov    DWORD PTR [rcx+rdx*1-0x10],eax
                elf_section.info = try in.readInt(elf.endian, u32);
  21b015:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  21b01a:	0f b6 00             	movzx  eax,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  21b01d:	88 44 24 70          	mov    BYTE PTR [rsp+0x70],al
  21b021:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  21b026:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  21b02d:	00 
  21b02e:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x4
  21b035:	00 04 00 00 00 
            return self.readFn(self, buffer);
  21b03a:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  21b041:	00 
  21b042:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  21b047:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  21b04e:	00 
  21b04f:	ff 54 24 58          	call   QWORD PTR [rsp+0x58]
  21b053:	44 0f b7 ac 24 f0 00 	movzx  r13d,WORD PTR [rsp+0xf0]
  21b05a:	00 00 
            const amt_read = try self.read(buf);
  21b05c:	66 45 85 ed          	test   r13w,r13w
  21b060:	0f 85 fb 04 00 00    	jne    21b561 <openSelfDebugInfo+0x4b21>
  21b066:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  21b06d:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  21b06e:	48 3b 84 24 a0 00 00 	cmp    rax,QWORD PTR [rsp+0xa0]
  21b075:	00 
  21b076:	0f 82 e0 04 00 00    	jb     21b55c <openSelfDebugInfo+0x4b1c>
  21b07c:	0f b6 44 24 20       	movzx  eax,BYTE PTR [rsp+0x20]
  21b081:	0f b6 4c 24 21       	movzx  ecx,BYTE PTR [rsp+0x21]
    switch (endian) {
  21b086:	f6 44 24 70 01       	test   BYTE PTR [rsp+0x70],0x1
  21b08b:	74 1b                	je     21b0a8 <openSelfDebugInfo+0x4668>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  21b08d:	c1 e1 08             	shl    ecx,0x8
  21b090:	09 c1                	or     ecx,eax
  21b092:	0f b6 54 24 22       	movzx  edx,BYTE PTR [rsp+0x22]
  21b097:	c1 e2 10             	shl    edx,0x10
  21b09a:	09 ca                	or     edx,ecx
  21b09c:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  21b0a1:	c1 e0 18             	shl    eax,0x18
  21b0a4:	09 d0                	or     eax,edx
  21b0a6:	eb 19                	jmp    21b0c1 <openSelfDebugInfo+0x4681>
                result = (result << 8) | b;
  21b0a8:	c1 e0 08             	shl    eax,0x8
  21b0ab:	09 c8                	or     eax,ecx
  21b0ad:	c1 e0 08             	shl    eax,0x8
  21b0b0:	0f b6 4c 24 22       	movzx  ecx,BYTE PTR [rsp+0x22]
  21b0b5:	09 c1                	or     ecx,eax
  21b0b7:	c1 e1 08             	shl    ecx,0x8
  21b0ba:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  21b0bf:	09 c8                	or     eax,ecx
  21b0c1:	48 8b 8c 24 80 00 00 	mov    rcx,QWORD PTR [rsp+0x80]
  21b0c8:	00 
  21b0c9:	48 8b 54 24 48       	mov    rdx,QWORD PTR [rsp+0x48]
  21b0ce:	89 44 11 f4          	mov    DWORD PTR [rcx+rdx*1-0xc],eax
                elf_section.addr_align = u64(try in.readInt(elf.endian, u32));
  21b0d2:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  21b0d7:	0f b6 00             	movzx  eax,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  21b0da:	88 44 24 70          	mov    BYTE PTR [rsp+0x70],al
  21b0de:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  21b0e3:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  21b0ea:	00 
  21b0eb:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x4
  21b0f2:	00 04 00 00 00 
            return self.readFn(self, buffer);
  21b0f7:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  21b0fe:	00 
  21b0ff:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  21b104:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  21b10b:	00 
  21b10c:	ff 54 24 58          	call   QWORD PTR [rsp+0x58]
  21b110:	44 0f b7 ac 24 f0 00 	movzx  r13d,WORD PTR [rsp+0xf0]
  21b117:	00 00 
            const amt_read = try self.read(buf);
  21b119:	66 45 85 ed          	test   r13w,r13w
  21b11d:	0f 85 3e 04 00 00    	jne    21b561 <openSelfDebugInfo+0x4b21>
  21b123:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  21b12a:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  21b12b:	48 3b 84 24 a0 00 00 	cmp    rax,QWORD PTR [rsp+0xa0]
  21b132:	00 
  21b133:	0f 82 23 04 00 00    	jb     21b55c <openSelfDebugInfo+0x4b1c>
  21b139:	0f b6 44 24 20       	movzx  eax,BYTE PTR [rsp+0x20]
  21b13e:	0f b6 4c 24 21       	movzx  ecx,BYTE PTR [rsp+0x21]
    switch (endian) {
  21b143:	f6 44 24 70 01       	test   BYTE PTR [rsp+0x70],0x1
  21b148:	74 1b                	je     21b165 <openSelfDebugInfo+0x4725>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  21b14a:	c1 e1 08             	shl    ecx,0x8
  21b14d:	09 c1                	or     ecx,eax
  21b14f:	0f b6 54 24 22       	movzx  edx,BYTE PTR [rsp+0x22]
  21b154:	c1 e2 10             	shl    edx,0x10
  21b157:	09 ca                	or     edx,ecx
  21b159:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  21b15e:	c1 e0 18             	shl    eax,0x18
  21b161:	09 d0                	or     eax,edx
  21b163:	eb 19                	jmp    21b17e <openSelfDebugInfo+0x473e>
                result = (result << 8) | b;
  21b165:	c1 e0 08             	shl    eax,0x8
  21b168:	09 c8                	or     eax,ecx
  21b16a:	c1 e0 08             	shl    eax,0x8
  21b16d:	0f b6 4c 24 22       	movzx  ecx,BYTE PTR [rsp+0x22]
  21b172:	09 c1                	or     ecx,eax
  21b174:	c1 e1 08             	shl    ecx,0x8
  21b177:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  21b17c:	09 c8                	or     eax,ecx
  21b17e:	89 c0                	mov    eax,eax
  21b180:	48 8b 8c 24 80 00 00 	mov    rcx,QWORD PTR [rsp+0x80]
  21b187:	00 
  21b188:	48 8b 54 24 48       	mov    rdx,QWORD PTR [rsp+0x48]
  21b18d:	48 89 44 11 f8       	mov    QWORD PTR [rcx+rdx*1-0x8],rax
                elf_section.ent_size = u64(try in.readInt(elf.endian, u32));
  21b192:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  21b197:	0f b6 00             	movzx  eax,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  21b19a:	88 44 24 70          	mov    BYTE PTR [rsp+0x70],al
  21b19e:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  21b1a3:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  21b1aa:	00 
  21b1ab:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x4
  21b1b2:	00 04 00 00 00 
            return self.readFn(self, buffer);
  21b1b7:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  21b1be:	00 
  21b1bf:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  21b1c4:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  21b1cb:	00 
  21b1cc:	ff 54 24 58          	call   QWORD PTR [rsp+0x58]
  21b1d0:	44 0f b7 ac 24 f0 00 	movzx  r13d,WORD PTR [rsp+0xf0]
  21b1d7:	00 00 
            const amt_read = try self.read(buf);
  21b1d9:	66 45 85 ed          	test   r13w,r13w
  21b1dd:	0f 85 7e 03 00 00    	jne    21b561 <openSelfDebugInfo+0x4b21>
  21b1e3:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  21b1ea:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  21b1eb:	48 3b 84 24 a0 00 00 	cmp    rax,QWORD PTR [rsp+0xa0]
  21b1f2:	00 
  21b1f3:	0f 82 63 03 00 00    	jb     21b55c <openSelfDebugInfo+0x4b1c>
  21b1f9:	0f b6 44 24 20       	movzx  eax,BYTE PTR [rsp+0x20]
  21b1fe:	0f b6 4c 24 21       	movzx  ecx,BYTE PTR [rsp+0x21]
    switch (endian) {
  21b203:	f6 44 24 70 01       	test   BYTE PTR [rsp+0x70],0x1
  21b208:	74 1b                	je     21b225 <openSelfDebugInfo+0x47e5>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  21b20a:	c1 e1 08             	shl    ecx,0x8
  21b20d:	09 c1                	or     ecx,eax
  21b20f:	0f b6 54 24 22       	movzx  edx,BYTE PTR [rsp+0x22]
  21b214:	c1 e2 10             	shl    edx,0x10
  21b217:	09 ca                	or     edx,ecx
  21b219:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  21b21e:	c1 e0 18             	shl    eax,0x18
  21b221:	09 d0                	or     eax,edx
  21b223:	eb 19                	jmp    21b23e <openSelfDebugInfo+0x47fe>
                result = (result << 8) | b;
  21b225:	c1 e0 08             	shl    eax,0x8
  21b228:	09 c8                	or     eax,ecx
  21b22a:	c1 e0 08             	shl    eax,0x8
  21b22d:	0f b6 4c 24 22       	movzx  ecx,BYTE PTR [rsp+0x22]
  21b232:	09 c1                	or     ecx,eax
  21b234:	c1 e1 08             	shl    ecx,0x8
  21b237:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  21b23c:	09 c8                	or     eax,ecx
  21b23e:	89 c0                	mov    eax,eax
  21b240:	48 8b 8c 24 80 00 00 	mov    rcx,QWORD PTR [rsp+0x80]
  21b247:	00 
  21b248:	48 8b 54 24 48       	mov    rdx,QWORD PTR [rsp+0x48]
  21b24d:	48 89 04 11          	mov    QWORD PTR [rcx+rdx*1],rax
  21b251:	48 8b 84 24 80 01 00 	mov    rax,QWORD PTR [rsp+0x180]
  21b258:	00 
  21b259:	48 89 c1             	mov    rcx,rax
            for (elf.section_headers) |*elf_section| {
  21b25c:	48 83 c1 01          	add    rcx,0x1
  21b260:	48 89 c8             	mov    rax,rcx
  21b263:	48 89 84 24 80 01 00 	mov    QWORD PTR [rsp+0x180],rax
  21b26a:	00 
  21b26b:	48 3b 4c 24 40       	cmp    rcx,QWORD PTR [rsp+0x40]
  21b270:	0f 83 36 03 00 00    	jae    21b5ac <openSelfDebugInfo+0x4b6c>
  21b276:	48 83 44 24 48 40    	add    QWORD PTR [rsp+0x48],0x40
  21b27c:	48 8b 84 24 90 00 00 	mov    rax,QWORD PTR [rsp+0x90]
  21b283:	00 
  21b284:	48 8b 00             	mov    rax,QWORD PTR [rax]
                elf_section.name = try in.readInt(elf.endian, u32);
  21b287:	48 89 84 24 80 00 00 	mov    QWORD PTR [rsp+0x80],rax
  21b28e:	00 
  21b28f:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  21b294:	0f b6 00             	movzx  eax,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  21b297:	88 44 24 70          	mov    BYTE PTR [rsp+0x70],al
  21b29b:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  21b2a0:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  21b2a7:	00 
  21b2a8:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x4
  21b2af:	00 04 00 00 00 
            return self.readFn(self, buffer);
  21b2b4:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  21b2bb:	00 
  21b2bc:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  21b2c1:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  21b2c8:	00 
  21b2c9:	ff 54 24 58          	call   QWORD PTR [rsp+0x58]
  21b2cd:	44 0f b7 ac 24 f0 00 	movzx  r13d,WORD PTR [rsp+0xf0]
  21b2d4:	00 00 
  21b2d6:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  21b2dd:	00 
            const amt_read = try self.read(buf);
  21b2de:	66 45 85 ed          	test   r13w,r13w
  21b2e2:	0f 84 4f f8 ff ff    	je     21ab37 <openSelfDebugInfo+0x40f7>
  21b2e8:	e9 74 02 00 00       	jmp    21b561 <openSelfDebugInfo+0x4b21>
        const bytes = @sliceToBytes(memory);
  21b2ed:	48 8b 84 24 88 00 00 	mov    rax,QWORD PTR [rsp+0x88]
  21b2f4:	00 
  21b2f5:	48 8b 00             	mov    rax,QWORD PTR [rax]
  21b2f8:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  21b2fc:	0f 84 8a b9 ff ff    	je     216c8c <openSelfDebugInfo+0x24c>
  21b302:	48 8b 4c 24 78       	mov    rcx,QWORD PTR [rsp+0x78]
  21b307:	48 8b 39             	mov    rdi,QWORD PTR [rcx]
        const bytes = @sliceToBytes(memory);
  21b30a:	48 8b 8c 24 90 00 00 	mov    rcx,QWORD PTR [rsp+0x90]
  21b311:	00 
  21b312:	48 8b 09             	mov    rcx,QWORD PTR [rcx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  21b315:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  21b319:	48 89 8c 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rcx
  21b320:	00 
  21b321:	48 89 84 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],rax
  21b328:	00 
  21b329:	48 8d b4 24 f0 00 00 	lea    rsi,[rsp+0xf0]
  21b330:	00 
  21b331:	ff d2                	call   rdx
                elf_section.flags = try in.readInt(elf.endian, u64);
  21b333:	44 0f b7 ac 24 78 03 	movzx  r13d,WORD PTR [rsp+0x378]
  21b33a:	00 00 
  21b33c:	66 45 85 ed          	test   r13w,r13w
  21b340:	0f 85 50 b9 ff ff    	jne    216c96 <openSelfDebugInfo+0x256>
  21b346:	e9 37 c0 ff ff       	jmp    217382 <openSelfDebugInfo+0x942>
        const bytes = @sliceToBytes(memory);
  21b34b:	48 8b 84 24 88 00 00 	mov    rax,QWORD PTR [rsp+0x88]
  21b352:	00 
  21b353:	48 8b 00             	mov    rax,QWORD PTR [rax]
  21b356:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  21b35a:	0f 84 2c b9 ff ff    	je     216c8c <openSelfDebugInfo+0x24c>
  21b360:	48 8b 4c 24 78       	mov    rcx,QWORD PTR [rsp+0x78]
  21b365:	48 8b 39             	mov    rdi,QWORD PTR [rcx]
        const bytes = @sliceToBytes(memory);
  21b368:	48 8b 8c 24 90 00 00 	mov    rcx,QWORD PTR [rsp+0x90]
  21b36f:	00 
  21b370:	48 8b 09             	mov    rcx,QWORD PTR [rcx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  21b373:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  21b377:	48 89 8c 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rcx
  21b37e:	00 
  21b37f:	48 89 84 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],rax
  21b386:	00 
  21b387:	48 8d b4 24 f0 00 00 	lea    rsi,[rsp+0xf0]
  21b38e:	00 
  21b38f:	ff d2                	call   rdx
                elf_section.addr = try in.readInt(elf.endian, u64);
  21b391:	44 0f b7 ac 24 a0 03 	movzx  r13d,WORD PTR [rsp+0x3a0]
  21b398:	00 00 
  21b39a:	66 45 85 ed          	test   r13w,r13w
  21b39e:	0f 85 f2 b8 ff ff    	jne    216c96 <openSelfDebugInfo+0x256>
  21b3a4:	e9 d9 bf ff ff       	jmp    217382 <openSelfDebugInfo+0x942>
        const bytes = @sliceToBytes(memory);
  21b3a9:	48 8b 84 24 88 00 00 	mov    rax,QWORD PTR [rsp+0x88]
  21b3b0:	00 
  21b3b1:	48 8b 00             	mov    rax,QWORD PTR [rax]
  21b3b4:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  21b3b8:	0f 84 ce b8 ff ff    	je     216c8c <openSelfDebugInfo+0x24c>
  21b3be:	48 8b 4c 24 78       	mov    rcx,QWORD PTR [rsp+0x78]
  21b3c3:	48 8b 39             	mov    rdi,QWORD PTR [rcx]
        const bytes = @sliceToBytes(memory);
  21b3c6:	48 8b 8c 24 90 00 00 	mov    rcx,QWORD PTR [rsp+0x90]
  21b3cd:	00 
  21b3ce:	48 8b 09             	mov    rcx,QWORD PTR [rcx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  21b3d1:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  21b3d5:	48 89 8c 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rcx
  21b3dc:	00 
  21b3dd:	48 89 84 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],rax
  21b3e4:	00 
  21b3e5:	48 8d b4 24 f0 00 00 	lea    rsi,[rsp+0xf0]
  21b3ec:	00 
  21b3ed:	ff d2                	call   rdx
                elf_section.offset = try in.readInt(elf.endian, u64);
  21b3ef:	44 0f b7 ac 24 50 03 	movzx  r13d,WORD PTR [rsp+0x350]
  21b3f6:	00 00 
  21b3f8:	66 45 85 ed          	test   r13w,r13w
  21b3fc:	0f 85 94 b8 ff ff    	jne    216c96 <openSelfDebugInfo+0x256>
  21b402:	e9 7b bf ff ff       	jmp    217382 <openSelfDebugInfo+0x942>
        const bytes = @sliceToBytes(memory);
  21b407:	48 8b 84 24 88 00 00 	mov    rax,QWORD PTR [rsp+0x88]
  21b40e:	00 
  21b40f:	48 8b 00             	mov    rax,QWORD PTR [rax]
  21b412:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  21b416:	0f 84 70 b8 ff ff    	je     216c8c <openSelfDebugInfo+0x24c>
  21b41c:	48 8b 4c 24 78       	mov    rcx,QWORD PTR [rsp+0x78]
  21b421:	48 8b 39             	mov    rdi,QWORD PTR [rcx]
        const bytes = @sliceToBytes(memory);
  21b424:	48 8b 8c 24 90 00 00 	mov    rcx,QWORD PTR [rsp+0x90]
  21b42b:	00 
  21b42c:	48 8b 09             	mov    rcx,QWORD PTR [rcx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  21b42f:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  21b433:	48 89 8c 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rcx
  21b43a:	00 
  21b43b:	48 89 84 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],rax
  21b442:	00 
  21b443:	48 8d b4 24 f0 00 00 	lea    rsi,[rsp+0xf0]
  21b44a:	00 
  21b44b:	ff d2                	call   rdx
                elf_section.size = try in.readInt(elf.endian, u64);
  21b44d:	44 0f b7 ac 24 d0 01 	movzx  r13d,WORD PTR [rsp+0x1d0]
  21b454:	00 00 
  21b456:	66 45 85 ed          	test   r13w,r13w
  21b45a:	0f 85 36 b8 ff ff    	jne    216c96 <openSelfDebugInfo+0x256>
  21b460:	e9 1d bf ff ff       	jmp    217382 <openSelfDebugInfo+0x942>
        const bytes = @sliceToBytes(memory);
  21b465:	48 8b 84 24 88 00 00 	mov    rax,QWORD PTR [rsp+0x88]
  21b46c:	00 
  21b46d:	48 8b 00             	mov    rax,QWORD PTR [rax]
  21b470:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  21b474:	0f 84 12 b8 ff ff    	je     216c8c <openSelfDebugInfo+0x24c>
  21b47a:	48 8b 4c 24 78       	mov    rcx,QWORD PTR [rsp+0x78]
  21b47f:	48 8b 39             	mov    rdi,QWORD PTR [rcx]
        const bytes = @sliceToBytes(memory);
  21b482:	48 8b 8c 24 90 00 00 	mov    rcx,QWORD PTR [rsp+0x90]
  21b489:	00 
  21b48a:	48 8b 09             	mov    rcx,QWORD PTR [rcx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  21b48d:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  21b491:	48 89 8c 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rcx
  21b498:	00 
  21b499:	48 89 84 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],rax
  21b4a0:	00 
  21b4a1:	48 8d b4 24 f0 00 00 	lea    rsi,[rsp+0xf0]
  21b4a8:	00 
  21b4a9:	ff d2                	call   rdx
                elf_section.addr_align = try in.readInt(elf.endian, u64);
  21b4ab:	44 0f b7 ac 24 10 02 	movzx  r13d,WORD PTR [rsp+0x210]
  21b4b2:	00 00 
  21b4b4:	66 45 85 ed          	test   r13w,r13w
  21b4b8:	0f 85 d8 b7 ff ff    	jne    216c96 <openSelfDebugInfo+0x256>
  21b4be:	e9 bf be ff ff       	jmp    217382 <openSelfDebugInfo+0x942>
        const bytes = @sliceToBytes(memory);
  21b4c3:	48 8b 84 24 88 00 00 	mov    rax,QWORD PTR [rsp+0x88]
  21b4ca:	00 
  21b4cb:	48 8b 00             	mov    rax,QWORD PTR [rax]
  21b4ce:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  21b4d2:	0f 84 b4 b7 ff ff    	je     216c8c <openSelfDebugInfo+0x24c>
  21b4d8:	48 8b 4c 24 78       	mov    rcx,QWORD PTR [rsp+0x78]
  21b4dd:	48 8b 39             	mov    rdi,QWORD PTR [rcx]
        const bytes = @sliceToBytes(memory);
  21b4e0:	48 8b 8c 24 90 00 00 	mov    rcx,QWORD PTR [rsp+0x90]
  21b4e7:	00 
  21b4e8:	48 8b 09             	mov    rcx,QWORD PTR [rcx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  21b4eb:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  21b4ef:	48 89 8c 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rcx
  21b4f6:	00 
  21b4f7:	48 89 84 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],rax
  21b4fe:	00 
  21b4ff:	48 8d b4 24 f0 00 00 	lea    rsi,[rsp+0xf0]
  21b506:	00 
  21b507:	ff d2                	call   rdx
                elf_section.ent_size = try in.readInt(elf.endian, u64);
  21b509:	44 0f b7 ac 24 40 02 	movzx  r13d,WORD PTR [rsp+0x240]
  21b510:	00 00 
  21b512:	66 45 85 ed          	test   r13w,r13w
  21b516:	0f 85 7a b7 ff ff    	jne    216c96 <openSelfDebugInfo+0x256>
  21b51c:	e9 61 be ff ff       	jmp    217382 <openSelfDebugInfo+0x942>
  21b521:	48 8b 44 24 78       	mov    rax,QWORD PTR [rsp+0x78]
  21b526:	48 8b 38             	mov    rdi,QWORD PTR [rax]
  21b529:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  21b52d:	48 8b 8c 24 80 00 00 	mov    rcx,QWORD PTR [rsp+0x80]
  21b534:	00 
  21b535:	48 89 8c 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rcx
  21b53c:	00 
  21b53d:	48 8b 8c 24 80 01 00 	mov    rcx,QWORD PTR [rsp+0x180]
  21b544:	00 
  21b545:	48 89 8c 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],rcx
  21b54c:	00 
  21b54d:	48 8d b4 24 f0 00 00 	lea    rsi,[rsp+0xf0]
  21b554:	00 
  21b555:	ff d0                	call   rax
  21b557:	e9 61 01 00 00       	jmp    21b6bd <openSelfDebugInfo+0x4c7d>
  21b55c:	66 41 bd 1f 00       	mov    r13w,0x1f
        const bytes = @sliceToBytes(memory);
  21b561:	48 8b 84 24 88 00 00 	mov    rax,QWORD PTR [rsp+0x88]
  21b568:	00 
  21b569:	48 8b 00             	mov    rax,QWORD PTR [rax]
  21b56c:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  21b570:	0f 84 20 b7 ff ff    	je     216c96 <openSelfDebugInfo+0x256>
  21b576:	48 8b 4c 24 78       	mov    rcx,QWORD PTR [rsp+0x78]
  21b57b:	48 8b 39             	mov    rdi,QWORD PTR [rcx]
        const bytes = @sliceToBytes(memory);
  21b57e:	48 8b 8c 24 90 00 00 	mov    rcx,QWORD PTR [rsp+0x90]
  21b585:	00 
  21b586:	48 8b 09             	mov    rcx,QWORD PTR [rcx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  21b589:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  21b58d:	48 89 8c 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rcx
  21b594:	00 
  21b595:	48 89 84 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],rax
  21b59c:	00 
  21b59d:	48 8d b4 24 f0 00 00 	lea    rsi,[rsp+0xf0]
  21b5a4:	00 
  21b5a5:	ff d2                	call   rdx
  21b5a7:	e9 ea b6 ff ff       	jmp    216c96 <openSelfDebugInfo+0x256>
        for (elf.section_headers) |*elf_section| {
  21b5ac:	48 8b 84 24 88 00 00 	mov    rax,QWORD PTR [rsp+0x88]
  21b5b3:	00 
  21b5b4:	48 8b 00             	mov    rax,QWORD PTR [rax]
  21b5b7:	48 85 c0             	test   rax,rax
  21b5ba:	74 6b                	je     21b627 <openSelfDebugInfo+0x4be7>
  21b5bc:	48 8b 8c 24 90 00 00 	mov    rcx,QWORD PTR [rsp+0x90]
  21b5c3:	00 
  21b5c4:	4c 8b 09             	mov    r9,QWORD PTR [rcx]
  21b5c7:	49 8d 51 20          	lea    rdx,[r9+0x20]
  21b5cb:	31 f6                	xor    esi,esi
  21b5cd:	4c 8d 05 2c 4f fe ff 	lea    r8,[rip+0xfffffffffffe4f2c]        # 200500 <__unnamed_52>
            if (elf_section.sh_type != SHT_NOBITS) {
  21b5d4:	83 7a e4 08          	cmp    DWORD PTR [rdx-0x1c],0x8
  21b5d8:	74 3e                	je     21b618 <openSelfDebugInfo+0x4bd8>
                const file_end_offset = try math.add(u64, elf_section.offset, elf_section.size);
  21b5da:	48 8b 4a f8          	mov    rcx,QWORD PTR [rdx-0x8]
  21b5de:	4c 89 c7             	mov    rdi,r8
    return if (@addWithOverflow(T, a, b, &answer)) error.Overflow else answer;
  21b5e1:	48 03 0a             	add    rcx,QWORD PTR [rdx]
  21b5e4:	72 1a                	jb     21b600 <openSelfDebugInfo+0x4bc0>
  21b5e6:	66 c7 84 24 f0 00 00 	mov    WORD PTR [rsp+0xf0],0x0
  21b5ed:	00 00 00 
  21b5f0:	48 89 8c 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],rcx
  21b5f7:	00 
  21b5f8:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  21b5ff:	00 
  21b600:	44 0f b7 2f          	movzx  r13d,WORD PTR [rdi]
  21b604:	66 45 85 ed          	test   r13w,r13w
  21b608:	75 52                	jne    21b65c <openSelfDebugInfo+0x4c1c>
                if (stream_end < file_end_offset) return error.InvalidFormat;
  21b60a:	48 8b 8c 24 c8 01 00 	mov    rcx,QWORD PTR [rsp+0x1c8]
  21b611:	00 
  21b612:	48 3b 4f 08          	cmp    rcx,QWORD PTR [rdi+0x8]
  21b616:	72 79                	jb     21b691 <openSelfDebugInfo+0x4c51>
        for (elf.section_headers) |*elf_section| {
  21b618:	48 83 c6 01          	add    rsi,0x1
  21b61c:	48 83 c2 40          	add    rdx,0x40
  21b620:	48 39 c6             	cmp    rsi,rax
  21b623:	72 af                	jb     21b5d4 <openSelfDebugInfo+0x4b94>
  21b625:	eb 0b                	jmp    21b632 <openSelfDebugInfo+0x4bf2>
        elf.string_section = &elf.section_headers[elf.string_section_index];
  21b627:	48 8b 8c 24 90 00 00 	mov    rcx,QWORD PTR [rsp+0x90]
  21b62e:	00 
  21b62f:	4c 8b 09             	mov    r9,QWORD PTR [rcx]
  21b632:	48 8b 4d 30          	mov    rcx,QWORD PTR [rbp+0x30]
  21b636:	48 c1 e1 06          	shl    rcx,0x6
  21b63a:	49 8d 14 09          	lea    rdx,[r9+rcx*1]
  21b63e:	48 89 55 38          	mov    QWORD PTR [rbp+0x38],rdx
        if (elf.string_section.sh_type != SHT_STRTAB) {
  21b642:	41 83 7c 09 04 03    	cmp    DWORD PTR [r9+rcx*1+0x4],0x3
  21b648:	75 47                	jne    21b691 <openSelfDebugInfo+0x4c51>
  21b64a:	45 31 ed             	xor    r13d,r13d
  21b64d:	66 45 85 ed          	test   r13w,r13w
  21b651:	0f 85 3f b6 ff ff    	jne    216c96 <openSelfDebugInfo+0x256>
  21b657:	e9 26 bd ff ff       	jmp    217382 <openSelfDebugInfo+0x942>
        const bytes = @sliceToBytes(memory);
  21b65c:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  21b660:	0f 84 30 b6 ff ff    	je     216c96 <openSelfDebugInfo+0x256>
  21b666:	48 8b 4c 24 78       	mov    rcx,QWORD PTR [rsp+0x78]
  21b66b:	48 8b 39             	mov    rdi,QWORD PTR [rcx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  21b66e:	48 8b 4f 10          	mov    rcx,QWORD PTR [rdi+0x10]
  21b672:	4c 89 8c 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],r9
  21b679:	00 
  21b67a:	48 89 84 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],rax
  21b681:	00 
  21b682:	48 8d b4 24 f0 00 00 	lea    rsi,[rsp+0xf0]
  21b689:	00 
  21b68a:	ff d1                	call   rcx
  21b68c:	e9 05 b6 ff ff       	jmp    216c96 <openSelfDebugInfo+0x256>
        const bytes = @sliceToBytes(memory);
  21b691:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  21b695:	74 26                	je     21b6bd <openSelfDebugInfo+0x4c7d>
  21b697:	48 8b 4c 24 78       	mov    rcx,QWORD PTR [rsp+0x78]
  21b69c:	48 8b 39             	mov    rdi,QWORD PTR [rcx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  21b69f:	48 8b 4f 10          	mov    rcx,QWORD PTR [rdi+0x10]
  21b6a3:	4c 89 8c 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],r9
  21b6aa:	00 
  21b6ab:	48 89 84 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],rax
  21b6b2:	00 
  21b6b3:	48 8d b4 24 f0 00 00 	lea    rsi,[rsp+0xf0]
  21b6ba:	00 
  21b6bb:	ff d1                	call   rcx
  21b6bd:	66 41 bd 20 00       	mov    r13w,0x20
  21b6c2:	e9 cf b5 ff ff       	jmp    216c96 <openSelfDebugInfo+0x256>
  21b6c7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  21b6ce:	00 00 

000000000021b6d0 <Elf_findSection>:
    }

    pub fn findSection(elf: *Elf, name: []const u8) !?*SectionHeader {
  21b6d0:	55                   	push   rbp
  21b6d1:	41 57                	push   r15
  21b6d3:	41 56                	push   r14
  21b6d5:	41 55                	push   r13
  21b6d7:	41 54                	push   r12
  21b6d9:	53                   	push   rbx
  21b6da:	48 81 ec 88 00 00 00 	sub    rsp,0x88
  21b6e1:	48 89 d3             	mov    rbx,rdx
  21b6e4:	48 89 7c 24 08       	mov    QWORD PTR [rsp+0x8],rdi
        var file_stream = io.FileInStream.init(elf.in_file);
  21b6e9:	48 8b 06             	mov    rax,QWORD PTR [rsi]
  21b6ec:	48 89 44 24 28       	mov    QWORD PTR [rsp+0x28],rax
  21b6f1:	48 8d 05 48 05 00 00 	lea    rax,[rip+0x548]        # 21bc40 <FileInStream_readFn>
  21b6f8:	48 89 44 24 30       	mov    QWORD PTR [rsp+0x30],rax
        const in = &file_stream.stream;

        section_loop: for (elf.section_headers) |*elf_section| {
  21b6fd:	48 8b 46 40          	mov    rax,QWORD PTR [rsi+0x40]
  21b701:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
  21b706:	48 85 c0             	test   rax,rax
  21b709:	0f 84 37 01 00 00    	je     21b846 <Elf_findSection+0x176>
  21b70f:	45 31 e4             	xor    r12d,r12d
  21b712:	48 89 74 24 20       	mov    QWORD PTR [rsp+0x20],rsi
  21b717:	4c 8b 76 38          	mov    r14,QWORD PTR [rsi+0x38]
  21b71b:	4c 89 e0             	mov    rax,r12
  21b71e:	48 c1 e0 06          	shl    rax,0x6
            if (elf_section.sh_type == SHT_NULL) continue;
  21b722:	41 83 7c 06 04 00    	cmp    DWORD PTR [r14+rax*1+0x4],0x0
  21b728:	0f 84 04 01 00 00    	je     21b832 <Elf_findSection+0x162>
  21b72e:	49 01 c6             	add    r14,rax
  21b731:	48 8b 4c 24 20       	mov    rcx,QWORD PTR [rsp+0x20]

            const name_offset = elf.string_section.offset + elf_section.name;
  21b736:	48 8b 41 30          	mov    rax,QWORD PTR [rcx+0x30]
  21b73a:	41 8b 36             	mov    esi,DWORD PTR [r14]
    if (@maxValue(@typeOf(x)) > @maxValue(T) and x > @maxValue(T)) {
  21b73d:	48 03 70 18          	add    rsi,QWORD PTR [rax+0x18]
  21b741:	0f 88 3e 01 00 00    	js     21b885 <Elf_findSection+0x1b5>
            try elf.in_file.seekTo(name_offset);
  21b747:	48 8b 01             	mov    rax,QWORD PTR [rcx]
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  21b74a:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  21b74d:	b8 08 00 00 00       	mov    eax,0x8
  21b752:	31 d2                	xor    edx,edx
  21b754:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  21b756:	48 89 c1             	mov    rcx,rax
  21b759:	48 f7 d9             	neg    rcx
  21b75c:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  21b762:	b8 00 00 00 00       	mov    eax,0x0
  21b767:	48 0f 46 c8          	cmovbe rcx,rax
  21b76b:	48 85 c9             	test   rcx,rcx
  21b76e:	0f 85 17 01 00 00    	jne    21b88b <Elf_findSection+0x1bb>

            for (name) |expected_c| {
  21b774:	4c 8b 6b 08          	mov    r13,QWORD PTR [rbx+0x8]
  21b778:	4d 85 ed             	test   r13,r13
  21b77b:	74 66                	je     21b7e3 <Elf_findSection+0x113>
  21b77d:	31 ed                	xor    ebp,ebp
  21b77f:	90                   	nop
  21b780:	48 8b 03             	mov    rax,QWORD PTR [rbx]
  21b783:	44 0f b6 3c 28       	movzx  r15d,BYTE PTR [rax+rbp*1]
            try self.readNoEof(result[0..]);
  21b788:	48 8d 44 24 07       	lea    rax,[rsp+0x7]
  21b78d:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  21b792:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  21b799:	00 00 
            return self.readFn(self, buffer);
  21b79b:	48 8d 7c 24 38       	lea    rdi,[rsp+0x38]
  21b7a0:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
  21b7a5:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  21b7aa:	ff 54 24 30          	call   QWORD PTR [rsp+0x30]
  21b7ae:	0f b7 44 24 38       	movzx  eax,WORD PTR [rsp+0x38]
            const amt_read = try self.read(buf);
  21b7b3:	66 85 c0             	test   ax,ax
  21b7b6:	0f 85 9d 00 00 00    	jne    21b859 <Elf_findSection+0x189>
  21b7bc:	48 8b 44 24 40       	mov    rax,QWORD PTR [rsp+0x40]
            if (amt_read < buf.len) return error.EndOfStream;
  21b7c1:	48 3b 44 24 18       	cmp    rax,QWORD PTR [rsp+0x18]
  21b7c6:	0f 82 89 00 00 00    	jb     21b855 <Elf_findSection+0x185>
            return result[0];
  21b7cc:	0f b6 44 24 07       	movzx  eax,BYTE PTR [rsp+0x7]
                const target_c = try in.readByte();
                if (target_c == 0 or expected_c != target_c) continue :section_loop;
  21b7d1:	84 c0                	test   al,al
  21b7d3:	74 5d                	je     21b832 <Elf_findSection+0x162>
  21b7d5:	41 38 c7             	cmp    r15b,al
  21b7d8:	75 58                	jne    21b832 <Elf_findSection+0x162>
  21b7da:	48 83 c5 01          	add    rbp,0x1
            for (name) |expected_c| {
  21b7de:	4c 39 ed             	cmp    rbp,r13
  21b7e1:	72 9d                	jb     21b780 <Elf_findSection+0xb0>
            try self.readNoEof(result[0..]);
  21b7e3:	48 8d 44 24 07       	lea    rax,[rsp+0x7]
  21b7e8:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  21b7ed:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  21b7f4:	00 00 
            return self.readFn(self, buffer);
  21b7f6:	48 8d 7c 24 38       	lea    rdi,[rsp+0x38]
  21b7fb:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
  21b800:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  21b805:	ff 54 24 30          	call   QWORD PTR [rsp+0x30]
  21b809:	0f b7 44 24 38       	movzx  eax,WORD PTR [rsp+0x38]
            const amt_read = try self.read(buf);
  21b80e:	66 85 c0             	test   ax,ax
  21b811:	0f 85 b7 00 00 00    	jne    21b8ce <Elf_findSection+0x1fe>
  21b817:	48 8b 44 24 40       	mov    rax,QWORD PTR [rsp+0x40]
            if (amt_read < buf.len) return error.EndOfStream;
  21b81c:	48 3b 44 24 18       	cmp    rax,QWORD PTR [rsp+0x18]
  21b821:	0f 82 a3 00 00 00    	jb     21b8ca <Elf_findSection+0x1fa>
            }

            {
                const null_byte = try in.readByte();
                if (null_byte == 0) return elf_section;
  21b827:	80 7c 24 07 00       	cmp    BYTE PTR [rsp+0x7],0x0
  21b82c:	0f 84 b0 00 00 00    	je     21b8e2 <Elf_findSection+0x212>
        section_loop: for (elf.section_headers) |*elf_section| {
  21b832:	49 83 c4 01          	add    r12,0x1
  21b836:	4c 3b 64 24 50       	cmp    r12,QWORD PTR [rsp+0x50]
  21b83b:	48 8b 74 24 20       	mov    rsi,QWORD PTR [rsp+0x20]
  21b840:	0f 82 d1 fe ff ff    	jb     21b717 <Elf_findSection+0x47>
            }
        }

        return null;
  21b846:	c5 f8 57 c0          	vxorps xmm0,xmm0,xmm0
  21b84a:	48 8b 44 24 08       	mov    rax,QWORD PTR [rsp+0x8]
  21b84f:	c5 f8 11 00          	vmovups XMMWORD PTR [rax],xmm0
  21b853:	eb 1e                	jmp    21b873 <Elf_findSection+0x1a3>
  21b855:	66 b8 1f 00          	mov    ax,0x1f
  21b859:	48 8b 54 24 08       	mov    rdx,QWORD PTR [rsp+0x8]
                const target_c = try in.readByte();
  21b85e:	66 89 02             	mov    WORD PTR [rdx],ax
  21b861:	48 8b 44 24 6c       	mov    rax,QWORD PTR [rsp+0x6c]
  21b866:	48 8b 4c 24 72       	mov    rcx,QWORD PTR [rsp+0x72]
  21b86b:	48 89 4a 08          	mov    QWORD PTR [rdx+0x8],rcx
  21b86f:	48 89 42 02          	mov    QWORD PTR [rdx+0x2],rax
  21b873:	48 81 c4 88 00 00 00 	add    rsp,0x88
  21b87a:	5b                   	pop    rbx
  21b87b:	41 5c                	pop    r12
  21b87d:	41 5d                	pop    r13
  21b87f:	41 5e                	pop    r14
  21b881:	41 5f                	pop    r15
  21b883:	5d                   	pop    rbp
  21b884:	c3                   	ret    
  21b885:	66 b8 04 00          	mov    ax,0x4
  21b889:	eb 28                	jmp    21b8b3 <Elf_findSection+0x1e3>
  21b88b:	48 8d 41 ea          	lea    rax,[rcx-0x16]
  21b88f:	48 83 f8 35          	cmp    rax,0x35
  21b893:	77 10                	ja     21b8a5 <Elf_findSection+0x1d5>
  21b895:	48 ba 81 00 00 00 00 	movabs rdx,0x20000000000081
  21b89c:	00 20 00 
  21b89f:	48 0f a3 c2          	bt     rdx,rax
  21b8a3:	72 0a                	jb     21b8af <Elf_findSection+0x1df>
  21b8a5:	66 b8 03 00          	mov    ax,0x3
  21b8a9:	48 83 f9 06          	cmp    rcx,0x6
  21b8ad:	75 04                	jne    21b8b3 <Elf_findSection+0x1e3>
  21b8af:	66 b8 21 00          	mov    ax,0x21
  21b8b3:	48 8b 54 24 08       	mov    rdx,QWORD PTR [rsp+0x8]
            try elf.in_file.seekTo(name_offset);
  21b8b8:	66 89 02             	mov    WORD PTR [rdx],ax
  21b8bb:	48 8b 44 24 7a       	mov    rax,QWORD PTR [rsp+0x7a]
  21b8c0:	48 8b 8c 24 80 00 00 	mov    rcx,QWORD PTR [rsp+0x80]
  21b8c7:	00 
  21b8c8:	eb a1                	jmp    21b86b <Elf_findSection+0x19b>
  21b8ca:	66 b8 1f 00          	mov    ax,0x1f
  21b8ce:	48 8b 54 24 08       	mov    rdx,QWORD PTR [rsp+0x8]
                const null_byte = try in.readByte();
  21b8d3:	66 89 02             	mov    WORD PTR [rdx],ax
  21b8d6:	48 8b 44 24 5e       	mov    rax,QWORD PTR [rsp+0x5e]
  21b8db:	48 8b 4c 24 64       	mov    rcx,QWORD PTR [rsp+0x64]
  21b8e0:	eb 89                	jmp    21b86b <Elf_findSection+0x19b>
  21b8e2:	48 8b 4c 24 08       	mov    rcx,QWORD PTR [rsp+0x8]
                if (null_byte == 0) return elf_section;
  21b8e7:	66 c7 01 00 00       	mov    WORD PTR [rcx],0x0
  21b8ec:	0f b7 44 24 4e       	movzx  eax,WORD PTR [rsp+0x4e]
  21b8f1:	66 89 41 06          	mov    WORD PTR [rcx+0x6],ax
  21b8f5:	8b 44 24 4a          	mov    eax,DWORD PTR [rsp+0x4a]
  21b8f9:	89 41 02             	mov    DWORD PTR [rcx+0x2],eax
  21b8fc:	4c 89 71 08          	mov    QWORD PTR [rcx+0x8],r14
  21b900:	e9 6e ff ff ff       	jmp    21b873 <Elf_findSection+0x1a3>
  21b905:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21b90c:	00 00 00 00 

000000000021b910 <File_openReadC>:
    pub fn openReadC(path: [*]const u8) OpenError!File {
  21b910:	49 89 f1             	mov    r9,rsi
  21b913:	49 89 f8             	mov    r8,rdi
  21b916:	45 31 d2             	xor    r10d,r10d
  21b919:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  21b920:	b8 02 00 00 00       	mov    eax,0x2
  21b925:	be 00 00 00 00       	mov    esi,0x0
  21b92a:	31 d2                	xor    edx,edx
  21b92c:	4c 89 cf             	mov    rdi,r9
  21b92f:	0f 05                	syscall 
  21b931:	48 89 c1             	mov    rcx,rax
  21b934:	48 f7 d9             	neg    rcx
  21b937:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  21b93d:	49 0f 46 ca          	cmovbe rcx,r10
        if (err > 0) {
  21b941:	48 83 f9 04          	cmp    rcx,0x4
  21b945:	74 d9                	je     21b920 <File_openReadC+0x10>
  21b947:	48 83 f9 4b          	cmp    rcx,0x4b
  21b94b:	77 2d                	ja     21b97a <File_openReadC+0x6a>
  21b94d:	48 8d 15 3c 58 fe ff 	lea    rdx,[rip+0xfffffffffffe583c]        # 201190 <app_mask+0x4b0>
  21b954:	48 63 0c 8a          	movsxd rcx,DWORD PTR [rdx+rcx*4]
  21b958:	48 01 d1             	add    rcx,rdx
  21b95b:	ff e1                	jmp    rcx
  21b95d:	66 b8 10 00          	mov    ax,0x10
  21b961:	eb 57                	jmp    21b9ba <File_openReadC+0xaa>
  21b963:	66 b8 0d 00          	mov    ax,0xd
  21b967:	eb 51                	jmp    21b9ba <File_openReadC+0xaa>
            return openHandle(fd);
  21b969:	66 41 c7 00 00 00    	mov    WORD PTR [r8],0x0
  21b96f:	41 89 40 04          	mov    DWORD PTR [r8+0x4],eax
  21b973:	c3                   	ret    
  21b974:	66 b8 14 00          	mov    ax,0x14
  21b978:	eb 40                	jmp    21b9ba <File_openReadC+0xaa>
  21b97a:	66 b8 03 00          	mov    ax,0x3
  21b97e:	eb 3a                	jmp    21b9ba <File_openReadC+0xaa>
  21b980:	66 b8 06 00          	mov    ax,0x6
  21b984:	eb 34                	jmp    21b9ba <File_openReadC+0xaa>
  21b986:	66 b8 13 00          	mov    ax,0x13
  21b98a:	eb 2e                	jmp    21b9ba <File_openReadC+0xaa>
  21b98c:	66 b8 1d 00          	mov    ax,0x1d
  21b990:	eb 28                	jmp    21b9ba <File_openReadC+0xaa>
  21b992:	66 b8 1e 00          	mov    ax,0x1e
  21b996:	eb 22                	jmp    21b9ba <File_openReadC+0xaa>
  21b998:	66 b8 19 00          	mov    ax,0x19
  21b99c:	eb 1c                	jmp    21b9ba <File_openReadC+0xaa>
  21b99e:	66 b8 1c 00          	mov    ax,0x1c
  21b9a2:	eb 16                	jmp    21b9ba <File_openReadC+0xaa>
  21b9a4:	66 b8 1b 00          	mov    ax,0x1b
  21b9a8:	eb 10                	jmp    21b9ba <File_openReadC+0xaa>
  21b9aa:	66 b8 0f 00          	mov    ax,0xf
  21b9ae:	eb 0a                	jmp    21b9ba <File_openReadC+0xaa>
  21b9b0:	66 b8 16 00          	mov    ax,0x16
  21b9b4:	eb 04                	jmp    21b9ba <File_openReadC+0xaa>
  21b9b6:	66 b8 1a 00          	mov    ax,0x1a
            const fd = try os.posixOpenC(path, flags, 0);
  21b9ba:	66 41 89 00          	mov    WORD PTR [r8],ax
  21b9be:	0f b7 44 24 fe       	movzx  eax,WORD PTR [rsp-0x2]
  21b9c3:	66 41 89 40 06       	mov    WORD PTR [r8+0x6],ax
  21b9c8:	8b 44 24 fa          	mov    eax,DWORD PTR [rsp-0x6]
  21b9cc:	41 89 40 02          	mov    DWORD PTR [r8+0x2],eax
  21b9d0:	c3                   	ret    
  21b9d1:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21b9d8:	0f 1f 84 00 00 00 00 
  21b9df:	00 

000000000021b9e0 <InStream(ReadError)_readInt.45>:
        pub fn readInt(self: *Self, endian: builtin.Endian, comptime T: type) !T {
  21b9e0:	55                   	push   rbp
  21b9e1:	53                   	push   rbx
  21b9e2:	48 83 ec 48          	sub    rsp,0x48
  21b9e6:	89 d5                	mov    ebp,edx
  21b9e8:	48 89 fb             	mov    rbx,rdi
  21b9eb:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
            try self.readNoEof(bytes[0..]);
  21b9f0:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  21b9f5:	48 c7 44 24 20 08 00 	mov    QWORD PTR [rsp+0x20],0x8
  21b9fc:	00 00 
  21b9fe:	48 8d 7c 24 28       	lea    rdi,[rsp+0x28]
  21ba03:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  21ba08:	ff 16                	call   QWORD PTR [rsi]
  21ba0a:	0f b7 44 24 28       	movzx  eax,WORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  21ba0f:	66 85 c0             	test   ax,ax
  21ba12:	75 10                	jne    21ba24 <InStream(ReadError)_readInt.45+0x44>
  21ba14:	48 8b 4c 24 30       	mov    rcx,QWORD PTR [rsp+0x30]
  21ba19:	66 b8 1f 00          	mov    ax,0x1f
            if (amt_read < buf.len) return error.EndOfStream;
  21ba1d:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  21ba22:	73 1c                	jae    21ba40 <InStream(ReadError)_readInt.45+0x60>
            try self.readNoEof(bytes[0..]);
  21ba24:	66 89 03             	mov    WORD PTR [rbx],ax
  21ba27:	48 8b 44 24 3a       	mov    rax,QWORD PTR [rsp+0x3a]
  21ba2c:	48 8b 4c 24 40       	mov    rcx,QWORD PTR [rsp+0x40]
  21ba31:	48 89 4b 08          	mov    QWORD PTR [rbx+0x8],rcx
  21ba35:	48 89 43 02          	mov    QWORD PTR [rbx+0x2],rax
  21ba39:	48 83 c4 48          	add    rsp,0x48
  21ba3d:	5b                   	pop    rbx
  21ba3e:	5d                   	pop    rbp
  21ba3f:	c3                   	ret    
  21ba40:	0f b6 44 24 08       	movzx  eax,BYTE PTR [rsp+0x8]
  21ba45:	0f b6 4c 24 09       	movzx  ecx,BYTE PTR [rsp+0x9]
    switch (endian) {
  21ba4a:	40 f6 c5 01          	test   bpl,0x1
  21ba4e:	74 51                	je     21baa1 <InStream(ReadError)_readInt.45+0xc1>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  21ba50:	48 c1 e1 08          	shl    rcx,0x8
  21ba54:	48 09 c1             	or     rcx,rax
  21ba57:	0f b6 44 24 0a       	movzx  eax,BYTE PTR [rsp+0xa]
  21ba5c:	48 c1 e0 10          	shl    rax,0x10
  21ba60:	48 09 c8             	or     rax,rcx
  21ba63:	0f b6 4c 24 0b       	movzx  ecx,BYTE PTR [rsp+0xb]
  21ba68:	48 c1 e1 18          	shl    rcx,0x18
  21ba6c:	48 09 c1             	or     rcx,rax
  21ba6f:	0f b6 44 24 0c       	movzx  eax,BYTE PTR [rsp+0xc]
  21ba74:	48 c1 e0 20          	shl    rax,0x20
  21ba78:	48 09 c8             	or     rax,rcx
  21ba7b:	0f b6 4c 24 0d       	movzx  ecx,BYTE PTR [rsp+0xd]
  21ba80:	48 c1 e1 28          	shl    rcx,0x28
  21ba84:	48 09 c1             	or     rcx,rax
  21ba87:	0f b6 54 24 0e       	movzx  edx,BYTE PTR [rsp+0xe]
  21ba8c:	48 c1 e2 30          	shl    rdx,0x30
  21ba90:	0f b6 44 24 0f       	movzx  eax,BYTE PTR [rsp+0xf]
  21ba95:	48 c1 e0 38          	shl    rax,0x38
  21ba99:	48 09 d0             	or     rax,rdx
  21ba9c:	48 09 c8             	or     rax,rcx
  21ba9f:	eb 4f                	jmp    21baf0 <InStream(ReadError)_readInt.45+0x110>
                result = (result << 8) | b;
  21baa1:	48 c1 e0 08          	shl    rax,0x8
  21baa5:	48 09 c8             	or     rax,rcx
  21baa8:	48 c1 e0 08          	shl    rax,0x8
  21baac:	0f b6 4c 24 0a       	movzx  ecx,BYTE PTR [rsp+0xa]
  21bab1:	48 09 c1             	or     rcx,rax
  21bab4:	48 c1 e1 08          	shl    rcx,0x8
  21bab8:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  21babd:	48 09 c8             	or     rax,rcx
  21bac0:	48 c1 e0 08          	shl    rax,0x8
  21bac4:	0f b6 4c 24 0c       	movzx  ecx,BYTE PTR [rsp+0xc]
  21bac9:	48 09 c1             	or     rcx,rax
  21bacc:	48 c1 e1 08          	shl    rcx,0x8
  21bad0:	0f b6 44 24 0d       	movzx  eax,BYTE PTR [rsp+0xd]
  21bad5:	48 09 c8             	or     rax,rcx
  21bad8:	48 c1 e0 08          	shl    rax,0x8
  21badc:	0f b6 4c 24 0e       	movzx  ecx,BYTE PTR [rsp+0xe]
  21bae1:	48 09 c1             	or     rcx,rax
  21bae4:	48 c1 e1 08          	shl    rcx,0x8
  21bae8:	0f b6 44 24 0f       	movzx  eax,BYTE PTR [rsp+0xf]
  21baed:	48 09 c8             	or     rax,rcx
            return mem.readInt(bytes, T, endian);
  21baf0:	66 c7 03 00 00       	mov    WORD PTR [rbx],0x0
  21baf5:	0f b7 4c 24 16       	movzx  ecx,WORD PTR [rsp+0x16]
  21bafa:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  21bafe:	8b 4c 24 12          	mov    ecx,DWORD PTR [rsp+0x12]
  21bb02:	89 4b 02             	mov    DWORD PTR [rbx+0x2],ecx
  21bb05:	48 89 43 08          	mov    QWORD PTR [rbx+0x8],rax
  21bb09:	48 83 c4 48          	add    rsp,0x48
  21bb0d:	5b                   	pop    rbx
  21bb0e:	5d                   	pop    rbp
  21bb0f:	c3                   	ret    

000000000021bb10 <File_read>:
        SystemResources,

        Unexpected,
    };

    pub fn read(self: *File, buffer: []u8) ReadError!usize {
  21bb10:	41 57                	push   r15
  21bb12:	41 56                	push   r14
  21bb14:	53                   	push   rbx
  21bb15:	49 89 d1             	mov    r9,rdx
  21bb18:	49 89 f2             	mov    r10,rsi
  21bb1b:	49 89 f8             	mov    r8,rdi
        if (is_posix) {
            var index: usize = 0;
            while (index < buffer.len) {
  21bb1e:	49 8b 51 08          	mov    rdx,QWORD PTR [r9+0x8]
  21bb22:	48 85 d2             	test   rdx,rdx
  21bb25:	74 70                	je     21bb97 <File_read+0x87>
  21bb27:	45 31 f6             	xor    r14d,r14d
  21bb2a:	4c 8d 3d 8f 57 fe ff 	lea    r15,[rip+0xfffffffffffe578f]        # 2012c0 <app_mask+0x5e0>
  21bb31:	31 db                	xor    ebx,ebx
  21bb33:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21bb3a:	84 00 00 00 00 00 
  21bb40:	49 8b 31             	mov    rsi,QWORD PTR [r9]
                const amt_read = posix.read(self.handle, buffer.ptr + index, buffer.len - index);
  21bb43:	48 01 de             	add    rsi,rbx
  21bb46:	48 29 da             	sub    rdx,rbx
    return syscall3(SYS_read, @intCast(usize, fd), @ptrToInt(buf), count);
  21bb49:	49 63 3a             	movsxd rdi,DWORD PTR [r10]
  21bb4c:	31 c0                	xor    eax,eax
  21bb4e:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  21bb50:	48 89 c1             	mov    rcx,rax
  21bb53:	48 f7 d9             	neg    rcx
  21bb56:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  21bb5c:	49 0f 46 ce          	cmovbe rcx,r14
                const read_err = posix.getErrno(amt_read);
                if (read_err > 0) {
  21bb60:	48 83 f9 04          	cmp    rcx,0x4
  21bb64:	75 0b                	jne    21bb71 <File_read+0x61>
            while (index < buffer.len) {
  21bb66:	49 8b 51 08          	mov    rdx,QWORD PTR [r9+0x8]
  21bb6a:	48 39 da             	cmp    rdx,rbx
  21bb6d:	77 d1                	ja     21bb40 <File_read+0x30>
  21bb6f:	eb 28                	jmp    21bb99 <File_read+0x89>
  21bb71:	48 83 f9 15          	cmp    rcx,0x15
  21bb75:	77 44                	ja     21bbbb <File_read+0xab>
  21bb77:	49 63 0c 8f          	movsxd rcx,DWORD PTR [r15+rcx*4]
  21bb7b:	4c 01 f9             	add    rcx,r15
  21bb7e:	ff e1                	jmp    rcx
                        posix.ENOBUFS => return error.SystemResources,
                        posix.ENOMEM => return error.SystemResources,
                        else => return os.unexpectedErrorPosix(read_err),
                    }
                }
                if (amt_read == 0) return index;
  21bb80:	48 85 c0             	test   rax,rax
  21bb83:	0f 84 91 00 00 00    	je     21bc1a <File_read+0x10a>
  21bb89:	48 01 c3             	add    rbx,rax
            while (index < buffer.len) {
  21bb8c:	49 8b 51 08          	mov    rdx,QWORD PTR [r9+0x8]
  21bb90:	48 39 da             	cmp    rdx,rbx
  21bb93:	77 ab                	ja     21bb40 <File_read+0x30>
  21bb95:	eb 02                	jmp    21bb99 <File_read+0x89>
  21bb97:	31 db                	xor    ebx,ebx
                index += amt_read;
            }
            return index;
  21bb99:	66 41 c7 00 00 00    	mov    WORD PTR [r8],0x0
  21bb9f:	0f b7 44 24 ea       	movzx  eax,WORD PTR [rsp-0x16]
  21bba4:	66 41 89 40 06       	mov    WORD PTR [r8+0x6],ax
  21bba9:	8b 44 24 e6          	mov    eax,DWORD PTR [rsp-0x1a]
  21bbad:	41 89 40 02          	mov    DWORD PTR [r8+0x2],eax
  21bbb1:	49 89 58 08          	mov    QWORD PTR [r8+0x8],rbx
  21bbb5:	5b                   	pop    rbx
  21bbb6:	41 5e                	pop    r14
  21bbb8:	41 5f                	pop    r15
  21bbba:	c3                   	ret    
                if (read_err > 0) {
  21bbbb:	48 83 f9 69          	cmp    rcx,0x69
  21bbbf:	75 0a                	jne    21bbcb <File_read+0xbb>
  21bbc1:	c5 f8 10 05 17 4e fe 	vmovups xmm0,XMMWORD PTR [rip+0xfffffffffffe4e17]        # 2009e0 <__unnamed_70>
  21bbc8:	ff 
  21bbc9:	eb 44                	jmp    21bc0f <File_read+0xff>
                        else => return os.unexpectedErrorPosix(read_err),
  21bbcb:	66 41 c7 00 03 00    	mov    WORD PTR [r8],0x3
  21bbd1:	48 8b 44 24 f2       	mov    rax,QWORD PTR [rsp-0xe]
  21bbd6:	48 8b 4c 24 f8       	mov    rcx,QWORD PTR [rsp-0x8]
  21bbdb:	49 89 48 08          	mov    QWORD PTR [r8+0x8],rcx
  21bbdf:	49 89 40 02          	mov    QWORD PTR [r8+0x2],rax
  21bbe3:	5b                   	pop    rbx
  21bbe4:	41 5e                	pop    r14
  21bbe6:	41 5f                	pop    r15
  21bbe8:	c3                   	ret    
                        posix.EIO => return error.InputOutput,
  21bbe9:	c5 f8 10 05 af 4d fe 	vmovups xmm0,XMMWORD PTR [rip+0xfffffffffffe4daf]        # 2009a0 <__unnamed_71>
  21bbf0:	ff 
  21bbf1:	eb 1c                	jmp    21bc0f <File_read+0xff>
                        posix.EBADF => return error.FileClosed,
  21bbf3:	c5 f8 10 05 45 48 fe 	vmovups xmm0,XMMWORD PTR [rip+0xfffffffffffe4845]        # 200440 <__unnamed_72>
  21bbfa:	ff 
  21bbfb:	eb 12                	jmp    21bc0f <File_read+0xff>
                        posix.EAGAIN => return error.WouldBlock,
  21bbfd:	c5 f8 10 05 2b 48 fe 	vmovups xmm0,XMMWORD PTR [rip+0xfffffffffffe482b]        # 200430 <__unnamed_73>
  21bc04:	ff 
  21bc05:	eb 08                	jmp    21bc0f <File_read+0xff>
                        posix.EISDIR => return error.IsDir,
  21bc07:	c5 f8 10 05 11 47 fe 	vmovups xmm0,XMMWORD PTR [rip+0xfffffffffffe4711]        # 200320 <__unnamed_74>
  21bc0e:	ff 
  21bc0f:	c4 c1 78 11 00       	vmovups XMMWORD PTR [r8],xmm0
  21bc14:	5b                   	pop    rbx
  21bc15:	41 5e                	pop    r14
  21bc17:	41 5f                	pop    r15
  21bc19:	c3                   	ret    
                if (amt_read == 0) return index;
  21bc1a:	66 41 c7 00 00 00    	mov    WORD PTR [r8],0x0
  21bc20:	0f b7 44 24 f0       	movzx  eax,WORD PTR [rsp-0x10]
  21bc25:	66 41 89 40 06       	mov    WORD PTR [r8+0x6],ax
  21bc2a:	8b 44 24 ec          	mov    eax,DWORD PTR [rsp-0x14]
  21bc2e:	e9 7a ff ff ff       	jmp    21bbad <File_read+0x9d>
  21bc33:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21bc3a:	84 00 00 00 00 00 

000000000021bc40 <FileInStream_readFn>:
    fn readFn(in_stream: *Stream, buffer: []u8) Error!usize {
  21bc40:	53                   	push   rbx
  21bc41:	48 83 ec 10          	sub    rsp,0x10
  21bc45:	48 89 fb             	mov    rbx,rdi
        return self.file.read(buffer);
  21bc48:	48 8b 76 f8          	mov    rsi,QWORD PTR [rsi-0x8]
  21bc4c:	48 89 e7             	mov    rdi,rsp
  21bc4f:	e8 bc fe ff ff       	call   21bb10 <File_read>
  21bc54:	c5 f8 10 04 24       	vmovups xmm0,XMMWORD PTR [rsp]
  21bc59:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  21bc5d:	48 89 d8             	mov    rax,rbx
  21bc60:	48 83 c4 10          	add    rsp,0x10
  21bc64:	5b                   	pop    rbx
  21bc65:	c3                   	ret    
  21bc66:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  21bc6d:	00 00 00 

000000000021bc70 <Allocator_alignedRealloc.53>:
    pub fn alignedRealloc(self: *Allocator, comptime T: type, comptime alignment: u29, old_mem: []align(alignment) T, n: usize) ![]align(alignment) T {
  21bc70:	41 56                	push   r14
  21bc72:	53                   	push   rbx
  21bc73:	48 81 ec 88 00 00 00 	sub    rsp,0x88
  21bc7a:	48 89 fb             	mov    rbx,rdi
        if (old_mem.len == 0) {
  21bc7d:	48 8b 42 08          	mov    rax,QWORD PTR [rdx+0x8]
  21bc81:	48 85 c0             	test   rax,rax
  21bc84:	74 54                	je     21bcda <Allocator_alignedRealloc.53+0x6a>
        if (n == 0) {
  21bc86:	48 85 c9             	test   rcx,rcx
  21bc89:	0f 84 9b 00 00 00    	je     21bd2a <Allocator_alignedRealloc.53+0xba>
        const old_byte_slice = @sliceToBytes(old_mem);
  21bc8f:	48 8b 12             	mov    rdx,QWORD PTR [rdx]
  21bc92:	48 6b c0 38          	imul   rax,rax,0x38
  21bc96:	48 89 54 24 38       	mov    QWORD PTR [rsp+0x38],rdx
  21bc9b:	48 89 44 24 40       	mov    QWORD PTR [rsp+0x40],rax
  21bca0:	ba 38 00 00 00       	mov    edx,0x38
    return if (@mulWithOverflow(T, a, b, &answer)) error.Overflow else answer;
  21bca5:	48 89 c8             	mov    rax,rcx
  21bca8:	48 f7 e2             	mul    rdx
  21bcab:	0f 81 c2 00 00 00    	jno    21bd73 <Allocator_alignedRealloc.53+0x103>
  21bcb1:	48 8d 0d 48 48 fe ff 	lea    rcx,[rip+0xfffffffffffe4848]        # 200500 <__unnamed_52>
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  21bcb8:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  21bcbc:	0f 84 cc 00 00 00    	je     21bd8e <Allocator_alignedRealloc.53+0x11e>
  21bcc2:	48 8b 05 67 c3 fe ff 	mov    rax,QWORD PTR [rip+0xfffffffffffec367]        # 208030 <__unnamed_75+0x10>
  21bcc9:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  21bccd:	c5 f8 10 05 4b c3 fe 	vmovups xmm0,XMMWORD PTR [rip+0xfffffffffffec34b]        # 208020 <__unnamed_75>
  21bcd4:	ff 
  21bcd5:	e9 8a 00 00 00       	jmp    21bd64 <Allocator_alignedRealloc.53+0xf4>
        if (n == 0) {
  21bcda:	48 85 c9             	test   rcx,rcx
  21bcdd:	0f 84 f8 00 00 00    	je     21bddb <Allocator_alignedRealloc.53+0x16b>
  21bce3:	ba 38 00 00 00       	mov    edx,0x38
  21bce8:	48 89 c8             	mov    rax,rcx
  21bceb:	48 f7 e2             	mul    rdx
  21bcee:	0f 81 08 01 00 00    	jno    21bdfc <Allocator_alignedRealloc.53+0x18c>
  21bcf4:	48 8d 0d 05 48 fe ff 	lea    rcx,[rip+0xfffffffffffe4805]        # 200500 <__unnamed_52>
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  21bcfb:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  21bcff:	0f 84 12 01 00 00    	je     21be17 <Allocator_alignedRealloc.53+0x1a7>
  21bd05:	0f b7 05 1a c3 fe ff 	movzx  eax,WORD PTR [rip+0xfffffffffffec31a]        # 208026 <__unnamed_75+0x6>
  21bd0c:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  21bd11:	8b 05 0b c3 fe ff    	mov    eax,DWORD PTR [rip+0xfffffffffffec30b]        # 208022 <__unnamed_75+0x2>
  21bd17:	89 04 24             	mov    DWORD PTR [rsp],eax
  21bd1a:	48 89 e0             	mov    rax,rsp
  21bd1d:	66 b9 01 00          	mov    cx,0x1
  21bd21:	31 f6                	xor    esi,esi
  21bd23:	31 d2                	xor    edx,edx
  21bd25:	e9 a9 01 00 00       	jmp    21bed3 <Allocator_alignedRealloc.53+0x263>
        const bytes = @sliceToBytes(memory);
  21bd2a:	48 6b c0 38          	imul   rax,rax,0x38
        if (bytes.len == 0) return;
  21bd2e:	48 85 c0             	test   rax,rax
  21bd31:	74 1e                	je     21bd51 <Allocator_alignedRealloc.53+0xe1>
        const bytes = @sliceToBytes(memory);
  21bd33:	48 8b 0a             	mov    rcx,QWORD PTR [rdx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  21bd36:	48 8b 56 10          	mov    rdx,QWORD PTR [rsi+0x10]
  21bd3a:	48 89 4c 24 08       	mov    QWORD PTR [rsp+0x8],rcx
  21bd3f:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  21bd44:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  21bd49:	48 89 f7             	mov    rdi,rsi
  21bd4c:	48 89 c6             	mov    rsi,rax
  21bd4f:	ff d2                	call   rdx
            return ([*]align(alignment) T)(undefined)[0..0];
  21bd51:	48 8b 05 c0 c2 fe ff 	mov    rax,QWORD PTR [rip+0xfffffffffffec2c0]        # 208018 <__unnamed_76+0x10>
  21bd58:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  21bd5c:	c5 f8 10 05 a4 c2 fe 	vmovups xmm0,XMMWORD PTR [rip+0xfffffffffffec2a4]        # 208008 <__unnamed_76>
  21bd63:	ff 
  21bd64:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  21bd68:	48 81 c4 88 00 00 00 	add    rsp,0x88
  21bd6f:	5b                   	pop    rbx
  21bd70:	41 5e                	pop    r14
  21bd72:	c3                   	ret    
  21bd73:	48 8d 4c 24 08       	lea    rcx,[rsp+0x8]
  21bd78:	66 c7 44 24 08 00 00 	mov    WORD PTR [rsp+0x8],0x0
  21bd7f:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  21bd84:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  21bd88:	0f 85 34 ff ff ff    	jne    21bcc2 <Allocator_alignedRealloc.53+0x52>
  21bd8e:	4c 8b 71 08          	mov    r14,QWORD PTR [rcx+0x8]
  21bd92:	48 8d 7c 24 58       	lea    rdi,[rsp+0x58]
  21bd97:	48 8d 54 24 38       	lea    rdx,[rsp+0x38]
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  21bd9c:	41 b8 01 00 00 00    	mov    r8d,0x1
  21bda2:	4c 89 f1             	mov    rcx,r14
  21bda5:	ff 56 08             	call   QWORD PTR [rsi+0x8]
  21bda8:	0f b7 44 24 58       	movzx  eax,WORD PTR [rsp+0x58]
  21bdad:	66 85 c0             	test   ax,ax
  21bdb0:	0f 84 97 00 00 00    	je     21be4d <Allocator_alignedRealloc.53+0x1dd>
  21bdb6:	66 89 03             	mov    WORD PTR [rbx],ax
  21bdb9:	48 8b 84 24 80 00 00 	mov    rax,QWORD PTR [rsp+0x80]
  21bdc0:	00 
  21bdc1:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  21bdc5:	c5 f8 10 44 24 72    	vmovups xmm0,XMMWORD PTR [rsp+0x72]
  21bdcb:	c5 f8 11 43 02       	vmovups XMMWORD PTR [rbx+0x2],xmm0
  21bdd0:	48 81 c4 88 00 00 00 	add    rsp,0x88
  21bdd7:	5b                   	pop    rbx
  21bdd8:	41 5e                	pop    r14
  21bdda:	c3                   	ret    
  21bddb:	48 89 e0             	mov    rax,rsp
            return ([*]align(alignment) T)(undefined)[0..0];
  21bdde:	0f b7 0d 29 c2 fe ff 	movzx  ecx,WORD PTR [rip+0xfffffffffffec229]        # 20800e <__unnamed_76+0x6>
  21bde5:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  21bdea:	8b 0d 1a c2 fe ff    	mov    ecx,DWORD PTR [rip+0xfffffffffffec21a]        # 20800a <__unnamed_76+0x2>
  21bdf0:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  21bdf3:	31 c9                	xor    ecx,ecx
  21bdf5:	31 d2                	xor    edx,edx
  21bdf7:	e9 d7 00 00 00       	jmp    21bed3 <Allocator_alignedRealloc.53+0x263>
  21bdfc:	48 8d 4c 24 48       	lea    rcx,[rsp+0x48]
  21be01:	66 c7 44 24 48 00 00 	mov    WORD PTR [rsp+0x48],0x0
  21be08:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  21be0d:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  21be11:	0f 85 ee fe ff ff    	jne    21bd05 <Allocator_alignedRealloc.53+0x95>
  21be17:	4c 8b 71 08          	mov    r14,QWORD PTR [rcx+0x8]
  21be1b:	48 8d 7c 24 08       	lea    rdi,[rsp+0x8]
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  21be20:	b9 01 00 00 00       	mov    ecx,0x1
  21be25:	4c 89 f2             	mov    rdx,r14
  21be28:	ff 16                	call   QWORD PTR [rsi]
  21be2a:	0f b7 4c 24 08       	movzx  ecx,WORD PTR [rsp+0x8]
  21be2f:	66 85 c9             	test   cx,cx
  21be32:	74 67                	je     21be9b <Allocator_alignedRealloc.53+0x22b>
  21be34:	0f b7 44 24 36       	movzx  eax,WORD PTR [rsp+0x36]
  21be39:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  21be3e:	48 89 e0             	mov    rax,rsp
  21be41:	8b 54 24 32          	mov    edx,DWORD PTR [rsp+0x32]
  21be45:	89 14 24             	mov    DWORD PTR [rsp],edx
  21be48:	e9 86 00 00 00       	jmp    21bed3 <Allocator_alignedRealloc.53+0x263>
        assert(byte_slice.len == byte_count);
  21be4d:	4c 39 74 24 68       	cmp    QWORD PTR [rsp+0x68],r14
    if (!ok) {
  21be52:	0f 85 9e 00 00 00    	jne    21bef6 <Allocator_alignedRealloc.53+0x286>
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  21be58:	49 c1 ee 03          	shr    r14,0x3
  21be5c:	48 b8 93 24 49 92 24 	movabs rax,0x2492492492492493
  21be63:	49 92 24 
  21be66:	4c 89 f2             	mov    rdx,r14
  21be69:	c4 e2 f3 f6 c0       	mulx   rax,rcx,rax
  21be6e:	66 c7 03 00 00       	mov    WORD PTR [rbx],0x0
  21be73:	0f b7 4c 24 2a       	movzx  ecx,WORD PTR [rsp+0x2a]
  21be78:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  21be7c:	48 8b 4c 24 60       	mov    rcx,QWORD PTR [rsp+0x60]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  21be81:	8b 54 24 26          	mov    edx,DWORD PTR [rsp+0x26]
  21be85:	89 53 02             	mov    DWORD PTR [rbx+0x2],edx
  21be88:	48 89 4b 08          	mov    QWORD PTR [rbx+0x8],rcx
  21be8c:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  21be90:	48 81 c4 88 00 00 00 	add    rsp,0x88
  21be97:	5b                   	pop    rbx
  21be98:	41 5e                	pop    r14
  21be9a:	c3                   	ret    
        assert(byte_slice.len == byte_count);
  21be9b:	4c 39 74 24 18       	cmp    QWORD PTR [rsp+0x18],r14
  21bea0:	75 54                	jne    21bef6 <Allocator_alignedRealloc.53+0x286>
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  21bea2:	48 8b 74 24 10       	mov    rsi,QWORD PTR [rsp+0x10]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  21bea7:	49 c1 ee 03          	shr    r14,0x3
  21beab:	48 b8 93 24 49 92 24 	movabs rax,0x2492492492492493
  21beb2:	49 92 24 
  21beb5:	4c 89 f2             	mov    rdx,r14
  21beb8:	c4 e2 fb f6 d0       	mulx   rdx,rax,rax
  21bebd:	48 89 e0             	mov    rax,rsp
  21bec0:	8b 4c 24 2c          	mov    ecx,DWORD PTR [rsp+0x2c]
  21bec4:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  21bec7:	0f b7 4c 24 30       	movzx  ecx,WORD PTR [rsp+0x30]
  21becc:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  21bed1:	31 c9                	xor    ecx,ecx
            return self.alignedAlloc(T, alignment, n);
  21bed3:	66 89 0b             	mov    WORD PTR [rbx],cx
  21bed6:	0f b7 48 04          	movzx  ecx,WORD PTR [rax+0x4]
  21beda:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  21bede:	8b 00                	mov    eax,DWORD PTR [rax]
  21bee0:	89 43 02             	mov    DWORD PTR [rbx+0x2],eax
  21bee3:	48 89 73 08          	mov    QWORD PTR [rbx+0x8],rsi
  21bee7:	48 89 53 10          	mov    QWORD PTR [rbx+0x10],rdx
  21beeb:	48 81 c4 88 00 00 00 	add    rsp,0x88
  21bef2:	5b                   	pop    rbx
  21bef3:	41 5e                	pop    r14
  21bef5:	c3                   	ret    
            @panic("assertion failure");
  21bef6:	e8 e5 86 ff ff       	call   2145e0 <panic>
  21befb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

000000000021bf00 <Allocator_alignedRealloc.56>:
    pub fn alignedRealloc(self: *Allocator, comptime T: type, comptime alignment: u29, old_mem: []align(alignment) T, n: usize) ![]align(alignment) T {
  21bf00:	41 56                	push   r14
  21bf02:	53                   	push   rbx
  21bf03:	48 81 ec 88 00 00 00 	sub    rsp,0x88
  21bf0a:	48 89 fb             	mov    rbx,rdi
        if (old_mem.len == 0) {
  21bf0d:	48 8b 42 08          	mov    rax,QWORD PTR [rdx+0x8]
  21bf11:	48 85 c0             	test   rax,rax
  21bf14:	74 5e                	je     21bf74 <Allocator_alignedRealloc.56+0x74>
        if (n == 0) {
  21bf16:	48 85 c9             	test   rcx,rcx
  21bf19:	0f 84 a6 00 00 00    	je     21bfc5 <Allocator_alignedRealloc.56+0xc5>
        const old_byte_slice = @sliceToBytes(old_mem);
  21bf1f:	48 8b 12             	mov    rdx,QWORD PTR [rdx]
  21bf22:	48 c1 e0 04          	shl    rax,0x4
  21bf26:	48 89 54 24 38       	mov    QWORD PTR [rsp+0x38],rdx
  21bf2b:	48 89 44 24 40       	mov    QWORD PTR [rsp+0x40],rax
  21bf30:	ba 10 00 00 00       	mov    edx,0x10
  21bf35:	48 89 c8             	mov    rax,rcx
  21bf38:	48 f7 e2             	mul    rdx
  21bf3b:	0f 81 ca 00 00 00    	jno    21c00b <Allocator_alignedRealloc.56+0x10b>
  21bf41:	48 8d 0d b8 45 fe ff 	lea    rcx,[rip+0xfffffffffffe45b8]        # 200500 <__unnamed_52>
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  21bf48:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  21bf4c:	0f 84 d4 00 00 00    	je     21c026 <Allocator_alignedRealloc.56+0x126>
  21bf52:	48 8b 05 07 c1 fe ff 	mov    rax,QWORD PTR [rip+0xfffffffffffec107]        # 208060 <__unnamed_77+0x10>
  21bf59:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  21bf5d:	c5 f8 10 05 eb c0 fe 	vmovups xmm0,XMMWORD PTR [rip+0xfffffffffffec0eb]        # 208050 <__unnamed_77>
  21bf64:	ff 
  21bf65:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  21bf69:	48 81 c4 88 00 00 00 	add    rsp,0x88
  21bf70:	5b                   	pop    rbx
  21bf71:	41 5e                	pop    r14
  21bf73:	c3                   	ret    
        if (n == 0) {
  21bf74:	48 85 c9             	test   rcx,rcx
  21bf77:	0f 84 f6 00 00 00    	je     21c073 <Allocator_alignedRealloc.56+0x173>
  21bf7d:	ba 10 00 00 00       	mov    edx,0x10
  21bf82:	48 89 c8             	mov    rax,rcx
  21bf85:	48 f7 e2             	mul    rdx
  21bf88:	0f 81 07 01 00 00    	jno    21c095 <Allocator_alignedRealloc.56+0x195>
  21bf8e:	48 8d 0d 6b 45 fe ff 	lea    rcx,[rip+0xfffffffffffe456b]        # 200500 <__unnamed_52>
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  21bf95:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  21bf99:	0f 84 11 01 00 00    	je     21c0b0 <Allocator_alignedRealloc.56+0x1b0>
  21bf9f:	0f b7 05 b0 c0 fe ff 	movzx  eax,WORD PTR [rip+0xfffffffffffec0b0]        # 208056 <__unnamed_77+0x6>
  21bfa6:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  21bfab:	8b 05 a1 c0 fe ff    	mov    eax,DWORD PTR [rip+0xfffffffffffec0a1]        # 208052 <__unnamed_77+0x2>
  21bfb1:	89 04 24             	mov    DWORD PTR [rsp],eax
  21bfb4:	48 89 e0             	mov    rax,rsp
  21bfb7:	66 b9 01 00          	mov    cx,0x1
  21bfbb:	31 d2                	xor    edx,edx
  21bfbd:	45 31 f6             	xor    r14d,r14d
  21bfc0:	e9 6f 01 00 00       	jmp    21c134 <Allocator_alignedRealloc.56+0x234>
        const bytes = @sliceToBytes(memory);
  21bfc5:	48 c1 e0 04          	shl    rax,0x4
        if (bytes.len == 0) return;
  21bfc9:	74 1e                	je     21bfe9 <Allocator_alignedRealloc.56+0xe9>
        const bytes = @sliceToBytes(memory);
  21bfcb:	48 8b 0a             	mov    rcx,QWORD PTR [rdx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  21bfce:	48 8b 56 10          	mov    rdx,QWORD PTR [rsi+0x10]
  21bfd2:	48 89 4c 24 08       	mov    QWORD PTR [rsp+0x8],rcx
  21bfd7:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  21bfdc:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  21bfe1:	48 89 f7             	mov    rdi,rsi
  21bfe4:	48 89 c6             	mov    rsi,rax
  21bfe7:	ff d2                	call   rdx
            return ([*]align(alignment) T)(undefined)[0..0];
  21bfe9:	48 8b 05 58 c0 fe ff 	mov    rax,QWORD PTR [rip+0xfffffffffffec058]        # 208048 <__unnamed_78+0x10>
  21bff0:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  21bff4:	c5 f8 10 05 3c c0 fe 	vmovups xmm0,XMMWORD PTR [rip+0xfffffffffffec03c]        # 208038 <__unnamed_78>
  21bffb:	ff 
  21bffc:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  21c000:	48 81 c4 88 00 00 00 	add    rsp,0x88
  21c007:	5b                   	pop    rbx
  21c008:	41 5e                	pop    r14
  21c00a:	c3                   	ret    
  21c00b:	48 8d 4c 24 08       	lea    rcx,[rsp+0x8]
  21c010:	66 c7 44 24 08 00 00 	mov    WORD PTR [rsp+0x8],0x0
  21c017:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  21c01c:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  21c020:	0f 85 2c ff ff ff    	jne    21bf52 <Allocator_alignedRealloc.56+0x52>
  21c026:	4c 8b 71 08          	mov    r14,QWORD PTR [rcx+0x8]
  21c02a:	48 8d 7c 24 58       	lea    rdi,[rsp+0x58]
  21c02f:	48 8d 54 24 38       	lea    rdx,[rsp+0x38]
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  21c034:	41 b8 08 00 00 00    	mov    r8d,0x8
  21c03a:	4c 89 f1             	mov    rcx,r14
  21c03d:	ff 56 08             	call   QWORD PTR [rsi+0x8]
  21c040:	0f b7 44 24 58       	movzx  eax,WORD PTR [rsp+0x58]
  21c045:	66 85 c0             	test   ax,ax
  21c048:	0f 84 95 00 00 00    	je     21c0e3 <Allocator_alignedRealloc.56+0x1e3>
  21c04e:	66 89 03             	mov    WORD PTR [rbx],ax
  21c051:	48 8b 84 24 80 00 00 	mov    rax,QWORD PTR [rsp+0x80]
  21c058:	00 
  21c059:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  21c05d:	c5 f8 10 44 24 72    	vmovups xmm0,XMMWORD PTR [rsp+0x72]
  21c063:	c5 f8 11 43 02       	vmovups XMMWORD PTR [rbx+0x2],xmm0
  21c068:	48 81 c4 88 00 00 00 	add    rsp,0x88
  21c06f:	5b                   	pop    rbx
  21c070:	41 5e                	pop    r14
  21c072:	c3                   	ret    
  21c073:	48 89 e0             	mov    rax,rsp
            return ([*]align(alignment) T)(undefined)[0..0];
  21c076:	0f b7 0d c1 bf fe ff 	movzx  ecx,WORD PTR [rip+0xfffffffffffebfc1]        # 20803e <__unnamed_78+0x6>
  21c07d:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  21c082:	8b 0d b2 bf fe ff    	mov    ecx,DWORD PTR [rip+0xfffffffffffebfb2]        # 20803a <__unnamed_78+0x2>
  21c088:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  21c08b:	31 c9                	xor    ecx,ecx
  21c08d:	45 31 f6             	xor    r14d,r14d
  21c090:	e9 9f 00 00 00       	jmp    21c134 <Allocator_alignedRealloc.56+0x234>
  21c095:	48 8d 4c 24 48       	lea    rcx,[rsp+0x48]
  21c09a:	66 c7 44 24 48 00 00 	mov    WORD PTR [rsp+0x48],0x0
  21c0a1:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  21c0a6:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  21c0aa:	0f 85 ef fe ff ff    	jne    21bf9f <Allocator_alignedRealloc.56+0x9f>
  21c0b0:	4c 8b 71 08          	mov    r14,QWORD PTR [rcx+0x8]
  21c0b4:	48 8d 7c 24 08       	lea    rdi,[rsp+0x8]
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  21c0b9:	b9 08 00 00 00       	mov    ecx,0x8
  21c0be:	4c 89 f2             	mov    rdx,r14
  21c0c1:	ff 16                	call   QWORD PTR [rsi]
  21c0c3:	0f b7 4c 24 08       	movzx  ecx,WORD PTR [rsp+0x8]
  21c0c8:	66 85 c9             	test   cx,cx
  21c0cb:	74 41                	je     21c10e <Allocator_alignedRealloc.56+0x20e>
  21c0cd:	0f b7 44 24 36       	movzx  eax,WORD PTR [rsp+0x36]
  21c0d2:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  21c0d7:	48 89 e0             	mov    rax,rsp
  21c0da:	8b 54 24 32          	mov    edx,DWORD PTR [rsp+0x32]
  21c0de:	89 14 24             	mov    DWORD PTR [rsp],edx
  21c0e1:	eb 51                	jmp    21c134 <Allocator_alignedRealloc.56+0x234>
        assert(byte_slice.len == byte_count);
  21c0e3:	4c 39 74 24 68       	cmp    QWORD PTR [rsp+0x68],r14
    if (!ok) {
  21c0e8:	75 6d                	jne    21c157 <Allocator_alignedRealloc.56+0x257>
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  21c0ea:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  21c0ef:	66 c7 03 00 00       	mov    WORD PTR [rbx],0x0
  21c0f4:	0f b7 4c 24 2a       	movzx  ecx,WORD PTR [rsp+0x2a]
  21c0f9:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  21c0fd:	49 c1 ee 04          	shr    r14,0x4
  21c101:	8b 4c 24 26          	mov    ecx,DWORD PTR [rsp+0x26]
  21c105:	89 4b 02             	mov    DWORD PTR [rbx+0x2],ecx
  21c108:	48 89 43 08          	mov    QWORD PTR [rbx+0x8],rax
  21c10c:	eb 3a                	jmp    21c148 <Allocator_alignedRealloc.56+0x248>
        assert(byte_slice.len == byte_count);
  21c10e:	4c 39 74 24 18       	cmp    QWORD PTR [rsp+0x18],r14
  21c113:	75 42                	jne    21c157 <Allocator_alignedRealloc.56+0x257>
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  21c115:	48 8b 54 24 10       	mov    rdx,QWORD PTR [rsp+0x10]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  21c11a:	49 c1 ee 04          	shr    r14,0x4
  21c11e:	48 89 e0             	mov    rax,rsp
  21c121:	8b 4c 24 2c          	mov    ecx,DWORD PTR [rsp+0x2c]
  21c125:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  21c128:	0f b7 4c 24 30       	movzx  ecx,WORD PTR [rsp+0x30]
  21c12d:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  21c132:	31 c9                	xor    ecx,ecx
            return self.alignedAlloc(T, alignment, n);
  21c134:	66 89 0b             	mov    WORD PTR [rbx],cx
  21c137:	0f b7 48 04          	movzx  ecx,WORD PTR [rax+0x4]
  21c13b:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  21c13f:	8b 00                	mov    eax,DWORD PTR [rax]
  21c141:	89 43 02             	mov    DWORD PTR [rbx+0x2],eax
  21c144:	48 89 53 08          	mov    QWORD PTR [rbx+0x8],rdx
  21c148:	4c 89 73 10          	mov    QWORD PTR [rbx+0x10],r14
  21c14c:	48 81 c4 88 00 00 00 	add    rsp,0x88
  21c153:	5b                   	pop    rbx
  21c154:	41 5e                	pop    r14
  21c156:	c3                   	ret    
            @panic("assertion failure");
  21c157:	e8 84 84 ff ff       	call   2145e0 <panic>
  21c15c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

000000000021c160 <Allocator_alignedRealloc.59>:
    pub fn alignedRealloc(self: *Allocator, comptime T: type, comptime alignment: u29, old_mem: []align(alignment) T, n: usize) ![]align(alignment) T {
  21c160:	41 56                	push   r14
  21c162:	53                   	push   rbx
  21c163:	48 81 ec 88 00 00 00 	sub    rsp,0x88
  21c16a:	48 89 fb             	mov    rbx,rdi
        if (old_mem.len == 0) {
  21c16d:	48 8b 42 08          	mov    rax,QWORD PTR [rdx+0x8]
  21c171:	48 85 c0             	test   rax,rax
  21c174:	74 62                	je     21c1d8 <Allocator_alignedRealloc.59+0x78>
        if (n == 0) {
  21c176:	48 85 c9             	test   rcx,rcx
  21c179:	0f 84 a9 00 00 00    	je     21c228 <Allocator_alignedRealloc.59+0xc8>
        const old_byte_slice = @sliceToBytes(old_mem);
  21c17f:	48 8b 12             	mov    rdx,QWORD PTR [rdx]
  21c182:	48 c1 e0 03          	shl    rax,0x3
  21c186:	48 8d 04 80          	lea    rax,[rax+rax*4]
  21c18a:	48 89 54 24 38       	mov    QWORD PTR [rsp+0x38],rdx
  21c18f:	48 89 44 24 40       	mov    QWORD PTR [rsp+0x40],rax
  21c194:	ba 28 00 00 00       	mov    edx,0x28
  21c199:	48 89 c8             	mov    rax,rcx
  21c19c:	48 f7 e2             	mul    rdx
  21c19f:	0f 81 d0 00 00 00    	jno    21c275 <Allocator_alignedRealloc.59+0x115>
  21c1a5:	48 8d 0d 54 43 fe ff 	lea    rcx,[rip+0xfffffffffffe4354]        # 200500 <__unnamed_52>
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  21c1ac:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  21c1b0:	0f 84 da 00 00 00    	je     21c290 <Allocator_alignedRealloc.59+0x130>
  21c1b6:	48 8b 05 d3 be fe ff 	mov    rax,QWORD PTR [rip+0xfffffffffffebed3]        # 208090 <__unnamed_79+0x10>
  21c1bd:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  21c1c1:	c5 f8 10 05 b7 be fe 	vmovups xmm0,XMMWORD PTR [rip+0xfffffffffffebeb7]        # 208080 <__unnamed_79>
  21c1c8:	ff 
  21c1c9:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  21c1cd:	48 81 c4 88 00 00 00 	add    rsp,0x88
  21c1d4:	5b                   	pop    rbx
  21c1d5:	41 5e                	pop    r14
  21c1d7:	c3                   	ret    
        if (n == 0) {
  21c1d8:	48 85 c9             	test   rcx,rcx
  21c1db:	0f 84 fc 00 00 00    	je     21c2dd <Allocator_alignedRealloc.59+0x17d>
  21c1e1:	ba 28 00 00 00       	mov    edx,0x28
  21c1e6:	48 89 c8             	mov    rax,rcx
  21c1e9:	48 f7 e2             	mul    rdx
  21c1ec:	0f 81 0c 01 00 00    	jno    21c2fe <Allocator_alignedRealloc.59+0x19e>
  21c1f2:	48 8d 0d 07 43 fe ff 	lea    rcx,[rip+0xfffffffffffe4307]        # 200500 <__unnamed_52>
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  21c1f9:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  21c1fd:	0f 84 16 01 00 00    	je     21c319 <Allocator_alignedRealloc.59+0x1b9>
  21c203:	0f b7 05 7c be fe ff 	movzx  eax,WORD PTR [rip+0xfffffffffffebe7c]        # 208086 <__unnamed_79+0x6>
  21c20a:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  21c20f:	8b 05 6d be fe ff    	mov    eax,DWORD PTR [rip+0xfffffffffffebe6d]        # 208082 <__unnamed_79+0x2>
  21c215:	89 04 24             	mov    DWORD PTR [rsp],eax
  21c218:	48 89 e0             	mov    rax,rsp
  21c21b:	66 b9 01 00          	mov    cx,0x1
  21c21f:	31 f6                	xor    esi,esi
  21c221:	31 d2                	xor    edx,edx
  21c223:	e9 9d 01 00 00       	jmp    21c3c5 <Allocator_alignedRealloc.59+0x265>
        const bytes = @sliceToBytes(memory);
  21c228:	48 c1 e0 03          	shl    rax,0x3
  21c22c:	48 8d 04 80          	lea    rax,[rax+rax*4]
        if (bytes.len == 0) return;
  21c230:	48 85 c0             	test   rax,rax
  21c233:	74 1e                	je     21c253 <Allocator_alignedRealloc.59+0xf3>
        const bytes = @sliceToBytes(memory);
  21c235:	48 8b 0a             	mov    rcx,QWORD PTR [rdx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  21c238:	48 8b 56 10          	mov    rdx,QWORD PTR [rsi+0x10]
  21c23c:	48 89 4c 24 08       	mov    QWORD PTR [rsp+0x8],rcx
  21c241:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  21c246:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  21c24b:	48 89 f7             	mov    rdi,rsi
  21c24e:	48 89 c6             	mov    rsi,rax
  21c251:	ff d2                	call   rdx
            return ([*]align(alignment) T)(undefined)[0..0];
  21c253:	48 8b 05 1e be fe ff 	mov    rax,QWORD PTR [rip+0xfffffffffffebe1e]        # 208078 <__unnamed_80+0x10>
  21c25a:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  21c25e:	c5 f8 10 05 02 be fe 	vmovups xmm0,XMMWORD PTR [rip+0xfffffffffffebe02]        # 208068 <__unnamed_80>
  21c265:	ff 
  21c266:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  21c26a:	48 81 c4 88 00 00 00 	add    rsp,0x88
  21c271:	5b                   	pop    rbx
  21c272:	41 5e                	pop    r14
  21c274:	c3                   	ret    
  21c275:	48 8d 4c 24 08       	lea    rcx,[rsp+0x8]
  21c27a:	66 c7 44 24 08 00 00 	mov    WORD PTR [rsp+0x8],0x0
  21c281:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  21c286:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  21c28a:	0f 85 26 ff ff ff    	jne    21c1b6 <Allocator_alignedRealloc.59+0x56>
  21c290:	4c 8b 71 08          	mov    r14,QWORD PTR [rcx+0x8]
  21c294:	48 8d 7c 24 58       	lea    rdi,[rsp+0x58]
  21c299:	48 8d 54 24 38       	lea    rdx,[rsp+0x38]
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  21c29e:	41 b8 08 00 00 00    	mov    r8d,0x8
  21c2a4:	4c 89 f1             	mov    rcx,r14
  21c2a7:	ff 56 08             	call   QWORD PTR [rsi+0x8]
  21c2aa:	0f b7 44 24 58       	movzx  eax,WORD PTR [rsp+0x58]
  21c2af:	66 85 c0             	test   ax,ax
  21c2b2:	0f 84 94 00 00 00    	je     21c34c <Allocator_alignedRealloc.59+0x1ec>
  21c2b8:	66 89 03             	mov    WORD PTR [rbx],ax
  21c2bb:	48 8b 84 24 80 00 00 	mov    rax,QWORD PTR [rsp+0x80]
  21c2c2:	00 
  21c2c3:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  21c2c7:	c5 f8 10 44 24 72    	vmovups xmm0,XMMWORD PTR [rsp+0x72]
  21c2cd:	c5 f8 11 43 02       	vmovups XMMWORD PTR [rbx+0x2],xmm0
  21c2d2:	48 81 c4 88 00 00 00 	add    rsp,0x88
  21c2d9:	5b                   	pop    rbx
  21c2da:	41 5e                	pop    r14
  21c2dc:	c3                   	ret    
  21c2dd:	48 89 e0             	mov    rax,rsp
            return ([*]align(alignment) T)(undefined)[0..0];
  21c2e0:	0f b7 0d 87 bd fe ff 	movzx  ecx,WORD PTR [rip+0xfffffffffffebd87]        # 20806e <__unnamed_80+0x6>
  21c2e7:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  21c2ec:	8b 0d 78 bd fe ff    	mov    ecx,DWORD PTR [rip+0xfffffffffffebd78]        # 20806a <__unnamed_80+0x2>
  21c2f2:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  21c2f5:	31 c9                	xor    ecx,ecx
  21c2f7:	31 d2                	xor    edx,edx
  21c2f9:	e9 c7 00 00 00       	jmp    21c3c5 <Allocator_alignedRealloc.59+0x265>
  21c2fe:	48 8d 4c 24 48       	lea    rcx,[rsp+0x48]
  21c303:	66 c7 44 24 48 00 00 	mov    WORD PTR [rsp+0x48],0x0
  21c30a:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  21c30f:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  21c313:	0f 85 ea fe ff ff    	jne    21c203 <Allocator_alignedRealloc.59+0xa3>
  21c319:	4c 8b 71 08          	mov    r14,QWORD PTR [rcx+0x8]
  21c31d:	48 8d 7c 24 08       	lea    rdi,[rsp+0x8]
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  21c322:	b9 08 00 00 00       	mov    ecx,0x8
  21c327:	4c 89 f2             	mov    rdx,r14
  21c32a:	ff 16                	call   QWORD PTR [rsi]
  21c32c:	0f b7 4c 24 08       	movzx  ecx,WORD PTR [rsp+0x8]
  21c331:	66 85 c9             	test   cx,cx
  21c334:	74 57                	je     21c38d <Allocator_alignedRealloc.59+0x22d>
  21c336:	0f b7 44 24 36       	movzx  eax,WORD PTR [rsp+0x36]
  21c33b:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  21c340:	48 89 e0             	mov    rax,rsp
  21c343:	8b 54 24 32          	mov    edx,DWORD PTR [rsp+0x32]
  21c347:	89 14 24             	mov    DWORD PTR [rsp],edx
  21c34a:	eb 79                	jmp    21c3c5 <Allocator_alignedRealloc.59+0x265>
        assert(byte_slice.len == byte_count);
  21c34c:	4c 39 74 24 68       	cmp    QWORD PTR [rsp+0x68],r14
    if (!ok) {
  21c351:	0f 85 91 00 00 00    	jne    21c3e8 <Allocator_alignedRealloc.59+0x288>
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  21c357:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  21c35c:	48 b9 cd cc cc cc cc 	movabs rcx,0xcccccccccccccccd
  21c363:	cc cc cc 
  21c366:	4c 89 f2             	mov    rdx,r14
  21c369:	c4 e2 f3 f6 d1       	mulx   rdx,rcx,rcx
  21c36e:	66 c7 03 00 00       	mov    WORD PTR [rbx],0x0
  21c373:	0f b7 4c 24 2a       	movzx  ecx,WORD PTR [rsp+0x2a]
  21c378:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  21c37c:	48 c1 ea 05          	shr    rdx,0x5
  21c380:	8b 4c 24 26          	mov    ecx,DWORD PTR [rsp+0x26]
  21c384:	89 4b 02             	mov    DWORD PTR [rbx+0x2],ecx
  21c387:	48 89 43 08          	mov    QWORD PTR [rbx+0x8],rax
  21c38b:	eb 4c                	jmp    21c3d9 <Allocator_alignedRealloc.59+0x279>
        assert(byte_slice.len == byte_count);
  21c38d:	4c 39 74 24 18       	cmp    QWORD PTR [rsp+0x18],r14
  21c392:	75 54                	jne    21c3e8 <Allocator_alignedRealloc.59+0x288>
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  21c394:	48 8b 74 24 10       	mov    rsi,QWORD PTR [rsp+0x10]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  21c399:	48 b8 cd cc cc cc cc 	movabs rax,0xcccccccccccccccd
  21c3a0:	cc cc cc 
  21c3a3:	4c 89 f2             	mov    rdx,r14
  21c3a6:	c4 e2 fb f6 d0       	mulx   rdx,rax,rax
  21c3ab:	48 c1 ea 05          	shr    rdx,0x5
  21c3af:	48 89 e0             	mov    rax,rsp
  21c3b2:	8b 4c 24 2c          	mov    ecx,DWORD PTR [rsp+0x2c]
  21c3b6:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  21c3b9:	0f b7 4c 24 30       	movzx  ecx,WORD PTR [rsp+0x30]
  21c3be:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  21c3c3:	31 c9                	xor    ecx,ecx
            return self.alignedAlloc(T, alignment, n);
  21c3c5:	66 89 0b             	mov    WORD PTR [rbx],cx
  21c3c8:	0f b7 48 04          	movzx  ecx,WORD PTR [rax+0x4]
  21c3cc:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  21c3d0:	8b 00                	mov    eax,DWORD PTR [rax]
  21c3d2:	89 43 02             	mov    DWORD PTR [rbx+0x2],eax
  21c3d5:	48 89 73 08          	mov    QWORD PTR [rbx+0x8],rsi
  21c3d9:	48 89 53 10          	mov    QWORD PTR [rbx+0x10],rdx
  21c3dd:	48 81 c4 88 00 00 00 	add    rsp,0x88
  21c3e4:	5b                   	pop    rbx
  21c3e5:	41 5e                	pop    r14
  21c3e7:	c3                   	ret    
            @panic("assertion failure");
  21c3e8:	e8 f3 81 ff ff       	call   2145e0 <panic>
  21c3ed:	0f 1f 00             	nop    DWORD PTR [rax]

000000000021c3f0 <parseFormValue>:
fn parseFormValue(allocator: *mem.Allocator, in_stream: var, form_id: u64, is_64: bool) ParseFormValueError!FormValue {
  21c3f0:	55                   	push   rbp
  21c3f1:	41 57                	push   r15
  21c3f3:	41 56                	push   r14
  21c3f5:	41 55                	push   r13
  21c3f7:	41 54                	push   r12
  21c3f9:	53                   	push   rbx
  21c3fa:	48 81 ec 08 07 00 00 	sub    rsp,0x708
  21c401:	44 89 c5             	mov    ebp,r8d
  21c404:	48 89 cb             	mov    rbx,rcx
  21c407:	49 89 d4             	mov    r12,rdx
  21c40a:	49 89 f7             	mov    r15,rsi
  21c40d:	49 89 fe             	mov    r14,rdi
  21c410:	48 8d 05 e9 bc fe ff 	lea    rax,[rip+0xfffffffffffebce9]        # 208100 <__unnamed_81>
    return switch (form_id) {
  21c417:	48 8d 4b ff          	lea    rcx,[rbx-0x1]
  21c41b:	48 83 f9 1f          	cmp    rcx,0x1f
  21c41f:	0f 87 d1 19 00 00    	ja     21ddf6 <parseFormValue+0x1a06>
  21c425:	48 8d 15 ec 4e fe ff 	lea    rdx,[rip+0xfffffffffffe4eec]        # 201318 <app_mask+0x638>
  21c42c:	48 63 0c 8a          	movsxd rcx,DWORD PTR [rdx+rcx*4]
  21c430:	48 01 d1             	add    rcx,rdx
  21c433:	ff e1                	jmp    rcx
  21c435:	4c 89 bc 24 d0 00 00 	mov    QWORD PTR [rsp+0xd0],r15
  21c43c:	00 
  21c43d:	4c 89 74 24 68       	mov    QWORD PTR [rsp+0x68],r14
  21c442:	4c 8d b4 24 b0 00 00 	lea    r14,[rsp+0xb0]
  21c449:	00 
            try self.readNoEof(result[0..]);
  21c44a:	4c 89 74 24 18       	mov    QWORD PTR [rsp+0x18],r14
  21c44f:	48 c7 44 24 20 01 00 	mov    QWORD PTR [rsp+0x20],0x1
  21c456:	00 00 
  21c458:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  21c45d:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  21c462:	4c 89 e6             	mov    rsi,r12
  21c465:	41 ff 14 24          	call   QWORD PTR [r12]
  21c469:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  21c46e:	66 85 c0             	test   ax,ax
  21c471:	0f 84 f2 0b 00 00    	je     21d069 <parseFormValue+0xc79>
  21c477:	48 8b 4c 24 68       	mov    rcx,QWORD PTR [rsp+0x68]
            const block_len = try readULeb128(in_stream);
  21c47c:	66 89 01             	mov    WORD PTR [rcx],ax
  21c47f:	48 8b 84 24 b4 06 00 	mov    rax,QWORD PTR [rsp+0x6b4]
  21c486:	00 
  21c487:	48 89 41 20          	mov    QWORD PTR [rcx+0x20],rax
  21c48b:	c5 fc 10 84 24 96 06 	vmovups ymm0,YMMWORD PTR [rsp+0x696]
  21c492:	00 00 
  21c494:	c5 fc 11 41 02       	vmovups YMMWORD PTR [rcx+0x2],ymm0
  21c499:	e9 69 19 00 00       	jmp    21de07 <parseFormValue+0x1a17>
  21c49e:	48 8d 44 24 78       	lea    rax,[rsp+0x78]
            try self.readNoEof(bytes[0..]);
  21c4a3:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  21c4a8:	48 c7 44 24 20 08 00 	mov    QWORD PTR [rsp+0x20],0x8
  21c4af:	00 00 
  21c4b1:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  21c4b6:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  21c4bb:	4c 89 e6             	mov    rsi,r12
  21c4be:	41 ff 14 24          	call   QWORD PTR [r12]
  21c4c2:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  21c4c7:	66 85 c0             	test   ax,ax
  21c4ca:	75 14                	jne    21c4e0 <parseFormValue+0xf0>
  21c4cc:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  21c4d1:	66 b8 1f 00          	mov    ax,0x1f
            if (amt_read < buf.len) return error.EndOfStream;
  21c4d5:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  21c4da:	0f 83 ce 12 00 00    	jae    21d7ae <parseFormValue+0x13be>
        DW.FORM_addr => FormValue{ .Address = try parseFormValueTargetAddrSize(in_stream) },
  21c4e0:	66 41 89 06          	mov    WORD PTR [r14],ax
  21c4e4:	48 8b 84 24 00 07 00 	mov    rax,QWORD PTR [rsp+0x700]
  21c4eb:	00 
  21c4ec:	49 89 46 20          	mov    QWORD PTR [r14+0x20],rax
  21c4f0:	c5 fc 10 84 24 e2 06 	vmovups ymm0,YMMWORD PTR [rsp+0x6e2]
  21c4f7:	00 00 
  21c4f9:	e9 0b 0d 00 00       	jmp    21d209 <parseFormValue+0xe19>
  21c4fe:	48 8d 44 24 78       	lea    rax,[rsp+0x78]
            const input_slice = input_buf[0..size];
  21c503:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  21c508:	48 c7 44 24 20 02 00 	mov    QWORD PTR [rsp+0x20],0x2
  21c50f:	00 00 
  21c511:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  21c516:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  21c51b:	4c 89 e6             	mov    rsi,r12
  21c51e:	41 ff 14 24          	call   QWORD PTR [r12]
  21c522:	0f b7 4c 24 40       	movzx  ecx,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  21c527:	66 85 c9             	test   cx,cx
  21c52a:	75 14                	jne    21c540 <parseFormValue+0x150>
            if (amt_read < buf.len) return error.EndOfStream;
  21c52c:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
  21c531:	66 b9 1f 00          	mov    cx,0x1f
  21c535:	48 39 44 24 48       	cmp    QWORD PTR [rsp+0x48],rax
  21c53a:	0f 83 d8 12 00 00    	jae    21d818 <parseFormValue+0x1428>
    const block_len = try in_stream.readVarInt(builtin.Endian.Little, usize, size);
  21c540:	66 89 8c 24 90 02 00 	mov    WORD PTR [rsp+0x290],cx
  21c547:	00 
  21c548:	8b 44 24 3a          	mov    eax,DWORD PTR [rsp+0x3a]
  21c54c:	89 84 24 92 02 00 00 	mov    DWORD PTR [rsp+0x292],eax
  21c553:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  21c558:	66 89 84 24 96 02 00 	mov    WORD PTR [rsp+0x296],ax
  21c55f:	00 
  21c560:	8b 44 24 11          	mov    eax,DWORD PTR [rsp+0x11]
  21c564:	89 84 24 a9 02 00 00 	mov    DWORD PTR [rsp+0x2a9],eax
  21c56b:	0f b7 44 24 15       	movzx  eax,WORD PTR [rsp+0x15]
  21c570:	66 89 84 24 ad 02 00 	mov    WORD PTR [rsp+0x2ad],ax
  21c577:	00 
  21c578:	8a 44 24 17          	mov    al,BYTE PTR [rsp+0x17]
  21c57c:	88 84 24 af 02 00 00 	mov    BYTE PTR [rsp+0x2af],al
  21c583:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  21c587:	89 84 24 b1 02 00 00 	mov    DWORD PTR [rsp+0x2b1],eax
  21c58e:	0f b7 44 24 0e       	movzx  eax,WORD PTR [rsp+0xe]
  21c593:	66 89 84 24 b5 02 00 	mov    WORD PTR [rsp+0x2b5],ax
  21c59a:	00 
  21c59b:	8a 44 24 10          	mov    al,BYTE PTR [rsp+0x10]
  21c59f:	88 84 24 b7 02 00 00 	mov    BYTE PTR [rsp+0x2b7],al
  21c5a6:	48 8d 84 24 90 02 00 	lea    rax,[rsp+0x290]
  21c5ad:	00 
  21c5ae:	e9 43 18 00 00       	jmp    21ddf6 <parseFormValue+0x1a06>
  21c5b3:	48 8d 44 24 78       	lea    rax,[rsp+0x78]
            const input_slice = input_buf[0..size];
  21c5b8:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  21c5bd:	48 c7 44 24 20 04 00 	mov    QWORD PTR [rsp+0x20],0x4
  21c5c4:	00 00 
  21c5c6:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  21c5cb:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  21c5d0:	4c 89 e6             	mov    rsi,r12
  21c5d3:	41 ff 14 24          	call   QWORD PTR [r12]
  21c5d7:	0f b7 4c 24 40       	movzx  ecx,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  21c5dc:	66 85 c9             	test   cx,cx
  21c5df:	75 14                	jne    21c5f5 <parseFormValue+0x205>
            if (amt_read < buf.len) return error.EndOfStream;
  21c5e1:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
  21c5e6:	66 b9 1f 00          	mov    cx,0x1f
  21c5ea:	48 39 44 24 48       	cmp    QWORD PTR [rsp+0x48],rax
  21c5ef:	0f 83 44 12 00 00    	jae    21d839 <parseFormValue+0x1449>
  21c5f5:	66 89 8c 24 68 02 00 	mov    WORD PTR [rsp+0x268],cx
  21c5fc:	00 
  21c5fd:	8b 44 24 3a          	mov    eax,DWORD PTR [rsp+0x3a]
  21c601:	89 84 24 6a 02 00 00 	mov    DWORD PTR [rsp+0x26a],eax
  21c608:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  21c60d:	66 89 84 24 6e 02 00 	mov    WORD PTR [rsp+0x26e],ax
  21c614:	00 
  21c615:	8b 44 24 11          	mov    eax,DWORD PTR [rsp+0x11]
  21c619:	89 84 24 81 02 00 00 	mov    DWORD PTR [rsp+0x281],eax
  21c620:	0f b7 44 24 15       	movzx  eax,WORD PTR [rsp+0x15]
  21c625:	66 89 84 24 85 02 00 	mov    WORD PTR [rsp+0x285],ax
  21c62c:	00 
  21c62d:	8a 44 24 17          	mov    al,BYTE PTR [rsp+0x17]
  21c631:	88 84 24 87 02 00 00 	mov    BYTE PTR [rsp+0x287],al
  21c638:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  21c63c:	89 84 24 89 02 00 00 	mov    DWORD PTR [rsp+0x289],eax
  21c643:	0f b7 44 24 0e       	movzx  eax,WORD PTR [rsp+0xe]
  21c648:	66 89 84 24 8d 02 00 	mov    WORD PTR [rsp+0x28d],ax
  21c64f:	00 
  21c650:	8a 44 24 10          	mov    al,BYTE PTR [rsp+0x10]
  21c654:	88 84 24 8f 02 00 00 	mov    BYTE PTR [rsp+0x28f],al
  21c65b:	48 8d 84 24 68 02 00 	lea    rax,[rsp+0x268]
  21c662:	00 
  21c663:	e9 8e 17 00 00       	jmp    21ddf6 <parseFormValue+0x1a06>
  21c668:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
            .payload = try readAllocBytes(allocator, in_stream, size),
  21c66d:	b9 02 00 00 00       	mov    ecx,0x2
  21c672:	4c 89 fe             	mov    rsi,r15
  21c675:	4c 89 e2             	mov    rdx,r12
  21c678:	e8 03 2b 00 00       	call   21f180 <readAllocBytes>
  21c67d:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
  21c682:	66 85 c0             	test   ax,ax
  21c685:	0f 84 89 0b 00 00    	je     21d214 <parseFormValue+0xe24>
  21c68b:	66 89 84 24 78 01 00 	mov    WORD PTR [rsp+0x178],ax
  21c692:	00 
  21c693:	8b 44 24 3a          	mov    eax,DWORD PTR [rsp+0x3a]
  21c697:	89 84 24 7a 01 00 00 	mov    DWORD PTR [rsp+0x17a],eax
  21c69e:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  21c6a3:	66 89 84 24 7e 01 00 	mov    WORD PTR [rsp+0x17e],ax
  21c6aa:	00 
  21c6ab:	8b 44 24 11          	mov    eax,DWORD PTR [rsp+0x11]
  21c6af:	89 84 24 91 01 00 00 	mov    DWORD PTR [rsp+0x191],eax
  21c6b6:	0f b7 44 24 15       	movzx  eax,WORD PTR [rsp+0x15]
  21c6bb:	66 89 84 24 95 01 00 	mov    WORD PTR [rsp+0x195],ax
  21c6c2:	00 
  21c6c3:	8a 44 24 17          	mov    al,BYTE PTR [rsp+0x17]
  21c6c7:	88 84 24 97 01 00 00 	mov    BYTE PTR [rsp+0x197],al
  21c6ce:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  21c6d2:	89 84 24 99 01 00 00 	mov    DWORD PTR [rsp+0x199],eax
  21c6d9:	0f b7 44 24 0e       	movzx  eax,WORD PTR [rsp+0xe]
  21c6de:	66 89 84 24 9d 01 00 	mov    WORD PTR [rsp+0x19d],ax
  21c6e5:	00 
  21c6e6:	8a 44 24 10          	mov    al,BYTE PTR [rsp+0x10]
  21c6ea:	88 84 24 9f 01 00 00 	mov    BYTE PTR [rsp+0x19f],al
  21c6f1:	48 8d 84 24 78 01 00 	lea    rax,[rsp+0x178]
  21c6f8:	00 
  21c6f9:	e9 f8 16 00 00       	jmp    21ddf6 <parseFormValue+0x1a06>
  21c6fe:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  21c703:	b9 04 00 00 00       	mov    ecx,0x4
  21c708:	4c 89 fe             	mov    rsi,r15
  21c70b:	4c 89 e2             	mov    rdx,r12
  21c70e:	e8 6d 2a 00 00       	call   21f180 <readAllocBytes>
  21c713:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
  21c718:	66 85 c0             	test   ax,ax
  21c71b:	0f 84 9d 0b 00 00    	je     21d2be <parseFormValue+0xece>
  21c721:	66 89 84 24 50 01 00 	mov    WORD PTR [rsp+0x150],ax
  21c728:	00 
  21c729:	8b 44 24 3a          	mov    eax,DWORD PTR [rsp+0x3a]
  21c72d:	89 84 24 52 01 00 00 	mov    DWORD PTR [rsp+0x152],eax
  21c734:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  21c739:	66 89 84 24 56 01 00 	mov    WORD PTR [rsp+0x156],ax
  21c740:	00 
  21c741:	8b 44 24 11          	mov    eax,DWORD PTR [rsp+0x11]
  21c745:	89 84 24 69 01 00 00 	mov    DWORD PTR [rsp+0x169],eax
  21c74c:	0f b7 44 24 15       	movzx  eax,WORD PTR [rsp+0x15]
  21c751:	66 89 84 24 6d 01 00 	mov    WORD PTR [rsp+0x16d],ax
  21c758:	00 
  21c759:	8a 44 24 17          	mov    al,BYTE PTR [rsp+0x17]
  21c75d:	88 84 24 6f 01 00 00 	mov    BYTE PTR [rsp+0x16f],al
  21c764:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  21c768:	89 84 24 71 01 00 00 	mov    DWORD PTR [rsp+0x171],eax
  21c76f:	0f b7 44 24 0e       	movzx  eax,WORD PTR [rsp+0xe]
  21c774:	66 89 84 24 75 01 00 	mov    WORD PTR [rsp+0x175],ax
  21c77b:	00 
  21c77c:	8a 44 24 10          	mov    al,BYTE PTR [rsp+0x10]
  21c780:	88 84 24 77 01 00 00 	mov    BYTE PTR [rsp+0x177],al
  21c787:	48 8d 84 24 50 01 00 	lea    rax,[rsp+0x150]
  21c78e:	00 
  21c78f:	e9 62 16 00 00       	jmp    21ddf6 <parseFormValue+0x1a06>
  21c794:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  21c799:	b9 08 00 00 00       	mov    ecx,0x8
  21c79e:	4c 89 fe             	mov    rsi,r15
  21c7a1:	4c 89 e2             	mov    rdx,r12
  21c7a4:	e8 d7 29 00 00       	call   21f180 <readAllocBytes>
  21c7a9:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
  21c7ae:	66 85 c0             	test   ax,ax
  21c7b1:	0f 84 b1 0b 00 00    	je     21d368 <parseFormValue+0xf78>
  21c7b7:	66 89 84 24 28 01 00 	mov    WORD PTR [rsp+0x128],ax
  21c7be:	00 
  21c7bf:	8b 44 24 3a          	mov    eax,DWORD PTR [rsp+0x3a]
  21c7c3:	89 84 24 2a 01 00 00 	mov    DWORD PTR [rsp+0x12a],eax
  21c7ca:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  21c7cf:	66 89 84 24 2e 01 00 	mov    WORD PTR [rsp+0x12e],ax
  21c7d6:	00 
  21c7d7:	8b 44 24 11          	mov    eax,DWORD PTR [rsp+0x11]
  21c7db:	89 84 24 41 01 00 00 	mov    DWORD PTR [rsp+0x141],eax
  21c7e2:	0f b7 44 24 15       	movzx  eax,WORD PTR [rsp+0x15]
  21c7e7:	66 89 84 24 45 01 00 	mov    WORD PTR [rsp+0x145],ax
  21c7ee:	00 
  21c7ef:	8a 44 24 17          	mov    al,BYTE PTR [rsp+0x17]
  21c7f3:	88 84 24 47 01 00 00 	mov    BYTE PTR [rsp+0x147],al
  21c7fa:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  21c7fe:	89 84 24 49 01 00 00 	mov    DWORD PTR [rsp+0x149],eax
  21c805:	0f b7 44 24 0e       	movzx  eax,WORD PTR [rsp+0xe]
  21c80a:	66 89 84 24 4d 01 00 	mov    WORD PTR [rsp+0x14d],ax
  21c811:	00 
  21c812:	8a 44 24 10          	mov    al,BYTE PTR [rsp+0x10]
  21c816:	88 84 24 4f 01 00 00 	mov    BYTE PTR [rsp+0x14f],al
  21c81d:	48 8d 84 24 28 01 00 	lea    rax,[rsp+0x128]
  21c824:	00 
  21c825:	e9 cc 15 00 00       	jmp    21ddf6 <parseFormValue+0x1a06>
  21c82a:	4c 89 74 24 68       	mov    QWORD PTR [rsp+0x68],r14
            return Self{
  21c82f:	c5 f8 57 c0          	vxorps xmm0,xmm0,xmm0
  21c833:	c5 f8 29 44 24 40    	vmovaps XMMWORD PTR [rsp+0x40],xmm0
  21c839:	48 c7 44 24 50 00 00 	mov    QWORD PTR [rsp+0x50],0x0
  21c840:	00 00 
  21c842:	4c 89 bc 24 d0 00 00 	mov    QWORD PTR [rsp+0xd0],r15
  21c849:	00 
    var buf = ArrayList(u8).init(allocator);
  21c84a:	4c 89 7c 24 58       	mov    QWORD PTR [rsp+0x58],r15
  21c84f:	48 8d 84 24 b0 00 00 	lea    rax,[rsp+0xb0]
  21c856:	00 
            try self.readNoEof(result[0..]);
  21c857:	48 89 84 24 90 00 00 	mov    QWORD PTR [rsp+0x90],rax
  21c85e:	00 
  21c85f:	48 c7 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],0x1
  21c866:	00 01 00 00 00 
  21c86b:	48 8d 7c 24 18       	lea    rdi,[rsp+0x18]
  21c870:	48 8d 94 24 90 00 00 	lea    rdx,[rsp+0x90]
  21c877:	00 
            return self.readFn(self, buffer);
  21c878:	4c 89 e6             	mov    rsi,r12
  21c87b:	41 ff 14 24          	call   QWORD PTR [r12]
  21c87f:	0f b7 44 24 18       	movzx  eax,WORD PTR [rsp+0x18]
            const amt_read = try self.read(buf);
  21c884:	66 85 c0             	test   ax,ax
  21c887:	0f 84 85 0b 00 00    	je     21d412 <parseFormValue+0x1022>
  21c88d:	48 8b 4c 24 68       	mov    rcx,QWORD PTR [rsp+0x68]
        DW.FORM_string => FormValue{ .String = try readStringRaw(allocator, in_stream) },
  21c892:	66 89 01             	mov    WORD PTR [rcx],ax
  21c895:	48 8b 84 24 84 05 00 	mov    rax,QWORD PTR [rsp+0x584]
  21c89c:	00 
  21c89d:	48 89 41 20          	mov    QWORD PTR [rcx+0x20],rax
  21c8a1:	c5 fc 10 84 24 66 05 	vmovups ymm0,YMMWORD PTR [rsp+0x566]
  21c8a8:	00 00 
  21c8aa:	c5 fc 11 41 02       	vmovups YMMWORD PTR [rcx+0x2],ymm0
  21c8af:	e9 53 15 00 00       	jmp    21de07 <parseFormValue+0x1a17>
  21c8b4:	4c 89 bc 24 d0 00 00 	mov    QWORD PTR [rsp+0xd0],r15
  21c8bb:	00 
  21c8bc:	4c 89 74 24 68       	mov    QWORD PTR [rsp+0x68],r14
  21c8c1:	4c 8d ac 24 b0 00 00 	lea    r13,[rsp+0xb0]
  21c8c8:	00 
            try self.readNoEof(result[0..]);
  21c8c9:	4c 89 6c 24 18       	mov    QWORD PTR [rsp+0x18],r13
  21c8ce:	48 c7 44 24 20 01 00 	mov    QWORD PTR [rsp+0x20],0x1
  21c8d5:	00 00 
  21c8d7:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  21c8dc:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  21c8e1:	4c 89 e6             	mov    rsi,r12
  21c8e4:	41 ff 14 24          	call   QWORD PTR [r12]
  21c8e8:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  21c8ed:	66 85 c0             	test   ax,ax
  21c8f0:	0f 84 fa 0b 00 00    	je     21d4f0 <parseFormValue+0x1100>
  21c8f6:	48 8b 4c 24 68       	mov    rcx,QWORD PTR [rsp+0x68]
            const block_len = try readULeb128(in_stream);
  21c8fb:	66 89 01             	mov    WORD PTR [rcx],ax
  21c8fe:	48 8b 84 24 da 06 00 	mov    rax,QWORD PTR [rsp+0x6da]
  21c905:	00 
  21c906:	48 89 41 20          	mov    QWORD PTR [rcx+0x20],rax
  21c90a:	c5 fc 10 84 24 bc 06 	vmovups ymm0,YMMWORD PTR [rsp+0x6bc]
  21c911:	00 00 
  21c913:	c5 fc 11 41 02       	vmovups YMMWORD PTR [rcx+0x2],ymm0
  21c918:	e9 ea 14 00 00       	jmp    21de07 <parseFormValue+0x1a17>
  21c91d:	48 8d 44 24 78       	lea    rax,[rsp+0x78]
            const input_slice = input_buf[0..size];
  21c922:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  21c927:	48 c7 44 24 20 01 00 	mov    QWORD PTR [rsp+0x20],0x1
  21c92e:	00 00 
  21c930:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  21c935:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  21c93a:	4c 89 e6             	mov    rsi,r12
  21c93d:	41 ff 14 24          	call   QWORD PTR [r12]
  21c941:	0f b7 4c 24 40       	movzx  ecx,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  21c946:	66 85 c9             	test   cx,cx
  21c949:	75 14                	jne    21c95f <parseFormValue+0x56f>
            if (amt_read < buf.len) return error.EndOfStream;
  21c94b:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
  21c950:	66 b9 1f 00          	mov    cx,0x1f
  21c954:	48 39 44 24 48       	cmp    QWORD PTR [rsp+0x48],rax
  21c959:	0f 83 fb 0e 00 00    	jae    21d85a <parseFormValue+0x146a>
    const block_len = try in_stream.readVarInt(builtin.Endian.Little, usize, size);
  21c95f:	66 89 8c 24 b8 02 00 	mov    WORD PTR [rsp+0x2b8],cx
  21c966:	00 
  21c967:	8b 44 24 3a          	mov    eax,DWORD PTR [rsp+0x3a]
  21c96b:	89 84 24 ba 02 00 00 	mov    DWORD PTR [rsp+0x2ba],eax
  21c972:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  21c977:	66 89 84 24 be 02 00 	mov    WORD PTR [rsp+0x2be],ax
  21c97e:	00 
  21c97f:	8b 44 24 11          	mov    eax,DWORD PTR [rsp+0x11]
  21c983:	89 84 24 d1 02 00 00 	mov    DWORD PTR [rsp+0x2d1],eax
  21c98a:	0f b7 44 24 15       	movzx  eax,WORD PTR [rsp+0x15]
  21c98f:	66 89 84 24 d5 02 00 	mov    WORD PTR [rsp+0x2d5],ax
  21c996:	00 
  21c997:	8a 44 24 17          	mov    al,BYTE PTR [rsp+0x17]
  21c99b:	88 84 24 d7 02 00 00 	mov    BYTE PTR [rsp+0x2d7],al
  21c9a2:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  21c9a6:	89 84 24 d9 02 00 00 	mov    DWORD PTR [rsp+0x2d9],eax
  21c9ad:	0f b7 44 24 0e       	movzx  eax,WORD PTR [rsp+0xe]
  21c9b2:	66 89 84 24 dd 02 00 	mov    WORD PTR [rsp+0x2dd],ax
  21c9b9:	00 
  21c9ba:	8a 44 24 10          	mov    al,BYTE PTR [rsp+0x10]
  21c9be:	88 84 24 df 02 00 00 	mov    BYTE PTR [rsp+0x2df],al
  21c9c5:	48 8d 84 24 b8 02 00 	lea    rax,[rsp+0x2b8]
  21c9cc:	00 
  21c9cd:	e9 24 14 00 00       	jmp    21ddf6 <parseFormValue+0x1a06>
  21c9d2:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
            .payload = try readAllocBytes(allocator, in_stream, size),
  21c9d7:	b9 01 00 00 00       	mov    ecx,0x1
  21c9dc:	4c 89 fe             	mov    rsi,r15
  21c9df:	4c 89 e2             	mov    rdx,r12
  21c9e2:	e8 99 27 00 00       	call   21f180 <readAllocBytes>
  21c9e7:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
  21c9ec:	66 85 c0             	test   ax,ax
  21c9ef:	0f 84 7c 0b 00 00    	je     21d571 <parseFormValue+0x1181>
  21c9f5:	66 89 84 24 a0 01 00 	mov    WORD PTR [rsp+0x1a0],ax
  21c9fc:	00 
  21c9fd:	8b 44 24 3a          	mov    eax,DWORD PTR [rsp+0x3a]
  21ca01:	89 84 24 a2 01 00 00 	mov    DWORD PTR [rsp+0x1a2],eax
  21ca08:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  21ca0d:	66 89 84 24 a6 01 00 	mov    WORD PTR [rsp+0x1a6],ax
  21ca14:	00 
  21ca15:	8b 44 24 11          	mov    eax,DWORD PTR [rsp+0x11]
  21ca19:	89 84 24 b9 01 00 00 	mov    DWORD PTR [rsp+0x1b9],eax
  21ca20:	0f b7 44 24 15       	movzx  eax,WORD PTR [rsp+0x15]
  21ca25:	66 89 84 24 bd 01 00 	mov    WORD PTR [rsp+0x1bd],ax
  21ca2c:	00 
  21ca2d:	8a 44 24 17          	mov    al,BYTE PTR [rsp+0x17]
  21ca31:	88 84 24 bf 01 00 00 	mov    BYTE PTR [rsp+0x1bf],al
  21ca38:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  21ca3c:	89 84 24 c1 01 00 00 	mov    DWORD PTR [rsp+0x1c1],eax
  21ca43:	0f b7 44 24 0e       	movzx  eax,WORD PTR [rsp+0xe]
  21ca48:	66 89 84 24 c5 01 00 	mov    WORD PTR [rsp+0x1c5],ax
  21ca4f:	00 
  21ca50:	8a 44 24 10          	mov    al,BYTE PTR [rsp+0x10]
  21ca54:	88 84 24 c7 01 00 00 	mov    BYTE PTR [rsp+0x1c7],al
  21ca5b:	48 8d 84 24 a0 01 00 	lea    rax,[rsp+0x1a0]
  21ca62:	00 
  21ca63:	e9 8e 13 00 00       	jmp    21ddf6 <parseFormValue+0x1a06>
  21ca68:	48 8d 84 24 b0 00 00 	lea    rax,[rsp+0xb0]
  21ca6f:	00 
            try self.readNoEof(result[0..]);
  21ca70:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  21ca75:	48 c7 44 24 20 01 00 	mov    QWORD PTR [rsp+0x20],0x1
  21ca7c:	00 00 
  21ca7e:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  21ca83:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  21ca88:	4c 89 e6             	mov    rsi,r12
  21ca8b:	41 ff 14 24          	call   QWORD PTR [r12]
  21ca8f:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  21ca94:	66 85 c0             	test   ax,ax
  21ca97:	75 14                	jne    21caad <parseFormValue+0x6bd>
  21ca99:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  21ca9e:	66 b8 1f 00          	mov    ax,0x1f
            if (amt_read < buf.len) return error.EndOfStream;
  21caa2:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  21caa7:	0f 83 ce 0d 00 00    	jae    21d87b <parseFormValue+0x148b>
        DW.FORM_flag => FormValue{ .Flag = (try in_stream.readByte()) != 0 },
  21caad:	66 41 89 06          	mov    WORD PTR [r14],ax
  21cab1:	48 8b 84 24 42 06 00 	mov    rax,QWORD PTR [rsp+0x642]
  21cab8:	00 
  21cab9:	49 89 46 20          	mov    QWORD PTR [r14+0x20],rax
  21cabd:	c5 fc 10 84 24 24 06 	vmovups ymm0,YMMWORD PTR [rsp+0x624]
  21cac4:	00 00 
  21cac6:	e9 3e 07 00 00       	jmp    21d209 <parseFormValue+0xe19>
    return if (is_64) try in_stream.readIntLe(u64) else u64(try in_stream.readIntLe(u32));
  21cacb:	40 f6 c5 01          	test   bpl,0x1
  21cacf:	0f 84 1c 06 00 00    	je     21d0f1 <parseFormValue+0xd01>
  21cad5:	48 8d 84 24 90 00 00 	lea    rax,[rsp+0x90]
  21cadc:	00 
            try self.readNoEof(bytes[0..]);
  21cadd:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  21cae2:	48 c7 44 24 20 08 00 	mov    QWORD PTR [rsp+0x20],0x8
  21cae9:	00 00 
  21caeb:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  21caf0:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  21caf5:	4c 89 e6             	mov    rsi,r12
  21caf8:	41 ff 14 24          	call   QWORD PTR [r12]
  21cafc:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  21cb01:	66 85 c0             	test   ax,ax
  21cb04:	0f 85 29 06 00 00    	jne    21d133 <parseFormValue+0xd43>
  21cb0a:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  21cb0f:	66 b8 1f 00          	mov    ax,0x1f
            if (amt_read < buf.len) return error.EndOfStream;
  21cb13:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  21cb18:	0f 82 15 06 00 00    	jb     21d133 <parseFormValue+0xd43>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  21cb1e:	48 8b 84 24 90 00 00 	mov    rax,QWORD PTR [rsp+0x90]
  21cb25:	00 
  21cb26:	e9 4f 11 00 00       	jmp    21dc7a <parseFormValue+0x188a>
  21cb2b:	40 f6 c5 01          	test   bpl,0x1
  21cb2f:	0f 84 1c 06 00 00    	je     21d151 <parseFormValue+0xd61>
  21cb35:	48 8d 84 24 90 00 00 	lea    rax,[rsp+0x90]
  21cb3c:	00 
            try self.readNoEof(bytes[0..]);
  21cb3d:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  21cb42:	48 c7 44 24 20 08 00 	mov    QWORD PTR [rsp+0x20],0x8
  21cb49:	00 00 
  21cb4b:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  21cb50:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  21cb55:	4c 89 e6             	mov    rsi,r12
  21cb58:	41 ff 14 24          	call   QWORD PTR [r12]
  21cb5c:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  21cb61:	66 85 c0             	test   ax,ax
  21cb64:	0f 85 29 06 00 00    	jne    21d193 <parseFormValue+0xda3>
  21cb6a:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  21cb6f:	66 b8 1f 00          	mov    ax,0x1f
            if (amt_read < buf.len) return error.EndOfStream;
  21cb73:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  21cb78:	0f 82 15 06 00 00    	jb     21d193 <parseFormValue+0xda3>
  21cb7e:	48 8b 84 24 90 00 00 	mov    rax,QWORD PTR [rsp+0x90]
  21cb85:	00 
  21cb86:	e9 7d 11 00 00       	jmp    21dd08 <parseFormValue+0x1918>
  21cb8b:	48 8d 84 24 b0 00 00 	lea    rax,[rsp+0xb0]
  21cb92:	00 
            try self.readNoEof(bytes[0..]);
  21cb93:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  21cb98:	48 c7 44 24 20 01 00 	mov    QWORD PTR [rsp+0x20],0x1
  21cb9f:	00 00 
  21cba1:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  21cba6:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  21cbab:	4c 89 e6             	mov    rsi,r12
  21cbae:	41 ff 14 24          	call   QWORD PTR [r12]
  21cbb2:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  21cbb7:	66 85 c0             	test   ax,ax
  21cbba:	75 14                	jne    21cbd0 <parseFormValue+0x7e0>
  21cbbc:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  21cbc1:	66 b8 1f 00          	mov    ax,0x1f
            if (amt_read < buf.len) return error.EndOfStream;
  21cbc5:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  21cbca:	0f 83 30 0d 00 00    	jae    21d900 <parseFormValue+0x1510>
    const block_len = try in_stream.readIntLe(T);
  21cbd0:	66 89 84 24 40 02 00 	mov    WORD PTR [rsp+0x240],ax
  21cbd7:	00 
  21cbd8:	8b 44 24 3a          	mov    eax,DWORD PTR [rsp+0x3a]
  21cbdc:	89 84 24 42 02 00 00 	mov    DWORD PTR [rsp+0x242],eax
  21cbe3:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  21cbe8:	66 89 84 24 46 02 00 	mov    WORD PTR [rsp+0x246],ax
  21cbef:	00 
  21cbf0:	8b 44 24 11          	mov    eax,DWORD PTR [rsp+0x11]
  21cbf4:	89 84 24 59 02 00 00 	mov    DWORD PTR [rsp+0x259],eax
  21cbfb:	0f b7 44 24 15       	movzx  eax,WORD PTR [rsp+0x15]
  21cc00:	66 89 84 24 5d 02 00 	mov    WORD PTR [rsp+0x25d],ax
  21cc07:	00 
  21cc08:	8a 44 24 17          	mov    al,BYTE PTR [rsp+0x17]
  21cc0c:	88 84 24 5f 02 00 00 	mov    BYTE PTR [rsp+0x25f],al
  21cc13:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  21cc17:	89 84 24 61 02 00 00 	mov    DWORD PTR [rsp+0x261],eax
  21cc1e:	0f b7 44 24 0e       	movzx  eax,WORD PTR [rsp+0xe]
  21cc23:	66 89 84 24 65 02 00 	mov    WORD PTR [rsp+0x265],ax
  21cc2a:	00 
  21cc2b:	8a 44 24 10          	mov    al,BYTE PTR [rsp+0x10]
  21cc2f:	88 84 24 67 02 00 00 	mov    BYTE PTR [rsp+0x267],al
  21cc36:	48 8d 84 24 40 02 00 	lea    rax,[rsp+0x240]
  21cc3d:	00 
  21cc3e:	e9 b3 11 00 00       	jmp    21ddf6 <parseFormValue+0x1a06>
  21cc43:	48 8d 44 24 78       	lea    rax,[rsp+0x78]
            try self.readNoEof(bytes[0..]);
  21cc48:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  21cc4d:	48 c7 44 24 20 02 00 	mov    QWORD PTR [rsp+0x20],0x2
  21cc54:	00 00 
  21cc56:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  21cc5b:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  21cc60:	4c 89 e6             	mov    rsi,r12
  21cc63:	41 ff 14 24          	call   QWORD PTR [r12]
  21cc67:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  21cc6c:	66 85 c0             	test   ax,ax
  21cc6f:	75 14                	jne    21cc85 <parseFormValue+0x895>
  21cc71:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  21cc76:	66 b8 1f 00          	mov    ax,0x1f
            if (amt_read < buf.len) return error.EndOfStream;
  21cc7a:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  21cc7f:	0f 83 dd 0c 00 00    	jae    21d962 <parseFormValue+0x1572>
  21cc85:	66 89 84 24 18 02 00 	mov    WORD PTR [rsp+0x218],ax
  21cc8c:	00 
  21cc8d:	8b 44 24 3a          	mov    eax,DWORD PTR [rsp+0x3a]
  21cc91:	89 84 24 1a 02 00 00 	mov    DWORD PTR [rsp+0x21a],eax
  21cc98:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  21cc9d:	66 89 84 24 1e 02 00 	mov    WORD PTR [rsp+0x21e],ax
  21cca4:	00 
  21cca5:	8b 44 24 11          	mov    eax,DWORD PTR [rsp+0x11]
  21cca9:	89 84 24 31 02 00 00 	mov    DWORD PTR [rsp+0x231],eax
  21ccb0:	0f b7 44 24 15       	movzx  eax,WORD PTR [rsp+0x15]
  21ccb5:	66 89 84 24 35 02 00 	mov    WORD PTR [rsp+0x235],ax
  21ccbc:	00 
  21ccbd:	8a 44 24 17          	mov    al,BYTE PTR [rsp+0x17]
  21ccc1:	88 84 24 37 02 00 00 	mov    BYTE PTR [rsp+0x237],al
  21ccc8:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  21cccc:	89 84 24 39 02 00 00 	mov    DWORD PTR [rsp+0x239],eax
  21ccd3:	0f b7 44 24 0e       	movzx  eax,WORD PTR [rsp+0xe]
  21ccd8:	66 89 84 24 3d 02 00 	mov    WORD PTR [rsp+0x23d],ax
  21ccdf:	00 
  21cce0:	8a 44 24 10          	mov    al,BYTE PTR [rsp+0x10]
  21cce4:	88 84 24 3f 02 00 00 	mov    BYTE PTR [rsp+0x23f],al
  21cceb:	48 8d 84 24 18 02 00 	lea    rax,[rsp+0x218]
  21ccf2:	00 
  21ccf3:	e9 fe 10 00 00       	jmp    21ddf6 <parseFormValue+0x1a06>
  21ccf8:	48 8d 44 24 78       	lea    rax,[rsp+0x78]
            try self.readNoEof(bytes[0..]);
  21ccfd:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  21cd02:	48 c7 44 24 20 04 00 	mov    QWORD PTR [rsp+0x20],0x4
  21cd09:	00 00 
  21cd0b:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  21cd10:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  21cd15:	4c 89 e6             	mov    rsi,r12
  21cd18:	41 ff 14 24          	call   QWORD PTR [r12]
  21cd1c:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  21cd21:	66 85 c0             	test   ax,ax
  21cd24:	75 14                	jne    21cd3a <parseFormValue+0x94a>
  21cd26:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  21cd2b:	66 b8 1f 00          	mov    ax,0x1f
            if (amt_read < buf.len) return error.EndOfStream;
  21cd2f:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  21cd34:	0f 83 93 0c 00 00    	jae    21d9cd <parseFormValue+0x15dd>
  21cd3a:	66 89 84 24 f0 01 00 	mov    WORD PTR [rsp+0x1f0],ax
  21cd41:	00 
  21cd42:	8b 44 24 3a          	mov    eax,DWORD PTR [rsp+0x3a]
  21cd46:	89 84 24 f2 01 00 00 	mov    DWORD PTR [rsp+0x1f2],eax
  21cd4d:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  21cd52:	66 89 84 24 f6 01 00 	mov    WORD PTR [rsp+0x1f6],ax
  21cd59:	00 
  21cd5a:	8b 44 24 11          	mov    eax,DWORD PTR [rsp+0x11]
  21cd5e:	89 84 24 09 02 00 00 	mov    DWORD PTR [rsp+0x209],eax
  21cd65:	0f b7 44 24 15       	movzx  eax,WORD PTR [rsp+0x15]
  21cd6a:	66 89 84 24 0d 02 00 	mov    WORD PTR [rsp+0x20d],ax
  21cd71:	00 
  21cd72:	8a 44 24 17          	mov    al,BYTE PTR [rsp+0x17]
  21cd76:	88 84 24 0f 02 00 00 	mov    BYTE PTR [rsp+0x20f],al
  21cd7d:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  21cd81:	89 84 24 11 02 00 00 	mov    DWORD PTR [rsp+0x211],eax
  21cd88:	0f b7 44 24 0e       	movzx  eax,WORD PTR [rsp+0xe]
  21cd8d:	66 89 84 24 15 02 00 	mov    WORD PTR [rsp+0x215],ax
  21cd94:	00 
  21cd95:	8a 44 24 10          	mov    al,BYTE PTR [rsp+0x10]
  21cd99:	88 84 24 17 02 00 00 	mov    BYTE PTR [rsp+0x217],al
  21cda0:	48 8d 84 24 f0 01 00 	lea    rax,[rsp+0x1f0]
  21cda7:	00 
  21cda8:	e9 49 10 00 00       	jmp    21ddf6 <parseFormValue+0x1a06>
  21cdad:	48 8d 44 24 78       	lea    rax,[rsp+0x78]
            try self.readNoEof(bytes[0..]);
  21cdb2:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  21cdb7:	48 c7 44 24 20 08 00 	mov    QWORD PTR [rsp+0x20],0x8
  21cdbe:	00 00 
  21cdc0:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  21cdc5:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  21cdca:	4c 89 e6             	mov    rsi,r12
  21cdcd:	41 ff 14 24          	call   QWORD PTR [r12]
  21cdd1:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  21cdd6:	66 85 c0             	test   ax,ax
  21cdd9:	75 14                	jne    21cdef <parseFormValue+0x9ff>
  21cddb:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  21cde0:	66 b8 1f 00          	mov    ax,0x1f
            if (amt_read < buf.len) return error.EndOfStream;
  21cde4:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  21cde9:	0f 83 61 0c 00 00    	jae    21da50 <parseFormValue+0x1660>
  21cdef:	66 89 84 24 c8 01 00 	mov    WORD PTR [rsp+0x1c8],ax
  21cdf6:	00 
  21cdf7:	8b 44 24 3a          	mov    eax,DWORD PTR [rsp+0x3a]
  21cdfb:	89 84 24 ca 01 00 00 	mov    DWORD PTR [rsp+0x1ca],eax
  21ce02:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  21ce07:	66 89 84 24 ce 01 00 	mov    WORD PTR [rsp+0x1ce],ax
  21ce0e:	00 
  21ce0f:	8b 44 24 11          	mov    eax,DWORD PTR [rsp+0x11]
  21ce13:	89 84 24 e1 01 00 00 	mov    DWORD PTR [rsp+0x1e1],eax
  21ce1a:	0f b7 44 24 15       	movzx  eax,WORD PTR [rsp+0x15]
  21ce1f:	66 89 84 24 e5 01 00 	mov    WORD PTR [rsp+0x1e5],ax
  21ce26:	00 
  21ce27:	8a 44 24 17          	mov    al,BYTE PTR [rsp+0x17]
  21ce2b:	88 84 24 e7 01 00 00 	mov    BYTE PTR [rsp+0x1e7],al
  21ce32:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  21ce36:	89 84 24 e9 01 00 00 	mov    DWORD PTR [rsp+0x1e9],eax
  21ce3d:	0f b7 44 24 0e       	movzx  eax,WORD PTR [rsp+0xe]
  21ce42:	66 89 84 24 ed 01 00 	mov    WORD PTR [rsp+0x1ed],ax
  21ce49:	00 
  21ce4a:	8a 44 24 10          	mov    al,BYTE PTR [rsp+0x10]
  21ce4e:	88 84 24 ef 01 00 00 	mov    BYTE PTR [rsp+0x1ef],al
  21ce55:	48 8d 84 24 c8 01 00 	lea    rax,[rsp+0x1c8]
  21ce5c:	00 
  21ce5d:	e9 94 0f 00 00       	jmp    21ddf6 <parseFormValue+0x1a06>
  21ce62:	4c 89 bc 24 d0 00 00 	mov    QWORD PTR [rsp+0xd0],r15
  21ce69:	00 
  21ce6a:	4c 89 74 24 68       	mov    QWORD PTR [rsp+0x68],r14
  21ce6f:	4c 8d b4 24 b0 00 00 	lea    r14,[rsp+0xb0]
  21ce76:	00 
            try self.readNoEof(result[0..]);
  21ce77:	4c 89 74 24 18       	mov    QWORD PTR [rsp+0x18],r14
  21ce7c:	48 c7 44 24 20 01 00 	mov    QWORD PTR [rsp+0x20],0x1
  21ce83:	00 00 
  21ce85:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  21ce8a:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  21ce8f:	4c 89 e6             	mov    rsi,r12
  21ce92:	41 ff 14 24          	call   QWORD PTR [r12]
  21ce96:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  21ce9b:	66 85 c0             	test   ax,ax
  21ce9e:	0f 84 77 07 00 00    	je     21d61b <parseFormValue+0x122b>
  21cea4:	48 8b 4c 24 68       	mov    rcx,QWORD PTR [rsp+0x68]
            const ref_len = try readULeb128(in_stream);
  21cea9:	66 89 01             	mov    WORD PTR [rcx],ax
  21ceac:	48 8b 84 24 f6 05 00 	mov    rax,QWORD PTR [rsp+0x5f6]
  21ceb3:	00 
  21ceb4:	48 89 41 20          	mov    QWORD PTR [rcx+0x20],rax
  21ceb8:	c5 fc 10 84 24 d8 05 	vmovups ymm0,YMMWORD PTR [rsp+0x5d8]
  21cebf:	00 00 
  21cec1:	c5 fc 11 41 02       	vmovups YMMWORD PTR [rcx+0x2],ymm0
  21cec6:	e9 3c 0f 00 00       	jmp    21de07 <parseFormValue+0x1a17>
  21cecb:	4c 89 bc 24 d0 00 00 	mov    QWORD PTR [rsp+0xd0],r15
  21ced2:	00 
  21ced3:	4c 89 74 24 68       	mov    QWORD PTR [rsp+0x68],r14
  21ced8:	4c 8d bc 24 b0 00 00 	lea    r15,[rsp+0xb0]
  21cedf:	00 
            try self.readNoEof(result[0..]);
  21cee0:	4c 89 7c 24 18       	mov    QWORD PTR [rsp+0x18],r15
  21cee5:	48 c7 44 24 20 01 00 	mov    QWORD PTR [rsp+0x20],0x1
  21ceec:	00 00 
  21ceee:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  21cef3:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  21cef8:	4c 89 e6             	mov    rsi,r12
  21cefb:	41 ff 14 24          	call   QWORD PTR [r12]
  21ceff:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  21cf04:	66 85 c0             	test   ax,ax
  21cf07:	0f 84 8f 07 00 00    	je     21d69c <parseFormValue+0x12ac>
  21cf0d:	48 8b 4c 24 68       	mov    rcx,QWORD PTR [rsp+0x68]
            const child_form_id = try readULeb128(in_stream);
  21cf12:	66 89 01             	mov    WORD PTR [rcx],ax
  21cf15:	48 8b 84 24 38 05 00 	mov    rax,QWORD PTR [rsp+0x538]
  21cf1c:	00 
  21cf1d:	48 89 41 20          	mov    QWORD PTR [rcx+0x20],rax
  21cf21:	c5 fc 10 84 24 1a 05 	vmovups ymm0,YMMWORD PTR [rsp+0x51a]
  21cf28:	00 00 
  21cf2a:	c5 fc 11 41 02       	vmovups YMMWORD PTR [rcx+0x2],ymm0
  21cf2f:	e9 d3 0e 00 00       	jmp    21de07 <parseFormValue+0x1a17>
    return if (is_64) try in_stream.readIntLe(u64) else u64(try in_stream.readIntLe(u32));
  21cf34:	40 f6 c5 01          	test   bpl,0x1
  21cf38:	0f 84 70 02 00 00    	je     21d1ae <parseFormValue+0xdbe>
  21cf3e:	48 8d 84 24 90 00 00 	lea    rax,[rsp+0x90]
  21cf45:	00 
            try self.readNoEof(bytes[0..]);
  21cf46:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  21cf4b:	48 c7 44 24 20 08 00 	mov    QWORD PTR [rsp+0x20],0x8
  21cf52:	00 00 
  21cf54:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  21cf59:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  21cf5e:	4c 89 e6             	mov    rsi,r12
  21cf61:	41 ff 14 24          	call   QWORD PTR [r12]
  21cf65:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  21cf6a:	66 85 c0             	test   ax,ax
  21cf6d:	0f 85 7d 02 00 00    	jne    21d1f0 <parseFormValue+0xe00>
  21cf73:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  21cf78:	66 b8 1f 00          	mov    ax,0x1f
            if (amt_read < buf.len) return error.EndOfStream;
  21cf7c:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  21cf81:	0f 82 69 02 00 00    	jb     21d1f0 <parseFormValue+0xe00>
  21cf87:	48 8b 84 24 90 00 00 	mov    rax,QWORD PTR [rsp+0x90]
  21cf8e:	00 
  21cf8f:	e9 02 0e 00 00       	jmp    21dd96 <parseFormValue+0x19a6>
  21cf94:	4c 89 bc 24 d0 00 00 	mov    QWORD PTR [rsp+0xd0],r15
  21cf9b:	00 
  21cf9c:	4c 89 74 24 68       	mov    QWORD PTR [rsp+0x68],r14
  21cfa1:	4c 8d b4 24 b0 00 00 	lea    r14,[rsp+0xb0]
  21cfa8:	00 
            try self.readNoEof(result[0..]);
  21cfa9:	4c 89 74 24 18       	mov    QWORD PTR [rsp+0x18],r14
  21cfae:	48 c7 44 24 20 01 00 	mov    QWORD PTR [rsp+0x20],0x1
  21cfb5:	00 00 
  21cfb7:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  21cfbc:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  21cfc1:	4c 89 e6             	mov    rsi,r12
  21cfc4:	41 ff 14 24          	call   QWORD PTR [r12]
  21cfc8:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  21cfcd:	66 85 c0             	test   ax,ax
  21cfd0:	0f 84 45 07 00 00    	je     21d71b <parseFormValue+0x132b>
  21cfd6:	48 8b 4c 24 68       	mov    rcx,QWORD PTR [rsp+0x68]
            const size = try readULeb128(in_stream);
  21cfdb:	66 89 01             	mov    WORD PTR [rcx],ax
  21cfde:	48 8b 84 24 8e 06 00 	mov    rax,QWORD PTR [rsp+0x68e]
  21cfe5:	00 
  21cfe6:	48 89 41 20          	mov    QWORD PTR [rcx+0x20],rax
  21cfea:	c5 fc 10 84 24 70 06 	vmovups ymm0,YMMWORD PTR [rsp+0x670]
  21cff1:	00 00 
  21cff3:	c5 fc 11 41 02       	vmovups YMMWORD PTR [rcx+0x2],ymm0
  21cff8:	e9 0a 0e 00 00       	jmp    21de07 <parseFormValue+0x1a17>
  21cffd:	48 8d 05 24 b1 fe ff 	lea    rax,[rip+0xfffffffffffeb124]        # 208128 <__unnamed_82>
  21d004:	e9 ed 0d 00 00       	jmp    21ddf6 <parseFormValue+0x1a06>
  21d009:	48 8d 44 24 78       	lea    rax,[rsp+0x78]
            try self.readNoEof(bytes[0..]);
  21d00e:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  21d013:	48 c7 44 24 20 08 00 	mov    QWORD PTR [rsp+0x20],0x8
  21d01a:	00 00 
  21d01c:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  21d021:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  21d026:	4c 89 e6             	mov    rsi,r12
  21d029:	41 ff 14 24          	call   QWORD PTR [r12]
  21d02d:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  21d032:	66 85 c0             	test   ax,ax
  21d035:	75 14                	jne    21d04b <parseFormValue+0xc5b>
  21d037:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  21d03c:	66 b8 1f 00          	mov    ax,0x1f
            if (amt_read < buf.len) return error.EndOfStream;
  21d040:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  21d045:	0f 83 64 0a 00 00    	jae    21daaf <parseFormValue+0x16bf>
        DW.FORM_ref_sig8 => FormValue{ .RefSig8 = try in_stream.readIntLe(u64) },
  21d04b:	66 41 89 06          	mov    WORD PTR [r14],ax
  21d04f:	48 8b 84 24 aa 05 00 	mov    rax,QWORD PTR [rsp+0x5aa]
  21d056:	00 
  21d057:	49 89 46 20          	mov    QWORD PTR [r14+0x20],rax
  21d05b:	c5 fc 10 84 24 8c 05 	vmovups ymm0,YMMWORD PTR [rsp+0x58c]
  21d062:	00 00 
  21d064:	e9 a0 01 00 00       	jmp    21d209 <parseFormValue+0xe19>
  21d069:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  21d06e:	31 ed                	xor    ebp,ebp
  21d070:	4c 8d 7c 24 18       	lea    r15,[rsp+0x18]
  21d075:	45 31 ed             	xor    r13d,r13d
  21d078:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  21d07f:	00 
  21d080:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  21d085:	0f 82 11 07 00 00    	jb     21d79c <parseFormValue+0x13ac>
            return result[0];
  21d08b:	0f b6 84 24 b0 00 00 	movzx  eax,BYTE PTR [rsp+0xb0]
  21d092:	00 
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  21d093:	89 c2                	mov    edx,eax
  21d095:	83 e2 7f             	and    edx,0x7f
  21d098:	44 89 ee             	mov    esi,r13d
  21d09b:	83 e6 3f             	and    esi,0x3f
  21d09e:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  21d0a3:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  21d0a8:	48 39 d6             	cmp    rsi,rdx
  21d0ab:	0f 85 f4 06 00 00    	jne    21d7a5 <parseFormValue+0x13b5>
        result |= operand;
  21d0b1:	48 09 cd             	or     rbp,rcx
        if ((byte & 0b10000000) == 0) return result;
  21d0b4:	84 c0                	test   al,al
  21d0b6:	0f 89 5d 0a 00 00    	jns    21db19 <parseFormValue+0x1729>
        shift += 7;
  21d0bc:	49 83 c5 07          	add    r13,0x7
            try self.readNoEof(result[0..]);
  21d0c0:	4c 89 74 24 18       	mov    QWORD PTR [rsp+0x18],r14
  21d0c5:	48 c7 44 24 20 01 00 	mov    QWORD PTR [rsp+0x20],0x1
  21d0cc:	00 00 
            return self.readFn(self, buffer);
  21d0ce:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  21d0d3:	4c 89 e6             	mov    rsi,r12
  21d0d6:	4c 89 fa             	mov    rdx,r15
  21d0d9:	41 ff 14 24          	call   QWORD PTR [r12]
  21d0dd:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
  21d0e2:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
            const amt_read = try self.read(buf);
  21d0e7:	66 85 c0             	test   ax,ax
  21d0ea:	74 94                	je     21d080 <parseFormValue+0xc90>
  21d0ec:	e9 86 f3 ff ff       	jmp    21c477 <parseFormValue+0x87>
  21d0f1:	48 8d 44 24 78       	lea    rax,[rsp+0x78]
            try self.readNoEof(bytes[0..]);
  21d0f6:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  21d0fb:	48 c7 44 24 20 04 00 	mov    QWORD PTR [rsp+0x20],0x4
  21d102:	00 00 
  21d104:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  21d109:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  21d10e:	4c 89 e6             	mov    rsi,r12
  21d111:	41 ff 14 24          	call   QWORD PTR [r12]
  21d115:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  21d11a:	66 85 c0             	test   ax,ax
  21d11d:	75 14                	jne    21d133 <parseFormValue+0xd43>
  21d11f:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  21d124:	66 b8 1f 00          	mov    ax,0x1f
            if (amt_read < buf.len) return error.EndOfStream;
  21d128:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  21d12d:	0f 83 1e 0b 00 00    	jae    21dc51 <parseFormValue+0x1861>
        DW.FORM_strp => FormValue{ .StrPtr = try parseFormValueDwarfOffsetSize(in_stream, is_64) },
  21d133:	66 41 89 06          	mov    WORD PTR [r14],ax
  21d137:	48 8b 84 24 5e 05 00 	mov    rax,QWORD PTR [rsp+0x55e]
  21d13e:	00 
  21d13f:	49 89 46 20          	mov    QWORD PTR [r14+0x20],rax
  21d143:	c5 fc 10 84 24 40 05 	vmovups ymm0,YMMWORD PTR [rsp+0x540]
  21d14a:	00 00 
  21d14c:	e9 b8 00 00 00       	jmp    21d209 <parseFormValue+0xe19>
  21d151:	48 8d 44 24 78       	lea    rax,[rsp+0x78]
            try self.readNoEof(bytes[0..]);
  21d156:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  21d15b:	48 c7 44 24 20 04 00 	mov    QWORD PTR [rsp+0x20],0x4
  21d162:	00 00 
  21d164:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  21d169:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  21d16e:	4c 89 e6             	mov    rsi,r12
  21d171:	41 ff 14 24          	call   QWORD PTR [r12]
  21d175:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  21d17a:	66 85 c0             	test   ax,ax
  21d17d:	75 14                	jne    21d193 <parseFormValue+0xda3>
  21d17f:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  21d184:	66 b8 1f 00          	mov    ax,0x1f
            if (amt_read < buf.len) return error.EndOfStream;
  21d188:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  21d18d:	0f 83 4c 0b 00 00    	jae    21dcdf <parseFormValue+0x18ef>
        DW.FORM_ref_addr => FormValue{ .RefAddr = try parseFormValueDwarfOffsetSize(in_stream, is_64) },
  21d193:	66 41 89 06          	mov    WORD PTR [r14],ax
  21d197:	48 8b 84 24 d0 05 00 	mov    rax,QWORD PTR [rsp+0x5d0]
  21d19e:	00 
  21d19f:	49 89 46 20          	mov    QWORD PTR [r14+0x20],rax
  21d1a3:	c5 fc 10 84 24 b2 05 	vmovups ymm0,YMMWORD PTR [rsp+0x5b2]
  21d1aa:	00 00 
  21d1ac:	eb 5b                	jmp    21d209 <parseFormValue+0xe19>
  21d1ae:	48 8d 44 24 78       	lea    rax,[rsp+0x78]
            try self.readNoEof(bytes[0..]);
  21d1b3:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  21d1b8:	48 c7 44 24 20 04 00 	mov    QWORD PTR [rsp+0x20],0x4
  21d1bf:	00 00 
  21d1c1:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  21d1c6:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  21d1cb:	4c 89 e6             	mov    rsi,r12
  21d1ce:	41 ff 14 24          	call   QWORD PTR [r12]
  21d1d2:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  21d1d7:	66 85 c0             	test   ax,ax
  21d1da:	75 14                	jne    21d1f0 <parseFormValue+0xe00>
  21d1dc:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  21d1e1:	66 b8 1f 00          	mov    ax,0x1f
            if (amt_read < buf.len) return error.EndOfStream;
  21d1e5:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  21d1ea:	0f 83 7d 0b 00 00    	jae    21dd6d <parseFormValue+0x197d>
        DW.FORM_sec_offset => FormValue{ .SecOffset = try parseFormValueDwarfOffsetSize(in_stream, is_64) },
  21d1f0:	66 41 89 06          	mov    WORD PTR [r14],ax
  21d1f4:	48 8b 84 24 1c 06 00 	mov    rax,QWORD PTR [rsp+0x61c]
  21d1fb:	00 
  21d1fc:	49 89 46 20          	mov    QWORD PTR [r14+0x20],rax
  21d200:	c5 fc 10 84 24 fe 05 	vmovups ymm0,YMMWORD PTR [rsp+0x5fe]
  21d207:	00 00 
  21d209:	c4 c1 7c 11 46 02    	vmovups YMMWORD PTR [r14+0x2],ymm0
  21d20f:	e9 f3 0b 00 00       	jmp    21de07 <parseFormValue+0x1a17>
    return FormValue{
  21d214:	c6 84 24 b0 00 00 00 	mov    BYTE PTR [rsp+0xb0],0x0
  21d21b:	00 
  21d21c:	c6 44 24 60 02       	mov    BYTE PTR [rsp+0x60],0x2
  21d221:	66 c7 84 24 78 01 00 	mov    WORD PTR [rsp+0x178],0x0
  21d228:	00 00 00 
  21d22b:	8b 44 24 78          	mov    eax,DWORD PTR [rsp+0x78]
  21d22f:	89 84 24 7a 01 00 00 	mov    DWORD PTR [rsp+0x17a],eax
        .Const = Constant{
  21d236:	c5 f8 10 44 24 48    	vmovups xmm0,XMMWORD PTR [rsp+0x48]
    return FormValue{
  21d23c:	0f b7 44 24 7c       	movzx  eax,WORD PTR [rsp+0x7c]
  21d241:	66 89 84 24 7e 01 00 	mov    WORD PTR [rsp+0x17e],ax
  21d248:	00 
  21d249:	c5 f8 11 84 24 80 01 	vmovups XMMWORD PTR [rsp+0x180],xmm0
  21d250:	00 00 
  21d252:	c6 84 24 90 01 00 00 	mov    BYTE PTR [rsp+0x190],0x0
  21d259:	00 
  21d25a:	8b 84 24 90 00 00 00 	mov    eax,DWORD PTR [rsp+0x90]
  21d261:	89 84 24 91 01 00 00 	mov    DWORD PTR [rsp+0x191],eax
  21d268:	0f b7 84 24 94 00 00 	movzx  eax,WORD PTR [rsp+0x94]
  21d26f:	00 
  21d270:	66 89 84 24 95 01 00 	mov    WORD PTR [rsp+0x195],ax
  21d277:	00 
  21d278:	8a 84 24 96 00 00 00 	mov    al,BYTE PTR [rsp+0x96]
  21d27f:	88 84 24 97 01 00 00 	mov    BYTE PTR [rsp+0x197],al
  21d286:	c6 84 24 98 01 00 00 	mov    BYTE PTR [rsp+0x198],0x2
  21d28d:	02 
  21d28e:	8a 44 24 1e          	mov    al,BYTE PTR [rsp+0x1e]
  21d292:	88 84 24 9f 01 00 00 	mov    BYTE PTR [rsp+0x19f],al
  21d299:	0f b7 44 24 1c       	movzx  eax,WORD PTR [rsp+0x1c]
  21d29e:	66 89 84 24 9d 01 00 	mov    WORD PTR [rsp+0x19d],ax
  21d2a5:	00 
  21d2a6:	8b 44 24 18          	mov    eax,DWORD PTR [rsp+0x18]
  21d2aa:	89 84 24 99 01 00 00 	mov    DWORD PTR [rsp+0x199],eax
  21d2b1:	48 8d 84 24 78 01 00 	lea    rax,[rsp+0x178]
  21d2b8:	00 
  21d2b9:	e9 38 0b 00 00       	jmp    21ddf6 <parseFormValue+0x1a06>
  21d2be:	c6 84 24 b0 00 00 00 	mov    BYTE PTR [rsp+0xb0],0x0
  21d2c5:	00 
  21d2c6:	c6 44 24 60 02       	mov    BYTE PTR [rsp+0x60],0x2
  21d2cb:	66 c7 84 24 50 01 00 	mov    WORD PTR [rsp+0x150],0x0
  21d2d2:	00 00 00 
  21d2d5:	8b 44 24 78          	mov    eax,DWORD PTR [rsp+0x78]
  21d2d9:	89 84 24 52 01 00 00 	mov    DWORD PTR [rsp+0x152],eax
        .Const = Constant{
  21d2e0:	c5 f8 10 44 24 48    	vmovups xmm0,XMMWORD PTR [rsp+0x48]
    return FormValue{
  21d2e6:	0f b7 44 24 7c       	movzx  eax,WORD PTR [rsp+0x7c]
  21d2eb:	66 89 84 24 56 01 00 	mov    WORD PTR [rsp+0x156],ax
  21d2f2:	00 
  21d2f3:	c5 f8 11 84 24 58 01 	vmovups XMMWORD PTR [rsp+0x158],xmm0
  21d2fa:	00 00 
  21d2fc:	c6 84 24 68 01 00 00 	mov    BYTE PTR [rsp+0x168],0x0
  21d303:	00 
  21d304:	8b 84 24 90 00 00 00 	mov    eax,DWORD PTR [rsp+0x90]
  21d30b:	89 84 24 69 01 00 00 	mov    DWORD PTR [rsp+0x169],eax
  21d312:	0f b7 84 24 94 00 00 	movzx  eax,WORD PTR [rsp+0x94]
  21d319:	00 
  21d31a:	66 89 84 24 6d 01 00 	mov    WORD PTR [rsp+0x16d],ax
  21d321:	00 
  21d322:	8a 84 24 96 00 00 00 	mov    al,BYTE PTR [rsp+0x96]
  21d329:	88 84 24 6f 01 00 00 	mov    BYTE PTR [rsp+0x16f],al
  21d330:	c6 84 24 70 01 00 00 	mov    BYTE PTR [rsp+0x170],0x2
  21d337:	02 
  21d338:	8a 44 24 1e          	mov    al,BYTE PTR [rsp+0x1e]
  21d33c:	88 84 24 77 01 00 00 	mov    BYTE PTR [rsp+0x177],al
  21d343:	0f b7 44 24 1c       	movzx  eax,WORD PTR [rsp+0x1c]
  21d348:	66 89 84 24 75 01 00 	mov    WORD PTR [rsp+0x175],ax
  21d34f:	00 
  21d350:	8b 44 24 18          	mov    eax,DWORD PTR [rsp+0x18]
  21d354:	89 84 24 71 01 00 00 	mov    DWORD PTR [rsp+0x171],eax
  21d35b:	48 8d 84 24 50 01 00 	lea    rax,[rsp+0x150]
  21d362:	00 
  21d363:	e9 8e 0a 00 00       	jmp    21ddf6 <parseFormValue+0x1a06>
  21d368:	c6 84 24 b0 00 00 00 	mov    BYTE PTR [rsp+0xb0],0x0
  21d36f:	00 
  21d370:	c6 44 24 60 02       	mov    BYTE PTR [rsp+0x60],0x2
  21d375:	66 c7 84 24 28 01 00 	mov    WORD PTR [rsp+0x128],0x0
  21d37c:	00 00 00 
  21d37f:	8b 44 24 78          	mov    eax,DWORD PTR [rsp+0x78]
  21d383:	89 84 24 2a 01 00 00 	mov    DWORD PTR [rsp+0x12a],eax
        .Const = Constant{
  21d38a:	c5 f8 10 44 24 48    	vmovups xmm0,XMMWORD PTR [rsp+0x48]
    return FormValue{
  21d390:	0f b7 44 24 7c       	movzx  eax,WORD PTR [rsp+0x7c]
  21d395:	66 89 84 24 2e 01 00 	mov    WORD PTR [rsp+0x12e],ax
  21d39c:	00 
  21d39d:	c5 f8 11 84 24 30 01 	vmovups XMMWORD PTR [rsp+0x130],xmm0
  21d3a4:	00 00 
  21d3a6:	c6 84 24 40 01 00 00 	mov    BYTE PTR [rsp+0x140],0x0
  21d3ad:	00 
  21d3ae:	8b 84 24 90 00 00 00 	mov    eax,DWORD PTR [rsp+0x90]
  21d3b5:	89 84 24 41 01 00 00 	mov    DWORD PTR [rsp+0x141],eax
  21d3bc:	0f b7 84 24 94 00 00 	movzx  eax,WORD PTR [rsp+0x94]
  21d3c3:	00 
  21d3c4:	66 89 84 24 45 01 00 	mov    WORD PTR [rsp+0x145],ax
  21d3cb:	00 
  21d3cc:	8a 84 24 96 00 00 00 	mov    al,BYTE PTR [rsp+0x96]
  21d3d3:	88 84 24 47 01 00 00 	mov    BYTE PTR [rsp+0x147],al
  21d3da:	c6 84 24 48 01 00 00 	mov    BYTE PTR [rsp+0x148],0x2
  21d3e1:	02 
  21d3e2:	8a 44 24 1e          	mov    al,BYTE PTR [rsp+0x1e]
  21d3e6:	88 84 24 4f 01 00 00 	mov    BYTE PTR [rsp+0x14f],al
  21d3ed:	0f b7 44 24 1c       	movzx  eax,WORD PTR [rsp+0x1c]
  21d3f2:	66 89 84 24 4d 01 00 	mov    WORD PTR [rsp+0x14d],ax
  21d3f9:	00 
  21d3fa:	8b 44 24 18          	mov    eax,DWORD PTR [rsp+0x18]
  21d3fe:	89 84 24 49 01 00 00 	mov    DWORD PTR [rsp+0x149],eax
  21d405:	48 8d 84 24 28 01 00 	lea    rax,[rsp+0x128]
  21d40c:	00 
  21d40d:	e9 e4 09 00 00       	jmp    21ddf6 <parseFormValue+0x1a06>
  21d412:	48 8b 4c 24 20       	mov    rcx,QWORD PTR [rsp+0x20]
  21d417:	45 31 ed             	xor    r13d,r13d
  21d41a:	48 8d 5c 24 18       	lea    rbx,[rsp+0x18]
  21d41f:	31 ed                	xor    ebp,ebp
  21d421:	48 3b 8c 24 98 00 00 	cmp    rcx,QWORD PTR [rsp+0x98]
  21d428:	00 
  21d429:	0f 82 90 07 00 00    	jb     21dbbf <parseFormValue+0x17cf>
            return result[0];
  21d42f:	44 8a bc 24 b0 00 00 	mov    r15b,BYTE PTR [rsp+0xb0]
  21d436:	00 
        if (byte == 0) break;
  21d437:	45 84 ff             	test   r15b,r15b
  21d43a:	0f 84 88 07 00 00    	je     21dbc8 <parseFormValue+0x17d8>
            var better_capacity = self.items.len;
  21d440:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
            if (better_capacity >= new_capacity) return;
  21d445:	48 39 e9             	cmp    rcx,rbp
  21d448:	77 4f                	ja     21d499 <parseFormValue+0x10a9>
  21d44a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
                better_capacity += better_capacity / 2 + 8;
  21d450:	48 89 c8             	mov    rax,rcx
  21d453:	48 d1 e8             	shr    rax,1
  21d456:	48 01 c1             	add    rcx,rax
  21d459:	48 83 c1 08          	add    rcx,0x8
                if (better_capacity >= new_capacity) break;
  21d45d:	48 39 e9             	cmp    rcx,rbp
  21d460:	76 ee                	jbe    21d450 <parseFormValue+0x1060>
            self.items = try self.allocator.alignedRealloc(T, A, self.items, better_capacity);
  21d462:	48 89 df             	mov    rdi,rbx
  21d465:	48 8b b4 24 d0 00 00 	mov    rsi,QWORD PTR [rsp+0xd0]
  21d46c:	00 
  21d46d:	48 8d 54 24 40       	lea    rdx,[rsp+0x40]
  21d472:	e8 49 47 00 00       	call   221bc0 <Allocator_alignedRealloc.86>
  21d477:	0f b7 44 24 18       	movzx  eax,WORD PTR [rsp+0x18]
  21d47c:	66 85 c0             	test   ax,ax
  21d47f:	0f 85 08 f4 ff ff    	jne    21c88d <parseFormValue+0x49d>
  21d485:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  21d48a:	c5 f8 10 00          	vmovups xmm0,XMMWORD PTR [rax]
  21d48e:	c5 f8 29 44 24 40    	vmovaps XMMWORD PTR [rsp+0x40],xmm0
            const result = &self.items[self.len];
  21d494:	4c 8b 6c 24 40       	mov    r13,QWORD PTR [rsp+0x40]
  21d499:	4c 8d 75 01          	lea    r14,[rbp+0x1]
            self.len = new_length;
  21d49d:	4c 89 74 24 50       	mov    QWORD PTR [rsp+0x50],r14
            new_item_ptr.* = item;
  21d4a2:	45 88 7c 2d 00       	mov    BYTE PTR [r13+rbp*1+0x0],r15b
            try self.readNoEof(result[0..]);
  21d4a7:	48 8d 84 24 b0 00 00 	lea    rax,[rsp+0xb0]
  21d4ae:	00 
  21d4af:	48 89 84 24 90 00 00 	mov    QWORD PTR [rsp+0x90],rax
  21d4b6:	00 
  21d4b7:	48 c7 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],0x1
  21d4be:	00 01 00 00 00 
            return self.readFn(self, buffer);
  21d4c3:	48 89 df             	mov    rdi,rbx
  21d4c6:	4c 89 e6             	mov    rsi,r12
  21d4c9:	48 8d 94 24 90 00 00 	lea    rdx,[rsp+0x90]
  21d4d0:	00 
  21d4d1:	41 ff 14 24          	call   QWORD PTR [r12]
  21d4d5:	0f b7 44 24 18       	movzx  eax,WORD PTR [rsp+0x18]
  21d4da:	48 8b 4c 24 20       	mov    rcx,QWORD PTR [rsp+0x20]
  21d4df:	4c 89 f5             	mov    rbp,r14
            const amt_read = try self.read(buf);
  21d4e2:	66 85 c0             	test   ax,ax
  21d4e5:	0f 84 36 ff ff ff    	je     21d421 <parseFormValue+0x1031>
  21d4eb:	e9 9d f3 ff ff       	jmp    21c88d <parseFormValue+0x49d>
  21d4f0:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  21d4f5:	31 db                	xor    ebx,ebx
  21d4f7:	4c 8d 7c 24 40       	lea    r15,[rsp+0x40]
  21d4fc:	4c 8d 74 24 18       	lea    r14,[rsp+0x18]
  21d501:	31 ed                	xor    ebp,ebp
            if (amt_read < buf.len) return error.EndOfStream;
  21d503:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  21d508:	0f 82 1f 07 00 00    	jb     21dc2d <parseFormValue+0x183d>
            return result[0];
  21d50e:	0f b6 84 24 b0 00 00 	movzx  eax,BYTE PTR [rsp+0xb0]
  21d515:	00 
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  21d516:	89 c2                	mov    edx,eax
  21d518:	83 e2 7f             	and    edx,0x7f
  21d51b:	89 ee                	mov    esi,ebp
  21d51d:	83 e6 3f             	and    esi,0x3f
  21d520:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  21d525:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  21d52a:	48 39 d6             	cmp    rsi,rdx
  21d52d:	0f 85 e9 08 00 00    	jne    21de1c <parseFormValue+0x1a2c>
        result |= operand;
  21d533:	48 09 cb             	or     rbx,rcx
        if ((byte & 0b10000000) == 0) return result;
  21d536:	84 c0                	test   al,al
  21d538:	0f 89 02 09 00 00    	jns    21de40 <parseFormValue+0x1a50>
        shift += 7;
  21d53e:	48 83 c5 07          	add    rbp,0x7
            try self.readNoEof(result[0..]);
  21d542:	4c 89 6c 24 18       	mov    QWORD PTR [rsp+0x18],r13
  21d547:	48 c7 44 24 20 01 00 	mov    QWORD PTR [rsp+0x20],0x1
  21d54e:	00 00 
            return self.readFn(self, buffer);
  21d550:	4c 89 ff             	mov    rdi,r15
  21d553:	4c 89 e6             	mov    rsi,r12
  21d556:	4c 89 f2             	mov    rdx,r14
  21d559:	41 ff 14 24          	call   QWORD PTR [r12]
  21d55d:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
  21d562:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
            const amt_read = try self.read(buf);
  21d567:	66 85 c0             	test   ax,ax
  21d56a:	74 97                	je     21d503 <parseFormValue+0x1113>
  21d56c:	e9 85 f3 ff ff       	jmp    21c8f6 <parseFormValue+0x506>
    return FormValue{
  21d571:	c6 84 24 b0 00 00 00 	mov    BYTE PTR [rsp+0xb0],0x0
  21d578:	00 
  21d579:	c6 44 24 60 02       	mov    BYTE PTR [rsp+0x60],0x2
  21d57e:	66 c7 84 24 a0 01 00 	mov    WORD PTR [rsp+0x1a0],0x0
  21d585:	00 00 00 
  21d588:	8b 44 24 78          	mov    eax,DWORD PTR [rsp+0x78]
  21d58c:	89 84 24 a2 01 00 00 	mov    DWORD PTR [rsp+0x1a2],eax
        .Const = Constant{
  21d593:	c5 f8 10 44 24 48    	vmovups xmm0,XMMWORD PTR [rsp+0x48]
    return FormValue{
  21d599:	0f b7 44 24 7c       	movzx  eax,WORD PTR [rsp+0x7c]
  21d59e:	66 89 84 24 a6 01 00 	mov    WORD PTR [rsp+0x1a6],ax
  21d5a5:	00 
  21d5a6:	c5 f8 11 84 24 a8 01 	vmovups XMMWORD PTR [rsp+0x1a8],xmm0
  21d5ad:	00 00 
  21d5af:	c6 84 24 b8 01 00 00 	mov    BYTE PTR [rsp+0x1b8],0x0
  21d5b6:	00 
  21d5b7:	8b 84 24 90 00 00 00 	mov    eax,DWORD PTR [rsp+0x90]
  21d5be:	89 84 24 b9 01 00 00 	mov    DWORD PTR [rsp+0x1b9],eax
  21d5c5:	0f b7 84 24 94 00 00 	movzx  eax,WORD PTR [rsp+0x94]
  21d5cc:	00 
  21d5cd:	66 89 84 24 bd 01 00 	mov    WORD PTR [rsp+0x1bd],ax
  21d5d4:	00 
  21d5d5:	8a 84 24 96 00 00 00 	mov    al,BYTE PTR [rsp+0x96]
  21d5dc:	88 84 24 bf 01 00 00 	mov    BYTE PTR [rsp+0x1bf],al
  21d5e3:	c6 84 24 c0 01 00 00 	mov    BYTE PTR [rsp+0x1c0],0x2
  21d5ea:	02 
  21d5eb:	8a 44 24 1e          	mov    al,BYTE PTR [rsp+0x1e]
  21d5ef:	88 84 24 c7 01 00 00 	mov    BYTE PTR [rsp+0x1c7],al
  21d5f6:	0f b7 44 24 1c       	movzx  eax,WORD PTR [rsp+0x1c]
  21d5fb:	66 89 84 24 c5 01 00 	mov    WORD PTR [rsp+0x1c5],ax
  21d602:	00 
  21d603:	8b 44 24 18          	mov    eax,DWORD PTR [rsp+0x18]
  21d607:	89 84 24 c1 01 00 00 	mov    DWORD PTR [rsp+0x1c1],eax
  21d60e:	48 8d 84 24 a0 01 00 	lea    rax,[rsp+0x1a0]
  21d615:	00 
  21d616:	e9 db 07 00 00       	jmp    21ddf6 <parseFormValue+0x1a06>
  21d61b:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  21d620:	31 db                	xor    ebx,ebx
  21d622:	4c 8d 6c 24 40       	lea    r13,[rsp+0x40]
  21d627:	4c 8d 7c 24 18       	lea    r15,[rsp+0x18]
  21d62c:	31 ed                	xor    ebp,ebp
            if (amt_read < buf.len) return error.EndOfStream;
  21d62e:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  21d633:	0f 82 fd 05 00 00    	jb     21dc36 <parseFormValue+0x1846>
            return result[0];
  21d639:	0f b6 84 24 b0 00 00 	movzx  eax,BYTE PTR [rsp+0xb0]
  21d640:	00 
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  21d641:	89 c2                	mov    edx,eax
  21d643:	83 e2 7f             	and    edx,0x7f
  21d646:	89 ee                	mov    esi,ebp
  21d648:	83 e6 3f             	and    esi,0x3f
  21d64b:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  21d650:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  21d655:	48 39 d6             	cmp    rsi,rdx
  21d658:	0f 85 c7 07 00 00    	jne    21de25 <parseFormValue+0x1a35>
        result |= operand;
  21d65e:	48 09 cb             	or     rbx,rcx
        if ((byte & 0b10000000) == 0) return result;
  21d661:	84 c0                	test   al,al
  21d663:	0f 89 7d 08 00 00    	jns    21dee6 <parseFormValue+0x1af6>
        shift += 7;
  21d669:	48 83 c5 07          	add    rbp,0x7
            try self.readNoEof(result[0..]);
  21d66d:	4c 89 74 24 18       	mov    QWORD PTR [rsp+0x18],r14
  21d672:	48 c7 44 24 20 01 00 	mov    QWORD PTR [rsp+0x20],0x1
  21d679:	00 00 
            return self.readFn(self, buffer);
  21d67b:	4c 89 ef             	mov    rdi,r13
  21d67e:	4c 89 e6             	mov    rsi,r12
  21d681:	4c 89 fa             	mov    rdx,r15
  21d684:	41 ff 14 24          	call   QWORD PTR [r12]
  21d688:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
  21d68d:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
            const amt_read = try self.read(buf);
  21d692:	66 85 c0             	test   ax,ax
  21d695:	74 97                	je     21d62e <parseFormValue+0x123e>
  21d697:	e9 08 f8 ff ff       	jmp    21cea4 <parseFormValue+0xab4>
  21d69c:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  21d6a1:	45 31 f6             	xor    r14d,r14d
  21d6a4:	4c 8d 6c 24 18       	lea    r13,[rsp+0x18]
  21d6a9:	31 db                	xor    ebx,ebx
            if (amt_read < buf.len) return error.EndOfStream;
  21d6ab:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  21d6b0:	0f 82 89 05 00 00    	jb     21dc3f <parseFormValue+0x184f>
            return result[0];
  21d6b6:	0f b6 84 24 b0 00 00 	movzx  eax,BYTE PTR [rsp+0xb0]
  21d6bd:	00 
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  21d6be:	89 c2                	mov    edx,eax
  21d6c0:	83 e2 7f             	and    edx,0x7f
  21d6c3:	89 de                	mov    esi,ebx
  21d6c5:	83 e6 3f             	and    esi,0x3f
  21d6c8:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  21d6cd:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  21d6d2:	48 39 d6             	cmp    rsi,rdx
  21d6d5:	0f 85 53 07 00 00    	jne    21de2e <parseFormValue+0x1a3e>
        result |= operand;
  21d6db:	49 09 ce             	or     r14,rcx
        if ((byte & 0b10000000) == 0) return result;
  21d6de:	84 c0                	test   al,al
  21d6e0:	0f 89 a6 08 00 00    	jns    21df8c <parseFormValue+0x1b9c>
        shift += 7;
  21d6e6:	48 83 c3 07          	add    rbx,0x7
            try self.readNoEof(result[0..]);
  21d6ea:	4c 89 7c 24 18       	mov    QWORD PTR [rsp+0x18],r15
  21d6ef:	48 c7 44 24 20 01 00 	mov    QWORD PTR [rsp+0x20],0x1
  21d6f6:	00 00 
            return self.readFn(self, buffer);
  21d6f8:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  21d6fd:	4c 89 e6             	mov    rsi,r12
  21d700:	4c 89 ea             	mov    rdx,r13
  21d703:	41 ff 14 24          	call   QWORD PTR [r12]
  21d707:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
  21d70c:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
            const amt_read = try self.read(buf);
  21d711:	66 85 c0             	test   ax,ax
  21d714:	74 95                	je     21d6ab <parseFormValue+0x12bb>
  21d716:	e9 f2 f7 ff ff       	jmp    21cf0d <parseFormValue+0xb1d>
  21d71b:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  21d720:	31 db                	xor    ebx,ebx
  21d722:	4c 8d 6c 24 40       	lea    r13,[rsp+0x40]
  21d727:	4c 8d 7c 24 18       	lea    r15,[rsp+0x18]
  21d72c:	31 ed                	xor    ebp,ebp
            if (amt_read < buf.len) return error.EndOfStream;
  21d72e:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  21d733:	0f 82 0f 05 00 00    	jb     21dc48 <parseFormValue+0x1858>
            return result[0];
  21d739:	0f b6 84 24 b0 00 00 	movzx  eax,BYTE PTR [rsp+0xb0]
  21d740:	00 
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  21d741:	89 c2                	mov    edx,eax
  21d743:	83 e2 7f             	and    edx,0x7f
  21d746:	89 ee                	mov    esi,ebp
  21d748:	83 e6 3f             	and    esi,0x3f
  21d74b:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  21d750:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  21d755:	48 39 d6             	cmp    rsi,rdx
  21d758:	0f 85 d9 06 00 00    	jne    21de37 <parseFormValue+0x1a47>
        result |= operand;
  21d75e:	48 09 cb             	or     rbx,rcx
        if ((byte & 0b10000000) == 0) return result;
  21d761:	84 c0                	test   al,al
  21d763:	0f 89 65 08 00 00    	jns    21dfce <parseFormValue+0x1bde>
        shift += 7;
  21d769:	48 83 c5 07          	add    rbp,0x7
            try self.readNoEof(result[0..]);
  21d76d:	4c 89 74 24 18       	mov    QWORD PTR [rsp+0x18],r14
  21d772:	48 c7 44 24 20 01 00 	mov    QWORD PTR [rsp+0x20],0x1
  21d779:	00 00 
            return self.readFn(self, buffer);
  21d77b:	4c 89 ef             	mov    rdi,r13
  21d77e:	4c 89 e6             	mov    rsi,r12
  21d781:	4c 89 fa             	mov    rdx,r15
  21d784:	41 ff 14 24          	call   QWORD PTR [r12]
  21d788:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
  21d78d:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
            const amt_read = try self.read(buf);
  21d792:	66 85 c0             	test   ax,ax
  21d795:	74 97                	je     21d72e <parseFormValue+0x133e>
  21d797:	e9 3a f8 ff ff       	jmp    21cfd6 <parseFormValue+0xbe6>
  21d79c:	66 b8 1f 00          	mov    ax,0x1f
  21d7a0:	e9 d2 ec ff ff       	jmp    21c477 <parseFormValue+0x87>
  21d7a5:	66 b8 23 00          	mov    ax,0x23
  21d7a9:	e9 c9 ec ff ff       	jmp    21c477 <parseFormValue+0x87>
  21d7ae:	48 8b 44 24 78       	mov    rax,QWORD PTR [rsp+0x78]
        DW.FORM_addr => FormValue{ .Address = try parseFormValueTargetAddrSize(in_stream) },
  21d7b3:	66 c7 84 24 08 04 00 	mov    WORD PTR [rsp+0x408],0x0
  21d7ba:	00 00 00 
  21d7bd:	48 89 84 24 10 04 00 	mov    QWORD PTR [rsp+0x410],rax
  21d7c4:	00 
  21d7c5:	c5 f8 10 84 24 08 05 	vmovups xmm0,XMMWORD PTR [rsp+0x508]
  21d7cc:	00 00 
  21d7ce:	c5 f8 11 84 24 18 04 	vmovups XMMWORD PTR [rsp+0x418],xmm0
  21d7d5:	00 00 
  21d7d7:	c6 84 24 28 04 00 00 	mov    BYTE PTR [rsp+0x428],0x0
  21d7de:	00 
  21d7df:	8b 84 24 11 03 00 00 	mov    eax,DWORD PTR [rsp+0x311]
  21d7e6:	89 84 24 29 04 00 00 	mov    DWORD PTR [rsp+0x429],eax
  21d7ed:	0f b7 84 24 15 03 00 	movzx  eax,WORD PTR [rsp+0x315]
  21d7f4:	00 
  21d7f5:	66 89 84 24 2d 04 00 	mov    WORD PTR [rsp+0x42d],ax
  21d7fc:	00 
  21d7fd:	8a 84 24 17 03 00 00 	mov    al,BYTE PTR [rsp+0x317]
  21d804:	88 84 24 2f 04 00 00 	mov    BYTE PTR [rsp+0x42f],al
  21d80b:	48 8d 84 24 08 04 00 	lea    rax,[rsp+0x408]
  21d812:	00 
  21d813:	e9 de 05 00 00       	jmp    21ddf6 <parseFormValue+0x1a06>
  21d818:	48 85 c0             	test   rax,rax
            for (bytes) |b, index| {
  21d81b:	0f 84 00 08 00 00    	je     21e021 <parseFormValue+0x1c31>
  21d821:	48 8b 54 24 18       	mov    rdx,QWORD PTR [rsp+0x18]
  21d826:	48 83 f8 10          	cmp    rax,0x10
  21d82a:	0f 83 cc 0b 00 00    	jae    21e3fc <parseFormValue+0x200c>
  21d830:	31 db                	xor    ebx,ebx
  21d832:	31 c9                	xor    ecx,ecx
  21d834:	e9 b7 11 00 00       	jmp    21e9f0 <parseFormValue+0x2600>
  21d839:	48 85 c0             	test   rax,rax
  21d83c:	0f 84 e6 07 00 00    	je     21e028 <parseFormValue+0x1c38>
  21d842:	48 8b 54 24 18       	mov    rdx,QWORD PTR [rsp+0x18]
  21d847:	48 83 f8 10          	cmp    rax,0x10
  21d84b:	0f 83 c9 0c 00 00    	jae    21e51a <parseFormValue+0x212a>
  21d851:	31 db                	xor    ebx,ebx
  21d853:	31 c9                	xor    ecx,ecx
  21d855:	e9 77 13 00 00       	jmp    21ebd1 <parseFormValue+0x27e1>
  21d85a:	48 85 c0             	test   rax,rax
  21d85d:	0f 84 cc 07 00 00    	je     21e02f <parseFormValue+0x1c3f>
  21d863:	48 8b 54 24 18       	mov    rdx,QWORD PTR [rsp+0x18]
  21d868:	48 83 f8 10          	cmp    rax,0x10
  21d86c:	0f 83 c6 0d 00 00    	jae    21e638 <parseFormValue+0x2248>
  21d872:	31 db                	xor    ebx,ebx
  21d874:	31 c9                	xor    ecx,ecx
  21d876:	e9 37 15 00 00       	jmp    21edb2 <parseFormValue+0x29c2>
        DW.FORM_flag => FormValue{ .Flag = (try in_stream.readByte()) != 0 },
  21d87b:	80 bc 24 b0 00 00 00 	cmp    BYTE PTR [rsp+0xb0],0x0
  21d882:	00 
  21d883:	0f 95 84 24 08 01 00 	setne  BYTE PTR [rsp+0x108]
  21d88a:	00 
  21d88b:	66 c7 84 24 18 03 00 	mov    WORD PTR [rsp+0x318],0x0
  21d892:	00 00 00 
  21d895:	0f 95 84 24 20 03 00 	setne  BYTE PTR [rsp+0x320]
  21d89c:	00 
  21d89d:	c5 f8 10 84 24 69 04 	vmovups xmm0,XMMWORD PTR [rsp+0x469]
  21d8a4:	00 00 
  21d8a6:	c5 f8 11 84 24 21 03 	vmovups XMMWORD PTR [rsp+0x321],xmm0
  21d8ad:	00 00 
  21d8af:	48 8b 84 24 78 04 00 	mov    rax,QWORD PTR [rsp+0x478]
  21d8b6:	00 
  21d8b7:	48 89 84 24 30 03 00 	mov    QWORD PTR [rsp+0x330],rax
  21d8be:	00 
  21d8bf:	c6 84 24 38 03 00 00 	mov    BYTE PTR [rsp+0x338],0x4
  21d8c6:	04 
  21d8c7:	8b 84 24 03 03 00 00 	mov    eax,DWORD PTR [rsp+0x303]
  21d8ce:	89 84 24 39 03 00 00 	mov    DWORD PTR [rsp+0x339],eax
  21d8d5:	0f b7 84 24 07 03 00 	movzx  eax,WORD PTR [rsp+0x307]
  21d8dc:	00 
  21d8dd:	66 89 84 24 3d 03 00 	mov    WORD PTR [rsp+0x33d],ax
  21d8e4:	00 
  21d8e5:	8a 84 24 09 03 00 00 	mov    al,BYTE PTR [rsp+0x309]
  21d8ec:	88 84 24 3f 03 00 00 	mov    BYTE PTR [rsp+0x33f],al
  21d8f3:	48 8d 84 24 18 03 00 	lea    rax,[rsp+0x318]
  21d8fa:	00 
  21d8fb:	e9 f6 04 00 00       	jmp    21ddf6 <parseFormValue+0x1a06>
            return mem.readInt(bytes, T, endian);
  21d900:	0f b6 8c 24 b0 00 00 	movzx  ecx,BYTE PTR [rsp+0xb0]
  21d907:	00 
  21d908:	48 8d 7c 24 78       	lea    rdi,[rsp+0x78]
    const buf = try readAllocBytes(allocator, in_stream, size);
  21d90d:	4c 89 fe             	mov    rsi,r15
  21d910:	4c 89 e2             	mov    rdx,r12
  21d913:	e8 68 18 00 00       	call   21f180 <readAllocBytes>
  21d918:	0f b7 44 24 78       	movzx  eax,WORD PTR [rsp+0x78]
  21d91d:	66 85 c0             	test   ax,ax
  21d920:	0f 84 10 07 00 00    	je     21e036 <parseFormValue+0x1c46>
  21d926:	c5 f8 10 44 24 40    	vmovups xmm0,XMMWORD PTR [rsp+0x40]
  21d92c:	c5 fa 6f 4c 24 4e    	vmovdqu xmm1,XMMWORD PTR [rsp+0x4e]
  21d932:	c5 fa 7f 8c 24 9e 00 	vmovdqu XMMWORD PTR [rsp+0x9e],xmm1
  21d939:	00 00 
  21d93b:	c5 f8 29 84 24 90 00 	vmovaps XMMWORD PTR [rsp+0x90],xmm0
  21d942:	00 00 
  21d944:	8b 4c 24 60          	mov    ecx,DWORD PTR [rsp+0x60]
  21d948:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  21d94b:	0f b7 4c 24 64       	movzx  ecx,WORD PTR [rsp+0x64]
  21d950:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  21d955:	8a 4c 24 66          	mov    cl,BYTE PTR [rsp+0x66]
  21d959:	88 4c 24 06          	mov    BYTE PTR [rsp+0x6],cl
  21d95d:	e9 39 07 00 00       	jmp    21e09b <parseFormValue+0x1cab>
  21d962:	0f b6 44 24 78       	movzx  eax,BYTE PTR [rsp+0x78]
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  21d967:	0f b6 4c 24 79       	movzx  ecx,BYTE PTR [rsp+0x79]
  21d96c:	48 c1 e1 08          	shl    rcx,0x8
  21d970:	48 09 c1             	or     rcx,rax
  21d973:	48 8d 7c 24 78       	lea    rdi,[rsp+0x78]
  21d978:	4c 89 fe             	mov    rsi,r15
  21d97b:	4c 89 e2             	mov    rdx,r12
  21d97e:	e8 fd 17 00 00       	call   21f180 <readAllocBytes>
  21d983:	0f b7 44 24 78       	movzx  eax,WORD PTR [rsp+0x78]
  21d988:	66 85 c0             	test   ax,ax
  21d98b:	0f 84 5d 07 00 00    	je     21e0ee <parseFormValue+0x1cfe>
  21d991:	c5 f8 10 44 24 40    	vmovups xmm0,XMMWORD PTR [rsp+0x40]
  21d997:	c5 fa 6f 4c 24 4e    	vmovdqu xmm1,XMMWORD PTR [rsp+0x4e]
  21d99d:	c5 fa 7f 8c 24 9e 00 	vmovdqu XMMWORD PTR [rsp+0x9e],xmm1
  21d9a4:	00 00 
  21d9a6:	c5 f8 29 84 24 90 00 	vmovaps XMMWORD PTR [rsp+0x90],xmm0
  21d9ad:	00 00 
  21d9af:	8b 4c 24 60          	mov    ecx,DWORD PTR [rsp+0x60]
  21d9b3:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  21d9b6:	0f b7 4c 24 64       	movzx  ecx,WORD PTR [rsp+0x64]
  21d9bb:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  21d9c0:	8a 4c 24 66          	mov    cl,BYTE PTR [rsp+0x66]
  21d9c4:	88 4c 24 06          	mov    BYTE PTR [rsp+0x6],cl
  21d9c8:	e9 86 07 00 00       	jmp    21e153 <parseFormValue+0x1d63>
  21d9cd:	0f b6 44 24 78       	movzx  eax,BYTE PTR [rsp+0x78]
  21d9d2:	0f b6 4c 24 79       	movzx  ecx,BYTE PTR [rsp+0x79]
  21d9d7:	48 c1 e1 08          	shl    rcx,0x8
  21d9db:	48 09 c1             	or     rcx,rax
  21d9de:	0f b6 44 24 7a       	movzx  eax,BYTE PTR [rsp+0x7a]
  21d9e3:	48 c1 e0 10          	shl    rax,0x10
  21d9e7:	48 09 c8             	or     rax,rcx
  21d9ea:	0f b6 4c 24 7b       	movzx  ecx,BYTE PTR [rsp+0x7b]
  21d9ef:	48 c1 e1 18          	shl    rcx,0x18
  21d9f3:	48 09 c1             	or     rcx,rax
  21d9f6:	48 8d 7c 24 78       	lea    rdi,[rsp+0x78]
  21d9fb:	4c 89 fe             	mov    rsi,r15
  21d9fe:	4c 89 e2             	mov    rdx,r12
  21da01:	e8 7a 17 00 00       	call   21f180 <readAllocBytes>
  21da06:	0f b7 44 24 78       	movzx  eax,WORD PTR [rsp+0x78]
  21da0b:	66 85 c0             	test   ax,ax
  21da0e:	0f 84 92 07 00 00    	je     21e1a6 <parseFormValue+0x1db6>
  21da14:	c5 f8 10 44 24 40    	vmovups xmm0,XMMWORD PTR [rsp+0x40]
  21da1a:	c5 fa 6f 4c 24 4e    	vmovdqu xmm1,XMMWORD PTR [rsp+0x4e]
  21da20:	c5 fa 7f 8c 24 9e 00 	vmovdqu XMMWORD PTR [rsp+0x9e],xmm1
  21da27:	00 00 
  21da29:	c5 f8 29 84 24 90 00 	vmovaps XMMWORD PTR [rsp+0x90],xmm0
  21da30:	00 00 
  21da32:	8b 4c 24 60          	mov    ecx,DWORD PTR [rsp+0x60]
  21da36:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  21da39:	0f b7 4c 24 64       	movzx  ecx,WORD PTR [rsp+0x64]
  21da3e:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  21da43:	8a 4c 24 66          	mov    cl,BYTE PTR [rsp+0x66]
  21da47:	88 4c 24 06          	mov    BYTE PTR [rsp+0x6],cl
  21da4b:	e9 bb 07 00 00       	jmp    21e20b <parseFormValue+0x1e1b>
  21da50:	48 8b 4c 24 78       	mov    rcx,QWORD PTR [rsp+0x78]
  21da55:	48 8d 7c 24 78       	lea    rdi,[rsp+0x78]
  21da5a:	4c 89 fe             	mov    rsi,r15
  21da5d:	4c 89 e2             	mov    rdx,r12
  21da60:	e8 1b 17 00 00       	call   21f180 <readAllocBytes>
  21da65:	0f b7 44 24 78       	movzx  eax,WORD PTR [rsp+0x78]
  21da6a:	66 85 c0             	test   ax,ax
  21da6d:	0f 84 eb 07 00 00    	je     21e25e <parseFormValue+0x1e6e>
  21da73:	c5 f8 10 44 24 40    	vmovups xmm0,XMMWORD PTR [rsp+0x40]
  21da79:	c5 fa 6f 4c 24 4e    	vmovdqu xmm1,XMMWORD PTR [rsp+0x4e]
  21da7f:	c5 fa 7f 8c 24 9e 00 	vmovdqu XMMWORD PTR [rsp+0x9e],xmm1
  21da86:	00 00 
  21da88:	c5 f8 29 84 24 90 00 	vmovaps XMMWORD PTR [rsp+0x90],xmm0
  21da8f:	00 00 
  21da91:	8b 4c 24 60          	mov    ecx,DWORD PTR [rsp+0x60]
  21da95:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  21da98:	0f b7 4c 24 64       	movzx  ecx,WORD PTR [rsp+0x64]
  21da9d:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  21daa2:	8a 4c 24 66          	mov    cl,BYTE PTR [rsp+0x66]
  21daa6:	88 4c 24 06          	mov    BYTE PTR [rsp+0x6],cl
  21daaa:	e9 14 08 00 00       	jmp    21e2c3 <parseFormValue+0x1ed3>
  21daaf:	48 8b 44 24 78       	mov    rax,QWORD PTR [rsp+0x78]
        DW.FORM_ref_sig8 => FormValue{ .RefSig8 = try in_stream.readIntLe(u64) },
  21dab4:	66 c7 84 24 90 03 00 	mov    WORD PTR [rsp+0x390],0x0
  21dabb:	00 00 00 
  21dabe:	48 89 84 24 98 03 00 	mov    QWORD PTR [rsp+0x398],rax
  21dac5:	00 
  21dac6:	c5 f8 10 84 24 d8 04 	vmovups xmm0,XMMWORD PTR [rsp+0x4d8]
  21dacd:	00 00 
  21dacf:	c5 f8 11 84 24 a0 03 	vmovups XMMWORD PTR [rsp+0x3a0],xmm0
  21dad6:	00 00 
  21dad8:	c6 84 24 b0 03 00 00 	mov    BYTE PTR [rsp+0x3b0],0x8
  21dadf:	08 
  21dae0:	8b 84 24 ee 02 00 00 	mov    eax,DWORD PTR [rsp+0x2ee]
  21dae7:	89 84 24 b1 03 00 00 	mov    DWORD PTR [rsp+0x3b1],eax
  21daee:	0f b7 84 24 f2 02 00 	movzx  eax,WORD PTR [rsp+0x2f2]
  21daf5:	00 
  21daf6:	66 89 84 24 b5 03 00 	mov    WORD PTR [rsp+0x3b5],ax
  21dafd:	00 
  21dafe:	8a 84 24 f4 02 00 00 	mov    al,BYTE PTR [rsp+0x2f4]
  21db05:	88 84 24 b7 03 00 00 	mov    BYTE PTR [rsp+0x3b7],al
  21db0c:	48 8d 84 24 90 03 00 	lea    rax,[rsp+0x390]
  21db13:	00 
  21db14:	e9 dd 02 00 00       	jmp    21ddf6 <parseFormValue+0x1a06>
  21db19:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
            .payload = try readAllocBytes(allocator, in_stream, size),
  21db1e:	48 8b b4 24 d0 00 00 	mov    rsi,QWORD PTR [rsp+0xd0]
  21db25:	00 
  21db26:	4c 89 e2             	mov    rdx,r12
  21db29:	48 89 e9             	mov    rcx,rbp
  21db2c:	e8 4f 16 00 00       	call   21f180 <readAllocBytes>
  21db31:	0f b7 54 24 40       	movzx  edx,WORD PTR [rsp+0x40]
  21db36:	66 85 d2             	test   dx,dx
  21db39:	48 8b 6c 24 68       	mov    rbp,QWORD PTR [rsp+0x68]
  21db3e:	0f 84 d2 07 00 00    	je     21e316 <parseFormValue+0x1f26>
  21db44:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  21db49:	66 89 84 24 1c 01 00 	mov    WORD PTR [rsp+0x11c],ax
  21db50:	00 
  21db51:	8b 44 24 3a          	mov    eax,DWORD PTR [rsp+0x3a]
  21db55:	89 84 24 18 01 00 00 	mov    DWORD PTR [rsp+0x118],eax
  21db5c:	8b 44 24 11          	mov    eax,DWORD PTR [rsp+0x11]
  21db60:	89 84 24 f0 00 00 00 	mov    DWORD PTR [rsp+0xf0],eax
  21db67:	0f b7 44 24 15       	movzx  eax,WORD PTR [rsp+0x15]
  21db6c:	66 89 84 24 f4 00 00 	mov    WORD PTR [rsp+0xf4],ax
  21db73:	00 
  21db74:	8a 44 24 17          	mov    al,BYTE PTR [rsp+0x17]
  21db78:	88 84 24 f6 00 00 00 	mov    BYTE PTR [rsp+0xf6],al
  21db7f:	48 8d b4 24 18 01 00 	lea    rsi,[rsp+0x118]
  21db86:	00 
  21db87:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  21db8b:	89 84 24 e8 00 00 00 	mov    DWORD PTR [rsp+0xe8],eax
  21db92:	48 8d 84 24 f0 00 00 	lea    rax,[rsp+0xf0]
  21db99:	00 
  21db9a:	0f b7 4c 24 0e       	movzx  ecx,WORD PTR [rsp+0xe]
  21db9f:	66 89 8c 24 ec 00 00 	mov    WORD PTR [rsp+0xec],cx
  21dba6:	00 
  21dba7:	48 8d 8c 24 e8 00 00 	lea    rcx,[rsp+0xe8]
  21dbae:	00 
  21dbaf:	8a 5c 24 10          	mov    bl,BYTE PTR [rsp+0x10]
  21dbb3:	88 9c 24 ee 00 00 00 	mov    BYTE PTR [rsp+0xee],bl
  21dbba:	e9 f5 07 00 00       	jmp    21e3b4 <parseFormValue+0x1fc4>
  21dbbf:	66 b8 1f 00          	mov    ax,0x1f
  21dbc3:	e9 c5 ec ff ff       	jmp    21c88d <parseFormValue+0x49d>
            return self.items[0..self.len];
  21dbc8:	48 8b 44 24 40       	mov    rax,QWORD PTR [rsp+0x40]
        DW.FORM_string => FormValue{ .String = try readStringRaw(allocator, in_stream) },
  21dbcd:	66 c7 84 24 68 03 00 	mov    WORD PTR [rsp+0x368],0x0
  21dbd4:	00 00 00 
  21dbd7:	48 89 84 24 70 03 00 	mov    QWORD PTR [rsp+0x370],rax
  21dbde:	00 
  21dbdf:	48 89 ac 24 78 03 00 	mov    QWORD PTR [rsp+0x378],rbp
  21dbe6:	00 
  21dbe7:	c6 84 24 88 03 00 00 	mov    BYTE PTR [rsp+0x388],0x9
  21dbee:	09 
  21dbef:	8b 84 24 e7 02 00 00 	mov    eax,DWORD PTR [rsp+0x2e7]
  21dbf6:	89 84 24 89 03 00 00 	mov    DWORD PTR [rsp+0x389],eax
  21dbfd:	0f b7 84 24 eb 02 00 	movzx  eax,WORD PTR [rsp+0x2eb]
  21dc04:	00 
  21dc05:	66 89 84 24 8d 03 00 	mov    WORD PTR [rsp+0x38d],ax
  21dc0c:	00 
  21dc0d:	8a 84 24 ed 02 00 00 	mov    al,BYTE PTR [rsp+0x2ed]
  21dc14:	88 84 24 8f 03 00 00 	mov    BYTE PTR [rsp+0x38f],al
  21dc1b:	48 8d 84 24 68 03 00 	lea    rax,[rsp+0x368]
  21dc22:	00 
  21dc23:	4c 8b 74 24 68       	mov    r14,QWORD PTR [rsp+0x68]
  21dc28:	e9 c9 01 00 00       	jmp    21ddf6 <parseFormValue+0x1a06>
  21dc2d:	66 b8 1f 00          	mov    ax,0x1f
  21dc31:	e9 c0 ec ff ff       	jmp    21c8f6 <parseFormValue+0x506>
  21dc36:	66 b8 1f 00          	mov    ax,0x1f
  21dc3a:	e9 65 f2 ff ff       	jmp    21cea4 <parseFormValue+0xab4>
  21dc3f:	66 b8 1f 00          	mov    ax,0x1f
  21dc43:	e9 c5 f2 ff ff       	jmp    21cf0d <parseFormValue+0xb1d>
  21dc48:	66 b8 1f 00          	mov    ax,0x1f
  21dc4c:	e9 85 f3 ff ff       	jmp    21cfd6 <parseFormValue+0xbe6>
  21dc51:	0f b6 44 24 78       	movzx  eax,BYTE PTR [rsp+0x78]
  21dc56:	0f b6 4c 24 79       	movzx  ecx,BYTE PTR [rsp+0x79]
  21dc5b:	48 c1 e1 08          	shl    rcx,0x8
  21dc5f:	48 09 c1             	or     rcx,rax
  21dc62:	0f b6 54 24 7a       	movzx  edx,BYTE PTR [rsp+0x7a]
  21dc67:	48 c1 e2 10          	shl    rdx,0x10
  21dc6b:	48 09 ca             	or     rdx,rcx
  21dc6e:	0f b6 44 24 7b       	movzx  eax,BYTE PTR [rsp+0x7b]
  21dc73:	48 c1 e0 18          	shl    rax,0x18
  21dc77:	48 09 d0             	or     rax,rdx
        DW.FORM_strp => FormValue{ .StrPtr = try parseFormValueDwarfOffsetSize(in_stream, is_64) },
  21dc7a:	66 c7 84 24 40 03 00 	mov    WORD PTR [rsp+0x340],0x0
  21dc81:	00 00 00 
  21dc84:	48 89 84 24 48 03 00 	mov    QWORD PTR [rsp+0x348],rax
  21dc8b:	00 
  21dc8c:	c5 f8 10 84 24 c8 04 	vmovups xmm0,XMMWORD PTR [rsp+0x4c8]
  21dc93:	00 00 
  21dc95:	c5 f8 11 84 24 50 03 	vmovups XMMWORD PTR [rsp+0x350],xmm0
  21dc9c:	00 00 
  21dc9e:	c6 84 24 60 03 00 00 	mov    BYTE PTR [rsp+0x360],0xa
  21dca5:	0a 
  21dca6:	8b 84 24 e0 02 00 00 	mov    eax,DWORD PTR [rsp+0x2e0]
  21dcad:	89 84 24 61 03 00 00 	mov    DWORD PTR [rsp+0x361],eax
  21dcb4:	0f b7 84 24 e4 02 00 	movzx  eax,WORD PTR [rsp+0x2e4]
  21dcbb:	00 
  21dcbc:	66 89 84 24 65 03 00 	mov    WORD PTR [rsp+0x365],ax
  21dcc3:	00 
  21dcc4:	8a 84 24 e6 02 00 00 	mov    al,BYTE PTR [rsp+0x2e6]
  21dccb:	88 84 24 67 03 00 00 	mov    BYTE PTR [rsp+0x367],al
  21dcd2:	48 8d 84 24 40 03 00 	lea    rax,[rsp+0x340]
  21dcd9:	00 
  21dcda:	e9 17 01 00 00       	jmp    21ddf6 <parseFormValue+0x1a06>
  21dcdf:	0f b6 44 24 78       	movzx  eax,BYTE PTR [rsp+0x78]
  21dce4:	0f b6 4c 24 79       	movzx  ecx,BYTE PTR [rsp+0x79]
  21dce9:	48 c1 e1 08          	shl    rcx,0x8
  21dced:	48 09 c1             	or     rcx,rax
  21dcf0:	0f b6 54 24 7a       	movzx  edx,BYTE PTR [rsp+0x7a]
  21dcf5:	48 c1 e2 10          	shl    rdx,0x10
  21dcf9:	48 09 ca             	or     rdx,rcx
  21dcfc:	0f b6 44 24 7b       	movzx  eax,BYTE PTR [rsp+0x7b]
  21dd01:	48 c1 e0 18          	shl    rax,0x18
  21dd05:	48 09 d0             	or     rax,rdx
        DW.FORM_ref_addr => FormValue{ .RefAddr = try parseFormValueDwarfOffsetSize(in_stream, is_64) },
  21dd08:	66 c7 84 24 b8 03 00 	mov    WORD PTR [rsp+0x3b8],0x0
  21dd0f:	00 00 00 
  21dd12:	48 89 84 24 c0 03 00 	mov    QWORD PTR [rsp+0x3c0],rax
  21dd19:	00 
  21dd1a:	c5 f8 10 84 24 e8 04 	vmovups xmm0,XMMWORD PTR [rsp+0x4e8]
  21dd21:	00 00 
  21dd23:	c5 f8 11 84 24 c8 03 	vmovups XMMWORD PTR [rsp+0x3c8],xmm0
  21dd2a:	00 00 
  21dd2c:	c6 84 24 d8 03 00 00 	mov    BYTE PTR [rsp+0x3d8],0x7
  21dd33:	07 
  21dd34:	8b 84 24 f5 02 00 00 	mov    eax,DWORD PTR [rsp+0x2f5]
  21dd3b:	89 84 24 d9 03 00 00 	mov    DWORD PTR [rsp+0x3d9],eax
  21dd42:	0f b7 84 24 f9 02 00 	movzx  eax,WORD PTR [rsp+0x2f9]
  21dd49:	00 
  21dd4a:	66 89 84 24 dd 03 00 	mov    WORD PTR [rsp+0x3dd],ax
  21dd51:	00 
  21dd52:	8a 84 24 fb 02 00 00 	mov    al,BYTE PTR [rsp+0x2fb]
  21dd59:	88 84 24 df 03 00 00 	mov    BYTE PTR [rsp+0x3df],al
  21dd60:	48 8d 84 24 b8 03 00 	lea    rax,[rsp+0x3b8]
  21dd67:	00 
  21dd68:	e9 89 00 00 00       	jmp    21ddf6 <parseFormValue+0x1a06>
  21dd6d:	0f b6 44 24 78       	movzx  eax,BYTE PTR [rsp+0x78]
  21dd72:	0f b6 4c 24 79       	movzx  ecx,BYTE PTR [rsp+0x79]
  21dd77:	48 c1 e1 08          	shl    rcx,0x8
  21dd7b:	48 09 c1             	or     rcx,rax
  21dd7e:	0f b6 54 24 7a       	movzx  edx,BYTE PTR [rsp+0x7a]
  21dd83:	48 c1 e2 10          	shl    rdx,0x10
  21dd87:	48 09 ca             	or     rdx,rcx
  21dd8a:	0f b6 44 24 7b       	movzx  eax,BYTE PTR [rsp+0x7b]
  21dd8f:	48 c1 e0 18          	shl    rax,0x18
  21dd93:	48 09 d0             	or     rax,rdx
        DW.FORM_sec_offset => FormValue{ .SecOffset = try parseFormValueDwarfOffsetSize(in_stream, is_64) },
  21dd96:	66 c7 84 24 e0 03 00 	mov    WORD PTR [rsp+0x3e0],0x0
  21dd9d:	00 00 00 
  21dda0:	48 89 84 24 e8 03 00 	mov    QWORD PTR [rsp+0x3e8],rax
  21dda7:	00 
  21dda8:	c5 f8 10 84 24 f8 04 	vmovups xmm0,XMMWORD PTR [rsp+0x4f8]
  21ddaf:	00 00 
  21ddb1:	c5 f8 11 84 24 f0 03 	vmovups XMMWORD PTR [rsp+0x3f0],xmm0
  21ddb8:	00 00 
  21ddba:	c6 84 24 00 04 00 00 	mov    BYTE PTR [rsp+0x400],0x5
  21ddc1:	05 
  21ddc2:	8b 84 24 fc 02 00 00 	mov    eax,DWORD PTR [rsp+0x2fc]
  21ddc9:	89 84 24 01 04 00 00 	mov    DWORD PTR [rsp+0x401],eax
  21ddd0:	0f b7 84 24 00 03 00 	movzx  eax,WORD PTR [rsp+0x300]
  21ddd7:	00 
  21ddd8:	66 89 84 24 05 04 00 	mov    WORD PTR [rsp+0x405],ax
  21dddf:	00 
  21dde0:	8a 84 24 02 03 00 00 	mov    al,BYTE PTR [rsp+0x302]
  21dde7:	88 84 24 07 04 00 00 	mov    BYTE PTR [rsp+0x407],al
  21ddee:	48 8d 84 24 e0 03 00 	lea    rax,[rsp+0x3e0]
  21ddf5:	00 
    return switch (form_id) {
  21ddf6:	48 8b 48 20          	mov    rcx,QWORD PTR [rax+0x20]
  21ddfa:	49 89 4e 20          	mov    QWORD PTR [r14+0x20],rcx
  21ddfe:	c5 fc 10 00          	vmovups ymm0,YMMWORD PTR [rax]
  21de02:	c4 c1 7c 11 06       	vmovups YMMWORD PTR [r14],ymm0
  21de07:	48 81 c4 08 07 00 00 	add    rsp,0x708
  21de0e:	5b                   	pop    rbx
  21de0f:	41 5c                	pop    r12
  21de11:	41 5d                	pop    r13
  21de13:	41 5e                	pop    r14
  21de15:	41 5f                	pop    r15
  21de17:	5d                   	pop    rbp
  21de18:	c5 f8 77             	vzeroupper 
  21de1b:	c3                   	ret    
  21de1c:	66 b8 23 00          	mov    ax,0x23
  21de20:	e9 d1 ea ff ff       	jmp    21c8f6 <parseFormValue+0x506>
  21de25:	66 b8 23 00          	mov    ax,0x23
  21de29:	e9 76 f0 ff ff       	jmp    21cea4 <parseFormValue+0xab4>
  21de2e:	66 b8 23 00          	mov    ax,0x23
  21de32:	e9 d6 f0 ff ff       	jmp    21cf0d <parseFormValue+0xb1d>
  21de37:	66 b8 23 00          	mov    ax,0x23
  21de3b:	e9 96 f1 ff ff       	jmp    21cfd6 <parseFormValue+0xbe6>
  21de40:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
    const buf = try readAllocBytes(allocator, in_stream, size);
  21de45:	48 8b b4 24 d0 00 00 	mov    rsi,QWORD PTR [rsp+0xd0]
  21de4c:	00 
  21de4d:	4c 89 e2             	mov    rdx,r12
  21de50:	48 89 d9             	mov    rcx,rbx
  21de53:	e8 28 13 00 00       	call   21f180 <readAllocBytes>
  21de58:	0f b7 4c 24 40       	movzx  ecx,WORD PTR [rsp+0x40]
  21de5d:	66 85 c9             	test   cx,cx
  21de60:	48 8b 7c 24 68       	mov    rdi,QWORD PTR [rsp+0x68]
  21de65:	0f 84 eb 08 00 00    	je     21e756 <parseFormValue+0x2366>
  21de6b:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  21de70:	66 89 84 24 24 01 00 	mov    WORD PTR [rsp+0x124],ax
  21de77:	00 
  21de78:	8b 44 24 3a          	mov    eax,DWORD PTR [rsp+0x3a]
  21de7c:	89 84 24 20 01 00 00 	mov    DWORD PTR [rsp+0x120],eax
  21de83:	8b 44 24 11          	mov    eax,DWORD PTR [rsp+0x11]
  21de87:	89 84 24 00 01 00 00 	mov    DWORD PTR [rsp+0x100],eax
  21de8e:	0f b7 44 24 15       	movzx  eax,WORD PTR [rsp+0x15]
  21de93:	66 89 84 24 04 01 00 	mov    WORD PTR [rsp+0x104],ax
  21de9a:	00 
  21de9b:	8a 44 24 17          	mov    al,BYTE PTR [rsp+0x17]
  21de9f:	88 84 24 06 01 00 00 	mov    BYTE PTR [rsp+0x106],al
  21dea6:	48 8d b4 24 20 01 00 	lea    rsi,[rsp+0x120]
  21dead:	00 
  21deae:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  21deb2:	89 84 24 f8 00 00 00 	mov    DWORD PTR [rsp+0xf8],eax
  21deb9:	48 8d 84 24 00 01 00 	lea    rax,[rsp+0x100]
  21dec0:	00 
  21dec1:	0f b7 54 24 0e       	movzx  edx,WORD PTR [rsp+0xe]
  21dec6:	66 89 94 24 fc 00 00 	mov    WORD PTR [rsp+0xfc],dx
  21decd:	00 
  21dece:	48 8d 94 24 f8 00 00 	lea    rdx,[rsp+0xf8]
  21ded5:	00 
  21ded6:	8a 5c 24 10          	mov    bl,BYTE PTR [rsp+0x10]
  21deda:	88 9c 24 fe 00 00 00 	mov    BYTE PTR [rsp+0xfe],bl
  21dee1:	e9 a1 00 00 00       	jmp    21df87 <parseFormValue+0x1b97>
  21dee6:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
    const buf = try readAllocBytes(allocator, in_stream, size);
  21deeb:	48 8b b4 24 d0 00 00 	mov    rsi,QWORD PTR [rsp+0xd0]
  21def2:	00 
  21def3:	4c 89 e2             	mov    rdx,r12
  21def6:	48 89 d9             	mov    rcx,rbx
  21def9:	e8 82 12 00 00       	call   21f180 <readAllocBytes>
  21defe:	0f b7 4c 24 40       	movzx  ecx,WORD PTR [rsp+0x40]
  21df03:	66 85 c9             	test   cx,cx
  21df06:	48 8b 7c 24 68       	mov    rdi,QWORD PTR [rsp+0x68]
  21df0b:	0f 84 d9 08 00 00    	je     21e7ea <parseFormValue+0x23fa>
  21df11:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  21df16:	66 89 84 24 14 01 00 	mov    WORD PTR [rsp+0x114],ax
  21df1d:	00 
  21df1e:	8b 44 24 3a          	mov    eax,DWORD PTR [rsp+0x3a]
  21df22:	89 84 24 10 01 00 00 	mov    DWORD PTR [rsp+0x110],eax
  21df29:	8b 44 24 11          	mov    eax,DWORD PTR [rsp+0x11]
  21df2d:	89 84 24 e0 00 00 00 	mov    DWORD PTR [rsp+0xe0],eax
  21df34:	0f b7 44 24 15       	movzx  eax,WORD PTR [rsp+0x15]
  21df39:	66 89 84 24 e4 00 00 	mov    WORD PTR [rsp+0xe4],ax
  21df40:	00 
  21df41:	8a 44 24 17          	mov    al,BYTE PTR [rsp+0x17]
  21df45:	88 84 24 e6 00 00 00 	mov    BYTE PTR [rsp+0xe6],al
  21df4c:	48 8d b4 24 10 01 00 	lea    rsi,[rsp+0x110]
  21df53:	00 
  21df54:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  21df58:	89 84 24 d8 00 00 00 	mov    DWORD PTR [rsp+0xd8],eax
  21df5f:	48 8d 84 24 e0 00 00 	lea    rax,[rsp+0xe0]
  21df66:	00 
  21df67:	0f b7 54 24 0e       	movzx  edx,WORD PTR [rsp+0xe]
  21df6c:	66 89 94 24 dc 00 00 	mov    WORD PTR [rsp+0xdc],dx
  21df73:	00 
  21df74:	48 8d 94 24 d8 00 00 	lea    rdx,[rsp+0xd8]
  21df7b:	00 
  21df7c:	8a 5c 24 10          	mov    bl,BYTE PTR [rsp+0x10]
  21df80:	88 9c 24 de 00 00 00 	mov    BYTE PTR [rsp+0xde],bl
  21df87:	e9 ef 08 00 00       	jmp    21e87b <parseFormValue+0x248b>
            return parseFormValue(allocator, in_stream, child_form_id, is_64);
  21df8c:	44 0f b6 c5          	movzx  r8d,bpl
  21df90:	48 8d bc 24 a0 04 00 	lea    rdi,[rsp+0x4a0]
  21df97:	00 
  21df98:	48 8b b4 24 d0 00 00 	mov    rsi,QWORD PTR [rsp+0xd0]
  21df9f:	00 
  21dfa0:	4c 89 e2             	mov    rdx,r12
  21dfa3:	4c 89 f1             	mov    rcx,r14
  21dfa6:	e8 45 e4 ff ff       	call   21c3f0 <parseFormValue>
  21dfab:	48 8b 84 24 c0 04 00 	mov    rax,QWORD PTR [rsp+0x4c0]
  21dfb2:	00 
  21dfb3:	48 8b 4c 24 68       	mov    rcx,QWORD PTR [rsp+0x68]
  21dfb8:	48 89 41 20          	mov    QWORD PTR [rcx+0x20],rax
  21dfbc:	c5 fc 10 84 24 a0 04 	vmovups ymm0,YMMWORD PTR [rsp+0x4a0]
  21dfc3:	00 00 
  21dfc5:	c5 fc 11 01          	vmovups YMMWORD PTR [rcx],ymm0
  21dfc9:	e9 39 fe ff ff       	jmp    21de07 <parseFormValue+0x1a17>
  21dfce:	48 8d bc 24 50 04 00 	lea    rdi,[rsp+0x450]
  21dfd5:	00 
            const buf = try readAllocBytes(allocator, in_stream, size);
  21dfd6:	48 8b b4 24 d0 00 00 	mov    rsi,QWORD PTR [rsp+0xd0]
  21dfdd:	00 
  21dfde:	4c 89 e2             	mov    rdx,r12
  21dfe1:	48 89 d9             	mov    rcx,rbx
  21dfe4:	e8 97 11 00 00       	call   21f180 <readAllocBytes>
  21dfe9:	0f b7 84 24 50 04 00 	movzx  eax,WORD PTR [rsp+0x450]
  21dff0:	00 
  21dff1:	66 85 c0             	test   ax,ax
  21dff4:	0f 84 c4 08 00 00    	je     21e8be <parseFormValue+0x24ce>
  21dffa:	48 8b 4c 24 68       	mov    rcx,QWORD PTR [rsp+0x68]
  21dfff:	66 89 01             	mov    WORD PTR [rcx],ax
  21e002:	48 8b 84 24 68 06 00 	mov    rax,QWORD PTR [rsp+0x668]
  21e009:	00 
  21e00a:	48 89 41 20          	mov    QWORD PTR [rcx+0x20],rax
  21e00e:	c5 fc 10 84 24 4a 06 	vmovups ymm0,YMMWORD PTR [rsp+0x64a]
  21e015:	00 00 
  21e017:	c5 fc 11 41 02       	vmovups YMMWORD PTR [rcx+0x2],ymm0
  21e01c:	e9 e6 fd ff ff       	jmp    21de07 <parseFormValue+0x1a17>
  21e021:	31 c9                	xor    ecx,ecx
  21e023:	e9 f1 09 00 00       	jmp    21ea19 <parseFormValue+0x2629>
  21e028:	31 c9                	xor    ecx,ecx
  21e02a:	e9 cb 0b 00 00       	jmp    21ebfa <parseFormValue+0x280a>
  21e02f:	31 c9                	xor    ecx,ecx
  21e031:	e9 a5 0d 00 00       	jmp    21eddb <parseFormValue+0x29eb>
    const buf = try readAllocBytes(allocator, in_stream, size);
  21e036:	c5 f8 10 84 24 80 00 	vmovups xmm0,XMMWORD PTR [rsp+0x80]
  21e03d:	00 00 
  21e03f:	c5 f8 29 84 24 b0 00 	vmovaps XMMWORD PTR [rsp+0xb0],xmm0
  21e046:	00 00 
    return FormValue{ .Ref = buf };
  21e048:	c5 f8 11 44 24 1e    	vmovups XMMWORD PTR [rsp+0x1e],xmm0
  21e04e:	48 8b 84 24 c0 00 00 	mov    rax,QWORD PTR [rsp+0xc0]
  21e055:	00 
  21e056:	48 89 44 24 2e       	mov    QWORD PTR [rsp+0x2e],rax
  21e05b:	c6 44 24 08 06       	mov    BYTE PTR [rsp+0x8],0x6
  21e060:	8b 44 24 71          	mov    eax,DWORD PTR [rsp+0x71]
  21e064:	89 04 24             	mov    DWORD PTR [rsp],eax
  21e067:	0f b7 44 24 75       	movzx  eax,WORD PTR [rsp+0x75]
  21e06c:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  21e071:	8a 44 24 77          	mov    al,BYTE PTR [rsp+0x77]
  21e075:	88 44 24 06          	mov    BYTE PTR [rsp+0x6],al
  21e079:	c5 f8 10 44 24 18    	vmovups xmm0,XMMWORD PTR [rsp+0x18]
  21e07f:	c5 f8 29 84 24 90 00 	vmovaps XMMWORD PTR [rsp+0x90],xmm0
  21e086:	00 00 
  21e088:	c5 f8 10 44 24 26    	vmovups xmm0,XMMWORD PTR [rsp+0x26]
  21e08e:	c5 f8 11 84 24 9e 00 	vmovups XMMWORD PTR [rsp+0x9e],xmm0
  21e095:	00 00 
  21e097:	b1 06                	mov    cl,0x6
  21e099:	31 c0                	xor    eax,eax
    return parseFormValueRefLen(allocator, in_stream, block_len);
  21e09b:	66 89 84 24 40 02 00 	mov    WORD PTR [rsp+0x240],ax
  21e0a2:	00 
  21e0a3:	c5 f8 28 84 24 90 00 	vmovaps xmm0,XMMWORD PTR [rsp+0x90]
  21e0aa:	00 00 
  21e0ac:	c5 f8 11 84 24 42 02 	vmovups XMMWORD PTR [rsp+0x242],xmm0
  21e0b3:	00 00 
  21e0b5:	c5 f8 10 84 24 9e 00 	vmovups xmm0,XMMWORD PTR [rsp+0x9e]
  21e0bc:	00 00 
  21e0be:	c5 f8 11 84 24 50 02 	vmovups XMMWORD PTR [rsp+0x250],xmm0
  21e0c5:	00 00 
  21e0c7:	88 8c 24 60 02 00 00 	mov    BYTE PTR [rsp+0x260],cl
  21e0ce:	8b 04 24             	mov    eax,DWORD PTR [rsp]
  21e0d1:	89 84 24 61 02 00 00 	mov    DWORD PTR [rsp+0x261],eax
  21e0d8:	0f b7 44 24 04       	movzx  eax,WORD PTR [rsp+0x4]
  21e0dd:	66 89 84 24 65 02 00 	mov    WORD PTR [rsp+0x265],ax
  21e0e4:	00 
  21e0e5:	8a 44 24 06          	mov    al,BYTE PTR [rsp+0x6]
  21e0e9:	e9 41 eb ff ff       	jmp    21cc2f <parseFormValue+0x83f>
    const buf = try readAllocBytes(allocator, in_stream, size);
  21e0ee:	c5 f8 10 84 24 80 00 	vmovups xmm0,XMMWORD PTR [rsp+0x80]
  21e0f5:	00 00 
  21e0f7:	c5 f8 29 84 24 b0 00 	vmovaps XMMWORD PTR [rsp+0xb0],xmm0
  21e0fe:	00 00 
    return FormValue{ .Ref = buf };
  21e100:	c5 f8 11 44 24 1e    	vmovups XMMWORD PTR [rsp+0x1e],xmm0
  21e106:	48 8b 84 24 c0 00 00 	mov    rax,QWORD PTR [rsp+0xc0]
  21e10d:	00 
  21e10e:	48 89 44 24 2e       	mov    QWORD PTR [rsp+0x2e],rax
  21e113:	c6 44 24 08 06       	mov    BYTE PTR [rsp+0x8],0x6
  21e118:	8b 44 24 71          	mov    eax,DWORD PTR [rsp+0x71]
  21e11c:	89 04 24             	mov    DWORD PTR [rsp],eax
  21e11f:	0f b7 44 24 75       	movzx  eax,WORD PTR [rsp+0x75]
  21e124:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  21e129:	8a 44 24 77          	mov    al,BYTE PTR [rsp+0x77]
  21e12d:	88 44 24 06          	mov    BYTE PTR [rsp+0x6],al
  21e131:	c5 f8 10 44 24 18    	vmovups xmm0,XMMWORD PTR [rsp+0x18]
  21e137:	c5 f8 29 84 24 90 00 	vmovaps XMMWORD PTR [rsp+0x90],xmm0
  21e13e:	00 00 
  21e140:	c5 f8 10 44 24 26    	vmovups xmm0,XMMWORD PTR [rsp+0x26]
  21e146:	c5 f8 11 84 24 9e 00 	vmovups XMMWORD PTR [rsp+0x9e],xmm0
  21e14d:	00 00 
  21e14f:	b1 06                	mov    cl,0x6
  21e151:	31 c0                	xor    eax,eax
    return parseFormValueRefLen(allocator, in_stream, block_len);
  21e153:	66 89 84 24 18 02 00 	mov    WORD PTR [rsp+0x218],ax
  21e15a:	00 
  21e15b:	c5 f8 28 84 24 90 00 	vmovaps xmm0,XMMWORD PTR [rsp+0x90]
  21e162:	00 00 
  21e164:	c5 f8 11 84 24 1a 02 	vmovups XMMWORD PTR [rsp+0x21a],xmm0
  21e16b:	00 00 
  21e16d:	c5 f8 10 84 24 9e 00 	vmovups xmm0,XMMWORD PTR [rsp+0x9e]
  21e174:	00 00 
  21e176:	c5 f8 11 84 24 28 02 	vmovups XMMWORD PTR [rsp+0x228],xmm0
  21e17d:	00 00 
  21e17f:	88 8c 24 38 02 00 00 	mov    BYTE PTR [rsp+0x238],cl
  21e186:	8b 04 24             	mov    eax,DWORD PTR [rsp]
  21e189:	89 84 24 39 02 00 00 	mov    DWORD PTR [rsp+0x239],eax
  21e190:	0f b7 44 24 04       	movzx  eax,WORD PTR [rsp+0x4]
  21e195:	66 89 84 24 3d 02 00 	mov    WORD PTR [rsp+0x23d],ax
  21e19c:	00 
  21e19d:	8a 44 24 06          	mov    al,BYTE PTR [rsp+0x6]
  21e1a1:	e9 3e eb ff ff       	jmp    21cce4 <parseFormValue+0x8f4>
    const buf = try readAllocBytes(allocator, in_stream, size);
  21e1a6:	c5 f8 10 84 24 80 00 	vmovups xmm0,XMMWORD PTR [rsp+0x80]
  21e1ad:	00 00 
  21e1af:	c5 f8 29 84 24 b0 00 	vmovaps XMMWORD PTR [rsp+0xb0],xmm0
  21e1b6:	00 00 
    return FormValue{ .Ref = buf };
  21e1b8:	c5 f8 11 44 24 1e    	vmovups XMMWORD PTR [rsp+0x1e],xmm0
  21e1be:	48 8b 84 24 c0 00 00 	mov    rax,QWORD PTR [rsp+0xc0]
  21e1c5:	00 
  21e1c6:	48 89 44 24 2e       	mov    QWORD PTR [rsp+0x2e],rax
  21e1cb:	c6 44 24 08 06       	mov    BYTE PTR [rsp+0x8],0x6
  21e1d0:	8b 44 24 71          	mov    eax,DWORD PTR [rsp+0x71]
  21e1d4:	89 04 24             	mov    DWORD PTR [rsp],eax
  21e1d7:	0f b7 44 24 75       	movzx  eax,WORD PTR [rsp+0x75]
  21e1dc:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  21e1e1:	8a 44 24 77          	mov    al,BYTE PTR [rsp+0x77]
  21e1e5:	88 44 24 06          	mov    BYTE PTR [rsp+0x6],al
  21e1e9:	c5 f8 10 44 24 18    	vmovups xmm0,XMMWORD PTR [rsp+0x18]
  21e1ef:	c5 f8 29 84 24 90 00 	vmovaps XMMWORD PTR [rsp+0x90],xmm0
  21e1f6:	00 00 
  21e1f8:	c5 f8 10 44 24 26    	vmovups xmm0,XMMWORD PTR [rsp+0x26]
  21e1fe:	c5 f8 11 84 24 9e 00 	vmovups XMMWORD PTR [rsp+0x9e],xmm0
  21e205:	00 00 
  21e207:	b1 06                	mov    cl,0x6
  21e209:	31 c0                	xor    eax,eax
    return parseFormValueRefLen(allocator, in_stream, block_len);
  21e20b:	66 89 84 24 f0 01 00 	mov    WORD PTR [rsp+0x1f0],ax
  21e212:	00 
  21e213:	c5 f8 28 84 24 90 00 	vmovaps xmm0,XMMWORD PTR [rsp+0x90]
  21e21a:	00 00 
  21e21c:	c5 f8 11 84 24 f2 01 	vmovups XMMWORD PTR [rsp+0x1f2],xmm0
  21e223:	00 00 
  21e225:	c5 f8 10 84 24 9e 00 	vmovups xmm0,XMMWORD PTR [rsp+0x9e]
  21e22c:	00 00 
  21e22e:	c5 f8 11 84 24 00 02 	vmovups XMMWORD PTR [rsp+0x200],xmm0
  21e235:	00 00 
  21e237:	88 8c 24 10 02 00 00 	mov    BYTE PTR [rsp+0x210],cl
  21e23e:	8b 04 24             	mov    eax,DWORD PTR [rsp]
  21e241:	89 84 24 11 02 00 00 	mov    DWORD PTR [rsp+0x211],eax
  21e248:	0f b7 44 24 04       	movzx  eax,WORD PTR [rsp+0x4]
  21e24d:	66 89 84 24 15 02 00 	mov    WORD PTR [rsp+0x215],ax
  21e254:	00 
  21e255:	8a 44 24 06          	mov    al,BYTE PTR [rsp+0x6]
  21e259:	e9 3b eb ff ff       	jmp    21cd99 <parseFormValue+0x9a9>
    const buf = try readAllocBytes(allocator, in_stream, size);
  21e25e:	c5 f8 10 84 24 80 00 	vmovups xmm0,XMMWORD PTR [rsp+0x80]
  21e265:	00 00 
  21e267:	c5 f8 29 84 24 b0 00 	vmovaps XMMWORD PTR [rsp+0xb0],xmm0
  21e26e:	00 00 
    return FormValue{ .Ref = buf };
  21e270:	c5 f8 11 44 24 1e    	vmovups XMMWORD PTR [rsp+0x1e],xmm0
  21e276:	48 8b 84 24 c0 00 00 	mov    rax,QWORD PTR [rsp+0xc0]
  21e27d:	00 
  21e27e:	48 89 44 24 2e       	mov    QWORD PTR [rsp+0x2e],rax
  21e283:	c6 44 24 08 06       	mov    BYTE PTR [rsp+0x8],0x6
  21e288:	8b 44 24 71          	mov    eax,DWORD PTR [rsp+0x71]
  21e28c:	89 04 24             	mov    DWORD PTR [rsp],eax
  21e28f:	0f b7 44 24 75       	movzx  eax,WORD PTR [rsp+0x75]
  21e294:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  21e299:	8a 44 24 77          	mov    al,BYTE PTR [rsp+0x77]
  21e29d:	88 44 24 06          	mov    BYTE PTR [rsp+0x6],al
  21e2a1:	c5 f8 10 44 24 18    	vmovups xmm0,XMMWORD PTR [rsp+0x18]
  21e2a7:	c5 f8 29 84 24 90 00 	vmovaps XMMWORD PTR [rsp+0x90],xmm0
  21e2ae:	00 00 
  21e2b0:	c5 f8 10 44 24 26    	vmovups xmm0,XMMWORD PTR [rsp+0x26]
  21e2b6:	c5 f8 11 84 24 9e 00 	vmovups XMMWORD PTR [rsp+0x9e],xmm0
  21e2bd:	00 00 
  21e2bf:	b1 06                	mov    cl,0x6
  21e2c1:	31 c0                	xor    eax,eax
    return parseFormValueRefLen(allocator, in_stream, block_len);
  21e2c3:	66 89 84 24 c8 01 00 	mov    WORD PTR [rsp+0x1c8],ax
  21e2ca:	00 
  21e2cb:	c5 f8 28 84 24 90 00 	vmovaps xmm0,XMMWORD PTR [rsp+0x90]
  21e2d2:	00 00 
  21e2d4:	c5 f8 11 84 24 ca 01 	vmovups XMMWORD PTR [rsp+0x1ca],xmm0
  21e2db:	00 00 
  21e2dd:	c5 f8 10 84 24 9e 00 	vmovups xmm0,XMMWORD PTR [rsp+0x9e]
  21e2e4:	00 00 
  21e2e6:	c5 f8 11 84 24 d8 01 	vmovups XMMWORD PTR [rsp+0x1d8],xmm0
  21e2ed:	00 00 
  21e2ef:	88 8c 24 e8 01 00 00 	mov    BYTE PTR [rsp+0x1e8],cl
  21e2f6:	8b 04 24             	mov    eax,DWORD PTR [rsp]
  21e2f9:	89 84 24 e9 01 00 00 	mov    DWORD PTR [rsp+0x1e9],eax
  21e300:	0f b7 44 24 04       	movzx  eax,WORD PTR [rsp+0x4]
  21e305:	66 89 84 24 ed 01 00 	mov    WORD PTR [rsp+0x1ed],ax
  21e30c:	00 
  21e30d:	8a 44 24 06          	mov    al,BYTE PTR [rsp+0x6]
  21e311:	e9 38 eb ff ff       	jmp    21ce4e <parseFormValue+0xa5e>
            const signed = form_id == DW.FORM_sdata;
  21e316:	48 83 fb 0d          	cmp    rbx,0xd
    return FormValue{
  21e31a:	0f 94 84 24 b0 00 00 	sete   BYTE PTR [rsp+0xb0]
  21e321:	00 
  21e322:	c6 44 24 60 02       	mov    BYTE PTR [rsp+0x60],0x2
  21e327:	8b 44 24 78          	mov    eax,DWORD PTR [rsp+0x78]
  21e32b:	89 84 24 18 01 00 00 	mov    DWORD PTR [rsp+0x118],eax
            const signed = form_id == DW.FORM_sdata;
  21e332:	40 0f 94 c7          	sete   dil
    return FormValue{
  21e336:	0f b7 44 24 7c       	movzx  eax,WORD PTR [rsp+0x7c]
  21e33b:	66 89 84 24 1c 01 00 	mov    WORD PTR [rsp+0x11c],ax
  21e342:	00 
        .Const = Constant{
  21e343:	c5 f8 10 44 24 48    	vmovups xmm0,XMMWORD PTR [rsp+0x48]
    return FormValue{
  21e349:	8b 84 24 90 00 00 00 	mov    eax,DWORD PTR [rsp+0x90]
  21e350:	89 84 24 f0 00 00 00 	mov    DWORD PTR [rsp+0xf0],eax
  21e357:	48 8d b4 24 18 01 00 	lea    rsi,[rsp+0x118]
  21e35e:	00 
  21e35f:	0f b7 84 24 94 00 00 	movzx  eax,WORD PTR [rsp+0x94]
  21e366:	00 
  21e367:	66 89 84 24 f4 00 00 	mov    WORD PTR [rsp+0xf4],ax
  21e36e:	00 
  21e36f:	48 8d 84 24 f0 00 00 	lea    rax,[rsp+0xf0]
  21e376:	00 
  21e377:	8a 8c 24 96 00 00 00 	mov    cl,BYTE PTR [rsp+0x96]
  21e37e:	88 8c 24 f6 00 00 00 	mov    BYTE PTR [rsp+0xf6],cl
  21e385:	b3 02                	mov    bl,0x2
  21e387:	8b 4c 24 18          	mov    ecx,DWORD PTR [rsp+0x18]
  21e38b:	89 8c 24 e8 00 00 00 	mov    DWORD PTR [rsp+0xe8],ecx
  21e392:	48 8d 8c 24 e8 00 00 	lea    rcx,[rsp+0xe8]
  21e399:	00 
  21e39a:	0f b7 54 24 1c       	movzx  edx,WORD PTR [rsp+0x1c]
  21e39f:	66 89 94 24 ec 00 00 	mov    WORD PTR [rsp+0xec],dx
  21e3a6:	00 
  21e3a7:	8a 54 24 1e          	mov    dl,BYTE PTR [rsp+0x1e]
  21e3ab:	88 94 24 ee 00 00 00 	mov    BYTE PTR [rsp+0xee],dl
  21e3b2:	31 d2                	xor    edx,edx
            return parseFormValueConstant(allocator, in_stream, signed, block_len);
  21e3b4:	66 89 55 00          	mov    WORD PTR [rbp+0x0],dx
  21e3b8:	0f b7 56 04          	movzx  edx,WORD PTR [rsi+0x4]
  21e3bc:	66 89 55 06          	mov    WORD PTR [rbp+0x6],dx
  21e3c0:	8b 16                	mov    edx,DWORD PTR [rsi]
  21e3c2:	89 55 02             	mov    DWORD PTR [rbp+0x2],edx
  21e3c5:	c5 f8 11 45 08       	vmovups XMMWORD PTR [rbp+0x8],xmm0
  21e3ca:	40 88 7d 18          	mov    BYTE PTR [rbp+0x18],dil
  21e3ce:	8a 50 06             	mov    dl,BYTE PTR [rax+0x6]
  21e3d1:	88 55 1f             	mov    BYTE PTR [rbp+0x1f],dl
  21e3d4:	0f b7 50 04          	movzx  edx,WORD PTR [rax+0x4]
  21e3d8:	66 89 55 1d          	mov    WORD PTR [rbp+0x1d],dx
  21e3dc:	8b 00                	mov    eax,DWORD PTR [rax]
  21e3de:	89 45 19             	mov    DWORD PTR [rbp+0x19],eax
  21e3e1:	88 5d 20             	mov    BYTE PTR [rbp+0x20],bl
  21e3e4:	0f b7 41 04          	movzx  eax,WORD PTR [rcx+0x4]
  21e3e8:	66 89 45 25          	mov    WORD PTR [rbp+0x25],ax
  21e3ec:	8b 01                	mov    eax,DWORD PTR [rcx]
  21e3ee:	89 45 21             	mov    DWORD PTR [rbp+0x21],eax
  21e3f1:	8a 41 06             	mov    al,BYTE PTR [rcx+0x6]
  21e3f4:	88 45 27             	mov    BYTE PTR [rbp+0x27],al
  21e3f7:	e9 0b fa ff ff       	jmp    21de07 <parseFormValue+0x1a17>
            for (bytes) |b, index| {
  21e3fc:	48 89 c3             	mov    rbx,rax
  21e3ff:	48 83 e3 f0          	and    rbx,0xfffffffffffffff0
  21e403:	48 8d 6b f0          	lea    rbp,[rbx-0x10]
  21e407:	48 89 e9             	mov    rcx,rbp
  21e40a:	48 c1 e9 04          	shr    rcx,0x4
  21e40e:	8d 79 01             	lea    edi,[rcx+0x1]
  21e411:	83 e7 01             	and    edi,0x1
  21e414:	48 85 ed             	test   rbp,rbp
  21e417:	0f 84 29 05 00 00    	je     21e946 <parseFormValue+0x2556>
  21e41d:	48 8d 6f ff          	lea    rbp,[rdi-0x1]
  21e421:	48 29 cd             	sub    rbp,rcx
  21e424:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  21e428:	c5 fd 6f 0d 70 1d fe 	vmovdqa ymm1,YMMWORD PTR [rip+0xfffffffffffe1d70]        # 2001a0 <__unnamed_103-0x40>
  21e42f:	ff 
  21e430:	31 c9                	xor    ecx,ecx
  21e432:	c4 e2 7d 59 2d 85 28 	vpbroadcastq ymm5,QWORD PTR [rip+0xfffffffffffe2885]        # 200cc0 <__unnamed_456+0x70>
  21e439:	fe ff 
  21e43b:	c4 e2 7d 59 35 ec 28 	vpbroadcastq ymm6,QWORD PTR [rip+0xfffffffffffe28ec]        # 200d30 <app_mask+0x50>
  21e442:	fe ff 
  21e444:	c4 e2 7d 59 3d d3 28 	vpbroadcastq ymm7,QWORD PTR [rip+0xfffffffffffe28d3]        # 200d20 <app_mask+0x40>
  21e44b:	fe ff 
  21e44d:	c4 62 7d 59 05 12 28 	vpbroadcastq ymm8,QWORD PTR [rip+0xfffffffffffe2812]        # 200c68 <__unnamed_456+0x18>
  21e454:	fe ff 
  21e456:	c5 e1 ef db          	vpxor  xmm3,xmm3,xmm3
  21e45a:	c5 d9 ef e4          	vpxor  xmm4,xmm4,xmm4
  21e45e:	c5 e9 ef d2          	vpxor  xmm2,xmm2,xmm2
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  21e462:	c4 62 7d 32 0c 0a    	vpmovzxbq ymm9,DWORD PTR [rdx+rcx*1]
  21e468:	c4 62 7d 32 54 0a 04 	vpmovzxbq ymm10,DWORD PTR [rdx+rcx*1+0x4]
  21e46f:	c4 62 7d 32 5c 0a 08 	vpmovzxbq ymm11,DWORD PTR [rdx+rcx*1+0x8]
  21e476:	c4 62 7d 32 64 0a 0c 	vpmovzxbq ymm12,DWORD PTR [rdx+rcx*1+0xc]
  21e47d:	c5 95 73 f1 03       	vpsllq ymm13,ymm1,0x3
  21e482:	c5 15 d4 f5          	vpaddq ymm14,ymm13,ymm5
  21e486:	c5 15 db fe          	vpand  ymm15,ymm13,ymm6
  21e48a:	c5 0d db f6          	vpand  ymm14,ymm14,ymm6
  21e48e:	c4 42 b5 47 cf       	vpsllvq ymm9,ymm9,ymm15
  21e493:	c5 b5 eb c0          	vpor   ymm0,ymm9,ymm0
  21e497:	c4 42 ad 47 ce       	vpsllvq ymm9,ymm10,ymm14
  21e49c:	c5 b5 eb db          	vpor   ymm3,ymm9,ymm3
  21e4a0:	c4 42 a5 47 cf       	vpsllvq ymm9,ymm11,ymm15
  21e4a5:	c5 b5 eb e4          	vpor   ymm4,ymm9,ymm4
  21e4a9:	c4 42 9d 47 ce       	vpsllvq ymm9,ymm12,ymm14
  21e4ae:	c4 62 7d 32 54 0a 10 	vpmovzxbq ymm10,DWORD PTR [rdx+rcx*1+0x10]
  21e4b5:	c4 62 7d 32 5c 0a 14 	vpmovzxbq ymm11,DWORD PTR [rdx+rcx*1+0x14]
  21e4bc:	c4 62 7d 32 64 0a 18 	vpmovzxbq ymm12,DWORD PTR [rdx+rcx*1+0x18]
  21e4c3:	c4 62 7d 32 74 0a 1c 	vpmovzxbq ymm14,DWORD PTR [rdx+rcx*1+0x1c]
  21e4ca:	c5 b5 eb d2          	vpor   ymm2,ymm9,ymm2
  21e4ce:	c5 15 d4 cf          	vpaddq ymm9,ymm13,ymm7
  21e4d2:	c4 41 15 d4 e8       	vpaddq ymm13,ymm13,ymm8
  21e4d7:	c5 35 db ce          	vpand  ymm9,ymm9,ymm6
  21e4db:	c5 15 db ee          	vpand  ymm13,ymm13,ymm6
  21e4df:	c4 42 ad 47 d1       	vpsllvq ymm10,ymm10,ymm9
  21e4e4:	c5 ad eb c0          	vpor   ymm0,ymm10,ymm0
  21e4e8:	c4 42 a5 47 d5       	vpsllvq ymm10,ymm11,ymm13
  21e4ed:	c5 ad eb db          	vpor   ymm3,ymm10,ymm3
  21e4f1:	c4 42 9d 47 c9       	vpsllvq ymm9,ymm12,ymm9
  21e4f6:	c5 b5 eb e4          	vpor   ymm4,ymm9,ymm4
  21e4fa:	c4 42 8d 47 cd       	vpsllvq ymm9,ymm14,ymm13
  21e4ff:	c5 b5 eb d2          	vpor   ymm2,ymm9,ymm2
            for (bytes) |b, index| {
  21e503:	48 83 c1 20          	add    rcx,0x20
  21e507:	c5 f5 d4 cd          	vpaddq ymm1,ymm1,ymm5
  21e50b:	48 83 c5 02          	add    rbp,0x2
  21e50f:	0f 85 4d ff ff ff    	jne    21e462 <parseFormValue+0x2072>
  21e515:	e9 46 04 00 00       	jmp    21e960 <parseFormValue+0x2570>
  21e51a:	48 89 c3             	mov    rbx,rax
  21e51d:	48 83 e3 f0          	and    rbx,0xfffffffffffffff0
  21e521:	48 8d 6b f0          	lea    rbp,[rbx-0x10]
  21e525:	48 89 e9             	mov    rcx,rbp
  21e528:	48 c1 e9 04          	shr    rcx,0x4
  21e52c:	8d 79 01             	lea    edi,[rcx+0x1]
  21e52f:	83 e7 01             	and    edi,0x1
  21e532:	48 85 ed             	test   rbp,rbp
  21e535:	0f 84 ec 05 00 00    	je     21eb27 <parseFormValue+0x2737>
  21e53b:	48 8d 6f ff          	lea    rbp,[rdi-0x1]
  21e53f:	48 29 cd             	sub    rbp,rcx
  21e542:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  21e546:	c5 fd 6f 0d 52 1c fe 	vmovdqa ymm1,YMMWORD PTR [rip+0xfffffffffffe1c52]        # 2001a0 <__unnamed_103-0x40>
  21e54d:	ff 
  21e54e:	31 c9                	xor    ecx,ecx
  21e550:	c4 e2 7d 59 2d 67 27 	vpbroadcastq ymm5,QWORD PTR [rip+0xfffffffffffe2767]        # 200cc0 <__unnamed_456+0x70>
  21e557:	fe ff 
  21e559:	c4 e2 7d 59 35 ce 27 	vpbroadcastq ymm6,QWORD PTR [rip+0xfffffffffffe27ce]        # 200d30 <app_mask+0x50>
  21e560:	fe ff 
  21e562:	c4 e2 7d 59 3d b5 27 	vpbroadcastq ymm7,QWORD PTR [rip+0xfffffffffffe27b5]        # 200d20 <app_mask+0x40>
  21e569:	fe ff 
  21e56b:	c4 62 7d 59 05 f4 26 	vpbroadcastq ymm8,QWORD PTR [rip+0xfffffffffffe26f4]        # 200c68 <__unnamed_456+0x18>
  21e572:	fe ff 
  21e574:	c5 e1 ef db          	vpxor  xmm3,xmm3,xmm3
  21e578:	c5 d9 ef e4          	vpxor  xmm4,xmm4,xmm4
  21e57c:	c5 e9 ef d2          	vpxor  xmm2,xmm2,xmm2
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  21e580:	c4 62 7d 32 0c 0a    	vpmovzxbq ymm9,DWORD PTR [rdx+rcx*1]
  21e586:	c4 62 7d 32 54 0a 04 	vpmovzxbq ymm10,DWORD PTR [rdx+rcx*1+0x4]
  21e58d:	c4 62 7d 32 5c 0a 08 	vpmovzxbq ymm11,DWORD PTR [rdx+rcx*1+0x8]
  21e594:	c4 62 7d 32 64 0a 0c 	vpmovzxbq ymm12,DWORD PTR [rdx+rcx*1+0xc]
  21e59b:	c5 95 73 f1 03       	vpsllq ymm13,ymm1,0x3
  21e5a0:	c5 15 d4 f5          	vpaddq ymm14,ymm13,ymm5
  21e5a4:	c5 15 db fe          	vpand  ymm15,ymm13,ymm6
  21e5a8:	c5 0d db f6          	vpand  ymm14,ymm14,ymm6
  21e5ac:	c4 42 b5 47 cf       	vpsllvq ymm9,ymm9,ymm15
  21e5b1:	c5 b5 eb c0          	vpor   ymm0,ymm9,ymm0
  21e5b5:	c4 42 ad 47 ce       	vpsllvq ymm9,ymm10,ymm14
  21e5ba:	c5 b5 eb db          	vpor   ymm3,ymm9,ymm3
  21e5be:	c4 42 a5 47 cf       	vpsllvq ymm9,ymm11,ymm15
  21e5c3:	c5 b5 eb e4          	vpor   ymm4,ymm9,ymm4
  21e5c7:	c4 42 9d 47 ce       	vpsllvq ymm9,ymm12,ymm14
  21e5cc:	c4 62 7d 32 54 0a 10 	vpmovzxbq ymm10,DWORD PTR [rdx+rcx*1+0x10]
  21e5d3:	c4 62 7d 32 5c 0a 14 	vpmovzxbq ymm11,DWORD PTR [rdx+rcx*1+0x14]
  21e5da:	c4 62 7d 32 64 0a 18 	vpmovzxbq ymm12,DWORD PTR [rdx+rcx*1+0x18]
  21e5e1:	c4 62 7d 32 74 0a 1c 	vpmovzxbq ymm14,DWORD PTR [rdx+rcx*1+0x1c]
  21e5e8:	c5 b5 eb d2          	vpor   ymm2,ymm9,ymm2
  21e5ec:	c5 15 d4 cf          	vpaddq ymm9,ymm13,ymm7
  21e5f0:	c4 41 15 d4 e8       	vpaddq ymm13,ymm13,ymm8
  21e5f5:	c5 35 db ce          	vpand  ymm9,ymm9,ymm6
  21e5f9:	c5 15 db ee          	vpand  ymm13,ymm13,ymm6
  21e5fd:	c4 42 ad 47 d1       	vpsllvq ymm10,ymm10,ymm9
  21e602:	c5 ad eb c0          	vpor   ymm0,ymm10,ymm0
  21e606:	c4 42 a5 47 d5       	vpsllvq ymm10,ymm11,ymm13
  21e60b:	c5 ad eb db          	vpor   ymm3,ymm10,ymm3
  21e60f:	c4 42 9d 47 c9       	vpsllvq ymm9,ymm12,ymm9
  21e614:	c5 b5 eb e4          	vpor   ymm4,ymm9,ymm4
  21e618:	c4 42 8d 47 cd       	vpsllvq ymm9,ymm14,ymm13
  21e61d:	c5 b5 eb d2          	vpor   ymm2,ymm9,ymm2
            for (bytes) |b, index| {
  21e621:	48 83 c1 20          	add    rcx,0x20
  21e625:	c5 f5 d4 cd          	vpaddq ymm1,ymm1,ymm5
  21e629:	48 83 c5 02          	add    rbp,0x2
  21e62d:	0f 85 4d ff ff ff    	jne    21e580 <parseFormValue+0x2190>
  21e633:	e9 09 05 00 00       	jmp    21eb41 <parseFormValue+0x2751>
  21e638:	48 89 c3             	mov    rbx,rax
  21e63b:	48 83 e3 f0          	and    rbx,0xfffffffffffffff0
  21e63f:	48 8d 6b f0          	lea    rbp,[rbx-0x10]
  21e643:	48 89 e9             	mov    rcx,rbp
  21e646:	48 c1 e9 04          	shr    rcx,0x4
  21e64a:	8d 79 01             	lea    edi,[rcx+0x1]
  21e64d:	83 e7 01             	and    edi,0x1
  21e650:	48 85 ed             	test   rbp,rbp
  21e653:	0f 84 af 06 00 00    	je     21ed08 <parseFormValue+0x2918>
  21e659:	48 8d 6f ff          	lea    rbp,[rdi-0x1]
  21e65d:	48 29 cd             	sub    rbp,rcx
  21e660:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  21e664:	c5 fd 6f 0d 34 1b fe 	vmovdqa ymm1,YMMWORD PTR [rip+0xfffffffffffe1b34]        # 2001a0 <__unnamed_103-0x40>
  21e66b:	ff 
  21e66c:	31 c9                	xor    ecx,ecx
  21e66e:	c4 e2 7d 59 2d 49 26 	vpbroadcastq ymm5,QWORD PTR [rip+0xfffffffffffe2649]        # 200cc0 <__unnamed_456+0x70>
  21e675:	fe ff 
  21e677:	c4 e2 7d 59 35 b0 26 	vpbroadcastq ymm6,QWORD PTR [rip+0xfffffffffffe26b0]        # 200d30 <app_mask+0x50>
  21e67e:	fe ff 
  21e680:	c4 e2 7d 59 3d 97 26 	vpbroadcastq ymm7,QWORD PTR [rip+0xfffffffffffe2697]        # 200d20 <app_mask+0x40>
  21e687:	fe ff 
  21e689:	c4 62 7d 59 05 d6 25 	vpbroadcastq ymm8,QWORD PTR [rip+0xfffffffffffe25d6]        # 200c68 <__unnamed_456+0x18>
  21e690:	fe ff 
  21e692:	c5 e1 ef db          	vpxor  xmm3,xmm3,xmm3
  21e696:	c5 d9 ef e4          	vpxor  xmm4,xmm4,xmm4
  21e69a:	c5 e9 ef d2          	vpxor  xmm2,xmm2,xmm2
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  21e69e:	c4 62 7d 32 0c 0a    	vpmovzxbq ymm9,DWORD PTR [rdx+rcx*1]
  21e6a4:	c4 62 7d 32 54 0a 04 	vpmovzxbq ymm10,DWORD PTR [rdx+rcx*1+0x4]
  21e6ab:	c4 62 7d 32 5c 0a 08 	vpmovzxbq ymm11,DWORD PTR [rdx+rcx*1+0x8]
  21e6b2:	c4 62 7d 32 64 0a 0c 	vpmovzxbq ymm12,DWORD PTR [rdx+rcx*1+0xc]
  21e6b9:	c5 95 73 f1 03       	vpsllq ymm13,ymm1,0x3
  21e6be:	c5 15 d4 f5          	vpaddq ymm14,ymm13,ymm5
  21e6c2:	c5 15 db fe          	vpand  ymm15,ymm13,ymm6
  21e6c6:	c5 0d db f6          	vpand  ymm14,ymm14,ymm6
  21e6ca:	c4 42 b5 47 cf       	vpsllvq ymm9,ymm9,ymm15
  21e6cf:	c5 b5 eb c0          	vpor   ymm0,ymm9,ymm0
  21e6d3:	c4 42 ad 47 ce       	vpsllvq ymm9,ymm10,ymm14
  21e6d8:	c5 b5 eb db          	vpor   ymm3,ymm9,ymm3
  21e6dc:	c4 42 a5 47 cf       	vpsllvq ymm9,ymm11,ymm15
  21e6e1:	c5 b5 eb e4          	vpor   ymm4,ymm9,ymm4
  21e6e5:	c4 42 9d 47 ce       	vpsllvq ymm9,ymm12,ymm14
  21e6ea:	c4 62 7d 32 54 0a 10 	vpmovzxbq ymm10,DWORD PTR [rdx+rcx*1+0x10]
  21e6f1:	c4 62 7d 32 5c 0a 14 	vpmovzxbq ymm11,DWORD PTR [rdx+rcx*1+0x14]
  21e6f8:	c4 62 7d 32 64 0a 18 	vpmovzxbq ymm12,DWORD PTR [rdx+rcx*1+0x18]
  21e6ff:	c4 62 7d 32 74 0a 1c 	vpmovzxbq ymm14,DWORD PTR [rdx+rcx*1+0x1c]
  21e706:	c5 b5 eb d2          	vpor   ymm2,ymm9,ymm2
  21e70a:	c5 15 d4 cf          	vpaddq ymm9,ymm13,ymm7
  21e70e:	c4 41 15 d4 e8       	vpaddq ymm13,ymm13,ymm8
  21e713:	c5 35 db ce          	vpand  ymm9,ymm9,ymm6
  21e717:	c5 15 db ee          	vpand  ymm13,ymm13,ymm6
  21e71b:	c4 42 ad 47 d1       	vpsllvq ymm10,ymm10,ymm9
  21e720:	c5 ad eb c0          	vpor   ymm0,ymm10,ymm0
  21e724:	c4 42 a5 47 d5       	vpsllvq ymm10,ymm11,ymm13
  21e729:	c5 ad eb db          	vpor   ymm3,ymm10,ymm3
  21e72d:	c4 42 9d 47 c9       	vpsllvq ymm9,ymm12,ymm9
  21e732:	c5 b5 eb e4          	vpor   ymm4,ymm9,ymm4
  21e736:	c4 42 8d 47 cd       	vpsllvq ymm9,ymm14,ymm13
  21e73b:	c5 b5 eb d2          	vpor   ymm2,ymm9,ymm2
            for (bytes) |b, index| {
  21e73f:	48 83 c1 20          	add    rcx,0x20
  21e743:	c5 f5 d4 cd          	vpaddq ymm1,ymm1,ymm5
  21e747:	48 83 c5 02          	add    rbp,0x2
  21e74b:	0f 85 4d ff ff ff    	jne    21e69e <parseFormValue+0x22ae>
  21e751:	e9 cc 05 00 00       	jmp    21ed22 <parseFormValue+0x2932>
    return FormValue{ .Block = buf };
  21e756:	c6 84 24 b0 00 00 00 	mov    BYTE PTR [rsp+0xb0],0x1
  21e75d:	01 
  21e75e:	8b 44 24 78          	mov    eax,DWORD PTR [rsp+0x78]
  21e762:	89 84 24 20 01 00 00 	mov    DWORD PTR [rsp+0x120],eax
  21e769:	0f b7 44 24 7c       	movzx  eax,WORD PTR [rsp+0x7c]
  21e76e:	66 89 84 24 24 01 00 	mov    WORD PTR [rsp+0x124],ax
  21e775:	00 
    const buf = try readAllocBytes(allocator, in_stream, size);
  21e776:	c5 f8 10 44 24 48    	vmovups xmm0,XMMWORD PTR [rsp+0x48]
    return FormValue{ .Block = buf };
  21e77c:	8b 44 24 18          	mov    eax,DWORD PTR [rsp+0x18]
  21e780:	89 84 24 00 01 00 00 	mov    DWORD PTR [rsp+0x100],eax
  21e787:	48 8d b4 24 20 01 00 	lea    rsi,[rsp+0x120]
  21e78e:	00 
  21e78f:	0f b7 44 24 1c       	movzx  eax,WORD PTR [rsp+0x1c]
  21e794:	66 89 84 24 04 01 00 	mov    WORD PTR [rsp+0x104],ax
  21e79b:	00 
  21e79c:	48 8d 84 24 00 01 00 	lea    rax,[rsp+0x100]
  21e7a3:	00 
  21e7a4:	8a 4c 24 1e          	mov    cl,BYTE PTR [rsp+0x1e]
  21e7a8:	88 8c 24 06 01 00 00 	mov    BYTE PTR [rsp+0x106],cl
  21e7af:	b3 01                	mov    bl,0x1
  21e7b1:	8b 8c 24 90 00 00 00 	mov    ecx,DWORD PTR [rsp+0x90]
  21e7b8:	89 8c 24 f8 00 00 00 	mov    DWORD PTR [rsp+0xf8],ecx
  21e7bf:	48 8d 94 24 f8 00 00 	lea    rdx,[rsp+0xf8]
  21e7c6:	00 
  21e7c7:	0f b7 8c 24 94 00 00 	movzx  ecx,WORD PTR [rsp+0x94]
  21e7ce:	00 
  21e7cf:	66 89 8c 24 fc 00 00 	mov    WORD PTR [rsp+0xfc],cx
  21e7d6:	00 
  21e7d7:	8a 8c 24 96 00 00 00 	mov    cl,BYTE PTR [rsp+0x96]
  21e7de:	88 8c 24 fe 00 00 00 	mov    BYTE PTR [rsp+0xfe],cl
  21e7e5:	e9 8f 00 00 00       	jmp    21e879 <parseFormValue+0x2489>
    return FormValue{ .Ref = buf };
  21e7ea:	c6 84 24 b0 00 00 00 	mov    BYTE PTR [rsp+0xb0],0x6
  21e7f1:	06 
  21e7f2:	8b 44 24 78          	mov    eax,DWORD PTR [rsp+0x78]
  21e7f6:	89 84 24 10 01 00 00 	mov    DWORD PTR [rsp+0x110],eax
  21e7fd:	0f b7 44 24 7c       	movzx  eax,WORD PTR [rsp+0x7c]
  21e802:	66 89 84 24 14 01 00 	mov    WORD PTR [rsp+0x114],ax
  21e809:	00 
    const buf = try readAllocBytes(allocator, in_stream, size);
  21e80a:	c5 f8 10 44 24 48    	vmovups xmm0,XMMWORD PTR [rsp+0x48]
    return FormValue{ .Ref = buf };
  21e810:	8b 44 24 18          	mov    eax,DWORD PTR [rsp+0x18]
  21e814:	89 84 24 e0 00 00 00 	mov    DWORD PTR [rsp+0xe0],eax
  21e81b:	48 8d b4 24 10 01 00 	lea    rsi,[rsp+0x110]
  21e822:	00 
  21e823:	0f b7 44 24 1c       	movzx  eax,WORD PTR [rsp+0x1c]
  21e828:	66 89 84 24 e4 00 00 	mov    WORD PTR [rsp+0xe4],ax
  21e82f:	00 
  21e830:	48 8d 84 24 e0 00 00 	lea    rax,[rsp+0xe0]
  21e837:	00 
  21e838:	8a 4c 24 1e          	mov    cl,BYTE PTR [rsp+0x1e]
  21e83c:	88 8c 24 e6 00 00 00 	mov    BYTE PTR [rsp+0xe6],cl
  21e843:	b3 06                	mov    bl,0x6
  21e845:	8b 8c 24 90 00 00 00 	mov    ecx,DWORD PTR [rsp+0x90]
  21e84c:	89 8c 24 d8 00 00 00 	mov    DWORD PTR [rsp+0xd8],ecx
  21e853:	48 8d 94 24 d8 00 00 	lea    rdx,[rsp+0xd8]
  21e85a:	00 
  21e85b:	0f b7 8c 24 94 00 00 	movzx  ecx,WORD PTR [rsp+0x94]
  21e862:	00 
  21e863:	66 89 8c 24 dc 00 00 	mov    WORD PTR [rsp+0xdc],cx
  21e86a:	00 
  21e86b:	8a 8c 24 96 00 00 00 	mov    cl,BYTE PTR [rsp+0x96]
  21e872:	88 8c 24 de 00 00 00 	mov    BYTE PTR [rsp+0xde],cl
  21e879:	31 c9                	xor    ecx,ecx
  21e87b:	66 89 0f             	mov    WORD PTR [rdi],cx
  21e87e:	0f b7 4e 04          	movzx  ecx,WORD PTR [rsi+0x4]
  21e882:	66 89 4f 06          	mov    WORD PTR [rdi+0x6],cx
  21e886:	8b 0e                	mov    ecx,DWORD PTR [rsi]
  21e888:	89 4f 02             	mov    DWORD PTR [rdi+0x2],ecx
  21e88b:	c5 f8 11 47 08       	vmovups XMMWORD PTR [rdi+0x8],xmm0
  21e890:	8a 48 06             	mov    cl,BYTE PTR [rax+0x6]
  21e893:	88 4f 1f             	mov    BYTE PTR [rdi+0x1f],cl
  21e896:	0f b7 48 04          	movzx  ecx,WORD PTR [rax+0x4]
  21e89a:	66 89 4f 1d          	mov    WORD PTR [rdi+0x1d],cx
  21e89e:	8b 00                	mov    eax,DWORD PTR [rax]
  21e8a0:	89 47 19             	mov    DWORD PTR [rdi+0x19],eax
  21e8a3:	88 5f 20             	mov    BYTE PTR [rdi+0x20],bl
  21e8a6:	0f b7 42 04          	movzx  eax,WORD PTR [rdx+0x4]
  21e8aa:	66 89 47 25          	mov    WORD PTR [rdi+0x25],ax
  21e8ae:	8b 02                	mov    eax,DWORD PTR [rdx]
  21e8b0:	89 47 21             	mov    DWORD PTR [rdi+0x21],eax
  21e8b3:	8a 42 06             	mov    al,BYTE PTR [rdx+0x6]
  21e8b6:	88 47 27             	mov    BYTE PTR [rdi+0x27],al
  21e8b9:	e9 49 f5 ff ff       	jmp    21de07 <parseFormValue+0x1a17>
            const buf = try readAllocBytes(allocator, in_stream, size);
  21e8be:	c5 f8 10 84 24 58 04 	vmovups xmm0,XMMWORD PTR [rsp+0x458]
  21e8c5:	00 00 
  21e8c7:	c5 f8 29 84 24 80 04 	vmovaps XMMWORD PTR [rsp+0x480],xmm0
  21e8ce:	00 00 
            return FormValue{ .ExprLoc = buf };
  21e8d0:	c5 f8 11 84 24 38 04 	vmovups XMMWORD PTR [rsp+0x438],xmm0
  21e8d7:	00 00 
  21e8d9:	48 8b 84 24 90 04 00 	mov    rax,QWORD PTR [rsp+0x490]
  21e8e0:	00 
  21e8e1:	48 89 84 24 48 04 00 	mov    QWORD PTR [rsp+0x448],rax
  21e8e8:	00 
  21e8e9:	c6 84 24 ae 00 00 00 	mov    BYTE PTR [rsp+0xae],0x3
  21e8f0:	03 
  21e8f1:	48 8b 4c 24 68       	mov    rcx,QWORD PTR [rsp+0x68]
  21e8f6:	66 c7 01 00 00       	mov    WORD PTR [rcx],0x0
  21e8fb:	c5 f8 10 84 24 32 04 	vmovups xmm0,XMMWORD PTR [rsp+0x432]
  21e902:	00 00 
  21e904:	c5 fa 6f 8c 24 40 04 	vmovdqu xmm1,XMMWORD PTR [rsp+0x440]
  21e90b:	00 00 
  21e90d:	c5 fa 7f 49 10       	vmovdqu XMMWORD PTR [rcx+0x10],xmm1
  21e912:	c5 f8 11 41 02       	vmovups XMMWORD PTR [rcx+0x2],xmm0
  21e917:	8a 84 24 ae 00 00 00 	mov    al,BYTE PTR [rsp+0xae]
  21e91e:	88 41 20             	mov    BYTE PTR [rcx+0x20],al
  21e921:	8a 84 24 10 03 00 00 	mov    al,BYTE PTR [rsp+0x310]
  21e928:	88 41 27             	mov    BYTE PTR [rcx+0x27],al
  21e92b:	0f b7 84 24 0e 03 00 	movzx  eax,WORD PTR [rsp+0x30e]
  21e932:	00 
  21e933:	66 89 41 25          	mov    WORD PTR [rcx+0x25],ax
  21e937:	8b 84 24 0a 03 00 00 	mov    eax,DWORD PTR [rsp+0x30a]
  21e93e:	89 41 21             	mov    DWORD PTR [rcx+0x21],eax
  21e941:	e9 c1 f4 ff ff       	jmp    21de07 <parseFormValue+0x1a17>
  21e946:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  21e94a:	c5 fd 6f 0d 4e 18 fe 	vmovdqa ymm1,YMMWORD PTR [rip+0xfffffffffffe184e]        # 2001a0 <__unnamed_103-0x40>
  21e951:	ff 
  21e952:	31 c9                	xor    ecx,ecx
  21e954:	c5 e1 ef db          	vpxor  xmm3,xmm3,xmm3
  21e958:	c5 d9 ef e4          	vpxor  xmm4,xmm4,xmm4
  21e95c:	c5 e9 ef d2          	vpxor  xmm2,xmm2,xmm2
  21e960:	48 85 ff             	test   rdi,rdi
  21e963:	74 62                	je     21e9c7 <parseFormValue+0x25d7>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  21e965:	c4 e2 7d 32 6c 0a 0c 	vpmovzxbq ymm5,DWORD PTR [rdx+rcx*1+0xc]
  21e96c:	c5 f5 73 f1 03       	vpsllq ymm1,ymm1,0x3
  21e971:	c4 e2 7d 59 35 46 23 	vpbroadcastq ymm6,QWORD PTR [rip+0xfffffffffffe2346]        # 200cc0 <__unnamed_456+0x70>
  21e978:	fe ff 
  21e97a:	c5 f5 d4 f6          	vpaddq ymm6,ymm1,ymm6
  21e97e:	c4 e2 7d 59 3d a9 23 	vpbroadcastq ymm7,QWORD PTR [rip+0xfffffffffffe23a9]        # 200d30 <app_mask+0x50>
  21e985:	fe ff 
  21e987:	c5 cd db f7          	vpand  ymm6,ymm6,ymm7
  21e98b:	c4 e2 d5 47 ee       	vpsllvq ymm5,ymm5,ymm6
  21e990:	c4 62 7d 32 44 0a 08 	vpmovzxbq ymm8,DWORD PTR [rdx+rcx*1+0x8]
  21e997:	c5 d5 eb d2          	vpor   ymm2,ymm5,ymm2
  21e99b:	c5 f5 db cf          	vpand  ymm1,ymm1,ymm7
  21e99f:	c4 e2 bd 47 e9       	vpsllvq ymm5,ymm8,ymm1
  21e9a4:	c5 d5 eb e4          	vpor   ymm4,ymm5,ymm4
  21e9a8:	c4 e2 7d 32 6c 0a 04 	vpmovzxbq ymm5,DWORD PTR [rdx+rcx*1+0x4]
  21e9af:	c4 e2 d5 47 ee       	vpsllvq ymm5,ymm5,ymm6
  21e9b4:	c5 d5 eb db          	vpor   ymm3,ymm5,ymm3
  21e9b8:	c4 e2 7d 32 2c 0a    	vpmovzxbq ymm5,DWORD PTR [rdx+rcx*1]
  21e9be:	c4 e2 d5 47 c9       	vpsllvq ymm1,ymm5,ymm1
  21e9c3:	c5 f5 eb c0          	vpor   ymm0,ymm1,ymm0
  21e9c7:	c5 e5 eb ca          	vpor   ymm1,ymm3,ymm2
  21e9cb:	c5 fd eb c4          	vpor   ymm0,ymm0,ymm4
  21e9cf:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  21e9d3:	c4 e3 7d 39 c1 01    	vextracti128 xmm1,ymm0,0x1
  21e9d9:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  21e9dd:	c5 f9 70 c8 4e       	vpshufd xmm1,xmm0,0x4e
  21e9e2:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  21e9e6:	c4 e1 f9 7e c1       	vmovq  rcx,xmm0
  21e9eb:	48 39 d8             	cmp    rax,rbx
            for (bytes) |b, index| {
  21e9ee:	74 29                	je     21ea19 <parseFormValue+0x2629>
  21e9f0:	48 29 d8             	sub    rax,rbx
  21e9f3:	48 01 da             	add    rdx,rbx
  21e9f6:	48 c1 e3 03          	shl    rbx,0x3
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  21e9fa:	0f b6 3a             	movzx  edi,BYTE PTR [rdx]
  21e9fd:	89 de                	mov    esi,ebx
  21e9ff:	40 80 e6 38          	and    sil,0x38
  21ea03:	c4 e2 c9 f7 f7       	shlx   rsi,rdi,rsi
  21ea08:	48 09 f1             	or     rcx,rsi
            for (bytes) |b, index| {
  21ea0b:	48 83 c3 08          	add    rbx,0x8
  21ea0f:	48 83 c2 01          	add    rdx,0x1
  21ea13:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  21ea17:	75 e1                	jne    21e9fa <parseFormValue+0x260a>
  21ea19:	48 8d 7c 24 78       	lea    rdi,[rsp+0x78]
    const buf = try readAllocBytes(allocator, in_stream, size);
  21ea1e:	4c 89 fe             	mov    rsi,r15
  21ea21:	4c 89 e2             	mov    rdx,r12
  21ea24:	c5 f8 77             	vzeroupper 
  21ea27:	e8 54 07 00 00       	call   21f180 <readAllocBytes>
  21ea2c:	0f b7 44 24 78       	movzx  eax,WORD PTR [rsp+0x78]
  21ea31:	66 85 c0             	test   ax,ax
  21ea34:	74 39                	je     21ea6f <parseFormValue+0x267f>
  21ea36:	c5 f8 10 44 24 40    	vmovups xmm0,XMMWORD PTR [rsp+0x40]
  21ea3c:	c5 fa 6f 4c 24 4e    	vmovdqu xmm1,XMMWORD PTR [rsp+0x4e]
  21ea42:	c5 fa 7f 8c 24 9e 00 	vmovdqu XMMWORD PTR [rsp+0x9e],xmm1
  21ea49:	00 00 
  21ea4b:	c5 f8 29 84 24 90 00 	vmovaps XMMWORD PTR [rsp+0x90],xmm0
  21ea52:	00 00 
  21ea54:	8b 4c 24 60          	mov    ecx,DWORD PTR [rsp+0x60]
  21ea58:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  21ea5b:	0f b7 4c 24 64       	movzx  ecx,WORD PTR [rsp+0x64]
  21ea60:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  21ea65:	8a 4c 24 66          	mov    cl,BYTE PTR [rsp+0x66]
  21ea69:	88 4c 24 06          	mov    BYTE PTR [rsp+0x6],cl
  21ea6d:	eb 65                	jmp    21ead4 <parseFormValue+0x26e4>
  21ea6f:	c5 f8 10 84 24 80 00 	vmovups xmm0,XMMWORD PTR [rsp+0x80]
  21ea76:	00 00 
  21ea78:	c5 f8 29 84 24 b0 00 	vmovaps XMMWORD PTR [rsp+0xb0],xmm0
  21ea7f:	00 00 
    return FormValue{ .Block = buf };
  21ea81:	c5 f8 11 44 24 1e    	vmovups XMMWORD PTR [rsp+0x1e],xmm0
  21ea87:	48 8b 84 24 c0 00 00 	mov    rax,QWORD PTR [rsp+0xc0]
  21ea8e:	00 
  21ea8f:	48 89 44 24 2e       	mov    QWORD PTR [rsp+0x2e],rax
  21ea94:	c6 44 24 08 01       	mov    BYTE PTR [rsp+0x8],0x1
  21ea99:	8b 44 24 71          	mov    eax,DWORD PTR [rsp+0x71]
  21ea9d:	89 04 24             	mov    DWORD PTR [rsp],eax
  21eaa0:	0f b7 44 24 75       	movzx  eax,WORD PTR [rsp+0x75]
  21eaa5:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  21eaaa:	8a 44 24 77          	mov    al,BYTE PTR [rsp+0x77]
  21eaae:	88 44 24 06          	mov    BYTE PTR [rsp+0x6],al
  21eab2:	c5 f8 10 44 24 18    	vmovups xmm0,XMMWORD PTR [rsp+0x18]
  21eab8:	c5 f8 29 84 24 90 00 	vmovaps XMMWORD PTR [rsp+0x90],xmm0
  21eabf:	00 00 
  21eac1:	c5 f8 10 44 24 26    	vmovups xmm0,XMMWORD PTR [rsp+0x26]
  21eac7:	c5 f8 11 84 24 9e 00 	vmovups XMMWORD PTR [rsp+0x9e],xmm0
  21eace:	00 00 
  21ead0:	b1 01                	mov    cl,0x1
  21ead2:	31 c0                	xor    eax,eax
    return parseFormValueBlockLen(allocator, in_stream, block_len);
  21ead4:	66 89 84 24 90 02 00 	mov    WORD PTR [rsp+0x290],ax
  21eadb:	00 
  21eadc:	c5 f8 28 84 24 90 00 	vmovaps xmm0,XMMWORD PTR [rsp+0x90]
  21eae3:	00 00 
  21eae5:	c5 f8 11 84 24 92 02 	vmovups XMMWORD PTR [rsp+0x292],xmm0
  21eaec:	00 00 
  21eaee:	c5 f8 10 84 24 9e 00 	vmovups xmm0,XMMWORD PTR [rsp+0x9e]
  21eaf5:	00 00 
  21eaf7:	c5 f8 11 84 24 a0 02 	vmovups XMMWORD PTR [rsp+0x2a0],xmm0
  21eafe:	00 00 
  21eb00:	88 8c 24 b0 02 00 00 	mov    BYTE PTR [rsp+0x2b0],cl
  21eb07:	8b 04 24             	mov    eax,DWORD PTR [rsp]
  21eb0a:	89 84 24 b1 02 00 00 	mov    DWORD PTR [rsp+0x2b1],eax
  21eb11:	0f b7 44 24 04       	movzx  eax,WORD PTR [rsp+0x4]
  21eb16:	66 89 84 24 b5 02 00 	mov    WORD PTR [rsp+0x2b5],ax
  21eb1d:	00 
  21eb1e:	8a 44 24 06          	mov    al,BYTE PTR [rsp+0x6]
  21eb22:	e9 78 da ff ff       	jmp    21c59f <parseFormValue+0x1af>
  21eb27:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  21eb2b:	c5 fd 6f 0d 6d 16 fe 	vmovdqa ymm1,YMMWORD PTR [rip+0xfffffffffffe166d]        # 2001a0 <__unnamed_103-0x40>
  21eb32:	ff 
  21eb33:	31 c9                	xor    ecx,ecx
  21eb35:	c5 e1 ef db          	vpxor  xmm3,xmm3,xmm3
  21eb39:	c5 d9 ef e4          	vpxor  xmm4,xmm4,xmm4
  21eb3d:	c5 e9 ef d2          	vpxor  xmm2,xmm2,xmm2
  21eb41:	48 85 ff             	test   rdi,rdi
  21eb44:	74 62                	je     21eba8 <parseFormValue+0x27b8>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  21eb46:	c4 e2 7d 32 6c 0a 0c 	vpmovzxbq ymm5,DWORD PTR [rdx+rcx*1+0xc]
  21eb4d:	c5 f5 73 f1 03       	vpsllq ymm1,ymm1,0x3
  21eb52:	c4 e2 7d 59 35 65 21 	vpbroadcastq ymm6,QWORD PTR [rip+0xfffffffffffe2165]        # 200cc0 <__unnamed_456+0x70>
  21eb59:	fe ff 
  21eb5b:	c5 f5 d4 f6          	vpaddq ymm6,ymm1,ymm6
  21eb5f:	c4 e2 7d 59 3d c8 21 	vpbroadcastq ymm7,QWORD PTR [rip+0xfffffffffffe21c8]        # 200d30 <app_mask+0x50>
  21eb66:	fe ff 
  21eb68:	c5 cd db f7          	vpand  ymm6,ymm6,ymm7
  21eb6c:	c4 e2 d5 47 ee       	vpsllvq ymm5,ymm5,ymm6
  21eb71:	c4 62 7d 32 44 0a 08 	vpmovzxbq ymm8,DWORD PTR [rdx+rcx*1+0x8]
  21eb78:	c5 d5 eb d2          	vpor   ymm2,ymm5,ymm2
  21eb7c:	c5 f5 db cf          	vpand  ymm1,ymm1,ymm7
  21eb80:	c4 e2 bd 47 e9       	vpsllvq ymm5,ymm8,ymm1
  21eb85:	c5 d5 eb e4          	vpor   ymm4,ymm5,ymm4
  21eb89:	c4 e2 7d 32 6c 0a 04 	vpmovzxbq ymm5,DWORD PTR [rdx+rcx*1+0x4]
  21eb90:	c4 e2 d5 47 ee       	vpsllvq ymm5,ymm5,ymm6
  21eb95:	c5 d5 eb db          	vpor   ymm3,ymm5,ymm3
  21eb99:	c4 e2 7d 32 2c 0a    	vpmovzxbq ymm5,DWORD PTR [rdx+rcx*1]
  21eb9f:	c4 e2 d5 47 c9       	vpsllvq ymm1,ymm5,ymm1
  21eba4:	c5 f5 eb c0          	vpor   ymm0,ymm1,ymm0
  21eba8:	c5 e5 eb ca          	vpor   ymm1,ymm3,ymm2
  21ebac:	c5 fd eb c4          	vpor   ymm0,ymm0,ymm4
  21ebb0:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  21ebb4:	c4 e3 7d 39 c1 01    	vextracti128 xmm1,ymm0,0x1
  21ebba:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  21ebbe:	c5 f9 70 c8 4e       	vpshufd xmm1,xmm0,0x4e
  21ebc3:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  21ebc7:	c4 e1 f9 7e c1       	vmovq  rcx,xmm0
  21ebcc:	48 39 d8             	cmp    rax,rbx
            for (bytes) |b, index| {
  21ebcf:	74 29                	je     21ebfa <parseFormValue+0x280a>
  21ebd1:	48 29 d8             	sub    rax,rbx
  21ebd4:	48 01 da             	add    rdx,rbx
  21ebd7:	48 c1 e3 03          	shl    rbx,0x3
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  21ebdb:	0f b6 3a             	movzx  edi,BYTE PTR [rdx]
  21ebde:	89 de                	mov    esi,ebx
  21ebe0:	40 80 e6 38          	and    sil,0x38
  21ebe4:	c4 e2 c9 f7 f7       	shlx   rsi,rdi,rsi
  21ebe9:	48 09 f1             	or     rcx,rsi
            for (bytes) |b, index| {
  21ebec:	48 83 c3 08          	add    rbx,0x8
  21ebf0:	48 83 c2 01          	add    rdx,0x1
  21ebf4:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  21ebf8:	75 e1                	jne    21ebdb <parseFormValue+0x27eb>
  21ebfa:	48 8d 7c 24 78       	lea    rdi,[rsp+0x78]
    const buf = try readAllocBytes(allocator, in_stream, size);
  21ebff:	4c 89 fe             	mov    rsi,r15
  21ec02:	4c 89 e2             	mov    rdx,r12
  21ec05:	c5 f8 77             	vzeroupper 
  21ec08:	e8 73 05 00 00       	call   21f180 <readAllocBytes>
  21ec0d:	0f b7 44 24 78       	movzx  eax,WORD PTR [rsp+0x78]
  21ec12:	66 85 c0             	test   ax,ax
  21ec15:	74 39                	je     21ec50 <parseFormValue+0x2860>
  21ec17:	c5 f8 10 44 24 40    	vmovups xmm0,XMMWORD PTR [rsp+0x40]
  21ec1d:	c5 fa 6f 4c 24 4e    	vmovdqu xmm1,XMMWORD PTR [rsp+0x4e]
  21ec23:	c5 fa 7f 8c 24 9e 00 	vmovdqu XMMWORD PTR [rsp+0x9e],xmm1
  21ec2a:	00 00 
  21ec2c:	c5 f8 29 84 24 90 00 	vmovaps XMMWORD PTR [rsp+0x90],xmm0
  21ec33:	00 00 
  21ec35:	8b 4c 24 60          	mov    ecx,DWORD PTR [rsp+0x60]
  21ec39:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  21ec3c:	0f b7 4c 24 64       	movzx  ecx,WORD PTR [rsp+0x64]
  21ec41:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  21ec46:	8a 4c 24 66          	mov    cl,BYTE PTR [rsp+0x66]
  21ec4a:	88 4c 24 06          	mov    BYTE PTR [rsp+0x6],cl
  21ec4e:	eb 65                	jmp    21ecb5 <parseFormValue+0x28c5>
  21ec50:	c5 f8 10 84 24 80 00 	vmovups xmm0,XMMWORD PTR [rsp+0x80]
  21ec57:	00 00 
  21ec59:	c5 f8 29 84 24 b0 00 	vmovaps XMMWORD PTR [rsp+0xb0],xmm0
  21ec60:	00 00 
    return FormValue{ .Block = buf };
  21ec62:	c5 f8 11 44 24 1e    	vmovups XMMWORD PTR [rsp+0x1e],xmm0
  21ec68:	48 8b 84 24 c0 00 00 	mov    rax,QWORD PTR [rsp+0xc0]
  21ec6f:	00 
  21ec70:	48 89 44 24 2e       	mov    QWORD PTR [rsp+0x2e],rax
  21ec75:	c6 44 24 08 01       	mov    BYTE PTR [rsp+0x8],0x1
  21ec7a:	8b 44 24 71          	mov    eax,DWORD PTR [rsp+0x71]
  21ec7e:	89 04 24             	mov    DWORD PTR [rsp],eax
  21ec81:	0f b7 44 24 75       	movzx  eax,WORD PTR [rsp+0x75]
  21ec86:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  21ec8b:	8a 44 24 77          	mov    al,BYTE PTR [rsp+0x77]
  21ec8f:	88 44 24 06          	mov    BYTE PTR [rsp+0x6],al
  21ec93:	c5 f8 10 44 24 18    	vmovups xmm0,XMMWORD PTR [rsp+0x18]
  21ec99:	c5 f8 29 84 24 90 00 	vmovaps XMMWORD PTR [rsp+0x90],xmm0
  21eca0:	00 00 
  21eca2:	c5 f8 10 44 24 26    	vmovups xmm0,XMMWORD PTR [rsp+0x26]
  21eca8:	c5 f8 11 84 24 9e 00 	vmovups XMMWORD PTR [rsp+0x9e],xmm0
  21ecaf:	00 00 
  21ecb1:	b1 01                	mov    cl,0x1
  21ecb3:	31 c0                	xor    eax,eax
    return parseFormValueBlockLen(allocator, in_stream, block_len);
  21ecb5:	66 89 84 24 68 02 00 	mov    WORD PTR [rsp+0x268],ax
  21ecbc:	00 
  21ecbd:	c5 f8 28 84 24 90 00 	vmovaps xmm0,XMMWORD PTR [rsp+0x90]
  21ecc4:	00 00 
  21ecc6:	c5 f8 11 84 24 6a 02 	vmovups XMMWORD PTR [rsp+0x26a],xmm0
  21eccd:	00 00 
  21eccf:	c5 f8 10 84 24 9e 00 	vmovups xmm0,XMMWORD PTR [rsp+0x9e]
  21ecd6:	00 00 
  21ecd8:	c5 f8 11 84 24 78 02 	vmovups XMMWORD PTR [rsp+0x278],xmm0
  21ecdf:	00 00 
  21ece1:	88 8c 24 88 02 00 00 	mov    BYTE PTR [rsp+0x288],cl
  21ece8:	8b 04 24             	mov    eax,DWORD PTR [rsp]
  21eceb:	89 84 24 89 02 00 00 	mov    DWORD PTR [rsp+0x289],eax
  21ecf2:	0f b7 44 24 04       	movzx  eax,WORD PTR [rsp+0x4]
  21ecf7:	66 89 84 24 8d 02 00 	mov    WORD PTR [rsp+0x28d],ax
  21ecfe:	00 
  21ecff:	8a 44 24 06          	mov    al,BYTE PTR [rsp+0x6]
  21ed03:	e9 4c d9 ff ff       	jmp    21c654 <parseFormValue+0x264>
  21ed08:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  21ed0c:	c5 fd 6f 0d 8c 14 fe 	vmovdqa ymm1,YMMWORD PTR [rip+0xfffffffffffe148c]        # 2001a0 <__unnamed_103-0x40>
  21ed13:	ff 
  21ed14:	31 c9                	xor    ecx,ecx
  21ed16:	c5 e1 ef db          	vpxor  xmm3,xmm3,xmm3
  21ed1a:	c5 d9 ef e4          	vpxor  xmm4,xmm4,xmm4
  21ed1e:	c5 e9 ef d2          	vpxor  xmm2,xmm2,xmm2
  21ed22:	48 85 ff             	test   rdi,rdi
  21ed25:	74 62                	je     21ed89 <parseFormValue+0x2999>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  21ed27:	c4 e2 7d 32 6c 0a 0c 	vpmovzxbq ymm5,DWORD PTR [rdx+rcx*1+0xc]
  21ed2e:	c5 f5 73 f1 03       	vpsllq ymm1,ymm1,0x3
  21ed33:	c4 e2 7d 59 35 84 1f 	vpbroadcastq ymm6,QWORD PTR [rip+0xfffffffffffe1f84]        # 200cc0 <__unnamed_456+0x70>
  21ed3a:	fe ff 
  21ed3c:	c5 f5 d4 f6          	vpaddq ymm6,ymm1,ymm6
  21ed40:	c4 e2 7d 59 3d e7 1f 	vpbroadcastq ymm7,QWORD PTR [rip+0xfffffffffffe1fe7]        # 200d30 <app_mask+0x50>
  21ed47:	fe ff 
  21ed49:	c5 cd db f7          	vpand  ymm6,ymm6,ymm7
  21ed4d:	c4 e2 d5 47 ee       	vpsllvq ymm5,ymm5,ymm6
  21ed52:	c4 62 7d 32 44 0a 08 	vpmovzxbq ymm8,DWORD PTR [rdx+rcx*1+0x8]
  21ed59:	c5 d5 eb d2          	vpor   ymm2,ymm5,ymm2
  21ed5d:	c5 f5 db cf          	vpand  ymm1,ymm1,ymm7
  21ed61:	c4 e2 bd 47 e9       	vpsllvq ymm5,ymm8,ymm1
  21ed66:	c5 d5 eb e4          	vpor   ymm4,ymm5,ymm4
  21ed6a:	c4 e2 7d 32 6c 0a 04 	vpmovzxbq ymm5,DWORD PTR [rdx+rcx*1+0x4]
  21ed71:	c4 e2 d5 47 ee       	vpsllvq ymm5,ymm5,ymm6
  21ed76:	c5 d5 eb db          	vpor   ymm3,ymm5,ymm3
  21ed7a:	c4 e2 7d 32 2c 0a    	vpmovzxbq ymm5,DWORD PTR [rdx+rcx*1]
  21ed80:	c4 e2 d5 47 c9       	vpsllvq ymm1,ymm5,ymm1
  21ed85:	c5 f5 eb c0          	vpor   ymm0,ymm1,ymm0
  21ed89:	c5 e5 eb ca          	vpor   ymm1,ymm3,ymm2
  21ed8d:	c5 fd eb c4          	vpor   ymm0,ymm0,ymm4
  21ed91:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  21ed95:	c4 e3 7d 39 c1 01    	vextracti128 xmm1,ymm0,0x1
  21ed9b:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  21ed9f:	c5 f9 70 c8 4e       	vpshufd xmm1,xmm0,0x4e
  21eda4:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  21eda8:	c4 e1 f9 7e c1       	vmovq  rcx,xmm0
  21edad:	48 39 d8             	cmp    rax,rbx
            for (bytes) |b, index| {
  21edb0:	74 29                	je     21eddb <parseFormValue+0x29eb>
  21edb2:	48 29 d8             	sub    rax,rbx
  21edb5:	48 01 da             	add    rdx,rbx
  21edb8:	48 c1 e3 03          	shl    rbx,0x3
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  21edbc:	0f b6 3a             	movzx  edi,BYTE PTR [rdx]
  21edbf:	89 de                	mov    esi,ebx
  21edc1:	40 80 e6 38          	and    sil,0x38
  21edc5:	c4 e2 c9 f7 f7       	shlx   rsi,rdi,rsi
  21edca:	48 09 f1             	or     rcx,rsi
            for (bytes) |b, index| {
  21edcd:	48 83 c3 08          	add    rbx,0x8
  21edd1:	48 83 c2 01          	add    rdx,0x1
  21edd5:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  21edd9:	75 e1                	jne    21edbc <parseFormValue+0x29cc>
  21eddb:	48 8d 7c 24 78       	lea    rdi,[rsp+0x78]
    const buf = try readAllocBytes(allocator, in_stream, size);
  21ede0:	4c 89 fe             	mov    rsi,r15
  21ede3:	4c 89 e2             	mov    rdx,r12
  21ede6:	c5 f8 77             	vzeroupper 
  21ede9:	e8 92 03 00 00       	call   21f180 <readAllocBytes>
  21edee:	0f b7 44 24 78       	movzx  eax,WORD PTR [rsp+0x78]
  21edf3:	66 85 c0             	test   ax,ax
  21edf6:	74 39                	je     21ee31 <parseFormValue+0x2a41>
  21edf8:	c5 f8 10 44 24 40    	vmovups xmm0,XMMWORD PTR [rsp+0x40]
  21edfe:	c5 fa 6f 4c 24 4e    	vmovdqu xmm1,XMMWORD PTR [rsp+0x4e]
  21ee04:	c5 fa 7f 8c 24 9e 00 	vmovdqu XMMWORD PTR [rsp+0x9e],xmm1
  21ee0b:	00 00 
  21ee0d:	c5 f8 29 84 24 90 00 	vmovaps XMMWORD PTR [rsp+0x90],xmm0
  21ee14:	00 00 
  21ee16:	8b 4c 24 60          	mov    ecx,DWORD PTR [rsp+0x60]
  21ee1a:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  21ee1d:	0f b7 4c 24 64       	movzx  ecx,WORD PTR [rsp+0x64]
  21ee22:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  21ee27:	8a 4c 24 66          	mov    cl,BYTE PTR [rsp+0x66]
  21ee2b:	88 4c 24 06          	mov    BYTE PTR [rsp+0x6],cl
  21ee2f:	eb 65                	jmp    21ee96 <parseFormValue+0x2aa6>
  21ee31:	c5 f8 10 84 24 80 00 	vmovups xmm0,XMMWORD PTR [rsp+0x80]
  21ee38:	00 00 
  21ee3a:	c5 f8 29 84 24 b0 00 	vmovaps XMMWORD PTR [rsp+0xb0],xmm0
  21ee41:	00 00 
    return FormValue{ .Block = buf };
  21ee43:	c5 f8 11 44 24 1e    	vmovups XMMWORD PTR [rsp+0x1e],xmm0
  21ee49:	48 8b 84 24 c0 00 00 	mov    rax,QWORD PTR [rsp+0xc0]
  21ee50:	00 
  21ee51:	48 89 44 24 2e       	mov    QWORD PTR [rsp+0x2e],rax
  21ee56:	c6 44 24 08 01       	mov    BYTE PTR [rsp+0x8],0x1
  21ee5b:	8b 44 24 71          	mov    eax,DWORD PTR [rsp+0x71]
  21ee5f:	89 04 24             	mov    DWORD PTR [rsp],eax
  21ee62:	0f b7 44 24 75       	movzx  eax,WORD PTR [rsp+0x75]
  21ee67:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  21ee6c:	8a 44 24 77          	mov    al,BYTE PTR [rsp+0x77]
  21ee70:	88 44 24 06          	mov    BYTE PTR [rsp+0x6],al
  21ee74:	c5 f8 10 44 24 18    	vmovups xmm0,XMMWORD PTR [rsp+0x18]
  21ee7a:	c5 f8 29 84 24 90 00 	vmovaps XMMWORD PTR [rsp+0x90],xmm0
  21ee81:	00 00 
  21ee83:	c5 f8 10 44 24 26    	vmovups xmm0,XMMWORD PTR [rsp+0x26]
  21ee89:	c5 f8 11 84 24 9e 00 	vmovups XMMWORD PTR [rsp+0x9e],xmm0
  21ee90:	00 00 
  21ee92:	b1 01                	mov    cl,0x1
  21ee94:	31 c0                	xor    eax,eax
    return parseFormValueBlockLen(allocator, in_stream, block_len);
  21ee96:	66 89 84 24 b8 02 00 	mov    WORD PTR [rsp+0x2b8],ax
  21ee9d:	00 
  21ee9e:	c5 f8 28 84 24 90 00 	vmovaps xmm0,XMMWORD PTR [rsp+0x90]
  21eea5:	00 00 
  21eea7:	c5 f8 11 84 24 ba 02 	vmovups XMMWORD PTR [rsp+0x2ba],xmm0
  21eeae:	00 00 
  21eeb0:	c5 f8 10 84 24 9e 00 	vmovups xmm0,XMMWORD PTR [rsp+0x9e]
  21eeb7:	00 00 
  21eeb9:	c5 f8 11 84 24 c8 02 	vmovups XMMWORD PTR [rsp+0x2c8],xmm0
  21eec0:	00 00 
  21eec2:	88 8c 24 d8 02 00 00 	mov    BYTE PTR [rsp+0x2d8],cl
  21eec9:	8b 04 24             	mov    eax,DWORD PTR [rsp]
  21eecc:	89 84 24 d9 02 00 00 	mov    DWORD PTR [rsp+0x2d9],eax
  21eed3:	0f b7 44 24 04       	movzx  eax,WORD PTR [rsp+0x4]
  21eed8:	66 89 84 24 dd 02 00 	mov    WORD PTR [rsp+0x2dd],ax
  21eedf:	00 
  21eee0:	8a 44 24 06          	mov    al,BYTE PTR [rsp+0x6]
  21eee4:	e9 d5 da ff ff       	jmp    21c9be <parseFormValue+0x5ce>
  21eee9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

000000000021eef0 <Allocator_alignedRealloc.62>:
    pub fn alignedRealloc(self: *Allocator, comptime T: type, comptime alignment: u29, old_mem: []align(alignment) T, n: usize) ![]align(alignment) T {
  21eef0:	41 56                	push   r14
  21eef2:	53                   	push   rbx
  21eef3:	48 81 ec 88 00 00 00 	sub    rsp,0x88
  21eefa:	48 89 fb             	mov    rbx,rdi
        if (old_mem.len == 0) {
  21eefd:	48 8b 42 08          	mov    rax,QWORD PTR [rdx+0x8]
  21ef01:	48 85 c0             	test   rax,rax
  21ef04:	74 62                	je     21ef68 <Allocator_alignedRealloc.62+0x78>
        if (n == 0) {
  21ef06:	48 85 c9             	test   rcx,rcx
  21ef09:	0f 84 a9 00 00 00    	je     21efb8 <Allocator_alignedRealloc.62+0xc8>
        const old_byte_slice = @sliceToBytes(old_mem);
  21ef0f:	48 8b 12             	mov    rdx,QWORD PTR [rdx]
  21ef12:	48 c1 e0 03          	shl    rax,0x3
  21ef16:	48 8d 04 80          	lea    rax,[rax+rax*4]
  21ef1a:	48 89 54 24 38       	mov    QWORD PTR [rsp+0x38],rdx
  21ef1f:	48 89 44 24 40       	mov    QWORD PTR [rsp+0x40],rax
  21ef24:	ba 28 00 00 00       	mov    edx,0x28
  21ef29:	48 89 c8             	mov    rax,rcx
  21ef2c:	48 f7 e2             	mul    rdx
  21ef2f:	0f 81 d0 00 00 00    	jno    21f005 <Allocator_alignedRealloc.62+0x115>
  21ef35:	48 8d 0d c4 15 fe ff 	lea    rcx,[rip+0xfffffffffffe15c4]        # 200500 <__unnamed_52>
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  21ef3c:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  21ef40:	0f 84 da 00 00 00    	je     21f020 <Allocator_alignedRealloc.62+0x130>
  21ef46:	48 8b 05 ab 91 fe ff 	mov    rax,QWORD PTR [rip+0xfffffffffffe91ab]        # 2080f8 <__unnamed_83+0x10>
  21ef4d:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  21ef51:	c5 f8 10 05 8f 91 fe 	vmovups xmm0,XMMWORD PTR [rip+0xfffffffffffe918f]        # 2080e8 <__unnamed_83>
  21ef58:	ff 
  21ef59:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  21ef5d:	48 81 c4 88 00 00 00 	add    rsp,0x88
  21ef64:	5b                   	pop    rbx
  21ef65:	41 5e                	pop    r14
  21ef67:	c3                   	ret    
        if (n == 0) {
  21ef68:	48 85 c9             	test   rcx,rcx
  21ef6b:	0f 84 fc 00 00 00    	je     21f06d <Allocator_alignedRealloc.62+0x17d>
  21ef71:	ba 28 00 00 00       	mov    edx,0x28
  21ef76:	48 89 c8             	mov    rax,rcx
  21ef79:	48 f7 e2             	mul    rdx
  21ef7c:	0f 81 0c 01 00 00    	jno    21f08e <Allocator_alignedRealloc.62+0x19e>
  21ef82:	48 8d 0d 77 15 fe ff 	lea    rcx,[rip+0xfffffffffffe1577]        # 200500 <__unnamed_52>
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  21ef89:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  21ef8d:	0f 84 16 01 00 00    	je     21f0a9 <Allocator_alignedRealloc.62+0x1b9>
  21ef93:	0f b7 05 54 91 fe ff 	movzx  eax,WORD PTR [rip+0xfffffffffffe9154]        # 2080ee <__unnamed_83+0x6>
  21ef9a:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  21ef9f:	8b 05 45 91 fe ff    	mov    eax,DWORD PTR [rip+0xfffffffffffe9145]        # 2080ea <__unnamed_83+0x2>
  21efa5:	89 04 24             	mov    DWORD PTR [rsp],eax
  21efa8:	48 89 e0             	mov    rax,rsp
  21efab:	66 b9 01 00          	mov    cx,0x1
  21efaf:	31 f6                	xor    esi,esi
  21efb1:	31 d2                	xor    edx,edx
  21efb3:	e9 9d 01 00 00       	jmp    21f155 <Allocator_alignedRealloc.62+0x265>
        const bytes = @sliceToBytes(memory);
  21efb8:	48 c1 e0 03          	shl    rax,0x3
  21efbc:	48 8d 04 80          	lea    rax,[rax+rax*4]
        if (bytes.len == 0) return;
  21efc0:	48 85 c0             	test   rax,rax
  21efc3:	74 1e                	je     21efe3 <Allocator_alignedRealloc.62+0xf3>
        const bytes = @sliceToBytes(memory);
  21efc5:	48 8b 0a             	mov    rcx,QWORD PTR [rdx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  21efc8:	48 8b 56 10          	mov    rdx,QWORD PTR [rsi+0x10]
  21efcc:	48 89 4c 24 08       	mov    QWORD PTR [rsp+0x8],rcx
  21efd1:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  21efd6:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  21efdb:	48 89 f7             	mov    rdi,rsi
  21efde:	48 89 c6             	mov    rsi,rax
  21efe1:	ff d2                	call   rdx
            return ([*]align(alignment) T)(undefined)[0..0];
  21efe3:	48 8b 05 f6 90 fe ff 	mov    rax,QWORD PTR [rip+0xfffffffffffe90f6]        # 2080e0 <__unnamed_84+0x10>
  21efea:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  21efee:	c5 f8 10 05 da 90 fe 	vmovups xmm0,XMMWORD PTR [rip+0xfffffffffffe90da]        # 2080d0 <__unnamed_84>
  21eff5:	ff 
  21eff6:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  21effa:	48 81 c4 88 00 00 00 	add    rsp,0x88
  21f001:	5b                   	pop    rbx
  21f002:	41 5e                	pop    r14
  21f004:	c3                   	ret    
  21f005:	48 8d 4c 24 08       	lea    rcx,[rsp+0x8]
  21f00a:	66 c7 44 24 08 00 00 	mov    WORD PTR [rsp+0x8],0x0
  21f011:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  21f016:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  21f01a:	0f 85 26 ff ff ff    	jne    21ef46 <Allocator_alignedRealloc.62+0x56>
  21f020:	4c 8b 71 08          	mov    r14,QWORD PTR [rcx+0x8]
  21f024:	48 8d 7c 24 58       	lea    rdi,[rsp+0x58]
  21f029:	48 8d 54 24 38       	lea    rdx,[rsp+0x38]
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  21f02e:	41 b8 08 00 00 00    	mov    r8d,0x8
  21f034:	4c 89 f1             	mov    rcx,r14
  21f037:	ff 56 08             	call   QWORD PTR [rsi+0x8]
  21f03a:	0f b7 44 24 58       	movzx  eax,WORD PTR [rsp+0x58]
  21f03f:	66 85 c0             	test   ax,ax
  21f042:	0f 84 94 00 00 00    	je     21f0dc <Allocator_alignedRealloc.62+0x1ec>
  21f048:	66 89 03             	mov    WORD PTR [rbx],ax
  21f04b:	48 8b 84 24 80 00 00 	mov    rax,QWORD PTR [rsp+0x80]
  21f052:	00 
  21f053:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  21f057:	c5 f8 10 44 24 72    	vmovups xmm0,XMMWORD PTR [rsp+0x72]
  21f05d:	c5 f8 11 43 02       	vmovups XMMWORD PTR [rbx+0x2],xmm0
  21f062:	48 81 c4 88 00 00 00 	add    rsp,0x88
  21f069:	5b                   	pop    rbx
  21f06a:	41 5e                	pop    r14
  21f06c:	c3                   	ret    
  21f06d:	48 89 e0             	mov    rax,rsp
            return ([*]align(alignment) T)(undefined)[0..0];
  21f070:	0f b7 0d 5f 90 fe ff 	movzx  ecx,WORD PTR [rip+0xfffffffffffe905f]        # 2080d6 <__unnamed_84+0x6>
  21f077:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  21f07c:	8b 0d 50 90 fe ff    	mov    ecx,DWORD PTR [rip+0xfffffffffffe9050]        # 2080d2 <__unnamed_84+0x2>
  21f082:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  21f085:	31 c9                	xor    ecx,ecx
  21f087:	31 d2                	xor    edx,edx
  21f089:	e9 c7 00 00 00       	jmp    21f155 <Allocator_alignedRealloc.62+0x265>
  21f08e:	48 8d 4c 24 48       	lea    rcx,[rsp+0x48]
  21f093:	66 c7 44 24 48 00 00 	mov    WORD PTR [rsp+0x48],0x0
  21f09a:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  21f09f:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  21f0a3:	0f 85 ea fe ff ff    	jne    21ef93 <Allocator_alignedRealloc.62+0xa3>
  21f0a9:	4c 8b 71 08          	mov    r14,QWORD PTR [rcx+0x8]
  21f0ad:	48 8d 7c 24 08       	lea    rdi,[rsp+0x8]
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  21f0b2:	b9 08 00 00 00       	mov    ecx,0x8
  21f0b7:	4c 89 f2             	mov    rdx,r14
  21f0ba:	ff 16                	call   QWORD PTR [rsi]
  21f0bc:	0f b7 4c 24 08       	movzx  ecx,WORD PTR [rsp+0x8]
  21f0c1:	66 85 c9             	test   cx,cx
  21f0c4:	74 57                	je     21f11d <Allocator_alignedRealloc.62+0x22d>
  21f0c6:	0f b7 44 24 36       	movzx  eax,WORD PTR [rsp+0x36]
  21f0cb:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  21f0d0:	48 89 e0             	mov    rax,rsp
  21f0d3:	8b 54 24 32          	mov    edx,DWORD PTR [rsp+0x32]
  21f0d7:	89 14 24             	mov    DWORD PTR [rsp],edx
  21f0da:	eb 79                	jmp    21f155 <Allocator_alignedRealloc.62+0x265>
        assert(byte_slice.len == byte_count);
  21f0dc:	4c 39 74 24 68       	cmp    QWORD PTR [rsp+0x68],r14
    if (!ok) {
  21f0e1:	0f 85 91 00 00 00    	jne    21f178 <Allocator_alignedRealloc.62+0x288>
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  21f0e7:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  21f0ec:	48 b9 cd cc cc cc cc 	movabs rcx,0xcccccccccccccccd
  21f0f3:	cc cc cc 
  21f0f6:	4c 89 f2             	mov    rdx,r14
  21f0f9:	c4 e2 f3 f6 d1       	mulx   rdx,rcx,rcx
  21f0fe:	66 c7 03 00 00       	mov    WORD PTR [rbx],0x0
  21f103:	0f b7 4c 24 2a       	movzx  ecx,WORD PTR [rsp+0x2a]
  21f108:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  21f10c:	48 c1 ea 05          	shr    rdx,0x5
  21f110:	8b 4c 24 26          	mov    ecx,DWORD PTR [rsp+0x26]
  21f114:	89 4b 02             	mov    DWORD PTR [rbx+0x2],ecx
  21f117:	48 89 43 08          	mov    QWORD PTR [rbx+0x8],rax
  21f11b:	eb 4c                	jmp    21f169 <Allocator_alignedRealloc.62+0x279>
        assert(byte_slice.len == byte_count);
  21f11d:	4c 39 74 24 18       	cmp    QWORD PTR [rsp+0x18],r14
  21f122:	75 54                	jne    21f178 <Allocator_alignedRealloc.62+0x288>
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  21f124:	48 8b 74 24 10       	mov    rsi,QWORD PTR [rsp+0x10]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  21f129:	48 b8 cd cc cc cc cc 	movabs rax,0xcccccccccccccccd
  21f130:	cc cc cc 
  21f133:	4c 89 f2             	mov    rdx,r14
  21f136:	c4 e2 fb f6 d0       	mulx   rdx,rax,rax
  21f13b:	48 c1 ea 05          	shr    rdx,0x5
  21f13f:	48 89 e0             	mov    rax,rsp
  21f142:	8b 4c 24 2c          	mov    ecx,DWORD PTR [rsp+0x2c]
  21f146:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  21f149:	0f b7 4c 24 30       	movzx  ecx,WORD PTR [rsp+0x30]
  21f14e:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  21f153:	31 c9                	xor    ecx,ecx
            return self.alignedAlloc(T, alignment, n);
  21f155:	66 89 0b             	mov    WORD PTR [rbx],cx
  21f158:	0f b7 48 04          	movzx  ecx,WORD PTR [rax+0x4]
  21f15c:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  21f160:	8b 00                	mov    eax,DWORD PTR [rax]
  21f162:	89 43 02             	mov    DWORD PTR [rbx+0x2],eax
  21f165:	48 89 73 08          	mov    QWORD PTR [rbx+0x8],rsi
  21f169:	48 89 53 10          	mov    QWORD PTR [rbx+0x10],rdx
  21f16d:	48 81 c4 88 00 00 00 	add    rsp,0x88
  21f174:	5b                   	pop    rbx
  21f175:	41 5e                	pop    r14
  21f177:	c3                   	ret    
            @panic("assertion failure");
  21f178:	e8 63 54 ff ff       	call   2145e0 <panic>
  21f17d:	0f 1f 00             	nop    DWORD PTR [rax]

000000000021f180 <readAllocBytes>:
fn readAllocBytes(allocator: *mem.Allocator, in_stream: var, size: usize) ![]u8 {
  21f180:	55                   	push   rbp
  21f181:	41 57                	push   r15
  21f183:	41 56                	push   r14
  21f185:	41 54                	push   r12
  21f187:	53                   	push   rbx
  21f188:	48 83 ec 70          	sub    rsp,0x70
  21f18c:	48 89 cb             	mov    rbx,rcx
  21f18f:	49 89 d4             	mov    r12,rdx
  21f192:	49 89 f6             	mov    r14,rsi
  21f195:	49 89 ff             	mov    r15,rdi
        if (n == 0) {
  21f198:	48 85 db             	test   rbx,rbx
  21f19b:	74 32                	je     21f1cf <readAllocBytes+0x4f>
  21f19d:	48 89 e7             	mov    rdi,rsp
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  21f1a0:	b9 01 00 00 00       	mov    ecx,0x1
  21f1a5:	4c 89 f6             	mov    rsi,r14
  21f1a8:	48 89 da             	mov    rdx,rbx
  21f1ab:	41 ff 16             	call   QWORD PTR [r14]
  21f1ae:	0f b7 04 24          	movzx  eax,WORD PTR [rsp]
  21f1b2:	66 85 c0             	test   ax,ax
  21f1b5:	74 1c                	je     21f1d3 <readAllocBytes+0x53>
    const buf = try allocator.alloc(u8, size);
  21f1b7:	66 41 89 07          	mov    WORD PTR [r15],ax
  21f1bb:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  21f1c0:	49 89 47 10          	mov    QWORD PTR [r15+0x10],rax
  21f1c4:	c5 f8 10 44 24 5a    	vmovups xmm0,XMMWORD PTR [rsp+0x5a]
  21f1ca:	e9 d8 00 00 00       	jmp    21f2a7 <readAllocBytes+0x127>
  21f1cf:	31 c0                	xor    eax,eax
  21f1d1:	eb 13                	jmp    21f1e6 <readAllocBytes+0x66>
        assert(byte_slice.len == byte_count);
  21f1d3:	48 39 5c 24 10       	cmp    QWORD PTR [rsp+0x10],rbx
    if (!ok) {
  21f1d8:	0f 85 dc 00 00 00    	jne    21f2ba <readAllocBytes+0x13a>
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  21f1de:	48 8b 4c 24 08       	mov    rcx,QWORD PTR [rsp+0x8]
  21f1e3:	48 89 d8             	mov    rax,rbx
    const buf = try allocator.alloc(u8, size);
  21f1e6:	48 89 4c 24 18       	mov    QWORD PTR [rsp+0x18],rcx
  21f1eb:	48 89 44 24 20       	mov    QWORD PTR [rsp+0x20],rax
  21f1f0:	48 89 e7             	mov    rdi,rsp
  21f1f3:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  21f1f8:	4c 89 e6             	mov    rsi,r12
  21f1fb:	41 ff 14 24          	call   QWORD PTR [r12]
  21f1ff:	0f b7 2c 24          	movzx  ebp,WORD PTR [rsp]
    if ((try in_stream.read(buf)) < size) return error.EndOfFile;
  21f203:	66 85 ed             	test   bp,bp
  21f206:	74 39                	je     21f241 <readAllocBytes+0xc1>
        const bytes = @sliceToBytes(memory);
  21f208:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
        if (bytes.len == 0) return;
  21f20d:	48 85 c0             	test   rax,rax
  21f210:	74 1a                	je     21f22c <readAllocBytes+0xac>
        const bytes = @sliceToBytes(memory);
  21f212:	48 8b 4c 24 18       	mov    rcx,QWORD PTR [rsp+0x18]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  21f217:	49 8b 56 10          	mov    rdx,QWORD PTR [r14+0x10]
  21f21b:	48 89 0c 24          	mov    QWORD PTR [rsp],rcx
  21f21f:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  21f224:	48 89 e6             	mov    rsi,rsp
  21f227:	4c 89 f7             	mov    rdi,r14
  21f22a:	ff d2                	call   rdx
  21f22c:	66 41 89 2f          	mov    WORD PTR [r15],bp
  21f230:	48 8b 44 24 52       	mov    rax,QWORD PTR [rsp+0x52]
  21f235:	49 89 47 10          	mov    QWORD PTR [r15+0x10],rax
  21f239:	c5 f8 10 44 24 44    	vmovups xmm0,XMMWORD PTR [rsp+0x44]
  21f23f:	eb 66                	jmp    21f2a7 <readAllocBytes+0x127>
  21f241:	48 39 5c 24 08       	cmp    QWORD PTR [rsp+0x8],rbx
  21f246:	73 3e                	jae    21f286 <readAllocBytes+0x106>
        const bytes = @sliceToBytes(memory);
  21f248:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
        if (bytes.len == 0) return;
  21f24d:	48 85 c0             	test   rax,rax
  21f250:	74 1a                	je     21f26c <readAllocBytes+0xec>
        const bytes = @sliceToBytes(memory);
  21f252:	48 8b 4c 24 18       	mov    rcx,QWORD PTR [rsp+0x18]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  21f257:	49 8b 56 10          	mov    rdx,QWORD PTR [r14+0x10]
  21f25b:	48 89 0c 24          	mov    QWORD PTR [rsp],rcx
  21f25f:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  21f264:	48 89 e6             	mov    rsi,rsp
  21f267:	4c 89 f7             	mov    rdi,r14
  21f26a:	ff d2                	call   rdx
  21f26c:	48 8b 05 0d 92 fe ff 	mov    rax,QWORD PTR [rip+0xfffffffffffe920d]        # 208480 <__unnamed_85+0x10>
  21f273:	49 89 47 10          	mov    QWORD PTR [r15+0x10],rax
  21f277:	c5 f8 10 05 f1 91 fe 	vmovups xmm0,XMMWORD PTR [rip+0xfffffffffffe91f1]        # 208470 <__unnamed_85>
  21f27e:	ff 
  21f27f:	c4 c1 78 11 07       	vmovups XMMWORD PTR [r15],xmm0
  21f284:	eb 27                	jmp    21f2ad <readAllocBytes+0x12d>
    return buf;
  21f286:	c5 f8 10 44 24 18    	vmovups xmm0,XMMWORD PTR [rsp+0x18]
  21f28c:	c5 f8 11 44 24 34    	vmovups XMMWORD PTR [rsp+0x34],xmm0
  21f292:	66 41 c7 07 00 00    	mov    WORD PTR [r15],0x0
  21f298:	48 8b 44 24 3c       	mov    rax,QWORD PTR [rsp+0x3c]
  21f29d:	49 89 47 10          	mov    QWORD PTR [r15+0x10],rax
  21f2a1:	c5 f8 10 44 24 2e    	vmovups xmm0,XMMWORD PTR [rsp+0x2e]
  21f2a7:	c4 c1 78 11 47 02    	vmovups XMMWORD PTR [r15+0x2],xmm0
  21f2ad:	48 83 c4 70          	add    rsp,0x70
  21f2b1:	5b                   	pop    rbx
  21f2b2:	41 5c                	pop    r12
  21f2b4:	41 5e                	pop    r14
  21f2b6:	41 5f                	pop    r15
  21f2b8:	5d                   	pop    rbp
  21f2b9:	c3                   	ret    
            @panic("assertion failure");
  21f2ba:	e8 21 53 ff ff       	call   2145e0 <panic>
  21f2bf:	90                   	nop

000000000021f2c0 <readStringRaw>:
            return Self{
  21f2c0:	55                   	push   rbp
  21f2c1:	41 57                	push   r15
  21f2c3:	41 56                	push   r14
  21f2c5:	41 55                	push   r13
  21f2c7:	41 54                	push   r12
  21f2c9:	53                   	push   rbx
  21f2ca:	48 81 ec 98 00 00 00 	sub    rsp,0x98
  21f2d1:	c5 f8 57 c0          	vxorps xmm0,xmm0,xmm0
  21f2d5:	c5 f8 29 44 24 40    	vmovaps XMMWORD PTR [rsp+0x40],xmm0
  21f2db:	48 89 d3             	mov    rbx,rdx
  21f2de:	49 89 f7             	mov    r15,rsi
  21f2e1:	48 89 7c 24 08       	mov    QWORD PTR [rsp+0x8],rdi
  21f2e6:	48 c7 44 24 50 00 00 	mov    QWORD PTR [rsp+0x50],0x0
  21f2ed:	00 00 
    var buf = ArrayList(u8).init(allocator);
  21f2ef:	4c 89 7c 24 58       	mov    QWORD PTR [rsp+0x58],r15
  21f2f4:	48 8d 44 24 07       	lea    rax,[rsp+0x7]
            try self.readNoEof(result[0..]);
  21f2f9:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  21f2fe:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  21f305:	00 00 
  21f307:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  21f30c:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
            return self.readFn(self, buffer);
  21f311:	48 89 de             	mov    rsi,rbx
  21f314:	ff 13                	call   QWORD PTR [rbx]
  21f316:	0f b7 4c 24 20       	movzx  ecx,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  21f31b:	66 85 c9             	test   cx,cx
  21f31e:	74 34                	je     21f354 <readStringRaw+0x94>
  21f320:	48 8b 54 24 08       	mov    rdx,QWORD PTR [rsp+0x8]
        const byte = try in_stream.readByte();
  21f325:	66 89 0a             	mov    WORD PTR [rdx],cx
  21f328:	48 8b 84 24 90 00 00 	mov    rax,QWORD PTR [rsp+0x90]
  21f32f:	00 
  21f330:	48 89 42 10          	mov    QWORD PTR [rdx+0x10],rax
  21f334:	c5 f8 10 84 24 82 00 	vmovups xmm0,XMMWORD PTR [rsp+0x82]
  21f33b:	00 00 
  21f33d:	c5 f8 11 42 02       	vmovups XMMWORD PTR [rdx+0x2],xmm0
  21f342:	48 81 c4 98 00 00 00 	add    rsp,0x98
  21f349:	5b                   	pop    rbx
  21f34a:	41 5c                	pop    r12
  21f34c:	41 5d                	pop    r13
  21f34e:	41 5e                	pop    r14
  21f350:	41 5f                	pop    r15
  21f352:	5d                   	pop    rbp
  21f353:	c3                   	ret    
  21f354:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
  21f359:	31 ed                	xor    ebp,ebp
  21f35b:	45 31 ed             	xor    r13d,r13d
  21f35e:	66 90                	xchg   ax,ax
            if (amt_read < buf.len) return error.EndOfStream;
  21f360:	48 3b 44 24 18       	cmp    rax,QWORD PTR [rsp+0x18]
  21f365:	0f 82 b6 00 00 00    	jb     21f421 <readStringRaw+0x161>
            return result[0];
  21f36b:	44 8a 64 24 07       	mov    r12b,BYTE PTR [rsp+0x7]
        if (byte == 0) break;
  21f370:	45 84 e4             	test   r12b,r12b
  21f373:	0f 84 b1 00 00 00    	je     21f42a <readStringRaw+0x16a>
            var better_capacity = self.items.len;
  21f379:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
            if (better_capacity >= new_capacity) return;
  21f37e:	4c 39 e9             	cmp    rcx,r13
  21f381:	77 53                	ja     21f3d6 <readStringRaw+0x116>
  21f383:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21f38a:	84 00 00 00 00 00 
                better_capacity += better_capacity / 2 + 8;
  21f390:	48 89 c8             	mov    rax,rcx
  21f393:	48 d1 e8             	shr    rax,1
  21f396:	48 01 c1             	add    rcx,rax
  21f399:	48 83 c1 08          	add    rcx,0x8
                if (better_capacity >= new_capacity) break;
  21f39d:	4c 39 e9             	cmp    rcx,r13
  21f3a0:	76 ee                	jbe    21f390 <readStringRaw+0xd0>
            self.items = try self.allocator.alignedRealloc(T, A, self.items, better_capacity);
  21f3a2:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  21f3a7:	4c 89 fe             	mov    rsi,r15
  21f3aa:	48 8d 54 24 40       	lea    rdx,[rsp+0x40]
  21f3af:	e8 0c 28 00 00       	call   221bc0 <Allocator_alignedRealloc.86>
  21f3b4:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  21f3b9:	66 85 c0             	test   ax,ax
  21f3bc:	0f 85 94 00 00 00    	jne    21f456 <readStringRaw+0x196>
  21f3c2:	48 8d 44 24 28       	lea    rax,[rsp+0x28]
  21f3c7:	c5 f8 10 00          	vmovups xmm0,XMMWORD PTR [rax]
  21f3cb:	c5 f8 29 44 24 40    	vmovaps XMMWORD PTR [rsp+0x40],xmm0
            const result = &self.items[self.len];
  21f3d1:	48 8b 6c 24 40       	mov    rbp,QWORD PTR [rsp+0x40]
  21f3d6:	4d 8d 75 01          	lea    r14,[r13+0x1]
            self.len = new_length;
  21f3da:	4c 89 74 24 50       	mov    QWORD PTR [rsp+0x50],r14
            new_item_ptr.* = item;
  21f3df:	46 88 64 2d 00       	mov    BYTE PTR [rbp+r13*1+0x0],r12b
            try self.readNoEof(result[0..]);
  21f3e4:	48 8d 44 24 07       	lea    rax,[rsp+0x7]
  21f3e9:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  21f3ee:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  21f3f5:	00 00 
            return self.readFn(self, buffer);
  21f3f7:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  21f3fc:	48 89 de             	mov    rsi,rbx
  21f3ff:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  21f404:	ff 13                	call   QWORD PTR [rbx]
  21f406:	0f b7 4c 24 20       	movzx  ecx,WORD PTR [rsp+0x20]
  21f40b:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
  21f410:	4d 89 f5             	mov    r13,r14
            const amt_read = try self.read(buf);
  21f413:	66 85 c9             	test   cx,cx
  21f416:	0f 84 44 ff ff ff    	je     21f360 <readStringRaw+0xa0>
  21f41c:	e9 ff fe ff ff       	jmp    21f320 <readStringRaw+0x60>
  21f421:	66 b9 1f 00          	mov    cx,0x1f
  21f425:	e9 f6 fe ff ff       	jmp    21f320 <readStringRaw+0x60>
  21f42a:	48 8b 54 24 08       	mov    rdx,QWORD PTR [rsp+0x8]
    return buf.toSlice();
  21f42f:	66 c7 02 00 00       	mov    WORD PTR [rdx],0x0
  21f434:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  21f439:	66 89 42 06          	mov    WORD PTR [rdx+0x6],ax
            return self.items[0..self.len];
  21f43d:	48 8b 44 24 40       	mov    rax,QWORD PTR [rsp+0x40]
  21f442:	8b 4c 24 3a          	mov    ecx,DWORD PTR [rsp+0x3a]
  21f446:	89 4a 02             	mov    DWORD PTR [rdx+0x2],ecx
  21f449:	48 89 42 08          	mov    QWORD PTR [rdx+0x8],rax
  21f44d:	4c 89 6a 10          	mov    QWORD PTR [rdx+0x10],r13
  21f451:	e9 ec fe ff ff       	jmp    21f342 <readStringRaw+0x82>
  21f456:	48 8b 4c 24 08       	mov    rcx,QWORD PTR [rsp+0x8]
        try buf.append(byte);
  21f45b:	66 89 01             	mov    WORD PTR [rcx],ax
  21f45e:	48 8b 44 24 7a       	mov    rax,QWORD PTR [rsp+0x7a]
  21f463:	48 89 41 10          	mov    QWORD PTR [rcx+0x10],rax
  21f467:	c5 f8 10 44 24 6c    	vmovups xmm0,XMMWORD PTR [rsp+0x6c]
  21f46d:	c5 f8 11 41 02       	vmovups XMMWORD PTR [rcx+0x2],xmm0
  21f472:	e9 cb fe ff ff       	jmp    21f342 <readStringRaw+0x82>
  21f477:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  21f47e:	00 00 

000000000021f480 <Allocator_alignedRealloc.69>:
    pub fn alignedRealloc(self: *Allocator, comptime T: type, comptime alignment: u29, old_mem: []align(alignment) T, n: usize) ![]align(alignment) T {
  21f480:	41 56                	push   r14
  21f482:	53                   	push   rbx
  21f483:	48 81 ec 88 00 00 00 	sub    rsp,0x88
  21f48a:	48 89 fb             	mov    rbx,rdi
        if (old_mem.len == 0) {
  21f48d:	48 8b 42 08          	mov    rax,QWORD PTR [rdx+0x8]
  21f491:	48 85 c0             	test   rax,rax
  21f494:	74 62                	je     21f4f8 <Allocator_alignedRealloc.69+0x78>
        if (n == 0) {
  21f496:	48 85 c9             	test   rcx,rcx
  21f499:	0f 84 a9 00 00 00    	je     21f548 <Allocator_alignedRealloc.69+0xc8>
        const old_byte_slice = @sliceToBytes(old_mem);
  21f49f:	48 8b 12             	mov    rdx,QWORD PTR [rdx]
  21f4a2:	48 c1 e0 04          	shl    rax,0x4
  21f4a6:	48 8d 04 40          	lea    rax,[rax+rax*2]
  21f4aa:	48 89 54 24 38       	mov    QWORD PTR [rsp+0x38],rdx
  21f4af:	48 89 44 24 40       	mov    QWORD PTR [rsp+0x40],rax
  21f4b4:	ba 30 00 00 00       	mov    edx,0x30
  21f4b9:	48 89 c8             	mov    rax,rcx
  21f4bc:	48 f7 e2             	mul    rdx
  21f4bf:	0f 81 d0 00 00 00    	jno    21f595 <Allocator_alignedRealloc.69+0x115>
  21f4c5:	48 8d 0d 34 10 fe ff 	lea    rcx,[rip+0xfffffffffffe1034]        # 200500 <__unnamed_52>
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  21f4cc:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  21f4d0:	0f 84 da 00 00 00    	je     21f5b0 <Allocator_alignedRealloc.69+0x130>
  21f4d6:	48 8b 05 93 8c fe ff 	mov    rax,QWORD PTR [rip+0xfffffffffffe8c93]        # 208170 <__unnamed_86+0x10>
  21f4dd:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  21f4e1:	c5 f8 10 05 77 8c fe 	vmovups xmm0,XMMWORD PTR [rip+0xfffffffffffe8c77]        # 208160 <__unnamed_86>
  21f4e8:	ff 
  21f4e9:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  21f4ed:	48 81 c4 88 00 00 00 	add    rsp,0x88
  21f4f4:	5b                   	pop    rbx
  21f4f5:	41 5e                	pop    r14
  21f4f7:	c3                   	ret    
        if (n == 0) {
  21f4f8:	48 85 c9             	test   rcx,rcx
  21f4fb:	0f 84 fc 00 00 00    	je     21f5fd <Allocator_alignedRealloc.69+0x17d>
  21f501:	ba 30 00 00 00       	mov    edx,0x30
  21f506:	48 89 c8             	mov    rax,rcx
  21f509:	48 f7 e2             	mul    rdx
  21f50c:	0f 81 0c 01 00 00    	jno    21f61e <Allocator_alignedRealloc.69+0x19e>
  21f512:	48 8d 0d e7 0f fe ff 	lea    rcx,[rip+0xfffffffffffe0fe7]        # 200500 <__unnamed_52>
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  21f519:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  21f51d:	0f 84 16 01 00 00    	je     21f639 <Allocator_alignedRealloc.69+0x1b9>
  21f523:	0f b7 05 3c 8c fe ff 	movzx  eax,WORD PTR [rip+0xfffffffffffe8c3c]        # 208166 <__unnamed_86+0x6>
  21f52a:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  21f52f:	8b 05 2d 8c fe ff    	mov    eax,DWORD PTR [rip+0xfffffffffffe8c2d]        # 208162 <__unnamed_86+0x2>
  21f535:	89 04 24             	mov    DWORD PTR [rsp],eax
  21f538:	48 89 e0             	mov    rax,rsp
  21f53b:	66 b9 01 00          	mov    cx,0x1
  21f53f:	31 f6                	xor    esi,esi
  21f541:	31 d2                	xor    edx,edx
  21f543:	e9 9d 01 00 00       	jmp    21f6e5 <Allocator_alignedRealloc.69+0x265>
        const bytes = @sliceToBytes(memory);
  21f548:	48 c1 e0 04          	shl    rax,0x4
  21f54c:	48 8d 04 40          	lea    rax,[rax+rax*2]
        if (bytes.len == 0) return;
  21f550:	48 85 c0             	test   rax,rax
  21f553:	74 1e                	je     21f573 <Allocator_alignedRealloc.69+0xf3>
        const bytes = @sliceToBytes(memory);
  21f555:	48 8b 0a             	mov    rcx,QWORD PTR [rdx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  21f558:	48 8b 56 10          	mov    rdx,QWORD PTR [rsi+0x10]
  21f55c:	48 89 4c 24 08       	mov    QWORD PTR [rsp+0x8],rcx
  21f561:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  21f566:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  21f56b:	48 89 f7             	mov    rdi,rsi
  21f56e:	48 89 c6             	mov    rsi,rax
  21f571:	ff d2                	call   rdx
            return ([*]align(alignment) T)(undefined)[0..0];
  21f573:	48 8b 05 de 8b fe ff 	mov    rax,QWORD PTR [rip+0xfffffffffffe8bde]        # 208158 <__unnamed_87+0x10>
  21f57a:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  21f57e:	c5 f8 10 05 c2 8b fe 	vmovups xmm0,XMMWORD PTR [rip+0xfffffffffffe8bc2]        # 208148 <__unnamed_87>
  21f585:	ff 
  21f586:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  21f58a:	48 81 c4 88 00 00 00 	add    rsp,0x88
  21f591:	5b                   	pop    rbx
  21f592:	41 5e                	pop    r14
  21f594:	c3                   	ret    
  21f595:	48 8d 4c 24 08       	lea    rcx,[rsp+0x8]
  21f59a:	66 c7 44 24 08 00 00 	mov    WORD PTR [rsp+0x8],0x0
  21f5a1:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  21f5a6:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  21f5aa:	0f 85 26 ff ff ff    	jne    21f4d6 <Allocator_alignedRealloc.69+0x56>
  21f5b0:	4c 8b 71 08          	mov    r14,QWORD PTR [rcx+0x8]
  21f5b4:	48 8d 7c 24 58       	lea    rdi,[rsp+0x58]
  21f5b9:	48 8d 54 24 38       	lea    rdx,[rsp+0x38]
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  21f5be:	41 b8 02 00 00 00    	mov    r8d,0x2
  21f5c4:	4c 89 f1             	mov    rcx,r14
  21f5c7:	ff 56 08             	call   QWORD PTR [rsi+0x8]
  21f5ca:	0f b7 44 24 58       	movzx  eax,WORD PTR [rsp+0x58]
  21f5cf:	66 85 c0             	test   ax,ax
  21f5d2:	0f 84 94 00 00 00    	je     21f66c <Allocator_alignedRealloc.69+0x1ec>
  21f5d8:	66 89 03             	mov    WORD PTR [rbx],ax
  21f5db:	48 8b 84 24 80 00 00 	mov    rax,QWORD PTR [rsp+0x80]
  21f5e2:	00 
  21f5e3:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  21f5e7:	c5 f8 10 44 24 72    	vmovups xmm0,XMMWORD PTR [rsp+0x72]
  21f5ed:	c5 f8 11 43 02       	vmovups XMMWORD PTR [rbx+0x2],xmm0
  21f5f2:	48 81 c4 88 00 00 00 	add    rsp,0x88
  21f5f9:	5b                   	pop    rbx
  21f5fa:	41 5e                	pop    r14
  21f5fc:	c3                   	ret    
  21f5fd:	48 89 e0             	mov    rax,rsp
            return ([*]align(alignment) T)(undefined)[0..0];
  21f600:	0f b7 0d 47 8b fe ff 	movzx  ecx,WORD PTR [rip+0xfffffffffffe8b47]        # 20814e <__unnamed_87+0x6>
  21f607:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  21f60c:	8b 0d 38 8b fe ff    	mov    ecx,DWORD PTR [rip+0xfffffffffffe8b38]        # 20814a <__unnamed_87+0x2>
  21f612:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  21f615:	31 c9                	xor    ecx,ecx
  21f617:	31 d2                	xor    edx,edx
  21f619:	e9 c7 00 00 00       	jmp    21f6e5 <Allocator_alignedRealloc.69+0x265>
  21f61e:	48 8d 4c 24 48       	lea    rcx,[rsp+0x48]
  21f623:	66 c7 44 24 48 00 00 	mov    WORD PTR [rsp+0x48],0x0
  21f62a:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  21f62f:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  21f633:	0f 85 ea fe ff ff    	jne    21f523 <Allocator_alignedRealloc.69+0xa3>
  21f639:	4c 8b 71 08          	mov    r14,QWORD PTR [rcx+0x8]
  21f63d:	48 8d 7c 24 08       	lea    rdi,[rsp+0x8]
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  21f642:	b9 02 00 00 00       	mov    ecx,0x2
  21f647:	4c 89 f2             	mov    rdx,r14
  21f64a:	ff 16                	call   QWORD PTR [rsi]
  21f64c:	0f b7 4c 24 08       	movzx  ecx,WORD PTR [rsp+0x8]
  21f651:	66 85 c9             	test   cx,cx
  21f654:	74 57                	je     21f6ad <Allocator_alignedRealloc.69+0x22d>
  21f656:	0f b7 44 24 36       	movzx  eax,WORD PTR [rsp+0x36]
  21f65b:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  21f660:	48 89 e0             	mov    rax,rsp
  21f663:	8b 54 24 32          	mov    edx,DWORD PTR [rsp+0x32]
  21f667:	89 14 24             	mov    DWORD PTR [rsp],edx
  21f66a:	eb 79                	jmp    21f6e5 <Allocator_alignedRealloc.69+0x265>
        assert(byte_slice.len == byte_count);
  21f66c:	4c 39 74 24 68       	cmp    QWORD PTR [rsp+0x68],r14
    if (!ok) {
  21f671:	0f 85 91 00 00 00    	jne    21f708 <Allocator_alignedRealloc.69+0x288>
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  21f677:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  21f67c:	48 b9 ab aa aa aa aa 	movabs rcx,0xaaaaaaaaaaaaaaab
  21f683:	aa aa aa 
  21f686:	4c 89 f2             	mov    rdx,r14
  21f689:	c4 e2 f3 f6 d1       	mulx   rdx,rcx,rcx
  21f68e:	66 c7 03 00 00       	mov    WORD PTR [rbx],0x0
  21f693:	0f b7 4c 24 2a       	movzx  ecx,WORD PTR [rsp+0x2a]
  21f698:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  21f69c:	48 c1 ea 05          	shr    rdx,0x5
  21f6a0:	8b 4c 24 26          	mov    ecx,DWORD PTR [rsp+0x26]
  21f6a4:	89 4b 02             	mov    DWORD PTR [rbx+0x2],ecx
  21f6a7:	48 89 43 08          	mov    QWORD PTR [rbx+0x8],rax
  21f6ab:	eb 4c                	jmp    21f6f9 <Allocator_alignedRealloc.69+0x279>
        assert(byte_slice.len == byte_count);
  21f6ad:	4c 39 74 24 18       	cmp    QWORD PTR [rsp+0x18],r14
  21f6b2:	75 54                	jne    21f708 <Allocator_alignedRealloc.69+0x288>
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  21f6b4:	48 8b 74 24 10       	mov    rsi,QWORD PTR [rsp+0x10]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  21f6b9:	48 b8 ab aa aa aa aa 	movabs rax,0xaaaaaaaaaaaaaaab
  21f6c0:	aa aa aa 
  21f6c3:	4c 89 f2             	mov    rdx,r14
  21f6c6:	c4 e2 fb f6 d0       	mulx   rdx,rax,rax
  21f6cb:	48 c1 ea 05          	shr    rdx,0x5
  21f6cf:	48 89 e0             	mov    rax,rsp
  21f6d2:	8b 4c 24 2c          	mov    ecx,DWORD PTR [rsp+0x2c]
  21f6d6:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  21f6d9:	0f b7 4c 24 30       	movzx  ecx,WORD PTR [rsp+0x30]
  21f6de:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  21f6e3:	31 c9                	xor    ecx,ecx
            return self.alignedAlloc(T, alignment, n);
  21f6e5:	66 89 0b             	mov    WORD PTR [rbx],cx
  21f6e8:	0f b7 48 04          	movzx  ecx,WORD PTR [rax+0x4]
  21f6ec:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  21f6f0:	8b 00                	mov    eax,DWORD PTR [rax]
  21f6f2:	89 43 02             	mov    DWORD PTR [rbx+0x2],eax
  21f6f5:	48 89 73 08          	mov    QWORD PTR [rbx+0x8],rsi
  21f6f9:	48 89 53 10          	mov    QWORD PTR [rbx+0x10],rdx
  21f6fd:	48 81 c4 88 00 00 00 	add    rsp,0x88
  21f704:	5b                   	pop    rbx
  21f705:	41 5e                	pop    r14
  21f707:	c3                   	ret    
            @panic("assertion failure");
  21f708:	e8 d3 4e ff ff       	call   2145e0 <panic>
  21f70d:	0f 1f 00             	nop    DWORD PTR [rax]

000000000021f710 <getLineNumberInfo>:
fn getLineNumberInfo(st: *ElfStackTrace, compile_unit: *const CompileUnit, target_address: usize) !LineInfo {
  21f710:	55                   	push   rbp
  21f711:	41 57                	push   r15
  21f713:	41 56                	push   r14
  21f715:	41 55                	push   r13
  21f717:	41 54                	push   r12
  21f719:	53                   	push   rbx
  21f71a:	48 81 ec 18 0b 00 00 	sub    rsp,0xb18
  21f721:	49 89 cc             	mov    r12,rcx
  21f724:	49 89 d6             	mov    r14,rdx
  21f727:	49 89 f7             	mov    r15,rsi
  21f72a:	48 89 fd             	mov    rbp,rdi
    const compile_unit_cwd = try compile_unit.die.getAttrString(st, DW.AT_comp_dir);
  21f72d:	49 8b 46 08          	mov    rax,QWORD PTR [r14+0x8]
            return self.items[0..self.len];
  21f731:	48 8b 48 20          	mov    rcx,QWORD PTR [rax+0x20]
        for (self.attrs.toSliceConst()) |*attr| {
  21f735:	48 85 c9             	test   rcx,rcx
  21f738:	74 19                	je     21f753 <getLineNumberInfo+0x43>
  21f73a:	48 8b 40 10          	mov    rax,QWORD PTR [rax+0x10]
  21f73e:	31 d2                	xor    edx,edx
            if (attr.id == id) return &attr.value;
  21f740:	48 83 38 1b          	cmp    QWORD PTR [rax],0x1b
  21f744:	74 36                	je     21f77c <getLineNumberInfo+0x6c>
        for (self.attrs.toSliceConst()) |*attr| {
  21f746:	48 83 c2 01          	add    rdx,0x1
  21f74a:	48 83 c0 28          	add    rax,0x28
  21f74e:	48 39 ca             	cmp    rdx,rcx
  21f751:	72 ed                	jb     21f740 <getLineNumberInfo+0x30>
        const form_value = self.getAttr(id) orelse return error.MissingDebugInfo;
  21f753:	48 8b 05 ce 8a fe ff 	mov    rax,QWORD PTR [rip+0xfffffffffffe8ace]        # 208228 <__unnamed_49+0x10>
  21f75a:	48 89 84 24 7e 01 00 	mov    QWORD PTR [rsp+0x17e],rax
  21f761:	00 
  21f762:	c5 f8 10 05 b0 8a fe 	vmovups xmm0,XMMWORD PTR [rip+0xfffffffffffe8ab0]        # 20821a <__unnamed_49+0x2>
  21f769:	ff 
  21f76a:	c5 f8 29 84 24 70 01 	vmovaps XMMWORD PTR [rsp+0x170],xmm0
  21f771:	00 00 
  21f773:	66 b8 22 00          	mov    ax,0x22
  21f777:	e9 c5 00 00 00       	jmp    21f841 <getLineNumberInfo+0x131>
  21f77c:	8a 48 20             	mov    cl,BYTE PTR [rax+0x20]
  21f77f:	80 f9 0a             	cmp    cl,0xa
        return switch (form_value.*) {
  21f782:	74 1e                	je     21f7a2 <getLineNumberInfo+0x92>
  21f784:	80 f9 09             	cmp    cl,0x9
  21f787:	75 69                	jne    21f7f2 <getLineNumberInfo+0xe2>
            FormValue.String => |value| value,
  21f789:	66 c7 44 24 08 00 00 	mov    WORD PTR [rsp+0x8],0x0
  21f790:	c5 f8 10 40 08       	vmovups xmm0,XMMWORD PTR [rax+0x8]
  21f795:	c5 f8 11 44 24 10    	vmovups XMMWORD PTR [rsp+0x10],xmm0
  21f79b:	48 8d 5c 24 08       	lea    rbx,[rsp+0x8]
  21f7a0:	eb 7d                	jmp    21f81f <getLineNumberInfo+0x10f>
            FormValue.StrPtr => |offset| getString(st, offset),
  21f7a2:	48 8b 70 08          	mov    rsi,QWORD PTR [rax+0x8]
    const pos = st.debug_str.offset + offset;
  21f7a6:	49 8b 47 70          	mov    rax,QWORD PTR [r15+0x70]
    if (@maxValue(@typeOf(x)) > @maxValue(T) and x > @maxValue(T)) {
  21f7aa:	48 03 70 18          	add    rsi,QWORD PTR [rax+0x18]
  21f7ae:	78 4b                	js     21f7fb <getLineNumberInfo+0xeb>
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  21f7b0:	49 63 3f             	movsxd rdi,DWORD PTR [r15]
  21f7b3:	31 db                	xor    ebx,ebx
  21f7b5:	b8 08 00 00 00       	mov    eax,0x8
  21f7ba:	31 d2                	xor    edx,edx
  21f7bc:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  21f7be:	48 89 c1             	mov    rcx,rax
  21f7c1:	48 f7 d9             	neg    rcx
  21f7c4:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  21f7ca:	48 0f 46 cb          	cmovbe rcx,rbx
  21f7ce:	66 b8 03 00          	mov    ax,0x3
                if (err > 0) {
  21f7d2:	48 83 f9 1d          	cmp    rcx,0x1d
  21f7d6:	0f 87 44 02 00 00    	ja     21fa20 <getLineNumberInfo+0x310>
  21f7dc:	48 8d 15 b5 1b fe ff 	lea    rdx,[rip+0xfffffffffffe1bb5]        # 201398 <app_mask+0x6b8>
  21f7e3:	48 63 0c 8a          	movsxd rcx,DWORD PTR [rdx+rcx*4]
  21f7e7:	48 01 d1             	add    rcx,rdx
  21f7ea:	ff e1                	jmp    rcx
  21f7ec:	66 b8 21 00          	mov    ax,0x21
  21f7f0:	eb 0d                	jmp    21f7ff <getLineNumberInfo+0xef>
  21f7f2:	48 8d 1d 37 8a fe ff 	lea    rbx,[rip+0xfffffffffffe8a37]        # 208230 <__unnamed_33>
  21f7f9:	eb 24                	jmp    21f81f <getLineNumberInfo+0x10f>
  21f7fb:	66 b8 04 00          	mov    ax,0x4
    try st.self_exe_file.seekTo(pos);
  21f7ff:	66 89 44 24 20       	mov    WORD PTR [rsp+0x20],ax
  21f804:	c5 f8 10 44 24 48    	vmovups xmm0,XMMWORD PTR [rsp+0x48]
  21f80a:	c5 f8 11 44 24 22    	vmovups XMMWORD PTR [rsp+0x22],xmm0
  21f810:	48 8b 44 24 56       	mov    rax,QWORD PTR [rsp+0x56]
  21f815:	48 89 44 24 30       	mov    QWORD PTR [rsp+0x30],rax
  21f81a:	48 8d 5c 24 20       	lea    rbx,[rsp+0x20]
        return switch (form_value.*) {
  21f81f:	0f b7 03             	movzx  eax,WORD PTR [rbx]
  21f822:	48 8b 4b 10          	mov    rcx,QWORD PTR [rbx+0x10]
  21f826:	48 89 8c 24 7e 01 00 	mov    QWORD PTR [rsp+0x17e],rcx
  21f82d:	00 
  21f82e:	c5 f8 10 43 02       	vmovups xmm0,XMMWORD PTR [rbx+0x2]
  21f833:	c5 f8 29 84 24 70 01 	vmovaps XMMWORD PTR [rsp+0x170],xmm0
  21f83a:	00 00 
    const compile_unit_cwd = try compile_unit.die.getAttrString(st, DW.AT_comp_dir);
  21f83c:	66 85 c0             	test   ax,ax
  21f83f:	74 35                	je     21f876 <getLineNumberInfo+0x166>
  21f841:	66 89 45 00          	mov    WORD PTR [rbp+0x0],ax
  21f845:	c5 fe 6f 84 24 ca 0a 	vmovdqu ymm0,YMMWORD PTR [rsp+0xaca]
  21f84c:	00 00 
  21f84e:	c5 fc 10 8c 24 d8 0a 	vmovups ymm1,YMMWORD PTR [rsp+0xad8]
  21f855:	00 00 
  21f857:	c5 fc 11 4d 10       	vmovups YMMWORD PTR [rbp+0x10],ymm1
  21f85c:	c5 fe 7f 45 02       	vmovdqu YMMWORD PTR [rbp+0x2],ymm0
  21f861:	48 81 c4 18 0b 00 00 	add    rsp,0xb18
  21f868:	5b                   	pop    rbx
  21f869:	41 5c                	pop    r12
  21f86b:	41 5d                	pop    r13
  21f86d:	41 5e                	pop    r14
  21f86f:	41 5f                	pop    r15
  21f871:	5d                   	pop    rbp
  21f872:	c5 f8 77             	vzeroupper 
  21f875:	c3                   	ret    
  21f876:	4c 89 a4 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],r12
  21f87d:	00 
  21f87e:	48 89 2c 24          	mov    QWORD PTR [rsp],rbp
  21f882:	c5 fa 6f 84 24 76 01 	vmovdqu xmm0,XMMWORD PTR [rsp+0x176]
  21f889:	00 00 
  21f88b:	c5 f9 7f 84 24 e0 01 	vmovdqa XMMWORD PTR [rsp+0x1e0],xmm0
  21f892:	00 00 
    const debug_line_end = st.debug_line.offset + st.debug_line.size;
  21f894:	49 8b 47 78          	mov    rax,QWORD PTR [r15+0x78]
  21f898:	48 8b 58 18          	mov    rbx,QWORD PTR [rax+0x18]
  21f89c:	4c 8b 60 20          	mov    r12,QWORD PTR [rax+0x20]
    var in_file_stream = io.FileInStream.init(in_file);
  21f8a0:	4c 89 7c 24 38       	mov    QWORD PTR [rsp+0x38],r15
  21f8a5:	48 8d 05 94 c3 ff ff 	lea    rax,[rip+0xffffffffffffc394]        # 21bc40 <FileInStream_readFn>
  21f8ac:	48 89 44 24 40       	mov    QWORD PTR [rsp+0x40],rax
    while (this_offset < debug_line_end) : (this_index += 1) {
  21f8b1:	4d 85 e4             	test   r12,r12
  21f8b4:	0f 84 44 01 00 00    	je     21f9fe <getLineNumberInfo+0x2ee>
  21f8ba:	49 01 dc             	add    r12,rbx
  21f8bd:	49 c7 c5 ff ff ff ff 	mov    r13,0xffffffffffffffff
  21f8c4:	4c 89 7c 24 60       	mov    QWORD PTR [rsp+0x60],r15
  21f8c9:	48 85 db             	test   rbx,rbx
  21f8cc:	0f 88 9e 01 00 00    	js     21fa70 <getLineNumberInfo+0x360>
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  21f8d2:	49 63 3f             	movsxd rdi,DWORD PTR [r15]
  21f8d5:	b8 08 00 00 00       	mov    eax,0x8
  21f8da:	31 d2                	xor    edx,edx
  21f8dc:	48 89 de             	mov    rsi,rbx
  21f8df:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  21f8e1:	48 89 c1             	mov    rcx,rax
  21f8e4:	48 f7 d9             	neg    rcx
  21f8e7:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  21f8ed:	b8 00 00 00 00       	mov    eax,0x0
  21f8f2:	48 0f 46 c8          	cmovbe rcx,rax
  21f8f6:	48 85 c9             	test   rcx,rcx
  21f8f9:	0f 85 77 01 00 00    	jne    21fa76 <getLineNumberInfo+0x366>
            try self.readNoEof(bytes[0..]);
  21f8ff:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  21f904:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  21f909:	48 c7 44 24 10 04 00 	mov    QWORD PTR [rsp+0x10],0x4
  21f910:	00 00 
            return self.readFn(self, buffer);
  21f912:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  21f917:	48 8d 6c 24 40       	lea    rbp,[rsp+0x40]
  21f91c:	48 89 ee             	mov    rsi,rbp
  21f91f:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
  21f924:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  21f928:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  21f92d:	66 85 c0             	test   ax,ax
  21f930:	0f 85 ed 01 00 00    	jne    21fb23 <getLineNumberInfo+0x413>
  21f936:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
            if (amt_read < buf.len) return error.EndOfStream;
  21f93b:	48 3b 44 24 10       	cmp    rax,QWORD PTR [rsp+0x10]
  21f940:	0f 82 e9 00 00 00    	jb     21fa2f <getLineNumberInfo+0x31f>
  21f946:	0f b6 44 24 48       	movzx  eax,BYTE PTR [rsp+0x48]
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  21f94b:	0f b6 4c 24 49       	movzx  ecx,BYTE PTR [rsp+0x49]
  21f950:	48 c1 e1 08          	shl    rcx,0x8
  21f954:	48 09 c1             	or     rcx,rax
  21f957:	0f b6 54 24 4a       	movzx  edx,BYTE PTR [rsp+0x4a]
  21f95c:	48 c1 e2 10          	shl    rdx,0x10
  21f960:	48 09 ca             	or     rdx,rcx
  21f963:	0f b6 44 24 4b       	movzx  eax,BYTE PTR [rsp+0x4b]
  21f968:	48 c1 e0 18          	shl    rax,0x18
  21f96c:	48 09 d0             	or     rax,rdx
    is_64.* = (first_32_bits == 0xffffffff);
  21f96f:	83 f8 ff             	cmp    eax,0xffffffff
    if (is_64.*) {
  21f972:	74 3f                	je     21f9b3 <getLineNumberInfo+0x2a3>
        if (first_32_bits >= 0xfffffff0) return error.InvalidDebugInfo;
  21f974:	83 f8 ef             	cmp    eax,0xffffffef
  21f977:	0f 87 a2 01 00 00    	ja     21fb1f <getLineNumberInfo+0x40f>
  21f97d:	45 31 ff             	xor    r15d,r15d
        if (unit_length == 0) return error.MissingDebugInfo;
  21f980:	48 85 c0             	test   rax,rax
  21f983:	74 79                	je     21f9fe <getLineNumberInfo+0x2ee>
        if (compile_unit.index != this_index) {
  21f985:	49 83 c5 01          	add    r13,0x1
  21f989:	4d 3b 6e 10          	cmp    r13,QWORD PTR [r14+0x10]
  21f98d:	0f 84 29 01 00 00    	je     21fabc <getLineNumberInfo+0x3ac>
        const next_offset = unit_length + (if (is_64) usize(12) else usize(4));
  21f993:	41 0f b6 cf          	movzx  ecx,r15b
  21f997:	48 8d 0c cb          	lea    rcx,[rbx+rcx*8]
            this_offset += next_offset;
  21f99b:	48 8d 1c 08          	lea    rbx,[rax+rcx*1]
  21f99f:	48 83 c3 04          	add    rbx,0x4
    while (this_offset < debug_line_end) : (this_index += 1) {
  21f9a3:	4c 39 e3             	cmp    rbx,r12
  21f9a6:	4c 8b 7c 24 60       	mov    r15,QWORD PTR [rsp+0x60]
  21f9ab:	0f 82 18 ff ff ff    	jb     21f8c9 <getLineNumberInfo+0x1b9>
  21f9b1:	eb 4b                	jmp    21f9fe <getLineNumberInfo+0x2ee>
            try self.readNoEof(bytes[0..]);
  21f9b3:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  21f9b8:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  21f9bd:	48 c7 44 24 10 08 00 	mov    QWORD PTR [rsp+0x10],0x8
  21f9c4:	00 00 
            return self.readFn(self, buffer);
  21f9c6:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  21f9cb:	48 89 ee             	mov    rsi,rbp
  21f9ce:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
  21f9d3:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  21f9d7:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  21f9dc:	66 85 c0             	test   ax,ax
  21f9df:	0f 85 3e 01 00 00    	jne    21fb23 <getLineNumberInfo+0x413>
  21f9e5:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
            if (amt_read < buf.len) return error.EndOfStream;
  21f9ea:	48 3b 44 24 10       	cmp    rax,QWORD PTR [rsp+0x10]
  21f9ef:	72 3e                	jb     21fa2f <getLineNumberInfo+0x31f>
  21f9f1:	48 8b 44 24 48       	mov    rax,QWORD PTR [rsp+0x48]
  21f9f6:	41 b7 01             	mov    r15b,0x1
        if (unit_length == 0) return error.MissingDebugInfo;
  21f9f9:	48 85 c0             	test   rax,rax
  21f9fc:	75 87                	jne    21f985 <getLineNumberInfo+0x275>
  21f9fe:	c5 fc 10 05 9a 88 fe 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffe889a]        # 2082a0 <__unnamed_88+0x10>
  21fa05:	ff 
  21fa06:	48 8b 04 24          	mov    rax,QWORD PTR [rsp]
  21fa0a:	c5 fc 11 40 10       	vmovups YMMWORD PTR [rax+0x10],ymm0
  21fa0f:	c5 fe 6f 05 79 88 fe 	vmovdqu ymm0,YMMWORD PTR [rip+0xfffffffffffe8879]        # 208290 <__unnamed_88>
  21fa16:	ff 
  21fa17:	c5 fe 7f 00          	vmovdqu YMMWORD PTR [rax],ymm0
  21fa1b:	e9 41 fe ff ff       	jmp    21f861 <getLineNumberInfo+0x151>
  21fa20:	48 83 f9 4b          	cmp    rcx,0x4b
  21fa24:	0f 85 d5 fd ff ff    	jne    21f7ff <getLineNumberInfo+0xef>
  21fa2a:	e9 bd fd ff ff       	jmp    21f7ec <getLineNumberInfo+0xdc>
  21fa2f:	66 b8 1f 00          	mov    ax,0x1f
  21fa33:	e9 eb 00 00 00       	jmp    21fb23 <getLineNumberInfo+0x413>
            var in_file_stream = io.FileInStream.init(&self.self_exe_file);
  21fa38:	4c 89 bc 24 a0 01 00 	mov    QWORD PTR [rsp+0x1a0],r15
  21fa3f:	00 
  21fa40:	48 8d 94 24 a8 01 00 	lea    rdx,[rsp+0x1a8]
  21fa47:	00 
  21fa48:	48 8d 05 f1 c1 ff ff 	lea    rax,[rip+0xffffffffffffc1f1]        # 21bc40 <FileInStream_readFn>
  21fa4f:	48 89 84 24 a8 01 00 	mov    QWORD PTR [rsp+0x1a8],rax
  21fa56:	00 
  21fa57:	49 8b b7 a0 00 00 00 	mov    rsi,QWORD PTR [r15+0xa0]
  21fa5e:	48 8d 5c 24 20       	lea    rbx,[rsp+0x20]
            return readStringRaw(self.allocator(), in_stream);
  21fa63:	48 89 df             	mov    rdi,rbx
  21fa66:	e8 55 f8 ff ff       	call   21f2c0 <readStringRaw>
  21fa6b:	e9 af fd ff ff       	jmp    21f81f <getLineNumberInfo+0x10f>
  21fa70:	66 b8 04 00          	mov    ax,0x4
  21fa74:	eb 28                	jmp    21fa9e <getLineNumberInfo+0x38e>
  21fa76:	48 8d 41 ea          	lea    rax,[rcx-0x16]
  21fa7a:	48 83 f8 35          	cmp    rax,0x35
  21fa7e:	77 10                	ja     21fa90 <getLineNumberInfo+0x380>
  21fa80:	48 ba 81 00 00 00 00 	movabs rdx,0x20000000000081
  21fa87:	00 20 00 
  21fa8a:	48 0f a3 c2          	bt     rdx,rax
  21fa8e:	72 0a                	jb     21fa9a <getLineNumberInfo+0x38a>
  21fa90:	66 b8 03 00          	mov    ax,0x3
  21fa94:	48 83 f9 06          	cmp    rcx,0x6
  21fa98:	75 04                	jne    21fa9e <getLineNumberInfo+0x38e>
  21fa9a:	66 b8 21 00          	mov    ax,0x21
  21fa9e:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
        try in_file.seekTo(this_offset);
  21faa2:	66 89 01             	mov    WORD PTR [rcx],ax
  21faa5:	c5 fe 6f 84 24 9c 0a 	vmovdqu ymm0,YMMWORD PTR [rsp+0xa9c]
  21faac:	00 00 
  21faae:	c5 fc 10 8c 24 aa 0a 	vmovups ymm1,YMMWORD PTR [rsp+0xaaa]
  21fab5:	00 00 
  21fab7:	e9 80 00 00 00       	jmp    21fb3c <getLineNumberInfo+0x42c>
        const version = try in_stream.readInt(st.elf.endian, u16);
  21fabc:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
  21fac1:	8a 58 12             	mov    bl,BYTE PTR [rax+0x12]
            try self.readNoEof(bytes[0..]);
  21fac4:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  21fac9:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  21face:	48 c7 44 24 10 02 00 	mov    QWORD PTR [rsp+0x10],0x2
  21fad5:	00 00 
  21fad7:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  21fadc:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
            return self.readFn(self, buffer);
  21fae1:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  21fae6:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  21faea:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  21faef:	66 85 c0             	test   ax,ax
  21faf2:	75 10                	jne    21fb04 <getLineNumberInfo+0x3f4>
  21faf4:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  21faf9:	66 b8 1f 00          	mov    ax,0x1f
            if (amt_read < buf.len) return error.EndOfStream;
  21fafd:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  21fb02:	73 47                	jae    21fb4b <getLineNumberInfo+0x43b>
  21fb04:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
  21fb08:	66 89 01             	mov    WORD PTR [rcx],ax
  21fb0b:	c5 fe 6f 84 24 40 0a 	vmovdqu ymm0,YMMWORD PTR [rsp+0xa40]
  21fb12:	00 00 
  21fb14:	c5 fc 10 8c 24 4e 0a 	vmovups ymm1,YMMWORD PTR [rsp+0xa4e]
  21fb1b:	00 00 
  21fb1d:	eb 1d                	jmp    21fb3c <getLineNumberInfo+0x42c>
  21fb1f:	66 b8 23 00          	mov    ax,0x23
  21fb23:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
        const unit_length = try readInitialLength(@typeOf(in_stream.readFn).ReturnType.ErrorSet, in_stream, &is_64);
  21fb27:	66 89 01             	mov    WORD PTR [rcx],ax
  21fb2a:	c5 fe 6f 84 24 6e 0a 	vmovdqu ymm0,YMMWORD PTR [rsp+0xa6e]
  21fb31:	00 00 
  21fb33:	c5 fc 10 8c 24 7c 0a 	vmovups ymm1,YMMWORD PTR [rsp+0xa7c]
  21fb3a:	00 00 
  21fb3c:	c5 fc 11 49 10       	vmovups YMMWORD PTR [rcx+0x10],ymm1
  21fb41:	c5 fe 7f 41 02       	vmovdqu YMMWORD PTR [rcx+0x2],ymm0
  21fb46:	e9 16 fd ff ff       	jmp    21f861 <getLineNumberInfo+0x151>
  21fb4b:	0f b6 44 24 48       	movzx  eax,BYTE PTR [rsp+0x48]
  21fb50:	0f b6 4c 24 49       	movzx  ecx,BYTE PTR [rsp+0x49]
  21fb55:	89 ca                	mov    edx,ecx
  21fb57:	c1 e2 08             	shl    edx,0x8
  21fb5a:	09 c2                	or     edx,eax
                result = (result << 8) | b;
  21fb5c:	c1 e0 08             	shl    eax,0x8
  21fb5f:	09 c8                	or     eax,ecx
    switch (endian) {
  21fb61:	f6 c3 01             	test   bl,0x1
  21fb64:	66 0f 45 c2          	cmovne ax,dx
        if (version != 2 and version != 4) return error.InvalidDebugInfo;
  21fb68:	44 0f b7 e0          	movzx  r12d,ax
  21fb6c:	41 83 fc 02          	cmp    r12d,0x2
  21fb70:	48 8b 2c 24          	mov    rbp,QWORD PTR [rsp]
  21fb74:	74 0a                	je     21fb80 <getLineNumberInfo+0x470>
  21fb76:	41 83 fc 04          	cmp    r12d,0x4
  21fb7a:	0f 85 ac 00 00 00    	jne    21fc2c <getLineNumberInfo+0x51c>
  21fb80:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
  21fb85:	8a 58 12             	mov    bl,BYTE PTR [rax+0x12]
        const prologue_length = if (is_64) try in_stream.readInt(st.elf.endian, u64) else try in_stream.readInt(st.elf.endian, u32);
  21fb88:	45 84 ff             	test   r15b,r15b
  21fb8b:	74 44                	je     21fbd1 <getLineNumberInfo+0x4c1>
  21fb8d:	0f b6 d3             	movzx  edx,bl
  21fb90:	48 8d bc 24 90 01 00 	lea    rdi,[rsp+0x190]
  21fb97:	00 
  21fb98:	48 8d 5c 24 40       	lea    rbx,[rsp+0x40]
  21fb9d:	48 89 de             	mov    rsi,rbx
  21fba0:	e8 3b be ff ff       	call   21b9e0 <InStream(ReadError)_readInt.45>
  21fba5:	0f b7 84 24 90 01 00 	movzx  eax,WORD PTR [rsp+0x190]
  21fbac:	00 
  21fbad:	66 85 c0             	test   ax,ax
  21fbb0:	0f 84 95 00 00 00    	je     21fc4b <getLineNumberInfo+0x53b>
  21fbb6:	66 89 45 00          	mov    WORD PTR [rbp+0x0],ax
  21fbba:	c5 fe 6f 84 24 12 0a 	vmovdqu ymm0,YMMWORD PTR [rsp+0xa12]
  21fbc1:	00 00 
  21fbc3:	c5 fc 10 8c 24 20 0a 	vmovups ymm1,YMMWORD PTR [rsp+0xa20]
  21fbca:	00 00 
  21fbcc:	e9 86 fc ff ff       	jmp    21f857 <getLineNumberInfo+0x147>
            try self.readNoEof(bytes[0..]);
  21fbd1:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  21fbd6:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  21fbdb:	48 c7 44 24 10 04 00 	mov    QWORD PTR [rsp+0x10],0x4
  21fbe2:	00 00 
  21fbe4:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  21fbe9:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
            return self.readFn(self, buffer);
  21fbee:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  21fbf3:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  21fbf7:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  21fbfc:	66 85 c0             	test   ax,ax
  21fbff:	75 10                	jne    21fc11 <getLineNumberInfo+0x501>
  21fc01:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  21fc06:	66 b8 1f 00          	mov    ax,0x1f
            if (amt_read < buf.len) return error.EndOfStream;
  21fc0a:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  21fc0f:	73 44                	jae    21fc55 <getLineNumberInfo+0x545>
  21fc11:	66 89 45 00          	mov    WORD PTR [rbp+0x0],ax
  21fc15:	c5 fe 6f 84 24 e4 09 	vmovdqu ymm0,YMMWORD PTR [rsp+0x9e4]
  21fc1c:	00 00 
  21fc1e:	c5 fc 10 8c 24 f2 09 	vmovups ymm1,YMMWORD PTR [rsp+0x9f2]
  21fc25:	00 00 
  21fc27:	e9 2b fc ff ff       	jmp    21f857 <getLineNumberInfo+0x147>
        if (version != 2 and version != 4) return error.InvalidDebugInfo;
  21fc2c:	c5 fc 10 05 3c 86 fe 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffe863c]        # 208270 <__unnamed_89+0x10>
  21fc33:	ff 
  21fc34:	c5 fc 11 45 10       	vmovups YMMWORD PTR [rbp+0x10],ymm0
  21fc39:	c5 fe 6f 05 1f 86 fe 	vmovdqu ymm0,YMMWORD PTR [rip+0xfffffffffffe861f]        # 208260 <__unnamed_89>
  21fc40:	ff 
  21fc41:	c5 fe 7f 45 00       	vmovdqu YMMWORD PTR [rbp+0x0],ymm0
  21fc46:	e9 16 fc ff ff       	jmp    21f861 <getLineNumberInfo+0x151>
        const prologue_length = if (is_64) try in_stream.readInt(st.elf.endian, u64) else try in_stream.readInt(st.elf.endian, u32);
  21fc4b:	4c 8b b4 24 98 01 00 	mov    r14,QWORD PTR [rsp+0x198]
  21fc52:	00 
  21fc53:	eb 4f                	jmp    21fca4 <getLineNumberInfo+0x594>
  21fc55:	0f b6 44 24 48       	movzx  eax,BYTE PTR [rsp+0x48]
  21fc5a:	0f b6 4c 24 49       	movzx  ecx,BYTE PTR [rsp+0x49]
  21fc5f:	f6 c3 01             	test   bl,0x1
  21fc62:	74 1b                	je     21fc7f <getLineNumberInfo+0x56f>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  21fc64:	c1 e1 08             	shl    ecx,0x8
  21fc67:	09 c1                	or     ecx,eax
  21fc69:	0f b6 54 24 4a       	movzx  edx,BYTE PTR [rsp+0x4a]
  21fc6e:	c1 e2 10             	shl    edx,0x10
  21fc71:	09 ca                	or     edx,ecx
  21fc73:	0f b6 44 24 4b       	movzx  eax,BYTE PTR [rsp+0x4b]
  21fc78:	c1 e0 18             	shl    eax,0x18
  21fc7b:	09 d0                	or     eax,edx
  21fc7d:	eb 19                	jmp    21fc98 <getLineNumberInfo+0x588>
                result = (result << 8) | b;
  21fc7f:	c1 e0 08             	shl    eax,0x8
  21fc82:	09 c8                	or     eax,ecx
  21fc84:	c1 e0 08             	shl    eax,0x8
  21fc87:	0f b6 4c 24 4a       	movzx  ecx,BYTE PTR [rsp+0x4a]
  21fc8c:	09 c1                	or     ecx,eax
  21fc8e:	c1 e1 08             	shl    ecx,0x8
  21fc91:	0f b6 44 24 4b       	movzx  eax,BYTE PTR [rsp+0x4b]
  21fc96:	09 c8                	or     eax,ecx
  21fc98:	41 89 c6             	mov    r14d,eax
  21fc9b:	48 8b 2c 24          	mov    rbp,QWORD PTR [rsp]
  21fc9f:	48 8d 5c 24 40       	lea    rbx,[rsp+0x40]
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  21fca4:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
  21fca9:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  21fcac:	45 31 c0             	xor    r8d,r8d
  21fcaf:	b8 08 00 00 00       	mov    eax,0x8
  21fcb4:	be 00 00 00 00       	mov    esi,0x0
  21fcb9:	ba 01 00 00 00       	mov    edx,0x1
  21fcbe:	0f 05                	syscall 
  21fcc0:	49 89 c5             	mov    r13,rax
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  21fcc3:	4c 89 e9             	mov    rcx,r13
  21fcc6:	48 f7 d9             	neg    rcx
  21fcc9:	49 81 fd 00 f0 ff ff 	cmp    r13,0xfffffffffffff000
  21fcd0:	49 0f 46 c8          	cmovbe rcx,r8
  21fcd4:	66 b8 21 00          	mov    ax,0x21
                if (err > 0) {
  21fcd8:	48 83 f9 1d          	cmp    rcx,0x1d
  21fcdc:	77 6c                	ja     21fd4a <getLineNumberInfo+0x63a>
  21fcde:	48 8d 15 2b 17 fe ff 	lea    rdx,[rip+0xfffffffffffe172b]        # 201410 <app_mask+0x730>
  21fce5:	48 63 0c 8a          	movsxd rcx,DWORD PTR [rdx+rcx*4]
  21fce9:	48 01 d1             	add    rcx,rdx
  21fcec:	ff e1                	jmp    rcx
            try self.readNoEof(result[0..]);
  21fcee:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  21fcf3:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  21fcf8:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  21fcff:	00 00 
  21fd01:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  21fd06:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
            return self.readFn(self, buffer);
  21fd0b:	48 89 de             	mov    rsi,rbx
  21fd0e:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  21fd12:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  21fd17:	66 85 c0             	test   ax,ax
  21fd1a:	75 10                	jne    21fd2c <getLineNumberInfo+0x61c>
  21fd1c:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  21fd21:	66 b8 1f 00          	mov    ax,0x1f
            if (amt_read < buf.len) return error.EndOfStream;
  21fd25:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  21fd2a:	73 43                	jae    21fd6f <getLineNumberInfo+0x65f>
  21fd2c:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
        const minimum_instruction_length = try in_stream.readByte();
  21fd30:	66 89 01             	mov    WORD PTR [rcx],ax
  21fd33:	c5 fe 6f 84 24 88 09 	vmovdqu ymm0,YMMWORD PTR [rsp+0x988]
  21fd3a:	00 00 
  21fd3c:	c5 fc 10 8c 24 96 09 	vmovups ymm1,YMMWORD PTR [rsp+0x996]
  21fd43:	00 00 
  21fd45:	e9 f2 fd ff ff       	jmp    21fb3c <getLineNumberInfo+0x42c>
  21fd4a:	48 83 f9 4b          	cmp    rcx,0x4b
  21fd4e:	74 04                	je     21fd54 <getLineNumberInfo+0x644>
  21fd50:	66 b8 03 00          	mov    ax,0x3
        const prog_start_offset = (try in_file.getPos()) + prologue_length;
  21fd54:	66 89 45 00          	mov    WORD PTR [rbp+0x0],ax
  21fd58:	c5 fe 6f 84 24 b6 09 	vmovdqu ymm0,YMMWORD PTR [rsp+0x9b6]
  21fd5f:	00 00 
  21fd61:	c5 fc 10 8c 24 c4 09 	vmovups ymm1,YMMWORD PTR [rsp+0x9c4]
  21fd68:	00 00 
  21fd6a:	e9 e8 fa ff ff       	jmp    21f857 <getLineNumberInfo+0x147>
            return result[0];
  21fd6f:	44 0f b6 7c 24 48    	movzx  r15d,BYTE PTR [rsp+0x48]
  21fd75:	4d 85 ff             	test   r15,r15
        if (minimum_instruction_length == 0) return error.InvalidDebugInfo;
  21fd78:	0f 84 59 15 00 00    	je     2212d7 <getLineNumberInfo+0x1bc7>
        if (version >= 4) {
  21fd7e:	41 83 fc 04          	cmp    r12d,0x4
  21fd82:	72 5e                	jb     21fde2 <getLineNumberInfo+0x6d2>
            try self.readNoEof(result[0..]);
  21fd84:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  21fd89:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  21fd8e:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  21fd95:	00 00 
  21fd97:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  21fd9c:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
            return self.readFn(self, buffer);
  21fda1:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  21fda6:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  21fdaa:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  21fdaf:	66 85 c0             	test   ax,ax
  21fdb2:	75 10                	jne    21fdc4 <getLineNumberInfo+0x6b4>
  21fdb4:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  21fdb9:	66 b8 1f 00          	mov    ax,0x1f
            if (amt_read < buf.len) return error.EndOfStream;
  21fdbd:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  21fdc2:	73 1e                	jae    21fde2 <getLineNumberInfo+0x6d2>
  21fdc4:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
            _ = try in_stream.readByte();
  21fdc8:	66 89 01             	mov    WORD PTR [rcx],ax
  21fdcb:	c5 fe 6f 84 24 5a 09 	vmovdqu ymm0,YMMWORD PTR [rsp+0x95a]
  21fdd2:	00 00 
  21fdd4:	c5 fc 10 8c 24 68 09 	vmovups ymm1,YMMWORD PTR [rsp+0x968]
  21fddb:	00 00 
  21fddd:	e9 5a fd ff ff       	jmp    21fb3c <getLineNumberInfo+0x42c>
            try self.readNoEof(result[0..]);
  21fde2:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  21fde7:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  21fdec:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  21fdf3:	00 00 
  21fdf5:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  21fdfa:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
            return self.readFn(self, buffer);
  21fdff:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  21fe04:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  21fe08:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  21fe0d:	66 85 c0             	test   ax,ax
  21fe10:	75 10                	jne    21fe22 <getLineNumberInfo+0x712>
  21fe12:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  21fe17:	66 b8 1f 00          	mov    ax,0x1f
            if (amt_read < buf.len) return error.EndOfStream;
  21fe1b:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  21fe20:	73 1e                	jae    21fe40 <getLineNumberInfo+0x730>
  21fe22:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
        const default_is_stmt = (try in_stream.readByte()) != 0;
  21fe26:	66 89 01             	mov    WORD PTR [rcx],ax
  21fe29:	c5 fe 6f 84 24 2c 09 	vmovdqu ymm0,YMMWORD PTR [rsp+0x92c]
  21fe30:	00 00 
  21fe32:	c5 fc 10 8c 24 3a 09 	vmovups ymm1,YMMWORD PTR [rsp+0x93a]
  21fe39:	00 00 
  21fe3b:	e9 fc fc ff ff       	jmp    21fb3c <getLineNumberInfo+0x42c>
            return result[0];
  21fe40:	40 8a 6c 24 48       	mov    bpl,BYTE PTR [rsp+0x48]
            try self.readNoEof(result[0..]);
  21fe45:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  21fe4a:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  21fe4f:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  21fe56:	00 00 
  21fe58:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  21fe5d:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
            return self.readFn(self, buffer);
  21fe62:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  21fe67:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  21fe6b:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  21fe70:	66 85 c0             	test   ax,ax
  21fe73:	75 10                	jne    21fe85 <getLineNumberInfo+0x775>
  21fe75:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  21fe7a:	66 b8 1f 00          	mov    ax,0x1f
            if (amt_read < buf.len) return error.EndOfStream;
  21fe7e:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  21fe83:	73 1e                	jae    21fea3 <getLineNumberInfo+0x793>
  21fe85:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
        const line_base = try in_stream.readByteSigned();
  21fe89:	66 89 01             	mov    WORD PTR [rcx],ax
  21fe8c:	c5 fe 6f 84 24 fe 08 	vmovdqu ymm0,YMMWORD PTR [rsp+0x8fe]
  21fe93:	00 00 
  21fe95:	c5 fc 10 8c 24 0c 09 	vmovups ymm1,YMMWORD PTR [rsp+0x90c]
  21fe9c:	00 00 
  21fe9e:	e9 99 fc ff ff       	jmp    21fb3c <getLineNumberInfo+0x42c>
            return result[0];
  21fea3:	48 0f be 44 24 48    	movsx  rax,BYTE PTR [rsp+0x48]
            try self.readNoEof(result[0..]);
  21fea9:	48 89 84 24 68 01 00 	mov    QWORD PTR [rsp+0x168],rax
  21feb0:	00 
  21feb1:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  21feb6:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  21febb:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  21fec2:	00 00 
  21fec4:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  21fec9:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
            return self.readFn(self, buffer);
  21fece:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  21fed3:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  21fed7:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  21fedc:	66 85 c0             	test   ax,ax
  21fedf:	75 10                	jne    21fef1 <getLineNumberInfo+0x7e1>
  21fee1:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  21fee6:	66 b8 1f 00          	mov    ax,0x1f
            if (amt_read < buf.len) return error.EndOfStream;
  21feea:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  21feef:	73 1e                	jae    21ff0f <getLineNumberInfo+0x7ff>
  21fef1:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
        const line_range = try in_stream.readByte();
  21fef5:	66 89 01             	mov    WORD PTR [rcx],ax
  21fef8:	c5 fe 6f 84 24 d0 08 	vmovdqu ymm0,YMMWORD PTR [rsp+0x8d0]
  21feff:	00 00 
  21ff01:	c5 fc 10 8c 24 de 08 	vmovups ymm1,YMMWORD PTR [rsp+0x8de]
  21ff08:	00 00 
  21ff0a:	e9 2d fc ff ff       	jmp    21fb3c <getLineNumberInfo+0x42c>
            return result[0];
  21ff0f:	8a 44 24 48          	mov    al,BYTE PTR [rsp+0x48]
  21ff13:	88 44 24 5f          	mov    BYTE PTR [rsp+0x5f],al
        if (line_range == 0) return error.InvalidDebugInfo;
  21ff17:	84 c0                	test   al,al
  21ff19:	0f 84 b8 13 00 00    	je     2212d7 <getLineNumberInfo+0x1bc7>
            try self.readNoEof(result[0..]);
  21ff1f:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  21ff24:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  21ff29:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  21ff30:	00 00 
  21ff32:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  21ff37:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
            return self.readFn(self, buffer);
  21ff3c:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  21ff41:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  21ff45:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  21ff4a:	66 85 c0             	test   ax,ax
  21ff4d:	75 10                	jne    21ff5f <getLineNumberInfo+0x84f>
  21ff4f:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  21ff54:	66 b8 1f 00          	mov    ax,0x1f
            if (amt_read < buf.len) return error.EndOfStream;
  21ff58:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  21ff5d:	73 1e                	jae    21ff7d <getLineNumberInfo+0x86d>
  21ff5f:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
        const opcode_base = try in_stream.readByte();
  21ff63:	66 89 01             	mov    WORD PTR [rcx],ax
  21ff66:	c5 fe 6f 84 24 a2 08 	vmovdqu ymm0,YMMWORD PTR [rsp+0x8a2]
  21ff6d:	00 00 
  21ff6f:	c5 fc 10 8c 24 b0 08 	vmovups ymm1,YMMWORD PTR [rsp+0x8b0]
  21ff76:	00 00 
  21ff78:	e9 bf fb ff ff       	jmp    21fb3c <getLineNumberInfo+0x42c>
            return result[0];
  21ff7d:	8a 4c 24 48          	mov    cl,BYTE PTR [rsp+0x48]
  21ff81:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
  21ff86:	48 8b 80 a0 00 00 00 	mov    rax,QWORD PTR [rax+0xa0]
  21ff8d:	48 89 44 24 68       	mov    QWORD PTR [rsp+0x68],rax
  21ff92:	88 4c 24 5e          	mov    BYTE PTR [rsp+0x5e],cl
        const standard_opcode_lengths = try st.allocator().alloc(u8, opcode_base - 1);
  21ff96:	89 c8                	mov    eax,ecx
  21ff98:	04 ff                	add    al,0xff
        if (n == 0) {
  21ff9a:	74 48                	je     21ffe4 <getLineNumberInfo+0x8d4>
  21ff9c:	0f b6 d0             	movzx  edx,al
  21ff9f:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  21ffa4:	b9 01 00 00 00       	mov    ecx,0x1
  21ffa9:	48 8b 74 24 68       	mov    rsi,QWORD PTR [rsp+0x68]
  21ffae:	48 89 94 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rdx
  21ffb5:	00 
  21ffb6:	ff 16                	call   QWORD PTR [rsi]
  21ffb8:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  21ffbd:	66 85 c0             	test   ax,ax
  21ffc0:	0f 84 91 00 00 00    	je     220057 <getLineNumberInfo+0x947>
  21ffc6:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
  21ffca:	66 89 01             	mov    WORD PTR [rcx],ax
  21ffcd:	c5 fe 6f 84 24 74 08 	vmovdqu ymm0,YMMWORD PTR [rsp+0x874]
  21ffd4:	00 00 
  21ffd6:	c5 fc 10 8c 24 82 08 	vmovups ymm1,YMMWORD PTR [rsp+0x882]
  21ffdd:	00 00 
  21ffdf:	e9 58 fb ff ff       	jmp    21fb3c <getLineNumberInfo+0x42c>
  21ffe4:	31 c0                	xor    eax,eax
  21ffe6:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  21ffed:	00 
            return Self{
  21ffee:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  21fff2:	c5 f9 7f 84 24 b0 00 	vmovdqa XMMWORD PTR [rsp+0xb0],xmm0
  21fff9:	00 00 
  21fffb:	48 c7 84 24 c0 00 00 	mov    QWORD PTR [rsp+0xc0],0x0
  220002:	00 00 00 00 00 
  220007:	48 8b 74 24 68       	mov    rsi,QWORD PTR [rsp+0x68]
        var include_directories = ArrayList([]u8).init(st.allocator());
  22000c:	48 89 b4 24 c8 00 00 	mov    QWORD PTR [rsp+0xc8],rsi
  220013:	00 
  220014:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  220019:	48 8d 94 24 b0 00 00 	lea    rdx,[rsp+0xb0]
  220020:	00 
            self.items = try self.allocator.alignedRealloc(T, A, self.items, better_capacity);
  220021:	b9 08 00 00 00       	mov    ecx,0x8
  220026:	e8 05 1f 00 00       	call   221f30 <Allocator_alignedRealloc.91>
  22002b:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  220030:	66 85 c0             	test   ax,ax
  220033:	0f 84 bd 00 00 00    	je     2200f6 <getLineNumberInfo+0x9e6>
  220039:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
        try include_directories.append(compile_unit_cwd);
  22003d:	66 89 01             	mov    WORD PTR [rcx],ax
  220040:	c5 fe 6f 84 24 18 08 	vmovdqu ymm0,YMMWORD PTR [rsp+0x818]
  220047:	00 00 
  220049:	c5 fc 10 8c 24 26 08 	vmovups ymm1,YMMWORD PTR [rsp+0x826]
  220050:	00 00 
  220052:	e9 e5 fa ff ff       	jmp    21fb3c <getLineNumberInfo+0x42c>
        assert(byte_slice.len == byte_count);
  220057:	48 8b 84 24 98 00 00 	mov    rax,QWORD PTR [rsp+0x98]
  22005e:	00 
  22005f:	48 39 44 24 30       	cmp    QWORD PTR [rsp+0x30],rax
    if (!ok) {
  220064:	0f 85 65 16 00 00    	jne    2216cf <getLineNumberInfo+0x1fbf>
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  22006a:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
  22006f:	48 89 84 24 d8 00 00 	mov    QWORD PTR [rsp+0xd8],rax
  220076:	00 
  220077:	45 31 e4             	xor    r12d,r12d
  22007a:	48 8d 5c 24 20       	lea    rbx,[rsp+0x20]
            try self.readNoEof(result[0..]);
  22007f:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  220084:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  220089:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  220090:	00 00 
            return self.readFn(self, buffer);
  220092:	48 89 df             	mov    rdi,rbx
  220095:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  22009a:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
  22009f:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  2200a3:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  2200a8:	66 85 c0             	test   ax,ax
  2200ab:	0f 85 cf 00 00 00    	jne    220180 <getLineNumberInfo+0xa70>
  2200b1:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
            if (amt_read < buf.len) return error.EndOfStream;
  2200b6:	48 3b 44 24 10       	cmp    rax,QWORD PTR [rsp+0x10]
  2200bb:	0f 82 bb 00 00 00    	jb     22017c <getLineNumberInfo+0xa6c>
            return result[0];
  2200c1:	0f b6 44 24 48       	movzx  eax,BYTE PTR [rsp+0x48]
                standard_opcode_lengths[i] = try in_stream.readByte();
  2200c6:	48 8b 8c 24 d8 00 00 	mov    rcx,QWORD PTR [rsp+0xd8]
  2200cd:	00 
  2200ce:	42 88 04 21          	mov    BYTE PTR [rcx+r12*1],al
            while (i < opcode_base - 1) : (i += 1) {
  2200d2:	49 83 c4 01          	add    r12,0x1
  2200d6:	4c 3b a4 24 98 00 00 	cmp    r12,QWORD PTR [rsp+0x98]
  2200dd:	00 
  2200de:	72 9f                	jb     22007f <getLineNumberInfo+0x96f>
  2200e0:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
  2200e5:	48 8b 80 a0 00 00 00 	mov    rax,QWORD PTR [rax+0xa0]
  2200ec:	48 89 44 24 68       	mov    QWORD PTR [rsp+0x68],rax
  2200f1:	e9 f8 fe ff ff       	jmp    21ffee <getLineNumberInfo+0x8de>
  2200f6:	c5 f8 10 44 24 28    	vmovups xmm0,XMMWORD PTR [rsp+0x28]
  2200fc:	c5 f8 29 84 24 b0 00 	vmovaps XMMWORD PTR [rsp+0xb0],xmm0
  220103:	00 00 
            const result = &self.items[self.len];
  220105:	4c 8b a4 24 b0 00 00 	mov    r12,QWORD PTR [rsp+0xb0]
  22010c:	00 
            self.len = new_length;
  22010d:	48 c7 84 24 c0 00 00 	mov    QWORD PTR [rsp+0xc0],0x1
  220114:	00 01 00 00 00 
            new_item_ptr.* = item;
  220119:	c5 f9 6f 84 24 e0 01 	vmovdqa xmm0,XMMWORD PTR [rsp+0x1e0]
  220120:	00 00 
  220122:	c4 c1 7a 7f 04 24    	vmovdqu XMMWORD PTR [r12],xmm0
  220128:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
            var in_file_stream = io.FileInStream.init(&self.self_exe_file);
  22012d:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  220132:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  220137:	48 8d 0d 02 bb ff ff 	lea    rcx,[rip+0xffffffffffffbb02]        # 21bc40 <FileInStream_readFn>
  22013e:	48 89 4c 24 10       	mov    QWORD PTR [rsp+0x10],rcx
  220143:	48 8b b0 a0 00 00 00 	mov    rsi,QWORD PTR [rax+0xa0]
  22014a:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
            return readStringRaw(self.allocator(), in_stream);
  22014f:	e8 6c f1 ff ff       	call   21f2c0 <readStringRaw>
  220154:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const dir = try st.readString();
  220159:	66 85 c0             	test   ax,ax
  22015c:	74 40                	je     22019e <getLineNumberInfo+0xa8e>
  22015e:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
  220162:	66 89 01             	mov    WORD PTR [rcx],ax
  220165:	c5 fe 6f 84 24 ea 07 	vmovdqu ymm0,YMMWORD PTR [rsp+0x7ea]
  22016c:	00 00 
  22016e:	c5 fc 10 8c 24 f8 07 	vmovups ymm1,YMMWORD PTR [rsp+0x7f8]
  220175:	00 00 
  220177:	e9 c0 f9 ff ff       	jmp    21fb3c <getLineNumberInfo+0x42c>
  22017c:	66 b8 1f 00          	mov    ax,0x1f
  220180:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                standard_opcode_lengths[i] = try in_stream.readByte();
  220184:	66 89 01             	mov    WORD PTR [rcx],ax
  220187:	c5 fe 6f 84 24 46 08 	vmovdqu ymm0,YMMWORD PTR [rsp+0x846]
  22018e:	00 00 
  220190:	c5 fc 10 8c 24 54 08 	vmovups ymm1,YMMWORD PTR [rsp+0x854]
  220197:	00 00 
  220199:	e9 9e f9 ff ff       	jmp    21fb3c <getLineNumberInfo+0x42c>
  22019e:	4d 01 f5             	add    r13,r14
  2201a1:	c5 fa 6f 44 24 28    	vmovdqu xmm0,XMMWORD PTR [rsp+0x28]
  2201a7:	c5 f9 7f 84 24 50 01 	vmovdqa XMMWORD PTR [rsp+0x150],xmm0
  2201ae:	00 00 
  2201b0:	41 be 01 00 00 00    	mov    r14d,0x1
            if (dir.len == 0) break;
  2201b6:	c5 f9 6f 84 24 50 01 	vmovdqa xmm0,XMMWORD PTR [rsp+0x150]
  2201bd:	00 00 
  2201bf:	c4 e3 f9 16 c0 01    	vpextrq rax,xmm0,0x1
  2201c5:	48 85 c0             	test   rax,rax
  2201c8:	0f 84 ce 00 00 00    	je     22029c <getLineNumberInfo+0xb8c>
            var better_capacity = self.items.len;
  2201ce:	48 8b 8c 24 b8 00 00 	mov    rcx,QWORD PTR [rsp+0xb8]
  2201d5:	00 
            if (better_capacity >= new_capacity) return;
  2201d6:	4c 39 f1             	cmp    rcx,r14
  2201d9:	77 51                	ja     22022c <getLineNumberInfo+0xb1c>
                better_capacity += better_capacity / 2 + 8;
  2201db:	48 89 c8             	mov    rax,rcx
  2201de:	48 d1 e8             	shr    rax,1
  2201e1:	48 01 c1             	add    rcx,rax
  2201e4:	48 83 c1 08          	add    rcx,0x8
                if (better_capacity >= new_capacity) break;
  2201e8:	4c 39 f1             	cmp    rcx,r14
  2201eb:	76 ee                	jbe    2201db <getLineNumberInfo+0xacb>
            self.items = try self.allocator.alignedRealloc(T, A, self.items, better_capacity);
  2201ed:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  2201f2:	48 8b 74 24 68       	mov    rsi,QWORD PTR [rsp+0x68]
  2201f7:	48 8d 94 24 b0 00 00 	lea    rdx,[rsp+0xb0]
  2201fe:	00 
  2201ff:	e8 2c 1d 00 00       	call   221f30 <Allocator_alignedRealloc.91>
  220204:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  220209:	66 85 c0             	test   ax,ax
  22020c:	0f 85 94 01 00 00    	jne    2203a6 <getLineNumberInfo+0xc96>
  220212:	48 8d 44 24 28       	lea    rax,[rsp+0x28]
  220217:	c5 fa 6f 00          	vmovdqu xmm0,XMMWORD PTR [rax]
  22021b:	c5 f9 7f 84 24 b0 00 	vmovdqa XMMWORD PTR [rsp+0xb0],xmm0
  220222:	00 00 
            const result = &self.items[self.len];
  220224:	4c 8b a4 24 b0 00 00 	mov    r12,QWORD PTR [rsp+0xb0]
  22022b:	00 
  22022c:	49 8d 5e 01          	lea    rbx,[r14+0x1]
  220230:	49 c1 e6 04          	shl    r14,0x4
            self.len = new_length;
  220234:	48 89 9c 24 c0 00 00 	mov    QWORD PTR [rsp+0xc0],rbx
  22023b:	00 
            new_item_ptr.* = item;
  22023c:	c5 f8 28 84 24 50 01 	vmovaps xmm0,XMMWORD PTR [rsp+0x150]
  220243:	00 00 
  220245:	c4 81 78 11 04 34    	vmovups XMMWORD PTR [r12+r14*1],xmm0
  22024b:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
            var in_file_stream = io.FileInStream.init(&self.self_exe_file);
  220250:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  220255:	48 8d 0d e4 b9 ff ff 	lea    rcx,[rip+0xffffffffffffb9e4]        # 21bc40 <FileInStream_readFn>
  22025c:	48 89 4c 24 10       	mov    QWORD PTR [rsp+0x10],rcx
  220261:	48 8b b0 a0 00 00 00 	mov    rsi,QWORD PTR [rax+0xa0]
            return readStringRaw(self.allocator(), in_stream);
  220268:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  22026d:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  220272:	e8 49 f0 ff ff       	call   21f2c0 <readStringRaw>
  220277:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  22027c:	c5 fa 6f 44 24 28    	vmovdqu xmm0,XMMWORD PTR [rsp+0x28]
  220282:	c5 f9 7f 84 24 50 01 	vmovdqa XMMWORD PTR [rsp+0x150],xmm0
  220289:	00 00 
  22028b:	49 89 de             	mov    r14,rbx
            const dir = try st.readString();
  22028e:	66 85 c0             	test   ax,ax
  220291:	0f 84 1f ff ff ff    	je     2201b6 <getLineNumberInfo+0xaa6>
  220297:	e9 c2 fe ff ff       	jmp    22015e <getLineNumberInfo+0xa4e>
  22029c:	48 8b 54 24 60       	mov    rdx,QWORD PTR [rsp+0x60]
  2202a1:	48 8b b2 a0 00 00 00 	mov    rsi,QWORD PTR [rdx+0xa0]
            return Self{
  2202a8:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  2202ac:	c5 f9 7f 44 24 70    	vmovdqa XMMWORD PTR [rsp+0x70],xmm0
  2202b2:	48 c7 84 24 80 00 00 	mov    QWORD PTR [rsp+0x80],0x0
  2202b9:	00 00 00 00 00 
        var file_entries = ArrayList(FileEntry).init(st.allocator());
  2202be:	48 89 b4 24 88 00 00 	mov    QWORD PTR [rsp+0x88],rsi
  2202c5:	00 
        var prog = LineNumberProgram.init(default_is_stmt, include_directories.toSliceConst(), &file_entries, target_address);
  2202c6:	c5 fc 28 05 f2 fe fd 	vmovaps ymm0,YMMWORD PTR [rip+0xfffffffffffdfef2]        # 2001c0 <__unnamed_103-0x20>
  2202cd:	ff 
  2202ce:	c5 fc 11 84 24 e0 00 	vmovups YMMWORD PTR [rsp+0xe0],ymm0
  2202d5:	00 00 
        const default_is_stmt = (try in_stream.readByte()) != 0;
  2202d7:	40 84 ed             	test   bpl,bpl
        var prog = LineNumberProgram.init(default_is_stmt, include_directories.toSliceConst(), &file_entries, target_address);
  2202da:	0f 95 84 24 00 01 00 	setne  BYTE PTR [rsp+0x100]
  2202e1:	00 
  2202e2:	66 c7 84 24 01 01 00 	mov    WORD PTR [rsp+0x101],0x0
  2202e9:	00 00 00 
  2202ec:	8b 84 24 d3 00 00 00 	mov    eax,DWORD PTR [rsp+0xd3]
  2202f3:	89 84 24 03 01 00 00 	mov    DWORD PTR [rsp+0x103],eax
            return self.items[0..self.len];
  2202fa:	48 8b 84 24 b0 00 00 	mov    rax,QWORD PTR [rsp+0xb0]
  220301:	00 
  220302:	8a 8c 24 d7 00 00 00 	mov    cl,BYTE PTR [rsp+0xd7]
  220309:	88 8c 24 07 01 00 00 	mov    BYTE PTR [rsp+0x107],cl
  220310:	48 8b 8c 24 a0 00 00 	mov    rcx,QWORD PTR [rsp+0xa0]
  220317:	00 
  220318:	48 89 8c 24 08 01 00 	mov    QWORD PTR [rsp+0x108],rcx
  22031f:	00 
  220320:	48 89 84 24 10 01 00 	mov    QWORD PTR [rsp+0x110],rax
  220327:	00 
  220328:	4c 89 b4 24 18 01 00 	mov    QWORD PTR [rsp+0x118],r14
  22032f:	00 
  220330:	48 8d 44 24 70       	lea    rax,[rsp+0x70]
  220335:	48 89 84 24 20 01 00 	mov    QWORD PTR [rsp+0x120],rax
  22033c:	00 
  22033d:	48 c7 84 24 28 01 00 	mov    QWORD PTR [rsp+0x128],0x0
  220344:	00 00 00 00 00 
  220349:	c5 fe 6f 84 24 f8 0a 	vmovdqu ymm0,YMMWORD PTR [rsp+0xaf8]
  220350:	00 00 
  220352:	c5 fe 7f 84 24 30 01 	vmovdqu YMMWORD PTR [rsp+0x130],ymm0
  220359:	00 00 
            var in_file_stream = io.FileInStream.init(&self.self_exe_file);
  22035b:	48 89 54 24 08       	mov    QWORD PTR [rsp+0x8],rdx
  220360:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  220365:	48 8d 05 d4 b8 ff ff 	lea    rax,[rip+0xffffffffffffb8d4]        # 21bc40 <FileInStream_readFn>
  22036c:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  220371:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
            return readStringRaw(self.allocator(), in_stream);
  220376:	c5 f8 77             	vzeroupper 
  220379:	e8 42 ef ff ff       	call   21f2c0 <readStringRaw>
  22037e:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const file_name = try st.readString();
  220383:	66 85 c0             	test   ax,ax
  220386:	74 3c                	je     2203c4 <getLineNumberInfo+0xcb4>
  220388:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
  22038c:	66 89 01             	mov    WORD PTR [rcx],ax
  22038f:	c5 fe 6f 84 24 8e 07 	vmovdqu ymm0,YMMWORD PTR [rsp+0x78e]
  220396:	00 00 
  220398:	c5 fc 10 8c 24 9c 07 	vmovups ymm1,YMMWORD PTR [rsp+0x79c]
  22039f:	00 00 
  2203a1:	e9 96 f7 ff ff       	jmp    21fb3c <getLineNumberInfo+0x42c>
  2203a6:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
            try include_directories.append(dir);
  2203aa:	66 89 01             	mov    WORD PTR [rcx],ax
  2203ad:	c5 fc 10 84 24 bc 07 	vmovups ymm0,YMMWORD PTR [rsp+0x7bc]
  2203b4:	00 00 
  2203b6:	c5 fc 10 8c 24 ca 07 	vmovups ymm1,YMMWORD PTR [rsp+0x7ca]
  2203bd:	00 00 
  2203bf:	e9 78 f7 ff ff       	jmp    21fb3c <getLineNumberInfo+0x42c>
  2203c4:	c5 fa 6f 44 24 28    	vmovdqu xmm0,XMMWORD PTR [rsp+0x28]
  2203ca:	c5 f9 7f 84 24 a0 00 	vmovdqa XMMWORD PTR [rsp+0xa0],xmm0
  2203d1:	00 00 
            if (file_name.len == 0) break;
  2203d3:	c5 f9 6f 84 24 a0 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0xa0]
  2203da:	00 00 
  2203dc:	c4 e3 f9 16 c0 01    	vpextrq rax,xmm0,0x1
  2203e2:	48 85 c0             	test   rax,rax
  2203e5:	0f 84 44 03 00 00    	je     22072f <getLineNumberInfo+0x101f>
            try self.readNoEof(result[0..]);
  2203eb:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  2203f0:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  2203f5:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  2203fc:	00 00 
            return self.readFn(self, buffer);
  2203fe:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  220403:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  220408:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
  22040d:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  220411:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  220416:	66 85 c0             	test   ax,ax
  220419:	0f 85 ca 02 00 00    	jne    2206e9 <getLineNumberInfo+0xfd9>
  22041f:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  220424:	45 31 e4             	xor    r12d,r12d
  220427:	31 ed                	xor    ebp,ebp
            if (amt_read < buf.len) return error.EndOfStream;
  220429:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  22042e:	0f 82 ab 02 00 00    	jb     2206df <getLineNumberInfo+0xfcf>
            return result[0];
  220434:	0f b6 44 24 48       	movzx  eax,BYTE PTR [rsp+0x48]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  220439:	89 c2                	mov    edx,eax
  22043b:	83 e2 7f             	and    edx,0x7f
  22043e:	89 ee                	mov    esi,ebp
  220440:	83 e6 3f             	and    esi,0x3f
  220443:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  220448:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  22044d:	48 39 d6             	cmp    rsi,rdx
  220450:	0f 85 8f 02 00 00    	jne    2206e5 <getLineNumberInfo+0xfd5>
        result |= operand;
  220456:	49 09 cc             	or     r12,rcx
        if ((byte & 0b10000000) == 0) return result;
  220459:	84 c0                	test   al,al
  22045b:	79 3e                	jns    22049b <getLineNumberInfo+0xd8b>
        shift += 7;
  22045d:	48 83 c5 07          	add    rbp,0x7
            try self.readNoEof(result[0..]);
  220461:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  220466:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  22046b:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  220472:	00 00 
            return self.readFn(self, buffer);
  220474:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  220479:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  22047e:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
  220483:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  220487:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  22048c:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  220491:	66 85 c0             	test   ax,ax
  220494:	74 93                	je     220429 <getLineNumberInfo+0xd19>
  220496:	e9 4e 02 00 00       	jmp    2206e9 <getLineNumberInfo+0xfd9>
            try self.readNoEof(result[0..]);
  22049b:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  2204a0:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  2204a5:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  2204ac:	00 00 
            return self.readFn(self, buffer);
  2204ae:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  2204b3:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  2204b8:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
  2204bd:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  2204c1:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  2204c6:	66 85 c0             	test   ax,ax
  2204c9:	0f 85 42 02 00 00    	jne    220711 <getLineNumberInfo+0x1001>
  2204cf:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  2204d4:	45 31 f6             	xor    r14d,r14d
  2204d7:	31 ed                	xor    ebp,ebp
            if (amt_read < buf.len) return error.EndOfStream;
  2204d9:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  2204de:	0f 82 23 02 00 00    	jb     220707 <getLineNumberInfo+0xff7>
            return result[0];
  2204e4:	0f b6 44 24 48       	movzx  eax,BYTE PTR [rsp+0x48]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  2204e9:	89 c2                	mov    edx,eax
  2204eb:	83 e2 7f             	and    edx,0x7f
  2204ee:	89 ee                	mov    esi,ebp
  2204f0:	83 e6 3f             	and    esi,0x3f
  2204f3:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  2204f8:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  2204fd:	48 39 d6             	cmp    rsi,rdx
  220500:	0f 85 07 02 00 00    	jne    22070d <getLineNumberInfo+0xffd>
        result |= operand;
  220506:	49 09 ce             	or     r14,rcx
        if ((byte & 0b10000000) == 0) return result;
  220509:	84 c0                	test   al,al
  22050b:	79 3e                	jns    22054b <getLineNumberInfo+0xe3b>
        shift += 7;
  22050d:	48 83 c5 07          	add    rbp,0x7
            try self.readNoEof(result[0..]);
  220511:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  220516:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  22051b:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  220522:	00 00 
            return self.readFn(self, buffer);
  220524:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  220529:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  22052e:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
  220533:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  220537:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  22053c:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  220541:	66 85 c0             	test   ax,ax
  220544:	74 93                	je     2204d9 <getLineNumberInfo+0xdc9>
  220546:	e9 c6 01 00 00       	jmp    220711 <getLineNumberInfo+0x1001>
            try self.readNoEof(result[0..]);
  22054b:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  220550:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  220555:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  22055c:	00 00 
            return self.readFn(self, buffer);
  22055e:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  220563:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  220568:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
  22056d:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  220571:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  220576:	66 85 c0             	test   ax,ax
  220579:	0f 85 05 02 00 00    	jne    220784 <getLineNumberInfo+0x1074>
  22057f:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  220584:	31 db                	xor    ebx,ebx
  220586:	31 ed                	xor    ebp,ebp
            if (amt_read < buf.len) return error.EndOfStream;
  220588:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  22058d:	0f 82 e7 01 00 00    	jb     22077a <getLineNumberInfo+0x106a>
            return result[0];
  220593:	0f b6 44 24 48       	movzx  eax,BYTE PTR [rsp+0x48]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  220598:	89 c2                	mov    edx,eax
  22059a:	83 e2 7f             	and    edx,0x7f
  22059d:	89 ee                	mov    esi,ebp
  22059f:	83 e6 3f             	and    esi,0x3f
  2205a2:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  2205a7:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  2205ac:	48 39 d6             	cmp    rsi,rdx
  2205af:	0f 85 cb 01 00 00    	jne    220780 <getLineNumberInfo+0x1070>
        result |= operand;
  2205b5:	48 09 cb             	or     rbx,rcx
        if ((byte & 0b10000000) == 0) return result;
  2205b8:	84 c0                	test   al,al
  2205ba:	79 3e                	jns    2205fa <getLineNumberInfo+0xeea>
        shift += 7;
  2205bc:	48 83 c5 07          	add    rbp,0x7
            try self.readNoEof(result[0..]);
  2205c0:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  2205c5:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  2205ca:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  2205d1:	00 00 
            return self.readFn(self, buffer);
  2205d3:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  2205d8:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  2205dd:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
  2205e2:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  2205e6:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  2205eb:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  2205f0:	66 85 c0             	test   ax,ax
  2205f3:	74 93                	je     220588 <getLineNumberInfo+0xe78>
  2205f5:	e9 8a 01 00 00       	jmp    220784 <getLineNumberInfo+0x1074>
            const new_length = self.len + 1;
  2205fa:	48 8b ac 24 80 00 00 	mov    rbp,QWORD PTR [rsp+0x80]
  220601:	00 
            var better_capacity = self.items.len;
  220602:	48 8b 4c 24 78       	mov    rcx,QWORD PTR [rsp+0x78]
            if (better_capacity >= new_capacity) return;
  220607:	48 39 e9             	cmp    rcx,rbp
  22060a:	76 05                	jbe    220611 <getLineNumberInfo+0xf01>
            const result = &self.items[self.len];
  22060c:	48 89 e8             	mov    rax,rbp
  22060f:	eb 4e                	jmp    22065f <getLineNumberInfo+0xf4f>
                better_capacity += better_capacity / 2 + 8;
  220611:	48 89 c8             	mov    rax,rcx
  220614:	48 d1 e8             	shr    rax,1
  220617:	48 01 c1             	add    rcx,rax
  22061a:	48 83 c1 08          	add    rcx,0x8
                if (better_capacity >= new_capacity) break;
  22061e:	48 39 e9             	cmp    rcx,rbp
  220621:	76 ee                	jbe    220611 <getLineNumberInfo+0xf01>
            self.items = try self.allocator.alignedRealloc(T, A, self.items, better_capacity);
  220623:	48 8b b4 24 88 00 00 	mov    rsi,QWORD PTR [rsp+0x88]
  22062a:	00 
  22062b:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  220630:	48 8d 54 24 70       	lea    rdx,[rsp+0x70]
  220635:	e8 56 1b 00 00       	call   222190 <Allocator_alignedRealloc.94>
  22063a:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  22063f:	66 85 c0             	test   ax,ax
  220642:	0f 85 d5 0c 00 00    	jne    22131d <getLineNumberInfo+0x1c0d>
  220648:	48 8d 44 24 28       	lea    rax,[rsp+0x28]
  22064d:	c5 fa 6f 00          	vmovdqu xmm0,XMMWORD PTR [rax]
  220651:	c5 f9 7f 44 24 70    	vmovdqa XMMWORD PTR [rsp+0x70],xmm0
            const result = &self.items[self.len];
  220657:	48 8b 84 24 80 00 00 	mov    rax,QWORD PTR [rsp+0x80]
  22065e:	00 
  22065f:	48 83 c5 01          	add    rbp,0x1
  220663:	48 8b 4c 24 70       	mov    rcx,QWORD PTR [rsp+0x70]
  220668:	48 8d 04 80          	lea    rax,[rax+rax*4]
            self.len = new_length;
  22066c:	48 89 ac 24 80 00 00 	mov    QWORD PTR [rsp+0x80],rbp
  220673:	00 
            new_item_ptr.* = item;
  220674:	c5 f8 28 84 24 a0 00 	vmovaps xmm0,XMMWORD PTR [rsp+0xa0]
  22067b:	00 00 
  22067d:	c5 f8 11 04 c1       	vmovups XMMWORD PTR [rcx+rax*8],xmm0
  220682:	4c 89 64 c1 10       	mov    QWORD PTR [rcx+rax*8+0x10],r12
  220687:	4c 89 74 c1 18       	mov    QWORD PTR [rcx+rax*8+0x18],r14
  22068c:	48 89 5c c1 20       	mov    QWORD PTR [rcx+rax*8+0x20],rbx
  220691:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
            var in_file_stream = io.FileInStream.init(&self.self_exe_file);
  220696:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  22069b:	48 8d 0d 9e b5 ff ff 	lea    rcx,[rip+0xffffffffffffb59e]        # 21bc40 <FileInStream_readFn>
  2206a2:	48 89 4c 24 10       	mov    QWORD PTR [rsp+0x10],rcx
  2206a7:	48 8b b0 a0 00 00 00 	mov    rsi,QWORD PTR [rax+0xa0]
            return readStringRaw(self.allocator(), in_stream);
  2206ae:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  2206b3:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  2206b8:	e8 03 ec ff ff       	call   21f2c0 <readStringRaw>
  2206bd:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  2206c2:	c5 fa 6f 44 24 28    	vmovdqu xmm0,XMMWORD PTR [rsp+0x28]
            const file_name = try st.readString();
  2206c8:	c5 f9 7f 84 24 a0 00 	vmovdqa XMMWORD PTR [rsp+0xa0],xmm0
  2206cf:	00 00 
  2206d1:	66 85 c0             	test   ax,ax
  2206d4:	0f 84 f9 fc ff ff    	je     2203d3 <getLineNumberInfo+0xcc3>
  2206da:	e9 a9 fc ff ff       	jmp    220388 <getLineNumberInfo+0xc78>
  2206df:	66 b8 1f 00          	mov    ax,0x1f
  2206e3:	eb 04                	jmp    2206e9 <getLineNumberInfo+0xfd9>
  2206e5:	66 b8 23 00          	mov    ax,0x23
  2206e9:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
            const dir_index = try readULeb128(in_stream);
  2206ed:	66 89 01             	mov    WORD PTR [rcx],ax
  2206f0:	c5 fe 6f 84 24 60 07 	vmovdqu ymm0,YMMWORD PTR [rsp+0x760]
  2206f7:	00 00 
  2206f9:	c5 fc 10 8c 24 6e 07 	vmovups ymm1,YMMWORD PTR [rsp+0x76e]
  220700:	00 00 
  220702:	e9 35 f4 ff ff       	jmp    21fb3c <getLineNumberInfo+0x42c>
  220707:	66 b8 1f 00          	mov    ax,0x1f
  22070b:	eb 04                	jmp    220711 <getLineNumberInfo+0x1001>
  22070d:	66 b8 23 00          	mov    ax,0x23
  220711:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
            const mtime = try readULeb128(in_stream);
  220715:	66 89 01             	mov    WORD PTR [rcx],ax
  220718:	c5 fe 6f 84 24 32 07 	vmovdqu ymm0,YMMWORD PTR [rsp+0x732]
  22071f:	00 00 
  220721:	c5 fc 10 8c 24 40 07 	vmovups ymm1,YMMWORD PTR [rsp+0x740]
  220728:	00 00 
  22072a:	e9 0d f4 ff ff       	jmp    21fb3c <getLineNumberInfo+0x42c>
  22072f:	4d 85 ed             	test   r13,r13
  220732:	78 6e                	js     2207a2 <getLineNumberInfo+0x1092>
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  220734:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
  220739:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  22073c:	31 ed                	xor    ebp,ebp
  22073e:	b8 08 00 00 00       	mov    eax,0x8
  220743:	31 d2                	xor    edx,edx
  220745:	4c 89 ee             	mov    rsi,r13
  220748:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  22074a:	48 89 c1             	mov    rcx,rax
  22074d:	48 f7 d9             	neg    rcx
  220750:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  220756:	48 0f 46 cd          	cmovbe rcx,rbp
  22075a:	66 b8 03 00          	mov    ax,0x3
                if (err > 0) {
  22075e:	48 83 f9 1d          	cmp    rcx,0x1d
  220762:	77 60                	ja     2207c4 <getLineNumberInfo+0x10b4>
  220764:	48 8d 15 1d 0d fe ff 	lea    rdx,[rip+0xfffffffffffe0d1d]        # 201488 <app_mask+0x7a8>
  22076b:	48 63 0c 8a          	movsxd rcx,DWORD PTR [rdx+rcx*4]
  22076f:	48 01 d1             	add    rcx,rdx
  220772:	ff e1                	jmp    rcx
  220774:	66 b8 21 00          	mov    ax,0x21
  220778:	eb 2c                	jmp    2207a6 <getLineNumberInfo+0x1096>
  22077a:	66 b8 1f 00          	mov    ax,0x1f
  22077e:	eb 04                	jmp    220784 <getLineNumberInfo+0x1074>
  220780:	66 b8 23 00          	mov    ax,0x23
  220784:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
            const len_bytes = try readULeb128(in_stream);
  220788:	66 89 01             	mov    WORD PTR [rcx],ax
  22078b:	c5 fe 6f 84 24 04 07 	vmovdqu ymm0,YMMWORD PTR [rsp+0x704]
  220792:	00 00 
  220794:	c5 fc 10 8c 24 12 07 	vmovups ymm1,YMMWORD PTR [rsp+0x712]
  22079b:	00 00 
  22079d:	e9 9a f3 ff ff       	jmp    21fb3c <getLineNumberInfo+0x42c>
  2207a2:	66 b8 04 00          	mov    ax,0x4
  2207a6:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
        try in_file.seekTo(prog_start_offset);
  2207aa:	66 89 01             	mov    WORD PTR [rcx],ax
  2207ad:	c5 fe 6f 84 24 a8 06 	vmovdqu ymm0,YMMWORD PTR [rsp+0x6a8]
  2207b4:	00 00 
  2207b6:	c5 fc 10 8c 24 b6 06 	vmovups ymm1,YMMWORD PTR [rsp+0x6b6]
  2207bd:	00 00 
  2207bf:	e9 78 f3 ff ff       	jmp    21fb3c <getLineNumberInfo+0x42c>
  2207c4:	48 83 f9 4b          	cmp    rcx,0x4b
  2207c8:	75 dc                	jne    2207a6 <getLineNumberInfo+0x1096>
  2207ca:	eb a8                	jmp    220774 <getLineNumberInfo+0x1064>
            try self.readNoEof(result[0..]);
  2207cc:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  2207d1:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  2207d6:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  2207dd:	00 00 
  2207df:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  2207e4:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
            return self.readFn(self, buffer);
  2207e9:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  2207ee:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  2207f2:	0f b7 4c 24 20       	movzx  ecx,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  2207f7:	66 85 c9             	test   cx,cx
  2207fa:	74 28                	je     220824 <getLineNumberInfo+0x1114>
  2207fc:	48 8b 04 24          	mov    rax,QWORD PTR [rsp]
            const opcode = try in_stream.readByte();
  220800:	66 89 08             	mov    WORD PTR [rax],cx
  220803:	c5 fe 6f 84 24 7a 06 	vmovdqu ymm0,YMMWORD PTR [rsp+0x67a]
  22080a:	00 00 
  22080c:	c5 fc 10 8c 24 88 06 	vmovups ymm1,YMMWORD PTR [rsp+0x688]
  220813:	00 00 
  220815:	c5 fc 11 48 10       	vmovups YMMWORD PTR [rax+0x10],ymm1
  22081a:	c5 fe 7f 40 02       	vmovdqu YMMWORD PTR [rax+0x2],ymm0
  22081f:	e9 3d f0 ff ff       	jmp    21f861 <getLineNumberInfo+0x151>
  220824:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
  220829:	8a 4c 24 5e          	mov    cl,BYTE PTR [rsp+0x5e]
  22082d:	f6 d1                	not    cl
  22082f:	88 8c 24 a0 00 00 00 	mov    BYTE PTR [rsp+0xa0],cl
  220836:	4c 8d 64 24 20       	lea    r12,[rsp+0x20]
  22083b:	4c 8d 6c 24 08       	lea    r13,[rsp+0x8]
            if (amt_read < buf.len) return error.EndOfStream;
  220840:	48 3b 44 24 10       	cmp    rax,QWORD PTR [rsp+0x10]
  220845:	0f 82 f0 0a 00 00    	jb     22133b <getLineNumberInfo+0x1c2b>
            return result[0];
  22084b:	8a 44 24 48          	mov    al,BYTE PTR [rsp+0x48]
            if (opcode == DW.LNS_extended_op) {
  22084f:	84 c0                	test   al,al
  220851:	74 62                	je     2208b5 <getLineNumberInfo+0x11a5>
            } else if (opcode >= opcode_base) {
  220853:	89 c1                	mov    ecx,eax
  220855:	2a 4c 24 5e          	sub    cl,BYTE PTR [rsp+0x5e]
  220859:	0f 83 01 01 00 00    	jae    220960 <getLineNumberInfo+0x1250>
                switch (opcode) {
  22085f:	04 ff                	add    al,0xff
  220861:	0f b6 c0             	movzx  eax,al
  220864:	3c 09                	cmp    al,0x9
  220866:	0f 87 3b 02 00 00    	ja     220aa7 <getLineNumberInfo+0x1397>
  22086c:	48 8d 0d 8d 0c fe ff 	lea    rcx,[rip+0xfffffffffffe0c8d]        # 201500 <app_mask+0x820>
  220873:	48 63 04 81          	movsxd rax,DWORD PTR [rcx+rax*4]
  220877:	48 01 c8             	add    rax,rcx
  22087a:	ff e0                	jmp    rax
                        if (try prog.checkLineMatch()) |info| return info;
  22087c:	48 8d bc 24 08 02 00 	lea    rdi,[rsp+0x208]
  220883:	00 
  220884:	48 8d b4 24 e0 00 00 	lea    rsi,[rsp+0xe0]
  22088b:	00 
  22088c:	e8 bf 14 00 00       	call   221d50 <LineNumberProgram_checkLineMatch>
  220891:	0f b7 84 24 08 02 00 	movzx  eax,WORD PTR [rsp+0x208]
  220898:	00 
  220899:	66 85 c0             	test   ax,ax
  22089c:	0f 85 ac 0c 00 00    	jne    22154e <getLineNumberInfo+0x1e3e>
  2208a2:	80 bc 24 38 02 00 00 	cmp    BYTE PTR [rsp+0x238],0x1
  2208a9:	01 
  2208aa:	0f 85 0c 01 00 00    	jne    2209bc <getLineNumberInfo+0x12ac>
  2208b0:	e9 b7 0c 00 00       	jmp    22156c <getLineNumberInfo+0x1e5c>
            try self.readNoEof(result[0..]);
  2208b5:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  2208ba:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  2208bf:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  2208c6:	00 00 
            return self.readFn(self, buffer);
  2208c8:	4c 89 e7             	mov    rdi,r12
  2208cb:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  2208d0:	4c 89 ea             	mov    rdx,r13
  2208d3:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  2208d7:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  2208dc:	66 85 c0             	test   ax,ax
  2208df:	0f 85 1a 0a 00 00    	jne    2212ff <getLineNumberInfo+0x1bef>
  2208e5:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  2208ea:	31 ed                	xor    ebp,ebp
  2208ec:	31 db                	xor    ebx,ebx
            if (amt_read < buf.len) return error.EndOfStream;
  2208ee:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  2208f3:	0f 82 fc 09 00 00    	jb     2212f5 <getLineNumberInfo+0x1be5>
            return result[0];
  2208f9:	0f b6 44 24 48       	movzx  eax,BYTE PTR [rsp+0x48]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  2208fe:	89 c2                	mov    edx,eax
  220900:	83 e2 7f             	and    edx,0x7f
  220903:	89 de                	mov    esi,ebx
  220905:	83 e6 3f             	and    esi,0x3f
  220908:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  22090d:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  220912:	48 39 d6             	cmp    rsi,rdx
  220915:	0f 85 e0 09 00 00    	jne    2212fb <getLineNumberInfo+0x1beb>
        result |= operand;
  22091b:	48 09 cd             	or     rbp,rcx
        if ((byte & 0b10000000) == 0) return result;
  22091e:	84 c0                	test   al,al
  220920:	0f 89 d8 00 00 00    	jns    2209fe <getLineNumberInfo+0x12ee>
        shift += 7;
  220926:	48 83 c3 07          	add    rbx,0x7
            try self.readNoEof(result[0..]);
  22092a:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  22092f:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  220934:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  22093b:	00 00 
            return self.readFn(self, buffer);
  22093d:	4c 89 e7             	mov    rdi,r12
  220940:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  220945:	4c 89 ea             	mov    rdx,r13
  220948:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  22094c:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  220951:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  220956:	66 85 c0             	test   ax,ax
  220959:	74 93                	je     2208ee <getLineNumberInfo+0x11de>
  22095b:	e9 9f 09 00 00       	jmp    2212ff <getLineNumberInfo+0x1bef>
                const inc_line = i32(line_base) + i32(adjusted_opcode % line_range);
  220960:	0f b6 c1             	movzx  eax,cl
  220963:	f6 74 24 5f          	div    BYTE PTR [rsp+0x5f]
  220967:	0f b6 cc             	movzx  ecx,ah
  22096a:	48 03 8c 24 68 01 00 	add    rcx,QWORD PTR [rsp+0x168]
  220971:	00 
                prog.line += inc_line;
  220972:	48 01 8c 24 f0 00 00 	add    QWORD PTR [rsp+0xf0],rcx
  220979:	00 
                const inc_addr = minimum_instruction_length * (adjusted_opcode / line_range);
  22097a:	41 f6 e7             	mul    r15b
                prog.address += inc_addr;
  22097d:	0f b6 c0             	movzx  eax,al
  220980:	48 01 84 24 e0 00 00 	add    QWORD PTR [rsp+0xe0],rax
  220987:	00 
                if (try prog.checkLineMatch()) |info| return info;
  220988:	48 8d bc 24 40 02 00 	lea    rdi,[rsp+0x240]
  22098f:	00 
  220990:	48 8d b4 24 e0 00 00 	lea    rsi,[rsp+0xe0]
  220997:	00 
  220998:	e8 b3 13 00 00       	call   221d50 <LineNumberProgram_checkLineMatch>
  22099d:	0f b7 84 24 40 02 00 	movzx  eax,WORD PTR [rsp+0x240]
  2209a4:	00 
  2209a5:	66 85 c0             	test   ax,ax
  2209a8:	0f 85 96 09 00 00    	jne    221344 <getLineNumberInfo+0x1c34>
  2209ae:	80 bc 24 70 02 00 00 	cmp    BYTE PTR [rsp+0x270],0x1
  2209b5:	01 
  2209b6:	0f 84 a6 09 00 00    	je     221362 <getLineNumberInfo+0x1c52>
  2209bc:	c6 84 24 01 01 00 00 	mov    BYTE PTR [rsp+0x101],0x0
  2209c3:	00 
            try self.readNoEof(result[0..]);
  2209c4:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  2209c9:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  2209ce:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  2209d5:	00 00 
            return self.readFn(self, buffer);
  2209d7:	4c 89 e7             	mov    rdi,r12
  2209da:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  2209df:	4c 89 ea             	mov    rdx,r13
  2209e2:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  2209e6:	0f b7 4c 24 20       	movzx  ecx,WORD PTR [rsp+0x20]
  2209eb:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  2209f0:	66 85 c9             	test   cx,cx
  2209f3:	0f 84 47 fe ff ff    	je     220840 <getLineNumberInfo+0x1130>
  2209f9:	e9 fe fd ff ff       	jmp    2207fc <getLineNumberInfo+0x10ec>
                if (op_size < 1) return error.InvalidDebugInfo;
  2209fe:	48 85 ed             	test   rbp,rbp
  220a01:	0f 84 d0 08 00 00    	je     2212d7 <getLineNumberInfo+0x1bc7>
            try self.readNoEof(result[0..]);
  220a07:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  220a0c:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  220a11:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  220a18:	00 00 
            return self.readFn(self, buffer);
  220a1a:	4c 89 e7             	mov    rdi,r12
  220a1d:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  220a22:	4c 89 ea             	mov    rdx,r13
  220a25:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  220a29:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  220a2e:	66 85 c0             	test   ax,ax
  220a31:	0f 85 39 0a 00 00    	jne    221470 <getLineNumberInfo+0x1d60>
  220a37:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
            if (amt_read < buf.len) return error.EndOfStream;
  220a3c:	48 3b 44 24 10       	cmp    rax,QWORD PTR [rsp+0x10]
  220a41:	0f 82 25 0a 00 00    	jb     22146c <getLineNumberInfo+0x1d5c>
            return result[0];
  220a47:	8a 44 24 48          	mov    al,BYTE PTR [rsp+0x48]
                switch (sub_op) {
  220a4b:	3c 02                	cmp    al,0x2
  220a4d:	0f 84 03 04 00 00    	je     220e56 <getLineNumberInfo+0x1746>
  220a53:	3c 03                	cmp    al,0x3
  220a55:	0f 84 b2 04 00 00    	je     220f0d <getLineNumberInfo+0x17fd>
  220a5b:	3c 01                	cmp    al,0x1
  220a5d:	0f 84 2b 0a 00 00    	je     22148e <getLineNumberInfo+0x1d7e>
  220a63:	48 83 c5 ff          	add    rbp,0xffffffffffffffff
  220a67:	0f 88 6a 08 00 00    	js     2212d7 <getLineNumberInfo+0x1bc7>
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  220a6d:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
  220a72:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  220a75:	b8 08 00 00 00       	mov    eax,0x8
  220a7a:	ba 01 00 00 00       	mov    edx,0x1
  220a7f:	48 89 ee             	mov    rsi,rbp
  220a82:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  220a84:	48 89 c1             	mov    rcx,rax
  220a87:	48 f7 d9             	neg    rcx
  220a8a:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  220a90:	b8 00 00 00 00       	mov    eax,0x0
  220a95:	48 0f 46 c8          	cmovbe rcx,rax
                if (err > 0) {
  220a99:	48 85 c9             	test   rcx,rcx
  220a9c:	0f 84 22 ff ff ff    	je     2209c4 <getLineNumberInfo+0x12b4>
  220aa2:	e9 8d 0b 00 00       	jmp    221634 <getLineNumberInfo+0x1f24>
                        if (opcode - 1 >= standard_opcode_lengths.len) return error.InvalidDebugInfo;
  220aa7:	48 39 84 24 98 00 00 	cmp    QWORD PTR [rsp+0x98],rax
  220aae:	00 
  220aaf:	0f 86 22 08 00 00    	jbe    2212d7 <getLineNumberInfo+0x1bc7>
                        try in_file.seekForward(len_bytes);
  220ab5:	48 8b 8c 24 d8 00 00 	mov    rcx,QWORD PTR [rsp+0xd8]
  220abc:	00 
  220abd:	0f b6 34 01          	movzx  esi,BYTE PTR [rcx+rax*1]
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  220ac1:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
  220ac6:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  220ac9:	b8 08 00 00 00       	mov    eax,0x8
  220ace:	ba 01 00 00 00       	mov    edx,0x1
  220ad3:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  220ad5:	48 89 c1             	mov    rcx,rax
  220ad8:	48 f7 d9             	neg    rcx
  220adb:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  220ae1:	b8 00 00 00 00       	mov    eax,0x0
  220ae6:	48 0f 46 c8          	cmovbe rcx,rax
  220aea:	48 85 c9             	test   rcx,rcx
  220aed:	0f 84 d1 fe ff ff    	je     2209c4 <getLineNumberInfo+0x12b4>
  220af3:	e9 b6 0a 00 00       	jmp    2215ae <getLineNumberInfo+0x1e9e>
            try self.readNoEof(result[0..]);
  220af8:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  220afd:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  220b02:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  220b09:	00 00 
            return self.readFn(self, buffer);
  220b0b:	4c 89 e7             	mov    rdi,r12
  220b0e:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  220b13:	4c 89 ea             	mov    rdx,r13
  220b16:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  220b1a:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  220b1f:	66 85 c0             	test   ax,ax
  220b22:	0f 85 98 08 00 00    	jne    2213c0 <getLineNumberInfo+0x1cb0>
  220b28:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  220b2d:	31 db                	xor    ebx,ebx
  220b2f:	31 ed                	xor    ebp,ebp
            if (amt_read < buf.len) return error.EndOfStream;
  220b31:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  220b36:	0f 82 68 08 00 00    	jb     2213a4 <getLineNumberInfo+0x1c94>
            return result[0];
  220b3c:	0f b6 44 24 48       	movzx  eax,BYTE PTR [rsp+0x48]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  220b41:	89 c2                	mov    edx,eax
  220b43:	83 e2 7f             	and    edx,0x7f
  220b46:	89 ee                	mov    esi,ebp
  220b48:	83 e6 3f             	and    esi,0x3f
  220b4b:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  220b50:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  220b55:	48 39 d6             	cmp    rsi,rdx
  220b58:	0f 85 5e 08 00 00    	jne    2213bc <getLineNumberInfo+0x1cac>
        result |= operand;
  220b5e:	48 09 cb             	or     rbx,rcx
        if ((byte & 0b10000000) == 0) return result;
  220b61:	84 c0                	test   al,al
  220b63:	0f 89 16 05 00 00    	jns    22107f <getLineNumberInfo+0x196f>
        shift += 7;
  220b69:	48 83 c5 07          	add    rbp,0x7
            try self.readNoEof(result[0..]);
  220b6d:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  220b72:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  220b77:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  220b7e:	00 00 
            return self.readFn(self, buffer);
  220b80:	4c 89 e7             	mov    rdi,r12
  220b83:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  220b88:	4c 89 ea             	mov    rdx,r13
  220b8b:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  220b8f:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  220b94:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  220b99:	66 85 c0             	test   ax,ax
  220b9c:	74 93                	je     220b31 <getLineNumberInfo+0x1421>
  220b9e:	e9 1d 08 00 00       	jmp    2213c0 <getLineNumberInfo+0x1cb0>
            try self.readNoEof(result[0..]);
  220ba3:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  220ba8:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  220bad:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  220bb4:	00 00 
            return self.readFn(self, buffer);
  220bb6:	4c 89 e7             	mov    rdi,r12
  220bb9:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  220bbe:	4c 89 ea             	mov    rdx,r13
  220bc1:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  220bc5:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  220bca:	66 85 c0             	test   ax,ax
  220bcd:	0f 85 0f 08 00 00    	jne    2213e2 <getLineNumberInfo+0x1cd2>
  220bd3:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  220bd8:	bb 07 00 00 00       	mov    ebx,0x7
  220bdd:	31 ed                	xor    ebp,ebp
            if (amt_read < buf.len) return error.EndOfStream;
  220bdf:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  220be4:	0f 82 c0 07 00 00    	jb     2213aa <getLineNumberInfo+0x1c9a>
  220bea:	48 8d 53 f9          	lea    rdx,[rbx-0x7]
            return result[0];
  220bee:	0f b6 44 24 48       	movzx  eax,BYTE PTR [rsp+0x48]
        if (@shlWithOverflow(i64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  220bf3:	89 c6                	mov    esi,eax
  220bf5:	83 e6 7f             	and    esi,0x7f
  220bf8:	83 e2 3f             	and    edx,0x3f
  220bfb:	c4 e2 e9 f7 ce       	shlx   rcx,rsi,rdx
  220c00:	c4 e2 ea f7 d1       	sarx   rdx,rcx,rdx
  220c05:	48 39 f2             	cmp    rdx,rsi
  220c08:	0f 85 d0 07 00 00    	jne    2213de <getLineNumberInfo+0x1cce>
        result |= operand;
  220c0e:	48 09 cd             	or     rbp,rcx
        if ((byte & 0b10000000) == 0) {
  220c11:	84 c0                	test   al,al
  220c13:	0f 89 77 04 00 00    	jns    221090 <getLineNumberInfo+0x1980>
            try self.readNoEof(result[0..]);
  220c19:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  220c1e:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  220c23:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  220c2a:	00 00 
            return self.readFn(self, buffer);
  220c2c:	4c 89 e7             	mov    rdi,r12
  220c2f:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  220c34:	4c 89 ea             	mov    rdx,r13
  220c37:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  220c3b:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  220c40:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  220c45:	48 83 c3 07          	add    rbx,0x7
  220c49:	66 85 c0             	test   ax,ax
  220c4c:	74 91                	je     220bdf <getLineNumberInfo+0x14cf>
  220c4e:	e9 8f 07 00 00       	jmp    2213e2 <getLineNumberInfo+0x1cd2>
            try self.readNoEof(result[0..]);
  220c53:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  220c58:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  220c5d:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  220c64:	00 00 
            return self.readFn(self, buffer);
  220c66:	4c 89 e7             	mov    rdi,r12
  220c69:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  220c6e:	4c 89 ea             	mov    rdx,r13
  220c71:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  220c75:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  220c7a:	66 85 c0             	test   ax,ax
  220c7d:	0f 85 81 07 00 00    	jne    221404 <getLineNumberInfo+0x1cf4>
  220c83:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  220c88:	31 db                	xor    ebx,ebx
  220c8a:	31 ed                	xor    ebp,ebp
            if (amt_read < buf.len) return error.EndOfStream;
  220c8c:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  220c91:	0f 82 19 07 00 00    	jb     2213b0 <getLineNumberInfo+0x1ca0>
            return result[0];
  220c97:	0f b6 44 24 48       	movzx  eax,BYTE PTR [rsp+0x48]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  220c9c:	89 c2                	mov    edx,eax
  220c9e:	83 e2 7f             	and    edx,0x7f
  220ca1:	89 ee                	mov    esi,ebp
  220ca3:	83 e6 3f             	and    esi,0x3f
  220ca6:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  220cab:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  220cb0:	48 39 d6             	cmp    rsi,rdx
  220cb3:	0f 85 47 07 00 00    	jne    221400 <getLineNumberInfo+0x1cf0>
        result |= operand;
  220cb9:	48 09 cb             	or     rbx,rcx
        if ((byte & 0b10000000) == 0) return result;
  220cbc:	84 c0                	test   al,al
  220cbe:	0f 89 f2 03 00 00    	jns    2210b6 <getLineNumberInfo+0x19a6>
        shift += 7;
  220cc4:	48 83 c5 07          	add    rbp,0x7
            try self.readNoEof(result[0..]);
  220cc8:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  220ccd:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  220cd2:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  220cd9:	00 00 
            return self.readFn(self, buffer);
  220cdb:	4c 89 e7             	mov    rdi,r12
  220cde:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  220ce3:	4c 89 ea             	mov    rdx,r13
  220ce6:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  220cea:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  220cef:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  220cf4:	66 85 c0             	test   ax,ax
  220cf7:	74 93                	je     220c8c <getLineNumberInfo+0x157c>
  220cf9:	e9 06 07 00 00       	jmp    221404 <getLineNumberInfo+0x1cf4>
            try self.readNoEof(result[0..]);
  220cfe:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  220d03:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  220d08:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  220d0f:	00 00 
            return self.readFn(self, buffer);
  220d11:	4c 89 e7             	mov    rdi,r12
  220d14:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  220d19:	4c 89 ea             	mov    rdx,r13
  220d1c:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  220d20:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  220d25:	66 85 c0             	test   ax,ax
  220d28:	0f 85 f8 06 00 00    	jne    221426 <getLineNumberInfo+0x1d16>
  220d2e:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  220d33:	31 db                	xor    ebx,ebx
  220d35:	31 ed                	xor    ebp,ebp
            if (amt_read < buf.len) return error.EndOfStream;
  220d37:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  220d3c:	0f 82 74 06 00 00    	jb     2213b6 <getLineNumberInfo+0x1ca6>
            return result[0];
  220d42:	0f b6 44 24 48       	movzx  eax,BYTE PTR [rsp+0x48]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  220d47:	89 c2                	mov    edx,eax
  220d49:	83 e2 7f             	and    edx,0x7f
  220d4c:	89 ee                	mov    esi,ebp
  220d4e:	83 e6 3f             	and    esi,0x3f
  220d51:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  220d56:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  220d5b:	48 39 d6             	cmp    rsi,rdx
  220d5e:	0f 85 be 06 00 00    	jne    221422 <getLineNumberInfo+0x1d12>
        result |= operand;
  220d64:	48 09 cb             	or     rbx,rcx
        if ((byte & 0b10000000) == 0) return result;
  220d67:	84 c0                	test   al,al
  220d69:	0f 89 54 03 00 00    	jns    2210c3 <getLineNumberInfo+0x19b3>
        shift += 7;
  220d6f:	48 83 c5 07          	add    rbp,0x7
            try self.readNoEof(result[0..]);
  220d73:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  220d78:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  220d7d:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  220d84:	00 00 
            return self.readFn(self, buffer);
  220d86:	4c 89 e7             	mov    rdi,r12
  220d89:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  220d8e:	4c 89 ea             	mov    rdx,r13
  220d91:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  220d95:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  220d9a:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  220d9f:	66 85 c0             	test   ax,ax
  220da2:	74 93                	je     220d37 <getLineNumberInfo+0x1627>
  220da4:	e9 7d 06 00 00       	jmp    221426 <getLineNumberInfo+0x1d16>
                        prog.is_stmt = !prog.is_stmt;
  220da9:	8a 84 24 00 01 00 00 	mov    al,BYTE PTR [rsp+0x100]
  220db0:	f6 d0                	not    al
  220db2:	24 01                	and    al,0x1
  220db4:	88 84 24 00 01 00 00 	mov    BYTE PTR [rsp+0x100],al
  220dbb:	e9 04 fc ff ff       	jmp    2209c4 <getLineNumberInfo+0x12b4>
                        prog.basic_block = true;
  220dc0:	c6 84 24 01 01 00 00 	mov    BYTE PTR [rsp+0x101],0x1
  220dc7:	01 
  220dc8:	e9 f7 fb ff ff       	jmp    2209c4 <getLineNumberInfo+0x12b4>
                        const inc_addr = minimum_instruction_length * ((255 - opcode_base) / line_range);
  220dcd:	0f b6 84 24 a0 00 00 	movzx  eax,BYTE PTR [rsp+0xa0]
  220dd4:	00 
  220dd5:	f6 74 24 5f          	div    BYTE PTR [rsp+0x5f]
  220dd9:	41 f6 e7             	mul    r15b
                        prog.address += inc_addr;
  220ddc:	0f b6 c0             	movzx  eax,al
  220ddf:	eb 68                	jmp    220e49 <getLineNumberInfo+0x1739>
                        const arg = try in_stream.readInt(st.elf.endian, u16);
  220de1:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
  220de6:	8a 58 12             	mov    bl,BYTE PTR [rax+0x12]
            try self.readNoEof(bytes[0..]);
  220de9:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  220dee:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  220df3:	48 c7 44 24 10 02 00 	mov    QWORD PTR [rsp+0x10],0x2
  220dfa:	00 00 
            return self.readFn(self, buffer);
  220dfc:	4c 89 e7             	mov    rdi,r12
  220dff:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  220e04:	4c 89 ea             	mov    rdx,r13
  220e07:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  220e0b:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  220e10:	66 85 c0             	test   ax,ax
  220e13:	0f 85 df 07 00 00    	jne    2215f8 <getLineNumberInfo+0x1ee8>
  220e19:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
            if (amt_read < buf.len) return error.EndOfStream;
  220e1e:	48 3b 44 24 10       	cmp    rax,QWORD PTR [rsp+0x10]
  220e23:	0f 82 cb 07 00 00    	jb     2215f4 <getLineNumberInfo+0x1ee4>
  220e29:	0f b6 44 24 48       	movzx  eax,BYTE PTR [rsp+0x48]
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  220e2e:	0f b6 4c 24 49       	movzx  ecx,BYTE PTR [rsp+0x49]
  220e33:	89 ca                	mov    edx,ecx
  220e35:	c1 e2 08             	shl    edx,0x8
  220e38:	09 c2                	or     edx,eax
                result = (result << 8) | b;
  220e3a:	c1 e0 08             	shl    eax,0x8
  220e3d:	09 c8                	or     eax,ecx
    switch (endian) {
  220e3f:	f6 c3 01             	test   bl,0x1
  220e42:	66 0f 45 c2          	cmovne ax,dx
                        prog.address += arg;
  220e46:	0f b7 c0             	movzx  eax,ax
  220e49:	48 01 84 24 e0 00 00 	add    QWORD PTR [rsp+0xe0],rax
  220e50:	00 
  220e51:	e9 6e fb ff ff       	jmp    2209c4 <getLineNumberInfo+0x12b4>
                        const addr = try in_stream.readInt(st.elf.endian, usize);
  220e56:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
  220e5b:	8a 58 12             	mov    bl,BYTE PTR [rax+0x12]
            try self.readNoEof(bytes[0..]);
  220e5e:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  220e63:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  220e68:	48 c7 44 24 10 08 00 	mov    QWORD PTR [rsp+0x10],0x8
  220e6f:	00 00 
            return self.readFn(self, buffer);
  220e71:	4c 89 e7             	mov    rdi,r12
  220e74:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  220e79:	4c 89 ea             	mov    rdx,r13
  220e7c:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  220e80:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  220e85:	66 85 c0             	test   ax,ax
  220e88:	0f 85 d0 07 00 00    	jne    22165e <getLineNumberInfo+0x1f4e>
  220e8e:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
            if (amt_read < buf.len) return error.EndOfStream;
  220e93:	48 3b 44 24 10       	cmp    rax,QWORD PTR [rsp+0x10]
  220e98:	0f 82 bc 07 00 00    	jb     22165a <getLineNumberInfo+0x1f4a>
  220e9e:	0f b6 44 24 48       	movzx  eax,BYTE PTR [rsp+0x48]
  220ea3:	0f b6 4c 24 49       	movzx  ecx,BYTE PTR [rsp+0x49]
  220ea8:	f6 c3 01             	test   bl,0x1
  220eab:	0f 84 72 01 00 00    	je     221023 <getLineNumberInfo+0x1913>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  220eb1:	48 c1 e1 08          	shl    rcx,0x8
  220eb5:	48 09 c1             	or     rcx,rax
  220eb8:	0f b6 44 24 4a       	movzx  eax,BYTE PTR [rsp+0x4a]
  220ebd:	48 c1 e0 10          	shl    rax,0x10
  220ec1:	48 09 c8             	or     rax,rcx
  220ec4:	0f b6 4c 24 4b       	movzx  ecx,BYTE PTR [rsp+0x4b]
  220ec9:	48 c1 e1 18          	shl    rcx,0x18
  220ecd:	48 09 c1             	or     rcx,rax
  220ed0:	0f b6 44 24 4c       	movzx  eax,BYTE PTR [rsp+0x4c]
  220ed5:	48 c1 e0 20          	shl    rax,0x20
  220ed9:	48 09 c8             	or     rax,rcx
  220edc:	0f b6 4c 24 4d       	movzx  ecx,BYTE PTR [rsp+0x4d]
  220ee1:	48 c1 e1 28          	shl    rcx,0x28
  220ee5:	48 09 c1             	or     rcx,rax
  220ee8:	0f b6 54 24 4e       	movzx  edx,BYTE PTR [rsp+0x4e]
  220eed:	48 c1 e2 30          	shl    rdx,0x30
  220ef1:	0f b6 44 24 4f       	movzx  eax,BYTE PTR [rsp+0x4f]
  220ef6:	48 c1 e0 38          	shl    rax,0x38
  220efa:	48 09 d0             	or     rax,rdx
  220efd:	48 09 c8             	or     rax,rcx
                        prog.address = addr;
  220f00:	48 89 84 24 e0 00 00 	mov    QWORD PTR [rsp+0xe0],rax
  220f07:	00 
  220f08:	e9 b7 fa ff ff       	jmp    2209c4 <getLineNumberInfo+0x12b4>
  220f0d:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
            var in_file_stream = io.FileInStream.init(&self.self_exe_file);
  220f12:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  220f17:	48 8d 0d 22 ad ff ff 	lea    rcx,[rip+0xffffffffffffad22]        # 21bc40 <FileInStream_readFn>
  220f1e:	48 89 4c 24 10       	mov    QWORD PTR [rsp+0x10],rcx
  220f23:	48 8b b0 a0 00 00 00 	mov    rsi,QWORD PTR [rax+0xa0]
            return readStringRaw(self.allocator(), in_stream);
  220f2a:	4c 89 e7             	mov    rdi,r12
  220f2d:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  220f32:	e8 89 e3 ff ff       	call   21f2c0 <readStringRaw>
  220f37:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  220f3c:	48 8d 4c 24 22       	lea    rcx,[rsp+0x22]
  220f41:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  220f45:	c5 f8 29 84 24 b0 01 	vmovaps XMMWORD PTR [rsp+0x1b0],xmm0
  220f4c:	00 00 
  220f4e:	48 8b 49 0e          	mov    rcx,QWORD PTR [rcx+0xe]
  220f52:	48 89 8c 24 be 01 00 	mov    QWORD PTR [rsp+0x1be],rcx
  220f59:	00 
                        const file_name = try st.readString();
  220f5a:	66 85 c0             	test   ax,ax
  220f5d:	0f 85 b3 06 00 00    	jne    221616 <getLineNumberInfo+0x1f06>
  220f63:	48 8d 84 24 b6 01 00 	lea    rax,[rsp+0x1b6]
  220f6a:	00 
  220f6b:	c5 fa 6f 00          	vmovdqu xmm0,XMMWORD PTR [rax]
  220f6f:	c5 f9 7f 84 24 d0 01 	vmovdqa XMMWORD PTR [rsp+0x1d0],xmm0
  220f76:	00 00 
            try self.readNoEof(result[0..]);
  220f78:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  220f7d:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  220f82:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  220f89:	00 00 
            return self.readFn(self, buffer);
  220f8b:	4c 89 e7             	mov    rdi,r12
  220f8e:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  220f93:	4c 89 ea             	mov    rdx,r13
  220f96:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  220f9a:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  220f9f:	66 85 c0             	test   ax,ax
  220fa2:	0f 85 a6 04 00 00    	jne    22144e <getLineNumberInfo+0x1d3e>
  220fa8:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  220fad:	31 ed                	xor    ebp,ebp
  220faf:	31 db                	xor    ebx,ebx
            if (amt_read < buf.len) return error.EndOfStream;
  220fb1:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  220fb6:	0f 82 88 04 00 00    	jb     221444 <getLineNumberInfo+0x1d34>
            return result[0];
  220fbc:	0f b6 44 24 48       	movzx  eax,BYTE PTR [rsp+0x48]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  220fc1:	89 c2                	mov    edx,eax
  220fc3:	83 e2 7f             	and    edx,0x7f
  220fc6:	89 de                	mov    esi,ebx
  220fc8:	83 e6 3f             	and    esi,0x3f
  220fcb:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  220fd0:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  220fd5:	48 39 d6             	cmp    rsi,rdx
  220fd8:	0f 85 6c 04 00 00    	jne    22144a <getLineNumberInfo+0x1d3a>
        result |= operand;
  220fde:	48 09 cd             	or     rbp,rcx
        if ((byte & 0b10000000) == 0) return result;
  220fe1:	84 c0                	test   al,al
  220fe3:	0f 89 e7 00 00 00    	jns    2210d0 <getLineNumberInfo+0x19c0>
        shift += 7;
  220fe9:	48 83 c3 07          	add    rbx,0x7
            try self.readNoEof(result[0..]);
  220fed:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  220ff2:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  220ff7:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  220ffe:	00 00 
            return self.readFn(self, buffer);
  221000:	4c 89 e7             	mov    rdi,r12
  221003:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  221008:	4c 89 ea             	mov    rdx,r13
  22100b:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  22100f:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  221014:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  221019:	66 85 c0             	test   ax,ax
  22101c:	74 93                	je     220fb1 <getLineNumberInfo+0x18a1>
  22101e:	e9 2b 04 00 00       	jmp    22144e <getLineNumberInfo+0x1d3e>
                result = (result << 8) | b;
  221023:	48 c1 e0 08          	shl    rax,0x8
  221027:	48 09 c8             	or     rax,rcx
  22102a:	48 c1 e0 08          	shl    rax,0x8
  22102e:	0f b6 4c 24 4a       	movzx  ecx,BYTE PTR [rsp+0x4a]
  221033:	48 09 c1             	or     rcx,rax
  221036:	48 c1 e1 08          	shl    rcx,0x8
  22103a:	0f b6 44 24 4b       	movzx  eax,BYTE PTR [rsp+0x4b]
  22103f:	48 09 c8             	or     rax,rcx
  221042:	48 c1 e0 08          	shl    rax,0x8
  221046:	0f b6 4c 24 4c       	movzx  ecx,BYTE PTR [rsp+0x4c]
  22104b:	48 09 c1             	or     rcx,rax
  22104e:	48 c1 e1 08          	shl    rcx,0x8
  221052:	0f b6 44 24 4d       	movzx  eax,BYTE PTR [rsp+0x4d]
  221057:	48 09 c8             	or     rax,rcx
  22105a:	48 c1 e0 08          	shl    rax,0x8
  22105e:	0f b6 4c 24 4e       	movzx  ecx,BYTE PTR [rsp+0x4e]
  221063:	48 09 c1             	or     rcx,rax
  221066:	48 c1 e1 08          	shl    rcx,0x8
  22106a:	0f b6 44 24 4f       	movzx  eax,BYTE PTR [rsp+0x4f]
  22106f:	48 09 c8             	or     rax,rcx
                        prog.address = addr;
  221072:	48 89 84 24 e0 00 00 	mov    QWORD PTR [rsp+0xe0],rax
  221079:	00 
  22107a:	e9 45 f9 ff ff       	jmp    2209c4 <getLineNumberInfo+0x12b4>
                        prog.address += arg * minimum_instruction_length;
  22107f:	49 0f af df          	imul   rbx,r15
  221083:	48 01 9c 24 e0 00 00 	add    QWORD PTR [rsp+0xe0],rbx
  22108a:	00 
  22108b:	e9 34 f9 ff ff       	jmp    2209c4 <getLineNumberInfo+0x12b4>
            if (shift < @sizeOf(i64) * 8 and (byte & 0b01000000) != 0) result |= -(i64(1) << @intCast(u6, shift));
  221090:	48 83 fb 3f          	cmp    rbx,0x3f
  221094:	77 13                	ja     2210a9 <getLineNumberInfo+0x1999>
  221096:	24 40                	and    al,0x40
  221098:	74 0f                	je     2210a9 <getLineNumberInfo+0x1999>
  22109a:	48 c7 c0 ff ff ff ff 	mov    rax,0xffffffffffffffff
  2210a1:	c4 e2 e1 f7 c0       	shlx   rax,rax,rbx
  2210a6:	48 09 c5             	or     rbp,rax
                        prog.line += arg;
  2210a9:	48 01 ac 24 f0 00 00 	add    QWORD PTR [rsp+0xf0],rbp
  2210b0:	00 
  2210b1:	e9 0e f9 ff ff       	jmp    2209c4 <getLineNumberInfo+0x12b4>
                        prog.file = arg;
  2210b6:	48 89 9c 24 e8 00 00 	mov    QWORD PTR [rsp+0xe8],rbx
  2210bd:	00 
  2210be:	e9 01 f9 ff ff       	jmp    2209c4 <getLineNumberInfo+0x12b4>
                        prog.column = arg;
  2210c3:	48 89 9c 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],rbx
  2210ca:	00 
  2210cb:	e9 f4 f8 ff ff       	jmp    2209c4 <getLineNumberInfo+0x12b4>
            try self.readNoEof(result[0..]);
  2210d0:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  2210d5:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  2210da:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  2210e1:	00 00 
            return self.readFn(self, buffer);
  2210e3:	4c 89 e7             	mov    rdi,r12
  2210e6:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  2210eb:	4c 89 ea             	mov    rdx,r13
  2210ee:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  2210f2:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  2210f7:	66 85 c0             	test   ax,ax
  2210fa:	0f 85 e0 03 00 00    	jne    2214e0 <getLineNumberInfo+0x1dd0>
  221100:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  221105:	45 31 f6             	xor    r14d,r14d
  221108:	31 db                	xor    ebx,ebx
            if (amt_read < buf.len) return error.EndOfStream;
  22110a:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  22110f:	0f 82 c1 03 00 00    	jb     2214d6 <getLineNumberInfo+0x1dc6>
            return result[0];
  221115:	0f b6 44 24 48       	movzx  eax,BYTE PTR [rsp+0x48]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  22111a:	89 c2                	mov    edx,eax
  22111c:	83 e2 7f             	and    edx,0x7f
  22111f:	89 de                	mov    esi,ebx
  221121:	83 e6 3f             	and    esi,0x3f
  221124:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  221129:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  22112e:	48 39 d6             	cmp    rsi,rdx
  221131:	0f 85 a5 03 00 00    	jne    2214dc <getLineNumberInfo+0x1dcc>
        result |= operand;
  221137:	49 09 ce             	or     r14,rcx
        if ((byte & 0b10000000) == 0) return result;
  22113a:	84 c0                	test   al,al
  22113c:	79 3a                	jns    221178 <getLineNumberInfo+0x1a68>
        shift += 7;
  22113e:	48 83 c3 07          	add    rbx,0x7
            try self.readNoEof(result[0..]);
  221142:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  221147:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  22114c:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  221153:	00 00 
            return self.readFn(self, buffer);
  221155:	4c 89 e7             	mov    rdi,r12
  221158:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  22115d:	4c 89 ea             	mov    rdx,r13
  221160:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  221164:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  221169:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  22116e:	66 85 c0             	test   ax,ax
  221171:	74 97                	je     22110a <getLineNumberInfo+0x19fa>
  221173:	e9 68 03 00 00       	jmp    2214e0 <getLineNumberInfo+0x1dd0>
            try self.readNoEof(result[0..]);
  221178:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  22117d:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  221182:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  221189:	00 00 
            return self.readFn(self, buffer);
  22118b:	4c 89 e7             	mov    rdi,r12
  22118e:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  221193:	4c 89 ea             	mov    rdx,r13
  221196:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  22119a:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  22119f:	66 85 c0             	test   ax,ax
  2211a2:	0f 85 de 04 00 00    	jne    221686 <getLineNumberInfo+0x1f76>
  2211a8:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  2211ad:	31 c0                	xor    eax,eax
  2211af:	48 89 44 24 68       	mov    QWORD PTR [rsp+0x68],rax
  2211b4:	31 db                	xor    ebx,ebx
            if (amt_read < buf.len) return error.EndOfStream;
  2211b6:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  2211bb:	0f 82 bb 04 00 00    	jb     22167c <getLineNumberInfo+0x1f6c>
            return result[0];
  2211c1:	0f b6 44 24 48       	movzx  eax,BYTE PTR [rsp+0x48]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  2211c6:	89 c2                	mov    edx,eax
  2211c8:	83 e2 7f             	and    edx,0x7f
  2211cb:	89 de                	mov    esi,ebx
  2211cd:	83 e6 3f             	and    esi,0x3f
  2211d0:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  2211d5:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  2211da:	48 39 d6             	cmp    rsi,rdx
  2211dd:	0f 85 9f 04 00 00    	jne    221682 <getLineNumberInfo+0x1f72>
        result |= operand;
  2211e3:	48 09 4c 24 68       	or     QWORD PTR [rsp+0x68],rcx
        if ((byte & 0b10000000) == 0) return result;
  2211e8:	84 c0                	test   al,al
  2211ea:	79 3a                	jns    221226 <getLineNumberInfo+0x1b16>
        shift += 7;
  2211ec:	48 83 c3 07          	add    rbx,0x7
            try self.readNoEof(result[0..]);
  2211f0:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  2211f5:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  2211fa:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  221201:	00 00 
            return self.readFn(self, buffer);
  221203:	4c 89 e7             	mov    rdi,r12
  221206:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  22120b:	4c 89 ea             	mov    rdx,r13
  22120e:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  221212:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  221217:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  22121c:	66 85 c0             	test   ax,ax
  22121f:	74 95                	je     2211b6 <getLineNumberInfo+0x1aa6>
  221221:	e9 60 04 00 00       	jmp    221686 <getLineNumberInfo+0x1f76>
                        try file_entries.append(FileEntry{
  221226:	c5 f9 6f 84 24 d0 01 	vmovdqa xmm0,XMMWORD PTR [rsp+0x1d0]
  22122d:	00 00 
  22122f:	c5 f9 7f 84 24 f0 01 	vmovdqa XMMWORD PTR [rsp+0x1f0],xmm0
  221236:	00 00 
            const new_length = self.len + 1;
  221238:	48 8b 9c 24 80 00 00 	mov    rbx,QWORD PTR [rsp+0x80]
  22123f:	00 
            var better_capacity = self.items.len;
  221240:	48 8b 4c 24 78       	mov    rcx,QWORD PTR [rsp+0x78]
            if (better_capacity >= new_capacity) return;
  221245:	48 39 d9             	cmp    rcx,rbx
  221248:	76 05                	jbe    22124f <getLineNumberInfo+0x1b3f>
            const result = &self.items[self.len];
  22124a:	48 89 d8             	mov    rax,rbx
  22124d:	eb 4c                	jmp    22129b <getLineNumberInfo+0x1b8b>
                better_capacity += better_capacity / 2 + 8;
  22124f:	48 89 c8             	mov    rax,rcx
  221252:	48 d1 e8             	shr    rax,1
  221255:	48 01 c1             	add    rcx,rax
  221258:	48 83 c1 08          	add    rcx,0x8
                if (better_capacity >= new_capacity) break;
  22125c:	48 39 d9             	cmp    rcx,rbx
  22125f:	76 ee                	jbe    22124f <getLineNumberInfo+0x1b3f>
            self.items = try self.allocator.alignedRealloc(T, A, self.items, better_capacity);
  221261:	48 8b b4 24 88 00 00 	mov    rsi,QWORD PTR [rsp+0x88]
  221268:	00 
  221269:	4c 89 e7             	mov    rdi,r12
  22126c:	48 8d 54 24 70       	lea    rdx,[rsp+0x70]
  221271:	e8 1a 0f 00 00       	call   222190 <Allocator_alignedRealloc.94>
  221276:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  22127b:	66 85 c0             	test   ax,ax
  22127e:	0f 85 50 04 00 00    	jne    2216d4 <getLineNumberInfo+0x1fc4>
  221284:	48 8d 44 24 28       	lea    rax,[rsp+0x28]
  221289:	c5 fa 6f 00          	vmovdqu xmm0,XMMWORD PTR [rax]
  22128d:	c5 f9 7f 44 24 70    	vmovdqa XMMWORD PTR [rsp+0x70],xmm0
            const result = &self.items[self.len];
  221293:	48 8b 84 24 80 00 00 	mov    rax,QWORD PTR [rsp+0x80]
  22129a:	00 
  22129b:	48 83 c3 01          	add    rbx,0x1
  22129f:	48 8b 4c 24 70       	mov    rcx,QWORD PTR [rsp+0x70]
  2212a4:	48 8d 04 80          	lea    rax,[rax+rax*4]
            self.len = new_length;
  2212a8:	48 89 9c 24 80 00 00 	mov    QWORD PTR [rsp+0x80],rbx
  2212af:	00 
            new_item_ptr.* = item;
  2212b0:	c5 f9 6f 84 24 f0 01 	vmovdqa xmm0,XMMWORD PTR [rsp+0x1f0]
  2212b7:	00 00 
  2212b9:	c5 fa 7f 04 c1       	vmovdqu XMMWORD PTR [rcx+rax*8],xmm0
  2212be:	48 89 6c c1 10       	mov    QWORD PTR [rcx+rax*8+0x10],rbp
  2212c3:	4c 89 74 c1 18       	mov    QWORD PTR [rcx+rax*8+0x18],r14
  2212c8:	48 8b 54 24 68       	mov    rdx,QWORD PTR [rsp+0x68]
  2212cd:	48 89 54 c1 20       	mov    QWORD PTR [rcx+rax*8+0x20],rdx
  2212d2:	e9 ed f6 ff ff       	jmp    2209c4 <getLineNumberInfo+0x12b4>
  2212d7:	c5 fc 10 05 91 6f fe 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffe6f91]        # 208270 <__unnamed_89+0x10>
  2212de:	ff 
  2212df:	48 8b 04 24          	mov    rax,QWORD PTR [rsp]
  2212e3:	c5 fc 11 40 10       	vmovups YMMWORD PTR [rax+0x10],ymm0
  2212e8:	c5 fe 6f 05 70 6f fe 	vmovdqu ymm0,YMMWORD PTR [rip+0xfffffffffffe6f70]        # 208260 <__unnamed_89>
  2212ef:	ff 
  2212f0:	e9 22 e7 ff ff       	jmp    21fa17 <getLineNumberInfo+0x307>
  2212f5:	66 b8 1f 00          	mov    ax,0x1f
  2212f9:	eb 04                	jmp    2212ff <getLineNumberInfo+0x1bef>
  2212fb:	66 b8 23 00          	mov    ax,0x23
  2212ff:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                const op_size = try readULeb128(in_stream);
  221303:	66 89 01             	mov    WORD PTR [rcx],ax
  221306:	c5 fe 6f 84 24 4c 06 	vmovdqu ymm0,YMMWORD PTR [rsp+0x64c]
  22130d:	00 00 
  22130f:	c5 fc 10 8c 24 5a 06 	vmovups ymm1,YMMWORD PTR [rsp+0x65a]
  221316:	00 00 
  221318:	e9 1f e8 ff ff       	jmp    21fb3c <getLineNumberInfo+0x42c>
  22131d:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
            try file_entries.append(FileEntry{
  221321:	66 89 01             	mov    WORD PTR [rcx],ax
  221324:	c5 fc 10 84 24 d6 06 	vmovups ymm0,YMMWORD PTR [rsp+0x6d6]
  22132b:	00 00 
  22132d:	c5 fc 10 8c 24 e4 06 	vmovups ymm1,YMMWORD PTR [rsp+0x6e4]
  221334:	00 00 
  221336:	e9 01 e8 ff ff       	jmp    21fb3c <getLineNumberInfo+0x42c>
  22133b:	66 b9 1f 00          	mov    cx,0x1f
  22133f:	e9 b8 f4 ff ff       	jmp    2207fc <getLineNumberInfo+0x10ec>
  221344:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                if (try prog.checkLineMatch()) |info| return info;
  221348:	66 89 01             	mov    WORD PTR [rcx],ax
  22134b:	c5 fc 10 84 24 80 04 	vmovups ymm0,YMMWORD PTR [rsp+0x480]
  221352:	00 00 
  221354:	c5 fc 10 8c 24 8e 04 	vmovups ymm1,YMMWORD PTR [rsp+0x48e]
  22135b:	00 00 
  22135d:	e9 da e7 ff ff       	jmp    21fb3c <getLineNumberInfo+0x42c>
  221362:	48 8b 84 24 68 02 00 	mov    rax,QWORD PTR [rsp+0x268]
  221369:	00 
  22136a:	48 89 84 24 08 03 00 	mov    QWORD PTR [rsp+0x308],rax
  221371:	00 
  221372:	c5 fc 10 84 24 48 02 	vmovups ymm0,YMMWORD PTR [rsp+0x248]
  221379:	00 00 
  22137b:	c5 fc 11 84 24 e8 02 	vmovups YMMWORD PTR [rsp+0x2e8],ymm0
  221382:	00 00 
  221384:	48 8b 04 24          	mov    rax,QWORD PTR [rsp]
  221388:	66 c7 00 00 00       	mov    WORD PTR [rax],0x0
  22138d:	c5 fc 10 84 24 e2 02 	vmovups ymm0,YMMWORD PTR [rsp+0x2e2]
  221394:	00 00 
  221396:	c5 fc 10 8c 24 f0 02 	vmovups ymm1,YMMWORD PTR [rsp+0x2f0]
  22139d:	00 00 
  22139f:	e9 71 f4 ff ff       	jmp    220815 <getLineNumberInfo+0x1105>
  2213a4:	66 b8 1f 00          	mov    ax,0x1f
  2213a8:	eb 16                	jmp    2213c0 <getLineNumberInfo+0x1cb0>
  2213aa:	66 b8 1f 00          	mov    ax,0x1f
  2213ae:	eb 32                	jmp    2213e2 <getLineNumberInfo+0x1cd2>
  2213b0:	66 b8 1f 00          	mov    ax,0x1f
  2213b4:	eb 4e                	jmp    221404 <getLineNumberInfo+0x1cf4>
  2213b6:	66 b8 1f 00          	mov    ax,0x1f
  2213ba:	eb 6a                	jmp    221426 <getLineNumberInfo+0x1d16>
  2213bc:	66 b8 23 00          	mov    ax,0x23
  2213c0:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                        const arg = try readULeb128(in_stream);
  2213c4:	66 89 01             	mov    WORD PTR [rcx],ax
  2213c7:	c5 fc 10 84 24 f6 03 	vmovups ymm0,YMMWORD PTR [rsp+0x3f6]
  2213ce:	00 00 
  2213d0:	c5 fc 10 8c 24 04 04 	vmovups ymm1,YMMWORD PTR [rsp+0x404]
  2213d7:	00 00 
  2213d9:	e9 5e e7 ff ff       	jmp    21fb3c <getLineNumberInfo+0x42c>
  2213de:	66 b8 23 00          	mov    ax,0x23
  2213e2:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                        const arg = try readILeb128(in_stream);
  2213e6:	66 89 01             	mov    WORD PTR [rcx],ax
  2213e9:	c5 fc 10 84 24 c8 03 	vmovups ymm0,YMMWORD PTR [rsp+0x3c8]
  2213f0:	00 00 
  2213f2:	c5 fc 10 8c 24 d6 03 	vmovups ymm1,YMMWORD PTR [rsp+0x3d6]
  2213f9:	00 00 
  2213fb:	e9 3c e7 ff ff       	jmp    21fb3c <getLineNumberInfo+0x42c>
  221400:	66 b8 23 00          	mov    ax,0x23
  221404:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                        const arg = try readULeb128(in_stream);
  221408:	66 89 01             	mov    WORD PTR [rcx],ax
  22140b:	c5 fc 10 84 24 9a 03 	vmovups ymm0,YMMWORD PTR [rsp+0x39a]
  221412:	00 00 
  221414:	c5 fc 10 8c 24 a8 03 	vmovups ymm1,YMMWORD PTR [rsp+0x3a8]
  22141b:	00 00 
  22141d:	e9 1a e7 ff ff       	jmp    21fb3c <getLineNumberInfo+0x42c>
  221422:	66 b8 23 00          	mov    ax,0x23
  221426:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                        const arg = try readULeb128(in_stream);
  22142a:	66 89 01             	mov    WORD PTR [rcx],ax
  22142d:	c5 fc 10 84 24 6c 03 	vmovups ymm0,YMMWORD PTR [rsp+0x36c]
  221434:	00 00 
  221436:	c5 fc 10 8c 24 7a 03 	vmovups ymm1,YMMWORD PTR [rsp+0x37a]
  22143d:	00 00 
  22143f:	e9 f8 e6 ff ff       	jmp    21fb3c <getLineNumberInfo+0x42c>
  221444:	66 b8 1f 00          	mov    ax,0x1f
  221448:	eb 04                	jmp    22144e <getLineNumberInfo+0x1d3e>
  22144a:	66 b8 23 00          	mov    ax,0x23
  22144e:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                        const dir_index = try readULeb128(in_stream);
  221452:	66 89 01             	mov    WORD PTR [rcx],ax
  221455:	c5 fc 10 84 24 38 05 	vmovups ymm0,YMMWORD PTR [rsp+0x538]
  22145c:	00 00 
  22145e:	c5 fc 10 8c 24 46 05 	vmovups ymm1,YMMWORD PTR [rsp+0x546]
  221465:	00 00 
  221467:	e9 d0 e6 ff ff       	jmp    21fb3c <getLineNumberInfo+0x42c>
  22146c:	66 b8 1f 00          	mov    ax,0x1f
  221470:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                sub_op = try in_stream.readByte();
  221474:	66 89 01             	mov    WORD PTR [rcx],ax
  221477:	c5 fe 6f 84 24 1e 06 	vmovdqu ymm0,YMMWORD PTR [rsp+0x61e]
  22147e:	00 00 
  221480:	c5 fc 10 8c 24 2c 06 	vmovups ymm1,YMMWORD PTR [rsp+0x62c]
  221487:	00 00 
  221489:	e9 ae e6 ff ff       	jmp    21fb3c <getLineNumberInfo+0x42c>
                        prog.end_sequence = true;
  22148e:	c6 84 24 02 01 00 00 	mov    BYTE PTR [rsp+0x102],0x1
  221495:	01 
  221496:	48 8d bc 24 78 02 00 	lea    rdi,[rsp+0x278]
  22149d:	00 
  22149e:	48 8d b4 24 e0 00 00 	lea    rsi,[rsp+0xe0]
  2214a5:	00 
                        if (try prog.checkLineMatch()) |info| return info;
  2214a6:	e8 a5 08 00 00       	call   221d50 <LineNumberProgram_checkLineMatch>
  2214ab:	0f b7 84 24 78 02 00 	movzx  eax,WORD PTR [rsp+0x278]
  2214b2:	00 
  2214b3:	66 85 c0             	test   ax,ax
  2214b6:	74 46                	je     2214fe <getLineNumberInfo+0x1dee>
  2214b8:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
  2214bc:	66 89 01             	mov    WORD PTR [rcx],ax
  2214bf:	c5 fc 10 84 24 c2 05 	vmovups ymm0,YMMWORD PTR [rsp+0x5c2]
  2214c6:	00 00 
  2214c8:	c5 fc 10 8c 24 d0 05 	vmovups ymm1,YMMWORD PTR [rsp+0x5d0]
  2214cf:	00 00 
  2214d1:	e9 66 e6 ff ff       	jmp    21fb3c <getLineNumberInfo+0x42c>
  2214d6:	66 b8 1f 00          	mov    ax,0x1f
  2214da:	eb 04                	jmp    2214e0 <getLineNumberInfo+0x1dd0>
  2214dc:	66 b8 23 00          	mov    ax,0x23
  2214e0:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                        const mtime = try readULeb128(in_stream);
  2214e4:	66 89 01             	mov    WORD PTR [rcx],ax
  2214e7:	c5 fc 10 84 24 0a 05 	vmovups ymm0,YMMWORD PTR [rsp+0x50a]
  2214ee:	00 00 
  2214f0:	c5 fc 10 8c 24 18 05 	vmovups ymm1,YMMWORD PTR [rsp+0x518]
  2214f7:	00 00 
  2214f9:	e9 3e e6 ff ff       	jmp    21fb3c <getLineNumberInfo+0x42c>
                        if (try prog.checkLineMatch()) |info| return info;
  2214fe:	80 bc 24 a8 02 00 00 	cmp    BYTE PTR [rsp+0x2a8],0x1
  221505:	01 
  221506:	0f 85 f2 e4 ff ff    	jne    21f9fe <getLineNumberInfo+0x2ee>
  22150c:	48 8b 84 24 a0 02 00 	mov    rax,QWORD PTR [rsp+0x2a0]
  221513:	00 
  221514:	48 89 84 24 36 03 00 	mov    QWORD PTR [rsp+0x336],rax
  22151b:	00 
  22151c:	c5 fc 10 84 24 80 02 	vmovups ymm0,YMMWORD PTR [rsp+0x280]
  221523:	00 00 
  221525:	c5 fc 11 84 24 16 03 	vmovups YMMWORD PTR [rsp+0x316],ymm0
  22152c:	00 00 
  22152e:	48 8b 04 24          	mov    rax,QWORD PTR [rsp]
  221532:	66 c7 00 00 00       	mov    WORD PTR [rax],0x0
  221537:	c5 fc 10 84 24 10 03 	vmovups ymm0,YMMWORD PTR [rsp+0x310]
  22153e:	00 00 
  221540:	c5 fc 10 8c 24 1e 03 	vmovups ymm1,YMMWORD PTR [rsp+0x31e]
  221547:	00 00 
  221549:	e9 c7 f2 ff ff       	jmp    220815 <getLineNumberInfo+0x1105>
  22154e:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                        if (try prog.checkLineMatch()) |info| return info;
  221552:	66 89 01             	mov    WORD PTR [rcx],ax
  221555:	c5 fc 10 84 24 24 04 	vmovups ymm0,YMMWORD PTR [rsp+0x424]
  22155c:	00 00 
  22155e:	c5 fc 10 8c 24 32 04 	vmovups ymm1,YMMWORD PTR [rsp+0x432]
  221565:	00 00 
  221567:	e9 d0 e5 ff ff       	jmp    21fb3c <getLineNumberInfo+0x42c>
  22156c:	48 8b 84 24 30 02 00 	mov    rax,QWORD PTR [rsp+0x230]
  221573:	00 
  221574:	48 89 84 24 da 02 00 	mov    QWORD PTR [rsp+0x2da],rax
  22157b:	00 
  22157c:	c5 fc 10 84 24 10 02 	vmovups ymm0,YMMWORD PTR [rsp+0x210]
  221583:	00 00 
  221585:	c5 fc 11 84 24 ba 02 	vmovups YMMWORD PTR [rsp+0x2ba],ymm0
  22158c:	00 00 
  22158e:	48 8b 04 24          	mov    rax,QWORD PTR [rsp]
  221592:	66 c7 00 00 00       	mov    WORD PTR [rax],0x0
  221597:	c5 fc 10 84 24 b4 02 	vmovups ymm0,YMMWORD PTR [rsp+0x2b4]
  22159e:	00 00 
  2215a0:	c5 fc 10 8c 24 c2 02 	vmovups ymm1,YMMWORD PTR [rsp+0x2c2]
  2215a7:	00 00 
  2215a9:	e9 67 f2 ff ff       	jmp    220815 <getLineNumberInfo+0x1105>
  2215ae:	48 8d 41 ea          	lea    rax,[rcx-0x16]
  2215b2:	48 83 f8 35          	cmp    rax,0x35
  2215b6:	77 10                	ja     2215c8 <getLineNumberInfo+0x1eb8>
  2215b8:	48 ba 81 00 00 00 00 	movabs rdx,0x20000000000081
  2215bf:	00 20 00 
  2215c2:	48 0f a3 c2          	bt     rdx,rax
  2215c6:	72 0a                	jb     2215d2 <getLineNumberInfo+0x1ec2>
  2215c8:	48 83 f9 06          	cmp    rcx,0x6
  2215cc:	0f 85 d2 00 00 00    	jne    2216a4 <getLineNumberInfo+0x1f94>
  2215d2:	66 b8 21 00          	mov    ax,0x21
  2215d6:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                        try in_file.seekForward(len_bytes);
  2215da:	66 89 01             	mov    WORD PTR [rcx],ax
  2215dd:	c5 fc 10 84 24 52 04 	vmovups ymm0,YMMWORD PTR [rsp+0x452]
  2215e4:	00 00 
  2215e6:	c5 fc 10 8c 24 60 04 	vmovups ymm1,YMMWORD PTR [rsp+0x460]
  2215ed:	00 00 
  2215ef:	e9 48 e5 ff ff       	jmp    21fb3c <getLineNumberInfo+0x42c>
  2215f4:	66 b8 1f 00          	mov    ax,0x1f
  2215f8:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                        const arg = try in_stream.readInt(st.elf.endian, u16);
  2215fc:	66 89 01             	mov    WORD PTR [rcx],ax
  2215ff:	c5 fc 10 84 24 3e 03 	vmovups ymm0,YMMWORD PTR [rsp+0x33e]
  221606:	00 00 
  221608:	c5 fc 10 8c 24 4c 03 	vmovups ymm1,YMMWORD PTR [rsp+0x34c]
  22160f:	00 00 
  221611:	e9 26 e5 ff ff       	jmp    21fb3c <getLineNumberInfo+0x42c>
  221616:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                        const file_name = try st.readString();
  22161a:	66 89 01             	mov    WORD PTR [rcx],ax
  22161d:	c5 fc 10 84 24 66 05 	vmovups ymm0,YMMWORD PTR [rsp+0x566]
  221624:	00 00 
  221626:	c5 fc 10 8c 24 74 05 	vmovups ymm1,YMMWORD PTR [rsp+0x574]
  22162d:	00 00 
  22162f:	e9 08 e5 ff ff       	jmp    21fb3c <getLineNumberInfo+0x42c>
  221634:	48 8d 41 ea          	lea    rax,[rcx-0x16]
  221638:	48 83 f8 35          	cmp    rax,0x35
  22163c:	77 10                	ja     22164e <getLineNumberInfo+0x1f3e>
  22163e:	48 ba 81 00 00 00 00 	movabs rdx,0x20000000000081
  221645:	00 20 00 
  221648:	48 0f a3 c2          	bt     rdx,rax
  22164c:	72 06                	jb     221654 <getLineNumberInfo+0x1f44>
  22164e:	48 83 f9 06          	cmp    rcx,0x6
  221652:	75 59                	jne    2216ad <getLineNumberInfo+0x1f9d>
  221654:	66 b8 21 00          	mov    ax,0x21
  221658:	eb 57                	jmp    2216b1 <getLineNumberInfo+0x1fa1>
  22165a:	66 b8 1f 00          	mov    ax,0x1f
  22165e:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                        const addr = try in_stream.readInt(st.elf.endian, usize);
  221662:	66 89 01             	mov    WORD PTR [rcx],ax
  221665:	c5 fe 6f 84 24 94 05 	vmovdqu ymm0,YMMWORD PTR [rsp+0x594]
  22166c:	00 00 
  22166e:	c5 fc 10 8c 24 a2 05 	vmovups ymm1,YMMWORD PTR [rsp+0x5a2]
  221675:	00 00 
  221677:	e9 c0 e4 ff ff       	jmp    21fb3c <getLineNumberInfo+0x42c>
  22167c:	66 b8 1f 00          	mov    ax,0x1f
  221680:	eb 04                	jmp    221686 <getLineNumberInfo+0x1f76>
  221682:	66 b8 23 00          	mov    ax,0x23
  221686:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                        const len_bytes = try readULeb128(in_stream);
  22168a:	66 89 01             	mov    WORD PTR [rcx],ax
  22168d:	c5 fc 10 84 24 dc 04 	vmovups ymm0,YMMWORD PTR [rsp+0x4dc]
  221694:	00 00 
  221696:	c5 fc 10 8c 24 ea 04 	vmovups ymm1,YMMWORD PTR [rsp+0x4ea]
  22169d:	00 00 
  22169f:	e9 98 e4 ff ff       	jmp    21fb3c <getLineNumberInfo+0x42c>
  2216a4:	66 b8 03 00          	mov    ax,0x3
  2216a8:	e9 29 ff ff ff       	jmp    2215d6 <getLineNumberInfo+0x1ec6>
  2216ad:	66 b8 03 00          	mov    ax,0x3
  2216b1:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                        try in_file.seekForward(fwd_amt);
  2216b5:	66 89 01             	mov    WORD PTR [rcx],ax
  2216b8:	c5 fc 10 84 24 f0 05 	vmovups ymm0,YMMWORD PTR [rsp+0x5f0]
  2216bf:	00 00 
  2216c1:	c5 fc 10 8c 24 fe 05 	vmovups ymm1,YMMWORD PTR [rsp+0x5fe]
  2216c8:	00 00 
  2216ca:	e9 6d e4 ff ff       	jmp    21fb3c <getLineNumberInfo+0x42c>
            @panic("assertion failure");
  2216cf:	e8 0c 2f ff ff       	call   2145e0 <panic>
  2216d4:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                        try file_entries.append(FileEntry{
  2216d8:	66 89 01             	mov    WORD PTR [rcx],ax
  2216db:	c5 fc 10 84 24 ae 04 	vmovups ymm0,YMMWORD PTR [rsp+0x4ae]
  2216e2:	00 00 
  2216e4:	c5 fc 10 8c 24 bc 04 	vmovups ymm1,YMMWORD PTR [rsp+0x4bc]
  2216eb:	00 00 
  2216ed:	e9 4a e4 ff ff       	jmp    21fb3c <getLineNumberInfo+0x42c>
  2216f2:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  2216f9:	1f 84 00 00 00 00 00 

0000000000221700 <printLineFromFile>:
fn printLineFromFile(out_stream: var, line_info: *const LineInfo) !void {
  221700:	55                   	push   rbp
  221701:	41 57                	push   r15
  221703:	41 56                	push   r14
  221705:	41 55                	push   r13
  221707:	41 54                	push   r12
  221709:	53                   	push   rbx
  22170a:	48 81 ec 48 30 00 00 	sub    rsp,0x3048
  221711:	48 89 f5             	mov    rbp,rsi
  221714:	48 89 7c 24 38       	mov    QWORD PTR [rsp+0x38],rdi
    var path_with_null: [posix.PATH_MAX]u8 = undefined;
  221719:	48 8d 35 68 6d fe ff 	lea    rsi,[rip+0xfffffffffffe6d68]        # 208488 <__unnamed_90>
  221720:	48 8d 7c 24 48       	lea    rdi,[rsp+0x48]
  221725:	ba 00 10 00 00       	mov    edx,0x1000
  22172a:	e8 b1 3f 00 00       	call   2256e0 <memcpy>
    if (file_path.len >= posix.PATH_MAX) return error.NameTooLong;
  22172f:	48 8b 5d 18          	mov    rbx,QWORD PTR [rbp+0x18]
  221733:	48 81 fb ff 0f 00 00 	cmp    rbx,0xfff
  22173a:	76 06                	jbe    221742 <printLineFromFile+0x42>
  22173c:	66 bd 16 00          	mov    bp,0x16
  221740:	eb 53                	jmp    221795 <printLineFromFile+0x95>
    for (source) |s, i|
  221742:	48 85 db             	test   rbx,rbx
  221745:	74 11                	je     221758 <printLineFromFile+0x58>
  221747:	48 8b 75 10          	mov    rsi,QWORD PTR [rbp+0x10]
  22174b:	48 8d 7c 24 48       	lea    rdi,[rsp+0x48]
        dest[i] = s;
  221750:	48 89 da             	mov    rdx,rbx
  221753:	e8 88 3f 00 00       	call   2256e0 <memcpy>
  221758:	48 89 6c 24 10       	mov    QWORD PTR [rsp+0x10],rbp
    path_with_null[file_path.len] = 0;
  22175d:	c6 44 1c 48 00       	mov    BYTE PTR [rsp+rbx*1+0x48],0x0
  221762:	48 8d 9c 24 48 10 00 	lea    rbx,[rsp+0x1048]
  221769:	00 
  22176a:	48 8d 74 24 48       	lea    rsi,[rsp+0x48]
    return path_with_null;
  22176f:	ba 00 10 00 00       	mov    edx,0x1000
  221774:	48 89 df             	mov    rdi,rbx
  221777:	e8 64 3f 00 00       	call   2256e0 <memcpy>
  22177c:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
            return openReadC(&path_c);
  221781:	48 89 de             	mov    rsi,rbx
  221784:	e8 87 a1 ff ff       	call   21b910 <File_openReadC>
  221789:	48 8b 5c 24 40       	mov    rbx,QWORD PTR [rsp+0x40]
  22178e:	89 dd                	mov    ebp,ebx
    var f = try os.File.openRead(line_info.file_name);
  221790:	66 85 db             	test   bx,bx
  221793:	74 14                	je     2217a9 <printLineFromFile+0xa9>
  221795:	89 e8                	mov    eax,ebp
  221797:	48 81 c4 48 30 00 00 	add    rsp,0x3048
  22179e:	5b                   	pop    rbx
  22179f:	41 5c                	pop    r12
  2217a1:	41 5d                	pop    r13
  2217a3:	41 5e                	pop    r14
  2217a5:	41 5f                	pop    r15
  2217a7:	5d                   	pop    rbp
  2217a8:	c3                   	ret    
  2217a9:	48 89 d8             	mov    rax,rbx
  2217ac:	48 c1 e8 20          	shr    rax,0x20
  2217b0:	89 44 24 08          	mov    DWORD PTR [rsp+0x8],eax
    var buf: [os.page_size]u8 = undefined;
  2217b4:	48 8d 35 cd 6c fe ff 	lea    rsi,[rip+0xfffffffffffe6ccd]        # 208488 <__unnamed_90>
  2217bb:	48 8d ac 24 48 20 00 	lea    rbp,[rsp+0x2048]
  2217c2:	00 
  2217c3:	ba 00 10 00 00       	mov    edx,0x1000
  2217c8:	48 89 ef             	mov    rdi,rbp
  2217cb:	e8 10 3f 00 00       	call   2256e0 <memcpy>
        const amt_read = try f.read(buf[0..]);
  2217d0:	48 89 6c 24 28       	mov    QWORD PTR [rsp+0x28],rbp
  2217d5:	48 c7 44 24 30 00 10 	mov    QWORD PTR [rsp+0x30],0x1000
  2217dc:	00 00 
  2217de:	48 8d 7c 24 18       	lea    rdi,[rsp+0x18]
  2217e3:	48 8d 74 24 08       	lea    rsi,[rsp+0x8]
  2217e8:	48 8d 54 24 28       	lea    rdx,[rsp+0x28]
  2217ed:	e8 1e a3 ff ff       	call   21bb10 <File_read>
  2217f2:	66 83 7c 24 18 00    	cmp    WORD PTR [rsp+0x18],0x0
  2217f8:	48 8b 6c 24 10       	mov    rbp,QWORD PTR [rsp+0x10]
  2217fd:	74 4e                	je     22184d <printLineFromFile+0x14d>
  2217ff:	48 c1 fb 20          	sar    rbx,0x20
  221803:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  22180a:	84 00 00 00 00 00 
    return asm volatile ("syscall"
  221810:	b8 03 00 00 00       	mov    eax,0x3
  221815:	48 89 df             	mov    rdi,rbx
  221818:	0f 05                	syscall 
            switch (err) {
  22181a:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  22181e:	74 f0                	je     221810 <printLineFromFile+0x110>
            const first = list.first orelse return null;
  221820:	48 8b 05 01 48 02 00 	mov    rax,QWORD PTR [rip+0x24801]        # 246028 <emfile_promise_queue>
  221827:	48 85 c0             	test   rax,rax
  22182a:	0f 84 05 02 00 00    	je     221a35 <printLineFromFile+0x335>
            if (node.prev) |prev_node| {
  221830:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  221833:	48 85 c9             	test   rcx,rcx
  221836:	0f 84 91 01 00 00    	je     2219cd <printLineFromFile+0x2cd>
                prev_node.next = node.next;
  22183c:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  221840:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  221844:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  221848:	e9 8b 01 00 00       	jmp    2219d8 <printLineFromFile+0x2d8>
  22184d:	41 bd 01 00 00 00    	mov    r13d,0x1
  221853:	4c 8b 64 24 20       	mov    r12,QWORD PTR [rsp+0x20]
        for (slice) |byte| {
  221858:	4d 85 e4             	test   r12,r12
  22185b:	0f 84 bb 02 00 00    	je     221b1c <printLineFromFile+0x41c>
  221861:	45 31 ff             	xor    r15d,r15d
  221864:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  22186b:	00 00 00 00 00 
  221870:	46 0f b6 b4 3c 48 20 	movzx  r14d,BYTE PTR [rsp+r15*1+0x2048]
  221877:	00 00 
            if (line == line_info.line) {
  221879:	4c 3b 6d 00          	cmp    r13,QWORD PTR [rbp+0x0]
  22187d:	75 51                	jne    2218d0 <printLineFromFile+0x1d0>
  22187f:	44 88 b4 24 48 10 00 	mov    BYTE PTR [rsp+0x1048],r14b
  221886:	00 
            const slice = (*[1]u8)(&byte)[0..];
  221887:	48 8d 84 24 48 10 00 	lea    rax,[rsp+0x1048]
  22188e:	00 
  22188f:	48 89 44 24 48       	mov    QWORD PTR [rsp+0x48],rax
  221894:	48 c7 44 24 50 01 00 	mov    QWORD PTR [rsp+0x50],0x1
  22189b:	00 00 
  22189d:	48 8b 7c 24 38       	mov    rdi,QWORD PTR [rsp+0x38]
            return self.writeFn(self, slice);
  2218a2:	48 8d 74 24 48       	lea    rsi,[rsp+0x48]
  2218a7:	ff 17                	call   QWORD PTR [rdi]
  2218a9:	89 c5                	mov    ebp,eax
                try out_stream.writeByte(byte);
  2218ab:	66 85 ed             	test   bp,bp
  2218ae:	75 7d                	jne    22192d <printLineFromFile+0x22d>
                if (byte == '\n') {
  2218b0:	41 80 fe 0a          	cmp    r14b,0xa
  2218b4:	48 8b 6c 24 10       	mov    rbp,QWORD PTR [rsp+0x10]
  2218b9:	0f 84 be 00 00 00    	je     22197d <printLineFromFile+0x27d>
        for (slice) |byte| {
  2218bf:	49 83 c7 01          	add    r15,0x1
  2218c3:	4d 39 e7             	cmp    r15,r12
  2218c6:	72 a8                	jb     221870 <printLineFromFile+0x170>
  2218c8:	eb 1b                	jmp    2218e5 <printLineFromFile+0x1e5>
  2218ca:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
            if (byte == '\n') {
  2218d0:	31 c0                	xor    eax,eax
  2218d2:	41 80 fe 0a          	cmp    r14b,0xa
  2218d6:	0f 94 c0             	sete   al
  2218d9:	49 01 c5             	add    r13,rax
        for (slice) |byte| {
  2218dc:	49 83 c7 01          	add    r15,0x1
  2218e0:	4d 39 e7             	cmp    r15,r12
  2218e3:	72 8b                	jb     221870 <printLineFromFile+0x170>
        if (amt_read < buf.len) return error.EndOfFile;
  2218e5:	49 81 fc ff 0f 00 00 	cmp    r12,0xfff
  2218ec:	48 8d 84 24 48 20 00 	lea    rax,[rsp+0x2048]
  2218f3:	00 
  2218f4:	0f 86 22 02 00 00    	jbe    221b1c <printLineFromFile+0x41c>
        const amt_read = try f.read(buf[0..]);
  2218fa:	48 89 44 24 28       	mov    QWORD PTR [rsp+0x28],rax
  2218ff:	48 c7 44 24 30 00 10 	mov    QWORD PTR [rsp+0x30],0x1000
  221906:	00 00 
  221908:	48 8d 7c 24 18       	lea    rdi,[rsp+0x18]
  22190d:	48 8d 74 24 08       	lea    rsi,[rsp+0x8]
  221912:	48 8d 54 24 28       	lea    rdx,[rsp+0x28]
  221917:	e8 f4 a1 ff ff       	call   21bb10 <File_read>
  22191c:	66 83 7c 24 18 00    	cmp    WORD PTR [rsp+0x18],0x0
  221922:	0f 84 2b ff ff ff    	je     221853 <printLineFromFile+0x153>
  221928:	e9 d2 fe ff ff       	jmp    2217ff <printLineFromFile+0xff>
  22192d:	48 c1 fb 20          	sar    rbx,0x20
  221931:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  221938:	0f 1f 84 00 00 00 00 
  22193f:	00 
  221940:	b8 03 00 00 00       	mov    eax,0x3
  221945:	48 89 df             	mov    rdi,rbx
  221948:	0f 05                	syscall 
  22194a:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  22194e:	74 f0                	je     221940 <printLineFromFile+0x240>
            const first = list.first orelse return null;
  221950:	48 8b 05 d1 46 02 00 	mov    rax,QWORD PTR [rip+0x246d1]        # 246028 <emfile_promise_queue>
  221957:	48 85 c0             	test   rax,rax
  22195a:	0f 84 35 fe ff ff    	je     221795 <printLineFromFile+0x95>
            if (node.prev) |prev_node| {
  221960:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  221963:	48 85 c9             	test   rcx,rcx
  221966:	0f 84 d3 00 00 00    	je     221a3f <printLineFromFile+0x33f>
                prev_node.next = node.next;
  22196c:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  221970:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  221974:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  221978:	e9 cd 00 00 00       	jmp    221a4a <printLineFromFile+0x34a>
  22197d:	48 c1 fb 20          	sar    rbx,0x20
  221981:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  221988:	0f 1f 84 00 00 00 00 
  22198f:	00 
  221990:	b8 03 00 00 00       	mov    eax,0x3
  221995:	48 89 df             	mov    rdi,rbx
  221998:	0f 05                	syscall 
  22199a:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  22199e:	74 f0                	je     221990 <printLineFromFile+0x290>
            const first = list.first orelse return null;
  2219a0:	48 8b 05 81 46 02 00 	mov    rax,QWORD PTR [rip+0x24681]        # 246028 <emfile_promise_queue>
  2219a7:	48 85 c0             	test   rax,rax
  2219aa:	0f 84 65 01 00 00    	je     221b15 <printLineFromFile+0x415>
            if (node.prev) |prev_node| {
  2219b0:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  2219b3:	48 85 c9             	test   rcx,rcx
  2219b6:	0f 84 f2 00 00 00    	je     221aae <printLineFromFile+0x3ae>
                prev_node.next = node.next;
  2219bc:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  2219c0:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  2219c4:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  2219c8:	e9 ec 00 00 00       	jmp    221ab9 <printLineFromFile+0x3b9>
                list.first = node.next;
  2219cd:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  2219d1:	48 89 0d 50 46 02 00 	mov    QWORD PTR [rip+0x24650],rcx        # 246028 <emfile_promise_queue>
            if (node.next) |next_node| {
  2219d8:	48 85 c9             	test   rcx,rcx
  2219db:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  2219de:	48 8d 35 4b 46 02 00 	lea    rsi,[rip+0x2464b]        # 246030 <emfile_promise_queue+0x8>
  2219e5:	48 0f 45 f1          	cmovne rsi,rcx
  2219e9:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  2219ec:	48 83 05 44 46 02 00 	add    QWORD PTR [rip+0x24644],0xffffffffffffffff        # 246038 <emfile_promise_queue+0x10>
  2219f3:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  2219f4:	74 1e                	je     221a14 <printLineFromFile+0x314>
  2219f6:	48 83 3d 2a 46 02 00 	cmp    QWORD PTR [rip+0x2462a],0x0        # 246028 <emfile_promise_queue>
  2219fd:	00 
  2219fe:	0f 84 b1 01 00 00    	je     221bb5 <printLineFromFile+0x4b5>
  221a04:	48 8b 0d 25 46 02 00 	mov    rcx,QWORD PTR [rip+0x24625]        # 246030 <emfile_promise_queue+0x8>
  221a0b:	48 85 c9             	test   rcx,rcx
  221a0e:	0f 84 a1 01 00 00    	je     221bb5 <printLineFromFile+0x4b5>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  221a14:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  221a18:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  221a1c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  221a20:	48 89 c1             	mov    rcx,rax
  221a23:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  221a27:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  221a2d:	75 f1                	jne    221a20 <printLineFromFile+0x320>
  221a2f:	a8 01                	test   al,0x1
  221a31:	75 02                	jne    221a35 <printLineFromFile+0x335>
  221a33:	ff 17                	call   QWORD PTR [rdi]
  221a35:	0f b7 44 24 18       	movzx  eax,WORD PTR [rsp+0x18]
  221a3a:	e9 58 fd ff ff       	jmp    221797 <printLineFromFile+0x97>
                list.first = node.next;
  221a3f:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  221a43:	48 89 0d de 45 02 00 	mov    QWORD PTR [rip+0x245de],rcx        # 246028 <emfile_promise_queue>
            if (node.next) |next_node| {
  221a4a:	48 85 c9             	test   rcx,rcx
  221a4d:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  221a50:	48 8d 35 d9 45 02 00 	lea    rsi,[rip+0x245d9]        # 246030 <emfile_promise_queue+0x8>
  221a57:	48 0f 45 f1          	cmovne rsi,rcx
  221a5b:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  221a5e:	48 83 05 d2 45 02 00 	add    QWORD PTR [rip+0x245d2],0xffffffffffffffff        # 246038 <emfile_promise_queue+0x10>
  221a65:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  221a66:	74 1e                	je     221a86 <printLineFromFile+0x386>
  221a68:	48 83 3d b8 45 02 00 	cmp    QWORD PTR [rip+0x245b8],0x0        # 246028 <emfile_promise_queue>
  221a6f:	00 
  221a70:	0f 84 3f 01 00 00    	je     221bb5 <printLineFromFile+0x4b5>
  221a76:	48 8b 0d b3 45 02 00 	mov    rcx,QWORD PTR [rip+0x245b3]        # 246030 <emfile_promise_queue+0x8>
  221a7d:	48 85 c9             	test   rcx,rcx
  221a80:	0f 84 2f 01 00 00    	je     221bb5 <printLineFromFile+0x4b5>
  221a86:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  221a8a:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  221a8e:	66 90                	xchg   ax,ax
  221a90:	48 89 c1             	mov    rcx,rax
  221a93:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  221a97:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  221a9d:	75 f1                	jne    221a90 <printLineFromFile+0x390>
  221a9f:	a8 01                	test   al,0x1
  221aa1:	0f 85 ee fc ff ff    	jne    221795 <printLineFromFile+0x95>
  221aa7:	ff 17                	call   QWORD PTR [rdi]
  221aa9:	e9 e7 fc ff ff       	jmp    221795 <printLineFromFile+0x95>
                list.first = node.next;
  221aae:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  221ab2:	48 89 0d 6f 45 02 00 	mov    QWORD PTR [rip+0x2456f],rcx        # 246028 <emfile_promise_queue>
            if (node.next) |next_node| {
  221ab9:	48 85 c9             	test   rcx,rcx
  221abc:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  221abf:	48 8d 35 6a 45 02 00 	lea    rsi,[rip+0x2456a]        # 246030 <emfile_promise_queue+0x8>
  221ac6:	48 0f 45 f1          	cmovne rsi,rcx
  221aca:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  221acd:	48 83 05 63 45 02 00 	add    QWORD PTR [rip+0x24563],0xffffffffffffffff        # 246038 <emfile_promise_queue+0x10>
  221ad4:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  221ad5:	74 1e                	je     221af5 <printLineFromFile+0x3f5>
  221ad7:	48 83 3d 49 45 02 00 	cmp    QWORD PTR [rip+0x24549],0x0        # 246028 <emfile_promise_queue>
  221ade:	00 
  221adf:	0f 84 d0 00 00 00    	je     221bb5 <printLineFromFile+0x4b5>
  221ae5:	48 8b 0d 44 45 02 00 	mov    rcx,QWORD PTR [rip+0x24544]        # 246030 <emfile_promise_queue+0x8>
  221aec:	48 85 c9             	test   rcx,rcx
  221aef:	0f 84 c0 00 00 00    	je     221bb5 <printLineFromFile+0x4b5>
  221af5:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  221af9:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  221afd:	0f 1f 00             	nop    DWORD PTR [rax]
  221b00:	48 89 c1             	mov    rcx,rax
  221b03:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  221b07:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  221b0d:	75 f1                	jne    221b00 <printLineFromFile+0x400>
  221b0f:	a8 01                	test   al,0x1
  221b11:	75 02                	jne    221b15 <printLineFromFile+0x415>
  221b13:	ff 17                	call   QWORD PTR [rdi]
  221b15:	31 ed                	xor    ebp,ebp
  221b17:	e9 79 fc ff ff       	jmp    221795 <printLineFromFile+0x95>
  221b1c:	48 c1 fb 20          	sar    rbx,0x20
  221b20:	b8 03 00 00 00       	mov    eax,0x3
  221b25:	48 89 df             	mov    rdi,rbx
  221b28:	0f 05                	syscall 
            switch (err) {
  221b2a:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  221b2e:	74 f0                	je     221b20 <printLineFromFile+0x420>
            const first = list.first orelse return null;
  221b30:	48 8b 05 f1 44 02 00 	mov    rax,QWORD PTR [rip+0x244f1]        # 246028 <emfile_promise_queue>
  221b37:	66 bd 24 00          	mov    bp,0x24
  221b3b:	48 85 c0             	test   rax,rax
  221b3e:	0f 84 51 fc ff ff    	je     221795 <printLineFromFile+0x95>
            if (node.prev) |prev_node| {
  221b44:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  221b47:	48 85 c9             	test   rcx,rcx
  221b4a:	74 0e                	je     221b5a <printLineFromFile+0x45a>
                prev_node.next = node.next;
  221b4c:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  221b50:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  221b54:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  221b58:	eb 0b                	jmp    221b65 <printLineFromFile+0x465>
                list.first = node.next;
  221b5a:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  221b5e:	48 89 0d c3 44 02 00 	mov    QWORD PTR [rip+0x244c3],rcx        # 246028 <emfile_promise_queue>
            if (node.next) |next_node| {
  221b65:	48 85 c9             	test   rcx,rcx
  221b68:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  221b6b:	48 8d 35 be 44 02 00 	lea    rsi,[rip+0x244be]        # 246030 <emfile_promise_queue+0x8>
  221b72:	48 0f 45 f1          	cmovne rsi,rcx
  221b76:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  221b79:	48 83 05 b7 44 02 00 	add    QWORD PTR [rip+0x244b7],0xffffffffffffffff        # 246038 <emfile_promise_queue+0x10>
  221b80:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  221b81:	74 16                	je     221b99 <printLineFromFile+0x499>
  221b83:	48 83 3d 9d 44 02 00 	cmp    QWORD PTR [rip+0x2449d],0x0        # 246028 <emfile_promise_queue>
  221b8a:	00 
  221b8b:	74 28                	je     221bb5 <printLineFromFile+0x4b5>
  221b8d:	48 8b 0d 9c 44 02 00 	mov    rcx,QWORD PTR [rip+0x2449c]        # 246030 <emfile_promise_queue+0x8>
  221b94:	48 85 c9             	test   rcx,rcx
  221b97:	74 1c                	je     221bb5 <printLineFromFile+0x4b5>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  221b99:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  221b9d:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  221ba1:	48 89 c1             	mov    rcx,rax
  221ba4:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  221ba8:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  221bae:	75 f1                	jne    221ba1 <printLineFromFile+0x4a1>
  221bb0:	e9 ea fe ff ff       	jmp    221a9f <printLineFromFile+0x39f>
            @panic("assertion failure");
  221bb5:	e8 26 2a ff ff       	call   2145e0 <panic>
  221bba:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000221bc0 <Allocator_alignedRealloc.86>:
    pub fn alignedRealloc(self: *Allocator, comptime T: type, comptime alignment: u29, old_mem: []align(alignment) T, n: usize) ![]align(alignment) T {
  221bc0:	41 56                	push   r14
  221bc2:	53                   	push   rbx
  221bc3:	48 83 ec 78          	sub    rsp,0x78
  221bc7:	49 89 ce             	mov    r14,rcx
  221bca:	48 89 fb             	mov    rbx,rdi
        if (old_mem.len == 0) {
  221bcd:	48 8b 42 08          	mov    rax,QWORD PTR [rdx+0x8]
  221bd1:	48 85 c0             	test   rax,rax
  221bd4:	74 59                	je     221c2f <Allocator_alignedRealloc.86+0x6f>
        if (n == 0) {
  221bd6:	4d 85 f6             	test   r14,r14
  221bd9:	0f 84 92 00 00 00    	je     221c71 <Allocator_alignedRealloc.86+0xb1>
        const old_byte_slice = @sliceToBytes(old_mem);
  221bdf:	48 8b 0a             	mov    rcx,QWORD PTR [rdx]
  221be2:	48 89 4c 24 38       	mov    QWORD PTR [rsp+0x38],rcx
  221be7:	48 89 44 24 40       	mov    QWORD PTR [rsp+0x40],rax
  221bec:	48 8d 7c 24 48       	lea    rdi,[rsp+0x48]
  221bf1:	48 8d 54 24 38       	lea    rdx,[rsp+0x38]
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  221bf6:	41 b8 01 00 00 00    	mov    r8d,0x1
  221bfc:	4c 89 f1             	mov    rcx,r14
  221bff:	ff 56 08             	call   QWORD PTR [rsi+0x8]
  221c02:	0f b7 44 24 48       	movzx  eax,WORD PTR [rsp+0x48]
  221c07:	66 85 c0             	test   ax,ax
  221c0a:	0f 84 9e 00 00 00    	je     221cae <Allocator_alignedRealloc.86+0xee>
  221c10:	66 89 03             	mov    WORD PTR [rbx],ax
  221c13:	48 8b 44 24 70       	mov    rax,QWORD PTR [rsp+0x70]
  221c18:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  221c1c:	c5 f8 10 44 24 62    	vmovups xmm0,XMMWORD PTR [rsp+0x62]
  221c22:	c5 f8 11 43 02       	vmovups XMMWORD PTR [rbx+0x2],xmm0
  221c27:	48 83 c4 78          	add    rsp,0x78
  221c2b:	5b                   	pop    rbx
  221c2c:	41 5e                	pop    r14
  221c2e:	c3                   	ret    
        if (n == 0) {
  221c2f:	4d 85 f6             	test   r14,r14
  221c32:	0f 84 a1 00 00 00    	je     221cd9 <Allocator_alignedRealloc.86+0x119>
  221c38:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  221c3d:	b9 01 00 00 00       	mov    ecx,0x1
  221c42:	4c 89 f2             	mov    rdx,r14
  221c45:	ff 16                	call   QWORD PTR [rsi]
  221c47:	0f b7 4c 24 20       	movzx  ecx,WORD PTR [rsp+0x20]
  221c4c:	66 85 c9             	test   cx,cx
  221c4f:	0f 84 a6 00 00 00    	je     221cfb <Allocator_alignedRealloc.86+0x13b>
  221c55:	0f b7 44 24 1e       	movzx  eax,WORD PTR [rsp+0x1e]
  221c5a:	66 89 44 24 0c       	mov    WORD PTR [rsp+0xc],ax
  221c5f:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  221c64:	8b 54 24 1a          	mov    edx,DWORD PTR [rsp+0x1a]
  221c68:	89 54 24 08          	mov    DWORD PTR [rsp+0x8],edx
  221c6c:	e9 af 00 00 00       	jmp    221d20 <Allocator_alignedRealloc.86+0x160>
        const bytes = @sliceToBytes(memory);
  221c71:	48 8b 0a             	mov    rcx,QWORD PTR [rdx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  221c74:	48 8b 56 10          	mov    rdx,QWORD PTR [rsi+0x10]
  221c78:	48 89 4c 24 20       	mov    QWORD PTR [rsp+0x20],rcx
  221c7d:	48 89 44 24 28       	mov    QWORD PTR [rsp+0x28],rax
  221c82:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  221c87:	48 89 f7             	mov    rdi,rsi
  221c8a:	48 89 c6             	mov    rsi,rax
  221c8d:	ff d2                	call   rdx
            return ([*]align(alignment) T)(undefined)[0..0];
  221c8f:	48 8b 05 c2 65 fe ff 	mov    rax,QWORD PTR [rip+0xfffffffffffe65c2]        # 208258 <__unnamed_91+0x10>
  221c96:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  221c9a:	c5 f8 10 05 a6 65 fe 	vmovups xmm0,XMMWORD PTR [rip+0xfffffffffffe65a6]        # 208248 <__unnamed_91>
  221ca1:	ff 
  221ca2:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  221ca6:	48 83 c4 78          	add    rsp,0x78
  221caa:	5b                   	pop    rbx
  221cab:	41 5e                	pop    r14
  221cad:	c3                   	ret    
        assert(byte_slice.len == byte_count);
  221cae:	4c 39 74 24 58       	cmp    QWORD PTR [rsp+0x58],r14
    if (!ok) {
  221cb3:	0f 85 87 00 00 00    	jne    221d40 <Allocator_alignedRealloc.86+0x180>
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  221cb9:	66 c7 03 00 00       	mov    WORD PTR [rbx],0x0
  221cbe:	0f b7 44 24 12       	movzx  eax,WORD PTR [rsp+0x12]
  221cc3:	66 89 43 06          	mov    WORD PTR [rbx+0x6],ax
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  221cc7:	48 8b 44 24 50       	mov    rax,QWORD PTR [rsp+0x50]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  221ccc:	8b 4c 24 0e          	mov    ecx,DWORD PTR [rsp+0xe]
  221cd0:	89 4b 02             	mov    DWORD PTR [rbx+0x2],ecx
  221cd3:	48 89 43 08          	mov    QWORD PTR [rbx+0x8],rax
  221cd7:	eb 5b                	jmp    221d34 <Allocator_alignedRealloc.86+0x174>
  221cd9:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
            return ([*]align(alignment) T)(undefined)[0..0];
  221cde:	0f b7 0d 69 65 fe ff 	movzx  ecx,WORD PTR [rip+0xfffffffffffe6569]        # 20824e <__unnamed_91+0x6>
  221ce5:	66 89 4c 24 0c       	mov    WORD PTR [rsp+0xc],cx
  221cea:	8b 0d 5a 65 fe ff    	mov    ecx,DWORD PTR [rip+0xfffffffffffe655a]        # 20824a <__unnamed_91+0x2>
  221cf0:	89 4c 24 08          	mov    DWORD PTR [rsp+0x8],ecx
  221cf4:	31 c9                	xor    ecx,ecx
  221cf6:	45 31 f6             	xor    r14d,r14d
  221cf9:	eb 25                	jmp    221d20 <Allocator_alignedRealloc.86+0x160>
        assert(byte_slice.len == byte_count);
  221cfb:	4c 39 74 24 30       	cmp    QWORD PTR [rsp+0x30],r14
  221d00:	75 3e                	jne    221d40 <Allocator_alignedRealloc.86+0x180>
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  221d02:	48 8b 54 24 28       	mov    rdx,QWORD PTR [rsp+0x28]
  221d07:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  221d0c:	8b 4c 24 14          	mov    ecx,DWORD PTR [rsp+0x14]
  221d10:	89 4c 24 08          	mov    DWORD PTR [rsp+0x8],ecx
  221d14:	0f b7 4c 24 18       	movzx  ecx,WORD PTR [rsp+0x18]
  221d19:	66 89 4c 24 0c       	mov    WORD PTR [rsp+0xc],cx
  221d1e:	31 c9                	xor    ecx,ecx
            return self.alignedAlloc(T, alignment, n);
  221d20:	66 89 0b             	mov    WORD PTR [rbx],cx
  221d23:	0f b7 48 04          	movzx  ecx,WORD PTR [rax+0x4]
  221d27:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  221d2b:	8b 00                	mov    eax,DWORD PTR [rax]
  221d2d:	89 43 02             	mov    DWORD PTR [rbx+0x2],eax
  221d30:	48 89 53 08          	mov    QWORD PTR [rbx+0x8],rdx
  221d34:	4c 89 73 10          	mov    QWORD PTR [rbx+0x10],r14
  221d38:	48 83 c4 78          	add    rsp,0x78
  221d3c:	5b                   	pop    rbx
  221d3d:	41 5e                	pop    r14
  221d3f:	c3                   	ret    
            @panic("assertion failure");
  221d40:	e8 9b 28 ff ff       	call   2145e0 <panic>
  221d45:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  221d4c:	00 00 00 00 

0000000000221d50 <LineNumberProgram_checkLineMatch>:
    pub fn checkLineMatch(self: *LineNumberProgram) !?LineInfo {
  221d50:	41 56                	push   r14
  221d52:	53                   	push   rbx
  221d53:	48 81 ec 98 00 00 00 	sub    rsp,0x98
  221d5a:	48 89 f3             	mov    rbx,rsi
  221d5d:	49 89 fe             	mov    r14,rdi
  221d60:	48 8b 03             	mov    rax,QWORD PTR [rbx]
        if (self.target_address >= self.prev_address and self.target_address < self.address) {
  221d63:	48 8b 4b 28          	mov    rcx,QWORD PTR [rbx+0x28]
  221d67:	48 3b 4b 48          	cmp    rcx,QWORD PTR [rbx+0x48]
  221d6b:	0f 82 b6 00 00 00    	jb     221e27 <LineNumberProgram_checkLineMatch+0xd7>
  221d71:	48 39 c1             	cmp    rcx,rax
  221d74:	0f 83 ad 00 00 00    	jae    221e27 <LineNumberProgram_checkLineMatch+0xd7>
            const file_entry = if (self.prev_file == 0) {
  221d7a:	48 8b 4b 50          	mov    rcx,QWORD PTR [rbx+0x50]
  221d7e:	48 85 c9             	test   rcx,rcx
  221d81:	0f 84 f8 00 00 00    	je     221e7f <LineNumberProgram_checkLineMatch+0x12f>
            } else if (self.prev_file - 1 >= self.file_entries.len) {
  221d87:	48 83 c1 ff          	add    rcx,0xffffffffffffffff
  221d8b:	48 8b 43 40          	mov    rax,QWORD PTR [rbx+0x40]
  221d8f:	48 3b 48 10          	cmp    rcx,QWORD PTR [rax+0x10]
  221d93:	0f 83 ce 00 00 00    	jae    221e67 <LineNumberProgram_checkLineMatch+0x117>
                &self.file_entries.items[self.prev_file - 1];
  221d99:	48 8b 10             	mov    rdx,QWORD PTR [rax]
            const dir_name = if (file_entry.dir_index >= self.include_dirs.len) {
  221d9c:	48 8d 0c 89          	lea    rcx,[rcx+rcx*4]
  221da0:	48 8b 74 ca 10       	mov    rsi,QWORD PTR [rdx+rcx*8+0x10]
  221da5:	48 3b 73 38          	cmp    rsi,QWORD PTR [rbx+0x38]
  221da9:	0f 83 b8 00 00 00    	jae    221e67 <LineNumberProgram_checkLineMatch+0x117>
                self.include_dirs[file_entry.dir_index];
  221daf:	48 8b 7b 30          	mov    rdi,QWORD PTR [rbx+0x30]
  221db3:	48 c1 e6 04          	shl    rsi,0x4
            const dir_name = if (file_entry.dir_index >= self.include_dirs.len) {
  221db7:	c5 f8 10 04 37       	vmovups xmm0,XMMWORD PTR [rdi+rsi*1]
  221dbc:	c5 f8 29 44 24 50    	vmovaps XMMWORD PTR [rsp+0x50],xmm0
            const file_name = try os.path.join(self.file_entries.allocator, dir_name, file_entry.file_name);
  221dc2:	48 8b 70 18          	mov    rsi,QWORD PTR [rax+0x18]
  221dc6:	48 8d 0c ca          	lea    rcx,[rdx+rcx*8]
  221dca:	48 8d 7c 24 18       	lea    rdi,[rsp+0x18]
  221dcf:	48 8d 54 24 50       	lea    rdx,[rsp+0x50]
pub fn joinWindows(allocator: *Allocator, paths: ...) ![]u8 {
    return mem.join(allocator, sep_windows, paths);
}

pub fn joinPosix(allocator: *Allocator, paths: ...) ![]u8 {
    return mem.join(allocator, sep_posix, paths);
  221dd4:	e8 47 06 00 00       	call   222420 <join.97>
  221dd9:	0f b7 44 24 18       	movzx  eax,WORD PTR [rsp+0x18]
  221dde:	c5 f8 10 44 24 1a    	vmovups xmm0,XMMWORD PTR [rsp+0x1a]
  221de4:	c5 f8 29 44 24 30    	vmovaps XMMWORD PTR [rsp+0x30],xmm0
  221dea:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  221def:	48 89 4c 24 3e       	mov    QWORD PTR [rsp+0x3e],rcx
  221df4:	66 85 c0             	test   ax,ax
  221df7:	0f 84 ab 00 00 00    	je     221ea8 <LineNumberProgram_checkLineMatch+0x158>
  221dfd:	66 41 89 06          	mov    WORD PTR [r14],ax
  221e01:	c5 fc 10 44 24 62    	vmovups ymm0,YMMWORD PTR [rsp+0x62]
  221e07:	c5 fc 10 4c 24 78    	vmovups ymm1,YMMWORD PTR [rsp+0x78]
  221e0d:	c4 c1 7c 11 4e 18    	vmovups YMMWORD PTR [r14+0x18],ymm1
  221e13:	c4 c1 7c 11 46 02    	vmovups YMMWORD PTR [r14+0x2],ymm0
  221e19:	48 81 c4 98 00 00 00 	add    rsp,0x98
  221e20:	5b                   	pop    rbx
  221e21:	41 5e                	pop    r14
  221e23:	c5 f8 77             	vzeroupper 
  221e26:	c3                   	ret    
        self.prev_address = self.address;
  221e27:	48 89 43 48          	mov    QWORD PTR [rbx+0x48],rax
        self.prev_file = self.file;
  221e2b:	c5 f8 10 43 08       	vmovups xmm0,XMMWORD PTR [rbx+0x8]
  221e30:	c5 f8 11 43 50       	vmovups XMMWORD PTR [rbx+0x50],xmm0
        self.prev_column = self.column;
  221e35:	48 8b 43 18          	mov    rax,QWORD PTR [rbx+0x18]
  221e39:	48 89 43 60          	mov    QWORD PTR [rbx+0x60],rax
        self.prev_is_stmt = self.is_stmt;
  221e3d:	8a 43 20             	mov    al,BYTE PTR [rbx+0x20]
  221e40:	88 43 68             	mov    BYTE PTR [rbx+0x68],al
        self.prev_basic_block = self.basic_block;
  221e43:	8a 43 21             	mov    al,BYTE PTR [rbx+0x21]
  221e46:	88 43 69             	mov    BYTE PTR [rbx+0x69],al
        self.prev_end_sequence = self.end_sequence;
  221e49:	8a 43 22             	mov    al,BYTE PTR [rbx+0x22]
  221e4c:	88 43 6a             	mov    BYTE PTR [rbx+0x6a],al
        return null;
  221e4f:	c5 fc 10 05 51 65 fe 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffe6551]        # 2083a8 <__unnamed_92+0x18>
  221e56:	ff 
  221e57:	c4 c1 7c 11 46 18    	vmovups YMMWORD PTR [r14+0x18],ymm0
  221e5d:	c5 fc 10 05 2b 65 fe 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffe652b]        # 208390 <__unnamed_92>
  221e64:	ff 
  221e65:	eb 2e                	jmp    221e95 <LineNumberProgram_checkLineMatch+0x145>
  221e67:	c5 fc 10 05 01 65 fe 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffe6501]        # 208370 <__unnamed_93+0x18>
  221e6e:	ff 
  221e6f:	c4 c1 7c 11 46 18    	vmovups YMMWORD PTR [r14+0x18],ymm0
  221e75:	c5 fc 10 05 db 64 fe 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffe64db]        # 208358 <__unnamed_93>
  221e7c:	ff 
  221e7d:	eb 16                	jmp    221e95 <LineNumberProgram_checkLineMatch+0x145>
                return error.MissingDebugInfo;
  221e7f:	c5 fc 10 05 b1 64 fe 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffe64b1]        # 208338 <__unnamed_94+0x18>
  221e86:	ff 
  221e87:	c4 c1 7c 11 46 18    	vmovups YMMWORD PTR [r14+0x18],ymm0
  221e8d:	c5 fc 10 05 8b 64 fe 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffe648b]        # 208320 <__unnamed_94>
  221e94:	ff 
  221e95:	c4 c1 7c 11 06       	vmovups YMMWORD PTR [r14],ymm0
  221e9a:	48 81 c4 98 00 00 00 	add    rsp,0x98
  221ea1:	5b                   	pop    rbx
  221ea2:	41 5e                	pop    r14
  221ea4:	c5 f8 77             	vzeroupper 
  221ea7:	c3                   	ret    
                .allocator = self.file_entries.allocator,
  221ea8:	48 8b 43 40          	mov    rax,QWORD PTR [rbx+0x40]
                .line = if (self.prev_line >= 0) @intCast(usize, self.prev_line) else 0,
  221eac:	48 8b 4b 58          	mov    rcx,QWORD PTR [rbx+0x58]
  221eb0:	48 89 ca             	mov    rdx,rcx
  221eb3:	48 c1 fa 3f          	sar    rdx,0x3f
  221eb7:	c4 e2 e8 f2 c9       	andn   rcx,rdx,rcx
                .column = self.prev_column,
  221ebc:	48 8b 53 60          	mov    rdx,QWORD PTR [rbx+0x60]
                .allocator = self.file_entries.allocator,
  221ec0:	48 8b 40 18          	mov    rax,QWORD PTR [rax+0x18]
            return LineInfo{
  221ec4:	c6 44 24 0a 01       	mov    BYTE PTR [rsp+0xa],0x1
  221ec9:	66 41 c7 06 00 00    	mov    WORD PTR [r14],0x0
  221ecf:	0f b7 74 24 16       	movzx  esi,WORD PTR [rsp+0x16]
  221ed4:	66 41 89 76 06       	mov    WORD PTR [r14+0x6],si
  221ed9:	8b 74 24 12          	mov    esi,DWORD PTR [rsp+0x12]
  221edd:	41 89 76 02          	mov    DWORD PTR [r14+0x2],esi
  221ee1:	49 89 4e 08          	mov    QWORD PTR [r14+0x8],rcx
  221ee5:	49 89 56 10          	mov    QWORD PTR [r14+0x10],rdx
  221ee9:	c5 f8 10 44 24 36    	vmovups xmm0,XMMWORD PTR [rsp+0x36]
  221eef:	c4 c1 78 11 46 18    	vmovups XMMWORD PTR [r14+0x18],xmm0
  221ef5:	49 89 46 28          	mov    QWORD PTR [r14+0x28],rax
  221ef9:	8a 44 24 0a          	mov    al,BYTE PTR [rsp+0xa]
  221efd:	41 88 46 30          	mov    BYTE PTR [r14+0x30],al
  221f01:	8a 44 24 11          	mov    al,BYTE PTR [rsp+0x11]
  221f05:	41 88 46 37          	mov    BYTE PTR [r14+0x37],al
  221f09:	0f b7 44 24 0f       	movzx  eax,WORD PTR [rsp+0xf]
  221f0e:	66 41 89 46 35       	mov    WORD PTR [r14+0x35],ax
  221f13:	8b 44 24 0b          	mov    eax,DWORD PTR [rsp+0xb]
  221f17:	41 89 46 31          	mov    DWORD PTR [r14+0x31],eax
  221f1b:	48 81 c4 98 00 00 00 	add    rsp,0x98
  221f22:	5b                   	pop    rbx
  221f23:	41 5e                	pop    r14
  221f25:	c3                   	ret    
  221f26:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  221f2d:	00 00 00 

0000000000221f30 <Allocator_alignedRealloc.91>:
    pub fn alignedRealloc(self: *Allocator, comptime T: type, comptime alignment: u29, old_mem: []align(alignment) T, n: usize) ![]align(alignment) T {
  221f30:	41 56                	push   r14
  221f32:	53                   	push   rbx
  221f33:	48 81 ec 88 00 00 00 	sub    rsp,0x88
  221f3a:	48 89 fb             	mov    rbx,rdi
        if (old_mem.len == 0) {
  221f3d:	48 8b 42 08          	mov    rax,QWORD PTR [rdx+0x8]
  221f41:	48 85 c0             	test   rax,rax
  221f44:	74 5e                	je     221fa4 <Allocator_alignedRealloc.91+0x74>
        if (n == 0) {
  221f46:	48 85 c9             	test   rcx,rcx
  221f49:	0f 84 a6 00 00 00    	je     221ff5 <Allocator_alignedRealloc.91+0xc5>
        const old_byte_slice = @sliceToBytes(old_mem);
  221f4f:	48 8b 12             	mov    rdx,QWORD PTR [rdx]
  221f52:	48 c1 e0 04          	shl    rax,0x4
  221f56:	48 89 54 24 38       	mov    QWORD PTR [rsp+0x38],rdx
  221f5b:	48 89 44 24 40       	mov    QWORD PTR [rsp+0x40],rax
    return if (@mulWithOverflow(T, a, b, &answer)) error.Overflow else answer;
  221f60:	ba 10 00 00 00       	mov    edx,0x10
  221f65:	48 89 c8             	mov    rax,rcx
  221f68:	48 f7 e2             	mul    rdx
  221f6b:	0f 81 ca 00 00 00    	jno    22203b <Allocator_alignedRealloc.91+0x10b>
  221f71:	48 8d 0d 88 e5 fd ff 	lea    rcx,[rip+0xfffffffffffde588]        # 200500 <__unnamed_52>
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  221f78:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  221f7c:	0f 84 d4 00 00 00    	je     222056 <Allocator_alignedRealloc.91+0x126>
  221f82:	48 8b 05 5f 63 fe ff 	mov    rax,QWORD PTR [rip+0xfffffffffffe635f]        # 2082e8 <__unnamed_95+0x10>
  221f89:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  221f8d:	c5 f8 10 05 43 63 fe 	vmovups xmm0,XMMWORD PTR [rip+0xfffffffffffe6343]        # 2082d8 <__unnamed_95>
  221f94:	ff 
  221f95:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  221f99:	48 81 c4 88 00 00 00 	add    rsp,0x88
  221fa0:	5b                   	pop    rbx
  221fa1:	41 5e                	pop    r14
  221fa3:	c3                   	ret    
        if (n == 0) {
  221fa4:	48 85 c9             	test   rcx,rcx
  221fa7:	0f 84 f6 00 00 00    	je     2220a3 <Allocator_alignedRealloc.91+0x173>
  221fad:	ba 10 00 00 00       	mov    edx,0x10
  221fb2:	48 89 c8             	mov    rax,rcx
  221fb5:	48 f7 e2             	mul    rdx
  221fb8:	0f 81 07 01 00 00    	jno    2220c5 <Allocator_alignedRealloc.91+0x195>
  221fbe:	48 8d 0d 3b e5 fd ff 	lea    rcx,[rip+0xfffffffffffde53b]        # 200500 <__unnamed_52>
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  221fc5:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  221fc9:	0f 84 11 01 00 00    	je     2220e0 <Allocator_alignedRealloc.91+0x1b0>
  221fcf:	0f b7 05 08 63 fe ff 	movzx  eax,WORD PTR [rip+0xfffffffffffe6308]        # 2082de <__unnamed_95+0x6>
  221fd6:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  221fdb:	8b 05 f9 62 fe ff    	mov    eax,DWORD PTR [rip+0xfffffffffffe62f9]        # 2082da <__unnamed_95+0x2>
  221fe1:	89 04 24             	mov    DWORD PTR [rsp],eax
  221fe4:	48 89 e0             	mov    rax,rsp
  221fe7:	66 b9 01 00          	mov    cx,0x1
  221feb:	31 d2                	xor    edx,edx
  221fed:	45 31 f6             	xor    r14d,r14d
  221ff0:	e9 6f 01 00 00       	jmp    222164 <Allocator_alignedRealloc.91+0x234>
        const bytes = @sliceToBytes(memory);
  221ff5:	48 c1 e0 04          	shl    rax,0x4
        if (bytes.len == 0) return;
  221ff9:	74 1e                	je     222019 <Allocator_alignedRealloc.91+0xe9>
        const bytes = @sliceToBytes(memory);
  221ffb:	48 8b 0a             	mov    rcx,QWORD PTR [rdx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  221ffe:	48 8b 56 10          	mov    rdx,QWORD PTR [rsi+0x10]
  222002:	48 89 4c 24 08       	mov    QWORD PTR [rsp+0x8],rcx
  222007:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  22200c:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  222011:	48 89 f7             	mov    rdi,rsi
  222014:	48 89 c6             	mov    rsi,rax
  222017:	ff d2                	call   rdx
            return ([*]align(alignment) T)(undefined)[0..0];
  222019:	48 8b 05 b0 62 fe ff 	mov    rax,QWORD PTR [rip+0xfffffffffffe62b0]        # 2082d0 <__unnamed_96+0x10>
  222020:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  222024:	c5 f8 10 05 94 62 fe 	vmovups xmm0,XMMWORD PTR [rip+0xfffffffffffe6294]        # 2082c0 <__unnamed_96>
  22202b:	ff 
  22202c:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  222030:	48 81 c4 88 00 00 00 	add    rsp,0x88
  222037:	5b                   	pop    rbx
  222038:	41 5e                	pop    r14
  22203a:	c3                   	ret    
  22203b:	48 8d 4c 24 08       	lea    rcx,[rsp+0x8]
  222040:	66 c7 44 24 08 00 00 	mov    WORD PTR [rsp+0x8],0x0
  222047:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  22204c:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  222050:	0f 85 2c ff ff ff    	jne    221f82 <Allocator_alignedRealloc.91+0x52>
  222056:	4c 8b 71 08          	mov    r14,QWORD PTR [rcx+0x8]
  22205a:	48 8d 7c 24 58       	lea    rdi,[rsp+0x58]
  22205f:	48 8d 54 24 38       	lea    rdx,[rsp+0x38]
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  222064:	41 b8 08 00 00 00    	mov    r8d,0x8
  22206a:	4c 89 f1             	mov    rcx,r14
  22206d:	ff 56 08             	call   QWORD PTR [rsi+0x8]
  222070:	0f b7 44 24 58       	movzx  eax,WORD PTR [rsp+0x58]
  222075:	66 85 c0             	test   ax,ax
  222078:	0f 84 95 00 00 00    	je     222113 <Allocator_alignedRealloc.91+0x1e3>
  22207e:	66 89 03             	mov    WORD PTR [rbx],ax
  222081:	48 8b 84 24 80 00 00 	mov    rax,QWORD PTR [rsp+0x80]
  222088:	00 
  222089:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  22208d:	c5 f8 10 44 24 72    	vmovups xmm0,XMMWORD PTR [rsp+0x72]
  222093:	c5 f8 11 43 02       	vmovups XMMWORD PTR [rbx+0x2],xmm0
  222098:	48 81 c4 88 00 00 00 	add    rsp,0x88
  22209f:	5b                   	pop    rbx
  2220a0:	41 5e                	pop    r14
  2220a2:	c3                   	ret    
  2220a3:	48 89 e0             	mov    rax,rsp
            return ([*]align(alignment) T)(undefined)[0..0];
  2220a6:	0f b7 0d 19 62 fe ff 	movzx  ecx,WORD PTR [rip+0xfffffffffffe6219]        # 2082c6 <__unnamed_96+0x6>
  2220ad:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  2220b2:	8b 0d 0a 62 fe ff    	mov    ecx,DWORD PTR [rip+0xfffffffffffe620a]        # 2082c2 <__unnamed_96+0x2>
  2220b8:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  2220bb:	31 c9                	xor    ecx,ecx
  2220bd:	45 31 f6             	xor    r14d,r14d
  2220c0:	e9 9f 00 00 00       	jmp    222164 <Allocator_alignedRealloc.91+0x234>
  2220c5:	48 8d 4c 24 48       	lea    rcx,[rsp+0x48]
  2220ca:	66 c7 44 24 48 00 00 	mov    WORD PTR [rsp+0x48],0x0
  2220d1:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  2220d6:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  2220da:	0f 85 ef fe ff ff    	jne    221fcf <Allocator_alignedRealloc.91+0x9f>
  2220e0:	4c 8b 71 08          	mov    r14,QWORD PTR [rcx+0x8]
  2220e4:	48 8d 7c 24 08       	lea    rdi,[rsp+0x8]
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  2220e9:	b9 08 00 00 00       	mov    ecx,0x8
  2220ee:	4c 89 f2             	mov    rdx,r14
  2220f1:	ff 16                	call   QWORD PTR [rsi]
  2220f3:	0f b7 4c 24 08       	movzx  ecx,WORD PTR [rsp+0x8]
  2220f8:	66 85 c9             	test   cx,cx
  2220fb:	74 41                	je     22213e <Allocator_alignedRealloc.91+0x20e>
  2220fd:	0f b7 44 24 36       	movzx  eax,WORD PTR [rsp+0x36]
  222102:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  222107:	48 89 e0             	mov    rax,rsp
  22210a:	8b 54 24 32          	mov    edx,DWORD PTR [rsp+0x32]
  22210e:	89 14 24             	mov    DWORD PTR [rsp],edx
  222111:	eb 51                	jmp    222164 <Allocator_alignedRealloc.91+0x234>
        assert(byte_slice.len == byte_count);
  222113:	4c 39 74 24 68       	cmp    QWORD PTR [rsp+0x68],r14
    if (!ok) {
  222118:	75 6d                	jne    222187 <Allocator_alignedRealloc.91+0x257>
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  22211a:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  22211f:	66 c7 03 00 00       	mov    WORD PTR [rbx],0x0
  222124:	0f b7 4c 24 2a       	movzx  ecx,WORD PTR [rsp+0x2a]
  222129:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  22212d:	49 c1 ee 04          	shr    r14,0x4
  222131:	8b 4c 24 26          	mov    ecx,DWORD PTR [rsp+0x26]
  222135:	89 4b 02             	mov    DWORD PTR [rbx+0x2],ecx
  222138:	48 89 43 08          	mov    QWORD PTR [rbx+0x8],rax
  22213c:	eb 3a                	jmp    222178 <Allocator_alignedRealloc.91+0x248>
        assert(byte_slice.len == byte_count);
  22213e:	4c 39 74 24 18       	cmp    QWORD PTR [rsp+0x18],r14
  222143:	75 42                	jne    222187 <Allocator_alignedRealloc.91+0x257>
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  222145:	48 8b 54 24 10       	mov    rdx,QWORD PTR [rsp+0x10]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  22214a:	49 c1 ee 04          	shr    r14,0x4
  22214e:	48 89 e0             	mov    rax,rsp
  222151:	8b 4c 24 2c          	mov    ecx,DWORD PTR [rsp+0x2c]
  222155:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  222158:	0f b7 4c 24 30       	movzx  ecx,WORD PTR [rsp+0x30]
  22215d:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  222162:	31 c9                	xor    ecx,ecx
            return self.alignedAlloc(T, alignment, n);
  222164:	66 89 0b             	mov    WORD PTR [rbx],cx
  222167:	0f b7 48 04          	movzx  ecx,WORD PTR [rax+0x4]
  22216b:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  22216f:	8b 00                	mov    eax,DWORD PTR [rax]
  222171:	89 43 02             	mov    DWORD PTR [rbx+0x2],eax
  222174:	48 89 53 08          	mov    QWORD PTR [rbx+0x8],rdx
  222178:	4c 89 73 10          	mov    QWORD PTR [rbx+0x10],r14
  22217c:	48 81 c4 88 00 00 00 	add    rsp,0x88
  222183:	5b                   	pop    rbx
  222184:	41 5e                	pop    r14
  222186:	c3                   	ret    
            @panic("assertion failure");
  222187:	e8 54 24 ff ff       	call   2145e0 <panic>
  22218c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

0000000000222190 <Allocator_alignedRealloc.94>:
    pub fn alignedRealloc(self: *Allocator, comptime T: type, comptime alignment: u29, old_mem: []align(alignment) T, n: usize) ![]align(alignment) T {
  222190:	41 56                	push   r14
  222192:	53                   	push   rbx
  222193:	48 81 ec 88 00 00 00 	sub    rsp,0x88
  22219a:	48 89 fb             	mov    rbx,rdi
        if (old_mem.len == 0) {
  22219d:	48 8b 42 08          	mov    rax,QWORD PTR [rdx+0x8]
  2221a1:	48 85 c0             	test   rax,rax
  2221a4:	74 62                	je     222208 <Allocator_alignedRealloc.94+0x78>
        if (n == 0) {
  2221a6:	48 85 c9             	test   rcx,rcx
  2221a9:	0f 84 a9 00 00 00    	je     222258 <Allocator_alignedRealloc.94+0xc8>
        const old_byte_slice = @sliceToBytes(old_mem);
  2221af:	48 8b 12             	mov    rdx,QWORD PTR [rdx]
  2221b2:	48 c1 e0 03          	shl    rax,0x3
  2221b6:	48 8d 04 80          	lea    rax,[rax+rax*4]
  2221ba:	48 89 54 24 38       	mov    QWORD PTR [rsp+0x38],rdx
  2221bf:	48 89 44 24 40       	mov    QWORD PTR [rsp+0x40],rax
  2221c4:	ba 28 00 00 00       	mov    edx,0x28
  2221c9:	48 89 c8             	mov    rax,rcx
  2221cc:	48 f7 e2             	mul    rdx
  2221cf:	0f 81 d0 00 00 00    	jno    2222a5 <Allocator_alignedRealloc.94+0x115>
  2221d5:	48 8d 0d 24 e3 fd ff 	lea    rcx,[rip+0xfffffffffffde324]        # 200500 <__unnamed_52>
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  2221dc:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  2221e0:	0f 84 da 00 00 00    	je     2222c0 <Allocator_alignedRealloc.94+0x130>
  2221e6:	48 8b 05 2b 61 fe ff 	mov    rax,QWORD PTR [rip+0xfffffffffffe612b]        # 208318 <__unnamed_97+0x10>
  2221ed:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  2221f1:	c5 f8 10 05 0f 61 fe 	vmovups xmm0,XMMWORD PTR [rip+0xfffffffffffe610f]        # 208308 <__unnamed_97>
  2221f8:	ff 
  2221f9:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  2221fd:	48 81 c4 88 00 00 00 	add    rsp,0x88
  222204:	5b                   	pop    rbx
  222205:	41 5e                	pop    r14
  222207:	c3                   	ret    
        if (n == 0) {
  222208:	48 85 c9             	test   rcx,rcx
  22220b:	0f 84 fc 00 00 00    	je     22230d <Allocator_alignedRealloc.94+0x17d>
  222211:	ba 28 00 00 00       	mov    edx,0x28
  222216:	48 89 c8             	mov    rax,rcx
  222219:	48 f7 e2             	mul    rdx
  22221c:	0f 81 0c 01 00 00    	jno    22232e <Allocator_alignedRealloc.94+0x19e>
  222222:	48 8d 0d d7 e2 fd ff 	lea    rcx,[rip+0xfffffffffffde2d7]        # 200500 <__unnamed_52>
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  222229:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  22222d:	0f 84 16 01 00 00    	je     222349 <Allocator_alignedRealloc.94+0x1b9>
  222233:	0f b7 05 d4 60 fe ff 	movzx  eax,WORD PTR [rip+0xfffffffffffe60d4]        # 20830e <__unnamed_97+0x6>
  22223a:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  22223f:	8b 05 c5 60 fe ff    	mov    eax,DWORD PTR [rip+0xfffffffffffe60c5]        # 20830a <__unnamed_97+0x2>
  222245:	89 04 24             	mov    DWORD PTR [rsp],eax
  222248:	48 89 e0             	mov    rax,rsp
  22224b:	66 b9 01 00          	mov    cx,0x1
  22224f:	31 f6                	xor    esi,esi
  222251:	31 d2                	xor    edx,edx
  222253:	e9 9d 01 00 00       	jmp    2223f5 <Allocator_alignedRealloc.94+0x265>
        const bytes = @sliceToBytes(memory);
  222258:	48 c1 e0 03          	shl    rax,0x3
  22225c:	48 8d 04 80          	lea    rax,[rax+rax*4]
        if (bytes.len == 0) return;
  222260:	48 85 c0             	test   rax,rax
  222263:	74 1e                	je     222283 <Allocator_alignedRealloc.94+0xf3>
        const bytes = @sliceToBytes(memory);
  222265:	48 8b 0a             	mov    rcx,QWORD PTR [rdx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  222268:	48 8b 56 10          	mov    rdx,QWORD PTR [rsi+0x10]
  22226c:	48 89 4c 24 08       	mov    QWORD PTR [rsp+0x8],rcx
  222271:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  222276:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  22227b:	48 89 f7             	mov    rdi,rsi
  22227e:	48 89 c6             	mov    rsi,rax
  222281:	ff d2                	call   rdx
            return ([*]align(alignment) T)(undefined)[0..0];
  222283:	48 8b 05 76 60 fe ff 	mov    rax,QWORD PTR [rip+0xfffffffffffe6076]        # 208300 <__unnamed_98+0x10>
  22228a:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  22228e:	c5 f8 10 05 5a 60 fe 	vmovups xmm0,XMMWORD PTR [rip+0xfffffffffffe605a]        # 2082f0 <__unnamed_98>
  222295:	ff 
  222296:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  22229a:	48 81 c4 88 00 00 00 	add    rsp,0x88
  2222a1:	5b                   	pop    rbx
  2222a2:	41 5e                	pop    r14
  2222a4:	c3                   	ret    
  2222a5:	48 8d 4c 24 08       	lea    rcx,[rsp+0x8]
  2222aa:	66 c7 44 24 08 00 00 	mov    WORD PTR [rsp+0x8],0x0
  2222b1:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  2222b6:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  2222ba:	0f 85 26 ff ff ff    	jne    2221e6 <Allocator_alignedRealloc.94+0x56>
  2222c0:	4c 8b 71 08          	mov    r14,QWORD PTR [rcx+0x8]
  2222c4:	48 8d 7c 24 58       	lea    rdi,[rsp+0x58]
  2222c9:	48 8d 54 24 38       	lea    rdx,[rsp+0x38]
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  2222ce:	41 b8 08 00 00 00    	mov    r8d,0x8
  2222d4:	4c 89 f1             	mov    rcx,r14
  2222d7:	ff 56 08             	call   QWORD PTR [rsi+0x8]
  2222da:	0f b7 44 24 58       	movzx  eax,WORD PTR [rsp+0x58]
  2222df:	66 85 c0             	test   ax,ax
  2222e2:	0f 84 94 00 00 00    	je     22237c <Allocator_alignedRealloc.94+0x1ec>
  2222e8:	66 89 03             	mov    WORD PTR [rbx],ax
  2222eb:	48 8b 84 24 80 00 00 	mov    rax,QWORD PTR [rsp+0x80]
  2222f2:	00 
  2222f3:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  2222f7:	c5 f8 10 44 24 72    	vmovups xmm0,XMMWORD PTR [rsp+0x72]
  2222fd:	c5 f8 11 43 02       	vmovups XMMWORD PTR [rbx+0x2],xmm0
  222302:	48 81 c4 88 00 00 00 	add    rsp,0x88
  222309:	5b                   	pop    rbx
  22230a:	41 5e                	pop    r14
  22230c:	c3                   	ret    
  22230d:	48 89 e0             	mov    rax,rsp
            return ([*]align(alignment) T)(undefined)[0..0];
  222310:	0f b7 0d df 5f fe ff 	movzx  ecx,WORD PTR [rip+0xfffffffffffe5fdf]        # 2082f6 <__unnamed_98+0x6>
  222317:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  22231c:	8b 0d d0 5f fe ff    	mov    ecx,DWORD PTR [rip+0xfffffffffffe5fd0]        # 2082f2 <__unnamed_98+0x2>
  222322:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  222325:	31 c9                	xor    ecx,ecx
  222327:	31 d2                	xor    edx,edx
  222329:	e9 c7 00 00 00       	jmp    2223f5 <Allocator_alignedRealloc.94+0x265>
  22232e:	48 8d 4c 24 48       	lea    rcx,[rsp+0x48]
  222333:	66 c7 44 24 48 00 00 	mov    WORD PTR [rsp+0x48],0x0
  22233a:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  22233f:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  222343:	0f 85 ea fe ff ff    	jne    222233 <Allocator_alignedRealloc.94+0xa3>
  222349:	4c 8b 71 08          	mov    r14,QWORD PTR [rcx+0x8]
  22234d:	48 8d 7c 24 08       	lea    rdi,[rsp+0x8]
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  222352:	b9 08 00 00 00       	mov    ecx,0x8
  222357:	4c 89 f2             	mov    rdx,r14
  22235a:	ff 16                	call   QWORD PTR [rsi]
  22235c:	0f b7 4c 24 08       	movzx  ecx,WORD PTR [rsp+0x8]
  222361:	66 85 c9             	test   cx,cx
  222364:	74 57                	je     2223bd <Allocator_alignedRealloc.94+0x22d>
  222366:	0f b7 44 24 36       	movzx  eax,WORD PTR [rsp+0x36]
  22236b:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  222370:	48 89 e0             	mov    rax,rsp
  222373:	8b 54 24 32          	mov    edx,DWORD PTR [rsp+0x32]
  222377:	89 14 24             	mov    DWORD PTR [rsp],edx
  22237a:	eb 79                	jmp    2223f5 <Allocator_alignedRealloc.94+0x265>
        assert(byte_slice.len == byte_count);
  22237c:	4c 39 74 24 68       	cmp    QWORD PTR [rsp+0x68],r14
    if (!ok) {
  222381:	0f 85 91 00 00 00    	jne    222418 <Allocator_alignedRealloc.94+0x288>
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  222387:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  22238c:	48 b9 cd cc cc cc cc 	movabs rcx,0xcccccccccccccccd
  222393:	cc cc cc 
  222396:	4c 89 f2             	mov    rdx,r14
  222399:	c4 e2 f3 f6 d1       	mulx   rdx,rcx,rcx
  22239e:	66 c7 03 00 00       	mov    WORD PTR [rbx],0x0
  2223a3:	0f b7 4c 24 2a       	movzx  ecx,WORD PTR [rsp+0x2a]
  2223a8:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  2223ac:	48 c1 ea 05          	shr    rdx,0x5
  2223b0:	8b 4c 24 26          	mov    ecx,DWORD PTR [rsp+0x26]
  2223b4:	89 4b 02             	mov    DWORD PTR [rbx+0x2],ecx
  2223b7:	48 89 43 08          	mov    QWORD PTR [rbx+0x8],rax
  2223bb:	eb 4c                	jmp    222409 <Allocator_alignedRealloc.94+0x279>
        assert(byte_slice.len == byte_count);
  2223bd:	4c 39 74 24 18       	cmp    QWORD PTR [rsp+0x18],r14
  2223c2:	75 54                	jne    222418 <Allocator_alignedRealloc.94+0x288>
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  2223c4:	48 8b 74 24 10       	mov    rsi,QWORD PTR [rsp+0x10]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  2223c9:	48 b8 cd cc cc cc cc 	movabs rax,0xcccccccccccccccd
  2223d0:	cc cc cc 
  2223d3:	4c 89 f2             	mov    rdx,r14
  2223d6:	c4 e2 fb f6 d0       	mulx   rdx,rax,rax
  2223db:	48 c1 ea 05          	shr    rdx,0x5
  2223df:	48 89 e0             	mov    rax,rsp
  2223e2:	8b 4c 24 2c          	mov    ecx,DWORD PTR [rsp+0x2c]
  2223e6:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  2223e9:	0f b7 4c 24 30       	movzx  ecx,WORD PTR [rsp+0x30]
  2223ee:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  2223f3:	31 c9                	xor    ecx,ecx
            return self.alignedAlloc(T, alignment, n);
  2223f5:	66 89 0b             	mov    WORD PTR [rbx],cx
  2223f8:	0f b7 48 04          	movzx  ecx,WORD PTR [rax+0x4]
  2223fc:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  222400:	8b 00                	mov    eax,DWORD PTR [rax]
  222402:	89 43 02             	mov    DWORD PTR [rbx+0x2],eax
  222405:	48 89 73 08          	mov    QWORD PTR [rbx+0x8],rsi
  222409:	48 89 53 10          	mov    QWORD PTR [rbx+0x10],rdx
  22240d:	48 81 c4 88 00 00 00 	add    rsp,0x88
  222414:	5b                   	pop    rbx
  222415:	41 5e                	pop    r14
  222417:	c3                   	ret    
            @panic("assertion failure");
  222418:	e8 c3 21 ff ff       	call   2145e0 <panic>
  22241d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000222420 <join.97>:
pub fn join(allocator: *Allocator, sep: u8, strings: ...) ![]u8 {
  222420:	55                   	push   rbp
  222421:	41 57                	push   r15
  222423:	41 56                	push   r14
  222425:	41 55                	push   r13
  222427:	41 54                	push   r12
  222429:	53                   	push   rbx
  22242a:	48 83 ec 58          	sub    rsp,0x58
  22242e:	49 89 cc             	mov    r12,rcx
  222431:	48 89 d3             	mov    rbx,rdx
  222434:	49 89 f2             	mov    r10,rsi
  222437:	49 89 ff             	mov    r15,rdi
            const arg = ([]const u8)(strings[string_i]);
  22243a:	4c 8b 43 08          	mov    r8,QWORD PTR [rbx+0x8]
  22243e:	4d 8b 6c 24 08       	mov    r13,QWORD PTR [r12+0x8]
            total_strings_len += arg.len;
  222443:	4d 01 c5             	add    r13,r8
        if (n == 0) {
  222446:	49 83 c5 02          	add    r13,0x2
  22244a:	74 42                	je     22248e <join.97+0x6e>
  22244c:	48 8d 7c 24 08       	lea    rdi,[rsp+0x8]
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  222451:	b9 01 00 00 00       	mov    ecx,0x1
  222456:	4c 89 d6             	mov    rsi,r10
  222459:	4c 89 ea             	mov    rdx,r13
  22245c:	4c 89 d5             	mov    rbp,r10
  22245f:	ff 55 00             	call   QWORD PTR [rbp+0x0]
  222462:	0f b7 44 24 08       	movzx  eax,WORD PTR [rsp+0x8]
  222467:	66 85 c0             	test   ax,ax
  22246a:	0f 84 e5 00 00 00    	je     222555 <join.97+0x135>
    const buf = try allocator.alloc(u8, total_strings_len);
  222470:	66 41 89 07          	mov    WORD PTR [r15],ax
  222474:	48 8b 44 24 50       	mov    rax,QWORD PTR [rsp+0x50]
  222479:	49 89 47 10          	mov    QWORD PTR [r15+0x10],rax
  22247d:	c5 f8 10 44 24 42    	vmovups xmm0,XMMWORD PTR [rsp+0x42]
  222483:	c4 c1 78 11 47 02    	vmovups XMMWORD PTR [r15+0x2],xmm0
  222489:	e9 df 05 00 00       	jmp    222a6d <join.97+0x64d>
  22248e:	45 31 ed             	xor    r13d,r13d
    assert(dest.len >= source.len);
  222491:	4d 39 c5             	cmp    r13,r8
    if (!ok) {
  222494:	0f 82 e5 05 00 00    	jb     222a7f <join.97+0x65f>
    for (source) |s, i|
  22249a:	4d 85 c0             	test   r8,r8
  22249d:	0f 84 8f 02 00 00    	je     222732 <join.97+0x312>
  2224a3:	48 8b 0b             	mov    rcx,QWORD PTR [rbx]
  2224a6:	49 81 f8 80 00 00 00 	cmp    r8,0x80
  2224ad:	72 1a                	jb     2224c9 <join.97+0xa9>
  2224af:	4a 8d 04 01          	lea    rax,[rcx+r8*1]
  2224b3:	48 39 e8             	cmp    rax,rbp
  2224b6:	0f 86 be 00 00 00    	jbe    22257a <join.97+0x15a>
  2224bc:	49 8d 04 28          	lea    rax,[r8+rbp*1]
  2224c0:	48 39 c1             	cmp    rcx,rax
  2224c3:	0f 83 b1 00 00 00    	jae    22257a <join.97+0x15a>
  2224c9:	31 d2                	xor    edx,edx
  2224cb:	49 8d 40 ff          	lea    rax,[r8-0x1]
  2224cf:	48 29 d0             	sub    rax,rdx
  2224d2:	4c 89 c6             	mov    rsi,r8
  2224d5:	48 83 e6 07          	and    rsi,0x7
  2224d9:	74 17                	je     2224f2 <join.97+0xd2>
  2224db:	48 f7 de             	neg    rsi
  2224de:	66 90                	xchg   ax,ax
  2224e0:	0f b6 1c 11          	movzx  ebx,BYTE PTR [rcx+rdx*1]
        dest[i] = s;
  2224e4:	88 5c 15 00          	mov    BYTE PTR [rbp+rdx*1+0x0],bl
    for (source) |s, i|
  2224e8:	48 83 c2 01          	add    rdx,0x1
  2224ec:	48 83 c6 01          	add    rsi,0x1
  2224f0:	75 ee                	jne    2224e0 <join.97+0xc0>
  2224f2:	48 83 f8 07          	cmp    rax,0x7
  2224f6:	0f 82 36 02 00 00    	jb     222732 <join.97+0x312>
  2224fc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  222500:	0f b6 04 11          	movzx  eax,BYTE PTR [rcx+rdx*1]
        dest[i] = s;
  222504:	88 44 15 00          	mov    BYTE PTR [rbp+rdx*1+0x0],al
    for (source) |s, i|
  222508:	0f b6 44 11 01       	movzx  eax,BYTE PTR [rcx+rdx*1+0x1]
        dest[i] = s;
  22250d:	88 44 15 01          	mov    BYTE PTR [rbp+rdx*1+0x1],al
    for (source) |s, i|
  222511:	0f b6 44 11 02       	movzx  eax,BYTE PTR [rcx+rdx*1+0x2]
        dest[i] = s;
  222516:	88 44 15 02          	mov    BYTE PTR [rbp+rdx*1+0x2],al
    for (source) |s, i|
  22251a:	0f b6 44 11 03       	movzx  eax,BYTE PTR [rcx+rdx*1+0x3]
        dest[i] = s;
  22251f:	88 44 15 03          	mov    BYTE PTR [rbp+rdx*1+0x3],al
    for (source) |s, i|
  222523:	0f b6 44 11 04       	movzx  eax,BYTE PTR [rcx+rdx*1+0x4]
        dest[i] = s;
  222528:	88 44 15 04          	mov    BYTE PTR [rbp+rdx*1+0x4],al
    for (source) |s, i|
  22252c:	0f b6 44 11 05       	movzx  eax,BYTE PTR [rcx+rdx*1+0x5]
        dest[i] = s;
  222531:	88 44 15 05          	mov    BYTE PTR [rbp+rdx*1+0x5],al
    for (source) |s, i|
  222535:	0f b6 44 11 06       	movzx  eax,BYTE PTR [rcx+rdx*1+0x6]
        dest[i] = s;
  22253a:	88 44 15 06          	mov    BYTE PTR [rbp+rdx*1+0x6],al
    for (source) |s, i|
  22253e:	0f b6 44 11 07       	movzx  eax,BYTE PTR [rcx+rdx*1+0x7]
        dest[i] = s;
  222543:	88 44 15 07          	mov    BYTE PTR [rbp+rdx*1+0x7],al
    for (source) |s, i|
  222547:	48 83 c2 08          	add    rdx,0x8
  22254b:	49 39 d0             	cmp    r8,rdx
  22254e:	75 b0                	jne    222500 <join.97+0xe0>
  222550:	e9 dd 01 00 00       	jmp    222732 <join.97+0x312>
  222555:	49 89 ea             	mov    r10,rbp
        assert(byte_slice.len == byte_count);
  222558:	4c 39 6c 24 18       	cmp    QWORD PTR [rsp+0x18],r13
  22255d:	0f 85 1c 05 00 00    	jne    222a7f <join.97+0x65f>
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  222563:	48 8b 6c 24 10       	mov    rbp,QWORD PTR [rsp+0x10]
        const arg = ([]const u8)(strings[string_i]);
  222568:	4c 8b 43 08          	mov    r8,QWORD PTR [rbx+0x8]
    assert(dest.len >= source.len);
  22256c:	4d 39 c5             	cmp    r13,r8
  22256f:	0f 83 25 ff ff ff    	jae    22249a <join.97+0x7a>
  222575:	e9 05 05 00 00       	jmp    222a7f <join.97+0x65f>
    for (source) |s, i|
  22257a:	4c 89 c2             	mov    rdx,r8
  22257d:	48 83 e2 80          	and    rdx,0xffffffffffffff80
  222581:	48 8d 42 80          	lea    rax,[rdx-0x80]
  222585:	48 89 c7             	mov    rdi,rax
  222588:	48 c1 ef 07          	shr    rdi,0x7
  22258c:	8d 77 01             	lea    esi,[rdi+0x1]
  22258f:	83 e6 03             	and    esi,0x3
  222592:	48 3d 80 01 00 00    	cmp    rax,0x180
  222598:	73 10                	jae    2225aa <join.97+0x18a>
  22259a:	31 ff                	xor    edi,edi
  22259c:	48 85 f6             	test   rsi,rsi
  22259f:	0f 85 38 01 00 00    	jne    2226dd <join.97+0x2bd>
  2225a5:	e9 7f 01 00 00       	jmp    222729 <join.97+0x309>
  2225aa:	48 8d 46 ff          	lea    rax,[rsi-0x1]
  2225ae:	48 29 f8             	sub    rax,rdi
  2225b1:	31 ff                	xor    edi,edi
  2225b3:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  2225ba:	84 00 00 00 00 00 
  2225c0:	c5 fc 10 04 39       	vmovups ymm0,YMMWORD PTR [rcx+rdi*1]
  2225c5:	c5 fc 10 4c 39 20    	vmovups ymm1,YMMWORD PTR [rcx+rdi*1+0x20]
  2225cb:	c5 fc 10 54 39 40    	vmovups ymm2,YMMWORD PTR [rcx+rdi*1+0x40]
  2225d1:	c5 fc 10 5c 39 60    	vmovups ymm3,YMMWORD PTR [rcx+rdi*1+0x60]
        dest[i] = s;
  2225d7:	c5 fc 11 44 3d 00    	vmovups YMMWORD PTR [rbp+rdi*1+0x0],ymm0
  2225dd:	c5 fc 11 4c 3d 20    	vmovups YMMWORD PTR [rbp+rdi*1+0x20],ymm1
  2225e3:	c5 fc 11 54 3d 40    	vmovups YMMWORD PTR [rbp+rdi*1+0x40],ymm2
  2225e9:	c5 fc 11 5c 3d 60    	vmovups YMMWORD PTR [rbp+rdi*1+0x60],ymm3
    for (source) |s, i|
  2225ef:	c5 fc 10 84 39 80 00 	vmovups ymm0,YMMWORD PTR [rcx+rdi*1+0x80]
  2225f6:	00 00 
  2225f8:	c5 fc 10 8c 39 a0 00 	vmovups ymm1,YMMWORD PTR [rcx+rdi*1+0xa0]
  2225ff:	00 00 
  222601:	c5 fc 10 94 39 c0 00 	vmovups ymm2,YMMWORD PTR [rcx+rdi*1+0xc0]
  222608:	00 00 
  22260a:	c5 fc 10 9c 39 e0 00 	vmovups ymm3,YMMWORD PTR [rcx+rdi*1+0xe0]
  222611:	00 00 
        dest[i] = s;
  222613:	c5 fc 11 84 3d 80 00 	vmovups YMMWORD PTR [rbp+rdi*1+0x80],ymm0
  22261a:	00 00 
  22261c:	c5 fc 11 8c 3d a0 00 	vmovups YMMWORD PTR [rbp+rdi*1+0xa0],ymm1
  222623:	00 00 
  222625:	c5 fc 11 94 3d c0 00 	vmovups YMMWORD PTR [rbp+rdi*1+0xc0],ymm2
  22262c:	00 00 
  22262e:	c5 fc 11 9c 3d e0 00 	vmovups YMMWORD PTR [rbp+rdi*1+0xe0],ymm3
  222635:	00 00 
    for (source) |s, i|
  222637:	c5 fc 10 84 39 00 01 	vmovups ymm0,YMMWORD PTR [rcx+rdi*1+0x100]
  22263e:	00 00 
  222640:	c5 fc 10 8c 39 20 01 	vmovups ymm1,YMMWORD PTR [rcx+rdi*1+0x120]
  222647:	00 00 
  222649:	c5 fc 10 94 39 40 01 	vmovups ymm2,YMMWORD PTR [rcx+rdi*1+0x140]
  222650:	00 00 
  222652:	c5 fc 10 9c 39 60 01 	vmovups ymm3,YMMWORD PTR [rcx+rdi*1+0x160]
  222659:	00 00 
        dest[i] = s;
  22265b:	c5 fc 11 84 3d 00 01 	vmovups YMMWORD PTR [rbp+rdi*1+0x100],ymm0
  222662:	00 00 
  222664:	c5 fc 11 8c 3d 20 01 	vmovups YMMWORD PTR [rbp+rdi*1+0x120],ymm1
  22266b:	00 00 
  22266d:	c5 fc 11 94 3d 40 01 	vmovups YMMWORD PTR [rbp+rdi*1+0x140],ymm2
  222674:	00 00 
  222676:	c5 fc 11 9c 3d 60 01 	vmovups YMMWORD PTR [rbp+rdi*1+0x160],ymm3
  22267d:	00 00 
    for (source) |s, i|
  22267f:	c5 fc 10 84 39 80 01 	vmovups ymm0,YMMWORD PTR [rcx+rdi*1+0x180]
  222686:	00 00 
  222688:	c5 fc 10 8c 39 a0 01 	vmovups ymm1,YMMWORD PTR [rcx+rdi*1+0x1a0]
  22268f:	00 00 
  222691:	c5 fc 10 94 39 c0 01 	vmovups ymm2,YMMWORD PTR [rcx+rdi*1+0x1c0]
  222698:	00 00 
  22269a:	c5 fc 10 9c 39 e0 01 	vmovups ymm3,YMMWORD PTR [rcx+rdi*1+0x1e0]
  2226a1:	00 00 
        dest[i] = s;
  2226a3:	c5 fc 11 84 3d 80 01 	vmovups YMMWORD PTR [rbp+rdi*1+0x180],ymm0
  2226aa:	00 00 
  2226ac:	c5 fc 11 8c 3d a0 01 	vmovups YMMWORD PTR [rbp+rdi*1+0x1a0],ymm1
  2226b3:	00 00 
  2226b5:	c5 fc 11 94 3d c0 01 	vmovups YMMWORD PTR [rbp+rdi*1+0x1c0],ymm2
  2226bc:	00 00 
  2226be:	c5 fc 11 9c 3d e0 01 	vmovups YMMWORD PTR [rbp+rdi*1+0x1e0],ymm3
  2226c5:	00 00 
    for (source) |s, i|
  2226c7:	48 81 c7 00 02 00 00 	add    rdi,0x200
  2226ce:	48 83 c0 04          	add    rax,0x4
  2226d2:	0f 85 e8 fe ff ff    	jne    2225c0 <join.97+0x1a0>
  2226d8:	48 85 f6             	test   rsi,rsi
  2226db:	74 4c                	je     222729 <join.97+0x309>
  2226dd:	48 83 c7 60          	add    rdi,0x60
  2226e1:	48 f7 de             	neg    rsi
  2226e4:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  2226eb:	00 00 00 00 00 
  2226f0:	c5 fc 10 44 39 a0    	vmovups ymm0,YMMWORD PTR [rcx+rdi*1-0x60]
  2226f6:	c5 fc 10 4c 39 c0    	vmovups ymm1,YMMWORD PTR [rcx+rdi*1-0x40]
  2226fc:	c5 fc 10 54 39 e0    	vmovups ymm2,YMMWORD PTR [rcx+rdi*1-0x20]
  222702:	c5 fc 10 1c 39       	vmovups ymm3,YMMWORD PTR [rcx+rdi*1]
        dest[i] = s;
  222707:	c5 fc 11 44 3d a0    	vmovups YMMWORD PTR [rbp+rdi*1-0x60],ymm0
  22270d:	c5 fc 11 4c 3d c0    	vmovups YMMWORD PTR [rbp+rdi*1-0x40],ymm1
  222713:	c5 fc 11 54 3d e0    	vmovups YMMWORD PTR [rbp+rdi*1-0x20],ymm2
  222719:	c5 fc 11 5c 3d 00    	vmovups YMMWORD PTR [rbp+rdi*1+0x0],ymm3
    for (source) |s, i|
  22271f:	48 83 ef 80          	sub    rdi,0xffffffffffffff80
  222723:	48 83 c6 01          	add    rsi,0x1
  222727:	75 c7                	jne    2226f0 <join.97+0x2d0>
  222729:	49 39 d0             	cmp    r8,rdx
  22272c:	0f 85 99 fd ff ff    	jne    2224cb <join.97+0xab>
        if (buf[buf_index - 1] != sep) {
  222732:	42 80 7c 05 ff 2f    	cmp    BYTE PTR [rbp+r8*1-0x1],0x2f
  222738:	74 0a                	je     222744 <join.97+0x324>
            buf[buf_index] = sep;
  22273a:	42 c6 44 05 00 2f    	mov    BYTE PTR [rbp+r8*1+0x0],0x2f
            buf_index += 1;
  222740:	49 83 c0 01          	add    r8,0x1
        const arg = ([]const u8)(strings[string_i]);
  222744:	4d 8b 74 24 08       	mov    r14,QWORD PTR [r12+0x8]
        copy(u8, buf[buf_index..], arg);
  222749:	4c 89 e8             	mov    rax,r13
  22274c:	4c 29 c0             	sub    rax,r8
    assert(dest.len >= source.len);
  22274f:	4c 39 f0             	cmp    rax,r14
  222752:	0f 82 27 03 00 00    	jb     222a7f <join.97+0x65f>
    for (source) |s, i|
  222758:	4d 85 f6             	test   r14,r14
  22275b:	0f 84 84 02 00 00    	je     2229e5 <join.97+0x5c5>
  222761:	49 8b 0c 24          	mov    rcx,QWORD PTR [r12]
  222765:	4d 8d 0c 28          	lea    r9,[r8+rbp*1]
  222769:	49 81 fe 80 00 00 00 	cmp    r14,0x80
  222770:	72 1d                	jb     22278f <join.97+0x36f>
  222772:	4a 8d 04 31          	lea    rax,[rcx+r14*1]
  222776:	49 39 c1             	cmp    r9,rax
  222779:	0f 83 b5 00 00 00    	jae    222834 <join.97+0x414>
  22277f:	4b 8d 04 30          	lea    rax,[r8+r14*1]
  222783:	48 01 e8             	add    rax,rbp
  222786:	48 39 c1             	cmp    rcx,rax
  222789:	0f 83 a5 00 00 00    	jae    222834 <join.97+0x414>
  22278f:	31 d2                	xor    edx,edx
  222791:	49 8d 46 ff          	lea    rax,[r14-0x1]
  222795:	48 29 d0             	sub    rax,rdx
  222798:	4c 89 f6             	mov    rsi,r14
  22279b:	48 83 e6 07          	and    rsi,0x7
  22279f:	74 21                	je     2227c2 <join.97+0x3a2>
  2227a1:	48 f7 de             	neg    rsi
  2227a4:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  2227ab:	00 00 00 00 00 
  2227b0:	0f b6 1c 11          	movzx  ebx,BYTE PTR [rcx+rdx*1]
        dest[i] = s;
  2227b4:	41 88 1c 11          	mov    BYTE PTR [r9+rdx*1],bl
    for (source) |s, i|
  2227b8:	48 83 c2 01          	add    rdx,0x1
  2227bc:	48 83 c6 01          	add    rsi,0x1
  2227c0:	75 ee                	jne    2227b0 <join.97+0x390>
  2227c2:	48 83 f8 07          	cmp    rax,0x7
  2227c6:	0f 82 19 02 00 00    	jb     2229e5 <join.97+0x5c5>
  2227cc:	49 8d 04 28          	lea    rax,[r8+rbp*1]
  2227d0:	48 83 c0 07          	add    rax,0x7
  2227d4:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  2227db:	00 00 00 00 00 
  2227e0:	0f b6 1c 11          	movzx  ebx,BYTE PTR [rcx+rdx*1]
        dest[i] = s;
  2227e4:	88 5c 10 f9          	mov    BYTE PTR [rax+rdx*1-0x7],bl
    for (source) |s, i|
  2227e8:	0f b6 5c 11 01       	movzx  ebx,BYTE PTR [rcx+rdx*1+0x1]
        dest[i] = s;
  2227ed:	88 5c 10 fa          	mov    BYTE PTR [rax+rdx*1-0x6],bl
    for (source) |s, i|
  2227f1:	0f b6 5c 11 02       	movzx  ebx,BYTE PTR [rcx+rdx*1+0x2]
        dest[i] = s;
  2227f6:	88 5c 10 fb          	mov    BYTE PTR [rax+rdx*1-0x5],bl
    for (source) |s, i|
  2227fa:	0f b6 5c 11 03       	movzx  ebx,BYTE PTR [rcx+rdx*1+0x3]
        dest[i] = s;
  2227ff:	88 5c 10 fc          	mov    BYTE PTR [rax+rdx*1-0x4],bl
    for (source) |s, i|
  222803:	0f b6 5c 11 04       	movzx  ebx,BYTE PTR [rcx+rdx*1+0x4]
        dest[i] = s;
  222808:	88 5c 10 fd          	mov    BYTE PTR [rax+rdx*1-0x3],bl
    for (source) |s, i|
  22280c:	0f b6 5c 11 05       	movzx  ebx,BYTE PTR [rcx+rdx*1+0x5]
        dest[i] = s;
  222811:	88 5c 10 fe          	mov    BYTE PTR [rax+rdx*1-0x2],bl
    for (source) |s, i|
  222815:	0f b6 5c 11 06       	movzx  ebx,BYTE PTR [rcx+rdx*1+0x6]
        dest[i] = s;
  22281a:	88 5c 10 ff          	mov    BYTE PTR [rax+rdx*1-0x1],bl
    for (source) |s, i|
  22281e:	0f b6 5c 11 07       	movzx  ebx,BYTE PTR [rcx+rdx*1+0x7]
        dest[i] = s;
  222823:	88 1c 10             	mov    BYTE PTR [rax+rdx*1],bl
    for (source) |s, i|
  222826:	48 83 c2 08          	add    rdx,0x8
  22282a:	49 39 d6             	cmp    r14,rdx
  22282d:	75 b1                	jne    2227e0 <join.97+0x3c0>
  22282f:	e9 b1 01 00 00       	jmp    2229e5 <join.97+0x5c5>
  222834:	4c 89 f2             	mov    rdx,r14
  222837:	48 83 e2 80          	and    rdx,0xffffffffffffff80
  22283b:	48 8d 72 80          	lea    rsi,[rdx-0x80]
  22283f:	48 89 f0             	mov    rax,rsi
  222842:	48 c1 e8 07          	shr    rax,0x7
  222846:	8d 78 01             	lea    edi,[rax+0x1]
  222849:	83 e7 03             	and    edi,0x3
  22284c:	48 81 fe 80 01 00 00 	cmp    rsi,0x180
  222853:	73 10                	jae    222865 <join.97+0x445>
  222855:	31 c0                	xor    eax,eax
  222857:	48 85 ff             	test   rdi,rdi
  22285a:	0f 85 38 01 00 00    	jne    222998 <join.97+0x578>
  222860:	e9 77 01 00 00       	jmp    2229dc <join.97+0x5bc>
  222865:	49 8d 1c 28          	lea    rbx,[r8+rbp*1]
  222869:	48 81 c3 e0 01 00 00 	add    rbx,0x1e0
  222870:	48 8d 77 ff          	lea    rsi,[rdi-0x1]
  222874:	48 29 c6             	sub    rsi,rax
  222877:	31 c0                	xor    eax,eax
  222879:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  222880:	c5 fc 10 04 01       	vmovups ymm0,YMMWORD PTR [rcx+rax*1]
  222885:	c5 fc 10 4c 01 20    	vmovups ymm1,YMMWORD PTR [rcx+rax*1+0x20]
  22288b:	c5 fc 10 54 01 40    	vmovups ymm2,YMMWORD PTR [rcx+rax*1+0x40]
  222891:	c5 fc 10 5c 01 60    	vmovups ymm3,YMMWORD PTR [rcx+rax*1+0x60]
        dest[i] = s;
  222897:	c5 fc 11 84 03 20 fe 	vmovups YMMWORD PTR [rbx+rax*1-0x1e0],ymm0
  22289e:	ff ff 
  2228a0:	c5 fc 11 8c 03 40 fe 	vmovups YMMWORD PTR [rbx+rax*1-0x1c0],ymm1
  2228a7:	ff ff 
  2228a9:	c5 fc 11 94 03 60 fe 	vmovups YMMWORD PTR [rbx+rax*1-0x1a0],ymm2
  2228b0:	ff ff 
  2228b2:	c5 fc 11 9c 03 80 fe 	vmovups YMMWORD PTR [rbx+rax*1-0x180],ymm3
  2228b9:	ff ff 
    for (source) |s, i|
  2228bb:	c5 fc 10 84 01 80 00 	vmovups ymm0,YMMWORD PTR [rcx+rax*1+0x80]
  2228c2:	00 00 
  2228c4:	c5 fc 10 8c 01 a0 00 	vmovups ymm1,YMMWORD PTR [rcx+rax*1+0xa0]
  2228cb:	00 00 
  2228cd:	c5 fc 10 94 01 c0 00 	vmovups ymm2,YMMWORD PTR [rcx+rax*1+0xc0]
  2228d4:	00 00 
  2228d6:	c5 fc 10 9c 01 e0 00 	vmovups ymm3,YMMWORD PTR [rcx+rax*1+0xe0]
  2228dd:	00 00 
        dest[i] = s;
  2228df:	c5 fc 11 84 03 a0 fe 	vmovups YMMWORD PTR [rbx+rax*1-0x160],ymm0
  2228e6:	ff ff 
  2228e8:	c5 fc 11 8c 03 c0 fe 	vmovups YMMWORD PTR [rbx+rax*1-0x140],ymm1
  2228ef:	ff ff 
  2228f1:	c5 fc 11 94 03 e0 fe 	vmovups YMMWORD PTR [rbx+rax*1-0x120],ymm2
  2228f8:	ff ff 
  2228fa:	c5 fc 11 9c 03 00 ff 	vmovups YMMWORD PTR [rbx+rax*1-0x100],ymm3
  222901:	ff ff 
    for (source) |s, i|
  222903:	c5 fc 10 84 01 00 01 	vmovups ymm0,YMMWORD PTR [rcx+rax*1+0x100]
  22290a:	00 00 
  22290c:	c5 fc 10 8c 01 20 01 	vmovups ymm1,YMMWORD PTR [rcx+rax*1+0x120]
  222913:	00 00 
  222915:	c5 fc 10 94 01 40 01 	vmovups ymm2,YMMWORD PTR [rcx+rax*1+0x140]
  22291c:	00 00 
  22291e:	c5 fc 10 9c 01 60 01 	vmovups ymm3,YMMWORD PTR [rcx+rax*1+0x160]
  222925:	00 00 
        dest[i] = s;
  222927:	c5 fc 11 84 03 20 ff 	vmovups YMMWORD PTR [rbx+rax*1-0xe0],ymm0
  22292e:	ff ff 
  222930:	c5 fc 11 8c 03 40 ff 	vmovups YMMWORD PTR [rbx+rax*1-0xc0],ymm1
  222937:	ff ff 
  222939:	c5 fc 11 94 03 60 ff 	vmovups YMMWORD PTR [rbx+rax*1-0xa0],ymm2
  222940:	ff ff 
  222942:	c5 fc 11 5c 03 80    	vmovups YMMWORD PTR [rbx+rax*1-0x80],ymm3
    for (source) |s, i|
  222948:	c5 fc 10 84 01 80 01 	vmovups ymm0,YMMWORD PTR [rcx+rax*1+0x180]
  22294f:	00 00 
  222951:	c5 fc 10 8c 01 a0 01 	vmovups ymm1,YMMWORD PTR [rcx+rax*1+0x1a0]
  222958:	00 00 
  22295a:	c5 fc 10 94 01 c0 01 	vmovups ymm2,YMMWORD PTR [rcx+rax*1+0x1c0]
  222961:	00 00 
  222963:	c5 fc 10 9c 01 e0 01 	vmovups ymm3,YMMWORD PTR [rcx+rax*1+0x1e0]
  22296a:	00 00 
        dest[i] = s;
  22296c:	c5 fc 11 44 03 a0    	vmovups YMMWORD PTR [rbx+rax*1-0x60],ymm0
  222972:	c5 fc 11 4c 03 c0    	vmovups YMMWORD PTR [rbx+rax*1-0x40],ymm1
  222978:	c5 fc 11 54 03 e0    	vmovups YMMWORD PTR [rbx+rax*1-0x20],ymm2
  22297e:	c5 fc 11 1c 03       	vmovups YMMWORD PTR [rbx+rax*1],ymm3
    for (source) |s, i|
  222983:	48 05 00 02 00 00    	add    rax,0x200
  222989:	48 83 c6 04          	add    rsi,0x4
  22298d:	0f 85 ed fe ff ff    	jne    222880 <join.97+0x460>
  222993:	48 85 ff             	test   rdi,rdi
  222996:	74 44                	je     2229dc <join.97+0x5bc>
  222998:	48 83 c0 60          	add    rax,0x60
  22299c:	48 f7 df             	neg    rdi
  22299f:	90                   	nop
  2229a0:	c5 fc 10 44 01 a0    	vmovups ymm0,YMMWORD PTR [rcx+rax*1-0x60]
  2229a6:	c5 fc 10 4c 01 c0    	vmovups ymm1,YMMWORD PTR [rcx+rax*1-0x40]
  2229ac:	c5 fc 10 54 01 e0    	vmovups ymm2,YMMWORD PTR [rcx+rax*1-0x20]
  2229b2:	c5 fc 10 1c 01       	vmovups ymm3,YMMWORD PTR [rcx+rax*1]
        dest[i] = s;
  2229b7:	c4 c1 7c 11 44 01 a0 	vmovups YMMWORD PTR [r9+rax*1-0x60],ymm0
  2229be:	c4 c1 7c 11 4c 01 c0 	vmovups YMMWORD PTR [r9+rax*1-0x40],ymm1
  2229c5:	c4 c1 7c 11 54 01 e0 	vmovups YMMWORD PTR [r9+rax*1-0x20],ymm2
  2229cc:	c4 c1 7c 11 1c 01    	vmovups YMMWORD PTR [r9+rax*1],ymm3
    for (source) |s, i|
  2229d2:	48 83 e8 80          	sub    rax,0xffffffffffffff80
  2229d6:	48 83 c7 01          	add    rdi,0x1
  2229da:	75 c4                	jne    2229a0 <join.97+0x580>
  2229dc:	49 39 d6             	cmp    r14,rdx
  2229df:	0f 85 ac fd ff ff    	jne    222791 <join.97+0x371>
        if (n == 0) {
  2229e5:	4d 01 c6             	add    r14,r8
  2229e8:	74 40                	je     222a2a <join.97+0x60a>
        assert(n <= old_mem.len);
  2229ea:	4d 39 f5             	cmp    r13,r14
  2229ed:	0f 82 8c 00 00 00    	jb     222a7f <join.97+0x65f>
        const byte_slice = self.reallocFn(self, @sliceToBytes(old_mem), byte_count, alignment) catch unreachable;
  2229f3:	49 8b 42 08          	mov    rax,QWORD PTR [r10+0x8]
  2229f7:	48 89 6c 24 20       	mov    QWORD PTR [rsp+0x20],rbp
  2229fc:	4c 89 6c 24 28       	mov    QWORD PTR [rsp+0x28],r13
  222a01:	48 8d 7c 24 08       	lea    rdi,[rsp+0x8]
  222a06:	48 8d 54 24 20       	lea    rdx,[rsp+0x20]
  222a0b:	41 b8 01 00 00 00    	mov    r8d,0x1
  222a11:	4c 89 d6             	mov    rsi,r10
  222a14:	4c 89 f1             	mov    rcx,r14
  222a17:	c5 f8 77             	vzeroupper 
  222a1a:	ff d0                	call   rax
        assert(byte_slice.len == byte_count);
  222a1c:	4c 39 74 24 18       	cmp    QWORD PTR [rsp+0x18],r14
  222a21:	75 5c                	jne    222a7f <join.97+0x65f>
        const byte_slice = self.reallocFn(self, @sliceToBytes(old_mem), byte_count, alignment) catch unreachable;
  222a23:	48 8b 6c 24 10       	mov    rbp,QWORD PTR [rsp+0x10]
  222a28:	eb 23                	jmp    222a4d <join.97+0x62d>
        if (bytes.len == 0) return;
  222a2a:	4d 85 ed             	test   r13,r13
  222a2d:	74 1b                	je     222a4a <join.97+0x62a>
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  222a2f:	49 8b 42 10          	mov    rax,QWORD PTR [r10+0x10]
  222a33:	48 89 6c 24 30       	mov    QWORD PTR [rsp+0x30],rbp
  222a38:	4c 89 6c 24 38       	mov    QWORD PTR [rsp+0x38],r13
  222a3d:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
  222a42:	4c 89 d7             	mov    rdi,r10
  222a45:	c5 f8 77             	vzeroupper 
  222a48:	ff d0                	call   rax
  222a4a:	45 31 f6             	xor    r14d,r14d
    return allocator.shrink(u8, buf, buf_index);
  222a4d:	66 41 c7 07 00 00    	mov    WORD PTR [r15],0x0
  222a53:	0f b7 44 24 06       	movzx  eax,WORD PTR [rsp+0x6]
  222a58:	66 41 89 47 06       	mov    WORD PTR [r15+0x6],ax
  222a5d:	8b 44 24 02          	mov    eax,DWORD PTR [rsp+0x2]
  222a61:	41 89 47 02          	mov    DWORD PTR [r15+0x2],eax
  222a65:	49 89 6f 08          	mov    QWORD PTR [r15+0x8],rbp
  222a69:	4d 89 77 10          	mov    QWORD PTR [r15+0x10],r14
  222a6d:	48 83 c4 58          	add    rsp,0x58
  222a71:	5b                   	pop    rbx
  222a72:	41 5c                	pop    r12
  222a74:	41 5d                	pop    r13
  222a76:	41 5e                	pop    r14
  222a78:	41 5f                	pop    r15
  222a7a:	5d                   	pop    rbp
  222a7b:	c5 f8 77             	vzeroupper 
  222a7e:	c3                   	ret    
            @panic("assertion failure");
  222a7f:	c5 f8 77             	vzeroupper 
  222a82:	e8 59 1b ff ff       	call   2145e0 <panic>
  222a87:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  222a8e:	00 00 

0000000000222a90 <DirectAllocator_alloc>:
    fn alloc(allocator: *Allocator, n: usize, alignment: u29) ![]u8 {
  222a90:	41 57                	push   r15
  222a92:	41 56                	push   r14
  222a94:	41 55                	push   r13
  222a96:	41 54                	push   r12
  222a98:	53                   	push   rbx
  222a99:	48 83 ec 10          	sub    rsp,0x10
  222a9d:	41 89 cc             	mov    r12d,ecx
  222aa0:	49 89 d6             	mov    r14,rdx
  222aa3:	49 89 ff             	mov    r15,rdi
  222aa6:	45 89 e5             	mov    r13d,r12d
  222aa9:	41 81 e5 ff ff ff 1f 	and    r13d,0x1fffffff
                const alloc_size = if (alignment <= os.page_size) n else n + alignment;
  222ab0:	31 c0                	xor    eax,eax
  222ab2:	41 81 fd 01 10 00 00 	cmp    r13d,0x1001
  222ab9:	4c 89 eb             	mov    rbx,r13
  222abc:	48 0f 42 d8          	cmovb  rbx,rax
  222ac0:	4a 8d 34 33          	lea    rsi,[rbx+r14*1]
    arg3: usize,
    arg4: usize,
    arg5: usize,
    arg6: usize,
) usize {
    return asm volatile ("syscall"
  222ac4:	b8 09 00 00 00       	mov    eax,0x9
  222ac9:	bf 00 00 00 00       	mov    edi,0x0
  222ace:	ba 03 00 00 00       	mov    edx,0x3
  222ad3:	41 ba 22 00 00 00    	mov    r10d,0x22
  222ad9:	49 c7 c0 ff ff ff ff 	mov    r8,0xffffffffffffffff
  222ae0:	45 31 c9             	xor    r9d,r9d
  222ae3:	0f 05                	syscall 
  222ae5:	48 89 c1             	mov    rcx,rax
                if (addr == p.MAP_FAILED) return error.OutOfMemory;
  222ae8:	48 83 f9 ff          	cmp    rcx,0xffffffffffffffff
  222aec:	74 55                	je     222b43 <DirectAllocator_alloc+0xb3>
                if (alloc_size == n) return @intToPtr([*]u8, addr)[0..n];
  222aee:	48 85 db             	test   rbx,rbx
  222af1:	74 6a                	je     222b5d <DirectAllocator_alloc+0xcd>
                const aligned_addr = (addr & ~usize(alignment - 1)) + alignment;
  222af3:	41 81 c4 ff ff ff 1f 	add    r12d,0x1fffffff
  222afa:	41 f7 d4             	not    r12d
  222afd:	49 81 cc 00 00 00 e0 	or     r12,0xffffffffe0000000
  222b04:	49 21 cc             	and    r12,rcx
  222b07:	4d 01 ec             	add    r12,r13
                const unused_len = aligned_addr - 1 - unused_start;
  222b0a:	48 89 ce             	mov    rsi,rcx
  222b0d:	48 f7 d6             	not    rsi
  222b10:	4c 01 e6             	add    rsi,r12
    return asm volatile ("syscall"
  222b13:	b8 0b 00 00 00       	mov    eax,0xb
  222b18:	48 89 cf             	mov    rdi,rcx
  222b1b:	0f 05                	syscall 
  222b1d:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
    if (!ok) {
  222b23:	73 69                	jae    222b8e <DirectAllocator_alloc+0xfe>
                return @intToPtr([*]u8, aligned_addr)[0..n];
  222b25:	66 41 c7 07 00 00    	mov    WORD PTR [r15],0x0
  222b2b:	0f b7 44 24 08       	movzx  eax,WORD PTR [rsp+0x8]
  222b30:	66 41 89 47 06       	mov    WORD PTR [r15+0x6],ax
  222b35:	8b 44 24 04          	mov    eax,DWORD PTR [rsp+0x4]
  222b39:	41 89 47 02          	mov    DWORD PTR [r15+0x2],eax
  222b3d:	4d 89 67 08          	mov    QWORD PTR [r15+0x8],r12
  222b41:	eb 36                	jmp    222b79 <DirectAllocator_alloc+0xe9>
                if (addr == p.MAP_FAILED) return error.OutOfMemory;
  222b43:	48 8b 05 4e 69 fe ff 	mov    rax,QWORD PTR [rip+0xfffffffffffe694e]        # 209498 <__unnamed_1+0x10>
  222b4a:	49 89 47 10          	mov    QWORD PTR [r15+0x10],rax
  222b4e:	c5 f8 10 05 32 69 fe 	vmovups xmm0,XMMWORD PTR [rip+0xfffffffffffe6932]        # 209488 <__unnamed_1>
  222b55:	ff 
  222b56:	c4 c1 78 11 07       	vmovups XMMWORD PTR [r15],xmm0
  222b5b:	eb 20                	jmp    222b7d <DirectAllocator_alloc+0xed>
                if (alloc_size == n) return @intToPtr([*]u8, addr)[0..n];
  222b5d:	66 41 c7 07 00 00    	mov    WORD PTR [r15],0x0
  222b63:	0f b7 44 24 0e       	movzx  eax,WORD PTR [rsp+0xe]
  222b68:	66 41 89 47 06       	mov    WORD PTR [r15+0x6],ax
  222b6d:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  222b71:	41 89 47 02          	mov    DWORD PTR [r15+0x2],eax
  222b75:	49 89 4f 08          	mov    QWORD PTR [r15+0x8],rcx
  222b79:	4d 89 77 10          	mov    QWORD PTR [r15+0x10],r14
  222b7d:	4c 89 f8             	mov    rax,r15
  222b80:	48 83 c4 10          	add    rsp,0x10
  222b84:	5b                   	pop    rbx
  222b85:	41 5c                	pop    r12
  222b87:	41 5d                	pop    r13
  222b89:	41 5e                	pop    r14
  222b8b:	41 5f                	pop    r15
  222b8d:	c3                   	ret    
            @panic("assertion failure");
  222b8e:	e8 4d 1a ff ff       	call   2145e0 <panic>
  222b93:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  222b9a:	84 00 00 00 00 00 

0000000000222ba0 <DirectAllocator_realloc>:
    fn realloc(allocator: *Allocator, old_mem: []u8, new_size: usize, alignment: u29) ![]u8 {
  222ba0:	55                   	push   rbp
  222ba1:	41 57                	push   r15
  222ba3:	41 56                	push   r14
  222ba5:	41 55                	push   r13
  222ba7:	41 54                	push   r12
  222ba9:	53                   	push   rbx
  222baa:	48 83 ec 28          	sub    rsp,0x28
  222bae:	45 89 c4             	mov    r12d,r8d
  222bb1:	48 89 cb             	mov    rbx,rcx
  222bb4:	49 89 d6             	mov    r14,rdx
  222bb7:	49 89 ff             	mov    r15,rdi
                if (new_size <= old_mem.len) {
  222bba:	49 8b 76 08          	mov    rsi,QWORD PTR [r14+0x8]
  222bbe:	48 39 de             	cmp    rsi,rbx
  222bc1:	0f 83 c7 00 00 00    	jae    222c8e <DirectAllocator_realloc+0xee>
                const alloc_size = if (alignment <= os.page_size) n else n + alignment;
  222bc7:	45 89 e5             	mov    r13d,r12d
  222bca:	41 81 e5 ff ff ff 1f 	and    r13d,0x1fffffff
  222bd1:	31 c0                	xor    eax,eax
  222bd3:	41 81 fd 01 10 00 00 	cmp    r13d,0x1001
  222bda:	4c 89 ed             	mov    rbp,r13
  222bdd:	48 0f 42 e8          	cmovb  rbp,rax
  222be1:	48 8d 74 1d 00       	lea    rsi,[rbp+rbx*1+0x0]
    return asm volatile ("syscall"
  222be6:	b8 09 00 00 00       	mov    eax,0x9
  222beb:	bf 00 00 00 00       	mov    edi,0x0
  222bf0:	ba 03 00 00 00       	mov    edx,0x3
  222bf5:	41 ba 22 00 00 00    	mov    r10d,0x22
  222bfb:	49 c7 c0 ff ff ff ff 	mov    r8,0xffffffffffffffff
  222c02:	45 31 c9             	xor    r9d,r9d
  222c05:	0f 05                	syscall 
  222c07:	48 89 c1             	mov    rcx,rax
                if (addr == p.MAP_FAILED) return error.OutOfMemory;
  222c0a:	48 83 f9 ff          	cmp    rcx,0xffffffffffffffff
  222c0e:	0f 84 d2 00 00 00    	je     222ce6 <DirectAllocator_realloc+0x146>
                if (alloc_size == n) return @intToPtr([*]u8, addr)[0..n];
  222c14:	48 85 ed             	test   rbp,rbp
  222c17:	74 39                	je     222c52 <DirectAllocator_realloc+0xb2>
                const aligned_addr = (addr & ~usize(alignment - 1)) + alignment;
  222c19:	41 81 c4 ff ff ff 1f 	add    r12d,0x1fffffff
  222c20:	41 f7 d4             	not    r12d
  222c23:	49 81 cc 00 00 00 e0 	or     r12,0xffffffffe0000000
  222c2a:	49 21 cc             	and    r12,rcx
  222c2d:	4d 01 ec             	add    r12,r13
                const unused_len = aligned_addr - 1 - unused_start;
  222c30:	48 89 ce             	mov    rsi,rcx
  222c33:	48 f7 d6             	not    rsi
  222c36:	4c 01 e6             	add    rsi,r12
    return asm volatile ("syscall"
  222c39:	b8 0b 00 00 00       	mov    eax,0xb
  222c3e:	48 89 cf             	mov    rdi,rcx
  222c41:	0f 05                	syscall 
  222c43:	4c 89 e1             	mov    rcx,r12
  222c46:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
    if (!ok) {
  222c4c:	0f 83 74 01 00 00    	jae    222dc6 <DirectAllocator_realloc+0x226>
    assert(dest.len >= source.len);
  222c52:	49 8b 76 08          	mov    rsi,QWORD PTR [r14+0x8]
  222c56:	48 89 dd             	mov    rbp,rbx
  222c59:	48 39 de             	cmp    rsi,rbx
  222c5c:	0f 87 64 01 00 00    	ja     222dc6 <DirectAllocator_realloc+0x226>
    for (source) |s, i|
  222c62:	48 85 f6             	test   rsi,rsi
  222c65:	0f 84 29 01 00 00    	je     222d94 <DirectAllocator_realloc+0x1f4>
  222c6b:	48 8d 56 ff          	lea    rdx,[rsi-0x1]
  222c6f:	89 f0                	mov    eax,esi
  222c71:	83 e0 07             	and    eax,0x7
  222c74:	48 83 fa 07          	cmp    rdx,0x7
  222c78:	0f 83 88 00 00 00    	jae    222d06 <DirectAllocator_realloc+0x166>
  222c7e:	31 d2                	xor    edx,edx
  222c80:	48 85 c0             	test   rax,rax
  222c83:	0f 85 f3 00 00 00    	jne    222d7c <DirectAllocator_realloc+0x1dc>
  222c89:	e9 06 01 00 00       	jmp    222d94 <DirectAllocator_realloc+0x1f4>
                    const base_addr = @ptrToInt(old_mem.ptr);
  222c8e:	49 8b 06             	mov    rax,QWORD PTR [r14]
                    const old_addr_end = base_addr + old_mem.len;
  222c91:	48 01 c6             	add    rsi,rax
                    const new_addr_end = base_addr + new_size;
  222c94:	48 8d 0c 18          	lea    rcx,[rax+rbx*1]
                    const rem = @rem(new_addr_end, os.page_size);
  222c98:	89 ca                	mov    edx,ecx
  222c9a:	81 e2 ff 0f 00 00    	and    edx,0xfff
                    const new_addr_end_rounded = new_addr_end + if (rem == 0) 0 else (os.page_size - rem);
  222ca0:	bf 00 10 00 00       	mov    edi,0x1000
  222ca5:	48 29 d7             	sub    rdi,rdx
  222ca8:	48 85 d2             	test   rdx,rdx
  222cab:	48 0f 44 fa          	cmove  rdi,rdx
  222caf:	48 01 cf             	add    rdi,rcx
                    if (old_addr_end > new_addr_end_rounded) {
  222cb2:	48 29 fe             	sub    rsi,rdi
  222cb5:	76 0a                	jbe    222cc1 <DirectAllocator_realloc+0x121>
  222cb7:	b8 0b 00 00 00       	mov    eax,0xb
  222cbc:	0f 05                	syscall 
                    return old_mem[0..new_size];
  222cbe:	49 8b 06             	mov    rax,QWORD PTR [r14]
  222cc1:	66 41 c7 07 00 00    	mov    WORD PTR [r15],0x0
  222cc7:	0f b7 4c 24 10       	movzx  ecx,WORD PTR [rsp+0x10]
  222ccc:	66 41 89 4f 06       	mov    WORD PTR [r15+0x6],cx
  222cd1:	8b 4c 24 0c          	mov    ecx,DWORD PTR [rsp+0xc]
  222cd5:	41 89 4f 02          	mov    DWORD PTR [r15+0x2],ecx
  222cd9:	49 89 47 08          	mov    QWORD PTR [r15+0x8],rax
  222cdd:	49 89 5f 10          	mov    QWORD PTR [r15+0x10],rbx
  222ce1:	e9 ce 00 00 00       	jmp    222db4 <DirectAllocator_realloc+0x214>
                const result = try alloc(allocator, new_size, alignment);
  222ce6:	66 41 c7 07 01 00    	mov    WORD PTR [r15],0x1
  222cec:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
  222cf1:	49 89 47 10          	mov    QWORD PTR [r15+0x10],rax
  222cf5:	c5 f8 10 44 24 12    	vmovups xmm0,XMMWORD PTR [rsp+0x12]
  222cfb:	c4 c1 78 11 47 02    	vmovups XMMWORD PTR [r15+0x2],xmm0
  222d01:	e9 ae 00 00 00       	jmp    222db4 <DirectAllocator_realloc+0x214>
  222d06:	48 29 c6             	sub    rsi,rax
  222d09:	31 d2                	xor    edx,edx
  222d0b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  222d10:	49 8b 3e             	mov    rdi,QWORD PTR [r14]
  222d13:	0f b6 1c 17          	movzx  ebx,BYTE PTR [rdi+rdx*1]
        dest[i] = s;
  222d17:	88 1c 11             	mov    BYTE PTR [rcx+rdx*1],bl
    for (source) |s, i|
  222d1a:	49 8b 3e             	mov    rdi,QWORD PTR [r14]
  222d1d:	0f b6 5c 17 01       	movzx  ebx,BYTE PTR [rdi+rdx*1+0x1]
        dest[i] = s;
  222d22:	88 5c 11 01          	mov    BYTE PTR [rcx+rdx*1+0x1],bl
    for (source) |s, i|
  222d26:	49 8b 3e             	mov    rdi,QWORD PTR [r14]
  222d29:	0f b6 5c 17 02       	movzx  ebx,BYTE PTR [rdi+rdx*1+0x2]
        dest[i] = s;
  222d2e:	88 5c 11 02          	mov    BYTE PTR [rcx+rdx*1+0x2],bl
    for (source) |s, i|
  222d32:	49 8b 3e             	mov    rdi,QWORD PTR [r14]
  222d35:	0f b6 5c 17 03       	movzx  ebx,BYTE PTR [rdi+rdx*1+0x3]
        dest[i] = s;
  222d3a:	88 5c 11 03          	mov    BYTE PTR [rcx+rdx*1+0x3],bl
    for (source) |s, i|
  222d3e:	49 8b 3e             	mov    rdi,QWORD PTR [r14]
  222d41:	0f b6 5c 17 04       	movzx  ebx,BYTE PTR [rdi+rdx*1+0x4]
        dest[i] = s;
  222d46:	88 5c 11 04          	mov    BYTE PTR [rcx+rdx*1+0x4],bl
    for (source) |s, i|
  222d4a:	49 8b 3e             	mov    rdi,QWORD PTR [r14]
  222d4d:	0f b6 5c 17 05       	movzx  ebx,BYTE PTR [rdi+rdx*1+0x5]
        dest[i] = s;
  222d52:	88 5c 11 05          	mov    BYTE PTR [rcx+rdx*1+0x5],bl
    for (source) |s, i|
  222d56:	49 8b 3e             	mov    rdi,QWORD PTR [r14]
  222d59:	0f b6 5c 17 06       	movzx  ebx,BYTE PTR [rdi+rdx*1+0x6]
        dest[i] = s;
  222d5e:	88 5c 11 06          	mov    BYTE PTR [rcx+rdx*1+0x6],bl
    for (source) |s, i|
  222d62:	49 8b 3e             	mov    rdi,QWORD PTR [r14]
  222d65:	0f b6 5c 17 07       	movzx  ebx,BYTE PTR [rdi+rdx*1+0x7]
        dest[i] = s;
  222d6a:	88 5c 11 07          	mov    BYTE PTR [rcx+rdx*1+0x7],bl
    for (source) |s, i|
  222d6e:	48 83 c2 08          	add    rdx,0x8
  222d72:	48 39 d6             	cmp    rsi,rdx
  222d75:	75 99                	jne    222d10 <DirectAllocator_realloc+0x170>
  222d77:	48 85 c0             	test   rax,rax
  222d7a:	74 18                	je     222d94 <DirectAllocator_realloc+0x1f4>
  222d7c:	48 f7 d8             	neg    rax
  222d7f:	90                   	nop
  222d80:	49 8b 36             	mov    rsi,QWORD PTR [r14]
  222d83:	0f b6 1c 16          	movzx  ebx,BYTE PTR [rsi+rdx*1]
        dest[i] = s;
  222d87:	88 1c 11             	mov    BYTE PTR [rcx+rdx*1],bl
    for (source) |s, i|
  222d8a:	48 83 c2 01          	add    rdx,0x1
  222d8e:	48 83 c0 01          	add    rax,0x1
  222d92:	75 ec                	jne    222d80 <DirectAllocator_realloc+0x1e0>
                return result;
  222d94:	66 41 c7 07 00 00    	mov    WORD PTR [r15],0x0
  222d9a:	0f b7 44 24 0a       	movzx  eax,WORD PTR [rsp+0xa]
  222d9f:	66 41 89 47 06       	mov    WORD PTR [r15+0x6],ax
  222da4:	8b 44 24 06          	mov    eax,DWORD PTR [rsp+0x6]
  222da8:	41 89 47 02          	mov    DWORD PTR [r15+0x2],eax
  222dac:	49 89 4f 08          	mov    QWORD PTR [r15+0x8],rcx
  222db0:	49 89 6f 10          	mov    QWORD PTR [r15+0x10],rbp
  222db4:	4c 89 f8             	mov    rax,r15
  222db7:	48 83 c4 28          	add    rsp,0x28
  222dbb:	5b                   	pop    rbx
  222dbc:	41 5c                	pop    r12
  222dbe:	41 5d                	pop    r13
  222dc0:	41 5e                	pop    r14
  222dc2:	41 5f                	pop    r15
  222dc4:	5d                   	pop    rbp
  222dc5:	c3                   	ret    
            @panic("assertion failure");
  222dc6:	e8 15 18 ff ff       	call   2145e0 <panic>
  222dcb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000222dd0 <DirectAllocator_free>:
                _ = os.posix.munmap(@ptrToInt(bytes.ptr), bytes.len);
  222dd0:	48 8b 3e             	mov    rdi,QWORD PTR [rsi]
  222dd3:	48 8b 76 08          	mov    rsi,QWORD PTR [rsi+0x8]
  222dd7:	b8 0b 00 00 00       	mov    eax,0xb
  222ddc:	0f 05                	syscall 
    fn free(allocator: *Allocator, bytes: []u8) void {
  222dde:	c3                   	ret    
  222ddf:	90                   	nop

0000000000222de0 <ArenaAllocator_alloc>:
    fn alloc(allocator: *Allocator, n: usize, alignment: u29) ![]u8 {
  222de0:	55                   	push   rbp
  222de1:	41 57                	push   r15
  222de3:	41 56                	push   r14
  222de5:	41 55                	push   r13
  222de7:	41 54                	push   r12
  222de9:	53                   	push   rbx
  222dea:	48 83 ec 58          	sub    rsp,0x58
  222dee:	89 cb                	mov    ebx,ecx
  222df0:	49 89 d7             	mov    r15,rdx
  222df3:	49 89 f4             	mov    r12,rsi
  222df6:	49 89 fe             	mov    r14,rdi
        var cur_node = if (self.buffer_list.last) |last_node| last_node else try self.createNode(0, n + alignment);
  222df9:	49 8b 44 24 28       	mov    rax,QWORD PTR [r12+0x28]
  222dfe:	81 e3 ff ff ff 1f    	and    ebx,0x1fffffff
  222e04:	4e 8d 2c 3b          	lea    r13,[rbx+r15*1]
  222e08:	48 85 c0             	test   rax,rax
  222e0b:	74 29                	je     222e36 <ArenaAllocator_alloc+0x56>
            const cur_buf = cur_node.data[@sizeOf(BufNode)..];
  222e0d:	48 8b 70 10          	mov    rsi,QWORD PTR [rax+0x10]
  222e11:	48 8b 48 18          	mov    rcx,QWORD PTR [rax+0x18]
  222e15:	48 83 c1 e0          	add    rcx,0xffffffffffffffe0
            const addr = @ptrToInt(cur_buf.ptr) + self.end_index;
  222e19:	49 8b 7c 24 38       	mov    rdi,QWORD PTR [r12+0x38]
  222e1e:	48 8d 04 37          	lea    rax,[rdi+rsi*1]
  222e22:	48 83 c0 20          	add    rax,0x20
  222e26:	48 89 c2             	mov    rdx,rax
  222e29:	48 c1 ea 20          	shr    rdx,0x20
  222e2d:	74 3f                	je     222e6e <ArenaAllocator_alloc+0x8e>
  222e2f:	31 d2                	xor    edx,edx
  222e31:	48 f7 f3             	div    rbx
  222e34:	eb 3c                	jmp    222e72 <ArenaAllocator_alloc+0x92>
  222e36:	48 8d 7c 24 18       	lea    rdi,[rsp+0x18]
        var cur_node = if (self.buffer_list.last) |last_node| last_node else try self.createNode(0, n + alignment);
  222e3b:	31 d2                	xor    edx,edx
  222e3d:	4c 89 e6             	mov    rsi,r12
  222e40:	4c 89 e9             	mov    rcx,r13
  222e43:	e8 68 03 00 00       	call   2231b0 <ArenaAllocator_createNode>
  222e48:	0f b7 44 24 18       	movzx  eax,WORD PTR [rsp+0x18]
  222e4d:	66 85 c0             	test   ax,ax
  222e50:	0f 84 fe 00 00 00    	je     222f54 <ArenaAllocator_alloc+0x174>
  222e56:	66 41 89 06          	mov    WORD PTR [r14],ax
  222e5a:	48 8b 44 24 50       	mov    rax,QWORD PTR [rsp+0x50]
  222e5f:	49 89 46 10          	mov    QWORD PTR [r14+0x10],rax
  222e63:	c5 f8 10 44 24 42    	vmovups xmm0,XMMWORD PTR [rsp+0x42]
  222e69:	e9 ce 00 00 00       	jmp    222f3c <ArenaAllocator_alloc+0x15c>
  222e6e:	31 d2                	xor    edx,edx
  222e70:	f7 f3                	div    ebx
            const march_forward_bytes = if (rem == 0) 0 else (alignment - rem);
  222e72:	48 89 d8             	mov    rax,rbx
  222e75:	48 29 d0             	sub    rax,rdx
  222e78:	48 85 d2             	test   rdx,rdx
  222e7b:	48 0f 44 c2          	cmove  rax,rdx
            const adjusted_index = self.end_index + march_forward_bytes;
  222e7f:	48 01 f8             	add    rax,rdi
            const new_end_index = adjusted_index + n;
  222e82:	4a 8d 14 38          	lea    rdx,[rax+r15*1]
            if (new_end_index > cur_buf.len) {
  222e86:	48 39 ca             	cmp    rdx,rcx
  222e89:	76 72                	jbe    222efd <ArenaAllocator_alloc+0x11d>
  222e8b:	48 8d 6c 24 08       	lea    rbp,[rsp+0x8]
                cur_node = try self.createNode(cur_buf.len, n + alignment);
  222e90:	48 89 ef             	mov    rdi,rbp
  222e93:	4c 89 e6             	mov    rsi,r12
  222e96:	48 89 ca             	mov    rdx,rcx
  222e99:	4c 89 e9             	mov    rcx,r13
  222e9c:	e8 0f 03 00 00       	call   2231b0 <ArenaAllocator_createNode>
  222ea1:	0f b7 44 24 08       	movzx  eax,WORD PTR [rsp+0x8]
  222ea6:	66 85 c0             	test   ax,ax
  222ea9:	75 7e                	jne    222f29 <ArenaAllocator_alloc+0x149>
  222eab:	48 8b 44 24 10       	mov    rax,QWORD PTR [rsp+0x10]
            const cur_buf = cur_node.data[@sizeOf(BufNode)..];
  222eb0:	48 8b 70 10          	mov    rsi,QWORD PTR [rax+0x10]
  222eb4:	48 8b 48 18          	mov    rcx,QWORD PTR [rax+0x18]
  222eb8:	48 83 c1 e0          	add    rcx,0xffffffffffffffe0
            const addr = @ptrToInt(cur_buf.ptr) + self.end_index;
  222ebc:	49 8b 7c 24 38       	mov    rdi,QWORD PTR [r12+0x38]
  222ec1:	48 8d 04 37          	lea    rax,[rdi+rsi*1]
  222ec5:	48 83 c0 20          	add    rax,0x20
  222ec9:	48 89 c2             	mov    rdx,rax
  222ecc:	48 c1 ea 20          	shr    rdx,0x20
  222ed0:	74 0e                	je     222ee0 <ArenaAllocator_alloc+0x100>
  222ed2:	31 d2                	xor    edx,edx
  222ed4:	48 f7 f3             	div    rbx
  222ed7:	eb 0b                	jmp    222ee4 <ArenaAllocator_alloc+0x104>
  222ed9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  222ee0:	31 d2                	xor    edx,edx
  222ee2:	f7 f3                	div    ebx
            const march_forward_bytes = if (rem == 0) 0 else (alignment - rem);
  222ee4:	48 89 d8             	mov    rax,rbx
  222ee7:	48 29 d0             	sub    rax,rdx
  222eea:	48 85 d2             	test   rdx,rdx
  222eed:	48 0f 44 c2          	cmove  rax,rdx
            const adjusted_index = self.end_index + march_forward_bytes;
  222ef1:	48 01 f8             	add    rax,rdi
            const new_end_index = adjusted_index + n;
  222ef4:	4a 8d 14 38          	lea    rdx,[rax+r15*1]
            if (new_end_index > cur_buf.len) {
  222ef8:	48 39 ca             	cmp    rdx,rcx
  222efb:	77 93                	ja     222e90 <ArenaAllocator_alloc+0xb0>
            self.end_index = new_end_index;
  222efd:	49 89 54 24 38       	mov    QWORD PTR [r12+0x38],rdx
            return result;
  222f02:	66 41 c7 06 00 00    	mov    WORD PTR [r14],0x0
  222f08:	0f b7 4c 24 06       	movzx  ecx,WORD PTR [rsp+0x6]
  222f0d:	66 41 89 4e 06       	mov    WORD PTR [r14+0x6],cx
            const result = cur_buf[adjusted_index..new_end_index];
  222f12:	48 8d 44 06 20       	lea    rax,[rsi+rax*1+0x20]
            return result;
  222f17:	8b 4c 24 02          	mov    ecx,DWORD PTR [rsp+0x2]
  222f1b:	41 89 4e 02          	mov    DWORD PTR [r14+0x2],ecx
  222f1f:	49 89 46 08          	mov    QWORD PTR [r14+0x8],rax
  222f23:	4d 89 7e 10          	mov    QWORD PTR [r14+0x10],r15
  222f27:	eb 19                	jmp    222f42 <ArenaAllocator_alloc+0x162>
                cur_node = try self.createNode(cur_buf.len, n + alignment);
  222f29:	66 41 89 06          	mov    WORD PTR [r14],ax
  222f2d:	48 8b 44 24 3a       	mov    rax,QWORD PTR [rsp+0x3a]
  222f32:	49 89 46 10          	mov    QWORD PTR [r14+0x10],rax
  222f36:	c5 f8 10 44 24 2c    	vmovups xmm0,XMMWORD PTR [rsp+0x2c]
  222f3c:	c4 c1 78 11 46 02    	vmovups XMMWORD PTR [r14+0x2],xmm0
  222f42:	4c 89 f0             	mov    rax,r14
  222f45:	48 83 c4 58          	add    rsp,0x58
  222f49:	5b                   	pop    rbx
  222f4a:	41 5c                	pop    r12
  222f4c:	41 5d                	pop    r13
  222f4e:	41 5e                	pop    r14
  222f50:	41 5f                	pop    r15
  222f52:	5d                   	pop    rbp
  222f53:	c3                   	ret    
        var cur_node = if (self.buffer_list.last) |last_node| last_node else try self.createNode(0, n + alignment);
  222f54:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
  222f59:	e9 af fe ff ff       	jmp    222e0d <ArenaAllocator_alloc+0x2d>
  222f5e:	66 90                	xchg   ax,ax

0000000000222f60 <ArenaAllocator_realloc>:
    fn realloc(allocator: *Allocator, old_mem: []u8, new_size: usize, alignment: u29) ![]u8 {
  222f60:	55                   	push   rbp
  222f61:	41 57                	push   r15
  222f63:	41 56                	push   r14
  222f65:	41 55                	push   r13
  222f67:	41 54                	push   r12
  222f69:	53                   	push   rbx
  222f6a:	48 83 ec 58          	sub    rsp,0x58
  222f6e:	45 89 c5             	mov    r13d,r8d
  222f71:	49 89 cf             	mov    r15,rcx
  222f74:	48 89 d3             	mov    rbx,rdx
  222f77:	49 89 f4             	mov    r12,rsi
  222f7a:	48 89 fd             	mov    rbp,rdi
        if (new_size <= old_mem.len) {
  222f7d:	4c 39 7b 08          	cmp    QWORD PTR [rbx+0x8],r15
  222f81:	73 43                	jae    222fc6 <ArenaAllocator_realloc+0x66>
        var cur_node = if (self.buffer_list.last) |last_node| last_node else try self.createNode(0, n + alignment);
  222f83:	49 8b 44 24 28       	mov    rax,QWORD PTR [r12+0x28]
  222f88:	41 81 e5 ff ff ff 1f 	and    r13d,0x1fffffff
  222f8f:	4f 8d 34 2f          	lea    r14,[r15+r13*1]
  222f93:	48 85 c0             	test   rax,rax
  222f96:	74 54                	je     222fec <ArenaAllocator_realloc+0x8c>
            const cur_buf = cur_node.data[@sizeOf(BufNode)..];
  222f98:	48 8b 70 10          	mov    rsi,QWORD PTR [rax+0x10]
  222f9c:	48 8b 48 18          	mov    rcx,QWORD PTR [rax+0x18]
  222fa0:	48 83 c1 e0          	add    rcx,0xffffffffffffffe0
            const addr = @ptrToInt(cur_buf.ptr) + self.end_index;
  222fa4:	49 8b 7c 24 38       	mov    rdi,QWORD PTR [r12+0x38]
  222fa9:	48 8d 04 37          	lea    rax,[rdi+rsi*1]
  222fad:	48 83 c0 20          	add    rax,0x20
  222fb1:	48 89 c2             	mov    rdx,rax
  222fb4:	48 c1 ea 20          	shr    rdx,0x20
  222fb8:	48 89 6c 24 08       	mov    QWORD PTR [rsp+0x8],rbp
  222fbd:	75 77                	jne    223036 <ArenaAllocator_realloc+0xd6>
  222fbf:	31 d2                	xor    edx,edx
  222fc1:	41 f7 f5             	div    r13d
  222fc4:	eb 75                	jmp    22303b <ArenaAllocator_realloc+0xdb>
            return old_mem[0..new_size];
  222fc6:	48 8b 03             	mov    rax,QWORD PTR [rbx]
  222fc9:	66 c7 45 00 00 00    	mov    WORD PTR [rbp+0x0],0x0
  222fcf:	0f b7 4c 24 1e       	movzx  ecx,WORD PTR [rsp+0x1e]
  222fd4:	66 89 4d 06          	mov    WORD PTR [rbp+0x6],cx
  222fd8:	8b 4c 24 1a          	mov    ecx,DWORD PTR [rsp+0x1a]
  222fdc:	89 4d 02             	mov    DWORD PTR [rbp+0x2],ecx
  222fdf:	48 89 45 08          	mov    QWORD PTR [rbp+0x8],rax
  222fe3:	4c 89 7d 10          	mov    QWORD PTR [rbp+0x10],r15
  222fe7:	e9 a2 00 00 00       	jmp    22308e <ArenaAllocator_realloc+0x12e>
  222fec:	48 8d 7c 24 30       	lea    rdi,[rsp+0x30]
        var cur_node = if (self.buffer_list.last) |last_node| last_node else try self.createNode(0, n + alignment);
  222ff1:	31 d2                	xor    edx,edx
  222ff3:	4c 89 e6             	mov    rsi,r12
  222ff6:	4c 89 f1             	mov    rcx,r14
  222ff9:	e8 b2 01 00 00       	call   2231b0 <ArenaAllocator_createNode>
  222ffe:	0f b7 44 24 30       	movzx  eax,WORD PTR [rsp+0x30]
  223003:	66 85 c0             	test   ax,ax
  223006:	75 6e                	jne    223076 <ArenaAllocator_realloc+0x116>
  223008:	48 8b 44 24 38       	mov    rax,QWORD PTR [rsp+0x38]
  22300d:	eb 89                	jmp    222f98 <ArenaAllocator_realloc+0x38>
                cur_node = try self.createNode(cur_buf.len, n + alignment);
  22300f:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
            const cur_buf = cur_node.data[@sizeOf(BufNode)..];
  223014:	48 8b 70 10          	mov    rsi,QWORD PTR [rax+0x10]
  223018:	48 8b 48 18          	mov    rcx,QWORD PTR [rax+0x18]
  22301c:	48 83 c1 e0          	add    rcx,0xffffffffffffffe0
            const addr = @ptrToInt(cur_buf.ptr) + self.end_index;
  223020:	49 8b 7c 24 38       	mov    rdi,QWORD PTR [r12+0x38]
  223025:	48 8d 04 37          	lea    rax,[rdi+rsi*1]
  223029:	48 83 c0 20          	add    rax,0x20
  22302d:	48 89 c2             	mov    rdx,rax
  223030:	48 c1 ea 20          	shr    rdx,0x20
  223034:	74 89                	je     222fbf <ArenaAllocator_realloc+0x5f>
  223036:	31 d2                	xor    edx,edx
  223038:	49 f7 f5             	div    r13
            const march_forward_bytes = if (rem == 0) 0 else (alignment - rem);
  22303b:	4c 89 ed             	mov    rbp,r13
  22303e:	48 29 d5             	sub    rbp,rdx
  223041:	48 85 d2             	test   rdx,rdx
  223044:	48 0f 44 ea          	cmove  rbp,rdx
            const adjusted_index = self.end_index + march_forward_bytes;
  223048:	48 01 fd             	add    rbp,rdi
            const new_end_index = adjusted_index + n;
  22304b:	49 8d 04 2f          	lea    rax,[r15+rbp*1]
            if (new_end_index > cur_buf.len) {
  22304f:	48 39 c8             	cmp    rax,rcx
  223052:	76 42                	jbe    223096 <ArenaAllocator_realloc+0x136>
                cur_node = try self.createNode(cur_buf.len, n + alignment);
  223054:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  223059:	4c 89 e6             	mov    rsi,r12
  22305c:	48 89 ca             	mov    rdx,rcx
  22305f:	4c 89 f1             	mov    rcx,r14
  223062:	e8 49 01 00 00       	call   2231b0 <ArenaAllocator_createNode>
  223067:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  22306c:	66 85 c0             	test   ax,ax
  22306f:	74 9e                	je     22300f <ArenaAllocator_realloc+0xaf>
  223071:	48 8b 6c 24 08       	mov    rbp,QWORD PTR [rsp+0x8]
            const result = try alloc(allocator, new_size, alignment);
  223076:	66 89 45 00          	mov    WORD PTR [rbp+0x0],ax
  22307a:	48 8b 44 24 50       	mov    rax,QWORD PTR [rsp+0x50]
  22307f:	48 89 45 10          	mov    QWORD PTR [rbp+0x10],rax
  223083:	c5 f8 10 44 24 42    	vmovups xmm0,XMMWORD PTR [rsp+0x42]
  223089:	c5 f8 11 45 02       	vmovups XMMWORD PTR [rbp+0x2],xmm0
  22308e:	48 89 e8             	mov    rax,rbp
  223091:	e9 f1 00 00 00       	jmp    223187 <ArenaAllocator_realloc+0x227>
            self.end_index = new_end_index;
  223096:	49 89 44 24 38       	mov    QWORD PTR [r12+0x38],rax
    assert(dest.len >= source.len);
  22309b:	48 8b 7b 08          	mov    rdi,QWORD PTR [rbx+0x8]
  22309f:	4c 39 ff             	cmp    rdi,r15
    if (!ok) {
  2230a2:	0f 87 ee 00 00 00    	ja     223196 <ArenaAllocator_realloc+0x236>
  2230a8:	4c 8d 04 2e          	lea    r8,[rsi+rbp*1]
  2230ac:	49 83 c0 20          	add    r8,0x20
    for (source) |s, i|
  2230b0:	48 85 ff             	test   rdi,rdi
  2230b3:	0f 84 ac 00 00 00    	je     223165 <ArenaAllocator_realloc+0x205>
  2230b9:	48 8d 57 ff          	lea    rdx,[rdi-0x1]
  2230bd:	89 f9                	mov    ecx,edi
  2230bf:	83 e1 07             	and    ecx,0x7
  2230c2:	48 83 fa 07          	cmp    rdx,0x7
  2230c6:	73 0c                	jae    2230d4 <ArenaAllocator_realloc+0x174>
  2230c8:	31 d2                	xor    edx,edx
  2230ca:	48 85 c9             	test   rcx,rcx
  2230cd:	75 7e                	jne    22314d <ArenaAllocator_realloc+0x1ed>
  2230cf:	e9 91 00 00 00       	jmp    223165 <ArenaAllocator_realloc+0x205>
  2230d4:	48 29 cf             	sub    rdi,rcx
  2230d7:	48 01 ee             	add    rsi,rbp
  2230da:	48 83 c6 27          	add    rsi,0x27
  2230de:	31 d2                	xor    edx,edx
  2230e0:	48 8b 2b             	mov    rbp,QWORD PTR [rbx]
  2230e3:	0f b6 44 15 00       	movzx  eax,BYTE PTR [rbp+rdx*1+0x0]
        dest[i] = s;
  2230e8:	88 44 16 f9          	mov    BYTE PTR [rsi+rdx*1-0x7],al
    for (source) |s, i|
  2230ec:	48 8b 03             	mov    rax,QWORD PTR [rbx]
  2230ef:	0f b6 44 10 01       	movzx  eax,BYTE PTR [rax+rdx*1+0x1]
        dest[i] = s;
  2230f4:	88 44 16 fa          	mov    BYTE PTR [rsi+rdx*1-0x6],al
    for (source) |s, i|
  2230f8:	48 8b 03             	mov    rax,QWORD PTR [rbx]
  2230fb:	0f b6 44 10 02       	movzx  eax,BYTE PTR [rax+rdx*1+0x2]
        dest[i] = s;
  223100:	88 44 16 fb          	mov    BYTE PTR [rsi+rdx*1-0x5],al
    for (source) |s, i|
  223104:	48 8b 03             	mov    rax,QWORD PTR [rbx]
  223107:	0f b6 44 10 03       	movzx  eax,BYTE PTR [rax+rdx*1+0x3]
        dest[i] = s;
  22310c:	88 44 16 fc          	mov    BYTE PTR [rsi+rdx*1-0x4],al
    for (source) |s, i|
  223110:	48 8b 03             	mov    rax,QWORD PTR [rbx]
  223113:	0f b6 44 10 04       	movzx  eax,BYTE PTR [rax+rdx*1+0x4]
        dest[i] = s;
  223118:	88 44 16 fd          	mov    BYTE PTR [rsi+rdx*1-0x3],al
    for (source) |s, i|
  22311c:	48 8b 03             	mov    rax,QWORD PTR [rbx]
  22311f:	0f b6 44 10 05       	movzx  eax,BYTE PTR [rax+rdx*1+0x5]
        dest[i] = s;
  223124:	88 44 16 fe          	mov    BYTE PTR [rsi+rdx*1-0x2],al
    for (source) |s, i|
  223128:	48 8b 03             	mov    rax,QWORD PTR [rbx]
  22312b:	0f b6 44 10 06       	movzx  eax,BYTE PTR [rax+rdx*1+0x6]
        dest[i] = s;
  223130:	88 44 16 ff          	mov    BYTE PTR [rsi+rdx*1-0x1],al
    for (source) |s, i|
  223134:	48 8b 03             	mov    rax,QWORD PTR [rbx]
  223137:	0f b6 44 10 07       	movzx  eax,BYTE PTR [rax+rdx*1+0x7]
        dest[i] = s;
  22313c:	88 04 16             	mov    BYTE PTR [rsi+rdx*1],al
    for (source) |s, i|
  22313f:	48 83 c2 08          	add    rdx,0x8
  223143:	48 39 d7             	cmp    rdi,rdx
  223146:	75 98                	jne    2230e0 <ArenaAllocator_realloc+0x180>
  223148:	48 85 c9             	test   rcx,rcx
  22314b:	74 18                	je     223165 <ArenaAllocator_realloc+0x205>
  22314d:	48 f7 d9             	neg    rcx
  223150:	48 8b 03             	mov    rax,QWORD PTR [rbx]
  223153:	0f b6 04 10          	movzx  eax,BYTE PTR [rax+rdx*1]
        dest[i] = s;
  223157:	41 88 04 10          	mov    BYTE PTR [r8+rdx*1],al
    for (source) |s, i|
  22315b:	48 83 c2 01          	add    rdx,0x1
  22315f:	48 83 c1 01          	add    rcx,0x1
  223163:	75 eb                	jne    223150 <ArenaAllocator_realloc+0x1f0>
  223165:	48 8b 44 24 08       	mov    rax,QWORD PTR [rsp+0x8]
            return result;
  22316a:	66 c7 00 00 00       	mov    WORD PTR [rax],0x0
  22316f:	0f b7 4c 24 18       	movzx  ecx,WORD PTR [rsp+0x18]
  223174:	66 89 48 06          	mov    WORD PTR [rax+0x6],cx
  223178:	8b 4c 24 14          	mov    ecx,DWORD PTR [rsp+0x14]
  22317c:	89 48 02             	mov    DWORD PTR [rax+0x2],ecx
  22317f:	4c 89 40 08          	mov    QWORD PTR [rax+0x8],r8
  223183:	4c 89 78 10          	mov    QWORD PTR [rax+0x10],r15
  223187:	48 83 c4 58          	add    rsp,0x58
  22318b:	5b                   	pop    rbx
  22318c:	41 5c                	pop    r12
  22318e:	41 5d                	pop    r13
  223190:	41 5e                	pop    r14
  223192:	41 5f                	pop    r15
  223194:	5d                   	pop    rbp
  223195:	c3                   	ret    
            @panic("assertion failure");
  223196:	e8 45 14 ff ff       	call   2145e0 <panic>
  22319b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

00000000002231a0 <ArenaAllocator_free>:
    fn free(allocator: *Allocator, bytes: []u8) void {}
  2231a0:	c3                   	ret    
  2231a1:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  2231a8:	0f 1f 84 00 00 00 00 
  2231af:	00 

00000000002231b0 <ArenaAllocator_createNode>:
    fn createNode(self: *ArenaAllocator, prev_len: usize, minimum_size: usize) !*BufNode {
  2231b0:	41 57                	push   r15
  2231b2:	41 56                	push   r14
  2231b4:	53                   	push   rbx
  2231b5:	48 83 ec 30          	sub    rsp,0x30
  2231b9:	48 89 d3             	mov    rbx,rdx
  2231bc:	49 89 f6             	mov    r14,rsi
  2231bf:	49 89 ff             	mov    r15,rdi
        const actual_min_size = minimum_size + @sizeOf(BufNode);
  2231c2:	48 83 c1 20          	add    rcx,0x20
  2231c6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  2231cd:	00 00 00 
            len += len / 2;
  2231d0:	48 89 d8             	mov    rax,rbx
  2231d3:	48 d1 e8             	shr    rax,1
  2231d6:	48 01 d8             	add    rax,rbx
            len += os.page_size - @rem(len, os.page_size);
  2231d9:	89 c2                	mov    edx,eax
  2231db:	81 e2 ff 0f 00 00    	and    edx,0xfff
  2231e1:	bb 00 10 00 00       	mov    ebx,0x1000
  2231e6:	48 29 d3             	sub    rbx,rdx
  2231e9:	48 01 c3             	add    rbx,rax
            if (len >= actual_min_size) break;
  2231ec:	48 39 cb             	cmp    rbx,rcx
  2231ef:	72 df                	jb     2231d0 <ArenaAllocator_createNode+0x20>
        if (n == 0) {
  2231f1:	48 85 db             	test   rbx,rbx
  2231f4:	74 38                	je     22322e <ArenaAllocator_createNode+0x7e>
  2231f6:	49 8b 76 18          	mov    rsi,QWORD PTR [r14+0x18]
  2231fa:	48 8d 7c 24 08       	lea    rdi,[rsp+0x8]
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  2231ff:	b9 08 00 00 00       	mov    ecx,0x8
  223204:	48 89 da             	mov    rdx,rbx
  223207:	ff 16                	call   QWORD PTR [rsi]
  223209:	0f b7 44 24 08       	movzx  eax,WORD PTR [rsp+0x8]
  22320e:	66 85 c0             	test   ax,ax
  223211:	74 1f                	je     223232 <ArenaAllocator_createNode+0x82>
        const buf = try self.child_allocator.alignedAlloc(u8, @alignOf(BufNode), len);
  223213:	66 41 89 07          	mov    WORD PTR [r15],ax
  223217:	48 8b 44 24 22       	mov    rax,QWORD PTR [rsp+0x22]
  22321c:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  223221:	49 89 4f 08          	mov    QWORD PTR [r15+0x8],rcx
  223225:	49 89 47 02          	mov    QWORD PTR [r15+0x2],rax
  223229:	e9 c6 00 00 00       	jmp    2232f4 <ArenaAllocator_createNode+0x144>
  22322e:	31 db                	xor    ebx,ebx
  223230:	eb 10                	jmp    223242 <ArenaAllocator_createNode+0x92>
        assert(byte_slice.len == byte_count);
  223232:	48 39 5c 24 18       	cmp    QWORD PTR [rsp+0x18],rbx
    if (!ok) {
  223237:	0f 85 c1 00 00 00    	jne    2232fe <ArenaAllocator_createNode+0x14e>
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  22323d:	48 8b 44 24 10       	mov    rax,QWORD PTR [rsp+0x10]
        buf_node.* = BufNode{
  223242:	c5 f8 57 c0          	vxorps xmm0,xmm0,xmm0
  223246:	c5 f8 11 00          	vmovups XMMWORD PTR [rax],xmm0
  22324a:	48 89 40 10          	mov    QWORD PTR [rax+0x10],rax
  22324e:	48 89 58 18          	mov    QWORD PTR [rax+0x18],rbx
            if (list.last) |last| {
  223252:	49 8b 4e 28          	mov    rcx,QWORD PTR [r14+0x28]
  223256:	48 85 c9             	test   rcx,rcx
  223259:	74 12                	je     22326d <ArenaAllocator_createNode+0xbd>
            new_node.prev = node;
  22325b:	48 89 08             	mov    QWORD PTR [rax],rcx
            if (node.next) |next_node| {
  22325e:	48 8b 51 08          	mov    rdx,QWORD PTR [rcx+0x8]
  223262:	48 85 d2             	test   rdx,rdx
  223265:	74 24                	je     22328b <ArenaAllocator_createNode+0xdb>
                new_node.next = next_node;
  223267:	48 89 50 08          	mov    QWORD PTR [rax+0x8],rdx
  22326b:	eb 2a                	jmp    223297 <ArenaAllocator_createNode+0xe7>
            if (list.first) |first| {
  22326d:	49 8b 4e 20          	mov    rcx,QWORD PTR [r14+0x20]
  223271:	48 85 c9             	test   rcx,rcx
  223274:	74 2a                	je     2232a0 <ArenaAllocator_createNode+0xf0>
            new_node.next = node;
  223276:	48 89 48 08          	mov    QWORD PTR [rax+0x8],rcx
            if (node.prev) |prev_node| {
  22327a:	48 8b 11             	mov    rdx,QWORD PTR [rcx]
  22327d:	48 85 d2             	test   rdx,rdx
  223280:	74 38                	je     2232ba <ArenaAllocator_createNode+0x10a>
                new_node.prev = prev_node;
  223282:	48 89 10             	mov    QWORD PTR [rax],rdx
                prev_node.next = new_node;
  223285:	48 83 c2 08          	add    rdx,0x8
  223289:	eb 3a                	jmp    2232c5 <ArenaAllocator_createNode+0x115>
  22328b:	49 8d 56 28          	lea    rdx,[r14+0x28]
                new_node.next = null;
  22328f:	48 c7 40 08 00 00 00 	mov    QWORD PTR [rax+0x8],0x0
  223296:	00 
  223297:	48 89 02             	mov    QWORD PTR [rdx],rax
            node.next = new_node;
  22329a:	48 89 41 08          	mov    QWORD PTR [rcx+0x8],rax
  22329e:	eb 2b                	jmp    2232cb <ArenaAllocator_createNode+0x11b>
                list.first = new_node;
  2232a0:	49 89 46 20          	mov    QWORD PTR [r14+0x20],rax
                list.last = new_node;
  2232a4:	49 89 46 28          	mov    QWORD PTR [r14+0x28],rax
                new_node.next = null;
  2232a8:	c5 f8 57 c0          	vxorps xmm0,xmm0,xmm0
  2232ac:	c5 f8 11 00          	vmovups XMMWORD PTR [rax],xmm0
                list.len = 1;
  2232b0:	49 c7 46 30 01 00 00 	mov    QWORD PTR [r14+0x30],0x1
  2232b7:	00 
  2232b8:	eb 16                	jmp    2232d0 <ArenaAllocator_createNode+0x120>
  2232ba:	49 8d 56 20          	lea    rdx,[r14+0x20]
                new_node.prev = null;
  2232be:	48 c7 00 00 00 00 00 	mov    QWORD PTR [rax],0x0
  2232c5:	48 89 02             	mov    QWORD PTR [rdx],rax
            node.prev = new_node;
  2232c8:	48 89 01             	mov    QWORD PTR [rcx],rax
  2232cb:	49 83 46 30 01       	add    QWORD PTR [r14+0x30],0x1
        self.end_index = 0;
  2232d0:	49 c7 46 38 00 00 00 	mov    QWORD PTR [r14+0x38],0x0
  2232d7:	00 
        return buf_node;
  2232d8:	66 41 c7 07 00 00    	mov    WORD PTR [r15],0x0
  2232de:	0f b7 4c 24 06       	movzx  ecx,WORD PTR [rsp+0x6]
  2232e3:	66 41 89 4f 06       	mov    WORD PTR [r15+0x6],cx
  2232e8:	8b 4c 24 02          	mov    ecx,DWORD PTR [rsp+0x2]
  2232ec:	41 89 4f 02          	mov    DWORD PTR [r15+0x2],ecx
  2232f0:	49 89 47 08          	mov    QWORD PTR [r15+0x8],rax
  2232f4:	48 83 c4 30          	add    rsp,0x30
  2232f8:	5b                   	pop    rbx
  2232f9:	41 5e                	pop    r14
  2232fb:	41 5f                	pop    r15
  2232fd:	c3                   	ret    
            @panic("assertion failure");
  2232fe:	e8 dd 12 ff ff       	call   2145e0 <panic>
  223303:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  22330a:	84 00 00 00 00 00 

0000000000223310 <formatFloatDecimal>:
pub fn formatFloatDecimal(
  223310:	55                   	push   rbp
  223311:	41 57                	push   r15
  223313:	41 56                	push   r14
  223315:	41 55                	push   r13
  223317:	41 54                	push   r12
  223319:	53                   	push   rbx
  22331a:	48 81 ec f8 00 00 00 	sub    rsp,0xf8
  223321:	49 89 d0             	mov    r8,rdx
  223324:	49 89 f7             	mov    r15,rsi
  223327:	49 89 fe             	mov    r14,rdi
    const bits = @bitCast(u32, x);
    return bits >> 31 != 0;
}

fn signbit64(x: f64) bool {
    const bits = @bitCast(u64, x);
  22332a:	c4 e1 f9 7e c0       	vmovq  rax,xmm0
    return bits >> 63 != 0;
  22332f:	48 85 c0             	test   rax,rax
    if (math.signbit(x)) {
  223332:	78 47                	js     22337b <formatFloatDecimal+0x6b>
  223334:	48 b8 00 00 00 00 00 	movabs rax,0x7ff0000000000000
  22333b:	00 f0 7f 
        f32 => {
            const bits = @bitCast(u32, x);
            return bits & 0x7FFFFFFF > 0x7F800000;
        },
        f64 => {
            const bits = @bitCast(u64, x);
  22333e:	c4 e1 f9 7e c5       	vmovq  rbp,xmm0
            return (bits & (@maxValue(u64) >> 1)) > (u64(0x7FF) << 52);
  223343:	b1 3f                	mov    cl,0x3f
  223345:	c4 e2 f0 f5 cd       	bzhi   rcx,rbp,rcx
  22334a:	48 39 c1             	cmp    rcx,rax
    if (math.isNan(x)) {
  22334d:	76 09                	jbe    223358 <formatFloatDecimal+0x48>
        return output(context, "nan");
  22334f:	48 8d 35 1a 2b 02 00 	lea    rsi,[rip+0x22b1a]        # 245e70 <__unnamed_99>
  223356:	eb 0c                	jmp    223364 <formatFloatDecimal+0x54>
        },
        f32 => {
            return @bitCast(u32, x) == 0x7F800000;
        },
        f64 => {
            return @bitCast(u64, x) == 0x7FF << 52;
  223358:	48 39 c5             	cmp    rbp,rax
    if (math.isPositiveInf(x)) {
  22335b:	75 4c                	jne    2233a9 <formatFloatDecimal+0x99>
        return output(context, "inf");
  22335d:	48 8d 35 1c 2b 02 00 	lea    rsi,[rip+0x22b1c]        # 245e80 <__unnamed_100>
  223364:	4c 89 ff             	mov    rdi,r15
  223367:	48 81 c4 f8 00 00 00 	add    rsp,0xf8
  22336e:	5b                   	pop    rbx
  22336f:	41 5c                	pop    r12
  223371:	41 5d                	pop    r13
  223373:	41 5e                	pop    r14
  223375:	41 5f                	pop    r15
  223377:	5d                   	pop    rbp
  223378:	41 ff e0             	jmp    r8
  22337b:	c5 f9 7f 44 24 10    	vmovdqa XMMWORD PTR [rsp+0x10],xmm0
        try output(context, "-");
  223381:	48 8d 35 d8 2a 02 00 	lea    rsi,[rip+0x22ad8]        # 245e60 <__unnamed_101>
  223388:	4c 89 ff             	mov    rdi,r15
  22338b:	4c 89 c3             	mov    rbx,r8
  22338e:	41 ff d0             	call   r8
  223391:	66 85 c0             	test   ax,ax
  223394:	75 38                	jne    2233ce <formatFloatDecimal+0xbe>
  223396:	c5 f9 6f 44 24 10    	vmovdqa xmm0,XMMWORD PTR [rsp+0x10]
        x = -x;
  22339c:	c5 f9 ef 05 cc d3 fd 	vpxor  xmm0,xmm0,XMMWORD PTR [rip+0xfffffffffffdd3cc]        # 200770 <__unnamed_555+0x10>
  2233a3:	ff 
  2233a4:	49 89 d8             	mov    r8,rbx
  2233a7:	eb 8b                	jmp    223334 <formatFloatDecimal+0x24>
    if (x == 0.0) {
  2233a9:	c5 f1 57 c9          	vxorpd xmm1,xmm1,xmm1
  2233ad:	c5 f9 2e c1          	vucomisd xmm0,xmm1
  2233b1:	75 2d                	jne    2233e0 <formatFloatDecimal+0xd0>
  2233b3:	7a 2b                	jp     2233e0 <formatFloatDecimal+0xd0>
        try output(context, "0");
  2233b5:	48 8d 35 f4 2a 02 00 	lea    rsi,[rip+0x22af4]        # 245eb0 <__unnamed_102>
  2233bc:	4c 89 ff             	mov    rdi,r15
  2233bf:	4c 89 c5             	mov    rbp,r8
  2233c2:	41 ff d0             	call   r8
  2233c5:	66 85 c0             	test   ax,ax
  2233c8:	0f 84 fb 02 00 00    	je     2236c9 <formatFloatDecimal+0x3b9>
  2233ce:	48 81 c4 f8 00 00 00 	add    rsp,0xf8
  2233d5:	5b                   	pop    rbx
  2233d6:	41 5c                	pop    r12
  2233d8:	41 5d                	pop    r13
  2233da:	41 5e                	pop    r14
  2233dc:	41 5f                	pop    r15
  2233de:	5d                   	pop    rbp
  2233df:	c3                   	ret    
    var buffer: [32]u8 = undefined;
  2233e0:	c5 fd 10 0d f8 cd fd 	vmovupd ymm1,YMMWORD PTR [rip+0xfffffffffffdcdf8]        # 2001e0 <__unnamed_103>
  2233e7:	ff 
  2233e8:	c5 fd 11 4c 24 50    	vmovupd YMMWORD PTR [rsp+0x50],ymm1
  2233ee:	48 8d 44 24 50       	lea    rax,[rsp+0x50]
    var float_decimal = errol.errol3(x, buffer[0..]);
  2233f3:	48 89 04 24          	mov    QWORD PTR [rsp],rax
  2233f7:	48 c7 44 24 08 20 00 	mov    QWORD PTR [rsp+0x8],0x20
  2233fe:	00 00 
  223400:	b8 b0 01 00 00       	mov    eax,0x1b0
  223405:	31 d2                	xor    edx,edx
  223407:	48 8d 0d 92 e2 fd ff 	lea    rcx,[rip+0xfffffffffffde292]        # 2016a0 <enum3.10>
  22340e:	66 90                	xchg   ax,ax
fn tableLowerBound(k: u64) usize {
    var i = enum3.len;
    var j: usize = 0;

    while (j < enum3.len) {
        if (enum3[j] < k) {
  223410:	48 39 2c d1          	cmp    QWORD PTR [rcx+rdx*8],rbp
  223414:	72 1a                	jb     223430 <formatFloatDecimal+0x120>
  223416:	48 89 d0             	mov    rax,rdx
  223419:	48 01 d2             	add    rdx,rdx
  22341c:	48 83 c2 01          	add    rdx,0x1
    while (j < enum3.len) {
  223420:	48 81 fa b0 01 00 00 	cmp    rdx,0x1b0
  223427:	72 e7                	jb     223410 <formatFloatDecimal+0x100>
  223429:	eb 15                	jmp    223440 <formatFloatDecimal+0x130>
  22342b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  223430:	48 01 d2             	add    rdx,rdx
  223433:	48 83 c2 02          	add    rdx,0x2
  223437:	48 81 fa b0 01 00 00 	cmp    rdx,0x1b0
  22343e:	72 d0                	jb     223410 <formatFloatDecimal+0x100>
    if (i < enum3.len and enum3[i] == bits) {
  223440:	48 3d af 01 00 00    	cmp    rax,0x1af
  223446:	77 44                	ja     22348c <formatFloatDecimal+0x17c>
  223448:	48 39 2c c1          	cmp    QWORD PTR [rcx+rax*8],rbp
  22344c:	75 3e                	jne    22348c <formatFloatDecimal+0x17c>
        const data = enum3_data[i];
  22344e:	48 8d 04 40          	lea    rax,[rax+rax*2]
  223452:	48 8d 0d 27 fe 01 00 	lea    rcx,[rip+0x1fe27]        # 243280 <enum3_data.11>
  223459:	48 8b 14 c1          	mov    rdx,QWORD PTR [rcx+rax*8]
  22345d:	4c 8b 64 c1 08       	mov    r12,QWORD PTR [rcx+rax*8+0x8]
    for (source) |s, i|
  223462:	49 8d 7c 24 ff       	lea    rdi,[r12-0x1]
  223467:	44 89 e6             	mov    esi,r12d
  22346a:	83 e6 07             	and    esi,0x7
  22346d:	48 83 ff 07          	cmp    rdi,0x7
  223471:	0f 83 f5 04 00 00    	jae    22396c <formatFloatDecimal+0x65c>
  223477:	31 ff                	xor    edi,edi
  223479:	4c 8d 4c 24 51       	lea    r9,[rsp+0x51]
  22347e:	48 85 f6             	test   rsi,rsi
  223481:	0f 85 53 05 00 00    	jne    2239da <formatFloatDecimal+0x6ca>
  223487:	e9 75 05 00 00       	jmp    223a01 <formatFloatDecimal+0x6f1>
    if (val > 9.007199254740992e15 and val < 3.40282366920938e+38) {
  22348c:	c5 f9 2e 05 a4 d8 fd 	vucomisd xmm0,QWORD PTR [rip+0xfffffffffffdd8a4]        # 200d38 <app_mask+0x58>
  223493:	ff 
  223494:	c5 f9 7f 44 24 10    	vmovdqa XMMWORD PTR [rsp+0x10],xmm0
  22349a:	0f 86 85 02 00 00    	jbe    223725 <formatFloatDecimal+0x415>
  2234a0:	c5 fb 10 0d 50 d8 fd 	vmovsd xmm1,QWORD PTR [rip+0xfffffffffffdd850]        # 200cf8 <app_mask+0x18>
  2234a7:	ff 
  2234a8:	c5 f9 2e c8          	vucomisd xmm1,xmm0
  2234ac:	0f 86 73 02 00 00    	jbe    223725 <formatFloatDecimal+0x415>
  2234b2:	4c 89 44 24 20       	mov    QWORD PTR [rsp+0x20],r8
fn errolInt(val: f64, buffer: []u8) FloatDecimal {
    const pow19 = u128(1e19);

    assert((val > 9.007199254740992e15) and val < (3.40282366920938e38));

    var mid = @floatToInt(u128, val);
  2234b7:	c5 f8 77             	vzeroupper 
  2234ba:	e8 f1 4c 00 00       	call   2281b0 <__fixunsdfti>
  2234bf:	c5 f9 28 4c 24 10    	vmovapd xmm1,XMMWORD PTR [rsp+0x10]
        .exp = exp,
    };
}

fn fpnext(val: f64) f64 {
    return @bitCast(f64, @bitCast(u64, val) +% 1);
  2234c5:	48 8d 4d 01          	lea    rcx,[rbp+0x1]
  2234c9:	c4 e1 f9 6e c1       	vmovq  xmm0,rcx
    var low: u128 = mid - fpeint((fpnext(val) - val) / 2.0);
  2234ce:	c5 fb 5c c1          	vsubsd xmm0,xmm0,xmm1
  2234d2:	c5 fb 59 05 de d7 fd 	vmulsd xmm0,xmm0,QWORD PTR [rip+0xfffffffffffdd7de]        # 200cb8 <__unnamed_456+0x68>
  2234d9:	ff 

    return buf_index;
}

fn fpeint(from: f64) u128 {
    const bits = @bitCast(u64, from);
  2234da:	c4 e1 f9 7e c1       	vmovq  rcx,xmm0
    assert((bits & ((1 << 52) - 1)) == 0);
  2234df:	48 89 ce             	mov    rsi,rcx
  2234e2:	48 c1 e6 0c          	shl    rsi,0xc
    if (!ok) {
  2234e6:	0f 85 99 12 00 00    	jne    224785 <formatFloatDecimal+0x1475>
  2234ec:	4c 89 74 24 70       	mov    QWORD PTR [rsp+0x70],r14
  2234f1:	48 be ff ff ff ff ff 	movabs rsi,0xfffffffffffff
  2234f8:	ff 0f 00 
    return @bitCast(f64, @bitCast(u64, val) -% 1);
  2234fb:	48 8d 7d ff          	lea    rdi,[rbp-0x1]
  2234ff:	c4 e1 f9 6e c7       	vmovq  xmm0,rdi
    var high: u128 = mid + fpeint((val - fpprev(val)) / 2.0);
  223504:	c5 f3 5c c0          	vsubsd xmm0,xmm1,xmm0
  223508:	c5 fb 59 05 a8 d7 fd 	vmulsd xmm0,xmm0,QWORD PTR [rip+0xfffffffffffdd7a8]        # 200cb8 <__unnamed_456+0x68>
  22350f:	ff 
    const bits = @bitCast(u64, from);
  223510:	c4 e1 f9 7e c3       	vmovq  rbx,xmm0
    assert((bits & ((1 << 52) - 1)) == 0);
  223515:	48 85 f3             	test   rbx,rsi
  223518:	0f 85 67 12 00 00    	jne    224785 <formatFloatDecimal+0x1475>

    return u128(1) << @truncate(u7, (bits >> 52) -% 1023);
  22351e:	48 c1 e9 34          	shr    rcx,0x34
  223522:	83 c1 01             	add    ecx,0x1
  223525:	83 e1 7f             	and    ecx,0x7f
  223528:	41 b8 01 00 00 00    	mov    r8d,0x1
  22352e:	31 ff                	xor    edi,edi
  223530:	4c 0f a5 c7          	shld   rdi,r8,cl

    var i: i32 = 0;
    var a_copy = a;
    var b_copy = b;

    if (af != bf) {
  223534:	45 31 c9             	xor    r9d,r9d
    return u128(1) << @truncate(u7, (bits >> 52) -% 1023);
  223537:	c4 c2 f1 f7 f0       	shlx   rsi,r8,rcx
  22353c:	f6 c1 40             	test   cl,0x40
  22353f:	48 0f 45 fe          	cmovne rdi,rsi
  223543:	49 0f 45 f1          	cmovne rsi,r9
    if (af != bf) {
  223547:	45 31 c9             	xor    r9d,r9d
    var low: u128 = mid - fpeint((fpnext(val) - val) / 2.0);
  22354a:	49 89 c6             	mov    r14,rax
  22354d:	49 29 f6             	sub    r14,rsi
  223550:	48 89 d6             	mov    rsi,rdx
  223553:	48 19 fe             	sbb    rsi,rdi
    return u128(1) << @truncate(u7, (bits >> 52) -% 1023);
  223556:	48 c1 eb 34          	shr    rbx,0x34
  22355a:	83 c3 01             	add    ebx,0x1
  22355d:	83 e3 7f             	and    ebx,0x7f
  223560:	31 ff                	xor    edi,edi
  223562:	89 d9                	mov    ecx,ebx
  223564:	4c 0f a5 c7          	shld   rdi,r8,cl
  223568:	c4 c2 e1 f7 c8       	shlx   rcx,r8,rbx
  22356d:	f6 c3 40             	test   bl,0x40
  223570:	48 0f 45 f9          	cmovne rdi,rcx
  223574:	49 0f 45 c9          	cmovne rcx,r9
    if (@bitCast(u64, val) & 0x1 != 0) {
  223578:	83 e5 01             	and    ebp,0x1
  22357b:	31 db                	xor    ebx,ebx
  22357d:	48 85 ed             	test   rbp,rbp
  223580:	0f 94 c3             	sete   bl
  223583:	48 89 44 24 30       	mov    QWORD PTR [rsp+0x30],rax
    var high: u128 = mid + fpeint((val - fpprev(val)) / 2.0);
  223588:	49 89 c5             	mov    r13,rax
  22358b:	49 29 ed             	sub    r13,rbp
  22358e:	48 89 54 24 48       	mov    QWORD PTR [rsp+0x48],rdx
  223593:	48 89 d5             	mov    rbp,rdx
  223596:	48 83 dd 00          	sbb    rbp,0x0
    if (@bitCast(u64, val) & 0x1 != 0) {
  22359a:	49 01 cd             	add    r13,rcx
  22359d:	48 11 fd             	adc    rbp,rdi
  2235a0:	49 29 de             	sub    r14,rbx
  2235a3:	48 83 de 00          	sbb    rsi,0x0
  2235a7:	49 bc 00 00 e8 89 04 	movabs r12,0x8ac7230489e80000
  2235ae:	23 c7 8a 
    const lf = @intCast(u64, (low / pow19) % pow19);
  2235b1:	31 c9                	xor    ecx,ecx
  2235b3:	4c 89 f7             	mov    rdi,r14
  2235b6:	4c 89 e2             	mov    rdx,r12
  2235b9:	e8 f2 56 00 00       	call   228cb0 <__udivti3>
  2235be:	48 89 c1             	mov    rcx,rax
  2235c1:	49 0f af cc          	imul   rcx,r12
  2235c5:	49 29 ce             	sub    r14,rcx
  2235c8:	31 c9                	xor    ecx,ecx
  2235ca:	48 89 c7             	mov    rdi,rax
  2235cd:	48 89 d6             	mov    rsi,rdx
  2235d0:	4c 89 e2             	mov    rdx,r12
  2235d3:	e8 f8 56 00 00       	call   228cd0 <__umodti3>
  2235d8:	48 89 c3             	mov    rbx,rax
    const hf = @intCast(u64, (high / pow19) % pow19);
  2235db:	31 c9                	xor    ecx,ecx
  2235dd:	4c 89 ef             	mov    rdi,r13
  2235e0:	48 89 ee             	mov    rsi,rbp
  2235e3:	4c 89 e2             	mov    rdx,r12
  2235e6:	e8 c5 56 00 00       	call   228cb0 <__udivti3>
  2235eb:	48 89 c1             	mov    rcx,rax
  2235ee:	49 0f af cc          	imul   rcx,r12
  2235f2:	49 29 cd             	sub    r13,rcx
  2235f5:	31 c9                	xor    ecx,ecx
  2235f7:	48 89 c7             	mov    rdi,rax
  2235fa:	48 89 d6             	mov    rsi,rdx
  2235fd:	4c 89 e2             	mov    rdx,r12
  223600:	e8 cb 56 00 00       	call   228cd0 <__umodti3>
  223605:	49 89 c4             	mov    r12,rax
    if (lf != hf) {
  223608:	4c 39 e3             	cmp    rbx,r12
  22360b:	48 89 5c 24 10       	mov    QWORD PTR [rsp+0x10],rbx
  223610:	4c 0f 45 f3          	cmovne r14,rbx
  223614:	4d 0f 45 ec          	cmovne r13,r12
  223618:	48 b9 bf d5 ed bd ce 	movabs rcx,0xdbe6fecebdedd5bf
  22361f:	fe e6 db 
    const af = a / pow10;
  223622:	4c 89 f2             	mov    rdx,r14
  223625:	c4 e2 eb f6 c1       	mulx   rax,rdx,rcx
  22362a:	48 c1 e8 21          	shr    rax,0x21
    const bf = b / pow10;
  22362e:	4c 89 ea             	mov    rdx,r13
  223631:	c4 e2 eb f6 c9       	mulx   rcx,rdx,rcx
  223636:	48 c1 e9 21          	shr    rcx,0x21
    if (af != bf) {
  22363a:	48 39 c8             	cmp    rax,rcx
  22363d:	bd 0a 00 00 00       	mov    ebp,0xa
  223642:	ba 00 00 00 00       	mov    edx,0x0
  223647:	0f 44 ea             	cmove  ebp,edx
  22364a:	49 0f 44 c6          	cmove  rax,r14
  22364e:	49 0f 44 cd          	cmove  rcx,r13
  223652:	bb 01 00 00 00       	mov    ebx,0x1
        i = 10;
        a_copy = af;
        b_copy = bf;
    }

    while (true) : (i += 1) {
  223657:	29 eb                	sub    ebx,ebp
  223659:	83 c5 12             	add    ebp,0x12
  22365c:	48 be cd cc cc cc cc 	movabs rsi,0xcccccccccccccccd
  223663:	cc cc cc 
  223666:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  22366d:	00 00 00 
        a_copy /= 10;
  223670:	48 89 c2             	mov    rdx,rax
  223673:	c4 e2 eb f6 c6       	mulx   rax,rdx,rsi
  223678:	48 c1 e8 03          	shr    rax,0x3
        b_copy /= 10;
  22367c:	48 89 ca             	mov    rdx,rcx
  22367f:	c4 e2 eb f6 ce       	mulx   rcx,rdx,rsi
  223684:	48 c1 e9 03          	shr    rcx,0x3

        if (a_copy == b_copy) return i;
  223688:	83 c3 ff             	add    ebx,0xffffffff
  22368b:	83 c5 01             	add    ebp,0x1
  22368e:	48 39 c8             	cmp    rax,rcx
  223691:	75 dd                	jne    223670 <formatFloatDecimal+0x360>
    if (lf != hf) {
  223693:	4c 39 64 24 10       	cmp    QWORD PTR [rsp+0x10],r12
  223698:	4c 8b 74 24 70       	mov    r14,QWORD PTR [rsp+0x70]
  22369d:	0f 84 81 02 00 00    	je     223924 <formatFloatDecimal+0x614>
        mid = mid / (pow19 / 10);
  2236a3:	48 ba 00 00 64 a7 b3 	movabs rdx,0xde0b6b3a7640000
  2236aa:	b6 e0 0d 
  2236ad:	31 c9                	xor    ecx,ecx
  2236af:	48 8b 7c 24 30       	mov    rdi,QWORD PTR [rsp+0x30]
  2236b4:	48 8b 74 24 48       	mov    rsi,QWORD PTR [rsp+0x48]
  2236b9:	e8 f2 55 00 00       	call   228cb0 <__udivti3>
  2236be:	48 89 c7             	mov    rdi,rax
  2236c1:	48 89 d6             	mov    rsi,rdx
  2236c4:	e9 65 02 00 00       	jmp    22392e <formatFloatDecimal+0x61e>
        if (maybe_precision) |precision| {
  2236c9:	41 80 7e 08 01       	cmp    BYTE PTR [r14+0x8],0x1
  2236ce:	0f 85 a0 01 00 00    	jne    223874 <formatFloatDecimal+0x564>
  2236d4:	4d 8b 26             	mov    r12,QWORD PTR [r14]
            if (precision != 0) {
  2236d7:	4d 85 e4             	test   r12,r12
  2236da:	48 89 e8             	mov    rax,rbp
  2236dd:	0f 84 4d 04 00 00    	je     223b30 <formatFloatDecimal+0x820>
                try output(context, ".");
  2236e3:	48 8d 35 b6 27 02 00 	lea    rsi,[rip+0x227b6]        # 245ea0 <__unnamed_104>
  2236ea:	4c 89 ff             	mov    rdi,r15
  2236ed:	ff d0                	call   rax
  2236ef:	66 85 c0             	test   ax,ax
  2236f2:	0f 85 d6 fc ff ff    	jne    2233ce <formatFloatDecimal+0xbe>
  2236f8:	31 db                	xor    ebx,ebx
  2236fa:	4c 8d 35 af 27 02 00 	lea    r14,[rip+0x227af]        # 245eb0 <__unnamed_102>
                    try output(context, "0");
  223701:	4c 89 ff             	mov    rdi,r15
  223704:	4c 89 f6             	mov    rsi,r14
  223707:	48 89 e8             	mov    rax,rbp
  22370a:	ff d0                	call   rax
  22370c:	66 85 c0             	test   ax,ax
  22370f:	0f 85 b9 fc ff ff    	jne    2233ce <formatFloatDecimal+0xbe>
  223715:	48 83 c3 01          	add    rbx,0x1
  223719:	31 c0                	xor    eax,eax
                while (i < precision) : (i += 1) {
  22371b:	4c 39 e3             	cmp    rbx,r12
  22371e:	72 e1                	jb     223701 <formatFloatDecimal+0x3f1>
  223720:	e9 a9 fc ff ff       	jmp    2233ce <formatFloatDecimal+0xbe>
  223725:	4c 89 c3             	mov    rbx,r8
    } else if (val >= 16.0 and val < 9.007199254740992e15) {
  223728:	c5 f9 2e 05 70 d5 fd 	vucomisd xmm0,QWORD PTR [rip+0xfffffffffffdd570]        # 200ca0 <__unnamed_456+0x50>
  22372f:	ff 
  223730:	0f 82 50 01 00 00    	jb     223886 <formatFloatDecimal+0x576>
  223736:	c5 fb 10 0d fa d5 fd 	vmovsd xmm1,QWORD PTR [rip+0xfffffffffffdd5fa]        # 200d38 <app_mask+0x58>
  22373d:	ff 
  22373e:	c5 f9 2e c8          	vucomisd xmm1,xmm0
  223742:	0f 86 3e 01 00 00    	jbe    223886 <formatFloatDecimal+0x576>
    const u = @floatToInt(u64, val);
  223748:	c5 fb 10 15 a0 d5 fd 	vmovsd xmm2,QWORD PTR [rip+0xfffffffffffdd5a0]        # 200cf0 <app_mask+0x10>
  22374f:	ff 
  223750:	c5 fb 5c ca          	vsubsd xmm1,xmm0,xmm2
  223754:	c4 e1 fb 2c c1       	vcvttsd2si rax,xmm1
  223759:	48 b9 00 00 00 00 00 	movabs rcx,0x8000000000000000
  223760:	00 00 80 
  223763:	48 31 c1             	xor    rcx,rax
  223766:	c4 e1 fb 2c f8       	vcvttsd2si rdi,xmm0
  22376b:	c5 f9 2e c2          	vucomisd xmm0,xmm2
  22376f:	48 0f 43 f9          	cmovae rdi,rcx
    const n = @intToFloat(f64, u);
  223773:	c4 e1 f9 6e cf       	vmovq  xmm1,rdi
  223778:	c5 f1 62 0d a0 ca fd 	vpunpckldq xmm1,xmm1,XMMWORD PTR [rip+0xfffffffffffdcaa0]        # 200220 <__unnamed_103+0x40>
  22377f:	ff 
  223780:	c5 f1 5c 0d c8 cf fd 	vsubpd xmm1,xmm1,XMMWORD PTR [rip+0xfffffffffffdcfc8]        # 200750 <__unnamed_586+0x10>
  223787:	ff 
  223788:	c5 f1 7c c9          	vhaddpd xmm1,xmm1,xmm1
  22378c:	c5 f9 29 4c 24 30    	vmovapd XMMWORD PTR [rsp+0x30],xmm1
    var mid = val - n;
  223792:	c5 fb 5c c9          	vsubsd xmm1,xmm0,xmm1
    var buf_index = u64toa(u, buffer);
  223796:	c5 f9 29 4c 24 20    	vmovapd XMMWORD PTR [rsp+0x20],xmm1
  22379c:	48 89 e6             	mov    rsi,rsp
  22379f:	c5 f8 77             	vzeroupper 
  2237a2:	e8 e9 0f 00 00       	call   224790 <u64toa>
  2237a7:	c5 f9 28 6c 24 20    	vmovapd xmm5,XMMWORD PTR [rsp+0x20]
  2237ad:	49 89 c5             	mov    r13,rax
    buffer[j] = 0;
  2237b0:	48 8b 04 24          	mov    rax,QWORD PTR [rsp]
  2237b4:	42 c6 04 28 00       	mov    BYTE PTR [rax+r13*1],0x0
    if (mid != 0.0) {
  2237b9:	c5 f9 57 c0          	vxorpd xmm0,xmm0,xmm0
  2237bd:	c5 f9 2e e8          	vucomisd xmm5,xmm0
  2237c1:	0f 84 7c 09 00 00    	je     224143 <formatFloatDecimal+0xe33>
    return @bitCast(f64, @bitCast(u64, val) -% 1);
  2237c7:	c4 e2 79 59 4c 24 10 	vpbroadcastq xmm1,QWORD PTR [rsp+0x10]
  2237ce:	c5 f1 d4 0d 2a d1 fd 	vpaddq xmm1,xmm1,XMMWORD PTR [rip+0xfffffffffffdd12a]        # 200900 <__unnamed_526+0x10>
  2237d5:	ff 
    var lo = ((fpprev(val) - n) + mid) / 2.0;
  2237d6:	c5 fb 12 54 24 30    	vmovddup xmm2,QWORD PTR [rsp+0x30]
  2237dc:	c5 f1 5c ca          	vsubpd xmm1,xmm1,xmm2
  2237e0:	c5 fb 12 d5          	vmovddup xmm2,xmm5
  2237e4:	c5 e9 58 c9          	vaddpd xmm1,xmm2,xmm1
  2237e8:	c5 f1 59 1d 20 cd fd 	vmulpd xmm3,xmm1,XMMWORD PTR [rip+0xfffffffffffdcd20]        # 200510 <__unnamed_52+0x10>
  2237ef:	ff 
  2237f0:	c5 f9 28 0d 38 cb fd 	vmovapd xmm1,XMMWORD PTR [rip+0xfffffffffffdcb38]        # 200330 <__unnamed_74+0x10>
  2237f7:	ff 
  2237f8:	c5 fb 10 15 78 d4 fd 	vmovsd xmm2,QWORD PTR [rip+0xfffffffffffdd478]        # 200c78 <__unnamed_456+0x28>
  2237ff:	ff 
  223800:	4c 89 e9             	mov    rcx,r13
  223803:	48 89 c8             	mov    rax,rcx
            mid *= 10.0;
  223806:	c5 d3 59 e2          	vmulsd xmm4,xmm5,xmm2
            const mdig = @floatToInt(i32, mid);
  22380a:	c5 fb 2c cc          	vcvttsd2si ecx,xmm4
            mid -= @intToFloat(f64, mdig);
  22380e:	c5 cb 2a e9          	vcvtsi2sd xmm5,xmm6,ecx
  223812:	c5 db 5c ed          	vsubsd xmm5,xmm4,xmm5
            buffer[j] = @intCast(u8, mdig + '0');
  223816:	48 8b 14 24          	mov    rdx,QWORD PTR [rsp]
  22381a:	80 c1 30             	add    cl,0x30
  22381d:	88 0c 02             	mov    BYTE PTR [rdx+rax*1],cl
            if (hdig != ldig or j > 50) break;
  223820:	48 83 f8 31          	cmp    rax,0x31
  223824:	77 2c                	ja     223852 <formatFloatDecimal+0x542>
  223826:	c5 e1 59 d9          	vmulpd xmm3,xmm3,xmm1
  22382a:	c5 fb 2c cb          	vcvttsd2si ecx,xmm3
  22382e:	c4 e3 79 05 e3 01    	vpermilpd xmm4,xmm3,0x1
  223834:	c5 fb 2c d4          	vcvttsd2si edx,xmm4
  223838:	39 ca                	cmp    edx,ecx
  22383a:	75 16                	jne    223852 <formatFloatDecimal+0x542>
            hi -= @intToFloat(f64, hdig);
  22383c:	c5 cb 2a e1          	vcvtsi2sd xmm4,xmm6,ecx
  223840:	48 8d 48 01          	lea    rcx,[rax+0x1]
            lo -= @intToFloat(f64, ldig);
  223844:	c5 fb 12 e4          	vmovddup xmm4,xmm4
  223848:	c5 e1 5c dc          	vsubpd xmm3,xmm3,xmm4
        while (mid != 0.0) {
  22384c:	c5 f9 2e e8          	vucomisd xmm5,xmm0
  223850:	75 b1                	jne    223803 <formatFloatDecimal+0x4f3>
        if (mid > 0.5) {
  223852:	4c 8d 60 01          	lea    r12,[rax+0x1]
  223856:	c5 f9 2e 2d 5a d4 fd 	vucomisd xmm5,QWORD PTR [rip+0xfffffffffffdd45a]        # 200cb8 <__unnamed_456+0x68>
  22385d:	ff 
  22385e:	49 89 d8             	mov    r8,rbx
  223861:	0f 86 22 09 00 00    	jbe    224189 <formatFloatDecimal+0xe79>
            buffer[j - 1] += 1;
  223867:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
  22386b:	80 04 01 01          	add    BYTE PTR [rcx+rax*1],0x1
  22386f:	e9 d7 0d 00 00       	jmp    22464b <formatFloatDecimal+0x133b>
            try output(context, "0");
  223874:	48 8d 35 35 26 02 00 	lea    rsi,[rip+0x22635]        # 245eb0 <__unnamed_102>
  22387b:	4c 89 ff             	mov    rdi,r15
  22387e:	48 89 e8             	mov    rax,rbp
  223881:	e9 b4 02 00 00       	jmp    223b3a <formatFloatDecimal+0x82a>
  223886:	48 8d bc 24 c8 00 00 	lea    rdi,[rsp+0xc8]
  22388d:	00 

pub fn frexp(x: var) frexp_result(@typeOf(x)) {
    const T = @typeOf(x);
    return switch (T) {
        f32 => frexp32(x),
        f64 => frexp64(x),
  22388e:	c5 f8 77             	vzeroupper 
  223891:	e8 ea 15 00 00       	call   224e80 <frexp64>
    var exp = @floatToInt(i16, math.floor(307 + @intToFloat(f64, e) * 0.30103));
  223896:	c5 eb 2a 84 24 d0 00 	vcvtsi2sd xmm0,xmm2,DWORD PTR [rsp+0xd0]
  22389d:	00 00 
  22389f:	c5 fb 59 05 01 d4 fd 	vmulsd xmm0,xmm0,QWORD PTR [rip+0xfffffffffffdd401]        # 200ca8 <__unnamed_456+0x58>
  2238a6:	ff 
  2238a7:	c5 fb 58 05 19 d4 fd 	vaddsd xmm0,xmm0,QWORD PTR [rip+0xfffffffffffdd419]        # 200cc8 <__unnamed_456+0x78>
  2238ae:	ff 
fn floor64(x: f64) f64 {
    const u = @bitCast(u64, x);
    const e = (u >> 52) & 0x7FF;
    var y: f64 = undefined;

    if (e >= 0x3FF + 52 or x == 0) {
  2238af:	c5 f1 57 c9          	vxorpd xmm1,xmm1,xmm1
  2238b3:	c5 f9 2e c1          	vucomisd xmm0,xmm1
  2238b7:	75 06                	jne    2238bf <formatFloatDecimal+0x5af>
  2238b9:	0f 8b 8e 02 00 00    	jnp    223b4d <formatFloatDecimal+0x83d>
  2238bf:	c4 e1 f9 7e c0       	vmovq  rax,xmm0
  2238c4:	b9 34 0b 00 00       	mov    ecx,0xb34
  2238c9:	c4 e2 f0 f7 c8       	bextr  rcx,rax,rcx
  2238ce:	48 81 f9 32 04 00 00 	cmp    rcx,0x432
  2238d5:	0f 87 72 02 00 00    	ja     223b4d <formatFloatDecimal+0x83d>
        return x;
    }

    if (u >> 63 != 0) {
        y = x - math.f64_toint + math.f64_toint - x;
  2238db:	c5 fb 10 15 b5 d3 fd 	vmovsd xmm2,QWORD PTR [rip+0xfffffffffffdd3b5]        # 200c98 <__unnamed_456+0x48>
  2238e2:	ff 
  2238e3:	c5 fb 10 1d e5 d3 fd 	vmovsd xmm3,QWORD PTR [rip+0xfffffffffffdd3e5]        # 200cd0 <__unnamed_456+0x80>
  2238ea:	ff 
    if (u >> 63 != 0) {
  2238eb:	48 85 c0             	test   rax,rax
  2238ee:	49 89 d8             	mov    r8,rbx
  2238f1:	c5 79 28 5c 24 10    	vmovapd xmm11,XMMWORD PTR [rsp+0x10]
  2238f7:	0f 88 b3 08 00 00    	js     2241b0 <formatFloatDecimal+0xea0>
  2238fd:	c5 fb 58 db          	vaddsd xmm3,xmm0,xmm3
  223901:	c5 e3 58 d2          	vaddsd xmm2,xmm3,xmm2
    } else {
        y = x + math.f64_toint - math.f64_toint - x;
    }

    if (e <= 0x3FF - 1) {
  223905:	48 81 f9 fe 03 00 00 	cmp    rcx,0x3fe
  22390c:	0f 87 b3 08 00 00    	ja     2241c5 <formatFloatDecimal+0xeb5>
    if (u >> 63 != 0) {
  223912:	48 85 c0             	test   rax,rax
        math.forceEval(y);
        if (u >> 63 != 0) {
  223915:	0f 88 4d 0d 00 00    	js     224668 <formatFloatDecimal+0x1358>
  22391b:	c5 f9 57 c0          	vxorpd xmm0,xmm0,xmm0
  22391f:	e9 32 02 00 00       	jmp    223b56 <formatFloatDecimal+0x846>
  223924:	48 8b 7c 24 30       	mov    rdi,QWORD PTR [rsp+0x30]
  223929:	48 8b 74 24 48       	mov    rsi,QWORD PTR [rsp+0x48]
        var i: i32 = @boolToInt(lf == hf);
  22392e:	31 c0                	xor    eax,eax
  223930:	4c 39 64 24 10       	cmp    QWORD PTR [rsp+0x10],r12
  223935:	0f 94 c0             	sete   al
        while (i < mi) : (i += 1) {
  223938:	41 89 dd             	mov    r13d,ebx
  22393b:	41 f7 dd             	neg    r13d
  22393e:	41 39 c5             	cmp    r13d,eax
  223941:	76 1d                	jbe    223960 <formatFloatDecimal+0x650>
  223943:	41 89 c2             	mov    r10d,eax
  223946:	41 f7 da             	neg    r10d
  223949:	41 29 da             	sub    r10d,ebx
  22394c:	41 83 fa 10          	cmp    r10d,0x10
  223950:	0f 83 ac 07 00 00    	jae    224102 <formatFloatDecimal+0xdf2>
  223956:	ba 01 00 00 00       	mov    edx,0x1
  22395b:	e9 92 0a 00 00       	jmp    2243f2 <formatFloatDecimal+0x10e2>
  223960:	31 c9                	xor    ecx,ecx
  223962:	ba 01 00 00 00       	mov    edx,0x1
  223967:	e9 a2 0a 00 00       	jmp    22440e <formatFloatDecimal+0x10fe>
  22396c:	4c 89 e5             	mov    rbp,r12
  22396f:	48 29 f5             	sub    rbp,rsi
  223972:	31 ff                	xor    edi,edi
  223974:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  22397b:	00 00 00 00 00 
  223980:	0f b6 1c 3a          	movzx  ebx,BYTE PTR [rdx+rdi*1]
        dest[i] = s;
  223984:	88 5c 3c 51          	mov    BYTE PTR [rsp+rdi*1+0x51],bl
    for (source) |s, i|
  223988:	0f b6 5c 3a 01       	movzx  ebx,BYTE PTR [rdx+rdi*1+0x1]
        dest[i] = s;
  22398d:	88 5c 3c 52          	mov    BYTE PTR [rsp+rdi*1+0x52],bl
    for (source) |s, i|
  223991:	0f b6 5c 3a 02       	movzx  ebx,BYTE PTR [rdx+rdi*1+0x2]
        dest[i] = s;
  223996:	88 5c 3c 53          	mov    BYTE PTR [rsp+rdi*1+0x53],bl
    for (source) |s, i|
  22399a:	0f b6 5c 3a 03       	movzx  ebx,BYTE PTR [rdx+rdi*1+0x3]
        dest[i] = s;
  22399f:	88 5c 3c 54          	mov    BYTE PTR [rsp+rdi*1+0x54],bl
    for (source) |s, i|
  2239a3:	0f b6 5c 3a 04       	movzx  ebx,BYTE PTR [rdx+rdi*1+0x4]
        dest[i] = s;
  2239a8:	88 5c 3c 55          	mov    BYTE PTR [rsp+rdi*1+0x55],bl
    for (source) |s, i|
  2239ac:	0f b6 5c 3a 05       	movzx  ebx,BYTE PTR [rdx+rdi*1+0x5]
        dest[i] = s;
  2239b1:	88 5c 3c 56          	mov    BYTE PTR [rsp+rdi*1+0x56],bl
    for (source) |s, i|
  2239b5:	0f b6 5c 3a 06       	movzx  ebx,BYTE PTR [rdx+rdi*1+0x6]
        dest[i] = s;
  2239ba:	88 5c 3c 57          	mov    BYTE PTR [rsp+rdi*1+0x57],bl
    for (source) |s, i|
  2239be:	0f b6 5c 3a 07       	movzx  ebx,BYTE PTR [rdx+rdi*1+0x7]
        dest[i] = s;
  2239c3:	88 5c 3c 58          	mov    BYTE PTR [rsp+rdi*1+0x58],bl
    for (source) |s, i|
  2239c7:	48 83 c7 08          	add    rdi,0x8
  2239cb:	48 39 fd             	cmp    rbp,rdi
  2239ce:	75 b0                	jne    223980 <formatFloatDecimal+0x670>
  2239d0:	4c 8d 4c 24 51       	lea    r9,[rsp+0x51]
  2239d5:	48 85 f6             	test   rsi,rsi
  2239d8:	74 27                	je     223a01 <formatFloatDecimal+0x6f1>
  2239da:	48 8d 2c 3c          	lea    rbp,[rsp+rdi*1]
  2239de:	48 83 c5 51          	add    rbp,0x51
  2239e2:	48 01 fa             	add    rdx,rdi
  2239e5:	31 ff                	xor    edi,edi
  2239e7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  2239ee:	00 00 
  2239f0:	0f b6 1c 3a          	movzx  ebx,BYTE PTR [rdx+rdi*1]
        dest[i] = s;
  2239f4:	88 5c 3d 00          	mov    BYTE PTR [rbp+rdi*1+0x0],bl
    for (source) |s, i|
  2239f8:	48 83 c7 01          	add    rdi,0x1
  2239fc:	48 39 fe             	cmp    rsi,rdi
  2239ff:	75 ef                	jne    2239f0 <formatFloatDecimal+0x6e0>
  223a01:	44 8b 6c c1 10       	mov    r13d,DWORD PTR [rcx+rax*8+0x10]
    if (maybe_precision) |precision| {
  223a06:	41 80 7e 08 01       	cmp    BYTE PTR [r14+0x8],0x1
  223a0b:	0f 84 54 0a 00 00    	je     224465 <formatFloatDecimal+0x1155>
        var num_digits_whole = if (float_decimal.exp > 0) @intCast(usize, float_decimal.exp) else 0;
  223a11:	31 ed                	xor    ebp,ebp
  223a13:	45 85 ed             	test   r13d,r13d
  223a16:	44 89 e8             	mov    eax,r13d
  223a19:	48 0f 4f e8          	cmovg  rbp,rax
    return if (x < y) x else y;
  223a1d:	4c 39 e5             	cmp    rbp,r12
  223a20:	4c 89 e0             	mov    rax,r12
  223a23:	48 0f 42 c5          	cmovb  rax,rbp
  223a27:	45 85 ed             	test   r13d,r13d
        if (num_digits_whole > 0) {
  223a2a:	4c 89 4c 24 10       	mov    QWORD PTR [rsp+0x10],r9
  223a2f:	48 89 44 24 20       	mov    QWORD PTR [rsp+0x20],rax
  223a34:	7e 5a                	jle    223a90 <formatFloatDecimal+0x780>
            try output(context, float_decimal.digits[0..num_digits_whole_no_pad]);
  223a36:	4c 89 8c 24 88 00 00 	mov    QWORD PTR [rsp+0x88],r9
  223a3d:	00 
  223a3e:	48 89 84 24 90 00 00 	mov    QWORD PTR [rsp+0x90],rax
  223a45:	00 
  223a46:	48 8d b4 24 88 00 00 	lea    rsi,[rsp+0x88]
  223a4d:	00 
  223a4e:	4c 89 ff             	mov    rdi,r15
  223a51:	4d 89 c6             	mov    r14,r8
  223a54:	c5 f8 77             	vzeroupper 
  223a57:	41 ff d0             	call   r8
  223a5a:	66 85 c0             	test   ax,ax
  223a5d:	0f 85 6b f9 ff ff    	jne    2233ce <formatFloatDecimal+0xbe>
            while (i < num_digits_whole) : (i += 1) {
  223a63:	4c 39 e5             	cmp    rbp,r12
  223a66:	76 44                	jbe    223aac <formatFloatDecimal+0x79c>
  223a68:	48 8b 5c 24 20       	mov    rbx,QWORD PTR [rsp+0x20]
                try output(context, "0");
  223a6d:	4c 89 ff             	mov    rdi,r15
  223a70:	48 8d 35 39 24 02 00 	lea    rsi,[rip+0x22439]        # 245eb0 <__unnamed_102>
  223a77:	4c 89 f0             	mov    rax,r14
  223a7a:	ff d0                	call   rax
  223a7c:	66 85 c0             	test   ax,ax
  223a7f:	0f 85 49 f9 ff ff    	jne    2233ce <formatFloatDecimal+0xbe>
  223a85:	48 83 c3 01          	add    rbx,0x1
            while (i < num_digits_whole) : (i += 1) {
  223a89:	48 39 eb             	cmp    rbx,rbp
  223a8c:	72 df                	jb     223a6d <formatFloatDecimal+0x75d>
  223a8e:	eb 1c                	jmp    223aac <formatFloatDecimal+0x79c>
            try output(context, "0");
  223a90:	48 8d 35 19 24 02 00 	lea    rsi,[rip+0x22419]        # 245eb0 <__unnamed_102>
  223a97:	4c 89 ff             	mov    rdi,r15
  223a9a:	4d 89 c6             	mov    r14,r8
  223a9d:	c5 f8 77             	vzeroupper 
  223aa0:	41 ff d0             	call   r8
  223aa3:	66 85 c0             	test   ax,ax
  223aa6:	0f 85 22 f9 ff ff    	jne    2233ce <formatFloatDecimal+0xbe>
        if (float_decimal.exp >= 0 and num_digits_whole_no_pad == float_decimal.digits.len) {
  223aac:	45 85 ed             	test   r13d,r13d
  223aaf:	78 09                	js     223aba <formatFloatDecimal+0x7aa>
  223ab1:	49 39 ec             	cmp    r12,rbp
  223ab4:	0f 86 c4 0c 00 00    	jbe    22477e <formatFloatDecimal+0x146e>
        try output(context, ".");
  223aba:	48 8d 35 df 23 02 00 	lea    rsi,[rip+0x223df]        # 245ea0 <__unnamed_104>
  223ac1:	4c 89 ff             	mov    rdi,r15
  223ac4:	4c 89 f3             	mov    rbx,r14
  223ac7:	41 ff d6             	call   r14
  223aca:	66 85 c0             	test   ax,ax
  223acd:	0f 85 fb f8 ff ff    	jne    2233ce <formatFloatDecimal+0xbe>
        if (float_decimal.exp < 0) {
  223ad3:	45 85 ed             	test   r13d,r13d
  223ad6:	79 2c                	jns    223b04 <formatFloatDecimal+0x7f4>
            const zero_digit_count = @intCast(usize, -float_decimal.exp);
  223ad8:	41 f7 dd             	neg    r13d
  223adb:	4d 63 ed             	movsxd r13,r13d
  223ade:	31 ed                	xor    ebp,ebp
  223ae0:	4c 8d 35 c9 23 02 00 	lea    r14,[rip+0x223c9]        # 245eb0 <__unnamed_102>
                try output(context, "0");
  223ae7:	4c 89 ff             	mov    rdi,r15
  223aea:	4c 89 f6             	mov    rsi,r14
  223aed:	48 89 d8             	mov    rax,rbx
  223af0:	ff d0                	call   rax
  223af2:	66 85 c0             	test   ax,ax
  223af5:	0f 85 d3 f8 ff ff    	jne    2233ce <formatFloatDecimal+0xbe>
  223afb:	48 83 c5 01          	add    rbp,0x1
            while (i < zero_digit_count) : (i += 1) {
  223aff:	4c 39 ed             	cmp    rbp,r13
  223b02:	72 e3                	jb     223ae7 <formatFloatDecimal+0x7d7>
  223b04:	48 8b 44 24 10       	mov    rax,QWORD PTR [rsp+0x10]
  223b09:	48 8b 4c 24 20       	mov    rcx,QWORD PTR [rsp+0x20]
        try output(context, float_decimal.digits[num_digits_whole_no_pad..]);
  223b0e:	48 01 c8             	add    rax,rcx
  223b11:	48 89 44 24 78       	mov    QWORD PTR [rsp+0x78],rax
  223b16:	49 29 cc             	sub    r12,rcx
  223b19:	4c 89 a4 24 80 00 00 	mov    QWORD PTR [rsp+0x80],r12
  223b20:	00 
  223b21:	48 8d 74 24 78       	lea    rsi,[rsp+0x78]
  223b26:	4c 89 ff             	mov    rdi,r15
  223b29:	ff d3                	call   rbx
  223b2b:	e9 9e f8 ff ff       	jmp    2233ce <formatFloatDecimal+0xbe>
                try output(context, ".0");
  223b30:	48 8d 35 59 23 02 00 	lea    rsi,[rip+0x22359]        # 245e90 <__unnamed_105>
  223b37:	4c 89 ff             	mov    rdi,r15
  223b3a:	48 81 c4 f8 00 00 00 	add    rsp,0xf8
  223b41:	5b                   	pop    rbx
  223b42:	41 5c                	pop    r12
  223b44:	41 5d                	pop    r13
  223b46:	41 5e                	pop    r14
  223b48:	41 5f                	pop    r15
  223b4a:	5d                   	pop    rbp
  223b4b:	ff e0                	jmp    rax
  223b4d:	49 89 d8             	mov    r8,rbx
  223b50:	c5 79 28 5c 24 10    	vmovapd xmm11,XMMWORD PTR [rsp+0x10]
    var exp = @floatToInt(i16, math.floor(307 + @intToFloat(f64, e) * 0.30103));
  223b56:	c5 fb 2c c0          	vcvttsd2si eax,xmm0
    if (exp < 20) {
  223b5a:	98                   	cwde   
    } else if (@intCast(usize, exp) >= lookup_table.len) {
  223b5b:	0f b7 c8             	movzx  ecx,ax
  223b5e:	81 f9 57 02 00 00    	cmp    ecx,0x257
  223b64:	66 b9 57 02          	mov    cx,0x257
  223b68:	66 0f 42 c8          	cmovb  cx,ax
    if (exp < 20) {
  223b6c:	83 f8 14             	cmp    eax,0x14
  223b6f:	66 b8 14 00          	mov    ax,0x14
  223b73:	66 0f 4d c1          	cmovge ax,cx
    var mid = lookup_table[@intCast(usize, exp)];
  223b77:	0f b7 c8             	movzx  ecx,ax
  223b7a:	48 c1 e1 04          	shl    rcx,0x4
  223b7e:	48 8d 15 03 fc fd ff 	lea    rdx,[rip+0xfffffffffffdfc03]        # 203788 <lookup_table.13>
  223b85:	48 8b 34 11          	mov    rsi,QWORD PTR [rcx+rdx*1]
  223b89:	c4 61 f9 6e c6       	vmovq  xmm8,rsi
    const new_bits = bits & 0xFFFFFFFFF8000000;
  223b8e:	48 81 e6 00 00 00 f8 	and    rsi,0xfffffffff8000000
    return @bitCast(f64, new_bits);
  223b95:	c4 e1 f9 6e c6       	vmovq  xmm0,rsi
    lo.* = val - hi.*;
  223b9a:	c5 bb 5c e0          	vsubsd xmm4,xmm8,xmm0
    const new_bits = bits & 0xFFFFFFFFF8000000;
  223b9e:	48 89 ee             	mov    rsi,rbp
  223ba1:	48 81 e6 00 00 00 f8 	and    rsi,0xfffffffff8000000
    return @bitCast(f64, new_bits);
  223ba8:	c4 e1 f9 6e ee       	vmovq  xmm5,rsi
    lo.* = val - hi.*;
  223bad:	c5 a3 5c f5          	vsubsd xmm6,xmm11,xmm5
    const p = in.val * val;
  223bb1:	c4 c1 23 59 d8       	vmulsd xmm3,xmm11,xmm8
    const e = ((hi * hi2 - p) + lo * hi2 + hi * lo2) + lo * lo2;
  223bb6:	c5 d3 59 f8          	vmulsd xmm7,xmm5,xmm0
  223bba:	c5 c3 5c fb          	vsubsd xmm7,xmm7,xmm3
  223bbe:	c5 db 59 ed          	vmulsd xmm5,xmm4,xmm5
  223bc2:	c5 d3 58 ef          	vaddsd xmm5,xmm5,xmm7
  223bc6:	c5 cb 59 c0          	vmulsd xmm0,xmm6,xmm0
  223bca:	c5 fb 58 c5          	vaddsd xmm0,xmm0,xmm5
  223bce:	c5 cb 59 e4          	vmulsd xmm4,xmm6,xmm4
  223bd2:	c5 db 58 c0          	vaddsd xmm0,xmm4,xmm0
        .off = in.off * val + e,
  223bd6:	c5 a3 59 64 11 08    	vmulsd xmm4,xmm11,QWORD PTR [rcx+rdx*1+0x8]
  223bdc:	c5 db 58 f0          	vaddsd xmm6,xmm4,xmm0
    exp -= 307;
  223be0:	8d 80 cd fe ff ff    	lea    eax,[rax-0x133]
    while (mid.val > 10.0 or (mid.val == 10.0 and mid.off >= 0.0)) {
  223be6:	44 0f bf e8          	movsx  r13d,ax
  223bea:	c5 fb 10 25 96 d0 fd 	vmovsd xmm4,QWORD PTR [rip+0xfffffffffffdd096]        # 200c88 <__unnamed_456+0x38>
  223bf1:	ff 
  223bf2:	c5 7b 10 35 7e d0 fd 	vmovsd xmm14,QWORD PTR [rip+0xfffffffffffdd07e]        # 200c78 <__unnamed_456+0x28>
  223bf9:	ff 
  223bfa:	c5 fb 10 2d 16 d1 fd 	vmovsd xmm5,QWORD PTR [rip+0xfffffffffffdd116]        # 200d18 <app_mask+0x38>
  223c01:	ff 
  223c02:	c4 c1 79 2e de       	vucomisd xmm3,xmm14
  223c07:	76 46                	jbe    223c4f <formatFloatDecimal+0x93f>
  223c09:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
    hp.val /= 10.0;
  223c10:	c4 c1 63 5e fe       	vdivsd xmm7,xmm3,xmm14
    hp.off /= 10.0;
  223c15:	c4 c1 4b 5e f6       	vdivsd xmm6,xmm6,xmm14
    val -= hp.val * 8.0;
  223c1a:	c5 c3 59 d5          	vmulsd xmm2,xmm7,xmm5
  223c1e:	c5 e3 58 d2          	vaddsd xmm2,xmm3,xmm2
    val -= hp.val * 2.0;
  223c22:	c5 c3 58 df          	vaddsd xmm3,xmm7,xmm7
  223c26:	c5 eb 5c d3          	vsubsd xmm2,xmm2,xmm3
    hp.off += val / 10.0;
  223c2a:	c4 c1 6b 5e d6       	vdivsd xmm2,xmm2,xmm14
  223c2f:	c5 cb 58 d2          	vaddsd xmm2,xmm6,xmm2
    hp.val += hp.off;
  223c33:	c5 c3 58 da          	vaddsd xmm3,xmm7,xmm2
    hp.off += val - hp.val;
  223c37:	c5 c3 5c f3          	vsubsd xmm6,xmm7,xmm3
  223c3b:	c5 eb 58 f6          	vaddsd xmm6,xmm2,xmm6
        ten /= 10.0;
  223c3f:	c4 c1 5b 5e e6       	vdivsd xmm4,xmm4,xmm14
    while (mid.val > 10.0 or (mid.val == 10.0 and mid.off >= 0.0)) {
  223c44:	41 83 c5 01          	add    r13d,0x1
  223c48:	c4 c1 79 2e de       	vucomisd xmm3,xmm14
  223c4d:	77 c1                	ja     223c10 <formatFloatDecimal+0x900>
  223c4f:	c5 f9 2e f1          	vucomisd xmm6,xmm1
  223c53:	72 42                	jb     223c97 <formatFloatDecimal+0x987>
  223c55:	c4 c1 79 2e de       	vucomisd xmm3,xmm14
  223c5a:	75 3b                	jne    223c97 <formatFloatDecimal+0x987>
  223c5c:	7b b2                	jnp    223c10 <formatFloatDecimal+0x900>
  223c5e:	eb 37                	jmp    223c97 <formatFloatDecimal+0x987>
    hp.val *= 10.0;
  223c60:	c4 c1 63 59 ce       	vmulsd xmm1,xmm3,xmm14
    hp.off *= 10.0;
  223c65:	c4 c1 4b 59 d6       	vmulsd xmm2,xmm6,xmm14
    off -= val * 8.0;
  223c6a:	c5 e3 59 2d a6 d0 fd 	vmulsd xmm5,xmm3,QWORD PTR [rip+0xfffffffffffdd0a6]        # 200d18 <app_mask+0x38>
  223c71:	ff 
  223c72:	c5 f3 58 ed          	vaddsd xmm5,xmm1,xmm5
    off -= val * 2.0;
  223c76:	c5 e3 58 db          	vaddsd xmm3,xmm3,xmm3
  223c7a:	c5 d3 5c db          	vsubsd xmm3,xmm5,xmm3
    hp.off -= off;
  223c7e:	c5 eb 5c d3          	vsubsd xmm2,xmm2,xmm3
    hp.val += hp.off;
  223c82:	c5 f3 58 da          	vaddsd xmm3,xmm1,xmm2
    hp.off += val - hp.val;
  223c86:	c5 f3 5c cb          	vsubsd xmm1,xmm1,xmm3
  223c8a:	c5 eb 58 f1          	vaddsd xmm6,xmm2,xmm1
        ten *= 10.0;
  223c8e:	c4 c1 5b 59 e6       	vmulsd xmm4,xmm4,xmm14
    while (mid.val < 1.0 or (mid.val == 1.0 and mid.off < 0.0)) {
  223c93:	41 83 c5 ff          	add    r13d,0xffffffff
  223c97:	c5 7b 10 0d e9 cf fd 	vmovsd xmm9,QWORD PTR [rip+0xfffffffffffdcfe9]        # 200c88 <__unnamed_456+0x38>
  223c9e:	ff 
  223c9f:	c5 79 2e cb          	vucomisd xmm9,xmm3
  223ca3:	77 bb                	ja     223c60 <formatFloatDecimal+0x950>
  223ca5:	c4 41 29 57 d2       	vxorpd xmm10,xmm10,xmm10
  223caa:	c5 79 2e d6          	vucomisd xmm10,xmm6
  223cae:	76 0c                	jbe    223cbc <formatFloatDecimal+0x9ac>
  223cb0:	c5 f9 2e 1d d0 cf fd 	vucomisd xmm3,QWORD PTR [rip+0xfffffffffffdcfd0]        # 200c88 <__unnamed_456+0x38>
  223cb7:	ff 
  223cb8:	75 02                	jne    223cbc <formatFloatDecimal+0x9ac>
  223cba:	7b a4                	jnp    223c60 <formatFloatDecimal+0x950>
    return @bitCast(f64, @bitCast(u64, val) +% 1);
  223cbc:	48 8d 45 01          	lea    rax,[rbp+0x1]
  223cc0:	c4 e1 f9 6e c8       	vmovq  xmm1,rax
        .off = mid.off + (fpnext(val) - val) * lten * ten / 2.0,
  223cc5:	c4 c1 73 5c cb       	vsubsd xmm1,xmm1,xmm11
    return @bitCast(f64, @bitCast(u64, val) -% 1);
  223cca:	48 83 c5 ff          	add    rbp,0xffffffffffffffff
  223cce:	c4 e1 f9 6e d5       	vmovq  xmm2,rbp
        .off = mid.off + (fpprev(val) - val) * lten * ten / 2.0,
  223cd3:	c4 c1 6b 5c d3       	vsubsd xmm2,xmm2,xmm11
        .off = mid.off + (fpnext(val) - val) * lten * ten / 2.0,
  223cd8:	c5 f1 14 ca          	vunpcklpd xmm1,xmm1,xmm2
  223cdc:	c4 c1 7b 12 d0       	vmovddup xmm2,xmm8
  223ce1:	c5 f1 59 ca          	vmulpd xmm1,xmm1,xmm2
  223ce5:	c5 fb 12 d4          	vmovddup xmm2,xmm4
  223ce9:	c5 f1 59 ca          	vmulpd xmm1,xmm1,xmm2
  223ced:	c5 f1 59 0d 1b c8 fd 	vmulpd xmm1,xmm1,XMMWORD PTR [rip+0xfffffffffffdc81b]        # 200510 <__unnamed_52+0x10>
  223cf4:	ff 
  223cf5:	c5 fb 12 d6          	vmovddup xmm2,xmm6
  223cf9:	c5 e9 58 c9          	vaddpd xmm1,xmm2,xmm1
    hp.val += hp.off;
  223cfd:	c5 e3 58 e1          	vaddsd xmm4,xmm3,xmm1
    hp.off += val - hp.val;
  223d01:	c5 e3 5c d4          	vsubsd xmm2,xmm3,xmm4
  223d05:	c5 e9 14 d3          	vunpcklpd xmm2,xmm2,xmm3
  223d09:	c5 f1 58 d2          	vaddpd xmm2,xmm1,xmm2
  223d0d:	c4 e3 79 05 f2 01    	vpermilpd xmm6,xmm2,0x1
  223d13:	c5 e3 5c f6          	vsubsd xmm6,xmm3,xmm6
    while (high.val > 10.0 or (high.val == 10.0 and high.off >= 0.0)) {
  223d17:	c4 e3 79 05 c9 01    	vpermilpd xmm1,xmm1,0x1
  223d1d:	c5 7b 10 1d 03 d0 fd 	vmovsd xmm11,QWORD PTR [rip+0xfffffffffffdd003]        # 200d28 <app_mask+0x48>
  223d24:	ff 
  223d25:	c5 79 28 05 03 c6 fd 	vmovapd xmm8,XMMWORD PTR [rip+0xfffffffffffdc603]        # 200330 <__unnamed_74+0x10>
  223d2c:	ff 
    hp.off += val - hp.val;
  223d2d:	c5 f3 58 ce          	vaddsd xmm1,xmm1,xmm6
    while (high.val > 10.0 or (high.val == 10.0 and high.off >= 0.0)) {
  223d31:	c4 c1 79 2e e6       	vucomisd xmm4,xmm14
  223d36:	0f 86 8a 00 00 00    	jbe    223dc6 <formatFloatDecimal+0xab6>
  223d3c:	eb 13                	jmp    223d51 <formatFloatDecimal+0xa41>
  223d3e:	66 90                	xchg   ax,ax
  223d40:	c4 c1 79 2e e6       	vucomisd xmm4,xmm14
  223d45:	0f 85 86 00 00 00    	jne    223dd1 <formatFloatDecimal+0xac1>
  223d4b:	0f 8a 80 00 00 00    	jp     223dd1 <formatFloatDecimal+0xac1>
    hp.val /= 10.0;
  223d51:	c4 c1 5b 5e f6       	vdivsd xmm6,xmm4,xmm14
    val -= hp.val * 8.0;
  223d56:	c4 c1 4b 59 eb       	vmulsd xmm5,xmm6,xmm11
    hp.val /= 10.0;
  223d5b:	c4 e3 79 05 fa 01    	vpermilpd xmm7,xmm2,0x1
  223d61:	c4 c1 43 5e fe       	vdivsd xmm7,xmm7,xmm14
    hp.off /= 10.0;
  223d66:	c5 e9 14 c9          	vunpcklpd xmm1,xmm2,xmm1
  223d6a:	c4 c1 71 5e c8       	vdivpd xmm1,xmm1,xmm8
    val -= hp.val * 8.0;
  223d6f:	c4 c1 43 59 db       	vmulsd xmm3,xmm7,xmm11
  223d74:	c4 e3 69 0d d4 01    	vblendpd xmm2,xmm2,xmm4,0x1
  223d7a:	c5 d1 14 db          	vunpcklpd xmm3,xmm5,xmm3
  223d7e:	c5 e9 5c d3          	vsubpd xmm2,xmm2,xmm3
    val -= hp.val * 2.0;
  223d82:	c5 c9 14 df          	vunpcklpd xmm3,xmm6,xmm7
  223d86:	c5 e1 58 db          	vaddpd xmm3,xmm3,xmm3
  223d8a:	c5 e9 5c d3          	vsubpd xmm2,xmm2,xmm3
    hp.off += val / 10.0;
  223d8e:	c4 c1 69 5e d0       	vdivpd xmm2,xmm2,xmm8
  223d93:	c5 f1 58 ca          	vaddpd xmm1,xmm1,xmm2
    hp.val += hp.off;
  223d97:	c5 cb 58 e1          	vaddsd xmm4,xmm6,xmm1
    hp.off += val - hp.val;
  223d9b:	c5 cb 5c d4          	vsubsd xmm2,xmm6,xmm4
  223d9f:	c5 e9 14 d7          	vunpcklpd xmm2,xmm2,xmm7
  223da3:	c5 f1 58 d2          	vaddpd xmm2,xmm1,xmm2
  223da7:	c4 e3 79 05 da 01    	vpermilpd xmm3,xmm2,0x1
  223dad:	c5 c3 5c f3          	vsubsd xmm6,xmm7,xmm3
    while (high.val > 10.0 or (high.val == 10.0 and high.off >= 0.0)) {
  223db1:	c4 e3 79 05 c9 01    	vpermilpd xmm1,xmm1,0x1
  223db7:	41 83 c5 01          	add    r13d,0x1
    hp.off += val - hp.val;
  223dbb:	c5 f3 58 ce          	vaddsd xmm1,xmm1,xmm6
    while (high.val > 10.0 or (high.val == 10.0 and high.off >= 0.0)) {
  223dbf:	c4 c1 79 2e e6       	vucomisd xmm4,xmm14
  223dc4:	77 8b                	ja     223d51 <formatFloatDecimal+0xa41>
  223dc6:	c4 c1 79 2e d2       	vucomisd xmm2,xmm10
  223dcb:	0f 83 6f ff ff ff    	jae    223d40 <formatFloatDecimal+0xa30>
  223dd1:	c5 d9 14 e1          	vunpcklpd xmm4,xmm4,xmm1
  223dd5:	c5 79 28 25 53 c5 fd 	vmovapd xmm12,XMMWORD PTR [rip+0xfffffffffffdc553]        # 200330 <__unnamed_74+0x10>
  223ddc:	ff 
  223ddd:	c4 41 39 57 c0       	vxorpd xmm8,xmm8,xmm8
    while (high.val < 1.0 or (high.val == 1.0 and high.off < 0.0)) {
  223de2:	c5 79 2e cc          	vucomisd xmm9,xmm4
  223de6:	0f 86 7e 00 00 00    	jbe    223e6a <formatFloatDecimal+0xb5a>
  223dec:	eb 0b                	jmp    223df9 <formatFloatDecimal+0xae9>
  223dee:	66 90                	xchg   ax,ax
  223df0:	c4 c1 79 2e e1       	vucomisd xmm4,xmm9
  223df5:	75 79                	jne    223e70 <formatFloatDecimal+0xb60>
  223df7:	7a 77                	jp     223e70 <formatFloatDecimal+0xb60>
    hp.val *= 10.0;
  223df9:	c4 c1 5b 59 ce       	vmulsd xmm1,xmm4,xmm14
    off -= val * 8.0;
  223dfe:	c4 c1 5b 59 eb       	vmulsd xmm5,xmm4,xmm11
  223e03:	c5 f3 5c ed          	vsubsd xmm5,xmm1,xmm5
    off -= val * 2.0;
  223e07:	c5 db 58 fc          	vaddsd xmm7,xmm4,xmm4
  223e0b:	c5 d3 5c ef          	vsubsd xmm5,xmm5,xmm7
    hp.off *= 10.0;
  223e0f:	c4 c1 69 59 fc       	vmulpd xmm7,xmm2,xmm12
  223e14:	c4 e3 79 05 e4 01    	vpermilpd xmm4,xmm4,0x1
  223e1a:	c4 c1 5b 59 e6       	vmulsd xmm4,xmm4,xmm14
    off -= val * 8.0;
  223e1f:	c4 e3 79 05 d2 01    	vpermilpd xmm2,xmm2,0x1
  223e25:	c4 c1 6b 59 db       	vmulsd xmm3,xmm2,xmm11
  223e2a:	c4 e3 79 05 f7 01    	vpermilpd xmm6,xmm7,0x1
  223e30:	c5 cb 5c db          	vsubsd xmm3,xmm6,xmm3
    off -= val * 2.0;
  223e34:	c5 eb 58 d2          	vaddsd xmm2,xmm2,xmm2
  223e38:	c5 e3 5c d2          	vsubsd xmm2,xmm3,xmm2
    hp.off -= off;
  223e3c:	c5 db 5c d2          	vsubsd xmm2,xmm4,xmm2
    hp.val += hp.off;
  223e40:	c5 cb 58 da          	vaddsd xmm3,xmm6,xmm2
    hp.off -= off;
  223e44:	c5 d1 14 e3          	vunpcklpd xmm4,xmm5,xmm3
  223e48:	c5 c1 5c ec          	vsubpd xmm5,xmm7,xmm4
    hp.val += hp.off;
  223e4c:	c5 f1 14 d2          	vunpcklpd xmm2,xmm1,xmm2
  223e50:	c5 e9 58 e5          	vaddpd xmm4,xmm2,xmm5
    hp.off += val - hp.val;
  223e54:	c5 f3 5c cc          	vsubsd xmm1,xmm1,xmm4
  223e58:	c5 d3 58 c9          	vaddsd xmm1,xmm5,xmm1
  223e5c:	c5 f1 14 d3          	vunpcklpd xmm2,xmm1,xmm3
    while (high.val < 1.0 or (high.val == 1.0 and high.off < 0.0)) {
  223e60:	41 83 c5 ff          	add    r13d,0xffffffff
  223e64:	c5 79 2e cc          	vucomisd xmm9,xmm4
  223e68:	77 8f                	ja     223df9 <formatFloatDecimal+0xae9>
  223e6a:	c5 79 2e c2          	vucomisd xmm8,xmm2
  223e6e:	77 80                	ja     223df0 <formatFloatDecimal+0xae0>
    while (true) {
  223e70:	c4 e3 79 05 ea 01    	vpermilpd xmm5,xmm2,0x1
  223e76:	41 bc 01 00 00 00    	mov    r12d,0x1
  223e7c:	bf 34 0b 00 00       	mov    edi,0xb34
  223e81:	c4 41 10 57 ed       	vxorps xmm13,xmm13,xmm13
  223e86:	c5 7b 10 0d 0a ce fd 	vmovsd xmm9,QWORD PTR [rip+0xfffffffffffdce0a]        # 200c98 <__unnamed_456+0x48>
  223e8d:	ff 
  223e8e:	c5 7b 10 15 3a ce fd 	vmovsd xmm10,QWORD PTR [rip+0xfffffffffffdce3a]        # 200cd0 <__unnamed_456+0x80>
  223e95:	ff 
  223e96:	c5 7b 10 05 12 ce fd 	vmovsd xmm8,QWORD PTR [rip+0xfffffffffffdce12]        # 200cb0 <__unnamed_456+0x60>
  223e9d:	ff 
    if (e >= 0x3FF + 52 or x == 0) {
  223e9e:	c4 c1 79 2e e5       	vucomisd xmm4,xmm13
  223ea3:	0f 85 ab 00 00 00    	jne    223f54 <formatFloatDecimal+0xc44>
  223ea9:	0f 8a a5 00 00 00    	jp     223f54 <formatFloatDecimal+0xc44>
  223eaf:	e9 07 01 00 00       	jmp    223fbb <formatFloatDecimal+0xcab>
  223eb4:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  223ebb:	00 00 00 00 00 
        buffer[buf_index] = hdig + '0';
  223ec0:	48 8b 04 24          	mov    rax,QWORD PTR [rsp]
        high.val -= @intToFloat(f64, hdig);
  223ec4:	0f b6 d1             	movzx  edx,cl
        buffer[buf_index] = hdig + '0';
  223ec7:	80 c1 30             	add    cl,0x30
  223eca:	42 88 0c 20          	mov    BYTE PTR [rax+r12*1],cl
        buf_index += 1;
  223ece:	49 83 c4 01          	add    r12,0x1
        high.val -= @intToFloat(f64, hdig);
  223ed2:	c5 83 2a ca          	vcvtsi2sd xmm1,xmm15,edx
  223ed6:	c5 db 5c d9          	vsubsd xmm3,xmm4,xmm1
        low.val -= @intToFloat(f64, ldig);
  223eda:	c5 d3 5c c9          	vsubsd xmm1,xmm5,xmm1
    hp.val *= 10.0;
  223ede:	c4 c1 63 59 ee       	vmulsd xmm5,xmm3,xmm14
    off -= val * 8.0;
  223ee3:	c4 c1 63 59 e3       	vmulsd xmm4,xmm3,xmm11
  223ee8:	c5 d3 5c e4          	vsubsd xmm4,xmm5,xmm4
    off -= val * 2.0;
  223eec:	c5 e3 58 db          	vaddsd xmm3,xmm3,xmm3
    hp.off *= 10.0;
  223ef0:	c5 e9 14 d1          	vunpcklpd xmm2,xmm2,xmm1
  223ef4:	c4 c1 69 59 d4       	vmulpd xmm2,xmm2,xmm12
  223ef9:	c4 c1 4b 59 f6       	vmulsd xmm6,xmm6,xmm14
    off -= val * 8.0;
  223efe:	c4 c1 73 59 fb       	vmulsd xmm7,xmm1,xmm11
  223f03:	c4 e3 79 05 c2 01    	vpermilpd xmm0,xmm2,0x1
  223f09:	c5 fb 5c c7          	vsubsd xmm0,xmm0,xmm7
    off -= val * 2.0;
  223f0d:	c5 f3 58 c9          	vaddsd xmm1,xmm1,xmm1
  223f11:	c5 fb 5c c1          	vsubsd xmm0,xmm0,xmm1
    hp.off -= off;
  223f15:	c5 cb 5c c0          	vsubsd xmm0,xmm6,xmm0
    off -= val * 2.0;
  223f19:	c4 e3 69 0d cc 01    	vblendpd xmm1,xmm2,xmm4,0x1
  223f1f:	c5 e1 14 d8          	vunpcklpd xmm3,xmm3,xmm0
  223f23:	c5 f1 5c e3          	vsubpd xmm4,xmm1,xmm3
  223f27:	c5 f1 58 cb          	vaddpd xmm1,xmm1,xmm3
  223f2b:	c4 e3 71 0d dc 01    	vblendpd xmm3,xmm1,xmm4,0x1
    hp.off -= off;
  223f31:	c5 e9 5c d3          	vsubpd xmm2,xmm2,xmm3
    hp.val += hp.off;
  223f35:	c5 d1 14 c0          	vunpcklpd xmm0,xmm5,xmm0
  223f39:	c5 f9 58 e2          	vaddpd xmm4,xmm0,xmm2
    hp.off += val - hp.val;
  223f3d:	c5 d3 5c c4          	vsubsd xmm0,xmm5,xmm4
  223f41:	c5 eb 58 d0          	vaddsd xmm2,xmm2,xmm0
    while (true) {
  223f45:	c4 e3 79 05 e9 01    	vpermilpd xmm5,xmm1,0x1
  223f4b:	c4 c1 79 2e e5       	vucomisd xmm4,xmm13
  223f50:	75 02                	jne    223f54 <formatFloatDecimal+0xc44>
  223f52:	7b 67                	jnp    223fbb <formatFloatDecimal+0xcab>
  223f54:	c4 e1 f9 7e e1       	vmovq  rcx,xmm4
  223f59:	c4 e2 c0 f7 d1       	bextr  rdx,rcx,rdi
  223f5e:	c5 f9 28 cc          	vmovapd xmm1,xmm4
  223f62:	48 81 fa 32 04 00 00 	cmp    rdx,0x432
  223f69:	77 54                	ja     223fbf <formatFloatDecimal+0xcaf>
    if (u >> 63 != 0) {
  223f6b:	48 85 c9             	test   rcx,rcx
  223f6e:	78 29                	js     223f99 <formatFloatDecimal+0xc89>
  223f70:	c4 c1 5b 58 ca       	vaddsd xmm1,xmm4,xmm10
  223f75:	c4 c1 73 58 c9       	vaddsd xmm1,xmm1,xmm9
    if (e <= 0x3FF - 1) {
  223f7a:	48 81 fa fe 03 00 00 	cmp    rdx,0x3fe
  223f81:	76 29                	jbe    223fac <formatFloatDecimal+0xc9c>
  223f83:	c5 f3 5c cc          	vsubsd xmm1,xmm1,xmm4
            return -1.0;
        } else {
            return 0.0;
        }
    } else if (y > 0) {
  223f87:	c4 c1 79 2e cd       	vucomisd xmm1,xmm13
  223f8c:	c5 db 58 c9          	vaddsd xmm1,xmm4,xmm1
  223f90:	76 2d                	jbe    223fbf <formatFloatDecimal+0xcaf>
        return x + y - 1;
  223f92:	c4 c1 73 58 c8       	vaddsd xmm1,xmm1,xmm8
  223f97:	eb 26                	jmp    223fbf <formatFloatDecimal+0xcaf>
  223f99:	c4 c1 5b 58 c9       	vaddsd xmm1,xmm4,xmm9
  223f9e:	c4 c1 73 58 ca       	vaddsd xmm1,xmm1,xmm10
    if (e <= 0x3FF - 1) {
  223fa3:	48 81 fa fe 03 00 00 	cmp    rdx,0x3fe
  223faa:	77 d7                	ja     223f83 <formatFloatDecimal+0xc73>
        if (u >> 63 != 0) {
  223fac:	c5 79 29 c1          	vmovapd xmm1,xmm8
    if (u >> 63 != 0) {
  223fb0:	48 85 c9             	test   rcx,rcx
        if (u >> 63 != 0) {
  223fb3:	78 0a                	js     223fbf <formatFloatDecimal+0xcaf>
  223fb5:	c5 f1 57 c9          	vxorpd xmm1,xmm1,xmm1
  223fb9:	eb 04                	jmp    223fbf <formatFloatDecimal+0xcaf>
  223fbb:	c5 f9 28 cc          	vmovapd xmm1,xmm4
        var hdig = @floatToInt(u8, math.floor(high.val));
  223fbf:	c5 fb 2c c9          	vcvttsd2si ecx,xmm1
        if ((high.val == @intToFloat(f64, hdig)) and (high.off < 0)) hdig -= 1;
  223fc3:	0f b6 c9             	movzx  ecx,cl
  223fc6:	c5 83 2a c9          	vcvtsi2sd xmm1,xmm15,ecx
  223fca:	c5 f9 2e e1          	vucomisd xmm4,xmm1
  223fce:	0f 9b c2             	setnp  dl
  223fd1:	0f 94 c3             	sete   bl
  223fd4:	20 d3                	and    bl,dl
  223fd6:	c5 79 2e ea          	vucomisd xmm13,xmm2
  223fda:	0f 97 c2             	seta   dl
  223fdd:	20 da                	and    dl,bl
  223fdf:	28 d1                	sub    cl,dl
    if (e >= 0x3FF + 52 or x == 0) {
  223fe1:	c4 c1 79 2e ed       	vucomisd xmm5,xmm13
  223fe6:	c5 f9 28 cd          	vmovapd xmm1,xmm5
  223fea:	75 02                	jne    223fee <formatFloatDecimal+0xcde>
  223fec:	7b 72                	jnp    224060 <formatFloatDecimal+0xd50>
  223fee:	c4 e1 f9 7e ea       	vmovq  rdx,xmm5
  223ff3:	c4 e2 c0 f7 f2       	bextr  rsi,rdx,rdi
  223ff8:	c5 f9 28 cd          	vmovapd xmm1,xmm5
  223ffc:	48 81 fe 32 04 00 00 	cmp    rsi,0x432
  224003:	77 5b                	ja     224060 <formatFloatDecimal+0xd50>
    if (u >> 63 != 0) {
  224005:	48 85 d2             	test   rdx,rdx
  224008:	78 29                	js     224033 <formatFloatDecimal+0xd23>
  22400a:	c4 c1 53 58 ca       	vaddsd xmm1,xmm5,xmm10
  22400f:	c4 c1 73 58 c9       	vaddsd xmm1,xmm1,xmm9
    if (e <= 0x3FF - 1) {
  224014:	48 81 fe fe 03 00 00 	cmp    rsi,0x3fe
  22401b:	76 29                	jbe    224046 <formatFloatDecimal+0xd36>
  22401d:	c5 f3 5c cd          	vsubsd xmm1,xmm1,xmm5
    } else if (y > 0) {
  224021:	c4 c1 79 2e cd       	vucomisd xmm1,xmm13
  224026:	c5 d3 58 c9          	vaddsd xmm1,xmm5,xmm1
  22402a:	76 34                	jbe    224060 <formatFloatDecimal+0xd50>
        return x + y - 1;
  22402c:	c4 c1 73 58 c8       	vaddsd xmm1,xmm1,xmm8
  224031:	eb 2d                	jmp    224060 <formatFloatDecimal+0xd50>
  224033:	c4 c1 53 58 c9       	vaddsd xmm1,xmm5,xmm9
  224038:	c4 c1 73 58 ca       	vaddsd xmm1,xmm1,xmm10
    if (e <= 0x3FF - 1) {
  22403d:	48 81 fe fe 03 00 00 	cmp    rsi,0x3fe
  224044:	77 d7                	ja     22401d <formatFloatDecimal+0xd0d>
        if (u >> 63 != 0) {
  224046:	c5 79 29 c1          	vmovapd xmm1,xmm8
    if (u >> 63 != 0) {
  22404a:	48 85 d2             	test   rdx,rdx
        if (u >> 63 != 0) {
  22404d:	78 11                	js     224060 <formatFloatDecimal+0xd50>
  22404f:	c5 f1 57 c9          	vxorpd xmm1,xmm1,xmm1
  224053:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  22405a:	84 00 00 00 00 00 
        var ldig = @floatToInt(u8, math.floor(low.val));
  224060:	c5 fb 2c d1          	vcvttsd2si edx,xmm1
        if ((low.val == @intToFloat(f64, ldig)) and (low.off < 0)) ldig -= 1;
  224064:	0f b6 d2             	movzx  edx,dl
  224067:	c5 83 2a ca          	vcvtsi2sd xmm1,xmm15,edx
  22406b:	c5 f9 2e e9          	vucomisd xmm5,xmm1
  22406f:	0f 9b c3             	setnp  bl
  224072:	0f 94 c0             	sete   al
  224075:	20 d8                	and    al,bl
  224077:	c4 e3 79 05 f4 01    	vpermilpd xmm6,xmm4,0x1
  22407d:	c5 79 2e ee          	vucomisd xmm13,xmm6
  224081:	0f 97 c3             	seta   bl
  224084:	20 c3                	and    bl,al
  224086:	28 da                	sub    dl,bl
        if (ldig != hdig) break;
  224088:	38 ca                	cmp    dl,cl
  22408a:	0f 84 30 fe ff ff    	je     223ec0 <formatFloatDecimal+0xbb0>
    const tmp = (high.val + low.val) / 2.0;
  224090:	c5 db 58 c5          	vaddsd xmm0,xmm4,xmm5
  224094:	c5 fb 10 0d 1c cc fd 	vmovsd xmm1,QWORD PTR [rip+0xfffffffffffdcc1c]        # 200cb8 <__unnamed_456+0x68>
  22409b:	ff 
  22409c:	c5 fb 59 c1          	vmulsd xmm0,xmm0,xmm1
    var mdig = @floatToInt(u8, math.floor(tmp + 0.5));
  2240a0:	c5 fb 58 c9          	vaddsd xmm1,xmm0,xmm1
    if (e >= 0x3FF + 52 or x == 0) {
  2240a4:	c5 e9 57 d2          	vxorpd xmm2,xmm2,xmm2
  2240a8:	c5 f9 2e ca          	vucomisd xmm1,xmm2
  2240ac:	75 06                	jne    2240b4 <formatFloatDecimal+0xda4>
  2240ae:	0f 8b c9 05 00 00    	jnp    22467d <formatFloatDecimal+0x136d>
  2240b4:	c4 e1 f9 7e c8       	vmovq  rax,xmm1
  2240b9:	b9 34 0b 00 00       	mov    ecx,0xb34
  2240be:	c4 e2 f0 f7 c8       	bextr  rcx,rax,rcx
  2240c3:	48 81 f9 32 04 00 00 	cmp    rcx,0x432
  2240ca:	0f 87 ad 05 00 00    	ja     22467d <formatFloatDecimal+0x136d>
    if (u >> 63 != 0) {
  2240d0:	48 85 c0             	test   rax,rax
  2240d3:	0f 88 0f 01 00 00    	js     2241e8 <formatFloatDecimal+0xed8>
  2240d9:	c4 c1 73 58 d2       	vaddsd xmm2,xmm1,xmm10
  2240de:	c4 c1 6b 58 d1       	vaddsd xmm2,xmm2,xmm9
    if (e <= 0x3FF - 1) {
  2240e3:	48 81 f9 fe 03 00 00 	cmp    rcx,0x3fe
  2240ea:	0f 87 0f 01 00 00    	ja     2241ff <formatFloatDecimal+0xeef>
    if (u >> 63 != 0) {
  2240f0:	48 85 c0             	test   rax,rax
        if (u >> 63 != 0) {
  2240f3:	0f 88 7c 05 00 00    	js     224675 <formatFloatDecimal+0x1365>
  2240f9:	c5 f1 57 c9          	vxorpd xmm1,xmm1,xmm1
  2240fd:	e9 7b 05 00 00       	jmp    22467d <formatFloatDecimal+0x136d>
        while (i < mi) : (i += 1) {
  224102:	45 89 d1             	mov    r9d,r10d
  224105:	41 83 e1 f0          	and    r9d,0xfffffff0
  224109:	41 8d 49 f0          	lea    ecx,[r9-0x10]
  22410d:	89 ca                	mov    edx,ecx
  22410f:	c1 ea 04             	shr    edx,0x4
  224112:	44 8d 42 01          	lea    r8d,[rdx+0x1]
  224116:	83 f9 70             	cmp    ecx,0x70
  224119:	0f 83 03 01 00 00    	jae    224222 <formatFloatDecimal+0xf12>
  22411f:	c4 e2 7d 59 0d c0 cb 	vpbroadcastq ymm1,QWORD PTR [rip+0xfffffffffffdcbc0]        # 200ce8 <app_mask+0x8>
  224126:	fd ff 
  224128:	c5 fd 6f d9          	vmovdqa ymm3,ymm1
  22412c:	c5 fd 6f d1          	vmovdqa ymm2,ymm1
  224130:	c5 fd 6f c1          	vmovdqa ymm0,ymm1
  224134:	41 f6 c0 07          	test   r8b,0x7
  224138:	0f 85 70 01 00 00    	jne    2242ae <formatFloatDecimal+0xf9e>
  22413e:	e9 e5 01 00 00       	jmp    224328 <formatFloatDecimal+0x1018>
        while (buffer[j - 1] == '0') {
  224143:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
  224147:	42 80 7c 29 ff 30    	cmp    BYTE PTR [rcx+r13*1-0x1],0x30
  22414d:	49 89 d8             	mov    r8,rbx
  224150:	0f 85 f2 04 00 00    	jne    224648 <formatFloatDecimal+0x1338>
  224156:	49 8d 45 ff          	lea    rax,[r13-0x1]
  22415a:	4c 01 e9             	add    rcx,r13
  22415d:	48 83 c1 ff          	add    rcx,0xffffffffffffffff
  224161:	4d 89 ec             	mov    r12,r13
            buffer[j - 1] = 0;
  224164:	c6 01 00             	mov    BYTE PTR [rcx],0x0
        while (buffer[j - 1] == '0') {
  224167:	48 8b 14 24          	mov    rdx,QWORD PTR [rsp]
  22416b:	48 8d 0c 02          	lea    rcx,[rdx+rax*1]
  22416f:	48 83 c1 ff          	add    rcx,0xffffffffffffffff
  224173:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  224177:	42 80 7c 22 fe 30    	cmp    BYTE PTR [rdx+r12*1-0x2],0x30
  22417d:	4d 8d 64 24 ff       	lea    r12,[r12-0x1]
  224182:	74 e0                	je     224164 <formatFloatDecimal+0xe54>
  224184:	e9 c2 04 00 00       	jmp    22464b <formatFloatDecimal+0x133b>
        } else if ((mid == 0.5) and (buffer[j - 1] & 0x1) != 0) {
  224189:	0f 85 bc 04 00 00    	jne    22464b <formatFloatDecimal+0x133b>
  22418f:	0f 8a b6 04 00 00    	jp     22464b <formatFloatDecimal+0x133b>
  224195:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
  224199:	8a 14 01             	mov    dl,BYTE PTR [rcx+rax*1]
  22419c:	f6 c2 01             	test   dl,0x1
  22419f:	0f 84 a6 04 00 00    	je     22464b <formatFloatDecimal+0x133b>
            buffer[j - 1] += 1;
  2241a5:	80 c2 01             	add    dl,0x1
  2241a8:	88 14 01             	mov    BYTE PTR [rcx+rax*1],dl
  2241ab:	e9 9b 04 00 00       	jmp    22464b <formatFloatDecimal+0x133b>
  2241b0:	c5 fb 58 d2          	vaddsd xmm2,xmm0,xmm2
  2241b4:	c5 eb 58 d3          	vaddsd xmm2,xmm2,xmm3
    if (e <= 0x3FF - 1) {
  2241b8:	48 81 f9 fe 03 00 00 	cmp    rcx,0x3fe
  2241bf:	0f 86 4d f7 ff ff    	jbe    223912 <formatFloatDecimal+0x602>
  2241c5:	c5 eb 5c d0          	vsubsd xmm2,xmm2,xmm0
    } else if (y > 0) {
  2241c9:	c5 e1 57 db          	vxorpd xmm3,xmm3,xmm3
  2241cd:	c5 f9 2e d3          	vucomisd xmm2,xmm3
  2241d1:	c5 fb 58 c2          	vaddsd xmm0,xmm0,xmm2
  2241d5:	0f 86 7b f9 ff ff    	jbe    223b56 <formatFloatDecimal+0x846>
        return x + y - 1;
  2241db:	c5 fb 58 05 cd ca fd 	vaddsd xmm0,xmm0,QWORD PTR [rip+0xfffffffffffdcacd]        # 200cb0 <__unnamed_456+0x60>
  2241e2:	ff 
  2241e3:	e9 6e f9 ff ff       	jmp    223b56 <formatFloatDecimal+0x846>
  2241e8:	c4 c1 73 58 d1       	vaddsd xmm2,xmm1,xmm9
  2241ed:	c4 c1 6b 58 d2       	vaddsd xmm2,xmm2,xmm10
    if (e <= 0x3FF - 1) {
  2241f2:	48 81 f9 fe 03 00 00 	cmp    rcx,0x3fe
  2241f9:	0f 86 f1 fe ff ff    	jbe    2240f0 <formatFloatDecimal+0xde0>
  2241ff:	c5 eb 5c d1          	vsubsd xmm2,xmm2,xmm1
    } else if (y > 0) {
  224203:	c5 e1 57 db          	vxorpd xmm3,xmm3,xmm3
  224207:	c5 f9 2e d3          	vucomisd xmm2,xmm3
  22420b:	c5 f3 58 ca          	vaddsd xmm1,xmm1,xmm2
  22420f:	0f 86 68 04 00 00    	jbe    22467d <formatFloatDecimal+0x136d>
        return x + y - 1;
  224215:	c5 f3 58 0d 93 ca fd 	vaddsd xmm1,xmm1,QWORD PTR [rip+0xfffffffffffdca93]        # 200cb0 <__unnamed_456+0x60>
  22421c:	ff 
  22421d:	e9 5b 04 00 00       	jmp    22467d <formatFloatDecimal+0x136d>
        while (i < mi) : (i += 1) {
  224222:	44 89 c1             	mov    ecx,r8d
  224225:	83 e1 07             	and    ecx,0x7
  224228:	83 c1 ff             	add    ecx,0xffffffff
  22422b:	29 d1                	sub    ecx,edx
  22422d:	c4 e2 7d 59 0d b2 ca 	vpbroadcastq ymm1,QWORD PTR [rip+0xfffffffffffdcab2]        # 200ce8 <app_mask+0x8>
  224234:	fd ff 
  224236:	c4 e2 7d 59 25 51 ca 	vpbroadcastq ymm4,QWORD PTR [rip+0xfffffffffffdca51]        # 200c90 <__unnamed_456+0x40>
  22423d:	fd ff 
  22423f:	c5 fd 6f d9          	vmovdqa ymm3,ymm1
  224243:	c5 fd 6f d1          	vmovdqa ymm2,ymm1
  224247:	c5 fd 6f c1          	vmovdqa ymm0,ymm1
            x *= 10;
  22424b:	c5 f5 f4 ec          	vpmuludq ymm5,ymm1,ymm4
  22424f:	c5 f5 73 d1 20       	vpsrlq ymm1,ymm1,0x20
  224254:	c5 f5 f4 cc          	vpmuludq ymm1,ymm1,ymm4
  224258:	c5 f5 73 f1 20       	vpsllq ymm1,ymm1,0x20
  22425d:	c5 d5 d4 c9          	vpaddq ymm1,ymm5,ymm1
  224261:	c5 e5 f4 ec          	vpmuludq ymm5,ymm3,ymm4
  224265:	c5 e5 73 d3 20       	vpsrlq ymm3,ymm3,0x20
  22426a:	c5 e5 f4 dc          	vpmuludq ymm3,ymm3,ymm4
  22426e:	c5 e5 73 f3 20       	vpsllq ymm3,ymm3,0x20
  224273:	c5 d5 d4 db          	vpaddq ymm3,ymm5,ymm3
  224277:	c5 ed f4 ec          	vpmuludq ymm5,ymm2,ymm4
  22427b:	c5 ed 73 d2 20       	vpsrlq ymm2,ymm2,0x20
  224280:	c5 ed f4 d4          	vpmuludq ymm2,ymm2,ymm4
  224284:	c5 ed 73 f2 20       	vpsllq ymm2,ymm2,0x20
  224289:	c5 d5 d4 d2          	vpaddq ymm2,ymm5,ymm2
  22428d:	c5 fd f4 ec          	vpmuludq ymm5,ymm0,ymm4
  224291:	c5 fd 73 d0 20       	vpsrlq ymm0,ymm0,0x20
  224296:	c5 fd f4 c4          	vpmuludq ymm0,ymm0,ymm4
  22429a:	c5 fd 73 f0 20       	vpsllq ymm0,ymm0,0x20
  22429f:	c5 d5 d4 c0          	vpaddq ymm0,ymm5,ymm0
  2242a3:	83 c1 08             	add    ecx,0x8
  2242a6:	75 a3                	jne    22424b <formatFloatDecimal+0xf3b>
  2242a8:	41 f6 c0 07          	test   r8b,0x7
  2242ac:	74 7a                	je     224328 <formatFloatDecimal+0x1018>
  2242ae:	44 89 d2             	mov    edx,r10d
  2242b1:	83 e2 70             	and    edx,0x70
  2242b4:	83 c2 f0             	add    edx,0xfffffff0
  2242b7:	c1 ea 04             	shr    edx,0x4
  2242ba:	83 c2 01             	add    edx,0x1
  2242bd:	83 e2 07             	and    edx,0x7
  2242c0:	f7 da                	neg    edx
  2242c2:	c4 e2 7d 59 25 b5 c9 	vpbroadcastq ymm4,QWORD PTR [rip+0xfffffffffffdc9b5]        # 200c80 <__unnamed_456+0x30>
  2242c9:	fd ff 
  2242cb:	c5 f5 f4 ec          	vpmuludq ymm5,ymm1,ymm4
  2242cf:	c5 f5 73 d1 20       	vpsrlq ymm1,ymm1,0x20
  2242d4:	c5 f5 f4 cc          	vpmuludq ymm1,ymm1,ymm4
  2242d8:	c5 f5 73 f1 20       	vpsllq ymm1,ymm1,0x20
  2242dd:	c5 d5 d4 c9          	vpaddq ymm1,ymm5,ymm1
  2242e1:	c5 e5 f4 ec          	vpmuludq ymm5,ymm3,ymm4
  2242e5:	c5 e5 73 d3 20       	vpsrlq ymm3,ymm3,0x20
  2242ea:	c5 e5 f4 dc          	vpmuludq ymm3,ymm3,ymm4
  2242ee:	c5 e5 73 f3 20       	vpsllq ymm3,ymm3,0x20
  2242f3:	c5 d5 d4 db          	vpaddq ymm3,ymm5,ymm3
  2242f7:	c5 ed f4 ec          	vpmuludq ymm5,ymm2,ymm4
  2242fb:	c5 ed 73 d2 20       	vpsrlq ymm2,ymm2,0x20
  224300:	c5 ed f4 d4          	vpmuludq ymm2,ymm2,ymm4
  224304:	c5 ed 73 f2 20       	vpsllq ymm2,ymm2,0x20
  224309:	c5 d5 d4 d2          	vpaddq ymm2,ymm5,ymm2
  22430d:	c5 fd f4 ec          	vpmuludq ymm5,ymm0,ymm4
  224311:	c5 fd 73 d0 20       	vpsrlq ymm0,ymm0,0x20
  224316:	c5 fd f4 c4          	vpmuludq ymm0,ymm0,ymm4
  22431a:	c5 fd 73 f0 20       	vpsllq ymm0,ymm0,0x20
  22431f:	c5 d5 d4 c0          	vpaddq ymm0,ymm5,ymm0
  224323:	83 c2 01             	add    edx,0x1
  224326:	75 a3                	jne    2242cb <formatFloatDecimal+0xfbb>
  224328:	c5 dd 73 d3 20       	vpsrlq ymm4,ymm3,0x20
  22432d:	c5 dd f4 e1          	vpmuludq ymm4,ymm4,ymm1
  224331:	c5 d5 73 d1 20       	vpsrlq ymm5,ymm1,0x20
  224336:	c5 e5 f4 ed          	vpmuludq ymm5,ymm3,ymm5
  22433a:	c5 d5 d4 e4          	vpaddq ymm4,ymm5,ymm4
  22433e:	c5 dd 73 f4 20       	vpsllq ymm4,ymm4,0x20
  224343:	c5 e5 f4 c9          	vpmuludq ymm1,ymm3,ymm1
  224347:	c5 f5 d4 cc          	vpaddq ymm1,ymm1,ymm4
  22434b:	c5 e5 73 d2 20       	vpsrlq ymm3,ymm2,0x20
  224350:	c5 e5 f4 d9          	vpmuludq ymm3,ymm3,ymm1
  224354:	c5 dd 73 d1 20       	vpsrlq ymm4,ymm1,0x20
  224359:	c5 ed f4 e4          	vpmuludq ymm4,ymm2,ymm4
  22435d:	c5 dd d4 db          	vpaddq ymm3,ymm4,ymm3
  224361:	c5 e5 73 f3 20       	vpsllq ymm3,ymm3,0x20
  224366:	c5 ed f4 c9          	vpmuludq ymm1,ymm2,ymm1
  22436a:	c5 f5 d4 cb          	vpaddq ymm1,ymm1,ymm3
  22436e:	c5 ed 73 d0 20       	vpsrlq ymm2,ymm0,0x20
  224373:	c5 ed f4 d1          	vpmuludq ymm2,ymm2,ymm1
  224377:	c5 e5 73 d1 20       	vpsrlq ymm3,ymm1,0x20
  22437c:	c5 fd f4 db          	vpmuludq ymm3,ymm0,ymm3
  224380:	c5 e5 d4 d2          	vpaddq ymm2,ymm3,ymm2
  224384:	c5 ed 73 f2 20       	vpsllq ymm2,ymm2,0x20
  224389:	c5 fd f4 c1          	vpmuludq ymm0,ymm0,ymm1
  22438d:	c5 fd d4 c2          	vpaddq ymm0,ymm0,ymm2
  224391:	c4 e3 7d 39 c1 01    	vextracti128 xmm1,ymm0,0x1
  224397:	c5 ed 73 d0 20       	vpsrlq ymm2,ymm0,0x20
  22439c:	c5 ed f4 d1          	vpmuludq ymm2,ymm2,ymm1
  2243a0:	c5 e5 73 d1 20       	vpsrlq ymm3,ymm1,0x20
  2243a5:	c5 fd f4 db          	vpmuludq ymm3,ymm0,ymm3
  2243a9:	c5 e5 d4 d2          	vpaddq ymm2,ymm3,ymm2
  2243ad:	c5 ed 73 f2 20       	vpsllq ymm2,ymm2,0x20
  2243b2:	c5 fd f4 c1          	vpmuludq ymm0,ymm0,ymm1
  2243b6:	c5 fd d4 c2          	vpaddq ymm0,ymm0,ymm2
  2243ba:	c5 f9 70 c8 4e       	vpshufd xmm1,xmm0,0x4e
  2243bf:	c5 ed 73 d0 20       	vpsrlq ymm2,ymm0,0x20
  2243c4:	c5 ed f4 d1          	vpmuludq ymm2,ymm2,ymm1
  2243c8:	c5 e5 73 d1 20       	vpsrlq ymm3,ymm1,0x20
  2243cd:	c5 fd f4 db          	vpmuludq ymm3,ymm0,ymm3
  2243d1:	c5 e5 d4 d2          	vpaddq ymm2,ymm3,ymm2
  2243d5:	c5 ed 73 f2 20       	vpsllq ymm2,ymm2,0x20
  2243da:	c5 fd f4 c1          	vpmuludq ymm0,ymm0,ymm1
  2243de:	c5 fd d4 c2          	vpaddq ymm0,ymm0,ymm2
  2243e2:	c4 e1 f9 7e c2       	vmovq  rdx,xmm0
  2243e7:	45 39 ca             	cmp    r10d,r9d
        while (i < mi) : (i += 1) {
  2243ea:	74 20                	je     22440c <formatFloatDecimal+0x10fc>
  2243ec:	41 09 c1             	or     r9d,eax
  2243ef:	44 89 c8             	mov    eax,r9d
            x *= 10;
  2243f2:	f7 d8                	neg    eax
  2243f4:	29 d8                	sub    eax,ebx
  2243f6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  2243fd:	00 00 00 
  224400:	48 01 d2             	add    rdx,rdx
  224403:	48 8d 14 92          	lea    rdx,[rdx+rdx*4]
        while (i < mi) : (i += 1) {
  224407:	83 c0 ff             	add    eax,0xffffffff
  22440a:	75 f4                	jne    224400 <formatFloatDecimal+0x10f0>
    const m64 = @truncate(u64, @divTrunc(mid, x));
  22440c:	31 c9                	xor    ecx,ecx
  22440e:	c5 f8 77             	vzeroupper 
  224411:	e8 9a 48 00 00       	call   228cb0 <__udivti3>
    if (lf != hf) {
  224416:	4c 39 64 24 10       	cmp    QWORD PTR [rsp+0x10],r12
    if (lf != hf) mi += 19;
  22441b:	44 0f 45 ed          	cmovne r13d,ebp
  22441f:	48 89 e6             	mov    rsi,rsp
    var buf_index = u64toa(m64, buffer) - 1;
  224422:	48 89 c7             	mov    rdi,rax
  224425:	e8 66 03 00 00       	call   224790 <u64toa>
  22442a:	49 89 c4             	mov    r12,rax
    if (mi != 0) {
  22442d:	45 85 ed             	test   r13d,r13d
  224430:	74 1c                	je     22444e <formatFloatDecimal+0x113e>
  224432:	4c 89 e0             	mov    rax,r12
  224435:	48 83 c0 ff          	add    rax,0xffffffffffffffff
        buffer[buf_index - 1] += @boolToInt(buffer[buf_index] >= '5');
  224439:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
  22443d:	42 80 7c 21 ff 34    	cmp    BYTE PTR [rcx+r12*1-0x1],0x34
  224443:	0f 97 c2             	seta   dl
  224446:	42 00 54 21 fe       	add    BYTE PTR [rcx+r12*1-0x2],dl
  22444b:	49 89 c4             	mov    r12,rax
  22444e:	4c 8b 44 24 20       	mov    r8,QWORD PTR [rsp+0x20]
        .digits = buffer[0..buf_index],
  224453:	4c 8b 0c 24          	mov    r9,QWORD PTR [rsp]
        .exp = @intCast(i32, buf_index) + mi,
  224457:	45 01 e5             	add    r13d,r12d
    if (maybe_precision) |precision| {
  22445a:	41 80 7e 08 01       	cmp    BYTE PTR [r14+0x8],0x1
  22445f:	0f 85 ac f5 ff ff    	jne    223a11 <formatFloatDecimal+0x701>
  224465:	49 8b 36             	mov    rsi,QWORD PTR [r14]
            if (float_decimal.exp >= 0) {
  224468:	45 85 ed             	test   r13d,r13d
  22446b:	78 15                	js     224482 <formatFloatDecimal+0x1172>
                round_digit = precision + @intCast(usize, float_decimal.exp);
  22446d:	49 63 cd             	movsxd rcx,r13d
  224470:	48 01 f1             	add    rcx,rsi
    if (round_digit < float_decimal.digits.len and float_decimal.digits[round_digit] - '0' >= 5) {
  224473:	4c 39 e1             	cmp    rcx,r12
  224476:	48 89 74 24 30       	mov    QWORD PTR [rsp+0x30],rsi
  22447b:	72 26                	jb     2244a3 <formatFloatDecimal+0x1193>
  22447d:	e9 a5 00 00 00       	jmp    224527 <formatFloatDecimal+0x1217>
                const min_exp_required = @intCast(usize, -float_decimal.exp);
  224482:	44 89 e8             	mov    eax,r13d
  224485:	f7 d8                	neg    eax
  224487:	48 98                	cdqe   
                if (precision > min_exp_required) {
  224489:	31 c9                	xor    ecx,ecx
  22448b:	48 89 f2             	mov    rdx,rsi
  22448e:	48 29 c2             	sub    rdx,rax
  224491:	48 0f 47 ca          	cmova  rcx,rdx
    if (round_digit < float_decimal.digits.len and float_decimal.digits[round_digit] - '0' >= 5) {
  224495:	4c 39 e1             	cmp    rcx,r12
  224498:	48 89 74 24 30       	mov    QWORD PTR [rsp+0x30],rsi
  22449d:	0f 83 84 00 00 00    	jae    224527 <formatFloatDecimal+0x1217>
  2244a3:	41 8a 04 09          	mov    al,BYTE PTR [r9+rcx*1]
  2244a7:	04 d0                	add    al,0xd0
  2244a9:	3c 05                	cmp    al,0x5
  2244ab:	72 7a                	jb     224527 <formatFloatDecimal+0x1217>
            if (i == 0) {
  2244ad:	48 85 c9             	test   rcx,rcx
  2244b0:	74 64                	je     224516 <formatFloatDecimal+0x1206>
            const new_value = (float_decimal.digits[i] - '0' + 1) % 10;
  2244b2:	41 8a 44 09 ff       	mov    al,BYTE PTR [r9+rcx*1-0x1]
  2244b7:	04 d1                	add    al,0xd1
  2244b9:	0f b6 f0             	movzx  esi,al
  2244bc:	69 c6 cd 00 00 00    	imul   eax,esi,0xcd
  2244c2:	ba 0b 05 00 00       	mov    edx,0x50b
  2244c7:	c4 e2 68 f7 c0       	bextr  eax,eax,edx
  2244cc:	b3 0a                	mov    bl,0xa
  2244ce:	f6 e3                	mul    bl
  2244d0:	40 28 c6             	sub    sil,al
            float_decimal.digits[i] = new_value + '0';
  2244d3:	89 f0                	mov    eax,esi
  2244d5:	0c 30                	or     al,0x30
  2244d7:	41 88 44 09 ff       	mov    BYTE PTR [r9+rcx*1-0x1],al
            if (new_value != 0) {
  2244dc:	40 84 f6             	test   sil,sil
  2244df:	75 46                	jne    224527 <formatFloatDecimal+0x1217>
            if (i == 0) {
  2244e1:	48 83 f9 01          	cmp    rcx,0x1
  2244e5:	74 2f                	je     224516 <formatFloatDecimal+0x1206>
            const new_value = (float_decimal.digits[i] - '0' + 1) % 10;
  2244e7:	41 0f b6 44 09 fe    	movzx  eax,BYTE PTR [r9+rcx*1-0x2]
  2244ed:	04 d1                	add    al,0xd1
  2244ef:	0f b6 f0             	movzx  esi,al
  2244f2:	69 c6 cd 00 00 00    	imul   eax,esi,0xcd
  2244f8:	c4 e2 68 f7 c0       	bextr  eax,eax,edx
  2244fd:	f6 e3                	mul    bl
  2244ff:	40 28 c6             	sub    sil,al
            float_decimal.digits[i] = new_value + '0';
  224502:	89 f0                	mov    eax,esi
  224504:	0c 30                	or     al,0x30
  224506:	41 88 44 09 fe       	mov    BYTE PTR [r9+rcx*1-0x2],al
            if (new_value != 0) {
  22450b:	48 83 c1 ff          	add    rcx,0xffffffffffffffff
  22450f:	40 84 f6             	test   sil,sil
  224512:	74 cd                	je     2244e1 <formatFloatDecimal+0x11d1>
  224514:	eb 11                	jmp    224527 <formatFloatDecimal+0x1217>
                float_decimal.exp += 1;
  224516:	41 83 c5 01          	add    r13d,0x1
                float_decimal.digits = one_before[0 .. float_decimal.digits.len + 1];
  22451a:	49 83 c4 01          	add    r12,0x1
                float_decimal.digits[0] = '1';
  22451e:	41 c6 41 ff 31       	mov    BYTE PTR [r9-0x1],0x31
                const one_before = @intToPtr([*]u8, @ptrToInt(&float_decimal.digits[0]) - 1);
  224523:	49 83 c1 ff          	add    r9,0xffffffffffffffff
        var num_digits_whole = if (float_decimal.exp > 0) @intCast(usize, float_decimal.exp) else 0;
  224527:	31 db                	xor    ebx,ebx
  224529:	45 85 ed             	test   r13d,r13d
  22452c:	44 89 e8             	mov    eax,r13d
  22452f:	48 0f 4f d8          	cmovg  rbx,rax
  224533:	4c 39 e3             	cmp    rbx,r12
  224536:	4c 89 e0             	mov    rax,r12
  224539:	48 0f 42 c3          	cmovb  rax,rbx
  22453d:	45 85 ed             	test   r13d,r13d
        if (num_digits_whole > 0) {
  224540:	4c 89 4c 24 10       	mov    QWORD PTR [rsp+0x10],r9
  224545:	48 89 44 24 48       	mov    QWORD PTR [rsp+0x48],rax
  22454a:	7e 5a                	jle    2245a6 <formatFloatDecimal+0x1296>
            try output(context, float_decimal.digits[0..num_digits_whole_no_pad]);
  22454c:	4c 89 8c 24 b8 00 00 	mov    QWORD PTR [rsp+0xb8],r9
  224553:	00 
  224554:	48 89 84 24 c0 00 00 	mov    QWORD PTR [rsp+0xc0],rax
  22455b:	00 
  22455c:	48 8d b4 24 b8 00 00 	lea    rsi,[rsp+0xb8]
  224563:	00 
  224564:	4c 89 ff             	mov    rdi,r15
  224567:	4c 89 c5             	mov    rbp,r8
  22456a:	c5 f8 77             	vzeroupper 
  22456d:	41 ff d0             	call   r8
  224570:	66 85 c0             	test   ax,ax
  224573:	0f 85 55 ee ff ff    	jne    2233ce <formatFloatDecimal+0xbe>
            while (i < num_digits_whole) : (i += 1) {
  224579:	4c 39 e3             	cmp    rbx,r12
  22457c:	76 44                	jbe    2245c2 <formatFloatDecimal+0x12b2>
  22457e:	4c 8b 74 24 48       	mov    r14,QWORD PTR [rsp+0x48]
                try output(context, "0");
  224583:	4c 89 ff             	mov    rdi,r15
  224586:	48 8d 35 23 19 02 00 	lea    rsi,[rip+0x21923]        # 245eb0 <__unnamed_102>
  22458d:	48 89 e8             	mov    rax,rbp
  224590:	ff d0                	call   rax
  224592:	66 85 c0             	test   ax,ax
  224595:	0f 85 33 ee ff ff    	jne    2233ce <formatFloatDecimal+0xbe>
  22459b:	49 83 c6 01          	add    r14,0x1
            while (i < num_digits_whole) : (i += 1) {
  22459f:	49 39 de             	cmp    r14,rbx
  2245a2:	72 df                	jb     224583 <formatFloatDecimal+0x1273>
  2245a4:	eb 1c                	jmp    2245c2 <formatFloatDecimal+0x12b2>
            try output(context, "0");
  2245a6:	48 8d 35 03 19 02 00 	lea    rsi,[rip+0x21903]        # 245eb0 <__unnamed_102>
  2245ad:	4c 89 ff             	mov    rdi,r15
  2245b0:	4c 89 c5             	mov    rbp,r8
  2245b3:	c5 f8 77             	vzeroupper 
  2245b6:	41 ff d0             	call   r8
  2245b9:	66 85 c0             	test   ax,ax
  2245bc:	0f 85 0c ee ff ff    	jne    2233ce <formatFloatDecimal+0xbe>
        if (precision == 0) {
  2245c2:	48 83 7c 24 30 00    	cmp    QWORD PTR [rsp+0x30],0x0
  2245c8:	0f 84 b0 01 00 00    	je     22477e <formatFloatDecimal+0x146e>
        try output(context, ".");
  2245ce:	48 8d 35 cb 18 02 00 	lea    rsi,[rip+0x218cb]        # 245ea0 <__unnamed_104>
  2245d5:	4c 89 ff             	mov    rdi,r15
  2245d8:	48 89 6c 24 20       	mov    QWORD PTR [rsp+0x20],rbp
  2245dd:	ff d5                	call   rbp
  2245df:	66 85 c0             	test   ax,ax
  2245e2:	0f 85 e6 ed ff ff    	jne    2233ce <formatFloatDecimal+0xbe>
        if (float_decimal.exp <= 0) {
  2245e8:	45 85 ed             	test   r13d,r13d
  2245eb:	0f 8e 37 01 00 00    	jle    224728 <formatFloatDecimal+0x1418>
  2245f1:	31 db                	xor    ebx,ebx
  2245f3:	48 8b 4c 24 20       	mov    rcx,QWORD PTR [rsp+0x20]
  2245f8:	48 8b 44 24 30       	mov    rax,QWORD PTR [rsp+0x30]
        debug.assert(precision >= printed);
  2245fd:	48 39 d8             	cmp    rax,rbx
  224600:	0f 82 7f 01 00 00    	jb     224785 <formatFloatDecimal+0x1475>
  224606:	48 8b 74 24 48       	mov    rsi,QWORD PTR [rsp+0x48]
        if (num_digits_whole_no_pad + precision - printed < float_decimal.digits.len) {
  22460b:	48 8d 04 06          	lea    rax,[rsi+rax*1]
  22460f:	48 29 d8             	sub    rax,rbx
  224612:	4c 39 e0             	cmp    rax,r12
  224615:	48 8b 54 24 10       	mov    rdx,QWORD PTR [rsp+0x10]
  22461a:	0f 83 a2 00 00 00    	jae    2246c2 <formatFloatDecimal+0x13b2>
            try output(context, float_decimal.digits[num_digits_whole_no_pad .. num_digits_whole_no_pad + precision - printed]);
  224620:	48 01 f2             	add    rdx,rsi
  224623:	48 89 94 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],rdx
  22462a:	00 
  22462b:	48 29 f0             	sub    rax,rsi
  22462e:	48 89 84 24 b0 00 00 	mov    QWORD PTR [rsp+0xb0],rax
  224635:	00 
  224636:	48 8d b4 24 a8 00 00 	lea    rsi,[rsp+0xa8]
  22463d:	00 
  22463e:	4c 89 ff             	mov    rdi,r15
  224641:	ff d1                	call   rcx
  224643:	e9 86 ed ff ff       	jmp    2233ce <formatFloatDecimal+0xbe>
  224648:	4d 89 ec             	mov    r12,r13
    buffer[j] = 0;
  22464b:	48 8b 04 24          	mov    rax,QWORD PTR [rsp]
  22464f:	42 c6 04 20 00       	mov    BYTE PTR [rax+r12*1],0x0
        .digits = buffer[0..j],
  224654:	4c 8b 0c 24          	mov    r9,QWORD PTR [rsp]
    if (maybe_precision) |precision| {
  224658:	41 80 7e 08 01       	cmp    BYTE PTR [r14+0x8],0x1
  22465d:	0f 84 02 fe ff ff    	je     224465 <formatFloatDecimal+0x1155>
  224663:	e9 a9 f3 ff ff       	jmp    223a11 <formatFloatDecimal+0x701>
  224668:	c5 fb 10 05 40 c6 fd 	vmovsd xmm0,QWORD PTR [rip+0xfffffffffffdc640]        # 200cb0 <__unnamed_456+0x60>
  22466f:	ff 
  224670:	e9 e1 f4 ff ff       	jmp    223b56 <formatFloatDecimal+0x846>
  224675:	c5 fb 10 0d 33 c6 fd 	vmovsd xmm1,QWORD PTR [rip+0xfffffffffffdc633]        # 200cb0 <__unnamed_456+0x60>
  22467c:	ff 
    var mdig = @floatToInt(u8, math.floor(tmp + 0.5));
  22467d:	c5 fb 2c c1          	vcvttsd2si eax,xmm1
    if ((@intToFloat(f64, mdig) - tmp) == 0.5 and (mdig & 0x1) != 0) mdig -= 1;
  224681:	0f b6 c0             	movzx  eax,al
  224684:	c5 83 2a c8          	vcvtsi2sd xmm1,xmm15,eax
  224688:	c5 f3 5c c0          	vsubsd xmm0,xmm1,xmm0
  22468c:	c5 f9 2e 05 24 c6 fd 	vucomisd xmm0,QWORD PTR [rip+0xfffffffffffdc624]        # 200cb8 <__unnamed_456+0x68>
  224693:	ff 
  224694:	0f 9b c1             	setnp  cl
  224697:	0f 94 c2             	sete   dl
  22469a:	20 ca                	and    dl,cl
  22469c:	20 c2                	and    dl,al
    buffer[buf_index] = mdig + '0';
  22469e:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
    if ((@intToFloat(f64, mdig) - tmp) == 0.5 and (mdig & 0x1) != 0) mdig -= 1;
  2246a2:	28 d0                	sub    al,dl
    buffer[buf_index] = mdig + '0';
  2246a4:	04 30                	add    al,0x30
  2246a6:	42 88 04 21          	mov    BYTE PTR [rcx+r12*1],al
        .digits = buffer[1..buf_index],
  2246aa:	4c 8b 0c 24          	mov    r9,QWORD PTR [rsp]
  2246ae:	49 83 c1 01          	add    r9,0x1
  2246b2:	41 80 7e 08 01       	cmp    BYTE PTR [r14+0x8],0x1
  2246b7:	0f 84 a8 fd ff ff    	je     224465 <formatFloatDecimal+0x1155>
  2246bd:	e9 4f f3 ff ff       	jmp    223a11 <formatFloatDecimal+0x701>
            try output(context, float_decimal.digits[num_digits_whole_no_pad..]);
  2246c2:	48 01 f2             	add    rdx,rsi
  2246c5:	48 89 94 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rdx
  2246cc:	00 
  2246cd:	49 29 f4             	sub    r12,rsi
  2246d0:	4c 89 a4 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],r12
  2246d7:	00 
  2246d8:	48 8d b4 24 98 00 00 	lea    rsi,[rsp+0x98]
  2246df:	00 
  2246e0:	4c 89 ff             	mov    rdi,r15
  2246e3:	ff d1                	call   rcx
  2246e5:	66 85 c0             	test   ax,ax
  2246e8:	0f 85 e0 ec ff ff    	jne    2233ce <formatFloatDecimal+0xbe>
            printed += float_decimal.digits.len - num_digits_whole_no_pad;
  2246ee:	4c 01 e3             	add    rbx,r12
            while (printed < precision) : (printed += 1) {
  2246f1:	48 3b 5c 24 30       	cmp    rbx,QWORD PTR [rsp+0x30]
  2246f6:	0f 83 82 00 00 00    	jae    22477e <formatFloatDecimal+0x146e>
  2246fc:	48 8d 2d ad 17 02 00 	lea    rbp,[rip+0x217ad]        # 245eb0 <__unnamed_102>
                try output(context, "0");
  224703:	4c 89 ff             	mov    rdi,r15
  224706:	48 89 ee             	mov    rsi,rbp
  224709:	ff 54 24 20          	call   QWORD PTR [rsp+0x20]
  22470d:	66 85 c0             	test   ax,ax
  224710:	0f 85 b8 ec ff ff    	jne    2233ce <formatFloatDecimal+0xbe>
  224716:	48 83 c3 01          	add    rbx,0x1
  22471a:	31 c0                	xor    eax,eax
            while (printed < precision) : (printed += 1) {
  22471c:	48 3b 5c 24 30       	cmp    rbx,QWORD PTR [rsp+0x30]
  224721:	72 e0                	jb     224703 <formatFloatDecimal+0x13f3>
  224723:	e9 a6 ec ff ff       	jmp    2233ce <formatFloatDecimal+0xbe>
            const zero_digit_count = @intCast(usize, -float_decimal.exp);
  224728:	41 f7 dd             	neg    r13d
  22472b:	4d 63 f5             	movsxd r14,r13d
  22472e:	48 8b 44 24 30       	mov    rax,QWORD PTR [rsp+0x30]
  224733:	4c 39 f0             	cmp    rax,r14
  224736:	4c 0f 46 f0          	cmovbe r14,rax
            while (i < zeros_to_print) : (i += 1) {
  22473a:	4d 85 f6             	test   r14,r14
  22473d:	48 8b 4c 24 20       	mov    rcx,QWORD PTR [rsp+0x20]
  224742:	74 2a                	je     22476e <formatFloatDecimal+0x145e>
  224744:	31 db                	xor    ebx,ebx
  224746:	4c 8d 2d 63 17 02 00 	lea    r13,[rip+0x21763]        # 245eb0 <__unnamed_102>
                try output(context, "0");
  22474d:	4c 89 ff             	mov    rdi,r15
  224750:	4c 89 ee             	mov    rsi,r13
  224753:	ff d1                	call   rcx
  224755:	66 85 c0             	test   ax,ax
  224758:	0f 85 70 ec ff ff    	jne    2233ce <formatFloatDecimal+0xbe>
            while (i < zeros_to_print) : (i += 1) {
  22475e:	48 83 c3 01          	add    rbx,0x1
  224762:	4c 39 f3             	cmp    rbx,r14
  224765:	48 8b 4c 24 20       	mov    rcx,QWORD PTR [rsp+0x20]
  22476a:	72 e1                	jb     22474d <formatFloatDecimal+0x143d>
  22476c:	eb 02                	jmp    224770 <formatFloatDecimal+0x1460>
  22476e:	31 db                	xor    ebx,ebx
  224770:	48 8b 44 24 30       	mov    rax,QWORD PTR [rsp+0x30]
            if (printed >= precision) {
  224775:	48 39 c3             	cmp    rbx,rax
  224778:	0f 82 7f fe ff ff    	jb     2245fd <formatFloatDecimal+0x12ed>
  22477e:	31 c0                	xor    eax,eax
  224780:	e9 49 ec ff ff       	jmp    2233ce <formatFloatDecimal+0xbe>
            @panic("assertion failure");
  224785:	e8 56 fe fe ff       	call   2145e0 <panic>
  22478a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000224790 <u64toa>:
    if (value < kTen8) {
  224790:	41 57                	push   r15
  224792:	41 56                	push   r14
  224794:	53                   	push   rbx
  224795:	48 81 ff ff e0 f5 05 	cmp    rdi,0x5f5e0ff
  22479c:	77 4b                	ja     2247e9 <u64toa+0x59>
            const b: u32 = v / 10000;
  22479e:	89 f8                	mov    eax,edi
        if (v < 10000) {
  2247a0:	81 ff 0f 27 00 00    	cmp    edi,0x270f
  2247a6:	0f 87 48 01 00 00    	ja     2248f4 <u64toa+0x164>
            const d1: u32 = (v / 100) << 1;
  2247ac:	48 69 d0 1f 85 eb 51 	imul   rdx,rax,0x51eb851f
  2247b3:	48 c1 ea 25          	shr    rdx,0x25
            const d2: u32 = (v % 100) << 1;
  2247b7:	6b c2 64             	imul   eax,edx,0x64
            const d1: u32 = (v / 100) << 1;
  2247ba:	48 01 d2             	add    rdx,rdx
            const d2: u32 = (v % 100) << 1;
  2247bd:	89 f9                	mov    ecx,edi
  2247bf:	29 c1                	sub    ecx,eax
  2247c1:	48 01 c9             	add    rcx,rcx
            if (v >= 1000) {
  2247c4:	81 ff e8 03 00 00    	cmp    edi,0x3e8
  2247ca:	0f 82 bf 01 00 00    	jb     22498f <u64toa+0x1ff>
                buffer[buf_index] = c_digits_lut[d1];
  2247d0:	48 8b 06             	mov    rax,QWORD PTR [rsi]
  2247d3:	48 8d 3d 2e 15 fe ff 	lea    rdi,[rip+0xfffffffffffe152e]        # 205d08 <c_digits_lut>
  2247da:	8a 1c 3a             	mov    bl,BYTE PTR [rdx+rdi*1]
  2247dd:	88 18                	mov    BYTE PTR [rax],bl
  2247df:	b8 01 00 00 00       	mov    eax,0x1
  2247e4:	e9 b1 01 00 00       	jmp    22499a <u64toa+0x20a>
  2247e9:	48 b9 00 00 c1 6f f2 	movabs rcx,0x2386f26fc10000
  2247f0:	86 23 00 
    } else if (value < kTen16) {
  2247f3:	48 39 cf             	cmp    rdi,rcx
  2247f6:	0f 83 71 01 00 00    	jae    22496d <u64toa+0x1dd>
        const v0: u32 = @intCast(u32, value / kTen8);
  2247fc:	48 b8 fd ce 61 84 11 	movabs rax,0xabcc77118461cefd
  224803:	77 cc ab 
  224806:	48 89 fa             	mov    rdx,rdi
  224809:	c4 62 fb f6 f8       	mulx   r15,rax,rax
  22480e:	49 c1 ef 1a          	shr    r15,0x1a
        const v1: u32 = @intCast(u32, value % kTen8);
  224812:	49 69 cf 00 e1 f5 05 	imul   rcx,r15,0x5f5e100
  224819:	48 89 f8             	mov    rax,rdi
  22481c:	48 29 c8             	sub    rax,rcx
        const b0: u32 = v0 / 10000;
  22481f:	44 89 fb             	mov    ebx,r15d
  224822:	41 be 59 17 b7 d1    	mov    r14d,0xd1b71759
        const d1: u32 = (b0 / 100) << 1;
  224828:	48 69 cb 83 de 1b 43 	imul   rcx,rbx,0x431bde83
        const b0: u32 = v0 / 10000;
  22482f:	49 0f af de          	imul   rbx,r14
  224833:	48 c1 eb 2d          	shr    rbx,0x2d
        const c0: u32 = v0 % 10000;
  224837:	69 d3 10 27 00 00    	imul   edx,ebx,0x2710
  22483d:	41 29 d7             	sub    r15d,edx
        const d1: u32 = (b0 / 100) << 1;
  224840:	48 c1 e9 31          	shr    rcx,0x31
  224844:	81 e1 fe 3f 00 00    	and    ecx,0x3ffe
        const d2: u32 = (b0 % 100) << 1;
  22484a:	48 69 d3 1f 85 eb 51 	imul   rdx,rbx,0x51eb851f
  224851:	48 c1 ea 25          	shr    rdx,0x25
  224855:	6b d2 64             	imul   edx,edx,0x64
  224858:	29 d3                	sub    ebx,edx
  22485a:	48 01 db             	add    rbx,rbx
        const d3: u32 = (c0 / 100) << 1;
  22485d:	4d 69 df 1f 85 eb 51 	imul   r11,r15,0x51eb851f
  224864:	49 c1 eb 25          	shr    r11,0x25
        const d4: u32 = (c0 % 100) << 1;
  224868:	41 6b d3 64          	imul   edx,r11d,0x64
        const d3: u32 = (c0 / 100) << 1;
  22486c:	4d 01 db             	add    r11,r11
        const d4: u32 = (c0 % 100) << 1;
  22486f:	41 29 d7             	sub    r15d,edx
  224872:	4d 01 ff             	add    r15,r15
        const b1: u32 = v1 / 10000;
  224875:	4c 0f af f0          	imul   r14,rax
  224879:	49 c1 ee 2d          	shr    r14,0x2d
        const c1: u32 = v1 % 10000;
  22487d:	41 69 d6 10 27 00 00 	imul   edx,r14d,0x2710
        const d5: u32 = (b1 / 100) << 1;
  224884:	4c 69 c8 83 de 1b 43 	imul   r9,rax,0x431bde83
        const c1: u32 = v1 % 10000;
  22488b:	41 89 c0             	mov    r8d,eax
  22488e:	41 29 d0             	sub    r8d,edx
        const d5: u32 = (b1 / 100) << 1;
  224891:	49 c1 e9 31          	shr    r9,0x31
  224895:	41 81 e1 fe 01 00 00 	and    r9d,0x1fe
        const d6: u32 = (b1 % 100) << 1;
  22489c:	49 69 c6 1f 85 eb 51 	imul   rax,r14,0x51eb851f
  2248a3:	48 c1 e8 25          	shr    rax,0x25
  2248a7:	6b c0 64             	imul   eax,eax,0x64
  2248aa:	41 29 c6             	sub    r14d,eax
  2248ad:	4d 01 f6             	add    r14,r14
        const d7: u32 = (c1 / 100) << 1;
  2248b0:	4d 69 d0 1f 85 eb 51 	imul   r10,r8,0x51eb851f
  2248b7:	49 c1 ea 25          	shr    r10,0x25
        const d8: u32 = (c1 % 100) << 1;
  2248bb:	41 6b c2 64          	imul   eax,r10d,0x64
        const d7: u32 = (c1 / 100) << 1;
  2248bf:	4d 01 d2             	add    r10,r10
        const d8: u32 = (c1 % 100) << 1;
  2248c2:	41 29 c0             	sub    r8d,eax
  2248c5:	4d 01 c0             	add    r8,r8
        if (value >= kTen15) {
  2248c8:	48 b8 00 80 c6 a4 7e 	movabs rax,0x38d7ea4c68000
  2248cf:	8d 03 00 
  2248d2:	48 39 c7             	cmp    rdi,rax
  2248d5:	0f 82 07 01 00 00    	jb     2249e2 <u64toa+0x252>
            buffer[buf_index] = c_digits_lut[d1];
  2248db:	48 8b 06             	mov    rax,QWORD PTR [rsi]
  2248de:	48 8d 15 23 14 fe ff 	lea    rdx,[rip+0xfffffffffffe1423]        # 205d08 <c_digits_lut>
  2248e5:	8a 14 11             	mov    dl,BYTE PTR [rcx+rdx*1]
  2248e8:	88 10                	mov    BYTE PTR [rax],dl
  2248ea:	b8 01 00 00 00       	mov    eax,0x1
  2248ef:	e9 03 01 00 00       	jmp    2249f7 <u64toa+0x267>
            const b: u32 = v / 10000;
  2248f4:	ba 59 17 b7 d1       	mov    edx,0xd1b71759
  2248f9:	48 0f af d0          	imul   rdx,rax
  2248fd:	48 c1 ea 2d          	shr    rdx,0x2d
            const c: u32 = v % 10000;
  224901:	69 da 10 27 00 00    	imul   ebx,edx,0x2710
  224907:	89 f9                	mov    ecx,edi
  224909:	29 d9                	sub    ecx,ebx
            const d1: u32 = (b / 100) << 1;
  22490b:	48 69 d8 83 de 1b 43 	imul   rbx,rax,0x431bde83
  224912:	48 c1 eb 31          	shr    rbx,0x31
            const d2: u32 = (b % 100) << 1;
  224916:	48 69 c2 1f 85 eb 51 	imul   rax,rdx,0x51eb851f
  22491d:	48 c1 e8 25          	shr    rax,0x25
  224921:	6b c0 64             	imul   eax,eax,0x64
            const d1: u32 = (b / 100) << 1;
  224924:	81 e3 fe 3f 00 00    	and    ebx,0x3ffe
            const d2: u32 = (b % 100) << 1;
  22492a:	29 c2                	sub    edx,eax
  22492c:	48 01 d2             	add    rdx,rdx
            const d3: u32 = (c / 100) << 1;
  22492f:	4c 69 c1 1f 85 eb 51 	imul   r8,rcx,0x51eb851f
  224936:	49 c1 e8 25          	shr    r8,0x25
            const d4: u32 = (c % 100) << 1;
  22493a:	41 6b c0 64          	imul   eax,r8d,0x64
            const d3: u32 = (c / 100) << 1;
  22493e:	4d 01 c0             	add    r8,r8
            const d4: u32 = (c % 100) << 1;
  224941:	29 c1                	sub    ecx,eax
  224943:	48 01 c9             	add    rcx,rcx
            if (value >= 10000000) {
  224946:	48 81 ff 80 96 98 00 	cmp    rdi,0x989680
  22494d:	0f 82 b0 01 00 00    	jb     224b03 <u64toa+0x373>
                buffer[buf_index] = c_digits_lut[d1];
  224953:	4c 8b 0e             	mov    r9,QWORD PTR [rsi]
  224956:	48 8d 3d ab 13 fe ff 	lea    rdi,[rip+0xfffffffffffe13ab]        # 205d08 <c_digits_lut>
  22495d:	8a 04 3b             	mov    al,BYTE PTR [rbx+rdi*1]
  224960:	41 88 01             	mov    BYTE PTR [r9],al
  224963:	b8 01 00 00 00       	mov    eax,0x1
  224968:	e9 a5 01 00 00       	jmp    224b12 <u64toa+0x382>
        value %= kTen16;
  22496d:	31 d2                	xor    edx,edx
  22496f:	48 89 f8             	mov    rax,rdi
  224972:	48 f7 f1             	div    rcx
        if (a < 10) {
  224975:	83 f8 09             	cmp    eax,0x9
  224978:	0f 87 0e 02 00 00    	ja     224b8c <u64toa+0x3fc>
            buffer[buf_index] = '0' + @intCast(u8, a);
  22497e:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  224981:	04 30                	add    al,0x30
  224983:	88 01                	mov    BYTE PTR [rcx],al
  224985:	b8 01 00 00 00       	mov    eax,0x1
  22498a:	e9 06 03 00 00       	jmp    224c95 <u64toa+0x505>
  22498f:	31 c0                	xor    eax,eax
            if (v >= 100) {
  224991:	83 ff 64             	cmp    edi,0x64
  224994:	0f 82 21 02 00 00    	jb     224bbb <u64toa+0x42b>
                buffer[buf_index] = c_digits_lut[d1 + 1];
  22499a:	48 8b 3e             	mov    rdi,QWORD PTR [rsi]
  22499d:	83 ca 01             	or     edx,0x1
  2249a0:	48 8d 1d 61 13 fe ff 	lea    rbx,[rip+0xfffffffffffe1361]        # 205d08 <c_digits_lut>
  2249a7:	8a 14 1a             	mov    dl,BYTE PTR [rdx+rbx*1]
  2249aa:	88 14 07             	mov    BYTE PTR [rdi+rax*1],dl
                buf_index += 1;
  2249ad:	48 83 c0 01          	add    rax,0x1
                buffer[buf_index] = c_digits_lut[d2];
  2249b1:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  2249b4:	48 8d 3d 4d 13 fe ff 	lea    rdi,[rip+0xfffffffffffe134d]        # 205d08 <c_digits_lut>
  2249bb:	8a 1c 39             	mov    bl,BYTE PTR [rcx+rdi*1]
  2249be:	88 1c 02             	mov    BYTE PTR [rdx+rax*1],bl
                buf_index += 1;
  2249c1:	48 83 c0 01          	add    rax,0x1
            buffer[buf_index] = c_digits_lut[d2 + 1];
  2249c5:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  2249c8:	83 c9 01             	or     ecx,0x1
  2249cb:	48 8d 35 36 13 fe ff 	lea    rsi,[rip+0xfffffffffffe1336]        # 205d08 <c_digits_lut>
  2249d2:	8a 0c 31             	mov    cl,BYTE PTR [rcx+rsi*1]
  2249d5:	88 0c 02             	mov    BYTE PTR [rdx+rax*1],cl
            buf_index += 1;
  2249d8:	48 83 c0 01          	add    rax,0x1
    return buf_index;
  2249dc:	5b                   	pop    rbx
  2249dd:	41 5e                	pop    r14
  2249df:	41 5f                	pop    r15
  2249e1:	c3                   	ret    
        if (value >= kTen14) {
  2249e2:	48 b8 00 40 7a 10 f3 	movabs rax,0x5af3107a4000
  2249e9:	5a 00 00 
  2249ec:	48 39 c7             	cmp    rdi,rax
  2249ef:	0f 82 d4 01 00 00    	jb     224bc9 <u64toa+0x439>
  2249f5:	31 c0                	xor    eax,eax
            buffer[buf_index] = c_digits_lut[d1 + 1];
  2249f7:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  2249fa:	83 c9 01             	or     ecx,0x1
  2249fd:	48 8d 3d 04 13 fe ff 	lea    rdi,[rip+0xfffffffffffe1304]        # 205d08 <c_digits_lut>
  224a04:	8a 0c 39             	mov    cl,BYTE PTR [rcx+rdi*1]
  224a07:	88 0c 02             	mov    BYTE PTR [rdx+rax*1],cl
            buf_index += 1;
  224a0a:	48 83 c0 01          	add    rax,0x1
            buffer[buf_index] = c_digits_lut[d2];
  224a0e:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  224a11:	48 8d 15 f0 12 fe ff 	lea    rdx,[rip+0xfffffffffffe12f0]        # 205d08 <c_digits_lut>
  224a18:	8a 14 13             	mov    dl,BYTE PTR [rbx+rdx*1]
  224a1b:	88 14 01             	mov    BYTE PTR [rcx+rax*1],dl
            buf_index += 1;
  224a1e:	48 83 c0 01          	add    rax,0x1
            buffer[buf_index] = c_digits_lut[d2 + 1];
  224a22:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  224a25:	83 cb 01             	or     ebx,0x1
  224a28:	48 8d 15 d9 12 fe ff 	lea    rdx,[rip+0xfffffffffffe12d9]        # 205d08 <c_digits_lut>
  224a2f:	8a 14 13             	mov    dl,BYTE PTR [rbx+rdx*1]
  224a32:	88 14 01             	mov    BYTE PTR [rcx+rax*1],dl
            buf_index += 1;
  224a35:	48 83 c0 01          	add    rax,0x1
            buffer[buf_index] = c_digits_lut[d3];
  224a39:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  224a3c:	48 8d 15 c5 12 fe ff 	lea    rdx,[rip+0xfffffffffffe12c5]        # 205d08 <c_digits_lut>
  224a43:	41 8a 14 13          	mov    dl,BYTE PTR [r11+rdx*1]
  224a47:	88 14 01             	mov    BYTE PTR [rcx+rax*1],dl
            buf_index += 1;
  224a4a:	48 83 c0 01          	add    rax,0x1
            buffer[buf_index] = c_digits_lut[d3 + 1];
  224a4e:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  224a51:	41 83 cb 01          	or     r11d,0x1
  224a55:	48 8d 15 ac 12 fe ff 	lea    rdx,[rip+0xfffffffffffe12ac]        # 205d08 <c_digits_lut>
  224a5c:	41 8a 14 13          	mov    dl,BYTE PTR [r11+rdx*1]
  224a60:	88 14 01             	mov    BYTE PTR [rcx+rax*1],dl
            buf_index += 1;
  224a63:	48 83 c0 01          	add    rax,0x1
            buffer[buf_index] = c_digits_lut[d4];
  224a67:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  224a6a:	48 8d 15 97 12 fe ff 	lea    rdx,[rip+0xfffffffffffe1297]        # 205d08 <c_digits_lut>
  224a71:	41 8a 14 17          	mov    dl,BYTE PTR [r15+rdx*1]
  224a75:	88 14 01             	mov    BYTE PTR [rcx+rax*1],dl
            buf_index += 1;
  224a78:	48 83 c0 01          	add    rax,0x1
            buffer[buf_index] = c_digits_lut[d4 + 1];
  224a7c:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  224a7f:	41 83 cf 01          	or     r15d,0x1
  224a83:	48 8d 0d 7e 12 fe ff 	lea    rcx,[rip+0xfffffffffffe127e]        # 205d08 <c_digits_lut>
  224a8a:	41 8a 1c 0f          	mov    bl,BYTE PTR [r15+rcx*1]
  224a8e:	88 1c 02             	mov    BYTE PTR [rdx+rax*1],bl
        buffer[buf_index] = c_digits_lut[d5];
  224a91:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  224a94:	41 8a 1c 09          	mov    bl,BYTE PTR [r9+rcx*1]
  224a98:	88 5c 02 01          	mov    BYTE PTR [rdx+rax*1+0x1],bl
        buffer[buf_index] = c_digits_lut[d5 + 1];
  224a9c:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  224a9f:	41 83 c9 01          	or     r9d,0x1
  224aa3:	41 8a 1c 09          	mov    bl,BYTE PTR [r9+rcx*1]
  224aa7:	88 5c 02 02          	mov    BYTE PTR [rdx+rax*1+0x2],bl
        buffer[buf_index] = c_digits_lut[d6];
  224aab:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  224aae:	41 8a 1c 0e          	mov    bl,BYTE PTR [r14+rcx*1]
  224ab2:	88 5c 02 03          	mov    BYTE PTR [rdx+rax*1+0x3],bl
        buffer[buf_index] = c_digits_lut[d6 + 1];
  224ab6:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  224ab9:	41 83 ce 01          	or     r14d,0x1
  224abd:	41 8a 1c 0e          	mov    bl,BYTE PTR [r14+rcx*1]
  224ac1:	88 5c 02 04          	mov    BYTE PTR [rdx+rax*1+0x4],bl
        buffer[buf_index] = c_digits_lut[d7];
  224ac5:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  224ac8:	41 8a 1c 0a          	mov    bl,BYTE PTR [r10+rcx*1]
  224acc:	88 5c 02 05          	mov    BYTE PTR [rdx+rax*1+0x5],bl
        buffer[buf_index] = c_digits_lut[d7 + 1];
  224ad0:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  224ad3:	41 83 ca 01          	or     r10d,0x1
  224ad7:	41 8a 1c 0a          	mov    bl,BYTE PTR [r10+rcx*1]
  224adb:	88 5c 02 06          	mov    BYTE PTR [rdx+rax*1+0x6],bl
        buffer[buf_index] = c_digits_lut[d8];
  224adf:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  224ae2:	41 8a 1c 08          	mov    bl,BYTE PTR [r8+rcx*1]
  224ae6:	88 5c 02 07          	mov    BYTE PTR [rdx+rax*1+0x7],bl
        buffer[buf_index] = c_digits_lut[d8 + 1];
  224aea:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  224aed:	41 83 c8 01          	or     r8d,0x1
  224af1:	41 8a 0c 08          	mov    cl,BYTE PTR [r8+rcx*1]
  224af5:	88 4c 02 08          	mov    BYTE PTR [rdx+rax*1+0x8],cl
        buf_index += 1;
  224af9:	48 83 c0 09          	add    rax,0x9
    return buf_index;
  224afd:	5b                   	pop    rbx
  224afe:	41 5e                	pop    r14
  224b00:	41 5f                	pop    r15
  224b02:	c3                   	ret    
  224b03:	31 c0                	xor    eax,eax
            if (value >= 1000000) {
  224b05:	48 81 ff 40 42 0f 00 	cmp    rdi,0xf4240
  224b0c:	0f 82 cd 00 00 00    	jb     224bdf <u64toa+0x44f>
                buffer[buf_index] = c_digits_lut[d1 + 1];
  224b12:	4c 8b 0e             	mov    r9,QWORD PTR [rsi]
  224b15:	83 cb 01             	or     ebx,0x1
  224b18:	48 8d 3d e9 11 fe ff 	lea    rdi,[rip+0xfffffffffffe11e9]        # 205d08 <c_digits_lut>
  224b1f:	8a 1c 3b             	mov    bl,BYTE PTR [rbx+rdi*1]
  224b22:	41 88 1c 01          	mov    BYTE PTR [r9+rax*1],bl
                buf_index += 1;
  224b26:	48 83 c0 01          	add    rax,0x1
                buffer[buf_index] = c_digits_lut[d2];
  224b2a:	48 8b 3e             	mov    rdi,QWORD PTR [rsi]
  224b2d:	48 8d 1d d4 11 fe ff 	lea    rbx,[rip+0xfffffffffffe11d4]        # 205d08 <c_digits_lut>
  224b34:	8a 1c 1a             	mov    bl,BYTE PTR [rdx+rbx*1]
  224b37:	88 1c 07             	mov    BYTE PTR [rdi+rax*1],bl
                buf_index += 1;
  224b3a:	48 83 c0 01          	add    rax,0x1
            buffer[buf_index] = c_digits_lut[d2 + 1];
  224b3e:	48 8b 1e             	mov    rbx,QWORD PTR [rsi]
  224b41:	83 ca 01             	or     edx,0x1
  224b44:	48 8d 3d bd 11 fe ff 	lea    rdi,[rip+0xfffffffffffe11bd]        # 205d08 <c_digits_lut>
  224b4b:	8a 14 3a             	mov    dl,BYTE PTR [rdx+rdi*1]
  224b4e:	88 14 03             	mov    BYTE PTR [rbx+rax*1],dl
            buffer[buf_index] = c_digits_lut[d3];
  224b51:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  224b54:	41 8a 1c 38          	mov    bl,BYTE PTR [r8+rdi*1]
  224b58:	88 5c 02 01          	mov    BYTE PTR [rdx+rax*1+0x1],bl
            buffer[buf_index] = c_digits_lut[d3 + 1];
  224b5c:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  224b5f:	41 83 c8 01          	or     r8d,0x1
  224b63:	41 8a 1c 38          	mov    bl,BYTE PTR [r8+rdi*1]
  224b67:	88 5c 02 02          	mov    BYTE PTR [rdx+rax*1+0x2],bl
            buffer[buf_index] = c_digits_lut[d4];
  224b6b:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  224b6e:	8a 1c 39             	mov    bl,BYTE PTR [rcx+rdi*1]
  224b71:	88 5c 02 03          	mov    BYTE PTR [rdx+rax*1+0x3],bl
            buffer[buf_index] = c_digits_lut[d4 + 1];
  224b75:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  224b78:	83 c9 01             	or     ecx,0x1
  224b7b:	8a 0c 39             	mov    cl,BYTE PTR [rcx+rdi*1]
  224b7e:	88 4c 02 04          	mov    BYTE PTR [rdx+rax*1+0x4],cl
            buf_index += 1;
  224b82:	48 83 c0 05          	add    rax,0x5
    return buf_index;
  224b86:	5b                   	pop    rbx
  224b87:	41 5e                	pop    r14
  224b89:	41 5f                	pop    r15
  224b8b:	c3                   	ret    
        } else if (a < 100) {
  224b8c:	83 f8 63             	cmp    eax,0x63
  224b8f:	77 60                	ja     224bf1 <u64toa+0x461>
            buffer[buf_index] = c_digits_lut[i];
  224b91:	89 c0                	mov    eax,eax
  224b93:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  224b96:	48 8d 3d 6b 11 fe ff 	lea    rdi,[rip+0xfffffffffffe116b]        # 205d08 <c_digits_lut>
  224b9d:	8a 1c 47             	mov    bl,BYTE PTR [rdi+rax*2]
            const i: u32 = a << 1;
  224ba0:	48 01 c0             	add    rax,rax
            buffer[buf_index] = c_digits_lut[i];
  224ba3:	88 19                	mov    BYTE PTR [rcx],bl
            buffer[buf_index] = c_digits_lut[i + 1];
  224ba5:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  224ba8:	83 c8 01             	or     eax,0x1
  224bab:	8a 04 38             	mov    al,BYTE PTR [rax+rdi*1]
  224bae:	88 41 01             	mov    BYTE PTR [rcx+0x1],al
  224bb1:	b8 02 00 00 00       	mov    eax,0x2
  224bb6:	e9 da 00 00 00       	jmp    224c95 <u64toa+0x505>
            if (v >= 10) {
  224bbb:	83 ff 0a             	cmp    edi,0xa
  224bbe:	0f 83 ed fd ff ff    	jae    2249b1 <u64toa+0x221>
  224bc4:	e9 fc fd ff ff       	jmp    2249c5 <u64toa+0x235>
        if (value >= kTen13) {
  224bc9:	48 89 f8             	mov    rax,rdi
  224bcc:	48 c1 e8 0d          	shr    rax,0xd
  224bd0:	48 3d 95 73 c2 48    	cmp    rax,0x48c27395
  224bd6:	72 60                	jb     224c38 <u64toa+0x4a8>
  224bd8:	31 c0                	xor    eax,eax
  224bda:	e9 2f fe ff ff       	jmp    224a0e <u64toa+0x27e>
            if (value >= 100000) {
  224bdf:	48 81 ff a0 86 01 00 	cmp    rdi,0x186a0
  224be6:	0f 83 3e ff ff ff    	jae    224b2a <u64toa+0x39a>
  224bec:	e9 4d ff ff ff       	jmp    224b3e <u64toa+0x3ae>
            const i: u32 = (a / 100) << 1;
  224bf1:	89 c1                	mov    ecx,eax
  224bf3:	48 69 c9 1f 85 eb 51 	imul   rcx,rcx,0x51eb851f
  224bfa:	48 c1 e9 25          	shr    rcx,0x25
            const j: u32 = (a % 100) << 1;
  224bfe:	6b f9 64             	imul   edi,ecx,0x64
        } else if (a < 1000) {
  224c01:	3d e7 03 00 00       	cmp    eax,0x3e7
  224c06:	77 4a                	ja     224c52 <u64toa+0x4c2>
            buffer[buf_index] = '0' + @intCast(u8, a / 100);
  224c08:	48 8b 1e             	mov    rbx,QWORD PTR [rsi]
  224c0b:	80 c1 30             	add    cl,0x30
  224c0e:	88 0b                	mov    BYTE PTR [rbx],cl
            const i: u32 = (a % 100) << 1;
  224c10:	29 f8                	sub    eax,edi
            buffer[buf_index] = c_digits_lut[i];
  224c12:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  224c15:	48 8d 3d ec 10 fe ff 	lea    rdi,[rip+0xfffffffffffe10ec]        # 205d08 <c_digits_lut>
  224c1c:	8a 1c 47             	mov    bl,BYTE PTR [rdi+rax*2]
            const i: u32 = (a % 100) << 1;
  224c1f:	48 01 c0             	add    rax,rax
            buffer[buf_index] = c_digits_lut[i];
  224c22:	88 59 01             	mov    BYTE PTR [rcx+0x1],bl
            buffer[buf_index] = c_digits_lut[i + 1];
  224c25:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  224c28:	83 c8 01             	or     eax,0x1
  224c2b:	8a 04 38             	mov    al,BYTE PTR [rax+rdi*1]
  224c2e:	88 41 02             	mov    BYTE PTR [rcx+0x2],al
  224c31:	b8 03 00 00 00       	mov    eax,0x3
  224c36:	eb 5d                	jmp    224c95 <u64toa+0x505>
        if (value >= kTen12) {
  224c38:	48 89 f8             	mov    rax,rdi
  224c3b:	48 c1 e8 0c          	shr    rax,0xc
  224c3f:	48 3d 51 4a 8d 0e    	cmp    rax,0xe8d4a51
  224c45:	0f 82 e9 01 00 00    	jb     224e34 <u64toa+0x6a4>
  224c4b:	31 c0                	xor    eax,eax
  224c4d:	e9 d0 fd ff ff       	jmp    224a22 <u64toa+0x292>
            const j: u32 = (a % 100) << 1;
  224c52:	29 f8                	sub    eax,edi
  224c54:	48 8d 3c 00          	lea    rdi,[rax+rax*1]
            buffer[buf_index] = c_digits_lut[i];
  224c58:	4c 8b 0e             	mov    r9,QWORD PTR [rsi]
  224c5b:	4c 8d 05 a6 10 fe ff 	lea    r8,[rip+0xfffffffffffe10a6]        # 205d08 <c_digits_lut>
  224c62:	41 8a 1c 48          	mov    bl,BYTE PTR [r8+rcx*2]
  224c66:	41 88 19             	mov    BYTE PTR [r9],bl
            const i: u32 = (a / 100) << 1;
  224c69:	48 01 c9             	add    rcx,rcx
            buffer[buf_index] = c_digits_lut[i + 1];
  224c6c:	48 8b 1e             	mov    rbx,QWORD PTR [rsi]
  224c6f:	83 c9 01             	or     ecx,0x1
  224c72:	42 8a 0c 01          	mov    cl,BYTE PTR [rcx+r8*1]
  224c76:	88 4b 01             	mov    BYTE PTR [rbx+0x1],cl
            buffer[buf_index] = c_digits_lut[j];
  224c79:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  224c7c:	41 8a 04 40          	mov    al,BYTE PTR [r8+rax*2]
  224c80:	88 41 02             	mov    BYTE PTR [rcx+0x2],al
            buffer[buf_index] = c_digits_lut[j + 1];
  224c83:	48 8b 06             	mov    rax,QWORD PTR [rsi]
  224c86:	83 cf 01             	or     edi,0x1
  224c89:	42 8a 0c 07          	mov    cl,BYTE PTR [rdi+r8*1]
  224c8d:	88 48 03             	mov    BYTE PTR [rax+0x3],cl
  224c90:	b8 04 00 00 00       	mov    eax,0x4
        const v0 = @intCast(u32, value / kTen8);
  224c95:	48 b9 fd ce 61 84 11 	movabs rcx,0xabcc77118461cefd
  224c9c:	77 cc ab 
  224c9f:	c4 62 f3 f6 f1       	mulx   r14,rcx,rcx
  224ca4:	49 c1 ee 1a          	shr    r14,0x1a
        const v1 = @intCast(u32, value % kTen8);
  224ca8:	4d 69 c6 00 e1 f5 05 	imul   r8,r14,0x5f5e100
        const b0: u32 = v0 / 10000;
  224caf:	44 89 f3             	mov    ebx,r14d
  224cb2:	41 ba 59 17 b7 d1    	mov    r10d,0xd1b71759
        const d1: u32 = (b0 / 100) << 1;
  224cb8:	4c 69 cb 83 de 1b 43 	imul   r9,rbx,0x431bde83
        const b0: u32 = v0 / 10000;
  224cbf:	49 0f af da          	imul   rbx,r10
  224cc3:	48 c1 eb 2d          	shr    rbx,0x2d
        const d1: u32 = (b0 / 100) << 1;
  224cc7:	49 c1 e9 32          	shr    r9,0x32
        buffer[buf_index] = c_digits_lut[d1];
  224ccb:	4c 8b 1e             	mov    r11,QWORD PTR [rsi]
  224cce:	48 8d 3d 33 10 fe ff 	lea    rdi,[rip+0xfffffffffffe1033]        # 205d08 <c_digits_lut>
  224cd5:	42 8a 0c 4f          	mov    cl,BYTE PTR [rdi+r9*2]
  224cd9:	41 88 0c 03          	mov    BYTE PTR [r11+rax*1],cl
        const c0: u32 = v0 % 10000;
  224cdd:	44 69 db 10 27 00 00 	imul   r11d,ebx,0x2710
        const d2: u32 = (b0 % 100) << 1;
  224ce4:	48 69 cb 1f 85 eb 51 	imul   rcx,rbx,0x51eb851f
  224ceb:	48 c1 e9 25          	shr    rcx,0x25
  224cef:	6b c9 64             	imul   ecx,ecx,0x64
        const c0: u32 = v0 % 10000;
  224cf2:	45 29 de             	sub    r14d,r11d
        const d2: u32 = (b0 % 100) << 1;
  224cf5:	29 cb                	sub    ebx,ecx
        const d1: u32 = (b0 / 100) << 1;
  224cf7:	4b 8d 0c 09          	lea    rcx,[r9+r9*1]
        buffer[buf_index] = c_digits_lut[d1 + 1];
  224cfb:	83 c9 01             	or     ecx,0x1
  224cfe:	44 8a 0c 39          	mov    r9b,BYTE PTR [rcx+rdi*1]
  224d02:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  224d05:	44 88 4c 01 01       	mov    BYTE PTR [rcx+rax*1+0x1],r9b
        buffer[buf_index] = c_digits_lut[d2];
  224d0a:	4c 8b 0e             	mov    r9,QWORD PTR [rsi]
  224d0d:	8a 0c 5f             	mov    cl,BYTE PTR [rdi+rbx*2]
  224d10:	41 88 4c 01 02       	mov    BYTE PTR [r9+rax*1+0x2],cl
        const d2: u32 = (b0 % 100) << 1;
  224d15:	48 8d 0c 1b          	lea    rcx,[rbx+rbx*1]
        const d3: u32 = (c0 / 100) << 1;
  224d19:	49 69 de 1f 85 eb 51 	imul   rbx,r14,0x51eb851f
  224d20:	48 c1 eb 25          	shr    rbx,0x25
        buffer[buf_index] = c_digits_lut[d2 + 1];
  224d24:	83 c9 01             	or     ecx,0x1
  224d27:	44 8a 0c 39          	mov    r9b,BYTE PTR [rcx+rdi*1]
  224d2b:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  224d2e:	44 88 4c 01 03       	mov    BYTE PTR [rcx+rax*1+0x3],r9b
        buffer[buf_index] = c_digits_lut[d3];
  224d33:	4c 8b 0e             	mov    r9,QWORD PTR [rsi]
  224d36:	8a 0c 5f             	mov    cl,BYTE PTR [rdi+rbx*2]
  224d39:	41 88 4c 01 04       	mov    BYTE PTR [r9+rax*1+0x4],cl
        const d4: u32 = (c0 % 100) << 1;
  224d3e:	6b cb 64             	imul   ecx,ebx,0x64
        const v1 = @intCast(u32, value % kTen8);
  224d41:	4c 29 c2             	sub    rdx,r8
        const d3: u32 = (c0 / 100) << 1;
  224d44:	48 8d 1c 1b          	lea    rbx,[rbx+rbx*1]
        const d4: u32 = (c0 % 100) << 1;
  224d48:	41 29 ce             	sub    r14d,ecx
        buffer[buf_index] = c_digits_lut[d3 + 1];
  224d4b:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  224d4e:	83 cb 01             	or     ebx,0x1
  224d51:	8a 1c 3b             	mov    bl,BYTE PTR [rbx+rdi*1]
  224d54:	88 5c 01 05          	mov    BYTE PTR [rcx+rax*1+0x5],bl
        const d4: u32 = (c0 % 100) << 1;
  224d58:	4b 8d 0c 36          	lea    rcx,[r14+r14*1]
        const b1: u32 = v1 / 10000;
  224d5c:	4c 0f af d2          	imul   r10,rdx
  224d60:	49 c1 ea 2d          	shr    r10,0x2d
        buffer[buf_index] = c_digits_lut[d4];
  224d64:	4c 8b 06             	mov    r8,QWORD PTR [rsi]
  224d67:	42 8a 1c 77          	mov    bl,BYTE PTR [rdi+r14*2]
  224d6b:	41 88 5c 00 06       	mov    BYTE PTR [r8+rax*1+0x6],bl
        const d5: u32 = (b1 / 100) << 1;
  224d70:	48 69 da 83 de 1b 43 	imul   rbx,rdx,0x431bde83
  224d77:	48 c1 eb 31          	shr    rbx,0x31
  224d7b:	81 e3 fe 01 00 00    	and    ebx,0x1fe
        buffer[buf_index] = c_digits_lut[d4 + 1];
  224d81:	4c 8b 06             	mov    r8,QWORD PTR [rsi]
  224d84:	83 c9 01             	or     ecx,0x1
  224d87:	8a 0c 39             	mov    cl,BYTE PTR [rcx+rdi*1]
  224d8a:	41 88 4c 00 07       	mov    BYTE PTR [r8+rax*1+0x7],cl
        buf_index += 1;
  224d8f:	48 83 c8 08          	or     rax,0x8
        buffer[buf_index] = c_digits_lut[d5];
  224d93:	4c 8b 06             	mov    r8,QWORD PTR [rsi]
  224d96:	8a 0c 3b             	mov    cl,BYTE PTR [rbx+rdi*1]
  224d99:	41 88 0c 00          	mov    BYTE PTR [r8+rax*1],cl
        const c1: u32 = v1 % 10000;
  224d9d:	45 69 c2 10 27 00 00 	imul   r8d,r10d,0x2710
        const d6: u32 = (b1 % 100) << 1;
  224da4:	49 69 ca 1f 85 eb 51 	imul   rcx,r10,0x51eb851f
  224dab:	48 c1 e9 25          	shr    rcx,0x25
  224daf:	6b c9 64             	imul   ecx,ecx,0x64
        const c1: u32 = v1 % 10000;
  224db2:	44 29 c2             	sub    edx,r8d
        const d6: u32 = (b1 % 100) << 1;
  224db5:	41 29 ca             	sub    r10d,ecx
        buffer[buf_index] = c_digits_lut[d5 + 1];
  224db8:	8d 4b 01             	lea    ecx,[rbx+0x1]
  224dbb:	8a 0c 39             	mov    cl,BYTE PTR [rcx+rdi*1]
  224dbe:	48 8b 1e             	mov    rbx,QWORD PTR [rsi]
  224dc1:	88 4c 03 01          	mov    BYTE PTR [rbx+rax*1+0x1],cl
        buffer[buf_index] = c_digits_lut[d6];
  224dc5:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  224dc8:	42 8a 1c 57          	mov    bl,BYTE PTR [rdi+r10*2]
  224dcc:	88 5c 01 02          	mov    BYTE PTR [rcx+rax*1+0x2],bl
        const d6: u32 = (b1 % 100) << 1;
  224dd0:	4b 8d 0c 12          	lea    rcx,[r10+r10*1]
        const d7: u32 = (c1 / 100) << 1;
  224dd4:	48 69 da 1f 85 eb 51 	imul   rbx,rdx,0x51eb851f
  224ddb:	48 c1 eb 25          	shr    rbx,0x25
        buffer[buf_index] = c_digits_lut[d6 + 1];
  224ddf:	83 c9 01             	or     ecx,0x1
  224de2:	44 8a 04 39          	mov    r8b,BYTE PTR [rcx+rdi*1]
  224de6:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  224de9:	44 88 44 01 03       	mov    BYTE PTR [rcx+rax*1+0x3],r8b
        buffer[buf_index] = c_digits_lut[d7];
  224dee:	4c 8b 06             	mov    r8,QWORD PTR [rsi]
  224df1:	8a 0c 5f             	mov    cl,BYTE PTR [rdi+rbx*2]
  224df4:	41 88 4c 00 04       	mov    BYTE PTR [r8+rax*1+0x4],cl
        const d8: u32 = (c1 % 100) << 1;
  224df9:	6b cb 64             	imul   ecx,ebx,0x64
  224dfc:	29 ca                	sub    edx,ecx
        const d7: u32 = (c1 / 100) << 1;
  224dfe:	48 8d 0c 1b          	lea    rcx,[rbx+rbx*1]
        buffer[buf_index] = c_digits_lut[d7 + 1];
  224e02:	83 c9 01             	or     ecx,0x1
  224e05:	8a 0c 39             	mov    cl,BYTE PTR [rcx+rdi*1]
  224e08:	48 8b 1e             	mov    rbx,QWORD PTR [rsi]
  224e0b:	88 4c 03 05          	mov    BYTE PTR [rbx+rax*1+0x5],cl
        buffer[buf_index] = c_digits_lut[d8];
  224e0f:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  224e12:	8a 1c 57             	mov    bl,BYTE PTR [rdi+rdx*2]
  224e15:	88 5c 01 06          	mov    BYTE PTR [rcx+rax*1+0x6],bl
        const d8: u32 = (c1 % 100) << 1;
  224e19:	48 8d 0c 12          	lea    rcx,[rdx+rdx*1]
        buffer[buf_index] = c_digits_lut[d8 + 1];
  224e1d:	83 c9 01             	or     ecx,0x1
  224e20:	8a 0c 39             	mov    cl,BYTE PTR [rcx+rdi*1]
  224e23:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  224e26:	88 4c 02 07          	mov    BYTE PTR [rdx+rax*1+0x7],cl
        buf_index += 1;
  224e2a:	48 83 c0 08          	add    rax,0x8
    return buf_index;
  224e2e:	5b                   	pop    rbx
  224e2f:	41 5e                	pop    r14
  224e31:	41 5f                	pop    r15
  224e33:	c3                   	ret    
        if (value >= kTen11) {
  224e34:	48 89 f8             	mov    rax,rdi
  224e37:	48 c1 e8 0b          	shr    rax,0xb
  224e3b:	48 3d dd 0e e9 02    	cmp    rax,0x2e90edd
  224e41:	72 07                	jb     224e4a <u64toa+0x6ba>
  224e43:	31 c0                	xor    eax,eax
  224e45:	e9 ef fb ff ff       	jmp    224a39 <u64toa+0x2a9>
        if (value >= kTen10) {
  224e4a:	48 89 f8             	mov    rax,rdi
  224e4d:	48 c1 e8 0a          	shr    rax,0xa
  224e51:	48 3d f9 02 95 00    	cmp    rax,0x9502f9
  224e57:	72 07                	jb     224e60 <u64toa+0x6d0>
  224e59:	31 c0                	xor    eax,eax
  224e5b:	e9 ee fb ff ff       	jmp    224a4e <u64toa+0x2be>
  224e60:	31 c0                	xor    eax,eax
        if (value >= kTen9) {
  224e62:	48 81 ff 00 ca 9a 3b 	cmp    rdi,0x3b9aca00
  224e69:	0f 83 f8 fb ff ff    	jae    224a67 <u64toa+0x2d7>
  224e6f:	e9 08 fc ff ff       	jmp    224a7c <u64toa+0x2ec>
  224e74:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  224e7b:	00 00 00 00 00 

0000000000224e80 <frexp64>:
    y |= 0x3F000000;
    result.significand = @bitCast(f32, y);
    return result;
}

fn frexp64(x: f64) frexp64_result {
  224e80:	53                   	push   rbx
  224e81:	48 83 ec 10          	sub    rsp,0x10
  224e85:	48 89 fb             	mov    rbx,rdi
    var result: frexp64_result = undefined;

    var y = @bitCast(u64, x);
  224e88:	c4 e1 f9 7e c1       	vmovq  rcx,xmm0
    const e = @intCast(i32, y >> 52) & 0x7FF;
  224e8d:	48 89 c8             	mov    rax,rcx
  224e90:	48 c1 e8 34          	shr    rax,0x34

    if (e == 0) {
  224e94:	89 c2                	mov    edx,eax
  224e96:	81 e2 ff 07 00 00    	and    edx,0x7ff
  224e9c:	81 fa ff 07 00 00    	cmp    edx,0x7ff
  224ea2:	74 31                	je     224ed5 <frexp64+0x55>
  224ea4:	66 85 d2             	test   dx,dx
  224ea7:	75 3d                	jne    224ee6 <frexp64+0x66>
        if (x != 0) {
  224ea9:	c5 f0 57 c9          	vxorps xmm1,xmm1,xmm1
  224ead:	c5 f9 2e c1          	vucomisd xmm0,xmm1
  224eb1:	74 63                	je     224f16 <frexp64+0x96>
            // subnormal
            result = frexp64(x * 0x1.0p64);
  224eb3:	c5 fb 59 05 4d be fd 	vmulsd xmm0,xmm0,QWORD PTR [rip+0xfffffffffffdbe4d]        # 200d08 <app_mask+0x28>
  224eba:	ff 
  224ebb:	48 89 e7             	mov    rdi,rsp
  224ebe:	e8 bd ff ff ff       	call   224e80 <frexp64>
  224ec3:	c5 fb 10 04 24       	vmovsd xmm0,QWORD PTR [rsp]
  224ec8:	8b 44 24 08          	mov    eax,DWORD PTR [rsp+0x8]
  224ecc:	8b 4c 24 0c          	mov    ecx,DWORD PTR [rsp+0xc]
            result.exponent -= 64;
  224ed0:	83 c0 c0             	add    eax,0xffffffc0
  224ed3:	eb 43                	jmp    224f18 <frexp64+0x98>
        // frexp(+-inf) = (+-inf, 0)
        if (math.isInf(x)) {
            result.exponent = 0;
        }

        return result;
  224ed5:	c5 fb 11 03          	vmovsd QWORD PTR [rbx],xmm0
  224ed9:	c7 43 08 00 00 00 00 	mov    DWORD PTR [rbx+0x8],0x0
  224ee0:	48 83 c4 10          	add    rsp,0x10
  224ee4:	5b                   	pop    rbx
  224ee5:	c3                   	ret    
    const e = @intCast(i32, y >> 52) & 0x7FF;
  224ee6:	25 ff 07 00 00       	and    eax,0x7ff
    }

    result.exponent = e - 0x3FE;
  224eeb:	05 02 fc ff ff       	add    eax,0xfffffc02
    y &= 0x800FFFFFFFFFFFFF;
  224ef0:	48 ba ff ff ff ff ff 	movabs rdx,0x800fffffffffffff
  224ef7:	ff 0f 80 
  224efa:	48 21 d1             	and    rcx,rdx
    y |= 0x3FE0000000000000;
  224efd:	48 ba 00 00 00 00 00 	movabs rdx,0x3fe0000000000000
  224f04:	00 e0 3f 
  224f07:	48 09 ca             	or     rdx,rcx
    result.significand = @bitCast(f64, y);
    return result;
  224f0a:	48 89 13             	mov    QWORD PTR [rbx],rdx
  224f0d:	89 43 08             	mov    DWORD PTR [rbx+0x8],eax
  224f10:	48 83 c4 10          	add    rsp,0x10
  224f14:	5b                   	pop    rbx
  224f15:	c3                   	ret    
  224f16:	31 c0                	xor    eax,eax
        return result;
  224f18:	c5 fb 11 03          	vmovsd QWORD PTR [rbx],xmm0
  224f1c:	89 43 08             	mov    DWORD PTR [rbx+0x8],eax
  224f1f:	89 4b 0c             	mov    DWORD PTR [rbx+0xc],ecx
  224f22:	48 83 c4 10          	add    rsp,0x10
  224f26:	5b                   	pop    rbx
  224f27:	c3                   	ret    
  224f28:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  224f2f:	00 

0000000000224f30 <_start>:
}

nakedcc fn _start() noreturn {
    switch (builtin.arch) {
        builtin.Arch.x86_64 => {
            argc_ptr = asm ("lea (%%rsp), %[argc]"
  224f30:	48 8d 04 24          	lea    rax,[rsp]
  224f34:	48 89 05 85 d1 01 00 	mov    QWORD PTR [rip+0x1d185],rax        # 2420c0 <argc_ptr>
        },
        else => @compileError("unsupported arch"),
    }
    // If LLVM inlines stack variables into _start, they will overwrite
    // the command line argument data.
    @noInlineCall(posixCallMainAndExit);
  224f3b:	e8 00 00 00 00       	call   224f40 <posixCallMainAndExit>

0000000000224f40 <posixCallMainAndExit>:
    std.os.windows.ExitProcess(callMain());
}

// TODO https://github.com/ziglang/zig/issues/265
fn posixCallMainAndExit() noreturn {
    const argc = argc_ptr[0];
  224f40:	41 56                	push   r14
  224f42:	53                   	push   rbx
  224f43:	48 83 ec 18          	sub    rsp,0x18
  224f47:	48 8b 15 72 d1 01 00 	mov    rdx,QWORD PTR [rip+0x1d172]        # 2420c0 <argc_ptr>
  224f4e:	48 8b 1a             	mov    rbx,QWORD PTR [rdx]
    const argv = @ptrCast([*][*]u8, argc_ptr + 1);

    const envp_optional = @ptrCast([*]?[*]u8, argv + argc + 1);
  224f51:	48 8d 0c da          	lea    rcx,[rdx+rbx*8]
  224f55:	48 83 c1 10          	add    rcx,0x10
    var envp_count: usize = 0;
    while (envp_optional[envp_count]) |_| : (envp_count += 1) {}
  224f59:	48 8d 04 da          	lea    rax,[rdx+rbx*8]
  224f5d:	48 83 c0 20          	add    rax,0x20
    const argv = @ptrCast([*][*]u8, argc_ptr + 1);
  224f61:	4c 8d 72 08          	lea    r14,[rdx+0x8]
  224f65:	48 c7 c2 ff ff ff ff 	mov    rdx,0xffffffffffffffff
  224f6c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
    while (envp_optional[envp_count]) |_| : (envp_count += 1) {}
  224f70:	48 83 c2 01          	add    rdx,0x1
  224f74:	48 83 78 f0 00       	cmp    QWORD PTR [rax-0x10],0x0
  224f79:	48 8d 40 08          	lea    rax,[rax+0x8]
  224f7d:	75 f1                	jne    224f70 <posixCallMainAndExit+0x30>
    const envp = @ptrCast([*][*]u8, envp_optional)[0..envp_count];
  224f7f:	48 89 4c 24 08       	mov    QWORD PTR [rsp+0x8],rcx
  224f84:	48 89 54 24 10       	mov    QWORD PTR [rsp+0x10],rdx
    if (builtin.os == builtin.Os.linux) {
        const auxv = @ptrCast([*]usize, envp.ptr + envp_count + 1);
        var i: usize = 0;
        while (auxv[i] != 0) : (i += 2) {
  224f89:	48 8b 48 f0          	mov    rcx,QWORD PTR [rax-0x10]
  224f8d:	48 85 c9             	test   rcx,rcx
  224f90:	74 28                	je     224fba <posixCallMainAndExit+0x7a>
  224f92:	48 8d 15 a7 10 02 00 	lea    rdx,[rip+0x210a7]        # 246040 <linux_aux_raw>
  224f99:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
            if (auxv[i] < std.os.linux_aux_raw.len) std.os.linux_aux_raw[auxv[i]] = auxv[i + 1];
  224fa0:	48 83 f9 25          	cmp    rcx,0x25
  224fa4:	77 08                	ja     224fae <posixCallMainAndExit+0x6e>
  224fa6:	48 8b 70 f8          	mov    rsi,QWORD PTR [rax-0x8]
  224faa:	48 89 34 ca          	mov    QWORD PTR [rdx+rcx*8],rsi
        while (auxv[i] != 0) : (i += 2) {
  224fae:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  224fb1:	48 83 c0 10          	add    rax,0x10
  224fb5:	48 85 c9             	test   rcx,rcx
  224fb8:	75 e6                	jne    224fa0 <posixCallMainAndExit+0x60>
        }
        std.debug.assert(std.os.linux_aux_raw[std.elf.AT_PAGESZ] == std.os.page_size);
  224fba:	31 ff                	xor    edi,edi
  224fbc:	48 81 3d a9 10 02 00 	cmp    QWORD PTR [rip+0x210a9],0x1000        # 246070 <linux_aux_raw+0x30>
  224fc3:	00 10 00 00 
  224fc7:	40 0f 94 c7          	sete   dil
  224fcb:	e8 a0 52 fe ff       	call   20a270 <assert>
  224fd0:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
    }

    std.os.posix.exit(callMainWithArgs(argc, argv, envp));
  224fd5:	48 89 df             	mov    rdi,rbx
  224fd8:	4c 89 f6             	mov    rsi,r14
  224fdb:	e8 10 00 00 00       	call   224ff0 <callMainWithArgs>
    _ = syscall1(SYS_exit, @bitCast(usize, isize(status)));
  224fe0:	0f b6 f8             	movzx  edi,al
    return asm volatile ("syscall"
  224fe3:	b8 3c 00 00 00       	mov    eax,0x3c
  224fe8:	0f 05                	syscall 
  224fea:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000224ff0 <callMainWithArgs>:
}

fn callMainWithArgs(argc: usize, argv: [*][*]u8, envp: [][*]u8) u8 {
    std.os.ArgIteratorPosix.raw = argv[0..argc];
  224ff0:	41 57                	push   r15
  224ff2:	41 56                	push   r14
  224ff4:	53                   	push   rbx
  224ff5:	48 83 ec 50          	sub    rsp,0x50
  224ff9:	48 89 35 c8 d0 01 00 	mov    QWORD PTR [rip+0x1d0c8],rsi        # 2420c8 <raw>
  225000:	48 89 3d c9 d0 01 00 	mov    QWORD PTR [rip+0x1d0c9],rdi        # 2420d0 <raw+0x8>
    std.os.posix_environ_raw = envp;
  225007:	c5 f8 10 02          	vmovups xmm0,XMMWORD PTR [rdx]
  22500b:	c5 f8 11 05 9d d0 01 	vmovups XMMWORD PTR [rip+0x1d09d],xmm0        # 2420b0 <posix_environ_raw>
  225012:	00 
  225013:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  22501a:	84 00 00 00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  225020:	b0 01                	mov    al,0x1
  225022:	86 05 e8 0f 02 00    	xchg   BYTE PTR [rip+0x20fe8],al        # 246010 <stderr_mutex>
  225028:	84 c0                	test   al,al
  22502a:	75 f4                	jne    225020 <callMainWithArgs+0x30>
    if (stderr_stream) |st| {
  22502c:	48 8b 1d d5 0f 02 00 	mov    rbx,QWORD PTR [rip+0x20fd5]        # 246008 <stderr_stream>
  225033:	48 85 db             	test   rbx,rbx
  225036:	74 09                	je     225041 <callMainWithArgs+0x51>
            return std.fmt.format(self, Error, self.writeFn, format, args);
  225038:	4c 8b 3d 01 d0 01 00 	mov    r15,QWORD PTR [rip+0x1d001]        # 242040 <stderr_file_out_stream+0x8>
  22503f:	eb 34                	jmp    225075 <callMainWithArgs+0x85>
        stderr_file = try io.getStdErr();
  225041:	48 8d 05 e8 cf 01 00 	lea    rax,[rip+0x1cfe8]        # 242030 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  225048:	48 89 05 e9 cf 01 00 	mov    QWORD PTR [rip+0x1cfe9],rax        # 242038 <stderr_file_out_stream>
  22504f:	4c 8d 3d fa 18 ff ff 	lea    r15,[rip+0xffffffffffff18fa]        # 216950 <FileOutStream_writeFn>
  225056:	4c 89 3d e3 cf 01 00 	mov    QWORD PTR [rip+0x1cfe3],r15        # 242040 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  22505d:	c7 05 c9 cf 01 00 02 	mov    DWORD PTR [rip+0x1cfc9],0x2        # 242030 <stderr_file>
  225064:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  225067:	48 8d 1d d2 cf 01 00 	lea    rbx,[rip+0x1cfd2]        # 242040 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  22506e:	48 89 1d 93 0f 02 00 	mov    QWORD PTR [rip+0x20f93],rbx        # 246008 <stderr_stream>
  225075:	4c 8d 74 24 4f       	lea    r14,[rsp+0x4f]
                        try output(context, fmt[start_index..i]);
  22507a:	48 8d 35 3f 0e 02 00 	lea    rsi,[rip+0x20e3f]        # 245ec0 <__unnamed_106>
  225081:	48 89 df             	mov    rdi,rbx
  225084:	41 ff d7             	call   r15
  225087:	66 85 c0             	test   ax,ax
  22508a:	0f 85 d1 00 00 00    	jne    225161 <callMainWithArgs+0x171>
    var buf: [max_int_digits - 1]u8 = undefined;
  225090:	c5 fc 10 05 27 44 fe 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffe4427]        # 2094bf <__unnamed_5+0x1f>
  225097:	ff 
  225098:	c5 fc 11 44 24 2f    	vmovups YMMWORD PTR [rsp+0x2f],ymm0
  22509e:	c5 fc 10 05 fa 43 fe 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffe43fa]        # 2094a0 <__unnamed_5>
  2250a5:	ff 
  2250a6:	c5 fc 11 44 24 10    	vmovups YMMWORD PTR [rsp+0x10],ymm0
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  2250ac:	c6 44 24 4f 31       	mov    BYTE PTR [rsp+0x4f],0x31
        const padded_buf = buf[index - padding ..];
  2250b1:	4c 89 34 24          	mov    QWORD PTR [rsp],r14
  2250b5:	48 c7 44 24 08 01 00 	mov    QWORD PTR [rsp+0x8],0x1
  2250bc:	00 00 
  2250be:	48 89 e6             	mov    rsi,rsp
        return output(context, padded_buf);
  2250c1:	48 89 df             	mov    rdi,rbx
  2250c4:	c5 f8 77             	vzeroupper 
  2250c7:	41 ff d7             	call   r15
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  2250ca:	66 85 c0             	test   ax,ax
  2250cd:	0f 85 8e 00 00 00    	jne    225161 <callMainWithArgs+0x171>
                        try output(context, fmt[start_index..i]);
  2250d3:	48 8d 35 f6 0d 02 00 	lea    rsi,[rip+0x20df6]        # 245ed0 <__unnamed_107>
  2250da:	48 89 df             	mov    rdi,rbx
  2250dd:	41 ff d7             	call   r15
  2250e0:	66 85 c0             	test   ax,ax
  2250e3:	75 7c                	jne    225161 <callMainWithArgs+0x171>
    var buf: [max_int_digits - 1]u8 = undefined;
  2250e5:	c5 fc 10 05 d2 43 fe 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffe43d2]        # 2094bf <__unnamed_5+0x1f>
  2250ec:	ff 
  2250ed:	c5 fc 11 44 24 2f    	vmovups YMMWORD PTR [rsp+0x2f],ymm0
  2250f3:	c5 fc 10 05 a5 43 fe 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffe43a5]        # 2094a0 <__unnamed_5>
  2250fa:	ff 
  2250fb:	c5 fc 11 44 24 10    	vmovups YMMWORD PTR [rsp+0x10],ymm0
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  225101:	c6 44 24 4f 31       	mov    BYTE PTR [rsp+0x4f],0x31
        const padded_buf = buf[index - padding ..];
  225106:	4c 89 34 24          	mov    QWORD PTR [rsp],r14
  22510a:	48 c7 44 24 08 01 00 	mov    QWORD PTR [rsp+0x8],0x1
  225111:	00 00 
  225113:	48 89 e6             	mov    rsi,rsp
        return output(context, padded_buf);
  225116:	48 89 df             	mov    rdi,rbx
  225119:	c5 f8 77             	vzeroupper 
  22511c:	41 ff d7             	call   r15
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  22511f:	66 85 c0             	test   ax,ax
  225122:	75 3d                	jne    225161 <callMainWithArgs+0x171>
                        try output(context, fmt[start_index..i]);
  225124:	48 8d 35 b5 0d 02 00 	lea    rsi,[rip+0x20db5]        # 245ee0 <__unnamed_108>
  22512b:	48 89 df             	mov    rdi,rbx
  22512e:	41 ff d7             	call   r15
  225131:	66 85 c0             	test   ax,ax
  225134:	75 2b                	jne    225161 <callMainWithArgs+0x171>
                const casted_value = ([]const u8)(value);
  225136:	c5 f8 10 05 c2 09 02 	vmovups xmm0,XMMWORD PTR [rip+0x209c2]        # 245b00 <__unnamed_109>
  22513d:	00 
  22513e:	c5 f8 29 44 24 10    	vmovaps XMMWORD PTR [rsp+0x10],xmm0
  225144:	48 8d 74 24 10       	lea    rsi,[rsp+0x10]
                return output(context, casted_value);
  225149:	48 89 df             	mov    rdi,rbx
  22514c:	41 ff d7             	call   r15
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  22514f:	66 85 c0             	test   ax,ax
  225152:	75 0d                	jne    225161 <callMainWithArgs+0x171>
        try output(context, fmt[start_index..]);
  225154:	48 8d 35 95 0d 02 00 	lea    rsi,[rip+0x20d95]        # 245ef0 <__unnamed_110>
  22515b:	48 89 df             	mov    rdi,rbx
  22515e:	41 ff d7             	call   r15
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  225161:	31 c0                	xor    eax,eax
  225163:	86 05 a7 0e 02 00    	xchg   BYTE PTR [rip+0x20ea7],al        # 246010 <stderr_mutex>
  225169:	3c 01                	cmp    al,0x1
    if (!ok) {
  22516b:	0f 85 6e 03 00 00    	jne    2254df <callMainWithArgs+0x4ef>
    var ok_count: usize = 0;
    var skip_count: usize = 0;
    for (test_fn_list) |test_fn, i| {
        warn("Test {}/{} {}...", i + 1, test_fn_list.len, test_fn.name);

        if (test_fn.func()) |_| {
  225171:	e8 ca 56 fe ff       	call   20a840 <benchmark.add>
  225176:	89 c3                	mov    ebx,eax
  225178:	66 85 db             	test   bx,bx
  22517b:	74 43                	je     2251c0 <callMainWithArgs+0x1d0>
  22517d:	0f b7 c3             	movzx  eax,bx
  225180:	83 f8 27             	cmp    eax,0x27
  225183:	75 6b                	jne    2251f0 <callMainWithArgs+0x200>
  225185:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  22518c:	00 00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  225190:	b0 01                	mov    al,0x1
  225192:	86 05 78 0e 02 00    	xchg   BYTE PTR [rip+0x20e78],al        # 246010 <stderr_mutex>
  225198:	84 c0                	test   al,al
  22519a:	75 f4                	jne    225190 <callMainWithArgs+0x1a0>
    if (stderr_stream) |st| {
  22519c:	48 8b 3d 65 0e 02 00 	mov    rdi,QWORD PTR [rip+0x20e65]        # 246008 <stderr_stream>
  2251a3:	48 85 ff             	test   rdi,rdi
  2251a6:	74 70                	je     225218 <callMainWithArgs+0x228>
  2251a8:	48 8b 0d 91 ce 01 00 	mov    rcx,QWORD PTR [rip+0x1ce91]        # 242040 <stderr_file_out_stream+0x8>
  2251af:	e9 98 00 00 00       	jmp    22524c <callMainWithArgs+0x25c>
  2251b4:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  2251bb:	00 00 00 00 00 
  2251c0:	b0 01                	mov    al,0x1
  2251c2:	86 05 48 0e 02 00    	xchg   BYTE PTR [rip+0x20e48],al        # 246010 <stderr_mutex>
  2251c8:	84 c0                	test   al,al
  2251ca:	75 f4                	jne    2251c0 <callMainWithArgs+0x1d0>
  2251cc:	48 8b 3d 35 0e 02 00 	mov    rdi,QWORD PTR [rip+0x20e35]        # 246008 <stderr_stream>
  2251d3:	48 85 ff             	test   rdi,rdi
  2251d6:	0f 84 bc 00 00 00    	je     225298 <callMainWithArgs+0x2a8>
  2251dc:	48 8b 0d 5d ce 01 00 	mov    rcx,QWORD PTR [rip+0x1ce5d]        # 242040 <stderr_file_out_stream+0x8>
  2251e3:	e9 e4 00 00 00       	jmp    2252cc <callMainWithArgs+0x2dc>
  2251e8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  2251ef:	00 
  2251f0:	b0 01                	mov    al,0x1
  2251f2:	86 05 18 0e 02 00    	xchg   BYTE PTR [rip+0x20e18],al        # 246010 <stderr_mutex>
  2251f8:	84 c0                	test   al,al
  2251fa:	75 f4                	jne    2251f0 <callMainWithArgs+0x200>
  2251fc:	4c 8b 35 05 0e 02 00 	mov    r14,QWORD PTR [rip+0x20e05]        # 246008 <stderr_stream>
  225203:	4d 85 f6             	test   r14,r14
  225206:	0f 84 41 02 00 00    	je     22544d <callMainWithArgs+0x45d>
  22520c:	4c 8b 3d 2d ce 01 00 	mov    r15,QWORD PTR [rip+0x1ce2d]        # 242040 <stderr_file_out_stream+0x8>
  225213:	e9 69 02 00 00       	jmp    225481 <callMainWithArgs+0x491>
        stderr_file = try io.getStdErr();
  225218:	48 8d 05 11 ce 01 00 	lea    rax,[rip+0x1ce11]        # 242030 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  22521f:	48 89 05 12 ce 01 00 	mov    QWORD PTR [rip+0x1ce12],rax        # 242038 <stderr_file_out_stream>
  225226:	48 8d 0d 23 17 ff ff 	lea    rcx,[rip+0xffffffffffff1723]        # 216950 <FileOutStream_writeFn>
  22522d:	48 89 0d 0c ce 01 00 	mov    QWORD PTR [rip+0x1ce0c],rcx        # 242040 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  225234:	c7 05 f2 cd 01 00 02 	mov    DWORD PTR [rip+0x1cdf2],0x2        # 242030 <stderr_file>
  22523b:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  22523e:	48 8d 3d fb cd 01 00 	lea    rdi,[rip+0x1cdfb]        # 242040 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  225245:	48 89 3d bc 0d 02 00 	mov    QWORD PTR [rip+0x20dbc],rdi        # 246008 <stderr_stream>
  22524c:	48 8d 35 bd 0c 02 00 	lea    rsi,[rip+0x20cbd]        # 245f10 <__unnamed_111>
  225253:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  225255:	31 c0                	xor    eax,eax
  225257:	86 05 b3 0d 02 00    	xchg   BYTE PTR [rip+0x20db3],al        # 246010 <stderr_mutex>
  22525d:	3c 01                	cmp    al,0x1
    if (!ok) {
  22525f:	0f 85 7a 02 00 00    	jne    2254df <callMainWithArgs+0x4ef>
  225265:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  22526c:	00 00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  225270:	b0 01                	mov    al,0x1
  225272:	86 05 98 0d 02 00    	xchg   BYTE PTR [rip+0x20d98],al        # 246010 <stderr_mutex>
  225278:	84 c0                	test   al,al
  22527a:	75 f4                	jne    225270 <callMainWithArgs+0x280>
    if (stderr_stream) |st| {
  22527c:	48 8b 1d 85 0d 02 00 	mov    rbx,QWORD PTR [rip+0x20d85]        # 246008 <stderr_stream>
  225283:	48 85 db             	test   rbx,rbx
  225286:	0f 84 8c 00 00 00    	je     225318 <callMainWithArgs+0x328>
  22528c:	4c 8b 3d ad cd 01 00 	mov    r15,QWORD PTR [rip+0x1cdad]        # 242040 <stderr_file_out_stream+0x8>
  225293:	e9 b4 00 00 00       	jmp    22534c <callMainWithArgs+0x35c>
        stderr_file = try io.getStdErr();
  225298:	48 8d 05 91 cd 01 00 	lea    rax,[rip+0x1cd91]        # 242030 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  22529f:	48 89 05 92 cd 01 00 	mov    QWORD PTR [rip+0x1cd92],rax        # 242038 <stderr_file_out_stream>
  2252a6:	48 8d 0d a3 16 ff ff 	lea    rcx,[rip+0xffffffffffff16a3]        # 216950 <FileOutStream_writeFn>
  2252ad:	48 89 0d 8c cd 01 00 	mov    QWORD PTR [rip+0x1cd8c],rcx        # 242040 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  2252b4:	c7 05 72 cd 01 00 02 	mov    DWORD PTR [rip+0x1cd72],0x2        # 242030 <stderr_file>
  2252bb:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  2252be:	48 8d 3d 7b cd 01 00 	lea    rdi,[rip+0x1cd7b]        # 242040 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  2252c5:	48 89 3d 3c 0d 02 00 	mov    QWORD PTR [rip+0x20d3c],rdi        # 246008 <stderr_stream>
  2252cc:	48 8d 35 2d 0c 02 00 	lea    rsi,[rip+0x20c2d]        # 245f00 <__unnamed_112>
  2252d3:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  2252d5:	31 c0                	xor    eax,eax
  2252d7:	86 05 33 0d 02 00    	xchg   BYTE PTR [rip+0x20d33],al        # 246010 <stderr_mutex>
  2252dd:	3c 01                	cmp    al,0x1
    if (!ok) {
  2252df:	0f 85 fa 01 00 00    	jne    2254df <callMainWithArgs+0x4ef>
  2252e5:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  2252ec:	00 00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  2252f0:	b0 01                	mov    al,0x1
  2252f2:	86 05 18 0d 02 00    	xchg   BYTE PTR [rip+0x20d18],al        # 246010 <stderr_mutex>
  2252f8:	84 c0                	test   al,al
  2252fa:	75 f4                	jne    2252f0 <callMainWithArgs+0x300>
    if (stderr_stream) |st| {
  2252fc:	48 8b 3d 05 0d 02 00 	mov    rdi,QWORD PTR [rip+0x20d05]        # 246008 <stderr_stream>
  225303:	48 85 ff             	test   rdi,rdi
  225306:	0f 84 e7 00 00 00    	je     2253f3 <callMainWithArgs+0x403>
  22530c:	48 8b 0d 2d cd 01 00 	mov    rcx,QWORD PTR [rip+0x1cd2d]        # 242040 <stderr_file_out_stream+0x8>
  225313:	e9 0f 01 00 00       	jmp    225427 <callMainWithArgs+0x437>
        stderr_file = try io.getStdErr();
  225318:	48 8d 05 11 cd 01 00 	lea    rax,[rip+0x1cd11]        # 242030 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  22531f:	48 89 05 12 cd 01 00 	mov    QWORD PTR [rip+0x1cd12],rax        # 242038 <stderr_file_out_stream>
  225326:	4c 8d 3d 23 16 ff ff 	lea    r15,[rip+0xffffffffffff1623]        # 216950 <FileOutStream_writeFn>
  22532d:	4c 89 3d 0c cd 01 00 	mov    QWORD PTR [rip+0x1cd0c],r15        # 242040 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  225334:	c7 05 f2 cc 01 00 02 	mov    DWORD PTR [rip+0x1ccf2],0x2        # 242030 <stderr_file>
  22533b:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  22533e:	48 8d 1d fb cc 01 00 	lea    rbx,[rip+0x1ccfb]        # 242040 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  225345:	48 89 1d bc 0c 02 00 	mov    QWORD PTR [rip+0x20cbc],rbx        # 246008 <stderr_stream>
    var buf: [max_int_digits - 1]u8 = undefined;
  22534c:	c5 fc 10 05 6b 41 fe 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffe416b]        # 2094bf <__unnamed_5+0x1f>
  225353:	ff 
  225354:	c5 fc 11 44 24 2f    	vmovups YMMWORD PTR [rsp+0x2f],ymm0
  22535a:	c5 fc 10 05 3e 41 fe 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffe413e]        # 2094a0 <__unnamed_5>
  225361:	ff 
  225362:	c5 fc 11 44 24 10    	vmovups YMMWORD PTR [rsp+0x10],ymm0
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  225368:	c6 44 24 4f 30       	mov    BYTE PTR [rsp+0x4f],0x30
        const padded_buf = buf[index - padding ..];
  22536d:	4c 89 34 24          	mov    QWORD PTR [rsp],r14
  225371:	48 c7 44 24 08 01 00 	mov    QWORD PTR [rsp+0x8],0x1
  225378:	00 00 
  22537a:	48 89 e6             	mov    rsi,rsp
        return output(context, padded_buf);
  22537d:	48 89 df             	mov    rdi,rbx
  225380:	c5 f8 77             	vzeroupper 
  225383:	41 ff d7             	call   r15
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  225386:	66 85 c0             	test   ax,ax
  225389:	0f 85 a1 00 00 00    	jne    225430 <callMainWithArgs+0x440>
                        try output(context, fmt[start_index..i]);
  22538f:	48 8d 35 9a 0b 02 00 	lea    rsi,[rip+0x20b9a]        # 245f30 <__unnamed_113>
  225396:	48 89 df             	mov    rdi,rbx
  225399:	41 ff d7             	call   r15
  22539c:	66 85 c0             	test   ax,ax
  22539f:	0f 85 8b 00 00 00    	jne    225430 <callMainWithArgs+0x440>
    var buf: [max_int_digits - 1]u8 = undefined;
  2253a5:	c5 fc 10 05 12 41 fe 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffe4112]        # 2094bf <__unnamed_5+0x1f>
  2253ac:	ff 
  2253ad:	c5 fc 11 44 24 2f    	vmovups YMMWORD PTR [rsp+0x2f],ymm0
  2253b3:	c5 fc 10 05 e5 40 fe 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffe40e5]        # 2094a0 <__unnamed_5>
  2253ba:	ff 
  2253bb:	c5 fc 11 44 24 10    	vmovups YMMWORD PTR [rsp+0x10],ymm0
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  2253c1:	c6 44 24 4f 31       	mov    BYTE PTR [rsp+0x4f],0x31
        const padded_buf = buf[index - padding ..];
  2253c6:	4c 89 34 24          	mov    QWORD PTR [rsp],r14
  2253ca:	48 c7 44 24 08 01 00 	mov    QWORD PTR [rsp+0x8],0x1
  2253d1:	00 00 
  2253d3:	48 89 e6             	mov    rsi,rsp
        return output(context, padded_buf);
  2253d6:	48 89 df             	mov    rdi,rbx
  2253d9:	c5 f8 77             	vzeroupper 
  2253dc:	41 ff d7             	call   r15
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  2253df:	66 85 c0             	test   ax,ax
  2253e2:	75 4c                	jne    225430 <callMainWithArgs+0x440>
        try output(context, fmt[start_index..]);
  2253e4:	48 8d 35 55 0b 02 00 	lea    rsi,[rip+0x20b55]        # 245f40 <__unnamed_114>
  2253eb:	48 89 df             	mov    rdi,rbx
  2253ee:	41 ff d7             	call   r15
  2253f1:	eb 3d                	jmp    225430 <callMainWithArgs+0x440>
        stderr_file = try io.getStdErr();
  2253f3:	48 8d 05 36 cc 01 00 	lea    rax,[rip+0x1cc36]        # 242030 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  2253fa:	48 89 05 37 cc 01 00 	mov    QWORD PTR [rip+0x1cc37],rax        # 242038 <stderr_file_out_stream>
  225401:	48 8d 0d 48 15 ff ff 	lea    rcx,[rip+0xffffffffffff1548]        # 216950 <FileOutStream_writeFn>
  225408:	48 89 0d 31 cc 01 00 	mov    QWORD PTR [rip+0x1cc31],rcx        # 242040 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  22540f:	c7 05 17 cc 01 00 02 	mov    DWORD PTR [rip+0x1cc17],0x2        # 242030 <stderr_file>
  225416:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  225419:	48 8d 3d 20 cc 01 00 	lea    rdi,[rip+0x1cc20]        # 242040 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  225420:	48 89 3d e1 0b 02 00 	mov    QWORD PTR [rip+0x20be1],rdi        # 246008 <stderr_stream>
  225427:	48 8d 35 f2 0a 02 00 	lea    rsi,[rip+0x20af2]        # 245f20 <__unnamed_115>
  22542e:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  225430:	31 c9                	xor    ecx,ecx
  225432:	86 0d d8 0b 02 00    	xchg   BYTE PTR [rip+0x20bd8],cl        # 246010 <stderr_mutex>
  225438:	31 c0                	xor    eax,eax
  22543a:	80 f9 01             	cmp    cl,0x1
    if (!ok) {
  22543d:	0f 85 9c 00 00 00    	jne    2254df <callMainWithArgs+0x4ef>
    return callMain();
  225443:	48 83 c4 50          	add    rsp,0x50
  225447:	5b                   	pop    rbx
  225448:	41 5e                	pop    r14
  22544a:	41 5f                	pop    r15
  22544c:	c3                   	ret    
        stderr_file = try io.getStdErr();
  22544d:	48 8d 05 dc cb 01 00 	lea    rax,[rip+0x1cbdc]        # 242030 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  225454:	48 89 05 dd cb 01 00 	mov    QWORD PTR [rip+0x1cbdd],rax        # 242038 <stderr_file_out_stream>
  22545b:	4c 8d 3d ee 14 ff ff 	lea    r15,[rip+0xffffffffffff14ee]        # 216950 <FileOutStream_writeFn>
  225462:	4c 89 3d d7 cb 01 00 	mov    QWORD PTR [rip+0x1cbd7],r15        # 242040 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  225469:	c7 05 bd cb 01 00 02 	mov    DWORD PTR [rip+0x1cbbd],0x2        # 242030 <stderr_file>
  225470:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  225473:	4c 8d 35 c6 cb 01 00 	lea    r14,[rip+0x1cbc6]        # 242040 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  22547a:	4c 89 35 87 0b 02 00 	mov    QWORD PTR [rip+0x20b87],r14        # 246008 <stderr_stream>
                        try output(context, fmt[start_index..i]);
  225481:	48 8d 35 c8 0a 02 00 	lea    rsi,[rip+0x20ac8]        # 245f50 <__unnamed_116>
  225488:	4c 89 f7             	mov    rdi,r14
  22548b:	41 ff d7             	call   r15
  22548e:	66 85 c0             	test   ax,ax
  225491:	75 39                	jne    2254cc <callMainWithArgs+0x4dc>
  225493:	48 0f bf c3          	movsx  rax,bx
  225497:	48 c1 e0 04          	shl    rax,0x4
  22549b:	48 8d 0d 5e db 01 00 	lea    rcx,[rip+0x1db5e]        # 243000 <raw+0xf38>
  2254a2:	48 01 c1             	add    rcx,rax
                const casted_value = ([]const u8)(value);
  2254a5:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  2254a9:	c5 f8 29 44 24 10    	vmovaps XMMWORD PTR [rsp+0x10],xmm0
  2254af:	48 8d 74 24 10       	lea    rsi,[rsp+0x10]
                return output(context, casted_value);
  2254b4:	4c 89 f7             	mov    rdi,r14
  2254b7:	41 ff d7             	call   r15
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  2254ba:	66 85 c0             	test   ax,ax
  2254bd:	75 0d                	jne    2254cc <callMainWithArgs+0x4dc>
        try output(context, fmt[start_index..]);
  2254bf:	48 8d 35 9a 0a 02 00 	lea    rsi,[rip+0x20a9a]        # 245f60 <__unnamed_117>
  2254c6:	4c 89 f7             	mov    rdi,r14
  2254c9:	41 ff d7             	call   r15
  2254cc:	31 c9                	xor    ecx,ecx
  2254ce:	86 0d 3c 0b 02 00    	xchg   BYTE PTR [rip+0x20b3c],cl        # 246010 <stderr_mutex>
  2254d4:	b0 01                	mov    al,0x1
  2254d6:	80 f9 01             	cmp    cl,0x1
    if (!ok) {
  2254d9:	0f 84 64 ff ff ff    	je     225443 <callMainWithArgs+0x453>
            @panic("assertion failure");
  2254df:	e8 fc f0 fe ff       	call   2145e0 <panic>
  2254e4:	cc                   	int3   
  2254e5:	cc                   	int3   
  2254e6:	cc                   	int3   
  2254e7:	cc                   	int3   
  2254e8:	cc                   	int3   
  2254e9:	cc                   	int3   
  2254ea:	cc                   	int3   
  2254eb:	cc                   	int3   
  2254ec:	cc                   	int3   
  2254ed:	cc                   	int3   
  2254ee:	cc                   	int3   
  2254ef:	cc                   	int3   

00000000002254f0 <memset>:

export fn memset(dest: ?[*]u8, c: u8, n: usize) ?[*]u8 {
    @setRuntimeSafety(false);

    var index: usize = 0;
    while (index != n) : (index += 1)
  2254f0:	48 85 d2             	test   rdx,rdx
  2254f3:	0f 84 d4 01 00 00    	je     2256cd <memset+0x1dd>
  2254f9:	48 81 fa 80 00 00 00 	cmp    rdx,0x80
  225500:	73 08                	jae    22550a <memset+0x1a>
  225502:	45 31 c0             	xor    r8d,r8d
  225505:	e9 a8 01 00 00       	jmp    2256b2 <memset+0x1c2>
  22550a:	49 89 d0             	mov    r8,rdx
  22550d:	49 83 e0 80          	and    r8,0xffffffffffffff80
  225511:	c5 f9 6e c6          	vmovd  xmm0,esi
  225515:	c4 e2 7d 78 c0       	vpbroadcastb ymm0,xmm0
  22551a:	49 8d 48 80          	lea    rcx,[r8-0x80]
  22551e:	48 89 c8             	mov    rax,rcx
  225521:	48 c1 e8 07          	shr    rax,0x7
  225525:	44 8d 48 01          	lea    r9d,[rax+0x1]
  225529:	41 83 e1 07          	and    r9d,0x7
  22552d:	48 81 f9 80 03 00 00 	cmp    rcx,0x380
  225534:	73 10                	jae    225546 <memset+0x56>
  225536:	31 c0                	xor    eax,eax
  225538:	4d 85 c9             	test   r9,r9
  22553b:	0f 85 44 01 00 00    	jne    225685 <memset+0x195>
  225541:	e9 67 01 00 00       	jmp    2256ad <memset+0x1bd>
  225546:	48 8d 8f e0 03 00 00 	lea    rcx,[rdi+0x3e0]
  22554d:	4d 8d 51 ff          	lea    r10,[r9-0x1]
  225551:	49 29 c2             	sub    r10,rax
  225554:	31 c0                	xor    eax,eax
  225556:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  22555d:	00 00 00 
        dest.?[index] = c;
  225560:	c5 fe 7f 84 01 20 fc 	vmovdqu YMMWORD PTR [rcx+rax*1-0x3e0],ymm0
  225567:	ff ff 
  225569:	c5 fe 7f 84 01 40 fc 	vmovdqu YMMWORD PTR [rcx+rax*1-0x3c0],ymm0
  225570:	ff ff 
  225572:	c5 fe 7f 84 01 60 fc 	vmovdqu YMMWORD PTR [rcx+rax*1-0x3a0],ymm0
  225579:	ff ff 
  22557b:	c5 fe 7f 84 01 80 fc 	vmovdqu YMMWORD PTR [rcx+rax*1-0x380],ymm0
  225582:	ff ff 
  225584:	c5 fe 7f 84 01 a0 fc 	vmovdqu YMMWORD PTR [rcx+rax*1-0x360],ymm0
  22558b:	ff ff 
  22558d:	c5 fe 7f 84 01 c0 fc 	vmovdqu YMMWORD PTR [rcx+rax*1-0x340],ymm0
  225594:	ff ff 
  225596:	c5 fe 7f 84 01 e0 fc 	vmovdqu YMMWORD PTR [rcx+rax*1-0x320],ymm0
  22559d:	ff ff 
  22559f:	c5 fe 7f 84 01 00 fd 	vmovdqu YMMWORD PTR [rcx+rax*1-0x300],ymm0
  2255a6:	ff ff 
  2255a8:	c5 fe 7f 84 01 20 fd 	vmovdqu YMMWORD PTR [rcx+rax*1-0x2e0],ymm0
  2255af:	ff ff 
  2255b1:	c5 fe 7f 84 01 40 fd 	vmovdqu YMMWORD PTR [rcx+rax*1-0x2c0],ymm0
  2255b8:	ff ff 
  2255ba:	c5 fe 7f 84 01 60 fd 	vmovdqu YMMWORD PTR [rcx+rax*1-0x2a0],ymm0
  2255c1:	ff ff 
  2255c3:	c5 fe 7f 84 01 80 fd 	vmovdqu YMMWORD PTR [rcx+rax*1-0x280],ymm0
  2255ca:	ff ff 
  2255cc:	c5 fe 7f 84 01 a0 fd 	vmovdqu YMMWORD PTR [rcx+rax*1-0x260],ymm0
  2255d3:	ff ff 
  2255d5:	c5 fe 7f 84 01 c0 fd 	vmovdqu YMMWORD PTR [rcx+rax*1-0x240],ymm0
  2255dc:	ff ff 
  2255de:	c5 fe 7f 84 01 e0 fd 	vmovdqu YMMWORD PTR [rcx+rax*1-0x220],ymm0
  2255e5:	ff ff 
  2255e7:	c5 fe 7f 84 01 00 fe 	vmovdqu YMMWORD PTR [rcx+rax*1-0x200],ymm0
  2255ee:	ff ff 
  2255f0:	c5 fe 7f 84 01 20 fe 	vmovdqu YMMWORD PTR [rcx+rax*1-0x1e0],ymm0
  2255f7:	ff ff 
  2255f9:	c5 fe 7f 84 01 40 fe 	vmovdqu YMMWORD PTR [rcx+rax*1-0x1c0],ymm0
  225600:	ff ff 
  225602:	c5 fe 7f 84 01 60 fe 	vmovdqu YMMWORD PTR [rcx+rax*1-0x1a0],ymm0
  225609:	ff ff 
  22560b:	c5 fe 7f 84 01 80 fe 	vmovdqu YMMWORD PTR [rcx+rax*1-0x180],ymm0
  225612:	ff ff 
  225614:	c5 fe 7f 84 01 a0 fe 	vmovdqu YMMWORD PTR [rcx+rax*1-0x160],ymm0
  22561b:	ff ff 
  22561d:	c5 fe 7f 84 01 c0 fe 	vmovdqu YMMWORD PTR [rcx+rax*1-0x140],ymm0
  225624:	ff ff 
  225626:	c5 fe 7f 84 01 e0 fe 	vmovdqu YMMWORD PTR [rcx+rax*1-0x120],ymm0
  22562d:	ff ff 
  22562f:	c5 fe 7f 84 01 00 ff 	vmovdqu YMMWORD PTR [rcx+rax*1-0x100],ymm0
  225636:	ff ff 
  225638:	c5 fe 7f 84 01 20 ff 	vmovdqu YMMWORD PTR [rcx+rax*1-0xe0],ymm0
  22563f:	ff ff 
  225641:	c5 fe 7f 84 01 40 ff 	vmovdqu YMMWORD PTR [rcx+rax*1-0xc0],ymm0
  225648:	ff ff 
  22564a:	c5 fe 7f 84 01 60 ff 	vmovdqu YMMWORD PTR [rcx+rax*1-0xa0],ymm0
  225651:	ff ff 
  225653:	c5 fe 7f 44 01 80    	vmovdqu YMMWORD PTR [rcx+rax*1-0x80],ymm0
  225659:	c5 fe 7f 44 01 a0    	vmovdqu YMMWORD PTR [rcx+rax*1-0x60],ymm0
  22565f:	c5 fe 7f 44 01 c0    	vmovdqu YMMWORD PTR [rcx+rax*1-0x40],ymm0
  225665:	c5 fe 7f 44 01 e0    	vmovdqu YMMWORD PTR [rcx+rax*1-0x20],ymm0
  22566b:	c5 fe 7f 04 01       	vmovdqu YMMWORD PTR [rcx+rax*1],ymm0
    while (index != n) : (index += 1)
  225670:	48 05 00 04 00 00    	add    rax,0x400
  225676:	49 83 c2 08          	add    r10,0x8
  22567a:	0f 85 e0 fe ff ff    	jne    225560 <memset+0x70>
  225680:	4d 85 c9             	test   r9,r9
  225683:	74 28                	je     2256ad <memset+0x1bd>
  225685:	48 01 f8             	add    rax,rdi
  225688:	48 83 c0 60          	add    rax,0x60
  22568c:	49 f7 d9             	neg    r9
  22568f:	90                   	nop
        dest.?[index] = c;
  225690:	c5 fe 7f 40 a0       	vmovdqu YMMWORD PTR [rax-0x60],ymm0
  225695:	c5 fe 7f 40 c0       	vmovdqu YMMWORD PTR [rax-0x40],ymm0
  22569a:	c5 fe 7f 40 e0       	vmovdqu YMMWORD PTR [rax-0x20],ymm0
  22569f:	c5 fe 7f 00          	vmovdqu YMMWORD PTR [rax],ymm0
    while (index != n) : (index += 1)
  2256a3:	48 83 e8 80          	sub    rax,0xffffffffffffff80
  2256a7:	49 83 c1 01          	add    r9,0x1
  2256ab:	75 e3                	jne    225690 <memset+0x1a0>
  2256ad:	49 39 d0             	cmp    r8,rdx
  2256b0:	74 1b                	je     2256cd <memset+0x1dd>
        dest.?[index] = c;
  2256b2:	4a 8d 04 07          	lea    rax,[rdi+r8*1]
  2256b6:	4c 29 c2             	sub    rdx,r8
  2256b9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  2256c0:	40 88 30             	mov    BYTE PTR [rax],sil
    while (index != n) : (index += 1)
  2256c3:	48 83 c0 01          	add    rax,0x1
  2256c7:	48 83 c2 ff          	add    rdx,0xffffffffffffffff
  2256cb:	75 f3                	jne    2256c0 <memset+0x1d0>

    return dest;
  2256cd:	48 89 f8             	mov    rax,rdi
  2256d0:	c5 f8 77             	vzeroupper 
  2256d3:	c3                   	ret    
  2256d4:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  2256db:	00 00 00 00 00 

00000000002256e0 <memcpy>:

export fn memcpy(noalias dest: ?[*]u8, noalias src: ?[*]const u8, n: usize) ?[*]u8 {
    @setRuntimeSafety(false);

    var index: usize = 0;
    while (index != n) : (index += 1)
  2256e0:	48 85 d2             	test   rdx,rdx
  2256e3:	0f 84 d7 01 00 00    	je     2258c0 <memcpy+0x1e0>
  2256e9:	48 81 fa 80 00 00 00 	cmp    rdx,0x80
  2256f0:	73 07                	jae    2256f9 <memcpy+0x19>
  2256f2:	31 c0                	xor    eax,eax
  2256f4:	e9 b7 01 00 00       	jmp    2258b0 <memcpy+0x1d0>
  2256f9:	48 89 d0             	mov    rax,rdx
  2256fc:	48 83 e0 80          	and    rax,0xffffffffffffff80
  225700:	4c 8d 48 80          	lea    r9,[rax-0x80]
  225704:	4c 89 c9             	mov    rcx,r9
  225707:	48 c1 e9 07          	shr    rcx,0x7
  22570b:	44 8d 41 01          	lea    r8d,[rcx+0x1]
  22570f:	41 83 e0 03          	and    r8d,0x3
  225713:	49 81 f9 80 01 00 00 	cmp    r9,0x180
  22571a:	73 10                	jae    22572c <memcpy+0x4c>
  22571c:	31 c9                	xor    ecx,ecx
  22571e:	4d 85 c0             	test   r8,r8
  225721:	0f 85 35 01 00 00    	jne    22585c <memcpy+0x17c>
  225727:	e9 7c 01 00 00       	jmp    2258a8 <memcpy+0x1c8>
  22572c:	4d 8d 48 ff          	lea    r9,[r8-0x1]
  225730:	49 29 c9             	sub    r9,rcx
  225733:	31 c9                	xor    ecx,ecx
  225735:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  22573c:	00 00 00 00 
        dest.?[index] = src.?[index];
  225740:	c5 fc 10 04 0e       	vmovups ymm0,YMMWORD PTR [rsi+rcx*1]
  225745:	c5 fc 10 4c 0e 20    	vmovups ymm1,YMMWORD PTR [rsi+rcx*1+0x20]
  22574b:	c5 fc 10 54 0e 40    	vmovups ymm2,YMMWORD PTR [rsi+rcx*1+0x40]
  225751:	c5 fc 10 5c 0e 60    	vmovups ymm3,YMMWORD PTR [rsi+rcx*1+0x60]
  225757:	c5 fc 11 04 0f       	vmovups YMMWORD PTR [rdi+rcx*1],ymm0
  22575c:	c5 fc 11 4c 0f 20    	vmovups YMMWORD PTR [rdi+rcx*1+0x20],ymm1
  225762:	c5 fc 11 54 0f 40    	vmovups YMMWORD PTR [rdi+rcx*1+0x40],ymm2
  225768:	c5 fc 11 5c 0f 60    	vmovups YMMWORD PTR [rdi+rcx*1+0x60],ymm3
  22576e:	c5 fc 10 84 0e 80 00 	vmovups ymm0,YMMWORD PTR [rsi+rcx*1+0x80]
  225775:	00 00 
  225777:	c5 fc 10 8c 0e a0 00 	vmovups ymm1,YMMWORD PTR [rsi+rcx*1+0xa0]
  22577e:	00 00 
  225780:	c5 fc 10 94 0e c0 00 	vmovups ymm2,YMMWORD PTR [rsi+rcx*1+0xc0]
  225787:	00 00 
  225789:	c5 fc 10 9c 0e e0 00 	vmovups ymm3,YMMWORD PTR [rsi+rcx*1+0xe0]
  225790:	00 00 
  225792:	c5 fc 11 84 0f 80 00 	vmovups YMMWORD PTR [rdi+rcx*1+0x80],ymm0
  225799:	00 00 
  22579b:	c5 fc 11 8c 0f a0 00 	vmovups YMMWORD PTR [rdi+rcx*1+0xa0],ymm1
  2257a2:	00 00 
  2257a4:	c5 fc 11 94 0f c0 00 	vmovups YMMWORD PTR [rdi+rcx*1+0xc0],ymm2
  2257ab:	00 00 
  2257ad:	c5 fc 11 9c 0f e0 00 	vmovups YMMWORD PTR [rdi+rcx*1+0xe0],ymm3
  2257b4:	00 00 
  2257b6:	c5 fc 10 84 0e 00 01 	vmovups ymm0,YMMWORD PTR [rsi+rcx*1+0x100]
  2257bd:	00 00 
  2257bf:	c5 fc 10 8c 0e 20 01 	vmovups ymm1,YMMWORD PTR [rsi+rcx*1+0x120]
  2257c6:	00 00 
  2257c8:	c5 fc 10 94 0e 40 01 	vmovups ymm2,YMMWORD PTR [rsi+rcx*1+0x140]
  2257cf:	00 00 
  2257d1:	c5 fc 10 9c 0e 60 01 	vmovups ymm3,YMMWORD PTR [rsi+rcx*1+0x160]
  2257d8:	00 00 
  2257da:	c5 fc 11 84 0f 00 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x100],ymm0
  2257e1:	00 00 
  2257e3:	c5 fc 11 8c 0f 20 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x120],ymm1
  2257ea:	00 00 
  2257ec:	c5 fc 11 94 0f 40 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x140],ymm2
  2257f3:	00 00 
  2257f5:	c5 fc 11 9c 0f 60 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x160],ymm3
  2257fc:	00 00 
  2257fe:	c5 fc 10 84 0e 80 01 	vmovups ymm0,YMMWORD PTR [rsi+rcx*1+0x180]
  225805:	00 00 
  225807:	c5 fc 10 8c 0e a0 01 	vmovups ymm1,YMMWORD PTR [rsi+rcx*1+0x1a0]
  22580e:	00 00 
  225810:	c5 fc 10 94 0e c0 01 	vmovups ymm2,YMMWORD PTR [rsi+rcx*1+0x1c0]
  225817:	00 00 
  225819:	c5 fc 10 9c 0e e0 01 	vmovups ymm3,YMMWORD PTR [rsi+rcx*1+0x1e0]
  225820:	00 00 
  225822:	c5 fc 11 84 0f 80 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x180],ymm0
  225829:	00 00 
  22582b:	c5 fc 11 8c 0f a0 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x1a0],ymm1
  225832:	00 00 
  225834:	c5 fc 11 94 0f c0 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x1c0],ymm2
  22583b:	00 00 
  22583d:	c5 fc 11 9c 0f e0 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x1e0],ymm3
  225844:	00 00 
    while (index != n) : (index += 1)
  225846:	48 81 c1 00 02 00 00 	add    rcx,0x200
  22584d:	49 83 c1 04          	add    r9,0x4
  225851:	0f 85 e9 fe ff ff    	jne    225740 <memcpy+0x60>
  225857:	4d 85 c0             	test   r8,r8
  22585a:	74 4c                	je     2258a8 <memcpy+0x1c8>
  22585c:	48 83 c1 60          	add    rcx,0x60
  225860:	49 f7 d8             	neg    r8
  225863:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  22586a:	84 00 00 00 00 00 
        dest.?[index] = src.?[index];
  225870:	c5 fc 10 44 0e a0    	vmovups ymm0,YMMWORD PTR [rsi+rcx*1-0x60]
  225876:	c5 fc 10 4c 0e c0    	vmovups ymm1,YMMWORD PTR [rsi+rcx*1-0x40]
  22587c:	c5 fc 10 54 0e e0    	vmovups ymm2,YMMWORD PTR [rsi+rcx*1-0x20]
  225882:	c5 fc 10 1c 0e       	vmovups ymm3,YMMWORD PTR [rsi+rcx*1]
  225887:	c5 fc 11 44 0f a0    	vmovups YMMWORD PTR [rdi+rcx*1-0x60],ymm0
  22588d:	c5 fc 11 4c 0f c0    	vmovups YMMWORD PTR [rdi+rcx*1-0x40],ymm1
  225893:	c5 fc 11 54 0f e0    	vmovups YMMWORD PTR [rdi+rcx*1-0x20],ymm2
  225899:	c5 fc 11 1c 0f       	vmovups YMMWORD PTR [rdi+rcx*1],ymm3
    while (index != n) : (index += 1)
  22589e:	48 83 e9 80          	sub    rcx,0xffffffffffffff80
  2258a2:	49 83 c0 01          	add    r8,0x1
  2258a6:	75 c8                	jne    225870 <memcpy+0x190>
  2258a8:	48 39 d0             	cmp    rax,rdx
  2258ab:	74 13                	je     2258c0 <memcpy+0x1e0>
  2258ad:	0f 1f 00             	nop    DWORD PTR [rax]
        dest.?[index] = src.?[index];
  2258b0:	0f b6 0c 06          	movzx  ecx,BYTE PTR [rsi+rax*1]
  2258b4:	88 0c 07             	mov    BYTE PTR [rdi+rax*1],cl
    while (index != n) : (index += 1)
  2258b7:	48 83 c0 01          	add    rax,0x1
  2258bb:	48 39 c2             	cmp    rdx,rax
  2258be:	75 f0                	jne    2258b0 <memcpy+0x1d0>

    return dest;
  2258c0:	48 89 f8             	mov    rax,rdi
  2258c3:	c5 f8 77             	vzeroupper 
  2258c6:	c3                   	ret    
  2258c7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  2258ce:	00 00 

00000000002258d0 <memmove>:
}

export fn memmove(dest: ?[*]u8, src: ?[*]const u8, n: usize) ?[*]u8 {
    @setRuntimeSafety(false);

    if (@ptrToInt(dest) < @ptrToInt(src)) {
  2258d0:	48 39 f7             	cmp    rdi,rsi
  2258d3:	0f 83 cb 00 00 00    	jae    2259a4 <memmove+0xd4>
  2258d9:	48 85 d2             	test   rdx,rdx
        var index: usize = 0;
        while (index != n) : (index += 1) {
  2258dc:	0f 84 0f 05 00 00    	je     225df1 <memmove+0x521>
  2258e2:	48 81 fa 80 00 00 00 	cmp    rdx,0x80
  2258e9:	72 1a                	jb     225905 <memmove+0x35>
  2258eb:	48 8d 04 16          	lea    rax,[rsi+rdx*1]
  2258ef:	48 39 f8             	cmp    rax,rdi
  2258f2:	0f 86 0b 01 00 00    	jbe    225a03 <memmove+0x133>
  2258f8:	48 8d 04 17          	lea    rax,[rdi+rdx*1]
  2258fc:	48 39 f0             	cmp    rax,rsi
  2258ff:	0f 86 fe 00 00 00    	jbe    225a03 <memmove+0x133>
  225905:	45 31 d2             	xor    r10d,r10d
            dest.?[index] = src.?[index];
  225908:	4c 8d 42 ff          	lea    r8,[rdx-0x1]
  22590c:	4d 29 d0             	sub    r8,r10
  22590f:	48 89 d1             	mov    rcx,rdx
  225912:	48 83 e1 07          	and    rcx,0x7
  225916:	74 1b                	je     225933 <memmove+0x63>
  225918:	48 f7 d9             	neg    rcx
  22591b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  225920:	42 0f b6 04 16       	movzx  eax,BYTE PTR [rsi+r10*1]
  225925:	42 88 04 17          	mov    BYTE PTR [rdi+r10*1],al
        while (index != n) : (index += 1) {
  225929:	49 83 c2 01          	add    r10,0x1
  22592d:	48 83 c1 01          	add    rcx,0x1
  225931:	75 ed                	jne    225920 <memmove+0x50>
            dest.?[index] = src.?[index];
  225933:	49 83 f8 07          	cmp    r8,0x7
  225937:	0f 82 b4 04 00 00    	jb     225df1 <memmove+0x521>
  22593d:	0f 1f 00             	nop    DWORD PTR [rax]
  225940:	42 0f b6 04 16       	movzx  eax,BYTE PTR [rsi+r10*1]
  225945:	42 88 04 17          	mov    BYTE PTR [rdi+r10*1],al
  225949:	42 0f b6 44 16 01    	movzx  eax,BYTE PTR [rsi+r10*1+0x1]
  22594f:	42 88 44 17 01       	mov    BYTE PTR [rdi+r10*1+0x1],al
  225954:	42 0f b6 44 16 02    	movzx  eax,BYTE PTR [rsi+r10*1+0x2]
  22595a:	42 88 44 17 02       	mov    BYTE PTR [rdi+r10*1+0x2],al
  22595f:	42 0f b6 44 16 03    	movzx  eax,BYTE PTR [rsi+r10*1+0x3]
  225965:	42 88 44 17 03       	mov    BYTE PTR [rdi+r10*1+0x3],al
  22596a:	42 0f b6 44 16 04    	movzx  eax,BYTE PTR [rsi+r10*1+0x4]
  225970:	42 88 44 17 04       	mov    BYTE PTR [rdi+r10*1+0x4],al
  225975:	42 0f b6 44 16 05    	movzx  eax,BYTE PTR [rsi+r10*1+0x5]
  22597b:	42 88 44 17 05       	mov    BYTE PTR [rdi+r10*1+0x5],al
  225980:	42 0f b6 44 16 06    	movzx  eax,BYTE PTR [rsi+r10*1+0x6]
  225986:	42 88 44 17 06       	mov    BYTE PTR [rdi+r10*1+0x6],al
  22598b:	42 0f b6 44 16 07    	movzx  eax,BYTE PTR [rsi+r10*1+0x7]
  225991:	42 88 44 17 07       	mov    BYTE PTR [rdi+r10*1+0x7],al
        while (index != n) : (index += 1) {
  225996:	49 83 c2 08          	add    r10,0x8
  22599a:	4c 39 d2             	cmp    rdx,r10
  22599d:	75 a1                	jne    225940 <memmove+0x70>
  22599f:	e9 4d 04 00 00       	jmp    225df1 <memmove+0x521>
  2259a4:	48 85 d2             	test   rdx,rdx
        }
    } else {
        var index = n;
        while (index != 0) {
  2259a7:	0f 84 44 04 00 00    	je     225df1 <memmove+0x521>
  2259ad:	48 81 fa 80 00 00 00 	cmp    rdx,0x80
  2259b4:	0f 82 2a 02 00 00    	jb     225be4 <memmove+0x314>
  2259ba:	48 8d 04 16          	lea    rax,[rsi+rdx*1]
  2259be:	48 39 f8             	cmp    rax,rdi
  2259c1:	76 0d                	jbe    2259d0 <memmove+0x100>
  2259c3:	48 8d 04 17          	lea    rax,[rdi+rdx*1]
  2259c7:	48 39 f0             	cmp    rax,rsi
  2259ca:	0f 87 14 02 00 00    	ja     225be4 <memmove+0x314>
  2259d0:	49 89 d0             	mov    r8,rdx
  2259d3:	49 83 e0 80          	and    r8,0xffffffffffffff80
  2259d7:	49 8d 48 80          	lea    rcx,[r8-0x80]
  2259db:	48 89 c8             	mov    rax,rcx
  2259de:	48 c1 e8 07          	shr    rax,0x7
  2259e2:	44 8d 48 01          	lea    r9d,[rax+0x1]
  2259e6:	41 83 e1 03          	and    r9d,0x3
  2259ea:	48 81 f9 80 01 00 00 	cmp    rcx,0x180
  2259f1:	73 47                	jae    225a3a <memmove+0x16a>
  2259f3:	31 c0                	xor    eax,eax
  2259f5:	4d 85 c9             	test   r9,r9
  2259f8:	0f 85 8a 01 00 00    	jne    225b88 <memmove+0x2b8>
  2259fe:	e9 d5 01 00 00       	jmp    225bd8 <memmove+0x308>
        while (index != n) : (index += 1) {
  225a03:	49 89 d2             	mov    r10,rdx
  225a06:	49 83 e2 80          	and    r10,0xffffffffffffff80
  225a0a:	4d 8d 4a 80          	lea    r9,[r10-0x80]
  225a0e:	4c 89 c9             	mov    rcx,r9
  225a11:	48 c1 e9 07          	shr    rcx,0x7
  225a15:	44 8d 41 01          	lea    r8d,[rcx+0x1]
  225a19:	41 83 e0 03          	and    r8d,0x3
  225a1d:	49 81 f9 80 01 00 00 	cmp    r9,0x180
  225a24:	0f 83 4c 02 00 00    	jae    225c76 <memmove+0x3a6>
  225a2a:	31 c9                	xor    ecx,ecx
  225a2c:	4d 85 c0             	test   r8,r8
  225a2f:	0f 85 67 03 00 00    	jne    225d9c <memmove+0x4cc>
  225a35:	e9 ae 03 00 00       	jmp    225de8 <memmove+0x518>
        while (index != 0) {
  225a3a:	4c 8d 14 16          	lea    r10,[rsi+rdx*1]
  225a3e:	49 83 c2 e0          	add    r10,0xffffffffffffffe0
  225a42:	48 8d 0c 17          	lea    rcx,[rdi+rdx*1]
  225a46:	48 83 c1 e0          	add    rcx,0xffffffffffffffe0
  225a4a:	4d 8d 59 ff          	lea    r11,[r9-0x1]
  225a4e:	49 29 c3             	sub    r11,rax
  225a51:	31 c0                	xor    eax,eax
  225a53:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  225a5a:	84 00 00 00 00 00 
            index -= 1;
            dest.?[index] = src.?[index];
  225a60:	c4 c1 7c 10 44 02 a0 	vmovups ymm0,YMMWORD PTR [r10+rax*1-0x60]
  225a67:	c4 c1 7c 10 4c 02 c0 	vmovups ymm1,YMMWORD PTR [r10+rax*1-0x40]
  225a6e:	c4 c1 7c 10 54 02 e0 	vmovups ymm2,YMMWORD PTR [r10+rax*1-0x20]
  225a75:	c4 c1 7c 10 1c 02    	vmovups ymm3,YMMWORD PTR [r10+rax*1]
  225a7b:	c5 fc 11 1c 01       	vmovups YMMWORD PTR [rcx+rax*1],ymm3
  225a80:	c5 fc 11 54 01 e0    	vmovups YMMWORD PTR [rcx+rax*1-0x20],ymm2
  225a86:	c5 fc 11 4c 01 c0    	vmovups YMMWORD PTR [rcx+rax*1-0x40],ymm1
  225a8c:	c5 fc 11 44 01 a0    	vmovups YMMWORD PTR [rcx+rax*1-0x60],ymm0
  225a92:	c4 c1 7c 10 84 02 20 	vmovups ymm0,YMMWORD PTR [r10+rax*1-0xe0]
  225a99:	ff ff ff 
  225a9c:	c4 c1 7c 10 8c 02 40 	vmovups ymm1,YMMWORD PTR [r10+rax*1-0xc0]
  225aa3:	ff ff ff 
  225aa6:	c4 c1 7c 10 94 02 60 	vmovups ymm2,YMMWORD PTR [r10+rax*1-0xa0]
  225aad:	ff ff ff 
  225ab0:	c4 c1 7c 10 5c 02 80 	vmovups ymm3,YMMWORD PTR [r10+rax*1-0x80]
  225ab7:	c5 fc 11 5c 01 80    	vmovups YMMWORD PTR [rcx+rax*1-0x80],ymm3
  225abd:	c5 fc 11 94 01 60 ff 	vmovups YMMWORD PTR [rcx+rax*1-0xa0],ymm2
  225ac4:	ff ff 
  225ac6:	c5 fc 11 8c 01 40 ff 	vmovups YMMWORD PTR [rcx+rax*1-0xc0],ymm1
  225acd:	ff ff 
  225acf:	c5 fc 11 84 01 20 ff 	vmovups YMMWORD PTR [rcx+rax*1-0xe0],ymm0
  225ad6:	ff ff 
  225ad8:	c4 c1 7c 10 84 02 a0 	vmovups ymm0,YMMWORD PTR [r10+rax*1-0x160]
  225adf:	fe ff ff 
  225ae2:	c4 c1 7c 10 8c 02 c0 	vmovups ymm1,YMMWORD PTR [r10+rax*1-0x140]
  225ae9:	fe ff ff 
  225aec:	c4 c1 7c 10 94 02 e0 	vmovups ymm2,YMMWORD PTR [r10+rax*1-0x120]
  225af3:	fe ff ff 
  225af6:	c4 c1 7c 10 9c 02 00 	vmovups ymm3,YMMWORD PTR [r10+rax*1-0x100]
  225afd:	ff ff ff 
  225b00:	c5 fc 11 9c 01 00 ff 	vmovups YMMWORD PTR [rcx+rax*1-0x100],ymm3
  225b07:	ff ff 
  225b09:	c5 fc 11 94 01 e0 fe 	vmovups YMMWORD PTR [rcx+rax*1-0x120],ymm2
  225b10:	ff ff 
  225b12:	c5 fc 11 8c 01 c0 fe 	vmovups YMMWORD PTR [rcx+rax*1-0x140],ymm1
  225b19:	ff ff 
  225b1b:	c5 fc 11 84 01 a0 fe 	vmovups YMMWORD PTR [rcx+rax*1-0x160],ymm0
  225b22:	ff ff 
  225b24:	c4 c1 7c 10 84 02 20 	vmovups ymm0,YMMWORD PTR [r10+rax*1-0x1e0]
  225b2b:	fe ff ff 
  225b2e:	c4 c1 7c 10 8c 02 40 	vmovups ymm1,YMMWORD PTR [r10+rax*1-0x1c0]
  225b35:	fe ff ff 
  225b38:	c4 c1 7c 10 94 02 60 	vmovups ymm2,YMMWORD PTR [r10+rax*1-0x1a0]
  225b3f:	fe ff ff 
  225b42:	c4 c1 7c 10 9c 02 80 	vmovups ymm3,YMMWORD PTR [r10+rax*1-0x180]
  225b49:	fe ff ff 
  225b4c:	c5 fc 11 9c 01 80 fe 	vmovups YMMWORD PTR [rcx+rax*1-0x180],ymm3
  225b53:	ff ff 
  225b55:	c5 fc 11 94 01 60 fe 	vmovups YMMWORD PTR [rcx+rax*1-0x1a0],ymm2
  225b5c:	ff ff 
  225b5e:	c5 fc 11 8c 01 40 fe 	vmovups YMMWORD PTR [rcx+rax*1-0x1c0],ymm1
  225b65:	ff ff 
  225b67:	c5 fc 11 84 01 20 fe 	vmovups YMMWORD PTR [rcx+rax*1-0x1e0],ymm0
  225b6e:	ff ff 
  225b70:	48 05 00 fe ff ff    	add    rax,0xfffffffffffffe00
  225b76:	49 83 c3 04          	add    r11,0x4
  225b7a:	0f 85 e0 fe ff ff    	jne    225a60 <memmove+0x190>
  225b80:	48 f7 d8             	neg    rax
  225b83:	4d 85 c9             	test   r9,r9
  225b86:	74 50                	je     225bd8 <memmove+0x308>
  225b88:	48 8d 4a e0          	lea    rcx,[rdx-0x20]
  225b8c:	48 29 c1             	sub    rcx,rax
  225b8f:	49 f7 d9             	neg    r9
  225b92:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  225b99:	1f 84 00 00 00 00 00 
  225ba0:	c5 fc 10 44 0e a0    	vmovups ymm0,YMMWORD PTR [rsi+rcx*1-0x60]
  225ba6:	c5 fc 10 4c 0e c0    	vmovups ymm1,YMMWORD PTR [rsi+rcx*1-0x40]
  225bac:	c5 fc 10 54 0e e0    	vmovups ymm2,YMMWORD PTR [rsi+rcx*1-0x20]
  225bb2:	c5 fc 10 1c 0e       	vmovups ymm3,YMMWORD PTR [rsi+rcx*1]
  225bb7:	c5 fc 11 1c 0f       	vmovups YMMWORD PTR [rdi+rcx*1],ymm3
  225bbc:	c5 fc 11 54 0f e0    	vmovups YMMWORD PTR [rdi+rcx*1-0x20],ymm2
  225bc2:	c5 fc 11 4c 0f c0    	vmovups YMMWORD PTR [rdi+rcx*1-0x40],ymm1
  225bc8:	c5 fc 11 44 0f a0    	vmovups YMMWORD PTR [rdi+rcx*1-0x60],ymm0
  225bce:	48 83 c1 80          	add    rcx,0xffffffffffffff80
  225bd2:	49 83 c1 01          	add    r9,0x1
  225bd6:	75 c8                	jne    225ba0 <memmove+0x2d0>
  225bd8:	49 39 d0             	cmp    r8,rdx
        while (index != 0) {
  225bdb:	0f 84 10 02 00 00    	je     225df1 <memmove+0x521>
  225be1:	4c 29 c2             	sub    rdx,r8
            index -= 1;
  225be4:	4c 8d 42 ff          	lea    r8,[rdx-0x1]
  225be8:	48 89 d1             	mov    rcx,rdx
  225beb:	48 83 e1 07          	and    rcx,0x7
  225bef:	74 22                	je     225c13 <memmove+0x343>
  225bf1:	48 f7 d9             	neg    rcx
  225bf4:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  225bfb:	00 00 00 00 00 
            dest.?[index] = src.?[index];
  225c00:	0f b6 44 16 ff       	movzx  eax,BYTE PTR [rsi+rdx*1-0x1]
  225c05:	88 44 17 ff          	mov    BYTE PTR [rdi+rdx*1-0x1],al
            index -= 1;
  225c09:	48 8d 52 ff          	lea    rdx,[rdx-0x1]
        while (index != 0) {
  225c0d:	48 83 c1 01          	add    rcx,0x1
  225c11:	75 ed                	jne    225c00 <memmove+0x330>
            index -= 1;
  225c13:	49 83 f8 07          	cmp    r8,0x7
  225c17:	0f 82 d4 01 00 00    	jb     225df1 <memmove+0x521>
        while (index != 0) {
  225c1d:	48 89 d0             	mov    rax,rdx
            dest.?[index] = src.?[index];
  225c20:	0f b6 4c 16 ff       	movzx  ecx,BYTE PTR [rsi+rdx*1-0x1]
  225c25:	88 4c 17 ff          	mov    BYTE PTR [rdi+rdx*1-0x1],cl
  225c29:	0f b6 4c 16 fe       	movzx  ecx,BYTE PTR [rsi+rdx*1-0x2]
  225c2e:	88 4c 17 fe          	mov    BYTE PTR [rdi+rdx*1-0x2],cl
  225c32:	0f b6 4c 16 fd       	movzx  ecx,BYTE PTR [rsi+rdx*1-0x3]
  225c37:	88 4c 17 fd          	mov    BYTE PTR [rdi+rdx*1-0x3],cl
  225c3b:	0f b6 4c 16 fc       	movzx  ecx,BYTE PTR [rsi+rdx*1-0x4]
  225c40:	88 4c 17 fc          	mov    BYTE PTR [rdi+rdx*1-0x4],cl
  225c44:	0f b6 4c 16 fb       	movzx  ecx,BYTE PTR [rsi+rdx*1-0x5]
  225c49:	88 4c 17 fb          	mov    BYTE PTR [rdi+rdx*1-0x5],cl
  225c4d:	0f b6 4c 16 fa       	movzx  ecx,BYTE PTR [rsi+rdx*1-0x6]
  225c52:	88 4c 17 fa          	mov    BYTE PTR [rdi+rdx*1-0x6],cl
  225c56:	0f b6 4c 16 f9       	movzx  ecx,BYTE PTR [rsi+rdx*1-0x7]
  225c5b:	88 4c 17 f9          	mov    BYTE PTR [rdi+rdx*1-0x7],cl
  225c5f:	0f b6 4c 16 f8       	movzx  ecx,BYTE PTR [rsi+rdx*1-0x8]
  225c64:	88 4c 17 f8          	mov    BYTE PTR [rdi+rdx*1-0x8],cl
        while (index != 0) {
  225c68:	48 83 c0 f8          	add    rax,0xfffffffffffffff8
  225c6c:	48 89 c2             	mov    rdx,rax
  225c6f:	75 af                	jne    225c20 <memmove+0x350>
  225c71:	e9 7b 01 00 00       	jmp    225df1 <memmove+0x521>
        while (index != n) : (index += 1) {
  225c76:	4d 8d 48 ff          	lea    r9,[r8-0x1]
  225c7a:	49 29 c9             	sub    r9,rcx
  225c7d:	31 c9                	xor    ecx,ecx
  225c7f:	90                   	nop
            dest.?[index] = src.?[index];
  225c80:	c5 fc 10 04 0e       	vmovups ymm0,YMMWORD PTR [rsi+rcx*1]
  225c85:	c5 fc 10 4c 0e 20    	vmovups ymm1,YMMWORD PTR [rsi+rcx*1+0x20]
  225c8b:	c5 fc 10 54 0e 40    	vmovups ymm2,YMMWORD PTR [rsi+rcx*1+0x40]
  225c91:	c5 fc 10 5c 0e 60    	vmovups ymm3,YMMWORD PTR [rsi+rcx*1+0x60]
  225c97:	c5 fc 11 04 0f       	vmovups YMMWORD PTR [rdi+rcx*1],ymm0
  225c9c:	c5 fc 11 4c 0f 20    	vmovups YMMWORD PTR [rdi+rcx*1+0x20],ymm1
  225ca2:	c5 fc 11 54 0f 40    	vmovups YMMWORD PTR [rdi+rcx*1+0x40],ymm2
  225ca8:	c5 fc 11 5c 0f 60    	vmovups YMMWORD PTR [rdi+rcx*1+0x60],ymm3
  225cae:	c5 fc 10 84 0e 80 00 	vmovups ymm0,YMMWORD PTR [rsi+rcx*1+0x80]
  225cb5:	00 00 
  225cb7:	c5 fc 10 8c 0e a0 00 	vmovups ymm1,YMMWORD PTR [rsi+rcx*1+0xa0]
  225cbe:	00 00 
  225cc0:	c5 fc 10 94 0e c0 00 	vmovups ymm2,YMMWORD PTR [rsi+rcx*1+0xc0]
  225cc7:	00 00 
  225cc9:	c5 fc 10 9c 0e e0 00 	vmovups ymm3,YMMWORD PTR [rsi+rcx*1+0xe0]
  225cd0:	00 00 
  225cd2:	c5 fc 11 84 0f 80 00 	vmovups YMMWORD PTR [rdi+rcx*1+0x80],ymm0
  225cd9:	00 00 
  225cdb:	c5 fc 11 8c 0f a0 00 	vmovups YMMWORD PTR [rdi+rcx*1+0xa0],ymm1
  225ce2:	00 00 
  225ce4:	c5 fc 11 94 0f c0 00 	vmovups YMMWORD PTR [rdi+rcx*1+0xc0],ymm2
  225ceb:	00 00 
  225ced:	c5 fc 11 9c 0f e0 00 	vmovups YMMWORD PTR [rdi+rcx*1+0xe0],ymm3
  225cf4:	00 00 
  225cf6:	c5 fc 10 84 0e 00 01 	vmovups ymm0,YMMWORD PTR [rsi+rcx*1+0x100]
  225cfd:	00 00 
  225cff:	c5 fc 10 8c 0e 20 01 	vmovups ymm1,YMMWORD PTR [rsi+rcx*1+0x120]
  225d06:	00 00 
  225d08:	c5 fc 10 94 0e 40 01 	vmovups ymm2,YMMWORD PTR [rsi+rcx*1+0x140]
  225d0f:	00 00 
  225d11:	c5 fc 10 9c 0e 60 01 	vmovups ymm3,YMMWORD PTR [rsi+rcx*1+0x160]
  225d18:	00 00 
  225d1a:	c5 fc 11 84 0f 00 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x100],ymm0
  225d21:	00 00 
  225d23:	c5 fc 11 8c 0f 20 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x120],ymm1
  225d2a:	00 00 
  225d2c:	c5 fc 11 94 0f 40 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x140],ymm2
  225d33:	00 00 
  225d35:	c5 fc 11 9c 0f 60 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x160],ymm3
  225d3c:	00 00 
  225d3e:	c5 fc 10 84 0e 80 01 	vmovups ymm0,YMMWORD PTR [rsi+rcx*1+0x180]
  225d45:	00 00 
  225d47:	c5 fc 10 8c 0e a0 01 	vmovups ymm1,YMMWORD PTR [rsi+rcx*1+0x1a0]
  225d4e:	00 00 
  225d50:	c5 fc 10 94 0e c0 01 	vmovups ymm2,YMMWORD PTR [rsi+rcx*1+0x1c0]
  225d57:	00 00 
  225d59:	c5 fc 10 9c 0e e0 01 	vmovups ymm3,YMMWORD PTR [rsi+rcx*1+0x1e0]
  225d60:	00 00 
  225d62:	c5 fc 11 84 0f 80 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x180],ymm0
  225d69:	00 00 
  225d6b:	c5 fc 11 8c 0f a0 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x1a0],ymm1
  225d72:	00 00 
  225d74:	c5 fc 11 94 0f c0 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x1c0],ymm2
  225d7b:	00 00 
  225d7d:	c5 fc 11 9c 0f e0 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x1e0],ymm3
  225d84:	00 00 
        while (index != n) : (index += 1) {
  225d86:	48 81 c1 00 02 00 00 	add    rcx,0x200
  225d8d:	49 83 c1 04          	add    r9,0x4
  225d91:	0f 85 e9 fe ff ff    	jne    225c80 <memmove+0x3b0>
  225d97:	4d 85 c0             	test   r8,r8
  225d9a:	74 4c                	je     225de8 <memmove+0x518>
  225d9c:	48 83 c1 60          	add    rcx,0x60
  225da0:	49 f7 d8             	neg    r8
  225da3:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  225daa:	84 00 00 00 00 00 
            dest.?[index] = src.?[index];
  225db0:	c5 fc 10 44 0e a0    	vmovups ymm0,YMMWORD PTR [rsi+rcx*1-0x60]
  225db6:	c5 fc 10 4c 0e c0    	vmovups ymm1,YMMWORD PTR [rsi+rcx*1-0x40]
  225dbc:	c5 fc 10 54 0e e0    	vmovups ymm2,YMMWORD PTR [rsi+rcx*1-0x20]
  225dc2:	c5 fc 10 1c 0e       	vmovups ymm3,YMMWORD PTR [rsi+rcx*1]
  225dc7:	c5 fc 11 44 0f a0    	vmovups YMMWORD PTR [rdi+rcx*1-0x60],ymm0
  225dcd:	c5 fc 11 4c 0f c0    	vmovups YMMWORD PTR [rdi+rcx*1-0x40],ymm1
  225dd3:	c5 fc 11 54 0f e0    	vmovups YMMWORD PTR [rdi+rcx*1-0x20],ymm2
  225dd9:	c5 fc 11 1c 0f       	vmovups YMMWORD PTR [rdi+rcx*1],ymm3
        while (index != n) : (index += 1) {
  225dde:	48 83 e9 80          	sub    rcx,0xffffffffffffff80
  225de2:	49 83 c0 01          	add    r8,0x1
  225de6:	75 c8                	jne    225db0 <memmove+0x4e0>
  225de8:	49 39 d2             	cmp    r10,rdx
  225deb:	0f 85 17 fb ff ff    	jne    225908 <memmove+0x38>
        }
    }

    return dest;
  225df1:	48 89 f8             	mov    rax,rdi
  225df4:	c5 f8 77             	vzeroupper 
  225df7:	c3                   	ret    
  225df8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  225dff:	00 

0000000000225e00 <clone>:

// TODO we should be able to put this directly in std/linux/x86_64.zig but
// it causes a segfault in release mode. this is a workaround of calling it
// across .o file boundaries. fix comptime @ptrCast of nakedcc functions.
nakedcc fn clone() void {
    asm volatile (
  225e00:	31 c0                	xor    eax,eax
  225e02:	b0 38                	mov    al,0x38
  225e04:	49 89 fb             	mov    r11,rdi
  225e07:	48 89 d7             	mov    rdi,rdx
  225e0a:	4c 89 c2             	mov    rdx,r8
  225e0d:	4d 89 c8             	mov    r8,r9
  225e10:	4c 8b 54 24 08       	mov    r10,QWORD PTR [rsp+0x8]
  225e15:	4d 89 d9             	mov    r9,r11
  225e18:	48 83 e6 f0          	and    rsi,0xfffffffffffffff0
  225e1c:	48 83 ee 08          	sub    rsi,0x8
  225e20:	48 89 0e             	mov    QWORD PTR [rsi],rcx
  225e23:	0f 05                	syscall 
  225e25:	85 c0                	test   eax,eax
  225e27:	75 0f                	jne    225e38 <clone+0x38>
  225e29:	31 ed                	xor    ebp,ebp
  225e2b:	5f                   	pop    rdi
  225e2c:	41 ff d1             	call   r9
  225e2f:	89 c7                	mov    edi,eax
  225e31:	31 c0                	xor    eax,eax
  225e33:	b0 3c                	mov    al,0x3c
  225e35:	0f 05                	syscall 
  225e37:	f4                   	hlt    
  225e38:	c3                   	ret    
nakedcc fn clone() void {
  225e39:	c3                   	ret    
  225e3a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000225e40 <fmodf>:
    const digits = if (T == f32) 23 else 52;
    const exp_bits = if (T == f32) 9 else 12;
    const bits_minus_1 = T.bit_count - 1;
    const mask = if (T == f32) 0xff else 0x7ff;
    var ux = @bitCast(uint, x);
    var uy = @bitCast(uint, y);
  225e40:	c4 c1 79 7e c9       	vmovd  r9d,xmm1
    var ex = @intCast(i32, (ux >> digits) & mask);
    var ey = @intCast(i32, (uy >> digits) & mask);
    const sx = if (T == f32) @intCast(u32, ux & 0x80000000) else @intCast(i32, ux >> bits_minus_1);
    var i: uint = undefined;

    if (uy << 1 == 0 or isNan(uint, uy) or ex == mask)
  225e45:	44 89 c8             	mov    eax,r9d
  225e48:	01 c0                	add    eax,eax
  225e4a:	74 5a                	je     225ea6 <fmodf+0x66>

fn isNan(comptime T: type, bits: T) bool {
    if (T == u16) {
        return (bits & 0x7fff) > 0x7c00;
    } else if (T == u32) {
        return (bits & 0x7fffffff) > 0x7f800000;
  225e4c:	44 89 c9             	mov    ecx,r9d
  225e4f:	81 e1 ff ff ff 7f    	and    ecx,0x7fffffff
  225e55:	81 f9 00 00 80 7f    	cmp    ecx,0x7f800000
    if (uy << 1 == 0 or isNan(uint, uy) or ex == mask)
  225e5b:	77 49                	ja     225ea6 <fmodf+0x66>
  225e5d:	c4 c1 79 7e c0       	vmovd  r8d,xmm0
  225e62:	ba 17 08 00 00       	mov    edx,0x817
  225e67:	c4 c2 68 f7 c8       	bextr  ecx,r8d,edx
  225e6c:	81 f9 ff 00 00 00    	cmp    ecx,0xff
  225e72:	74 32                	je     225ea6 <fmodf+0x66>
    if (ux << 1 <= uy << 1) {
  225e74:	43 8d 34 00          	lea    esi,[r8+r8*1]
  225e78:	39 c6                	cmp    esi,eax
  225e7a:	76 33                	jbe    225eaf <fmodf+0x6f>
  225e7c:	c4 c2 68 f7 f9       	bextr  edi,r9d,edx
        ux &= @maxValue(uint) >> exp_bits;
  225e81:	44 89 c0             	mov    eax,r8d
    if (ex == 0) {
  225e84:	85 c9                	test   ecx,ecx
  225e86:	74 32                	je     225eba <fmodf+0x7a>
        ux &= @maxValue(uint) >> exp_bits;
  225e88:	25 ff ff 7f 00       	and    eax,0x7fffff
        ux |= 1 << digits;
  225e8d:	0d 00 00 80 00       	or     eax,0x800000
    if (ey == 0) {
  225e92:	85 ff                	test   edi,edi
  225e94:	74 51                	je     225ee7 <fmodf+0xa7>
        uy &= @maxValue(uint) >> exp_bits;
  225e96:	41 81 e1 ff ff 7f 00 	and    r9d,0x7fffff
        uy |= 1 << digits;
  225e9d:	41 81 c9 00 00 80 00 	or     r9d,0x800000
  225ea4:	eb 7f                	jmp    225f25 <fmodf+0xe5>
        return (x * y) / (x * y);
  225ea6:	c5 fa 59 c1          	vmulss xmm0,xmm0,xmm1
  225eaa:	c5 fa 5e c0          	vdivss xmm0,xmm0,xmm0
    return generic_fmod(f32, x, y);
  225eae:	c3                   	ret    
        if (ux << 1 == uy << 1)
  225eaf:	75 08                	jne    225eb9 <fmodf+0x79>
  225eb1:	c5 f1 ef c9          	vpxor  xmm1,xmm1,xmm1
  225eb5:	c5 fa 59 c1          	vmulss xmm0,xmm0,xmm1
  225eb9:	c3                   	ret    
  225eba:	31 c9                	xor    ecx,ecx
        i = ux << exp_bits;
  225ebc:	c1 e0 09             	shl    eax,0x9
        while (i >> bits_minus_1 == 0) : (b: {
  225ebf:	78 16                	js     225ed7 <fmodf+0x97>
  225ec1:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  225ec8:	0f 1f 84 00 00 00 00 
  225ecf:	00 
            ex -= 1;
  225ed0:	83 c1 ff             	add    ecx,0xffffffff
            i <<= 1;
  225ed3:	01 c0                	add    eax,eax
        while (i >> bits_minus_1 == 0) : (b: {
  225ed5:	79 f9                	jns    225ed0 <fmodf+0x90>
        ux <<= @intCast(log2uint, @bitCast(u32, -ex + 1));
  225ed7:	b8 01 00 00 00       	mov    eax,0x1
  225edc:	29 c8                	sub    eax,ecx
  225ede:	c4 c2 79 f7 c0       	shlx   eax,r8d,eax
    if (ey == 0) {
  225ee3:	85 ff                	test   edi,edi
  225ee5:	75 af                	jne    225e96 <fmodf+0x56>
        i = uy << exp_bits;
  225ee7:	44 89 ca             	mov    edx,r9d
  225eea:	31 ff                	xor    edi,edi
  225eec:	c1 e2 09             	shl    edx,0x9
        while (i >> bits_minus_1 == 0) : (b: {
  225eef:	78 16                	js     225f07 <fmodf+0xc7>
  225ef1:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  225ef8:	0f 1f 84 00 00 00 00 
  225eff:	00 
            ey -= 1;
  225f00:	83 c7 ff             	add    edi,0xffffffff
            i <<= 1;
  225f03:	01 d2                	add    edx,edx
        while (i >> bits_minus_1 == 0) : (b: {
  225f05:	79 f9                	jns    225f00 <fmodf+0xc0>
        uy <<= @intCast(log2uint, @bitCast(u32, -ey + 1));
  225f07:	ba 01 00 00 00       	mov    edx,0x1
  225f0c:	29 fa                	sub    edx,edi
  225f0e:	c4 42 69 f7 c9       	shlx   r9d,r9d,edx
  225f13:	eb 10                	jmp    225f25 <fmodf+0xe5>
  225f15:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  225f1c:	00 00 00 00 
        ux <<= 1;
  225f20:	01 c0                	add    eax,eax
    while (ex > ey) : (ex -= 1) {
  225f22:	83 c1 ff             	add    ecx,0xffffffff
  225f25:	89 c6                	mov    esi,eax
  225f27:	44 29 ce             	sub    esi,r9d
  225f2a:	0f 99 c2             	setns  dl
  225f2d:	39 f9                	cmp    ecx,edi
  225f2f:	7e 0d                	jle    225f3e <fmodf+0xfe>
        if (i >> bits_minus_1 == 0) {
  225f31:	f6 c2 01             	test   dl,0x1
  225f34:	74 ea                	je     225f20 <fmodf+0xe0>
  225f36:	89 f0                	mov    eax,esi
            if (i == 0)
  225f38:	85 f6                	test   esi,esi
  225f3a:	75 e4                	jne    225f20 <fmodf+0xe0>
  225f3c:	eb 3b                	jmp    225f79 <fmodf+0x139>
    if (i >> bits_minus_1 == 0) {
  225f3e:	84 d2                	test   dl,dl
  225f40:	74 06                	je     225f48 <fmodf+0x108>
  225f42:	89 f0                	mov    eax,esi
        if (i == 0)
  225f44:	85 f6                	test   esi,esi
  225f46:	74 31                	je     225f79 <fmodf+0x139>
    while (ux >> digits == 0) : (b: {
  225f48:	3d ff ff 7f 00       	cmp    eax,0x7fffff
  225f4d:	77 0d                	ja     225f5c <fmodf+0x11c>
  225f4f:	90                   	nop
        ux <<= 1;
  225f50:	01 c0                	add    eax,eax
        ex -= 1;
  225f52:	83 c1 ff             	add    ecx,0xffffffff
    while (ux >> digits == 0) : (b: {
  225f55:	3d 00 00 80 00       	cmp    eax,0x800000
  225f5a:	72 f4                	jb     225f50 <fmodf+0x110>
  225f5c:	41 81 e0 00 00 00 80 	and    r8d,0x80000000
    if (ex > 0) {
  225f63:	85 c9                	test   ecx,ecx
  225f65:	7e 1b                	jle    225f82 <fmodf+0x142>
        ux -%= 1 << digits;
  225f67:	05 00 00 80 ff       	add    eax,0xff800000
        ux |= uint(@bitCast(u32, ex)) << digits;
  225f6c:	c1 e1 17             	shl    ecx,0x17
  225f6f:	09 c1                	or     ecx,eax
        ux |= sx;
  225f71:	44 09 c1             	or     ecx,r8d
    return @bitCast(T, ux);
  225f74:	c5 f9 6e c1          	vmovd  xmm0,ecx
    return generic_fmod(f32, x, y);
  225f78:	c3                   	ret    
  225f79:	c5 f1 ef c9          	vpxor  xmm1,xmm1,xmm1
  225f7d:	c5 fa 59 c1          	vmulss xmm0,xmm0,xmm1
  225f81:	c3                   	ret    
        ux >>= @intCast(log2uint, @bitCast(u32, -ex + 1));
  225f82:	ba 01 00 00 00       	mov    edx,0x1
  225f87:	29 ca                	sub    edx,ecx
  225f89:	c4 e2 6b f7 c8       	shrx   ecx,eax,edx
        ux |= sx;
  225f8e:	44 09 c1             	or     ecx,r8d
    return @bitCast(T, ux);
  225f91:	c5 f9 6e c1          	vmovd  xmm0,ecx
    return generic_fmod(f32, x, y);
  225f95:	c3                   	ret    
  225f96:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  225f9d:	00 00 00 

0000000000225fa0 <fmod>:
    var uy = @bitCast(uint, y);
  225fa0:	c4 c1 f9 7e cb       	vmovq  r11,xmm1
    if (uy << 1 == 0 or isNan(uint, uy) or ex == mask)
  225fa5:	4c 89 d8             	mov    rax,r11
  225fa8:	48 01 c0             	add    rax,rax
  225fab:	74 7a                	je     226027 <fmod+0x87>
  225fad:	49 b9 ff ff ff ff ff 	movabs r9,0x7fffffffffffffff
  225fb4:	ff ff 7f 
    } else if (T == u64) {
        return (bits & (@maxValue(u64) >> 1)) > (u64(0x7ff) << 52);
  225fb7:	4c 89 d9             	mov    rcx,r11
  225fba:	4c 21 c9             	and    rcx,r9
  225fbd:	48 ba 00 00 00 00 00 	movabs rdx,0x7ff0000000000000
  225fc4:	00 f0 7f 
  225fc7:	48 39 d1             	cmp    rcx,rdx
    if (uy << 1 == 0 or isNan(uint, uy) or ex == mask)
  225fca:	77 5b                	ja     226027 <fmod+0x87>
  225fcc:	c4 c1 f9 7e c2       	vmovq  r10,xmm0
  225fd1:	4c 89 d1             	mov    rcx,r10
  225fd4:	48 c1 e9 34          	shr    rcx,0x34
  225fd8:	81 e1 ff 07 00 00    	and    ecx,0x7ff
  225fde:	81 f9 ff 07 00 00    	cmp    ecx,0x7ff
  225fe4:	74 41                	je     226027 <fmod+0x87>
    if (ux << 1 <= uy << 1) {
  225fe6:	4b 8d 14 12          	lea    rdx,[r10+r10*1]
  225fea:	48 39 c2             	cmp    rdx,rax
  225fed:	76 41                	jbe    226030 <fmod+0x90>
  225fef:	4c 89 df             	mov    rdi,r11
  225ff2:	48 c1 ef 34          	shr    rdi,0x34
  225ff6:	81 e7 ff 07 00 00    	and    edi,0x7ff
  225ffc:	49 b8 00 00 00 00 00 	movabs r8,0x10000000000000
  226003:	00 10 00 
    if (ex == 0) {
  226006:	85 c9                	test   ecx,ecx
  226008:	74 31                	je     22603b <fmod+0x9b>
        ux &= @maxValue(uint) >> exp_bits;
  22600a:	49 8d 40 ff          	lea    rax,[r8-0x1]
  22600e:	4c 21 d0             	and    rax,r10
        ux |= 1 << digits;
  226011:	4c 09 c0             	or     rax,r8
    if (ey == 0) {
  226014:	85 ff                	test   edi,edi
  226016:	74 50                	je     226068 <fmod+0xc8>
        uy &= @maxValue(uint) >> exp_bits;
  226018:	49 8d 50 ff          	lea    rdx,[r8-0x1]
  22601c:	49 21 d3             	and    r11,rdx
        uy |= 1 << digits;
  22601f:	4d 09 c3             	or     r11,r8
  226022:	e9 7f 00 00 00       	jmp    2260a6 <fmod+0x106>
        return (x * y) / (x * y);
  226027:	c5 fb 59 c1          	vmulsd xmm0,xmm0,xmm1
  22602b:	c5 fb 5e c0          	vdivsd xmm0,xmm0,xmm0
    return generic_fmod(f64, x, y);
  22602f:	c3                   	ret    
        if (ux << 1 == uy << 1)
  226030:	75 08                	jne    22603a <fmod+0x9a>
  226032:	c5 f1 ef c9          	vpxor  xmm1,xmm1,xmm1
  226036:	c5 fb 59 c1          	vmulsd xmm0,xmm0,xmm1
  22603a:	c3                   	ret    
        i = ux << exp_bits;
  22603b:	4c 89 d0             	mov    rax,r10
  22603e:	31 c9                	xor    ecx,ecx
  226040:	48 c1 e0 0c          	shl    rax,0xc
        while (i >> bits_minus_1 == 0) : (b: {
  226044:	78 12                	js     226058 <fmod+0xb8>
  226046:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  22604d:	00 00 00 
            ex -= 1;
  226050:	83 c1 ff             	add    ecx,0xffffffff
            i <<= 1;
  226053:	48 01 c0             	add    rax,rax
        while (i >> bits_minus_1 == 0) : (b: {
  226056:	79 f8                	jns    226050 <fmod+0xb0>
        ux <<= @intCast(log2uint, @bitCast(u32, -ex + 1));
  226058:	b8 01 00 00 00       	mov    eax,0x1
  22605d:	29 c8                	sub    eax,ecx
  22605f:	c4 c2 f9 f7 c2       	shlx   rax,r10,rax
    if (ey == 0) {
  226064:	85 ff                	test   edi,edi
  226066:	75 b0                	jne    226018 <fmod+0x78>
        i = uy << exp_bits;
  226068:	4c 89 da             	mov    rdx,r11
  22606b:	31 ff                	xor    edi,edi
  22606d:	48 c1 e2 0c          	shl    rdx,0xc
        while (i >> bits_minus_1 == 0) : (b: {
  226071:	78 15                	js     226088 <fmod+0xe8>
  226073:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  22607a:	84 00 00 00 00 00 
            ey -= 1;
  226080:	83 c7 ff             	add    edi,0xffffffff
            i <<= 1;
  226083:	48 01 d2             	add    rdx,rdx
        while (i >> bits_minus_1 == 0) : (b: {
  226086:	79 f8                	jns    226080 <fmod+0xe0>
        uy <<= @intCast(log2uint, @bitCast(u32, -ey + 1));
  226088:	ba 01 00 00 00       	mov    edx,0x1
  22608d:	29 fa                	sub    edx,edi
  22608f:	c4 42 e9 f7 db       	shlx   r11,r11,rdx
  226094:	eb 10                	jmp    2260a6 <fmod+0x106>
  226096:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  22609d:	00 00 00 
        ux <<= 1;
  2260a0:	48 01 c0             	add    rax,rax
    while (ex > ey) : (ex -= 1) {
  2260a3:	83 c1 ff             	add    ecx,0xffffffff
  2260a6:	48 89 c6             	mov    rsi,rax
  2260a9:	4c 29 de             	sub    rsi,r11
  2260ac:	0f 99 c2             	setns  dl
  2260af:	39 f9                	cmp    ecx,edi
  2260b1:	7e 0f                	jle    2260c2 <fmod+0x122>
        if (i >> bits_minus_1 == 0) {
  2260b3:	f6 c2 01             	test   dl,0x1
  2260b6:	74 e8                	je     2260a0 <fmod+0x100>
  2260b8:	48 89 f0             	mov    rax,rsi
            if (i == 0)
  2260bb:	48 85 f6             	test   rsi,rsi
  2260be:	75 e0                	jne    2260a0 <fmod+0x100>
  2260c0:	eb 4d                	jmp    22610f <fmod+0x16f>
    if (i >> bits_minus_1 == 0) {
  2260c2:	84 d2                	test   dl,dl
  2260c4:	74 08                	je     2260ce <fmod+0x12e>
  2260c6:	48 89 f0             	mov    rax,rsi
        if (i == 0)
  2260c9:	48 85 f6             	test   rsi,rsi
  2260cc:	74 41                	je     22610f <fmod+0x16f>
  2260ce:	49 83 c1 01          	add    r9,0x1
    while (ux >> digits == 0) : (b: {
  2260d2:	4c 39 c0             	cmp    rax,r8
  2260d5:	73 14                	jae    2260eb <fmod+0x14b>
  2260d7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  2260de:	00 00 
        ux <<= 1;
  2260e0:	48 01 c0             	add    rax,rax
        ex -= 1;
  2260e3:	83 c1 ff             	add    ecx,0xffffffff
    while (ux >> digits == 0) : (b: {
  2260e6:	4c 39 c0             	cmp    rax,r8
  2260e9:	72 f5                	jb     2260e0 <fmod+0x140>
  2260eb:	4d 21 ca             	and    r10,r9
    if (ex > 0) {
  2260ee:	85 c9                	test   ecx,ecx
  2260f0:	7e 26                	jle    226118 <fmod+0x178>
        ux -%= 1 << digits;
  2260f2:	48 ba 00 00 00 00 00 	movabs rdx,0xfff0000000000000
  2260f9:	00 f0 ff 
  2260fc:	48 01 d0             	add    rax,rdx
        ux |= uint(@bitCast(u32, ex)) << digits;
  2260ff:	48 c1 e1 34          	shl    rcx,0x34
  226103:	48 09 c1             	or     rcx,rax
        ux |= @intCast(uint, sx) << bits_minus_1;
  226106:	4c 09 d1             	or     rcx,r10
    return @bitCast(T, ux);
  226109:	c4 e1 f9 6e c1       	vmovq  xmm0,rcx
    return generic_fmod(f64, x, y);
  22610e:	c3                   	ret    
  22610f:	c5 f1 ef c9          	vpxor  xmm1,xmm1,xmm1
  226113:	c5 fb 59 c1          	vmulsd xmm0,xmm0,xmm1
  226117:	c3                   	ret    
        ux >>= @intCast(log2uint, @bitCast(u32, -ex + 1));
  226118:	ba 01 00 00 00       	mov    edx,0x1
  22611d:	29 ca                	sub    edx,ecx
  22611f:	c4 e2 eb f7 c8       	shrx   rcx,rax,rdx
        ux |= @intCast(uint, sx) << bits_minus_1;
  226124:	4c 09 d1             	or     rcx,r10
    return @bitCast(T, ux);
  226127:	c4 e1 f9 6e c1       	vmovq  xmm0,rcx
    return generic_fmod(f64, x, y);
  22612c:	c3                   	ret    
  22612d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000226130 <floorf>:
    if (x == 0.0) {
  226130:	c5 f0 57 c9          	vxorps xmm1,xmm1,xmm1
  226134:	c5 f8 2e c1          	vucomiss xmm0,xmm1
  226138:	75 02                	jne    22613c <floorf+0xc>
  22613a:	7b 57                	jnp    226193 <floorf+0x63>
  22613c:	c5 f9 7e c1          	vmovd  ecx,xmm0
  226140:	89 c8                	mov    eax,ecx
  226142:	c1 e8 17             	shr    eax,0x17
  226145:	0f b6 d0             	movzx  edx,al
  226148:	81 fa 95 00 00 00    	cmp    edx,0x95
  22614e:	77 43                	ja     226193 <floorf+0x63>
    if (e >= 0) {
  226150:	83 fa 7f             	cmp    edx,0x7f
  226153:	72 2e                	jb     226183 <floorf+0x53>
  226155:	83 c0 01             	add    eax,0x1
        m = u32(0x007FFFFF) >> @intCast(u5, e);
  226158:	83 e0 1f             	and    eax,0x1f
  22615b:	ba ff ff 7f 00       	mov    edx,0x7fffff
  226160:	c4 e2 7b f7 d2       	shrx   edx,edx,eax
        if (u & m == 0) {
  226165:	85 ca                	test   edx,ecx
  226167:	74 2a                	je     226193 <floorf+0x63>
        if (u >> 31 != 0) {
  226169:	89 ce                	mov    esi,ecx
  22616b:	c1 fe 1f             	sar    esi,0x1f
  22616e:	21 d6                	and    esi,edx
  226170:	01 ce                	add    esi,ecx
        return @bitCast(f32, u & ~m);
  226172:	b9 00 00 80 ff       	mov    ecx,0xff800000
  226177:	c4 e2 7a f7 c1       	sarx   eax,ecx,eax
  22617c:	21 f0                	and    eax,esi
  22617e:	c5 f9 6e c0          	vmovd  xmm0,eax
    return math.floor(x);
  226182:	c3                   	ret    
        if (u >> 31 == 0) {
  226183:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  226187:	85 c9                	test   ecx,ecx
  226189:	79 08                	jns    226193 <floorf+0x63>
  22618b:	c5 f9 6e 05 a9 33 fe 	vmovd  xmm0,DWORD PTR [rip+0xfffffffffffe33a9]        # 20953c <__unnamed_59+0x16>
  226192:	ff 
  226193:	c3                   	ret    
  226194:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  22619b:	00 00 00 00 00 

00000000002261a0 <ceilf>:
    var u = @bitCast(u32, x);
    var e = @intCast(i32, (u >> 23) & 0xFF) - 0x7F;
    var m: u32 = undefined;

    // TODO: Shouldn't need this explicit check.
    if (x == 0.0) {
  2261a0:	c5 f0 57 c9          	vxorps xmm1,xmm1,xmm1
  2261a4:	c5 f8 2e c1          	vucomiss xmm0,xmm1
  2261a8:	75 02                	jne    2261ac <ceilf+0xc>
  2261aa:	7b 5a                	jnp    226206 <ceilf+0x66>
  2261ac:	c5 f9 7e c1          	vmovd  ecx,xmm0
  2261b0:	89 c8                	mov    eax,ecx
  2261b2:	c1 e8 17             	shr    eax,0x17
  2261b5:	0f b6 d0             	movzx  edx,al
  2261b8:	81 fa 95 00 00 00    	cmp    edx,0x95
  2261be:	77 46                	ja     226206 <ceilf+0x66>
        return x;
    }

    if (e >= 23) {
        return x;
    } else if (e >= 0) {
  2261c0:	83 fa 7f             	cmp    edx,0x7f
  2261c3:	72 31                	jb     2261f6 <ceilf+0x56>
  2261c5:	83 c0 01             	add    eax,0x1
        m = u32(0x007FFFFF) >> @intCast(u5, e);
  2261c8:	83 e0 1f             	and    eax,0x1f
  2261cb:	ba ff ff 7f 00       	mov    edx,0x7fffff
  2261d0:	c4 e2 7b f7 d2       	shrx   edx,edx,eax
        if (u & m == 0) {
  2261d5:	85 ca                	test   edx,ecx
  2261d7:	74 2d                	je     226206 <ceilf+0x66>
            return x;
        }
        math.forceEval(x + 0x1.0p120);
        if (u >> 31 == 0) {
  2261d9:	89 ce                	mov    esi,ecx
  2261db:	c1 fe 1f             	sar    esi,0x1f
  2261de:	c4 e2 48 f2 d2       	andn   edx,esi,edx
  2261e3:	01 ca                	add    edx,ecx
            u += m;
        }
        u &= ~m;
  2261e5:	b9 00 00 80 ff       	mov    ecx,0xff800000
  2261ea:	c4 e2 7a f7 c1       	sarx   eax,ecx,eax
  2261ef:	21 d0                	and    eax,edx
        return @bitCast(f32, u);
  2261f1:	c5 f9 6e c0          	vmovd  xmm0,eax
    return math.ceil(x);
  2261f5:	c3                   	ret    
    } else {
        math.forceEval(x + 0x1.0p120);
        if (u >> 31 != 0) {
  2261f6:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  2261fa:	85 c9                	test   ecx,ecx
  2261fc:	78 08                	js     226206 <ceilf+0x66>
  2261fe:	c5 f9 6e 05 32 33 fe 	vmovd  xmm0,DWORD PTR [rip+0xfffffffffffe3332]        # 209538 <__unnamed_59+0x12>
  226205:	ff 
  226206:	c3                   	ret    
  226207:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  22620e:	00 00 

0000000000226210 <floor>:
    if (e >= 0x3FF + 52 or x == 0) {
  226210:	c5 f1 57 c9          	vxorpd xmm1,xmm1,xmm1
  226214:	c5 f9 2e c1          	vucomisd xmm0,xmm1
  226218:	75 02                	jne    22621c <floor+0xc>
  22621a:	7b 58                	jnp    226274 <floor+0x64>
  22621c:	c4 e1 f9 7e c0       	vmovq  rax,xmm0
  226221:	b9 34 0b 00 00       	mov    ecx,0xb34
  226226:	c4 e2 f0 f7 c8       	bextr  rcx,rax,rcx
  22622b:	48 81 f9 32 04 00 00 	cmp    rcx,0x432
  226232:	77 40                	ja     226274 <floor+0x64>
        y = x - math.f64_toint + math.f64_toint - x;
  226234:	c5 fb 10 0d 5c aa fd 	vmovsd xmm1,QWORD PTR [rip+0xfffffffffffdaa5c]        # 200c98 <__unnamed_456+0x48>
  22623b:	ff 
  22623c:	c5 fb 10 15 8c aa fd 	vmovsd xmm2,QWORD PTR [rip+0xfffffffffffdaa8c]        # 200cd0 <__unnamed_456+0x80>
  226243:	ff 
    if (u >> 63 != 0) {
  226244:	48 85 c0             	test   rax,rax
  226247:	78 2c                	js     226275 <floor+0x65>
  226249:	c5 fb 58 d2          	vaddsd xmm2,xmm0,xmm2
  22624d:	c5 eb 58 c9          	vaddsd xmm1,xmm2,xmm1
    if (e <= 0x3FF - 1) {
  226251:	48 81 f9 fe 03 00 00 	cmp    rcx,0x3fe
  226258:	76 2c                	jbe    226286 <floor+0x76>
  22625a:	c5 f3 5c c8          	vsubsd xmm1,xmm1,xmm0
    } else if (y > 0) {
  22625e:	c5 e9 57 d2          	vxorpd xmm2,xmm2,xmm2
  226262:	c5 f9 2e ca          	vucomisd xmm1,xmm2
  226266:	c5 f3 58 c0          	vaddsd xmm0,xmm1,xmm0
  22626a:	76 08                	jbe    226274 <floor+0x64>
        return x + y - 1;
  22626c:	c5 fb 58 05 3c aa fd 	vaddsd xmm0,xmm0,QWORD PTR [rip+0xfffffffffffdaa3c]        # 200cb0 <__unnamed_456+0x60>
  226273:	ff 
    return math.floor(x);
  226274:	c3                   	ret    
  226275:	c5 fb 58 c9          	vaddsd xmm1,xmm0,xmm1
  226279:	c5 f3 58 ca          	vaddsd xmm1,xmm1,xmm2
    if (e <= 0x3FF - 1) {
  22627d:	48 81 f9 fe 03 00 00 	cmp    rcx,0x3fe
  226284:	77 d4                	ja     22625a <floor+0x4a>
    if (u >> 63 != 0) {
  226286:	48 85 c0             	test   rax,rax
        if (u >> 63 != 0) {
  226289:	78 05                	js     226290 <floor+0x80>
  22628b:	c5 f9 57 c0          	vxorpd xmm0,xmm0,xmm0
  22628f:	c3                   	ret    
  226290:	c5 fb 10 05 18 aa fd 	vmovsd xmm0,QWORD PTR [rip+0xfffffffffffdaa18]        # 200cb0 <__unnamed_456+0x60>
  226297:	ff 
  226298:	c3                   	ret    
  226299:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

00000000002262a0 <ceil>:
fn ceil64(x: f64) f64 {
    const u = @bitCast(u64, x);
    const e = (u >> 52) & 0x7FF;
    var y: f64 = undefined;

    if (e >= 0x3FF + 52 or x == 0) {
  2262a0:	c5 f1 57 c9          	vxorpd xmm1,xmm1,xmm1
  2262a4:	c5 f9 2e c1          	vucomisd xmm0,xmm1
  2262a8:	75 02                	jne    2262ac <ceil+0xc>
  2262aa:	7b 7d                	jnp    226329 <ceil+0x89>
  2262ac:	c4 e1 f9 7e c0       	vmovq  rax,xmm0
  2262b1:	b9 34 0b 00 00       	mov    ecx,0xb34
  2262b6:	c4 e2 f0 f7 c8       	bextr  rcx,rax,rcx
  2262bb:	48 81 f9 32 04 00 00 	cmp    rcx,0x432
  2262c2:	77 65                	ja     226329 <ceil+0x89>
        return x;
    }

    if (u >> 63 != 0) {
        y = x - math.f64_toint + math.f64_toint - x;
  2262c4:	c5 fb 10 0d cc a9 fd 	vmovsd xmm1,QWORD PTR [rip+0xfffffffffffda9cc]        # 200c98 <__unnamed_456+0x48>
  2262cb:	ff 
  2262cc:	c5 fb 10 15 fc a9 fd 	vmovsd xmm2,QWORD PTR [rip+0xfffffffffffda9fc]        # 200cd0 <__unnamed_456+0x80>
  2262d3:	ff 
    if (u >> 63 != 0) {
  2262d4:	48 85 c0             	test   rax,rax
  2262d7:	78 2d                	js     226306 <ceil+0x66>
  2262d9:	c5 fb 58 d2          	vaddsd xmm2,xmm0,xmm2
  2262dd:	c5 eb 58 c9          	vaddsd xmm1,xmm2,xmm1
    } else {
        y = x + math.f64_toint - math.f64_toint - x;
    }

    if (e <= 0x3FF - 1) {
  2262e1:	48 81 f9 fe 03 00 00 	cmp    rcx,0x3fe
  2262e8:	76 2d                	jbe    226317 <ceil+0x77>
  2262ea:	c5 f3 5c c8          	vsubsd xmm1,xmm1,xmm0
        if (u >> 63 != 0) {
            return -0.0;
        } else {
            return 1.0;
        }
    } else if (y < 0) {
  2262ee:	c5 e9 57 d2          	vxorpd xmm2,xmm2,xmm2
  2262f2:	c5 f9 2e d1          	vucomisd xmm2,xmm1
  2262f6:	c5 f3 58 c0          	vaddsd xmm0,xmm1,xmm0
  2262fa:	76 2d                	jbe    226329 <ceil+0x89>
        return x + y + 1;
  2262fc:	c5 fb 58 05 84 a9 fd 	vaddsd xmm0,xmm0,QWORD PTR [rip+0xfffffffffffda984]        # 200c88 <__unnamed_456+0x38>
  226303:	ff 
  226304:	eb 23                	jmp    226329 <ceil+0x89>
  226306:	c5 fb 58 c9          	vaddsd xmm1,xmm0,xmm1
  22630a:	c5 f3 58 ca          	vaddsd xmm1,xmm1,xmm2
    if (e <= 0x3FF - 1) {
  22630e:	48 81 f9 fe 03 00 00 	cmp    rcx,0x3fe
  226315:	77 d3                	ja     2262ea <ceil+0x4a>
        if (u >> 63 != 0) {
  226317:	c5 f9 57 c0          	vxorpd xmm0,xmm0,xmm0
    if (u >> 63 != 0) {
  22631b:	48 85 c0             	test   rax,rax
        if (u >> 63 != 0) {
  22631e:	78 09                	js     226329 <ceil+0x89>
  226320:	c5 fb 10 05 60 a9 fd 	vmovsd xmm0,QWORD PTR [rip+0xfffffffffffda960]        # 200c88 <__unnamed_456+0x38>
  226327:	ff 
    return math.ceil(x);
  226328:	c3                   	ret    
  226329:	c3                   	ret    
  22632a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000226330 <sqrt>:
// behaviour. Most intermediate i32 values are changed to u32 where appropriate but there are
// potentially some edge cases remaining that are not handled in the same way.
export fn sqrt(x: f64) f64 {
    const tiny: f64 = 1.0e-300;
    const sign: u32 = 0x80000000;
    const u = @bitCast(u64, x);
  226330:	c4 e1 f9 7e c0       	vmovq  rax,xmm0

    var ix0 = @intCast(u32, u >> 32);
  226335:	48 89 c7             	mov    rdi,rax
  226338:	48 c1 ef 20          	shr    rdi,0x20
    var ix1 = @intCast(u32, u & 0xFFFFFFFF);

    // sqrt(nan) = nan, sqrt(+inf) = +inf, sqrt(-inf) = nan
    if (ix0 & 0x7FF00000 == 0x7FF00000) {
  22633c:	b9 00 00 f0 7f       	mov    ecx,0x7ff00000
  226341:	c4 e2 40 f2 c9       	andn   ecx,edi,ecx
  226346:	75 09                	jne    226351 <sqrt+0x21>
        return x * x + x;
  226348:	c5 fb 59 c8          	vmulsd xmm1,xmm0,xmm0
  22634c:	c5 f3 58 c0          	vaddsd xmm0,xmm1,xmm0
  226350:	c3                   	ret    
    }

    // sqrt(+-0) = +-0
    if (x == 0.0) {
  226351:	c5 f0 57 c9          	vxorps xmm1,xmm1,xmm1
  226355:	c5 f9 2e c1          	vucomisd xmm0,xmm1
  226359:	75 03                	jne    22635e <sqrt+0x2e>
  22635b:	7a 01                	jp     22635e <sqrt+0x2e>
        return x;
  22635d:	c3                   	ret    
    }
    // sqrt(-ve) = snan
    if (ix0 & sign != 0) {
  22635e:	85 ff                	test   edi,edi
  226360:	0f 88 cf 00 00 00    	js     226435 <sqrt+0x105>
        return math.snan(f64);
    }

    // normalize x
    var m = @intCast(i32, ix0 >> 20);
  226366:	49 89 c0             	mov    r8,rax
  226369:	49 c1 e8 34          	shr    r8,0x34
    if (m == 0) {
  22636d:	45 85 c0             	test   r8d,r8d
  226370:	75 5b                	jne    2263cd <sqrt+0x9d>
  226372:	31 d2                	xor    edx,edx
  226374:	31 c9                	xor    ecx,ecx
        // subnormal
        while (ix0 == 0) {
  226376:	85 ff                	test   edi,edi
  226378:	75 15                	jne    22638f <sqrt+0x5f>
  22637a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
            m -= 21;
  226380:	83 c1 eb             	add    ecx,0xffffffeb
            ix0 |= ix1 >> 11;
  226383:	89 c7                	mov    edi,eax
  226385:	c1 ef 0b             	shr    edi,0xb
            ix1 <<= 21;
  226388:	c1 e0 15             	shl    eax,0x15
        while (ix0 == 0) {
  22638b:	85 ff                	test   edi,edi
  22638d:	74 f1                	je     226380 <sqrt+0x50>
  22638f:	31 f6                	xor    esi,esi
        }

        // subnormal
        var i: u32 = 0;
        while (ix0 & 0x00100000 == 0) : (i += 1) {
  226391:	0f ba e7 14          	bt     edi,0x14
  226395:	72 20                	jb     2263b7 <sqrt+0x87>
  226397:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  22639e:	00 00 
  2263a0:	89 fa                	mov    edx,edi
            ix0 <<= 1;
  2263a2:	8d 3c 12             	lea    edi,[rdx+rdx*1]
        while (ix0 & 0x00100000 == 0) : (i += 1) {
  2263a5:	83 c6 ff             	add    esi,0xffffffff
  2263a8:	f7 c2 00 00 08 00    	test   edx,0x80000
  2263ae:	74 f0                	je     2263a0 <sqrt+0x70>
  2263b0:	89 f2                	mov    edx,esi
  2263b2:	f7 da                	neg    edx
  2263b4:	83 e2 1f             	and    edx,0x1f
        }
        m -= @intCast(i32, i) - 1;
  2263b7:	44 8d 04 31          	lea    r8d,[rcx+rsi*1]
  2263bb:	41 83 c0 01          	add    r8d,0x1
        ix0 |= ix1 >> @intCast(u5, 32 - i);
  2263bf:	c4 e2 4b f7 c8       	shrx   ecx,eax,esi
  2263c4:	09 f9                	or     ecx,edi
        ix1 <<= @intCast(u5, i);
  2263c6:	c4 e2 69 f7 c0       	shlx   eax,eax,edx
  2263cb:	89 cf                	mov    edi,ecx
    }

    // unbias exponent
    m -= 1023;
  2263cd:	41 81 c0 01 fc ff ff 	add    r8d,0xfffffc01
    ix0 = (ix0 & 0x000FFFFF) | 0x00100000;
  2263d4:	81 e7 ff ff 0f 00    	and    edi,0xfffff
  2263da:	81 cf 00 00 10 00    	or     edi,0x100000
    if (m & 1 != 0) {
  2263e0:	41 f6 c0 01          	test   r8b,0x1
  2263e4:	74 06                	je     2263ec <sqrt+0xbc>
        ix0 += ix0 + (ix1 >> 31);
  2263e6:	0f a4 c7 01          	shld   edi,eax,0x1
        ix1 = ix1 +% ix1;
  2263ea:	01 c0                	add    eax,eax
    }
    m >>= 1;

    // sqrt(x) bit by bit
    ix0 += ix0 + (ix1 >> 31);
  2263ec:	0f a4 c7 01          	shld   edi,eax,0x1
    var t: u32 = undefined;
    var t1: u32 = undefined;

    while (r != 0) {
        t = s0 +% r;
        if (t <= ix0) {
  2263f0:	31 f6                	xor    esi,esi
  2263f2:	81 ff ff ff 1f 00    	cmp    edi,0x1fffff
  2263f8:	40 0f 97 c6          	seta   sil
  2263fc:	41 89 f1             	mov    r9d,esi
  2263ff:	41 c1 e1 15          	shl    r9d,0x15
  226403:	c1 e6 16             	shl    esi,0x16
            s0 = t + r;
            ix0 -= t;
            q += r;
        }
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  226406:	8d 0c 3f             	lea    ecx,[rdi+rdi*1]
        if (t <= ix0) {
  226409:	81 ff 00 00 20 00    	cmp    edi,0x200000
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  22640f:	8d bc 3f 00 00 c0 ff 	lea    edi,[rdi+rdi*1-0x400000]
  226416:	0f 42 f9             	cmovb  edi,ecx
  226419:	b9 1e 01 00 00       	mov    ecx,0x11e
  22641e:	c4 e2 70 f7 d0       	bextr  edx,eax,ecx
  226423:	09 fa                	or     edx,edi
        t = s0 +% r;
  226425:	8d be 00 00 10 00    	lea    edi,[rsi+0x100000]
        if (t <= ix0) {
  22642b:	89 d1                	mov    ecx,edx
  22642d:	29 f9                	sub    ecx,edi
  22642f:	73 0d                	jae    22643e <sqrt+0x10e>
  226431:	89 d1                	mov    ecx,edx
  226433:	eb 18                	jmp    22644d <sqrt+0x11d>
  226435:	c5 fb 10 05 d3 a8 fd 	vmovsd xmm0,QWORD PTR [rip+0xfffffffffffda8d3]        # 200d10 <app_mask+0x30>
  22643c:	ff 
        return x;
  22643d:	c3                   	ret    
            s0 = t + r;
  22643e:	81 c7 00 00 10 00    	add    edi,0x100000
            q += r;
  226444:	41 81 c9 00 00 10 00 	or     r9d,0x100000
  22644b:	89 fe                	mov    esi,edi
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  22644d:	ba 1d 01 00 00       	mov    edx,0x11d
  226452:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  226457:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  22645a:	8d be 00 00 08 00    	lea    edi,[rsi+0x80000]
        if (t <= ix0) {
  226460:	89 d1                	mov    ecx,edx
  226462:	29 f9                	sub    ecx,edi
  226464:	73 04                	jae    22646a <sqrt+0x13a>
  226466:	89 d1                	mov    ecx,edx
  226468:	eb 0d                	jmp    226477 <sqrt+0x147>
            s0 = t + r;
  22646a:	81 c6 00 00 10 00    	add    esi,0x100000
            q += r;
  226470:	41 81 c1 00 00 08 00 	add    r9d,0x80000
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  226477:	ba 1c 01 00 00       	mov    edx,0x11c
  22647c:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  226481:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  226484:	8d be 00 00 04 00    	lea    edi,[rsi+0x40000]
        if (t <= ix0) {
  22648a:	89 d1                	mov    ecx,edx
  22648c:	29 f9                	sub    ecx,edi
  22648e:	73 04                	jae    226494 <sqrt+0x164>
  226490:	89 d1                	mov    ecx,edx
  226492:	eb 0d                	jmp    2264a1 <sqrt+0x171>
            s0 = t + r;
  226494:	81 c6 00 00 08 00    	add    esi,0x80000
            q += r;
  22649a:	41 81 c1 00 00 04 00 	add    r9d,0x40000
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  2264a1:	ba 1b 01 00 00       	mov    edx,0x11b
  2264a6:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  2264ab:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  2264ae:	8d be 00 00 02 00    	lea    edi,[rsi+0x20000]
        if (t <= ix0) {
  2264b4:	89 d1                	mov    ecx,edx
  2264b6:	29 f9                	sub    ecx,edi
  2264b8:	73 04                	jae    2264be <sqrt+0x18e>
  2264ba:	89 d1                	mov    ecx,edx
  2264bc:	eb 0d                	jmp    2264cb <sqrt+0x19b>
            s0 = t + r;
  2264be:	81 c6 00 00 04 00    	add    esi,0x40000
            q += r;
  2264c4:	41 81 c1 00 00 02 00 	add    r9d,0x20000
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  2264cb:	ba 1a 01 00 00       	mov    edx,0x11a
  2264d0:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  2264d5:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  2264d8:	8d be 00 00 01 00    	lea    edi,[rsi+0x10000]
        if (t <= ix0) {
  2264de:	89 d1                	mov    ecx,edx
  2264e0:	29 f9                	sub    ecx,edi
  2264e2:	73 04                	jae    2264e8 <sqrt+0x1b8>
  2264e4:	89 d1                	mov    ecx,edx
  2264e6:	eb 0d                	jmp    2264f5 <sqrt+0x1c5>
            s0 = t + r;
  2264e8:	81 c6 00 00 02 00    	add    esi,0x20000
            q += r;
  2264ee:	41 81 c1 00 00 01 00 	add    r9d,0x10000
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  2264f5:	ba 19 01 00 00       	mov    edx,0x119
  2264fa:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  2264ff:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  226502:	8d be 00 80 00 00    	lea    edi,[rsi+0x8000]
        if (t <= ix0) {
  226508:	89 d1                	mov    ecx,edx
  22650a:	29 f9                	sub    ecx,edi
  22650c:	73 04                	jae    226512 <sqrt+0x1e2>
  22650e:	89 d1                	mov    ecx,edx
  226510:	eb 0d                	jmp    22651f <sqrt+0x1ef>
            s0 = t + r;
  226512:	81 c6 00 00 01 00    	add    esi,0x10000
            q += r;
  226518:	41 81 c1 00 80 00 00 	add    r9d,0x8000
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  22651f:	ba 18 01 00 00       	mov    edx,0x118
  226524:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  226529:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  22652c:	8d be 00 40 00 00    	lea    edi,[rsi+0x4000]
        if (t <= ix0) {
  226532:	89 d1                	mov    ecx,edx
  226534:	29 f9                	sub    ecx,edi
  226536:	73 04                	jae    22653c <sqrt+0x20c>
  226538:	89 d1                	mov    ecx,edx
  22653a:	eb 0d                	jmp    226549 <sqrt+0x219>
            s0 = t + r;
  22653c:	81 c6 00 80 00 00    	add    esi,0x8000
            q += r;
  226542:	41 81 c1 00 40 00 00 	add    r9d,0x4000
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  226549:	ba 17 01 00 00       	mov    edx,0x117
  22654e:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  226553:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  226556:	8d be 00 20 00 00    	lea    edi,[rsi+0x2000]
        if (t <= ix0) {
  22655c:	89 d1                	mov    ecx,edx
  22655e:	29 f9                	sub    ecx,edi
  226560:	73 04                	jae    226566 <sqrt+0x236>
  226562:	89 d1                	mov    ecx,edx
  226564:	eb 0d                	jmp    226573 <sqrt+0x243>
            s0 = t + r;
  226566:	81 c6 00 40 00 00    	add    esi,0x4000
            q += r;
  22656c:	41 81 c1 00 20 00 00 	add    r9d,0x2000
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  226573:	ba 16 01 00 00       	mov    edx,0x116
  226578:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  22657d:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  226580:	8d be 00 10 00 00    	lea    edi,[rsi+0x1000]
        if (t <= ix0) {
  226586:	89 d1                	mov    ecx,edx
  226588:	29 f9                	sub    ecx,edi
  22658a:	73 04                	jae    226590 <sqrt+0x260>
  22658c:	89 d1                	mov    ecx,edx
  22658e:	eb 0d                	jmp    22659d <sqrt+0x26d>
            s0 = t + r;
  226590:	81 c6 00 20 00 00    	add    esi,0x2000
            q += r;
  226596:	41 81 c1 00 10 00 00 	add    r9d,0x1000
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  22659d:	ba 15 01 00 00       	mov    edx,0x115
  2265a2:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  2265a7:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  2265aa:	8d be 00 08 00 00    	lea    edi,[rsi+0x800]
        if (t <= ix0) {
  2265b0:	89 d1                	mov    ecx,edx
  2265b2:	29 f9                	sub    ecx,edi
  2265b4:	73 04                	jae    2265ba <sqrt+0x28a>
  2265b6:	89 d1                	mov    ecx,edx
  2265b8:	eb 0d                	jmp    2265c7 <sqrt+0x297>
            s0 = t + r;
  2265ba:	81 c6 00 10 00 00    	add    esi,0x1000
            q += r;
  2265c0:	41 81 c1 00 08 00 00 	add    r9d,0x800
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  2265c7:	ba 14 01 00 00       	mov    edx,0x114
  2265cc:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  2265d1:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  2265d4:	8d be 00 04 00 00    	lea    edi,[rsi+0x400]
        if (t <= ix0) {
  2265da:	89 d1                	mov    ecx,edx
  2265dc:	29 f9                	sub    ecx,edi
  2265de:	73 04                	jae    2265e4 <sqrt+0x2b4>
  2265e0:	89 d1                	mov    ecx,edx
  2265e2:	eb 0d                	jmp    2265f1 <sqrt+0x2c1>
            s0 = t + r;
  2265e4:	81 c6 00 08 00 00    	add    esi,0x800
            q += r;
  2265ea:	41 81 c1 00 04 00 00 	add    r9d,0x400
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  2265f1:	ba 13 01 00 00       	mov    edx,0x113
  2265f6:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  2265fb:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  2265fe:	8d be 00 02 00 00    	lea    edi,[rsi+0x200]
        if (t <= ix0) {
  226604:	89 d1                	mov    ecx,edx
  226606:	29 f9                	sub    ecx,edi
  226608:	73 04                	jae    22660e <sqrt+0x2de>
  22660a:	89 d1                	mov    ecx,edx
  22660c:	eb 0d                	jmp    22661b <sqrt+0x2eb>
            s0 = t + r;
  22660e:	81 c6 00 04 00 00    	add    esi,0x400
            q += r;
  226614:	41 81 c1 00 02 00 00 	add    r9d,0x200
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  22661b:	ba 12 01 00 00       	mov    edx,0x112
  226620:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  226625:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  226628:	8d be 00 01 00 00    	lea    edi,[rsi+0x100]
        if (t <= ix0) {
  22662e:	89 d1                	mov    ecx,edx
  226630:	29 f9                	sub    ecx,edi
  226632:	73 04                	jae    226638 <sqrt+0x308>
  226634:	89 d1                	mov    ecx,edx
  226636:	eb 0d                	jmp    226645 <sqrt+0x315>
            s0 = t + r;
  226638:	81 c6 00 02 00 00    	add    esi,0x200
            q += r;
  22663e:	41 81 c1 00 01 00 00 	add    r9d,0x100
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  226645:	ba 11 01 00 00       	mov    edx,0x111
  22664a:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  22664f:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  226652:	89 f7                	mov    edi,esi
  226654:	83 ef 80             	sub    edi,0xffffff80
        if (t <= ix0) {
  226657:	89 d1                	mov    ecx,edx
  226659:	29 f9                	sub    ecx,edi
  22665b:	73 04                	jae    226661 <sqrt+0x331>
  22665d:	89 d1                	mov    ecx,edx
  22665f:	eb 0a                	jmp    22666b <sqrt+0x33b>
            s0 = t + r;
  226661:	81 c6 00 01 00 00    	add    esi,0x100
            q += r;
  226667:	41 83 e9 80          	sub    r9d,0xffffff80
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  22666b:	ba 10 01 00 00       	mov    edx,0x110
  226670:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  226675:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  226678:	8d 7e 40             	lea    edi,[rsi+0x40]
        if (t <= ix0) {
  22667b:	89 d1                	mov    ecx,edx
  22667d:	29 f9                	sub    ecx,edi
  22667f:	73 04                	jae    226685 <sqrt+0x355>
  226681:	89 d1                	mov    ecx,edx
  226683:	eb 07                	jmp    22668c <sqrt+0x35c>
            s0 = t + r;
  226685:	83 ee 80             	sub    esi,0xffffff80
            q += r;
  226688:	41 83 c1 40          	add    r9d,0x40
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  22668c:	ba 0f 01 00 00       	mov    edx,0x10f
  226691:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  226696:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  226699:	8d 7e 20             	lea    edi,[rsi+0x20]
        if (t <= ix0) {
  22669c:	89 d1                	mov    ecx,edx
  22669e:	29 f9                	sub    ecx,edi
  2266a0:	73 04                	jae    2266a6 <sqrt+0x376>
  2266a2:	89 d1                	mov    ecx,edx
  2266a4:	eb 07                	jmp    2266ad <sqrt+0x37d>
            s0 = t + r;
  2266a6:	83 c6 40             	add    esi,0x40
            q += r;
  2266a9:	41 83 c1 20          	add    r9d,0x20
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  2266ad:	ba 0e 01 00 00       	mov    edx,0x10e
  2266b2:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  2266b7:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  2266ba:	8d 7e 10             	lea    edi,[rsi+0x10]
        if (t <= ix0) {
  2266bd:	89 d1                	mov    ecx,edx
  2266bf:	29 f9                	sub    ecx,edi
  2266c1:	73 04                	jae    2266c7 <sqrt+0x397>
  2266c3:	89 d1                	mov    ecx,edx
  2266c5:	eb 07                	jmp    2266ce <sqrt+0x39e>
            s0 = t + r;
  2266c7:	83 c6 20             	add    esi,0x20
            q += r;
  2266ca:	41 83 c1 10          	add    r9d,0x10
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  2266ce:	ba 0d 01 00 00       	mov    edx,0x10d
  2266d3:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  2266d8:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  2266db:	8d 7e 08             	lea    edi,[rsi+0x8]
        if (t <= ix0) {
  2266de:	89 d1                	mov    ecx,edx
  2266e0:	29 f9                	sub    ecx,edi
  2266e2:	73 04                	jae    2266e8 <sqrt+0x3b8>
  2266e4:	89 d1                	mov    ecx,edx
  2266e6:	eb 07                	jmp    2266ef <sqrt+0x3bf>
            s0 = t + r;
  2266e8:	83 c6 10             	add    esi,0x10
            q += r;
  2266eb:	41 83 c1 08          	add    r9d,0x8
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  2266ef:	ba 0c 01 00 00       	mov    edx,0x10c
  2266f4:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  2266f9:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  2266fc:	8d 7e 04             	lea    edi,[rsi+0x4]
        if (t <= ix0) {
  2266ff:	89 d1                	mov    ecx,edx
  226701:	29 f9                	sub    ecx,edi
  226703:	73 04                	jae    226709 <sqrt+0x3d9>
  226705:	89 d1                	mov    ecx,edx
  226707:	eb 07                	jmp    226710 <sqrt+0x3e0>
            s0 = t + r;
  226709:	83 c6 08             	add    esi,0x8
            q += r;
  22670c:	41 83 c1 04          	add    r9d,0x4
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  226710:	ba 0b 01 00 00       	mov    edx,0x10b
  226715:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  22671a:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  22671d:	8d 7e 02             	lea    edi,[rsi+0x2]
        if (t <= ix0) {
  226720:	89 d1                	mov    ecx,edx
  226722:	29 f9                	sub    ecx,edi
  226724:	73 04                	jae    22672a <sqrt+0x3fa>
  226726:	89 d1                	mov    ecx,edx
  226728:	eb 07                	jmp    226731 <sqrt+0x401>
            s0 = t + r;
  22672a:	83 c6 04             	add    esi,0x4
            q += r;
  22672d:	41 83 c1 02          	add    r9d,0x2
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  226731:	ba 0a 01 00 00       	mov    edx,0x10a
  226736:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  22673b:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  22673e:	8d 7e 01             	lea    edi,[rsi+0x1]
        if (t <= ix0) {
  226741:	89 d1                	mov    ecx,edx
  226743:	29 f9                	sub    ecx,edi
  226745:	73 04                	jae    22674b <sqrt+0x41b>
  226747:	89 d1                	mov    ecx,edx
  226749:	eb 07                	jmp    226752 <sqrt+0x422>
            s0 = t + r;
  22674b:	83 c6 02             	add    esi,0x2
            q += r;
  22674e:	41 83 c1 01          	add    r9d,0x1
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  226752:	55                   	push   rbp
  226753:	41 56                	push   r14
  226755:	53                   	push   rbx
  226756:	ba 09 01 00 00       	mov    edx,0x109
  22675b:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  226760:	c1 e0 17             	shl    eax,0x17
  226763:	8d 1c 4a             	lea    ebx,[rdx+rcx*2]
    m >>= 1;
  226766:	41 d1 e8             	shr    r8d,1
  226769:	31 d2                	xor    edx,edx
  22676b:	bf 00 00 00 80       	mov    edi,0x80000000
  226770:	41 ba 1e 01 00 00    	mov    r10d,0x11e
  226776:	41 bb 1d 01 00 00    	mov    r11d,0x11d
  22677c:	41 be 1c 01 00 00    	mov    r14d,0x11c
  226782:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  226789:	1f 84 00 00 00 00 00 

    r = sign;
    while (r != 0) {
        t = s1 +% r;
        t = s0;
        if (t < ix0 or (t == ix0 and t1 <= ix1)) {
  226790:	89 fd                	mov    ebp,edi
  226792:	89 f1                	mov    ecx,esi
  226794:	39 f3                	cmp    ebx,esi
  226796:	73 04                	jae    22679c <sqrt+0x46c>
  226798:	31 ed                	xor    ebp,ebp
  22679a:	31 c9                	xor    ecx,ecx
  22679c:	01 d5                	add    ebp,edx
  22679e:	29 cb                	sub    ebx,ecx
                ix0 -= 1;
            }
            ix1 = ix1 -% t1;
            q1 += r;
        }
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  2267a0:	0f a4 c3 01          	shld   ebx,eax,0x1
        if (t < ix0 or (t == ix0 and t1 <= ix1)) {
  2267a4:	39 f3                	cmp    ebx,esi
  2267a6:	73 08                	jae    2267b0 <sqrt+0x480>
  2267a8:	31 d2                	xor    edx,edx
  2267aa:	31 c9                	xor    ecx,ecx
  2267ac:	eb 08                	jmp    2267b6 <sqrt+0x486>
  2267ae:	66 90                	xchg   ax,ax
  2267b0:	89 fa                	mov    edx,edi
  2267b2:	d1 ea                	shr    edx,1
  2267b4:	89 f1                	mov    ecx,esi
  2267b6:	01 ea                	add    edx,ebp
  2267b8:	29 cb                	sub    ebx,ecx
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  2267ba:	c4 e2 28 f7 c8       	bextr  ecx,eax,r10d
  2267bf:	8d 2c 59             	lea    ebp,[rcx+rbx*2]
        if (t < ix0 or (t == ix0 and t1 <= ix1)) {
  2267c2:	39 f5                	cmp    ebp,esi
  2267c4:	73 0a                	jae    2267d0 <sqrt+0x4a0>
  2267c6:	31 db                	xor    ebx,ebx
  2267c8:	31 c9                	xor    ecx,ecx
  2267ca:	eb 0b                	jmp    2267d7 <sqrt+0x4a7>
  2267cc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  2267d0:	89 fb                	mov    ebx,edi
  2267d2:	c1 eb 02             	shr    ebx,0x2
  2267d5:	89 f1                	mov    ecx,esi
  2267d7:	01 d3                	add    ebx,edx
  2267d9:	29 cd                	sub    ebp,ecx
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  2267db:	c4 e2 20 f7 c8       	bextr  ecx,eax,r11d
  2267e0:	8d 2c 69             	lea    ebp,[rcx+rbp*2]
        if (t < ix0 or (t == ix0 and t1 <= ix1)) {
  2267e3:	39 f5                	cmp    ebp,esi
  2267e5:	73 09                	jae    2267f0 <sqrt+0x4c0>
  2267e7:	31 d2                	xor    edx,edx
  2267e9:	31 c9                	xor    ecx,ecx
  2267eb:	eb 0a                	jmp    2267f7 <sqrt+0x4c7>
  2267ed:	0f 1f 00             	nop    DWORD PTR [rax]
  2267f0:	89 fa                	mov    edx,edi
  2267f2:	c1 ea 03             	shr    edx,0x3
  2267f5:	89 f1                	mov    ecx,esi
  2267f7:	01 da                	add    edx,ebx
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  2267f9:	c4 e2 08 f7 d8       	bextr  ebx,eax,r14d
        if (t < ix0 or (t == ix0 and t1 <= ix1)) {
  2267fe:	29 cd                	sub    ebp,ecx
  226800:	c1 e0 04             	shl    eax,0x4
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  226803:	8d 1c 6b             	lea    ebx,[rbx+rbp*2]
        ix1 = ix1 +% ix1;
        r >>= 1;
  226806:	c1 ef 04             	shr    edi,0x4
    while (r != 0) {
  226809:	75 85                	jne    226790 <sqrt+0x460>
    }

    // rounding direction
    if (ix0 | ix1 != 0) {
  22680b:	09 c3                	or     ebx,eax
  22680d:	5b                   	pop    rbx
  22680e:	41 5e                	pop    r14
  226810:	5d                   	pop    rbp
  226811:	74 16                	je     226829 <sqrt+0x4f9>
        var z = 1.0 - tiny; // raise inexact
        if (z >= 1.0) {
            z = 1.0 + tiny;
            if (q1 == 0xFFFFFFFF) {
  226813:	83 fa ff             	cmp    edx,0xffffffff
  226816:	74 0b                	je     226823 <sqrt+0x4f3>
                if (q1 == 0xFFFFFFFE) {
                    q += 1;
                }
                q1 += 2;
            } else {
                q1 += q1 & 1;
  226818:	89 d0                	mov    eax,edx
  22681a:	83 e0 01             	and    eax,0x1
  22681d:	01 d0                	add    eax,edx
  22681f:	89 c2                	mov    edx,eax
  226821:	eb 06                	jmp    226829 <sqrt+0x4f9>
                q += 1;
  226823:	41 83 c1 01          	add    r9d,0x1
  226827:	31 d2                	xor    edx,edx
            }
        }
    }

    ix0 = (q >> 1) + 0x3FE00000;
  226829:	44 89 c8             	mov    eax,r9d
  22682c:	d1 e8                	shr    eax,1
    ix1 = q1 >> 1;
    if (q & 1 != 0) {
  22682e:	44 0f ac ca 01       	shrd   edx,r9d,0x1
    }

    // NOTE: musl here appears to rely on signed twos-complement wraparound. +% has the same
    // behaviour at least.
    var iix0 = @intCast(i32, ix0);
    iix0 = iix0 +% (m << 20);
  226833:	41 c1 e0 14          	shl    r8d,0x14
  226837:	41 8d 04 00          	lea    eax,[r8+rax*1]
  22683b:	05 00 00 e0 3f       	add    eax,0x3fe00000

    const uz = (@intCast(u64, iix0) << 32) | ix1;
  226840:	48 c1 e0 20          	shl    rax,0x20
  226844:	48 09 c2             	or     rdx,rax
    return @bitCast(f64, uz);
  226847:	c4 e1 f9 6e c2       	vmovq  xmm0,rdx
  22684c:	c3                   	ret    
  22684d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000226850 <sqrtf>:
}

export fn sqrtf(x: f32) f32 {
    const tiny: f32 = 1.0e-30;
    const sign: i32 = @bitCast(i32, u32(0x80000000));
    var ix: i32 = @bitCast(i32, x);
  226850:	c5 f9 7e c1          	vmovd  ecx,xmm0

    if ((ix & 0x7F800000) == 0x7F800000) {
  226854:	b8 00 00 80 7f       	mov    eax,0x7f800000
  226859:	c4 e2 70 f2 c0       	andn   eax,ecx,eax
  22685e:	75 09                	jne    226869 <sqrtf+0x19>
        return x * x + x; // sqrt(nan) = nan, sqrt(+inf) = +inf, sqrt(-inf) = snan
  226860:	c5 fa 59 c8          	vmulss xmm1,xmm0,xmm0
  226864:	c5 f2 58 c0          	vaddss xmm0,xmm1,xmm0
  226868:	c3                   	ret    
    }

    // zero
    if (ix <= 0) {
  226869:	85 c9                	test   ecx,ecx
  22686b:	7e 15                	jle    226882 <sqrtf+0x32>
  22686d:	41 89 c8             	mov    r8d,ecx
  226870:	41 c1 e8 17          	shr    r8d,0x17
        }
    }

    // normalize
    var m = ix >> 23;
    if (m == 0) {
  226874:	75 45                	jne    2268bb <sqrtf+0x6b>
  226876:	31 d2                	xor    edx,edx
        // subnormal
        var i: i32 = 0;
        while (ix & 0x00800000 == 0) : (i += 1) {
  226878:	0f ba e1 17          	bt     ecx,0x17
  22687c:	73 18                	jae    226896 <sqrtf+0x46>
  22687e:	89 ce                	mov    esi,ecx
  226880:	eb 2e                	jmp    2268b0 <sqrtf+0x60>
        if (ix & ~sign == 0) {
  226882:	f7 c1 ff ff ff 7f    	test   ecx,0x7fffffff
  226888:	0f 84 26 03 00 00    	je     226bb4 <sqrtf+0x364>
        if (ix < 0) {
  22688e:	85 c9                	test   ecx,ecx
  226890:	0f 88 16 03 00 00    	js     226bac <sqrtf+0x35c>
  226896:	31 d2                	xor    edx,edx
  226898:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  22689f:	00 
            ix <<= 1;
  2268a0:	8d 34 09             	lea    esi,[rcx+rcx*1]
        while (ix & 0x00800000 == 0) : (i += 1) {
  2268a3:	83 c2 01             	add    edx,0x1
  2268a6:	f7 c1 00 00 40 00    	test   ecx,0x400000
  2268ac:	89 f1                	mov    ecx,esi
  2268ae:	74 f0                	je     2268a0 <sqrtf+0x50>
        }
        m -= i - 1;
  2268b0:	41 b8 01 00 00 00    	mov    r8d,0x1
  2268b6:	41 29 d0             	sub    r8d,edx
  2268b9:	89 f1                	mov    ecx,esi
    }

    m -= 127; // unbias exponent
  2268bb:	41 83 c0 81          	add    r8d,0xffffff81
    ix = (ix & 0x007FFFFF) | 0x00800000;
  2268bf:	81 e1 ff ff 7f 00    	and    ecx,0x7fffff
  2268c5:	81 c9 00 00 80 00    	or     ecx,0x800000

    if (m & 1 != 0) { // odd m, double x to even
  2268cb:	44 89 c0             	mov    eax,r8d
  2268ce:	24 01                	and    al,0x1
  2268d0:	c4 e2 79 f7 c1       	shlx   eax,ecx,eax
  2268d5:	8d 34 85 00 00 00 00 	lea    esi,[rax*4+0x0]
    var s: i32 = 0;
    var r: i32 = 0x01000000; // r = moving bit right -> left

    while (r != 0) {
        const t = s + r;
        if (t <= ix) {
  2268dc:	31 d2                	xor    edx,edx
  2268de:	3d ff ff 7f 00       	cmp    eax,0x7fffff
  2268e3:	0f 9f c2             	setg   dl
  2268e6:	89 d1                	mov    ecx,edx
  2268e8:	c1 e1 18             	shl    ecx,0x18
  2268eb:	c1 e2 19             	shl    edx,0x19
  2268ee:	3d 00 00 80 00       	cmp    eax,0x800000
  2268f3:	8d 3c 85 00 00 00 fe 	lea    edi,[rax*4-0x2000000]
  2268fa:	0f 4c fe             	cmovl  edi,esi
        const t = s + r;
  2268fd:	8d 82 00 00 80 00    	lea    eax,[rdx+0x800000]
        if (t <= ix) {
  226903:	89 fe                	mov    esi,edi
  226905:	29 c6                	sub    esi,eax
  226907:	7d 04                	jge    22690d <sqrtf+0xbd>
  226909:	89 fe                	mov    esi,edi
  22690b:	eb 0d                	jmp    22691a <sqrtf+0xca>
            s = t + r;
  22690d:	05 00 00 80 00       	add    eax,0x800000
            ix -= t;
            q += r;
  226912:	81 c9 00 00 80 00    	or     ecx,0x800000
  226918:	89 c2                	mov    edx,eax
  22691a:	01 f6                	add    esi,esi
        const t = s + r;
  22691c:	8d 82 00 00 40 00    	lea    eax,[rdx+0x400000]
        if (t <= ix) {
  226922:	89 f7                	mov    edi,esi
  226924:	29 c7                	sub    edi,eax
  226926:	7d 04                	jge    22692c <sqrtf+0xdc>
  226928:	89 f7                	mov    edi,esi
  22692a:	eb 0c                	jmp    226938 <sqrtf+0xe8>
            s = t + r;
  22692c:	81 c2 00 00 80 00    	add    edx,0x800000
            q += r;
  226932:	81 c1 00 00 40 00    	add    ecx,0x400000
  226938:	01 ff                	add    edi,edi
        const t = s + r;
  22693a:	8d 82 00 00 20 00    	lea    eax,[rdx+0x200000]
        if (t <= ix) {
  226940:	89 fe                	mov    esi,edi
  226942:	29 c6                	sub    esi,eax
  226944:	7d 04                	jge    22694a <sqrtf+0xfa>
  226946:	89 fe                	mov    esi,edi
  226948:	eb 0c                	jmp    226956 <sqrtf+0x106>
            s = t + r;
  22694a:	81 c2 00 00 40 00    	add    edx,0x400000
            q += r;
  226950:	81 c1 00 00 20 00    	add    ecx,0x200000
  226956:	01 f6                	add    esi,esi
        const t = s + r;
  226958:	8d 82 00 00 10 00    	lea    eax,[rdx+0x100000]
        if (t <= ix) {
  22695e:	89 f7                	mov    edi,esi
  226960:	29 c7                	sub    edi,eax
  226962:	7d 04                	jge    226968 <sqrtf+0x118>
  226964:	89 f7                	mov    edi,esi
  226966:	eb 0c                	jmp    226974 <sqrtf+0x124>
            s = t + r;
  226968:	81 c2 00 00 20 00    	add    edx,0x200000
            q += r;
  22696e:	81 c1 00 00 10 00    	add    ecx,0x100000
  226974:	01 ff                	add    edi,edi
        const t = s + r;
  226976:	8d 82 00 00 08 00    	lea    eax,[rdx+0x80000]
        if (t <= ix) {
  22697c:	89 fe                	mov    esi,edi
  22697e:	29 c6                	sub    esi,eax
  226980:	7d 04                	jge    226986 <sqrtf+0x136>
  226982:	89 fe                	mov    esi,edi
  226984:	eb 0c                	jmp    226992 <sqrtf+0x142>
            s = t + r;
  226986:	81 c2 00 00 10 00    	add    edx,0x100000
            q += r;
  22698c:	81 c1 00 00 08 00    	add    ecx,0x80000
  226992:	01 f6                	add    esi,esi
        const t = s + r;
  226994:	8d 82 00 00 04 00    	lea    eax,[rdx+0x40000]
        if (t <= ix) {
  22699a:	89 f7                	mov    edi,esi
  22699c:	29 c7                	sub    edi,eax
  22699e:	7d 04                	jge    2269a4 <sqrtf+0x154>
  2269a0:	89 f7                	mov    edi,esi
  2269a2:	eb 0c                	jmp    2269b0 <sqrtf+0x160>
            s = t + r;
  2269a4:	81 c2 00 00 08 00    	add    edx,0x80000
            q += r;
  2269aa:	81 c1 00 00 04 00    	add    ecx,0x40000
  2269b0:	01 ff                	add    edi,edi
        const t = s + r;
  2269b2:	8d 82 00 00 02 00    	lea    eax,[rdx+0x20000]
        if (t <= ix) {
  2269b8:	89 fe                	mov    esi,edi
  2269ba:	29 c6                	sub    esi,eax
  2269bc:	7d 04                	jge    2269c2 <sqrtf+0x172>
  2269be:	89 fe                	mov    esi,edi
  2269c0:	eb 0c                	jmp    2269ce <sqrtf+0x17e>
            s = t + r;
  2269c2:	81 c2 00 00 04 00    	add    edx,0x40000
            q += r;
  2269c8:	81 c1 00 00 02 00    	add    ecx,0x20000
  2269ce:	01 f6                	add    esi,esi
        const t = s + r;
  2269d0:	8d 82 00 00 01 00    	lea    eax,[rdx+0x10000]
        if (t <= ix) {
  2269d6:	89 f7                	mov    edi,esi
  2269d8:	29 c7                	sub    edi,eax
  2269da:	7d 04                	jge    2269e0 <sqrtf+0x190>
  2269dc:	89 f7                	mov    edi,esi
  2269de:	eb 0c                	jmp    2269ec <sqrtf+0x19c>
            s = t + r;
  2269e0:	81 c2 00 00 02 00    	add    edx,0x20000
            q += r;
  2269e6:	81 c1 00 00 01 00    	add    ecx,0x10000
  2269ec:	01 ff                	add    edi,edi
        const t = s + r;
  2269ee:	8d 82 00 80 00 00    	lea    eax,[rdx+0x8000]
        if (t <= ix) {
  2269f4:	89 fe                	mov    esi,edi
  2269f6:	29 c6                	sub    esi,eax
  2269f8:	7d 04                	jge    2269fe <sqrtf+0x1ae>
  2269fa:	89 fe                	mov    esi,edi
  2269fc:	eb 0c                	jmp    226a0a <sqrtf+0x1ba>
            s = t + r;
  2269fe:	81 c2 00 00 01 00    	add    edx,0x10000
            q += r;
  226a04:	81 c1 00 80 00 00    	add    ecx,0x8000
  226a0a:	01 f6                	add    esi,esi
        const t = s + r;
  226a0c:	8d 82 00 40 00 00    	lea    eax,[rdx+0x4000]
        if (t <= ix) {
  226a12:	89 f7                	mov    edi,esi
  226a14:	29 c7                	sub    edi,eax
  226a16:	7d 04                	jge    226a1c <sqrtf+0x1cc>
  226a18:	89 f7                	mov    edi,esi
  226a1a:	eb 0c                	jmp    226a28 <sqrtf+0x1d8>
            s = t + r;
  226a1c:	81 c2 00 80 00 00    	add    edx,0x8000
            q += r;
  226a22:	81 c1 00 40 00 00    	add    ecx,0x4000
  226a28:	01 ff                	add    edi,edi
        const t = s + r;
  226a2a:	8d 82 00 20 00 00    	lea    eax,[rdx+0x2000]
        if (t <= ix) {
  226a30:	89 fe                	mov    esi,edi
  226a32:	29 c6                	sub    esi,eax
  226a34:	7d 04                	jge    226a3a <sqrtf+0x1ea>
  226a36:	89 fe                	mov    esi,edi
  226a38:	eb 0c                	jmp    226a46 <sqrtf+0x1f6>
            s = t + r;
  226a3a:	81 c2 00 40 00 00    	add    edx,0x4000
            q += r;
  226a40:	81 c1 00 20 00 00    	add    ecx,0x2000
  226a46:	01 f6                	add    esi,esi
        const t = s + r;
  226a48:	8d 82 00 10 00 00    	lea    eax,[rdx+0x1000]
        if (t <= ix) {
  226a4e:	89 f7                	mov    edi,esi
  226a50:	29 c7                	sub    edi,eax
  226a52:	7d 04                	jge    226a58 <sqrtf+0x208>
  226a54:	89 f7                	mov    edi,esi
  226a56:	eb 0c                	jmp    226a64 <sqrtf+0x214>
            s = t + r;
  226a58:	81 c2 00 20 00 00    	add    edx,0x2000
            q += r;
  226a5e:	81 c1 00 10 00 00    	add    ecx,0x1000
  226a64:	01 ff                	add    edi,edi
        const t = s + r;
  226a66:	8d 82 00 08 00 00    	lea    eax,[rdx+0x800]
        if (t <= ix) {
  226a6c:	89 fe                	mov    esi,edi
  226a6e:	29 c6                	sub    esi,eax
  226a70:	7d 04                	jge    226a76 <sqrtf+0x226>
  226a72:	89 fe                	mov    esi,edi
  226a74:	eb 0c                	jmp    226a82 <sqrtf+0x232>
            s = t + r;
  226a76:	81 c2 00 10 00 00    	add    edx,0x1000
            q += r;
  226a7c:	81 c1 00 08 00 00    	add    ecx,0x800
  226a82:	01 f6                	add    esi,esi
        const t = s + r;
  226a84:	8d 82 00 04 00 00    	lea    eax,[rdx+0x400]
        if (t <= ix) {
  226a8a:	89 f7                	mov    edi,esi
  226a8c:	29 c7                	sub    edi,eax
  226a8e:	7d 04                	jge    226a94 <sqrtf+0x244>
  226a90:	89 f7                	mov    edi,esi
  226a92:	eb 0c                	jmp    226aa0 <sqrtf+0x250>
            s = t + r;
  226a94:	81 c2 00 08 00 00    	add    edx,0x800
            q += r;
  226a9a:	81 c1 00 04 00 00    	add    ecx,0x400
  226aa0:	01 ff                	add    edi,edi
        const t = s + r;
  226aa2:	8d 82 00 02 00 00    	lea    eax,[rdx+0x200]
        if (t <= ix) {
  226aa8:	89 fe                	mov    esi,edi
  226aaa:	29 c6                	sub    esi,eax
  226aac:	7d 04                	jge    226ab2 <sqrtf+0x262>
  226aae:	89 fe                	mov    esi,edi
  226ab0:	eb 0c                	jmp    226abe <sqrtf+0x26e>
            s = t + r;
  226ab2:	81 c2 00 04 00 00    	add    edx,0x400
            q += r;
  226ab8:	81 c1 00 02 00 00    	add    ecx,0x200
  226abe:	01 f6                	add    esi,esi
        const t = s + r;
  226ac0:	8d 82 00 01 00 00    	lea    eax,[rdx+0x100]
        if (t <= ix) {
  226ac6:	89 f7                	mov    edi,esi
  226ac8:	29 c7                	sub    edi,eax
  226aca:	7d 04                	jge    226ad0 <sqrtf+0x280>
  226acc:	89 f7                	mov    edi,esi
  226ace:	eb 0c                	jmp    226adc <sqrtf+0x28c>
            s = t + r;
  226ad0:	81 c2 00 02 00 00    	add    edx,0x200
            q += r;
  226ad6:	81 c1 00 01 00 00    	add    ecx,0x100
  226adc:	01 ff                	add    edi,edi
        const t = s + r;
  226ade:	89 d0                	mov    eax,edx
  226ae0:	83 e8 80             	sub    eax,0xffffff80
        if (t <= ix) {
  226ae3:	89 fe                	mov    esi,edi
  226ae5:	29 c6                	sub    esi,eax
  226ae7:	7d 04                	jge    226aed <sqrtf+0x29d>
  226ae9:	89 fe                	mov    esi,edi
  226aeb:	eb 09                	jmp    226af6 <sqrtf+0x2a6>
            s = t + r;
  226aed:	81 c2 00 01 00 00    	add    edx,0x100
            q += r;
  226af3:	83 e9 80             	sub    ecx,0xffffff80
  226af6:	01 f6                	add    esi,esi
        const t = s + r;
  226af8:	8d 42 40             	lea    eax,[rdx+0x40]
        if (t <= ix) {
  226afb:	89 f7                	mov    edi,esi
  226afd:	29 c7                	sub    edi,eax
  226aff:	7d 04                	jge    226b05 <sqrtf+0x2b5>
  226b01:	89 f7                	mov    edi,esi
  226b03:	eb 06                	jmp    226b0b <sqrtf+0x2bb>
            s = t + r;
  226b05:	83 ea 80             	sub    edx,0xffffff80
            q += r;
  226b08:	83 c1 40             	add    ecx,0x40
  226b0b:	01 ff                	add    edi,edi
        const t = s + r;
  226b0d:	8d 42 20             	lea    eax,[rdx+0x20]
        if (t <= ix) {
  226b10:	89 fe                	mov    esi,edi
  226b12:	29 c6                	sub    esi,eax
  226b14:	7d 04                	jge    226b1a <sqrtf+0x2ca>
  226b16:	89 fe                	mov    esi,edi
  226b18:	eb 06                	jmp    226b20 <sqrtf+0x2d0>
            s = t + r;
  226b1a:	83 c2 40             	add    edx,0x40
            q += r;
  226b1d:	83 c1 20             	add    ecx,0x20
  226b20:	01 f6                	add    esi,esi
        const t = s + r;
  226b22:	8d 42 10             	lea    eax,[rdx+0x10]
        if (t <= ix) {
  226b25:	89 f7                	mov    edi,esi
  226b27:	29 c7                	sub    edi,eax
  226b29:	7d 04                	jge    226b2f <sqrtf+0x2df>
  226b2b:	89 f7                	mov    edi,esi
  226b2d:	eb 06                	jmp    226b35 <sqrtf+0x2e5>
            s = t + r;
  226b2f:	83 c2 20             	add    edx,0x20
            q += r;
  226b32:	83 c1 10             	add    ecx,0x10
  226b35:	01 ff                	add    edi,edi
        const t = s + r;
  226b37:	8d 42 08             	lea    eax,[rdx+0x8]
        if (t <= ix) {
  226b3a:	89 fe                	mov    esi,edi
  226b3c:	29 c6                	sub    esi,eax
  226b3e:	7d 04                	jge    226b44 <sqrtf+0x2f4>
  226b40:	89 fe                	mov    esi,edi
  226b42:	eb 06                	jmp    226b4a <sqrtf+0x2fa>
            s = t + r;
  226b44:	83 c2 10             	add    edx,0x10
            q += r;
  226b47:	83 c1 08             	add    ecx,0x8
  226b4a:	01 f6                	add    esi,esi
        const t = s + r;
  226b4c:	8d 42 04             	lea    eax,[rdx+0x4]
        if (t <= ix) {
  226b4f:	89 f7                	mov    edi,esi
  226b51:	29 c7                	sub    edi,eax
  226b53:	7d 04                	jge    226b59 <sqrtf+0x309>
  226b55:	89 f7                	mov    edi,esi
  226b57:	eb 06                	jmp    226b5f <sqrtf+0x30f>
            s = t + r;
  226b59:	83 c2 08             	add    edx,0x8
            q += r;
  226b5c:	83 c1 04             	add    ecx,0x4
  226b5f:	01 ff                	add    edi,edi
        const t = s + r;
  226b61:	8d 42 02             	lea    eax,[rdx+0x2]
        if (t <= ix) {
  226b64:	89 fe                	mov    esi,edi
  226b66:	29 c6                	sub    esi,eax
  226b68:	7d 0a                	jge    226b74 <sqrtf+0x324>
  226b6a:	89 fe                	mov    esi,edi
  226b6c:	01 f6                	add    esi,esi
  226b6e:	39 d6                	cmp    esi,edx
  226b70:	7f 0e                	jg     226b80 <sqrtf+0x330>
  226b72:	eb 14                	jmp    226b88 <sqrtf+0x338>
            s = t + r;
  226b74:	83 c2 04             	add    edx,0x4
            q += r;
  226b77:	83 c1 02             	add    ecx,0x2
  226b7a:	01 f6                	add    esi,esi
        if (t <= ix) {
  226b7c:	39 d6                	cmp    esi,edx
  226b7e:	7e 08                	jle    226b88 <sqrtf+0x338>
        const t = s + r;
  226b80:	83 c2 01             	add    edx,0x1
            ix -= t;
  226b83:	29 d6                	sub    esi,edx
            q += r;
  226b85:	83 c1 01             	add    ecx,0x1
    m >>= 1; // m = [m / 2]
  226b88:	41 83 e0 fe          	and    r8d,0xfffffffe
  226b8c:	41 c1 e0 16          	shl    r8d,0x16
        ix += ix;
        r >>= 1;
    }

    // floating add to find rounding direction
    if (ix != 0) {
  226b90:	85 f6                	test   esi,esi
  226b92:	0f 95 c0             	setne  al
  226b95:	20 c8                	and    al,cl
  226b97:	0f b6 c0             	movzx  eax,al
  226b9a:	01 c8                	add    eax,ecx
                }
            }
        }
    }

    ix = (q >> 1) + 0x3f000000;
  226b9c:	d1 f8                	sar    eax,1
    ix += m << 23;
  226b9e:	41 8d 04 00          	lea    eax,[r8+rax*1]
  226ba2:	05 00 00 00 3f       	add    eax,0x3f000000
    return @bitCast(f32, ix);
  226ba7:	c5 f9 6e c0          	vmovd  xmm0,eax
  226bab:	c3                   	ret    
  226bac:	c5 f9 6e 05 8c 29 fe 	vmovd  xmm0,DWORD PTR [rip+0xfffffffffffe298c]        # 209540 <__unnamed_59+0x1a>
  226bb3:	ff 
            return x; // sqrt (+-0) = +-0
  226bb4:	c3                   	ret    
  226bb5:	cc                   	int3   
  226bb6:	cc                   	int3   
  226bb7:	cc                   	int3   
  226bb8:	cc                   	int3   
  226bb9:	cc                   	int3   
  226bba:	cc                   	int3   
  226bbb:	cc                   	int3   
  226bbc:	cc                   	int3   
  226bbd:	cc                   	int3   
  226bbe:	cc                   	int3   
  226bbf:	cc                   	int3   

0000000000226bc0 <__udivmoddi4>:
const udivmod = @import("udivmod.zig").udivmod;
const builtin = @import("builtin");

pub extern fn __udivmoddi4(a: u64, b: u64, maybe_rem: ?*u64) u64 {
  226bc0:	55                   	push   rbp
  226bc1:	41 57                	push   r15
  226bc3:	41 56                	push   r14
  226bc5:	41 54                	push   r12
  226bc7:	53                   	push   rbx
  226bc8:	49 89 d0             	mov    r8,rdx
  226bcb:	49 89 fa             	mov    r10,rdi
  226bce:	4c 89 d3             	mov    rbx,r10
  226bd1:	48 c1 eb 20          	shr    rbx,0x20
  226bd5:	48 89 f1             	mov    rcx,rsi
  226bd8:	48 c1 e9 20          	shr    rcx,0x20
    const d = @ptrCast(*const [2]SingleInt, &b).*; // TODO issue #421
    var q: [2]SingleInt = undefined;
    var r: [2]SingleInt = undefined;
    var sr: c_uint = undefined;
    // special cases, X is unknown, K != 0
    if (n[high] == 0) {
  226bdc:	85 db                	test   ebx,ebx
  226bde:	74 2f                	je     226c0f <__udivmoddi4+0x4f>
            rem.* = n[low];
        }
        return 0;
    }
    // n[high] != 0
    if (d[low] == 0) {
  226be0:	85 f6                	test   esi,esi
  226be2:	74 46                	je     226c2a <__udivmoddi4+0x6a>
  226be4:	85 c9                	test   ecx,ecx
        // r.all = a >> sr;
        r[high] = n[high] >> @intCast(Log2SingleInt, sr);
        r[low] = (n[high] << @intCast(Log2SingleInt, SingleInt.bit_count - sr)) | (n[low] >> @intCast(Log2SingleInt, sr));
    } else {
        // d[low] != 0
        if (d[high] == 0) {
  226be6:	74 78                	je     226c60 <__udivmoddi4+0xa0>
            }
        } else {
            // K X
            // ---
            // K K
            sr = @bitCast(c_uint, c_int(@clz(d[high])) - c_int(@clz(n[high])));
  226be8:	f3 0f bd e9          	lzcnt  ebp,ecx
  226bec:	f3 0f bd c3          	lzcnt  eax,ebx
  226bf0:	29 c5                	sub    ebp,eax
            // 0 <= sr <= SingleInt.bit_count - 1 or sr large
            if (sr > SingleInt.bit_count - 1) {
  226bf2:	83 fd 20             	cmp    ebp,0x20
  226bf5:	0f 82 b3 00 00 00    	jb     226cae <__udivmoddi4+0xee>
                if (maybe_rem) |rem| {
  226bfb:	4d 85 c0             	test   r8,r8
  226bfe:	0f 84 d5 00 00 00    	je     226cd9 <__udivmoddi4+0x119>
  226c04:	4d 89 10             	mov    QWORD PTR [r8],r10
  226c07:	45 31 d2             	xor    r10d,r10d
  226c0a:	e9 06 03 00 00       	jmp    226f15 <__udivmoddi4+0x355>
        if (d[high] == 0) {
  226c0f:	85 c9                	test   ecx,ecx
  226c11:	74 7d                	je     226c90 <__udivmoddi4+0xd0>
  226c13:	4d 85 c0             	test   r8,r8
        if (maybe_rem) |rem| {
  226c16:	0f 84 bd 00 00 00    	je     226cd9 <__udivmoddi4+0x119>
            rem.* = n[low];
  226c1c:	44 89 d0             	mov    eax,r10d
  226c1f:	49 89 00             	mov    QWORD PTR [r8],rax
  226c22:	45 31 d2             	xor    r10d,r10d
  226c25:	e9 eb 02 00 00       	jmp    226f15 <__udivmoddi4+0x355>
  226c2a:	85 c9                	test   ecx,ecx
        if (d[high] == 0) {
  226c2c:	0f 84 93 00 00 00    	je     226cc5 <__udivmoddi4+0x105>
        if (n[low] == 0) {
  226c32:	45 85 d2             	test   r10d,r10d
  226c35:	0f 84 d2 00 00 00    	je     226d0d <__udivmoddi4+0x14d>
        if ((d[high] & (d[high] - 1)) == 0) {
  226c3b:	8d 41 ff             	lea    eax,[rcx-0x1]
  226c3e:	85 c8                	test   eax,ecx
  226c40:	0f 84 5d 01 00 00    	je     226da3 <__udivmoddi4+0x1e3>
        sr = @bitCast(c_uint, c_int(@clz(d[high])) - c_int(@clz(n[high])));
  226c46:	f3 0f bd c9          	lzcnt  ecx,ecx
  226c4a:	f3 0f bd c3          	lzcnt  eax,ebx
  226c4e:	29 c1                	sub    ecx,eax
        if (sr > SingleInt.bit_count - 2) {
  226c50:	83 f9 1f             	cmp    ecx,0x1f
  226c53:	0f 82 6c 01 00 00    	jb     226dc5 <__udivmoddi4+0x205>
            if (maybe_rem) |rem| {
  226c59:	4d 85 c0             	test   r8,r8
  226c5c:	75 a6                	jne    226c04 <__udivmoddi4+0x44>
  226c5e:	eb 79                	jmp    226cd9 <__udivmoddi4+0x119>
            if ((d[low] & (d[low] - 1)) == 0) {
  226c60:	8d 46 ff             	lea    eax,[rsi-0x1]
  226c63:	85 f0                	test   eax,esi
  226c65:	0f 84 c2 00 00 00    	je     226d2d <__udivmoddi4+0x16d>
            sr = 1 + SingleInt.bit_count + c_uint(@clz(d[low])) - c_uint(@clz(n[high]));
  226c6b:	f3 0f bd ce          	lzcnt  ecx,esi
  226c6f:	83 c1 21             	add    ecx,0x21
  226c72:	f3 0f bd c3          	lzcnt  eax,ebx
  226c76:	29 c1                	sub    ecx,eax
  226c78:	31 d2                	xor    edx,edx
            if (sr == SingleInt.bit_count) {
  226c7a:	83 f9 20             	cmp    ecx,0x20
  226c7d:	0f 85 e7 00 00 00    	jne    226d6a <__udivmoddi4+0x1aa>
  226c83:	45 31 ff             	xor    r15d,r15d
  226c86:	b9 20 00 00 00       	mov    ecx,0x20
  226c8b:	e9 7c 01 00 00       	jmp    226e0c <__udivmoddi4+0x24c>
  226c90:	4d 85 c0             	test   r8,r8
            if (maybe_rem) |rem| {
  226c93:	74 0a                	je     226c9f <__udivmoddi4+0xdf>
                rem.* = n[low] % d[low];
  226c95:	31 d2                	xor    edx,edx
  226c97:	44 89 d0             	mov    eax,r10d
  226c9a:	f7 f6                	div    esi
  226c9c:	49 89 10             	mov    QWORD PTR [r8],rdx
            return n[low] / d[low];
  226c9f:	31 d2                	xor    edx,edx
  226ca1:	44 89 d0             	mov    eax,r10d
  226ca4:	f7 f6                	div    esi
  226ca6:	41 89 c2             	mov    r10d,eax
  226ca9:	e9 67 02 00 00       	jmp    226f15 <__udivmoddi4+0x355>
                    rem.* = a;
                }
                return 0;
            }
            sr += 1;
  226cae:	8d 4d 01             	lea    ecx,[rbp+0x1]
  226cb1:	45 31 ff             	xor    r15d,r15d
            // 1 <= sr <= SingleInt.bit_count
            // q.all = a << (DoubleInt.bit_count - sr);
            // r.all = a >> sr;
            q[low] = 0;
            if (sr == SingleInt.bit_count) {
  226cb4:	83 f9 20             	cmp    ecx,0x20
  226cb7:	75 28                	jne    226ce1 <__udivmoddi4+0x121>
  226cb9:	31 d2                	xor    edx,edx
  226cbb:	b9 20 00 00 00       	mov    ecx,0x20
  226cc0:	e9 47 01 00 00       	jmp    226e0c <__udivmoddi4+0x24c>
            if (maybe_rem) |rem| {
  226cc5:	4d 85 c0             	test   r8,r8
  226cc8:	74 0f                	je     226cd9 <__udivmoddi4+0x119>
                rem.* = n[high] % d[low];
  226cca:	49 c7 00 00 00 00 00 	mov    QWORD PTR [r8],0x0
  226cd1:	45 31 d2             	xor    r10d,r10d
  226cd4:	e9 3c 02 00 00       	jmp    226f15 <__udivmoddi4+0x355>
  226cd9:	45 31 d2             	xor    r10d,r10d
  226cdc:	e9 34 02 00 00       	jmp    226f15 <__udivmoddi4+0x355>
                q[high] = n[low];
                r[high] = 0;
                r[low] = n[high];
            } else {
                r[high] = n[high] >> @intCast(Log2SingleInt, sr);
  226ce1:	41 89 c9             	mov    r9d,ecx
  226ce4:	41 83 e1 1f          	and    r9d,0x1f
  226ce8:	c4 e2 33 f7 d3       	shrx   edx,ebx,r9d
  226ced:	b8 1f 00 00 00       	mov    eax,0x1f
                r[low] = (n[high] << @intCast(Log2SingleInt, SingleInt.bit_count - sr)) | (n[low] >> @intCast(Log2SingleInt, sr));
  226cf2:	29 e8                	sub    eax,ebp
  226cf4:	83 e0 1f             	and    eax,0x1f
  226cf7:	c4 e2 79 f7 eb       	shlx   ebp,ebx,eax
  226cfc:	c4 c2 33 f7 da       	shrx   ebx,r10d,r9d
  226d01:	09 eb                	or     ebx,ebp
                q[high] = n[low] << @intCast(Log2SingleInt, SingleInt.bit_count - sr);
  226d03:	c4 42 79 f7 d2       	shlx   r10d,r10d,eax
  226d08:	e9 ff 00 00 00       	jmp    226e0c <__udivmoddi4+0x24c>
            if (maybe_rem) |rem| {
  226d0d:	4d 85 c0             	test   r8,r8
  226d10:	74 0d                	je     226d1f <__udivmoddi4+0x15f>
                r[high] = n[high] % d[high];
  226d12:	31 d2                	xor    edx,edx
  226d14:	89 d8                	mov    eax,ebx
  226d16:	f7 f1                	div    ecx
                rem.* = @ptrCast(*align(@alignOf(SingleInt)) DoubleInt, &r[0]).*; // TODO issue #421
  226d18:	48 c1 e2 20          	shl    rdx,0x20
  226d1c:	49 89 10             	mov    QWORD PTR [r8],rdx
            return n[high] / d[high];
  226d1f:	31 d2                	xor    edx,edx
  226d21:	89 d8                	mov    eax,ebx
  226d23:	f7 f1                	div    ecx
  226d25:	41 89 c2             	mov    r10d,eax
  226d28:	e9 e8 01 00 00       	jmp    226f15 <__udivmoddi4+0x355>
                if (maybe_rem) |rem| {
  226d2d:	4d 85 c0             	test   r8,r8
  226d30:	74 06                	je     226d38 <__udivmoddi4+0x178>
                    rem.* = n[low] & (d[low] - 1);
  226d32:	44 21 d0             	and    eax,r10d
  226d35:	49 89 00             	mov    QWORD PTR [r8],rax
                if (d[low] == 1) {
  226d38:	83 fe 01             	cmp    esi,0x1
  226d3b:	0f 84 d4 01 00 00    	je     226f15 <__udivmoddi4+0x355>
                sr = @ctz(d[low]);
  226d41:	f3 0f bc c6          	tzcnt  eax,esi
                q[high] = n[high] >> @intCast(Log2SingleInt, sr);
  226d45:	89 c1                	mov    ecx,eax
  226d47:	83 e1 1f             	and    ecx,0x1f
  226d4a:	c4 e2 73 f7 d3       	shrx   edx,ebx,ecx
                q[low] = (n[high] << @intCast(Log2SingleInt, SingleInt.bit_count - sr)) | (n[low] >> @intCast(Log2SingleInt, sr));
  226d4f:	f7 d8                	neg    eax
  226d51:	c4 e2 79 f7 c3       	shlx   eax,ebx,eax
  226d56:	c4 42 73 f7 d2       	shrx   r10d,r10d,ecx
  226d5b:	41 09 c2             	or     r10d,eax
                return @ptrCast(*align(@alignOf(SingleInt)) DoubleInt, &q[0]).*; // TODO issue #421
  226d5e:	48 c1 e2 20          	shl    rdx,0x20
  226d62:	49 09 d2             	or     r10,rdx
  226d65:	e9 ab 01 00 00       	jmp    226f15 <__udivmoddi4+0x355>
  226d6a:	89 cd                	mov    ebp,ecx
  226d6c:	f7 dd                	neg    ebp
  226d6e:	83 e5 1f             	and    ebp,0x1f
  226d71:	c4 42 51 f7 fa       	shlx   r15d,r10d,ebp
            } else if (sr < SingleInt.bit_count) {
  226d76:	83 f9 20             	cmp    ecx,0x20
  226d79:	73 7a                	jae    226df5 <__udivmoddi4+0x235>
  226d7b:	31 d2                	xor    edx,edx
    // q.all = a << (DoubleInt.bit_count - sr);
    // r.all = a >> sr;
    // 1 <= sr <= DoubleInt.bit_count - 1
    var carry: u32 = 0;
    var r_all: DoubleInt = undefined;
    while (sr > 0) : (sr -= 1) {
  226d7d:	85 c9                	test   ecx,ecx
  226d7f:	0f 84 9c 01 00 00    	je     226f21 <__udivmoddi4+0x361>
  226d85:	89 c8                	mov    eax,ecx
  226d87:	83 e0 1f             	and    eax,0x1f
  226d8a:	c4 e2 7b f7 d3       	shrx   edx,ebx,eax
  226d8f:	c4 e2 51 f7 eb       	shlx   ebp,ebx,ebp
  226d94:	c4 c2 7b f7 da       	shrx   ebx,r10d,eax
  226d99:	09 eb                	or     ebx,ebp
  226d9b:	45 89 fa             	mov    r10d,r15d
  226d9e:	45 31 ff             	xor    r15d,r15d
  226da1:	eb 69                	jmp    226e0c <__udivmoddi4+0x24c>
            if (maybe_rem) |rem| {
  226da3:	4d 85 c0             	test   r8,r8
  226da6:	74 0f                	je     226db7 <__udivmoddi4+0x1f7>
                r[high] = n[high] & (d[high] - 1);
  226da8:	21 d8                	and    eax,ebx
                rem.* = @ptrCast(*align(@alignOf(SingleInt)) DoubleInt, &r[0]).*; // TODO issue #421
  226daa:	48 c1 e0 20          	shl    rax,0x20
  226dae:	44 89 d2             	mov    edx,r10d
  226db1:	48 09 c2             	or     rdx,rax
  226db4:	49 89 10             	mov    QWORD PTR [r8],rdx
            return n[high] >> @intCast(Log2SingleInt, @ctz(d[high]));
  226db7:	f3 0f bc c1          	tzcnt  eax,ecx
  226dbb:	c4 62 7b f7 d3       	shrx   r10d,ebx,eax
  226dc0:	e9 50 01 00 00       	jmp    226f15 <__udivmoddi4+0x355>
        q[high] = n[low] << @intCast(Log2SingleInt, SingleInt.bit_count - sr);
  226dc5:	b8 1f 00 00 00       	mov    eax,0x1f
  226dca:	29 c8                	sub    eax,ecx
        sr += 1;
  226dcc:	83 c1 01             	add    ecx,0x1
        q[high] = n[low] << @intCast(Log2SingleInt, SingleInt.bit_count - sr);
  226dcf:	83 e0 1f             	and    eax,0x1f
        r[high] = n[high] >> @intCast(Log2SingleInt, sr);
  226dd2:	89 cd                	mov    ebp,ecx
  226dd4:	83 e5 1f             	and    ebp,0x1f
  226dd7:	c4 e2 53 f7 d3       	shrx   edx,ebx,ebp
        r[low] = (n[high] << @intCast(Log2SingleInt, SingleInt.bit_count - sr)) | (n[low] >> @intCast(Log2SingleInt, sr));
  226ddc:	c4 e2 79 f7 fb       	shlx   edi,ebx,eax
  226de1:	c4 c2 53 f7 da       	shrx   ebx,r10d,ebp
        q[high] = n[low] << @intCast(Log2SingleInt, SingleInt.bit_count - sr);
  226de6:	c4 c2 79 f7 ea       	shlx   ebp,r10d,eax
        r[low] = (n[high] << @intCast(Log2SingleInt, SingleInt.bit_count - sr)) | (n[low] >> @intCast(Log2SingleInt, sr));
  226deb:	09 fb                	or     ebx,edi
  226ded:	45 31 ff             	xor    r15d,r15d
  226df0:	41 89 ea             	mov    r10d,ebp
  226df3:	eb 17                	jmp    226e0c <__udivmoddi4+0x24c>
                q[high] = (n[high] << @intCast(Log2SingleInt, DoubleInt.bit_count - sr)) | (n[low] >> @intCast(Log2SingleInt, sr - SingleInt.bit_count));
  226df5:	c4 e2 51 f7 eb       	shlx   ebp,ebx,ebp
  226dfa:	89 c8                	mov    eax,ecx
  226dfc:	83 e0 1f             	and    eax,0x1f
  226dff:	c4 42 7b f7 d2       	shrx   r10d,r10d,eax
  226e04:	41 09 ea             	or     r10d,ebp
                r[low] = n[high] >> @intCast(Log2SingleInt, sr - SingleInt.bit_count);
  226e07:	c4 e2 7b f7 db       	shrx   ebx,ebx,eax
  226e0c:	4c 8d 4e ff          	lea    r9,[rsi-0x1]
    while (sr > 0) : (sr -= 1) {
  226e10:	41 89 cb             	mov    r11d,ecx
  226e13:	41 83 e3 01          	and    r11d,0x1
  226e17:	83 f9 01             	cmp    ecx,0x1
  226e1a:	75 10                	jne    226e2c <__udivmoddi4+0x26c>
  226e1c:	31 c9                	xor    ecx,ecx
  226e1e:	45 85 db             	test   r11d,r11d
  226e21:	0f 85 9e 00 00 00    	jne    226ec5 <__udivmoddi4+0x305>
  226e27:	e9 c9 00 00 00       	jmp    226ef5 <__udivmoddi4+0x335>
  226e2c:	45 89 dc             	mov    r12d,r11d
  226e2f:	41 29 cc             	sub    r12d,ecx
  226e32:	31 c9                	xor    ecx,ecx
  226e34:	41 be 1e 01 00 00    	mov    r14d,0x11e
  226e3a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
        // r:q = ((r:q)  << 1) | carry
        r[high] = (r[high] << 1) | (r[low] >> (SingleInt.bit_count - 1));
  226e40:	0f a4 da 01          	shld   edx,ebx,0x1
        r[low] = (r[low] << 1) | (q[high] >> (SingleInt.bit_count - 1));
  226e44:	44 0f a4 d3 01       	shld   ebx,r10d,0x1
  226e49:	c4 c2 08 f7 ea       	bextr  ebp,r10d,r14d
        q[high] = (q[high] << 1) | (q[low] >> (SingleInt.bit_count - 1));
  226e4e:	45 0f a4 fa 01       	shld   r10d,r15d,0x1
        q[low] = (q[low] << 1) | carry;
  226e53:	43 8d 04 3f          	lea    eax,[r15+r15*1]
  226e57:	09 c8                	or     eax,ecx
        // if (r.all >= b)
        // {
        //     r.all -= b;
        //      carry = 1;
        // }
        r_all = @ptrCast(*align(@alignOf(SingleInt)) DoubleInt, &r[0]).*; // TODO issue #421
  226e59:	48 c1 e2 20          	shl    rdx,0x20
  226e5d:	48 09 d3             	or     rbx,rdx
        const s: SignedDoubleInt = @intCast(SignedDoubleInt, b -% r_all -% 1) >> (DoubleInt.bit_count - 1);
  226e60:	4c 89 c9             	mov    rcx,r9
  226e63:	48 29 d9             	sub    rcx,rbx
  226e66:	48 c1 f9 3f          	sar    rcx,0x3f
        carry = @intCast(u32, s & 1);
  226e6a:	89 ca                	mov    edx,ecx
  226e6c:	83 e2 01             	and    edx,0x1
        r_all -= b & @bitCast(DoubleInt, s);
  226e6f:	48 21 f1             	and    rcx,rsi
  226e72:	48 29 cb             	sub    rbx,rcx
        r[high] = (r[high] << 1) | (r[low] >> (SingleInt.bit_count - 1));
  226e75:	48 89 d9             	mov    rcx,rbx
  226e78:	48 c1 e9 1f          	shr    rcx,0x1f
  226e7c:	83 e1 fe             	and    ecx,0xfffffffe
  226e7f:	89 df                	mov    edi,ebx
  226e81:	c1 ef 1f             	shr    edi,0x1f
  226e84:	09 cf                	or     edi,ecx
        q[high] = (q[high] << 1) | (q[low] >> (SingleInt.bit_count - 1));
  226e86:	c4 c2 08 f7 cf       	bextr  ecx,r15d,r14d
        r[low] = (r[low] << 1) | (q[high] >> (SingleInt.bit_count - 1));
  226e8b:	8d 5c 5d 00          	lea    ebx,[rbp+rbx*2+0x0]
        q[high] = (q[high] << 1) | (q[low] >> (SingleInt.bit_count - 1));
  226e8f:	46 8d 14 51          	lea    r10d,[rcx+r10*2]
        q[low] = (q[low] << 1) | carry;
  226e93:	44 8d 3c 42          	lea    r15d,[rdx+rax*2]
        r_all = @ptrCast(*align(@alignOf(SingleInt)) DoubleInt, &r[0]).*; // TODO issue #421
  226e97:	48 c1 e7 20          	shl    rdi,0x20
  226e9b:	48 09 fb             	or     rbx,rdi
        const s: SignedDoubleInt = @intCast(SignedDoubleInt, b -% r_all -% 1) >> (DoubleInt.bit_count - 1);
  226e9e:	4c 89 c8             	mov    rax,r9
  226ea1:	48 29 d8             	sub    rax,rbx
  226ea4:	48 c1 f8 3f          	sar    rax,0x3f
        carry = @intCast(u32, s & 1);
  226ea8:	89 c1                	mov    ecx,eax
  226eaa:	83 e1 01             	and    ecx,0x1
        r_all -= b & @bitCast(DoubleInt, s);
  226ead:	48 21 f0             	and    rax,rsi
  226eb0:	48 29 c3             	sub    rbx,rax
        r = @ptrCast(*[2]SingleInt, &r_all).*; // TODO issue #421
  226eb3:	48 89 da             	mov    rdx,rbx
  226eb6:	48 c1 ea 20          	shr    rdx,0x20
    while (sr > 0) : (sr -= 1) {
  226eba:	41 83 c4 02          	add    r12d,0x2
  226ebe:	75 80                	jne    226e40 <__udivmoddi4+0x280>
  226ec0:	45 85 db             	test   r11d,r11d
  226ec3:	74 30                	je     226ef5 <__udivmoddi4+0x335>
        r[high] = (r[high] << 1) | (r[low] >> (SingleInt.bit_count - 1));
  226ec5:	0f a4 da 01          	shld   edx,ebx,0x1
        r[low] = (r[low] << 1) | (q[high] >> (SingleInt.bit_count - 1));
  226ec9:	44 0f a4 d3 01       	shld   ebx,r10d,0x1
        r_all = @ptrCast(*align(@alignOf(SingleInt)) DoubleInt, &r[0]).*; // TODO issue #421
  226ece:	48 c1 e2 20          	shl    rdx,0x20
  226ed2:	48 09 d3             	or     rbx,rdx
        const s: SignedDoubleInt = @intCast(SignedDoubleInt, b -% r_all -% 1) >> (DoubleInt.bit_count - 1);
  226ed5:	49 29 d9             	sub    r9,rbx
  226ed8:	49 c1 f9 3f          	sar    r9,0x3f
        r_all -= b & @bitCast(DoubleInt, s);
  226edc:	4c 21 ce             	and    rsi,r9
  226edf:	48 29 f3             	sub    rbx,rsi
        carry = @intCast(u32, s & 1);
  226ee2:	41 83 e1 01          	and    r9d,0x1
        q[high] = (q[high] << 1) | (q[low] >> (SingleInt.bit_count - 1));
  226ee6:	45 0f a4 fa 01       	shld   r10d,r15d,0x1
        q[low] = (q[low] << 1) | carry;
  226eeb:	42 8d 04 79          	lea    eax,[rcx+r15*2]
  226eef:	41 89 c7             	mov    r15d,eax
  226ef2:	44 89 c9             	mov    ecx,r9d
    }
    const q_all = ((@ptrCast(*align(@alignOf(SingleInt)) DoubleInt, &q[0]).*) << 1) | carry; // TODO issue #421
  226ef5:	89 ca                	mov    edx,ecx
  226ef7:	44 89 f9             	mov    ecx,r15d
  226efa:	45 89 d7             	mov    r15d,r10d
  226efd:	49 c1 e7 20          	shl    r15,0x20
  226f01:	49 09 cf             	or     r15,rcx
  226f04:	4d 01 ff             	add    r15,r15
  226f07:	4d 89 fa             	mov    r10,r15
  226f0a:	49 09 d2             	or     r10,rdx
    if (maybe_rem) |rem| {
  226f0d:	4d 85 c0             	test   r8,r8
  226f10:	74 03                	je     226f15 <__udivmoddi4+0x355>
        rem.* = r_all;
  226f12:	49 89 18             	mov    QWORD PTR [r8],rbx
    @setRuntimeSafety(builtin.is_test);
    return udivmod(u64, a, b, maybe_rem);
  226f15:	4c 89 d0             	mov    rax,r10
  226f18:	5b                   	pop    rbx
  226f19:	41 5c                	pop    r12
  226f1b:	41 5e                	pop    r14
  226f1d:	41 5f                	pop    r15
  226f1f:	5d                   	pop    rbp
  226f20:	c3                   	ret    
  226f21:	31 c9                	xor    ecx,ecx
  226f23:	eb d8                	jmp    226efd <__udivmoddi4+0x33d>
  226f25:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  226f2c:	00 00 00 00 

0000000000226f30 <__cmptf2>:
const is_test = builtin.is_test;

pub extern fn __letf2(a: f128, b: f128) c_int {
    @setRuntimeSafety(is_test);

    const aInt = @bitCast(rep_t, a);
  226f30:	66 0f 7f 44 24 e8    	movdqa XMMWORD PTR [rsp-0x18],xmm0
  226f36:	4c 8b 5c 24 e8       	mov    r11,QWORD PTR [rsp-0x18]
  226f3b:	4c 8b 44 24 f0       	mov    r8,QWORD PTR [rsp-0x10]
    const bInt = @bitCast(rep_t, b);
  226f40:	66 0f 7f 4c 24 d8    	movdqa XMMWORD PTR [rsp-0x28],xmm1

    const aAbs: rep_t = aInt & absMask;
  226f46:	40 b6 3f             	mov    sil,0x3f
  226f49:	c4 c2 c8 f5 c8       	bzhi   rcx,r8,rsi
    const bAbs: rep_t = bInt & absMask;

    // If either a or b is NaN, they are unordered.
    if (aAbs > infRep or bAbs > infRep) return LE_UNORDERED;
  226f4e:	4c 89 d8             	mov    rax,r11
  226f51:	48 f7 d8             	neg    rax
  226f54:	49 ba 00 00 00 00 00 	movabs r10,0x7fff000000000000
  226f5b:	00 ff 7f 
  226f5e:	4c 89 d0             	mov    rax,r10
  226f61:	48 19 c8             	sbb    rax,rcx
  226f64:	b8 01 00 00 00       	mov    eax,0x1
  226f69:	72 68                	jb     226fd3 <__cmptf2+0xa3>
  226f6b:	48 8b 7c 24 d8       	mov    rdi,QWORD PTR [rsp-0x28]
  226f70:	4c 8b 4c 24 e0       	mov    r9,QWORD PTR [rsp-0x20]
  226f75:	c4 c2 c8 f5 d1       	bzhi   rdx,r9,rsi
  226f7a:	48 83 ff 01          	cmp    rdi,0x1
  226f7e:	48 89 d6             	mov    rsi,rdx
  226f81:	4c 19 d6             	sbb    rsi,r10
  226f84:	73 4d                	jae    226fd3 <__cmptf2+0xa3>

    // If a and b are both zeros, they are equal.
    if ((aAbs | bAbs) == 0) return LE_EQUAL;
  226f86:	48 89 f8             	mov    rax,rdi
  226f89:	4c 09 d8             	or     rax,r11
  226f8c:	48 09 ca             	or     rdx,rcx
  226f8f:	48 09 c2             	or     rdx,rax
  226f92:	74 40                	je     226fd4 <__cmptf2+0xa4>
  226f94:	b8 ff ff ff ff       	mov    eax,0xffffffff

    // If at least one of a and b is positive, we get the same result comparing
    // a and b as signed integers as we would with a floating-point compare.
    return if ((aInt & bInt) >= 0) if (aInt < bInt)
  226f99:	49 39 fb             	cmp    r11,rdi
  226f9c:	4c 89 c1             	mov    rcx,r8
  226f9f:	4c 19 c9             	sbb    rcx,r9
  226fa2:	72 2f                	jb     226fd3 <__cmptf2+0xa3>
        LE_LESS
    else if (aInt == bInt)
  226fa4:	c4 e1 f9 6e c7       	vmovq  xmm0,rdi
  226fa9:	c4 c1 f9 6e c9       	vmovq  xmm1,r9
  226fae:	c5 f9 6c c1          	vpunpcklqdq xmm0,xmm0,xmm1
  226fb2:	c4 c1 f9 6e cb       	vmovq  xmm1,r11
  226fb7:	c4 c1 f9 6e d0       	vmovq  xmm2,r8
  226fbc:	c5 f1 6c ca          	vpunpcklqdq xmm1,xmm1,xmm2
  226fc0:	c5 f1 74 c0          	vpcmpeqb xmm0,xmm1,xmm0
  226fc4:	c5 f9 d7 c8          	vpmovmskb ecx,xmm0
  226fc8:	31 c0                	xor    eax,eax
  226fca:	81 f9 ff ff 00 00    	cmp    ecx,0xffff
  226fd0:	0f 95 c0             	setne  al
    if (aAbs > infRep or bAbs > infRep) return LE_UNORDERED;
  226fd3:	c3                   	ret    
  226fd4:	31 c0                	xor    eax,eax
  226fd6:	c3                   	ret    
  226fd7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  226fde:	00 00 

0000000000226fe0 <__gttf2>:
const GE_UNORDERED = c_int(-1); // Note: different from LE_UNORDERED

pub extern fn __getf2(a: f128, b: f128) c_int {
    @setRuntimeSafety(is_test);

    const aInt = @bitCast(srep_t, a);
  226fe0:	53                   	push   rbx
  226fe1:	0f 29 44 24 f0       	movaps XMMWORD PTR [rsp-0x10],xmm0
  226fe6:	4c 8b 54 24 f0       	mov    r10,QWORD PTR [rsp-0x10]
  226feb:	4c 8b 44 24 f8       	mov    r8,QWORD PTR [rsp-0x8]
    const bInt = @bitCast(srep_t, b);
  226ff0:	0f 29 4c 24 e0       	movaps XMMWORD PTR [rsp-0x20],xmm1
    const aAbs = @bitCast(rep_t, aInt) & absMask;
  226ff5:	41 b1 3f             	mov    r9b,0x3f
  226ff8:	c4 c2 b0 f5 c8       	bzhi   rcx,r8,r9
    const bAbs = @bitCast(rep_t, bInt) & absMask;

    if (aAbs > infRep or bAbs > infRep) return GE_UNORDERED;
  226ffd:	4c 89 d0             	mov    rax,r10
  227000:	48 f7 d8             	neg    rax
  227003:	48 bb 00 00 00 00 00 	movabs rbx,0x7fff000000000000
  22700a:	00 ff 7f 
  22700d:	48 89 d8             	mov    rax,rbx
  227010:	48 19 c8             	sbb    rax,rcx
  227013:	b8 ff ff ff ff       	mov    eax,0xffffffff
  227018:	72 39                	jb     227053 <__gttf2+0x73>
  22701a:	48 8b 7c 24 e0       	mov    rdi,QWORD PTR [rsp-0x20]
  22701f:	4c 8b 5c 24 e8       	mov    r11,QWORD PTR [rsp-0x18]
  227024:	c4 c2 b0 f5 f3       	bzhi   rsi,r11,r9
  227029:	48 83 ff 01          	cmp    rdi,0x1
  22702d:	48 89 f2             	mov    rdx,rsi
  227030:	48 19 da             	sbb    rdx,rbx
  227033:	73 1e                	jae    227053 <__gttf2+0x73>
    if ((aAbs | bAbs) == 0) return GE_EQUAL;
  227035:	48 89 fa             	mov    rdx,rdi
  227038:	4c 09 d2             	or     rdx,r10
  22703b:	48 09 ce             	or     rsi,rcx
  22703e:	48 09 d6             	or     rsi,rdx
  227041:	74 12                	je     227055 <__gttf2+0x75>
    return if ((aInt & bInt) >= 0) if (aInt < bInt)
  227043:	4d 85 c3             	test   r11,r8
  227046:	78 11                	js     227059 <__gttf2+0x79>
  227048:	49 39 fa             	cmp    r10,rdi
  22704b:	4c 89 c1             	mov    rcx,r8
  22704e:	4c 19 d9             	sbb    rcx,r11
  227051:	7d 11                	jge    227064 <__gttf2+0x84>
    if (aAbs > infRep or bAbs > infRep) return GE_UNORDERED;
  227053:	5b                   	pop    rbx
  227054:	c3                   	ret    
  227055:	31 c0                	xor    eax,eax
  227057:	5b                   	pop    rbx
  227058:	c3                   	ret    
        GE_LESS
    else if (aInt == bInt)
        GE_EQUAL
    else
        GE_GREATER else if (aInt > bInt)
  227059:	4c 39 d7             	cmp    rdi,r10
  22705c:	4c 89 d9             	mov    rcx,r11
  22705f:	4c 19 c1             	sbb    rcx,r8
  227062:	7c ef                	jl     227053 <__gttf2+0x73>
  227064:	c4 e1 f9 6e c7       	vmovq  xmm0,rdi
  227069:	c4 c1 f9 6e cb       	vmovq  xmm1,r11
  22706e:	c5 f9 6c c1          	vpunpcklqdq xmm0,xmm0,xmm1
  227072:	c4 c1 f9 6e ca       	vmovq  xmm1,r10
  227077:	c4 c1 f9 6e d0       	vmovq  xmm2,r8
  22707c:	c5 f1 6c ca          	vpunpcklqdq xmm1,xmm1,xmm2
  227080:	c5 f1 74 c0          	vpcmpeqb xmm0,xmm1,xmm0
  227084:	c5 f9 d7 c8          	vpmovmskb ecx,xmm0
  227088:	31 c0                	xor    eax,eax
  22708a:	81 f9 ff ff 00 00    	cmp    ecx,0xffff
  227090:	0f 95 c0             	setne  al
    if (aAbs > infRep or bAbs > infRep) return GE_UNORDERED;
  227093:	5b                   	pop    rbx
  227094:	c3                   	ret    
  227095:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  22709c:	00 00 00 00 

00000000002270a0 <__extendhfsf2>:

    const dstMinNormal: dst_rep_t = dst_rep_t(1) << dstSigBits;

    // Break a into a sign and representation of the absolute value
    const aRep: src_rep_t = @bitCast(src_rep_t, a);
    const aAbs: src_rep_t = aRep & srcAbsMask;
  2270a0:	89 f9                	mov    ecx,edi
  2270a2:	81 e1 ff 7f 00 00    	and    ecx,0x7fff
    const sign: src_rep_t = aRep & srcSignMask;
  2270a8:	89 f8                	mov    eax,edi
  2270aa:	25 00 80 00 00       	and    eax,0x8000
    var absResult: dst_rep_t = undefined;

    if (aAbs -% srcMinNormal < srcInfinity - srcMinNormal) {
  2270af:	89 ca                	mov    edx,ecx
  2270b1:	81 c2 00 fc ff ff    	add    edx,0xfffffc00
  2270b7:	0f b7 d2             	movzx  edx,dx
  2270ba:	81 fa ff 77 00 00    	cmp    edx,0x77ff
  2270c0:	77 16                	ja     2270d8 <__extendhfsf2+0x38>
        // a is a normal number.
        // Extend to the destination type by shifting the significand and
        // exponent into the proper position and rebiasing the exponent.
        absResult = dst_rep_t(aAbs) << (dstSigBits - srcSigBits);
  2270c2:	0f b7 c9             	movzx  ecx,cx
  2270c5:	c1 e1 0d             	shl    ecx,0xd
        absResult += (dstExpBias - srcExpBias) << dstSigBits;
  2270c8:	81 c1 00 00 00 38    	add    ecx,0x38000000
        // a is zero.
        absResult = 0;
    }

    // Apply the signbit to (dst_t)abs(a).
    const result: dst_rep_t align(@alignOf(dst_t)) = absResult | dst_rep_t(sign) << (dstBits - srcBits);
  2270ce:	c1 e0 10             	shl    eax,0x10
  2270d1:	09 c8                	or     eax,ecx
    return @bitCast(dst_t, result);
  2270d3:	c5 f9 6e c0          	vmovd  xmm0,eax
    return extendXfYf2(f32, f16, @bitCast(f16, a));
  2270d7:	c3                   	ret    
    } else if (aAbs >= srcInfinity) {
  2270d8:	0f b7 d1             	movzx  edx,cx
  2270db:	81 fa 00 7c 00 00    	cmp    edx,0x7c00
  2270e1:	72 16                	jb     2270f9 <__extendhfsf2+0x59>
        absResult |= dst_rep_t(aAbs & srcNaNCode) << (dstSigBits - srcSigBits);
  2270e3:	0f b7 cf             	movzx  ecx,di
  2270e6:	c1 e1 0d             	shl    ecx,0xd
  2270e9:	81 c9 00 00 80 7f    	or     ecx,0x7f800000
    const result: dst_rep_t align(@alignOf(dst_t)) = absResult | dst_rep_t(sign) << (dstBits - srcBits);
  2270ef:	c1 e0 10             	shl    eax,0x10
  2270f2:	09 c8                	or     eax,ecx
    return @bitCast(dst_t, result);
  2270f4:	c5 f9 6e c0          	vmovd  xmm0,eax
    return extendXfYf2(f32, f16, @bitCast(f16, a));
  2270f8:	c3                   	ret    
    } else if (aAbs != 0) {
  2270f9:	66 85 c9             	test   cx,cx
  2270fc:	74 2f                	je     22712d <__extendhfsf2+0x8d>
        const scale: u32 = @clz(aAbs) - @clz(src_rep_t(srcMinNormal));
  2270fe:	66 f3 0f bd c9       	lzcnt  cx,cx
  227103:	8d 71 1b             	lea    esi,[rcx+0x1b]
  227106:	83 e6 1f             	and    esi,0x1f
        absResult = dst_rep_t(aAbs) << @intCast(DstShift, dstSigBits - srcSigBits + scale);
  227109:	83 c1 08             	add    ecx,0x8
  22710c:	c4 e2 71 f7 d2       	shlx   edx,edx,ecx
        absResult ^= dstMinNormal;
  227111:	81 f2 00 00 80 00    	xor    edx,0x800000
        absResult |= @intCast(dst_rep_t, resultExponent) << dstSigBits;
  227117:	c1 e6 17             	shl    esi,0x17
  22711a:	b9 00 00 80 38       	mov    ecx,0x38800000
  22711f:	29 f1                	sub    ecx,esi
  227121:	09 d1                	or     ecx,edx
    const result: dst_rep_t align(@alignOf(dst_t)) = absResult | dst_rep_t(sign) << (dstBits - srcBits);
  227123:	c1 e0 10             	shl    eax,0x10
  227126:	09 c8                	or     eax,ecx
    return @bitCast(dst_t, result);
  227128:	c5 f9 6e c0          	vmovd  xmm0,eax
    return extendXfYf2(f32, f16, @bitCast(f16, a));
  22712c:	c3                   	ret    
  22712d:	31 c9                	xor    ecx,ecx
    const result: dst_rep_t align(@alignOf(dst_t)) = absResult | dst_rep_t(sign) << (dstBits - srcBits);
  22712f:	c1 e0 10             	shl    eax,0x10
  227132:	09 c8                	or     eax,ecx
    return @bitCast(dst_t, result);
  227134:	c5 f9 6e c0          	vmovd  xmm0,eax
    return extendXfYf2(f32, f16, @bitCast(f16, a));
  227138:	c3                   	ret    
  227139:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

0000000000227140 <__truncsfhf2>:

    const dstQNaN = 1 << (dstSigBits - 1);
    const dstNaNCode = dstQNaN - 1;

    // Break a into a sign and representation of the absolute value
    const aRep: src_rep_t = @bitCast(src_rep_t, a);
  227140:	c5 f9 7e c2          	vmovd  edx,xmm0
    const aAbs: src_rep_t = aRep & srcAbsMask;
  227144:	89 d6                	mov    esi,edx
  227146:	81 e6 ff ff ff 7f    	and    esi,0x7fffffff
    const sign: src_rep_t = aRep & srcSignMask;
    var absResult: dst_rep_t = undefined;

    if (aAbs -% underflow < aAbs -% overflow) {
  22714c:	8d 86 00 00 80 c7    	lea    eax,[rsi-0x38800000]
  227152:	8d 8e 00 00 80 b8    	lea    ecx,[rsi-0x47800000]
  227158:	39 c8                	cmp    eax,ecx
  22715a:	73 1f                	jae    22717b <__truncsfhf2+0x3b>
        // The exponent of a is within the range of normal numbers in the
        // destination format.  We can convert by simply right-shifting with
        // rounding and adjusting the exponent.
        absResult = @truncate(dst_rep_t, aAbs >> (srcSigBits - dstSigBits));
  22715c:	89 d0                	mov    eax,edx
  22715e:	c1 e8 0d             	shr    eax,0xd
        absResult -%= dst_rep_t(srcExpBias - dstExpBias) << dstSigBits;

        const roundBits: src_rep_t = aAbs & roundMask;
  227161:	89 d1                	mov    ecx,edx
  227163:	81 e1 ff 1f 00 00    	and    ecx,0x1fff
        if (roundBits > halfway) {
  227169:	81 f9 01 10 00 00    	cmp    ecx,0x1001
  22716f:	72 23                	jb     227194 <__truncsfhf2+0x54>
            // Round to nearest
            absResult += 1;
  227171:	05 01 40 00 00       	add    eax,0x4001
  227176:	e9 83 00 00 00       	jmp    2271fe <__truncsfhf2+0xbe>
        } else if (roundBits == halfway) {
            // Ties to even
            absResult += absResult & 1;
        }
    } else if (aAbs > srcInfinity) {
  22717b:	81 fe 01 00 80 7f    	cmp    esi,0x7f800001
  227181:	72 29                	jb     2271ac <__truncsfhf2+0x6c>
        // a is NaN.
        // Conjure the result by beginning with infinity, setting the qNaN
        // bit and inserting the (truncated) trailing NaN field.
        absResult = @intCast(dst_rep_t, dstInfExp) << dstSigBits;
        absResult |= dstQNaN;
        absResult |= @intCast(dst_rep_t, ((aAbs & srcNaNCode) >> (srcSigBits - dstSigBits)) & dstNaNCode);
  227183:	b8 0d 09 00 00       	mov    eax,0x90d
  227188:	c4 e2 78 f7 c2       	bextr  eax,edx,eax
  22718d:	0d 00 7e 00 00       	or     eax,0x7e00
  227192:	eb 6a                	jmp    2271fe <__truncsfhf2+0xbe>
  227194:	05 00 40 00 00       	add    eax,0x4000
        } else if (roundBits == halfway) {
  227199:	81 f9 00 10 00 00    	cmp    ecx,0x1000
  22719f:	75 5d                	jne    2271fe <__truncsfhf2+0xbe>
  2271a1:	89 c1                	mov    ecx,eax
  2271a3:	83 e1 01             	and    ecx,0x1
  2271a6:	01 c1                	add    ecx,eax
  2271a8:	89 c8                	mov    eax,ecx
  2271aa:	eb 52                	jmp    2271fe <__truncsfhf2+0xbe>
  2271ac:	66 b8 00 7c          	mov    ax,0x7c00
    } else if (aAbs >= overflow) {
  2271b0:	81 fe ff ff 7f 47    	cmp    esi,0x477fffff
  2271b6:	77 46                	ja     2271fe <__truncsfhf2+0xbe>
        absResult = @intCast(dst_rep_t, dstInfExp) << dstSigBits;
    } else {
        // a underflows on conversion to the destination type or is an exact
        // zero.  The result may be a denormal or zero.  Extract the exponent
        // to get the shift amount for the denormalization.
        const aExp = @intCast(u32, aAbs >> srcSigBits);
  2271b8:	c1 ee 17             	shr    esi,0x17
        const shift = @intCast(u32, srcExpBias - dstExpBias - aExp + 1);
  2271bb:	b9 70 00 00 00       	mov    ecx,0x70
  2271c0:	29 f1                	sub    ecx,esi

        const significand: src_rep_t = (aRep & srcSignificandMask) | srcMinNormal;

        // Right shift by the denormalization amount with sticky.
        if (shift > srcSigBits) {
  2271c2:	83 f9 16             	cmp    ecx,0x16
  2271c5:	76 04                	jbe    2271cb <__truncsfhf2+0x8b>
  2271c7:	31 c0                	xor    eax,eax
  2271c9:	eb 33                	jmp    2271fe <__truncsfhf2+0xbe>
  2271cb:	89 d6                	mov    esi,edx
  2271cd:	81 e6 ff ff 7f 00    	and    esi,0x7fffff
  2271d3:	81 ce 00 00 80 00    	or     esi,0x800000
        const shift = @intCast(u32, srcExpBias - dstExpBias - aExp + 1);
  2271d9:	83 c1 01             	add    ecx,0x1
            absResult = 0;
        } else {
            const sticky: src_rep_t = significand << @intCast(SrcShift, srcBits - shift);
            const denormalizedSignificand: src_rep_t = significand >> @intCast(SrcShift, shift) | sticky;
  2271dc:	d3 ce                	ror    esi,cl
            absResult = @intCast(dst_rep_t, denormalizedSignificand >> (srcSigBits - dstSigBits));
  2271de:	89 f0                	mov    eax,esi
  2271e0:	c1 e8 0d             	shr    eax,0xd
            const roundBits: src_rep_t = denormalizedSignificand & roundMask;
  2271e3:	81 e6 ff 1f 00 00    	and    esi,0x1fff
            if (roundBits > halfway) {
  2271e9:	81 fe 01 10 00 00    	cmp    esi,0x1001
  2271ef:	72 05                	jb     2271f6 <__truncsfhf2+0xb6>
                // Round to nearest
                absResult += 1;
  2271f1:	83 c0 01             	add    eax,0x1
  2271f4:	eb 08                	jmp    2271fe <__truncsfhf2+0xbe>
            } else if (roundBits == halfway) {
  2271f6:	81 fe 00 10 00 00    	cmp    esi,0x1000
  2271fc:	74 a3                	je     2271a1 <__truncsfhf2+0x61>
                absResult += absResult & 1;
            }
        }
    }

    const result: dst_rep_t align(@alignOf(dst_t)) = absResult | @truncate(dst_rep_t, sign >> @intCast(SrcShift, srcBits - dstBits));
  2271fe:	c1 ea 10             	shr    edx,0x10
  227201:	81 e2 00 80 00 00    	and    edx,0x8000
  227207:	09 d0                	or     eax,edx
    return @bitCast(u16, truncXfYf2(f16, f32, a));
  227209:	c3                   	ret    
  22720a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000227210 <__unordtf2>:
}

pub extern fn __unordtf2(a: f128, b: f128) c_int {
    @setRuntimeSafety(is_test);

    const aAbs = @bitCast(rep_t, a) & absMask;
  227210:	0f 29 44 24 e8       	movaps XMMWORD PTR [rsp-0x18],xmm0
  227215:	b0 3f                	mov    al,0x3f
  227217:	c4 e2 f8 f5 4c 24 f0 	bzhi   rcx,QWORD PTR [rsp-0x10],rax
    const bAbs = @bitCast(rep_t, b) & absMask;
  22721e:	0f 29 4c 24 d8       	movaps XMMWORD PTR [rsp-0x28],xmm1
  227223:	c4 e2 f8 f5 44 24 e0 	bzhi   rax,QWORD PTR [rsp-0x20],rax
    return @boolToInt(aAbs > infRep or bAbs > infRep);
  22722a:	31 d2                	xor    edx,edx
  22722c:	48 3b 54 24 e8       	cmp    rdx,QWORD PTR [rsp-0x18]
  227231:	48 be 00 00 00 00 00 	movabs rsi,0x7fff000000000000
  227238:	00 ff 7f 
  22723b:	48 89 f7             	mov    rdi,rsi
  22723e:	48 19 cf             	sbb    rdi,rcx
  227241:	0f 92 c1             	setb   cl
  227244:	48 3b 54 24 d8       	cmp    rdx,QWORD PTR [rsp-0x28]
  227249:	48 19 c6             	sbb    rsi,rax
  22724c:	0f 92 c0             	setb   al
  22724f:	08 c8                	or     al,cl
  227251:	0f b6 c0             	movzx  eax,al
  227254:	c3                   	ret    
  227255:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  22725c:	00 00 00 00 

0000000000227260 <__floattitf>:
const LDBL_MANT_DIG = 113;

pub extern fn __floattitf(arg: i128) f128 {
    @setRuntimeSafety(is_test);

    if (arg == 0)
  227260:	48 89 f8             	mov    rax,rdi
  227263:	48 09 f0             	or     rax,rsi
  227266:	0f 84 ba 00 00 00    	je     227326 <__floattitf+0xc6>
        return 0.0;

    var ai = arg;
    const N: u32 = 128;
    const si = ai >> @intCast(u7, (N - 1));
  22726c:	41 57                	push   r15
  22726e:	41 56                	push   r14
  227270:	53                   	push   rbx
  227271:	48 89 f0             	mov    rax,rsi
  227274:	48 c1 f8 3f          	sar    rax,0x3f
    ai = ((ai ^ si) -% si);
  227278:	48 89 c2             	mov    rdx,rax
  22727b:	48 31 f2             	xor    rdx,rsi
  22727e:	48 31 c7             	xor    rdi,rax
  227281:	48 29 c7             	sub    rdi,rax
  227284:	48 19 c2             	sbb    rdx,rax
    var a = @bitCast(u128, ai);

    const sd = @bitCast(i32, N - @clz(a)); // number of significant digits
  227287:	f3 48 0f bd c2       	lzcnt  rax,rdx
  22728c:	f3 48 0f bd cf       	lzcnt  rcx,rdi
  227291:	83 c1 40             	add    ecx,0x40
  227294:	48 85 d2             	test   rdx,rdx
  227297:	0f 45 c8             	cmovne ecx,eax
  22729a:	41 b9 80 00 00 00    	mov    r9d,0x80
  2272a0:	41 29 c9             	sub    r9d,ecx
    var e: i32 = sd - 1; // exponent
  2272a3:	41 ba 7f 00 00 00    	mov    r10d,0x7f
  2272a9:	41 29 ca             	sub    r10d,ecx
    if (sd > LDBL_MANT_DIG) {
  2272ac:	41 83 f9 72          	cmp    r9d,0x72
  2272b0:	7c 7c                	jl     22732e <__floattitf+0xce>
        //                                                12345678901234567890123456
        //  1 = msb 1 bit
        //  P = bit LDBL_MANT_DIG-1 bits to the right of 1
        //  Q = bit LDBL_MANT_DIG bits to the right of 1
        //  R = "or" of all bits to the right of Q
        switch (sd) {
  2272b2:	0f 84 99 00 00 00    	je     227351 <__floattitf+0xf1>
  2272b8:	41 83 f9 73          	cmp    r9d,0x73
  2272bc:	0f 84 97 00 00 00    	je     227359 <__floattitf+0xf9>
            LDBL_MANT_DIG + 1 => {
                a <<= 1;
            },
            LDBL_MANT_DIG + 2 => {},
            else => {
                const shift1_amt = @intCast(i32, sd - (LDBL_MANT_DIG + 2));
  2272c2:	41 8d 49 0d          	lea    ecx,[r9+0xd]
                const shift1_amt_u7 = @intCast(u7, shift1_amt);

                const shift2_amt = @intCast(i32, N + (LDBL_MANT_DIG + 2)) - sd;
  2272c6:	41 b8 73 00 00 00    	mov    r8d,0x73
                const shift2_amt_u7 = @intCast(u7, shift2_amt);

                a = (a >> shift1_amt_u7) | @boolToInt((a & (@intCast(u128, @maxValue(u128)) >> shift2_amt_u7)) != 0);
  2272cc:	83 e1 7f             	and    ecx,0x7f
  2272cf:	49 89 ff             	mov    r15,rdi
  2272d2:	49 0f ad d7          	shrd   r15,rdx,cl
                const shift2_amt = @intCast(i32, N + (LDBL_MANT_DIG + 2)) - sd;
  2272d6:	45 29 c8             	sub    r8d,r9d
                a = (a >> shift1_amt_u7) | @boolToInt((a & (@intCast(u128, @maxValue(u128)) >> shift2_amt_u7)) != 0);
  2272d9:	c4 62 f3 f7 da       	shrx   r11,rdx,rcx
  2272de:	45 31 f6             	xor    r14d,r14d
  2272e1:	f6 c1 40             	test   cl,0x40
  2272e4:	4d 0f 45 fb          	cmovne r15,r11
  2272e8:	4d 0f 45 de          	cmovne r11,r14
  2272ec:	41 83 e0 7f          	and    r8d,0x7f
  2272f0:	48 c7 c3 ff ff ff ff 	mov    rbx,0xffffffffffffffff
  2272f7:	c4 e2 bb f7 c3       	shrx   rax,rbx,r8
  2272fc:	44 89 c1             	mov    ecx,r8d
  2272ff:	48 0f ad db          	shrd   rbx,rbx,cl
  227303:	41 f6 c0 40          	test   r8b,0x40
  227307:	48 0f 45 d8          	cmovne rbx,rax
  22730b:	49 0f 45 c6          	cmovne rax,r14
  22730f:	48 21 fb             	and    rbx,rdi
  227312:	48 21 d0             	and    rax,rdx
  227315:	31 ff                	xor    edi,edi
  227317:	48 09 d8             	or     rax,rbx
  22731a:	40 0f 95 c7          	setne  dil
  22731e:	4c 09 ff             	or     rdi,r15
  227321:	4c 89 da             	mov    rdx,r11
  227324:	eb 33                	jmp    227359 <__floattitf+0xf9>
        return 0.0;
  227326:	0f 28 05 e3 8f fd ff 	movaps xmm0,XMMWORD PTR [rip+0xfffffffffffd8fe3]        # 200310 <__unnamed_18>
  22732d:	c3                   	ret    
            a >>= 1;
            e += 1;
        }
        // a is now rounded to LDBL_MANT_DIG bits
    } else {
        a <<= @intCast(u7, LDBL_MANT_DIG - sd);
  22732e:	b9 71 00 00 00       	mov    ecx,0x71
  227333:	44 29 c9             	sub    ecx,r9d
  227336:	83 e1 7f             	and    ecx,0x7f
  227339:	48 0f a5 fa          	shld   rdx,rdi,cl
  22733d:	c4 e2 f1 f7 ff       	shlx   rdi,rdi,rcx
  227342:	31 c0                	xor    eax,eax
  227344:	f6 c1 40             	test   cl,0x40
  227347:	48 0f 45 d7          	cmovne rdx,rdi
  22734b:	48 0f 44 c7          	cmove  rax,rdi
  22734f:	eb 3b                	jmp    22738c <__floattitf+0x12c>
                a <<= 1;
  227351:	48 0f a4 fa 01       	shld   rdx,rdi,0x1
  227356:	48 01 ff             	add    rdi,rdi
        a |= @boolToInt((a & 4) != 0); // Or P into R
  227359:	b8 02 01 00 00       	mov    eax,0x102
  22735e:	c4 e2 78 f7 c7       	bextr  eax,edi,eax
  227363:	48 09 f8             	or     rax,rdi
        a += 1; // round - this step may add a significant bit
  227366:	48 83 c0 01          	add    rax,0x1
  22736a:	48 83 d2 00          	adc    rdx,0x0
        if ((a & (u128(1) << LDBL_MANT_DIG)) != 0) {
  22736e:	48 0f ba e2 33       	bt     rdx,0x33
  227373:	72 0b                	jb     227380 <__floattitf+0x120>
  227375:	48 0f ac d0 02       	shrd   rax,rdx,0x2
  22737a:	48 c1 ea 02          	shr    rdx,0x2
  22737e:	eb 0c                	jmp    22738c <__floattitf+0x12c>
            a >>= 1;
  227380:	48 0f ac d0 03       	shrd   rax,rdx,0x3
  227385:	48 c1 ea 03          	shr    rdx,0x3
  227389:	45 89 ca             	mov    r10d,r9d
        // a is now rounded to LDBL_MANT_DIG bits
    }

    const s = @bitCast(u128, arg) >> (128 - 64);
    const high: u128 = (@intCast(u64, s) & 0x8000000000000000) | // sign
  22738c:	48 b9 00 00 00 00 00 	movabs rcx,0x8000000000000000
  227393:	00 00 80 
  227396:	48 21 ce             	and    rsi,rcx
        (@intCast(u64, (e + 16383)) << 48) | // exponent
  227399:	41 81 c2 ff 3f 00 00 	add    r10d,0x3fff
  2273a0:	49 c1 e2 30          	shl    r10,0x30
    const high: u128 = (@intCast(u64, s) & 0x8000000000000000) | // sign
  2273a4:	49 09 f2             	or     r10,rsi
        (@truncate(u64, a >> 64) & 0x0000ffffffffffff); // mantissa-high
  2273a7:	b1 30                	mov    cl,0x30
  2273a9:	c4 e2 f0 f5 ca       	bzhi   rcx,rdx,rcx
    const low = @truncate(u64, a); // mantissa-low

    return @bitCast(f128, low | (high << 64));
  2273ae:	48 89 44 24 f0       	mov    QWORD PTR [rsp-0x10],rax
        (@intCast(u64, (e + 16383)) << 48) | // exponent
  2273b3:	4c 09 d1             	or     rcx,r10
    return @bitCast(f128, low | (high << 64));
  2273b6:	48 89 4c 24 f8       	mov    QWORD PTR [rsp-0x8],rcx
  2273bb:	0f 28 44 24 f0       	movaps xmm0,XMMWORD PTR [rsp-0x10]
  2273c0:	5b                   	pop    rbx
  2273c1:	41 5e                	pop    r14
  2273c3:	41 5f                	pop    r15
  2273c5:	c3                   	ret    
  2273c6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  2273cd:	00 00 00 

00000000002273d0 <__floattidf>:
const DBL_MANT_DIG = 53;

pub extern fn __floattidf(arg: i128) f64 {
    @setRuntimeSafety(is_test);

    if (arg == 0)
  2273d0:	48 89 f8             	mov    rax,rdi
  2273d3:	48 09 f0             	or     rax,rsi
  2273d6:	0f 84 b8 00 00 00    	je     227494 <__floattidf+0xc4>
        return 0.0;

    var ai = arg;
    const N: u32 = 128;
    const si = ai >> @intCast(u7, (N - 1));
  2273dc:	41 57                	push   r15
  2273de:	41 56                	push   r14
  2273e0:	53                   	push   rbx
  2273e1:	48 89 f0             	mov    rax,rsi
  2273e4:	48 c1 f8 3f          	sar    rax,0x3f
    ai = ((ai ^ si) -% si);
  2273e8:	48 89 c2             	mov    rdx,rax
  2273eb:	48 31 f2             	xor    rdx,rsi
  2273ee:	48 31 c7             	xor    rdi,rax
  2273f1:	48 29 c7             	sub    rdi,rax
  2273f4:	48 19 c2             	sbb    rdx,rax
    var a = @bitCast(u128, ai);

    const sd = @bitCast(i32, N - @clz(a)); // number of significant digits
  2273f7:	f3 48 0f bd c2       	lzcnt  rax,rdx
  2273fc:	f3 48 0f bd cf       	lzcnt  rcx,rdi
  227401:	83 c1 40             	add    ecx,0x40
  227404:	48 85 d2             	test   rdx,rdx
  227407:	0f 45 c8             	cmovne ecx,eax
  22740a:	41 b9 80 00 00 00    	mov    r9d,0x80
  227410:	41 29 c9             	sub    r9d,ecx
    var e: i32 = sd - 1; // exponent
  227413:	b8 7f 00 00 00       	mov    eax,0x7f
  227418:	29 c8                	sub    eax,ecx
    if (sd > DBL_MANT_DIG) {
  22741a:	41 83 f9 36          	cmp    r9d,0x36
  22741e:	7c 79                	jl     227499 <__floattidf+0xc9>
        //                                                12345678901234567890123456
        //  1 = msb 1 bit
        //  P = bit DBL_MANT_DIG-1 bits to the right of 1
        //  Q = bit DBL_MANT_DIG bits to the right of 1
        //  R = "or" of all bits to the right of Q
        switch (sd) {
  227420:	0f 84 9b 00 00 00    	je     2274c1 <__floattidf+0xf1>
  227426:	41 83 f9 37          	cmp    r9d,0x37
  22742a:	0f 84 99 00 00 00    	je     2274c9 <__floattidf+0xf9>
            DBL_MANT_DIG + 1 => {
                a <<= 1;
            },
            DBL_MANT_DIG + 2 => {},
            else => {
                const shift1_amt = @intCast(i32, sd - (DBL_MANT_DIG + 2));
  227430:	41 8d 49 49          	lea    ecx,[r9+0x49]
                const shift1_amt_u7 = @intCast(u7, shift1_amt);

                const shift2_amt = @intCast(i32, N + (DBL_MANT_DIG + 2)) - sd;
  227434:	41 b8 37 00 00 00    	mov    r8d,0x37
                const shift2_amt_u7 = @intCast(u7, shift2_amt);

                a = (a >> shift1_amt_u7) | @boolToInt((a & (@intCast(u128, @maxValue(u128)) >> shift2_amt_u7)) != 0);
  22743a:	83 e1 7f             	and    ecx,0x7f
  22743d:	49 89 fa             	mov    r10,rdi
  227440:	49 0f ad d2          	shrd   r10,rdx,cl
                const shift2_amt = @intCast(i32, N + (DBL_MANT_DIG + 2)) - sd;
  227444:	45 29 c8             	sub    r8d,r9d
                a = (a >> shift1_amt_u7) | @boolToInt((a & (@intCast(u128, @maxValue(u128)) >> shift2_amt_u7)) != 0);
  227447:	c4 62 f3 f7 da       	shrx   r11,rdx,rcx
  22744c:	45 31 f6             	xor    r14d,r14d
  22744f:	f6 c1 40             	test   cl,0x40
  227452:	4d 0f 45 d3          	cmovne r10,r11
  227456:	4d 0f 45 de          	cmovne r11,r14
  22745a:	41 83 e0 7f          	and    r8d,0x7f
  22745e:	48 c7 c3 ff ff ff ff 	mov    rbx,0xffffffffffffffff
  227465:	c4 62 bb f7 fb       	shrx   r15,rbx,r8
  22746a:	44 89 c1             	mov    ecx,r8d
  22746d:	48 0f ad db          	shrd   rbx,rbx,cl
  227471:	41 f6 c0 40          	test   r8b,0x40
  227475:	49 0f 45 df          	cmovne rbx,r15
  227479:	4d 0f 45 fe          	cmovne r15,r14
  22747d:	48 21 fb             	and    rbx,rdi
  227480:	49 21 d7             	and    r15,rdx
  227483:	31 ff                	xor    edi,edi
  227485:	49 09 df             	or     r15,rbx
  227488:	40 0f 95 c7          	setne  dil
  22748c:	4c 09 d7             	or     rdi,r10
  22748f:	4c 89 da             	mov    rdx,r11
  227492:	eb 35                	jmp    2274c9 <__floattidf+0xf9>
        return 0.0;
  227494:	c5 f8 57 c0          	vxorps xmm0,xmm0,xmm0
  227498:	c3                   	ret    
            a >>= 1;
            e += 1;
        }
        // a is now rounded to DBL_MANT_DIG bits
    } else {
        a <<= @intCast(u7, DBL_MANT_DIG - sd);
  227499:	b9 35 00 00 00       	mov    ecx,0x35
  22749e:	44 29 c9             	sub    ecx,r9d
  2274a1:	83 e1 7f             	and    ecx,0x7f
  2274a4:	48 0f a5 fa          	shld   rdx,rdi,cl
  2274a8:	c4 e2 f1 f7 df       	shlx   rbx,rdi,rcx
  2274ad:	31 ff                	xor    edi,edi
  2274af:	f6 c1 40             	test   cl,0x40
  2274b2:	48 0f 45 d3          	cmovne rdx,rbx
  2274b6:	48 0f 44 fb          	cmove  rdi,rbx
    if (sd > DBL_MANT_DIG) {
  2274ba:	48 0f a4 fa 20       	shld   rdx,rdi,0x20
  2274bf:	eb 40                	jmp    227501 <__floattidf+0x131>
                a <<= 1;
  2274c1:	48 0f a4 fa 01       	shld   rdx,rdi,0x1
  2274c6:	48 01 ff             	add    rdi,rdi
        a |= @boolToInt((a & 4) != 0); // Or P into R
  2274c9:	b9 02 01 00 00       	mov    ecx,0x102
  2274ce:	c4 e2 70 f7 cf       	bextr  ecx,edi,ecx
  2274d3:	48 09 f9             	or     rcx,rdi
        a += 1; // round - this step may add a significant bit
  2274d6:	48 83 c1 01          	add    rcx,0x1
  2274da:	48 83 d2 00          	adc    rdx,0x0
            a >>= 1;
  2274de:	48 89 d7             	mov    rdi,rdx
        if ((a & (u128(1) << DBL_MANT_DIG)) != 0) {
  2274e1:	48 0f ba e1 37       	bt     rcx,0x37
  2274e6:	72 0c                	jb     2274f4 <__floattidf+0x124>
  2274e8:	48 0f a4 cf 3e       	shld   rdi,rcx,0x3e
  2274ed:	48 0f a4 ca 1e       	shld   rdx,rcx,0x1e
  2274f2:	eb 0d                	jmp    227501 <__floattidf+0x131>
            a >>= 1;
  2274f4:	48 0f a4 cf 3d       	shld   rdi,rcx,0x3d
        if ((a & (u128(1) << DBL_MANT_DIG)) != 0) {
  2274f9:	48 0f a4 ca 1d       	shld   rdx,rcx,0x1d
  2274fe:	44 89 c8             	mov    eax,r9d
        // a is now rounded to DBL_MANT_DIG bits
    }

    const s = @bitCast(u128, arg) >> (128 - 32);
  227501:	48 c1 ee 20          	shr    rsi,0x20
    const high: u64 = (@intCast(u64, s) & 0x80000000) | // sign
  227505:	81 e6 00 00 00 80    	and    esi,0x80000000
        (@intCast(u32, (e + 1023)) << 20) | // exponent
  22750b:	c1 e0 14             	shl    eax,0x14
  22750e:	05 00 00 f0 3f       	add    eax,0x3ff00000
    const high: u64 = (@intCast(u64, s) & 0x80000000) | // sign
  227513:	09 f0                	or     eax,esi
        (@truncate(u32, a >> 32) & 0x000fffff); // mantissa-high
  227515:	81 e2 ff ff 0f 00    	and    edx,0xfffff
        (@intCast(u32, (e + 1023)) << 20) | // exponent
  22751b:	09 c2                	or     edx,eax
    const low: u64 = @truncate(u32, a); // mantissa-low
  22751d:	89 f8                	mov    eax,edi

    return @bitCast(f64, low | (high << 32));
  22751f:	48 c1 e2 20          	shl    rdx,0x20
  227523:	48 09 c2             	or     rdx,rax
  227526:	c4 e1 f9 6e c2       	vmovq  xmm0,rdx
  22752b:	5b                   	pop    rbx
  22752c:	41 5e                	pop    r14
  22752e:	41 5f                	pop    r15
  227530:	c3                   	ret    
  227531:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  227538:	0f 1f 84 00 00 00 00 
  22753f:	00 

0000000000227540 <__floattisf>:
const FLT_MANT_DIG = 24;

pub extern fn __floattisf(arg: i128) f32 {
    @setRuntimeSafety(is_test);

    if (arg == 0)
  227540:	48 89 f8             	mov    rax,rdi
  227543:	48 09 f0             	or     rax,rsi
  227546:	0f 84 b2 00 00 00    	je     2275fe <__floattisf+0xbe>
        return 0.0;

    var ai = arg;
    const N: u32 = 128;
    const si = ai >> @intCast(u7, (N - 1));
  22754c:	48 89 f1             	mov    rcx,rsi
  22754f:	48 c1 f9 3f          	sar    rcx,0x3f
    ai = ((ai ^ si) -% si);
  227553:	48 89 c8             	mov    rax,rcx
  227556:	48 31 f0             	xor    rax,rsi
  227559:	48 31 cf             	xor    rdi,rcx
  22755c:	48 29 cf             	sub    rdi,rcx
  22755f:	48 19 c8             	sbb    rax,rcx
    var a = @bitCast(u128, ai);

    const sd = @bitCast(i32, N - @clz(a)); // number of significant digits
  227562:	f3 48 0f bd d0       	lzcnt  rdx,rax
  227567:	f3 48 0f bd cf       	lzcnt  rcx,rdi
  22756c:	83 c1 40             	add    ecx,0x40
  22756f:	48 85 c0             	test   rax,rax
  227572:	0f 45 ca             	cmovne ecx,edx
  227575:	41 b9 80 00 00 00    	mov    r9d,0x80
  22757b:	41 29 c9             	sub    r9d,ecx
    var e: i32 = sd - 1; // exponent
  22757e:	ba 7f 00 00 00       	mov    edx,0x7f
  227583:	29 ca                	sub    edx,ecx

    if (sd > FLT_MANT_DIG) {
  227585:	41 83 f9 19          	cmp    r9d,0x19
  227589:	7c 78                	jl     227603 <__floattisf+0xc3>
        //                                                12345678901234567890123456
        //  1 = msb 1 bit
        //  P = bit FLT_MANT_DIG-1 bits to the right of 1
        //  Q = bit FLT_MANT_DIG bits to the right of 1
        //  R = "or" of all bits to the right of Q
        switch (sd) {
  22758b:	0f 84 8d 00 00 00    	je     22761e <__floattisf+0xde>
  227591:	41 83 f9 1a          	cmp    r9d,0x1a
  227595:	0f 84 86 00 00 00    	je     227621 <__floattisf+0xe1>
            FLT_MANT_DIG + 1 => {
                a <<= 1;
            },
            FLT_MANT_DIG + 2 => {},
            else => {
                const shift1_amt = @intCast(i32, sd - (FLT_MANT_DIG + 2));
  22759b:	41 56                	push   r14
  22759d:	53                   	push   rbx
  22759e:	41 8d 49 66          	lea    ecx,[r9+0x66]
                const shift1_amt_u7 = @intCast(u7, shift1_amt);

                const shift2_amt = @intCast(i32, N + (FLT_MANT_DIG + 2)) - sd;
                const shift2_amt_u7 = @intCast(u7, shift2_amt);

                a = (a >> shift1_amt_u7) | @boolToInt((a & (@intCast(u128, @maxValue(u128)) >> shift2_amt_u7)) != 0);
  2275a2:	83 e1 7f             	and    ecx,0x7f
  2275a5:	49 89 fa             	mov    r10,rdi
  2275a8:	49 0f ad c2          	shrd   r10,rax,cl
                const shift2_amt = @intCast(i32, N + (FLT_MANT_DIG + 2)) - sd;
  2275ac:	41 b8 1a 00 00 00    	mov    r8d,0x1a
  2275b2:	45 29 c8             	sub    r8d,r9d
                a = (a >> shift1_amt_u7) | @boolToInt((a & (@intCast(u128, @maxValue(u128)) >> shift2_amt_u7)) != 0);
  2275b5:	c4 62 f3 f7 d8       	shrx   r11,rax,rcx
  2275ba:	45 31 f6             	xor    r14d,r14d
  2275bd:	f6 c1 40             	test   cl,0x40
  2275c0:	4d 0f 44 da          	cmove  r11,r10
  2275c4:	41 83 e0 7f          	and    r8d,0x7f
  2275c8:	48 c7 c3 ff ff ff ff 	mov    rbx,0xffffffffffffffff
  2275cf:	c4 62 bb f7 d3       	shrx   r10,rbx,r8
  2275d4:	44 89 c1             	mov    ecx,r8d
  2275d7:	48 0f ad db          	shrd   rbx,rbx,cl
  2275db:	41 f6 c0 40          	test   r8b,0x40
  2275df:	49 0f 45 da          	cmovne rbx,r10
  2275e3:	4d 0f 44 f2          	cmove  r14,r10
  2275e7:	48 21 fb             	and    rbx,rdi
  2275ea:	49 21 c6             	and    r14,rax
  2275ed:	31 ff                	xor    edi,edi
  2275ef:	49 09 de             	or     r14,rbx
  2275f2:	40 0f 95 c7          	setne  dil
  2275f6:	4c 09 df             	or     rdi,r11
        switch (sd) {
  2275f9:	5b                   	pop    rbx
  2275fa:	41 5e                	pop    r14
  2275fc:	eb 23                	jmp    227621 <__floattisf+0xe1>
        return 0.0;
  2275fe:	c5 f8 57 c0          	vxorps xmm0,xmm0,xmm0
  227602:	c3                   	ret    
            a >>= 1;
            e += 1;
        }
        // a is now rounded to FLT_MANT_DIG bits
    } else {
        a <<= @intCast(u7, FLT_MANT_DIG - sd);
  227603:	b9 18 00 00 00       	mov    ecx,0x18
  227608:	44 29 c9             	sub    ecx,r9d
  22760b:	83 e1 7f             	and    ecx,0x7f
  22760e:	c4 e2 f1 f7 ff       	shlx   rdi,rdi,rcx
  227613:	31 c0                	xor    eax,eax
  227615:	f6 c1 40             	test   cl,0x40
  227618:	48 0f 44 c7          	cmove  rax,rdi
  22761c:	eb 28                	jmp    227646 <__floattisf+0x106>
                a <<= 1;
  22761e:	48 01 ff             	add    rdi,rdi
        a |= @boolToInt((a & 4) != 0); // Or P into R
  227621:	b8 02 01 00 00       	mov    eax,0x102
  227626:	c4 e2 78 f7 c7       	bextr  eax,edi,eax
  22762b:	48 09 f8             	or     rax,rdi
        a += 1; // round - this step may add a significant bit
  22762e:	48 83 c0 01          	add    rax,0x1
        if ((a & (u128(1) << FLT_MANT_DIG)) != 0) {
  227632:	a9 00 00 00 04       	test   eax,0x4000000
  227637:	75 06                	jne    22763f <__floattisf+0xff>
  227639:	48 c1 e8 02          	shr    rax,0x2
  22763d:	eb 07                	jmp    227646 <__floattisf+0x106>
            a >>= 1;
  22763f:	48 c1 e8 03          	shr    rax,0x3
  227643:	44 89 ca             	mov    edx,r9d
        // a is now rounded to FLT_MANT_DIG bits
    }

    const s = @bitCast(u128, arg) >> (128 - 32);
  227646:	48 c1 ee 20          	shr    rsi,0x20
    const r = (@intCast(u32, s) & 0x80000000) | // sign
  22764a:	81 e6 00 00 00 80    	and    esi,0x80000000
        (@intCast(u32, (e + 127)) << 23) | // exponent
  227650:	c1 e2 17             	shl    edx,0x17
  227653:	81 c2 00 00 80 3f    	add    edx,0x3f800000
    const r = (@intCast(u32, s) & 0x80000000) | // sign
  227659:	09 f2                	or     edx,esi
        (@truncate(u32, a) & 0x007fffff); // mantissa-high
  22765b:	25 ff ff 7f 00       	and    eax,0x7fffff
        (@intCast(u32, (e + 127)) << 23) | // exponent
  227660:	09 d0                	or     eax,edx

    return @bitCast(f32, r);
  227662:	c5 f9 6e c0          	vmovd  xmm0,eax
  227666:	c3                   	ret    
  227667:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  22766e:	00 00 

0000000000227670 <__floatunditf>:
const std = @import("std");

pub extern fn __floatunditf(a: u128) f128 {
    @setRuntimeSafety(is_test);

    if (a == 0) {
  227670:	48 89 f8             	mov    rax,rdi
  227673:	48 09 f0             	or     rax,rsi
  227676:	74 0f                	je     227687 <__floatunditf+0x17>
    const mantissa_bits = std.math.floatMantissaBits(f128);
    const exponent_bits = std.math.floatExponentBits(f128);
    const exponent_bias = (1 << (exponent_bits - 1)) - 1;
    const implicit_bit = 1 << mantissa_bits;

    const exp = (u128.bit_count - 1) - @clz(a);
  227678:	48 85 f6             	test   rsi,rsi
  22767b:	75 12                	jne    22768f <__floatunditf+0x1f>
  22767d:	f3 48 0f bd c7       	lzcnt  rax,rdi
  227682:	83 c0 40             	add    eax,0x40
  227685:	eb 0d                	jmp    227694 <__floatunditf+0x24>
        return 0;
  227687:	0f 28 05 82 8c fd ff 	movaps xmm0,XMMWORD PTR [rip+0xfffffffffffd8c82]        # 200310 <__unnamed_18>
  22768e:	c3                   	ret    
  22768f:	f3 48 0f bd c6       	lzcnt  rax,rsi
  227694:	b2 7f                	mov    dl,0x7f
    const exp = (u128.bit_count - 1) - @clz(a);
  227696:	28 c2                	sub    dl,al
  227698:	b1 70                	mov    cl,0x70
    const shift = mantissa_bits - @intCast(u7, exp);
  22769a:	28 d1                	sub    cl,dl

    var result: u128 align(16) = (a << shift) ^ implicit_bit;
  22769c:	48 0f a5 fe          	shld   rsi,rdi,cl
  2276a0:	c4 e2 f1 f7 c7       	shlx   rax,rdi,rcx
  2276a5:	31 ff                	xor    edi,edi
  2276a7:	f6 c1 40             	test   cl,0x40
  2276aa:	48 0f 45 f0          	cmovne rsi,rax
  2276ae:	48 0f 44 f8          	cmove  rdi,rax
  2276b2:	48 b8 00 00 00 00 00 	movabs rax,0x1000000000000
  2276b9:	00 01 00 
  2276bc:	48 31 f0             	xor    rax,rsi
    result += (@intCast(u128, exp) + exponent_bias) << mantissa_bits;
  2276bf:	0f b6 ca             	movzx  ecx,dl
  2276c2:	48 c1 e1 30          	shl    rcx,0x30
  2276c6:	48 01 c1             	add    rcx,rax
  2276c9:	48 89 7c 24 e8       	mov    QWORD PTR [rsp-0x18],rdi
  2276ce:	48 b8 00 00 00 00 00 	movabs rax,0x3fff000000000000
  2276d5:	00 ff 3f 
  2276d8:	48 01 c8             	add    rax,rcx
  2276db:	48 89 44 24 f0       	mov    QWORD PTR [rsp-0x10],rax
  2276e0:	0f 28 44 24 e8       	movaps xmm0,XMMWORD PTR [rsp-0x18]

    return @bitCast(f128, result);
  2276e5:	c3                   	ret    
  2276e6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  2276ed:	00 00 00 

00000000002276f0 <__floatunsitf>:
const std = @import("std");

pub extern fn __floatunsitf(a: u64) f128 {
    @setRuntimeSafety(is_test);

    if (a == 0) {
  2276f0:	48 85 ff             	test   rdi,rdi
  2276f3:	74 5c                	je     227751 <__floatunsitf+0x61>
    const mantissa_bits = std.math.floatMantissaBits(f128);
    const exponent_bits = std.math.floatExponentBits(f128);
    const exponent_bias = (1 << (exponent_bits - 1)) - 1;
    const implicit_bit = 1 << mantissa_bits;

    const exp = (u64.bit_count - 1) - @clz(a);
  2276f5:	f3 48 0f bd c7       	lzcnt  rax,rdi
  2276fa:	b2 3f                	mov    dl,0x3f
  2276fc:	28 c2                	sub    dl,al
  2276fe:	b1 70                	mov    cl,0x70
    const shift = mantissa_bits - @intCast(u7, exp);
  227700:	28 d1                	sub    cl,dl
  227702:	31 c0                	xor    eax,eax

    // TODO(#1148): @bitCast alignment error
    var result align(16) = (@intCast(u128, a) << shift) ^ implicit_bit;
  227704:	31 f6                	xor    esi,esi
  227706:	48 0f a5 fe          	shld   rsi,rdi,cl
  22770a:	c4 e2 f1 f7 ff       	shlx   rdi,rdi,rcx
  22770f:	f6 c1 40             	test   cl,0x40
  227712:	48 0f 45 f7          	cmovne rsi,rdi
  227716:	48 0f 45 f8          	cmovne rdi,rax
  22771a:	48 b8 00 00 00 00 00 	movabs rax,0x1000000000000
  227721:	00 01 00 
  227724:	48 31 f0             	xor    rax,rsi
    result += (@intCast(u128, exp) + exponent_bias) << mantissa_bits;
  227727:	0f b6 ca             	movzx  ecx,dl
  22772a:	83 e1 7f             	and    ecx,0x7f
  22772d:	48 c1 e1 30          	shl    rcx,0x30
  227731:	48 01 c1             	add    rcx,rax
  227734:	48 89 7c 24 e8       	mov    QWORD PTR [rsp-0x18],rdi
  227739:	48 b8 00 00 00 00 00 	movabs rax,0x3fff000000000000
  227740:	00 ff 3f 
  227743:	48 01 c8             	add    rax,rcx
  227746:	48 89 44 24 f0       	mov    QWORD PTR [rsp-0x10],rax
  22774b:	0f 28 44 24 e8       	movaps xmm0,XMMWORD PTR [rsp-0x18]

    return @bitCast(f128, result);
  227750:	c3                   	ret    
        return 0;
  227751:	0f 28 05 b8 8b fd ff 	movaps xmm0,XMMWORD PTR [rip+0xfffffffffffd8bb8]        # 200310 <__unnamed_18>
  227758:	c3                   	ret    
  227759:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

0000000000227760 <__floatuntitf>:
const LDBL_MANT_DIG = 113;

pub extern fn __floatuntitf(arg: u128) f128 {
    @setRuntimeSafety(is_test);

    if (arg == 0)
  227760:	48 89 f8             	mov    rax,rdi
  227763:	48 09 f0             	or     rax,rsi
  227766:	0f 84 a0 00 00 00    	je     22780c <__floatuntitf+0xac>
        return 0.0;

    var a = arg;
    const N: u32 = @sizeOf(u128) * 8;
    const sd = @bitCast(i32, N - @clz(a)); // number of significant digits
  22776c:	41 56                	push   r14
  22776e:	53                   	push   rbx
  22776f:	f3 48 0f bd c6       	lzcnt  rax,rsi
  227774:	f3 48 0f bd cf       	lzcnt  rcx,rdi
  227779:	83 c1 40             	add    ecx,0x40
  22777c:	48 85 f6             	test   rsi,rsi
  22777f:	0f 45 c8             	cmovne ecx,eax
  227782:	41 b9 80 00 00 00    	mov    r9d,0x80
  227788:	41 29 c9             	sub    r9d,ecx
    var e: i32 = sd - 1; // exponent
  22778b:	ba 7f 00 00 00       	mov    edx,0x7f
  227790:	29 ca                	sub    edx,ecx
    if (sd > LDBL_MANT_DIG) {
  227792:	41 83 f9 72          	cmp    r9d,0x72
  227796:	7c 7c                	jl     227814 <__floatuntitf+0xb4>
        //                                                12345678901234567890123456
        //  1 = msb 1 bit
        //  P = bit LDBL_MANT_DIG-1 bits to the right of 1
        //  Q = bit LDBL_MANT_DIG bits to the right of 1
        //  R = "or" of all bits to the right of Q
        switch (sd) {
  227798:	0f 84 99 00 00 00    	je     227837 <__floatuntitf+0xd7>
  22779e:	41 83 f9 73          	cmp    r9d,0x73
  2277a2:	0f 84 97 00 00 00    	je     22783f <__floatuntitf+0xdf>
            LDBL_MANT_DIG + 1 => {
                a <<= 1;
            },
            LDBL_MANT_DIG + 2 => {},
            else => {
                const shift_amt = @bitCast(i32, N + (LDBL_MANT_DIG + 2)) - sd;
  2277a8:	41 b8 73 00 00 00    	mov    r8d,0x73
                const shift_amt_u7 = @intCast(u7, shift_amt);
                a = (a >> @intCast(u7, sd - (LDBL_MANT_DIG + 2))) |
  2277ae:	41 8d 49 0d          	lea    ecx,[r9+0xd]
  2277b2:	83 e1 7f             	and    ecx,0x7f
  2277b5:	49 89 fe             	mov    r14,rdi
  2277b8:	49 0f ad f6          	shrd   r14,rsi,cl
                const shift_amt = @bitCast(i32, N + (LDBL_MANT_DIG + 2)) - sd;
  2277bc:	45 29 c8             	sub    r8d,r9d
                a = (a >> @intCast(u7, sd - (LDBL_MANT_DIG + 2))) |
  2277bf:	c4 62 f3 f7 d6       	shrx   r10,rsi,rcx
  2277c4:	45 31 db             	xor    r11d,r11d
  2277c7:	f6 c1 40             	test   cl,0x40
  2277ca:	4d 0f 45 f2          	cmovne r14,r10
  2277ce:	4d 0f 45 d3          	cmovne r10,r11
                    @boolToInt((a & (u128(@maxValue(u128)) >> shift_amt_u7)) != 0);
  2277d2:	41 83 e0 7f          	and    r8d,0x7f
  2277d6:	48 c7 c3 ff ff ff ff 	mov    rbx,0xffffffffffffffff
  2277dd:	c4 e2 bb f7 c3       	shrx   rax,rbx,r8
  2277e2:	44 89 c1             	mov    ecx,r8d
  2277e5:	48 0f ad db          	shrd   rbx,rbx,cl
  2277e9:	41 f6 c0 40          	test   r8b,0x40
  2277ed:	48 0f 45 d8          	cmovne rbx,rax
  2277f1:	49 0f 45 c3          	cmovne rax,r11
  2277f5:	48 21 fb             	and    rbx,rdi
  2277f8:	48 21 f0             	and    rax,rsi
  2277fb:	31 ff                	xor    edi,edi
  2277fd:	48 09 d8             	or     rax,rbx
  227800:	40 0f 95 c7          	setne  dil
                a = (a >> @intCast(u7, sd - (LDBL_MANT_DIG + 2))) |
  227804:	4c 09 f7             	or     rdi,r14
  227807:	4c 89 d6             	mov    rsi,r10
  22780a:	eb 33                	jmp    22783f <__floatuntitf+0xdf>
        return 0.0;
  22780c:	0f 28 05 fd 8a fd ff 	movaps xmm0,XMMWORD PTR [rip+0xfffffffffffd8afd]        # 200310 <__unnamed_18>
  227813:	c3                   	ret    
            a >>= 1;
            e += 1;
        }
        // a is now rounded to LDBL_MANT_DIG bits
    } else {
        a <<= @intCast(u7, LDBL_MANT_DIG - sd);
  227814:	b9 71 00 00 00       	mov    ecx,0x71
  227819:	44 29 c9             	sub    ecx,r9d
  22781c:	83 e1 7f             	and    ecx,0x7f
  22781f:	48 0f a5 fe          	shld   rsi,rdi,cl
  227823:	c4 e2 f1 f7 ff       	shlx   rdi,rdi,rcx
  227828:	31 c0                	xor    eax,eax
  22782a:	f6 c1 40             	test   cl,0x40
  22782d:	48 0f 45 f7          	cmovne rsi,rdi
  227831:	48 0f 44 c7          	cmove  rax,rdi
  227835:	eb 3b                	jmp    227872 <__floatuntitf+0x112>
                a <<= 1;
  227837:	48 0f a4 fe 01       	shld   rsi,rdi,0x1
  22783c:	48 01 ff             	add    rdi,rdi
        a |= @boolToInt((a & 4) != 0); // Or P into R
  22783f:	b8 02 01 00 00       	mov    eax,0x102
  227844:	c4 e2 78 f7 c7       	bextr  eax,edi,eax
  227849:	48 09 f8             	or     rax,rdi
        a += 1; // round - this step may add a significant bit
  22784c:	48 83 c0 01          	add    rax,0x1
  227850:	48 83 d6 00          	adc    rsi,0x0
        if ((a & (u128(1) << LDBL_MANT_DIG)) != 0) {
  227854:	48 0f ba e6 33       	bt     rsi,0x33
  227859:	72 0b                	jb     227866 <__floatuntitf+0x106>
  22785b:	48 0f ac f0 02       	shrd   rax,rsi,0x2
  227860:	48 c1 ee 02          	shr    rsi,0x2
  227864:	eb 0c                	jmp    227872 <__floatuntitf+0x112>
            a >>= 1;
  227866:	48 0f ac f0 03       	shrd   rax,rsi,0x3
  22786b:	48 c1 ee 03          	shr    rsi,0x3
  22786f:	44 89 ca             	mov    edx,r9d
        // a is now rounded to LDBL_MANT_DIG bits
    }

    const high: u128 = (@intCast(u64, (e + 16383)) << 48) | // exponent
  227872:	81 c2 ff 3f 00 00    	add    edx,0x3fff
  227878:	48 c1 e2 30          	shl    rdx,0x30
        (@truncate(u64, a >> 64) & 0x0000ffffffffffff); // mantissa-high
  22787c:	b1 30                	mov    cl,0x30
  22787e:	c4 e2 f0 f5 ce       	bzhi   rcx,rsi,rcx
    const low = @truncate(u64, a); // mantissa-low

    return @bitCast(f128, low | (high << 64));
  227883:	48 89 44 24 e8       	mov    QWORD PTR [rsp-0x18],rax
    const high: u128 = (@intCast(u64, (e + 16383)) << 48) | // exponent
  227888:	48 09 d1             	or     rcx,rdx
    return @bitCast(f128, low | (high << 64));
  22788b:	48 89 4c 24 f0       	mov    QWORD PTR [rsp-0x10],rcx
  227890:	0f 28 44 24 e8       	movaps xmm0,XMMWORD PTR [rsp-0x18]
  227895:	5b                   	pop    rbx
  227896:	41 5e                	pop    r14
  227898:	c3                   	ret    
  227899:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

00000000002278a0 <__floatuntidf>:
const DBL_MANT_DIG = 53;

pub extern fn __floatuntidf(arg: u128) f64 {
    @setRuntimeSafety(is_test);

    if (arg == 0)
  2278a0:	48 89 f8             	mov    rax,rdi
  2278a3:	48 09 f0             	or     rax,rsi
  2278a6:	0f 84 a0 00 00 00    	je     22794c <__floatuntidf+0xac>
        return 0.0;

    var a = arg;
    const N: u32 = @sizeOf(u128) * 8;
    const sd = @bitCast(i32, N - @clz(a)); // number of significant digits
  2278ac:	f3 48 0f bd c6       	lzcnt  rax,rsi
  2278b1:	f3 48 0f bd cf       	lzcnt  rcx,rdi
  2278b6:	83 c1 40             	add    ecx,0x40
  2278b9:	48 85 f6             	test   rsi,rsi
  2278bc:	0f 45 c8             	cmovne ecx,eax
  2278bf:	ba 80 00 00 00       	mov    edx,0x80
  2278c4:	29 ca                	sub    edx,ecx
    var e: i32 = sd - 1; // exponent
  2278c6:	41 bb 7f 00 00 00    	mov    r11d,0x7f
  2278cc:	41 29 cb             	sub    r11d,ecx
    if (sd > DBL_MANT_DIG) {
  2278cf:	83 fa 36             	cmp    edx,0x36
  2278d2:	7c 7d                	jl     227951 <__floatuntidf+0xb1>
        //                                                12345678901234567890123456
        //  1 = msb 1 bit
        //  P = bit DBL_MANT_DIG-1 bits to the right of 1
        //  Q = bit DBL_MANT_DIG bits to the right of 1
        //  R = "or" of all bits to the right of Q
        switch (sd) {
  2278d4:	0f 84 97 00 00 00    	je     227971 <__floatuntidf+0xd1>
  2278da:	83 fa 37             	cmp    edx,0x37
  2278dd:	0f 84 96 00 00 00    	je     227979 <__floatuntidf+0xd9>
            DBL_MANT_DIG + 1 => {
                a <<= 1;
            },
            DBL_MANT_DIG + 2 => {},
            else => {
                const shift_amt = @bitCast(i32, N + (DBL_MANT_DIG + 2)) - sd;
  2278e3:	41 56                	push   r14
  2278e5:	53                   	push   rbx
  2278e6:	41 b8 37 00 00 00    	mov    r8d,0x37
                const shift_amt_u7 = @intCast(u7, shift_amt);
                a = (a >> @intCast(u7, sd - (DBL_MANT_DIG + 2))) |
  2278ec:	8d 4a 49             	lea    ecx,[rdx+0x49]
  2278ef:	83 e1 7f             	and    ecx,0x7f
  2278f2:	49 89 f9             	mov    r9,rdi
  2278f5:	49 0f ad f1          	shrd   r9,rsi,cl
                const shift_amt = @bitCast(i32, N + (DBL_MANT_DIG + 2)) - sd;
  2278f9:	41 29 d0             	sub    r8d,edx
                a = (a >> @intCast(u7, sd - (DBL_MANT_DIG + 2))) |
  2278fc:	c4 62 f3 f7 d6       	shrx   r10,rsi,rcx
  227901:	45 31 f6             	xor    r14d,r14d
  227904:	f6 c1 40             	test   cl,0x40
  227907:	4d 0f 45 ca          	cmovne r9,r10
  22790b:	4d 0f 45 d6          	cmovne r10,r14
                    @boolToInt((a & (u128(@maxValue(u128)) >> shift_amt_u7)) != 0);
  22790f:	41 83 e0 7f          	and    r8d,0x7f
  227913:	48 c7 c3 ff ff ff ff 	mov    rbx,0xffffffffffffffff
  22791a:	c4 e2 bb f7 c3       	shrx   rax,rbx,r8
  22791f:	44 89 c1             	mov    ecx,r8d
  227922:	48 0f ad db          	shrd   rbx,rbx,cl
  227926:	41 f6 c0 40          	test   r8b,0x40
  22792a:	48 0f 45 d8          	cmovne rbx,rax
  22792e:	49 0f 45 c6          	cmovne rax,r14
  227932:	48 21 fb             	and    rbx,rdi
  227935:	48 21 f0             	and    rax,rsi
  227938:	31 ff                	xor    edi,edi
  22793a:	48 09 d8             	or     rax,rbx
  22793d:	40 0f 95 c7          	setne  dil
                a = (a >> @intCast(u7, sd - (DBL_MANT_DIG + 2))) |
  227941:	4c 09 cf             	or     rdi,r9
  227944:	4c 89 d6             	mov    rsi,r10
        switch (sd) {
  227947:	5b                   	pop    rbx
  227948:	41 5e                	pop    r14
  22794a:	eb 2d                	jmp    227979 <__floatuntidf+0xd9>
        return 0.0;
  22794c:	c5 f8 57 c0          	vxorps xmm0,xmm0,xmm0
  227950:	c3                   	ret    
            a >>= 1;
            e += 1;
        }
        // a is now rounded to DBL_MANT_DIG bits
    } else {
        a <<= @intCast(u7, DBL_MANT_DIG - sd);
  227951:	b8 35 00 00 00       	mov    eax,0x35
  227956:	29 d0                	sub    eax,edx
  227958:	83 e0 7f             	and    eax,0x7f
  22795b:	c4 e2 f9 f7 d7       	shlx   rdx,rdi,rax
  227960:	31 c9                	xor    ecx,ecx
  227962:	a8 40                	test   al,0x40
  227964:	48 0f 44 ca          	cmove  rcx,rdx
    if (sd > DBL_MANT_DIG) {
  227968:	48 89 ce             	mov    rsi,rcx
  22796b:	48 c1 ee 20          	shr    rsi,0x20
  22796f:	eb 48                	jmp    2279b9 <__floatuntidf+0x119>
                a <<= 1;
  227971:	48 0f a4 fe 01       	shld   rsi,rdi,0x1
  227976:	48 01 ff             	add    rdi,rdi
        a |= @boolToInt((a & 4) != 0); // Or P into R
  227979:	b8 02 01 00 00       	mov    eax,0x102
  22797e:	c4 e2 78 f7 c7       	bextr  eax,edi,eax
  227983:	48 09 f8             	or     rax,rdi
        a += 1; // round - this step may add a significant bit
  227986:	48 83 c0 01          	add    rax,0x1
  22798a:	48 83 d6 00          	adc    rsi,0x0
            a >>= 1;
  22798e:	48 89 f1             	mov    rcx,rsi
        if ((a & (u128(1) << DBL_MANT_DIG)) != 0) {
  227991:	48 0f ba e0 37       	bt     rax,0x37
  227996:	72 10                	jb     2279a8 <__floatuntidf+0x108>
  227998:	48 0f a4 c1 3e       	shld   rcx,rax,0x3e
  22799d:	48 c1 e8 22          	shr    rax,0x22
  2279a1:	c1 e6 1e             	shl    esi,0x1e
  2279a4:	09 c6                	or     esi,eax
  2279a6:	eb 11                	jmp    2279b9 <__floatuntidf+0x119>
            a >>= 1;
  2279a8:	48 0f a4 c1 3d       	shld   rcx,rax,0x3d
        if ((a & (u128(1) << DBL_MANT_DIG)) != 0) {
  2279ad:	48 c1 e8 23          	shr    rax,0x23
  2279b1:	c1 e6 1d             	shl    esi,0x1d
  2279b4:	09 c6                	or     esi,eax
  2279b6:	41 89 d3             	mov    r11d,edx
        // a is now rounded to DBL_MANT_DIG bits
    }

    const high: u64 = @bitCast(u32, (e + 1023) << 20) | // exponent
  2279b9:	41 c1 e3 14          	shl    r11d,0x14
        (@truncate(u32, a >> 32) & 0x000FFFFF); // mantissa-high
  2279bd:	81 e6 ff ff 0f 00    	and    esi,0xfffff
    const high: u64 = @bitCast(u32, (e + 1023) << 20) | // exponent
  2279c3:	42 8d 04 1e          	lea    eax,[rsi+r11*1]
  2279c7:	05 00 00 f0 3f       	add    eax,0x3ff00000
    const low = @truncate(u32, a); // mantissa-low

    return @bitCast(f64, low | (high << 32));
  2279cc:	48 c1 e0 20          	shl    rax,0x20
  2279d0:	89 c9                	mov    ecx,ecx
  2279d2:	48 09 c1             	or     rcx,rax
  2279d5:	c4 e1 f9 6e c1       	vmovq  xmm0,rcx
  2279da:	c3                   	ret    
  2279db:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

00000000002279e0 <__floatuntisf>:
const FLT_MANT_DIG = 24;

pub extern fn __floatuntisf(arg: u128) f32 {
    @setRuntimeSafety(is_test);

    if (arg == 0)
  2279e0:	48 89 f8             	mov    rax,rdi
  2279e3:	48 09 f0             	or     rax,rsi
  2279e6:	0f 84 93 00 00 00    	je     227a7f <__floatuntisf+0x9f>
        return 0.0;

    var a = arg;
    const N: u32 = @sizeOf(u128) * 8;
    const sd = @bitCast(i32, N - @clz(a)); // number of significant digits
  2279ec:	f3 48 0f bd c6       	lzcnt  rax,rsi
  2279f1:	f3 48 0f bd cf       	lzcnt  rcx,rdi
  2279f6:	83 c1 40             	add    ecx,0x40
  2279f9:	48 85 f6             	test   rsi,rsi
  2279fc:	0f 45 c8             	cmovne ecx,eax
  2279ff:	ba 80 00 00 00       	mov    edx,0x80
  227a04:	29 ca                	sub    edx,ecx
    var e: i32 = sd - 1; // exponent
  227a06:	b8 7f 00 00 00       	mov    eax,0x7f
  227a0b:	29 c8                	sub    eax,ecx
    if (sd > FLT_MANT_DIG) {
  227a0d:	83 fa 19             	cmp    edx,0x19
  227a10:	7c 72                	jl     227a84 <__floatuntisf+0xa4>
        //                                                12345678901234567890123456
        //  1 = msb 1 bit
        //  P = bit FLT_MANT_DIG-1 bits to the right of 1
        //  Q = bit FLT_MANT_DIG bits to the right of 1
        //  R = "or" of all bits to the right of Q
        switch (sd) {
  227a12:	0f 84 87 00 00 00    	je     227a9f <__floatuntisf+0xbf>
  227a18:	83 fa 1a             	cmp    edx,0x1a
  227a1b:	0f 84 81 00 00 00    	je     227aa2 <__floatuntisf+0xc2>
            },
            FLT_MANT_DIG + 2 => {},
            else => {
                const shift_amt = @bitCast(i32, N + (FLT_MANT_DIG + 2)) - sd;
                const shift_amt_u7 = @intCast(u7, shift_amt);
                a = (a >> @intCast(u7, sd - (FLT_MANT_DIG + 2))) |
  227a21:	53                   	push   rbx
  227a22:	8d 4a 66             	lea    ecx,[rdx+0x66]
  227a25:	83 e1 7f             	and    ecx,0x7f
  227a28:	49 89 f9             	mov    r9,rdi
  227a2b:	49 0f ad f1          	shrd   r9,rsi,cl
                const shift_amt = @bitCast(i32, N + (FLT_MANT_DIG + 2)) - sd;
  227a2f:	41 b8 1a 00 00 00    	mov    r8d,0x1a
  227a35:	41 29 d0             	sub    r8d,edx
                a = (a >> @intCast(u7, sd - (FLT_MANT_DIG + 2))) |
  227a38:	c4 62 f3 f7 d6       	shrx   r10,rsi,rcx
  227a3d:	45 31 db             	xor    r11d,r11d
  227a40:	f6 c1 40             	test   cl,0x40
  227a43:	4d 0f 44 d1          	cmove  r10,r9
                    @boolToInt((a & (u128(@maxValue(u128)) >> shift_amt_u7)) != 0);
  227a47:	41 83 e0 7f          	and    r8d,0x7f
  227a4b:	49 c7 c1 ff ff ff ff 	mov    r9,0xffffffffffffffff
  227a52:	c4 c2 bb f7 d9       	shrx   rbx,r9,r8
  227a57:	44 89 c1             	mov    ecx,r8d
  227a5a:	4d 0f ad c9          	shrd   r9,r9,cl
  227a5e:	41 f6 c0 40          	test   r8b,0x40
  227a62:	4c 0f 45 cb          	cmovne r9,rbx
  227a66:	4c 0f 44 db          	cmove  r11,rbx
  227a6a:	49 21 f9             	and    r9,rdi
  227a6d:	49 21 f3             	and    r11,rsi
  227a70:	31 ff                	xor    edi,edi
  227a72:	4d 09 cb             	or     r11,r9
  227a75:	40 0f 95 c7          	setne  dil
                a = (a >> @intCast(u7, sd - (FLT_MANT_DIG + 2))) |
  227a79:	4c 09 d7             	or     rdi,r10
        switch (sd) {
  227a7c:	5b                   	pop    rbx
  227a7d:	eb 23                	jmp    227aa2 <__floatuntisf+0xc2>
        return 0.0;
  227a7f:	c5 f8 57 c0          	vxorps xmm0,xmm0,xmm0
  227a83:	c3                   	ret    
            a >>= 1;
            e += 1;
        }
        // a is now rounded to FLT_MANT_DIG bits
    } else {
        a <<= @intCast(u7, FLT_MANT_DIG - sd);
  227a84:	be 18 00 00 00       	mov    esi,0x18
  227a89:	29 d6                	sub    esi,edx
  227a8b:	83 e6 7f             	and    esi,0x7f
  227a8e:	c4 e2 c9 f7 d7       	shlx   rdx,rdi,rsi
  227a93:	31 c9                	xor    ecx,ecx
  227a95:	40 f6 c6 40          	test   sil,0x40
  227a99:	48 0f 44 ca          	cmove  rcx,rdx
  227a9d:	eb 28                	jmp    227ac7 <__floatuntisf+0xe7>
                a <<= 1;
  227a9f:	48 01 ff             	add    rdi,rdi
        a |= @boolToInt((a & 4) != 0); // Or P into R
  227aa2:	b9 02 01 00 00       	mov    ecx,0x102
  227aa7:	c4 e2 70 f7 cf       	bextr  ecx,edi,ecx
  227aac:	48 09 f9             	or     rcx,rdi
        a += 1; // round - this step may add a significant bit
  227aaf:	48 83 c1 01          	add    rcx,0x1
        if ((a & (u128(1) << FLT_MANT_DIG)) != 0) {
  227ab3:	f7 c1 00 00 00 04    	test   ecx,0x4000000
  227ab9:	75 06                	jne    227ac1 <__floatuntisf+0xe1>
  227abb:	48 c1 e9 02          	shr    rcx,0x2
  227abf:	eb 06                	jmp    227ac7 <__floatuntisf+0xe7>
            a >>= 1;
  227ac1:	48 c1 e9 03          	shr    rcx,0x3
  227ac5:	89 d0                	mov    eax,edx
        // a is now rounded to FLT_MANT_DIG bits
    }

    const high = @bitCast(u32, (e + 127) << 23); // exponent
  227ac7:	c1 e0 17             	shl    eax,0x17
    const low = @truncate(u32, a) & 0x007fffff; // mantissa
  227aca:	81 e1 ff ff 7f 00    	and    ecx,0x7fffff

    return @bitCast(f32, high | low);
  227ad0:	8d 04 08             	lea    eax,[rax+rcx*1]
  227ad3:	05 00 00 80 3f       	add    eax,0x3f800000
  227ad8:	c5 f9 6e c0          	vmovd  xmm0,eax
  227adc:	c3                   	ret    
  227add:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000227ae0 <__extenddftf2>:
    const aRep: src_rep_t = @bitCast(src_rep_t, a);
  227ae0:	c4 e1 f9 7e c1       	vmovq  rcx,xmm0
    const aAbs: src_rep_t = aRep & srcAbsMask;
  227ae5:	b0 3f                	mov    al,0x3f
  227ae7:	c4 e2 f8 f5 f1       	bzhi   rsi,rcx,rax
  227aec:	48 b8 ff ff ff ff ff 	movabs rax,0x7fffffffffffffff
  227af3:	ff ff 7f 
    const sign: src_rep_t = aRep & srcSignMask;
  227af6:	48 83 c0 01          	add    rax,0x1
  227afa:	48 21 c8             	and    rax,rcx
    if (aAbs -% srcMinNormal < srcInfinity - srcMinNormal) {
  227afd:	48 ba 00 00 00 00 00 	movabs rdx,0xfff0000000000000
  227b04:	00 f0 ff 
  227b07:	48 01 f2             	add    rdx,rsi
  227b0a:	48 c1 ea 35          	shr    rdx,0x35
  227b0e:	48 81 fa fe 03 00 00 	cmp    rdx,0x3fe
  227b15:	77 1a                	ja     227b31 <__extenddftf2+0x51>
        absResult = dst_rep_t(aAbs) << (dstSigBits - srcSigBits);
  227b17:	48 89 f2             	mov    rdx,rsi
  227b1a:	48 c1 e2 3c          	shl    rdx,0x3c
  227b1e:	48 c1 ee 04          	shr    rsi,0x4
        absResult += (dstExpBias - srcExpBias) << dstSigBits;
  227b22:	48 bf 00 00 00 00 00 	movabs rdi,0x3c00000000000000
  227b29:	00 00 3c 
  227b2c:	48 01 f7             	add    rdi,rsi
  227b2f:	eb 7a                	jmp    227bab <__extenddftf2+0xcb>
    } else if (aAbs >= srcInfinity) {
  227b31:	48 89 f2             	mov    rdx,rsi
  227b34:	48 c1 ea 34          	shr    rdx,0x34
  227b38:	48 81 fa ff 07 00 00 	cmp    rdx,0x7ff
  227b3f:	72 17                	jb     227b58 <__extenddftf2+0x78>
        absResult |= dst_rep_t(aAbs & srcNaNCode) << (dstSigBits - srcSigBits);
  227b41:	48 89 ca             	mov    rdx,rcx
  227b44:	48 c1 e2 3c          	shl    rdx,0x3c
  227b48:	48 c1 e9 04          	shr    rcx,0x4
  227b4c:	48 bf 00 00 00 00 00 	movabs rdi,0x7fff000000000000
  227b53:	00 ff 7f 
  227b56:	eb 4a                	jmp    227ba2 <__extenddftf2+0xc2>
    } else if (aAbs != 0) {
  227b58:	48 85 f6             	test   rsi,rsi
  227b5b:	74 4a                	je     227ba7 <__extenddftf2+0xc7>
        const scale: u32 = @clz(aAbs) - @clz(src_rep_t(srcMinNormal));
  227b5d:	f3 48 0f bd ce       	lzcnt  rcx,rsi
  227b62:	44 8d 41 75          	lea    r8d,[rcx+0x75]
  227b66:	41 83 e0 7f          	and    r8d,0x7f
        absResult = dst_rep_t(aAbs) << @intCast(DstShift, dstSigBits - srcSigBits + scale);
  227b6a:	83 c1 31             	add    ecx,0x31
  227b6d:	83 e1 7f             	and    ecx,0x7f
  227b70:	45 31 c9             	xor    r9d,r9d
  227b73:	31 ff                	xor    edi,edi
  227b75:	48 0f a5 f7          	shld   rdi,rsi,cl
  227b79:	c4 e2 f1 f7 d6       	shlx   rdx,rsi,rcx
  227b7e:	f6 c1 40             	test   cl,0x40
  227b81:	48 0f 45 fa          	cmovne rdi,rdx
  227b85:	49 0f 45 d1          	cmovne rdx,r9
        absResult ^= dstMinNormal;
  227b89:	48 b9 00 00 00 00 00 	movabs rcx,0x1000000000000
  227b90:	00 01 00 
  227b93:	48 31 f9             	xor    rcx,rdi
        const resultExponent: u32 = dstExpBias - srcExpBias - scale + 1;
  227b96:	bf 01 3c 00 00       	mov    edi,0x3c01
  227b9b:	44 29 c7             	sub    edi,r8d
        absResult |= @intCast(dst_rep_t, resultExponent) << dstSigBits;
  227b9e:	48 c1 e7 30          	shl    rdi,0x30
  227ba2:	48 09 cf             	or     rdi,rcx
  227ba5:	eb 04                	jmp    227bab <__extenddftf2+0xcb>
  227ba7:	31 d2                	xor    edx,edx
  227ba9:	31 ff                	xor    edi,edi
    const result: dst_rep_t align(@alignOf(dst_t)) = absResult | dst_rep_t(sign) << (dstBits - srcBits);
  227bab:	48 89 54 24 e8       	mov    QWORD PTR [rsp-0x18],rdx
  227bb0:	48 09 c7             	or     rdi,rax
  227bb3:	48 89 7c 24 f0       	mov    QWORD PTR [rsp-0x10],rdi
  227bb8:	0f 28 44 24 e8       	movaps xmm0,XMMWORD PTR [rsp-0x18]
    return extendXfYf2(f128, f64, a);
  227bbd:	c3                   	ret    
  227bbe:	66 90                	xchg   ax,ax

0000000000227bc0 <__extendsftf2>:
    const aRep: src_rep_t = @bitCast(src_rep_t, a);
  227bc0:	c5 f9 7e c2          	vmovd  edx,xmm0
    const aAbs: src_rep_t = aRep & srcAbsMask;
  227bc4:	89 d1                	mov    ecx,edx
  227bc6:	81 e1 ff ff ff 7f    	and    ecx,0x7fffffff
    const sign: src_rep_t = aRep & srcSignMask;
  227bcc:	89 d0                	mov    eax,edx
  227bce:	25 00 00 00 80       	and    eax,0x80000000
    if (aAbs -% srcMinNormal < srcInfinity - srcMinNormal) {
  227bd3:	8d b1 00 00 80 ff    	lea    esi,[rcx-0x800000]
  227bd9:	81 fe ff ff ff 7e    	cmp    esi,0x7effffff
  227bdf:	77 17                	ja     227bf8 <__extendsftf2+0x38>
        absResult = dst_rep_t(aAbs) << (dstSigBits - srcSigBits);
  227be1:	89 ca                	mov    edx,ecx
  227be3:	48 c1 e2 19          	shl    rdx,0x19
        absResult += (dstExpBias - srcExpBias) << dstSigBits;
  227be7:	48 b9 00 00 00 00 00 	movabs rcx,0x3f80000000000000
  227bee:	00 80 3f 
  227bf1:	48 01 d1             	add    rcx,rdx
  227bf4:	31 d2                	xor    edx,edx
  227bf6:	eb 6f                	jmp    227c67 <__extendsftf2+0xa7>
    } else if (aAbs >= srcInfinity) {
  227bf8:	81 f9 00 00 80 7f    	cmp    ecx,0x7f800000
  227bfe:	72 17                	jb     227c17 <__extendsftf2+0x57>
        absResult |= dst_rep_t(aAbs & srcNaNCode) << (dstSigBits - srcSigBits);
  227c00:	89 d2                	mov    edx,edx
  227c02:	48 c1 e2 19          	shl    rdx,0x19
  227c06:	48 b9 00 00 00 00 00 	movabs rcx,0x7fff000000000000
  227c0d:	00 ff 7f 
  227c10:	48 09 d1             	or     rcx,rdx
  227c13:	31 d2                	xor    edx,edx
  227c15:	eb 50                	jmp    227c67 <__extendsftf2+0xa7>
    } else if (aAbs != 0) {
  227c17:	85 c9                	test   ecx,ecx
  227c19:	74 48                	je     227c63 <__extendsftf2+0xa3>
        const scale: u32 = @clz(aAbs) - @clz(src_rep_t(srcMinNormal));
  227c1b:	f3 0f bd f1          	lzcnt  esi,ecx
  227c1f:	83 c6 38             	add    esi,0x38
  227c22:	83 e6 3f             	and    esi,0x3f
        absResult = dst_rep_t(aAbs) << @intCast(DstShift, dstSigBits - srcSigBits + scale);
  227c25:	89 ca                	mov    edx,ecx
  227c27:	8d 4e 59             	lea    ecx,[rsi+0x59]
  227c2a:	83 e1 7f             	and    ecx,0x7f
  227c2d:	45 31 c0             	xor    r8d,r8d
  227c30:	31 ff                	xor    edi,edi
  227c32:	48 0f a5 d7          	shld   rdi,rdx,cl
  227c36:	c4 e2 f1 f7 d2       	shlx   rdx,rdx,rcx
  227c3b:	f6 c1 40             	test   cl,0x40
  227c3e:	48 0f 45 fa          	cmovne rdi,rdx
  227c42:	49 0f 45 d0          	cmovne rdx,r8
        absResult ^= dstMinNormal;
  227c46:	49 b8 00 00 00 00 00 	movabs r8,0x1000000000000
  227c4d:	00 01 00 
  227c50:	49 31 f8             	xor    r8,rdi
        const resultExponent: u32 = dstExpBias - srcExpBias - scale + 1;
  227c53:	b9 81 3f 00 00       	mov    ecx,0x3f81
  227c58:	29 f1                	sub    ecx,esi
        absResult |= @intCast(dst_rep_t, resultExponent) << dstSigBits;
  227c5a:	48 c1 e1 30          	shl    rcx,0x30
  227c5e:	4c 09 c1             	or     rcx,r8
  227c61:	eb 04                	jmp    227c67 <__extendsftf2+0xa7>
  227c63:	31 d2                	xor    edx,edx
  227c65:	31 c9                	xor    ecx,ecx
    const result: dst_rep_t align(@alignOf(dst_t)) = absResult | dst_rep_t(sign) << (dstBits - srcBits);
  227c67:	48 c1 e0 20          	shl    rax,0x20
  227c6b:	48 89 54 24 e8       	mov    QWORD PTR [rsp-0x18],rdx
  227c70:	48 09 c8             	or     rax,rcx
  227c73:	48 89 44 24 f0       	mov    QWORD PTR [rsp-0x10],rax
  227c78:	0f 28 44 24 e8       	movaps xmm0,XMMWORD PTR [rsp-0x18]
    return extendXfYf2(f128, f32, a);
  227c7d:	c3                   	ret    
  227c7e:	66 90                	xchg   ax,ax

0000000000227c80 <__trunctfdf2>:
    const aRep: src_rep_t = @bitCast(src_rep_t, a);
  227c80:	66 0f 7f 44 24 e8    	movdqa XMMWORD PTR [rsp-0x18],xmm0
  227c86:	48 8b 74 24 e8       	mov    rsi,QWORD PTR [rsp-0x18]
  227c8b:	48 8b 54 24 f0       	mov    rdx,QWORD PTR [rsp-0x10]
    const aAbs: src_rep_t = aRep & srcAbsMask;
  227c90:	b0 3f                	mov    al,0x3f
  227c92:	c4 e2 f8 f5 ca       	bzhi   rcx,rdx,rax
    if (aAbs -% underflow < aAbs -% overflow) {
  227c97:	48 b8 00 00 00 00 00 	movabs rax,0xc3ff000000000000
  227c9e:	00 ff c3 
  227ca1:	48 01 c8             	add    rax,rcx
  227ca4:	48 bf 00 00 00 00 00 	movabs rdi,0xbc01000000000000
  227cab:	00 01 bc 
  227cae:	48 01 cf             	add    rdi,rcx
  227cb1:	48 39 f8             	cmp    rax,rdi
  227cb4:	73 35                	jae    227ceb <__trunctfdf2+0x6b>
  227cb6:	48 b8 00 00 00 00 00 	movabs rax,0x4000000000000000
  227cbd:	00 00 40 
        absResult = @truncate(dst_rep_t, aAbs >> (srcSigBits - dstSigBits));
  227cc0:	48 89 d1             	mov    rcx,rdx
  227cc3:	48 0f a4 f1 04       	shld   rcx,rsi,0x4
        const roundBits: src_rep_t = aAbs & roundMask;
  227cc8:	40 b7 3c             	mov    dil,0x3c
  227ccb:	c4 e2 c0 f5 f6       	bzhi   rsi,rsi,rdi
        if (roundBits > halfway) {
  227cd0:	48 bf 01 00 00 00 00 	movabs rdi,0x800000000000001
  227cd7:	00 00 08 
  227cda:	48 39 fe             	cmp    rsi,rdi
  227cdd:	72 40                	jb     227d1f <__trunctfdf2+0x9f>
            absResult += 1;
  227cdf:	48 01 c1             	add    rcx,rax
  227ce2:	48 83 c1 01          	add    rcx,0x1
  227ce6:	e9 0f 01 00 00       	jmp    227dfa <__trunctfdf2+0x17a>
    } else if (aAbs > srcInfinity) {
  227ceb:	48 83 fe 01          	cmp    rsi,0x1
  227cef:	48 b8 00 00 00 00 00 	movabs rax,0x7fff000000000000
  227cf6:	00 ff 7f 
  227cf9:	48 89 cf             	mov    rdi,rcx
  227cfc:	48 19 c7             	sbb    rdi,rax
  227cff:	72 55                	jb     227d56 <__trunctfdf2+0xd6>
        absResult |= @intCast(dst_rep_t, ((aAbs & srcNaNCode) >> (srcSigBits - dstSigBits)) & dstNaNCode);
  227d01:	48 0f ac d6 3c       	shrd   rsi,rdx,0x3c
  227d06:	b0 33                	mov    al,0x33
  227d08:	c4 e2 f8 f5 c6       	bzhi   rax,rsi,rax
  227d0d:	48 b9 00 00 00 00 00 	movabs rcx,0x7ff8000000000000
  227d14:	00 f8 7f 
  227d17:	48 09 c1             	or     rcx,rax
  227d1a:	e9 db 00 00 00       	jmp    227dfa <__trunctfdf2+0x17a>
  227d1f:	48 01 c1             	add    rcx,rax
        } else if (roundBits == halfway) {
  227d22:	c4 e1 f9 6e c6       	vmovq  xmm0,rsi
  227d27:	48 b8 00 00 00 00 00 	movabs rax,0x800000000000000
  227d2e:	00 00 08 
  227d31:	c4 e1 f9 6e c8       	vmovq  xmm1,rax
  227d36:	c5 f9 74 c1          	vpcmpeqb xmm0,xmm0,xmm1
  227d3a:	c5 f9 d7 c0          	vpmovmskb eax,xmm0
  227d3e:	3d ff ff 00 00       	cmp    eax,0xffff
  227d43:	0f 85 b1 00 00 00    	jne    227dfa <__trunctfdf2+0x17a>
  227d49:	89 c8                	mov    eax,ecx
  227d4b:	83 e0 01             	and    eax,0x1
  227d4e:	48 01 c1             	add    rcx,rax
  227d51:	e9 a4 00 00 00       	jmp    227dfa <__trunctfdf2+0x17a>
    } else if (aAbs >= overflow) {
  227d56:	48 c1 e9 30          	shr    rcx,0x30
  227d5a:	48 81 f9 fe 43 00 00 	cmp    rcx,0x43fe
  227d61:	76 0f                	jbe    227d72 <__trunctfdf2+0xf2>
  227d63:	48 b9 00 00 00 00 00 	movabs rcx,0x7ff0000000000000
  227d6a:	00 f0 7f 
  227d6d:	e9 88 00 00 00       	jmp    227dfa <__trunctfdf2+0x17a>
        const shift = @intCast(u32, srcExpBias - dstExpBias - aExp + 1);
  227d72:	b8 00 3c 00 00       	mov    eax,0x3c00
  227d77:	29 c8                	sub    eax,ecx
        if (shift > srcSigBits) {
  227d79:	83 f8 6f             	cmp    eax,0x6f
  227d7c:	76 04                	jbe    227d82 <__trunctfdf2+0x102>
  227d7e:	31 c9                	xor    ecx,ecx
  227d80:	eb 78                	jmp    227dfa <__trunctfdf2+0x17a>
  227d82:	b1 30                	mov    cl,0x30
  227d84:	c4 e2 f0 f5 ca       	bzhi   rcx,rdx,rcx
  227d89:	49 b8 00 00 00 00 00 	movabs r8,0x1000000000000
  227d90:	00 01 00 
  227d93:	49 09 c8             	or     r8,rcx
            const sticky: src_rep_t = significand << @intCast(SrcShift, srcBits - shift);
  227d96:	b9 7f 00 00 00       	mov    ecx,0x7f
  227d9b:	29 c1                	sub    ecx,eax
  227d9d:	83 e1 7f             	and    ecx,0x7f
  227da0:	4c 89 c7             	mov    rdi,r8
  227da3:	48 0f a5 f7          	shld   rdi,rsi,cl
        const shift = @intCast(u32, srcExpBias - dstExpBias - aExp + 1);
  227da7:	83 c0 01             	add    eax,0x1
            const sticky: src_rep_t = significand << @intCast(SrcShift, srcBits - shift);
  227daa:	c4 62 f1 f7 ce       	shlx   r9,rsi,rcx
  227daf:	45 31 d2             	xor    r10d,r10d
  227db2:	f6 c1 40             	test   cl,0x40
  227db5:	49 0f 45 f9          	cmovne rdi,r9
  227db9:	4d 0f 45 ca          	cmovne r9,r10
            const denormalizedSignificand: src_rep_t = significand >> @intCast(SrcShift, shift) | sticky;
  227dbd:	83 e0 7f             	and    eax,0x7f
  227dc0:	89 c1                	mov    ecx,eax
  227dc2:	4c 0f ad c6          	shrd   rsi,r8,cl
  227dc6:	c4 c2 fb f7 c8       	shrx   rcx,r8,rax
  227dcb:	a8 40                	test   al,0x40
  227dcd:	48 0f 45 f1          	cmovne rsi,rcx
  227dd1:	49 0f 45 ca          	cmovne rcx,r10
  227dd5:	4c 09 ce             	or     rsi,r9
  227dd8:	48 09 f9             	or     rcx,rdi
            absResult = @intCast(dst_rep_t, denormalizedSignificand >> (srcSigBits - dstSigBits));
  227ddb:	48 0f a4 f1 04       	shld   rcx,rsi,0x4
            const roundBits: src_rep_t = denormalizedSignificand & roundMask;
  227de0:	b0 3c                	mov    al,0x3c
  227de2:	c4 e2 f8 f5 c6       	bzhi   rax,rsi,rax
            if (roundBits > halfway) {
  227de7:	48 be 01 00 00 00 00 	movabs rsi,0x800000000000001
  227dee:	00 00 08 
  227df1:	48 39 f0             	cmp    rax,rsi
  227df4:	72 1a                	jb     227e10 <__trunctfdf2+0x190>
                absResult += 1;
  227df6:	48 83 c1 01          	add    rcx,0x1
    const result: dst_rep_t align(@alignOf(dst_t)) = absResult | @truncate(dst_rep_t, sign >> @intCast(SrcShift, srcBits - dstBits));
  227dfa:	48 b8 00 00 00 00 00 	movabs rax,0x8000000000000000
  227e01:	00 00 80 
  227e04:	48 21 c2             	and    rdx,rax
  227e07:	48 09 ca             	or     rdx,rcx
    return @bitCast(dst_t, result);
  227e0a:	c4 e1 f9 6e c2       	vmovq  xmm0,rdx
    return truncXfYf2(f64, f128, a);
  227e0f:	c3                   	ret    
            } else if (roundBits == halfway) {
  227e10:	c4 e1 f9 6e c0       	vmovq  xmm0,rax
  227e15:	e9 0d ff ff ff       	jmp    227d27 <__trunctfdf2+0xa7>
  227e1a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000227e20 <__trunctfsf2>:
    const aRep: src_rep_t = @bitCast(src_rep_t, a);
  227e20:	66 0f 7f 44 24 e8    	movdqa XMMWORD PTR [rsp-0x18],xmm0
  227e26:	48 8b 74 24 e8       	mov    rsi,QWORD PTR [rsp-0x18]
  227e2b:	48 8b 54 24 f0       	mov    rdx,QWORD PTR [rsp-0x10]
    const aAbs: src_rep_t = aRep & srcAbsMask;
  227e30:	b0 3f                	mov    al,0x3f
  227e32:	c4 e2 f8 f5 fa       	bzhi   rdi,rdx,rax
    if (aAbs -% underflow < aAbs -% overflow) {
  227e37:	48 b8 00 00 00 00 00 	movabs rax,0xc07f000000000000
  227e3e:	00 7f c0 
  227e41:	48 01 f8             	add    rax,rdi
  227e44:	48 b9 00 00 00 00 00 	movabs rcx,0xbf81000000000000
  227e4b:	00 81 bf 
  227e4e:	48 01 f9             	add    rcx,rdi
  227e51:	48 39 c8             	cmp    rax,rcx
  227e54:	73 29                	jae    227e7f <__trunctfsf2+0x5f>
        absResult = @truncate(dst_rep_t, aAbs >> (srcSigBits - dstSigBits));
  227e56:	48 89 d1             	mov    rcx,rdx
  227e59:	48 c1 e9 19          	shr    rcx,0x19
        const roundBits: src_rep_t = aAbs & roundMask;
  227e5d:	89 d0                	mov    eax,edx
  227e5f:	25 ff ff ff 01       	and    eax,0x1ffffff
        if (roundBits > halfway) {
  227e64:	48 83 fe 01          	cmp    rsi,0x1
  227e68:	48 89 c7             	mov    rdi,rax
  227e6b:	48 81 df 00 00 00 01 	sbb    rdi,0x1000000
  227e72:	72 39                	jb     227ead <__trunctfsf2+0x8d>
            absResult += 1;
  227e74:	81 c1 01 00 00 40    	add    ecx,0x40000001
  227e7a:	e9 0e 01 00 00       	jmp    227f8d <__trunctfsf2+0x16d>
    } else if (aAbs > srcInfinity) {
  227e7f:	48 83 fe 01          	cmp    rsi,0x1
  227e83:	48 b8 00 00 00 00 00 	movabs rax,0x7fff000000000000
  227e8a:	00 ff 7f 
  227e8d:	48 89 f9             	mov    rcx,rdi
  227e90:	48 19 c1             	sbb    rcx,rax
  227e93:	72 5c                	jb     227ef1 <__trunctfsf2+0xd1>
        absResult |= @intCast(dst_rep_t, ((aAbs & srcNaNCode) >> (srcSigBits - dstSigBits)) & dstNaNCode);
  227e95:	48 89 d1             	mov    rcx,rdx
  227e98:	48 c1 e9 19          	shr    rcx,0x19
  227e9c:	81 e1 ff ff 3f 00    	and    ecx,0x3fffff
  227ea2:	81 c9 00 00 c0 7f    	or     ecx,0x7fc00000
  227ea8:	e9 e0 00 00 00       	jmp    227f8d <__trunctfsf2+0x16d>
  227ead:	81 c1 00 00 00 40    	add    ecx,0x40000000
        } else if (roundBits == halfway) {
  227eb3:	c4 e1 f9 6e c6       	vmovq  xmm0,rsi
  227eb8:	c4 e1 f9 6e c8       	vmovq  xmm1,rax
  227ebd:	c5 f9 6c c1          	vpunpcklqdq xmm0,xmm0,xmm1
  227ec1:	b8 00 00 00 01       	mov    eax,0x1000000
  227ec6:	c4 e1 f9 6e c8       	vmovq  xmm1,rax
  227ecb:	c5 f1 73 f9 08       	vpslldq xmm1,xmm1,0x8
  227ed0:	c5 f9 74 c1          	vpcmpeqb xmm0,xmm0,xmm1
  227ed4:	c5 f9 d7 c0          	vpmovmskb eax,xmm0
  227ed8:	3d ff ff 00 00       	cmp    eax,0xffff
  227edd:	0f 85 aa 00 00 00    	jne    227f8d <__trunctfsf2+0x16d>
  227ee3:	89 c8                	mov    eax,ecx
  227ee5:	83 e0 01             	and    eax,0x1
  227ee8:	01 c8                	add    eax,ecx
  227eea:	89 c1                	mov    ecx,eax
  227eec:	e9 9c 00 00 00       	jmp    227f8d <__trunctfsf2+0x16d>
    } else if (aAbs >= overflow) {
  227ef1:	48 c1 ef 30          	shr    rdi,0x30
  227ef5:	b9 00 00 80 7f       	mov    ecx,0x7f800000
  227efa:	48 81 ff 7e 40 00 00 	cmp    rdi,0x407e
  227f01:	0f 87 86 00 00 00    	ja     227f8d <__trunctfsf2+0x16d>
        const shift = @intCast(u32, srcExpBias - dstExpBias - aExp + 1);
  227f07:	b8 80 3f 00 00       	mov    eax,0x3f80
  227f0c:	29 f8                	sub    eax,edi
  227f0e:	31 c9                	xor    ecx,ecx
        if (shift > srcSigBits) {
  227f10:	83 f8 6f             	cmp    eax,0x6f
  227f13:	77 78                	ja     227f8d <__trunctfsf2+0x16d>
  227f15:	b1 30                	mov    cl,0x30
  227f17:	c4 e2 f0 f5 ca       	bzhi   rcx,rdx,rcx
  227f1c:	48 bf 00 00 00 00 00 	movabs rdi,0x1000000000000
  227f23:	00 01 00 
  227f26:	48 09 cf             	or     rdi,rcx
            const sticky: src_rep_t = significand << @intCast(SrcShift, srcBits - shift);
  227f29:	b9 7f 00 00 00       	mov    ecx,0x7f
  227f2e:	29 c1                	sub    ecx,eax
  227f30:	83 e1 7f             	and    ecx,0x7f
  227f33:	49 89 f8             	mov    r8,rdi
  227f36:	49 0f a5 f0          	shld   r8,rsi,cl
        const shift = @intCast(u32, srcExpBias - dstExpBias - aExp + 1);
  227f3a:	83 c0 01             	add    eax,0x1
            const sticky: src_rep_t = significand << @intCast(SrcShift, srcBits - shift);
  227f3d:	c4 62 f1 f7 ce       	shlx   r9,rsi,rcx
  227f42:	45 31 d2             	xor    r10d,r10d
  227f45:	f6 c1 40             	test   cl,0x40
  227f48:	4d 0f 45 c1          	cmovne r8,r9
  227f4c:	4d 0f 45 ca          	cmovne r9,r10
            const denormalizedSignificand: src_rep_t = significand >> @intCast(SrcShift, shift) | sticky;
  227f50:	83 e0 7f             	and    eax,0x7f
  227f53:	89 c1                	mov    ecx,eax
  227f55:	48 0f ad fe          	shrd   rsi,rdi,cl
  227f59:	c4 e2 fb f7 ff       	shrx   rdi,rdi,rax
  227f5e:	a8 40                	test   al,0x40
  227f60:	48 0f 45 f7          	cmovne rsi,rdi
  227f64:	49 0f 45 fa          	cmovne rdi,r10
  227f68:	4c 09 ce             	or     rsi,r9
  227f6b:	4c 09 c7             	or     rdi,r8
            absResult = @intCast(dst_rep_t, denormalizedSignificand >> (srcSigBits - dstSigBits));
  227f6e:	48 89 f9             	mov    rcx,rdi
  227f71:	48 c1 e9 19          	shr    rcx,0x19
            const roundBits: src_rep_t = denormalizedSignificand & roundMask;
  227f75:	81 e7 ff ff ff 01    	and    edi,0x1ffffff
            if (roundBits > halfway) {
  227f7b:	48 83 fe 01          	cmp    rsi,0x1
  227f7f:	48 89 f8             	mov    rax,rdi
  227f82:	48 1d 00 00 00 01    	sbb    rax,0x1000000
  227f88:	72 14                	jb     227f9e <__trunctfsf2+0x17e>
                absResult += 1;
  227f8a:	83 c1 01             	add    ecx,0x1
    const result: dst_rep_t align(@alignOf(dst_t)) = absResult | @truncate(dst_rep_t, sign >> @intCast(SrcShift, srcBits - dstBits));
  227f8d:	48 c1 ea 20          	shr    rdx,0x20
  227f91:	81 e2 00 00 00 80    	and    edx,0x80000000
  227f97:	09 ca                	or     edx,ecx
    return @bitCast(dst_t, result);
  227f99:	c5 f9 6e c2          	vmovd  xmm0,edx
    return truncXfYf2(f32, f128, a);
  227f9d:	c3                   	ret    
            } else if (roundBits == halfway) {
  227f9e:	c4 e1 f9 6e c6       	vmovq  xmm0,rsi
  227fa3:	c4 e1 f9 6e cf       	vmovq  xmm1,rdi
  227fa8:	e9 10 ff ff ff       	jmp    227ebd <__trunctfsf2+0x9d>
  227fad:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000227fb0 <__fixunssfsi>:

    const implicitBit = (rep_t(1) << significandBits);
    const significandMask = (implicitBit - 1);

    // Break a into sign, exponent, significand
    const aRep: rep_t = @bitCast(rep_t, a);
  227fb0:	c5 f9 7e c1          	vmovd  ecx,xmm0
  227fb4:	31 c0                	xor    eax,eax
    const absMask = signBit - 1;
    const aAbs: rep_t = aRep & absMask;

    const sign = if ((aRep & signBit) != 0) i32(-1) else i32(1);
  227fb6:	85 c9                	test   ecx,ecx
    const exponent = @intCast(i32, aAbs >> significandBits) - exponentBias;
    const significand: rep_t = (aAbs & significandMask) | implicitBit;

    // If either the value or the exponent is negative, the result is zero.
    if (sign == -1 or exponent < 0) return 0;
  227fb8:	78 43                	js     227ffd <__fixunssfsi+0x4d>
  227fba:	89 ca                	mov    edx,ecx
  227fbc:	c1 ea 17             	shr    edx,0x17
  227fbf:	0f b6 f2             	movzx  esi,dl
  227fc2:	83 fe 7f             	cmp    esi,0x7f
  227fc5:	72 36                	jb     227ffd <__fixunssfsi+0x4d>
    const exponent = @intCast(i32, aAbs >> significandBits) - exponentBias;
  227fc7:	8d 7e 81             	lea    edi,[rsi-0x7f]
  227fca:	b8 ff ff ff ff       	mov    eax,0xffffffff

    // If the value is too large for the integer type, saturate.
    if (@intCast(c_uint, exponent) >= fixuint_t.bit_count) return ~fixuint_t(0);
  227fcf:	83 ff 1f             	cmp    edi,0x1f
  227fd2:	77 29                	ja     227ffd <__fixunssfsi+0x4d>
  227fd4:	81 e1 ff ff 7f 00    	and    ecx,0x7fffff
  227fda:	81 c9 00 00 80 00    	or     ecx,0x800000

    // If 0 <= exponent < significandBits, right shift to get the result.
    // Otherwise, shift left.
    if (exponent < significandBits) {
  227fe0:	81 fe 95 00 00 00    	cmp    esi,0x95
  227fe6:	77 0d                	ja     227ff5 <__fixunssfsi+0x45>
        return @intCast(fixuint_t, significand >> @intCast(Log2Int(rep_t), significandBits - exponent));
  227fe8:	b8 16 00 00 00       	mov    eax,0x16
  227fed:	29 d0                	sub    eax,edx
  227fef:	c4 e2 7b f7 c1       	shrx   eax,ecx,eax
const fixuint = @import("fixuint.zig").fixuint;
const builtin = @import("builtin");

pub extern fn __fixunssfsi(a: f32) u32 {
    @setRuntimeSafety(builtin.is_test);
    return fixuint(f32, u32, a);
  227ff4:	c3                   	ret    
    } else {
        return @intCast(fixuint_t, significand) << @intCast(Log2Int(fixuint_t), exponent - significandBits);
  227ff5:	83 c2 0a             	add    edx,0xa
  227ff8:	c4 e2 69 f7 c1       	shlx   eax,ecx,edx
  227ffd:	c3                   	ret    
  227ffe:	66 90                	xchg   ax,ax

0000000000228000 <__fixunssfdi>:
    const aRep: rep_t = @bitCast(rep_t, a);
  228000:	c5 f9 7e c1          	vmovd  ecx,xmm0
  228004:	31 c0                	xor    eax,eax
    const sign = if ((aRep & signBit) != 0) i32(-1) else i32(1);
  228006:	85 c9                	test   ecx,ecx
    if (sign == -1 or exponent < 0) return 0;
  228008:	78 47                	js     228051 <__fixunssfdi+0x51>
  22800a:	89 ca                	mov    edx,ecx
  22800c:	c1 ea 17             	shr    edx,0x17
  22800f:	0f b6 f2             	movzx  esi,dl
  228012:	83 fe 7f             	cmp    esi,0x7f
  228015:	72 3a                	jb     228051 <__fixunssfdi+0x51>
    const exponent = @intCast(i32, aAbs >> significandBits) - exponentBias;
  228017:	8d 7e 81             	lea    edi,[rsi-0x7f]
  22801a:	48 c7 c0 ff ff ff ff 	mov    rax,0xffffffffffffffff
    if (@intCast(c_uint, exponent) >= fixuint_t.bit_count) return ~fixuint_t(0);
  228021:	83 ff 3f             	cmp    edi,0x3f
  228024:	77 2b                	ja     228051 <__fixunssfdi+0x51>
  228026:	81 e1 ff ff 7f 00    	and    ecx,0x7fffff
  22802c:	81 c9 00 00 80 00    	or     ecx,0x800000
    if (exponent < significandBits) {
  228032:	81 fe 95 00 00 00    	cmp    esi,0x95
  228038:	77 0d                	ja     228047 <__fixunssfdi+0x47>
        return @intCast(fixuint_t, significand >> @intCast(Log2Int(rep_t), significandBits - exponent));
  22803a:	b8 16 00 00 00       	mov    eax,0x16
  22803f:	29 d0                	sub    eax,edx
  228041:	c4 e2 7b f7 c1       	shrx   eax,ecx,eax
const fixuint = @import("fixuint.zig").fixuint;
const builtin = @import("builtin");

pub extern fn __fixunssfdi(a: f32) u64 {
    @setRuntimeSafety(builtin.is_test);
    return fixuint(f32, u64, a);
  228046:	c3                   	ret    
        return @intCast(fixuint_t, significand) << @intCast(Log2Int(fixuint_t), exponent - significandBits);
  228047:	89 c8                	mov    eax,ecx
  228049:	83 c2 2a             	add    edx,0x2a
  22804c:	c4 e2 e9 f7 c0       	shlx   rax,rax,rdx
  228051:	c3                   	ret    
  228052:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  228059:	1f 84 00 00 00 00 00 

0000000000228060 <__fixunssfti>:
    const aRep: rep_t = @bitCast(rep_t, a);
  228060:	c5 f9 7e c6          	vmovd  esi,xmm0
  228064:	31 d2                	xor    edx,edx
  228066:	b8 00 00 00 00       	mov    eax,0x0
    const sign = if ((aRep & signBit) != 0) i32(-1) else i32(1);
  22806b:	85 f6                	test   esi,esi
    if (sign == -1 or exponent < 0) return 0;
  22806d:	78 68                	js     2280d7 <__fixunssfti+0x77>
  22806f:	89 f1                	mov    ecx,esi
  228071:	c1 e9 17             	shr    ecx,0x17
  228074:	0f b6 f9             	movzx  edi,cl
  228077:	83 ff 7f             	cmp    edi,0x7f
  22807a:	72 5b                	jb     2280d7 <__fixunssfti+0x77>
    const exponent = @intCast(i32, aAbs >> significandBits) - exponentBias;
  22807c:	44 8d 47 81          	lea    r8d,[rdi-0x7f]
  228080:	48 c7 c0 ff ff ff ff 	mov    rax,0xffffffffffffffff
  228087:	48 c7 c2 ff ff ff ff 	mov    rdx,0xffffffffffffffff
    if (@intCast(c_uint, exponent) >= fixuint_t.bit_count) return ~fixuint_t(0);
  22808e:	41 83 f8 7f          	cmp    r8d,0x7f
  228092:	77 43                	ja     2280d7 <__fixunssfti+0x77>
  228094:	81 e6 ff ff 7f 00    	and    esi,0x7fffff
  22809a:	81 ce 00 00 80 00    	or     esi,0x800000
    if (exponent < significandBits) {
  2280a0:	81 ff 95 00 00 00    	cmp    edi,0x95
  2280a6:	77 0f                	ja     2280b7 <__fixunssfti+0x57>
        return @intCast(fixuint_t, significand >> @intCast(Log2Int(rep_t), significandBits - exponent));
  2280a8:	b8 16 00 00 00       	mov    eax,0x16
  2280ad:	29 c8                	sub    eax,ecx
  2280af:	c4 e2 7b f7 c6       	shrx   eax,esi,eax
  2280b4:	31 d2                	xor    edx,edx
const fixuint = @import("fixuint.zig").fixuint;
const builtin = @import("builtin");

pub extern fn __fixunssfti(a: f32) u128 {
    @setRuntimeSafety(builtin.is_test);
    return fixuint(f32, u128, a);
  2280b6:	c3                   	ret    
        return @intCast(fixuint_t, significand) << @intCast(Log2Int(fixuint_t), exponent - significandBits);
  2280b7:	89 f0                	mov    eax,esi
  2280b9:	83 c1 6a             	add    ecx,0x6a
  2280bc:	83 e1 7f             	and    ecx,0x7f
  2280bf:	31 d2                	xor    edx,edx
  2280c1:	48 0f a5 c2          	shld   rdx,rax,cl
  2280c5:	31 f6                	xor    esi,esi
  2280c7:	c4 e2 f1 f7 c0       	shlx   rax,rax,rcx
  2280cc:	f6 c1 40             	test   cl,0x40
  2280cf:	48 0f 45 d0          	cmovne rdx,rax
  2280d3:	48 0f 45 c6          	cmovne rax,rsi
  2280d7:	c3                   	ret    
  2280d8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  2280df:	00 

00000000002280e0 <__fixunsdfsi>:
    const aRep: rep_t = @bitCast(rep_t, a);
  2280e0:	c4 e1 f9 7e c2       	vmovq  rdx,xmm0
  2280e5:	31 c0                	xor    eax,eax
    const sign = if ((aRep & signBit) != 0) i32(-1) else i32(1);
  2280e7:	48 85 d2             	test   rdx,rdx
    if (sign == -1 or exponent < 0) return 0;
  2280ea:	78 4b                	js     228137 <__fixunsdfsi+0x57>
  2280ec:	48 89 d1             	mov    rcx,rdx
  2280ef:	48 c1 e9 34          	shr    rcx,0x34
  2280f3:	89 ce                	mov    esi,ecx
  2280f5:	81 e6 ff 07 00 00    	and    esi,0x7ff
  2280fb:	81 fe ff 03 00 00    	cmp    esi,0x3ff
  228101:	72 34                	jb     228137 <__fixunsdfsi+0x57>
    const exponent = @intCast(i32, aAbs >> significandBits) - exponentBias;
  228103:	81 c6 01 fc ff ff    	add    esi,0xfffffc01
  228109:	b8 ff ff ff ff       	mov    eax,0xffffffff
    if (@intCast(c_uint, exponent) >= fixuint_t.bit_count) return ~fixuint_t(0);
  22810e:	83 fe 1f             	cmp    esi,0x1f
  228111:	77 24                	ja     228137 <__fixunsdfsi+0x57>
  228113:	b0 34                	mov    al,0x34
  228115:	c4 e2 f8 f5 c2       	bzhi   rax,rdx,rax
  22811a:	48 ba ff ff ff ff ff 	movabs rdx,0xfffffffffffff
  228121:	ff 0f 00 
  228124:	48 83 c2 01          	add    rdx,0x1
  228128:	48 09 c2             	or     rdx,rax
        return @intCast(fixuint_t, significand >> @intCast(Log2Int(rep_t), significandBits - exponent));
  22812b:	b8 33 00 00 00       	mov    eax,0x33
  228130:	29 c8                	sub    eax,ecx
  228132:	c4 e2 fb f7 c2       	shrx   rax,rdx,rax
const fixuint = @import("fixuint.zig").fixuint;
const builtin = @import("builtin");

pub extern fn __fixunsdfsi(a: f64) u32 {
    @setRuntimeSafety(builtin.is_test);
    return fixuint(f64, u32, a);
  228137:	c3                   	ret    
  228138:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  22813f:	00 

0000000000228140 <__fixunsdfdi>:
    const aRep: rep_t = @bitCast(rep_t, a);
  228140:	c4 e1 f9 7e c2       	vmovq  rdx,xmm0
  228145:	31 c0                	xor    eax,eax
    const sign = if ((aRep & signBit) != 0) i32(-1) else i32(1);
  228147:	48 85 d2             	test   rdx,rdx
    if (sign == -1 or exponent < 0) return 0;
  22814a:	78 5e                	js     2281aa <__fixunsdfdi+0x6a>
  22814c:	48 89 d1             	mov    rcx,rdx
  22814f:	48 c1 e9 34          	shr    rcx,0x34
  228153:	89 ce                	mov    esi,ecx
  228155:	81 e6 ff 07 00 00    	and    esi,0x7ff
  22815b:	81 fe ff 03 00 00    	cmp    esi,0x3ff
  228161:	72 47                	jb     2281aa <__fixunsdfdi+0x6a>
    const exponent = @intCast(i32, aAbs >> significandBits) - exponentBias;
  228163:	8d be 01 fc ff ff    	lea    edi,[rsi-0x3ff]
  228169:	48 c7 c0 ff ff ff ff 	mov    rax,0xffffffffffffffff
    if (@intCast(c_uint, exponent) >= fixuint_t.bit_count) return ~fixuint_t(0);
  228170:	83 ff 3f             	cmp    edi,0x3f
  228173:	77 35                	ja     2281aa <__fixunsdfdi+0x6a>
  228175:	b0 34                	mov    al,0x34
  228177:	c4 e2 f8 f5 d2       	bzhi   rdx,rdx,rax
  22817c:	48 b8 ff ff ff ff ff 	movabs rax,0xfffffffffffff
  228183:	ff 0f 00 
  228186:	48 83 c0 01          	add    rax,0x1
  22818a:	48 09 d0             	or     rax,rdx
    if (exponent < significandBits) {
  22818d:	81 fe 32 04 00 00    	cmp    esi,0x432
  228193:	77 0d                	ja     2281a2 <__fixunsdfdi+0x62>
        return @intCast(fixuint_t, significand >> @intCast(Log2Int(rep_t), significandBits - exponent));
  228195:	ba 33 00 00 00       	mov    edx,0x33
  22819a:	29 ca                	sub    edx,ecx
  22819c:	c4 e2 eb f7 c0       	shrx   rax,rax,rdx
const fixuint = @import("fixuint.zig").fixuint;
const builtin = @import("builtin");

pub extern fn __fixunsdfdi(a: f64) u64 {
    @setRuntimeSafety(builtin.is_test);
    return fixuint(f64, u64, a);
  2281a1:	c3                   	ret    
        return @intCast(fixuint_t, significand) << @intCast(Log2Int(fixuint_t), exponent - significandBits);
  2281a2:	83 c1 0d             	add    ecx,0xd
  2281a5:	c4 e2 f1 f7 c0       	shlx   rax,rax,rcx
  2281aa:	c3                   	ret    
  2281ab:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

00000000002281b0 <__fixunsdfti>:
    const aRep: rep_t = @bitCast(rep_t, a);
  2281b0:	c4 e1 f9 7e c6       	vmovq  rsi,xmm0
  2281b5:	31 d2                	xor    edx,edx
  2281b7:	b8 00 00 00 00       	mov    eax,0x0
    const sign = if ((aRep & signBit) != 0) i32(-1) else i32(1);
  2281bc:	48 85 f6             	test   rsi,rsi
    if (sign == -1 or exponent < 0) return 0;
  2281bf:	78 7f                	js     228240 <__fixunsdfti+0x90>
  2281c1:	48 89 f1             	mov    rcx,rsi
  2281c4:	48 c1 e9 34          	shr    rcx,0x34
  2281c8:	89 cf                	mov    edi,ecx
  2281ca:	81 e7 ff 07 00 00    	and    edi,0x7ff
  2281d0:	81 ff ff 03 00 00    	cmp    edi,0x3ff
  2281d6:	72 68                	jb     228240 <__fixunsdfti+0x90>
    const exponent = @intCast(i32, aAbs >> significandBits) - exponentBias;
  2281d8:	44 8d 87 01 fc ff ff 	lea    r8d,[rdi-0x3ff]
  2281df:	48 c7 c0 ff ff ff ff 	mov    rax,0xffffffffffffffff
  2281e6:	48 c7 c2 ff ff ff ff 	mov    rdx,0xffffffffffffffff
    if (@intCast(c_uint, exponent) >= fixuint_t.bit_count) return ~fixuint_t(0);
  2281ed:	41 83 f8 7f          	cmp    r8d,0x7f
  2281f1:	77 4d                	ja     228240 <__fixunsdfti+0x90>
  2281f3:	b0 34                	mov    al,0x34
  2281f5:	c4 e2 f8 f5 d6       	bzhi   rdx,rsi,rax
  2281fa:	48 b8 ff ff ff ff ff 	movabs rax,0xfffffffffffff
  228201:	ff 0f 00 
  228204:	48 83 c0 01          	add    rax,0x1
  228208:	48 09 d0             	or     rax,rdx
    if (exponent < significandBits) {
  22820b:	81 ff 32 04 00 00    	cmp    edi,0x432
  228211:	77 0f                	ja     228222 <__fixunsdfti+0x72>
        return @intCast(fixuint_t, significand >> @intCast(Log2Int(rep_t), significandBits - exponent));
  228213:	ba 33 00 00 00       	mov    edx,0x33
  228218:	29 ca                	sub    edx,ecx
  22821a:	c4 e2 eb f7 c0       	shrx   rax,rax,rdx
  22821f:	31 d2                	xor    edx,edx
const fixuint = @import("fixuint.zig").fixuint;
const builtin = @import("builtin");

pub extern fn __fixunsdfti(a: f64) u128 {
    @setRuntimeSafety(builtin.is_test);
    return fixuint(f64, u128, a);
  228221:	c3                   	ret    
        return @intCast(fixuint_t, significand) << @intCast(Log2Int(fixuint_t), exponent - significandBits);
  228222:	8d 49 4d             	lea    ecx,[rcx+0x4d]
  228225:	83 e1 7f             	and    ecx,0x7f
  228228:	31 d2                	xor    edx,edx
  22822a:	48 0f a5 c2          	shld   rdx,rax,cl
  22822e:	31 f6                	xor    esi,esi
  228230:	c4 e2 f1 f7 c0       	shlx   rax,rax,rcx
  228235:	f6 c1 40             	test   cl,0x40
  228238:	48 0f 45 d0          	cmovne rdx,rax
  22823c:	48 0f 45 c6          	cmovne rax,rsi
  228240:	c3                   	ret    
  228241:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  228248:	0f 1f 84 00 00 00 00 
  22824f:	00 

0000000000228250 <__fixunstfsi>:
    const aRep: rep_t = @bitCast(rep_t, a);
  228250:	0f 29 44 24 e8       	movaps XMMWORD PTR [rsp-0x18],xmm0
  228255:	48 8b 4c 24 f0       	mov    rcx,QWORD PTR [rsp-0x10]
  22825a:	31 c0                	xor    eax,eax
    const sign = if ((aRep & signBit) != 0) i32(-1) else i32(1);
  22825c:	48 85 c9             	test   rcx,rcx
    if (sign == -1 or exponent < 0) return 0;
  22825f:	78 5a                	js     2282bb <__fixunstfsi+0x6b>
  228261:	48 89 ca             	mov    rdx,rcx
  228264:	48 c1 ea 30          	shr    rdx,0x30
  228268:	89 d6                	mov    esi,edx
  22826a:	81 e6 ff 7f 00 00    	and    esi,0x7fff
  228270:	81 fe ff 3f 00 00    	cmp    esi,0x3fff
  228276:	72 43                	jb     2282bb <__fixunstfsi+0x6b>
    const exponent = @intCast(i32, aAbs >> significandBits) - exponentBias;
  228278:	81 c6 01 c0 ff ff    	add    esi,0xffffc001
  22827e:	b8 ff ff ff ff       	mov    eax,0xffffffff
    if (@intCast(c_uint, exponent) >= fixuint_t.bit_count) return ~fixuint_t(0);
  228283:	83 fe 1f             	cmp    esi,0x1f
  228286:	77 33                	ja     2282bb <__fixunstfsi+0x6b>
  228288:	48 8b 74 24 e8       	mov    rsi,QWORD PTR [rsp-0x18]
  22828d:	b0 30                	mov    al,0x30
  22828f:	c4 e2 f8 f5 c1       	bzhi   rax,rcx,rax
  228294:	48 bf 00 00 00 00 00 	movabs rdi,0x1000000000000
  22829b:	00 01 00 
  22829e:	48 09 c7             	or     rdi,rax
        return @intCast(fixuint_t, significand >> @intCast(Log2Int(rep_t), significandBits - exponent));
  2282a1:	b9 6f 00 00 00       	mov    ecx,0x6f
  2282a6:	29 d1                	sub    ecx,edx
  2282a8:	83 e1 7f             	and    ecx,0x7f
  2282ab:	48 0f ad fe          	shrd   rsi,rdi,cl
  2282af:	c4 e2 f3 f7 c7       	shrx   rax,rdi,rcx
  2282b4:	f6 c1 40             	test   cl,0x40
  2282b7:	48 0f 44 c6          	cmove  rax,rsi
const fixuint = @import("fixuint.zig").fixuint;
const builtin = @import("builtin");

pub extern fn __fixunstfsi(a: f128) u32 {
    @setRuntimeSafety(builtin.is_test);
    return fixuint(f128, u32, a);
  2282bb:	c3                   	ret    
  2282bc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

00000000002282c0 <__fixunstfdi>:
    const aRep: rep_t = @bitCast(rep_t, a);
  2282c0:	0f 29 44 24 e8       	movaps XMMWORD PTR [rsp-0x18],xmm0
  2282c5:	48 8b 4c 24 f0       	mov    rcx,QWORD PTR [rsp-0x10]
  2282ca:	31 c0                	xor    eax,eax
    const sign = if ((aRep & signBit) != 0) i32(-1) else i32(1);
  2282cc:	48 85 c9             	test   rcx,rcx
    if (sign == -1 or exponent < 0) return 0;
  2282cf:	78 5c                	js     22832d <__fixunstfdi+0x6d>
  2282d1:	48 89 ca             	mov    rdx,rcx
  2282d4:	48 c1 ea 30          	shr    rdx,0x30
  2282d8:	89 d6                	mov    esi,edx
  2282da:	81 e6 ff 7f 00 00    	and    esi,0x7fff
  2282e0:	81 fe ff 3f 00 00    	cmp    esi,0x3fff
  2282e6:	72 45                	jb     22832d <__fixunstfdi+0x6d>
    const exponent = @intCast(i32, aAbs >> significandBits) - exponentBias;
  2282e8:	81 c6 01 c0 ff ff    	add    esi,0xffffc001
  2282ee:	48 c7 c0 ff ff ff ff 	mov    rax,0xffffffffffffffff
    if (@intCast(c_uint, exponent) >= fixuint_t.bit_count) return ~fixuint_t(0);
  2282f5:	83 fe 3f             	cmp    esi,0x3f
  2282f8:	77 33                	ja     22832d <__fixunstfdi+0x6d>
  2282fa:	48 8b 74 24 e8       	mov    rsi,QWORD PTR [rsp-0x18]
  2282ff:	b0 30                	mov    al,0x30
  228301:	c4 e2 f8 f5 c1       	bzhi   rax,rcx,rax
  228306:	48 bf 00 00 00 00 00 	movabs rdi,0x1000000000000
  22830d:	00 01 00 
  228310:	48 09 c7             	or     rdi,rax
        return @intCast(fixuint_t, significand >> @intCast(Log2Int(rep_t), significandBits - exponent));
  228313:	b9 6f 00 00 00       	mov    ecx,0x6f
  228318:	29 d1                	sub    ecx,edx
  22831a:	83 e1 7f             	and    ecx,0x7f
  22831d:	48 0f ad fe          	shrd   rsi,rdi,cl
  228321:	c4 e2 f3 f7 c7       	shrx   rax,rdi,rcx
  228326:	f6 c1 40             	test   cl,0x40
  228329:	48 0f 44 c6          	cmove  rax,rsi
const fixuint = @import("fixuint.zig").fixuint;
const builtin = @import("builtin");

pub extern fn __fixunstfdi(a: f128) u64 {
    @setRuntimeSafety(builtin.is_test);
    return fixuint(f128, u64, a);
  22832d:	c3                   	ret    
  22832e:	66 90                	xchg   ax,ax

0000000000228330 <__fixunstfti>:
    const aRep: rep_t = @bitCast(rep_t, a);
  228330:	0f 29 44 24 e8       	movaps XMMWORD PTR [rsp-0x18],xmm0
  228335:	48 8b 74 24 f0       	mov    rsi,QWORD PTR [rsp-0x10]
  22833a:	31 d2                	xor    edx,edx
  22833c:	b8 00 00 00 00       	mov    eax,0x0
    const sign = if ((aRep & signBit) != 0) i32(-1) else i32(1);
  228341:	48 85 f6             	test   rsi,rsi
    if (sign == -1 or exponent < 0) return 0;
  228344:	0f 88 93 00 00 00    	js     2283dd <__fixunstfti+0xad>
  22834a:	48 89 f1             	mov    rcx,rsi
  22834d:	48 c1 e9 30          	shr    rcx,0x30
  228351:	89 cf                	mov    edi,ecx
  228353:	81 e7 ff 7f 00 00    	and    edi,0x7fff
  228359:	81 ff ff 3f 00 00    	cmp    edi,0x3fff
  22835f:	72 7c                	jb     2283dd <__fixunstfti+0xad>
    const exponent = @intCast(i32, aAbs >> significandBits) - exponentBias;
  228361:	44 8d 87 01 c0 ff ff 	lea    r8d,[rdi-0x3fff]
  228368:	48 c7 c0 ff ff ff ff 	mov    rax,0xffffffffffffffff
  22836f:	48 c7 c2 ff ff ff ff 	mov    rdx,0xffffffffffffffff
    if (@intCast(c_uint, exponent) >= fixuint_t.bit_count) return ~fixuint_t(0);
  228376:	41 83 f8 7f          	cmp    r8d,0x7f
  22837a:	77 61                	ja     2283dd <__fixunstfti+0xad>
  22837c:	48 8b 44 24 e8       	mov    rax,QWORD PTR [rsp-0x18]
  228381:	b2 30                	mov    dl,0x30
  228383:	c4 e2 e8 f5 f6       	bzhi   rsi,rsi,rdx
  228388:	48 ba 00 00 00 00 00 	movabs rdx,0x1000000000000
  22838f:	00 01 00 
  228392:	48 09 f2             	or     rdx,rsi
    if (exponent < significandBits) {
  228395:	81 ff 6e 40 00 00    	cmp    edi,0x406e
  22839b:	77 24                	ja     2283c1 <__fixunstfti+0x91>
        return @intCast(fixuint_t, significand >> @intCast(Log2Int(rep_t), significandBits - exponent));
  22839d:	be 6f 00 00 00       	mov    esi,0x6f
  2283a2:	29 ce                	sub    esi,ecx
  2283a4:	83 e6 7f             	and    esi,0x7f
  2283a7:	89 f1                	mov    ecx,esi
  2283a9:	48 0f ad d0          	shrd   rax,rdx,cl
  2283ad:	c4 e2 cb f7 ca       	shrx   rcx,rdx,rsi
  2283b2:	31 d2                	xor    edx,edx
  2283b4:	40 f6 c6 40          	test   sil,0x40
  2283b8:	48 0f 45 c1          	cmovne rax,rcx
  2283bc:	48 0f 44 d1          	cmove  rdx,rcx
const fixuint = @import("fixuint.zig").fixuint;
const builtin = @import("builtin");

pub extern fn __fixunstfti(a: f128) u128 {
    @setRuntimeSafety(builtin.is_test);
    return fixuint(f128, u128, a);
  2283c0:	c3                   	ret    
        return @intCast(fixuint_t, significand) << @intCast(Log2Int(fixuint_t), exponent - significandBits);
  2283c1:	83 c1 11             	add    ecx,0x11
  2283c4:	83 e1 7f             	and    ecx,0x7f
  2283c7:	48 0f a5 c2          	shld   rdx,rax,cl
  2283cb:	c4 e2 f1 f7 f0       	shlx   rsi,rax,rcx
  2283d0:	31 c0                	xor    eax,eax
  2283d2:	f6 c1 40             	test   cl,0x40
  2283d5:	48 0f 45 d6          	cmovne rdx,rsi
  2283d9:	48 0f 44 c6          	cmove  rax,rsi
  2283dd:	c3                   	ret    
  2283de:	66 90                	xchg   ax,ax

00000000002283e0 <__udivsi3>:
    const d = __udivsi3(a, b);
    rem.* = @bitCast(u32, @bitCast(i32, a) -% (@bitCast(i32, d) * @bitCast(i32, b)));
    return d;
}

extern fn __udivsi3(n: u32, d: u32) u32 {
  2283e0:	55                   	push   rbp
  2283e1:	41 56                	push   r14
  2283e3:	53                   	push   rbx
  2283e4:	31 c0                	xor    eax,eax
    @setRuntimeSafety(is_test);

    const n_uword_bits: c_uint = u32.bit_count;
    // special cases
    if (d == 0) return 0; // ?!
    if (n == 0) return 0;
  2283e6:	85 ff                	test   edi,edi
    if (d == 0) return 0; // ?!
  2283e8:	74 19                	je     228403 <__udivsi3+0x23>
  2283ea:	85 f6                	test   esi,esi
  2283ec:	74 15                	je     228403 <__udivsi3+0x23>
    var sr = @bitCast(c_uint, c_int(@clz(d)) - c_int(@clz(n)));
  2283ee:	f3 0f bd ce          	lzcnt  ecx,esi
  2283f2:	f3 0f bd d7          	lzcnt  edx,edi
  2283f6:	89 cb                	mov    ebx,ecx
  2283f8:	29 d3                	sub    ebx,edx
    // 0 <= sr <= n_uword_bits - 1 or sr large
    if (sr > n_uword_bits - 1) {
  2283fa:	83 fb 1f             	cmp    ebx,0x1f
  2283fd:	77 04                	ja     228403 <__udivsi3+0x23>
        // d > r
        return 0;
    }
    if (sr == n_uword_bits - 1) {
  2283ff:	75 07                	jne    228408 <__udivsi3+0x28>
  228401:	89 f8                	mov    eax,edi
  228403:	5b                   	pop    rbx
  228404:	41 5e                	pop    r14
  228406:	5d                   	pop    rbp
  228407:	c3                   	ret    
        // d == 1
        return n;
    }
    sr += 1;
  228408:	44 8d 4b 01          	lea    r9d,[rbx+0x1]
    // 1 <= sr <= n_uword_bits - 1
    // Not a special case
    var q: u32 = n << @intCast(u5, n_uword_bits - sr);
  22840c:	b8 1f 00 00 00       	mov    eax,0x1f
  228411:	29 d8                	sub    eax,ebx
  228413:	c4 e2 79 f7 c7       	shlx   eax,edi,eax
    var r: u32 = n >> @intCast(u5, sr);
  228418:	c4 e2 33 f7 ff       	shrx   edi,edi,r9d
  22841d:	44 8d 46 ff          	lea    r8d,[rsi-0x1]
    var carry: u32 = 0;
    while (sr > 0) : (sr -= 1) {
  228421:	41 83 e1 03          	and    r9d,0x3
  228425:	83 fb 03             	cmp    ebx,0x3
  228428:	73 10                	jae    22843a <__udivsi3+0x5a>
  22842a:	31 c9                	xor    ecx,ecx
  22842c:	45 85 c9             	test   r9d,r9d
  22842f:	0f 85 a6 00 00 00    	jne    2284db <__udivsi3+0xfb>
  228435:	e9 c5 00 00 00       	jmp    2284ff <__udivsi3+0x11f>
  22843a:	42 8d 14 0a          	lea    edx,[rdx+r9*1]
  22843e:	83 c2 ff             	add    edx,0xffffffff
  228441:	29 ca                	sub    edx,ecx
  228443:	31 c9                	xor    ecx,ecx
  228445:	41 ba 1e 01 00 00    	mov    r10d,0x11e
  22844b:	41 bb 1d 01 00 00    	mov    r11d,0x11d
  228451:	41 be 1c 01 00 00    	mov    r14d,0x11c
  228457:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  22845e:	00 00 
        // r:q = ((r:q)  << 1) | carry
        r = (r << 1) | (q >> @intCast(u5, n_uword_bits - 1));
  228460:	0f a4 c7 01          	shld   edi,eax,0x1
        q = (q << 1) | carry;
  228464:	8d 1c 00             	lea    ebx,[rax+rax*1]
  228467:	09 cb                	or     ebx,ecx
        // if (r.all >= d.all)
        // {
        //      r.all -= d.all;
        //      carry = 1;
        // }
        const s = @intCast(i32, d -% r -% 1) >> @intCast(u5, n_uword_bits - 1);
  228469:	44 89 c1             	mov    ecx,r8d
  22846c:	29 f9                	sub    ecx,edi
  22846e:	c1 f9 1f             	sar    ecx,0x1f
        carry = @intCast(u32, s & 1);
  228471:	89 cd                	mov    ebp,ecx
  228473:	83 e5 01             	and    ebp,0x1
        r -= d & @bitCast(u32, s);
  228476:	21 f1                	and    ecx,esi
  228478:	29 cf                	sub    edi,ecx
        r = (r << 1) | (q >> @intCast(u5, n_uword_bits - 1));
  22847a:	c4 e2 28 f7 c8       	bextr  ecx,eax,r10d
  22847f:	8d 0c 79             	lea    ecx,[rcx+rdi*2]
        q = (q << 1) | carry;
  228482:	8d 7c 5d 00          	lea    edi,[rbp+rbx*2+0x0]
        const s = @intCast(i32, d -% r -% 1) >> @intCast(u5, n_uword_bits - 1);
  228486:	44 89 c3             	mov    ebx,r8d
  228489:	29 cb                	sub    ebx,ecx
  22848b:	c1 fb 1f             	sar    ebx,0x1f
        carry = @intCast(u32, s & 1);
  22848e:	89 dd                	mov    ebp,ebx
  228490:	83 e5 01             	and    ebp,0x1
        r -= d & @bitCast(u32, s);
  228493:	21 f3                	and    ebx,esi
  228495:	29 d9                	sub    ecx,ebx
        r = (r << 1) | (q >> @intCast(u5, n_uword_bits - 1));
  228497:	c4 e2 20 f7 d8       	bextr  ebx,eax,r11d
  22849c:	8d 0c 4b             	lea    ecx,[rbx+rcx*2]
        q = (q << 1) | carry;
  22849f:	8d 5c 7d 00          	lea    ebx,[rbp+rdi*2+0x0]
        const s = @intCast(i32, d -% r -% 1) >> @intCast(u5, n_uword_bits - 1);
  2284a3:	44 89 c7             	mov    edi,r8d
  2284a6:	29 cf                	sub    edi,ecx
  2284a8:	c1 ff 1f             	sar    edi,0x1f
        carry = @intCast(u32, s & 1);
  2284ab:	89 fd                	mov    ebp,edi
  2284ad:	83 e5 01             	and    ebp,0x1
        r -= d & @bitCast(u32, s);
  2284b0:	21 f7                	and    edi,esi
  2284b2:	29 f9                	sub    ecx,edi
        r = (r << 1) | (q >> @intCast(u5, n_uword_bits - 1));
  2284b4:	c4 e2 08 f7 c0       	bextr  eax,eax,r14d
  2284b9:	8d 3c 48             	lea    edi,[rax+rcx*2]
        q = (q << 1) | carry;
  2284bc:	8d 44 5d 00          	lea    eax,[rbp+rbx*2+0x0]
        const s = @intCast(i32, d -% r -% 1) >> @intCast(u5, n_uword_bits - 1);
  2284c0:	44 89 c3             	mov    ebx,r8d
  2284c3:	29 fb                	sub    ebx,edi
  2284c5:	c1 fb 1f             	sar    ebx,0x1f
        carry = @intCast(u32, s & 1);
  2284c8:	89 d9                	mov    ecx,ebx
  2284ca:	83 e1 01             	and    ecx,0x1
        r -= d & @bitCast(u32, s);
  2284cd:	21 f3                	and    ebx,esi
  2284cf:	29 df                	sub    edi,ebx
    while (sr > 0) : (sr -= 1) {
  2284d1:	83 c2 04             	add    edx,0x4
  2284d4:	75 8a                	jne    228460 <__udivsi3+0x80>
  2284d6:	45 85 c9             	test   r9d,r9d
  2284d9:	74 24                	je     2284ff <__udivsi3+0x11f>
  2284db:	41 f7 d9             	neg    r9d
  2284de:	66 90                	xchg   ax,ax
        r = (r << 1) | (q >> @intCast(u5, n_uword_bits - 1));
  2284e0:	0f a4 c7 01          	shld   edi,eax,0x1
        q = (q << 1) | carry;
  2284e4:	01 c0                	add    eax,eax
  2284e6:	09 c8                	or     eax,ecx
        const s = @intCast(i32, d -% r -% 1) >> @intCast(u5, n_uword_bits - 1);
  2284e8:	44 89 c2             	mov    edx,r8d
  2284eb:	29 fa                	sub    edx,edi
  2284ed:	c1 fa 1f             	sar    edx,0x1f
        carry = @intCast(u32, s & 1);
  2284f0:	89 d1                	mov    ecx,edx
  2284f2:	83 e1 01             	and    ecx,0x1
        r -= d & @bitCast(u32, s);
  2284f5:	21 f2                	and    edx,esi
  2284f7:	29 d7                	sub    edi,edx
    while (sr > 0) : (sr -= 1) {
  2284f9:	41 83 c1 01          	add    r9d,0x1
  2284fd:	75 e1                	jne    2284e0 <__udivsi3+0x100>
    }
    q = (q << 1) | carry;
  2284ff:	01 c0                	add    eax,eax
  228501:	09 c8                	or     eax,ecx
  228503:	5b                   	pop    rbx
  228504:	41 5e                	pop    r14
  228506:	5d                   	pop    rbp
  228507:	c3                   	ret    
  228508:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  22850f:	00 

0000000000228510 <__udivdi3>:
    return __udivmoddi4(a, b, null);
  228510:	31 d2                	xor    edx,edx
  228512:	e9 a9 e6 ff ff       	jmp    226bc0 <__udivmoddi4>
  228517:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  22851e:	00 00 

0000000000228520 <__umoddi3>:
extern fn __umoddi3(a: u64, b: u64) u64 {
  228520:	50                   	push   rax
  228521:	48 89 e2             	mov    rdx,rsp
    _ = __udivmoddi4(a, b, &r);
  228524:	e8 97 e6 ff ff       	call   226bc0 <__udivmoddi4>
    return r;
  228529:	48 8b 04 24          	mov    rax,QWORD PTR [rsp]
  22852d:	59                   	pop    rcx
  22852e:	c3                   	ret    
  22852f:	90                   	nop

0000000000228530 <__udivmodsi4>:
extern fn __udivmodsi4(a: u32, b: u32, rem: *u32) u32 {
  228530:	55                   	push   rbp
  228531:	41 57                	push   r15
  228533:	41 56                	push   r14
  228535:	41 55                	push   r13
  228537:	41 54                	push   r12
  228539:	53                   	push   rbx
  22853a:	31 c0                	xor    eax,eax
    if (n == 0) return 0;
  22853c:	85 ff                	test   edi,edi
    if (d == 0) return 0; // ?!
  22853e:	0f 84 33 01 00 00    	je     228677 <__udivmodsi4+0x147>
  228544:	85 f6                	test   esi,esi
  228546:	0f 84 2b 01 00 00    	je     228677 <__udivmodsi4+0x147>
    var sr = @bitCast(c_uint, c_int(@clz(d)) - c_int(@clz(n)));
  22854c:	f3 44 0f bd de       	lzcnt  r11d,esi
  228551:	f3 0f bd df          	lzcnt  ebx,edi
  228555:	44 89 dd             	mov    ebp,r11d
  228558:	29 dd                	sub    ebp,ebx
    if (sr > n_uword_bits - 1) {
  22855a:	83 fd 1f             	cmp    ebp,0x1f
  22855d:	0f 87 14 01 00 00    	ja     228677 <__udivmodsi4+0x147>
  228563:	89 f8                	mov    eax,edi
    if (sr == n_uword_bits - 1) {
  228565:	0f 84 0c 01 00 00    	je     228677 <__udivmodsi4+0x147>
    sr += 1;
  22856b:	44 8d 4d 01          	lea    r9d,[rbp+0x1]
    var q: u32 = n << @intCast(u5, n_uword_bits - sr);
  22856f:	b8 1f 00 00 00       	mov    eax,0x1f
  228574:	29 e8                	sub    eax,ebp
  228576:	c4 e2 79 f7 c7       	shlx   eax,edi,eax
    var r: u32 = n >> @intCast(u5, sr);
  22857b:	c4 e2 33 f7 cf       	shrx   ecx,edi,r9d
  228580:	44 8d 46 ff          	lea    r8d,[rsi-0x1]
    while (sr > 0) : (sr -= 1) {
  228584:	41 83 e1 03          	and    r9d,0x3
  228588:	83 fd 03             	cmp    ebp,0x3
  22858b:	73 11                	jae    22859e <__udivmodsi4+0x6e>
  22858d:	45 31 db             	xor    r11d,r11d
  228590:	45 85 c9             	test   r9d,r9d
  228593:	0f 85 aa 00 00 00    	jne    228643 <__udivmodsi4+0x113>
  228599:	e9 d4 00 00 00       	jmp    228672 <__udivmodsi4+0x142>
  22859e:	46 8d 14 0b          	lea    r10d,[rbx+r9*1]
  2285a2:	41 83 c2 ff          	add    r10d,0xffffffff
  2285a6:	45 29 da             	sub    r10d,r11d
  2285a9:	45 31 db             	xor    r11d,r11d
  2285ac:	41 be 1e 01 00 00    	mov    r14d,0x11e
  2285b2:	41 bf 1d 01 00 00    	mov    r15d,0x11d
  2285b8:	41 bc 1c 01 00 00    	mov    r12d,0x11c
  2285be:	66 90                	xchg   ax,ax
        r = (r << 1) | (q >> @intCast(u5, n_uword_bits - 1));
  2285c0:	0f a4 c1 01          	shld   ecx,eax,0x1
        q = (q << 1) | carry;
  2285c4:	44 8d 2c 00          	lea    r13d,[rax+rax*1]
  2285c8:	45 09 dd             	or     r13d,r11d
        const s = @intCast(i32, d -% r -% 1) >> @intCast(u5, n_uword_bits - 1);
  2285cb:	44 89 c3             	mov    ebx,r8d
  2285ce:	29 cb                	sub    ebx,ecx
  2285d0:	c1 fb 1f             	sar    ebx,0x1f
        carry = @intCast(u32, s & 1);
  2285d3:	89 dd                	mov    ebp,ebx
  2285d5:	83 e5 01             	and    ebp,0x1
        r -= d & @bitCast(u32, s);
  2285d8:	21 f3                	and    ebx,esi
  2285da:	29 d9                	sub    ecx,ebx
        r = (r << 1) | (q >> @intCast(u5, n_uword_bits - 1));
  2285dc:	c4 e2 08 f7 d8       	bextr  ebx,eax,r14d
  2285e1:	8d 0c 4b             	lea    ecx,[rbx+rcx*2]
        q = (q << 1) | carry;
  2285e4:	46 8d 5c 6d 00       	lea    r11d,[rbp+r13*2+0x0]
        const s = @intCast(i32, d -% r -% 1) >> @intCast(u5, n_uword_bits - 1);
  2285e9:	44 89 c3             	mov    ebx,r8d
  2285ec:	29 cb                	sub    ebx,ecx
  2285ee:	c1 fb 1f             	sar    ebx,0x1f
        carry = @intCast(u32, s & 1);
  2285f1:	89 dd                	mov    ebp,ebx
  2285f3:	83 e5 01             	and    ebp,0x1
        r -= d & @bitCast(u32, s);
  2285f6:	21 f3                	and    ebx,esi
  2285f8:	29 d9                	sub    ecx,ebx
        r = (r << 1) | (q >> @intCast(u5, n_uword_bits - 1));
  2285fa:	c4 e2 00 f7 d8       	bextr  ebx,eax,r15d
  2285ff:	8d 0c 4b             	lea    ecx,[rbx+rcx*2]
        q = (q << 1) | carry;
  228602:	46 8d 5c 5d 00       	lea    r11d,[rbp+r11*2+0x0]
        const s = @intCast(i32, d -% r -% 1) >> @intCast(u5, n_uword_bits - 1);
  228607:	44 89 c3             	mov    ebx,r8d
  22860a:	29 cb                	sub    ebx,ecx
  22860c:	c1 fb 1f             	sar    ebx,0x1f
        carry = @intCast(u32, s & 1);
  22860f:	89 dd                	mov    ebp,ebx
  228611:	83 e5 01             	and    ebp,0x1
        r -= d & @bitCast(u32, s);
  228614:	21 f3                	and    ebx,esi
  228616:	29 d9                	sub    ecx,ebx
        r = (r << 1) | (q >> @intCast(u5, n_uword_bits - 1));
  228618:	c4 e2 18 f7 c0       	bextr  eax,eax,r12d
  22861d:	8d 0c 48             	lea    ecx,[rax+rcx*2]
        q = (q << 1) | carry;
  228620:	42 8d 44 5d 00       	lea    eax,[rbp+r11*2+0x0]
        const s = @intCast(i32, d -% r -% 1) >> @intCast(u5, n_uword_bits - 1);
  228625:	44 89 c3             	mov    ebx,r8d
  228628:	29 cb                	sub    ebx,ecx
  22862a:	c1 fb 1f             	sar    ebx,0x1f
        carry = @intCast(u32, s & 1);
  22862d:	41 89 db             	mov    r11d,ebx
  228630:	41 83 e3 01          	and    r11d,0x1
        r -= d & @bitCast(u32, s);
  228634:	21 f3                	and    ebx,esi
  228636:	29 d9                	sub    ecx,ebx
    while (sr > 0) : (sr -= 1) {
  228638:	41 83 c2 04          	add    r10d,0x4
  22863c:	75 82                	jne    2285c0 <__udivmodsi4+0x90>
  22863e:	45 85 c9             	test   r9d,r9d
  228641:	74 2f                	je     228672 <__udivmodsi4+0x142>
  228643:	41 f7 d9             	neg    r9d
  228646:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  22864d:	00 00 00 
        r = (r << 1) | (q >> @intCast(u5, n_uword_bits - 1));
  228650:	0f a4 c1 01          	shld   ecx,eax,0x1
        q = (q << 1) | carry;
  228654:	01 c0                	add    eax,eax
  228656:	44 09 d8             	or     eax,r11d
        const s = @intCast(i32, d -% r -% 1) >> @intCast(u5, n_uword_bits - 1);
  228659:	44 89 c5             	mov    ebp,r8d
  22865c:	29 cd                	sub    ebp,ecx
  22865e:	c1 fd 1f             	sar    ebp,0x1f
        carry = @intCast(u32, s & 1);
  228661:	41 89 eb             	mov    r11d,ebp
  228664:	41 83 e3 01          	and    r11d,0x1
        r -= d & @bitCast(u32, s);
  228668:	21 f5                	and    ebp,esi
  22866a:	29 e9                	sub    ecx,ebp
    while (sr > 0) : (sr -= 1) {
  22866c:	41 83 c1 01          	add    r9d,0x1
  228670:	75 de                	jne    228650 <__udivmodsi4+0x120>
    q = (q << 1) | carry;
  228672:	01 c0                	add    eax,eax
  228674:	44 09 d8             	or     eax,r11d
    rem.* = @bitCast(u32, @bitCast(i32, a) -% (@bitCast(i32, d) * @bitCast(i32, b)));
  228677:	0f af f0             	imul   esi,eax
  22867a:	29 f7                	sub    edi,esi
  22867c:	89 3a                	mov    DWORD PTR [rdx],edi
    return d;
  22867e:	5b                   	pop    rbx
  22867f:	41 5c                	pop    r12
  228681:	41 5d                	pop    r13
  228683:	41 5e                	pop    r14
  228685:	41 5f                	pop    r15
  228687:	5d                   	pop    rbp
  228688:	c3                   	ret    
  228689:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

0000000000228690 <__divti3>:
const compiler_rt = @import("index.zig");

pub extern fn __divti3(a: i128, b: i128) i128 {
    @setRuntimeSafety(builtin.is_test);

    const s_a = a >> (i128.bit_count - 1);
  228690:	41 56                	push   r14
  228692:	53                   	push   rbx
  228693:	50                   	push   rax
  228694:	48 89 f0             	mov    rax,rsi
  228697:	48 c1 f8 3f          	sar    rax,0x3f
    const s_b = b >> (i128.bit_count - 1);
  22869b:	49 89 ce             	mov    r14,rcx
  22869e:	49 31 f6             	xor    r14,rsi
  2286a1:	48 89 cb             	mov    rbx,rcx
  2286a4:	48 c1 fb 3f          	sar    rbx,0x3f

    const an = (a ^ s_a) -% s_a;
  2286a8:	48 31 c6             	xor    rsi,rax
  2286ab:	48 31 c7             	xor    rdi,rax
  2286ae:	48 29 c7             	sub    rdi,rax
  2286b1:	48 19 c6             	sbb    rsi,rax
    const bn = (b ^ s_b) -% s_b;
  2286b4:	48 31 d9             	xor    rcx,rbx
  2286b7:	48 31 da             	xor    rdx,rbx
  2286ba:	48 29 da             	sub    rdx,rbx
  2286bd:	48 19 d9             	sbb    rcx,rbx

    const r = udivmod(u128, @bitCast(u128, an), @bitCast(u128, bn), null);
  2286c0:	45 31 c0             	xor    r8d,r8d
  2286c3:	e8 18 00 00 00       	call   2286e0 <udivmod.14>
    const s = s_a ^ s_b;
  2286c8:	49 c1 fe 3f          	sar    r14,0x3f
    return (@bitCast(i128, r) ^ s) -% s;
  2286cc:	4c 31 f2             	xor    rdx,r14
  2286cf:	4c 31 f0             	xor    rax,r14
  2286d2:	4c 29 f0             	sub    rax,r14
  2286d5:	4c 19 f2             	sbb    rdx,r14
  2286d8:	48 83 c4 08          	add    rsp,0x8
  2286dc:	5b                   	pop    rbx
  2286dd:	41 5e                	pop    r14
  2286df:	c3                   	ret    

00000000002286e0 <udivmod.14>:
pub fn udivmod(comptime DoubleInt: type, a: DoubleInt, b: DoubleInt, maybe_rem: ?*DoubleInt) DoubleInt {
  2286e0:	55                   	push   rbp
  2286e1:	41 57                	push   r15
  2286e3:	41 56                	push   r14
  2286e5:	41 55                	push   r13
  2286e7:	41 54                	push   r12
  2286e9:	53                   	push   rbx
  2286ea:	49 89 d1             	mov    r9,rdx
    if (n[high] == 0) {
  2286ed:	48 85 f6             	test   rsi,rsi
  2286f0:	74 38                	je     22872a <udivmod.14+0x4a>
    if (d[low] == 0) {
  2286f2:	4d 85 c9             	test   r9,r9
  2286f5:	74 55                	je     22874c <udivmod.14+0x6c>
  2286f7:	48 85 c9             	test   rcx,rcx
        if (d[high] == 0) {
  2286fa:	0f 84 af 00 00 00    	je     2287af <udivmod.14+0xcf>
            sr = @bitCast(c_uint, c_int(@clz(d[high])) - c_int(@clz(n[high])));
  228700:	f3 48 0f bd c1       	lzcnt  rax,rcx
  228705:	f3 48 0f bd d6       	lzcnt  rdx,rsi
  22870a:	29 d0                	sub    eax,edx
            if (sr > SingleInt.bit_count - 1) {
  22870c:	83 f8 40             	cmp    eax,0x40
  22870f:	0f 82 23 01 00 00    	jb     228838 <udivmod.14+0x158>
  228715:	4d 85 c0             	test   r8,r8
  228718:	0f 84 3f 01 00 00    	je     22885d <udivmod.14+0x17d>
  22871e:	49 89 38             	mov    QWORD PTR [r8],rdi
  228721:	49 89 70 08          	mov    QWORD PTR [r8+0x8],rsi
  228725:	e9 33 01 00 00       	jmp    22885d <udivmod.14+0x17d>
        if (d[high] == 0) {
  22872a:	48 85 c9             	test   rcx,rcx
  22872d:	0f 84 df 00 00 00    	je     228812 <udivmod.14+0x132>
  228733:	4d 85 c0             	test   r8,r8
        if (maybe_rem) |rem| {
  228736:	0f 84 21 01 00 00    	je     22885d <udivmod.14+0x17d>
            rem.* = n[low];
  22873c:	49 89 38             	mov    QWORD PTR [r8],rdi
  22873f:	49 c7 40 08 00 00 00 	mov    QWORD PTR [r8+0x8],0x0
  228746:	00 
  228747:	e9 11 01 00 00       	jmp    22885d <udivmod.14+0x17d>
  22874c:	48 85 c9             	test   rcx,rcx
        if (d[high] == 0) {
  22874f:	0f 84 fa 00 00 00    	je     22884f <udivmod.14+0x16f>
        if (n[low] == 0) {
  228755:	48 85 ff             	test   rdi,rdi
  228758:	0f 84 6e 02 00 00    	je     2289cc <udivmod.14+0x2ec>
        if ((d[high] & (d[high] - 1)) == 0) {
  22875e:	48 8d 41 ff          	lea    rax,[rcx-0x1]
  228762:	48 85 c8             	test   rax,rcx
  228765:	0f 84 c3 02 00 00    	je     228a2e <udivmod.14+0x34e>
        sr = @bitCast(c_uint, c_int(@clz(d[high])) - c_int(@clz(n[high])));
  22876b:	f3 4c 0f bd d1       	lzcnt  r10,rcx
  228770:	f3 48 0f bd c6       	lzcnt  rax,rsi
  228775:	41 29 c2             	sub    r10d,eax
        if (sr > SingleInt.bit_count - 2) {
  228778:	41 83 fa 3f          	cmp    r10d,0x3f
  22877c:	73 97                	jae    228715 <udivmod.14+0x35>
        q[high] = n[low] << @intCast(Log2SingleInt, SingleInt.bit_count - sr);
  22877e:	b8 3f 00 00 00       	mov    eax,0x3f
  228783:	44 29 d0             	sub    eax,r10d
        sr += 1;
  228786:	41 83 c2 01          	add    r10d,0x1
        q[high] = n[low] << @intCast(Log2SingleInt, SingleInt.bit_count - sr);
  22878a:	83 e0 3f             	and    eax,0x3f
        r[high] = n[high] >> @intCast(Log2SingleInt, sr);
  22878d:	44 89 d5             	mov    ebp,r10d
  228790:	83 e5 3f             	and    ebp,0x3f
  228793:	c4 e2 d3 f7 d6       	shrx   rdx,rsi,rbp
        r[low] = (n[high] << @intCast(Log2SingleInt, SingleInt.bit_count - sr)) | (n[low] >> @intCast(Log2SingleInt, sr));
  228798:	c4 e2 f9 f7 de       	shlx   rbx,rsi,rax
  22879d:	c4 e2 d3 f7 f7       	shrx   rsi,rdi,rbp
        q[high] = n[low] << @intCast(Log2SingleInt, SingleInt.bit_count - sr);
  2287a2:	c4 e2 f9 f7 ff       	shlx   rdi,rdi,rax
        r[low] = (n[high] << @intCast(Log2SingleInt, SingleInt.bit_count - sr)) | (n[low] >> @intCast(Log2SingleInt, sr));
  2287a7:	48 09 de             	or     rsi,rbx
  2287aa:	e9 de 00 00 00       	jmp    22888d <udivmod.14+0x1ad>
            if ((d[low] & (d[low] - 1)) == 0) {
  2287af:	49 8d 41 ff          	lea    rax,[r9-0x1]
  2287b3:	4c 85 c8             	test   rax,r9
  2287b6:	0f 84 36 02 00 00    	je     2289f2 <udivmod.14+0x312>
            sr = 1 + SingleInt.bit_count + c_uint(@clz(d[low])) - c_uint(@clz(n[high]));
  2287bc:	f3 4d 0f bd d1       	lzcnt  r10,r9
  2287c1:	41 83 c2 41          	add    r10d,0x41
  2287c5:	f3 48 0f bd c6       	lzcnt  rax,rsi
  2287ca:	41 29 c2             	sub    r10d,eax
            if (sr == SingleInt.bit_count) {
  2287cd:	41 83 fa 40          	cmp    r10d,0x40
  2287d1:	74 6f                	je     228842 <udivmod.14+0x162>
  2287d3:	44 89 d3             	mov    ebx,r10d
  2287d6:	f7 db                	neg    ebx
  2287d8:	83 e3 3f             	and    ebx,0x3f
  2287db:	c4 62 e1 f7 e7       	shlx   r12,rdi,rbx
            } else if (sr < SingleInt.bit_count) {
  2287e0:	41 83 fa 40          	cmp    r10d,0x40
  2287e4:	0f 83 90 02 00 00    	jae    228a7a <udivmod.14+0x39a>
  2287ea:	31 ed                	xor    ebp,ebp
    while (sr > 0) : (sr -= 1) {
  2287ec:	45 85 d2             	test   r10d,r10d
  2287ef:	0f 84 de 02 00 00    	je     228ad3 <udivmod.14+0x3f3>
  2287f5:	44 89 d5             	mov    ebp,r10d
  2287f8:	83 e5 3f             	and    ebp,0x3f
  2287fb:	c4 e2 d3 f7 d6       	shrx   rdx,rsi,rbp
  228800:	c4 e2 e1 f7 de       	shlx   rbx,rsi,rbx
  228805:	c4 e2 d3 f7 f7       	shrx   rsi,rdi,rbp
  22880a:	48 09 de             	or     rsi,rbx
  22880d:	4c 89 e7             	mov    rdi,r12
  228810:	eb 7b                	jmp    22888d <udivmod.14+0x1ad>
  228812:	4d 85 c0             	test   r8,r8
            if (maybe_rem) |rem| {
  228815:	0f 84 40 02 00 00    	je     228a5b <udivmod.14+0x37b>
  22881b:	48 89 f8             	mov    rax,rdi
  22881e:	4c 09 c8             	or     rax,r9
  228821:	48 c1 e8 20          	shr    rax,0x20
  228825:	0f 84 1e 02 00 00    	je     228a49 <udivmod.14+0x369>
  22882b:	31 d2                	xor    edx,edx
  22882d:	48 89 f8             	mov    rax,rdi
  228830:	49 f7 f1             	div    r9
  228833:	e9 18 02 00 00       	jmp    228a50 <udivmod.14+0x370>
            sr += 1;
  228838:	44 8d 50 01          	lea    r10d,[rax+0x1]
            if (sr == SingleInt.bit_count) {
  22883c:	41 83 fa 40          	cmp    r10d,0x40
  228840:	75 24                	jne    228866 <udivmod.14+0x186>
  228842:	41 ba 40 00 00 00    	mov    r10d,0x40
  228848:	45 31 e4             	xor    r12d,r12d
  22884b:	31 d2                	xor    edx,edx
  22884d:	eb 41                	jmp    228890 <udivmod.14+0x1b0>
            if (maybe_rem) |rem| {
  22884f:	4d 85 c0             	test   r8,r8
  228852:	74 09                	je     22885d <udivmod.14+0x17d>
                rem.* = n[high] % d[low];
  228854:	c5 f8 57 c0          	vxorps xmm0,xmm0,xmm0
  228858:	c4 c1 78 11 00       	vmovups XMMWORD PTR [r8],xmm0
  22885d:	31 ff                	xor    edi,edi
  22885f:	31 f6                	xor    esi,esi
  228861:	e9 5b 01 00 00       	jmp    2289c1 <udivmod.14+0x2e1>
                r[high] = n[high] >> @intCast(Log2SingleInt, sr);
  228866:	44 89 d5             	mov    ebp,r10d
  228869:	83 e5 3f             	and    ebp,0x3f
  22886c:	c4 e2 d3 f7 d6       	shrx   rdx,rsi,rbp
  228871:	bb 3f 00 00 00       	mov    ebx,0x3f
                r[low] = (n[high] << @intCast(Log2SingleInt, SingleInt.bit_count - sr)) | (n[low] >> @intCast(Log2SingleInt, sr));
  228876:	29 c3                	sub    ebx,eax
  228878:	83 e3 3f             	and    ebx,0x3f
  22887b:	c4 e2 e1 f7 c6       	shlx   rax,rsi,rbx
  228880:	c4 e2 d3 f7 f7       	shrx   rsi,rdi,rbp
  228885:	48 09 c6             	or     rsi,rax
                q[high] = n[low] << @intCast(Log2SingleInt, SingleInt.bit_count - sr);
  228888:	c4 e2 e1 f7 ff       	shlx   rdi,rdi,rbx
  22888d:	45 31 e4             	xor    r12d,r12d
  228890:	4d 89 cf             	mov    r15,r9
  228893:	49 83 c7 ff          	add    r15,0xffffffffffffffff
  228897:	49 89 cb             	mov    r11,rcx
  22889a:	49 83 d3 ff          	adc    r11,0xffffffffffffffff
    while (sr > 0) : (sr -= 1) {
  22889e:	44 89 d0             	mov    eax,r10d
  2288a1:	83 e0 01             	and    eax,0x1
  2288a4:	31 ed                	xor    ebp,ebp
  2288a6:	41 83 fa 01          	cmp    r10d,0x1
  2288aa:	75 0f                	jne    2288bb <udivmod.14+0x1db>
  2288ac:	31 db                	xor    ebx,ebx
  2288ae:	85 c0                	test   eax,eax
  2288b0:	0f 85 ac 00 00 00    	jne    228962 <udivmod.14+0x282>
  2288b6:	e9 da 00 00 00       	jmp    228995 <udivmod.14+0x2b5>
  2288bb:	4c 89 44 24 f8       	mov    QWORD PTR [rsp-0x8],r8
  2288c0:	89 44 24 f4          	mov    DWORD PTR [rsp-0xc],eax
  2288c4:	41 89 c5             	mov    r13d,eax
  2288c7:	45 29 d5             	sub    r13d,r10d
  2288ca:	41 ba 3e 01 00 00    	mov    r10d,0x13e
        r[high] = (r[high] << 1) | (r[low] >> (SingleInt.bit_count - 1));
  2288d0:	48 0f a4 f2 01       	shld   rdx,rsi,0x1
        r[low] = (r[low] << 1) | (q[high] >> (SingleInt.bit_count - 1));
  2288d5:	48 0f a4 fe 01       	shld   rsi,rdi,0x1
        q[high] = (q[high] << 1) | (q[low] >> (SingleInt.bit_count - 1));
  2288da:	48 89 f8             	mov    rax,rdi
  2288dd:	4c 0f a4 e0 01       	shld   rax,r12,0x1
        q[low] = (q[low] << 1) | carry;
  2288e2:	4b 8d 1c 24          	lea    rbx,[r12+r12*1]
  2288e6:	89 ed                	mov    ebp,ebp
  2288e8:	48 09 dd             	or     rbp,rbx
        const s: SignedDoubleInt = @intCast(SignedDoubleInt, b -% r_all -% 1) >> (DoubleInt.bit_count - 1);
  2288eb:	49 39 f7             	cmp    r15,rsi
  2288ee:	4c 89 db             	mov    rbx,r11
  2288f1:	48 19 d3             	sbb    rbx,rdx
  2288f4:	48 c1 fb 3f          	sar    rbx,0x3f
        carry = @intCast(u32, s & 1);
  2288f8:	41 89 de             	mov    r14d,ebx
  2288fb:	41 83 e6 01          	and    r14d,0x1
        r_all -= b & @bitCast(DoubleInt, s);
  2288ff:	49 89 d8             	mov    r8,rbx
  228902:	49 21 c8             	and    r8,rcx
  228905:	4c 21 cb             	and    rbx,r9
  228908:	48 29 de             	sub    rsi,rbx
  22890b:	4c 19 c2             	sbb    rdx,r8
        r[high] = (r[high] << 1) | (r[low] >> (SingleInt.bit_count - 1));
  22890e:	48 0f a4 f2 01       	shld   rdx,rsi,0x1
        r[low] = (r[low] << 1) | (q[high] >> (SingleInt.bit_count - 1));
  228913:	c4 e2 a8 f7 ff       	bextr  rdi,rdi,r10
  228918:	48 8d 34 77          	lea    rsi,[rdi+rsi*2]
        q[high] = (q[high] << 1) | (q[low] >> (SingleInt.bit_count - 1));
  22891c:	c4 c2 a8 f7 fc       	bextr  rdi,r12,r10
  228921:	48 8d 3c 47          	lea    rdi,[rdi+rax*2]
        q[low] = (q[low] << 1) | carry;
  228925:	4d 8d 24 6e          	lea    r12,[r14+rbp*2]
        const s: SignedDoubleInt = @intCast(SignedDoubleInt, b -% r_all -% 1) >> (DoubleInt.bit_count - 1);
  228929:	49 39 f7             	cmp    r15,rsi
  22892c:	4c 89 d8             	mov    rax,r11
  22892f:	48 19 d0             	sbb    rax,rdx
  228932:	48 c1 f8 3f          	sar    rax,0x3f
        carry = @intCast(u32, s & 1);
  228936:	89 c5                	mov    ebp,eax
  228938:	83 e5 01             	and    ebp,0x1
        r_all -= b & @bitCast(DoubleInt, s);
  22893b:	48 89 c3             	mov    rbx,rax
  22893e:	48 21 cb             	and    rbx,rcx
  228941:	4c 21 c8             	and    rax,r9
  228944:	48 29 c6             	sub    rsi,rax
  228947:	48 19 da             	sbb    rdx,rbx
    while (sr > 0) : (sr -= 1) {
  22894a:	41 83 c5 02          	add    r13d,0x2
  22894e:	75 80                	jne    2288d0 <udivmod.14+0x1f0>
  228950:	89 eb                	mov    ebx,ebp
  228952:	49 89 f2             	mov    r10,rsi
  228955:	4c 8b 44 24 f8       	mov    r8,QWORD PTR [rsp-0x8]
  22895a:	8b 44 24 f4          	mov    eax,DWORD PTR [rsp-0xc]
  22895e:	85 c0                	test   eax,eax
  228960:	74 33                	je     228995 <udivmod.14+0x2b5>
        r[high] = (r[high] << 1) | (r[low] >> (SingleInt.bit_count - 1));
  228962:	48 0f a4 f2 01       	shld   rdx,rsi,0x1
        r[low] = (r[low] << 1) | (q[high] >> (SingleInt.bit_count - 1));
  228967:	48 0f a4 fe 01       	shld   rsi,rdi,0x1
        const s: SignedDoubleInt = @intCast(SignedDoubleInt, b -% r_all -% 1) >> (DoubleInt.bit_count - 1);
  22896c:	49 39 f7             	cmp    r15,rsi
  22896f:	49 19 d3             	sbb    r11,rdx
  228972:	49 c1 fb 3f          	sar    r11,0x3f
        r_all -= b & @bitCast(DoubleInt, s);
  228976:	4c 21 d9             	and    rcx,r11
  228979:	4d 21 d9             	and    r9,r11
  22897c:	4c 29 ce             	sub    rsi,r9
  22897f:	48 19 ca             	sbb    rdx,rcx
        carry = @intCast(u32, s & 1);
  228982:	41 83 e3 01          	and    r11d,0x1
        q[high] = (q[high] << 1) | (q[low] >> (SingleInt.bit_count - 1));
  228986:	4c 0f a4 e7 01       	shld   rdi,r12,0x1
        q[low] = (q[low] << 1) | carry;
  22898b:	4e 8d 24 63          	lea    r12,[rbx+r12*2]
  22898f:	44 89 dd             	mov    ebp,r11d
  228992:	49 89 f2             	mov    r10,rsi
  228995:	48 89 f8             	mov    rax,rdi
    const q_all = ((@ptrCast(*align(@alignOf(SingleInt)) DoubleInt, &q[0]).*) << 1) | carry; // TODO issue #421
  228998:	89 ed                	mov    ebp,ebp
  22899a:	31 c9                	xor    ecx,ecx
  22899c:	4c 89 e7             	mov    rdi,r12
  22899f:	31 f6                	xor    esi,esi
  2289a1:	49 89 c4             	mov    r12,rax
  2289a4:	4c 09 e6             	or     rsi,r12
  2289a7:	48 0f a4 fe 01       	shld   rsi,rdi,0x1
  2289ac:	48 09 ce             	or     rsi,rcx
  2289af:	48 01 ff             	add    rdi,rdi
  2289b2:	48 09 ef             	or     rdi,rbp
    if (maybe_rem) |rem| {
  2289b5:	4d 85 c0             	test   r8,r8
  2289b8:	74 07                	je     2289c1 <udivmod.14+0x2e1>
        rem.* = r_all;
  2289ba:	4d 89 10             	mov    QWORD PTR [r8],r10
  2289bd:	49 89 50 08          	mov    QWORD PTR [r8+0x8],rdx
        return 0;
  2289c1:	48 89 f8             	mov    rax,rdi
  2289c4:	48 89 f2             	mov    rdx,rsi
  2289c7:	e9 fc 00 00 00       	jmp    228ac8 <udivmod.14+0x3e8>
            if (maybe_rem) |rem| {
  2289cc:	4d 85 c0             	test   r8,r8
  2289cf:	0f 84 d5 00 00 00    	je     228aaa <udivmod.14+0x3ca>
  2289d5:	48 89 f0             	mov    rax,rsi
  2289d8:	48 09 c8             	or     rax,rcx
  2289db:	48 c1 e8 20          	shr    rax,0x20
  2289df:	0f 84 b4 00 00 00    	je     228a99 <udivmod.14+0x3b9>
  2289e5:	31 d2                	xor    edx,edx
  2289e7:	48 89 f0             	mov    rax,rsi
  2289ea:	48 f7 f1             	div    rcx
  2289ed:	e9 ad 00 00 00       	jmp    228a9f <udivmod.14+0x3bf>
                if (maybe_rem) |rem| {
  2289f2:	4d 85 c0             	test   r8,r8
  2289f5:	74 0e                	je     228a05 <udivmod.14+0x325>
                    rem.* = n[low] & (d[low] - 1);
  2289f7:	48 21 f8             	and    rax,rdi
  2289fa:	49 89 00             	mov    QWORD PTR [r8],rax
  2289fd:	49 c7 40 08 00 00 00 	mov    QWORD PTR [r8+0x8],0x0
  228a04:	00 
                if (d[low] == 1) {
  228a05:	49 83 f9 01          	cmp    r9,0x1
  228a09:	74 b6                	je     2289c1 <udivmod.14+0x2e1>
                sr = @ctz(d[low]);
  228a0b:	f3 49 0f bc c1       	tzcnt  rax,r9
                q[high] = n[high] >> @intCast(Log2SingleInt, sr);
  228a10:	89 c1                	mov    ecx,eax
  228a12:	83 e1 3f             	and    ecx,0x3f
  228a15:	c4 e2 f3 f7 d6       	shrx   rdx,rsi,rcx
                q[low] = (n[high] << @intCast(Log2SingleInt, SingleInt.bit_count - sr)) | (n[low] >> @intCast(Log2SingleInt, sr));
  228a1a:	f7 d8                	neg    eax
  228a1c:	c4 e2 f9 f7 f6       	shlx   rsi,rsi,rax
  228a21:	c4 e2 f3 f7 c7       	shrx   rax,rdi,rcx
  228a26:	48 09 f0             	or     rax,rsi
  228a29:	e9 9a 00 00 00       	jmp    228ac8 <udivmod.14+0x3e8>
            if (maybe_rem) |rem| {
  228a2e:	4d 85 c0             	test   r8,r8
  228a31:	74 0a                	je     228a3d <udivmod.14+0x35d>
                r[high] = n[high] & (d[high] - 1);
  228a33:	48 21 f0             	and    rax,rsi
                rem.* = @ptrCast(*align(@alignOf(SingleInt)) DoubleInt, &r[0]).*; // TODO issue #421
  228a36:	49 89 38             	mov    QWORD PTR [r8],rdi
  228a39:	49 89 40 08          	mov    QWORD PTR [r8+0x8],rax
            return n[high] >> @intCast(Log2SingleInt, @ctz(d[high]));
  228a3d:	f3 48 0f bc c1       	tzcnt  rax,rcx
  228a42:	c4 e2 fb f7 c6       	shrx   rax,rsi,rax
  228a47:	eb 7d                	jmp    228ac6 <udivmod.14+0x3e6>
  228a49:	31 d2                	xor    edx,edx
  228a4b:	89 f8                	mov    eax,edi
  228a4d:	41 f7 f1             	div    r9d
                rem.* = n[low] % d[low];
  228a50:	49 89 10             	mov    QWORD PTR [r8],rdx
  228a53:	49 c7 40 08 00 00 00 	mov    QWORD PTR [r8+0x8],0x0
  228a5a:	00 
  228a5b:	48 89 f8             	mov    rax,rdi
  228a5e:	4c 09 c8             	or     rax,r9
  228a61:	48 c1 e8 20          	shr    rax,0x20
  228a65:	74 0a                	je     228a71 <udivmod.14+0x391>
  228a67:	31 d2                	xor    edx,edx
  228a69:	48 89 f8             	mov    rax,rdi
  228a6c:	49 f7 f1             	div    r9
  228a6f:	eb 55                	jmp    228ac6 <udivmod.14+0x3e6>
  228a71:	31 d2                	xor    edx,edx
  228a73:	89 f8                	mov    eax,edi
  228a75:	41 f7 f1             	div    r9d
  228a78:	eb 4c                	jmp    228ac6 <udivmod.14+0x3e6>
                q[high] = (n[high] << @intCast(Log2SingleInt, DoubleInt.bit_count - sr)) | (n[low] >> @intCast(Log2SingleInt, sr - SingleInt.bit_count));
  228a7a:	c4 e2 e1 f7 d6       	shlx   rdx,rsi,rbx
  228a7f:	44 89 d5             	mov    ebp,r10d
  228a82:	83 e5 3f             	and    ebp,0x3f
  228a85:	c4 e2 d3 f7 ff       	shrx   rdi,rdi,rbp
  228a8a:	48 09 d7             	or     rdi,rdx
                r[low] = n[high] >> @intCast(Log2SingleInt, sr - SingleInt.bit_count);
  228a8d:	c4 e2 d3 f7 f6       	shrx   rsi,rsi,rbp
  228a92:	31 d2                	xor    edx,edx
  228a94:	e9 f7 fd ff ff       	jmp    228890 <udivmod.14+0x1b0>
  228a99:	31 d2                	xor    edx,edx
  228a9b:	89 f0                	mov    eax,esi
  228a9d:	f7 f1                	div    ecx
                rem.* = @ptrCast(*align(@alignOf(SingleInt)) DoubleInt, &r[0]).*; // TODO issue #421
  228a9f:	49 89 50 08          	mov    QWORD PTR [r8+0x8],rdx
  228aa3:	49 c7 00 00 00 00 00 	mov    QWORD PTR [r8],0x0
  228aaa:	48 89 f0             	mov    rax,rsi
  228aad:	48 09 c8             	or     rax,rcx
  228ab0:	48 c1 e8 20          	shr    rax,0x20
  228ab4:	74 0a                	je     228ac0 <udivmod.14+0x3e0>
  228ab6:	31 d2                	xor    edx,edx
  228ab8:	48 89 f0             	mov    rax,rsi
  228abb:	48 f7 f1             	div    rcx
  228abe:	eb 06                	jmp    228ac6 <udivmod.14+0x3e6>
  228ac0:	31 d2                	xor    edx,edx
  228ac2:	89 f0                	mov    eax,esi
  228ac4:	f7 f1                	div    ecx
  228ac6:	31 d2                	xor    edx,edx
  228ac8:	5b                   	pop    rbx
  228ac9:	41 5c                	pop    r12
  228acb:	41 5d                	pop    r13
  228acd:	41 5e                	pop    r14
  228acf:	41 5f                	pop    r15
  228ad1:	5d                   	pop    rbp
  228ad2:	c3                   	ret    
  228ad3:	31 c9                	xor    ecx,ecx
  228ad5:	31 ff                	xor    edi,edi
  228ad7:	31 f6                	xor    esi,esi
  228ad9:	e9 c6 fe ff ff       	jmp    2289a4 <udivmod.14+0x2c4>
  228ade:	66 90                	xchg   ax,ax

0000000000228ae0 <__muloti4>:
const udivmod = @import("udivmod.zig").udivmod;
const builtin = @import("builtin");
const compiler_rt = @import("index.zig");

pub extern fn __muloti4(a: i128, b: i128, overflow: *c_int) i128 {
  228ae0:	55                   	push   rbp
  228ae1:	41 57                	push   r15
  228ae3:	41 56                	push   r14
  228ae5:	41 55                	push   r13
  228ae7:	41 54                	push   r12
  228ae9:	53                   	push   rbx
  228aea:	48 83 ec 28          	sub    rsp,0x28
  228aee:	4d 89 c7             	mov    r15,r8
  228af1:	48 89 d5             	mov    rbp,rdx
  228af4:	49 89 f4             	mov    r12,rsi
  228af7:	48 89 fb             	mov    rbx,rdi
  228afa:	c4 c1 f9 6e c4       	vmovq  xmm0,r12
  228aff:	c4 e1 f9 6e cb       	vmovq  xmm1,rbx
  228b04:	c5 f1 6c c0          	vpunpcklqdq xmm0,xmm1,xmm0
    @setRuntimeSafety(builtin.is_test);

    const min = @bitCast(i128, u128(1 << (i128.bit_count - 1)));
    const max = ~min;
    overflow.* = 0;
  228b08:	41 c7 07 00 00 00 00 	mov    DWORD PTR [r15],0x0

    const r = a *% b;
  228b0f:	48 89 e8             	mov    rax,rbp
  228b12:	49 0f af c4          	imul   rax,r12
  228b16:	c4 e2 8b f6 d3       	mulx   rdx,r14,rbx
  228b1b:	48 01 c2             	add    rdx,rax
  228b1e:	49 89 cd             	mov    r13,rcx
  228b21:	4c 0f af eb          	imul   r13,rbx
  228b25:	49 01 d5             	add    r13,rdx
    if (a == min) {
  228b28:	48 be 00 00 00 00 00 	movabs rsi,0x8000000000000000
  228b2f:	00 00 80 
  228b32:	c4 e1 f9 6e ce       	vmovq  xmm1,rsi
  228b37:	c5 e9 73 f9 08       	vpslldq xmm2,xmm1,0x8
  228b3c:	c5 f9 74 c2          	vpcmpeqb xmm0,xmm0,xmm2
  228b40:	c5 f9 d7 c0          	vpmovmskb eax,xmm0
  228b44:	3d ff ff 00 00       	cmp    eax,0xffff
  228b49:	75 13                	jne    228b5e <__muloti4+0x7e>
        if (b != 0 and b != 1) {
  228b4b:	48 83 fd 02          	cmp    rbp,0x2
  228b4f:	48 83 d9 00          	sbb    rcx,0x0
  228b53:	0f 83 b7 00 00 00    	jae    228c10 <__muloti4+0x130>
  228b59:	e9 b9 00 00 00       	jmp    228c17 <__muloti4+0x137>
            overflow.* = 1;
        }
        return r;
    }
    if (b == min) {
  228b5e:	c4 e1 f9 6e c5       	vmovq  xmm0,rbp
  228b63:	c4 e1 f9 6e c9       	vmovq  xmm1,rcx
  228b68:	c5 f9 6c c1          	vpunpcklqdq xmm0,xmm0,xmm1
  228b6c:	c5 f9 74 c2          	vpcmpeqb xmm0,xmm0,xmm2
  228b70:	c5 f9 d7 c0          	vpmovmskb eax,xmm0
  228b74:	3d ff ff 00 00       	cmp    eax,0xffff
  228b79:	75 13                	jne    228b8e <__muloti4+0xae>
        if (a != 0 and a != 1) {
  228b7b:	48 83 fb 02          	cmp    rbx,0x2
  228b7f:	49 83 dc 00          	sbb    r12,0x0
  228b83:	0f 83 87 00 00 00    	jae    228c10 <__muloti4+0x130>
  228b89:	e9 89 00 00 00       	jmp    228c17 <__muloti4+0x137>
            overflow.* = 1;
        }
        return r;
    }

    const sa = a >> (i128.bit_count - 1);
  228b8e:	4c 89 e0             	mov    rax,r12
  228b91:	48 c1 f8 3f          	sar    rax,0x3f
    const abs_a = (a ^ sa) -% sa;
  228b95:	49 31 c4             	xor    r12,rax
  228b98:	48 31 c3             	xor    rbx,rax
  228b9b:	48 29 c3             	sub    rbx,rax
  228b9e:	49 19 c4             	sbb    r12,rax
    const sb = b >> (i128.bit_count - 1);
  228ba1:	48 89 ca             	mov    rdx,rcx
  228ba4:	48 c1 fa 3f          	sar    rdx,0x3f
    const abs_b = (b ^ sb) -% sb;
  228ba8:	48 31 d1             	xor    rcx,rdx
  228bab:	48 31 d5             	xor    rbp,rdx
  228bae:	48 29 d5             	sub    rbp,rdx
  228bb1:	48 19 d1             	sbb    rcx,rdx

    if (abs_a < 2 or abs_b < 2) {
  228bb4:	48 83 fb 02          	cmp    rbx,0x2
  228bb8:	4c 89 e7             	mov    rdi,r12
  228bbb:	48 83 df 00          	sbb    rdi,0x0
  228bbf:	7c 56                	jl     228c17 <__muloti4+0x137>
  228bc1:	48 83 fd 02          	cmp    rbp,0x2
  228bc5:	48 89 cf             	mov    rdi,rcx
  228bc8:	48 83 df 00          	sbb    rdi,0x0
  228bcc:	7c 49                	jl     228c17 <__muloti4+0x137>
        return r;
    }

    if (sa == sb) {
  228bce:	c4 e1 f9 6e c2       	vmovq  xmm0,rdx
  228bd3:	c5 f9 6c c0          	vpunpcklqdq xmm0,xmm0,xmm0
  228bd7:	c4 e1 f9 6e c8       	vmovq  xmm1,rax
  228bdc:	c5 f1 6c c9          	vpunpcklqdq xmm1,xmm1,xmm1
  228be0:	c5 f1 74 c0          	vpcmpeqb xmm0,xmm1,xmm0
  228be4:	c5 f9 d7 c0          	vpmovmskb eax,xmm0
  228be8:	3d ff ff 00 00       	cmp    eax,0xffff
  228bed:	75 3d                	jne    228c2c <__muloti4+0x14c>
  228bef:	48 be ff ff ff ff ff 	movabs rsi,0x7fffffffffffffff
  228bf6:	ff ff 7f 
  228bf9:	48 c7 c7 ff ff ff ff 	mov    rdi,0xffffffffffffffff
  228c00:	48 89 ea             	mov    rdx,rbp
  228c03:	e8 a8 00 00 00       	call   228cb0 <__udivti3>
        if (abs_a > @divFloor(max, abs_b)) {
  228c08:	48 39 d8             	cmp    rax,rbx
  228c0b:	4c 19 e2             	sbb    rdx,r12
  228c0e:	7d 07                	jge    228c17 <__muloti4+0x137>
  228c10:	41 c7 07 01 00 00 00 	mov    DWORD PTR [r15],0x1
        return r;
  228c17:	4c 89 f0             	mov    rax,r14
  228c1a:	4c 89 ea             	mov    rdx,r13
  228c1d:	48 83 c4 28          	add    rsp,0x28
  228c21:	5b                   	pop    rbx
  228c22:	41 5c                	pop    r12
  228c24:	41 5d                	pop    r13
  228c26:	41 5e                	pop    r14
  228c28:	41 5f                	pop    r15
  228c2a:	5d                   	pop    rbp
  228c2b:	c3                   	ret    
  228c2c:	31 c0                	xor    eax,eax
            overflow.* = 1;
        }
    } else {
        if (abs_a > @divFloor(min, -abs_b)) {
  228c2e:	48 f7 dd             	neg    rbp
  228c31:	48 19 c8             	sbb    rax,rcx
  228c34:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  228c39:	31 ff                	xor    edi,edi
  228c3b:	48 89 ea             	mov    rdx,rbp
  228c3e:	48 89 c1             	mov    rcx,rax
  228c41:	c5 f9 7f 54 24 10    	vmovdqa XMMWORD PTR [rsp+0x10],xmm2
  228c47:	e8 44 fa ff ff       	call   228690 <__divti3>
  228c4c:	48 89 d1             	mov    rcx,rdx
  228c4f:	48 85 c9             	test   rcx,rcx
  228c52:	41 0f 98 c0          	sets   r8b
  228c56:	48 89 c2             	mov    rdx,rax
  228c59:	c4 e2 eb f6 fd       	mulx   rdi,rdx,rbp
  228c5e:	48 8b 74 24 08       	mov    rsi,QWORD PTR [rsp+0x8]
  228c63:	48 0f af f0          	imul   rsi,rax
  228c67:	48 01 f7             	add    rdi,rsi
  228c6a:	48 0f af e9          	imul   rbp,rcx
  228c6e:	48 01 fd             	add    rbp,rdi
  228c71:	c4 e1 f9 6e c5       	vmovq  xmm0,rbp
  228c76:	c4 e1 f9 6e ca       	vmovq  xmm1,rdx
  228c7b:	c5 f1 6c c0          	vpunpcklqdq xmm0,xmm1,xmm0
  228c7f:	c5 f9 74 44 24 10    	vpcmpeqb xmm0,xmm0,XMMWORD PTR [rsp+0x10]
  228c85:	c5 f9 d7 d0          	vpmovmskb edx,xmm0
  228c89:	81 fa ff ff 00 00    	cmp    edx,0xffff
  228c8f:	0f 95 c2             	setne  dl
  228c92:	44 20 c2             	and    dl,r8b
  228c95:	0f b6 d2             	movzx  edx,dl
  228c98:	48 29 d0             	sub    rax,rdx
  228c9b:	48 83 d9 00          	sbb    rcx,0x0
  228c9f:	48 39 d8             	cmp    rax,rbx
  228ca2:	4c 19 e1             	sbb    rcx,r12
  228ca5:	0f 8c 65 ff ff ff    	jl     228c10 <__muloti4+0x130>
  228cab:	e9 67 ff ff ff       	jmp    228c17 <__muloti4+0x137>

0000000000228cb0 <__udivti3>:
const builtin = @import("builtin");
const compiler_rt = @import("index.zig");

pub extern fn __udivmodti4(a: u128, b: u128, maybe_rem: ?*u128) u128 {
    @setRuntimeSafety(builtin.is_test);
    return udivmod(u128, a, b, maybe_rem);
  228cb0:	45 31 c0             	xor    r8d,r8d
  228cb3:	e9 28 fa ff ff       	jmp    2286e0 <udivmod.14>
  228cb8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  228cbf:	00 

0000000000228cc0 <__udivmodti4>:
  228cc0:	e9 1b fa ff ff       	jmp    2286e0 <udivmod.14>
  228cc5:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  228ccc:	00 00 00 00 

0000000000228cd0 <__umodti3>:
const udivmodti4 = @import("udivmodti4.zig");
const builtin = @import("builtin");
const compiler_rt = @import("index.zig");

pub extern fn __umodti3(a: u128, b: u128) u128 {
  228cd0:	48 83 ec 18          	sub    rsp,0x18
  228cd4:	4c 8d 44 24 08       	lea    r8,[rsp+0x8]
  228cd9:	e8 02 fa ff ff       	call   2286e0 <udivmod.14>
    @setRuntimeSafety(builtin.is_test);
    var r: u128 = undefined;
    _ = udivmodti4.__udivmodti4(a, b, &r);
    return r;
  228cde:	48 8b 44 24 08       	mov    rax,QWORD PTR [rsp+0x8]
  228ce3:	48 8b 54 24 10       	mov    rdx,QWORD PTR [rsp+0x10]
  228ce8:	48 83 c4 18          	add    rsp,0x18
  228cec:	c3                   	ret    
