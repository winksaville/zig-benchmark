
./zig-cache/test:     file format elf64-x86-64


Disassembly of section .text:

000000000020a000 <ThreadSafeFixedBufferAllocator_alloc>:
            .buffer = buffer,
            .end_index = 0,
        };
    }

    fn alloc(allocator: *Allocator, n: usize, alignment: u29) ![]u8 {
  20a000:	49 89 d0             	mov    r8,rdx
        const self = @fieldParentPtr(ThreadSafeFixedBufferAllocator, "allocator", allocator);
        var end_index = @atomicLoad(usize, &self.end_index, builtin.AtomicOrder.SeqCst);
  20a003:	4c 8b 4e 18          	mov    r9,QWORD PTR [rsi+0x18]
  20a007:	48 8b 46 20          	mov    rax,QWORD PTR [rsi+0x20]
        while (true) {
            const addr = @ptrToInt(self.buffer.ptr) + end_index;
  20a00b:	4c 01 c8             	add    rax,r9
            const rem = @rem(addr, alignment);
  20a00e:	81 e1 ff ff ff 1f    	and    ecx,0x1fffffff
  20a014:	48 89 c2             	mov    rdx,rax
  20a017:	48 c1 ea 20          	shr    rdx,0x20
  20a01b:	75 13                	jne    20a030 <ThreadSafeFixedBufferAllocator_alloc+0x30>
  20a01d:	eb 21                	jmp    20a040 <ThreadSafeFixedBufferAllocator_alloc+0x40>
  20a01f:	90                   	nop
  20a020:	48 8b 46 20          	mov    rax,QWORD PTR [rsi+0x20]
            const addr = @ptrToInt(self.buffer.ptr) + end_index;
  20a024:	4c 01 c8             	add    rax,r9
  20a027:	48 89 c2             	mov    rdx,rax
  20a02a:	48 c1 ea 20          	shr    rdx,0x20
  20a02e:	74 10                	je     20a040 <ThreadSafeFixedBufferAllocator_alloc+0x40>
  20a030:	31 d2                	xor    edx,edx
  20a032:	48 f7 f1             	div    rcx
  20a035:	eb 0d                	jmp    20a044 <ThreadSafeFixedBufferAllocator_alloc+0x44>
  20a037:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  20a03e:	00 00 
  20a040:	31 d2                	xor    edx,edx
  20a042:	f7 f1                	div    ecx
            const march_forward_bytes = if (rem == 0) 0 else (alignment - rem);
  20a044:	49 89 ca             	mov    r10,rcx
  20a047:	49 29 d2             	sub    r10,rdx
  20a04a:	48 85 d2             	test   rdx,rdx
  20a04d:	4c 0f 44 d2          	cmove  r10,rdx
            const adjusted_index = end_index + march_forward_bytes;
  20a051:	4d 01 ca             	add    r10,r9
            const new_end_index = adjusted_index + n;
  20a054:	4b 8d 14 02          	lea    rdx,[r10+r8*1]
            if (new_end_index > self.buffer.len) {
  20a058:	48 3b 56 28          	cmp    rdx,QWORD PTR [rsi+0x28]
  20a05c:	77 33                	ja     20a091 <ThreadSafeFixedBufferAllocator_alloc+0x91>
                return error.OutOfMemory;
            }
            end_index = @cmpxchgWeak(usize, &self.end_index, end_index, new_end_index, builtin.AtomicOrder.SeqCst, builtin.AtomicOrder.SeqCst) orelse return self.buffer[adjusted_index..new_end_index];
  20a05e:	4c 89 c8             	mov    rax,r9
  20a061:	f0 48 0f b1 56 18    	lock cmpxchg QWORD PTR [rsi+0x18],rdx
  20a067:	49 89 c1             	mov    r9,rax
  20a06a:	75 b4                	jne    20a020 <ThreadSafeFixedBufferAllocator_alloc+0x20>
  20a06c:	4c 03 56 20          	add    r10,QWORD PTR [rsi+0x20]
  20a070:	66 c7 07 00 00       	mov    WORD PTR [rdi],0x0
  20a075:	0f b7 44 24 fe       	movzx  eax,WORD PTR [rsp-0x2]
  20a07a:	66 89 47 06          	mov    WORD PTR [rdi+0x6],ax
  20a07e:	8b 44 24 fa          	mov    eax,DWORD PTR [rsp-0x6]
  20a082:	89 47 02             	mov    DWORD PTR [rdi+0x2],eax
  20a085:	4c 89 57 08          	mov    QWORD PTR [rdi+0x8],r10
  20a089:	4c 89 47 10          	mov    QWORD PTR [rdi+0x10],r8
  20a08d:	48 89 f8             	mov    rax,rdi
  20a090:	c3                   	ret    
                return error.OutOfMemory;
  20a091:	48 8b 05 30 f6 ff ff 	mov    rax,QWORD PTR [rip+0xfffffffffffff630]        # 2096c8 <__unnamed_1+0x10>
  20a098:	48 89 47 10          	mov    QWORD PTR [rdi+0x10],rax
  20a09c:	c5 f8 10 05 14 f6 ff 	vmovups xmm0,XMMWORD PTR [rip+0xfffffffffffff614]        # 2096b8 <__unnamed_1>
  20a0a3:	ff 
  20a0a4:	c5 f8 11 07          	vmovups XMMWORD PTR [rdi],xmm0
  20a0a8:	48 89 f8             	mov    rax,rdi
  20a0ab:	c3                   	ret    
  20a0ac:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

000000000020a0b0 <ThreadSafeFixedBufferAllocator_realloc>:
        }
    }

    fn realloc(allocator: *Allocator, old_mem: []u8, new_size: usize, alignment: u29) ![]u8 {
  20a0b0:	53                   	push   rbx
  20a0b1:	48 83 ec 30          	sub    rsp,0x30
  20a0b5:	49 89 d1             	mov    r9,rdx
        if (new_size <= old_mem.len) {
  20a0b8:	49 39 49 08          	cmp    QWORD PTR [r9+0x8],rcx
  20a0bc:	0f 83 a9 00 00 00    	jae    20a16b <ThreadSafeFixedBufferAllocator_realloc+0xbb>
        var end_index = @atomicLoad(usize, &self.end_index, builtin.AtomicOrder.SeqCst);
  20a0c2:	4c 8b 56 18          	mov    r10,QWORD PTR [rsi+0x18]
  20a0c6:	48 8b 46 20          	mov    rax,QWORD PTR [rsi+0x20]
            const addr = @ptrToInt(self.buffer.ptr) + end_index;
  20a0ca:	4c 01 d0             	add    rax,r10
            const rem = @rem(addr, alignment);
  20a0cd:	41 81 e0 ff ff ff 1f 	and    r8d,0x1fffffff
  20a0d4:	48 89 c2             	mov    rdx,rax
  20a0d7:	48 c1 ea 20          	shr    rdx,0x20
  20a0db:	75 13                	jne    20a0f0 <ThreadSafeFixedBufferAllocator_realloc+0x40>
  20a0dd:	eb 21                	jmp    20a100 <ThreadSafeFixedBufferAllocator_realloc+0x50>
  20a0df:	90                   	nop
  20a0e0:	48 8b 46 20          	mov    rax,QWORD PTR [rsi+0x20]
            const addr = @ptrToInt(self.buffer.ptr) + end_index;
  20a0e4:	4c 01 d0             	add    rax,r10
  20a0e7:	48 89 c2             	mov    rdx,rax
  20a0ea:	48 c1 ea 20          	shr    rdx,0x20
  20a0ee:	74 10                	je     20a100 <ThreadSafeFixedBufferAllocator_realloc+0x50>
  20a0f0:	31 d2                	xor    edx,edx
  20a0f2:	49 f7 f0             	div    r8
  20a0f5:	eb 0e                	jmp    20a105 <ThreadSafeFixedBufferAllocator_realloc+0x55>
  20a0f7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  20a0fe:	00 00 
  20a100:	31 d2                	xor    edx,edx
  20a102:	41 f7 f0             	div    r8d
            const march_forward_bytes = if (rem == 0) 0 else (alignment - rem);
  20a105:	4d 89 c3             	mov    r11,r8
  20a108:	49 29 d3             	sub    r11,rdx
  20a10b:	48 85 d2             	test   rdx,rdx
  20a10e:	4c 0f 44 da          	cmove  r11,rdx
            const adjusted_index = end_index + march_forward_bytes;
  20a112:	4d 01 d3             	add    r11,r10
            const new_end_index = adjusted_index + n;
  20a115:	49 8d 14 0b          	lea    rdx,[r11+rcx*1]
            if (new_end_index > self.buffer.len) {
  20a119:	48 3b 56 28          	cmp    rdx,QWORD PTR [rsi+0x28]
  20a11d:	77 6d                	ja     20a18c <ThreadSafeFixedBufferAllocator_realloc+0xdc>
            end_index = @cmpxchgWeak(usize, &self.end_index, end_index, new_end_index, builtin.AtomicOrder.SeqCst, builtin.AtomicOrder.SeqCst) orelse return self.buffer[adjusted_index..new_end_index];
  20a11f:	4c 89 d0             	mov    rax,r10
  20a122:	f0 48 0f b1 56 18    	lock cmpxchg QWORD PTR [rsi+0x18],rdx
  20a128:	49 89 c2             	mov    r10,rax
  20a12b:	75 b3                	jne    20a0e0 <ThreadSafeFixedBufferAllocator_realloc+0x30>
pub fn copy(comptime T: type, dest: []T, source: []const T) void {
    // TODO instead of manually doing this check for the whole array
    // and turning off runtime safety, the compiler should detect loops like
    // this and automatically omit safety checks for loops
    @setRuntimeSafety(false);
    assert(dest.len >= source.len);
  20a12d:	4d 8b 51 08          	mov    r10,QWORD PTR [r9+0x8]
  20a131:	49 39 ca             	cmp    r10,rcx
/// In Debug and ReleaseSafe modes, calls to this function are always
/// generated, and the `unreachable` statement triggers a panic.
/// In ReleaseFast and ReleaseSmall modes, calls to this function can be
/// optimized away.
pub fn assert(ok: bool) void {
    if (!ok) {
  20a134:	0f 87 31 01 00 00    	ja     20a26b <ThreadSafeFixedBufferAllocator_realloc+0x1bb>
  20a13a:	48 8b 46 20          	mov    rax,QWORD PTR [rsi+0x20]
  20a13e:	4e 8d 04 18          	lea    r8,[rax+r11*1]
    for (source) |s, i|
  20a142:	4d 85 d2             	test   r10,r10
  20a145:	0f 84 fa 00 00 00    	je     20a245 <ThreadSafeFixedBufferAllocator_realloc+0x195>
  20a14b:	49 8d 72 ff          	lea    rsi,[r10-0x1]
  20a14f:	44 89 d3             	mov    ebx,r10d
  20a152:	83 e3 07             	and    ebx,0x7
  20a155:	48 83 fe 07          	cmp    rsi,0x7
  20a159:	73 53                	jae    20a1ae <ThreadSafeFixedBufferAllocator_realloc+0xfe>
  20a15b:	31 f6                	xor    esi,esi
  20a15d:	48 85 db             	test   rbx,rbx
  20a160:	0f 85 c6 00 00 00    	jne    20a22c <ThreadSafeFixedBufferAllocator_realloc+0x17c>
  20a166:	e9 da 00 00 00       	jmp    20a245 <ThreadSafeFixedBufferAllocator_realloc+0x195>
            return old_mem[0..new_size];
  20a16b:	49 8b 01             	mov    rax,QWORD PTR [r9]
  20a16e:	66 c7 07 00 00       	mov    WORD PTR [rdi],0x0
  20a173:	0f b7 54 24 18       	movzx  edx,WORD PTR [rsp+0x18]
  20a178:	66 89 57 06          	mov    WORD PTR [rdi+0x6],dx
  20a17c:	8b 54 24 14          	mov    edx,DWORD PTR [rsp+0x14]
  20a180:	89 57 02             	mov    DWORD PTR [rdi+0x2],edx
  20a183:	48 89 47 08          	mov    QWORD PTR [rdi+0x8],rax
  20a187:	e9 d2 00 00 00       	jmp    20a25e <ThreadSafeFixedBufferAllocator_realloc+0x1ae>
        } else {
            const result = try alloc(allocator, new_size, alignment);
  20a18c:	66 c7 07 01 00       	mov    WORD PTR [rdi],0x1
  20a191:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
  20a196:	48 89 47 10          	mov    QWORD PTR [rdi+0x10],rax
  20a19a:	c5 f8 10 44 24 1a    	vmovups xmm0,XMMWORD PTR [rsp+0x1a]
  20a1a0:	c5 f8 11 47 02       	vmovups XMMWORD PTR [rdi+0x2],xmm0
  20a1a5:	48 89 f8             	mov    rax,rdi
  20a1a8:	48 83 c4 30          	add    rsp,0x30
  20a1ac:	5b                   	pop    rbx
  20a1ad:	c3                   	ret    
  20a1ae:	49 29 da             	sub    r10,rbx
  20a1b1:	4c 01 d8             	add    rax,r11
  20a1b4:	48 83 c0 07          	add    rax,0x7
  20a1b8:	31 f6                	xor    esi,esi
  20a1ba:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  20a1c0:	49 8b 11             	mov    rdx,QWORD PTR [r9]
  20a1c3:	0f b6 14 32          	movzx  edx,BYTE PTR [rdx+rsi*1]
        dest[i] = s;
  20a1c7:	88 54 30 f9          	mov    BYTE PTR [rax+rsi*1-0x7],dl
    for (source) |s, i|
  20a1cb:	49 8b 11             	mov    rdx,QWORD PTR [r9]
  20a1ce:	0f b6 54 32 01       	movzx  edx,BYTE PTR [rdx+rsi*1+0x1]
        dest[i] = s;
  20a1d3:	88 54 30 fa          	mov    BYTE PTR [rax+rsi*1-0x6],dl
    for (source) |s, i|
  20a1d7:	49 8b 11             	mov    rdx,QWORD PTR [r9]
  20a1da:	0f b6 54 32 02       	movzx  edx,BYTE PTR [rdx+rsi*1+0x2]
        dest[i] = s;
  20a1df:	88 54 30 fb          	mov    BYTE PTR [rax+rsi*1-0x5],dl
    for (source) |s, i|
  20a1e3:	49 8b 11             	mov    rdx,QWORD PTR [r9]
  20a1e6:	0f b6 54 32 03       	movzx  edx,BYTE PTR [rdx+rsi*1+0x3]
        dest[i] = s;
  20a1eb:	88 54 30 fc          	mov    BYTE PTR [rax+rsi*1-0x4],dl
    for (source) |s, i|
  20a1ef:	49 8b 11             	mov    rdx,QWORD PTR [r9]
  20a1f2:	0f b6 54 32 04       	movzx  edx,BYTE PTR [rdx+rsi*1+0x4]
        dest[i] = s;
  20a1f7:	88 54 30 fd          	mov    BYTE PTR [rax+rsi*1-0x3],dl
    for (source) |s, i|
  20a1fb:	49 8b 11             	mov    rdx,QWORD PTR [r9]
  20a1fe:	0f b6 54 32 05       	movzx  edx,BYTE PTR [rdx+rsi*1+0x5]
        dest[i] = s;
  20a203:	88 54 30 fe          	mov    BYTE PTR [rax+rsi*1-0x2],dl
    for (source) |s, i|
  20a207:	49 8b 11             	mov    rdx,QWORD PTR [r9]
  20a20a:	0f b6 54 32 06       	movzx  edx,BYTE PTR [rdx+rsi*1+0x6]
        dest[i] = s;
  20a20f:	88 54 30 ff          	mov    BYTE PTR [rax+rsi*1-0x1],dl
    for (source) |s, i|
  20a213:	49 8b 11             	mov    rdx,QWORD PTR [r9]
  20a216:	0f b6 54 32 07       	movzx  edx,BYTE PTR [rdx+rsi*1+0x7]
        dest[i] = s;
  20a21b:	88 14 30             	mov    BYTE PTR [rax+rsi*1],dl
    for (source) |s, i|
  20a21e:	48 83 c6 08          	add    rsi,0x8
  20a222:	49 39 f2             	cmp    r10,rsi
  20a225:	75 99                	jne    20a1c0 <ThreadSafeFixedBufferAllocator_realloc+0x110>
  20a227:	48 85 db             	test   rbx,rbx
  20a22a:	74 19                	je     20a245 <ThreadSafeFixedBufferAllocator_realloc+0x195>
  20a22c:	48 f7 db             	neg    rbx
  20a22f:	90                   	nop
  20a230:	49 8b 01             	mov    rax,QWORD PTR [r9]
  20a233:	0f b6 04 30          	movzx  eax,BYTE PTR [rax+rsi*1]
        dest[i] = s;
  20a237:	41 88 04 30          	mov    BYTE PTR [r8+rsi*1],al
    for (source) |s, i|
  20a23b:	48 83 c6 01          	add    rsi,0x1
  20a23f:	48 83 c3 01          	add    rbx,0x1
  20a243:	75 eb                	jne    20a230 <ThreadSafeFixedBufferAllocator_realloc+0x180>
            mem.copy(u8, result, old_mem);
            return result;
  20a245:	66 c7 07 00 00       	mov    WORD PTR [rdi],0x0
  20a24a:	0f b7 44 24 12       	movzx  eax,WORD PTR [rsp+0x12]
  20a24f:	66 89 47 06          	mov    WORD PTR [rdi+0x6],ax
  20a253:	8b 44 24 0e          	mov    eax,DWORD PTR [rsp+0xe]
  20a257:	89 47 02             	mov    DWORD PTR [rdi+0x2],eax
  20a25a:	4c 89 47 08          	mov    QWORD PTR [rdi+0x8],r8
  20a25e:	48 89 4f 10          	mov    QWORD PTR [rdi+0x10],rcx
  20a262:	48 89 f8             	mov    rax,rdi
  20a265:	48 83 c4 30          	add    rsp,0x30
  20a269:	5b                   	pop    rbx
  20a26a:	c3                   	ret    
        // In ReleaseFast test mode, we still want assert(false) to crash, so
        // we insert an explicit call to @panic instead of unreachable.
        // TODO we should use `assertOrPanic` in tests and remove this logic.
        if (builtin.is_test) {
            @panic("assertion failure");
  20a26b:	48 8d 3d 1e 5b 04 00 	lea    rdi,[rip+0x45b1e]        # 24fd90 <__unnamed_2>
  20a272:	e8 a9 84 00 00       	call   212720 <panic>
  20a277:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  20a27e:	00 00 

000000000020a280 <assert>:
    if (!ok) {
  20a280:	40 f6 c7 01          	test   dil,0x1
  20a284:	74 01                	je     20a287 <assert+0x7>
pub fn assert(ok: bool) void {
  20a286:	c3                   	ret    
            @panic("assertion failure");
  20a287:	50                   	push   rax
  20a288:	48 8d 3d 01 5b 04 00 	lea    rdi,[rip+0x45b01]        # 24fd90 <__unnamed_2>
  20a28f:	e8 8c 84 00 00       	call   212720 <panic>
  20a294:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20a29b:	00 00 00 00 00 

000000000020a2a0 <init_vdso_clock_gettime>:
const linux = std.os.linux;
const cstr = std.cstr;
const mem = std.mem;

pub fn lookup(vername: []const u8, name: []const u8) usize {
    const vdso_addr = std.os.linux_aux_raw[std.elf.AT_SYSINFO_EHDR];
  20a2a0:	55                   	push   rbp
  20a2a1:	41 57                	push   r15
  20a2a3:	41 56                	push   r14
  20a2a5:	41 55                	push   r13
  20a2a7:	41 54                	push   r12
  20a2a9:	53                   	push   rbx
  20a2aa:	4c 8b 0d 8f 6e 04 00 	mov    r9,QWORD PTR [rip+0x46e8f]        # 251140 <linux_aux_raw+0x108>
    if (vdso_addr == 0) return 0;
  20a2b1:	4d 85 c9             	test   r9,r9
  20a2b4:	0f 84 53 05 00 00    	je     20a80d <init_vdso_clock_gettime+0x56d>

    var maybe_dynv: ?[*]usize = null;
    var base: usize = @maxValue(usize);
    {
        var i: usize = 0;
        while (i < eh.e_phnum) : ({
  20a2ba:	41 0f b7 51 38       	movzx  edx,WORD PTR [r9+0x38]
  20a2bf:	48 85 d2             	test   rdx,rdx
  20a2c2:	0f 84 45 05 00 00    	je     20a80d <init_vdso_clock_gettime+0x56d>
  20a2c8:	49 8b 59 20          	mov    rbx,QWORD PTR [r9+0x20]
    var ph_addr: usize = vdso_addr + eh.e_phoff;
  20a2cc:	4c 01 cb             	add    rbx,r9
  20a2cf:	41 0f b7 49 36       	movzx  ecx,WORD PTR [r9+0x36]
        while (i < eh.e_phnum) : ({
  20a2d4:	48 8d 42 ff          	lea    rax,[rdx-0x1]
  20a2d8:	89 d5                	mov    ebp,edx
  20a2da:	83 e5 03             	and    ebp,0x3
  20a2dd:	48 83 f8 03          	cmp    rax,0x3
  20a2e1:	73 18                	jae    20a2fb <init_vdso_clock_gettime+0x5b>
  20a2e3:	49 c7 c0 ff ff ff ff 	mov    r8,0xffffffffffffffff
  20a2ea:	45 31 f6             	xor    r14d,r14d
            i += 1;
            ph_addr += eh.e_phentsize;
        }) {
            const this_ph = @intToPtr(*elf.Phdr, ph_addr);
            switch (this_ph.p_type) {
  20a2ed:	48 85 ed             	test   rbp,rbp
  20a2f0:	0f 85 ec 00 00 00    	jne    20a3e2 <init_vdso_clock_gettime+0x142>
  20a2f6:	e9 29 01 00 00       	jmp    20a424 <init_vdso_clock_gettime+0x184>
        while (i < eh.e_phnum) : ({
  20a2fb:	48 89 e8             	mov    rax,rbp
  20a2fe:	48 29 d0             	sub    rax,rdx
  20a301:	49 c7 c0 ff ff ff ff 	mov    r8,0xffffffffffffffff
  20a308:	45 31 f6             	xor    r14d,r14d
  20a30b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  20a310:	48 89 da             	mov    rdx,rbx
            switch (this_ph.p_type) {
  20a313:	8b 1a                	mov    ebx,DWORD PTR [rdx]
  20a315:	83 fb 02             	cmp    ebx,0x2
  20a318:	74 66                	je     20a380 <init_vdso_clock_gettime+0xe0>
  20a31a:	83 fb 01             	cmp    ebx,0x1
  20a31d:	75 0b                	jne    20a32a <init_vdso_clock_gettime+0x8a>
  20a31f:	4c 8b 42 08          	mov    r8,QWORD PTR [rdx+0x8]
                elf.PT_LOAD => base = vdso_addr + this_ph.p_offset - this_ph.p_vaddr,
  20a323:	4d 01 c8             	add    r8,r9
  20a326:	4c 2b 42 10          	sub    r8,QWORD PTR [rdx+0x10]
            switch (this_ph.p_type) {
  20a32a:	8b 1c 0a             	mov    ebx,DWORD PTR [rdx+rcx*1]
            ph_addr += eh.e_phentsize;
  20a32d:	48 01 ca             	add    rdx,rcx
            switch (this_ph.p_type) {
  20a330:	83 fb 01             	cmp    ebx,0x1
  20a333:	74 5d                	je     20a392 <init_vdso_clock_gettime+0xf2>
  20a335:	83 fb 02             	cmp    ebx,0x2
  20a338:	75 07                	jne    20a341 <init_vdso_clock_gettime+0xa1>
  20a33a:	4c 8b 72 08          	mov    r14,QWORD PTR [rdx+0x8]
                elf.PT_DYNAMIC => maybe_dynv = @intToPtr([*]usize, vdso_addr + this_ph.p_offset),
  20a33e:	4d 01 ce             	add    r14,r9
            switch (this_ph.p_type) {
  20a341:	8b 1c 11             	mov    ebx,DWORD PTR [rcx+rdx*1]
            ph_addr += eh.e_phentsize;
  20a344:	48 01 ca             	add    rdx,rcx
            switch (this_ph.p_type) {
  20a347:	83 fb 01             	cmp    ebx,0x1
  20a34a:	74 5c                	je     20a3a8 <init_vdso_clock_gettime+0x108>
  20a34c:	83 fb 02             	cmp    ebx,0x2
  20a34f:	75 07                	jne    20a358 <init_vdso_clock_gettime+0xb8>
  20a351:	4c 8b 72 08          	mov    r14,QWORD PTR [rdx+0x8]
                elf.PT_DYNAMIC => maybe_dynv = @intToPtr([*]usize, vdso_addr + this_ph.p_offset),
  20a355:	4d 01 ce             	add    r14,r9
            switch (this_ph.p_type) {
  20a358:	8b 1c 11             	mov    ebx,DWORD PTR [rcx+rdx*1]
            ph_addr += eh.e_phentsize;
  20a35b:	48 01 ca             	add    rdx,rcx
            switch (this_ph.p_type) {
  20a35e:	83 fb 01             	cmp    ebx,0x1
  20a361:	74 5b                	je     20a3be <init_vdso_clock_gettime+0x11e>
  20a363:	83 fb 02             	cmp    ebx,0x2
  20a366:	75 07                	jne    20a36f <init_vdso_clock_gettime+0xcf>
  20a368:	4c 8b 72 08          	mov    r14,QWORD PTR [rdx+0x8]
                elf.PT_DYNAMIC => maybe_dynv = @intToPtr([*]usize, vdso_addr + this_ph.p_offset),
  20a36c:	4d 01 ce             	add    r14,r9
        while (i < eh.e_phnum) : ({
  20a36f:	48 8d 1c 0a          	lea    rbx,[rdx+rcx*1]
  20a373:	48 83 c0 04          	add    rax,0x4
  20a377:	75 97                	jne    20a310 <init_vdso_clock_gettime+0x70>
  20a379:	eb 5c                	jmp    20a3d7 <init_vdso_clock_gettime+0x137>
  20a37b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  20a380:	4c 8b 72 08          	mov    r14,QWORD PTR [rdx+0x8]
                elf.PT_DYNAMIC => maybe_dynv = @intToPtr([*]usize, vdso_addr + this_ph.p_offset),
  20a384:	4d 01 ce             	add    r14,r9
            switch (this_ph.p_type) {
  20a387:	8b 1c 0a             	mov    ebx,DWORD PTR [rdx+rcx*1]
            ph_addr += eh.e_phentsize;
  20a38a:	48 01 ca             	add    rdx,rcx
            switch (this_ph.p_type) {
  20a38d:	83 fb 01             	cmp    ebx,0x1
  20a390:	75 a3                	jne    20a335 <init_vdso_clock_gettime+0x95>
  20a392:	4c 8b 42 08          	mov    r8,QWORD PTR [rdx+0x8]
                elf.PT_LOAD => base = vdso_addr + this_ph.p_offset - this_ph.p_vaddr,
  20a396:	4d 01 c8             	add    r8,r9
  20a399:	4c 2b 42 10          	sub    r8,QWORD PTR [rdx+0x10]
            switch (this_ph.p_type) {
  20a39d:	8b 1c 11             	mov    ebx,DWORD PTR [rcx+rdx*1]
            ph_addr += eh.e_phentsize;
  20a3a0:	48 01 ca             	add    rdx,rcx
            switch (this_ph.p_type) {
  20a3a3:	83 fb 01             	cmp    ebx,0x1
  20a3a6:	75 a4                	jne    20a34c <init_vdso_clock_gettime+0xac>
  20a3a8:	4c 8b 42 08          	mov    r8,QWORD PTR [rdx+0x8]
                elf.PT_LOAD => base = vdso_addr + this_ph.p_offset - this_ph.p_vaddr,
  20a3ac:	4d 01 c8             	add    r8,r9
  20a3af:	4c 2b 42 10          	sub    r8,QWORD PTR [rdx+0x10]
            switch (this_ph.p_type) {
  20a3b3:	8b 1c 11             	mov    ebx,DWORD PTR [rcx+rdx*1]
            ph_addr += eh.e_phentsize;
  20a3b6:	48 01 ca             	add    rdx,rcx
            switch (this_ph.p_type) {
  20a3b9:	83 fb 01             	cmp    ebx,0x1
  20a3bc:	75 a5                	jne    20a363 <init_vdso_clock_gettime+0xc3>
  20a3be:	4c 8b 42 08          	mov    r8,QWORD PTR [rdx+0x8]
                elf.PT_LOAD => base = vdso_addr + this_ph.p_offset - this_ph.p_vaddr,
  20a3c2:	4d 01 c8             	add    r8,r9
  20a3c5:	4c 2b 42 10          	sub    r8,QWORD PTR [rdx+0x10]
        while (i < eh.e_phnum) : ({
  20a3c9:	48 8d 1c 0a          	lea    rbx,[rdx+rcx*1]
  20a3cd:	48 83 c0 04          	add    rax,0x4
  20a3d1:	0f 85 39 ff ff ff    	jne    20a310 <init_vdso_clock_gettime+0x70>
  20a3d7:	48 01 ca             	add    rdx,rcx
  20a3da:	48 89 d3             	mov    rbx,rdx
            switch (this_ph.p_type) {
  20a3dd:	48 85 ed             	test   rbp,rbp
  20a3e0:	74 42                	je     20a424 <init_vdso_clock_gettime+0x184>
  20a3e2:	48 f7 dd             	neg    rbp
  20a3e5:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20a3ec:	00 00 00 00 
  20a3f0:	8b 03                	mov    eax,DWORD PTR [rbx]
  20a3f2:	83 f8 01             	cmp    eax,0x1
  20a3f5:	74 19                	je     20a410 <init_vdso_clock_gettime+0x170>
  20a3f7:	83 f8 02             	cmp    eax,0x2
  20a3fa:	75 07                	jne    20a403 <init_vdso_clock_gettime+0x163>
  20a3fc:	4c 8b 73 08          	mov    r14,QWORD PTR [rbx+0x8]
                elf.PT_DYNAMIC => maybe_dynv = @intToPtr([*]usize, vdso_addr + this_ph.p_offset),
  20a400:	4d 01 ce             	add    r14,r9
            ph_addr += eh.e_phentsize;
  20a403:	48 01 cb             	add    rbx,rcx
        while (i < eh.e_phnum) : ({
  20a406:	48 83 c5 01          	add    rbp,0x1
  20a40a:	75 e4                	jne    20a3f0 <init_vdso_clock_gettime+0x150>
  20a40c:	eb 16                	jmp    20a424 <init_vdso_clock_gettime+0x184>
  20a40e:	66 90                	xchg   ax,ax
  20a410:	4c 8b 43 08          	mov    r8,QWORD PTR [rbx+0x8]
                elf.PT_LOAD => base = vdso_addr + this_ph.p_offset - this_ph.p_vaddr,
  20a414:	4d 01 c8             	add    r8,r9
  20a417:	4c 2b 43 10          	sub    r8,QWORD PTR [rbx+0x10]
            ph_addr += eh.e_phentsize;
  20a41b:	48 01 cb             	add    rbx,rcx
        while (i < eh.e_phnum) : ({
  20a41e:	48 83 c5 01          	add    rbp,0x1
  20a422:	75 cc                	jne    20a3f0 <init_vdso_clock_gettime+0x150>
                else => {},
            }
        }
    }
    const dynv = maybe_dynv orelse return 0;
    if (base == @maxValue(usize)) return 0;
  20a424:	49 83 f8 ff          	cmp    r8,0xffffffffffffffff
    const dynv = maybe_dynv orelse return 0;
  20a428:	0f 84 df 03 00 00    	je     20a80d <init_vdso_clock_gettime+0x56d>
  20a42e:	4d 85 f6             	test   r14,r14
  20a431:	0f 84 d6 03 00 00    	je     20a80d <init_vdso_clock_gettime+0x56d>
    var maybe_versym: ?[*]u16 = null;
    var maybe_verdef: ?*elf.Verdef = null;

    {
        var i: usize = 0;
        while (dynv[i] != 0) : (i += 2) {
  20a437:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  20a43a:	48 85 d2             	test   rdx,rdx
  20a43d:	0f 84 ca 03 00 00    	je     20a80d <init_vdso_clock_gettime+0x56d>
            const p = base + dynv[i + 1];
  20a443:	49 83 c6 10          	add    r14,0x10
  20a447:	45 31 ff             	xor    r15d,r15d
  20a44a:	45 31 db             	xor    r11d,r11d
  20a44d:	45 31 d2             	xor    r10d,r10d
  20a450:	31 ed                	xor    ebp,ebp
  20a452:	45 31 ed             	xor    r13d,r13d
  20a455:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20a45c:	00 00 00 00 
  20a460:	49 8b 4e f8          	mov    rcx,QWORD PTR [r14-0x8]
  20a464:	4c 01 c1             	add    rcx,r8
            switch (dynv[i]) {
  20a467:	48 83 fa 05          	cmp    rdx,0x5
  20a46b:	7e 33                	jle    20a4a0 <init_vdso_clock_gettime+0x200>
  20a46d:	48 83 fa 06          	cmp    rdx,0x6
  20a471:	74 4b                	je     20a4be <init_vdso_clock_gettime+0x21e>
  20a473:	48 81 fa f0 ff ff 6f 	cmp    rdx,0x6ffffff0
  20a47a:	74 53                	je     20a4cf <init_vdso_clock_gettime+0x22f>
  20a47c:	48 81 fa fc ff ff 6f 	cmp    rdx,0x6ffffffc
  20a483:	75 2b                	jne    20a4b0 <init_vdso_clock_gettime+0x210>
  20a485:	49 89 cb             	mov    r11,rcx
        while (dynv[i] != 0) : (i += 2) {
  20a488:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  20a48b:	49 83 c6 10          	add    r14,0x10
  20a48f:	48 85 d2             	test   rdx,rdx
  20a492:	75 cc                	jne    20a460 <init_vdso_clock_gettime+0x1c0>
  20a494:	eb 5d                	jmp    20a4f3 <init_vdso_clock_gettime+0x253>
  20a496:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  20a49d:	00 00 00 
            switch (dynv[i]) {
  20a4a0:	48 83 fa 04          	cmp    rdx,0x4
  20a4a4:	74 3a                	je     20a4e0 <init_vdso_clock_gettime+0x240>
  20a4a6:	48 83 fa 05          	cmp    rdx,0x5
  20a4aa:	75 04                	jne    20a4b0 <init_vdso_clock_gettime+0x210>
  20a4ac:	49 89 cf             	mov    r15,rcx
  20a4af:	90                   	nop
        while (dynv[i] != 0) : (i += 2) {
  20a4b0:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  20a4b3:	49 83 c6 10          	add    r14,0x10
  20a4b7:	48 85 d2             	test   rdx,rdx
  20a4ba:	75 a4                	jne    20a460 <init_vdso_clock_gettime+0x1c0>
  20a4bc:	eb 35                	jmp    20a4f3 <init_vdso_clock_gettime+0x253>
  20a4be:	49 89 cd             	mov    r13,rcx
  20a4c1:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  20a4c4:	49 83 c6 10          	add    r14,0x10
  20a4c8:	48 85 d2             	test   rdx,rdx
  20a4cb:	75 93                	jne    20a460 <init_vdso_clock_gettime+0x1c0>
  20a4cd:	eb 24                	jmp    20a4f3 <init_vdso_clock_gettime+0x253>
  20a4cf:	49 89 ca             	mov    r10,rcx
  20a4d2:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  20a4d5:	49 83 c6 10          	add    r14,0x10
  20a4d9:	48 85 d2             	test   rdx,rdx
  20a4dc:	75 82                	jne    20a460 <init_vdso_clock_gettime+0x1c0>
  20a4de:	eb 13                	jmp    20a4f3 <init_vdso_clock_gettime+0x253>
  20a4e0:	48 89 cd             	mov    rbp,rcx
  20a4e3:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  20a4e6:	49 83 c6 10          	add    r14,0x10
  20a4ea:	48 85 d2             	test   rdx,rdx
  20a4ed:	0f 85 6d ff ff ff    	jne    20a460 <init_vdso_clock_gettime+0x1c0>
        }
    }

    const strings = maybe_strings orelse return 0;
    const syms = maybe_syms orelse return 0;
    const hashtab = maybe_hashtab orelse return 0;
  20a4f3:	48 85 ed             	test   rbp,rbp
    const strings = maybe_strings orelse return 0;
  20a4f6:	0f 84 11 03 00 00    	je     20a80d <init_vdso_clock_gettime+0x56d>
  20a4fc:	4d 85 ed             	test   r13,r13
  20a4ff:	0f 84 08 03 00 00    	je     20a80d <init_vdso_clock_gettime+0x56d>
  20a505:	4d 85 ff             	test   r15,r15
  20a508:	0f 84 ff 02 00 00    	je     20a80d <init_vdso_clock_gettime+0x56d>
    if (maybe_verdef == null) maybe_versym = null;
  20a50e:	4d 85 db             	test   r11,r11
  20a511:	4d 0f 44 d3          	cmove  r10,r11

    const OK_TYPES = (1 << elf.STT_NOTYPE | 1 << elf.STT_OBJECT | 1 << elf.STT_FUNC | 1 << elf.STT_COMMON);
    const OK_BINDS = (1 << elf.STB_GLOBAL | 1 << elf.STB_WEAK | 1 << elf.STB_GNU_UNIQUE);

    var i: usize = 0;
    while (i < hashtab[1]) : (i += 1) {
  20a515:	44 8b 4d 04          	mov    r9d,DWORD PTR [rbp+0x4]
  20a519:	4d 85 c9             	test   r9,r9
  20a51c:	0f 84 eb 02 00 00    	je     20a80d <init_vdso_clock_gettime+0x56d>
  20a522:	31 d2                	xor    edx,edx
  20a524:	4d 85 d2             	test   r10,r10
  20a527:	0f 84 e5 01 00 00    	je     20a712 <init_vdso_clock_gettime+0x472>
  20a52d:	41 bc 27 00 00 00    	mov    r12d,0x27
  20a533:	41 be 06 04 00 00    	mov    r14d,0x406
  20a539:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
        if (0 == (u32(1) << @intCast(u5, syms[i].st_info & 0xf) & OK_TYPES)) continue;
  20a540:	48 8d 0c 52          	lea    rcx,[rdx+rdx*2]
  20a544:	41 8a 5c cd 04       	mov    bl,BYTE PTR [r13+rcx*8+0x4]
  20a549:	89 d8                	mov    eax,ebx
  20a54b:	24 0f                	and    al,0xf
  20a54d:	0f b6 c0             	movzx  eax,al
  20a550:	41 0f a3 c4          	bt     r12d,eax
  20a554:	0f 83 a6 01 00 00    	jae    20a700 <init_vdso_clock_gettime+0x460>
        if (0 == (u32(1) << @intCast(u5, syms[i].st_info >> 4) & OK_BINDS)) continue;
  20a55a:	c0 eb 04             	shr    bl,0x4
  20a55d:	0f b6 c3             	movzx  eax,bl
  20a560:	41 0f a3 c6          	bt     r14d,eax
  20a564:	0f 83 96 01 00 00    	jae    20a700 <init_vdso_clock_gettime+0x460>
        if (0 == syms[i].st_shndx) continue;
  20a56a:	66 41 83 7c cd 06 00 	cmp    WORD PTR [r13+rcx*8+0x6],0x0
  20a571:	0f 84 89 01 00 00    	je     20a700 <init_vdso_clock_gettime+0x460>
        if (!mem.eql(u8, name, cstr.toSliceConst(strings + syms[i].st_name))) continue;
  20a577:	41 8b 6c cd 00       	mov    ebp,DWORD PTR [r13+rcx*8+0x0]
  20a57c:	4c 01 fd             	add    rbp,r15
  20a57f:	48 c7 c1 eb ff ff ff 	mov    rcx,0xffffffffffffffeb
  20a586:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  20a58d:	00 00 00 
    return true;
}

pub fn len(comptime T: type, ptr: [*]const T) usize {
    var count: usize = 0;
    while (ptr[count] != 0) : (count += 1) {}
  20a590:	80 7c 0d 15 00       	cmp    BYTE PTR [rbp+rcx*1+0x15],0x0
  20a595:	48 8d 49 01          	lea    rcx,[rcx+0x1]
  20a599:	75 f5                	jne    20a590 <init_vdso_clock_gettime+0x2f0>
    if (a.len != b.len) return false;
  20a59b:	48 85 c9             	test   rcx,rcx
  20a59e:	0f 85 5c 01 00 00    	jne    20a700 <init_vdso_clock_gettime+0x460>
        if (b[index] != item) return false;
  20a5a4:	80 7d 00 5f          	cmp    BYTE PTR [rbp+0x0],0x5f
  20a5a8:	0f 85 52 01 00 00    	jne    20a700 <init_vdso_clock_gettime+0x460>
  20a5ae:	80 7d 01 5f          	cmp    BYTE PTR [rbp+0x1],0x5f
  20a5b2:	0f 85 48 01 00 00    	jne    20a700 <init_vdso_clock_gettime+0x460>
  20a5b8:	80 7d 02 76          	cmp    BYTE PTR [rbp+0x2],0x76
  20a5bc:	0f 85 3e 01 00 00    	jne    20a700 <init_vdso_clock_gettime+0x460>
  20a5c2:	80 7d 03 64          	cmp    BYTE PTR [rbp+0x3],0x64
  20a5c6:	0f 85 34 01 00 00    	jne    20a700 <init_vdso_clock_gettime+0x460>
  20a5cc:	80 7d 04 73          	cmp    BYTE PTR [rbp+0x4],0x73
  20a5d0:	0f 85 2a 01 00 00    	jne    20a700 <init_vdso_clock_gettime+0x460>
  20a5d6:	80 7d 05 6f          	cmp    BYTE PTR [rbp+0x5],0x6f
  20a5da:	0f 85 20 01 00 00    	jne    20a700 <init_vdso_clock_gettime+0x460>
  20a5e0:	80 7d 06 5f          	cmp    BYTE PTR [rbp+0x6],0x5f
  20a5e4:	0f 85 16 01 00 00    	jne    20a700 <init_vdso_clock_gettime+0x460>
  20a5ea:	80 7d 07 63          	cmp    BYTE PTR [rbp+0x7],0x63
  20a5ee:	0f 85 0c 01 00 00    	jne    20a700 <init_vdso_clock_gettime+0x460>
  20a5f4:	80 7d 08 6c          	cmp    BYTE PTR [rbp+0x8],0x6c
  20a5f8:	0f 85 02 01 00 00    	jne    20a700 <init_vdso_clock_gettime+0x460>
  20a5fe:	80 7d 09 6f          	cmp    BYTE PTR [rbp+0x9],0x6f
  20a602:	0f 85 f8 00 00 00    	jne    20a700 <init_vdso_clock_gettime+0x460>
  20a608:	80 7d 0a 63          	cmp    BYTE PTR [rbp+0xa],0x63
  20a60c:	0f 85 ee 00 00 00    	jne    20a700 <init_vdso_clock_gettime+0x460>
  20a612:	80 7d 0b 6b          	cmp    BYTE PTR [rbp+0xb],0x6b
  20a616:	0f 85 e4 00 00 00    	jne    20a700 <init_vdso_clock_gettime+0x460>
  20a61c:	80 7d 0c 5f          	cmp    BYTE PTR [rbp+0xc],0x5f
  20a620:	0f 85 da 00 00 00    	jne    20a700 <init_vdso_clock_gettime+0x460>
  20a626:	80 7d 0d 67          	cmp    BYTE PTR [rbp+0xd],0x67
  20a62a:	0f 85 d0 00 00 00    	jne    20a700 <init_vdso_clock_gettime+0x460>
  20a630:	80 7d 0e 65          	cmp    BYTE PTR [rbp+0xe],0x65
  20a634:	0f 85 c6 00 00 00    	jne    20a700 <init_vdso_clock_gettime+0x460>
  20a63a:	80 7d 0f 74          	cmp    BYTE PTR [rbp+0xf],0x74
  20a63e:	0f 85 bc 00 00 00    	jne    20a700 <init_vdso_clock_gettime+0x460>
  20a644:	80 7d 10 74          	cmp    BYTE PTR [rbp+0x10],0x74
  20a648:	0f 85 b2 00 00 00    	jne    20a700 <init_vdso_clock_gettime+0x460>
  20a64e:	80 7d 11 69          	cmp    BYTE PTR [rbp+0x11],0x69
  20a652:	0f 85 a8 00 00 00    	jne    20a700 <init_vdso_clock_gettime+0x460>
  20a658:	80 7d 12 6d          	cmp    BYTE PTR [rbp+0x12],0x6d
  20a65c:	0f 85 9e 00 00 00    	jne    20a700 <init_vdso_clock_gettime+0x460>
  20a662:	80 7d 13 65          	cmp    BYTE PTR [rbp+0x13],0x65
  20a666:	0f 85 94 00 00 00    	jne    20a700 <init_vdso_clock_gettime+0x460>
        if (maybe_versym) |versym| {
            if (!checkver(maybe_verdef.?, versym[i], vername, strings))
  20a66c:	41 0f b7 2c 52       	movzx  ebp,WORD PTR [r10+rdx*2]
  20a671:	4c 89 d9             	mov    rcx,r11

fn checkver(def_arg: *elf.Verdef, vsym_arg: i32, vername: []const u8, strings: [*]u8) bool {
    var def = def_arg;
    const vsym = @bitCast(u32, vsym_arg) & 0x7fff;
    while (true) {
        if (0 == (def.vd_flags & elf.VER_FLG_BASE) and (def.vd_ndx & 0x7fff) == vsym)
  20a674:	f6 41 02 01          	test   BYTE PTR [rcx+0x2],0x1
  20a678:	75 1c                	jne    20a696 <init_vdso_clock_gettime+0x3f6>
  20a67a:	eb 09                	jmp    20a685 <init_vdso_clock_gettime+0x3e5>
            break;
        if (def.vd_next == 0)
            return false;
        def = @intToPtr(*elf.Verdef, @ptrToInt(def) + def.vd_next);
  20a67c:	48 01 d9             	add    rcx,rbx
        if (0 == (def.vd_flags & elf.VER_FLG_BASE) and (def.vd_ndx & 0x7fff) == vsym)
  20a67f:	f6 41 02 01          	test   BYTE PTR [rcx+0x2],0x1
  20a683:	75 11                	jne    20a696 <init_vdso_clock_gettime+0x3f6>
  20a685:	0f b7 41 04          	movzx  eax,WORD PTR [rcx+0x4]
  20a689:	66 31 e8             	xor    ax,bp
  20a68c:	25 ff 7f 00 00       	and    eax,0x7fff
  20a691:	66 85 c0             	test   ax,ax
  20a694:	74 0a                	je     20a6a0 <init_vdso_clock_gettime+0x400>
        if (def.vd_next == 0)
  20a696:	8b 59 10             	mov    ebx,DWORD PTR [rcx+0x10]
  20a699:	48 85 db             	test   rbx,rbx
  20a69c:	75 de                	jne    20a67c <init_vdso_clock_gettime+0x3dc>
  20a69e:	eb 60                	jmp    20a700 <init_vdso_clock_gettime+0x460>
    }
    const aux = @intToPtr(*elf.Verdaux, @ptrToInt(def) + def.vd_aux);
  20a6a0:	8b 41 0c             	mov    eax,DWORD PTR [rcx+0xc]
    return mem.eql(u8, vername, cstr.toSliceConst(strings + aux.vda_name));
  20a6a3:	8b 2c 08             	mov    ebp,DWORD PTR [rax+rcx*1]
  20a6a6:	4c 01 fd             	add    rbp,r15
  20a6a9:	48 c7 c1 f6 ff ff ff 	mov    rcx,0xfffffffffffffff6
    while (ptr[count] != 0) : (count += 1) {}
  20a6b0:	80 7c 0d 0a 00       	cmp    BYTE PTR [rbp+rcx*1+0xa],0x0
  20a6b5:	48 8d 49 01          	lea    rcx,[rcx+0x1]
  20a6b9:	75 f5                	jne    20a6b0 <init_vdso_clock_gettime+0x410>
    if (a.len != b.len) return false;
  20a6bb:	48 85 c9             	test   rcx,rcx
  20a6be:	75 40                	jne    20a700 <init_vdso_clock_gettime+0x460>
        if (b[index] != item) return false;
  20a6c0:	80 7d 00 4c          	cmp    BYTE PTR [rbp+0x0],0x4c
  20a6c4:	75 3a                	jne    20a700 <init_vdso_clock_gettime+0x460>
  20a6c6:	80 7d 01 49          	cmp    BYTE PTR [rbp+0x1],0x49
  20a6ca:	75 34                	jne    20a700 <init_vdso_clock_gettime+0x460>
  20a6cc:	80 7d 02 4e          	cmp    BYTE PTR [rbp+0x2],0x4e
  20a6d0:	75 2e                	jne    20a700 <init_vdso_clock_gettime+0x460>
  20a6d2:	80 7d 03 55          	cmp    BYTE PTR [rbp+0x3],0x55
  20a6d6:	75 28                	jne    20a700 <init_vdso_clock_gettime+0x460>
  20a6d8:	80 7d 04 58          	cmp    BYTE PTR [rbp+0x4],0x58
  20a6dc:	75 22                	jne    20a700 <init_vdso_clock_gettime+0x460>
  20a6de:	80 7d 05 5f          	cmp    BYTE PTR [rbp+0x5],0x5f
  20a6e2:	75 1c                	jne    20a700 <init_vdso_clock_gettime+0x460>
  20a6e4:	80 7d 06 32          	cmp    BYTE PTR [rbp+0x6],0x32
  20a6e8:	75 16                	jne    20a700 <init_vdso_clock_gettime+0x460>
  20a6ea:	80 7d 07 2e          	cmp    BYTE PTR [rbp+0x7],0x2e
  20a6ee:	75 10                	jne    20a700 <init_vdso_clock_gettime+0x460>
  20a6f0:	80 7d 08 36          	cmp    BYTE PTR [rbp+0x8],0x36
            if (!checkver(maybe_verdef.?, versym[i], vername, strings))
  20a6f4:	0f 84 37 01 00 00    	je     20a831 <init_vdso_clock_gettime+0x591>
  20a6fa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
    while (i < hashtab[1]) : (i += 1) {
  20a700:	48 83 c2 01          	add    rdx,0x1
  20a704:	4c 39 ca             	cmp    rdx,r9
  20a707:	0f 82 33 fe ff ff    	jb     20a540 <init_vdso_clock_gettime+0x2a0>
  20a70d:	e9 fb 00 00 00       	jmp    20a80d <init_vdso_clock_gettime+0x56d>
  20a712:	bd 27 00 00 00       	mov    ebp,0x27
  20a717:	41 ba 06 04 00 00    	mov    r10d,0x406
  20a71d:	0f 1f 00             	nop    DWORD PTR [rax]
        if (0 == (u32(1) << @intCast(u5, syms[i].st_info & 0xf) & OK_TYPES)) continue;
  20a720:	48 8d 0c 52          	lea    rcx,[rdx+rdx*2]
  20a724:	41 8a 44 cd 04       	mov    al,BYTE PTR [r13+rcx*8+0x4]
  20a729:	89 c3                	mov    ebx,eax
  20a72b:	80 e3 0f             	and    bl,0xf
  20a72e:	0f b6 db             	movzx  ebx,bl
  20a731:	0f a3 dd             	bt     ebp,ebx
  20a734:	0f 83 c6 00 00 00    	jae    20a800 <init_vdso_clock_gettime+0x560>
        if (0 == (u32(1) << @intCast(u5, syms[i].st_info >> 4) & OK_BINDS)) continue;
  20a73a:	c0 e8 04             	shr    al,0x4
  20a73d:	0f b6 c0             	movzx  eax,al
  20a740:	41 0f a3 c2          	bt     r10d,eax
  20a744:	0f 83 b6 00 00 00    	jae    20a800 <init_vdso_clock_gettime+0x560>
        if (0 == syms[i].st_shndx) continue;
  20a74a:	66 41 83 7c cd 06 00 	cmp    WORD PTR [r13+rcx*8+0x6],0x0
  20a751:	0f 84 a9 00 00 00    	je     20a800 <init_vdso_clock_gettime+0x560>
        if (!mem.eql(u8, name, cstr.toSliceConst(strings + syms[i].st_name))) continue;
  20a757:	41 8b 5c cd 00       	mov    ebx,DWORD PTR [r13+rcx*8+0x0]
  20a75c:	4c 01 fb             	add    rbx,r15
  20a75f:	48 c7 c1 eb ff ff ff 	mov    rcx,0xffffffffffffffeb
  20a766:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  20a76d:	00 00 00 
    while (ptr[count] != 0) : (count += 1) {}
  20a770:	80 7c 0b 15 00       	cmp    BYTE PTR [rbx+rcx*1+0x15],0x0
  20a775:	48 8d 49 01          	lea    rcx,[rcx+0x1]
  20a779:	75 f5                	jne    20a770 <init_vdso_clock_gettime+0x4d0>
    if (a.len != b.len) return false;
  20a77b:	48 85 c9             	test   rcx,rcx
  20a77e:	0f 85 7c 00 00 00    	jne    20a800 <init_vdso_clock_gettime+0x560>
        if (b[index] != item) return false;
  20a784:	80 3b 5f             	cmp    BYTE PTR [rbx],0x5f
  20a787:	75 77                	jne    20a800 <init_vdso_clock_gettime+0x560>
  20a789:	80 7b 01 5f          	cmp    BYTE PTR [rbx+0x1],0x5f
  20a78d:	75 71                	jne    20a800 <init_vdso_clock_gettime+0x560>
  20a78f:	80 7b 02 76          	cmp    BYTE PTR [rbx+0x2],0x76
  20a793:	75 6b                	jne    20a800 <init_vdso_clock_gettime+0x560>
  20a795:	80 7b 03 64          	cmp    BYTE PTR [rbx+0x3],0x64
  20a799:	75 65                	jne    20a800 <init_vdso_clock_gettime+0x560>
  20a79b:	80 7b 04 73          	cmp    BYTE PTR [rbx+0x4],0x73
  20a79f:	75 5f                	jne    20a800 <init_vdso_clock_gettime+0x560>
  20a7a1:	80 7b 05 6f          	cmp    BYTE PTR [rbx+0x5],0x6f
  20a7a5:	75 59                	jne    20a800 <init_vdso_clock_gettime+0x560>
  20a7a7:	80 7b 06 5f          	cmp    BYTE PTR [rbx+0x6],0x5f
  20a7ab:	75 53                	jne    20a800 <init_vdso_clock_gettime+0x560>
  20a7ad:	80 7b 07 63          	cmp    BYTE PTR [rbx+0x7],0x63
  20a7b1:	75 4d                	jne    20a800 <init_vdso_clock_gettime+0x560>
  20a7b3:	80 7b 08 6c          	cmp    BYTE PTR [rbx+0x8],0x6c
  20a7b7:	75 47                	jne    20a800 <init_vdso_clock_gettime+0x560>
  20a7b9:	80 7b 09 6f          	cmp    BYTE PTR [rbx+0x9],0x6f
  20a7bd:	75 41                	jne    20a800 <init_vdso_clock_gettime+0x560>
  20a7bf:	80 7b 0a 63          	cmp    BYTE PTR [rbx+0xa],0x63
  20a7c3:	75 3b                	jne    20a800 <init_vdso_clock_gettime+0x560>
  20a7c5:	80 7b 0b 6b          	cmp    BYTE PTR [rbx+0xb],0x6b
  20a7c9:	75 35                	jne    20a800 <init_vdso_clock_gettime+0x560>
  20a7cb:	80 7b 0c 5f          	cmp    BYTE PTR [rbx+0xc],0x5f
  20a7cf:	75 2f                	jne    20a800 <init_vdso_clock_gettime+0x560>
  20a7d1:	80 7b 0d 67          	cmp    BYTE PTR [rbx+0xd],0x67
  20a7d5:	75 29                	jne    20a800 <init_vdso_clock_gettime+0x560>
  20a7d7:	80 7b 0e 65          	cmp    BYTE PTR [rbx+0xe],0x65
  20a7db:	75 23                	jne    20a800 <init_vdso_clock_gettime+0x560>
  20a7dd:	80 7b 0f 74          	cmp    BYTE PTR [rbx+0xf],0x74
  20a7e1:	75 1d                	jne    20a800 <init_vdso_clock_gettime+0x560>
  20a7e3:	80 7b 10 74          	cmp    BYTE PTR [rbx+0x10],0x74
  20a7e7:	75 17                	jne    20a800 <init_vdso_clock_gettime+0x560>
  20a7e9:	80 7b 11 69          	cmp    BYTE PTR [rbx+0x11],0x69
  20a7ed:	75 11                	jne    20a800 <init_vdso_clock_gettime+0x560>
  20a7ef:	80 7b 12 6d          	cmp    BYTE PTR [rbx+0x12],0x6d
  20a7f3:	75 0b                	jne    20a800 <init_vdso_clock_gettime+0x560>
  20a7f5:	80 7b 13 65          	cmp    BYTE PTR [rbx+0x13],0x65
  20a7f9:	74 36                	je     20a831 <init_vdso_clock_gettime+0x591>
  20a7fb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
    while (i < hashtab[1]) : (i += 1) {
  20a800:	48 83 c2 01          	add    rdx,0x1
  20a804:	4c 39 ca             	cmp    rdx,r9
  20a807:	0f 82 13 ff ff ff    	jb     20a720 <init_vdso_clock_gettime+0x480>
}
var vdso_clock_gettime = init_vdso_clock_gettime;
extern fn init_vdso_clock_gettime(clk: i32, ts: *timespec) usize {
    const addr = vdso.lookup(VDSO_CGT_VER, VDSO_CGT_SYM);
    var f = @intToPtr(@typeOf(init_vdso_clock_gettime), addr);
    _ = @cmpxchgStrong(@typeOf(init_vdso_clock_gettime), &vdso_clock_gettime, init_vdso_clock_gettime, f, builtin.AtomicOrder.Monotonic, builtin.AtomicOrder.Monotonic);
  20a80d:	48 8d 05 8c fa ff ff 	lea    rax,[rip+0xfffffffffffffa8c]        # 20a2a0 <init_vdso_clock_gettime>
  20a814:	31 c9                	xor    ecx,ecx
  20a816:	f0 48 0f b1 0d f9 18 	lock cmpxchg QWORD PTR [rip+0x418f9],rcx        # 24c118 <vdso_clock_gettime>
  20a81d:	04 00 
    if (@ptrToInt(f) == 0) return @bitCast(usize, isize(-ENOSYS));
  20a81f:	48 c7 c0 da ff ff ff 	mov    rax,0xffffffffffffffda
  20a826:	5b                   	pop    rbx
  20a827:	41 5c                	pop    r12
  20a829:	41 5d                	pop    r13
  20a82b:	41 5e                	pop    r14
  20a82d:	41 5f                	pop    r15
  20a82f:	5d                   	pop    rbp
  20a830:	c3                   	ret    
        return base + syms[i].st_value;
  20a831:	48 8d 04 52          	lea    rax,[rdx+rdx*2]
  20a835:	4d 03 44 c5 08       	add    r8,QWORD PTR [r13+rax*8+0x8]
    _ = @cmpxchgStrong(@typeOf(init_vdso_clock_gettime), &vdso_clock_gettime, init_vdso_clock_gettime, f, builtin.AtomicOrder.Monotonic, builtin.AtomicOrder.Monotonic);
  20a83a:	48 8d 05 5f fa ff ff 	lea    rax,[rip+0xfffffffffffffa5f]        # 20a2a0 <init_vdso_clock_gettime>
  20a841:	f0 4c 0f b1 05 ce 18 	lock cmpxchg QWORD PTR [rip+0x418ce],r8        # 24c118 <vdso_clock_gettime>
  20a848:	04 00 
    if (@ptrToInt(f) == 0) return @bitCast(usize, isize(-ENOSYS));
  20a84a:	4d 85 c0             	test   r8,r8
  20a84d:	74 d0                	je     20a81f <init_vdso_clock_gettime+0x57f>
    return f(clk, ts);
  20a84f:	5b                   	pop    rbx
  20a850:	41 5c                	pop    r12
  20a852:	41 5d                	pop    r13
  20a854:	41 5e                	pop    r14
  20a856:	41 5f                	pop    r15
  20a858:	5d                   	pop    rbp
  20a859:	41 ff e0             	jmp    r8
  20a85c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

000000000020a860 <BmSimple.cfence>:
        }
        return std_dev;
    }
};

test "BmSimple.cfence" {
  20a860:	55                   	push   rbp
  20a861:	41 57                	push   r15
  20a863:	41 56                	push   r14
  20a865:	41 55                	push   r13
  20a867:	41 54                	push   r12
  20a869:	53                   	push   rbx
  20a86a:	48 81 ec f8 00 00 00 	sub    rsp,0xf8
  20a871:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20a878:	0f 1f 84 00 00 00 00 
  20a87f:	00 
    pub fn init() Mutex {
        return Mutex{ .lock = 0 };
    }

    pub fn acquire(self: *Mutex) Held {
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20a880:	b0 01                	mov    al,0x1
  20a882:	86 05 88 67 04 00    	xchg   BYTE PTR [rip+0x46788],al        # 251010 <stderr_mutex>
  20a888:	84 c0                	test   al,al
  20a88a:	75 f4                	jne    20a880 <BmSimple.cfence+0x20>
    if (stderr_stream) |st| {
  20a88c:	48 8b 3d 75 67 04 00 	mov    rdi,QWORD PTR [rip+0x46775]        # 251008 <stderr_stream>
  20a893:	48 85 ff             	test   rdi,rdi
  20a896:	74 09                	je     20a8a1 <BmSimple.cfence+0x41>
        pub const Error = WriteError;

        writeFn: fn (self: *Self, bytes: []const u8) Error!void,

        pub fn print(self: *Self, comptime format: []const u8, args: ...) !void {
            return std.fmt.format(self, Error, self.writeFn, format, args);
  20a898:	48 8b 05 a1 17 04 00 	mov    rax,QWORD PTR [rip+0x417a1]        # 24c040 <stderr_file_out_stream+0x8>
  20a89f:	eb 34                	jmp    20a8d5 <BmSimple.cfence+0x75>
        stderr_file = try io.getStdErr();
  20a8a1:	48 8d 05 88 17 04 00 	lea    rax,[rip+0x41788]        # 24c030 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20a8a8:	48 89 05 89 17 04 00 	mov    QWORD PTR [rip+0x41789],rax        # 24c038 <stderr_file_out_stream>
  20a8af:	48 8d 05 ea 45 01 00 	lea    rax,[rip+0x145ea]        # 21eea0 <FileOutStream_writeFn>
  20a8b6:	48 89 05 83 17 04 00 	mov    QWORD PTR [rip+0x41783],rax        # 24c040 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  20a8bd:	c7 05 69 17 04 00 02 	mov    DWORD PTR [rip+0x41769],0x2        # 24c030 <stderr_file>
  20a8c4:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20a8c7:	48 8d 3d 72 17 04 00 	lea    rdi,[rip+0x41772]        # 24c040 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  20a8ce:	48 89 3d 33 67 04 00 	mov    QWORD PTR [rip+0x46733],rdi        # 251008 <stderr_stream>
        if (state != State.Start) {
            @compileError("Incomplete format string: " ++ fmt);
        }
    }
    if (start_index < fmt.len) {
        try output(context, fmt[start_index..]);
  20a8d5:	48 8d 35 14 56 04 00 	lea    rsi,[rip+0x45614]        # 24fef0 <__unnamed_3>
  20a8dc:	ff d0                	call   rax
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20a8de:	31 c0                	xor    eax,eax
  20a8e0:	86 05 2a 67 04 00    	xchg   BYTE PTR [rip+0x4672a],al        # 251010 <stderr_mutex>
  20a8e6:	3c 01                	cmp    al,0x1
    if (!ok) {
  20a8e8:	0f 85 8a 0a 00 00    	jne    20b378 <BmSimple.cfence+0xb18>
    // Since this is a test print a \n before we run
    warn("\n");

    // Create an instance of Benchmark and run
    var bm = Benchmark.init("BmSimple.cfence", std.debug.global_allocator);
  20a8ee:	c5 f8 10 05 ea 53 04 	vmovups xmm0,XMMWORD PTR [rip+0x453ea]        # 24fce0 <__unnamed_4>
  20a8f5:	00 
  20a8f6:	c5 f8 29 44 24 20    	vmovaps XMMWORD PTR [rsp+0x20],xmm0
  20a8fc:	c5 fc 28 05 bc 58 ff 	vmovaps ymm0,YMMWORD PTR [rip+0xffffffffffff58bc]        # 2001c0 <__unnamed_29-0x40>
  20a903:	ff 
  20a904:	c5 fc 11 44 24 30    	vmovups YMMWORD PTR [rsp+0x30],ymm0
  20a90a:	c5 fa 6f 05 fe 59 ff 	vmovdqu xmm0,XMMWORD PTR [rip+0xffffffffffff59fe]        # 200310 <__unnamed_35>
  20a911:	ff 
  20a912:	c5 f9 7f 44 24 50    	vmovdqa XMMWORD PTR [rsp+0x50],xmm0
  20a918:	48 8d 05 e1 16 04 00 	lea    rax,[rip+0x416e1]        # 24c000 <global_fixed_allocator>
  20a91f:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  20a924:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  20a928:	c5 fa 7f 44 24 68    	vmovdqu XMMWORD PTR [rsp+0x68],xmm0
  20a92e:	48 c7 44 24 78 00 00 	mov    QWORD PTR [rsp+0x78],0x0
  20a935:	00 00 
  20a937:	48 89 84 24 80 00 00 	mov    QWORD PTR [rsp+0x80],rax
  20a93e:	00 
  20a93f:	41 b6 01             	mov    r14b,0x1
  20a942:	49 bf 00 e8 76 48 17 	movabs r15,0x174876e800
  20a949:	00 00 00 
  20a94c:	bb 01 00 00 00       	mov    ebx,0x1
  20a951:	4c 8d a4 24 90 00 00 	lea    r12,[rsp+0x90]
  20a958:	00 
  20a959:	45 31 ed             	xor    r13d,r13d
            while (iterations <= pSelf.max_iterations) {
  20a95c:	4c 39 fb             	cmp    rbx,r15
  20a95f:	0f 87 2e 03 00 00    	ja     20ac93 <BmSimple.cfence+0x433>
  20a965:	eb 17                	jmp    20a97e <BmSimple.cfence+0x11e>
  20a967:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  20a96e:	00 00 
                        warn("iteratons:{} numer:{} denom:{}\n", iterations, numer, denom);
  20a970:	48 89 df             	mov    rdi,rbx
  20a973:	48 89 ca             	mov    rdx,rcx
  20a976:	c5 f8 77             	vzeroupper 
  20a979:	e8 b2 a6 00 00       	call   215030 <warn.37>
                //On Linux, seccomp can do arbitrary things to our ability to call
                //  syscalls, including return any errno value it wants and
                //  inconsistently throwing errors. Since we can't account for
                //  abuses of seccomp in a reasonable way, we'll assume that if
                //  seccomp is going to block us it will at least do so consistently
                var ts: posix.timespec = undefined;
  20a97e:	c5 fa 6f 05 8a 59 ff 	vmovdqu xmm0,XMMWORD PTR [rip+0xffffffffffff598a]        # 200310 <__unnamed_35>
  20a985:	ff 
  20a986:	c5 f9 7f 84 24 90 00 	vmovdqa XMMWORD PTR [rsp+0x90],xmm0
  20a98d:	00 00 
        : "rcx", "r11"
    );
}

pub fn syscall2(number: usize, arg1: usize, arg2: usize) usize {
    return asm volatile ("syscall"
  20a98f:	b8 e5 00 00 00       	mov    eax,0xe5
  20a994:	bf 01 00 00 00       	mov    edi,0x1
  20a999:	4c 89 e6             	mov    rsi,r12
  20a99c:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  20a99e:	48 89 c1             	mov    rcx,rax
  20a9a1:	48 f7 d9             	neg    rcx
  20a9a4:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  20a9aa:	b8 00 00 00 00       	mov    eax,0x0
  20a9af:	48 0f 46 c8          	cmovbe rcx,rax
                var result = posix.clock_getres(monotonic_clock_id, &ts);
                var errno = posix.getErrno(result);
                switch (errno) {
  20a9b3:	48 85 c9             	test   rcx,rcx
  20a9b6:	0f 85 97 09 00 00    	jne    20b353 <BmSimple.cfence+0xaf3>
        const f = @atomicLoad(@typeOf(init_vdso_clock_gettime), &vdso_clock_gettime, builtin.AtomicOrder.Unordered);
  20a9bc:	48 8b 05 55 17 04 00 	mov    rax,QWORD PTR [rip+0x41755]        # 24c118 <vdso_clock_gettime>
        if (@ptrToInt(f) != 0) {
  20a9c3:	48 85 c0             	test   rax,rax
  20a9c6:	74 24                	je     20a9ec <BmSimple.cfence+0x18c>
            const rc = f(clk_id, tp);
  20a9c8:	bf 01 00 00 00       	mov    edi,0x1
  20a9cd:	4c 89 e6             	mov    rsi,r12
  20a9d0:	c5 f8 77             	vzeroupper 
  20a9d3:	ff d0                	call   rax
            switch (rc) {
  20a9d5:	48 83 f8 ea          	cmp    rax,0xffffffffffffffea
  20a9d9:	0f 84 41 02 00 00    	je     20ac20 <BmSimple.cfence+0x3c0>
  20a9df:	48 85 c0             	test   rax,rax
  20a9e2:	c5 fa 6f 05 26 59 ff 	vmovdqu xmm0,XMMWORD PTR [rip+0xffffffffffff5926]        # 200310 <__unnamed_35>
  20a9e9:	ff 
  20a9ea:	74 0f                	je     20a9fb <BmSimple.cfence+0x19b>
  20a9ec:	b8 e4 00 00 00       	mov    eax,0xe4
  20a9f1:	bf 01 00 00 00       	mov    edi,0x1
  20a9f6:	4c 89 e6             	mov    rsi,r12
  20a9f9:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  20a9fb:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
                }
                self.resolution = @intCast(u64, ts.tv_sec) * u64(ns_per_s) + @intCast(u64, ts.tv_nsec);

                result = posix.clock_gettime(monotonic_clock_id, &ts);
                errno = posix.getErrno(result);
                if (errno != 0) return std.os.unexpectedErrorPosix(errno);
  20aa01:	0f 83 58 09 00 00    	jae    20b35f <BmSimple.cfence+0xaff>
                self.start_time = @intCast(u64, ts.tv_sec) * u64(ns_per_s) + @intCast(u64, ts.tv_nsec);
  20aa07:	c5 f9 6f 8c 24 90 00 	vmovdqa xmm1,XMMWORD PTR [rsp+0x90]
  20aa0e:	00 00 
        while (iter > 0) : (iter -= 1) {
  20aa10:	48 85 db             	test   rbx,rbx
  20aa13:	74 11                	je     20aa26 <BmSimple.cfence+0x1c6>
  20aa15:	48 89 d8             	mov    rax,rbx
  20aa18:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  20aa1f:	00 
  20aa20:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  20aa24:	75 fa                	jne    20aa20 <BmSimple.cfence+0x1c0>
    fn clockDarwin() u64 {
        return darwin.mach_absolute_time();
    }

    fn clockLinux() u64 {
        var ts: posix.timespec = undefined;
  20aa26:	c5 f9 7f 84 24 90 00 	vmovdqa XMMWORD PTR [rsp+0x90],xmm0
  20aa2d:	00 00 
        const f = @atomicLoad(@typeOf(init_vdso_clock_gettime), &vdso_clock_gettime, builtin.AtomicOrder.Unordered);
  20aa2f:	48 8b 05 e2 16 04 00 	mov    rax,QWORD PTR [rip+0x416e2]        # 24c118 <vdso_clock_gettime>
        if (@ptrToInt(f) != 0) {
  20aa36:	48 85 c0             	test   rax,rax
  20aa39:	74 2e                	je     20aa69 <BmSimple.cfence+0x209>
  20aa3b:	c5 f9 7f 8c 24 c0 00 	vmovdqa XMMWORD PTR [rsp+0xc0],xmm1
  20aa42:	00 00 
            const rc = f(clk_id, tp);
  20aa44:	bf 01 00 00 00       	mov    edi,0x1
  20aa49:	4c 89 e6             	mov    rsi,r12
  20aa4c:	c5 f8 77             	vzeroupper 
  20aa4f:	ff d0                	call   rax
            switch (rc) {
  20aa51:	48 83 f8 ea          	cmp    rax,0xffffffffffffffea
  20aa55:	0f 84 de 01 00 00    	je     20ac39 <BmSimple.cfence+0x3d9>
  20aa5b:	48 85 c0             	test   rax,rax
  20aa5e:	c5 f9 6f 8c 24 c0 00 	vmovdqa xmm1,XMMWORD PTR [rsp+0xc0]
  20aa65:	00 00 
  20aa67:	74 0f                	je     20aa78 <BmSimple.cfence+0x218>
  20aa69:	b8 e4 00 00 00       	mov    eax,0xe4
  20aa6e:	bf 01 00 00 00       	mov    edi,0x1
  20aa73:	4c 89 e6             	mov    rsi,r12
  20aa76:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  20aa78:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
  20aa7e:	0f 83 f4 08 00 00    	jae    20b378 <BmSimple.cfence+0xb18>
        var result = posix.clock_gettime(monotonic_clock_id, &ts);
        debug.assert(posix.getErrno(result) == 0);
        return @intCast(u64, ts.tv_sec) * u64(ns_per_s) + @intCast(u64, ts.tv_nsec);
  20aa84:	c5 f9 6f 84 24 90 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x90]
  20aa8b:	00 00 
  20aa8d:	c5 f9 fb c1          	vpsubq xmm0,xmm0,xmm1
  20aa91:	c4 e1 f9 7e c0       	vmovq  rax,xmm0
        var clock = clockNative() - self.start_time;
  20aa96:	c4 e3 f9 16 c5 01    	vpextrq rbp,xmm0,0x1
  20aa9c:	48 69 c0 00 ca 9a 3b 	imul   rax,rax,0x3b9aca00
  20aaa3:	48 01 c5             	add    rbp,rax
                if ((run_time_ns >= pSelf.min_runtime_ns) or (iterations >= pSelf.max_iterations)) {
  20aaa6:	48 3b 6c 24 38       	cmp    rbp,QWORD PTR [rsp+0x38]
  20aaab:	0f 83 a2 01 00 00    	jae    20ac53 <BmSimple.cfence+0x3f3>
  20aab1:	4c 39 fb             	cmp    rbx,r15
  20aab4:	0f 83 99 01 00 00    	jae    20ac53 <BmSimple.cfence+0x3f3>
                    if (pSelf.logl >= 1) {
  20aaba:	48 83 7c 24 30 00    	cmp    QWORD PTR [rsp+0x30],0x0
  20aac0:	0f 84 c0 00 00 00    	je     20ab86 <BmSimple.cfence+0x326>
                            Result {.run_time_ns = run_time_ns, .iterations = iterations});
  20aac6:	48 89 ac 24 d8 00 00 	mov    QWORD PTR [rsp+0xd8],rbp
  20aacd:	00 
  20aace:	48 89 9c 24 e0 00 00 	mov    QWORD PTR [rsp+0xe0],rbx
  20aad5:	00 
                        try pSelf.report(
  20aad6:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  20aadb:	48 8d b4 24 d8 00 00 	lea    rsi,[rsp+0xd8]
  20aae2:	00 
  20aae3:	c5 f8 77             	vzeroupper 
  20aae6:	e8 35 84 00 00       	call   212f20 <Benchmark_report>
  20aaeb:	66 85 c0             	test   ax,ax
  20aaee:	0f 85 6f 08 00 00    	jne    20b363 <BmSimple.cfence+0xb03>
  20aaf4:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20aafb:	00 00 00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20ab00:	b0 01                	mov    al,0x1
  20ab02:	86 05 08 65 04 00    	xchg   BYTE PTR [rip+0x46508],al        # 251010 <stderr_mutex>
  20ab08:	84 c0                	test   al,al
  20ab0a:	75 f4                	jne    20ab00 <BmSimple.cfence+0x2a0>
    if (stderr_stream) |st| {
  20ab0c:	48 8b 3d f5 64 04 00 	mov    rdi,QWORD PTR [rip+0x464f5]        # 251008 <stderr_stream>
  20ab13:	48 85 ff             	test   rdi,rdi
  20ab16:	74 18                	je     20ab30 <BmSimple.cfence+0x2d0>
  20ab18:	48 8b 0d 21 15 04 00 	mov    rcx,QWORD PTR [rip+0x41521]        # 24c040 <stderr_file_out_stream+0x8>
  20ab1f:	eb 4c                	jmp    20ab6d <BmSimple.cfence+0x30d>
  20ab21:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20ab28:	0f 1f 84 00 00 00 00 
  20ab2f:	00 
        stderr_file = try io.getStdErr();
  20ab30:	c7 05 f6 14 04 00 02 	mov    DWORD PTR [rip+0x414f6],0x2        # 24c030 <stderr_file>
  20ab37:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20ab3a:	48 8d 05 ef 14 04 00 	lea    rax,[rip+0x414ef]        # 24c030 <stderr_file>
  20ab41:	48 89 05 f0 14 04 00 	mov    QWORD PTR [rip+0x414f0],rax        # 24c038 <stderr_file_out_stream>
  20ab48:	48 8d 05 51 43 01 00 	lea    rax,[rip+0x14351]        # 21eea0 <FileOutStream_writeFn>
  20ab4f:	48 89 05 ea 14 04 00 	mov    QWORD PTR [rip+0x414ea],rax        # 24c040 <stderr_file_out_stream+0x8>
  20ab56:	48 8d 0d e3 14 04 00 	lea    rcx,[rip+0x414e3]        # 24c040 <stderr_file_out_stream+0x8>
  20ab5d:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20ab60:	48 89 15 a1 64 04 00 	mov    QWORD PTR [rip+0x464a1],rdx        # 251008 <stderr_stream>
  20ab67:	48 89 c1             	mov    rcx,rax
  20ab6a:	48 89 d7             	mov    rdi,rdx
  20ab6d:	48 8d 35 7c 53 04 00 	lea    rsi,[rip+0x4537c]        # 24fef0 <__unnamed_3>
  20ab74:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20ab76:	31 c0                	xor    eax,eax
  20ab78:	86 05 92 64 04 00    	xchg   BYTE PTR [rip+0x46492],al        # 251010 <stderr_mutex>
  20ab7e:	3c 01                	cmp    al,0x1
    if (!ok) {
  20ab80:	0f 85 f2 07 00 00    	jne    20b378 <BmSimple.cfence+0xb18>
                    if (run_time_ns < 1000) {
  20ab86:	48 81 fd e8 03 00 00 	cmp    rbp,0x3e8
  20ab8d:	73 31                	jae    20abc0 <BmSimple.cfence+0x360>
  20ab8f:	b9 01 00 00 00       	mov    ecx,0x1
  20ab94:	be e8 03 00 00       	mov    esi,0x3e8
                    iterations = (iterations * numer) / denom;
  20ab99:	48 0f af de          	imul   rbx,rsi
  20ab9d:	48 89 d8             	mov    rax,rbx
  20aba0:	48 c1 e8 20          	shr    rax,0x20
  20aba4:	74 54                	je     20abfa <BmSimple.cfence+0x39a>
  20aba6:	31 d2                	xor    edx,edx
  20aba8:	48 89 d8             	mov    rax,rbx
  20abab:	48 f7 f1             	div    rcx
  20abae:	48 89 c3             	mov    rbx,rax
  20abb1:	eb 4f                	jmp    20ac02 <BmSimple.cfence+0x3a2>
  20abb3:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20abba:	84 00 00 00 00 00 
                    } else if (run_time_ns < (pSelf.min_runtime_ns / 10)) {
  20abc0:	48 ba cd cc cc cc cc 	movabs rdx,0xcccccccccccccccd
  20abc7:	cc cc cc 
  20abca:	c4 e2 fb f6 4c 24 38 	mulx   rcx,rax,QWORD PTR [rsp+0x38]
  20abd1:	48 c1 e9 03          	shr    rcx,0x3
  20abd5:	31 c0                	xor    eax,eax
  20abd7:	48 39 cd             	cmp    rbp,rcx
  20abda:	0f 93 c0             	setae  al
  20abdd:	48 8d 0c c0          	lea    rcx,[rax+rax*8]
  20abe1:	48 83 c1 01          	add    rcx,0x1
  20abe5:	48 8d 34 85 0a 00 00 	lea    rsi,[rax*4+0xa]
  20abec:	00 
                    iterations = (iterations * numer) / denom;
  20abed:	48 0f af de          	imul   rbx,rsi
  20abf1:	48 89 d8             	mov    rax,rbx
  20abf4:	48 c1 e8 20          	shr    rax,0x20
  20abf8:	75 ac                	jne    20aba6 <BmSimple.cfence+0x346>
  20abfa:	31 d2                	xor    edx,edx
  20abfc:	89 d8                	mov    eax,ebx
  20abfe:	f7 f1                	div    ecx
  20ac00:	89 c3                	mov    ebx,eax
                    if (iterations > pSelf.max_iterations) {
  20ac02:	4c 8b 7c 24 48       	mov    r15,QWORD PTR [rsp+0x48]
  20ac07:	4c 39 fb             	cmp    rbx,r15
  20ac0a:	49 0f 47 df          	cmova  rbx,r15
                    if (pSelf.logl >= 2) {
  20ac0e:	48 83 7c 24 30 02    	cmp    QWORD PTR [rsp+0x30],0x2
  20ac14:	0f 82 64 fd ff ff    	jb     20a97e <BmSimple.cfence+0x11e>
  20ac1a:	e9 51 fd ff ff       	jmp    20a970 <BmSimple.cfence+0x110>
  20ac1f:	90                   	nop
  20ac20:	c5 fa 6f 05 e8 56 ff 	vmovdqu xmm0,XMMWORD PTR [rip+0xffffffffffff56e8]        # 200310 <__unnamed_35>
  20ac27:	ff 
  20ac28:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
                if (errno != 0) return std.os.unexpectedErrorPosix(errno);
  20ac2e:	0f 82 d3 fd ff ff    	jb     20aa07 <BmSimple.cfence+0x1a7>
  20ac34:	e9 26 07 00 00       	jmp    20b35f <BmSimple.cfence+0xaff>
  20ac39:	c5 f9 6f 8c 24 c0 00 	vmovdqa xmm1,XMMWORD PTR [rsp+0xc0]
  20ac40:	00 00 
  20ac42:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
  20ac48:	0f 82 36 fe ff ff    	jb     20aa84 <BmSimple.cfence+0x224>
  20ac4e:	e9 25 07 00 00       	jmp    20b378 <BmSimple.cfence+0xb18>
                            Result { .run_time_ns = run_time_ns, .iterations = iterations});
  20ac53:	48 89 ac 24 e8 00 00 	mov    QWORD PTR [rsp+0xe8],rbp
  20ac5a:	00 
  20ac5b:	48 89 9c 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rbx
  20ac62:	00 
                    try pSelf.results.append(
  20ac63:	48 8d 7c 24 68       	lea    rdi,[rsp+0x68]
  20ac68:	48 8d b4 24 e8 00 00 	lea    rsi,[rsp+0xe8]
  20ac6f:	00 
  20ac70:	c5 f8 77             	vzeroupper 
  20ac73:	e8 38 81 00 00       	call   212db0 <AlignedArrayList(Result,8)_append>
  20ac78:	66 85 c0             	test   ax,ax
  20ac7b:	74 16                	je     20ac93 <BmSimple.cfence+0x433>
  20ac7d:	e9 e1 06 00 00       	jmp    20b363 <BmSimple.cfence+0xb03>
            while (iterations <= pSelf.max_iterations) {
  20ac82:	4c 8b 7c 24 48       	mov    r15,QWORD PTR [rsp+0x48]
  20ac87:	45 31 f6             	xor    r14d,r14d
  20ac8a:	4c 39 fb             	cmp    rbx,r15
  20ac8d:	0f 86 eb fc ff ff    	jbe    20a97e <BmSimple.cfence+0x11e>
            if (once) {
  20ac93:	41 f6 c6 01          	test   r14b,0x1
  20ac97:	48 8d 6c 24 0f       	lea    rbp,[rsp+0xf]
  20ac9c:	4c 8d 74 24 10       	lea    r14,[rsp+0x10]
  20aca1:	0f 84 e0 05 00 00    	je     20b287 <BmSimple.cfence+0xa27>
                try leftJustified(22, "name repetitions:{}", pSelf.repetitions);
  20aca7:	48 8b 7c 24 40       	mov    rdi,QWORD PTR [rsp+0x40]
  20acac:	c5 f8 77             	vzeroupper 
  20acaf:	e8 ec a6 00 00       	call   2153a0 <Benchmark_leftJustified>
  20acb4:	66 85 c0             	test   ax,ax
  20acb7:	0f 85 a6 06 00 00    	jne    20b363 <BmSimple.cfence+0xb03>
                try rightJustified(14, "{}", "iterations");
  20acbd:	e8 7e a9 00 00       	call   215640 <Benchmark_rightJustified>
  20acc2:	66 85 c0             	test   ax,ax
  20acc5:	0f 85 98 06 00 00    	jne    20b363 <BmSimple.cfence+0xb03>
        var buffer: [40]u8 = undefined;
  20accb:	c5 fe 6f 05 7c b2 ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffffb27c]        # 205f4f <__unnamed_7>
  20acd2:	ff 
  20acd3:	c5 fe 7f 84 24 90 00 	vmovdqu YMMWORD PTR [rsp+0x90],ymm0
  20acda:	00 00 
  20acdc:	48 8b 05 8c b2 ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffffb28c]        # 205f6f <__unnamed_7+0x20>
  20ace3:	48 89 84 24 b0 00 00 	mov    QWORD PTR [rsp+0xb0],rax
  20acea:	00 
        dest[i] = s;
  20aceb:	c7 84 24 90 00 00 00 	mov    DWORD PTR [rsp+0x90],0x656d6974
  20acf2:	74 69 6d 65 
  20acf6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  20acfd:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20ad00:	b0 01                	mov    al,0x1
  20ad02:	86 05 08 63 04 00    	xchg   BYTE PTR [rip+0x46308],al        # 251010 <stderr_mutex>
  20ad08:	84 c0                	test   al,al
  20ad0a:	75 f4                	jne    20ad00 <BmSimple.cfence+0x4a0>
    if (stderr_stream) |st| {
  20ad0c:	48 8b 3d f5 62 04 00 	mov    rdi,QWORD PTR [rip+0x462f5]        # 251008 <stderr_stream>
  20ad13:	48 85 ff             	test   rdi,rdi
  20ad16:	74 09                	je     20ad21 <BmSimple.cfence+0x4c1>
  20ad18:	48 8b 0d 21 13 04 00 	mov    rcx,QWORD PTR [rip+0x41321]        # 24c040 <stderr_file_out_stream+0x8>
  20ad1f:	eb 3d                	jmp    20ad5e <BmSimple.cfence+0x4fe>
        stderr_file = try io.getStdErr();
  20ad21:	c7 05 05 13 04 00 02 	mov    DWORD PTR [rip+0x41305],0x2        # 24c030 <stderr_file>
  20ad28:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20ad2b:	48 8d 05 fe 12 04 00 	lea    rax,[rip+0x412fe]        # 24c030 <stderr_file>
  20ad32:	48 89 05 ff 12 04 00 	mov    QWORD PTR [rip+0x412ff],rax        # 24c038 <stderr_file_out_stream>
  20ad39:	48 8d 05 60 41 01 00 	lea    rax,[rip+0x14160]        # 21eea0 <FileOutStream_writeFn>
  20ad40:	48 89 05 f9 12 04 00 	mov    QWORD PTR [rip+0x412f9],rax        # 24c040 <stderr_file_out_stream+0x8>
  20ad47:	48 8d 0d f2 12 04 00 	lea    rcx,[rip+0x412f2]        # 24c040 <stderr_file_out_stream+0x8>
  20ad4e:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20ad51:	48 89 15 b0 62 04 00 	mov    QWORD PTR [rip+0x462b0],rdx        # 251008 <stderr_stream>
  20ad58:	48 89 c1             	mov    rcx,rax
  20ad5b:	48 89 d7             	mov    rdi,rdx
  20ad5e:	c6 44 24 0f 20       	mov    BYTE PTR [rsp+0xf],0x20
    c: u8,
    context: var,
    comptime Errors: type,
    output: fn (@typeOf(context), []const u8) Errors!void,
) Errors!void {
    return output(context, (*[1]u8)(&c)[0..]);
  20ad63:	48 89 6c 24 10       	mov    QWORD PTR [rsp+0x10],rbp
  20ad68:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  20ad6f:	00 00 
  20ad71:	4c 89 f6             	mov    rsi,r14
  20ad74:	c5 f8 77             	vzeroupper 
  20ad77:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20ad79:	31 c0                	xor    eax,eax
  20ad7b:	86 05 8f 62 04 00    	xchg   BYTE PTR [rip+0x4628f],al        # 251010 <stderr_mutex>
  20ad81:	3c 01                	cmp    al,0x1
    if (!ok) {
  20ad83:	0f 85 ef 05 00 00    	jne    20b378 <BmSimple.cfence+0xb18>
  20ad89:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20ad90:	b0 01                	mov    al,0x1
  20ad92:	86 05 78 62 04 00    	xchg   BYTE PTR [rip+0x46278],al        # 251010 <stderr_mutex>
  20ad98:	84 c0                	test   al,al
  20ad9a:	75 f4                	jne    20ad90 <BmSimple.cfence+0x530>
    if (stderr_stream) |st| {
  20ad9c:	48 8b 3d 65 62 04 00 	mov    rdi,QWORD PTR [rip+0x46265]        # 251008 <stderr_stream>
  20ada3:	48 85 ff             	test   rdi,rdi
  20ada6:	74 09                	je     20adb1 <BmSimple.cfence+0x551>
  20ada8:	48 8b 0d 91 12 04 00 	mov    rcx,QWORD PTR [rip+0x41291]        # 24c040 <stderr_file_out_stream+0x8>
  20adaf:	eb 3d                	jmp    20adee <BmSimple.cfence+0x58e>
        stderr_file = try io.getStdErr();
  20adb1:	c7 05 75 12 04 00 02 	mov    DWORD PTR [rip+0x41275],0x2        # 24c030 <stderr_file>
  20adb8:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20adbb:	48 8d 05 6e 12 04 00 	lea    rax,[rip+0x4126e]        # 24c030 <stderr_file>
  20adc2:	48 89 05 6f 12 04 00 	mov    QWORD PTR [rip+0x4126f],rax        # 24c038 <stderr_file_out_stream>
  20adc9:	48 8d 05 d0 40 01 00 	lea    rax,[rip+0x140d0]        # 21eea0 <FileOutStream_writeFn>
  20add0:	48 89 05 69 12 04 00 	mov    QWORD PTR [rip+0x41269],rax        # 24c040 <stderr_file_out_stream+0x8>
  20add7:	48 8d 0d 62 12 04 00 	lea    rcx,[rip+0x41262]        # 24c040 <stderr_file_out_stream+0x8>
  20adde:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20ade1:	48 89 15 20 62 04 00 	mov    QWORD PTR [rip+0x46220],rdx        # 251008 <stderr_stream>
  20ade8:	48 89 c1             	mov    rcx,rax
  20adeb:	48 89 d7             	mov    rdi,rdx
  20adee:	c6 44 24 0f 20       	mov    BYTE PTR [rsp+0xf],0x20
  20adf3:	48 89 6c 24 10       	mov    QWORD PTR [rsp+0x10],rbp
  20adf8:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  20adff:	00 00 
  20ae01:	4c 89 f6             	mov    rsi,r14
  20ae04:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20ae06:	31 c0                	xor    eax,eax
  20ae08:	86 05 02 62 04 00    	xchg   BYTE PTR [rip+0x46202],al        # 251010 <stderr_mutex>
  20ae0e:	3c 01                	cmp    al,0x1
    if (!ok) {
  20ae10:	0f 85 62 05 00 00    	jne    20b378 <BmSimple.cfence+0xb18>
  20ae16:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  20ae1d:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20ae20:	b0 01                	mov    al,0x1
  20ae22:	86 05 e8 61 04 00    	xchg   BYTE PTR [rip+0x461e8],al        # 251010 <stderr_mutex>
  20ae28:	84 c0                	test   al,al
  20ae2a:	75 f4                	jne    20ae20 <BmSimple.cfence+0x5c0>
    if (stderr_stream) |st| {
  20ae2c:	48 8b 3d d5 61 04 00 	mov    rdi,QWORD PTR [rip+0x461d5]        # 251008 <stderr_stream>
  20ae33:	48 85 ff             	test   rdi,rdi
  20ae36:	74 09                	je     20ae41 <BmSimple.cfence+0x5e1>
  20ae38:	48 8b 0d 01 12 04 00 	mov    rcx,QWORD PTR [rip+0x41201]        # 24c040 <stderr_file_out_stream+0x8>
  20ae3f:	eb 3d                	jmp    20ae7e <BmSimple.cfence+0x61e>
        stderr_file = try io.getStdErr();
  20ae41:	c7 05 e5 11 04 00 02 	mov    DWORD PTR [rip+0x411e5],0x2        # 24c030 <stderr_file>
  20ae48:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20ae4b:	48 8d 05 de 11 04 00 	lea    rax,[rip+0x411de]        # 24c030 <stderr_file>
  20ae52:	48 89 05 df 11 04 00 	mov    QWORD PTR [rip+0x411df],rax        # 24c038 <stderr_file_out_stream>
  20ae59:	48 8d 05 40 40 01 00 	lea    rax,[rip+0x14040]        # 21eea0 <FileOutStream_writeFn>
  20ae60:	48 89 05 d9 11 04 00 	mov    QWORD PTR [rip+0x411d9],rax        # 24c040 <stderr_file_out_stream+0x8>
  20ae67:	48 8d 0d d2 11 04 00 	lea    rcx,[rip+0x411d2]        # 24c040 <stderr_file_out_stream+0x8>
  20ae6e:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20ae71:	48 89 15 90 61 04 00 	mov    QWORD PTR [rip+0x46190],rdx        # 251008 <stderr_stream>
  20ae78:	48 89 c1             	mov    rcx,rax
  20ae7b:	48 89 d7             	mov    rdi,rdx
  20ae7e:	c6 44 24 0f 20       	mov    BYTE PTR [rsp+0xf],0x20
  20ae83:	48 89 6c 24 10       	mov    QWORD PTR [rsp+0x10],rbp
  20ae88:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  20ae8f:	00 00 
  20ae91:	4c 89 f6             	mov    rsi,r14
  20ae94:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20ae96:	31 c0                	xor    eax,eax
  20ae98:	86 05 72 61 04 00    	xchg   BYTE PTR [rip+0x46172],al        # 251010 <stderr_mutex>
  20ae9e:	3c 01                	cmp    al,0x1
    if (!ok) {
  20aea0:	0f 85 d2 04 00 00    	jne    20b378 <BmSimple.cfence+0xb18>
  20aea6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  20aead:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20aeb0:	b0 01                	mov    al,0x1
  20aeb2:	86 05 58 61 04 00    	xchg   BYTE PTR [rip+0x46158],al        # 251010 <stderr_mutex>
  20aeb8:	84 c0                	test   al,al
  20aeba:	75 f4                	jne    20aeb0 <BmSimple.cfence+0x650>
    if (stderr_stream) |st| {
  20aebc:	48 8b 3d 45 61 04 00 	mov    rdi,QWORD PTR [rip+0x46145]        # 251008 <stderr_stream>
  20aec3:	48 85 ff             	test   rdi,rdi
  20aec6:	74 09                	je     20aed1 <BmSimple.cfence+0x671>
  20aec8:	48 8b 0d 71 11 04 00 	mov    rcx,QWORD PTR [rip+0x41171]        # 24c040 <stderr_file_out_stream+0x8>
  20aecf:	eb 3d                	jmp    20af0e <BmSimple.cfence+0x6ae>
        stderr_file = try io.getStdErr();
  20aed1:	c7 05 55 11 04 00 02 	mov    DWORD PTR [rip+0x41155],0x2        # 24c030 <stderr_file>
  20aed8:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20aedb:	48 8d 05 4e 11 04 00 	lea    rax,[rip+0x4114e]        # 24c030 <stderr_file>
  20aee2:	48 89 05 4f 11 04 00 	mov    QWORD PTR [rip+0x4114f],rax        # 24c038 <stderr_file_out_stream>
  20aee9:	48 8d 05 b0 3f 01 00 	lea    rax,[rip+0x13fb0]        # 21eea0 <FileOutStream_writeFn>
  20aef0:	48 89 05 49 11 04 00 	mov    QWORD PTR [rip+0x41149],rax        # 24c040 <stderr_file_out_stream+0x8>
  20aef7:	48 8d 0d 42 11 04 00 	lea    rcx,[rip+0x41142]        # 24c040 <stderr_file_out_stream+0x8>
  20aefe:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20af01:	48 89 15 00 61 04 00 	mov    QWORD PTR [rip+0x46100],rdx        # 251008 <stderr_stream>
  20af08:	48 89 c1             	mov    rcx,rax
  20af0b:	48 89 d7             	mov    rdi,rdx
  20af0e:	c6 44 24 0f 20       	mov    BYTE PTR [rsp+0xf],0x20
  20af13:	48 89 6c 24 10       	mov    QWORD PTR [rsp+0x10],rbp
  20af18:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  20af1f:	00 00 
  20af21:	4c 89 f6             	mov    rsi,r14
  20af24:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20af26:	31 c0                	xor    eax,eax
  20af28:	86 05 e2 60 04 00    	xchg   BYTE PTR [rip+0x460e2],al        # 251010 <stderr_mutex>
  20af2e:	3c 01                	cmp    al,0x1
    if (!ok) {
  20af30:	0f 85 42 04 00 00    	jne    20b378 <BmSimple.cfence+0xb18>
  20af36:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  20af3d:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20af40:	b0 01                	mov    al,0x1
  20af42:	86 05 c8 60 04 00    	xchg   BYTE PTR [rip+0x460c8],al        # 251010 <stderr_mutex>
  20af48:	84 c0                	test   al,al
  20af4a:	75 f4                	jne    20af40 <BmSimple.cfence+0x6e0>
    if (stderr_stream) |st| {
  20af4c:	48 8b 3d b5 60 04 00 	mov    rdi,QWORD PTR [rip+0x460b5]        # 251008 <stderr_stream>
  20af53:	48 85 ff             	test   rdi,rdi
  20af56:	74 09                	je     20af61 <BmSimple.cfence+0x701>
  20af58:	48 8b 0d e1 10 04 00 	mov    rcx,QWORD PTR [rip+0x410e1]        # 24c040 <stderr_file_out_stream+0x8>
  20af5f:	eb 3d                	jmp    20af9e <BmSimple.cfence+0x73e>
        stderr_file = try io.getStdErr();
  20af61:	c7 05 c5 10 04 00 02 	mov    DWORD PTR [rip+0x410c5],0x2        # 24c030 <stderr_file>
  20af68:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20af6b:	48 8d 05 be 10 04 00 	lea    rax,[rip+0x410be]        # 24c030 <stderr_file>
  20af72:	48 89 05 bf 10 04 00 	mov    QWORD PTR [rip+0x410bf],rax        # 24c038 <stderr_file_out_stream>
  20af79:	48 8d 05 20 3f 01 00 	lea    rax,[rip+0x13f20]        # 21eea0 <FileOutStream_writeFn>
  20af80:	48 89 05 b9 10 04 00 	mov    QWORD PTR [rip+0x410b9],rax        # 24c040 <stderr_file_out_stream+0x8>
  20af87:	48 8d 0d b2 10 04 00 	lea    rcx,[rip+0x410b2]        # 24c040 <stderr_file_out_stream+0x8>
  20af8e:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20af91:	48 89 15 70 60 04 00 	mov    QWORD PTR [rip+0x46070],rdx        # 251008 <stderr_stream>
  20af98:	48 89 c1             	mov    rcx,rax
  20af9b:	48 89 d7             	mov    rdi,rdx
  20af9e:	c6 44 24 0f 20       	mov    BYTE PTR [rsp+0xf],0x20
  20afa3:	48 89 6c 24 10       	mov    QWORD PTR [rsp+0x10],rbp
  20afa8:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  20afaf:	00 00 
  20afb1:	4c 89 f6             	mov    rsi,r14
  20afb4:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20afb6:	31 c0                	xor    eax,eax
  20afb8:	86 05 52 60 04 00    	xchg   BYTE PTR [rip+0x46052],al        # 251010 <stderr_mutex>
  20afbe:	3c 01                	cmp    al,0x1
    if (!ok) {
  20afc0:	0f 85 b2 03 00 00    	jne    20b378 <BmSimple.cfence+0xb18>
  20afc6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  20afcd:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20afd0:	b0 01                	mov    al,0x1
  20afd2:	86 05 38 60 04 00    	xchg   BYTE PTR [rip+0x46038],al        # 251010 <stderr_mutex>
  20afd8:	84 c0                	test   al,al
  20afda:	75 f4                	jne    20afd0 <BmSimple.cfence+0x770>
    if (stderr_stream) |st| {
  20afdc:	48 8b 3d 25 60 04 00 	mov    rdi,QWORD PTR [rip+0x46025]        # 251008 <stderr_stream>
  20afe3:	48 85 ff             	test   rdi,rdi
  20afe6:	74 09                	je     20aff1 <BmSimple.cfence+0x791>
  20afe8:	48 8b 0d 51 10 04 00 	mov    rcx,QWORD PTR [rip+0x41051]        # 24c040 <stderr_file_out_stream+0x8>
  20afef:	eb 3d                	jmp    20b02e <BmSimple.cfence+0x7ce>
        stderr_file = try io.getStdErr();
  20aff1:	c7 05 35 10 04 00 02 	mov    DWORD PTR [rip+0x41035],0x2        # 24c030 <stderr_file>
  20aff8:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20affb:	48 8d 05 2e 10 04 00 	lea    rax,[rip+0x4102e]        # 24c030 <stderr_file>
  20b002:	48 89 05 2f 10 04 00 	mov    QWORD PTR [rip+0x4102f],rax        # 24c038 <stderr_file_out_stream>
  20b009:	48 8d 05 90 3e 01 00 	lea    rax,[rip+0x13e90]        # 21eea0 <FileOutStream_writeFn>
  20b010:	48 89 05 29 10 04 00 	mov    QWORD PTR [rip+0x41029],rax        # 24c040 <stderr_file_out_stream+0x8>
  20b017:	48 8d 0d 22 10 04 00 	lea    rcx,[rip+0x41022]        # 24c040 <stderr_file_out_stream+0x8>
  20b01e:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20b021:	48 89 15 e0 5f 04 00 	mov    QWORD PTR [rip+0x45fe0],rdx        # 251008 <stderr_stream>
  20b028:	48 89 c1             	mov    rcx,rax
  20b02b:	48 89 d7             	mov    rdi,rdx
  20b02e:	c6 44 24 0f 20       	mov    BYTE PTR [rsp+0xf],0x20
  20b033:	48 89 6c 24 10       	mov    QWORD PTR [rsp+0x10],rbp
  20b038:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  20b03f:	00 00 
  20b041:	4c 89 f6             	mov    rsi,r14
  20b044:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20b046:	31 c0                	xor    eax,eax
  20b048:	86 05 c2 5f 04 00    	xchg   BYTE PTR [rip+0x45fc2],al        # 251010 <stderr_mutex>
  20b04e:	3c 01                	cmp    al,0x1
    if (!ok) {
  20b050:	0f 85 22 03 00 00    	jne    20b378 <BmSimple.cfence+0xb18>
  20b056:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  20b05d:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20b060:	b0 01                	mov    al,0x1
  20b062:	86 05 a8 5f 04 00    	xchg   BYTE PTR [rip+0x45fa8],al        # 251010 <stderr_mutex>
  20b068:	84 c0                	test   al,al
  20b06a:	75 f4                	jne    20b060 <BmSimple.cfence+0x800>
    if (stderr_stream) |st| {
  20b06c:	48 8b 3d 95 5f 04 00 	mov    rdi,QWORD PTR [rip+0x45f95]        # 251008 <stderr_stream>
  20b073:	48 85 ff             	test   rdi,rdi
  20b076:	74 09                	je     20b081 <BmSimple.cfence+0x821>
  20b078:	48 8b 0d c1 0f 04 00 	mov    rcx,QWORD PTR [rip+0x40fc1]        # 24c040 <stderr_file_out_stream+0x8>
  20b07f:	eb 3d                	jmp    20b0be <BmSimple.cfence+0x85e>
        stderr_file = try io.getStdErr();
  20b081:	c7 05 a5 0f 04 00 02 	mov    DWORD PTR [rip+0x40fa5],0x2        # 24c030 <stderr_file>
  20b088:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20b08b:	48 8d 05 9e 0f 04 00 	lea    rax,[rip+0x40f9e]        # 24c030 <stderr_file>
  20b092:	48 89 05 9f 0f 04 00 	mov    QWORD PTR [rip+0x40f9f],rax        # 24c038 <stderr_file_out_stream>
  20b099:	48 8d 05 00 3e 01 00 	lea    rax,[rip+0x13e00]        # 21eea0 <FileOutStream_writeFn>
  20b0a0:	48 89 05 99 0f 04 00 	mov    QWORD PTR [rip+0x40f99],rax        # 24c040 <stderr_file_out_stream+0x8>
  20b0a7:	48 8d 0d 92 0f 04 00 	lea    rcx,[rip+0x40f92]        # 24c040 <stderr_file_out_stream+0x8>
  20b0ae:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20b0b1:	48 89 15 50 5f 04 00 	mov    QWORD PTR [rip+0x45f50],rdx        # 251008 <stderr_stream>
  20b0b8:	48 89 c1             	mov    rcx,rax
  20b0bb:	48 89 d7             	mov    rdi,rdx
  20b0be:	c6 44 24 0f 20       	mov    BYTE PTR [rsp+0xf],0x20
  20b0c3:	48 89 6c 24 10       	mov    QWORD PTR [rsp+0x10],rbp
  20b0c8:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  20b0cf:	00 00 
  20b0d1:	4c 89 f6             	mov    rsi,r14
  20b0d4:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20b0d6:	31 c0                	xor    eax,eax
  20b0d8:	86 05 32 5f 04 00    	xchg   BYTE PTR [rip+0x45f32],al        # 251010 <stderr_mutex>
  20b0de:	3c 01                	cmp    al,0x1
    if (!ok) {
  20b0e0:	0f 85 92 02 00 00    	jne    20b378 <BmSimple.cfence+0xb18>
  20b0e6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  20b0ed:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20b0f0:	b0 01                	mov    al,0x1
  20b0f2:	86 05 18 5f 04 00    	xchg   BYTE PTR [rip+0x45f18],al        # 251010 <stderr_mutex>
  20b0f8:	84 c0                	test   al,al
  20b0fa:	75 f4                	jne    20b0f0 <BmSimple.cfence+0x890>
    if (stderr_stream) |st| {
  20b0fc:	48 8b 3d 05 5f 04 00 	mov    rdi,QWORD PTR [rip+0x45f05]        # 251008 <stderr_stream>
  20b103:	48 85 ff             	test   rdi,rdi
  20b106:	74 09                	je     20b111 <BmSimple.cfence+0x8b1>
  20b108:	48 8b 0d 31 0f 04 00 	mov    rcx,QWORD PTR [rip+0x40f31]        # 24c040 <stderr_file_out_stream+0x8>
  20b10f:	eb 3d                	jmp    20b14e <BmSimple.cfence+0x8ee>
        stderr_file = try io.getStdErr();
  20b111:	c7 05 15 0f 04 00 02 	mov    DWORD PTR [rip+0x40f15],0x2        # 24c030 <stderr_file>
  20b118:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20b11b:	48 8d 05 0e 0f 04 00 	lea    rax,[rip+0x40f0e]        # 24c030 <stderr_file>
  20b122:	48 89 05 0f 0f 04 00 	mov    QWORD PTR [rip+0x40f0f],rax        # 24c038 <stderr_file_out_stream>
  20b129:	48 8d 05 70 3d 01 00 	lea    rax,[rip+0x13d70]        # 21eea0 <FileOutStream_writeFn>
  20b130:	48 89 05 09 0f 04 00 	mov    QWORD PTR [rip+0x40f09],rax        # 24c040 <stderr_file_out_stream+0x8>
  20b137:	48 8d 0d 02 0f 04 00 	lea    rcx,[rip+0x40f02]        # 24c040 <stderr_file_out_stream+0x8>
  20b13e:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20b141:	48 89 15 c0 5e 04 00 	mov    QWORD PTR [rip+0x45ec0],rdx        # 251008 <stderr_stream>
  20b148:	48 89 c1             	mov    rcx,rax
  20b14b:	48 89 d7             	mov    rdi,rdx
  20b14e:	c6 44 24 0f 20       	mov    BYTE PTR [rsp+0xf],0x20
  20b153:	48 89 6c 24 10       	mov    QWORD PTR [rsp+0x10],rbp
  20b158:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  20b15f:	00 00 
  20b161:	4c 89 f6             	mov    rsi,r14
  20b164:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20b166:	31 c0                	xor    eax,eax
  20b168:	86 05 a2 5e 04 00    	xchg   BYTE PTR [rip+0x45ea2],al        # 251010 <stderr_mutex>
  20b16e:	3c 01                	cmp    al,0x1
    if (!ok) {
  20b170:	0f 85 02 02 00 00    	jne    20b378 <BmSimple.cfence+0xb18>
  20b176:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  20b17d:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20b180:	b0 01                	mov    al,0x1
  20b182:	86 05 88 5e 04 00    	xchg   BYTE PTR [rip+0x45e88],al        # 251010 <stderr_mutex>
  20b188:	84 c0                	test   al,al
  20b18a:	75 f4                	jne    20b180 <BmSimple.cfence+0x920>
    if (stderr_stream) |st| {
  20b18c:	48 8b 3d 75 5e 04 00 	mov    rdi,QWORD PTR [rip+0x45e75]        # 251008 <stderr_stream>
  20b193:	48 85 ff             	test   rdi,rdi
  20b196:	74 09                	je     20b1a1 <BmSimple.cfence+0x941>
  20b198:	48 8b 0d a1 0e 04 00 	mov    rcx,QWORD PTR [rip+0x40ea1]        # 24c040 <stderr_file_out_stream+0x8>
  20b19f:	eb 3d                	jmp    20b1de <BmSimple.cfence+0x97e>
        stderr_file = try io.getStdErr();
  20b1a1:	c7 05 85 0e 04 00 02 	mov    DWORD PTR [rip+0x40e85],0x2        # 24c030 <stderr_file>
  20b1a8:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20b1ab:	48 8d 05 7e 0e 04 00 	lea    rax,[rip+0x40e7e]        # 24c030 <stderr_file>
  20b1b2:	48 89 05 7f 0e 04 00 	mov    QWORD PTR [rip+0x40e7f],rax        # 24c038 <stderr_file_out_stream>
  20b1b9:	48 8d 05 e0 3c 01 00 	lea    rax,[rip+0x13ce0]        # 21eea0 <FileOutStream_writeFn>
  20b1c0:	48 89 05 79 0e 04 00 	mov    QWORD PTR [rip+0x40e79],rax        # 24c040 <stderr_file_out_stream+0x8>
  20b1c7:	48 8d 0d 72 0e 04 00 	lea    rcx,[rip+0x40e72]        # 24c040 <stderr_file_out_stream+0x8>
  20b1ce:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20b1d1:	48 89 15 30 5e 04 00 	mov    QWORD PTR [rip+0x45e30],rdx        # 251008 <stderr_stream>
  20b1d8:	48 89 c1             	mov    rcx,rax
  20b1db:	48 89 d7             	mov    rdi,rdx
                const casted_value = ([]const u8)(value);
  20b1de:	4c 89 64 24 10       	mov    QWORD PTR [rsp+0x10],r12
  20b1e3:	48 c7 44 24 18 04 00 	mov    QWORD PTR [rsp+0x18],0x4
  20b1ea:	00 00 
                return output(context, casted_value);
  20b1ec:	4c 89 f6             	mov    rsi,r14
  20b1ef:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20b1f1:	31 c0                	xor    eax,eax
  20b1f3:	86 05 17 5e 04 00    	xchg   BYTE PTR [rip+0x45e17],al        # 251010 <stderr_mutex>
  20b1f9:	3c 01                	cmp    al,0x1
    if (!ok) {
  20b1fb:	0f 85 77 01 00 00    	jne    20b378 <BmSimple.cfence+0xb18>
                try rightJustified(18, "{}", "time/operation");
  20b201:	e8 1a a7 00 00       	call   215920 <Benchmark_rightJustified.39>
  20b206:	66 85 c0             	test   ax,ax
  20b209:	0f 85 54 01 00 00    	jne    20b363 <BmSimple.cfence+0xb03>
  20b20f:	90                   	nop
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20b210:	b0 01                	mov    al,0x1
  20b212:	86 05 f8 5d 04 00    	xchg   BYTE PTR [rip+0x45df8],al        # 251010 <stderr_mutex>
  20b218:	84 c0                	test   al,al
  20b21a:	75 f4                	jne    20b210 <BmSimple.cfence+0x9b0>
    if (stderr_stream) |st| {
  20b21c:	48 8b 3d e5 5d 04 00 	mov    rdi,QWORD PTR [rip+0x45de5]        # 251008 <stderr_stream>
  20b223:	48 85 ff             	test   rdi,rdi
  20b226:	74 09                	je     20b231 <BmSimple.cfence+0x9d1>
  20b228:	48 8b 0d 11 0e 04 00 	mov    rcx,QWORD PTR [rip+0x40e11]        # 24c040 <stderr_file_out_stream+0x8>
  20b22f:	eb 3d                	jmp    20b26e <BmSimple.cfence+0xa0e>
        stderr_file = try io.getStdErr();
  20b231:	c7 05 f5 0d 04 00 02 	mov    DWORD PTR [rip+0x40df5],0x2        # 24c030 <stderr_file>
  20b238:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20b23b:	48 8d 05 ee 0d 04 00 	lea    rax,[rip+0x40dee]        # 24c030 <stderr_file>
  20b242:	48 89 05 ef 0d 04 00 	mov    QWORD PTR [rip+0x40def],rax        # 24c038 <stderr_file_out_stream>
  20b249:	48 8d 05 50 3c 01 00 	lea    rax,[rip+0x13c50]        # 21eea0 <FileOutStream_writeFn>
  20b250:	48 89 05 e9 0d 04 00 	mov    QWORD PTR [rip+0x40de9],rax        # 24c040 <stderr_file_out_stream+0x8>
  20b257:	48 8d 0d e2 0d 04 00 	lea    rcx,[rip+0x40de2]        # 24c040 <stderr_file_out_stream+0x8>
  20b25e:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20b261:	48 89 15 a0 5d 04 00 	mov    QWORD PTR [rip+0x45da0],rdx        # 251008 <stderr_stream>
  20b268:	48 89 c1             	mov    rcx,rax
  20b26b:	48 89 d7             	mov    rdi,rdx
        try output(context, fmt[start_index..]);
  20b26e:	48 8d 35 7b 4c 04 00 	lea    rsi,[rip+0x44c7b]        # 24fef0 <__unnamed_3>
  20b275:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20b277:	31 c0                	xor    eax,eax
  20b279:	86 05 91 5d 04 00    	xchg   BYTE PTR [rip+0x45d91],al        # 251010 <stderr_mutex>
  20b27f:	3c 01                	cmp    al,0x1
    if (!ok) {
  20b281:	0f 85 f1 00 00 00    	jne    20b378 <BmSimple.cfence+0xb18>
            try pSelf.report(pSelf.results.items[pSelf.results.len - 1]); warn("\n");
  20b287:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  20b28c:	48 8b 4c 24 78       	mov    rcx,QWORD PTR [rsp+0x78]
  20b291:	48 c1 e1 04          	shl    rcx,0x4
  20b295:	48 8d 34 08          	lea    rsi,[rax+rcx*1]
  20b299:	48 83 c6 f0          	add    rsi,0xfffffffffffffff0
  20b29d:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  20b2a2:	c5 f8 77             	vzeroupper 
  20b2a5:	e8 76 7c 00 00       	call   212f20 <Benchmark_report>
  20b2aa:	66 85 c0             	test   ax,ax
  20b2ad:	0f 85 b0 00 00 00    	jne    20b363 <BmSimple.cfence+0xb03>
  20b2b3:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20b2ba:	84 00 00 00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20b2c0:	b0 01                	mov    al,0x1
  20b2c2:	86 05 48 5d 04 00    	xchg   BYTE PTR [rip+0x45d48],al        # 251010 <stderr_mutex>
  20b2c8:	84 c0                	test   al,al
  20b2ca:	75 f4                	jne    20b2c0 <BmSimple.cfence+0xa60>
    if (stderr_stream) |st| {
  20b2cc:	48 8b 3d 35 5d 04 00 	mov    rdi,QWORD PTR [rip+0x45d35]        # 251008 <stderr_stream>
  20b2d3:	48 85 ff             	test   rdi,rdi
  20b2d6:	74 09                	je     20b2e1 <BmSimple.cfence+0xa81>
  20b2d8:	48 8b 0d 61 0d 04 00 	mov    rcx,QWORD PTR [rip+0x40d61]        # 24c040 <stderr_file_out_stream+0x8>
  20b2df:	eb 3d                	jmp    20b31e <BmSimple.cfence+0xabe>
        stderr_file = try io.getStdErr();
  20b2e1:	c7 05 45 0d 04 00 02 	mov    DWORD PTR [rip+0x40d45],0x2        # 24c030 <stderr_file>
  20b2e8:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20b2eb:	48 8d 05 3e 0d 04 00 	lea    rax,[rip+0x40d3e]        # 24c030 <stderr_file>
  20b2f2:	48 89 05 3f 0d 04 00 	mov    QWORD PTR [rip+0x40d3f],rax        # 24c038 <stderr_file_out_stream>
  20b2f9:	48 8d 05 a0 3b 01 00 	lea    rax,[rip+0x13ba0]        # 21eea0 <FileOutStream_writeFn>
  20b300:	48 89 05 39 0d 04 00 	mov    QWORD PTR [rip+0x40d39],rax        # 24c040 <stderr_file_out_stream+0x8>
  20b307:	48 8d 0d 32 0d 04 00 	lea    rcx,[rip+0x40d32]        # 24c040 <stderr_file_out_stream+0x8>
  20b30e:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20b311:	48 89 15 f0 5c 04 00 	mov    QWORD PTR [rip+0x45cf0],rdx        # 251008 <stderr_stream>
  20b318:	48 89 c1             	mov    rcx,rax
  20b31b:	48 89 d7             	mov    rdi,rdx
  20b31e:	48 8d 35 cb 4b 04 00 	lea    rsi,[rip+0x44bcb]        # 24fef0 <__unnamed_3>
  20b325:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20b327:	31 c0                	xor    eax,eax
  20b329:	86 05 e1 5c 04 00    	xchg   BYTE PTR [rip+0x45ce1],al        # 251010 <stderr_mutex>
  20b32f:	3c 01                	cmp    al,0x1
    if (!ok) {
  20b331:	75 45                	jne    20b378 <BmSimple.cfence+0xb18>
  20b333:	49 83 c5 01          	add    r13,0x1
        while (rep < pSelf.repetitions) : (rep += 1) {
  20b337:	4c 3b 6c 24 40       	cmp    r13,QWORD PTR [rsp+0x40]
  20b33c:	0f 82 40 f9 ff ff    	jb     20ac82 <BmSimple.cfence+0x422>
  20b342:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
        try pSelf.reportStats(pSelf.results);
  20b347:	48 8d 74 24 68       	lea    rsi,[rsp+0x68]
  20b34c:	e8 af a8 00 00       	call   215c00 <Benchmark_reportStats>
  20b351:	eb 10                	jmp    20b363 <BmSimple.cfence+0xb03>
                switch (errno) {
  20b353:	48 83 f9 16          	cmp    rcx,0x16
  20b357:	75 06                	jne    20b35f <BmSimple.cfence+0xaff>
  20b359:	66 b8 02 00          	mov    ax,0x2
  20b35d:	eb 04                	jmp    20b363 <BmSimple.cfence+0xb03>
  20b35f:	66 b8 03 00          	mov    ax,0x3
    _ = try bm.run(struct {
  20b363:	48 81 c4 f8 00 00 00 	add    rsp,0xf8
  20b36a:	5b                   	pop    rbx
  20b36b:	41 5c                	pop    r12
  20b36d:	41 5d                	pop    r13
  20b36f:	41 5e                	pop    r14
  20b371:	41 5f                	pop    r15
  20b373:	5d                   	pop    rbp
  20b374:	c5 f8 77             	vzeroupper 
  20b377:	c3                   	ret    
            @panic("assertion failure");
  20b378:	48 8d 3d 11 4a 04 00 	lea    rdi,[rip+0x44a11]        # 24fd90 <__unnamed_2>
  20b37f:	c5 f8 77             	vzeroupper 
  20b382:	e8 99 73 00 00       	call   212720 <panic>
  20b387:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  20b38e:	00 00 

000000000020b390 <BmSimple.lfence>:
            cfence();
        }
    });
}

test "BmSimple.lfence" {
  20b390:	55                   	push   rbp
  20b391:	41 57                	push   r15
  20b393:	41 56                	push   r14
  20b395:	41 55                	push   r13
  20b397:	41 54                	push   r12
  20b399:	53                   	push   rbx
  20b39a:	48 81 ec f8 00 00 00 	sub    rsp,0xf8
  20b3a1:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20b3a8:	0f 1f 84 00 00 00 00 
  20b3af:	00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20b3b0:	b0 01                	mov    al,0x1
  20b3b2:	86 05 58 5c 04 00    	xchg   BYTE PTR [rip+0x45c58],al        # 251010 <stderr_mutex>
  20b3b8:	84 c0                	test   al,al
  20b3ba:	75 f4                	jne    20b3b0 <BmSimple.lfence+0x20>
    if (stderr_stream) |st| {
  20b3bc:	48 8b 3d 45 5c 04 00 	mov    rdi,QWORD PTR [rip+0x45c45]        # 251008 <stderr_stream>
  20b3c3:	48 85 ff             	test   rdi,rdi
  20b3c6:	74 09                	je     20b3d1 <BmSimple.lfence+0x41>
  20b3c8:	48 8b 05 71 0c 04 00 	mov    rax,QWORD PTR [rip+0x40c71]        # 24c040 <stderr_file_out_stream+0x8>
  20b3cf:	eb 34                	jmp    20b405 <BmSimple.lfence+0x75>
        stderr_file = try io.getStdErr();
  20b3d1:	48 8d 05 58 0c 04 00 	lea    rax,[rip+0x40c58]        # 24c030 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20b3d8:	48 89 05 59 0c 04 00 	mov    QWORD PTR [rip+0x40c59],rax        # 24c038 <stderr_file_out_stream>
  20b3df:	48 8d 05 ba 3a 01 00 	lea    rax,[rip+0x13aba]        # 21eea0 <FileOutStream_writeFn>
  20b3e6:	48 89 05 53 0c 04 00 	mov    QWORD PTR [rip+0x40c53],rax        # 24c040 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  20b3ed:	c7 05 39 0c 04 00 02 	mov    DWORD PTR [rip+0x40c39],0x2        # 24c030 <stderr_file>
  20b3f4:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20b3f7:	48 8d 3d 42 0c 04 00 	lea    rdi,[rip+0x40c42]        # 24c040 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  20b3fe:	48 89 3d 03 5c 04 00 	mov    QWORD PTR [rip+0x45c03],rdi        # 251008 <stderr_stream>
  20b405:	48 8d 35 e4 4a 04 00 	lea    rsi,[rip+0x44ae4]        # 24fef0 <__unnamed_3>
  20b40c:	ff d0                	call   rax
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20b40e:	31 c0                	xor    eax,eax
  20b410:	86 05 fa 5b 04 00    	xchg   BYTE PTR [rip+0x45bfa],al        # 251010 <stderr_mutex>
  20b416:	3c 01                	cmp    al,0x1
    if (!ok) {
  20b418:	0f 85 8a 0a 00 00    	jne    20bea8 <BmSimple.lfence+0xb18>
    // Since this is a test print a \n before we run
    warn("\n");

    // Create an instance of Benchmark and run
    var bm = Benchmark.init("BmSimple.lfence", std.debug.global_allocator);
  20b41e:	c5 f8 10 05 ca 48 04 	vmovups xmm0,XMMWORD PTR [rip+0x448ca]        # 24fcf0 <__unnamed_8>
  20b425:	00 
  20b426:	c5 f8 29 44 24 20    	vmovaps XMMWORD PTR [rsp+0x20],xmm0
  20b42c:	c5 fc 28 05 8c 4d ff 	vmovaps ymm0,YMMWORD PTR [rip+0xffffffffffff4d8c]        # 2001c0 <__unnamed_29-0x40>
  20b433:	ff 
  20b434:	c5 fc 11 44 24 30    	vmovups YMMWORD PTR [rsp+0x30],ymm0
  20b43a:	c5 fa 6f 05 ce 4e ff 	vmovdqu xmm0,XMMWORD PTR [rip+0xffffffffffff4ece]        # 200310 <__unnamed_35>
  20b441:	ff 
  20b442:	c5 f9 7f 44 24 50    	vmovdqa XMMWORD PTR [rsp+0x50],xmm0
  20b448:	48 8d 05 b1 0b 04 00 	lea    rax,[rip+0x40bb1]        # 24c000 <global_fixed_allocator>
  20b44f:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  20b454:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  20b458:	c5 fa 7f 44 24 68    	vmovdqu XMMWORD PTR [rsp+0x68],xmm0
  20b45e:	48 c7 44 24 78 00 00 	mov    QWORD PTR [rsp+0x78],0x0
  20b465:	00 00 
  20b467:	48 89 84 24 80 00 00 	mov    QWORD PTR [rsp+0x80],rax
  20b46e:	00 
  20b46f:	41 b6 01             	mov    r14b,0x1
  20b472:	49 bf 00 e8 76 48 17 	movabs r15,0x174876e800
  20b479:	00 00 00 
  20b47c:	bb 01 00 00 00       	mov    ebx,0x1
  20b481:	4c 8d a4 24 90 00 00 	lea    r12,[rsp+0x90]
  20b488:	00 
  20b489:	45 31 ed             	xor    r13d,r13d
            while (iterations <= pSelf.max_iterations) {
  20b48c:	4c 39 fb             	cmp    rbx,r15
  20b48f:	0f 87 2e 03 00 00    	ja     20b7c3 <BmSimple.lfence+0x433>
  20b495:	eb 17                	jmp    20b4ae <BmSimple.lfence+0x11e>
  20b497:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  20b49e:	00 00 
                        warn("iteratons:{} numer:{} denom:{}\n", iterations, numer, denom);
  20b4a0:	48 89 df             	mov    rdi,rbx
  20b4a3:	48 89 ca             	mov    rdx,rcx
  20b4a6:	c5 f8 77             	vzeroupper 
  20b4a9:	e8 82 9b 00 00       	call   215030 <warn.37>
                var ts: posix.timespec = undefined;
  20b4ae:	c5 fa 6f 05 5a 4e ff 	vmovdqu xmm0,XMMWORD PTR [rip+0xffffffffffff4e5a]        # 200310 <__unnamed_35>
  20b4b5:	ff 
  20b4b6:	c5 f9 7f 84 24 90 00 	vmovdqa XMMWORD PTR [rsp+0x90],xmm0
  20b4bd:	00 00 
  20b4bf:	b8 e5 00 00 00       	mov    eax,0xe5
  20b4c4:	bf 01 00 00 00       	mov    edi,0x1
  20b4c9:	4c 89 e6             	mov    rsi,r12
  20b4cc:	0f 05                	syscall 
  20b4ce:	48 89 c1             	mov    rcx,rax
  20b4d1:	48 f7 d9             	neg    rcx
  20b4d4:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  20b4da:	b8 00 00 00 00       	mov    eax,0x0
  20b4df:	48 0f 46 c8          	cmovbe rcx,rax
                switch (errno) {
  20b4e3:	48 85 c9             	test   rcx,rcx
  20b4e6:	0f 85 97 09 00 00    	jne    20be83 <BmSimple.lfence+0xaf3>
        const f = @atomicLoad(@typeOf(init_vdso_clock_gettime), &vdso_clock_gettime, builtin.AtomicOrder.Unordered);
  20b4ec:	48 8b 05 25 0c 04 00 	mov    rax,QWORD PTR [rip+0x40c25]        # 24c118 <vdso_clock_gettime>
        if (@ptrToInt(f) != 0) {
  20b4f3:	48 85 c0             	test   rax,rax
  20b4f6:	74 24                	je     20b51c <BmSimple.lfence+0x18c>
            const rc = f(clk_id, tp);
  20b4f8:	bf 01 00 00 00       	mov    edi,0x1
  20b4fd:	4c 89 e6             	mov    rsi,r12
  20b500:	c5 f8 77             	vzeroupper 
  20b503:	ff d0                	call   rax
            switch (rc) {
  20b505:	48 83 f8 ea          	cmp    rax,0xffffffffffffffea
  20b509:	0f 84 41 02 00 00    	je     20b750 <BmSimple.lfence+0x3c0>
  20b50f:	48 85 c0             	test   rax,rax
  20b512:	c5 fa 6f 05 f6 4d ff 	vmovdqu xmm0,XMMWORD PTR [rip+0xffffffffffff4df6]        # 200310 <__unnamed_35>
  20b519:	ff 
  20b51a:	74 0f                	je     20b52b <BmSimple.lfence+0x19b>
  20b51c:	b8 e4 00 00 00       	mov    eax,0xe4
  20b521:	bf 01 00 00 00       	mov    edi,0x1
  20b526:	4c 89 e6             	mov    rsi,r12
  20b529:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  20b52b:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
                if (errno != 0) return std.os.unexpectedErrorPosix(errno);
  20b531:	0f 83 58 09 00 00    	jae    20be8f <BmSimple.lfence+0xaff>
                self.start_time = @intCast(u64, ts.tv_sec) * u64(ns_per_s) + @intCast(u64, ts.tv_nsec);
  20b537:	c5 f9 6f 8c 24 90 00 	vmovdqa xmm1,XMMWORD PTR [rsp+0x90]
  20b53e:	00 00 
        while (iter > 0) : (iter -= 1) {
  20b540:	48 85 db             	test   rbx,rbx
  20b543:	74 14                	je     20b559 <BmSimple.lfence+0x1c9>
  20b545:	48 89 d8             	mov    rax,rbx
  20b548:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  20b54f:	00 
    asm volatile ("lfence": : :"memory");
  20b550:	0f ae e8             	lfence 
        while (iter > 0) : (iter -= 1) {
  20b553:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  20b557:	75 f7                	jne    20b550 <BmSimple.lfence+0x1c0>
        var ts: posix.timespec = undefined;
  20b559:	c5 f9 7f 84 24 90 00 	vmovdqa XMMWORD PTR [rsp+0x90],xmm0
  20b560:	00 00 
        const f = @atomicLoad(@typeOf(init_vdso_clock_gettime), &vdso_clock_gettime, builtin.AtomicOrder.Unordered);
  20b562:	48 8b 05 af 0b 04 00 	mov    rax,QWORD PTR [rip+0x40baf]        # 24c118 <vdso_clock_gettime>
        if (@ptrToInt(f) != 0) {
  20b569:	48 85 c0             	test   rax,rax
  20b56c:	74 2e                	je     20b59c <BmSimple.lfence+0x20c>
  20b56e:	c5 f9 7f 8c 24 c0 00 	vmovdqa XMMWORD PTR [rsp+0xc0],xmm1
  20b575:	00 00 
            const rc = f(clk_id, tp);
  20b577:	bf 01 00 00 00       	mov    edi,0x1
  20b57c:	4c 89 e6             	mov    rsi,r12
  20b57f:	c5 f8 77             	vzeroupper 
  20b582:	ff d0                	call   rax
            switch (rc) {
  20b584:	48 83 f8 ea          	cmp    rax,0xffffffffffffffea
  20b588:	0f 84 db 01 00 00    	je     20b769 <BmSimple.lfence+0x3d9>
  20b58e:	48 85 c0             	test   rax,rax
  20b591:	c5 f9 6f 8c 24 c0 00 	vmovdqa xmm1,XMMWORD PTR [rsp+0xc0]
  20b598:	00 00 
  20b59a:	74 0f                	je     20b5ab <BmSimple.lfence+0x21b>
  20b59c:	b8 e4 00 00 00       	mov    eax,0xe4
  20b5a1:	bf 01 00 00 00       	mov    edi,0x1
  20b5a6:	4c 89 e6             	mov    rsi,r12
  20b5a9:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  20b5ab:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
  20b5b1:	0f 83 f1 08 00 00    	jae    20bea8 <BmSimple.lfence+0xb18>
        return @intCast(u64, ts.tv_sec) * u64(ns_per_s) + @intCast(u64, ts.tv_nsec);
  20b5b7:	c5 f9 6f 84 24 90 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x90]
  20b5be:	00 00 
  20b5c0:	c5 f9 fb c1          	vpsubq xmm0,xmm0,xmm1
  20b5c4:	c4 e1 f9 7e c0       	vmovq  rax,xmm0
        var clock = clockNative() - self.start_time;
  20b5c9:	c4 e3 f9 16 c5 01    	vpextrq rbp,xmm0,0x1
  20b5cf:	48 69 c0 00 ca 9a 3b 	imul   rax,rax,0x3b9aca00
  20b5d6:	48 01 c5             	add    rbp,rax
                if ((run_time_ns >= pSelf.min_runtime_ns) or (iterations >= pSelf.max_iterations)) {
  20b5d9:	48 3b 6c 24 38       	cmp    rbp,QWORD PTR [rsp+0x38]
  20b5de:	0f 83 9f 01 00 00    	jae    20b783 <BmSimple.lfence+0x3f3>
  20b5e4:	4c 39 fb             	cmp    rbx,r15
  20b5e7:	0f 83 96 01 00 00    	jae    20b783 <BmSimple.lfence+0x3f3>
                    if (pSelf.logl >= 1) {
  20b5ed:	48 83 7c 24 30 00    	cmp    QWORD PTR [rsp+0x30],0x0
  20b5f3:	0f 84 bd 00 00 00    	je     20b6b6 <BmSimple.lfence+0x326>
                            Result {.run_time_ns = run_time_ns, .iterations = iterations});
  20b5f9:	48 89 ac 24 d8 00 00 	mov    QWORD PTR [rsp+0xd8],rbp
  20b600:	00 
  20b601:	48 89 9c 24 e0 00 00 	mov    QWORD PTR [rsp+0xe0],rbx
  20b608:	00 
                        try pSelf.report(
  20b609:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  20b60e:	48 8d b4 24 d8 00 00 	lea    rsi,[rsp+0xd8]
  20b615:	00 
  20b616:	c5 f8 77             	vzeroupper 
  20b619:	e8 02 79 00 00       	call   212f20 <Benchmark_report>
  20b61e:	66 85 c0             	test   ax,ax
  20b621:	0f 85 6c 08 00 00    	jne    20be93 <BmSimple.lfence+0xb03>
  20b627:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  20b62e:	00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20b630:	b0 01                	mov    al,0x1
  20b632:	86 05 d8 59 04 00    	xchg   BYTE PTR [rip+0x459d8],al        # 251010 <stderr_mutex>
  20b638:	84 c0                	test   al,al
  20b63a:	75 f4                	jne    20b630 <BmSimple.lfence+0x2a0>
    if (stderr_stream) |st| {
  20b63c:	48 8b 3d c5 59 04 00 	mov    rdi,QWORD PTR [rip+0x459c5]        # 251008 <stderr_stream>
  20b643:	48 85 ff             	test   rdi,rdi
  20b646:	74 18                	je     20b660 <BmSimple.lfence+0x2d0>
  20b648:	48 8b 0d f1 09 04 00 	mov    rcx,QWORD PTR [rip+0x409f1]        # 24c040 <stderr_file_out_stream+0x8>
  20b64f:	eb 4c                	jmp    20b69d <BmSimple.lfence+0x30d>
  20b651:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20b658:	0f 1f 84 00 00 00 00 
  20b65f:	00 
        stderr_file = try io.getStdErr();
  20b660:	c7 05 c6 09 04 00 02 	mov    DWORD PTR [rip+0x409c6],0x2        # 24c030 <stderr_file>
  20b667:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20b66a:	48 8d 05 bf 09 04 00 	lea    rax,[rip+0x409bf]        # 24c030 <stderr_file>
  20b671:	48 89 05 c0 09 04 00 	mov    QWORD PTR [rip+0x409c0],rax        # 24c038 <stderr_file_out_stream>
  20b678:	48 8d 05 21 38 01 00 	lea    rax,[rip+0x13821]        # 21eea0 <FileOutStream_writeFn>
  20b67f:	48 89 05 ba 09 04 00 	mov    QWORD PTR [rip+0x409ba],rax        # 24c040 <stderr_file_out_stream+0x8>
  20b686:	48 8d 0d b3 09 04 00 	lea    rcx,[rip+0x409b3]        # 24c040 <stderr_file_out_stream+0x8>
  20b68d:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20b690:	48 89 15 71 59 04 00 	mov    QWORD PTR [rip+0x45971],rdx        # 251008 <stderr_stream>
  20b697:	48 89 c1             	mov    rcx,rax
  20b69a:	48 89 d7             	mov    rdi,rdx
  20b69d:	48 8d 35 4c 48 04 00 	lea    rsi,[rip+0x4484c]        # 24fef0 <__unnamed_3>
  20b6a4:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20b6a6:	31 c0                	xor    eax,eax
  20b6a8:	86 05 62 59 04 00    	xchg   BYTE PTR [rip+0x45962],al        # 251010 <stderr_mutex>
  20b6ae:	3c 01                	cmp    al,0x1
    if (!ok) {
  20b6b0:	0f 85 f2 07 00 00    	jne    20bea8 <BmSimple.lfence+0xb18>
                    if (run_time_ns < 1000) {
  20b6b6:	48 81 fd e8 03 00 00 	cmp    rbp,0x3e8
  20b6bd:	73 31                	jae    20b6f0 <BmSimple.lfence+0x360>
  20b6bf:	b9 01 00 00 00       	mov    ecx,0x1
  20b6c4:	be e8 03 00 00       	mov    esi,0x3e8
                    iterations = (iterations * numer) / denom;
  20b6c9:	48 0f af de          	imul   rbx,rsi
  20b6cd:	48 89 d8             	mov    rax,rbx
  20b6d0:	48 c1 e8 20          	shr    rax,0x20
  20b6d4:	74 54                	je     20b72a <BmSimple.lfence+0x39a>
  20b6d6:	31 d2                	xor    edx,edx
  20b6d8:	48 89 d8             	mov    rax,rbx
  20b6db:	48 f7 f1             	div    rcx
  20b6de:	48 89 c3             	mov    rbx,rax
  20b6e1:	eb 4f                	jmp    20b732 <BmSimple.lfence+0x3a2>
  20b6e3:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20b6ea:	84 00 00 00 00 00 
                    } else if (run_time_ns < (pSelf.min_runtime_ns / 10)) {
  20b6f0:	48 ba cd cc cc cc cc 	movabs rdx,0xcccccccccccccccd
  20b6f7:	cc cc cc 
  20b6fa:	c4 e2 fb f6 4c 24 38 	mulx   rcx,rax,QWORD PTR [rsp+0x38]
  20b701:	48 c1 e9 03          	shr    rcx,0x3
  20b705:	31 c0                	xor    eax,eax
  20b707:	48 39 cd             	cmp    rbp,rcx
  20b70a:	0f 93 c0             	setae  al
  20b70d:	48 8d 0c c0          	lea    rcx,[rax+rax*8]
  20b711:	48 83 c1 01          	add    rcx,0x1
  20b715:	48 8d 34 85 0a 00 00 	lea    rsi,[rax*4+0xa]
  20b71c:	00 
                    iterations = (iterations * numer) / denom;
  20b71d:	48 0f af de          	imul   rbx,rsi
  20b721:	48 89 d8             	mov    rax,rbx
  20b724:	48 c1 e8 20          	shr    rax,0x20
  20b728:	75 ac                	jne    20b6d6 <BmSimple.lfence+0x346>
  20b72a:	31 d2                	xor    edx,edx
  20b72c:	89 d8                	mov    eax,ebx
  20b72e:	f7 f1                	div    ecx
  20b730:	89 c3                	mov    ebx,eax
                    if (iterations > pSelf.max_iterations) {
  20b732:	4c 8b 7c 24 48       	mov    r15,QWORD PTR [rsp+0x48]
  20b737:	4c 39 fb             	cmp    rbx,r15
  20b73a:	49 0f 47 df          	cmova  rbx,r15
                    if (pSelf.logl >= 2) {
  20b73e:	48 83 7c 24 30 02    	cmp    QWORD PTR [rsp+0x30],0x2
  20b744:	0f 82 64 fd ff ff    	jb     20b4ae <BmSimple.lfence+0x11e>
  20b74a:	e9 51 fd ff ff       	jmp    20b4a0 <BmSimple.lfence+0x110>
  20b74f:	90                   	nop
  20b750:	c5 fa 6f 05 b8 4b ff 	vmovdqu xmm0,XMMWORD PTR [rip+0xffffffffffff4bb8]        # 200310 <__unnamed_35>
  20b757:	ff 
  20b758:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
                if (errno != 0) return std.os.unexpectedErrorPosix(errno);
  20b75e:	0f 82 d3 fd ff ff    	jb     20b537 <BmSimple.lfence+0x1a7>
  20b764:	e9 26 07 00 00       	jmp    20be8f <BmSimple.lfence+0xaff>
  20b769:	c5 f9 6f 8c 24 c0 00 	vmovdqa xmm1,XMMWORD PTR [rsp+0xc0]
  20b770:	00 00 
  20b772:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
  20b778:	0f 82 39 fe ff ff    	jb     20b5b7 <BmSimple.lfence+0x227>
  20b77e:	e9 25 07 00 00       	jmp    20bea8 <BmSimple.lfence+0xb18>
                            Result { .run_time_ns = run_time_ns, .iterations = iterations});
  20b783:	48 89 ac 24 e8 00 00 	mov    QWORD PTR [rsp+0xe8],rbp
  20b78a:	00 
  20b78b:	48 89 9c 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rbx
  20b792:	00 
                    try pSelf.results.append(
  20b793:	48 8d 7c 24 68       	lea    rdi,[rsp+0x68]
  20b798:	48 8d b4 24 e8 00 00 	lea    rsi,[rsp+0xe8]
  20b79f:	00 
  20b7a0:	c5 f8 77             	vzeroupper 
  20b7a3:	e8 08 76 00 00       	call   212db0 <AlignedArrayList(Result,8)_append>
  20b7a8:	66 85 c0             	test   ax,ax
  20b7ab:	74 16                	je     20b7c3 <BmSimple.lfence+0x433>
  20b7ad:	e9 e1 06 00 00       	jmp    20be93 <BmSimple.lfence+0xb03>
            while (iterations <= pSelf.max_iterations) {
  20b7b2:	4c 8b 7c 24 48       	mov    r15,QWORD PTR [rsp+0x48]
  20b7b7:	45 31 f6             	xor    r14d,r14d
  20b7ba:	4c 39 fb             	cmp    rbx,r15
  20b7bd:	0f 86 eb fc ff ff    	jbe    20b4ae <BmSimple.lfence+0x11e>
            if (once) {
  20b7c3:	41 f6 c6 01          	test   r14b,0x1
  20b7c7:	48 8d 6c 24 0f       	lea    rbp,[rsp+0xf]
  20b7cc:	4c 8d 74 24 10       	lea    r14,[rsp+0x10]
  20b7d1:	0f 84 e0 05 00 00    	je     20bdb7 <BmSimple.lfence+0xa27>
                try leftJustified(22, "name repetitions:{}", pSelf.repetitions);
  20b7d7:	48 8b 7c 24 40       	mov    rdi,QWORD PTR [rsp+0x40]
  20b7dc:	c5 f8 77             	vzeroupper 
  20b7df:	e8 bc 9b 00 00       	call   2153a0 <Benchmark_leftJustified>
  20b7e4:	66 85 c0             	test   ax,ax
  20b7e7:	0f 85 a6 06 00 00    	jne    20be93 <BmSimple.lfence+0xb03>
                try rightJustified(14, "{}", "iterations");
  20b7ed:	e8 4e 9e 00 00       	call   215640 <Benchmark_rightJustified>
  20b7f2:	66 85 c0             	test   ax,ax
  20b7f5:	0f 85 98 06 00 00    	jne    20be93 <BmSimple.lfence+0xb03>
        var buffer: [40]u8 = undefined;
  20b7fb:	c5 fe 6f 05 4c a7 ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffffa74c]        # 205f4f <__unnamed_7>
  20b802:	ff 
  20b803:	c5 fe 7f 84 24 90 00 	vmovdqu YMMWORD PTR [rsp+0x90],ymm0
  20b80a:	00 00 
  20b80c:	48 8b 05 5c a7 ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffffa75c]        # 205f6f <__unnamed_7+0x20>
  20b813:	48 89 84 24 b0 00 00 	mov    QWORD PTR [rsp+0xb0],rax
  20b81a:	00 
  20b81b:	c7 84 24 90 00 00 00 	mov    DWORD PTR [rsp+0x90],0x656d6974
  20b822:	74 69 6d 65 
  20b826:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  20b82d:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20b830:	b0 01                	mov    al,0x1
  20b832:	86 05 d8 57 04 00    	xchg   BYTE PTR [rip+0x457d8],al        # 251010 <stderr_mutex>
  20b838:	84 c0                	test   al,al
  20b83a:	75 f4                	jne    20b830 <BmSimple.lfence+0x4a0>
    if (stderr_stream) |st| {
  20b83c:	48 8b 3d c5 57 04 00 	mov    rdi,QWORD PTR [rip+0x457c5]        # 251008 <stderr_stream>
  20b843:	48 85 ff             	test   rdi,rdi
  20b846:	74 09                	je     20b851 <BmSimple.lfence+0x4c1>
  20b848:	48 8b 0d f1 07 04 00 	mov    rcx,QWORD PTR [rip+0x407f1]        # 24c040 <stderr_file_out_stream+0x8>
  20b84f:	eb 3d                	jmp    20b88e <BmSimple.lfence+0x4fe>
        stderr_file = try io.getStdErr();
  20b851:	c7 05 d5 07 04 00 02 	mov    DWORD PTR [rip+0x407d5],0x2        # 24c030 <stderr_file>
  20b858:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20b85b:	48 8d 05 ce 07 04 00 	lea    rax,[rip+0x407ce]        # 24c030 <stderr_file>
  20b862:	48 89 05 cf 07 04 00 	mov    QWORD PTR [rip+0x407cf],rax        # 24c038 <stderr_file_out_stream>
  20b869:	48 8d 05 30 36 01 00 	lea    rax,[rip+0x13630]        # 21eea0 <FileOutStream_writeFn>
  20b870:	48 89 05 c9 07 04 00 	mov    QWORD PTR [rip+0x407c9],rax        # 24c040 <stderr_file_out_stream+0x8>
  20b877:	48 8d 0d c2 07 04 00 	lea    rcx,[rip+0x407c2]        # 24c040 <stderr_file_out_stream+0x8>
  20b87e:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20b881:	48 89 15 80 57 04 00 	mov    QWORD PTR [rip+0x45780],rdx        # 251008 <stderr_stream>
  20b888:	48 89 c1             	mov    rcx,rax
  20b88b:	48 89 d7             	mov    rdi,rdx
  20b88e:	c6 44 24 0f 20       	mov    BYTE PTR [rsp+0xf],0x20
    return output(context, (*[1]u8)(&c)[0..]);
  20b893:	48 89 6c 24 10       	mov    QWORD PTR [rsp+0x10],rbp
  20b898:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  20b89f:	00 00 
  20b8a1:	4c 89 f6             	mov    rsi,r14
  20b8a4:	c5 f8 77             	vzeroupper 
  20b8a7:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20b8a9:	31 c0                	xor    eax,eax
  20b8ab:	86 05 5f 57 04 00    	xchg   BYTE PTR [rip+0x4575f],al        # 251010 <stderr_mutex>
  20b8b1:	3c 01                	cmp    al,0x1
    if (!ok) {
  20b8b3:	0f 85 ef 05 00 00    	jne    20bea8 <BmSimple.lfence+0xb18>
  20b8b9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20b8c0:	b0 01                	mov    al,0x1
  20b8c2:	86 05 48 57 04 00    	xchg   BYTE PTR [rip+0x45748],al        # 251010 <stderr_mutex>
  20b8c8:	84 c0                	test   al,al
  20b8ca:	75 f4                	jne    20b8c0 <BmSimple.lfence+0x530>
    if (stderr_stream) |st| {
  20b8cc:	48 8b 3d 35 57 04 00 	mov    rdi,QWORD PTR [rip+0x45735]        # 251008 <stderr_stream>
  20b8d3:	48 85 ff             	test   rdi,rdi
  20b8d6:	74 09                	je     20b8e1 <BmSimple.lfence+0x551>
  20b8d8:	48 8b 0d 61 07 04 00 	mov    rcx,QWORD PTR [rip+0x40761]        # 24c040 <stderr_file_out_stream+0x8>
  20b8df:	eb 3d                	jmp    20b91e <BmSimple.lfence+0x58e>
        stderr_file = try io.getStdErr();
  20b8e1:	c7 05 45 07 04 00 02 	mov    DWORD PTR [rip+0x40745],0x2        # 24c030 <stderr_file>
  20b8e8:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20b8eb:	48 8d 05 3e 07 04 00 	lea    rax,[rip+0x4073e]        # 24c030 <stderr_file>
  20b8f2:	48 89 05 3f 07 04 00 	mov    QWORD PTR [rip+0x4073f],rax        # 24c038 <stderr_file_out_stream>
  20b8f9:	48 8d 05 a0 35 01 00 	lea    rax,[rip+0x135a0]        # 21eea0 <FileOutStream_writeFn>
  20b900:	48 89 05 39 07 04 00 	mov    QWORD PTR [rip+0x40739],rax        # 24c040 <stderr_file_out_stream+0x8>
  20b907:	48 8d 0d 32 07 04 00 	lea    rcx,[rip+0x40732]        # 24c040 <stderr_file_out_stream+0x8>
  20b90e:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20b911:	48 89 15 f0 56 04 00 	mov    QWORD PTR [rip+0x456f0],rdx        # 251008 <stderr_stream>
  20b918:	48 89 c1             	mov    rcx,rax
  20b91b:	48 89 d7             	mov    rdi,rdx
  20b91e:	c6 44 24 0f 20       	mov    BYTE PTR [rsp+0xf],0x20
  20b923:	48 89 6c 24 10       	mov    QWORD PTR [rsp+0x10],rbp
  20b928:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  20b92f:	00 00 
  20b931:	4c 89 f6             	mov    rsi,r14
  20b934:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20b936:	31 c0                	xor    eax,eax
  20b938:	86 05 d2 56 04 00    	xchg   BYTE PTR [rip+0x456d2],al        # 251010 <stderr_mutex>
  20b93e:	3c 01                	cmp    al,0x1
    if (!ok) {
  20b940:	0f 85 62 05 00 00    	jne    20bea8 <BmSimple.lfence+0xb18>
  20b946:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  20b94d:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20b950:	b0 01                	mov    al,0x1
  20b952:	86 05 b8 56 04 00    	xchg   BYTE PTR [rip+0x456b8],al        # 251010 <stderr_mutex>
  20b958:	84 c0                	test   al,al
  20b95a:	75 f4                	jne    20b950 <BmSimple.lfence+0x5c0>
    if (stderr_stream) |st| {
  20b95c:	48 8b 3d a5 56 04 00 	mov    rdi,QWORD PTR [rip+0x456a5]        # 251008 <stderr_stream>
  20b963:	48 85 ff             	test   rdi,rdi
  20b966:	74 09                	je     20b971 <BmSimple.lfence+0x5e1>
  20b968:	48 8b 0d d1 06 04 00 	mov    rcx,QWORD PTR [rip+0x406d1]        # 24c040 <stderr_file_out_stream+0x8>
  20b96f:	eb 3d                	jmp    20b9ae <BmSimple.lfence+0x61e>
        stderr_file = try io.getStdErr();
  20b971:	c7 05 b5 06 04 00 02 	mov    DWORD PTR [rip+0x406b5],0x2        # 24c030 <stderr_file>
  20b978:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20b97b:	48 8d 05 ae 06 04 00 	lea    rax,[rip+0x406ae]        # 24c030 <stderr_file>
  20b982:	48 89 05 af 06 04 00 	mov    QWORD PTR [rip+0x406af],rax        # 24c038 <stderr_file_out_stream>
  20b989:	48 8d 05 10 35 01 00 	lea    rax,[rip+0x13510]        # 21eea0 <FileOutStream_writeFn>
  20b990:	48 89 05 a9 06 04 00 	mov    QWORD PTR [rip+0x406a9],rax        # 24c040 <stderr_file_out_stream+0x8>
  20b997:	48 8d 0d a2 06 04 00 	lea    rcx,[rip+0x406a2]        # 24c040 <stderr_file_out_stream+0x8>
  20b99e:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20b9a1:	48 89 15 60 56 04 00 	mov    QWORD PTR [rip+0x45660],rdx        # 251008 <stderr_stream>
  20b9a8:	48 89 c1             	mov    rcx,rax
  20b9ab:	48 89 d7             	mov    rdi,rdx
  20b9ae:	c6 44 24 0f 20       	mov    BYTE PTR [rsp+0xf],0x20
  20b9b3:	48 89 6c 24 10       	mov    QWORD PTR [rsp+0x10],rbp
  20b9b8:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  20b9bf:	00 00 
  20b9c1:	4c 89 f6             	mov    rsi,r14
  20b9c4:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20b9c6:	31 c0                	xor    eax,eax
  20b9c8:	86 05 42 56 04 00    	xchg   BYTE PTR [rip+0x45642],al        # 251010 <stderr_mutex>
  20b9ce:	3c 01                	cmp    al,0x1
    if (!ok) {
  20b9d0:	0f 85 d2 04 00 00    	jne    20bea8 <BmSimple.lfence+0xb18>
  20b9d6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  20b9dd:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20b9e0:	b0 01                	mov    al,0x1
  20b9e2:	86 05 28 56 04 00    	xchg   BYTE PTR [rip+0x45628],al        # 251010 <stderr_mutex>
  20b9e8:	84 c0                	test   al,al
  20b9ea:	75 f4                	jne    20b9e0 <BmSimple.lfence+0x650>
    if (stderr_stream) |st| {
  20b9ec:	48 8b 3d 15 56 04 00 	mov    rdi,QWORD PTR [rip+0x45615]        # 251008 <stderr_stream>
  20b9f3:	48 85 ff             	test   rdi,rdi
  20b9f6:	74 09                	je     20ba01 <BmSimple.lfence+0x671>
  20b9f8:	48 8b 0d 41 06 04 00 	mov    rcx,QWORD PTR [rip+0x40641]        # 24c040 <stderr_file_out_stream+0x8>
  20b9ff:	eb 3d                	jmp    20ba3e <BmSimple.lfence+0x6ae>
        stderr_file = try io.getStdErr();
  20ba01:	c7 05 25 06 04 00 02 	mov    DWORD PTR [rip+0x40625],0x2        # 24c030 <stderr_file>
  20ba08:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20ba0b:	48 8d 05 1e 06 04 00 	lea    rax,[rip+0x4061e]        # 24c030 <stderr_file>
  20ba12:	48 89 05 1f 06 04 00 	mov    QWORD PTR [rip+0x4061f],rax        # 24c038 <stderr_file_out_stream>
  20ba19:	48 8d 05 80 34 01 00 	lea    rax,[rip+0x13480]        # 21eea0 <FileOutStream_writeFn>
  20ba20:	48 89 05 19 06 04 00 	mov    QWORD PTR [rip+0x40619],rax        # 24c040 <stderr_file_out_stream+0x8>
  20ba27:	48 8d 0d 12 06 04 00 	lea    rcx,[rip+0x40612]        # 24c040 <stderr_file_out_stream+0x8>
  20ba2e:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20ba31:	48 89 15 d0 55 04 00 	mov    QWORD PTR [rip+0x455d0],rdx        # 251008 <stderr_stream>
  20ba38:	48 89 c1             	mov    rcx,rax
  20ba3b:	48 89 d7             	mov    rdi,rdx
  20ba3e:	c6 44 24 0f 20       	mov    BYTE PTR [rsp+0xf],0x20
  20ba43:	48 89 6c 24 10       	mov    QWORD PTR [rsp+0x10],rbp
  20ba48:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  20ba4f:	00 00 
  20ba51:	4c 89 f6             	mov    rsi,r14
  20ba54:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20ba56:	31 c0                	xor    eax,eax
  20ba58:	86 05 b2 55 04 00    	xchg   BYTE PTR [rip+0x455b2],al        # 251010 <stderr_mutex>
  20ba5e:	3c 01                	cmp    al,0x1
    if (!ok) {
  20ba60:	0f 85 42 04 00 00    	jne    20bea8 <BmSimple.lfence+0xb18>
  20ba66:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  20ba6d:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20ba70:	b0 01                	mov    al,0x1
  20ba72:	86 05 98 55 04 00    	xchg   BYTE PTR [rip+0x45598],al        # 251010 <stderr_mutex>
  20ba78:	84 c0                	test   al,al
  20ba7a:	75 f4                	jne    20ba70 <BmSimple.lfence+0x6e0>
    if (stderr_stream) |st| {
  20ba7c:	48 8b 3d 85 55 04 00 	mov    rdi,QWORD PTR [rip+0x45585]        # 251008 <stderr_stream>
  20ba83:	48 85 ff             	test   rdi,rdi
  20ba86:	74 09                	je     20ba91 <BmSimple.lfence+0x701>
  20ba88:	48 8b 0d b1 05 04 00 	mov    rcx,QWORD PTR [rip+0x405b1]        # 24c040 <stderr_file_out_stream+0x8>
  20ba8f:	eb 3d                	jmp    20bace <BmSimple.lfence+0x73e>
        stderr_file = try io.getStdErr();
  20ba91:	c7 05 95 05 04 00 02 	mov    DWORD PTR [rip+0x40595],0x2        # 24c030 <stderr_file>
  20ba98:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20ba9b:	48 8d 05 8e 05 04 00 	lea    rax,[rip+0x4058e]        # 24c030 <stderr_file>
  20baa2:	48 89 05 8f 05 04 00 	mov    QWORD PTR [rip+0x4058f],rax        # 24c038 <stderr_file_out_stream>
  20baa9:	48 8d 05 f0 33 01 00 	lea    rax,[rip+0x133f0]        # 21eea0 <FileOutStream_writeFn>
  20bab0:	48 89 05 89 05 04 00 	mov    QWORD PTR [rip+0x40589],rax        # 24c040 <stderr_file_out_stream+0x8>
  20bab7:	48 8d 0d 82 05 04 00 	lea    rcx,[rip+0x40582]        # 24c040 <stderr_file_out_stream+0x8>
  20babe:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20bac1:	48 89 15 40 55 04 00 	mov    QWORD PTR [rip+0x45540],rdx        # 251008 <stderr_stream>
  20bac8:	48 89 c1             	mov    rcx,rax
  20bacb:	48 89 d7             	mov    rdi,rdx
  20bace:	c6 44 24 0f 20       	mov    BYTE PTR [rsp+0xf],0x20
  20bad3:	48 89 6c 24 10       	mov    QWORD PTR [rsp+0x10],rbp
  20bad8:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  20badf:	00 00 
  20bae1:	4c 89 f6             	mov    rsi,r14
  20bae4:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20bae6:	31 c0                	xor    eax,eax
  20bae8:	86 05 22 55 04 00    	xchg   BYTE PTR [rip+0x45522],al        # 251010 <stderr_mutex>
  20baee:	3c 01                	cmp    al,0x1
    if (!ok) {
  20baf0:	0f 85 b2 03 00 00    	jne    20bea8 <BmSimple.lfence+0xb18>
  20baf6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  20bafd:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20bb00:	b0 01                	mov    al,0x1
  20bb02:	86 05 08 55 04 00    	xchg   BYTE PTR [rip+0x45508],al        # 251010 <stderr_mutex>
  20bb08:	84 c0                	test   al,al
  20bb0a:	75 f4                	jne    20bb00 <BmSimple.lfence+0x770>
    if (stderr_stream) |st| {
  20bb0c:	48 8b 3d f5 54 04 00 	mov    rdi,QWORD PTR [rip+0x454f5]        # 251008 <stderr_stream>
  20bb13:	48 85 ff             	test   rdi,rdi
  20bb16:	74 09                	je     20bb21 <BmSimple.lfence+0x791>
  20bb18:	48 8b 0d 21 05 04 00 	mov    rcx,QWORD PTR [rip+0x40521]        # 24c040 <stderr_file_out_stream+0x8>
  20bb1f:	eb 3d                	jmp    20bb5e <BmSimple.lfence+0x7ce>
        stderr_file = try io.getStdErr();
  20bb21:	c7 05 05 05 04 00 02 	mov    DWORD PTR [rip+0x40505],0x2        # 24c030 <stderr_file>
  20bb28:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20bb2b:	48 8d 05 fe 04 04 00 	lea    rax,[rip+0x404fe]        # 24c030 <stderr_file>
  20bb32:	48 89 05 ff 04 04 00 	mov    QWORD PTR [rip+0x404ff],rax        # 24c038 <stderr_file_out_stream>
  20bb39:	48 8d 05 60 33 01 00 	lea    rax,[rip+0x13360]        # 21eea0 <FileOutStream_writeFn>
  20bb40:	48 89 05 f9 04 04 00 	mov    QWORD PTR [rip+0x404f9],rax        # 24c040 <stderr_file_out_stream+0x8>
  20bb47:	48 8d 0d f2 04 04 00 	lea    rcx,[rip+0x404f2]        # 24c040 <stderr_file_out_stream+0x8>
  20bb4e:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20bb51:	48 89 15 b0 54 04 00 	mov    QWORD PTR [rip+0x454b0],rdx        # 251008 <stderr_stream>
  20bb58:	48 89 c1             	mov    rcx,rax
  20bb5b:	48 89 d7             	mov    rdi,rdx
  20bb5e:	c6 44 24 0f 20       	mov    BYTE PTR [rsp+0xf],0x20
  20bb63:	48 89 6c 24 10       	mov    QWORD PTR [rsp+0x10],rbp
  20bb68:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  20bb6f:	00 00 
  20bb71:	4c 89 f6             	mov    rsi,r14
  20bb74:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20bb76:	31 c0                	xor    eax,eax
  20bb78:	86 05 92 54 04 00    	xchg   BYTE PTR [rip+0x45492],al        # 251010 <stderr_mutex>
  20bb7e:	3c 01                	cmp    al,0x1
    if (!ok) {
  20bb80:	0f 85 22 03 00 00    	jne    20bea8 <BmSimple.lfence+0xb18>
  20bb86:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  20bb8d:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20bb90:	b0 01                	mov    al,0x1
  20bb92:	86 05 78 54 04 00    	xchg   BYTE PTR [rip+0x45478],al        # 251010 <stderr_mutex>
  20bb98:	84 c0                	test   al,al
  20bb9a:	75 f4                	jne    20bb90 <BmSimple.lfence+0x800>
    if (stderr_stream) |st| {
  20bb9c:	48 8b 3d 65 54 04 00 	mov    rdi,QWORD PTR [rip+0x45465]        # 251008 <stderr_stream>
  20bba3:	48 85 ff             	test   rdi,rdi
  20bba6:	74 09                	je     20bbb1 <BmSimple.lfence+0x821>
  20bba8:	48 8b 0d 91 04 04 00 	mov    rcx,QWORD PTR [rip+0x40491]        # 24c040 <stderr_file_out_stream+0x8>
  20bbaf:	eb 3d                	jmp    20bbee <BmSimple.lfence+0x85e>
        stderr_file = try io.getStdErr();
  20bbb1:	c7 05 75 04 04 00 02 	mov    DWORD PTR [rip+0x40475],0x2        # 24c030 <stderr_file>
  20bbb8:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20bbbb:	48 8d 05 6e 04 04 00 	lea    rax,[rip+0x4046e]        # 24c030 <stderr_file>
  20bbc2:	48 89 05 6f 04 04 00 	mov    QWORD PTR [rip+0x4046f],rax        # 24c038 <stderr_file_out_stream>
  20bbc9:	48 8d 05 d0 32 01 00 	lea    rax,[rip+0x132d0]        # 21eea0 <FileOutStream_writeFn>
  20bbd0:	48 89 05 69 04 04 00 	mov    QWORD PTR [rip+0x40469],rax        # 24c040 <stderr_file_out_stream+0x8>
  20bbd7:	48 8d 0d 62 04 04 00 	lea    rcx,[rip+0x40462]        # 24c040 <stderr_file_out_stream+0x8>
  20bbde:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20bbe1:	48 89 15 20 54 04 00 	mov    QWORD PTR [rip+0x45420],rdx        # 251008 <stderr_stream>
  20bbe8:	48 89 c1             	mov    rcx,rax
  20bbeb:	48 89 d7             	mov    rdi,rdx
  20bbee:	c6 44 24 0f 20       	mov    BYTE PTR [rsp+0xf],0x20
  20bbf3:	48 89 6c 24 10       	mov    QWORD PTR [rsp+0x10],rbp
  20bbf8:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  20bbff:	00 00 
  20bc01:	4c 89 f6             	mov    rsi,r14
  20bc04:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20bc06:	31 c0                	xor    eax,eax
  20bc08:	86 05 02 54 04 00    	xchg   BYTE PTR [rip+0x45402],al        # 251010 <stderr_mutex>
  20bc0e:	3c 01                	cmp    al,0x1
    if (!ok) {
  20bc10:	0f 85 92 02 00 00    	jne    20bea8 <BmSimple.lfence+0xb18>
  20bc16:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  20bc1d:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20bc20:	b0 01                	mov    al,0x1
  20bc22:	86 05 e8 53 04 00    	xchg   BYTE PTR [rip+0x453e8],al        # 251010 <stderr_mutex>
  20bc28:	84 c0                	test   al,al
  20bc2a:	75 f4                	jne    20bc20 <BmSimple.lfence+0x890>
    if (stderr_stream) |st| {
  20bc2c:	48 8b 3d d5 53 04 00 	mov    rdi,QWORD PTR [rip+0x453d5]        # 251008 <stderr_stream>
  20bc33:	48 85 ff             	test   rdi,rdi
  20bc36:	74 09                	je     20bc41 <BmSimple.lfence+0x8b1>
  20bc38:	48 8b 0d 01 04 04 00 	mov    rcx,QWORD PTR [rip+0x40401]        # 24c040 <stderr_file_out_stream+0x8>
  20bc3f:	eb 3d                	jmp    20bc7e <BmSimple.lfence+0x8ee>
        stderr_file = try io.getStdErr();
  20bc41:	c7 05 e5 03 04 00 02 	mov    DWORD PTR [rip+0x403e5],0x2        # 24c030 <stderr_file>
  20bc48:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20bc4b:	48 8d 05 de 03 04 00 	lea    rax,[rip+0x403de]        # 24c030 <stderr_file>
  20bc52:	48 89 05 df 03 04 00 	mov    QWORD PTR [rip+0x403df],rax        # 24c038 <stderr_file_out_stream>
  20bc59:	48 8d 05 40 32 01 00 	lea    rax,[rip+0x13240]        # 21eea0 <FileOutStream_writeFn>
  20bc60:	48 89 05 d9 03 04 00 	mov    QWORD PTR [rip+0x403d9],rax        # 24c040 <stderr_file_out_stream+0x8>
  20bc67:	48 8d 0d d2 03 04 00 	lea    rcx,[rip+0x403d2]        # 24c040 <stderr_file_out_stream+0x8>
  20bc6e:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20bc71:	48 89 15 90 53 04 00 	mov    QWORD PTR [rip+0x45390],rdx        # 251008 <stderr_stream>
  20bc78:	48 89 c1             	mov    rcx,rax
  20bc7b:	48 89 d7             	mov    rdi,rdx
  20bc7e:	c6 44 24 0f 20       	mov    BYTE PTR [rsp+0xf],0x20
  20bc83:	48 89 6c 24 10       	mov    QWORD PTR [rsp+0x10],rbp
  20bc88:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  20bc8f:	00 00 
  20bc91:	4c 89 f6             	mov    rsi,r14
  20bc94:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20bc96:	31 c0                	xor    eax,eax
  20bc98:	86 05 72 53 04 00    	xchg   BYTE PTR [rip+0x45372],al        # 251010 <stderr_mutex>
  20bc9e:	3c 01                	cmp    al,0x1
    if (!ok) {
  20bca0:	0f 85 02 02 00 00    	jne    20bea8 <BmSimple.lfence+0xb18>
  20bca6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  20bcad:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20bcb0:	b0 01                	mov    al,0x1
  20bcb2:	86 05 58 53 04 00    	xchg   BYTE PTR [rip+0x45358],al        # 251010 <stderr_mutex>
  20bcb8:	84 c0                	test   al,al
  20bcba:	75 f4                	jne    20bcb0 <BmSimple.lfence+0x920>
    if (stderr_stream) |st| {
  20bcbc:	48 8b 3d 45 53 04 00 	mov    rdi,QWORD PTR [rip+0x45345]        # 251008 <stderr_stream>
  20bcc3:	48 85 ff             	test   rdi,rdi
  20bcc6:	74 09                	je     20bcd1 <BmSimple.lfence+0x941>
  20bcc8:	48 8b 0d 71 03 04 00 	mov    rcx,QWORD PTR [rip+0x40371]        # 24c040 <stderr_file_out_stream+0x8>
  20bccf:	eb 3d                	jmp    20bd0e <BmSimple.lfence+0x97e>
        stderr_file = try io.getStdErr();
  20bcd1:	c7 05 55 03 04 00 02 	mov    DWORD PTR [rip+0x40355],0x2        # 24c030 <stderr_file>
  20bcd8:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20bcdb:	48 8d 05 4e 03 04 00 	lea    rax,[rip+0x4034e]        # 24c030 <stderr_file>
  20bce2:	48 89 05 4f 03 04 00 	mov    QWORD PTR [rip+0x4034f],rax        # 24c038 <stderr_file_out_stream>
  20bce9:	48 8d 05 b0 31 01 00 	lea    rax,[rip+0x131b0]        # 21eea0 <FileOutStream_writeFn>
  20bcf0:	48 89 05 49 03 04 00 	mov    QWORD PTR [rip+0x40349],rax        # 24c040 <stderr_file_out_stream+0x8>
  20bcf7:	48 8d 0d 42 03 04 00 	lea    rcx,[rip+0x40342]        # 24c040 <stderr_file_out_stream+0x8>
  20bcfe:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20bd01:	48 89 15 00 53 04 00 	mov    QWORD PTR [rip+0x45300],rdx        # 251008 <stderr_stream>
  20bd08:	48 89 c1             	mov    rcx,rax
  20bd0b:	48 89 d7             	mov    rdi,rdx
                const casted_value = ([]const u8)(value);
  20bd0e:	4c 89 64 24 10       	mov    QWORD PTR [rsp+0x10],r12
  20bd13:	48 c7 44 24 18 04 00 	mov    QWORD PTR [rsp+0x18],0x4
  20bd1a:	00 00 
                return output(context, casted_value);
  20bd1c:	4c 89 f6             	mov    rsi,r14
  20bd1f:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20bd21:	31 c0                	xor    eax,eax
  20bd23:	86 05 e7 52 04 00    	xchg   BYTE PTR [rip+0x452e7],al        # 251010 <stderr_mutex>
  20bd29:	3c 01                	cmp    al,0x1
    if (!ok) {
  20bd2b:	0f 85 77 01 00 00    	jne    20bea8 <BmSimple.lfence+0xb18>
                try rightJustified(18, "{}", "time/operation");
  20bd31:	e8 ea 9b 00 00       	call   215920 <Benchmark_rightJustified.39>
  20bd36:	66 85 c0             	test   ax,ax
  20bd39:	0f 85 54 01 00 00    	jne    20be93 <BmSimple.lfence+0xb03>
  20bd3f:	90                   	nop
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20bd40:	b0 01                	mov    al,0x1
  20bd42:	86 05 c8 52 04 00    	xchg   BYTE PTR [rip+0x452c8],al        # 251010 <stderr_mutex>
  20bd48:	84 c0                	test   al,al
  20bd4a:	75 f4                	jne    20bd40 <BmSimple.lfence+0x9b0>
    if (stderr_stream) |st| {
  20bd4c:	48 8b 3d b5 52 04 00 	mov    rdi,QWORD PTR [rip+0x452b5]        # 251008 <stderr_stream>
  20bd53:	48 85 ff             	test   rdi,rdi
  20bd56:	74 09                	je     20bd61 <BmSimple.lfence+0x9d1>
  20bd58:	48 8b 0d e1 02 04 00 	mov    rcx,QWORD PTR [rip+0x402e1]        # 24c040 <stderr_file_out_stream+0x8>
  20bd5f:	eb 3d                	jmp    20bd9e <BmSimple.lfence+0xa0e>
        stderr_file = try io.getStdErr();
  20bd61:	c7 05 c5 02 04 00 02 	mov    DWORD PTR [rip+0x402c5],0x2        # 24c030 <stderr_file>
  20bd68:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20bd6b:	48 8d 05 be 02 04 00 	lea    rax,[rip+0x402be]        # 24c030 <stderr_file>
  20bd72:	48 89 05 bf 02 04 00 	mov    QWORD PTR [rip+0x402bf],rax        # 24c038 <stderr_file_out_stream>
  20bd79:	48 8d 05 20 31 01 00 	lea    rax,[rip+0x13120]        # 21eea0 <FileOutStream_writeFn>
  20bd80:	48 89 05 b9 02 04 00 	mov    QWORD PTR [rip+0x402b9],rax        # 24c040 <stderr_file_out_stream+0x8>
  20bd87:	48 8d 0d b2 02 04 00 	lea    rcx,[rip+0x402b2]        # 24c040 <stderr_file_out_stream+0x8>
  20bd8e:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20bd91:	48 89 15 70 52 04 00 	mov    QWORD PTR [rip+0x45270],rdx        # 251008 <stderr_stream>
  20bd98:	48 89 c1             	mov    rcx,rax
  20bd9b:	48 89 d7             	mov    rdi,rdx
        try output(context, fmt[start_index..]);
  20bd9e:	48 8d 35 4b 41 04 00 	lea    rsi,[rip+0x4414b]        # 24fef0 <__unnamed_3>
  20bda5:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20bda7:	31 c0                	xor    eax,eax
  20bda9:	86 05 61 52 04 00    	xchg   BYTE PTR [rip+0x45261],al        # 251010 <stderr_mutex>
  20bdaf:	3c 01                	cmp    al,0x1
    if (!ok) {
  20bdb1:	0f 85 f1 00 00 00    	jne    20bea8 <BmSimple.lfence+0xb18>
            try pSelf.report(pSelf.results.items[pSelf.results.len - 1]); warn("\n");
  20bdb7:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  20bdbc:	48 8b 4c 24 78       	mov    rcx,QWORD PTR [rsp+0x78]
  20bdc1:	48 c1 e1 04          	shl    rcx,0x4
  20bdc5:	48 8d 34 08          	lea    rsi,[rax+rcx*1]
  20bdc9:	48 83 c6 f0          	add    rsi,0xfffffffffffffff0
  20bdcd:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  20bdd2:	c5 f8 77             	vzeroupper 
  20bdd5:	e8 46 71 00 00       	call   212f20 <Benchmark_report>
  20bdda:	66 85 c0             	test   ax,ax
  20bddd:	0f 85 b0 00 00 00    	jne    20be93 <BmSimple.lfence+0xb03>
  20bde3:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20bdea:	84 00 00 00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20bdf0:	b0 01                	mov    al,0x1
  20bdf2:	86 05 18 52 04 00    	xchg   BYTE PTR [rip+0x45218],al        # 251010 <stderr_mutex>
  20bdf8:	84 c0                	test   al,al
  20bdfa:	75 f4                	jne    20bdf0 <BmSimple.lfence+0xa60>
    if (stderr_stream) |st| {
  20bdfc:	48 8b 3d 05 52 04 00 	mov    rdi,QWORD PTR [rip+0x45205]        # 251008 <stderr_stream>
  20be03:	48 85 ff             	test   rdi,rdi
  20be06:	74 09                	je     20be11 <BmSimple.lfence+0xa81>
  20be08:	48 8b 0d 31 02 04 00 	mov    rcx,QWORD PTR [rip+0x40231]        # 24c040 <stderr_file_out_stream+0x8>
  20be0f:	eb 3d                	jmp    20be4e <BmSimple.lfence+0xabe>
        stderr_file = try io.getStdErr();
  20be11:	c7 05 15 02 04 00 02 	mov    DWORD PTR [rip+0x40215],0x2        # 24c030 <stderr_file>
  20be18:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20be1b:	48 8d 05 0e 02 04 00 	lea    rax,[rip+0x4020e]        # 24c030 <stderr_file>
  20be22:	48 89 05 0f 02 04 00 	mov    QWORD PTR [rip+0x4020f],rax        # 24c038 <stderr_file_out_stream>
  20be29:	48 8d 05 70 30 01 00 	lea    rax,[rip+0x13070]        # 21eea0 <FileOutStream_writeFn>
  20be30:	48 89 05 09 02 04 00 	mov    QWORD PTR [rip+0x40209],rax        # 24c040 <stderr_file_out_stream+0x8>
  20be37:	48 8d 0d 02 02 04 00 	lea    rcx,[rip+0x40202]        # 24c040 <stderr_file_out_stream+0x8>
  20be3e:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20be41:	48 89 15 c0 51 04 00 	mov    QWORD PTR [rip+0x451c0],rdx        # 251008 <stderr_stream>
  20be48:	48 89 c1             	mov    rcx,rax
  20be4b:	48 89 d7             	mov    rdi,rdx
  20be4e:	48 8d 35 9b 40 04 00 	lea    rsi,[rip+0x4409b]        # 24fef0 <__unnamed_3>
  20be55:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20be57:	31 c0                	xor    eax,eax
  20be59:	86 05 b1 51 04 00    	xchg   BYTE PTR [rip+0x451b1],al        # 251010 <stderr_mutex>
  20be5f:	3c 01                	cmp    al,0x1
    if (!ok) {
  20be61:	75 45                	jne    20bea8 <BmSimple.lfence+0xb18>
  20be63:	49 83 c5 01          	add    r13,0x1
        while (rep < pSelf.repetitions) : (rep += 1) {
  20be67:	4c 3b 6c 24 40       	cmp    r13,QWORD PTR [rsp+0x40]
  20be6c:	0f 82 40 f9 ff ff    	jb     20b7b2 <BmSimple.lfence+0x422>
  20be72:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
        try pSelf.reportStats(pSelf.results);
  20be77:	48 8d 74 24 68       	lea    rsi,[rsp+0x68]
  20be7c:	e8 7f 9d 00 00       	call   215c00 <Benchmark_reportStats>
  20be81:	eb 10                	jmp    20be93 <BmSimple.lfence+0xb03>
                switch (errno) {
  20be83:	48 83 f9 16          	cmp    rcx,0x16
  20be87:	75 06                	jne    20be8f <BmSimple.lfence+0xaff>
  20be89:	66 b8 02 00          	mov    ax,0x2
  20be8d:	eb 04                	jmp    20be93 <BmSimple.lfence+0xb03>
  20be8f:	66 b8 03 00          	mov    ax,0x3
    _ = try bm.run(struct {
  20be93:	48 81 c4 f8 00 00 00 	add    rsp,0xf8
  20be9a:	5b                   	pop    rbx
  20be9b:	41 5c                	pop    r12
  20be9d:	41 5d                	pop    r13
  20be9f:	41 5e                	pop    r14
  20bea1:	41 5f                	pop    r15
  20bea3:	5d                   	pop    rbp
  20bea4:	c5 f8 77             	vzeroupper 
  20bea7:	c3                   	ret    
            @panic("assertion failure");
  20bea8:	48 8d 3d e1 3e 04 00 	lea    rdi,[rip+0x43ee1]        # 24fd90 <__unnamed_2>
  20beaf:	c5 f8 77             	vzeroupper 
  20beb2:	e8 69 68 00 00       	call   212720 <panic>
  20beb7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  20bebe:	00 00 

000000000020bec0 <BmSimple.sfence>:
            lfence();
        }
    });
}

test "BmSimple.sfence" {
  20bec0:	55                   	push   rbp
  20bec1:	41 57                	push   r15
  20bec3:	41 56                	push   r14
  20bec5:	41 55                	push   r13
  20bec7:	41 54                	push   r12
  20bec9:	53                   	push   rbx
  20beca:	48 81 ec f8 00 00 00 	sub    rsp,0xf8
  20bed1:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20bed8:	0f 1f 84 00 00 00 00 
  20bedf:	00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20bee0:	b0 01                	mov    al,0x1
  20bee2:	86 05 28 51 04 00    	xchg   BYTE PTR [rip+0x45128],al        # 251010 <stderr_mutex>
  20bee8:	84 c0                	test   al,al
  20beea:	75 f4                	jne    20bee0 <BmSimple.sfence+0x20>
    if (stderr_stream) |st| {
  20beec:	48 8b 3d 15 51 04 00 	mov    rdi,QWORD PTR [rip+0x45115]        # 251008 <stderr_stream>
  20bef3:	48 85 ff             	test   rdi,rdi
  20bef6:	74 09                	je     20bf01 <BmSimple.sfence+0x41>
  20bef8:	48 8b 05 41 01 04 00 	mov    rax,QWORD PTR [rip+0x40141]        # 24c040 <stderr_file_out_stream+0x8>
  20beff:	eb 34                	jmp    20bf35 <BmSimple.sfence+0x75>
        stderr_file = try io.getStdErr();
  20bf01:	48 8d 05 28 01 04 00 	lea    rax,[rip+0x40128]        # 24c030 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20bf08:	48 89 05 29 01 04 00 	mov    QWORD PTR [rip+0x40129],rax        # 24c038 <stderr_file_out_stream>
  20bf0f:	48 8d 05 8a 2f 01 00 	lea    rax,[rip+0x12f8a]        # 21eea0 <FileOutStream_writeFn>
  20bf16:	48 89 05 23 01 04 00 	mov    QWORD PTR [rip+0x40123],rax        # 24c040 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  20bf1d:	c7 05 09 01 04 00 02 	mov    DWORD PTR [rip+0x40109],0x2        # 24c030 <stderr_file>
  20bf24:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20bf27:	48 8d 3d 12 01 04 00 	lea    rdi,[rip+0x40112]        # 24c040 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  20bf2e:	48 89 3d d3 50 04 00 	mov    QWORD PTR [rip+0x450d3],rdi        # 251008 <stderr_stream>
  20bf35:	48 8d 35 b4 3f 04 00 	lea    rsi,[rip+0x43fb4]        # 24fef0 <__unnamed_3>
  20bf3c:	ff d0                	call   rax
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20bf3e:	31 c0                	xor    eax,eax
  20bf40:	86 05 ca 50 04 00    	xchg   BYTE PTR [rip+0x450ca],al        # 251010 <stderr_mutex>
  20bf46:	3c 01                	cmp    al,0x1
    if (!ok) {
  20bf48:	0f 85 8a 0a 00 00    	jne    20c9d8 <BmSimple.sfence+0xb18>
    // Since this is a test print a \n before we run
    warn("\n");

    // Create an instance of Benchmark and run
    var bm = Benchmark.init("BmSimple.sfence", std.debug.global_allocator);
  20bf4e:	c5 f8 10 05 aa 3d 04 	vmovups xmm0,XMMWORD PTR [rip+0x43daa]        # 24fd00 <__unnamed_9>
  20bf55:	00 
  20bf56:	c5 f8 29 44 24 20    	vmovaps XMMWORD PTR [rsp+0x20],xmm0
  20bf5c:	c5 fc 28 05 5c 42 ff 	vmovaps ymm0,YMMWORD PTR [rip+0xffffffffffff425c]        # 2001c0 <__unnamed_29-0x40>
  20bf63:	ff 
  20bf64:	c5 fc 11 44 24 30    	vmovups YMMWORD PTR [rsp+0x30],ymm0
  20bf6a:	c5 fa 6f 05 9e 43 ff 	vmovdqu xmm0,XMMWORD PTR [rip+0xffffffffffff439e]        # 200310 <__unnamed_35>
  20bf71:	ff 
  20bf72:	c5 f9 7f 44 24 50    	vmovdqa XMMWORD PTR [rsp+0x50],xmm0
  20bf78:	48 8d 05 81 00 04 00 	lea    rax,[rip+0x40081]        # 24c000 <global_fixed_allocator>
  20bf7f:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  20bf84:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  20bf88:	c5 fa 7f 44 24 68    	vmovdqu XMMWORD PTR [rsp+0x68],xmm0
  20bf8e:	48 c7 44 24 78 00 00 	mov    QWORD PTR [rsp+0x78],0x0
  20bf95:	00 00 
  20bf97:	48 89 84 24 80 00 00 	mov    QWORD PTR [rsp+0x80],rax
  20bf9e:	00 
  20bf9f:	41 b6 01             	mov    r14b,0x1
  20bfa2:	49 bf 00 e8 76 48 17 	movabs r15,0x174876e800
  20bfa9:	00 00 00 
  20bfac:	bb 01 00 00 00       	mov    ebx,0x1
  20bfb1:	4c 8d a4 24 90 00 00 	lea    r12,[rsp+0x90]
  20bfb8:	00 
  20bfb9:	45 31 ed             	xor    r13d,r13d
            while (iterations <= pSelf.max_iterations) {
  20bfbc:	4c 39 fb             	cmp    rbx,r15
  20bfbf:	0f 87 2e 03 00 00    	ja     20c2f3 <BmSimple.sfence+0x433>
  20bfc5:	eb 17                	jmp    20bfde <BmSimple.sfence+0x11e>
  20bfc7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  20bfce:	00 00 
                        warn("iteratons:{} numer:{} denom:{}\n", iterations, numer, denom);
  20bfd0:	48 89 df             	mov    rdi,rbx
  20bfd3:	48 89 ca             	mov    rdx,rcx
  20bfd6:	c5 f8 77             	vzeroupper 
  20bfd9:	e8 52 90 00 00       	call   215030 <warn.37>
                var ts: posix.timespec = undefined;
  20bfde:	c5 fa 6f 05 2a 43 ff 	vmovdqu xmm0,XMMWORD PTR [rip+0xffffffffffff432a]        # 200310 <__unnamed_35>
  20bfe5:	ff 
  20bfe6:	c5 f9 7f 84 24 90 00 	vmovdqa XMMWORD PTR [rsp+0x90],xmm0
  20bfed:	00 00 
  20bfef:	b8 e5 00 00 00       	mov    eax,0xe5
  20bff4:	bf 01 00 00 00       	mov    edi,0x1
  20bff9:	4c 89 e6             	mov    rsi,r12
  20bffc:	0f 05                	syscall 
  20bffe:	48 89 c1             	mov    rcx,rax
  20c001:	48 f7 d9             	neg    rcx
  20c004:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  20c00a:	b8 00 00 00 00       	mov    eax,0x0
  20c00f:	48 0f 46 c8          	cmovbe rcx,rax
                switch (errno) {
  20c013:	48 85 c9             	test   rcx,rcx
  20c016:	0f 85 97 09 00 00    	jne    20c9b3 <BmSimple.sfence+0xaf3>
        const f = @atomicLoad(@typeOf(init_vdso_clock_gettime), &vdso_clock_gettime, builtin.AtomicOrder.Unordered);
  20c01c:	48 8b 05 f5 00 04 00 	mov    rax,QWORD PTR [rip+0x400f5]        # 24c118 <vdso_clock_gettime>
        if (@ptrToInt(f) != 0) {
  20c023:	48 85 c0             	test   rax,rax
  20c026:	74 24                	je     20c04c <BmSimple.sfence+0x18c>
            const rc = f(clk_id, tp);
  20c028:	bf 01 00 00 00       	mov    edi,0x1
  20c02d:	4c 89 e6             	mov    rsi,r12
  20c030:	c5 f8 77             	vzeroupper 
  20c033:	ff d0                	call   rax
            switch (rc) {
  20c035:	48 83 f8 ea          	cmp    rax,0xffffffffffffffea
  20c039:	0f 84 41 02 00 00    	je     20c280 <BmSimple.sfence+0x3c0>
  20c03f:	48 85 c0             	test   rax,rax
  20c042:	c5 fa 6f 05 c6 42 ff 	vmovdqu xmm0,XMMWORD PTR [rip+0xffffffffffff42c6]        # 200310 <__unnamed_35>
  20c049:	ff 
  20c04a:	74 0f                	je     20c05b <BmSimple.sfence+0x19b>
  20c04c:	b8 e4 00 00 00       	mov    eax,0xe4
  20c051:	bf 01 00 00 00       	mov    edi,0x1
  20c056:	4c 89 e6             	mov    rsi,r12
  20c059:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  20c05b:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
                if (errno != 0) return std.os.unexpectedErrorPosix(errno);
  20c061:	0f 83 58 09 00 00    	jae    20c9bf <BmSimple.sfence+0xaff>
                self.start_time = @intCast(u64, ts.tv_sec) * u64(ns_per_s) + @intCast(u64, ts.tv_nsec);
  20c067:	c5 f9 6f 8c 24 90 00 	vmovdqa xmm1,XMMWORD PTR [rsp+0x90]
  20c06e:	00 00 
        while (iter > 0) : (iter -= 1) {
  20c070:	48 85 db             	test   rbx,rbx
  20c073:	74 14                	je     20c089 <BmSimple.sfence+0x1c9>
  20c075:	48 89 d8             	mov    rax,rbx
  20c078:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  20c07f:	00 
    asm volatile ("sfence": : :"memory");
  20c080:	0f ae f8             	sfence 
        while (iter > 0) : (iter -= 1) {
  20c083:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  20c087:	75 f7                	jne    20c080 <BmSimple.sfence+0x1c0>
        var ts: posix.timespec = undefined;
  20c089:	c5 f9 7f 84 24 90 00 	vmovdqa XMMWORD PTR [rsp+0x90],xmm0
  20c090:	00 00 
        const f = @atomicLoad(@typeOf(init_vdso_clock_gettime), &vdso_clock_gettime, builtin.AtomicOrder.Unordered);
  20c092:	48 8b 05 7f 00 04 00 	mov    rax,QWORD PTR [rip+0x4007f]        # 24c118 <vdso_clock_gettime>
        if (@ptrToInt(f) != 0) {
  20c099:	48 85 c0             	test   rax,rax
  20c09c:	74 2e                	je     20c0cc <BmSimple.sfence+0x20c>
  20c09e:	c5 f9 7f 8c 24 c0 00 	vmovdqa XMMWORD PTR [rsp+0xc0],xmm1
  20c0a5:	00 00 
            const rc = f(clk_id, tp);
  20c0a7:	bf 01 00 00 00       	mov    edi,0x1
  20c0ac:	4c 89 e6             	mov    rsi,r12
  20c0af:	c5 f8 77             	vzeroupper 
  20c0b2:	ff d0                	call   rax
            switch (rc) {
  20c0b4:	48 83 f8 ea          	cmp    rax,0xffffffffffffffea
  20c0b8:	0f 84 db 01 00 00    	je     20c299 <BmSimple.sfence+0x3d9>
  20c0be:	48 85 c0             	test   rax,rax
  20c0c1:	c5 f9 6f 8c 24 c0 00 	vmovdqa xmm1,XMMWORD PTR [rsp+0xc0]
  20c0c8:	00 00 
  20c0ca:	74 0f                	je     20c0db <BmSimple.sfence+0x21b>
  20c0cc:	b8 e4 00 00 00       	mov    eax,0xe4
  20c0d1:	bf 01 00 00 00       	mov    edi,0x1
  20c0d6:	4c 89 e6             	mov    rsi,r12
  20c0d9:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  20c0db:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
  20c0e1:	0f 83 f1 08 00 00    	jae    20c9d8 <BmSimple.sfence+0xb18>
        return @intCast(u64, ts.tv_sec) * u64(ns_per_s) + @intCast(u64, ts.tv_nsec);
  20c0e7:	c5 f9 6f 84 24 90 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x90]
  20c0ee:	00 00 
  20c0f0:	c5 f9 fb c1          	vpsubq xmm0,xmm0,xmm1
  20c0f4:	c4 e1 f9 7e c0       	vmovq  rax,xmm0
        var clock = clockNative() - self.start_time;
  20c0f9:	c4 e3 f9 16 c5 01    	vpextrq rbp,xmm0,0x1
  20c0ff:	48 69 c0 00 ca 9a 3b 	imul   rax,rax,0x3b9aca00
  20c106:	48 01 c5             	add    rbp,rax
                if ((run_time_ns >= pSelf.min_runtime_ns) or (iterations >= pSelf.max_iterations)) {
  20c109:	48 3b 6c 24 38       	cmp    rbp,QWORD PTR [rsp+0x38]
  20c10e:	0f 83 9f 01 00 00    	jae    20c2b3 <BmSimple.sfence+0x3f3>
  20c114:	4c 39 fb             	cmp    rbx,r15
  20c117:	0f 83 96 01 00 00    	jae    20c2b3 <BmSimple.sfence+0x3f3>
                    if (pSelf.logl >= 1) {
  20c11d:	48 83 7c 24 30 00    	cmp    QWORD PTR [rsp+0x30],0x0
  20c123:	0f 84 bd 00 00 00    	je     20c1e6 <BmSimple.sfence+0x326>
                            Result {.run_time_ns = run_time_ns, .iterations = iterations});
  20c129:	48 89 ac 24 d8 00 00 	mov    QWORD PTR [rsp+0xd8],rbp
  20c130:	00 
  20c131:	48 89 9c 24 e0 00 00 	mov    QWORD PTR [rsp+0xe0],rbx
  20c138:	00 
                        try pSelf.report(
  20c139:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  20c13e:	48 8d b4 24 d8 00 00 	lea    rsi,[rsp+0xd8]
  20c145:	00 
  20c146:	c5 f8 77             	vzeroupper 
  20c149:	e8 d2 6d 00 00       	call   212f20 <Benchmark_report>
  20c14e:	66 85 c0             	test   ax,ax
  20c151:	0f 85 6c 08 00 00    	jne    20c9c3 <BmSimple.sfence+0xb03>
  20c157:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  20c15e:	00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20c160:	b0 01                	mov    al,0x1
  20c162:	86 05 a8 4e 04 00    	xchg   BYTE PTR [rip+0x44ea8],al        # 251010 <stderr_mutex>
  20c168:	84 c0                	test   al,al
  20c16a:	75 f4                	jne    20c160 <BmSimple.sfence+0x2a0>
    if (stderr_stream) |st| {
  20c16c:	48 8b 3d 95 4e 04 00 	mov    rdi,QWORD PTR [rip+0x44e95]        # 251008 <stderr_stream>
  20c173:	48 85 ff             	test   rdi,rdi
  20c176:	74 18                	je     20c190 <BmSimple.sfence+0x2d0>
  20c178:	48 8b 0d c1 fe 03 00 	mov    rcx,QWORD PTR [rip+0x3fec1]        # 24c040 <stderr_file_out_stream+0x8>
  20c17f:	eb 4c                	jmp    20c1cd <BmSimple.sfence+0x30d>
  20c181:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20c188:	0f 1f 84 00 00 00 00 
  20c18f:	00 
        stderr_file = try io.getStdErr();
  20c190:	c7 05 96 fe 03 00 02 	mov    DWORD PTR [rip+0x3fe96],0x2        # 24c030 <stderr_file>
  20c197:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20c19a:	48 8d 05 8f fe 03 00 	lea    rax,[rip+0x3fe8f]        # 24c030 <stderr_file>
  20c1a1:	48 89 05 90 fe 03 00 	mov    QWORD PTR [rip+0x3fe90],rax        # 24c038 <stderr_file_out_stream>
  20c1a8:	48 8d 05 f1 2c 01 00 	lea    rax,[rip+0x12cf1]        # 21eea0 <FileOutStream_writeFn>
  20c1af:	48 89 05 8a fe 03 00 	mov    QWORD PTR [rip+0x3fe8a],rax        # 24c040 <stderr_file_out_stream+0x8>
  20c1b6:	48 8d 0d 83 fe 03 00 	lea    rcx,[rip+0x3fe83]        # 24c040 <stderr_file_out_stream+0x8>
  20c1bd:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20c1c0:	48 89 15 41 4e 04 00 	mov    QWORD PTR [rip+0x44e41],rdx        # 251008 <stderr_stream>
  20c1c7:	48 89 c1             	mov    rcx,rax
  20c1ca:	48 89 d7             	mov    rdi,rdx
  20c1cd:	48 8d 35 1c 3d 04 00 	lea    rsi,[rip+0x43d1c]        # 24fef0 <__unnamed_3>
  20c1d4:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20c1d6:	31 c0                	xor    eax,eax
  20c1d8:	86 05 32 4e 04 00    	xchg   BYTE PTR [rip+0x44e32],al        # 251010 <stderr_mutex>
  20c1de:	3c 01                	cmp    al,0x1
    if (!ok) {
  20c1e0:	0f 85 f2 07 00 00    	jne    20c9d8 <BmSimple.sfence+0xb18>
                    if (run_time_ns < 1000) {
  20c1e6:	48 81 fd e8 03 00 00 	cmp    rbp,0x3e8
  20c1ed:	73 31                	jae    20c220 <BmSimple.sfence+0x360>
  20c1ef:	b9 01 00 00 00       	mov    ecx,0x1
  20c1f4:	be e8 03 00 00       	mov    esi,0x3e8
                    iterations = (iterations * numer) / denom;
  20c1f9:	48 0f af de          	imul   rbx,rsi
  20c1fd:	48 89 d8             	mov    rax,rbx
  20c200:	48 c1 e8 20          	shr    rax,0x20
  20c204:	74 54                	je     20c25a <BmSimple.sfence+0x39a>
  20c206:	31 d2                	xor    edx,edx
  20c208:	48 89 d8             	mov    rax,rbx
  20c20b:	48 f7 f1             	div    rcx
  20c20e:	48 89 c3             	mov    rbx,rax
  20c211:	eb 4f                	jmp    20c262 <BmSimple.sfence+0x3a2>
  20c213:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20c21a:	84 00 00 00 00 00 
                    } else if (run_time_ns < (pSelf.min_runtime_ns / 10)) {
  20c220:	48 ba cd cc cc cc cc 	movabs rdx,0xcccccccccccccccd
  20c227:	cc cc cc 
  20c22a:	c4 e2 fb f6 4c 24 38 	mulx   rcx,rax,QWORD PTR [rsp+0x38]
  20c231:	48 c1 e9 03          	shr    rcx,0x3
  20c235:	31 c0                	xor    eax,eax
  20c237:	48 39 cd             	cmp    rbp,rcx
  20c23a:	0f 93 c0             	setae  al
  20c23d:	48 8d 0c c0          	lea    rcx,[rax+rax*8]
  20c241:	48 83 c1 01          	add    rcx,0x1
  20c245:	48 8d 34 85 0a 00 00 	lea    rsi,[rax*4+0xa]
  20c24c:	00 
                    iterations = (iterations * numer) / denom;
  20c24d:	48 0f af de          	imul   rbx,rsi
  20c251:	48 89 d8             	mov    rax,rbx
  20c254:	48 c1 e8 20          	shr    rax,0x20
  20c258:	75 ac                	jne    20c206 <BmSimple.sfence+0x346>
  20c25a:	31 d2                	xor    edx,edx
  20c25c:	89 d8                	mov    eax,ebx
  20c25e:	f7 f1                	div    ecx
  20c260:	89 c3                	mov    ebx,eax
                    if (iterations > pSelf.max_iterations) {
  20c262:	4c 8b 7c 24 48       	mov    r15,QWORD PTR [rsp+0x48]
  20c267:	4c 39 fb             	cmp    rbx,r15
  20c26a:	49 0f 47 df          	cmova  rbx,r15
                    if (pSelf.logl >= 2) {
  20c26e:	48 83 7c 24 30 02    	cmp    QWORD PTR [rsp+0x30],0x2
  20c274:	0f 82 64 fd ff ff    	jb     20bfde <BmSimple.sfence+0x11e>
  20c27a:	e9 51 fd ff ff       	jmp    20bfd0 <BmSimple.sfence+0x110>
  20c27f:	90                   	nop
  20c280:	c5 fa 6f 05 88 40 ff 	vmovdqu xmm0,XMMWORD PTR [rip+0xffffffffffff4088]        # 200310 <__unnamed_35>
  20c287:	ff 
  20c288:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
                if (errno != 0) return std.os.unexpectedErrorPosix(errno);
  20c28e:	0f 82 d3 fd ff ff    	jb     20c067 <BmSimple.sfence+0x1a7>
  20c294:	e9 26 07 00 00       	jmp    20c9bf <BmSimple.sfence+0xaff>
  20c299:	c5 f9 6f 8c 24 c0 00 	vmovdqa xmm1,XMMWORD PTR [rsp+0xc0]
  20c2a0:	00 00 
  20c2a2:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
  20c2a8:	0f 82 39 fe ff ff    	jb     20c0e7 <BmSimple.sfence+0x227>
  20c2ae:	e9 25 07 00 00       	jmp    20c9d8 <BmSimple.sfence+0xb18>
                            Result { .run_time_ns = run_time_ns, .iterations = iterations});
  20c2b3:	48 89 ac 24 e8 00 00 	mov    QWORD PTR [rsp+0xe8],rbp
  20c2ba:	00 
  20c2bb:	48 89 9c 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rbx
  20c2c2:	00 
                    try pSelf.results.append(
  20c2c3:	48 8d 7c 24 68       	lea    rdi,[rsp+0x68]
  20c2c8:	48 8d b4 24 e8 00 00 	lea    rsi,[rsp+0xe8]
  20c2cf:	00 
  20c2d0:	c5 f8 77             	vzeroupper 
  20c2d3:	e8 d8 6a 00 00       	call   212db0 <AlignedArrayList(Result,8)_append>
  20c2d8:	66 85 c0             	test   ax,ax
  20c2db:	74 16                	je     20c2f3 <BmSimple.sfence+0x433>
  20c2dd:	e9 e1 06 00 00       	jmp    20c9c3 <BmSimple.sfence+0xb03>
            while (iterations <= pSelf.max_iterations) {
  20c2e2:	4c 8b 7c 24 48       	mov    r15,QWORD PTR [rsp+0x48]
  20c2e7:	45 31 f6             	xor    r14d,r14d
  20c2ea:	4c 39 fb             	cmp    rbx,r15
  20c2ed:	0f 86 eb fc ff ff    	jbe    20bfde <BmSimple.sfence+0x11e>
            if (once) {
  20c2f3:	41 f6 c6 01          	test   r14b,0x1
  20c2f7:	48 8d 6c 24 0f       	lea    rbp,[rsp+0xf]
  20c2fc:	4c 8d 74 24 10       	lea    r14,[rsp+0x10]
  20c301:	0f 84 e0 05 00 00    	je     20c8e7 <BmSimple.sfence+0xa27>
                try leftJustified(22, "name repetitions:{}", pSelf.repetitions);
  20c307:	48 8b 7c 24 40       	mov    rdi,QWORD PTR [rsp+0x40]
  20c30c:	c5 f8 77             	vzeroupper 
  20c30f:	e8 8c 90 00 00       	call   2153a0 <Benchmark_leftJustified>
  20c314:	66 85 c0             	test   ax,ax
  20c317:	0f 85 a6 06 00 00    	jne    20c9c3 <BmSimple.sfence+0xb03>
                try rightJustified(14, "{}", "iterations");
  20c31d:	e8 1e 93 00 00       	call   215640 <Benchmark_rightJustified>
  20c322:	66 85 c0             	test   ax,ax
  20c325:	0f 85 98 06 00 00    	jne    20c9c3 <BmSimple.sfence+0xb03>
        var buffer: [40]u8 = undefined;
  20c32b:	c5 fe 6f 05 1c 9c ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffff9c1c]        # 205f4f <__unnamed_7>
  20c332:	ff 
  20c333:	c5 fe 7f 84 24 90 00 	vmovdqu YMMWORD PTR [rsp+0x90],ymm0
  20c33a:	00 00 
  20c33c:	48 8b 05 2c 9c ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffff9c2c]        # 205f6f <__unnamed_7+0x20>
  20c343:	48 89 84 24 b0 00 00 	mov    QWORD PTR [rsp+0xb0],rax
  20c34a:	00 
  20c34b:	c7 84 24 90 00 00 00 	mov    DWORD PTR [rsp+0x90],0x656d6974
  20c352:	74 69 6d 65 
  20c356:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  20c35d:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20c360:	b0 01                	mov    al,0x1
  20c362:	86 05 a8 4c 04 00    	xchg   BYTE PTR [rip+0x44ca8],al        # 251010 <stderr_mutex>
  20c368:	84 c0                	test   al,al
  20c36a:	75 f4                	jne    20c360 <BmSimple.sfence+0x4a0>
    if (stderr_stream) |st| {
  20c36c:	48 8b 3d 95 4c 04 00 	mov    rdi,QWORD PTR [rip+0x44c95]        # 251008 <stderr_stream>
  20c373:	48 85 ff             	test   rdi,rdi
  20c376:	74 09                	je     20c381 <BmSimple.sfence+0x4c1>
  20c378:	48 8b 0d c1 fc 03 00 	mov    rcx,QWORD PTR [rip+0x3fcc1]        # 24c040 <stderr_file_out_stream+0x8>
  20c37f:	eb 3d                	jmp    20c3be <BmSimple.sfence+0x4fe>
        stderr_file = try io.getStdErr();
  20c381:	c7 05 a5 fc 03 00 02 	mov    DWORD PTR [rip+0x3fca5],0x2        # 24c030 <stderr_file>
  20c388:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20c38b:	48 8d 05 9e fc 03 00 	lea    rax,[rip+0x3fc9e]        # 24c030 <stderr_file>
  20c392:	48 89 05 9f fc 03 00 	mov    QWORD PTR [rip+0x3fc9f],rax        # 24c038 <stderr_file_out_stream>
  20c399:	48 8d 05 00 2b 01 00 	lea    rax,[rip+0x12b00]        # 21eea0 <FileOutStream_writeFn>
  20c3a0:	48 89 05 99 fc 03 00 	mov    QWORD PTR [rip+0x3fc99],rax        # 24c040 <stderr_file_out_stream+0x8>
  20c3a7:	48 8d 0d 92 fc 03 00 	lea    rcx,[rip+0x3fc92]        # 24c040 <stderr_file_out_stream+0x8>
  20c3ae:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20c3b1:	48 89 15 50 4c 04 00 	mov    QWORD PTR [rip+0x44c50],rdx        # 251008 <stderr_stream>
  20c3b8:	48 89 c1             	mov    rcx,rax
  20c3bb:	48 89 d7             	mov    rdi,rdx
  20c3be:	c6 44 24 0f 20       	mov    BYTE PTR [rsp+0xf],0x20
    return output(context, (*[1]u8)(&c)[0..]);
  20c3c3:	48 89 6c 24 10       	mov    QWORD PTR [rsp+0x10],rbp
  20c3c8:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  20c3cf:	00 00 
  20c3d1:	4c 89 f6             	mov    rsi,r14
  20c3d4:	c5 f8 77             	vzeroupper 
  20c3d7:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20c3d9:	31 c0                	xor    eax,eax
  20c3db:	86 05 2f 4c 04 00    	xchg   BYTE PTR [rip+0x44c2f],al        # 251010 <stderr_mutex>
  20c3e1:	3c 01                	cmp    al,0x1
    if (!ok) {
  20c3e3:	0f 85 ef 05 00 00    	jne    20c9d8 <BmSimple.sfence+0xb18>
  20c3e9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20c3f0:	b0 01                	mov    al,0x1
  20c3f2:	86 05 18 4c 04 00    	xchg   BYTE PTR [rip+0x44c18],al        # 251010 <stderr_mutex>
  20c3f8:	84 c0                	test   al,al
  20c3fa:	75 f4                	jne    20c3f0 <BmSimple.sfence+0x530>
    if (stderr_stream) |st| {
  20c3fc:	48 8b 3d 05 4c 04 00 	mov    rdi,QWORD PTR [rip+0x44c05]        # 251008 <stderr_stream>
  20c403:	48 85 ff             	test   rdi,rdi
  20c406:	74 09                	je     20c411 <BmSimple.sfence+0x551>
  20c408:	48 8b 0d 31 fc 03 00 	mov    rcx,QWORD PTR [rip+0x3fc31]        # 24c040 <stderr_file_out_stream+0x8>
  20c40f:	eb 3d                	jmp    20c44e <BmSimple.sfence+0x58e>
        stderr_file = try io.getStdErr();
  20c411:	c7 05 15 fc 03 00 02 	mov    DWORD PTR [rip+0x3fc15],0x2        # 24c030 <stderr_file>
  20c418:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20c41b:	48 8d 05 0e fc 03 00 	lea    rax,[rip+0x3fc0e]        # 24c030 <stderr_file>
  20c422:	48 89 05 0f fc 03 00 	mov    QWORD PTR [rip+0x3fc0f],rax        # 24c038 <stderr_file_out_stream>
  20c429:	48 8d 05 70 2a 01 00 	lea    rax,[rip+0x12a70]        # 21eea0 <FileOutStream_writeFn>
  20c430:	48 89 05 09 fc 03 00 	mov    QWORD PTR [rip+0x3fc09],rax        # 24c040 <stderr_file_out_stream+0x8>
  20c437:	48 8d 0d 02 fc 03 00 	lea    rcx,[rip+0x3fc02]        # 24c040 <stderr_file_out_stream+0x8>
  20c43e:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20c441:	48 89 15 c0 4b 04 00 	mov    QWORD PTR [rip+0x44bc0],rdx        # 251008 <stderr_stream>
  20c448:	48 89 c1             	mov    rcx,rax
  20c44b:	48 89 d7             	mov    rdi,rdx
  20c44e:	c6 44 24 0f 20       	mov    BYTE PTR [rsp+0xf],0x20
  20c453:	48 89 6c 24 10       	mov    QWORD PTR [rsp+0x10],rbp
  20c458:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  20c45f:	00 00 
  20c461:	4c 89 f6             	mov    rsi,r14
  20c464:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20c466:	31 c0                	xor    eax,eax
  20c468:	86 05 a2 4b 04 00    	xchg   BYTE PTR [rip+0x44ba2],al        # 251010 <stderr_mutex>
  20c46e:	3c 01                	cmp    al,0x1
    if (!ok) {
  20c470:	0f 85 62 05 00 00    	jne    20c9d8 <BmSimple.sfence+0xb18>
  20c476:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  20c47d:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20c480:	b0 01                	mov    al,0x1
  20c482:	86 05 88 4b 04 00    	xchg   BYTE PTR [rip+0x44b88],al        # 251010 <stderr_mutex>
  20c488:	84 c0                	test   al,al
  20c48a:	75 f4                	jne    20c480 <BmSimple.sfence+0x5c0>
    if (stderr_stream) |st| {
  20c48c:	48 8b 3d 75 4b 04 00 	mov    rdi,QWORD PTR [rip+0x44b75]        # 251008 <stderr_stream>
  20c493:	48 85 ff             	test   rdi,rdi
  20c496:	74 09                	je     20c4a1 <BmSimple.sfence+0x5e1>
  20c498:	48 8b 0d a1 fb 03 00 	mov    rcx,QWORD PTR [rip+0x3fba1]        # 24c040 <stderr_file_out_stream+0x8>
  20c49f:	eb 3d                	jmp    20c4de <BmSimple.sfence+0x61e>
        stderr_file = try io.getStdErr();
  20c4a1:	c7 05 85 fb 03 00 02 	mov    DWORD PTR [rip+0x3fb85],0x2        # 24c030 <stderr_file>
  20c4a8:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20c4ab:	48 8d 05 7e fb 03 00 	lea    rax,[rip+0x3fb7e]        # 24c030 <stderr_file>
  20c4b2:	48 89 05 7f fb 03 00 	mov    QWORD PTR [rip+0x3fb7f],rax        # 24c038 <stderr_file_out_stream>
  20c4b9:	48 8d 05 e0 29 01 00 	lea    rax,[rip+0x129e0]        # 21eea0 <FileOutStream_writeFn>
  20c4c0:	48 89 05 79 fb 03 00 	mov    QWORD PTR [rip+0x3fb79],rax        # 24c040 <stderr_file_out_stream+0x8>
  20c4c7:	48 8d 0d 72 fb 03 00 	lea    rcx,[rip+0x3fb72]        # 24c040 <stderr_file_out_stream+0x8>
  20c4ce:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20c4d1:	48 89 15 30 4b 04 00 	mov    QWORD PTR [rip+0x44b30],rdx        # 251008 <stderr_stream>
  20c4d8:	48 89 c1             	mov    rcx,rax
  20c4db:	48 89 d7             	mov    rdi,rdx
  20c4de:	c6 44 24 0f 20       	mov    BYTE PTR [rsp+0xf],0x20
  20c4e3:	48 89 6c 24 10       	mov    QWORD PTR [rsp+0x10],rbp
  20c4e8:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  20c4ef:	00 00 
  20c4f1:	4c 89 f6             	mov    rsi,r14
  20c4f4:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20c4f6:	31 c0                	xor    eax,eax
  20c4f8:	86 05 12 4b 04 00    	xchg   BYTE PTR [rip+0x44b12],al        # 251010 <stderr_mutex>
  20c4fe:	3c 01                	cmp    al,0x1
    if (!ok) {
  20c500:	0f 85 d2 04 00 00    	jne    20c9d8 <BmSimple.sfence+0xb18>
  20c506:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  20c50d:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20c510:	b0 01                	mov    al,0x1
  20c512:	86 05 f8 4a 04 00    	xchg   BYTE PTR [rip+0x44af8],al        # 251010 <stderr_mutex>
  20c518:	84 c0                	test   al,al
  20c51a:	75 f4                	jne    20c510 <BmSimple.sfence+0x650>
    if (stderr_stream) |st| {
  20c51c:	48 8b 3d e5 4a 04 00 	mov    rdi,QWORD PTR [rip+0x44ae5]        # 251008 <stderr_stream>
  20c523:	48 85 ff             	test   rdi,rdi
  20c526:	74 09                	je     20c531 <BmSimple.sfence+0x671>
  20c528:	48 8b 0d 11 fb 03 00 	mov    rcx,QWORD PTR [rip+0x3fb11]        # 24c040 <stderr_file_out_stream+0x8>
  20c52f:	eb 3d                	jmp    20c56e <BmSimple.sfence+0x6ae>
        stderr_file = try io.getStdErr();
  20c531:	c7 05 f5 fa 03 00 02 	mov    DWORD PTR [rip+0x3faf5],0x2        # 24c030 <stderr_file>
  20c538:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20c53b:	48 8d 05 ee fa 03 00 	lea    rax,[rip+0x3faee]        # 24c030 <stderr_file>
  20c542:	48 89 05 ef fa 03 00 	mov    QWORD PTR [rip+0x3faef],rax        # 24c038 <stderr_file_out_stream>
  20c549:	48 8d 05 50 29 01 00 	lea    rax,[rip+0x12950]        # 21eea0 <FileOutStream_writeFn>
  20c550:	48 89 05 e9 fa 03 00 	mov    QWORD PTR [rip+0x3fae9],rax        # 24c040 <stderr_file_out_stream+0x8>
  20c557:	48 8d 0d e2 fa 03 00 	lea    rcx,[rip+0x3fae2]        # 24c040 <stderr_file_out_stream+0x8>
  20c55e:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20c561:	48 89 15 a0 4a 04 00 	mov    QWORD PTR [rip+0x44aa0],rdx        # 251008 <stderr_stream>
  20c568:	48 89 c1             	mov    rcx,rax
  20c56b:	48 89 d7             	mov    rdi,rdx
  20c56e:	c6 44 24 0f 20       	mov    BYTE PTR [rsp+0xf],0x20
  20c573:	48 89 6c 24 10       	mov    QWORD PTR [rsp+0x10],rbp
  20c578:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  20c57f:	00 00 
  20c581:	4c 89 f6             	mov    rsi,r14
  20c584:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20c586:	31 c0                	xor    eax,eax
  20c588:	86 05 82 4a 04 00    	xchg   BYTE PTR [rip+0x44a82],al        # 251010 <stderr_mutex>
  20c58e:	3c 01                	cmp    al,0x1
    if (!ok) {
  20c590:	0f 85 42 04 00 00    	jne    20c9d8 <BmSimple.sfence+0xb18>
  20c596:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  20c59d:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20c5a0:	b0 01                	mov    al,0x1
  20c5a2:	86 05 68 4a 04 00    	xchg   BYTE PTR [rip+0x44a68],al        # 251010 <stderr_mutex>
  20c5a8:	84 c0                	test   al,al
  20c5aa:	75 f4                	jne    20c5a0 <BmSimple.sfence+0x6e0>
    if (stderr_stream) |st| {
  20c5ac:	48 8b 3d 55 4a 04 00 	mov    rdi,QWORD PTR [rip+0x44a55]        # 251008 <stderr_stream>
  20c5b3:	48 85 ff             	test   rdi,rdi
  20c5b6:	74 09                	je     20c5c1 <BmSimple.sfence+0x701>
  20c5b8:	48 8b 0d 81 fa 03 00 	mov    rcx,QWORD PTR [rip+0x3fa81]        # 24c040 <stderr_file_out_stream+0x8>
  20c5bf:	eb 3d                	jmp    20c5fe <BmSimple.sfence+0x73e>
        stderr_file = try io.getStdErr();
  20c5c1:	c7 05 65 fa 03 00 02 	mov    DWORD PTR [rip+0x3fa65],0x2        # 24c030 <stderr_file>
  20c5c8:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20c5cb:	48 8d 05 5e fa 03 00 	lea    rax,[rip+0x3fa5e]        # 24c030 <stderr_file>
  20c5d2:	48 89 05 5f fa 03 00 	mov    QWORD PTR [rip+0x3fa5f],rax        # 24c038 <stderr_file_out_stream>
  20c5d9:	48 8d 05 c0 28 01 00 	lea    rax,[rip+0x128c0]        # 21eea0 <FileOutStream_writeFn>
  20c5e0:	48 89 05 59 fa 03 00 	mov    QWORD PTR [rip+0x3fa59],rax        # 24c040 <stderr_file_out_stream+0x8>
  20c5e7:	48 8d 0d 52 fa 03 00 	lea    rcx,[rip+0x3fa52]        # 24c040 <stderr_file_out_stream+0x8>
  20c5ee:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20c5f1:	48 89 15 10 4a 04 00 	mov    QWORD PTR [rip+0x44a10],rdx        # 251008 <stderr_stream>
  20c5f8:	48 89 c1             	mov    rcx,rax
  20c5fb:	48 89 d7             	mov    rdi,rdx
  20c5fe:	c6 44 24 0f 20       	mov    BYTE PTR [rsp+0xf],0x20
  20c603:	48 89 6c 24 10       	mov    QWORD PTR [rsp+0x10],rbp
  20c608:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  20c60f:	00 00 
  20c611:	4c 89 f6             	mov    rsi,r14
  20c614:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20c616:	31 c0                	xor    eax,eax
  20c618:	86 05 f2 49 04 00    	xchg   BYTE PTR [rip+0x449f2],al        # 251010 <stderr_mutex>
  20c61e:	3c 01                	cmp    al,0x1
    if (!ok) {
  20c620:	0f 85 b2 03 00 00    	jne    20c9d8 <BmSimple.sfence+0xb18>
  20c626:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  20c62d:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20c630:	b0 01                	mov    al,0x1
  20c632:	86 05 d8 49 04 00    	xchg   BYTE PTR [rip+0x449d8],al        # 251010 <stderr_mutex>
  20c638:	84 c0                	test   al,al
  20c63a:	75 f4                	jne    20c630 <BmSimple.sfence+0x770>
    if (stderr_stream) |st| {
  20c63c:	48 8b 3d c5 49 04 00 	mov    rdi,QWORD PTR [rip+0x449c5]        # 251008 <stderr_stream>
  20c643:	48 85 ff             	test   rdi,rdi
  20c646:	74 09                	je     20c651 <BmSimple.sfence+0x791>
  20c648:	48 8b 0d f1 f9 03 00 	mov    rcx,QWORD PTR [rip+0x3f9f1]        # 24c040 <stderr_file_out_stream+0x8>
  20c64f:	eb 3d                	jmp    20c68e <BmSimple.sfence+0x7ce>
        stderr_file = try io.getStdErr();
  20c651:	c7 05 d5 f9 03 00 02 	mov    DWORD PTR [rip+0x3f9d5],0x2        # 24c030 <stderr_file>
  20c658:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20c65b:	48 8d 05 ce f9 03 00 	lea    rax,[rip+0x3f9ce]        # 24c030 <stderr_file>
  20c662:	48 89 05 cf f9 03 00 	mov    QWORD PTR [rip+0x3f9cf],rax        # 24c038 <stderr_file_out_stream>
  20c669:	48 8d 05 30 28 01 00 	lea    rax,[rip+0x12830]        # 21eea0 <FileOutStream_writeFn>
  20c670:	48 89 05 c9 f9 03 00 	mov    QWORD PTR [rip+0x3f9c9],rax        # 24c040 <stderr_file_out_stream+0x8>
  20c677:	48 8d 0d c2 f9 03 00 	lea    rcx,[rip+0x3f9c2]        # 24c040 <stderr_file_out_stream+0x8>
  20c67e:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20c681:	48 89 15 80 49 04 00 	mov    QWORD PTR [rip+0x44980],rdx        # 251008 <stderr_stream>
  20c688:	48 89 c1             	mov    rcx,rax
  20c68b:	48 89 d7             	mov    rdi,rdx
  20c68e:	c6 44 24 0f 20       	mov    BYTE PTR [rsp+0xf],0x20
  20c693:	48 89 6c 24 10       	mov    QWORD PTR [rsp+0x10],rbp
  20c698:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  20c69f:	00 00 
  20c6a1:	4c 89 f6             	mov    rsi,r14
  20c6a4:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20c6a6:	31 c0                	xor    eax,eax
  20c6a8:	86 05 62 49 04 00    	xchg   BYTE PTR [rip+0x44962],al        # 251010 <stderr_mutex>
  20c6ae:	3c 01                	cmp    al,0x1
    if (!ok) {
  20c6b0:	0f 85 22 03 00 00    	jne    20c9d8 <BmSimple.sfence+0xb18>
  20c6b6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  20c6bd:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20c6c0:	b0 01                	mov    al,0x1
  20c6c2:	86 05 48 49 04 00    	xchg   BYTE PTR [rip+0x44948],al        # 251010 <stderr_mutex>
  20c6c8:	84 c0                	test   al,al
  20c6ca:	75 f4                	jne    20c6c0 <BmSimple.sfence+0x800>
    if (stderr_stream) |st| {
  20c6cc:	48 8b 3d 35 49 04 00 	mov    rdi,QWORD PTR [rip+0x44935]        # 251008 <stderr_stream>
  20c6d3:	48 85 ff             	test   rdi,rdi
  20c6d6:	74 09                	je     20c6e1 <BmSimple.sfence+0x821>
  20c6d8:	48 8b 0d 61 f9 03 00 	mov    rcx,QWORD PTR [rip+0x3f961]        # 24c040 <stderr_file_out_stream+0x8>
  20c6df:	eb 3d                	jmp    20c71e <BmSimple.sfence+0x85e>
        stderr_file = try io.getStdErr();
  20c6e1:	c7 05 45 f9 03 00 02 	mov    DWORD PTR [rip+0x3f945],0x2        # 24c030 <stderr_file>
  20c6e8:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20c6eb:	48 8d 05 3e f9 03 00 	lea    rax,[rip+0x3f93e]        # 24c030 <stderr_file>
  20c6f2:	48 89 05 3f f9 03 00 	mov    QWORD PTR [rip+0x3f93f],rax        # 24c038 <stderr_file_out_stream>
  20c6f9:	48 8d 05 a0 27 01 00 	lea    rax,[rip+0x127a0]        # 21eea0 <FileOutStream_writeFn>
  20c700:	48 89 05 39 f9 03 00 	mov    QWORD PTR [rip+0x3f939],rax        # 24c040 <stderr_file_out_stream+0x8>
  20c707:	48 8d 0d 32 f9 03 00 	lea    rcx,[rip+0x3f932]        # 24c040 <stderr_file_out_stream+0x8>
  20c70e:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20c711:	48 89 15 f0 48 04 00 	mov    QWORD PTR [rip+0x448f0],rdx        # 251008 <stderr_stream>
  20c718:	48 89 c1             	mov    rcx,rax
  20c71b:	48 89 d7             	mov    rdi,rdx
  20c71e:	c6 44 24 0f 20       	mov    BYTE PTR [rsp+0xf],0x20
  20c723:	48 89 6c 24 10       	mov    QWORD PTR [rsp+0x10],rbp
  20c728:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  20c72f:	00 00 
  20c731:	4c 89 f6             	mov    rsi,r14
  20c734:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20c736:	31 c0                	xor    eax,eax
  20c738:	86 05 d2 48 04 00    	xchg   BYTE PTR [rip+0x448d2],al        # 251010 <stderr_mutex>
  20c73e:	3c 01                	cmp    al,0x1
    if (!ok) {
  20c740:	0f 85 92 02 00 00    	jne    20c9d8 <BmSimple.sfence+0xb18>
  20c746:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  20c74d:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20c750:	b0 01                	mov    al,0x1
  20c752:	86 05 b8 48 04 00    	xchg   BYTE PTR [rip+0x448b8],al        # 251010 <stderr_mutex>
  20c758:	84 c0                	test   al,al
  20c75a:	75 f4                	jne    20c750 <BmSimple.sfence+0x890>
    if (stderr_stream) |st| {
  20c75c:	48 8b 3d a5 48 04 00 	mov    rdi,QWORD PTR [rip+0x448a5]        # 251008 <stderr_stream>
  20c763:	48 85 ff             	test   rdi,rdi
  20c766:	74 09                	je     20c771 <BmSimple.sfence+0x8b1>
  20c768:	48 8b 0d d1 f8 03 00 	mov    rcx,QWORD PTR [rip+0x3f8d1]        # 24c040 <stderr_file_out_stream+0x8>
  20c76f:	eb 3d                	jmp    20c7ae <BmSimple.sfence+0x8ee>
        stderr_file = try io.getStdErr();
  20c771:	c7 05 b5 f8 03 00 02 	mov    DWORD PTR [rip+0x3f8b5],0x2        # 24c030 <stderr_file>
  20c778:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20c77b:	48 8d 05 ae f8 03 00 	lea    rax,[rip+0x3f8ae]        # 24c030 <stderr_file>
  20c782:	48 89 05 af f8 03 00 	mov    QWORD PTR [rip+0x3f8af],rax        # 24c038 <stderr_file_out_stream>
  20c789:	48 8d 05 10 27 01 00 	lea    rax,[rip+0x12710]        # 21eea0 <FileOutStream_writeFn>
  20c790:	48 89 05 a9 f8 03 00 	mov    QWORD PTR [rip+0x3f8a9],rax        # 24c040 <stderr_file_out_stream+0x8>
  20c797:	48 8d 0d a2 f8 03 00 	lea    rcx,[rip+0x3f8a2]        # 24c040 <stderr_file_out_stream+0x8>
  20c79e:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20c7a1:	48 89 15 60 48 04 00 	mov    QWORD PTR [rip+0x44860],rdx        # 251008 <stderr_stream>
  20c7a8:	48 89 c1             	mov    rcx,rax
  20c7ab:	48 89 d7             	mov    rdi,rdx
  20c7ae:	c6 44 24 0f 20       	mov    BYTE PTR [rsp+0xf],0x20
  20c7b3:	48 89 6c 24 10       	mov    QWORD PTR [rsp+0x10],rbp
  20c7b8:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  20c7bf:	00 00 
  20c7c1:	4c 89 f6             	mov    rsi,r14
  20c7c4:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20c7c6:	31 c0                	xor    eax,eax
  20c7c8:	86 05 42 48 04 00    	xchg   BYTE PTR [rip+0x44842],al        # 251010 <stderr_mutex>
  20c7ce:	3c 01                	cmp    al,0x1
    if (!ok) {
  20c7d0:	0f 85 02 02 00 00    	jne    20c9d8 <BmSimple.sfence+0xb18>
  20c7d6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  20c7dd:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20c7e0:	b0 01                	mov    al,0x1
  20c7e2:	86 05 28 48 04 00    	xchg   BYTE PTR [rip+0x44828],al        # 251010 <stderr_mutex>
  20c7e8:	84 c0                	test   al,al
  20c7ea:	75 f4                	jne    20c7e0 <BmSimple.sfence+0x920>
    if (stderr_stream) |st| {
  20c7ec:	48 8b 3d 15 48 04 00 	mov    rdi,QWORD PTR [rip+0x44815]        # 251008 <stderr_stream>
  20c7f3:	48 85 ff             	test   rdi,rdi
  20c7f6:	74 09                	je     20c801 <BmSimple.sfence+0x941>
  20c7f8:	48 8b 0d 41 f8 03 00 	mov    rcx,QWORD PTR [rip+0x3f841]        # 24c040 <stderr_file_out_stream+0x8>
  20c7ff:	eb 3d                	jmp    20c83e <BmSimple.sfence+0x97e>
        stderr_file = try io.getStdErr();
  20c801:	c7 05 25 f8 03 00 02 	mov    DWORD PTR [rip+0x3f825],0x2        # 24c030 <stderr_file>
  20c808:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20c80b:	48 8d 05 1e f8 03 00 	lea    rax,[rip+0x3f81e]        # 24c030 <stderr_file>
  20c812:	48 89 05 1f f8 03 00 	mov    QWORD PTR [rip+0x3f81f],rax        # 24c038 <stderr_file_out_stream>
  20c819:	48 8d 05 80 26 01 00 	lea    rax,[rip+0x12680]        # 21eea0 <FileOutStream_writeFn>
  20c820:	48 89 05 19 f8 03 00 	mov    QWORD PTR [rip+0x3f819],rax        # 24c040 <stderr_file_out_stream+0x8>
  20c827:	48 8d 0d 12 f8 03 00 	lea    rcx,[rip+0x3f812]        # 24c040 <stderr_file_out_stream+0x8>
  20c82e:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20c831:	48 89 15 d0 47 04 00 	mov    QWORD PTR [rip+0x447d0],rdx        # 251008 <stderr_stream>
  20c838:	48 89 c1             	mov    rcx,rax
  20c83b:	48 89 d7             	mov    rdi,rdx
                const casted_value = ([]const u8)(value);
  20c83e:	4c 89 64 24 10       	mov    QWORD PTR [rsp+0x10],r12
  20c843:	48 c7 44 24 18 04 00 	mov    QWORD PTR [rsp+0x18],0x4
  20c84a:	00 00 
                return output(context, casted_value);
  20c84c:	4c 89 f6             	mov    rsi,r14
  20c84f:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20c851:	31 c0                	xor    eax,eax
  20c853:	86 05 b7 47 04 00    	xchg   BYTE PTR [rip+0x447b7],al        # 251010 <stderr_mutex>
  20c859:	3c 01                	cmp    al,0x1
    if (!ok) {
  20c85b:	0f 85 77 01 00 00    	jne    20c9d8 <BmSimple.sfence+0xb18>
                try rightJustified(18, "{}", "time/operation");
  20c861:	e8 ba 90 00 00       	call   215920 <Benchmark_rightJustified.39>
  20c866:	66 85 c0             	test   ax,ax
  20c869:	0f 85 54 01 00 00    	jne    20c9c3 <BmSimple.sfence+0xb03>
  20c86f:	90                   	nop
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20c870:	b0 01                	mov    al,0x1
  20c872:	86 05 98 47 04 00    	xchg   BYTE PTR [rip+0x44798],al        # 251010 <stderr_mutex>
  20c878:	84 c0                	test   al,al
  20c87a:	75 f4                	jne    20c870 <BmSimple.sfence+0x9b0>
    if (stderr_stream) |st| {
  20c87c:	48 8b 3d 85 47 04 00 	mov    rdi,QWORD PTR [rip+0x44785]        # 251008 <stderr_stream>
  20c883:	48 85 ff             	test   rdi,rdi
  20c886:	74 09                	je     20c891 <BmSimple.sfence+0x9d1>
  20c888:	48 8b 0d b1 f7 03 00 	mov    rcx,QWORD PTR [rip+0x3f7b1]        # 24c040 <stderr_file_out_stream+0x8>
  20c88f:	eb 3d                	jmp    20c8ce <BmSimple.sfence+0xa0e>
        stderr_file = try io.getStdErr();
  20c891:	c7 05 95 f7 03 00 02 	mov    DWORD PTR [rip+0x3f795],0x2        # 24c030 <stderr_file>
  20c898:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20c89b:	48 8d 05 8e f7 03 00 	lea    rax,[rip+0x3f78e]        # 24c030 <stderr_file>
  20c8a2:	48 89 05 8f f7 03 00 	mov    QWORD PTR [rip+0x3f78f],rax        # 24c038 <stderr_file_out_stream>
  20c8a9:	48 8d 05 f0 25 01 00 	lea    rax,[rip+0x125f0]        # 21eea0 <FileOutStream_writeFn>
  20c8b0:	48 89 05 89 f7 03 00 	mov    QWORD PTR [rip+0x3f789],rax        # 24c040 <stderr_file_out_stream+0x8>
  20c8b7:	48 8d 0d 82 f7 03 00 	lea    rcx,[rip+0x3f782]        # 24c040 <stderr_file_out_stream+0x8>
  20c8be:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20c8c1:	48 89 15 40 47 04 00 	mov    QWORD PTR [rip+0x44740],rdx        # 251008 <stderr_stream>
  20c8c8:	48 89 c1             	mov    rcx,rax
  20c8cb:	48 89 d7             	mov    rdi,rdx
        try output(context, fmt[start_index..]);
  20c8ce:	48 8d 35 1b 36 04 00 	lea    rsi,[rip+0x4361b]        # 24fef0 <__unnamed_3>
  20c8d5:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20c8d7:	31 c0                	xor    eax,eax
  20c8d9:	86 05 31 47 04 00    	xchg   BYTE PTR [rip+0x44731],al        # 251010 <stderr_mutex>
  20c8df:	3c 01                	cmp    al,0x1
    if (!ok) {
  20c8e1:	0f 85 f1 00 00 00    	jne    20c9d8 <BmSimple.sfence+0xb18>
            try pSelf.report(pSelf.results.items[pSelf.results.len - 1]); warn("\n");
  20c8e7:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  20c8ec:	48 8b 4c 24 78       	mov    rcx,QWORD PTR [rsp+0x78]
  20c8f1:	48 c1 e1 04          	shl    rcx,0x4
  20c8f5:	48 8d 34 08          	lea    rsi,[rax+rcx*1]
  20c8f9:	48 83 c6 f0          	add    rsi,0xfffffffffffffff0
  20c8fd:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  20c902:	c5 f8 77             	vzeroupper 
  20c905:	e8 16 66 00 00       	call   212f20 <Benchmark_report>
  20c90a:	66 85 c0             	test   ax,ax
  20c90d:	0f 85 b0 00 00 00    	jne    20c9c3 <BmSimple.sfence+0xb03>
  20c913:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20c91a:	84 00 00 00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20c920:	b0 01                	mov    al,0x1
  20c922:	86 05 e8 46 04 00    	xchg   BYTE PTR [rip+0x446e8],al        # 251010 <stderr_mutex>
  20c928:	84 c0                	test   al,al
  20c92a:	75 f4                	jne    20c920 <BmSimple.sfence+0xa60>
    if (stderr_stream) |st| {
  20c92c:	48 8b 3d d5 46 04 00 	mov    rdi,QWORD PTR [rip+0x446d5]        # 251008 <stderr_stream>
  20c933:	48 85 ff             	test   rdi,rdi
  20c936:	74 09                	je     20c941 <BmSimple.sfence+0xa81>
  20c938:	48 8b 0d 01 f7 03 00 	mov    rcx,QWORD PTR [rip+0x3f701]        # 24c040 <stderr_file_out_stream+0x8>
  20c93f:	eb 3d                	jmp    20c97e <BmSimple.sfence+0xabe>
        stderr_file = try io.getStdErr();
  20c941:	c7 05 e5 f6 03 00 02 	mov    DWORD PTR [rip+0x3f6e5],0x2        # 24c030 <stderr_file>
  20c948:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20c94b:	48 8d 05 de f6 03 00 	lea    rax,[rip+0x3f6de]        # 24c030 <stderr_file>
  20c952:	48 89 05 df f6 03 00 	mov    QWORD PTR [rip+0x3f6df],rax        # 24c038 <stderr_file_out_stream>
  20c959:	48 8d 05 40 25 01 00 	lea    rax,[rip+0x12540]        # 21eea0 <FileOutStream_writeFn>
  20c960:	48 89 05 d9 f6 03 00 	mov    QWORD PTR [rip+0x3f6d9],rax        # 24c040 <stderr_file_out_stream+0x8>
  20c967:	48 8d 0d d2 f6 03 00 	lea    rcx,[rip+0x3f6d2]        # 24c040 <stderr_file_out_stream+0x8>
  20c96e:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20c971:	48 89 15 90 46 04 00 	mov    QWORD PTR [rip+0x44690],rdx        # 251008 <stderr_stream>
  20c978:	48 89 c1             	mov    rcx,rax
  20c97b:	48 89 d7             	mov    rdi,rdx
  20c97e:	48 8d 35 6b 35 04 00 	lea    rsi,[rip+0x4356b]        # 24fef0 <__unnamed_3>
  20c985:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20c987:	31 c0                	xor    eax,eax
  20c989:	86 05 81 46 04 00    	xchg   BYTE PTR [rip+0x44681],al        # 251010 <stderr_mutex>
  20c98f:	3c 01                	cmp    al,0x1
    if (!ok) {
  20c991:	75 45                	jne    20c9d8 <BmSimple.sfence+0xb18>
  20c993:	49 83 c5 01          	add    r13,0x1
        while (rep < pSelf.repetitions) : (rep += 1) {
  20c997:	4c 3b 6c 24 40       	cmp    r13,QWORD PTR [rsp+0x40]
  20c99c:	0f 82 40 f9 ff ff    	jb     20c2e2 <BmSimple.sfence+0x422>
  20c9a2:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
        try pSelf.reportStats(pSelf.results);
  20c9a7:	48 8d 74 24 68       	lea    rsi,[rsp+0x68]
  20c9ac:	e8 4f 92 00 00       	call   215c00 <Benchmark_reportStats>
  20c9b1:	eb 10                	jmp    20c9c3 <BmSimple.sfence+0xb03>
                switch (errno) {
  20c9b3:	48 83 f9 16          	cmp    rcx,0x16
  20c9b7:	75 06                	jne    20c9bf <BmSimple.sfence+0xaff>
  20c9b9:	66 b8 02 00          	mov    ax,0x2
  20c9bd:	eb 04                	jmp    20c9c3 <BmSimple.sfence+0xb03>
  20c9bf:	66 b8 03 00          	mov    ax,0x3
    _ = try bm.run(struct {
  20c9c3:	48 81 c4 f8 00 00 00 	add    rsp,0xf8
  20c9ca:	5b                   	pop    rbx
  20c9cb:	41 5c                	pop    r12
  20c9cd:	41 5d                	pop    r13
  20c9cf:	41 5e                	pop    r14
  20c9d1:	41 5f                	pop    r15
  20c9d3:	5d                   	pop    rbp
  20c9d4:	c5 f8 77             	vzeroupper 
  20c9d7:	c3                   	ret    
            @panic("assertion failure");
  20c9d8:	48 8d 3d b1 33 04 00 	lea    rdi,[rip+0x433b1]        # 24fd90 <__unnamed_2>
  20c9df:	c5 f8 77             	vzeroupper 
  20c9e2:	e8 39 5d 00 00       	call   212720 <panic>
  20c9e7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  20c9ee:	00 00 

000000000020c9f0 <BmSimple.mfence>:
            sfence();
        }
    });
}

test "BmSimple.mfence" {
  20c9f0:	55                   	push   rbp
  20c9f1:	41 57                	push   r15
  20c9f3:	41 56                	push   r14
  20c9f5:	41 55                	push   r13
  20c9f7:	41 54                	push   r12
  20c9f9:	53                   	push   rbx
  20c9fa:	48 81 ec f8 00 00 00 	sub    rsp,0xf8
  20ca01:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20ca08:	0f 1f 84 00 00 00 00 
  20ca0f:	00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20ca10:	b0 01                	mov    al,0x1
  20ca12:	86 05 f8 45 04 00    	xchg   BYTE PTR [rip+0x445f8],al        # 251010 <stderr_mutex>
  20ca18:	84 c0                	test   al,al
  20ca1a:	75 f4                	jne    20ca10 <BmSimple.mfence+0x20>
    if (stderr_stream) |st| {
  20ca1c:	48 8b 3d e5 45 04 00 	mov    rdi,QWORD PTR [rip+0x445e5]        # 251008 <stderr_stream>
  20ca23:	48 85 ff             	test   rdi,rdi
  20ca26:	74 09                	je     20ca31 <BmSimple.mfence+0x41>
  20ca28:	48 8b 05 11 f6 03 00 	mov    rax,QWORD PTR [rip+0x3f611]        # 24c040 <stderr_file_out_stream+0x8>
  20ca2f:	eb 34                	jmp    20ca65 <BmSimple.mfence+0x75>
        stderr_file = try io.getStdErr();
  20ca31:	48 8d 05 f8 f5 03 00 	lea    rax,[rip+0x3f5f8]        # 24c030 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20ca38:	48 89 05 f9 f5 03 00 	mov    QWORD PTR [rip+0x3f5f9],rax        # 24c038 <stderr_file_out_stream>
  20ca3f:	48 8d 05 5a 24 01 00 	lea    rax,[rip+0x1245a]        # 21eea0 <FileOutStream_writeFn>
  20ca46:	48 89 05 f3 f5 03 00 	mov    QWORD PTR [rip+0x3f5f3],rax        # 24c040 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  20ca4d:	c7 05 d9 f5 03 00 02 	mov    DWORD PTR [rip+0x3f5d9],0x2        # 24c030 <stderr_file>
  20ca54:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20ca57:	48 8d 3d e2 f5 03 00 	lea    rdi,[rip+0x3f5e2]        # 24c040 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  20ca5e:	48 89 3d a3 45 04 00 	mov    QWORD PTR [rip+0x445a3],rdi        # 251008 <stderr_stream>
  20ca65:	48 8d 35 84 34 04 00 	lea    rsi,[rip+0x43484]        # 24fef0 <__unnamed_3>
  20ca6c:	ff d0                	call   rax
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20ca6e:	31 c0                	xor    eax,eax
  20ca70:	86 05 9a 45 04 00    	xchg   BYTE PTR [rip+0x4459a],al        # 251010 <stderr_mutex>
  20ca76:	3c 01                	cmp    al,0x1
    if (!ok) {
  20ca78:	0f 85 8a 0a 00 00    	jne    20d508 <BmSimple.mfence+0xb18>
    // Since this is a test print a \n before we run
    warn("\n");

    // Create an instance of Benchmark and run
    var bm = Benchmark.init("BmSimple.mfence", std.debug.global_allocator);
  20ca7e:	c5 f8 10 05 8a 32 04 	vmovups xmm0,XMMWORD PTR [rip+0x4328a]        # 24fd10 <__unnamed_10>
  20ca85:	00 
  20ca86:	c5 f8 29 44 24 20    	vmovaps XMMWORD PTR [rsp+0x20],xmm0
  20ca8c:	c5 fc 28 05 2c 37 ff 	vmovaps ymm0,YMMWORD PTR [rip+0xffffffffffff372c]        # 2001c0 <__unnamed_29-0x40>
  20ca93:	ff 
  20ca94:	c5 fc 11 44 24 30    	vmovups YMMWORD PTR [rsp+0x30],ymm0
  20ca9a:	c5 fa 6f 05 6e 38 ff 	vmovdqu xmm0,XMMWORD PTR [rip+0xffffffffffff386e]        # 200310 <__unnamed_35>
  20caa1:	ff 
  20caa2:	c5 f9 7f 44 24 50    	vmovdqa XMMWORD PTR [rsp+0x50],xmm0
  20caa8:	48 8d 05 51 f5 03 00 	lea    rax,[rip+0x3f551]        # 24c000 <global_fixed_allocator>
  20caaf:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  20cab4:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  20cab8:	c5 fa 7f 44 24 68    	vmovdqu XMMWORD PTR [rsp+0x68],xmm0
  20cabe:	48 c7 44 24 78 00 00 	mov    QWORD PTR [rsp+0x78],0x0
  20cac5:	00 00 
  20cac7:	48 89 84 24 80 00 00 	mov    QWORD PTR [rsp+0x80],rax
  20cace:	00 
  20cacf:	41 b6 01             	mov    r14b,0x1
  20cad2:	49 bf 00 e8 76 48 17 	movabs r15,0x174876e800
  20cad9:	00 00 00 
  20cadc:	bb 01 00 00 00       	mov    ebx,0x1
  20cae1:	4c 8d a4 24 90 00 00 	lea    r12,[rsp+0x90]
  20cae8:	00 
  20cae9:	45 31 ed             	xor    r13d,r13d
            while (iterations <= pSelf.max_iterations) {
  20caec:	4c 39 fb             	cmp    rbx,r15
  20caef:	0f 87 2e 03 00 00    	ja     20ce23 <BmSimple.mfence+0x433>
  20caf5:	eb 17                	jmp    20cb0e <BmSimple.mfence+0x11e>
  20caf7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  20cafe:	00 00 
                        warn("iteratons:{} numer:{} denom:{}\n", iterations, numer, denom);
  20cb00:	48 89 df             	mov    rdi,rbx
  20cb03:	48 89 ca             	mov    rdx,rcx
  20cb06:	c5 f8 77             	vzeroupper 
  20cb09:	e8 22 85 00 00       	call   215030 <warn.37>
                var ts: posix.timespec = undefined;
  20cb0e:	c5 fa 6f 05 fa 37 ff 	vmovdqu xmm0,XMMWORD PTR [rip+0xffffffffffff37fa]        # 200310 <__unnamed_35>
  20cb15:	ff 
  20cb16:	c5 f9 7f 84 24 90 00 	vmovdqa XMMWORD PTR [rsp+0x90],xmm0
  20cb1d:	00 00 
  20cb1f:	b8 e5 00 00 00       	mov    eax,0xe5
  20cb24:	bf 01 00 00 00       	mov    edi,0x1
  20cb29:	4c 89 e6             	mov    rsi,r12
  20cb2c:	0f 05                	syscall 
  20cb2e:	48 89 c1             	mov    rcx,rax
  20cb31:	48 f7 d9             	neg    rcx
  20cb34:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  20cb3a:	b8 00 00 00 00       	mov    eax,0x0
  20cb3f:	48 0f 46 c8          	cmovbe rcx,rax
                switch (errno) {
  20cb43:	48 85 c9             	test   rcx,rcx
  20cb46:	0f 85 97 09 00 00    	jne    20d4e3 <BmSimple.mfence+0xaf3>
        const f = @atomicLoad(@typeOf(init_vdso_clock_gettime), &vdso_clock_gettime, builtin.AtomicOrder.Unordered);
  20cb4c:	48 8b 05 c5 f5 03 00 	mov    rax,QWORD PTR [rip+0x3f5c5]        # 24c118 <vdso_clock_gettime>
        if (@ptrToInt(f) != 0) {
  20cb53:	48 85 c0             	test   rax,rax
  20cb56:	74 24                	je     20cb7c <BmSimple.mfence+0x18c>
            const rc = f(clk_id, tp);
  20cb58:	bf 01 00 00 00       	mov    edi,0x1
  20cb5d:	4c 89 e6             	mov    rsi,r12
  20cb60:	c5 f8 77             	vzeroupper 
  20cb63:	ff d0                	call   rax
            switch (rc) {
  20cb65:	48 83 f8 ea          	cmp    rax,0xffffffffffffffea
  20cb69:	0f 84 41 02 00 00    	je     20cdb0 <BmSimple.mfence+0x3c0>
  20cb6f:	48 85 c0             	test   rax,rax
  20cb72:	c5 fa 6f 05 96 37 ff 	vmovdqu xmm0,XMMWORD PTR [rip+0xffffffffffff3796]        # 200310 <__unnamed_35>
  20cb79:	ff 
  20cb7a:	74 0f                	je     20cb8b <BmSimple.mfence+0x19b>
  20cb7c:	b8 e4 00 00 00       	mov    eax,0xe4
  20cb81:	bf 01 00 00 00       	mov    edi,0x1
  20cb86:	4c 89 e6             	mov    rsi,r12
  20cb89:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  20cb8b:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
                if (errno != 0) return std.os.unexpectedErrorPosix(errno);
  20cb91:	0f 83 58 09 00 00    	jae    20d4ef <BmSimple.mfence+0xaff>
                self.start_time = @intCast(u64, ts.tv_sec) * u64(ns_per_s) + @intCast(u64, ts.tv_nsec);
  20cb97:	c5 f9 6f 8c 24 90 00 	vmovdqa xmm1,XMMWORD PTR [rsp+0x90]
  20cb9e:	00 00 
        while (iter > 0) : (iter -= 1) {
  20cba0:	48 85 db             	test   rbx,rbx
  20cba3:	74 14                	je     20cbb9 <BmSimple.mfence+0x1c9>
  20cba5:	48 89 d8             	mov    rax,rbx
  20cba8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  20cbaf:	00 
    asm volatile ("mfence": : :"memory");
  20cbb0:	0f ae f0             	mfence 
        while (iter > 0) : (iter -= 1) {
  20cbb3:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  20cbb7:	75 f7                	jne    20cbb0 <BmSimple.mfence+0x1c0>
        var ts: posix.timespec = undefined;
  20cbb9:	c5 f9 7f 84 24 90 00 	vmovdqa XMMWORD PTR [rsp+0x90],xmm0
  20cbc0:	00 00 
        const f = @atomicLoad(@typeOf(init_vdso_clock_gettime), &vdso_clock_gettime, builtin.AtomicOrder.Unordered);
  20cbc2:	48 8b 05 4f f5 03 00 	mov    rax,QWORD PTR [rip+0x3f54f]        # 24c118 <vdso_clock_gettime>
        if (@ptrToInt(f) != 0) {
  20cbc9:	48 85 c0             	test   rax,rax
  20cbcc:	74 2e                	je     20cbfc <BmSimple.mfence+0x20c>
  20cbce:	c5 f9 7f 8c 24 c0 00 	vmovdqa XMMWORD PTR [rsp+0xc0],xmm1
  20cbd5:	00 00 
            const rc = f(clk_id, tp);
  20cbd7:	bf 01 00 00 00       	mov    edi,0x1
  20cbdc:	4c 89 e6             	mov    rsi,r12
  20cbdf:	c5 f8 77             	vzeroupper 
  20cbe2:	ff d0                	call   rax
            switch (rc) {
  20cbe4:	48 83 f8 ea          	cmp    rax,0xffffffffffffffea
  20cbe8:	0f 84 db 01 00 00    	je     20cdc9 <BmSimple.mfence+0x3d9>
  20cbee:	48 85 c0             	test   rax,rax
  20cbf1:	c5 f9 6f 8c 24 c0 00 	vmovdqa xmm1,XMMWORD PTR [rsp+0xc0]
  20cbf8:	00 00 
  20cbfa:	74 0f                	je     20cc0b <BmSimple.mfence+0x21b>
  20cbfc:	b8 e4 00 00 00       	mov    eax,0xe4
  20cc01:	bf 01 00 00 00       	mov    edi,0x1
  20cc06:	4c 89 e6             	mov    rsi,r12
  20cc09:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  20cc0b:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
  20cc11:	0f 83 f1 08 00 00    	jae    20d508 <BmSimple.mfence+0xb18>
        return @intCast(u64, ts.tv_sec) * u64(ns_per_s) + @intCast(u64, ts.tv_nsec);
  20cc17:	c5 f9 6f 84 24 90 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x90]
  20cc1e:	00 00 
  20cc20:	c5 f9 fb c1          	vpsubq xmm0,xmm0,xmm1
  20cc24:	c4 e1 f9 7e c0       	vmovq  rax,xmm0
        var clock = clockNative() - self.start_time;
  20cc29:	c4 e3 f9 16 c5 01    	vpextrq rbp,xmm0,0x1
  20cc2f:	48 69 c0 00 ca 9a 3b 	imul   rax,rax,0x3b9aca00
  20cc36:	48 01 c5             	add    rbp,rax
                if ((run_time_ns >= pSelf.min_runtime_ns) or (iterations >= pSelf.max_iterations)) {
  20cc39:	48 3b 6c 24 38       	cmp    rbp,QWORD PTR [rsp+0x38]
  20cc3e:	0f 83 9f 01 00 00    	jae    20cde3 <BmSimple.mfence+0x3f3>
  20cc44:	4c 39 fb             	cmp    rbx,r15
  20cc47:	0f 83 96 01 00 00    	jae    20cde3 <BmSimple.mfence+0x3f3>
                    if (pSelf.logl >= 1) {
  20cc4d:	48 83 7c 24 30 00    	cmp    QWORD PTR [rsp+0x30],0x0
  20cc53:	0f 84 bd 00 00 00    	je     20cd16 <BmSimple.mfence+0x326>
                            Result {.run_time_ns = run_time_ns, .iterations = iterations});
  20cc59:	48 89 ac 24 d8 00 00 	mov    QWORD PTR [rsp+0xd8],rbp
  20cc60:	00 
  20cc61:	48 89 9c 24 e0 00 00 	mov    QWORD PTR [rsp+0xe0],rbx
  20cc68:	00 
                        try pSelf.report(
  20cc69:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  20cc6e:	48 8d b4 24 d8 00 00 	lea    rsi,[rsp+0xd8]
  20cc75:	00 
  20cc76:	c5 f8 77             	vzeroupper 
  20cc79:	e8 a2 62 00 00       	call   212f20 <Benchmark_report>
  20cc7e:	66 85 c0             	test   ax,ax
  20cc81:	0f 85 6c 08 00 00    	jne    20d4f3 <BmSimple.mfence+0xb03>
  20cc87:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  20cc8e:	00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20cc90:	b0 01                	mov    al,0x1
  20cc92:	86 05 78 43 04 00    	xchg   BYTE PTR [rip+0x44378],al        # 251010 <stderr_mutex>
  20cc98:	84 c0                	test   al,al
  20cc9a:	75 f4                	jne    20cc90 <BmSimple.mfence+0x2a0>
    if (stderr_stream) |st| {
  20cc9c:	48 8b 3d 65 43 04 00 	mov    rdi,QWORD PTR [rip+0x44365]        # 251008 <stderr_stream>
  20cca3:	48 85 ff             	test   rdi,rdi
  20cca6:	74 18                	je     20ccc0 <BmSimple.mfence+0x2d0>
  20cca8:	48 8b 0d 91 f3 03 00 	mov    rcx,QWORD PTR [rip+0x3f391]        # 24c040 <stderr_file_out_stream+0x8>
  20ccaf:	eb 4c                	jmp    20ccfd <BmSimple.mfence+0x30d>
  20ccb1:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20ccb8:	0f 1f 84 00 00 00 00 
  20ccbf:	00 
        stderr_file = try io.getStdErr();
  20ccc0:	c7 05 66 f3 03 00 02 	mov    DWORD PTR [rip+0x3f366],0x2        # 24c030 <stderr_file>
  20ccc7:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20ccca:	48 8d 05 5f f3 03 00 	lea    rax,[rip+0x3f35f]        # 24c030 <stderr_file>
  20ccd1:	48 89 05 60 f3 03 00 	mov    QWORD PTR [rip+0x3f360],rax        # 24c038 <stderr_file_out_stream>
  20ccd8:	48 8d 05 c1 21 01 00 	lea    rax,[rip+0x121c1]        # 21eea0 <FileOutStream_writeFn>
  20ccdf:	48 89 05 5a f3 03 00 	mov    QWORD PTR [rip+0x3f35a],rax        # 24c040 <stderr_file_out_stream+0x8>
  20cce6:	48 8d 0d 53 f3 03 00 	lea    rcx,[rip+0x3f353]        # 24c040 <stderr_file_out_stream+0x8>
  20cced:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20ccf0:	48 89 15 11 43 04 00 	mov    QWORD PTR [rip+0x44311],rdx        # 251008 <stderr_stream>
  20ccf7:	48 89 c1             	mov    rcx,rax
  20ccfa:	48 89 d7             	mov    rdi,rdx
  20ccfd:	48 8d 35 ec 31 04 00 	lea    rsi,[rip+0x431ec]        # 24fef0 <__unnamed_3>
  20cd04:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20cd06:	31 c0                	xor    eax,eax
  20cd08:	86 05 02 43 04 00    	xchg   BYTE PTR [rip+0x44302],al        # 251010 <stderr_mutex>
  20cd0e:	3c 01                	cmp    al,0x1
    if (!ok) {
  20cd10:	0f 85 f2 07 00 00    	jne    20d508 <BmSimple.mfence+0xb18>
                    if (run_time_ns < 1000) {
  20cd16:	48 81 fd e8 03 00 00 	cmp    rbp,0x3e8
  20cd1d:	73 31                	jae    20cd50 <BmSimple.mfence+0x360>
  20cd1f:	b9 01 00 00 00       	mov    ecx,0x1
  20cd24:	be e8 03 00 00       	mov    esi,0x3e8
                    iterations = (iterations * numer) / denom;
  20cd29:	48 0f af de          	imul   rbx,rsi
  20cd2d:	48 89 d8             	mov    rax,rbx
  20cd30:	48 c1 e8 20          	shr    rax,0x20
  20cd34:	74 54                	je     20cd8a <BmSimple.mfence+0x39a>
  20cd36:	31 d2                	xor    edx,edx
  20cd38:	48 89 d8             	mov    rax,rbx
  20cd3b:	48 f7 f1             	div    rcx
  20cd3e:	48 89 c3             	mov    rbx,rax
  20cd41:	eb 4f                	jmp    20cd92 <BmSimple.mfence+0x3a2>
  20cd43:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20cd4a:	84 00 00 00 00 00 
                    } else if (run_time_ns < (pSelf.min_runtime_ns / 10)) {
  20cd50:	48 ba cd cc cc cc cc 	movabs rdx,0xcccccccccccccccd
  20cd57:	cc cc cc 
  20cd5a:	c4 e2 fb f6 4c 24 38 	mulx   rcx,rax,QWORD PTR [rsp+0x38]
  20cd61:	48 c1 e9 03          	shr    rcx,0x3
  20cd65:	31 c0                	xor    eax,eax
  20cd67:	48 39 cd             	cmp    rbp,rcx
  20cd6a:	0f 93 c0             	setae  al
  20cd6d:	48 8d 0c c0          	lea    rcx,[rax+rax*8]
  20cd71:	48 83 c1 01          	add    rcx,0x1
  20cd75:	48 8d 34 85 0a 00 00 	lea    rsi,[rax*4+0xa]
  20cd7c:	00 
                    iterations = (iterations * numer) / denom;
  20cd7d:	48 0f af de          	imul   rbx,rsi
  20cd81:	48 89 d8             	mov    rax,rbx
  20cd84:	48 c1 e8 20          	shr    rax,0x20
  20cd88:	75 ac                	jne    20cd36 <BmSimple.mfence+0x346>
  20cd8a:	31 d2                	xor    edx,edx
  20cd8c:	89 d8                	mov    eax,ebx
  20cd8e:	f7 f1                	div    ecx
  20cd90:	89 c3                	mov    ebx,eax
                    if (iterations > pSelf.max_iterations) {
  20cd92:	4c 8b 7c 24 48       	mov    r15,QWORD PTR [rsp+0x48]
  20cd97:	4c 39 fb             	cmp    rbx,r15
  20cd9a:	49 0f 47 df          	cmova  rbx,r15
                    if (pSelf.logl >= 2) {
  20cd9e:	48 83 7c 24 30 02    	cmp    QWORD PTR [rsp+0x30],0x2
  20cda4:	0f 82 64 fd ff ff    	jb     20cb0e <BmSimple.mfence+0x11e>
  20cdaa:	e9 51 fd ff ff       	jmp    20cb00 <BmSimple.mfence+0x110>
  20cdaf:	90                   	nop
  20cdb0:	c5 fa 6f 05 58 35 ff 	vmovdqu xmm0,XMMWORD PTR [rip+0xffffffffffff3558]        # 200310 <__unnamed_35>
  20cdb7:	ff 
  20cdb8:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
                if (errno != 0) return std.os.unexpectedErrorPosix(errno);
  20cdbe:	0f 82 d3 fd ff ff    	jb     20cb97 <BmSimple.mfence+0x1a7>
  20cdc4:	e9 26 07 00 00       	jmp    20d4ef <BmSimple.mfence+0xaff>
  20cdc9:	c5 f9 6f 8c 24 c0 00 	vmovdqa xmm1,XMMWORD PTR [rsp+0xc0]
  20cdd0:	00 00 
  20cdd2:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
  20cdd8:	0f 82 39 fe ff ff    	jb     20cc17 <BmSimple.mfence+0x227>
  20cdde:	e9 25 07 00 00       	jmp    20d508 <BmSimple.mfence+0xb18>
                            Result { .run_time_ns = run_time_ns, .iterations = iterations});
  20cde3:	48 89 ac 24 e8 00 00 	mov    QWORD PTR [rsp+0xe8],rbp
  20cdea:	00 
  20cdeb:	48 89 9c 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rbx
  20cdf2:	00 
                    try pSelf.results.append(
  20cdf3:	48 8d 7c 24 68       	lea    rdi,[rsp+0x68]
  20cdf8:	48 8d b4 24 e8 00 00 	lea    rsi,[rsp+0xe8]
  20cdff:	00 
  20ce00:	c5 f8 77             	vzeroupper 
  20ce03:	e8 a8 5f 00 00       	call   212db0 <AlignedArrayList(Result,8)_append>
  20ce08:	66 85 c0             	test   ax,ax
  20ce0b:	74 16                	je     20ce23 <BmSimple.mfence+0x433>
  20ce0d:	e9 e1 06 00 00       	jmp    20d4f3 <BmSimple.mfence+0xb03>
            while (iterations <= pSelf.max_iterations) {
  20ce12:	4c 8b 7c 24 48       	mov    r15,QWORD PTR [rsp+0x48]
  20ce17:	45 31 f6             	xor    r14d,r14d
  20ce1a:	4c 39 fb             	cmp    rbx,r15
  20ce1d:	0f 86 eb fc ff ff    	jbe    20cb0e <BmSimple.mfence+0x11e>
            if (once) {
  20ce23:	41 f6 c6 01          	test   r14b,0x1
  20ce27:	48 8d 6c 24 0f       	lea    rbp,[rsp+0xf]
  20ce2c:	4c 8d 74 24 10       	lea    r14,[rsp+0x10]
  20ce31:	0f 84 e0 05 00 00    	je     20d417 <BmSimple.mfence+0xa27>
                try leftJustified(22, "name repetitions:{}", pSelf.repetitions);
  20ce37:	48 8b 7c 24 40       	mov    rdi,QWORD PTR [rsp+0x40]
  20ce3c:	c5 f8 77             	vzeroupper 
  20ce3f:	e8 5c 85 00 00       	call   2153a0 <Benchmark_leftJustified>
  20ce44:	66 85 c0             	test   ax,ax
  20ce47:	0f 85 a6 06 00 00    	jne    20d4f3 <BmSimple.mfence+0xb03>
                try rightJustified(14, "{}", "iterations");
  20ce4d:	e8 ee 87 00 00       	call   215640 <Benchmark_rightJustified>
  20ce52:	66 85 c0             	test   ax,ax
  20ce55:	0f 85 98 06 00 00    	jne    20d4f3 <BmSimple.mfence+0xb03>
        var buffer: [40]u8 = undefined;
  20ce5b:	c5 fe 6f 05 ec 90 ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffff90ec]        # 205f4f <__unnamed_7>
  20ce62:	ff 
  20ce63:	c5 fe 7f 84 24 90 00 	vmovdqu YMMWORD PTR [rsp+0x90],ymm0
  20ce6a:	00 00 
  20ce6c:	48 8b 05 fc 90 ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffff90fc]        # 205f6f <__unnamed_7+0x20>
  20ce73:	48 89 84 24 b0 00 00 	mov    QWORD PTR [rsp+0xb0],rax
  20ce7a:	00 
  20ce7b:	c7 84 24 90 00 00 00 	mov    DWORD PTR [rsp+0x90],0x656d6974
  20ce82:	74 69 6d 65 
  20ce86:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  20ce8d:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20ce90:	b0 01                	mov    al,0x1
  20ce92:	86 05 78 41 04 00    	xchg   BYTE PTR [rip+0x44178],al        # 251010 <stderr_mutex>
  20ce98:	84 c0                	test   al,al
  20ce9a:	75 f4                	jne    20ce90 <BmSimple.mfence+0x4a0>
    if (stderr_stream) |st| {
  20ce9c:	48 8b 3d 65 41 04 00 	mov    rdi,QWORD PTR [rip+0x44165]        # 251008 <stderr_stream>
  20cea3:	48 85 ff             	test   rdi,rdi
  20cea6:	74 09                	je     20ceb1 <BmSimple.mfence+0x4c1>
  20cea8:	48 8b 0d 91 f1 03 00 	mov    rcx,QWORD PTR [rip+0x3f191]        # 24c040 <stderr_file_out_stream+0x8>
  20ceaf:	eb 3d                	jmp    20ceee <BmSimple.mfence+0x4fe>
        stderr_file = try io.getStdErr();
  20ceb1:	c7 05 75 f1 03 00 02 	mov    DWORD PTR [rip+0x3f175],0x2        # 24c030 <stderr_file>
  20ceb8:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20cebb:	48 8d 05 6e f1 03 00 	lea    rax,[rip+0x3f16e]        # 24c030 <stderr_file>
  20cec2:	48 89 05 6f f1 03 00 	mov    QWORD PTR [rip+0x3f16f],rax        # 24c038 <stderr_file_out_stream>
  20cec9:	48 8d 05 d0 1f 01 00 	lea    rax,[rip+0x11fd0]        # 21eea0 <FileOutStream_writeFn>
  20ced0:	48 89 05 69 f1 03 00 	mov    QWORD PTR [rip+0x3f169],rax        # 24c040 <stderr_file_out_stream+0x8>
  20ced7:	48 8d 0d 62 f1 03 00 	lea    rcx,[rip+0x3f162]        # 24c040 <stderr_file_out_stream+0x8>
  20cede:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20cee1:	48 89 15 20 41 04 00 	mov    QWORD PTR [rip+0x44120],rdx        # 251008 <stderr_stream>
  20cee8:	48 89 c1             	mov    rcx,rax
  20ceeb:	48 89 d7             	mov    rdi,rdx
  20ceee:	c6 44 24 0f 20       	mov    BYTE PTR [rsp+0xf],0x20
    return output(context, (*[1]u8)(&c)[0..]);
  20cef3:	48 89 6c 24 10       	mov    QWORD PTR [rsp+0x10],rbp
  20cef8:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  20ceff:	00 00 
  20cf01:	4c 89 f6             	mov    rsi,r14
  20cf04:	c5 f8 77             	vzeroupper 
  20cf07:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20cf09:	31 c0                	xor    eax,eax
  20cf0b:	86 05 ff 40 04 00    	xchg   BYTE PTR [rip+0x440ff],al        # 251010 <stderr_mutex>
  20cf11:	3c 01                	cmp    al,0x1
    if (!ok) {
  20cf13:	0f 85 ef 05 00 00    	jne    20d508 <BmSimple.mfence+0xb18>
  20cf19:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20cf20:	b0 01                	mov    al,0x1
  20cf22:	86 05 e8 40 04 00    	xchg   BYTE PTR [rip+0x440e8],al        # 251010 <stderr_mutex>
  20cf28:	84 c0                	test   al,al
  20cf2a:	75 f4                	jne    20cf20 <BmSimple.mfence+0x530>
    if (stderr_stream) |st| {
  20cf2c:	48 8b 3d d5 40 04 00 	mov    rdi,QWORD PTR [rip+0x440d5]        # 251008 <stderr_stream>
  20cf33:	48 85 ff             	test   rdi,rdi
  20cf36:	74 09                	je     20cf41 <BmSimple.mfence+0x551>
  20cf38:	48 8b 0d 01 f1 03 00 	mov    rcx,QWORD PTR [rip+0x3f101]        # 24c040 <stderr_file_out_stream+0x8>
  20cf3f:	eb 3d                	jmp    20cf7e <BmSimple.mfence+0x58e>
        stderr_file = try io.getStdErr();
  20cf41:	c7 05 e5 f0 03 00 02 	mov    DWORD PTR [rip+0x3f0e5],0x2        # 24c030 <stderr_file>
  20cf48:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20cf4b:	48 8d 05 de f0 03 00 	lea    rax,[rip+0x3f0de]        # 24c030 <stderr_file>
  20cf52:	48 89 05 df f0 03 00 	mov    QWORD PTR [rip+0x3f0df],rax        # 24c038 <stderr_file_out_stream>
  20cf59:	48 8d 05 40 1f 01 00 	lea    rax,[rip+0x11f40]        # 21eea0 <FileOutStream_writeFn>
  20cf60:	48 89 05 d9 f0 03 00 	mov    QWORD PTR [rip+0x3f0d9],rax        # 24c040 <stderr_file_out_stream+0x8>
  20cf67:	48 8d 0d d2 f0 03 00 	lea    rcx,[rip+0x3f0d2]        # 24c040 <stderr_file_out_stream+0x8>
  20cf6e:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20cf71:	48 89 15 90 40 04 00 	mov    QWORD PTR [rip+0x44090],rdx        # 251008 <stderr_stream>
  20cf78:	48 89 c1             	mov    rcx,rax
  20cf7b:	48 89 d7             	mov    rdi,rdx
  20cf7e:	c6 44 24 0f 20       	mov    BYTE PTR [rsp+0xf],0x20
  20cf83:	48 89 6c 24 10       	mov    QWORD PTR [rsp+0x10],rbp
  20cf88:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  20cf8f:	00 00 
  20cf91:	4c 89 f6             	mov    rsi,r14
  20cf94:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20cf96:	31 c0                	xor    eax,eax
  20cf98:	86 05 72 40 04 00    	xchg   BYTE PTR [rip+0x44072],al        # 251010 <stderr_mutex>
  20cf9e:	3c 01                	cmp    al,0x1
    if (!ok) {
  20cfa0:	0f 85 62 05 00 00    	jne    20d508 <BmSimple.mfence+0xb18>
  20cfa6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  20cfad:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20cfb0:	b0 01                	mov    al,0x1
  20cfb2:	86 05 58 40 04 00    	xchg   BYTE PTR [rip+0x44058],al        # 251010 <stderr_mutex>
  20cfb8:	84 c0                	test   al,al
  20cfba:	75 f4                	jne    20cfb0 <BmSimple.mfence+0x5c0>
    if (stderr_stream) |st| {
  20cfbc:	48 8b 3d 45 40 04 00 	mov    rdi,QWORD PTR [rip+0x44045]        # 251008 <stderr_stream>
  20cfc3:	48 85 ff             	test   rdi,rdi
  20cfc6:	74 09                	je     20cfd1 <BmSimple.mfence+0x5e1>
  20cfc8:	48 8b 0d 71 f0 03 00 	mov    rcx,QWORD PTR [rip+0x3f071]        # 24c040 <stderr_file_out_stream+0x8>
  20cfcf:	eb 3d                	jmp    20d00e <BmSimple.mfence+0x61e>
        stderr_file = try io.getStdErr();
  20cfd1:	c7 05 55 f0 03 00 02 	mov    DWORD PTR [rip+0x3f055],0x2        # 24c030 <stderr_file>
  20cfd8:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20cfdb:	48 8d 05 4e f0 03 00 	lea    rax,[rip+0x3f04e]        # 24c030 <stderr_file>
  20cfe2:	48 89 05 4f f0 03 00 	mov    QWORD PTR [rip+0x3f04f],rax        # 24c038 <stderr_file_out_stream>
  20cfe9:	48 8d 05 b0 1e 01 00 	lea    rax,[rip+0x11eb0]        # 21eea0 <FileOutStream_writeFn>
  20cff0:	48 89 05 49 f0 03 00 	mov    QWORD PTR [rip+0x3f049],rax        # 24c040 <stderr_file_out_stream+0x8>
  20cff7:	48 8d 0d 42 f0 03 00 	lea    rcx,[rip+0x3f042]        # 24c040 <stderr_file_out_stream+0x8>
  20cffe:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20d001:	48 89 15 00 40 04 00 	mov    QWORD PTR [rip+0x44000],rdx        # 251008 <stderr_stream>
  20d008:	48 89 c1             	mov    rcx,rax
  20d00b:	48 89 d7             	mov    rdi,rdx
  20d00e:	c6 44 24 0f 20       	mov    BYTE PTR [rsp+0xf],0x20
  20d013:	48 89 6c 24 10       	mov    QWORD PTR [rsp+0x10],rbp
  20d018:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  20d01f:	00 00 
  20d021:	4c 89 f6             	mov    rsi,r14
  20d024:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20d026:	31 c0                	xor    eax,eax
  20d028:	86 05 e2 3f 04 00    	xchg   BYTE PTR [rip+0x43fe2],al        # 251010 <stderr_mutex>
  20d02e:	3c 01                	cmp    al,0x1
    if (!ok) {
  20d030:	0f 85 d2 04 00 00    	jne    20d508 <BmSimple.mfence+0xb18>
  20d036:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  20d03d:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20d040:	b0 01                	mov    al,0x1
  20d042:	86 05 c8 3f 04 00    	xchg   BYTE PTR [rip+0x43fc8],al        # 251010 <stderr_mutex>
  20d048:	84 c0                	test   al,al
  20d04a:	75 f4                	jne    20d040 <BmSimple.mfence+0x650>
    if (stderr_stream) |st| {
  20d04c:	48 8b 3d b5 3f 04 00 	mov    rdi,QWORD PTR [rip+0x43fb5]        # 251008 <stderr_stream>
  20d053:	48 85 ff             	test   rdi,rdi
  20d056:	74 09                	je     20d061 <BmSimple.mfence+0x671>
  20d058:	48 8b 0d e1 ef 03 00 	mov    rcx,QWORD PTR [rip+0x3efe1]        # 24c040 <stderr_file_out_stream+0x8>
  20d05f:	eb 3d                	jmp    20d09e <BmSimple.mfence+0x6ae>
        stderr_file = try io.getStdErr();
  20d061:	c7 05 c5 ef 03 00 02 	mov    DWORD PTR [rip+0x3efc5],0x2        # 24c030 <stderr_file>
  20d068:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20d06b:	48 8d 05 be ef 03 00 	lea    rax,[rip+0x3efbe]        # 24c030 <stderr_file>
  20d072:	48 89 05 bf ef 03 00 	mov    QWORD PTR [rip+0x3efbf],rax        # 24c038 <stderr_file_out_stream>
  20d079:	48 8d 05 20 1e 01 00 	lea    rax,[rip+0x11e20]        # 21eea0 <FileOutStream_writeFn>
  20d080:	48 89 05 b9 ef 03 00 	mov    QWORD PTR [rip+0x3efb9],rax        # 24c040 <stderr_file_out_stream+0x8>
  20d087:	48 8d 0d b2 ef 03 00 	lea    rcx,[rip+0x3efb2]        # 24c040 <stderr_file_out_stream+0x8>
  20d08e:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20d091:	48 89 15 70 3f 04 00 	mov    QWORD PTR [rip+0x43f70],rdx        # 251008 <stderr_stream>
  20d098:	48 89 c1             	mov    rcx,rax
  20d09b:	48 89 d7             	mov    rdi,rdx
  20d09e:	c6 44 24 0f 20       	mov    BYTE PTR [rsp+0xf],0x20
  20d0a3:	48 89 6c 24 10       	mov    QWORD PTR [rsp+0x10],rbp
  20d0a8:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  20d0af:	00 00 
  20d0b1:	4c 89 f6             	mov    rsi,r14
  20d0b4:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20d0b6:	31 c0                	xor    eax,eax
  20d0b8:	86 05 52 3f 04 00    	xchg   BYTE PTR [rip+0x43f52],al        # 251010 <stderr_mutex>
  20d0be:	3c 01                	cmp    al,0x1
    if (!ok) {
  20d0c0:	0f 85 42 04 00 00    	jne    20d508 <BmSimple.mfence+0xb18>
  20d0c6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  20d0cd:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20d0d0:	b0 01                	mov    al,0x1
  20d0d2:	86 05 38 3f 04 00    	xchg   BYTE PTR [rip+0x43f38],al        # 251010 <stderr_mutex>
  20d0d8:	84 c0                	test   al,al
  20d0da:	75 f4                	jne    20d0d0 <BmSimple.mfence+0x6e0>
    if (stderr_stream) |st| {
  20d0dc:	48 8b 3d 25 3f 04 00 	mov    rdi,QWORD PTR [rip+0x43f25]        # 251008 <stderr_stream>
  20d0e3:	48 85 ff             	test   rdi,rdi
  20d0e6:	74 09                	je     20d0f1 <BmSimple.mfence+0x701>
  20d0e8:	48 8b 0d 51 ef 03 00 	mov    rcx,QWORD PTR [rip+0x3ef51]        # 24c040 <stderr_file_out_stream+0x8>
  20d0ef:	eb 3d                	jmp    20d12e <BmSimple.mfence+0x73e>
        stderr_file = try io.getStdErr();
  20d0f1:	c7 05 35 ef 03 00 02 	mov    DWORD PTR [rip+0x3ef35],0x2        # 24c030 <stderr_file>
  20d0f8:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20d0fb:	48 8d 05 2e ef 03 00 	lea    rax,[rip+0x3ef2e]        # 24c030 <stderr_file>
  20d102:	48 89 05 2f ef 03 00 	mov    QWORD PTR [rip+0x3ef2f],rax        # 24c038 <stderr_file_out_stream>
  20d109:	48 8d 05 90 1d 01 00 	lea    rax,[rip+0x11d90]        # 21eea0 <FileOutStream_writeFn>
  20d110:	48 89 05 29 ef 03 00 	mov    QWORD PTR [rip+0x3ef29],rax        # 24c040 <stderr_file_out_stream+0x8>
  20d117:	48 8d 0d 22 ef 03 00 	lea    rcx,[rip+0x3ef22]        # 24c040 <stderr_file_out_stream+0x8>
  20d11e:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20d121:	48 89 15 e0 3e 04 00 	mov    QWORD PTR [rip+0x43ee0],rdx        # 251008 <stderr_stream>
  20d128:	48 89 c1             	mov    rcx,rax
  20d12b:	48 89 d7             	mov    rdi,rdx
  20d12e:	c6 44 24 0f 20       	mov    BYTE PTR [rsp+0xf],0x20
  20d133:	48 89 6c 24 10       	mov    QWORD PTR [rsp+0x10],rbp
  20d138:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  20d13f:	00 00 
  20d141:	4c 89 f6             	mov    rsi,r14
  20d144:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20d146:	31 c0                	xor    eax,eax
  20d148:	86 05 c2 3e 04 00    	xchg   BYTE PTR [rip+0x43ec2],al        # 251010 <stderr_mutex>
  20d14e:	3c 01                	cmp    al,0x1
    if (!ok) {
  20d150:	0f 85 b2 03 00 00    	jne    20d508 <BmSimple.mfence+0xb18>
  20d156:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  20d15d:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20d160:	b0 01                	mov    al,0x1
  20d162:	86 05 a8 3e 04 00    	xchg   BYTE PTR [rip+0x43ea8],al        # 251010 <stderr_mutex>
  20d168:	84 c0                	test   al,al
  20d16a:	75 f4                	jne    20d160 <BmSimple.mfence+0x770>
    if (stderr_stream) |st| {
  20d16c:	48 8b 3d 95 3e 04 00 	mov    rdi,QWORD PTR [rip+0x43e95]        # 251008 <stderr_stream>
  20d173:	48 85 ff             	test   rdi,rdi
  20d176:	74 09                	je     20d181 <BmSimple.mfence+0x791>
  20d178:	48 8b 0d c1 ee 03 00 	mov    rcx,QWORD PTR [rip+0x3eec1]        # 24c040 <stderr_file_out_stream+0x8>
  20d17f:	eb 3d                	jmp    20d1be <BmSimple.mfence+0x7ce>
        stderr_file = try io.getStdErr();
  20d181:	c7 05 a5 ee 03 00 02 	mov    DWORD PTR [rip+0x3eea5],0x2        # 24c030 <stderr_file>
  20d188:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20d18b:	48 8d 05 9e ee 03 00 	lea    rax,[rip+0x3ee9e]        # 24c030 <stderr_file>
  20d192:	48 89 05 9f ee 03 00 	mov    QWORD PTR [rip+0x3ee9f],rax        # 24c038 <stderr_file_out_stream>
  20d199:	48 8d 05 00 1d 01 00 	lea    rax,[rip+0x11d00]        # 21eea0 <FileOutStream_writeFn>
  20d1a0:	48 89 05 99 ee 03 00 	mov    QWORD PTR [rip+0x3ee99],rax        # 24c040 <stderr_file_out_stream+0x8>
  20d1a7:	48 8d 0d 92 ee 03 00 	lea    rcx,[rip+0x3ee92]        # 24c040 <stderr_file_out_stream+0x8>
  20d1ae:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20d1b1:	48 89 15 50 3e 04 00 	mov    QWORD PTR [rip+0x43e50],rdx        # 251008 <stderr_stream>
  20d1b8:	48 89 c1             	mov    rcx,rax
  20d1bb:	48 89 d7             	mov    rdi,rdx
  20d1be:	c6 44 24 0f 20       	mov    BYTE PTR [rsp+0xf],0x20
  20d1c3:	48 89 6c 24 10       	mov    QWORD PTR [rsp+0x10],rbp
  20d1c8:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  20d1cf:	00 00 
  20d1d1:	4c 89 f6             	mov    rsi,r14
  20d1d4:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20d1d6:	31 c0                	xor    eax,eax
  20d1d8:	86 05 32 3e 04 00    	xchg   BYTE PTR [rip+0x43e32],al        # 251010 <stderr_mutex>
  20d1de:	3c 01                	cmp    al,0x1
    if (!ok) {
  20d1e0:	0f 85 22 03 00 00    	jne    20d508 <BmSimple.mfence+0xb18>
  20d1e6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  20d1ed:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20d1f0:	b0 01                	mov    al,0x1
  20d1f2:	86 05 18 3e 04 00    	xchg   BYTE PTR [rip+0x43e18],al        # 251010 <stderr_mutex>
  20d1f8:	84 c0                	test   al,al
  20d1fa:	75 f4                	jne    20d1f0 <BmSimple.mfence+0x800>
    if (stderr_stream) |st| {
  20d1fc:	48 8b 3d 05 3e 04 00 	mov    rdi,QWORD PTR [rip+0x43e05]        # 251008 <stderr_stream>
  20d203:	48 85 ff             	test   rdi,rdi
  20d206:	74 09                	je     20d211 <BmSimple.mfence+0x821>
  20d208:	48 8b 0d 31 ee 03 00 	mov    rcx,QWORD PTR [rip+0x3ee31]        # 24c040 <stderr_file_out_stream+0x8>
  20d20f:	eb 3d                	jmp    20d24e <BmSimple.mfence+0x85e>
        stderr_file = try io.getStdErr();
  20d211:	c7 05 15 ee 03 00 02 	mov    DWORD PTR [rip+0x3ee15],0x2        # 24c030 <stderr_file>
  20d218:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20d21b:	48 8d 05 0e ee 03 00 	lea    rax,[rip+0x3ee0e]        # 24c030 <stderr_file>
  20d222:	48 89 05 0f ee 03 00 	mov    QWORD PTR [rip+0x3ee0f],rax        # 24c038 <stderr_file_out_stream>
  20d229:	48 8d 05 70 1c 01 00 	lea    rax,[rip+0x11c70]        # 21eea0 <FileOutStream_writeFn>
  20d230:	48 89 05 09 ee 03 00 	mov    QWORD PTR [rip+0x3ee09],rax        # 24c040 <stderr_file_out_stream+0x8>
  20d237:	48 8d 0d 02 ee 03 00 	lea    rcx,[rip+0x3ee02]        # 24c040 <stderr_file_out_stream+0x8>
  20d23e:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20d241:	48 89 15 c0 3d 04 00 	mov    QWORD PTR [rip+0x43dc0],rdx        # 251008 <stderr_stream>
  20d248:	48 89 c1             	mov    rcx,rax
  20d24b:	48 89 d7             	mov    rdi,rdx
  20d24e:	c6 44 24 0f 20       	mov    BYTE PTR [rsp+0xf],0x20
  20d253:	48 89 6c 24 10       	mov    QWORD PTR [rsp+0x10],rbp
  20d258:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  20d25f:	00 00 
  20d261:	4c 89 f6             	mov    rsi,r14
  20d264:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20d266:	31 c0                	xor    eax,eax
  20d268:	86 05 a2 3d 04 00    	xchg   BYTE PTR [rip+0x43da2],al        # 251010 <stderr_mutex>
  20d26e:	3c 01                	cmp    al,0x1
    if (!ok) {
  20d270:	0f 85 92 02 00 00    	jne    20d508 <BmSimple.mfence+0xb18>
  20d276:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  20d27d:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20d280:	b0 01                	mov    al,0x1
  20d282:	86 05 88 3d 04 00    	xchg   BYTE PTR [rip+0x43d88],al        # 251010 <stderr_mutex>
  20d288:	84 c0                	test   al,al
  20d28a:	75 f4                	jne    20d280 <BmSimple.mfence+0x890>
    if (stderr_stream) |st| {
  20d28c:	48 8b 3d 75 3d 04 00 	mov    rdi,QWORD PTR [rip+0x43d75]        # 251008 <stderr_stream>
  20d293:	48 85 ff             	test   rdi,rdi
  20d296:	74 09                	je     20d2a1 <BmSimple.mfence+0x8b1>
  20d298:	48 8b 0d a1 ed 03 00 	mov    rcx,QWORD PTR [rip+0x3eda1]        # 24c040 <stderr_file_out_stream+0x8>
  20d29f:	eb 3d                	jmp    20d2de <BmSimple.mfence+0x8ee>
        stderr_file = try io.getStdErr();
  20d2a1:	c7 05 85 ed 03 00 02 	mov    DWORD PTR [rip+0x3ed85],0x2        # 24c030 <stderr_file>
  20d2a8:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20d2ab:	48 8d 05 7e ed 03 00 	lea    rax,[rip+0x3ed7e]        # 24c030 <stderr_file>
  20d2b2:	48 89 05 7f ed 03 00 	mov    QWORD PTR [rip+0x3ed7f],rax        # 24c038 <stderr_file_out_stream>
  20d2b9:	48 8d 05 e0 1b 01 00 	lea    rax,[rip+0x11be0]        # 21eea0 <FileOutStream_writeFn>
  20d2c0:	48 89 05 79 ed 03 00 	mov    QWORD PTR [rip+0x3ed79],rax        # 24c040 <stderr_file_out_stream+0x8>
  20d2c7:	48 8d 0d 72 ed 03 00 	lea    rcx,[rip+0x3ed72]        # 24c040 <stderr_file_out_stream+0x8>
  20d2ce:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20d2d1:	48 89 15 30 3d 04 00 	mov    QWORD PTR [rip+0x43d30],rdx        # 251008 <stderr_stream>
  20d2d8:	48 89 c1             	mov    rcx,rax
  20d2db:	48 89 d7             	mov    rdi,rdx
  20d2de:	c6 44 24 0f 20       	mov    BYTE PTR [rsp+0xf],0x20
  20d2e3:	48 89 6c 24 10       	mov    QWORD PTR [rsp+0x10],rbp
  20d2e8:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  20d2ef:	00 00 
  20d2f1:	4c 89 f6             	mov    rsi,r14
  20d2f4:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20d2f6:	31 c0                	xor    eax,eax
  20d2f8:	86 05 12 3d 04 00    	xchg   BYTE PTR [rip+0x43d12],al        # 251010 <stderr_mutex>
  20d2fe:	3c 01                	cmp    al,0x1
    if (!ok) {
  20d300:	0f 85 02 02 00 00    	jne    20d508 <BmSimple.mfence+0xb18>
  20d306:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  20d30d:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20d310:	b0 01                	mov    al,0x1
  20d312:	86 05 f8 3c 04 00    	xchg   BYTE PTR [rip+0x43cf8],al        # 251010 <stderr_mutex>
  20d318:	84 c0                	test   al,al
  20d31a:	75 f4                	jne    20d310 <BmSimple.mfence+0x920>
    if (stderr_stream) |st| {
  20d31c:	48 8b 3d e5 3c 04 00 	mov    rdi,QWORD PTR [rip+0x43ce5]        # 251008 <stderr_stream>
  20d323:	48 85 ff             	test   rdi,rdi
  20d326:	74 09                	je     20d331 <BmSimple.mfence+0x941>
  20d328:	48 8b 0d 11 ed 03 00 	mov    rcx,QWORD PTR [rip+0x3ed11]        # 24c040 <stderr_file_out_stream+0x8>
  20d32f:	eb 3d                	jmp    20d36e <BmSimple.mfence+0x97e>
        stderr_file = try io.getStdErr();
  20d331:	c7 05 f5 ec 03 00 02 	mov    DWORD PTR [rip+0x3ecf5],0x2        # 24c030 <stderr_file>
  20d338:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20d33b:	48 8d 05 ee ec 03 00 	lea    rax,[rip+0x3ecee]        # 24c030 <stderr_file>
  20d342:	48 89 05 ef ec 03 00 	mov    QWORD PTR [rip+0x3ecef],rax        # 24c038 <stderr_file_out_stream>
  20d349:	48 8d 05 50 1b 01 00 	lea    rax,[rip+0x11b50]        # 21eea0 <FileOutStream_writeFn>
  20d350:	48 89 05 e9 ec 03 00 	mov    QWORD PTR [rip+0x3ece9],rax        # 24c040 <stderr_file_out_stream+0x8>
  20d357:	48 8d 0d e2 ec 03 00 	lea    rcx,[rip+0x3ece2]        # 24c040 <stderr_file_out_stream+0x8>
  20d35e:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20d361:	48 89 15 a0 3c 04 00 	mov    QWORD PTR [rip+0x43ca0],rdx        # 251008 <stderr_stream>
  20d368:	48 89 c1             	mov    rcx,rax
  20d36b:	48 89 d7             	mov    rdi,rdx
                const casted_value = ([]const u8)(value);
  20d36e:	4c 89 64 24 10       	mov    QWORD PTR [rsp+0x10],r12
  20d373:	48 c7 44 24 18 04 00 	mov    QWORD PTR [rsp+0x18],0x4
  20d37a:	00 00 
                return output(context, casted_value);
  20d37c:	4c 89 f6             	mov    rsi,r14
  20d37f:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20d381:	31 c0                	xor    eax,eax
  20d383:	86 05 87 3c 04 00    	xchg   BYTE PTR [rip+0x43c87],al        # 251010 <stderr_mutex>
  20d389:	3c 01                	cmp    al,0x1
    if (!ok) {
  20d38b:	0f 85 77 01 00 00    	jne    20d508 <BmSimple.mfence+0xb18>
                try rightJustified(18, "{}", "time/operation");
  20d391:	e8 8a 85 00 00       	call   215920 <Benchmark_rightJustified.39>
  20d396:	66 85 c0             	test   ax,ax
  20d399:	0f 85 54 01 00 00    	jne    20d4f3 <BmSimple.mfence+0xb03>
  20d39f:	90                   	nop
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20d3a0:	b0 01                	mov    al,0x1
  20d3a2:	86 05 68 3c 04 00    	xchg   BYTE PTR [rip+0x43c68],al        # 251010 <stderr_mutex>
  20d3a8:	84 c0                	test   al,al
  20d3aa:	75 f4                	jne    20d3a0 <BmSimple.mfence+0x9b0>
    if (stderr_stream) |st| {
  20d3ac:	48 8b 3d 55 3c 04 00 	mov    rdi,QWORD PTR [rip+0x43c55]        # 251008 <stderr_stream>
  20d3b3:	48 85 ff             	test   rdi,rdi
  20d3b6:	74 09                	je     20d3c1 <BmSimple.mfence+0x9d1>
  20d3b8:	48 8b 0d 81 ec 03 00 	mov    rcx,QWORD PTR [rip+0x3ec81]        # 24c040 <stderr_file_out_stream+0x8>
  20d3bf:	eb 3d                	jmp    20d3fe <BmSimple.mfence+0xa0e>
        stderr_file = try io.getStdErr();
  20d3c1:	c7 05 65 ec 03 00 02 	mov    DWORD PTR [rip+0x3ec65],0x2        # 24c030 <stderr_file>
  20d3c8:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20d3cb:	48 8d 05 5e ec 03 00 	lea    rax,[rip+0x3ec5e]        # 24c030 <stderr_file>
  20d3d2:	48 89 05 5f ec 03 00 	mov    QWORD PTR [rip+0x3ec5f],rax        # 24c038 <stderr_file_out_stream>
  20d3d9:	48 8d 05 c0 1a 01 00 	lea    rax,[rip+0x11ac0]        # 21eea0 <FileOutStream_writeFn>
  20d3e0:	48 89 05 59 ec 03 00 	mov    QWORD PTR [rip+0x3ec59],rax        # 24c040 <stderr_file_out_stream+0x8>
  20d3e7:	48 8d 0d 52 ec 03 00 	lea    rcx,[rip+0x3ec52]        # 24c040 <stderr_file_out_stream+0x8>
  20d3ee:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20d3f1:	48 89 15 10 3c 04 00 	mov    QWORD PTR [rip+0x43c10],rdx        # 251008 <stderr_stream>
  20d3f8:	48 89 c1             	mov    rcx,rax
  20d3fb:	48 89 d7             	mov    rdi,rdx
        try output(context, fmt[start_index..]);
  20d3fe:	48 8d 35 eb 2a 04 00 	lea    rsi,[rip+0x42aeb]        # 24fef0 <__unnamed_3>
  20d405:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20d407:	31 c0                	xor    eax,eax
  20d409:	86 05 01 3c 04 00    	xchg   BYTE PTR [rip+0x43c01],al        # 251010 <stderr_mutex>
  20d40f:	3c 01                	cmp    al,0x1
    if (!ok) {
  20d411:	0f 85 f1 00 00 00    	jne    20d508 <BmSimple.mfence+0xb18>
            try pSelf.report(pSelf.results.items[pSelf.results.len - 1]); warn("\n");
  20d417:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  20d41c:	48 8b 4c 24 78       	mov    rcx,QWORD PTR [rsp+0x78]
  20d421:	48 c1 e1 04          	shl    rcx,0x4
  20d425:	48 8d 34 08          	lea    rsi,[rax+rcx*1]
  20d429:	48 83 c6 f0          	add    rsi,0xfffffffffffffff0
  20d42d:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  20d432:	c5 f8 77             	vzeroupper 
  20d435:	e8 e6 5a 00 00       	call   212f20 <Benchmark_report>
  20d43a:	66 85 c0             	test   ax,ax
  20d43d:	0f 85 b0 00 00 00    	jne    20d4f3 <BmSimple.mfence+0xb03>
  20d443:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20d44a:	84 00 00 00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20d450:	b0 01                	mov    al,0x1
  20d452:	86 05 b8 3b 04 00    	xchg   BYTE PTR [rip+0x43bb8],al        # 251010 <stderr_mutex>
  20d458:	84 c0                	test   al,al
  20d45a:	75 f4                	jne    20d450 <BmSimple.mfence+0xa60>
    if (stderr_stream) |st| {
  20d45c:	48 8b 3d a5 3b 04 00 	mov    rdi,QWORD PTR [rip+0x43ba5]        # 251008 <stderr_stream>
  20d463:	48 85 ff             	test   rdi,rdi
  20d466:	74 09                	je     20d471 <BmSimple.mfence+0xa81>
  20d468:	48 8b 0d d1 eb 03 00 	mov    rcx,QWORD PTR [rip+0x3ebd1]        # 24c040 <stderr_file_out_stream+0x8>
  20d46f:	eb 3d                	jmp    20d4ae <BmSimple.mfence+0xabe>
        stderr_file = try io.getStdErr();
  20d471:	c7 05 b5 eb 03 00 02 	mov    DWORD PTR [rip+0x3ebb5],0x2        # 24c030 <stderr_file>
  20d478:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20d47b:	48 8d 05 ae eb 03 00 	lea    rax,[rip+0x3ebae]        # 24c030 <stderr_file>
  20d482:	48 89 05 af eb 03 00 	mov    QWORD PTR [rip+0x3ebaf],rax        # 24c038 <stderr_file_out_stream>
  20d489:	48 8d 05 10 1a 01 00 	lea    rax,[rip+0x11a10]        # 21eea0 <FileOutStream_writeFn>
  20d490:	48 89 05 a9 eb 03 00 	mov    QWORD PTR [rip+0x3eba9],rax        # 24c040 <stderr_file_out_stream+0x8>
  20d497:	48 8d 0d a2 eb 03 00 	lea    rcx,[rip+0x3eba2]        # 24c040 <stderr_file_out_stream+0x8>
  20d49e:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20d4a1:	48 89 15 60 3b 04 00 	mov    QWORD PTR [rip+0x43b60],rdx        # 251008 <stderr_stream>
  20d4a8:	48 89 c1             	mov    rcx,rax
  20d4ab:	48 89 d7             	mov    rdi,rdx
  20d4ae:	48 8d 35 3b 2a 04 00 	lea    rsi,[rip+0x42a3b]        # 24fef0 <__unnamed_3>
  20d4b5:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20d4b7:	31 c0                	xor    eax,eax
  20d4b9:	86 05 51 3b 04 00    	xchg   BYTE PTR [rip+0x43b51],al        # 251010 <stderr_mutex>
  20d4bf:	3c 01                	cmp    al,0x1
    if (!ok) {
  20d4c1:	75 45                	jne    20d508 <BmSimple.mfence+0xb18>
  20d4c3:	49 83 c5 01          	add    r13,0x1
        while (rep < pSelf.repetitions) : (rep += 1) {
  20d4c7:	4c 3b 6c 24 40       	cmp    r13,QWORD PTR [rsp+0x40]
  20d4cc:	0f 82 40 f9 ff ff    	jb     20ce12 <BmSimple.mfence+0x422>
  20d4d2:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
        try pSelf.reportStats(pSelf.results);
  20d4d7:	48 8d 74 24 68       	lea    rsi,[rsp+0x68]
  20d4dc:	e8 1f 87 00 00       	call   215c00 <Benchmark_reportStats>
  20d4e1:	eb 10                	jmp    20d4f3 <BmSimple.mfence+0xb03>
                switch (errno) {
  20d4e3:	48 83 f9 16          	cmp    rcx,0x16
  20d4e7:	75 06                	jne    20d4ef <BmSimple.mfence+0xaff>
  20d4e9:	66 b8 02 00          	mov    ax,0x2
  20d4ed:	eb 04                	jmp    20d4f3 <BmSimple.mfence+0xb03>
  20d4ef:	66 b8 03 00          	mov    ax,0x3
    _ = try bm.run(struct {
  20d4f3:	48 81 c4 f8 00 00 00 	add    rsp,0xf8
  20d4fa:	5b                   	pop    rbx
  20d4fb:	41 5c                	pop    r12
  20d4fd:	41 5d                	pop    r13
  20d4ff:	41 5e                	pop    r14
  20d501:	41 5f                	pop    r15
  20d503:	5d                   	pop    rbp
  20d504:	c5 f8 77             	vzeroupper 
  20d507:	c3                   	ret    
            @panic("assertion failure");
  20d508:	48 8d 3d 81 28 04 00 	lea    rdi,[rip+0x42881]        # 24fd90 <__unnamed_2>
  20d50f:	c5 f8 77             	vzeroupper 
  20d512:	e8 09 52 00 00       	call   212720 <panic>
  20d517:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  20d51e:	00 00 

000000000020d520 <BmPoor.init>:
//   20d6ce:	00 00 
//         var ts: posix.timespec = undefined;
//   20d6d0:	c5 f9 7f 84 24 90 00 	vmovdqa XMMWORD PTR [rsp+0x90],xmm0
//   20d6d7:	00 00 

test "BmPoor.init" {
  20d520:	55                   	push   rbp
  20d521:	41 57                	push   r15
  20d523:	41 56                	push   r14
  20d525:	41 55                	push   r13
  20d527:	41 54                	push   r12
  20d529:	53                   	push   rbx
  20d52a:	48 81 ec f8 00 00 00 	sub    rsp,0xf8
  20d531:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20d538:	0f 1f 84 00 00 00 00 
  20d53f:	00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20d540:	b0 01                	mov    al,0x1
  20d542:	86 05 c8 3a 04 00    	xchg   BYTE PTR [rip+0x43ac8],al        # 251010 <stderr_mutex>
  20d548:	84 c0                	test   al,al
  20d54a:	75 f4                	jne    20d540 <BmPoor.init+0x20>
    if (stderr_stream) |st| {
  20d54c:	48 8b 3d b5 3a 04 00 	mov    rdi,QWORD PTR [rip+0x43ab5]        # 251008 <stderr_stream>
  20d553:	48 85 ff             	test   rdi,rdi
  20d556:	74 09                	je     20d561 <BmPoor.init+0x41>
  20d558:	48 8b 05 e1 ea 03 00 	mov    rax,QWORD PTR [rip+0x3eae1]        # 24c040 <stderr_file_out_stream+0x8>
  20d55f:	eb 34                	jmp    20d595 <BmPoor.init+0x75>
        stderr_file = try io.getStdErr();
  20d561:	48 8d 05 c8 ea 03 00 	lea    rax,[rip+0x3eac8]        # 24c030 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20d568:	48 89 05 c9 ea 03 00 	mov    QWORD PTR [rip+0x3eac9],rax        # 24c038 <stderr_file_out_stream>
  20d56f:	48 8d 05 2a 19 01 00 	lea    rax,[rip+0x1192a]        # 21eea0 <FileOutStream_writeFn>
  20d576:	48 89 05 c3 ea 03 00 	mov    QWORD PTR [rip+0x3eac3],rax        # 24c040 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  20d57d:	c7 05 a9 ea 03 00 02 	mov    DWORD PTR [rip+0x3eaa9],0x2        # 24c030 <stderr_file>
  20d584:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20d587:	48 8d 3d b2 ea 03 00 	lea    rdi,[rip+0x3eab2]        # 24c040 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  20d58e:	48 89 3d 73 3a 04 00 	mov    QWORD PTR [rip+0x43a73],rdi        # 251008 <stderr_stream>
  20d595:	48 8d 35 54 29 04 00 	lea    rsi,[rip+0x42954]        # 24fef0 <__unnamed_3>
  20d59c:	ff d0                	call   rax
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20d59e:	31 c0                	xor    eax,eax
  20d5a0:	86 05 6a 3a 04 00    	xchg   BYTE PTR [rip+0x43a6a],al        # 251010 <stderr_mutex>
  20d5a6:	3c 01                	cmp    al,0x1
    if (!ok) {
  20d5a8:	0f 85 49 0b 00 00    	jne    20e0f7 <BmPoor.init+0xbd7>
    // Since this is a test print a \n before we run
    warn("\n");

    // Test fn benchmark(pSelf) can return an error
    var bm = Benchmark.init("BmPoor.init", std.debug.global_allocator);
  20d5ae:	c5 f8 10 05 6a 27 04 	vmovups xmm0,XMMWORD PTR [rip+0x4276a]        # 24fd20 <__unnamed_11>
  20d5b5:	00 
  20d5b6:	c5 f8 29 44 24 20    	vmovaps XMMWORD PTR [rsp+0x20],xmm0
  20d5bc:	c5 fc 28 05 fc 2b ff 	vmovaps ymm0,YMMWORD PTR [rip+0xffffffffffff2bfc]        # 2001c0 <__unnamed_29-0x40>
  20d5c3:	ff 
  20d5c4:	c5 fc 11 44 24 30    	vmovups YMMWORD PTR [rsp+0x30],ymm0
  20d5ca:	c5 fa 6f 05 3e 2d ff 	vmovdqu xmm0,XMMWORD PTR [rip+0xffffffffffff2d3e]        # 200310 <__unnamed_35>
  20d5d1:	ff 
  20d5d2:	c5 f9 7f 44 24 50    	vmovdqa XMMWORD PTR [rsp+0x50],xmm0
  20d5d8:	48 8d 05 21 ea 03 00 	lea    rax,[rip+0x3ea21]        # 24c000 <global_fixed_allocator>
  20d5df:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  20d5e4:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  20d5e8:	c5 fa 7f 44 24 68    	vmovdqu XMMWORD PTR [rsp+0x68],xmm0
  20d5ee:	48 c7 44 24 78 00 00 	mov    QWORD PTR [rsp+0x78],0x0
  20d5f5:	00 00 
  20d5f7:	48 89 84 24 80 00 00 	mov    QWORD PTR [rsp+0x80],rax
  20d5fe:	00 
  20d5ff:	b1 01                	mov    cl,0x1
  20d601:	48 bd 00 e8 76 48 17 	movabs rbp,0x174876e800
  20d608:	00 00 00 
  20d60b:	bb 01 00 00 00       	mov    ebx,0x1
  20d610:	4c 8d a4 24 90 00 00 	lea    r12,[rsp+0x90]
  20d617:	00 
  20d618:	45 31 f6             	xor    r14d,r14d
  20d61b:	45 31 ed             	xor    r13d,r13d
            while (iterations <= pSelf.max_iterations) {
  20d61e:	48 39 eb             	cmp    rbx,rbp
  20d621:	0f 87 39 03 00 00    	ja     20d960 <BmPoor.init+0x440>
  20d627:	89 4c 24 1c          	mov    DWORD PTR [rsp+0x1c],ecx
  20d62b:	eb 11                	jmp    20d63e <BmPoor.init+0x11e>
  20d62d:	0f 1f 00             	nop    DWORD PTR [rax]
                        warn("iteratons:{} numer:{} denom:{}\n", iterations, numer, denom);
  20d630:	48 89 df             	mov    rdi,rbx
  20d633:	48 89 ca             	mov    rdx,rcx
  20d636:	c5 f8 77             	vzeroupper 
  20d639:	e8 f2 79 00 00       	call   215030 <warn.37>
                var ts: posix.timespec = undefined;
  20d63e:	c5 fa 6f 05 ca 2c ff 	vmovdqu xmm0,XMMWORD PTR [rip+0xffffffffffff2cca]        # 200310 <__unnamed_35>
  20d645:	ff 
  20d646:	c5 f9 7f 84 24 90 00 	vmovdqa XMMWORD PTR [rsp+0x90],xmm0
  20d64d:	00 00 
  20d64f:	b8 e5 00 00 00       	mov    eax,0xe5
  20d654:	bf 01 00 00 00       	mov    edi,0x1
  20d659:	4c 89 e6             	mov    rsi,r12
  20d65c:	0f 05                	syscall 
  20d65e:	48 89 c1             	mov    rcx,rax
  20d661:	48 f7 d9             	neg    rcx
  20d664:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  20d66a:	b8 00 00 00 00       	mov    eax,0x0
  20d66f:	48 0f 46 c8          	cmovbe rcx,rax
                switch (errno) {
  20d673:	48 85 c9             	test   rcx,rcx
  20d676:	0f 85 56 0a 00 00    	jne    20e0d2 <BmPoor.init+0xbb2>
        const f = @atomicLoad(@typeOf(init_vdso_clock_gettime), &vdso_clock_gettime, builtin.AtomicOrder.Unordered);
  20d67c:	48 8b 05 95 ea 03 00 	mov    rax,QWORD PTR [rip+0x3ea95]        # 24c118 <vdso_clock_gettime>
        if (@ptrToInt(f) != 0) {
  20d683:	48 85 c0             	test   rax,rax
  20d686:	74 24                	je     20d6ac <BmPoor.init+0x18c>
            const rc = f(clk_id, tp);
  20d688:	bf 01 00 00 00       	mov    edi,0x1
  20d68d:	4c 89 e6             	mov    rsi,r12
  20d690:	c5 f8 77             	vzeroupper 
  20d693:	ff d0                	call   rax
            switch (rc) {
  20d695:	48 83 f8 ea          	cmp    rax,0xffffffffffffffea
  20d699:	0f 84 31 02 00 00    	je     20d8d0 <BmPoor.init+0x3b0>
  20d69f:	48 85 c0             	test   rax,rax
  20d6a2:	c5 fa 6f 05 66 2c ff 	vmovdqu xmm0,XMMWORD PTR [rip+0xffffffffffff2c66]        # 200310 <__unnamed_35>
  20d6a9:	ff 
  20d6aa:	74 0f                	je     20d6bb <BmPoor.init+0x19b>
  20d6ac:	b8 e4 00 00 00       	mov    eax,0xe4
  20d6b1:	bf 01 00 00 00       	mov    edi,0x1
  20d6b6:	4c 89 e6             	mov    rsi,r12
  20d6b9:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  20d6bb:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
                if (errno != 0) return std.os.unexpectedErrorPosix(errno);
  20d6c1:	0f 83 17 0a 00 00    	jae    20e0de <BmPoor.init+0xbbe>
                self.start_time = @intCast(u64, ts.tv_sec) * u64(ns_per_s) + @intCast(u64, ts.tv_nsec);
  20d6c7:	c5 f9 6f 8c 24 90 00 	vmovdqa xmm1,XMMWORD PTR [rsp+0x90]
  20d6ce:	00 00 
        var ts: posix.timespec = undefined;
  20d6d0:	c5 f9 7f 84 24 90 00 	vmovdqa XMMWORD PTR [rsp+0x90],xmm0
  20d6d7:	00 00 
        const f = @atomicLoad(@typeOf(init_vdso_clock_gettime), &vdso_clock_gettime, builtin.AtomicOrder.Unordered);
  20d6d9:	48 8b 05 38 ea 03 00 	mov    rax,QWORD PTR [rip+0x3ea38]        # 24c118 <vdso_clock_gettime>
        if (@ptrToInt(f) != 0) {
  20d6e0:	48 85 c0             	test   rax,rax
  20d6e3:	74 2e                	je     20d713 <BmPoor.init+0x1f3>
  20d6e5:	c5 f9 7f 8c 24 c0 00 	vmovdqa XMMWORD PTR [rsp+0xc0],xmm1
  20d6ec:	00 00 
            const rc = f(clk_id, tp);
  20d6ee:	bf 01 00 00 00       	mov    edi,0x1
  20d6f3:	4c 89 e6             	mov    rsi,r12
  20d6f6:	c5 f8 77             	vzeroupper 
  20d6f9:	ff d0                	call   rax
            switch (rc) {
  20d6fb:	48 83 f8 ea          	cmp    rax,0xffffffffffffffea
  20d6ff:	0f 84 e4 01 00 00    	je     20d8e9 <BmPoor.init+0x3c9>
  20d705:	48 85 c0             	test   rax,rax
  20d708:	c5 f9 6f 8c 24 c0 00 	vmovdqa xmm1,XMMWORD PTR [rsp+0xc0]
  20d70f:	00 00 
  20d711:	74 0f                	je     20d722 <BmPoor.init+0x202>
  20d713:	b8 e4 00 00 00       	mov    eax,0xe4
  20d718:	bf 01 00 00 00       	mov    edi,0x1
  20d71d:	4c 89 e6             	mov    rsi,r12
  20d720:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  20d722:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
  20d728:	0f 83 c9 09 00 00    	jae    20e0f7 <BmPoor.init+0xbd7>
  20d72e:	49 01 dd             	add    r13,rbx
        return @intCast(u64, ts.tv_sec) * u64(ns_per_s) + @intCast(u64, ts.tv_nsec);
  20d731:	c5 f9 6f 84 24 90 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x90]
  20d738:	00 00 
  20d73a:	c5 f9 fb c1          	vpsubq xmm0,xmm0,xmm1
  20d73e:	c4 e1 f9 7e c0       	vmovq  rax,xmm0
        var clock = clockNative() - self.start_time;
  20d743:	c4 c3 f9 16 c7 01    	vpextrq r15,xmm0,0x1
  20d749:	48 69 c0 00 ca 9a 3b 	imul   rax,rax,0x3b9aca00
  20d750:	49 01 c7             	add    r15,rax
                if ((run_time_ns >= pSelf.min_runtime_ns) or (iterations >= pSelf.max_iterations)) {
  20d753:	4c 3b 7c 24 38       	cmp    r15,QWORD PTR [rsp+0x38]
  20d758:	0f 83 b2 01 00 00    	jae    20d910 <BmPoor.init+0x3f0>
  20d75e:	48 39 eb             	cmp    rbx,rbp
  20d761:	0f 83 a9 01 00 00    	jae    20d910 <BmPoor.init+0x3f0>
                    if (pSelf.logl >= 1) {
  20d767:	48 83 7c 24 30 00    	cmp    QWORD PTR [rsp+0x30],0x0
  20d76d:	0f 84 c3 00 00 00    	je     20d836 <BmPoor.init+0x316>
                            Result {.run_time_ns = run_time_ns, .iterations = iterations});
  20d773:	4c 89 bc 24 d8 00 00 	mov    QWORD PTR [rsp+0xd8],r15
  20d77a:	00 
  20d77b:	48 89 9c 24 e0 00 00 	mov    QWORD PTR [rsp+0xe0],rbx
  20d782:	00 
                        try pSelf.report(
  20d783:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  20d788:	48 8d b4 24 d8 00 00 	lea    rsi,[rsp+0xd8]
  20d78f:	00 
  20d790:	c5 f8 77             	vzeroupper 
  20d793:	e8 88 57 00 00       	call   212f20 <Benchmark_report>
  20d798:	66 85 c0             	test   ax,ax
  20d79b:	0f 85 41 09 00 00    	jne    20e0e2 <BmPoor.init+0xbc2>
  20d7a1:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20d7a8:	0f 1f 84 00 00 00 00 
  20d7af:	00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20d7b0:	b0 01                	mov    al,0x1
  20d7b2:	86 05 58 38 04 00    	xchg   BYTE PTR [rip+0x43858],al        # 251010 <stderr_mutex>
  20d7b8:	84 c0                	test   al,al
  20d7ba:	75 f4                	jne    20d7b0 <BmPoor.init+0x290>
    if (stderr_stream) |st| {
  20d7bc:	48 8b 3d 45 38 04 00 	mov    rdi,QWORD PTR [rip+0x43845]        # 251008 <stderr_stream>
  20d7c3:	48 85 ff             	test   rdi,rdi
  20d7c6:	74 18                	je     20d7e0 <BmPoor.init+0x2c0>
  20d7c8:	48 8b 0d 71 e8 03 00 	mov    rcx,QWORD PTR [rip+0x3e871]        # 24c040 <stderr_file_out_stream+0x8>
  20d7cf:	eb 4c                	jmp    20d81d <BmPoor.init+0x2fd>
  20d7d1:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20d7d8:	0f 1f 84 00 00 00 00 
  20d7df:	00 
        stderr_file = try io.getStdErr();
  20d7e0:	c7 05 46 e8 03 00 02 	mov    DWORD PTR [rip+0x3e846],0x2        # 24c030 <stderr_file>
  20d7e7:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20d7ea:	48 8d 05 3f e8 03 00 	lea    rax,[rip+0x3e83f]        # 24c030 <stderr_file>
  20d7f1:	48 89 05 40 e8 03 00 	mov    QWORD PTR [rip+0x3e840],rax        # 24c038 <stderr_file_out_stream>
  20d7f8:	48 8d 05 a1 16 01 00 	lea    rax,[rip+0x116a1]        # 21eea0 <FileOutStream_writeFn>
  20d7ff:	48 89 05 3a e8 03 00 	mov    QWORD PTR [rip+0x3e83a],rax        # 24c040 <stderr_file_out_stream+0x8>
  20d806:	48 8d 0d 33 e8 03 00 	lea    rcx,[rip+0x3e833]        # 24c040 <stderr_file_out_stream+0x8>
  20d80d:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20d810:	48 89 15 f1 37 04 00 	mov    QWORD PTR [rip+0x437f1],rdx        # 251008 <stderr_stream>
  20d817:	48 89 c1             	mov    rcx,rax
  20d81a:	48 89 d7             	mov    rdi,rdx
  20d81d:	48 8d 35 cc 26 04 00 	lea    rsi,[rip+0x426cc]        # 24fef0 <__unnamed_3>
  20d824:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20d826:	31 c0                	xor    eax,eax
  20d828:	86 05 e2 37 04 00    	xchg   BYTE PTR [rip+0x437e2],al        # 251010 <stderr_mutex>
  20d82e:	3c 01                	cmp    al,0x1
    if (!ok) {
  20d830:	0f 85 c1 08 00 00    	jne    20e0f7 <BmPoor.init+0xbd7>
                    if (run_time_ns < 1000) {
  20d836:	49 81 ff e8 03 00 00 	cmp    r15,0x3e8
  20d83d:	73 31                	jae    20d870 <BmPoor.init+0x350>
  20d83f:	b9 01 00 00 00       	mov    ecx,0x1
  20d844:	be e8 03 00 00       	mov    esi,0x3e8
                    iterations = (iterations * numer) / denom;
  20d849:	48 0f af de          	imul   rbx,rsi
  20d84d:	48 89 d8             	mov    rax,rbx
  20d850:	48 c1 e8 20          	shr    rax,0x20
  20d854:	74 54                	je     20d8aa <BmPoor.init+0x38a>
  20d856:	31 d2                	xor    edx,edx
  20d858:	48 89 d8             	mov    rax,rbx
  20d85b:	48 f7 f1             	div    rcx
  20d85e:	48 89 c3             	mov    rbx,rax
  20d861:	eb 4f                	jmp    20d8b2 <BmPoor.init+0x392>
  20d863:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20d86a:	84 00 00 00 00 00 
                    } else if (run_time_ns < (pSelf.min_runtime_ns / 10)) {
  20d870:	48 ba cd cc cc cc cc 	movabs rdx,0xcccccccccccccccd
  20d877:	cc cc cc 
  20d87a:	c4 e2 fb f6 4c 24 38 	mulx   rcx,rax,QWORD PTR [rsp+0x38]
  20d881:	48 c1 e9 03          	shr    rcx,0x3
  20d885:	31 c0                	xor    eax,eax
  20d887:	49 39 cf             	cmp    r15,rcx
  20d88a:	0f 93 c0             	setae  al
  20d88d:	48 8d 0c c0          	lea    rcx,[rax+rax*8]
  20d891:	48 83 c1 01          	add    rcx,0x1
  20d895:	48 8d 34 85 0a 00 00 	lea    rsi,[rax*4+0xa]
  20d89c:	00 
                    iterations = (iterations * numer) / denom;
  20d89d:	48 0f af de          	imul   rbx,rsi
  20d8a1:	48 89 d8             	mov    rax,rbx
  20d8a4:	48 c1 e8 20          	shr    rax,0x20
  20d8a8:	75 ac                	jne    20d856 <BmPoor.init+0x336>
  20d8aa:	31 d2                	xor    edx,edx
  20d8ac:	89 d8                	mov    eax,ebx
  20d8ae:	f7 f1                	div    ecx
  20d8b0:	89 c3                	mov    ebx,eax
                    if (iterations > pSelf.max_iterations) {
  20d8b2:	48 8b 6c 24 48       	mov    rbp,QWORD PTR [rsp+0x48]
  20d8b7:	48 39 eb             	cmp    rbx,rbp
  20d8ba:	48 0f 47 dd          	cmova  rbx,rbp
                    if (pSelf.logl >= 2) {
  20d8be:	48 83 7c 24 30 02    	cmp    QWORD PTR [rsp+0x30],0x2
  20d8c4:	0f 82 74 fd ff ff    	jb     20d63e <BmPoor.init+0x11e>
  20d8ca:	e9 61 fd ff ff       	jmp    20d630 <BmPoor.init+0x110>
  20d8cf:	90                   	nop
  20d8d0:	c5 fa 6f 05 38 2a ff 	vmovdqu xmm0,XMMWORD PTR [rip+0xffffffffffff2a38]        # 200310 <__unnamed_35>
  20d8d7:	ff 
  20d8d8:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
                if (errno != 0) return std.os.unexpectedErrorPosix(errno);
  20d8de:	0f 82 e3 fd ff ff    	jb     20d6c7 <BmPoor.init+0x1a7>
  20d8e4:	e9 f5 07 00 00       	jmp    20e0de <BmPoor.init+0xbbe>
  20d8e9:	c5 f9 6f 8c 24 c0 00 	vmovdqa xmm1,XMMWORD PTR [rsp+0xc0]
  20d8f0:	00 00 
  20d8f2:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
  20d8f8:	0f 82 30 fe ff ff    	jb     20d72e <BmPoor.init+0x20e>
  20d8fe:	e9 f4 07 00 00       	jmp    20e0f7 <BmPoor.init+0xbd7>
  20d903:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20d90a:	84 00 00 00 00 00 
                            Result { .run_time_ns = run_time_ns, .iterations = iterations});
  20d910:	4c 89 bc 24 e8 00 00 	mov    QWORD PTR [rsp+0xe8],r15
  20d917:	00 
  20d918:	48 89 9c 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rbx
  20d91f:	00 
                    try pSelf.results.append(
  20d920:	48 8d 7c 24 68       	lea    rdi,[rsp+0x68]
  20d925:	48 8d b4 24 e8 00 00 	lea    rsi,[rsp+0xe8]
  20d92c:	00 
  20d92d:	c5 f8 77             	vzeroupper 
  20d930:	e8 7b 54 00 00       	call   212db0 <AlignedArrayList(Result,8)_append>
  20d935:	66 85 c0             	test   ax,ax
  20d938:	8b 4c 24 1c          	mov    ecx,DWORD PTR [rsp+0x1c]
  20d93c:	74 22                	je     20d960 <BmPoor.init+0x440>
  20d93e:	e9 9f 07 00 00       	jmp    20e0e2 <BmPoor.init+0xbc2>
  20d943:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20d94a:	84 00 00 00 00 00 
            while (iterations <= pSelf.max_iterations) {
  20d950:	48 8b 6c 24 48       	mov    rbp,QWORD PTR [rsp+0x48]
  20d955:	31 c9                	xor    ecx,ecx
  20d957:	48 39 eb             	cmp    rbx,rbp
  20d95a:	0f 86 c7 fc ff ff    	jbe    20d627 <BmPoor.init+0x107>
            if (once) {
  20d960:	f6 c1 01             	test   cl,0x1
  20d963:	48 8d 6c 24 07       	lea    rbp,[rsp+0x7]
  20d968:	0f 84 78 06 00 00    	je     20dfe6 <BmPoor.init+0xac6>
                try leftJustified(22, "name repetitions:{}", pSelf.repetitions);
  20d96e:	48 8b 7c 24 40       	mov    rdi,QWORD PTR [rsp+0x40]
  20d973:	c5 f8 77             	vzeroupper 
  20d976:	e8 25 7a 00 00       	call   2153a0 <Benchmark_leftJustified>
  20d97b:	66 85 c0             	test   ax,ax
  20d97e:	0f 85 5e 07 00 00    	jne    20e0e2 <BmPoor.init+0xbc2>
                try rightJustified(14, "{}", "iterations");
  20d984:	e8 b7 7c 00 00       	call   215640 <Benchmark_rightJustified>
  20d989:	66 85 c0             	test   ax,ax
  20d98c:	0f 85 50 07 00 00    	jne    20e0e2 <BmPoor.init+0xbc2>
        var buffer: [40]u8 = undefined;
  20d992:	c5 fe 6f 05 b5 85 ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffff85b5]        # 205f4f <__unnamed_7>
  20d999:	ff 
  20d99a:	c5 fe 7f 84 24 90 00 	vmovdqu YMMWORD PTR [rsp+0x90],ymm0
  20d9a1:	00 00 
  20d9a3:	48 8b 05 c5 85 ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffff85c5]        # 205f6f <__unnamed_7+0x20>
  20d9aa:	48 89 84 24 b0 00 00 	mov    QWORD PTR [rsp+0xb0],rax
  20d9b1:	00 
  20d9b2:	c7 84 24 90 00 00 00 	mov    DWORD PTR [rsp+0x90],0x656d6974
  20d9b9:	74 69 6d 65 
  20d9bd:	0f 1f 00             	nop    DWORD PTR [rax]
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20d9c0:	b0 01                	mov    al,0x1
  20d9c2:	86 05 48 36 04 00    	xchg   BYTE PTR [rip+0x43648],al        # 251010 <stderr_mutex>
  20d9c8:	84 c0                	test   al,al
  20d9ca:	75 f4                	jne    20d9c0 <BmPoor.init+0x4a0>
    if (stderr_stream) |st| {
  20d9cc:	48 8b 3d 35 36 04 00 	mov    rdi,QWORD PTR [rip+0x43635]        # 251008 <stderr_stream>
  20d9d3:	48 85 ff             	test   rdi,rdi
  20d9d6:	74 18                	je     20d9f0 <BmPoor.init+0x4d0>
  20d9d8:	48 8b 0d 61 e6 03 00 	mov    rcx,QWORD PTR [rip+0x3e661]        # 24c040 <stderr_file_out_stream+0x8>
  20d9df:	eb 4c                	jmp    20da2d <BmPoor.init+0x50d>
  20d9e1:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20d9e8:	0f 1f 84 00 00 00 00 
  20d9ef:	00 
        stderr_file = try io.getStdErr();
  20d9f0:	c7 05 36 e6 03 00 02 	mov    DWORD PTR [rip+0x3e636],0x2        # 24c030 <stderr_file>
  20d9f7:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20d9fa:	48 8d 05 2f e6 03 00 	lea    rax,[rip+0x3e62f]        # 24c030 <stderr_file>
  20da01:	48 89 05 30 e6 03 00 	mov    QWORD PTR [rip+0x3e630],rax        # 24c038 <stderr_file_out_stream>
  20da08:	48 8d 05 91 14 01 00 	lea    rax,[rip+0x11491]        # 21eea0 <FileOutStream_writeFn>
  20da0f:	48 89 05 2a e6 03 00 	mov    QWORD PTR [rip+0x3e62a],rax        # 24c040 <stderr_file_out_stream+0x8>
  20da16:	48 8d 0d 23 e6 03 00 	lea    rcx,[rip+0x3e623]        # 24c040 <stderr_file_out_stream+0x8>
  20da1d:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20da20:	48 89 15 e1 35 04 00 	mov    QWORD PTR [rip+0x435e1],rdx        # 251008 <stderr_stream>
  20da27:	48 89 c1             	mov    rcx,rax
  20da2a:	48 89 d7             	mov    rdi,rdx
  20da2d:	c6 44 24 07 20       	mov    BYTE PTR [rsp+0x7],0x20
    return output(context, (*[1]u8)(&c)[0..]);
  20da32:	48 89 6c 24 08       	mov    QWORD PTR [rsp+0x8],rbp
  20da37:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  20da3e:	00 00 
  20da40:	48 8d 74 24 08       	lea    rsi,[rsp+0x8]
  20da45:	c5 f8 77             	vzeroupper 
  20da48:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20da4a:	31 c0                	xor    eax,eax
  20da4c:	86 05 be 35 04 00    	xchg   BYTE PTR [rip+0x435be],al        # 251010 <stderr_mutex>
  20da52:	3c 01                	cmp    al,0x1
    if (!ok) {
  20da54:	0f 85 9d 06 00 00    	jne    20e0f7 <BmPoor.init+0xbd7>
  20da5a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20da60:	b0 01                	mov    al,0x1
  20da62:	86 05 a8 35 04 00    	xchg   BYTE PTR [rip+0x435a8],al        # 251010 <stderr_mutex>
  20da68:	84 c0                	test   al,al
  20da6a:	75 f4                	jne    20da60 <BmPoor.init+0x540>
    if (stderr_stream) |st| {
  20da6c:	48 8b 3d 95 35 04 00 	mov    rdi,QWORD PTR [rip+0x43595]        # 251008 <stderr_stream>
  20da73:	48 85 ff             	test   rdi,rdi
  20da76:	74 18                	je     20da90 <BmPoor.init+0x570>
  20da78:	48 8b 0d c1 e5 03 00 	mov    rcx,QWORD PTR [rip+0x3e5c1]        # 24c040 <stderr_file_out_stream+0x8>
  20da7f:	eb 4c                	jmp    20dacd <BmPoor.init+0x5ad>
  20da81:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20da88:	0f 1f 84 00 00 00 00 
  20da8f:	00 
        stderr_file = try io.getStdErr();
  20da90:	c7 05 96 e5 03 00 02 	mov    DWORD PTR [rip+0x3e596],0x2        # 24c030 <stderr_file>
  20da97:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20da9a:	48 8d 05 8f e5 03 00 	lea    rax,[rip+0x3e58f]        # 24c030 <stderr_file>
  20daa1:	48 89 05 90 e5 03 00 	mov    QWORD PTR [rip+0x3e590],rax        # 24c038 <stderr_file_out_stream>
  20daa8:	48 8d 05 f1 13 01 00 	lea    rax,[rip+0x113f1]        # 21eea0 <FileOutStream_writeFn>
  20daaf:	48 89 05 8a e5 03 00 	mov    QWORD PTR [rip+0x3e58a],rax        # 24c040 <stderr_file_out_stream+0x8>
  20dab6:	48 8d 0d 83 e5 03 00 	lea    rcx,[rip+0x3e583]        # 24c040 <stderr_file_out_stream+0x8>
  20dabd:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20dac0:	48 89 15 41 35 04 00 	mov    QWORD PTR [rip+0x43541],rdx        # 251008 <stderr_stream>
  20dac7:	48 89 c1             	mov    rcx,rax
  20daca:	48 89 d7             	mov    rdi,rdx
  20dacd:	c6 44 24 07 20       	mov    BYTE PTR [rsp+0x7],0x20
  20dad2:	48 89 6c 24 08       	mov    QWORD PTR [rsp+0x8],rbp
  20dad7:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  20dade:	00 00 
  20dae0:	48 8d 74 24 08       	lea    rsi,[rsp+0x8]
  20dae5:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20dae7:	31 c0                	xor    eax,eax
  20dae9:	86 05 21 35 04 00    	xchg   BYTE PTR [rip+0x43521],al        # 251010 <stderr_mutex>
  20daef:	3c 01                	cmp    al,0x1
    if (!ok) {
  20daf1:	0f 85 00 06 00 00    	jne    20e0f7 <BmPoor.init+0xbd7>
  20daf7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  20dafe:	00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20db00:	b0 01                	mov    al,0x1
  20db02:	86 05 08 35 04 00    	xchg   BYTE PTR [rip+0x43508],al        # 251010 <stderr_mutex>
  20db08:	84 c0                	test   al,al
  20db0a:	75 f4                	jne    20db00 <BmPoor.init+0x5e0>
    if (stderr_stream) |st| {
  20db0c:	48 8b 3d f5 34 04 00 	mov    rdi,QWORD PTR [rip+0x434f5]        # 251008 <stderr_stream>
  20db13:	48 85 ff             	test   rdi,rdi
  20db16:	74 18                	je     20db30 <BmPoor.init+0x610>
  20db18:	48 8b 0d 21 e5 03 00 	mov    rcx,QWORD PTR [rip+0x3e521]        # 24c040 <stderr_file_out_stream+0x8>
  20db1f:	eb 4c                	jmp    20db6d <BmPoor.init+0x64d>
  20db21:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20db28:	0f 1f 84 00 00 00 00 
  20db2f:	00 
        stderr_file = try io.getStdErr();
  20db30:	c7 05 f6 e4 03 00 02 	mov    DWORD PTR [rip+0x3e4f6],0x2        # 24c030 <stderr_file>
  20db37:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20db3a:	48 8d 05 ef e4 03 00 	lea    rax,[rip+0x3e4ef]        # 24c030 <stderr_file>
  20db41:	48 89 05 f0 e4 03 00 	mov    QWORD PTR [rip+0x3e4f0],rax        # 24c038 <stderr_file_out_stream>
  20db48:	48 8d 05 51 13 01 00 	lea    rax,[rip+0x11351]        # 21eea0 <FileOutStream_writeFn>
  20db4f:	48 89 05 ea e4 03 00 	mov    QWORD PTR [rip+0x3e4ea],rax        # 24c040 <stderr_file_out_stream+0x8>
  20db56:	48 8d 0d e3 e4 03 00 	lea    rcx,[rip+0x3e4e3]        # 24c040 <stderr_file_out_stream+0x8>
  20db5d:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20db60:	48 89 15 a1 34 04 00 	mov    QWORD PTR [rip+0x434a1],rdx        # 251008 <stderr_stream>
  20db67:	48 89 c1             	mov    rcx,rax
  20db6a:	48 89 d7             	mov    rdi,rdx
  20db6d:	c6 44 24 07 20       	mov    BYTE PTR [rsp+0x7],0x20
  20db72:	48 89 6c 24 08       	mov    QWORD PTR [rsp+0x8],rbp
  20db77:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  20db7e:	00 00 
  20db80:	48 8d 74 24 08       	lea    rsi,[rsp+0x8]
  20db85:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20db87:	31 c0                	xor    eax,eax
  20db89:	86 05 81 34 04 00    	xchg   BYTE PTR [rip+0x43481],al        # 251010 <stderr_mutex>
  20db8f:	3c 01                	cmp    al,0x1
    if (!ok) {
  20db91:	0f 85 60 05 00 00    	jne    20e0f7 <BmPoor.init+0xbd7>
  20db97:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  20db9e:	00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20dba0:	b0 01                	mov    al,0x1
  20dba2:	86 05 68 34 04 00    	xchg   BYTE PTR [rip+0x43468],al        # 251010 <stderr_mutex>
  20dba8:	84 c0                	test   al,al
  20dbaa:	75 f4                	jne    20dba0 <BmPoor.init+0x680>
    if (stderr_stream) |st| {
  20dbac:	48 8b 3d 55 34 04 00 	mov    rdi,QWORD PTR [rip+0x43455]        # 251008 <stderr_stream>
  20dbb3:	48 85 ff             	test   rdi,rdi
  20dbb6:	74 18                	je     20dbd0 <BmPoor.init+0x6b0>
  20dbb8:	48 8b 0d 81 e4 03 00 	mov    rcx,QWORD PTR [rip+0x3e481]        # 24c040 <stderr_file_out_stream+0x8>
  20dbbf:	eb 4c                	jmp    20dc0d <BmPoor.init+0x6ed>
  20dbc1:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20dbc8:	0f 1f 84 00 00 00 00 
  20dbcf:	00 
        stderr_file = try io.getStdErr();
  20dbd0:	c7 05 56 e4 03 00 02 	mov    DWORD PTR [rip+0x3e456],0x2        # 24c030 <stderr_file>
  20dbd7:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20dbda:	48 8d 05 4f e4 03 00 	lea    rax,[rip+0x3e44f]        # 24c030 <stderr_file>
  20dbe1:	48 89 05 50 e4 03 00 	mov    QWORD PTR [rip+0x3e450],rax        # 24c038 <stderr_file_out_stream>
  20dbe8:	48 8d 05 b1 12 01 00 	lea    rax,[rip+0x112b1]        # 21eea0 <FileOutStream_writeFn>
  20dbef:	48 89 05 4a e4 03 00 	mov    QWORD PTR [rip+0x3e44a],rax        # 24c040 <stderr_file_out_stream+0x8>
  20dbf6:	48 8d 0d 43 e4 03 00 	lea    rcx,[rip+0x3e443]        # 24c040 <stderr_file_out_stream+0x8>
  20dbfd:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20dc00:	48 89 15 01 34 04 00 	mov    QWORD PTR [rip+0x43401],rdx        # 251008 <stderr_stream>
  20dc07:	48 89 c1             	mov    rcx,rax
  20dc0a:	48 89 d7             	mov    rdi,rdx
  20dc0d:	c6 44 24 07 20       	mov    BYTE PTR [rsp+0x7],0x20
  20dc12:	48 89 6c 24 08       	mov    QWORD PTR [rsp+0x8],rbp
  20dc17:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  20dc1e:	00 00 
  20dc20:	48 8d 74 24 08       	lea    rsi,[rsp+0x8]
  20dc25:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20dc27:	31 c0                	xor    eax,eax
  20dc29:	86 05 e1 33 04 00    	xchg   BYTE PTR [rip+0x433e1],al        # 251010 <stderr_mutex>
  20dc2f:	3c 01                	cmp    al,0x1
    if (!ok) {
  20dc31:	0f 85 c0 04 00 00    	jne    20e0f7 <BmPoor.init+0xbd7>
  20dc37:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  20dc3e:	00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20dc40:	b0 01                	mov    al,0x1
  20dc42:	86 05 c8 33 04 00    	xchg   BYTE PTR [rip+0x433c8],al        # 251010 <stderr_mutex>
  20dc48:	84 c0                	test   al,al
  20dc4a:	75 f4                	jne    20dc40 <BmPoor.init+0x720>
    if (stderr_stream) |st| {
  20dc4c:	48 8b 3d b5 33 04 00 	mov    rdi,QWORD PTR [rip+0x433b5]        # 251008 <stderr_stream>
  20dc53:	48 85 ff             	test   rdi,rdi
  20dc56:	74 18                	je     20dc70 <BmPoor.init+0x750>
  20dc58:	48 8b 0d e1 e3 03 00 	mov    rcx,QWORD PTR [rip+0x3e3e1]        # 24c040 <stderr_file_out_stream+0x8>
  20dc5f:	eb 4c                	jmp    20dcad <BmPoor.init+0x78d>
  20dc61:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20dc68:	0f 1f 84 00 00 00 00 
  20dc6f:	00 
        stderr_file = try io.getStdErr();
  20dc70:	c7 05 b6 e3 03 00 02 	mov    DWORD PTR [rip+0x3e3b6],0x2        # 24c030 <stderr_file>
  20dc77:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20dc7a:	48 8d 05 af e3 03 00 	lea    rax,[rip+0x3e3af]        # 24c030 <stderr_file>
  20dc81:	48 89 05 b0 e3 03 00 	mov    QWORD PTR [rip+0x3e3b0],rax        # 24c038 <stderr_file_out_stream>
  20dc88:	48 8d 05 11 12 01 00 	lea    rax,[rip+0x11211]        # 21eea0 <FileOutStream_writeFn>
  20dc8f:	48 89 05 aa e3 03 00 	mov    QWORD PTR [rip+0x3e3aa],rax        # 24c040 <stderr_file_out_stream+0x8>
  20dc96:	48 8d 0d a3 e3 03 00 	lea    rcx,[rip+0x3e3a3]        # 24c040 <stderr_file_out_stream+0x8>
  20dc9d:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20dca0:	48 89 15 61 33 04 00 	mov    QWORD PTR [rip+0x43361],rdx        # 251008 <stderr_stream>
  20dca7:	48 89 c1             	mov    rcx,rax
  20dcaa:	48 89 d7             	mov    rdi,rdx
  20dcad:	c6 44 24 07 20       	mov    BYTE PTR [rsp+0x7],0x20
  20dcb2:	48 89 6c 24 08       	mov    QWORD PTR [rsp+0x8],rbp
  20dcb7:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  20dcbe:	00 00 
  20dcc0:	48 8d 74 24 08       	lea    rsi,[rsp+0x8]
  20dcc5:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20dcc7:	31 c0                	xor    eax,eax
  20dcc9:	86 05 41 33 04 00    	xchg   BYTE PTR [rip+0x43341],al        # 251010 <stderr_mutex>
  20dccf:	3c 01                	cmp    al,0x1
    if (!ok) {
  20dcd1:	0f 85 20 04 00 00    	jne    20e0f7 <BmPoor.init+0xbd7>
  20dcd7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  20dcde:	00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20dce0:	b0 01                	mov    al,0x1
  20dce2:	86 05 28 33 04 00    	xchg   BYTE PTR [rip+0x43328],al        # 251010 <stderr_mutex>
  20dce8:	84 c0                	test   al,al
  20dcea:	75 f4                	jne    20dce0 <BmPoor.init+0x7c0>
    if (stderr_stream) |st| {
  20dcec:	48 8b 3d 15 33 04 00 	mov    rdi,QWORD PTR [rip+0x43315]        # 251008 <stderr_stream>
  20dcf3:	48 85 ff             	test   rdi,rdi
  20dcf6:	74 18                	je     20dd10 <BmPoor.init+0x7f0>
  20dcf8:	48 8b 0d 41 e3 03 00 	mov    rcx,QWORD PTR [rip+0x3e341]        # 24c040 <stderr_file_out_stream+0x8>
  20dcff:	eb 4c                	jmp    20dd4d <BmPoor.init+0x82d>
  20dd01:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20dd08:	0f 1f 84 00 00 00 00 
  20dd0f:	00 
        stderr_file = try io.getStdErr();
  20dd10:	c7 05 16 e3 03 00 02 	mov    DWORD PTR [rip+0x3e316],0x2        # 24c030 <stderr_file>
  20dd17:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20dd1a:	48 8d 05 0f e3 03 00 	lea    rax,[rip+0x3e30f]        # 24c030 <stderr_file>
  20dd21:	48 89 05 10 e3 03 00 	mov    QWORD PTR [rip+0x3e310],rax        # 24c038 <stderr_file_out_stream>
  20dd28:	48 8d 05 71 11 01 00 	lea    rax,[rip+0x11171]        # 21eea0 <FileOutStream_writeFn>
  20dd2f:	48 89 05 0a e3 03 00 	mov    QWORD PTR [rip+0x3e30a],rax        # 24c040 <stderr_file_out_stream+0x8>
  20dd36:	48 8d 0d 03 e3 03 00 	lea    rcx,[rip+0x3e303]        # 24c040 <stderr_file_out_stream+0x8>
  20dd3d:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20dd40:	48 89 15 c1 32 04 00 	mov    QWORD PTR [rip+0x432c1],rdx        # 251008 <stderr_stream>
  20dd47:	48 89 c1             	mov    rcx,rax
  20dd4a:	48 89 d7             	mov    rdi,rdx
  20dd4d:	c6 44 24 07 20       	mov    BYTE PTR [rsp+0x7],0x20
  20dd52:	48 89 6c 24 08       	mov    QWORD PTR [rsp+0x8],rbp
  20dd57:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  20dd5e:	00 00 
  20dd60:	48 8d 74 24 08       	lea    rsi,[rsp+0x8]
  20dd65:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20dd67:	31 c0                	xor    eax,eax
  20dd69:	86 05 a1 32 04 00    	xchg   BYTE PTR [rip+0x432a1],al        # 251010 <stderr_mutex>
  20dd6f:	3c 01                	cmp    al,0x1
    if (!ok) {
  20dd71:	0f 85 80 03 00 00    	jne    20e0f7 <BmPoor.init+0xbd7>
  20dd77:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  20dd7e:	00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20dd80:	b0 01                	mov    al,0x1
  20dd82:	86 05 88 32 04 00    	xchg   BYTE PTR [rip+0x43288],al        # 251010 <stderr_mutex>
  20dd88:	84 c0                	test   al,al
  20dd8a:	75 f4                	jne    20dd80 <BmPoor.init+0x860>
    if (stderr_stream) |st| {
  20dd8c:	48 8b 3d 75 32 04 00 	mov    rdi,QWORD PTR [rip+0x43275]        # 251008 <stderr_stream>
  20dd93:	48 85 ff             	test   rdi,rdi
  20dd96:	74 18                	je     20ddb0 <BmPoor.init+0x890>
  20dd98:	48 8b 0d a1 e2 03 00 	mov    rcx,QWORD PTR [rip+0x3e2a1]        # 24c040 <stderr_file_out_stream+0x8>
  20dd9f:	eb 4c                	jmp    20dded <BmPoor.init+0x8cd>
  20dda1:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20dda8:	0f 1f 84 00 00 00 00 
  20ddaf:	00 
        stderr_file = try io.getStdErr();
  20ddb0:	c7 05 76 e2 03 00 02 	mov    DWORD PTR [rip+0x3e276],0x2        # 24c030 <stderr_file>
  20ddb7:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20ddba:	48 8d 05 6f e2 03 00 	lea    rax,[rip+0x3e26f]        # 24c030 <stderr_file>
  20ddc1:	48 89 05 70 e2 03 00 	mov    QWORD PTR [rip+0x3e270],rax        # 24c038 <stderr_file_out_stream>
  20ddc8:	48 8d 05 d1 10 01 00 	lea    rax,[rip+0x110d1]        # 21eea0 <FileOutStream_writeFn>
  20ddcf:	48 89 05 6a e2 03 00 	mov    QWORD PTR [rip+0x3e26a],rax        # 24c040 <stderr_file_out_stream+0x8>
  20ddd6:	48 8d 0d 63 e2 03 00 	lea    rcx,[rip+0x3e263]        # 24c040 <stderr_file_out_stream+0x8>
  20dddd:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20dde0:	48 89 15 21 32 04 00 	mov    QWORD PTR [rip+0x43221],rdx        # 251008 <stderr_stream>
  20dde7:	48 89 c1             	mov    rcx,rax
  20ddea:	48 89 d7             	mov    rdi,rdx
  20dded:	c6 44 24 07 20       	mov    BYTE PTR [rsp+0x7],0x20
  20ddf2:	48 89 6c 24 08       	mov    QWORD PTR [rsp+0x8],rbp
  20ddf7:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  20ddfe:	00 00 
  20de00:	48 8d 74 24 08       	lea    rsi,[rsp+0x8]
  20de05:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20de07:	31 c0                	xor    eax,eax
  20de09:	86 05 01 32 04 00    	xchg   BYTE PTR [rip+0x43201],al        # 251010 <stderr_mutex>
  20de0f:	3c 01                	cmp    al,0x1
    if (!ok) {
  20de11:	0f 85 e0 02 00 00    	jne    20e0f7 <BmPoor.init+0xbd7>
  20de17:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  20de1e:	00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20de20:	b0 01                	mov    al,0x1
  20de22:	86 05 e8 31 04 00    	xchg   BYTE PTR [rip+0x431e8],al        # 251010 <stderr_mutex>
  20de28:	84 c0                	test   al,al
  20de2a:	75 f4                	jne    20de20 <BmPoor.init+0x900>
    if (stderr_stream) |st| {
  20de2c:	48 8b 3d d5 31 04 00 	mov    rdi,QWORD PTR [rip+0x431d5]        # 251008 <stderr_stream>
  20de33:	48 85 ff             	test   rdi,rdi
  20de36:	74 18                	je     20de50 <BmPoor.init+0x930>
  20de38:	48 8b 0d 01 e2 03 00 	mov    rcx,QWORD PTR [rip+0x3e201]        # 24c040 <stderr_file_out_stream+0x8>
  20de3f:	eb 4c                	jmp    20de8d <BmPoor.init+0x96d>
  20de41:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20de48:	0f 1f 84 00 00 00 00 
  20de4f:	00 
        stderr_file = try io.getStdErr();
  20de50:	c7 05 d6 e1 03 00 02 	mov    DWORD PTR [rip+0x3e1d6],0x2        # 24c030 <stderr_file>
  20de57:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20de5a:	48 8d 05 cf e1 03 00 	lea    rax,[rip+0x3e1cf]        # 24c030 <stderr_file>
  20de61:	48 89 05 d0 e1 03 00 	mov    QWORD PTR [rip+0x3e1d0],rax        # 24c038 <stderr_file_out_stream>
  20de68:	48 8d 05 31 10 01 00 	lea    rax,[rip+0x11031]        # 21eea0 <FileOutStream_writeFn>
  20de6f:	48 89 05 ca e1 03 00 	mov    QWORD PTR [rip+0x3e1ca],rax        # 24c040 <stderr_file_out_stream+0x8>
  20de76:	48 8d 0d c3 e1 03 00 	lea    rcx,[rip+0x3e1c3]        # 24c040 <stderr_file_out_stream+0x8>
  20de7d:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20de80:	48 89 15 81 31 04 00 	mov    QWORD PTR [rip+0x43181],rdx        # 251008 <stderr_stream>
  20de87:	48 89 c1             	mov    rcx,rax
  20de8a:	48 89 d7             	mov    rdi,rdx
  20de8d:	c6 44 24 07 20       	mov    BYTE PTR [rsp+0x7],0x20
  20de92:	48 89 6c 24 08       	mov    QWORD PTR [rsp+0x8],rbp
  20de97:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  20de9e:	00 00 
  20dea0:	48 8d 74 24 08       	lea    rsi,[rsp+0x8]
  20dea5:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20dea7:	31 c0                	xor    eax,eax
  20dea9:	86 05 61 31 04 00    	xchg   BYTE PTR [rip+0x43161],al        # 251010 <stderr_mutex>
  20deaf:	3c 01                	cmp    al,0x1
    if (!ok) {
  20deb1:	0f 85 40 02 00 00    	jne    20e0f7 <BmPoor.init+0xbd7>
  20deb7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  20debe:	00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20dec0:	b0 01                	mov    al,0x1
  20dec2:	86 05 48 31 04 00    	xchg   BYTE PTR [rip+0x43148],al        # 251010 <stderr_mutex>
  20dec8:	84 c0                	test   al,al
  20deca:	75 f4                	jne    20dec0 <BmPoor.init+0x9a0>
    if (stderr_stream) |st| {
  20decc:	48 8b 3d 35 31 04 00 	mov    rdi,QWORD PTR [rip+0x43135]        # 251008 <stderr_stream>
  20ded3:	48 85 ff             	test   rdi,rdi
  20ded6:	74 18                	je     20def0 <BmPoor.init+0x9d0>
  20ded8:	48 8b 0d 61 e1 03 00 	mov    rcx,QWORD PTR [rip+0x3e161]        # 24c040 <stderr_file_out_stream+0x8>
  20dedf:	eb 4c                	jmp    20df2d <BmPoor.init+0xa0d>
  20dee1:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20dee8:	0f 1f 84 00 00 00 00 
  20deef:	00 
        stderr_file = try io.getStdErr();
  20def0:	c7 05 36 e1 03 00 02 	mov    DWORD PTR [rip+0x3e136],0x2        # 24c030 <stderr_file>
  20def7:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20defa:	48 8d 05 2f e1 03 00 	lea    rax,[rip+0x3e12f]        # 24c030 <stderr_file>
  20df01:	48 89 05 30 e1 03 00 	mov    QWORD PTR [rip+0x3e130],rax        # 24c038 <stderr_file_out_stream>
  20df08:	48 8d 05 91 0f 01 00 	lea    rax,[rip+0x10f91]        # 21eea0 <FileOutStream_writeFn>
  20df0f:	48 89 05 2a e1 03 00 	mov    QWORD PTR [rip+0x3e12a],rax        # 24c040 <stderr_file_out_stream+0x8>
  20df16:	48 8d 0d 23 e1 03 00 	lea    rcx,[rip+0x3e123]        # 24c040 <stderr_file_out_stream+0x8>
  20df1d:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20df20:	48 89 15 e1 30 04 00 	mov    QWORD PTR [rip+0x430e1],rdx        # 251008 <stderr_stream>
  20df27:	48 89 c1             	mov    rcx,rax
  20df2a:	48 89 d7             	mov    rdi,rdx
                const casted_value = ([]const u8)(value);
  20df2d:	4c 89 64 24 08       	mov    QWORD PTR [rsp+0x8],r12
  20df32:	48 c7 44 24 10 04 00 	mov    QWORD PTR [rsp+0x10],0x4
  20df39:	00 00 
                return output(context, casted_value);
  20df3b:	48 8d 74 24 08       	lea    rsi,[rsp+0x8]
  20df40:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20df42:	31 c0                	xor    eax,eax
  20df44:	86 05 c6 30 04 00    	xchg   BYTE PTR [rip+0x430c6],al        # 251010 <stderr_mutex>
  20df4a:	3c 01                	cmp    al,0x1
    if (!ok) {
  20df4c:	0f 85 a5 01 00 00    	jne    20e0f7 <BmPoor.init+0xbd7>
                try rightJustified(18, "{}", "time/operation");
  20df52:	e8 c9 79 00 00       	call   215920 <Benchmark_rightJustified.39>
  20df57:	66 85 c0             	test   ax,ax
  20df5a:	0f 85 82 01 00 00    	jne    20e0e2 <BmPoor.init+0xbc2>
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20df60:	b0 01                	mov    al,0x1
  20df62:	86 05 a8 30 04 00    	xchg   BYTE PTR [rip+0x430a8],al        # 251010 <stderr_mutex>
  20df68:	84 c0                	test   al,al
  20df6a:	75 f4                	jne    20df60 <BmPoor.init+0xa40>
    if (stderr_stream) |st| {
  20df6c:	48 8b 3d 95 30 04 00 	mov    rdi,QWORD PTR [rip+0x43095]        # 251008 <stderr_stream>
  20df73:	48 85 ff             	test   rdi,rdi
  20df76:	74 18                	je     20df90 <BmPoor.init+0xa70>
  20df78:	48 8b 0d c1 e0 03 00 	mov    rcx,QWORD PTR [rip+0x3e0c1]        # 24c040 <stderr_file_out_stream+0x8>
  20df7f:	eb 4c                	jmp    20dfcd <BmPoor.init+0xaad>
  20df81:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20df88:	0f 1f 84 00 00 00 00 
  20df8f:	00 
        stderr_file = try io.getStdErr();
  20df90:	c7 05 96 e0 03 00 02 	mov    DWORD PTR [rip+0x3e096],0x2        # 24c030 <stderr_file>
  20df97:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20df9a:	48 8d 05 8f e0 03 00 	lea    rax,[rip+0x3e08f]        # 24c030 <stderr_file>
  20dfa1:	48 89 05 90 e0 03 00 	mov    QWORD PTR [rip+0x3e090],rax        # 24c038 <stderr_file_out_stream>
  20dfa8:	48 8d 05 f1 0e 01 00 	lea    rax,[rip+0x10ef1]        # 21eea0 <FileOutStream_writeFn>
  20dfaf:	48 89 05 8a e0 03 00 	mov    QWORD PTR [rip+0x3e08a],rax        # 24c040 <stderr_file_out_stream+0x8>
  20dfb6:	48 8d 0d 83 e0 03 00 	lea    rcx,[rip+0x3e083]        # 24c040 <stderr_file_out_stream+0x8>
  20dfbd:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20dfc0:	48 89 15 41 30 04 00 	mov    QWORD PTR [rip+0x43041],rdx        # 251008 <stderr_stream>
  20dfc7:	48 89 c1             	mov    rcx,rax
  20dfca:	48 89 d7             	mov    rdi,rdx
        try output(context, fmt[start_index..]);
  20dfcd:	48 8d 35 1c 1f 04 00 	lea    rsi,[rip+0x41f1c]        # 24fef0 <__unnamed_3>
  20dfd4:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20dfd6:	31 c0                	xor    eax,eax
  20dfd8:	86 05 32 30 04 00    	xchg   BYTE PTR [rip+0x43032],al        # 251010 <stderr_mutex>
  20dfde:	3c 01                	cmp    al,0x1
    if (!ok) {
  20dfe0:	0f 85 11 01 00 00    	jne    20e0f7 <BmPoor.init+0xbd7>
            try pSelf.report(pSelf.results.items[pSelf.results.len - 1]); warn("\n");
  20dfe6:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  20dfeb:	48 8b 4c 24 78       	mov    rcx,QWORD PTR [rsp+0x78]
  20dff0:	48 c1 e1 04          	shl    rcx,0x4
  20dff4:	48 8d 34 08          	lea    rsi,[rax+rcx*1]
  20dff8:	48 83 c6 f0          	add    rsi,0xfffffffffffffff0
  20dffc:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  20e001:	c5 f8 77             	vzeroupper 
  20e004:	e8 17 4f 00 00       	call   212f20 <Benchmark_report>
  20e009:	66 85 c0             	test   ax,ax
  20e00c:	0f 85 d0 00 00 00    	jne    20e0e2 <BmPoor.init+0xbc2>
  20e012:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20e019:	1f 84 00 00 00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20e020:	b0 01                	mov    al,0x1
  20e022:	86 05 e8 2f 04 00    	xchg   BYTE PTR [rip+0x42fe8],al        # 251010 <stderr_mutex>
  20e028:	84 c0                	test   al,al
  20e02a:	75 f4                	jne    20e020 <BmPoor.init+0xb00>
    if (stderr_stream) |st| {
  20e02c:	48 8b 3d d5 2f 04 00 	mov    rdi,QWORD PTR [rip+0x42fd5]        # 251008 <stderr_stream>
  20e033:	48 85 ff             	test   rdi,rdi
  20e036:	74 18                	je     20e050 <BmPoor.init+0xb30>
  20e038:	48 8b 0d 01 e0 03 00 	mov    rcx,QWORD PTR [rip+0x3e001]        # 24c040 <stderr_file_out_stream+0x8>
  20e03f:	eb 4c                	jmp    20e08d <BmPoor.init+0xb6d>
  20e041:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20e048:	0f 1f 84 00 00 00 00 
  20e04f:	00 
        stderr_file = try io.getStdErr();
  20e050:	c7 05 d6 df 03 00 02 	mov    DWORD PTR [rip+0x3dfd6],0x2        # 24c030 <stderr_file>
  20e057:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20e05a:	48 8d 05 cf df 03 00 	lea    rax,[rip+0x3dfcf]        # 24c030 <stderr_file>
  20e061:	48 89 05 d0 df 03 00 	mov    QWORD PTR [rip+0x3dfd0],rax        # 24c038 <stderr_file_out_stream>
  20e068:	48 8d 05 31 0e 01 00 	lea    rax,[rip+0x10e31]        # 21eea0 <FileOutStream_writeFn>
  20e06f:	48 89 05 ca df 03 00 	mov    QWORD PTR [rip+0x3dfca],rax        # 24c040 <stderr_file_out_stream+0x8>
  20e076:	48 8d 0d c3 df 03 00 	lea    rcx,[rip+0x3dfc3]        # 24c040 <stderr_file_out_stream+0x8>
  20e07d:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20e080:	48 89 15 81 2f 04 00 	mov    QWORD PTR [rip+0x42f81],rdx        # 251008 <stderr_stream>
  20e087:	48 89 c1             	mov    rcx,rax
  20e08a:	48 89 d7             	mov    rdi,rdx
  20e08d:	48 8d 35 5c 1e 04 00 	lea    rsi,[rip+0x41e5c]        # 24fef0 <__unnamed_3>
  20e094:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20e096:	31 c0                	xor    eax,eax
  20e098:	86 05 72 2f 04 00    	xchg   BYTE PTR [rip+0x42f72],al        # 251010 <stderr_mutex>
  20e09e:	3c 01                	cmp    al,0x1
    if (!ok) {
  20e0a0:	75 55                	jne    20e0f7 <BmPoor.init+0xbd7>
  20e0a2:	49 83 c6 01          	add    r14,0x1
        while (rep < pSelf.repetitions) : (rep += 1) {
  20e0a6:	4c 3b 74 24 40       	cmp    r14,QWORD PTR [rsp+0x40]
  20e0ab:	0f 82 9f f8 ff ff    	jb     20d950 <BmPoor.init+0x430>
  20e0b1:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
        try pSelf.reportStats(pSelf.results);
  20e0b6:	48 8d 74 24 68       	lea    rsi,[rsp+0x68]
  20e0bb:	e8 40 7b 00 00       	call   215c00 <Benchmark_reportStats>
  20e0c0:	66 85 c0             	test   ax,ax
  20e0c3:	75 1d                	jne    20e0e2 <BmPoor.init+0xbc2>
    };

    var bmSelf = try bm.run(BmSelf);
    assert(bmSelf.init_count == 1);
    assert(bmSelf.setup_count == 0);
    assert(bmSelf.benchmark_count > 1000000);
  20e0c5:	49 81 fd 40 42 0f 00 	cmp    r13,0xf4240
  20e0cc:	76 29                	jbe    20e0f7 <BmPoor.init+0xbd7>
  20e0ce:	31 c0                	xor    eax,eax
  20e0d0:	eb 10                	jmp    20e0e2 <BmPoor.init+0xbc2>
                switch (errno) {
  20e0d2:	48 83 f9 16          	cmp    rcx,0x16
  20e0d6:	75 06                	jne    20e0de <BmPoor.init+0xbbe>
  20e0d8:	66 b8 02 00          	mov    ax,0x2
  20e0dc:	eb 04                	jmp    20e0e2 <BmPoor.init+0xbc2>
  20e0de:	66 b8 03 00          	mov    ax,0x3
    var bmSelf = try bm.run(BmSelf);
  20e0e2:	48 81 c4 f8 00 00 00 	add    rsp,0xf8
  20e0e9:	5b                   	pop    rbx
  20e0ea:	41 5c                	pop    r12
  20e0ec:	41 5d                	pop    r13
  20e0ee:	41 5e                	pop    r14
  20e0f0:	41 5f                	pop    r15
  20e0f2:	5d                   	pop    rbp
  20e0f3:	c5 f8 77             	vzeroupper 
  20e0f6:	c3                   	ret    
            @panic("assertion failure");
  20e0f7:	48 8d 3d 92 1c 04 00 	lea    rdi,[rip+0x41c92]        # 24fd90 <__unnamed_2>
  20e0fe:	c5 f8 77             	vzeroupper 
  20e101:	e8 1a 46 00 00       	call   212720 <panic>
  20e106:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  20e10d:	00 00 00 

000000000020e110 <BmPoor.init.setup>:
    assert(bmSelf.tearDown_count == 0);
}

test "BmPoor.init.setup" {
  20e110:	55                   	push   rbp
  20e111:	41 57                	push   r15
  20e113:	41 56                	push   r14
  20e115:	41 55                	push   r13
  20e117:	41 54                	push   r12
  20e119:	53                   	push   rbx
  20e11a:	48 81 ec f8 00 00 00 	sub    rsp,0xf8
  20e121:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20e128:	0f 1f 84 00 00 00 00 
  20e12f:	00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20e130:	b0 01                	mov    al,0x1
  20e132:	86 05 d8 2e 04 00    	xchg   BYTE PTR [rip+0x42ed8],al        # 251010 <stderr_mutex>
  20e138:	84 c0                	test   al,al
  20e13a:	75 f4                	jne    20e130 <BmPoor.init.setup+0x20>
    if (stderr_stream) |st| {
  20e13c:	48 8b 3d c5 2e 04 00 	mov    rdi,QWORD PTR [rip+0x42ec5]        # 251008 <stderr_stream>
  20e143:	48 85 ff             	test   rdi,rdi
  20e146:	74 09                	je     20e151 <BmPoor.init.setup+0x41>
  20e148:	48 8b 05 f1 de 03 00 	mov    rax,QWORD PTR [rip+0x3def1]        # 24c040 <stderr_file_out_stream+0x8>
  20e14f:	eb 34                	jmp    20e185 <BmPoor.init.setup+0x75>
        stderr_file = try io.getStdErr();
  20e151:	48 8d 05 d8 de 03 00 	lea    rax,[rip+0x3ded8]        # 24c030 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20e158:	48 89 05 d9 de 03 00 	mov    QWORD PTR [rip+0x3ded9],rax        # 24c038 <stderr_file_out_stream>
  20e15f:	48 8d 05 3a 0d 01 00 	lea    rax,[rip+0x10d3a]        # 21eea0 <FileOutStream_writeFn>
  20e166:	48 89 05 d3 de 03 00 	mov    QWORD PTR [rip+0x3ded3],rax        # 24c040 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  20e16d:	c7 05 b9 de 03 00 02 	mov    DWORD PTR [rip+0x3deb9],0x2        # 24c030 <stderr_file>
  20e174:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20e177:	48 8d 3d c2 de 03 00 	lea    rdi,[rip+0x3dec2]        # 24c040 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  20e17e:	48 89 3d 83 2e 04 00 	mov    QWORD PTR [rip+0x42e83],rdi        # 251008 <stderr_stream>
  20e185:	48 8d 35 64 1d 04 00 	lea    rsi,[rip+0x41d64]        # 24fef0 <__unnamed_3>
  20e18c:	ff d0                	call   rax
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20e18e:	31 c0                	xor    eax,eax
  20e190:	86 05 7a 2e 04 00    	xchg   BYTE PTR [rip+0x42e7a],al        # 251010 <stderr_mutex>
  20e196:	3c 01                	cmp    al,0x1
    if (!ok) {
  20e198:	0f 85 58 0b 00 00    	jne    20ecf6 <BmPoor.init.setup+0xbe6>
    // Since this is a test print a \n before we run
    warn("\n");

    // Test fn benchmark(pSelf) can return an error
    var bm = Benchmark.init("BmPoor.init.setup", std.debug.global_allocator);
  20e19e:	c5 f8 10 05 8a 1b 04 	vmovups xmm0,XMMWORD PTR [rip+0x41b8a]        # 24fd30 <__unnamed_12>
  20e1a5:	00 
  20e1a6:	c5 f8 29 44 24 20    	vmovaps XMMWORD PTR [rsp+0x20],xmm0
  20e1ac:	49 bf 00 e8 76 48 17 	movabs r15,0x174876e800
  20e1b3:	00 00 00 
  20e1b6:	b8 00 65 cd 1d       	mov    eax,0x1dcd6500
  20e1bb:	c4 e1 f9 6e c0       	vmovq  xmm0,rax
  20e1c0:	c5 f9 73 f8 08       	vpslldq xmm0,xmm0,0x8
  20e1c5:	c5 f9 7f 44 24 30    	vmovdqa XMMWORD PTR [rsp+0x30],xmm0
  20e1cb:	4c 89 7c 24 48       	mov    QWORD PTR [rsp+0x48],r15
  20e1d0:	c5 fa 6f 05 38 21 ff 	vmovdqu xmm0,XMMWORD PTR [rip+0xffffffffffff2138]        # 200310 <__unnamed_35>
  20e1d7:	ff 
  20e1d8:	c5 f9 7f 44 24 50    	vmovdqa XMMWORD PTR [rsp+0x50],xmm0
  20e1de:	48 8d 05 1b de 03 00 	lea    rax,[rip+0x3de1b]        # 24c000 <global_fixed_allocator>
  20e1e5:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  20e1ea:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  20e1ee:	c5 fa 7f 44 24 68    	vmovdqu XMMWORD PTR [rsp+0x68],xmm0
  20e1f4:	48 c7 44 24 78 00 00 	mov    QWORD PTR [rsp+0x78],0x0
  20e1fb:	00 00 
  20e1fd:	48 89 84 24 80 00 00 	mov    QWORD PTR [rsp+0x80],rax
  20e204:	00 
        fn benchmark(pSelf: *Self) void {
            pSelf.benchmark_count += 1;
        }
    };

    bm.repetitions = 3;
  20e205:	48 c7 44 24 40 03 00 	mov    QWORD PTR [rsp+0x40],0x3
  20e20c:	00 00 
  20e20e:	b1 01                	mov    cl,0x1
  20e210:	bb 01 00 00 00       	mov    ebx,0x1
  20e215:	4c 8d a4 24 90 00 00 	lea    r12,[rsp+0x90]
  20e21c:	00 
  20e21d:	45 31 f6             	xor    r14d,r14d
  20e220:	45 31 ed             	xor    r13d,r13d
            while (iterations <= pSelf.max_iterations) {
  20e223:	4c 39 fb             	cmp    rbx,r15
  20e226:	0f 87 27 03 00 00    	ja     20e553 <BmPoor.init.setup+0x443>
  20e22c:	89 4c 24 1c          	mov    DWORD PTR [rsp+0x1c],ecx
  20e230:	eb 19                	jmp    20e24b <BmPoor.init.setup+0x13b>
  20e232:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20e239:	1f 84 00 00 00 00 00 
                        warn("iteratons:{} numer:{} denom:{}\n", iterations, numer, denom);
  20e240:	48 89 df             	mov    rdi,rbx
  20e243:	48 89 ca             	mov    rdx,rcx
  20e246:	e8 e5 6d 00 00       	call   215030 <warn.37>
                var ts: posix.timespec = undefined;
  20e24b:	c5 fa 6f 05 bd 20 ff 	vmovdqu xmm0,XMMWORD PTR [rip+0xffffffffffff20bd]        # 200310 <__unnamed_35>
  20e252:	ff 
  20e253:	c5 f9 7f 84 24 90 00 	vmovdqa XMMWORD PTR [rsp+0x90],xmm0
  20e25a:	00 00 
  20e25c:	b8 e5 00 00 00       	mov    eax,0xe5
  20e261:	bf 01 00 00 00       	mov    edi,0x1
  20e266:	4c 89 e6             	mov    rsi,r12
  20e269:	0f 05                	syscall 
  20e26b:	48 89 c1             	mov    rcx,rax
  20e26e:	48 f7 d9             	neg    rcx
  20e271:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  20e277:	b8 00 00 00 00       	mov    eax,0x0
  20e27c:	48 0f 46 c8          	cmovbe rcx,rax
                switch (errno) {
  20e280:	48 85 c9             	test   rcx,rcx
  20e283:	0f 85 4b 0a 00 00    	jne    20ecd4 <BmPoor.init.setup+0xbc4>
        const f = @atomicLoad(@typeOf(init_vdso_clock_gettime), &vdso_clock_gettime, builtin.AtomicOrder.Unordered);
  20e289:	48 8b 05 88 de 03 00 	mov    rax,QWORD PTR [rip+0x3de88]        # 24c118 <vdso_clock_gettime>
        if (@ptrToInt(f) != 0) {
  20e290:	48 85 c0             	test   rax,rax
  20e293:	74 21                	je     20e2b6 <BmPoor.init.setup+0x1a6>
            const rc = f(clk_id, tp);
  20e295:	bf 01 00 00 00       	mov    edi,0x1
  20e29a:	4c 89 e6             	mov    rsi,r12
  20e29d:	ff d0                	call   rax
            switch (rc) {
  20e29f:	48 83 f8 ea          	cmp    rax,0xffffffffffffffea
  20e2a3:	0f 84 27 02 00 00    	je     20e4d0 <BmPoor.init.setup+0x3c0>
  20e2a9:	48 85 c0             	test   rax,rax
  20e2ac:	c5 fa 6f 05 5c 20 ff 	vmovdqu xmm0,XMMWORD PTR [rip+0xffffffffffff205c]        # 200310 <__unnamed_35>
  20e2b3:	ff 
  20e2b4:	74 0f                	je     20e2c5 <BmPoor.init.setup+0x1b5>
  20e2b6:	b8 e4 00 00 00       	mov    eax,0xe4
  20e2bb:	bf 01 00 00 00       	mov    edi,0x1
  20e2c0:	4c 89 e6             	mov    rsi,r12
  20e2c3:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  20e2c5:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
                if (errno != 0) return std.os.unexpectedErrorPosix(errno);
  20e2cb:	0f 83 0f 0a 00 00    	jae    20ece0 <BmPoor.init.setup+0xbd0>
                self.start_time = @intCast(u64, ts.tv_sec) * u64(ns_per_s) + @intCast(u64, ts.tv_nsec);
  20e2d1:	c5 f9 6f 8c 24 90 00 	vmovdqa xmm1,XMMWORD PTR [rsp+0x90]
  20e2d8:	00 00 
        var ts: posix.timespec = undefined;
  20e2da:	c5 f9 7f 84 24 90 00 	vmovdqa XMMWORD PTR [rsp+0x90],xmm0
  20e2e1:	00 00 
        const f = @atomicLoad(@typeOf(init_vdso_clock_gettime), &vdso_clock_gettime, builtin.AtomicOrder.Unordered);
  20e2e3:	48 8b 05 2e de 03 00 	mov    rax,QWORD PTR [rip+0x3de2e]        # 24c118 <vdso_clock_gettime>
        if (@ptrToInt(f) != 0) {
  20e2ea:	48 85 c0             	test   rax,rax
  20e2ed:	74 2b                	je     20e31a <BmPoor.init.setup+0x20a>
  20e2ef:	c5 f9 7f 8c 24 c0 00 	vmovdqa XMMWORD PTR [rsp+0xc0],xmm1
  20e2f6:	00 00 
            const rc = f(clk_id, tp);
  20e2f8:	bf 01 00 00 00       	mov    edi,0x1
  20e2fd:	4c 89 e6             	mov    rsi,r12
  20e300:	ff d0                	call   rax
            switch (rc) {
  20e302:	48 83 f8 ea          	cmp    rax,0xffffffffffffffea
  20e306:	0f 84 dd 01 00 00    	je     20e4e9 <BmPoor.init.setup+0x3d9>
  20e30c:	48 85 c0             	test   rax,rax
  20e30f:	c5 f9 6f 8c 24 c0 00 	vmovdqa xmm1,XMMWORD PTR [rsp+0xc0]
  20e316:	00 00 
  20e318:	74 0f                	je     20e329 <BmPoor.init.setup+0x219>
  20e31a:	b8 e4 00 00 00       	mov    eax,0xe4
  20e31f:	bf 01 00 00 00       	mov    edi,0x1
  20e324:	4c 89 e6             	mov    rsi,r12
  20e327:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  20e329:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
  20e32f:	0f 83 c1 09 00 00    	jae    20ecf6 <BmPoor.init.setup+0xbe6>
  20e335:	49 01 dd             	add    r13,rbx
        return @intCast(u64, ts.tv_sec) * u64(ns_per_s) + @intCast(u64, ts.tv_nsec);
  20e338:	c5 f9 6f 84 24 90 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x90]
  20e33f:	00 00 
  20e341:	c5 f9 fb c1          	vpsubq xmm0,xmm0,xmm1
  20e345:	c4 e1 f9 7e c0       	vmovq  rax,xmm0
        var clock = clockNative() - self.start_time;
  20e34a:	c4 e3 f9 16 c5 01    	vpextrq rbp,xmm0,0x1
  20e350:	48 69 c0 00 ca 9a 3b 	imul   rax,rax,0x3b9aca00
  20e357:	48 01 c5             	add    rbp,rax
                if ((run_time_ns >= pSelf.min_runtime_ns) or (iterations >= pSelf.max_iterations)) {
  20e35a:	48 3b 6c 24 38       	cmp    rbp,QWORD PTR [rsp+0x38]
  20e35f:	0f 83 ab 01 00 00    	jae    20e510 <BmPoor.init.setup+0x400>
  20e365:	4c 39 fb             	cmp    rbx,r15
  20e368:	0f 83 a2 01 00 00    	jae    20e510 <BmPoor.init.setup+0x400>
                    if (pSelf.logl >= 1) {
  20e36e:	48 83 7c 24 30 00    	cmp    QWORD PTR [rsp+0x30],0x0
  20e374:	0f 84 bc 00 00 00    	je     20e436 <BmPoor.init.setup+0x326>
                            Result {.run_time_ns = run_time_ns, .iterations = iterations});
  20e37a:	48 89 ac 24 d8 00 00 	mov    QWORD PTR [rsp+0xd8],rbp
  20e381:	00 
  20e382:	48 89 9c 24 e0 00 00 	mov    QWORD PTR [rsp+0xe0],rbx
  20e389:	00 
                        try pSelf.report(
  20e38a:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  20e38f:	48 8d b4 24 d8 00 00 	lea    rsi,[rsp+0xd8]
  20e396:	00 
  20e397:	e8 84 4b 00 00       	call   212f20 <Benchmark_report>
  20e39c:	66 85 c0             	test   ax,ax
  20e39f:	0f 85 3f 09 00 00    	jne    20ece4 <BmPoor.init.setup+0xbd4>
  20e3a5:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20e3ac:	00 00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20e3b0:	b0 01                	mov    al,0x1
  20e3b2:	86 05 58 2c 04 00    	xchg   BYTE PTR [rip+0x42c58],al        # 251010 <stderr_mutex>
  20e3b8:	84 c0                	test   al,al
  20e3ba:	75 f4                	jne    20e3b0 <BmPoor.init.setup+0x2a0>
    if (stderr_stream) |st| {
  20e3bc:	48 8b 3d 45 2c 04 00 	mov    rdi,QWORD PTR [rip+0x42c45]        # 251008 <stderr_stream>
  20e3c3:	48 85 ff             	test   rdi,rdi
  20e3c6:	74 18                	je     20e3e0 <BmPoor.init.setup+0x2d0>
  20e3c8:	48 8b 0d 71 dc 03 00 	mov    rcx,QWORD PTR [rip+0x3dc71]        # 24c040 <stderr_file_out_stream+0x8>
  20e3cf:	eb 4c                	jmp    20e41d <BmPoor.init.setup+0x30d>
  20e3d1:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20e3d8:	0f 1f 84 00 00 00 00 
  20e3df:	00 
        stderr_file = try io.getStdErr();
  20e3e0:	c7 05 46 dc 03 00 02 	mov    DWORD PTR [rip+0x3dc46],0x2        # 24c030 <stderr_file>
  20e3e7:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20e3ea:	48 8d 05 3f dc 03 00 	lea    rax,[rip+0x3dc3f]        # 24c030 <stderr_file>
  20e3f1:	48 89 05 40 dc 03 00 	mov    QWORD PTR [rip+0x3dc40],rax        # 24c038 <stderr_file_out_stream>
  20e3f8:	48 8d 05 a1 0a 01 00 	lea    rax,[rip+0x10aa1]        # 21eea0 <FileOutStream_writeFn>
  20e3ff:	48 89 05 3a dc 03 00 	mov    QWORD PTR [rip+0x3dc3a],rax        # 24c040 <stderr_file_out_stream+0x8>
  20e406:	48 8d 0d 33 dc 03 00 	lea    rcx,[rip+0x3dc33]        # 24c040 <stderr_file_out_stream+0x8>
  20e40d:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20e410:	48 89 15 f1 2b 04 00 	mov    QWORD PTR [rip+0x42bf1],rdx        # 251008 <stderr_stream>
  20e417:	48 89 c1             	mov    rcx,rax
  20e41a:	48 89 d7             	mov    rdi,rdx
  20e41d:	48 8d 35 cc 1a 04 00 	lea    rsi,[rip+0x41acc]        # 24fef0 <__unnamed_3>
  20e424:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20e426:	31 c0                	xor    eax,eax
  20e428:	86 05 e2 2b 04 00    	xchg   BYTE PTR [rip+0x42be2],al        # 251010 <stderr_mutex>
  20e42e:	3c 01                	cmp    al,0x1
    if (!ok) {
  20e430:	0f 85 c0 08 00 00    	jne    20ecf6 <BmPoor.init.setup+0xbe6>
                    if (run_time_ns < 1000) {
  20e436:	48 81 fd e8 03 00 00 	cmp    rbp,0x3e8
  20e43d:	73 31                	jae    20e470 <BmPoor.init.setup+0x360>
  20e43f:	b9 01 00 00 00       	mov    ecx,0x1
  20e444:	be e8 03 00 00       	mov    esi,0x3e8
                    iterations = (iterations * numer) / denom;
  20e449:	48 0f af de          	imul   rbx,rsi
  20e44d:	48 89 d8             	mov    rax,rbx
  20e450:	48 c1 e8 20          	shr    rax,0x20
  20e454:	74 54                	je     20e4aa <BmPoor.init.setup+0x39a>
  20e456:	31 d2                	xor    edx,edx
  20e458:	48 89 d8             	mov    rax,rbx
  20e45b:	48 f7 f1             	div    rcx
  20e45e:	48 89 c3             	mov    rbx,rax
  20e461:	eb 4f                	jmp    20e4b2 <BmPoor.init.setup+0x3a2>
  20e463:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20e46a:	84 00 00 00 00 00 
                    } else if (run_time_ns < (pSelf.min_runtime_ns / 10)) {
  20e470:	48 ba cd cc cc cc cc 	movabs rdx,0xcccccccccccccccd
  20e477:	cc cc cc 
  20e47a:	c4 e2 fb f6 4c 24 38 	mulx   rcx,rax,QWORD PTR [rsp+0x38]
  20e481:	48 c1 e9 03          	shr    rcx,0x3
  20e485:	31 c0                	xor    eax,eax
  20e487:	48 39 cd             	cmp    rbp,rcx
  20e48a:	0f 93 c0             	setae  al
  20e48d:	48 8d 0c c0          	lea    rcx,[rax+rax*8]
  20e491:	48 83 c1 01          	add    rcx,0x1
  20e495:	48 8d 34 85 0a 00 00 	lea    rsi,[rax*4+0xa]
  20e49c:	00 
                    iterations = (iterations * numer) / denom;
  20e49d:	48 0f af de          	imul   rbx,rsi
  20e4a1:	48 89 d8             	mov    rax,rbx
  20e4a4:	48 c1 e8 20          	shr    rax,0x20
  20e4a8:	75 ac                	jne    20e456 <BmPoor.init.setup+0x346>
  20e4aa:	31 d2                	xor    edx,edx
  20e4ac:	89 d8                	mov    eax,ebx
  20e4ae:	f7 f1                	div    ecx
  20e4b0:	89 c3                	mov    ebx,eax
                    if (iterations > pSelf.max_iterations) {
  20e4b2:	4c 8b 7c 24 48       	mov    r15,QWORD PTR [rsp+0x48]
  20e4b7:	4c 39 fb             	cmp    rbx,r15
  20e4ba:	49 0f 47 df          	cmova  rbx,r15
                    if (pSelf.logl >= 2) {
  20e4be:	48 83 7c 24 30 02    	cmp    QWORD PTR [rsp+0x30],0x2
  20e4c4:	0f 82 81 fd ff ff    	jb     20e24b <BmPoor.init.setup+0x13b>
  20e4ca:	e9 71 fd ff ff       	jmp    20e240 <BmPoor.init.setup+0x130>
  20e4cf:	90                   	nop
  20e4d0:	c5 fa 6f 05 38 1e ff 	vmovdqu xmm0,XMMWORD PTR [rip+0xffffffffffff1e38]        # 200310 <__unnamed_35>
  20e4d7:	ff 
  20e4d8:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
                if (errno != 0) return std.os.unexpectedErrorPosix(errno);
  20e4de:	0f 82 ed fd ff ff    	jb     20e2d1 <BmPoor.init.setup+0x1c1>
  20e4e4:	e9 f7 07 00 00       	jmp    20ece0 <BmPoor.init.setup+0xbd0>
  20e4e9:	c5 f9 6f 8c 24 c0 00 	vmovdqa xmm1,XMMWORD PTR [rsp+0xc0]
  20e4f0:	00 00 
  20e4f2:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
  20e4f8:	0f 82 37 fe ff ff    	jb     20e335 <BmPoor.init.setup+0x225>
  20e4fe:	e9 f3 07 00 00       	jmp    20ecf6 <BmPoor.init.setup+0xbe6>
  20e503:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20e50a:	84 00 00 00 00 00 
                            Result { .run_time_ns = run_time_ns, .iterations = iterations});
  20e510:	48 89 ac 24 e8 00 00 	mov    QWORD PTR [rsp+0xe8],rbp
  20e517:	00 
  20e518:	48 89 9c 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rbx
  20e51f:	00 
                    try pSelf.results.append(
  20e520:	48 8d 7c 24 68       	lea    rdi,[rsp+0x68]
  20e525:	48 8d b4 24 e8 00 00 	lea    rsi,[rsp+0xe8]
  20e52c:	00 
  20e52d:	e8 7e 48 00 00       	call   212db0 <AlignedArrayList(Result,8)_append>
  20e532:	66 85 c0             	test   ax,ax
  20e535:	8b 4c 24 1c          	mov    ecx,DWORD PTR [rsp+0x1c]
  20e539:	74 18                	je     20e553 <BmPoor.init.setup+0x443>
  20e53b:	e9 a4 07 00 00       	jmp    20ece4 <BmPoor.init.setup+0xbd4>
  20e540:	49 89 ee             	mov    r14,rbp
            while (iterations <= pSelf.max_iterations) {
  20e543:	4c 8b 7c 24 48       	mov    r15,QWORD PTR [rsp+0x48]
  20e548:	31 c9                	xor    ecx,ecx
  20e54a:	4c 39 fb             	cmp    rbx,r15
  20e54d:	0f 86 d9 fc ff ff    	jbe    20e22c <BmPoor.init.setup+0x11c>
            if (once) {
  20e553:	f6 c1 01             	test   cl,0x1
  20e556:	48 8d 6c 24 07       	lea    rbp,[rsp+0x7]
  20e55b:	49 89 ef             	mov    r15,rbp
  20e55e:	4c 89 f5             	mov    rbp,r14
  20e561:	4c 8d 74 24 08       	lea    r14,[rsp+0x8]
  20e566:	0f 84 7a 06 00 00    	je     20ebe6 <BmPoor.init.setup+0xad6>
                try leftJustified(22, "name repetitions:{}", pSelf.repetitions);
  20e56c:	48 8b 7c 24 40       	mov    rdi,QWORD PTR [rsp+0x40]
  20e571:	e8 2a 6e 00 00       	call   2153a0 <Benchmark_leftJustified>
  20e576:	66 85 c0             	test   ax,ax
  20e579:	0f 85 65 07 00 00    	jne    20ece4 <BmPoor.init.setup+0xbd4>
                try rightJustified(14, "{}", "iterations");
  20e57f:	e8 bc 70 00 00       	call   215640 <Benchmark_rightJustified>
  20e584:	66 85 c0             	test   ax,ax
  20e587:	0f 85 57 07 00 00    	jne    20ece4 <BmPoor.init.setup+0xbd4>
        var buffer: [40]u8 = undefined;
  20e58d:	c5 fe 6f 05 ba 79 ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffff79ba]        # 205f4f <__unnamed_7>
  20e594:	ff 
  20e595:	c5 fe 7f 84 24 90 00 	vmovdqu YMMWORD PTR [rsp+0x90],ymm0
  20e59c:	00 00 
  20e59e:	48 8b 05 ca 79 ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffff79ca]        # 205f6f <__unnamed_7+0x20>
  20e5a5:	48 89 84 24 b0 00 00 	mov    QWORD PTR [rsp+0xb0],rax
  20e5ac:	00 
  20e5ad:	c7 84 24 90 00 00 00 	mov    DWORD PTR [rsp+0x90],0x656d6974
  20e5b4:	74 69 6d 65 
  20e5b8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  20e5bf:	00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20e5c0:	b0 01                	mov    al,0x1
  20e5c2:	86 05 48 2a 04 00    	xchg   BYTE PTR [rip+0x42a48],al        # 251010 <stderr_mutex>
  20e5c8:	84 c0                	test   al,al
  20e5ca:	75 f4                	jne    20e5c0 <BmPoor.init.setup+0x4b0>
    if (stderr_stream) |st| {
  20e5cc:	48 8b 3d 35 2a 04 00 	mov    rdi,QWORD PTR [rip+0x42a35]        # 251008 <stderr_stream>
  20e5d3:	48 85 ff             	test   rdi,rdi
  20e5d6:	74 18                	je     20e5f0 <BmPoor.init.setup+0x4e0>
  20e5d8:	48 8b 0d 61 da 03 00 	mov    rcx,QWORD PTR [rip+0x3da61]        # 24c040 <stderr_file_out_stream+0x8>
  20e5df:	eb 4c                	jmp    20e62d <BmPoor.init.setup+0x51d>
  20e5e1:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20e5e8:	0f 1f 84 00 00 00 00 
  20e5ef:	00 
        stderr_file = try io.getStdErr();
  20e5f0:	c7 05 36 da 03 00 02 	mov    DWORD PTR [rip+0x3da36],0x2        # 24c030 <stderr_file>
  20e5f7:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20e5fa:	48 8d 05 2f da 03 00 	lea    rax,[rip+0x3da2f]        # 24c030 <stderr_file>
  20e601:	48 89 05 30 da 03 00 	mov    QWORD PTR [rip+0x3da30],rax        # 24c038 <stderr_file_out_stream>
  20e608:	48 8d 05 91 08 01 00 	lea    rax,[rip+0x10891]        # 21eea0 <FileOutStream_writeFn>
  20e60f:	48 89 05 2a da 03 00 	mov    QWORD PTR [rip+0x3da2a],rax        # 24c040 <stderr_file_out_stream+0x8>
  20e616:	48 8d 0d 23 da 03 00 	lea    rcx,[rip+0x3da23]        # 24c040 <stderr_file_out_stream+0x8>
  20e61d:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20e620:	48 89 15 e1 29 04 00 	mov    QWORD PTR [rip+0x429e1],rdx        # 251008 <stderr_stream>
  20e627:	48 89 c1             	mov    rcx,rax
  20e62a:	48 89 d7             	mov    rdi,rdx
  20e62d:	c6 44 24 07 20       	mov    BYTE PTR [rsp+0x7],0x20
    return output(context, (*[1]u8)(&c)[0..]);
  20e632:	4c 89 7c 24 08       	mov    QWORD PTR [rsp+0x8],r15
  20e637:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  20e63e:	00 00 
  20e640:	4c 89 f6             	mov    rsi,r14
  20e643:	c5 f8 77             	vzeroupper 
  20e646:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20e648:	31 c0                	xor    eax,eax
  20e64a:	86 05 c0 29 04 00    	xchg   BYTE PTR [rip+0x429c0],al        # 251010 <stderr_mutex>
  20e650:	3c 01                	cmp    al,0x1
    if (!ok) {
  20e652:	0f 85 9e 06 00 00    	jne    20ecf6 <BmPoor.init.setup+0xbe6>
  20e658:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  20e65f:	00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20e660:	b0 01                	mov    al,0x1
  20e662:	86 05 a8 29 04 00    	xchg   BYTE PTR [rip+0x429a8],al        # 251010 <stderr_mutex>
  20e668:	84 c0                	test   al,al
  20e66a:	75 f4                	jne    20e660 <BmPoor.init.setup+0x550>
    if (stderr_stream) |st| {
  20e66c:	48 8b 3d 95 29 04 00 	mov    rdi,QWORD PTR [rip+0x42995]        # 251008 <stderr_stream>
  20e673:	48 85 ff             	test   rdi,rdi
  20e676:	74 18                	je     20e690 <BmPoor.init.setup+0x580>
  20e678:	48 8b 0d c1 d9 03 00 	mov    rcx,QWORD PTR [rip+0x3d9c1]        # 24c040 <stderr_file_out_stream+0x8>
  20e67f:	eb 4c                	jmp    20e6cd <BmPoor.init.setup+0x5bd>
  20e681:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20e688:	0f 1f 84 00 00 00 00 
  20e68f:	00 
        stderr_file = try io.getStdErr();
  20e690:	c7 05 96 d9 03 00 02 	mov    DWORD PTR [rip+0x3d996],0x2        # 24c030 <stderr_file>
  20e697:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20e69a:	48 8d 05 8f d9 03 00 	lea    rax,[rip+0x3d98f]        # 24c030 <stderr_file>
  20e6a1:	48 89 05 90 d9 03 00 	mov    QWORD PTR [rip+0x3d990],rax        # 24c038 <stderr_file_out_stream>
  20e6a8:	48 8d 05 f1 07 01 00 	lea    rax,[rip+0x107f1]        # 21eea0 <FileOutStream_writeFn>
  20e6af:	48 89 05 8a d9 03 00 	mov    QWORD PTR [rip+0x3d98a],rax        # 24c040 <stderr_file_out_stream+0x8>
  20e6b6:	48 8d 0d 83 d9 03 00 	lea    rcx,[rip+0x3d983]        # 24c040 <stderr_file_out_stream+0x8>
  20e6bd:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20e6c0:	48 89 15 41 29 04 00 	mov    QWORD PTR [rip+0x42941],rdx        # 251008 <stderr_stream>
  20e6c7:	48 89 c1             	mov    rcx,rax
  20e6ca:	48 89 d7             	mov    rdi,rdx
  20e6cd:	c6 44 24 07 20       	mov    BYTE PTR [rsp+0x7],0x20
  20e6d2:	4c 89 7c 24 08       	mov    QWORD PTR [rsp+0x8],r15
  20e6d7:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  20e6de:	00 00 
  20e6e0:	4c 89 f6             	mov    rsi,r14
  20e6e3:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20e6e5:	31 c0                	xor    eax,eax
  20e6e7:	86 05 23 29 04 00    	xchg   BYTE PTR [rip+0x42923],al        # 251010 <stderr_mutex>
  20e6ed:	3c 01                	cmp    al,0x1
    if (!ok) {
  20e6ef:	0f 85 01 06 00 00    	jne    20ecf6 <BmPoor.init.setup+0xbe6>
  20e6f5:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20e6fc:	00 00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20e700:	b0 01                	mov    al,0x1
  20e702:	86 05 08 29 04 00    	xchg   BYTE PTR [rip+0x42908],al        # 251010 <stderr_mutex>
  20e708:	84 c0                	test   al,al
  20e70a:	75 f4                	jne    20e700 <BmPoor.init.setup+0x5f0>
    if (stderr_stream) |st| {
  20e70c:	48 8b 3d f5 28 04 00 	mov    rdi,QWORD PTR [rip+0x428f5]        # 251008 <stderr_stream>
  20e713:	48 85 ff             	test   rdi,rdi
  20e716:	74 18                	je     20e730 <BmPoor.init.setup+0x620>
  20e718:	48 8b 0d 21 d9 03 00 	mov    rcx,QWORD PTR [rip+0x3d921]        # 24c040 <stderr_file_out_stream+0x8>
  20e71f:	eb 4c                	jmp    20e76d <BmPoor.init.setup+0x65d>
  20e721:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20e728:	0f 1f 84 00 00 00 00 
  20e72f:	00 
        stderr_file = try io.getStdErr();
  20e730:	c7 05 f6 d8 03 00 02 	mov    DWORD PTR [rip+0x3d8f6],0x2        # 24c030 <stderr_file>
  20e737:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20e73a:	48 8d 05 ef d8 03 00 	lea    rax,[rip+0x3d8ef]        # 24c030 <stderr_file>
  20e741:	48 89 05 f0 d8 03 00 	mov    QWORD PTR [rip+0x3d8f0],rax        # 24c038 <stderr_file_out_stream>
  20e748:	48 8d 05 51 07 01 00 	lea    rax,[rip+0x10751]        # 21eea0 <FileOutStream_writeFn>
  20e74f:	48 89 05 ea d8 03 00 	mov    QWORD PTR [rip+0x3d8ea],rax        # 24c040 <stderr_file_out_stream+0x8>
  20e756:	48 8d 0d e3 d8 03 00 	lea    rcx,[rip+0x3d8e3]        # 24c040 <stderr_file_out_stream+0x8>
  20e75d:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20e760:	48 89 15 a1 28 04 00 	mov    QWORD PTR [rip+0x428a1],rdx        # 251008 <stderr_stream>
  20e767:	48 89 c1             	mov    rcx,rax
  20e76a:	48 89 d7             	mov    rdi,rdx
  20e76d:	c6 44 24 07 20       	mov    BYTE PTR [rsp+0x7],0x20
  20e772:	4c 89 7c 24 08       	mov    QWORD PTR [rsp+0x8],r15
  20e777:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  20e77e:	00 00 
  20e780:	4c 89 f6             	mov    rsi,r14
  20e783:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20e785:	31 c0                	xor    eax,eax
  20e787:	86 05 83 28 04 00    	xchg   BYTE PTR [rip+0x42883],al        # 251010 <stderr_mutex>
  20e78d:	3c 01                	cmp    al,0x1
    if (!ok) {
  20e78f:	0f 85 61 05 00 00    	jne    20ecf6 <BmPoor.init.setup+0xbe6>
  20e795:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20e79c:	00 00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20e7a0:	b0 01                	mov    al,0x1
  20e7a2:	86 05 68 28 04 00    	xchg   BYTE PTR [rip+0x42868],al        # 251010 <stderr_mutex>
  20e7a8:	84 c0                	test   al,al
  20e7aa:	75 f4                	jne    20e7a0 <BmPoor.init.setup+0x690>
    if (stderr_stream) |st| {
  20e7ac:	48 8b 3d 55 28 04 00 	mov    rdi,QWORD PTR [rip+0x42855]        # 251008 <stderr_stream>
  20e7b3:	48 85 ff             	test   rdi,rdi
  20e7b6:	74 18                	je     20e7d0 <BmPoor.init.setup+0x6c0>
  20e7b8:	48 8b 0d 81 d8 03 00 	mov    rcx,QWORD PTR [rip+0x3d881]        # 24c040 <stderr_file_out_stream+0x8>
  20e7bf:	eb 4c                	jmp    20e80d <BmPoor.init.setup+0x6fd>
  20e7c1:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20e7c8:	0f 1f 84 00 00 00 00 
  20e7cf:	00 
        stderr_file = try io.getStdErr();
  20e7d0:	c7 05 56 d8 03 00 02 	mov    DWORD PTR [rip+0x3d856],0x2        # 24c030 <stderr_file>
  20e7d7:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20e7da:	48 8d 05 4f d8 03 00 	lea    rax,[rip+0x3d84f]        # 24c030 <stderr_file>
  20e7e1:	48 89 05 50 d8 03 00 	mov    QWORD PTR [rip+0x3d850],rax        # 24c038 <stderr_file_out_stream>
  20e7e8:	48 8d 05 b1 06 01 00 	lea    rax,[rip+0x106b1]        # 21eea0 <FileOutStream_writeFn>
  20e7ef:	48 89 05 4a d8 03 00 	mov    QWORD PTR [rip+0x3d84a],rax        # 24c040 <stderr_file_out_stream+0x8>
  20e7f6:	48 8d 0d 43 d8 03 00 	lea    rcx,[rip+0x3d843]        # 24c040 <stderr_file_out_stream+0x8>
  20e7fd:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20e800:	48 89 15 01 28 04 00 	mov    QWORD PTR [rip+0x42801],rdx        # 251008 <stderr_stream>
  20e807:	48 89 c1             	mov    rcx,rax
  20e80a:	48 89 d7             	mov    rdi,rdx
  20e80d:	c6 44 24 07 20       	mov    BYTE PTR [rsp+0x7],0x20
  20e812:	4c 89 7c 24 08       	mov    QWORD PTR [rsp+0x8],r15
  20e817:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  20e81e:	00 00 
  20e820:	4c 89 f6             	mov    rsi,r14
  20e823:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20e825:	31 c0                	xor    eax,eax
  20e827:	86 05 e3 27 04 00    	xchg   BYTE PTR [rip+0x427e3],al        # 251010 <stderr_mutex>
  20e82d:	3c 01                	cmp    al,0x1
    if (!ok) {
  20e82f:	0f 85 c1 04 00 00    	jne    20ecf6 <BmPoor.init.setup+0xbe6>
  20e835:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20e83c:	00 00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20e840:	b0 01                	mov    al,0x1
  20e842:	86 05 c8 27 04 00    	xchg   BYTE PTR [rip+0x427c8],al        # 251010 <stderr_mutex>
  20e848:	84 c0                	test   al,al
  20e84a:	75 f4                	jne    20e840 <BmPoor.init.setup+0x730>
    if (stderr_stream) |st| {
  20e84c:	48 8b 3d b5 27 04 00 	mov    rdi,QWORD PTR [rip+0x427b5]        # 251008 <stderr_stream>
  20e853:	48 85 ff             	test   rdi,rdi
  20e856:	74 18                	je     20e870 <BmPoor.init.setup+0x760>
  20e858:	48 8b 0d e1 d7 03 00 	mov    rcx,QWORD PTR [rip+0x3d7e1]        # 24c040 <stderr_file_out_stream+0x8>
  20e85f:	eb 4c                	jmp    20e8ad <BmPoor.init.setup+0x79d>
  20e861:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20e868:	0f 1f 84 00 00 00 00 
  20e86f:	00 
        stderr_file = try io.getStdErr();
  20e870:	c7 05 b6 d7 03 00 02 	mov    DWORD PTR [rip+0x3d7b6],0x2        # 24c030 <stderr_file>
  20e877:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20e87a:	48 8d 05 af d7 03 00 	lea    rax,[rip+0x3d7af]        # 24c030 <stderr_file>
  20e881:	48 89 05 b0 d7 03 00 	mov    QWORD PTR [rip+0x3d7b0],rax        # 24c038 <stderr_file_out_stream>
  20e888:	48 8d 05 11 06 01 00 	lea    rax,[rip+0x10611]        # 21eea0 <FileOutStream_writeFn>
  20e88f:	48 89 05 aa d7 03 00 	mov    QWORD PTR [rip+0x3d7aa],rax        # 24c040 <stderr_file_out_stream+0x8>
  20e896:	48 8d 0d a3 d7 03 00 	lea    rcx,[rip+0x3d7a3]        # 24c040 <stderr_file_out_stream+0x8>
  20e89d:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20e8a0:	48 89 15 61 27 04 00 	mov    QWORD PTR [rip+0x42761],rdx        # 251008 <stderr_stream>
  20e8a7:	48 89 c1             	mov    rcx,rax
  20e8aa:	48 89 d7             	mov    rdi,rdx
  20e8ad:	c6 44 24 07 20       	mov    BYTE PTR [rsp+0x7],0x20
  20e8b2:	4c 89 7c 24 08       	mov    QWORD PTR [rsp+0x8],r15
  20e8b7:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  20e8be:	00 00 
  20e8c0:	4c 89 f6             	mov    rsi,r14
  20e8c3:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20e8c5:	31 c0                	xor    eax,eax
  20e8c7:	86 05 43 27 04 00    	xchg   BYTE PTR [rip+0x42743],al        # 251010 <stderr_mutex>
  20e8cd:	3c 01                	cmp    al,0x1
    if (!ok) {
  20e8cf:	0f 85 21 04 00 00    	jne    20ecf6 <BmPoor.init.setup+0xbe6>
  20e8d5:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20e8dc:	00 00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20e8e0:	b0 01                	mov    al,0x1
  20e8e2:	86 05 28 27 04 00    	xchg   BYTE PTR [rip+0x42728],al        # 251010 <stderr_mutex>
  20e8e8:	84 c0                	test   al,al
  20e8ea:	75 f4                	jne    20e8e0 <BmPoor.init.setup+0x7d0>
    if (stderr_stream) |st| {
  20e8ec:	48 8b 3d 15 27 04 00 	mov    rdi,QWORD PTR [rip+0x42715]        # 251008 <stderr_stream>
  20e8f3:	48 85 ff             	test   rdi,rdi
  20e8f6:	74 18                	je     20e910 <BmPoor.init.setup+0x800>
  20e8f8:	48 8b 0d 41 d7 03 00 	mov    rcx,QWORD PTR [rip+0x3d741]        # 24c040 <stderr_file_out_stream+0x8>
  20e8ff:	eb 4c                	jmp    20e94d <BmPoor.init.setup+0x83d>
  20e901:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20e908:	0f 1f 84 00 00 00 00 
  20e90f:	00 
        stderr_file = try io.getStdErr();
  20e910:	c7 05 16 d7 03 00 02 	mov    DWORD PTR [rip+0x3d716],0x2        # 24c030 <stderr_file>
  20e917:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20e91a:	48 8d 05 0f d7 03 00 	lea    rax,[rip+0x3d70f]        # 24c030 <stderr_file>
  20e921:	48 89 05 10 d7 03 00 	mov    QWORD PTR [rip+0x3d710],rax        # 24c038 <stderr_file_out_stream>
  20e928:	48 8d 05 71 05 01 00 	lea    rax,[rip+0x10571]        # 21eea0 <FileOutStream_writeFn>
  20e92f:	48 89 05 0a d7 03 00 	mov    QWORD PTR [rip+0x3d70a],rax        # 24c040 <stderr_file_out_stream+0x8>
  20e936:	48 8d 0d 03 d7 03 00 	lea    rcx,[rip+0x3d703]        # 24c040 <stderr_file_out_stream+0x8>
  20e93d:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20e940:	48 89 15 c1 26 04 00 	mov    QWORD PTR [rip+0x426c1],rdx        # 251008 <stderr_stream>
  20e947:	48 89 c1             	mov    rcx,rax
  20e94a:	48 89 d7             	mov    rdi,rdx
  20e94d:	c6 44 24 07 20       	mov    BYTE PTR [rsp+0x7],0x20
  20e952:	4c 89 7c 24 08       	mov    QWORD PTR [rsp+0x8],r15
  20e957:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  20e95e:	00 00 
  20e960:	4c 89 f6             	mov    rsi,r14
  20e963:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20e965:	31 c0                	xor    eax,eax
  20e967:	86 05 a3 26 04 00    	xchg   BYTE PTR [rip+0x426a3],al        # 251010 <stderr_mutex>
  20e96d:	3c 01                	cmp    al,0x1
    if (!ok) {
  20e96f:	0f 85 81 03 00 00    	jne    20ecf6 <BmPoor.init.setup+0xbe6>
  20e975:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20e97c:	00 00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20e980:	b0 01                	mov    al,0x1
  20e982:	86 05 88 26 04 00    	xchg   BYTE PTR [rip+0x42688],al        # 251010 <stderr_mutex>
  20e988:	84 c0                	test   al,al
  20e98a:	75 f4                	jne    20e980 <BmPoor.init.setup+0x870>
    if (stderr_stream) |st| {
  20e98c:	48 8b 3d 75 26 04 00 	mov    rdi,QWORD PTR [rip+0x42675]        # 251008 <stderr_stream>
  20e993:	48 85 ff             	test   rdi,rdi
  20e996:	74 18                	je     20e9b0 <BmPoor.init.setup+0x8a0>
  20e998:	48 8b 0d a1 d6 03 00 	mov    rcx,QWORD PTR [rip+0x3d6a1]        # 24c040 <stderr_file_out_stream+0x8>
  20e99f:	eb 4c                	jmp    20e9ed <BmPoor.init.setup+0x8dd>
  20e9a1:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20e9a8:	0f 1f 84 00 00 00 00 
  20e9af:	00 
        stderr_file = try io.getStdErr();
  20e9b0:	c7 05 76 d6 03 00 02 	mov    DWORD PTR [rip+0x3d676],0x2        # 24c030 <stderr_file>
  20e9b7:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20e9ba:	48 8d 05 6f d6 03 00 	lea    rax,[rip+0x3d66f]        # 24c030 <stderr_file>
  20e9c1:	48 89 05 70 d6 03 00 	mov    QWORD PTR [rip+0x3d670],rax        # 24c038 <stderr_file_out_stream>
  20e9c8:	48 8d 05 d1 04 01 00 	lea    rax,[rip+0x104d1]        # 21eea0 <FileOutStream_writeFn>
  20e9cf:	48 89 05 6a d6 03 00 	mov    QWORD PTR [rip+0x3d66a],rax        # 24c040 <stderr_file_out_stream+0x8>
  20e9d6:	48 8d 0d 63 d6 03 00 	lea    rcx,[rip+0x3d663]        # 24c040 <stderr_file_out_stream+0x8>
  20e9dd:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20e9e0:	48 89 15 21 26 04 00 	mov    QWORD PTR [rip+0x42621],rdx        # 251008 <stderr_stream>
  20e9e7:	48 89 c1             	mov    rcx,rax
  20e9ea:	48 89 d7             	mov    rdi,rdx
  20e9ed:	c6 44 24 07 20       	mov    BYTE PTR [rsp+0x7],0x20
  20e9f2:	4c 89 7c 24 08       	mov    QWORD PTR [rsp+0x8],r15
  20e9f7:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  20e9fe:	00 00 
  20ea00:	4c 89 f6             	mov    rsi,r14
  20ea03:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20ea05:	31 c0                	xor    eax,eax
  20ea07:	86 05 03 26 04 00    	xchg   BYTE PTR [rip+0x42603],al        # 251010 <stderr_mutex>
  20ea0d:	3c 01                	cmp    al,0x1
    if (!ok) {
  20ea0f:	0f 85 e1 02 00 00    	jne    20ecf6 <BmPoor.init.setup+0xbe6>
  20ea15:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20ea1c:	00 00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20ea20:	b0 01                	mov    al,0x1
  20ea22:	86 05 e8 25 04 00    	xchg   BYTE PTR [rip+0x425e8],al        # 251010 <stderr_mutex>
  20ea28:	84 c0                	test   al,al
  20ea2a:	75 f4                	jne    20ea20 <BmPoor.init.setup+0x910>
    if (stderr_stream) |st| {
  20ea2c:	48 8b 3d d5 25 04 00 	mov    rdi,QWORD PTR [rip+0x425d5]        # 251008 <stderr_stream>
  20ea33:	48 85 ff             	test   rdi,rdi
  20ea36:	74 18                	je     20ea50 <BmPoor.init.setup+0x940>
  20ea38:	48 8b 0d 01 d6 03 00 	mov    rcx,QWORD PTR [rip+0x3d601]        # 24c040 <stderr_file_out_stream+0x8>
  20ea3f:	eb 4c                	jmp    20ea8d <BmPoor.init.setup+0x97d>
  20ea41:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20ea48:	0f 1f 84 00 00 00 00 
  20ea4f:	00 
        stderr_file = try io.getStdErr();
  20ea50:	c7 05 d6 d5 03 00 02 	mov    DWORD PTR [rip+0x3d5d6],0x2        # 24c030 <stderr_file>
  20ea57:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20ea5a:	48 8d 05 cf d5 03 00 	lea    rax,[rip+0x3d5cf]        # 24c030 <stderr_file>
  20ea61:	48 89 05 d0 d5 03 00 	mov    QWORD PTR [rip+0x3d5d0],rax        # 24c038 <stderr_file_out_stream>
  20ea68:	48 8d 05 31 04 01 00 	lea    rax,[rip+0x10431]        # 21eea0 <FileOutStream_writeFn>
  20ea6f:	48 89 05 ca d5 03 00 	mov    QWORD PTR [rip+0x3d5ca],rax        # 24c040 <stderr_file_out_stream+0x8>
  20ea76:	48 8d 0d c3 d5 03 00 	lea    rcx,[rip+0x3d5c3]        # 24c040 <stderr_file_out_stream+0x8>
  20ea7d:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20ea80:	48 89 15 81 25 04 00 	mov    QWORD PTR [rip+0x42581],rdx        # 251008 <stderr_stream>
  20ea87:	48 89 c1             	mov    rcx,rax
  20ea8a:	48 89 d7             	mov    rdi,rdx
  20ea8d:	c6 44 24 07 20       	mov    BYTE PTR [rsp+0x7],0x20
  20ea92:	4c 89 7c 24 08       	mov    QWORD PTR [rsp+0x8],r15
  20ea97:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  20ea9e:	00 00 
  20eaa0:	4c 89 f6             	mov    rsi,r14
  20eaa3:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20eaa5:	31 c0                	xor    eax,eax
  20eaa7:	86 05 63 25 04 00    	xchg   BYTE PTR [rip+0x42563],al        # 251010 <stderr_mutex>
  20eaad:	3c 01                	cmp    al,0x1
    if (!ok) {
  20eaaf:	0f 85 41 02 00 00    	jne    20ecf6 <BmPoor.init.setup+0xbe6>
  20eab5:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20eabc:	00 00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20eac0:	b0 01                	mov    al,0x1
  20eac2:	86 05 48 25 04 00    	xchg   BYTE PTR [rip+0x42548],al        # 251010 <stderr_mutex>
  20eac8:	84 c0                	test   al,al
  20eaca:	75 f4                	jne    20eac0 <BmPoor.init.setup+0x9b0>
    if (stderr_stream) |st| {
  20eacc:	48 8b 3d 35 25 04 00 	mov    rdi,QWORD PTR [rip+0x42535]        # 251008 <stderr_stream>
  20ead3:	48 85 ff             	test   rdi,rdi
  20ead6:	74 18                	je     20eaf0 <BmPoor.init.setup+0x9e0>
  20ead8:	48 8b 0d 61 d5 03 00 	mov    rcx,QWORD PTR [rip+0x3d561]        # 24c040 <stderr_file_out_stream+0x8>
  20eadf:	eb 4c                	jmp    20eb2d <BmPoor.init.setup+0xa1d>
  20eae1:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20eae8:	0f 1f 84 00 00 00 00 
  20eaef:	00 
        stderr_file = try io.getStdErr();
  20eaf0:	c7 05 36 d5 03 00 02 	mov    DWORD PTR [rip+0x3d536],0x2        # 24c030 <stderr_file>
  20eaf7:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20eafa:	48 8d 05 2f d5 03 00 	lea    rax,[rip+0x3d52f]        # 24c030 <stderr_file>
  20eb01:	48 89 05 30 d5 03 00 	mov    QWORD PTR [rip+0x3d530],rax        # 24c038 <stderr_file_out_stream>
  20eb08:	48 8d 05 91 03 01 00 	lea    rax,[rip+0x10391]        # 21eea0 <FileOutStream_writeFn>
  20eb0f:	48 89 05 2a d5 03 00 	mov    QWORD PTR [rip+0x3d52a],rax        # 24c040 <stderr_file_out_stream+0x8>
  20eb16:	48 8d 0d 23 d5 03 00 	lea    rcx,[rip+0x3d523]        # 24c040 <stderr_file_out_stream+0x8>
  20eb1d:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20eb20:	48 89 15 e1 24 04 00 	mov    QWORD PTR [rip+0x424e1],rdx        # 251008 <stderr_stream>
  20eb27:	48 89 c1             	mov    rcx,rax
  20eb2a:	48 89 d7             	mov    rdi,rdx
                const casted_value = ([]const u8)(value);
  20eb2d:	4c 89 64 24 08       	mov    QWORD PTR [rsp+0x8],r12
  20eb32:	48 c7 44 24 10 04 00 	mov    QWORD PTR [rsp+0x10],0x4
  20eb39:	00 00 
                return output(context, casted_value);
  20eb3b:	4c 89 f6             	mov    rsi,r14
  20eb3e:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20eb40:	31 c0                	xor    eax,eax
  20eb42:	86 05 c8 24 04 00    	xchg   BYTE PTR [rip+0x424c8],al        # 251010 <stderr_mutex>
  20eb48:	3c 01                	cmp    al,0x1
    if (!ok) {
  20eb4a:	0f 85 a6 01 00 00    	jne    20ecf6 <BmPoor.init.setup+0xbe6>
                try rightJustified(18, "{}", "time/operation");
  20eb50:	e8 cb 6d 00 00       	call   215920 <Benchmark_rightJustified.39>
  20eb55:	66 85 c0             	test   ax,ax
  20eb58:	0f 85 86 01 00 00    	jne    20ece4 <BmPoor.init.setup+0xbd4>
  20eb5e:	66 90                	xchg   ax,ax
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20eb60:	b0 01                	mov    al,0x1
  20eb62:	86 05 a8 24 04 00    	xchg   BYTE PTR [rip+0x424a8],al        # 251010 <stderr_mutex>
  20eb68:	84 c0                	test   al,al
  20eb6a:	75 f4                	jne    20eb60 <BmPoor.init.setup+0xa50>
    if (stderr_stream) |st| {
  20eb6c:	48 8b 3d 95 24 04 00 	mov    rdi,QWORD PTR [rip+0x42495]        # 251008 <stderr_stream>
  20eb73:	48 85 ff             	test   rdi,rdi
  20eb76:	74 18                	je     20eb90 <BmPoor.init.setup+0xa80>
  20eb78:	48 8b 0d c1 d4 03 00 	mov    rcx,QWORD PTR [rip+0x3d4c1]        # 24c040 <stderr_file_out_stream+0x8>
  20eb7f:	eb 4c                	jmp    20ebcd <BmPoor.init.setup+0xabd>
  20eb81:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20eb88:	0f 1f 84 00 00 00 00 
  20eb8f:	00 
        stderr_file = try io.getStdErr();
  20eb90:	c7 05 96 d4 03 00 02 	mov    DWORD PTR [rip+0x3d496],0x2        # 24c030 <stderr_file>
  20eb97:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20eb9a:	48 8d 05 8f d4 03 00 	lea    rax,[rip+0x3d48f]        # 24c030 <stderr_file>
  20eba1:	48 89 05 90 d4 03 00 	mov    QWORD PTR [rip+0x3d490],rax        # 24c038 <stderr_file_out_stream>
  20eba8:	48 8d 05 f1 02 01 00 	lea    rax,[rip+0x102f1]        # 21eea0 <FileOutStream_writeFn>
  20ebaf:	48 89 05 8a d4 03 00 	mov    QWORD PTR [rip+0x3d48a],rax        # 24c040 <stderr_file_out_stream+0x8>
  20ebb6:	48 8d 0d 83 d4 03 00 	lea    rcx,[rip+0x3d483]        # 24c040 <stderr_file_out_stream+0x8>
  20ebbd:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20ebc0:	48 89 15 41 24 04 00 	mov    QWORD PTR [rip+0x42441],rdx        # 251008 <stderr_stream>
  20ebc7:	48 89 c1             	mov    rcx,rax
  20ebca:	48 89 d7             	mov    rdi,rdx
        try output(context, fmt[start_index..]);
  20ebcd:	48 8d 35 1c 13 04 00 	lea    rsi,[rip+0x4131c]        # 24fef0 <__unnamed_3>
  20ebd4:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20ebd6:	31 c0                	xor    eax,eax
  20ebd8:	86 05 32 24 04 00    	xchg   BYTE PTR [rip+0x42432],al        # 251010 <stderr_mutex>
  20ebde:	3c 01                	cmp    al,0x1
    if (!ok) {
  20ebe0:	0f 85 10 01 00 00    	jne    20ecf6 <BmPoor.init.setup+0xbe6>
            try pSelf.report(pSelf.results.items[pSelf.results.len - 1]); warn("\n");
  20ebe6:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  20ebeb:	48 8b 4c 24 78       	mov    rcx,QWORD PTR [rsp+0x78]
  20ebf0:	48 c1 e1 04          	shl    rcx,0x4
  20ebf4:	48 8d 34 08          	lea    rsi,[rax+rcx*1]
  20ebf8:	48 83 c6 f0          	add    rsi,0xfffffffffffffff0
  20ebfc:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  20ec01:	e8 1a 43 00 00       	call   212f20 <Benchmark_report>
  20ec06:	66 85 c0             	test   ax,ax
  20ec09:	0f 85 d5 00 00 00    	jne    20ece4 <BmPoor.init.setup+0xbd4>
  20ec0f:	48 83 c5 01          	add    rbp,0x1
  20ec13:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20ec1a:	84 00 00 00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20ec20:	b0 01                	mov    al,0x1
  20ec22:	86 05 e8 23 04 00    	xchg   BYTE PTR [rip+0x423e8],al        # 251010 <stderr_mutex>
  20ec28:	84 c0                	test   al,al
  20ec2a:	75 f4                	jne    20ec20 <BmPoor.init.setup+0xb10>
    if (stderr_stream) |st| {
  20ec2c:	48 8b 3d d5 23 04 00 	mov    rdi,QWORD PTR [rip+0x423d5]        # 251008 <stderr_stream>
  20ec33:	48 85 ff             	test   rdi,rdi
  20ec36:	74 18                	je     20ec50 <BmPoor.init.setup+0xb40>
  20ec38:	48 8b 0d 01 d4 03 00 	mov    rcx,QWORD PTR [rip+0x3d401]        # 24c040 <stderr_file_out_stream+0x8>
  20ec3f:	eb 4c                	jmp    20ec8d <BmPoor.init.setup+0xb7d>
  20ec41:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20ec48:	0f 1f 84 00 00 00 00 
  20ec4f:	00 
        stderr_file = try io.getStdErr();
  20ec50:	c7 05 d6 d3 03 00 02 	mov    DWORD PTR [rip+0x3d3d6],0x2        # 24c030 <stderr_file>
  20ec57:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20ec5a:	48 8d 05 cf d3 03 00 	lea    rax,[rip+0x3d3cf]        # 24c030 <stderr_file>
  20ec61:	48 89 05 d0 d3 03 00 	mov    QWORD PTR [rip+0x3d3d0],rax        # 24c038 <stderr_file_out_stream>
  20ec68:	48 8d 05 31 02 01 00 	lea    rax,[rip+0x10231]        # 21eea0 <FileOutStream_writeFn>
  20ec6f:	48 89 05 ca d3 03 00 	mov    QWORD PTR [rip+0x3d3ca],rax        # 24c040 <stderr_file_out_stream+0x8>
  20ec76:	48 8d 0d c3 d3 03 00 	lea    rcx,[rip+0x3d3c3]        # 24c040 <stderr_file_out_stream+0x8>
  20ec7d:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20ec80:	48 89 15 81 23 04 00 	mov    QWORD PTR [rip+0x42381],rdx        # 251008 <stderr_stream>
  20ec87:	48 89 c1             	mov    rcx,rax
  20ec8a:	48 89 d7             	mov    rdi,rdx
  20ec8d:	48 8d 35 5c 12 04 00 	lea    rsi,[rip+0x4125c]        # 24fef0 <__unnamed_3>
  20ec94:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20ec96:	31 c0                	xor    eax,eax
  20ec98:	86 05 72 23 04 00    	xchg   BYTE PTR [rip+0x42372],al        # 251010 <stderr_mutex>
  20ec9e:	3c 01                	cmp    al,0x1
    if (!ok) {
  20eca0:	75 54                	jne    20ecf6 <BmPoor.init.setup+0xbe6>
        while (rep < pSelf.repetitions) : (rep += 1) {
  20eca2:	48 3b 6c 24 40       	cmp    rbp,QWORD PTR [rsp+0x40]
  20eca7:	0f 82 93 f8 ff ff    	jb     20e540 <BmPoor.init.setup+0x430>
  20ecad:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
        try pSelf.reportStats(pSelf.results);
  20ecb2:	48 8d 74 24 68       	lea    rsi,[rsp+0x68]
  20ecb7:	e8 44 6f 00 00       	call   215c00 <Benchmark_reportStats>
  20ecbc:	66 85 c0             	test   ax,ax
  20ecbf:	75 23                	jne    20ece4 <BmPoor.init.setup+0xbd4>
    var bmSelf = try bm.run(BmSelf);
    assert(bmSelf.init_count == 1);
    assert(bmSelf.setup_count == 3);
  20ecc1:	48 83 fd 03          	cmp    rbp,0x3
  20ecc5:	75 2f                	jne    20ecf6 <BmPoor.init.setup+0xbe6>
    assert(bmSelf.benchmark_count > 1000000);
  20ecc7:	49 81 fd 40 42 0f 00 	cmp    r13,0xf4240
  20ecce:	76 26                	jbe    20ecf6 <BmPoor.init.setup+0xbe6>
  20ecd0:	31 c0                	xor    eax,eax
  20ecd2:	eb 10                	jmp    20ece4 <BmPoor.init.setup+0xbd4>
                switch (errno) {
  20ecd4:	48 83 f9 16          	cmp    rcx,0x16
  20ecd8:	75 06                	jne    20ece0 <BmPoor.init.setup+0xbd0>
  20ecda:	66 b8 02 00          	mov    ax,0x2
  20ecde:	eb 04                	jmp    20ece4 <BmPoor.init.setup+0xbd4>
  20ece0:	66 b8 03 00          	mov    ax,0x3
    var bmSelf = try bm.run(BmSelf);
  20ece4:	48 81 c4 f8 00 00 00 	add    rsp,0xf8
  20eceb:	5b                   	pop    rbx
  20ecec:	41 5c                	pop    r12
  20ecee:	41 5d                	pop    r13
  20ecf0:	41 5e                	pop    r14
  20ecf2:	41 5f                	pop    r15
  20ecf4:	5d                   	pop    rbp
  20ecf5:	c3                   	ret    
            @panic("assertion failure");
  20ecf6:	48 8d 3d 93 10 04 00 	lea    rdi,[rip+0x41093]        # 24fd90 <__unnamed_2>
  20ecfd:	e8 1e 3a 00 00       	call   212720 <panic>
  20ed02:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20ed09:	1f 84 00 00 00 00 00 

000000000020ed10 <BmPoor.init.setup.tearDown>:
    assert(bmSelf.tearDown_count == 0);
}

test "BmPoor.init.setup.tearDown" {
  20ed10:	55                   	push   rbp
  20ed11:	41 57                	push   r15
  20ed13:	41 56                	push   r14
  20ed15:	41 55                	push   r13
  20ed17:	41 54                	push   r12
  20ed19:	53                   	push   rbx
  20ed1a:	48 81 ec f8 00 00 00 	sub    rsp,0xf8
  20ed21:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20ed28:	0f 1f 84 00 00 00 00 
  20ed2f:	00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20ed30:	b0 01                	mov    al,0x1
  20ed32:	86 05 d8 22 04 00    	xchg   BYTE PTR [rip+0x422d8],al        # 251010 <stderr_mutex>
  20ed38:	84 c0                	test   al,al
  20ed3a:	75 f4                	jne    20ed30 <BmPoor.init.setup.tearDown+0x20>
    if (stderr_stream) |st| {
  20ed3c:	48 8b 3d c5 22 04 00 	mov    rdi,QWORD PTR [rip+0x422c5]        # 251008 <stderr_stream>
  20ed43:	48 85 ff             	test   rdi,rdi
  20ed46:	74 09                	je     20ed51 <BmPoor.init.setup.tearDown+0x41>
  20ed48:	48 8b 05 f1 d2 03 00 	mov    rax,QWORD PTR [rip+0x3d2f1]        # 24c040 <stderr_file_out_stream+0x8>
  20ed4f:	eb 34                	jmp    20ed85 <BmPoor.init.setup.tearDown+0x75>
        stderr_file = try io.getStdErr();
  20ed51:	48 8d 05 d8 d2 03 00 	lea    rax,[rip+0x3d2d8]        # 24c030 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20ed58:	48 89 05 d9 d2 03 00 	mov    QWORD PTR [rip+0x3d2d9],rax        # 24c038 <stderr_file_out_stream>
  20ed5f:	48 8d 05 3a 01 01 00 	lea    rax,[rip+0x1013a]        # 21eea0 <FileOutStream_writeFn>
  20ed66:	48 89 05 d3 d2 03 00 	mov    QWORD PTR [rip+0x3d2d3],rax        # 24c040 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  20ed6d:	c7 05 b9 d2 03 00 02 	mov    DWORD PTR [rip+0x3d2b9],0x2        # 24c030 <stderr_file>
  20ed74:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20ed77:	48 8d 3d c2 d2 03 00 	lea    rdi,[rip+0x3d2c2]        # 24c040 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  20ed7e:	48 89 3d 83 22 04 00 	mov    QWORD PTR [rip+0x42283],rdi        # 251008 <stderr_stream>
  20ed85:	48 8d 35 64 11 04 00 	lea    rsi,[rip+0x41164]        # 24fef0 <__unnamed_3>
  20ed8c:	ff d0                	call   rax
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20ed8e:	31 c0                	xor    eax,eax
  20ed90:	86 05 7a 22 04 00    	xchg   BYTE PTR [rip+0x4227a],al        # 251010 <stderr_mutex>
  20ed96:	3c 01                	cmp    al,0x1
    if (!ok) {
  20ed98:	0f 85 58 0b 00 00    	jne    20f8f6 <BmPoor.init.setup.tearDown+0xbe6>
    // Since this is a test print a \n before we run
    warn("\n");

    // Test fn benchmark(pSelf) can return an error
    var bm = Benchmark.init("BmPoor.init.setup.tearDown", std.debug.global_allocator);
  20ed9e:	c5 f8 10 05 9a 0f 04 	vmovups xmm0,XMMWORD PTR [rip+0x40f9a]        # 24fd40 <__unnamed_13>
  20eda5:	00 
  20eda6:	c5 f8 29 44 24 20    	vmovaps XMMWORD PTR [rsp+0x20],xmm0
  20edac:	49 bf 00 e8 76 48 17 	movabs r15,0x174876e800
  20edb3:	00 00 00 
  20edb6:	b8 00 65 cd 1d       	mov    eax,0x1dcd6500
  20edbb:	c4 e1 f9 6e c0       	vmovq  xmm0,rax
  20edc0:	c5 f9 73 f8 08       	vpslldq xmm0,xmm0,0x8
  20edc5:	c5 f9 7f 44 24 30    	vmovdqa XMMWORD PTR [rsp+0x30],xmm0
  20edcb:	4c 89 7c 24 48       	mov    QWORD PTR [rsp+0x48],r15
  20edd0:	c5 fa 6f 05 38 15 ff 	vmovdqu xmm0,XMMWORD PTR [rip+0xffffffffffff1538]        # 200310 <__unnamed_35>
  20edd7:	ff 
  20edd8:	c5 f9 7f 44 24 50    	vmovdqa XMMWORD PTR [rsp+0x50],xmm0
  20edde:	48 8d 05 1b d2 03 00 	lea    rax,[rip+0x3d21b]        # 24c000 <global_fixed_allocator>
  20ede5:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  20edea:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  20edee:	c5 fa 7f 44 24 68    	vmovdqu XMMWORD PTR [rsp+0x68],xmm0
  20edf4:	48 c7 44 24 78 00 00 	mov    QWORD PTR [rsp+0x78],0x0
  20edfb:	00 00 
  20edfd:	48 89 84 24 80 00 00 	mov    QWORD PTR [rsp+0x80],rax
  20ee04:	00 
        fn tearDown(pSelf: *Self) void {
            pSelf.tearDown_count += 1;
        }
    };

    bm.repetitions = 3;
  20ee05:	48 c7 44 24 40 03 00 	mov    QWORD PTR [rsp+0x40],0x3
  20ee0c:	00 00 
  20ee0e:	b1 01                	mov    cl,0x1
  20ee10:	bb 01 00 00 00       	mov    ebx,0x1
  20ee15:	4c 8d a4 24 90 00 00 	lea    r12,[rsp+0x90]
  20ee1c:	00 
  20ee1d:	45 31 f6             	xor    r14d,r14d
  20ee20:	45 31 ed             	xor    r13d,r13d
            while (iterations <= pSelf.max_iterations) {
  20ee23:	4c 39 fb             	cmp    rbx,r15
  20ee26:	0f 87 27 03 00 00    	ja     20f153 <BmPoor.init.setup.tearDown+0x443>
  20ee2c:	89 4c 24 1c          	mov    DWORD PTR [rsp+0x1c],ecx
  20ee30:	eb 19                	jmp    20ee4b <BmPoor.init.setup.tearDown+0x13b>
  20ee32:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20ee39:	1f 84 00 00 00 00 00 
                        warn("iteratons:{} numer:{} denom:{}\n", iterations, numer, denom);
  20ee40:	48 89 df             	mov    rdi,rbx
  20ee43:	48 89 ca             	mov    rdx,rcx
  20ee46:	e8 e5 61 00 00       	call   215030 <warn.37>
                var ts: posix.timespec = undefined;
  20ee4b:	c5 fa 6f 05 bd 14 ff 	vmovdqu xmm0,XMMWORD PTR [rip+0xffffffffffff14bd]        # 200310 <__unnamed_35>
  20ee52:	ff 
  20ee53:	c5 f9 7f 84 24 90 00 	vmovdqa XMMWORD PTR [rsp+0x90],xmm0
  20ee5a:	00 00 
  20ee5c:	b8 e5 00 00 00       	mov    eax,0xe5
  20ee61:	bf 01 00 00 00       	mov    edi,0x1
  20ee66:	4c 89 e6             	mov    rsi,r12
  20ee69:	0f 05                	syscall 
  20ee6b:	48 89 c1             	mov    rcx,rax
  20ee6e:	48 f7 d9             	neg    rcx
  20ee71:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  20ee77:	b8 00 00 00 00       	mov    eax,0x0
  20ee7c:	48 0f 46 c8          	cmovbe rcx,rax
                switch (errno) {
  20ee80:	48 85 c9             	test   rcx,rcx
  20ee83:	0f 85 4b 0a 00 00    	jne    20f8d4 <BmPoor.init.setup.tearDown+0xbc4>
        const f = @atomicLoad(@typeOf(init_vdso_clock_gettime), &vdso_clock_gettime, builtin.AtomicOrder.Unordered);
  20ee89:	48 8b 05 88 d2 03 00 	mov    rax,QWORD PTR [rip+0x3d288]        # 24c118 <vdso_clock_gettime>
        if (@ptrToInt(f) != 0) {
  20ee90:	48 85 c0             	test   rax,rax
  20ee93:	74 21                	je     20eeb6 <BmPoor.init.setup.tearDown+0x1a6>
            const rc = f(clk_id, tp);
  20ee95:	bf 01 00 00 00       	mov    edi,0x1
  20ee9a:	4c 89 e6             	mov    rsi,r12
  20ee9d:	ff d0                	call   rax
            switch (rc) {
  20ee9f:	48 83 f8 ea          	cmp    rax,0xffffffffffffffea
  20eea3:	0f 84 27 02 00 00    	je     20f0d0 <BmPoor.init.setup.tearDown+0x3c0>
  20eea9:	48 85 c0             	test   rax,rax
  20eeac:	c5 fa 6f 05 5c 14 ff 	vmovdqu xmm0,XMMWORD PTR [rip+0xffffffffffff145c]        # 200310 <__unnamed_35>
  20eeb3:	ff 
  20eeb4:	74 0f                	je     20eec5 <BmPoor.init.setup.tearDown+0x1b5>
  20eeb6:	b8 e4 00 00 00       	mov    eax,0xe4
  20eebb:	bf 01 00 00 00       	mov    edi,0x1
  20eec0:	4c 89 e6             	mov    rsi,r12
  20eec3:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  20eec5:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
                if (errno != 0) return std.os.unexpectedErrorPosix(errno);
  20eecb:	0f 83 0f 0a 00 00    	jae    20f8e0 <BmPoor.init.setup.tearDown+0xbd0>
                self.start_time = @intCast(u64, ts.tv_sec) * u64(ns_per_s) + @intCast(u64, ts.tv_nsec);
  20eed1:	c5 f9 6f 8c 24 90 00 	vmovdqa xmm1,XMMWORD PTR [rsp+0x90]
  20eed8:	00 00 
        var ts: posix.timespec = undefined;
  20eeda:	c5 f9 7f 84 24 90 00 	vmovdqa XMMWORD PTR [rsp+0x90],xmm0
  20eee1:	00 00 
        const f = @atomicLoad(@typeOf(init_vdso_clock_gettime), &vdso_clock_gettime, builtin.AtomicOrder.Unordered);
  20eee3:	48 8b 05 2e d2 03 00 	mov    rax,QWORD PTR [rip+0x3d22e]        # 24c118 <vdso_clock_gettime>
        if (@ptrToInt(f) != 0) {
  20eeea:	48 85 c0             	test   rax,rax
  20eeed:	74 2b                	je     20ef1a <BmPoor.init.setup.tearDown+0x20a>
  20eeef:	c5 f9 7f 8c 24 c0 00 	vmovdqa XMMWORD PTR [rsp+0xc0],xmm1
  20eef6:	00 00 
            const rc = f(clk_id, tp);
  20eef8:	bf 01 00 00 00       	mov    edi,0x1
  20eefd:	4c 89 e6             	mov    rsi,r12
  20ef00:	ff d0                	call   rax
            switch (rc) {
  20ef02:	48 83 f8 ea          	cmp    rax,0xffffffffffffffea
  20ef06:	0f 84 dd 01 00 00    	je     20f0e9 <BmPoor.init.setup.tearDown+0x3d9>
  20ef0c:	48 85 c0             	test   rax,rax
  20ef0f:	c5 f9 6f 8c 24 c0 00 	vmovdqa xmm1,XMMWORD PTR [rsp+0xc0]
  20ef16:	00 00 
  20ef18:	74 0f                	je     20ef29 <BmPoor.init.setup.tearDown+0x219>
  20ef1a:	b8 e4 00 00 00       	mov    eax,0xe4
  20ef1f:	bf 01 00 00 00       	mov    edi,0x1
  20ef24:	4c 89 e6             	mov    rsi,r12
  20ef27:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  20ef29:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
  20ef2f:	0f 83 c1 09 00 00    	jae    20f8f6 <BmPoor.init.setup.tearDown+0xbe6>
  20ef35:	49 01 dd             	add    r13,rbx
        return @intCast(u64, ts.tv_sec) * u64(ns_per_s) + @intCast(u64, ts.tv_nsec);
  20ef38:	c5 f9 6f 84 24 90 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x90]
  20ef3f:	00 00 
  20ef41:	c5 f9 fb c1          	vpsubq xmm0,xmm0,xmm1
  20ef45:	c4 e1 f9 7e c0       	vmovq  rax,xmm0
        var clock = clockNative() - self.start_time;
  20ef4a:	c4 e3 f9 16 c5 01    	vpextrq rbp,xmm0,0x1
  20ef50:	48 69 c0 00 ca 9a 3b 	imul   rax,rax,0x3b9aca00
  20ef57:	48 01 c5             	add    rbp,rax
                if ((run_time_ns >= pSelf.min_runtime_ns) or (iterations >= pSelf.max_iterations)) {
  20ef5a:	48 3b 6c 24 38       	cmp    rbp,QWORD PTR [rsp+0x38]
  20ef5f:	0f 83 ab 01 00 00    	jae    20f110 <BmPoor.init.setup.tearDown+0x400>
  20ef65:	4c 39 fb             	cmp    rbx,r15
  20ef68:	0f 83 a2 01 00 00    	jae    20f110 <BmPoor.init.setup.tearDown+0x400>
                    if (pSelf.logl >= 1) {
  20ef6e:	48 83 7c 24 30 00    	cmp    QWORD PTR [rsp+0x30],0x0
  20ef74:	0f 84 bc 00 00 00    	je     20f036 <BmPoor.init.setup.tearDown+0x326>
                            Result {.run_time_ns = run_time_ns, .iterations = iterations});
  20ef7a:	48 89 ac 24 d8 00 00 	mov    QWORD PTR [rsp+0xd8],rbp
  20ef81:	00 
  20ef82:	48 89 9c 24 e0 00 00 	mov    QWORD PTR [rsp+0xe0],rbx
  20ef89:	00 
                        try pSelf.report(
  20ef8a:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  20ef8f:	48 8d b4 24 d8 00 00 	lea    rsi,[rsp+0xd8]
  20ef96:	00 
  20ef97:	e8 84 3f 00 00       	call   212f20 <Benchmark_report>
  20ef9c:	66 85 c0             	test   ax,ax
  20ef9f:	0f 85 3f 09 00 00    	jne    20f8e4 <BmPoor.init.setup.tearDown+0xbd4>
  20efa5:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20efac:	00 00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20efb0:	b0 01                	mov    al,0x1
  20efb2:	86 05 58 20 04 00    	xchg   BYTE PTR [rip+0x42058],al        # 251010 <stderr_mutex>
  20efb8:	84 c0                	test   al,al
  20efba:	75 f4                	jne    20efb0 <BmPoor.init.setup.tearDown+0x2a0>
    if (stderr_stream) |st| {
  20efbc:	48 8b 3d 45 20 04 00 	mov    rdi,QWORD PTR [rip+0x42045]        # 251008 <stderr_stream>
  20efc3:	48 85 ff             	test   rdi,rdi
  20efc6:	74 18                	je     20efe0 <BmPoor.init.setup.tearDown+0x2d0>
  20efc8:	48 8b 0d 71 d0 03 00 	mov    rcx,QWORD PTR [rip+0x3d071]        # 24c040 <stderr_file_out_stream+0x8>
  20efcf:	eb 4c                	jmp    20f01d <BmPoor.init.setup.tearDown+0x30d>
  20efd1:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20efd8:	0f 1f 84 00 00 00 00 
  20efdf:	00 
        stderr_file = try io.getStdErr();
  20efe0:	c7 05 46 d0 03 00 02 	mov    DWORD PTR [rip+0x3d046],0x2        # 24c030 <stderr_file>
  20efe7:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20efea:	48 8d 05 3f d0 03 00 	lea    rax,[rip+0x3d03f]        # 24c030 <stderr_file>
  20eff1:	48 89 05 40 d0 03 00 	mov    QWORD PTR [rip+0x3d040],rax        # 24c038 <stderr_file_out_stream>
  20eff8:	48 8d 05 a1 fe 00 00 	lea    rax,[rip+0xfea1]        # 21eea0 <FileOutStream_writeFn>
  20efff:	48 89 05 3a d0 03 00 	mov    QWORD PTR [rip+0x3d03a],rax        # 24c040 <stderr_file_out_stream+0x8>
  20f006:	48 8d 0d 33 d0 03 00 	lea    rcx,[rip+0x3d033]        # 24c040 <stderr_file_out_stream+0x8>
  20f00d:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20f010:	48 89 15 f1 1f 04 00 	mov    QWORD PTR [rip+0x41ff1],rdx        # 251008 <stderr_stream>
  20f017:	48 89 c1             	mov    rcx,rax
  20f01a:	48 89 d7             	mov    rdi,rdx
  20f01d:	48 8d 35 cc 0e 04 00 	lea    rsi,[rip+0x40ecc]        # 24fef0 <__unnamed_3>
  20f024:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20f026:	31 c0                	xor    eax,eax
  20f028:	86 05 e2 1f 04 00    	xchg   BYTE PTR [rip+0x41fe2],al        # 251010 <stderr_mutex>
  20f02e:	3c 01                	cmp    al,0x1
    if (!ok) {
  20f030:	0f 85 c0 08 00 00    	jne    20f8f6 <BmPoor.init.setup.tearDown+0xbe6>
                    if (run_time_ns < 1000) {
  20f036:	48 81 fd e8 03 00 00 	cmp    rbp,0x3e8
  20f03d:	73 31                	jae    20f070 <BmPoor.init.setup.tearDown+0x360>
  20f03f:	b9 01 00 00 00       	mov    ecx,0x1
  20f044:	be e8 03 00 00       	mov    esi,0x3e8
                    iterations = (iterations * numer) / denom;
  20f049:	48 0f af de          	imul   rbx,rsi
  20f04d:	48 89 d8             	mov    rax,rbx
  20f050:	48 c1 e8 20          	shr    rax,0x20
  20f054:	74 54                	je     20f0aa <BmPoor.init.setup.tearDown+0x39a>
  20f056:	31 d2                	xor    edx,edx
  20f058:	48 89 d8             	mov    rax,rbx
  20f05b:	48 f7 f1             	div    rcx
  20f05e:	48 89 c3             	mov    rbx,rax
  20f061:	eb 4f                	jmp    20f0b2 <BmPoor.init.setup.tearDown+0x3a2>
  20f063:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20f06a:	84 00 00 00 00 00 
                    } else if (run_time_ns < (pSelf.min_runtime_ns / 10)) {
  20f070:	48 ba cd cc cc cc cc 	movabs rdx,0xcccccccccccccccd
  20f077:	cc cc cc 
  20f07a:	c4 e2 fb f6 4c 24 38 	mulx   rcx,rax,QWORD PTR [rsp+0x38]
  20f081:	48 c1 e9 03          	shr    rcx,0x3
  20f085:	31 c0                	xor    eax,eax
  20f087:	48 39 cd             	cmp    rbp,rcx
  20f08a:	0f 93 c0             	setae  al
  20f08d:	48 8d 0c c0          	lea    rcx,[rax+rax*8]
  20f091:	48 83 c1 01          	add    rcx,0x1
  20f095:	48 8d 34 85 0a 00 00 	lea    rsi,[rax*4+0xa]
  20f09c:	00 
                    iterations = (iterations * numer) / denom;
  20f09d:	48 0f af de          	imul   rbx,rsi
  20f0a1:	48 89 d8             	mov    rax,rbx
  20f0a4:	48 c1 e8 20          	shr    rax,0x20
  20f0a8:	75 ac                	jne    20f056 <BmPoor.init.setup.tearDown+0x346>
  20f0aa:	31 d2                	xor    edx,edx
  20f0ac:	89 d8                	mov    eax,ebx
  20f0ae:	f7 f1                	div    ecx
  20f0b0:	89 c3                	mov    ebx,eax
                    if (iterations > pSelf.max_iterations) {
  20f0b2:	4c 8b 7c 24 48       	mov    r15,QWORD PTR [rsp+0x48]
  20f0b7:	4c 39 fb             	cmp    rbx,r15
  20f0ba:	49 0f 47 df          	cmova  rbx,r15
                    if (pSelf.logl >= 2) {
  20f0be:	48 83 7c 24 30 02    	cmp    QWORD PTR [rsp+0x30],0x2
  20f0c4:	0f 82 81 fd ff ff    	jb     20ee4b <BmPoor.init.setup.tearDown+0x13b>
  20f0ca:	e9 71 fd ff ff       	jmp    20ee40 <BmPoor.init.setup.tearDown+0x130>
  20f0cf:	90                   	nop
  20f0d0:	c5 fa 6f 05 38 12 ff 	vmovdqu xmm0,XMMWORD PTR [rip+0xffffffffffff1238]        # 200310 <__unnamed_35>
  20f0d7:	ff 
  20f0d8:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
                if (errno != 0) return std.os.unexpectedErrorPosix(errno);
  20f0de:	0f 82 ed fd ff ff    	jb     20eed1 <BmPoor.init.setup.tearDown+0x1c1>
  20f0e4:	e9 f7 07 00 00       	jmp    20f8e0 <BmPoor.init.setup.tearDown+0xbd0>
  20f0e9:	c5 f9 6f 8c 24 c0 00 	vmovdqa xmm1,XMMWORD PTR [rsp+0xc0]
  20f0f0:	00 00 
  20f0f2:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
  20f0f8:	0f 82 37 fe ff ff    	jb     20ef35 <BmPoor.init.setup.tearDown+0x225>
  20f0fe:	e9 f3 07 00 00       	jmp    20f8f6 <BmPoor.init.setup.tearDown+0xbe6>
  20f103:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20f10a:	84 00 00 00 00 00 
                            Result { .run_time_ns = run_time_ns, .iterations = iterations});
  20f110:	48 89 ac 24 e8 00 00 	mov    QWORD PTR [rsp+0xe8],rbp
  20f117:	00 
  20f118:	48 89 9c 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rbx
  20f11f:	00 
                    try pSelf.results.append(
  20f120:	48 8d 7c 24 68       	lea    rdi,[rsp+0x68]
  20f125:	48 8d b4 24 e8 00 00 	lea    rsi,[rsp+0xe8]
  20f12c:	00 
  20f12d:	e8 7e 3c 00 00       	call   212db0 <AlignedArrayList(Result,8)_append>
  20f132:	66 85 c0             	test   ax,ax
  20f135:	8b 4c 24 1c          	mov    ecx,DWORD PTR [rsp+0x1c]
  20f139:	74 18                	je     20f153 <BmPoor.init.setup.tearDown+0x443>
  20f13b:	e9 a4 07 00 00       	jmp    20f8e4 <BmPoor.init.setup.tearDown+0xbd4>
  20f140:	49 89 ee             	mov    r14,rbp
            while (iterations <= pSelf.max_iterations) {
  20f143:	4c 8b 7c 24 48       	mov    r15,QWORD PTR [rsp+0x48]
  20f148:	31 c9                	xor    ecx,ecx
  20f14a:	4c 39 fb             	cmp    rbx,r15
  20f14d:	0f 86 d9 fc ff ff    	jbe    20ee2c <BmPoor.init.setup.tearDown+0x11c>
            if (once) {
  20f153:	f6 c1 01             	test   cl,0x1
  20f156:	48 8d 6c 24 07       	lea    rbp,[rsp+0x7]
  20f15b:	49 89 ef             	mov    r15,rbp
  20f15e:	4c 89 f5             	mov    rbp,r14
  20f161:	4c 8d 74 24 08       	lea    r14,[rsp+0x8]
  20f166:	0f 84 7a 06 00 00    	je     20f7e6 <BmPoor.init.setup.tearDown+0xad6>
                try leftJustified(22, "name repetitions:{}", pSelf.repetitions);
  20f16c:	48 8b 7c 24 40       	mov    rdi,QWORD PTR [rsp+0x40]
  20f171:	e8 2a 62 00 00       	call   2153a0 <Benchmark_leftJustified>
  20f176:	66 85 c0             	test   ax,ax
  20f179:	0f 85 65 07 00 00    	jne    20f8e4 <BmPoor.init.setup.tearDown+0xbd4>
                try rightJustified(14, "{}", "iterations");
  20f17f:	e8 bc 64 00 00       	call   215640 <Benchmark_rightJustified>
  20f184:	66 85 c0             	test   ax,ax
  20f187:	0f 85 57 07 00 00    	jne    20f8e4 <BmPoor.init.setup.tearDown+0xbd4>
        var buffer: [40]u8 = undefined;
  20f18d:	c5 fe 6f 05 ba 6d ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffff6dba]        # 205f4f <__unnamed_7>
  20f194:	ff 
  20f195:	c5 fe 7f 84 24 90 00 	vmovdqu YMMWORD PTR [rsp+0x90],ymm0
  20f19c:	00 00 
  20f19e:	48 8b 05 ca 6d ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffff6dca]        # 205f6f <__unnamed_7+0x20>
  20f1a5:	48 89 84 24 b0 00 00 	mov    QWORD PTR [rsp+0xb0],rax
  20f1ac:	00 
  20f1ad:	c7 84 24 90 00 00 00 	mov    DWORD PTR [rsp+0x90],0x656d6974
  20f1b4:	74 69 6d 65 
  20f1b8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  20f1bf:	00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20f1c0:	b0 01                	mov    al,0x1
  20f1c2:	86 05 48 1e 04 00    	xchg   BYTE PTR [rip+0x41e48],al        # 251010 <stderr_mutex>
  20f1c8:	84 c0                	test   al,al
  20f1ca:	75 f4                	jne    20f1c0 <BmPoor.init.setup.tearDown+0x4b0>
    if (stderr_stream) |st| {
  20f1cc:	48 8b 3d 35 1e 04 00 	mov    rdi,QWORD PTR [rip+0x41e35]        # 251008 <stderr_stream>
  20f1d3:	48 85 ff             	test   rdi,rdi
  20f1d6:	74 18                	je     20f1f0 <BmPoor.init.setup.tearDown+0x4e0>
  20f1d8:	48 8b 0d 61 ce 03 00 	mov    rcx,QWORD PTR [rip+0x3ce61]        # 24c040 <stderr_file_out_stream+0x8>
  20f1df:	eb 4c                	jmp    20f22d <BmPoor.init.setup.tearDown+0x51d>
  20f1e1:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20f1e8:	0f 1f 84 00 00 00 00 
  20f1ef:	00 
        stderr_file = try io.getStdErr();
  20f1f0:	c7 05 36 ce 03 00 02 	mov    DWORD PTR [rip+0x3ce36],0x2        # 24c030 <stderr_file>
  20f1f7:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20f1fa:	48 8d 05 2f ce 03 00 	lea    rax,[rip+0x3ce2f]        # 24c030 <stderr_file>
  20f201:	48 89 05 30 ce 03 00 	mov    QWORD PTR [rip+0x3ce30],rax        # 24c038 <stderr_file_out_stream>
  20f208:	48 8d 05 91 fc 00 00 	lea    rax,[rip+0xfc91]        # 21eea0 <FileOutStream_writeFn>
  20f20f:	48 89 05 2a ce 03 00 	mov    QWORD PTR [rip+0x3ce2a],rax        # 24c040 <stderr_file_out_stream+0x8>
  20f216:	48 8d 0d 23 ce 03 00 	lea    rcx,[rip+0x3ce23]        # 24c040 <stderr_file_out_stream+0x8>
  20f21d:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20f220:	48 89 15 e1 1d 04 00 	mov    QWORD PTR [rip+0x41de1],rdx        # 251008 <stderr_stream>
  20f227:	48 89 c1             	mov    rcx,rax
  20f22a:	48 89 d7             	mov    rdi,rdx
  20f22d:	c6 44 24 07 20       	mov    BYTE PTR [rsp+0x7],0x20
    return output(context, (*[1]u8)(&c)[0..]);
  20f232:	4c 89 7c 24 08       	mov    QWORD PTR [rsp+0x8],r15
  20f237:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  20f23e:	00 00 
  20f240:	4c 89 f6             	mov    rsi,r14
  20f243:	c5 f8 77             	vzeroupper 
  20f246:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20f248:	31 c0                	xor    eax,eax
  20f24a:	86 05 c0 1d 04 00    	xchg   BYTE PTR [rip+0x41dc0],al        # 251010 <stderr_mutex>
  20f250:	3c 01                	cmp    al,0x1
    if (!ok) {
  20f252:	0f 85 9e 06 00 00    	jne    20f8f6 <BmPoor.init.setup.tearDown+0xbe6>
  20f258:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  20f25f:	00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20f260:	b0 01                	mov    al,0x1
  20f262:	86 05 a8 1d 04 00    	xchg   BYTE PTR [rip+0x41da8],al        # 251010 <stderr_mutex>
  20f268:	84 c0                	test   al,al
  20f26a:	75 f4                	jne    20f260 <BmPoor.init.setup.tearDown+0x550>
    if (stderr_stream) |st| {
  20f26c:	48 8b 3d 95 1d 04 00 	mov    rdi,QWORD PTR [rip+0x41d95]        # 251008 <stderr_stream>
  20f273:	48 85 ff             	test   rdi,rdi
  20f276:	74 18                	je     20f290 <BmPoor.init.setup.tearDown+0x580>
  20f278:	48 8b 0d c1 cd 03 00 	mov    rcx,QWORD PTR [rip+0x3cdc1]        # 24c040 <stderr_file_out_stream+0x8>
  20f27f:	eb 4c                	jmp    20f2cd <BmPoor.init.setup.tearDown+0x5bd>
  20f281:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20f288:	0f 1f 84 00 00 00 00 
  20f28f:	00 
        stderr_file = try io.getStdErr();
  20f290:	c7 05 96 cd 03 00 02 	mov    DWORD PTR [rip+0x3cd96],0x2        # 24c030 <stderr_file>
  20f297:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20f29a:	48 8d 05 8f cd 03 00 	lea    rax,[rip+0x3cd8f]        # 24c030 <stderr_file>
  20f2a1:	48 89 05 90 cd 03 00 	mov    QWORD PTR [rip+0x3cd90],rax        # 24c038 <stderr_file_out_stream>
  20f2a8:	48 8d 05 f1 fb 00 00 	lea    rax,[rip+0xfbf1]        # 21eea0 <FileOutStream_writeFn>
  20f2af:	48 89 05 8a cd 03 00 	mov    QWORD PTR [rip+0x3cd8a],rax        # 24c040 <stderr_file_out_stream+0x8>
  20f2b6:	48 8d 0d 83 cd 03 00 	lea    rcx,[rip+0x3cd83]        # 24c040 <stderr_file_out_stream+0x8>
  20f2bd:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20f2c0:	48 89 15 41 1d 04 00 	mov    QWORD PTR [rip+0x41d41],rdx        # 251008 <stderr_stream>
  20f2c7:	48 89 c1             	mov    rcx,rax
  20f2ca:	48 89 d7             	mov    rdi,rdx
  20f2cd:	c6 44 24 07 20       	mov    BYTE PTR [rsp+0x7],0x20
  20f2d2:	4c 89 7c 24 08       	mov    QWORD PTR [rsp+0x8],r15
  20f2d7:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  20f2de:	00 00 
  20f2e0:	4c 89 f6             	mov    rsi,r14
  20f2e3:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20f2e5:	31 c0                	xor    eax,eax
  20f2e7:	86 05 23 1d 04 00    	xchg   BYTE PTR [rip+0x41d23],al        # 251010 <stderr_mutex>
  20f2ed:	3c 01                	cmp    al,0x1
    if (!ok) {
  20f2ef:	0f 85 01 06 00 00    	jne    20f8f6 <BmPoor.init.setup.tearDown+0xbe6>
  20f2f5:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20f2fc:	00 00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20f300:	b0 01                	mov    al,0x1
  20f302:	86 05 08 1d 04 00    	xchg   BYTE PTR [rip+0x41d08],al        # 251010 <stderr_mutex>
  20f308:	84 c0                	test   al,al
  20f30a:	75 f4                	jne    20f300 <BmPoor.init.setup.tearDown+0x5f0>
    if (stderr_stream) |st| {
  20f30c:	48 8b 3d f5 1c 04 00 	mov    rdi,QWORD PTR [rip+0x41cf5]        # 251008 <stderr_stream>
  20f313:	48 85 ff             	test   rdi,rdi
  20f316:	74 18                	je     20f330 <BmPoor.init.setup.tearDown+0x620>
  20f318:	48 8b 0d 21 cd 03 00 	mov    rcx,QWORD PTR [rip+0x3cd21]        # 24c040 <stderr_file_out_stream+0x8>
  20f31f:	eb 4c                	jmp    20f36d <BmPoor.init.setup.tearDown+0x65d>
  20f321:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20f328:	0f 1f 84 00 00 00 00 
  20f32f:	00 
        stderr_file = try io.getStdErr();
  20f330:	c7 05 f6 cc 03 00 02 	mov    DWORD PTR [rip+0x3ccf6],0x2        # 24c030 <stderr_file>
  20f337:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20f33a:	48 8d 05 ef cc 03 00 	lea    rax,[rip+0x3ccef]        # 24c030 <stderr_file>
  20f341:	48 89 05 f0 cc 03 00 	mov    QWORD PTR [rip+0x3ccf0],rax        # 24c038 <stderr_file_out_stream>
  20f348:	48 8d 05 51 fb 00 00 	lea    rax,[rip+0xfb51]        # 21eea0 <FileOutStream_writeFn>
  20f34f:	48 89 05 ea cc 03 00 	mov    QWORD PTR [rip+0x3ccea],rax        # 24c040 <stderr_file_out_stream+0x8>
  20f356:	48 8d 0d e3 cc 03 00 	lea    rcx,[rip+0x3cce3]        # 24c040 <stderr_file_out_stream+0x8>
  20f35d:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20f360:	48 89 15 a1 1c 04 00 	mov    QWORD PTR [rip+0x41ca1],rdx        # 251008 <stderr_stream>
  20f367:	48 89 c1             	mov    rcx,rax
  20f36a:	48 89 d7             	mov    rdi,rdx
  20f36d:	c6 44 24 07 20       	mov    BYTE PTR [rsp+0x7],0x20
  20f372:	4c 89 7c 24 08       	mov    QWORD PTR [rsp+0x8],r15
  20f377:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  20f37e:	00 00 
  20f380:	4c 89 f6             	mov    rsi,r14
  20f383:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20f385:	31 c0                	xor    eax,eax
  20f387:	86 05 83 1c 04 00    	xchg   BYTE PTR [rip+0x41c83],al        # 251010 <stderr_mutex>
  20f38d:	3c 01                	cmp    al,0x1
    if (!ok) {
  20f38f:	0f 85 61 05 00 00    	jne    20f8f6 <BmPoor.init.setup.tearDown+0xbe6>
  20f395:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20f39c:	00 00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20f3a0:	b0 01                	mov    al,0x1
  20f3a2:	86 05 68 1c 04 00    	xchg   BYTE PTR [rip+0x41c68],al        # 251010 <stderr_mutex>
  20f3a8:	84 c0                	test   al,al
  20f3aa:	75 f4                	jne    20f3a0 <BmPoor.init.setup.tearDown+0x690>
    if (stderr_stream) |st| {
  20f3ac:	48 8b 3d 55 1c 04 00 	mov    rdi,QWORD PTR [rip+0x41c55]        # 251008 <stderr_stream>
  20f3b3:	48 85 ff             	test   rdi,rdi
  20f3b6:	74 18                	je     20f3d0 <BmPoor.init.setup.tearDown+0x6c0>
  20f3b8:	48 8b 0d 81 cc 03 00 	mov    rcx,QWORD PTR [rip+0x3cc81]        # 24c040 <stderr_file_out_stream+0x8>
  20f3bf:	eb 4c                	jmp    20f40d <BmPoor.init.setup.tearDown+0x6fd>
  20f3c1:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20f3c8:	0f 1f 84 00 00 00 00 
  20f3cf:	00 
        stderr_file = try io.getStdErr();
  20f3d0:	c7 05 56 cc 03 00 02 	mov    DWORD PTR [rip+0x3cc56],0x2        # 24c030 <stderr_file>
  20f3d7:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20f3da:	48 8d 05 4f cc 03 00 	lea    rax,[rip+0x3cc4f]        # 24c030 <stderr_file>
  20f3e1:	48 89 05 50 cc 03 00 	mov    QWORD PTR [rip+0x3cc50],rax        # 24c038 <stderr_file_out_stream>
  20f3e8:	48 8d 05 b1 fa 00 00 	lea    rax,[rip+0xfab1]        # 21eea0 <FileOutStream_writeFn>
  20f3ef:	48 89 05 4a cc 03 00 	mov    QWORD PTR [rip+0x3cc4a],rax        # 24c040 <stderr_file_out_stream+0x8>
  20f3f6:	48 8d 0d 43 cc 03 00 	lea    rcx,[rip+0x3cc43]        # 24c040 <stderr_file_out_stream+0x8>
  20f3fd:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20f400:	48 89 15 01 1c 04 00 	mov    QWORD PTR [rip+0x41c01],rdx        # 251008 <stderr_stream>
  20f407:	48 89 c1             	mov    rcx,rax
  20f40a:	48 89 d7             	mov    rdi,rdx
  20f40d:	c6 44 24 07 20       	mov    BYTE PTR [rsp+0x7],0x20
  20f412:	4c 89 7c 24 08       	mov    QWORD PTR [rsp+0x8],r15
  20f417:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  20f41e:	00 00 
  20f420:	4c 89 f6             	mov    rsi,r14
  20f423:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20f425:	31 c0                	xor    eax,eax
  20f427:	86 05 e3 1b 04 00    	xchg   BYTE PTR [rip+0x41be3],al        # 251010 <stderr_mutex>
  20f42d:	3c 01                	cmp    al,0x1
    if (!ok) {
  20f42f:	0f 85 c1 04 00 00    	jne    20f8f6 <BmPoor.init.setup.tearDown+0xbe6>
  20f435:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20f43c:	00 00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20f440:	b0 01                	mov    al,0x1
  20f442:	86 05 c8 1b 04 00    	xchg   BYTE PTR [rip+0x41bc8],al        # 251010 <stderr_mutex>
  20f448:	84 c0                	test   al,al
  20f44a:	75 f4                	jne    20f440 <BmPoor.init.setup.tearDown+0x730>
    if (stderr_stream) |st| {
  20f44c:	48 8b 3d b5 1b 04 00 	mov    rdi,QWORD PTR [rip+0x41bb5]        # 251008 <stderr_stream>
  20f453:	48 85 ff             	test   rdi,rdi
  20f456:	74 18                	je     20f470 <BmPoor.init.setup.tearDown+0x760>
  20f458:	48 8b 0d e1 cb 03 00 	mov    rcx,QWORD PTR [rip+0x3cbe1]        # 24c040 <stderr_file_out_stream+0x8>
  20f45f:	eb 4c                	jmp    20f4ad <BmPoor.init.setup.tearDown+0x79d>
  20f461:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20f468:	0f 1f 84 00 00 00 00 
  20f46f:	00 
        stderr_file = try io.getStdErr();
  20f470:	c7 05 b6 cb 03 00 02 	mov    DWORD PTR [rip+0x3cbb6],0x2        # 24c030 <stderr_file>
  20f477:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20f47a:	48 8d 05 af cb 03 00 	lea    rax,[rip+0x3cbaf]        # 24c030 <stderr_file>
  20f481:	48 89 05 b0 cb 03 00 	mov    QWORD PTR [rip+0x3cbb0],rax        # 24c038 <stderr_file_out_stream>
  20f488:	48 8d 05 11 fa 00 00 	lea    rax,[rip+0xfa11]        # 21eea0 <FileOutStream_writeFn>
  20f48f:	48 89 05 aa cb 03 00 	mov    QWORD PTR [rip+0x3cbaa],rax        # 24c040 <stderr_file_out_stream+0x8>
  20f496:	48 8d 0d a3 cb 03 00 	lea    rcx,[rip+0x3cba3]        # 24c040 <stderr_file_out_stream+0x8>
  20f49d:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20f4a0:	48 89 15 61 1b 04 00 	mov    QWORD PTR [rip+0x41b61],rdx        # 251008 <stderr_stream>
  20f4a7:	48 89 c1             	mov    rcx,rax
  20f4aa:	48 89 d7             	mov    rdi,rdx
  20f4ad:	c6 44 24 07 20       	mov    BYTE PTR [rsp+0x7],0x20
  20f4b2:	4c 89 7c 24 08       	mov    QWORD PTR [rsp+0x8],r15
  20f4b7:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  20f4be:	00 00 
  20f4c0:	4c 89 f6             	mov    rsi,r14
  20f4c3:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20f4c5:	31 c0                	xor    eax,eax
  20f4c7:	86 05 43 1b 04 00    	xchg   BYTE PTR [rip+0x41b43],al        # 251010 <stderr_mutex>
  20f4cd:	3c 01                	cmp    al,0x1
    if (!ok) {
  20f4cf:	0f 85 21 04 00 00    	jne    20f8f6 <BmPoor.init.setup.tearDown+0xbe6>
  20f4d5:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20f4dc:	00 00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20f4e0:	b0 01                	mov    al,0x1
  20f4e2:	86 05 28 1b 04 00    	xchg   BYTE PTR [rip+0x41b28],al        # 251010 <stderr_mutex>
  20f4e8:	84 c0                	test   al,al
  20f4ea:	75 f4                	jne    20f4e0 <BmPoor.init.setup.tearDown+0x7d0>
    if (stderr_stream) |st| {
  20f4ec:	48 8b 3d 15 1b 04 00 	mov    rdi,QWORD PTR [rip+0x41b15]        # 251008 <stderr_stream>
  20f4f3:	48 85 ff             	test   rdi,rdi
  20f4f6:	74 18                	je     20f510 <BmPoor.init.setup.tearDown+0x800>
  20f4f8:	48 8b 0d 41 cb 03 00 	mov    rcx,QWORD PTR [rip+0x3cb41]        # 24c040 <stderr_file_out_stream+0x8>
  20f4ff:	eb 4c                	jmp    20f54d <BmPoor.init.setup.tearDown+0x83d>
  20f501:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20f508:	0f 1f 84 00 00 00 00 
  20f50f:	00 
        stderr_file = try io.getStdErr();
  20f510:	c7 05 16 cb 03 00 02 	mov    DWORD PTR [rip+0x3cb16],0x2        # 24c030 <stderr_file>
  20f517:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20f51a:	48 8d 05 0f cb 03 00 	lea    rax,[rip+0x3cb0f]        # 24c030 <stderr_file>
  20f521:	48 89 05 10 cb 03 00 	mov    QWORD PTR [rip+0x3cb10],rax        # 24c038 <stderr_file_out_stream>
  20f528:	48 8d 05 71 f9 00 00 	lea    rax,[rip+0xf971]        # 21eea0 <FileOutStream_writeFn>
  20f52f:	48 89 05 0a cb 03 00 	mov    QWORD PTR [rip+0x3cb0a],rax        # 24c040 <stderr_file_out_stream+0x8>
  20f536:	48 8d 0d 03 cb 03 00 	lea    rcx,[rip+0x3cb03]        # 24c040 <stderr_file_out_stream+0x8>
  20f53d:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20f540:	48 89 15 c1 1a 04 00 	mov    QWORD PTR [rip+0x41ac1],rdx        # 251008 <stderr_stream>
  20f547:	48 89 c1             	mov    rcx,rax
  20f54a:	48 89 d7             	mov    rdi,rdx
  20f54d:	c6 44 24 07 20       	mov    BYTE PTR [rsp+0x7],0x20
  20f552:	4c 89 7c 24 08       	mov    QWORD PTR [rsp+0x8],r15
  20f557:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  20f55e:	00 00 
  20f560:	4c 89 f6             	mov    rsi,r14
  20f563:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20f565:	31 c0                	xor    eax,eax
  20f567:	86 05 a3 1a 04 00    	xchg   BYTE PTR [rip+0x41aa3],al        # 251010 <stderr_mutex>
  20f56d:	3c 01                	cmp    al,0x1
    if (!ok) {
  20f56f:	0f 85 81 03 00 00    	jne    20f8f6 <BmPoor.init.setup.tearDown+0xbe6>
  20f575:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20f57c:	00 00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20f580:	b0 01                	mov    al,0x1
  20f582:	86 05 88 1a 04 00    	xchg   BYTE PTR [rip+0x41a88],al        # 251010 <stderr_mutex>
  20f588:	84 c0                	test   al,al
  20f58a:	75 f4                	jne    20f580 <BmPoor.init.setup.tearDown+0x870>
    if (stderr_stream) |st| {
  20f58c:	48 8b 3d 75 1a 04 00 	mov    rdi,QWORD PTR [rip+0x41a75]        # 251008 <stderr_stream>
  20f593:	48 85 ff             	test   rdi,rdi
  20f596:	74 18                	je     20f5b0 <BmPoor.init.setup.tearDown+0x8a0>
  20f598:	48 8b 0d a1 ca 03 00 	mov    rcx,QWORD PTR [rip+0x3caa1]        # 24c040 <stderr_file_out_stream+0x8>
  20f59f:	eb 4c                	jmp    20f5ed <BmPoor.init.setup.tearDown+0x8dd>
  20f5a1:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20f5a8:	0f 1f 84 00 00 00 00 
  20f5af:	00 
        stderr_file = try io.getStdErr();
  20f5b0:	c7 05 76 ca 03 00 02 	mov    DWORD PTR [rip+0x3ca76],0x2        # 24c030 <stderr_file>
  20f5b7:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20f5ba:	48 8d 05 6f ca 03 00 	lea    rax,[rip+0x3ca6f]        # 24c030 <stderr_file>
  20f5c1:	48 89 05 70 ca 03 00 	mov    QWORD PTR [rip+0x3ca70],rax        # 24c038 <stderr_file_out_stream>
  20f5c8:	48 8d 05 d1 f8 00 00 	lea    rax,[rip+0xf8d1]        # 21eea0 <FileOutStream_writeFn>
  20f5cf:	48 89 05 6a ca 03 00 	mov    QWORD PTR [rip+0x3ca6a],rax        # 24c040 <stderr_file_out_stream+0x8>
  20f5d6:	48 8d 0d 63 ca 03 00 	lea    rcx,[rip+0x3ca63]        # 24c040 <stderr_file_out_stream+0x8>
  20f5dd:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20f5e0:	48 89 15 21 1a 04 00 	mov    QWORD PTR [rip+0x41a21],rdx        # 251008 <stderr_stream>
  20f5e7:	48 89 c1             	mov    rcx,rax
  20f5ea:	48 89 d7             	mov    rdi,rdx
  20f5ed:	c6 44 24 07 20       	mov    BYTE PTR [rsp+0x7],0x20
  20f5f2:	4c 89 7c 24 08       	mov    QWORD PTR [rsp+0x8],r15
  20f5f7:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  20f5fe:	00 00 
  20f600:	4c 89 f6             	mov    rsi,r14
  20f603:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20f605:	31 c0                	xor    eax,eax
  20f607:	86 05 03 1a 04 00    	xchg   BYTE PTR [rip+0x41a03],al        # 251010 <stderr_mutex>
  20f60d:	3c 01                	cmp    al,0x1
    if (!ok) {
  20f60f:	0f 85 e1 02 00 00    	jne    20f8f6 <BmPoor.init.setup.tearDown+0xbe6>
  20f615:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20f61c:	00 00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20f620:	b0 01                	mov    al,0x1
  20f622:	86 05 e8 19 04 00    	xchg   BYTE PTR [rip+0x419e8],al        # 251010 <stderr_mutex>
  20f628:	84 c0                	test   al,al
  20f62a:	75 f4                	jne    20f620 <BmPoor.init.setup.tearDown+0x910>
    if (stderr_stream) |st| {
  20f62c:	48 8b 3d d5 19 04 00 	mov    rdi,QWORD PTR [rip+0x419d5]        # 251008 <stderr_stream>
  20f633:	48 85 ff             	test   rdi,rdi
  20f636:	74 18                	je     20f650 <BmPoor.init.setup.tearDown+0x940>
  20f638:	48 8b 0d 01 ca 03 00 	mov    rcx,QWORD PTR [rip+0x3ca01]        # 24c040 <stderr_file_out_stream+0x8>
  20f63f:	eb 4c                	jmp    20f68d <BmPoor.init.setup.tearDown+0x97d>
  20f641:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20f648:	0f 1f 84 00 00 00 00 
  20f64f:	00 
        stderr_file = try io.getStdErr();
  20f650:	c7 05 d6 c9 03 00 02 	mov    DWORD PTR [rip+0x3c9d6],0x2        # 24c030 <stderr_file>
  20f657:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20f65a:	48 8d 05 cf c9 03 00 	lea    rax,[rip+0x3c9cf]        # 24c030 <stderr_file>
  20f661:	48 89 05 d0 c9 03 00 	mov    QWORD PTR [rip+0x3c9d0],rax        # 24c038 <stderr_file_out_stream>
  20f668:	48 8d 05 31 f8 00 00 	lea    rax,[rip+0xf831]        # 21eea0 <FileOutStream_writeFn>
  20f66f:	48 89 05 ca c9 03 00 	mov    QWORD PTR [rip+0x3c9ca],rax        # 24c040 <stderr_file_out_stream+0x8>
  20f676:	48 8d 0d c3 c9 03 00 	lea    rcx,[rip+0x3c9c3]        # 24c040 <stderr_file_out_stream+0x8>
  20f67d:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20f680:	48 89 15 81 19 04 00 	mov    QWORD PTR [rip+0x41981],rdx        # 251008 <stderr_stream>
  20f687:	48 89 c1             	mov    rcx,rax
  20f68a:	48 89 d7             	mov    rdi,rdx
  20f68d:	c6 44 24 07 20       	mov    BYTE PTR [rsp+0x7],0x20
  20f692:	4c 89 7c 24 08       	mov    QWORD PTR [rsp+0x8],r15
  20f697:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  20f69e:	00 00 
  20f6a0:	4c 89 f6             	mov    rsi,r14
  20f6a3:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20f6a5:	31 c0                	xor    eax,eax
  20f6a7:	86 05 63 19 04 00    	xchg   BYTE PTR [rip+0x41963],al        # 251010 <stderr_mutex>
  20f6ad:	3c 01                	cmp    al,0x1
    if (!ok) {
  20f6af:	0f 85 41 02 00 00    	jne    20f8f6 <BmPoor.init.setup.tearDown+0xbe6>
  20f6b5:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20f6bc:	00 00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20f6c0:	b0 01                	mov    al,0x1
  20f6c2:	86 05 48 19 04 00    	xchg   BYTE PTR [rip+0x41948],al        # 251010 <stderr_mutex>
  20f6c8:	84 c0                	test   al,al
  20f6ca:	75 f4                	jne    20f6c0 <BmPoor.init.setup.tearDown+0x9b0>
    if (stderr_stream) |st| {
  20f6cc:	48 8b 3d 35 19 04 00 	mov    rdi,QWORD PTR [rip+0x41935]        # 251008 <stderr_stream>
  20f6d3:	48 85 ff             	test   rdi,rdi
  20f6d6:	74 18                	je     20f6f0 <BmPoor.init.setup.tearDown+0x9e0>
  20f6d8:	48 8b 0d 61 c9 03 00 	mov    rcx,QWORD PTR [rip+0x3c961]        # 24c040 <stderr_file_out_stream+0x8>
  20f6df:	eb 4c                	jmp    20f72d <BmPoor.init.setup.tearDown+0xa1d>
  20f6e1:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20f6e8:	0f 1f 84 00 00 00 00 
  20f6ef:	00 
        stderr_file = try io.getStdErr();
  20f6f0:	c7 05 36 c9 03 00 02 	mov    DWORD PTR [rip+0x3c936],0x2        # 24c030 <stderr_file>
  20f6f7:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20f6fa:	48 8d 05 2f c9 03 00 	lea    rax,[rip+0x3c92f]        # 24c030 <stderr_file>
  20f701:	48 89 05 30 c9 03 00 	mov    QWORD PTR [rip+0x3c930],rax        # 24c038 <stderr_file_out_stream>
  20f708:	48 8d 05 91 f7 00 00 	lea    rax,[rip+0xf791]        # 21eea0 <FileOutStream_writeFn>
  20f70f:	48 89 05 2a c9 03 00 	mov    QWORD PTR [rip+0x3c92a],rax        # 24c040 <stderr_file_out_stream+0x8>
  20f716:	48 8d 0d 23 c9 03 00 	lea    rcx,[rip+0x3c923]        # 24c040 <stderr_file_out_stream+0x8>
  20f71d:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20f720:	48 89 15 e1 18 04 00 	mov    QWORD PTR [rip+0x418e1],rdx        # 251008 <stderr_stream>
  20f727:	48 89 c1             	mov    rcx,rax
  20f72a:	48 89 d7             	mov    rdi,rdx
                const casted_value = ([]const u8)(value);
  20f72d:	4c 89 64 24 08       	mov    QWORD PTR [rsp+0x8],r12
  20f732:	48 c7 44 24 10 04 00 	mov    QWORD PTR [rsp+0x10],0x4
  20f739:	00 00 
                return output(context, casted_value);
  20f73b:	4c 89 f6             	mov    rsi,r14
  20f73e:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20f740:	31 c0                	xor    eax,eax
  20f742:	86 05 c8 18 04 00    	xchg   BYTE PTR [rip+0x418c8],al        # 251010 <stderr_mutex>
  20f748:	3c 01                	cmp    al,0x1
    if (!ok) {
  20f74a:	0f 85 a6 01 00 00    	jne    20f8f6 <BmPoor.init.setup.tearDown+0xbe6>
                try rightJustified(18, "{}", "time/operation");
  20f750:	e8 cb 61 00 00       	call   215920 <Benchmark_rightJustified.39>
  20f755:	66 85 c0             	test   ax,ax
  20f758:	0f 85 86 01 00 00    	jne    20f8e4 <BmPoor.init.setup.tearDown+0xbd4>
  20f75e:	66 90                	xchg   ax,ax
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20f760:	b0 01                	mov    al,0x1
  20f762:	86 05 a8 18 04 00    	xchg   BYTE PTR [rip+0x418a8],al        # 251010 <stderr_mutex>
  20f768:	84 c0                	test   al,al
  20f76a:	75 f4                	jne    20f760 <BmPoor.init.setup.tearDown+0xa50>
    if (stderr_stream) |st| {
  20f76c:	48 8b 3d 95 18 04 00 	mov    rdi,QWORD PTR [rip+0x41895]        # 251008 <stderr_stream>
  20f773:	48 85 ff             	test   rdi,rdi
  20f776:	74 18                	je     20f790 <BmPoor.init.setup.tearDown+0xa80>
  20f778:	48 8b 0d c1 c8 03 00 	mov    rcx,QWORD PTR [rip+0x3c8c1]        # 24c040 <stderr_file_out_stream+0x8>
  20f77f:	eb 4c                	jmp    20f7cd <BmPoor.init.setup.tearDown+0xabd>
  20f781:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20f788:	0f 1f 84 00 00 00 00 
  20f78f:	00 
        stderr_file = try io.getStdErr();
  20f790:	c7 05 96 c8 03 00 02 	mov    DWORD PTR [rip+0x3c896],0x2        # 24c030 <stderr_file>
  20f797:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20f79a:	48 8d 05 8f c8 03 00 	lea    rax,[rip+0x3c88f]        # 24c030 <stderr_file>
  20f7a1:	48 89 05 90 c8 03 00 	mov    QWORD PTR [rip+0x3c890],rax        # 24c038 <stderr_file_out_stream>
  20f7a8:	48 8d 05 f1 f6 00 00 	lea    rax,[rip+0xf6f1]        # 21eea0 <FileOutStream_writeFn>
  20f7af:	48 89 05 8a c8 03 00 	mov    QWORD PTR [rip+0x3c88a],rax        # 24c040 <stderr_file_out_stream+0x8>
  20f7b6:	48 8d 0d 83 c8 03 00 	lea    rcx,[rip+0x3c883]        # 24c040 <stderr_file_out_stream+0x8>
  20f7bd:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20f7c0:	48 89 15 41 18 04 00 	mov    QWORD PTR [rip+0x41841],rdx        # 251008 <stderr_stream>
  20f7c7:	48 89 c1             	mov    rcx,rax
  20f7ca:	48 89 d7             	mov    rdi,rdx
        try output(context, fmt[start_index..]);
  20f7cd:	48 8d 35 1c 07 04 00 	lea    rsi,[rip+0x4071c]        # 24fef0 <__unnamed_3>
  20f7d4:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20f7d6:	31 c0                	xor    eax,eax
  20f7d8:	86 05 32 18 04 00    	xchg   BYTE PTR [rip+0x41832],al        # 251010 <stderr_mutex>
  20f7de:	3c 01                	cmp    al,0x1
    if (!ok) {
  20f7e0:	0f 85 10 01 00 00    	jne    20f8f6 <BmPoor.init.setup.tearDown+0xbe6>
            try pSelf.report(pSelf.results.items[pSelf.results.len - 1]); warn("\n");
  20f7e6:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  20f7eb:	48 8b 4c 24 78       	mov    rcx,QWORD PTR [rsp+0x78]
  20f7f0:	48 c1 e1 04          	shl    rcx,0x4
  20f7f4:	48 8d 34 08          	lea    rsi,[rax+rcx*1]
  20f7f8:	48 83 c6 f0          	add    rsi,0xfffffffffffffff0
  20f7fc:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  20f801:	e8 1a 37 00 00       	call   212f20 <Benchmark_report>
  20f806:	66 85 c0             	test   ax,ax
  20f809:	0f 85 d5 00 00 00    	jne    20f8e4 <BmPoor.init.setup.tearDown+0xbd4>
  20f80f:	48 83 c5 01          	add    rbp,0x1
  20f813:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20f81a:	84 00 00 00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20f820:	b0 01                	mov    al,0x1
  20f822:	86 05 e8 17 04 00    	xchg   BYTE PTR [rip+0x417e8],al        # 251010 <stderr_mutex>
  20f828:	84 c0                	test   al,al
  20f82a:	75 f4                	jne    20f820 <BmPoor.init.setup.tearDown+0xb10>
    if (stderr_stream) |st| {
  20f82c:	48 8b 3d d5 17 04 00 	mov    rdi,QWORD PTR [rip+0x417d5]        # 251008 <stderr_stream>
  20f833:	48 85 ff             	test   rdi,rdi
  20f836:	74 18                	je     20f850 <BmPoor.init.setup.tearDown+0xb40>
  20f838:	48 8b 0d 01 c8 03 00 	mov    rcx,QWORD PTR [rip+0x3c801]        # 24c040 <stderr_file_out_stream+0x8>
  20f83f:	eb 4c                	jmp    20f88d <BmPoor.init.setup.tearDown+0xb7d>
  20f841:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20f848:	0f 1f 84 00 00 00 00 
  20f84f:	00 
        stderr_file = try io.getStdErr();
  20f850:	c7 05 d6 c7 03 00 02 	mov    DWORD PTR [rip+0x3c7d6],0x2        # 24c030 <stderr_file>
  20f857:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20f85a:	48 8d 05 cf c7 03 00 	lea    rax,[rip+0x3c7cf]        # 24c030 <stderr_file>
  20f861:	48 89 05 d0 c7 03 00 	mov    QWORD PTR [rip+0x3c7d0],rax        # 24c038 <stderr_file_out_stream>
  20f868:	48 8d 05 31 f6 00 00 	lea    rax,[rip+0xf631]        # 21eea0 <FileOutStream_writeFn>
  20f86f:	48 89 05 ca c7 03 00 	mov    QWORD PTR [rip+0x3c7ca],rax        # 24c040 <stderr_file_out_stream+0x8>
  20f876:	48 8d 0d c3 c7 03 00 	lea    rcx,[rip+0x3c7c3]        # 24c040 <stderr_file_out_stream+0x8>
  20f87d:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20f880:	48 89 15 81 17 04 00 	mov    QWORD PTR [rip+0x41781],rdx        # 251008 <stderr_stream>
  20f887:	48 89 c1             	mov    rcx,rax
  20f88a:	48 89 d7             	mov    rdi,rdx
  20f88d:	48 8d 35 5c 06 04 00 	lea    rsi,[rip+0x4065c]        # 24fef0 <__unnamed_3>
  20f894:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20f896:	31 c0                	xor    eax,eax
  20f898:	86 05 72 17 04 00    	xchg   BYTE PTR [rip+0x41772],al        # 251010 <stderr_mutex>
  20f89e:	3c 01                	cmp    al,0x1
    if (!ok) {
  20f8a0:	75 54                	jne    20f8f6 <BmPoor.init.setup.tearDown+0xbe6>
        while (rep < pSelf.repetitions) : (rep += 1) {
  20f8a2:	48 3b 6c 24 40       	cmp    rbp,QWORD PTR [rsp+0x40]
  20f8a7:	0f 82 93 f8 ff ff    	jb     20f140 <BmPoor.init.setup.tearDown+0x430>
  20f8ad:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
        try pSelf.reportStats(pSelf.results);
  20f8b2:	48 8d 74 24 68       	lea    rsi,[rsp+0x68]
  20f8b7:	e8 44 63 00 00       	call   215c00 <Benchmark_reportStats>
  20f8bc:	66 85 c0             	test   ax,ax
  20f8bf:	75 23                	jne    20f8e4 <BmPoor.init.setup.tearDown+0xbd4>
    var bmSelf = try bm.run(BmSelf);
    assert(bmSelf.init_count == 1);
    assert(bmSelf.setup_count == 3);
  20f8c1:	48 83 fd 03          	cmp    rbp,0x3
  20f8c5:	75 2f                	jne    20f8f6 <BmPoor.init.setup.tearDown+0xbe6>
    assert(bmSelf.benchmark_count > 1000000);
  20f8c7:	49 81 fd 40 42 0f 00 	cmp    r13,0xf4240
  20f8ce:	76 26                	jbe    20f8f6 <BmPoor.init.setup.tearDown+0xbe6>
  20f8d0:	31 c0                	xor    eax,eax
  20f8d2:	eb 10                	jmp    20f8e4 <BmPoor.init.setup.tearDown+0xbd4>
                switch (errno) {
  20f8d4:	48 83 f9 16          	cmp    rcx,0x16
  20f8d8:	75 06                	jne    20f8e0 <BmPoor.init.setup.tearDown+0xbd0>
  20f8da:	66 b8 02 00          	mov    ax,0x2
  20f8de:	eb 04                	jmp    20f8e4 <BmPoor.init.setup.tearDown+0xbd4>
  20f8e0:	66 b8 03 00          	mov    ax,0x3
    var bmSelf = try bm.run(BmSelf);
  20f8e4:	48 81 c4 f8 00 00 00 	add    rsp,0xf8
  20f8eb:	5b                   	pop    rbx
  20f8ec:	41 5c                	pop    r12
  20f8ee:	41 5d                	pop    r13
  20f8f0:	41 5e                	pop    r14
  20f8f2:	41 5f                	pop    r15
  20f8f4:	5d                   	pop    rbp
  20f8f5:	c3                   	ret    
            @panic("assertion failure");
  20f8f6:	48 8d 3d 93 04 04 00 	lea    rdi,[rip+0x40493]        # 24fd90 <__unnamed_2>
  20f8fd:	e8 1e 2e 00 00       	call   212720 <panic>
  20f902:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20f909:	1f 84 00 00 00 00 00 

000000000020f910 <BmPoor.add>:
    assert(bmSelf.tearDown_count == 3);
}

/// The inner loop is optimized away.
test "BmPoor.add" {
  20f910:	55                   	push   rbp
  20f911:	41 57                	push   r15
  20f913:	41 56                	push   r14
  20f915:	41 55                	push   r13
  20f917:	41 54                	push   r12
  20f919:	53                   	push   rbx
  20f91a:	48 81 ec 08 01 00 00 	sub    rsp,0x108
  20f921:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20f928:	0f 1f 84 00 00 00 00 
  20f92f:	00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20f930:	b0 01                	mov    al,0x1
  20f932:	86 05 d8 16 04 00    	xchg   BYTE PTR [rip+0x416d8],al        # 251010 <stderr_mutex>
  20f938:	84 c0                	test   al,al
  20f93a:	75 f4                	jne    20f930 <BmPoor.add+0x20>
    if (stderr_stream) |st| {
  20f93c:	48 8b 3d c5 16 04 00 	mov    rdi,QWORD PTR [rip+0x416c5]        # 251008 <stderr_stream>
  20f943:	48 85 ff             	test   rdi,rdi
  20f946:	74 09                	je     20f951 <BmPoor.add+0x41>
  20f948:	48 8b 05 f1 c6 03 00 	mov    rax,QWORD PTR [rip+0x3c6f1]        # 24c040 <stderr_file_out_stream+0x8>
  20f94f:	eb 34                	jmp    20f985 <BmPoor.add+0x75>
        stderr_file = try io.getStdErr();
  20f951:	48 8d 05 d8 c6 03 00 	lea    rax,[rip+0x3c6d8]        # 24c030 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20f958:	48 89 05 d9 c6 03 00 	mov    QWORD PTR [rip+0x3c6d9],rax        # 24c038 <stderr_file_out_stream>
  20f95f:	48 8d 05 3a f5 00 00 	lea    rax,[rip+0xf53a]        # 21eea0 <FileOutStream_writeFn>
  20f966:	48 89 05 d3 c6 03 00 	mov    QWORD PTR [rip+0x3c6d3],rax        # 24c040 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  20f96d:	c7 05 b9 c6 03 00 02 	mov    DWORD PTR [rip+0x3c6b9],0x2        # 24c030 <stderr_file>
  20f974:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20f977:	48 8d 3d c2 c6 03 00 	lea    rdi,[rip+0x3c6c2]        # 24c040 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  20f97e:	48 89 3d 83 16 04 00 	mov    QWORD PTR [rip+0x41683],rdi        # 251008 <stderr_stream>
  20f985:	48 8d 35 64 05 04 00 	lea    rsi,[rip+0x40564]        # 24fef0 <__unnamed_3>
  20f98c:	ff d0                	call   rax
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20f98e:	31 c0                	xor    eax,eax
  20f990:	86 05 7a 16 04 00    	xchg   BYTE PTR [rip+0x4167a],al        # 251010 <stderr_mutex>
  20f996:	3c 01                	cmp    al,0x1
    if (!ok) {
  20f998:	0f 85 98 0c 00 00    	jne    210636 <BmPoor.add+0xd26>

    // Since this is a test print a \n before we run
    warn("\n");

    // Create an instance of Benchmark, set 10 iterations and run
    var bm = Benchmark.init("BmAdd", std.debug.global_allocator);
  20f99e:	c5 f8 10 05 aa 03 04 	vmovups xmm0,XMMWORD PTR [rip+0x403aa]        # 24fd50 <__unnamed_14>
  20f9a5:	00 
  20f9a6:	c5 f8 29 44 24 60    	vmovaps XMMWORD PTR [rsp+0x60],xmm0
  20f9ac:	b8 00 65 cd 1d       	mov    eax,0x1dcd6500
  20f9b1:	c4 e1 f9 6e c0       	vmovq  xmm0,rax
  20f9b6:	c5 f9 73 f8 08       	vpslldq xmm0,xmm0,0x8
  20f9bb:	c5 f9 7f 44 24 70    	vmovdqa XMMWORD PTR [rsp+0x70],xmm0
  20f9c1:	48 b8 00 e8 76 48 17 	movabs rax,0x174876e800
  20f9c8:	00 00 00 
  20f9cb:	48 89 84 24 88 00 00 	mov    QWORD PTR [rsp+0x88],rax
  20f9d2:	00 
  20f9d3:	c5 fa 6f 05 35 09 ff 	vmovdqu xmm0,XMMWORD PTR [rip+0xffffffffffff0935]        # 200310 <__unnamed_35>
  20f9da:	ff 
  20f9db:	c5 f9 7f 84 24 90 00 	vmovdqa XMMWORD PTR [rsp+0x90],xmm0
  20f9e2:	00 00 
  20f9e4:	48 8d 05 15 c6 03 00 	lea    rax,[rip+0x3c615]        # 24c000 <global_fixed_allocator>
  20f9eb:	48 89 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rax
  20f9f2:	00 
  20f9f3:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  20f9f7:	c5 fa 7f 84 24 a8 00 	vmovdqu XMMWORD PTR [rsp+0xa8],xmm0
  20f9fe:	00 00 
  20fa00:	48 c7 84 24 b8 00 00 	mov    QWORD PTR [rsp+0xb8],0x0
  20fa07:	00 00 00 00 00 
  20fa0c:	48 89 84 24 c0 00 00 	mov    QWORD PTR [rsp+0xc0],rax
  20fa13:	00 
    bm.repetitions = 10;
  20fa14:	48 c7 84 24 80 00 00 	mov    QWORD PTR [rsp+0x80],0xa
  20fa1b:	00 0a 00 00 00 
  20fa20:	b0 01                	mov    al,0x1
  20fa22:	bb 01 00 00 00       	mov    ebx,0x1
  20fa27:	31 ed                	xor    ebp,ebp
  20fa29:	c5 f8 10 0d df 08 ff 	vmovups xmm1,XMMWORD PTR [rip+0xffffffffffff08df]        # 200310 <__unnamed_35>
  20fa30:	ff 
  20fa31:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
  20fa36:	45 31 ed             	xor    r13d,r13d
  20fa39:	89 44 24 24          	mov    DWORD PTR [rsp+0x24],eax
                var ts: posix.timespec = undefined;
  20fa3d:	c5 f8 29 4c 24 30    	vmovaps XMMWORD PTR [rsp+0x30],xmm1
  20fa43:	b8 e5 00 00 00       	mov    eax,0xe5
  20fa48:	bf 01 00 00 00       	mov    edi,0x1
  20fa4d:	49 89 f7             	mov    r15,rsi
  20fa50:	0f 05                	syscall 
  20fa52:	48 89 c1             	mov    rcx,rax
  20fa55:	48 f7 d9             	neg    rcx
  20fa58:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  20fa5e:	48 0f 46 cd          	cmovbe rcx,rbp
                switch (errno) {
  20fa62:	48 85 c9             	test   rcx,rcx
  20fa65:	0f 85 a3 0b 00 00    	jne    21060e <BmPoor.add+0xcfe>
        const f = @atomicLoad(@typeOf(init_vdso_clock_gettime), &vdso_clock_gettime, builtin.AtomicOrder.Unordered);
  20fa6b:	48 8b 05 a6 c6 03 00 	mov    rax,QWORD PTR [rip+0x3c6a6]        # 24c118 <vdso_clock_gettime>
        if (@ptrToInt(f) != 0) {
  20fa72:	48 85 c0             	test   rax,rax
  20fa75:	4c 89 fd             	mov    rbp,r15
  20fa78:	74 21                	je     20fa9b <BmPoor.add+0x18b>
            const rc = f(clk_id, tp);
  20fa7a:	bf 01 00 00 00       	mov    edi,0x1
  20fa7f:	48 89 ee             	mov    rsi,rbp
  20fa82:	ff d0                	call   rax
            switch (rc) {
  20fa84:	48 83 f8 ea          	cmp    rax,0xffffffffffffffea
  20fa88:	0f 84 42 04 00 00    	je     20fed0 <BmPoor.add+0x5c0>
  20fa8e:	48 85 c0             	test   rax,rax
  20fa91:	c5 f8 10 0d 77 08 ff 	vmovups xmm1,XMMWORD PTR [rip+0xffffffffffff0877]        # 200310 <__unnamed_35>
  20fa98:	ff 
  20fa99:	74 0f                	je     20faaa <BmPoor.add+0x19a>
  20fa9b:	b8 e4 00 00 00       	mov    eax,0xe4
  20faa0:	bf 01 00 00 00       	mov    edi,0x1
  20faa5:	48 89 ee             	mov    rsi,rbp
  20faa8:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  20faaa:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
                if (errno != 0) return std.os.unexpectedErrorPosix(errno);
  20fab0:	0f 83 64 0b 00 00    	jae    21061a <BmPoor.add+0xd0a>
                self.start_time = @intCast(u64, ts.tv_sec) * u64(ns_per_s) + @intCast(u64, ts.tv_nsec);
  20fab6:	48 8b 6c 24 30       	mov    rbp,QWORD PTR [rsp+0x30]
  20fabb:	4c 8b 64 24 38       	mov    r12,QWORD PTR [rsp+0x38]
        var ts: posix.timespec = undefined;
  20fac0:	c5 f8 29 4c 24 30    	vmovaps XMMWORD PTR [rsp+0x30],xmm1
        const f = @atomicLoad(@typeOf(init_vdso_clock_gettime), &vdso_clock_gettime, builtin.AtomicOrder.Unordered);
  20fac6:	48 8b 05 4b c6 03 00 	mov    rax,QWORD PTR [rip+0x3c64b]        # 24c118 <vdso_clock_gettime>
        if (@ptrToInt(f) != 0) {
  20facd:	48 85 c0             	test   rax,rax
  20fad0:	74 21                	je     20faf3 <BmPoor.add+0x1e3>
            const rc = f(clk_id, tp);
  20fad2:	bf 01 00 00 00       	mov    edi,0x1
  20fad7:	4c 89 fe             	mov    rsi,r15
  20fada:	ff d0                	call   rax
            switch (rc) {
  20fadc:	48 83 f8 ea          	cmp    rax,0xffffffffffffffea
  20fae0:	0f 84 03 04 00 00    	je     20fee9 <BmPoor.add+0x5d9>
  20fae6:	48 85 c0             	test   rax,rax
  20fae9:	c5 f8 10 0d 1f 08 ff 	vmovups xmm1,XMMWORD PTR [rip+0xffffffffffff081f]        # 200310 <__unnamed_35>
  20faf0:	ff 
  20faf1:	74 0f                	je     20fb02 <BmPoor.add+0x1f2>
  20faf3:	b8 e4 00 00 00       	mov    eax,0xe4
  20faf8:	bf 01 00 00 00       	mov    edi,0x1
  20fafd:	4c 89 fe             	mov    rsi,r15
  20fb00:	0f 05                	syscall 
  20fb02:	4c 89 6c 24 28       	mov    QWORD PTR [rsp+0x28],r13
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  20fb07:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
  20fb0d:	0f 83 23 0b 00 00    	jae    210636 <BmPoor.add+0xd26>
        return @intCast(u64, ts.tv_sec) * u64(ns_per_s) + @intCast(u64, ts.tv_nsec);
  20fb13:	48 8b 44 24 30       	mov    rax,QWORD PTR [rsp+0x30]
  20fb18:	48 29 e8             	sub    rax,rbp
  20fb1b:	48 8b 4c 24 38       	mov    rcx,QWORD PTR [rsp+0x38]
  20fb20:	4c 29 e1             	sub    rcx,r12
  20fb23:	48 69 c0 00 ca 9a 3b 	imul   rax,rax,0x3b9aca00
        var clock = clockNative() - self.start_time;
  20fb2a:	48 01 c8             	add    rax,rcx
    pub fn init(seed: u64) SplitMix64 {
        return SplitMix64{ .s = seed };
    }

    pub fn next(self: *SplitMix64) u64 {
        self.s +%= 0x9e3779b97f4a7c15;
  20fb2d:	48 b9 15 7c 4a 7f b9 	movabs rcx,0x9e3779b97f4a7c15
  20fb34:	79 37 9e 
  20fb37:	48 8d 0c 08          	lea    rcx,[rax+rcx*1]

        var z = self.s;
        z = (z ^ (z >> 30)) *% 0xbf58476d1ce4e5b9;
  20fb3b:	48 89 ca             	mov    rdx,rcx
  20fb3e:	48 c1 ea 1e          	shr    rdx,0x1e
  20fb42:	48 31 ca             	xor    rdx,rcx
  20fb45:	48 b9 b9 e5 e4 1c 6d 	movabs rcx,0xbf58476d1ce4e5b9
  20fb4c:	47 58 bf 
  20fb4f:	48 89 ce             	mov    rsi,rcx
  20fb52:	48 0f af d6          	imul   rdx,rsi
        z = (z ^ (z >> 27)) *% 0x94d049bb133111eb;
  20fb56:	48 89 d1             	mov    rcx,rdx
  20fb59:	48 c1 e9 1b          	shr    rcx,0x1b
  20fb5d:	48 31 d1             	xor    rcx,rdx
  20fb60:	48 ba eb 11 31 13 bb 	movabs rdx,0x94d049bb133111eb
  20fb67:	49 d0 94 
  20fb6a:	48 89 d7             	mov    rdi,rdx
  20fb6d:	48 0f af cf          	imul   rcx,rdi
        return z ^ (z >> 31);
  20fb71:	48 89 ca             	mov    rdx,rcx
  20fb74:	48 c1 ea 1f          	shr    rdx,0x1f
  20fb78:	48 31 ca             	xor    rdx,rcx
        self.s +%= 0x9e3779b97f4a7c15;
  20fb7b:	48 b9 2a f8 94 fe 72 	movabs rcx,0x3c6ef372fe94f82a
  20fb82:	f3 6e 3c 
  20fb85:	48 01 c8             	add    rax,rcx
        z = (z ^ (z >> 30)) *% 0xbf58476d1ce4e5b9;
  20fb88:	48 89 c1             	mov    rcx,rax
  20fb8b:	48 c1 e9 1e          	shr    rcx,0x1e
  20fb8f:	48 31 c1             	xor    rcx,rax
  20fb92:	48 0f af ce          	imul   rcx,rsi
        z = (z ^ (z >> 27)) *% 0x94d049bb133111eb;
  20fb96:	48 89 c8             	mov    rax,rcx
  20fb99:	48 c1 e8 1b          	shr    rax,0x1b
  20fb9d:	48 31 c8             	xor    rax,rcx
  20fba0:	48 0f af c7          	imul   rax,rdi
        return z ^ (z >> 31);
  20fba4:	49 89 c4             	mov    r12,rax
  20fba7:	49 c1 ec 1f          	shr    r12,0x1f
  20fbab:	49 31 c4             	xor    r12,rax
    fn next(self: *Xoroshiro128) u64 {
        const s0 = self.s[0];
        var s1 = self.s[1];
        const r = s0 +% s1;

        s1 ^= s0;
  20fbae:	4c 89 e0             	mov    rax,r12
  20fbb1:	48 31 d0             	xor    rax,rdx
pub fn rotl(comptime T: type, x: T, r: var) T {
    if (T.is_signed) {
        @compileError("cannot rotate signed integer");
    } else {
        const ar = @mod(r, T.bit_count);
        return shl(T, x, ar) | shr(T, x, T.bit_count - ar);
  20fbb4:	c4 e3 fb f0 ca 09    	rorx   rcx,rdx,0x9
        self.s[0] = math.rotl(u64, s0, u8(55)) ^ s1 ^ (s1 << 14);
  20fbba:	48 31 c1             	xor    rcx,rax
  20fbbd:	c4 e3 fb f0 f0 1c    	rorx   rsi,rax,0x1c
  20fbc3:	48 c1 e0 0e          	shl    rax,0xe
  20fbc7:	48 31 c8             	xor    rax,rcx
            while (iterations <= pSelf.max_iterations) {
  20fbca:	4c 8b ac 24 88 00 00 	mov    r13,QWORD PTR [rsp+0x88]
  20fbd1:	00 
        const r = s0 +% s1;
  20fbd2:	49 01 d4             	add    r12,rdx
  20fbd5:	49 01 f4             	add    r12,rsi
  20fbd8:	49 01 c4             	add    r12,rax
  20fbdb:	4c 39 eb             	cmp    rbx,r13
  20fbde:	bd 00 00 00 00       	mov    ebp,0x0
  20fbe3:	76 1e                	jbe    20fc03 <BmPoor.add+0x2f3>
  20fbe5:	e9 50 03 00 00       	jmp    20ff3a <BmPoor.add+0x62a>
  20fbea:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
                        warn("iteratons:{} numer:{} denom:{}\n", iterations, numer, denom);
  20fbf0:	48 89 df             	mov    rdi,rbx
  20fbf3:	48 89 ca             	mov    rdx,rcx
  20fbf6:	e8 35 54 00 00       	call   215030 <warn.37>
  20fbfb:	c5 f8 10 0d 0d 07 ff 	vmovups xmm1,XMMWORD PTR [rip+0xffffffffffff070d]        # 200310 <__unnamed_35>
  20fc02:	ff 
                var ts: posix.timespec = undefined;
  20fc03:	c5 f8 29 4c 24 30    	vmovaps XMMWORD PTR [rsp+0x30],xmm1
  20fc09:	b8 e5 00 00 00       	mov    eax,0xe5
  20fc0e:	bf 01 00 00 00       	mov    edi,0x1
  20fc13:	4c 89 fe             	mov    rsi,r15
  20fc16:	0f 05                	syscall 
  20fc18:	48 89 c1             	mov    rcx,rax
  20fc1b:	48 f7 d9             	neg    rcx
  20fc1e:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  20fc24:	48 0f 46 cd          	cmovbe rcx,rbp
                switch (errno) {
  20fc28:	48 85 c9             	test   rcx,rcx
  20fc2b:	0f 85 dd 09 00 00    	jne    21060e <BmPoor.add+0xcfe>
        const f = @atomicLoad(@typeOf(init_vdso_clock_gettime), &vdso_clock_gettime, builtin.AtomicOrder.Unordered);
  20fc31:	48 8b 05 e0 c4 03 00 	mov    rax,QWORD PTR [rip+0x3c4e0]        # 24c118 <vdso_clock_gettime>
        if (@ptrToInt(f) != 0) {
  20fc38:	48 85 c0             	test   rax,rax
  20fc3b:	4c 89 fd             	mov    rbp,r15
  20fc3e:	74 21                	je     20fc61 <BmPoor.add+0x351>
            const rc = f(clk_id, tp);
  20fc40:	bf 01 00 00 00       	mov    edi,0x1
  20fc45:	48 89 ee             	mov    rsi,rbp
  20fc48:	ff d0                	call   rax
            switch (rc) {
  20fc4a:	48 83 f8 ea          	cmp    rax,0xffffffffffffffea
  20fc4e:	0f 84 3c 02 00 00    	je     20fe90 <BmPoor.add+0x580>
  20fc54:	48 85 c0             	test   rax,rax
  20fc57:	c5 f8 10 0d b1 06 ff 	vmovups xmm1,XMMWORD PTR [rip+0xffffffffffff06b1]        # 200310 <__unnamed_35>
  20fc5e:	ff 
  20fc5f:	74 0f                	je     20fc70 <BmPoor.add+0x360>
  20fc61:	b8 e4 00 00 00       	mov    eax,0xe4
  20fc66:	bf 01 00 00 00       	mov    edi,0x1
  20fc6b:	48 89 ee             	mov    rsi,rbp
  20fc6e:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  20fc70:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
                if (errno != 0) return std.os.unexpectedErrorPosix(errno);
  20fc76:	0f 83 9e 09 00 00    	jae    21061a <BmPoor.add+0xd0a>
                self.start_time = @intCast(u64, ts.tv_sec) * u64(ns_per_s) + @intCast(u64, ts.tv_nsec);
  20fc7c:	c5 f9 6f 54 24 30    	vmovdqa xmm2,XMMWORD PTR [rsp+0x30]
        while (iter > 0) : (iter -= 1) {
  20fc82:	48 85 db             	test   rbx,rbx
  20fc85:	4d 0f 45 f4          	cmovne r14,r12
        var ts: posix.timespec = undefined;
  20fc89:	c5 f8 29 4c 24 30    	vmovaps XMMWORD PTR [rsp+0x30],xmm1
        const f = @atomicLoad(@typeOf(init_vdso_clock_gettime), &vdso_clock_gettime, builtin.AtomicOrder.Unordered);
  20fc8f:	48 8b 05 82 c4 03 00 	mov    rax,QWORD PTR [rip+0x3c482]        # 24c118 <vdso_clock_gettime>
        if (@ptrToInt(f) != 0) {
  20fc96:	48 85 c0             	test   rax,rax
  20fc99:	74 33                	je     20fcce <BmPoor.add+0x3be>
  20fc9b:	c5 f9 7f 94 24 d0 00 	vmovdqa XMMWORD PTR [rsp+0xd0],xmm2
  20fca2:	00 00 
            const rc = f(clk_id, tp);
  20fca4:	bf 01 00 00 00       	mov    edi,0x1
  20fca9:	48 89 ee             	mov    rsi,rbp
  20fcac:	ff d0                	call   rax
            switch (rc) {
  20fcae:	48 83 f8 ea          	cmp    rax,0xffffffffffffffea
  20fcb2:	0f 84 f1 01 00 00    	je     20fea9 <BmPoor.add+0x599>
  20fcb8:	48 85 c0             	test   rax,rax
  20fcbb:	c5 f8 10 0d 4d 06 ff 	vmovups xmm1,XMMWORD PTR [rip+0xffffffffffff064d]        # 200310 <__unnamed_35>
  20fcc2:	ff 
  20fcc3:	c5 f9 6f 94 24 d0 00 	vmovdqa xmm2,XMMWORD PTR [rsp+0xd0]
  20fcca:	00 00 
  20fccc:	74 0f                	je     20fcdd <BmPoor.add+0x3cd>
  20fcce:	b8 e4 00 00 00       	mov    eax,0xe4
  20fcd3:	bf 01 00 00 00       	mov    edi,0x1
  20fcd8:	48 89 ee             	mov    rsi,rbp
  20fcdb:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  20fcdd:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
  20fce3:	0f 83 4d 09 00 00    	jae    210636 <BmPoor.add+0xd26>
        return @intCast(u64, ts.tv_sec) * u64(ns_per_s) + @intCast(u64, ts.tv_nsec);
  20fce9:	c5 f9 6f 44 24 30    	vmovdqa xmm0,XMMWORD PTR [rsp+0x30]
  20fcef:	c5 f9 fb c2          	vpsubq xmm0,xmm0,xmm2
  20fcf3:	c4 e1 f9 7e c0       	vmovq  rax,xmm0
        var clock = clockNative() - self.start_time;
  20fcf8:	c4 e3 f9 16 c5 01    	vpextrq rbp,xmm0,0x1
  20fcfe:	48 69 c0 00 ca 9a 3b 	imul   rax,rax,0x3b9aca00
  20fd05:	48 01 c5             	add    rbp,rax
                if ((run_time_ns >= pSelf.min_runtime_ns) or (iterations >= pSelf.max_iterations)) {
  20fd08:	48 3b 6c 24 78       	cmp    rbp,QWORD PTR [rsp+0x78]
  20fd0d:	0f 83 f4 01 00 00    	jae    20ff07 <BmPoor.add+0x5f7>
  20fd13:	4c 39 eb             	cmp    rbx,r13
  20fd16:	0f 83 eb 01 00 00    	jae    20ff07 <BmPoor.add+0x5f7>
                    if (pSelf.logl >= 1) {
  20fd1c:	48 83 7c 24 70 00    	cmp    QWORD PTR [rsp+0x70],0x0
  20fd22:	0f 84 c6 00 00 00    	je     20fdee <BmPoor.add+0x4de>
                            Result {.run_time_ns = run_time_ns, .iterations = iterations});
  20fd28:	48 89 ac 24 e8 00 00 	mov    QWORD PTR [rsp+0xe8],rbp
  20fd2f:	00 
  20fd30:	48 89 9c 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rbx
  20fd37:	00 
                        try pSelf.report(
  20fd38:	48 8d 7c 24 60       	lea    rdi,[rsp+0x60]
  20fd3d:	48 8d b4 24 e8 00 00 	lea    rsi,[rsp+0xe8]
  20fd44:	00 
  20fd45:	e8 d6 31 00 00       	call   212f20 <Benchmark_report>
  20fd4a:	66 85 c0             	test   ax,ax
  20fd4d:	0f 85 cb 08 00 00    	jne    21061e <BmPoor.add+0xd0e>
  20fd53:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20fd5a:	84 00 00 00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20fd60:	b0 01                	mov    al,0x1
  20fd62:	86 05 a8 12 04 00    	xchg   BYTE PTR [rip+0x412a8],al        # 251010 <stderr_mutex>
  20fd68:	84 c0                	test   al,al
  20fd6a:	75 f4                	jne    20fd60 <BmPoor.add+0x450>
    if (stderr_stream) |st| {
  20fd6c:	48 8b 3d 95 12 04 00 	mov    rdi,QWORD PTR [rip+0x41295]        # 251008 <stderr_stream>
  20fd73:	48 85 ff             	test   rdi,rdi
  20fd76:	74 18                	je     20fd90 <BmPoor.add+0x480>
  20fd78:	48 8b 0d c1 c2 03 00 	mov    rcx,QWORD PTR [rip+0x3c2c1]        # 24c040 <stderr_file_out_stream+0x8>
  20fd7f:	eb 4c                	jmp    20fdcd <BmPoor.add+0x4bd>
  20fd81:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20fd88:	0f 1f 84 00 00 00 00 
  20fd8f:	00 
        stderr_file = try io.getStdErr();
  20fd90:	c7 05 96 c2 03 00 02 	mov    DWORD PTR [rip+0x3c296],0x2        # 24c030 <stderr_file>
  20fd97:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20fd9a:	48 8d 05 8f c2 03 00 	lea    rax,[rip+0x3c28f]        # 24c030 <stderr_file>
  20fda1:	48 89 05 90 c2 03 00 	mov    QWORD PTR [rip+0x3c290],rax        # 24c038 <stderr_file_out_stream>
  20fda8:	48 8d 05 f1 f0 00 00 	lea    rax,[rip+0xf0f1]        # 21eea0 <FileOutStream_writeFn>
  20fdaf:	48 89 05 8a c2 03 00 	mov    QWORD PTR [rip+0x3c28a],rax        # 24c040 <stderr_file_out_stream+0x8>
  20fdb6:	48 8d 0d 83 c2 03 00 	lea    rcx,[rip+0x3c283]        # 24c040 <stderr_file_out_stream+0x8>
  20fdbd:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20fdc0:	48 89 15 41 12 04 00 	mov    QWORD PTR [rip+0x41241],rdx        # 251008 <stderr_stream>
  20fdc7:	48 89 c1             	mov    rcx,rax
  20fdca:	48 89 d7             	mov    rdi,rdx
  20fdcd:	48 8d 35 1c 01 04 00 	lea    rsi,[rip+0x4011c]        # 24fef0 <__unnamed_3>
  20fdd4:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20fdd6:	31 c0                	xor    eax,eax
  20fdd8:	86 05 32 12 04 00    	xchg   BYTE PTR [rip+0x41232],al        # 251010 <stderr_mutex>
  20fdde:	3c 01                	cmp    al,0x1
  20fde0:	c5 f8 10 0d 28 05 ff 	vmovups xmm1,XMMWORD PTR [rip+0xffffffffffff0528]        # 200310 <__unnamed_35>
  20fde7:	ff 
    if (!ok) {
  20fde8:	0f 85 48 08 00 00    	jne    210636 <BmPoor.add+0xd26>
                    if (run_time_ns < 1000) {
  20fdee:	48 81 fd e8 03 00 00 	cmp    rbp,0x3e8
  20fdf5:	73 19                	jae    20fe10 <BmPoor.add+0x500>
  20fdf7:	b9 01 00 00 00       	mov    ecx,0x1
  20fdfc:	be e8 03 00 00       	mov    esi,0x3e8
  20fe01:	eb 3a                	jmp    20fe3d <BmPoor.add+0x52d>
  20fe03:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20fe0a:	84 00 00 00 00 00 
                    } else if (run_time_ns < (pSelf.min_runtime_ns / 10)) {
  20fe10:	48 ba cd cc cc cc cc 	movabs rdx,0xcccccccccccccccd
  20fe17:	cc cc cc 
  20fe1a:	c4 e2 fb f6 4c 24 78 	mulx   rcx,rax,QWORD PTR [rsp+0x78]
  20fe21:	48 c1 e9 03          	shr    rcx,0x3
  20fe25:	31 c0                	xor    eax,eax
  20fe27:	48 39 cd             	cmp    rbp,rcx
  20fe2a:	0f 93 c0             	setae  al
  20fe2d:	48 8d 0c c0          	lea    rcx,[rax+rax*8]
  20fe31:	48 83 c1 01          	add    rcx,0x1
  20fe35:	48 8d 34 85 0a 00 00 	lea    rsi,[rax*4+0xa]
  20fe3c:	00 
  20fe3d:	31 ed                	xor    ebp,ebp
                    iterations = (iterations * numer) / denom;
  20fe3f:	48 0f af de          	imul   rbx,rsi
  20fe43:	48 89 d8             	mov    rax,rbx
  20fe46:	48 c1 e8 20          	shr    rax,0x20
  20fe4a:	74 14                	je     20fe60 <BmPoor.add+0x550>
  20fe4c:	31 d2                	xor    edx,edx
  20fe4e:	48 89 d8             	mov    rax,rbx
  20fe51:	48 f7 f1             	div    rcx
  20fe54:	48 89 c3             	mov    rbx,rax
  20fe57:	eb 0f                	jmp    20fe68 <BmPoor.add+0x558>
  20fe59:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  20fe60:	31 d2                	xor    edx,edx
  20fe62:	89 d8                	mov    eax,ebx
  20fe64:	f7 f1                	div    ecx
  20fe66:	89 c3                	mov    ebx,eax
                    if (iterations > pSelf.max_iterations) {
  20fe68:	4c 8b ac 24 88 00 00 	mov    r13,QWORD PTR [rsp+0x88]
  20fe6f:	00 
  20fe70:	4c 39 eb             	cmp    rbx,r13
  20fe73:	49 0f 47 dd          	cmova  rbx,r13
                    if (pSelf.logl >= 2) {
  20fe77:	48 83 7c 24 70 02    	cmp    QWORD PTR [rsp+0x70],0x2
  20fe7d:	0f 82 80 fd ff ff    	jb     20fc03 <BmPoor.add+0x2f3>
  20fe83:	e9 68 fd ff ff       	jmp    20fbf0 <BmPoor.add+0x2e0>
  20fe88:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  20fe8f:	00 
  20fe90:	c5 f8 10 0d 78 04 ff 	vmovups xmm1,XMMWORD PTR [rip+0xffffffffffff0478]        # 200310 <__unnamed_35>
  20fe97:	ff 
  20fe98:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
  20fe9e:	0f 82 d8 fd ff ff    	jb     20fc7c <BmPoor.add+0x36c>
  20fea4:	e9 71 07 00 00       	jmp    21061a <BmPoor.add+0xd0a>
  20fea9:	c5 f8 10 0d 5f 04 ff 	vmovups xmm1,XMMWORD PTR [rip+0xffffffffffff045f]        # 200310 <__unnamed_35>
  20feb0:	ff 
  20feb1:	c5 f9 6f 94 24 d0 00 	vmovdqa xmm2,XMMWORD PTR [rsp+0xd0]
  20feb8:	00 00 
  20feba:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
  20fec0:	0f 82 23 fe ff ff    	jb     20fce9 <BmPoor.add+0x3d9>
  20fec6:	e9 6b 07 00 00       	jmp    210636 <BmPoor.add+0xd26>
  20fecb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  20fed0:	c5 f8 10 0d 38 04 ff 	vmovups xmm1,XMMWORD PTR [rip+0xffffffffffff0438]        # 200310 <__unnamed_35>
  20fed7:	ff 
  20fed8:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
                if (errno != 0) return std.os.unexpectedErrorPosix(errno);
  20fede:	0f 82 d2 fb ff ff    	jb     20fab6 <BmPoor.add+0x1a6>
  20fee4:	e9 31 07 00 00       	jmp    21061a <BmPoor.add+0xd0a>
  20fee9:	c5 f8 10 0d 1f 04 ff 	vmovups xmm1,XMMWORD PTR [rip+0xffffffffffff041f]        # 200310 <__unnamed_35>
  20fef0:	ff 
  20fef1:	4c 89 6c 24 28       	mov    QWORD PTR [rsp+0x28],r13
  20fef6:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
  20fefc:	0f 82 11 fc ff ff    	jb     20fb13 <BmPoor.add+0x203>
  20ff02:	e9 2f 07 00 00       	jmp    210636 <BmPoor.add+0xd26>
                            Result { .run_time_ns = run_time_ns, .iterations = iterations});
  20ff07:	48 89 ac 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],rbp
  20ff0e:	00 
  20ff0f:	48 89 9c 24 00 01 00 	mov    QWORD PTR [rsp+0x100],rbx
  20ff16:	00 
                    try pSelf.results.append(
  20ff17:	48 8d bc 24 a8 00 00 	lea    rdi,[rsp+0xa8]
  20ff1e:	00 
  20ff1f:	48 8d b4 24 f8 00 00 	lea    rsi,[rsp+0xf8]
  20ff26:	00 
  20ff27:	e8 84 2e 00 00       	call   212db0 <AlignedArrayList(Result,8)_append>
  20ff2c:	66 85 c0             	test   ax,ax
  20ff2f:	bd 00 00 00 00       	mov    ebp,0x0
  20ff34:	0f 85 e4 06 00 00    	jne    21061e <BmPoor.add+0xd0e>
            if (pSelf.r != (u64(pSelf.a) +% u64(pSelf.b))) return error.Failed;
  20ff3a:	4d 39 f4             	cmp    r12,r14
  20ff3d:	4c 8d 6c 24 10       	lea    r13,[rsp+0x10]
                    try bm.tearDown();
  20ff42:	0f 85 e8 06 00 00    	jne    210630 <BmPoor.add+0xd20>
            if (once) {
  20ff48:	f6 44 24 24 01       	test   BYTE PTR [rsp+0x24],0x1
  20ff4d:	4c 8d 74 24 0f       	lea    r14,[rsp+0xf]
  20ff52:	0f 84 cf 05 00 00    	je     210527 <BmPoor.add+0xc17>
                try leftJustified(22, "name repetitions:{}", pSelf.repetitions);
  20ff58:	48 8b bc 24 80 00 00 	mov    rdi,QWORD PTR [rsp+0x80]
  20ff5f:	00 
  20ff60:	e8 3b 54 00 00       	call   2153a0 <Benchmark_leftJustified>
  20ff65:	66 85 c0             	test   ax,ax
  20ff68:	0f 85 b0 06 00 00    	jne    21061e <BmPoor.add+0xd0e>
                try rightJustified(14, "{}", "iterations");
  20ff6e:	e8 cd 56 00 00       	call   215640 <Benchmark_rightJustified>
  20ff73:	66 85 c0             	test   ax,ax
  20ff76:	0f 85 a2 06 00 00    	jne    21061e <BmPoor.add+0xd0e>
        var buffer: [40]u8 = undefined;
  20ff7c:	c5 fe 6f 05 cb 5f ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffff5fcb]        # 205f4f <__unnamed_7>
  20ff83:	ff 
  20ff84:	c5 fe 7f 44 24 30    	vmovdqu YMMWORD PTR [rsp+0x30],ymm0
  20ff8a:	48 8b 05 de 5f ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffff5fde]        # 205f6f <__unnamed_7+0x20>
  20ff91:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
  20ff96:	c7 44 24 30 74 69 6d 	mov    DWORD PTR [rsp+0x30],0x656d6974
  20ff9d:	65 
  20ff9e:	66 90                	xchg   ax,ax
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20ffa0:	b0 01                	mov    al,0x1
  20ffa2:	86 05 68 10 04 00    	xchg   BYTE PTR [rip+0x41068],al        # 251010 <stderr_mutex>
  20ffa8:	84 c0                	test   al,al
  20ffaa:	75 f4                	jne    20ffa0 <BmPoor.add+0x690>
    if (stderr_stream) |st| {
  20ffac:	48 8b 3d 55 10 04 00 	mov    rdi,QWORD PTR [rip+0x41055]        # 251008 <stderr_stream>
  20ffb3:	48 85 ff             	test   rdi,rdi
  20ffb6:	74 09                	je     20ffc1 <BmPoor.add+0x6b1>
  20ffb8:	48 8b 0d 81 c0 03 00 	mov    rcx,QWORD PTR [rip+0x3c081]        # 24c040 <stderr_file_out_stream+0x8>
  20ffbf:	eb 3d                	jmp    20fffe <BmPoor.add+0x6ee>
        stderr_file = try io.getStdErr();
  20ffc1:	c7 05 65 c0 03 00 02 	mov    DWORD PTR [rip+0x3c065],0x2        # 24c030 <stderr_file>
  20ffc8:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20ffcb:	48 8d 05 5e c0 03 00 	lea    rax,[rip+0x3c05e]        # 24c030 <stderr_file>
  20ffd2:	48 89 05 5f c0 03 00 	mov    QWORD PTR [rip+0x3c05f],rax        # 24c038 <stderr_file_out_stream>
  20ffd9:	48 8d 05 c0 ee 00 00 	lea    rax,[rip+0xeec0]        # 21eea0 <FileOutStream_writeFn>
  20ffe0:	48 89 05 59 c0 03 00 	mov    QWORD PTR [rip+0x3c059],rax        # 24c040 <stderr_file_out_stream+0x8>
  20ffe7:	48 8d 0d 52 c0 03 00 	lea    rcx,[rip+0x3c052]        # 24c040 <stderr_file_out_stream+0x8>
  20ffee:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20fff1:	48 89 15 10 10 04 00 	mov    QWORD PTR [rip+0x41010],rdx        # 251008 <stderr_stream>
  20fff8:	48 89 c1             	mov    rcx,rax
  20fffb:	48 89 d7             	mov    rdi,rdx
  20fffe:	c6 44 24 0f 20       	mov    BYTE PTR [rsp+0xf],0x20
    return output(context, (*[1]u8)(&c)[0..]);
  210003:	4c 89 74 24 10       	mov    QWORD PTR [rsp+0x10],r14
  210008:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  21000f:	00 00 
  210011:	4c 89 ee             	mov    rsi,r13
  210014:	c5 f8 77             	vzeroupper 
  210017:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  210019:	31 c0                	xor    eax,eax
  21001b:	86 05 ef 0f 04 00    	xchg   BYTE PTR [rip+0x40fef],al        # 251010 <stderr_mutex>
  210021:	3c 01                	cmp    al,0x1
    if (!ok) {
  210023:	0f 85 0d 06 00 00    	jne    210636 <BmPoor.add+0xd26>
  210029:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  210030:	b0 01                	mov    al,0x1
  210032:	86 05 d8 0f 04 00    	xchg   BYTE PTR [rip+0x40fd8],al        # 251010 <stderr_mutex>
  210038:	84 c0                	test   al,al
  21003a:	75 f4                	jne    210030 <BmPoor.add+0x720>
    if (stderr_stream) |st| {
  21003c:	48 8b 3d c5 0f 04 00 	mov    rdi,QWORD PTR [rip+0x40fc5]        # 251008 <stderr_stream>
  210043:	48 85 ff             	test   rdi,rdi
  210046:	74 09                	je     210051 <BmPoor.add+0x741>
  210048:	48 8b 0d f1 bf 03 00 	mov    rcx,QWORD PTR [rip+0x3bff1]        # 24c040 <stderr_file_out_stream+0x8>
  21004f:	eb 3d                	jmp    21008e <BmPoor.add+0x77e>
        stderr_file = try io.getStdErr();
  210051:	c7 05 d5 bf 03 00 02 	mov    DWORD PTR [rip+0x3bfd5],0x2        # 24c030 <stderr_file>
  210058:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  21005b:	48 8d 05 ce bf 03 00 	lea    rax,[rip+0x3bfce]        # 24c030 <stderr_file>
  210062:	48 89 05 cf bf 03 00 	mov    QWORD PTR [rip+0x3bfcf],rax        # 24c038 <stderr_file_out_stream>
  210069:	48 8d 05 30 ee 00 00 	lea    rax,[rip+0xee30]        # 21eea0 <FileOutStream_writeFn>
  210070:	48 89 05 c9 bf 03 00 	mov    QWORD PTR [rip+0x3bfc9],rax        # 24c040 <stderr_file_out_stream+0x8>
  210077:	48 8d 0d c2 bf 03 00 	lea    rcx,[rip+0x3bfc2]        # 24c040 <stderr_file_out_stream+0x8>
  21007e:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  210081:	48 89 15 80 0f 04 00 	mov    QWORD PTR [rip+0x40f80],rdx        # 251008 <stderr_stream>
  210088:	48 89 c1             	mov    rcx,rax
  21008b:	48 89 d7             	mov    rdi,rdx
  21008e:	c6 44 24 0f 20       	mov    BYTE PTR [rsp+0xf],0x20
  210093:	4c 89 74 24 10       	mov    QWORD PTR [rsp+0x10],r14
  210098:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  21009f:	00 00 
  2100a1:	4c 89 ee             	mov    rsi,r13
  2100a4:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  2100a6:	31 c0                	xor    eax,eax
  2100a8:	86 05 62 0f 04 00    	xchg   BYTE PTR [rip+0x40f62],al        # 251010 <stderr_mutex>
  2100ae:	3c 01                	cmp    al,0x1
    if (!ok) {
  2100b0:	0f 85 80 05 00 00    	jne    210636 <BmPoor.add+0xd26>
  2100b6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  2100bd:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  2100c0:	b0 01                	mov    al,0x1
  2100c2:	86 05 48 0f 04 00    	xchg   BYTE PTR [rip+0x40f48],al        # 251010 <stderr_mutex>
  2100c8:	84 c0                	test   al,al
  2100ca:	75 f4                	jne    2100c0 <BmPoor.add+0x7b0>
    if (stderr_stream) |st| {
  2100cc:	48 8b 3d 35 0f 04 00 	mov    rdi,QWORD PTR [rip+0x40f35]        # 251008 <stderr_stream>
  2100d3:	48 85 ff             	test   rdi,rdi
  2100d6:	74 09                	je     2100e1 <BmPoor.add+0x7d1>
  2100d8:	48 8b 0d 61 bf 03 00 	mov    rcx,QWORD PTR [rip+0x3bf61]        # 24c040 <stderr_file_out_stream+0x8>
  2100df:	eb 3d                	jmp    21011e <BmPoor.add+0x80e>
        stderr_file = try io.getStdErr();
  2100e1:	c7 05 45 bf 03 00 02 	mov    DWORD PTR [rip+0x3bf45],0x2        # 24c030 <stderr_file>
  2100e8:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  2100eb:	48 8d 05 3e bf 03 00 	lea    rax,[rip+0x3bf3e]        # 24c030 <stderr_file>
  2100f2:	48 89 05 3f bf 03 00 	mov    QWORD PTR [rip+0x3bf3f],rax        # 24c038 <stderr_file_out_stream>
  2100f9:	48 8d 05 a0 ed 00 00 	lea    rax,[rip+0xeda0]        # 21eea0 <FileOutStream_writeFn>
  210100:	48 89 05 39 bf 03 00 	mov    QWORD PTR [rip+0x3bf39],rax        # 24c040 <stderr_file_out_stream+0x8>
  210107:	48 8d 0d 32 bf 03 00 	lea    rcx,[rip+0x3bf32]        # 24c040 <stderr_file_out_stream+0x8>
  21010e:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  210111:	48 89 15 f0 0e 04 00 	mov    QWORD PTR [rip+0x40ef0],rdx        # 251008 <stderr_stream>
  210118:	48 89 c1             	mov    rcx,rax
  21011b:	48 89 d7             	mov    rdi,rdx
  21011e:	c6 44 24 0f 20       	mov    BYTE PTR [rsp+0xf],0x20
  210123:	4c 89 74 24 10       	mov    QWORD PTR [rsp+0x10],r14
  210128:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  21012f:	00 00 
  210131:	4c 89 ee             	mov    rsi,r13
  210134:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  210136:	31 c0                	xor    eax,eax
  210138:	86 05 d2 0e 04 00    	xchg   BYTE PTR [rip+0x40ed2],al        # 251010 <stderr_mutex>
  21013e:	3c 01                	cmp    al,0x1
    if (!ok) {
  210140:	0f 85 f0 04 00 00    	jne    210636 <BmPoor.add+0xd26>
  210146:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  21014d:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  210150:	b0 01                	mov    al,0x1
  210152:	86 05 b8 0e 04 00    	xchg   BYTE PTR [rip+0x40eb8],al        # 251010 <stderr_mutex>
  210158:	84 c0                	test   al,al
  21015a:	75 f4                	jne    210150 <BmPoor.add+0x840>
    if (stderr_stream) |st| {
  21015c:	48 8b 3d a5 0e 04 00 	mov    rdi,QWORD PTR [rip+0x40ea5]        # 251008 <stderr_stream>
  210163:	48 85 ff             	test   rdi,rdi
  210166:	74 09                	je     210171 <BmPoor.add+0x861>
  210168:	48 8b 0d d1 be 03 00 	mov    rcx,QWORD PTR [rip+0x3bed1]        # 24c040 <stderr_file_out_stream+0x8>
  21016f:	eb 3d                	jmp    2101ae <BmPoor.add+0x89e>
        stderr_file = try io.getStdErr();
  210171:	c7 05 b5 be 03 00 02 	mov    DWORD PTR [rip+0x3beb5],0x2        # 24c030 <stderr_file>
  210178:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  21017b:	48 8d 05 ae be 03 00 	lea    rax,[rip+0x3beae]        # 24c030 <stderr_file>
  210182:	48 89 05 af be 03 00 	mov    QWORD PTR [rip+0x3beaf],rax        # 24c038 <stderr_file_out_stream>
  210189:	48 8d 05 10 ed 00 00 	lea    rax,[rip+0xed10]        # 21eea0 <FileOutStream_writeFn>
  210190:	48 89 05 a9 be 03 00 	mov    QWORD PTR [rip+0x3bea9],rax        # 24c040 <stderr_file_out_stream+0x8>
  210197:	48 8d 0d a2 be 03 00 	lea    rcx,[rip+0x3bea2]        # 24c040 <stderr_file_out_stream+0x8>
  21019e:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  2101a1:	48 89 15 60 0e 04 00 	mov    QWORD PTR [rip+0x40e60],rdx        # 251008 <stderr_stream>
  2101a8:	48 89 c1             	mov    rcx,rax
  2101ab:	48 89 d7             	mov    rdi,rdx
  2101ae:	c6 44 24 0f 20       	mov    BYTE PTR [rsp+0xf],0x20
  2101b3:	4c 89 74 24 10       	mov    QWORD PTR [rsp+0x10],r14
  2101b8:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  2101bf:	00 00 
  2101c1:	4c 89 ee             	mov    rsi,r13
  2101c4:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  2101c6:	31 c0                	xor    eax,eax
  2101c8:	86 05 42 0e 04 00    	xchg   BYTE PTR [rip+0x40e42],al        # 251010 <stderr_mutex>
  2101ce:	3c 01                	cmp    al,0x1
    if (!ok) {
  2101d0:	0f 85 60 04 00 00    	jne    210636 <BmPoor.add+0xd26>
  2101d6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  2101dd:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  2101e0:	b0 01                	mov    al,0x1
  2101e2:	86 05 28 0e 04 00    	xchg   BYTE PTR [rip+0x40e28],al        # 251010 <stderr_mutex>
  2101e8:	84 c0                	test   al,al
  2101ea:	75 f4                	jne    2101e0 <BmPoor.add+0x8d0>
    if (stderr_stream) |st| {
  2101ec:	48 8b 3d 15 0e 04 00 	mov    rdi,QWORD PTR [rip+0x40e15]        # 251008 <stderr_stream>
  2101f3:	48 85 ff             	test   rdi,rdi
  2101f6:	74 09                	je     210201 <BmPoor.add+0x8f1>
  2101f8:	48 8b 0d 41 be 03 00 	mov    rcx,QWORD PTR [rip+0x3be41]        # 24c040 <stderr_file_out_stream+0x8>
  2101ff:	eb 3d                	jmp    21023e <BmPoor.add+0x92e>
        stderr_file = try io.getStdErr();
  210201:	c7 05 25 be 03 00 02 	mov    DWORD PTR [rip+0x3be25],0x2        # 24c030 <stderr_file>
  210208:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  21020b:	48 8d 05 1e be 03 00 	lea    rax,[rip+0x3be1e]        # 24c030 <stderr_file>
  210212:	48 89 05 1f be 03 00 	mov    QWORD PTR [rip+0x3be1f],rax        # 24c038 <stderr_file_out_stream>
  210219:	48 8d 05 80 ec 00 00 	lea    rax,[rip+0xec80]        # 21eea0 <FileOutStream_writeFn>
  210220:	48 89 05 19 be 03 00 	mov    QWORD PTR [rip+0x3be19],rax        # 24c040 <stderr_file_out_stream+0x8>
  210227:	48 8d 0d 12 be 03 00 	lea    rcx,[rip+0x3be12]        # 24c040 <stderr_file_out_stream+0x8>
  21022e:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  210231:	48 89 15 d0 0d 04 00 	mov    QWORD PTR [rip+0x40dd0],rdx        # 251008 <stderr_stream>
  210238:	48 89 c1             	mov    rcx,rax
  21023b:	48 89 d7             	mov    rdi,rdx
  21023e:	c6 44 24 0f 20       	mov    BYTE PTR [rsp+0xf],0x20
  210243:	4c 89 74 24 10       	mov    QWORD PTR [rsp+0x10],r14
  210248:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  21024f:	00 00 
  210251:	4c 89 ee             	mov    rsi,r13
  210254:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  210256:	31 c0                	xor    eax,eax
  210258:	86 05 b2 0d 04 00    	xchg   BYTE PTR [rip+0x40db2],al        # 251010 <stderr_mutex>
  21025e:	3c 01                	cmp    al,0x1
    if (!ok) {
  210260:	0f 85 d0 03 00 00    	jne    210636 <BmPoor.add+0xd26>
  210266:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  21026d:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  210270:	b0 01                	mov    al,0x1
  210272:	86 05 98 0d 04 00    	xchg   BYTE PTR [rip+0x40d98],al        # 251010 <stderr_mutex>
  210278:	84 c0                	test   al,al
  21027a:	75 f4                	jne    210270 <BmPoor.add+0x960>
    if (stderr_stream) |st| {
  21027c:	48 8b 3d 85 0d 04 00 	mov    rdi,QWORD PTR [rip+0x40d85]        # 251008 <stderr_stream>
  210283:	48 85 ff             	test   rdi,rdi
  210286:	74 09                	je     210291 <BmPoor.add+0x981>
  210288:	48 8b 0d b1 bd 03 00 	mov    rcx,QWORD PTR [rip+0x3bdb1]        # 24c040 <stderr_file_out_stream+0x8>
  21028f:	eb 3d                	jmp    2102ce <BmPoor.add+0x9be>
        stderr_file = try io.getStdErr();
  210291:	c7 05 95 bd 03 00 02 	mov    DWORD PTR [rip+0x3bd95],0x2        # 24c030 <stderr_file>
  210298:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  21029b:	48 8d 05 8e bd 03 00 	lea    rax,[rip+0x3bd8e]        # 24c030 <stderr_file>
  2102a2:	48 89 05 8f bd 03 00 	mov    QWORD PTR [rip+0x3bd8f],rax        # 24c038 <stderr_file_out_stream>
  2102a9:	48 8d 05 f0 eb 00 00 	lea    rax,[rip+0xebf0]        # 21eea0 <FileOutStream_writeFn>
  2102b0:	48 89 05 89 bd 03 00 	mov    QWORD PTR [rip+0x3bd89],rax        # 24c040 <stderr_file_out_stream+0x8>
  2102b7:	48 8d 0d 82 bd 03 00 	lea    rcx,[rip+0x3bd82]        # 24c040 <stderr_file_out_stream+0x8>
  2102be:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  2102c1:	48 89 15 40 0d 04 00 	mov    QWORD PTR [rip+0x40d40],rdx        # 251008 <stderr_stream>
  2102c8:	48 89 c1             	mov    rcx,rax
  2102cb:	48 89 d7             	mov    rdi,rdx
  2102ce:	c6 44 24 0f 20       	mov    BYTE PTR [rsp+0xf],0x20
  2102d3:	4c 89 74 24 10       	mov    QWORD PTR [rsp+0x10],r14
  2102d8:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  2102df:	00 00 
  2102e1:	4c 89 ee             	mov    rsi,r13
  2102e4:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  2102e6:	31 c0                	xor    eax,eax
  2102e8:	86 05 22 0d 04 00    	xchg   BYTE PTR [rip+0x40d22],al        # 251010 <stderr_mutex>
  2102ee:	3c 01                	cmp    al,0x1
    if (!ok) {
  2102f0:	0f 85 40 03 00 00    	jne    210636 <BmPoor.add+0xd26>
  2102f6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  2102fd:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  210300:	b0 01                	mov    al,0x1
  210302:	86 05 08 0d 04 00    	xchg   BYTE PTR [rip+0x40d08],al        # 251010 <stderr_mutex>
  210308:	84 c0                	test   al,al
  21030a:	75 f4                	jne    210300 <BmPoor.add+0x9f0>
    if (stderr_stream) |st| {
  21030c:	48 8b 3d f5 0c 04 00 	mov    rdi,QWORD PTR [rip+0x40cf5]        # 251008 <stderr_stream>
  210313:	48 85 ff             	test   rdi,rdi
  210316:	74 09                	je     210321 <BmPoor.add+0xa11>
  210318:	48 8b 0d 21 bd 03 00 	mov    rcx,QWORD PTR [rip+0x3bd21]        # 24c040 <stderr_file_out_stream+0x8>
  21031f:	eb 3d                	jmp    21035e <BmPoor.add+0xa4e>
        stderr_file = try io.getStdErr();
  210321:	c7 05 05 bd 03 00 02 	mov    DWORD PTR [rip+0x3bd05],0x2        # 24c030 <stderr_file>
  210328:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  21032b:	48 8d 05 fe bc 03 00 	lea    rax,[rip+0x3bcfe]        # 24c030 <stderr_file>
  210332:	48 89 05 ff bc 03 00 	mov    QWORD PTR [rip+0x3bcff],rax        # 24c038 <stderr_file_out_stream>
  210339:	48 8d 05 60 eb 00 00 	lea    rax,[rip+0xeb60]        # 21eea0 <FileOutStream_writeFn>
  210340:	48 89 05 f9 bc 03 00 	mov    QWORD PTR [rip+0x3bcf9],rax        # 24c040 <stderr_file_out_stream+0x8>
  210347:	48 8d 0d f2 bc 03 00 	lea    rcx,[rip+0x3bcf2]        # 24c040 <stderr_file_out_stream+0x8>
  21034e:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  210351:	48 89 15 b0 0c 04 00 	mov    QWORD PTR [rip+0x40cb0],rdx        # 251008 <stderr_stream>
  210358:	48 89 c1             	mov    rcx,rax
  21035b:	48 89 d7             	mov    rdi,rdx
  21035e:	c6 44 24 0f 20       	mov    BYTE PTR [rsp+0xf],0x20
  210363:	4c 89 74 24 10       	mov    QWORD PTR [rsp+0x10],r14
  210368:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  21036f:	00 00 
  210371:	4c 89 ee             	mov    rsi,r13
  210374:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  210376:	31 c0                	xor    eax,eax
  210378:	86 05 92 0c 04 00    	xchg   BYTE PTR [rip+0x40c92],al        # 251010 <stderr_mutex>
  21037e:	3c 01                	cmp    al,0x1
    if (!ok) {
  210380:	0f 85 b0 02 00 00    	jne    210636 <BmPoor.add+0xd26>
  210386:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  21038d:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  210390:	b0 01                	mov    al,0x1
  210392:	86 05 78 0c 04 00    	xchg   BYTE PTR [rip+0x40c78],al        # 251010 <stderr_mutex>
  210398:	84 c0                	test   al,al
  21039a:	75 f4                	jne    210390 <BmPoor.add+0xa80>
    if (stderr_stream) |st| {
  21039c:	48 8b 3d 65 0c 04 00 	mov    rdi,QWORD PTR [rip+0x40c65]        # 251008 <stderr_stream>
  2103a3:	48 85 ff             	test   rdi,rdi
  2103a6:	74 09                	je     2103b1 <BmPoor.add+0xaa1>
  2103a8:	48 8b 0d 91 bc 03 00 	mov    rcx,QWORD PTR [rip+0x3bc91]        # 24c040 <stderr_file_out_stream+0x8>
  2103af:	eb 3d                	jmp    2103ee <BmPoor.add+0xade>
        stderr_file = try io.getStdErr();
  2103b1:	c7 05 75 bc 03 00 02 	mov    DWORD PTR [rip+0x3bc75],0x2        # 24c030 <stderr_file>
  2103b8:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  2103bb:	48 8d 05 6e bc 03 00 	lea    rax,[rip+0x3bc6e]        # 24c030 <stderr_file>
  2103c2:	48 89 05 6f bc 03 00 	mov    QWORD PTR [rip+0x3bc6f],rax        # 24c038 <stderr_file_out_stream>
  2103c9:	48 8d 05 d0 ea 00 00 	lea    rax,[rip+0xead0]        # 21eea0 <FileOutStream_writeFn>
  2103d0:	48 89 05 69 bc 03 00 	mov    QWORD PTR [rip+0x3bc69],rax        # 24c040 <stderr_file_out_stream+0x8>
  2103d7:	48 8d 0d 62 bc 03 00 	lea    rcx,[rip+0x3bc62]        # 24c040 <stderr_file_out_stream+0x8>
  2103de:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  2103e1:	48 89 15 20 0c 04 00 	mov    QWORD PTR [rip+0x40c20],rdx        # 251008 <stderr_stream>
  2103e8:	48 89 c1             	mov    rcx,rax
  2103eb:	48 89 d7             	mov    rdi,rdx
  2103ee:	c6 44 24 0f 20       	mov    BYTE PTR [rsp+0xf],0x20
  2103f3:	4c 89 74 24 10       	mov    QWORD PTR [rsp+0x10],r14
  2103f8:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  2103ff:	00 00 
  210401:	4c 89 ee             	mov    rsi,r13
  210404:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  210406:	31 c0                	xor    eax,eax
  210408:	86 05 02 0c 04 00    	xchg   BYTE PTR [rip+0x40c02],al        # 251010 <stderr_mutex>
  21040e:	3c 01                	cmp    al,0x1
    if (!ok) {
  210410:	0f 85 20 02 00 00    	jne    210636 <BmPoor.add+0xd26>
  210416:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  21041d:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  210420:	b0 01                	mov    al,0x1
  210422:	86 05 e8 0b 04 00    	xchg   BYTE PTR [rip+0x40be8],al        # 251010 <stderr_mutex>
  210428:	84 c0                	test   al,al
  21042a:	75 f4                	jne    210420 <BmPoor.add+0xb10>
    if (stderr_stream) |st| {
  21042c:	48 8b 3d d5 0b 04 00 	mov    rdi,QWORD PTR [rip+0x40bd5]        # 251008 <stderr_stream>
  210433:	48 85 ff             	test   rdi,rdi
  210436:	74 09                	je     210441 <BmPoor.add+0xb31>
  210438:	48 8b 0d 01 bc 03 00 	mov    rcx,QWORD PTR [rip+0x3bc01]        # 24c040 <stderr_file_out_stream+0x8>
  21043f:	eb 3d                	jmp    21047e <BmPoor.add+0xb6e>
        stderr_file = try io.getStdErr();
  210441:	c7 05 e5 bb 03 00 02 	mov    DWORD PTR [rip+0x3bbe5],0x2        # 24c030 <stderr_file>
  210448:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  21044b:	48 8d 05 de bb 03 00 	lea    rax,[rip+0x3bbde]        # 24c030 <stderr_file>
  210452:	48 89 05 df bb 03 00 	mov    QWORD PTR [rip+0x3bbdf],rax        # 24c038 <stderr_file_out_stream>
  210459:	48 8d 05 40 ea 00 00 	lea    rax,[rip+0xea40]        # 21eea0 <FileOutStream_writeFn>
  210460:	48 89 05 d9 bb 03 00 	mov    QWORD PTR [rip+0x3bbd9],rax        # 24c040 <stderr_file_out_stream+0x8>
  210467:	48 8d 0d d2 bb 03 00 	lea    rcx,[rip+0x3bbd2]        # 24c040 <stderr_file_out_stream+0x8>
  21046e:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  210471:	48 89 15 90 0b 04 00 	mov    QWORD PTR [rip+0x40b90],rdx        # 251008 <stderr_stream>
  210478:	48 89 c1             	mov    rcx,rax
  21047b:	48 89 d7             	mov    rdi,rdx
                const casted_value = ([]const u8)(value);
  21047e:	4c 89 7c 24 10       	mov    QWORD PTR [rsp+0x10],r15
  210483:	48 c7 44 24 18 04 00 	mov    QWORD PTR [rsp+0x18],0x4
  21048a:	00 00 
                return output(context, casted_value);
  21048c:	4c 89 ee             	mov    rsi,r13
  21048f:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  210491:	31 c0                	xor    eax,eax
  210493:	86 05 77 0b 04 00    	xchg   BYTE PTR [rip+0x40b77],al        # 251010 <stderr_mutex>
  210499:	3c 01                	cmp    al,0x1
    if (!ok) {
  21049b:	0f 85 95 01 00 00    	jne    210636 <BmPoor.add+0xd26>
                try rightJustified(18, "{}", "time/operation");
  2104a1:	e8 7a 54 00 00       	call   215920 <Benchmark_rightJustified.39>
  2104a6:	66 85 c0             	test   ax,ax
  2104a9:	0f 85 6f 01 00 00    	jne    21061e <BmPoor.add+0xd0e>
  2104af:	90                   	nop
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  2104b0:	b0 01                	mov    al,0x1
  2104b2:	86 05 58 0b 04 00    	xchg   BYTE PTR [rip+0x40b58],al        # 251010 <stderr_mutex>
  2104b8:	84 c0                	test   al,al
  2104ba:	75 f4                	jne    2104b0 <BmPoor.add+0xba0>
    if (stderr_stream) |st| {
  2104bc:	48 8b 3d 45 0b 04 00 	mov    rdi,QWORD PTR [rip+0x40b45]        # 251008 <stderr_stream>
  2104c3:	48 85 ff             	test   rdi,rdi
  2104c6:	74 09                	je     2104d1 <BmPoor.add+0xbc1>
  2104c8:	48 8b 0d 71 bb 03 00 	mov    rcx,QWORD PTR [rip+0x3bb71]        # 24c040 <stderr_file_out_stream+0x8>
  2104cf:	eb 3d                	jmp    21050e <BmPoor.add+0xbfe>
        stderr_file = try io.getStdErr();
  2104d1:	c7 05 55 bb 03 00 02 	mov    DWORD PTR [rip+0x3bb55],0x2        # 24c030 <stderr_file>
  2104d8:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  2104db:	48 8d 05 4e bb 03 00 	lea    rax,[rip+0x3bb4e]        # 24c030 <stderr_file>
  2104e2:	48 89 05 4f bb 03 00 	mov    QWORD PTR [rip+0x3bb4f],rax        # 24c038 <stderr_file_out_stream>
  2104e9:	48 8d 05 b0 e9 00 00 	lea    rax,[rip+0xe9b0]        # 21eea0 <FileOutStream_writeFn>
  2104f0:	48 89 05 49 bb 03 00 	mov    QWORD PTR [rip+0x3bb49],rax        # 24c040 <stderr_file_out_stream+0x8>
  2104f7:	48 8d 0d 42 bb 03 00 	lea    rcx,[rip+0x3bb42]        # 24c040 <stderr_file_out_stream+0x8>
  2104fe:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  210501:	48 89 15 00 0b 04 00 	mov    QWORD PTR [rip+0x40b00],rdx        # 251008 <stderr_stream>
  210508:	48 89 c1             	mov    rcx,rax
  21050b:	48 89 d7             	mov    rdi,rdx
        try output(context, fmt[start_index..]);
  21050e:	48 8d 35 db f9 03 00 	lea    rsi,[rip+0x3f9db]        # 24fef0 <__unnamed_3>
  210515:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  210517:	31 c0                	xor    eax,eax
  210519:	86 05 f1 0a 04 00    	xchg   BYTE PTR [rip+0x40af1],al        # 251010 <stderr_mutex>
  21051f:	3c 01                	cmp    al,0x1
    if (!ok) {
  210521:	0f 85 0f 01 00 00    	jne    210636 <BmPoor.add+0xd26>
            try pSelf.report(pSelf.results.items[pSelf.results.len - 1]); warn("\n");
  210527:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  21052e:	00 
  21052f:	48 8b 8c 24 b8 00 00 	mov    rcx,QWORD PTR [rsp+0xb8]
  210536:	00 
  210537:	48 c1 e1 04          	shl    rcx,0x4
  21053b:	48 8d 34 08          	lea    rsi,[rax+rcx*1]
  21053f:	48 83 c6 f0          	add    rsi,0xfffffffffffffff0
  210543:	48 8d 7c 24 60       	lea    rdi,[rsp+0x60]
  210548:	e8 d3 29 00 00       	call   212f20 <Benchmark_report>
  21054d:	66 85 c0             	test   ax,ax
  210550:	0f 85 c8 00 00 00    	jne    21061e <BmPoor.add+0xd0e>
  210556:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  21055d:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  210560:	b0 01                	mov    al,0x1
  210562:	86 05 a8 0a 04 00    	xchg   BYTE PTR [rip+0x40aa8],al        # 251010 <stderr_mutex>
  210568:	84 c0                	test   al,al
  21056a:	75 f4                	jne    210560 <BmPoor.add+0xc50>
    if (stderr_stream) |st| {
  21056c:	48 8b 3d 95 0a 04 00 	mov    rdi,QWORD PTR [rip+0x40a95]        # 251008 <stderr_stream>
  210573:	48 85 ff             	test   rdi,rdi
  210576:	74 09                	je     210581 <BmPoor.add+0xc71>
  210578:	48 8b 0d c1 ba 03 00 	mov    rcx,QWORD PTR [rip+0x3bac1]        # 24c040 <stderr_file_out_stream+0x8>
  21057f:	eb 3d                	jmp    2105be <BmPoor.add+0xcae>
        stderr_file = try io.getStdErr();
  210581:	c7 05 a5 ba 03 00 02 	mov    DWORD PTR [rip+0x3baa5],0x2        # 24c030 <stderr_file>
  210588:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  21058b:	48 8d 05 9e ba 03 00 	lea    rax,[rip+0x3ba9e]        # 24c030 <stderr_file>
  210592:	48 89 05 9f ba 03 00 	mov    QWORD PTR [rip+0x3ba9f],rax        # 24c038 <stderr_file_out_stream>
  210599:	48 8d 05 00 e9 00 00 	lea    rax,[rip+0xe900]        # 21eea0 <FileOutStream_writeFn>
  2105a0:	48 89 05 99 ba 03 00 	mov    QWORD PTR [rip+0x3ba99],rax        # 24c040 <stderr_file_out_stream+0x8>
  2105a7:	48 8d 0d 92 ba 03 00 	lea    rcx,[rip+0x3ba92]        # 24c040 <stderr_file_out_stream+0x8>
  2105ae:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  2105b1:	48 89 15 50 0a 04 00 	mov    QWORD PTR [rip+0x40a50],rdx        # 251008 <stderr_stream>
  2105b8:	48 89 c1             	mov    rcx,rax
  2105bb:	48 89 d7             	mov    rdi,rdx
  2105be:	4c 8b 6c 24 28       	mov    r13,QWORD PTR [rsp+0x28]
  2105c3:	48 8d 35 26 f9 03 00 	lea    rsi,[rip+0x3f926]        # 24fef0 <__unnamed_3>
  2105ca:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  2105cc:	31 c0                	xor    eax,eax
  2105ce:	86 05 3c 0a 04 00    	xchg   BYTE PTR [rip+0x40a3c],al        # 251010 <stderr_mutex>
  2105d4:	3c 01                	cmp    al,0x1
    if (!ok) {
  2105d6:	75 5e                	jne    210636 <BmPoor.add+0xd26>
  2105d8:	49 83 c5 01          	add    r13,0x1
  2105dc:	31 c0                	xor    eax,eax
  2105de:	4d 89 e6             	mov    r14,r12
        while (rep < pSelf.repetitions) : (rep += 1) {
  2105e1:	4c 3b ac 24 80 00 00 	cmp    r13,QWORD PTR [rsp+0x80]
  2105e8:	00 
  2105e9:	c5 f8 10 0d 1f fd fe 	vmovups xmm1,XMMWORD PTR [rip+0xfffffffffffefd1f]        # 200310 <__unnamed_35>
  2105f0:	ff 
  2105f1:	4c 89 fe             	mov    rsi,r15
  2105f4:	0f 82 3f f4 ff ff    	jb     20fa39 <BmPoor.add+0x129>
  2105fa:	48 8d 7c 24 60       	lea    rdi,[rsp+0x60]
        try pSelf.reportStats(pSelf.results);
  2105ff:	48 8d b4 24 a8 00 00 	lea    rsi,[rsp+0xa8]
  210606:	00 
  210607:	e8 f4 55 00 00       	call   215c00 <Benchmark_reportStats>
  21060c:	eb 10                	jmp    21061e <BmPoor.add+0xd0e>
                switch (errno) {
  21060e:	48 83 f9 16          	cmp    rcx,0x16
  210612:	75 06                	jne    21061a <BmPoor.add+0xd0a>
  210614:	66 b8 02 00          	mov    ax,0x2
  210618:	eb 04                	jmp    21061e <BmPoor.add+0xd0e>
  21061a:	66 b8 03 00          	mov    ax,0x3
    _ = try bm.run(BmAdd);
  21061e:	48 81 c4 08 01 00 00 	add    rsp,0x108
  210625:	5b                   	pop    rbx
  210626:	41 5c                	pop    r12
  210628:	41 5d                	pop    r13
  21062a:	41 5e                	pop    r14
  21062c:	41 5f                	pop    r15
  21062e:	5d                   	pop    rbp
  21062f:	c3                   	ret    
  210630:	66 b8 06 00          	mov    ax,0x6
  210634:	eb e8                	jmp    21061e <BmPoor.add+0xd0e>
            @panic("assertion failure");
  210636:	48 8d 3d 53 f7 03 00 	lea    rdi,[rip+0x3f753]        # 24fd90 <__unnamed_2>
  21063d:	e8 de 20 00 00       	call   212720 <panic>
  210642:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  210649:	1f 84 00 00 00 00 00 

0000000000210650 <Bm.AtomicRmwOp.Add>:
}

// Measure @atomicRmw Add operation
test "Bm.AtomicRmwOp.Add" {
  210650:	55                   	push   rbp
  210651:	41 57                	push   r15
  210653:	41 56                	push   r14
  210655:	41 55                	push   r13
  210657:	41 54                	push   r12
  210659:	53                   	push   rbx
  21065a:	48 81 ec f8 00 00 00 	sub    rsp,0xf8
  210661:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  210668:	0f 1f 84 00 00 00 00 
  21066f:	00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  210670:	b0 01                	mov    al,0x1
  210672:	86 05 98 09 04 00    	xchg   BYTE PTR [rip+0x40998],al        # 251010 <stderr_mutex>
  210678:	84 c0                	test   al,al
  21067a:	75 f4                	jne    210670 <Bm.AtomicRmwOp.Add+0x20>
    if (stderr_stream) |st| {
  21067c:	48 8b 3d 85 09 04 00 	mov    rdi,QWORD PTR [rip+0x40985]        # 251008 <stderr_stream>
  210683:	48 85 ff             	test   rdi,rdi
  210686:	74 09                	je     210691 <Bm.AtomicRmwOp.Add+0x41>
  210688:	48 8b 05 b1 b9 03 00 	mov    rax,QWORD PTR [rip+0x3b9b1]        # 24c040 <stderr_file_out_stream+0x8>
  21068f:	eb 34                	jmp    2106c5 <Bm.AtomicRmwOp.Add+0x75>
        stderr_file = try io.getStdErr();
  210691:	48 8d 05 98 b9 03 00 	lea    rax,[rip+0x3b998]        # 24c030 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  210698:	48 89 05 99 b9 03 00 	mov    QWORD PTR [rip+0x3b999],rax        # 24c038 <stderr_file_out_stream>
  21069f:	48 8d 05 fa e7 00 00 	lea    rax,[rip+0xe7fa]        # 21eea0 <FileOutStream_writeFn>
  2106a6:	48 89 05 93 b9 03 00 	mov    QWORD PTR [rip+0x3b993],rax        # 24c040 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  2106ad:	c7 05 79 b9 03 00 02 	mov    DWORD PTR [rip+0x3b979],0x2        # 24c030 <stderr_file>
  2106b4:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  2106b7:	48 8d 3d 82 b9 03 00 	lea    rdi,[rip+0x3b982]        # 24c040 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  2106be:	48 89 3d 43 09 04 00 	mov    QWORD PTR [rip+0x40943],rdi        # 251008 <stderr_stream>
  2106c5:	48 8d 35 24 f8 03 00 	lea    rsi,[rip+0x3f824]        # 24fef0 <__unnamed_3>
  2106cc:	ff d0                	call   rax
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  2106ce:	31 c0                	xor    eax,eax
  2106d0:	86 05 3a 09 04 00    	xchg   BYTE PTR [rip+0x4093a],al        # 251010 <stderr_mutex>
  2106d6:	3c 01                	cmp    al,0x1
    if (!ok) {
  2106d8:	0f 85 06 0b 00 00    	jne    2111e4 <Bm.AtomicRmwOp.Add+0xb94>
    // Since this is a test print a \n before we run
    warn("\n");

    // Test fn benchmark(pSelf) can return an error
    var bm = Benchmark.init("Bm.AtomicRmwOp.Add", std.debug.global_allocator);
  2106de:	c5 f8 10 05 7a f6 03 	vmovups xmm0,XMMWORD PTR [rip+0x3f67a]        # 24fd60 <__unnamed_15>
  2106e5:	00 
  2106e6:	c5 f8 29 44 24 20    	vmovaps XMMWORD PTR [rsp+0x20],xmm0
  2106ec:	48 b8 00 e8 76 48 17 	movabs rax,0x174876e800
  2106f3:	00 00 00 
  2106f6:	b9 00 65 cd 1d       	mov    ecx,0x1dcd6500
  2106fb:	c4 e1 f9 6e c1       	vmovq  xmm0,rcx
  210700:	c5 f9 73 f8 08       	vpslldq xmm0,xmm0,0x8
  210705:	c5 f9 7f 44 24 30    	vmovdqa XMMWORD PTR [rsp+0x30],xmm0
  21070b:	48 89 44 24 48       	mov    QWORD PTR [rsp+0x48],rax
  210710:	c5 fa 6f 05 f8 fb fe 	vmovdqu xmm0,XMMWORD PTR [rip+0xfffffffffffefbf8]        # 200310 <__unnamed_35>
  210717:	ff 
  210718:	c5 f9 7f 44 24 50    	vmovdqa XMMWORD PTR [rsp+0x50],xmm0
  21071e:	48 8d 0d db b8 03 00 	lea    rcx,[rip+0x3b8db]        # 24c000 <global_fixed_allocator>
  210725:	48 89 4c 24 60       	mov    QWORD PTR [rsp+0x60],rcx
  21072a:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  21072e:	c5 fa 7f 44 24 68    	vmovdqu XMMWORD PTR [rsp+0x68],xmm0
  210734:	48 c7 44 24 78 00 00 	mov    QWORD PTR [rsp+0x78],0x0
  21073b:	00 00 
  21073d:	48 89 8c 24 80 00 00 	mov    QWORD PTR [rsp+0x80],rcx
  210744:	00 
        fn benchmark(pSelf: *Self) void {
            _ = @atomicRmw(u64, &pSelf.benchmark_count, AtomicRmwOp.Add, 1, AtomicOrder.Release);
        }
    };

    bm.repetitions = 10;
  210745:	48 c7 44 24 40 0a 00 	mov    QWORD PTR [rsp+0x40],0xa
  21074c:	00 00 
                bm = T.init();
  21074e:	48 c7 44 24 08 00 00 	mov    QWORD PTR [rsp+0x8],0x0
  210755:	00 00 
  210757:	41 b6 01             	mov    r14b,0x1
  21075a:	bb 01 00 00 00       	mov    ebx,0x1
  21075f:	4c 8d a4 24 90 00 00 	lea    r12,[rsp+0x90]
  210766:	00 
  210767:	48 8d 2d 82 f7 03 00 	lea    rbp,[rip+0x3f782]        # 24fef0 <__unnamed_3>
  21076e:	45 31 ed             	xor    r13d,r13d
            while (iterations <= pSelf.max_iterations) {
  210771:	48 39 c3             	cmp    rbx,rax
  210774:	0f 87 86 03 00 00    	ja     210b00 <Bm.AtomicRmwOp.Add+0x4b0>
  21077a:	eb 0f                	jmp    21078b <Bm.AtomicRmwOp.Add+0x13b>
  21077c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
                        warn("iteratons:{} numer:{} denom:{}\n", iterations, numer, denom);
  210780:	48 89 df             	mov    rdi,rbx
  210783:	48 89 ca             	mov    rdx,rcx
  210786:	e8 a5 48 00 00       	call   215030 <warn.37>
                var ts: posix.timespec = undefined;
  21078b:	c5 fa 6f 05 7d fb fe 	vmovdqu xmm0,XMMWORD PTR [rip+0xfffffffffffefb7d]        # 200310 <__unnamed_35>
  210792:	ff 
  210793:	c5 f9 7f 84 24 90 00 	vmovdqa XMMWORD PTR [rsp+0x90],xmm0
  21079a:	00 00 
  21079c:	b8 e5 00 00 00       	mov    eax,0xe5
  2107a1:	bf 01 00 00 00       	mov    edi,0x1
  2107a6:	4c 89 e6             	mov    rsi,r12
  2107a9:	0f 05                	syscall 
  2107ab:	48 89 c1             	mov    rcx,rax
  2107ae:	48 f7 d9             	neg    rcx
  2107b1:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  2107b7:	b8 00 00 00 00       	mov    eax,0x0
  2107bc:	48 0f 46 c8          	cmovbe rcx,rax
                switch (errno) {
  2107c0:	48 85 c9             	test   rcx,rcx
  2107c3:	0f 85 f9 09 00 00    	jne    2111c2 <Bm.AtomicRmwOp.Add+0xb72>
        const f = @atomicLoad(@typeOf(init_vdso_clock_gettime), &vdso_clock_gettime, builtin.AtomicOrder.Unordered);
  2107c9:	48 8b 05 48 b9 03 00 	mov    rax,QWORD PTR [rip+0x3b948]        # 24c118 <vdso_clock_gettime>
        if (@ptrToInt(f) != 0) {
  2107d0:	48 85 c0             	test   rax,rax
  2107d3:	74 21                	je     2107f6 <Bm.AtomicRmwOp.Add+0x1a6>
            const rc = f(clk_id, tp);
  2107d5:	bf 01 00 00 00       	mov    edi,0x1
  2107da:	4c 89 e6             	mov    rsi,r12
  2107dd:	ff d0                	call   rax
            switch (rc) {
  2107df:	48 83 f8 ea          	cmp    rax,0xffffffffffffffea
  2107e3:	0f 84 a7 02 00 00    	je     210a90 <Bm.AtomicRmwOp.Add+0x440>
  2107e9:	48 85 c0             	test   rax,rax
  2107ec:	c5 fa 6f 05 1c fb fe 	vmovdqu xmm0,XMMWORD PTR [rip+0xfffffffffffefb1c]        # 200310 <__unnamed_35>
  2107f3:	ff 
  2107f4:	74 0f                	je     210805 <Bm.AtomicRmwOp.Add+0x1b5>
  2107f6:	b8 e4 00 00 00       	mov    eax,0xe4
  2107fb:	bf 01 00 00 00       	mov    edi,0x1
  210800:	4c 89 e6             	mov    rsi,r12
  210803:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  210805:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
                if (errno != 0) return std.os.unexpectedErrorPosix(errno);
  21080b:	0f 83 bd 09 00 00    	jae    2111ce <Bm.AtomicRmwOp.Add+0xb7e>
                self.start_time = @intCast(u64, ts.tv_sec) * u64(ns_per_s) + @intCast(u64, ts.tv_nsec);
  210811:	c5 f9 6f 8c 24 90 00 	vmovdqa xmm1,XMMWORD PTR [rsp+0x90]
  210818:	00 00 
        while (iter > 0) : (iter -= 1) {
  21081a:	48 85 db             	test   rbx,rbx
  21081d:	0f 84 93 00 00 00    	je     2108b6 <Bm.AtomicRmwOp.Add+0x266>
            _ = @atomicRmw(u64, &pSelf.benchmark_count, AtomicRmwOp.Add, 1, AtomicOrder.Release);
  210823:	48 8d 4b ff          	lea    rcx,[rbx-0x1]
  210827:	48 89 da             	mov    rdx,rbx
  21082a:	48 89 d8             	mov    rax,rbx
  21082d:	48 83 e2 07          	and    rdx,0x7
  210831:	74 21                	je     210854 <Bm.AtomicRmwOp.Add+0x204>
  210833:	48 f7 da             	neg    rdx
  210836:	48 89 d8             	mov    rax,rbx
  210839:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  210840:	f0 48 81 44 24 08 01 	lock add QWORD PTR [rsp+0x8],0x1
  210847:	00 00 00 
        while (iter > 0) : (iter -= 1) {
  21084a:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  21084e:	48 83 c2 01          	add    rdx,0x1
  210852:	75 ec                	jne    210840 <Bm.AtomicRmwOp.Add+0x1f0>
            _ = @atomicRmw(u64, &pSelf.benchmark_count, AtomicRmwOp.Add, 1, AtomicOrder.Release);
  210854:	48 83 f9 07          	cmp    rcx,0x7
  210858:	72 5c                	jb     2108b6 <Bm.AtomicRmwOp.Add+0x266>
  21085a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  210860:	f0 48 81 44 24 08 01 	lock add QWORD PTR [rsp+0x8],0x1
  210867:	00 00 00 
  21086a:	f0 48 81 44 24 08 01 	lock add QWORD PTR [rsp+0x8],0x1
  210871:	00 00 00 
  210874:	f0 48 81 44 24 08 01 	lock add QWORD PTR [rsp+0x8],0x1
  21087b:	00 00 00 
  21087e:	f0 48 81 44 24 08 01 	lock add QWORD PTR [rsp+0x8],0x1
  210885:	00 00 00 
  210888:	f0 48 81 44 24 08 01 	lock add QWORD PTR [rsp+0x8],0x1
  21088f:	00 00 00 
  210892:	f0 48 81 44 24 08 01 	lock add QWORD PTR [rsp+0x8],0x1
  210899:	00 00 00 
  21089c:	f0 48 81 44 24 08 01 	lock add QWORD PTR [rsp+0x8],0x1
  2108a3:	00 00 00 
  2108a6:	f0 48 81 44 24 08 01 	lock add QWORD PTR [rsp+0x8],0x1
  2108ad:	00 00 00 
        while (iter > 0) : (iter -= 1) {
  2108b0:	48 83 c0 f8          	add    rax,0xfffffffffffffff8
  2108b4:	75 aa                	jne    210860 <Bm.AtomicRmwOp.Add+0x210>
        var ts: posix.timespec = undefined;
  2108b6:	c5 f9 7f 84 24 90 00 	vmovdqa XMMWORD PTR [rsp+0x90],xmm0
  2108bd:	00 00 
        const f = @atomicLoad(@typeOf(init_vdso_clock_gettime), &vdso_clock_gettime, builtin.AtomicOrder.Unordered);
  2108bf:	48 8b 05 52 b8 03 00 	mov    rax,QWORD PTR [rip+0x3b852]        # 24c118 <vdso_clock_gettime>
        if (@ptrToInt(f) != 0) {
  2108c6:	48 85 c0             	test   rax,rax
  2108c9:	74 2b                	je     2108f6 <Bm.AtomicRmwOp.Add+0x2a6>
  2108cb:	c5 f9 7f 8c 24 c0 00 	vmovdqa XMMWORD PTR [rsp+0xc0],xmm1
  2108d2:	00 00 
            const rc = f(clk_id, tp);
  2108d4:	bf 01 00 00 00       	mov    edi,0x1
  2108d9:	4c 89 e6             	mov    rsi,r12
  2108dc:	ff d0                	call   rax
            switch (rc) {
  2108de:	48 83 f8 ea          	cmp    rax,0xffffffffffffffea
  2108e2:	0f 84 c1 01 00 00    	je     210aa9 <Bm.AtomicRmwOp.Add+0x459>
  2108e8:	48 85 c0             	test   rax,rax
  2108eb:	c5 f9 6f 8c 24 c0 00 	vmovdqa xmm1,XMMWORD PTR [rsp+0xc0]
  2108f2:	00 00 
  2108f4:	74 0f                	je     210905 <Bm.AtomicRmwOp.Add+0x2b5>
  2108f6:	b8 e4 00 00 00       	mov    eax,0xe4
  2108fb:	bf 01 00 00 00       	mov    edi,0x1
  210900:	4c 89 e6             	mov    rsi,r12
  210903:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  210905:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
  21090b:	0f 83 d3 08 00 00    	jae    2111e4 <Bm.AtomicRmwOp.Add+0xb94>
        return @intCast(u64, ts.tv_sec) * u64(ns_per_s) + @intCast(u64, ts.tv_nsec);
  210911:	c5 f9 6f 84 24 90 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x90]
  210918:	00 00 
  21091a:	c5 f9 fb c1          	vpsubq xmm0,xmm0,xmm1
  21091e:	c4 e1 f9 7e c0       	vmovq  rax,xmm0
        var clock = clockNative() - self.start_time;
  210923:	c4 c3 f9 16 c7 01    	vpextrq r15,xmm0,0x1
  210929:	48 69 c0 00 ca 9a 3b 	imul   rax,rax,0x3b9aca00
  210930:	49 01 c7             	add    r15,rax
                if ((run_time_ns >= pSelf.min_runtime_ns) or (iterations >= pSelf.max_iterations)) {
  210933:	4c 3b 7c 24 38       	cmp    r15,QWORD PTR [rsp+0x38]
  210938:	0f 83 85 01 00 00    	jae    210ac3 <Bm.AtomicRmwOp.Add+0x473>
  21093e:	48 3b 5c 24 48       	cmp    rbx,QWORD PTR [rsp+0x48]
  210943:	0f 83 7a 01 00 00    	jae    210ac3 <Bm.AtomicRmwOp.Add+0x473>
                    if (pSelf.logl >= 1) {
  210949:	48 83 7c 24 30 00    	cmp    QWORD PTR [rsp+0x30],0x0
  21094f:	0f 84 ad 00 00 00    	je     210a02 <Bm.AtomicRmwOp.Add+0x3b2>
                            Result {.run_time_ns = run_time_ns, .iterations = iterations});
  210955:	4c 89 bc 24 d8 00 00 	mov    QWORD PTR [rsp+0xd8],r15
  21095c:	00 
  21095d:	48 89 9c 24 e0 00 00 	mov    QWORD PTR [rsp+0xe0],rbx
  210964:	00 
                        try pSelf.report(
  210965:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  21096a:	48 8d b4 24 d8 00 00 	lea    rsi,[rsp+0xd8]
  210971:	00 
  210972:	e8 a9 25 00 00       	call   212f20 <Benchmark_report>
  210977:	66 85 c0             	test   ax,ax
  21097a:	0f 85 52 08 00 00    	jne    2111d2 <Bm.AtomicRmwOp.Add+0xb82>
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  210980:	b0 01                	mov    al,0x1
  210982:	86 05 88 06 04 00    	xchg   BYTE PTR [rip+0x40688],al        # 251010 <stderr_mutex>
  210988:	84 c0                	test   al,al
  21098a:	75 f4                	jne    210980 <Bm.AtomicRmwOp.Add+0x330>
    if (stderr_stream) |st| {
  21098c:	48 8b 3d 75 06 04 00 	mov    rdi,QWORD PTR [rip+0x40675]        # 251008 <stderr_stream>
  210993:	48 85 ff             	test   rdi,rdi
  210996:	74 18                	je     2109b0 <Bm.AtomicRmwOp.Add+0x360>
  210998:	48 8b 0d a1 b6 03 00 	mov    rcx,QWORD PTR [rip+0x3b6a1]        # 24c040 <stderr_file_out_stream+0x8>
  21099f:	eb 4c                	jmp    2109ed <Bm.AtomicRmwOp.Add+0x39d>
  2109a1:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  2109a8:	0f 1f 84 00 00 00 00 
  2109af:	00 
        stderr_file = try io.getStdErr();
  2109b0:	c7 05 76 b6 03 00 02 	mov    DWORD PTR [rip+0x3b676],0x2        # 24c030 <stderr_file>
  2109b7:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  2109ba:	48 8d 05 6f b6 03 00 	lea    rax,[rip+0x3b66f]        # 24c030 <stderr_file>
  2109c1:	48 89 05 70 b6 03 00 	mov    QWORD PTR [rip+0x3b670],rax        # 24c038 <stderr_file_out_stream>
  2109c8:	48 8d 05 d1 e4 00 00 	lea    rax,[rip+0xe4d1]        # 21eea0 <FileOutStream_writeFn>
  2109cf:	48 89 05 6a b6 03 00 	mov    QWORD PTR [rip+0x3b66a],rax        # 24c040 <stderr_file_out_stream+0x8>
  2109d6:	48 8d 0d 63 b6 03 00 	lea    rcx,[rip+0x3b663]        # 24c040 <stderr_file_out_stream+0x8>
  2109dd:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  2109e0:	48 89 15 21 06 04 00 	mov    QWORD PTR [rip+0x40621],rdx        # 251008 <stderr_stream>
  2109e7:	48 89 c1             	mov    rcx,rax
  2109ea:	48 89 d7             	mov    rdi,rdx
  2109ed:	48 89 ee             	mov    rsi,rbp
  2109f0:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  2109f2:	31 c0                	xor    eax,eax
  2109f4:	86 05 16 06 04 00    	xchg   BYTE PTR [rip+0x40616],al        # 251010 <stderr_mutex>
  2109fa:	3c 01                	cmp    al,0x1
    if (!ok) {
  2109fc:	0f 85 e2 07 00 00    	jne    2111e4 <Bm.AtomicRmwOp.Add+0xb94>
                    if (run_time_ns < 1000) {
  210a02:	49 81 ff e8 03 00 00 	cmp    r15,0x3e8
  210a09:	73 25                	jae    210a30 <Bm.AtomicRmwOp.Add+0x3e0>
  210a0b:	b9 01 00 00 00       	mov    ecx,0x1
  210a10:	be e8 03 00 00       	mov    esi,0x3e8
                    iterations = (iterations * numer) / denom;
  210a15:	48 0f af de          	imul   rbx,rsi
  210a19:	48 89 d8             	mov    rax,rbx
  210a1c:	48 c1 e8 20          	shr    rax,0x20
  210a20:	74 48                	je     210a6a <Bm.AtomicRmwOp.Add+0x41a>
  210a22:	31 d2                	xor    edx,edx
  210a24:	48 89 d8             	mov    rax,rbx
  210a27:	48 f7 f1             	div    rcx
  210a2a:	48 89 c3             	mov    rbx,rax
  210a2d:	eb 43                	jmp    210a72 <Bm.AtomicRmwOp.Add+0x422>
  210a2f:	90                   	nop
                    } else if (run_time_ns < (pSelf.min_runtime_ns / 10)) {
  210a30:	48 ba cd cc cc cc cc 	movabs rdx,0xcccccccccccccccd
  210a37:	cc cc cc 
  210a3a:	c4 e2 fb f6 4c 24 38 	mulx   rcx,rax,QWORD PTR [rsp+0x38]
  210a41:	48 c1 e9 03          	shr    rcx,0x3
  210a45:	31 c0                	xor    eax,eax
  210a47:	49 39 cf             	cmp    r15,rcx
  210a4a:	0f 93 c0             	setae  al
  210a4d:	48 8d 0c c0          	lea    rcx,[rax+rax*8]
  210a51:	48 83 c1 01          	add    rcx,0x1
  210a55:	48 8d 34 85 0a 00 00 	lea    rsi,[rax*4+0xa]
  210a5c:	00 
                    iterations = (iterations * numer) / denom;
  210a5d:	48 0f af de          	imul   rbx,rsi
  210a61:	48 89 d8             	mov    rax,rbx
  210a64:	48 c1 e8 20          	shr    rax,0x20
  210a68:	75 b8                	jne    210a22 <Bm.AtomicRmwOp.Add+0x3d2>
  210a6a:	31 d2                	xor    edx,edx
  210a6c:	89 d8                	mov    eax,ebx
  210a6e:	f7 f1                	div    ecx
  210a70:	89 c3                	mov    ebx,eax
                    if (iterations > pSelf.max_iterations) {
  210a72:	48 8b 44 24 48       	mov    rax,QWORD PTR [rsp+0x48]
  210a77:	48 39 c3             	cmp    rbx,rax
  210a7a:	48 0f 47 d8          	cmova  rbx,rax
                    if (pSelf.logl >= 2) {
  210a7e:	48 83 7c 24 30 02    	cmp    QWORD PTR [rsp+0x30],0x2
  210a84:	0f 82 01 fd ff ff    	jb     21078b <Bm.AtomicRmwOp.Add+0x13b>
  210a8a:	e9 f1 fc ff ff       	jmp    210780 <Bm.AtomicRmwOp.Add+0x130>
  210a8f:	90                   	nop
  210a90:	c5 fa 6f 05 78 f8 fe 	vmovdqu xmm0,XMMWORD PTR [rip+0xfffffffffffef878]        # 200310 <__unnamed_35>
  210a97:	ff 
  210a98:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
                if (errno != 0) return std.os.unexpectedErrorPosix(errno);
  210a9e:	0f 82 6d fd ff ff    	jb     210811 <Bm.AtomicRmwOp.Add+0x1c1>
  210aa4:	e9 25 07 00 00       	jmp    2111ce <Bm.AtomicRmwOp.Add+0xb7e>
  210aa9:	c5 f9 6f 8c 24 c0 00 	vmovdqa xmm1,XMMWORD PTR [rsp+0xc0]
  210ab0:	00 00 
  210ab2:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
  210ab8:	0f 82 53 fe ff ff    	jb     210911 <Bm.AtomicRmwOp.Add+0x2c1>
  210abe:	e9 21 07 00 00       	jmp    2111e4 <Bm.AtomicRmwOp.Add+0xb94>
                            Result { .run_time_ns = run_time_ns, .iterations = iterations});
  210ac3:	4c 89 bc 24 e8 00 00 	mov    QWORD PTR [rsp+0xe8],r15
  210aca:	00 
  210acb:	48 89 9c 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rbx
  210ad2:	00 
                    try pSelf.results.append(
  210ad3:	48 8d 7c 24 68       	lea    rdi,[rsp+0x68]
  210ad8:	48 8d b4 24 e8 00 00 	lea    rsi,[rsp+0xe8]
  210adf:	00 
  210ae0:	e8 cb 22 00 00       	call   212db0 <AlignedArrayList(Result,8)_append>
  210ae5:	66 85 c0             	test   ax,ax
  210ae8:	74 16                	je     210b00 <Bm.AtomicRmwOp.Add+0x4b0>
  210aea:	e9 e3 06 00 00       	jmp    2111d2 <Bm.AtomicRmwOp.Add+0xb82>
            while (iterations <= pSelf.max_iterations) {
  210aef:	48 8b 44 24 48       	mov    rax,QWORD PTR [rsp+0x48]
  210af4:	45 31 f6             	xor    r14d,r14d
  210af7:	48 39 c3             	cmp    rbx,rax
  210afa:	0f 86 8b fc ff ff    	jbe    21078b <Bm.AtomicRmwOp.Add+0x13b>
  210b00:	49 89 ef             	mov    r15,rbp
            if (once) {
  210b03:	41 f6 c6 01          	test   r14b,0x1
  210b07:	48 8d 6c 24 07       	lea    rbp,[rsp+0x7]
  210b0c:	4c 8d 74 24 10       	lea    r14,[rsp+0x10]
  210b11:	0f 84 ec 05 00 00    	je     211103 <Bm.AtomicRmwOp.Add+0xab3>
                try leftJustified(22, "name repetitions:{}", pSelf.repetitions);
  210b17:	48 8b 7c 24 40       	mov    rdi,QWORD PTR [rsp+0x40]
  210b1c:	e8 7f 48 00 00       	call   2153a0 <Benchmark_leftJustified>
  210b21:	66 85 c0             	test   ax,ax
  210b24:	0f 85 a8 06 00 00    	jne    2111d2 <Bm.AtomicRmwOp.Add+0xb82>
                try rightJustified(14, "{}", "iterations");
  210b2a:	e8 11 4b 00 00       	call   215640 <Benchmark_rightJustified>
  210b2f:	66 85 c0             	test   ax,ax
  210b32:	0f 85 9a 06 00 00    	jne    2111d2 <Bm.AtomicRmwOp.Add+0xb82>
        var buffer: [40]u8 = undefined;
  210b38:	c5 fe 6f 05 0f 54 ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffff540f]        # 205f4f <__unnamed_7>
  210b3f:	ff 
  210b40:	c5 fe 7f 84 24 90 00 	vmovdqu YMMWORD PTR [rsp+0x90],ymm0
  210b47:	00 00 
  210b49:	48 8b 05 1f 54 ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffff541f]        # 205f6f <__unnamed_7+0x20>
  210b50:	48 89 84 24 b0 00 00 	mov    QWORD PTR [rsp+0xb0],rax
  210b57:	00 
  210b58:	c7 84 24 90 00 00 00 	mov    DWORD PTR [rsp+0x90],0x656d6974
  210b5f:	74 69 6d 65 
  210b63:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  210b6a:	84 00 00 00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  210b70:	b0 01                	mov    al,0x1
  210b72:	86 05 98 04 04 00    	xchg   BYTE PTR [rip+0x40498],al        # 251010 <stderr_mutex>
  210b78:	84 c0                	test   al,al
  210b7a:	75 f4                	jne    210b70 <Bm.AtomicRmwOp.Add+0x520>
    if (stderr_stream) |st| {
  210b7c:	48 8b 3d 85 04 04 00 	mov    rdi,QWORD PTR [rip+0x40485]        # 251008 <stderr_stream>
  210b83:	48 85 ff             	test   rdi,rdi
  210b86:	74 09                	je     210b91 <Bm.AtomicRmwOp.Add+0x541>
  210b88:	48 8b 0d b1 b4 03 00 	mov    rcx,QWORD PTR [rip+0x3b4b1]        # 24c040 <stderr_file_out_stream+0x8>
  210b8f:	eb 3d                	jmp    210bce <Bm.AtomicRmwOp.Add+0x57e>
        stderr_file = try io.getStdErr();
  210b91:	c7 05 95 b4 03 00 02 	mov    DWORD PTR [rip+0x3b495],0x2        # 24c030 <stderr_file>
  210b98:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  210b9b:	48 8d 05 8e b4 03 00 	lea    rax,[rip+0x3b48e]        # 24c030 <stderr_file>
  210ba2:	48 89 05 8f b4 03 00 	mov    QWORD PTR [rip+0x3b48f],rax        # 24c038 <stderr_file_out_stream>
  210ba9:	48 8d 05 f0 e2 00 00 	lea    rax,[rip+0xe2f0]        # 21eea0 <FileOutStream_writeFn>
  210bb0:	48 89 05 89 b4 03 00 	mov    QWORD PTR [rip+0x3b489],rax        # 24c040 <stderr_file_out_stream+0x8>
  210bb7:	48 8d 0d 82 b4 03 00 	lea    rcx,[rip+0x3b482]        # 24c040 <stderr_file_out_stream+0x8>
  210bbe:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  210bc1:	48 89 15 40 04 04 00 	mov    QWORD PTR [rip+0x40440],rdx        # 251008 <stderr_stream>
  210bc8:	48 89 c1             	mov    rcx,rax
  210bcb:	48 89 d7             	mov    rdi,rdx
  210bce:	c6 44 24 07 20       	mov    BYTE PTR [rsp+0x7],0x20
    return output(context, (*[1]u8)(&c)[0..]);
  210bd3:	48 89 6c 24 10       	mov    QWORD PTR [rsp+0x10],rbp
  210bd8:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  210bdf:	00 00 
  210be1:	4c 89 f6             	mov    rsi,r14
  210be4:	c5 f8 77             	vzeroupper 
  210be7:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  210be9:	31 c0                	xor    eax,eax
  210beb:	86 05 1f 04 04 00    	xchg   BYTE PTR [rip+0x4041f],al        # 251010 <stderr_mutex>
  210bf1:	3c 01                	cmp    al,0x1
    if (!ok) {
  210bf3:	0f 85 eb 05 00 00    	jne    2111e4 <Bm.AtomicRmwOp.Add+0xb94>
  210bf9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  210c00:	b0 01                	mov    al,0x1
  210c02:	86 05 08 04 04 00    	xchg   BYTE PTR [rip+0x40408],al        # 251010 <stderr_mutex>
  210c08:	84 c0                	test   al,al
  210c0a:	75 f4                	jne    210c00 <Bm.AtomicRmwOp.Add+0x5b0>
    if (stderr_stream) |st| {
  210c0c:	48 8b 3d f5 03 04 00 	mov    rdi,QWORD PTR [rip+0x403f5]        # 251008 <stderr_stream>
  210c13:	48 85 ff             	test   rdi,rdi
  210c16:	74 09                	je     210c21 <Bm.AtomicRmwOp.Add+0x5d1>
  210c18:	48 8b 0d 21 b4 03 00 	mov    rcx,QWORD PTR [rip+0x3b421]        # 24c040 <stderr_file_out_stream+0x8>
  210c1f:	eb 3d                	jmp    210c5e <Bm.AtomicRmwOp.Add+0x60e>
        stderr_file = try io.getStdErr();
  210c21:	c7 05 05 b4 03 00 02 	mov    DWORD PTR [rip+0x3b405],0x2        # 24c030 <stderr_file>
  210c28:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  210c2b:	48 8d 05 fe b3 03 00 	lea    rax,[rip+0x3b3fe]        # 24c030 <stderr_file>
  210c32:	48 89 05 ff b3 03 00 	mov    QWORD PTR [rip+0x3b3ff],rax        # 24c038 <stderr_file_out_stream>
  210c39:	48 8d 05 60 e2 00 00 	lea    rax,[rip+0xe260]        # 21eea0 <FileOutStream_writeFn>
  210c40:	48 89 05 f9 b3 03 00 	mov    QWORD PTR [rip+0x3b3f9],rax        # 24c040 <stderr_file_out_stream+0x8>
  210c47:	48 8d 0d f2 b3 03 00 	lea    rcx,[rip+0x3b3f2]        # 24c040 <stderr_file_out_stream+0x8>
  210c4e:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  210c51:	48 89 15 b0 03 04 00 	mov    QWORD PTR [rip+0x403b0],rdx        # 251008 <stderr_stream>
  210c58:	48 89 c1             	mov    rcx,rax
  210c5b:	48 89 d7             	mov    rdi,rdx
  210c5e:	c6 44 24 07 20       	mov    BYTE PTR [rsp+0x7],0x20
  210c63:	48 89 6c 24 10       	mov    QWORD PTR [rsp+0x10],rbp
  210c68:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  210c6f:	00 00 
  210c71:	4c 89 f6             	mov    rsi,r14
  210c74:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  210c76:	31 c0                	xor    eax,eax
  210c78:	86 05 92 03 04 00    	xchg   BYTE PTR [rip+0x40392],al        # 251010 <stderr_mutex>
  210c7e:	3c 01                	cmp    al,0x1
    if (!ok) {
  210c80:	0f 85 5e 05 00 00    	jne    2111e4 <Bm.AtomicRmwOp.Add+0xb94>
  210c86:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  210c8d:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  210c90:	b0 01                	mov    al,0x1
  210c92:	86 05 78 03 04 00    	xchg   BYTE PTR [rip+0x40378],al        # 251010 <stderr_mutex>
  210c98:	84 c0                	test   al,al
  210c9a:	75 f4                	jne    210c90 <Bm.AtomicRmwOp.Add+0x640>
    if (stderr_stream) |st| {
  210c9c:	48 8b 3d 65 03 04 00 	mov    rdi,QWORD PTR [rip+0x40365]        # 251008 <stderr_stream>
  210ca3:	48 85 ff             	test   rdi,rdi
  210ca6:	74 09                	je     210cb1 <Bm.AtomicRmwOp.Add+0x661>
  210ca8:	48 8b 0d 91 b3 03 00 	mov    rcx,QWORD PTR [rip+0x3b391]        # 24c040 <stderr_file_out_stream+0x8>
  210caf:	eb 3d                	jmp    210cee <Bm.AtomicRmwOp.Add+0x69e>
        stderr_file = try io.getStdErr();
  210cb1:	c7 05 75 b3 03 00 02 	mov    DWORD PTR [rip+0x3b375],0x2        # 24c030 <stderr_file>
  210cb8:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  210cbb:	48 8d 05 6e b3 03 00 	lea    rax,[rip+0x3b36e]        # 24c030 <stderr_file>
  210cc2:	48 89 05 6f b3 03 00 	mov    QWORD PTR [rip+0x3b36f],rax        # 24c038 <stderr_file_out_stream>
  210cc9:	48 8d 05 d0 e1 00 00 	lea    rax,[rip+0xe1d0]        # 21eea0 <FileOutStream_writeFn>
  210cd0:	48 89 05 69 b3 03 00 	mov    QWORD PTR [rip+0x3b369],rax        # 24c040 <stderr_file_out_stream+0x8>
  210cd7:	48 8d 0d 62 b3 03 00 	lea    rcx,[rip+0x3b362]        # 24c040 <stderr_file_out_stream+0x8>
  210cde:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  210ce1:	48 89 15 20 03 04 00 	mov    QWORD PTR [rip+0x40320],rdx        # 251008 <stderr_stream>
  210ce8:	48 89 c1             	mov    rcx,rax
  210ceb:	48 89 d7             	mov    rdi,rdx
  210cee:	c6 44 24 07 20       	mov    BYTE PTR [rsp+0x7],0x20
  210cf3:	48 89 6c 24 10       	mov    QWORD PTR [rsp+0x10],rbp
  210cf8:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  210cff:	00 00 
  210d01:	4c 89 f6             	mov    rsi,r14
  210d04:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  210d06:	31 c0                	xor    eax,eax
  210d08:	86 05 02 03 04 00    	xchg   BYTE PTR [rip+0x40302],al        # 251010 <stderr_mutex>
  210d0e:	3c 01                	cmp    al,0x1
    if (!ok) {
  210d10:	0f 85 ce 04 00 00    	jne    2111e4 <Bm.AtomicRmwOp.Add+0xb94>
  210d16:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  210d1d:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  210d20:	b0 01                	mov    al,0x1
  210d22:	86 05 e8 02 04 00    	xchg   BYTE PTR [rip+0x402e8],al        # 251010 <stderr_mutex>
  210d28:	84 c0                	test   al,al
  210d2a:	75 f4                	jne    210d20 <Bm.AtomicRmwOp.Add+0x6d0>
    if (stderr_stream) |st| {
  210d2c:	48 8b 3d d5 02 04 00 	mov    rdi,QWORD PTR [rip+0x402d5]        # 251008 <stderr_stream>
  210d33:	48 85 ff             	test   rdi,rdi
  210d36:	74 09                	je     210d41 <Bm.AtomicRmwOp.Add+0x6f1>
  210d38:	48 8b 0d 01 b3 03 00 	mov    rcx,QWORD PTR [rip+0x3b301]        # 24c040 <stderr_file_out_stream+0x8>
  210d3f:	eb 3d                	jmp    210d7e <Bm.AtomicRmwOp.Add+0x72e>
        stderr_file = try io.getStdErr();
  210d41:	c7 05 e5 b2 03 00 02 	mov    DWORD PTR [rip+0x3b2e5],0x2        # 24c030 <stderr_file>
  210d48:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  210d4b:	48 8d 05 de b2 03 00 	lea    rax,[rip+0x3b2de]        # 24c030 <stderr_file>
  210d52:	48 89 05 df b2 03 00 	mov    QWORD PTR [rip+0x3b2df],rax        # 24c038 <stderr_file_out_stream>
  210d59:	48 8d 05 40 e1 00 00 	lea    rax,[rip+0xe140]        # 21eea0 <FileOutStream_writeFn>
  210d60:	48 89 05 d9 b2 03 00 	mov    QWORD PTR [rip+0x3b2d9],rax        # 24c040 <stderr_file_out_stream+0x8>
  210d67:	48 8d 0d d2 b2 03 00 	lea    rcx,[rip+0x3b2d2]        # 24c040 <stderr_file_out_stream+0x8>
  210d6e:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  210d71:	48 89 15 90 02 04 00 	mov    QWORD PTR [rip+0x40290],rdx        # 251008 <stderr_stream>
  210d78:	48 89 c1             	mov    rcx,rax
  210d7b:	48 89 d7             	mov    rdi,rdx
  210d7e:	c6 44 24 07 20       	mov    BYTE PTR [rsp+0x7],0x20
  210d83:	48 89 6c 24 10       	mov    QWORD PTR [rsp+0x10],rbp
  210d88:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  210d8f:	00 00 
  210d91:	4c 89 f6             	mov    rsi,r14
  210d94:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  210d96:	31 c0                	xor    eax,eax
  210d98:	86 05 72 02 04 00    	xchg   BYTE PTR [rip+0x40272],al        # 251010 <stderr_mutex>
  210d9e:	3c 01                	cmp    al,0x1
    if (!ok) {
  210da0:	0f 85 3e 04 00 00    	jne    2111e4 <Bm.AtomicRmwOp.Add+0xb94>
  210da6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  210dad:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  210db0:	b0 01                	mov    al,0x1
  210db2:	86 05 58 02 04 00    	xchg   BYTE PTR [rip+0x40258],al        # 251010 <stderr_mutex>
  210db8:	84 c0                	test   al,al
  210dba:	75 f4                	jne    210db0 <Bm.AtomicRmwOp.Add+0x760>
    if (stderr_stream) |st| {
  210dbc:	48 8b 3d 45 02 04 00 	mov    rdi,QWORD PTR [rip+0x40245]        # 251008 <stderr_stream>
  210dc3:	48 85 ff             	test   rdi,rdi
  210dc6:	74 09                	je     210dd1 <Bm.AtomicRmwOp.Add+0x781>
  210dc8:	48 8b 0d 71 b2 03 00 	mov    rcx,QWORD PTR [rip+0x3b271]        # 24c040 <stderr_file_out_stream+0x8>
  210dcf:	eb 3d                	jmp    210e0e <Bm.AtomicRmwOp.Add+0x7be>
        stderr_file = try io.getStdErr();
  210dd1:	c7 05 55 b2 03 00 02 	mov    DWORD PTR [rip+0x3b255],0x2        # 24c030 <stderr_file>
  210dd8:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  210ddb:	48 8d 05 4e b2 03 00 	lea    rax,[rip+0x3b24e]        # 24c030 <stderr_file>
  210de2:	48 89 05 4f b2 03 00 	mov    QWORD PTR [rip+0x3b24f],rax        # 24c038 <stderr_file_out_stream>
  210de9:	48 8d 05 b0 e0 00 00 	lea    rax,[rip+0xe0b0]        # 21eea0 <FileOutStream_writeFn>
  210df0:	48 89 05 49 b2 03 00 	mov    QWORD PTR [rip+0x3b249],rax        # 24c040 <stderr_file_out_stream+0x8>
  210df7:	48 8d 0d 42 b2 03 00 	lea    rcx,[rip+0x3b242]        # 24c040 <stderr_file_out_stream+0x8>
  210dfe:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  210e01:	48 89 15 00 02 04 00 	mov    QWORD PTR [rip+0x40200],rdx        # 251008 <stderr_stream>
  210e08:	48 89 c1             	mov    rcx,rax
  210e0b:	48 89 d7             	mov    rdi,rdx
  210e0e:	c6 44 24 07 20       	mov    BYTE PTR [rsp+0x7],0x20
  210e13:	48 89 6c 24 10       	mov    QWORD PTR [rsp+0x10],rbp
  210e18:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  210e1f:	00 00 
  210e21:	4c 89 f6             	mov    rsi,r14
  210e24:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  210e26:	31 c0                	xor    eax,eax
  210e28:	86 05 e2 01 04 00    	xchg   BYTE PTR [rip+0x401e2],al        # 251010 <stderr_mutex>
  210e2e:	3c 01                	cmp    al,0x1
    if (!ok) {
  210e30:	0f 85 ae 03 00 00    	jne    2111e4 <Bm.AtomicRmwOp.Add+0xb94>
  210e36:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  210e3d:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  210e40:	b0 01                	mov    al,0x1
  210e42:	86 05 c8 01 04 00    	xchg   BYTE PTR [rip+0x401c8],al        # 251010 <stderr_mutex>
  210e48:	84 c0                	test   al,al
  210e4a:	75 f4                	jne    210e40 <Bm.AtomicRmwOp.Add+0x7f0>
    if (stderr_stream) |st| {
  210e4c:	48 8b 3d b5 01 04 00 	mov    rdi,QWORD PTR [rip+0x401b5]        # 251008 <stderr_stream>
  210e53:	48 85 ff             	test   rdi,rdi
  210e56:	74 09                	je     210e61 <Bm.AtomicRmwOp.Add+0x811>
  210e58:	48 8b 0d e1 b1 03 00 	mov    rcx,QWORD PTR [rip+0x3b1e1]        # 24c040 <stderr_file_out_stream+0x8>
  210e5f:	eb 3d                	jmp    210e9e <Bm.AtomicRmwOp.Add+0x84e>
        stderr_file = try io.getStdErr();
  210e61:	c7 05 c5 b1 03 00 02 	mov    DWORD PTR [rip+0x3b1c5],0x2        # 24c030 <stderr_file>
  210e68:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  210e6b:	48 8d 05 be b1 03 00 	lea    rax,[rip+0x3b1be]        # 24c030 <stderr_file>
  210e72:	48 89 05 bf b1 03 00 	mov    QWORD PTR [rip+0x3b1bf],rax        # 24c038 <stderr_file_out_stream>
  210e79:	48 8d 05 20 e0 00 00 	lea    rax,[rip+0xe020]        # 21eea0 <FileOutStream_writeFn>
  210e80:	48 89 05 b9 b1 03 00 	mov    QWORD PTR [rip+0x3b1b9],rax        # 24c040 <stderr_file_out_stream+0x8>
  210e87:	48 8d 0d b2 b1 03 00 	lea    rcx,[rip+0x3b1b2]        # 24c040 <stderr_file_out_stream+0x8>
  210e8e:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  210e91:	48 89 15 70 01 04 00 	mov    QWORD PTR [rip+0x40170],rdx        # 251008 <stderr_stream>
  210e98:	48 89 c1             	mov    rcx,rax
  210e9b:	48 89 d7             	mov    rdi,rdx
  210e9e:	c6 44 24 07 20       	mov    BYTE PTR [rsp+0x7],0x20
  210ea3:	48 89 6c 24 10       	mov    QWORD PTR [rsp+0x10],rbp
  210ea8:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  210eaf:	00 00 
  210eb1:	4c 89 f6             	mov    rsi,r14
  210eb4:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  210eb6:	31 c0                	xor    eax,eax
  210eb8:	86 05 52 01 04 00    	xchg   BYTE PTR [rip+0x40152],al        # 251010 <stderr_mutex>
  210ebe:	3c 01                	cmp    al,0x1
    if (!ok) {
  210ec0:	0f 85 1e 03 00 00    	jne    2111e4 <Bm.AtomicRmwOp.Add+0xb94>
  210ec6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  210ecd:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  210ed0:	b0 01                	mov    al,0x1
  210ed2:	86 05 38 01 04 00    	xchg   BYTE PTR [rip+0x40138],al        # 251010 <stderr_mutex>
  210ed8:	84 c0                	test   al,al
  210eda:	75 f4                	jne    210ed0 <Bm.AtomicRmwOp.Add+0x880>
    if (stderr_stream) |st| {
  210edc:	48 8b 3d 25 01 04 00 	mov    rdi,QWORD PTR [rip+0x40125]        # 251008 <stderr_stream>
  210ee3:	48 85 ff             	test   rdi,rdi
  210ee6:	74 09                	je     210ef1 <Bm.AtomicRmwOp.Add+0x8a1>
  210ee8:	48 8b 0d 51 b1 03 00 	mov    rcx,QWORD PTR [rip+0x3b151]        # 24c040 <stderr_file_out_stream+0x8>
  210eef:	eb 3d                	jmp    210f2e <Bm.AtomicRmwOp.Add+0x8de>
        stderr_file = try io.getStdErr();
  210ef1:	c7 05 35 b1 03 00 02 	mov    DWORD PTR [rip+0x3b135],0x2        # 24c030 <stderr_file>
  210ef8:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  210efb:	48 8d 05 2e b1 03 00 	lea    rax,[rip+0x3b12e]        # 24c030 <stderr_file>
  210f02:	48 89 05 2f b1 03 00 	mov    QWORD PTR [rip+0x3b12f],rax        # 24c038 <stderr_file_out_stream>
  210f09:	48 8d 05 90 df 00 00 	lea    rax,[rip+0xdf90]        # 21eea0 <FileOutStream_writeFn>
  210f10:	48 89 05 29 b1 03 00 	mov    QWORD PTR [rip+0x3b129],rax        # 24c040 <stderr_file_out_stream+0x8>
  210f17:	48 8d 0d 22 b1 03 00 	lea    rcx,[rip+0x3b122]        # 24c040 <stderr_file_out_stream+0x8>
  210f1e:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  210f21:	48 89 15 e0 00 04 00 	mov    QWORD PTR [rip+0x400e0],rdx        # 251008 <stderr_stream>
  210f28:	48 89 c1             	mov    rcx,rax
  210f2b:	48 89 d7             	mov    rdi,rdx
  210f2e:	c6 44 24 07 20       	mov    BYTE PTR [rsp+0x7],0x20
  210f33:	48 89 6c 24 10       	mov    QWORD PTR [rsp+0x10],rbp
  210f38:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  210f3f:	00 00 
  210f41:	4c 89 f6             	mov    rsi,r14
  210f44:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  210f46:	31 c0                	xor    eax,eax
  210f48:	86 05 c2 00 04 00    	xchg   BYTE PTR [rip+0x400c2],al        # 251010 <stderr_mutex>
  210f4e:	3c 01                	cmp    al,0x1
    if (!ok) {
  210f50:	0f 85 8e 02 00 00    	jne    2111e4 <Bm.AtomicRmwOp.Add+0xb94>
  210f56:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  210f5d:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  210f60:	b0 01                	mov    al,0x1
  210f62:	86 05 a8 00 04 00    	xchg   BYTE PTR [rip+0x400a8],al        # 251010 <stderr_mutex>
  210f68:	84 c0                	test   al,al
  210f6a:	75 f4                	jne    210f60 <Bm.AtomicRmwOp.Add+0x910>
    if (stderr_stream) |st| {
  210f6c:	48 8b 3d 95 00 04 00 	mov    rdi,QWORD PTR [rip+0x40095]        # 251008 <stderr_stream>
  210f73:	48 85 ff             	test   rdi,rdi
  210f76:	74 09                	je     210f81 <Bm.AtomicRmwOp.Add+0x931>
  210f78:	48 8b 0d c1 b0 03 00 	mov    rcx,QWORD PTR [rip+0x3b0c1]        # 24c040 <stderr_file_out_stream+0x8>
  210f7f:	eb 3d                	jmp    210fbe <Bm.AtomicRmwOp.Add+0x96e>
        stderr_file = try io.getStdErr();
  210f81:	c7 05 a5 b0 03 00 02 	mov    DWORD PTR [rip+0x3b0a5],0x2        # 24c030 <stderr_file>
  210f88:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  210f8b:	48 8d 05 9e b0 03 00 	lea    rax,[rip+0x3b09e]        # 24c030 <stderr_file>
  210f92:	48 89 05 9f b0 03 00 	mov    QWORD PTR [rip+0x3b09f],rax        # 24c038 <stderr_file_out_stream>
  210f99:	48 8d 05 00 df 00 00 	lea    rax,[rip+0xdf00]        # 21eea0 <FileOutStream_writeFn>
  210fa0:	48 89 05 99 b0 03 00 	mov    QWORD PTR [rip+0x3b099],rax        # 24c040 <stderr_file_out_stream+0x8>
  210fa7:	48 8d 0d 92 b0 03 00 	lea    rcx,[rip+0x3b092]        # 24c040 <stderr_file_out_stream+0x8>
  210fae:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  210fb1:	48 89 15 50 00 04 00 	mov    QWORD PTR [rip+0x40050],rdx        # 251008 <stderr_stream>
  210fb8:	48 89 c1             	mov    rcx,rax
  210fbb:	48 89 d7             	mov    rdi,rdx
  210fbe:	c6 44 24 07 20       	mov    BYTE PTR [rsp+0x7],0x20
  210fc3:	48 89 6c 24 10       	mov    QWORD PTR [rsp+0x10],rbp
  210fc8:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  210fcf:	00 00 
  210fd1:	4c 89 f6             	mov    rsi,r14
  210fd4:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  210fd6:	31 c0                	xor    eax,eax
  210fd8:	86 05 32 00 04 00    	xchg   BYTE PTR [rip+0x40032],al        # 251010 <stderr_mutex>
  210fde:	3c 01                	cmp    al,0x1
    if (!ok) {
  210fe0:	0f 85 fe 01 00 00    	jne    2111e4 <Bm.AtomicRmwOp.Add+0xb94>
  210fe6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  210fed:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  210ff0:	b0 01                	mov    al,0x1
  210ff2:	86 05 18 00 04 00    	xchg   BYTE PTR [rip+0x40018],al        # 251010 <stderr_mutex>
  210ff8:	84 c0                	test   al,al
  210ffa:	75 f4                	jne    210ff0 <Bm.AtomicRmwOp.Add+0x9a0>
    if (stderr_stream) |st| {
  210ffc:	48 8b 3d 05 00 04 00 	mov    rdi,QWORD PTR [rip+0x40005]        # 251008 <stderr_stream>
  211003:	48 85 ff             	test   rdi,rdi
  211006:	74 09                	je     211011 <Bm.AtomicRmwOp.Add+0x9c1>
  211008:	48 8b 0d 31 b0 03 00 	mov    rcx,QWORD PTR [rip+0x3b031]        # 24c040 <stderr_file_out_stream+0x8>
  21100f:	eb 3d                	jmp    21104e <Bm.AtomicRmwOp.Add+0x9fe>
        stderr_file = try io.getStdErr();
  211011:	c7 05 15 b0 03 00 02 	mov    DWORD PTR [rip+0x3b015],0x2        # 24c030 <stderr_file>
  211018:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  21101b:	48 8d 05 0e b0 03 00 	lea    rax,[rip+0x3b00e]        # 24c030 <stderr_file>
  211022:	48 89 05 0f b0 03 00 	mov    QWORD PTR [rip+0x3b00f],rax        # 24c038 <stderr_file_out_stream>
  211029:	48 8d 05 70 de 00 00 	lea    rax,[rip+0xde70]        # 21eea0 <FileOutStream_writeFn>
  211030:	48 89 05 09 b0 03 00 	mov    QWORD PTR [rip+0x3b009],rax        # 24c040 <stderr_file_out_stream+0x8>
  211037:	48 8d 0d 02 b0 03 00 	lea    rcx,[rip+0x3b002]        # 24c040 <stderr_file_out_stream+0x8>
  21103e:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  211041:	48 89 15 c0 ff 03 00 	mov    QWORD PTR [rip+0x3ffc0],rdx        # 251008 <stderr_stream>
  211048:	48 89 c1             	mov    rcx,rax
  21104b:	48 89 d7             	mov    rdi,rdx
  21104e:	4c 89 fd             	mov    rbp,r15
                const casted_value = ([]const u8)(value);
  211051:	4c 89 64 24 10       	mov    QWORD PTR [rsp+0x10],r12
  211056:	48 c7 44 24 18 04 00 	mov    QWORD PTR [rsp+0x18],0x4
  21105d:	00 00 
                return output(context, casted_value);
  21105f:	4c 89 f6             	mov    rsi,r14
  211062:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  211064:	31 c0                	xor    eax,eax
  211066:	86 05 a4 ff 03 00    	xchg   BYTE PTR [rip+0x3ffa4],al        # 251010 <stderr_mutex>
  21106c:	3c 01                	cmp    al,0x1
    if (!ok) {
  21106e:	0f 85 70 01 00 00    	jne    2111e4 <Bm.AtomicRmwOp.Add+0xb94>
                try rightJustified(18, "{}", "time/operation");
  211074:	e8 a7 48 00 00       	call   215920 <Benchmark_rightJustified.39>
  211079:	66 85 c0             	test   ax,ax
  21107c:	0f 85 50 01 00 00    	jne    2111d2 <Bm.AtomicRmwOp.Add+0xb82>
  211082:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  211089:	1f 84 00 00 00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  211090:	b0 01                	mov    al,0x1
  211092:	86 05 78 ff 03 00    	xchg   BYTE PTR [rip+0x3ff78],al        # 251010 <stderr_mutex>
  211098:	84 c0                	test   al,al
  21109a:	75 f4                	jne    211090 <Bm.AtomicRmwOp.Add+0xa40>
    if (stderr_stream) |st| {
  21109c:	48 8b 3d 65 ff 03 00 	mov    rdi,QWORD PTR [rip+0x3ff65]        # 251008 <stderr_stream>
  2110a3:	48 85 ff             	test   rdi,rdi
  2110a6:	74 09                	je     2110b1 <Bm.AtomicRmwOp.Add+0xa61>
  2110a8:	48 8b 0d 91 af 03 00 	mov    rcx,QWORD PTR [rip+0x3af91]        # 24c040 <stderr_file_out_stream+0x8>
  2110af:	eb 3d                	jmp    2110ee <Bm.AtomicRmwOp.Add+0xa9e>
        stderr_file = try io.getStdErr();
  2110b1:	c7 05 75 af 03 00 02 	mov    DWORD PTR [rip+0x3af75],0x2        # 24c030 <stderr_file>
  2110b8:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  2110bb:	48 8d 05 6e af 03 00 	lea    rax,[rip+0x3af6e]        # 24c030 <stderr_file>
  2110c2:	48 89 05 6f af 03 00 	mov    QWORD PTR [rip+0x3af6f],rax        # 24c038 <stderr_file_out_stream>
  2110c9:	48 8d 05 d0 dd 00 00 	lea    rax,[rip+0xddd0]        # 21eea0 <FileOutStream_writeFn>
  2110d0:	48 89 05 69 af 03 00 	mov    QWORD PTR [rip+0x3af69],rax        # 24c040 <stderr_file_out_stream+0x8>
  2110d7:	48 8d 0d 62 af 03 00 	lea    rcx,[rip+0x3af62]        # 24c040 <stderr_file_out_stream+0x8>
  2110de:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  2110e1:	48 89 15 20 ff 03 00 	mov    QWORD PTR [rip+0x3ff20],rdx        # 251008 <stderr_stream>
  2110e8:	48 89 c1             	mov    rcx,rax
  2110eb:	48 89 d7             	mov    rdi,rdx
        try output(context, fmt[start_index..]);
  2110ee:	48 89 ee             	mov    rsi,rbp
  2110f1:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  2110f3:	31 c0                	xor    eax,eax
  2110f5:	86 05 15 ff 03 00    	xchg   BYTE PTR [rip+0x3ff15],al        # 251010 <stderr_mutex>
  2110fb:	3c 01                	cmp    al,0x1
    if (!ok) {
  2110fd:	0f 85 e1 00 00 00    	jne    2111e4 <Bm.AtomicRmwOp.Add+0xb94>
            try pSelf.report(pSelf.results.items[pSelf.results.len - 1]); warn("\n");
  211103:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  211108:	48 8b 4c 24 78       	mov    rcx,QWORD PTR [rsp+0x78]
  21110d:	48 c1 e1 04          	shl    rcx,0x4
  211111:	48 8d 34 08          	lea    rsi,[rax+rcx*1]
  211115:	48 83 c6 f0          	add    rsi,0xfffffffffffffff0
  211119:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  21111e:	e8 fd 1d 00 00       	call   212f20 <Benchmark_report>
  211123:	66 85 c0             	test   ax,ax
  211126:	0f 85 a6 00 00 00    	jne    2111d2 <Bm.AtomicRmwOp.Add+0xb82>
  21112c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  211130:	b0 01                	mov    al,0x1
  211132:	86 05 d8 fe 03 00    	xchg   BYTE PTR [rip+0x3fed8],al        # 251010 <stderr_mutex>
  211138:	84 c0                	test   al,al
  21113a:	75 f4                	jne    211130 <Bm.AtomicRmwOp.Add+0xae0>
    if (stderr_stream) |st| {
  21113c:	48 8b 3d c5 fe 03 00 	mov    rdi,QWORD PTR [rip+0x3fec5]        # 251008 <stderr_stream>
  211143:	48 85 ff             	test   rdi,rdi
  211146:	74 09                	je     211151 <Bm.AtomicRmwOp.Add+0xb01>
  211148:	48 8b 0d f1 ae 03 00 	mov    rcx,QWORD PTR [rip+0x3aef1]        # 24c040 <stderr_file_out_stream+0x8>
  21114f:	eb 3d                	jmp    21118e <Bm.AtomicRmwOp.Add+0xb3e>
        stderr_file = try io.getStdErr();
  211151:	c7 05 d5 ae 03 00 02 	mov    DWORD PTR [rip+0x3aed5],0x2        # 24c030 <stderr_file>
  211158:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  21115b:	48 8d 05 ce ae 03 00 	lea    rax,[rip+0x3aece]        # 24c030 <stderr_file>
  211162:	48 89 05 cf ae 03 00 	mov    QWORD PTR [rip+0x3aecf],rax        # 24c038 <stderr_file_out_stream>
  211169:	48 8d 05 30 dd 00 00 	lea    rax,[rip+0xdd30]        # 21eea0 <FileOutStream_writeFn>
  211170:	48 89 05 c9 ae 03 00 	mov    QWORD PTR [rip+0x3aec9],rax        # 24c040 <stderr_file_out_stream+0x8>
  211177:	48 8d 0d c2 ae 03 00 	lea    rcx,[rip+0x3aec2]        # 24c040 <stderr_file_out_stream+0x8>
  21117e:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  211181:	48 89 15 80 fe 03 00 	mov    QWORD PTR [rip+0x3fe80],rdx        # 251008 <stderr_stream>
  211188:	48 89 c1             	mov    rcx,rax
  21118b:	48 89 d7             	mov    rdi,rdx
  21118e:	4c 89 fd             	mov    rbp,r15
  211191:	48 89 ee             	mov    rsi,rbp
  211194:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  211196:	31 c0                	xor    eax,eax
  211198:	86 05 72 fe 03 00    	xchg   BYTE PTR [rip+0x3fe72],al        # 251010 <stderr_mutex>
  21119e:	3c 01                	cmp    al,0x1
    if (!ok) {
  2111a0:	75 42                	jne    2111e4 <Bm.AtomicRmwOp.Add+0xb94>
  2111a2:	49 83 c5 01          	add    r13,0x1
        while (rep < pSelf.repetitions) : (rep += 1) {
  2111a6:	4c 3b 6c 24 40       	cmp    r13,QWORD PTR [rsp+0x40]
  2111ab:	0f 82 3e f9 ff ff    	jb     210aef <Bm.AtomicRmwOp.Add+0x49f>
  2111b1:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
        try pSelf.reportStats(pSelf.results);
  2111b6:	48 8d 74 24 68       	lea    rsi,[rsp+0x68]
  2111bb:	e8 40 4a 00 00       	call   215c00 <Benchmark_reportStats>
  2111c0:	eb 10                	jmp    2111d2 <Bm.AtomicRmwOp.Add+0xb82>
                switch (errno) {
  2111c2:	48 83 f9 16          	cmp    rcx,0x16
  2111c6:	75 06                	jne    2111ce <Bm.AtomicRmwOp.Add+0xb7e>
  2111c8:	66 b8 02 00          	mov    ax,0x2
  2111cc:	eb 04                	jmp    2111d2 <Bm.AtomicRmwOp.Add+0xb82>
  2111ce:	66 b8 03 00          	mov    ax,0x3
    var bmSelf = try bm.run(BmSelf);
  2111d2:	48 81 c4 f8 00 00 00 	add    rsp,0xf8
  2111d9:	5b                   	pop    rbx
  2111da:	41 5c                	pop    r12
  2111dc:	41 5d                	pop    r13
  2111de:	41 5e                	pop    r14
  2111e0:	41 5f                	pop    r15
  2111e2:	5d                   	pop    rbp
  2111e3:	c3                   	ret    
            @panic("assertion failure");
  2111e4:	48 8d 3d a5 eb 03 00 	lea    rdi,[rip+0x3eba5]        # 24fd90 <__unnamed_2>
  2111eb:	e8 30 15 00 00       	call   212720 <panic>

00000000002111f0 <Bm.volatile.add>:
}

/// Use volatile to actually measure r = a +% b
test "Bm.volatile.add" {
  2111f0:	55                   	push   rbp
  2111f1:	41 57                	push   r15
  2111f3:	41 56                	push   r14
  2111f5:	41 55                	push   r13
  2111f7:	41 54                	push   r12
  2111f9:	53                   	push   rbx
  2111fa:	48 81 ec 08 01 00 00 	sub    rsp,0x108
  211201:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  211208:	0f 1f 84 00 00 00 00 
  21120f:	00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  211210:	b0 01                	mov    al,0x1
  211212:	86 05 f8 fd 03 00    	xchg   BYTE PTR [rip+0x3fdf8],al        # 251010 <stderr_mutex>
  211218:	84 c0                	test   al,al
  21121a:	75 f4                	jne    211210 <Bm.volatile.add+0x20>
    if (stderr_stream) |st| {
  21121c:	48 8b 3d e5 fd 03 00 	mov    rdi,QWORD PTR [rip+0x3fde5]        # 251008 <stderr_stream>
  211223:	48 85 ff             	test   rdi,rdi
  211226:	74 09                	je     211231 <Bm.volatile.add+0x41>
  211228:	48 8b 05 11 ae 03 00 	mov    rax,QWORD PTR [rip+0x3ae11]        # 24c040 <stderr_file_out_stream+0x8>
  21122f:	eb 34                	jmp    211265 <Bm.volatile.add+0x75>
        stderr_file = try io.getStdErr();
  211231:	48 8d 05 f8 ad 03 00 	lea    rax,[rip+0x3adf8]        # 24c030 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  211238:	48 89 05 f9 ad 03 00 	mov    QWORD PTR [rip+0x3adf9],rax        # 24c038 <stderr_file_out_stream>
  21123f:	48 8d 05 5a dc 00 00 	lea    rax,[rip+0xdc5a]        # 21eea0 <FileOutStream_writeFn>
  211246:	48 89 05 f3 ad 03 00 	mov    QWORD PTR [rip+0x3adf3],rax        # 24c040 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  21124d:	c7 05 d9 ad 03 00 02 	mov    DWORD PTR [rip+0x3add9],0x2        # 24c030 <stderr_file>
  211254:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  211257:	48 8d 3d e2 ad 03 00 	lea    rdi,[rip+0x3ade2]        # 24c040 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  21125e:	48 89 3d a3 fd 03 00 	mov    QWORD PTR [rip+0x3fda3],rdi        # 251008 <stderr_stream>
  211265:	48 8d 35 84 ec 03 00 	lea    rsi,[rip+0x3ec84]        # 24fef0 <__unnamed_3>
  21126c:	ff d0                	call   rax
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  21126e:	31 c0                	xor    eax,eax
  211270:	86 05 9a fd 03 00    	xchg   BYTE PTR [rip+0x3fd9a],al        # 251010 <stderr_mutex>
  211276:	3c 01                	cmp    al,0x1
    if (!ok) {
  211278:	0f 85 4e 0d 00 00    	jne    211fcc <Bm.volatile.add+0xddc>

    // Since this is a test print a \n before we run
    warn("\n");

    // Create an instance of Benchmark, set 10 iterations and run
    var bm = Benchmark.init("Bm.Add", std.debug.global_allocator);
  21127e:	c5 f8 10 05 ea ea 03 	vmovups xmm0,XMMWORD PTR [rip+0x3eaea]        # 24fd70 <__unnamed_16>
  211285:	00 
  211286:	c5 f8 29 44 24 60    	vmovaps XMMWORD PTR [rsp+0x60],xmm0
  21128c:	b8 00 65 cd 1d       	mov    eax,0x1dcd6500
  211291:	c4 e1 f9 6e c0       	vmovq  xmm0,rax
  211296:	c5 f9 73 f8 08       	vpslldq xmm0,xmm0,0x8
  21129b:	c5 f9 7f 44 24 70    	vmovdqa XMMWORD PTR [rsp+0x70],xmm0
  2112a1:	48 b8 00 e8 76 48 17 	movabs rax,0x174876e800
  2112a8:	00 00 00 
  2112ab:	48 89 84 24 88 00 00 	mov    QWORD PTR [rsp+0x88],rax
  2112b2:	00 
  2112b3:	c5 fa 6f 05 55 f0 fe 	vmovdqu xmm0,XMMWORD PTR [rip+0xfffffffffffef055]        # 200310 <__unnamed_35>
  2112ba:	ff 
  2112bb:	c5 f9 7f 84 24 90 00 	vmovdqa XMMWORD PTR [rsp+0x90],xmm0
  2112c2:	00 00 
  2112c4:	48 8d 05 35 ad 03 00 	lea    rax,[rip+0x3ad35]        # 24c000 <global_fixed_allocator>
  2112cb:	48 89 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rax
  2112d2:	00 
  2112d3:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  2112d7:	c5 fa 7f 84 24 a8 00 	vmovdqu XMMWORD PTR [rsp+0xa8],xmm0
  2112de:	00 00 
  2112e0:	48 c7 84 24 b8 00 00 	mov    QWORD PTR [rsp+0xb8],0x0
  2112e7:	00 00 00 00 00 
  2112ec:	48 89 84 24 c0 00 00 	mov    QWORD PTR [rsp+0xc0],rax
  2112f3:	00 
    bm.repetitions = 10;
  2112f4:	48 c7 84 24 80 00 00 	mov    QWORD PTR [rsp+0x80],0xa
  2112fb:	00 0a 00 00 00 
  211300:	41 b6 01             	mov    r14b,0x1
  211303:	bb 01 00 00 00       	mov    ebx,0x1
  211308:	45 31 e4             	xor    r12d,r12d
  21130b:	c5 f8 10 0d fd ef fe 	vmovups xmm1,XMMWORD PTR [rip+0xfffffffffffeeffd]        # 200310 <__unnamed_35>
  211312:	ff 
  211313:	4c 8d 7c 24 30       	lea    r15,[rsp+0x30]
  211318:	45 31 ed             	xor    r13d,r13d
                var ts: posix.timespec = undefined;
  21131b:	c5 f8 29 4c 24 30    	vmovaps XMMWORD PTR [rsp+0x30],xmm1
  211321:	b8 e5 00 00 00       	mov    eax,0xe5
  211326:	bf 01 00 00 00       	mov    edi,0x1
  21132b:	4c 89 fe             	mov    rsi,r15
  21132e:	0f 05                	syscall 
  211330:	48 89 c1             	mov    rcx,rax
  211333:	48 f7 d9             	neg    rcx
  211336:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  21133c:	49 0f 46 cc          	cmovbe rcx,r12
                switch (errno) {
  211340:	48 85 c9             	test   rcx,rcx
  211343:	0f 85 5b 0c 00 00    	jne    211fa4 <Bm.volatile.add+0xdb4>
        const f = @atomicLoad(@typeOf(init_vdso_clock_gettime), &vdso_clock_gettime, builtin.AtomicOrder.Unordered);
  211349:	48 8b 05 c8 ad 03 00 	mov    rax,QWORD PTR [rip+0x3adc8]        # 24c118 <vdso_clock_gettime>
        if (@ptrToInt(f) != 0) {
  211350:	48 85 c0             	test   rax,rax
  211353:	74 21                	je     211376 <Bm.volatile.add+0x186>
            const rc = f(clk_id, tp);
  211355:	bf 01 00 00 00       	mov    edi,0x1
  21135a:	4c 89 fe             	mov    rsi,r15
  21135d:	ff d0                	call   rax
            switch (rc) {
  21135f:	48 83 f8 ea          	cmp    rax,0xffffffffffffffea
  211363:	0f 84 f7 04 00 00    	je     211860 <Bm.volatile.add+0x670>
  211369:	48 85 c0             	test   rax,rax
  21136c:	c5 f8 10 0d 9c ef fe 	vmovups xmm1,XMMWORD PTR [rip+0xfffffffffffeef9c]        # 200310 <__unnamed_35>
  211373:	ff 
  211374:	74 0f                	je     211385 <Bm.volatile.add+0x195>
  211376:	b8 e4 00 00 00       	mov    eax,0xe4
  21137b:	bf 01 00 00 00       	mov    edi,0x1
  211380:	4c 89 fe             	mov    rsi,r15
  211383:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  211385:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
                if (errno != 0) return std.os.unexpectedErrorPosix(errno);
  21138b:	0f 83 1f 0c 00 00    	jae    211fb0 <Bm.volatile.add+0xdc0>
                self.start_time = @intCast(u64, ts.tv_sec) * u64(ns_per_s) + @intCast(u64, ts.tv_nsec);
  211391:	48 8b 6c 24 30       	mov    rbp,QWORD PTR [rsp+0x30]
  211396:	4c 8b 64 24 38       	mov    r12,QWORD PTR [rsp+0x38]
        var ts: posix.timespec = undefined;
  21139b:	c5 f8 29 4c 24 30    	vmovaps XMMWORD PTR [rsp+0x30],xmm1
        const f = @atomicLoad(@typeOf(init_vdso_clock_gettime), &vdso_clock_gettime, builtin.AtomicOrder.Unordered);
  2113a1:	48 8b 05 70 ad 03 00 	mov    rax,QWORD PTR [rip+0x3ad70]        # 24c118 <vdso_clock_gettime>
        if (@ptrToInt(f) != 0) {
  2113a8:	48 85 c0             	test   rax,rax
  2113ab:	74 21                	je     2113ce <Bm.volatile.add+0x1de>
            const rc = f(clk_id, tp);
  2113ad:	bf 01 00 00 00       	mov    edi,0x1
  2113b2:	4c 89 fe             	mov    rsi,r15
  2113b5:	ff d0                	call   rax
            switch (rc) {
  2113b7:	48 83 f8 ea          	cmp    rax,0xffffffffffffffea
  2113bb:	0f 84 b8 04 00 00    	je     211879 <Bm.volatile.add+0x689>
  2113c1:	48 85 c0             	test   rax,rax
  2113c4:	c5 f8 10 0d 44 ef fe 	vmovups xmm1,XMMWORD PTR [rip+0xfffffffffffeef44]        # 200310 <__unnamed_35>
  2113cb:	ff 
  2113cc:	74 0f                	je     2113dd <Bm.volatile.add+0x1ed>
  2113ce:	b8 e4 00 00 00       	mov    eax,0xe4
  2113d3:	bf 01 00 00 00       	mov    edi,0x1
  2113d8:	4c 89 fe             	mov    rsi,r15
  2113db:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  2113dd:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
  2113e3:	0f 83 e3 0b 00 00    	jae    211fcc <Bm.volatile.add+0xddc>
        return @intCast(u64, ts.tv_sec) * u64(ns_per_s) + @intCast(u64, ts.tv_nsec);
  2113e9:	48 8b 44 24 30       	mov    rax,QWORD PTR [rsp+0x30]
  2113ee:	48 29 e8             	sub    rax,rbp
  2113f1:	48 8b 4c 24 38       	mov    rcx,QWORD PTR [rsp+0x38]
  2113f6:	4c 29 e1             	sub    rcx,r12
  2113f9:	48 69 c0 00 ca 9a 3b 	imul   rax,rax,0x3b9aca00
        var clock = clockNative() - self.start_time;
  211400:	48 01 c8             	add    rax,rcx
        self.s +%= 0x9e3779b97f4a7c15;
  211403:	48 b9 15 7c 4a 7f b9 	movabs rcx,0x9e3779b97f4a7c15
  21140a:	79 37 9e 
  21140d:	48 8d 0c 08          	lea    rcx,[rax+rcx*1]
        z = (z ^ (z >> 30)) *% 0xbf58476d1ce4e5b9;
  211411:	48 89 ca             	mov    rdx,rcx
  211414:	48 c1 ea 1e          	shr    rdx,0x1e
  211418:	48 31 ca             	xor    rdx,rcx
  21141b:	48 b9 b9 e5 e4 1c 6d 	movabs rcx,0xbf58476d1ce4e5b9
  211422:	47 58 bf 
  211425:	48 89 ce             	mov    rsi,rcx
  211428:	48 0f af d6          	imul   rdx,rsi
        z = (z ^ (z >> 27)) *% 0x94d049bb133111eb;
  21142c:	48 89 d1             	mov    rcx,rdx
  21142f:	48 c1 e9 1b          	shr    rcx,0x1b
  211433:	48 31 d1             	xor    rcx,rdx
  211436:	48 ba eb 11 31 13 bb 	movabs rdx,0x94d049bb133111eb
  21143d:	49 d0 94 
  211440:	48 89 d7             	mov    rdi,rdx
  211443:	48 0f af cf          	imul   rcx,rdi
        return z ^ (z >> 31);
  211447:	48 89 ca             	mov    rdx,rcx
  21144a:	48 c1 ea 1f          	shr    rdx,0x1f
  21144e:	48 31 ca             	xor    rdx,rcx
        self.s +%= 0x9e3779b97f4a7c15;
  211451:	48 b9 2a f8 94 fe 72 	movabs rcx,0x3c6ef372fe94f82a
  211458:	f3 6e 3c 
  21145b:	48 01 c8             	add    rax,rcx
        z = (z ^ (z >> 30)) *% 0xbf58476d1ce4e5b9;
  21145e:	48 89 c1             	mov    rcx,rax
  211461:	48 c1 e9 1e          	shr    rcx,0x1e
  211465:	48 31 c1             	xor    rcx,rax
  211468:	48 0f af ce          	imul   rcx,rsi
        z = (z ^ (z >> 27)) *% 0x94d049bb133111eb;
  21146c:	48 89 c8             	mov    rax,rcx
  21146f:	48 c1 e8 1b          	shr    rax,0x1b
  211473:	48 31 c8             	xor    rax,rcx
  211476:	48 0f af c7          	imul   rax,rdi
        return z ^ (z >> 31);
  21147a:	48 89 c1             	mov    rcx,rax
  21147d:	48 c1 e9 1f          	shr    rcx,0x1f
  211481:	48 31 c1             	xor    rcx,rax
        const r = s0 +% s1;
  211484:	48 8d 04 11          	lea    rax,[rcx+rdx*1]
        s1 ^= s0;
  211488:	48 31 d1             	xor    rcx,rdx
  21148b:	c4 e3 fb f0 d2 09    	rorx   rdx,rdx,0x9
        self.s[0] = math.rotl(u64, s0, u8(55)) ^ s1 ^ (s1 << 14);
  211491:	48 31 ca             	xor    rdx,rcx
  211494:	c4 e3 fb f0 f1 1c    	rorx   rsi,rcx,0x1c
  21149a:	48 c1 e1 0e          	shl    rcx,0xe
  21149e:	48 31 d1             	xor    rcx,rdx
        const r = s0 +% s1;
  2114a1:	48 01 f1             	add    rcx,rsi
            pSelf.a = prng.random.scalar(u64);
  2114a4:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
            pSelf.b = prng.random.scalar(u64);
  2114a9:	48 89 4c 24 08       	mov    QWORD PTR [rsp+0x8],rcx
            while (iterations <= pSelf.max_iterations) {
  2114ae:	48 8b ac 24 88 00 00 	mov    rbp,QWORD PTR [rsp+0x88]
  2114b5:	00 
  2114b6:	48 39 eb             	cmp    rbx,rbp
  2114b9:	41 bc 00 00 00 00    	mov    r12d,0x0
  2114bf:	76 22                	jbe    2114e3 <Bm.volatile.add+0x2f3>
  2114c1:	e9 00 04 00 00       	jmp    2118c6 <Bm.volatile.add+0x6d6>
  2114c6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  2114cd:	00 00 00 
                        warn("iteratons:{} numer:{} denom:{}\n", iterations, numer, denom);
  2114d0:	48 89 df             	mov    rdi,rbx
  2114d3:	48 89 ca             	mov    rdx,rcx
  2114d6:	e8 55 3b 00 00       	call   215030 <warn.37>
  2114db:	c5 f8 10 0d 2d ee fe 	vmovups xmm1,XMMWORD PTR [rip+0xfffffffffffeee2d]        # 200310 <__unnamed_35>
  2114e2:	ff 
                var ts: posix.timespec = undefined;
  2114e3:	c5 f8 29 4c 24 30    	vmovaps XMMWORD PTR [rsp+0x30],xmm1
  2114e9:	b8 e5 00 00 00       	mov    eax,0xe5
  2114ee:	bf 01 00 00 00       	mov    edi,0x1
  2114f3:	4c 89 fe             	mov    rsi,r15
  2114f6:	0f 05                	syscall 
  2114f8:	48 89 c1             	mov    rcx,rax
  2114fb:	48 f7 d9             	neg    rcx
  2114fe:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  211504:	49 0f 46 cc          	cmovbe rcx,r12
                switch (errno) {
  211508:	48 85 c9             	test   rcx,rcx
  21150b:	0f 85 93 0a 00 00    	jne    211fa4 <Bm.volatile.add+0xdb4>
        const f = @atomicLoad(@typeOf(init_vdso_clock_gettime), &vdso_clock_gettime, builtin.AtomicOrder.Unordered);
  211511:	48 8b 05 00 ac 03 00 	mov    rax,QWORD PTR [rip+0x3ac00]        # 24c118 <vdso_clock_gettime>
        if (@ptrToInt(f) != 0) {
  211518:	48 85 c0             	test   rax,rax
  21151b:	74 21                	je     21153e <Bm.volatile.add+0x34e>
            const rc = f(clk_id, tp);
  21151d:	bf 01 00 00 00       	mov    edi,0x1
  211522:	4c 89 fe             	mov    rsi,r15
  211525:	ff d0                	call   rax
            switch (rc) {
  211527:	48 83 f8 ea          	cmp    rax,0xffffffffffffffea
  21152b:	0f 84 ef 02 00 00    	je     211820 <Bm.volatile.add+0x630>
  211531:	48 85 c0             	test   rax,rax
  211534:	c5 f8 10 0d d4 ed fe 	vmovups xmm1,XMMWORD PTR [rip+0xfffffffffffeedd4]        # 200310 <__unnamed_35>
  21153b:	ff 
  21153c:	74 0f                	je     21154d <Bm.volatile.add+0x35d>
  21153e:	b8 e4 00 00 00       	mov    eax,0xe4
  211543:	bf 01 00 00 00       	mov    edi,0x1
  211548:	4c 89 fe             	mov    rsi,r15
  21154b:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  21154d:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
                if (errno != 0) return std.os.unexpectedErrorPosix(errno);
  211553:	0f 83 57 0a 00 00    	jae    211fb0 <Bm.volatile.add+0xdc0>
                self.start_time = @intCast(u64, ts.tv_sec) * u64(ns_per_s) + @intCast(u64, ts.tv_nsec);
  211559:	c5 f9 6f 54 24 30    	vmovdqa xmm2,XMMWORD PTR [rsp+0x30]
        while (iter > 0) : (iter -= 1) {
  21155f:	48 85 db             	test   rbx,rbx
  211562:	0f 84 b6 00 00 00    	je     21161e <Bm.volatile.add+0x42e>
            pR.* = (pA.* +% pB.*);
  211568:	48 8d 4b ff          	lea    rcx,[rbx-0x1]
  21156c:	48 89 da             	mov    rdx,rbx
  21156f:	48 89 d8             	mov    rax,rbx
  211572:	48 83 e2 07          	and    rdx,0x7
  211576:	74 21                	je     211599 <Bm.volatile.add+0x3a9>
  211578:	48 f7 da             	neg    rdx
  21157b:	48 89 d8             	mov    rax,rbx
  21157e:	66 90                	xchg   ax,ax
  211580:	48 8b 74 24 10       	mov    rsi,QWORD PTR [rsp+0x10]
  211585:	48 03 74 24 08       	add    rsi,QWORD PTR [rsp+0x8]
  21158a:	48 89 74 24 18       	mov    QWORD PTR [rsp+0x18],rsi
        while (iter > 0) : (iter -= 1) {
  21158f:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  211593:	48 83 c2 01          	add    rdx,0x1
  211597:	75 e7                	jne    211580 <Bm.volatile.add+0x390>
            pR.* = (pA.* +% pB.*);
  211599:	48 83 f9 07          	cmp    rcx,0x7
  21159d:	72 7f                	jb     21161e <Bm.volatile.add+0x42e>
  21159f:	90                   	nop
  2115a0:	48 8b 4c 24 10       	mov    rcx,QWORD PTR [rsp+0x10]
  2115a5:	48 03 4c 24 08       	add    rcx,QWORD PTR [rsp+0x8]
  2115aa:	48 89 4c 24 18       	mov    QWORD PTR [rsp+0x18],rcx
  2115af:	48 8b 4c 24 10       	mov    rcx,QWORD PTR [rsp+0x10]
  2115b4:	48 03 4c 24 08       	add    rcx,QWORD PTR [rsp+0x8]
  2115b9:	48 89 4c 24 18       	mov    QWORD PTR [rsp+0x18],rcx
  2115be:	48 8b 4c 24 10       	mov    rcx,QWORD PTR [rsp+0x10]
  2115c3:	48 03 4c 24 08       	add    rcx,QWORD PTR [rsp+0x8]
  2115c8:	48 89 4c 24 18       	mov    QWORD PTR [rsp+0x18],rcx
  2115cd:	48 8b 4c 24 10       	mov    rcx,QWORD PTR [rsp+0x10]
  2115d2:	48 03 4c 24 08       	add    rcx,QWORD PTR [rsp+0x8]
  2115d7:	48 89 4c 24 18       	mov    QWORD PTR [rsp+0x18],rcx
  2115dc:	48 8b 4c 24 10       	mov    rcx,QWORD PTR [rsp+0x10]
  2115e1:	48 03 4c 24 08       	add    rcx,QWORD PTR [rsp+0x8]
  2115e6:	48 89 4c 24 18       	mov    QWORD PTR [rsp+0x18],rcx
  2115eb:	48 8b 4c 24 10       	mov    rcx,QWORD PTR [rsp+0x10]
  2115f0:	48 03 4c 24 08       	add    rcx,QWORD PTR [rsp+0x8]
  2115f5:	48 89 4c 24 18       	mov    QWORD PTR [rsp+0x18],rcx
  2115fa:	48 8b 4c 24 10       	mov    rcx,QWORD PTR [rsp+0x10]
  2115ff:	48 03 4c 24 08       	add    rcx,QWORD PTR [rsp+0x8]
  211604:	48 89 4c 24 18       	mov    QWORD PTR [rsp+0x18],rcx
  211609:	48 8b 4c 24 10       	mov    rcx,QWORD PTR [rsp+0x10]
  21160e:	48 03 4c 24 08       	add    rcx,QWORD PTR [rsp+0x8]
        while (iter > 0) : (iter -= 1) {
  211613:	48 83 c0 f8          	add    rax,0xfffffffffffffff8
            pR.* = (pA.* +% pB.*);
  211617:	48 89 4c 24 18       	mov    QWORD PTR [rsp+0x18],rcx
        while (iter > 0) : (iter -= 1) {
  21161c:	75 82                	jne    2115a0 <Bm.volatile.add+0x3b0>
        var ts: posix.timespec = undefined;
  21161e:	c5 f8 29 4c 24 30    	vmovaps XMMWORD PTR [rsp+0x30],xmm1
        const f = @atomicLoad(@typeOf(init_vdso_clock_gettime), &vdso_clock_gettime, builtin.AtomicOrder.Unordered);
  211624:	48 8b 05 ed aa 03 00 	mov    rax,QWORD PTR [rip+0x3aaed]        # 24c118 <vdso_clock_gettime>
        if (@ptrToInt(f) != 0) {
  21162b:	48 85 c0             	test   rax,rax
  21162e:	74 33                	je     211663 <Bm.volatile.add+0x473>
  211630:	c5 f9 7f 94 24 d0 00 	vmovdqa XMMWORD PTR [rsp+0xd0],xmm2
  211637:	00 00 
            const rc = f(clk_id, tp);
  211639:	bf 01 00 00 00       	mov    edi,0x1
  21163e:	4c 89 fe             	mov    rsi,r15
  211641:	ff d0                	call   rax
            switch (rc) {
  211643:	48 83 f8 ea          	cmp    rax,0xffffffffffffffea
  211647:	0f 84 ec 01 00 00    	je     211839 <Bm.volatile.add+0x649>
  21164d:	48 85 c0             	test   rax,rax
  211650:	c5 f8 10 0d b8 ec fe 	vmovups xmm1,XMMWORD PTR [rip+0xfffffffffffeecb8]        # 200310 <__unnamed_35>
  211657:	ff 
  211658:	c5 f9 6f 94 24 d0 00 	vmovdqa xmm2,XMMWORD PTR [rsp+0xd0]
  21165f:	00 00 
  211661:	74 0f                	je     211672 <Bm.volatile.add+0x482>
  211663:	b8 e4 00 00 00       	mov    eax,0xe4
  211668:	bf 01 00 00 00       	mov    edi,0x1
  21166d:	4c 89 fe             	mov    rsi,r15
  211670:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  211672:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
  211678:	0f 83 4e 09 00 00    	jae    211fcc <Bm.volatile.add+0xddc>
        return @intCast(u64, ts.tv_sec) * u64(ns_per_s) + @intCast(u64, ts.tv_nsec);
  21167e:	c5 f9 6f 44 24 30    	vmovdqa xmm0,XMMWORD PTR [rsp+0x30]
  211684:	c5 f9 fb c2          	vpsubq xmm0,xmm0,xmm2
  211688:	c4 e1 f9 7e c0       	vmovq  rax,xmm0
        var clock = clockNative() - self.start_time;
  21168d:	c4 c3 f9 16 c4 01    	vpextrq r12,xmm0,0x1
  211693:	48 69 c0 00 ca 9a 3b 	imul   rax,rax,0x3b9aca00
  21169a:	49 01 c4             	add    r12,rax
                if ((run_time_ns >= pSelf.min_runtime_ns) or (iterations >= pSelf.max_iterations)) {
  21169d:	4c 3b 64 24 78       	cmp    r12,QWORD PTR [rsp+0x78]
  2116a2:	0f 83 ea 01 00 00    	jae    211892 <Bm.volatile.add+0x6a2>
  2116a8:	48 39 eb             	cmp    rbx,rbp
  2116ab:	0f 83 e1 01 00 00    	jae    211892 <Bm.volatile.add+0x6a2>
                    if (pSelf.logl >= 1) {
  2116b1:	48 83 7c 24 70 00    	cmp    QWORD PTR [rsp+0x70],0x0
  2116b7:	0f 84 c1 00 00 00    	je     21177e <Bm.volatile.add+0x58e>
                            Result {.run_time_ns = run_time_ns, .iterations = iterations});
  2116bd:	4c 89 a4 24 e8 00 00 	mov    QWORD PTR [rsp+0xe8],r12
  2116c4:	00 
  2116c5:	48 89 9c 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rbx
  2116cc:	00 
                        try pSelf.report(
  2116cd:	48 8d 7c 24 60       	lea    rdi,[rsp+0x60]
  2116d2:	48 8d b4 24 e8 00 00 	lea    rsi,[rsp+0xe8]
  2116d9:	00 
  2116da:	e8 41 18 00 00       	call   212f20 <Benchmark_report>
  2116df:	66 85 c0             	test   ax,ax
  2116e2:	0f 85 cc 08 00 00    	jne    211fb4 <Bm.volatile.add+0xdc4>
  2116e8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  2116ef:	00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  2116f0:	b0 01                	mov    al,0x1
  2116f2:	86 05 18 f9 03 00    	xchg   BYTE PTR [rip+0x3f918],al        # 251010 <stderr_mutex>
  2116f8:	84 c0                	test   al,al
  2116fa:	75 f4                	jne    2116f0 <Bm.volatile.add+0x500>
    if (stderr_stream) |st| {
  2116fc:	48 8b 3d 05 f9 03 00 	mov    rdi,QWORD PTR [rip+0x3f905]        # 251008 <stderr_stream>
  211703:	48 85 ff             	test   rdi,rdi
  211706:	74 18                	je     211720 <Bm.volatile.add+0x530>
  211708:	48 8b 0d 31 a9 03 00 	mov    rcx,QWORD PTR [rip+0x3a931]        # 24c040 <stderr_file_out_stream+0x8>
  21170f:	eb 4c                	jmp    21175d <Bm.volatile.add+0x56d>
  211711:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  211718:	0f 1f 84 00 00 00 00 
  21171f:	00 
        stderr_file = try io.getStdErr();
  211720:	c7 05 06 a9 03 00 02 	mov    DWORD PTR [rip+0x3a906],0x2        # 24c030 <stderr_file>
  211727:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  21172a:	48 8d 05 ff a8 03 00 	lea    rax,[rip+0x3a8ff]        # 24c030 <stderr_file>
  211731:	48 89 05 00 a9 03 00 	mov    QWORD PTR [rip+0x3a900],rax        # 24c038 <stderr_file_out_stream>
  211738:	48 8d 05 61 d7 00 00 	lea    rax,[rip+0xd761]        # 21eea0 <FileOutStream_writeFn>
  21173f:	48 89 05 fa a8 03 00 	mov    QWORD PTR [rip+0x3a8fa],rax        # 24c040 <stderr_file_out_stream+0x8>
  211746:	48 8d 0d f3 a8 03 00 	lea    rcx,[rip+0x3a8f3]        # 24c040 <stderr_file_out_stream+0x8>
  21174d:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  211750:	48 89 15 b1 f8 03 00 	mov    QWORD PTR [rip+0x3f8b1],rdx        # 251008 <stderr_stream>
  211757:	48 89 c1             	mov    rcx,rax
  21175a:	48 89 d7             	mov    rdi,rdx
  21175d:	48 8d 35 8c e7 03 00 	lea    rsi,[rip+0x3e78c]        # 24fef0 <__unnamed_3>
  211764:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  211766:	31 c0                	xor    eax,eax
  211768:	86 05 a2 f8 03 00    	xchg   BYTE PTR [rip+0x3f8a2],al        # 251010 <stderr_mutex>
  21176e:	3c 01                	cmp    al,0x1
  211770:	c5 f8 10 0d 98 eb fe 	vmovups xmm1,XMMWORD PTR [rip+0xfffffffffffeeb98]        # 200310 <__unnamed_35>
  211777:	ff 
    if (!ok) {
  211778:	0f 85 4e 08 00 00    	jne    211fcc <Bm.volatile.add+0xddc>
                    if (run_time_ns < 1000) {
  21177e:	49 81 fc e8 03 00 00 	cmp    r12,0x3e8
  211785:	73 19                	jae    2117a0 <Bm.volatile.add+0x5b0>
  211787:	b9 01 00 00 00       	mov    ecx,0x1
  21178c:	be e8 03 00 00       	mov    esi,0x3e8
  211791:	eb 3a                	jmp    2117cd <Bm.volatile.add+0x5dd>
  211793:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21179a:	84 00 00 00 00 00 
                    } else if (run_time_ns < (pSelf.min_runtime_ns / 10)) {
  2117a0:	48 ba cd cc cc cc cc 	movabs rdx,0xcccccccccccccccd
  2117a7:	cc cc cc 
  2117aa:	c4 e2 fb f6 4c 24 78 	mulx   rcx,rax,QWORD PTR [rsp+0x78]
  2117b1:	48 c1 e9 03          	shr    rcx,0x3
  2117b5:	31 c0                	xor    eax,eax
  2117b7:	49 39 cc             	cmp    r12,rcx
  2117ba:	0f 93 c0             	setae  al
  2117bd:	48 8d 0c c0          	lea    rcx,[rax+rax*8]
  2117c1:	48 83 c1 01          	add    rcx,0x1
  2117c5:	48 8d 34 85 0a 00 00 	lea    rsi,[rax*4+0xa]
  2117cc:	00 
  2117cd:	45 31 e4             	xor    r12d,r12d
                    iterations = (iterations * numer) / denom;
  2117d0:	48 0f af de          	imul   rbx,rsi
  2117d4:	48 89 d8             	mov    rax,rbx
  2117d7:	48 c1 e8 20          	shr    rax,0x20
  2117db:	74 13                	je     2117f0 <Bm.volatile.add+0x600>
  2117dd:	31 d2                	xor    edx,edx
  2117df:	48 89 d8             	mov    rax,rbx
  2117e2:	48 f7 f1             	div    rcx
  2117e5:	48 89 c3             	mov    rbx,rax
  2117e8:	eb 0e                	jmp    2117f8 <Bm.volatile.add+0x608>
  2117ea:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  2117f0:	31 d2                	xor    edx,edx
  2117f2:	89 d8                	mov    eax,ebx
  2117f4:	f7 f1                	div    ecx
  2117f6:	89 c3                	mov    ebx,eax
                    if (iterations > pSelf.max_iterations) {
  2117f8:	48 8b ac 24 88 00 00 	mov    rbp,QWORD PTR [rsp+0x88]
  2117ff:	00 
  211800:	48 39 eb             	cmp    rbx,rbp
  211803:	48 0f 47 dd          	cmova  rbx,rbp
                    if (pSelf.logl >= 2) {
  211807:	48 83 7c 24 70 02    	cmp    QWORD PTR [rsp+0x70],0x2
  21180d:	0f 82 d0 fc ff ff    	jb     2114e3 <Bm.volatile.add+0x2f3>
  211813:	e9 b8 fc ff ff       	jmp    2114d0 <Bm.volatile.add+0x2e0>
  211818:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  21181f:	00 
  211820:	c5 f8 10 0d e8 ea fe 	vmovups xmm1,XMMWORD PTR [rip+0xfffffffffffeeae8]        # 200310 <__unnamed_35>
  211827:	ff 
  211828:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
  21182e:	0f 82 25 fd ff ff    	jb     211559 <Bm.volatile.add+0x369>
  211834:	e9 77 07 00 00       	jmp    211fb0 <Bm.volatile.add+0xdc0>
  211839:	c5 f8 10 0d cf ea fe 	vmovups xmm1,XMMWORD PTR [rip+0xfffffffffffeeacf]        # 200310 <__unnamed_35>
  211840:	ff 
  211841:	c5 f9 6f 94 24 d0 00 	vmovdqa xmm2,XMMWORD PTR [rsp+0xd0]
  211848:	00 00 
  21184a:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
  211850:	0f 82 28 fe ff ff    	jb     21167e <Bm.volatile.add+0x48e>
  211856:	e9 71 07 00 00       	jmp    211fcc <Bm.volatile.add+0xddc>
  21185b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  211860:	c5 f8 10 0d a8 ea fe 	vmovups xmm1,XMMWORD PTR [rip+0xfffffffffffeeaa8]        # 200310 <__unnamed_35>
  211867:	ff 
  211868:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
                if (errno != 0) return std.os.unexpectedErrorPosix(errno);
  21186e:	0f 82 1d fb ff ff    	jb     211391 <Bm.volatile.add+0x1a1>
  211874:	e9 37 07 00 00       	jmp    211fb0 <Bm.volatile.add+0xdc0>
  211879:	c5 f8 10 0d 8f ea fe 	vmovups xmm1,XMMWORD PTR [rip+0xfffffffffffeea8f]        # 200310 <__unnamed_35>
  211880:	ff 
  211881:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
  211887:	0f 82 5c fb ff ff    	jb     2113e9 <Bm.volatile.add+0x1f9>
  21188d:	e9 3a 07 00 00       	jmp    211fcc <Bm.volatile.add+0xddc>
                            Result { .run_time_ns = run_time_ns, .iterations = iterations});
  211892:	4c 89 a4 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],r12
  211899:	00 
  21189a:	48 89 9c 24 00 01 00 	mov    QWORD PTR [rsp+0x100],rbx
  2118a1:	00 
                    try pSelf.results.append(
  2118a2:	48 8d bc 24 a8 00 00 	lea    rdi,[rsp+0xa8]
  2118a9:	00 
  2118aa:	48 8d b4 24 f8 00 00 	lea    rsi,[rsp+0xf8]
  2118b1:	00 
  2118b2:	e8 f9 14 00 00       	call   212db0 <AlignedArrayList(Result,8)_append>
  2118b7:	66 85 c0             	test   ax,ax
  2118ba:	41 bc 00 00 00 00    	mov    r12d,0x0
  2118c0:	0f 85 ee 06 00 00    	jne    211fb4 <Bm.volatile.add+0xdc4>
  2118c6:	48 8b 44 24 08       	mov    rax,QWORD PTR [rsp+0x8]
            if (pSelf.r != (u64(pSelf.a) +% u64(pSelf.b))) return error.Failed;
  2118cb:	48 03 44 24 10       	add    rax,QWORD PTR [rsp+0x10]
  2118d0:	48 3b 44 24 18       	cmp    rax,QWORD PTR [rsp+0x18]
                    try bm.tearDown();
  2118d5:	0f 85 eb 06 00 00    	jne    211fc6 <Bm.volatile.add+0xdd6>
            if (once) {
  2118db:	41 f6 c6 01          	test   r14b,0x1
  2118df:	48 8d 6c 24 07       	lea    rbp,[rsp+0x7]
  2118e4:	4c 8d 74 24 20       	lea    r14,[rsp+0x20]
  2118e9:	0f 84 d8 05 00 00    	je     211ec7 <Bm.volatile.add+0xcd7>
                try leftJustified(22, "name repetitions:{}", pSelf.repetitions);
  2118ef:	48 8b bc 24 80 00 00 	mov    rdi,QWORD PTR [rsp+0x80]
  2118f6:	00 
  2118f7:	e8 a4 3a 00 00       	call   2153a0 <Benchmark_leftJustified>
  2118fc:	66 85 c0             	test   ax,ax
  2118ff:	0f 85 af 06 00 00    	jne    211fb4 <Bm.volatile.add+0xdc4>
                try rightJustified(14, "{}", "iterations");
  211905:	e8 36 3d 00 00       	call   215640 <Benchmark_rightJustified>
  21190a:	66 85 c0             	test   ax,ax
  21190d:	0f 85 a1 06 00 00    	jne    211fb4 <Bm.volatile.add+0xdc4>
        var buffer: [40]u8 = undefined;
  211913:	c5 fe 6f 05 34 46 ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffff4634]        # 205f4f <__unnamed_7>
  21191a:	ff 
  21191b:	c5 fe 7f 44 24 30    	vmovdqu YMMWORD PTR [rsp+0x30],ymm0
  211921:	48 8b 05 47 46 ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffff4647]        # 205f6f <__unnamed_7+0x20>
  211928:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
  21192d:	c7 44 24 30 74 69 6d 	mov    DWORD PTR [rsp+0x30],0x656d6974
  211934:	65 
  211935:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21193c:	00 00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  211940:	b0 01                	mov    al,0x1
  211942:	86 05 c8 f6 03 00    	xchg   BYTE PTR [rip+0x3f6c8],al        # 251010 <stderr_mutex>
  211948:	84 c0                	test   al,al
  21194a:	75 f4                	jne    211940 <Bm.volatile.add+0x750>
    if (stderr_stream) |st| {
  21194c:	48 8b 3d b5 f6 03 00 	mov    rdi,QWORD PTR [rip+0x3f6b5]        # 251008 <stderr_stream>
  211953:	48 85 ff             	test   rdi,rdi
  211956:	74 09                	je     211961 <Bm.volatile.add+0x771>
  211958:	48 8b 0d e1 a6 03 00 	mov    rcx,QWORD PTR [rip+0x3a6e1]        # 24c040 <stderr_file_out_stream+0x8>
  21195f:	eb 3d                	jmp    21199e <Bm.volatile.add+0x7ae>
        stderr_file = try io.getStdErr();
  211961:	c7 05 c5 a6 03 00 02 	mov    DWORD PTR [rip+0x3a6c5],0x2        # 24c030 <stderr_file>
  211968:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  21196b:	48 8d 05 be a6 03 00 	lea    rax,[rip+0x3a6be]        # 24c030 <stderr_file>
  211972:	48 89 05 bf a6 03 00 	mov    QWORD PTR [rip+0x3a6bf],rax        # 24c038 <stderr_file_out_stream>
  211979:	48 8d 05 20 d5 00 00 	lea    rax,[rip+0xd520]        # 21eea0 <FileOutStream_writeFn>
  211980:	48 89 05 b9 a6 03 00 	mov    QWORD PTR [rip+0x3a6b9],rax        # 24c040 <stderr_file_out_stream+0x8>
  211987:	48 8d 0d b2 a6 03 00 	lea    rcx,[rip+0x3a6b2]        # 24c040 <stderr_file_out_stream+0x8>
  21198e:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  211991:	48 89 15 70 f6 03 00 	mov    QWORD PTR [rip+0x3f670],rdx        # 251008 <stderr_stream>
  211998:	48 89 c1             	mov    rcx,rax
  21199b:	48 89 d7             	mov    rdi,rdx
  21199e:	c6 44 24 07 20       	mov    BYTE PTR [rsp+0x7],0x20
    return output(context, (*[1]u8)(&c)[0..]);
  2119a3:	48 89 6c 24 20       	mov    QWORD PTR [rsp+0x20],rbp
  2119a8:	48 c7 44 24 28 01 00 	mov    QWORD PTR [rsp+0x28],0x1
  2119af:	00 00 
  2119b1:	4c 89 f6             	mov    rsi,r14
  2119b4:	c5 f8 77             	vzeroupper 
  2119b7:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  2119b9:	31 c0                	xor    eax,eax
  2119bb:	86 05 4f f6 03 00    	xchg   BYTE PTR [rip+0x3f64f],al        # 251010 <stderr_mutex>
  2119c1:	3c 01                	cmp    al,0x1
    if (!ok) {
  2119c3:	0f 85 03 06 00 00    	jne    211fcc <Bm.volatile.add+0xddc>
  2119c9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  2119d0:	b0 01                	mov    al,0x1
  2119d2:	86 05 38 f6 03 00    	xchg   BYTE PTR [rip+0x3f638],al        # 251010 <stderr_mutex>
  2119d8:	84 c0                	test   al,al
  2119da:	75 f4                	jne    2119d0 <Bm.volatile.add+0x7e0>
    if (stderr_stream) |st| {
  2119dc:	48 8b 3d 25 f6 03 00 	mov    rdi,QWORD PTR [rip+0x3f625]        # 251008 <stderr_stream>
  2119e3:	48 85 ff             	test   rdi,rdi
  2119e6:	74 09                	je     2119f1 <Bm.volatile.add+0x801>
  2119e8:	48 8b 0d 51 a6 03 00 	mov    rcx,QWORD PTR [rip+0x3a651]        # 24c040 <stderr_file_out_stream+0x8>
  2119ef:	eb 3d                	jmp    211a2e <Bm.volatile.add+0x83e>
        stderr_file = try io.getStdErr();
  2119f1:	c7 05 35 a6 03 00 02 	mov    DWORD PTR [rip+0x3a635],0x2        # 24c030 <stderr_file>
  2119f8:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  2119fb:	48 8d 05 2e a6 03 00 	lea    rax,[rip+0x3a62e]        # 24c030 <stderr_file>
  211a02:	48 89 05 2f a6 03 00 	mov    QWORD PTR [rip+0x3a62f],rax        # 24c038 <stderr_file_out_stream>
  211a09:	48 8d 05 90 d4 00 00 	lea    rax,[rip+0xd490]        # 21eea0 <FileOutStream_writeFn>
  211a10:	48 89 05 29 a6 03 00 	mov    QWORD PTR [rip+0x3a629],rax        # 24c040 <stderr_file_out_stream+0x8>
  211a17:	48 8d 0d 22 a6 03 00 	lea    rcx,[rip+0x3a622]        # 24c040 <stderr_file_out_stream+0x8>
  211a1e:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  211a21:	48 89 15 e0 f5 03 00 	mov    QWORD PTR [rip+0x3f5e0],rdx        # 251008 <stderr_stream>
  211a28:	48 89 c1             	mov    rcx,rax
  211a2b:	48 89 d7             	mov    rdi,rdx
  211a2e:	c6 44 24 07 20       	mov    BYTE PTR [rsp+0x7],0x20
  211a33:	48 89 6c 24 20       	mov    QWORD PTR [rsp+0x20],rbp
  211a38:	48 c7 44 24 28 01 00 	mov    QWORD PTR [rsp+0x28],0x1
  211a3f:	00 00 
  211a41:	4c 89 f6             	mov    rsi,r14
  211a44:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  211a46:	31 c0                	xor    eax,eax
  211a48:	86 05 c2 f5 03 00    	xchg   BYTE PTR [rip+0x3f5c2],al        # 251010 <stderr_mutex>
  211a4e:	3c 01                	cmp    al,0x1
    if (!ok) {
  211a50:	0f 85 76 05 00 00    	jne    211fcc <Bm.volatile.add+0xddc>
  211a56:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  211a5d:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  211a60:	b0 01                	mov    al,0x1
  211a62:	86 05 a8 f5 03 00    	xchg   BYTE PTR [rip+0x3f5a8],al        # 251010 <stderr_mutex>
  211a68:	84 c0                	test   al,al
  211a6a:	75 f4                	jne    211a60 <Bm.volatile.add+0x870>
    if (stderr_stream) |st| {
  211a6c:	48 8b 3d 95 f5 03 00 	mov    rdi,QWORD PTR [rip+0x3f595]        # 251008 <stderr_stream>
  211a73:	48 85 ff             	test   rdi,rdi
  211a76:	74 09                	je     211a81 <Bm.volatile.add+0x891>
  211a78:	48 8b 0d c1 a5 03 00 	mov    rcx,QWORD PTR [rip+0x3a5c1]        # 24c040 <stderr_file_out_stream+0x8>
  211a7f:	eb 3d                	jmp    211abe <Bm.volatile.add+0x8ce>
        stderr_file = try io.getStdErr();
  211a81:	c7 05 a5 a5 03 00 02 	mov    DWORD PTR [rip+0x3a5a5],0x2        # 24c030 <stderr_file>
  211a88:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  211a8b:	48 8d 05 9e a5 03 00 	lea    rax,[rip+0x3a59e]        # 24c030 <stderr_file>
  211a92:	48 89 05 9f a5 03 00 	mov    QWORD PTR [rip+0x3a59f],rax        # 24c038 <stderr_file_out_stream>
  211a99:	48 8d 05 00 d4 00 00 	lea    rax,[rip+0xd400]        # 21eea0 <FileOutStream_writeFn>
  211aa0:	48 89 05 99 a5 03 00 	mov    QWORD PTR [rip+0x3a599],rax        # 24c040 <stderr_file_out_stream+0x8>
  211aa7:	48 8d 0d 92 a5 03 00 	lea    rcx,[rip+0x3a592]        # 24c040 <stderr_file_out_stream+0x8>
  211aae:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  211ab1:	48 89 15 50 f5 03 00 	mov    QWORD PTR [rip+0x3f550],rdx        # 251008 <stderr_stream>
  211ab8:	48 89 c1             	mov    rcx,rax
  211abb:	48 89 d7             	mov    rdi,rdx
  211abe:	c6 44 24 07 20       	mov    BYTE PTR [rsp+0x7],0x20
  211ac3:	48 89 6c 24 20       	mov    QWORD PTR [rsp+0x20],rbp
  211ac8:	48 c7 44 24 28 01 00 	mov    QWORD PTR [rsp+0x28],0x1
  211acf:	00 00 
  211ad1:	4c 89 f6             	mov    rsi,r14
  211ad4:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  211ad6:	31 c0                	xor    eax,eax
  211ad8:	86 05 32 f5 03 00    	xchg   BYTE PTR [rip+0x3f532],al        # 251010 <stderr_mutex>
  211ade:	3c 01                	cmp    al,0x1
    if (!ok) {
  211ae0:	0f 85 e6 04 00 00    	jne    211fcc <Bm.volatile.add+0xddc>
  211ae6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  211aed:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  211af0:	b0 01                	mov    al,0x1
  211af2:	86 05 18 f5 03 00    	xchg   BYTE PTR [rip+0x3f518],al        # 251010 <stderr_mutex>
  211af8:	84 c0                	test   al,al
  211afa:	75 f4                	jne    211af0 <Bm.volatile.add+0x900>
    if (stderr_stream) |st| {
  211afc:	48 8b 3d 05 f5 03 00 	mov    rdi,QWORD PTR [rip+0x3f505]        # 251008 <stderr_stream>
  211b03:	48 85 ff             	test   rdi,rdi
  211b06:	74 09                	je     211b11 <Bm.volatile.add+0x921>
  211b08:	48 8b 0d 31 a5 03 00 	mov    rcx,QWORD PTR [rip+0x3a531]        # 24c040 <stderr_file_out_stream+0x8>
  211b0f:	eb 3d                	jmp    211b4e <Bm.volatile.add+0x95e>
        stderr_file = try io.getStdErr();
  211b11:	c7 05 15 a5 03 00 02 	mov    DWORD PTR [rip+0x3a515],0x2        # 24c030 <stderr_file>
  211b18:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  211b1b:	48 8d 05 0e a5 03 00 	lea    rax,[rip+0x3a50e]        # 24c030 <stderr_file>
  211b22:	48 89 05 0f a5 03 00 	mov    QWORD PTR [rip+0x3a50f],rax        # 24c038 <stderr_file_out_stream>
  211b29:	48 8d 05 70 d3 00 00 	lea    rax,[rip+0xd370]        # 21eea0 <FileOutStream_writeFn>
  211b30:	48 89 05 09 a5 03 00 	mov    QWORD PTR [rip+0x3a509],rax        # 24c040 <stderr_file_out_stream+0x8>
  211b37:	48 8d 0d 02 a5 03 00 	lea    rcx,[rip+0x3a502]        # 24c040 <stderr_file_out_stream+0x8>
  211b3e:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  211b41:	48 89 15 c0 f4 03 00 	mov    QWORD PTR [rip+0x3f4c0],rdx        # 251008 <stderr_stream>
  211b48:	48 89 c1             	mov    rcx,rax
  211b4b:	48 89 d7             	mov    rdi,rdx
  211b4e:	c6 44 24 07 20       	mov    BYTE PTR [rsp+0x7],0x20
  211b53:	48 89 6c 24 20       	mov    QWORD PTR [rsp+0x20],rbp
  211b58:	48 c7 44 24 28 01 00 	mov    QWORD PTR [rsp+0x28],0x1
  211b5f:	00 00 
  211b61:	4c 89 f6             	mov    rsi,r14
  211b64:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  211b66:	31 c0                	xor    eax,eax
  211b68:	86 05 a2 f4 03 00    	xchg   BYTE PTR [rip+0x3f4a2],al        # 251010 <stderr_mutex>
  211b6e:	3c 01                	cmp    al,0x1
    if (!ok) {
  211b70:	0f 85 56 04 00 00    	jne    211fcc <Bm.volatile.add+0xddc>
  211b76:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  211b7d:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  211b80:	b0 01                	mov    al,0x1
  211b82:	86 05 88 f4 03 00    	xchg   BYTE PTR [rip+0x3f488],al        # 251010 <stderr_mutex>
  211b88:	84 c0                	test   al,al
  211b8a:	75 f4                	jne    211b80 <Bm.volatile.add+0x990>
    if (stderr_stream) |st| {
  211b8c:	48 8b 3d 75 f4 03 00 	mov    rdi,QWORD PTR [rip+0x3f475]        # 251008 <stderr_stream>
  211b93:	48 85 ff             	test   rdi,rdi
  211b96:	74 09                	je     211ba1 <Bm.volatile.add+0x9b1>
  211b98:	48 8b 0d a1 a4 03 00 	mov    rcx,QWORD PTR [rip+0x3a4a1]        # 24c040 <stderr_file_out_stream+0x8>
  211b9f:	eb 3d                	jmp    211bde <Bm.volatile.add+0x9ee>
        stderr_file = try io.getStdErr();
  211ba1:	c7 05 85 a4 03 00 02 	mov    DWORD PTR [rip+0x3a485],0x2        # 24c030 <stderr_file>
  211ba8:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  211bab:	48 8d 05 7e a4 03 00 	lea    rax,[rip+0x3a47e]        # 24c030 <stderr_file>
  211bb2:	48 89 05 7f a4 03 00 	mov    QWORD PTR [rip+0x3a47f],rax        # 24c038 <stderr_file_out_stream>
  211bb9:	48 8d 05 e0 d2 00 00 	lea    rax,[rip+0xd2e0]        # 21eea0 <FileOutStream_writeFn>
  211bc0:	48 89 05 79 a4 03 00 	mov    QWORD PTR [rip+0x3a479],rax        # 24c040 <stderr_file_out_stream+0x8>
  211bc7:	48 8d 0d 72 a4 03 00 	lea    rcx,[rip+0x3a472]        # 24c040 <stderr_file_out_stream+0x8>
  211bce:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  211bd1:	48 89 15 30 f4 03 00 	mov    QWORD PTR [rip+0x3f430],rdx        # 251008 <stderr_stream>
  211bd8:	48 89 c1             	mov    rcx,rax
  211bdb:	48 89 d7             	mov    rdi,rdx
  211bde:	c6 44 24 07 20       	mov    BYTE PTR [rsp+0x7],0x20
  211be3:	48 89 6c 24 20       	mov    QWORD PTR [rsp+0x20],rbp
  211be8:	48 c7 44 24 28 01 00 	mov    QWORD PTR [rsp+0x28],0x1
  211bef:	00 00 
  211bf1:	4c 89 f6             	mov    rsi,r14
  211bf4:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  211bf6:	31 c0                	xor    eax,eax
  211bf8:	86 05 12 f4 03 00    	xchg   BYTE PTR [rip+0x3f412],al        # 251010 <stderr_mutex>
  211bfe:	3c 01                	cmp    al,0x1
    if (!ok) {
  211c00:	0f 85 c6 03 00 00    	jne    211fcc <Bm.volatile.add+0xddc>
  211c06:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  211c0d:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  211c10:	b0 01                	mov    al,0x1
  211c12:	86 05 f8 f3 03 00    	xchg   BYTE PTR [rip+0x3f3f8],al        # 251010 <stderr_mutex>
  211c18:	84 c0                	test   al,al
  211c1a:	75 f4                	jne    211c10 <Bm.volatile.add+0xa20>
    if (stderr_stream) |st| {
  211c1c:	48 8b 3d e5 f3 03 00 	mov    rdi,QWORD PTR [rip+0x3f3e5]        # 251008 <stderr_stream>
  211c23:	48 85 ff             	test   rdi,rdi
  211c26:	74 09                	je     211c31 <Bm.volatile.add+0xa41>
  211c28:	48 8b 0d 11 a4 03 00 	mov    rcx,QWORD PTR [rip+0x3a411]        # 24c040 <stderr_file_out_stream+0x8>
  211c2f:	eb 3d                	jmp    211c6e <Bm.volatile.add+0xa7e>
        stderr_file = try io.getStdErr();
  211c31:	c7 05 f5 a3 03 00 02 	mov    DWORD PTR [rip+0x3a3f5],0x2        # 24c030 <stderr_file>
  211c38:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  211c3b:	48 8d 05 ee a3 03 00 	lea    rax,[rip+0x3a3ee]        # 24c030 <stderr_file>
  211c42:	48 89 05 ef a3 03 00 	mov    QWORD PTR [rip+0x3a3ef],rax        # 24c038 <stderr_file_out_stream>
  211c49:	48 8d 05 50 d2 00 00 	lea    rax,[rip+0xd250]        # 21eea0 <FileOutStream_writeFn>
  211c50:	48 89 05 e9 a3 03 00 	mov    QWORD PTR [rip+0x3a3e9],rax        # 24c040 <stderr_file_out_stream+0x8>
  211c57:	48 8d 0d e2 a3 03 00 	lea    rcx,[rip+0x3a3e2]        # 24c040 <stderr_file_out_stream+0x8>
  211c5e:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  211c61:	48 89 15 a0 f3 03 00 	mov    QWORD PTR [rip+0x3f3a0],rdx        # 251008 <stderr_stream>
  211c68:	48 89 c1             	mov    rcx,rax
  211c6b:	48 89 d7             	mov    rdi,rdx
  211c6e:	c6 44 24 07 20       	mov    BYTE PTR [rsp+0x7],0x20
  211c73:	48 89 6c 24 20       	mov    QWORD PTR [rsp+0x20],rbp
  211c78:	48 c7 44 24 28 01 00 	mov    QWORD PTR [rsp+0x28],0x1
  211c7f:	00 00 
  211c81:	4c 89 f6             	mov    rsi,r14
  211c84:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  211c86:	31 c0                	xor    eax,eax
  211c88:	86 05 82 f3 03 00    	xchg   BYTE PTR [rip+0x3f382],al        # 251010 <stderr_mutex>
  211c8e:	3c 01                	cmp    al,0x1
    if (!ok) {
  211c90:	0f 85 36 03 00 00    	jne    211fcc <Bm.volatile.add+0xddc>
  211c96:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  211c9d:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  211ca0:	b0 01                	mov    al,0x1
  211ca2:	86 05 68 f3 03 00    	xchg   BYTE PTR [rip+0x3f368],al        # 251010 <stderr_mutex>
  211ca8:	84 c0                	test   al,al
  211caa:	75 f4                	jne    211ca0 <Bm.volatile.add+0xab0>
    if (stderr_stream) |st| {
  211cac:	48 8b 3d 55 f3 03 00 	mov    rdi,QWORD PTR [rip+0x3f355]        # 251008 <stderr_stream>
  211cb3:	48 85 ff             	test   rdi,rdi
  211cb6:	74 09                	je     211cc1 <Bm.volatile.add+0xad1>
  211cb8:	48 8b 0d 81 a3 03 00 	mov    rcx,QWORD PTR [rip+0x3a381]        # 24c040 <stderr_file_out_stream+0x8>
  211cbf:	eb 3d                	jmp    211cfe <Bm.volatile.add+0xb0e>
        stderr_file = try io.getStdErr();
  211cc1:	c7 05 65 a3 03 00 02 	mov    DWORD PTR [rip+0x3a365],0x2        # 24c030 <stderr_file>
  211cc8:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  211ccb:	48 8d 05 5e a3 03 00 	lea    rax,[rip+0x3a35e]        # 24c030 <stderr_file>
  211cd2:	48 89 05 5f a3 03 00 	mov    QWORD PTR [rip+0x3a35f],rax        # 24c038 <stderr_file_out_stream>
  211cd9:	48 8d 05 c0 d1 00 00 	lea    rax,[rip+0xd1c0]        # 21eea0 <FileOutStream_writeFn>
  211ce0:	48 89 05 59 a3 03 00 	mov    QWORD PTR [rip+0x3a359],rax        # 24c040 <stderr_file_out_stream+0x8>
  211ce7:	48 8d 0d 52 a3 03 00 	lea    rcx,[rip+0x3a352]        # 24c040 <stderr_file_out_stream+0x8>
  211cee:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  211cf1:	48 89 15 10 f3 03 00 	mov    QWORD PTR [rip+0x3f310],rdx        # 251008 <stderr_stream>
  211cf8:	48 89 c1             	mov    rcx,rax
  211cfb:	48 89 d7             	mov    rdi,rdx
  211cfe:	c6 44 24 07 20       	mov    BYTE PTR [rsp+0x7],0x20
  211d03:	48 89 6c 24 20       	mov    QWORD PTR [rsp+0x20],rbp
  211d08:	48 c7 44 24 28 01 00 	mov    QWORD PTR [rsp+0x28],0x1
  211d0f:	00 00 
  211d11:	4c 89 f6             	mov    rsi,r14
  211d14:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  211d16:	31 c0                	xor    eax,eax
  211d18:	86 05 f2 f2 03 00    	xchg   BYTE PTR [rip+0x3f2f2],al        # 251010 <stderr_mutex>
  211d1e:	3c 01                	cmp    al,0x1
    if (!ok) {
  211d20:	0f 85 a6 02 00 00    	jne    211fcc <Bm.volatile.add+0xddc>
  211d26:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  211d2d:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  211d30:	b0 01                	mov    al,0x1
  211d32:	86 05 d8 f2 03 00    	xchg   BYTE PTR [rip+0x3f2d8],al        # 251010 <stderr_mutex>
  211d38:	84 c0                	test   al,al
  211d3a:	75 f4                	jne    211d30 <Bm.volatile.add+0xb40>
    if (stderr_stream) |st| {
  211d3c:	48 8b 3d c5 f2 03 00 	mov    rdi,QWORD PTR [rip+0x3f2c5]        # 251008 <stderr_stream>
  211d43:	48 85 ff             	test   rdi,rdi
  211d46:	74 09                	je     211d51 <Bm.volatile.add+0xb61>
  211d48:	48 8b 0d f1 a2 03 00 	mov    rcx,QWORD PTR [rip+0x3a2f1]        # 24c040 <stderr_file_out_stream+0x8>
  211d4f:	eb 3d                	jmp    211d8e <Bm.volatile.add+0xb9e>
        stderr_file = try io.getStdErr();
  211d51:	c7 05 d5 a2 03 00 02 	mov    DWORD PTR [rip+0x3a2d5],0x2        # 24c030 <stderr_file>
  211d58:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  211d5b:	48 8d 05 ce a2 03 00 	lea    rax,[rip+0x3a2ce]        # 24c030 <stderr_file>
  211d62:	48 89 05 cf a2 03 00 	mov    QWORD PTR [rip+0x3a2cf],rax        # 24c038 <stderr_file_out_stream>
  211d69:	48 8d 05 30 d1 00 00 	lea    rax,[rip+0xd130]        # 21eea0 <FileOutStream_writeFn>
  211d70:	48 89 05 c9 a2 03 00 	mov    QWORD PTR [rip+0x3a2c9],rax        # 24c040 <stderr_file_out_stream+0x8>
  211d77:	48 8d 0d c2 a2 03 00 	lea    rcx,[rip+0x3a2c2]        # 24c040 <stderr_file_out_stream+0x8>
  211d7e:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  211d81:	48 89 15 80 f2 03 00 	mov    QWORD PTR [rip+0x3f280],rdx        # 251008 <stderr_stream>
  211d88:	48 89 c1             	mov    rcx,rax
  211d8b:	48 89 d7             	mov    rdi,rdx
  211d8e:	c6 44 24 07 20       	mov    BYTE PTR [rsp+0x7],0x20
  211d93:	48 89 6c 24 20       	mov    QWORD PTR [rsp+0x20],rbp
  211d98:	48 c7 44 24 28 01 00 	mov    QWORD PTR [rsp+0x28],0x1
  211d9f:	00 00 
  211da1:	4c 89 f6             	mov    rsi,r14
  211da4:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  211da6:	31 c0                	xor    eax,eax
  211da8:	86 05 62 f2 03 00    	xchg   BYTE PTR [rip+0x3f262],al        # 251010 <stderr_mutex>
  211dae:	3c 01                	cmp    al,0x1
    if (!ok) {
  211db0:	0f 85 16 02 00 00    	jne    211fcc <Bm.volatile.add+0xddc>
  211db6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  211dbd:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  211dc0:	b0 01                	mov    al,0x1
  211dc2:	86 05 48 f2 03 00    	xchg   BYTE PTR [rip+0x3f248],al        # 251010 <stderr_mutex>
  211dc8:	84 c0                	test   al,al
  211dca:	75 f4                	jne    211dc0 <Bm.volatile.add+0xbd0>
    if (stderr_stream) |st| {
  211dcc:	48 8b 3d 35 f2 03 00 	mov    rdi,QWORD PTR [rip+0x3f235]        # 251008 <stderr_stream>
  211dd3:	48 85 ff             	test   rdi,rdi
  211dd6:	74 09                	je     211de1 <Bm.volatile.add+0xbf1>
  211dd8:	48 8b 0d 61 a2 03 00 	mov    rcx,QWORD PTR [rip+0x3a261]        # 24c040 <stderr_file_out_stream+0x8>
  211ddf:	eb 3d                	jmp    211e1e <Bm.volatile.add+0xc2e>
        stderr_file = try io.getStdErr();
  211de1:	c7 05 45 a2 03 00 02 	mov    DWORD PTR [rip+0x3a245],0x2        # 24c030 <stderr_file>
  211de8:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  211deb:	48 8d 05 3e a2 03 00 	lea    rax,[rip+0x3a23e]        # 24c030 <stderr_file>
  211df2:	48 89 05 3f a2 03 00 	mov    QWORD PTR [rip+0x3a23f],rax        # 24c038 <stderr_file_out_stream>
  211df9:	48 8d 05 a0 d0 00 00 	lea    rax,[rip+0xd0a0]        # 21eea0 <FileOutStream_writeFn>
  211e00:	48 89 05 39 a2 03 00 	mov    QWORD PTR [rip+0x3a239],rax        # 24c040 <stderr_file_out_stream+0x8>
  211e07:	48 8d 0d 32 a2 03 00 	lea    rcx,[rip+0x3a232]        # 24c040 <stderr_file_out_stream+0x8>
  211e0e:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  211e11:	48 89 15 f0 f1 03 00 	mov    QWORD PTR [rip+0x3f1f0],rdx        # 251008 <stderr_stream>
  211e18:	48 89 c1             	mov    rcx,rax
  211e1b:	48 89 d7             	mov    rdi,rdx
                const casted_value = ([]const u8)(value);
  211e1e:	4c 89 7c 24 20       	mov    QWORD PTR [rsp+0x20],r15
  211e23:	48 c7 44 24 28 04 00 	mov    QWORD PTR [rsp+0x28],0x4
  211e2a:	00 00 
                return output(context, casted_value);
  211e2c:	4c 89 f6             	mov    rsi,r14
  211e2f:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  211e31:	31 c0                	xor    eax,eax
  211e33:	86 05 d7 f1 03 00    	xchg   BYTE PTR [rip+0x3f1d7],al        # 251010 <stderr_mutex>
  211e39:	3c 01                	cmp    al,0x1
    if (!ok) {
  211e3b:	0f 85 8b 01 00 00    	jne    211fcc <Bm.volatile.add+0xddc>
                try rightJustified(18, "{}", "time/operation");
  211e41:	e8 da 3a 00 00       	call   215920 <Benchmark_rightJustified.39>
  211e46:	66 85 c0             	test   ax,ax
  211e49:	0f 85 65 01 00 00    	jne    211fb4 <Bm.volatile.add+0xdc4>
  211e4f:	90                   	nop
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  211e50:	b0 01                	mov    al,0x1
  211e52:	86 05 b8 f1 03 00    	xchg   BYTE PTR [rip+0x3f1b8],al        # 251010 <stderr_mutex>
  211e58:	84 c0                	test   al,al
  211e5a:	75 f4                	jne    211e50 <Bm.volatile.add+0xc60>
    if (stderr_stream) |st| {
  211e5c:	48 8b 3d a5 f1 03 00 	mov    rdi,QWORD PTR [rip+0x3f1a5]        # 251008 <stderr_stream>
  211e63:	48 85 ff             	test   rdi,rdi
  211e66:	74 09                	je     211e71 <Bm.volatile.add+0xc81>
  211e68:	48 8b 0d d1 a1 03 00 	mov    rcx,QWORD PTR [rip+0x3a1d1]        # 24c040 <stderr_file_out_stream+0x8>
  211e6f:	eb 3d                	jmp    211eae <Bm.volatile.add+0xcbe>
        stderr_file = try io.getStdErr();
  211e71:	c7 05 b5 a1 03 00 02 	mov    DWORD PTR [rip+0x3a1b5],0x2        # 24c030 <stderr_file>
  211e78:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  211e7b:	48 8d 05 ae a1 03 00 	lea    rax,[rip+0x3a1ae]        # 24c030 <stderr_file>
  211e82:	48 89 05 af a1 03 00 	mov    QWORD PTR [rip+0x3a1af],rax        # 24c038 <stderr_file_out_stream>
  211e89:	48 8d 05 10 d0 00 00 	lea    rax,[rip+0xd010]        # 21eea0 <FileOutStream_writeFn>
  211e90:	48 89 05 a9 a1 03 00 	mov    QWORD PTR [rip+0x3a1a9],rax        # 24c040 <stderr_file_out_stream+0x8>
  211e97:	48 8d 0d a2 a1 03 00 	lea    rcx,[rip+0x3a1a2]        # 24c040 <stderr_file_out_stream+0x8>
  211e9e:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  211ea1:	48 89 15 60 f1 03 00 	mov    QWORD PTR [rip+0x3f160],rdx        # 251008 <stderr_stream>
  211ea8:	48 89 c1             	mov    rcx,rax
  211eab:	48 89 d7             	mov    rdi,rdx
        try output(context, fmt[start_index..]);
  211eae:	48 8d 35 3b e0 03 00 	lea    rsi,[rip+0x3e03b]        # 24fef0 <__unnamed_3>
  211eb5:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  211eb7:	31 c0                	xor    eax,eax
  211eb9:	86 05 51 f1 03 00    	xchg   BYTE PTR [rip+0x3f151],al        # 251010 <stderr_mutex>
  211ebf:	3c 01                	cmp    al,0x1
    if (!ok) {
  211ec1:	0f 85 05 01 00 00    	jne    211fcc <Bm.volatile.add+0xddc>
            try pSelf.report(pSelf.results.items[pSelf.results.len - 1]); warn("\n");
  211ec7:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  211ece:	00 
  211ecf:	48 8b 8c 24 b8 00 00 	mov    rcx,QWORD PTR [rsp+0xb8]
  211ed6:	00 
  211ed7:	48 c1 e1 04          	shl    rcx,0x4
  211edb:	48 8d 34 08          	lea    rsi,[rax+rcx*1]
  211edf:	48 83 c6 f0          	add    rsi,0xfffffffffffffff0
  211ee3:	48 8d 7c 24 60       	lea    rdi,[rsp+0x60]
  211ee8:	e8 33 10 00 00       	call   212f20 <Benchmark_report>
  211eed:	66 85 c0             	test   ax,ax
  211ef0:	0f 85 be 00 00 00    	jne    211fb4 <Bm.volatile.add+0xdc4>
  211ef6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  211efd:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  211f00:	b0 01                	mov    al,0x1
  211f02:	86 05 08 f1 03 00    	xchg   BYTE PTR [rip+0x3f108],al        # 251010 <stderr_mutex>
  211f08:	84 c0                	test   al,al
  211f0a:	75 f4                	jne    211f00 <Bm.volatile.add+0xd10>
    if (stderr_stream) |st| {
  211f0c:	48 8b 3d f5 f0 03 00 	mov    rdi,QWORD PTR [rip+0x3f0f5]        # 251008 <stderr_stream>
  211f13:	48 85 ff             	test   rdi,rdi
  211f16:	74 09                	je     211f21 <Bm.volatile.add+0xd31>
  211f18:	48 8b 0d 21 a1 03 00 	mov    rcx,QWORD PTR [rip+0x3a121]        # 24c040 <stderr_file_out_stream+0x8>
  211f1f:	eb 3d                	jmp    211f5e <Bm.volatile.add+0xd6e>
        stderr_file = try io.getStdErr();
  211f21:	c7 05 05 a1 03 00 02 	mov    DWORD PTR [rip+0x3a105],0x2        # 24c030 <stderr_file>
  211f28:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  211f2b:	48 8d 05 fe a0 03 00 	lea    rax,[rip+0x3a0fe]        # 24c030 <stderr_file>
  211f32:	48 89 05 ff a0 03 00 	mov    QWORD PTR [rip+0x3a0ff],rax        # 24c038 <stderr_file_out_stream>
  211f39:	48 8d 05 60 cf 00 00 	lea    rax,[rip+0xcf60]        # 21eea0 <FileOutStream_writeFn>
  211f40:	48 89 05 f9 a0 03 00 	mov    QWORD PTR [rip+0x3a0f9],rax        # 24c040 <stderr_file_out_stream+0x8>
  211f47:	48 8d 0d f2 a0 03 00 	lea    rcx,[rip+0x3a0f2]        # 24c040 <stderr_file_out_stream+0x8>
  211f4e:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  211f51:	48 89 15 b0 f0 03 00 	mov    QWORD PTR [rip+0x3f0b0],rdx        # 251008 <stderr_stream>
  211f58:	48 89 c1             	mov    rcx,rax
  211f5b:	48 89 d7             	mov    rdi,rdx
  211f5e:	48 8d 35 8b df 03 00 	lea    rsi,[rip+0x3df8b]        # 24fef0 <__unnamed_3>
  211f65:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  211f67:	31 c0                	xor    eax,eax
  211f69:	86 05 a1 f0 03 00    	xchg   BYTE PTR [rip+0x3f0a1],al        # 251010 <stderr_mutex>
  211f6f:	3c 01                	cmp    al,0x1
    if (!ok) {
  211f71:	75 59                	jne    211fcc <Bm.volatile.add+0xddc>
  211f73:	49 83 c5 01          	add    r13,0x1
  211f77:	45 31 f6             	xor    r14d,r14d
        while (rep < pSelf.repetitions) : (rep += 1) {
  211f7a:	4c 3b ac 24 80 00 00 	cmp    r13,QWORD PTR [rsp+0x80]
  211f81:	00 
  211f82:	c5 f8 10 0d 86 e3 fe 	vmovups xmm1,XMMWORD PTR [rip+0xfffffffffffee386]        # 200310 <__unnamed_35>
  211f89:	ff 
  211f8a:	0f 82 8b f3 ff ff    	jb     21131b <Bm.volatile.add+0x12b>
  211f90:	48 8d 7c 24 60       	lea    rdi,[rsp+0x60]
        try pSelf.reportStats(pSelf.results);
  211f95:	48 8d b4 24 a8 00 00 	lea    rsi,[rsp+0xa8]
  211f9c:	00 
  211f9d:	e8 5e 3c 00 00       	call   215c00 <Benchmark_reportStats>
  211fa2:	eb 10                	jmp    211fb4 <Bm.volatile.add+0xdc4>
                switch (errno) {
  211fa4:	48 83 f9 16          	cmp    rcx,0x16
  211fa8:	75 06                	jne    211fb0 <Bm.volatile.add+0xdc0>
  211faa:	66 b8 02 00          	mov    ax,0x2
  211fae:	eb 04                	jmp    211fb4 <Bm.volatile.add+0xdc4>
  211fb0:	66 b8 03 00          	mov    ax,0x3
    _ = try bm.run(BmAdd);
  211fb4:	48 81 c4 08 01 00 00 	add    rsp,0x108
  211fbb:	5b                   	pop    rbx
  211fbc:	41 5c                	pop    r12
  211fbe:	41 5d                	pop    r13
  211fc0:	41 5e                	pop    r14
  211fc2:	41 5f                	pop    r15
  211fc4:	5d                   	pop    rbp
  211fc5:	c3                   	ret    
  211fc6:	66 b8 06 00          	mov    ax,0x6
  211fca:	eb e8                	jmp    211fb4 <Bm.volatile.add+0xdc4>
            @panic("assertion failure");
  211fcc:	48 8d 3d bd dd 03 00 	lea    rdi,[rip+0x3ddbd]        # 24fd90 <__unnamed_2>
  211fd3:	e8 48 07 00 00       	call   212720 <panic>
  211fd8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  211fdf:	00 

0000000000211fe0 <BmError.benchmark>:
}

test "BmError.benchmark" {
  211fe0:	48 83 ec 18          	sub    rsp,0x18
  211fe4:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  211feb:	00 00 00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  211ff0:	b0 01                	mov    al,0x1
  211ff2:	86 05 18 f0 03 00    	xchg   BYTE PTR [rip+0x3f018],al        # 251010 <stderr_mutex>
  211ff8:	84 c0                	test   al,al
  211ffa:	75 f4                	jne    211ff0 <BmError.benchmark+0x10>
    if (stderr_stream) |st| {
  211ffc:	48 8b 3d 05 f0 03 00 	mov    rdi,QWORD PTR [rip+0x3f005]        # 251008 <stderr_stream>
  212003:	48 85 ff             	test   rdi,rdi
  212006:	74 09                	je     212011 <BmError.benchmark+0x31>
  212008:	48 8b 05 31 a0 03 00 	mov    rax,QWORD PTR [rip+0x3a031]        # 24c040 <stderr_file_out_stream+0x8>
  21200f:	eb 34                	jmp    212045 <BmError.benchmark+0x65>
        stderr_file = try io.getStdErr();
  212011:	48 8d 05 18 a0 03 00 	lea    rax,[rip+0x3a018]        # 24c030 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  212018:	48 89 05 19 a0 03 00 	mov    QWORD PTR [rip+0x3a019],rax        # 24c038 <stderr_file_out_stream>
  21201f:	48 8d 05 7a ce 00 00 	lea    rax,[rip+0xce7a]        # 21eea0 <FileOutStream_writeFn>
  212026:	48 89 05 13 a0 03 00 	mov    QWORD PTR [rip+0x3a013],rax        # 24c040 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  21202d:	c7 05 f9 9f 03 00 02 	mov    DWORD PTR [rip+0x39ff9],0x2        # 24c030 <stderr_file>
  212034:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  212037:	48 8d 3d 02 a0 03 00 	lea    rdi,[rip+0x3a002]        # 24c040 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  21203e:	48 89 3d c3 ef 03 00 	mov    QWORD PTR [rip+0x3efc3],rdi        # 251008 <stderr_stream>
  212045:	48 8d 35 a4 de 03 00 	lea    rsi,[rip+0x3dea4]        # 24fef0 <__unnamed_3>
  21204c:	ff d0                	call   rax
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  21204e:	31 c0                	xor    eax,eax
  212050:	86 05 ba ef 03 00    	xchg   BYTE PTR [rip+0x3efba],al        # 251010 <stderr_mutex>
  212056:	3c 01                	cmp    al,0x1
    if (!ok) {
  212058:	75 76                	jne    2120d0 <BmError.benchmark+0xf0>
                var ts: posix.timespec = undefined;
  21205a:	c5 f8 10 05 ae e2 fe 	vmovups xmm0,XMMWORD PTR [rip+0xfffffffffffee2ae]        # 200310 <__unnamed_35>
  212061:	ff 
  212062:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
  212067:	48 89 e6             	mov    rsi,rsp
  21206a:	b8 e5 00 00 00       	mov    eax,0xe5
  21206f:	bf 01 00 00 00       	mov    edi,0x1
  212074:	0f 05                	syscall 
  212076:	48 89 c2             	mov    rdx,rax
  212079:	48 f7 da             	neg    rdx
  21207c:	31 c9                	xor    ecx,ecx
  21207e:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  212084:	48 0f 47 ca          	cmova  rcx,rdx
                switch (errno) {
  212088:	48 85 c9             	test   rcx,rcx
  21208b:	75 3f                	jne    2120cc <BmError.benchmark+0xec>
        const f = @atomicLoad(@typeOf(init_vdso_clock_gettime), &vdso_clock_gettime, builtin.AtomicOrder.Unordered);
  21208d:	48 8b 05 84 a0 03 00 	mov    rax,QWORD PTR [rip+0x3a084]        # 24c118 <vdso_clock_gettime>
        if (@ptrToInt(f) != 0) {
  212094:	48 85 c0             	test   rax,rax
  212097:	74 15                	je     2120ae <BmError.benchmark+0xce>
  212099:	48 89 e6             	mov    rsi,rsp
            const rc = f(clk_id, tp);
  21209c:	bf 01 00 00 00       	mov    edi,0x1
  2120a1:	ff d0                	call   rax
            switch (rc) {
  2120a3:	48 83 f8 ea          	cmp    rax,0xffffffffffffffea
  2120a7:	74 14                	je     2120bd <BmError.benchmark+0xdd>
  2120a9:	48 85 c0             	test   rax,rax
  2120ac:	74 0f                	je     2120bd <BmError.benchmark+0xdd>
  2120ae:	48 89 e6             	mov    rsi,rsp
  2120b1:	b8 e4 00 00 00       	mov    eax,0xe4
  2120b6:	bf 01 00 00 00       	mov    edi,0x1
  2120bb:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  2120bd:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
}

/// TODO: add `==` operator for `error_union == error_set`, and then
/// remove this function
pub fn assertError(value: var, expected_error: error) void {
    if (value) {
  2120c3:	73 0b                	jae    2120d0 <BmError.benchmark+0xf0>
  2120c5:	31 c0                	xor    eax,eax
  2120c7:	48 83 c4 18          	add    rsp,0x18
  2120cb:	c3                   	ret    
  2120cc:	48 83 f9 16          	cmp    rcx,0x16
            @panic("assertion failure");
  2120d0:	48 8d 3d b9 dc 03 00 	lea    rdi,[rip+0x3dcb9]        # 24fd90 <__unnamed_2>
  2120d7:	e8 44 06 00 00       	call   212720 <panic>
  2120dc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

00000000002120e0 <BmError.init_error.setup.tearDown>:
            return error.BenchmarkError;
        }
    }), error.BenchmarkError);
}

test "BmError.init_error.setup.tearDown" {
  2120e0:	50                   	push   rax
  2120e1:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  2120e8:	0f 1f 84 00 00 00 00 
  2120ef:	00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  2120f0:	b0 01                	mov    al,0x1
  2120f2:	86 05 18 ef 03 00    	xchg   BYTE PTR [rip+0x3ef18],al        # 251010 <stderr_mutex>
  2120f8:	84 c0                	test   al,al
  2120fa:	75 f4                	jne    2120f0 <BmError.init_error.setup.tearDown+0x10>
    if (stderr_stream) |st| {
  2120fc:	48 8b 3d 05 ef 03 00 	mov    rdi,QWORD PTR [rip+0x3ef05]        # 251008 <stderr_stream>
  212103:	48 85 ff             	test   rdi,rdi
  212106:	74 09                	je     212111 <BmError.init_error.setup.tearDown+0x31>
  212108:	48 8b 05 31 9f 03 00 	mov    rax,QWORD PTR [rip+0x39f31]        # 24c040 <stderr_file_out_stream+0x8>
  21210f:	eb 34                	jmp    212145 <BmError.init_error.setup.tearDown+0x65>
        stderr_file = try io.getStdErr();
  212111:	48 8d 05 18 9f 03 00 	lea    rax,[rip+0x39f18]        # 24c030 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  212118:	48 89 05 19 9f 03 00 	mov    QWORD PTR [rip+0x39f19],rax        # 24c038 <stderr_file_out_stream>
  21211f:	48 8d 05 7a cd 00 00 	lea    rax,[rip+0xcd7a]        # 21eea0 <FileOutStream_writeFn>
  212126:	48 89 05 13 9f 03 00 	mov    QWORD PTR [rip+0x39f13],rax        # 24c040 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  21212d:	c7 05 f9 9e 03 00 02 	mov    DWORD PTR [rip+0x39ef9],0x2        # 24c030 <stderr_file>
  212134:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  212137:	48 8d 3d 02 9f 03 00 	lea    rdi,[rip+0x39f02]        # 24c040 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  21213e:	48 89 3d c3 ee 03 00 	mov    QWORD PTR [rip+0x3eec3],rdi        # 251008 <stderr_stream>
  212145:	48 8d 35 a4 dd 03 00 	lea    rsi,[rip+0x3dda4]        # 24fef0 <__unnamed_3>
  21214c:	ff d0                	call   rax
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  21214e:	31 c0                	xor    eax,eax
  212150:	86 05 ba ee 03 00    	xchg   BYTE PTR [rip+0x3eeba],al        # 251010 <stderr_mutex>
  212156:	3c 01                	cmp    al,0x1
    if (!ok) {
  212158:	75 04                	jne    21215e <BmError.init_error.setup.tearDown+0x7e>
  21215a:	31 c0                	xor    eax,eax
  21215c:	59                   	pop    rcx
  21215d:	c3                   	ret    
            @panic("assertion failure");
  21215e:	48 8d 3d 2b dc 03 00 	lea    rdi,[rip+0x3dc2b]        # 24fd90 <__unnamed_2>
  212165:	e8 b6 05 00 00       	call   212720 <panic>
  21216a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000212170 <BmError.init.setup_error.tearDown>:
    };

    assertError(bm.run(BmSelf), error.InitError);
}

test "BmError.init.setup_error.tearDown" {
  212170:	50                   	push   rax
  212171:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  212178:	0f 1f 84 00 00 00 00 
  21217f:	00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  212180:	b0 01                	mov    al,0x1
  212182:	86 05 88 ee 03 00    	xchg   BYTE PTR [rip+0x3ee88],al        # 251010 <stderr_mutex>
  212188:	84 c0                	test   al,al
  21218a:	75 f4                	jne    212180 <BmError.init.setup_error.tearDown+0x10>
    if (stderr_stream) |st| {
  21218c:	48 8b 3d 75 ee 03 00 	mov    rdi,QWORD PTR [rip+0x3ee75]        # 251008 <stderr_stream>
  212193:	48 85 ff             	test   rdi,rdi
  212196:	74 09                	je     2121a1 <BmError.init.setup_error.tearDown+0x31>
  212198:	48 8b 05 a1 9e 03 00 	mov    rax,QWORD PTR [rip+0x39ea1]        # 24c040 <stderr_file_out_stream+0x8>
  21219f:	eb 34                	jmp    2121d5 <BmError.init.setup_error.tearDown+0x65>
        stderr_file = try io.getStdErr();
  2121a1:	48 8d 05 88 9e 03 00 	lea    rax,[rip+0x39e88]        # 24c030 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  2121a8:	48 89 05 89 9e 03 00 	mov    QWORD PTR [rip+0x39e89],rax        # 24c038 <stderr_file_out_stream>
  2121af:	48 8d 05 ea cc 00 00 	lea    rax,[rip+0xccea]        # 21eea0 <FileOutStream_writeFn>
  2121b6:	48 89 05 83 9e 03 00 	mov    QWORD PTR [rip+0x39e83],rax        # 24c040 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  2121bd:	c7 05 69 9e 03 00 02 	mov    DWORD PTR [rip+0x39e69],0x2        # 24c030 <stderr_file>
  2121c4:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  2121c7:	48 8d 3d 72 9e 03 00 	lea    rdi,[rip+0x39e72]        # 24c040 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  2121ce:	48 89 3d 33 ee 03 00 	mov    QWORD PTR [rip+0x3ee33],rdi        # 251008 <stderr_stream>
  2121d5:	48 8d 35 14 dd 03 00 	lea    rsi,[rip+0x3dd14]        # 24fef0 <__unnamed_3>
  2121dc:	ff d0                	call   rax
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  2121de:	31 c0                	xor    eax,eax
  2121e0:	86 05 2a ee 03 00    	xchg   BYTE PTR [rip+0x3ee2a],al        # 251010 <stderr_mutex>
  2121e6:	3c 01                	cmp    al,0x1
    if (!ok) {
  2121e8:	75 04                	jne    2121ee <BmError.init.setup_error.tearDown+0x7e>
  2121ea:	31 c0                	xor    eax,eax
  2121ec:	59                   	pop    rcx
  2121ed:	c3                   	ret    
            @panic("assertion failure");
  2121ee:	48 8d 3d 9b db 03 00 	lea    rdi,[rip+0x3db9b]        # 24fd90 <__unnamed_2>
  2121f5:	e8 26 05 00 00       	call   212720 <panic>
  2121fa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000212200 <BmError.init.setup.tearDown_error>:
    };

    assertError(bm.run(BmSelf), error.SetupError);
}

test "BmError.init.setup.tearDown_error" {
  212200:	55                   	push   rbp
  212201:	41 57                	push   r15
  212203:	41 56                	push   r14
  212205:	41 55                	push   r13
  212207:	41 54                	push   r12
  212209:	53                   	push   rbx
  21220a:	48 81 ec a8 00 00 00 	sub    rsp,0xa8
  212211:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  212218:	0f 1f 84 00 00 00 00 
  21221f:	00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  212220:	b0 01                	mov    al,0x1
  212222:	86 05 e8 ed 03 00    	xchg   BYTE PTR [rip+0x3ede8],al        # 251010 <stderr_mutex>
  212228:	84 c0                	test   al,al
  21222a:	75 f4                	jne    212220 <BmError.init.setup.tearDown_error+0x20>
    if (stderr_stream) |st| {
  21222c:	48 8b 3d d5 ed 03 00 	mov    rdi,QWORD PTR [rip+0x3edd5]        # 251008 <stderr_stream>
  212233:	48 85 ff             	test   rdi,rdi
  212236:	74 09                	je     212241 <BmError.init.setup.tearDown_error+0x41>
  212238:	48 8b 05 01 9e 03 00 	mov    rax,QWORD PTR [rip+0x39e01]        # 24c040 <stderr_file_out_stream+0x8>
  21223f:	eb 34                	jmp    212275 <BmError.init.setup.tearDown_error+0x75>
        stderr_file = try io.getStdErr();
  212241:	48 8d 05 e8 9d 03 00 	lea    rax,[rip+0x39de8]        # 24c030 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  212248:	48 89 05 e9 9d 03 00 	mov    QWORD PTR [rip+0x39de9],rax        # 24c038 <stderr_file_out_stream>
  21224f:	48 8d 05 4a cc 00 00 	lea    rax,[rip+0xcc4a]        # 21eea0 <FileOutStream_writeFn>
  212256:	48 89 05 e3 9d 03 00 	mov    QWORD PTR [rip+0x39de3],rax        # 24c040 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  21225d:	c7 05 c9 9d 03 00 02 	mov    DWORD PTR [rip+0x39dc9],0x2        # 24c030 <stderr_file>
  212264:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  212267:	48 8d 3d d2 9d 03 00 	lea    rdi,[rip+0x39dd2]        # 24c040 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  21226e:	48 89 3d 93 ed 03 00 	mov    QWORD PTR [rip+0x3ed93],rdi        # 251008 <stderr_stream>
  212275:	48 8d 35 74 dc 03 00 	lea    rsi,[rip+0x3dc74]        # 24fef0 <__unnamed_3>
  21227c:	ff d0                	call   rax
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  21227e:	31 c0                	xor    eax,eax
  212280:	86 05 8a ed 03 00    	xchg   BYTE PTR [rip+0x3ed8a],al        # 251010 <stderr_mutex>
  212286:	3c 01                	cmp    al,0x1
    if (!ok) {
  212288:	0f 85 81 03 00 00    	jne    21260f <BmError.init.setup.tearDown_error+0x40f>
    // Since this is a test print a \n before we run
    warn("\n");

    // Test fn benchmark(pSelf) can return an error
    var bm = Benchmark.init("BmError.init.setup.tearDown_error", std.debug.global_allocator);
  21228e:	c5 f8 10 05 ea da 03 	vmovups xmm0,XMMWORD PTR [rip+0x3daea]        # 24fd80 <__unnamed_17>
  212295:	00 
  212296:	c5 f8 29 44 24 40    	vmovaps XMMWORD PTR [rsp+0x40],xmm0
  21229c:	c5 fc 28 05 1c df fe 	vmovaps ymm0,YMMWORD PTR [rip+0xfffffffffffedf1c]        # 2001c0 <__unnamed_29-0x40>
  2122a3:	ff 
  2122a4:	c5 fc 11 44 24 50    	vmovups YMMWORD PTR [rsp+0x50],ymm0
  2122aa:	c5 fa 6f 05 5e e0 fe 	vmovdqu xmm0,XMMWORD PTR [rip+0xfffffffffffee05e]        # 200310 <__unnamed_35>
  2122b1:	ff 
  2122b2:	c5 f9 7f 44 24 70    	vmovdqa XMMWORD PTR [rsp+0x70],xmm0
  2122b8:	48 8d 05 41 9d 03 00 	lea    rax,[rip+0x39d41]        # 24c000 <global_fixed_allocator>
  2122bf:	48 89 84 24 80 00 00 	mov    QWORD PTR [rsp+0x80],rax
  2122c6:	00 
  2122c7:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  2122cb:	c5 fa 7f 84 24 88 00 	vmovdqu XMMWORD PTR [rsp+0x88],xmm0
  2122d2:	00 00 
  2122d4:	48 c7 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],0x0
  2122db:	00 00 00 00 00 
  2122e0:	48 89 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rax
  2122e7:	00 
  2122e8:	49 be 00 e8 76 48 17 	movabs r14,0x174876e800
  2122ef:	00 00 00 
  2122f2:	bb 01 00 00 00       	mov    ebx,0x1
  2122f7:	45 31 e4             	xor    r12d,r12d
  2122fa:	49 89 e7             	mov    r15,rsp
  2122fd:	45 31 ed             	xor    r13d,r13d
  212300:	eb 1c                	jmp    21231e <BmError.init.setup.tearDown_error+0x11e>
  212302:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  212309:	1f 84 00 00 00 00 00 
                        warn("iteratons:{} numer:{} denom:{}\n", iterations, numer, denom);
  212310:	48 89 df             	mov    rdi,rbx
  212313:	48 89 ca             	mov    rdx,rcx
  212316:	c5 f8 77             	vzeroupper 
  212319:	e8 12 2d 00 00       	call   215030 <warn.37>
                var ts: posix.timespec = undefined;
  21231e:	c5 fa 6f 05 ea df fe 	vmovdqu xmm0,XMMWORD PTR [rip+0xfffffffffffedfea]        # 200310 <__unnamed_35>
  212325:	ff 
  212326:	c5 f9 7f 04 24       	vmovdqa XMMWORD PTR [rsp],xmm0
  21232b:	b8 e5 00 00 00       	mov    eax,0xe5
  212330:	bf 01 00 00 00       	mov    edi,0x1
  212335:	4c 89 fe             	mov    rsi,r15
  212338:	0f 05                	syscall 
  21233a:	48 89 c1             	mov    rcx,rax
  21233d:	48 f7 d9             	neg    rcx
  212340:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  212346:	49 0f 46 cc          	cmovbe rcx,r12
                switch (errno) {
  21234a:	48 85 c9             	test   rcx,rcx
  21234d:	0f 85 43 02 00 00    	jne    212596 <BmError.init.setup.tearDown_error+0x396>
        const f = @atomicLoad(@typeOf(init_vdso_clock_gettime), &vdso_clock_gettime, builtin.AtomicOrder.Unordered);
  212353:	48 8b 05 be 9d 03 00 	mov    rax,QWORD PTR [rip+0x39dbe]        # 24c118 <vdso_clock_gettime>
        if (@ptrToInt(f) != 0) {
  21235a:	48 85 c0             	test   rax,rax
  21235d:	74 18                	je     212377 <BmError.init.setup.tearDown_error+0x177>
            const rc = f(clk_id, tp);
  21235f:	bf 01 00 00 00       	mov    edi,0x1
  212364:	4c 89 fe             	mov    rsi,r15
  212367:	c5 f8 77             	vzeroupper 
  21236a:	ff d0                	call   rax
            switch (rc) {
  21236c:	48 83 f8 ea          	cmp    rax,0xffffffffffffffea
  212370:	74 14                	je     212386 <BmError.init.setup.tearDown_error+0x186>
  212372:	48 85 c0             	test   rax,rax
  212375:	74 0f                	je     212386 <BmError.init.setup.tearDown_error+0x186>
  212377:	b8 e4 00 00 00       	mov    eax,0xe4
  21237c:	bf 01 00 00 00       	mov    edi,0x1
  212381:	4c 89 fe             	mov    rsi,r15
  212384:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  212386:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
                if (errno != 0) return std.os.unexpectedErrorPosix(errno);
  21238c:	0f 83 18 02 00 00    	jae    2125aa <BmError.init.setup.tearDown_error+0x3aa>
                self.start_time = @intCast(u64, ts.tv_sec) * u64(ns_per_s) + @intCast(u64, ts.tv_nsec);
  212392:	c5 f9 6f 0c 24       	vmovdqa xmm1,XMMWORD PTR [rsp]
        var ts: posix.timespec = undefined;
  212397:	c5 fa 6f 05 71 df fe 	vmovdqu xmm0,XMMWORD PTR [rip+0xfffffffffffedf71]        # 200310 <__unnamed_35>
  21239e:	ff 
  21239f:	c5 f9 7f 04 24       	vmovdqa XMMWORD PTR [rsp],xmm0
        const f = @atomicLoad(@typeOf(init_vdso_clock_gettime), &vdso_clock_gettime, builtin.AtomicOrder.Unordered);
  2123a4:	48 8b 05 6d 9d 03 00 	mov    rax,QWORD PTR [rip+0x39d6d]        # 24c118 <vdso_clock_gettime>
        if (@ptrToInt(f) != 0) {
  2123ab:	48 85 c0             	test   rax,rax
  2123ae:	74 28                	je     2123d8 <BmError.init.setup.tearDown_error+0x1d8>
  2123b0:	c5 f9 7f 4c 24 10    	vmovdqa XMMWORD PTR [rsp+0x10],xmm1
            const rc = f(clk_id, tp);
  2123b6:	bf 01 00 00 00       	mov    edi,0x1
  2123bb:	4c 89 fe             	mov    rsi,r15
  2123be:	c5 f8 77             	vzeroupper 
  2123c1:	ff d0                	call   rax
            switch (rc) {
  2123c3:	48 83 f8 ea          	cmp    rax,0xffffffffffffffea
  2123c7:	0f 84 b5 01 00 00    	je     212582 <BmError.init.setup.tearDown_error+0x382>
  2123cd:	48 85 c0             	test   rax,rax
  2123d0:	c5 f9 6f 4c 24 10    	vmovdqa xmm1,XMMWORD PTR [rsp+0x10]
  2123d6:	74 0f                	je     2123e7 <BmError.init.setup.tearDown_error+0x1e7>
  2123d8:	b8 e4 00 00 00       	mov    eax,0xe4
  2123dd:	bf 01 00 00 00       	mov    edi,0x1
  2123e2:	4c 89 fe             	mov    rsi,r15
  2123e5:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  2123e7:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
  2123ed:	0f 83 1c 02 00 00    	jae    21260f <BmError.init.setup.tearDown_error+0x40f>
        return @intCast(u64, ts.tv_sec) * u64(ns_per_s) + @intCast(u64, ts.tv_nsec);
  2123f3:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  2123f8:	c5 f9 fb c1          	vpsubq xmm0,xmm0,xmm1
  2123fc:	c4 e1 f9 7e c0       	vmovq  rax,xmm0
        var clock = clockNative() - self.start_time;
  212401:	c4 e3 f9 16 c5 01    	vpextrq rbp,xmm0,0x1
  212407:	48 69 c0 00 ca 9a 3b 	imul   rax,rax,0x3b9aca00
  21240e:	48 01 c5             	add    rbp,rax
                if ((run_time_ns >= pSelf.min_runtime_ns) or (iterations >= pSelf.max_iterations)) {
  212411:	48 3b 6c 24 58       	cmp    rbp,QWORD PTR [rsp+0x58]
  212416:	0f 83 9c 01 00 00    	jae    2125b8 <BmError.init.setup.tearDown_error+0x3b8>
  21241c:	4c 39 f3             	cmp    rbx,r14
  21241f:	0f 83 93 01 00 00    	jae    2125b8 <BmError.init.setup.tearDown_error+0x3b8>
                    if (pSelf.logl >= 1) {
  212425:	4d 85 ed             	test   r13,r13
  212428:	0f 84 b8 00 00 00    	je     2124e6 <BmError.init.setup.tearDown_error+0x2e6>
                            Result {.run_time_ns = run_time_ns, .iterations = iterations});
  21242e:	48 89 6c 24 20       	mov    QWORD PTR [rsp+0x20],rbp
  212433:	48 89 5c 24 28       	mov    QWORD PTR [rsp+0x28],rbx
                        try pSelf.report(
  212438:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  21243d:	48 8d 74 24 20       	lea    rsi,[rsp+0x20]
  212442:	c5 f8 77             	vzeroupper 
  212445:	e8 d6 0a 00 00       	call   212f20 <Benchmark_report>
  21244a:	66 85 c0             	test   ax,ax
  21244d:	0f 85 89 01 00 00    	jne    2125dc <BmError.init.setup.tearDown_error+0x3dc>
  212453:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21245a:	84 00 00 00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  212460:	b0 01                	mov    al,0x1
  212462:	86 05 a8 eb 03 00    	xchg   BYTE PTR [rip+0x3eba8],al        # 251010 <stderr_mutex>
  212468:	84 c0                	test   al,al
  21246a:	75 f4                	jne    212460 <BmError.init.setup.tearDown_error+0x260>
    if (stderr_stream) |st| {
  21246c:	48 8b 3d 95 eb 03 00 	mov    rdi,QWORD PTR [rip+0x3eb95]        # 251008 <stderr_stream>
  212473:	48 85 ff             	test   rdi,rdi
  212476:	74 18                	je     212490 <BmError.init.setup.tearDown_error+0x290>
  212478:	48 8b 0d c1 9b 03 00 	mov    rcx,QWORD PTR [rip+0x39bc1]        # 24c040 <stderr_file_out_stream+0x8>
  21247f:	eb 4c                	jmp    2124cd <BmError.init.setup.tearDown_error+0x2cd>
  212481:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  212488:	0f 1f 84 00 00 00 00 
  21248f:	00 
        stderr_file = try io.getStdErr();
  212490:	c7 05 96 9b 03 00 02 	mov    DWORD PTR [rip+0x39b96],0x2        # 24c030 <stderr_file>
  212497:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  21249a:	48 8d 05 8f 9b 03 00 	lea    rax,[rip+0x39b8f]        # 24c030 <stderr_file>
  2124a1:	48 89 05 90 9b 03 00 	mov    QWORD PTR [rip+0x39b90],rax        # 24c038 <stderr_file_out_stream>
  2124a8:	48 8d 05 f1 c9 00 00 	lea    rax,[rip+0xc9f1]        # 21eea0 <FileOutStream_writeFn>
  2124af:	48 89 05 8a 9b 03 00 	mov    QWORD PTR [rip+0x39b8a],rax        # 24c040 <stderr_file_out_stream+0x8>
  2124b6:	48 8d 0d 83 9b 03 00 	lea    rcx,[rip+0x39b83]        # 24c040 <stderr_file_out_stream+0x8>
  2124bd:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  2124c0:	48 89 15 41 eb 03 00 	mov    QWORD PTR [rip+0x3eb41],rdx        # 251008 <stderr_stream>
  2124c7:	48 89 c1             	mov    rcx,rax
  2124ca:	48 89 d7             	mov    rdi,rdx
  2124cd:	48 8d 35 1c da 03 00 	lea    rsi,[rip+0x3da1c]        # 24fef0 <__unnamed_3>
  2124d4:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  2124d6:	31 c0                	xor    eax,eax
  2124d8:	86 05 32 eb 03 00    	xchg   BYTE PTR [rip+0x3eb32],al        # 251010 <stderr_mutex>
  2124de:	3c 01                	cmp    al,0x1
    if (!ok) {
  2124e0:	0f 85 29 01 00 00    	jne    21260f <BmError.init.setup.tearDown_error+0x40f>
                    if (run_time_ns < 1000) {
  2124e6:	48 81 fd e8 03 00 00 	cmp    rbp,0x3e8
  2124ed:	73 31                	jae    212520 <BmError.init.setup.tearDown_error+0x320>
  2124ef:	b9 01 00 00 00       	mov    ecx,0x1
  2124f4:	be e8 03 00 00       	mov    esi,0x3e8
                    iterations = (iterations * numer) / denom;
  2124f9:	48 0f af de          	imul   rbx,rsi
  2124fd:	48 89 d8             	mov    rax,rbx
  212500:	48 c1 e8 20          	shr    rax,0x20
  212504:	74 54                	je     21255a <BmError.init.setup.tearDown_error+0x35a>
  212506:	31 d2                	xor    edx,edx
  212508:	48 89 d8             	mov    rax,rbx
  21250b:	48 f7 f1             	div    rcx
  21250e:	48 89 c3             	mov    rbx,rax
  212511:	eb 4f                	jmp    212562 <BmError.init.setup.tearDown_error+0x362>
  212513:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21251a:	84 00 00 00 00 00 
                    } else if (run_time_ns < (pSelf.min_runtime_ns / 10)) {
  212520:	48 ba cd cc cc cc cc 	movabs rdx,0xcccccccccccccccd
  212527:	cc cc cc 
  21252a:	c4 e2 fb f6 4c 24 58 	mulx   rcx,rax,QWORD PTR [rsp+0x58]
  212531:	48 c1 e9 03          	shr    rcx,0x3
  212535:	31 c0                	xor    eax,eax
  212537:	48 39 cd             	cmp    rbp,rcx
  21253a:	0f 93 c0             	setae  al
  21253d:	48 8d 0c c0          	lea    rcx,[rax+rax*8]
  212541:	48 83 c1 01          	add    rcx,0x1
  212545:	48 8d 34 85 0a 00 00 	lea    rsi,[rax*4+0xa]
  21254c:	00 
                    iterations = (iterations * numer) / denom;
  21254d:	48 0f af de          	imul   rbx,rsi
  212551:	48 89 d8             	mov    rax,rbx
  212554:	48 c1 e8 20          	shr    rax,0x20
  212558:	75 ac                	jne    212506 <BmError.init.setup.tearDown_error+0x306>
  21255a:	31 d2                	xor    edx,edx
  21255c:	89 d8                	mov    eax,ebx
  21255e:	f7 f1                	div    ecx
  212560:	89 c3                	mov    ebx,eax
                    if (pSelf.logl >= 2) {
  212562:	4c 8b 6c 24 50       	mov    r13,QWORD PTR [rsp+0x50]
                    if (iterations > pSelf.max_iterations) {
  212567:	4c 8b 74 24 68       	mov    r14,QWORD PTR [rsp+0x68]
  21256c:	4c 39 f3             	cmp    rbx,r14
  21256f:	49 0f 47 de          	cmova  rbx,r14
                    if (pSelf.logl >= 2) {
  212573:	49 83 fd 02          	cmp    r13,0x2
  212577:	0f 82 a1 fd ff ff    	jb     21231e <BmError.init.setup.tearDown_error+0x11e>
  21257d:	e9 8e fd ff ff       	jmp    212310 <BmError.init.setup.tearDown_error+0x110>
  212582:	c5 f9 6f 4c 24 10    	vmovdqa xmm1,XMMWORD PTR [rsp+0x10]
  212588:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
  21258e:	0f 82 5f fe ff ff    	jb     2123f3 <BmError.init.setup.tearDown_error+0x1f3>
  212594:	eb 79                	jmp    21260f <BmError.init.setup.tearDown_error+0x40f>
                switch (errno) {
  212596:	48 83 f9 16          	cmp    rcx,0x16
  21259a:	75 0e                	jne    2125aa <BmError.init.setup.tearDown_error+0x3aa>
  21259c:	66 b8 02 00          	mov    ax,0x2
    if (value) {
  2125a0:	0f b7 c8             	movzx  ecx,ax
  2125a3:	83 f9 0b             	cmp    ecx,0xb
  2125a6:	74 3c                	je     2125e4 <BmError.init.setup.tearDown_error+0x3e4>
  2125a8:	eb 51                	jmp    2125fb <BmError.init.setup.tearDown_error+0x3fb>
  2125aa:	66 b8 03 00          	mov    ax,0x3
  2125ae:	0f b7 c8             	movzx  ecx,ax
  2125b1:	83 f9 0b             	cmp    ecx,0xb
  2125b4:	74 2e                	je     2125e4 <BmError.init.setup.tearDown_error+0x3e4>
  2125b6:	eb 43                	jmp    2125fb <BmError.init.setup.tearDown_error+0x3fb>
                            Result { .run_time_ns = run_time_ns, .iterations = iterations});
  2125b8:	48 89 6c 24 30       	mov    QWORD PTR [rsp+0x30],rbp
  2125bd:	48 89 5c 24 38       	mov    QWORD PTR [rsp+0x38],rbx
  2125c2:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
                    try pSelf.results.append(
  2125c7:	48 8d bc 24 88 00 00 	lea    rdi,[rsp+0x88]
  2125ce:	00 
  2125cf:	c5 f8 77             	vzeroupper 
  2125d2:	e8 d9 07 00 00       	call   212db0 <AlignedArrayList(Result,8)_append>
  2125d7:	66 85 c0             	test   ax,ax
  2125da:	74 08                	je     2125e4 <BmError.init.setup.tearDown_error+0x3e4>
  2125dc:	0f b7 c8             	movzx  ecx,ax
  2125df:	83 f9 0b             	cmp    ecx,0xb
  2125e2:	75 17                	jne    2125fb <BmError.init.setup.tearDown_error+0x3fb>
test "BmError.init.setup.tearDown_error" {
  2125e4:	31 c0                	xor    eax,eax
  2125e6:	48 81 c4 a8 00 00 00 	add    rsp,0xa8
  2125ed:	5b                   	pop    rbx
  2125ee:	41 5c                	pop    r12
  2125f0:	41 5d                	pop    r13
  2125f2:	41 5e                	pop    r14
  2125f4:	41 5f                	pop    r15
  2125f6:	5d                   	pop    rbp
  2125f7:	c5 f8 77             	vzeroupper 
  2125fa:	c3                   	ret    
  2125fb:	66 85 c0             	test   ax,ax
  2125fe:	75 0f                	jne    21260f <BmError.init.setup.tearDown_error+0x40f>
        @panic("expected error");
  212600:	48 8d 3d 99 d7 03 00 	lea    rdi,[rip+0x3d799]        # 24fda0 <__unnamed_18>
  212607:	c5 f8 77             	vzeroupper 
  21260a:	e8 11 01 00 00       	call   212720 <panic>
            @panic("assertion failure");
  21260f:	48 8d 3d 7a d7 03 00 	lea    rdi,[rip+0x3d77a]        # 24fd90 <__unnamed_2>
  212616:	c5 f8 77             	vzeroupper 
  212619:	e8 02 01 00 00       	call   212720 <panic>
  21261e:	66 90                	xchg   ax,ax

0000000000212620 <BmError.init.setup.tearDown.benchmark_error>:
    };

    assertError(bm.run(BmSelf), error.TearDownError);
}

test "BmError.init.setup.tearDown.benchmark_error" {
  212620:	48 83 ec 18          	sub    rsp,0x18
  212624:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21262b:	00 00 00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  212630:	b0 01                	mov    al,0x1
  212632:	86 05 d8 e9 03 00    	xchg   BYTE PTR [rip+0x3e9d8],al        # 251010 <stderr_mutex>
  212638:	84 c0                	test   al,al
  21263a:	75 f4                	jne    212630 <BmError.init.setup.tearDown.benchmark_error+0x10>
    if (stderr_stream) |st| {
  21263c:	48 8b 3d c5 e9 03 00 	mov    rdi,QWORD PTR [rip+0x3e9c5]        # 251008 <stderr_stream>
  212643:	48 85 ff             	test   rdi,rdi
  212646:	74 09                	je     212651 <BmError.init.setup.tearDown.benchmark_error+0x31>
  212648:	48 8b 05 f1 99 03 00 	mov    rax,QWORD PTR [rip+0x399f1]        # 24c040 <stderr_file_out_stream+0x8>
  21264f:	eb 34                	jmp    212685 <BmError.init.setup.tearDown.benchmark_error+0x65>
        stderr_file = try io.getStdErr();
  212651:	48 8d 05 d8 99 03 00 	lea    rax,[rip+0x399d8]        # 24c030 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  212658:	48 89 05 d9 99 03 00 	mov    QWORD PTR [rip+0x399d9],rax        # 24c038 <stderr_file_out_stream>
  21265f:	48 8d 05 3a c8 00 00 	lea    rax,[rip+0xc83a]        # 21eea0 <FileOutStream_writeFn>
  212666:	48 89 05 d3 99 03 00 	mov    QWORD PTR [rip+0x399d3],rax        # 24c040 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  21266d:	c7 05 b9 99 03 00 02 	mov    DWORD PTR [rip+0x399b9],0x2        # 24c030 <stderr_file>
  212674:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  212677:	48 8d 3d c2 99 03 00 	lea    rdi,[rip+0x399c2]        # 24c040 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  21267e:	48 89 3d 83 e9 03 00 	mov    QWORD PTR [rip+0x3e983],rdi        # 251008 <stderr_stream>
  212685:	48 8d 35 64 d8 03 00 	lea    rsi,[rip+0x3d864]        # 24fef0 <__unnamed_3>
  21268c:	ff d0                	call   rax
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  21268e:	31 c0                	xor    eax,eax
  212690:	86 05 7a e9 03 00    	xchg   BYTE PTR [rip+0x3e97a],al        # 251010 <stderr_mutex>
  212696:	3c 01                	cmp    al,0x1
    if (!ok) {
  212698:	75 76                	jne    212710 <BmError.init.setup.tearDown.benchmark_error+0xf0>
                var ts: posix.timespec = undefined;
  21269a:	c5 f8 10 05 6e dc fe 	vmovups xmm0,XMMWORD PTR [rip+0xfffffffffffedc6e]        # 200310 <__unnamed_35>
  2126a1:	ff 
  2126a2:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
  2126a7:	48 89 e6             	mov    rsi,rsp
  2126aa:	b8 e5 00 00 00       	mov    eax,0xe5
  2126af:	bf 01 00 00 00       	mov    edi,0x1
  2126b4:	0f 05                	syscall 
  2126b6:	48 89 c2             	mov    rdx,rax
  2126b9:	48 f7 da             	neg    rdx
  2126bc:	31 c9                	xor    ecx,ecx
  2126be:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  2126c4:	48 0f 47 ca          	cmova  rcx,rdx
                switch (errno) {
  2126c8:	48 85 c9             	test   rcx,rcx
  2126cb:	75 3f                	jne    21270c <BmError.init.setup.tearDown.benchmark_error+0xec>
        const f = @atomicLoad(@typeOf(init_vdso_clock_gettime), &vdso_clock_gettime, builtin.AtomicOrder.Unordered);
  2126cd:	48 8b 05 44 9a 03 00 	mov    rax,QWORD PTR [rip+0x39a44]        # 24c118 <vdso_clock_gettime>
        if (@ptrToInt(f) != 0) {
  2126d4:	48 85 c0             	test   rax,rax
  2126d7:	74 15                	je     2126ee <BmError.init.setup.tearDown.benchmark_error+0xce>
  2126d9:	48 89 e6             	mov    rsi,rsp
            const rc = f(clk_id, tp);
  2126dc:	bf 01 00 00 00       	mov    edi,0x1
  2126e1:	ff d0                	call   rax
            switch (rc) {
  2126e3:	48 83 f8 ea          	cmp    rax,0xffffffffffffffea
  2126e7:	74 14                	je     2126fd <BmError.init.setup.tearDown.benchmark_error+0xdd>
  2126e9:	48 85 c0             	test   rax,rax
  2126ec:	74 0f                	je     2126fd <BmError.init.setup.tearDown.benchmark_error+0xdd>
  2126ee:	48 89 e6             	mov    rsi,rsp
  2126f1:	b8 e4 00 00 00       	mov    eax,0xe4
  2126f6:	bf 01 00 00 00       	mov    edi,0x1
  2126fb:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  2126fd:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
    if (value) {
  212703:	73 0b                	jae    212710 <BmError.init.setup.tearDown.benchmark_error+0xf0>
  212705:	31 c0                	xor    eax,eax
  212707:	48 83 c4 18          	add    rsp,0x18
  21270b:	c3                   	ret    
  21270c:	48 83 f9 16          	cmp    rcx,0x16
            @panic("assertion failure");
  212710:	48 8d 3d 79 d6 03 00 	lea    rdi,[rip+0x3d679]        # 24fd90 <__unnamed_2>
  212717:	e8 04 00 00 00       	call   212720 <panic>
  21271c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

0000000000212720 <panic>:
// have to be added in the compiler.

const builtin = @import("builtin");
const std = @import("std");

pub fn panic(msg: []const u8, error_return_trace: ?*builtin.StackTrace) noreturn {
  212720:	48 83 ec 18          	sub    rsp,0x18
  212724:	48 89 f8             	mov    rax,rdi
        // TODO: fix panic in zen.
        builtin.Os.freestanding, builtin.Os.zen => {
            while (true) {}
        },
        else => {
            const first_trace_addr = @ptrToInt(@returnAddress());
  212727:	48 8b 4c 24 18       	mov    rcx,QWORD PTR [rsp+0x18]
            std.debug.panicExtra(error_return_trace, first_trace_addr, "{}", msg);
  21272c:	48 89 4c 24 08       	mov    QWORD PTR [rsp+0x8],rcx
  212731:	c6 44 24 10 01       	mov    BYTE PTR [rsp+0x10],0x1
  212736:	48 8d 7c 24 08       	lea    rdi,[rsp+0x8]
  21273b:	48 89 c6             	mov    rsi,rax
  21273e:	e8 0d 00 00 00       	call   212750 <panicExtra>
  212743:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21274a:	84 00 00 00 00 00 

0000000000212750 <panicExtra>:
}

/// TODO multithreaded awareness
var panicking: u8 = 0; // TODO make this a bool

pub fn panicExtra(trace: ?*const builtin.StackTrace, first_trace_addr: ?usize, comptime format: []const u8, args: ...) noreturn {
  212750:	41 57                	push   r15
  212752:	41 56                	push   r14
  212754:	53                   	push   rbx
  212755:	48 83 ec 10          	sub    rsp,0x10
  212759:	b0 01                	mov    al,0x1
    @setCold(true);

    if (@atomicRmw(u8, &panicking, builtin.AtomicRmwOp.Xchg, 1, builtin.AtomicOrder.SeqCst) == 1) {
  21275b:	86 05 9f e8 03 00    	xchg   BYTE PTR [rip+0x3e89f],al        # 251000 <panicking>
  212761:	49 89 fe             	mov    r14,rdi
  212764:	3c 01                	cmp    al,0x1
  212766:	74 7a                	je     2127e2 <panicExtra+0x92>
    if (stderr_stream) |st| {
  212768:	48 8b 1d 99 e8 03 00 	mov    rbx,QWORD PTR [rip+0x3e899]        # 251008 <stderr_stream>
  21276f:	48 85 db             	test   rbx,rbx
  212772:	75 36                	jne    2127aa <panicExtra+0x5a>
        stderr_file = try io.getStdErr();
  212774:	48 8d 05 b5 98 03 00 	lea    rax,[rip+0x398b5]        # 24c030 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  21277b:	48 89 05 b6 98 03 00 	mov    QWORD PTR [rip+0x398b6],rax        # 24c038 <stderr_file_out_stream>
  212782:	4c 8d 3d 17 c7 00 00 	lea    r15,[rip+0xc717]        # 21eea0 <FileOutStream_writeFn>
  212789:	4c 89 3d b0 98 03 00 	mov    QWORD PTR [rip+0x398b0],r15        # 24c040 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  212790:	c7 05 96 98 03 00 02 	mov    DWORD PTR [rip+0x39896],0x2        # 24c030 <stderr_file>
  212797:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  21279a:	48 8d 1d 9f 98 03 00 	lea    rbx,[rip+0x3989f]        # 24c040 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  2127a1:	48 89 1d 60 e8 03 00 	mov    QWORD PTR [rip+0x3e860],rbx        # 251008 <stderr_stream>
  2127a8:	eb 07                	jmp    2127b1 <panicExtra+0x61>
  2127aa:	4c 8b 3d 8f 98 03 00 	mov    r15,QWORD PTR [rip+0x3988f]        # 24c040 <stderr_file_out_stream+0x8>
                const casted_value = ([]const u8)(value);
  2127b1:	c5 f8 10 06          	vmovups xmm0,XMMWORD PTR [rsi]
  2127b5:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
  2127ba:	48 89 e6             	mov    rsi,rsp
                return output(context, casted_value);
  2127bd:	48 89 df             	mov    rdi,rbx
  2127c0:	41 ff d7             	call   r15
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  2127c3:	66 85 c0             	test   ax,ax
  2127c6:	75 1a                	jne    2127e2 <panicExtra+0x92>
        try output(context, fmt[start_index..]);
  2127c8:	48 8d 35 e1 d5 03 00 	lea    rsi,[rip+0x3d5e1]        # 24fdb0 <__unnamed_19>
  2127cf:	48 89 df             	mov    rdi,rbx
  2127d2:	41 ff d7             	call   r15
        // we would want to return here instead of calling abort, so that the thread
        // which first called panic can finish printing a stack trace.
        os.abort();
    }
    const stderr = getStderrStream() catch os.abort();
    stderr.print(format ++ "\n", args) catch os.abort();
  2127d5:	66 85 c0             	test   ax,ax
  2127d8:	75 08                	jne    2127e2 <panicExtra+0x92>
    if (trace) |t| {
        dumpStackTrace(t);
    }
    dumpCurrentStackTrace(first_trace_addr);
  2127da:	4c 89 f7             	mov    rdi,r14
  2127dd:	e8 0e 01 00 00       	call   2128f0 <dumpCurrentStackTrace>
  2127e2:	e8 09 00 00 00       	call   2127f0 <abort>
  2127e7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  2127ee:	00 00 

00000000002127f0 <abort>:
pub const SIG_DFL = @intToPtr(extern fn (i32) void, 0);
pub const SIG_IGN = @intToPtr(extern fn (i32) void, 1);
pub const empty_sigset = []usize{0} ** sigset_t.len;

pub fn raise(sig: i32) usize {
    var set: sigset_t = undefined;
  2127f0:	50                   	push   rax
  2127f1:	c5 fc 10 05 17 58 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffff5817]        # 208010 <__unnamed_20+0x60>
  2127f8:	ff 
  2127f9:	c5 fc 11 44 24 e0    	vmovups YMMWORD PTR [rsp-0x20],ymm0
  2127ff:	c5 fc 10 0d e9 57 ff 	vmovups ymm1,YMMWORD PTR [rip+0xffffffffffff57e9]        # 207ff0 <__unnamed_20+0x40>
  212806:	ff 
  212807:	c5 fc 11 4c 24 c0    	vmovups YMMWORD PTR [rsp-0x40],ymm1
  21280d:	c5 fc 10 15 bb 57 ff 	vmovups ymm2,YMMWORD PTR [rip+0xffffffffffff57bb]        # 207fd0 <__unnamed_20+0x20>
  212814:	ff 
  212815:	c5 fc 11 54 24 a0    	vmovups YMMWORD PTR [rsp-0x60],ymm2
  21281b:	c5 fc 10 1d 8d 57 ff 	vmovups ymm3,YMMWORD PTR [rip+0xffffffffffff578d]        # 207fb0 <__unnamed_20>
  212822:	ff 
  212823:	c5 fc 11 5c 24 80    	vmovups YMMWORD PTR [rsp-0x80],ymm3
        : "rcx", "r11"
    );
}

pub fn syscall4(number: usize, arg1: usize, arg2: usize, arg3: usize, arg4: usize) usize {
    return asm volatile ("syscall"
  212829:	4c 8d 0d 78 e4 fe ff 	lea    r9,[rip+0xfffffffffffee478]        # 200ca8 <app_mask>
  212830:	4c 8d 44 24 80       	lea    r8,[rsp-0x80]
  212835:	b8 0e 00 00 00       	mov    eax,0xe
  21283a:	bf 00 00 00 00       	mov    edi,0x0
  21283f:	41 ba 08 00 00 00    	mov    r10d,0x8
  212845:	4c 89 ce             	mov    rsi,r9
  212848:	4c 89 c2             	mov    rdx,r8
  21284b:	0f 05                	syscall 
    return asm volatile ("syscall"
  21284d:	b8 ba 00 00 00       	mov    eax,0xba
  212852:	0f 05                	syscall 
    blockAppSignals(&set);
    const tid = @intCast(i32, syscall0(SYS_gettid));
    const ret = syscall2(SYS_tkill, @intCast(usize, tid), @intCast(usize, sig));
  212854:	48 63 f8             	movsxd rdi,eax
    return asm volatile ("syscall"
  212857:	b8 c8 00 00 00       	mov    eax,0xc8
  21285c:	be 06 00 00 00       	mov    esi,0x6
  212861:	0f 05                	syscall 
    return asm volatile ("syscall"
  212863:	b8 0e 00 00 00       	mov    eax,0xe
  212868:	bf 02 00 00 00       	mov    edi,0x2
  21286d:	ba 00 00 00 00       	mov    edx,0x0
  212872:	41 ba 08 00 00 00    	mov    r10d,0x8
  212878:	4c 89 c6             	mov    rsi,r8
  21287b:	0f 05                	syscall 
    var set: sigset_t = undefined;
  21287d:	c5 fc 11 44 24 e0    	vmovups YMMWORD PTR [rsp-0x20],ymm0
  212883:	c5 fc 11 4c 24 c0    	vmovups YMMWORD PTR [rsp-0x40],ymm1
  212889:	c5 fc 11 54 24 a0    	vmovups YMMWORD PTR [rsp-0x60],ymm2
  21288f:	c5 fc 11 5c 24 80    	vmovups YMMWORD PTR [rsp-0x80],ymm3
  212895:	b8 0e 00 00 00       	mov    eax,0xe
  21289a:	bf 00 00 00 00       	mov    edi,0x0
  21289f:	41 ba 08 00 00 00    	mov    r10d,0x8
  2128a5:	4c 89 ce             	mov    rsi,r9
  2128a8:	4c 89 c2             	mov    rdx,r8
  2128ab:	0f 05                	syscall 
    return asm volatile ("syscall"
  2128ad:	b8 ba 00 00 00       	mov    eax,0xba
  2128b2:	0f 05                	syscall 
    const ret = syscall2(SYS_tkill, @intCast(usize, tid), @intCast(usize, sig));
  2128b4:	48 63 f8             	movsxd rdi,eax
    return asm volatile ("syscall"
  2128b7:	b8 c8 00 00 00       	mov    eax,0xc8
  2128bc:	be 09 00 00 00       	mov    esi,0x9
  2128c1:	0f 05                	syscall 
    return asm volatile ("syscall"
  2128c3:	b8 0e 00 00 00       	mov    eax,0xe
  2128c8:	bf 02 00 00 00       	mov    edi,0x2
  2128cd:	31 d2                	xor    edx,edx
  2128cf:	41 ba 08 00 00 00    	mov    r10d,0x8
  2128d5:	4c 89 c6             	mov    rsi,r8
  2128d8:	0f 05                	syscall 
  2128da:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
    }
    switch (builtin.os) {
        Os.linux, Os.macosx, Os.ios => {
            _ = posix.raise(posix.SIGABRT);
            _ = posix.raise(posix.SIGKILL);
            while (true) {}
  2128e0:	eb fe                	jmp    2128e0 <abort+0xf0>
  2128e2:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  2128e9:	1f 84 00 00 00 00 00 

00000000002128f0 <dumpCurrentStackTrace>:
pub fn dumpCurrentStackTrace(start_addr: ?usize) void {
  2128f0:	55                   	push   rbp
  2128f1:	48 89 e5             	mov    rbp,rsp
  2128f4:	41 57                	push   r15
  2128f6:	41 56                	push   r14
  2128f8:	41 55                	push   r13
  2128fa:	41 54                	push   r12
  2128fc:	53                   	push   rbx
  2128fd:	48 81 ec b8 01 00 00 	sub    rsp,0x1b8
  212904:	49 89 fe             	mov    r14,rdi
    if (stderr_stream) |st| {
  212907:	48 8b 05 fa e6 03 00 	mov    rax,QWORD PTR [rip+0x3e6fa]        # 251008 <stderr_stream>
  21290e:	48 89 45 d0          	mov    QWORD PTR [rbp-0x30],rax
  212912:	48 85 c0             	test   rax,rax
  212915:	74 2c                	je     212943 <dumpCurrentStackTrace+0x53>
    if (self_debug_info) |*info| {
  212917:	80 3d f2 97 03 00 01 	cmp    BYTE PTR [rip+0x397f2],0x1        # 24c110 <self_debug_info+0xc8>
  21291e:	75 64                	jne    212984 <dumpCurrentStackTrace+0x94>
/// TODO multithreaded awareness
var debug_info_allocator: ?*mem.Allocator = null;
var debug_info_direct_allocator: std.heap.DirectAllocator = undefined;
var debug_info_arena_allocator: std.heap.ArenaAllocator = undefined;
fn getDebugInfoAllocator() *mem.Allocator {
    if (debug_info_allocator) |a| return a;
  212920:	48 83 3d f0 e6 03 00 	cmp    QWORD PTR [rip+0x3e6f0],0x0        # 251018 <debug_info_allocator>
  212927:	00 
  212928:	0f 84 30 02 00 00    	je     212b5e <dumpCurrentStackTrace+0x26e>
    }
}

/// TODO make this go through libc when we have it
pub fn getEnvPosix(key: []const u8) ?[]const u8 {
    for (posix_environ_raw) |ptr| {
  21292e:	48 8b 05 53 98 03 00 	mov    rax,QWORD PTR [rip+0x39853]        # 24c188 <posix_environ_raw+0x8>
  212935:	48 85 c0             	test   rax,rax
  212938:	0f 85 86 02 00 00    	jne    212bc4 <dumpCurrentStackTrace+0x2d4>
  21293e:	e9 3a 03 00 00       	jmp    212c7d <dumpCurrentStackTrace+0x38d>
        stderr_file = try io.getStdErr();
  212943:	48 8d 05 e6 96 03 00 	lea    rax,[rip+0x396e6]        # 24c030 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  21294a:	48 89 05 e7 96 03 00 	mov    QWORD PTR [rip+0x396e7],rax        # 24c038 <stderr_file_out_stream>
  212951:	48 8d 05 48 c5 00 00 	lea    rax,[rip+0xc548]        # 21eea0 <FileOutStream_writeFn>
  212958:	48 89 05 e1 96 03 00 	mov    QWORD PTR [rip+0x396e1],rax        # 24c040 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  21295f:	c7 05 c7 96 03 00 02 	mov    DWORD PTR [rip+0x396c7],0x2        # 24c030 <stderr_file>
  212966:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  212969:	48 8d 05 d0 96 03 00 	lea    rax,[rip+0x396d0]        # 24c040 <stderr_file_out_stream+0x8>
  212970:	48 89 45 d0          	mov    QWORD PTR [rbp-0x30],rax
        stderr_stream = st;
  212974:	48 89 05 8d e6 03 00 	mov    QWORD PTR [rip+0x3e68d],rax        # 251008 <stderr_stream>
    if (self_debug_info) |*info| {
  21297b:	80 3d 8e 97 03 00 01 	cmp    BYTE PTR [rip+0x3978e],0x1        # 24c110 <self_debug_info+0xc8>
  212982:	74 9c                	je     212920 <dumpCurrentStackTrace+0x30>
    if (debug_info_allocator) |a| return a;
  212984:	48 8b 35 8d e6 03 00 	mov    rsi,QWORD PTR [rip+0x3e68d]        # 251018 <debug_info_allocator>
  21298b:	48 85 f6             	test   rsi,rsi
  21298e:	75 56                	jne    2129e6 <dumpCurrentStackTrace+0xf6>

    debug_info_direct_allocator = std.heap.DirectAllocator.init();
  212990:	c5 fc 10 05 c8 d6 03 	vmovups ymm0,YMMWORD PTR [rip+0x3d6c8]        # 250060 <__unnamed_21>
  212997:	00 
  212998:	c5 fc 11 05 80 97 03 	vmovups YMMWORD PTR [rip+0x39780],ymm0        # 24c120 <debug_info_direct_allocator>
  21299f:	00 
    debug_info_arena_allocator = std.heap.ArenaAllocator.init(&debug_info_direct_allocator.allocator);
  2129a0:	c5 f8 10 05 d8 d6 03 	vmovups xmm0,XMMWORD PTR [rip+0x3d6d8]        # 250080 <__unnamed_22>
  2129a7:	00 
  2129a8:	c5 f8 11 05 90 97 03 	vmovups XMMWORD PTR [rip+0x39790],xmm0        # 24c140 <debug_info_arena_allocator>
  2129af:	00 
    debug_info_direct_allocator = std.heap.DirectAllocator.init();
  2129b0:	48 8d 05 69 97 03 00 	lea    rax,[rip+0x39769]        # 24c120 <debug_info_direct_allocator>
    debug_info_arena_allocator = std.heap.ArenaAllocator.init(&debug_info_direct_allocator.allocator);
  2129b7:	48 8b 0d d2 d6 03 00 	mov    rcx,QWORD PTR [rip+0x3d6d2]        # 250090 <__unnamed_22+0x10>
  2129be:	48 89 0d 8b 97 03 00 	mov    QWORD PTR [rip+0x3978b],rcx        # 24c150 <debug_info_arena_allocator+0x10>
  2129c5:	48 8d 35 74 97 03 00 	lea    rsi,[rip+0x39774]        # 24c140 <debug_info_arena_allocator>
  2129cc:	48 89 05 85 97 03 00 	mov    QWORD PTR [rip+0x39785],rax        # 24c158 <debug_info_arena_allocator+0x18>
  2129d3:	c5 f8 57 c0          	vxorps xmm0,xmm0,xmm0
  2129d7:	c5 fc 11 05 81 97 03 	vmovups YMMWORD PTR [rip+0x39781],ymm0        # 24c160 <debug_info_arena_allocator+0x20>
  2129de:	00 
    debug_info_allocator = &debug_info_arena_allocator.allocator;
  2129df:	48 89 35 32 e6 03 00 	mov    QWORD PTR [rip+0x3e632],rsi        # 251018 <debug_info_allocator>
  2129e6:	48 8d bd 20 fe ff ff 	lea    rdi,[rbp-0x1e0]
        builtin.Os.linux => return openSelfDebugInfoLinux(allocator),
  2129ed:	c5 f8 77             	vzeroupper 
  2129f0:	e8 9b c5 00 00       	call   21ef90 <openSelfDebugInfoLinux>
  2129f5:	c5 fc 10 85 22 fe ff 	vmovups ymm0,YMMWORD PTR [rbp-0x1de]
  2129fc:	ff 
  2129fd:	c5 fc 10 8d 42 fe ff 	vmovups ymm1,YMMWORD PTR [rbp-0x1be]
  212a04:	ff 
  212a05:	c5 fc 10 95 62 fe ff 	vmovups ymm2,YMMWORD PTR [rbp-0x19e]
  212a0c:	ff 
  212a0d:	c5 fc 10 9d 82 fe ff 	vmovups ymm3,YMMWORD PTR [rbp-0x17e]
  212a14:	ff 
  212a15:	c5 fc 11 85 f0 fe ff 	vmovups YMMWORD PTR [rbp-0x110],ymm0
  212a1c:	ff 
  212a1d:	c5 fc 11 8d 10 ff ff 	vmovups YMMWORD PTR [rbp-0xf0],ymm1
  212a24:	ff 
  212a25:	c5 fc 11 95 30 ff ff 	vmovups YMMWORD PTR [rbp-0xd0],ymm2
  212a2c:	ff 
  212a2d:	c5 fc 11 9d 50 ff ff 	vmovups YMMWORD PTR [rbp-0xb0],ymm3
  212a34:	ff 
  212a35:	c5 fc 10 85 a2 fe ff 	vmovups ymm0,YMMWORD PTR [rbp-0x15e]
  212a3c:	ff 
  212a3d:	c5 fc 11 85 70 ff ff 	vmovups YMMWORD PTR [rbp-0x90],ymm0
  212a44:	ff 
  212a45:	48 0f bf 9d 20 fe ff 	movsx  rbx,WORD PTR [rbp-0x1e0]
  212a4c:	ff 
  212a4d:	c5 fc 10 85 c2 fe ff 	vmovups ymm0,YMMWORD PTR [rbp-0x13e]
  212a54:	ff 
  212a55:	c5 fc 11 45 90       	vmovups YMMWORD PTR [rbp-0x70],ymm0
  212a5a:	c5 fc 10 85 d0 fe ff 	vmovups ymm0,YMMWORD PTR [rbp-0x130]
  212a61:	ff 
  212a62:	c5 fc 11 45 9e       	vmovups YMMWORD PTR [rbp-0x62],ymm0
  212a67:	48 85 db             	test   rbx,rbx
        self_debug_info = try openSelfDebugInfo(getDebugInfoAllocator());
  212a6a:	74 58                	je     212ac4 <dumpCurrentStackTrace+0x1d4>
  212a6c:	48 8b 7d d0          	mov    rdi,QWORD PTR [rbp-0x30]
  212a70:	4c 8b 37             	mov    r14,QWORD PTR [rdi]
                        try output(context, fmt[start_index..i]);
  212a73:	48 8d 35 06 d4 03 00 	lea    rsi,[rip+0x3d406]        # 24fe80 <__unnamed_23>
  212a7a:	c5 f8 77             	vzeroupper 
  212a7d:	41 ff d6             	call   r14
  212a80:	66 85 c0             	test   ax,ax
  212a83:	0f 85 df 02 00 00    	jne    212d68 <dumpCurrentStackTrace+0x478>
        stderr.print("Unable to dump stack trace: Unable to open debug info: {}\n", @errorName(err)) catch return;
  212a89:	48 c1 e3 04          	shl    rbx,0x4
  212a8d:	48 8d 05 6c a5 03 00 	lea    rax,[rip+0x3a56c]        # 24d000 <raw+0xe68>
                const casted_value = ([]const u8)(value);
  212a94:	c5 f8 10 04 03       	vmovups xmm0,XMMWORD PTR [rbx+rax*1]
  212a99:	c5 f8 29 85 20 fe ff 	vmovaps XMMWORD PTR [rbp-0x1e0],xmm0
  212aa0:	ff 
  212aa1:	48 8d b5 20 fe ff ff 	lea    rsi,[rbp-0x1e0]
                return output(context, casted_value);
  212aa8:	48 8b 7d d0          	mov    rdi,QWORD PTR [rbp-0x30]
  212aac:	41 ff d6             	call   r14
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  212aaf:	66 85 c0             	test   ax,ax
  212ab2:	0f 85 b0 02 00 00    	jne    212d68 <dumpCurrentStackTrace+0x478>
        try output(context, fmt[start_index..]);
  212ab8:	48 8d 35 d1 d3 03 00 	lea    rsi,[rip+0x3d3d1]        # 24fe90 <__unnamed_24>
  212abf:	e9 9d 02 00 00       	jmp    212d61 <dumpCurrentStackTrace+0x471>
        self_debug_info = try openSelfDebugInfo(getDebugInfoAllocator());
  212ac4:	48 8b 45 b6          	mov    rax,QWORD PTR [rbp-0x4a]
  212ac8:	48 89 05 39 96 03 00 	mov    QWORD PTR [rip+0x39639],rax        # 24c108 <self_debug_info+0xc0>
  212acf:	c5 fc 10 45 96       	vmovups ymm0,YMMWORD PTR [rbp-0x6a]
  212ad4:	c5 fc 11 05 0c 96 03 	vmovups YMMWORD PTR [rip+0x3960c],ymm0        # 24c0e8 <self_debug_info+0xa0>
  212adb:	00 
  212adc:	c5 fc 10 85 76 ff ff 	vmovups ymm0,YMMWORD PTR [rbp-0x8a]
  212ae3:	ff 
  212ae4:	c5 fc 11 05 dc 95 03 	vmovups YMMWORD PTR [rip+0x395dc],ymm0        # 24c0c8 <self_debug_info+0x80>
  212aeb:	00 
  212aec:	c5 fc 10 85 f6 fe ff 	vmovups ymm0,YMMWORD PTR [rbp-0x10a]
  212af3:	ff 
  212af4:	c5 fc 10 8d 16 ff ff 	vmovups ymm1,YMMWORD PTR [rbp-0xea]
  212afb:	ff 
  212afc:	c5 fc 10 95 36 ff ff 	vmovups ymm2,YMMWORD PTR [rbp-0xca]
  212b03:	ff 
  212b04:	c5 fc 10 9d 56 ff ff 	vmovups ymm3,YMMWORD PTR [rbp-0xaa]
  212b0b:	ff 
  212b0c:	c5 fc 11 1d 94 95 03 	vmovups YMMWORD PTR [rip+0x39594],ymm3        # 24c0a8 <self_debug_info+0x60>
  212b13:	00 
  212b14:	c5 fc 11 15 6c 95 03 	vmovups YMMWORD PTR [rip+0x3956c],ymm2        # 24c088 <self_debug_info+0x40>
  212b1b:	00 
  212b1c:	c5 fc 11 0d 44 95 03 	vmovups YMMWORD PTR [rip+0x39544],ymm1        # 24c068 <self_debug_info+0x20>
  212b23:	00 
  212b24:	c5 fc 11 05 1c 95 03 	vmovups YMMWORD PTR [rip+0x3951c],ymm0        # 24c048 <self_debug_info>
  212b2b:	00 
  212b2c:	c6 05 dd 95 03 00 01 	mov    BYTE PTR [rip+0x395dd],0x1        # 24c110 <self_debug_info+0xc8>
  212b33:	8b 45 c9             	mov    eax,DWORD PTR [rbp-0x37]
  212b36:	89 05 d5 95 03 00    	mov    DWORD PTR [rip+0x395d5],eax        # 24c111 <self_debug_info+0xc9>
  212b3c:	0f b7 45 cd          	movzx  eax,WORD PTR [rbp-0x33]
  212b40:	66 89 05 ce 95 03 00 	mov    WORD PTR [rip+0x395ce],ax        # 24c115 <self_debug_info+0xcd>
  212b47:	8a 45 cf             	mov    al,BYTE PTR [rbp-0x31]
  212b4a:	88 05 c7 95 03 00    	mov    BYTE PTR [rip+0x395c7],al        # 24c117 <self_debug_info+0xcf>
    if (debug_info_allocator) |a| return a;
  212b50:	48 83 3d c0 e4 03 00 	cmp    QWORD PTR [rip+0x3e4c0],0x0        # 251018 <debug_info_allocator>
  212b57:	00 
  212b58:	0f 85 d0 fd ff ff    	jne    21292e <dumpCurrentStackTrace+0x3e>
    debug_info_direct_allocator = std.heap.DirectAllocator.init();
  212b5e:	c5 fc 10 05 fa d4 03 	vmovups ymm0,YMMWORD PTR [rip+0x3d4fa]        # 250060 <__unnamed_21>
  212b65:	00 
  212b66:	c5 fc 11 05 b2 95 03 	vmovups YMMWORD PTR [rip+0x395b2],ymm0        # 24c120 <debug_info_direct_allocator>
  212b6d:	00 
    debug_info_arena_allocator = std.heap.ArenaAllocator.init(&debug_info_direct_allocator.allocator);
  212b6e:	c5 f8 10 05 0a d5 03 	vmovups xmm0,XMMWORD PTR [rip+0x3d50a]        # 250080 <__unnamed_22>
  212b75:	00 
  212b76:	c5 f8 11 05 c2 95 03 	vmovups XMMWORD PTR [rip+0x395c2],xmm0        # 24c140 <debug_info_arena_allocator>
  212b7d:	00 
    debug_info_direct_allocator = std.heap.DirectAllocator.init();
  212b7e:	48 8d 05 9b 95 03 00 	lea    rax,[rip+0x3959b]        # 24c120 <debug_info_direct_allocator>
    debug_info_arena_allocator = std.heap.ArenaAllocator.init(&debug_info_direct_allocator.allocator);
  212b85:	48 8b 0d 04 d5 03 00 	mov    rcx,QWORD PTR [rip+0x3d504]        # 250090 <__unnamed_22+0x10>
  212b8c:	48 89 0d bd 95 03 00 	mov    QWORD PTR [rip+0x395bd],rcx        # 24c150 <debug_info_arena_allocator+0x10>
  212b93:	48 8d 0d a6 95 03 00 	lea    rcx,[rip+0x395a6]        # 24c140 <debug_info_arena_allocator>
  212b9a:	48 89 05 b7 95 03 00 	mov    QWORD PTR [rip+0x395b7],rax        # 24c158 <debug_info_arena_allocator+0x18>
  212ba1:	c5 f8 57 c0          	vxorps xmm0,xmm0,xmm0
  212ba5:	c5 fc 11 05 b3 95 03 	vmovups YMMWORD PTR [rip+0x395b3],ymm0        # 24c160 <debug_info_arena_allocator+0x20>
  212bac:	00 
    debug_info_allocator = &debug_info_arena_allocator.allocator;
  212bad:	48 89 0d 64 e4 03 00 	mov    QWORD PTR [rip+0x3e464],rcx        # 251018 <debug_info_allocator>
  212bb4:	48 8b 05 cd 95 03 00 	mov    rax,QWORD PTR [rip+0x395cd]        # 24c188 <posix_environ_raw+0x8>
  212bbb:	48 85 c0             	test   rax,rax
  212bbe:	0f 84 b9 00 00 00    	je     212c7d <dumpCurrentStackTrace+0x38d>
  212bc4:	48 8b 0d b5 95 03 00 	mov    rcx,QWORD PTR [rip+0x395b5]        # 24c180 <posix_environ_raw>
  212bcb:	31 d2                	xor    edx,edx
  212bcd:	0f 1f 00             	nop    DWORD PTR [rax]
  212bd0:	48 8b 34 d1          	mov    rsi,QWORD PTR [rcx+rdx*8]
  212bd4:	48 c7 c7 f1 ff ff ff 	mov    rdi,0xfffffffffffffff1
        var line_i: usize = 0;
        while (ptr[line_i] != 0 and ptr[line_i] != '=') : (line_i += 1) {}
  212bdb:	8a 5c 3e 0f          	mov    bl,BYTE PTR [rsi+rdi*1+0xf]
  212bdf:	84 db                	test   bl,bl
  212be1:	75 1a                	jne    212bfd <dumpCurrentStackTrace+0x30d>
  212be3:	eb 1d                	jmp    212c02 <dumpCurrentStackTrace+0x312>
  212be5:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  212bec:	00 00 00 00 
  212bf0:	48 83 c7 01          	add    rdi,0x1
  212bf4:	0f b6 5c 3e 0f       	movzx  ebx,BYTE PTR [rsi+rdi*1+0xf]
  212bf9:	84 db                	test   bl,bl
  212bfb:	74 05                	je     212c02 <dumpCurrentStackTrace+0x312>
  212bfd:	80 fb 3d             	cmp    bl,0x3d
  212c00:	75 ee                	jne    212bf0 <dumpCurrentStackTrace+0x300>
    if (a.len != b.len) return false;
  212c02:	48 85 ff             	test   rdi,rdi
  212c05:	75 69                	jne    212c70 <dumpCurrentStackTrace+0x380>
        if (b[index] != item) return false;
  212c07:	80 3e 5a             	cmp    BYTE PTR [rsi],0x5a
  212c0a:	75 64                	jne    212c70 <dumpCurrentStackTrace+0x380>
  212c0c:	80 7e 01 49          	cmp    BYTE PTR [rsi+0x1],0x49
  212c10:	75 5e                	jne    212c70 <dumpCurrentStackTrace+0x380>
  212c12:	80 7e 02 47          	cmp    BYTE PTR [rsi+0x2],0x47
  212c16:	75 58                	jne    212c70 <dumpCurrentStackTrace+0x380>
  212c18:	80 7e 03 5f          	cmp    BYTE PTR [rsi+0x3],0x5f
  212c1c:	75 52                	jne    212c70 <dumpCurrentStackTrace+0x380>
  212c1e:	80 7e 04 44          	cmp    BYTE PTR [rsi+0x4],0x44
  212c22:	75 4c                	jne    212c70 <dumpCurrentStackTrace+0x380>
  212c24:	80 7e 05 45          	cmp    BYTE PTR [rsi+0x5],0x45
  212c28:	75 46                	jne    212c70 <dumpCurrentStackTrace+0x380>
  212c2a:	80 7e 06 42          	cmp    BYTE PTR [rsi+0x6],0x42
  212c2e:	75 40                	jne    212c70 <dumpCurrentStackTrace+0x380>
  212c30:	80 7e 07 55          	cmp    BYTE PTR [rsi+0x7],0x55
  212c34:	75 3a                	jne    212c70 <dumpCurrentStackTrace+0x380>
  212c36:	80 7e 08 47          	cmp    BYTE PTR [rsi+0x8],0x47
  212c3a:	75 34                	jne    212c70 <dumpCurrentStackTrace+0x380>
  212c3c:	80 7e 09 5f          	cmp    BYTE PTR [rsi+0x9],0x5f
  212c40:	75 2e                	jne    212c70 <dumpCurrentStackTrace+0x380>
  212c42:	80 7e 0a 43          	cmp    BYTE PTR [rsi+0xa],0x43
  212c46:	75 28                	jne    212c70 <dumpCurrentStackTrace+0x380>
  212c48:	80 7e 0b 4f          	cmp    BYTE PTR [rsi+0xb],0x4f
  212c4c:	75 22                	jne    212c70 <dumpCurrentStackTrace+0x380>
  212c4e:	80 7e 0c 4c          	cmp    BYTE PTR [rsi+0xc],0x4c
  212c52:	75 1c                	jne    212c70 <dumpCurrentStackTrace+0x380>
  212c54:	80 7e 0d 4f          	cmp    BYTE PTR [rsi+0xd],0x4f
  212c58:	75 16                	jne    212c70 <dumpCurrentStackTrace+0x380>
  212c5a:	80 7e 0e 52          	cmp    BYTE PTR [rsi+0xe],0x52
  212c5e:	0f 84 19 01 00 00    	je     212d7d <dumpCurrentStackTrace+0x48d>
  212c64:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  212c6b:	00 00 00 00 00 
    for (posix_environ_raw) |ptr| {
  212c70:	48 83 c2 01          	add    rdx,0x1
  212c74:	48 39 c2             	cmp    rdx,rax
  212c77:	0f 82 53 ff ff ff    	jb     212bd0 <dumpCurrentStackTrace+0x2e0>
    return syscall3(SYS_ioctl, @intCast(usize, fd), TIOCGWINSZ, @ptrToInt(&wsz)) == 0;
  212c7d:	48 63 3d ac 93 03 00 	movsxd rdi,DWORD PTR [rip+0x393ac]        # 24c030 <stderr_file>
  212c84:	48 8d 95 20 fe ff ff 	lea    rdx,[rbp-0x1e0]
    return asm volatile ("syscall"
  212c8b:	b8 10 00 00 00       	mov    eax,0x10
  212c90:	be 13 54 00 00       	mov    esi,0x5413
  212c95:	0f 05                	syscall 
  212c97:	48 85 c0             	test   rax,rax
  212c9a:	0f 94 c1             	sete   cl
    if (start_addr) |addr| {
  212c9d:	41 80 7e 08 01       	cmp    BYTE PTR [r14+0x8],0x1
  212ca2:	75 0f                	jne    212cb3 <dumpCurrentStackTrace+0x3c3>
  212ca4:	4d 8b 2e             	mov    r13,QWORD PTR [r14]
  212ca7:	b0 01                	mov    al,0x1
    while (fp != 0) : (fp = @intToPtr(*const usize, fp).*) {
  212ca9:	48 85 ed             	test   rbp,rbp
  212cac:	75 10                	jne    212cbe <dumpCurrentStackTrace+0x3ce>
  212cae:	e9 b5 00 00 00       	jmp    212d68 <dumpCurrentStackTrace+0x478>
  212cb3:	31 c0                	xor    eax,eax
  212cb5:	48 85 ed             	test   rbp,rbp
  212cb8:	0f 84 aa 00 00 00    	je     212d68 <dumpCurrentStackTrace+0x478>
  212cbe:	49 89 ef             	mov    r15,rbp
  212cc1:	44 0f b6 e1          	movzx  r12d,cl
  212cc5:	4c 8d 35 7c 93 03 00 	lea    r14,[rip+0x3937c]        # 24c048 <self_debug_info>
  212ccc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
        const return_address = @intToPtr(*const usize, fp + @sizeOf(usize)).*;
  212cd0:	49 8b 57 08          	mov    rdx,QWORD PTR [r15+0x8]
                if (return_address == addr) {
  212cd4:	4c 39 ea             	cmp    rdx,r13
        switch (addr_state) {
  212cd7:	74 17                	je     212cf0 <dumpCurrentStackTrace+0x400>
  212cd9:	f6 d0                	not    al
  212cdb:	a8 01                	test   al,0x1
  212cdd:	b0 01                	mov    al,0x1
  212cdf:	75 0f                	jne    212cf0 <dumpCurrentStackTrace+0x400>
    while (fp != 0) : (fp = @intToPtr(*const usize, fp).*) {
  212ce1:	4d 8b 3f             	mov    r15,QWORD PTR [r15]
  212ce4:	4d 85 ff             	test   r15,r15
  212ce7:	75 e7                	jne    212cd0 <dumpCurrentStackTrace+0x3e0>
  212ce9:	eb 7d                	jmp    212d68 <dumpCurrentStackTrace+0x478>
  212ceb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
        builtin.Os.linux => return printSourceAtAddressLinux(debug_info, out_stream, address, tty_color),
  212cf0:	4c 89 f7             	mov    rdi,r14
  212cf3:	48 8b 75 d0          	mov    rsi,QWORD PTR [rbp-0x30]
  212cf7:	44 89 e1             	mov    ecx,r12d
  212cfa:	c5 f8 77             	vzeroupper 
  212cfd:	e8 8e 4f 01 00       	call   227c90 <printSourceAtAddressLinux>
  212d02:	89 c3                	mov    ebx,eax
        try printSourceAtAddress(debug_info, out_stream, return_address, tty_color);
  212d04:	66 85 db             	test   bx,bx
  212d07:	75 0c                	jne    212d15 <dumpCurrentStackTrace+0x425>
  212d09:	31 c0                	xor    eax,eax
    while (fp != 0) : (fp = @intToPtr(*const usize, fp).*) {
  212d0b:	4d 8b 3f             	mov    r15,QWORD PTR [r15]
  212d0e:	4d 85 ff             	test   r15,r15
  212d11:	75 bd                	jne    212cd0 <dumpCurrentStackTrace+0x3e0>
  212d13:	eb 53                	jmp    212d68 <dumpCurrentStackTrace+0x478>
  212d15:	48 8b 7d d0          	mov    rdi,QWORD PTR [rbp-0x30]
  212d19:	4c 8b 37             	mov    r14,QWORD PTR [rdi]
                        try output(context, fmt[start_index..i]);
  212d1c:	48 8d 35 1d d3 03 00 	lea    rsi,[rip+0x3d31d]        # 250040 <__unnamed_25>
  212d23:	41 ff d6             	call   r14
  212d26:	66 85 c0             	test   ax,ax
  212d29:	75 3d                	jne    212d68 <dumpCurrentStackTrace+0x478>
        stderr.print("Unable to dump stack trace: {}\n", @errorName(err)) catch return;
  212d2b:	48 0f bf c3          	movsx  rax,bx
  212d2f:	48 c1 e0 04          	shl    rax,0x4
  212d33:	48 8d 0d c6 a2 03 00 	lea    rcx,[rip+0x3a2c6]        # 24d000 <raw+0xe68>
                const casted_value = ([]const u8)(value);
  212d3a:	c5 f8 10 04 08       	vmovups xmm0,XMMWORD PTR [rax+rcx*1]
  212d3f:	c5 f8 29 85 20 fe ff 	vmovaps XMMWORD PTR [rbp-0x1e0],xmm0
  212d46:	ff 
  212d47:	48 8d b5 20 fe ff ff 	lea    rsi,[rbp-0x1e0]
                return output(context, casted_value);
  212d4e:	48 8b 7d d0          	mov    rdi,QWORD PTR [rbp-0x30]
  212d52:	41 ff d6             	call   r14
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  212d55:	66 85 c0             	test   ax,ax
  212d58:	75 0e                	jne    212d68 <dumpCurrentStackTrace+0x478>
        try output(context, fmt[start_index..]);
  212d5a:	48 8d 35 ef d2 03 00 	lea    rsi,[rip+0x3d2ef]        # 250050 <__unnamed_26>
  212d61:	48 8b 7d d0          	mov    rdi,QWORD PTR [rbp-0x30]
  212d65:	41 ff d6             	call   r14
    const stderr = getStderrStream() catch return;
  212d68:	48 81 c4 b8 01 00 00 	add    rsp,0x1b8
  212d6f:	5b                   	pop    rbx
  212d70:	41 5c                	pop    r12
  212d72:	41 5d                	pop    r13
  212d74:	41 5e                	pop    r14
  212d76:	41 5f                	pop    r15
  212d78:	5d                   	pop    rbp
  212d79:	c5 f8 77             	vzeroupper 
  212d7c:	c3                   	ret    
  212d7d:	48 c7 c0 fe ff ff ff 	mov    rax,0xfffffffffffffffe
        const this_key = ptr[0..line_i];
        if (!mem.eql(u8, key, this_key)) continue;

        var end_i: usize = line_i;
        while (ptr[end_i] != 0) : (end_i += 1) {}
  212d84:	80 7c 06 11 00       	cmp    BYTE PTR [rsi+rax*1+0x11],0x0
  212d89:	48 8d 40 01          	lea    rax,[rax+0x1]
  212d8d:	75 f5                	jne    212d84 <dumpCurrentStackTrace+0x494>
  212d8f:	b1 01                	mov    cl,0x1
        if (new_end_index > self.buffer.len) {
  212d91:	48 3d 81 00 00 00    	cmp    rax,0x81
        if (n == 0) {
  212d97:	0f 83 e0 fe ff ff    	jae    212c7d <dumpCurrentStackTrace+0x38d>
  212d9d:	e9 fb fe ff ff       	jmp    212c9d <dumpCurrentStackTrace+0x3ad>
  212da2:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  212da9:	1f 84 00 00 00 00 00 

0000000000212db0 <AlignedArrayList(Result,8)_append>:

            mem.copyBackwards(T, self.items[n + items.len .. self.len], self.items[n .. self.len - items.len]);
            mem.copy(T, self.items[n .. n + items.len], items);
        }

        pub fn append(self: *Self, item: T) !void {
  212db0:	41 57                	push   r15
  212db2:	41 56                	push   r14
  212db4:	41 54                	push   r12
  212db6:	53                   	push   rbx
  212db7:	48 83 ec 58          	sub    rsp,0x58
  212dbb:	49 89 f6             	mov    r14,rsi
  212dbe:	49 89 fc             	mov    r12,rdi
            assert(new_len <= self.len);
            self.len = new_len;
        }

        pub fn ensureCapacity(self: *Self, new_capacity: usize) !void {
            var better_capacity = self.items.len;
  212dc1:	49 8b 4c 24 08       	mov    rcx,QWORD PTR [r12+0x8]
            }
            self.items = try self.allocator.alignedRealloc(T, A, self.items, better_capacity);
        }

        pub fn addOne(self: *Self) !*T {
            const new_length = self.len + 1;
  212dc6:	49 8b 5c 24 10       	mov    rbx,QWORD PTR [r12+0x10]
            if (better_capacity >= new_capacity) return;
  212dcb:	48 39 d9             	cmp    rcx,rbx
  212dce:	76 25                	jbe    212df5 <AlignedArrayList(Result,8)_append+0x45>
            try self.ensureCapacity(new_length);
            const result = &self.items[self.len];
  212dd0:	49 8b 04 24          	mov    rax,QWORD PTR [r12]
  212dd4:	48 89 d9             	mov    rcx,rbx
  212dd7:	48 83 c3 01          	add    rbx,0x1
  212ddb:	48 c1 e1 04          	shl    rcx,0x4
            self.len = new_length;
  212ddf:	49 89 5c 24 10       	mov    QWORD PTR [r12+0x10],rbx
            new_item_ptr.* = item;
  212de4:	c4 c1 78 10 06       	vmovups xmm0,XMMWORD PTR [r14]
  212de9:	c5 f8 11 04 08       	vmovups XMMWORD PTR [rax+rcx*1],xmm0
        pub fn append(self: *Self, item: T) !void {
  212dee:	31 c0                	xor    eax,eax
  212df0:	e9 cf 00 00 00       	jmp    212ec4 <AlignedArrayList(Result,8)_append+0x114>
  212df5:	48 89 c8             	mov    rax,rcx
  212df8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  212dff:	00 
                better_capacity += better_capacity / 2 + 8;
  212e00:	48 89 c2             	mov    rdx,rax
  212e03:	48 d1 ea             	shr    rdx,1
  212e06:	48 01 d0             	add    rax,rdx
  212e09:	48 83 c0 08          	add    rax,0x8
                if (better_capacity >= new_capacity) break;
  212e0d:	48 39 d8             	cmp    rax,rbx
  212e10:	76 ee                	jbe    212e00 <AlignedArrayList(Result,8)_append+0x50>
            self.items = try self.allocator.alignedRealloc(T, A, self.items, better_capacity);
  212e12:	49 8b 74 24 18       	mov    rsi,QWORD PTR [r12+0x18]
        if (old_mem.len == 0) {
  212e17:	48 85 c9             	test   rcx,rcx
  212e1a:	74 2b                	je     212e47 <AlignedArrayList(Result,8)_append+0x97>
        const old_byte_slice = @sliceToBytes(old_mem);
  212e1c:	49 8b 14 24          	mov    rdx,QWORD PTR [r12]
  212e20:	48 c1 e1 04          	shl    rcx,0x4
  212e24:	48 89 54 24 20       	mov    QWORD PTR [rsp+0x20],rdx
  212e29:	48 89 4c 24 28       	mov    QWORD PTR [rsp+0x28],rcx
    return if (@mulWithOverflow(T, a, b, &answer)) error.Overflow else answer;
  212e2e:	b9 10 00 00 00       	mov    ecx,0x10
  212e33:	48 f7 e1             	mul    rcx
  212e36:	71 28                	jno    212e60 <AlignedArrayList(Result,8)_append+0xb0>
  212e38:	48 8d 0d 81 d6 fe ff 	lea    rcx,[rip+0xfffffffffffed681]        # 2004c0 <__unnamed_27>
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  212e3f:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  212e43:	75 7b                	jne    212ec0 <AlignedArrayList(Result,8)_append+0x110>
  212e45:	eb 30                	jmp    212e77 <AlignedArrayList(Result,8)_append+0xc7>
  212e47:	b9 10 00 00 00       	mov    ecx,0x10
  212e4c:	48 f7 e1             	mul    rcx
  212e4f:	71 58                	jno    212ea9 <AlignedArrayList(Result,8)_append+0xf9>
  212e51:	48 8d 0d 68 d6 fe ff 	lea    rcx,[rip+0xfffffffffffed668]        # 2004c0 <__unnamed_27>
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  212e58:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  212e5c:	75 62                	jne    212ec0 <AlignedArrayList(Result,8)_append+0x110>
  212e5e:	eb 70                	jmp    212ed0 <AlignedArrayList(Result,8)_append+0x120>
  212e60:	48 8d 4c 24 08       	lea    rcx,[rsp+0x8]
  212e65:	66 c7 44 24 08 00 00 	mov    WORD PTR [rsp+0x8],0x0
  212e6c:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  212e71:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  212e75:	75 49                	jne    212ec0 <AlignedArrayList(Result,8)_append+0x110>
  212e77:	4c 8b 79 08          	mov    r15,QWORD PTR [rcx+0x8]
  212e7b:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  212e80:	48 8d 54 24 20       	lea    rdx,[rsp+0x20]
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  212e85:	41 b8 08 00 00 00    	mov    r8d,0x8
  212e8b:	4c 89 f9             	mov    rcx,r15
  212e8e:	ff 56 08             	call   QWORD PTR [rsi+0x8]
  212e91:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
  212e96:	66 85 c0             	test   ax,ax
  212e99:	75 29                	jne    212ec4 <AlignedArrayList(Result,8)_append+0x114>
        assert(byte_slice.len == byte_count);
  212e9b:	4c 39 7c 24 50       	cmp    QWORD PTR [rsp+0x50],r15
    if (!ok) {
  212ea0:	75 6e                	jne    212f10 <AlignedArrayList(Result,8)_append+0x160>
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  212ea2:	48 8b 44 24 48       	mov    rax,QWORD PTR [rsp+0x48]
  212ea7:	eb 50                	jmp    212ef9 <AlignedArrayList(Result,8)_append+0x149>
  212ea9:	48 8d 4c 24 30       	lea    rcx,[rsp+0x30]
  212eae:	66 c7 44 24 30 00 00 	mov    WORD PTR [rsp+0x30],0x0
  212eb5:	48 89 44 24 38       	mov    QWORD PTR [rsp+0x38],rax
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  212eba:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  212ebe:	74 10                	je     212ed0 <AlignedArrayList(Result,8)_append+0x120>
  212ec0:	66 b8 01 00          	mov    ax,0x1
  212ec4:	48 83 c4 58          	add    rsp,0x58
  212ec8:	5b                   	pop    rbx
  212ec9:	41 5c                	pop    r12
  212ecb:	41 5e                	pop    r14
  212ecd:	41 5f                	pop    r15
  212ecf:	c3                   	ret    
  212ed0:	4c 8b 79 08          	mov    r15,QWORD PTR [rcx+0x8]
  212ed4:	48 8d 7c 24 08       	lea    rdi,[rsp+0x8]
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  212ed9:	b9 08 00 00 00       	mov    ecx,0x8
  212ede:	4c 89 fa             	mov    rdx,r15
  212ee1:	ff 16                	call   QWORD PTR [rsi]
  212ee3:	0f b7 44 24 08       	movzx  eax,WORD PTR [rsp+0x8]
  212ee8:	66 85 c0             	test   ax,ax
  212eeb:	75 d7                	jne    212ec4 <AlignedArrayList(Result,8)_append+0x114>
        assert(byte_slice.len == byte_count);
  212eed:	4c 39 7c 24 18       	cmp    QWORD PTR [rsp+0x18],r15
  212ef2:	75 1c                	jne    212f10 <AlignedArrayList(Result,8)_append+0x160>
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  212ef4:	48 8b 44 24 10       	mov    rax,QWORD PTR [rsp+0x10]
  212ef9:	49 89 04 24          	mov    QWORD PTR [r12],rax
  212efd:	49 c1 ef 04          	shr    r15,0x4
  212f01:	4d 89 7c 24 08       	mov    QWORD PTR [r12+0x8],r15
            const result = &self.items[self.len];
  212f06:	49 8b 4c 24 10       	mov    rcx,QWORD PTR [r12+0x10]
  212f0b:	e9 c7 fe ff ff       	jmp    212dd7 <AlignedArrayList(Result,8)_append+0x27>
            @panic("assertion failure");
  212f10:	48 8d 3d 79 ce 03 00 	lea    rdi,[rip+0x3ce79]        # 24fd90 <__unnamed_2>
  212f17:	e8 04 f8 ff ff       	call   212720 <panic>
  212f1c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

0000000000212f20 <Benchmark_report>:
    fn report(pSelf: *Self, result: Result) !void {
  212f20:	55                   	push   rbp
  212f21:	41 57                	push   r15
  212f23:	41 56                	push   r14
  212f25:	41 55                	push   r13
  212f27:	41 54                	push   r12
  212f29:	53                   	push   rbx
  212f2a:	48 81 ec b8 00 00 00 	sub    rsp,0xb8
  212f31:	48 89 f5             	mov    rbp,rsi
  212f34:	48 8b 37             	mov    rsi,QWORD PTR [rdi]
  212f37:	48 8b 5f 08          	mov    rbx,QWORD PTR [rdi+0x8]
        var buffer: [40]u8 = undefined;
  212f3b:	48 8b 05 2d 30 ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffff302d]        # 205f6f <__unnamed_7+0x20>
  212f42:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
  212f47:	c5 fd 10 05 00 30 ff 	vmovupd ymm0,YMMWORD PTR [rip+0xffffffffffff3000]        # 205f4f <__unnamed_7>
  212f4e:	ff 
  212f4f:	c5 fd 11 44 24 30    	vmovupd YMMWORD PTR [rsp+0x30],ymm0
const BufPrintContext = struct {
    remaining: []u8,
};

fn bufPrintWrite(context: *BufPrintContext, bytes: []const u8) !void {
    if (context.remaining.len < bytes.len) return error.BufferTooSmall;
  212f55:	48 83 fb 28          	cmp    rbx,0x28
  212f59:	0f 87 2f 02 00 00    	ja     21318e <Benchmark_report+0x26e>
    for (source) |s, i|
  212f5f:	48 85 db             	test   rbx,rbx
  212f62:	74 12                	je     212f76 <Benchmark_report+0x56>
  212f64:	48 8d 7c 24 30       	lea    rdi,[rsp+0x30]
        dest[i] = s;
  212f69:	48 89 da             	mov    rdx,rbx
  212f6c:	c5 f8 77             	vzeroupper 
  212f6f:	e8 0c bf 01 00       	call   22ee80 <memcpy>
  212f74:	eb 0a                	jmp    212f80 <Benchmark_report+0x60>
  212f76:	31 db                	xor    ebx,ebx
  212f78:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  212f7f:	00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  212f80:	b0 01                	mov    al,0x1
  212f82:	86 05 88 e0 03 00    	xchg   BYTE PTR [rip+0x3e088],al        # 251010 <stderr_mutex>
  212f88:	84 c0                	test   al,al
  212f8a:	75 f4                	jne    212f80 <Benchmark_report+0x60>
    if (stderr_stream) |st| {
  212f8c:	48 8b 3d 75 e0 03 00 	mov    rdi,QWORD PTR [rip+0x3e075]        # 251008 <stderr_stream>
  212f93:	48 85 ff             	test   rdi,rdi
  212f96:	48 89 6c 24 08       	mov    QWORD PTR [rsp+0x8],rbp
  212f9b:	74 09                	je     212fa6 <Benchmark_report+0x86>
  212f9d:	48 8b 0d 9c 90 03 00 	mov    rcx,QWORD PTR [rip+0x3909c]        # 24c040 <stderr_file_out_stream+0x8>
  212fa4:	eb 34                	jmp    212fda <Benchmark_report+0xba>
        stderr_file = try io.getStdErr();
  212fa6:	48 8d 05 83 90 03 00 	lea    rax,[rip+0x39083]        # 24c030 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  212fad:	48 89 05 84 90 03 00 	mov    QWORD PTR [rip+0x39084],rax        # 24c038 <stderr_file_out_stream>
  212fb4:	48 8d 0d e5 be 00 00 	lea    rcx,[rip+0xbee5]        # 21eea0 <FileOutStream_writeFn>
  212fbb:	48 89 0d 7e 90 03 00 	mov    QWORD PTR [rip+0x3907e],rcx        # 24c040 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  212fc2:	c7 05 64 90 03 00 02 	mov    DWORD PTR [rip+0x39064],0x2        # 24c030 <stderr_file>
  212fc9:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  212fcc:	48 8d 3d 6d 90 03 00 	lea    rdi,[rip+0x3906d]        # 24c040 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  212fd3:	48 89 3d 2e e0 03 00 	mov    QWORD PTR [rip+0x3e02e],rdi        # 251008 <stderr_stream>
  212fda:	48 8d 44 24 30       	lea    rax,[rsp+0x30]
                const casted_value = ([]const u8)(value);
  212fdf:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  212fe4:	48 89 5c 24 68       	mov    QWORD PTR [rsp+0x68],rbx
  212fe9:	48 8d 74 24 60       	lea    rsi,[rsp+0x60]
                return output(context, casted_value);
  212fee:	c5 f8 77             	vzeroupper 
  212ff1:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  212ff3:	31 c0                	xor    eax,eax
  212ff5:	86 05 15 e0 03 00    	xchg   BYTE PTR [rip+0x3e015],al        # 251010 <stderr_mutex>
  212ffb:	3c 01                	cmp    al,0x1
    if (!ok) {
  212ffd:	0f 85 af 09 00 00    	jne    2139b2 <Benchmark_report+0xa92>
        if (width > str.len) {
  213003:	48 83 fb 15          	cmp    rbx,0x15
  213007:	0f 87 b1 00 00 00    	ja     2130be <Benchmark_report+0x19e>
            pad(width - str.len, ' ');
  21300d:	bd 16 00 00 00       	mov    ebp,0x16
        while (i < count) : (i += 1) {
  213012:	48 29 dd             	sub    rbp,rbx
  213015:	0f 84 a3 00 00 00    	je     2130be <Benchmark_report+0x19e>
  21301b:	31 db                	xor    ebx,ebx
  21301d:	4c 8d 35 7c be 00 00 	lea    r14,[rip+0xbe7c]        # 21eea0 <FileOutStream_writeFn>
  213024:	4c 8d 2d 15 90 03 00 	lea    r13,[rip+0x39015]        # 24c040 <stderr_file_out_stream+0x8>
  21302b:	4c 8d 7c 24 18       	lea    r15,[rsp+0x18]
  213030:	4c 8d 64 24 60       	lea    r12,[rsp+0x60]
  213035:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21303c:	00 00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  213040:	b0 01                	mov    al,0x1
  213042:	86 05 c8 df 03 00    	xchg   BYTE PTR [rip+0x3dfc8],al        # 251010 <stderr_mutex>
  213048:	84 c0                	test   al,al
  21304a:	75 f4                	jne    213040 <Benchmark_report+0x120>
    if (stderr_stream) |st| {
  21304c:	48 8b 3d b5 df 03 00 	mov    rdi,QWORD PTR [rip+0x3dfb5]        # 251008 <stderr_stream>
  213053:	48 85 ff             	test   rdi,rdi
  213056:	74 09                	je     213061 <Benchmark_report+0x141>
  213058:	48 8b 0d e1 8f 03 00 	mov    rcx,QWORD PTR [rip+0x38fe1]        # 24c040 <stderr_file_out_stream+0x8>
  21305f:	eb 2c                	jmp    21308d <Benchmark_report+0x16d>
        stderr_file = try io.getStdErr();
  213061:	c7 05 c5 8f 03 00 02 	mov    DWORD PTR [rip+0x38fc5],0x2        # 24c030 <stderr_file>
  213068:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  21306b:	48 8d 05 be 8f 03 00 	lea    rax,[rip+0x38fbe]        # 24c030 <stderr_file>
  213072:	48 89 05 bf 8f 03 00 	mov    QWORD PTR [rip+0x38fbf],rax        # 24c038 <stderr_file_out_stream>
  213079:	4c 89 35 c0 8f 03 00 	mov    QWORD PTR [rip+0x38fc0],r14        # 24c040 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  213080:	4c 89 2d 81 df 03 00 	mov    QWORD PTR [rip+0x3df81],r13        # 251008 <stderr_stream>
  213087:	4c 89 f1             	mov    rcx,r14
  21308a:	4c 89 ef             	mov    rdi,r13
  21308d:	c6 44 24 18 20       	mov    BYTE PTR [rsp+0x18],0x20
    return output(context, (*[1]u8)(&c)[0..]);
  213092:	4c 89 7c 24 60       	mov    QWORD PTR [rsp+0x60],r15
  213097:	48 c7 44 24 68 01 00 	mov    QWORD PTR [rsp+0x68],0x1
  21309e:	00 00 
  2130a0:	4c 89 e6             	mov    rsi,r12
  2130a3:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  2130a5:	31 c0                	xor    eax,eax
  2130a7:	86 05 63 df 03 00    	xchg   BYTE PTR [rip+0x3df63],al        # 251010 <stderr_mutex>
  2130ad:	3c 01                	cmp    al,0x1
    if (!ok) {
  2130af:	0f 85 fd 08 00 00    	jne    2139b2 <Benchmark_report+0xa92>
  2130b5:	48 83 c3 01          	add    rbx,0x1
  2130b9:	48 39 eb             	cmp    rbx,rbp
  2130bc:	72 82                	jb     213040 <Benchmark_report+0x120>
  2130be:	4c 8b 7c 24 08       	mov    r15,QWORD PTR [rsp+0x8]
        try rightJustified(14, "{}", result.iterations);
  2130c3:	49 8b 47 08          	mov    rax,QWORD PTR [r15+0x8]
  2130c7:	4c 8b 35 a1 2e ff ff 	mov    r14,QWORD PTR [rip+0xffffffffffff2ea1]        # 205f6f <__unnamed_7+0x20>
        var buffer: [40]u8 = undefined;
  2130ce:	4c 89 74 24 50       	mov    QWORD PTR [rsp+0x50],r14
  2130d3:	c5 fc 10 05 74 2e ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffff2e74]        # 205f4f <__unnamed_7>
  2130da:	ff 
  2130db:	c5 fc 11 44 24 30    	vmovups YMMWORD PTR [rsp+0x30],ymm0
    var buf: [max_int_digits - 1]u8 = undefined;
  2130e1:	c5 fc 10 05 06 66 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffff6606]        # 2096ef <__unnamed_28+0x1f>
  2130e8:	ff 
  2130e9:	c5 fc 11 44 24 7f    	vmovups YMMWORD PTR [rsp+0x7f],ymm0
  2130ef:	c5 fd 10 05 d9 65 ff 	vmovupd ymm0,YMMWORD PTR [rip+0xffffffffffff65d9]        # 2096d0 <__unnamed_28>
  2130f6:	ff 
  2130f7:	c5 fd 11 44 24 60    	vmovupd YMMWORD PTR [rsp+0x60],ymm0
        const digit = a % base;
  2130fd:	48 be cd cc cc cc cc 	movabs rsi,0xcccccccccccccccd
  213104:	cc cc cc 
  213107:	48 89 c2             	mov    rdx,rax
  21310a:	c4 e2 f3 f6 d6       	mulx   rdx,rcx,rsi
  21310f:	c1 ea 02             	shr    edx,0x2
  213112:	81 e2 fe ff ff 3f    	and    edx,0x3ffffffe
  213118:	8d 0c 92             	lea    ecx,[rdx+rdx*4]
  21311b:	89 c2                	mov    edx,eax
  21311d:	29 ca                	sub    edx,ecx
        0...9 => digit + '0',
  21311f:	b1 30                	mov    cl,0x30
  213121:	80 fa 0a             	cmp    dl,0xa
  213124:	72 02                	jb     213128 <Benchmark_report+0x208>
  213126:	b1 57                	mov    cl,0x57
  213128:	00 d1                	add    cl,dl
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  21312a:	88 8c 24 9f 00 00 00 	mov    BYTE PTR [rsp+0x9f],cl
  213131:	bb 40 00 00 00       	mov    ebx,0x40
        if (a == 0) break;
  213136:	48 83 f8 0a          	cmp    rax,0xa
  21313a:	72 43                	jb     21317f <Benchmark_report+0x25f>
  21313c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
        a /= base;
  213140:	48 89 c2             	mov    rdx,rax
  213143:	c4 e2 f3 f6 d6       	mulx   rdx,rcx,rsi
  213148:	48 c1 ea 03          	shr    rdx,0x3
        const digit = a % base;
  21314c:	c4 e2 f3 f6 fe       	mulx   rdi,rcx,rsi
  213151:	c1 ef 02             	shr    edi,0x2
  213154:	81 e7 fe ff ff 3f    	and    edi,0x3ffffffe
  21315a:	8d 0c bf             	lea    ecx,[rdi+rdi*4]
  21315d:	89 d7                	mov    edi,edx
  21315f:	29 cf                	sub    edi,ecx
        0...9 => digit + '0',
  213161:	b1 30                	mov    cl,0x30
  213163:	40 80 ff 0a          	cmp    dil,0xa
  213167:	72 02                	jb     21316b <Benchmark_report+0x24b>
  213169:	b1 57                	mov    cl,0x57
  21316b:	40 00 f9             	add    cl,dil
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  21316e:	88 4c 1c 5e          	mov    BYTE PTR [rsp+rbx*1+0x5e],cl
        if (a == 0) break;
  213172:	48 83 c3 ff          	add    rbx,0xffffffffffffffff
  213176:	48 83 f8 63          	cmp    rax,0x63
  21317a:	48 89 d0             	mov    rax,rdx
  21317d:	77 c1                	ja     213140 <Benchmark_report+0x220>
        const padded_buf = buf[index - padding ..];
  21317f:	41 bc 41 00 00 00    	mov    r12d,0x41
  213185:	49 29 dc             	sub    r12,rbx
    if (context.remaining.len < bytes.len) return error.BufferTooSmall;
  213188:	49 83 fc 28          	cmp    r12,0x28
  21318c:	76 19                	jbe    2131a7 <Benchmark_report+0x287>
  21318e:	66 b8 05 00          	mov    ax,0x5
  213192:	48 81 c4 b8 00 00 00 	add    rsp,0xb8
  213199:	5b                   	pop    rbx
  21319a:	41 5c                	pop    r12
  21319c:	41 5d                	pop    r13
  21319e:	41 5e                	pop    r14
  2131a0:	41 5f                	pop    r15
  2131a2:	5d                   	pop    rbp
  2131a3:	c5 f8 77             	vzeroupper 
  2131a6:	c3                   	ret    
    for (source) |s, i|
  2131a7:	4d 85 e4             	test   r12,r12
  2131aa:	74 1f                	je     2131cb <Benchmark_report+0x2ab>
        dest[i] = s;
  2131ac:	88 4c 24 30          	mov    BYTE PTR [rsp+0x30],cl
    for (source) |s, i|
  2131b0:	49 83 fc 01          	cmp    r12,0x1
  2131b4:	75 27                	jne    2131dd <Benchmark_report+0x2bd>
  2131b6:	41 bc 01 00 00 00    	mov    r12d,0x1
            pad(width - str.len, ' ');
  2131bc:	bd 0e 00 00 00       	mov    ebp,0xe
        while (i < count) : (i += 1) {
  2131c1:	4c 29 e5             	sub    rbp,r12
  2131c4:	75 4c                	jne    213212 <Benchmark_report+0x2f2>
  2131c6:	e9 15 01 00 00       	jmp    2132e0 <Benchmark_report+0x3c0>
  2131cb:	45 31 e4             	xor    r12d,r12d
            pad(width - str.len, ' ');
  2131ce:	bd 0e 00 00 00       	mov    ebp,0xe
        while (i < count) : (i += 1) {
  2131d3:	4c 29 e5             	sub    rbp,r12
  2131d6:	75 3a                	jne    213212 <Benchmark_report+0x2f2>
  2131d8:	e9 03 01 00 00       	jmp    2132e0 <Benchmark_report+0x3c0>
  2131dd:	48 8d 7c 24 31       	lea    rdi,[rsp+0x31]
  2131e2:	48 8d 34 1c          	lea    rsi,[rsp+rbx*1]
  2131e6:	48 83 c6 60          	add    rsi,0x60
  2131ea:	ba 40 00 00 00       	mov    edx,0x40
  2131ef:	48 29 da             	sub    rdx,rbx
        dest[i] = s;
  2131f2:	c5 f8 77             	vzeroupper 
  2131f5:	e8 86 bc 01 00       	call   22ee80 <memcpy>
        if (width > str.len) {
  2131fa:	49 83 fc 0d          	cmp    r12,0xd
  2131fe:	0f 87 dc 00 00 00    	ja     2132e0 <Benchmark_report+0x3c0>
            pad(width - str.len, ' ');
  213204:	bd 0e 00 00 00       	mov    ebp,0xe
        while (i < count) : (i += 1) {
  213209:	4c 29 e5             	sub    rbp,r12
  21320c:	0f 84 ce 00 00 00    	je     2132e0 <Benchmark_report+0x3c0>
  213212:	4c 89 64 24 10       	mov    QWORD PTR [rsp+0x10],r12
  213217:	45 31 ff             	xor    r15d,r15d
  21321a:	4c 8d 2d 7f bc 00 00 	lea    r13,[rip+0xbc7f]        # 21eea0 <FileOutStream_writeFn>
  213221:	4c 8d 35 18 8e 03 00 	lea    r14,[rip+0x38e18]        # 24c040 <stderr_file_out_stream+0x8>
  213228:	4c 8d 64 24 18       	lea    r12,[rsp+0x18]
  21322d:	48 8d 5c 24 60       	lea    rbx,[rsp+0x60]
  213232:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  213239:	1f 84 00 00 00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  213240:	b0 01                	mov    al,0x1
  213242:	86 05 c8 dd 03 00    	xchg   BYTE PTR [rip+0x3ddc8],al        # 251010 <stderr_mutex>
  213248:	84 c0                	test   al,al
  21324a:	75 f4                	jne    213240 <Benchmark_report+0x320>
    if (stderr_stream) |st| {
  21324c:	48 8b 3d b5 dd 03 00 	mov    rdi,QWORD PTR [rip+0x3ddb5]        # 251008 <stderr_stream>
  213253:	48 85 ff             	test   rdi,rdi
  213256:	74 09                	je     213261 <Benchmark_report+0x341>
  213258:	48 8b 0d e1 8d 03 00 	mov    rcx,QWORD PTR [rip+0x38de1]        # 24c040 <stderr_file_out_stream+0x8>
  21325f:	eb 2c                	jmp    21328d <Benchmark_report+0x36d>
        stderr_file = try io.getStdErr();
  213261:	c7 05 c5 8d 03 00 02 	mov    DWORD PTR [rip+0x38dc5],0x2        # 24c030 <stderr_file>
  213268:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  21326b:	48 8d 05 be 8d 03 00 	lea    rax,[rip+0x38dbe]        # 24c030 <stderr_file>
  213272:	48 89 05 bf 8d 03 00 	mov    QWORD PTR [rip+0x38dbf],rax        # 24c038 <stderr_file_out_stream>
  213279:	4c 89 2d c0 8d 03 00 	mov    QWORD PTR [rip+0x38dc0],r13        # 24c040 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  213280:	4c 89 35 81 dd 03 00 	mov    QWORD PTR [rip+0x3dd81],r14        # 251008 <stderr_stream>
  213287:	4c 89 e9             	mov    rcx,r13
  21328a:	4c 89 f7             	mov    rdi,r14
  21328d:	c6 44 24 18 20       	mov    BYTE PTR [rsp+0x18],0x20
    return output(context, (*[1]u8)(&c)[0..]);
  213292:	4c 89 64 24 60       	mov    QWORD PTR [rsp+0x60],r12
  213297:	48 c7 44 24 68 01 00 	mov    QWORD PTR [rsp+0x68],0x1
  21329e:	00 00 
  2132a0:	48 89 de             	mov    rsi,rbx
  2132a3:	c5 f8 77             	vzeroupper 
  2132a6:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  2132a8:	31 c0                	xor    eax,eax
  2132aa:	86 05 60 dd 03 00    	xchg   BYTE PTR [rip+0x3dd60],al        # 251010 <stderr_mutex>
  2132b0:	3c 01                	cmp    al,0x1
    if (!ok) {
  2132b2:	0f 85 fa 06 00 00    	jne    2139b2 <Benchmark_report+0xa92>
  2132b8:	49 83 c7 01          	add    r15,0x1
  2132bc:	49 39 ef             	cmp    r15,rbp
  2132bf:	0f 82 7b ff ff ff    	jb     213240 <Benchmark_report+0x320>
  2132c5:	4c 8b 35 a3 2c ff ff 	mov    r14,QWORD PTR [rip+0xffffffffffff2ca3]        # 205f6f <__unnamed_7+0x20>
  2132cc:	4c 8b 7c 24 08       	mov    r15,QWORD PTR [rsp+0x8]
  2132d1:	4c 8b 64 24 10       	mov    r12,QWORD PTR [rsp+0x10]
  2132d6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  2132dd:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  2132e0:	b0 01                	mov    al,0x1
  2132e2:	86 05 28 dd 03 00    	xchg   BYTE PTR [rip+0x3dd28],al        # 251010 <stderr_mutex>
  2132e8:	84 c0                	test   al,al
  2132ea:	75 f4                	jne    2132e0 <Benchmark_report+0x3c0>
    if (stderr_stream) |st| {
  2132ec:	48 8b 3d 15 dd 03 00 	mov    rdi,QWORD PTR [rip+0x3dd15]        # 251008 <stderr_stream>
  2132f3:	48 85 ff             	test   rdi,rdi
  2132f6:	74 09                	je     213301 <Benchmark_report+0x3e1>
  2132f8:	48 8b 0d 41 8d 03 00 	mov    rcx,QWORD PTR [rip+0x38d41]        # 24c040 <stderr_file_out_stream+0x8>
  2132ff:	eb 34                	jmp    213335 <Benchmark_report+0x415>
        stderr_file = try io.getStdErr();
  213301:	48 8d 05 28 8d 03 00 	lea    rax,[rip+0x38d28]        # 24c030 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  213308:	48 89 05 29 8d 03 00 	mov    QWORD PTR [rip+0x38d29],rax        # 24c038 <stderr_file_out_stream>
  21330f:	48 8d 0d 8a bb 00 00 	lea    rcx,[rip+0xbb8a]        # 21eea0 <FileOutStream_writeFn>
  213316:	48 89 0d 23 8d 03 00 	mov    QWORD PTR [rip+0x38d23],rcx        # 24c040 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  21331d:	c7 05 09 8d 03 00 02 	mov    DWORD PTR [rip+0x38d09],0x2        # 24c030 <stderr_file>
  213324:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  213327:	48 8d 3d 12 8d 03 00 	lea    rdi,[rip+0x38d12]        # 24c040 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  21332e:	48 89 3d d3 dc 03 00 	mov    QWORD PTR [rip+0x3dcd3],rdi        # 251008 <stderr_stream>
                const casted_value = ([]const u8)(value);
  213335:	48 8d 44 24 30       	lea    rax,[rsp+0x30]
  21333a:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  21333f:	4c 89 64 24 68       	mov    QWORD PTR [rsp+0x68],r12
  213344:	48 8d 5c 24 60       	lea    rbx,[rsp+0x60]
                return output(context, casted_value);
  213349:	48 89 de             	mov    rsi,rbx
  21334c:	c5 f8 77             	vzeroupper 
  21334f:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  213351:	31 c0                	xor    eax,eax
  213353:	86 05 b7 dc 03 00    	xchg   BYTE PTR [rip+0x3dcb7],al        # 251010 <stderr_mutex>
  213359:	3c 01                	cmp    al,0x1
    if (!ok) {
  21335b:	0f 85 51 06 00 00    	jne    2139b2 <Benchmark_report+0xa92>
                @intToFloat(f64, result.run_time_ns)/@intToFloat(f64, ns_per_s));
  213361:	c4 c1 7b 10 07       	vmovsd xmm0,QWORD PTR [r15]
  213366:	c5 f8 14 05 b2 ce fe 	vunpcklps xmm0,xmm0,XMMWORD PTR [rip+0xfffffffffffeceb2]        # 200220 <__unnamed_29+0x20>
  21336d:	ff 
  21336e:	c5 f9 5c 05 ba d3 fe 	vsubpd xmm0,xmm0,XMMWORD PTR [rip+0xfffffffffffed3ba]        # 200730 <__unnamed_55+0x10>
  213375:	ff 
  213376:	c5 f9 7c c0          	vhaddpd xmm0,xmm0,xmm0
  21337a:	c5 fb 5e 05 ae d8 fe 	vdivsd xmm0,xmm0,QWORD PTR [rip+0xfffffffffffed8ae]        # 200c30 <__unnamed_464+0x20>
  213381:	ff 
        var buffer: [40]u8 = undefined;
  213382:	4c 89 74 24 50       	mov    QWORD PTR [rsp+0x50],r14
  213387:	c5 fc 10 0d c0 2b ff 	vmovups ymm1,YMMWORD PTR [rip+0xffffffffffff2bc0]        # 205f4f <__unnamed_7>
  21338e:	ff 
  21338f:	c5 fc 11 4c 24 30    	vmovups YMMWORD PTR [rsp+0x30],ymm1
    const bits = @bitCast(u32, x);
    return bits >> 31 != 0;
}

fn signbit64(x: f64) bool {
    const bits = @bitCast(u64, x);
  213395:	c4 e1 f9 7e c0       	vmovq  rax,xmm0
    return bits >> 63 != 0;
  21339a:	48 85 c0             	test   rax,rax
    if (math.signbit(x)) {
  21339d:	78 0d                	js     2133ac <Benchmark_report+0x48c>
  21339f:	41 be 28 00 00 00    	mov    r14d,0x28
  2133a5:	48 8d 6c 24 30       	lea    rbp,[rsp+0x30]
  2133aa:	eb 18                	jmp    2133c4 <Benchmark_report+0x4a4>
  2133ac:	c6 44 24 30 2d       	mov    BYTE PTR [rsp+0x30],0x2d
    mem.copy(u8, context.remaining, bytes);
    context.remaining = context.remaining[bytes.len..];
  2133b1:	48 8d 6c 24 31       	lea    rbp,[rsp+0x31]
        x = -x;
  2133b6:	c5 f9 57 05 92 d3 fe 	vxorpd xmm0,xmm0,XMMWORD PTR [rip+0xfffffffffffed392]        # 200750 <__unnamed_563+0x10>
  2133bd:	ff 
  2133be:	41 be 27 00 00 00    	mov    r14d,0x27
  2133c4:	48 ba 00 00 00 00 00 	movabs rdx,0x7ff0000000000000
  2133cb:	00 f0 7f 
        f32 => {
            const bits = @bitCast(u32, x);
            return bits & 0x7FFFFFFF > 0x7F800000;
        },
        f64 => {
            const bits = @bitCast(u64, x);
  2133ce:	c4 e1 f9 7e c0       	vmovq  rax,xmm0
            return (bits & (@maxValue(u64) >> 1)) > (u64(0x7FF) << 52);
  2133d3:	b1 3f                	mov    cl,0x3f
  2133d5:	c4 e2 f0 f5 c8       	bzhi   rcx,rax,rcx
  2133da:	48 39 d1             	cmp    rcx,rdx
    if (math.isNan(x)) {
  2133dd:	76 0c                	jbe    2133eb <Benchmark_report+0x4cb>
  2133df:	66 c7 45 00 6e 61    	mov    WORD PTR [rbp+0x0],0x616e
  2133e5:	c6 45 02 6e          	mov    BYTE PTR [rbp+0x2],0x6e
  2133e9:	eb 13                	jmp    2133fe <Benchmark_report+0x4de>
        },
        f32 => {
            return @bitCast(u32, x) == 0x7F800000;
        },
        f64 => {
            return @bitCast(u64, x) == 0x7FF << 52;
  2133eb:	48 39 d0             	cmp    rax,rdx
    if (math.isPositiveInf(x)) {
  2133ee:	0f 85 44 01 00 00    	jne    213538 <Benchmark_report+0x618>
  2133f4:	66 c7 45 00 69 6e    	mov    WORD PTR [rbp+0x0],0x6e69
  2133fa:	c6 45 02 66          	mov    BYTE PTR [rbp+0x2],0x66
    context.remaining = context.remaining[bytes.len..];
  2133fe:	48 83 c5 03          	add    rbp,0x3
  213402:	49 83 c6 fd          	add    r14,0xfffffffffffffffd
  213406:	31 c0                	xor    eax,eax
  213408:	4c 89 f7             	mov    rdi,r14
                    try formatType(args[next_arg], fmt[s..i], context, Errors, output);
  21340b:	66 85 c0             	test   ax,ax
  21340e:	0f 85 7e fd ff ff    	jne    213192 <Benchmark_report+0x272>
  213414:	66 b8 05 00          	mov    ax,0x5
    if (context.remaining.len < bytes.len) return error.BufferTooSmall;
  213418:	48 83 ff 02          	cmp    rdi,0x2
  21341c:	0f 82 70 fd ff ff    	jb     213192 <Benchmark_report+0x272>
  213422:	66 c7 45 00 20 73    	mov    WORD PTR [rbp+0x0],0x7320
}

pub fn bufPrint(buf: []u8, comptime fmt: []const u8, args: ...) ![]u8 {
    var context = BufPrintContext{ .remaining = buf };
    try format(&context, error{BufferTooSmall}, bufPrintWrite, fmt, args);
    return buf[0 .. buf.len - context.remaining.len];
  213428:	b8 2a 00 00 00       	mov    eax,0x2a
  21342d:	48 29 f8             	sub    rax,rdi
  213430:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
        if (width > str.len) {
  213435:	48 83 f8 0c          	cmp    rax,0xc
  213439:	0f 83 d1 00 00 00    	jae    213510 <Benchmark_report+0x5f0>
  21343f:	b8 02 00 00 00       	mov    eax,0x2
  213444:	48 29 f8             	sub    rax,rdi
            pad(width - str.len, ' ');
  213447:	48 c7 c5 e4 ff ff ff 	mov    rbp,0xffffffffffffffe4
        while (i < count) : (i += 1) {
  21344e:	48 29 c5             	sub    rbp,rax
  213451:	0f 84 b9 00 00 00    	je     213510 <Benchmark_report+0x5f0>
  213457:	31 db                	xor    ebx,ebx
  213459:	4c 8d 25 40 ba 00 00 	lea    r12,[rip+0xba40]        # 21eea0 <FileOutStream_writeFn>
  213460:	4c 8d 35 d9 8b 03 00 	lea    r14,[rip+0x38bd9]        # 24c040 <stderr_file_out_stream+0x8>
  213467:	4c 8d 6c 24 18       	lea    r13,[rsp+0x18]
  21346c:	4c 8d 7c 24 60       	lea    r15,[rsp+0x60]
  213471:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  213478:	0f 1f 84 00 00 00 00 
  21347f:	00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  213480:	b0 01                	mov    al,0x1
  213482:	86 05 88 db 03 00    	xchg   BYTE PTR [rip+0x3db88],al        # 251010 <stderr_mutex>
  213488:	84 c0                	test   al,al
  21348a:	75 f4                	jne    213480 <Benchmark_report+0x560>
    if (stderr_stream) |st| {
  21348c:	48 8b 3d 75 db 03 00 	mov    rdi,QWORD PTR [rip+0x3db75]        # 251008 <stderr_stream>
  213493:	48 85 ff             	test   rdi,rdi
  213496:	74 09                	je     2134a1 <Benchmark_report+0x581>
  213498:	48 8b 0d a1 8b 03 00 	mov    rcx,QWORD PTR [rip+0x38ba1]        # 24c040 <stderr_file_out_stream+0x8>
  21349f:	eb 2c                	jmp    2134cd <Benchmark_report+0x5ad>
        stderr_file = try io.getStdErr();
  2134a1:	c7 05 85 8b 03 00 02 	mov    DWORD PTR [rip+0x38b85],0x2        # 24c030 <stderr_file>
  2134a8:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  2134ab:	48 8d 05 7e 8b 03 00 	lea    rax,[rip+0x38b7e]        # 24c030 <stderr_file>
  2134b2:	48 89 05 7f 8b 03 00 	mov    QWORD PTR [rip+0x38b7f],rax        # 24c038 <stderr_file_out_stream>
  2134b9:	4c 89 25 80 8b 03 00 	mov    QWORD PTR [rip+0x38b80],r12        # 24c040 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  2134c0:	4c 89 35 41 db 03 00 	mov    QWORD PTR [rip+0x3db41],r14        # 251008 <stderr_stream>
  2134c7:	4c 89 e1             	mov    rcx,r12
  2134ca:	4c 89 f7             	mov    rdi,r14
  2134cd:	c6 44 24 18 20       	mov    BYTE PTR [rsp+0x18],0x20
    return output(context, (*[1]u8)(&c)[0..]);
  2134d2:	4c 89 6c 24 60       	mov    QWORD PTR [rsp+0x60],r13
  2134d7:	48 c7 44 24 68 01 00 	mov    QWORD PTR [rsp+0x68],0x1
  2134de:	00 00 
  2134e0:	4c 89 fe             	mov    rsi,r15
  2134e3:	c5 f8 77             	vzeroupper 
  2134e6:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  2134e8:	31 c0                	xor    eax,eax
  2134ea:	86 05 20 db 03 00    	xchg   BYTE PTR [rip+0x3db20],al        # 251010 <stderr_mutex>
  2134f0:	3c 01                	cmp    al,0x1
    if (!ok) {
  2134f2:	0f 85 ba 04 00 00    	jne    2139b2 <Benchmark_report+0xa92>
  2134f8:	48 83 c3 01          	add    rbx,0x1
  2134fc:	48 39 eb             	cmp    rbx,rbp
  2134ff:	0f 82 7b ff ff ff    	jb     213480 <Benchmark_report+0x560>
  213505:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21350c:	00 00 00 00 
  213510:	b0 01                	mov    al,0x1
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  213512:	86 05 f8 da 03 00    	xchg   BYTE PTR [rip+0x3daf8],al        # 251010 <stderr_mutex>
  213518:	84 c0                	test   al,al
  21351a:	75 f4                	jne    213510 <Benchmark_report+0x5f0>
    if (stderr_stream) |st| {
  21351c:	48 8b 3d e5 da 03 00 	mov    rdi,QWORD PTR [rip+0x3dae5]        # 251008 <stderr_stream>
  213523:	48 85 ff             	test   rdi,rdi
  213526:	0f 84 91 00 00 00    	je     2135bd <Benchmark_report+0x69d>
  21352c:	48 8b 0d 0d 8b 03 00 	mov    rcx,QWORD PTR [rip+0x38b0d]        # 24c040 <stderr_file_out_stream+0x8>
  213533:	e9 b9 00 00 00       	jmp    2135f1 <Benchmark_report+0x6d1>
    if (x == 0.0) {
  213538:	c5 f0 57 c9          	vxorps xmm1,xmm1,xmm1
  21353c:	c5 f9 2e c1          	vucomisd xmm0,xmm1
  213540:	75 1a                	jne    21355c <Benchmark_report+0x63c>
  213542:	7a 18                	jp     21355c <Benchmark_report+0x63c>
  213544:	c7 45 00 30 2e 30 30 	mov    DWORD PTR [rbp+0x0],0x30302e30
  21354b:	c6 45 04 30          	mov    BYTE PTR [rbp+0x4],0x30
    context.remaining = context.remaining[bytes.len..];
  21354f:	48 83 c5 05          	add    rbp,0x5
  213553:	49 83 c6 fb          	add    r14,0xfffffffffffffffb
  213557:	e9 aa fe ff ff       	jmp    213406 <Benchmark_report+0x4e6>
    var buffer: [32]u8 = undefined;
  21355c:	c5 fc 10 0d 9c cc fe 	vmovups ymm1,YMMWORD PTR [rip+0xfffffffffffecc9c]        # 200200 <__unnamed_29>
  213563:	ff 
  213564:	c5 fc 11 4c 24 60    	vmovups YMMWORD PTR [rsp+0x60],ymm1
    var float_decimal = errol.errol3(x, buffer[0..]);
  21356a:	48 89 9c 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],rbx
  213571:	00 
  213572:	48 c7 84 24 b0 00 00 	mov    QWORD PTR [rsp+0xb0],0x20
  213579:	00 20 00 00 00 
  21357e:	48 8d 7c 24 18       	lea    rdi,[rsp+0x18]
  213583:	48 8d b4 24 a8 00 00 	lea    rsi,[rsp+0xa8]
  21358a:	00 
  21358b:	c5 f8 77             	vzeroupper 
  21358e:	e8 1d 98 01 00       	call   22cdb0 <errol3>
  213593:	4c 8b 6c 24 18       	mov    r13,QWORD PTR [rsp+0x18]
  213598:	4c 8b 4c 24 20       	mov    r9,QWORD PTR [rsp+0x20]
  21359d:	4c 63 44 24 28       	movsxd r8,DWORD PTR [rsp+0x28]
  2135a2:	4d 85 c0             	test   r8,r8
    // whether we need to round to match the specified precision.
    var round_digit: usize = 0;

    switch (mode) {
        RoundMode.Decimal => {
            if (float_decimal.exp >= 0) {
  2135a5:	0f 88 92 02 00 00    	js     21383d <Benchmark_report+0x91d>
                round_digit = precision + @intCast(usize, float_decimal.exp);
  2135ab:	49 8d 50 03          	lea    rdx,[r8+0x3]

    // It suffices to look at just this digit. We don't round and propagate say 0.04999 to 0.05
    // first, and then to 0.1 in the case of a {.1} single precision.

    // Find the digit which will signify the round point and start rounding backwards.
    if (round_digit < float_decimal.digits.len and float_decimal.digits[round_digit] - '0' >= 5) {
  2135af:	4c 39 ca             	cmp    rdx,r9
  2135b2:	0f 82 0e 03 00 00    	jb     2138c6 <Benchmark_report+0x9a6>
  2135b8:	e9 12 04 00 00       	jmp    2139cf <Benchmark_report+0xaaf>
        stderr_file = try io.getStdErr();
  2135bd:	48 8d 05 6c 8a 03 00 	lea    rax,[rip+0x38a6c]        # 24c030 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  2135c4:	48 89 05 6d 8a 03 00 	mov    QWORD PTR [rip+0x38a6d],rax        # 24c038 <stderr_file_out_stream>
  2135cb:	48 8d 0d ce b8 00 00 	lea    rcx,[rip+0xb8ce]        # 21eea0 <FileOutStream_writeFn>
  2135d2:	48 89 0d 67 8a 03 00 	mov    QWORD PTR [rip+0x38a67],rcx        # 24c040 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  2135d9:	c7 05 4d 8a 03 00 02 	mov    DWORD PTR [rip+0x38a4d],0x2        # 24c030 <stderr_file>
  2135e0:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  2135e3:	48 8d 3d 56 8a 03 00 	lea    rdi,[rip+0x38a56]        # 24c040 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  2135ea:	48 89 3d 17 da 03 00 	mov    QWORD PTR [rip+0x3da17],rdi        # 251008 <stderr_stream>
  2135f1:	48 8b 2d 77 29 ff ff 	mov    rbp,QWORD PTR [rip+0xffffffffffff2977]        # 205f6f <__unnamed_7+0x20>
  2135f8:	48 8b 5c 24 08       	mov    rbx,QWORD PTR [rsp+0x8]
  2135fd:	49 bf 00 00 00 00 00 	movabs r15,0x7ff0000000000000
  213604:	00 f0 7f 
  213607:	4c 8d 74 24 30       	lea    r14,[rsp+0x30]
                const casted_value = ([]const u8)(value);
  21360c:	4c 89 74 24 60       	mov    QWORD PTR [rsp+0x60],r14
  213611:	48 8b 44 24 10       	mov    rax,QWORD PTR [rsp+0x10]
  213616:	48 89 44 24 68       	mov    QWORD PTR [rsp+0x68],rax
  21361b:	4c 8d 6c 24 60       	lea    r13,[rsp+0x60]
                return output(context, casted_value);
  213620:	4c 89 ee             	mov    rsi,r13
  213623:	c5 f8 77             	vzeroupper 
  213626:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  213628:	31 c0                	xor    eax,eax
  21362a:	86 05 e0 d9 03 00    	xchg   BYTE PTR [rip+0x3d9e0],al        # 251010 <stderr_mutex>
  213630:	3c 01                	cmp    al,0x1
    if (!ok) {
  213632:	0f 85 7a 03 00 00    	jne    2139b2 <Benchmark_report+0xa92>
                @intToFloat(f64, result.run_time_ns)/@intToFloat(f64, result.iterations));
  213638:	c5 fb 10 03          	vmovsd xmm0,QWORD PTR [rbx]
  21363c:	c5 f9 28 0d dc cb fe 	vmovapd xmm1,XMMWORD PTR [rip+0xfffffffffffecbdc]        # 200220 <__unnamed_29+0x20>
  213643:	ff 
  213644:	c5 f8 14 c1          	vunpcklps xmm0,xmm0,xmm1
  213648:	c5 f9 28 15 e0 d0 fe 	vmovapd xmm2,XMMWORD PTR [rip+0xfffffffffffed0e0]        # 200730 <__unnamed_55+0x10>
  21364f:	ff 
  213650:	c5 f9 5c c2          	vsubpd xmm0,xmm0,xmm2
  213654:	c5 f9 7c c0          	vhaddpd xmm0,xmm0,xmm0
  213658:	c5 fb 10 5b 08       	vmovsd xmm3,QWORD PTR [rbx+0x8]
  21365d:	c5 e0 14 c9          	vunpcklps xmm1,xmm3,xmm1
  213661:	c5 f1 5c ca          	vsubpd xmm1,xmm1,xmm2
  213665:	c5 f1 7c c9          	vhaddpd xmm1,xmm1,xmm1
  213669:	c5 fb 5e c1          	vdivsd xmm0,xmm0,xmm1
        var buffer: [40]u8 = undefined;
  21366d:	48 89 6c 24 50       	mov    QWORD PTR [rsp+0x50],rbp
  213672:	c5 fc 10 0d d5 28 ff 	vmovups ymm1,YMMWORD PTR [rip+0xffffffffffff28d5]        # 205f4f <__unnamed_7>
  213679:	ff 
  21367a:	c5 fc 11 4c 24 30    	vmovups YMMWORD PTR [rsp+0x30],ymm1
    const bits = @bitCast(u64, x);
  213680:	c4 e1 f9 7e c0       	vmovq  rax,xmm0
    return bits >> 63 != 0;
  213685:	48 85 c0             	test   rax,rax
    if (math.signbit(x)) {
  213688:	78 07                	js     213691 <Benchmark_report+0x771>
  21368a:	bd 28 00 00 00       	mov    ebp,0x28
  21368f:	eb 17                	jmp    2136a8 <Benchmark_report+0x788>
  213691:	c6 44 24 30 2d       	mov    BYTE PTR [rsp+0x30],0x2d
    context.remaining = context.remaining[bytes.len..];
  213696:	4c 8d 74 24 31       	lea    r14,[rsp+0x31]
        x = -x;
  21369b:	c5 f9 57 05 ad d0 fe 	vxorpd xmm0,xmm0,XMMWORD PTR [rip+0xfffffffffffed0ad]        # 200750 <__unnamed_563+0x10>
  2136a2:	ff 
  2136a3:	bd 27 00 00 00       	mov    ebp,0x27
            const bits = @bitCast(u64, x);
  2136a8:	c4 e1 f9 7e c0       	vmovq  rax,xmm0
  2136ad:	48 b9 ff ff ff ff ff 	movabs rcx,0x7fffffffffffffff
  2136b4:	ff ff 7f 
            return (bits & (@maxValue(u64) >> 1)) > (u64(0x7FF) << 52);
  2136b7:	48 21 c1             	and    rcx,rax
  2136ba:	4c 39 f9             	cmp    rcx,r15
    if (math.isNan(x)) {
  2136bd:	76 0d                	jbe    2136cc <Benchmark_report+0x7ac>
  2136bf:	66 41 c7 06 6e 61    	mov    WORD PTR [r14],0x616e
  2136c5:	41 c6 46 02 6e       	mov    BYTE PTR [r14+0x2],0x6e
  2136ca:	eb 14                	jmp    2136e0 <Benchmark_report+0x7c0>
  2136cc:	4c 39 f8             	cmp    rax,r15
    if (math.isPositiveInf(x)) {
  2136cf:	0f 85 43 01 00 00    	jne    213818 <Benchmark_report+0x8f8>
  2136d5:	66 41 c7 06 69 6e    	mov    WORD PTR [r14],0x6e69
  2136db:	41 c6 46 02 66       	mov    BYTE PTR [r14+0x2],0x66
    context.remaining = context.remaining[bytes.len..];
  2136e0:	49 83 c6 03          	add    r14,0x3
  2136e4:	48 83 c5 fd          	add    rbp,0xfffffffffffffffd
  2136e8:	31 c0                	xor    eax,eax
  2136ea:	48 89 ef             	mov    rdi,rbp
                    try formatType(args[next_arg], fmt[s..i], context, Errors, output);
  2136ed:	66 85 c0             	test   ax,ax
  2136f0:	0f 85 9c fa ff ff    	jne    213192 <Benchmark_report+0x272>
  2136f6:	66 b8 05 00          	mov    ax,0x5
    if (context.remaining.len < bytes.len) return error.BufferTooSmall;
  2136fa:	48 83 ff 06          	cmp    rdi,0x6
  2136fe:	0f 82 8e fa ff ff    	jb     213192 <Benchmark_report+0x272>
  213704:	41 c7 06 20 6e 73 2f 	mov    DWORD PTR [r14],0x2f736e20
  21370b:	66 41 c7 46 04 6f 70 	mov    WORD PTR [r14+0x4],0x706f
    return buf[0 .. buf.len - context.remaining.len];
  213712:	b8 2e 00 00 00       	mov    eax,0x2e
  213717:	48 29 f8             	sub    rax,rdi
  21371a:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
        if (width > str.len) {
  21371f:	48 83 f8 12          	cmp    rax,0x12
  213723:	0f 83 c7 00 00 00    	jae    2137f0 <Benchmark_report+0x8d0>
  213729:	b8 06 00 00 00       	mov    eax,0x6
  21372e:	48 29 f8             	sub    rax,rdi
            pad(width - str.len, ' ');
  213731:	48 c7 c5 ea ff ff ff 	mov    rbp,0xffffffffffffffea
        while (i < count) : (i += 1) {
  213738:	48 29 c5             	sub    rbp,rax
  21373b:	0f 84 af 00 00 00    	je     2137f0 <Benchmark_report+0x8d0>
  213741:	31 db                	xor    ebx,ebx
  213743:	4c 8d 2d 56 b7 00 00 	lea    r13,[rip+0xb756]        # 21eea0 <FileOutStream_writeFn>
  21374a:	4c 8d 25 ef 88 03 00 	lea    r12,[rip+0x388ef]        # 24c040 <stderr_file_out_stream+0x8>
  213751:	4c 8d 74 24 18       	lea    r14,[rsp+0x18]
  213756:	4c 8d 7c 24 60       	lea    r15,[rsp+0x60]
  21375b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  213760:	b0 01                	mov    al,0x1
  213762:	86 05 a8 d8 03 00    	xchg   BYTE PTR [rip+0x3d8a8],al        # 251010 <stderr_mutex>
  213768:	84 c0                	test   al,al
  21376a:	75 f4                	jne    213760 <Benchmark_report+0x840>
    if (stderr_stream) |st| {
  21376c:	48 8b 3d 95 d8 03 00 	mov    rdi,QWORD PTR [rip+0x3d895]        # 251008 <stderr_stream>
  213773:	48 85 ff             	test   rdi,rdi
  213776:	74 09                	je     213781 <Benchmark_report+0x861>
  213778:	48 8b 0d c1 88 03 00 	mov    rcx,QWORD PTR [rip+0x388c1]        # 24c040 <stderr_file_out_stream+0x8>
  21377f:	eb 2c                	jmp    2137ad <Benchmark_report+0x88d>
        stderr_file = try io.getStdErr();
  213781:	c7 05 a5 88 03 00 02 	mov    DWORD PTR [rip+0x388a5],0x2        # 24c030 <stderr_file>
  213788:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  21378b:	48 8d 05 9e 88 03 00 	lea    rax,[rip+0x3889e]        # 24c030 <stderr_file>
  213792:	48 89 05 9f 88 03 00 	mov    QWORD PTR [rip+0x3889f],rax        # 24c038 <stderr_file_out_stream>
  213799:	4c 89 2d a0 88 03 00 	mov    QWORD PTR [rip+0x388a0],r13        # 24c040 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  2137a0:	4c 89 25 61 d8 03 00 	mov    QWORD PTR [rip+0x3d861],r12        # 251008 <stderr_stream>
  2137a7:	4c 89 e9             	mov    rcx,r13
  2137aa:	4c 89 e7             	mov    rdi,r12
  2137ad:	c6 44 24 18 20       	mov    BYTE PTR [rsp+0x18],0x20
    return output(context, (*[1]u8)(&c)[0..]);
  2137b2:	4c 89 74 24 60       	mov    QWORD PTR [rsp+0x60],r14
  2137b7:	48 c7 44 24 68 01 00 	mov    QWORD PTR [rsp+0x68],0x1
  2137be:	00 00 
  2137c0:	4c 89 fe             	mov    rsi,r15
  2137c3:	c5 f8 77             	vzeroupper 
  2137c6:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  2137c8:	31 c0                	xor    eax,eax
  2137ca:	86 05 40 d8 03 00    	xchg   BYTE PTR [rip+0x3d840],al        # 251010 <stderr_mutex>
  2137d0:	3c 01                	cmp    al,0x1
    if (!ok) {
  2137d2:	0f 85 da 01 00 00    	jne    2139b2 <Benchmark_report+0xa92>
  2137d8:	48 83 c3 01          	add    rbx,0x1
  2137dc:	48 39 eb             	cmp    rbx,rbp
  2137df:	0f 82 7b ff ff ff    	jb     213760 <Benchmark_report+0x840>
  2137e5:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  2137ec:	00 00 00 00 
  2137f0:	b0 01                	mov    al,0x1
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  2137f2:	86 05 18 d8 03 00    	xchg   BYTE PTR [rip+0x3d818],al        # 251010 <stderr_mutex>
  2137f8:	84 c0                	test   al,al
  2137fa:	75 f4                	jne    2137f0 <Benchmark_report+0x8d0>
    if (stderr_stream) |st| {
  2137fc:	48 8b 3d 05 d8 03 00 	mov    rdi,QWORD PTR [rip+0x3d805]        # 251008 <stderr_stream>
  213803:	48 85 ff             	test   rdi,rdi
  213806:	0f 84 41 01 00 00    	je     21394d <Benchmark_report+0xa2d>
  21380c:	48 8b 0d 2d 88 03 00 	mov    rcx,QWORD PTR [rip+0x3882d]        # 24c040 <stderr_file_out_stream+0x8>
  213813:	e9 69 01 00 00       	jmp    213981 <Benchmark_report+0xa61>
    if (x == 0.0) {
  213818:	c5 f0 57 c9          	vxorps xmm1,xmm1,xmm1
  21381c:	c5 f9 2e c1          	vucomisd xmm0,xmm1
  213820:	75 38                	jne    21385a <Benchmark_report+0x93a>
  213822:	7a 36                	jp     21385a <Benchmark_report+0x93a>
  213824:	41 c7 06 30 2e 30 30 	mov    DWORD PTR [r14],0x30302e30
  21382b:	41 c6 46 04 30       	mov    BYTE PTR [r14+0x4],0x30
    context.remaining = context.remaining[bytes.len..];
  213830:	49 83 c6 05          	add    r14,0x5
  213834:	48 83 c5 fb          	add    rbp,0xfffffffffffffffb
  213838:	e9 ab fe ff ff       	jmp    2136e8 <Benchmark_report+0x7c8>
                const min_exp_required = @intCast(usize, -float_decimal.exp);
  21383d:	4c 89 c0             	mov    rax,r8
  213840:	48 f7 d8             	neg    rax
                if (precision > min_exp_required) {
  213843:	83 f8 02             	cmp    eax,0x2
  213846:	77 73                	ja     2138bb <Benchmark_report+0x99b>
                    round_digit = precision - min_exp_required;
  213848:	ba 03 00 00 00       	mov    edx,0x3
  21384d:	48 29 c2             	sub    rdx,rax
    if (round_digit < float_decimal.digits.len and float_decimal.digits[round_digit] - '0' >= 5) {
  213850:	4c 39 ca             	cmp    rdx,r9
  213853:	72 71                	jb     2138c6 <Benchmark_report+0x9a6>
  213855:	e9 75 01 00 00       	jmp    2139cf <Benchmark_report+0xaaf>
    var buffer: [32]u8 = undefined;
  21385a:	c5 fc 10 0d 9e c9 fe 	vmovups ymm1,YMMWORD PTR [rip+0xfffffffffffec99e]        # 200200 <__unnamed_29>
  213861:	ff 
  213862:	c5 fc 11 4c 24 60    	vmovups YMMWORD PTR [rsp+0x60],ymm1
    var float_decimal = errol.errol3(x, buffer[0..]);
  213868:	4c 89 ac 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],r13
  21386f:	00 
  213870:	48 c7 84 24 b0 00 00 	mov    QWORD PTR [rsp+0xb0],0x20
  213877:	00 20 00 00 00 
  21387c:	48 8d 7c 24 18       	lea    rdi,[rsp+0x18]
  213881:	48 8d b4 24 a8 00 00 	lea    rsi,[rsp+0xa8]
  213888:	00 
  213889:	c5 f8 77             	vzeroupper 
  21388c:	e8 1f 95 01 00       	call   22cdb0 <errol3>
  213891:	4c 8b 6c 24 18       	mov    r13,QWORD PTR [rsp+0x18]
  213896:	4c 8b 44 24 20       	mov    r8,QWORD PTR [rsp+0x20]
  21389b:	4c 63 4c 24 28       	movsxd r9,DWORD PTR [rsp+0x28]
  2138a0:	4d 85 c9             	test   r9,r9
            if (float_decimal.exp >= 0) {
  2138a3:	0f 88 9a 02 00 00    	js     213b43 <Benchmark_report+0xc23>
                round_digit = precision + @intCast(usize, float_decimal.exp);
  2138a9:	49 8d 51 03          	lea    rdx,[r9+0x3]
    if (round_digit < float_decimal.digits.len and float_decimal.digits[round_digit] - '0' >= 5) {
  2138ad:	4c 39 c2             	cmp    rdx,r8
  2138b0:	0f 82 e9 02 00 00    	jb     213b9f <Benchmark_report+0xc7f>
  2138b6:	e9 98 08 00 00       	jmp    214153 <Benchmark_report+0x1233>
  2138bb:	31 d2                	xor    edx,edx
  2138bd:	4c 39 ca             	cmp    rdx,r9
  2138c0:	0f 83 09 01 00 00    	jae    2139cf <Benchmark_report+0xaaf>
  2138c6:	41 8a 44 15 00       	mov    al,BYTE PTR [r13+rdx*1+0x0]
  2138cb:	04 d0                	add    al,0xd0
  2138cd:	3c 05                	cmp    al,0x5
  2138cf:	0f 82 fa 00 00 00    	jb     2139cf <Benchmark_report+0xaaf>
        assert(round_digit >= 0);

        var i = round_digit;
        while (true) {
            if (i == 0) {
  2138d5:	48 85 d2             	test   rdx,rdx
  2138d8:	0f 84 e0 00 00 00    	je     2139be <Benchmark_report+0xa9e>
                return;
            }

            i -= 1;

            const new_value = (float_decimal.digits[i] - '0' + 1) % 10;
  2138de:	41 8a 44 15 ff       	mov    al,BYTE PTR [r13+rdx*1-0x1]
  2138e3:	04 d1                	add    al,0xd1
  2138e5:	0f b6 f8             	movzx  edi,al
  2138e8:	69 c7 cd 00 00 00    	imul   eax,edi,0xcd
  2138ee:	be 0b 05 00 00       	mov    esi,0x50b
  2138f3:	c4 e2 48 f7 c0       	bextr  eax,eax,esi
  2138f8:	b3 0a                	mov    bl,0xa
  2138fa:	f6 e3                	mul    bl
  2138fc:	40 28 c7             	sub    dil,al
            float_decimal.digits[i] = new_value + '0';
  2138ff:	89 f8                	mov    eax,edi
  213901:	0c 30                	or     al,0x30
  213903:	41 88 44 15 ff       	mov    BYTE PTR [r13+rdx*1-0x1],al

            // must continue rounding until non-9
            if (new_value != 0) {
  213908:	40 84 ff             	test   dil,dil
  21390b:	0f 85 be 00 00 00    	jne    2139cf <Benchmark_report+0xaaf>
            if (i == 0) {
  213911:	48 83 fa 01          	cmp    rdx,0x1
  213915:	0f 84 a3 00 00 00    	je     2139be <Benchmark_report+0xa9e>
            const new_value = (float_decimal.digits[i] - '0' + 1) % 10;
  21391b:	41 0f b6 44 15 fe    	movzx  eax,BYTE PTR [r13+rdx*1-0x2]
  213921:	04 d1                	add    al,0xd1
  213923:	0f b6 f8             	movzx  edi,al
  213926:	69 c7 cd 00 00 00    	imul   eax,edi,0xcd
  21392c:	c4 e2 48 f7 c0       	bextr  eax,eax,esi
  213931:	f6 e3                	mul    bl
  213933:	40 28 c7             	sub    dil,al
            float_decimal.digits[i] = new_value + '0';
  213936:	89 f8                	mov    eax,edi
  213938:	0c 30                	or     al,0x30
  21393a:	41 88 44 15 fe       	mov    BYTE PTR [r13+rdx*1-0x2],al
            if (new_value != 0) {
  21393f:	48 83 c2 ff          	add    rdx,0xffffffffffffffff
  213943:	40 84 ff             	test   dil,dil
  213946:	74 c9                	je     213911 <Benchmark_report+0x9f1>
  213948:	e9 82 00 00 00       	jmp    2139cf <Benchmark_report+0xaaf>
        stderr_file = try io.getStdErr();
  21394d:	48 8d 05 dc 86 03 00 	lea    rax,[rip+0x386dc]        # 24c030 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  213954:	48 89 05 dd 86 03 00 	mov    QWORD PTR [rip+0x386dd],rax        # 24c038 <stderr_file_out_stream>
  21395b:	48 8d 0d 3e b5 00 00 	lea    rcx,[rip+0xb53e]        # 21eea0 <FileOutStream_writeFn>
  213962:	48 89 0d d7 86 03 00 	mov    QWORD PTR [rip+0x386d7],rcx        # 24c040 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  213969:	c7 05 bd 86 03 00 02 	mov    DWORD PTR [rip+0x386bd],0x2        # 24c030 <stderr_file>
  213970:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  213973:	48 8d 3d c6 86 03 00 	lea    rdi,[rip+0x386c6]        # 24c040 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  21397a:	48 89 3d 87 d6 03 00 	mov    QWORD PTR [rip+0x3d687],rdi        # 251008 <stderr_stream>
  213981:	48 8b 54 24 08       	mov    rdx,QWORD PTR [rsp+0x8]
  213986:	48 8d 44 24 30       	lea    rax,[rsp+0x30]
                const casted_value = ([]const u8)(value);
  21398b:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  213990:	48 89 54 24 68       	mov    QWORD PTR [rsp+0x68],rdx
  213995:	48 8d 74 24 60       	lea    rsi,[rsp+0x60]
                return output(context, casted_value);
  21399a:	c5 f8 77             	vzeroupper 
  21399d:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  21399f:	31 c9                	xor    ecx,ecx
  2139a1:	86 0d 69 d6 03 00    	xchg   BYTE PTR [rip+0x3d669],cl        # 251010 <stderr_mutex>
  2139a7:	31 c0                	xor    eax,eax
  2139a9:	80 f9 01             	cmp    cl,0x1
    if (!ok) {
  2139ac:	0f 84 e0 f7 ff ff    	je     213192 <Benchmark_report+0x272>
            @panic("assertion failure");
  2139b2:	48 8d 3d d7 c3 03 00 	lea    rdi,[rip+0x3c3d7]        # 24fd90 <__unnamed_2>
  2139b9:	e8 62 ed ff ff       	call   212720 <panic>
                float_decimal.exp += 1;
  2139be:	41 83 c0 01          	add    r8d,0x1
                float_decimal.digits = one_before[0 .. float_decimal.digits.len + 1];
  2139c2:	49 83 c1 01          	add    r9,0x1
                float_decimal.digits[0] = '1';
  2139c6:	41 c6 45 ff 31       	mov    BYTE PTR [r13-0x1],0x31
                const one_before = @intToPtr([*]u8, @ptrToInt(&float_decimal.digits[0]) - 1);
  2139cb:	49 83 c5 ff          	add    r13,0xffffffffffffffff
        var num_digits_whole = if (float_decimal.exp > 0) @intCast(usize, float_decimal.exp) else 0;
  2139cf:	45 31 db             	xor    r11d,r11d
  2139d2:	45 85 c0             	test   r8d,r8d
  2139d5:	44 89 c0             	mov    eax,r8d
  2139d8:	4c 0f 4f d8          	cmovg  r11,rax
    return if (x < y) x else y;
  2139dc:	4d 39 cb             	cmp    r11,r9
  2139df:	4d 89 cc             	mov    r12,r9
  2139e2:	4d 0f 42 e3          	cmovb  r12,r11
  2139e6:	45 85 c0             	test   r8d,r8d
        if (num_digits_whole > 0) {
  2139e9:	0f 8e 15 01 00 00    	jle    213b04 <Benchmark_report+0xbe4>
  2139ef:	66 b8 05 00          	mov    ax,0x5
    if (context.remaining.len < bytes.len) return error.BufferTooSmall;
  2139f3:	4d 39 e6             	cmp    r14,r12
  2139f6:	0f 82 0c fa ff ff    	jb     213408 <Benchmark_report+0x4e8>
    for (source) |s, i|
  2139fc:	4d 85 e4             	test   r12,r12
  2139ff:	0f 84 28 01 00 00    	je     213b2d <Benchmark_report+0xc0d>
  213a05:	49 81 fc 80 00 00 00 	cmp    r12,0x80
  213a0c:	72 1a                	jb     213a28 <Benchmark_report+0xb08>
  213a0e:	4b 8d 14 2c          	lea    rdx,[r12+r13*1]
  213a12:	48 39 d5             	cmp    rbp,rdx
  213a15:	0f 83 45 01 00 00    	jae    213b60 <Benchmark_report+0xc40>
  213a1b:	49 8d 14 2c          	lea    rdx,[r12+rbp*1]
  213a1f:	4c 39 ea             	cmp    rdx,r13
  213a22:	0f 86 38 01 00 00    	jbe    213b60 <Benchmark_report+0xc40>
  213a28:	31 ff                	xor    edi,edi
  213a2a:	4d 39 d9             	cmp    r9,r11
  213a2d:	4c 89 ce             	mov    rsi,r9
  213a30:	49 0f 47 f3          	cmova  rsi,r11
  213a34:	48 89 f3             	mov    rbx,rsi
  213a37:	48 f7 d3             	not    rbx
  213a3a:	48 c7 c2 fe ff ff ff 	mov    rdx,0xfffffffffffffffe
  213a41:	48 29 fa             	sub    rdx,rdi
  213a44:	48 29 da             	sub    rdx,rbx
  213a47:	48 83 e6 07          	and    rsi,0x7
  213a4b:	74 17                	je     213a64 <Benchmark_report+0xb44>
  213a4d:	48 f7 de             	neg    rsi
  213a50:	41 0f b6 5c 3d 00    	movzx  ebx,BYTE PTR [r13+rdi*1+0x0]
        dest[i] = s;
  213a56:	88 5c 3d 00          	mov    BYTE PTR [rbp+rdi*1+0x0],bl
    for (source) |s, i|
  213a5a:	48 83 c7 01          	add    rdi,0x1
  213a5e:	48 83 c6 01          	add    rsi,0x1
  213a62:	75 ec                	jne    213a50 <Benchmark_report+0xb30>
    context.remaining = context.remaining[bytes.len..];
  213a64:	4c 89 e6             	mov    rsi,r12
  213a67:	48 83 fa 07          	cmp    rdx,0x7
  213a6b:	0f 82 3d 03 00 00    	jb     213dae <Benchmark_report+0xe8e>
  213a71:	48 89 fa             	mov    rdx,rdi
  213a74:	48 f7 d2             	not    rdx
  213a77:	4c 89 de             	mov    rsi,r11
  213a7a:	48 f7 d6             	not    rsi
  213a7d:	4c 89 cb             	mov    rbx,r9
  213a80:	48 f7 d3             	not    rbx
  213a83:	48 39 de             	cmp    rsi,rbx
  213a86:	48 0f 47 de          	cmova  rbx,rsi
  213a8a:	48 29 da             	sub    rdx,rbx
  213a8d:	48 8d 34 2f          	lea    rsi,[rdi+rbp*1]
  213a91:	48 83 c6 07          	add    rsi,0x7
  213a95:	4c 01 ef             	add    rdi,r13
  213a98:	48 83 c7 07          	add    rdi,0x7
  213a9c:	31 db                	xor    ebx,ebx
  213a9e:	0f b6 4c 1f f9       	movzx  ecx,BYTE PTR [rdi+rbx*1-0x7]
        dest[i] = s;
  213aa3:	88 4c 1e f9          	mov    BYTE PTR [rsi+rbx*1-0x7],cl
    for (source) |s, i|
  213aa7:	0f b6 4c 1f fa       	movzx  ecx,BYTE PTR [rdi+rbx*1-0x6]
        dest[i] = s;
  213aac:	88 4c 1e fa          	mov    BYTE PTR [rsi+rbx*1-0x6],cl
    for (source) |s, i|
  213ab0:	0f b6 4c 1f fb       	movzx  ecx,BYTE PTR [rdi+rbx*1-0x5]
        dest[i] = s;
  213ab5:	88 4c 1e fb          	mov    BYTE PTR [rsi+rbx*1-0x5],cl
    for (source) |s, i|
  213ab9:	0f b6 4c 1f fc       	movzx  ecx,BYTE PTR [rdi+rbx*1-0x4]
        dest[i] = s;
  213abe:	88 4c 1e fc          	mov    BYTE PTR [rsi+rbx*1-0x4],cl
    for (source) |s, i|
  213ac2:	0f b6 4c 1f fd       	movzx  ecx,BYTE PTR [rdi+rbx*1-0x3]
        dest[i] = s;
  213ac7:	88 4c 1e fd          	mov    BYTE PTR [rsi+rbx*1-0x3],cl
    for (source) |s, i|
  213acb:	0f b6 4c 1f fe       	movzx  ecx,BYTE PTR [rdi+rbx*1-0x2]
        dest[i] = s;
  213ad0:	88 4c 1e fe          	mov    BYTE PTR [rsi+rbx*1-0x2],cl
    for (source) |s, i|
  213ad4:	0f b6 4c 1f ff       	movzx  ecx,BYTE PTR [rdi+rbx*1-0x1]
        dest[i] = s;
  213ad9:	88 4c 1e ff          	mov    BYTE PTR [rsi+rbx*1-0x1],cl
    for (source) |s, i|
  213add:	0f b6 0c 1f          	movzx  ecx,BYTE PTR [rdi+rbx*1]
        dest[i] = s;
  213ae1:	88 0c 1e             	mov    BYTE PTR [rsi+rbx*1],cl
    for (source) |s, i|
  213ae4:	48 83 c3 08          	add    rbx,0x8
  213ae8:	48 39 da             	cmp    rdx,rbx
  213aeb:	75 b1                	jne    213a9e <Benchmark_report+0xb7e>
  213aed:	4c 89 e6             	mov    rsi,r12
  213af0:	48 01 f5             	add    rbp,rsi
  213af3:	49 29 f6             	sub    r14,rsi
            while (i < num_digits_whole) : (i += 1) {
  213af6:	4d 39 cb             	cmp    r11,r9
  213af9:	0f 86 dd 02 00 00    	jbe    213ddc <Benchmark_report+0xebc>
  213aff:	e9 b5 02 00 00       	jmp    213db9 <Benchmark_report+0xe99>
        dest[i] = s;
  213b04:	c6 45 00 30          	mov    BYTE PTR [rbp+0x0],0x30
    context.remaining = context.remaining[bytes.len..];
  213b08:	48 83 c5 01          	add    rbp,0x1
  213b0c:	49 83 c6 ff          	add    r14,0xffffffffffffffff
  213b10:	66 b8 05 00          	mov    ax,0x5
    if (context.remaining.len < bytes.len) return error.BufferTooSmall;
  213b14:	4d 85 f6             	test   r14,r14
  213b17:	0f 85 cc 02 00 00    	jne    213de9 <Benchmark_report+0xec9>
  213b1d:	31 ff                	xor    edi,edi
                    try formatType(args[next_arg], fmt[s..i], context, Errors, output);
  213b1f:	66 85 c0             	test   ax,ax
  213b22:	0f 85 6a f6 ff ff    	jne    213192 <Benchmark_report+0x272>
  213b28:	e9 e7 f8 ff ff       	jmp    213414 <Benchmark_report+0x4f4>
  213b2d:	31 f6                	xor    esi,esi
    context.remaining = context.remaining[bytes.len..];
  213b2f:	48 01 f5             	add    rbp,rsi
  213b32:	49 29 f6             	sub    r14,rsi
            while (i < num_digits_whole) : (i += 1) {
  213b35:	4d 39 cb             	cmp    r11,r9
  213b38:	0f 87 7b 02 00 00    	ja     213db9 <Benchmark_report+0xe99>
  213b3e:	e9 99 02 00 00       	jmp    213ddc <Benchmark_report+0xebc>
                const min_exp_required = @intCast(usize, -float_decimal.exp);
  213b43:	4c 89 c8             	mov    rax,r9
  213b46:	48 f7 d8             	neg    rax
                if (precision > min_exp_required) {
  213b49:	83 f8 02             	cmp    eax,0x2
  213b4c:	77 46                	ja     213b94 <Benchmark_report+0xc74>
                    round_digit = precision - min_exp_required;
  213b4e:	ba 03 00 00 00       	mov    edx,0x3
  213b53:	48 29 c2             	sub    rdx,rax
    if (round_digit < float_decimal.digits.len and float_decimal.digits[round_digit] - '0' >= 5) {
  213b56:	4c 39 c2             	cmp    rdx,r8
  213b59:	72 44                	jb     213b9f <Benchmark_report+0xc7f>
  213b5b:	e9 f3 05 00 00       	jmp    214153 <Benchmark_report+0x1233>
    for (source) |s, i|
  213b60:	44 89 e7             	mov    edi,r12d
  213b63:	83 e7 80             	and    edi,0xffffff80
  213b66:	48 8d 5f 80          	lea    rbx,[rdi-0x80]
  213b6a:	48 89 da             	mov    rdx,rbx
  213b6d:	48 c1 ea 07          	shr    rdx,0x7
  213b71:	8d 72 01             	lea    esi,[rdx+0x1]
  213b74:	83 e6 03             	and    esi,0x3
  213b77:	48 81 fb 80 01 00 00 	cmp    rbx,0x180
  213b7e:	0f 83 a2 00 00 00    	jae    213c26 <Benchmark_report+0xd06>
  213b84:	31 d2                	xor    edx,edx
  213b86:	48 85 f6             	test   rsi,rsi
  213b89:	0f 85 ce 01 00 00    	jne    213d5d <Benchmark_report+0xe3d>
  213b8f:	e9 0e 02 00 00       	jmp    213da2 <Benchmark_report+0xe82>
  213b94:	31 d2                	xor    edx,edx
  213b96:	4c 39 c2             	cmp    rdx,r8
  213b99:	0f 83 b4 05 00 00    	jae    214153 <Benchmark_report+0x1233>
  213b9f:	41 8a 44 15 00       	mov    al,BYTE PTR [r13+rdx*1+0x0]
  213ba4:	04 d0                	add    al,0xd0
  213ba6:	3c 05                	cmp    al,0x5
  213ba8:	0f 82 a5 05 00 00    	jb     214153 <Benchmark_report+0x1233>
            if (i == 0) {
  213bae:	48 85 d2             	test   rdx,rdx
  213bb1:	0f 84 8b 05 00 00    	je     214142 <Benchmark_report+0x1222>
            const new_value = (float_decimal.digits[i] - '0' + 1) % 10;
  213bb7:	41 8a 44 15 ff       	mov    al,BYTE PTR [r13+rdx*1-0x1]
  213bbc:	04 d1                	add    al,0xd1
  213bbe:	0f b6 f8             	movzx  edi,al
  213bc1:	69 c7 cd 00 00 00    	imul   eax,edi,0xcd
  213bc7:	be 0b 05 00 00       	mov    esi,0x50b
  213bcc:	c4 e2 48 f7 c0       	bextr  eax,eax,esi
  213bd1:	b1 0a                	mov    cl,0xa
  213bd3:	f6 e1                	mul    cl
  213bd5:	40 28 c7             	sub    dil,al
            float_decimal.digits[i] = new_value + '0';
  213bd8:	89 f8                	mov    eax,edi
  213bda:	0c 30                	or     al,0x30
  213bdc:	41 88 44 15 ff       	mov    BYTE PTR [r13+rdx*1-0x1],al
            if (new_value != 0) {
  213be1:	40 84 ff             	test   dil,dil
  213be4:	0f 85 69 05 00 00    	jne    214153 <Benchmark_report+0x1233>
            if (i == 0) {
  213bea:	48 83 fa 01          	cmp    rdx,0x1
  213bee:	0f 84 4e 05 00 00    	je     214142 <Benchmark_report+0x1222>
            const new_value = (float_decimal.digits[i] - '0' + 1) % 10;
  213bf4:	41 0f b6 44 15 fe    	movzx  eax,BYTE PTR [r13+rdx*1-0x2]
  213bfa:	04 d1                	add    al,0xd1
  213bfc:	0f b6 f8             	movzx  edi,al
  213bff:	69 c7 cd 00 00 00    	imul   eax,edi,0xcd
  213c05:	c4 e2 48 f7 c0       	bextr  eax,eax,esi
  213c0a:	f6 e1                	mul    cl
  213c0c:	40 28 c7             	sub    dil,al
            float_decimal.digits[i] = new_value + '0';
  213c0f:	89 f8                	mov    eax,edi
  213c11:	0c 30                	or     al,0x30
  213c13:	41 88 44 15 fe       	mov    BYTE PTR [r13+rdx*1-0x2],al
            if (new_value != 0) {
  213c18:	48 83 c2 ff          	add    rdx,0xffffffffffffffff
  213c1c:	40 84 ff             	test   dil,dil
  213c1f:	74 c9                	je     213bea <Benchmark_report+0xcca>
  213c21:	e9 2d 05 00 00       	jmp    214153 <Benchmark_report+0x1233>
  213c26:	48 8d 5e ff          	lea    rbx,[rsi-0x1]
  213c2a:	48 29 d3             	sub    rbx,rdx
  213c2d:	31 d2                	xor    edx,edx
  213c2f:	c4 c1 7c 10 44 15 00 	vmovups ymm0,YMMWORD PTR [r13+rdx*1+0x0]
  213c36:	c4 c1 7c 10 4c 15 20 	vmovups ymm1,YMMWORD PTR [r13+rdx*1+0x20]
  213c3d:	c4 c1 7c 10 54 15 40 	vmovups ymm2,YMMWORD PTR [r13+rdx*1+0x40]
  213c44:	c4 c1 7c 10 5c 15 60 	vmovups ymm3,YMMWORD PTR [r13+rdx*1+0x60]
        dest[i] = s;
  213c4b:	c5 fc 11 44 15 00    	vmovups YMMWORD PTR [rbp+rdx*1+0x0],ymm0
  213c51:	c5 fc 11 4c 15 20    	vmovups YMMWORD PTR [rbp+rdx*1+0x20],ymm1
  213c57:	c5 fc 11 54 15 40    	vmovups YMMWORD PTR [rbp+rdx*1+0x40],ymm2
  213c5d:	c5 fc 11 5c 15 60    	vmovups YMMWORD PTR [rbp+rdx*1+0x60],ymm3
    for (source) |s, i|
  213c63:	c4 c1 7c 10 84 15 80 	vmovups ymm0,YMMWORD PTR [r13+rdx*1+0x80]
  213c6a:	00 00 00 
  213c6d:	c4 c1 7c 10 8c 15 a0 	vmovups ymm1,YMMWORD PTR [r13+rdx*1+0xa0]
  213c74:	00 00 00 
  213c77:	c4 c1 7c 10 94 15 c0 	vmovups ymm2,YMMWORD PTR [r13+rdx*1+0xc0]
  213c7e:	00 00 00 
  213c81:	c4 c1 7c 10 9c 15 e0 	vmovups ymm3,YMMWORD PTR [r13+rdx*1+0xe0]
  213c88:	00 00 00 
        dest[i] = s;
  213c8b:	c5 fc 11 84 15 80 00 	vmovups YMMWORD PTR [rbp+rdx*1+0x80],ymm0
  213c92:	00 00 
  213c94:	c5 fc 11 8c 15 a0 00 	vmovups YMMWORD PTR [rbp+rdx*1+0xa0],ymm1
  213c9b:	00 00 
  213c9d:	c5 fc 11 94 15 c0 00 	vmovups YMMWORD PTR [rbp+rdx*1+0xc0],ymm2
  213ca4:	00 00 
  213ca6:	c5 fc 11 9c 15 e0 00 	vmovups YMMWORD PTR [rbp+rdx*1+0xe0],ymm3
  213cad:	00 00 
    for (source) |s, i|
  213caf:	c4 c1 7c 10 84 15 00 	vmovups ymm0,YMMWORD PTR [r13+rdx*1+0x100]
  213cb6:	01 00 00 
  213cb9:	c4 c1 7c 10 8c 15 20 	vmovups ymm1,YMMWORD PTR [r13+rdx*1+0x120]
  213cc0:	01 00 00 
  213cc3:	c4 c1 7c 10 94 15 40 	vmovups ymm2,YMMWORD PTR [r13+rdx*1+0x140]
  213cca:	01 00 00 
  213ccd:	c4 c1 7c 10 9c 15 60 	vmovups ymm3,YMMWORD PTR [r13+rdx*1+0x160]
  213cd4:	01 00 00 
        dest[i] = s;
  213cd7:	c5 fc 11 84 15 00 01 	vmovups YMMWORD PTR [rbp+rdx*1+0x100],ymm0
  213cde:	00 00 
  213ce0:	c5 fc 11 8c 15 20 01 	vmovups YMMWORD PTR [rbp+rdx*1+0x120],ymm1
  213ce7:	00 00 
  213ce9:	c5 fc 11 94 15 40 01 	vmovups YMMWORD PTR [rbp+rdx*1+0x140],ymm2
  213cf0:	00 00 
  213cf2:	c5 fc 11 9c 15 60 01 	vmovups YMMWORD PTR [rbp+rdx*1+0x160],ymm3
  213cf9:	00 00 
    for (source) |s, i|
  213cfb:	c4 c1 7d 10 84 15 80 	vmovupd ymm0,YMMWORD PTR [r13+rdx*1+0x180]
  213d02:	01 00 00 
  213d05:	c4 c1 7c 10 8c 15 a0 	vmovups ymm1,YMMWORD PTR [r13+rdx*1+0x1a0]
  213d0c:	01 00 00 
  213d0f:	c4 c1 7d 10 94 15 c0 	vmovupd ymm2,YMMWORD PTR [r13+rdx*1+0x1c0]
  213d16:	01 00 00 
  213d19:	c4 c1 7d 10 9c 15 e0 	vmovupd ymm3,YMMWORD PTR [r13+rdx*1+0x1e0]
  213d20:	01 00 00 
        dest[i] = s;
  213d23:	c5 fd 11 84 15 80 01 	vmovupd YMMWORD PTR [rbp+rdx*1+0x180],ymm0
  213d2a:	00 00 
  213d2c:	c5 fc 11 8c 15 a0 01 	vmovups YMMWORD PTR [rbp+rdx*1+0x1a0],ymm1
  213d33:	00 00 
  213d35:	c5 fd 11 94 15 c0 01 	vmovupd YMMWORD PTR [rbp+rdx*1+0x1c0],ymm2
  213d3c:	00 00 
  213d3e:	c5 fd 11 9c 15 e0 01 	vmovupd YMMWORD PTR [rbp+rdx*1+0x1e0],ymm3
  213d45:	00 00 
    for (source) |s, i|
  213d47:	48 81 c2 00 02 00 00 	add    rdx,0x200
  213d4e:	48 83 c3 04          	add    rbx,0x4
  213d52:	0f 85 d7 fe ff ff    	jne    213c2f <Benchmark_report+0xd0f>
  213d58:	48 85 f6             	test   rsi,rsi
  213d5b:	74 45                	je     213da2 <Benchmark_report+0xe82>
  213d5d:	48 83 c2 60          	add    rdx,0x60
  213d61:	48 f7 de             	neg    rsi
  213d64:	c4 c1 7d 10 44 15 a0 	vmovupd ymm0,YMMWORD PTR [r13+rdx*1-0x60]
  213d6b:	c4 c1 7c 10 4c 15 c0 	vmovups ymm1,YMMWORD PTR [r13+rdx*1-0x40]
  213d72:	c4 c1 7d 10 54 15 e0 	vmovupd ymm2,YMMWORD PTR [r13+rdx*1-0x20]
  213d79:	c4 c1 7d 10 5c 15 00 	vmovupd ymm3,YMMWORD PTR [r13+rdx*1+0x0]
        dest[i] = s;
  213d80:	c5 fd 11 44 15 a0    	vmovupd YMMWORD PTR [rbp+rdx*1-0x60],ymm0
  213d86:	c5 fc 11 4c 15 c0    	vmovups YMMWORD PTR [rbp+rdx*1-0x40],ymm1
  213d8c:	c5 fd 11 54 15 e0    	vmovupd YMMWORD PTR [rbp+rdx*1-0x20],ymm2
  213d92:	c5 fd 11 5c 15 00    	vmovupd YMMWORD PTR [rbp+rdx*1+0x0],ymm3
    for (source) |s, i|
  213d98:	48 83 ea 80          	sub    rdx,0xffffffffffffff80
  213d9c:	48 83 c6 01          	add    rsi,0x1
  213da0:	75 c2                	jne    213d64 <Benchmark_report+0xe44>
    context.remaining = context.remaining[bytes.len..];
  213da2:	4c 89 e6             	mov    rsi,r12
  213da5:	49 39 fc             	cmp    r12,rdi
  213da8:	0f 85 7c fc ff ff    	jne    213a2a <Benchmark_report+0xb0a>
  213dae:	48 01 f5             	add    rbp,rsi
  213db1:	49 29 f6             	sub    r14,rsi
            while (i < num_digits_whole) : (i += 1) {
  213db4:	4d 39 cb             	cmp    r11,r9
  213db7:	76 23                	jbe    213ddc <Benchmark_report+0xebc>
  213db9:	31 ff                	xor    edi,edi
  213dbb:	4c 89 e2             	mov    rdx,r12
    if (context.remaining.len < bytes.len) return error.BufferTooSmall;
  213dbe:	4d 85 f6             	test   r14,r14
  213dc1:	0f 84 44 f6 ff ff    	je     21340b <Benchmark_report+0x4eb>
        dest[i] = s;
  213dc7:	c6 45 00 30          	mov    BYTE PTR [rbp+0x0],0x30
    context.remaining = context.remaining[bytes.len..];
  213dcb:	48 83 c5 01          	add    rbp,0x1
  213dcf:	49 83 c6 ff          	add    r14,0xffffffffffffffff
            while (i < num_digits_whole) : (i += 1) {
  213dd3:	48 83 c2 01          	add    rdx,0x1
  213dd7:	4c 39 da             	cmp    rdx,r11
  213dda:	72 e2                	jb     213dbe <Benchmark_report+0xe9e>
  213ddc:	66 b8 05 00          	mov    ax,0x5
    if (context.remaining.len < bytes.len) return error.BufferTooSmall;
  213de0:	4d 85 f6             	test   r14,r14
  213de3:	0f 84 34 fd ff ff    	je     213b1d <Benchmark_report+0xbfd>
  213de9:	c6 45 00 2e          	mov    BYTE PTR [rbp+0x0],0x2e
    context.remaining = context.remaining[bytes.len..];
  213ded:	4c 8d 55 01          	lea    r10,[rbp+0x1]
  213df1:	49 8d 7e ff          	lea    rdi,[r14-0x1]
        if (float_decimal.exp <= 0) {
  213df5:	45 85 c0             	test   r8d,r8d
  213df8:	7e 69                	jle    213e63 <Benchmark_report+0xf43>
  213dfa:	45 31 c0             	xor    r8d,r8d
        if (num_digits_whole_no_pad + precision - printed < float_decimal.digits.len) {
  213dfd:	4c 89 c1             	mov    rcx,r8
  213e00:	48 f7 d9             	neg    rcx
  213e03:	49 8d 14 0c          	lea    rdx,[r12+rcx*1]
  213e07:	48 83 c2 03          	add    rdx,0x3
  213e0b:	4f 8d 34 2c          	lea    r14,[r12+r13*1]
  213e0f:	4c 39 ca             	cmp    rdx,r9
  213e12:	73 2f                	jae    213e43 <Benchmark_report+0xf23>
            try output(context, float_decimal.digits[num_digits_whole_no_pad .. num_digits_whole_no_pad + precision - printed]);
  213e14:	49 89 d7             	mov    r15,rdx
  213e17:	4d 29 e7             	sub    r15,r12
    if (context.remaining.len < bytes.len) return error.BufferTooSmall;
  213e1a:	4c 39 ff             	cmp    rdi,r15
  213e1d:	72 33                	jb     213e52 <Benchmark_report+0xf32>
    for (source) |s, i|
  213e1f:	4d 85 ff             	test   r15,r15
  213e22:	0f 84 e0 00 00 00    	je     213f08 <Benchmark_report+0xfe8>
  213e28:	41 8a 06             	mov    al,BYTE PTR [r14]
        dest[i] = s;
  213e2b:	41 88 02             	mov    BYTE PTR [r10],al
    for (source) |s, i|
  213e2e:	49 83 ff 01          	cmp    r15,0x1
  213e32:	0f 85 f4 00 00 00    	jne    213f2c <Benchmark_report+0x100c>
  213e38:	41 bf 01 00 00 00    	mov    r15d,0x1
  213e3e:	e9 3a 0c 00 00       	jmp    214a7d <Benchmark_report+0x1b5d>
            try output(context, float_decimal.digits[num_digits_whole_no_pad..]);
  213e43:	4d 89 cf             	mov    r15,r9
  213e46:	4d 29 e7             	sub    r15,r12
    if (context.remaining.len < bytes.len) return error.BufferTooSmall;
  213e49:	4c 39 ff             	cmp    rdi,r15
  213e4c:	0f 83 97 00 00 00    	jae    213ee9 <Benchmark_report+0xfc9>
  213e52:	4c 89 d5             	mov    rbp,r10
                    try formatType(args[next_arg], fmt[s..i], context, Errors, output);
  213e55:	66 85 c0             	test   ax,ax
  213e58:	0f 85 34 f3 ff ff    	jne    213192 <Benchmark_report+0x272>
  213e5e:	e9 b1 f5 ff ff       	jmp    213414 <Benchmark_report+0x4f4>
            const zero_digit_count = @intCast(usize, -float_decimal.exp);
  213e63:	41 f7 d8             	neg    r8d
  213e66:	49 63 c8             	movsxd rcx,r8d
  213e69:	48 83 f9 03          	cmp    rcx,0x3
  213e6d:	ba 03 00 00 00       	mov    edx,0x3
  213e72:	48 0f 42 d1          	cmovb  rdx,rcx
            while (i < zeros_to_print) : (i += 1) {
  213e76:	48 85 d2             	test   rdx,rdx
  213e79:	0f 84 7b ff ff ff    	je     213dfa <Benchmark_report+0xeda>
    if (context.remaining.len < bytes.len) return error.BufferTooSmall;
  213e7f:	48 85 ff             	test   rdi,rdi
  213e82:	0f 84 a7 02 00 00    	je     21412f <Benchmark_report+0x120f>
        dest[i] = s;
  213e88:	c6 45 01 30          	mov    BYTE PTR [rbp+0x1],0x30
    context.remaining = context.remaining[bytes.len..];
  213e8c:	4c 8d 55 02          	lea    r10,[rbp+0x2]
  213e90:	49 8d 7e fe          	lea    rdi,[r14-0x2]
            while (i < zeros_to_print) : (i += 1) {
  213e94:	48 83 fa 01          	cmp    rdx,0x1
  213e98:	76 7d                	jbe    213f17 <Benchmark_report+0xff7>
    if (context.remaining.len < bytes.len) return error.BufferTooSmall;
  213e9a:	48 85 ff             	test   rdi,rdi
  213e9d:	0f 84 8c 02 00 00    	je     21412f <Benchmark_report+0x120f>
  213ea3:	c6 45 02 30          	mov    BYTE PTR [rbp+0x2],0x30
    context.remaining = context.remaining[bytes.len..];
  213ea7:	4c 8d 55 03          	lea    r10,[rbp+0x3]
  213eab:	49 8d 7e fd          	lea    rdi,[r14-0x3]
            while (i < zeros_to_print) : (i += 1) {
  213eaf:	48 83 fa 03          	cmp    rdx,0x3
  213eb3:	0f 82 59 04 00 00    	jb     214312 <Benchmark_report+0x13f2>
    if (context.remaining.len < bytes.len) return error.BufferTooSmall;
  213eb9:	48 85 ff             	test   rdi,rdi
  213ebc:	0f 84 6d 02 00 00    	je     21412f <Benchmark_report+0x120f>
  213ec2:	c6 45 03 30          	mov    BYTE PTR [rbp+0x3],0x30
    context.remaining = context.remaining[bytes.len..];
  213ec6:	48 83 c5 04          	add    rbp,0x4
  213eca:	49 83 c6 fc          	add    r14,0xfffffffffffffffc
  213ece:	b2 01                	mov    dl,0x1
  213ed0:	41 b8 03 00 00 00    	mov    r8d,0x3
  213ed6:	49 89 ea             	mov    r10,rbp
  213ed9:	4c 89 f7             	mov    rdi,r14
            if (printed >= precision) {
  213edc:	84 d2                	test   dl,dl
  213ede:	0f 84 19 ff ff ff    	je     213dfd <Benchmark_report+0xedd>
  213ee4:	e9 39 04 00 00       	jmp    214322 <Benchmark_report+0x1402>
    for (source) |s, i|
  213ee9:	4d 85 ff             	test   r15,r15
  213eec:	74 22                	je     213f10 <Benchmark_report+0xff0>
  213eee:	41 8a 0e             	mov    cl,BYTE PTR [r14]
        dest[i] = s;
  213ef1:	41 88 0a             	mov    BYTE PTR [r10],cl
    for (source) |s, i|
  213ef4:	49 83 ff 01          	cmp    r15,0x1
  213ef8:	0f 85 29 01 00 00    	jne    214027 <Benchmark_report+0x1107>
  213efe:	ba 01 00 00 00       	mov    edx,0x1
  213f03:	e9 a5 01 00 00       	jmp    2140ad <Benchmark_report+0x118d>
  213f08:	45 31 ff             	xor    r15d,r15d
  213f0b:	e9 6d 0b 00 00       	jmp    214a7d <Benchmark_report+0x1b5d>
  213f10:	31 d2                	xor    edx,edx
  213f12:	e9 96 01 00 00       	jmp    2140ad <Benchmark_report+0x118d>
  213f17:	31 d2                	xor    edx,edx
  213f19:	41 b8 01 00 00 00    	mov    r8d,0x1
  213f1f:	84 d2                	test   dl,dl
  213f21:	0f 84 d6 fe ff ff    	je     213dfd <Benchmark_report+0xedd>
  213f27:	e9 f6 03 00 00       	jmp    214322 <Benchmark_report+0x1402>
  213f2c:	b9 02 00 00 00       	mov    ecx,0x2
  213f31:	4c 29 c1             	sub    rcx,r8
  213f34:	48 81 f9 80 00 00 00 	cmp    rcx,0x80
  213f3b:	72 25                	jb     213f62 <Benchmark_report+0x1042>
  213f3d:	49 8d 42 01          	lea    rax,[r10+0x1]
  213f41:	4c 01 ea             	add    rdx,r13
  213f44:	48 39 d0             	cmp    rax,rdx
  213f47:	0f 83 e8 03 00 00    	jae    214335 <Benchmark_report+0x1415>
  213f4d:	4b 8d 04 3a          	lea    rax,[r10+r15*1]
  213f51:	4b 8d 14 2c          	lea    rdx,[r12+r13*1]
  213f55:	48 83 c2 01          	add    rdx,0x1
  213f59:	48 39 c2             	cmp    rdx,rax
  213f5c:	0f 83 d3 03 00 00    	jae    214335 <Benchmark_report+0x1415>
  213f62:	b8 01 00 00 00       	mov    eax,0x1
  213f67:	ba 03 00 00 00       	mov    edx,0x3
  213f6c:	44 29 c2             	sub    edx,r8d
  213f6f:	29 c2                	sub    edx,eax
  213f71:	be 02 00 00 00       	mov    esi,0x2
  213f76:	4c 29 c6             	sub    rsi,r8
  213f79:	48 29 c6             	sub    rsi,rax
  213f7c:	48 83 e2 07          	and    rdx,0x7
  213f80:	74 16                	je     213f98 <Benchmark_report+0x1078>
  213f82:	48 f7 da             	neg    rdx
  213f85:	41 0f b6 0c 06       	movzx  ecx,BYTE PTR [r14+rax*1]
        dest[i] = s;
  213f8a:	41 88 0c 02          	mov    BYTE PTR [r10+rax*1],cl
    for (source) |s, i|
  213f8e:	48 83 c0 01          	add    rax,0x1
  213f92:	48 83 c2 01          	add    rdx,0x1
  213f96:	75 ed                	jne    213f85 <Benchmark_report+0x1065>
  213f98:	48 83 fe 07          	cmp    rsi,0x7
  213f9c:	0f 82 db 0a 00 00    	jb     214a7d <Benchmark_report+0x1b5d>
  213fa2:	ba 03 00 00 00       	mov    edx,0x3
  213fa7:	4c 29 c2             	sub    rdx,r8
  213faa:	48 29 c2             	sub    rdx,rax
  213fad:	49 f7 d3             	not    r11
  213fb0:	49 f7 d1             	not    r9
  213fb3:	4d 39 cb             	cmp    r11,r9
  213fb6:	4d 0f 47 cb          	cmova  r9,r11
  213fba:	49 8d 34 02          	lea    rsi,[r10+rax*1]
  213fbe:	48 83 c6 07          	add    rsi,0x7
  213fc2:	4c 29 c8             	sub    rax,r9
  213fc5:	49 01 c5             	add    r13,rax
  213fc8:	31 c0                	xor    eax,eax
  213fca:	41 0f b6 4c 05 ff    	movzx  ecx,BYTE PTR [r13+rax*1-0x1]
        dest[i] = s;
  213fd0:	88 4c 06 f9          	mov    BYTE PTR [rsi+rax*1-0x7],cl
    for (source) |s, i|
  213fd4:	41 0f b6 4c 05 00    	movzx  ecx,BYTE PTR [r13+rax*1+0x0]
        dest[i] = s;
  213fda:	88 4c 06 fa          	mov    BYTE PTR [rsi+rax*1-0x6],cl
    for (source) |s, i|
  213fde:	41 0f b6 4c 05 01    	movzx  ecx,BYTE PTR [r13+rax*1+0x1]
        dest[i] = s;
  213fe4:	88 4c 06 fb          	mov    BYTE PTR [rsi+rax*1-0x5],cl
    for (source) |s, i|
  213fe8:	41 0f b6 4c 05 02    	movzx  ecx,BYTE PTR [r13+rax*1+0x2]
        dest[i] = s;
  213fee:	88 4c 06 fc          	mov    BYTE PTR [rsi+rax*1-0x4],cl
    for (source) |s, i|
  213ff2:	41 0f b6 4c 05 03    	movzx  ecx,BYTE PTR [r13+rax*1+0x3]
        dest[i] = s;
  213ff8:	88 4c 06 fd          	mov    BYTE PTR [rsi+rax*1-0x3],cl
    for (source) |s, i|
  213ffc:	41 0f b6 4c 05 04    	movzx  ecx,BYTE PTR [r13+rax*1+0x4]
        dest[i] = s;
  214002:	88 4c 06 fe          	mov    BYTE PTR [rsi+rax*1-0x2],cl
    for (source) |s, i|
  214006:	41 0f b6 4c 05 05    	movzx  ecx,BYTE PTR [r13+rax*1+0x5]
        dest[i] = s;
  21400c:	88 4c 06 ff          	mov    BYTE PTR [rsi+rax*1-0x1],cl
    for (source) |s, i|
  214010:	41 0f b6 4c 05 06    	movzx  ecx,BYTE PTR [r13+rax*1+0x6]
        dest[i] = s;
  214016:	88 0c 06             	mov    BYTE PTR [rsi+rax*1],cl
    for (source) |s, i|
  214019:	48 83 c0 08          	add    rax,0x8
  21401d:	48 39 c2             	cmp    rdx,rax
  214020:	75 a8                	jne    213fca <Benchmark_report+0x10aa>
  214022:	e9 56 0a 00 00       	jmp    214a7d <Benchmark_report+0x1b5d>
  214027:	4d 39 d9             	cmp    r9,r11
  21402a:	4c 89 ce             	mov    rsi,r9
  21402d:	49 0f 47 f3          	cmova  rsi,r11
  214031:	48 f7 d6             	not    rsi
  214034:	49 8d 1c 31          	lea    rbx,[r9+rsi*1]
  214038:	48 81 fb 80 00 00 00 	cmp    rbx,0x80
  21403f:	72 26                	jb     214067 <Benchmark_report+0x1147>
  214041:	49 8d 4a 01          	lea    rcx,[r10+0x1]
  214045:	4b 8d 14 29          	lea    rdx,[r9+r13*1]
  214049:	48 39 d1             	cmp    rcx,rdx
  21404c:	0f 83 18 03 00 00    	jae    21436a <Benchmark_report+0x144a>
  214052:	4b 8d 0c 3a          	lea    rcx,[r10+r15*1]
  214056:	4b 8d 14 2c          	lea    rdx,[r12+r13*1]
  21405a:	48 83 c2 01          	add    rdx,0x1
  21405e:	48 39 ca             	cmp    rdx,rcx
  214061:	0f 83 03 03 00 00    	jae    21436a <Benchmark_report+0x144a>
  214067:	41 bc 01 00 00 00    	mov    r12d,0x1
  21406d:	49 f7 d3             	not    r11
  214070:	4c 89 c9             	mov    rcx,r9
  214073:	48 f7 d1             	not    rcx
  214076:	49 39 cb             	cmp    r11,rcx
  214079:	49 0f 47 cb          	cmova  rcx,r11
  21407d:	49 8d 14 09          	lea    rdx,[r9+rcx*1]
  214081:	48 83 c2 01          	add    rdx,0x1
  214085:	4c 29 e2             	sub    rdx,r12
  214088:	4b 8d 34 22          	lea    rsi,[r10+r12*1]
  21408c:	49 83 c4 ff          	add    r12,0xffffffffffffffff
  214090:	49 29 cc             	sub    r12,rcx
  214093:	4d 01 e5             	add    r13,r12
  214096:	31 ed                	xor    ebp,ebp
  214098:	41 0f b6 4c 2d 00    	movzx  ecx,BYTE PTR [r13+rbp*1+0x0]
        dest[i] = s;
  21409e:	88 0c 2e             	mov    BYTE PTR [rsi+rbp*1],cl
    for (source) |s, i|
  2140a1:	48 83 c5 01          	add    rbp,0x1
  2140a5:	48 39 ea             	cmp    rdx,rbp
  2140a8:	75 ee                	jne    214098 <Benchmark_report+0x1178>
    context.remaining = context.remaining[bytes.len..];
  2140aa:	4c 89 fa             	mov    rdx,r15
  2140ad:	49 01 d2             	add    r10,rdx
  2140b0:	48 29 d7             	sub    rdi,rdx
            printed += float_decimal.digits.len - num_digits_whole_no_pad;
  2140b3:	4d 01 f8             	add    r8,r15
            while (printed < precision) : (printed += 1) {
  2140b6:	49 83 f8 02          	cmp    r8,0x2
  2140ba:	0f 87 62 02 00 00    	ja     214322 <Benchmark_report+0x1402>
    if (context.remaining.len < bytes.len) return error.BufferTooSmall;
  2140c0:	48 85 ff             	test   rdi,rdi
  2140c3:	74 6a                	je     21412f <Benchmark_report+0x120f>
        dest[i] = s;
  2140c5:	41 c6 02 30          	mov    BYTE PTR [r10],0x30
    context.remaining = context.remaining[bytes.len..];
  2140c9:	49 83 c2 01          	add    r10,0x1
  2140cd:	48 8d 4f ff          	lea    rcx,[rdi-0x1]
            while (printed < precision) : (printed += 1) {
  2140d1:	49 8d 50 01          	lea    rdx,[r8+0x1]
  2140d5:	48 83 fa 03          	cmp    rdx,0x3
  2140d9:	0f 83 e9 01 00 00    	jae    2142c8 <Benchmark_report+0x13a8>
    if (context.remaining.len < bytes.len) return error.BufferTooSmall;
  2140df:	48 85 c9             	test   rcx,rcx
  2140e2:	74 4b                	je     21412f <Benchmark_report+0x120f>
  2140e4:	41 c6 02 30          	mov    BYTE PTR [r10],0x30
    context.remaining = context.remaining[bytes.len..];
  2140e8:	49 83 c2 01          	add    r10,0x1
  2140ec:	48 8d 4f fe          	lea    rcx,[rdi-0x2]
            while (printed < precision) : (printed += 1) {
  2140f0:	49 8d 50 02          	lea    rdx,[r8+0x2]
  2140f4:	48 83 fa 02          	cmp    rdx,0x2
  2140f8:	0f 87 ca 01 00 00    	ja     2142c8 <Benchmark_report+0x13a8>
    if (context.remaining.len < bytes.len) return error.BufferTooSmall;
  2140fe:	48 85 c9             	test   rcx,rcx
  214101:	74 2c                	je     21412f <Benchmark_report+0x120f>
  214103:	41 c6 02 30          	mov    BYTE PTR [r10],0x30
    context.remaining = context.remaining[bytes.len..];
  214107:	49 83 c2 01          	add    r10,0x1
  21410b:	48 8d 4f fd          	lea    rcx,[rdi-0x3]
            while (printed < precision) : (printed += 1) {
  21410f:	49 83 f8 fd          	cmp    r8,0xfffffffffffffffd
  214113:	0f 82 af 01 00 00    	jb     2142c8 <Benchmark_report+0x13a8>
    if (context.remaining.len < bytes.len) return error.BufferTooSmall;
  214119:	48 85 c9             	test   rcx,rcx
  21411c:	74 11                	je     21412f <Benchmark_report+0x120f>
  21411e:	41 c6 02 30          	mov    BYTE PTR [r10],0x30
    context.remaining = context.remaining[bytes.len..];
  214122:	49 83 c2 01          	add    r10,0x1
  214126:	48 83 c7 fc          	add    rdi,0xfffffffffffffffc
  21412a:	e9 f3 01 00 00       	jmp    214322 <Benchmark_report+0x1402>
  21412f:	31 ff                	xor    edi,edi
  214131:	4c 89 d5             	mov    rbp,r10
                    try formatType(args[next_arg], fmt[s..i], context, Errors, output);
  214134:	66 85 c0             	test   ax,ax
  214137:	0f 85 55 f0 ff ff    	jne    213192 <Benchmark_report+0x272>
  21413d:	e9 d2 f2 ff ff       	jmp    213414 <Benchmark_report+0x4f4>
                float_decimal.exp += 1;
  214142:	41 83 c1 01          	add    r9d,0x1
                float_decimal.digits = one_before[0 .. float_decimal.digits.len + 1];
  214146:	49 83 c0 01          	add    r8,0x1
                float_decimal.digits[0] = '1';
  21414a:	41 c6 45 ff 31       	mov    BYTE PTR [r13-0x1],0x31
                const one_before = @intToPtr([*]u8, @ptrToInt(&float_decimal.digits[0]) - 1);
  21414f:	49 83 c5 ff          	add    r13,0xffffffffffffffff
        var num_digits_whole = if (float_decimal.exp > 0) @intCast(usize, float_decimal.exp) else 0;
  214153:	45 31 db             	xor    r11d,r11d
  214156:	45 85 c9             	test   r9d,r9d
  214159:	44 89 c8             	mov    eax,r9d
  21415c:	4c 0f 4f d8          	cmovg  r11,rax
  214160:	4d 39 c3             	cmp    r11,r8
  214163:	4d 89 c7             	mov    r15,r8
  214166:	4d 0f 42 fb          	cmovb  r15,r11
  21416a:	45 85 c9             	test   r9d,r9d
        if (num_digits_whole > 0) {
  21416d:	0f 8e 16 01 00 00    	jle    214289 <Benchmark_report+0x1369>
  214173:	66 b8 05 00          	mov    ax,0x5
    if (context.remaining.len < bytes.len) return error.BufferTooSmall;
  214177:	4c 39 fd             	cmp    rbp,r15
  21417a:	0f 82 6a f5 ff ff    	jb     2136ea <Benchmark_report+0x7ca>
    for (source) |s, i|
  214180:	4d 85 ff             	test   r15,r15
  214183:	0f 84 29 01 00 00    	je     2142b2 <Benchmark_report+0x1392>
  214189:	49 81 ff 80 00 00 00 	cmp    r15,0x80
  214190:	72 1a                	jb     2141ac <Benchmark_report+0x128c>
  214192:	4b 8d 0c 2f          	lea    rcx,[r15+r13*1]
  214196:	49 39 ce             	cmp    r14,rcx
  214199:	0f 83 3f 01 00 00    	jae    2142de <Benchmark_report+0x13be>
  21419f:	4b 8d 0c 3e          	lea    rcx,[r14+r15*1]
  2141a3:	4c 39 e9             	cmp    rcx,r13
  2141a6:	0f 86 32 01 00 00    	jbe    2142de <Benchmark_report+0x13be>
  2141ac:	31 ff                	xor    edi,edi
  2141ae:	4d 39 d8             	cmp    r8,r11
  2141b1:	4c 89 c2             	mov    rdx,r8
  2141b4:	49 0f 47 d3          	cmova  rdx,r11
  2141b8:	48 89 d6             	mov    rsi,rdx
  2141bb:	48 f7 d6             	not    rsi
  2141be:	49 c7 c2 fe ff ff ff 	mov    r10,0xfffffffffffffffe
  2141c5:	49 29 fa             	sub    r10,rdi
  2141c8:	49 29 f2             	sub    r10,rsi
  2141cb:	48 83 e2 07          	and    rdx,0x7
  2141cf:	74 17                	je     2141e8 <Benchmark_report+0x12c8>
  2141d1:	48 f7 da             	neg    rdx
  2141d4:	41 0f b6 4c 3d 00    	movzx  ecx,BYTE PTR [r13+rdi*1+0x0]
        dest[i] = s;
  2141da:	41 88 0c 3e          	mov    BYTE PTR [r14+rdi*1],cl
    for (source) |s, i|
  2141de:	48 83 c7 01          	add    rdi,0x1
  2141e2:	48 83 c2 01          	add    rdx,0x1
  2141e6:	75 ec                	jne    2141d4 <Benchmark_report+0x12b4>
    context.remaining = context.remaining[bytes.len..];
  2141e8:	4c 89 fa             	mov    rdx,r15
  2141eb:	49 83 fa 07          	cmp    r10,0x7
  2141ef:	0f 82 4a 03 00 00    	jb     21453f <Benchmark_report+0x161f>
  2141f5:	49 89 fa             	mov    r10,rdi
  2141f8:	49 f7 d2             	not    r10
  2141fb:	4c 89 da             	mov    rdx,r11
  2141fe:	48 f7 d2             	not    rdx
  214201:	4c 89 c6             	mov    rsi,r8
  214204:	48 f7 d6             	not    rsi
  214207:	48 39 f2             	cmp    rdx,rsi
  21420a:	48 0f 47 f2          	cmova  rsi,rdx
  21420e:	49 29 f2             	sub    r10,rsi
  214211:	49 8d 14 3e          	lea    rdx,[r14+rdi*1]
  214215:	48 83 c2 07          	add    rdx,0x7
  214219:	4a 8d 34 2f          	lea    rsi,[rdi+r13*1]
  21421d:	48 83 c6 07          	add    rsi,0x7
  214221:	31 ff                	xor    edi,edi
  214223:	0f b6 4c 3e f9       	movzx  ecx,BYTE PTR [rsi+rdi*1-0x7]
        dest[i] = s;
  214228:	88 4c 3a f9          	mov    BYTE PTR [rdx+rdi*1-0x7],cl
    for (source) |s, i|
  21422c:	0f b6 4c 3e fa       	movzx  ecx,BYTE PTR [rsi+rdi*1-0x6]
        dest[i] = s;
  214231:	88 4c 3a fa          	mov    BYTE PTR [rdx+rdi*1-0x6],cl
    for (source) |s, i|
  214235:	0f b6 4c 3e fb       	movzx  ecx,BYTE PTR [rsi+rdi*1-0x5]
        dest[i] = s;
  21423a:	88 4c 3a fb          	mov    BYTE PTR [rdx+rdi*1-0x5],cl
    for (source) |s, i|
  21423e:	0f b6 4c 3e fc       	movzx  ecx,BYTE PTR [rsi+rdi*1-0x4]
        dest[i] = s;
  214243:	88 4c 3a fc          	mov    BYTE PTR [rdx+rdi*1-0x4],cl
    for (source) |s, i|
  214247:	0f b6 4c 3e fd       	movzx  ecx,BYTE PTR [rsi+rdi*1-0x3]
        dest[i] = s;
  21424c:	88 4c 3a fd          	mov    BYTE PTR [rdx+rdi*1-0x3],cl
    for (source) |s, i|
  214250:	0f b6 4c 3e fe       	movzx  ecx,BYTE PTR [rsi+rdi*1-0x2]
        dest[i] = s;
  214255:	88 4c 3a fe          	mov    BYTE PTR [rdx+rdi*1-0x2],cl
    for (source) |s, i|
  214259:	0f b6 4c 3e ff       	movzx  ecx,BYTE PTR [rsi+rdi*1-0x1]
        dest[i] = s;
  21425e:	88 4c 3a ff          	mov    BYTE PTR [rdx+rdi*1-0x1],cl
    for (source) |s, i|
  214262:	0f b6 0c 3e          	movzx  ecx,BYTE PTR [rsi+rdi*1]
        dest[i] = s;
  214266:	88 0c 3a             	mov    BYTE PTR [rdx+rdi*1],cl
    for (source) |s, i|
  214269:	48 83 c7 08          	add    rdi,0x8
  21426d:	49 39 fa             	cmp    r10,rdi
  214270:	75 b1                	jne    214223 <Benchmark_report+0x1303>
  214272:	4c 89 fa             	mov    rdx,r15
  214275:	49 01 d6             	add    r14,rdx
  214278:	48 29 d5             	sub    rbp,rdx
            while (i < num_digits_whole) : (i += 1) {
  21427b:	4d 39 c3             	cmp    r11,r8
  21427e:	0f 86 e9 02 00 00    	jbe    21456d <Benchmark_report+0x164d>
  214284:	e9 c1 02 00 00       	jmp    21454a <Benchmark_report+0x162a>
        dest[i] = s;
  214289:	41 c6 06 30          	mov    BYTE PTR [r14],0x30
    context.remaining = context.remaining[bytes.len..];
  21428d:	49 83 c6 01          	add    r14,0x1
  214291:	48 83 c5 ff          	add    rbp,0xffffffffffffffff
  214295:	66 b8 05 00          	mov    ax,0x5
    if (context.remaining.len < bytes.len) return error.BufferTooSmall;
  214299:	48 85 ed             	test   rbp,rbp
  21429c:	0f 85 d8 02 00 00    	jne    21457a <Benchmark_report+0x165a>
  2142a2:	31 ff                	xor    edi,edi
                    try formatType(args[next_arg], fmt[s..i], context, Errors, output);
  2142a4:	66 85 c0             	test   ax,ax
  2142a7:	0f 85 e5 ee ff ff    	jne    213192 <Benchmark_report+0x272>
  2142ad:	e9 44 f4 ff ff       	jmp    2136f6 <Benchmark_report+0x7d6>
  2142b2:	31 d2                	xor    edx,edx
    context.remaining = context.remaining[bytes.len..];
  2142b4:	49 01 d6             	add    r14,rdx
  2142b7:	48 29 d5             	sub    rbp,rdx
            while (i < num_digits_whole) : (i += 1) {
  2142ba:	4d 39 c3             	cmp    r11,r8
  2142bd:	0f 87 87 02 00 00    	ja     21454a <Benchmark_report+0x162a>
  2142c3:	e9 a5 02 00 00       	jmp    21456d <Benchmark_report+0x164d>
  2142c8:	31 c0                	xor    eax,eax
  2142ca:	48 89 cf             	mov    rdi,rcx
  2142cd:	4c 89 d5             	mov    rbp,r10
                    try formatType(args[next_arg], fmt[s..i], context, Errors, output);
  2142d0:	66 85 c0             	test   ax,ax
  2142d3:	0f 85 b9 ee ff ff    	jne    213192 <Benchmark_report+0x272>
  2142d9:	e9 36 f1 ff ff       	jmp    213414 <Benchmark_report+0x4f4>
    for (source) |s, i|
  2142de:	44 89 ff             	mov    edi,r15d
  2142e1:	83 e7 80             	and    edi,0xffffff80
  2142e4:	48 8d 4f 80          	lea    rcx,[rdi-0x80]
  2142e8:	48 89 ce             	mov    rsi,rcx
  2142eb:	48 c1 ee 07          	shr    rsi,0x7
  2142ef:	8d 56 01             	lea    edx,[rsi+0x1]
  2142f2:	83 e2 03             	and    edx,0x3
  2142f5:	48 81 f9 80 01 00 00 	cmp    rcx,0x180
  2142fc:	0f 83 a3 00 00 00    	jae    2143a5 <Benchmark_report+0x1485>
  214302:	31 f6                	xor    esi,esi
  214304:	48 85 d2             	test   rdx,rdx
  214307:	0f 85 de 01 00 00    	jne    2144eb <Benchmark_report+0x15cb>
  21430d:	e9 21 02 00 00       	jmp    214533 <Benchmark_report+0x1613>
  214312:	31 d2                	xor    edx,edx
  214314:	41 b8 02 00 00 00    	mov    r8d,0x2
            if (printed >= precision) {
  21431a:	84 d2                	test   dl,dl
  21431c:	0f 84 db fa ff ff    	je     213dfd <Benchmark_report+0xedd>
  214322:	31 c0                	xor    eax,eax
  214324:	4c 89 d5             	mov    rbp,r10
                    try formatType(args[next_arg], fmt[s..i], context, Errors, output);
  214327:	66 85 c0             	test   ax,ax
  21432a:	0f 85 62 ee ff ff    	jne    213192 <Benchmark_report+0x272>
  214330:	e9 df f0 ff ff       	jmp    213414 <Benchmark_report+0x4f4>
  214335:	48 89 c8             	mov    rax,rcx
  214338:	48 83 e0 80          	and    rax,0xffffffffffffff80
  21433c:	48 8d 58 80          	lea    rbx,[rax-0x80]
  214340:	48 89 de             	mov    rsi,rbx
  214343:	48 c1 ee 07          	shr    rsi,0x7
  214347:	8d 56 01             	lea    edx,[rsi+0x1]
  21434a:	83 e2 03             	and    edx,0x3
  21434d:	48 81 fb 80 01 00 00 	cmp    rbx,0x180
  214354:	0f 83 7f 05 00 00    	jae    2148d9 <Benchmark_report+0x19b9>
  21435a:	31 f6                	xor    esi,esi
  21435c:	48 85 d2             	test   rdx,rdx
  21435f:	0f 85 c5 06 00 00    	jne    214a2a <Benchmark_report+0x1b0a>
  214365:	e9 0a 07 00 00       	jmp    214a74 <Benchmark_report+0x1b54>
  21436a:	48 89 5c 24 10       	mov    QWORD PTR [rsp+0x10],rbx
  21436f:	49 89 dc             	mov    r12,rbx
  214372:	49 83 e4 80          	and    r12,0xffffffffffffff80
  214376:	49 8d 5c 24 80       	lea    rbx,[r12-0x80]
  21437b:	48 89 d9             	mov    rcx,rbx
  21437e:	48 c1 e9 07          	shr    rcx,0x7
  214382:	8d 51 01             	lea    edx,[rcx+0x1]
  214385:	83 e2 03             	and    edx,0x3
  214388:	48 81 fb 80 01 00 00 	cmp    rbx,0x180
  21438f:	0f 83 01 07 00 00    	jae    214a96 <Benchmark_report+0x1b76>
  214395:	31 f6                	xor    esi,esi
  214397:	48 85 d2             	test   rdx,rdx
  21439a:	0f 85 34 08 00 00    	jne    214bd4 <Benchmark_report+0x1cb4>
  2143a0:	e9 79 08 00 00       	jmp    214c1e <Benchmark_report+0x1cfe>
  2143a5:	48 8d 4a ff          	lea    rcx,[rdx-0x1]
  2143a9:	48 29 f1             	sub    rcx,rsi
  2143ac:	31 f6                	xor    esi,esi
  2143ae:	c4 c1 7c 10 44 35 00 	vmovups ymm0,YMMWORD PTR [r13+rsi*1+0x0]
  2143b5:	c4 c1 7c 10 4c 35 20 	vmovups ymm1,YMMWORD PTR [r13+rsi*1+0x20]
  2143bc:	c4 c1 7c 10 54 35 40 	vmovups ymm2,YMMWORD PTR [r13+rsi*1+0x40]
  2143c3:	c4 c1 7c 10 5c 35 60 	vmovups ymm3,YMMWORD PTR [r13+rsi*1+0x60]
        dest[i] = s;
  2143ca:	c4 c1 7c 11 04 36    	vmovups YMMWORD PTR [r14+rsi*1],ymm0
  2143d0:	c4 c1 7c 11 4c 36 20 	vmovups YMMWORD PTR [r14+rsi*1+0x20],ymm1
  2143d7:	c4 c1 7c 11 54 36 40 	vmovups YMMWORD PTR [r14+rsi*1+0x40],ymm2
  2143de:	c4 c1 7c 11 5c 36 60 	vmovups YMMWORD PTR [r14+rsi*1+0x60],ymm3
    for (source) |s, i|
  2143e5:	c4 c1 7c 10 84 35 80 	vmovups ymm0,YMMWORD PTR [r13+rsi*1+0x80]
  2143ec:	00 00 00 
  2143ef:	c4 c1 7c 10 8c 35 a0 	vmovups ymm1,YMMWORD PTR [r13+rsi*1+0xa0]
  2143f6:	00 00 00 
  2143f9:	c4 c1 7c 10 94 35 c0 	vmovups ymm2,YMMWORD PTR [r13+rsi*1+0xc0]
  214400:	00 00 00 
  214403:	c4 c1 7c 10 9c 35 e0 	vmovups ymm3,YMMWORD PTR [r13+rsi*1+0xe0]
  21440a:	00 00 00 
        dest[i] = s;
  21440d:	c4 c1 7c 11 84 36 80 	vmovups YMMWORD PTR [r14+rsi*1+0x80],ymm0
  214414:	00 00 00 
  214417:	c4 c1 7c 11 8c 36 a0 	vmovups YMMWORD PTR [r14+rsi*1+0xa0],ymm1
  21441e:	00 00 00 
  214421:	c4 c1 7c 11 94 36 c0 	vmovups YMMWORD PTR [r14+rsi*1+0xc0],ymm2
  214428:	00 00 00 
  21442b:	c4 c1 7c 11 9c 36 e0 	vmovups YMMWORD PTR [r14+rsi*1+0xe0],ymm3
  214432:	00 00 00 
    for (source) |s, i|
  214435:	c4 c1 7c 10 84 35 00 	vmovups ymm0,YMMWORD PTR [r13+rsi*1+0x100]
  21443c:	01 00 00 
  21443f:	c4 c1 7c 10 8c 35 20 	vmovups ymm1,YMMWORD PTR [r13+rsi*1+0x120]
  214446:	01 00 00 
  214449:	c4 c1 7c 10 94 35 40 	vmovups ymm2,YMMWORD PTR [r13+rsi*1+0x140]
  214450:	01 00 00 
  214453:	c4 c1 7c 10 9c 35 60 	vmovups ymm3,YMMWORD PTR [r13+rsi*1+0x160]
  21445a:	01 00 00 
        dest[i] = s;
  21445d:	c4 c1 7c 11 84 36 00 	vmovups YMMWORD PTR [r14+rsi*1+0x100],ymm0
  214464:	01 00 00 
  214467:	c4 c1 7c 11 8c 36 20 	vmovups YMMWORD PTR [r14+rsi*1+0x120],ymm1
  21446e:	01 00 00 
  214471:	c4 c1 7c 11 94 36 40 	vmovups YMMWORD PTR [r14+rsi*1+0x140],ymm2
  214478:	01 00 00 
  21447b:	c4 c1 7c 11 9c 36 60 	vmovups YMMWORD PTR [r14+rsi*1+0x160],ymm3
  214482:	01 00 00 
    for (source) |s, i|
  214485:	c4 c1 7d 10 84 35 80 	vmovupd ymm0,YMMWORD PTR [r13+rsi*1+0x180]
  21448c:	01 00 00 
  21448f:	c4 c1 7c 10 8c 35 a0 	vmovups ymm1,YMMWORD PTR [r13+rsi*1+0x1a0]
  214496:	01 00 00 
  214499:	c4 c1 7d 10 94 35 c0 	vmovupd ymm2,YMMWORD PTR [r13+rsi*1+0x1c0]
  2144a0:	01 00 00 
  2144a3:	c4 c1 7d 10 9c 35 e0 	vmovupd ymm3,YMMWORD PTR [r13+rsi*1+0x1e0]
  2144aa:	01 00 00 
        dest[i] = s;
  2144ad:	c4 c1 7d 11 84 36 80 	vmovupd YMMWORD PTR [r14+rsi*1+0x180],ymm0
  2144b4:	01 00 00 
  2144b7:	c4 c1 7c 11 8c 36 a0 	vmovups YMMWORD PTR [r14+rsi*1+0x1a0],ymm1
  2144be:	01 00 00 
  2144c1:	c4 c1 7d 11 94 36 c0 	vmovupd YMMWORD PTR [r14+rsi*1+0x1c0],ymm2
  2144c8:	01 00 00 
  2144cb:	c4 c1 7d 11 9c 36 e0 	vmovupd YMMWORD PTR [r14+rsi*1+0x1e0],ymm3
  2144d2:	01 00 00 
    for (source) |s, i|
  2144d5:	48 81 c6 00 02 00 00 	add    rsi,0x200
  2144dc:	48 83 c1 04          	add    rcx,0x4
  2144e0:	0f 85 c8 fe ff ff    	jne    2143ae <Benchmark_report+0x148e>
  2144e6:	48 85 d2             	test   rdx,rdx
  2144e9:	74 48                	je     214533 <Benchmark_report+0x1613>
  2144eb:	48 83 c6 60          	add    rsi,0x60
  2144ef:	48 f7 da             	neg    rdx
  2144f2:	c4 c1 7d 10 44 35 a0 	vmovupd ymm0,YMMWORD PTR [r13+rsi*1-0x60]
  2144f9:	c4 c1 7c 10 4c 35 c0 	vmovups ymm1,YMMWORD PTR [r13+rsi*1-0x40]
  214500:	c4 c1 7d 10 54 35 e0 	vmovupd ymm2,YMMWORD PTR [r13+rsi*1-0x20]
  214507:	c4 c1 7d 10 5c 35 00 	vmovupd ymm3,YMMWORD PTR [r13+rsi*1+0x0]
        dest[i] = s;
  21450e:	c4 c1 7d 11 44 36 a0 	vmovupd YMMWORD PTR [r14+rsi*1-0x60],ymm0
  214515:	c4 c1 7c 11 4c 36 c0 	vmovups YMMWORD PTR [r14+rsi*1-0x40],ymm1
  21451c:	c4 c1 7d 11 54 36 e0 	vmovupd YMMWORD PTR [r14+rsi*1-0x20],ymm2
  214523:	c4 c1 7d 11 1c 36    	vmovupd YMMWORD PTR [r14+rsi*1],ymm3
    for (source) |s, i|
  214529:	48 83 ee 80          	sub    rsi,0xffffffffffffff80
  21452d:	48 83 c2 01          	add    rdx,0x1
  214531:	75 bf                	jne    2144f2 <Benchmark_report+0x15d2>
    context.remaining = context.remaining[bytes.len..];
  214533:	4c 89 fa             	mov    rdx,r15
  214536:	49 39 ff             	cmp    r15,rdi
  214539:	0f 85 6f fc ff ff    	jne    2141ae <Benchmark_report+0x128e>
  21453f:	49 01 d6             	add    r14,rdx
  214542:	48 29 d5             	sub    rbp,rdx
            while (i < num_digits_whole) : (i += 1) {
  214545:	4d 39 c3             	cmp    r11,r8
  214548:	76 23                	jbe    21456d <Benchmark_report+0x164d>
  21454a:	31 ff                	xor    edi,edi
  21454c:	4c 89 f9             	mov    rcx,r15
    if (context.remaining.len < bytes.len) return error.BufferTooSmall;
  21454f:	48 85 ed             	test   rbp,rbp
  214552:	0f 84 95 f1 ff ff    	je     2136ed <Benchmark_report+0x7cd>
        dest[i] = s;
  214558:	41 c6 06 30          	mov    BYTE PTR [r14],0x30
    context.remaining = context.remaining[bytes.len..];
  21455c:	49 83 c6 01          	add    r14,0x1
  214560:	48 83 c5 ff          	add    rbp,0xffffffffffffffff
            while (i < num_digits_whole) : (i += 1) {
  214564:	48 83 c1 01          	add    rcx,0x1
  214568:	4c 39 d9             	cmp    rcx,r11
  21456b:	72 e2                	jb     21454f <Benchmark_report+0x162f>
  21456d:	66 b8 05 00          	mov    ax,0x5
    if (context.remaining.len < bytes.len) return error.BufferTooSmall;
  214571:	48 85 ed             	test   rbp,rbp
  214574:	0f 84 28 fd ff ff    	je     2142a2 <Benchmark_report+0x1382>
  21457a:	41 c6 06 2e          	mov    BYTE PTR [r14],0x2e
    context.remaining = context.remaining[bytes.len..];
  21457e:	4d 8d 56 01          	lea    r10,[r14+0x1]
  214582:	48 8d 7d ff          	lea    rdi,[rbp-0x1]
        if (float_decimal.exp <= 0) {
  214586:	45 85 c9             	test   r9d,r9d
  214589:	7e 67                	jle    2145f2 <Benchmark_report+0x16d2>
  21458b:	45 31 c9             	xor    r9d,r9d
        if (num_digits_whole_no_pad + precision - printed < float_decimal.digits.len) {
  21458e:	4c 89 c9             	mov    rcx,r9
  214591:	48 f7 d9             	neg    rcx
  214594:	4c 01 f9             	add    rcx,r15
  214597:	48 83 c1 03          	add    rcx,0x3
  21459b:	4b 8d 34 2f          	lea    rsi,[r15+r13*1]
  21459f:	4c 39 c1             	cmp    rcx,r8
  2145a2:	73 2e                	jae    2145d2 <Benchmark_report+0x16b2>
            try output(context, float_decimal.digits[num_digits_whole_no_pad .. num_digits_whole_no_pad + precision - printed]);
  2145a4:	49 89 cc             	mov    r12,rcx
  2145a7:	4d 29 fc             	sub    r12,r15
    if (context.remaining.len < bytes.len) return error.BufferTooSmall;
  2145aa:	4c 39 e7             	cmp    rdi,r12
  2145ad:	72 32                	jb     2145e1 <Benchmark_report+0x16c1>
    for (source) |s, i|
  2145af:	4d 85 e4             	test   r12,r12
  2145b2:	0f 84 dd 00 00 00    	je     214695 <Benchmark_report+0x1775>
  2145b8:	8a 06                	mov    al,BYTE PTR [rsi]
        dest[i] = s;
  2145ba:	41 88 02             	mov    BYTE PTR [r10],al
    for (source) |s, i|
  2145bd:	49 83 fc 01          	cmp    r12,0x1
  2145c1:	0f 85 f2 00 00 00    	jne    2146b9 <Benchmark_report+0x1799>
  2145c7:	41 bc 01 00 00 00    	mov    r12d,0x1
  2145cd:	e9 95 08 00 00       	jmp    214e67 <Benchmark_report+0x1f47>
            try output(context, float_decimal.digits[num_digits_whole_no_pad..]);
  2145d2:	4d 89 c4             	mov    r12,r8
  2145d5:	4d 29 fc             	sub    r12,r15
    if (context.remaining.len < bytes.len) return error.BufferTooSmall;
  2145d8:	4c 39 e7             	cmp    rdi,r12
  2145db:	0f 83 96 00 00 00    	jae    214677 <Benchmark_report+0x1757>
  2145e1:	4d 89 d6             	mov    r14,r10
                    try formatType(args[next_arg], fmt[s..i], context, Errors, output);
  2145e4:	66 85 c0             	test   ax,ax
  2145e7:	0f 85 a5 eb ff ff    	jne    213192 <Benchmark_report+0x272>
  2145ed:	e9 04 f1 ff ff       	jmp    2136f6 <Benchmark_report+0x7d6>
            const zero_digit_count = @intCast(usize, -float_decimal.exp);
  2145f2:	41 f7 d9             	neg    r9d
  2145f5:	49 63 d1             	movsxd rdx,r9d
  2145f8:	48 83 fa 03          	cmp    rdx,0x3
  2145fc:	b9 03 00 00 00       	mov    ecx,0x3
  214601:	48 0f 42 ca          	cmovb  rcx,rdx
            while (i < zeros_to_print) : (i += 1) {
  214605:	48 85 c9             	test   rcx,rcx
  214608:	74 81                	je     21458b <Benchmark_report+0x166b>
    if (context.remaining.len < bytes.len) return error.BufferTooSmall;
  21460a:	48 85 ff             	test   rdi,rdi
  21460d:	0f 84 9d 02 00 00    	je     2148b0 <Benchmark_report+0x1990>
        dest[i] = s;
  214613:	41 c6 46 01 30       	mov    BYTE PTR [r14+0x1],0x30
    context.remaining = context.remaining[bytes.len..];
  214618:	4d 8d 56 02          	lea    r10,[r14+0x2]
  21461c:	48 8d 7d fe          	lea    rdi,[rbp-0x2]
            while (i < zeros_to_print) : (i += 1) {
  214620:	48 83 f9 01          	cmp    rcx,0x1
  214624:	76 7e                	jbe    2146a4 <Benchmark_report+0x1784>
    if (context.remaining.len < bytes.len) return error.BufferTooSmall;
  214626:	48 85 ff             	test   rdi,rdi
  214629:	0f 84 81 02 00 00    	je     2148b0 <Benchmark_report+0x1990>
  21462f:	41 c6 46 02 30       	mov    BYTE PTR [r14+0x2],0x30
    context.remaining = context.remaining[bytes.len..];
  214634:	4d 8d 56 03          	lea    r10,[r14+0x3]
  214638:	48 8d 7d fd          	lea    rdi,[rbp-0x3]
            while (i < zeros_to_print) : (i += 1) {
  21463c:	48 83 f9 03          	cmp    rcx,0x3
  214640:	0f 82 f8 05 00 00    	jb     214c3e <Benchmark_report+0x1d1e>
    if (context.remaining.len < bytes.len) return error.BufferTooSmall;
  214646:	48 85 ff             	test   rdi,rdi
  214649:	0f 84 61 02 00 00    	je     2148b0 <Benchmark_report+0x1990>
  21464f:	41 c6 46 03 30       	mov    BYTE PTR [r14+0x3],0x30
    context.remaining = context.remaining[bytes.len..];
  214654:	49 83 c6 04          	add    r14,0x4
  214658:	48 83 c5 fc          	add    rbp,0xfffffffffffffffc
  21465c:	b1 01                	mov    cl,0x1
  21465e:	41 b9 03 00 00 00    	mov    r9d,0x3
  214664:	4d 89 f2             	mov    r10,r14
  214667:	48 89 ef             	mov    rdi,rbp
            if (printed >= precision) {
  21466a:	84 c9                	test   cl,cl
  21466c:	0f 84 1c ff ff ff    	je     21458e <Benchmark_report+0x166e>
  214672:	e9 d7 05 00 00       	jmp    214c4e <Benchmark_report+0x1d2e>
    for (source) |s, i|
  214677:	4d 85 e4             	test   r12,r12
  21467a:	74 21                	je     21469d <Benchmark_report+0x177d>
  21467c:	8a 0e                	mov    cl,BYTE PTR [rsi]
        dest[i] = s;
  21467e:	41 88 0a             	mov    BYTE PTR [r10],cl
    for (source) |s, i|
  214681:	49 83 fc 01          	cmp    r12,0x1
  214685:	0f 85 29 01 00 00    	jne    2147b4 <Benchmark_report+0x1894>
  21468b:	b9 01 00 00 00       	mov    ecx,0x1
  214690:	e9 a5 01 00 00       	jmp    21483a <Benchmark_report+0x191a>
  214695:	45 31 e4             	xor    r12d,r12d
  214698:	e9 ca 07 00 00       	jmp    214e67 <Benchmark_report+0x1f47>
  21469d:	31 c9                	xor    ecx,ecx
  21469f:	e9 96 01 00 00       	jmp    21483a <Benchmark_report+0x191a>
  2146a4:	31 c9                	xor    ecx,ecx
  2146a6:	41 b9 01 00 00 00    	mov    r9d,0x1
  2146ac:	84 c9                	test   cl,cl
  2146ae:	0f 84 da fe ff ff    	je     21458e <Benchmark_report+0x166e>
  2146b4:	e9 95 05 00 00       	jmp    214c4e <Benchmark_report+0x1d2e>
  2146b9:	41 be 02 00 00 00    	mov    r14d,0x2
  2146bf:	4d 29 ce             	sub    r14,r9
  2146c2:	49 81 fe 80 00 00 00 	cmp    r14,0x80
  2146c9:	72 25                	jb     2146f0 <Benchmark_report+0x17d0>
  2146cb:	49 8d 42 01          	lea    rax,[r10+0x1]
  2146cf:	4c 01 e9             	add    rcx,r13
  2146d2:	48 39 c8             	cmp    rax,rcx
  2146d5:	0f 83 86 05 00 00    	jae    214c61 <Benchmark_report+0x1d41>
  2146db:	4b 8d 04 22          	lea    rax,[r10+r12*1]
  2146df:	4b 8d 0c 2f          	lea    rcx,[r15+r13*1]
  2146e3:	48 83 c1 01          	add    rcx,0x1
  2146e7:	48 39 c1             	cmp    rcx,rax
  2146ea:	0f 83 71 05 00 00    	jae    214c61 <Benchmark_report+0x1d41>
  2146f0:	b8 01 00 00 00       	mov    eax,0x1
  2146f5:	b9 03 00 00 00       	mov    ecx,0x3
  2146fa:	44 29 c9             	sub    ecx,r9d
  2146fd:	29 c1                	sub    ecx,eax
  2146ff:	ba 02 00 00 00       	mov    edx,0x2
  214704:	4c 29 ca             	sub    rdx,r9
  214707:	48 29 c2             	sub    rdx,rax
  21470a:	48 83 e1 07          	and    rcx,0x7
  21470e:	74 15                	je     214725 <Benchmark_report+0x1805>
  214710:	48 f7 d9             	neg    rcx
  214713:	0f b6 1c 06          	movzx  ebx,BYTE PTR [rsi+rax*1]
        dest[i] = s;
  214717:	41 88 1c 02          	mov    BYTE PTR [r10+rax*1],bl
    for (source) |s, i|
  21471b:	48 83 c0 01          	add    rax,0x1
  21471f:	48 83 c1 01          	add    rcx,0x1
  214723:	75 ee                	jne    214713 <Benchmark_report+0x17f3>
  214725:	48 83 fa 07          	cmp    rdx,0x7
  214729:	0f 82 38 07 00 00    	jb     214e67 <Benchmark_report+0x1f47>
  21472f:	b9 03 00 00 00       	mov    ecx,0x3
  214734:	4c 29 c9             	sub    rcx,r9
  214737:	48 29 c1             	sub    rcx,rax
  21473a:	49 f7 d3             	not    r11
  21473d:	49 f7 d0             	not    r8
  214740:	4d 39 c3             	cmp    r11,r8
  214743:	4d 0f 47 c3          	cmova  r8,r11
  214747:	49 8d 14 02          	lea    rdx,[r10+rax*1]
  21474b:	48 83 c2 07          	add    rdx,0x7
  21474f:	4c 29 c0             	sub    rax,r8
  214752:	49 01 c5             	add    r13,rax
  214755:	31 c0                	xor    eax,eax
  214757:	41 0f b6 5c 05 ff    	movzx  ebx,BYTE PTR [r13+rax*1-0x1]
        dest[i] = s;
  21475d:	88 5c 02 f9          	mov    BYTE PTR [rdx+rax*1-0x7],bl
    for (source) |s, i|
  214761:	41 0f b6 5c 05 00    	movzx  ebx,BYTE PTR [r13+rax*1+0x0]
        dest[i] = s;
  214767:	88 5c 02 fa          	mov    BYTE PTR [rdx+rax*1-0x6],bl
    for (source) |s, i|
  21476b:	41 0f b6 5c 05 01    	movzx  ebx,BYTE PTR [r13+rax*1+0x1]
        dest[i] = s;
  214771:	88 5c 02 fb          	mov    BYTE PTR [rdx+rax*1-0x5],bl
    for (source) |s, i|
  214775:	41 0f b6 5c 05 02    	movzx  ebx,BYTE PTR [r13+rax*1+0x2]
        dest[i] = s;
  21477b:	88 5c 02 fc          	mov    BYTE PTR [rdx+rax*1-0x4],bl
    for (source) |s, i|
  21477f:	41 0f b6 5c 05 03    	movzx  ebx,BYTE PTR [r13+rax*1+0x3]
        dest[i] = s;
  214785:	88 5c 02 fd          	mov    BYTE PTR [rdx+rax*1-0x3],bl
    for (source) |s, i|
  214789:	41 0f b6 5c 05 04    	movzx  ebx,BYTE PTR [r13+rax*1+0x4]
        dest[i] = s;
  21478f:	88 5c 02 fe          	mov    BYTE PTR [rdx+rax*1-0x2],bl
    for (source) |s, i|
  214793:	41 0f b6 5c 05 05    	movzx  ebx,BYTE PTR [r13+rax*1+0x5]
        dest[i] = s;
  214799:	88 5c 02 ff          	mov    BYTE PTR [rdx+rax*1-0x1],bl
    for (source) |s, i|
  21479d:	41 0f b6 5c 05 06    	movzx  ebx,BYTE PTR [r13+rax*1+0x6]
        dest[i] = s;
  2147a3:	88 1c 02             	mov    BYTE PTR [rdx+rax*1],bl
    for (source) |s, i|
  2147a6:	48 83 c0 08          	add    rax,0x8
  2147aa:	48 39 c1             	cmp    rcx,rax
  2147ad:	75 a8                	jne    214757 <Benchmark_report+0x1837>
  2147af:	e9 b3 06 00 00       	jmp    214e67 <Benchmark_report+0x1f47>
  2147b4:	4d 39 d8             	cmp    r8,r11
  2147b7:	4c 89 c1             	mov    rcx,r8
  2147ba:	49 0f 47 cb          	cmova  rcx,r11
  2147be:	48 f7 d1             	not    rcx
  2147c1:	4d 8d 34 08          	lea    r14,[r8+rcx*1]
  2147c5:	49 81 fe 80 00 00 00 	cmp    r14,0x80
  2147cc:	72 26                	jb     2147f4 <Benchmark_report+0x18d4>
  2147ce:	49 8d 52 01          	lea    rdx,[r10+0x1]
  2147d2:	4b 8d 1c 28          	lea    rbx,[r8+r13*1]
  2147d6:	48 39 da             	cmp    rdx,rbx
  2147d9:	0f 83 b3 04 00 00    	jae    214c92 <Benchmark_report+0x1d72>
  2147df:	4b 8d 14 22          	lea    rdx,[r10+r12*1]
  2147e3:	4b 8d 1c 2f          	lea    rbx,[r15+r13*1]
  2147e7:	48 83 c3 01          	add    rbx,0x1
  2147eb:	48 39 d3             	cmp    rbx,rdx
  2147ee:	0f 83 9e 04 00 00    	jae    214c92 <Benchmark_report+0x1d72>
  2147f4:	41 bf 01 00 00 00    	mov    r15d,0x1
  2147fa:	49 f7 d3             	not    r11
  2147fd:	4c 89 c6             	mov    rsi,r8
  214800:	48 f7 d6             	not    rsi
  214803:	49 39 f3             	cmp    r11,rsi
  214806:	49 0f 47 f3          	cmova  rsi,r11
  21480a:	49 8d 0c 30          	lea    rcx,[r8+rsi*1]
  21480e:	48 83 c1 01          	add    rcx,0x1
  214812:	4c 29 f9             	sub    rcx,r15
  214815:	4b 8d 14 3a          	lea    rdx,[r10+r15*1]
  214819:	49 83 c7 ff          	add    r15,0xffffffffffffffff
  21481d:	49 29 f7             	sub    r15,rsi
  214820:	4d 01 fd             	add    r13,r15
  214823:	31 f6                	xor    esi,esi
  214825:	41 0f b6 5c 35 00    	movzx  ebx,BYTE PTR [r13+rsi*1+0x0]
        dest[i] = s;
  21482b:	88 1c 32             	mov    BYTE PTR [rdx+rsi*1],bl
    for (source) |s, i|
  21482e:	48 83 c6 01          	add    rsi,0x1
  214832:	48 39 f1             	cmp    rcx,rsi
  214835:	75 ee                	jne    214825 <Benchmark_report+0x1905>
    context.remaining = context.remaining[bytes.len..];
  214837:	4c 89 e1             	mov    rcx,r12
  21483a:	49 01 ca             	add    r10,rcx
  21483d:	48 29 cf             	sub    rdi,rcx
            printed += float_decimal.digits.len - num_digits_whole_no_pad;
  214840:	4d 01 e1             	add    r9,r12
            while (printed < precision) : (printed += 1) {
  214843:	49 83 f9 02          	cmp    r9,0x2
  214847:	0f 87 01 04 00 00    	ja     214c4e <Benchmark_report+0x1d2e>
    if (context.remaining.len < bytes.len) return error.BufferTooSmall;
  21484d:	48 85 ff             	test   rdi,rdi
  214850:	74 5e                	je     2148b0 <Benchmark_report+0x1990>
        dest[i] = s;
  214852:	41 c6 02 30          	mov    BYTE PTR [r10],0x30
    context.remaining = context.remaining[bytes.len..];
  214856:	49 83 c2 01          	add    r10,0x1
  21485a:	48 8d 4f ff          	lea    rcx,[rdi-0x1]
            while (printed < precision) : (printed += 1) {
  21485e:	49 8d 51 01          	lea    rdx,[r9+0x1]
  214862:	48 83 fa 03          	cmp    rdx,0x3
  214866:	73 5b                	jae    2148c3 <Benchmark_report+0x19a3>
    if (context.remaining.len < bytes.len) return error.BufferTooSmall;
  214868:	48 85 c9             	test   rcx,rcx
  21486b:	74 43                	je     2148b0 <Benchmark_report+0x1990>
  21486d:	41 c6 02 30          	mov    BYTE PTR [r10],0x30
    context.remaining = context.remaining[bytes.len..];
  214871:	49 83 c2 01          	add    r10,0x1
  214875:	48 8d 4f fe          	lea    rcx,[rdi-0x2]
            while (printed < precision) : (printed += 1) {
  214879:	49 8d 51 02          	lea    rdx,[r9+0x2]
  21487d:	48 83 fa 02          	cmp    rdx,0x2
  214881:	77 40                	ja     2148c3 <Benchmark_report+0x19a3>
    if (context.remaining.len < bytes.len) return error.BufferTooSmall;
  214883:	48 85 c9             	test   rcx,rcx
  214886:	74 28                	je     2148b0 <Benchmark_report+0x1990>
  214888:	41 c6 02 30          	mov    BYTE PTR [r10],0x30
    context.remaining = context.remaining[bytes.len..];
  21488c:	49 83 c2 01          	add    r10,0x1
  214890:	48 8d 4f fd          	lea    rcx,[rdi-0x3]
            while (printed < precision) : (printed += 1) {
  214894:	49 83 f9 fd          	cmp    r9,0xfffffffffffffffd
  214898:	72 29                	jb     2148c3 <Benchmark_report+0x19a3>
    if (context.remaining.len < bytes.len) return error.BufferTooSmall;
  21489a:	48 85 c9             	test   rcx,rcx
  21489d:	74 11                	je     2148b0 <Benchmark_report+0x1990>
  21489f:	41 c6 02 30          	mov    BYTE PTR [r10],0x30
    context.remaining = context.remaining[bytes.len..];
  2148a3:	49 83 c2 01          	add    r10,0x1
  2148a7:	48 83 c7 fc          	add    rdi,0xfffffffffffffffc
  2148ab:	e9 9e 03 00 00       	jmp    214c4e <Benchmark_report+0x1d2e>
  2148b0:	31 ff                	xor    edi,edi
  2148b2:	4d 89 d6             	mov    r14,r10
                    try formatType(args[next_arg], fmt[s..i], context, Errors, output);
  2148b5:	66 85 c0             	test   ax,ax
  2148b8:	0f 85 d4 e8 ff ff    	jne    213192 <Benchmark_report+0x272>
  2148be:	e9 33 ee ff ff       	jmp    2136f6 <Benchmark_report+0x7d6>
  2148c3:	31 c0                	xor    eax,eax
  2148c5:	48 89 cf             	mov    rdi,rcx
  2148c8:	4d 89 d6             	mov    r14,r10
  2148cb:	66 85 c0             	test   ax,ax
  2148ce:	0f 85 be e8 ff ff    	jne    213192 <Benchmark_report+0x272>
  2148d4:	e9 1d ee ff ff       	jmp    2136f6 <Benchmark_report+0x7d6>
    for (source) |s, i|
  2148d9:	4c 89 db             	mov    rbx,r11
  2148dc:	48 f7 d3             	not    rbx
  2148df:	4c 89 cd             	mov    rbp,r9
  2148e2:	48 f7 d5             	not    rbp
  2148e5:	48 39 eb             	cmp    rbx,rbp
  2148e8:	48 0f 47 eb          	cmova  rbp,rbx
  2148ec:	bb e0 01 00 00       	mov    ebx,0x1e0
  2148f1:	48 29 eb             	sub    rbx,rbp
  2148f4:	4c 01 eb             	add    rbx,r13
  2148f7:	48 8d 6a ff          	lea    rbp,[rdx-0x1]
  2148fb:	48 29 f5             	sub    rbp,rsi
  2148fe:	31 f6                	xor    esi,esi
  214900:	c5 fc 10 84 33 20 fe 	vmovups ymm0,YMMWORD PTR [rbx+rsi*1-0x1e0]
  214907:	ff ff 
  214909:	c5 fc 10 8c 33 40 fe 	vmovups ymm1,YMMWORD PTR [rbx+rsi*1-0x1c0]
  214910:	ff ff 
  214912:	c5 fc 10 94 33 60 fe 	vmovups ymm2,YMMWORD PTR [rbx+rsi*1-0x1a0]
  214919:	ff ff 
  21491b:	c5 fc 10 9c 33 80 fe 	vmovups ymm3,YMMWORD PTR [rbx+rsi*1-0x180]
  214922:	ff ff 
        dest[i] = s;
  214924:	c4 c1 7c 11 44 32 01 	vmovups YMMWORD PTR [r10+rsi*1+0x1],ymm0
  21492b:	c4 c1 7c 11 4c 32 21 	vmovups YMMWORD PTR [r10+rsi*1+0x21],ymm1
  214932:	c4 c1 7c 11 54 32 41 	vmovups YMMWORD PTR [r10+rsi*1+0x41],ymm2
  214939:	c4 c1 7c 11 5c 32 61 	vmovups YMMWORD PTR [r10+rsi*1+0x61],ymm3
    for (source) |s, i|
  214940:	c5 fc 10 84 33 a0 fe 	vmovups ymm0,YMMWORD PTR [rbx+rsi*1-0x160]
  214947:	ff ff 
  214949:	c5 fc 10 8c 33 c0 fe 	vmovups ymm1,YMMWORD PTR [rbx+rsi*1-0x140]
  214950:	ff ff 
  214952:	c5 fc 10 94 33 e0 fe 	vmovups ymm2,YMMWORD PTR [rbx+rsi*1-0x120]
  214959:	ff ff 
  21495b:	c5 fc 10 9c 33 00 ff 	vmovups ymm3,YMMWORD PTR [rbx+rsi*1-0x100]
  214962:	ff ff 
        dest[i] = s;
  214964:	c4 c1 7c 11 84 32 81 	vmovups YMMWORD PTR [r10+rsi*1+0x81],ymm0
  21496b:	00 00 00 
  21496e:	c4 c1 7c 11 8c 32 a1 	vmovups YMMWORD PTR [r10+rsi*1+0xa1],ymm1
  214975:	00 00 00 
  214978:	c4 c1 7c 11 94 32 c1 	vmovups YMMWORD PTR [r10+rsi*1+0xc1],ymm2
  21497f:	00 00 00 
  214982:	c4 c1 7c 11 9c 32 e1 	vmovups YMMWORD PTR [r10+rsi*1+0xe1],ymm3
  214989:	00 00 00 
    for (source) |s, i|
  21498c:	c5 fc 10 84 33 20 ff 	vmovups ymm0,YMMWORD PTR [rbx+rsi*1-0xe0]
  214993:	ff ff 
  214995:	c5 fc 10 8c 33 40 ff 	vmovups ymm1,YMMWORD PTR [rbx+rsi*1-0xc0]
  21499c:	ff ff 
  21499e:	c5 fc 10 94 33 60 ff 	vmovups ymm2,YMMWORD PTR [rbx+rsi*1-0xa0]
  2149a5:	ff ff 
  2149a7:	c5 fc 10 5c 33 80    	vmovups ymm3,YMMWORD PTR [rbx+rsi*1-0x80]
        dest[i] = s;
  2149ad:	c4 c1 7c 11 84 32 01 	vmovups YMMWORD PTR [r10+rsi*1+0x101],ymm0
  2149b4:	01 00 00 
  2149b7:	c4 c1 7c 11 8c 32 21 	vmovups YMMWORD PTR [r10+rsi*1+0x121],ymm1
  2149be:	01 00 00 
  2149c1:	c4 c1 7c 11 94 32 41 	vmovups YMMWORD PTR [r10+rsi*1+0x141],ymm2
  2149c8:	01 00 00 
  2149cb:	c4 c1 7c 11 9c 32 61 	vmovups YMMWORD PTR [r10+rsi*1+0x161],ymm3
  2149d2:	01 00 00 
    for (source) |s, i|
  2149d5:	c5 fd 10 44 33 a0    	vmovupd ymm0,YMMWORD PTR [rbx+rsi*1-0x60]
  2149db:	c5 fc 10 4c 33 c0    	vmovups ymm1,YMMWORD PTR [rbx+rsi*1-0x40]
  2149e1:	c5 fd 10 54 33 e0    	vmovupd ymm2,YMMWORD PTR [rbx+rsi*1-0x20]
  2149e7:	c5 fd 10 1c 33       	vmovupd ymm3,YMMWORD PTR [rbx+rsi*1]
        dest[i] = s;
  2149ec:	c4 c1 7d 11 84 32 81 	vmovupd YMMWORD PTR [r10+rsi*1+0x181],ymm0
  2149f3:	01 00 00 
  2149f6:	c4 c1 7c 11 8c 32 a1 	vmovups YMMWORD PTR [r10+rsi*1+0x1a1],ymm1
  2149fd:	01 00 00 
  214a00:	c4 c1 7d 11 94 32 c1 	vmovupd YMMWORD PTR [r10+rsi*1+0x1c1],ymm2
  214a07:	01 00 00 
  214a0a:	c4 c1 7d 11 9c 32 e1 	vmovupd YMMWORD PTR [r10+rsi*1+0x1e1],ymm3
  214a11:	01 00 00 
  214a14:	48 81 c6 00 02 00 00 	add    rsi,0x200
  214a1b:	48 83 c5 04          	add    rbp,0x4
  214a1f:	0f 85 db fe ff ff    	jne    214900 <Benchmark_report+0x19e0>
  214a25:	48 85 d2             	test   rdx,rdx
  214a28:	74 4a                	je     214a74 <Benchmark_report+0x1b54>
  214a2a:	48 f7 da             	neg    rdx
  214a2d:	48 89 f3             	mov    rbx,rsi
  214a30:	48 83 cb 01          	or     rbx,0x1
    for (source) |s, i|
  214a34:	c4 c1 7d 10 04 1e    	vmovupd ymm0,YMMWORD PTR [r14+rbx*1]
  214a3a:	c4 c1 7c 10 4c 1e 20 	vmovups ymm1,YMMWORD PTR [r14+rbx*1+0x20]
  214a41:	c4 c1 7d 10 54 1e 40 	vmovupd ymm2,YMMWORD PTR [r14+rbx*1+0x40]
  214a48:	c4 c1 7d 10 5c 1e 60 	vmovupd ymm3,YMMWORD PTR [r14+rbx*1+0x60]
        dest[i] = s;
  214a4f:	c4 c1 7d 11 04 1a    	vmovupd YMMWORD PTR [r10+rbx*1],ymm0
  214a55:	c4 c1 7c 11 4c 1a 20 	vmovups YMMWORD PTR [r10+rbx*1+0x20],ymm1
  214a5c:	c4 c1 7d 11 54 1a 40 	vmovupd YMMWORD PTR [r10+rbx*1+0x40],ymm2
  214a63:	c4 c1 7d 11 5c 1a 60 	vmovupd YMMWORD PTR [r10+rbx*1+0x60],ymm3
  214a6a:	48 83 ee 80          	sub    rsi,0xffffffffffffff80
  214a6e:	48 83 c2 01          	add    rdx,0x1
  214a72:	75 b9                	jne    214a2d <Benchmark_report+0x1b0d>
  214a74:	48 39 c1             	cmp    rcx,rax
    for (source) |s, i|
  214a77:	0f 85 b8 01 00 00    	jne    214c35 <Benchmark_report+0x1d15>
    context.remaining = context.remaining[bytes.len..];
  214a7d:	4d 01 fa             	add    r10,r15
  214a80:	4c 29 ff             	sub    rdi,r15
  214a83:	31 c0                	xor    eax,eax
  214a85:	4c 89 d5             	mov    rbp,r10
                    try formatType(args[next_arg], fmt[s..i], context, Errors, output);
  214a88:	66 85 c0             	test   ax,ax
  214a8b:	0f 85 01 e7 ff ff    	jne    213192 <Benchmark_report+0x272>
  214a91:	e9 7e e9 ff ff       	jmp    213414 <Benchmark_report+0x4f4>
  214a96:	bb e0 01 00 00       	mov    ebx,0x1e0
  214a9b:	48 29 f3             	sub    rbx,rsi
  214a9e:	4c 01 eb             	add    rbx,r13
  214aa1:	48 8d 6a ff          	lea    rbp,[rdx-0x1]
  214aa5:	48 29 cd             	sub    rbp,rcx
  214aa8:	31 f6                	xor    esi,esi
  214aaa:	c5 fc 10 84 33 20 fe 	vmovups ymm0,YMMWORD PTR [rbx+rsi*1-0x1e0]
  214ab1:	ff ff 
  214ab3:	c5 fc 10 8c 33 40 fe 	vmovups ymm1,YMMWORD PTR [rbx+rsi*1-0x1c0]
  214aba:	ff ff 
  214abc:	c5 fc 10 94 33 60 fe 	vmovups ymm2,YMMWORD PTR [rbx+rsi*1-0x1a0]
  214ac3:	ff ff 
  214ac5:	c5 fc 10 9c 33 80 fe 	vmovups ymm3,YMMWORD PTR [rbx+rsi*1-0x180]
  214acc:	ff ff 
        dest[i] = s;
  214ace:	c4 c1 7c 11 44 32 01 	vmovups YMMWORD PTR [r10+rsi*1+0x1],ymm0
  214ad5:	c4 c1 7c 11 4c 32 21 	vmovups YMMWORD PTR [r10+rsi*1+0x21],ymm1
  214adc:	c4 c1 7c 11 54 32 41 	vmovups YMMWORD PTR [r10+rsi*1+0x41],ymm2
  214ae3:	c4 c1 7c 11 5c 32 61 	vmovups YMMWORD PTR [r10+rsi*1+0x61],ymm3
    for (source) |s, i|
  214aea:	c5 fc 10 84 33 a0 fe 	vmovups ymm0,YMMWORD PTR [rbx+rsi*1-0x160]
  214af1:	ff ff 
  214af3:	c5 fc 10 8c 33 c0 fe 	vmovups ymm1,YMMWORD PTR [rbx+rsi*1-0x140]
  214afa:	ff ff 
  214afc:	c5 fc 10 94 33 e0 fe 	vmovups ymm2,YMMWORD PTR [rbx+rsi*1-0x120]
  214b03:	ff ff 
  214b05:	c5 fc 10 9c 33 00 ff 	vmovups ymm3,YMMWORD PTR [rbx+rsi*1-0x100]
  214b0c:	ff ff 
        dest[i] = s;
  214b0e:	c4 c1 7c 11 84 32 81 	vmovups YMMWORD PTR [r10+rsi*1+0x81],ymm0
  214b15:	00 00 00 
  214b18:	c4 c1 7c 11 8c 32 a1 	vmovups YMMWORD PTR [r10+rsi*1+0xa1],ymm1
  214b1f:	00 00 00 
  214b22:	c4 c1 7c 11 94 32 c1 	vmovups YMMWORD PTR [r10+rsi*1+0xc1],ymm2
  214b29:	00 00 00 
  214b2c:	c4 c1 7c 11 9c 32 e1 	vmovups YMMWORD PTR [r10+rsi*1+0xe1],ymm3
  214b33:	00 00 00 
    for (source) |s, i|
  214b36:	c5 fc 10 84 33 20 ff 	vmovups ymm0,YMMWORD PTR [rbx+rsi*1-0xe0]
  214b3d:	ff ff 
  214b3f:	c5 fc 10 8c 33 40 ff 	vmovups ymm1,YMMWORD PTR [rbx+rsi*1-0xc0]
  214b46:	ff ff 
  214b48:	c5 fc 10 94 33 60 ff 	vmovups ymm2,YMMWORD PTR [rbx+rsi*1-0xa0]
  214b4f:	ff ff 
  214b51:	c5 fc 10 5c 33 80    	vmovups ymm3,YMMWORD PTR [rbx+rsi*1-0x80]
        dest[i] = s;
  214b57:	c4 c1 7c 11 84 32 01 	vmovups YMMWORD PTR [r10+rsi*1+0x101],ymm0
  214b5e:	01 00 00 
  214b61:	c4 c1 7c 11 8c 32 21 	vmovups YMMWORD PTR [r10+rsi*1+0x121],ymm1
  214b68:	01 00 00 
  214b6b:	c4 c1 7c 11 94 32 41 	vmovups YMMWORD PTR [r10+rsi*1+0x141],ymm2
  214b72:	01 00 00 
  214b75:	c4 c1 7c 11 9c 32 61 	vmovups YMMWORD PTR [r10+rsi*1+0x161],ymm3
  214b7c:	01 00 00 
    for (source) |s, i|
  214b7f:	c5 fd 10 44 33 a0    	vmovupd ymm0,YMMWORD PTR [rbx+rsi*1-0x60]
  214b85:	c5 fc 10 4c 33 c0    	vmovups ymm1,YMMWORD PTR [rbx+rsi*1-0x40]
  214b8b:	c5 fd 10 54 33 e0    	vmovupd ymm2,YMMWORD PTR [rbx+rsi*1-0x20]
  214b91:	c5 fd 10 1c 33       	vmovupd ymm3,YMMWORD PTR [rbx+rsi*1]
        dest[i] = s;
  214b96:	c4 c1 7d 11 84 32 81 	vmovupd YMMWORD PTR [r10+rsi*1+0x181],ymm0
  214b9d:	01 00 00 
  214ba0:	c4 c1 7c 11 8c 32 a1 	vmovups YMMWORD PTR [r10+rsi*1+0x1a1],ymm1
  214ba7:	01 00 00 
  214baa:	c4 c1 7d 11 94 32 c1 	vmovupd YMMWORD PTR [r10+rsi*1+0x1c1],ymm2
  214bb1:	01 00 00 
  214bb4:	c4 c1 7d 11 9c 32 e1 	vmovupd YMMWORD PTR [r10+rsi*1+0x1e1],ymm3
  214bbb:	01 00 00 
  214bbe:	48 81 c6 00 02 00 00 	add    rsi,0x200
  214bc5:	48 83 c5 04          	add    rbp,0x4
  214bc9:	0f 85 db fe ff ff    	jne    214aaa <Benchmark_report+0x1b8a>
  214bcf:	48 85 d2             	test   rdx,rdx
  214bd2:	74 4a                	je     214c1e <Benchmark_report+0x1cfe>
  214bd4:	48 f7 da             	neg    rdx
  214bd7:	48 89 f1             	mov    rcx,rsi
  214bda:	48 83 c9 01          	or     rcx,0x1
    for (source) |s, i|
  214bde:	c4 c1 7d 10 04 0e    	vmovupd ymm0,YMMWORD PTR [r14+rcx*1]
  214be4:	c4 c1 7c 10 4c 0e 20 	vmovups ymm1,YMMWORD PTR [r14+rcx*1+0x20]
  214beb:	c4 c1 7d 10 54 0e 40 	vmovupd ymm2,YMMWORD PTR [r14+rcx*1+0x40]
  214bf2:	c4 c1 7d 10 5c 0e 60 	vmovupd ymm3,YMMWORD PTR [r14+rcx*1+0x60]
        dest[i] = s;
  214bf9:	c4 c1 7d 11 04 0a    	vmovupd YMMWORD PTR [r10+rcx*1],ymm0
  214bff:	c4 c1 7c 11 4c 0a 20 	vmovups YMMWORD PTR [r10+rcx*1+0x20],ymm1
  214c06:	c4 c1 7d 11 54 0a 40 	vmovupd YMMWORD PTR [r10+rcx*1+0x40],ymm2
  214c0d:	c4 c1 7d 11 5c 0a 60 	vmovupd YMMWORD PTR [r10+rcx*1+0x60],ymm3
  214c14:	48 83 ee 80          	sub    rsi,0xffffffffffffff80
  214c18:	48 83 c2 01          	add    rdx,0x1
  214c1c:	75 b9                	jne    214bd7 <Benchmark_report+0x1cb7>
    context.remaining = context.remaining[bytes.len..];
  214c1e:	4c 89 fa             	mov    rdx,r15
  214c21:	4c 39 64 24 10       	cmp    QWORD PTR [rsp+0x10],r12
    for (source) |s, i|
  214c26:	0f 84 81 f4 ff ff    	je     2140ad <Benchmark_report+0x118d>
  214c2c:	49 83 cc 01          	or     r12,0x1
  214c30:	e9 38 f4 ff ff       	jmp    21406d <Benchmark_report+0x114d>
  214c35:	48 83 c8 01          	or     rax,0x1
  214c39:	e9 29 f3 ff ff       	jmp    213f67 <Benchmark_report+0x1047>
  214c3e:	31 c9                	xor    ecx,ecx
  214c40:	41 b9 02 00 00 00    	mov    r9d,0x2
            if (printed >= precision) {
  214c46:	84 c9                	test   cl,cl
  214c48:	0f 84 40 f9 ff ff    	je     21458e <Benchmark_report+0x166e>
  214c4e:	31 c0                	xor    eax,eax
  214c50:	4d 89 d6             	mov    r14,r10
                    try formatType(args[next_arg], fmt[s..i], context, Errors, output);
  214c53:	66 85 c0             	test   ax,ax
  214c56:	0f 85 36 e5 ff ff    	jne    213192 <Benchmark_report+0x272>
  214c5c:	e9 95 ea ff ff       	jmp    2136f6 <Benchmark_report+0x7d6>
  214c61:	4c 89 f0             	mov    rax,r14
  214c64:	48 83 e0 80          	and    rax,0xffffffffffffff80
  214c68:	48 8d 48 80          	lea    rcx,[rax-0x80]
  214c6c:	48 89 cd             	mov    rbp,rcx
  214c6f:	48 c1 ed 07          	shr    rbp,0x7
  214c73:	8d 55 01             	lea    edx,[rbp+0x1]
  214c76:	83 e2 03             	and    edx,0x3
  214c79:	48 81 f9 80 01 00 00 	cmp    rcx,0x180
  214c80:	73 45                	jae    214cc7 <Benchmark_report+0x1da7>
  214c82:	31 ed                	xor    ebp,ebp
  214c84:	48 85 d2             	test   rdx,rdx
  214c87:	0f 85 8b 01 00 00    	jne    214e18 <Benchmark_report+0x1ef8>
  214c8d:	e9 cc 01 00 00       	jmp    214e5e <Benchmark_report+0x1f3e>
  214c92:	4d 89 f7             	mov    r15,r14
  214c95:	49 83 e7 80          	and    r15,0xffffffffffffff80
  214c99:	49 8d 5f 80          	lea    rbx,[r15-0x80]
  214c9d:	48 89 da             	mov    rdx,rbx
  214ca0:	48 c1 ea 07          	shr    rdx,0x7
  214ca4:	8d 6a 01             	lea    ebp,[rdx+0x1]
  214ca7:	83 e5 03             	and    ebp,0x3
  214caa:	48 81 fb 80 01 00 00 	cmp    rbx,0x180
  214cb1:	0f 83 c9 01 00 00    	jae    214e80 <Benchmark_report+0x1f60>
  214cb7:	31 d2                	xor    edx,edx
  214cb9:	48 85 ed             	test   rbp,rbp
  214cbc:	0f 85 fc 02 00 00    	jne    214fbe <Benchmark_report+0x209e>
  214cc2:	e9 3d 03 00 00       	jmp    215004 <Benchmark_report+0x20e4>
  214cc7:	4c 89 db             	mov    rbx,r11
  214cca:	48 f7 d3             	not    rbx
  214ccd:	4c 89 c1             	mov    rcx,r8
  214cd0:	48 f7 d1             	not    rcx
  214cd3:	48 39 cb             	cmp    rbx,rcx
  214cd6:	48 0f 47 cb          	cmova  rcx,rbx
  214cda:	bb e0 01 00 00       	mov    ebx,0x1e0
  214cdf:	48 29 cb             	sub    rbx,rcx
  214ce2:	4c 01 eb             	add    rbx,r13
  214ce5:	48 8d 4a ff          	lea    rcx,[rdx-0x1]
  214ce9:	48 29 e9             	sub    rcx,rbp
  214cec:	31 ed                	xor    ebp,ebp
  214cee:	c5 fc 10 84 2b 20 fe 	vmovups ymm0,YMMWORD PTR [rbx+rbp*1-0x1e0]
  214cf5:	ff ff 
  214cf7:	c5 fc 10 8c 2b 40 fe 	vmovups ymm1,YMMWORD PTR [rbx+rbp*1-0x1c0]
  214cfe:	ff ff 
  214d00:	c5 fc 10 94 2b 60 fe 	vmovups ymm2,YMMWORD PTR [rbx+rbp*1-0x1a0]
  214d07:	ff ff 
  214d09:	c5 fc 10 9c 2b 80 fe 	vmovups ymm3,YMMWORD PTR [rbx+rbp*1-0x180]
  214d10:	ff ff 
        dest[i] = s;
  214d12:	c4 c1 7c 11 44 2a 01 	vmovups YMMWORD PTR [r10+rbp*1+0x1],ymm0
  214d19:	c4 c1 7c 11 4c 2a 21 	vmovups YMMWORD PTR [r10+rbp*1+0x21],ymm1
  214d20:	c4 c1 7c 11 54 2a 41 	vmovups YMMWORD PTR [r10+rbp*1+0x41],ymm2
  214d27:	c4 c1 7c 11 5c 2a 61 	vmovups YMMWORD PTR [r10+rbp*1+0x61],ymm3
    for (source) |s, i|
  214d2e:	c5 fc 10 84 2b a0 fe 	vmovups ymm0,YMMWORD PTR [rbx+rbp*1-0x160]
  214d35:	ff ff 
  214d37:	c5 fc 10 8c 2b c0 fe 	vmovups ymm1,YMMWORD PTR [rbx+rbp*1-0x140]
  214d3e:	ff ff 
  214d40:	c5 fc 10 94 2b e0 fe 	vmovups ymm2,YMMWORD PTR [rbx+rbp*1-0x120]
  214d47:	ff ff 
  214d49:	c5 fc 10 9c 2b 00 ff 	vmovups ymm3,YMMWORD PTR [rbx+rbp*1-0x100]
  214d50:	ff ff 
        dest[i] = s;
  214d52:	c4 c1 7c 11 84 2a 81 	vmovups YMMWORD PTR [r10+rbp*1+0x81],ymm0
  214d59:	00 00 00 
  214d5c:	c4 c1 7c 11 8c 2a a1 	vmovups YMMWORD PTR [r10+rbp*1+0xa1],ymm1
  214d63:	00 00 00 
  214d66:	c4 c1 7c 11 94 2a c1 	vmovups YMMWORD PTR [r10+rbp*1+0xc1],ymm2
  214d6d:	00 00 00 
  214d70:	c4 c1 7c 11 9c 2a e1 	vmovups YMMWORD PTR [r10+rbp*1+0xe1],ymm3
  214d77:	00 00 00 
    for (source) |s, i|
  214d7a:	c5 fc 10 84 2b 20 ff 	vmovups ymm0,YMMWORD PTR [rbx+rbp*1-0xe0]
  214d81:	ff ff 
  214d83:	c5 fc 10 8c 2b 40 ff 	vmovups ymm1,YMMWORD PTR [rbx+rbp*1-0xc0]
  214d8a:	ff ff 
  214d8c:	c5 fc 10 94 2b 60 ff 	vmovups ymm2,YMMWORD PTR [rbx+rbp*1-0xa0]
  214d93:	ff ff 
  214d95:	c5 fc 10 5c 2b 80    	vmovups ymm3,YMMWORD PTR [rbx+rbp*1-0x80]
        dest[i] = s;
  214d9b:	c4 c1 7c 11 84 2a 01 	vmovups YMMWORD PTR [r10+rbp*1+0x101],ymm0
  214da2:	01 00 00 
  214da5:	c4 c1 7c 11 8c 2a 21 	vmovups YMMWORD PTR [r10+rbp*1+0x121],ymm1
  214dac:	01 00 00 
  214daf:	c4 c1 7c 11 94 2a 41 	vmovups YMMWORD PTR [r10+rbp*1+0x141],ymm2
  214db6:	01 00 00 
  214db9:	c4 c1 7c 11 9c 2a 61 	vmovups YMMWORD PTR [r10+rbp*1+0x161],ymm3
  214dc0:	01 00 00 
    for (source) |s, i|
  214dc3:	c5 fd 10 44 2b a0    	vmovupd ymm0,YMMWORD PTR [rbx+rbp*1-0x60]
  214dc9:	c5 fc 10 4c 2b c0    	vmovups ymm1,YMMWORD PTR [rbx+rbp*1-0x40]
  214dcf:	c5 fd 10 54 2b e0    	vmovupd ymm2,YMMWORD PTR [rbx+rbp*1-0x20]
  214dd5:	c5 fd 10 1c 2b       	vmovupd ymm3,YMMWORD PTR [rbx+rbp*1]
        dest[i] = s;
  214dda:	c4 c1 7d 11 84 2a 81 	vmovupd YMMWORD PTR [r10+rbp*1+0x181],ymm0
  214de1:	01 00 00 
  214de4:	c4 c1 7c 11 8c 2a a1 	vmovups YMMWORD PTR [r10+rbp*1+0x1a1],ymm1
  214deb:	01 00 00 
  214dee:	c4 c1 7d 11 94 2a c1 	vmovupd YMMWORD PTR [r10+rbp*1+0x1c1],ymm2
  214df5:	01 00 00 
  214df8:	c4 c1 7d 11 9c 2a e1 	vmovupd YMMWORD PTR [r10+rbp*1+0x1e1],ymm3
  214dff:	01 00 00 
  214e02:	48 81 c5 00 02 00 00 	add    rbp,0x200
  214e09:	48 83 c1 04          	add    rcx,0x4
  214e0d:	0f 85 db fe ff ff    	jne    214cee <Benchmark_report+0x1dce>
  214e13:	48 85 d2             	test   rdx,rdx
  214e16:	74 46                	je     214e5e <Benchmark_report+0x1f3e>
  214e18:	48 f7 da             	neg    rdx
  214e1b:	48 89 e9             	mov    rcx,rbp
  214e1e:	48 83 c9 01          	or     rcx,0x1
    for (source) |s, i|
  214e22:	c5 fd 10 04 0e       	vmovupd ymm0,YMMWORD PTR [rsi+rcx*1]
  214e27:	c5 fc 10 4c 0e 20    	vmovups ymm1,YMMWORD PTR [rsi+rcx*1+0x20]
  214e2d:	c5 fd 10 54 0e 40    	vmovupd ymm2,YMMWORD PTR [rsi+rcx*1+0x40]
  214e33:	c5 fd 10 5c 0e 60    	vmovupd ymm3,YMMWORD PTR [rsi+rcx*1+0x60]
        dest[i] = s;
  214e39:	c4 c1 7d 11 04 0a    	vmovupd YMMWORD PTR [r10+rcx*1],ymm0
  214e3f:	c4 c1 7c 11 4c 0a 20 	vmovups YMMWORD PTR [r10+rcx*1+0x20],ymm1
  214e46:	c4 c1 7d 11 54 0a 40 	vmovupd YMMWORD PTR [r10+rcx*1+0x40],ymm2
  214e4d:	c4 c1 7d 11 5c 0a 60 	vmovupd YMMWORD PTR [r10+rcx*1+0x60],ymm3
  214e54:	48 83 ed 80          	sub    rbp,0xffffffffffffff80
  214e58:	48 83 c2 01          	add    rdx,0x1
  214e5c:	75 bd                	jne    214e1b <Benchmark_report+0x1efb>
  214e5e:	49 39 c6             	cmp    r14,rax
    for (source) |s, i|
  214e61:	0f 85 b2 01 00 00    	jne    215019 <Benchmark_report+0x20f9>
    context.remaining = context.remaining[bytes.len..];
  214e67:	4d 01 e2             	add    r10,r12
  214e6a:	4c 29 e7             	sub    rdi,r12
  214e6d:	31 c0                	xor    eax,eax
  214e6f:	4d 89 d6             	mov    r14,r10
                    try formatType(args[next_arg], fmt[s..i], context, Errors, output);
  214e72:	66 85 c0             	test   ax,ax
  214e75:	0f 85 17 e3 ff ff    	jne    213192 <Benchmark_report+0x272>
  214e7b:	e9 76 e8 ff ff       	jmp    2136f6 <Benchmark_report+0x7d6>
  214e80:	bb e0 01 00 00       	mov    ebx,0x1e0
  214e85:	48 29 cb             	sub    rbx,rcx
  214e88:	4c 01 eb             	add    rbx,r13
  214e8b:	48 8d 4d ff          	lea    rcx,[rbp-0x1]
  214e8f:	48 29 d1             	sub    rcx,rdx
  214e92:	31 d2                	xor    edx,edx
  214e94:	c5 fc 10 84 13 20 fe 	vmovups ymm0,YMMWORD PTR [rbx+rdx*1-0x1e0]
  214e9b:	ff ff 
  214e9d:	c5 fc 10 8c 13 40 fe 	vmovups ymm1,YMMWORD PTR [rbx+rdx*1-0x1c0]
  214ea4:	ff ff 
  214ea6:	c5 fc 10 94 13 60 fe 	vmovups ymm2,YMMWORD PTR [rbx+rdx*1-0x1a0]
  214ead:	ff ff 
  214eaf:	c5 fc 10 9c 13 80 fe 	vmovups ymm3,YMMWORD PTR [rbx+rdx*1-0x180]
  214eb6:	ff ff 
        dest[i] = s;
  214eb8:	c4 c1 7c 11 44 12 01 	vmovups YMMWORD PTR [r10+rdx*1+0x1],ymm0
  214ebf:	c4 c1 7c 11 4c 12 21 	vmovups YMMWORD PTR [r10+rdx*1+0x21],ymm1
  214ec6:	c4 c1 7c 11 54 12 41 	vmovups YMMWORD PTR [r10+rdx*1+0x41],ymm2
  214ecd:	c4 c1 7c 11 5c 12 61 	vmovups YMMWORD PTR [r10+rdx*1+0x61],ymm3
    for (source) |s, i|
  214ed4:	c5 fc 10 84 13 a0 fe 	vmovups ymm0,YMMWORD PTR [rbx+rdx*1-0x160]
  214edb:	ff ff 
  214edd:	c5 fc 10 8c 13 c0 fe 	vmovups ymm1,YMMWORD PTR [rbx+rdx*1-0x140]
  214ee4:	ff ff 
  214ee6:	c5 fc 10 94 13 e0 fe 	vmovups ymm2,YMMWORD PTR [rbx+rdx*1-0x120]
  214eed:	ff ff 
  214eef:	c5 fc 10 9c 13 00 ff 	vmovups ymm3,YMMWORD PTR [rbx+rdx*1-0x100]
  214ef6:	ff ff 
        dest[i] = s;
  214ef8:	c4 c1 7c 11 84 12 81 	vmovups YMMWORD PTR [r10+rdx*1+0x81],ymm0
  214eff:	00 00 00 
  214f02:	c4 c1 7c 11 8c 12 a1 	vmovups YMMWORD PTR [r10+rdx*1+0xa1],ymm1
  214f09:	00 00 00 
  214f0c:	c4 c1 7c 11 94 12 c1 	vmovups YMMWORD PTR [r10+rdx*1+0xc1],ymm2
  214f13:	00 00 00 
  214f16:	c4 c1 7c 11 9c 12 e1 	vmovups YMMWORD PTR [r10+rdx*1+0xe1],ymm3
  214f1d:	00 00 00 
    for (source) |s, i|
  214f20:	c5 fc 10 84 13 20 ff 	vmovups ymm0,YMMWORD PTR [rbx+rdx*1-0xe0]
  214f27:	ff ff 
  214f29:	c5 fc 10 8c 13 40 ff 	vmovups ymm1,YMMWORD PTR [rbx+rdx*1-0xc0]
  214f30:	ff ff 
  214f32:	c5 fc 10 94 13 60 ff 	vmovups ymm2,YMMWORD PTR [rbx+rdx*1-0xa0]
  214f39:	ff ff 
  214f3b:	c5 fc 10 5c 13 80    	vmovups ymm3,YMMWORD PTR [rbx+rdx*1-0x80]
        dest[i] = s;
  214f41:	c4 c1 7c 11 84 12 01 	vmovups YMMWORD PTR [r10+rdx*1+0x101],ymm0
  214f48:	01 00 00 
  214f4b:	c4 c1 7c 11 8c 12 21 	vmovups YMMWORD PTR [r10+rdx*1+0x121],ymm1
  214f52:	01 00 00 
  214f55:	c4 c1 7c 11 94 12 41 	vmovups YMMWORD PTR [r10+rdx*1+0x141],ymm2
  214f5c:	01 00 00 
  214f5f:	c4 c1 7c 11 9c 12 61 	vmovups YMMWORD PTR [r10+rdx*1+0x161],ymm3
  214f66:	01 00 00 
    for (source) |s, i|
  214f69:	c5 fd 10 44 13 a0    	vmovupd ymm0,YMMWORD PTR [rbx+rdx*1-0x60]
  214f6f:	c5 fc 10 4c 13 c0    	vmovups ymm1,YMMWORD PTR [rbx+rdx*1-0x40]
  214f75:	c5 fd 10 54 13 e0    	vmovupd ymm2,YMMWORD PTR [rbx+rdx*1-0x20]
  214f7b:	c5 fd 10 1c 13       	vmovupd ymm3,YMMWORD PTR [rbx+rdx*1]
        dest[i] = s;
  214f80:	c4 c1 7d 11 84 12 81 	vmovupd YMMWORD PTR [r10+rdx*1+0x181],ymm0
  214f87:	01 00 00 
  214f8a:	c4 c1 7c 11 8c 12 a1 	vmovups YMMWORD PTR [r10+rdx*1+0x1a1],ymm1
  214f91:	01 00 00 
  214f94:	c4 c1 7d 11 94 12 c1 	vmovupd YMMWORD PTR [r10+rdx*1+0x1c1],ymm2
  214f9b:	01 00 00 
  214f9e:	c4 c1 7d 11 9c 12 e1 	vmovupd YMMWORD PTR [r10+rdx*1+0x1e1],ymm3
  214fa5:	01 00 00 
  214fa8:	48 81 c2 00 02 00 00 	add    rdx,0x200
  214faf:	48 83 c1 04          	add    rcx,0x4
  214fb3:	0f 85 db fe ff ff    	jne    214e94 <Benchmark_report+0x1f74>
  214fb9:	48 85 ed             	test   rbp,rbp
  214fbc:	74 46                	je     215004 <Benchmark_report+0x20e4>
  214fbe:	48 f7 dd             	neg    rbp
  214fc1:	48 89 d1             	mov    rcx,rdx
  214fc4:	48 83 c9 01          	or     rcx,0x1
    for (source) |s, i|
  214fc8:	c5 fd 10 04 0e       	vmovupd ymm0,YMMWORD PTR [rsi+rcx*1]
  214fcd:	c5 fc 10 4c 0e 20    	vmovups ymm1,YMMWORD PTR [rsi+rcx*1+0x20]
  214fd3:	c5 fd 10 54 0e 40    	vmovupd ymm2,YMMWORD PTR [rsi+rcx*1+0x40]
  214fd9:	c5 fd 10 5c 0e 60    	vmovupd ymm3,YMMWORD PTR [rsi+rcx*1+0x60]
        dest[i] = s;
  214fdf:	c4 c1 7d 11 04 0a    	vmovupd YMMWORD PTR [r10+rcx*1],ymm0
  214fe5:	c4 c1 7c 11 4c 0a 20 	vmovups YMMWORD PTR [r10+rcx*1+0x20],ymm1
  214fec:	c4 c1 7d 11 54 0a 40 	vmovupd YMMWORD PTR [r10+rcx*1+0x40],ymm2
  214ff3:	c4 c1 7d 11 5c 0a 60 	vmovupd YMMWORD PTR [r10+rcx*1+0x60],ymm3
  214ffa:	48 83 ea 80          	sub    rdx,0xffffffffffffff80
  214ffe:	48 83 c5 01          	add    rbp,0x1
  215002:	75 bd                	jne    214fc1 <Benchmark_report+0x20a1>
    context.remaining = context.remaining[bytes.len..];
  215004:	4c 89 e1             	mov    rcx,r12
  215007:	4d 39 fe             	cmp    r14,r15
    for (source) |s, i|
  21500a:	0f 84 2a f8 ff ff    	je     21483a <Benchmark_report+0x191a>
  215010:	49 83 cf 01          	or     r15,0x1
  215014:	e9 e1 f7 ff ff       	jmp    2147fa <Benchmark_report+0x18da>
  215019:	48 83 c8 01          	or     rax,0x1
  21501d:	e9 d3 f6 ff ff       	jmp    2146f5 <Benchmark_report+0x17d5>
  215022:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  215029:	1f 84 00 00 00 00 00 

0000000000215030 <warn.37>:
pub fn warn(comptime fmt: []const u8, args: ...) void {
  215030:	55                   	push   rbp
  215031:	41 57                	push   r15
  215033:	41 56                	push   r14
  215035:	41 55                	push   r13
  215037:	41 54                	push   r12
  215039:	53                   	push   rbx
  21503a:	48 83 ec 58          	sub    rsp,0x58
  21503e:	48 89 d3             	mov    rbx,rdx
  215041:	49 89 f4             	mov    r12,rsi
  215044:	49 89 fe             	mov    r14,rdi
  215047:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  21504e:	00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  215050:	b0 01                	mov    al,0x1
  215052:	86 05 b8 bf 03 00    	xchg   BYTE PTR [rip+0x3bfb8],al        # 251010 <stderr_mutex>
  215058:	84 c0                	test   al,al
  21505a:	75 f4                	jne    215050 <warn.37+0x20>
    if (stderr_stream) |st| {
  21505c:	4c 8b 3d a5 bf 03 00 	mov    r15,QWORD PTR [rip+0x3bfa5]        # 251008 <stderr_stream>
  215063:	4d 85 ff             	test   r15,r15
  215066:	74 09                	je     215071 <warn.37+0x41>
  215068:	4c 8b 2d d1 6f 03 00 	mov    r13,QWORD PTR [rip+0x36fd1]        # 24c040 <stderr_file_out_stream+0x8>
  21506f:	eb 34                	jmp    2150a5 <warn.37+0x75>
        stderr_file = try io.getStdErr();
  215071:	48 8d 05 b8 6f 03 00 	lea    rax,[rip+0x36fb8]        # 24c030 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  215078:	48 89 05 b9 6f 03 00 	mov    QWORD PTR [rip+0x36fb9],rax        # 24c038 <stderr_file_out_stream>
  21507f:	4c 8d 2d 1a 9e 00 00 	lea    r13,[rip+0x9e1a]        # 21eea0 <FileOutStream_writeFn>
  215086:	4c 89 2d b3 6f 03 00 	mov    QWORD PTR [rip+0x36fb3],r13        # 24c040 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  21508d:	c7 05 99 6f 03 00 02 	mov    DWORD PTR [rip+0x36f99],0x2        # 24c030 <stderr_file>
  215094:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  215097:	4c 8d 3d a2 6f 03 00 	lea    r15,[rip+0x36fa2]        # 24c040 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  21509e:	4c 89 3d 63 bf 03 00 	mov    QWORD PTR [rip+0x3bf63],r15        # 251008 <stderr_stream>
                        try output(context, fmt[start_index..i]);
  2150a5:	48 8d 35 14 ad 03 00 	lea    rsi,[rip+0x3ad14]        # 24fdc0 <__unnamed_30>
  2150ac:	4c 89 ff             	mov    rdi,r15
  2150af:	41 ff d5             	call   r13
  2150b2:	66 85 c0             	test   ax,ax
  2150b5:	0f 85 b2 02 00 00    	jne    21536d <warn.37+0x33d>
    var buf: [max_int_digits - 1]u8 = undefined;
  2150bb:	c5 fc 10 05 2c 46 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffff462c]        # 2096ef <__unnamed_28+0x1f>
  2150c2:	ff 
  2150c3:	c5 fc 11 44 24 2f    	vmovups YMMWORD PTR [rsp+0x2f],ymm0
  2150c9:	c5 fc 10 05 ff 45 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffff45ff]        # 2096d0 <__unnamed_28>
  2150d0:	ff 
  2150d1:	c5 fc 11 44 24 10    	vmovups YMMWORD PTR [rsp+0x10],ymm0
        const digit = a % base;
  2150d7:	48 bd cd cc cc cc cc 	movabs rbp,0xcccccccccccccccd
  2150de:	cc cc cc 
  2150e1:	4c 89 f2             	mov    rdx,r14
  2150e4:	c4 e2 fb f6 cd       	mulx   rcx,rax,rbp
  2150e9:	c1 e9 02             	shr    ecx,0x2
  2150ec:	81 e1 fe ff ff 3f    	and    ecx,0x3ffffffe
  2150f2:	8d 0c 89             	lea    ecx,[rcx+rcx*4]
  2150f5:	44 89 f0             	mov    eax,r14d
  2150f8:	29 c8                	sub    eax,ecx
        0...9 => digit + '0',
  2150fa:	b1 30                	mov    cl,0x30
  2150fc:	3c 0a                	cmp    al,0xa
  2150fe:	72 02                	jb     215102 <warn.37+0xd2>
  215100:	b1 57                	mov    cl,0x57
  215102:	48 8d 54 24 4f       	lea    rdx,[rsp+0x4f]
  215107:	00 c1                	add    cl,al
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  215109:	88 4c 24 4f          	mov    BYTE PTR [rsp+0x4f],cl
        if (a == 0) break;
  21510d:	49 83 fe 0a          	cmp    r14,0xa
  215111:	73 0a                	jae    21511d <warn.37+0xed>
  215113:	b8 40 00 00 00       	mov    eax,0x40
  215118:	48 89 d1             	mov    rcx,rdx
  21511b:	eb 5b                	jmp    215178 <warn.37+0x148>
  21511d:	48 89 df             	mov    rdi,rbx
  215120:	b8 40 00 00 00       	mov    eax,0x40
  215125:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21512c:	00 00 00 00 
        a /= base;
  215130:	4c 89 f2             	mov    rdx,r14
  215133:	c4 e2 f3 f6 d5       	mulx   rdx,rcx,rbp
  215138:	48 c1 ea 03          	shr    rdx,0x3
        const digit = a % base;
  21513c:	c4 e2 f3 f6 f5       	mulx   rsi,rcx,rbp
  215141:	c1 ee 02             	shr    esi,0x2
  215144:	81 e6 fe ff ff 3f    	and    esi,0x3ffffffe
  21514a:	8d 34 b6             	lea    esi,[rsi+rsi*4]
  21514d:	89 d1                	mov    ecx,edx
  21514f:	29 f1                	sub    ecx,esi
        0...9 => digit + '0',
  215151:	b3 30                	mov    bl,0x30
  215153:	80 f9 0a             	cmp    cl,0xa
  215156:	72 02                	jb     21515a <warn.37+0x12a>
  215158:	b3 57                	mov    bl,0x57
  21515a:	00 cb                	add    bl,cl
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  21515c:	88 5c 04 0e          	mov    BYTE PTR [rsp+rax*1+0xe],bl
        if (a == 0) break;
  215160:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  215164:	49 83 fe 63          	cmp    r14,0x63
  215168:	49 89 d6             	mov    r14,rdx
  21516b:	77 c3                	ja     215130 <warn.37+0x100>
        const padded_buf = buf[index - padding ..];
  21516d:	48 8d 0c 04          	lea    rcx,[rsp+rax*1]
  215171:	48 83 c1 0f          	add    rcx,0xf
  215175:	48 89 fb             	mov    rbx,rdi
  215178:	ba 41 00 00 00       	mov    edx,0x41
  21517d:	48 29 c2             	sub    rdx,rax
  215180:	48 89 0c 24          	mov    QWORD PTR [rsp],rcx
  215184:	48 89 54 24 08       	mov    QWORD PTR [rsp+0x8],rdx
  215189:	48 89 e6             	mov    rsi,rsp
        return output(context, padded_buf);
  21518c:	4c 89 ff             	mov    rdi,r15
  21518f:	c5 f8 77             	vzeroupper 
  215192:	41 ff d5             	call   r13
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  215195:	66 85 c0             	test   ax,ax
  215198:	0f 85 cf 01 00 00    	jne    21536d <warn.37+0x33d>
                        try output(context, fmt[start_index..i]);
  21519e:	48 8d 35 2b ac 03 00 	lea    rsi,[rip+0x3ac2b]        # 24fdd0 <__unnamed_31>
  2151a5:	4c 89 ff             	mov    rdi,r15
  2151a8:	41 ff d5             	call   r13
  2151ab:	66 85 c0             	test   ax,ax
  2151ae:	0f 85 b9 01 00 00    	jne    21536d <warn.37+0x33d>
    var buf: [max_int_digits - 1]u8 = undefined;
  2151b4:	c5 fc 10 05 33 45 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffff4533]        # 2096ef <__unnamed_28+0x1f>
  2151bb:	ff 
  2151bc:	c5 fc 11 44 24 2f    	vmovups YMMWORD PTR [rsp+0x2f],ymm0
  2151c2:	c5 fc 10 05 06 45 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffff4506]        # 2096d0 <__unnamed_28>
  2151c9:	ff 
  2151ca:	c5 fc 11 44 24 10    	vmovups YMMWORD PTR [rsp+0x10],ymm0
        const digit = a % base;
  2151d0:	4c 89 e2             	mov    rdx,r12
  2151d3:	c4 e2 fb f6 cd       	mulx   rcx,rax,rbp
  2151d8:	c1 e9 02             	shr    ecx,0x2
  2151db:	81 e1 fe ff ff 3f    	and    ecx,0x3ffffffe
  2151e1:	8d 0c 89             	lea    ecx,[rcx+rcx*4]
  2151e4:	44 89 e0             	mov    eax,r12d
  2151e7:	29 c8                	sub    eax,ecx
        0...9 => digit + '0',
  2151e9:	b1 30                	mov    cl,0x30
  2151eb:	3c 0a                	cmp    al,0xa
  2151ed:	72 02                	jb     2151f1 <warn.37+0x1c1>
  2151ef:	b1 57                	mov    cl,0x57
  2151f1:	00 c1                	add    cl,al
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  2151f3:	88 4c 24 4f          	mov    BYTE PTR [rsp+0x4f],cl
        if (a == 0) break;
  2151f7:	49 83 fc 0a          	cmp    r12,0xa
  2151fb:	73 0c                	jae    215209 <warn.37+0x1d9>
  2151fd:	b8 40 00 00 00       	mov    eax,0x40
  215202:	48 8d 4c 24 4f       	lea    rcx,[rsp+0x4f]
  215207:	eb 5f                	jmp    215268 <warn.37+0x238>
  215209:	48 89 df             	mov    rdi,rbx
  21520c:	b8 40 00 00 00       	mov    eax,0x40
  215211:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  215218:	0f 1f 84 00 00 00 00 
  21521f:	00 
        a /= base;
  215220:	4c 89 e2             	mov    rdx,r12
  215223:	c4 e2 f3 f6 d5       	mulx   rdx,rcx,rbp
  215228:	48 c1 ea 03          	shr    rdx,0x3
        const digit = a % base;
  21522c:	c4 e2 f3 f6 f5       	mulx   rsi,rcx,rbp
  215231:	c1 ee 02             	shr    esi,0x2
  215234:	81 e6 fe ff ff 3f    	and    esi,0x3ffffffe
  21523a:	8d 34 b6             	lea    esi,[rsi+rsi*4]
  21523d:	89 d1                	mov    ecx,edx
  21523f:	29 f1                	sub    ecx,esi
        0...9 => digit + '0',
  215241:	b3 30                	mov    bl,0x30
  215243:	80 f9 0a             	cmp    cl,0xa
  215246:	72 02                	jb     21524a <warn.37+0x21a>
  215248:	b3 57                	mov    bl,0x57
  21524a:	00 cb                	add    bl,cl
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  21524c:	88 5c 04 0e          	mov    BYTE PTR [rsp+rax*1+0xe],bl
        if (a == 0) break;
  215250:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  215254:	49 83 fc 63          	cmp    r12,0x63
  215258:	49 89 d4             	mov    r12,rdx
  21525b:	77 c3                	ja     215220 <warn.37+0x1f0>
        const padded_buf = buf[index - padding ..];
  21525d:	48 8d 0c 04          	lea    rcx,[rsp+rax*1]
  215261:	48 83 c1 0f          	add    rcx,0xf
  215265:	48 89 fb             	mov    rbx,rdi
  215268:	ba 41 00 00 00       	mov    edx,0x41
  21526d:	48 29 c2             	sub    rdx,rax
  215270:	48 89 0c 24          	mov    QWORD PTR [rsp],rcx
  215274:	48 89 54 24 08       	mov    QWORD PTR [rsp+0x8],rdx
  215279:	48 89 e6             	mov    rsi,rsp
        return output(context, padded_buf);
  21527c:	4c 89 ff             	mov    rdi,r15
  21527f:	c5 f8 77             	vzeroupper 
  215282:	41 ff d5             	call   r13
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  215285:	66 85 c0             	test   ax,ax
  215288:	0f 85 df 00 00 00    	jne    21536d <warn.37+0x33d>
                        try output(context, fmt[start_index..i]);
  21528e:	48 8d 35 4b ab 03 00 	lea    rsi,[rip+0x3ab4b]        # 24fde0 <__unnamed_32>
  215295:	4c 89 ff             	mov    rdi,r15
  215298:	41 ff d5             	call   r13
  21529b:	66 85 c0             	test   ax,ax
  21529e:	0f 85 c9 00 00 00    	jne    21536d <warn.37+0x33d>
    var buf: [max_int_digits - 1]u8 = undefined;
  2152a4:	c5 fc 10 05 43 44 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffff4443]        # 2096ef <__unnamed_28+0x1f>
  2152ab:	ff 
  2152ac:	c5 fc 11 44 24 2f    	vmovups YMMWORD PTR [rsp+0x2f],ymm0
  2152b2:	c5 fc 10 05 16 44 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffff4416]        # 2096d0 <__unnamed_28>
  2152b9:	ff 
  2152ba:	c5 fc 11 44 24 10    	vmovups YMMWORD PTR [rsp+0x10],ymm0
        const digit = a % base;
  2152c0:	48 89 da             	mov    rdx,rbx
  2152c3:	c4 e2 fb f6 cd       	mulx   rcx,rax,rbp
  2152c8:	c1 e9 02             	shr    ecx,0x2
  2152cb:	81 e1 fe ff ff 3f    	and    ecx,0x3ffffffe
  2152d1:	8d 0c 89             	lea    ecx,[rcx+rcx*4]
  2152d4:	89 d8                	mov    eax,ebx
  2152d6:	29 c8                	sub    eax,ecx
        0...9 => digit + '0',
  2152d8:	b1 30                	mov    cl,0x30
  2152da:	3c 0a                	cmp    al,0xa
  2152dc:	72 02                	jb     2152e0 <warn.37+0x2b0>
  2152de:	b1 57                	mov    cl,0x57
  2152e0:	00 c1                	add    cl,al
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  2152e2:	88 4c 24 4f          	mov    BYTE PTR [rsp+0x4f],cl
        if (a == 0) break;
  2152e6:	48 83 fb 0a          	cmp    rbx,0xa
  2152ea:	48 8d 54 24 4f       	lea    rdx,[rsp+0x4f]
  2152ef:	b8 40 00 00 00       	mov    eax,0x40
  2152f4:	72 48                	jb     21533e <warn.37+0x30e>
  2152f6:	48 89 df             	mov    rdi,rbx
        a /= base;
  2152f9:	48 89 da             	mov    rdx,rbx
  2152fc:	c4 e2 f3 f6 d5       	mulx   rdx,rcx,rbp
  215301:	48 c1 ea 03          	shr    rdx,0x3
        const digit = a % base;
  215305:	c4 e2 f3 f6 f5       	mulx   rsi,rcx,rbp
  21530a:	c1 ee 02             	shr    esi,0x2
  21530d:	81 e6 fe ff ff 3f    	and    esi,0x3ffffffe
  215313:	8d 34 b6             	lea    esi,[rsi+rsi*4]
  215316:	89 d1                	mov    ecx,edx
  215318:	29 f1                	sub    ecx,esi
        0...9 => digit + '0',
  21531a:	b3 30                	mov    bl,0x30
  21531c:	80 f9 0a             	cmp    cl,0xa
  21531f:	72 02                	jb     215323 <warn.37+0x2f3>
  215321:	b3 57                	mov    bl,0x57
  215323:	00 cb                	add    bl,cl
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  215325:	88 5c 04 0e          	mov    BYTE PTR [rsp+rax*1+0xe],bl
        if (a == 0) break;
  215329:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  21532d:	48 83 ff 63          	cmp    rdi,0x63
  215331:	48 89 d3             	mov    rbx,rdx
  215334:	77 c0                	ja     2152f6 <warn.37+0x2c6>
        const padded_buf = buf[index - padding ..];
  215336:	48 8d 14 04          	lea    rdx,[rsp+rax*1]
  21533a:	48 83 c2 0f          	add    rdx,0xf
  21533e:	b9 41 00 00 00       	mov    ecx,0x41
  215343:	48 29 c1             	sub    rcx,rax
  215346:	48 89 14 24          	mov    QWORD PTR [rsp],rdx
  21534a:	48 89 4c 24 08       	mov    QWORD PTR [rsp+0x8],rcx
  21534f:	48 89 e6             	mov    rsi,rsp
        return output(context, padded_buf);
  215352:	4c 89 ff             	mov    rdi,r15
  215355:	c5 f8 77             	vzeroupper 
  215358:	41 ff d5             	call   r13
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  21535b:	66 85 c0             	test   ax,ax
  21535e:	75 0d                	jne    21536d <warn.37+0x33d>
        try output(context, fmt[start_index..]);
  215360:	48 8d 35 89 aa 03 00 	lea    rsi,[rip+0x3aa89]        # 24fdf0 <__unnamed_33>
  215367:	4c 89 ff             	mov    rdi,r15
  21536a:	41 ff d5             	call   r13
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  21536d:	31 c0                	xor    eax,eax
  21536f:	86 05 9b bc 03 00    	xchg   BYTE PTR [rip+0x3bc9b],al        # 251010 <stderr_mutex>
  215375:	3c 01                	cmp    al,0x1
    if (!ok) {
  215377:	75 0f                	jne    215388 <warn.37+0x358>
pub fn warn(comptime fmt: []const u8, args: ...) void {
  215379:	48 83 c4 58          	add    rsp,0x58
  21537d:	5b                   	pop    rbx
  21537e:	41 5c                	pop    r12
  215380:	41 5d                	pop    r13
  215382:	41 5e                	pop    r14
  215384:	41 5f                	pop    r15
  215386:	5d                   	pop    rbp
  215387:	c3                   	ret    
            @panic("assertion failure");
  215388:	48 8d 3d 01 aa 03 00 	lea    rdi,[rip+0x3aa01]        # 24fd90 <__unnamed_2>
  21538f:	e8 8c d3 ff ff       	call   212720 <panic>
  215394:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21539b:	00 00 00 00 00 

00000000002153a0 <Benchmark_leftJustified>:
        var buffer: [40]u8 = undefined;
  2153a0:	55                   	push   rbp
  2153a1:	41 57                	push   r15
  2153a3:	41 56                	push   r14
  2153a5:	41 55                	push   r13
  2153a7:	41 54                	push   r12
  2153a9:	53                   	push   rbx
  2153aa:	48 81 ec 88 00 00 00 	sub    rsp,0x88
  2153b1:	c5 fc 10 05 96 0b ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffff0b96]        # 205f4f <__unnamed_7>
  2153b8:	ff 
  2153b9:	c5 fc 11 44 24 10    	vmovups YMMWORD PTR [rsp+0x10],ymm0
  2153bf:	48 8b 05 a9 0b ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffff0ba9]        # 205f6f <__unnamed_7+0x20>
  2153c6:	48 89 44 24 30       	mov    QWORD PTR [rsp+0x30],rax
        dest[i] = s;
  2153cb:	c5 f8 28 05 cd b7 fe 	vmovaps xmm0,XMMWORD PTR [rip+0xfffffffffffeb7cd]        # 200ba0 <__unnamed_52+0x10>
  2153d2:	ff 
  2153d3:	c5 f8 29 44 24 10    	vmovaps XMMWORD PTR [rsp+0x10],xmm0
  2153d9:	c6 44 24 20 3a       	mov    BYTE PTR [rsp+0x20],0x3a
  2153de:	48 89 f8             	mov    rax,rdi
    var buf: [max_int_digits - 1]u8 = undefined;
  2153e1:	c5 fc 10 05 06 43 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffff4306]        # 2096ef <__unnamed_28+0x1f>
  2153e8:	ff 
  2153e9:	c5 fc 11 44 24 5f    	vmovups YMMWORD PTR [rsp+0x5f],ymm0
  2153ef:	c5 fc 10 05 d9 42 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffff42d9]        # 2096d0 <__unnamed_28>
  2153f6:	ff 
  2153f7:	c5 fc 11 44 24 40    	vmovups YMMWORD PTR [rsp+0x40],ymm0
        const digit = a % base;
  2153fd:	48 be cd cc cc cc cc 	movabs rsi,0xcccccccccccccccd
  215404:	cc cc cc 
  215407:	48 89 c2             	mov    rdx,rax
  21540a:	c4 e2 f3 f6 d6       	mulx   rdx,rcx,rsi
  21540f:	c1 ea 02             	shr    edx,0x2
  215412:	81 e2 fe ff ff 3f    	and    edx,0x3ffffffe
  215418:	8d 0c 92             	lea    ecx,[rdx+rdx*4]
  21541b:	89 c2                	mov    edx,eax
  21541d:	29 ca                	sub    edx,ecx
        0...9 => digit + '0',
  21541f:	b1 30                	mov    cl,0x30
  215421:	80 fa 0a             	cmp    dl,0xa
  215424:	72 02                	jb     215428 <Benchmark_leftJustified+0x88>
  215426:	b1 57                	mov    cl,0x57
  215428:	00 d1                	add    cl,dl
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  21542a:	88 4c 24 7f          	mov    BYTE PTR [rsp+0x7f],cl
  21542e:	bb 40 00 00 00       	mov    ebx,0x40
        if (a == 0) break;
  215433:	48 83 f8 0a          	cmp    rax,0xa
  215437:	72 46                	jb     21547f <Benchmark_leftJustified+0xdf>
  215439:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
        a /= base;
  215440:	48 89 c2             	mov    rdx,rax
  215443:	c4 e2 f3 f6 d6       	mulx   rdx,rcx,rsi
  215448:	48 c1 ea 03          	shr    rdx,0x3
        const digit = a % base;
  21544c:	c4 e2 f3 f6 fe       	mulx   rdi,rcx,rsi
  215451:	c1 ef 02             	shr    edi,0x2
  215454:	81 e7 fe ff ff 3f    	and    edi,0x3ffffffe
  21545a:	8d 0c bf             	lea    ecx,[rdi+rdi*4]
  21545d:	89 d7                	mov    edi,edx
  21545f:	29 cf                	sub    edi,ecx
        0...9 => digit + '0',
  215461:	b1 30                	mov    cl,0x30
  215463:	40 80 ff 0a          	cmp    dil,0xa
  215467:	72 02                	jb     21546b <Benchmark_leftJustified+0xcb>
  215469:	b1 57                	mov    cl,0x57
  21546b:	40 00 f9             	add    cl,dil
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  21546e:	88 4c 1c 3e          	mov    BYTE PTR [rsp+rbx*1+0x3e],cl
        if (a == 0) break;
  215472:	48 83 c3 ff          	add    rbx,0xffffffffffffffff
  215476:	48 83 f8 63          	cmp    rax,0x63
  21547a:	48 89 d0             	mov    rax,rdx
  21547d:	77 c1                	ja     215440 <Benchmark_leftJustified+0xa0>
        const padded_buf = buf[index - padding ..];
  21547f:	41 be 41 00 00 00    	mov    r14d,0x41
  215485:	49 29 de             	sub    r14,rbx
    if (context.remaining.len < bytes.len) return error.BufferTooSmall;
  215488:	49 83 fe 17          	cmp    r14,0x17
  21548c:	76 09                	jbe    215497 <Benchmark_leftJustified+0xf7>
  21548e:	66 b8 05 00          	mov    ax,0x5
  215492:	e9 85 01 00 00       	jmp    21561c <Benchmark_leftJustified+0x27c>
    for (source) |s, i|
  215497:	4d 85 f6             	test   r14,r14
  21549a:	74 12                	je     2154ae <Benchmark_leftJustified+0x10e>
        dest[i] = s;
  21549c:	88 4c 24 21          	mov    BYTE PTR [rsp+0x21],cl
    for (source) |s, i|
  2154a0:	49 83 fe 01          	cmp    r14,0x1
  2154a4:	75 10                	jne    2154b6 <Benchmark_leftJustified+0x116>
  2154a6:	41 be 12 00 00 00    	mov    r14d,0x12
  2154ac:	eb 32                	jmp    2154e0 <Benchmark_leftJustified+0x140>
  2154ae:	41 be 11 00 00 00    	mov    r14d,0x11
  2154b4:	eb 2a                	jmp    2154e0 <Benchmark_leftJustified+0x140>
  2154b6:	48 8d 7c 24 22       	lea    rdi,[rsp+0x22]
  2154bb:	48 8d 34 1c          	lea    rsi,[rsp+rbx*1]
  2154bf:	48 83 c6 40          	add    rsi,0x40
  2154c3:	ba 40 00 00 00       	mov    edx,0x40
  2154c8:	48 29 da             	sub    rdx,rbx
        dest[i] = s;
  2154cb:	c5 f8 77             	vzeroupper 
  2154ce:	e8 ad 99 01 00       	call   22ee80 <memcpy>
        return output(context, padded_buf);
  2154d3:	49 83 c6 11          	add    r14,0x11
  2154d7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  2154de:	00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  2154e0:	b0 01                	mov    al,0x1
  2154e2:	86 05 28 bb 03 00    	xchg   BYTE PTR [rip+0x3bb28],al        # 251010 <stderr_mutex>
  2154e8:	84 c0                	test   al,al
  2154ea:	75 f4                	jne    2154e0 <Benchmark_leftJustified+0x140>
    if (stderr_stream) |st| {
  2154ec:	48 8b 3d 15 bb 03 00 	mov    rdi,QWORD PTR [rip+0x3bb15]        # 251008 <stderr_stream>
  2154f3:	48 85 ff             	test   rdi,rdi
  2154f6:	74 09                	je     215501 <Benchmark_leftJustified+0x161>
  2154f8:	48 8b 0d 41 6b 03 00 	mov    rcx,QWORD PTR [rip+0x36b41]        # 24c040 <stderr_file_out_stream+0x8>
  2154ff:	eb 34                	jmp    215535 <Benchmark_leftJustified+0x195>
        stderr_file = try io.getStdErr();
  215501:	48 8d 05 28 6b 03 00 	lea    rax,[rip+0x36b28]        # 24c030 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  215508:	48 89 05 29 6b 03 00 	mov    QWORD PTR [rip+0x36b29],rax        # 24c038 <stderr_file_out_stream>
  21550f:	48 8d 0d 8a 99 00 00 	lea    rcx,[rip+0x998a]        # 21eea0 <FileOutStream_writeFn>
  215516:	48 89 0d 23 6b 03 00 	mov    QWORD PTR [rip+0x36b23],rcx        # 24c040 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  21551d:	c7 05 09 6b 03 00 02 	mov    DWORD PTR [rip+0x36b09],0x2        # 24c030 <stderr_file>
  215524:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  215527:	48 8d 3d 12 6b 03 00 	lea    rdi,[rip+0x36b12]        # 24c040 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  21552e:	48 89 3d d3 ba 03 00 	mov    QWORD PTR [rip+0x3bad3],rdi        # 251008 <stderr_stream>
  215535:	48 8d 44 24 10       	lea    rax,[rsp+0x10]
                const casted_value = ([]const u8)(value);
  21553a:	48 89 44 24 40       	mov    QWORD PTR [rsp+0x40],rax
  21553f:	4c 89 74 24 48       	mov    QWORD PTR [rsp+0x48],r14
  215544:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
                return output(context, casted_value);
  215549:	c5 f8 77             	vzeroupper 
  21554c:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  21554e:	31 c0                	xor    eax,eax
  215550:	86 05 ba ba 03 00    	xchg   BYTE PTR [rip+0x3baba],al        # 251010 <stderr_mutex>
  215556:	3c 01                	cmp    al,0x1
    if (!ok) {
  215558:	0f 85 d3 00 00 00    	jne    215631 <Benchmark_leftJustified+0x291>
        if (width > str.len) {
  21555e:	49 83 fe 15          	cmp    r14,0x15
  215562:	0f 87 b2 00 00 00    	ja     21561a <Benchmark_leftJustified+0x27a>
            pad(width - str.len, ' ');
  215568:	41 bf 16 00 00 00    	mov    r15d,0x16
        while (i < count) : (i += 1) {
  21556e:	4d 29 f7             	sub    r15,r14
  215571:	0f 84 a3 00 00 00    	je     21561a <Benchmark_leftJustified+0x27a>
  215577:	31 db                	xor    ebx,ebx
  215579:	4c 8d 2d 20 99 00 00 	lea    r13,[rip+0x9920]        # 21eea0 <FileOutStream_writeFn>
  215580:	48 8d 2d b9 6a 03 00 	lea    rbp,[rip+0x36ab9]        # 24c040 <stderr_file_out_stream+0x8>
  215587:	4c 8d 64 24 0f       	lea    r12,[rsp+0xf]
  21558c:	4c 8d 74 24 40       	lea    r14,[rsp+0x40]
  215591:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  215598:	0f 1f 84 00 00 00 00 
  21559f:	00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  2155a0:	b0 01                	mov    al,0x1
  2155a2:	86 05 68 ba 03 00    	xchg   BYTE PTR [rip+0x3ba68],al        # 251010 <stderr_mutex>
  2155a8:	84 c0                	test   al,al
  2155aa:	75 f4                	jne    2155a0 <Benchmark_leftJustified+0x200>
    if (stderr_stream) |st| {
  2155ac:	48 8b 3d 55 ba 03 00 	mov    rdi,QWORD PTR [rip+0x3ba55]        # 251008 <stderr_stream>
  2155b3:	48 85 ff             	test   rdi,rdi
  2155b6:	74 09                	je     2155c1 <Benchmark_leftJustified+0x221>
  2155b8:	48 8b 0d 81 6a 03 00 	mov    rcx,QWORD PTR [rip+0x36a81]        # 24c040 <stderr_file_out_stream+0x8>
  2155bf:	eb 2c                	jmp    2155ed <Benchmark_leftJustified+0x24d>
        stderr_file = try io.getStdErr();
  2155c1:	c7 05 65 6a 03 00 02 	mov    DWORD PTR [rip+0x36a65],0x2        # 24c030 <stderr_file>
  2155c8:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  2155cb:	48 8d 05 5e 6a 03 00 	lea    rax,[rip+0x36a5e]        # 24c030 <stderr_file>
  2155d2:	48 89 05 5f 6a 03 00 	mov    QWORD PTR [rip+0x36a5f],rax        # 24c038 <stderr_file_out_stream>
  2155d9:	4c 89 2d 60 6a 03 00 	mov    QWORD PTR [rip+0x36a60],r13        # 24c040 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  2155e0:	48 89 2d 21 ba 03 00 	mov    QWORD PTR [rip+0x3ba21],rbp        # 251008 <stderr_stream>
  2155e7:	4c 89 e9             	mov    rcx,r13
  2155ea:	48 89 ef             	mov    rdi,rbp
  2155ed:	c6 44 24 0f 20       	mov    BYTE PTR [rsp+0xf],0x20
    return output(context, (*[1]u8)(&c)[0..]);
  2155f2:	4c 89 64 24 40       	mov    QWORD PTR [rsp+0x40],r12
  2155f7:	48 c7 44 24 48 01 00 	mov    QWORD PTR [rsp+0x48],0x1
  2155fe:	00 00 
  215600:	4c 89 f6             	mov    rsi,r14
  215603:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  215605:	31 c0                	xor    eax,eax
  215607:	86 05 03 ba 03 00    	xchg   BYTE PTR [rip+0x3ba03],al        # 251010 <stderr_mutex>
  21560d:	3c 01                	cmp    al,0x1
    if (!ok) {
  21560f:	75 20                	jne    215631 <Benchmark_leftJustified+0x291>
  215611:	48 83 c3 01          	add    rbx,0x1
  215615:	4c 39 fb             	cmp    rbx,r15
  215618:	72 86                	jb     2155a0 <Benchmark_leftJustified+0x200>
  21561a:	31 c0                	xor    eax,eax
        var str = try bufPrint(buffer[0..], fmt, args);
  21561c:	48 81 c4 88 00 00 00 	add    rsp,0x88
  215623:	5b                   	pop    rbx
  215624:	41 5c                	pop    r12
  215626:	41 5d                	pop    r13
  215628:	41 5e                	pop    r14
  21562a:	41 5f                	pop    r15
  21562c:	5d                   	pop    rbp
  21562d:	c5 f8 77             	vzeroupper 
  215630:	c3                   	ret    
            @panic("assertion failure");
  215631:	48 8d 3d 58 a7 03 00 	lea    rdi,[rip+0x3a758]        # 24fd90 <__unnamed_2>
  215638:	e8 e3 d0 ff ff       	call   212720 <panic>
  21563d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000215640 <Benchmark_rightJustified>:
        var buffer: [40]u8 = undefined;
  215640:	53                   	push   rbx
  215641:	48 83 ec 50          	sub    rsp,0x50
  215645:	c5 fc 10 05 02 09 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffff0902]        # 205f4f <__unnamed_7>
  21564c:	ff 
  21564d:	c5 fc 11 44 24 20    	vmovups YMMWORD PTR [rsp+0x20],ymm0
  215653:	48 8b 05 15 09 ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffff0915]        # 205f6f <__unnamed_7+0x20>
  21565a:	48 89 44 24 40       	mov    QWORD PTR [rsp+0x40],rax
  21565f:	48 b8 69 74 65 72 61 	movabs rax,0x6f69746172657469
  215666:	74 69 6f 
  215669:	48 89 44 24 20       	mov    QWORD PTR [rsp+0x20],rax
  21566e:	66 c7 44 24 28 6e 73 	mov    WORD PTR [rsp+0x28],0x736e
  215675:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21567c:	00 00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  215680:	b0 01                	mov    al,0x1
  215682:	86 05 88 b9 03 00    	xchg   BYTE PTR [rip+0x3b988],al        # 251010 <stderr_mutex>
  215688:	84 c0                	test   al,al
  21568a:	75 f4                	jne    215680 <Benchmark_rightJustified+0x40>
    if (stderr_stream) |st| {
  21568c:	48 8b 3d 75 b9 03 00 	mov    rdi,QWORD PTR [rip+0x3b975]        # 251008 <stderr_stream>
  215693:	48 85 ff             	test   rdi,rdi
  215696:	74 09                	je     2156a1 <Benchmark_rightJustified+0x61>
  215698:	48 8b 05 a1 69 03 00 	mov    rax,QWORD PTR [rip+0x369a1]        # 24c040 <stderr_file_out_stream+0x8>
  21569f:	eb 34                	jmp    2156d5 <Benchmark_rightJustified+0x95>
        stderr_file = try io.getStdErr();
  2156a1:	48 8d 05 88 69 03 00 	lea    rax,[rip+0x36988]        # 24c030 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  2156a8:	48 89 05 89 69 03 00 	mov    QWORD PTR [rip+0x36989],rax        # 24c038 <stderr_file_out_stream>
  2156af:	48 8d 05 ea 97 00 00 	lea    rax,[rip+0x97ea]        # 21eea0 <FileOutStream_writeFn>
  2156b6:	48 89 05 83 69 03 00 	mov    QWORD PTR [rip+0x36983],rax        # 24c040 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  2156bd:	c7 05 69 69 03 00 02 	mov    DWORD PTR [rip+0x36969],0x2        # 24c030 <stderr_file>
  2156c4:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  2156c7:	48 8d 3d 72 69 03 00 	lea    rdi,[rip+0x36972]        # 24c040 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  2156ce:	48 89 3d 33 b9 03 00 	mov    QWORD PTR [rip+0x3b933],rdi        # 251008 <stderr_stream>
  2156d5:	c6 44 24 0f 20       	mov    BYTE PTR [rsp+0xf],0x20
  2156da:	48 8d 5c 24 0f       	lea    rbx,[rsp+0xf]
  2156df:	48 89 5c 24 10       	mov    QWORD PTR [rsp+0x10],rbx
  2156e4:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  2156eb:	00 00 
  2156ed:	48 8d 74 24 10       	lea    rsi,[rsp+0x10]
  2156f2:	c5 f8 77             	vzeroupper 
  2156f5:	ff d0                	call   rax
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  2156f7:	31 c0                	xor    eax,eax
  2156f9:	86 05 11 b9 03 00    	xchg   BYTE PTR [rip+0x3b911],al        # 251010 <stderr_mutex>
  2156ff:	3c 01                	cmp    al,0x1
    if (!ok) {
  215701:	0f 85 0c 02 00 00    	jne    215913 <Benchmark_rightJustified+0x2d3>
  215707:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  21570e:	00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  215710:	b0 01                	mov    al,0x1
  215712:	86 05 f8 b8 03 00    	xchg   BYTE PTR [rip+0x3b8f8],al        # 251010 <stderr_mutex>
  215718:	84 c0                	test   al,al
  21571a:	75 f4                	jne    215710 <Benchmark_rightJustified+0xd0>
    if (stderr_stream) |st| {
  21571c:	48 8b 3d e5 b8 03 00 	mov    rdi,QWORD PTR [rip+0x3b8e5]        # 251008 <stderr_stream>
  215723:	48 85 ff             	test   rdi,rdi
  215726:	74 09                	je     215731 <Benchmark_rightJustified+0xf1>
  215728:	48 8b 0d 11 69 03 00 	mov    rcx,QWORD PTR [rip+0x36911]        # 24c040 <stderr_file_out_stream+0x8>
  21572f:	eb 34                	jmp    215765 <Benchmark_rightJustified+0x125>
        stderr_file = try io.getStdErr();
  215731:	48 8d 05 f8 68 03 00 	lea    rax,[rip+0x368f8]        # 24c030 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  215738:	48 89 05 f9 68 03 00 	mov    QWORD PTR [rip+0x368f9],rax        # 24c038 <stderr_file_out_stream>
  21573f:	48 8d 0d 5a 97 00 00 	lea    rcx,[rip+0x975a]        # 21eea0 <FileOutStream_writeFn>
  215746:	48 89 0d f3 68 03 00 	mov    QWORD PTR [rip+0x368f3],rcx        # 24c040 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  21574d:	c7 05 d9 68 03 00 02 	mov    DWORD PTR [rip+0x368d9],0x2        # 24c030 <stderr_file>
  215754:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  215757:	48 8d 3d e2 68 03 00 	lea    rdi,[rip+0x368e2]        # 24c040 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  21575e:	48 89 3d a3 b8 03 00 	mov    QWORD PTR [rip+0x3b8a3],rdi        # 251008 <stderr_stream>
  215765:	c6 44 24 0f 20       	mov    BYTE PTR [rsp+0xf],0x20
  21576a:	48 89 5c 24 10       	mov    QWORD PTR [rsp+0x10],rbx
  21576f:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  215776:	00 00 
  215778:	48 8d 74 24 10       	lea    rsi,[rsp+0x10]
  21577d:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  21577f:	31 c0                	xor    eax,eax
  215781:	86 05 89 b8 03 00    	xchg   BYTE PTR [rip+0x3b889],al        # 251010 <stderr_mutex>
  215787:	3c 01                	cmp    al,0x1
    if (!ok) {
  215789:	0f 85 84 01 00 00    	jne    215913 <Benchmark_rightJustified+0x2d3>
  21578f:	90                   	nop
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  215790:	b0 01                	mov    al,0x1
  215792:	86 05 78 b8 03 00    	xchg   BYTE PTR [rip+0x3b878],al        # 251010 <stderr_mutex>
  215798:	84 c0                	test   al,al
  21579a:	75 f4                	jne    215790 <Benchmark_rightJustified+0x150>
    if (stderr_stream) |st| {
  21579c:	48 8b 3d 65 b8 03 00 	mov    rdi,QWORD PTR [rip+0x3b865]        # 251008 <stderr_stream>
  2157a3:	48 85 ff             	test   rdi,rdi
  2157a6:	74 09                	je     2157b1 <Benchmark_rightJustified+0x171>
  2157a8:	48 8b 0d 91 68 03 00 	mov    rcx,QWORD PTR [rip+0x36891]        # 24c040 <stderr_file_out_stream+0x8>
  2157af:	eb 34                	jmp    2157e5 <Benchmark_rightJustified+0x1a5>
        stderr_file = try io.getStdErr();
  2157b1:	48 8d 05 78 68 03 00 	lea    rax,[rip+0x36878]        # 24c030 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  2157b8:	48 89 05 79 68 03 00 	mov    QWORD PTR [rip+0x36879],rax        # 24c038 <stderr_file_out_stream>
  2157bf:	48 8d 0d da 96 00 00 	lea    rcx,[rip+0x96da]        # 21eea0 <FileOutStream_writeFn>
  2157c6:	48 89 0d 73 68 03 00 	mov    QWORD PTR [rip+0x36873],rcx        # 24c040 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  2157cd:	c7 05 59 68 03 00 02 	mov    DWORD PTR [rip+0x36859],0x2        # 24c030 <stderr_file>
  2157d4:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  2157d7:	48 8d 3d 62 68 03 00 	lea    rdi,[rip+0x36862]        # 24c040 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  2157de:	48 89 3d 23 b8 03 00 	mov    QWORD PTR [rip+0x3b823],rdi        # 251008 <stderr_stream>
  2157e5:	c6 44 24 0f 20       	mov    BYTE PTR [rsp+0xf],0x20
  2157ea:	48 89 5c 24 10       	mov    QWORD PTR [rsp+0x10],rbx
  2157ef:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  2157f6:	00 00 
  2157f8:	48 8d 74 24 10       	lea    rsi,[rsp+0x10]
  2157fd:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  2157ff:	31 c0                	xor    eax,eax
  215801:	86 05 09 b8 03 00    	xchg   BYTE PTR [rip+0x3b809],al        # 251010 <stderr_mutex>
  215807:	3c 01                	cmp    al,0x1
    if (!ok) {
  215809:	0f 85 04 01 00 00    	jne    215913 <Benchmark_rightJustified+0x2d3>
  21580f:	90                   	nop
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  215810:	b0 01                	mov    al,0x1
  215812:	86 05 f8 b7 03 00    	xchg   BYTE PTR [rip+0x3b7f8],al        # 251010 <stderr_mutex>
  215818:	84 c0                	test   al,al
  21581a:	75 f4                	jne    215810 <Benchmark_rightJustified+0x1d0>
    if (stderr_stream) |st| {
  21581c:	48 8b 3d e5 b7 03 00 	mov    rdi,QWORD PTR [rip+0x3b7e5]        # 251008 <stderr_stream>
  215823:	48 85 ff             	test   rdi,rdi
  215826:	74 09                	je     215831 <Benchmark_rightJustified+0x1f1>
  215828:	48 8b 0d 11 68 03 00 	mov    rcx,QWORD PTR [rip+0x36811]        # 24c040 <stderr_file_out_stream+0x8>
  21582f:	eb 34                	jmp    215865 <Benchmark_rightJustified+0x225>
        stderr_file = try io.getStdErr();
  215831:	48 8d 05 f8 67 03 00 	lea    rax,[rip+0x367f8]        # 24c030 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  215838:	48 89 05 f9 67 03 00 	mov    QWORD PTR [rip+0x367f9],rax        # 24c038 <stderr_file_out_stream>
  21583f:	48 8d 0d 5a 96 00 00 	lea    rcx,[rip+0x965a]        # 21eea0 <FileOutStream_writeFn>
  215846:	48 89 0d f3 67 03 00 	mov    QWORD PTR [rip+0x367f3],rcx        # 24c040 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  21584d:	c7 05 d9 67 03 00 02 	mov    DWORD PTR [rip+0x367d9],0x2        # 24c030 <stderr_file>
  215854:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  215857:	48 8d 3d e2 67 03 00 	lea    rdi,[rip+0x367e2]        # 24c040 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  21585e:	48 89 3d a3 b7 03 00 	mov    QWORD PTR [rip+0x3b7a3],rdi        # 251008 <stderr_stream>
  215865:	c6 44 24 0f 20       	mov    BYTE PTR [rsp+0xf],0x20
  21586a:	48 89 5c 24 10       	mov    QWORD PTR [rsp+0x10],rbx
  21586f:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  215876:	00 00 
  215878:	48 8d 74 24 10       	lea    rsi,[rsp+0x10]
  21587d:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  21587f:	31 c0                	xor    eax,eax
  215881:	86 05 89 b7 03 00    	xchg   BYTE PTR [rip+0x3b789],al        # 251010 <stderr_mutex>
  215887:	3c 01                	cmp    al,0x1
    if (!ok) {
  215889:	0f 85 84 00 00 00    	jne    215913 <Benchmark_rightJustified+0x2d3>
  21588f:	90                   	nop
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  215890:	b0 01                	mov    al,0x1
  215892:	86 05 78 b7 03 00    	xchg   BYTE PTR [rip+0x3b778],al        # 251010 <stderr_mutex>
  215898:	84 c0                	test   al,al
  21589a:	75 f4                	jne    215890 <Benchmark_rightJustified+0x250>
    if (stderr_stream) |st| {
  21589c:	48 8b 3d 65 b7 03 00 	mov    rdi,QWORD PTR [rip+0x3b765]        # 251008 <stderr_stream>
  2158a3:	48 85 ff             	test   rdi,rdi
  2158a6:	74 09                	je     2158b1 <Benchmark_rightJustified+0x271>
  2158a8:	48 8b 0d 91 67 03 00 	mov    rcx,QWORD PTR [rip+0x36791]        # 24c040 <stderr_file_out_stream+0x8>
  2158af:	eb 34                	jmp    2158e5 <Benchmark_rightJustified+0x2a5>
        stderr_file = try io.getStdErr();
  2158b1:	48 8d 05 78 67 03 00 	lea    rax,[rip+0x36778]        # 24c030 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  2158b8:	48 89 05 79 67 03 00 	mov    QWORD PTR [rip+0x36779],rax        # 24c038 <stderr_file_out_stream>
  2158bf:	48 8d 0d da 95 00 00 	lea    rcx,[rip+0x95da]        # 21eea0 <FileOutStream_writeFn>
  2158c6:	48 89 0d 73 67 03 00 	mov    QWORD PTR [rip+0x36773],rcx        # 24c040 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  2158cd:	c7 05 59 67 03 00 02 	mov    DWORD PTR [rip+0x36759],0x2        # 24c030 <stderr_file>
  2158d4:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  2158d7:	48 8d 3d 62 67 03 00 	lea    rdi,[rip+0x36762]        # 24c040 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  2158de:	48 89 3d 23 b7 03 00 	mov    QWORD PTR [rip+0x3b723],rdi        # 251008 <stderr_stream>
  2158e5:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
                const casted_value = ([]const u8)(value);
  2158ea:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  2158ef:	48 c7 44 24 18 0a 00 	mov    QWORD PTR [rsp+0x18],0xa
  2158f6:	00 00 
  2158f8:	48 8d 74 24 10       	lea    rsi,[rsp+0x10]
                return output(context, casted_value);
  2158fd:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  2158ff:	31 c0                	xor    eax,eax
  215901:	86 05 09 b7 03 00    	xchg   BYTE PTR [rip+0x3b709],al        # 251010 <stderr_mutex>
  215907:	3c 01                	cmp    al,0x1
    if (!ok) {
  215909:	75 08                	jne    215913 <Benchmark_rightJustified+0x2d3>
    fn rightJustified(width: usize, comptime fmt: []const u8, args: ...) !void {
  21590b:	31 c0                	xor    eax,eax
  21590d:	48 83 c4 50          	add    rsp,0x50
  215911:	5b                   	pop    rbx
  215912:	c3                   	ret    
            @panic("assertion failure");
  215913:	48 8d 3d 76 a4 03 00 	lea    rdi,[rip+0x3a476]        # 24fd90 <__unnamed_2>
  21591a:	e8 01 ce ff ff       	call   212720 <panic>
  21591f:	90                   	nop

0000000000215920 <Benchmark_rightJustified.39>:
        var buffer: [40]u8 = undefined;
  215920:	53                   	push   rbx
  215921:	48 83 ec 50          	sub    rsp,0x50
  215925:	c5 fc 10 05 22 06 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffff0622]        # 205f4f <__unnamed_7>
  21592c:	ff 
  21592d:	c5 fc 11 44 24 20    	vmovups YMMWORD PTR [rsp+0x20],ymm0
  215933:	48 8b 05 35 06 ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffff0635]        # 205f6f <__unnamed_7+0x20>
  21593a:	48 89 44 24 40       	mov    QWORD PTR [rsp+0x40],rax
  21593f:	48 b8 74 69 6d 65 2f 	movabs rax,0x65706f2f656d6974
  215946:	6f 70 65 
  215949:	48 89 44 24 20       	mov    QWORD PTR [rsp+0x20],rax
  21594e:	c7 44 24 28 72 61 74 	mov    DWORD PTR [rsp+0x28],0x69746172
  215955:	69 
  215956:	66 c7 44 24 2c 6f 6e 	mov    WORD PTR [rsp+0x2c],0x6e6f
  21595d:	0f 1f 00             	nop    DWORD PTR [rax]
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  215960:	b0 01                	mov    al,0x1
  215962:	86 05 a8 b6 03 00    	xchg   BYTE PTR [rip+0x3b6a8],al        # 251010 <stderr_mutex>
  215968:	84 c0                	test   al,al
  21596a:	75 f4                	jne    215960 <Benchmark_rightJustified.39+0x40>
    if (stderr_stream) |st| {
  21596c:	48 8b 3d 95 b6 03 00 	mov    rdi,QWORD PTR [rip+0x3b695]        # 251008 <stderr_stream>
  215973:	48 85 ff             	test   rdi,rdi
  215976:	74 09                	je     215981 <Benchmark_rightJustified.39+0x61>
  215978:	48 8b 05 c1 66 03 00 	mov    rax,QWORD PTR [rip+0x366c1]        # 24c040 <stderr_file_out_stream+0x8>
  21597f:	eb 34                	jmp    2159b5 <Benchmark_rightJustified.39+0x95>
        stderr_file = try io.getStdErr();
  215981:	48 8d 05 a8 66 03 00 	lea    rax,[rip+0x366a8]        # 24c030 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  215988:	48 89 05 a9 66 03 00 	mov    QWORD PTR [rip+0x366a9],rax        # 24c038 <stderr_file_out_stream>
  21598f:	48 8d 05 0a 95 00 00 	lea    rax,[rip+0x950a]        # 21eea0 <FileOutStream_writeFn>
  215996:	48 89 05 a3 66 03 00 	mov    QWORD PTR [rip+0x366a3],rax        # 24c040 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  21599d:	c7 05 89 66 03 00 02 	mov    DWORD PTR [rip+0x36689],0x2        # 24c030 <stderr_file>
  2159a4:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  2159a7:	48 8d 3d 92 66 03 00 	lea    rdi,[rip+0x36692]        # 24c040 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  2159ae:	48 89 3d 53 b6 03 00 	mov    QWORD PTR [rip+0x3b653],rdi        # 251008 <stderr_stream>
  2159b5:	c6 44 24 0f 20       	mov    BYTE PTR [rsp+0xf],0x20
  2159ba:	48 8d 5c 24 0f       	lea    rbx,[rsp+0xf]
    return output(context, (*[1]u8)(&c)[0..]);
  2159bf:	48 89 5c 24 10       	mov    QWORD PTR [rsp+0x10],rbx
  2159c4:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  2159cb:	00 00 
  2159cd:	48 8d 74 24 10       	lea    rsi,[rsp+0x10]
  2159d2:	c5 f8 77             	vzeroupper 
  2159d5:	ff d0                	call   rax
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  2159d7:	31 c0                	xor    eax,eax
  2159d9:	86 05 31 b6 03 00    	xchg   BYTE PTR [rip+0x3b631],al        # 251010 <stderr_mutex>
  2159df:	3c 01                	cmp    al,0x1
    if (!ok) {
  2159e1:	0f 85 0c 02 00 00    	jne    215bf3 <Benchmark_rightJustified.39+0x2d3>
  2159e7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  2159ee:	00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  2159f0:	b0 01                	mov    al,0x1
  2159f2:	86 05 18 b6 03 00    	xchg   BYTE PTR [rip+0x3b618],al        # 251010 <stderr_mutex>
  2159f8:	84 c0                	test   al,al
  2159fa:	75 f4                	jne    2159f0 <Benchmark_rightJustified.39+0xd0>
    if (stderr_stream) |st| {
  2159fc:	48 8b 3d 05 b6 03 00 	mov    rdi,QWORD PTR [rip+0x3b605]        # 251008 <stderr_stream>
  215a03:	48 85 ff             	test   rdi,rdi
  215a06:	74 09                	je     215a11 <Benchmark_rightJustified.39+0xf1>
  215a08:	48 8b 0d 31 66 03 00 	mov    rcx,QWORD PTR [rip+0x36631]        # 24c040 <stderr_file_out_stream+0x8>
  215a0f:	eb 34                	jmp    215a45 <Benchmark_rightJustified.39+0x125>
        stderr_file = try io.getStdErr();
  215a11:	48 8d 05 18 66 03 00 	lea    rax,[rip+0x36618]        # 24c030 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  215a18:	48 89 05 19 66 03 00 	mov    QWORD PTR [rip+0x36619],rax        # 24c038 <stderr_file_out_stream>
  215a1f:	48 8d 0d 7a 94 00 00 	lea    rcx,[rip+0x947a]        # 21eea0 <FileOutStream_writeFn>
  215a26:	48 89 0d 13 66 03 00 	mov    QWORD PTR [rip+0x36613],rcx        # 24c040 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  215a2d:	c7 05 f9 65 03 00 02 	mov    DWORD PTR [rip+0x365f9],0x2        # 24c030 <stderr_file>
  215a34:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  215a37:	48 8d 3d 02 66 03 00 	lea    rdi,[rip+0x36602]        # 24c040 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  215a3e:	48 89 3d c3 b5 03 00 	mov    QWORD PTR [rip+0x3b5c3],rdi        # 251008 <stderr_stream>
  215a45:	c6 44 24 0f 20       	mov    BYTE PTR [rsp+0xf],0x20
  215a4a:	48 89 5c 24 10       	mov    QWORD PTR [rsp+0x10],rbx
  215a4f:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  215a56:	00 00 
  215a58:	48 8d 74 24 10       	lea    rsi,[rsp+0x10]
  215a5d:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  215a5f:	31 c0                	xor    eax,eax
  215a61:	86 05 a9 b5 03 00    	xchg   BYTE PTR [rip+0x3b5a9],al        # 251010 <stderr_mutex>
  215a67:	3c 01                	cmp    al,0x1
    if (!ok) {
  215a69:	0f 85 84 01 00 00    	jne    215bf3 <Benchmark_rightJustified.39+0x2d3>
  215a6f:	90                   	nop
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  215a70:	b0 01                	mov    al,0x1
  215a72:	86 05 98 b5 03 00    	xchg   BYTE PTR [rip+0x3b598],al        # 251010 <stderr_mutex>
  215a78:	84 c0                	test   al,al
  215a7a:	75 f4                	jne    215a70 <Benchmark_rightJustified.39+0x150>
    if (stderr_stream) |st| {
  215a7c:	48 8b 3d 85 b5 03 00 	mov    rdi,QWORD PTR [rip+0x3b585]        # 251008 <stderr_stream>
  215a83:	48 85 ff             	test   rdi,rdi
  215a86:	74 09                	je     215a91 <Benchmark_rightJustified.39+0x171>
  215a88:	48 8b 0d b1 65 03 00 	mov    rcx,QWORD PTR [rip+0x365b1]        # 24c040 <stderr_file_out_stream+0x8>
  215a8f:	eb 34                	jmp    215ac5 <Benchmark_rightJustified.39+0x1a5>
        stderr_file = try io.getStdErr();
  215a91:	48 8d 05 98 65 03 00 	lea    rax,[rip+0x36598]        # 24c030 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  215a98:	48 89 05 99 65 03 00 	mov    QWORD PTR [rip+0x36599],rax        # 24c038 <stderr_file_out_stream>
  215a9f:	48 8d 0d fa 93 00 00 	lea    rcx,[rip+0x93fa]        # 21eea0 <FileOutStream_writeFn>
  215aa6:	48 89 0d 93 65 03 00 	mov    QWORD PTR [rip+0x36593],rcx        # 24c040 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  215aad:	c7 05 79 65 03 00 02 	mov    DWORD PTR [rip+0x36579],0x2        # 24c030 <stderr_file>
  215ab4:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  215ab7:	48 8d 3d 82 65 03 00 	lea    rdi,[rip+0x36582]        # 24c040 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  215abe:	48 89 3d 43 b5 03 00 	mov    QWORD PTR [rip+0x3b543],rdi        # 251008 <stderr_stream>
  215ac5:	c6 44 24 0f 20       	mov    BYTE PTR [rsp+0xf],0x20
  215aca:	48 89 5c 24 10       	mov    QWORD PTR [rsp+0x10],rbx
  215acf:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  215ad6:	00 00 
  215ad8:	48 8d 74 24 10       	lea    rsi,[rsp+0x10]
  215add:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  215adf:	31 c0                	xor    eax,eax
  215ae1:	86 05 29 b5 03 00    	xchg   BYTE PTR [rip+0x3b529],al        # 251010 <stderr_mutex>
  215ae7:	3c 01                	cmp    al,0x1
    if (!ok) {
  215ae9:	0f 85 04 01 00 00    	jne    215bf3 <Benchmark_rightJustified.39+0x2d3>
  215aef:	90                   	nop
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  215af0:	b0 01                	mov    al,0x1
  215af2:	86 05 18 b5 03 00    	xchg   BYTE PTR [rip+0x3b518],al        # 251010 <stderr_mutex>
  215af8:	84 c0                	test   al,al
  215afa:	75 f4                	jne    215af0 <Benchmark_rightJustified.39+0x1d0>
    if (stderr_stream) |st| {
  215afc:	48 8b 3d 05 b5 03 00 	mov    rdi,QWORD PTR [rip+0x3b505]        # 251008 <stderr_stream>
  215b03:	48 85 ff             	test   rdi,rdi
  215b06:	74 09                	je     215b11 <Benchmark_rightJustified.39+0x1f1>
  215b08:	48 8b 0d 31 65 03 00 	mov    rcx,QWORD PTR [rip+0x36531]        # 24c040 <stderr_file_out_stream+0x8>
  215b0f:	eb 34                	jmp    215b45 <Benchmark_rightJustified.39+0x225>
        stderr_file = try io.getStdErr();
  215b11:	48 8d 05 18 65 03 00 	lea    rax,[rip+0x36518]        # 24c030 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  215b18:	48 89 05 19 65 03 00 	mov    QWORD PTR [rip+0x36519],rax        # 24c038 <stderr_file_out_stream>
  215b1f:	48 8d 0d 7a 93 00 00 	lea    rcx,[rip+0x937a]        # 21eea0 <FileOutStream_writeFn>
  215b26:	48 89 0d 13 65 03 00 	mov    QWORD PTR [rip+0x36513],rcx        # 24c040 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  215b2d:	c7 05 f9 64 03 00 02 	mov    DWORD PTR [rip+0x364f9],0x2        # 24c030 <stderr_file>
  215b34:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  215b37:	48 8d 3d 02 65 03 00 	lea    rdi,[rip+0x36502]        # 24c040 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  215b3e:	48 89 3d c3 b4 03 00 	mov    QWORD PTR [rip+0x3b4c3],rdi        # 251008 <stderr_stream>
  215b45:	c6 44 24 0f 20       	mov    BYTE PTR [rsp+0xf],0x20
  215b4a:	48 89 5c 24 10       	mov    QWORD PTR [rsp+0x10],rbx
  215b4f:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  215b56:	00 00 
  215b58:	48 8d 74 24 10       	lea    rsi,[rsp+0x10]
  215b5d:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  215b5f:	31 c0                	xor    eax,eax
  215b61:	86 05 a9 b4 03 00    	xchg   BYTE PTR [rip+0x3b4a9],al        # 251010 <stderr_mutex>
  215b67:	3c 01                	cmp    al,0x1
    if (!ok) {
  215b69:	0f 85 84 00 00 00    	jne    215bf3 <Benchmark_rightJustified.39+0x2d3>
  215b6f:	90                   	nop
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  215b70:	b0 01                	mov    al,0x1
  215b72:	86 05 98 b4 03 00    	xchg   BYTE PTR [rip+0x3b498],al        # 251010 <stderr_mutex>
  215b78:	84 c0                	test   al,al
  215b7a:	75 f4                	jne    215b70 <Benchmark_rightJustified.39+0x250>
    if (stderr_stream) |st| {
  215b7c:	48 8b 3d 85 b4 03 00 	mov    rdi,QWORD PTR [rip+0x3b485]        # 251008 <stderr_stream>
  215b83:	48 85 ff             	test   rdi,rdi
  215b86:	74 09                	je     215b91 <Benchmark_rightJustified.39+0x271>
  215b88:	48 8b 0d b1 64 03 00 	mov    rcx,QWORD PTR [rip+0x364b1]        # 24c040 <stderr_file_out_stream+0x8>
  215b8f:	eb 34                	jmp    215bc5 <Benchmark_rightJustified.39+0x2a5>
        stderr_file = try io.getStdErr();
  215b91:	48 8d 05 98 64 03 00 	lea    rax,[rip+0x36498]        # 24c030 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  215b98:	48 89 05 99 64 03 00 	mov    QWORD PTR [rip+0x36499],rax        # 24c038 <stderr_file_out_stream>
  215b9f:	48 8d 0d fa 92 00 00 	lea    rcx,[rip+0x92fa]        # 21eea0 <FileOutStream_writeFn>
  215ba6:	48 89 0d 93 64 03 00 	mov    QWORD PTR [rip+0x36493],rcx        # 24c040 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  215bad:	c7 05 79 64 03 00 02 	mov    DWORD PTR [rip+0x36479],0x2        # 24c030 <stderr_file>
  215bb4:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  215bb7:	48 8d 3d 82 64 03 00 	lea    rdi,[rip+0x36482]        # 24c040 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  215bbe:	48 89 3d 43 b4 03 00 	mov    QWORD PTR [rip+0x3b443],rdi        # 251008 <stderr_stream>
  215bc5:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
                const casted_value = ([]const u8)(value);
  215bca:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  215bcf:	48 c7 44 24 18 0e 00 	mov    QWORD PTR [rsp+0x18],0xe
  215bd6:	00 00 
  215bd8:	48 8d 74 24 10       	lea    rsi,[rsp+0x10]
                return output(context, casted_value);
  215bdd:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  215bdf:	31 c0                	xor    eax,eax
  215be1:	86 05 29 b4 03 00    	xchg   BYTE PTR [rip+0x3b429],al        # 251010 <stderr_mutex>
  215be7:	3c 01                	cmp    al,0x1
    if (!ok) {
  215be9:	75 08                	jne    215bf3 <Benchmark_rightJustified.39+0x2d3>
    fn rightJustified(width: usize, comptime fmt: []const u8, args: ...) !void {
  215beb:	31 c0                	xor    eax,eax
  215bed:	48 83 c4 50          	add    rsp,0x50
  215bf1:	5b                   	pop    rbx
  215bf2:	c3                   	ret    
            @panic("assertion failure");
  215bf3:	48 8d 3d 96 a1 03 00 	lea    rdi,[rip+0x3a196]        # 24fd90 <__unnamed_2>
  215bfa:	e8 21 cb ff ff       	call   212720 <panic>
  215bff:	90                   	nop

0000000000215c00 <Benchmark_reportStats>:
    fn reportStats(pSelf: *Self, results: ArrayList(Result)) !void {
  215c00:	55                   	push   rbp
  215c01:	48 89 e5             	mov    rbp,rsp
  215c04:	41 57                	push   r15
  215c06:	41 56                	push   r14
  215c08:	41 55                	push   r13
  215c0a:	41 54                	push   r12
  215c0c:	53                   	push   rbx
  215c0d:	48 83 e4 e0          	and    rsp,0xffffffffffffffe0
  215c11:	48 81 ec 40 22 00 00 	sub    rsp,0x2240
  215c18:	48 89 fb             	mov    rbx,rdi
            return self.items[0..self.len];
  215c1b:	48 8b 7e 10          	mov    rdi,QWORD PTR [rsi+0x10]
        for (results.toSlice()) |result, i| {
  215c1f:	48 85 ff             	test   rdi,rdi
  215c22:	74 26                	je     215c4a <Benchmark_reportStats+0x4a>
  215c24:	48 8b 06             	mov    rax,QWORD PTR [rsi]
  215c27:	48 8d 57 ff          	lea    rdx,[rdi-0x1]
  215c2b:	89 f9                	mov    ecx,edi
  215c2d:	83 e1 07             	and    ecx,0x7
  215c30:	48 83 fa 07          	cmp    rdx,0x7
  215c34:	73 1d                	jae    215c53 <Benchmark_reportStats+0x53>
  215c36:	c5 c9 57 f6          	vxorpd xmm6,xmm6,xmm6
  215c3a:	31 d2                	xor    edx,edx
  215c3c:	48 85 c9             	test   rcx,rcx
  215c3f:	0f 85 e8 00 00 00    	jne    215d2d <Benchmark_reportStats+0x12d>
  215c45:	e9 24 01 00 00       	jmp    215d6e <Benchmark_reportStats+0x16e>
  215c4a:	c5 c9 57 f6          	vxorpd xmm6,xmm6,xmm6
  215c4e:	e9 1b 01 00 00       	jmp    215d6e <Benchmark_reportStats+0x16e>
  215c53:	48 29 cf             	sub    rdi,rcx
  215c56:	48 8d 70 70          	lea    rsi,[rax+0x70]
  215c5a:	c5 c9 57 f6          	vxorpd xmm6,xmm6,xmm6
  215c5e:	31 d2                	xor    edx,edx
  215c60:	c5 f9 28 05 b8 a5 fe 	vmovapd xmm0,XMMWORD PTR [rip+0xfffffffffffea5b8]        # 200220 <__unnamed_29+0x20>
  215c67:	ff 
  215c68:	c5 f9 28 0d c0 aa fe 	vmovapd xmm1,XMMWORD PTR [rip+0xfffffffffffeaac0]        # 200730 <__unnamed_55+0x10>
  215c6f:	ff 
            sum += @intToFloat(f64, result.run_time_ns);
  215c70:	c5 fb 10 56 90       	vmovsd xmm2,QWORD PTR [rsi-0x70]
  215c75:	c5 e8 14 d0          	vunpcklps xmm2,xmm2,xmm0
  215c79:	c5 e9 5c d1          	vsubpd xmm2,xmm2,xmm1
  215c7d:	c5 e9 7c d2          	vhaddpd xmm2,xmm2,xmm2
  215c81:	c5 fb 10 5e a0       	vmovsd xmm3,QWORD PTR [rsi-0x60]
  215c86:	c5 e0 14 d8          	vunpcklps xmm3,xmm3,xmm0
  215c8a:	c5 e1 5c d9          	vsubpd xmm3,xmm3,xmm1
  215c8e:	c5 e1 7c db          	vhaddpd xmm3,xmm3,xmm3
  215c92:	c5 fb 10 66 b0       	vmovsd xmm4,QWORD PTR [rsi-0x50]
  215c97:	c5 d8 14 e0          	vunpcklps xmm4,xmm4,xmm0
  215c9b:	c5 d9 5c e1          	vsubpd xmm4,xmm4,xmm1
  215c9f:	c5 d9 7c e4          	vhaddpd xmm4,xmm4,xmm4
  215ca3:	c5 fb 10 6e c0       	vmovsd xmm5,QWORD PTR [rsi-0x40]
  215ca8:	c5 d0 14 e8          	vunpcklps xmm5,xmm5,xmm0
  215cac:	c5 d1 5c e9          	vsubpd xmm5,xmm5,xmm1
  215cb0:	c5 d1 7c ed          	vhaddpd xmm5,xmm5,xmm5
  215cb4:	c5 cb 58 d2          	vaddsd xmm2,xmm6,xmm2
  215cb8:	c5 fb 10 76 d0       	vmovsd xmm6,QWORD PTR [rsi-0x30]
  215cbd:	c5 c8 14 f0          	vunpcklps xmm6,xmm6,xmm0
  215cc1:	c5 c9 5c f1          	vsubpd xmm6,xmm6,xmm1
  215cc5:	c5 c9 7c f6          	vhaddpd xmm6,xmm6,xmm6
  215cc9:	c5 eb 58 d3          	vaddsd xmm2,xmm2,xmm3
  215ccd:	c5 eb 58 d4          	vaddsd xmm2,xmm2,xmm4
  215cd1:	c5 fb 10 5e e0       	vmovsd xmm3,QWORD PTR [rsi-0x20]
  215cd6:	c5 e0 14 d8          	vunpcklps xmm3,xmm3,xmm0
  215cda:	c5 e1 5c d9          	vsubpd xmm3,xmm3,xmm1
  215cde:	c5 e1 7c db          	vhaddpd xmm3,xmm3,xmm3
  215ce2:	c5 eb 58 d5          	vaddsd xmm2,xmm2,xmm5
  215ce6:	c5 eb 58 d6          	vaddsd xmm2,xmm2,xmm6
  215cea:	c5 fb 10 66 f0       	vmovsd xmm4,QWORD PTR [rsi-0x10]
  215cef:	c5 d8 14 e0          	vunpcklps xmm4,xmm4,xmm0
  215cf3:	c5 d9 5c e1          	vsubpd xmm4,xmm4,xmm1
  215cf7:	c5 d9 7c e4          	vhaddpd xmm4,xmm4,xmm4
  215cfb:	c5 eb 58 d3          	vaddsd xmm2,xmm2,xmm3
  215cff:	c5 eb 58 d4          	vaddsd xmm2,xmm2,xmm4
  215d03:	c5 fb 10 1e          	vmovsd xmm3,QWORD PTR [rsi]
  215d07:	c5 e0 14 d8          	vunpcklps xmm3,xmm3,xmm0
  215d0b:	c5 e1 5c d9          	vsubpd xmm3,xmm3,xmm1
  215d0f:	c5 e1 7c db          	vhaddpd xmm3,xmm3,xmm3
  215d13:	c5 eb 58 f3          	vaddsd xmm6,xmm2,xmm3
        for (results.toSlice()) |result, i| {
  215d17:	48 83 c2 08          	add    rdx,0x8
  215d1b:	48 83 ee 80          	sub    rsi,0xffffffffffffff80
  215d1f:	48 39 d7             	cmp    rdi,rdx
  215d22:	0f 85 48 ff ff ff    	jne    215c70 <Benchmark_reportStats+0x70>
  215d28:	48 85 c9             	test   rcx,rcx
  215d2b:	74 41                	je     215d6e <Benchmark_reportStats+0x16e>
  215d2d:	48 c1 e2 04          	shl    rdx,0x4
  215d31:	48 01 d0             	add    rax,rdx
  215d34:	48 f7 d9             	neg    rcx
  215d37:	c5 f9 28 05 e1 a4 fe 	vmovapd xmm0,XMMWORD PTR [rip+0xfffffffffffea4e1]        # 200220 <__unnamed_29+0x20>
  215d3e:	ff 
  215d3f:	c5 f9 28 0d e9 a9 fe 	vmovapd xmm1,XMMWORD PTR [rip+0xfffffffffffea9e9]        # 200730 <__unnamed_55+0x10>
  215d46:	ff 
  215d47:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  215d4e:	00 00 
            sum += @intToFloat(f64, result.run_time_ns);
  215d50:	c5 fb 10 10          	vmovsd xmm2,QWORD PTR [rax]
  215d54:	c5 e8 14 d0          	vunpcklps xmm2,xmm2,xmm0
  215d58:	c5 e9 5c d1          	vsubpd xmm2,xmm2,xmm1
  215d5c:	c5 e9 7c d2          	vhaddpd xmm2,xmm2,xmm2
  215d60:	c5 cb 58 f2          	vaddsd xmm6,xmm6,xmm2
        for (results.toSlice()) |result, i| {
  215d64:	48 83 c0 10          	add    rax,0x10
  215d68:	48 83 c1 01          	add    rcx,0x1
  215d6c:	75 e2                	jne    215d50 <Benchmark_reportStats+0x150>
  215d6e:	48 8b 43 48          	mov    rax,QWORD PTR [rbx+0x48]
            .run_time_ns = @floatToInt(u64, sum / @intToFloat(f64, results.len)),
  215d72:	c5 fb 10 43 58       	vmovsd xmm0,QWORD PTR [rbx+0x58]
  215d77:	c5 f8 14 05 a1 a4 fe 	vunpcklps xmm0,xmm0,XMMWORD PTR [rip+0xfffffffffffea4a1]        # 200220 <__unnamed_29+0x20>
  215d7e:	ff 
  215d7f:	c5 f9 5c 05 a9 a9 fe 	vsubpd xmm0,xmm0,XMMWORD PTR [rip+0xfffffffffffea9a9]        # 200730 <__unnamed_55+0x10>
  215d86:	ff 
  215d87:	c5 f9 7c c0          	vhaddpd xmm0,xmm0,xmm0
  215d8b:	c5 fb 11 b4 24 90 01 	vmovsd QWORD PTR [rsp+0x190],xmm6
  215d92:	00 00 
  215d94:	c5 cb 5e c0          	vdivsd xmm0,xmm6,xmm0
  215d98:	c5 fb 10 15 20 af fe 	vmovsd xmm2,QWORD PTR [rip+0xfffffffffffeaf20]        # 200cc0 <__unnamed_621+0x8>
  215d9f:	ff 
  215da0:	c5 fb 5c ca          	vsubsd xmm1,xmm0,xmm2
  215da4:	c4 e1 fb 2c c9       	vcvttsd2si rcx,xmm1
  215da9:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
  215dad:	48 be 00 00 00 00 00 	movabs rsi,0x8000000000000000
  215db4:	00 00 80 
  215db7:	c4 e1 fb 2c d0       	vcvttsd2si rdx,xmm0
  215dbc:	48 31 f1             	xor    rcx,rsi
  215dbf:	c5 f9 2e c2          	vucomisd xmm0,xmm2
  215dc3:	48 0f 43 d1          	cmovae rdx,rcx
        try pSelf.report(Result {
  215dc7:	48 89 94 24 28 02 00 	mov    QWORD PTR [rsp+0x228],rdx
  215dce:	00 
  215dcf:	48 89 84 24 30 02 00 	mov    QWORD PTR [rsp+0x230],rax
  215dd6:	00 
  215dd7:	48 8d b4 24 28 02 00 	lea    rsi,[rsp+0x228]
  215dde:	00 
  215ddf:	48 89 df             	mov    rdi,rbx
  215de2:	e8 39 d1 ff ff       	call   212f20 <Benchmark_report>
        try pSelf.reportStatsMean(sum, pSelf.results); warn(" mean\n");
  215de7:	66 85 c0             	test   ax,ax
  215dea:	0f 85 6d 89 00 00    	jne    21e75d <Benchmark_reportStats+0x8b5d>
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  215df0:	b0 01                	mov    al,0x1
  215df2:	86 05 18 b2 03 00    	xchg   BYTE PTR [rip+0x3b218],al        # 251010 <stderr_mutex>
  215df8:	84 c0                	test   al,al
  215dfa:	75 f4                	jne    215df0 <Benchmark_reportStats+0x1f0>
    if (stderr_stream) |st| {
  215dfc:	48 8b 3d 05 b2 03 00 	mov    rdi,QWORD PTR [rip+0x3b205]        # 251008 <stderr_stream>
  215e03:	48 85 ff             	test   rdi,rdi
  215e06:	74 09                	je     215e11 <Benchmark_reportStats+0x211>
  215e08:	48 8b 0d 31 62 03 00 	mov    rcx,QWORD PTR [rip+0x36231]        # 24c040 <stderr_file_out_stream+0x8>
  215e0f:	eb 34                	jmp    215e45 <Benchmark_reportStats+0x245>
        stderr_file = try io.getStdErr();
  215e11:	48 8d 05 18 62 03 00 	lea    rax,[rip+0x36218]        # 24c030 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  215e18:	48 89 05 19 62 03 00 	mov    QWORD PTR [rip+0x36219],rax        # 24c038 <stderr_file_out_stream>
  215e1f:	48 8d 0d 7a 90 00 00 	lea    rcx,[rip+0x907a]        # 21eea0 <FileOutStream_writeFn>
  215e26:	48 89 0d 13 62 03 00 	mov    QWORD PTR [rip+0x36213],rcx        # 24c040 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  215e2d:	c7 05 f9 61 03 00 02 	mov    DWORD PTR [rip+0x361f9],0x2        # 24c030 <stderr_file>
  215e34:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  215e37:	48 8d 3d 02 62 03 00 	lea    rdi,[rip+0x36202]        # 24c040 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  215e3e:	48 89 3d c3 b1 03 00 	mov    QWORD PTR [rip+0x3b1c3],rdi        # 251008 <stderr_stream>
        try output(context, fmt[start_index..]);
  215e45:	48 8d 35 b4 9f 03 00 	lea    rsi,[rip+0x39fb4]        # 24fe00 <__unnamed_34>
  215e4c:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  215e4e:	31 c0                	xor    eax,eax
  215e50:	86 05 ba b1 03 00    	xchg   BYTE PTR [rip+0x3b1ba],al        # 251010 <stderr_mutex>
  215e56:	3c 01                	cmp    al,0x1
    if (!ok) {
  215e58:	0f 85 0e 89 00 00    	jne    21e76c <Benchmark_reportStats+0x8b6c>
        if (results.len < 3) {
  215e5e:	4c 8b 63 58          	mov    r12,QWORD PTR [rbx+0x58]
  215e62:	49 83 fc 02          	cmp    r12,0x2
  215e66:	77 7a                	ja     215ee2 <Benchmark_reportStats+0x2e2>
            .run_time_ns = @floatToInt(u64, sum / @intToFloat(f64, results.len)),
  215e68:	c4 c1 f9 6e c4       	vmovq  xmm0,r12
  215e6d:	c5 f9 62 05 ab a3 fe 	vpunpckldq xmm0,xmm0,XMMWORD PTR [rip+0xfffffffffffea3ab]        # 200220 <__unnamed_29+0x20>
  215e74:	ff 
  215e75:	c5 f9 5c 05 b3 a8 fe 	vsubpd xmm0,xmm0,XMMWORD PTR [rip+0xfffffffffffea8b3]        # 200730 <__unnamed_55+0x10>
  215e7c:	ff 
  215e7d:	c5 f9 7c c0          	vhaddpd xmm0,xmm0,xmm0
  215e81:	48 8b 43 48          	mov    rax,QWORD PTR [rbx+0x48]
  215e85:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
  215e89:	c5 fb 10 8c 24 90 01 	vmovsd xmm1,QWORD PTR [rsp+0x190]
  215e90:	00 00 
  215e92:	c5 f3 5e c0          	vdivsd xmm0,xmm1,xmm0
  215e96:	c5 fb 10 0d 22 ae fe 	vmovsd xmm1,QWORD PTR [rip+0xfffffffffffeae22]        # 200cc0 <__unnamed_621+0x8>
  215e9d:	ff 
  215e9e:	c5 f9 28 d1          	vmovapd xmm2,xmm1
  215ea2:	c5 fb 5c ca          	vsubsd xmm1,xmm0,xmm2
  215ea6:	c4 e1 fb 2c c9       	vcvttsd2si rcx,xmm1
  215eab:	c4 e1 fb 2c d0       	vcvttsd2si rdx,xmm0
  215eb0:	48 be 00 00 00 00 00 	movabs rsi,0x8000000000000000
  215eb7:	00 00 80 
  215eba:	48 31 f1             	xor    rcx,rsi
  215ebd:	c5 f9 2e c2          	vucomisd xmm0,xmm2
  215ec1:	48 0f 43 d1          	cmovae rdx,rcx
        try pSelf.report(Result {
  215ec5:	48 89 94 24 28 02 00 	mov    QWORD PTR [rsp+0x228],rdx
  215ecc:	00 
  215ecd:	48 89 84 24 30 02 00 	mov    QWORD PTR [rsp+0x230],rax
  215ed4:	00 
  215ed5:	48 8d b4 24 28 02 00 	lea    rsi,[rsp+0x228]
  215edc:	00 
  215edd:	e9 b3 85 00 00       	jmp    21e495 <Benchmark_reportStats+0x8895>
        var copy = ArrayList(Result).init(pSelf.pAllocator);
  215ee2:	48 8b 43 40          	mov    rax,QWORD PTR [rbx+0x40]
            return Self{
  215ee6:	c5 f9 57 c0          	vxorpd xmm0,xmm0,xmm0
  215eea:	c5 f9 29 84 24 a0 01 	vmovapd XMMWORD PTR [rsp+0x1a0],xmm0
  215ef1:	00 00 
  215ef3:	48 c7 84 24 b0 01 00 	mov    QWORD PTR [rsp+0x1b0],0x0
  215efa:	00 00 00 00 00 
  215eff:	48 89 84 24 b8 01 00 	mov    QWORD PTR [rsp+0x1b8],rax
  215f06:	00 
  215f07:	48 89 9c 24 88 01 00 	mov    QWORD PTR [rsp+0x188],rbx
  215f0e:	00 
            return self.items[0..self.len];
  215f0f:	4c 8b 6b 48          	mov    r13,QWORD PTR [rbx+0x48]
        for (results.toSlice()) |result| {
  215f13:	c5 fa 6f 05 f5 a3 fe 	vmovdqu xmm0,XMMWORD PTR [rip+0xfffffffffffea3f5]        # 200310 <__unnamed_35>
  215f1a:	ff 
  215f1b:	c5 f9 7f 84 24 e0 01 	vmovdqa XMMWORD PTR [rsp+0x1e0],xmm0
  215f22:	00 00 
  215f24:	31 db                	xor    ebx,ebx
  215f26:	4c 8d b4 24 a0 01 00 	lea    r14,[rsp+0x1a0]
  215f2d:	00 
  215f2e:	4c 8d bc 24 e0 01 00 	lea    r15,[rsp+0x1e0]
  215f35:	00 
  215f36:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  215f3d:	00 00 00 
  215f40:	c4 c1 7a 6f 45 00    	vmovdqu xmm0,XMMWORD PTR [r13+0x0]
  215f46:	c5 f9 7f 84 24 e0 01 	vmovdqa XMMWORD PTR [rsp+0x1e0],xmm0
  215f4d:	00 00 
            try copy.append(result);
  215f4f:	4c 89 f7             	mov    rdi,r14
  215f52:	4c 89 fe             	mov    rsi,r15
  215f55:	e8 56 ce ff ff       	call   212db0 <AlignedArrayList(Result,8)_append>
  215f5a:	66 85 c0             	test   ax,ax
  215f5d:	0f 85 fa 87 00 00    	jne    21e75d <Benchmark_reportStats+0x8b5d>
  215f63:	48 83 c3 01          	add    rbx,0x1
        for (results.toSlice()) |result| {
  215f67:	49 83 c5 10          	add    r13,0x10
  215f6b:	4c 39 e3             	cmp    rbx,r12
  215f6e:	72 d0                	jb     215f40 <Benchmark_reportStats+0x340>
  215f70:	48 8b 9c 24 a0 01 00 	mov    rbx,QWORD PTR [rsp+0x1a0]
  215f77:	00 
  215f78:	4c 8b b4 24 b0 01 00 	mov    r14,QWORD PTR [rsp+0x1b0]
  215f7f:	00 
  215f80:	48 89 5c 24 40       	mov    QWORD PTR [rsp+0x40],rbx
  215f85:	4c 89 74 24 48       	mov    QWORD PTR [rsp+0x48],r14

/// Stable in-place sort. O(n) best case, O(n*log(n)) worst case and average case. O(1) memory (no allocator required).
/// Currently implemented as block sort.
pub fn sort(comptime T: type, items: []T, lessThan: fn (lhs: T, rhs: T) bool) void {
    // Implementation ported from https://github.com/BonzaiThePenguin/WikiSort/blob/master/WikiSort.c
    var cache: [512]T = undefined;
  215f8a:	48 8d 35 e7 ff fe ff 	lea    rsi,[rip+0xfffffffffffeffe7]        # 205f78 <__unnamed_36>
  215f91:	48 8d bc 24 28 02 00 	lea    rdi,[rsp+0x228]
  215f98:	00 
  215f99:	ba 00 20 00 00       	mov    edx,0x2000
  215f9e:	e8 dd 8e 01 00       	call   22ee80 <memcpy>
  215fa3:	4c 89 f0             	mov    rax,r14

    if (items.len < 4) {
  215fa6:	48 83 f8 03          	cmp    rax,0x3
  215faa:	0f 87 96 00 00 00    	ja     216046 <Benchmark_reportStats+0x446>
        if (items.len == 3) {
  215fb0:	48 83 f8 02          	cmp    rax,0x2
  215fb4:	0f 84 e5 83 00 00    	je     21e39f <Benchmark_reportStats+0x879f>
  215fba:	48 83 f8 03          	cmp    rax,0x3
  215fbe:	0f 85 0a 84 00 00    	jne    21e3ce <Benchmark_reportStats+0x87ce>
            // hard coded insertion sort
            if (lessThan(items[1], items[0])) mem.swap(T, &items[0], &items[1]);
  215fc4:	48 8d 43 10          	lea    rax,[rbx+0x10]
  215fc8:	48 8b 4b 10          	mov    rcx,QWORD PTR [rbx+0x10]
            return lhs.run_time_ns < rhs.run_time_ns;
  215fcc:	48 3b 0b             	cmp    rcx,QWORD PTR [rbx]
  215fcf:	73 26                	jae    215ff7 <Benchmark_reportStats+0x3f7>
test "mem.max" {
    assert(max(u8, "abcdefg") == 'g');
}

pub fn swap(comptime T: type, a: *T, b: *T) void {
    const tmp = a.*;
  215fd1:	c5 f8 10 03          	vmovups xmm0,XMMWORD PTR [rbx]
  215fd5:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  215fdc:	00 00 
    a.* = b.*;
  215fde:	c5 f8 10 00          	vmovups xmm0,XMMWORD PTR [rax]
  215fe2:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
    b.* = tmp;
  215fe6:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  215fed:	00 00 
  215fef:	c5 fa 7f 00          	vmovdqu XMMWORD PTR [rax],xmm0
  215ff3:	48 8b 4b 10          	mov    rcx,QWORD PTR [rbx+0x10]
  215ff7:	48 39 4b 20          	cmp    QWORD PTR [rbx+0x20],rcx
            if (lessThan(items[2], items[1])) {
  215ffb:	0f 83 cd 83 00 00    	jae    21e3ce <Benchmark_reportStats+0x87ce>
    const tmp = a.*;
  216001:	c5 f8 10 00          	vmovups xmm0,XMMWORD PTR [rax]
  216005:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  21600c:	00 00 
  21600e:	48 8d 4b 20          	lea    rcx,[rbx+0x20]
    a.* = b.*;
  216012:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  216016:	c5 f8 11 00          	vmovups XMMWORD PTR [rax],xmm0
    b.* = tmp;
  21601a:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  216021:	00 00 
  216023:	c5 fa 7f 01          	vmovdqu XMMWORD PTR [rcx],xmm0
  216027:	48 8b 4b 10          	mov    rcx,QWORD PTR [rbx+0x10]
  21602b:	48 3b 0b             	cmp    rcx,QWORD PTR [rbx]
                mem.swap(T, &items[1], &items[2]);
                if (lessThan(items[1], items[0])) mem.swap(T, &items[0], &items[1]);
  21602e:	0f 83 9a 83 00 00    	jae    21e3ce <Benchmark_reportStats+0x87ce>
    const tmp = a.*;
  216034:	c5 f8 10 03          	vmovups xmm0,XMMWORD PTR [rbx]
  216038:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  21603f:	00 00 
  216041:	e9 73 83 00 00       	jmp    21e3b9 <Benchmark_reportStats+0x87b9>
pub fn floorPowerOfTwo(comptime T: type, value: T) T {
    var x = value;

    comptime var i = 1;
    inline while (T.bit_count > i) : (i *= 2) {
        x |= (x >> i);
  216046:	48 89 c2             	mov    rdx,rax
  216049:	48 d1 ea             	shr    rdx,1
  21604c:	48 09 c2             	or     rdx,rax
  21604f:	48 89 d1             	mov    rcx,rdx
  216052:	48 c1 e9 02          	shr    rcx,0x2
  216056:	48 09 d1             	or     rcx,rdx
  216059:	48 89 ca             	mov    rdx,rcx
  21605c:	48 c1 ea 04          	shr    rdx,0x4
  216060:	48 09 ca             	or     rdx,rcx
  216063:	48 89 d1             	mov    rcx,rdx
  216066:	48 c1 e9 08          	shr    rcx,0x8
  21606a:	48 09 d1             	or     rcx,rdx
  21606d:	48 89 ca             	mov    rdx,rcx
  216070:	48 c1 ea 10          	shr    rdx,0x10
  216074:	48 09 ca             	or     rdx,rcx
  216077:	49 89 d7             	mov    r15,rdx
  21607a:	49 c1 ef 20          	shr    r15,0x20
  21607e:	49 09 d7             	or     r15,rdx
    }

    return x - (x >> 1);
  216081:	4c 89 f9             	mov    rcx,r15
  216084:	48 d1 e9             	shr    rcx,1
  216087:	49 29 cf             	sub    r15,rcx
        const denominator = power_of_two / min_level;
  21608a:	49 c1 ef 02          	shr    r15,0x2
  21608e:	48 89 c1             	mov    rcx,rax
  216091:	4c 09 f9             	or     rcx,r15
  216094:	48 c1 e9 20          	shr    rcx,0x20
  216098:	48 89 84 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rax
  21609f:	00 
  2160a0:	74 07                	je     2160a9 <Benchmark_reportStats+0x4a9>
  2160a2:	31 d2                	xor    edx,edx
  2160a4:	49 f7 f7             	div    r15
  2160a7:	eb 05                	jmp    2160ae <Benchmark_reportStats+0x4ae>
  2160a9:	31 d2                	xor    edx,edx
  2160ab:	41 f7 f7             	div    r15d
  2160ae:	31 ff                	xor    edi,edi
  2160b0:	31 f6                	xor    esi,esi
  2160b2:	4c 89 bc 24 00 01 00 	mov    QWORD PTR [rsp+0x100],r15
  2160b9:	00 
  2160ba:	48 89 84 24 d8 00 00 	mov    QWORD PTR [rsp+0xd8],rax
  2160c1:	00 
  2160c2:	48 89 94 24 e0 00 00 	mov    QWORD PTR [rsp+0xe0],rdx
  2160c9:	00 
  2160ca:	eb 1f                	jmp    2160eb <Benchmark_reportStats+0x4eb>
  2160cc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  2160d0:	4c 29 ee             	sub    rsi,r13
    var iterator = Iterator.init(items.len, 4);
    while (!iterator.finished()) {
        var order = []u8{ 0, 1, 2, 3, 4, 5, 6, 7 };
        const range = iterator.nextRange();

        const sliced_items = items[range.start..];
  2160d3:	48 8b 5c 24 40       	mov    rbx,QWORD PTR [rsp+0x40]
  2160d8:	4c 89 d7             	mov    rdi,r10
  2160db:	48 8b 84 24 d8 00 00 	mov    rax,QWORD PTR [rsp+0xd8]
  2160e2:	00 
  2160e3:	48 8b 94 24 e0 00 00 	mov    rdx,QWORD PTR [rsp+0xe0]
  2160ea:	00 
        self.decimal += self.decimal_step;
  2160eb:	48 8d 0c 07          	lea    rcx,[rdi+rax*1]
        self.numerator += self.numerator_step;
  2160ef:	48 01 d6             	add    rsi,rdx
        if (self.numerator >= self.denominator) {
  2160f2:	45 31 d2             	xor    r10d,r10d
  2160f5:	4c 39 fe             	cmp    rsi,r15
  2160f8:	41 0f 93 c2          	setae  r10b
  2160fc:	41 bd 00 00 00 00    	mov    r13d,0x0
  216102:	4d 0f 43 ef          	cmovae r13,r15
  216106:	49 01 ca             	add    r10,rcx
        return self.end - self.start;
  216109:	4c 89 d1             	mov    rcx,r10
  21610c:	48 29 f9             	sub    rcx,rdi
        switch (range.length()) {
  21610f:	48 83 c1 fc          	add    rcx,0xfffffffffffffffc
  216113:	48 83 f9 04          	cmp    rcx,0x4
  216117:	0f 87 93 13 00 00    	ja     2174b0 <Benchmark_reportStats+0x18b0>
  21611d:	48 c1 e7 04          	shl    rdi,0x4
  216121:	48 01 fb             	add    rbx,rdi
  216124:	48 8d 05 e5 ab fe ff 	lea    rax,[rip+0xfffffffffffeabe5]        # 200d10 <__unnamed_621+0x58>
  21612b:	48 89 c2             	mov    rdx,rax
  21612e:	48 63 04 8a          	movsxd rax,DWORD PTR [rdx+rcx*4]
  216132:	48 01 d0             	add    rax,rdx
  216135:	ff e0                	jmp    rax
    // copy the remainder of A into the final array
    mem.copy(T, items[insert_index..], cache[A_index..A_last]);
}

fn swap(comptime T: type, items: []T, lessThan: fn (lhs: T, rhs: T) bool, order: *[8]u8, x: usize, y: usize) void {
    if (lessThan(items[y], items[x]) or ((order.*)[x] > (order.*)[y] and !lessThan(items[x], items[y]))) {
  216137:	48 8d 43 10          	lea    rax,[rbx+0x10]
  21613b:	48 8b 4b 10          	mov    rcx,QWORD PTR [rbx+0x10]
  21613f:	48 3b 0b             	cmp    rcx,QWORD PTR [rbx]
  216142:	0f 83 48 01 00 00    	jae    216290 <Benchmark_reportStats+0x690>
  216148:	c5 f8 10 03          	vmovups xmm0,XMMWORD PTR [rbx]
  21614c:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  216153:	00 00 
    a.* = b.*;
  216155:	c5 f8 10 00          	vmovups xmm0,XMMWORD PTR [rax]
  216159:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
    b.* = tmp;
  21615d:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  216164:	00 00 
  216166:	c5 fa 7f 00          	vmovdqu XMMWORD PTR [rax],xmm0
  21616a:	41 b3 01             	mov    r11b,0x1
  21616d:	45 31 f6             	xor    r14d,r14d
  216170:	e9 21 01 00 00       	jmp    216296 <Benchmark_reportStats+0x696>
  216175:	4c 8d 63 10          	lea    r12,[rbx+0x10]
  216179:	48 8b 43 10          	mov    rax,QWORD PTR [rbx+0x10]
  21617d:	48 3b 03             	cmp    rax,QWORD PTR [rbx]
  216180:	48 89 74 24 38       	mov    QWORD PTR [rsp+0x38],rsi
  216185:	4c 89 6c 24 18       	mov    QWORD PTR [rsp+0x18],r13
  21618a:	0f 83 55 01 00 00    	jae    2162e5 <Benchmark_reportStats+0x6e5>
    const tmp = a.*;
  216190:	c5 f8 10 03          	vmovups xmm0,XMMWORD PTR [rbx]
  216194:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  21619b:	00 00 
    a.* = b.*;
  21619d:	c4 c1 78 10 04 24    	vmovups xmm0,XMMWORD PTR [r12]
  2161a3:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
    b.* = tmp;
  2161a7:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  2161ae:	00 00 
  2161b0:	c4 c1 7a 7f 04 24    	vmovdqu XMMWORD PTR [r12],xmm0
  2161b6:	41 b0 01             	mov    r8b,0x1
  2161b9:	45 31 db             	xor    r11d,r11d
  2161bc:	e9 2a 01 00 00       	jmp    2162eb <Benchmark_reportStats+0x6eb>
  2161c1:	4c 8d 43 20          	lea    r8,[rbx+0x20]
  2161c5:	4c 8d 4b 10          	lea    r9,[rbx+0x10]
  2161c9:	48 8b 43 20          	mov    rax,QWORD PTR [rbx+0x20]
  2161cd:	48 3b 43 10          	cmp    rax,QWORD PTR [rbx+0x10]
  2161d1:	0f 83 a4 01 00 00    	jae    21637b <Benchmark_reportStats+0x77b>
    const tmp = a.*;
  2161d7:	c4 c1 78 10 01       	vmovups xmm0,XMMWORD PTR [r9]
  2161dc:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  2161e3:	00 00 
    a.* = b.*;
  2161e5:	c4 c1 78 10 00       	vmovups xmm0,XMMWORD PTR [r8]
  2161ea:	c4 c1 78 11 01       	vmovups XMMWORD PTR [r9],xmm0
    b.* = tmp;
  2161ef:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  2161f6:	00 00 
  2161f8:	c4 c1 7a 7f 00       	vmovdqu XMMWORD PTR [r8],xmm0
  2161fd:	41 b7 02             	mov    r15b,0x2
  216200:	b0 01                	mov    al,0x1
  216202:	e9 79 01 00 00       	jmp    216380 <Benchmark_reportStats+0x780>
  216207:	48 8d 7b 20          	lea    rdi,[rbx+0x20]
  21620b:	4c 8d 7b 10          	lea    r15,[rbx+0x10]
  21620f:	48 8b 43 20          	mov    rax,QWORD PTR [rbx+0x20]
  216213:	48 3b 43 10          	cmp    rax,QWORD PTR [rbx+0x10]
  216217:	0f 83 bd 01 00 00    	jae    2163da <Benchmark_reportStats+0x7da>
    const tmp = a.*;
  21621d:	c4 c1 78 10 07       	vmovups xmm0,XMMWORD PTR [r15]
  216222:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  216229:	00 00 
    a.* = b.*;
  21622b:	c5 f8 10 07          	vmovups xmm0,XMMWORD PTR [rdi]
  21622f:	c4 c1 78 11 07       	vmovups XMMWORD PTR [r15],xmm0
    b.* = tmp;
  216234:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  21623b:	00 00 
  21623d:	c5 fa 7f 07          	vmovdqu XMMWORD PTR [rdi],xmm0
  216241:	b0 02                	mov    al,0x2
  216243:	41 b4 01             	mov    r12b,0x1
  216246:	e9 94 01 00 00       	jmp    2163df <Benchmark_reportStats+0x7df>
  21624b:	4c 8d 63 10          	lea    r12,[rbx+0x10]
  21624f:	48 8b 43 10          	mov    rax,QWORD PTR [rbx+0x10]
  216253:	48 3b 03             	cmp    rax,QWORD PTR [rbx]
  216256:	0f 83 cd 01 00 00    	jae    216429 <Benchmark_reportStats+0x829>
    const tmp = a.*;
  21625c:	c5 f8 10 03          	vmovups xmm0,XMMWORD PTR [rbx]
  216260:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  216267:	00 00 
    a.* = b.*;
  216269:	c4 c1 78 10 04 24    	vmovups xmm0,XMMWORD PTR [r12]
  21626f:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
    b.* = tmp;
  216273:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  21627a:	00 00 
  21627c:	c4 c1 7a 7f 04 24    	vmovdqu XMMWORD PTR [r12],xmm0
  216282:	b0 01                	mov    al,0x1
  216284:	89 44 24 20          	mov    DWORD PTR [rsp+0x20],eax
  216288:	45 31 c9             	xor    r9d,r9d
  21628b:	e9 a4 01 00 00       	jmp    216434 <Benchmark_reportStats+0x834>
  216290:	41 b6 01             	mov    r14b,0x1
  216293:	45 31 db             	xor    r11d,r11d
  216296:	48 8d 53 30          	lea    rdx,[rbx+0x30]
  21629a:	48 8d 4b 20          	lea    rcx,[rbx+0x20]
  21629e:	48 8b 7b 20          	mov    rdi,QWORD PTR [rbx+0x20]
  2162a2:	48 39 7b 30          	cmp    QWORD PTR [rbx+0x30],rdi
  2162a6:	0f 83 cf 01 00 00    	jae    21647b <Benchmark_reportStats+0x87b>
    const tmp = a.*;
  2162ac:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  2162b0:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  2162b7:	00 00 
    a.* = b.*;
  2162b9:	c5 f8 10 02          	vmovups xmm0,XMMWORD PTR [rdx]
  2162bd:	c5 f8 11 01          	vmovups XMMWORD PTR [rcx],xmm0
    b.* = tmp;
  2162c1:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  2162c8:	00 00 
  2162ca:	c5 fa 7f 02          	vmovdqu XMMWORD PTR [rdx],xmm0
  2162ce:	48 8b 39             	mov    rdi,QWORD PTR [rcx]
  2162d1:	41 b0 03             	mov    r8b,0x3
  2162d4:	41 b1 02             	mov    r9b,0x2
  2162d7:	48 3b 3b             	cmp    rdi,QWORD PTR [rbx]
  2162da:	0f 82 a6 01 00 00    	jb     216486 <Benchmark_reportStats+0x886>
  2162e0:	e9 c6 01 00 00       	jmp    2164ab <Benchmark_reportStats+0x8ab>
  2162e5:	41 b3 01             	mov    r11b,0x1
  2162e8:	45 31 c0             	xor    r8d,r8d
  2162eb:	48 8d 73 40          	lea    rsi,[rbx+0x40]
  2162ef:	4c 8d 6b 30          	lea    r13,[rbx+0x30]
  2162f3:	48 8b 4b 40          	mov    rcx,QWORD PTR [rbx+0x40]
  2162f7:	48 3b 4b 30          	cmp    rcx,QWORD PTR [rbx+0x30]
  2162fb:	0f 83 32 02 00 00    	jae    216533 <Benchmark_reportStats+0x933>
    const tmp = a.*;
  216301:	c4 c1 78 10 45 00    	vmovups xmm0,XMMWORD PTR [r13+0x0]
  216307:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  21630e:	00 00 
    a.* = b.*;
  216310:	c5 f8 10 06          	vmovups xmm0,XMMWORD PTR [rsi]
  216314:	c4 c1 78 11 45 00    	vmovups XMMWORD PTR [r13+0x0],xmm0
    b.* = tmp;
  21631a:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  216321:	00 00 
  216323:	c5 fa 7f 06          	vmovdqu XMMWORD PTR [rsi],xmm0
  216327:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  21632a:	41 b1 04             	mov    r9b,0x4
  21632d:	b2 03                	mov    dl,0x3
  21632f:	48 8d 7b 20          	lea    rdi,[rbx+0x20]
  216333:	48 8b 43 20          	mov    rax,QWORD PTR [rbx+0x20]
  216337:	48 39 c1             	cmp    rcx,rax
  21633a:	0f 82 09 02 00 00    	jb     216549 <Benchmark_reportStats+0x949>
  216340:	41 89 d7             	mov    r15d,edx
  216343:	b2 02                	mov    dl,0x2
  216345:	49 8b 4d 00          	mov    rcx,QWORD PTR [r13+0x0]
  216349:	48 39 c1             	cmp    rcx,rax
  21634c:	0f 82 2c 02 00 00    	jb     21657e <Benchmark_reportStats+0x97e>
  216352:	44 38 ca             	cmp    dl,r9b
  216355:	76 09                	jbe    216360 <Benchmark_reportStats+0x760>
  216357:	48 39 c8             	cmp    rax,rcx
  21635a:	0f 83 1e 02 00 00    	jae    21657e <Benchmark_reportStats+0x97e>
  216360:	45 89 ce             	mov    r14d,r9d
  216363:	41 89 d1             	mov    r9d,edx
  216366:	48 8b 06             	mov    rax,QWORD PTR [rsi]
  216369:	49 8b 0c 24          	mov    rcx,QWORD PTR [r12]
  21636d:	48 39 c8             	cmp    rax,rcx
  216370:	0f 83 3d 02 00 00    	jae    2165b3 <Benchmark_reportStats+0x9b3>
  216376:	e9 42 02 00 00       	jmp    2165bd <Benchmark_reportStats+0x9bd>
  21637b:	41 b7 01             	mov    r15b,0x1
  21637e:	b0 02                	mov    al,0x2
  216380:	89 44 24 10          	mov    DWORD PTR [rsp+0x10],eax
  216384:	4c 8d 73 50          	lea    r14,[rbx+0x50]
  216388:	48 8d 7b 40          	lea    rdi,[rbx+0x40]
  21638c:	48 8b 43 50          	mov    rax,QWORD PTR [rbx+0x50]
  216390:	48 3b 43 40          	cmp    rax,QWORD PTR [rbx+0x40]
  216394:	0f 83 04 03 00 00    	jae    21669e <Benchmark_reportStats+0xa9e>
    const tmp = a.*;
  21639a:	c5 f8 10 07          	vmovups xmm0,XMMWORD PTR [rdi]
  21639e:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  2163a5:	00 00 
    a.* = b.*;
  2163a7:	c4 c1 78 10 06       	vmovups xmm0,XMMWORD PTR [r14]
  2163ac:	c5 f8 11 07          	vmovups XMMWORD PTR [rdi],xmm0
    b.* = tmp;
  2163b0:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  2163b7:	00 00 
  2163b9:	c4 c1 7a 7f 06       	vmovdqu XMMWORD PTR [r14],xmm0
  2163be:	c6 44 24 20 05       	mov    BYTE PTR [rsp+0x20],0x5
  2163c3:	41 b4 04             	mov    r12b,0x4
  2163c6:	48 8b 43 20          	mov    rax,QWORD PTR [rbx+0x20]
  2163ca:	48 3b 03             	cmp    rax,QWORD PTR [rbx]
  2163cd:	0f 82 e0 02 00 00    	jb     2166b3 <Benchmark_reportStats+0xab3>
  2163d3:	31 c9                	xor    ecx,ecx
  2163d5:	e9 0b 03 00 00       	jmp    2166e5 <Benchmark_reportStats+0xae5>
  2163da:	b0 01                	mov    al,0x1
  2163dc:	41 b4 02             	mov    r12b,0x2
  2163df:	88 44 24 58          	mov    BYTE PTR [rsp+0x58],al
  2163e3:	4c 8d 5b 40          	lea    r11,[rbx+0x40]
  2163e7:	4c 8d 4b 30          	lea    r9,[rbx+0x30]
  2163eb:	48 8b 43 40          	mov    rax,QWORD PTR [rbx+0x40]
  2163ef:	48 3b 43 30          	cmp    rax,QWORD PTR [rbx+0x30]
  2163f3:	0f 83 68 03 00 00    	jae    216761 <Benchmark_reportStats+0xb61>
    const tmp = a.*;
  2163f9:	c4 c1 78 10 01       	vmovups xmm0,XMMWORD PTR [r9]
  2163fe:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  216405:	00 00 
    a.* = b.*;
  216407:	c4 c1 78 10 03       	vmovups xmm0,XMMWORD PTR [r11]
  21640c:	c4 c1 78 11 01       	vmovups XMMWORD PTR [r9],xmm0
    b.* = tmp;
  216411:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  216418:	00 00 
  21641a:	c4 c1 7a 7f 03       	vmovdqu XMMWORD PTR [r11],xmm0
  21641f:	41 b6 04             	mov    r14b,0x4
  216422:	b0 03                	mov    al,0x3
  216424:	e9 3d 03 00 00       	jmp    216766 <Benchmark_reportStats+0xb66>
  216429:	41 b1 01             	mov    r9b,0x1
  21642c:	c7 44 24 20 00 00 00 	mov    DWORD PTR [rsp+0x20],0x0
  216433:	00 
  216434:	48 8d 7b 30          	lea    rdi,[rbx+0x30]
  216438:	4c 8d 5b 20          	lea    r11,[rbx+0x20]
  21643c:	48 8b 43 30          	mov    rax,QWORD PTR [rbx+0x30]
  216440:	48 3b 43 20          	cmp    rax,QWORD PTR [rbx+0x20]
  216444:	0f 83 82 03 00 00    	jae    2167cc <Benchmark_reportStats+0xbcc>
    const tmp = a.*;
  21644a:	c4 c1 78 10 03       	vmovups xmm0,XMMWORD PTR [r11]
  21644f:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  216456:	00 00 
    a.* = b.*;
  216458:	c5 f8 10 07          	vmovups xmm0,XMMWORD PTR [rdi]
  21645c:	c4 c1 78 11 03       	vmovups XMMWORD PTR [r11],xmm0
    b.* = tmp;
  216461:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  216468:	00 00 
  21646a:	c5 fa 7f 07          	vmovdqu XMMWORD PTR [rdi],xmm0
  21646e:	41 b0 03             	mov    r8b,0x3
  216471:	c6 44 24 10 02       	mov    BYTE PTR [rsp+0x10],0x2
  216476:	e9 59 03 00 00       	jmp    2167d4 <Benchmark_reportStats+0xbd4>
  21647b:	41 b0 02             	mov    r8b,0x2
  21647e:	41 b1 03             	mov    r9b,0x3
  216481:	48 3b 3b             	cmp    rdi,QWORD PTR [rbx]
  216484:	73 25                	jae    2164ab <Benchmark_reportStats+0x8ab>
    const tmp = a.*;
  216486:	c5 f8 10 03          	vmovups xmm0,XMMWORD PTR [rbx]
  21648a:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  216491:	00 00 
    a.* = b.*;
  216493:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  216497:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
    b.* = tmp;
  21649b:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  2164a2:	00 00 
  2164a4:	c5 fa 7f 01          	vmovdqu XMMWORD PTR [rcx],xmm0
  2164a8:	45 89 d8             	mov    r8d,r11d
  2164ab:	48 8b 38             	mov    rdi,QWORD PTR [rax]
  2164ae:	48 39 3a             	cmp    QWORD PTR [rdx],rdi
  2164b1:	73 43                	jae    2164f6 <Benchmark_reportStats+0x8f6>
    const tmp = a.*;
  2164b3:	c5 f8 10 00          	vmovups xmm0,XMMWORD PTR [rax]
  2164b7:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  2164be:	00 00 
    a.* = b.*;
  2164c0:	c5 f8 10 02          	vmovups xmm0,XMMWORD PTR [rdx]
  2164c4:	c5 f8 11 00          	vmovups XMMWORD PTR [rax],xmm0
    b.* = tmp;
  2164c8:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  2164cf:	00 00 
  2164d1:	c5 fa 7f 02          	vmovdqu XMMWORD PTR [rdx],xmm0
  2164d5:	48 8b 38             	mov    rdi,QWORD PTR [rax]
  2164d8:	45 89 ce             	mov    r14d,r9d
  2164db:	48 8b 11             	mov    rdx,QWORD PTR [rcx]
  2164de:	48 39 fa             	cmp    rdx,rdi
  2164e1:	72 1b                	jb     2164fe <Benchmark_reportStats+0x8fe>
  2164e3:	45 38 c6             	cmp    r14b,r8b
  2164e6:	0f 86 c4 0f 00 00    	jbe    2174b0 <Benchmark_reportStats+0x18b0>
  2164ec:	48 39 d7             	cmp    rdi,rdx
  2164ef:	73 0d                	jae    2164fe <Benchmark_reportStats+0x8fe>
  2164f1:	e9 ba 0f 00 00       	jmp    2174b0 <Benchmark_reportStats+0x18b0>
  2164f6:	48 8b 11             	mov    rdx,QWORD PTR [rcx]
  2164f9:	48 39 fa             	cmp    rdx,rdi
  2164fc:	73 e5                	jae    2164e3 <Benchmark_reportStats+0x8e3>
    const tmp = a.*;
  2164fe:	c5 f8 10 00          	vmovups xmm0,XMMWORD PTR [rax]
  216502:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  216509:	00 00 
    a.* = b.*;
  21650b:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  21650f:	c5 f8 11 00          	vmovups XMMWORD PTR [rax],xmm0
    b.* = tmp;
  216513:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  21651a:	00 00 
  21651c:	c5 fa 7f 01          	vmovdqu XMMWORD PTR [rcx],xmm0
        return self.decimal >= self.size;
  216520:	4c 3b 94 24 f0 00 00 	cmp    r10,QWORD PTR [rsp+0xf0]
  216527:	00 
  216528:	0f 82 a2 fb ff ff    	jb     2160d0 <Benchmark_reportStats+0x4d0>
  21652e:	e9 a6 0f 00 00       	jmp    2174d9 <Benchmark_reportStats+0x18d9>
  216533:	41 b1 03             	mov    r9b,0x3
  216536:	b2 04                	mov    dl,0x4
    if (lessThan(items[y], items[x]) or ((order.*)[x] > (order.*)[y] and !lessThan(items[x], items[y]))) {
  216538:	48 8d 7b 20          	lea    rdi,[rbx+0x20]
  21653c:	48 8b 43 20          	mov    rax,QWORD PTR [rbx+0x20]
  216540:	48 39 c1             	cmp    rcx,rax
  216543:	0f 83 f7 fd ff ff    	jae    216340 <Benchmark_reportStats+0x740>
    const tmp = a.*;
  216549:	c5 f8 10 07          	vmovups xmm0,XMMWORD PTR [rdi]
  21654d:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  216554:	00 00 
    a.* = b.*;
  216556:	c5 f8 10 06          	vmovups xmm0,XMMWORD PTR [rsi]
  21655a:	c5 f8 11 07          	vmovups XMMWORD PTR [rdi],xmm0
    b.* = tmp;
  21655e:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  216565:	00 00 
  216567:	c5 fa 7f 06          	vmovdqu XMMWORD PTR [rsi],xmm0
  21656b:	48 8b 07             	mov    rax,QWORD PTR [rdi]
  21656e:	41 b7 02             	mov    r15b,0x2
  216571:	49 8b 4d 00          	mov    rcx,QWORD PTR [r13+0x0]
  216575:	48 39 c1             	cmp    rcx,rax
  216578:	0f 83 d4 fd ff ff    	jae    216352 <Benchmark_reportStats+0x752>
    const tmp = a.*;
  21657e:	c5 f8 10 07          	vmovups xmm0,XMMWORD PTR [rdi]
  216582:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  216589:	00 00 
    a.* = b.*;
  21658b:	c4 c1 78 10 45 00    	vmovups xmm0,XMMWORD PTR [r13+0x0]
  216591:	c5 f8 11 07          	vmovups XMMWORD PTR [rdi],xmm0
    b.* = tmp;
  216595:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  21659c:	00 00 
  21659e:	c4 c1 7a 7f 45 00    	vmovdqu XMMWORD PTR [r13+0x0],xmm0
  2165a4:	41 89 d6             	mov    r14d,edx
  2165a7:	48 8b 06             	mov    rax,QWORD PTR [rsi]
  2165aa:	49 8b 0c 24          	mov    rcx,QWORD PTR [r12]
  2165ae:	48 39 c8             	cmp    rax,rcx
  2165b1:	72 0a                	jb     2165bd <Benchmark_reportStats+0x9bd>
  2165b3:	45 38 fb             	cmp    r11b,r15b
  2165b6:	76 2e                	jbe    2165e6 <Benchmark_reportStats+0x9e6>
  2165b8:	48 39 c1             	cmp    rcx,rax
  2165bb:	72 29                	jb     2165e6 <Benchmark_reportStats+0x9e6>
    const tmp = a.*;
  2165bd:	c4 c1 78 10 04 24    	vmovups xmm0,XMMWORD PTR [r12]
  2165c3:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  2165ca:	00 00 
    a.* = b.*;
  2165cc:	c5 f8 10 06          	vmovups xmm0,XMMWORD PTR [rsi]
  2165d0:	c4 c1 78 11 04 24    	vmovups XMMWORD PTR [r12],xmm0
    b.* = tmp;
  2165d6:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  2165dd:	00 00 
  2165df:	c5 fa 7f 06          	vmovdqu XMMWORD PTR [rsi],xmm0
  2165e3:	45 89 fb             	mov    r11d,r15d
  2165e6:	48 8b 13             	mov    rdx,QWORD PTR [rbx]
  2165e9:	48 8b 43 30          	mov    rax,QWORD PTR [rbx+0x30]
  2165ed:	48 39 d0             	cmp    rax,rdx
  2165f0:	4c 8b bc 24 00 01 00 	mov    r15,QWORD PTR [rsp+0x100]
  2165f7:	00 
  2165f8:	48 8b 74 24 38       	mov    rsi,QWORD PTR [rsp+0x38]
  2165fd:	72 12                	jb     216611 <Benchmark_reportStats+0xa11>
  2165ff:	45 38 f0             	cmp    r8b,r14b
  216602:	0f 86 de 05 00 00    	jbe    216be6 <Benchmark_reportStats+0xfe6>
  216608:	48 39 c2             	cmp    rdx,rax
  21660b:	0f 82 d5 05 00 00    	jb     216be6 <Benchmark_reportStats+0xfe6>
    const tmp = a.*;
  216611:	c5 f8 10 03          	vmovups xmm0,XMMWORD PTR [rbx]
  216615:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  21661c:	00 00 
    a.* = b.*;
  21661e:	c4 c1 78 10 45 00    	vmovups xmm0,XMMWORD PTR [r13+0x0]
  216624:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
    b.* = tmp;
  216628:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  21662f:	00 00 
  216631:	c4 c1 7a 7f 45 00    	vmovdqu XMMWORD PTR [r13+0x0],xmm0
  216637:	48 8b 13             	mov    rdx,QWORD PTR [rbx]
  21663a:	44 89 f0             	mov    eax,r14d
  21663d:	48 8b 0f             	mov    rcx,QWORD PTR [rdi]
  216640:	48 39 d1             	cmp    rcx,rdx
  216643:	0f 82 af 05 00 00    	jb     216bf8 <Benchmark_reportStats+0xff8>
  216649:	44 38 c8             	cmp    al,r9b
  21664c:	76 09                	jbe    216657 <Benchmark_reportStats+0xa57>
  21664e:	48 39 ca             	cmp    rdx,rcx
  216651:	0f 83 a1 05 00 00    	jae    216bf8 <Benchmark_reportStats+0xff8>
  216657:	49 8b 45 00          	mov    rax,QWORD PTR [r13+0x0]
  21665b:	49 8b 14 24          	mov    rdx,QWORD PTR [r12]
  21665f:	48 39 d0             	cmp    rax,rdx
  216662:	0f 82 c6 05 00 00    	jb     216c2e <Benchmark_reportStats+0x102e>
  216668:	45 38 c3             	cmp    r11b,r8b
  21666b:	76 09                	jbe    216676 <Benchmark_reportStats+0xa76>
  21666d:	48 39 c2             	cmp    rdx,rax
  216670:	0f 83 b8 05 00 00    	jae    216c2e <Benchmark_reportStats+0x102e>
  216676:	48 8b 07             	mov    rax,QWORD PTR [rdi]
  216679:	48 39 d0             	cmp    rax,rdx
  21667c:	4c 8b 6c 24 18       	mov    r13,QWORD PTR [rsp+0x18]
  216681:	0f 82 e9 05 00 00    	jb     216c70 <Benchmark_reportStats+0x1070>
  216687:	45 38 cb             	cmp    r11b,r9b
  21668a:	0f 86 20 0e 00 00    	jbe    2174b0 <Benchmark_reportStats+0x18b0>
  216690:	48 39 c2             	cmp    rdx,rax
  216693:	0f 83 d7 05 00 00    	jae    216c70 <Benchmark_reportStats+0x1070>
  216699:	e9 12 0e 00 00       	jmp    2174b0 <Benchmark_reportStats+0x18b0>
  21669e:	c6 44 24 20 04       	mov    BYTE PTR [rsp+0x20],0x4
  2166a3:	41 b4 05             	mov    r12b,0x5
  2166a6:	48 8b 43 20          	mov    rax,QWORD PTR [rbx+0x20]
  2166aa:	48 3b 03             	cmp    rax,QWORD PTR [rbx]
  2166ad:	0f 83 20 fd ff ff    	jae    2163d3 <Benchmark_reportStats+0x7d3>
    const tmp = a.*;
  2166b3:	c5 f8 10 03          	vmovups xmm0,XMMWORD PTR [rbx]
  2166b7:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  2166be:	00 00 
    a.* = b.*;
  2166c0:	c4 c1 78 10 00       	vmovups xmm0,XMMWORD PTR [r8]
  2166c5:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
    b.* = tmp;
  2166c9:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  2166d0:	00 00 
  2166d2:	c4 c1 7a 7f 00       	vmovdqu XMMWORD PTR [r8],xmm0
  2166d7:	8b 44 24 10          	mov    eax,DWORD PTR [rsp+0x10]
  2166db:	89 c1                	mov    ecx,eax
  2166dd:	c7 44 24 10 00 00 00 	mov    DWORD PTR [rsp+0x10],0x0
  2166e4:	00 
  2166e5:	4c 89 6c 24 18       	mov    QWORD PTR [rsp+0x18],r13
  2166ea:	4c 8d 5b 30          	lea    r11,[rbx+0x30]
  2166ee:	48 8b 43 50          	mov    rax,QWORD PTR [rbx+0x50]
  2166f2:	48 3b 43 30          	cmp    rax,QWORD PTR [rbx+0x30]
  2166f6:	0f 83 2d 01 00 00    	jae    216829 <Benchmark_reportStats+0xc29>
    const tmp = a.*;
  2166fc:	c4 c1 78 10 03       	vmovups xmm0,XMMWORD PTR [r11]
  216701:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  216708:	00 00 
    a.* = b.*;
  21670a:	c4 c1 78 10 06       	vmovups xmm0,XMMWORD PTR [r14]
  21670f:	c4 c1 78 11 03       	vmovups XMMWORD PTR [r11],xmm0
    b.* = tmp;
  216714:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  21671b:	00 00 
  21671d:	c4 c1 7a 7f 06       	vmovdqu XMMWORD PTR [r14],xmm0
  216722:	41 b5 03             	mov    r13b,0x3
  216725:	48 8b 13             	mov    rdx,QWORD PTR [rbx]
  216728:	48 8b 43 10          	mov    rax,QWORD PTR [rbx+0x10]
  21672c:	48 39 d0             	cmp    rax,rdx
  21672f:	0f 82 0a 01 00 00    	jb     21683f <Benchmark_reportStats+0xc3f>
  216735:	44 38 f9             	cmp    cl,r15b
  216738:	76 09                	jbe    216743 <Benchmark_reportStats+0xb43>
  21673a:	48 39 c2             	cmp    rdx,rax
  21673d:	0f 83 fc 00 00 00    	jae    21683f <Benchmark_reportStats+0xc3f>
  216743:	44 89 f8             	mov    eax,r15d
  216746:	41 89 cf             	mov    r15d,ecx
  216749:	89 44 24 30          	mov    DWORD PTR [rsp+0x30],eax
  21674d:	48 8b 17             	mov    rdx,QWORD PTR [rdi]
  216750:	49 8b 03             	mov    rax,QWORD PTR [r11]
  216753:	48 39 c2             	cmp    rdx,rax
  216756:	0f 83 16 01 00 00    	jae    216872 <Benchmark_reportStats+0xc72>
  21675c:	e9 25 01 00 00       	jmp    216886 <Benchmark_reportStats+0xc86>
  216761:	41 b6 03             	mov    r14b,0x3
  216764:	b0 04                	mov    al,0x4
  216766:	4c 89 6c 24 18       	mov    QWORD PTR [rsp+0x18],r13
  21676b:	4c 8d 43 60          	lea    r8,[rbx+0x60]
  21676f:	48 8d 4b 50          	lea    rcx,[rbx+0x50]
  216773:	48 8b 53 60          	mov    rdx,QWORD PTR [rbx+0x60]
  216777:	48 3b 53 50          	cmp    rdx,QWORD PTR [rbx+0x50]
  21677b:	0f 83 33 01 00 00    	jae    2168b4 <Benchmark_reportStats+0xcb4>
    const tmp = a.*;
  216781:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  216785:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  21678c:	00 00 
    a.* = b.*;
  21678e:	c4 c1 78 10 00       	vmovups xmm0,XMMWORD PTR [r8]
  216793:	c5 f8 11 01          	vmovups XMMWORD PTR [rcx],xmm0
    b.* = tmp;
  216797:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  21679e:	00 00 
  2167a0:	c4 c1 7a 7f 00       	vmovdqu XMMWORD PTR [r8],xmm0
  2167a5:	c6 44 24 20 06       	mov    BYTE PTR [rsp+0x20],0x6
  2167aa:	41 b5 05             	mov    r13b,0x5
  2167ad:	48 8b 53 20          	mov    rdx,QWORD PTR [rbx+0x20]
  2167b1:	48 3b 13             	cmp    rdx,QWORD PTR [rbx]
  2167b4:	48 89 74 24 38       	mov    QWORD PTR [rsp+0x38],rsi
  2167b9:	0f 82 0f 01 00 00    	jb     2168ce <Benchmark_reportStats+0xcce>
  2167bf:	c7 44 24 10 00 00 00 	mov    DWORD PTR [rsp+0x10],0x0
  2167c6:	00 
  2167c7:	e9 2c 01 00 00       	jmp    2168f8 <Benchmark_reportStats+0xcf8>
  2167cc:	41 b0 02             	mov    r8b,0x2
  2167cf:	c6 44 24 10 03       	mov    BYTE PTR [rsp+0x10],0x3
  2167d4:	4c 8d 7b 50          	lea    r15,[rbx+0x50]
  2167d8:	4c 8d 73 40          	lea    r14,[rbx+0x40]
  2167dc:	48 8b 43 50          	mov    rax,QWORD PTR [rbx+0x50]
  2167e0:	48 3b 43 40          	cmp    rax,QWORD PTR [rbx+0x40]
  2167e4:	48 89 74 24 38       	mov    QWORD PTR [rsp+0x38],rsi
  2167e9:	4c 89 6c 24 18       	mov    QWORD PTR [rsp+0x18],r13
  2167ee:	0f 83 77 01 00 00    	jae    21696b <Benchmark_reportStats+0xd6b>
    const tmp = a.*;
  2167f4:	c4 c1 78 10 06       	vmovups xmm0,XMMWORD PTR [r14]
  2167f9:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  216800:	00 00 
    a.* = b.*;
  216802:	c4 c1 78 10 07       	vmovups xmm0,XMMWORD PTR [r15]
  216807:	c4 c1 78 11 06       	vmovups XMMWORD PTR [r14],xmm0
    b.* = tmp;
  21680c:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  216813:	00 00 
  216815:	c4 c1 7a 7f 07       	vmovdqu XMMWORD PTR [r15],xmm0
  21681a:	c6 44 24 50 05       	mov    BYTE PTR [rsp+0x50],0x5
  21681f:	c6 44 24 58 04       	mov    BYTE PTR [rsp+0x58],0x4
  216824:	e9 4c 01 00 00       	jmp    216975 <Benchmark_reportStats+0xd75>
  216829:	45 89 e5             	mov    r13d,r12d
  21682c:	41 b4 03             	mov    r12b,0x3
  21682f:	48 8b 13             	mov    rdx,QWORD PTR [rbx]
  216832:	48 8b 43 10          	mov    rax,QWORD PTR [rbx+0x10]
  216836:	48 39 d0             	cmp    rax,rdx
  216839:	0f 83 f6 fe ff ff    	jae    216735 <Benchmark_reportStats+0xb35>
  21683f:	89 4c 24 30          	mov    DWORD PTR [rsp+0x30],ecx
    const tmp = a.*;
  216843:	c5 f8 10 03          	vmovups xmm0,XMMWORD PTR [rbx]
  216847:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  21684e:	00 00 
    a.* = b.*;
  216850:	c4 c1 78 10 01       	vmovups xmm0,XMMWORD PTR [r9]
  216855:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
    b.* = tmp;
  216859:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  216860:	00 00 
  216862:	c4 c1 7a 7f 01       	vmovdqu XMMWORD PTR [r9],xmm0
  216867:	48 8b 17             	mov    rdx,QWORD PTR [rdi]
  21686a:	49 8b 03             	mov    rax,QWORD PTR [r11]
  21686d:	48 39 c2             	cmp    rdx,rax
  216870:	72 14                	jb     216886 <Benchmark_reportStats+0xc86>
  216872:	44 3a 64 24 20       	cmp    r12b,BYTE PTR [rsp+0x20]
  216877:	0f 86 2c 04 00 00    	jbe    216ca9 <Benchmark_reportStats+0x10a9>
  21687d:	48 39 d0             	cmp    rax,rdx
  216880:	0f 82 23 04 00 00    	jb     216ca9 <Benchmark_reportStats+0x10a9>
    const tmp = a.*;
  216886:	c4 c1 78 10 03       	vmovups xmm0,XMMWORD PTR [r11]
  21688b:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  216892:	00 00 
    a.* = b.*;
  216894:	c5 f8 10 07          	vmovups xmm0,XMMWORD PTR [rdi]
  216898:	c4 c1 78 11 03       	vmovups XMMWORD PTR [r11],xmm0
    b.* = tmp;
  21689d:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  2168a4:	00 00 
  2168a6:	c5 fa 7f 07          	vmovdqu XMMWORD PTR [rdi],xmm0
  2168aa:	44 88 64 24 28       	mov    BYTE PTR [rsp+0x28],r12b
  2168af:	e9 03 04 00 00       	jmp    216cb7 <Benchmark_reportStats+0x10b7>
  2168b4:	c6 44 24 20 05       	mov    BYTE PTR [rsp+0x20],0x5
  2168b9:	41 b5 06             	mov    r13b,0x6
  2168bc:	48 8b 53 20          	mov    rdx,QWORD PTR [rbx+0x20]
  2168c0:	48 3b 13             	cmp    rdx,QWORD PTR [rbx]
  2168c3:	48 89 74 24 38       	mov    QWORD PTR [rsp+0x38],rsi
  2168c8:	0f 83 f1 fe ff ff    	jae    2167bf <Benchmark_reportStats+0xbbf>
    const tmp = a.*;
  2168ce:	c5 f8 10 03          	vmovups xmm0,XMMWORD PTR [rbx]
  2168d2:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  2168d9:	00 00 
    a.* = b.*;
  2168db:	c5 f8 10 07          	vmovups xmm0,XMMWORD PTR [rdi]
  2168df:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
    b.* = tmp;
  2168e3:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  2168ea:	00 00 
  2168ec:	c5 fa 7f 07          	vmovdqu XMMWORD PTR [rdi],xmm0
  2168f0:	44 89 64 24 10       	mov    DWORD PTR [rsp+0x10],r12d
  2168f5:	45 31 e4             	xor    r12d,r12d
  2168f8:	48 8b 11             	mov    rdx,QWORD PTR [rcx]
  2168fb:	49 8b 31             	mov    rsi,QWORD PTR [r9]
  2168fe:	48 39 f2             	cmp    rdx,rsi
  216901:	44 89 64 24 30       	mov    DWORD PTR [rsp+0x30],r12d
  216906:	72 14                	jb     21691c <Benchmark_reportStats+0xd1c>
  216908:	44 3a 74 24 20       	cmp    r14b,BYTE PTR [rsp+0x20]
  21690d:	0f 86 e2 04 00 00    	jbe    216df5 <Benchmark_reportStats+0x11f5>
  216913:	48 39 d6             	cmp    rsi,rdx
  216916:	0f 82 d9 04 00 00    	jb     216df5 <Benchmark_reportStats+0x11f5>
    const tmp = a.*;
  21691c:	c4 c1 78 10 01       	vmovups xmm0,XMMWORD PTR [r9]
  216921:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  216928:	00 00 
    a.* = b.*;
  21692a:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  21692e:	c4 c1 78 11 01       	vmovups XMMWORD PTR [r9],xmm0
    b.* = tmp;
  216933:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  21693a:	00 00 
  21693c:	c5 fa 7f 01          	vmovdqu XMMWORD PTR [rcx],xmm0
  216940:	45 89 f4             	mov    r12d,r14d
  216943:	49 8b 10             	mov    rdx,QWORD PTR [r8]
  216946:	49 8b 33             	mov    rsi,QWORD PTR [r11]
  216949:	48 39 f2             	cmp    rdx,rsi
  21694c:	0f 82 bd 04 00 00    	jb     216e0f <Benchmark_reportStats+0x120f>
  216952:	44 38 e8             	cmp    al,r13b
  216955:	76 09                	jbe    216960 <Benchmark_reportStats+0xd60>
  216957:	48 39 d6             	cmp    rsi,rdx
  21695a:	0f 83 af 04 00 00    	jae    216e0f <Benchmark_reportStats+0x120f>
  216960:	45 89 ee             	mov    r14d,r13d
  216963:	41 89 c5             	mov    r13d,eax
  216966:	e9 cd 04 00 00       	jmp    216e38 <Benchmark_reportStats+0x1238>
  21696b:	c6 44 24 50 04       	mov    BYTE PTR [rsp+0x50],0x4
  216970:	c6 44 24 58 05       	mov    BYTE PTR [rsp+0x58],0x5
  216975:	4c 8d 6b 70          	lea    r13,[rbx+0x70]
  216979:	48 8d 73 60          	lea    rsi,[rbx+0x60]
  21697d:	48 8b 53 70          	mov    rdx,QWORD PTR [rbx+0x70]
  216981:	48 3b 53 60          	cmp    rdx,QWORD PTR [rbx+0x60]
  216985:	0f 83 df 00 00 00    	jae    216a6a <Benchmark_reportStats+0xe6a>
    const tmp = a.*;
  21698b:	c5 f8 10 06          	vmovups xmm0,XMMWORD PTR [rsi]
  21698f:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  216996:	00 00 
    a.* = b.*;
  216998:	c4 c1 78 10 45 00    	vmovups xmm0,XMMWORD PTR [r13+0x0]
  21699e:	c5 f8 11 06          	vmovups XMMWORD PTR [rsi],xmm0
    b.* = tmp;
  2169a2:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  2169a9:	00 00 
  2169ab:	c4 c1 7a 7f 45 00    	vmovdqu XMMWORD PTR [r13+0x0],xmm0
  2169b1:	c6 44 24 28 07       	mov    BYTE PTR [rsp+0x28],0x7
  2169b6:	b1 06                	mov    cl,0x6
  2169b8:	48 8b 53 20          	mov    rdx,QWORD PTR [rbx+0x20]
  2169bc:	48 3b 13             	cmp    rdx,QWORD PTR [rbx]
  2169bf:	0f 82 b9 00 00 00    	jb     216a7e <Benchmark_reportStats+0xe7e>
  2169c5:	8b 54 24 20          	mov    edx,DWORD PTR [rsp+0x20]
  2169c9:	89 d0                	mov    eax,edx
  2169cb:	88 44 24 60          	mov    BYTE PTR [rsp+0x60],al
  2169cf:	44 89 c2             	mov    edx,r8d
  2169d2:	89 54 24 20          	mov    DWORD PTR [rsp+0x20],edx
  2169d6:	48 8b 17             	mov    rdx,QWORD PTR [rdi]
  2169d9:	49 3b 14 24          	cmp    rdx,QWORD PTR [r12]
  2169dd:	0f 82 d1 00 00 00    	jb     216ab4 <Benchmark_reportStats+0xeb4>
  2169e3:	0f b6 54 24 10       	movzx  edx,BYTE PTR [rsp+0x10]
  2169e8:	44 89 c8             	mov    eax,r9d
  2169eb:	88 44 24 10          	mov    BYTE PTR [rsp+0x10],al
  2169ef:	88 54 24 30          	mov    BYTE PTR [rsp+0x30],dl
  2169f3:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  2169f6:	49 3b 16             	cmp    rdx,QWORD PTR [r14]
  2169f9:	0f 82 ee 00 00 00    	jb     216aed <Benchmark_reportStats+0xeed>
  2169ff:	44 0f b6 44 24 28    	movzx  r8d,BYTE PTR [rsp+0x28]
  216a05:	0f b6 44 24 50       	movzx  eax,BYTE PTR [rsp+0x50]
  216a0a:	88 44 24 28          	mov    BYTE PTR [rsp+0x28],al
  216a0e:	49 8b 45 00          	mov    rax,QWORD PTR [r13+0x0]
  216a12:	49 3b 07             	cmp    rax,QWORD PTR [r15]
  216a15:	0f 82 09 01 00 00    	jb     216b24 <Benchmark_reportStats+0xf24>
  216a1b:	88 4c 24 50          	mov    BYTE PTR [rsp+0x50],cl
  216a1f:	0f b6 4c 24 58       	movzx  ecx,BYTE PTR [rsp+0x58]
  216a24:	49 8b 13             	mov    rdx,QWORD PTR [r11]
  216a27:	49 8b 04 24          	mov    rax,QWORD PTR [r12]
  216a2b:	48 39 c2             	cmp    rdx,rax
  216a2e:	0f 82 31 01 00 00    	jb     216b65 <Benchmark_reportStats+0xf65>
  216a34:	45 89 c1             	mov    r9d,r8d
  216a37:	44 0f b6 44 24 10    	movzx  r8d,BYTE PTR [rsp+0x10]
  216a3d:	44 3a 44 24 20       	cmp    r8b,BYTE PTR [rsp+0x20]
  216a42:	0f 86 78 0a 00 00    	jbe    2174c0 <Benchmark_reportStats+0x18c0>
  216a48:	48 39 d0             	cmp    rax,rdx
  216a4b:	45 89 c8             	mov    r8d,r9d
  216a4e:	0f 83 11 01 00 00    	jae    216b65 <Benchmark_reportStats+0xf65>
  216a54:	8b 44 24 20          	mov    eax,DWORD PTR [rsp+0x20]
  216a58:	88 44 24 58          	mov    BYTE PTR [rsp+0x58],al
  216a5c:	0f b6 44 24 10       	movzx  eax,BYTE PTR [rsp+0x10]
  216a61:	89 44 24 20          	mov    DWORD PTR [rsp+0x20],eax
  216a65:	e9 2c 01 00 00       	jmp    216b96 <Benchmark_reportStats+0xf96>
  216a6a:	c6 44 24 28 06       	mov    BYTE PTR [rsp+0x28],0x6
  216a6f:	b1 07                	mov    cl,0x7
  216a71:	48 8b 53 20          	mov    rdx,QWORD PTR [rbx+0x20]
  216a75:	48 3b 13             	cmp    rdx,QWORD PTR [rbx]
  216a78:	0f 83 47 ff ff ff    	jae    2169c5 <Benchmark_reportStats+0xdc5>
    const tmp = a.*;
  216a7e:	c5 f8 10 03          	vmovups xmm0,XMMWORD PTR [rbx]
  216a82:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  216a89:	00 00 
    a.* = b.*;
  216a8b:	c4 c1 78 10 03       	vmovups xmm0,XMMWORD PTR [r11]
  216a90:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
    b.* = tmp;
  216a94:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  216a9b:	00 00 
  216a9d:	c4 c1 7a 7f 03       	vmovdqu XMMWORD PTR [r11],xmm0
  216aa2:	44 88 44 24 60       	mov    BYTE PTR [rsp+0x60],r8b
  216aa7:	48 8b 17             	mov    rdx,QWORD PTR [rdi]
  216aaa:	49 3b 14 24          	cmp    rdx,QWORD PTR [r12]
  216aae:	0f 83 2f ff ff ff    	jae    2169e3 <Benchmark_reportStats+0xde3>
    const tmp = a.*;
  216ab4:	c4 c1 78 10 04 24    	vmovups xmm0,XMMWORD PTR [r12]
  216aba:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  216ac1:	00 00 
    a.* = b.*;
  216ac3:	c5 f8 10 07          	vmovups xmm0,XMMWORD PTR [rdi]
  216ac7:	c4 c1 78 11 04 24    	vmovups XMMWORD PTR [r12],xmm0
    b.* = tmp;
  216acd:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  216ad4:	00 00 
  216ad6:	c5 fa 7f 07          	vmovdqu XMMWORD PTR [rdi],xmm0
  216ada:	44 89 ca             	mov    edx,r9d
  216add:	88 54 24 30          	mov    BYTE PTR [rsp+0x30],dl
  216ae1:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  216ae4:	49 3b 16             	cmp    rdx,QWORD PTR [r14]
  216ae7:	0f 83 12 ff ff ff    	jae    2169ff <Benchmark_reportStats+0xdff>
    const tmp = a.*;
  216aed:	c4 c1 78 10 06       	vmovups xmm0,XMMWORD PTR [r14]
  216af2:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  216af9:	00 00 
    a.* = b.*;
  216afb:	c5 f8 10 06          	vmovups xmm0,XMMWORD PTR [rsi]
  216aff:	c4 c1 78 11 06       	vmovups XMMWORD PTR [r14],xmm0
    b.* = tmp;
  216b04:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  216b0b:	00 00 
  216b0d:	c5 fa 7f 06          	vmovdqu XMMWORD PTR [rsi],xmm0
  216b11:	44 0f b6 44 24 50    	movzx  r8d,BYTE PTR [rsp+0x50]
  216b17:	49 8b 45 00          	mov    rax,QWORD PTR [r13+0x0]
  216b1b:	49 3b 07             	cmp    rax,QWORD PTR [r15]
  216b1e:	0f 83 f7 fe ff ff    	jae    216a1b <Benchmark_reportStats+0xe1b>
    const tmp = a.*;
  216b24:	c4 c1 78 10 07       	vmovups xmm0,XMMWORD PTR [r15]
  216b29:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  216b30:	00 00 
    a.* = b.*;
  216b32:	c4 c1 78 10 45 00    	vmovups xmm0,XMMWORD PTR [r13+0x0]
  216b38:	c4 c1 78 11 07       	vmovups XMMWORD PTR [r15],xmm0
    b.* = tmp;
  216b3d:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  216b44:	00 00 
  216b46:	c4 c1 7a 7f 45 00    	vmovdqu XMMWORD PTR [r13+0x0],xmm0
  216b4c:	0f b6 44 24 58       	movzx  eax,BYTE PTR [rsp+0x58]
  216b51:	88 44 24 50          	mov    BYTE PTR [rsp+0x50],al
  216b55:	49 8b 13             	mov    rdx,QWORD PTR [r11]
  216b58:	49 8b 04 24          	mov    rax,QWORD PTR [r12]
  216b5c:	48 39 c2             	cmp    rdx,rax
  216b5f:	0f 83 cf fe ff ff    	jae    216a34 <Benchmark_reportStats+0xe34>
    const tmp = a.*;
  216b65:	c4 c1 78 10 04 24    	vmovups xmm0,XMMWORD PTR [r12]
  216b6b:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  216b72:	00 00 
    a.* = b.*;
  216b74:	c4 c1 78 10 03       	vmovups xmm0,XMMWORD PTR [r11]
  216b79:	c4 c1 78 11 04 24    	vmovups XMMWORD PTR [r12],xmm0
    b.* = tmp;
  216b7f:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  216b86:	00 00 
  216b88:	c4 c1 7a 7f 03       	vmovdqu XMMWORD PTR [r11],xmm0
  216b8d:	0f b6 44 24 10       	movzx  eax,BYTE PTR [rsp+0x10]
  216b92:	88 44 24 58          	mov    BYTE PTR [rsp+0x58],al
  216b96:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  216b99:	49 8b 07             	mov    rax,QWORD PTR [r15]
  216b9c:	48 39 c2             	cmp    rdx,rax
  216b9f:	44 0f b6 4c 24 28    	movzx  r9d,BYTE PTR [rsp+0x28]
  216ba5:	72 12                	jb     216bb9 <Benchmark_reportStats+0xfb9>
  216ba7:	44 38 c1             	cmp    cl,r8b
  216baa:	0f 86 d9 02 00 00    	jbe    216e89 <Benchmark_reportStats+0x1289>
  216bb0:	48 39 d0             	cmp    rax,rdx
  216bb3:	0f 82 d0 02 00 00    	jb     216e89 <Benchmark_reportStats+0x1289>
    const tmp = a.*;
  216bb9:	c4 c1 78 10 07       	vmovups xmm0,XMMWORD PTR [r15]
  216bbe:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  216bc5:	00 00 
    a.* = b.*;
  216bc7:	c5 f8 10 06          	vmovups xmm0,XMMWORD PTR [rsi]
  216bcb:	c4 c1 78 11 07       	vmovups XMMWORD PTR [r15],xmm0
    b.* = tmp;
  216bd0:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  216bd7:	00 00 
  216bd9:	c5 fa 7f 06          	vmovdqu XMMWORD PTR [rsi],xmm0
  216bdd:	88 4c 24 10          	mov    BYTE PTR [rsp+0x10],cl
  216be1:	e9 ab 02 00 00       	jmp    216e91 <Benchmark_reportStats+0x1291>
  216be6:	44 89 c0             	mov    eax,r8d
  216be9:	45 89 f0             	mov    r8d,r14d
  216bec:	48 8b 0f             	mov    rcx,QWORD PTR [rdi]
  216bef:	48 39 d1             	cmp    rcx,rdx
  216bf2:	0f 83 51 fa ff ff    	jae    216649 <Benchmark_reportStats+0xa49>
    const tmp = a.*;
  216bf8:	c5 f8 10 03          	vmovups xmm0,XMMWORD PTR [rbx]
  216bfc:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  216c03:	00 00 
    a.* = b.*;
  216c05:	c5 f8 10 07          	vmovups xmm0,XMMWORD PTR [rdi]
  216c09:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
    b.* = tmp;
  216c0d:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  216c14:	00 00 
  216c16:	c5 fa 7f 07          	vmovdqu XMMWORD PTR [rdi],xmm0
  216c1a:	41 89 c1             	mov    r9d,eax
  216c1d:	49 8b 45 00          	mov    rax,QWORD PTR [r13+0x0]
  216c21:	49 8b 14 24          	mov    rdx,QWORD PTR [r12]
  216c25:	48 39 d0             	cmp    rax,rdx
  216c28:	0f 83 3a fa ff ff    	jae    216668 <Benchmark_reportStats+0xa68>
    const tmp = a.*;
  216c2e:	c4 c1 78 10 04 24    	vmovups xmm0,XMMWORD PTR [r12]
  216c34:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  216c3b:	00 00 
    a.* = b.*;
  216c3d:	c4 c1 78 10 45 00    	vmovups xmm0,XMMWORD PTR [r13+0x0]
  216c43:	c4 c1 78 11 04 24    	vmovups XMMWORD PTR [r12],xmm0
    b.* = tmp;
  216c49:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  216c50:	00 00 
  216c52:	c4 c1 7a 7f 45 00    	vmovdqu XMMWORD PTR [r13+0x0],xmm0
  216c58:	49 8b 14 24          	mov    rdx,QWORD PTR [r12]
  216c5c:	45 89 c3             	mov    r11d,r8d
  216c5f:	48 8b 07             	mov    rax,QWORD PTR [rdi]
  216c62:	48 39 d0             	cmp    rax,rdx
  216c65:	4c 8b 6c 24 18       	mov    r13,QWORD PTR [rsp+0x18]
  216c6a:	0f 83 17 fa ff ff    	jae    216687 <Benchmark_reportStats+0xa87>
    const tmp = a.*;
  216c70:	c4 c1 78 10 04 24    	vmovups xmm0,XMMWORD PTR [r12]
  216c76:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  216c7d:	00 00 
    a.* = b.*;
  216c7f:	c5 f8 10 07          	vmovups xmm0,XMMWORD PTR [rdi]
  216c83:	c4 c1 78 11 04 24    	vmovups XMMWORD PTR [r12],xmm0
    b.* = tmp;
  216c89:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  216c90:	00 00 
  216c92:	c5 fa 7f 07          	vmovdqu XMMWORD PTR [rdi],xmm0
        return self.decimal >= self.size;
  216c96:	4c 3b 94 24 f0 00 00 	cmp    r10,QWORD PTR [rsp+0xf0]
  216c9d:	00 
  216c9e:	0f 82 2c f4 ff ff    	jb     2160d0 <Benchmark_reportStats+0x4d0>
  216ca4:	e9 30 08 00 00       	jmp    2174d9 <Benchmark_reportStats+0x18d9>
  216ca9:	0f b6 44 24 20       	movzx  eax,BYTE PTR [rsp+0x20]
  216cae:	88 44 24 28          	mov    BYTE PTR [rsp+0x28],al
  216cb2:	44 88 64 24 20       	mov    BYTE PTR [rsp+0x20],r12b
  216cb7:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  216cba:	49 8b 00             	mov    rax,QWORD PTR [r8]
  216cbd:	48 39 c2             	cmp    rdx,rax
  216cc0:	44 8b 64 24 10       	mov    r12d,DWORD PTR [rsp+0x10]
    if (lessThan(items[y], items[x]) or ((order.*)[x] > (order.*)[y] and !lessThan(items[x], items[y]))) {
  216cc5:	72 0a                	jb     216cd1 <Benchmark_reportStats+0x10d1>
  216cc7:	45 38 ec             	cmp    r12b,r13b
  216cca:	76 2e                	jbe    216cfa <Benchmark_reportStats+0x10fa>
  216ccc:	48 39 d0             	cmp    rax,rdx
  216ccf:	72 29                	jb     216cfa <Benchmark_reportStats+0x10fa>
    const tmp = a.*;
  216cd1:	c4 c1 78 10 00       	vmovups xmm0,XMMWORD PTR [r8]
  216cd6:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  216cdd:	00 00 
    a.* = b.*;
  216cdf:	c4 c1 78 10 06       	vmovups xmm0,XMMWORD PTR [r14]
  216ce4:	c4 c1 78 11 00       	vmovups XMMWORD PTR [r8],xmm0
    b.* = tmp;
  216ce9:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  216cf0:	00 00 
  216cf2:	c4 c1 7a 7f 06       	vmovdqu XMMWORD PTR [r14],xmm0
  216cf7:	45 89 ec             	mov    r12d,r13d
  216cfa:	48 8b 0b             	mov    rcx,QWORD PTR [rbx]
  216cfd:	48 8b 43 30          	mov    rax,QWORD PTR [rbx+0x30]
  216d01:	48 39 c8             	cmp    rax,rcx
  216d04:	4c 8b 6c 24 18       	mov    r13,QWORD PTR [rsp+0x18]
  216d09:	72 0c                	jb     216d17 <Benchmark_reportStats+0x1117>
  216d0b:	44 3a 7c 24 20       	cmp    r15b,BYTE PTR [rsp+0x20]
  216d10:	76 2e                	jbe    216d40 <Benchmark_reportStats+0x1140>
  216d12:	48 39 c1             	cmp    rcx,rax
  216d15:	72 29                	jb     216d40 <Benchmark_reportStats+0x1140>
    const tmp = a.*;
  216d17:	c5 f8 10 03          	vmovups xmm0,XMMWORD PTR [rbx]
  216d1b:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  216d22:	00 00 
    a.* = b.*;
  216d24:	c4 c1 78 10 03       	vmovups xmm0,XMMWORD PTR [r11]
  216d29:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
    b.* = tmp;
  216d2d:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  216d34:	00 00 
  216d36:	c4 c1 7a 7f 03       	vmovdqu XMMWORD PTR [r11],xmm0
  216d3b:	44 88 7c 24 20       	mov    BYTE PTR [rsp+0x20],r15b
  216d40:	48 8b 0f             	mov    rcx,QWORD PTR [rdi]
  216d43:	49 8b 01             	mov    rax,QWORD PTR [r9]
  216d46:	48 39 c1             	cmp    rcx,rax
  216d49:	4c 8b bc 24 00 01 00 	mov    r15,QWORD PTR [rsp+0x100]
  216d50:	00 
  216d51:	0f b6 5c 24 28       	movzx  ebx,BYTE PTR [rsp+0x28]
  216d56:	72 13                	jb     216d6b <Benchmark_reportStats+0x116b>
  216d58:	38 5c 24 30          	cmp    BYTE PTR [rsp+0x30],bl
  216d5c:	0f 86 4d 02 00 00    	jbe    216faf <Benchmark_reportStats+0x13af>
  216d62:	48 39 c8             	cmp    rax,rcx
  216d65:	0f 82 44 02 00 00    	jb     216faf <Benchmark_reportStats+0x13af>
    const tmp = a.*;
  216d6b:	c4 c1 78 10 01       	vmovups xmm0,XMMWORD PTR [r9]
  216d70:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  216d77:	00 00 
    a.* = b.*;
  216d79:	c5 f8 10 07          	vmovups xmm0,XMMWORD PTR [rdi]
  216d7d:	c4 c1 78 11 01       	vmovups XMMWORD PTR [r9],xmm0
    b.* = tmp;
  216d82:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  216d89:	00 00 
  216d8b:	c5 fa 7f 07          	vmovdqu XMMWORD PTR [rdi],xmm0
  216d8f:	48 8b 0f             	mov    rcx,QWORD PTR [rdi]
  216d92:	8b 44 24 30          	mov    eax,DWORD PTR [rsp+0x30]
  216d96:	89 c2                	mov    edx,eax
  216d98:	49 8b 00             	mov    rax,QWORD PTR [r8]
  216d9b:	48 39 c1             	cmp    rcx,rax
  216d9e:	0f 82 1f 02 00 00    	jb     216fc3 <Benchmark_reportStats+0x13c3>
  216da4:	41 38 d4             	cmp    r12b,dl
  216da7:	76 09                	jbe    216db2 <Benchmark_reportStats+0x11b2>
  216da9:	48 39 c8             	cmp    rax,rcx
  216dac:	0f 83 11 02 00 00    	jae    216fc3 <Benchmark_reportStats+0x13c3>
  216db2:	49 8b 0b             	mov    rcx,QWORD PTR [r11]
  216db5:	49 8b 01             	mov    rax,QWORD PTR [r9]
  216db8:	48 39 c1             	cmp    rcx,rax
  216dbb:	0f 82 38 02 00 00    	jb     216ff9 <Benchmark_reportStats+0x13f9>
  216dc1:	3a 5c 24 20          	cmp    bl,BYTE PTR [rsp+0x20]
  216dc5:	76 09                	jbe    216dd0 <Benchmark_reportStats+0x11d0>
  216dc7:	48 39 c8             	cmp    rax,rcx
  216dca:	0f 83 29 02 00 00    	jae    216ff9 <Benchmark_reportStats+0x13f9>
  216dd0:	49 8b 10             	mov    rdx,QWORD PTR [r8]
  216dd3:	48 39 d1             	cmp    rcx,rdx
  216dd6:	0f 82 56 02 00 00    	jb     217032 <Benchmark_reportStats+0x1432>
  216ddc:	44 3a 64 24 20       	cmp    r12b,BYTE PTR [rsp+0x20]
  216de1:	0f 86 c9 06 00 00    	jbe    2174b0 <Benchmark_reportStats+0x18b0>
  216de7:	48 39 ca             	cmp    rdx,rcx
  216dea:	0f 83 42 02 00 00    	jae    217032 <Benchmark_reportStats+0x1432>
  216df0:	e9 bb 06 00 00       	jmp    2174b0 <Benchmark_reportStats+0x18b0>
  216df5:	44 0f b6 64 24 20    	movzx  r12d,BYTE PTR [rsp+0x20]
  216dfb:	44 88 74 24 20       	mov    BYTE PTR [rsp+0x20],r14b
  216e00:	49 8b 10             	mov    rdx,QWORD PTR [r8]
  216e03:	49 8b 33             	mov    rsi,QWORD PTR [r11]
  216e06:	48 39 f2             	cmp    rdx,rsi
  216e09:	0f 83 43 fb ff ff    	jae    216952 <Benchmark_reportStats+0xd52>
    const tmp = a.*;
  216e0f:	c4 c1 78 10 03       	vmovups xmm0,XMMWORD PTR [r11]
  216e14:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  216e1b:	00 00 
    a.* = b.*;
  216e1d:	c4 c1 78 10 00       	vmovups xmm0,XMMWORD PTR [r8]
  216e22:	c4 c1 78 11 03       	vmovups XMMWORD PTR [r11],xmm0
    b.* = tmp;
  216e27:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  216e2e:	00 00 
  216e30:	c4 c1 7a 7f 00       	vmovdqu XMMWORD PTR [r8],xmm0
  216e35:	41 89 c6             	mov    r14d,eax
  216e38:	48 8b 13             	mov    rdx,QWORD PTR [rbx]
  216e3b:	48 8b 73 10          	mov    rsi,QWORD PTR [rbx+0x10]
  216e3f:	48 39 d6             	cmp    rsi,rdx
  216e42:	0f b6 44 24 58       	movzx  eax,BYTE PTR [rsp+0x58]
  216e47:	72 13                	jb     216e5c <Benchmark_reportStats+0x125c>
  216e49:	38 44 24 10          	cmp    BYTE PTR [rsp+0x10],al
  216e4d:	0f 86 18 02 00 00    	jbe    21706b <Benchmark_reportStats+0x146b>
  216e53:	48 39 f2             	cmp    rdx,rsi
  216e56:	0f 82 0f 02 00 00    	jb     21706b <Benchmark_reportStats+0x146b>
    const tmp = a.*;
  216e5c:	c5 f8 10 03          	vmovups xmm0,XMMWORD PTR [rbx]
  216e60:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  216e67:	00 00 
    a.* = b.*;
  216e69:	c4 c1 78 10 07       	vmovups xmm0,XMMWORD PTR [r15]
  216e6e:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
    b.* = tmp;
  216e72:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  216e79:	00 00 
  216e7b:	c4 c1 7a 7f 07       	vmovdqu XMMWORD PTR [r15],xmm0
  216e80:	88 44 24 28          	mov    BYTE PTR [rsp+0x28],al
  216e84:	e9 f0 01 00 00       	jmp    217079 <Benchmark_reportStats+0x1479>
  216e89:	44 88 44 24 10       	mov    BYTE PTR [rsp+0x10],r8b
  216e8e:	41 89 c8             	mov    r8d,ecx
  216e91:	48 8b 13             	mov    rdx,QWORD PTR [rbx]
  216e94:	48 8b 43 40          	mov    rax,QWORD PTR [rbx+0x40]
  216e98:	48 39 d0             	cmp    rax,rdx
  216e9b:	0f b6 4c 24 60       	movzx  ecx,BYTE PTR [rsp+0x60]
  216ea0:	72 0a                	jb     216eac <Benchmark_reportStats+0x12ac>
  216ea2:	44 38 c9             	cmp    cl,r9b
  216ea5:	76 2c                	jbe    216ed3 <Benchmark_reportStats+0x12d3>
  216ea7:	48 39 c2             	cmp    rdx,rax
  216eaa:	72 27                	jb     216ed3 <Benchmark_reportStats+0x12d3>
    const tmp = a.*;
  216eac:	c5 f8 10 03          	vmovups xmm0,XMMWORD PTR [rbx]
  216eb0:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  216eb7:	00 00 
    a.* = b.*;
  216eb9:	c4 c1 78 10 06       	vmovups xmm0,XMMWORD PTR [r14]
  216ebe:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
    b.* = tmp;
  216ec2:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  216ec9:	00 00 
  216ecb:	c4 c1 7a 7f 06       	vmovdqu XMMWORD PTR [r14],xmm0
  216ed0:	41 89 c9             	mov    r9d,ecx
  216ed3:	49 8b 55 00          	mov    rdx,QWORD PTR [r13+0x0]
  216ed7:	48 8b 07             	mov    rax,QWORD PTR [rdi]
  216eda:	48 39 c2             	cmp    rdx,rax
  216edd:	0f b6 5c 24 58       	movzx  ebx,BYTE PTR [rsp+0x58]
  216ee2:	0f b6 4c 24 50       	movzx  ecx,BYTE PTR [rsp+0x50]
  216ee7:	72 0b                	jb     216ef4 <Benchmark_reportStats+0x12f4>
  216ee9:	38 4c 24 30          	cmp    BYTE PTR [rsp+0x30],cl
  216eed:	76 2f                	jbe    216f1e <Benchmark_reportStats+0x131e>
  216eef:	48 39 d0             	cmp    rax,rdx
  216ef2:	72 2a                	jb     216f1e <Benchmark_reportStats+0x131e>
    const tmp = a.*;
  216ef4:	c5 f8 10 07          	vmovups xmm0,XMMWORD PTR [rdi]
  216ef8:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  216eff:	00 00 
    a.* = b.*;
  216f01:	c4 c1 78 10 45 00    	vmovups xmm0,XMMWORD PTR [r13+0x0]
  216f07:	c5 f8 11 07          	vmovups XMMWORD PTR [rdi],xmm0
    b.* = tmp;
  216f0b:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  216f12:	00 00 
  216f14:	c4 c1 7a 7f 45 00    	vmovdqu XMMWORD PTR [r13+0x0],xmm0
  216f1a:	88 4c 24 30          	mov    BYTE PTR [rsp+0x30],cl
  216f1e:	49 8b 17             	mov    rdx,QWORD PTR [r15]
  216f21:	49 8b 04 24          	mov    rax,QWORD PTR [r12]
  216f25:	48 39 c2             	cmp    rdx,rax
  216f28:	4c 8b 6c 24 18       	mov    r13,QWORD PTR [rsp+0x18]
  216f2d:	72 14                	jb     216f43 <Benchmark_reportStats+0x1343>
  216f2f:	44 38 44 24 20       	cmp    BYTE PTR [rsp+0x20],r8b
  216f34:	0f 86 8b 01 00 00    	jbe    2170c5 <Benchmark_reportStats+0x14c5>
  216f3a:	48 39 d0             	cmp    rax,rdx
  216f3d:	0f 82 82 01 00 00    	jb     2170c5 <Benchmark_reportStats+0x14c5>
    const tmp = a.*;
  216f43:	c4 c1 78 10 04 24    	vmovups xmm0,XMMWORD PTR [r12]
  216f49:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  216f50:	00 00 
    a.* = b.*;
  216f52:	c4 c1 78 10 07       	vmovups xmm0,XMMWORD PTR [r15]
  216f57:	c4 c1 78 11 04 24    	vmovups XMMWORD PTR [r12],xmm0
    b.* = tmp;
  216f5d:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  216f64:	00 00 
  216f66:	c4 c1 7a 7f 07       	vmovdqu XMMWORD PTR [r15],xmm0
  216f6b:	8b 44 24 20          	mov    eax,DWORD PTR [rsp+0x20]
  216f6f:	88 44 24 28          	mov    BYTE PTR [rsp+0x28],al
  216f73:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  216f76:	49 8b 03             	mov    rax,QWORD PTR [r11]
  216f79:	48 39 c2             	cmp    rdx,rax
  216f7c:	0f 82 5e 01 00 00    	jb     2170e0 <Benchmark_reportStats+0x14e0>
  216f82:	3a 5c 24 10          	cmp    bl,BYTE PTR [rsp+0x10]
  216f86:	76 09                	jbe    216f91 <Benchmark_reportStats+0x1391>
  216f88:	48 39 d0             	cmp    rax,rdx
  216f8b:	0f 83 4f 01 00 00    	jae    2170e0 <Benchmark_reportStats+0x14e0>
  216f91:	0f b6 54 24 10       	movzx  edx,BYTE PTR [rsp+0x10]
  216f96:	88 5c 24 10          	mov    BYTE PTR [rsp+0x10],bl
  216f9a:	49 8b 1e             	mov    rbx,QWORD PTR [r14]
  216f9d:	49 8b 04 24          	mov    rax,QWORD PTR [r12]
  216fa1:	48 39 c3             	cmp    rbx,rax
  216fa4:	0f 83 68 01 00 00    	jae    217112 <Benchmark_reportStats+0x1512>
  216faa:	e9 6d 01 00 00       	jmp    21711c <Benchmark_reportStats+0x151c>
  216faf:	89 da                	mov    edx,ebx
  216fb1:	8b 44 24 30          	mov    eax,DWORD PTR [rsp+0x30]
  216fb5:	89 c3                	mov    ebx,eax
  216fb7:	49 8b 00             	mov    rax,QWORD PTR [r8]
  216fba:	48 39 c1             	cmp    rcx,rax
  216fbd:	0f 83 e1 fd ff ff    	jae    216da4 <Benchmark_reportStats+0x11a4>
    const tmp = a.*;
  216fc3:	c4 c1 78 10 00       	vmovups xmm0,XMMWORD PTR [r8]
  216fc8:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  216fcf:	00 00 
    a.* = b.*;
  216fd1:	c5 f8 10 07          	vmovups xmm0,XMMWORD PTR [rdi]
  216fd5:	c4 c1 78 11 00       	vmovups XMMWORD PTR [r8],xmm0
    b.* = tmp;
  216fda:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  216fe1:	00 00 
  216fe3:	c5 fa 7f 07          	vmovdqu XMMWORD PTR [rdi],xmm0
  216fe7:	41 89 d4             	mov    r12d,edx
  216fea:	49 8b 0b             	mov    rcx,QWORD PTR [r11]
  216fed:	49 8b 01             	mov    rax,QWORD PTR [r9]
  216ff0:	48 39 c1             	cmp    rcx,rax
  216ff3:	0f 83 c8 fd ff ff    	jae    216dc1 <Benchmark_reportStats+0x11c1>
    const tmp = a.*;
  216ff9:	c4 c1 78 10 01       	vmovups xmm0,XMMWORD PTR [r9]
  216ffe:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  217005:	00 00 
    a.* = b.*;
  217007:	c4 c1 78 10 03       	vmovups xmm0,XMMWORD PTR [r11]
  21700c:	c4 c1 78 11 01       	vmovups XMMWORD PTR [r9],xmm0
    b.* = tmp;
  217011:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  217018:	00 00 
  21701a:	c4 c1 7a 7f 03       	vmovdqu XMMWORD PTR [r11],xmm0
  21701f:	49 8b 0b             	mov    rcx,QWORD PTR [r11]
  217022:	88 5c 24 20          	mov    BYTE PTR [rsp+0x20],bl
  217026:	49 8b 10             	mov    rdx,QWORD PTR [r8]
  217029:	48 39 d1             	cmp    rcx,rdx
  21702c:	0f 83 aa fd ff ff    	jae    216ddc <Benchmark_reportStats+0x11dc>
    const tmp = a.*;
  217032:	c4 c1 78 10 00       	vmovups xmm0,XMMWORD PTR [r8]
  217037:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  21703e:	00 00 
    a.* = b.*;
  217040:	c4 c1 78 10 03       	vmovups xmm0,XMMWORD PTR [r11]
  217045:	c4 c1 78 11 00       	vmovups XMMWORD PTR [r8],xmm0
    b.* = tmp;
  21704a:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  217051:	00 00 
  217053:	c4 c1 7a 7f 03       	vmovdqu XMMWORD PTR [r11],xmm0
        return self.decimal >= self.size;
  217058:	4c 3b 94 24 f0 00 00 	cmp    r10,QWORD PTR [rsp+0xf0]
  21705f:	00 
  217060:	0f 82 6a f0 ff ff    	jb     2160d0 <Benchmark_reportStats+0x4d0>
  217066:	e9 6e 04 00 00       	jmp    2174d9 <Benchmark_reportStats+0x18d9>
  21706b:	8b 54 24 10          	mov    edx,DWORD PTR [rsp+0x10]
  21706f:	88 54 24 28          	mov    BYTE PTR [rsp+0x28],dl
  217073:	89 c2                	mov    edx,eax
  217075:	89 54 24 10          	mov    DWORD PTR [rsp+0x10],edx
  217079:	48 8b 11             	mov    rdx,QWORD PTR [rcx]
  21707c:	49 8b 33             	mov    rsi,QWORD PTR [r11]
  21707f:	48 39 f2             	cmp    rdx,rsi
  217082:	44 89 f0             	mov    eax,r14d
    if (lessThan(items[y], items[x]) or ((order.*)[x] > (order.*)[y] and !lessThan(items[x], items[y]))) {
  217085:	72 12                	jb     217099 <Benchmark_reportStats+0x1499>
  217087:	45 38 e5             	cmp    r13b,r12b
  21708a:	0f 86 d7 01 00 00    	jbe    217267 <Benchmark_reportStats+0x1667>
  217090:	48 39 d6             	cmp    rsi,rdx
  217093:	0f 82 ce 01 00 00    	jb     217267 <Benchmark_reportStats+0x1667>
    const tmp = a.*;
  217099:	c4 c1 78 10 03       	vmovups xmm0,XMMWORD PTR [r11]
  21709e:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  2170a5:	00 00 
    a.* = b.*;
  2170a7:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  2170ab:	c4 c1 78 11 03       	vmovups XMMWORD PTR [r11],xmm0
    b.* = tmp;
  2170b0:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  2170b7:	00 00 
  2170b9:	c5 fa 7f 01          	vmovdqu XMMWORD PTR [rcx],xmm0
  2170bd:	45 89 ee             	mov    r14d,r13d
  2170c0:	e9 a8 01 00 00       	jmp    21726d <Benchmark_reportStats+0x166d>
  2170c5:	44 88 44 24 28       	mov    BYTE PTR [rsp+0x28],r8b
  2170ca:	8b 44 24 20          	mov    eax,DWORD PTR [rsp+0x20]
  2170ce:	41 89 c0             	mov    r8d,eax
  2170d1:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  2170d4:	49 8b 03             	mov    rax,QWORD PTR [r11]
  2170d7:	48 39 c2             	cmp    rdx,rax
  2170da:	0f 83 a2 fe ff ff    	jae    216f82 <Benchmark_reportStats+0x1382>
    const tmp = a.*;
  2170e0:	c4 c1 78 10 03       	vmovups xmm0,XMMWORD PTR [r11]
  2170e5:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  2170ec:	00 00 
    a.* = b.*;
  2170ee:	c5 f8 10 06          	vmovups xmm0,XMMWORD PTR [rsi]
  2170f2:	c4 c1 78 11 03       	vmovups XMMWORD PTR [r11],xmm0
    b.* = tmp;
  2170f7:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  2170fe:	00 00 
  217100:	c5 fa 7f 06          	vmovdqu XMMWORD PTR [rsi],xmm0
  217104:	89 da                	mov    edx,ebx
  217106:	49 8b 1e             	mov    rbx,QWORD PTR [r14]
  217109:	49 8b 04 24          	mov    rax,QWORD PTR [r12]
  21710d:	48 39 c3             	cmp    rbx,rax
  217110:	72 0a                	jb     21711c <Benchmark_reportStats+0x151c>
  217112:	45 38 c8             	cmp    r8b,r9b
  217115:	76 30                	jbe    217147 <Benchmark_reportStats+0x1547>
  217117:	48 39 d8             	cmp    rax,rbx
  21711a:	72 2b                	jb     217147 <Benchmark_reportStats+0x1547>
    const tmp = a.*;
  21711c:	c4 c1 78 10 04 24    	vmovups xmm0,XMMWORD PTR [r12]
  217122:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  217129:	00 00 
    a.* = b.*;
  21712b:	c4 c1 78 10 06       	vmovups xmm0,XMMWORD PTR [r14]
  217130:	c4 c1 78 11 04 24    	vmovups XMMWORD PTR [r12],xmm0
    b.* = tmp;
  217136:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  21713d:	00 00 
  21713f:	c4 c1 7a 7f 06       	vmovdqu XMMWORD PTR [r14],xmm0
  217144:	45 89 c1             	mov    r9d,r8d
  217147:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  21714a:	48 8b 07             	mov    rax,QWORD PTR [rdi]
  21714d:	48 39 c1             	cmp    rcx,rax
  217150:	0f b6 5c 24 30       	movzx  ebx,BYTE PTR [rsp+0x30]
  217155:	72 09                	jb     217160 <Benchmark_reportStats+0x1560>
  217157:	38 d3                	cmp    bl,dl
  217159:	76 29                	jbe    217184 <Benchmark_reportStats+0x1584>
  21715b:	48 39 c8             	cmp    rax,rcx
  21715e:	72 24                	jb     217184 <Benchmark_reportStats+0x1584>
    const tmp = a.*;
  217160:	c5 f8 10 07          	vmovups xmm0,XMMWORD PTR [rdi]
  217164:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  21716b:	00 00 
    a.* = b.*;
  21716d:	c5 f8 10 06          	vmovups xmm0,XMMWORD PTR [rsi]
  217171:	c5 f8 11 07          	vmovups XMMWORD PTR [rdi],xmm0
    b.* = tmp;
  217175:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  21717c:	00 00 
  21717e:	c5 fa 7f 06          	vmovdqu XMMWORD PTR [rsi],xmm0
  217182:	89 d3                	mov    ebx,edx
  217184:	49 8b 0e             	mov    rcx,QWORD PTR [r14]
  217187:	49 8b 03             	mov    rax,QWORD PTR [r11]
  21718a:	48 39 c1             	cmp    rcx,rax
  21718d:	48 8b 74 24 38       	mov    rsi,QWORD PTR [rsp+0x38]
  217192:	72 0c                	jb     2171a0 <Benchmark_reportStats+0x15a0>
  217194:	44 38 4c 24 10       	cmp    BYTE PTR [rsp+0x10],r9b
  217199:	76 31                	jbe    2171cc <Benchmark_reportStats+0x15cc>
  21719b:	48 39 c8             	cmp    rax,rcx
  21719e:	72 2c                	jb     2171cc <Benchmark_reportStats+0x15cc>
    const tmp = a.*;
  2171a0:	c4 c1 78 10 03       	vmovups xmm0,XMMWORD PTR [r11]
  2171a5:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  2171ac:	00 00 
    a.* = b.*;
  2171ae:	c4 c1 78 10 06       	vmovups xmm0,XMMWORD PTR [r14]
  2171b3:	c4 c1 78 11 03       	vmovups XMMWORD PTR [r11],xmm0
    b.* = tmp;
  2171b8:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  2171bf:	00 00 
  2171c1:	c4 c1 7a 7f 06       	vmovdqu XMMWORD PTR [r14],xmm0
  2171c6:	44 0f b6 4c 24 10    	movzx  r9d,BYTE PTR [rsp+0x10]
  2171cc:	49 8b 17             	mov    rdx,QWORD PTR [r15]
  2171cf:	48 8b 0f             	mov    rcx,QWORD PTR [rdi]
  2171d2:	48 39 ca             	cmp    rdx,rcx
  2171d5:	0f b6 44 24 28       	movzx  eax,BYTE PTR [rsp+0x28]
  2171da:	72 09                	jb     2171e5 <Benchmark_reportStats+0x15e5>
  2171dc:	38 c3                	cmp    bl,al
  2171de:	76 2e                	jbe    21720e <Benchmark_reportStats+0x160e>
  2171e0:	48 39 d1             	cmp    rcx,rdx
  2171e3:	72 29                	jb     21720e <Benchmark_reportStats+0x160e>
    const tmp = a.*;
  2171e5:	c5 f8 10 07          	vmovups xmm0,XMMWORD PTR [rdi]
  2171e9:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  2171f0:	00 00 
    a.* = b.*;
  2171f2:	c4 c1 78 10 07       	vmovups xmm0,XMMWORD PTR [r15]
  2171f7:	c5 f8 11 07          	vmovups XMMWORD PTR [rdi],xmm0
    b.* = tmp;
  2171fb:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  217202:	00 00 
  217204:	c4 c1 7a 7f 07       	vmovdqu XMMWORD PTR [r15],xmm0
  217209:	48 8b 0f             	mov    rcx,QWORD PTR [rdi]
  21720c:	89 c3                	mov    ebx,eax
  21720e:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  217211:	48 39 ca             	cmp    rdx,rcx
  217214:	4c 8b bc 24 00 01 00 	mov    r15,QWORD PTR [rsp+0x100]
  21721b:	00 
  21721c:	72 12                	jb     217230 <Benchmark_reportStats+0x1630>
  21721e:	44 38 cb             	cmp    bl,r9b
  217221:	0f 86 89 02 00 00    	jbe    2174b0 <Benchmark_reportStats+0x18b0>
  217227:	48 39 d1             	cmp    rcx,rdx
  21722a:	0f 82 80 02 00 00    	jb     2174b0 <Benchmark_reportStats+0x18b0>
    const tmp = a.*;
  217230:	c5 f8 10 07          	vmovups xmm0,XMMWORD PTR [rdi]
  217234:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  21723b:	00 00 
    a.* = b.*;
  21723d:	c4 c1 78 10 06       	vmovups xmm0,XMMWORD PTR [r14]
  217242:	c5 f8 11 07          	vmovups XMMWORD PTR [rdi],xmm0
    b.* = tmp;
  217246:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  21724d:	00 00 
  21724f:	c4 c1 7a 7f 06       	vmovdqu XMMWORD PTR [r14],xmm0
        return self.decimal >= self.size;
  217254:	4c 3b 94 24 f0 00 00 	cmp    r10,QWORD PTR [rsp+0xf0]
  21725b:	00 
  21725c:	0f 82 6e ee ff ff    	jb     2160d0 <Benchmark_reportStats+0x4d0>
  217262:	e9 72 02 00 00       	jmp    2174d9 <Benchmark_reportStats+0x18d9>
  217267:	45 89 e6             	mov    r14d,r12d
  21726a:	45 89 ec             	mov    r12d,r13d
  21726d:	49 8b 10             	mov    rdx,QWORD PTR [r8]
  217270:	48 8b 37             	mov    rsi,QWORD PTR [rdi]
  217273:	48 39 f2             	cmp    rdx,rsi
  217276:	4c 8b 6c 24 18       	mov    r13,QWORD PTR [rsp+0x18]
    if (lessThan(items[y], items[x]) or ((order.*)[x] > (order.*)[y] and !lessThan(items[x], items[y]))) {
  21727b:	72 0b                	jb     217288 <Benchmark_reportStats+0x1688>
  21727d:	38 44 24 30          	cmp    BYTE PTR [rsp+0x30],al
  217281:	76 2d                	jbe    2172b0 <Benchmark_reportStats+0x16b0>
  217283:	48 39 d6             	cmp    rsi,rdx
  217286:	72 28                	jb     2172b0 <Benchmark_reportStats+0x16b0>
    const tmp = a.*;
  217288:	c5 f8 10 07          	vmovups xmm0,XMMWORD PTR [rdi]
  21728c:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  217293:	00 00 
    a.* = b.*;
  217295:	c4 c1 78 10 00       	vmovups xmm0,XMMWORD PTR [r8]
  21729a:	c5 f8 11 07          	vmovups XMMWORD PTR [rdi],xmm0
    b.* = tmp;
  21729e:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  2172a5:	00 00 
  2172a7:	c4 c1 7a 7f 00       	vmovdqu XMMWORD PTR [r8],xmm0
  2172ac:	89 44 24 30          	mov    DWORD PTR [rsp+0x30],eax
  2172b0:	48 8b 03             	mov    rax,QWORD PTR [rbx]
  2172b3:	48 8b 53 40          	mov    rdx,QWORD PTR [rbx+0x40]
  2172b7:	48 39 c2             	cmp    rdx,rax
  2172ba:	45 89 f0             	mov    r8d,r14d
  2172bd:	72 0c                	jb     2172cb <Benchmark_reportStats+0x16cb>
  2172bf:	44 38 64 24 28       	cmp    BYTE PTR [rsp+0x28],r12b
  2172c4:	76 2e                	jbe    2172f4 <Benchmark_reportStats+0x16f4>
  2172c6:	48 39 d0             	cmp    rax,rdx
  2172c9:	72 29                	jb     2172f4 <Benchmark_reportStats+0x16f4>
    const tmp = a.*;
  2172cb:	c5 f8 10 03          	vmovups xmm0,XMMWORD PTR [rbx]
  2172cf:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  2172d6:	00 00 
    a.* = b.*;
  2172d8:	c4 c1 78 10 03       	vmovups xmm0,XMMWORD PTR [r11]
  2172dd:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
    b.* = tmp;
  2172e1:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  2172e8:	00 00 
  2172ea:	c4 c1 7a 7f 03       	vmovdqu XMMWORD PTR [r11],xmm0
  2172ef:	45 89 e6             	mov    r14d,r12d
  2172f2:	eb 0b                	jmp    2172ff <Benchmark_reportStats+0x16ff>
  2172f4:	44 0f b6 74 24 28    	movzx  r14d,BYTE PTR [rsp+0x28]
  2172fa:	44 88 64 24 28       	mov    BYTE PTR [rsp+0x28],r12b
  2172ff:	48 8b 11             	mov    rdx,QWORD PTR [rcx]
  217302:	49 8b 07             	mov    rax,QWORD PTR [r15]
  217305:	48 39 c2             	cmp    rdx,rax
  217308:	44 8b 64 24 30       	mov    r12d,DWORD PTR [rsp+0x30]
  21730d:	72 0c                	jb     21731b <Benchmark_reportStats+0x171b>
  21730f:	44 38 44 24 10       	cmp    BYTE PTR [rsp+0x10],r8b
  217314:	76 5e                	jbe    217374 <Benchmark_reportStats+0x1774>
  217316:	48 39 d0             	cmp    rax,rdx
  217319:	72 59                	jb     217374 <Benchmark_reportStats+0x1774>
    const tmp = a.*;
  21731b:	c4 c1 78 10 07       	vmovups xmm0,XMMWORD PTR [r15]
  217320:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  217327:	00 00 
    a.* = b.*;
  217329:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  21732d:	c4 c1 78 11 07       	vmovups XMMWORD PTR [r15],xmm0
    b.* = tmp;
  217332:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  217339:	00 00 
  21733b:	c5 fa 7f 01          	vmovdqu XMMWORD PTR [rcx],xmm0
  21733f:	8b 44 24 10          	mov    eax,DWORD PTR [rsp+0x10]
  217343:	89 c2                	mov    edx,eax
  217345:	48 8b 03             	mov    rax,QWORD PTR [rbx]
  217348:	48 8b 73 30          	mov    rsi,QWORD PTR [rbx+0x30]
  21734c:	48 39 c6             	cmp    rsi,rax
  21734f:	72 39                	jb     21738a <Benchmark_reportStats+0x178a>
  217351:	44 3a 74 24 20       	cmp    r14b,BYTE PTR [rsp+0x20]
  217356:	76 05                	jbe    21735d <Benchmark_reportStats+0x175d>
  217358:	48 39 f0             	cmp    rax,rsi
  21735b:	73 2d                	jae    21738a <Benchmark_reportStats+0x178a>
  21735d:	48 8b 01             	mov    rax,QWORD PTR [rcx]
  217360:	48 8b 37             	mov    rsi,QWORD PTR [rdi]
  217363:	48 39 f0             	cmp    rax,rsi
  217366:	72 56                	jb     2173be <Benchmark_reportStats+0x17be>
  217368:	41 38 d4             	cmp    r12b,dl
  21736b:	76 76                	jbe    2173e3 <Benchmark_reportStats+0x17e3>
  21736d:	48 39 c6             	cmp    rsi,rax
  217370:	73 4c                	jae    2173be <Benchmark_reportStats+0x17be>
  217372:	eb 6f                	jmp    2173e3 <Benchmark_reportStats+0x17e3>
  217374:	44 89 c2             	mov    edx,r8d
  217377:	8b 44 24 10          	mov    eax,DWORD PTR [rsp+0x10]
  21737b:	41 89 c0             	mov    r8d,eax
  21737e:	48 8b 03             	mov    rax,QWORD PTR [rbx]
  217381:	48 8b 73 30          	mov    rsi,QWORD PTR [rbx+0x30]
  217385:	48 39 c6             	cmp    rsi,rax
  217388:	73 c7                	jae    217351 <Benchmark_reportStats+0x1751>
    const tmp = a.*;
  21738a:	c5 f8 10 03          	vmovups xmm0,XMMWORD PTR [rbx]
  21738e:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  217395:	00 00 
    a.* = b.*;
  217397:	c4 c1 78 10 01       	vmovups xmm0,XMMWORD PTR [r9]
  21739c:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
    b.* = tmp;
  2173a0:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  2173a7:	00 00 
  2173a9:	c4 c1 7a 7f 01       	vmovdqu XMMWORD PTR [r9],xmm0
  2173ae:	44 88 74 24 20       	mov    BYTE PTR [rsp+0x20],r14b
  2173b3:	48 8b 01             	mov    rax,QWORD PTR [rcx]
  2173b6:	48 8b 37             	mov    rsi,QWORD PTR [rdi]
  2173b9:	48 39 f0             	cmp    rax,rsi
  2173bc:	73 aa                	jae    217368 <Benchmark_reportStats+0x1768>
    const tmp = a.*;
  2173be:	c5 f8 10 07          	vmovups xmm0,XMMWORD PTR [rdi]
  2173c2:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  2173c9:	00 00 
    a.* = b.*;
  2173cb:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  2173cf:	c5 f8 11 07          	vmovups XMMWORD PTR [rdi],xmm0
    b.* = tmp;
  2173d3:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  2173da:	00 00 
  2173dc:	c5 fa 7f 01          	vmovdqu XMMWORD PTR [rcx],xmm0
  2173e0:	41 89 d4             	mov    r12d,edx
  2173e3:	49 8b 01             	mov    rax,QWORD PTR [r9]
  2173e6:	49 8b 0f             	mov    rcx,QWORD PTR [r15]
  2173e9:	48 39 c8             	cmp    rax,rcx
  2173ec:	48 8b 74 24 38       	mov    rsi,QWORD PTR [rsp+0x38]
  2173f1:	72 0c                	jb     2173ff <Benchmark_reportStats+0x17ff>
  2173f3:	44 3a 44 24 20       	cmp    r8b,BYTE PTR [rsp+0x20]
  2173f8:	76 30                	jbe    21742a <Benchmark_reportStats+0x182a>
  2173fa:	48 39 c1             	cmp    rcx,rax
  2173fd:	72 2b                	jb     21742a <Benchmark_reportStats+0x182a>
    const tmp = a.*;
  2173ff:	c4 c1 78 10 07       	vmovups xmm0,XMMWORD PTR [r15]
  217404:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  21740b:	00 00 
    a.* = b.*;
  21740d:	c4 c1 78 10 01       	vmovups xmm0,XMMWORD PTR [r9]
  217412:	c4 c1 78 11 07       	vmovups XMMWORD PTR [r15],xmm0
    b.* = tmp;
  217417:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  21741e:	00 00 
  217420:	c4 c1 7a 7f 01       	vmovdqu XMMWORD PTR [r9],xmm0
  217425:	44 88 44 24 20       	mov    BYTE PTR [rsp+0x20],r8b
  21742a:	49 8b 0b             	mov    rcx,QWORD PTR [r11]
  21742d:	48 8b 07             	mov    rax,QWORD PTR [rdi]
  217430:	48 39 c1             	cmp    rcx,rax
  217433:	4c 8b bc 24 00 01 00 	mov    r15,QWORD PTR [rsp+0x100]
  21743a:	00 
  21743b:	72 0c                	jb     217449 <Benchmark_reportStats+0x1849>
  21743d:	44 3a 64 24 28       	cmp    r12b,BYTE PTR [rsp+0x28]
  217442:	76 34                	jbe    217478 <Benchmark_reportStats+0x1878>
  217444:	48 39 c8             	cmp    rax,rcx
  217447:	72 2f                	jb     217478 <Benchmark_reportStats+0x1878>
    const tmp = a.*;
  217449:	c5 f8 10 07          	vmovups xmm0,XMMWORD PTR [rdi]
  21744d:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  217454:	00 00 
    a.* = b.*;
  217456:	c4 c1 78 10 03       	vmovups xmm0,XMMWORD PTR [r11]
  21745b:	c5 f8 11 07          	vmovups XMMWORD PTR [rdi],xmm0
    b.* = tmp;
  21745f:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  217466:	00 00 
  217468:	c4 c1 7a 7f 03       	vmovdqu XMMWORD PTR [r11],xmm0
  21746d:	48 8b 07             	mov    rax,QWORD PTR [rdi]
  217470:	0f b6 4c 24 28       	movzx  ecx,BYTE PTR [rsp+0x28]
  217475:	41 89 cc             	mov    r12d,ecx
  217478:	49 8b 09             	mov    rcx,QWORD PTR [r9]
  21747b:	48 39 c1             	cmp    rcx,rax
  21747e:	72 0c                	jb     21748c <Benchmark_reportStats+0x188c>
  217480:	44 3a 64 24 20       	cmp    r12b,BYTE PTR [rsp+0x20]
  217485:	76 29                	jbe    2174b0 <Benchmark_reportStats+0x18b0>
  217487:	48 39 c8             	cmp    rax,rcx
  21748a:	72 24                	jb     2174b0 <Benchmark_reportStats+0x18b0>
    const tmp = a.*;
  21748c:	c5 f8 10 07          	vmovups xmm0,XMMWORD PTR [rdi]
  217490:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  217497:	00 00 
    a.* = b.*;
  217499:	c4 c1 78 10 01       	vmovups xmm0,XMMWORD PTR [r9]
  21749e:	c5 f8 11 07          	vmovups XMMWORD PTR [rdi],xmm0
    b.* = tmp;
  2174a2:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  2174a9:	00 00 
  2174ab:	c4 c1 7a 7f 01       	vmovdqu XMMWORD PTR [r9],xmm0
        return self.decimal >= self.size;
  2174b0:	4c 3b 94 24 f0 00 00 	cmp    r10,QWORD PTR [rsp+0xf0]
  2174b7:	00 
    while (!iterator.finished()) {
  2174b8:	0f 82 12 ec ff ff    	jb     2160d0 <Benchmark_reportStats+0x4d0>
  2174be:	eb 19                	jmp    2174d9 <Benchmark_reportStats+0x18d9>
  2174c0:	8b 44 24 20          	mov    eax,DWORD PTR [rsp+0x20]
  2174c4:	88 44 24 58          	mov    BYTE PTR [rsp+0x58],al
  2174c8:	0f b6 44 24 10       	movzx  eax,BYTE PTR [rsp+0x10]
  2174cd:	89 44 24 20          	mov    DWORD PTR [rsp+0x20],eax
  2174d1:	45 89 c8             	mov    r8d,r9d
  2174d4:	e9 bd f6 ff ff       	jmp    216b96 <Benchmark_reportStats+0xf96>
    if (items.len < 8) return;
  2174d9:	48 83 7c 24 48 08    	cmp    QWORD PTR [rsp+0x48],0x8
  2174df:	4c 8b a4 24 d8 00 00 	mov    r12,QWORD PTR [rsp+0xd8]
  2174e6:	00 
  2174e7:	0f 82 e1 6e 00 00    	jb     21e3ce <Benchmark_reportStats+0x87ce>
  2174ed:	4c 8b 8c 24 e0 00 00 	mov    r9,QWORD PTR [rsp+0xe0]
  2174f4:	00 
        if (iterator.length() < cache.len) {
  2174f5:	49 81 fc 00 02 00 00 	cmp    r12,0x200
  2174fc:	4c 89 a4 24 d8 00 00 	mov    QWORD PTR [rsp+0xd8],r12
  217503:	00 
  217504:	4c 89 8c 24 e0 00 00 	mov    QWORD PTR [rsp+0xe0],r9
  21750b:	00 
  21750c:	0f 82 2d 49 00 00    	jb     21be3f <Benchmark_reportStats+0x623f>
  217512:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  217519:	1f 84 00 00 00 00 00 
  217520:	48 b9 00 00 00 00 00 	movabs rcx,0x4000000000000000
  217527:	00 00 40 
  21752a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  217530:	48 89 c8             	mov    rax,rcx
    var res: T = 0;
    var one: T = 1 << (T.bit_count - 2);

    // "one" starts at the highest power of four <= than the argument.
    while (one > op) {
        one >>= 2;
  217533:	48 c1 e9 02          	shr    rcx,0x2
    while (one > op) {
  217537:	4c 39 e0             	cmp    rax,r12
  21753a:	77 f4                	ja     217530 <Benchmark_reportStats+0x1930>
  21753c:	31 c9                	xor    ecx,ecx
    }

    while (one != 0) {
  21753e:	48 85 c0             	test   rax,rax
  217541:	74 29                	je     21756c <Benchmark_reportStats+0x196c>
  217543:	4c 89 e2             	mov    rdx,r12
  217546:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  21754d:	00 00 00 
        if (op >= res + one) {
  217550:	48 8d 3c 01          	lea    rdi,[rcx+rax*1]
  217554:	48 89 d6             	mov    rsi,rdx
  217557:	48 29 fe             	sub    rsi,rdi
  21755a:	72 07                	jb     217563 <Benchmark_reportStats+0x1963>
            op -= res + one;
            res += 2 * one;
  21755c:	48 8d 0c 41          	lea    rcx,[rcx+rax*2]
  217560:	48 89 f2             	mov    rdx,rsi
        }
        res >>= 1;
  217563:	48 d1 e9             	shr    rcx,1
        one >>= 2;
  217566:	48 c1 e8 02          	shr    rax,0x2
    while (one != 0) {
  21756a:	75 e4                	jne    217550 <Benchmark_reportStats+0x1950>
            var block_size: usize = math.sqrt(iterator.length());
  21756c:	89 c9                	mov    ecx,ecx
  21756e:	4c 89 e0             	mov    rax,r12
  217571:	48 c1 e8 20          	shr    rax,0x20
  217575:	74 0d                	je     217584 <Benchmark_reportStats+0x1984>
  217577:	31 d2                	xor    edx,edx
  217579:	4c 89 e0             	mov    rax,r12
  21757c:	48 f7 f1             	div    rcx
  21757f:	48 89 c7             	mov    rdi,rax
  217582:	eb 09                	jmp    21758d <Benchmark_reportStats+0x198d>
  217584:	31 d2                	xor    edx,edx
  217586:	44 89 e0             	mov    eax,r12d
  217589:	f7 f1                	div    ecx
  21758b:	89 c7                	mov    edi,eax
            if (block_size <= cache.len) {
  21758d:	81 f9 00 02 00 00    	cmp    ecx,0x200
  217593:	0f 97 c0             	seta   al
            find = buffer_size + buffer_size;
  217596:	48 8d 34 3f          	lea    rsi,[rdi+rdi*1]
  21759a:	48 83 c6 02          	add    rsi,0x2
            } else if (find > iterator.length()) {
  21759e:	4c 39 e6             	cmp    rsi,r12
  2175a1:	0f 97 c3             	seta   bl
            var buffer_size = iterator.length() / block_size + 1;
  2175a4:	48 8d 57 01          	lea    rdx,[rdi+0x1]
  2175a8:	48 89 74 24 58       	mov    QWORD PTR [rsp+0x58],rsi
            if (block_size <= cache.len) {
  2175ad:	49 89 f6             	mov    r14,rsi
  2175b0:	4c 0f 47 f2          	cmova  r14,rdx
  2175b4:	48 89 8c 24 08 01 00 	mov    QWORD PTR [rsp+0x108],rcx
  2175bb:	00 
  2175bc:	81 f9 01 02 00 00    	cmp    ecx,0x201
  2175c2:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
            var pull = []Pull{
  2175c6:	c5 fe 7f 84 24 b0 00 	vmovdqu YMMWORD PTR [rsp+0xb0],ymm0
  2175cd:	00 00 
  2175cf:	c5 fd 7f 84 24 a0 00 	vmovdqa YMMWORD PTR [rsp+0xa0],ymm0
  2175d6:	00 00 
  2175d8:	c5 fd 7f 84 24 80 00 	vmovdqa YMMWORD PTR [rsp+0x80],ymm0
  2175df:	00 00 
  2175e1:	48 89 54 24 78       	mov    QWORD PTR [rsp+0x78],rdx
            if (block_size <= cache.len) {
  2175e6:	4c 0f 42 f2          	cmovb  r14,rdx
  2175ea:	20 c3                	and    bl,al
  2175ec:	89 9c 24 f8 00 00 00 	mov    DWORD PTR [rsp+0xf8],ebx
  2175f3:	31 c0                	xor    eax,eax
  2175f5:	48 89 44 24 38       	mov    QWORD PTR [rsp+0x38],rax
  2175fa:	31 c9                	xor    ecx,ecx
  2175fc:	31 db                	xor    ebx,ebx
  2175fe:	31 c0                	xor    eax,eax
  217600:	48 89 44 24 70       	mov    QWORD PTR [rsp+0x70],rax
  217605:	45 31 ed             	xor    r13d,r13d
  217608:	48 89 7c 24 20       	mov    QWORD PTR [rsp+0x20],rdi
  21760d:	e9 de 00 00 00       	jmp    2176f0 <Benchmark_reportStats+0x1af0>
  217612:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  217619:	1f 84 00 00 00 00 00 
  217620:	4c 89 ca             	mov    rdx,r9
  217623:	48 8b 7c 24 20       	mov    rdi,QWORD PTR [rsp+0x20]
                if (count >= buffer_size) {
  217628:	49 39 f8             	cmp    r8,rdi
  21762b:	0f 87 1d 05 00 00    	ja     217b4e <Benchmark_reportStats+0x1f4e>
  217631:	e9 ae 05 00 00       	jmp    217be4 <Benchmark_reportStats+0x1fe4>
  217636:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  21763d:	00 00 00 
            if (block_size <= cache.len) {
  217640:	81 bc 24 08 01 00 00 	cmp    DWORD PTR [rsp+0x108],0x200
  217647:	00 02 00 00 
  21764b:	48 8b 84 24 f0 00 00 	mov    rax,QWORD PTR [rsp+0xf0]
  217652:	00 
                    } else if (block_size <= cache.len) {
  217653:	0f 86 70 06 00 00    	jbe    217cc9 <Benchmark_reportStats+0x20c9>
                    } else if (find_separately) {
  217659:	f6 84 24 f8 00 00 00 	test   BYTE PTR [rsp+0xf8],0x1
  217660:	01 
  217661:	0f 84 38 3b 00 00    	je     21b19f <Benchmark_reportStats+0x559f>
                        buffer1 = Range.init(B.end - count, B.end);
  217667:	48 89 ca             	mov    rdx,rcx
  21766a:	4c 29 c2             	sub    rdx,r8
  21766d:	48 89 54 24 70       	mov    QWORD PTR [rsp+0x70],rdx
  217672:	c7 84 24 f8 00 00 00 	mov    DWORD PTR [rsp+0xf8],0x0
  217679:	00 00 00 00 
  21767d:	49 89 cd             	mov    r13,rcx
  217680:	be 01 00 00 00       	mov    esi,0x1
                    } else if (find == buffer_size + buffer_size) {
  217685:	48 89 74 24 38       	mov    QWORD PTR [rsp+0x38],rsi
  21768a:	48 8b 5c 24 30       	mov    rbx,QWORD PTR [rsp+0x30]
  21768f:	48 2b 5c 24 28       	sub    rbx,QWORD PTR [rsp+0x28]
        return self.decimal >= self.size;
  217694:	48 39 c1             	cmp    rcx,rax
            while (!iterator.finished()) {
  217697:	72 57                	jb     2176f0 <Benchmark_reportStats+0x1af0>
  217699:	e9 d0 05 00 00       	jmp    217c6e <Benchmark_reportStats+0x206e>
  21769e:	31 c0                	xor    eax,eax
  2176a0:	48 89 44 24 38       	mov    QWORD PTR [rsp+0x38],rax
  2176a5:	48 8b 84 24 f0 00 00 	mov    rax,QWORD PTR [rsp+0xf0]
  2176ac:	00 
  2176ad:	48 8b 4c 24 50       	mov    rcx,QWORD PTR [rsp+0x50]
  2176b2:	48 8b 5c 24 30       	mov    rbx,QWORD PTR [rsp+0x30]
  2176b7:	48 2b 5c 24 28       	sub    rbx,QWORD PTR [rsp+0x28]
        return self.decimal >= self.size;
  2176bc:	48 39 c1             	cmp    rcx,rax
            while (!iterator.finished()) {
  2176bf:	72 2f                	jb     2176f0 <Benchmark_reportStats+0x1af0>
  2176c1:	e9 a8 05 00 00       	jmp    217c6e <Benchmark_reportStats+0x206e>
  2176c6:	4c 89 ca             	mov    rdx,r9
  2176c9:	4c 8b 74 24 18       	mov    r14,QWORD PTR [rsp+0x18]
  2176ce:	48 8b 7c 24 20       	mov    rdi,QWORD PTR [rsp+0x20]
                if (count >= buffer_size) {
  2176d3:	49 39 f8             	cmp    r8,rdi
  2176d6:	0f 87 72 04 00 00    	ja     217b4e <Benchmark_reportStats+0x1f4e>
  2176dc:	e9 03 05 00 00       	jmp    217be4 <Benchmark_reportStats+0x1fe4>
  2176e1:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  2176e8:	0f 1f 84 00 00 00 00 
  2176ef:	00 
  2176f0:	4c 89 ac 24 d0 00 00 	mov    QWORD PTR [rsp+0xd0],r13
  2176f7:	00 
  2176f8:	48 89 cf             	mov    rdi,rcx
        self.decimal += self.decimal_step;
  2176fb:	4a 8d 04 27          	lea    rax,[rdi+r12*1]
        self.numerator += self.numerator_step;
  2176ff:	4c 01 cb             	add    rbx,r9
        if (self.numerator >= self.denominator) {
  217702:	45 31 ff             	xor    r15d,r15d
  217705:	48 8b 94 24 00 01 00 	mov    rdx,QWORD PTR [rsp+0x100]
  21770c:	00 
  21770d:	48 39 d3             	cmp    rbx,rdx
  217710:	41 0f 93 c7          	setae  r15b
  217714:	48 89 d1             	mov    rcx,rdx
  217717:	be 00 00 00 00       	mov    esi,0x0
  21771c:	48 0f 42 ce          	cmovb  rcx,rsi
  217720:	48 29 cb             	sub    rbx,rcx
  217723:	49 01 c7             	add    r15,rax
        self.decimal += self.decimal_step;
  217726:	4b 8d 04 27          	lea    rax,[r15+r12*1]
        self.numerator += self.numerator_step;
  21772a:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
  21772f:	4c 01 cb             	add    rbx,r9
        if (self.numerator >= self.denominator) {
  217732:	31 c0                	xor    eax,eax
  217734:	48 89 5c 24 30       	mov    QWORD PTR [rsp+0x30],rbx
  217739:	48 39 d3             	cmp    rbx,rdx
  21773c:	0f 93 c0             	setae  al
  21773f:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  217744:	48 0f 42 d6          	cmovb  rdx,rsi
  217748:	48 89 54 24 28       	mov    QWORD PTR [rsp+0x28],rdx
                while (count < find) : ({
  21774d:	49 83 fe 02          	cmp    r14,0x2
  217751:	48 89 7c 24 60       	mov    QWORD PTR [rsp+0x60],rdi
  217756:	4c 89 74 24 18       	mov    QWORD PTR [rsp+0x18],r14
  21775b:	0f 82 df 00 00 00    	jb     217840 <Benchmark_reportStats+0x1c40>
  217761:	48 8b 5c 24 40       	mov    rbx,QWORD PTR [rsp+0x40]
  217766:	4d 8d 66 ff          	lea    r12,[r14-0x1]
  21776a:	49 89 fe             	mov    r14,rdi
  21776d:	41 bd 01 00 00 00    	mov    r13d,0x1
  217773:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21777a:	84 00 00 00 00 00 
                    index = findLastForward(T, items, items[last], Range.init(last + 1, A.end), lessThan, find - count);
  217780:	4c 89 f6             	mov    rsi,r14
  217783:	48 c1 e6 04          	shl    rsi,0x4
  217787:	48 01 de             	add    rsi,rbx
  21778a:	49 8d 56 01          	lea    rdx,[r14+0x1]
  21778e:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  217793:	4c 89 f9             	mov    rcx,r15
  217796:	4d 89 e0             	mov    r8,r12
  217799:	c5 f8 77             	vzeroupper 
  21779c:	e8 df 6f 00 00       	call   21e780 <findLastForward>
                    if (index == A.end) break;
  2177a1:	4c 39 f8             	cmp    rax,r15
  2177a4:	0f 84 d6 00 00 00    	je     217880 <Benchmark_reportStats+0x1c80>
                    count += 1;
  2177aa:	49 83 c5 01          	add    r13,0x1
                while (count < find) : ({
  2177ae:	49 83 c4 ff          	add    r12,0xffffffffffffffff
  2177b2:	49 89 c6             	mov    r14,rax
  2177b5:	4c 39 6c 24 18       	cmp    QWORD PTR [rsp+0x18],r13
  2177ba:	77 c4                	ja     217780 <Benchmark_reportStats+0x1b80>
  2177bc:	48 8b 54 24 50       	mov    rdx,QWORD PTR [rsp+0x50]
  2177c1:	48 03 54 24 10       	add    rdx,QWORD PTR [rsp+0x10]
                if (count >= buffer_size) {
  2177c6:	4c 3b 6c 24 20       	cmp    r13,QWORD PTR [rsp+0x20]
  2177cb:	0f 86 8d 00 00 00    	jbe    21785e <Benchmark_reportStats+0x1c5e>
                    pull[pull_index] = Pull{
  2177d1:	48 8b 4c 24 38       	mov    rcx,QWORD PTR [rsp+0x38]
  2177d6:	48 8d 0c 89          	lea    rcx,[rcx+rcx*4]
  2177da:	48 89 84 cc 80 00 00 	mov    QWORD PTR [rsp+rcx*8+0x80],rax
  2177e1:	00 
  2177e2:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
  2177e7:	48 89 84 cc 88 00 00 	mov    QWORD PTR [rsp+rcx*8+0x88],rax
  2177ee:	00 
  2177ef:	4c 89 ac cc 90 00 00 	mov    QWORD PTR [rsp+rcx*8+0x90],r13
  2177f6:	00 
  2177f7:	48 89 84 cc 98 00 00 	mov    QWORD PTR [rsp+rcx*8+0x98],rax
  2177fe:	00 
  2177ff:	48 89 94 cc a0 00 00 	mov    QWORD PTR [rsp+rcx*8+0xa0],rdx
  217806:	00 
  217807:	48 8b 74 24 58       	mov    rsi,QWORD PTR [rsp+0x58]
                    if (count == buffer_size + buffer_size) {
  21780c:	49 39 f5             	cmp    r13,rsi
  21780f:	4c 8b 74 24 18       	mov    r14,QWORD PTR [rsp+0x18]
  217814:	0f 84 5e 04 00 00    	je     217c78 <Benchmark_reportStats+0x2078>
  21781a:	49 01 c5             	add    r13,rax
                    } else if (find == buffer_size + buffer_size) {
  21781d:	49 39 f6             	cmp    r14,rsi
  217820:	75 7e                	jne    2178a0 <Benchmark_reportStats+0x1ca0>
  217822:	48 89 44 24 70       	mov    QWORD PTR [rsp+0x70],rax
  217827:	b8 01 00 00 00       	mov    eax,0x1
  21782c:	48 89 44 24 38       	mov    QWORD PTR [rsp+0x38],rax
  217831:	4c 8b 74 24 78       	mov    r14,QWORD PTR [rsp+0x78]
  217836:	e9 fe 00 00 00       	jmp    217939 <Benchmark_reportStats+0x1d39>
  21783b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  217840:	41 bd 01 00 00 00    	mov    r13d,0x1
  217846:	48 89 f8             	mov    rax,rdi
  217849:	48 8b 54 24 50       	mov    rdx,QWORD PTR [rsp+0x50]
  21784e:	48 03 54 24 10       	add    rdx,QWORD PTR [rsp+0x10]
                if (count >= buffer_size) {
  217853:	4c 3b 6c 24 20       	cmp    r13,QWORD PTR [rsp+0x20]
  217858:	0f 87 73 ff ff ff    	ja     2177d1 <Benchmark_reportStats+0x1bd1>
                } else if (pull_index == 0 and count > buffer1.length()) {
  21785e:	48 83 7c 24 38 00    	cmp    QWORD PTR [rsp+0x38],0x0
  217864:	4c 8b 74 24 18       	mov    r14,QWORD PTR [rsp+0x18]
  217869:	74 78                	je     2178e3 <Benchmark_reportStats+0x1ce3>
  21786b:	4c 8b ac 24 d0 00 00 	mov    r13,QWORD PTR [rsp+0xd0]
  217872:	00 
  217873:	e9 c1 00 00 00       	jmp    217939 <Benchmark_reportStats+0x1d39>
  217878:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  21787f:	00 
  217880:	4c 89 f0             	mov    rax,r14
  217883:	48 8b 54 24 50       	mov    rdx,QWORD PTR [rsp+0x50]
  217888:	48 03 54 24 10       	add    rdx,QWORD PTR [rsp+0x10]
                if (count >= buffer_size) {
  21788d:	4c 3b 6c 24 20       	cmp    r13,QWORD PTR [rsp+0x20]
  217892:	0f 87 39 ff ff ff    	ja     2177d1 <Benchmark_reportStats+0x1bd1>
  217898:	eb c4                	jmp    21785e <Benchmark_reportStats+0x1c5e>
  21789a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
            if (block_size <= cache.len) {
  2178a0:	81 bc 24 08 01 00 00 	cmp    DWORD PTR [rsp+0x108],0x201
  2178a7:	01 02 00 00 
  2178ab:	4c 8b a4 24 d8 00 00 	mov    r12,QWORD PTR [rsp+0xd8]
  2178b2:	00 
                    } else if (block_size <= cache.len) {
  2178b3:	0f 82 01 04 00 00    	jb     217cba <Benchmark_reportStats+0x20ba>
                    } else if (find_separately) {
  2178b9:	f6 84 24 f8 00 00 00 	test   BYTE PTR [rsp+0xf8],0x1
  2178c0:	01 
  2178c1:	0f 84 ce 38 00 00    	je     21b195 <Benchmark_reportStats+0x5595>
  2178c7:	c7 84 24 f8 00 00 00 	mov    DWORD PTR [rsp+0xf8],0x0
  2178ce:	00 00 00 00 
  2178d2:	48 89 44 24 70       	mov    QWORD PTR [rsp+0x70],rax
  2178d7:	b8 01 00 00 00       	mov    eax,0x1
  2178dc:	48 89 44 24 38       	mov    QWORD PTR [rsp+0x38],rax
  2178e1:	eb 5e                	jmp    217941 <Benchmark_reportStats+0x1d41>
  2178e3:	48 8b b4 24 d0 00 00 	mov    rsi,QWORD PTR [rsp+0xd0]
  2178ea:	00 
        return self.end - self.start;
  2178eb:	48 89 f1             	mov    rcx,rsi
  2178ee:	48 2b 4c 24 70       	sub    rcx,QWORD PTR [rsp+0x70]
                } else if (pull_index == 0 and count > buffer1.length()) {
  2178f3:	49 39 cd             	cmp    r13,rcx
  2178f6:	76 37                	jbe    21792f <Benchmark_reportStats+0x1d2f>
                    pull[pull_index] = Pull{
  2178f8:	48 89 84 24 80 00 00 	mov    QWORD PTR [rsp+0x80],rax
  2178ff:	00 
  217900:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
  217905:	48 89 84 24 88 00 00 	mov    QWORD PTR [rsp+0x88],rax
  21790c:	00 
  21790d:	4c 89 ac 24 90 00 00 	mov    QWORD PTR [rsp+0x90],r13
  217914:	00 
  217915:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  21791c:	00 
                    buffer1 = Range.init(A.start, A.start + count);
  21791d:	49 01 c5             	add    r13,rax
                    pull[pull_index] = Pull{
  217920:	48 89 94 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rdx
  217927:	00 
  217928:	48 89 44 24 70       	mov    QWORD PTR [rsp+0x70],rax
  21792d:	eb 03                	jmp    217932 <Benchmark_reportStats+0x1d32>
  21792f:	49 89 f5             	mov    r13,rsi
  217932:	31 c0                	xor    eax,eax
  217934:	48 89 44 24 38       	mov    QWORD PTR [rsp+0x38],rax
  217939:	4c 8b a4 24 d8 00 00 	mov    r12,QWORD PTR [rsp+0xd8]
  217940:	00 
  217941:	48 89 d0             	mov    rax,rdx
  217944:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
  217949:	48 8d 52 ff          	lea    rdx,[rdx-0x1]
                while (count < find) : ({
  21794d:	49 83 fe 02          	cmp    r14,0x2
  217951:	0f 82 79 02 00 00    	jb     217bd0 <Benchmark_reportStats+0x1fd0>
  217957:	4c 8b 5c 24 40       	mov    r11,QWORD PTR [rsp+0x40]
  21795c:	49 89 d1             	mov    r9,rdx
  21795f:	41 b8 01 00 00 00    	mov    r8d,0x1
  217965:	4c 89 74 24 18       	mov    QWORD PTR [rsp+0x18],r14
  21796a:	eb 74                	jmp    2179e0 <Benchmark_reportStats+0x1de0>
  21796c:	48 89 ce             	mov    rsi,rcx
    if (range.start >= range.end) return range.end;
  21796f:	48 85 c0             	test   rax,rax
  217972:	0f 85 01 01 00 00    	jne    217a79 <Benchmark_reportStats+0x1e79>
  217978:	e9 7f 01 00 00       	jmp    217afc <Benchmark_reportStats+0x1efc>
    while (start < end) {
  21797d:	4c 39 ff             	cmp    rdi,r15
  217980:	0f 86 40 fd ff ff    	jbe    2176c6 <Benchmark_reportStats+0x1ac6>
  217986:	4c 89 fa             	mov    rdx,r15
  217989:	4c 8b 74 24 18       	mov    r14,QWORD PTR [rsp+0x18]
  21798e:	66 90                	xchg   ax,ax
        const mid = start + (end - start) / 2;
  217990:	48 89 f8             	mov    rax,rdi
  217993:	48 29 d0             	sub    rax,rdx
  217996:	48 d1 e8             	shr    rax,1
  217999:	48 8d 0c 10          	lea    rcx,[rax+rdx*1]
  21799d:	48 89 ce             	mov    rsi,rcx
  2179a0:	48 c1 e6 04          	shl    rsi,0x4
  2179a4:	49 39 1c 33          	cmp    QWORD PTR [r11+rsi*1],rbx
        if (lessThan(items[mid], value)) {
  2179a8:	72 16                	jb     2179c0 <Benchmark_reportStats+0x1dc0>
  2179aa:	48 89 cf             	mov    rdi,rcx
    while (start < end) {
  2179ad:	48 39 d7             	cmp    rdi,rdx
  2179b0:	77 de                	ja     217990 <Benchmark_reportStats+0x1d90>
  2179b2:	e9 5e 01 00 00       	jmp    217b15 <Benchmark_reportStats+0x1f15>
  2179b7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  2179be:	00 00 
  2179c0:	48 01 c2             	add    rdx,rax
  2179c3:	48 83 c2 01          	add    rdx,0x1
  2179c7:	48 39 d7             	cmp    rdi,rdx
  2179ca:	77 c4                	ja     217990 <Benchmark_reportStats+0x1d90>
  2179cc:	e9 44 01 00 00       	jmp    217b15 <Benchmark_reportStats+0x1f15>
  2179d1:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  2179d8:	0f 1f 84 00 00 00 00 
  2179df:	00 
    if (range.length() == 0) return range.start;
  2179e0:	4c 89 c8             	mov    rax,r9
  2179e3:	4c 29 f8             	sub    rax,r15
  2179e6:	0f 84 34 fc ff ff    	je     217620 <Benchmark_reportStats+0x1a20>
  2179ec:	4d 89 ca             	mov    r10,r9
  2179ef:	49 c1 e2 04          	shl    r10,0x4
                    index = findFirstBackward(T, items, items[last], Range.init(B.start, last), lessThan, find - count);
  2179f3:	4c 89 f1             	mov    rcx,r14
  2179f6:	4c 29 c1             	sub    rcx,r8
  2179f9:	48 89 c2             	mov    rdx,rax
  2179fc:	48 09 ca             	or     rdx,rcx
  2179ff:	48 c1 ea 20          	shr    rdx,0x20
  217a03:	74 0b                	je     217a10 <Benchmark_reportStats+0x1e10>
  217a05:	31 d2                	xor    edx,edx
  217a07:	48 f7 f1             	div    rcx
  217a0a:	eb 08                	jmp    217a14 <Benchmark_reportStats+0x1e14>
  217a0c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  217a10:	31 d2                	xor    edx,edx
  217a12:	f7 f1                	div    ecx
  217a14:	4d 01 da             	add    r10,r11
    return if (x > y) x else y;
  217a17:	48 83 f8 01          	cmp    rax,0x1
  217a1b:	b9 01 00 00 00       	mov    ecx,0x1
  217a20:	48 0f 46 c1          	cmovbe rax,rcx
  217a24:	4c 89 ce             	mov    rsi,r9
  217a27:	48 29 c6             	sub    rsi,rax
    while (index > range.start and !lessThan(items[index - 1], value)) : (index -= skip) {
  217a2a:	4c 39 fe             	cmp    rsi,r15
  217a2d:	0f 86 bd 00 00 00    	jbe    217af0 <Benchmark_reportStats+0x1ef0>
  217a33:	49 8b 1a             	mov    rbx,QWORD PTR [r10]
  217a36:	4e 8d 34 38          	lea    r14,[rax+r15*1]
  217a3a:	4c 89 ca             	mov    rdx,r9
  217a3d:	0f 1f 00             	nop    DWORD PTR [rax]
  217a40:	48 89 f1             	mov    rcx,rsi
  217a43:	48 8d 79 ff          	lea    rdi,[rcx-0x1]
  217a47:	48 89 fe             	mov    rsi,rdi
  217a4a:	48 c1 e6 04          	shl    rsi,0x4
  217a4e:	49 39 1c 33          	cmp    QWORD PTR [r11+rsi*1],rbx
  217a52:	0f 82 14 ff ff ff    	jb     21796c <Benchmark_reportStats+0x1d6c>
        if (index < range.start + skip) {
  217a58:	4c 39 f1             	cmp    rcx,r14
  217a5b:	0f 82 1c ff ff ff    	jb     21797d <Benchmark_reportStats+0x1d7d>
  217a61:	48 89 ce             	mov    rsi,rcx
  217a64:	48 29 c6             	sub    rsi,rax
  217a67:	48 89 ca             	mov    rdx,rcx
    while (index > range.start and !lessThan(items[index - 1], value)) : (index -= skip) {
  217a6a:	4c 39 fe             	cmp    rsi,r15
  217a6d:	77 d1                	ja     217a40 <Benchmark_reportStats+0x1e40>
  217a6f:	90                   	nop
    if (range.start >= range.end) return range.end;
  217a70:	48 85 c0             	test   rax,rax
  217a73:	0f 84 83 00 00 00    	je     217afc <Benchmark_reportStats+0x1efc>
    var end = range.end - 1;
  217a79:	48 83 c2 ff          	add    rdx,0xffffffffffffffff
    while (start < end) {
  217a7d:	48 39 f2             	cmp    rdx,rsi
  217a80:	76 4a                	jbe    217acc <Benchmark_reportStats+0x1ecc>
  217a82:	4d 8b 32             	mov    r14,QWORD PTR [r10]
  217a85:	48 89 d3             	mov    rbx,rdx
  217a88:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  217a8f:	00 
        const mid = start + (end - start) / 2;
  217a90:	48 89 d9             	mov    rcx,rbx
  217a93:	48 29 f1             	sub    rcx,rsi
  217a96:	48 d1 e9             	shr    rcx,1
  217a99:	48 8d 04 31          	lea    rax,[rcx+rsi*1]
  217a9d:	48 89 c7             	mov    rdi,rax
  217aa0:	48 c1 e7 04          	shl    rdi,0x4
  217aa4:	4d 39 34 3b          	cmp    QWORD PTR [r11+rdi*1],r14
        if (lessThan(items[mid], value)) {
  217aa8:	72 16                	jb     217ac0 <Benchmark_reportStats+0x1ec0>
  217aaa:	48 89 c3             	mov    rbx,rax
    while (start < end) {
  217aad:	48 39 f3             	cmp    rbx,rsi
  217ab0:	77 de                	ja     217a90 <Benchmark_reportStats+0x1e90>
  217ab2:	eb 18                	jmp    217acc <Benchmark_reportStats+0x1ecc>
  217ab4:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  217abb:	00 00 00 00 00 
  217ac0:	48 01 ce             	add    rsi,rcx
  217ac3:	48 83 c6 01          	add    rsi,0x1
  217ac7:	48 39 f3             	cmp    rbx,rsi
  217aca:	77 c4                	ja     217a90 <Benchmark_reportStats+0x1e90>
    if (start == range.end - 1 and lessThan(items[start], value)) {
  217acc:	48 39 d6             	cmp    rsi,rdx
  217acf:	4c 8b 74 24 18       	mov    r14,QWORD PTR [rsp+0x18]
  217ad4:	75 3a                	jne    217b10 <Benchmark_reportStats+0x1f10>
  217ad6:	48 c1 e2 04          	shl    rdx,0x4
  217ada:	49 8b 04 13          	mov    rax,QWORD PTR [r11+rdx*1]
  217ade:	31 d2                	xor    edx,edx
  217ae0:	49 3b 02             	cmp    rax,QWORD PTR [r10]
  217ae3:	0f 92 c2             	setb   dl
  217ae6:	eb 2a                	jmp    217b12 <Benchmark_reportStats+0x1f12>
  217ae8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  217aef:	00 
  217af0:	4c 89 ca             	mov    rdx,r9
    if (range.start >= range.end) return range.end;
  217af3:	48 85 c0             	test   rax,rax
  217af6:	0f 85 7d ff ff ff    	jne    217a79 <Benchmark_reportStats+0x1e79>
  217afc:	4c 8b 74 24 18       	mov    r14,QWORD PTR [rsp+0x18]
                    if (index == B.start) break;
  217b01:	4c 39 fa             	cmp    rdx,r15
  217b04:	75 18                	jne    217b1e <Benchmark_reportStats+0x1f1e>
  217b06:	e9 15 fb ff ff       	jmp    217620 <Benchmark_reportStats+0x1a20>
  217b0b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  217b10:	31 d2                	xor    edx,edx
    if (start == range.end - 1 and lessThan(items[start], value)) {
  217b12:	48 01 f2             	add    rdx,rsi
                    if (index == B.start) break;
  217b15:	4c 39 fa             	cmp    rdx,r15
  217b18:	0f 84 02 fb ff ff    	je     217620 <Benchmark_reportStats+0x1a20>
                    count += 1;
  217b1e:	49 83 c0 01          	add    r8,0x1
  217b22:	48 83 c2 ff          	add    rdx,0xffffffffffffffff
  217b26:	49 89 d1             	mov    r9,rdx
                while (count < find) : ({
  217b29:	4d 39 c6             	cmp    r14,r8
  217b2c:	0f 87 ae fe ff ff    	ja     2179e0 <Benchmark_reportStats+0x1de0>
  217b32:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  217b39:	1f 84 00 00 00 00 00 
  217b40:	48 8b 7c 24 20       	mov    rdi,QWORD PTR [rsp+0x20]
                if (count >= buffer_size) {
  217b45:	49 39 f8             	cmp    r8,rdi
  217b48:	0f 86 96 00 00 00    	jbe    217be4 <Benchmark_reportStats+0x1fe4>
                    pull[pull_index] = Pull{
  217b4e:	48 8b 44 24 38       	mov    rax,QWORD PTR [rsp+0x38]
  217b53:	48 8d 04 80          	lea    rax,[rax+rax*4]
  217b57:	48 89 94 c4 80 00 00 	mov    QWORD PTR [rsp+rax*8+0x80],rdx
  217b5e:	00 
  217b5f:	48 8b 4c 24 50       	mov    rcx,QWORD PTR [rsp+0x50]
  217b64:	48 89 8c c4 88 00 00 	mov    QWORD PTR [rsp+rax*8+0x88],rcx
  217b6b:	00 
  217b6c:	4c 89 84 c4 90 00 00 	mov    QWORD PTR [rsp+rax*8+0x90],r8
  217b73:	00 
  217b74:	48 8b 54 24 60       	mov    rdx,QWORD PTR [rsp+0x60]
  217b79:	48 89 94 c4 98 00 00 	mov    QWORD PTR [rsp+rax*8+0x98],rdx
  217b80:	00 
  217b81:	48 89 8c c4 a0 00 00 	mov    QWORD PTR [rsp+rax*8+0xa0],rcx
  217b88:	00 
  217b89:	48 8b 54 24 58       	mov    rdx,QWORD PTR [rsp+0x58]
                    if (count == buffer_size + buffer_size) {
  217b8e:	49 39 d0             	cmp    r8,rdx
  217b91:	4c 8b 8c 24 e0 00 00 	mov    r9,QWORD PTR [rsp+0xe0]
  217b98:	00 
  217b99:	0f 84 fe 00 00 00    	je     217c9d <Benchmark_reportStats+0x209d>
                    } else if (find == buffer_size + buffer_size) {
  217b9f:	49 39 d6             	cmp    r14,rdx
  217ba2:	0f 85 98 fa ff ff    	jne    217640 <Benchmark_reportStats+0x1a40>
                        buffer1 = Range.init(B.end - count, B.end);
  217ba8:	48 89 c8             	mov    rax,rcx
  217bab:	4c 29 c0             	sub    rax,r8
  217bae:	48 89 44 24 70       	mov    QWORD PTR [rsp+0x70],rax
  217bb3:	49 89 cd             	mov    r13,rcx
  217bb6:	b8 01 00 00 00       	mov    eax,0x1
  217bbb:	48 89 44 24 38       	mov    QWORD PTR [rsp+0x38],rax
  217bc0:	4c 8b 74 24 78       	mov    r14,QWORD PTR [rsp+0x78]
  217bc5:	e9 89 00 00 00       	jmp    217c53 <Benchmark_reportStats+0x2053>
  217bca:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  217bd0:	41 b8 01 00 00 00    	mov    r8d,0x1
  217bd6:	48 8b 7c 24 20       	mov    rdi,QWORD PTR [rsp+0x20]
                if (count >= buffer_size) {
  217bdb:	49 39 f8             	cmp    r8,rdi
  217bde:	0f 87 6a ff ff ff    	ja     217b4e <Benchmark_reportStats+0x1f4e>
                } else if (pull_index == 0 and count > buffer1.length()) {
  217be4:	48 83 7c 24 38 00    	cmp    QWORD PTR [rsp+0x38],0x0
  217bea:	4c 8b 8c 24 e0 00 00 	mov    r9,QWORD PTR [rsp+0xe0]
  217bf1:	00 
  217bf2:	0f 85 ad fa ff ff    	jne    2176a5 <Benchmark_reportStats+0x1aa5>
        return self.end - self.start;
  217bf8:	4c 89 e8             	mov    rax,r13
  217bfb:	48 2b 44 24 70       	sub    rax,QWORD PTR [rsp+0x70]
                } else if (pull_index == 0 and count > buffer1.length()) {
  217c00:	49 39 c0             	cmp    r8,rax
  217c03:	0f 86 95 fa ff ff    	jbe    21769e <Benchmark_reportStats+0x1a9e>
  217c09:	48 8b 44 24 50       	mov    rax,QWORD PTR [rsp+0x50]
                    buffer1 = Range.init(B.end - count, B.end);
  217c0e:	48 89 c6             	mov    rsi,rax
                    pull[pull_index] = Pull{
  217c11:	48 89 94 24 80 00 00 	mov    QWORD PTR [rsp+0x80],rdx
  217c18:	00 
  217c19:	48 89 c1             	mov    rcx,rax
  217c1c:	48 89 8c 24 88 00 00 	mov    QWORD PTR [rsp+0x88],rcx
  217c23:	00 
  217c24:	4c 89 84 24 90 00 00 	mov    QWORD PTR [rsp+0x90],r8
  217c2b:	00 
  217c2c:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
  217c31:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  217c38:	00 
                    buffer1 = Range.init(B.end - count, B.end);
  217c39:	4c 29 c6             	sub    rsi,r8
  217c3c:	48 89 74 24 70       	mov    QWORD PTR [rsp+0x70],rsi
                    pull[pull_index] = Pull{
  217c41:	48 89 8c 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rcx
  217c48:	00 
  217c49:	49 89 cd             	mov    r13,rcx
  217c4c:	31 c0                	xor    eax,eax
  217c4e:	48 89 44 24 38       	mov    QWORD PTR [rsp+0x38],rax
  217c53:	48 8b 84 24 f0 00 00 	mov    rax,QWORD PTR [rsp+0xf0]
  217c5a:	00 
  217c5b:	48 8b 5c 24 30       	mov    rbx,QWORD PTR [rsp+0x30]
  217c60:	48 2b 5c 24 28       	sub    rbx,QWORD PTR [rsp+0x28]
        return self.decimal >= self.size;
  217c65:	48 39 c1             	cmp    rcx,rax
            while (!iterator.finished()) {
  217c68:	0f 82 82 fa ff ff    	jb     2176f0 <Benchmark_reportStats+0x1af0>
  217c6e:	4c 89 ac 24 d0 00 00 	mov    QWORD PTR [rsp+0xd0],r13
  217c75:	00 
  217c76:	eb 64                	jmp    217cdc <Benchmark_reportStats+0x20dc>
  217c78:	48 8b 4c 24 78       	mov    rcx,QWORD PTR [rsp+0x78]
                        buffer1 = Range.init(A.start, A.start + buffer_size);
  217c7d:	48 01 c1             	add    rcx,rax
                        buffer2 = Range.init(A.start + buffer_size, A.start + count);
  217c80:	48 01 c6             	add    rsi,rax
  217c83:	48 89 8c 24 d0 00 00 	mov    QWORD PTR [rsp+0xd0],rcx
  217c8a:	00 
  217c8b:	48 89 44 24 70       	mov    QWORD PTR [rsp+0x70],rax
  217c90:	48 89 f0             	mov    rax,rsi
  217c93:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
  217c98:	48 89 c8             	mov    rax,rcx
  217c9b:	eb 48                	jmp    217ce5 <Benchmark_reportStats+0x20e5>
                        buffer1 = Range.init(B.end - count, B.end - buffer_size);
  217c9d:	48 89 c8             	mov    rax,rcx
  217ca0:	48 29 d0             	sub    rax,rdx
  217ca3:	48 89 44 24 70       	mov    QWORD PTR [rsp+0x70],rax
  217ca8:	48 2b 4c 24 78       	sub    rcx,QWORD PTR [rsp+0x78]
  217cad:	48 89 8c 24 d0 00 00 	mov    QWORD PTR [rsp+0xd0],rcx
  217cb4:	00 
  217cb5:	48 89 c8             	mov    rax,rcx
  217cb8:	eb 2b                	jmp    217ce5 <Benchmark_reportStats+0x20e5>
  217cba:	4c 89 ac 24 d0 00 00 	mov    QWORD PTR [rsp+0xd0],r13
  217cc1:	00 
  217cc2:	48 89 44 24 70       	mov    QWORD PTR [rsp+0x70],rax
  217cc7:	eb 13                	jmp    217cdc <Benchmark_reportStats+0x20dc>
                        buffer1 = Range.init(B.end - count, B.end);
  217cc9:	48 89 c8             	mov    rax,rcx
  217ccc:	4c 29 c0             	sub    rax,r8
  217ccf:	48 89 44 24 70       	mov    QWORD PTR [rsp+0x70],rax
  217cd4:	48 89 8c 24 d0 00 00 	mov    QWORD PTR [rsp+0xd0],rcx
  217cdb:	00 
  217cdc:	31 c0                	xor    eax,eax
  217cde:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
  217ce3:	31 c0                	xor    eax,eax
  217ce5:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  217cea:	31 c0                	xor    eax,eax
  217cec:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  217cf0:	48 89 44 24 58       	mov    QWORD PTR [rsp+0x58],rax
                const length = pull[pull_index].count;
  217cf5:	48 8d 04 80          	lea    rax,[rax+rax*4]
  217cf9:	48 8d 0c c4          	lea    rcx,[rsp+rax*8]
  217cfd:	48 81 c1 80 00 00 00 	add    rcx,0x80
  217d04:	48 89 4c 24 20       	mov    QWORD PTR [rsp+0x20],rcx
  217d09:	48 8b 94 c4 90 00 00 	mov    rdx,QWORD PTR [rsp+rax*8+0x90]
  217d10:	00 
                if (pull[pull_index].to < pull[pull_index].from) {
  217d11:	4c 8b a4 c4 80 00 00 	mov    r12,QWORD PTR [rsp+rax*8+0x80]
  217d18:	00 
  217d19:	48 8b 8c c4 88 00 00 	mov    rcx,QWORD PTR [rsp+rax*8+0x88]
  217d20:	00 
  217d21:	4c 39 e1             	cmp    rcx,r12
  217d24:	48 89 54 24 10       	mov    QWORD PTR [rsp+0x10],rdx
  217d29:	0f 83 21 06 00 00    	jae    218350 <Benchmark_reportStats+0x2750>
                    while (count < length) : (count += 1) {
  217d2f:	48 83 fa 02          	cmp    rdx,0x2
  217d33:	0f 82 14 0b 00 00    	jb     21884d <Benchmark_reportStats+0x2c4d>
  217d39:	49 c7 c2 ff ff ff ff 	mov    r10,0xffffffffffffffff
  217d40:	49 c7 c1 fe ff ff ff 	mov    r9,0xfffffffffffffffe
  217d47:	31 c0                	xor    eax,eax
  217d49:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  217d4e:	4d 89 e6             	mov    r14,r12
  217d51:	41 bb 01 00 00 00    	mov    r11d,0x1
  217d57:	eb 13                	jmp    217d6c <Benchmark_reportStats+0x216c>
  217d59:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
                        index = findFirstBackward(T, items, items[index - 1], Range.init(pull[pull_index].to, pull[pull_index].from - (count - 1)), lessThan, length - count);
  217d60:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
                    while (count < length) : (count += 1) {
  217d64:	49 83 c2 ff          	add    r10,0xffffffffffffffff
  217d68:	49 83 c1 ff          	add    r9,0xffffffffffffffff
                        index = findFirstBackward(T, items, items[index - 1], Range.init(pull[pull_index].to, pull[pull_index].from - (count - 1)), lessThan, length - count);
  217d6c:	4c 8b 6c 24 40       	mov    r13,QWORD PTR [rsp+0x40]
  217d71:	bf 01 00 00 00       	mov    edi,0x1
  217d76:	4c 29 df             	sub    rdi,r11
  217d79:	4c 01 e7             	add    rdi,r12
    if (range.length() == 0) return range.start;
  217d7c:	48 89 f8             	mov    rax,rdi
  217d7f:	48 29 c8             	sub    rax,rcx
  217d82:	74 2c                	je     217db0 <Benchmark_reportStats+0x21b0>
  217d84:	49 c1 e6 04          	shl    r14,0x4
                        index = findFirstBackward(T, items, items[index - 1], Range.init(pull[pull_index].to, pull[pull_index].from - (count - 1)), lessThan, length - count);
  217d88:	48 89 d6             	mov    rsi,rdx
  217d8b:	4c 29 de             	sub    rsi,r11
  217d8e:	48 89 c2             	mov    rdx,rax
  217d91:	48 09 f2             	or     rdx,rsi
  217d94:	48 c1 ea 20          	shr    rdx,0x20
  217d98:	74 26                	je     217dc0 <Benchmark_reportStats+0x21c0>
  217d9a:	31 d2                	xor    edx,edx
  217d9c:	48 f7 f6             	div    rsi
  217d9f:	eb 23                	jmp    217dc4 <Benchmark_reportStats+0x21c4>
  217da1:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  217da8:	0f 1f 84 00 00 00 00 
  217daf:	00 
  217db0:	49 89 ce             	mov    r14,rcx
  217db3:	e9 48 01 00 00       	jmp    217f00 <Benchmark_reportStats+0x2300>
  217db8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  217dbf:	00 
  217dc0:	31 d2                	xor    edx,edx
  217dc2:	f7 f6                	div    esi
  217dc4:	48 83 f8 01          	cmp    rax,0x1
  217dc8:	ba 01 00 00 00       	mov    edx,0x1
  217dcd:	48 0f 46 c2          	cmovbe rax,rdx
  217dd1:	4f 8d 3c 2e          	lea    r15,[r14+r13*1]
  217dd5:	49 83 c7 f0          	add    r15,0xfffffffffffffff0
  217dd9:	48 89 fe             	mov    rsi,rdi
  217ddc:	48 29 c6             	sub    rsi,rax
    while (index > range.start and !lessThan(items[index - 1], value)) : (index -= skip) {
  217ddf:	48 39 ce             	cmp    rsi,rcx
  217de2:	76 3c                	jbe    217e20 <Benchmark_reportStats+0x2220>
  217de4:	4d 8b 07             	mov    r8,QWORD PTR [r15]
  217de7:	4c 8d 34 08          	lea    r14,[rax+rcx*1]
  217deb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  217df0:	48 89 f2             	mov    rdx,rsi
  217df3:	48 8d 5a ff          	lea    rbx,[rdx-0x1]
  217df7:	48 89 de             	mov    rsi,rbx
  217dfa:	48 c1 e6 04          	shl    rsi,0x4
  217dfe:	4d 39 44 35 00       	cmp    QWORD PTR [r13+rsi*1+0x0],r8
  217e03:	0f 82 95 00 00 00    	jb     217e9e <Benchmark_reportStats+0x229e>
        if (index < range.start + skip) {
  217e09:	4c 39 f2             	cmp    rdx,r14
  217e0c:	0f 82 9d 00 00 00    	jb     217eaf <Benchmark_reportStats+0x22af>
  217e12:	48 89 d6             	mov    rsi,rdx
  217e15:	48 29 c6             	sub    rsi,rax
  217e18:	48 89 d7             	mov    rdi,rdx
    while (index > range.start and !lessThan(items[index - 1], value)) : (index -= skip) {
  217e1b:	48 39 ce             	cmp    rsi,rcx
  217e1e:	77 d0                	ja     217df0 <Benchmark_reportStats+0x21f0>
    if (range.start >= range.end) return range.end;
  217e20:	48 85 c0             	test   rax,rax
  217e23:	0f 84 81 00 00 00    	je     217eaa <Benchmark_reportStats+0x22aa>
    var end = range.end - 1;
  217e29:	48 83 c7 ff          	add    rdi,0xffffffffffffffff
    while (start < end) {
  217e2d:	48 39 f7             	cmp    rdi,rsi
  217e30:	76 4a                	jbe    217e7c <Benchmark_reportStats+0x227c>
  217e32:	4d 8b 07             	mov    r8,QWORD PTR [r15]
  217e35:	48 89 f9             	mov    rcx,rdi
  217e38:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  217e3f:	00 
        const mid = start + (end - start) / 2;
  217e40:	48 89 ca             	mov    rdx,rcx
  217e43:	48 29 f2             	sub    rdx,rsi
  217e46:	48 d1 ea             	shr    rdx,1
  217e49:	48 8d 04 32          	lea    rax,[rdx+rsi*1]
  217e4d:	48 89 c3             	mov    rbx,rax
  217e50:	48 c1 e3 04          	shl    rbx,0x4
  217e54:	4d 39 44 1d 00       	cmp    QWORD PTR [r13+rbx*1+0x0],r8
        if (lessThan(items[mid], value)) {
  217e59:	72 15                	jb     217e70 <Benchmark_reportStats+0x2270>
  217e5b:	48 89 c1             	mov    rcx,rax
    while (start < end) {
  217e5e:	48 39 f1             	cmp    rcx,rsi
  217e61:	77 dd                	ja     217e40 <Benchmark_reportStats+0x2240>
  217e63:	eb 17                	jmp    217e7c <Benchmark_reportStats+0x227c>
  217e65:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  217e6c:	00 00 00 00 
  217e70:	48 01 d6             	add    rsi,rdx
  217e73:	48 83 c6 01          	add    rsi,0x1
  217e77:	48 39 f1             	cmp    rcx,rsi
  217e7a:	77 c4                	ja     217e40 <Benchmark_reportStats+0x2240>
    if (start == range.end - 1 and lessThan(items[start], value)) {
  217e7c:	48 39 fe             	cmp    rsi,rdi
  217e7f:	75 15                	jne    217e96 <Benchmark_reportStats+0x2296>
  217e81:	48 c1 e7 04          	shl    rdi,0x4
  217e85:	49 8b 44 3d 00       	mov    rax,QWORD PTR [r13+rdi*1+0x0]
  217e8a:	45 31 f6             	xor    r14d,r14d
  217e8d:	49 3b 07             	cmp    rax,QWORD PTR [r15]
  217e90:	41 0f 92 c6          	setb   r14b
  217e94:	eb 03                	jmp    217e99 <Benchmark_reportStats+0x2299>
  217e96:	45 31 f6             	xor    r14d,r14d
  217e99:	49 01 f6             	add    r14,rsi
  217e9c:	eb 62                	jmp    217f00 <Benchmark_reportStats+0x2300>
  217e9e:	48 89 d6             	mov    rsi,rdx
    if (range.start >= range.end) return range.end;
  217ea1:	48 85 c0             	test   rax,rax
  217ea4:	0f 85 7f ff ff ff    	jne    217e29 <Benchmark_reportStats+0x2229>
  217eaa:	49 89 fe             	mov    r14,rdi
  217ead:	eb 51                	jmp    217f00 <Benchmark_reportStats+0x2300>
  217eaf:	49 89 ce             	mov    r14,rcx
    while (start < end) {
  217eb2:	48 39 cb             	cmp    rbx,rcx
  217eb5:	76 49                	jbe    217f00 <Benchmark_reportStats+0x2300>
  217eb7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  217ebe:	00 00 
        const mid = start + (end - start) / 2;
  217ec0:	48 89 d8             	mov    rax,rbx
  217ec3:	4c 29 f0             	sub    rax,r14
  217ec6:	48 d1 e8             	shr    rax,1
  217ec9:	4a 8d 0c 30          	lea    rcx,[rax+r14*1]
  217ecd:	48 89 ca             	mov    rdx,rcx
  217ed0:	48 c1 e2 04          	shl    rdx,0x4
  217ed4:	4d 39 44 15 00       	cmp    QWORD PTR [r13+rdx*1+0x0],r8
        if (lessThan(items[mid], value)) {
  217ed9:	72 15                	jb     217ef0 <Benchmark_reportStats+0x22f0>
  217edb:	48 89 cb             	mov    rbx,rcx
    while (start < end) {
  217ede:	4c 39 f3             	cmp    rbx,r14
  217ee1:	77 dd                	ja     217ec0 <Benchmark_reportStats+0x22c0>
  217ee3:	eb 1b                	jmp    217f00 <Benchmark_reportStats+0x2300>
  217ee5:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  217eec:	00 00 00 00 
  217ef0:	49 01 c6             	add    r14,rax
  217ef3:	49 83 c6 01          	add    r14,0x1
  217ef7:	4c 39 f3             	cmp    rbx,r14
  217efa:	77 c4                	ja     217ec0 <Benchmark_reportStats+0x22c0>
  217efc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
                        const range = Range.init(index + 1, pull[pull_index].from + 1);
  217f00:	4d 89 f7             	mov    r15,r14
  217f03:	49 c1 e7 04          	shl    r15,0x4
  217f07:	4c 89 f0             	mov    rax,r14
  217f0a:	48 f7 d0             	not    rax
                        mem.rotate(T, items[range.start..range.end], range.length() - count);
  217f0d:	4d 8d 04 04          	lea    r8,[r12+rax*1]
  217f11:	49 83 c0 01          	add    r8,0x1
  217f15:	4c 89 c2             	mov    rdx,r8
  217f18:	4c 29 da             	sub    rdx,r11
}

/// In-place order reversal of a slice
pub fn reverse(comptime T: type, items: []T) void {
    var i: usize = 0;
    const end = items.len / 2;
  217f1b:	48 d1 ea             	shr    rdx,1
    while (i < end) : (i += 1) {
  217f1e:	0f 84 44 01 00 00    	je     218068 <Benchmark_reportStats+0x2468>
        swap(T, &items[i], &items[items.len - i - 1]);
  217f24:	48 8d 42 ff          	lea    rax,[rdx-0x1]
  217f28:	48 83 f8 03          	cmp    rax,0x3
  217f2c:	73 12                	jae    217f40 <Benchmark_reportStats+0x2340>
  217f2e:	31 f6                	xor    esi,esi
    while (i < end) : (i += 1) {
  217f30:	f6 c2 03             	test   dl,0x3
  217f33:	0f 85 c5 00 00 00    	jne    217ffe <Benchmark_reportStats+0x23fe>
  217f39:	e9 2a 01 00 00       	jmp    218068 <Benchmark_reportStats+0x2468>
  217f3e:	66 90                	xchg   ax,ax
        swap(T, &items[i], &items[items.len - i - 1]);
  217f40:	4b 8d 0c 2f          	lea    rcx,[r15+r13*1]
  217f44:	48 83 c1 40          	add    rcx,0x40
  217f48:	4b 8d 3c 14          	lea    rdi,[r12+r10*1]
  217f4c:	4c 29 f7             	sub    rdi,r14
  217f4f:	48 d1 ef             	shr    rdi,1
  217f52:	89 f8                	mov    eax,edi
  217f54:	83 e0 03             	and    eax,0x3
  217f57:	48 29 c7             	sub    rdi,rax
  217f5a:	4b 8d 04 0c          	lea    rax,[r12+r9*1]
  217f5e:	48 c1 e0 04          	shl    rax,0x4
  217f62:	4c 01 e8             	add    rax,r13
  217f65:	48 83 c0 10          	add    rax,0x10
  217f69:	31 f6                	xor    esi,esi
  217f6b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
    const tmp = a.*;
  217f70:	c5 f8 10 41 d0       	vmovups xmm0,XMMWORD PTR [rcx-0x30]
  217f75:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  217f7a:	c5 f8 10 00          	vmovups xmm0,XMMWORD PTR [rax]
  217f7e:	c5 f8 11 41 d0       	vmovups XMMWORD PTR [rcx-0x30],xmm0
    b.* = tmp;
  217f83:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  217f88:	c5 f8 11 00          	vmovups XMMWORD PTR [rax],xmm0
    const tmp = a.*;
  217f8c:	c5 f8 10 41 e0       	vmovups xmm0,XMMWORD PTR [rcx-0x20]
  217f91:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  217f96:	c5 f8 10 40 f0       	vmovups xmm0,XMMWORD PTR [rax-0x10]
  217f9b:	c5 f8 11 41 e0       	vmovups XMMWORD PTR [rcx-0x20],xmm0
    b.* = tmp;
  217fa0:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  217fa5:	c5 f8 11 40 f0       	vmovups XMMWORD PTR [rax-0x10],xmm0
    const tmp = a.*;
  217faa:	c5 f8 10 41 f0       	vmovups xmm0,XMMWORD PTR [rcx-0x10]
  217faf:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  217fb4:	c5 f8 10 40 e0       	vmovups xmm0,XMMWORD PTR [rax-0x20]
  217fb9:	c5 f8 11 41 f0       	vmovups XMMWORD PTR [rcx-0x10],xmm0
    b.* = tmp;
  217fbe:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  217fc3:	c5 f8 11 40 e0       	vmovups XMMWORD PTR [rax-0x20],xmm0
    const tmp = a.*;
  217fc8:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  217fcc:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  217fd1:	c5 f8 10 40 d0       	vmovups xmm0,XMMWORD PTR [rax-0x30]
  217fd6:	c5 f8 11 01          	vmovups XMMWORD PTR [rcx],xmm0
    b.* = tmp;
  217fda:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  217fdf:	c5 fa 7f 40 d0       	vmovdqu XMMWORD PTR [rax-0x30],xmm0
    while (i < end) : (i += 1) {
  217fe4:	48 83 c6 04          	add    rsi,0x4
  217fe8:	48 83 c1 40          	add    rcx,0x40
  217fec:	48 83 c0 c0          	add    rax,0xffffffffffffffc0
  217ff0:	48 39 f7             	cmp    rdi,rsi
  217ff3:	0f 85 77 ff ff ff    	jne    217f70 <Benchmark_reportStats+0x2370>
  217ff9:	f6 c2 03             	test   dl,0x3
  217ffc:	74 6a                	je     218068 <Benchmark_reportStats+0x2468>
  217ffe:	4b 8d 04 0c          	lea    rax,[r12+r9*1]
  218002:	48 29 f0             	sub    rax,rsi
  218005:	48 c1 e0 04          	shl    rax,0x4
  218009:	4c 01 e8             	add    rax,r13
  21800c:	48 83 c0 10          	add    rax,0x10
  218010:	4c 01 f6             	add    rsi,r14
  218013:	48 c1 e6 04          	shl    rsi,0x4
  218017:	4a 8d 0c 2e          	lea    rcx,[rsi+r13*1]
  21801b:	48 83 c1 10          	add    rcx,0x10
  21801f:	43 8d 14 14          	lea    edx,[r12+r10*1]
  218023:	44 29 f2             	sub    edx,r14d
  218026:	be 01 02 00 00       	mov    esi,0x201
  21802b:	c4 e2 48 f7 d2       	bextr  edx,edx,esi
  218030:	48 f7 da             	neg    rdx
  218033:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21803a:	84 00 00 00 00 00 
    const tmp = a.*;
  218040:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  218044:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  218049:	c5 f8 10 00          	vmovups xmm0,XMMWORD PTR [rax]
  21804d:	c5 f8 11 01          	vmovups XMMWORD PTR [rcx],xmm0
    b.* = tmp;
  218051:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  218056:	c5 fa 7f 00          	vmovdqu XMMWORD PTR [rax],xmm0
    while (i < end) : (i += 1) {
  21805a:	48 83 c0 f0          	add    rax,0xfffffffffffffff0
  21805e:	48 83 c1 10          	add    rcx,0x10
  218062:	48 83 c2 01          	add    rdx,0x1
  218066:	75 d8                	jne    218040 <Benchmark_reportStats+0x2440>
  218068:	48 83 44 24 18 01    	add    QWORD PTR [rsp+0x18],0x1
  21806e:	49 83 fb 02          	cmp    r11,0x2
  218072:	0f 82 40 01 00 00    	jb     2181b8 <Benchmark_reportStats+0x25b8>
  218078:	4c 89 d9             	mov    rcx,r11
  21807b:	48 d1 e9             	shr    rcx,1
  21807e:	89 ca                	mov    edx,ecx
  218080:	83 e2 03             	and    edx,0x3
  218083:	48 8b 5c 24 18       	mov    rbx,QWORD PTR [rsp+0x18]
  218088:	48 d1 eb             	shr    rbx,1
  21808b:	48 8d 43 ff          	lea    rax,[rbx-0x1]
        swap(T, &items[i], &items[items.len - i - 1]);
  21808f:	48 83 f8 03          	cmp    rax,0x3
  218093:	73 1b                	jae    2180b0 <Benchmark_reportStats+0x24b0>
  218095:	31 ff                	xor    edi,edi
    while (i < end) : (i += 1) {
  218097:	f6 c3 03             	test   bl,0x3
  21809a:	0f 85 ce 00 00 00    	jne    21816e <Benchmark_reportStats+0x256e>
  2180a0:	e9 13 01 00 00       	jmp    2181b8 <Benchmark_reportStats+0x25b8>
  2180a5:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  2180ac:	00 00 00 00 
  2180b0:	48 29 d1             	sub    rcx,rdx
        swap(T, &items[i], &items[items.len - i - 1]);
  2180b3:	4b 8d 04 14          	lea    rax,[r12+r10*1]
  2180b7:	48 c1 e0 04          	shl    rax,0x4
  2180bb:	4a 8d 34 28          	lea    rsi,[rax+r13*1]
  2180bf:	48 83 c6 40          	add    rsi,0x40
  2180c3:	4c 89 e0             	mov    rax,r12
  2180c6:	48 c1 e0 04          	shl    rax,0x4
  2180ca:	4c 01 e8             	add    rax,r13
  2180cd:	48 83 c0 f0          	add    rax,0xfffffffffffffff0
  2180d1:	31 ff                	xor    edi,edi
  2180d3:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  2180da:	84 00 00 00 00 00 
    const tmp = a.*;
  2180e0:	c5 f8 10 46 d0       	vmovups xmm0,XMMWORD PTR [rsi-0x30]
  2180e5:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  2180ea:	c5 f8 10 40 10       	vmovups xmm0,XMMWORD PTR [rax+0x10]
  2180ef:	c5 f8 11 46 d0       	vmovups XMMWORD PTR [rsi-0x30],xmm0
    b.* = tmp;
  2180f4:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  2180f9:	c5 f8 11 40 10       	vmovups XMMWORD PTR [rax+0x10],xmm0
    const tmp = a.*;
  2180fe:	c5 f8 10 46 e0       	vmovups xmm0,XMMWORD PTR [rsi-0x20]
  218103:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  218108:	c5 f8 10 00          	vmovups xmm0,XMMWORD PTR [rax]
  21810c:	c5 f8 11 46 e0       	vmovups XMMWORD PTR [rsi-0x20],xmm0
    b.* = tmp;
  218111:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  218116:	c5 f8 11 00          	vmovups XMMWORD PTR [rax],xmm0
    const tmp = a.*;
  21811a:	c5 f8 10 46 f0       	vmovups xmm0,XMMWORD PTR [rsi-0x10]
  21811f:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  218124:	c5 f8 10 40 f0       	vmovups xmm0,XMMWORD PTR [rax-0x10]
  218129:	c5 f8 11 46 f0       	vmovups XMMWORD PTR [rsi-0x10],xmm0
    b.* = tmp;
  21812e:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  218133:	c5 f8 11 40 f0       	vmovups XMMWORD PTR [rax-0x10],xmm0
    const tmp = a.*;
  218138:	c5 f8 10 06          	vmovups xmm0,XMMWORD PTR [rsi]
  21813c:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  218141:	c5 f8 10 40 e0       	vmovups xmm0,XMMWORD PTR [rax-0x20]
  218146:	c5 f8 11 06          	vmovups XMMWORD PTR [rsi],xmm0
    b.* = tmp;
  21814a:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  21814f:	c5 fa 7f 40 e0       	vmovdqu XMMWORD PTR [rax-0x20],xmm0
    while (i < end) : (i += 1) {
  218154:	48 83 c7 04          	add    rdi,0x4
  218158:	48 83 c6 40          	add    rsi,0x40
  21815c:	48 83 c0 c0          	add    rax,0xffffffffffffffc0
  218160:	48 39 f9             	cmp    rcx,rdi
  218163:	0f 85 77 ff ff ff    	jne    2180e0 <Benchmark_reportStats+0x24e0>
  218169:	f6 c3 03             	test   bl,0x3
  21816c:	74 4a                	je     2181b8 <Benchmark_reportStats+0x25b8>
  21816e:	48 f7 da             	neg    rdx
  218171:	4c 89 e0             	mov    rax,r12
  218174:	48 29 f8             	sub    rax,rdi
  218177:	48 c1 e0 04          	shl    rax,0x4
  21817b:	4c 01 e8             	add    rax,r13
  21817e:	4c 01 e7             	add    rdi,r12
  218181:	4c 01 d7             	add    rdi,r10
  218184:	48 c1 e7 04          	shl    rdi,0x4
  218188:	4a 8d 0c 2f          	lea    rcx,[rdi+r13*1]
  21818c:	48 83 c1 10          	add    rcx,0x10
    const tmp = a.*;
  218190:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  218194:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  218199:	c5 f8 10 00          	vmovups xmm0,XMMWORD PTR [rax]
  21819d:	c5 f8 11 01          	vmovups XMMWORD PTR [rcx],xmm0
    b.* = tmp;
  2181a1:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  2181a6:	c5 fa 7f 00          	vmovdqu XMMWORD PTR [rax],xmm0
    while (i < end) : (i += 1) {
  2181aa:	48 83 c0 f0          	add    rax,0xfffffffffffffff0
  2181ae:	48 83 c1 10          	add    rcx,0x10
  2181b2:	48 83 c2 01          	add    rdx,0x1
  2181b6:	75 d8                	jne    218190 <Benchmark_reportStats+0x2590>
    const end = items.len / 2;
  2181b8:	49 d1 e8             	shr    r8,1
    while (i < end) : (i += 1) {
  2181bb:	0f 84 5f 01 00 00    	je     218320 <Benchmark_reportStats+0x2720>
  2181c1:	4b 8d 0c 2f          	lea    rcx,[r15+r13*1]
  2181c5:	48 83 c1 10          	add    rcx,0x10
        swap(T, &items[i], &items[items.len - i - 1]);
  2181c9:	4c 89 e0             	mov    rax,r12
    const tmp = a.*;
  2181cc:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  2181d0:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  2181d5:	48 c1 e0 04          	shl    rax,0x4
    a.* = b.*;
  2181d9:	c4 c1 78 10 44 05 00 	vmovups xmm0,XMMWORD PTR [r13+rax*1+0x0]
  2181e0:	c5 f8 11 01          	vmovups XMMWORD PTR [rcx],xmm0
    b.* = tmp;
  2181e4:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  2181e9:	c4 c1 7a 7f 44 05 00 	vmovdqu XMMWORD PTR [r13+rax*1+0x0],xmm0
    while (i < end) : (i += 1) {
  2181f0:	49 83 f8 01          	cmp    r8,0x1
  2181f4:	0f 84 26 01 00 00    	je     218320 <Benchmark_reportStats+0x2720>
        swap(T, &items[i], &items[items.len - i - 1]);
  2181fa:	41 8d 50 ff          	lea    edx,[r8-0x1]
  2181fe:	49 8d 48 fe          	lea    rcx,[r8-0x2]
  218202:	83 e2 03             	and    edx,0x3
  218205:	48 83 f9 03          	cmp    rcx,0x3
  218209:	73 13                	jae    21821e <Benchmark_reportStats+0x261e>
  21820b:	b9 01 00 00 00       	mov    ecx,0x1
    while (i < end) : (i += 1) {
  218210:	48 85 d2             	test   rdx,rdx
  218213:	0f 85 b5 00 00 00    	jne    2182ce <Benchmark_reportStats+0x26ce>
  218219:	e9 02 01 00 00       	jmp    218320 <Benchmark_reportStats+0x2720>
        swap(T, &items[i], &items[items.len - i - 1]);
  21821e:	4a 8d 34 28          	lea    rsi,[rax+r13*1]
  218222:	48 83 c6 f0          	add    rsi,0xfffffffffffffff0
  218226:	4b 8d 3c 2f          	lea    rdi,[r15+r13*1]
  21822a:	48 83 c7 50          	add    rdi,0x50
  21822e:	49 29 d0             	sub    r8,rdx
  218231:	b9 01 00 00 00       	mov    ecx,0x1
  218236:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  21823d:	00 00 00 
    const tmp = a.*;
  218240:	c5 f8 10 47 d0       	vmovups xmm0,XMMWORD PTR [rdi-0x30]
  218245:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21824a:	c5 f8 10 06          	vmovups xmm0,XMMWORD PTR [rsi]
  21824e:	c5 f8 11 47 d0       	vmovups XMMWORD PTR [rdi-0x30],xmm0
    b.* = tmp;
  218253:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  218258:	c5 f8 11 06          	vmovups XMMWORD PTR [rsi],xmm0
    const tmp = a.*;
  21825c:	c5 f8 10 47 e0       	vmovups xmm0,XMMWORD PTR [rdi-0x20]
  218261:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  218266:	c5 f8 10 46 f0       	vmovups xmm0,XMMWORD PTR [rsi-0x10]
  21826b:	c5 f8 11 47 e0       	vmovups XMMWORD PTR [rdi-0x20],xmm0
    b.* = tmp;
  218270:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  218275:	c5 f8 11 46 f0       	vmovups XMMWORD PTR [rsi-0x10],xmm0
    const tmp = a.*;
  21827a:	c5 f8 10 47 f0       	vmovups xmm0,XMMWORD PTR [rdi-0x10]
  21827f:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  218284:	c5 f8 10 46 e0       	vmovups xmm0,XMMWORD PTR [rsi-0x20]
  218289:	c5 f8 11 47 f0       	vmovups XMMWORD PTR [rdi-0x10],xmm0
    b.* = tmp;
  21828e:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  218293:	c5 f8 11 46 e0       	vmovups XMMWORD PTR [rsi-0x20],xmm0
    const tmp = a.*;
  218298:	c5 f8 10 07          	vmovups xmm0,XMMWORD PTR [rdi]
  21829c:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  2182a1:	c5 f8 10 46 d0       	vmovups xmm0,XMMWORD PTR [rsi-0x30]
  2182a6:	c5 f8 11 07          	vmovups XMMWORD PTR [rdi],xmm0
    b.* = tmp;
  2182aa:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  2182af:	c5 fa 7f 46 d0       	vmovdqu XMMWORD PTR [rsi-0x30],xmm0
    while (i < end) : (i += 1) {
  2182b4:	48 83 c1 04          	add    rcx,0x4
  2182b8:	48 83 c6 c0          	add    rsi,0xffffffffffffffc0
  2182bc:	48 83 c7 40          	add    rdi,0x40
  2182c0:	49 39 c8             	cmp    r8,rcx
  2182c3:	0f 85 77 ff ff ff    	jne    218240 <Benchmark_reportStats+0x2640>
  2182c9:	48 85 d2             	test   rdx,rdx
  2182cc:	74 52                	je     218320 <Benchmark_reportStats+0x2720>
  2182ce:	49 29 cc             	sub    r12,rcx
  2182d1:	49 c1 e4 04          	shl    r12,0x4
  2182d5:	4d 01 ec             	add    r12,r13
  2182d8:	4c 01 f1             	add    rcx,r14
  2182db:	48 c1 e1 04          	shl    rcx,0x4
  2182df:	4a 8d 04 29          	lea    rax,[rcx+r13*1]
  2182e3:	48 83 c0 10          	add    rax,0x10
  2182e7:	48 f7 da             	neg    rdx
  2182ea:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
    const tmp = a.*;
  2182f0:	c5 f8 10 00          	vmovups xmm0,XMMWORD PTR [rax]
  2182f4:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  2182f9:	c4 c1 78 10 04 24    	vmovups xmm0,XMMWORD PTR [r12]
  2182ff:	c5 f8 11 00          	vmovups XMMWORD PTR [rax],xmm0
    b.* = tmp;
  218303:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  218308:	c4 c1 7a 7f 04 24    	vmovdqu XMMWORD PTR [r12],xmm0
    while (i < end) : (i += 1) {
  21830e:	49 83 c4 f0          	add    r12,0xfffffffffffffff0
  218312:	48 83 c0 10          	add    rax,0x10
  218316:	48 83 c2 01          	add    rdx,0x1
  21831a:	75 d4                	jne    2182f0 <Benchmark_reportStats+0x26f0>
  21831c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
                        pull[pull_index].from = index + count;
  218320:	4f 8d 24 1e          	lea    r12,[r14+r11*1]
  218324:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
  218329:	4c 89 20             	mov    QWORD PTR [rax],r12
                    while (count < length) : (count += 1) {
  21832c:	49 83 c3 01          	add    r11,0x1
  218330:	48 8b 54 24 10       	mov    rdx,QWORD PTR [rsp+0x10]
  218335:	49 39 d3             	cmp    r11,rdx
  218338:	0f 85 22 fa ff ff    	jne    217d60 <Benchmark_reportStats+0x2160>
  21833e:	e9 0a 05 00 00       	jmp    21884d <Benchmark_reportStats+0x2c4d>
  218343:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21834a:	84 00 00 00 00 00 
                    while (count < length) : (count += 1) {
  218350:	48 83 fa 02          	cmp    rdx,0x2
                } else if (pull[pull_index].to > pull[pull_index].from) {
  218354:	0f 82 f3 04 00 00    	jb     21884d <Benchmark_reportStats+0x2c4d>
  21835a:	4c 39 e1             	cmp    rcx,r12
  21835d:	0f 86 ea 04 00 00    	jbe    21884d <Benchmark_reportStats+0x2c4d>
                    index = pull[pull_index].from + 1;
  218363:	49 8d 44 24 01       	lea    rax,[r12+0x1]
  218368:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  21836d:	49 c7 c6 ff ff ff ff 	mov    r14,0xffffffffffffffff
  218374:	48 c7 44 24 30 fe ff 	mov    QWORD PTR [rsp+0x30],0xfffffffffffffffe
  21837b:	ff ff 
  21837d:	b8 02 00 00 00       	mov    eax,0x2
  218382:	48 89 44 24 28       	mov    QWORD PTR [rsp+0x28],rax
  218387:	45 31 ff             	xor    r15d,r15d
  21838a:	41 bd 01 00 00 00    	mov    r13d,0x1
  218390:	eb 30                	jmp    2183c2 <Benchmark_reportStats+0x27c2>
  218392:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  218399:	1f 84 00 00 00 00 00 
                        index = findLastForward(T, items, items[index], Range.init(index, pull[pull_index].to), lessThan, length - count);
  2183a0:	48 8b 49 08          	mov    rcx,QWORD PTR [rcx+0x8]
                    while (count < length) : (count += 1) {
  2183a4:	49 83 c6 01          	add    r14,0x1
  2183a8:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  2183ac:	48 89 44 24 30       	mov    QWORD PTR [rsp+0x30],rax
  2183b1:	49 83 c7 01          	add    r15,0x1
  2183b5:	4c 89 7c 24 28       	mov    QWORD PTR [rsp+0x28],r15
  2183ba:	4c 8b 7c 24 38       	mov    r15,QWORD PTR [rsp+0x38]
                        const range = Range.init(pull[pull_index].from, index - 1);
  2183bf:	4d 89 cc             	mov    r12,r9
                        index = findLastForward(T, items, items[index], Range.init(index, pull[pull_index].to), lessThan, length - count);
  2183c2:	49 8d 47 01          	lea    rax,[r15+0x1]
  2183c6:	48 89 44 24 38       	mov    QWORD PTR [rsp+0x38],rax
  2183cb:	48 8b 5c 24 40       	mov    rbx,QWORD PTR [rsp+0x40]
  2183d0:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  2183d5:	48 89 c6             	mov    rsi,rax
  2183d8:	48 c1 e6 04          	shl    rsi,0x4
  2183dc:	48 01 de             	add    rsi,rbx
  2183df:	49 89 d0             	mov    r8,rdx
  2183e2:	4d 29 e8             	sub    r8,r13
  2183e5:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  2183ea:	48 89 c2             	mov    rdx,rax
  2183ed:	c5 f8 77             	vzeroupper 
  2183f0:	e8 8b 63 00 00       	call   21e780 <findLastForward>
  2183f5:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
                        const range = Range.init(pull[pull_index].from, index - 1);
  2183fa:	4c 8d 48 ff          	lea    r9,[rax-0x1]
                        mem.rotate(T, items[range.start..range.end], count);
  2183fe:	4d 89 e0             	mov    r8,r12
  218401:	49 c1 e0 04          	shl    r8,0x4
  218405:	4d 89 ca             	mov    r10,r9
  218408:	4d 29 e2             	sub    r10,r12
  21840b:	49 83 fd 02          	cmp    r13,0x2
  21840f:	0f 82 45 01 00 00    	jb     21855a <Benchmark_reportStats+0x295a>
                        index = findLastForward(T, items, items[index], Range.init(index, pull[pull_index].to), lessThan, length - count);
  218415:	4c 89 ee             	mov    rsi,r13
  218418:	48 d1 ee             	shr    rsi,1
  21841b:	89 f7                	mov    edi,esi
  21841d:	83 e7 03             	and    edi,0x3
  218420:	4c 8b 5c 24 38       	mov    r11,QWORD PTR [rsp+0x38]
  218425:	49 d1 eb             	shr    r11,1
  218428:	49 8d 4b ff          	lea    rcx,[r11-0x1]
        swap(T, &items[i], &items[items.len - i - 1]);
  21842c:	48 83 f9 03          	cmp    rcx,0x3
  218430:	73 1e                	jae    218450 <Benchmark_reportStats+0x2850>
  218432:	4c 89 f0             	mov    rax,r14
  218435:	31 c9                	xor    ecx,ecx
    while (i < end) : (i += 1) {
  218437:	41 f6 c3 03          	test   r11b,0x3
  21843b:	49 89 c6             	mov    r14,rax
  21843e:	0f 85 c6 00 00 00    	jne    21850a <Benchmark_reportStats+0x290a>
  218444:	e9 11 01 00 00       	jmp    21855a <Benchmark_reportStats+0x295a>
  218449:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  218450:	48 29 fe             	sub    rsi,rdi
        swap(T, &items[i], &items[items.len - i - 1]);
  218453:	4a 8d 14 03          	lea    rdx,[rbx+r8*1]
  218457:	48 83 c2 30          	add    rdx,0x30
  21845b:	4c 89 f0             	mov    rax,r14
  21845e:	4f 8d 34 34          	lea    r14,[r12+r14*1]
  218462:	49 c1 e6 04          	shl    r14,0x4
  218466:	49 01 de             	add    r14,rbx
  218469:	31 c9                	xor    ecx,ecx
  21846b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
    const tmp = a.*;
  218470:	c5 f8 10 42 d0       	vmovups xmm0,XMMWORD PTR [rdx-0x30]
  218475:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21847a:	c4 c1 78 10 46 10    	vmovups xmm0,XMMWORD PTR [r14+0x10]
  218480:	c5 f8 11 42 d0       	vmovups XMMWORD PTR [rdx-0x30],xmm0
    b.* = tmp;
  218485:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  21848a:	c4 c1 78 11 46 10    	vmovups XMMWORD PTR [r14+0x10],xmm0
    const tmp = a.*;
  218490:	c5 f8 10 42 e0       	vmovups xmm0,XMMWORD PTR [rdx-0x20]
  218495:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21849a:	c4 c1 78 10 06       	vmovups xmm0,XMMWORD PTR [r14]
  21849f:	c5 f8 11 42 e0       	vmovups XMMWORD PTR [rdx-0x20],xmm0
    b.* = tmp;
  2184a4:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  2184a9:	c4 c1 78 11 06       	vmovups XMMWORD PTR [r14],xmm0
    const tmp = a.*;
  2184ae:	c5 f8 10 42 f0       	vmovups xmm0,XMMWORD PTR [rdx-0x10]
  2184b3:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  2184b8:	c4 c1 78 10 46 f0    	vmovups xmm0,XMMWORD PTR [r14-0x10]
  2184be:	c5 f8 11 42 f0       	vmovups XMMWORD PTR [rdx-0x10],xmm0
    b.* = tmp;
  2184c3:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  2184c8:	c4 c1 78 11 46 f0    	vmovups XMMWORD PTR [r14-0x10],xmm0
    const tmp = a.*;
  2184ce:	c5 f8 10 02          	vmovups xmm0,XMMWORD PTR [rdx]
  2184d2:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  2184d7:	c4 c1 78 10 46 e0    	vmovups xmm0,XMMWORD PTR [r14-0x20]
  2184dd:	c5 f8 11 02          	vmovups XMMWORD PTR [rdx],xmm0
    b.* = tmp;
  2184e1:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  2184e6:	c4 c1 7a 7f 46 e0    	vmovdqu XMMWORD PTR [r14-0x20],xmm0
    while (i < end) : (i += 1) {
  2184ec:	48 83 c1 04          	add    rcx,0x4
  2184f0:	48 83 c2 40          	add    rdx,0x40
  2184f4:	49 83 c6 c0          	add    r14,0xffffffffffffffc0
  2184f8:	48 39 ce             	cmp    rsi,rcx
  2184fb:	0f 85 6f ff ff ff    	jne    218470 <Benchmark_reportStats+0x2870>
  218501:	41 f6 c3 03          	test   r11b,0x3
  218505:	49 89 c6             	mov    r14,rax
  218508:	74 50                	je     21855a <Benchmark_reportStats+0x295a>
  21850a:	48 f7 df             	neg    rdi
  21850d:	4d 01 e7             	add    r15,r12
  218510:	49 29 cf             	sub    r15,rcx
  218513:	49 c1 e7 04          	shl    r15,0x4
  218517:	49 01 df             	add    r15,rbx
  21851a:	4c 01 e1             	add    rcx,r12
  21851d:	48 c1 e1 04          	shl    rcx,0x4
  218521:	48 01 d9             	add    rcx,rbx
  218524:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21852b:	00 00 00 00 00 
    const tmp = a.*;
  218530:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  218534:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  218539:	c4 c1 78 10 07       	vmovups xmm0,XMMWORD PTR [r15]
  21853e:	c5 f8 11 01          	vmovups XMMWORD PTR [rcx],xmm0
    b.* = tmp;
  218542:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  218547:	c4 c1 7a 7f 07       	vmovdqu XMMWORD PTR [r15],xmm0
    while (i < end) : (i += 1) {
  21854c:	49 83 c7 f0          	add    r15,0xfffffffffffffff0
  218550:	48 83 c1 10          	add    rcx,0x10
  218554:	48 83 c7 01          	add    rdi,0x1
  218558:	75 d6                	jne    218530 <Benchmark_reportStats+0x2930>

/// In-place rotation of the values in an array ([0 1 2 3] becomes [1 2 3 0] if we rotate by 1)
/// Assumes 0 <= amount <= items.len
pub fn rotate(comptime T: type, items: []T, amount: usize) void {
    reverse(T, items[0..amount]);
    reverse(T, items[amount..]);
  21855a:	4d 89 d3             	mov    r11,r10
  21855d:	4d 29 eb             	sub    r11,r13
    const end = items.len / 2;
  218560:	49 d1 eb             	shr    r11,1
  218563:	48 8b 44 24 30       	mov    rax,QWORD PTR [rsp+0x30]
  218568:	4c 8b 7c 24 28       	mov    r15,QWORD PTR [rsp+0x28]
    while (i < end) : (i += 1) {
  21856d:	0f 84 55 01 00 00    	je     2186c8 <Benchmark_reportStats+0x2ac8>
        swap(T, &items[i], &items[items.len - i - 1]);
  218573:	49 8d 4b ff          	lea    rcx,[r11-0x1]
  218577:	48 83 f9 03          	cmp    rcx,0x3
  21857b:	73 13                	jae    218590 <Benchmark_reportStats+0x2990>
  21857d:	31 ff                	xor    edi,edi
    while (i < end) : (i += 1) {
  21857f:	41 f6 c3 03          	test   r11b,0x3
  218583:	0f 85 d6 00 00 00    	jne    21865f <Benchmark_reportStats+0x2a5f>
  218589:	e9 3a 01 00 00       	jmp    2186c8 <Benchmark_reportStats+0x2ac8>
  21858e:	66 90                	xchg   ax,ax
  218590:	48 8b 74 24 18       	mov    rsi,QWORD PTR [rsp+0x18]
        swap(T, &items[i], &items[items.len - i - 1]);
  218595:	48 8d 14 06          	lea    rdx,[rsi+rax*1]
  218599:	4c 29 e2             	sub    rdx,r12
  21859c:	48 d1 ea             	shr    rdx,1
  21859f:	89 d1                	mov    ecx,edx
  2185a1:	83 e1 03             	and    ecx,0x3
  2185a4:	48 29 ca             	sub    rdx,rcx
  2185a7:	48 89 f1             	mov    rcx,rsi
  2185aa:	48 c1 e1 04          	shl    rcx,0x4
  2185ae:	48 8d 34 0b          	lea    rsi,[rbx+rcx*1]
  2185b2:	48 83 c6 b0          	add    rsi,0xffffffffffffffb0
  2185b6:	4b 8d 0c 3c          	lea    rcx,[r12+r15*1]
  2185ba:	48 c1 e1 04          	shl    rcx,0x4
  2185be:	48 01 d9             	add    rcx,rbx
  2185c1:	31 ff                	xor    edi,edi
  2185c3:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  2185ca:	84 00 00 00 00 00 
    const tmp = a.*;
  2185d0:	c5 f8 10 41 f0       	vmovups xmm0,XMMWORD PTR [rcx-0x10]
  2185d5:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  2185da:	c5 f8 10 46 30       	vmovups xmm0,XMMWORD PTR [rsi+0x30]
  2185df:	c5 f8 11 41 f0       	vmovups XMMWORD PTR [rcx-0x10],xmm0
    b.* = tmp;
  2185e4:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  2185e9:	c5 f8 11 46 30       	vmovups XMMWORD PTR [rsi+0x30],xmm0
    const tmp = a.*;
  2185ee:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  2185f2:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  2185f7:	c5 f8 10 46 20       	vmovups xmm0,XMMWORD PTR [rsi+0x20]
  2185fc:	c5 f8 11 01          	vmovups XMMWORD PTR [rcx],xmm0
    b.* = tmp;
  218600:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  218605:	c5 f8 11 46 20       	vmovups XMMWORD PTR [rsi+0x20],xmm0
    const tmp = a.*;
  21860a:	c5 f8 10 41 10       	vmovups xmm0,XMMWORD PTR [rcx+0x10]
  21860f:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  218614:	c5 f8 10 46 10       	vmovups xmm0,XMMWORD PTR [rsi+0x10]
  218619:	c5 f8 11 41 10       	vmovups XMMWORD PTR [rcx+0x10],xmm0
    b.* = tmp;
  21861e:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  218623:	c5 f8 11 46 10       	vmovups XMMWORD PTR [rsi+0x10],xmm0
    const tmp = a.*;
  218628:	c5 f8 10 41 20       	vmovups xmm0,XMMWORD PTR [rcx+0x20]
  21862d:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  218632:	c5 f8 10 06          	vmovups xmm0,XMMWORD PTR [rsi]
  218636:	c5 f8 11 41 20       	vmovups XMMWORD PTR [rcx+0x20],xmm0
    b.* = tmp;
  21863b:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  218640:	c5 fa 7f 06          	vmovdqu XMMWORD PTR [rsi],xmm0
    while (i < end) : (i += 1) {
  218644:	48 83 c7 04          	add    rdi,0x4
  218648:	48 83 c6 c0          	add    rsi,0xffffffffffffffc0
  21864c:	48 83 c1 40          	add    rcx,0x40
  218650:	48 39 fa             	cmp    rdx,rdi
  218653:	0f 85 77 ff ff ff    	jne    2185d0 <Benchmark_reportStats+0x29d0>
  218659:	41 f6 c3 03          	test   r11b,0x3
  21865d:	74 69                	je     2186c8 <Benchmark_reportStats+0x2ac8>
  21865f:	48 8b 54 24 18       	mov    rdx,QWORD PTR [rsp+0x18]
  218664:	48 8d 4a fe          	lea    rcx,[rdx-0x2]
  218668:	48 29 f9             	sub    rcx,rdi
  21866b:	48 c1 e1 04          	shl    rcx,0x4
  21866f:	48 01 d9             	add    rcx,rbx
  218672:	4c 01 e7             	add    rdi,r12
  218675:	4c 01 ef             	add    rdi,r13
  218678:	48 c1 e7 04          	shl    rdi,0x4
  21867c:	48 01 df             	add    rdi,rbx
  21867f:	8d 14 02             	lea    edx,[rdx+rax*1]
  218682:	44 29 e2             	sub    edx,r12d
  218685:	be 01 02 00 00       	mov    esi,0x201
  21868a:	c4 e2 48 f7 d2       	bextr  edx,edx,esi
  21868f:	48 f7 da             	neg    rdx
  218692:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  218699:	1f 84 00 00 00 00 00 
    const tmp = a.*;
  2186a0:	c5 f8 10 07          	vmovups xmm0,XMMWORD PTR [rdi]
  2186a4:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  2186a9:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  2186ad:	c5 f8 11 07          	vmovups XMMWORD PTR [rdi],xmm0
    b.* = tmp;
  2186b1:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  2186b6:	c5 fa 7f 01          	vmovdqu XMMWORD PTR [rcx],xmm0
    while (i < end) : (i += 1) {
  2186ba:	48 83 c1 f0          	add    rcx,0xfffffffffffffff0
  2186be:	48 83 c7 10          	add    rdi,0x10
  2186c2:	48 83 c2 01          	add    rdx,0x1
  2186c6:	75 d8                	jne    2186a0 <Benchmark_reportStats+0x2aa0>
    const end = items.len / 2;
  2186c8:	4d 89 d3             	mov    r11,r10
  2186cb:	49 d1 eb             	shr    r11,1
    while (i < end) : (i += 1) {
  2186ce:	0f 84 5c 01 00 00    	je     218830 <Benchmark_reportStats+0x2c30>
  2186d4:	4a 8d 0c 03          	lea    rcx,[rbx+r8*1]
    const tmp = a.*;
  2186d8:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  2186dc:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  2186e1:	49 c1 e2 04          	shl    r10,0x4
    a.* = b.*;
  2186e5:	c4 a1 78 10 44 11 f0 	vmovups xmm0,XMMWORD PTR [rcx+r10*1-0x10]
  2186ec:	c5 f8 11 01          	vmovups XMMWORD PTR [rcx],xmm0
    b.* = tmp;
  2186f0:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  2186f5:	c4 a1 7a 7f 44 11 f0 	vmovdqu XMMWORD PTR [rcx+r10*1-0x10],xmm0
    while (i < end) : (i += 1) {
  2186fc:	49 83 fb 01          	cmp    r11,0x1
  218700:	0f 84 2a 01 00 00    	je     218830 <Benchmark_reportStats+0x2c30>
        swap(T, &items[i], &items[items.len - i - 1]);
  218706:	41 8d 73 ff          	lea    esi,[r11-0x1]
  21870a:	49 8d 4b fe          	lea    rcx,[r11-0x2]
  21870e:	83 e6 03             	and    esi,0x3
  218711:	48 83 f9 03          	cmp    rcx,0x3
  218715:	73 13                	jae    21872a <Benchmark_reportStats+0x2b2a>
  218717:	ba 01 00 00 00       	mov    edx,0x1
    while (i < end) : (i += 1) {
  21871c:	48 85 f6             	test   rsi,rsi
  21871f:	0f 85 b9 00 00 00    	jne    2187de <Benchmark_reportStats+0x2bde>
  218725:	e9 06 01 00 00       	jmp    218830 <Benchmark_reportStats+0x2c30>
        swap(T, &items[i], &items[items.len - i - 1]);
  21872a:	48 8b 4c 24 18       	mov    rcx,QWORD PTR [rsp+0x18]
  21872f:	48 c1 e1 04          	shl    rcx,0x4
  218733:	48 8d 3c 0b          	lea    rdi,[rbx+rcx*1]
  218737:	48 83 c7 d0          	add    rdi,0xffffffffffffffd0
  21873b:	4a 8d 0c 03          	lea    rcx,[rbx+r8*1]
  21873f:	48 83 c1 40          	add    rcx,0x40
  218743:	49 29 f3             	sub    r11,rsi
  218746:	ba 01 00 00 00       	mov    edx,0x1
  21874b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
    const tmp = a.*;
  218750:	c5 f8 10 41 d0       	vmovups xmm0,XMMWORD PTR [rcx-0x30]
  218755:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21875a:	c5 f8 10 07          	vmovups xmm0,XMMWORD PTR [rdi]
  21875e:	c5 f8 11 41 d0       	vmovups XMMWORD PTR [rcx-0x30],xmm0
    b.* = tmp;
  218763:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  218768:	c5 f8 11 07          	vmovups XMMWORD PTR [rdi],xmm0
    const tmp = a.*;
  21876c:	c5 f8 10 41 e0       	vmovups xmm0,XMMWORD PTR [rcx-0x20]
  218771:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  218776:	c5 f8 10 47 f0       	vmovups xmm0,XMMWORD PTR [rdi-0x10]
  21877b:	c5 f8 11 41 e0       	vmovups XMMWORD PTR [rcx-0x20],xmm0
    b.* = tmp;
  218780:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  218785:	c5 f8 11 47 f0       	vmovups XMMWORD PTR [rdi-0x10],xmm0
    const tmp = a.*;
  21878a:	c5 f8 10 41 f0       	vmovups xmm0,XMMWORD PTR [rcx-0x10]
  21878f:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  218794:	c5 f8 10 47 e0       	vmovups xmm0,XMMWORD PTR [rdi-0x20]
  218799:	c5 f8 11 41 f0       	vmovups XMMWORD PTR [rcx-0x10],xmm0
    b.* = tmp;
  21879e:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  2187a3:	c5 f8 11 47 e0       	vmovups XMMWORD PTR [rdi-0x20],xmm0
    const tmp = a.*;
  2187a8:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  2187ac:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  2187b1:	c5 f8 10 47 d0       	vmovups xmm0,XMMWORD PTR [rdi-0x30]
  2187b6:	c5 f8 11 01          	vmovups XMMWORD PTR [rcx],xmm0
    b.* = tmp;
  2187ba:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  2187bf:	c5 fa 7f 47 d0       	vmovdqu XMMWORD PTR [rdi-0x30],xmm0
    while (i < end) : (i += 1) {
  2187c4:	48 83 c2 04          	add    rdx,0x4
  2187c8:	48 83 c7 c0          	add    rdi,0xffffffffffffffc0
  2187cc:	48 83 c1 40          	add    rcx,0x40
  2187d0:	49 39 d3             	cmp    r11,rdx
  2187d3:	0f 85 77 ff ff ff    	jne    218750 <Benchmark_reportStats+0x2b50>
  2187d9:	48 85 f6             	test   rsi,rsi
  2187dc:	74 52                	je     218830 <Benchmark_reportStats+0x2c30>
  2187de:	48 8b 4c 24 18       	mov    rcx,QWORD PTR [rsp+0x18]
  2187e3:	48 29 d1             	sub    rcx,rdx
  2187e6:	48 c1 e1 04          	shl    rcx,0x4
  2187ea:	48 01 d9             	add    rcx,rbx
  2187ed:	48 83 c1 e0          	add    rcx,0xffffffffffffffe0
  2187f1:	49 01 d4             	add    r12,rdx
  2187f4:	49 c1 e4 04          	shl    r12,0x4
  2187f8:	49 01 dc             	add    r12,rbx
  2187fb:	48 f7 de             	neg    rsi
  2187fe:	66 90                	xchg   ax,ax
    const tmp = a.*;
  218800:	c4 c1 78 10 04 24    	vmovups xmm0,XMMWORD PTR [r12]
  218806:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21880b:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  21880f:	c4 c1 78 11 04 24    	vmovups XMMWORD PTR [r12],xmm0
    b.* = tmp;
  218815:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  21881a:	c5 fa 7f 01          	vmovdqu XMMWORD PTR [rcx],xmm0
    while (i < end) : (i += 1) {
  21881e:	48 83 c1 f0          	add    rcx,0xfffffffffffffff0
  218822:	49 83 c4 10          	add    r12,0x10
  218826:	48 83 c6 01          	add    rsi,0x1
  21882a:	75 d4                	jne    218800 <Benchmark_reportStats+0x2c00>
  21882c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
                        pull[pull_index].from = index - 1 - count;
  218830:	4d 29 e9             	sub    r9,r13
  218833:	48 8b 4c 24 20       	mov    rcx,QWORD PTR [rsp+0x20]
  218838:	4c 89 09             	mov    QWORD PTR [rcx],r9
                    while (count < length) : (count += 1) {
  21883b:	49 83 c5 01          	add    r13,0x1
  21883f:	48 8b 54 24 10       	mov    rdx,QWORD PTR [rsp+0x10]
  218844:	49 39 d5             	cmp    r13,rdx
  218847:	0f 85 53 fb ff ff    	jne    2183a0 <Benchmark_reportStats+0x27a0>
  21884d:	48 8b 44 24 58       	mov    rax,QWORD PTR [rsp+0x58]
            while (pull_index < 2) : (pull_index += 1) {
  218852:	48 83 c0 01          	add    rax,0x1
  218856:	48 83 f8 02          	cmp    rax,0x2
  21885a:	0f 85 90 f4 ff ff    	jne    217cf0 <Benchmark_reportStats+0x20f0>
  218860:	48 8b 8c 24 d0 00 00 	mov    rcx,QWORD PTR [rsp+0xd0]
  218867:	00 
        return self.end - self.start;
  218868:	48 2b 4c 24 70       	sub    rcx,QWORD PTR [rsp+0x70]
  21886d:	48 8b b4 24 d8 00 00 	mov    rsi,QWORD PTR [rsp+0xd8]
  218874:	00 
  218875:	48 89 f0             	mov    rax,rsi
  218878:	48 09 c8             	or     rax,rcx
  21887b:	48 c1 e8 20          	shr    rax,0x20
  21887f:	74 0a                	je     21888b <Benchmark_reportStats+0x2c8b>
  218881:	31 d2                	xor    edx,edx
  218883:	48 89 f0             	mov    rax,rsi
  218886:	48 f7 f1             	div    rcx
  218889:	eb 06                	jmp    218891 <Benchmark_reportStats+0x2c91>
  21888b:	31 d2                	xor    edx,edx
  21888d:	89 f0                	mov    eax,esi
  21888f:	f7 f1                	div    ecx
  218891:	48 8b 94 24 e0 00 00 	mov    rdx,QWORD PTR [rsp+0xe0]
  218898:	00 
  218899:	48 89 44 24 58       	mov    QWORD PTR [rsp+0x58],rax
            block_size = iterator.length() / buffer_size + 1;
  21889e:	48 8d 58 01          	lea    rbx,[rax+0x1]
  2188a2:	48 8b 44 24 50       	mov    rax,QWORD PTR [rsp+0x50]
  2188a7:	48 89 c7             	mov    rdi,rax
  2188aa:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
  2188af:	49 89 c0             	mov    r8,rax
  2188b2:	4c 29 c7             	sub    rdi,r8
  2188b5:	48 89 bc 24 c0 01 00 	mov    QWORD PTR [rsp+0x1c0],rdi
  2188bc:	00 
  2188bd:	0f 95 c0             	setne  al
  2188c0:	48 81 fb 01 02 00 00 	cmp    rbx,0x201
  2188c7:	0f 92 c1             	setb   cl
  2188ca:	08 c1                	or     cl,al
  2188cc:	88 4c 24 78          	mov    BYTE PTR [rsp+0x78],cl
        mem.swap(T, &items[start1 + index], &items[start2 + index]);
  2188d0:	48 8d 46 ff          	lea    rax,[rsi-0x1]
            while (!iterator.finished()) {
  2188d4:	48 89 84 24 98 01 00 	mov    QWORD PTR [rsp+0x198],rax
  2188db:	00 
  2188dc:	48 89 d8             	mov    rax,rbx
  2188df:	48 d1 e8             	shr    rax,1
  2188e2:	89 d9                	mov    ecx,ebx
  2188e4:	83 e1 03             	and    ecx,0x3
  2188e7:	48 89 df             	mov    rdi,rbx
  2188ea:	48 89 4c 24 10       	mov    QWORD PTR [rsp+0x10],rcx
  2188ef:	48 29 cf             	sub    rdi,rcx
  2188f2:	48 89 bc 24 10 01 00 	mov    QWORD PTR [rsp+0x110],rdi
  2188f9:	00 
  2188fa:	89 d9                	mov    ecx,ebx
  2188fc:	83 e1 07             	and    ecx,0x7
  2188ff:	48 89 5c 24 28       	mov    QWORD PTR [rsp+0x28],rbx
  218904:	48 89 8c 24 20 01 00 	mov    QWORD PTR [rsp+0x120],rcx
  21890b:	00 
  21890c:	48 29 cb             	sub    rbx,rcx
  21890f:	48 89 9c 24 60 01 00 	mov    QWORD PTR [rsp+0x160],rbx
  218916:	00 
  218917:	89 c1                	mov    ecx,eax
  218919:	83 e1 03             	and    ecx,0x3
  21891c:	48 8d 78 ff          	lea    rdi,[rax-0x1]
  218920:	48 89 bc 24 70 01 00 	mov    QWORD PTR [rsp+0x170],rdi
  218927:	00 
  218928:	48 89 8c 24 40 01 00 	mov    QWORD PTR [rsp+0x140],rcx
  21892f:	00 
  218930:	48 29 c8             	sub    rax,rcx
  218933:	48 89 84 24 68 01 00 	mov    QWORD PTR [rsp+0x168],rax
  21893a:	00 
  21893b:	48 8b 44 24 70       	mov    rax,QWORD PTR [rsp+0x70]
  218940:	48 c1 e0 04          	shl    rax,0x4
  218944:	48 89 84 24 d8 01 00 	mov    QWORD PTR [rsp+0x1d8],rax
  21894b:	00 
  21894c:	48 8d 40 10          	lea    rax,[rax+0x10]
  218950:	48 89 84 24 c8 01 00 	mov    QWORD PTR [rsp+0x1c8],rax
  218957:	00 
  218958:	49 c1 e0 04          	shl    r8,0x4
  21895c:	4c 89 84 24 18 01 00 	mov    QWORD PTR [rsp+0x118],r8
  218963:	00 
  218964:	49 8d 40 20          	lea    rax,[r8+0x20]
  218968:	48 89 84 24 58 01 00 	mov    QWORD PTR [rsp+0x158],rax
  21896f:	00 
  218970:	31 c0                	xor    eax,eax
  218972:	31 db                	xor    ebx,ebx
  218974:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21897b:	00 00 00 00 00 
  218980:	49 89 c7             	mov    r15,rax
        self.decimal += self.decimal_step;
  218983:	4d 8d 2c 37          	lea    r13,[r15+rsi*1]
        self.numerator += self.numerator_step;
  218987:	48 01 d3             	add    rbx,rdx
        if (self.numerator >= self.denominator) {
  21898a:	45 31 c9             	xor    r9d,r9d
  21898d:	48 8b 8c 24 00 01 00 	mov    rcx,QWORD PTR [rsp+0x100]
  218994:	00 
  218995:	48 39 cb             	cmp    rbx,rcx
  218998:	41 0f 93 c1          	setae  r9b
  21899c:	48 89 c8             	mov    rax,rcx
  21899f:	bf 00 00 00 00       	mov    edi,0x0
  2189a4:	48 0f 42 c7          	cmovb  rax,rdi
  2189a8:	48 29 c3             	sub    rbx,rax
  2189ab:	4f 8d 04 29          	lea    r8,[r9+r13*1]
        self.decimal += self.decimal_step;
  2189af:	49 8d 04 30          	lea    rax,[r8+rsi*1]
        self.numerator += self.numerator_step;
  2189b3:	48 01 d3             	add    rbx,rdx
        if (self.numerator >= self.denominator) {
  2189b6:	31 d2                	xor    edx,edx
  2189b8:	48 89 9c 24 38 01 00 	mov    QWORD PTR [rsp+0x138],rbx
  2189bf:	00 
  2189c0:	48 39 cb             	cmp    rbx,rcx
  2189c3:	48 0f 42 cf          	cmovb  rcx,rdi
  2189c7:	48 89 8c 24 30 01 00 	mov    QWORD PTR [rsp+0x130],rcx
  2189ce:	00 
  2189cf:	0f 93 c2             	setae  dl
  2189d2:	48 01 c2             	add    rdx,rax
  2189d5:	4d 89 fc             	mov    r12,r15
  2189d8:	48 89 94 24 08 01 00 	mov    QWORD PTR [rsp+0x108],rdx
  2189df:	00 
                if (start == pull[0].range.start) {
  2189e0:	4c 3b bc 24 98 00 00 	cmp    r15,QWORD PTR [rsp+0x98]
  2189e7:	00 
  2189e8:	75 66                	jne    218a50 <Benchmark_reportStats+0x2e50>
                    if (pull[0].from > pull[0].to) {
  2189ea:	48 8b 84 24 88 00 00 	mov    rax,QWORD PTR [rsp+0x88]
  2189f1:	00 
  2189f2:	48 39 84 24 80 00 00 	cmp    QWORD PTR [rsp+0x80],rax
  2189f9:	00 
  2189fa:	76 24                	jbe    218a20 <Benchmark_reportStats+0x2e20>
  2189fc:	4c 8b a4 24 90 00 00 	mov    r12,QWORD PTR [rsp+0x90]
  218a03:	00 
                        A.start += pull[0].count;
  218a04:	4d 01 fc             	add    r12,r15
  218a07:	48 8b 94 24 08 01 00 	mov    rdx,QWORD PTR [rsp+0x108]
  218a0e:	00 
                        if (A.length() == 0) continue;
  218a0f:	4d 39 e0             	cmp    r8,r12
  218a12:	75 3c                	jne    218a50 <Benchmark_reportStats+0x2e50>
  218a14:	e9 97 25 00 00       	jmp    21afb0 <Benchmark_reportStats+0x53b0>
  218a19:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  218a20:	4d 89 fc             	mov    r12,r15
  218a23:	48 8b 94 24 08 01 00 	mov    rdx,QWORD PTR [rsp+0x108]
  218a2a:	00 
                    } else if (pull[0].from < pull[0].to) {
  218a2b:	73 23                	jae    218a50 <Benchmark_reportStats+0x2e50>
                        B.end -= pull[0].count;
  218a2d:	48 8b 94 24 08 01 00 	mov    rdx,QWORD PTR [rsp+0x108]
  218a34:	00 
  218a35:	48 2b 94 24 90 00 00 	sub    rdx,QWORD PTR [rsp+0x90]
  218a3c:	00 
  218a3d:	4d 89 fc             	mov    r12,r15
                        if (B.length() == 0) continue;
  218a40:	4c 39 c2             	cmp    rdx,r8
  218a43:	0f 84 67 25 00 00    	je     21afb0 <Benchmark_reportStats+0x53b0>
  218a49:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
                if (start == pull[1].range.start) {
  218a50:	4c 3b bc 24 c0 00 00 	cmp    r15,QWORD PTR [rsp+0xc0]
  218a57:	00 
  218a58:	75 46                	jne    218aa0 <Benchmark_reportStats+0x2ea0>
                    if (pull[1].from > pull[1].to) {
  218a5a:	48 8b 84 24 b0 00 00 	mov    rax,QWORD PTR [rsp+0xb0]
  218a61:	00 
  218a62:	48 39 84 24 a8 00 00 	cmp    QWORD PTR [rsp+0xa8],rax
  218a69:	00 
  218a6a:	76 14                	jbe    218a80 <Benchmark_reportStats+0x2e80>
                        A.start += pull[1].count;
  218a6c:	4c 03 a4 24 b8 00 00 	add    r12,QWORD PTR [rsp+0xb8]
  218a73:	00 
                        if (A.length() == 0) continue;
  218a74:	4d 39 e0             	cmp    r8,r12
  218a77:	75 27                	jne    218aa0 <Benchmark_reportStats+0x2ea0>
  218a79:	e9 32 25 00 00       	jmp    21afb0 <Benchmark_reportStats+0x53b0>
  218a7e:	66 90                	xchg   ax,ax
                    } else if (pull[1].from < pull[1].to) {
  218a80:	73 1e                	jae    218aa0 <Benchmark_reportStats+0x2ea0>
                        B.end -= pull[1].count;
  218a82:	48 2b 94 24 b8 00 00 	sub    rdx,QWORD PTR [rsp+0xb8]
  218a89:	00 
                        if (B.length() == 0) continue;
  218a8a:	4c 39 c2             	cmp    rdx,r8
  218a8d:	0f 84 1d 25 00 00    	je     21afb0 <Benchmark_reportStats+0x53b0>
  218a93:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  218a9a:	84 00 00 00 00 00 
  218aa0:	4c 89 44 24 30       	mov    QWORD PTR [rsp+0x30],r8
                if (lessThan(items[B.end - 1], items[A.start])) {
  218aa5:	49 89 d3             	mov    r11,rdx
  218aa8:	49 c1 e3 04          	shl    r11,0x4
  218aac:	4c 8b 54 24 40       	mov    r10,QWORD PTR [rsp+0x40]
  218ab1:	4d 89 e0             	mov    r8,r12
  218ab4:	49 c1 e0 04          	shl    r8,0x4
  218ab8:	4b 8b 44 1a f0       	mov    rax,QWORD PTR [r10+r11*1-0x10]
  218abd:	4b 3b 04 02          	cmp    rax,QWORD PTR [r10+r8*1]
  218ac1:	73 4d                	jae    218b10 <Benchmark_reportStats+0x2f10>
  218ac3:	48 89 94 24 e8 00 00 	mov    QWORD PTR [rsp+0xe8],rdx
  218aca:	00 
                    mem.rotate(T, items[A.start..B.end], A.length());
  218acb:	48 89 d7             	mov    rdi,rdx
  218ace:	4c 29 e7             	sub    rdi,r12
        return self.end - self.start;
  218ad1:	4c 8b 74 24 30       	mov    r14,QWORD PTR [rsp+0x30]
  218ad6:	4d 29 e6             	sub    r14,r12
    const end = items.len / 2;
  218ad9:	4c 89 f3             	mov    rbx,r14
  218adc:	48 d1 eb             	shr    rbx,1
    while (i < end) : (i += 1) {
  218adf:	0f 84 73 01 00 00    	je     218c58 <Benchmark_reportStats+0x3058>
        swap(T, &items[i], &items[items.len - i - 1]);
  218ae5:	48 8d 43 ff          	lea    rax,[rbx-0x1]
  218ae9:	89 da                	mov    edx,ebx
  218aeb:	83 e2 03             	and    edx,0x3
  218aee:	48 83 f8 03          	cmp    rax,0x3
  218af2:	73 67                	jae    218b5b <Benchmark_reportStats+0x2f5b>
  218af4:	31 c0                	xor    eax,eax
    while (i < end) : (i += 1) {
  218af6:	48 85 d2             	test   rdx,rdx
  218af9:	0f 85 0f 01 00 00    	jne    218c0e <Benchmark_reportStats+0x300e>
  218aff:	e9 54 01 00 00       	jmp    218c58 <Benchmark_reportStats+0x3058>
  218b04:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  218b0b:	00 00 00 00 00 
  218b10:	4c 8b 6c 24 30       	mov    r13,QWORD PTR [rsp+0x30]
                } else if (lessThan(items[A.end], items[A.end - 1])) {
  218b15:	4c 89 e8             	mov    rax,r13
  218b18:	48 c1 e0 04          	shl    rax,0x4
  218b1c:	49 8b 0c 02          	mov    rcx,QWORD PTR [r10+rax*1]
  218b20:	49 3b 4c 02 f0       	cmp    rcx,QWORD PTR [r10+rax*1-0x10]
  218b25:	0f 83 85 24 00 00    	jae    21afb0 <Benchmark_reportStats+0x53b0>
  218b2b:	48 89 94 24 e8 00 00 	mov    QWORD PTR [rsp+0xe8],rdx
  218b32:	00 
        return self.end - self.start;
  218b33:	4d 29 e5             	sub    r13,r12
  218b36:	4d 89 eb             	mov    r11,r13
  218b39:	4c 8b 74 24 28       	mov    r14,QWORD PTR [rsp+0x28]
  218b3e:	4d 09 f3             	or     r11,r14
  218b41:	49 c1 eb 20          	shr    r11,0x20
  218b45:	0f 84 b0 02 00 00    	je     218dfb <Benchmark_reportStats+0x31fb>
  218b4b:	31 d2                	xor    edx,edx
  218b4d:	4c 89 e8             	mov    rax,r13
  218b50:	49 f7 f6             	div    r14
  218b53:	48 89 d6             	mov    rsi,rdx
  218b56:	e9 aa 02 00 00       	jmp    218e05 <Benchmark_reportStats+0x3205>
        swap(T, &items[i], &items[items.len - i - 1]);
  218b5b:	48 29 d3             	sub    rbx,rdx
  218b5e:	4b 8d 0c 02          	lea    rcx,[r10+r8*1]
  218b62:	48 83 c1 30          	add    rcx,0x30
  218b66:	48 8b 44 24 30       	mov    rax,QWORD PTR [rsp+0x30]
  218b6b:	48 c1 e0 04          	shl    rax,0x4
  218b6f:	49 8d 34 02          	lea    rsi,[r10+rax*1]
  218b73:	48 83 c6 f0          	add    rsi,0xfffffffffffffff0
  218b77:	31 c0                	xor    eax,eax
  218b79:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
    const tmp = a.*;
  218b80:	c5 f8 10 41 d0       	vmovups xmm0,XMMWORD PTR [rcx-0x30]
  218b85:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  218b8a:	c5 f8 10 06          	vmovups xmm0,XMMWORD PTR [rsi]
  218b8e:	c5 f8 11 41 d0       	vmovups XMMWORD PTR [rcx-0x30],xmm0
    b.* = tmp;
  218b93:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  218b98:	c5 f8 11 06          	vmovups XMMWORD PTR [rsi],xmm0
    const tmp = a.*;
  218b9c:	c5 f8 10 41 e0       	vmovups xmm0,XMMWORD PTR [rcx-0x20]
  218ba1:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  218ba6:	c5 f8 10 46 f0       	vmovups xmm0,XMMWORD PTR [rsi-0x10]
  218bab:	c5 f8 11 41 e0       	vmovups XMMWORD PTR [rcx-0x20],xmm0
    b.* = tmp;
  218bb0:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  218bb5:	c5 f8 11 46 f0       	vmovups XMMWORD PTR [rsi-0x10],xmm0
    const tmp = a.*;
  218bba:	c5 f8 10 41 f0       	vmovups xmm0,XMMWORD PTR [rcx-0x10]
  218bbf:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  218bc4:	c5 f8 10 46 e0       	vmovups xmm0,XMMWORD PTR [rsi-0x20]
  218bc9:	c5 f8 11 41 f0       	vmovups XMMWORD PTR [rcx-0x10],xmm0
    b.* = tmp;
  218bce:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  218bd3:	c5 f8 11 46 e0       	vmovups XMMWORD PTR [rsi-0x20],xmm0
    const tmp = a.*;
  218bd8:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  218bdc:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  218be1:	c5 f8 10 46 d0       	vmovups xmm0,XMMWORD PTR [rsi-0x30]
  218be6:	c5 f8 11 01          	vmovups XMMWORD PTR [rcx],xmm0
    b.* = tmp;
  218bea:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  218bef:	c5 fa 7f 46 d0       	vmovdqu XMMWORD PTR [rsi-0x30],xmm0
    while (i < end) : (i += 1) {
  218bf4:	48 83 c0 04          	add    rax,0x4
  218bf8:	48 83 c1 40          	add    rcx,0x40
  218bfc:	48 83 c6 c0          	add    rsi,0xffffffffffffffc0
  218c00:	48 39 c3             	cmp    rbx,rax
  218c03:	0f 85 77 ff ff ff    	jne    218b80 <Benchmark_reportStats+0x2f80>
  218c09:	48 85 d2             	test   rdx,rdx
  218c0c:	74 4a                	je     218c58 <Benchmark_reportStats+0x3058>
  218c0e:	4d 01 cd             	add    r13,r9
  218c11:	49 29 c5             	sub    r13,rax
  218c14:	49 c1 e5 04          	shl    r13,0x4
  218c18:	4b 8d 0c 2a          	lea    rcx,[r10+r13*1]
  218c1c:	48 83 c1 f0          	add    rcx,0xfffffffffffffff0
  218c20:	4c 01 e0             	add    rax,r12
  218c23:	48 c1 e0 04          	shl    rax,0x4
  218c27:	4c 01 d0             	add    rax,r10
  218c2a:	48 f7 da             	neg    rdx
  218c2d:	0f 1f 00             	nop    DWORD PTR [rax]
    const tmp = a.*;
  218c30:	c5 f8 10 00          	vmovups xmm0,XMMWORD PTR [rax]
  218c34:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  218c39:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  218c3d:	c5 f8 11 00          	vmovups XMMWORD PTR [rax],xmm0
    b.* = tmp;
  218c41:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  218c46:	c5 fa 7f 01          	vmovdqu XMMWORD PTR [rcx],xmm0
    while (i < end) : (i += 1) {
  218c4a:	48 83 c1 f0          	add    rcx,0xfffffffffffffff0
  218c4e:	48 83 c0 10          	add    rax,0x10
  218c52:	48 83 c2 01          	add    rdx,0x1
  218c56:	75 d8                	jne    218c30 <Benchmark_reportStats+0x3030>
    reverse(T, items[amount..]);
  218c58:	48 89 f8             	mov    rax,rdi
  218c5b:	4c 29 f0             	sub    rax,r14
    const end = items.len / 2;
  218c5e:	48 d1 e8             	shr    rax,1
  218c61:	4c 8b b4 24 e8 00 00 	mov    r14,QWORD PTR [rsp+0xe8]
  218c68:	00 
    while (i < end) : (i += 1) {
  218c69:	0f 84 29 01 00 00    	je     218d98 <Benchmark_reportStats+0x3198>
        swap(T, &items[i], &items[items.len - i - 1]);
  218c6f:	48 8d 48 ff          	lea    rcx,[rax-0x1]
  218c73:	89 c6                	mov    esi,eax
  218c75:	83 e6 03             	and    esi,0x3
  218c78:	48 83 f9 03          	cmp    rcx,0x3
  218c7c:	73 10                	jae    218c8e <Benchmark_reportStats+0x308e>
  218c7e:	31 d2                	xor    edx,edx
    while (i < end) : (i += 1) {
  218c80:	48 85 f6             	test   rsi,rsi
  218c83:	0f 85 b5 00 00 00    	jne    218d3e <Benchmark_reportStats+0x313e>
  218c89:	e9 0a 01 00 00       	jmp    218d98 <Benchmark_reportStats+0x3198>
        swap(T, &items[i], &items[items.len - i - 1]);
  218c8e:	48 29 f0             	sub    rax,rsi
  218c91:	48 8b 4c 24 30       	mov    rcx,QWORD PTR [rsp+0x30]
  218c96:	48 c1 e1 04          	shl    rcx,0x4
  218c9a:	4c 01 d1             	add    rcx,r10
  218c9d:	48 83 c1 30          	add    rcx,0x30
  218ca1:	4b 8d 1c 1a          	lea    rbx,[r10+r11*1]
  218ca5:	48 83 c3 f0          	add    rbx,0xfffffffffffffff0
  218ca9:	31 d2                	xor    edx,edx
  218cab:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
    const tmp = a.*;
  218cb0:	c5 f8 10 41 d0       	vmovups xmm0,XMMWORD PTR [rcx-0x30]
  218cb5:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  218cba:	c5 f8 10 03          	vmovups xmm0,XMMWORD PTR [rbx]
  218cbe:	c5 f8 11 41 d0       	vmovups XMMWORD PTR [rcx-0x30],xmm0
    b.* = tmp;
  218cc3:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  218cc8:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
    const tmp = a.*;
  218ccc:	c5 f8 10 41 e0       	vmovups xmm0,XMMWORD PTR [rcx-0x20]
  218cd1:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  218cd6:	c5 f8 10 43 f0       	vmovups xmm0,XMMWORD PTR [rbx-0x10]
  218cdb:	c5 f8 11 41 e0       	vmovups XMMWORD PTR [rcx-0x20],xmm0
    b.* = tmp;
  218ce0:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  218ce5:	c5 f8 11 43 f0       	vmovups XMMWORD PTR [rbx-0x10],xmm0
    const tmp = a.*;
  218cea:	c5 f8 10 41 f0       	vmovups xmm0,XMMWORD PTR [rcx-0x10]
  218cef:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  218cf4:	c5 f8 10 43 e0       	vmovups xmm0,XMMWORD PTR [rbx-0x20]
  218cf9:	c5 f8 11 41 f0       	vmovups XMMWORD PTR [rcx-0x10],xmm0
    b.* = tmp;
  218cfe:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  218d03:	c5 f8 11 43 e0       	vmovups XMMWORD PTR [rbx-0x20],xmm0
    const tmp = a.*;
  218d08:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  218d0c:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  218d11:	c5 f8 10 43 d0       	vmovups xmm0,XMMWORD PTR [rbx-0x30]
  218d16:	c5 f8 11 01          	vmovups XMMWORD PTR [rcx],xmm0
    b.* = tmp;
  218d1a:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  218d1f:	c5 fa 7f 43 d0       	vmovdqu XMMWORD PTR [rbx-0x30],xmm0
    while (i < end) : (i += 1) {
  218d24:	48 83 c2 04          	add    rdx,0x4
  218d28:	48 83 c1 40          	add    rcx,0x40
  218d2c:	48 83 c3 c0          	add    rbx,0xffffffffffffffc0
  218d30:	48 39 d0             	cmp    rax,rdx
  218d33:	0f 85 77 ff ff ff    	jne    218cb0 <Benchmark_reportStats+0x30b0>
  218d39:	48 85 f6             	test   rsi,rsi
  218d3c:	74 5a                	je     218d98 <Benchmark_reportStats+0x3198>
  218d3e:	4c 89 f0             	mov    rax,r14
  218d41:	48 29 d0             	sub    rax,rdx
  218d44:	48 c1 e0 04          	shl    rax,0x4
  218d48:	4c 01 d0             	add    rax,r10
  218d4b:	48 83 c0 f0          	add    rax,0xfffffffffffffff0
  218d4f:	48 03 94 24 d8 00 00 	add    rdx,QWORD PTR [rsp+0xd8]
  218d56:	00 
  218d57:	4c 01 fa             	add    rdx,r15
  218d5a:	4c 01 ca             	add    rdx,r9
  218d5d:	48 c1 e2 04          	shl    rdx,0x4
  218d61:	4c 01 d2             	add    rdx,r10
  218d64:	48 f7 de             	neg    rsi
  218d67:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  218d6e:	00 00 
    const tmp = a.*;
  218d70:	c5 f8 10 02          	vmovups xmm0,XMMWORD PTR [rdx]
  218d74:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  218d79:	c5 f8 10 00          	vmovups xmm0,XMMWORD PTR [rax]
  218d7d:	c5 f8 11 02          	vmovups XMMWORD PTR [rdx],xmm0
    b.* = tmp;
  218d81:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  218d86:	c5 fa 7f 00          	vmovdqu XMMWORD PTR [rax],xmm0
    while (i < end) : (i += 1) {
  218d8a:	48 83 c0 f0          	add    rax,0xfffffffffffffff0
  218d8e:	48 83 c2 10          	add    rdx,0x10
  218d92:	48 83 c6 01          	add    rsi,0x1
  218d96:	75 d8                	jne    218d70 <Benchmark_reportStats+0x3170>
    const end = items.len / 2;
  218d98:	48 89 f8             	mov    rax,rdi
  218d9b:	48 d1 e8             	shr    rax,1
    while (i < end) : (i += 1) {
  218d9e:	0f 84 0c 22 00 00    	je     21afb0 <Benchmark_reportStats+0x53b0>
  218da4:	4b 8d 0c 02          	lea    rcx,[r10+r8*1]
    const tmp = a.*;
  218da8:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  218dac:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  218db1:	48 c1 e7 04          	shl    rdi,0x4
    a.* = b.*;
  218db5:	c5 f8 10 44 39 f0    	vmovups xmm0,XMMWORD PTR [rcx+rdi*1-0x10]
  218dbb:	c5 f8 11 01          	vmovups XMMWORD PTR [rcx],xmm0
    b.* = tmp;
  218dbf:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  218dc4:	c5 fa 7f 44 39 f0    	vmovdqu XMMWORD PTR [rcx+rdi*1-0x10],xmm0
    while (i < end) : (i += 1) {
  218dca:	48 83 f8 01          	cmp    rax,0x1
  218dce:	0f 84 dc 21 00 00    	je     21afb0 <Benchmark_reportStats+0x53b0>
        swap(T, &items[i], &items[items.len - i - 1]);
  218dd4:	8d 48 ff             	lea    ecx,[rax-0x1]
  218dd7:	48 8d 50 fe          	lea    rdx,[rax-0x2]
  218ddb:	83 e1 03             	and    ecx,0x3
  218dde:	48 83 fa 03          	cmp    rdx,0x3
  218de2:	0f 83 4e 01 00 00    	jae    218f36 <Benchmark_reportStats+0x3336>
  218de8:	ba 01 00 00 00       	mov    edx,0x1
    while (i < end) : (i += 1) {
  218ded:	48 85 c9             	test   rcx,rcx
  218df0:	0f 85 ec 01 00 00    	jne    218fe2 <Benchmark_reportStats+0x33e2>
  218df6:	e9 b5 21 00 00       	jmp    21afb0 <Benchmark_reportStats+0x53b0>
  218dfb:	31 d2                	xor    edx,edx
  218dfd:	44 89 e8             	mov    eax,r13d
  218e00:	41 f7 f6             	div    r14d
  218e03:	89 d6                	mov    esi,edx
                    var firstA = Range.init(A.start, A.start + blockA.length() % block_size);
  218e05:	4a 8d 04 26          	lea    rax,[rsi+r12*1]
  218e09:	48 8b 7c 24 30       	mov    rdi,QWORD PTR [rsp+0x30]
  218e0e:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
                    while (index < blockA.end) : ({
  218e13:	48 39 f8             	cmp    rax,rdi
  218e16:	0f 83 8a 00 00 00    	jae    218ea6 <Benchmark_reportStats+0x32a6>
  218e1c:	48 8b 54 24 18       	mov    rdx,QWORD PTR [rsp+0x18]
                        mem.swap(T, &items[indexA], &items[index]);
  218e21:	48 89 d0             	mov    rax,rdx
  218e24:	48 c1 e0 04          	shl    rax,0x4
  218e28:	48 8b 8c 24 d8 01 00 	mov    rcx,QWORD PTR [rsp+0x1d8]
  218e2f:	00 
    const tmp = a.*;
  218e30:	c4 c1 78 10 04 0a    	vmovups xmm0,XMMWORD PTR [r10+rcx*1]
  218e36:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  218e3b:	c4 c1 78 10 04 02    	vmovups xmm0,XMMWORD PTR [r10+rax*1]
  218e41:	c4 c1 78 11 04 0a    	vmovups XMMWORD PTR [r10+rcx*1],xmm0
    b.* = tmp;
  218e47:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  218e4c:	c4 c1 7a 7f 04 02    	vmovdqu XMMWORD PTR [r10+rax*1],xmm0
                        index += block_size;
  218e52:	4a 8d 1c 32          	lea    rbx,[rdx+r14*1]
                    while (index < blockA.end) : ({
  218e56:	48 39 fb             	cmp    rbx,rdi
  218e59:	73 4b                	jae    218ea6 <Benchmark_reportStats+0x32a6>
  218e5b:	48 8b 8c 24 c8 01 00 	mov    rcx,QWORD PTR [rsp+0x1c8]
  218e62:	00 
  218e63:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  218e6a:	84 00 00 00 00 00 
                        mem.swap(T, &items[indexA], &items[index]);
  218e70:	48 8b 54 24 40       	mov    rdx,QWORD PTR [rsp+0x40]
  218e75:	48 89 d8             	mov    rax,rbx
    const tmp = a.*;
  218e78:	c5 f8 10 04 0a       	vmovups xmm0,XMMWORD PTR [rdx+rcx*1]
  218e7d:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
  218e82:	48 c1 e0 04          	shl    rax,0x4
    a.* = b.*;
  218e86:	c5 f8 10 04 02       	vmovups xmm0,XMMWORD PTR [rdx+rax*1]
  218e8b:	c5 f8 11 04 0a       	vmovups XMMWORD PTR [rdx+rcx*1],xmm0
    b.* = tmp;
  218e90:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  218e95:	c5 fa 7f 04 02       	vmovdqu XMMWORD PTR [rdx+rax*1],xmm0
                        index += block_size;
  218e9a:	4c 01 f3             	add    rbx,r14
                    while (index < blockA.end) : ({
  218e9d:	48 83 c1 10          	add    rcx,0x10
  218ea1:	48 39 fb             	cmp    rbx,rdi
  218ea4:	72 ca                	jb     218e70 <Benchmark_reportStats+0x3270>
                    var lastA = firstA;
  218ea6:	4c 89 a4 24 78 01 00 	mov    QWORD PTR [rsp+0x178],r12
  218ead:	00 
  218eae:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  218eb3:	48 89 84 24 80 01 00 	mov    QWORD PTR [rsp+0x180],rax
  218eba:	00 
        return self.end - self.start;
  218ebb:	4c 8b 94 24 e8 00 00 	mov    r10,QWORD PTR [rsp+0xe8]
  218ec2:	00 
  218ec3:	49 29 fa             	sub    r10,rdi
    return if (x < y) x else y;
  218ec6:	4d 39 d6             	cmp    r14,r10
  218ec9:	4d 0f 42 d6          	cmovb  r10,r14
                    if (lastA.length() <= cache.len) {
  218ecd:	48 81 fe 00 02 00 00 	cmp    rsi,0x200
  218ed4:	77 2f                	ja     218f05 <Benchmark_reportStats+0x3305>
    for (source) |s, i|
  218ed6:	48 85 f6             	test   rsi,rsi
  218ed9:	0f 84 a2 03 00 00    	je     219281 <Benchmark_reportStats+0x3681>
  218edf:	4c 03 44 24 40       	add    r8,QWORD PTR [rsp+0x40]
  218ee4:	4c 03 bc 24 98 01 00 	add    r15,QWORD PTR [rsp+0x198]
  218eeb:	00 
  218eec:	4d 01 cf             	add    r15,r9
  218eef:	4d 85 db             	test   r11,r11
  218ef2:	0f 84 39 01 00 00    	je     219031 <Benchmark_reportStats+0x3431>
  218ef8:	31 d2                	xor    edx,edx
  218efa:	4c 89 e8             	mov    rax,r13
  218efd:	49 f7 f6             	div    r14
  218f00:	e9 34 01 00 00       	jmp    219039 <Benchmark_reportStats+0x3439>
  218f05:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
  218f0a:	48 39 44 24 50       	cmp    QWORD PTR [rsp+0x50],rax
                    } else if (buffer2.length() > 0) {
  218f0f:	0f 84 6c 03 00 00    	je     219281 <Benchmark_reportStats+0x3681>
        mem.swap(T, &items[start1 + index], &items[start2 + index]);
  218f15:	4c 03 bc 24 98 01 00 	add    r15,QWORD PTR [rsp+0x198]
  218f1c:	00 
  218f1d:	4d 01 cf             	add    r15,r9
  218f20:	4d 85 db             	test   r11,r11
  218f23:	0f 84 05 02 00 00    	je     21912e <Benchmark_reportStats+0x352e>
  218f29:	31 d2                	xor    edx,edx
  218f2b:	4c 89 e8             	mov    rax,r13
  218f2e:	49 f7 f6             	div    r14
  218f31:	e9 00 02 00 00       	jmp    219136 <Benchmark_reportStats+0x3536>
        swap(T, &items[i], &items[items.len - i - 1]);
  218f36:	4b 8d 34 1a          	lea    rsi,[r10+r11*1]
  218f3a:	48 83 c6 e0          	add    rsi,0xffffffffffffffe0
  218f3e:	4b 8d 3c 02          	lea    rdi,[r10+r8*1]
  218f42:	48 83 c7 40          	add    rdi,0x40
  218f46:	48 29 c8             	sub    rax,rcx
  218f49:	ba 01 00 00 00       	mov    edx,0x1
  218f4e:	66 90                	xchg   ax,ax
    const tmp = a.*;
  218f50:	c5 f8 10 47 d0       	vmovups xmm0,XMMWORD PTR [rdi-0x30]
  218f55:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  218f5a:	c5 f8 10 06          	vmovups xmm0,XMMWORD PTR [rsi]
  218f5e:	c5 f8 11 47 d0       	vmovups XMMWORD PTR [rdi-0x30],xmm0
    b.* = tmp;
  218f63:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  218f68:	c5 f8 11 06          	vmovups XMMWORD PTR [rsi],xmm0
    const tmp = a.*;
  218f6c:	c5 f8 10 47 e0       	vmovups xmm0,XMMWORD PTR [rdi-0x20]
  218f71:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  218f76:	c5 f8 10 46 f0       	vmovups xmm0,XMMWORD PTR [rsi-0x10]
  218f7b:	c5 f8 11 47 e0       	vmovups XMMWORD PTR [rdi-0x20],xmm0
    b.* = tmp;
  218f80:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  218f85:	c5 f8 11 46 f0       	vmovups XMMWORD PTR [rsi-0x10],xmm0
    const tmp = a.*;
  218f8a:	c5 f8 10 47 f0       	vmovups xmm0,XMMWORD PTR [rdi-0x10]
  218f8f:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  218f94:	c5 f8 10 46 e0       	vmovups xmm0,XMMWORD PTR [rsi-0x20]
  218f99:	c5 f8 11 47 f0       	vmovups XMMWORD PTR [rdi-0x10],xmm0
    b.* = tmp;
  218f9e:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  218fa3:	c5 f8 11 46 e0       	vmovups XMMWORD PTR [rsi-0x20],xmm0
    const tmp = a.*;
  218fa8:	c5 f8 10 07          	vmovups xmm0,XMMWORD PTR [rdi]
  218fac:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  218fb1:	c5 f8 10 46 d0       	vmovups xmm0,XMMWORD PTR [rsi-0x30]
  218fb6:	c5 f8 11 07          	vmovups XMMWORD PTR [rdi],xmm0
    b.* = tmp;
  218fba:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  218fbf:	c5 fa 7f 46 d0       	vmovdqu XMMWORD PTR [rsi-0x30],xmm0
    while (i < end) : (i += 1) {
  218fc4:	48 83 c2 04          	add    rdx,0x4
  218fc8:	48 83 c6 c0          	add    rsi,0xffffffffffffffc0
  218fcc:	48 83 c7 40          	add    rdi,0x40
  218fd0:	48 39 d0             	cmp    rax,rdx
  218fd3:	0f 85 77 ff ff ff    	jne    218f50 <Benchmark_reportStats+0x3350>
  218fd9:	48 85 c9             	test   rcx,rcx
  218fdc:	0f 84 ce 1f 00 00    	je     21afb0 <Benchmark_reportStats+0x53b0>
  218fe2:	49 29 d6             	sub    r14,rdx
  218fe5:	49 c1 e6 04          	shl    r14,0x4
  218fe9:	4b 8d 04 32          	lea    rax,[r10+r14*1]
  218fed:	48 83 c0 f0          	add    rax,0xfffffffffffffff0
  218ff1:	49 01 d4             	add    r12,rdx
  218ff4:	49 c1 e4 04          	shl    r12,0x4
  218ff8:	4d 01 d4             	add    r12,r10
  218ffb:	48 f7 d9             	neg    rcx
  218ffe:	66 90                	xchg   ax,ax
    const tmp = a.*;
  219000:	c4 c1 78 10 04 24    	vmovups xmm0,XMMWORD PTR [r12]
  219006:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21900b:	c5 f8 10 00          	vmovups xmm0,XMMWORD PTR [rax]
  21900f:	c4 c1 78 11 04 24    	vmovups XMMWORD PTR [r12],xmm0
    b.* = tmp;
  219015:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  21901a:	c5 fa 7f 00          	vmovdqu XMMWORD PTR [rax],xmm0
    while (i < end) : (i += 1) {
  21901e:	48 83 c0 f0          	add    rax,0xfffffffffffffff0
  219022:	49 83 c4 10          	add    r12,0x10
  219026:	48 83 c1 01          	add    rcx,0x1
  21902a:	75 d4                	jne    219000 <Benchmark_reportStats+0x3400>
  21902c:	e9 7f 1f 00 00       	jmp    21afb0 <Benchmark_reportStats+0x53b0>
  219031:	31 d2                	xor    edx,edx
  219033:	44 89 e8             	mov    eax,r13d
  219036:	41 f7 f6             	div    r14d
    for (source) |s, i|
  219039:	4c 29 ea             	sub    rdx,r13
  21903c:	49 01 d7             	add    r15,rdx
  21903f:	4d 29 e7             	sub    r15,r12
  219042:	89 f0                	mov    eax,esi
  219044:	83 e0 07             	and    eax,0x7
  219047:	49 83 ff 07          	cmp    r15,0x7
  21904b:	73 10                	jae    21905d <Benchmark_reportStats+0x345d>
  21904d:	31 c9                	xor    ecx,ecx
  21904f:	48 85 c0             	test   rax,rax
  219052:	0f 85 b2 00 00 00    	jne    21910a <Benchmark_reportStats+0x350a>
  219058:	e9 24 02 00 00       	jmp    219281 <Benchmark_reportStats+0x3681>
  21905d:	48 29 c6             	sub    rsi,rax
  219060:	ba 70 00 00 00       	mov    edx,0x70
  219065:	31 c9                	xor    ecx,ecx
  219067:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  21906e:	00 00 
        dest[i] = s;
  219070:	c4 c1 78 10 44 10 90 	vmovups xmm0,XMMWORD PTR [r8+rdx*1-0x70]
  219077:	c5 f8 11 84 14 b8 01 	vmovups XMMWORD PTR [rsp+rdx*1+0x1b8],xmm0
  21907e:	00 00 
  219080:	c4 c1 78 10 44 10 a0 	vmovups xmm0,XMMWORD PTR [r8+rdx*1-0x60]
  219087:	c5 f8 11 84 14 c8 01 	vmovups XMMWORD PTR [rsp+rdx*1+0x1c8],xmm0
  21908e:	00 00 
  219090:	c4 c1 78 10 44 10 b0 	vmovups xmm0,XMMWORD PTR [r8+rdx*1-0x50]
  219097:	c5 f8 11 84 14 d8 01 	vmovups XMMWORD PTR [rsp+rdx*1+0x1d8],xmm0
  21909e:	00 00 
  2190a0:	c4 c1 78 10 44 10 c0 	vmovups xmm0,XMMWORD PTR [r8+rdx*1-0x40]
  2190a7:	c5 f8 11 84 14 e8 01 	vmovups XMMWORD PTR [rsp+rdx*1+0x1e8],xmm0
  2190ae:	00 00 
  2190b0:	c4 c1 78 10 44 10 d0 	vmovups xmm0,XMMWORD PTR [r8+rdx*1-0x30]
  2190b7:	c5 f8 11 84 14 f8 01 	vmovups XMMWORD PTR [rsp+rdx*1+0x1f8],xmm0
  2190be:	00 00 
  2190c0:	c4 c1 78 10 44 10 e0 	vmovups xmm0,XMMWORD PTR [r8+rdx*1-0x20]
  2190c7:	c5 f8 11 84 14 08 02 	vmovups XMMWORD PTR [rsp+rdx*1+0x208],xmm0
  2190ce:	00 00 
  2190d0:	c4 c1 78 10 44 10 f0 	vmovups xmm0,XMMWORD PTR [r8+rdx*1-0x10]
  2190d7:	c5 f8 11 84 14 18 02 	vmovups XMMWORD PTR [rsp+rdx*1+0x218],xmm0
  2190de:	00 00 
  2190e0:	c4 c1 7a 6f 04 10    	vmovdqu xmm0,XMMWORD PTR [r8+rdx*1]
  2190e6:	c5 fa 7f 84 14 28 02 	vmovdqu XMMWORD PTR [rsp+rdx*1+0x228],xmm0
  2190ed:	00 00 
    for (source) |s, i|
  2190ef:	48 83 c1 08          	add    rcx,0x8
  2190f3:	48 83 ea 80          	sub    rdx,0xffffffffffffff80
  2190f7:	48 83 c6 f8          	add    rsi,0xfffffffffffffff8
  2190fb:	0f 85 6f ff ff ff    	jne    219070 <Benchmark_reportStats+0x3470>
  219101:	48 85 c0             	test   rax,rax
  219104:	0f 84 77 01 00 00    	je     219281 <Benchmark_reportStats+0x3681>
  21910a:	48 c1 e1 04          	shl    rcx,0x4
  21910e:	66 90                	xchg   ax,ax
        dest[i] = s;
  219110:	c4 c1 7a 6f 04 08    	vmovdqu xmm0,XMMWORD PTR [r8+rcx*1]
  219116:	c5 fa 7f 84 0c 28 02 	vmovdqu XMMWORD PTR [rsp+rcx*1+0x228],xmm0
  21911d:	00 00 
    for (source) |s, i|
  21911f:	48 83 c1 10          	add    rcx,0x10
  219123:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  219127:	75 e7                	jne    219110 <Benchmark_reportStats+0x3510>
  219129:	e9 53 01 00 00       	jmp    219281 <Benchmark_reportStats+0x3681>
  21912e:	31 d2                	xor    edx,edx
  219130:	44 89 e8             	mov    eax,r13d
  219133:	41 f7 f6             	div    r14d
  219136:	4c 29 ea             	sub    rdx,r13
  219139:	49 01 d7             	add    r15,rdx
  21913c:	4d 29 e7             	sub    r15,r12
  21913f:	89 f0                	mov    eax,esi
  219141:	83 e0 03             	and    eax,0x3
  219144:	49 83 ff 03          	cmp    r15,0x3
  219148:	4c 8b 8c 24 18 01 00 	mov    r9,QWORD PTR [rsp+0x118]
  21914f:	00 
  219150:	73 10                	jae    219162 <Benchmark_reportStats+0x3562>
  219152:	31 c9                	xor    ecx,ecx
    while (index < block_size) : (index += 1) {
  219154:	48 85 c0             	test   rax,rax
  219157:	0f 85 db 00 00 00    	jne    219238 <Benchmark_reportStats+0x3638>
  21915d:	e9 1f 01 00 00       	jmp    219281 <Benchmark_reportStats+0x3681>
        mem.swap(T, &items[start1 + index], &items[start2 + index]);
  219162:	48 29 c6             	sub    rsi,rax
  219165:	31 d2                	xor    edx,edx
  219167:	31 c9                	xor    ecx,ecx
  219169:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  219170:	48 8b 5c 24 40       	mov    rbx,QWORD PTR [rsp+0x40]
    const tmp = a.*;
  219175:	4a 8d 3c 03          	lea    rdi,[rbx+r8*1]
  219179:	c5 f8 10 04 3a       	vmovups xmm0,XMMWORD PTR [rdx+rdi*1]
  21917e:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  219183:	4c 01 cb             	add    rbx,r9
  219186:	c5 f8 10 04 1a       	vmovups xmm0,XMMWORD PTR [rdx+rbx*1]
  21918b:	c5 f8 11 04 3a       	vmovups XMMWORD PTR [rdx+rdi*1],xmm0
    b.* = tmp;
  219190:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  219195:	c5 f8 11 04 1a       	vmovups XMMWORD PTR [rdx+rbx*1],xmm0
  21919a:	48 8b 7c 24 40       	mov    rdi,QWORD PTR [rsp+0x40]
    const tmp = a.*;
  21919f:	4a 8d 5c 07 10       	lea    rbx,[rdi+r8*1+0x10]
  2191a4:	c5 f8 10 04 1a       	vmovups xmm0,XMMWORD PTR [rdx+rbx*1]
  2191a9:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  2191ae:	4a 8d 7c 0f 10       	lea    rdi,[rdi+r9*1+0x10]
  2191b3:	c5 f8 10 04 3a       	vmovups xmm0,XMMWORD PTR [rdx+rdi*1]
  2191b8:	c5 f8 11 04 1a       	vmovups XMMWORD PTR [rdx+rbx*1],xmm0
    b.* = tmp;
  2191bd:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  2191c2:	c5 f8 11 04 3a       	vmovups XMMWORD PTR [rdx+rdi*1],xmm0
  2191c7:	48 8b 7c 24 40       	mov    rdi,QWORD PTR [rsp+0x40]
    const tmp = a.*;
  2191cc:	4a 8d 5c 07 20       	lea    rbx,[rdi+r8*1+0x20]
  2191d1:	c5 f8 10 04 1a       	vmovups xmm0,XMMWORD PTR [rdx+rbx*1]
  2191d6:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  2191db:	4a 8d 7c 0f 20       	lea    rdi,[rdi+r9*1+0x20]
  2191e0:	c5 f8 10 04 3a       	vmovups xmm0,XMMWORD PTR [rdx+rdi*1]
  2191e5:	c5 f8 11 04 1a       	vmovups XMMWORD PTR [rdx+rbx*1],xmm0
    b.* = tmp;
  2191ea:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  2191ef:	c5 f8 11 04 3a       	vmovups XMMWORD PTR [rdx+rdi*1],xmm0
  2191f4:	48 8b 7c 24 40       	mov    rdi,QWORD PTR [rsp+0x40]
    const tmp = a.*;
  2191f9:	4a 8d 5c 07 30       	lea    rbx,[rdi+r8*1+0x30]
  2191fe:	c5 f8 10 04 1a       	vmovups xmm0,XMMWORD PTR [rdx+rbx*1]
  219203:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  219208:	4a 8d 7c 0f 30       	lea    rdi,[rdi+r9*1+0x30]
  21920d:	c5 f8 10 04 3a       	vmovups xmm0,XMMWORD PTR [rdx+rdi*1]
  219212:	c5 f8 11 04 1a       	vmovups XMMWORD PTR [rdx+rbx*1],xmm0
    b.* = tmp;
  219217:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  21921c:	c5 fa 7f 04 3a       	vmovdqu XMMWORD PTR [rdx+rdi*1],xmm0
    while (index < block_size) : (index += 1) {
  219221:	48 83 c1 04          	add    rcx,0x4
  219225:	48 83 c2 40          	add    rdx,0x40
  219229:	48 83 c6 fc          	add    rsi,0xfffffffffffffffc
  21922d:	0f 85 3d ff ff ff    	jne    219170 <Benchmark_reportStats+0x3570>
  219233:	48 85 c0             	test   rax,rax
  219236:	74 49                	je     219281 <Benchmark_reportStats+0x3681>
  219238:	48 8b 54 24 60       	mov    rdx,QWORD PTR [rsp+0x60]
  21923d:	48 8d 14 0a          	lea    rdx,[rdx+rcx*1]
  219241:	48 c1 e2 04          	shl    rdx,0x4
  219245:	4c 01 e1             	add    rcx,r12
  219248:	48 c1 e1 04          	shl    rcx,0x4
  21924c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
        mem.swap(T, &items[start1 + index], &items[start2 + index]);
  219250:	48 8b 74 24 40       	mov    rsi,QWORD PTR [rsp+0x40]
    const tmp = a.*;
  219255:	c5 f8 10 04 0e       	vmovups xmm0,XMMWORD PTR [rsi+rcx*1]
  21925a:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21925f:	c5 f8 10 04 16       	vmovups xmm0,XMMWORD PTR [rsi+rdx*1]
  219264:	c5 f8 11 04 0e       	vmovups XMMWORD PTR [rsi+rcx*1],xmm0
    b.* = tmp;
  219269:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  21926e:	c5 fa 7f 04 16       	vmovdqu XMMWORD PTR [rsi+rdx*1],xmm0
    while (index < block_size) : (index += 1) {
  219273:	48 83 c2 10          	add    rdx,0x10
  219277:	48 83 c1 10          	add    rcx,0x10
  21927b:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  21927f:	75 cf                	jne    219250 <Benchmark_reportStats+0x3650>
  219281:	4c 8b 5c 24 30       	mov    r11,QWORD PTR [rsp+0x30]
                    if (blockA.length() > 0) {
  219286:	4c 3b 5c 24 18       	cmp    r11,QWORD PTR [rsp+0x18]
  21928b:	0f 85 d6 00 00 00    	jne    219367 <Benchmark_reportStats+0x3767>
  219291:	4d 89 df             	mov    r15,r11
  219294:	48 8b 44 24 50       	mov    rax,QWORD PTR [rsp+0x50]
                    if (lastA.length() <= cache.len) {
  219299:	49 81 fd 00 02 00 00 	cmp    r13,0x200
  2192a0:	4c 8b 84 24 e8 00 00 	mov    r8,QWORD PTR [rsp+0xe8]
  2192a7:	00 
  2192a8:	0f 87 51 1a 00 00    	ja     21acff <Benchmark_reportStats+0x50ff>
    if (B.length() > 0 and A.length() > 0) {
  2192ae:	4d 85 ed             	test   r13,r13
  2192b1:	0f 84 e3 00 00 00    	je     21939a <Benchmark_reportStats+0x379a>
  2192b7:	4d 39 f8             	cmp    r8,r15
  2192ba:	0f 84 da 00 00 00    	je     21939a <Benchmark_reportStats+0x379a>
            if (!lessThan(items[B_index], cache[A_index])) {
  2192c0:	4d 89 ea             	mov    r10,r13
  2192c3:	49 f7 da             	neg    r10
  2192c6:	31 d2                	xor    edx,edx
  2192c8:	49 89 d1             	mov    r9,rdx
  2192cb:	4c 89 e3             	mov    rbx,r12
  2192ce:	48 c1 e3 04          	shl    rbx,0x4
  2192d2:	4f 8d 1c 0a          	lea    r11,[r10+r9*1]
  2192d6:	4c 89 c8             	mov    rax,r9
  2192d9:	48 c1 e0 04          	shl    rax,0x4
  2192dd:	48 8d 0c 04          	lea    rcx,[rsp+rax*1]
  2192e1:	48 81 c1 28 02 00 00 	add    rcx,0x228
  2192e8:	31 f6                	xor    esi,esi
  2192ea:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  2192f0:	48 8b 54 24 40       	mov    rdx,QWORD PTR [rsp+0x40]
  2192f5:	4c 89 f8             	mov    rax,r15
  2192f8:	48 c1 e0 04          	shl    rax,0x4
  2192fc:	48 8b 3c 02          	mov    rdi,QWORD PTR [rdx+rax*1]
  219300:	48 3b 39             	cmp    rdi,QWORD PTR [rcx]
  219303:	72 2b                	jb     219330 <Benchmark_reportStats+0x3730>
                items[insert_index] = cache[A_index];
  219305:	c5 fa 6f 01          	vmovdqu xmm0,XMMWORD PTR [rcx]
  219309:	c5 fa 7f 04 1a       	vmovdqu XMMWORD PTR [rdx+rbx*1],xmm0
                if (A_index == A_last) break;
  21930e:	48 83 c6 ff          	add    rsi,0xffffffffffffffff
  219312:	48 83 c3 10          	add    rbx,0x10
  219316:	48 83 c1 10          	add    rcx,0x10
  21931a:	49 39 f3             	cmp    r11,rsi
  21931d:	75 d1                	jne    2192f0 <Benchmark_reportStats+0x36f0>
  21931f:	eb 7e                	jmp    21939f <Benchmark_reportStats+0x379f>
  219321:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  219328:	0f 1f 84 00 00 00 00 
  21932f:	00 
  219330:	48 01 d0             	add    rax,rdx
                items[insert_index] = items[B_index];
  219333:	c5 fa 6f 00          	vmovdqu xmm0,XMMWORD PTR [rax]
  219337:	c5 fa 7f 04 1a       	vmovdqu XMMWORD PTR [rdx+rbx*1],xmm0
                B_index += 1;
  21933c:	49 83 c7 01          	add    r15,0x1
                if (B_index == B_last) break;
  219340:	4c 89 e1             	mov    rcx,r12
  219343:	48 83 c1 01          	add    rcx,0x1
  219347:	49 89 cc             	mov    r12,rcx
  21934a:	49 29 f4             	sub    r12,rsi
  21934d:	4c 89 ca             	mov    rdx,r9
  219350:	48 29 f2             	sub    rdx,rsi
  219353:	4d 39 c7             	cmp    r15,r8
  219356:	0f 85 6c ff ff ff    	jne    2192c8 <Benchmark_reportStats+0x36c8>
    mem.copy(T, items[insert_index..], cache[A_index..A_last]);
  21935c:	48 29 f1             	sub    rcx,rsi
  21935f:	49 29 f1             	sub    r9,rsi
  219362:	49 89 cc             	mov    r12,rcx
  219365:	eb 3e                	jmp    2193a5 <Benchmark_reportStats+0x37a5>
  219367:	4d 89 d0             	mov    r8,r10
  21936a:	4d 01 d8             	add    r8,r11
  21936d:	48 8b 84 24 e8 00 00 	mov    rax,QWORD PTR [rsp+0xe8]
  219374:	00 
  219375:	4c 29 f0             	sub    rax,r14
  219378:	48 89 84 24 d0 01 00 	mov    QWORD PTR [rsp+0x1d0],rax
  21937f:	00 
  219380:	31 db                	xor    ebx,ebx
  219382:	45 31 e4             	xor    r12d,r12d
  219385:	4c 89 df             	mov    rdi,r11
  219388:	48 8b 44 24 70       	mov    rax,QWORD PTR [rsp+0x70]
  21938d:	48 89 c6             	mov    rsi,rax
  219390:	4c 8b 54 24 18       	mov    r10,QWORD PTR [rsp+0x18]
  219395:	e9 66 01 00 00       	jmp    219500 <Benchmark_reportStats+0x3900>
  21939a:	45 31 c9             	xor    r9d,r9d
  21939d:	eb 06                	jmp    2193a5 <Benchmark_reportStats+0x37a5>
  21939f:	49 29 f4             	sub    r12,rsi
  2193a2:	4d 89 e9             	mov    r9,r13
  2193a5:	48 8b 44 24 48       	mov    rax,QWORD PTR [rsp+0x48]
  2193aa:	4c 29 e0             	sub    rax,r12
  2193ad:	4c 89 ee             	mov    rsi,r13
  2193b0:	4c 29 ce             	sub    rsi,r9
    assert(dest.len >= source.len);
  2193b3:	48 39 f0             	cmp    rax,rsi
  2193b6:	0f 82 b0 53 00 00    	jb     21e76c <Benchmark_reportStats+0x8b6c>
    for (source) |s, i|
  2193bc:	48 85 f6             	test   rsi,rsi
  2193bf:	0f 84 eb 1b 00 00    	je     21afb0 <Benchmark_reportStats+0x53b0>
  2193c5:	4c 8b 54 24 40       	mov    r10,QWORD PTR [rsp+0x40]
  2193ca:	49 83 c5 ff          	add    r13,0xffffffffffffffff
  2193ce:	4d 29 cd             	sub    r13,r9
  2193d1:	89 f2                	mov    edx,esi
  2193d3:	83 e2 07             	and    edx,0x7
  2193d6:	49 83 fd 07          	cmp    r13,0x7
  2193da:	73 10                	jae    2193ec <Benchmark_reportStats+0x37ec>
  2193dc:	31 ff                	xor    edi,edi
  2193de:	48 85 d2             	test   rdx,rdx
  2193e1:	0f 85 ad 00 00 00    	jne    219494 <Benchmark_reportStats+0x3894>
  2193e7:	e9 c4 1b 00 00       	jmp    21afb0 <Benchmark_reportStats+0x53b0>
  2193ec:	4c 89 e3             	mov    rbx,r12
  2193ef:	48 c1 e3 04          	shl    rbx,0x4
  2193f3:	4c 01 d3             	add    rbx,r10
  2193f6:	48 29 d6             	sub    rsi,rdx
  2193f9:	4c 89 c8             	mov    rax,r9
  2193fc:	48 c1 e0 04          	shl    rax,0x4
  219400:	48 8d 0c 04          	lea    rcx,[rsp+rax*1]
  219404:	48 81 c1 28 02 00 00 	add    rcx,0x228
  21940b:	b8 70 00 00 00       	mov    eax,0x70
  219410:	31 ff                	xor    edi,edi
  219412:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  219419:	1f 84 00 00 00 00 00 
        dest[i] = s;
  219420:	c5 f8 10 44 01 90    	vmovups xmm0,XMMWORD PTR [rcx+rax*1-0x70]
  219426:	c5 f8 11 44 03 90    	vmovups XMMWORD PTR [rbx+rax*1-0x70],xmm0
  21942c:	c5 f8 10 44 01 a0    	vmovups xmm0,XMMWORD PTR [rcx+rax*1-0x60]
  219432:	c5 f8 11 44 03 a0    	vmovups XMMWORD PTR [rbx+rax*1-0x60],xmm0
  219438:	c5 f8 10 44 01 b0    	vmovups xmm0,XMMWORD PTR [rcx+rax*1-0x50]
  21943e:	c5 f8 11 44 03 b0    	vmovups XMMWORD PTR [rbx+rax*1-0x50],xmm0
  219444:	c5 f8 10 44 01 c0    	vmovups xmm0,XMMWORD PTR [rcx+rax*1-0x40]
  21944a:	c5 f8 11 44 03 c0    	vmovups XMMWORD PTR [rbx+rax*1-0x40],xmm0
  219450:	c5 f8 10 44 01 d0    	vmovups xmm0,XMMWORD PTR [rcx+rax*1-0x30]
  219456:	c5 f8 11 44 03 d0    	vmovups XMMWORD PTR [rbx+rax*1-0x30],xmm0
  21945c:	c5 f8 10 44 01 e0    	vmovups xmm0,XMMWORD PTR [rcx+rax*1-0x20]
  219462:	c5 f8 11 44 03 e0    	vmovups XMMWORD PTR [rbx+rax*1-0x20],xmm0
  219468:	c5 f8 10 44 01 f0    	vmovups xmm0,XMMWORD PTR [rcx+rax*1-0x10]
  21946e:	c5 f8 11 44 03 f0    	vmovups XMMWORD PTR [rbx+rax*1-0x10],xmm0
  219474:	c5 fa 6f 04 01       	vmovdqu xmm0,XMMWORD PTR [rcx+rax*1]
  219479:	c5 fa 7f 04 03       	vmovdqu XMMWORD PTR [rbx+rax*1],xmm0
    for (source) |s, i|
  21947e:	48 83 c7 08          	add    rdi,0x8
  219482:	48 83 e8 80          	sub    rax,0xffffffffffffff80
  219486:	48 39 fe             	cmp    rsi,rdi
  219489:	75 95                	jne    219420 <Benchmark_reportStats+0x3820>
  21948b:	48 85 d2             	test   rdx,rdx
  21948e:	0f 84 1c 1b 00 00    	je     21afb0 <Benchmark_reportStats+0x53b0>
  219494:	49 01 fc             	add    r12,rdi
  219497:	49 c1 e4 04          	shl    r12,0x4
  21949b:	4d 01 e2             	add    r10,r12
  21949e:	49 01 f9             	add    r9,rdi
  2194a1:	49 c1 e1 04          	shl    r9,0x4
  2194a5:	4a 8d 04 0c          	lea    rax,[rsp+r9*1]
  2194a9:	48 05 28 02 00 00    	add    rax,0x228
  2194af:	48 f7 da             	neg    rdx
  2194b2:	31 c9                	xor    ecx,ecx
  2194b4:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  2194bb:	00 00 00 00 00 
        dest[i] = s;
  2194c0:	c5 fa 6f 04 08       	vmovdqu xmm0,XMMWORD PTR [rax+rcx*1]
  2194c5:	c4 c1 7a 7f 04 0a    	vmovdqu XMMWORD PTR [r10+rcx*1],xmm0
    for (source) |s, i|
  2194cb:	48 83 c1 10          	add    rcx,0x10
  2194cf:	48 83 c2 01          	add    rdx,0x1
  2194d3:	75 eb                	jne    2194c0 <Benchmark_reportStats+0x38c0>
  2194d5:	e9 d6 1a 00 00       	jmp    21afb0 <Benchmark_reportStats+0x53b0>
                                lastB = Range.init(blockA.start, blockA.start + block_size);
  2194da:	4f 8d 14 34          	lea    r10,[r12+r14*1]
                                blockA.end += block_size;
  2194de:	4d 01 f3             	add    r11,r14
                                blockB.start += block_size;
  2194e1:	4c 01 f7             	add    rdi,r14
                                if (blockB.end > B.end - block_size) {
  2194e4:	4c 3b 84 24 d0 01 00 	cmp    r8,QWORD PTR [rsp+0x1d0]
  2194eb:	00 
                                    blockB.end += block_size;
  2194ec:	4f 8d 04 30          	lea    r8,[r8+r14*1]
                                if (blockB.end > B.end - block_size) {
  2194f0:	4c 0f 47 84 24 e8 00 	cmova  r8,QWORD PTR [rsp+0xe8]
  2194f7:	00 00 
  2194f9:	4c 89 d3             	mov    rbx,r10
  2194fc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  219500:	48 89 bc 24 d0 00 00 	mov    QWORD PTR [rsp+0xd0],rdi
  219507:	00 
  219508:	eb 20                	jmp    21952a <Benchmark_reportStats+0x392a>
  21950a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
                                blockA.end += blockB.length();
  219510:	4d 01 d3             	add    r11,r10
                                lastB = Range.init(blockA.start, blockA.start + blockB.length());
  219513:	4f 8d 14 22          	lea    r10,[r10+r12*1]
  219517:	4c 89 d3             	mov    rbx,r10
  21951a:	48 8b bc 24 d0 00 00 	mov    rdi,QWORD PTR [rsp+0xd0]
  219521:	00 
  219522:	49 89 f8             	mov    r8,rdi
  219525:	48 8b 74 24 20       	mov    rsi,QWORD PTR [rsp+0x20]
  21952a:	4d 89 e7             	mov    r15,r12
  21952d:	4c 89 5c 24 30       	mov    QWORD PTR [rsp+0x30],r11
  219532:	4c 89 84 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],r8
  219539:	00 
  21953a:	eb 14                	jmp    219550 <Benchmark_reportStats+0x3950>
  21953c:	45 31 d2             	xor    r10d,r10d
  21953f:	31 ff                	xor    edi,edi
    while (index < block_size) : (index += 1) {
  219541:	4d 29 d1             	sub    r9,r10
  219544:	0f 85 65 06 00 00    	jne    219baf <Benchmark_reportStats+0x3faf>
  21954a:	e9 e1 07 00 00       	jmp    219d30 <Benchmark_reportStats+0x4130>
  21954f:	90                   	nop
  219550:	4d 89 d4             	mov    r12,r10
                            if ((lastB.length() > 0 and !lessThan(items[lastB.end - 1], items[indexA])) or blockB.length() == 0) {
  219553:	4c 39 fb             	cmp    rbx,r15
  219556:	48 89 74 24 20       	mov    QWORD PTR [rsp+0x20],rsi
  21955b:	75 13                	jne    219570 <Benchmark_reportStats+0x3970>
  21955d:	49 39 f8             	cmp    r8,rdi
  219560:	0f 85 3a 11 00 00    	jne    21a6a0 <Benchmark_reportStats+0x4aa0>
                                const B_split = binaryFirst(T, items, items[indexA], lastB, lessThan);
  219566:	48 8b 54 24 40       	mov    rdx,QWORD PTR [rsp+0x40]
  21956b:	eb 2a                	jmp    219597 <Benchmark_reportStats+0x3997>
  21956d:	0f 1f 00             	nop    DWORD PTR [rax]
                            if ((lastB.length() > 0 and !lessThan(items[lastB.end - 1], items[indexA])) or blockB.length() == 0) {
  219570:	48 8b 54 24 40       	mov    rdx,QWORD PTR [rsp+0x40]
  219575:	49 39 f8             	cmp    r8,rdi
  219578:	74 1d                	je     219597 <Benchmark_reportStats+0x3997>
  21957a:	48 89 d8             	mov    rax,rbx
  21957d:	48 c1 e0 04          	shl    rax,0x4
  219581:	48 89 f1             	mov    rcx,rsi
  219584:	48 c1 e1 04          	shl    rcx,0x4
  219588:	48 8b 0c 0a          	mov    rcx,QWORD PTR [rdx+rcx*1]
  21958c:	48 39 4c 02 f0       	cmp    QWORD PTR [rdx+rax*1-0x10],rcx
  219591:	0f 82 09 11 00 00    	jb     21a6a0 <Benchmark_reportStats+0x4aa0>
                                const B_split = binaryFirst(T, items, items[indexA], lastB, lessThan);
  219597:	49 89 f1             	mov    r9,rsi
  21959a:	49 c1 e1 04          	shl    r9,0x4
  21959e:	49 89 dd             	mov    r13,rbx
  2195a1:	48 89 5c 24 38       	mov    QWORD PTR [rsp+0x38],rbx
    if (range.start >= range.end) return range.end;
  2195a6:	49 39 df             	cmp    r15,rbx
  2195a9:	0f 83 87 00 00 00    	jae    219636 <Benchmark_reportStats+0x3a36>
  2195af:	4e 8d 04 0a          	lea    r8,[rdx+r9*1]
    var end = range.end - 1;
  2195b3:	48 8b 44 24 38       	mov    rax,QWORD PTR [rsp+0x38]
  2195b8:	4c 8d 50 ff          	lea    r10,[rax-0x1]
    while (start < end) {
  2195bc:	4d 39 fa             	cmp    r10,r15
  2195bf:	76 4b                	jbe    21960c <Benchmark_reportStats+0x3a0c>
  2195c1:	49 8b 18             	mov    rbx,QWORD PTR [r8]
  2195c4:	4c 89 d1             	mov    rcx,r10
  2195c7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  2195ce:	00 00 
        const mid = start + (end - start) / 2;
  2195d0:	48 89 ce             	mov    rsi,rcx
  2195d3:	4c 29 fe             	sub    rsi,r15
  2195d6:	48 d1 ee             	shr    rsi,1
  2195d9:	4a 8d 3c 3e          	lea    rdi,[rsi+r15*1]
  2195dd:	48 89 f8             	mov    rax,rdi
  2195e0:	48 c1 e0 04          	shl    rax,0x4
  2195e4:	48 39 1c 02          	cmp    QWORD PTR [rdx+rax*1],rbx
        if (lessThan(items[mid], value)) {
  2195e8:	72 16                	jb     219600 <Benchmark_reportStats+0x3a00>
  2195ea:	48 89 f9             	mov    rcx,rdi
    while (start < end) {
  2195ed:	4c 39 f9             	cmp    rcx,r15
  2195f0:	77 de                	ja     2195d0 <Benchmark_reportStats+0x39d0>
  2195f2:	eb 18                	jmp    21960c <Benchmark_reportStats+0x3a0c>
  2195f4:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  2195fb:	00 00 00 00 00 
  219600:	49 01 f7             	add    r15,rsi
  219603:	49 83 c7 01          	add    r15,0x1
  219607:	4c 39 f9             	cmp    rcx,r15
  21960a:	77 c4                	ja     2195d0 <Benchmark_reportStats+0x39d0>
    if (start == range.end - 1 and lessThan(items[start], value)) {
  21960c:	4d 39 d7             	cmp    r15,r10
  21960f:	75 1f                	jne    219630 <Benchmark_reportStats+0x3a30>
  219611:	49 c1 e2 04          	shl    r10,0x4
  219615:	4a 8b 04 12          	mov    rax,QWORD PTR [rdx+r10*1]
  219619:	45 31 ed             	xor    r13d,r13d
  21961c:	49 3b 00             	cmp    rax,QWORD PTR [r8]
  21961f:	41 0f 92 c5          	setb   r13b
  219623:	eb 0e                	jmp    219633 <Benchmark_reportStats+0x3a33>
  219625:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21962c:	00 00 00 00 
  219630:	45 31 ed             	xor    r13d,r13d
  219633:	4d 01 fd             	add    r13,r15
  219636:	4f 8d 04 34          	lea    r8,[r12+r14*1]
  21963a:	4c 89 e0             	mov    rax,r12
                                while (findA < blockA.end) : (findA += block_size) {
  21963d:	4d 39 d8             	cmp    r8,r11
  219640:	73 37                	jae    219679 <Benchmark_reportStats+0x3a79>
  219642:	4c 89 c6             	mov    rsi,r8
  219645:	4c 89 e3             	mov    rbx,r12
  219648:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  21964f:	00 
  219650:	48 89 f0             	mov    rax,rsi
  219653:	48 c1 e0 04          	shl    rax,0x4
  219657:	48 8b 0c 02          	mov    rcx,QWORD PTR [rdx+rax*1]
  21965b:	48 89 df             	mov    rdi,rbx
  21965e:	48 c1 e7 04          	shl    rdi,0x4
                                    if (lessThan(items[findA], items[minA])) {
  219662:	48 89 f0             	mov    rax,rsi
  219665:	48 3b 0c 3a          	cmp    rcx,QWORD PTR [rdx+rdi*1]
  219669:	72 03                	jb     21966e <Benchmark_reportStats+0x3a6e>
  21966b:	48 89 d8             	mov    rax,rbx
  21966e:	4c 01 f6             	add    rsi,r14
  219671:	48 89 c3             	mov    rbx,rax
                                while (findA < blockA.end) : (findA += block_size) {
  219674:	4c 39 de             	cmp    rsi,r11
  219677:	72 d7                	jb     219650 <Benchmark_reportStats+0x3a50>
  219679:	48 83 7c 24 58 03    	cmp    QWORD PTR [rsp+0x58],0x3
    while (index < block_size) : (index += 1) {
  21967f:	73 1f                	jae    2196a0 <Benchmark_reportStats+0x3aa0>
  219681:	31 f6                	xor    esi,esi
  219683:	48 83 7c 24 10 00    	cmp    QWORD PTR [rsp+0x10],0x0
  219689:	0f 85 0f 01 00 00    	jne    21979e <Benchmark_reportStats+0x3b9e>
  21968f:	e9 55 01 00 00       	jmp    2197e9 <Benchmark_reportStats+0x3be9>
  219694:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21969b:	00 00 00 00 00 
  2196a0:	48 89 c7             	mov    rdi,rax
  2196a3:	48 c1 e7 04          	shl    rdi,0x4
  2196a7:	48 83 c7 20          	add    rdi,0x20
  2196ab:	31 f6                	xor    esi,esi
  2196ad:	48 8b 9c 24 10 01 00 	mov    rbx,QWORD PTR [rsp+0x110]
  2196b4:	00 
  2196b5:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  2196bc:	00 00 00 00 
        mem.swap(T, &items[start1 + index], &items[start2 + index]);
  2196c0:	4a 8d 0c 26          	lea    rcx,[rsi+r12*1]
  2196c4:	48 c1 e1 04          	shl    rcx,0x4
    const tmp = a.*;
  2196c8:	c5 f8 10 04 0a       	vmovups xmm0,XMMWORD PTR [rdx+rcx*1]
  2196cd:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  2196d2:	c5 f8 10 44 3a e0    	vmovups xmm0,XMMWORD PTR [rdx+rdi*1-0x20]
  2196d8:	c5 f8 11 04 0a       	vmovups XMMWORD PTR [rdx+rcx*1],xmm0
    b.* = tmp;
  2196dd:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  2196e2:	c5 f8 11 44 3a e0    	vmovups XMMWORD PTR [rdx+rdi*1-0x20],xmm0
    while (index < block_size) : (index += 1) {
  2196e8:	48 89 f1             	mov    rcx,rsi
  2196eb:	48 83 c9 01          	or     rcx,0x1
  2196ef:	48 8b 54 24 40       	mov    rdx,QWORD PTR [rsp+0x40]
        mem.swap(T, &items[start1 + index], &items[start2 + index]);
  2196f4:	4c 01 e1             	add    rcx,r12
  2196f7:	48 c1 e1 04          	shl    rcx,0x4
    const tmp = a.*;
  2196fb:	c5 f8 10 04 0a       	vmovups xmm0,XMMWORD PTR [rdx+rcx*1]
  219700:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  219705:	c5 f8 10 44 3a f0    	vmovups xmm0,XMMWORD PTR [rdx+rdi*1-0x10]
  21970b:	c5 f8 11 04 0a       	vmovups XMMWORD PTR [rdx+rcx*1],xmm0
    b.* = tmp;
  219710:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  219715:	c5 f8 11 44 3a f0    	vmovups XMMWORD PTR [rdx+rdi*1-0x10],xmm0
    while (index < block_size) : (index += 1) {
  21971b:	48 89 f1             	mov    rcx,rsi
  21971e:	48 83 c9 02          	or     rcx,0x2
  219722:	48 8b 54 24 40       	mov    rdx,QWORD PTR [rsp+0x40]
        mem.swap(T, &items[start1 + index], &items[start2 + index]);
  219727:	4c 01 e1             	add    rcx,r12
  21972a:	48 c1 e1 04          	shl    rcx,0x4
    const tmp = a.*;
  21972e:	c5 f8 10 04 0a       	vmovups xmm0,XMMWORD PTR [rdx+rcx*1]
  219733:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  219738:	c5 f8 10 04 3a       	vmovups xmm0,XMMWORD PTR [rdx+rdi*1]
  21973d:	c5 f8 11 04 0a       	vmovups XMMWORD PTR [rdx+rcx*1],xmm0
    b.* = tmp;
  219742:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  219747:	c5 f8 11 04 3a       	vmovups XMMWORD PTR [rdx+rdi*1],xmm0
    while (index < block_size) : (index += 1) {
  21974c:	48 89 f1             	mov    rcx,rsi
  21974f:	48 83 c9 03          	or     rcx,0x3
  219753:	48 8b 54 24 40       	mov    rdx,QWORD PTR [rsp+0x40]
        mem.swap(T, &items[start1 + index], &items[start2 + index]);
  219758:	4c 01 e1             	add    rcx,r12
  21975b:	48 c1 e1 04          	shl    rcx,0x4
    const tmp = a.*;
  21975f:	c5 f8 10 04 0a       	vmovups xmm0,XMMWORD PTR [rdx+rcx*1]
  219764:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  219769:	c5 f8 10 44 3a 10    	vmovups xmm0,XMMWORD PTR [rdx+rdi*1+0x10]
  21976f:	c5 f8 11 04 0a       	vmovups XMMWORD PTR [rdx+rcx*1],xmm0
    b.* = tmp;
  219774:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  219779:	c5 fa 7f 44 3a 10    	vmovdqu XMMWORD PTR [rdx+rdi*1+0x10],xmm0
    while (index < block_size) : (index += 1) {
  21977f:	48 83 c6 04          	add    rsi,0x4
  219783:	48 8b 54 24 40       	mov    rdx,QWORD PTR [rsp+0x40]
  219788:	48 83 c7 40          	add    rdi,0x40
  21978c:	48 83 c3 fc          	add    rbx,0xfffffffffffffffc
  219790:	0f 85 2a ff ff ff    	jne    2196c0 <Benchmark_reportStats+0x3ac0>
  219796:	48 83 7c 24 10 00    	cmp    QWORD PTR [rsp+0x10],0x0
  21979c:	74 4b                	je     2197e9 <Benchmark_reportStats+0x3be9>
  21979e:	48 01 f0             	add    rax,rsi
  2197a1:	48 c1 e0 04          	shl    rax,0x4
  2197a5:	48 8b 7c 24 10       	mov    rdi,QWORD PTR [rsp+0x10]
  2197aa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
        mem.swap(T, &items[start1 + index], &items[start2 + index]);
  2197b0:	4a 8d 0c 26          	lea    rcx,[rsi+r12*1]
  2197b4:	48 c1 e1 04          	shl    rcx,0x4
    const tmp = a.*;
  2197b8:	c5 f8 10 04 0a       	vmovups xmm0,XMMWORD PTR [rdx+rcx*1]
  2197bd:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  2197c2:	c5 f8 10 04 02       	vmovups xmm0,XMMWORD PTR [rdx+rax*1]
  2197c7:	c5 f8 11 04 0a       	vmovups XMMWORD PTR [rdx+rcx*1],xmm0
    b.* = tmp;
  2197cc:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  2197d1:	c5 fa 7f 04 02       	vmovdqu XMMWORD PTR [rdx+rax*1],xmm0
    while (index < block_size) : (index += 1) {
  2197d6:	48 83 c6 01          	add    rsi,0x1
  2197da:	48 8b 54 24 40       	mov    rdx,QWORD PTR [rsp+0x40]
  2197df:	48 83 c0 10          	add    rax,0x10
  2197e3:	48 83 c7 ff          	add    rdi,0xffffffffffffffff
  2197e7:	75 c7                	jne    2197b0 <Benchmark_reportStats+0x3bb0>
                                mem.swap(T, &items[blockA.start], &items[indexA]);
  2197e9:	4d 89 e6             	mov    r14,r12
  2197ec:	49 c1 e6 04          	shl    r14,0x4
    const tmp = a.*;
  2197f0:	c4 a1 78 10 04 32    	vmovups xmm0,XMMWORD PTR [rdx+r14*1]
  2197f6:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  2197fb:	c4 a1 78 10 04 0a    	vmovups xmm0,XMMWORD PTR [rdx+r9*1]
  219801:	c4 a1 78 11 04 32    	vmovups XMMWORD PTR [rdx+r14*1],xmm0
    b.* = tmp;
  219807:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  21980c:	c4 a1 7a 7f 04 0a    	vmovdqu XMMWORD PTR [rdx+r9*1],xmm0
  219812:	4c 8b 9c 24 78 01 00 	mov    r11,QWORD PTR [rsp+0x178]
  219819:	00 
  21981a:	48 8b b4 24 80 01 00 	mov    rsi,QWORD PTR [rsp+0x180]
  219821:	00 
        return self.end - self.start;
  219822:	49 89 f1             	mov    r9,rsi
  219825:	4d 29 d9             	sub    r9,r11
                                if (lastA.length() <= cache.len) {
  219828:	49 81 f9 00 02 00 00 	cmp    r9,0x200
  21982f:	4c 89 44 24 18       	mov    QWORD PTR [rsp+0x18],r8
  219834:	0f 87 f6 00 00 00    	ja     219930 <Benchmark_reportStats+0x3d30>
  21983a:	4d 89 d8             	mov    r8,r11
    if (B.length() > 0 and A.length() > 0) {
  21983d:	49 39 f5             	cmp    r13,rsi
  219840:	0f 84 27 02 00 00    	je     219a6d <Benchmark_reportStats+0x3e6d>
  219846:	41 bf 00 00 00 00    	mov    r15d,0x0
  21984c:	4d 85 c9             	test   r9,r9
  21984f:	0f 84 1b 02 00 00    	je     219a70 <Benchmark_reportStats+0x3e70>
            if (!lessThan(items[B_index], cache[A_index])) {
  219855:	4c 89 d9             	mov    rcx,r11
  219858:	48 29 f1             	sub    rcx,rsi
  21985b:	4d 89 d8             	mov    r8,r11
  21985e:	48 89 74 24 68       	mov    QWORD PTR [rsp+0x68],rsi
  219863:	49 89 f2             	mov    r10,rsi
  219866:	31 f6                	xor    esi,esi
  219868:	48 89 8c 24 28 01 00 	mov    QWORD PTR [rsp+0x128],rcx
  21986f:	00 
  219870:	4c 89 c7             	mov    rdi,r8
  219873:	48 c1 e7 04          	shl    rdi,0x4
  219877:	48 8d 04 31          	lea    rax,[rcx+rsi*1]
  21987b:	48 89 b4 24 50 01 00 	mov    QWORD PTR [rsp+0x150],rsi
  219882:	00 
  219883:	48 89 f1             	mov    rcx,rsi
  219886:	48 c1 e1 04          	shl    rcx,0x4
  21988a:	48 8d 34 0c          	lea    rsi,[rsp+rcx*1]
  21988e:	48 81 c6 28 02 00 00 	add    rsi,0x228
  219895:	31 d2                	xor    edx,edx
  219897:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  21989e:	00 00 
  2198a0:	48 8b 5c 24 40       	mov    rbx,QWORD PTR [rsp+0x40]
  2198a5:	4c 89 d1             	mov    rcx,r10
  2198a8:	48 c1 e1 04          	shl    rcx,0x4
  2198ac:	4c 8b 3c 0b          	mov    r15,QWORD PTR [rbx+rcx*1]
  2198b0:	4c 3b 3e             	cmp    r15,QWORD PTR [rsi]
  2198b3:	72 2b                	jb     2198e0 <Benchmark_reportStats+0x3ce0>
                items[insert_index] = cache[A_index];
  2198b5:	c5 fa 6f 06          	vmovdqu xmm0,XMMWORD PTR [rsi]
  2198b9:	c5 fa 7f 04 3b       	vmovdqu XMMWORD PTR [rbx+rdi*1],xmm0
                if (A_index == A_last) break;
  2198be:	48 83 c2 ff          	add    rdx,0xffffffffffffffff
  2198c2:	48 83 c7 10          	add    rdi,0x10
  2198c6:	48 83 c6 10          	add    rsi,0x10
  2198ca:	48 39 d0             	cmp    rax,rdx
  2198cd:	75 d1                	jne    2198a0 <Benchmark_reportStats+0x3ca0>
  2198cf:	e9 8c 01 00 00       	jmp    219a60 <Benchmark_reportStats+0x3e60>
  2198d4:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  2198db:	00 00 00 00 00 
  2198e0:	48 01 d9             	add    rcx,rbx
                items[insert_index] = items[B_index];
  2198e3:	c5 fa 6f 01          	vmovdqu xmm0,XMMWORD PTR [rcx]
  2198e7:	c5 fa 7f 04 3b       	vmovdqu XMMWORD PTR [rbx+rdi*1],xmm0
                B_index += 1;
  2198ec:	49 83 c2 01          	add    r10,0x1
                if (B_index == B_last) break;
  2198f0:	4c 89 c0             	mov    rax,r8
  2198f3:	48 83 c0 01          	add    rax,0x1
  2198f7:	49 89 c0             	mov    r8,rax
  2198fa:	49 29 d0             	sub    r8,rdx
  2198fd:	4c 8b bc 24 50 01 00 	mov    r15,QWORD PTR [rsp+0x150]
  219904:	00 
  219905:	4c 89 fe             	mov    rsi,r15
  219908:	48 29 d6             	sub    rsi,rdx
  21990b:	4d 39 ea             	cmp    r10,r13
  21990e:	48 8b 8c 24 28 01 00 	mov    rcx,QWORD PTR [rsp+0x128]
  219915:	00 
  219916:	0f 85 54 ff ff ff    	jne    219870 <Benchmark_reportStats+0x3c70>
    mem.copy(T, items[insert_index..], cache[A_index..A_last]);
  21991c:	48 29 d0             	sub    rax,rdx
  21991f:	49 29 d7             	sub    r15,rdx
  219922:	49 89 c0             	mov    r8,rax
  219925:	e9 3c 01 00 00       	jmp    219a66 <Benchmark_reportStats+0x3e66>
  21992a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  219930:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
  219935:	48 39 44 24 50       	cmp    QWORD PTR [rsp+0x50],rax
                                } else if (buffer2.length() > 0) {
  21993a:	75 34                	jne    219970 <Benchmark_reportStats+0x3d70>
        return Range{
  21993c:	48 89 b4 24 18 02 00 	mov    QWORD PTR [rsp+0x218],rsi
  219943:	00 
  219944:	4c 89 ac 24 20 02 00 	mov    QWORD PTR [rsp+0x220],r13
  21994b:	00 
                                    mergeInPlace(T, items, lastA, Range.init(lastA.end, B_split), lessThan);
  21994c:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  219951:	48 8d b4 24 78 01 00 	lea    rsi,[rsp+0x178]
  219958:	00 
  219959:	48 8d 94 24 18 02 00 	lea    rdx,[rsp+0x218]
  219960:	00 
  219961:	c5 f8 77             	vzeroupper 
  219964:	e8 97 4f 00 00       	call   21e900 <mergeInPlace>
  219969:	e9 c2 03 00 00       	jmp    219d30 <Benchmark_reportStats+0x4130>
  21996e:	66 90                	xchg   ax,ax
    if (B.length() > 0 and A.length() > 0) {
  219970:	4d 89 ef             	mov    r15,r13
  219973:	49 29 f7             	sub    r15,rsi
  219976:	0f 84 c0 fb ff ff    	je     21953c <Benchmark_reportStats+0x393c>
  21997c:	41 ba 00 00 00 00    	mov    r10d,0x0
  219982:	bf 00 00 00 00       	mov    edi,0x0
  219987:	4c 39 de             	cmp    rsi,r11
  21998a:	0f 84 16 02 00 00    	je     219ba6 <Benchmark_reportStats+0x3fa6>
  219990:	45 31 d2             	xor    r10d,r10d
  219993:	31 c9                	xor    ecx,ecx
  219995:	31 c0                	xor    eax,eax
  219997:	4c 89 9c 24 48 01 00 	mov    QWORD PTR [rsp+0x148],r11
  21999e:	00 
  21999f:	48 89 74 24 68       	mov    QWORD PTR [rsp+0x68],rsi
  2199a4:	48 8b 54 24 60       	mov    rdx,QWORD PTR [rsp+0x60]
  2199a9:	4d 8d 04 12          	lea    r8,[r10+rdx*1]
            if (!lessThan(items[B.start + B_count], items[buffer.start + A_count])) {
  2199ad:	48 8d 1c 0e          	lea    rbx,[rsi+rcx*1]
  2199b1:	48 c1 e3 04          	shl    rbx,0x4
  2199b5:	49 8d 14 03          	lea    rdx,[r11+rax*1]
  2199b9:	48 c1 e2 04          	shl    rdx,0x4
  2199bd:	48 89 c7             	mov    rdi,rax
  2199c0:	48 8b 44 24 40       	mov    rax,QWORD PTR [rsp+0x40]
  2199c5:	4c 89 c6             	mov    rsi,r8
  2199c8:	48 c1 e6 04          	shl    rsi,0x4
  2199cc:	4c 8b 1c 18          	mov    r11,QWORD PTR [rax+rbx*1]
  2199d0:	4c 3b 1c 30          	cmp    r11,QWORD PTR [rax+rsi*1]
  2199d4:	73 3a                	jae    219a10 <Benchmark_reportStats+0x3e10>
    const tmp = a.*;
  2199d6:	c5 f8 10 04 10       	vmovups xmm0,XMMWORD PTR [rax+rdx*1]
  2199db:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  2199e0:	c5 f8 10 04 18       	vmovups xmm0,XMMWORD PTR [rax+rbx*1]
  2199e5:	c5 f8 11 04 10       	vmovups XMMWORD PTR [rax+rdx*1],xmm0
    b.* = tmp;
  2199ea:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  2199ef:	c5 fa 7f 04 18       	vmovdqu XMMWORD PTR [rax+rbx*1],xmm0
                B_count += 1;
  2199f4:	48 83 c1 01          	add    rcx,0x1
                insert += 1;
  2199f8:	48 83 c7 01          	add    rdi,0x1
                if (B_count >= B.length()) break;
  2199fc:	48 83 c3 10          	add    rbx,0x10
  219a00:	48 83 c2 10          	add    rdx,0x10
  219a04:	4c 39 f9             	cmp    rcx,r15
  219a07:	72 b7                	jb     2199c0 <Benchmark_reportStats+0x3dc0>
  219a09:	e9 8b 01 00 00       	jmp    219b99 <Benchmark_reportStats+0x3f99>
  219a0e:	66 90                	xchg   ax,ax
    const tmp = a.*;
  219a10:	c5 f8 10 04 10       	vmovups xmm0,XMMWORD PTR [rax+rdx*1]
  219a15:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
  219a1a:	48 01 c6             	add    rsi,rax
    a.* = b.*;
  219a1d:	c5 f8 10 06          	vmovups xmm0,XMMWORD PTR [rsi]
  219a21:	c5 f8 11 04 10       	vmovups XMMWORD PTR [rax+rdx*1],xmm0
    b.* = tmp;
  219a26:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  219a2b:	c5 fa 7f 06          	vmovdqu XMMWORD PTR [rsi],xmm0
                A_count += 1;
  219a2f:	49 83 c2 01          	add    r10,0x1
                if (A_count >= A.length()) break;
  219a33:	48 8d 47 01          	lea    rax,[rdi+0x1]
  219a37:	4d 39 ca             	cmp    r10,r9
  219a3a:	4c 8b 9c 24 48 01 00 	mov    r11,QWORD PTR [rsp+0x148]
  219a41:	00 
  219a42:	48 8b 74 24 68       	mov    rsi,QWORD PTR [rsp+0x68]
  219a47:	0f 82 57 ff ff ff    	jb     2199a4 <Benchmark_reportStats+0x3da4>
    blockSwap(T, items, buffer.start + A_count, A.start + insert, A.length() - A_count);
  219a4d:	48 83 c7 01          	add    rdi,0x1
    while (index < block_size) : (index += 1) {
  219a51:	4d 29 d1             	sub    r9,r10
  219a54:	0f 85 55 01 00 00    	jne    219baf <Benchmark_reportStats+0x3faf>
  219a5a:	e9 d1 02 00 00       	jmp    219d30 <Benchmark_reportStats+0x4130>
  219a5f:	90                   	nop
    mem.copy(T, items[insert_index..], cache[A_index..A_last]);
  219a60:	49 29 d0             	sub    r8,rdx
  219a63:	4d 89 cf             	mov    r15,r9
  219a66:	48 8b 74 24 68       	mov    rsi,QWORD PTR [rsp+0x68]
  219a6b:	eb 03                	jmp    219a70 <Benchmark_reportStats+0x3e70>
  219a6d:	45 31 ff             	xor    r15d,r15d
  219a70:	48 8b 44 24 48       	mov    rax,QWORD PTR [rsp+0x48]
  219a75:	4c 29 c0             	sub    rax,r8
  219a78:	4d 29 f9             	sub    r9,r15
    assert(dest.len >= source.len);
  219a7b:	4c 39 c8             	cmp    rax,r9
  219a7e:	0f 82 e8 4c 00 00    	jb     21e76c <Benchmark_reportStats+0x8b6c>
    for (source) |s, i|
  219a84:	4d 85 c9             	test   r9,r9
  219a87:	0f 84 a3 02 00 00    	je     219d30 <Benchmark_reportStats+0x4130>
  219a8d:	48 8b 44 24 40       	mov    rax,QWORD PTR [rsp+0x40]
  219a92:	48 83 c6 ff          	add    rsi,0xffffffffffffffff
  219a96:	4c 29 fe             	sub    rsi,r15
  219a99:	4c 29 de             	sub    rsi,r11
  219a9c:	44 89 c9             	mov    ecx,r9d
  219a9f:	83 e1 07             	and    ecx,0x7
  219aa2:	48 83 fe 07          	cmp    rsi,0x7
  219aa6:	73 10                	jae    219ab8 <Benchmark_reportStats+0x3eb8>
  219aa8:	31 d2                	xor    edx,edx
  219aaa:	48 85 c9             	test   rcx,rcx
  219aad:	0f 85 a1 00 00 00    	jne    219b54 <Benchmark_reportStats+0x3f54>
  219ab3:	e9 78 02 00 00       	jmp    219d30 <Benchmark_reportStats+0x4130>
  219ab8:	4c 89 c7             	mov    rdi,r8
  219abb:	48 c1 e7 04          	shl    rdi,0x4
  219abf:	48 01 c7             	add    rdi,rax
  219ac2:	49 29 c9             	sub    r9,rcx
  219ac5:	4c 89 fa             	mov    rdx,r15
  219ac8:	48 c1 e2 04          	shl    rdx,0x4
  219acc:	48 8d 34 14          	lea    rsi,[rsp+rdx*1]
  219ad0:	48 81 c6 28 02 00 00 	add    rsi,0x228
  219ad7:	bb 70 00 00 00       	mov    ebx,0x70
  219adc:	31 d2                	xor    edx,edx
  219ade:	66 90                	xchg   ax,ax
        dest[i] = s;
  219ae0:	c5 f8 10 44 1e 90    	vmovups xmm0,XMMWORD PTR [rsi+rbx*1-0x70]
  219ae6:	c5 f8 11 44 1f 90    	vmovups XMMWORD PTR [rdi+rbx*1-0x70],xmm0
  219aec:	c5 f8 10 44 1e a0    	vmovups xmm0,XMMWORD PTR [rsi+rbx*1-0x60]
  219af2:	c5 f8 11 44 1f a0    	vmovups XMMWORD PTR [rdi+rbx*1-0x60],xmm0
  219af8:	c5 f8 10 44 1e b0    	vmovups xmm0,XMMWORD PTR [rsi+rbx*1-0x50]
  219afe:	c5 f8 11 44 1f b0    	vmovups XMMWORD PTR [rdi+rbx*1-0x50],xmm0
  219b04:	c5 f8 10 44 1e c0    	vmovups xmm0,XMMWORD PTR [rsi+rbx*1-0x40]
  219b0a:	c5 f8 11 44 1f c0    	vmovups XMMWORD PTR [rdi+rbx*1-0x40],xmm0
  219b10:	c5 f8 10 44 1e d0    	vmovups xmm0,XMMWORD PTR [rsi+rbx*1-0x30]
  219b16:	c5 f8 11 44 1f d0    	vmovups XMMWORD PTR [rdi+rbx*1-0x30],xmm0
  219b1c:	c5 f8 10 44 1e e0    	vmovups xmm0,XMMWORD PTR [rsi+rbx*1-0x20]
  219b22:	c5 f8 11 44 1f e0    	vmovups XMMWORD PTR [rdi+rbx*1-0x20],xmm0
  219b28:	c5 f8 10 44 1e f0    	vmovups xmm0,XMMWORD PTR [rsi+rbx*1-0x10]
  219b2e:	c5 f8 11 44 1f f0    	vmovups XMMWORD PTR [rdi+rbx*1-0x10],xmm0
  219b34:	c5 fa 6f 04 1e       	vmovdqu xmm0,XMMWORD PTR [rsi+rbx*1]
  219b39:	c5 fa 7f 04 1f       	vmovdqu XMMWORD PTR [rdi+rbx*1],xmm0
    for (source) |s, i|
  219b3e:	48 83 c2 08          	add    rdx,0x8
  219b42:	48 83 eb 80          	sub    rbx,0xffffffffffffff80
  219b46:	49 39 d1             	cmp    r9,rdx
  219b49:	75 95                	jne    219ae0 <Benchmark_reportStats+0x3ee0>
  219b4b:	48 85 c9             	test   rcx,rcx
  219b4e:	0f 84 dc 01 00 00    	je     219d30 <Benchmark_reportStats+0x4130>
  219b54:	49 01 d0             	add    r8,rdx
  219b57:	49 c1 e0 04          	shl    r8,0x4
  219b5b:	4c 01 c0             	add    rax,r8
  219b5e:	49 01 d7             	add    r15,rdx
  219b61:	49 c1 e7 04          	shl    r15,0x4
  219b65:	4a 8d 14 3c          	lea    rdx,[rsp+r15*1]
  219b69:	48 81 c2 28 02 00 00 	add    rdx,0x228
  219b70:	48 f7 d9             	neg    rcx
  219b73:	31 f6                	xor    esi,esi
  219b75:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  219b7c:	00 00 00 00 
        dest[i] = s;
  219b80:	c5 fa 6f 04 32       	vmovdqu xmm0,XMMWORD PTR [rdx+rsi*1]
  219b85:	c5 fa 7f 04 30       	vmovdqu XMMWORD PTR [rax+rsi*1],xmm0
    for (source) |s, i|
  219b8a:	48 83 c6 10          	add    rsi,0x10
  219b8e:	48 83 c1 01          	add    rcx,0x1
  219b92:	75 ec                	jne    219b80 <Benchmark_reportStats+0x3f80>
  219b94:	e9 97 01 00 00       	jmp    219d30 <Benchmark_reportStats+0x4130>
  219b99:	4c 8b 9c 24 48 01 00 	mov    r11,QWORD PTR [rsp+0x148]
  219ba0:	00 
  219ba1:	48 8b 74 24 68       	mov    rsi,QWORD PTR [rsp+0x68]
    while (index < block_size) : (index += 1) {
  219ba6:	4d 29 d1             	sub    r9,r10
  219ba9:	0f 84 81 01 00 00    	je     219d30 <Benchmark_reportStats+0x4130>
        mem.swap(T, &items[start1 + index], &items[start2 + index]);
  219baf:	48 83 c6 ff          	add    rsi,0xffffffffffffffff
  219bb3:	4c 29 d6             	sub    rsi,r10
  219bb6:	4c 29 de             	sub    rsi,r11
  219bb9:	44 89 c8             	mov    eax,r9d
  219bbc:	83 e0 03             	and    eax,0x3
  219bbf:	48 83 fe 03          	cmp    rsi,0x3
  219bc3:	73 13                	jae    219bd8 <Benchmark_reportStats+0x3fd8>
  219bc5:	4d 89 df             	mov    r15,r11
  219bc8:	31 db                	xor    ebx,ebx
    while (index < block_size) : (index += 1) {
  219bca:	48 85 c0             	test   rax,rax
  219bcd:	0f 85 f7 00 00 00    	jne    219cca <Benchmark_reportStats+0x40ca>
  219bd3:	e9 58 01 00 00       	jmp    219d30 <Benchmark_reportStats+0x4130>
        mem.swap(T, &items[start1 + index], &items[start2 + index]);
  219bd8:	49 29 c1             	sub    r9,rax
  219bdb:	4d 89 d0             	mov    r8,r10
  219bde:	49 c1 e0 04          	shl    r8,0x4
  219be2:	4c 03 84 24 18 01 00 	add    r8,QWORD PTR [rsp+0x118]
  219be9:	00 
  219bea:	48 89 fe             	mov    rsi,rdi
  219bed:	48 c1 e6 04          	shl    rsi,0x4
  219bf1:	4d 89 df             	mov    r15,r11
  219bf4:	49 c1 e3 04          	shl    r11,0x4
  219bf8:	49 01 f3             	add    r11,rsi
  219bfb:	31 f6                	xor    esi,esi
  219bfd:	31 db                	xor    ebx,ebx
  219bff:	90                   	nop
  219c00:	48 8b 4c 24 40       	mov    rcx,QWORD PTR [rsp+0x40]
    const tmp = a.*;
  219c05:	4a 8d 14 01          	lea    rdx,[rcx+r8*1]
  219c09:	c5 f8 10 04 16       	vmovups xmm0,XMMWORD PTR [rsi+rdx*1]
  219c0e:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  219c13:	4c 01 d9             	add    rcx,r11
  219c16:	c5 f8 10 04 0e       	vmovups xmm0,XMMWORD PTR [rsi+rcx*1]
  219c1b:	c5 f8 11 04 16       	vmovups XMMWORD PTR [rsi+rdx*1],xmm0
    b.* = tmp;
  219c20:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  219c25:	c5 f8 11 04 0e       	vmovups XMMWORD PTR [rsi+rcx*1],xmm0
  219c2a:	48 8b 4c 24 40       	mov    rcx,QWORD PTR [rsp+0x40]
    const tmp = a.*;
  219c2f:	4a 8d 14 01          	lea    rdx,[rcx+r8*1]
  219c33:	c5 f8 10 44 16 10    	vmovups xmm0,XMMWORD PTR [rsi+rdx*1+0x10]
  219c39:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  219c3e:	4c 01 d9             	add    rcx,r11
  219c41:	c5 f8 10 44 0e 10    	vmovups xmm0,XMMWORD PTR [rsi+rcx*1+0x10]
  219c47:	c5 f8 11 44 16 10    	vmovups XMMWORD PTR [rsi+rdx*1+0x10],xmm0
    b.* = tmp;
  219c4d:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  219c52:	c5 f8 11 44 0e 10    	vmovups XMMWORD PTR [rsi+rcx*1+0x10],xmm0
  219c58:	48 8b 4c 24 40       	mov    rcx,QWORD PTR [rsp+0x40]
    const tmp = a.*;
  219c5d:	4a 8d 14 01          	lea    rdx,[rcx+r8*1]
  219c61:	c5 f8 10 44 16 20    	vmovups xmm0,XMMWORD PTR [rsi+rdx*1+0x20]
  219c67:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  219c6c:	4c 01 d9             	add    rcx,r11
  219c6f:	c5 f8 10 44 0e 20    	vmovups xmm0,XMMWORD PTR [rsi+rcx*1+0x20]
  219c75:	c5 f8 11 44 16 20    	vmovups XMMWORD PTR [rsi+rdx*1+0x20],xmm0
    b.* = tmp;
  219c7b:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  219c80:	c5 f8 11 44 0e 20    	vmovups XMMWORD PTR [rsi+rcx*1+0x20],xmm0
  219c86:	48 8b 4c 24 40       	mov    rcx,QWORD PTR [rsp+0x40]
    const tmp = a.*;
  219c8b:	4a 8d 14 01          	lea    rdx,[rcx+r8*1]
  219c8f:	c5 f8 10 44 16 30    	vmovups xmm0,XMMWORD PTR [rsi+rdx*1+0x30]
  219c95:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  219c9a:	4c 01 d9             	add    rcx,r11
  219c9d:	c5 f8 10 44 0e 30    	vmovups xmm0,XMMWORD PTR [rsi+rcx*1+0x30]
  219ca3:	c5 f8 11 44 16 30    	vmovups XMMWORD PTR [rsi+rdx*1+0x30],xmm0
    b.* = tmp;
  219ca9:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  219cae:	c5 fa 7f 44 0e 30    	vmovdqu XMMWORD PTR [rsi+rcx*1+0x30],xmm0
    while (index < block_size) : (index += 1) {
  219cb4:	48 83 c3 04          	add    rbx,0x4
  219cb8:	48 83 c6 40          	add    rsi,0x40
  219cbc:	49 39 d9             	cmp    r9,rbx
  219cbf:	0f 85 3b ff ff ff    	jne    219c00 <Benchmark_reportStats+0x4000>
  219cc5:	48 85 c0             	test   rax,rax
  219cc8:	74 66                	je     219d30 <Benchmark_reportStats+0x4130>
  219cca:	48 01 df             	add    rdi,rbx
  219ccd:	4c 01 ff             	add    rdi,r15
  219cd0:	48 c1 e7 04          	shl    rdi,0x4
  219cd4:	4c 03 54 24 60       	add    r10,QWORD PTR [rsp+0x60]
  219cd9:	49 01 da             	add    r10,rbx
  219cdc:	49 c1 e2 04          	shl    r10,0x4
  219ce0:	48 f7 d8             	neg    rax
  219ce3:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  219cea:	84 00 00 00 00 00 
        mem.swap(T, &items[start1 + index], &items[start2 + index]);
  219cf0:	48 8b 4c 24 40       	mov    rcx,QWORD PTR [rsp+0x40]
    const tmp = a.*;
  219cf5:	c4 a1 78 10 04 11    	vmovups xmm0,XMMWORD PTR [rcx+r10*1]
  219cfb:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  219d00:	c5 f8 10 04 39       	vmovups xmm0,XMMWORD PTR [rcx+rdi*1]
  219d05:	c4 a1 78 11 04 11    	vmovups XMMWORD PTR [rcx+r10*1],xmm0
    b.* = tmp;
  219d0b:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  219d10:	c5 fa 7f 04 39       	vmovdqu XMMWORD PTR [rcx+rdi*1],xmm0
    while (index < block_size) : (index += 1) {
  219d15:	48 83 c7 10          	add    rdi,0x10
  219d19:	49 83 c2 10          	add    r10,0x10
  219d1d:	48 83 c0 01          	add    rax,0x1
  219d21:	75 cd                	jne    219cf0 <Benchmark_reportStats+0x40f0>
  219d23:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  219d2a:	84 00 00 00 00 00 
  219d30:	48 8b 5c 24 38       	mov    rbx,QWORD PTR [rsp+0x38]
  219d35:	49 89 df             	mov    r15,rbx
  219d38:	4d 29 ef             	sub    r15,r13
                                if (buffer2.length() > 0 or block_size <= cache.len) {
  219d3b:	80 7c 24 78 00       	cmp    BYTE PTR [rsp+0x78],0x0
  219d40:	74 3e                	je     219d80 <Benchmark_reportStats+0x4180>
  219d42:	48 81 7c 24 28 01 02 	cmp    QWORD PTR [rsp+0x28],0x201
  219d49:	00 00 
  219d4b:	4c 8b 54 24 18       	mov    r10,QWORD PTR [rsp+0x18]
                                    if (block_size <= cache.len) {
  219d50:	0f 83 8a 00 00 00    	jae    219de0 <Benchmark_reportStats+0x41e0>
                                        mem.copy(T, cache[0..], items[blockA.start .. blockA.start + block_size]);
  219d56:	4c 03 74 24 40       	add    r14,QWORD PTR [rsp+0x40]
  219d5b:	48 83 7c 24 58 07    	cmp    QWORD PTR [rsp+0x58],0x7
    for (source) |s, i|
  219d61:	0f 83 04 02 00 00    	jae    219f6b <Benchmark_reportStats+0x436b>
  219d67:	31 c0                	xor    eax,eax
  219d69:	48 83 bc 24 20 01 00 	cmp    QWORD PTR [rsp+0x120],0x0
  219d70:	00 00 
  219d72:	0f 85 b5 02 00 00    	jne    21a02d <Benchmark_reportStats+0x442d>
  219d78:	e9 3c 04 00 00       	jmp    21a1b9 <Benchmark_reportStats+0x45b9>
  219d7d:	0f 1f 00             	nop    DWORD PTR [rax]
  219d80:	4c 89 7c 24 38       	mov    QWORD PTR [rsp+0x38],r15
                                    mem.rotate(T, items[B_split .. blockA.start + block_size], blockA.start - B_split);
  219d85:	4c 8b 5c 24 40       	mov    r11,QWORD PTR [rsp+0x40]
  219d8a:	4c 89 ea             	mov    rdx,r13
  219d8d:	48 c1 e2 04          	shl    rdx,0x4
  219d91:	4d 8d 0c 13          	lea    r9,[r11+rdx*1]
  219d95:	4c 8b 54 24 18       	mov    r10,QWORD PTR [rsp+0x18]
  219d9a:	4d 89 d0             	mov    r8,r10
  219d9d:	4d 29 e8             	sub    r8,r13
  219da0:	4d 89 e7             	mov    r15,r12
  219da3:	4d 29 ef             	sub    r15,r13
    const end = items.len / 2;
  219da6:	4c 89 fb             	mov    rbx,r15
  219da9:	48 d1 eb             	shr    rbx,1
    while (i < end) : (i += 1) {
  219dac:	0f 84 77 01 00 00    	je     219f29 <Benchmark_reportStats+0x4329>
        swap(T, &items[i], &items[items.len - i - 1]);
  219db2:	48 8d 4b ff          	lea    rcx,[rbx-0x1]
  219db6:	89 d8                	mov    eax,ebx
  219db8:	83 e0 03             	and    eax,0x3
  219dbb:	48 83 f9 03          	cmp    rcx,0x3
  219dbf:	73 3e                	jae    219dff <Benchmark_reportStats+0x41ff>
  219dc1:	31 f6                	xor    esi,esi
    while (i < end) : (i += 1) {
  219dc3:	48 85 c0             	test   rax,rax
  219dc6:	0f 85 19 01 00 00    	jne    219ee5 <Benchmark_reportStats+0x42e5>
  219dcc:	e9 58 01 00 00       	jmp    219f29 <Benchmark_reportStats+0x4329>
  219dd1:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  219dd8:	0f 1f 84 00 00 00 00 
  219ddf:	00 
  219de0:	48 83 7c 24 58 03    	cmp    QWORD PTR [rsp+0x58],0x3
        mem.swap(T, &items[start1 + index], &items[start2 + index]);
  219de6:	0f 83 88 02 00 00    	jae    21a074 <Benchmark_reportStats+0x4474>
  219dec:	31 c0                	xor    eax,eax
  219dee:	48 83 7c 24 10 00    	cmp    QWORD PTR [rsp+0x10],0x0
    while (index < block_size) : (index += 1) {
  219df4:	0f 85 74 03 00 00    	jne    21a16e <Benchmark_reportStats+0x456e>
  219dfa:	e9 ba 03 00 00       	jmp    21a1b9 <Benchmark_reportStats+0x45b9>
        swap(T, &items[i], &items[items.len - i - 1]);
  219dff:	48 29 c3             	sub    rbx,rax
  219e02:	49 8d 0c 13          	lea    rcx,[r11+rdx*1]
  219e06:	48 83 c1 30          	add    rcx,0x30
  219e0a:	31 f6                	xor    esi,esi
  219e0c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  219e10:	48 89 f7             	mov    rdi,rsi
  219e13:	48 f7 d7             	not    rdi
  219e16:	4c 01 ff             	add    rdi,r15
  219e19:	48 c1 e7 04          	shl    rdi,0x4
    const tmp = a.*;
  219e1d:	c5 f8 10 41 d0       	vmovups xmm0,XMMWORD PTR [rcx-0x30]
  219e22:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  219e27:	c4 c1 78 10 04 39    	vmovups xmm0,XMMWORD PTR [r9+rdi*1]
  219e2d:	c5 f8 11 41 d0       	vmovups XMMWORD PTR [rcx-0x30],xmm0
    b.* = tmp;
  219e32:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  219e37:	c4 c1 78 11 04 39    	vmovups XMMWORD PTR [r9+rdi*1],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  219e3d:	48 c7 c7 fe ff ff ff 	mov    rdi,0xfffffffffffffffe
  219e44:	48 29 f7             	sub    rdi,rsi
  219e47:	4c 01 ff             	add    rdi,r15
    const tmp = a.*;
  219e4a:	c5 f8 10 41 e0       	vmovups xmm0,XMMWORD PTR [rcx-0x20]
  219e4f:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  219e54:	48 c1 e7 04          	shl    rdi,0x4
    a.* = b.*;
  219e58:	c4 c1 78 10 04 39    	vmovups xmm0,XMMWORD PTR [r9+rdi*1]
  219e5e:	c5 f8 11 41 e0       	vmovups XMMWORD PTR [rcx-0x20],xmm0
    b.* = tmp;
  219e63:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  219e68:	c4 c1 78 11 04 39    	vmovups XMMWORD PTR [r9+rdi*1],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  219e6e:	48 c7 c7 fd ff ff ff 	mov    rdi,0xfffffffffffffffd
  219e75:	48 29 f7             	sub    rdi,rsi
  219e78:	4c 01 ff             	add    rdi,r15
  219e7b:	48 c1 e7 04          	shl    rdi,0x4
    const tmp = a.*;
  219e7f:	c5 f8 10 41 f0       	vmovups xmm0,XMMWORD PTR [rcx-0x10]
  219e84:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  219e89:	c4 c1 78 10 04 39    	vmovups xmm0,XMMWORD PTR [r9+rdi*1]
  219e8f:	c5 f8 11 41 f0       	vmovups XMMWORD PTR [rcx-0x10],xmm0
    b.* = tmp;
  219e94:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  219e99:	c4 c1 78 11 04 39    	vmovups XMMWORD PTR [r9+rdi*1],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  219e9f:	48 c7 c7 fc ff ff ff 	mov    rdi,0xfffffffffffffffc
  219ea6:	48 29 f7             	sub    rdi,rsi
  219ea9:	4c 01 ff             	add    rdi,r15
    const tmp = a.*;
  219eac:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  219eb0:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  219eb5:	48 c1 e7 04          	shl    rdi,0x4
    a.* = b.*;
  219eb9:	c4 c1 78 10 04 39    	vmovups xmm0,XMMWORD PTR [r9+rdi*1]
  219ebf:	c5 f8 11 01          	vmovups XMMWORD PTR [rcx],xmm0
    b.* = tmp;
  219ec3:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  219ec8:	c4 c1 7a 7f 04 39    	vmovdqu XMMWORD PTR [r9+rdi*1],xmm0
    while (i < end) : (i += 1) {
  219ece:	48 83 c6 04          	add    rsi,0x4
  219ed2:	48 83 c1 40          	add    rcx,0x40
  219ed6:	48 83 c3 fc          	add    rbx,0xfffffffffffffffc
  219eda:	0f 85 30 ff ff ff    	jne    219e10 <Benchmark_reportStats+0x4210>
  219ee0:	48 85 c0             	test   rax,rax
  219ee3:	74 44                	je     219f29 <Benchmark_reportStats+0x4329>
  219ee5:	4a 8d 0c 2e          	lea    rcx,[rsi+r13*1]
  219ee9:	48 c1 e1 04          	shl    rcx,0x4
  219eed:	4c 01 d9             	add    rcx,r11
        swap(T, &items[i], &items[items.len - i - 1]);
  219ef0:	48 89 f7             	mov    rdi,rsi
  219ef3:	48 f7 d7             	not    rdi
  219ef6:	4c 01 ff             	add    rdi,r15
    const tmp = a.*;
  219ef9:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  219efd:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  219f02:	48 c1 e7 04          	shl    rdi,0x4
    a.* = b.*;
  219f06:	c4 c1 78 10 04 39    	vmovups xmm0,XMMWORD PTR [r9+rdi*1]
  219f0c:	c5 f8 11 01          	vmovups XMMWORD PTR [rcx],xmm0
    b.* = tmp;
  219f10:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  219f15:	c4 c1 7a 7f 04 39    	vmovdqu XMMWORD PTR [r9+rdi*1],xmm0
    while (i < end) : (i += 1) {
  219f1b:	48 83 c6 01          	add    rsi,0x1
  219f1f:	48 83 c1 10          	add    rcx,0x10
  219f23:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  219f27:	75 c7                	jne    219ef0 <Benchmark_reportStats+0x42f0>
  219f29:	48 89 54 24 68       	mov    QWORD PTR [rsp+0x68],rdx
    reverse(T, items[amount..]);
  219f2e:	4d 89 c2             	mov    r10,r8
  219f31:	4d 29 fa             	sub    r10,r15
    while (i < end) : (i += 1) {
  219f34:	49 83 fa 02          	cmp    r10,0x2
  219f38:	4c 8b 7c 24 38       	mov    r15,QWORD PTR [rsp+0x38]
  219f3d:	0f 82 5d 05 00 00    	jb     21a4a0 <Benchmark_reportStats+0x48a0>
  219f43:	4d 01 de             	add    r14,r11
  219f46:	48 83 bc 24 70 01 00 	cmp    QWORD PTR [rsp+0x170],0x3
  219f4d:	00 03 
        swap(T, &items[i], &items[items.len - i - 1]);
  219f4f:	0f 83 eb 03 00 00    	jae    21a340 <Benchmark_reportStats+0x4740>
  219f55:	31 ff                	xor    edi,edi
  219f57:	48 83 bc 24 40 01 00 	cmp    QWORD PTR [rsp+0x140],0x0
  219f5e:	00 00 
    while (i < end) : (i += 1) {
  219f60:	0f 85 e4 04 00 00    	jne    21a44a <Benchmark_reportStats+0x484a>
  219f66:	e9 35 05 00 00       	jmp    21a4a0 <Benchmark_reportStats+0x48a0>
  219f6b:	48 8d 8c 24 98 02 00 	lea    rcx,[rsp+0x298]
  219f72:	00 
  219f73:	31 c0                	xor    eax,eax
  219f75:	48 8b 94 24 60 01 00 	mov    rdx,QWORD PTR [rsp+0x160]
  219f7c:	00 
  219f7d:	0f 1f 00             	nop    DWORD PTR [rax]
    for (source) |s, i|
  219f80:	48 89 c6             	mov    rsi,rax
  219f83:	48 c1 e6 04          	shl    rsi,0x4
        dest[i] = s;
  219f87:	c4 c1 78 10 04 36    	vmovups xmm0,XMMWORD PTR [r14+rsi*1]
  219f8d:	c5 f8 11 41 90       	vmovups XMMWORD PTR [rcx-0x70],xmm0
    for (source) |s, i|
  219f92:	48 89 f7             	mov    rdi,rsi
  219f95:	48 83 cf 10          	or     rdi,0x10
        dest[i] = s;
  219f99:	c4 c1 78 10 04 3e    	vmovups xmm0,XMMWORD PTR [r14+rdi*1]
  219f9f:	c5 f8 11 41 a0       	vmovups XMMWORD PTR [rcx-0x60],xmm0
    for (source) |s, i|
  219fa4:	48 89 f7             	mov    rdi,rsi
  219fa7:	48 83 cf 20          	or     rdi,0x20
        dest[i] = s;
  219fab:	c4 c1 78 10 04 3e    	vmovups xmm0,XMMWORD PTR [r14+rdi*1]
  219fb1:	c5 f8 11 41 b0       	vmovups XMMWORD PTR [rcx-0x50],xmm0
    for (source) |s, i|
  219fb6:	48 89 f7             	mov    rdi,rsi
  219fb9:	48 83 cf 30          	or     rdi,0x30
        dest[i] = s;
  219fbd:	c4 c1 78 10 04 3e    	vmovups xmm0,XMMWORD PTR [r14+rdi*1]
  219fc3:	c5 f8 11 41 c0       	vmovups XMMWORD PTR [rcx-0x40],xmm0
    for (source) |s, i|
  219fc8:	48 89 f7             	mov    rdi,rsi
  219fcb:	48 83 cf 40          	or     rdi,0x40
        dest[i] = s;
  219fcf:	c4 c1 78 10 04 3e    	vmovups xmm0,XMMWORD PTR [r14+rdi*1]
  219fd5:	c5 f8 11 41 d0       	vmovups XMMWORD PTR [rcx-0x30],xmm0
    for (source) |s, i|
  219fda:	48 89 f7             	mov    rdi,rsi
  219fdd:	48 83 cf 50          	or     rdi,0x50
        dest[i] = s;
  219fe1:	c4 c1 78 10 04 3e    	vmovups xmm0,XMMWORD PTR [r14+rdi*1]
  219fe7:	c5 f8 11 41 e0       	vmovups XMMWORD PTR [rcx-0x20],xmm0
    for (source) |s, i|
  219fec:	48 89 f7             	mov    rdi,rsi
  219fef:	48 83 cf 60          	or     rdi,0x60
        dest[i] = s;
  219ff3:	c4 c1 78 10 04 3e    	vmovups xmm0,XMMWORD PTR [r14+rdi*1]
  219ff9:	c5 f8 11 41 f0       	vmovups XMMWORD PTR [rcx-0x10],xmm0
    for (source) |s, i|
  219ffe:	48 83 ce 70          	or     rsi,0x70
        dest[i] = s;
  21a002:	c4 c1 7a 6f 04 36    	vmovdqu xmm0,XMMWORD PTR [r14+rsi*1]
  21a008:	c5 fa 7f 01          	vmovdqu XMMWORD PTR [rcx],xmm0
    for (source) |s, i|
  21a00c:	48 83 c0 08          	add    rax,0x8
  21a010:	48 83 e9 80          	sub    rcx,0xffffffffffffff80
  21a014:	48 83 c2 f8          	add    rdx,0xfffffffffffffff8
  21a018:	0f 85 62 ff ff ff    	jne    219f80 <Benchmark_reportStats+0x4380>
  21a01e:	48 83 bc 24 20 01 00 	cmp    QWORD PTR [rsp+0x120],0x0
  21a025:	00 00 
  21a027:	0f 84 8c 01 00 00    	je     21a1b9 <Benchmark_reportStats+0x45b9>
  21a02d:	48 89 c1             	mov    rcx,rax
  21a030:	48 c1 e1 04          	shl    rcx,0x4
  21a034:	48 01 e1             	add    rcx,rsp
  21a037:	48 81 c1 28 02 00 00 	add    rcx,0x228
  21a03e:	48 8b 94 24 20 01 00 	mov    rdx,QWORD PTR [rsp+0x120]
  21a045:	00 
  21a046:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  21a04d:	00 00 00 
  21a050:	48 89 c6             	mov    rsi,rax
  21a053:	48 c1 e6 04          	shl    rsi,0x4
        dest[i] = s;
  21a057:	c4 c1 7a 6f 04 36    	vmovdqu xmm0,XMMWORD PTR [r14+rsi*1]
  21a05d:	c5 fa 7f 01          	vmovdqu XMMWORD PTR [rcx],xmm0
    for (source) |s, i|
  21a061:	48 83 c0 01          	add    rax,0x1
  21a065:	48 83 c1 10          	add    rcx,0x10
  21a069:	48 83 c2 ff          	add    rdx,0xffffffffffffffff
  21a06d:	75 e1                	jne    21a050 <Benchmark_reportStats+0x4450>
  21a06f:	e9 45 01 00 00       	jmp    21a1b9 <Benchmark_reportStats+0x45b9>
  21a074:	48 8b 8c 24 58 01 00 	mov    rcx,QWORD PTR [rsp+0x158]
  21a07b:	00 
  21a07c:	31 c0                	xor    eax,eax
  21a07e:	48 8b 94 24 10 01 00 	mov    rdx,QWORD PTR [rsp+0x110]
  21a085:	00 
  21a086:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  21a08d:	00 00 00 
        mem.swap(T, &items[start1 + index], &items[start2 + index]);
  21a090:	4a 8d 34 20          	lea    rsi,[rax+r12*1]
  21a094:	48 8b 7c 24 40       	mov    rdi,QWORD PTR [rsp+0x40]
  21a099:	48 c1 e6 04          	shl    rsi,0x4
    const tmp = a.*;
  21a09d:	c5 f8 10 04 37       	vmovups xmm0,XMMWORD PTR [rdi+rsi*1]
  21a0a2:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21a0a7:	c5 f8 10 44 0f e0    	vmovups xmm0,XMMWORD PTR [rdi+rcx*1-0x20]
  21a0ad:	c5 f8 11 04 37       	vmovups XMMWORD PTR [rdi+rsi*1],xmm0
    b.* = tmp;
  21a0b2:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  21a0b7:	c5 f8 11 44 0f e0    	vmovups XMMWORD PTR [rdi+rcx*1-0x20],xmm0
    while (index < block_size) : (index += 1) {
  21a0bd:	48 89 c6             	mov    rsi,rax
  21a0c0:	48 83 ce 01          	or     rsi,0x1
        mem.swap(T, &items[start1 + index], &items[start2 + index]);
  21a0c4:	4c 01 e6             	add    rsi,r12
  21a0c7:	48 8b 7c 24 40       	mov    rdi,QWORD PTR [rsp+0x40]
  21a0cc:	48 c1 e6 04          	shl    rsi,0x4
    const tmp = a.*;
  21a0d0:	c5 f8 10 04 37       	vmovups xmm0,XMMWORD PTR [rdi+rsi*1]
  21a0d5:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21a0da:	c5 f8 10 44 0f f0    	vmovups xmm0,XMMWORD PTR [rdi+rcx*1-0x10]
  21a0e0:	c5 f8 11 04 37       	vmovups XMMWORD PTR [rdi+rsi*1],xmm0
    b.* = tmp;
  21a0e5:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  21a0ea:	c5 f8 11 44 0f f0    	vmovups XMMWORD PTR [rdi+rcx*1-0x10],xmm0
    while (index < block_size) : (index += 1) {
  21a0f0:	48 89 c6             	mov    rsi,rax
  21a0f3:	48 83 ce 02          	or     rsi,0x2
        mem.swap(T, &items[start1 + index], &items[start2 + index]);
  21a0f7:	4c 01 e6             	add    rsi,r12
  21a0fa:	48 8b 7c 24 40       	mov    rdi,QWORD PTR [rsp+0x40]
  21a0ff:	48 c1 e6 04          	shl    rsi,0x4
    const tmp = a.*;
  21a103:	c5 f8 10 04 37       	vmovups xmm0,XMMWORD PTR [rdi+rsi*1]
  21a108:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21a10d:	c5 f8 10 04 0f       	vmovups xmm0,XMMWORD PTR [rdi+rcx*1]
  21a112:	c5 f8 11 04 37       	vmovups XMMWORD PTR [rdi+rsi*1],xmm0
    b.* = tmp;
  21a117:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  21a11c:	c5 f8 11 04 0f       	vmovups XMMWORD PTR [rdi+rcx*1],xmm0
    while (index < block_size) : (index += 1) {
  21a121:	48 89 c6             	mov    rsi,rax
  21a124:	48 83 ce 03          	or     rsi,0x3
        mem.swap(T, &items[start1 + index], &items[start2 + index]);
  21a128:	4c 01 e6             	add    rsi,r12
  21a12b:	48 8b 7c 24 40       	mov    rdi,QWORD PTR [rsp+0x40]
  21a130:	48 c1 e6 04          	shl    rsi,0x4
    const tmp = a.*;
  21a134:	c5 f8 10 04 37       	vmovups xmm0,XMMWORD PTR [rdi+rsi*1]
  21a139:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21a13e:	c5 f8 10 44 0f 10    	vmovups xmm0,XMMWORD PTR [rdi+rcx*1+0x10]
  21a144:	c5 f8 11 04 37       	vmovups XMMWORD PTR [rdi+rsi*1],xmm0
    b.* = tmp;
  21a149:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  21a14e:	c5 fa 7f 44 0f 10    	vmovdqu XMMWORD PTR [rdi+rcx*1+0x10],xmm0
    while (index < block_size) : (index += 1) {
  21a154:	48 83 c0 04          	add    rax,0x4
  21a158:	48 83 c1 40          	add    rcx,0x40
  21a15c:	48 83 c2 fc          	add    rdx,0xfffffffffffffffc
  21a160:	0f 85 2a ff ff ff    	jne    21a090 <Benchmark_reportStats+0x4490>
  21a166:	48 83 7c 24 10 00    	cmp    QWORD PTR [rsp+0x10],0x0
  21a16c:	74 4b                	je     21a1b9 <Benchmark_reportStats+0x45b9>
  21a16e:	48 8b 4c 24 60       	mov    rcx,QWORD PTR [rsp+0x60]
  21a173:	48 8d 0c 01          	lea    rcx,[rcx+rax*1]
  21a177:	48 c1 e1 04          	shl    rcx,0x4
  21a17b:	48 8b 54 24 10       	mov    rdx,QWORD PTR [rsp+0x10]
        mem.swap(T, &items[start1 + index], &items[start2 + index]);
  21a180:	4a 8d 34 20          	lea    rsi,[rax+r12*1]
  21a184:	48 8b 7c 24 40       	mov    rdi,QWORD PTR [rsp+0x40]
  21a189:	48 c1 e6 04          	shl    rsi,0x4
    const tmp = a.*;
  21a18d:	c5 f8 10 04 37       	vmovups xmm0,XMMWORD PTR [rdi+rsi*1]
  21a192:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21a197:	c5 f8 10 04 0f       	vmovups xmm0,XMMWORD PTR [rdi+rcx*1]
  21a19c:	c5 f8 11 04 37       	vmovups XMMWORD PTR [rdi+rsi*1],xmm0
    b.* = tmp;
  21a1a1:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  21a1a6:	c5 fa 7f 04 0f       	vmovdqu XMMWORD PTR [rdi+rcx*1],xmm0
    while (index < block_size) : (index += 1) {
  21a1ab:	48 83 c0 01          	add    rax,0x1
  21a1af:	48 83 c1 10          	add    rcx,0x10
  21a1b3:	48 83 c2 ff          	add    rdx,0xffffffffffffffff
  21a1b7:	75 c7                	jne    21a180 <Benchmark_reportStats+0x4580>
  21a1b9:	4d 85 ff             	test   r15,r15
  21a1bc:	4c 8b 74 24 28       	mov    r14,QWORD PTR [rsp+0x28]
  21a1c1:	0f 84 89 04 00 00    	je     21a650 <Benchmark_reportStats+0x4a50>
  21a1c7:	4c 89 d1             	mov    rcx,r10
  21a1ca:	4c 29 f9             	sub    rcx,r15
        mem.swap(T, &items[start1 + index], &items[start2 + index]);
  21a1cd:	48 83 c3 ff          	add    rbx,0xffffffffffffffff
  21a1d1:	4c 29 eb             	sub    rbx,r13
  21a1d4:	44 89 f8             	mov    eax,r15d
  21a1d7:	83 e0 03             	and    eax,0x3
  21a1da:	48 83 fb 03          	cmp    rbx,0x3
  21a1de:	73 10                	jae    21a1f0 <Benchmark_reportStats+0x45f0>
  21a1e0:	31 d2                	xor    edx,edx
    while (index < block_size) : (index += 1) {
  21a1e2:	48 85 c0             	test   rax,rax
  21a1e5:	0f 85 03 01 00 00    	jne    21a2ee <Benchmark_reportStats+0x46ee>
  21a1eb:	e9 60 04 00 00       	jmp    21a650 <Benchmark_reportStats+0x4a50>
        mem.swap(T, &items[start1 + index], &items[start2 + index]);
  21a1f0:	4d 89 f9             	mov    r9,r15
  21a1f3:	49 29 c1             	sub    r9,rax
  21a1f6:	4c 89 ef             	mov    rdi,r13
  21a1f9:	48 c1 e7 04          	shl    rdi,0x4
  21a1fd:	48 83 c7 20          	add    rdi,0x20
  21a201:	31 d2                	xor    edx,edx
  21a203:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21a20a:	84 00 00 00 00 00 
  21a210:	48 8b 5c 24 40       	mov    rbx,QWORD PTR [rsp+0x40]
  21a215:	48 8d 34 11          	lea    rsi,[rcx+rdx*1]
  21a219:	48 c1 e6 04          	shl    rsi,0x4
    const tmp = a.*;
  21a21d:	c5 f8 10 44 3b e0    	vmovups xmm0,XMMWORD PTR [rbx+rdi*1-0x20]
  21a223:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21a228:	c5 f8 10 04 33       	vmovups xmm0,XMMWORD PTR [rbx+rsi*1]
  21a22d:	c5 f8 11 44 3b e0    	vmovups XMMWORD PTR [rbx+rdi*1-0x20],xmm0
    b.* = tmp;
  21a233:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  21a238:	c5 f8 11 04 33       	vmovups XMMWORD PTR [rbx+rsi*1],xmm0
    while (index < block_size) : (index += 1) {
  21a23d:	48 89 d6             	mov    rsi,rdx
  21a240:	48 83 ce 01          	or     rsi,0x1
        mem.swap(T, &items[start1 + index], &items[start2 + index]);
  21a244:	48 8b 5c 24 40       	mov    rbx,QWORD PTR [rsp+0x40]
  21a249:	48 01 ce             	add    rsi,rcx
    const tmp = a.*;
  21a24c:	c5 f8 10 44 3b f0    	vmovups xmm0,XMMWORD PTR [rbx+rdi*1-0x10]
  21a252:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
  21a257:	48 c1 e6 04          	shl    rsi,0x4
    a.* = b.*;
  21a25b:	c5 f8 10 04 33       	vmovups xmm0,XMMWORD PTR [rbx+rsi*1]
  21a260:	c5 f8 11 44 3b f0    	vmovups XMMWORD PTR [rbx+rdi*1-0x10],xmm0
    b.* = tmp;
  21a266:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  21a26b:	c5 f8 11 04 33       	vmovups XMMWORD PTR [rbx+rsi*1],xmm0
    while (index < block_size) : (index += 1) {
  21a270:	48 89 d6             	mov    rsi,rdx
  21a273:	48 83 ce 02          	or     rsi,0x2
        mem.swap(T, &items[start1 + index], &items[start2 + index]);
  21a277:	48 8b 5c 24 40       	mov    rbx,QWORD PTR [rsp+0x40]
  21a27c:	48 01 ce             	add    rsi,rcx
  21a27f:	48 c1 e6 04          	shl    rsi,0x4
    const tmp = a.*;
  21a283:	c5 f8 10 04 3b       	vmovups xmm0,XMMWORD PTR [rbx+rdi*1]
  21a288:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21a28d:	c5 f8 10 04 33       	vmovups xmm0,XMMWORD PTR [rbx+rsi*1]
  21a292:	c5 f8 11 04 3b       	vmovups XMMWORD PTR [rbx+rdi*1],xmm0
    b.* = tmp;
  21a297:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  21a29c:	c5 f8 11 04 33       	vmovups XMMWORD PTR [rbx+rsi*1],xmm0
    while (index < block_size) : (index += 1) {
  21a2a1:	48 89 d6             	mov    rsi,rdx
  21a2a4:	48 83 ce 03          	or     rsi,0x3
        mem.swap(T, &items[start1 + index], &items[start2 + index]);
  21a2a8:	48 8b 5c 24 40       	mov    rbx,QWORD PTR [rsp+0x40]
  21a2ad:	48 01 ce             	add    rsi,rcx
    const tmp = a.*;
  21a2b0:	c5 f8 10 44 3b 10    	vmovups xmm0,XMMWORD PTR [rbx+rdi*1+0x10]
  21a2b6:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
  21a2bb:	48 c1 e6 04          	shl    rsi,0x4
    a.* = b.*;
  21a2bf:	c5 f8 10 04 33       	vmovups xmm0,XMMWORD PTR [rbx+rsi*1]
  21a2c4:	c5 f8 11 44 3b 10    	vmovups XMMWORD PTR [rbx+rdi*1+0x10],xmm0
    b.* = tmp;
  21a2ca:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  21a2cf:	c5 fa 7f 04 33       	vmovdqu XMMWORD PTR [rbx+rsi*1],xmm0
    while (index < block_size) : (index += 1) {
  21a2d4:	48 83 c2 04          	add    rdx,0x4
  21a2d8:	48 83 c7 40          	add    rdi,0x40
  21a2dc:	49 39 d1             	cmp    r9,rdx
  21a2df:	0f 85 2b ff ff ff    	jne    21a210 <Benchmark_reportStats+0x4610>
  21a2e5:	48 85 c0             	test   rax,rax
  21a2e8:	0f 84 62 03 00 00    	je     21a650 <Benchmark_reportStats+0x4a50>
  21a2ee:	49 01 d5             	add    r13,rdx
  21a2f1:	49 c1 e5 04          	shl    r13,0x4
  21a2f5:	48 f7 d8             	neg    rax
  21a2f8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  21a2ff:	00 
        mem.swap(T, &items[start1 + index], &items[start2 + index]);
  21a300:	48 8b 74 24 40       	mov    rsi,QWORD PTR [rsp+0x40]
  21a305:	48 8d 3c 11          	lea    rdi,[rcx+rdx*1]
    const tmp = a.*;
  21a309:	c4 a1 78 10 04 2e    	vmovups xmm0,XMMWORD PTR [rsi+r13*1]
  21a30f:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
  21a314:	48 c1 e7 04          	shl    rdi,0x4
    a.* = b.*;
  21a318:	c5 f8 10 04 3e       	vmovups xmm0,XMMWORD PTR [rsi+rdi*1]
  21a31d:	c4 a1 78 11 04 2e    	vmovups XMMWORD PTR [rsi+r13*1],xmm0
    b.* = tmp;
  21a323:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  21a328:	c5 fa 7f 04 3e       	vmovdqu XMMWORD PTR [rsi+rdi*1],xmm0
    while (index < block_size) : (index += 1) {
  21a32d:	48 83 c2 01          	add    rdx,0x1
  21a331:	49 83 c5 10          	add    r13,0x10
  21a335:	48 83 c0 01          	add    rax,0x1
  21a339:	75 c5                	jne    21a300 <Benchmark_reportStats+0x4700>
  21a33b:	e9 10 03 00 00       	jmp    21a650 <Benchmark_reportStats+0x4a50>
  21a340:	31 ff                	xor    edi,edi
  21a342:	48 8b 8c 24 68 01 00 	mov    rcx,QWORD PTR [rsp+0x168]
  21a349:	00 
  21a34a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
        swap(T, &items[i], &items[items.len - i - 1]);
  21a350:	48 89 fe             	mov    rsi,rdi
  21a353:	48 c1 e6 04          	shl    rsi,0x4
  21a357:	48 89 fb             	mov    rbx,rdi
  21a35a:	48 f7 d3             	not    rbx
  21a35d:	4c 01 d3             	add    rbx,r10
    const tmp = a.*;
  21a360:	c4 c1 78 10 04 36    	vmovups xmm0,XMMWORD PTR [r14+rsi*1]
  21a366:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  21a36b:	48 c1 e3 04          	shl    rbx,0x4
    a.* = b.*;
  21a36f:	c4 c1 78 10 04 1e    	vmovups xmm0,XMMWORD PTR [r14+rbx*1]
  21a375:	c4 c1 78 11 04 36    	vmovups XMMWORD PTR [r14+rsi*1],xmm0
    b.* = tmp;
  21a37b:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
        swap(T, &items[i], &items[items.len - i - 1]);
  21a380:	48 89 f0             	mov    rax,rsi
  21a383:	48 83 c8 10          	or     rax,0x10
  21a387:	48 c7 c2 fe ff ff ff 	mov    rdx,0xfffffffffffffffe
  21a38e:	48 29 fa             	sub    rdx,rdi
  21a391:	4c 01 d2             	add    rdx,r10
  21a394:	48 c1 e2 04          	shl    rdx,0x4
    b.* = tmp;
  21a398:	c4 c1 78 11 04 1e    	vmovups XMMWORD PTR [r14+rbx*1],xmm0
    const tmp = a.*;
  21a39e:	c4 c1 78 10 04 06    	vmovups xmm0,XMMWORD PTR [r14+rax*1]
  21a3a4:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21a3a9:	c4 c1 78 10 04 16    	vmovups xmm0,XMMWORD PTR [r14+rdx*1]
  21a3af:	c4 c1 78 11 04 06    	vmovups XMMWORD PTR [r14+rax*1],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  21a3b5:	48 89 f0             	mov    rax,rsi
  21a3b8:	48 83 c8 20          	or     rax,0x20
    b.* = tmp;
  21a3bc:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
        swap(T, &items[i], &items[items.len - i - 1]);
  21a3c1:	48 c7 c3 fd ff ff ff 	mov    rbx,0xfffffffffffffffd
  21a3c8:	48 29 fb             	sub    rbx,rdi
    b.* = tmp;
  21a3cb:	c4 c1 78 11 04 16    	vmovups XMMWORD PTR [r14+rdx*1],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  21a3d1:	4c 01 d3             	add    rbx,r10
    const tmp = a.*;
  21a3d4:	c4 c1 78 10 04 06    	vmovups xmm0,XMMWORD PTR [r14+rax*1]
  21a3da:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  21a3df:	48 c1 e3 04          	shl    rbx,0x4
    a.* = b.*;
  21a3e3:	c4 c1 78 10 04 1e    	vmovups xmm0,XMMWORD PTR [r14+rbx*1]
  21a3e9:	c4 c1 78 11 04 06    	vmovups XMMWORD PTR [r14+rax*1],xmm0
    b.* = tmp;
  21a3ef:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
        swap(T, &items[i], &items[items.len - i - 1]);
  21a3f4:	48 83 ce 30          	or     rsi,0x30
  21a3f8:	48 c7 c0 fc ff ff ff 	mov    rax,0xfffffffffffffffc
  21a3ff:	48 29 f8             	sub    rax,rdi
  21a402:	4c 01 d0             	add    rax,r10
    b.* = tmp;
  21a405:	c4 c1 78 11 04 1e    	vmovups XMMWORD PTR [r14+rbx*1],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  21a40b:	48 c1 e0 04          	shl    rax,0x4
    const tmp = a.*;
  21a40f:	c4 c1 78 10 04 36    	vmovups xmm0,XMMWORD PTR [r14+rsi*1]
  21a415:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21a41a:	c4 c1 78 10 04 06    	vmovups xmm0,XMMWORD PTR [r14+rax*1]
  21a420:	c4 c1 78 11 04 36    	vmovups XMMWORD PTR [r14+rsi*1],xmm0
    b.* = tmp;
  21a426:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
    while (i < end) : (i += 1) {
  21a42b:	48 83 c7 04          	add    rdi,0x4
  21a42f:	48 83 c1 fc          	add    rcx,0xfffffffffffffffc
    b.* = tmp;
  21a433:	c4 c1 7a 7f 04 06    	vmovdqu XMMWORD PTR [r14+rax*1],xmm0
    while (i < end) : (i += 1) {
  21a439:	0f 85 11 ff ff ff    	jne    21a350 <Benchmark_reportStats+0x4750>
  21a43f:	48 83 bc 24 40 01 00 	cmp    QWORD PTR [rsp+0x140],0x0
  21a446:	00 00 
  21a448:	74 56                	je     21a4a0 <Benchmark_reportStats+0x48a0>
  21a44a:	48 8b 8c 24 40 01 00 	mov    rcx,QWORD PTR [rsp+0x140]
  21a451:	00 
  21a452:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21a459:	1f 84 00 00 00 00 00 
        swap(T, &items[i], &items[items.len - i - 1]);
  21a460:	48 89 f8             	mov    rax,rdi
  21a463:	48 c1 e0 04          	shl    rax,0x4
  21a467:	48 89 fa             	mov    rdx,rdi
  21a46a:	48 f7 d2             	not    rdx
  21a46d:	4c 01 d2             	add    rdx,r10
  21a470:	48 c1 e2 04          	shl    rdx,0x4
    const tmp = a.*;
  21a474:	c4 c1 78 10 04 06    	vmovups xmm0,XMMWORD PTR [r14+rax*1]
  21a47a:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21a47f:	c4 c1 78 10 04 16    	vmovups xmm0,XMMWORD PTR [r14+rdx*1]
  21a485:	c4 c1 78 11 04 06    	vmovups XMMWORD PTR [r14+rax*1],xmm0
    b.* = tmp;
  21a48b:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  21a490:	c4 c1 7a 7f 04 16    	vmovdqu XMMWORD PTR [r14+rdx*1],xmm0
    while (i < end) : (i += 1) {
  21a496:	48 83 c7 01          	add    rdi,0x1
  21a49a:	48 83 c1 ff          	add    rcx,0xffffffffffffffff
  21a49e:	75 c0                	jne    21a460 <Benchmark_reportStats+0x4860>
    const end = items.len / 2;
  21a4a0:	4c 89 c0             	mov    rax,r8
  21a4a3:	48 d1 e8             	shr    rax,1
  21a4a6:	4c 8b 74 24 28       	mov    r14,QWORD PTR [rsp+0x28]
  21a4ab:	4c 8b 54 24 18       	mov    r10,QWORD PTR [rsp+0x18]
    while (i < end) : (i += 1) {
  21a4b0:	0f 84 9a 01 00 00    	je     21a650 <Benchmark_reportStats+0x4a50>
        swap(T, &items[i], &items[items.len - i - 1]);
  21a4b6:	4c 89 c1             	mov    rcx,r8
    const tmp = a.*;
  21a4b9:	c4 c1 78 10 01       	vmovups xmm0,XMMWORD PTR [r9]
  21a4be:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  21a4c3:	48 c1 e1 04          	shl    rcx,0x4
    a.* = b.*;
  21a4c7:	c4 c1 78 10 44 09 f0 	vmovups xmm0,XMMWORD PTR [r9+rcx*1-0x10]
  21a4ce:	c4 c1 78 11 01       	vmovups XMMWORD PTR [r9],xmm0
    b.* = tmp;
  21a4d3:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  21a4d8:	c4 c1 7a 7f 44 09 f0 	vmovdqu XMMWORD PTR [r9+rcx*1-0x10],xmm0
    while (i < end) : (i += 1) {
  21a4df:	48 83 f8 01          	cmp    rax,0x1
  21a4e3:	0f 84 67 01 00 00    	je     21a650 <Benchmark_reportStats+0x4a50>
        swap(T, &items[i], &items[items.len - i - 1]);
  21a4e9:	48 8d 70 ff          	lea    rsi,[rax-0x1]
  21a4ed:	48 83 c0 fe          	add    rax,0xfffffffffffffffe
  21a4f1:	89 f3                	mov    ebx,esi
  21a4f3:	83 e3 03             	and    ebx,0x3
  21a4f6:	48 83 f8 03          	cmp    rax,0x3
  21a4fa:	73 13                	jae    21a50f <Benchmark_reportStats+0x490f>
  21a4fc:	b8 01 00 00 00       	mov    eax,0x1
    while (i < end) : (i += 1) {
  21a501:	48 85 db             	test   rbx,rbx
  21a504:	0f 85 fb 00 00 00    	jne    21a605 <Benchmark_reportStats+0x4a05>
  21a50a:	e9 41 01 00 00       	jmp    21a650 <Benchmark_reportStats+0x4a50>
        swap(T, &items[i], &items[items.len - i - 1]);
  21a50f:	48 29 de             	sub    rsi,rbx
  21a512:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  21a517:	49 8d 0c 03          	lea    rcx,[r11+rax*1]
  21a51b:	48 83 c1 40          	add    rcx,0x40
  21a51f:	b8 01 00 00 00       	mov    eax,0x1
  21a524:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21a52b:	00 00 00 00 00 
  21a530:	48 89 c2             	mov    rdx,rax
  21a533:	48 f7 d2             	not    rdx
  21a536:	4c 01 c2             	add    rdx,r8
  21a539:	48 c1 e2 04          	shl    rdx,0x4
    const tmp = a.*;
  21a53d:	c5 f8 10 41 d0       	vmovups xmm0,XMMWORD PTR [rcx-0x30]
  21a542:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21a547:	c4 c1 78 10 04 11    	vmovups xmm0,XMMWORD PTR [r9+rdx*1]
  21a54d:	c5 f8 11 41 d0       	vmovups XMMWORD PTR [rcx-0x30],xmm0
    b.* = tmp;
  21a552:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  21a557:	c4 c1 78 11 04 11    	vmovups XMMWORD PTR [r9+rdx*1],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  21a55d:	48 c7 c2 fe ff ff ff 	mov    rdx,0xfffffffffffffffe
  21a564:	48 29 c2             	sub    rdx,rax
  21a567:	4c 01 c2             	add    rdx,r8
    const tmp = a.*;
  21a56a:	c5 f8 10 41 e0       	vmovups xmm0,XMMWORD PTR [rcx-0x20]
  21a56f:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  21a574:	48 c1 e2 04          	shl    rdx,0x4
    a.* = b.*;
  21a578:	c4 c1 78 10 04 11    	vmovups xmm0,XMMWORD PTR [r9+rdx*1]
  21a57e:	c5 f8 11 41 e0       	vmovups XMMWORD PTR [rcx-0x20],xmm0
    b.* = tmp;
  21a583:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  21a588:	c4 c1 78 11 04 11    	vmovups XMMWORD PTR [r9+rdx*1],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  21a58e:	48 c7 c2 fd ff ff ff 	mov    rdx,0xfffffffffffffffd
  21a595:	48 29 c2             	sub    rdx,rax
  21a598:	4c 01 c2             	add    rdx,r8
  21a59b:	48 c1 e2 04          	shl    rdx,0x4
    const tmp = a.*;
  21a59f:	c5 f8 10 41 f0       	vmovups xmm0,XMMWORD PTR [rcx-0x10]
  21a5a4:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21a5a9:	c4 c1 78 10 04 11    	vmovups xmm0,XMMWORD PTR [r9+rdx*1]
  21a5af:	c5 f8 11 41 f0       	vmovups XMMWORD PTR [rcx-0x10],xmm0
    b.* = tmp;
  21a5b4:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  21a5b9:	c4 c1 78 11 04 11    	vmovups XMMWORD PTR [r9+rdx*1],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  21a5bf:	48 c7 c2 fc ff ff ff 	mov    rdx,0xfffffffffffffffc
  21a5c6:	48 29 c2             	sub    rdx,rax
  21a5c9:	4c 01 c2             	add    rdx,r8
    const tmp = a.*;
  21a5cc:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  21a5d0:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  21a5d5:	48 c1 e2 04          	shl    rdx,0x4
    a.* = b.*;
  21a5d9:	c4 c1 78 10 04 11    	vmovups xmm0,XMMWORD PTR [r9+rdx*1]
  21a5df:	c5 f8 11 01          	vmovups XMMWORD PTR [rcx],xmm0
    b.* = tmp;
  21a5e3:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  21a5e8:	c4 c1 7a 7f 04 11    	vmovdqu XMMWORD PTR [r9+rdx*1],xmm0
    while (i < end) : (i += 1) {
  21a5ee:	48 83 c0 04          	add    rax,0x4
  21a5f2:	48 83 c1 40          	add    rcx,0x40
  21a5f6:	48 83 c6 fc          	add    rsi,0xfffffffffffffffc
  21a5fa:	0f 85 30 ff ff ff    	jne    21a530 <Benchmark_reportStats+0x4930>
  21a600:	48 85 db             	test   rbx,rbx
  21a603:	74 4b                	je     21a650 <Benchmark_reportStats+0x4a50>
  21a605:	49 01 c5             	add    r13,rax
  21a608:	49 c1 e5 04          	shl    r13,0x4
  21a60c:	4d 01 eb             	add    r11,r13
  21a60f:	90                   	nop
        swap(T, &items[i], &items[items.len - i - 1]);
  21a610:	48 89 c1             	mov    rcx,rax
  21a613:	48 f7 d1             	not    rcx
  21a616:	4c 01 c1             	add    rcx,r8
    const tmp = a.*;
  21a619:	c4 c1 78 10 03       	vmovups xmm0,XMMWORD PTR [r11]
  21a61e:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  21a623:	48 c1 e1 04          	shl    rcx,0x4
    a.* = b.*;
  21a627:	c4 c1 78 10 04 09    	vmovups xmm0,XMMWORD PTR [r9+rcx*1]
  21a62d:	c4 c1 78 11 03       	vmovups XMMWORD PTR [r11],xmm0
    b.* = tmp;
  21a632:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  21a637:	c4 c1 7a 7f 04 09    	vmovdqu XMMWORD PTR [r9+rcx*1],xmm0
    while (i < end) : (i += 1) {
  21a63d:	48 83 c0 01          	add    rax,0x1
  21a641:	49 83 c3 10          	add    r11,0x10
  21a645:	48 83 c3 ff          	add    rbx,0xffffffffffffffff
  21a649:	75 c5                	jne    21a610 <Benchmark_reportStats+0x4a10>
  21a64b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  21a650:	48 8b 74 24 20       	mov    rsi,QWORD PTR [rsp+0x20]
  21a655:	48 83 c6 01          	add    rsi,0x1
                                lastA = Range.init(blockA.start - B_remaining, blockA.start - B_remaining + block_size);
  21a659:	4d 29 fc             	sub    r12,r15
  21a65c:	4c 89 a4 24 78 01 00 	mov    QWORD PTR [rsp+0x178],r12
  21a663:	00 
  21a664:	4f 8d 3c 34          	lea    r15,[r12+r14*1]
  21a668:	4c 89 bc 24 80 01 00 	mov    QWORD PTR [rsp+0x180],r15
  21a66f:	00 
  21a670:	4c 89 d3             	mov    rbx,r10
  21a673:	4c 8b 5c 24 30       	mov    r11,QWORD PTR [rsp+0x30]
                                if (blockA.length() == 0) break;
  21a678:	4d 39 d3             	cmp    r11,r10
  21a67b:	4c 8b 84 24 f8 00 00 	mov    r8,QWORD PTR [rsp+0xf8]
  21a682:	00 
  21a683:	48 8b bc 24 d0 00 00 	mov    rdi,QWORD PTR [rsp+0xd0]
  21a68a:	00 
  21a68b:	0f 85 bf ee ff ff    	jne    219550 <Benchmark_reportStats+0x3950>
  21a691:	e9 4c 06 00 00       	jmp    21ace2 <Benchmark_reportStats+0x50e2>
  21a696:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  21a69d:	00 00 00 
        return self.end - self.start;
  21a6a0:	4d 89 c2             	mov    r10,r8
  21a6a3:	49 29 fa             	sub    r10,rdi
                            } else if (blockB.length() < block_size) {
  21a6a6:	4c 3b 54 24 58       	cmp    r10,QWORD PTR [rsp+0x58]
  21a6ab:	0f 87 b9 04 00 00    	ja     21ab6a <Benchmark_reportStats+0x4f6a>
                                mem.rotate(T, items[blockA.start..blockB.end], blockB.start - blockA.start);
  21a6b1:	48 8b 44 24 40       	mov    rax,QWORD PTR [rsp+0x40]
  21a6b6:	4d 89 e5             	mov    r13,r12
  21a6b9:	49 c1 e5 04          	shl    r13,0x4
  21a6bd:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  21a6c2:	49 01 c5             	add    r13,rax
  21a6c5:	4d 29 e0             	sub    r8,r12
  21a6c8:	49 89 fe             	mov    r14,rdi
  21a6cb:	4d 29 e6             	sub    r14,r12
    const end = items.len / 2;
  21a6ce:	4d 89 f7             	mov    r15,r14
  21a6d1:	49 d1 ef             	shr    r15,1
    while (i < end) : (i += 1) {
  21a6d4:	0f 84 7a 01 00 00    	je     21a854 <Benchmark_reportStats+0x4c54>
        swap(T, &items[i], &items[items.len - i - 1]);
  21a6da:	49 8d 57 ff          	lea    rdx,[r15-0x1]
  21a6de:	45 89 fb             	mov    r11d,r15d
  21a6e1:	41 83 e3 03          	and    r11d,0x3
  21a6e5:	48 83 fa 03          	cmp    rdx,0x3
  21a6e9:	73 10                	jae    21a6fb <Benchmark_reportStats+0x4afb>
  21a6eb:	31 db                	xor    ebx,ebx
    while (i < end) : (i += 1) {
  21a6ed:	4d 85 db             	test   r11,r11
  21a6f0:	0f 85 1a 01 00 00    	jne    21a810 <Benchmark_reportStats+0x4c10>
  21a6f6:	e9 59 01 00 00       	jmp    21a854 <Benchmark_reportStats+0x4c54>
        swap(T, &items[i], &items[items.len - i - 1]);
  21a6fb:	4d 29 df             	sub    r15,r11
  21a6fe:	31 db                	xor    ebx,ebx
  21a700:	48 89 de             	mov    rsi,rbx
  21a703:	48 c1 e6 04          	shl    rsi,0x4
  21a707:	48 89 da             	mov    rdx,rbx
  21a70a:	48 f7 d2             	not    rdx
  21a70d:	4c 01 f2             	add    rdx,r14
    const tmp = a.*;
  21a710:	c4 c1 78 10 44 35 00 	vmovups xmm0,XMMWORD PTR [r13+rsi*1+0x0]
  21a717:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  21a71c:	48 c1 e2 04          	shl    rdx,0x4
    a.* = b.*;
  21a720:	c4 c1 78 10 44 15 00 	vmovups xmm0,XMMWORD PTR [r13+rdx*1+0x0]
  21a727:	c4 c1 78 11 44 35 00 	vmovups XMMWORD PTR [r13+rsi*1+0x0],xmm0
    b.* = tmp;
  21a72e:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
        swap(T, &items[i], &items[items.len - i - 1]);
  21a733:	48 89 f7             	mov    rdi,rsi
  21a736:	48 83 cf 10          	or     rdi,0x10
  21a73a:	48 c7 c0 fe ff ff ff 	mov    rax,0xfffffffffffffffe
  21a741:	48 29 d8             	sub    rax,rbx
  21a744:	4c 01 f0             	add    rax,r14
  21a747:	48 c1 e0 04          	shl    rax,0x4
    b.* = tmp;
  21a74b:	c4 c1 78 11 44 15 00 	vmovups XMMWORD PTR [r13+rdx*1+0x0],xmm0
    const tmp = a.*;
  21a752:	c4 c1 78 10 44 3d 00 	vmovups xmm0,XMMWORD PTR [r13+rdi*1+0x0]
  21a759:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21a75e:	c4 c1 78 10 44 05 00 	vmovups xmm0,XMMWORD PTR [r13+rax*1+0x0]
  21a765:	c4 c1 78 11 44 3d 00 	vmovups XMMWORD PTR [r13+rdi*1+0x0],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  21a76c:	48 89 f2             	mov    rdx,rsi
  21a76f:	48 83 ca 20          	or     rdx,0x20
    b.* = tmp;
  21a773:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
        swap(T, &items[i], &items[items.len - i - 1]);
  21a778:	48 c7 c7 fd ff ff ff 	mov    rdi,0xfffffffffffffffd
  21a77f:	48 29 df             	sub    rdi,rbx
    b.* = tmp;
  21a782:	c4 c1 78 11 44 05 00 	vmovups XMMWORD PTR [r13+rax*1+0x0],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  21a789:	4c 01 f7             	add    rdi,r14
    const tmp = a.*;
  21a78c:	c4 c1 78 10 44 15 00 	vmovups xmm0,XMMWORD PTR [r13+rdx*1+0x0]
  21a793:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  21a798:	48 c1 e7 04          	shl    rdi,0x4
    a.* = b.*;
  21a79c:	c4 c1 78 10 44 3d 00 	vmovups xmm0,XMMWORD PTR [r13+rdi*1+0x0]
  21a7a3:	c4 c1 78 11 44 15 00 	vmovups XMMWORD PTR [r13+rdx*1+0x0],xmm0
    b.* = tmp;
  21a7aa:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
        swap(T, &items[i], &items[items.len - i - 1]);
  21a7af:	48 83 ce 30          	or     rsi,0x30
  21a7b3:	48 c7 c0 fc ff ff ff 	mov    rax,0xfffffffffffffffc
  21a7ba:	48 29 d8             	sub    rax,rbx
  21a7bd:	4c 01 f0             	add    rax,r14
    b.* = tmp;
  21a7c0:	c4 c1 78 11 44 3d 00 	vmovups XMMWORD PTR [r13+rdi*1+0x0],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  21a7c7:	48 c1 e0 04          	shl    rax,0x4
    const tmp = a.*;
  21a7cb:	c4 c1 78 10 44 35 00 	vmovups xmm0,XMMWORD PTR [r13+rsi*1+0x0]
  21a7d2:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21a7d7:	c4 c1 78 10 44 05 00 	vmovups xmm0,XMMWORD PTR [r13+rax*1+0x0]
  21a7de:	c4 c1 78 11 44 35 00 	vmovups XMMWORD PTR [r13+rsi*1+0x0],xmm0
    b.* = tmp;
  21a7e5:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
    while (i < end) : (i += 1) {
  21a7ea:	48 83 c3 04          	add    rbx,0x4
  21a7ee:	49 83 c7 fc          	add    r15,0xfffffffffffffffc
    b.* = tmp;
  21a7f2:	c4 c1 7a 7f 44 05 00 	vmovdqu XMMWORD PTR [r13+rax*1+0x0],xmm0
    while (i < end) : (i += 1) {
  21a7f9:	0f 85 01 ff ff ff    	jne    21a700 <Benchmark_reportStats+0x4b00>
  21a7ff:	4d 85 db             	test   r11,r11
  21a802:	74 50                	je     21a854 <Benchmark_reportStats+0x4c54>
  21a804:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21a80b:	00 00 00 00 00 
        swap(T, &items[i], &items[items.len - i - 1]);
  21a810:	48 89 d8             	mov    rax,rbx
  21a813:	48 c1 e0 04          	shl    rax,0x4
  21a817:	48 89 da             	mov    rdx,rbx
  21a81a:	48 f7 d2             	not    rdx
  21a81d:	4c 01 f2             	add    rdx,r14
  21a820:	48 c1 e2 04          	shl    rdx,0x4
    const tmp = a.*;
  21a824:	c4 c1 78 10 44 05 00 	vmovups xmm0,XMMWORD PTR [r13+rax*1+0x0]
  21a82b:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21a830:	c4 c1 78 10 44 15 00 	vmovups xmm0,XMMWORD PTR [r13+rdx*1+0x0]
  21a837:	c4 c1 78 11 44 05 00 	vmovups XMMWORD PTR [r13+rax*1+0x0],xmm0
    b.* = tmp;
  21a83e:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  21a843:	c4 c1 7a 7f 44 15 00 	vmovdqu XMMWORD PTR [r13+rdx*1+0x0],xmm0
    while (i < end) : (i += 1) {
  21a84a:	48 83 c3 01          	add    rbx,0x1
  21a84e:	49 83 c3 ff          	add    r11,0xffffffffffffffff
  21a852:	75 bc                	jne    21a810 <Benchmark_reportStats+0x4c10>
    reverse(T, items[amount..]);
  21a854:	4d 89 c3             	mov    r11,r8
  21a857:	4d 29 f3             	sub    r11,r14
    const end = items.len / 2;
  21a85a:	4d 89 df             	mov    r15,r11
  21a85d:	49 d1 ef             	shr    r15,1
    while (i < end) : (i += 1) {
  21a860:	0f 84 66 01 00 00    	je     21a9cc <Benchmark_reportStats+0x4dcc>
  21a866:	48 8b 9c 24 d0 00 00 	mov    rbx,QWORD PTR [rsp+0xd0]
  21a86d:	00 
  21a86e:	48 c1 e3 04          	shl    rbx,0x4
  21a872:	48 03 5c 24 18       	add    rbx,QWORD PTR [rsp+0x18]
        swap(T, &items[i], &items[items.len - i - 1]);
  21a877:	49 8d 47 ff          	lea    rax,[r15-0x1]
  21a87b:	45 89 fe             	mov    r14d,r15d
  21a87e:	41 83 e6 03          	and    r14d,0x3
  21a882:	48 83 f8 03          	cmp    rax,0x3
  21a886:	73 10                	jae    21a898 <Benchmark_reportStats+0x4c98>
  21a888:	31 d2                	xor    edx,edx
    while (i < end) : (i += 1) {
  21a88a:	4d 85 f6             	test   r14,r14
  21a88d:	0f 85 fd 00 00 00    	jne    21a990 <Benchmark_reportStats+0x4d90>
  21a893:	e9 34 01 00 00       	jmp    21a9cc <Benchmark_reportStats+0x4dcc>
        swap(T, &items[i], &items[items.len - i - 1]);
  21a898:	4d 29 f7             	sub    r15,r14
  21a89b:	31 d2                	xor    edx,edx
  21a89d:	0f 1f 00             	nop    DWORD PTR [rax]
  21a8a0:	48 89 d0             	mov    rax,rdx
  21a8a3:	48 c1 e0 04          	shl    rax,0x4
  21a8a7:	48 89 d6             	mov    rsi,rdx
  21a8aa:	48 f7 d6             	not    rsi
  21a8ad:	4c 01 de             	add    rsi,r11
    const tmp = a.*;
  21a8b0:	c5 f8 10 04 03       	vmovups xmm0,XMMWORD PTR [rbx+rax*1]
  21a8b5:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  21a8ba:	48 c1 e6 04          	shl    rsi,0x4
    a.* = b.*;
  21a8be:	c5 f8 10 04 33       	vmovups xmm0,XMMWORD PTR [rbx+rsi*1]
  21a8c3:	c5 f8 11 04 03       	vmovups XMMWORD PTR [rbx+rax*1],xmm0
    b.* = tmp;
  21a8c8:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
        swap(T, &items[i], &items[items.len - i - 1]);
  21a8cd:	48 89 c7             	mov    rdi,rax
  21a8d0:	48 83 cf 10          	or     rdi,0x10
  21a8d4:	48 c7 c1 fe ff ff ff 	mov    rcx,0xfffffffffffffffe
  21a8db:	48 29 d1             	sub    rcx,rdx
  21a8de:	4c 01 d9             	add    rcx,r11
  21a8e1:	48 c1 e1 04          	shl    rcx,0x4
    b.* = tmp;
  21a8e5:	c5 f8 11 04 33       	vmovups XMMWORD PTR [rbx+rsi*1],xmm0
    const tmp = a.*;
  21a8ea:	c5 f8 10 04 3b       	vmovups xmm0,XMMWORD PTR [rbx+rdi*1]
  21a8ef:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21a8f4:	c5 f8 10 04 0b       	vmovups xmm0,XMMWORD PTR [rbx+rcx*1]
  21a8f9:	c5 f8 11 04 3b       	vmovups XMMWORD PTR [rbx+rdi*1],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  21a8fe:	48 89 c6             	mov    rsi,rax
  21a901:	48 83 ce 20          	or     rsi,0x20
    b.* = tmp;
  21a905:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
        swap(T, &items[i], &items[items.len - i - 1]);
  21a90a:	48 c7 c7 fd ff ff ff 	mov    rdi,0xfffffffffffffffd
  21a911:	48 29 d7             	sub    rdi,rdx
    b.* = tmp;
  21a914:	c5 f8 11 04 0b       	vmovups XMMWORD PTR [rbx+rcx*1],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  21a919:	4c 01 df             	add    rdi,r11
    const tmp = a.*;
  21a91c:	c5 f8 10 04 33       	vmovups xmm0,XMMWORD PTR [rbx+rsi*1]
  21a921:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  21a926:	48 c1 e7 04          	shl    rdi,0x4
    a.* = b.*;
  21a92a:	c5 f8 10 04 3b       	vmovups xmm0,XMMWORD PTR [rbx+rdi*1]
  21a92f:	c5 f8 11 04 33       	vmovups XMMWORD PTR [rbx+rsi*1],xmm0
    b.* = tmp;
  21a934:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
        swap(T, &items[i], &items[items.len - i - 1]);
  21a939:	48 83 c8 30          	or     rax,0x30
  21a93d:	48 c7 c1 fc ff ff ff 	mov    rcx,0xfffffffffffffffc
  21a944:	48 29 d1             	sub    rcx,rdx
  21a947:	4c 01 d9             	add    rcx,r11
    b.* = tmp;
  21a94a:	c5 f8 11 04 3b       	vmovups XMMWORD PTR [rbx+rdi*1],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  21a94f:	48 c1 e1 04          	shl    rcx,0x4
    const tmp = a.*;
  21a953:	c5 f8 10 04 03       	vmovups xmm0,XMMWORD PTR [rbx+rax*1]
  21a958:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21a95d:	c5 f8 10 04 0b       	vmovups xmm0,XMMWORD PTR [rbx+rcx*1]
  21a962:	c5 f8 11 04 03       	vmovups XMMWORD PTR [rbx+rax*1],xmm0
    b.* = tmp;
  21a967:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
    while (i < end) : (i += 1) {
  21a96c:	48 83 c2 04          	add    rdx,0x4
  21a970:	49 83 c7 fc          	add    r15,0xfffffffffffffffc
    b.* = tmp;
  21a974:	c5 fa 7f 04 0b       	vmovdqu XMMWORD PTR [rbx+rcx*1],xmm0
    while (i < end) : (i += 1) {
  21a979:	0f 85 21 ff ff ff    	jne    21a8a0 <Benchmark_reportStats+0x4ca0>
  21a97f:	4d 85 f6             	test   r14,r14
  21a982:	74 48                	je     21a9cc <Benchmark_reportStats+0x4dcc>
  21a984:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21a98b:	00 00 00 00 00 
        swap(T, &items[i], &items[items.len - i - 1]);
  21a990:	48 89 d0             	mov    rax,rdx
  21a993:	48 c1 e0 04          	shl    rax,0x4
  21a997:	48 89 d1             	mov    rcx,rdx
  21a99a:	48 f7 d1             	not    rcx
  21a99d:	4c 01 d9             	add    rcx,r11
  21a9a0:	48 c1 e1 04          	shl    rcx,0x4
    const tmp = a.*;
  21a9a4:	c5 f8 10 04 03       	vmovups xmm0,XMMWORD PTR [rbx+rax*1]
  21a9a9:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21a9ae:	c5 f8 10 04 0b       	vmovups xmm0,XMMWORD PTR [rbx+rcx*1]
  21a9b3:	c5 f8 11 04 03       	vmovups XMMWORD PTR [rbx+rax*1],xmm0
    b.* = tmp;
  21a9b8:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  21a9bd:	c5 fa 7f 04 0b       	vmovdqu XMMWORD PTR [rbx+rcx*1],xmm0
    while (i < end) : (i += 1) {
  21a9c2:	48 83 c2 01          	add    rdx,0x1
  21a9c6:	49 83 c6 ff          	add    r14,0xffffffffffffffff
  21a9ca:	75 c4                	jne    21a990 <Benchmark_reportStats+0x4d90>
    const end = items.len / 2;
  21a9cc:	4c 89 c0             	mov    rax,r8
  21a9cf:	48 d1 e8             	shr    rax,1
  21a9d2:	4c 8b 74 24 28       	mov    r14,QWORD PTR [rsp+0x28]
  21a9d7:	4c 8b 5c 24 30       	mov    r11,QWORD PTR [rsp+0x30]
    while (i < end) : (i += 1) {
  21a9dc:	0f 84 2e eb ff ff    	je     219510 <Benchmark_reportStats+0x3910>
    const tmp = a.*;
  21a9e2:	c4 c1 78 10 45 00    	vmovups xmm0,XMMWORD PTR [r13+0x0]
  21a9e8:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  21a9ed:	49 c1 e0 04          	shl    r8,0x4
    a.* = b.*;
  21a9f1:	c4 81 78 10 44 05 f0 	vmovups xmm0,XMMWORD PTR [r13+r8*1-0x10]
  21a9f8:	c4 c1 78 11 45 00    	vmovups XMMWORD PTR [r13+0x0],xmm0
    b.* = tmp;
  21a9fe:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  21aa03:	c4 81 7a 7f 44 05 f0 	vmovdqu XMMWORD PTR [r13+r8*1-0x10],xmm0
    while (i < end) : (i += 1) {
  21aa0a:	48 83 f8 01          	cmp    rax,0x1
  21aa0e:	0f 84 fc ea ff ff    	je     219510 <Benchmark_reportStats+0x3910>
        swap(T, &items[i], &items[items.len - i - 1]);
  21aa14:	48 8d 70 ff          	lea    rsi,[rax-0x1]
  21aa18:	48 83 c0 fe          	add    rax,0xfffffffffffffffe
  21aa1c:	89 f2                	mov    edx,esi
  21aa1e:	83 e2 03             	and    edx,0x3
  21aa21:	48 83 f8 03          	cmp    rax,0x3
  21aa25:	73 13                	jae    21aa3a <Benchmark_reportStats+0x4e3a>
  21aa27:	b8 01 00 00 00       	mov    eax,0x1
    while (i < end) : (i += 1) {
  21aa2c:	48 85 d2             	test   rdx,rdx
  21aa2f:	0f 85 d3 00 00 00    	jne    21ab08 <Benchmark_reportStats+0x4f08>
  21aa35:	e9 d6 ea ff ff       	jmp    219510 <Benchmark_reportStats+0x3910>
        swap(T, &items[i], &items[items.len - i - 1]);
  21aa3a:	48 29 d6             	sub    rsi,rdx
  21aa3d:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  21aa44:	00 
  21aa45:	48 c1 e0 04          	shl    rax,0x4
  21aa49:	48 8b 4c 24 18       	mov    rcx,QWORD PTR [rsp+0x18]
  21aa4e:	48 8d 3c 01          	lea    rdi,[rcx+rax*1]
  21aa52:	48 83 c7 e0          	add    rdi,0xffffffffffffffe0
  21aa56:	b8 01 00 00 00       	mov    eax,0x1
  21aa5b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  21aa60:	48 89 c1             	mov    rcx,rax
  21aa63:	48 c1 e1 04          	shl    rcx,0x4
    const tmp = a.*;
  21aa67:	c4 c1 78 10 44 0d 00 	vmovups xmm0,XMMWORD PTR [r13+rcx*1+0x0]
  21aa6e:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21aa73:	c5 f8 10 07          	vmovups xmm0,XMMWORD PTR [rdi]
  21aa77:	c4 c1 78 11 44 0d 00 	vmovups XMMWORD PTR [r13+rcx*1+0x0],xmm0
    b.* = tmp;
  21aa7e:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  21aa83:	c5 f8 11 07          	vmovups XMMWORD PTR [rdi],xmm0
    const tmp = a.*;
  21aa87:	c4 c1 78 10 44 0d 10 	vmovups xmm0,XMMWORD PTR [r13+rcx*1+0x10]
  21aa8e:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21aa93:	c5 f8 10 47 f0       	vmovups xmm0,XMMWORD PTR [rdi-0x10]
  21aa98:	c4 c1 78 11 44 0d 10 	vmovups XMMWORD PTR [r13+rcx*1+0x10],xmm0
    b.* = tmp;
  21aa9f:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  21aaa4:	c5 f8 11 47 f0       	vmovups XMMWORD PTR [rdi-0x10],xmm0
    const tmp = a.*;
  21aaa9:	c4 c1 78 10 44 0d 20 	vmovups xmm0,XMMWORD PTR [r13+rcx*1+0x20]
  21aab0:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21aab5:	c5 f8 10 47 e0       	vmovups xmm0,XMMWORD PTR [rdi-0x20]
  21aaba:	c4 c1 78 11 44 0d 20 	vmovups XMMWORD PTR [r13+rcx*1+0x20],xmm0
    b.* = tmp;
  21aac1:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  21aac6:	c5 f8 11 47 e0       	vmovups XMMWORD PTR [rdi-0x20],xmm0
    const tmp = a.*;
  21aacb:	c4 c1 78 10 44 0d 30 	vmovups xmm0,XMMWORD PTR [r13+rcx*1+0x30]
  21aad2:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21aad7:	c5 f8 10 47 d0       	vmovups xmm0,XMMWORD PTR [rdi-0x30]
  21aadc:	c4 c1 78 11 44 0d 30 	vmovups XMMWORD PTR [r13+rcx*1+0x30],xmm0
    b.* = tmp;
  21aae3:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  21aae8:	c5 fa 7f 47 d0       	vmovdqu XMMWORD PTR [rdi-0x30],xmm0
    while (i < end) : (i += 1) {
  21aaed:	48 83 c0 04          	add    rax,0x4
  21aaf1:	48 83 c7 c0          	add    rdi,0xffffffffffffffc0
  21aaf5:	48 83 c6 fc          	add    rsi,0xfffffffffffffffc
  21aaf9:	0f 85 61 ff ff ff    	jne    21aa60 <Benchmark_reportStats+0x4e60>
  21aaff:	48 85 d2             	test   rdx,rdx
  21ab02:	0f 84 08 ea ff ff    	je     219510 <Benchmark_reportStats+0x3910>
  21ab08:	48 8b 8c 24 f8 00 00 	mov    rcx,QWORD PTR [rsp+0xf8]
  21ab0f:	00 
  21ab10:	48 29 c1             	sub    rcx,rax
  21ab13:	48 c1 e1 04          	shl    rcx,0x4
  21ab17:	48 8b 74 24 18       	mov    rsi,QWORD PTR [rsp+0x18]
  21ab1c:	48 01 ce             	add    rsi,rcx
  21ab1f:	48 83 c6 f0          	add    rsi,0xfffffffffffffff0
  21ab23:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21ab2a:	84 00 00 00 00 00 
        swap(T, &items[i], &items[items.len - i - 1]);
  21ab30:	48 89 c1             	mov    rcx,rax
  21ab33:	48 c1 e1 04          	shl    rcx,0x4
    const tmp = a.*;
  21ab37:	c4 c1 78 10 44 0d 00 	vmovups xmm0,XMMWORD PTR [r13+rcx*1+0x0]
  21ab3e:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21ab43:	c5 f8 10 06          	vmovups xmm0,XMMWORD PTR [rsi]
  21ab47:	c4 c1 78 11 44 0d 00 	vmovups XMMWORD PTR [r13+rcx*1+0x0],xmm0
    b.* = tmp;
  21ab4e:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  21ab53:	c5 fa 7f 06          	vmovdqu XMMWORD PTR [rsi],xmm0
    while (i < end) : (i += 1) {
  21ab57:	48 83 c0 01          	add    rax,0x1
  21ab5b:	48 83 c6 f0          	add    rsi,0xfffffffffffffff0
  21ab5f:	48 83 c2 ff          	add    rdx,0xffffffffffffffff
  21ab63:	75 cb                	jne    21ab30 <Benchmark_reportStats+0x4f30>
  21ab65:	e9 a6 e9 ff ff       	jmp    219510 <Benchmark_reportStats+0x3910>
  21ab6a:	48 83 7c 24 58 03    	cmp    QWORD PTR [rsp+0x58],0x3
        mem.swap(T, &items[start1 + index], &items[start2 + index]);
  21ab70:	73 14                	jae    21ab86 <Benchmark_reportStats+0x4f86>
  21ab72:	45 31 c9             	xor    r9d,r9d
  21ab75:	48 83 7c 24 10 00    	cmp    QWORD PTR [rsp+0x10],0x0
  21ab7b:	0f 85 17 01 00 00    	jne    21ac98 <Benchmark_reportStats+0x5098>
  21ab81:	e9 54 e9 ff ff       	jmp    2194da <Benchmark_reportStats+0x38da>
  21ab86:	45 31 c9             	xor    r9d,r9d
  21ab89:	48 8b 9c 24 10 01 00 	mov    rbx,QWORD PTR [rsp+0x110]
  21ab90:	00 
  21ab91:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21ab98:	0f 1f 84 00 00 00 00 
  21ab9f:	00 
  21aba0:	4b 8d 14 21          	lea    rdx,[r9+r12*1]
  21aba4:	48 8b 44 24 40       	mov    rax,QWORD PTR [rsp+0x40]
  21aba9:	48 c1 e2 04          	shl    rdx,0x4
  21abad:	49 8d 0c 39          	lea    rcx,[r9+rdi*1]
    const tmp = a.*;
  21abb1:	c5 f8 10 04 10       	vmovups xmm0,XMMWORD PTR [rax+rdx*1]
  21abb6:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
  21abbb:	48 c1 e1 04          	shl    rcx,0x4
    a.* = b.*;
  21abbf:	c5 f8 10 04 08       	vmovups xmm0,XMMWORD PTR [rax+rcx*1]
  21abc4:	c5 f8 11 04 10       	vmovups XMMWORD PTR [rax+rdx*1],xmm0
    b.* = tmp;
  21abc9:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
    while (index < block_size) : (index += 1) {
  21abce:	4c 89 ca             	mov    rdx,r9
  21abd1:	c5 f8 11 04 08       	vmovups XMMWORD PTR [rax+rcx*1],xmm0
  21abd6:	48 83 ca 01          	or     rdx,0x1
        mem.swap(T, &items[start1 + index], &items[start2 + index]);
  21abda:	4a 8d 04 22          	lea    rax,[rdx+r12*1]
  21abde:	48 8b 4c 24 40       	mov    rcx,QWORD PTR [rsp+0x40]
  21abe3:	48 c1 e0 04          	shl    rax,0x4
  21abe7:	48 01 fa             	add    rdx,rdi
    const tmp = a.*;
  21abea:	c5 f8 10 04 01       	vmovups xmm0,XMMWORD PTR [rcx+rax*1]
  21abef:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
  21abf4:	48 c1 e2 04          	shl    rdx,0x4
    a.* = b.*;
  21abf8:	c5 f8 10 04 11       	vmovups xmm0,XMMWORD PTR [rcx+rdx*1]
  21abfd:	c5 f8 11 04 01       	vmovups XMMWORD PTR [rcx+rax*1],xmm0
    b.* = tmp;
  21ac02:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
    while (index < block_size) : (index += 1) {
  21ac07:	4c 89 c8             	mov    rax,r9
  21ac0a:	c5 f8 11 04 11       	vmovups XMMWORD PTR [rcx+rdx*1],xmm0
  21ac0f:	48 83 c8 02          	or     rax,0x2
        mem.swap(T, &items[start1 + index], &items[start2 + index]);
  21ac13:	4a 8d 14 20          	lea    rdx,[rax+r12*1]
  21ac17:	48 8b 4c 24 40       	mov    rcx,QWORD PTR [rsp+0x40]
  21ac1c:	48 c1 e2 04          	shl    rdx,0x4
  21ac20:	48 01 f8             	add    rax,rdi
    const tmp = a.*;
  21ac23:	c5 f8 10 04 11       	vmovups xmm0,XMMWORD PTR [rcx+rdx*1]
  21ac28:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
  21ac2d:	48 c1 e0 04          	shl    rax,0x4
    a.* = b.*;
  21ac31:	c5 f8 10 04 01       	vmovups xmm0,XMMWORD PTR [rcx+rax*1]
  21ac36:	c5 f8 11 04 11       	vmovups XMMWORD PTR [rcx+rdx*1],xmm0
    b.* = tmp;
  21ac3b:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
    while (index < block_size) : (index += 1) {
  21ac40:	4c 89 ca             	mov    rdx,r9
  21ac43:	48 83 ca 03          	or     rdx,0x3
  21ac47:	c5 f8 11 04 01       	vmovups XMMWORD PTR [rcx+rax*1],xmm0
        mem.swap(T, &items[start1 + index], &items[start2 + index]);
  21ac4c:	4a 8d 04 22          	lea    rax,[rdx+r12*1]
  21ac50:	48 8b 4c 24 40       	mov    rcx,QWORD PTR [rsp+0x40]
  21ac55:	48 c1 e0 04          	shl    rax,0x4
  21ac59:	48 01 fa             	add    rdx,rdi
  21ac5c:	48 c1 e2 04          	shl    rdx,0x4
    const tmp = a.*;
  21ac60:	c5 f8 10 04 01       	vmovups xmm0,XMMWORD PTR [rcx+rax*1]
  21ac65:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21ac6a:	c5 f8 10 04 11       	vmovups xmm0,XMMWORD PTR [rcx+rdx*1]
  21ac6f:	c5 f8 11 04 01       	vmovups XMMWORD PTR [rcx+rax*1],xmm0
    b.* = tmp;
  21ac74:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
    while (index < block_size) : (index += 1) {
  21ac79:	49 83 c1 04          	add    r9,0x4
  21ac7d:	48 83 c3 fc          	add    rbx,0xfffffffffffffffc
  21ac81:	c5 fa 7f 04 11       	vmovdqu XMMWORD PTR [rcx+rdx*1],xmm0
  21ac86:	0f 85 14 ff ff ff    	jne    21aba0 <Benchmark_reportStats+0x4fa0>
  21ac8c:	48 83 7c 24 10 00    	cmp    QWORD PTR [rsp+0x10],0x0
  21ac92:	0f 84 42 e8 ff ff    	je     2194da <Benchmark_reportStats+0x38da>
  21ac98:	48 8b 5c 24 10       	mov    rbx,QWORD PTR [rsp+0x10]
  21ac9d:	0f 1f 00             	nop    DWORD PTR [rax]
        mem.swap(T, &items[start1 + index], &items[start2 + index]);
  21aca0:	4b 8d 14 21          	lea    rdx,[r9+r12*1]
  21aca4:	48 8b 44 24 40       	mov    rax,QWORD PTR [rsp+0x40]
  21aca9:	48 c1 e2 04          	shl    rdx,0x4
  21acad:	49 8d 0c 39          	lea    rcx,[r9+rdi*1]
  21acb1:	48 c1 e1 04          	shl    rcx,0x4
    const tmp = a.*;
  21acb5:	c5 f8 10 04 10       	vmovups xmm0,XMMWORD PTR [rax+rdx*1]
  21acba:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21acbf:	c5 f8 10 04 08       	vmovups xmm0,XMMWORD PTR [rax+rcx*1]
  21acc4:	c5 f8 11 04 10       	vmovups XMMWORD PTR [rax+rdx*1],xmm0
    b.* = tmp;
  21acc9:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  21acce:	c5 fa 7f 04 08       	vmovdqu XMMWORD PTR [rax+rcx*1],xmm0
    while (index < block_size) : (index += 1) {
  21acd3:	49 83 c1 01          	add    r9,0x1
  21acd7:	48 83 c3 ff          	add    rbx,0xffffffffffffffff
  21acdb:	75 c3                	jne    21aca0 <Benchmark_reportStats+0x50a0>
  21acdd:	e9 f8 e7 ff ff       	jmp    2194da <Benchmark_reportStats+0x38da>
        return self.end - self.start;
  21ace2:	4d 89 f5             	mov    r13,r14
  21ace5:	48 8b 44 24 50       	mov    rax,QWORD PTR [rsp+0x50]
                    if (lastA.length() <= cache.len) {
  21acea:	49 81 fd 00 02 00 00 	cmp    r13,0x200
  21acf1:	4c 8b 84 24 e8 00 00 	mov    r8,QWORD PTR [rsp+0xe8]
  21acf8:	00 
  21acf9:	0f 86 af e5 ff ff    	jbe    2192ae <Benchmark_reportStats+0x36ae>
  21acff:	48 8b 4c 24 60       	mov    rcx,QWORD PTR [rsp+0x60]
  21ad04:	48 39 c8             	cmp    rax,rcx
  21ad07:	48 89 c8             	mov    rax,rcx
                    } else if (buffer2.length() > 0) {
  21ad0a:	75 32                	jne    21ad3e <Benchmark_reportStats+0x513e>
        return Range{
  21ad0c:	4c 89 bc 24 08 02 00 	mov    QWORD PTR [rsp+0x208],r15
  21ad13:	00 
  21ad14:	4c 89 84 24 10 02 00 	mov    QWORD PTR [rsp+0x210],r8
  21ad1b:	00 
                        mergeInPlace(T, items, lastA, Range.init(lastA.end, B.end), lessThan);
  21ad1c:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  21ad21:	48 8d b4 24 78 01 00 	lea    rsi,[rsp+0x178]
  21ad28:	00 
  21ad29:	48 8d 94 24 08 02 00 	lea    rdx,[rsp+0x208]
  21ad30:	00 
  21ad31:	c5 f8 77             	vzeroupper 
  21ad34:	e8 c7 3b 00 00       	call   21e900 <mergeInPlace>
  21ad39:	e9 72 02 00 00       	jmp    21afb0 <Benchmark_reportStats+0x53b0>
    if (B.length() > 0 and A.length() > 0) {
  21ad3e:	4d 29 f8             	sub    r8,r15
  21ad41:	0f 84 cf 00 00 00    	je     21ae16 <Benchmark_reportStats+0x5216>
  21ad47:	41 ba 00 00 00 00    	mov    r10d,0x0
  21ad4d:	41 be 00 00 00 00    	mov    r14d,0x0
  21ad53:	4d 39 e7             	cmp    r15,r12
  21ad56:	0f 84 c0 00 00 00    	je     21ae1c <Benchmark_reportStats+0x521c>
  21ad5c:	45 31 d2             	xor    r10d,r10d
  21ad5f:	31 f6                	xor    esi,esi
  21ad61:	45 31 c9             	xor    r9d,r9d
  21ad64:	4d 8d 1c 02          	lea    r11,[r10+rax*1]
            if (!lessThan(items[B.start + B_count], items[buffer.start + A_count])) {
  21ad68:	49 8d 1c 37          	lea    rbx,[r15+rsi*1]
  21ad6c:	48 c1 e3 04          	shl    rbx,0x4
  21ad70:	4b 8d 0c 0c          	lea    rcx,[r12+r9*1]
  21ad74:	48 c1 e1 04          	shl    rcx,0x4
  21ad78:	4d 89 ce             	mov    r14,r9
  21ad7b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  21ad80:	48 8b 44 24 40       	mov    rax,QWORD PTR [rsp+0x40]
  21ad85:	4c 89 da             	mov    rdx,r11
  21ad88:	48 c1 e2 04          	shl    rdx,0x4
  21ad8c:	48 8b 3c 18          	mov    rdi,QWORD PTR [rax+rbx*1]
  21ad90:	48 3b 3c 10          	cmp    rdi,QWORD PTR [rax+rdx*1]
  21ad94:	73 3a                	jae    21add0 <Benchmark_reportStats+0x51d0>
    const tmp = a.*;
  21ad96:	c5 f8 10 04 08       	vmovups xmm0,XMMWORD PTR [rax+rcx*1]
  21ad9b:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21ada0:	c5 f8 10 04 18       	vmovups xmm0,XMMWORD PTR [rax+rbx*1]
  21ada5:	c5 f8 11 04 08       	vmovups XMMWORD PTR [rax+rcx*1],xmm0
    b.* = tmp;
  21adaa:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  21adaf:	c5 fa 7f 04 18       	vmovdqu XMMWORD PTR [rax+rbx*1],xmm0
                B_count += 1;
  21adb4:	48 83 c6 01          	add    rsi,0x1
                insert += 1;
  21adb8:	49 83 c6 01          	add    r14,0x1
                if (B_count >= B.length()) break;
  21adbc:	48 83 c3 10          	add    rbx,0x10
  21adc0:	48 83 c1 10          	add    rcx,0x10
  21adc4:	4c 39 c6             	cmp    rsi,r8
  21adc7:	72 b7                	jb     21ad80 <Benchmark_reportStats+0x5180>
  21adc9:	eb 51                	jmp    21ae1c <Benchmark_reportStats+0x521c>
  21adcb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
    const tmp = a.*;
  21add0:	c5 f8 10 04 08       	vmovups xmm0,XMMWORD PTR [rax+rcx*1]
  21add5:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
  21adda:	48 01 c2             	add    rdx,rax
    a.* = b.*;
  21addd:	c5 f8 10 02          	vmovups xmm0,XMMWORD PTR [rdx]
  21ade1:	c5 f8 11 04 08       	vmovups XMMWORD PTR [rax+rcx*1],xmm0
    b.* = tmp;
  21ade6:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  21adeb:	c5 fa 7f 02          	vmovdqu XMMWORD PTR [rdx],xmm0
                A_count += 1;
  21adef:	49 83 c2 01          	add    r10,0x1
                if (A_count >= A.length()) break;
  21adf3:	4d 8d 4e 01          	lea    r9,[r14+0x1]
  21adf7:	4d 39 ea             	cmp    r10,r13
  21adfa:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
  21adff:	0f 82 5f ff ff ff    	jb     21ad64 <Benchmark_reportStats+0x5164>
    blockSwap(T, items, buffer.start + A_count, A.start + insert, A.length() - A_count);
  21ae05:	49 83 c6 01          	add    r14,0x1
    while (index < block_size) : (index += 1) {
  21ae09:	4d 89 e9             	mov    r9,r13
  21ae0c:	4d 29 d1             	sub    r9,r10
  21ae0f:	75 17                	jne    21ae28 <Benchmark_reportStats+0x5228>
  21ae11:	e9 9a 01 00 00       	jmp    21afb0 <Benchmark_reportStats+0x53b0>
  21ae16:	45 31 d2             	xor    r10d,r10d
  21ae19:	45 31 f6             	xor    r14d,r14d
  21ae1c:	4d 89 e9             	mov    r9,r13
  21ae1f:	4d 29 d1             	sub    r9,r10
  21ae22:	0f 84 88 01 00 00    	je     21afb0 <Benchmark_reportStats+0x53b0>
        mem.swap(T, &items[start1 + index], &items[start2 + index]);
  21ae28:	49 83 c5 ff          	add    r13,0xffffffffffffffff
  21ae2c:	4d 29 d5             	sub    r13,r10
  21ae2f:	44 89 c8             	mov    eax,r9d
  21ae32:	83 e0 03             	and    eax,0x3
  21ae35:	49 83 fd 03          	cmp    r13,0x3
  21ae39:	73 10                	jae    21ae4b <Benchmark_reportStats+0x524b>
  21ae3b:	31 ff                	xor    edi,edi
    while (index < block_size) : (index += 1) {
  21ae3d:	48 85 c0             	test   rax,rax
  21ae40:	0f 85 04 01 00 00    	jne    21af4a <Benchmark_reportStats+0x534a>
  21ae46:	e9 65 01 00 00       	jmp    21afb0 <Benchmark_reportStats+0x53b0>
        mem.swap(T, &items[start1 + index], &items[start2 + index]);
  21ae4b:	49 29 c1             	sub    r9,rax
  21ae4e:	4d 89 d0             	mov    r8,r10
  21ae51:	49 c1 e0 04          	shl    r8,0x4
  21ae55:	4c 03 84 24 18 01 00 	add    r8,QWORD PTR [rsp+0x118]
  21ae5c:	00 
  21ae5d:	4c 89 f2             	mov    rdx,r14
  21ae60:	48 c1 e2 04          	shl    rdx,0x4
  21ae64:	4c 89 e6             	mov    rsi,r12
  21ae67:	48 c1 e6 04          	shl    rsi,0x4
  21ae6b:	48 01 d6             	add    rsi,rdx
  21ae6e:	31 db                	xor    ebx,ebx
  21ae70:	31 ff                	xor    edi,edi
  21ae72:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21ae79:	1f 84 00 00 00 00 00 
  21ae80:	48 8b 54 24 40       	mov    rdx,QWORD PTR [rsp+0x40]
    const tmp = a.*;
  21ae85:	4a 8d 0c 02          	lea    rcx,[rdx+r8*1]
  21ae89:	c5 f8 10 04 0b       	vmovups xmm0,XMMWORD PTR [rbx+rcx*1]
  21ae8e:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21ae93:	48 01 f2             	add    rdx,rsi
  21ae96:	c5 f8 10 04 13       	vmovups xmm0,XMMWORD PTR [rbx+rdx*1]
  21ae9b:	c5 f8 11 04 0b       	vmovups XMMWORD PTR [rbx+rcx*1],xmm0
    b.* = tmp;
  21aea0:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  21aea5:	c5 f8 11 04 13       	vmovups XMMWORD PTR [rbx+rdx*1],xmm0
  21aeaa:	48 8b 4c 24 40       	mov    rcx,QWORD PTR [rsp+0x40]
    const tmp = a.*;
  21aeaf:	4a 8d 14 01          	lea    rdx,[rcx+r8*1]
  21aeb3:	c5 f8 10 44 13 10    	vmovups xmm0,XMMWORD PTR [rbx+rdx*1+0x10]
  21aeb9:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21aebe:	48 01 f1             	add    rcx,rsi
  21aec1:	c5 f8 10 44 0b 10    	vmovups xmm0,XMMWORD PTR [rbx+rcx*1+0x10]
  21aec7:	c5 f8 11 44 13 10    	vmovups XMMWORD PTR [rbx+rdx*1+0x10],xmm0
    b.* = tmp;
  21aecd:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  21aed2:	c5 f8 11 44 0b 10    	vmovups XMMWORD PTR [rbx+rcx*1+0x10],xmm0
  21aed8:	48 8b 4c 24 40       	mov    rcx,QWORD PTR [rsp+0x40]
    const tmp = a.*;
  21aedd:	4a 8d 14 01          	lea    rdx,[rcx+r8*1]
  21aee1:	c5 f8 10 44 13 20    	vmovups xmm0,XMMWORD PTR [rbx+rdx*1+0x20]
  21aee7:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21aeec:	48 01 f1             	add    rcx,rsi
  21aeef:	c5 f8 10 44 0b 20    	vmovups xmm0,XMMWORD PTR [rbx+rcx*1+0x20]
  21aef5:	c5 f8 11 44 13 20    	vmovups XMMWORD PTR [rbx+rdx*1+0x20],xmm0
    b.* = tmp;
  21aefb:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  21af00:	c5 f8 11 44 0b 20    	vmovups XMMWORD PTR [rbx+rcx*1+0x20],xmm0
  21af06:	48 8b 4c 24 40       	mov    rcx,QWORD PTR [rsp+0x40]
    const tmp = a.*;
  21af0b:	4a 8d 14 01          	lea    rdx,[rcx+r8*1]
  21af0f:	c5 f8 10 44 13 30    	vmovups xmm0,XMMWORD PTR [rbx+rdx*1+0x30]
  21af15:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21af1a:	48 01 f1             	add    rcx,rsi
  21af1d:	c5 f8 10 44 0b 30    	vmovups xmm0,XMMWORD PTR [rbx+rcx*1+0x30]
  21af23:	c5 f8 11 44 13 30    	vmovups XMMWORD PTR [rbx+rdx*1+0x30],xmm0
    b.* = tmp;
  21af29:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  21af2e:	c5 fa 7f 44 0b 30    	vmovdqu XMMWORD PTR [rbx+rcx*1+0x30],xmm0
    while (index < block_size) : (index += 1) {
  21af34:	48 83 c7 04          	add    rdi,0x4
  21af38:	48 83 c3 40          	add    rbx,0x40
  21af3c:	49 39 f9             	cmp    r9,rdi
  21af3f:	0f 85 3b ff ff ff    	jne    21ae80 <Benchmark_reportStats+0x5280>
  21af45:	48 85 c0             	test   rax,rax
  21af48:	74 66                	je     21afb0 <Benchmark_reportStats+0x53b0>
  21af4a:	4d 01 e6             	add    r14,r12
  21af4d:	49 01 fe             	add    r14,rdi
  21af50:	49 c1 e6 04          	shl    r14,0x4
  21af54:	4c 03 54 24 60       	add    r10,QWORD PTR [rsp+0x60]
  21af59:	49 01 fa             	add    r10,rdi
  21af5c:	49 c1 e2 04          	shl    r10,0x4
  21af60:	48 f7 d8             	neg    rax
  21af63:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21af6a:	84 00 00 00 00 00 
        mem.swap(T, &items[start1 + index], &items[start2 + index]);
  21af70:	48 8b 4c 24 40       	mov    rcx,QWORD PTR [rsp+0x40]
    const tmp = a.*;
  21af75:	c4 a1 78 10 04 11    	vmovups xmm0,XMMWORD PTR [rcx+r10*1]
  21af7b:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21af80:	c4 a1 78 10 04 31    	vmovups xmm0,XMMWORD PTR [rcx+r14*1]
  21af86:	c4 a1 78 11 04 11    	vmovups XMMWORD PTR [rcx+r10*1],xmm0
    b.* = tmp;
  21af8c:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  21af91:	c4 a1 7a 7f 04 31    	vmovdqu XMMWORD PTR [rcx+r14*1],xmm0
    while (index < block_size) : (index += 1) {
  21af97:	49 83 c6 10          	add    r14,0x10
  21af9b:	49 83 c2 10          	add    r10,0x10
  21af9f:	48 83 c0 01          	add    rax,0x1
  21afa3:	75 cb                	jne    21af70 <Benchmark_reportStats+0x5370>
  21afa5:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21afac:	00 00 00 00 
  21afb0:	48 8b 9c 24 38 01 00 	mov    rbx,QWORD PTR [rsp+0x138]
  21afb7:	00 
  21afb8:	48 2b 9c 24 30 01 00 	sub    rbx,QWORD PTR [rsp+0x130]
  21afbf:	00 
  21afc0:	48 8b 84 24 08 01 00 	mov    rax,QWORD PTR [rsp+0x108]
  21afc7:	00 
        return self.decimal >= self.size;
  21afc8:	48 3b 84 24 f0 00 00 	cmp    rax,QWORD PTR [rsp+0xf0]
  21afcf:	00 
  21afd0:	48 8b b4 24 d8 00 00 	mov    rsi,QWORD PTR [rsp+0xd8]
  21afd7:	00 
  21afd8:	48 8b 94 24 e0 00 00 	mov    rdx,QWORD PTR [rsp+0xe0]
  21afdf:	00 
            while (!iterator.finished()) {
  21afe0:	0f 82 9a d9 ff ff    	jb     218980 <Benchmark_reportStats+0x2d80>
        while (i < items.len) : (i += 1) {
  21afe6:	48 83 bc 24 c0 01 00 	cmp    QWORD PTR [rsp+0x1c0],0x2
  21afed:	00 02 
  21afef:	0f 82 e3 01 00 00    	jb     21b1d8 <Benchmark_reportStats+0x55d8>
  21aff5:	48 8b 44 24 40       	mov    rax,QWORD PTR [rsp+0x40]
  21affa:	48 8b b4 24 18 01 00 	mov    rsi,QWORD PTR [rsp+0x118]
  21b001:	00 
  21b002:	4c 8d 0c 30          	lea    r9,[rax+rsi*1]
  21b006:	48 8b 4c 24 50       	mov    rcx,QWORD PTR [rsp+0x50]
            const x = items[i];
  21b00b:	4c 8d 51 ff          	lea    r10,[rcx-0x1]
  21b00f:	48 8b 54 24 60       	mov    rdx,QWORD PTR [rsp+0x60]
  21b014:	49 29 d2             	sub    r10,rdx
  21b017:	48 83 c1 fe          	add    rcx,0xfffffffffffffffe
  21b01b:	45 89 d0             	mov    r8d,r10d
  21b01e:	41 83 e0 01          	and    r8d,0x1
  21b022:	48 39 d1             	cmp    rcx,rdx
  21b025:	75 13                	jne    21b03a <Benchmark_reportStats+0x543a>
  21b027:	be 01 00 00 00       	mov    esi,0x1
            while (j > 0 and lessThan(x, items[j - 1])) : (j -= 1) {
  21b02c:	4d 85 c0             	test   r8,r8
  21b02f:	0f 85 19 01 00 00    	jne    21b14e <Benchmark_reportStats+0x554e>
  21b035:	e9 9e 01 00 00       	jmp    21b1d8 <Benchmark_reportStats+0x55d8>
            const x = items[i];
  21b03a:	4d 29 c2             	sub    r10,r8
  21b03d:	4c 8d 3c 30          	lea    r15,[rax+rsi*1]
  21b041:	49 83 c7 10          	add    r15,0x10
  21b045:	4c 8d 1c 30          	lea    r11,[rax+rsi*1]
  21b049:	49 83 c3 20          	add    r11,0x20
  21b04d:	49 c7 c4 ff ff ff ff 	mov    r12,0xffffffffffffffff
  21b054:	49 c7 c6 fe ff ff ff 	mov    r14,0xfffffffffffffffe
  21b05b:	be 01 00 00 00       	mov    esi,0x1
  21b060:	48 89 f1             	mov    rcx,rsi
  21b063:	48 c1 e1 04          	shl    rcx,0x4
  21b067:	c4 c1 7a 6f 04 09    	vmovdqu xmm0,XMMWORD PTR [r9+rcx*1]
  21b06d:	c4 e1 f9 7e c0       	vmovq  rax,xmm0
  21b072:	4c 89 e2             	mov    rdx,r12
  21b075:	4c 89 ff             	mov    rdi,r15
  21b078:	49 3b 44 09 f0       	cmp    rax,QWORD PTR [r9+rcx*1-0x10]
            while (j > 0 and lessThan(x, items[j - 1])) : (j -= 1) {
  21b07d:	73 31                	jae    21b0b0 <Benchmark_reportStats+0x54b0>
  21b07f:	90                   	nop
  21b080:	48 89 fb             	mov    rbx,rdi
                items[j] = items[j - 1];
  21b083:	c5 f9 10 4b f0       	vmovupd xmm1,XMMWORD PTR [rbx-0x10]
  21b088:	c5 f9 11 0b          	vmovupd XMMWORD PTR [rbx],xmm1
            while (j > 0 and lessThan(x, items[j - 1])) : (j -= 1) {
  21b08c:	48 83 c2 01          	add    rdx,0x1
  21b090:	74 2e                	je     21b0c0 <Benchmark_reportStats+0x54c0>
  21b092:	48 8d 7b f0          	lea    rdi,[rbx-0x10]
  21b096:	48 3b 43 e0          	cmp    rax,QWORD PTR [rbx-0x20]
  21b09a:	72 e4                	jb     21b080 <Benchmark_reportStats+0x5480>
  21b09c:	48 83 c3 f0          	add    rbx,0xfffffffffffffff0
  21b0a0:	eb 21                	jmp    21b0c3 <Benchmark_reportStats+0x54c3>
  21b0a2:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21b0a9:	1f 84 00 00 00 00 00 
  21b0b0:	49 8d 1c 09          	lea    rbx,[r9+rcx*1]
  21b0b4:	eb 0d                	jmp    21b0c3 <Benchmark_reportStats+0x54c3>
  21b0b6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  21b0bd:	00 00 00 
  21b0c0:	4c 89 cb             	mov    rbx,r9
            items[j] = x;
  21b0c3:	c5 fa 7f 03          	vmovdqu XMMWORD PTR [rbx],xmm0
            const x = items[i];
  21b0c7:	c4 c1 7a 6f 44 09 10 	vmovdqu xmm0,XMMWORD PTR [r9+rcx*1+0x10]
  21b0ce:	c4 e1 f9 7e c3       	vmovq  rbx,xmm0
  21b0d3:	49 3b 1c 09          	cmp    rbx,QWORD PTR [r9+rcx*1]
            while (j > 0 and lessThan(x, items[j - 1])) : (j -= 1) {
  21b0d7:	73 37                	jae    21b110 <Benchmark_reportStats+0x5510>
  21b0d9:	4c 89 f0             	mov    rax,r14
  21b0dc:	4c 89 da             	mov    rdx,r11
  21b0df:	90                   	nop
  21b0e0:	48 89 d1             	mov    rcx,rdx
                items[j] = items[j - 1];
  21b0e3:	c5 f9 10 49 f0       	vmovupd xmm1,XMMWORD PTR [rcx-0x10]
  21b0e8:	c5 f9 11 09          	vmovupd XMMWORD PTR [rcx],xmm1
            while (j > 0 and lessThan(x, items[j - 1])) : (j -= 1) {
  21b0ec:	48 83 c0 01          	add    rax,0x1
  21b0f0:	74 2e                	je     21b120 <Benchmark_reportStats+0x5520>
  21b0f2:	48 8d 51 f0          	lea    rdx,[rcx-0x10]
  21b0f6:	48 3b 59 e0          	cmp    rbx,QWORD PTR [rcx-0x20]
  21b0fa:	72 e4                	jb     21b0e0 <Benchmark_reportStats+0x54e0>
  21b0fc:	48 83 c1 f0          	add    rcx,0xfffffffffffffff0
  21b100:	eb 21                	jmp    21b123 <Benchmark_reportStats+0x5523>
  21b102:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21b109:	1f 84 00 00 00 00 00 
  21b110:	4c 01 c9             	add    rcx,r9
  21b113:	48 83 c1 10          	add    rcx,0x10
  21b117:	eb 0a                	jmp    21b123 <Benchmark_reportStats+0x5523>
  21b119:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  21b120:	4c 89 c9             	mov    rcx,r9
            items[j] = x;
  21b123:	c5 fa 7f 01          	vmovdqu XMMWORD PTR [rcx],xmm0
        while (i < items.len) : (i += 1) {
  21b127:	48 83 c6 02          	add    rsi,0x2
  21b12b:	49 83 c7 20          	add    r15,0x20
  21b12f:	49 83 c4 fe          	add    r12,0xfffffffffffffffe
  21b133:	49 83 c3 20          	add    r11,0x20
  21b137:	49 83 c6 fe          	add    r14,0xfffffffffffffffe
  21b13b:	49 83 c2 fe          	add    r10,0xfffffffffffffffe
  21b13f:	0f 85 1b ff ff ff    	jne    21b060 <Benchmark_reportStats+0x5460>
            while (j > 0 and lessThan(x, items[j - 1])) : (j -= 1) {
  21b145:	4d 85 c0             	test   r8,r8
  21b148:	0f 84 8a 00 00 00    	je     21b1d8 <Benchmark_reportStats+0x55d8>
            const x = items[i];
  21b14e:	48 89 f2             	mov    rdx,rsi
  21b151:	48 c1 e2 04          	shl    rdx,0x4
  21b155:	49 8d 04 11          	lea    rax,[r9+rdx*1]
  21b159:	c4 c1 7a 6f 04 11    	vmovdqu xmm0,XMMWORD PTR [r9+rdx*1]
  21b15f:	c4 e1 f9 7e c1       	vmovq  rcx,xmm0
  21b164:	49 3b 4c 11 f0       	cmp    rcx,QWORD PTR [r9+rdx*1-0x10]
            while (j > 0 and lessThan(x, items[j - 1])) : (j -= 1) {
  21b169:	73 69                	jae    21b1d4 <Benchmark_reportStats+0x55d4>
  21b16b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  21b170:	48 89 c2             	mov    rdx,rax
                items[j] = items[j - 1];
  21b173:	c5 f9 10 4a f0       	vmovupd xmm1,XMMWORD PTR [rdx-0x10]
  21b178:	c5 f9 11 0a          	vmovupd XMMWORD PTR [rdx],xmm1
            while (j > 0 and lessThan(x, items[j - 1])) : (j -= 1) {
  21b17c:	48 83 c6 ff          	add    rsi,0xffffffffffffffff
  21b180:	74 4f                	je     21b1d1 <Benchmark_reportStats+0x55d1>
  21b182:	48 8d 42 f0          	lea    rax,[rdx-0x10]
  21b186:	48 3b 4a e0          	cmp    rcx,QWORD PTR [rdx-0x20]
  21b18a:	72 e4                	jb     21b170 <Benchmark_reportStats+0x5570>
  21b18c:	48 83 c2 f0          	add    rdx,0xfffffffffffffff0
  21b190:	48 89 d0             	mov    rax,rdx
  21b193:	eb 3f                	jmp    21b1d4 <Benchmark_reportStats+0x55d4>
  21b195:	4c 89 6c 24 50       	mov    QWORD PTR [rsp+0x50],r13
  21b19a:	e9 46 cb ff ff       	jmp    217ce5 <Benchmark_reportStats+0x20e5>
                        if (pull[0].range.start == A.start) pull[0].range.end -= pull[1].count;
  21b19f:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
  21b1a4:	48 39 84 24 98 00 00 	cmp    QWORD PTR [rsp+0x98],rax
  21b1ab:	00 
  21b1ac:	75 10                	jne    21b1be <Benchmark_reportStats+0x55be>
  21b1ae:	48 8b 84 24 b8 00 00 	mov    rax,QWORD PTR [rsp+0xb8]
  21b1b5:	00 
  21b1b6:	48 29 84 24 a0 00 00 	sub    QWORD PTR [rsp+0xa0],rax
  21b1bd:	00 
                        buffer2 = Range.init(B.end - count, B.end);
  21b1be:	48 89 c8             	mov    rax,rcx
  21b1c1:	4c 29 c0             	sub    rax,r8
  21b1c4:	4c 89 ac 24 d0 00 00 	mov    QWORD PTR [rsp+0xd0],r13
  21b1cb:	00 
  21b1cc:	e9 14 cb ff ff       	jmp    217ce5 <Benchmark_reportStats+0x20e5>
  21b1d1:	4c 89 c8             	mov    rax,r9
            items[j] = x;
  21b1d4:	c5 fa 7f 00          	vmovdqu XMMWORD PTR [rax],xmm0
  21b1d8:	31 c0                	xor    eax,eax
  21b1da:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  21b1e0:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
                var unique = pull[pull_index].count * 2;
  21b1e5:	48 8d 04 80          	lea    rax,[rax+rax*4]
  21b1e9:	4c 8b 94 c4 90 00 00 	mov    r10,QWORD PTR [rsp+rax*8+0x90]
  21b1f0:	00 
  21b1f1:	4f 8d 34 12          	lea    r14,[r10+r10*1]
                if (pull[pull_index].from > pull[pull_index].to) {
  21b1f5:	48 8b 8c c4 88 00 00 	mov    rcx,QWORD PTR [rsp+rax*8+0x88]
  21b1fc:	00 
  21b1fd:	48 39 8c c4 80 00 00 	cmp    QWORD PTR [rsp+rax*8+0x80],rcx
  21b204:	00 
  21b205:	76 29                	jbe    21b230 <Benchmark_reportStats+0x5630>
                    while (buffer.length() > 0) {
  21b207:	4d 85 d2             	test   r10,r10
  21b20a:	0f 84 c2 0b 00 00    	je     21bdd2 <Benchmark_reportStats+0x61d2>
  21b210:	4c 8b a4 c4 98 00 00 	mov    r12,QWORD PTR [rsp+rax*8+0x98]
  21b217:	00 
                    var buffer = Range.init(pull[pull_index].range.start, pull[pull_index].range.start + pull[pull_index].count);
  21b218:	4b 8d 0c 14          	lea    rcx,[r12+r10*1]
  21b21c:	48 8d 04 c4          	lea    rax,[rsp+rax*8]
  21b220:	48 05 a0 00 00 00    	add    rax,0xa0
  21b226:	48 89 44 24 20       	mov    QWORD PTR [rsp+0x20],rax
  21b22b:	e9 d0 05 00 00       	jmp    21b800 <Benchmark_reportStats+0x5c00>
                } else if (pull[pull_index].from < pull[pull_index].to) {
  21b230:	0f 83 9c 0b 00 00    	jae    21bdd2 <Benchmark_reportStats+0x61d2>
                    while (buffer.length() > 0) {
  21b236:	4d 85 d2             	test   r10,r10
  21b239:	0f 84 93 0b 00 00    	je     21bdd2 <Benchmark_reportStats+0x61d2>
  21b23f:	4c 8b 9c c4 a0 00 00 	mov    r11,QWORD PTR [rsp+rax*8+0xa0]
  21b246:	00 
                    var buffer = Range.init(pull[pull_index].range.end - pull[pull_index].count, pull[pull_index].range.end);
  21b247:	4d 89 df             	mov    r15,r11
  21b24a:	4d 29 d7             	sub    r15,r10
  21b24d:	48 8d 04 c4          	lea    rax,[rsp+rax*8]
  21b251:	48 05 98 00 00 00    	add    rax,0x98
  21b257:	48 89 44 24 38       	mov    QWORD PTR [rsp+0x38],rax
  21b25c:	eb 12                	jmp    21b270 <Benchmark_reportStats+0x5670>
  21b25e:	48 89 d3             	mov    rbx,rdx
    if (range.start >= range.end) return range.end;
  21b261:	48 85 c0             	test   rax,rax
  21b264:	0f 85 af 00 00 00    	jne    21b319 <Benchmark_reportStats+0x5719>
  21b26a:	e9 6d 01 00 00       	jmp    21b3dc <Benchmark_reportStats+0x57dc>
  21b26f:	90                   	nop
  21b270:	4c 89 fe             	mov    rsi,r15
                        index = findLastBackward(T, items, items[buffer.end - 1], Range.init(pull[pull_index].range.start, buffer.start), lessThan, unique);
  21b273:	49 8d 7b ff          	lea    rdi,[r11-0x1]
  21b277:	4c 8b 6c 24 40       	mov    r13,QWORD PTR [rsp+0x40]
  21b27c:	48 8b 44 24 38       	mov    rax,QWORD PTR [rsp+0x38]
  21b281:	4c 8b 38             	mov    r15,QWORD PTR [rax]
    if (range.length() == 0) return range.start;
  21b284:	48 89 f0             	mov    rax,rsi
  21b287:	4c 29 f8             	sub    rax,r15
  21b28a:	48 89 7c 24 18       	mov    QWORD PTR [rsp+0x18],rdi
  21b28f:	0f 84 52 01 00 00    	je     21b3e7 <Benchmark_reportStats+0x57e7>
  21b295:	49 89 f8             	mov    r8,rdi
  21b298:	49 c1 e0 04          	shl    r8,0x4
  21b29c:	48 89 c1             	mov    rcx,rax
  21b29f:	4c 09 f1             	or     rcx,r14
  21b2a2:	48 c1 e9 20          	shr    rcx,0x20
  21b2a6:	74 08                	je     21b2b0 <Benchmark_reportStats+0x56b0>
  21b2a8:	31 d2                	xor    edx,edx
  21b2aa:	49 f7 f6             	div    r14
  21b2ad:	eb 06                	jmp    21b2b5 <Benchmark_reportStats+0x56b5>
  21b2af:	90                   	nop
  21b2b0:	31 d2                	xor    edx,edx
  21b2b2:	41 f7 f6             	div    r14d
  21b2b5:	4d 01 e8             	add    r8,r13
    return if (x > y) x else y;
  21b2b8:	48 83 f8 01          	cmp    rax,0x1
  21b2bc:	b9 01 00 00 00       	mov    ecx,0x1
  21b2c1:	48 0f 46 c1          	cmovbe rax,rcx
  21b2c5:	48 89 f3             	mov    rbx,rsi
  21b2c8:	48 29 c3             	sub    rbx,rax
    while (index > range.start and lessThan(value, items[index - 1])) : (index -= skip) {
  21b2cb:	4c 39 fb             	cmp    rbx,r15
  21b2ce:	0f 86 fc 00 00 00    	jbe    21b3d0 <Benchmark_reportStats+0x57d0>
  21b2d4:	4d 8b 08             	mov    r9,QWORD PTR [r8]
  21b2d7:	4a 8d 0c 38          	lea    rcx,[rax+r15*1]
  21b2db:	49 89 f2             	mov    r10,rsi
  21b2de:	66 90                	xchg   ax,ax
  21b2e0:	48 89 da             	mov    rdx,rbx
  21b2e3:	48 8d 7a ff          	lea    rdi,[rdx-0x1]
  21b2e7:	48 89 fb             	mov    rbx,rdi
  21b2ea:	48 c1 e3 04          	shl    rbx,0x4
  21b2ee:	4d 3b 4c 1d 00       	cmp    r9,QWORD PTR [r13+rbx*1+0x0]
  21b2f3:	0f 83 65 ff ff ff    	jae    21b25e <Benchmark_reportStats+0x565e>
        if (index < range.start + skip) {
  21b2f9:	48 39 ca             	cmp    rdx,rcx
  21b2fc:	0f 82 95 00 00 00    	jb     21b397 <Benchmark_reportStats+0x5797>
  21b302:	48 89 d3             	mov    rbx,rdx
  21b305:	48 29 c3             	sub    rbx,rax
  21b308:	49 89 d2             	mov    r10,rdx
    while (index > range.start and lessThan(value, items[index - 1])) : (index -= skip) {
  21b30b:	4c 39 fb             	cmp    rbx,r15
  21b30e:	77 d0                	ja     21b2e0 <Benchmark_reportStats+0x56e0>
    if (range.start >= range.end) return range.end;
  21b310:	48 85 c0             	test   rax,rax
  21b313:	0f 84 c3 00 00 00    	je     21b3dc <Benchmark_reportStats+0x57dc>
    var end = range.end - 1;
  21b319:	49 83 c2 ff          	add    r10,0xffffffffffffffff
    while (start < end) {
  21b31d:	49 39 da             	cmp    r10,rbx
  21b320:	76 46                	jbe    21b368 <Benchmark_reportStats+0x5768>
  21b322:	4d 8b 08             	mov    r9,QWORD PTR [r8]
  21b325:	4c 89 d1             	mov    rcx,r10
  21b328:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  21b32f:	00 
        const mid = start + (end - start) / 2;
  21b330:	48 89 ca             	mov    rdx,rcx
  21b333:	48 29 da             	sub    rdx,rbx
  21b336:	48 d1 ea             	shr    rdx,1
  21b339:	48 8d 04 1a          	lea    rax,[rdx+rbx*1]
  21b33d:	48 89 c7             	mov    rdi,rax
  21b340:	48 c1 e7 04          	shl    rdi,0x4
  21b344:	4d 3b 4c 3d 00       	cmp    r9,QWORD PTR [r13+rdi*1+0x0]
        if (!lessThan(value, items[mid])) {
  21b349:	72 15                	jb     21b360 <Benchmark_reportStats+0x5760>
  21b34b:	48 01 d3             	add    rbx,rdx
  21b34e:	48 83 c3 01          	add    rbx,0x1
    while (start < end) {
  21b352:	48 39 d9             	cmp    rcx,rbx
  21b355:	77 d9                	ja     21b330 <Benchmark_reportStats+0x5730>
  21b357:	eb 0f                	jmp    21b368 <Benchmark_reportStats+0x5768>
  21b359:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
        if (!lessThan(value, items[mid])) {
  21b360:	48 89 c1             	mov    rcx,rax
    while (start < end) {
  21b363:	48 39 d9             	cmp    rcx,rbx
  21b366:	77 c8                	ja     21b330 <Benchmark_reportStats+0x5730>
    if (start == range.end - 1 and !lessThan(value, items[start])) {
  21b368:	4c 39 d3             	cmp    rbx,r10
  21b36b:	75 74                	jne    21b3e1 <Benchmark_reportStats+0x57e1>
  21b36d:	49 8b 00             	mov    rax,QWORD PTR [r8]
  21b370:	49 c1 e2 04          	shl    r10,0x4
  21b374:	45 31 ff             	xor    r15d,r15d
  21b377:	4b 3b 44 15 00       	cmp    rax,QWORD PTR [r13+r10*1+0x0]
  21b37c:	41 0f 93 c7          	setae  r15b
  21b380:	eb 62                	jmp    21b3e4 <Benchmark_reportStats+0x57e4>
  21b382:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21b389:	1f 84 00 00 00 00 00 
  21b390:	49 01 c7             	add    r15,rax
  21b393:	49 83 c7 01          	add    r15,0x1
    while (start < end) {
  21b397:	4c 39 ff             	cmp    rdi,r15
  21b39a:	76 4b                	jbe    21b3e7 <Benchmark_reportStats+0x57e7>
        const mid = start + (end - start) / 2;
  21b39c:	48 89 f8             	mov    rax,rdi
  21b39f:	4c 29 f8             	sub    rax,r15
  21b3a2:	48 d1 e8             	shr    rax,1
  21b3a5:	4a 8d 0c 38          	lea    rcx,[rax+r15*1]
  21b3a9:	48 89 ca             	mov    rdx,rcx
  21b3ac:	48 c1 e2 04          	shl    rdx,0x4
  21b3b0:	4d 3b 4c 15 00       	cmp    r9,QWORD PTR [r13+rdx*1+0x0]
        if (!lessThan(value, items[mid])) {
  21b3b5:	73 d9                	jae    21b390 <Benchmark_reportStats+0x5790>
  21b3b7:	48 89 cf             	mov    rdi,rcx
    while (start < end) {
  21b3ba:	4c 39 ff             	cmp    rdi,r15
  21b3bd:	77 dd                	ja     21b39c <Benchmark_reportStats+0x579c>
  21b3bf:	eb 26                	jmp    21b3e7 <Benchmark_reportStats+0x57e7>
  21b3c1:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21b3c8:	0f 1f 84 00 00 00 00 
  21b3cf:	00 
  21b3d0:	49 89 f2             	mov    r10,rsi
    if (range.start >= range.end) return range.end;
  21b3d3:	48 85 c0             	test   rax,rax
  21b3d6:	0f 85 3d ff ff ff    	jne    21b319 <Benchmark_reportStats+0x5719>
  21b3dc:	4d 89 d7             	mov    r15,r10
  21b3df:	eb 06                	jmp    21b3e7 <Benchmark_reportStats+0x57e7>
  21b3e1:	45 31 ff             	xor    r15d,r15d
    if (start == range.end - 1 and !lessThan(value, items[start])) {
  21b3e4:	49 01 df             	add    r15,rbx
                        const amount = buffer.start - index;
  21b3e7:	49 89 f4             	mov    r12,rsi
  21b3ea:	4d 29 fc             	sub    r12,r15
                        mem.rotate(T, items[index..buffer.end], amount);
  21b3ed:	4d 89 fa             	mov    r10,r15
  21b3f0:	49 c1 e2 04          	shl    r10,0x4
  21b3f4:	4d 89 d8             	mov    r8,r11
  21b3f7:	4d 29 f8             	sub    r8,r15
    const end = items.len / 2;
  21b3fa:	4c 89 e7             	mov    rdi,r12
  21b3fd:	48 d1 ef             	shr    rdi,1
    while (i < end) : (i += 1) {
  21b400:	0f 84 32 01 00 00    	je     21b538 <Benchmark_reportStats+0x5938>
        swap(T, &items[i], &items[items.len - i - 1]);
  21b406:	48 8d 47 ff          	lea    rax,[rdi-0x1]
  21b40a:	89 fa                	mov    edx,edi
  21b40c:	83 e2 03             	and    edx,0x3
  21b40f:	48 83 f8 03          	cmp    rax,0x3
  21b413:	73 1b                	jae    21b430 <Benchmark_reportStats+0x5830>
  21b415:	31 c0                	xor    eax,eax
    while (i < end) : (i += 1) {
  21b417:	48 85 d2             	test   rdx,rdx
  21b41a:	0f 85 c6 00 00 00    	jne    21b4e6 <Benchmark_reportStats+0x58e6>
  21b420:	e9 13 01 00 00       	jmp    21b538 <Benchmark_reportStats+0x5938>
  21b425:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21b42c:	00 00 00 00 
        swap(T, &items[i], &items[items.len - i - 1]);
  21b430:	48 29 d7             	sub    rdi,rdx
  21b433:	4b 8d 0c 2a          	lea    rcx,[r10+r13*1]
  21b437:	48 83 c1 30          	add    rcx,0x30
  21b43b:	48 89 f0             	mov    rax,rsi
  21b43e:	48 c1 e0 04          	shl    rax,0x4
  21b442:	4e 8d 0c 28          	lea    r9,[rax+r13*1]
  21b446:	49 83 c1 f0          	add    r9,0xfffffffffffffff0
  21b44a:	31 c0                	xor    eax,eax
  21b44c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
    const tmp = a.*;
  21b450:	c5 f8 10 41 d0       	vmovups xmm0,XMMWORD PTR [rcx-0x30]
  21b455:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21b45a:	c4 c1 78 10 01       	vmovups xmm0,XMMWORD PTR [r9]
  21b45f:	c5 f8 11 41 d0       	vmovups XMMWORD PTR [rcx-0x30],xmm0
    b.* = tmp;
  21b464:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  21b469:	c4 c1 78 11 01       	vmovups XMMWORD PTR [r9],xmm0
    const tmp = a.*;
  21b46e:	c5 f8 10 41 e0       	vmovups xmm0,XMMWORD PTR [rcx-0x20]
  21b473:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21b478:	c4 c1 78 10 41 f0    	vmovups xmm0,XMMWORD PTR [r9-0x10]
  21b47e:	c5 f8 11 41 e0       	vmovups XMMWORD PTR [rcx-0x20],xmm0
    b.* = tmp;
  21b483:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  21b488:	c4 c1 78 11 41 f0    	vmovups XMMWORD PTR [r9-0x10],xmm0
    const tmp = a.*;
  21b48e:	c5 f8 10 41 f0       	vmovups xmm0,XMMWORD PTR [rcx-0x10]
  21b493:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21b498:	c4 c1 78 10 41 e0    	vmovups xmm0,XMMWORD PTR [r9-0x20]
  21b49e:	c5 f8 11 41 f0       	vmovups XMMWORD PTR [rcx-0x10],xmm0
    b.* = tmp;
  21b4a3:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  21b4a8:	c4 c1 78 11 41 e0    	vmovups XMMWORD PTR [r9-0x20],xmm0
    const tmp = a.*;
  21b4ae:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  21b4b2:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21b4b7:	c4 c1 78 10 41 d0    	vmovups xmm0,XMMWORD PTR [r9-0x30]
  21b4bd:	c5 f8 11 01          	vmovups XMMWORD PTR [rcx],xmm0
    b.* = tmp;
  21b4c1:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  21b4c6:	c4 c1 7a 7f 41 d0    	vmovdqu XMMWORD PTR [r9-0x30],xmm0
    while (i < end) : (i += 1) {
  21b4cc:	48 83 c0 04          	add    rax,0x4
  21b4d0:	48 83 c1 40          	add    rcx,0x40
  21b4d4:	49 83 c1 c0          	add    r9,0xffffffffffffffc0
  21b4d8:	48 39 c7             	cmp    rdi,rax
  21b4db:	0f 85 6f ff ff ff    	jne    21b450 <Benchmark_reportStats+0x5850>
  21b4e1:	48 85 d2             	test   rdx,rdx
  21b4e4:	74 52                	je     21b538 <Benchmark_reportStats+0x5938>
  21b4e6:	48 89 f1             	mov    rcx,rsi
  21b4e9:	48 29 c1             	sub    rcx,rax
  21b4ec:	48 c1 e1 04          	shl    rcx,0x4
  21b4f0:	4c 01 e9             	add    rcx,r13
  21b4f3:	48 83 c1 f0          	add    rcx,0xfffffffffffffff0
  21b4f7:	4c 01 f8             	add    rax,r15
  21b4fa:	48 c1 e0 04          	shl    rax,0x4
  21b4fe:	4c 01 e8             	add    rax,r13
  21b501:	48 f7 da             	neg    rdx
  21b504:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21b50b:	00 00 00 00 00 
    const tmp = a.*;
  21b510:	c5 f8 10 00          	vmovups xmm0,XMMWORD PTR [rax]
  21b514:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21b519:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  21b51d:	c5 f8 11 00          	vmovups XMMWORD PTR [rax],xmm0
    b.* = tmp;
  21b521:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  21b526:	c5 fa 7f 01          	vmovdqu XMMWORD PTR [rcx],xmm0
    while (i < end) : (i += 1) {
  21b52a:	48 83 c1 f0          	add    rcx,0xfffffffffffffff0
  21b52e:	48 83 c0 10          	add    rax,0x10
  21b532:	48 83 c2 01          	add    rdx,0x1
  21b536:	75 d8                	jne    21b510 <Benchmark_reportStats+0x5910>
    reverse(T, items[amount..]);
  21b538:	4c 89 c0             	mov    rax,r8
  21b53b:	4c 29 e0             	sub    rax,r12
    const end = items.len / 2;
  21b53e:	48 d1 e8             	shr    rax,1
  21b541:	4c 8b 4c 24 18       	mov    r9,QWORD PTR [rsp+0x18]
    while (i < end) : (i += 1) {
  21b546:	0f 84 2c 01 00 00    	je     21b678 <Benchmark_reportStats+0x5a78>
        swap(T, &items[i], &items[items.len - i - 1]);
  21b54c:	48 8d 48 ff          	lea    rcx,[rax-0x1]
  21b550:	89 c2                	mov    edx,eax
  21b552:	83 e2 03             	and    edx,0x3
  21b555:	48 83 f9 03          	cmp    rcx,0x3
  21b559:	73 15                	jae    21b570 <Benchmark_reportStats+0x5970>
  21b55b:	31 c9                	xor    ecx,ecx
    while (i < end) : (i += 1) {
  21b55d:	48 85 d2             	test   rdx,rdx
  21b560:	0f 85 c8 00 00 00    	jne    21b62e <Benchmark_reportStats+0x5a2e>
  21b566:	e9 0d 01 00 00       	jmp    21b678 <Benchmark_reportStats+0x5a78>
  21b56b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
        swap(T, &items[i], &items[items.len - i - 1]);
  21b570:	48 29 d0             	sub    rax,rdx
  21b573:	48 89 f1             	mov    rcx,rsi
  21b576:	48 c1 e1 04          	shl    rcx,0x4
  21b57a:	4a 8d 3c 29          	lea    rdi,[rcx+r13*1]
  21b57e:	48 83 c7 30          	add    rdi,0x30
  21b582:	4c 89 d9             	mov    rcx,r11
  21b585:	48 c1 e1 04          	shl    rcx,0x4
  21b589:	4a 8d 1c 29          	lea    rbx,[rcx+r13*1]
  21b58d:	48 83 c3 f0          	add    rbx,0xfffffffffffffff0
  21b591:	31 c9                	xor    ecx,ecx
  21b593:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21b59a:	84 00 00 00 00 00 
    const tmp = a.*;
  21b5a0:	c5 f8 10 47 d0       	vmovups xmm0,XMMWORD PTR [rdi-0x30]
  21b5a5:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21b5aa:	c5 f8 10 03          	vmovups xmm0,XMMWORD PTR [rbx]
  21b5ae:	c5 f8 11 47 d0       	vmovups XMMWORD PTR [rdi-0x30],xmm0
    b.* = tmp;
  21b5b3:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  21b5b8:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
    const tmp = a.*;
  21b5bc:	c5 f8 10 47 e0       	vmovups xmm0,XMMWORD PTR [rdi-0x20]
  21b5c1:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21b5c6:	c5 f8 10 43 f0       	vmovups xmm0,XMMWORD PTR [rbx-0x10]
  21b5cb:	c5 f8 11 47 e0       	vmovups XMMWORD PTR [rdi-0x20],xmm0
    b.* = tmp;
  21b5d0:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  21b5d5:	c5 f8 11 43 f0       	vmovups XMMWORD PTR [rbx-0x10],xmm0
    const tmp = a.*;
  21b5da:	c5 f8 10 47 f0       	vmovups xmm0,XMMWORD PTR [rdi-0x10]
  21b5df:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21b5e4:	c5 f8 10 43 e0       	vmovups xmm0,XMMWORD PTR [rbx-0x20]
  21b5e9:	c5 f8 11 47 f0       	vmovups XMMWORD PTR [rdi-0x10],xmm0
    b.* = tmp;
  21b5ee:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  21b5f3:	c5 f8 11 43 e0       	vmovups XMMWORD PTR [rbx-0x20],xmm0
    const tmp = a.*;
  21b5f8:	c5 f8 10 07          	vmovups xmm0,XMMWORD PTR [rdi]
  21b5fc:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21b601:	c5 f8 10 43 d0       	vmovups xmm0,XMMWORD PTR [rbx-0x30]
  21b606:	c5 f8 11 07          	vmovups XMMWORD PTR [rdi],xmm0
    b.* = tmp;
  21b60a:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  21b60f:	c5 fa 7f 43 d0       	vmovdqu XMMWORD PTR [rbx-0x30],xmm0
    while (i < end) : (i += 1) {
  21b614:	48 83 c1 04          	add    rcx,0x4
  21b618:	48 83 c7 40          	add    rdi,0x40
  21b61c:	48 83 c3 c0          	add    rbx,0xffffffffffffffc0
  21b620:	48 39 c8             	cmp    rax,rcx
  21b623:	0f 85 77 ff ff ff    	jne    21b5a0 <Benchmark_reportStats+0x59a0>
  21b629:	48 85 d2             	test   rdx,rdx
  21b62c:	74 4a                	je     21b678 <Benchmark_reportStats+0x5a78>
  21b62e:	4c 89 d8             	mov    rax,r11
  21b631:	48 29 c8             	sub    rax,rcx
  21b634:	48 c1 e0 04          	shl    rax,0x4
  21b638:	4c 01 e8             	add    rax,r13
  21b63b:	48 83 c0 f0          	add    rax,0xfffffffffffffff0
  21b63f:	48 01 ce             	add    rsi,rcx
  21b642:	48 c1 e6 04          	shl    rsi,0x4
  21b646:	4c 01 ee             	add    rsi,r13
  21b649:	48 f7 da             	neg    rdx
  21b64c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
    const tmp = a.*;
  21b650:	c5 f8 10 06          	vmovups xmm0,XMMWORD PTR [rsi]
  21b654:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21b659:	c5 f8 10 00          	vmovups xmm0,XMMWORD PTR [rax]
  21b65d:	c5 f8 11 06          	vmovups XMMWORD PTR [rsi],xmm0
    b.* = tmp;
  21b661:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  21b666:	c5 fa 7f 00          	vmovdqu XMMWORD PTR [rax],xmm0
    while (i < end) : (i += 1) {
  21b66a:	48 83 c0 f0          	add    rax,0xfffffffffffffff0
  21b66e:	48 83 c6 10          	add    rsi,0x10
  21b672:	48 83 c2 01          	add    rdx,0x1
  21b676:	75 d8                	jne    21b650 <Benchmark_reportStats+0x5a50>
    const end = items.len / 2;
  21b678:	4c 89 c2             	mov    rdx,r8
  21b67b:	48 d1 ea             	shr    rdx,1
    while (i < end) : (i += 1) {
  21b67e:	0f 84 5c 01 00 00    	je     21b7e0 <Benchmark_reportStats+0x5be0>
  21b684:	4b 8d 04 2a          	lea    rax,[r10+r13*1]
    const tmp = a.*;
  21b688:	c5 f8 10 00          	vmovups xmm0,XMMWORD PTR [rax]
  21b68c:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  21b691:	49 c1 e0 04          	shl    r8,0x4
    a.* = b.*;
  21b695:	c4 a1 78 10 44 00 f0 	vmovups xmm0,XMMWORD PTR [rax+r8*1-0x10]
  21b69c:	c5 f8 11 00          	vmovups XMMWORD PTR [rax],xmm0
    b.* = tmp;
  21b6a0:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  21b6a5:	c4 a1 7a 7f 44 00 f0 	vmovdqu XMMWORD PTR [rax+r8*1-0x10],xmm0
    while (i < end) : (i += 1) {
  21b6ac:	48 83 fa 01          	cmp    rdx,0x1
  21b6b0:	0f 84 2a 01 00 00    	je     21b7e0 <Benchmark_reportStats+0x5be0>
        swap(T, &items[i], &items[items.len - i - 1]);
  21b6b6:	8d 72 ff             	lea    esi,[rdx-0x1]
  21b6b9:	48 8d 42 fe          	lea    rax,[rdx-0x2]
  21b6bd:	83 e6 03             	and    esi,0x3
  21b6c0:	48 83 f8 03          	cmp    rax,0x3
  21b6c4:	73 13                	jae    21b6d9 <Benchmark_reportStats+0x5ad9>
  21b6c6:	b8 01 00 00 00       	mov    eax,0x1
    while (i < end) : (i += 1) {
  21b6cb:	48 85 f6             	test   rsi,rsi
  21b6ce:	0f 85 ba 00 00 00    	jne    21b78e <Benchmark_reportStats+0x5b8e>
  21b6d4:	e9 07 01 00 00       	jmp    21b7e0 <Benchmark_reportStats+0x5be0>
        swap(T, &items[i], &items[items.len - i - 1]);
  21b6d9:	4c 89 d8             	mov    rax,r11
  21b6dc:	48 c1 e0 04          	shl    rax,0x4
  21b6e0:	4a 8d 0c 28          	lea    rcx,[rax+r13*1]
  21b6e4:	48 83 c1 e0          	add    rcx,0xffffffffffffffe0
  21b6e8:	4b 8d 3c 2a          	lea    rdi,[r10+r13*1]
  21b6ec:	48 83 c7 40          	add    rdi,0x40
  21b6f0:	48 29 f2             	sub    rdx,rsi
  21b6f3:	b8 01 00 00 00       	mov    eax,0x1
  21b6f8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  21b6ff:	00 
    const tmp = a.*;
  21b700:	c5 f8 10 47 d0       	vmovups xmm0,XMMWORD PTR [rdi-0x30]
  21b705:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21b70a:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  21b70e:	c5 f8 11 47 d0       	vmovups XMMWORD PTR [rdi-0x30],xmm0
    b.* = tmp;
  21b713:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  21b718:	c5 f8 11 01          	vmovups XMMWORD PTR [rcx],xmm0
    const tmp = a.*;
  21b71c:	c5 f8 10 47 e0       	vmovups xmm0,XMMWORD PTR [rdi-0x20]
  21b721:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21b726:	c5 f8 10 41 f0       	vmovups xmm0,XMMWORD PTR [rcx-0x10]
  21b72b:	c5 f8 11 47 e0       	vmovups XMMWORD PTR [rdi-0x20],xmm0
    b.* = tmp;
  21b730:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  21b735:	c5 f8 11 41 f0       	vmovups XMMWORD PTR [rcx-0x10],xmm0
    const tmp = a.*;
  21b73a:	c5 f8 10 47 f0       	vmovups xmm0,XMMWORD PTR [rdi-0x10]
  21b73f:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21b744:	c5 f8 10 41 e0       	vmovups xmm0,XMMWORD PTR [rcx-0x20]
  21b749:	c5 f8 11 47 f0       	vmovups XMMWORD PTR [rdi-0x10],xmm0
    b.* = tmp;
  21b74e:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  21b753:	c5 f8 11 41 e0       	vmovups XMMWORD PTR [rcx-0x20],xmm0
    const tmp = a.*;
  21b758:	c5 f8 10 07          	vmovups xmm0,XMMWORD PTR [rdi]
  21b75c:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21b761:	c5 f8 10 41 d0       	vmovups xmm0,XMMWORD PTR [rcx-0x30]
  21b766:	c5 f8 11 07          	vmovups XMMWORD PTR [rdi],xmm0
    b.* = tmp;
  21b76a:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  21b76f:	c5 fa 7f 41 d0       	vmovdqu XMMWORD PTR [rcx-0x30],xmm0
    while (i < end) : (i += 1) {
  21b774:	48 83 c0 04          	add    rax,0x4
  21b778:	48 83 c1 c0          	add    rcx,0xffffffffffffffc0
  21b77c:	48 83 c7 40          	add    rdi,0x40
  21b780:	48 39 c2             	cmp    rdx,rax
  21b783:	0f 85 77 ff ff ff    	jne    21b700 <Benchmark_reportStats+0x5b00>
  21b789:	48 85 f6             	test   rsi,rsi
  21b78c:	74 52                	je     21b7e0 <Benchmark_reportStats+0x5be0>
  21b78e:	49 29 c3             	sub    r11,rax
  21b791:	49 c1 e3 04          	shl    r11,0x4
  21b795:	4b 8d 0c 2b          	lea    rcx,[r11+r13*1]
  21b799:	48 83 c1 f0          	add    rcx,0xfffffffffffffff0
  21b79d:	4c 01 f8             	add    rax,r15
  21b7a0:	48 c1 e0 04          	shl    rax,0x4
  21b7a4:	4c 01 e8             	add    rax,r13
  21b7a7:	48 f7 de             	neg    rsi
  21b7aa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
    const tmp = a.*;
  21b7b0:	c5 f8 10 00          	vmovups xmm0,XMMWORD PTR [rax]
  21b7b4:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21b7b9:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  21b7bd:	c5 f8 11 00          	vmovups XMMWORD PTR [rax],xmm0
    b.* = tmp;
  21b7c1:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  21b7c6:	c5 fa 7f 01          	vmovdqu XMMWORD PTR [rcx],xmm0
    while (i < end) : (i += 1) {
  21b7ca:	48 83 c1 f0          	add    rcx,0xfffffffffffffff0
  21b7ce:	48 83 c0 10          	add    rax,0x10
  21b7d2:	48 83 c6 01          	add    rsi,0x1
  21b7d6:	75 d8                	jne    21b7b0 <Benchmark_reportStats+0x5bb0>
  21b7d8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  21b7df:	00 
                        buffer.end -= (amount + 1);
  21b7e0:	4d 29 e1             	sub    r9,r12
                        unique -= 2;
  21b7e3:	49 83 c6 fe          	add    r14,0xfffffffffffffffe
  21b7e7:	4d 89 cb             	mov    r11,r9
                    while (buffer.length() > 0) {
  21b7ea:	4d 39 f9             	cmp    r9,r15
  21b7ed:	0f 85 7d fa ff ff    	jne    21b270 <Benchmark_reportStats+0x5670>
  21b7f3:	e9 da 05 00 00       	jmp    21bdd2 <Benchmark_reportStats+0x61d2>
  21b7f8:	31 c9                	xor    ecx,ecx
  21b7fa:	e9 1e 01 00 00       	jmp    21b91d <Benchmark_reportStats+0x5d1d>
  21b7ff:	90                   	nop
  21b800:	49 89 cf             	mov    r15,rcx
                        index = findFirstForward(T, items, items[buffer.start], Range.init(buffer.end, pull[pull_index].range.end), lessThan, unique);
  21b803:	4c 8b 5c 24 40       	mov    r11,QWORD PTR [rsp+0x40]
  21b808:	4c 89 e0             	mov    rax,r12
  21b80b:	48 c1 e0 04          	shl    rax,0x4
  21b80f:	48 89 44 24 38       	mov    QWORD PTR [rsp+0x38],rax
  21b814:	49 8d 04 03          	lea    rax,[r11+rax*1]
  21b818:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  21b81d:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
  21b822:	4c 8b 28             	mov    r13,QWORD PTR [rax]
    if (range.length() == 0) return range.start;
  21b825:	4c 89 e8             	mov    rax,r13
  21b828:	4c 29 f8             	sub    rax,r15
  21b82b:	0f 84 7f 01 00 00    	je     21b9b0 <Benchmark_reportStats+0x5db0>
  21b831:	48 89 c1             	mov    rcx,rax
  21b834:	4c 09 f1             	or     rcx,r14
  21b837:	48 c1 e9 20          	shr    rcx,0x20
  21b83b:	74 13                	je     21b850 <Benchmark_reportStats+0x5c50>
  21b83d:	31 d2                	xor    edx,edx
  21b83f:	49 f7 f6             	div    r14
  21b842:	eb 11                	jmp    21b855 <Benchmark_reportStats+0x5c55>
  21b844:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21b84b:	00 00 00 00 00 
  21b850:	31 d2                	xor    edx,edx
  21b852:	41 f7 f6             	div    r14d
  21b855:	48 83 f8 01          	cmp    rax,0x1
  21b859:	b9 01 00 00 00       	mov    ecx,0x1
  21b85e:	48 0f 46 c1          	cmovbe rax,rcx
  21b862:	4a 8d 0c 38          	lea    rcx,[rax+r15*1]
    while (lessThan(items[index - 1], value)) : (index += skip) {
  21b866:	4e 8d 04 38          	lea    r8,[rax+r15*1]
  21b86a:	49 83 c0 ff          	add    r8,0xffffffffffffffff
  21b86e:	4c 89 c2             	mov    rdx,r8
  21b871:	48 c1 e2 04          	shl    rdx,0x4
  21b875:	4d 8b 0c 13          	mov    r9,QWORD PTR [r11+rdx*1]
  21b879:	48 8b 54 24 18       	mov    rdx,QWORD PTR [rsp+0x18]
  21b87e:	48 8b 3a             	mov    rdi,QWORD PTR [rdx]
  21b881:	49 39 f9             	cmp    r9,rdi
  21b884:	0f 83 a6 00 00 00    	jae    21b930 <Benchmark_reportStats+0x5d30>
  21b88a:	4c 89 ee             	mov    rsi,r13
  21b88d:	48 29 c6             	sub    rsi,rax
  21b890:	48 89 ca             	mov    rdx,rcx
        if (index >= range.end - skip) {
  21b893:	48 39 f2             	cmp    rdx,rsi
  21b896:	0f 83 9e 00 00 00    	jae    21b93a <Benchmark_reportStats+0x5d3a>
  21b89c:	48 8d 0c 02          	lea    rcx,[rdx+rax*1]
    while (lessThan(items[index - 1], value)) : (index += skip) {
  21b8a0:	4c 8d 04 02          	lea    r8,[rdx+rax*1]
  21b8a4:	49 83 c0 ff          	add    r8,0xffffffffffffffff
  21b8a8:	4c 89 c3             	mov    rbx,r8
  21b8ab:	48 c1 e3 04          	shl    rbx,0x4
  21b8af:	4d 8b 0c 1b          	mov    r9,QWORD PTR [r11+rbx*1]
  21b8b3:	49 39 f9             	cmp    r9,rdi
  21b8b6:	72 d8                	jb     21b890 <Benchmark_reportStats+0x5c90>
    if (range.start >= range.end) return range.end;
  21b8b8:	48 85 c0             	test   rax,rax
  21b8bb:	0f 84 ef 00 00 00    	je     21b9b0 <Benchmark_reportStats+0x5db0>
    while (start < end) {
  21b8c1:	49 39 d0             	cmp    r8,rdx
  21b8c4:	76 46                	jbe    21b90c <Benchmark_reportStats+0x5d0c>
  21b8c6:	4c 89 c0             	mov    rax,r8
  21b8c9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
        const mid = start + (end - start) / 2;
  21b8d0:	48 89 c1             	mov    rcx,rax
  21b8d3:	48 29 d1             	sub    rcx,rdx
  21b8d6:	48 d1 e9             	shr    rcx,1
  21b8d9:	48 8d 34 11          	lea    rsi,[rcx+rdx*1]
  21b8dd:	48 89 f3             	mov    rbx,rsi
  21b8e0:	48 c1 e3 04          	shl    rbx,0x4
  21b8e4:	49 39 3c 1b          	cmp    QWORD PTR [r11+rbx*1],rdi
        if (lessThan(items[mid], value)) {
  21b8e8:	72 16                	jb     21b900 <Benchmark_reportStats+0x5d00>
  21b8ea:	48 89 f0             	mov    rax,rsi
    while (start < end) {
  21b8ed:	48 39 d0             	cmp    rax,rdx
  21b8f0:	77 de                	ja     21b8d0 <Benchmark_reportStats+0x5cd0>
  21b8f2:	eb 18                	jmp    21b90c <Benchmark_reportStats+0x5d0c>
  21b8f4:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21b8fb:	00 00 00 00 00 
  21b900:	48 01 ca             	add    rdx,rcx
  21b903:	48 83 c2 01          	add    rdx,0x1
  21b907:	48 39 d0             	cmp    rax,rdx
  21b90a:	77 c4                	ja     21b8d0 <Benchmark_reportStats+0x5cd0>
    if (start == range.end - 1 and lessThan(items[start], value)) {
  21b90c:	4c 39 c2             	cmp    rdx,r8
  21b90f:	0f 94 c0             	sete   al
  21b912:	49 39 f9             	cmp    r9,rdi
  21b915:	0f 92 c1             	setb   cl
  21b918:	20 c1                	and    cl,al
  21b91a:	0f b6 c9             	movzx  ecx,cl
  21b91d:	48 01 d1             	add    rcx,rdx
  21b920:	e9 8b 00 00 00       	jmp    21b9b0 <Benchmark_reportStats+0x5db0>
  21b925:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21b92c:	00 00 00 00 
  21b930:	4c 89 fa             	mov    rdx,r15
    if (range.start >= range.end) return range.end;
  21b933:	48 85 c0             	test   rax,rax
  21b936:	75 89                	jne    21b8c1 <Benchmark_reportStats+0x5cc1>
  21b938:	eb 76                	jmp    21b9b0 <Benchmark_reportStats+0x5db0>
  21b93a:	4c 39 ea             	cmp    rdx,r13
  21b93d:	73 68                	jae    21b9a7 <Benchmark_reportStats+0x5da7>
    var end = range.end - 1;
  21b93f:	49 83 c5 ff          	add    r13,0xffffffffffffffff
    while (start < end) {
  21b943:	49 39 d5             	cmp    r13,rdx
  21b946:	76 44                	jbe    21b98c <Benchmark_reportStats+0x5d8c>
  21b948:	4c 89 e8             	mov    rax,r13
  21b94b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
        const mid = start + (end - start) / 2;
  21b950:	48 89 c1             	mov    rcx,rax
  21b953:	48 29 d1             	sub    rcx,rdx
  21b956:	48 d1 e9             	shr    rcx,1
  21b959:	48 8d 1c 11          	lea    rbx,[rcx+rdx*1]
  21b95d:	48 89 de             	mov    rsi,rbx
  21b960:	48 c1 e6 04          	shl    rsi,0x4
  21b964:	49 39 3c 33          	cmp    QWORD PTR [r11+rsi*1],rdi
        if (lessThan(items[mid], value)) {
  21b968:	72 16                	jb     21b980 <Benchmark_reportStats+0x5d80>
  21b96a:	48 89 d8             	mov    rax,rbx
    while (start < end) {
  21b96d:	48 39 d0             	cmp    rax,rdx
  21b970:	77 de                	ja     21b950 <Benchmark_reportStats+0x5d50>
  21b972:	eb 18                	jmp    21b98c <Benchmark_reportStats+0x5d8c>
  21b974:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21b97b:	00 00 00 00 00 
  21b980:	48 01 ca             	add    rdx,rcx
  21b983:	48 83 c2 01          	add    rdx,0x1
  21b987:	48 39 d0             	cmp    rax,rdx
  21b98a:	77 c4                	ja     21b950 <Benchmark_reportStats+0x5d50>
    if (start == range.end - 1 and lessThan(items[start], value)) {
  21b98c:	4c 39 ea             	cmp    rdx,r13
  21b98f:	0f 85 63 fe ff ff    	jne    21b7f8 <Benchmark_reportStats+0x5bf8>
  21b995:	49 c1 e5 04          	shl    r13,0x4
  21b999:	31 c9                	xor    ecx,ecx
  21b99b:	4b 39 3c 2b          	cmp    QWORD PTR [r11+r13*1],rdi
  21b99f:	0f 92 c1             	setb   cl
  21b9a2:	e9 76 ff ff ff       	jmp    21b91d <Benchmark_reportStats+0x5d1d>
  21b9a7:	4c 89 e9             	mov    rcx,r13
  21b9aa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
                        mem.rotate(T, items[buffer.start..index], buffer.length());
  21b9b0:	49 89 c8             	mov    r8,rcx
  21b9b3:	4d 29 e0             	sub    r8,r12
    const end = items.len / 2;
  21b9b6:	4c 89 d0             	mov    rax,r10
  21b9b9:	48 d1 e8             	shr    rax,1
    while (i < end) : (i += 1) {
  21b9bc:	0f 84 36 01 00 00    	je     21baf8 <Benchmark_reportStats+0x5ef8>
        swap(T, &items[i], &items[items.len - i - 1]);
  21b9c2:	48 8d 70 ff          	lea    rsi,[rax-0x1]
  21b9c6:	89 c2                	mov    edx,eax
  21b9c8:	83 e2 03             	and    edx,0x3
  21b9cb:	48 83 fe 03          	cmp    rsi,0x3
  21b9cf:	73 1f                	jae    21b9f0 <Benchmark_reportStats+0x5df0>
  21b9d1:	31 ff                	xor    edi,edi
    while (i < end) : (i += 1) {
  21b9d3:	48 85 d2             	test   rdx,rdx
  21b9d6:	0f 85 d2 00 00 00    	jne    21baae <Benchmark_reportStats+0x5eae>
  21b9dc:	e9 17 01 00 00       	jmp    21baf8 <Benchmark_reportStats+0x5ef8>
  21b9e1:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21b9e8:	0f 1f 84 00 00 00 00 
  21b9ef:	00 
        swap(T, &items[i], &items[items.len - i - 1]);
  21b9f0:	48 29 d0             	sub    rax,rdx
  21b9f3:	48 8b 74 24 38       	mov    rsi,QWORD PTR [rsp+0x38]
  21b9f8:	49 8d 1c 33          	lea    rbx,[r11+rsi*1]
  21b9fc:	48 83 c3 30          	add    rbx,0x30
  21ba00:	4b 8d 34 22          	lea    rsi,[r10+r12*1]
  21ba04:	48 c1 e6 04          	shl    rsi,0x4
  21ba08:	4c 01 de             	add    rsi,r11
  21ba0b:	48 83 c6 f0          	add    rsi,0xfffffffffffffff0
  21ba0f:	31 ff                	xor    edi,edi
  21ba11:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21ba18:	0f 1f 84 00 00 00 00 
  21ba1f:	00 
    const tmp = a.*;
  21ba20:	c5 f8 10 43 d0       	vmovups xmm0,XMMWORD PTR [rbx-0x30]
  21ba25:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21ba2a:	c5 f8 10 06          	vmovups xmm0,XMMWORD PTR [rsi]
  21ba2e:	c5 f8 11 43 d0       	vmovups XMMWORD PTR [rbx-0x30],xmm0
    b.* = tmp;
  21ba33:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  21ba38:	c5 f8 11 06          	vmovups XMMWORD PTR [rsi],xmm0
    const tmp = a.*;
  21ba3c:	c5 f8 10 43 e0       	vmovups xmm0,XMMWORD PTR [rbx-0x20]
  21ba41:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21ba46:	c5 f8 10 46 f0       	vmovups xmm0,XMMWORD PTR [rsi-0x10]
  21ba4b:	c5 f8 11 43 e0       	vmovups XMMWORD PTR [rbx-0x20],xmm0
    b.* = tmp;
  21ba50:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  21ba55:	c5 f8 11 46 f0       	vmovups XMMWORD PTR [rsi-0x10],xmm0
    const tmp = a.*;
  21ba5a:	c5 f8 10 43 f0       	vmovups xmm0,XMMWORD PTR [rbx-0x10]
  21ba5f:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21ba64:	c5 f8 10 46 e0       	vmovups xmm0,XMMWORD PTR [rsi-0x20]
  21ba69:	c5 f8 11 43 f0       	vmovups XMMWORD PTR [rbx-0x10],xmm0
    b.* = tmp;
  21ba6e:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  21ba73:	c5 f8 11 46 e0       	vmovups XMMWORD PTR [rsi-0x20],xmm0
    const tmp = a.*;
  21ba78:	c5 f8 10 03          	vmovups xmm0,XMMWORD PTR [rbx]
  21ba7c:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21ba81:	c5 f8 10 46 d0       	vmovups xmm0,XMMWORD PTR [rsi-0x30]
  21ba86:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
    b.* = tmp;
  21ba8a:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  21ba8f:	c5 fa 7f 46 d0       	vmovdqu XMMWORD PTR [rsi-0x30],xmm0
    while (i < end) : (i += 1) {
  21ba94:	48 83 c7 04          	add    rdi,0x4
  21ba98:	48 83 c3 40          	add    rbx,0x40
  21ba9c:	48 83 c6 c0          	add    rsi,0xffffffffffffffc0
  21baa0:	48 39 f8             	cmp    rax,rdi
  21baa3:	0f 85 77 ff ff ff    	jne    21ba20 <Benchmark_reportStats+0x5e20>
  21baa9:	48 85 d2             	test   rdx,rdx
  21baac:	74 4a                	je     21baf8 <Benchmark_reportStats+0x5ef8>
  21baae:	4b 8d 04 22          	lea    rax,[r10+r12*1]
  21bab2:	48 29 f8             	sub    rax,rdi
  21bab5:	48 c1 e0 04          	shl    rax,0x4
  21bab9:	4c 01 d8             	add    rax,r11
  21babc:	48 83 c0 f0          	add    rax,0xfffffffffffffff0
  21bac0:	4c 01 e7             	add    rdi,r12
  21bac3:	48 c1 e7 04          	shl    rdi,0x4
  21bac7:	4c 01 df             	add    rdi,r11
  21baca:	48 f7 da             	neg    rdx
  21bacd:	0f 1f 00             	nop    DWORD PTR [rax]
    const tmp = a.*;
  21bad0:	c5 f8 10 07          	vmovups xmm0,XMMWORD PTR [rdi]
  21bad4:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21bad9:	c5 f8 10 00          	vmovups xmm0,XMMWORD PTR [rax]
  21badd:	c5 f8 11 07          	vmovups XMMWORD PTR [rdi],xmm0
    b.* = tmp;
  21bae1:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  21bae6:	c5 fa 7f 00          	vmovdqu XMMWORD PTR [rax],xmm0
    while (i < end) : (i += 1) {
  21baea:	48 83 c0 f0          	add    rax,0xfffffffffffffff0
  21baee:	48 83 c7 10          	add    rdi,0x10
  21baf2:	48 83 c2 01          	add    rdx,0x1
  21baf6:	75 d8                	jne    21bad0 <Benchmark_reportStats+0x5ed0>
    reverse(T, items[amount..]);
  21baf8:	4c 89 c0             	mov    rax,r8
  21bafb:	4c 29 d0             	sub    rax,r10
    const end = items.len / 2;
  21bafe:	48 d1 e8             	shr    rax,1
    while (i < end) : (i += 1) {
  21bb01:	0f 84 41 01 00 00    	je     21bc48 <Benchmark_reportStats+0x6048>
        swap(T, &items[i], &items[items.len - i - 1]);
  21bb07:	48 8d 70 ff          	lea    rsi,[rax-0x1]
  21bb0b:	89 c2                	mov    edx,eax
  21bb0d:	83 e2 03             	and    edx,0x3
  21bb10:	48 83 fe 03          	cmp    rsi,0x3
  21bb14:	73 1a                	jae    21bb30 <Benchmark_reportStats+0x5f30>
  21bb16:	31 ff                	xor    edi,edi
    while (i < end) : (i += 1) {
  21bb18:	48 85 d2             	test   rdx,rdx
  21bb1b:	0f 85 cd 00 00 00    	jne    21bbee <Benchmark_reportStats+0x5fee>
  21bb21:	e9 22 01 00 00       	jmp    21bc48 <Benchmark_reportStats+0x6048>
  21bb26:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  21bb2d:	00 00 00 
        swap(T, &items[i], &items[items.len - i - 1]);
  21bb30:	48 29 d0             	sub    rax,rdx
  21bb33:	4c 89 fe             	mov    rsi,r15
  21bb36:	48 c1 e6 04          	shl    rsi,0x4
  21bb3a:	49 8d 1c 33          	lea    rbx,[r11+rsi*1]
  21bb3e:	48 83 c3 30          	add    rbx,0x30
  21bb42:	4a 8d 34 39          	lea    rsi,[rcx+r15*1]
  21bb46:	4b 8d 3c 22          	lea    rdi,[r10+r12*1]
  21bb4a:	48 29 fe             	sub    rsi,rdi
  21bb4d:	48 c1 e6 04          	shl    rsi,0x4
  21bb51:	4c 01 de             	add    rsi,r11
  21bb54:	48 83 c6 f0          	add    rsi,0xfffffffffffffff0
  21bb58:	31 ff                	xor    edi,edi
  21bb5a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
    const tmp = a.*;
  21bb60:	c5 f8 10 43 d0       	vmovups xmm0,XMMWORD PTR [rbx-0x30]
  21bb65:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21bb6a:	c5 f8 10 06          	vmovups xmm0,XMMWORD PTR [rsi]
  21bb6e:	c5 f8 11 43 d0       	vmovups XMMWORD PTR [rbx-0x30],xmm0
    b.* = tmp;
  21bb73:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  21bb78:	c5 f8 11 06          	vmovups XMMWORD PTR [rsi],xmm0
    const tmp = a.*;
  21bb7c:	c5 f8 10 43 e0       	vmovups xmm0,XMMWORD PTR [rbx-0x20]
  21bb81:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21bb86:	c5 f8 10 46 f0       	vmovups xmm0,XMMWORD PTR [rsi-0x10]
  21bb8b:	c5 f8 11 43 e0       	vmovups XMMWORD PTR [rbx-0x20],xmm0
    b.* = tmp;
  21bb90:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  21bb95:	c5 f8 11 46 f0       	vmovups XMMWORD PTR [rsi-0x10],xmm0
    const tmp = a.*;
  21bb9a:	c5 f8 10 43 f0       	vmovups xmm0,XMMWORD PTR [rbx-0x10]
  21bb9f:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21bba4:	c5 f8 10 46 e0       	vmovups xmm0,XMMWORD PTR [rsi-0x20]
  21bba9:	c5 f8 11 43 f0       	vmovups XMMWORD PTR [rbx-0x10],xmm0
    b.* = tmp;
  21bbae:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  21bbb3:	c5 f8 11 46 e0       	vmovups XMMWORD PTR [rsi-0x20],xmm0
    const tmp = a.*;
  21bbb8:	c5 f8 10 03          	vmovups xmm0,XMMWORD PTR [rbx]
  21bbbc:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21bbc1:	c5 f8 10 46 d0       	vmovups xmm0,XMMWORD PTR [rsi-0x30]
  21bbc6:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
    b.* = tmp;
  21bbca:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  21bbcf:	c5 fa 7f 46 d0       	vmovdqu XMMWORD PTR [rsi-0x30],xmm0
    while (i < end) : (i += 1) {
  21bbd4:	48 83 c7 04          	add    rdi,0x4
  21bbd8:	48 83 c3 40          	add    rbx,0x40
  21bbdc:	48 83 c6 c0          	add    rsi,0xffffffffffffffc0
  21bbe0:	48 39 f8             	cmp    rax,rdi
  21bbe3:	0f 85 77 ff ff ff    	jne    21bb60 <Benchmark_reportStats+0x5f60>
  21bbe9:	48 85 d2             	test   rdx,rdx
  21bbec:	74 5a                	je     21bc48 <Benchmark_reportStats+0x6048>
  21bbee:	4a 8d 04 39          	lea    rax,[rcx+r15*1]
  21bbf2:	4d 01 e2             	add    r10,r12
  21bbf5:	49 01 fa             	add    r10,rdi
  21bbf8:	4c 29 d0             	sub    rax,r10
  21bbfb:	48 c1 e0 04          	shl    rax,0x4
  21bbff:	4c 01 d8             	add    rax,r11
  21bc02:	48 83 c0 f0          	add    rax,0xfffffffffffffff0
  21bc06:	4c 01 ff             	add    rdi,r15
  21bc09:	48 c1 e7 04          	shl    rdi,0x4
  21bc0d:	4c 01 df             	add    rdi,r11
  21bc10:	48 f7 da             	neg    rdx
  21bc13:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21bc1a:	84 00 00 00 00 00 
    const tmp = a.*;
  21bc20:	c5 f8 10 07          	vmovups xmm0,XMMWORD PTR [rdi]
  21bc24:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21bc29:	c5 f8 10 00          	vmovups xmm0,XMMWORD PTR [rax]
  21bc2d:	c5 f8 11 07          	vmovups XMMWORD PTR [rdi],xmm0
    b.* = tmp;
  21bc31:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  21bc36:	c5 fa 7f 00          	vmovdqu XMMWORD PTR [rax],xmm0
    while (i < end) : (i += 1) {
  21bc3a:	48 83 c0 f0          	add    rax,0xfffffffffffffff0
  21bc3e:	48 83 c7 10          	add    rdi,0x10
  21bc42:	48 83 c2 01          	add    rdx,0x1
  21bc46:	75 d8                	jne    21bc20 <Benchmark_reportStats+0x6020>
    const end = items.len / 2;
  21bc48:	4c 89 c6             	mov    rsi,r8
  21bc4b:	48 d1 ee             	shr    rsi,1
    while (i < end) : (i += 1) {
  21bc4e:	0f 84 5c 01 00 00    	je     21bdb0 <Benchmark_reportStats+0x61b0>
  21bc54:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
    const tmp = a.*;
  21bc59:	c5 f8 10 00          	vmovups xmm0,XMMWORD PTR [rax]
  21bc5d:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  21bc62:	49 c1 e0 04          	shl    r8,0x4
    a.* = b.*;
  21bc66:	c4 a1 78 10 44 00 f0 	vmovups xmm0,XMMWORD PTR [rax+r8*1-0x10]
  21bc6d:	c5 f8 11 00          	vmovups XMMWORD PTR [rax],xmm0
    b.* = tmp;
  21bc71:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  21bc76:	c4 a1 7a 7f 44 00 f0 	vmovdqu XMMWORD PTR [rax+r8*1-0x10],xmm0
    while (i < end) : (i += 1) {
  21bc7d:	48 83 fe 01          	cmp    rsi,0x1
  21bc81:	0f 84 29 01 00 00    	je     21bdb0 <Benchmark_reportStats+0x61b0>
        swap(T, &items[i], &items[items.len - i - 1]);
  21bc87:	8d 46 ff             	lea    eax,[rsi-0x1]
  21bc8a:	48 8d 56 fe          	lea    rdx,[rsi-0x2]
  21bc8e:	83 e0 03             	and    eax,0x3
  21bc91:	48 83 fa 03          	cmp    rdx,0x3
  21bc95:	73 13                	jae    21bcaa <Benchmark_reportStats+0x60aa>
  21bc97:	ba 01 00 00 00       	mov    edx,0x1
    while (i < end) : (i += 1) {
  21bc9c:	48 85 c0             	test   rax,rax
  21bc9f:	0f 85 b9 00 00 00    	jne    21bd5e <Benchmark_reportStats+0x615e>
  21bca5:	e9 06 01 00 00       	jmp    21bdb0 <Benchmark_reportStats+0x61b0>
        swap(T, &items[i], &items[items.len - i - 1]);
  21bcaa:	48 89 ca             	mov    rdx,rcx
  21bcad:	48 c1 e2 04          	shl    rdx,0x4
  21bcb1:	49 8d 3c 13          	lea    rdi,[r11+rdx*1]
  21bcb5:	48 83 c7 e0          	add    rdi,0xffffffffffffffe0
  21bcb9:	48 8b 54 24 38       	mov    rdx,QWORD PTR [rsp+0x38]
  21bcbe:	49 8d 1c 13          	lea    rbx,[r11+rdx*1]
  21bcc2:	48 83 c3 40          	add    rbx,0x40
  21bcc6:	48 29 c6             	sub    rsi,rax
  21bcc9:	ba 01 00 00 00       	mov    edx,0x1
  21bcce:	66 90                	xchg   ax,ax
    const tmp = a.*;
  21bcd0:	c5 f8 10 43 d0       	vmovups xmm0,XMMWORD PTR [rbx-0x30]
  21bcd5:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21bcda:	c5 f8 10 07          	vmovups xmm0,XMMWORD PTR [rdi]
  21bcde:	c5 f8 11 43 d0       	vmovups XMMWORD PTR [rbx-0x30],xmm0
    b.* = tmp;
  21bce3:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  21bce8:	c5 f8 11 07          	vmovups XMMWORD PTR [rdi],xmm0
    const tmp = a.*;
  21bcec:	c5 f8 10 43 e0       	vmovups xmm0,XMMWORD PTR [rbx-0x20]
  21bcf1:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21bcf6:	c5 f8 10 47 f0       	vmovups xmm0,XMMWORD PTR [rdi-0x10]
  21bcfb:	c5 f8 11 43 e0       	vmovups XMMWORD PTR [rbx-0x20],xmm0
    b.* = tmp;
  21bd00:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  21bd05:	c5 f8 11 47 f0       	vmovups XMMWORD PTR [rdi-0x10],xmm0
    const tmp = a.*;
  21bd0a:	c5 f8 10 43 f0       	vmovups xmm0,XMMWORD PTR [rbx-0x10]
  21bd0f:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21bd14:	c5 f8 10 47 e0       	vmovups xmm0,XMMWORD PTR [rdi-0x20]
  21bd19:	c5 f8 11 43 f0       	vmovups XMMWORD PTR [rbx-0x10],xmm0
    b.* = tmp;
  21bd1e:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  21bd23:	c5 f8 11 47 e0       	vmovups XMMWORD PTR [rdi-0x20],xmm0
    const tmp = a.*;
  21bd28:	c5 f8 10 03          	vmovups xmm0,XMMWORD PTR [rbx]
  21bd2c:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21bd31:	c5 f8 10 47 d0       	vmovups xmm0,XMMWORD PTR [rdi-0x30]
  21bd36:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
    b.* = tmp;
  21bd3a:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  21bd3f:	c5 fa 7f 47 d0       	vmovdqu XMMWORD PTR [rdi-0x30],xmm0
    while (i < end) : (i += 1) {
  21bd44:	48 83 c2 04          	add    rdx,0x4
  21bd48:	48 83 c7 c0          	add    rdi,0xffffffffffffffc0
  21bd4c:	48 83 c3 40          	add    rbx,0x40
  21bd50:	48 39 d6             	cmp    rsi,rdx
  21bd53:	0f 85 77 ff ff ff    	jne    21bcd0 <Benchmark_reportStats+0x60d0>
  21bd59:	48 85 c0             	test   rax,rax
  21bd5c:	74 52                	je     21bdb0 <Benchmark_reportStats+0x61b0>
  21bd5e:	48 89 ce             	mov    rsi,rcx
  21bd61:	48 29 d6             	sub    rsi,rdx
  21bd64:	48 c1 e6 04          	shl    rsi,0x4
  21bd68:	4c 01 de             	add    rsi,r11
  21bd6b:	48 83 c6 f0          	add    rsi,0xfffffffffffffff0
  21bd6f:	4c 01 e2             	add    rdx,r12
  21bd72:	48 c1 e2 04          	shl    rdx,0x4
  21bd76:	4c 01 da             	add    rdx,r11
  21bd79:	48 f7 d8             	neg    rax
  21bd7c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
    const tmp = a.*;
  21bd80:	c5 f8 10 02          	vmovups xmm0,XMMWORD PTR [rdx]
  21bd84:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21bd89:	c5 f8 10 06          	vmovups xmm0,XMMWORD PTR [rsi]
  21bd8d:	c5 f8 11 02          	vmovups XMMWORD PTR [rdx],xmm0
    b.* = tmp;
  21bd91:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  21bd96:	c5 fa 7f 06          	vmovdqu XMMWORD PTR [rsi],xmm0
    while (i < end) : (i += 1) {
  21bd9a:	48 83 c6 f0          	add    rsi,0xfffffffffffffff0
  21bd9e:	48 83 c2 10          	add    rdx,0x10
  21bda2:	48 83 c0 01          	add    rax,0x1
  21bda6:	75 d8                	jne    21bd80 <Benchmark_reportStats+0x6180>
  21bda8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  21bdaf:	00 
                        const amount = index - buffer.end;
  21bdb0:	b8 01 00 00 00       	mov    eax,0x1
  21bdb5:	4c 29 f8             	sub    rax,r15
                        buffer.start += (amount + 1);
  21bdb8:	4c 01 e0             	add    rax,r12
  21bdbb:	4c 8d 24 01          	lea    r12,[rcx+rax*1]
                        unique -= 2;
  21bdbf:	49 83 c6 fe          	add    r14,0xfffffffffffffffe
        return self.end - self.start;
  21bdc3:	49 89 c2             	mov    r10,rax
  21bdc6:	49 f7 da             	neg    r10
                    while (buffer.length() > 0) {
  21bdc9:	48 85 c0             	test   rax,rax
  21bdcc:	0f 85 2e fa ff ff    	jne    21b800 <Benchmark_reportStats+0x5c00>
  21bdd2:	48 8b 44 24 10       	mov    rax,QWORD PTR [rsp+0x10]
            while (pull_index < 2) : (pull_index += 1) {
  21bdd7:	48 83 c0 01          	add    rax,0x1
  21bddb:	48 83 f8 02          	cmp    rax,0x2
  21bddf:	0f 85 fb f3 ff ff    	jne    21b1e0 <Benchmark_reportStats+0x55e0>
  21bde5:	48 8b 84 24 e0 00 00 	mov    rax,QWORD PTR [rsp+0xe0]
  21bdec:	00 
  21bded:	4c 8b bc 24 00 01 00 	mov    r15,QWORD PTR [rsp+0x100]
  21bdf4:	00 
  21bdf5:	4c 8b a4 24 d8 00 00 	mov    r12,QWORD PTR [rsp+0xd8]
  21bdfc:	00 
  21bdfd:	e9 7e 25 00 00       	jmp    21e380 <Benchmark_reportStats+0x8780>
  21be02:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21be09:	1f 84 00 00 00 00 00 
        if (self.numerator_step >= self.denominator) {
  21be10:	4c 39 f8             	cmp    rax,r15
  21be13:	b9 00 00 00 00       	mov    ecx,0x0
  21be18:	49 0f 43 cf          	cmovae rcx,r15
  21be1c:	48 29 c8             	sub    rax,rcx
  21be1f:	49 89 c1             	mov    r9,rax
        if (iterator.length() < cache.len) {
  21be22:	49 81 fc 00 02 00 00 	cmp    r12,0x200
  21be29:	4c 89 a4 24 d8 00 00 	mov    QWORD PTR [rsp+0xd8],r12
  21be30:	00 
  21be31:	4c 89 8c 24 e0 00 00 	mov    QWORD PTR [rsp+0xe0],r9
  21be38:	00 
  21be39:	0f 83 e1 b6 ff ff    	jae    217520 <Benchmark_reportStats+0x1920>
            if ((iterator.length() + 1) * 4 <= cache.len and iterator.length() * 4 <= items.len) {
  21be3f:	4a 8d 04 a5 04 00 00 	lea    rax,[r12*4+0x4]
  21be46:	00 
    for (source) |s, i|
  21be47:	49 8d 4c 24 ff       	lea    rcx,[r12-0x1]
  21be4c:	48 89 4c 24 50       	mov    QWORD PTR [rsp+0x50],rcx
  21be51:	48 3d 00 02 00 00    	cmp    rax,0x200
  21be57:	0f 87 fa 1c 00 00    	ja     21db57 <Benchmark_reportStats+0x7f57>
  21be5d:	4a 8d 0c a5 00 00 00 	lea    rcx,[r12*4+0x0]
  21be64:	00 
  21be65:	48 3b 4c 24 48       	cmp    rcx,QWORD PTR [rsp+0x48]
  21be6a:	0f 87 e7 1c 00 00    	ja     21db57 <Benchmark_reportStats+0x7f57>
        self.decimal += self.decimal_step;
  21be70:	4b 8d 04 24          	lea    rax,[r12+r12*1]
  21be74:	48 89 44 24 68       	mov    QWORD PTR [rsp+0x68],rax
  21be79:	4b 8d 04 24          	lea    rax,[r12+r12*1]
  21be7d:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  21be81:	48 89 84 24 38 01 00 	mov    QWORD PTR [rsp+0x138],rax
  21be88:	00 
  21be89:	48 89 8c 24 58 01 00 	mov    QWORD PTR [rsp+0x158],rcx
  21be90:	00 
  21be91:	48 8d 41 ff          	lea    rax,[rcx-0x1]
  21be95:	48 89 84 24 70 01 00 	mov    QWORD PTR [rsp+0x170],rax
  21be9c:	00 
  21be9d:	4b 8d 0c 64          	lea    rcx,[r12+r12*2]
  21bea1:	4b 8d 04 64          	lea    rax,[r12+r12*2]
  21bea5:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  21bea9:	48 89 84 24 68 01 00 	mov    QWORD PTR [rsp+0x168],rax
  21beb0:	00 
  21beb1:	4c 89 e2             	mov    rdx,r12
  21beb4:	48 c1 e2 04          	shl    rdx,0x4
  21beb8:	48 8d 84 24 98 02 00 	lea    rax,[rsp+0x298]
  21bebf:	00 
  21bec0:	48 8d 3c 10          	lea    rdi,[rax+rdx*1]
  21bec4:	48 89 bc 24 60 01 00 	mov    QWORD PTR [rsp+0x160],rdi
  21becb:	00 
  21becc:	48 89 94 24 20 01 00 	mov    QWORD PTR [rsp+0x120],rdx
  21bed3:	00 
  21bed4:	48 01 e2             	add    rdx,rsp
  21bed7:	48 81 c2 28 02 00 00 	add    rdx,0x228
  21bede:	48 89 94 24 10 01 00 	mov    QWORD PTR [rsp+0x110],rdx
  21bee5:	00 
  21bee6:	4c 89 e2             	mov    rdx,r12
  21bee9:	48 c1 e2 05          	shl    rdx,0x5
  21beed:	48 8d 3c 10          	lea    rdi,[rax+rdx*1]
  21bef1:	48 89 bc 24 40 01 00 	mov    QWORD PTR [rsp+0x140],rdi
  21bef8:	00 
  21bef9:	48 8d 3c 14          	lea    rdi,[rsp+rdx*1]
  21befd:	48 81 c7 28 02 00 00 	add    rdi,0x228
  21bf04:	48 89 bc 24 28 01 00 	mov    QWORD PTR [rsp+0x128],rdi
  21bf0b:	00 
  21bf0c:	48 89 8c 24 18 01 00 	mov    QWORD PTR [rsp+0x118],rcx
  21bf13:	00 
  21bf14:	48 89 cf             	mov    rdi,rcx
  21bf17:	48 c1 e7 04          	shl    rdi,0x4
  21bf1b:	48 8d 0c 3c          	lea    rcx,[rsp+rdi*1]
  21bf1f:	48 81 c1 28 02 00 00 	add    rcx,0x228
  21bf26:	48 89 8c 24 e8 00 00 	mov    QWORD PTR [rsp+0xe8],rcx
  21bf2d:	00 
  21bf2e:	48 8d 8c 24 38 02 00 	lea    rcx,[rsp+0x238]
  21bf35:	00 
  21bf36:	48 01 ca             	add    rdx,rcx
  21bf39:	48 89 54 24 70       	mov    QWORD PTR [rsp+0x70],rdx
  21bf3e:	48 89 bc 24 30 01 00 	mov    QWORD PTR [rsp+0x130],rdi
  21bf45:	00 
  21bf46:	48 8d 04 38          	lea    rax,[rax+rdi*1]
  21bf4a:	48 89 84 24 48 01 00 	mov    QWORD PTR [rsp+0x148],rax
  21bf51:	00 
  21bf52:	31 c0                	xor    eax,eax
  21bf54:	45 31 d2             	xor    r10d,r10d
  21bf57:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  21bf5e:	00 00 
  21bf60:	49 89 c3             	mov    r11,rax
  21bf63:	4f 8d 34 23          	lea    r14,[r11+r12*1]
        self.numerator += self.numerator_step;
  21bf67:	4d 01 ca             	add    r10,r9
        if (self.numerator >= self.denominator) {
  21bf6a:	31 f6                	xor    esi,esi
  21bf6c:	4d 39 fa             	cmp    r10,r15
  21bf6f:	4c 89 f8             	mov    rax,r15
  21bf72:	b9 00 00 00 00       	mov    ecx,0x0
  21bf77:	48 0f 42 c1          	cmovb  rax,rcx
  21bf7b:	40 0f 93 c6          	setae  sil
  21bf7f:	49 29 c2             	sub    r10,rax
  21bf82:	49 01 f6             	add    r14,rsi
        self.decimal += self.decimal_step;
  21bf85:	4b 8d 3c 26          	lea    rdi,[r14+r12*1]
        self.numerator += self.numerator_step;
  21bf89:	4d 01 ca             	add    r10,r9
        if (self.numerator >= self.denominator) {
  21bf8c:	31 d2                	xor    edx,edx
  21bf8e:	4d 39 fa             	cmp    r10,r15
  21bf91:	0f 93 c2             	setae  dl
  21bf94:	4c 89 f8             	mov    rax,r15
  21bf97:	48 0f 42 c1          	cmovb  rax,rcx
  21bf9b:	49 29 c2             	sub    r10,rax
  21bf9e:	48 89 d0             	mov    rax,rdx
  21bfa1:	48 89 44 24 30       	mov    QWORD PTR [rsp+0x30],rax
  21bfa6:	48 01 d7             	add    rdi,rdx
        self.decimal += self.decimal_step;
  21bfa9:	4a 8d 1c 27          	lea    rbx,[rdi+r12*1]
        self.numerator += self.numerator_step;
  21bfad:	4d 01 ca             	add    r10,r9
        if (self.numerator >= self.denominator) {
  21bfb0:	31 d2                	xor    edx,edx
  21bfb2:	4d 39 fa             	cmp    r10,r15
  21bfb5:	0f 93 c2             	setae  dl
  21bfb8:	4c 89 f8             	mov    rax,r15
  21bfbb:	48 0f 42 c1          	cmovb  rax,rcx
  21bfbf:	49 29 c2             	sub    r10,rax
  21bfc2:	48 89 54 24 58       	mov    QWORD PTR [rsp+0x58],rdx
  21bfc7:	48 01 d3             	add    rbx,rdx
  21bfca:	48 89 5c 24 20       	mov    QWORD PTR [rsp+0x20],rbx
        self.decimal += self.decimal_step;
  21bfcf:	4a 8d 04 23          	lea    rax,[rbx+r12*1]
        self.numerator += self.numerator_step;
  21bfd3:	4d 01 ca             	add    r10,r9
        if (self.numerator >= self.denominator) {
  21bfd6:	31 d2                	xor    edx,edx
  21bfd8:	4d 39 fa             	cmp    r10,r15
  21bfdb:	0f 93 c2             	setae  dl
  21bfde:	4d 89 f9             	mov    r9,r15
  21bfe1:	4c 0f 42 c9          	cmovb  r9,rcx
  21bfe5:	48 89 54 24 60       	mov    QWORD PTR [rsp+0x60],rdx
  21bfea:	48 01 d0             	add    rax,rdx
                    if (lessThan(items[B1.end - 1], items[A1.start])) {
  21bfed:	48 89 44 24 38       	mov    QWORD PTR [rsp+0x38],rax
  21bff2:	48 89 fb             	mov    rbx,rdi
  21bff5:	48 c1 e3 04          	shl    rbx,0x4
  21bff9:	4c 8b 7c 24 40       	mov    r15,QWORD PTR [rsp+0x40]
  21bffe:	4c 89 d9             	mov    rcx,r11
  21c001:	48 c1 e1 04          	shl    rcx,0x4
  21c005:	49 8b 44 1f f0       	mov    rax,QWORD PTR [r15+rbx*1-0x10]
  21c00a:	49 8b 14 0f          	mov    rdx,QWORD PTR [r15+rcx*1]
  21c00e:	48 39 d0             	cmp    rax,rdx
  21c011:	48 89 8c 24 08 01 00 	mov    QWORD PTR [rsp+0x108],rcx
  21c018:	00 
  21c019:	4d 8d 24 0f          	lea    r12,[r15+rcx*1]
  21c01d:	4c 89 d9             	mov    rcx,r11
  21c020:	48 89 4c 24 10       	mov    QWORD PTR [rsp+0x10],rcx
  21c025:	48 89 74 24 28       	mov    QWORD PTR [rsp+0x28],rsi
  21c02a:	48 89 7c 24 18       	mov    QWORD PTR [rsp+0x18],rdi
  21c02f:	4c 89 94 24 d0 00 00 	mov    QWORD PTR [rsp+0xd0],r10
  21c036:	00 
  21c037:	4c 89 8c 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],r9
  21c03e:	00 
  21c03f:	48 89 5c 24 78       	mov    QWORD PTR [rsp+0x78],rbx
  21c044:	73 5a                	jae    21c0a0 <Benchmark_reportStats+0x64a0>
        return self.end - self.start;
  21c046:	4c 29 f7             	sub    rdi,r14
                        mem.copy(T, cache[B1.length()..], items[A1.start..A1.end]);
  21c049:	b8 00 02 00 00       	mov    eax,0x200
  21c04e:	48 29 f8             	sub    rax,rdi
  21c051:	4c 89 f2             	mov    rdx,r14
  21c054:	4c 29 da             	sub    rdx,r11
    assert(dest.len >= source.len);
  21c057:	48 39 d0             	cmp    rax,rdx
  21c05a:	0f 82 0c 27 00 00    	jb     21e76c <Benchmark_reportStats+0x8b6c>
    for (source) |s, i|
  21c060:	48 85 d2             	test   rdx,rdx
  21c063:	0f 84 2b 02 00 00    	je     21c294 <Benchmark_reportStats+0x6694>
  21c069:	48 8b 44 24 50       	mov    rax,QWORD PTR [rsp+0x50]
  21c06e:	48 8d 0c 30          	lea    rcx,[rax+rsi*1]
  21c072:	89 d0                	mov    eax,edx
  21c074:	83 e0 07             	and    eax,0x7
  21c077:	48 83 f9 07          	cmp    rcx,0x7
  21c07b:	0f 83 35 01 00 00    	jae    21c1b6 <Benchmark_reportStats+0x65b6>
  21c081:	31 c9                	xor    ecx,ecx
  21c083:	48 85 c0             	test   rax,rax
  21c086:	0f 85 cc 01 00 00    	jne    21c258 <Benchmark_reportStats+0x6658>
  21c08c:	e9 03 02 00 00       	jmp    21c294 <Benchmark_reportStats+0x6694>
  21c091:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21c098:	0f 1f 84 00 00 00 00 
  21c09f:	00 
                    } else if (lessThan(items[B1.start], items[A1.end - 1])) {
  21c0a0:	4c 89 f1             	mov    rcx,r14
  21c0a3:	48 c1 e1 04          	shl    rcx,0x4
  21c0a7:	4d 8b 04 0f          	mov    r8,QWORD PTR [r15+rcx*1]
  21c0ab:	4d 3b 44 0f f0       	cmp    r8,QWORD PTR [r15+rcx*1-0x10]
  21c0b0:	0f 83 9a 00 00 00    	jae    21c150 <Benchmark_reportStats+0x6550>
  21c0b6:	4c 89 f0             	mov    rax,r14
  21c0b9:	4c 89 db             	mov    rbx,r11
  21c0bc:	31 ff                	xor    edi,edi
  21c0be:	eb 0e                	jmp    21c0ce <Benchmark_reportStats+0x64ce>
  21c0c0:	48 89 c1             	mov    rcx,rax
  21c0c3:	48 c1 e1 04          	shl    rcx,0x4
  21c0c7:	4d 8b 04 0f          	mov    r8,QWORD PTR [r15+rcx*1]
  21c0cb:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
        if (!lessThan(from[B_index], from[A_index])) {
  21c0ce:	48 89 c1             	mov    rcx,rax
  21c0d1:	48 c1 e1 04          	shl    rcx,0x4
  21c0d5:	4d 8d 1c 0f          	lea    r11,[r15+rcx*1]
  21c0d9:	49 89 da             	mov    r10,rbx
  21c0dc:	49 c1 e2 04          	shl    r10,0x4
  21c0e0:	4b 8d 34 17          	lea    rsi,[r15+r10*1]
  21c0e4:	49 89 f9             	mov    r9,rdi
  21c0e7:	49 c1 e1 04          	shl    r9,0x4
  21c0eb:	4e 8d 2c 0c          	lea    r13,[rsp+r9*1]
  21c0ef:	49 81 c5 28 02 00 00 	add    r13,0x228
  21c0f6:	49 39 d0             	cmp    r8,rdx
  21c0f9:	73 25                	jae    21c120 <Benchmark_reportStats+0x6520>
            into[insert_index] = from[B_index];
  21c0fb:	c4 c1 7a 6f 03       	vmovdqu xmm0,XMMWORD PTR [r11]
  21c100:	c4 c1 7a 7f 45 00    	vmovdqu XMMWORD PTR [r13+0x0],xmm0
            B_index += 1;
  21c106:	48 83 c0 01          	add    rax,0x1
            if (B_index == B_last) {
  21c10a:	48 3b 44 24 18       	cmp    rax,QWORD PTR [rsp+0x18]
  21c10f:	0f 84 a9 02 00 00    	je     21c3be <Benchmark_reportStats+0x67be>
  21c115:	48 83 c7 01          	add    rdi,0x1
  21c119:	eb a5                	jmp    21c0c0 <Benchmark_reportStats+0x64c0>
  21c11b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
            into[insert_index] = from[A_index];
  21c120:	c5 fa 6f 06          	vmovdqu xmm0,XMMWORD PTR [rsi]
  21c124:	c4 c1 7a 7f 45 00    	vmovdqu XMMWORD PTR [r13+0x0],xmm0
            A_index += 1;
  21c12a:	48 83 c3 01          	add    rbx,0x1
            if (A_index == A_last) {
  21c12e:	4c 39 f3             	cmp    rbx,r14
  21c131:	0f 84 da 02 00 00    	je     21c411 <Benchmark_reportStats+0x6811>
  21c137:	48 83 c7 01          	add    rdi,0x1
  21c13b:	48 89 de             	mov    rsi,rbx
  21c13e:	48 c1 e6 04          	shl    rsi,0x4
  21c142:	4c 01 fe             	add    rsi,r15
  21c145:	e9 76 ff ff ff       	jmp    21c0c0 <Benchmark_reportStats+0x64c0>
  21c14a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
                        if (!lessThan(items[B2.start], items[A2.end - 1]) and !lessThan(items[A2.start], items[B1.end - 1])) continue;
  21c150:	48 8b 4c 24 20       	mov    rcx,QWORD PTR [rsp+0x20]
  21c155:	48 c1 e1 04          	shl    rcx,0x4
  21c159:	49 8b 14 0f          	mov    rdx,QWORD PTR [r15+rcx*1]
  21c15d:	49 3b 54 0f f0       	cmp    rdx,QWORD PTR [r15+rcx*1-0x10]
  21c162:	72 0a                	jb     21c16e <Benchmark_reportStats+0x656e>
  21c164:	49 39 04 1f          	cmp    QWORD PTR [r15+rbx*1],rax
  21c168:	0f 83 92 19 00 00    	jae    21db00 <Benchmark_reportStats+0x7f00>
                        mem.copy(T, cache[0..], items[A1.start..A1.end]);
  21c16e:	4c 89 f0             	mov    rax,r14
  21c171:	4c 29 d8             	sub    rax,r11
    assert(dest.len >= source.len);
  21c174:	48 3d 01 02 00 00    	cmp    rax,0x201
  21c17a:	0f 83 ec 25 00 00    	jae    21e76c <Benchmark_reportStats+0x8b6c>
    for (source) |s, i|
  21c180:	48 85 c0             	test   rax,rax
  21c183:	0f 84 d0 03 00 00    	je     21c559 <Benchmark_reportStats+0x6959>
  21c189:	48 8b 4c 24 50       	mov    rcx,QWORD PTR [rsp+0x50]
  21c18e:	48 8d 14 31          	lea    rdx,[rcx+rsi*1]
  21c192:	89 c1                	mov    ecx,eax
  21c194:	83 e1 07             	and    ecx,0x7
  21c197:	48 83 fa 07          	cmp    rdx,0x7
  21c19b:	0f 83 d6 02 00 00    	jae    21c477 <Benchmark_reportStats+0x6877>
  21c1a1:	31 d2                	xor    edx,edx
  21c1a3:	48 85 c9             	test   rcx,rcx
  21c1a6:	48 8b 7c 24 18       	mov    rdi,QWORD PTR [rsp+0x18]
  21c1ab:	0f 85 79 03 00 00    	jne    21c52a <Benchmark_reportStats+0x692a>
  21c1b1:	e9 a3 03 00 00       	jmp    21c559 <Benchmark_reportStats+0x6959>
  21c1b6:	48 29 c2             	sub    rdx,rax
  21c1b9:	48 8b 74 24 30       	mov    rsi,QWORD PTR [rsp+0x30]
  21c1be:	48 c1 e6 04          	shl    rsi,0x4
  21c1c2:	48 03 b4 24 10 01 00 	add    rsi,QWORD PTR [rsp+0x110]
  21c1c9:	00 
  21c1ca:	bb 70 00 00 00       	mov    ebx,0x70
  21c1cf:	31 c9                	xor    ecx,ecx
  21c1d1:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21c1d8:	0f 1f 84 00 00 00 00 
  21c1df:	00 
        dest[i] = s;
  21c1e0:	c4 c1 78 10 44 1c 90 	vmovups xmm0,XMMWORD PTR [r12+rbx*1-0x70]
  21c1e7:	c5 f8 11 44 1e 90    	vmovups XMMWORD PTR [rsi+rbx*1-0x70],xmm0
  21c1ed:	c4 c1 78 10 44 1c a0 	vmovups xmm0,XMMWORD PTR [r12+rbx*1-0x60]
  21c1f4:	c5 f8 11 44 1e a0    	vmovups XMMWORD PTR [rsi+rbx*1-0x60],xmm0
  21c1fa:	c4 c1 78 10 44 1c b0 	vmovups xmm0,XMMWORD PTR [r12+rbx*1-0x50]
  21c201:	c5 f8 11 44 1e b0    	vmovups XMMWORD PTR [rsi+rbx*1-0x50],xmm0
  21c207:	c4 c1 78 10 44 1c c0 	vmovups xmm0,XMMWORD PTR [r12+rbx*1-0x40]
  21c20e:	c5 f8 11 44 1e c0    	vmovups XMMWORD PTR [rsi+rbx*1-0x40],xmm0
  21c214:	c4 c1 78 10 44 1c d0 	vmovups xmm0,XMMWORD PTR [r12+rbx*1-0x30]
  21c21b:	c5 f8 11 44 1e d0    	vmovups XMMWORD PTR [rsi+rbx*1-0x30],xmm0
  21c221:	c4 c1 78 10 44 1c e0 	vmovups xmm0,XMMWORD PTR [r12+rbx*1-0x20]
  21c228:	c5 f8 11 44 1e e0    	vmovups XMMWORD PTR [rsi+rbx*1-0x20],xmm0
  21c22e:	c4 c1 78 10 44 1c f0 	vmovups xmm0,XMMWORD PTR [r12+rbx*1-0x10]
  21c235:	c5 f8 11 44 1e f0    	vmovups XMMWORD PTR [rsi+rbx*1-0x10],xmm0
  21c23b:	c4 c1 7a 6f 04 1c    	vmovdqu xmm0,XMMWORD PTR [r12+rbx*1]
  21c241:	c5 fa 7f 04 1e       	vmovdqu XMMWORD PTR [rsi+rbx*1],xmm0
    for (source) |s, i|
  21c246:	48 83 c1 08          	add    rcx,0x8
  21c24a:	48 83 eb 80          	sub    rbx,0xffffffffffffff80
  21c24e:	48 39 ca             	cmp    rdx,rcx
  21c251:	75 8d                	jne    21c1e0 <Benchmark_reportStats+0x65e0>
  21c253:	48 85 c0             	test   rax,rax
  21c256:	74 3c                	je     21c294 <Benchmark_reportStats+0x6694>
  21c258:	48 8b 54 24 30       	mov    rdx,QWORD PTR [rsp+0x30]
  21c25d:	48 8d 14 11          	lea    rdx,[rcx+rdx*1]
  21c261:	48 c1 e2 04          	shl    rdx,0x4
  21c265:	48 03 94 24 10 01 00 	add    rdx,QWORD PTR [rsp+0x110]
  21c26c:	00 
  21c26d:	4c 01 d9             	add    rcx,r11
  21c270:	48 c1 e1 04          	shl    rcx,0x4
  21c274:	4c 01 f9             	add    rcx,r15
  21c277:	48 f7 d8             	neg    rax
  21c27a:	31 f6                	xor    esi,esi
  21c27c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
        dest[i] = s;
  21c280:	c5 fa 6f 04 31       	vmovdqu xmm0,XMMWORD PTR [rcx+rsi*1]
  21c285:	c5 fa 7f 04 32       	vmovdqu XMMWORD PTR [rdx+rsi*1],xmm0
    for (source) |s, i|
  21c28a:	48 83 c6 10          	add    rsi,0x10
  21c28e:	48 83 c0 01          	add    rax,0x1
  21c292:	75 ec                	jne    21c280 <Benchmark_reportStats+0x6680>
    assert(dest.len >= source.len);
  21c294:	48 81 ff 01 02 00 00 	cmp    rdi,0x201
  21c29b:	0f 83 cb 24 00 00    	jae    21e76c <Benchmark_reportStats+0x8b6c>
    for (source) |s, i|
  21c2a1:	48 85 ff             	test   rdi,rdi
  21c2a4:	0f 84 b6 05 00 00    	je     21c860 <Benchmark_reportStats+0x6c60>
  21c2aa:	48 8b 44 24 50       	mov    rax,QWORD PTR [rsp+0x50]
  21c2af:	48 8b 4c 24 30       	mov    rcx,QWORD PTR [rsp+0x30]
  21c2b4:	48 8d 0c 08          	lea    rcx,[rax+rcx*1]
  21c2b8:	89 f8                	mov    eax,edi
  21c2ba:	83 e0 07             	and    eax,0x7
  21c2bd:	48 83 f9 07          	cmp    rcx,0x7
  21c2c1:	73 10                	jae    21c2d3 <Benchmark_reportStats+0x66d3>
  21c2c3:	31 c9                	xor    ecx,ecx
  21c2c5:	48 85 c0             	test   rax,rax
  21c2c8:	0f 85 c3 00 00 00    	jne    21c391 <Benchmark_reportStats+0x6791>
  21c2ce:	e9 8d 05 00 00       	jmp    21c860 <Benchmark_reportStats+0x6c60>
  21c2d3:	48 29 c7             	sub    rdi,rax
  21c2d6:	48 8b 8c 24 20 01 00 	mov    rcx,QWORD PTR [rsp+0x120]
  21c2dd:	00 
  21c2de:	49 8d 0c 0f          	lea    rcx,[r15+rcx*1]
  21c2e2:	48 8b 54 24 10       	mov    rdx,QWORD PTR [rsp+0x10]
  21c2e7:	48 8b 74 24 28       	mov    rsi,QWORD PTR [rsp+0x28]
  21c2ec:	48 8d 14 32          	lea    rdx,[rdx+rsi*1]
  21c2f0:	48 c1 e2 04          	shl    rdx,0x4
  21c2f4:	48 01 ca             	add    rdx,rcx
  21c2f7:	be 70 00 00 00       	mov    esi,0x70
  21c2fc:	31 c9                	xor    ecx,ecx
  21c2fe:	66 90                	xchg   ax,ax
        dest[i] = s;
  21c300:	c5 f8 10 44 32 90    	vmovups xmm0,XMMWORD PTR [rdx+rsi*1-0x70]
  21c306:	c5 f8 11 84 34 b8 01 	vmovups XMMWORD PTR [rsp+rsi*1+0x1b8],xmm0
  21c30d:	00 00 
  21c30f:	c5 f8 10 44 32 a0    	vmovups xmm0,XMMWORD PTR [rdx+rsi*1-0x60]
  21c315:	c5 f8 11 84 34 c8 01 	vmovups XMMWORD PTR [rsp+rsi*1+0x1c8],xmm0
  21c31c:	00 00 
  21c31e:	c5 f8 10 44 32 b0    	vmovups xmm0,XMMWORD PTR [rdx+rsi*1-0x50]
  21c324:	c5 f8 11 84 34 d8 01 	vmovups XMMWORD PTR [rsp+rsi*1+0x1d8],xmm0
  21c32b:	00 00 
  21c32d:	c5 f8 10 44 32 c0    	vmovups xmm0,XMMWORD PTR [rdx+rsi*1-0x40]
  21c333:	c5 f8 11 84 34 e8 01 	vmovups XMMWORD PTR [rsp+rsi*1+0x1e8],xmm0
  21c33a:	00 00 
  21c33c:	c5 f8 10 44 32 d0    	vmovups xmm0,XMMWORD PTR [rdx+rsi*1-0x30]
  21c342:	c5 f8 11 84 34 f8 01 	vmovups XMMWORD PTR [rsp+rsi*1+0x1f8],xmm0
  21c349:	00 00 
  21c34b:	c5 f8 10 44 32 e0    	vmovups xmm0,XMMWORD PTR [rdx+rsi*1-0x20]
  21c351:	c5 f8 11 84 34 08 02 	vmovups XMMWORD PTR [rsp+rsi*1+0x208],xmm0
  21c358:	00 00 
  21c35a:	c5 f8 10 44 32 f0    	vmovups xmm0,XMMWORD PTR [rdx+rsi*1-0x10]
  21c360:	c5 f8 11 84 34 18 02 	vmovups XMMWORD PTR [rsp+rsi*1+0x218],xmm0
  21c367:	00 00 
  21c369:	c5 fa 6f 04 32       	vmovdqu xmm0,XMMWORD PTR [rdx+rsi*1]
  21c36e:	c5 fa 7f 84 34 28 02 	vmovdqu XMMWORD PTR [rsp+rsi*1+0x228],xmm0
  21c375:	00 00 
    for (source) |s, i|
  21c377:	48 83 c1 08          	add    rcx,0x8
  21c37b:	48 83 ee 80          	sub    rsi,0xffffffffffffff80
  21c37f:	48 39 cf             	cmp    rdi,rcx
  21c382:	0f 85 78 ff ff ff    	jne    21c300 <Benchmark_reportStats+0x6700>
  21c388:	48 85 c0             	test   rax,rax
  21c38b:	0f 84 cf 04 00 00    	je     21c860 <Benchmark_reportStats+0x6c60>
  21c391:	49 c1 e6 04          	shl    r14,0x4
  21c395:	4d 01 fe             	add    r14,r15
  21c398:	48 c1 e1 04          	shl    rcx,0x4
  21c39c:	48 f7 d8             	neg    rax
  21c39f:	90                   	nop
        dest[i] = s;
  21c3a0:	c4 c1 7a 6f 04 0e    	vmovdqu xmm0,XMMWORD PTR [r14+rcx*1]
  21c3a6:	c5 fa 7f 84 0c 28 02 	vmovdqu XMMWORD PTR [rsp+rcx*1+0x228],xmm0
  21c3ad:	00 00 
    for (source) |s, i|
  21c3af:	48 83 c1 10          	add    rcx,0x10
  21c3b3:	48 83 c0 01          	add    rax,0x1
  21c3b7:	75 e7                	jne    21c3a0 <Benchmark_reportStats+0x67a0>
  21c3b9:	e9 a2 04 00 00       	jmp    21c860 <Benchmark_reportStats+0x6c60>
                mem.copy(T, into[insert_index..], from[A_index..A_last]);
  21c3be:	b8 ff 01 00 00       	mov    eax,0x1ff
  21c3c3:	48 29 f8             	sub    rax,rdi
  21c3c6:	49 29 de             	sub    r14,rbx
    assert(dest.len >= source.len);
  21c3c9:	4c 39 f0             	cmp    rax,r14
  21c3cc:	0f 82 9a 23 00 00    	jb     21e76c <Benchmark_reportStats+0x8b6c>
    for (source) |s, i|
  21c3d2:	4d 85 f6             	test   r14,r14
  21c3d5:	0f 84 85 04 00 00    	je     21c860 <Benchmark_reportStats+0x6c60>
  21c3db:	48 8b 44 24 50       	mov    rax,QWORD PTR [rsp+0x50]
  21c3e0:	48 8b 4c 24 10       	mov    rcx,QWORD PTR [rsp+0x10]
  21c3e5:	48 8d 0c 08          	lea    rcx,[rax+rcx*1]
  21c3e9:	48 03 4c 24 28       	add    rcx,QWORD PTR [rsp+0x28]
  21c3ee:	48 29 d9             	sub    rcx,rbx
  21c3f1:	44 89 f0             	mov    eax,r14d
  21c3f4:	83 e0 07             	and    eax,0x7
  21c3f7:	48 83 f9 07          	cmp    rcx,0x7
  21c3fb:	0f 83 a8 02 00 00    	jae    21c6a9 <Benchmark_reportStats+0x6aa9>
  21c401:	31 c9                	xor    ecx,ecx
  21c403:	48 85 c0             	test   rax,rax
  21c406:	0f 85 31 03 00 00    	jne    21c73d <Benchmark_reportStats+0x6b3d>
  21c40c:	e9 4f 04 00 00       	jmp    21c860 <Benchmark_reportStats+0x6c60>
                mem.copy(T, into[insert_index..], from[B_index..B_last]);
  21c411:	ba ff 01 00 00       	mov    edx,0x1ff
  21c416:	48 29 fa             	sub    rdx,rdi
  21c419:	48 8b 74 24 18       	mov    rsi,QWORD PTR [rsp+0x18]
  21c41e:	48 29 c6             	sub    rsi,rax
    assert(dest.len >= source.len);
  21c421:	48 39 f2             	cmp    rdx,rsi
  21c424:	0f 82 42 23 00 00    	jb     21e76c <Benchmark_reportStats+0x8b6c>
    for (source) |s, i|
  21c42a:	48 85 f6             	test   rsi,rsi
  21c42d:	0f 84 2d 04 00 00    	je     21c860 <Benchmark_reportStats+0x6c60>
  21c433:	48 8b 94 24 38 01 00 	mov    rdx,QWORD PTR [rsp+0x138]
  21c43a:	00 
  21c43b:	48 8b 7c 24 10       	mov    rdi,QWORD PTR [rsp+0x10]
  21c440:	48 8d 14 3a          	lea    rdx,[rdx+rdi*1]
  21c444:	48 8b 5c 24 28       	mov    rbx,QWORD PTR [rsp+0x28]
  21c449:	49 89 d8             	mov    r8,rbx
  21c44c:	4c 01 c2             	add    rdx,r8
  21c44f:	48 8b 5c 24 30       	mov    rbx,QWORD PTR [rsp+0x30]
  21c454:	48 01 da             	add    rdx,rbx
  21c457:	48 29 c2             	sub    rdx,rax
  21c45a:	83 e6 07             	and    esi,0x7
  21c45d:	48 83 fa 07          	cmp    rdx,0x7
  21c461:	0f 83 12 03 00 00    	jae    21c779 <Benchmark_reportStats+0x6b79>
  21c467:	31 c0                	xor    eax,eax
  21c469:	48 85 f6             	test   rsi,rsi
  21c46c:	0f 85 af 03 00 00    	jne    21c821 <Benchmark_reportStats+0x6c21>
  21c472:	e9 e9 03 00 00       	jmp    21c860 <Benchmark_reportStats+0x6c60>
  21c477:	48 89 c6             	mov    rsi,rax
  21c47a:	48 29 ce             	sub    rsi,rcx
  21c47d:	bf 70 00 00 00       	mov    edi,0x70
  21c482:	31 d2                	xor    edx,edx
  21c484:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21c48b:	00 00 00 00 00 
        dest[i] = s;
  21c490:	c4 c1 78 10 44 3c 90 	vmovups xmm0,XMMWORD PTR [r12+rdi*1-0x70]
  21c497:	c5 f8 11 84 3c b8 01 	vmovups XMMWORD PTR [rsp+rdi*1+0x1b8],xmm0
  21c49e:	00 00 
  21c4a0:	c4 c1 78 10 44 3c a0 	vmovups xmm0,XMMWORD PTR [r12+rdi*1-0x60]
  21c4a7:	c5 f8 11 84 3c c8 01 	vmovups XMMWORD PTR [rsp+rdi*1+0x1c8],xmm0
  21c4ae:	00 00 
  21c4b0:	c4 c1 78 10 44 3c b0 	vmovups xmm0,XMMWORD PTR [r12+rdi*1-0x50]
  21c4b7:	c5 f8 11 84 3c d8 01 	vmovups XMMWORD PTR [rsp+rdi*1+0x1d8],xmm0
  21c4be:	00 00 
  21c4c0:	c4 c1 78 10 44 3c c0 	vmovups xmm0,XMMWORD PTR [r12+rdi*1-0x40]
  21c4c7:	c5 f8 11 84 3c e8 01 	vmovups XMMWORD PTR [rsp+rdi*1+0x1e8],xmm0
  21c4ce:	00 00 
  21c4d0:	c4 c1 78 10 44 3c d0 	vmovups xmm0,XMMWORD PTR [r12+rdi*1-0x30]
  21c4d7:	c5 f8 11 84 3c f8 01 	vmovups XMMWORD PTR [rsp+rdi*1+0x1f8],xmm0
  21c4de:	00 00 
  21c4e0:	c4 c1 78 10 44 3c e0 	vmovups xmm0,XMMWORD PTR [r12+rdi*1-0x20]
  21c4e7:	c5 f8 11 84 3c 08 02 	vmovups XMMWORD PTR [rsp+rdi*1+0x208],xmm0
  21c4ee:	00 00 
  21c4f0:	c4 c1 78 10 44 3c f0 	vmovups xmm0,XMMWORD PTR [r12+rdi*1-0x10]
  21c4f7:	c5 f8 11 84 3c 18 02 	vmovups XMMWORD PTR [rsp+rdi*1+0x218],xmm0
  21c4fe:	00 00 
  21c500:	c4 c1 7a 6f 04 3c    	vmovdqu xmm0,XMMWORD PTR [r12+rdi*1]
  21c506:	c5 fa 7f 84 3c 28 02 	vmovdqu XMMWORD PTR [rsp+rdi*1+0x228],xmm0
  21c50d:	00 00 
    for (source) |s, i|
  21c50f:	48 83 c2 08          	add    rdx,0x8
  21c513:	48 83 ef 80          	sub    rdi,0xffffffffffffff80
  21c517:	48 39 d6             	cmp    rsi,rdx
  21c51a:	0f 85 70 ff ff ff    	jne    21c490 <Benchmark_reportStats+0x6890>
  21c520:	48 85 c9             	test   rcx,rcx
  21c523:	48 8b 7c 24 18       	mov    rdi,QWORD PTR [rsp+0x18]
  21c528:	74 2f                	je     21c559 <Benchmark_reportStats+0x6959>
  21c52a:	48 c1 e2 04          	shl    rdx,0x4
  21c52e:	48 f7 d9             	neg    rcx
  21c531:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21c538:	0f 1f 84 00 00 00 00 
  21c53f:	00 
        dest[i] = s;
  21c540:	c4 c1 7a 6f 04 14    	vmovdqu xmm0,XMMWORD PTR [r12+rdx*1]
  21c546:	c5 fa 7f 84 14 28 02 	vmovdqu XMMWORD PTR [rsp+rdx*1+0x228],xmm0
  21c54d:	00 00 
    for (source) |s, i|
  21c54f:	48 83 c2 10          	add    rdx,0x10
  21c553:	48 83 c1 01          	add    rcx,0x1
  21c557:	75 e7                	jne    21c540 <Benchmark_reportStats+0x6940>
                        mem.copy(T, cache[A1.length()..], items[B1.start..B1.end]);
  21c559:	b9 00 02 00 00       	mov    ecx,0x200
  21c55e:	48 29 c1             	sub    rcx,rax
  21c561:	48 89 fa             	mov    rdx,rdi
  21c564:	4c 29 f2             	sub    rdx,r14
    assert(dest.len >= source.len);
  21c567:	48 39 d1             	cmp    rcx,rdx
  21c56a:	0f 82 fc 21 00 00    	jb     21e76c <Benchmark_reportStats+0x8b6c>
    for (source) |s, i|
  21c570:	48 85 d2             	test   rdx,rdx
  21c573:	0f 84 e7 02 00 00    	je     21c860 <Benchmark_reportStats+0x6c60>
  21c579:	48 8b 44 24 50       	mov    rax,QWORD PTR [rsp+0x50]
  21c57e:	48 8b 4c 24 30       	mov    rcx,QWORD PTR [rsp+0x30]
  21c583:	48 8d 0c 08          	lea    rcx,[rax+rcx*1]
  21c587:	89 d0                	mov    eax,edx
  21c589:	83 e0 07             	and    eax,0x7
  21c58c:	48 83 f9 07          	cmp    rcx,0x7
  21c590:	73 10                	jae    21c5a2 <Benchmark_reportStats+0x69a2>
  21c592:	31 c9                	xor    ecx,ecx
  21c594:	48 85 c0             	test   rax,rax
  21c597:	0f 85 b7 00 00 00    	jne    21c654 <Benchmark_reportStats+0x6a54>
  21c59d:	e9 be 02 00 00       	jmp    21c860 <Benchmark_reportStats+0x6c60>
  21c5a2:	48 29 c2             	sub    rdx,rax
  21c5a5:	48 8b 8c 24 20 01 00 	mov    rcx,QWORD PTR [rsp+0x120]
  21c5ac:	00 
  21c5ad:	49 8d 0c 0f          	lea    rcx,[r15+rcx*1]
  21c5b1:	48 8b 74 24 10       	mov    rsi,QWORD PTR [rsp+0x10]
  21c5b6:	48 8b 7c 24 28       	mov    rdi,QWORD PTR [rsp+0x28]
  21c5bb:	48 8d 34 3e          	lea    rsi,[rsi+rdi*1]
  21c5bf:	48 c1 e6 04          	shl    rsi,0x4
  21c5c3:	48 01 ce             	add    rsi,rcx
  21c5c6:	48 83 c6 70          	add    rsi,0x70
  21c5ca:	48 c1 e7 04          	shl    rdi,0x4
  21c5ce:	48 03 bc 24 60 01 00 	add    rdi,QWORD PTR [rsp+0x160]
  21c5d5:	00 
  21c5d6:	31 db                	xor    ebx,ebx
  21c5d8:	31 c9                	xor    ecx,ecx
  21c5da:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
        dest[i] = s;
  21c5e0:	c5 f8 10 44 1e 90    	vmovups xmm0,XMMWORD PTR [rsi+rbx*1-0x70]
  21c5e6:	c5 f8 11 44 1f 90    	vmovups XMMWORD PTR [rdi+rbx*1-0x70],xmm0
  21c5ec:	c5 f8 10 44 1e a0    	vmovups xmm0,XMMWORD PTR [rsi+rbx*1-0x60]
  21c5f2:	c5 f8 11 44 1f a0    	vmovups XMMWORD PTR [rdi+rbx*1-0x60],xmm0
  21c5f8:	c5 f8 10 44 1e b0    	vmovups xmm0,XMMWORD PTR [rsi+rbx*1-0x50]
  21c5fe:	c5 f8 11 44 1f b0    	vmovups XMMWORD PTR [rdi+rbx*1-0x50],xmm0
  21c604:	c5 f8 10 44 1e c0    	vmovups xmm0,XMMWORD PTR [rsi+rbx*1-0x40]
  21c60a:	c5 f8 11 44 1f c0    	vmovups XMMWORD PTR [rdi+rbx*1-0x40],xmm0
  21c610:	c5 f8 10 44 1e d0    	vmovups xmm0,XMMWORD PTR [rsi+rbx*1-0x30]
  21c616:	c5 f8 11 44 1f d0    	vmovups XMMWORD PTR [rdi+rbx*1-0x30],xmm0
  21c61c:	c5 f8 10 44 1e e0    	vmovups xmm0,XMMWORD PTR [rsi+rbx*1-0x20]
  21c622:	c5 f8 11 44 1f e0    	vmovups XMMWORD PTR [rdi+rbx*1-0x20],xmm0
  21c628:	c5 f8 10 44 1e f0    	vmovups xmm0,XMMWORD PTR [rsi+rbx*1-0x10]
  21c62e:	c5 f8 11 44 1f f0    	vmovups XMMWORD PTR [rdi+rbx*1-0x10],xmm0
  21c634:	c5 fa 6f 04 1e       	vmovdqu xmm0,XMMWORD PTR [rsi+rbx*1]
  21c639:	c5 fa 7f 04 1f       	vmovdqu XMMWORD PTR [rdi+rbx*1],xmm0
    for (source) |s, i|
  21c63e:	48 83 c1 08          	add    rcx,0x8
  21c642:	48 83 eb 80          	sub    rbx,0xffffffffffffff80
  21c646:	48 39 ca             	cmp    rdx,rcx
  21c649:	75 95                	jne    21c5e0 <Benchmark_reportStats+0x69e0>
  21c64b:	48 85 c0             	test   rax,rax
  21c64e:	0f 84 0c 02 00 00    	je     21c860 <Benchmark_reportStats+0x6c60>
  21c654:	48 8b 7c 24 28       	mov    rdi,QWORD PTR [rsp+0x28]
  21c659:	48 8d 14 39          	lea    rdx,[rcx+rdi*1]
  21c65d:	48 c1 e2 04          	shl    rdx,0x4
  21c661:	48 03 94 24 10 01 00 	add    rdx,QWORD PTR [rsp+0x110]
  21c668:	00 
  21c669:	48 8b b4 24 20 01 00 	mov    rsi,QWORD PTR [rsp+0x120]
  21c670:	00 
  21c671:	49 8d 34 37          	lea    rsi,[r15+rsi*1]
  21c675:	48 03 4c 24 10       	add    rcx,QWORD PTR [rsp+0x10]
  21c67a:	48 01 f9             	add    rcx,rdi
  21c67d:	48 c1 e1 04          	shl    rcx,0x4
  21c681:	48 01 f1             	add    rcx,rsi
  21c684:	48 f7 d8             	neg    rax
  21c687:	31 f6                	xor    esi,esi
  21c689:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
        dest[i] = s;
  21c690:	c5 fa 6f 04 31       	vmovdqu xmm0,XMMWORD PTR [rcx+rsi*1]
  21c695:	c5 fa 7f 04 32       	vmovdqu XMMWORD PTR [rdx+rsi*1],xmm0
    for (source) |s, i|
  21c69a:	48 83 c6 10          	add    rsi,0x10
  21c69e:	48 83 c0 01          	add    rax,0x1
  21c6a2:	75 ec                	jne    21c690 <Benchmark_reportStats+0x6a90>
  21c6a4:	e9 b7 01 00 00       	jmp    21c860 <Benchmark_reportStats+0x6c60>
  21c6a9:	49 29 c6             	sub    r14,rax
  21c6ac:	ba 70 00 00 00       	mov    edx,0x70
  21c6b1:	31 c9                	xor    ecx,ecx
  21c6b3:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21c6ba:	84 00 00 00 00 00 
        dest[i] = s;
  21c6c0:	c5 f8 10 44 16 90    	vmovups xmm0,XMMWORD PTR [rsi+rdx*1-0x70]
  21c6c6:	c4 c1 78 11 44 15 a0 	vmovups XMMWORD PTR [r13+rdx*1-0x60],xmm0
  21c6cd:	c5 f8 10 44 16 a0    	vmovups xmm0,XMMWORD PTR [rsi+rdx*1-0x60]
  21c6d3:	c4 c1 78 11 44 15 b0 	vmovups XMMWORD PTR [r13+rdx*1-0x50],xmm0
  21c6da:	c5 f8 10 44 16 b0    	vmovups xmm0,XMMWORD PTR [rsi+rdx*1-0x50]
  21c6e0:	c4 c1 78 11 44 15 c0 	vmovups XMMWORD PTR [r13+rdx*1-0x40],xmm0
  21c6e7:	c5 f8 10 44 16 c0    	vmovups xmm0,XMMWORD PTR [rsi+rdx*1-0x40]
  21c6ed:	c4 c1 78 11 44 15 d0 	vmovups XMMWORD PTR [r13+rdx*1-0x30],xmm0
  21c6f4:	c5 f8 10 44 16 d0    	vmovups xmm0,XMMWORD PTR [rsi+rdx*1-0x30]
  21c6fa:	c4 c1 78 11 44 15 e0 	vmovups XMMWORD PTR [r13+rdx*1-0x20],xmm0
  21c701:	c5 f8 10 44 16 e0    	vmovups xmm0,XMMWORD PTR [rsi+rdx*1-0x20]
  21c707:	c4 c1 78 11 44 15 f0 	vmovups XMMWORD PTR [r13+rdx*1-0x10],xmm0
  21c70e:	c5 f8 10 44 16 f0    	vmovups xmm0,XMMWORD PTR [rsi+rdx*1-0x10]
  21c714:	c4 c1 78 11 44 15 00 	vmovups XMMWORD PTR [r13+rdx*1+0x0],xmm0
  21c71b:	c5 fa 6f 04 16       	vmovdqu xmm0,XMMWORD PTR [rsi+rdx*1]
  21c720:	c4 c1 7a 7f 44 15 10 	vmovdqu XMMWORD PTR [r13+rdx*1+0x10],xmm0
    for (source) |s, i|
  21c727:	48 83 c1 08          	add    rcx,0x8
  21c72b:	48 83 ea 80          	sub    rdx,0xffffffffffffff80
  21c72f:	49 39 ce             	cmp    r14,rcx
  21c732:	75 8c                	jne    21c6c0 <Benchmark_reportStats+0x6ac0>
  21c734:	48 85 c0             	test   rax,rax
  21c737:	0f 84 23 01 00 00    	je     21c860 <Benchmark_reportStats+0x6c60>
  21c73d:	48 c1 e1 04          	shl    rcx,0x4
  21c741:	48 8d 94 24 38 02 00 	lea    rdx,[rsp+0x238]
  21c748:	00 
  21c749:	48 8d 14 0a          	lea    rdx,[rdx+rcx*1]
  21c74d:	4c 01 ca             	add    rdx,r9
  21c750:	4c 01 f9             	add    rcx,r15
  21c753:	4c 01 d1             	add    rcx,r10
  21c756:	48 f7 d8             	neg    rax
  21c759:	31 f6                	xor    esi,esi
  21c75b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
        dest[i] = s;
  21c760:	c5 fa 6f 04 31       	vmovdqu xmm0,XMMWORD PTR [rcx+rsi*1]
  21c765:	c5 fa 7f 04 32       	vmovdqu XMMWORD PTR [rdx+rsi*1],xmm0
    for (source) |s, i|
  21c76a:	48 83 c6 10          	add    rsi,0x10
  21c76e:	48 83 c0 01          	add    rax,0x1
  21c772:	75 ec                	jne    21c760 <Benchmark_reportStats+0x6b60>
  21c774:	e9 e7 00 00 00       	jmp    21c860 <Benchmark_reportStats+0x6c60>
  21c779:	48 8b 54 24 68       	mov    rdx,QWORD PTR [rsp+0x68]
  21c77e:	48 8d 3c 3a          	lea    rdi,[rdx+rdi*1]
  21c782:	48 01 df             	add    rdi,rbx
  21c785:	4c 01 c7             	add    rdi,r8
  21c788:	48 29 f7             	sub    rdi,rsi
  21c78b:	48 29 c7             	sub    rdi,rax
  21c78e:	ba 70 00 00 00       	mov    edx,0x70
  21c793:	31 c0                	xor    eax,eax
  21c795:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21c79c:	00 00 00 00 
        dest[i] = s;
  21c7a0:	c4 c1 78 10 44 13 90 	vmovups xmm0,XMMWORD PTR [r11+rdx*1-0x70]
  21c7a7:	c4 c1 78 11 44 15 a0 	vmovups XMMWORD PTR [r13+rdx*1-0x60],xmm0
  21c7ae:	c4 c1 78 10 44 13 a0 	vmovups xmm0,XMMWORD PTR [r11+rdx*1-0x60]
  21c7b5:	c4 c1 78 11 44 15 b0 	vmovups XMMWORD PTR [r13+rdx*1-0x50],xmm0
  21c7bc:	c4 c1 78 10 44 13 b0 	vmovups xmm0,XMMWORD PTR [r11+rdx*1-0x50]
  21c7c3:	c4 c1 78 11 44 15 c0 	vmovups XMMWORD PTR [r13+rdx*1-0x40],xmm0
  21c7ca:	c4 c1 78 10 44 13 c0 	vmovups xmm0,XMMWORD PTR [r11+rdx*1-0x40]
  21c7d1:	c4 c1 78 11 44 15 d0 	vmovups XMMWORD PTR [r13+rdx*1-0x30],xmm0
  21c7d8:	c4 c1 78 10 44 13 d0 	vmovups xmm0,XMMWORD PTR [r11+rdx*1-0x30]
  21c7df:	c4 c1 78 11 44 15 e0 	vmovups XMMWORD PTR [r13+rdx*1-0x20],xmm0
  21c7e6:	c4 c1 78 10 44 13 e0 	vmovups xmm0,XMMWORD PTR [r11+rdx*1-0x20]
  21c7ed:	c4 c1 78 11 44 15 f0 	vmovups XMMWORD PTR [r13+rdx*1-0x10],xmm0
  21c7f4:	c4 c1 78 10 44 13 f0 	vmovups xmm0,XMMWORD PTR [r11+rdx*1-0x10]
  21c7fb:	c4 c1 78 11 44 15 00 	vmovups XMMWORD PTR [r13+rdx*1+0x0],xmm0
  21c802:	c4 c1 7a 6f 04 13    	vmovdqu xmm0,XMMWORD PTR [r11+rdx*1]
  21c808:	c4 c1 7a 7f 44 15 10 	vmovdqu XMMWORD PTR [r13+rdx*1+0x10],xmm0
    for (source) |s, i|
  21c80f:	48 83 c0 08          	add    rax,0x8
  21c813:	48 83 ea 80          	sub    rdx,0xffffffffffffff80
  21c817:	48 39 c7             	cmp    rdi,rax
  21c81a:	75 84                	jne    21c7a0 <Benchmark_reportStats+0x6ba0>
  21c81c:	48 85 f6             	test   rsi,rsi
  21c81f:	74 3f                	je     21c860 <Benchmark_reportStats+0x6c60>
  21c821:	48 c1 e0 04          	shl    rax,0x4
  21c825:	48 8d 94 24 38 02 00 	lea    rdx,[rsp+0x238]
  21c82c:	00 
  21c82d:	48 8d 14 02          	lea    rdx,[rdx+rax*1]
  21c831:	4c 01 ca             	add    rdx,r9
  21c834:	4c 01 f8             	add    rax,r15
  21c837:	48 01 c8             	add    rax,rcx
  21c83a:	48 f7 de             	neg    rsi
  21c83d:	31 c9                	xor    ecx,ecx
  21c83f:	90                   	nop
        dest[i] = s;
  21c840:	c5 fa 6f 04 08       	vmovdqu xmm0,XMMWORD PTR [rax+rcx*1]
  21c845:	c5 fa 7f 04 0a       	vmovdqu XMMWORD PTR [rdx+rcx*1],xmm0
    for (source) |s, i|
  21c84a:	48 83 c1 10          	add    rcx,0x10
  21c84e:	48 83 c6 01          	add    rsi,0x1
  21c852:	75 ec                	jne    21c840 <Benchmark_reportStats+0x6c40>
  21c854:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21c85b:	00 00 00 00 00 
  21c860:	4c 8b 4c 24 38       	mov    r9,QWORD PTR [rsp+0x38]
                    if (lessThan(items[B2.end - 1], items[A2.start])) {
  21c865:	4c 89 c8             	mov    rax,r9
  21c868:	48 c1 e0 04          	shl    rax,0x4
  21c86c:	48 8b 4c 24 78       	mov    rcx,QWORD PTR [rsp+0x78]
  21c871:	4d 8b 14 0f          	mov    r10,QWORD PTR [r15+rcx*1]
  21c875:	4d 39 54 07 f0       	cmp    QWORD PTR [r15+rax*1-0x10],r10
  21c87a:	0f 83 90 00 00 00    	jae    21c910 <Benchmark_reportStats+0x6d10>
  21c880:	48 8b 54 24 18       	mov    rdx,QWORD PTR [rsp+0x18]
        return self.end - self.start;
  21c885:	48 89 d0             	mov    rax,rdx
  21c888:	4c 8b 6c 24 10       	mov    r13,QWORD PTR [rsp+0x10]
  21c88d:	4c 29 e8             	sub    rax,r13
  21c890:	4c 89 cf             	mov    rdi,r9
  21c893:	48 8b 5c 24 20       	mov    rbx,QWORD PTR [rsp+0x20]
  21c898:	48 29 df             	sub    rdi,rbx
  21c89b:	49 89 c2             	mov    r10,rax
                        mem.copy(T, cache[A1.length() + B2.length() ..], items[A2.start..A2.end]);
  21c89e:	48 8d 04 07          	lea    rax,[rdi+rax*1]
  21c8a2:	b9 00 02 00 00       	mov    ecx,0x200
  21c8a7:	48 29 c1             	sub    rcx,rax
  21c8aa:	48 29 d3             	sub    rbx,rdx
    assert(dest.len >= source.len);
  21c8ad:	48 39 d9             	cmp    rcx,rbx
  21c8b0:	4c 8b 5c 24 60       	mov    r11,QWORD PTR [rsp+0x60]
  21c8b5:	4c 8b 74 24 58       	mov    r14,QWORD PTR [rsp+0x58]
  21c8ba:	0f 82 ac 1e 00 00    	jb     21e76c <Benchmark_reportStats+0x8b6c>
    for (source) |s, i|
  21c8c0:	48 85 db             	test   rbx,rbx
  21c8c3:	4c 8b 44 24 30       	mov    r8,QWORD PTR [rsp+0x30]
  21c8c8:	0f 84 a6 02 00 00    	je     21cb74 <Benchmark_reportStats+0x6f74>
  21c8ce:	48 8b 44 24 50       	mov    rax,QWORD PTR [rsp+0x50]
  21c8d3:	4a 8d 0c 30          	lea    rcx,[rax+r14*1]
  21c8d7:	89 d8                	mov    eax,ebx
  21c8d9:	83 e0 07             	and    eax,0x7
  21c8dc:	48 83 f9 07          	cmp    rcx,0x7
  21c8e0:	0f 83 6a 01 00 00    	jae    21ca50 <Benchmark_reportStats+0x6e50>
  21c8e6:	4d 89 d9             	mov    r9,r11
  21c8e9:	31 c9                	xor    ecx,ecx
  21c8eb:	48 85 c0             	test   rax,rax
  21c8ee:	4d 89 cb             	mov    r11,r9
  21c8f1:	4c 8b 4c 24 38       	mov    r9,QWORD PTR [rsp+0x38]
  21c8f6:	0f 85 1c 02 00 00    	jne    21cb18 <Benchmark_reportStats+0x6f18>
  21c8fc:	e9 73 02 00 00       	jmp    21cb74 <Benchmark_reportStats+0x6f74>
  21c901:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21c908:	0f 1f 84 00 00 00 00 
  21c90f:	00 
  21c910:	48 8b 5c 24 20       	mov    rbx,QWORD PTR [rsp+0x20]
                    } else if (lessThan(items[B2.start], items[A2.end - 1])) {
  21c915:	48 89 d8             	mov    rax,rbx
  21c918:	48 c1 e0 04          	shl    rax,0x4
  21c91c:	4d 8b 1c 07          	mov    r11,QWORD PTR [r15+rax*1]
  21c920:	48 8b 4c 24 18       	mov    rcx,QWORD PTR [rsp+0x18]
        return self.end - self.start;
  21c925:	48 89 ca             	mov    rdx,rcx
  21c928:	4c 8b 6c 24 10       	mov    r13,QWORD PTR [rsp+0x10]
  21c92d:	4c 29 ea             	sub    rdx,r13
  21c930:	be 00 02 00 00       	mov    esi,0x200
  21c935:	48 29 d6             	sub    rsi,rdx
  21c938:	4d 3b 5c 07 f0       	cmp    r11,QWORD PTR [r15+rax*1-0x10]
                    } else if (lessThan(items[B2.start], items[A2.end - 1])) {
  21c93d:	48 89 54 24 78       	mov    QWORD PTR [rsp+0x78],rdx
  21c942:	0f 83 b8 00 00 00    	jae    21ca00 <Benchmark_reportStats+0x6e00>
  21c948:	48 89 b4 24 50 01 00 	mov    QWORD PTR [rsp+0x150],rsi
  21c94f:	00 
  21c950:	48 89 d0             	mov    rax,rdx
  21c953:	48 c1 e0 04          	shl    rax,0x4
  21c957:	4c 8d 0c 04          	lea    r9,[rsp+rax*1]
  21c95b:	49 81 c1 28 02 00 00 	add    r9,0x228
  21c962:	48 89 ca             	mov    rdx,rcx
  21c965:	45 31 ed             	xor    r13d,r13d
  21c968:	eb 14                	jmp    21c97e <Benchmark_reportStats+0x6d7e>
  21c96a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  21c970:	48 89 d9             	mov    rcx,rbx
  21c973:	48 c1 e1 04          	shl    rcx,0x4
  21c977:	4d 8b 1c 0f          	mov    r11,QWORD PTR [r15+rcx*1]
  21c97b:	4c 8b 10             	mov    r10,QWORD PTR [rax]
        if (!lessThan(from[B_index], from[A_index])) {
  21c97e:	48 89 d9             	mov    rcx,rbx
  21c981:	48 c1 e1 04          	shl    rcx,0x4
  21c985:	4d 8d 04 0f          	lea    r8,[r15+rcx*1]
  21c989:	48 89 d6             	mov    rsi,rdx
  21c98c:	48 c1 e6 04          	shl    rsi,0x4
  21c990:	49 8d 04 37          	lea    rax,[r15+rsi*1]
  21c994:	4d 89 ee             	mov    r14,r13
  21c997:	49 c1 e6 04          	shl    r14,0x4
  21c99b:	4b 8d 3c 31          	lea    rdi,[r9+r14*1]
  21c99f:	4d 39 d3             	cmp    r11,r10
  21c9a2:	73 2c                	jae    21c9d0 <Benchmark_reportStats+0x6dd0>
            into[insert_index] = from[B_index];
  21c9a4:	c4 c1 7a 6f 00       	vmovdqu xmm0,XMMWORD PTR [r8]
  21c9a9:	c5 fa 7f 07          	vmovdqu XMMWORD PTR [rdi],xmm0
            B_index += 1;
  21c9ad:	48 83 c3 01          	add    rbx,0x1
            insert_index += 1;
  21c9b1:	49 83 c5 01          	add    r13,0x1
            if (B_index == B_last) {
  21c9b5:	48 3b 5c 24 38       	cmp    rbx,QWORD PTR [rsp+0x38]
  21c9ba:	75 b4                	jne    21c970 <Benchmark_reportStats+0x6d70>
  21c9bc:	e9 0b 03 00 00       	jmp    21cccc <Benchmark_reportStats+0x70cc>
  21c9c1:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21c9c8:	0f 1f 84 00 00 00 00 
  21c9cf:	00 
            into[insert_index] = from[A_index];
  21c9d0:	c5 fa 6f 00          	vmovdqu xmm0,XMMWORD PTR [rax]
  21c9d4:	c5 fa 7f 07          	vmovdqu XMMWORD PTR [rdi],xmm0
            A_index += 1;
  21c9d8:	48 83 c2 01          	add    rdx,0x1
            insert_index += 1;
  21c9dc:	49 83 c5 01          	add    r13,0x1
            if (A_index == A_last) {
  21c9e0:	48 3b 54 24 20       	cmp    rdx,QWORD PTR [rsp+0x20]
  21c9e5:	0f 84 64 03 00 00    	je     21cd4f <Benchmark_reportStats+0x714f>
  21c9eb:	48 89 d0             	mov    rax,rdx
  21c9ee:	48 c1 e0 04          	shl    rax,0x4
  21c9f2:	4c 01 f8             	add    rax,r15
  21c9f5:	e9 76 ff ff ff       	jmp    21c970 <Benchmark_reportStats+0x6d70>
  21c9fa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
                        mem.copy(T, cache[A1.length()..], items[A2.start..A2.end]);
  21ca00:	49 89 d8             	mov    r8,rbx
  21ca03:	49 29 c8             	sub    r8,rcx
    assert(dest.len >= source.len);
  21ca06:	4c 39 c6             	cmp    rsi,r8
  21ca09:	4c 8b 74 24 58       	mov    r14,QWORD PTR [rsp+0x58]
  21ca0e:	0f 82 58 1d 00 00    	jb     21e76c <Benchmark_reportStats+0x8b6c>
    for (source) |s, i|
  21ca14:	4d 85 c0             	test   r8,r8
  21ca17:	4c 8b 5c 24 60       	mov    r11,QWORD PTR [rsp+0x60]
  21ca1c:	0f 84 d2 04 00 00    	je     21cef4 <Benchmark_reportStats+0x72f4>
  21ca22:	48 8b 44 24 50       	mov    rax,QWORD PTR [rsp+0x50]
  21ca27:	4a 8d 0c 30          	lea    rcx,[rax+r14*1]
  21ca2b:	44 89 c0             	mov    eax,r8d
  21ca2e:	83 e0 07             	and    eax,0x7
  21ca31:	48 83 f9 07          	cmp    rcx,0x7
  21ca35:	0f 83 95 03 00 00    	jae    21cdd0 <Benchmark_reportStats+0x71d0>
  21ca3b:	31 d2                	xor    edx,edx
  21ca3d:	48 85 c0             	test   rax,rax
  21ca40:	48 8b 5c 24 20       	mov    rbx,QWORD PTR [rsp+0x20]
  21ca45:	0f 85 4a 04 00 00    	jne    21ce95 <Benchmark_reportStats+0x7295>
  21ca4b:	e9 a4 04 00 00       	jmp    21cef4 <Benchmark_reportStats+0x72f4>
  21ca50:	48 29 c3             	sub    rbx,rax
  21ca53:	48 8b 4c 24 68       	mov    rcx,QWORD PTR [rsp+0x68]
  21ca58:	48 c1 e1 04          	shl    rcx,0x4
  21ca5c:	4c 01 f9             	add    rcx,r15
  21ca5f:	48 8b 74 24 28       	mov    rsi,QWORD PTR [rsp+0x28]
  21ca64:	4a 8d 14 2e          	lea    rdx,[rsi+r13*1]
  21ca68:	4c 01 c2             	add    rdx,r8
  21ca6b:	48 c1 e2 04          	shl    rdx,0x4
  21ca6f:	48 01 ca             	add    rdx,rcx
  21ca72:	48 83 c2 70          	add    rdx,0x70
  21ca76:	49 8d 34 30          	lea    rsi,[r8+rsi*1]
  21ca7a:	4d 89 d9             	mov    r9,r11
  21ca7d:	4c 01 de             	add    rsi,r11
  21ca80:	48 c1 e6 04          	shl    rsi,0x4
  21ca84:	48 03 b4 24 48 01 00 	add    rsi,QWORD PTR [rsp+0x148]
  21ca8b:	00 
  21ca8c:	49 89 db             	mov    r11,rbx
  21ca8f:	31 db                	xor    ebx,ebx
  21ca91:	31 c9                	xor    ecx,ecx
  21ca93:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21ca9a:	84 00 00 00 00 00 
        dest[i] = s;
  21caa0:	c5 f8 10 44 1a 90    	vmovups xmm0,XMMWORD PTR [rdx+rbx*1-0x70]
  21caa6:	c5 f8 11 44 1e 90    	vmovups XMMWORD PTR [rsi+rbx*1-0x70],xmm0
  21caac:	c5 f8 10 44 1a a0    	vmovups xmm0,XMMWORD PTR [rdx+rbx*1-0x60]
  21cab2:	c5 f8 11 44 1e a0    	vmovups XMMWORD PTR [rsi+rbx*1-0x60],xmm0
  21cab8:	c5 f8 10 44 1a b0    	vmovups xmm0,XMMWORD PTR [rdx+rbx*1-0x50]
  21cabe:	c5 f8 11 44 1e b0    	vmovups XMMWORD PTR [rsi+rbx*1-0x50],xmm0
  21cac4:	c5 f8 10 44 1a c0    	vmovups xmm0,XMMWORD PTR [rdx+rbx*1-0x40]
  21caca:	c5 f8 11 44 1e c0    	vmovups XMMWORD PTR [rsi+rbx*1-0x40],xmm0
  21cad0:	c5 f8 10 44 1a d0    	vmovups xmm0,XMMWORD PTR [rdx+rbx*1-0x30]
  21cad6:	c5 f8 11 44 1e d0    	vmovups XMMWORD PTR [rsi+rbx*1-0x30],xmm0
  21cadc:	c5 f8 10 44 1a e0    	vmovups xmm0,XMMWORD PTR [rdx+rbx*1-0x20]
  21cae2:	c5 f8 11 44 1e e0    	vmovups XMMWORD PTR [rsi+rbx*1-0x20],xmm0
  21cae8:	c5 f8 10 44 1a f0    	vmovups xmm0,XMMWORD PTR [rdx+rbx*1-0x10]
  21caee:	c5 f8 11 44 1e f0    	vmovups XMMWORD PTR [rsi+rbx*1-0x10],xmm0
  21caf4:	c5 fa 6f 04 1a       	vmovdqu xmm0,XMMWORD PTR [rdx+rbx*1]
  21caf9:	c5 fa 7f 04 1e       	vmovdqu XMMWORD PTR [rsi+rbx*1],xmm0
    for (source) |s, i|
  21cafe:	48 83 c1 08          	add    rcx,0x8
  21cb02:	48 83 eb 80          	sub    rbx,0xffffffffffffff80
  21cb06:	49 39 cb             	cmp    r11,rcx
  21cb09:	75 95                	jne    21caa0 <Benchmark_reportStats+0x6ea0>
  21cb0b:	48 85 c0             	test   rax,rax
  21cb0e:	4d 89 cb             	mov    r11,r9
  21cb11:	4c 8b 4c 24 38       	mov    r9,QWORD PTR [rsp+0x38]
  21cb16:	74 5c                	je     21cb74 <Benchmark_reportStats+0x6f74>
  21cb18:	4a 8d 14 01          	lea    rdx,[rcx+r8*1]
  21cb1c:	48 8b 74 24 28       	mov    rsi,QWORD PTR [rsp+0x28]
  21cb21:	48 89 f3             	mov    rbx,rsi
  21cb24:	48 01 da             	add    rdx,rbx
  21cb27:	4c 01 da             	add    rdx,r11
  21cb2a:	48 c1 e2 04          	shl    rdx,0x4
  21cb2e:	48 03 94 24 e8 00 00 	add    rdx,QWORD PTR [rsp+0xe8]
  21cb35:	00 
  21cb36:	48 8b 74 24 68       	mov    rsi,QWORD PTR [rsp+0x68]
  21cb3b:	48 c1 e6 04          	shl    rsi,0x4
  21cb3f:	4c 01 fe             	add    rsi,r15
  21cb42:	4c 01 e9             	add    rcx,r13
  21cb45:	48 01 d9             	add    rcx,rbx
  21cb48:	4c 01 c1             	add    rcx,r8
  21cb4b:	48 c1 e1 04          	shl    rcx,0x4
  21cb4f:	48 01 f1             	add    rcx,rsi
  21cb52:	48 f7 d8             	neg    rax
  21cb55:	31 f6                	xor    esi,esi
  21cb57:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  21cb5e:	00 00 
        dest[i] = s;
  21cb60:	c5 fa 6f 04 31       	vmovdqu xmm0,XMMWORD PTR [rcx+rsi*1]
  21cb65:	c5 fa 7f 04 32       	vmovdqu XMMWORD PTR [rdx+rsi*1],xmm0
    for (source) |s, i|
  21cb6a:	48 83 c6 10          	add    rsi,0x10
  21cb6e:	48 83 c0 01          	add    rax,0x1
  21cb72:	75 ec                	jne    21cb60 <Benchmark_reportStats+0x6f60>
                        mem.copy(T, cache[A1.length()..], items[B2.start..B2.end]);
  21cb74:	b8 00 02 00 00       	mov    eax,0x200
  21cb79:	4c 89 d6             	mov    rsi,r10
  21cb7c:	48 29 f0             	sub    rax,rsi
    assert(dest.len >= source.len);
  21cb7f:	48 39 f8             	cmp    rax,rdi
  21cb82:	0f 82 e4 1b 00 00    	jb     21e76c <Benchmark_reportStats+0x8b6c>
    for (source) |s, i|
  21cb88:	48 85 ff             	test   rdi,rdi
  21cb8b:	0f 84 dd 06 00 00    	je     21d26e <Benchmark_reportStats+0x766e>
  21cb91:	48 8b 44 24 50       	mov    rax,QWORD PTR [rsp+0x50]
  21cb96:	4a 8d 0c 18          	lea    rcx,[rax+r11*1]
  21cb9a:	89 f8                	mov    eax,edi
  21cb9c:	83 e0 07             	and    eax,0x7
  21cb9f:	48 83 f9 07          	cmp    rcx,0x7
  21cba3:	73 10                	jae    21cbb5 <Benchmark_reportStats+0x6fb5>
  21cba5:	31 c9                	xor    ecx,ecx
  21cba7:	48 85 c0             	test   rax,rax
  21cbaa:	0f 85 c0 00 00 00    	jne    21cc70 <Benchmark_reportStats+0x7070>
  21cbb0:	e9 0f 01 00 00       	jmp    21ccc4 <Benchmark_reportStats+0x70c4>
  21cbb5:	48 29 c7             	sub    rdi,rax
  21cbb8:	48 8b 8c 24 30 01 00 	mov    rcx,QWORD PTR [rsp+0x130]
  21cbbf:	00 
  21cbc0:	49 8d 0c 0f          	lea    rcx,[r15+rcx*1]
  21cbc4:	4b 8d 14 28          	lea    rdx,[r8+r13*1]
  21cbc8:	48 8b 74 24 28       	mov    rsi,QWORD PTR [rsp+0x28]
  21cbcd:	48 01 f2             	add    rdx,rsi
  21cbd0:	4c 01 f2             	add    rdx,r14
  21cbd3:	48 c1 e2 04          	shl    rdx,0x4
  21cbd7:	48 01 ca             	add    rdx,rcx
  21cbda:	48 83 c2 70          	add    rdx,0x70
  21cbde:	4a 8d 34 06          	lea    rsi,[rsi+r8*1]
  21cbe2:	48 c1 e6 04          	shl    rsi,0x4
  21cbe6:	48 03 b4 24 40 01 00 	add    rsi,QWORD PTR [rsp+0x140]
  21cbed:	00 
  21cbee:	31 db                	xor    ebx,ebx
  21cbf0:	31 c9                	xor    ecx,ecx
  21cbf2:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21cbf9:	1f 84 00 00 00 00 00 
        dest[i] = s;
  21cc00:	c5 f8 10 44 1a 90    	vmovups xmm0,XMMWORD PTR [rdx+rbx*1-0x70]
  21cc06:	c5 f8 11 44 1e 90    	vmovups XMMWORD PTR [rsi+rbx*1-0x70],xmm0
  21cc0c:	c5 f8 10 44 1a a0    	vmovups xmm0,XMMWORD PTR [rdx+rbx*1-0x60]
  21cc12:	c5 f8 11 44 1e a0    	vmovups XMMWORD PTR [rsi+rbx*1-0x60],xmm0
  21cc18:	c5 f8 10 44 1a b0    	vmovups xmm0,XMMWORD PTR [rdx+rbx*1-0x50]
  21cc1e:	c5 f8 11 44 1e b0    	vmovups XMMWORD PTR [rsi+rbx*1-0x50],xmm0
  21cc24:	c5 f8 10 44 1a c0    	vmovups xmm0,XMMWORD PTR [rdx+rbx*1-0x40]
  21cc2a:	c5 f8 11 44 1e c0    	vmovups XMMWORD PTR [rsi+rbx*1-0x40],xmm0
  21cc30:	c5 f8 10 44 1a d0    	vmovups xmm0,XMMWORD PTR [rdx+rbx*1-0x30]
  21cc36:	c5 f8 11 44 1e d0    	vmovups XMMWORD PTR [rsi+rbx*1-0x30],xmm0
  21cc3c:	c5 f8 10 44 1a e0    	vmovups xmm0,XMMWORD PTR [rdx+rbx*1-0x20]
  21cc42:	c5 f8 11 44 1e e0    	vmovups XMMWORD PTR [rsi+rbx*1-0x20],xmm0
  21cc48:	c5 f8 10 44 1a f0    	vmovups xmm0,XMMWORD PTR [rdx+rbx*1-0x10]
  21cc4e:	c5 f8 11 44 1e f0    	vmovups XMMWORD PTR [rsi+rbx*1-0x10],xmm0
  21cc54:	c5 fa 6f 04 1a       	vmovdqu xmm0,XMMWORD PTR [rdx+rbx*1]
  21cc59:	c5 fa 7f 04 1e       	vmovdqu XMMWORD PTR [rsi+rbx*1],xmm0
    for (source) |s, i|
  21cc5e:	48 83 c1 08          	add    rcx,0x8
  21cc62:	48 83 eb 80          	sub    rbx,0xffffffffffffff80
  21cc66:	48 39 cf             	cmp    rdi,rcx
  21cc69:	75 95                	jne    21cc00 <Benchmark_reportStats+0x7000>
  21cc6b:	48 85 c0             	test   rax,rax
  21cc6e:	74 54                	je     21ccc4 <Benchmark_reportStats+0x70c4>
  21cc70:	48 8b 7c 24 28       	mov    rdi,QWORD PTR [rsp+0x28]
  21cc75:	48 8d 14 39          	lea    rdx,[rcx+rdi*1]
  21cc79:	4c 01 c2             	add    rdx,r8
  21cc7c:	48 c1 e2 04          	shl    rdx,0x4
  21cc80:	48 03 94 24 28 01 00 	add    rdx,QWORD PTR [rsp+0x128]
  21cc87:	00 
  21cc88:	48 8b b4 24 30 01 00 	mov    rsi,QWORD PTR [rsp+0x130]
  21cc8f:	00 
  21cc90:	49 8d 34 37          	lea    rsi,[r15+rsi*1]
  21cc94:	4c 01 e9             	add    rcx,r13
  21cc97:	4c 01 c1             	add    rcx,r8
  21cc9a:	48 01 f9             	add    rcx,rdi
  21cc9d:	4c 01 f1             	add    rcx,r14
  21cca0:	48 c1 e1 04          	shl    rcx,0x4
  21cca4:	48 01 f1             	add    rcx,rsi
  21cca7:	48 f7 d8             	neg    rax
  21ccaa:	31 f6                	xor    esi,esi
  21ccac:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
        dest[i] = s;
  21ccb0:	c5 fa 6f 04 31       	vmovdqu xmm0,XMMWORD PTR [rcx+rsi*1]
  21ccb5:	c5 fa 7f 04 32       	vmovdqu XMMWORD PTR [rdx+rsi*1],xmm0
    for (source) |s, i|
  21ccba:	48 83 c6 10          	add    rsi,0x10
  21ccbe:	48 83 c0 01          	add    rax,0x1
  21ccc2:	75 ec                	jne    21ccb0 <Benchmark_reportStats+0x70b0>
  21ccc4:	4c 89 d6             	mov    rsi,r10
  21ccc7:	e9 a2 05 00 00       	jmp    21d26e <Benchmark_reportStats+0x766e>
  21cccc:	48 8b 8c 24 50 01 00 	mov    rcx,QWORD PTR [rsp+0x150]
  21ccd3:	00 
                mem.copy(T, into[insert_index..], from[A_index..A_last]);
  21ccd4:	4c 29 e9             	sub    rcx,r13
  21ccd7:	48 8b 7c 24 20       	mov    rdi,QWORD PTR [rsp+0x20]
  21ccdc:	48 29 d7             	sub    rdi,rdx
    assert(dest.len >= source.len);
  21ccdf:	48 39 f9             	cmp    rcx,rdi
  21cce2:	4c 8b 5c 24 60       	mov    r11,QWORD PTR [rsp+0x60]
  21cce7:	0f 82 7f 1a 00 00    	jb     21e76c <Benchmark_reportStats+0x8b6c>
    for (source) |s, i|
  21cced:	48 85 ff             	test   rdi,rdi
  21ccf0:	4c 8b 4c 24 38       	mov    r9,QWORD PTR [rsp+0x38]
  21ccf5:	4c 8b 6c 24 10       	mov    r13,QWORD PTR [rsp+0x10]
  21ccfa:	0f 84 64 05 00 00    	je     21d264 <Benchmark_reportStats+0x7664>
  21cd00:	48 8b 8c 24 68 01 00 	mov    rcx,QWORD PTR [rsp+0x168]
  21cd07:	00 
  21cd08:	4a 8d 0c 29          	lea    rcx,[rcx+r13*1]
  21cd0c:	4c 8b 54 24 28       	mov    r10,QWORD PTR [rsp+0x28]
  21cd11:	4c 01 d1             	add    rcx,r10
  21cd14:	4c 8b 44 24 30       	mov    r8,QWORD PTR [rsp+0x30]
  21cd19:	4c 01 c1             	add    rcx,r8
  21cd1c:	48 8b 5c 24 58       	mov    rbx,QWORD PTR [rsp+0x58]
  21cd21:	48 01 d9             	add    rcx,rbx
  21cd24:	48 29 d1             	sub    rcx,rdx
  21cd27:	83 e7 07             	and    edi,0x7
  21cd2a:	48 83 f9 07          	cmp    rcx,0x7
  21cd2e:	49 89 fb             	mov    r11,rdi
  21cd31:	0f 83 3c 03 00 00    	jae    21d073 <Benchmark_reportStats+0x7473>
  21cd37:	4d 89 da             	mov    r10,r11
  21cd3a:	31 c9                	xor    ecx,ecx
  21cd3c:	4d 85 d2             	test   r10,r10
  21cd3f:	4c 8b 5c 24 60       	mov    r11,QWORD PTR [rsp+0x60]
  21cd44:	0f 85 df 03 00 00    	jne    21d129 <Benchmark_reportStats+0x7529>
  21cd4a:	e9 15 05 00 00       	jmp    21d264 <Benchmark_reportStats+0x7664>
  21cd4f:	48 8b 94 24 50 01 00 	mov    rdx,QWORD PTR [rsp+0x150]
  21cd56:	00 
                mem.copy(T, into[insert_index..], from[B_index..B_last]);
  21cd57:	4c 29 ea             	sub    rdx,r13
  21cd5a:	4c 8b 4c 24 38       	mov    r9,QWORD PTR [rsp+0x38]
  21cd5f:	4c 89 c8             	mov    rax,r9
  21cd62:	48 29 d8             	sub    rax,rbx
    assert(dest.len >= source.len);
  21cd65:	48 39 c2             	cmp    rdx,rax
  21cd68:	4c 8b 5c 24 60       	mov    r11,QWORD PTR [rsp+0x60]
  21cd6d:	48 8b 74 24 78       	mov    rsi,QWORD PTR [rsp+0x78]
  21cd72:	0f 82 f4 19 00 00    	jb     21e76c <Benchmark_reportStats+0x8b6c>
    for (source) |s, i|
  21cd78:	48 85 c0             	test   rax,rax
  21cd7b:	4c 8b 6c 24 10       	mov    r13,QWORD PTR [rsp+0x10]
  21cd80:	0f 84 e3 02 00 00    	je     21d069 <Benchmark_reportStats+0x7469>
  21cd86:	48 8b 94 24 70 01 00 	mov    rdx,QWORD PTR [rsp+0x170]
  21cd8d:	00 
  21cd8e:	4a 8d 14 2a          	lea    rdx,[rdx+r13*1]
  21cd92:	4c 8b 54 24 28       	mov    r10,QWORD PTR [rsp+0x28]
  21cd97:	4c 89 d6             	mov    rsi,r10
  21cd9a:	48 01 f2             	add    rdx,rsi
  21cd9d:	4c 8b 54 24 30       	mov    r10,QWORD PTR [rsp+0x30]
  21cda2:	4c 01 d2             	add    rdx,r10
  21cda5:	48 8b 7c 24 58       	mov    rdi,QWORD PTR [rsp+0x58]
  21cdaa:	48 01 fa             	add    rdx,rdi
  21cdad:	4c 01 da             	add    rdx,r11
  21cdb0:	48 29 da             	sub    rdx,rbx
  21cdb3:	83 e0 07             	and    eax,0x7
  21cdb6:	48 83 fa 07          	cmp    rdx,0x7
  21cdba:	0f 83 a9 03 00 00    	jae    21d169 <Benchmark_reportStats+0x7569>
  21cdc0:	31 d2                	xor    edx,edx
  21cdc2:	48 85 c0             	test   rax,rax
  21cdc5:	0f 85 5d 04 00 00    	jne    21d228 <Benchmark_reportStats+0x7628>
  21cdcb:	e9 94 04 00 00       	jmp    21d264 <Benchmark_reportStats+0x7664>
  21cdd0:	4c 89 c6             	mov    rsi,r8
  21cdd3:	48 29 c6             	sub    rsi,rax
  21cdd6:	48 8b 4c 24 68       	mov    rcx,QWORD PTR [rsp+0x68]
  21cddb:	48 c1 e1 04          	shl    rcx,0x4
  21cddf:	4c 01 f9             	add    rcx,r15
  21cde2:	48 8b 5c 24 28       	mov    rbx,QWORD PTR [rsp+0x28]
  21cde7:	4a 8d 14 2b          	lea    rdx,[rbx+r13*1]
  21cdeb:	4c 8b 54 24 30       	mov    r10,QWORD PTR [rsp+0x30]
  21cdf0:	4c 01 d2             	add    rdx,r10
  21cdf3:	48 c1 e2 04          	shl    rdx,0x4
  21cdf7:	48 8d 3c 0a          	lea    rdi,[rdx+rcx*1]
  21cdfb:	48 83 c7 70          	add    rdi,0x70
  21cdff:	4a 8d 1c 13          	lea    rbx,[rbx+r10*1]
  21ce03:	48 c1 e3 04          	shl    rbx,0x4
  21ce07:	48 03 9c 24 40 01 00 	add    rbx,QWORD PTR [rsp+0x140]
  21ce0e:	00 
  21ce0f:	31 c9                	xor    ecx,ecx
  21ce11:	31 d2                	xor    edx,edx
  21ce13:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21ce1a:	84 00 00 00 00 00 
        dest[i] = s;
  21ce20:	c5 f8 10 44 0f 90    	vmovups xmm0,XMMWORD PTR [rdi+rcx*1-0x70]
  21ce26:	c5 f8 11 44 0b 90    	vmovups XMMWORD PTR [rbx+rcx*1-0x70],xmm0
  21ce2c:	c5 f8 10 44 0f a0    	vmovups xmm0,XMMWORD PTR [rdi+rcx*1-0x60]
  21ce32:	c5 f8 11 44 0b a0    	vmovups XMMWORD PTR [rbx+rcx*1-0x60],xmm0
  21ce38:	c5 f8 10 44 0f b0    	vmovups xmm0,XMMWORD PTR [rdi+rcx*1-0x50]
  21ce3e:	c5 f8 11 44 0b b0    	vmovups XMMWORD PTR [rbx+rcx*1-0x50],xmm0
  21ce44:	c5 f8 10 44 0f c0    	vmovups xmm0,XMMWORD PTR [rdi+rcx*1-0x40]
  21ce4a:	c5 f8 11 44 0b c0    	vmovups XMMWORD PTR [rbx+rcx*1-0x40],xmm0
  21ce50:	c5 f8 10 44 0f d0    	vmovups xmm0,XMMWORD PTR [rdi+rcx*1-0x30]
  21ce56:	c5 f8 11 44 0b d0    	vmovups XMMWORD PTR [rbx+rcx*1-0x30],xmm0
  21ce5c:	c5 f8 10 44 0f e0    	vmovups xmm0,XMMWORD PTR [rdi+rcx*1-0x20]
  21ce62:	c5 f8 11 44 0b e0    	vmovups XMMWORD PTR [rbx+rcx*1-0x20],xmm0
  21ce68:	c5 f8 10 44 0f f0    	vmovups xmm0,XMMWORD PTR [rdi+rcx*1-0x10]
  21ce6e:	c5 f8 11 44 0b f0    	vmovups XMMWORD PTR [rbx+rcx*1-0x10],xmm0
  21ce74:	c5 fa 6f 04 0f       	vmovdqu xmm0,XMMWORD PTR [rdi+rcx*1]
  21ce79:	c5 fa 7f 04 0b       	vmovdqu XMMWORD PTR [rbx+rcx*1],xmm0
    for (source) |s, i|
  21ce7e:	48 83 c2 08          	add    rdx,0x8
  21ce82:	48 83 e9 80          	sub    rcx,0xffffffffffffff80
  21ce86:	48 39 d6             	cmp    rsi,rdx
  21ce89:	75 95                	jne    21ce20 <Benchmark_reportStats+0x7220>
  21ce8b:	48 85 c0             	test   rax,rax
  21ce8e:	48 8b 5c 24 20       	mov    rbx,QWORD PTR [rsp+0x20]
  21ce93:	74 5f                	je     21cef4 <Benchmark_reportStats+0x72f4>
  21ce95:	48 8b 7c 24 28       	mov    rdi,QWORD PTR [rsp+0x28]
  21ce9a:	48 8d 34 3a          	lea    rsi,[rdx+rdi*1]
  21ce9e:	4c 8b 54 24 30       	mov    r10,QWORD PTR [rsp+0x30]
  21cea3:	4c 01 d6             	add    rsi,r10
  21cea6:	48 c1 e6 04          	shl    rsi,0x4
  21ceaa:	48 03 b4 24 28 01 00 	add    rsi,QWORD PTR [rsp+0x128]
  21ceb1:	00 
  21ceb2:	48 8b 4c 24 68       	mov    rcx,QWORD PTR [rsp+0x68]
  21ceb7:	48 c1 e1 04          	shl    rcx,0x4
  21cebb:	4c 01 f9             	add    rcx,r15
  21cebe:	4c 01 ea             	add    rdx,r13
  21cec1:	48 01 fa             	add    rdx,rdi
  21cec4:	4c 01 d2             	add    rdx,r10
  21cec7:	48 c1 e2 04          	shl    rdx,0x4
  21cecb:	48 01 ca             	add    rdx,rcx
  21cece:	48 f7 d8             	neg    rax
  21ced1:	31 c9                	xor    ecx,ecx
  21ced3:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21ceda:	84 00 00 00 00 00 
        dest[i] = s;
  21cee0:	c5 fa 6f 04 0a       	vmovdqu xmm0,XMMWORD PTR [rdx+rcx*1]
  21cee5:	c5 fa 7f 04 0e       	vmovdqu XMMWORD PTR [rsi+rcx*1],xmm0
    for (source) |s, i|
  21ceea:	48 83 c1 10          	add    rcx,0x10
  21ceee:	48 83 c0 01          	add    rax,0x1
  21cef2:	75 ec                	jne    21cee0 <Benchmark_reportStats+0x72e0>
  21cef4:	48 8b 74 24 78       	mov    rsi,QWORD PTR [rsp+0x78]
                        mem.copy(T, cache[A1.length() + A2.length() ..], items[B2.start..B2.end]);
  21cef9:	49 01 f0             	add    r8,rsi
  21cefc:	b8 00 02 00 00       	mov    eax,0x200
  21cf01:	4c 29 c0             	sub    rax,r8
  21cf04:	4c 89 ca             	mov    rdx,r9
  21cf07:	48 29 da             	sub    rdx,rbx
    assert(dest.len >= source.len);
  21cf0a:	48 39 d0             	cmp    rax,rdx
  21cf0d:	0f 82 59 18 00 00    	jb     21e76c <Benchmark_reportStats+0x8b6c>
    for (source) |s, i|
  21cf13:	48 85 d2             	test   rdx,rdx
  21cf16:	0f 84 52 03 00 00    	je     21d26e <Benchmark_reportStats+0x766e>
  21cf1c:	48 8b 44 24 50       	mov    rax,QWORD PTR [rsp+0x50]
  21cf21:	4a 8d 0c 18          	lea    rcx,[rax+r11*1]
  21cf25:	89 d0                	mov    eax,edx
  21cf27:	83 e0 07             	and    eax,0x7
  21cf2a:	48 83 f9 07          	cmp    rcx,0x7
  21cf2e:	73 10                	jae    21cf40 <Benchmark_reportStats+0x7340>
  21cf30:	31 c9                	xor    ecx,ecx
  21cf32:	48 85 c0             	test   rax,rax
  21cf35:	0f 85 c9 00 00 00    	jne    21d004 <Benchmark_reportStats+0x7404>
  21cf3b:	e9 29 03 00 00       	jmp    21d269 <Benchmark_reportStats+0x7669>
  21cf40:	48 29 c2             	sub    rdx,rax
  21cf43:	48 8b 8c 24 30 01 00 	mov    rcx,QWORD PTR [rsp+0x130]
  21cf4a:	00 
  21cf4b:	49 8d 0c 0f          	lea    rcx,[r15+rcx*1]
  21cf4f:	48 8b 5c 24 30       	mov    rbx,QWORD PTR [rsp+0x30]
  21cf54:	4a 8d 34 2b          	lea    rsi,[rbx+r13*1]
  21cf58:	48 8b 7c 24 28       	mov    rdi,QWORD PTR [rsp+0x28]
  21cf5d:	48 01 fe             	add    rsi,rdi
  21cf60:	4c 01 f6             	add    rsi,r14
  21cf63:	48 c1 e6 04          	shl    rsi,0x4
  21cf67:	48 01 ce             	add    rsi,rcx
  21cf6a:	48 8d 3c 3b          	lea    rdi,[rbx+rdi*1]
  21cf6e:	4c 01 f7             	add    rdi,r14
  21cf71:	48 c1 e7 04          	shl    rdi,0x4
  21cf75:	48 03 bc 24 e8 00 00 	add    rdi,QWORD PTR [rsp+0xe8]
  21cf7c:	00 
  21cf7d:	bb 70 00 00 00       	mov    ebx,0x70
  21cf82:	31 c9                	xor    ecx,ecx
  21cf84:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21cf8b:	00 00 00 00 00 
        dest[i] = s;
  21cf90:	c5 f8 10 44 1e 90    	vmovups xmm0,XMMWORD PTR [rsi+rbx*1-0x70]
  21cf96:	c5 f8 11 44 1f 90    	vmovups XMMWORD PTR [rdi+rbx*1-0x70],xmm0
  21cf9c:	c5 f8 10 44 1e a0    	vmovups xmm0,XMMWORD PTR [rsi+rbx*1-0x60]
  21cfa2:	c5 f8 11 44 1f a0    	vmovups XMMWORD PTR [rdi+rbx*1-0x60],xmm0
  21cfa8:	c5 f8 10 44 1e b0    	vmovups xmm0,XMMWORD PTR [rsi+rbx*1-0x50]
  21cfae:	c5 f8 11 44 1f b0    	vmovups XMMWORD PTR [rdi+rbx*1-0x50],xmm0
  21cfb4:	c5 f8 10 44 1e c0    	vmovups xmm0,XMMWORD PTR [rsi+rbx*1-0x40]
  21cfba:	c5 f8 11 44 1f c0    	vmovups XMMWORD PTR [rdi+rbx*1-0x40],xmm0
  21cfc0:	c5 f8 10 44 1e d0    	vmovups xmm0,XMMWORD PTR [rsi+rbx*1-0x30]
  21cfc6:	c5 f8 11 44 1f d0    	vmovups XMMWORD PTR [rdi+rbx*1-0x30],xmm0
  21cfcc:	c5 f8 10 44 1e e0    	vmovups xmm0,XMMWORD PTR [rsi+rbx*1-0x20]
  21cfd2:	c5 f8 11 44 1f e0    	vmovups XMMWORD PTR [rdi+rbx*1-0x20],xmm0
  21cfd8:	c5 f8 10 44 1e f0    	vmovups xmm0,XMMWORD PTR [rsi+rbx*1-0x10]
  21cfde:	c5 f8 11 44 1f f0    	vmovups XMMWORD PTR [rdi+rbx*1-0x10],xmm0
  21cfe4:	c5 fa 6f 04 1e       	vmovdqu xmm0,XMMWORD PTR [rsi+rbx*1]
  21cfe9:	c5 fa 7f 04 1f       	vmovdqu XMMWORD PTR [rdi+rbx*1],xmm0
    for (source) |s, i|
  21cfee:	48 83 c1 08          	add    rcx,0x8
  21cff2:	48 83 eb 80          	sub    rbx,0xffffffffffffff80
  21cff6:	48 39 ca             	cmp    rdx,rcx
  21cff9:	75 95                	jne    21cf90 <Benchmark_reportStats+0x7390>
  21cffb:	48 85 c0             	test   rax,rax
  21cffe:	0f 84 65 02 00 00    	je     21d269 <Benchmark_reportStats+0x7669>
  21d004:	48 8b 5c 24 30       	mov    rbx,QWORD PTR [rsp+0x30]
  21d009:	48 8d 14 19          	lea    rdx,[rcx+rbx*1]
  21d00d:	48 8b 74 24 28       	mov    rsi,QWORD PTR [rsp+0x28]
  21d012:	48 89 f7             	mov    rdi,rsi
  21d015:	48 01 fa             	add    rdx,rdi
  21d018:	4c 01 f2             	add    rdx,r14
  21d01b:	48 c1 e2 04          	shl    rdx,0x4
  21d01f:	48 03 94 24 e8 00 00 	add    rdx,QWORD PTR [rsp+0xe8]
  21d026:	00 
  21d027:	48 8b b4 24 30 01 00 	mov    rsi,QWORD PTR [rsp+0x130]
  21d02e:	00 
  21d02f:	49 8d 34 37          	lea    rsi,[r15+rsi*1]
  21d033:	4c 01 e9             	add    rcx,r13
  21d036:	48 01 d9             	add    rcx,rbx
  21d039:	48 01 f9             	add    rcx,rdi
  21d03c:	4c 01 f1             	add    rcx,r14
  21d03f:	48 c1 e1 04          	shl    rcx,0x4
  21d043:	48 01 f1             	add    rcx,rsi
  21d046:	48 f7 d8             	neg    rax
  21d049:	31 f6                	xor    esi,esi
  21d04b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
        dest[i] = s;
  21d050:	c5 fa 6f 04 31       	vmovdqu xmm0,XMMWORD PTR [rcx+rsi*1]
  21d055:	c5 fa 7f 04 32       	vmovdqu XMMWORD PTR [rdx+rsi*1],xmm0
    for (source) |s, i|
  21d05a:	48 83 c6 10          	add    rsi,0x10
  21d05e:	48 83 c0 01          	add    rax,0x1
  21d062:	75 ec                	jne    21d050 <Benchmark_reportStats+0x7450>
  21d064:	e9 00 02 00 00       	jmp    21d269 <Benchmark_reportStats+0x7669>
  21d069:	4c 8b 74 24 58       	mov    r14,QWORD PTR [rsp+0x58]
  21d06e:	e9 fb 01 00 00       	jmp    21d26e <Benchmark_reportStats+0x766e>
  21d073:	4b 8d 3c 02          	lea    rdi,[r10+r8*1]
  21d077:	48 c1 e7 04          	shl    rdi,0x4
  21d07b:	48 03 bc 24 28 01 00 	add    rdi,QWORD PTR [rsp+0x128]
  21d082:	00 
  21d083:	4c 01 f7             	add    rdi,r14
  21d086:	48 8b 8c 24 18 01 00 	mov    rcx,QWORD PTR [rsp+0x118]
  21d08d:	00 
  21d08e:	4a 8d 1c 29          	lea    rbx,[rcx+r13*1]
  21d092:	48 03 5c 24 58       	add    rbx,QWORD PTR [rsp+0x58]
  21d097:	4c 01 d3             	add    rbx,r10
  21d09a:	4c 01 c3             	add    rbx,r8
  21d09d:	4d 89 da             	mov    r10,r11
  21d0a0:	4c 29 db             	sub    rbx,r11
  21d0a3:	48 29 d3             	sub    rbx,rdx
  21d0a6:	ba 70 00 00 00       	mov    edx,0x70
  21d0ab:	31 c9                	xor    ecx,ecx
  21d0ad:	0f 1f 00             	nop    DWORD PTR [rax]
        dest[i] = s;
  21d0b0:	c5 f8 10 44 10 90    	vmovups xmm0,XMMWORD PTR [rax+rdx*1-0x70]
  21d0b6:	c5 f8 11 44 17 a0    	vmovups XMMWORD PTR [rdi+rdx*1-0x60],xmm0
  21d0bc:	c5 f8 10 44 10 a0    	vmovups xmm0,XMMWORD PTR [rax+rdx*1-0x60]
  21d0c2:	c5 f8 11 44 17 b0    	vmovups XMMWORD PTR [rdi+rdx*1-0x50],xmm0
  21d0c8:	c5 f8 10 44 10 b0    	vmovups xmm0,XMMWORD PTR [rax+rdx*1-0x50]
  21d0ce:	c5 f8 11 44 17 c0    	vmovups XMMWORD PTR [rdi+rdx*1-0x40],xmm0
  21d0d4:	c5 f8 10 44 10 c0    	vmovups xmm0,XMMWORD PTR [rax+rdx*1-0x40]
  21d0da:	c5 f8 11 44 17 d0    	vmovups XMMWORD PTR [rdi+rdx*1-0x30],xmm0
  21d0e0:	c5 f8 10 44 10 d0    	vmovups xmm0,XMMWORD PTR [rax+rdx*1-0x30]
  21d0e6:	c5 f8 11 44 17 e0    	vmovups XMMWORD PTR [rdi+rdx*1-0x20],xmm0
  21d0ec:	c5 f8 10 44 10 e0    	vmovups xmm0,XMMWORD PTR [rax+rdx*1-0x20]
  21d0f2:	c5 f8 11 44 17 f0    	vmovups XMMWORD PTR [rdi+rdx*1-0x10],xmm0
  21d0f8:	c5 f8 10 44 10 f0    	vmovups xmm0,XMMWORD PTR [rax+rdx*1-0x10]
  21d0fe:	c5 f8 11 04 17       	vmovups XMMWORD PTR [rdi+rdx*1],xmm0
  21d103:	c5 fa 6f 04 10       	vmovdqu xmm0,XMMWORD PTR [rax+rdx*1]
  21d108:	c5 fa 7f 44 17 10    	vmovdqu XMMWORD PTR [rdi+rdx*1+0x10],xmm0
    for (source) |s, i|
  21d10e:	48 83 c1 08          	add    rcx,0x8
  21d112:	48 83 ea 80          	sub    rdx,0xffffffffffffff80
  21d116:	48 39 cb             	cmp    rbx,rcx
  21d119:	75 95                	jne    21d0b0 <Benchmark_reportStats+0x74b0>
  21d11b:	4d 85 d2             	test   r10,r10
  21d11e:	4c 8b 5c 24 60       	mov    r11,QWORD PTR [rsp+0x60]
  21d123:	0f 84 3b 01 00 00    	je     21d264 <Benchmark_reportStats+0x7664>
  21d129:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
  21d12e:	48 8d 04 01          	lea    rax,[rcx+rax*1]
  21d132:	4c 01 c0             	add    rax,r8
  21d135:	48 c1 e0 04          	shl    rax,0x4
  21d139:	48 03 44 24 70       	add    rax,QWORD PTR [rsp+0x70]
  21d13e:	4c 01 f0             	add    rax,r14
  21d141:	48 c1 e1 04          	shl    rcx,0x4
  21d145:	4c 01 f9             	add    rcx,r15
  21d148:	48 01 f1             	add    rcx,rsi
  21d14b:	49 f7 da             	neg    r10
  21d14e:	31 d2                	xor    edx,edx
        dest[i] = s;
  21d150:	c5 fa 6f 04 11       	vmovdqu xmm0,XMMWORD PTR [rcx+rdx*1]
  21d155:	c5 fa 7f 04 10       	vmovdqu XMMWORD PTR [rax+rdx*1],xmm0
    for (source) |s, i|
  21d15a:	48 83 c2 10          	add    rdx,0x10
  21d15e:	49 83 c2 01          	add    r10,0x1
  21d162:	75 ec                	jne    21d150 <Benchmark_reportStats+0x7550>
  21d164:	e9 fb 00 00 00       	jmp    21d264 <Benchmark_reportStats+0x7664>
  21d169:	4a 8d 34 16          	lea    rsi,[rsi+r10*1]
  21d16d:	48 c1 e6 04          	shl    rsi,0x4
  21d171:	48 03 b4 24 28 01 00 	add    rsi,QWORD PTR [rsp+0x128]
  21d178:	00 
  21d179:	4c 01 f6             	add    rsi,r14
  21d17c:	48 8b 94 24 58 01 00 	mov    rdx,QWORD PTR [rsp+0x158]
  21d183:	00 
  21d184:	4a 8d 3c 2a          	lea    rdi,[rdx+r13*1]
  21d188:	48 03 7c 24 58       	add    rdi,QWORD PTR [rsp+0x58]
  21d18d:	4c 01 df             	add    rdi,r11
  21d190:	48 03 7c 24 28       	add    rdi,QWORD PTR [rsp+0x28]
  21d195:	4c 01 d7             	add    rdi,r10
  21d198:	48 29 c7             	sub    rdi,rax
  21d19b:	48 29 df             	sub    rdi,rbx
  21d19e:	bb 70 00 00 00       	mov    ebx,0x70
  21d1a3:	31 d2                	xor    edx,edx
  21d1a5:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21d1ac:	00 00 00 00 
        dest[i] = s;
  21d1b0:	c4 c1 78 10 44 18 90 	vmovups xmm0,XMMWORD PTR [r8+rbx*1-0x70]
  21d1b7:	c5 f8 11 44 1e a0    	vmovups XMMWORD PTR [rsi+rbx*1-0x60],xmm0
  21d1bd:	c4 c1 78 10 44 18 a0 	vmovups xmm0,XMMWORD PTR [r8+rbx*1-0x60]
  21d1c4:	c5 f8 11 44 1e b0    	vmovups XMMWORD PTR [rsi+rbx*1-0x50],xmm0
  21d1ca:	c4 c1 78 10 44 18 b0 	vmovups xmm0,XMMWORD PTR [r8+rbx*1-0x50]
  21d1d1:	c5 f8 11 44 1e c0    	vmovups XMMWORD PTR [rsi+rbx*1-0x40],xmm0
  21d1d7:	c4 c1 78 10 44 18 c0 	vmovups xmm0,XMMWORD PTR [r8+rbx*1-0x40]
  21d1de:	c5 f8 11 44 1e d0    	vmovups XMMWORD PTR [rsi+rbx*1-0x30],xmm0
  21d1e4:	c4 c1 78 10 44 18 d0 	vmovups xmm0,XMMWORD PTR [r8+rbx*1-0x30]
  21d1eb:	c5 f8 11 44 1e e0    	vmovups XMMWORD PTR [rsi+rbx*1-0x20],xmm0
  21d1f1:	c4 c1 78 10 44 18 e0 	vmovups xmm0,XMMWORD PTR [r8+rbx*1-0x20]
  21d1f8:	c5 f8 11 44 1e f0    	vmovups XMMWORD PTR [rsi+rbx*1-0x10],xmm0
  21d1fe:	c4 c1 78 10 44 18 f0 	vmovups xmm0,XMMWORD PTR [r8+rbx*1-0x10]
  21d205:	c5 f8 11 04 1e       	vmovups XMMWORD PTR [rsi+rbx*1],xmm0
  21d20a:	c4 c1 7a 6f 04 18    	vmovdqu xmm0,XMMWORD PTR [r8+rbx*1]
  21d210:	c5 fa 7f 44 1e 10    	vmovdqu XMMWORD PTR [rsi+rbx*1+0x10],xmm0
    for (source) |s, i|
  21d216:	48 83 c2 08          	add    rdx,0x8
  21d21a:	48 83 eb 80          	sub    rbx,0xffffffffffffff80
  21d21e:	48 39 d7             	cmp    rdi,rdx
  21d221:	75 8d                	jne    21d1b0 <Benchmark_reportStats+0x75b0>
  21d223:	48 85 c0             	test   rax,rax
  21d226:	74 3c                	je     21d264 <Benchmark_reportStats+0x7664>
  21d228:	48 8b 74 24 28       	mov    rsi,QWORD PTR [rsp+0x28]
  21d22d:	48 8d 34 32          	lea    rsi,[rdx+rsi*1]
  21d231:	4c 01 d6             	add    rsi,r10
  21d234:	48 c1 e6 04          	shl    rsi,0x4
  21d238:	48 03 74 24 70       	add    rsi,QWORD PTR [rsp+0x70]
  21d23d:	4c 01 f6             	add    rsi,r14
  21d240:	48 c1 e2 04          	shl    rdx,0x4
  21d244:	4c 01 fa             	add    rdx,r15
  21d247:	48 01 ca             	add    rdx,rcx
  21d24a:	48 f7 d8             	neg    rax
  21d24d:	31 c9                	xor    ecx,ecx
  21d24f:	90                   	nop
        dest[i] = s;
  21d250:	c5 fa 6f 04 0a       	vmovdqu xmm0,XMMWORD PTR [rdx+rcx*1]
  21d255:	c5 fa 7f 04 0e       	vmovdqu XMMWORD PTR [rsi+rcx*1],xmm0
    for (source) |s, i|
  21d25a:	48 83 c1 10          	add    rcx,0x10
  21d25e:	48 83 c0 01          	add    rax,0x1
  21d262:	75 ec                	jne    21d250 <Benchmark_reportStats+0x7650>
  21d264:	4c 8b 74 24 58       	mov    r14,QWORD PTR [rsp+0x58]
  21d269:	48 8b 74 24 78       	mov    rsi,QWORD PTR [rsp+0x78]
        return self.end - self.start;
  21d26e:	4c 89 cf             	mov    rdi,r9
  21d271:	48 2b 7c 24 18       	sub    rdi,QWORD PTR [rsp+0x18]
                    const B3 = Range.init(A1.length(), A1.length() + A2.length());
  21d276:	4c 8d 04 3e          	lea    r8,[rsi+rdi*1]
                    if (lessThan(cache[B3.end - 1], cache[A3.start])) {
  21d27a:	4c 89 c0             	mov    rax,r8
  21d27d:	48 c1 e0 04          	shl    rax,0x4
  21d281:	48 8b 84 04 18 02 00 	mov    rax,QWORD PTR [rsp+rax*1+0x218]
  21d288:	00 
  21d289:	48 3b 84 24 28 02 00 	cmp    rax,QWORD PTR [rsp+0x228]
  21d290:	00 
  21d291:	73 4d                	jae    21d2e0 <Benchmark_reportStats+0x76e0>
                        mem.copy(T, items[A1.start + A2.length() ..], cache[A3.start..A3.end]);
  21d293:	4e 8d 04 2f          	lea    r8,[rdi+r13*1]
  21d297:	48 8b 44 24 48       	mov    rax,QWORD PTR [rsp+0x48]
  21d29c:	48 89 c1             	mov    rcx,rax
  21d29f:	4c 29 c1             	sub    rcx,r8
    assert(dest.len >= source.len);
  21d2a2:	48 39 f1             	cmp    rcx,rsi
  21d2a5:	0f 82 c1 14 00 00    	jb     21e76c <Benchmark_reportStats+0x8b6c>
    for (source) |s, i|
  21d2ab:	48 85 f6             	test   rsi,rsi
  21d2ae:	0f 84 99 01 00 00    	je     21d44d <Benchmark_reportStats+0x784d>
  21d2b4:	48 8d 46 ff          	lea    rax,[rsi-0x1]
  21d2b8:	89 f1                	mov    ecx,esi
  21d2ba:	83 e1 07             	and    ecx,0x7
  21d2bd:	48 83 f8 07          	cmp    rax,0x7
  21d2c1:	0f 83 d9 01 00 00    	jae    21d4a0 <Benchmark_reportStats+0x78a0>
  21d2c7:	49 89 f1             	mov    r9,rsi
  21d2ca:	31 f6                	xor    esi,esi
  21d2cc:	48 85 c9             	test   rcx,rcx
  21d2cf:	0f 85 88 02 00 00    	jne    21d55d <Benchmark_reportStats+0x795d>
  21d2d5:	e9 af 02 00 00       	jmp    21d589 <Benchmark_reportStats+0x7989>
  21d2da:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
                    } else if (lessThan(cache[B3.start], cache[A3.end - 1])) {
  21d2e0:	48 89 f1             	mov    rcx,rsi
  21d2e3:	48 c1 e1 04          	shl    rcx,0x4
  21d2e7:	48 8b 84 0c 28 02 00 	mov    rax,QWORD PTR [rsp+rcx*1+0x228]
  21d2ee:	00 
  21d2ef:	48 8b 5c 24 48       	mov    rbx,QWORD PTR [rsp+0x48]
  21d2f4:	48 89 da             	mov    rdx,rbx
  21d2f7:	4c 29 ea             	sub    rdx,r13
  21d2fa:	48 3b 84 0c 18 02 00 	cmp    rax,QWORD PTR [rsp+rcx*1+0x218]
  21d301:	00 
  21d302:	0f 83 08 01 00 00    	jae    21d410 <Benchmark_reportStats+0x7810>
  21d308:	48 89 54 24 18       	mov    QWORD PTR [rsp+0x18],rdx
  21d30d:	49 89 f2             	mov    r10,rsi
  21d310:	48 89 f2             	mov    rdx,rsi
  21d313:	31 f6                	xor    esi,esi
  21d315:	31 c9                	xor    ecx,ecx
  21d317:	eb 16                	jmp    21d32f <Benchmark_reportStats+0x772f>
  21d319:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  21d320:	48 89 d0             	mov    rax,rdx
  21d323:	48 c1 e0 04          	shl    rax,0x4
  21d327:	48 8b 84 04 28 02 00 	mov    rax,QWORD PTR [rsp+rax*1+0x228]
  21d32e:	00 
        if (!lessThan(from[B_index], from[A_index])) {
  21d32f:	48 89 d3             	mov    rbx,rdx
  21d332:	48 c1 e3 04          	shl    rbx,0x4
  21d336:	4c 8d 0c 1c          	lea    r9,[rsp+rbx*1]
  21d33a:	49 81 c1 28 02 00 00 	add    r9,0x228
  21d341:	48 89 f7             	mov    rdi,rsi
  21d344:	48 c1 e7 04          	shl    rdi,0x4
  21d348:	4c 8d 2c 3c          	lea    r13,[rsp+rdi*1]
  21d34c:	49 81 c5 28 02 00 00 	add    r13,0x228
  21d353:	49 89 cb             	mov    r11,rcx
  21d356:	49 c1 e3 04          	shl    r11,0x4
  21d35a:	4f 8d 34 1c          	lea    r14,[r12+r11*1]
  21d35e:	48 3b 84 3c 28 02 00 	cmp    rax,QWORD PTR [rsp+rdi*1+0x228]
  21d365:	00 
  21d366:	73 28                	jae    21d390 <Benchmark_reportStats+0x7790>
            into[insert_index] = from[B_index];
  21d368:	c4 c1 7a 6f 01       	vmovdqu xmm0,XMMWORD PTR [r9]
  21d36d:	c4 c1 7a 7f 06       	vmovdqu XMMWORD PTR [r14],xmm0
            B_index += 1;
  21d372:	48 83 c2 01          	add    rdx,0x1
            insert_index += 1;
  21d376:	48 83 c1 01          	add    rcx,0x1
            if (B_index == B_last) {
  21d37a:	4c 39 c2             	cmp    rdx,r8
  21d37d:	75 a1                	jne    21d320 <Benchmark_reportStats+0x7720>
  21d37f:	e9 16 03 00 00       	jmp    21d69a <Benchmark_reportStats+0x7a9a>
  21d384:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21d38b:	00 00 00 00 00 
            into[insert_index] = from[A_index];
  21d390:	c4 c1 7a 6f 45 00    	vmovdqu xmm0,XMMWORD PTR [r13+0x0]
  21d396:	c4 c1 7a 7f 06       	vmovdqu XMMWORD PTR [r14],xmm0
            A_index += 1;
  21d39b:	48 83 c6 01          	add    rsi,0x1
            insert_index += 1;
  21d39f:	48 83 c1 01          	add    rcx,0x1
            if (A_index == A_last) {
  21d3a3:	4c 39 d6             	cmp    rsi,r10
  21d3a6:	0f 85 74 ff ff ff    	jne    21d320 <Benchmark_reportStats+0x7720>
  21d3ac:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
                mem.copy(T, into[insert_index..], from[B_index..B_last]);
  21d3b1:	48 29 c8             	sub    rax,rcx
  21d3b4:	49 29 d0             	sub    r8,rdx
    assert(dest.len >= source.len);
  21d3b7:	4c 39 c0             	cmp    rax,r8
  21d3ba:	0f 82 ac 13 00 00    	jb     21e76c <Benchmark_reportStats+0x8b6c>
    for (source) |s, i|
  21d3c0:	4d 85 c0             	test   r8,r8
  21d3c3:	0f 84 37 07 00 00    	je     21db00 <Benchmark_reportStats+0x7f00>
  21d3c9:	48 8b 84 24 38 01 00 	mov    rax,QWORD PTR [rsp+0x138]
  21d3d0:	00 
  21d3d1:	4a 8d 04 10          	lea    rax,[rax+r10*1]
  21d3d5:	48 8b 74 24 58       	mov    rsi,QWORD PTR [rsp+0x58]
  21d3da:	48 01 f0             	add    rax,rsi
  21d3dd:	48 8b 4c 24 60       	mov    rcx,QWORD PTR [rsp+0x60]
  21d3e2:	48 01 c8             	add    rax,rcx
  21d3e5:	48 29 d0             	sub    rax,rdx
  21d3e8:	41 83 e0 07          	and    r8d,0x7
  21d3ec:	48 83 f8 07          	cmp    rax,0x7
  21d3f0:	0f 83 33 05 00 00    	jae    21d929 <Benchmark_reportStats+0x7d29>
  21d3f6:	31 c0                	xor    eax,eax
  21d3f8:	4d 85 c0             	test   r8,r8
  21d3fb:	48 8b 4c 24 10       	mov    rcx,QWORD PTR [rsp+0x10]
  21d400:	0f 85 d3 05 00 00    	jne    21d9d9 <Benchmark_reportStats+0x7dd9>
  21d406:	e9 f5 06 00 00       	jmp    21db00 <Benchmark_reportStats+0x7f00>
  21d40b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
    assert(dest.len >= source.len);
  21d410:	48 39 f2             	cmp    rdx,rsi
  21d413:	0f 82 53 13 00 00    	jb     21e76c <Benchmark_reportStats+0x8b6c>
    for (source) |s, i|
  21d419:	48 85 f6             	test   rsi,rsi
  21d41c:	4c 8b 4c 24 28       	mov    r9,QWORD PTR [rsp+0x28]
  21d421:	0f 84 9f 03 00 00    	je     21d7c6 <Benchmark_reportStats+0x7bc6>
  21d427:	48 8d 46 ff          	lea    rax,[rsi-0x1]
  21d42b:	89 f2                	mov    edx,esi
  21d42d:	83 e2 07             	and    edx,0x7
  21d430:	48 83 f8 07          	cmp    rax,0x7
  21d434:	0f 83 ab 02 00 00    	jae    21d6e5 <Benchmark_reportStats+0x7ae5>
  21d43a:	49 89 f0             	mov    r8,rsi
  21d43d:	31 f6                	xor    esi,esi
  21d43f:	48 85 d2             	test   rdx,rdx
  21d442:	0f 85 4d 03 00 00    	jne    21d795 <Benchmark_reportStats+0x7b95>
  21d448:	e9 6c 03 00 00       	jmp    21d7b9 <Benchmark_reportStats+0x7bb9>
  21d44d:	49 89 f1             	mov    r9,rsi
                        mem.copy(T, items[A1.start..], cache[B3.start..B3.end]);
  21d450:	4c 29 e8             	sub    rax,r13
    assert(dest.len >= source.len);
  21d453:	48 39 f8             	cmp    rax,rdi
  21d456:	0f 82 10 13 00 00    	jb     21e76c <Benchmark_reportStats+0x8b6c>
    for (source) |s, i|
  21d45c:	48 85 ff             	test   rdi,rdi
  21d45f:	0f 84 9b 06 00 00    	je     21db00 <Benchmark_reportStats+0x7f00>
  21d465:	48 8b 84 24 38 01 00 	mov    rax,QWORD PTR [rsp+0x138]
  21d46c:	00 
  21d46d:	48 8b 4c 24 58       	mov    rcx,QWORD PTR [rsp+0x58]
  21d472:	48 8d 04 08          	lea    rax,[rax+rcx*1]
  21d476:	48 8b 74 24 60       	mov    rsi,QWORD PTR [rsp+0x60]
  21d47b:	48 01 f0             	add    rax,rsi
  21d47e:	83 e7 07             	and    edi,0x7
  21d481:	48 83 f8 07          	cmp    rax,0x7
  21d485:	0f 83 19 01 00 00    	jae    21d5a4 <Benchmark_reportStats+0x79a4>
  21d48b:	31 c9                	xor    ecx,ecx
  21d48d:	48 85 ff             	test   rdi,rdi
  21d490:	48 8b 44 24 10       	mov    rax,QWORD PTR [rsp+0x10]
  21d495:	0f 85 be 01 00 00    	jne    21d659 <Benchmark_reportStats+0x7a59>
  21d49b:	e9 60 06 00 00       	jmp    21db00 <Benchmark_reportStats+0x7f00>
  21d4a0:	49 89 f1             	mov    r9,rsi
  21d4a3:	48 89 f0             	mov    rax,rsi
  21d4a6:	48 29 c8             	sub    rax,rcx
  21d4a9:	48 8b 54 24 68       	mov    rdx,QWORD PTR [rsp+0x68]
  21d4ae:	48 c1 e2 04          	shl    rdx,0x4
  21d4b2:	4c 01 fa             	add    rdx,r15
  21d4b5:	4b 8d 1c 2e          	lea    rbx,[r14+r13*1]
  21d4b9:	4c 01 db             	add    rbx,r11
  21d4bc:	48 c1 e3 04          	shl    rbx,0x4
  21d4c0:	48 01 d3             	add    rbx,rdx
  21d4c3:	ba 70 00 00 00       	mov    edx,0x70
  21d4c8:	31 f6                	xor    esi,esi
  21d4ca:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
        dest[i] = s;
  21d4d0:	c5 f8 10 84 14 b8 01 	vmovups xmm0,XMMWORD PTR [rsp+rdx*1+0x1b8]
  21d4d7:	00 00 
  21d4d9:	c5 f8 11 44 13 90    	vmovups XMMWORD PTR [rbx+rdx*1-0x70],xmm0
  21d4df:	c5 f8 10 84 14 c8 01 	vmovups xmm0,XMMWORD PTR [rsp+rdx*1+0x1c8]
  21d4e6:	00 00 
  21d4e8:	c5 f8 11 44 13 a0    	vmovups XMMWORD PTR [rbx+rdx*1-0x60],xmm0
  21d4ee:	c5 f8 10 84 14 d8 01 	vmovups xmm0,XMMWORD PTR [rsp+rdx*1+0x1d8]
  21d4f5:	00 00 
  21d4f7:	c5 f8 11 44 13 b0    	vmovups XMMWORD PTR [rbx+rdx*1-0x50],xmm0
  21d4fd:	c5 f8 10 84 14 e8 01 	vmovups xmm0,XMMWORD PTR [rsp+rdx*1+0x1e8]
  21d504:	00 00 
  21d506:	c5 f8 11 44 13 c0    	vmovups XMMWORD PTR [rbx+rdx*1-0x40],xmm0
  21d50c:	c5 f8 10 84 14 f8 01 	vmovups xmm0,XMMWORD PTR [rsp+rdx*1+0x1f8]
  21d513:	00 00 
  21d515:	c5 f8 11 44 13 d0    	vmovups XMMWORD PTR [rbx+rdx*1-0x30],xmm0
  21d51b:	c5 f8 10 84 14 08 02 	vmovups xmm0,XMMWORD PTR [rsp+rdx*1+0x208]
  21d522:	00 00 
  21d524:	c5 f8 11 44 13 e0    	vmovups XMMWORD PTR [rbx+rdx*1-0x20],xmm0
  21d52a:	c5 f8 10 84 14 18 02 	vmovups xmm0,XMMWORD PTR [rsp+rdx*1+0x218]
  21d531:	00 00 
  21d533:	c5 f8 11 44 13 f0    	vmovups XMMWORD PTR [rbx+rdx*1-0x10],xmm0
  21d539:	c5 fa 6f 84 14 28 02 	vmovdqu xmm0,XMMWORD PTR [rsp+rdx*1+0x228]
  21d540:	00 00 
  21d542:	c5 fa 7f 04 13       	vmovdqu XMMWORD PTR [rbx+rdx*1],xmm0
    for (source) |s, i|
  21d547:	48 83 c6 08          	add    rsi,0x8
  21d54b:	48 83 ea 80          	sub    rdx,0xffffffffffffff80
  21d54f:	48 39 f0             	cmp    rax,rsi
  21d552:	0f 85 78 ff ff ff    	jne    21d4d0 <Benchmark_reportStats+0x78d0>
  21d558:	48 85 c9             	test   rcx,rcx
  21d55b:	74 2c                	je     21d589 <Benchmark_reportStats+0x7989>
  21d55d:	49 c1 e0 04          	shl    r8,0x4
  21d561:	4d 01 c7             	add    r15,r8
  21d564:	48 c1 e6 04          	shl    rsi,0x4
  21d568:	48 f7 d9             	neg    rcx
  21d56b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
        dest[i] = s;
  21d570:	c5 fa 6f 84 34 28 02 	vmovdqu xmm0,XMMWORD PTR [rsp+rsi*1+0x228]
  21d577:	00 00 
  21d579:	c4 c1 7a 7f 04 37    	vmovdqu XMMWORD PTR [r15+rsi*1],xmm0
    for (source) |s, i|
  21d57f:	48 83 c6 10          	add    rsi,0x10
  21d583:	48 83 c1 01          	add    rcx,0x1
  21d587:	75 e7                	jne    21d570 <Benchmark_reportStats+0x7970>
  21d589:	4c 8b 7c 24 40       	mov    r15,QWORD PTR [rsp+0x40]
  21d58e:	48 8b 44 24 48       	mov    rax,QWORD PTR [rsp+0x48]
  21d593:	4c 29 e8             	sub    rax,r13
    assert(dest.len >= source.len);
  21d596:	48 39 f8             	cmp    rax,rdi
  21d599:	0f 83 bd fe ff ff    	jae    21d45c <Benchmark_reportStats+0x785c>
  21d59f:	e9 c8 11 00 00       	jmp    21e76c <Benchmark_reportStats+0x8b6c>
  21d5a4:	48 8b 9c 24 08 01 00 	mov    rbx,QWORD PTR [rsp+0x108]
  21d5ab:	00 
  21d5ac:	4c 01 fb             	add    rbx,r15
    for (source) |s, i|
  21d5af:	4c 89 c8             	mov    rax,r9
  21d5b2:	48 c1 e0 04          	shl    rax,0x4
  21d5b6:	48 8d 14 04          	lea    rdx,[rsp+rax*1]
  21d5ba:	48 81 c2 28 02 00 00 	add    rdx,0x228
  21d5c1:	48 03 74 24 68       	add    rsi,QWORD PTR [rsp+0x68]
  21d5c6:	48 01 ce             	add    rsi,rcx
  21d5c9:	48 29 fe             	sub    rsi,rdi
  21d5cc:	b8 70 00 00 00       	mov    eax,0x70
  21d5d1:	31 c9                	xor    ecx,ecx
  21d5d3:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21d5da:	84 00 00 00 00 00 
        dest[i] = s;
  21d5e0:	c5 f8 10 44 02 90    	vmovups xmm0,XMMWORD PTR [rdx+rax*1-0x70]
  21d5e6:	c5 f8 11 44 03 90    	vmovups XMMWORD PTR [rbx+rax*1-0x70],xmm0
  21d5ec:	c5 f8 10 44 02 a0    	vmovups xmm0,XMMWORD PTR [rdx+rax*1-0x60]
  21d5f2:	c5 f8 11 44 03 a0    	vmovups XMMWORD PTR [rbx+rax*1-0x60],xmm0
  21d5f8:	c5 f8 10 44 02 b0    	vmovups xmm0,XMMWORD PTR [rdx+rax*1-0x50]
  21d5fe:	c5 f8 11 44 03 b0    	vmovups XMMWORD PTR [rbx+rax*1-0x50],xmm0
  21d604:	c5 f8 10 44 02 c0    	vmovups xmm0,XMMWORD PTR [rdx+rax*1-0x40]
  21d60a:	c5 f8 11 44 03 c0    	vmovups XMMWORD PTR [rbx+rax*1-0x40],xmm0
  21d610:	c5 f8 10 44 02 d0    	vmovups xmm0,XMMWORD PTR [rdx+rax*1-0x30]
  21d616:	c5 f8 11 44 03 d0    	vmovups XMMWORD PTR [rbx+rax*1-0x30],xmm0
  21d61c:	c5 f8 10 44 02 e0    	vmovups xmm0,XMMWORD PTR [rdx+rax*1-0x20]
  21d622:	c5 f8 11 44 03 e0    	vmovups XMMWORD PTR [rbx+rax*1-0x20],xmm0
  21d628:	c5 f8 10 44 02 f0    	vmovups xmm0,XMMWORD PTR [rdx+rax*1-0x10]
  21d62e:	c5 f8 11 44 03 f0    	vmovups XMMWORD PTR [rbx+rax*1-0x10],xmm0
  21d634:	c5 fa 6f 04 02       	vmovdqu xmm0,XMMWORD PTR [rdx+rax*1]
  21d639:	c5 fa 7f 04 03       	vmovdqu XMMWORD PTR [rbx+rax*1],xmm0
    for (source) |s, i|
  21d63e:	48 83 c1 08          	add    rcx,0x8
  21d642:	48 83 e8 80          	sub    rax,0xffffffffffffff80
  21d646:	48 39 ce             	cmp    rsi,rcx
  21d649:	75 95                	jne    21d5e0 <Benchmark_reportStats+0x79e0>
  21d64b:	48 85 ff             	test   rdi,rdi
  21d64e:	48 8b 44 24 10       	mov    rax,QWORD PTR [rsp+0x10]
  21d653:	0f 84 a7 04 00 00    	je     21db00 <Benchmark_reportStats+0x7f00>
  21d659:	48 01 c8             	add    rax,rcx
  21d65c:	48 c1 e0 04          	shl    rax,0x4
  21d660:	49 01 c7             	add    r15,rax
  21d663:	49 01 c9             	add    r9,rcx
  21d666:	49 c1 e1 04          	shl    r9,0x4
  21d66a:	4a 8d 04 0c          	lea    rax,[rsp+r9*1]
  21d66e:	48 05 28 02 00 00    	add    rax,0x228
  21d674:	48 f7 df             	neg    rdi
  21d677:	31 c9                	xor    ecx,ecx
  21d679:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
        dest[i] = s;
  21d680:	c5 fa 6f 04 08       	vmovdqu xmm0,XMMWORD PTR [rax+rcx*1]
  21d685:	c4 c1 7a 7f 04 0f    	vmovdqu XMMWORD PTR [r15+rcx*1],xmm0
    for (source) |s, i|
  21d68b:	48 83 c1 10          	add    rcx,0x10
  21d68f:	48 83 c7 01          	add    rdi,0x1
  21d693:	75 eb                	jne    21d680 <Benchmark_reportStats+0x7a80>
  21d695:	e9 66 04 00 00       	jmp    21db00 <Benchmark_reportStats+0x7f00>
  21d69a:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
                mem.copy(T, into[insert_index..], from[A_index..A_last]);
  21d69f:	48 29 c8             	sub    rax,rcx
  21d6a2:	4c 89 d1             	mov    rcx,r10
  21d6a5:	48 29 f1             	sub    rcx,rsi
    assert(dest.len >= source.len);
  21d6a8:	48 39 c8             	cmp    rax,rcx
  21d6ab:	0f 82 bb 10 00 00    	jb     21e76c <Benchmark_reportStats+0x8b6c>
    for (source) |s, i|
  21d6b1:	48 85 c9             	test   rcx,rcx
  21d6b4:	0f 84 46 04 00 00    	je     21db00 <Benchmark_reportStats+0x7f00>
  21d6ba:	49 83 c2 ff          	add    r10,0xffffffffffffffff
  21d6be:	49 29 f2             	sub    r10,rsi
  21d6c1:	89 ca                	mov    edx,ecx
  21d6c3:	83 e2 07             	and    edx,0x7
  21d6c6:	49 83 fa 07          	cmp    r10,0x7
  21d6ca:	0f 83 49 03 00 00    	jae    21da19 <Benchmark_reportStats+0x7e19>
  21d6d0:	31 f6                	xor    esi,esi
  21d6d2:	48 85 d2             	test   rdx,rdx
  21d6d5:	48 8b 44 24 10       	mov    rax,QWORD PTR [rsp+0x10]
  21d6da:	0f 85 d6 03 00 00    	jne    21dab6 <Benchmark_reportStats+0x7eb6>
  21d6e0:	e9 1b 04 00 00       	jmp    21db00 <Benchmark_reportStats+0x7f00>
  21d6e5:	49 89 f0             	mov    r8,rsi
  21d6e8:	48 89 f0             	mov    rax,rsi
  21d6eb:	48 29 d0             	sub    rax,rdx
  21d6ee:	bb 70 00 00 00       	mov    ebx,0x70
  21d6f3:	31 f6                	xor    esi,esi
  21d6f5:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21d6fc:	00 00 00 00 
        dest[i] = s;
  21d700:	c5 f8 10 84 1c b8 01 	vmovups xmm0,XMMWORD PTR [rsp+rbx*1+0x1b8]
  21d707:	00 00 
  21d709:	c4 c1 78 11 44 1c 90 	vmovups XMMWORD PTR [r12+rbx*1-0x70],xmm0
  21d710:	c5 f8 10 84 1c c8 01 	vmovups xmm0,XMMWORD PTR [rsp+rbx*1+0x1c8]
  21d717:	00 00 
  21d719:	c4 c1 78 11 44 1c a0 	vmovups XMMWORD PTR [r12+rbx*1-0x60],xmm0
  21d720:	c5 f8 10 84 1c d8 01 	vmovups xmm0,XMMWORD PTR [rsp+rbx*1+0x1d8]
  21d727:	00 00 
  21d729:	c4 c1 78 11 44 1c b0 	vmovups XMMWORD PTR [r12+rbx*1-0x50],xmm0
  21d730:	c5 f8 10 84 1c e8 01 	vmovups xmm0,XMMWORD PTR [rsp+rbx*1+0x1e8]
  21d737:	00 00 
  21d739:	c4 c1 78 11 44 1c c0 	vmovups XMMWORD PTR [r12+rbx*1-0x40],xmm0
  21d740:	c5 f8 10 84 1c f8 01 	vmovups xmm0,XMMWORD PTR [rsp+rbx*1+0x1f8]
  21d747:	00 00 
  21d749:	c4 c1 78 11 44 1c d0 	vmovups XMMWORD PTR [r12+rbx*1-0x30],xmm0
  21d750:	c5 f8 10 84 1c 08 02 	vmovups xmm0,XMMWORD PTR [rsp+rbx*1+0x208]
  21d757:	00 00 
  21d759:	c4 c1 78 11 44 1c e0 	vmovups XMMWORD PTR [r12+rbx*1-0x20],xmm0
  21d760:	c5 f8 10 84 1c 18 02 	vmovups xmm0,XMMWORD PTR [rsp+rbx*1+0x218]
  21d767:	00 00 
  21d769:	c4 c1 78 11 44 1c f0 	vmovups XMMWORD PTR [r12+rbx*1-0x10],xmm0
  21d770:	c5 fa 6f 84 1c 28 02 	vmovdqu xmm0,XMMWORD PTR [rsp+rbx*1+0x228]
  21d777:	00 00 
  21d779:	c4 c1 7a 7f 04 1c    	vmovdqu XMMWORD PTR [r12+rbx*1],xmm0
    for (source) |s, i|
  21d77f:	48 83 c6 08          	add    rsi,0x8
  21d783:	48 83 eb 80          	sub    rbx,0xffffffffffffff80
  21d787:	48 39 f0             	cmp    rax,rsi
  21d78a:	0f 85 70 ff ff ff    	jne    21d700 <Benchmark_reportStats+0x7b00>
  21d790:	48 85 d2             	test   rdx,rdx
  21d793:	74 24                	je     21d7b9 <Benchmark_reportStats+0x7bb9>
  21d795:	48 c1 e6 04          	shl    rsi,0x4
  21d799:	48 f7 da             	neg    rdx
  21d79c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
        dest[i] = s;
  21d7a0:	c5 fa 6f 84 34 28 02 	vmovdqu xmm0,XMMWORD PTR [rsp+rsi*1+0x228]
  21d7a7:	00 00 
  21d7a9:	c4 c1 7a 7f 04 34    	vmovdqu XMMWORD PTR [r12+rsi*1],xmm0
    for (source) |s, i|
  21d7af:	48 83 c6 10          	add    rsi,0x10
  21d7b3:	48 83 c2 01          	add    rdx,0x1
  21d7b7:	75 e7                	jne    21d7a0 <Benchmark_reportStats+0x7ba0>
                        mem.copy(T, items[A1.start + A1.length() ..], cache[B3.start..B3.end]);
  21d7b9:	4c 8b 7c 24 40       	mov    r15,QWORD PTR [rsp+0x40]
  21d7be:	48 8b 5c 24 48       	mov    rbx,QWORD PTR [rsp+0x48]
  21d7c3:	4c 89 c6             	mov    rsi,r8
  21d7c6:	49 89 f3             	mov    r11,rsi
  21d7c9:	48 2b 5c 24 18       	sub    rbx,QWORD PTR [rsp+0x18]
    assert(dest.len >= source.len);
  21d7ce:	48 39 fb             	cmp    rbx,rdi
  21d7d1:	0f 82 95 0f 00 00    	jb     21e76c <Benchmark_reportStats+0x8b6c>
    for (source) |s, i|
  21d7d7:	48 85 ff             	test   rdi,rdi
  21d7da:	0f 84 20 03 00 00    	je     21db00 <Benchmark_reportStats+0x7f00>
  21d7e0:	48 8b 84 24 38 01 00 	mov    rax,QWORD PTR [rsp+0x138]
  21d7e7:	00 
  21d7e8:	4c 8b 44 24 58       	mov    r8,QWORD PTR [rsp+0x58]
  21d7ed:	4a 8d 04 00          	lea    rax,[rax+r8*1]
  21d7f1:	48 8b 5c 24 60       	mov    rbx,QWORD PTR [rsp+0x60]
  21d7f6:	48 01 d8             	add    rax,rbx
  21d7f9:	83 e7 07             	and    edi,0x7
  21d7fc:	48 83 f8 07          	cmp    rax,0x7
  21d800:	73 15                	jae    21d817 <Benchmark_reportStats+0x7c17>
  21d802:	31 c9                	xor    ecx,ecx
  21d804:	48 85 ff             	test   rdi,rdi
  21d807:	48 8b 54 24 10       	mov    rdx,QWORD PTR [rsp+0x10]
  21d80c:	0f 85 c7 00 00 00    	jne    21d8d9 <Benchmark_reportStats+0x7cd9>
  21d812:	e9 e9 02 00 00       	jmp    21db00 <Benchmark_reportStats+0x7f00>
  21d817:	48 8d 14 0c          	lea    rdx,[rsp+rcx*1]
  21d81b:	48 81 c2 28 02 00 00 	add    rdx,0x228
  21d822:	48 8b 4c 24 68       	mov    rcx,QWORD PTR [rsp+0x68]
  21d827:	48 89 c8             	mov    rax,rcx
  21d82a:	48 c1 e0 04          	shl    rax,0x4
  21d82e:	4c 01 f8             	add    rax,r15
  21d831:	48 8b 74 24 10       	mov    rsi,QWORD PTR [rsp+0x10]
  21d836:	4a 8d 34 0e          	lea    rsi,[rsi+r9*1]
  21d83a:	48 03 74 24 30       	add    rsi,QWORD PTR [rsp+0x30]
  21d83f:	48 c1 e6 04          	shl    rsi,0x4
  21d843:	48 01 c6             	add    rsi,rax
  21d846:	48 01 cb             	add    rbx,rcx
  21d849:	4c 01 c3             	add    rbx,r8
  21d84c:	48 29 fb             	sub    rbx,rdi
  21d84f:	b8 70 00 00 00       	mov    eax,0x70
  21d854:	31 c9                	xor    ecx,ecx
  21d856:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  21d85d:	00 00 00 
        dest[i] = s;
  21d860:	c5 f8 10 44 02 90    	vmovups xmm0,XMMWORD PTR [rdx+rax*1-0x70]
  21d866:	c5 f8 11 44 06 90    	vmovups XMMWORD PTR [rsi+rax*1-0x70],xmm0
  21d86c:	c5 f8 10 44 02 a0    	vmovups xmm0,XMMWORD PTR [rdx+rax*1-0x60]
  21d872:	c5 f8 11 44 06 a0    	vmovups XMMWORD PTR [rsi+rax*1-0x60],xmm0
  21d878:	c5 f8 10 44 02 b0    	vmovups xmm0,XMMWORD PTR [rdx+rax*1-0x50]
  21d87e:	c5 f8 11 44 06 b0    	vmovups XMMWORD PTR [rsi+rax*1-0x50],xmm0
  21d884:	c5 f8 10 44 02 c0    	vmovups xmm0,XMMWORD PTR [rdx+rax*1-0x40]
  21d88a:	c5 f8 11 44 06 c0    	vmovups XMMWORD PTR [rsi+rax*1-0x40],xmm0
  21d890:	c5 f8 10 44 02 d0    	vmovups xmm0,XMMWORD PTR [rdx+rax*1-0x30]
  21d896:	c5 f8 11 44 06 d0    	vmovups XMMWORD PTR [rsi+rax*1-0x30],xmm0
  21d89c:	c5 f8 10 44 02 e0    	vmovups xmm0,XMMWORD PTR [rdx+rax*1-0x20]
  21d8a2:	c5 f8 11 44 06 e0    	vmovups XMMWORD PTR [rsi+rax*1-0x20],xmm0
  21d8a8:	c5 f8 10 44 02 f0    	vmovups xmm0,XMMWORD PTR [rdx+rax*1-0x10]
  21d8ae:	c5 f8 11 44 06 f0    	vmovups XMMWORD PTR [rsi+rax*1-0x10],xmm0
  21d8b4:	c5 fa 6f 04 02       	vmovdqu xmm0,XMMWORD PTR [rdx+rax*1]
  21d8b9:	c5 fa 7f 04 06       	vmovdqu XMMWORD PTR [rsi+rax*1],xmm0
    for (source) |s, i|
  21d8be:	48 83 c1 08          	add    rcx,0x8
  21d8c2:	48 83 e8 80          	sub    rax,0xffffffffffffff80
  21d8c6:	48 39 cb             	cmp    rbx,rcx
  21d8c9:	75 95                	jne    21d860 <Benchmark_reportStats+0x7c60>
  21d8cb:	48 85 ff             	test   rdi,rdi
  21d8ce:	48 8b 54 24 10       	mov    rdx,QWORD PTR [rsp+0x10]
  21d8d3:	0f 84 27 02 00 00    	je     21db00 <Benchmark_reportStats+0x7f00>
  21d8d9:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  21d8de:	48 c1 e0 04          	shl    rax,0x4
  21d8e2:	49 01 c7             	add    r15,rax
  21d8e5:	48 01 ca             	add    rdx,rcx
  21d8e8:	4c 01 ca             	add    rdx,r9
  21d8eb:	48 03 54 24 30       	add    rdx,QWORD PTR [rsp+0x30]
  21d8f0:	48 c1 e2 04          	shl    rdx,0x4
  21d8f4:	4c 01 fa             	add    rdx,r15
  21d8f7:	49 01 cb             	add    r11,rcx
  21d8fa:	49 c1 e3 04          	shl    r11,0x4
  21d8fe:	4a 8d 04 1c          	lea    rax,[rsp+r11*1]
  21d902:	48 05 28 02 00 00    	add    rax,0x228
  21d908:	48 f7 df             	neg    rdi
  21d90b:	31 c9                	xor    ecx,ecx
  21d90d:	0f 1f 00             	nop    DWORD PTR [rax]
        dest[i] = s;
  21d910:	c5 fa 6f 04 08       	vmovdqu xmm0,XMMWORD PTR [rax+rcx*1]
  21d915:	c5 fa 7f 04 0a       	vmovdqu XMMWORD PTR [rdx+rcx*1],xmm0
    for (source) |s, i|
  21d91a:	48 83 c1 10          	add    rcx,0x10
  21d91e:	48 83 c7 01          	add    rdi,0x1
  21d922:	75 ec                	jne    21d910 <Benchmark_reportStats+0x7d10>
  21d924:	e9 d7 01 00 00       	jmp    21db00 <Benchmark_reportStats+0x7f00>
  21d929:	4c 03 54 24 68       	add    r10,QWORD PTR [rsp+0x68]
  21d92e:	49 01 ca             	add    r10,rcx
  21d931:	49 01 f2             	add    r10,rsi
  21d934:	4d 29 c2             	sub    r10,r8
  21d937:	49 29 d2             	sub    r10,rdx
  21d93a:	b9 70 00 00 00       	mov    ecx,0x70
  21d93f:	31 c0                	xor    eax,eax
  21d941:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21d948:	0f 1f 84 00 00 00 00 
  21d94f:	00 
        dest[i] = s;
  21d950:	c4 c1 78 10 44 09 90 	vmovups xmm0,XMMWORD PTR [r9+rcx*1-0x70]
  21d957:	c4 c1 78 11 44 0e a0 	vmovups XMMWORD PTR [r14+rcx*1-0x60],xmm0
  21d95e:	c4 c1 78 10 44 09 a0 	vmovups xmm0,XMMWORD PTR [r9+rcx*1-0x60]
  21d965:	c4 c1 78 11 44 0e b0 	vmovups XMMWORD PTR [r14+rcx*1-0x50],xmm0
  21d96c:	c4 c1 78 10 44 09 b0 	vmovups xmm0,XMMWORD PTR [r9+rcx*1-0x50]
  21d973:	c4 c1 78 11 44 0e c0 	vmovups XMMWORD PTR [r14+rcx*1-0x40],xmm0
  21d97a:	c4 c1 78 10 44 09 c0 	vmovups xmm0,XMMWORD PTR [r9+rcx*1-0x40]
  21d981:	c4 c1 78 11 44 0e d0 	vmovups XMMWORD PTR [r14+rcx*1-0x30],xmm0
  21d988:	c4 c1 78 10 44 09 d0 	vmovups xmm0,XMMWORD PTR [r9+rcx*1-0x30]
  21d98f:	c4 c1 78 11 44 0e e0 	vmovups XMMWORD PTR [r14+rcx*1-0x20],xmm0
  21d996:	c4 c1 78 10 44 09 e0 	vmovups xmm0,XMMWORD PTR [r9+rcx*1-0x20]
  21d99d:	c4 c1 78 11 44 0e f0 	vmovups XMMWORD PTR [r14+rcx*1-0x10],xmm0
  21d9a4:	c4 c1 78 10 44 09 f0 	vmovups xmm0,XMMWORD PTR [r9+rcx*1-0x10]
  21d9ab:	c4 c1 78 11 04 0e    	vmovups XMMWORD PTR [r14+rcx*1],xmm0
  21d9b1:	c4 c1 7a 6f 04 09    	vmovdqu xmm0,XMMWORD PTR [r9+rcx*1]
  21d9b7:	c4 c1 7a 7f 44 0e 10 	vmovdqu XMMWORD PTR [r14+rcx*1+0x10],xmm0
    for (source) |s, i|
  21d9be:	48 83 c0 08          	add    rax,0x8
  21d9c2:	48 83 e9 80          	sub    rcx,0xffffffffffffff80
  21d9c6:	49 39 c2             	cmp    r10,rax
  21d9c9:	75 85                	jne    21d950 <Benchmark_reportStats+0x7d50>
  21d9cb:	4d 85 c0             	test   r8,r8
  21d9ce:	48 8b 4c 24 10       	mov    rcx,QWORD PTR [rsp+0x10]
  21d9d3:	0f 84 27 01 00 00    	je     21db00 <Benchmark_reportStats+0x7f00>
  21d9d9:	48 01 c1             	add    rcx,rax
  21d9dc:	48 c1 e1 04          	shl    rcx,0x4
  21d9e0:	49 01 cf             	add    r15,rcx
  21d9e3:	4b 8d 0c 3b          	lea    rcx,[r11+r15*1]
  21d9e7:	48 83 c1 10          	add    rcx,0x10
  21d9eb:	48 c1 e0 04          	shl    rax,0x4
  21d9ef:	48 01 e0             	add    rax,rsp
  21d9f2:	48 05 28 02 00 00    	add    rax,0x228
  21d9f8:	48 01 d8             	add    rax,rbx
  21d9fb:	49 f7 d8             	neg    r8
  21d9fe:	31 d2                	xor    edx,edx
        dest[i] = s;
  21da00:	c5 fa 6f 04 10       	vmovdqu xmm0,XMMWORD PTR [rax+rdx*1]
  21da05:	c5 fa 7f 04 11       	vmovdqu XMMWORD PTR [rcx+rdx*1],xmm0
    for (source) |s, i|
  21da0a:	48 83 c2 10          	add    rdx,0x10
  21da0e:	49 83 c0 01          	add    r8,0x1
  21da12:	75 ec                	jne    21da00 <Benchmark_reportStats+0x7e00>
  21da14:	e9 e7 00 00 00       	jmp    21db00 <Benchmark_reportStats+0x7f00>
  21da19:	48 29 d1             	sub    rcx,rdx
  21da1c:	b8 70 00 00 00       	mov    eax,0x70
  21da21:	31 f6                	xor    esi,esi
  21da23:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21da2a:	84 00 00 00 00 00 
        dest[i] = s;
  21da30:	c4 c1 78 10 44 05 90 	vmovups xmm0,XMMWORD PTR [r13+rax*1-0x70]
  21da37:	c4 c1 78 11 44 06 a0 	vmovups XMMWORD PTR [r14+rax*1-0x60],xmm0
  21da3e:	c4 c1 78 10 44 05 a0 	vmovups xmm0,XMMWORD PTR [r13+rax*1-0x60]
  21da45:	c4 c1 78 11 44 06 b0 	vmovups XMMWORD PTR [r14+rax*1-0x50],xmm0
  21da4c:	c4 c1 78 10 44 05 b0 	vmovups xmm0,XMMWORD PTR [r13+rax*1-0x50]
  21da53:	c4 c1 78 11 44 06 c0 	vmovups XMMWORD PTR [r14+rax*1-0x40],xmm0
  21da5a:	c4 c1 78 10 44 05 c0 	vmovups xmm0,XMMWORD PTR [r13+rax*1-0x40]
  21da61:	c4 c1 78 11 44 06 d0 	vmovups XMMWORD PTR [r14+rax*1-0x30],xmm0
  21da68:	c4 c1 78 10 44 05 d0 	vmovups xmm0,XMMWORD PTR [r13+rax*1-0x30]
  21da6f:	c4 c1 78 11 44 06 e0 	vmovups XMMWORD PTR [r14+rax*1-0x20],xmm0
  21da76:	c4 c1 78 10 44 05 e0 	vmovups xmm0,XMMWORD PTR [r13+rax*1-0x20]
  21da7d:	c4 c1 78 11 44 06 f0 	vmovups XMMWORD PTR [r14+rax*1-0x10],xmm0
  21da84:	c4 c1 78 10 44 05 f0 	vmovups xmm0,XMMWORD PTR [r13+rax*1-0x10]
  21da8b:	c4 c1 78 11 04 06    	vmovups XMMWORD PTR [r14+rax*1],xmm0
  21da91:	c4 c1 7a 6f 44 05 00 	vmovdqu xmm0,XMMWORD PTR [r13+rax*1+0x0]
  21da98:	c4 c1 7a 7f 44 06 10 	vmovdqu XMMWORD PTR [r14+rax*1+0x10],xmm0
    for (source) |s, i|
  21da9f:	48 83 c6 08          	add    rsi,0x8
  21daa3:	48 83 e8 80          	sub    rax,0xffffffffffffff80
  21daa7:	48 39 f1             	cmp    rcx,rsi
  21daaa:	75 84                	jne    21da30 <Benchmark_reportStats+0x7e30>
  21daac:	48 85 d2             	test   rdx,rdx
  21daaf:	48 8b 44 24 10       	mov    rax,QWORD PTR [rsp+0x10]
  21dab4:	74 4a                	je     21db00 <Benchmark_reportStats+0x7f00>
  21dab6:	48 01 f0             	add    rax,rsi
  21dab9:	48 c1 e0 04          	shl    rax,0x4
  21dabd:	49 01 c7             	add    r15,rax
  21dac0:	4b 8d 04 3b          	lea    rax,[r11+r15*1]
  21dac4:	48 83 c0 10          	add    rax,0x10
  21dac8:	48 c1 e6 04          	shl    rsi,0x4
  21dacc:	48 8d 0c 34          	lea    rcx,[rsp+rsi*1]
  21dad0:	48 81 c1 28 02 00 00 	add    rcx,0x228
  21dad7:	48 01 f9             	add    rcx,rdi
  21dada:	48 f7 da             	neg    rdx
  21dadd:	31 f6                	xor    esi,esi
  21dadf:	90                   	nop
        dest[i] = s;
  21dae0:	c5 fa 6f 04 31       	vmovdqu xmm0,XMMWORD PTR [rcx+rsi*1]
  21dae5:	c5 fa 7f 04 30       	vmovdqu XMMWORD PTR [rax+rsi*1],xmm0
    for (source) |s, i|
  21daea:	48 83 c6 10          	add    rsi,0x10
  21daee:	48 83 c2 01          	add    rdx,0x1
  21daf2:	75 ec                	jne    21dae0 <Benchmark_reportStats+0x7ee0>
  21daf4:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21dafb:	00 00 00 00 00 
  21db00:	4c 8b 94 24 d0 00 00 	mov    r10,QWORD PTR [rsp+0xd0]
  21db07:	00 
  21db08:	4c 2b 94 24 f8 00 00 	sub    r10,QWORD PTR [rsp+0xf8]
  21db0f:	00 
  21db10:	48 8b 44 24 38       	mov    rax,QWORD PTR [rsp+0x38]
        return self.decimal >= self.size;
  21db15:	48 3b 84 24 f0 00 00 	cmp    rax,QWORD PTR [rsp+0xf0]
  21db1c:	00 
  21db1d:	4c 8b bc 24 00 01 00 	mov    r15,QWORD PTR [rsp+0x100]
  21db24:	00 
  21db25:	4c 8b a4 24 d8 00 00 	mov    r12,QWORD PTR [rsp+0xd8]
  21db2c:	00 
  21db2d:	4c 8b 8c 24 e0 00 00 	mov    r9,QWORD PTR [rsp+0xe0]
  21db34:	00 
                while (!iterator.finished()) {
  21db35:	0f 82 25 e4 ff ff    	jb     21bf60 <Benchmark_reportStats+0x6360>
        self.numerator_step += self.numerator_step;
  21db3b:	4d 01 c9             	add    r9,r9
        if (self.numerator_step >= self.denominator) {
  21db3e:	4c 89 c8             	mov    rax,r9
  21db41:	4c 29 f8             	sub    rax,r15
  21db44:	0f 83 23 08 00 00    	jae    21e36d <Benchmark_reportStats+0x876d>
  21db4a:	4c 8b 64 24 68       	mov    r12,QWORD PTR [rsp+0x68]
  21db4f:	4c 89 c8             	mov    rax,r9
  21db52:	e9 29 08 00 00       	jmp    21e380 <Benchmark_reportStats+0x8780>
        self.decimal += self.decimal_step;
  21db57:	4b 8d 04 24          	lea    rax,[r12+r12*1]
  21db5b:	48 89 44 24 30       	mov    QWORD PTR [rsp+0x30],rax
  21db60:	45 31 c9             	xor    r9d,r9d
  21db63:	45 31 db             	xor    r11d,r11d
  21db66:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  21db6d:	00 00 00 
  21db70:	4d 89 ce             	mov    r14,r9
  21db73:	4b 8d 04 26          	lea    rax,[r14+r12*1]
  21db77:	48 8b 94 24 e0 00 00 	mov    rdx,QWORD PTR [rsp+0xe0]
  21db7e:	00 
        self.numerator += self.numerator_step;
  21db7f:	49 01 d3             	add    r11,rdx
        if (self.numerator >= self.denominator) {
  21db82:	31 f6                	xor    esi,esi
  21db84:	4d 39 fb             	cmp    r11,r15
  21db87:	40 0f 93 c6          	setae  sil
  21db8b:	4c 89 f9             	mov    rcx,r15
  21db8e:	bf 00 00 00 00       	mov    edi,0x0
  21db93:	48 0f 42 cf          	cmovb  rcx,rdi
  21db97:	49 29 cb             	sub    r11,rcx
  21db9a:	48 89 74 24 18       	mov    QWORD PTR [rsp+0x18],rsi
  21db9f:	4c 8d 2c 30          	lea    r13,[rax+rsi*1]
        self.decimal += self.decimal_step;
  21dba3:	4f 8d 0c 2c          	lea    r9,[r12+r13*1]
        self.numerator += self.numerator_step;
  21dba7:	49 01 d3             	add    r11,rdx
        if (self.numerator >= self.denominator) {
  21dbaa:	31 f6                	xor    esi,esi
  21dbac:	4d 39 fb             	cmp    r11,r15
  21dbaf:	40 0f 93 c6          	setae  sil
  21dbb3:	4c 89 fa             	mov    rdx,r15
  21dbb6:	48 0f 42 d7          	cmovb  rdx,rdi
  21dbba:	49 01 f1             	add    r9,rsi
                    if (lessThan(items[B.end - 1], items[A.start])) {
  21dbbd:	4c 89 c9             	mov    rcx,r9
  21dbc0:	48 c1 e1 04          	shl    rcx,0x4
  21dbc4:	4c 8b 7c 24 40       	mov    r15,QWORD PTR [rsp+0x40]
  21dbc9:	4d 89 f2             	mov    r10,r14
  21dbcc:	49 c1 e2 04          	shl    r10,0x4
  21dbd0:	49 8b 4c 0f f0       	mov    rcx,QWORD PTR [r15+rcx*1-0x10]
  21dbd5:	4b 3b 0c 17          	cmp    rcx,QWORD PTR [r15+r10*1]
  21dbd9:	4b 8d 3c 17          	lea    rdi,[r15+r10*1]
  21dbdd:	48 89 54 24 38       	mov    QWORD PTR [rsp+0x38],rdx
  21dbe2:	73 4c                	jae    21dc30 <Benchmark_reportStats+0x8030>
  21dbe4:	48 89 74 24 10       	mov    QWORD PTR [rsp+0x10],rsi
  21dbe9:	4c 89 4c 24 20       	mov    QWORD PTR [rsp+0x20],r9
                        mem.rotate(T, items[A.start..B.end], A.length());
  21dbee:	4d 89 cc             	mov    r12,r9
  21dbf1:	4d 29 f4             	sub    r12,r14
        return self.end - self.start;
  21dbf4:	4c 89 eb             	mov    rbx,r13
  21dbf7:	4c 29 f3             	sub    rbx,r14
    const end = items.len / 2;
  21dbfa:	48 89 de             	mov    rsi,rbx
  21dbfd:	48 d1 ee             	shr    rsi,1
    while (i < end) : (i += 1) {
  21dc00:	0f 84 94 01 00 00    	je     21dd9a <Benchmark_reportStats+0x819a>
        swap(T, &items[i], &items[items.len - i - 1]);
  21dc06:	48 8d 4e ff          	lea    rcx,[rsi-0x1]
  21dc0a:	41 89 f0             	mov    r8d,esi
  21dc0d:	41 83 e0 03          	and    r8d,0x3
  21dc11:	48 83 f9 03          	cmp    rcx,0x3
  21dc15:	73 79                	jae    21dc90 <Benchmark_reportStats+0x8090>
  21dc17:	45 31 c9             	xor    r9d,r9d
    while (i < end) : (i += 1) {
  21dc1a:	4d 85 c0             	test   r8,r8
  21dc1d:	0f 85 1b 01 00 00    	jne    21dd3e <Benchmark_reportStats+0x813e>
  21dc23:	e9 72 01 00 00       	jmp    21dd9a <Benchmark_reportStats+0x819a>
  21dc28:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  21dc2f:	00 
                    } else if (lessThan(items[B.start], items[A.end - 1])) {
  21dc30:	4c 89 e8             	mov    rax,r13
  21dc33:	48 c1 e0 04          	shl    rax,0x4
  21dc37:	49 8b 0c 07          	mov    rcx,QWORD PTR [r15+rax*1]
  21dc3b:	49 3b 4c 07 f0       	cmp    rcx,QWORD PTR [r15+rax*1-0x10]
  21dc40:	0f 83 fa 06 00 00    	jae    21e340 <Benchmark_reportStats+0x8740>
                        mem.copy(T, cache[0..], items[A.start..A.end]);
  21dc46:	4d 89 ea             	mov    r10,r13
  21dc49:	4d 29 f2             	sub    r10,r14
    assert(dest.len >= source.len);
  21dc4c:	49 81 fa 01 02 00 00 	cmp    r10,0x201
  21dc53:	0f 83 13 0b 00 00    	jae    21e76c <Benchmark_reportStats+0x8b6c>
    for (source) |s, i|
  21dc59:	4d 85 d2             	test   r10,r10
  21dc5c:	0f 84 cf 03 00 00    	je     21e031 <Benchmark_reportStats+0x8431>
  21dc62:	48 8b 44 24 50       	mov    rax,QWORD PTR [rsp+0x50]
  21dc67:	48 8b 4c 24 18       	mov    rcx,QWORD PTR [rsp+0x18]
  21dc6c:	48 8d 04 08          	lea    rax,[rax+rcx*1]
  21dc70:	44 89 d6             	mov    esi,r10d
  21dc73:	83 e6 07             	and    esi,0x7
  21dc76:	48 83 f8 07          	cmp    rax,0x7
  21dc7a:	0f 83 de 02 00 00    	jae    21df5e <Benchmark_reportStats+0x835e>
  21dc80:	31 c9                	xor    ecx,ecx
  21dc82:	48 85 f6             	test   rsi,rsi
  21dc85:	0f 85 72 03 00 00    	jne    21dffd <Benchmark_reportStats+0x83fd>
  21dc8b:	e9 98 03 00 00       	jmp    21e028 <Benchmark_reportStats+0x8428>
        swap(T, &items[i], &items[items.len - i - 1]);
  21dc90:	4c 29 c6             	sub    rsi,r8
  21dc93:	4b 8d 0c 17          	lea    rcx,[r15+r10*1]
  21dc97:	48 83 c1 30          	add    rcx,0x30
  21dc9b:	4c 89 ea             	mov    rdx,r13
  21dc9e:	48 c1 e2 04          	shl    rdx,0x4
  21dca2:	4c 01 fa             	add    rdx,r15
  21dca5:	48 83 c2 f0          	add    rdx,0xfffffffffffffff0
  21dca9:	45 31 c9             	xor    r9d,r9d
  21dcac:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
    const tmp = a.*;
  21dcb0:	c5 f8 10 41 d0       	vmovups xmm0,XMMWORD PTR [rcx-0x30]
  21dcb5:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21dcba:	c5 f8 10 02          	vmovups xmm0,XMMWORD PTR [rdx]
  21dcbe:	c5 f8 11 41 d0       	vmovups XMMWORD PTR [rcx-0x30],xmm0
    b.* = tmp;
  21dcc3:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  21dcc8:	c5 f8 11 02          	vmovups XMMWORD PTR [rdx],xmm0
    const tmp = a.*;
  21dccc:	c5 f8 10 41 e0       	vmovups xmm0,XMMWORD PTR [rcx-0x20]
  21dcd1:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21dcd6:	c5 f8 10 42 f0       	vmovups xmm0,XMMWORD PTR [rdx-0x10]
  21dcdb:	c5 f8 11 41 e0       	vmovups XMMWORD PTR [rcx-0x20],xmm0
    b.* = tmp;
  21dce0:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  21dce5:	c5 f8 11 42 f0       	vmovups XMMWORD PTR [rdx-0x10],xmm0
    const tmp = a.*;
  21dcea:	c5 f8 10 41 f0       	vmovups xmm0,XMMWORD PTR [rcx-0x10]
  21dcef:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21dcf4:	c5 f8 10 42 e0       	vmovups xmm0,XMMWORD PTR [rdx-0x20]
  21dcf9:	c5 f8 11 41 f0       	vmovups XMMWORD PTR [rcx-0x10],xmm0
    b.* = tmp;
  21dcfe:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  21dd03:	c5 f8 11 42 e0       	vmovups XMMWORD PTR [rdx-0x20],xmm0
    const tmp = a.*;
  21dd08:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  21dd0c:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21dd11:	c5 f8 10 42 d0       	vmovups xmm0,XMMWORD PTR [rdx-0x30]
  21dd16:	c5 f8 11 01          	vmovups XMMWORD PTR [rcx],xmm0
    b.* = tmp;
  21dd1a:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  21dd1f:	c5 fa 7f 42 d0       	vmovdqu XMMWORD PTR [rdx-0x30],xmm0
    while (i < end) : (i += 1) {
  21dd24:	49 83 c1 04          	add    r9,0x4
  21dd28:	48 83 c1 40          	add    rcx,0x40
  21dd2c:	48 83 c2 c0          	add    rdx,0xffffffffffffffc0
  21dd30:	4c 39 ce             	cmp    rsi,r9
  21dd33:	0f 85 77 ff ff ff    	jne    21dcb0 <Benchmark_reportStats+0x80b0>
  21dd39:	4d 85 c0             	test   r8,r8
  21dd3c:	74 5c                	je     21dd9a <Benchmark_reportStats+0x819a>
  21dd3e:	48 8b 4c 24 18       	mov    rcx,QWORD PTR [rsp+0x18]
  21dd43:	48 8d 0c 08          	lea    rcx,[rax+rcx*1]
  21dd47:	4c 29 c9             	sub    rcx,r9
  21dd4a:	48 c1 e1 04          	shl    rcx,0x4
  21dd4e:	4c 01 f9             	add    rcx,r15
  21dd51:	48 83 c1 f0          	add    rcx,0xfffffffffffffff0
  21dd55:	4d 01 f1             	add    r9,r14
  21dd58:	49 c1 e1 04          	shl    r9,0x4
  21dd5c:	4d 01 f9             	add    r9,r15
  21dd5f:	49 f7 d8             	neg    r8
  21dd62:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21dd69:	1f 84 00 00 00 00 00 
    const tmp = a.*;
  21dd70:	c4 c1 78 10 01       	vmovups xmm0,XMMWORD PTR [r9]
  21dd75:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21dd7a:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  21dd7e:	c4 c1 78 11 01       	vmovups XMMWORD PTR [r9],xmm0
    b.* = tmp;
  21dd83:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  21dd88:	c5 fa 7f 01          	vmovdqu XMMWORD PTR [rcx],xmm0
    while (i < end) : (i += 1) {
  21dd8c:	48 83 c1 f0          	add    rcx,0xfffffffffffffff0
  21dd90:	49 83 c1 10          	add    r9,0x10
  21dd94:	49 83 c0 01          	add    r8,0x1
  21dd98:	75 d6                	jne    21dd70 <Benchmark_reportStats+0x8170>
    reverse(T, items[amount..]);
  21dd9a:	4d 89 e0             	mov    r8,r12
  21dd9d:	49 29 d8             	sub    r8,rbx
    const end = items.len / 2;
  21dda0:	49 d1 e8             	shr    r8,1
    while (i < end) : (i += 1) {
  21dda3:	0f 84 4f 01 00 00    	je     21def8 <Benchmark_reportStats+0x82f8>
        swap(T, &items[i], &items[items.len - i - 1]);
  21dda9:	49 8d 48 ff          	lea    rcx,[r8-0x1]
  21ddad:	44 89 c3             	mov    ebx,r8d
  21ddb0:	83 e3 03             	and    ebx,0x3
  21ddb3:	48 83 f9 03          	cmp    rcx,0x3
  21ddb7:	73 10                	jae    21ddc9 <Benchmark_reportStats+0x81c9>
  21ddb9:	31 c9                	xor    ecx,ecx
    while (i < end) : (i += 1) {
  21ddbb:	48 85 db             	test   rbx,rbx
  21ddbe:	0f 85 ca 00 00 00    	jne    21de8e <Benchmark_reportStats+0x828e>
  21ddc4:	e9 2f 01 00 00       	jmp    21def8 <Benchmark_reportStats+0x82f8>
        swap(T, &items[i], &items[items.len - i - 1]);
  21ddc9:	49 29 d8             	sub    r8,rbx
  21ddcc:	49 c1 e5 04          	shl    r13,0x4
  21ddd0:	4b 8d 14 2f          	lea    rdx,[r15+r13*1]
  21ddd4:	48 83 c2 30          	add    rdx,0x30
  21ddd8:	48 8b 4c 24 30       	mov    rcx,QWORD PTR [rsp+0x30]
  21dddd:	48 c1 e1 04          	shl    rcx,0x4
  21dde1:	4c 01 f9             	add    rcx,r15
  21dde4:	48 8b 74 24 18       	mov    rsi,QWORD PTR [rsp+0x18]
  21dde9:	49 8d 34 36          	lea    rsi,[r14+rsi*1]
  21dded:	48 03 74 24 10       	add    rsi,QWORD PTR [rsp+0x10]
  21ddf2:	48 c1 e6 04          	shl    rsi,0x4
  21ddf6:	48 01 ce             	add    rsi,rcx
  21ddf9:	48 83 c6 f0          	add    rsi,0xfffffffffffffff0
  21ddfd:	31 c9                	xor    ecx,ecx
  21ddff:	90                   	nop
    const tmp = a.*;
  21de00:	c5 f8 10 42 d0       	vmovups xmm0,XMMWORD PTR [rdx-0x30]
  21de05:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21de0a:	c5 f8 10 06          	vmovups xmm0,XMMWORD PTR [rsi]
  21de0e:	c5 f8 11 42 d0       	vmovups XMMWORD PTR [rdx-0x30],xmm0
    b.* = tmp;
  21de13:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  21de18:	c5 f8 11 06          	vmovups XMMWORD PTR [rsi],xmm0
    const tmp = a.*;
  21de1c:	c5 f8 10 42 e0       	vmovups xmm0,XMMWORD PTR [rdx-0x20]
  21de21:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21de26:	c5 f8 10 46 f0       	vmovups xmm0,XMMWORD PTR [rsi-0x10]
  21de2b:	c5 f8 11 42 e0       	vmovups XMMWORD PTR [rdx-0x20],xmm0
    b.* = tmp;
  21de30:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  21de35:	c5 f8 11 46 f0       	vmovups XMMWORD PTR [rsi-0x10],xmm0
    const tmp = a.*;
  21de3a:	c5 f8 10 42 f0       	vmovups xmm0,XMMWORD PTR [rdx-0x10]
  21de3f:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21de44:	c5 f8 10 46 e0       	vmovups xmm0,XMMWORD PTR [rsi-0x20]
  21de49:	c5 f8 11 42 f0       	vmovups XMMWORD PTR [rdx-0x10],xmm0
    b.* = tmp;
  21de4e:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  21de53:	c5 f8 11 46 e0       	vmovups XMMWORD PTR [rsi-0x20],xmm0
    const tmp = a.*;
  21de58:	c5 f8 10 02          	vmovups xmm0,XMMWORD PTR [rdx]
  21de5c:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21de61:	c5 f8 10 46 d0       	vmovups xmm0,XMMWORD PTR [rsi-0x30]
  21de66:	c5 f8 11 02          	vmovups XMMWORD PTR [rdx],xmm0
    b.* = tmp;
  21de6a:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  21de6f:	c5 fa 7f 46 d0       	vmovdqu XMMWORD PTR [rsi-0x30],xmm0
    while (i < end) : (i += 1) {
  21de74:	48 83 c1 04          	add    rcx,0x4
  21de78:	48 83 c2 40          	add    rdx,0x40
  21de7c:	48 83 c6 c0          	add    rsi,0xffffffffffffffc0
  21de80:	49 39 c8             	cmp    r8,rcx
  21de83:	0f 85 77 ff ff ff    	jne    21de00 <Benchmark_reportStats+0x8200>
  21de89:	48 85 db             	test   rbx,rbx
  21de8c:	74 6a                	je     21def8 <Benchmark_reportStats+0x82f8>
  21de8e:	48 8b 54 24 30       	mov    rdx,QWORD PTR [rsp+0x30]
  21de93:	48 c1 e2 04          	shl    rdx,0x4
  21de97:	4c 01 fa             	add    rdx,r15
  21de9a:	4c 8b 44 24 18       	mov    r8,QWORD PTR [rsp+0x18]
  21de9f:	4b 8d 34 06          	lea    rsi,[r14+r8*1]
  21dea3:	48 03 74 24 10       	add    rsi,QWORD PTR [rsp+0x10]
  21dea8:	48 29 ce             	sub    rsi,rcx
  21deab:	48 c1 e6 04          	shl    rsi,0x4
  21deaf:	48 01 f2             	add    rdx,rsi
  21deb2:	48 83 c2 f0          	add    rdx,0xfffffffffffffff0
  21deb6:	48 01 c8             	add    rax,rcx
  21deb9:	4c 01 c0             	add    rax,r8
  21debc:	48 c1 e0 04          	shl    rax,0x4
  21dec0:	4c 01 f8             	add    rax,r15
  21dec3:	48 f7 db             	neg    rbx
  21dec6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  21decd:	00 00 00 
    const tmp = a.*;
  21ded0:	c5 f8 10 00          	vmovups xmm0,XMMWORD PTR [rax]
  21ded4:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21ded9:	c5 f8 10 02          	vmovups xmm0,XMMWORD PTR [rdx]
  21dedd:	c5 f8 11 00          	vmovups XMMWORD PTR [rax],xmm0
    b.* = tmp;
  21dee1:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  21dee6:	c5 fa 7f 02          	vmovdqu XMMWORD PTR [rdx],xmm0
    while (i < end) : (i += 1) {
  21deea:	48 83 c2 f0          	add    rdx,0xfffffffffffffff0
  21deee:	48 83 c0 10          	add    rax,0x10
  21def2:	48 83 c3 01          	add    rbx,0x1
  21def6:	75 d8                	jne    21ded0 <Benchmark_reportStats+0x82d0>
    const end = items.len / 2;
  21def8:	4c 89 e3             	mov    rbx,r12
  21defb:	48 d1 eb             	shr    rbx,1
  21defe:	4c 8b 4c 24 20       	mov    r9,QWORD PTR [rsp+0x20]
    while (i < end) : (i += 1) {
  21df03:	0f 84 37 04 00 00    	je     21e340 <Benchmark_reportStats+0x8740>
    const tmp = a.*;
  21df09:	c5 f8 10 07          	vmovups xmm0,XMMWORD PTR [rdi]
  21df0d:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  21df12:	49 c1 e4 04          	shl    r12,0x4
    a.* = b.*;
  21df16:	c4 a1 78 10 44 27 f0 	vmovups xmm0,XMMWORD PTR [rdi+r12*1-0x10]
  21df1d:	c5 f8 11 07          	vmovups XMMWORD PTR [rdi],xmm0
    b.* = tmp;
  21df21:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  21df26:	c4 a1 7a 7f 44 27 f0 	vmovdqu XMMWORD PTR [rdi+r12*1-0x10],xmm0
    while (i < end) : (i += 1) {
  21df2d:	48 83 fb 01          	cmp    rbx,0x1
  21df31:	0f 84 09 04 00 00    	je     21e340 <Benchmark_reportStats+0x8740>
        swap(T, &items[i], &items[items.len - i - 1]);
  21df37:	8d 43 ff             	lea    eax,[rbx-0x1]
  21df3a:	48 8d 4b fe          	lea    rcx,[rbx-0x2]
  21df3e:	83 e0 03             	and    eax,0x3
  21df41:	48 83 f9 03          	cmp    rcx,0x3
  21df45:	0f 83 ee 00 00 00    	jae    21e039 <Benchmark_reportStats+0x8439>
  21df4b:	be 01 00 00 00       	mov    esi,0x1
    while (i < end) : (i += 1) {
  21df50:	48 85 c0             	test   rax,rax
  21df53:	0f 85 a9 01 00 00    	jne    21e102 <Benchmark_reportStats+0x8502>
  21df59:	e9 e2 03 00 00       	jmp    21e340 <Benchmark_reportStats+0x8740>
    for (source) |s, i|
  21df5e:	4c 89 d2             	mov    rdx,r10
  21df61:	48 29 f2             	sub    rdx,rsi
  21df64:	bb 70 00 00 00       	mov    ebx,0x70
  21df69:	31 c9                	xor    ecx,ecx
  21df6b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
        dest[i] = s;
  21df70:	c5 f8 10 44 1f 90    	vmovups xmm0,XMMWORD PTR [rdi+rbx*1-0x70]
  21df76:	c5 f8 11 84 1c b8 01 	vmovups XMMWORD PTR [rsp+rbx*1+0x1b8],xmm0
  21df7d:	00 00 
  21df7f:	c5 f8 10 44 1f a0    	vmovups xmm0,XMMWORD PTR [rdi+rbx*1-0x60]
  21df85:	c5 f8 11 84 1c c8 01 	vmovups XMMWORD PTR [rsp+rbx*1+0x1c8],xmm0
  21df8c:	00 00 
  21df8e:	c5 f8 10 44 1f b0    	vmovups xmm0,XMMWORD PTR [rdi+rbx*1-0x50]
  21df94:	c5 f8 11 84 1c d8 01 	vmovups XMMWORD PTR [rsp+rbx*1+0x1d8],xmm0
  21df9b:	00 00 
  21df9d:	c5 f8 10 44 1f c0    	vmovups xmm0,XMMWORD PTR [rdi+rbx*1-0x40]
  21dfa3:	c5 f8 11 84 1c e8 01 	vmovups XMMWORD PTR [rsp+rbx*1+0x1e8],xmm0
  21dfaa:	00 00 
  21dfac:	c5 f8 10 44 1f d0    	vmovups xmm0,XMMWORD PTR [rdi+rbx*1-0x30]
  21dfb2:	c5 f8 11 84 1c f8 01 	vmovups XMMWORD PTR [rsp+rbx*1+0x1f8],xmm0
  21dfb9:	00 00 
  21dfbb:	c5 f8 10 44 1f e0    	vmovups xmm0,XMMWORD PTR [rdi+rbx*1-0x20]
  21dfc1:	c5 f8 11 84 1c 08 02 	vmovups XMMWORD PTR [rsp+rbx*1+0x208],xmm0
  21dfc8:	00 00 
  21dfca:	c5 f8 10 44 1f f0    	vmovups xmm0,XMMWORD PTR [rdi+rbx*1-0x10]
  21dfd0:	c5 f8 11 84 1c 18 02 	vmovups XMMWORD PTR [rsp+rbx*1+0x218],xmm0
  21dfd7:	00 00 
  21dfd9:	c5 fa 6f 04 1f       	vmovdqu xmm0,XMMWORD PTR [rdi+rbx*1]
  21dfde:	c5 fa 7f 84 1c 28 02 	vmovdqu XMMWORD PTR [rsp+rbx*1+0x228],xmm0
  21dfe5:	00 00 
    for (source) |s, i|
  21dfe7:	48 83 c1 08          	add    rcx,0x8
  21dfeb:	48 83 eb 80          	sub    rbx,0xffffffffffffff80
  21dfef:	48 39 ca             	cmp    rdx,rcx
  21dff2:	0f 85 78 ff ff ff    	jne    21df70 <Benchmark_reportStats+0x8370>
  21dff8:	48 85 f6             	test   rsi,rsi
  21dffb:	74 2b                	je     21e028 <Benchmark_reportStats+0x8428>
  21dffd:	48 c1 e1 04          	shl    rcx,0x4
  21e001:	48 f7 de             	neg    rsi
  21e004:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21e00b:	00 00 00 00 00 
        dest[i] = s;
  21e010:	c5 fa 6f 04 0f       	vmovdqu xmm0,XMMWORD PTR [rdi+rcx*1]
  21e015:	c5 fa 7f 84 0c 28 02 	vmovdqu XMMWORD PTR [rsp+rcx*1+0x228],xmm0
  21e01c:	00 00 
    for (source) |s, i|
  21e01e:	48 83 c1 10          	add    rcx,0x10
  21e022:	48 83 c6 01          	add    rsi,0x1
  21e026:	75 e8                	jne    21e010 <Benchmark_reportStats+0x8410>
    if (B.length() > 0 and A.length() > 0) {
  21e028:	4d 39 e9             	cmp    r9,r13
  21e02b:	0f 85 3e 01 00 00    	jne    21e16f <Benchmark_reportStats+0x856f>
  21e031:	45 31 c0             	xor    r8d,r8d
  21e034:	e9 f1 01 00 00       	jmp    21e22a <Benchmark_reportStats+0x862a>
        swap(T, &items[i], &items[items.len - i - 1]);
  21e039:	48 8b 4c 24 30       	mov    rcx,QWORD PTR [rsp+0x30]
  21e03e:	48 c1 e1 04          	shl    rcx,0x4
  21e042:	4c 01 f9             	add    rcx,r15
  21e045:	48 8b 54 24 18       	mov    rdx,QWORD PTR [rsp+0x18]
  21e04a:	49 8d 14 16          	lea    rdx,[r14+rdx*1]
  21e04e:	48 03 54 24 10       	add    rdx,QWORD PTR [rsp+0x10]
  21e053:	48 c1 e2 04          	shl    rdx,0x4
  21e057:	48 01 d1             	add    rcx,rdx
  21e05a:	48 83 c1 e0          	add    rcx,0xffffffffffffffe0
  21e05e:	4b 8d 14 17          	lea    rdx,[r15+r10*1]
  21e062:	48 83 c2 40          	add    rdx,0x40
  21e066:	48 29 c3             	sub    rbx,rax
  21e069:	be 01 00 00 00       	mov    esi,0x1
  21e06e:	66 90                	xchg   ax,ax
    const tmp = a.*;
  21e070:	c5 f8 10 42 d0       	vmovups xmm0,XMMWORD PTR [rdx-0x30]
  21e075:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21e07a:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  21e07e:	c5 f8 11 42 d0       	vmovups XMMWORD PTR [rdx-0x30],xmm0
    b.* = tmp;
  21e083:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  21e088:	c5 f8 11 01          	vmovups XMMWORD PTR [rcx],xmm0
    const tmp = a.*;
  21e08c:	c5 f8 10 42 e0       	vmovups xmm0,XMMWORD PTR [rdx-0x20]
  21e091:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21e096:	c5 f8 10 41 f0       	vmovups xmm0,XMMWORD PTR [rcx-0x10]
  21e09b:	c5 f8 11 42 e0       	vmovups XMMWORD PTR [rdx-0x20],xmm0
    b.* = tmp;
  21e0a0:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  21e0a5:	c5 f8 11 41 f0       	vmovups XMMWORD PTR [rcx-0x10],xmm0
    const tmp = a.*;
  21e0aa:	c5 f8 10 42 f0       	vmovups xmm0,XMMWORD PTR [rdx-0x10]
  21e0af:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21e0b4:	c5 f8 10 41 e0       	vmovups xmm0,XMMWORD PTR [rcx-0x20]
  21e0b9:	c5 f8 11 42 f0       	vmovups XMMWORD PTR [rdx-0x10],xmm0
    b.* = tmp;
  21e0be:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  21e0c3:	c5 f8 11 41 e0       	vmovups XMMWORD PTR [rcx-0x20],xmm0
    const tmp = a.*;
  21e0c8:	c5 f8 10 02          	vmovups xmm0,XMMWORD PTR [rdx]
  21e0cc:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21e0d1:	c5 f8 10 41 d0       	vmovups xmm0,XMMWORD PTR [rcx-0x30]
  21e0d6:	c5 f8 11 02          	vmovups XMMWORD PTR [rdx],xmm0
    b.* = tmp;
  21e0da:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  21e0df:	c5 fa 7f 41 d0       	vmovdqu XMMWORD PTR [rcx-0x30],xmm0
    while (i < end) : (i += 1) {
  21e0e4:	48 83 c6 04          	add    rsi,0x4
  21e0e8:	48 83 c1 c0          	add    rcx,0xffffffffffffffc0
  21e0ec:	48 83 c2 40          	add    rdx,0x40
  21e0f0:	48 39 f3             	cmp    rbx,rsi
  21e0f3:	0f 85 77 ff ff ff    	jne    21e070 <Benchmark_reportStats+0x8470>
  21e0f9:	48 85 c0             	test   rax,rax
  21e0fc:	0f 84 3e 02 00 00    	je     21e340 <Benchmark_reportStats+0x8740>
  21e102:	48 8b 4c 24 30       	mov    rcx,QWORD PTR [rsp+0x30]
  21e107:	48 c1 e1 04          	shl    rcx,0x4
  21e10b:	4c 01 f9             	add    rcx,r15
  21e10e:	48 8b 54 24 18       	mov    rdx,QWORD PTR [rsp+0x18]
  21e113:	4c 01 f2             	add    rdx,r14
  21e116:	48 03 54 24 10       	add    rdx,QWORD PTR [rsp+0x10]
  21e11b:	48 29 f2             	sub    rdx,rsi
  21e11e:	48 c1 e2 04          	shl    rdx,0x4
  21e122:	48 01 d1             	add    rcx,rdx
  21e125:	48 83 c1 f0          	add    rcx,0xfffffffffffffff0
  21e129:	49 01 f6             	add    r14,rsi
  21e12c:	49 c1 e6 04          	shl    r14,0x4
  21e130:	4d 01 fe             	add    r14,r15
  21e133:	48 f7 d8             	neg    rax
  21e136:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  21e13d:	00 00 00 
    const tmp = a.*;
  21e140:	c4 c1 78 10 06       	vmovups xmm0,XMMWORD PTR [r14]
  21e145:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21e14a:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  21e14e:	c4 c1 78 11 06       	vmovups XMMWORD PTR [r14],xmm0
    b.* = tmp;
  21e153:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  21e158:	c5 fa 7f 01          	vmovdqu XMMWORD PTR [rcx],xmm0
    while (i < end) : (i += 1) {
  21e15c:	48 83 c1 f0          	add    rcx,0xfffffffffffffff0
  21e160:	49 83 c6 10          	add    r14,0x10
  21e164:	48 83 c0 01          	add    rax,0x1
  21e168:	75 d6                	jne    21e140 <Benchmark_reportStats+0x8540>
  21e16a:	e9 d1 01 00 00       	jmp    21e340 <Benchmark_reportStats+0x8740>
  21e16f:	4c 89 4c 24 20       	mov    QWORD PTR [rsp+0x20],r9
            if (!lessThan(items[B_index], cache[A_index])) {
  21e174:	49 f7 d9             	neg    r9
  21e177:	45 31 c0             	xor    r8d,r8d
  21e17a:	4c 89 c0             	mov    rax,r8
  21e17d:	48 c1 e0 04          	shl    rax,0x4
  21e181:	4c 8d 24 04          	lea    r12,[rsp+rax*1]
  21e185:	49 81 c4 28 02 00 00 	add    r12,0x228
  21e18c:	4c 89 f7             	mov    rdi,r14
  21e18f:	48 c1 e7 04          	shl    rdi,0x4
  21e193:	4b 8d 1c 29          	lea    rbx,[r9+r13*1]
  21e197:	4c 89 e9             	mov    rcx,r13
  21e19a:	48 c1 e1 04          	shl    rcx,0x4
  21e19e:	4c 89 f8             	mov    rax,r15
  21e1a1:	31 d2                	xor    edx,edx
  21e1a3:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21e1aa:	84 00 00 00 00 00 
  21e1b0:	48 8b 34 08          	mov    rsi,QWORD PTR [rax+rcx*1]
  21e1b4:	49 3b 34 24          	cmp    rsi,QWORD PTR [r12]
  21e1b8:	73 26                	jae    21e1e0 <Benchmark_reportStats+0x85e0>
                items[insert_index] = items[B_index];
  21e1ba:	c5 fa 6f 04 01       	vmovdqu xmm0,XMMWORD PTR [rcx+rax*1]
  21e1bf:	c5 fa 7f 04 07       	vmovdqu XMMWORD PTR [rdi+rax*1],xmm0
                if (B_index == B_last) break;
  21e1c4:	48 83 c2 ff          	add    rdx,0xffffffffffffffff
  21e1c8:	48 83 c0 10          	add    rax,0x10
  21e1cc:	48 39 d3             	cmp    rbx,rdx
  21e1cf:	75 df                	jne    21e1b0 <Benchmark_reportStats+0x85b0>
  21e1d1:	eb 45                	jmp    21e218 <Benchmark_reportStats+0x8618>
  21e1d3:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21e1da:	84 00 00 00 00 00 
                items[insert_index] = cache[A_index];
  21e1e0:	c4 c1 7a 6f 04 24    	vmovdqu xmm0,XMMWORD PTR [r12]
  21e1e6:	c5 fa 7f 04 07       	vmovdqu XMMWORD PTR [rdi+rax*1],xmm0
                A_index += 1;
  21e1eb:	49 83 c0 01          	add    r8,0x1
                if (A_index == A_last) break;
  21e1ef:	4c 89 f0             	mov    rax,r14
  21e1f2:	48 83 c0 01          	add    rax,0x1
  21e1f6:	49 89 c6             	mov    r14,rax
  21e1f9:	49 29 d6             	sub    r14,rdx
  21e1fc:	4c 8b 7c 24 40       	mov    r15,QWORD PTR [rsp+0x40]
  21e201:	49 29 d5             	sub    r13,rdx
  21e204:	4d 39 d0             	cmp    r8,r10
  21e207:	0f 85 6d ff ff ff    	jne    21e17a <Benchmark_reportStats+0x857a>
    mem.copy(T, items[insert_index..], cache[A_index..A_last]);
  21e20d:	48 29 d0             	sub    rax,rdx
  21e210:	49 89 c6             	mov    r14,rax
  21e213:	4d 89 d0             	mov    r8,r10
  21e216:	eb 03                	jmp    21e21b <Benchmark_reportStats+0x861b>
  21e218:	49 29 d6             	sub    r14,rdx
  21e21b:	4c 89 f7             	mov    rdi,r14
  21e21e:	48 c1 e7 04          	shl    rdi,0x4
  21e222:	4c 01 ff             	add    rdi,r15
  21e225:	4c 8b 4c 24 20       	mov    r9,QWORD PTR [rsp+0x20]
  21e22a:	48 8b 44 24 48       	mov    rax,QWORD PTR [rsp+0x48]
  21e22f:	4c 29 f0             	sub    rax,r14
  21e232:	4d 29 c2             	sub    r10,r8
    assert(dest.len >= source.len);
  21e235:	4c 39 d0             	cmp    rax,r10
  21e238:	0f 82 2e 05 00 00    	jb     21e76c <Benchmark_reportStats+0x8b6c>
    for (source) |s, i|
  21e23e:	4d 85 d2             	test   r10,r10
  21e241:	0f 84 f9 00 00 00    	je     21e340 <Benchmark_reportStats+0x8740>
  21e247:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  21e24c:	48 03 44 24 50       	add    rax,QWORD PTR [rsp+0x50]
  21e251:	4c 29 c0             	sub    rax,r8
  21e254:	44 89 d2             	mov    edx,r10d
  21e257:	83 e2 07             	and    edx,0x7
  21e25a:	48 83 f8 07          	cmp    rax,0x7
  21e25e:	73 10                	jae    21e270 <Benchmark_reportStats+0x8670>
  21e260:	31 c9                	xor    ecx,ecx
  21e262:	48 85 d2             	test   rdx,rdx
  21e265:	0f 85 95 00 00 00    	jne    21e300 <Benchmark_reportStats+0x8700>
  21e26b:	e9 d0 00 00 00       	jmp    21e340 <Benchmark_reportStats+0x8740>
  21e270:	49 29 d2             	sub    r10,rdx
  21e273:	4c 89 c0             	mov    rax,r8
  21e276:	48 c1 e0 04          	shl    rax,0x4
  21e27a:	48 8d 1c 04          	lea    rbx,[rsp+rax*1]
  21e27e:	48 81 c3 28 02 00 00 	add    rbx,0x228
  21e285:	be 70 00 00 00       	mov    esi,0x70
  21e28a:	31 c9                	xor    ecx,ecx
  21e28c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
        dest[i] = s;
  21e290:	c5 f8 10 44 33 90    	vmovups xmm0,XMMWORD PTR [rbx+rsi*1-0x70]
  21e296:	c5 f8 11 44 37 90    	vmovups XMMWORD PTR [rdi+rsi*1-0x70],xmm0
  21e29c:	c5 f8 10 44 33 a0    	vmovups xmm0,XMMWORD PTR [rbx+rsi*1-0x60]
  21e2a2:	c5 f8 11 44 37 a0    	vmovups XMMWORD PTR [rdi+rsi*1-0x60],xmm0
  21e2a8:	c5 f8 10 44 33 b0    	vmovups xmm0,XMMWORD PTR [rbx+rsi*1-0x50]
  21e2ae:	c5 f8 11 44 37 b0    	vmovups XMMWORD PTR [rdi+rsi*1-0x50],xmm0
  21e2b4:	c5 f8 10 44 33 c0    	vmovups xmm0,XMMWORD PTR [rbx+rsi*1-0x40]
  21e2ba:	c5 f8 11 44 37 c0    	vmovups XMMWORD PTR [rdi+rsi*1-0x40],xmm0
  21e2c0:	c5 f8 10 44 33 d0    	vmovups xmm0,XMMWORD PTR [rbx+rsi*1-0x30]
  21e2c6:	c5 f8 11 44 37 d0    	vmovups XMMWORD PTR [rdi+rsi*1-0x30],xmm0
  21e2cc:	c5 f8 10 44 33 e0    	vmovups xmm0,XMMWORD PTR [rbx+rsi*1-0x20]
  21e2d2:	c5 f8 11 44 37 e0    	vmovups XMMWORD PTR [rdi+rsi*1-0x20],xmm0
  21e2d8:	c5 f8 10 44 33 f0    	vmovups xmm0,XMMWORD PTR [rbx+rsi*1-0x10]
  21e2de:	c5 f8 11 44 37 f0    	vmovups XMMWORD PTR [rdi+rsi*1-0x10],xmm0
  21e2e4:	c5 fa 6f 04 33       	vmovdqu xmm0,XMMWORD PTR [rbx+rsi*1]
  21e2e9:	c5 fa 7f 04 37       	vmovdqu XMMWORD PTR [rdi+rsi*1],xmm0
    for (source) |s, i|
  21e2ee:	48 83 c1 08          	add    rcx,0x8
  21e2f2:	48 83 ee 80          	sub    rsi,0xffffffffffffff80
  21e2f6:	49 39 ca             	cmp    r10,rcx
  21e2f9:	75 95                	jne    21e290 <Benchmark_reportStats+0x8690>
  21e2fb:	48 85 d2             	test   rdx,rdx
  21e2fe:	74 40                	je     21e340 <Benchmark_reportStats+0x8740>
  21e300:	48 c1 e1 04          	shl    rcx,0x4
  21e304:	49 c1 e0 04          	shl    r8,0x4
  21e308:	4a 8d 04 04          	lea    rax,[rsp+r8*1]
  21e30c:	48 05 28 02 00 00    	add    rax,0x228
  21e312:	48 f7 da             	neg    rdx
  21e315:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21e31c:	00 00 00 00 
        dest[i] = s;
  21e320:	c5 fa 6f 04 08       	vmovdqu xmm0,XMMWORD PTR [rax+rcx*1]
  21e325:	c5 fa 7f 04 0f       	vmovdqu XMMWORD PTR [rdi+rcx*1],xmm0
    for (source) |s, i|
  21e32a:	48 83 c1 10          	add    rcx,0x10
  21e32e:	48 83 c2 01          	add    rdx,0x1
  21e332:	75 ec                	jne    21e320 <Benchmark_reportStats+0x8720>
  21e334:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21e33b:	00 00 00 00 00 
  21e340:	4c 2b 5c 24 38       	sub    r11,QWORD PTR [rsp+0x38]
        return self.decimal >= self.size;
  21e345:	4c 3b 8c 24 f0 00 00 	cmp    r9,QWORD PTR [rsp+0xf0]
  21e34c:	00 
  21e34d:	4c 8b bc 24 00 01 00 	mov    r15,QWORD PTR [rsp+0x100]
  21e354:	00 
  21e355:	4c 8b a4 24 d8 00 00 	mov    r12,QWORD PTR [rsp+0xd8]
  21e35c:	00 
                while (!iterator.finished()) {
  21e35d:	0f 82 0d f8 ff ff    	jb     21db70 <Benchmark_reportStats+0x7f70>
  21e363:	48 8b 84 24 e0 00 00 	mov    rax,QWORD PTR [rsp+0xe0]
  21e36a:	00 
  21e36b:	eb 13                	jmp    21e380 <Benchmark_reportStats+0x8780>
  21e36d:	4c 8b 64 24 68       	mov    r12,QWORD PTR [rsp+0x68]
            self.decimal_step += 1;
  21e372:	49 83 cc 01          	or     r12,0x1
  21e376:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  21e37d:	00 00 00 
        self.numerator_step += self.numerator_step;
  21e380:	48 01 c0             	add    rax,rax
        if (self.numerator_step >= self.denominator) {
  21e383:	31 c9                	xor    ecx,ecx
  21e385:	4c 39 f8             	cmp    rax,r15
  21e388:	0f 93 c1             	setae  cl
  21e38b:	4e 8d 24 61          	lea    r12,[rcx+r12*2]
        return (self.decimal_step < self.size);
  21e38f:	4c 3b a4 24 f0 00 00 	cmp    r12,QWORD PTR [rsp+0xf0]
  21e396:	00 
  21e397:	0f 82 73 da ff ff    	jb     21be10 <Benchmark_reportStats+0x6210>
  21e39d:	eb 2f                	jmp    21e3ce <Benchmark_reportStats+0x87ce>
  21e39f:	48 8b 43 10          	mov    rax,QWORD PTR [rbx+0x10]
  21e3a3:	48 3b 03             	cmp    rax,QWORD PTR [rbx]
            if (lessThan(items[1], items[0])) mem.swap(T, &items[0], &items[1]);
  21e3a6:	73 26                	jae    21e3ce <Benchmark_reportStats+0x87ce>
    const tmp = a.*;
  21e3a8:	c5 f8 10 03          	vmovups xmm0,XMMWORD PTR [rbx]
  21e3ac:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  21e3b3:	00 00 
  21e3b5:	48 8d 43 10          	lea    rax,[rbx+0x10]
    a.* = b.*;
  21e3b9:	c5 f8 10 00          	vmovups xmm0,XMMWORD PTR [rax]
  21e3bd:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
    b.* = tmp;
  21e3c1:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  21e3c8:	00 00 
  21e3ca:	c5 fa 7f 00          	vmovdqu XMMWORD PTR [rax],xmm0
        var center = copy.len / 2;
  21e3ce:	48 8b 8c 24 b0 01 00 	mov    rcx,QWORD PTR [rsp+0x1b0]
  21e3d5:	00 
  21e3d6:	48 89 c8             	mov    rax,rcx
  21e3d9:	48 d1 e8             	shr    rax,1
        if ((copy.len & 1) == 1) {
  21e3dc:	f6 c1 01             	test   cl,0x1
  21e3df:	75 38                	jne    21e419 <Benchmark_reportStats+0x8819>
            median = @intToFloat(f64, copy.items[center-1].run_time_ns
  21e3e1:	48 8b 8c 24 a0 01 00 	mov    rcx,QWORD PTR [rsp+0x1a0]
  21e3e8:	00 
  21e3e9:	48 c1 e0 04          	shl    rax,0x4
                        + copy.items[center].run_time_ns) / 2;
  21e3ed:	48 8b 14 01          	mov    rdx,QWORD PTR [rcx+rax*1]
  21e3f1:	48 03 54 01 f0       	add    rdx,QWORD PTR [rcx+rax*1-0x10]
            median = @intToFloat(f64, copy.items[center-1].run_time_ns
  21e3f6:	c4 e1 f9 6e c2       	vmovq  xmm0,rdx
  21e3fb:	c5 f9 62 05 1d 1e fe 	vpunpckldq xmm0,xmm0,XMMWORD PTR [rip+0xfffffffffffe1e1d]        # 200220 <__unnamed_29+0x20>
  21e402:	ff 
  21e403:	c5 f9 5c 05 25 23 fe 	vsubpd xmm0,xmm0,XMMWORD PTR [rip+0xfffffffffffe2325]        # 200730 <__unnamed_55+0x10>
  21e40a:	ff 
  21e40b:	c5 f9 7c c0          	vhaddpd xmm0,xmm0,xmm0
                        + copy.items[center].run_time_ns) / 2;
  21e40f:	c5 fb 59 05 69 28 fe 	vmulsd xmm0,xmm0,QWORD PTR [rip+0xfffffffffffe2869]        # 200c80 <__unnamed_622+0x8>
  21e416:	ff 
  21e417:	eb 25                	jmp    21e43e <Benchmark_reportStats+0x883e>
            median = @intToFloat(f64, copy.items[center].run_time_ns);
  21e419:	48 8b 8c 24 a0 01 00 	mov    rcx,QWORD PTR [rsp+0x1a0]
  21e420:	00 
  21e421:	48 c1 e0 04          	shl    rax,0x4
  21e425:	c5 fb 10 04 01       	vmovsd xmm0,QWORD PTR [rcx+rax*1]
  21e42a:	c5 f8 14 05 ee 1d fe 	vunpcklps xmm0,xmm0,XMMWORD PTR [rip+0xfffffffffffe1dee]        # 200220 <__unnamed_29+0x20>
  21e431:	ff 
  21e432:	c5 f9 5c 05 f6 22 fe 	vsubpd xmm0,xmm0,XMMWORD PTR [rip+0xfffffffffffe22f6]        # 200730 <__unnamed_55+0x10>
  21e439:	ff 
  21e43a:	c5 f9 7c c0          	vhaddpd xmm0,xmm0,xmm0
  21e43e:	48 8b 9c 24 88 01 00 	mov    rbx,QWORD PTR [rsp+0x188]
  21e445:	00 
  21e446:	c5 fb 10 0d 72 28 fe 	vmovsd xmm1,QWORD PTR [rip+0xfffffffffffe2872]        # 200cc0 <__unnamed_621+0x8>
  21e44d:	ff 
  21e44e:	c5 f9 28 d1          	vmovapd xmm2,xmm1
            .run_time_ns = @floatToInt(u64, try pSelf.statsMedian(sum, results)),
  21e452:	c5 fb 5c ca          	vsubsd xmm1,xmm0,xmm2
  21e456:	c4 e1 fb 2c c1       	vcvttsd2si rax,xmm1
  21e45b:	48 b9 00 00 00 00 00 	movabs rcx,0x8000000000000000
  21e462:	00 00 80 
  21e465:	48 31 c8             	xor    rax,rcx
  21e468:	c4 e1 fb 2c c8       	vcvttsd2si rcx,xmm0
  21e46d:	c5 f9 2e c2          	vucomisd xmm0,xmm2
  21e471:	48 0f 43 c8          	cmovae rcx,rax
            .iterations = results.items[0].iterations}
  21e475:	48 8b 43 48          	mov    rax,QWORD PTR [rbx+0x48]
  21e479:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
        try pSelf.report(Result {
  21e47d:	48 89 8c 24 f8 01 00 	mov    QWORD PTR [rsp+0x1f8],rcx
  21e484:	00 
  21e485:	48 89 84 24 00 02 00 	mov    QWORD PTR [rsp+0x200],rax
  21e48c:	00 
  21e48d:	48 8d b4 24 f8 01 00 	lea    rsi,[rsp+0x1f8]
  21e494:	00 
  21e495:	48 89 df             	mov    rdi,rbx
  21e498:	c5 f8 77             	vzeroupper 
  21e49b:	e8 80 4a ff ff       	call   212f20 <Benchmark_report>
        try pSelf.reportStatsMedian(sum, pSelf.results); warn(" median\n");
  21e4a0:	66 85 c0             	test   ax,ax
  21e4a3:	0f 85 b4 02 00 00    	jne    21e75d <Benchmark_reportStats+0x8b5d>
  21e4a9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  21e4b0:	b0 01                	mov    al,0x1
  21e4b2:	86 05 58 2b 03 00    	xchg   BYTE PTR [rip+0x32b58],al        # 251010 <stderr_mutex>
  21e4b8:	84 c0                	test   al,al
  21e4ba:	75 f4                	jne    21e4b0 <Benchmark_reportStats+0x88b0>
    if (stderr_stream) |st| {
  21e4bc:	48 8b 3d 45 2b 03 00 	mov    rdi,QWORD PTR [rip+0x32b45]        # 251008 <stderr_stream>
  21e4c3:	48 85 ff             	test   rdi,rdi
  21e4c6:	74 09                	je     21e4d1 <Benchmark_reportStats+0x88d1>
  21e4c8:	48 8b 0d 71 db 02 00 	mov    rcx,QWORD PTR [rip+0x2db71]        # 24c040 <stderr_file_out_stream+0x8>
  21e4cf:	eb 34                	jmp    21e505 <Benchmark_reportStats+0x8905>
        stderr_file = try io.getStdErr();
  21e4d1:	48 8d 05 58 db 02 00 	lea    rax,[rip+0x2db58]        # 24c030 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  21e4d8:	48 89 05 59 db 02 00 	mov    QWORD PTR [rip+0x2db59],rax        # 24c038 <stderr_file_out_stream>
  21e4df:	48 8d 0d ba 09 00 00 	lea    rcx,[rip+0x9ba]        # 21eea0 <FileOutStream_writeFn>
  21e4e6:	48 89 0d 53 db 02 00 	mov    QWORD PTR [rip+0x2db53],rcx        # 24c040 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  21e4ed:	c7 05 39 db 02 00 02 	mov    DWORD PTR [rip+0x2db39],0x2        # 24c030 <stderr_file>
  21e4f4:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  21e4f7:	48 8d 3d 42 db 02 00 	lea    rdi,[rip+0x2db42]        # 24c040 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  21e4fe:	48 89 3d 03 2b 03 00 	mov    QWORD PTR [rip+0x32b03],rdi        # 251008 <stderr_stream>
  21e505:	48 8d 35 04 19 03 00 	lea    rsi,[rip+0x31904]        # 24fe10 <__unnamed_37>
  21e50c:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  21e50e:	31 c0                	xor    eax,eax
  21e510:	86 05 fa 2a 03 00    	xchg   BYTE PTR [rip+0x32afa],al        # 251010 <stderr_mutex>
  21e516:	3c 01                	cmp    al,0x1
    if (!ok) {
  21e518:	0f 85 4e 02 00 00    	jne    21e76c <Benchmark_reportStats+0x8b6c>
        if (results.len <= 1) {
  21e51e:	48 8b 7b 58          	mov    rdi,QWORD PTR [rbx+0x58]
  21e522:	48 83 ff 01          	cmp    rdi,0x1
  21e526:	c5 fb 10 8c 24 90 01 	vmovsd xmm1,QWORD PTR [rsp+0x190]
  21e52d:	00 00 
  21e52f:	77 0b                	ja     21e53c <Benchmark_reportStats+0x893c>
            .iterations = results.items[0].iterations}
  21e531:	48 8b 43 48          	mov    rax,QWORD PTR [rbx+0x48]
  21e535:	31 c9                	xor    ecx,ecx
  21e537:	e9 7d 01 00 00       	jmp    21e6b9 <Benchmark_reportStats+0x8ab9>
            return sum / @intToFloat(f64, results.len);
  21e53c:	c4 e1 f9 6e c7       	vmovq  xmm0,rdi
  21e541:	c5 f9 62 05 d7 1c fe 	vpunpckldq xmm0,xmm0,XMMWORD PTR [rip+0xfffffffffffe1cd7]        # 200220 <__unnamed_29+0x20>
  21e548:	ff 
  21e549:	c5 f9 5c 05 df 21 fe 	vsubpd xmm0,xmm0,XMMWORD PTR [rip+0xfffffffffffe21df]        # 200730 <__unnamed_55+0x10>
  21e550:	ff 
  21e551:	c5 f9 7c c0          	vhaddpd xmm0,xmm0,xmm0
  21e555:	c5 f3 5e c0          	vdivsd xmm0,xmm1,xmm0
  21e559:	49 89 d8             	mov    r8,rbx
  21e55c:	48 8b 43 48          	mov    rax,QWORD PTR [rbx+0x48]
            for (results.toSlice()) |result| {
  21e560:	48 8d 4f ff          	lea    rcx,[rdi-0x1]
  21e564:	89 fa                	mov    edx,edi
  21e566:	83 e2 03             	and    edx,0x3
  21e569:	48 83 f9 03          	cmp    rcx,0x3
  21e56d:	73 14                	jae    21e583 <Benchmark_reportStats+0x8983>
  21e56f:	c5 f1 57 c9          	vxorpd xmm1,xmm1,xmm1
  21e573:	31 f6                	xor    esi,esi
  21e575:	48 85 d2             	test   rdx,rdx
  21e578:	0f 85 a7 00 00 00    	jne    21e625 <Benchmark_reportStats+0x8a25>
  21e57e:	e9 e3 00 00 00       	jmp    21e666 <Benchmark_reportStats+0x8a66>
  21e583:	48 29 d7             	sub    rdi,rdx
  21e586:	48 8d 58 30          	lea    rbx,[rax+0x30]
  21e58a:	c5 f1 57 c9          	vxorpd xmm1,xmm1,xmm1
  21e58e:	31 f6                	xor    esi,esi
  21e590:	c5 f9 28 15 88 1c fe 	vmovapd xmm2,XMMWORD PTR [rip+0xfffffffffffe1c88]        # 200220 <__unnamed_29+0x20>
  21e597:	ff 
  21e598:	c5 f9 28 1d 90 21 fe 	vmovapd xmm3,XMMWORD PTR [rip+0xfffffffffffe2190]        # 200730 <__unnamed_55+0x10>
  21e59f:	ff 
                var diff = @intToFloat(f64, result.run_time_ns) - mean;
  21e5a0:	c5 fb 10 63 d0       	vmovsd xmm4,QWORD PTR [rbx-0x30]
  21e5a5:	c5 d8 14 e2          	vunpcklps xmm4,xmm4,xmm2
  21e5a9:	c5 d9 5c e3          	vsubpd xmm4,xmm4,xmm3
  21e5ad:	c5 d9 7c e4          	vhaddpd xmm4,xmm4,xmm4
  21e5b1:	c5 db 5c e0          	vsubsd xmm4,xmm4,xmm0
                var square = diff * diff;
  21e5b5:	c5 db 59 e4          	vmulsd xmm4,xmm4,xmm4
                sum_of_squares += square;
  21e5b9:	c5 f3 58 cc          	vaddsd xmm1,xmm1,xmm4
                var diff = @intToFloat(f64, result.run_time_ns) - mean;
  21e5bd:	c5 fb 10 63 e0       	vmovsd xmm4,QWORD PTR [rbx-0x20]
  21e5c2:	c5 d8 14 e2          	vunpcklps xmm4,xmm4,xmm2
  21e5c6:	c5 d9 5c e3          	vsubpd xmm4,xmm4,xmm3
  21e5ca:	c5 d9 7c e4          	vhaddpd xmm4,xmm4,xmm4
  21e5ce:	c5 db 5c e0          	vsubsd xmm4,xmm4,xmm0
                var square = diff * diff;
  21e5d2:	c5 db 59 e4          	vmulsd xmm4,xmm4,xmm4
                var diff = @intToFloat(f64, result.run_time_ns) - mean;
  21e5d6:	c5 fb 10 6b f0       	vmovsd xmm5,QWORD PTR [rbx-0x10]
  21e5db:	c5 d0 14 ea          	vunpcklps xmm5,xmm5,xmm2
  21e5df:	c5 d1 5c eb          	vsubpd xmm5,xmm5,xmm3
  21e5e3:	c5 d1 7c ed          	vhaddpd xmm5,xmm5,xmm5
                sum_of_squares += square;
  21e5e7:	c5 f3 58 cc          	vaddsd xmm1,xmm1,xmm4
                var diff = @intToFloat(f64, result.run_time_ns) - mean;
  21e5eb:	c5 d3 5c e0          	vsubsd xmm4,xmm5,xmm0
  21e5ef:	c5 fb 10 2b          	vmovsd xmm5,QWORD PTR [rbx]
  21e5f3:	c5 d0 14 ea          	vunpcklps xmm5,xmm5,xmm2
  21e5f7:	c5 d1 5c eb          	vsubpd xmm5,xmm5,xmm3
  21e5fb:	c5 d1 7c ed          	vhaddpd xmm5,xmm5,xmm5
                var square = diff * diff;
  21e5ff:	c5 db 59 e4          	vmulsd xmm4,xmm4,xmm4
                sum_of_squares += square;
  21e603:	c5 f3 58 cc          	vaddsd xmm1,xmm1,xmm4
                var diff = @intToFloat(f64, result.run_time_ns) - mean;
  21e607:	c5 d3 5c e0          	vsubsd xmm4,xmm5,xmm0
                var square = diff * diff;
  21e60b:	c5 db 59 e4          	vmulsd xmm4,xmm4,xmm4
                sum_of_squares += square;
  21e60f:	c5 f3 58 cc          	vaddsd xmm1,xmm1,xmm4
            for (results.toSlice()) |result| {
  21e613:	48 83 c6 04          	add    rsi,0x4
  21e617:	48 83 c3 40          	add    rbx,0x40
  21e61b:	48 39 f7             	cmp    rdi,rsi
  21e61e:	75 80                	jne    21e5a0 <Benchmark_reportStats+0x89a0>
  21e620:	48 85 d2             	test   rdx,rdx
  21e623:	74 41                	je     21e666 <Benchmark_reportStats+0x8a66>
  21e625:	48 c1 e6 04          	shl    rsi,0x4
  21e629:	48 01 c6             	add    rsi,rax
  21e62c:	48 f7 da             	neg    rdx
  21e62f:	c5 f9 28 15 e9 1b fe 	vmovapd xmm2,XMMWORD PTR [rip+0xfffffffffffe1be9]        # 200220 <__unnamed_29+0x20>
  21e636:	ff 
  21e637:	c5 f9 28 1d f1 20 fe 	vmovapd xmm3,XMMWORD PTR [rip+0xfffffffffffe20f1]        # 200730 <__unnamed_55+0x10>
  21e63e:	ff 
  21e63f:	90                   	nop
                var diff = @intToFloat(f64, result.run_time_ns) - mean;
  21e640:	c5 fb 10 26          	vmovsd xmm4,QWORD PTR [rsi]
  21e644:	c5 d8 14 e2          	vunpcklps xmm4,xmm4,xmm2
  21e648:	c5 d9 5c e3          	vsubpd xmm4,xmm4,xmm3
  21e64c:	c5 d9 7c e4          	vhaddpd xmm4,xmm4,xmm4
  21e650:	c5 db 5c e0          	vsubsd xmm4,xmm4,xmm0
                var square = diff * diff;
  21e654:	c5 db 59 e4          	vmulsd xmm4,xmm4,xmm4
                sum_of_squares += square;
  21e658:	c5 f3 58 cc          	vaddsd xmm1,xmm1,xmm4
            for (results.toSlice()) |result| {
  21e65c:	48 83 c6 10          	add    rsi,0x10
  21e660:	48 83 c2 01          	add    rdx,0x1
  21e664:	75 da                	jne    21e640 <Benchmark_reportStats+0x8a40>
            std_dev = @sqrt(f64, sum_of_squares / @intToFloat(f64, results.len - 1));
  21e666:	c4 e1 f9 6e c1       	vmovq  xmm0,rcx
  21e66b:	c5 f9 62 05 ad 1b fe 	vpunpckldq xmm0,xmm0,XMMWORD PTR [rip+0xfffffffffffe1bad]        # 200220 <__unnamed_29+0x20>
  21e672:	ff 
  21e673:	c5 f9 5c 05 b5 20 fe 	vsubpd xmm0,xmm0,XMMWORD PTR [rip+0xfffffffffffe20b5]        # 200730 <__unnamed_55+0x10>
  21e67a:	ff 
  21e67b:	c5 f9 7c c0          	vhaddpd xmm0,xmm0,xmm0
  21e67f:	c5 f3 5e c0          	vdivsd xmm0,xmm1,xmm0
  21e683:	c5 fb 51 c0          	vsqrtsd xmm0,xmm0,xmm0
  21e687:	c5 fb 10 0d 31 26 fe 	vmovsd xmm1,QWORD PTR [rip+0xfffffffffffe2631]        # 200cc0 <__unnamed_621+0x8>
  21e68e:	ff 
  21e68f:	c5 f9 28 d1          	vmovapd xmm2,xmm1
        if (results.len <= 1) {
  21e693:	c5 fb 5c ca          	vsubsd xmm1,xmm0,xmm2
  21e697:	c4 e1 fb 2c d1       	vcvttsd2si rdx,xmm1
  21e69c:	c4 e1 fb 2c c8       	vcvttsd2si rcx,xmm0
  21e6a1:	48 be 00 00 00 00 00 	movabs rsi,0x8000000000000000
  21e6a8:	00 00 80 
  21e6ab:	48 31 f2             	xor    rdx,rsi
  21e6ae:	c5 f9 2e c2          	vucomisd xmm0,xmm2
  21e6b2:	48 0f 43 ca          	cmovae rcx,rdx
  21e6b6:	4c 89 c3             	mov    rbx,r8
            .iterations = results.items[0].iterations}
  21e6b9:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
        try pSelf.report(Result {
  21e6bd:	48 89 8c 24 28 02 00 	mov    QWORD PTR [rsp+0x228],rcx
  21e6c4:	00 
  21e6c5:	48 89 84 24 30 02 00 	mov    QWORD PTR [rsp+0x230],rax
  21e6cc:	00 
  21e6cd:	48 8d b4 24 28 02 00 	lea    rsi,[rsp+0x228]
  21e6d4:	00 
  21e6d5:	48 89 df             	mov    rdi,rbx
  21e6d8:	e8 43 48 ff ff       	call   212f20 <Benchmark_report>
        try pSelf.reportStatsStdDev(sum, pSelf.results); warn(" stddev\n");
  21e6dd:	66 85 c0             	test   ax,ax
  21e6e0:	75 7b                	jne    21e75d <Benchmark_reportStats+0x8b5d>
  21e6e2:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21e6e9:	1f 84 00 00 00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  21e6f0:	b0 01                	mov    al,0x1
  21e6f2:	86 05 18 29 03 00    	xchg   BYTE PTR [rip+0x32918],al        # 251010 <stderr_mutex>
  21e6f8:	84 c0                	test   al,al
  21e6fa:	75 f4                	jne    21e6f0 <Benchmark_reportStats+0x8af0>
    if (stderr_stream) |st| {
  21e6fc:	48 8b 3d 05 29 03 00 	mov    rdi,QWORD PTR [rip+0x32905]        # 251008 <stderr_stream>
  21e703:	48 85 ff             	test   rdi,rdi
  21e706:	74 09                	je     21e711 <Benchmark_reportStats+0x8b11>
  21e708:	48 8b 0d 31 d9 02 00 	mov    rcx,QWORD PTR [rip+0x2d931]        # 24c040 <stderr_file_out_stream+0x8>
  21e70f:	eb 34                	jmp    21e745 <Benchmark_reportStats+0x8b45>
        stderr_file = try io.getStdErr();
  21e711:	48 8d 05 18 d9 02 00 	lea    rax,[rip+0x2d918]        # 24c030 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  21e718:	48 89 05 19 d9 02 00 	mov    QWORD PTR [rip+0x2d919],rax        # 24c038 <stderr_file_out_stream>
  21e71f:	48 8d 0d 7a 07 00 00 	lea    rcx,[rip+0x77a]        # 21eea0 <FileOutStream_writeFn>
  21e726:	48 89 0d 13 d9 02 00 	mov    QWORD PTR [rip+0x2d913],rcx        # 24c040 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  21e72d:	c7 05 f9 d8 02 00 02 	mov    DWORD PTR [rip+0x2d8f9],0x2        # 24c030 <stderr_file>
  21e734:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  21e737:	48 8d 3d 02 d9 02 00 	lea    rdi,[rip+0x2d902]        # 24c040 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  21e73e:	48 89 3d c3 28 03 00 	mov    QWORD PTR [rip+0x328c3],rdi        # 251008 <stderr_stream>
  21e745:	48 8d 35 d4 16 03 00 	lea    rsi,[rip+0x316d4]        # 24fe20 <__unnamed_38>
  21e74c:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  21e74e:	31 c9                	xor    ecx,ecx
  21e750:	86 0d ba 28 03 00    	xchg   BYTE PTR [rip+0x328ba],cl        # 251010 <stderr_mutex>
  21e756:	31 c0                	xor    eax,eax
  21e758:	80 f9 01             	cmp    cl,0x1
    if (!ok) {
  21e75b:	75 0f                	jne    21e76c <Benchmark_reportStats+0x8b6c>
        try pSelf.reportStatsMean(sum, pSelf.results); warn(" mean\n");
  21e75d:	48 8d 65 d8          	lea    rsp,[rbp-0x28]
  21e761:	5b                   	pop    rbx
  21e762:	41 5c                	pop    r12
  21e764:	41 5d                	pop    r13
  21e766:	41 5e                	pop    r14
  21e768:	41 5f                	pop    r15
  21e76a:	5d                   	pop    rbp
  21e76b:	c3                   	ret    
            @panic("assertion failure");
  21e76c:	48 8d 3d 1d 16 03 00 	lea    rdi,[rip+0x3161d]        # 24fd90 <__unnamed_2>
  21e773:	c5 f8 77             	vzeroupper 
  21e776:	e8 a5 3f ff ff       	call   212720 <panic>
  21e77b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

000000000021e780 <findLastForward>:
fn findLastForward(comptime T: type, items: []T, value: T, range: Range, lessThan: fn (T, T) bool, unique: usize) usize {
  21e780:	41 56                	push   r14
  21e782:	53                   	push   rbx
  21e783:	49 89 d1             	mov    r9,rdx
    if (range.length() == 0) return range.start;
  21e786:	48 89 c8             	mov    rax,rcx
  21e789:	4c 29 c8             	sub    rax,r9
  21e78c:	0f 84 eb 00 00 00    	je     21e87d <findLastForward+0xfd>
  21e792:	48 89 c2             	mov    rdx,rax
  21e795:	4c 09 c2             	or     rdx,r8
  21e798:	48 c1 ea 20          	shr    rdx,0x20
  21e79c:	74 07                	je     21e7a5 <findLastForward+0x25>
  21e79e:	31 d2                	xor    edx,edx
  21e7a0:	49 f7 f0             	div    r8
  21e7a3:	eb 05                	jmp    21e7aa <findLastForward+0x2a>
  21e7a5:	31 d2                	xor    edx,edx
  21e7a7:	41 f7 f0             	div    r8d
  21e7aa:	48 83 f8 01          	cmp    rax,0x1
  21e7ae:	41 ba 01 00 00 00    	mov    r10d,0x1
  21e7b4:	4c 0f 47 d0          	cmova  r10,rax
  21e7b8:	4b 8d 14 0a          	lea    rdx,[r10+r9*1]
    while (!lessThan(value, items[index - 1])) : (index += skip) {
  21e7bc:	4f 8d 5c 0a ff       	lea    r11,[r10+r9*1-0x1]
  21e7c1:	4c 8b 37             	mov    r14,QWORD PTR [rdi]
  21e7c4:	4c 8b 06             	mov    r8,QWORD PTR [rsi]
  21e7c7:	4c 89 d8             	mov    rax,r11
  21e7ca:	48 c1 e0 04          	shl    rax,0x4
  21e7ce:	49 8b 34 06          	mov    rsi,QWORD PTR [r14+rax*1]
            return lhs.run_time_ns < rhs.run_time_ns;
  21e7d2:	49 39 f0             	cmp    r8,rsi
  21e7d5:	73 10                	jae    21e7e7 <findLastForward+0x67>
  21e7d7:	4c 89 c8             	mov    rax,r9
  21e7da:	49 89 d1             	mov    r9,rdx
    if (range.start >= range.end) return range.end;
  21e7dd:	4d 85 d2             	test   r10,r10
  21e7e0:	75 3e                	jne    21e820 <findLastForward+0xa0>
  21e7e2:	e9 96 00 00 00       	jmp    21e87d <findLastForward+0xfd>
  21e7e7:	48 89 cf             	mov    rdi,rcx
  21e7ea:	4c 29 d7             	sub    rdi,r10
  21e7ed:	0f 1f 00             	nop    DWORD PTR [rax]
  21e7f0:	48 89 d0             	mov    rax,rdx
        if (index >= range.end - skip) {
  21e7f3:	48 39 f8             	cmp    rax,rdi
  21e7f6:	0f 83 88 00 00 00    	jae    21e884 <findLastForward+0x104>
  21e7fc:	4a 8d 14 10          	lea    rdx,[rax+r10*1]
    while (!lessThan(value, items[index - 1])) : (index += skip) {
  21e800:	4e 8d 1c 10          	lea    r11,[rax+r10*1]
  21e804:	49 83 c3 ff          	add    r11,0xffffffffffffffff
  21e808:	4c 89 de             	mov    rsi,r11
  21e80b:	48 c1 e6 04          	shl    rsi,0x4
  21e80f:	49 8b 34 36          	mov    rsi,QWORD PTR [r14+rsi*1]
  21e813:	49 39 f0             	cmp    r8,rsi
  21e816:	73 d8                	jae    21e7f0 <findLastForward+0x70>
  21e818:	49 89 d1             	mov    r9,rdx
    if (range.start >= range.end) return range.end;
  21e81b:	4d 85 d2             	test   r10,r10
  21e81e:	74 5d                	je     21e87d <findLastForward+0xfd>
    while (start < end) {
  21e820:	49 39 c3             	cmp    r11,rax
  21e823:	76 43                	jbe    21e868 <findLastForward+0xe8>
  21e825:	4c 89 d9             	mov    rcx,r11
  21e828:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  21e82f:	00 
        const mid = start + (end - start) / 2;
  21e830:	48 89 ca             	mov    rdx,rcx
  21e833:	48 29 c2             	sub    rdx,rax
  21e836:	48 d1 ea             	shr    rdx,1
  21e839:	48 8d 1c 02          	lea    rbx,[rdx+rax*1]
  21e83d:	48 89 df             	mov    rdi,rbx
  21e840:	48 c1 e7 04          	shl    rdi,0x4
  21e844:	4d 3b 04 3e          	cmp    r8,QWORD PTR [r14+rdi*1]
        if (!lessThan(value, items[mid])) {
  21e848:	72 16                	jb     21e860 <findLastForward+0xe0>
  21e84a:	48 01 d0             	add    rax,rdx
  21e84d:	48 83 c0 01          	add    rax,0x1
    while (start < end) {
  21e851:	48 39 c1             	cmp    rcx,rax
  21e854:	77 da                	ja     21e830 <findLastForward+0xb0>
  21e856:	eb 10                	jmp    21e868 <findLastForward+0xe8>
  21e858:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  21e85f:	00 
        if (!lessThan(value, items[mid])) {
  21e860:	48 89 d9             	mov    rcx,rbx
    while (start < end) {
  21e863:	48 39 c1             	cmp    rcx,rax
  21e866:	77 c8                	ja     21e830 <findLastForward+0xb0>
    if (start == range.end - 1 and !lessThan(value, items[start])) {
  21e868:	4c 39 d8             	cmp    rax,r11
  21e86b:	0f 94 c1             	sete   cl
  21e86e:	49 39 f0             	cmp    r8,rsi
  21e871:	0f 93 c2             	setae  dl
  21e874:	20 ca                	and    dl,cl
  21e876:	44 0f b6 ca          	movzx  r9d,dl
  21e87a:	49 01 c1             	add    r9,rax
    if (range.length() == 0) return range.start;
  21e87d:	4c 89 c8             	mov    rax,r9
  21e880:	5b                   	pop    rbx
  21e881:	41 5e                	pop    r14
  21e883:	c3                   	ret    
    if (range.start >= range.end) return range.end;
  21e884:	48 39 c8             	cmp    rax,rcx
  21e887:	73 65                	jae    21e8ee <findLastForward+0x16e>
    var end = range.end - 1;
  21e889:	48 83 c1 ff          	add    rcx,0xffffffffffffffff
    while (start < end) {
  21e88d:	48 39 c1             	cmp    rcx,rax
  21e890:	76 46                	jbe    21e8d8 <findLastForward+0x158>
  21e892:	49 89 c9             	mov    r9,rcx
  21e895:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21e89c:	00 00 00 00 
        const mid = start + (end - start) / 2;
  21e8a0:	4c 89 ce             	mov    rsi,r9
  21e8a3:	48 29 c6             	sub    rsi,rax
  21e8a6:	48 d1 ee             	shr    rsi,1
  21e8a9:	48 8d 14 06          	lea    rdx,[rsi+rax*1]
  21e8ad:	48 89 d7             	mov    rdi,rdx
  21e8b0:	48 c1 e7 04          	shl    rdi,0x4
  21e8b4:	4d 3b 04 3e          	cmp    r8,QWORD PTR [r14+rdi*1]
        if (!lessThan(value, items[mid])) {
  21e8b8:	72 16                	jb     21e8d0 <findLastForward+0x150>
  21e8ba:	48 01 f0             	add    rax,rsi
  21e8bd:	48 83 c0 01          	add    rax,0x1
    while (start < end) {
  21e8c1:	49 39 c1             	cmp    r9,rax
  21e8c4:	77 da                	ja     21e8a0 <findLastForward+0x120>
  21e8c6:	eb 10                	jmp    21e8d8 <findLastForward+0x158>
  21e8c8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  21e8cf:	00 
        if (!lessThan(value, items[mid])) {
  21e8d0:	49 89 d1             	mov    r9,rdx
    while (start < end) {
  21e8d3:	49 39 c1             	cmp    r9,rax
  21e8d6:	77 c8                	ja     21e8a0 <findLastForward+0x120>
    if (start == range.end - 1 and !lessThan(value, items[start])) {
  21e8d8:	48 39 c8             	cmp    rax,rcx
  21e8db:	75 1b                	jne    21e8f8 <findLastForward+0x178>
  21e8dd:	48 c1 e1 04          	shl    rcx,0x4
  21e8e1:	45 31 c9             	xor    r9d,r9d
  21e8e4:	4d 3b 04 0e          	cmp    r8,QWORD PTR [r14+rcx*1]
  21e8e8:	41 0f 93 c1          	setae  r9b
  21e8ec:	eb 8c                	jmp    21e87a <findLastForward+0xfa>
  21e8ee:	49 89 c9             	mov    r9,rcx
    if (range.length() == 0) return range.start;
  21e8f1:	4c 89 c8             	mov    rax,r9
  21e8f4:	5b                   	pop    rbx
  21e8f5:	41 5e                	pop    r14
  21e8f7:	c3                   	ret    
  21e8f8:	45 31 c9             	xor    r9d,r9d
  21e8fb:	e9 7a ff ff ff       	jmp    21e87a <findLastForward+0xfa>

000000000021e900 <mergeInPlace>:
fn mergeInPlace(comptime T: type, items: []T, A_arg: Range, B_arg: Range, lessThan: fn (T, T) bool) void {
  21e900:	55                   	push   rbp
  21e901:	41 57                	push   r15
  21e903:	41 56                	push   r14
  21e905:	41 55                	push   r13
  21e907:	41 54                	push   r12
  21e909:	53                   	push   rbx
  21e90a:	48 89 7c 24 f0       	mov    QWORD PTR [rsp-0x10],rdi
  21e90f:	4c 8b 3e             	mov    r15,QWORD PTR [rsi]
  21e912:	4c 8b 76 08          	mov    r14,QWORD PTR [rsi+0x8]
    if (A_arg.length() == 0 or B_arg.length() == 0) return;
  21e916:	4d 39 fe             	cmp    r14,r15
  21e919:	0f 84 76 05 00 00    	je     21ee95 <mergeInPlace+0x595>
  21e91f:	48 8b 0a             	mov    rcx,QWORD PTR [rdx]
  21e922:	4c 8b 4a 08          	mov    r9,QWORD PTR [rdx+0x8]
  21e926:	49 39 c9             	cmp    r9,rcx
  21e929:	0f 84 66 05 00 00    	je     21ee95 <mergeInPlace+0x595>
  21e92f:	49 8d 41 ff          	lea    rax,[r9-0x1]
        const mid = binaryFirst(T, items, items[A.start], B, lessThan);
  21e933:	48 89 44 24 f8       	mov    QWORD PTR [rsp-0x8],rax
  21e938:	48 8b 44 24 f0       	mov    rax,QWORD PTR [rsp-0x10]
  21e93d:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  21e940:	4d 89 fa             	mov    r10,r15
  21e943:	49 c1 e2 04          	shl    r10,0x4
  21e947:	4e 8d 1c 12          	lea    r11,[rdx+r10*1]
  21e94b:	4d 89 cc             	mov    r12,r9
    if (range.start >= range.end) return range.end;
  21e94e:	4c 39 c9             	cmp    rcx,r9
  21e951:	0f 83 7f 00 00 00    	jae    21e9d6 <mergeInPlace+0xd6>
  21e957:	4c 8b 44 24 f8       	mov    r8,QWORD PTR [rsp-0x8]
    while (start < end) {
  21e95c:	49 39 c8             	cmp    r8,rcx
  21e95f:	76 4b                	jbe    21e9ac <mergeInPlace+0xac>
  21e961:	49 8b 03             	mov    rax,QWORD PTR [r11]
  21e964:	4c 89 c5             	mov    rbp,r8
  21e967:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  21e96e:	00 00 
        const mid = start + (end - start) / 2;
  21e970:	48 89 ee             	mov    rsi,rbp
  21e973:	48 29 ce             	sub    rsi,rcx
  21e976:	48 d1 ee             	shr    rsi,1
  21e979:	48 8d 1c 0e          	lea    rbx,[rsi+rcx*1]
  21e97d:	48 89 df             	mov    rdi,rbx
  21e980:	48 c1 e7 04          	shl    rdi,0x4
  21e984:	48 39 04 3a          	cmp    QWORD PTR [rdx+rdi*1],rax
        if (lessThan(items[mid], value)) {
  21e988:	72 16                	jb     21e9a0 <mergeInPlace+0xa0>
  21e98a:	48 89 dd             	mov    rbp,rbx
    while (start < end) {
  21e98d:	48 39 cd             	cmp    rbp,rcx
  21e990:	77 de                	ja     21e970 <mergeInPlace+0x70>
  21e992:	eb 18                	jmp    21e9ac <mergeInPlace+0xac>
  21e994:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21e99b:	00 00 00 00 00 
  21e9a0:	48 01 f1             	add    rcx,rsi
  21e9a3:	48 83 c1 01          	add    rcx,0x1
  21e9a7:	48 39 cd             	cmp    rbp,rcx
  21e9aa:	77 c4                	ja     21e970 <mergeInPlace+0x70>
    if (start == range.end - 1 and lessThan(items[start], value)) {
  21e9ac:	4c 39 c1             	cmp    rcx,r8
  21e9af:	75 1f                	jne    21e9d0 <mergeInPlace+0xd0>
  21e9b1:	4c 89 c0             	mov    rax,r8
  21e9b4:	48 c1 e0 04          	shl    rax,0x4
  21e9b8:	48 8b 04 02          	mov    rax,QWORD PTR [rdx+rax*1]
  21e9bc:	45 31 e4             	xor    r12d,r12d
  21e9bf:	49 3b 03             	cmp    rax,QWORD PTR [r11]
  21e9c2:	41 0f 92 c4          	setb   r12b
  21e9c6:	eb 0b                	jmp    21e9d3 <mergeInPlace+0xd3>
  21e9c8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  21e9cf:	00 
  21e9d0:	45 31 e4             	xor    r12d,r12d
  21e9d3:	49 01 cc             	add    r12,rcx
        mem.rotate(T, items[A.start..mid], A.length());
  21e9d6:	4d 89 e5             	mov    r13,r12
  21e9d9:	4d 29 fd             	sub    r13,r15
        return self.end - self.start;
  21e9dc:	4c 89 f3             	mov    rbx,r14
  21e9df:	4c 29 fb             	sub    rbx,r15
    const end = items.len / 2;
  21e9e2:	48 89 de             	mov    rsi,rbx
  21e9e5:	48 d1 ee             	shr    rsi,1
    while (i < end) : (i += 1) {
  21e9e8:	0f 84 2c 01 00 00    	je     21eb1a <mergeInPlace+0x21a>
        swap(T, &items[i], &items[items.len - i - 1]);
  21e9ee:	48 8d 46 ff          	lea    rax,[rsi-0x1]
  21e9f2:	89 f1                	mov    ecx,esi
  21e9f4:	83 e1 03             	and    ecx,0x3
  21e9f7:	48 83 f8 03          	cmp    rax,0x3
  21e9fb:	73 13                	jae    21ea10 <mergeInPlace+0x110>
  21e9fd:	31 c0                	xor    eax,eax
    while (i < end) : (i += 1) {
  21e9ff:	48 85 c9             	test   rcx,rcx
  21ea02:	0f 85 c8 00 00 00    	jne    21ead0 <mergeInPlace+0x1d0>
  21ea08:	e9 0d 01 00 00       	jmp    21eb1a <mergeInPlace+0x21a>
  21ea0d:	0f 1f 00             	nop    DWORD PTR [rax]
        swap(T, &items[i], &items[items.len - i - 1]);
  21ea10:	48 29 ce             	sub    rsi,rcx
  21ea13:	4a 8d 2c 12          	lea    rbp,[rdx+r10*1]
  21ea17:	48 83 c5 30          	add    rbp,0x30
  21ea1b:	4c 89 f0             	mov    rax,r14
  21ea1e:	48 c1 e0 04          	shl    rax,0x4
  21ea22:	4c 8d 04 02          	lea    r8,[rdx+rax*1]
  21ea26:	49 83 c0 f0          	add    r8,0xfffffffffffffff0
  21ea2a:	31 c0                	xor    eax,eax
  21ea2c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
    const tmp = a.*;
  21ea30:	c5 f8 10 45 d0       	vmovups xmm0,XMMWORD PTR [rbp-0x30]
  21ea35:	c5 f8 29 44 24 d8    	vmovaps XMMWORD PTR [rsp-0x28],xmm0
    a.* = b.*;
  21ea3b:	c4 c1 78 10 00       	vmovups xmm0,XMMWORD PTR [r8]
  21ea40:	c5 f8 11 45 d0       	vmovups XMMWORD PTR [rbp-0x30],xmm0
    b.* = tmp;
  21ea45:	c5 f8 28 44 24 d8    	vmovaps xmm0,XMMWORD PTR [rsp-0x28]
  21ea4b:	c4 c1 78 11 00       	vmovups XMMWORD PTR [r8],xmm0
    const tmp = a.*;
  21ea50:	c5 f8 10 45 e0       	vmovups xmm0,XMMWORD PTR [rbp-0x20]
  21ea55:	c5 f8 29 44 24 d8    	vmovaps XMMWORD PTR [rsp-0x28],xmm0
    a.* = b.*;
  21ea5b:	c4 c1 78 10 40 f0    	vmovups xmm0,XMMWORD PTR [r8-0x10]
  21ea61:	c5 f8 11 45 e0       	vmovups XMMWORD PTR [rbp-0x20],xmm0
    b.* = tmp;
  21ea66:	c5 f8 28 44 24 d8    	vmovaps xmm0,XMMWORD PTR [rsp-0x28]
  21ea6c:	c4 c1 78 11 40 f0    	vmovups XMMWORD PTR [r8-0x10],xmm0
    const tmp = a.*;
  21ea72:	c5 f8 10 45 f0       	vmovups xmm0,XMMWORD PTR [rbp-0x10]
  21ea77:	c5 f8 29 44 24 d8    	vmovaps XMMWORD PTR [rsp-0x28],xmm0
    a.* = b.*;
  21ea7d:	c4 c1 78 10 40 e0    	vmovups xmm0,XMMWORD PTR [r8-0x20]
  21ea83:	c5 f8 11 45 f0       	vmovups XMMWORD PTR [rbp-0x10],xmm0
    b.* = tmp;
  21ea88:	c5 f8 28 44 24 d8    	vmovaps xmm0,XMMWORD PTR [rsp-0x28]
  21ea8e:	c4 c1 78 11 40 e0    	vmovups XMMWORD PTR [r8-0x20],xmm0
    const tmp = a.*;
  21ea94:	c5 f8 10 45 00       	vmovups xmm0,XMMWORD PTR [rbp+0x0]
  21ea99:	c5 f8 29 44 24 d8    	vmovaps XMMWORD PTR [rsp-0x28],xmm0
    a.* = b.*;
  21ea9f:	c4 c1 78 10 40 d0    	vmovups xmm0,XMMWORD PTR [r8-0x30]
  21eaa5:	c5 f8 11 45 00       	vmovups XMMWORD PTR [rbp+0x0],xmm0
    b.* = tmp;
  21eaaa:	c5 f8 28 44 24 d8    	vmovaps xmm0,XMMWORD PTR [rsp-0x28]
  21eab0:	c4 c1 78 11 40 d0    	vmovups XMMWORD PTR [r8-0x30],xmm0
    while (i < end) : (i += 1) {
  21eab6:	48 83 c0 04          	add    rax,0x4
  21eaba:	48 83 c5 40          	add    rbp,0x40
  21eabe:	49 83 c0 c0          	add    r8,0xffffffffffffffc0
  21eac2:	48 39 c6             	cmp    rsi,rax
  21eac5:	0f 85 65 ff ff ff    	jne    21ea30 <mergeInPlace+0x130>
  21eacb:	48 85 c9             	test   rcx,rcx
  21eace:	74 4a                	je     21eb1a <mergeInPlace+0x21a>
  21ead0:	4c 89 f6             	mov    rsi,r14
  21ead3:	48 29 c6             	sub    rsi,rax
  21ead6:	48 c1 e6 04          	shl    rsi,0x4
  21eada:	48 01 d6             	add    rsi,rdx
  21eadd:	48 83 c6 f0          	add    rsi,0xfffffffffffffff0
  21eae1:	4c 01 f8             	add    rax,r15
  21eae4:	48 c1 e0 04          	shl    rax,0x4
  21eae8:	48 01 d0             	add    rax,rdx
  21eaeb:	48 f7 d9             	neg    rcx
  21eaee:	66 90                	xchg   ax,ax
    const tmp = a.*;
  21eaf0:	c5 f8 10 00          	vmovups xmm0,XMMWORD PTR [rax]
  21eaf4:	c5 f8 29 44 24 d8    	vmovaps XMMWORD PTR [rsp-0x28],xmm0
    a.* = b.*;
  21eafa:	c5 f8 10 06          	vmovups xmm0,XMMWORD PTR [rsi]
  21eafe:	c5 f8 11 00          	vmovups XMMWORD PTR [rax],xmm0
    b.* = tmp;
  21eb02:	c5 f8 28 44 24 d8    	vmovaps xmm0,XMMWORD PTR [rsp-0x28]
  21eb08:	c5 f8 11 06          	vmovups XMMWORD PTR [rsi],xmm0
    while (i < end) : (i += 1) {
  21eb0c:	48 83 c6 f0          	add    rsi,0xfffffffffffffff0
  21eb10:	48 83 c0 10          	add    rax,0x10
  21eb14:	48 83 c1 01          	add    rcx,0x1
  21eb18:	75 d6                	jne    21eaf0 <mergeInPlace+0x1f0>
    reverse(T, items[amount..]);
  21eb1a:	4c 89 e9             	mov    rcx,r13
  21eb1d:	48 29 d9             	sub    rcx,rbx
    const end = items.len / 2;
  21eb20:	48 d1 e9             	shr    rcx,1
    while (i < end) : (i += 1) {
  21eb23:	0f 84 41 01 00 00    	je     21ec6a <mergeInPlace+0x36a>
        swap(T, &items[i], &items[items.len - i - 1]);
  21eb29:	48 8d 41 ff          	lea    rax,[rcx-0x1]
  21eb2d:	89 ce                	mov    esi,ecx
  21eb2f:	83 e6 03             	and    esi,0x3
  21eb32:	48 83 f8 03          	cmp    rax,0x3
  21eb36:	73 18                	jae    21eb50 <mergeInPlace+0x250>
  21eb38:	31 c0                	xor    eax,eax
    while (i < end) : (i += 1) {
  21eb3a:	48 85 f6             	test   rsi,rsi
  21eb3d:	0f 85 d5 00 00 00    	jne    21ec18 <mergeInPlace+0x318>
  21eb43:	e9 22 01 00 00       	jmp    21ec6a <mergeInPlace+0x36a>
  21eb48:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  21eb4f:	00 
        swap(T, &items[i], &items[items.len - i - 1]);
  21eb50:	48 29 f1             	sub    rcx,rsi
  21eb53:	4c 89 f0             	mov    rax,r14
  21eb56:	48 c1 e0 04          	shl    rax,0x4
  21eb5a:	48 8d 1c 02          	lea    rbx,[rdx+rax*1]
  21eb5e:	48 83 c3 30          	add    rbx,0x30
  21eb62:	4c 89 e0             	mov    rax,r12
  21eb65:	48 c1 e0 04          	shl    rax,0x4
  21eb69:	48 8d 2c 02          	lea    rbp,[rdx+rax*1]
  21eb6d:	48 83 c5 f0          	add    rbp,0xfffffffffffffff0
  21eb71:	31 c0                	xor    eax,eax
  21eb73:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21eb7a:	84 00 00 00 00 00 
    const tmp = a.*;
  21eb80:	c5 f8 10 43 d0       	vmovups xmm0,XMMWORD PTR [rbx-0x30]
  21eb85:	c5 f8 29 44 24 d8    	vmovaps XMMWORD PTR [rsp-0x28],xmm0
    a.* = b.*;
  21eb8b:	c5 f8 10 45 00       	vmovups xmm0,XMMWORD PTR [rbp+0x0]
  21eb90:	c5 f8 11 43 d0       	vmovups XMMWORD PTR [rbx-0x30],xmm0
    b.* = tmp;
  21eb95:	c5 f8 28 44 24 d8    	vmovaps xmm0,XMMWORD PTR [rsp-0x28]
  21eb9b:	c5 f8 11 45 00       	vmovups XMMWORD PTR [rbp+0x0],xmm0
    const tmp = a.*;
  21eba0:	c5 f8 10 43 e0       	vmovups xmm0,XMMWORD PTR [rbx-0x20]
  21eba5:	c5 f8 29 44 24 d8    	vmovaps XMMWORD PTR [rsp-0x28],xmm0
    a.* = b.*;
  21ebab:	c5 f8 10 45 f0       	vmovups xmm0,XMMWORD PTR [rbp-0x10]
  21ebb0:	c5 f8 11 43 e0       	vmovups XMMWORD PTR [rbx-0x20],xmm0
    b.* = tmp;
  21ebb5:	c5 f8 28 44 24 d8    	vmovaps xmm0,XMMWORD PTR [rsp-0x28]
  21ebbb:	c5 f8 11 45 f0       	vmovups XMMWORD PTR [rbp-0x10],xmm0
    const tmp = a.*;
  21ebc0:	c5 f8 10 43 f0       	vmovups xmm0,XMMWORD PTR [rbx-0x10]
  21ebc5:	c5 f8 29 44 24 d8    	vmovaps XMMWORD PTR [rsp-0x28],xmm0
    a.* = b.*;
  21ebcb:	c5 f8 10 45 e0       	vmovups xmm0,XMMWORD PTR [rbp-0x20]
  21ebd0:	c5 f8 11 43 f0       	vmovups XMMWORD PTR [rbx-0x10],xmm0
    b.* = tmp;
  21ebd5:	c5 f8 28 44 24 d8    	vmovaps xmm0,XMMWORD PTR [rsp-0x28]
  21ebdb:	c5 f8 11 45 e0       	vmovups XMMWORD PTR [rbp-0x20],xmm0
    const tmp = a.*;
  21ebe0:	c5 f8 10 03          	vmovups xmm0,XMMWORD PTR [rbx]
  21ebe4:	c5 f8 29 44 24 d8    	vmovaps XMMWORD PTR [rsp-0x28],xmm0
    a.* = b.*;
  21ebea:	c5 f8 10 45 d0       	vmovups xmm0,XMMWORD PTR [rbp-0x30]
  21ebef:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
    b.* = tmp;
  21ebf3:	c5 f8 28 44 24 d8    	vmovaps xmm0,XMMWORD PTR [rsp-0x28]
  21ebf9:	c5 f8 11 45 d0       	vmovups XMMWORD PTR [rbp-0x30],xmm0
    while (i < end) : (i += 1) {
  21ebfe:	48 83 c0 04          	add    rax,0x4
  21ec02:	48 83 c3 40          	add    rbx,0x40
  21ec06:	48 83 c5 c0          	add    rbp,0xffffffffffffffc0
  21ec0a:	48 39 c1             	cmp    rcx,rax
  21ec0d:	0f 85 6d ff ff ff    	jne    21eb80 <mergeInPlace+0x280>
  21ec13:	48 85 f6             	test   rsi,rsi
  21ec16:	74 52                	je     21ec6a <mergeInPlace+0x36a>
  21ec18:	4c 89 e1             	mov    rcx,r12
  21ec1b:	48 29 c1             	sub    rcx,rax
  21ec1e:	48 c1 e1 04          	shl    rcx,0x4
  21ec22:	48 01 d1             	add    rcx,rdx
  21ec25:	48 83 c1 f0          	add    rcx,0xfffffffffffffff0
  21ec29:	4c 01 f0             	add    rax,r14
  21ec2c:	48 c1 e0 04          	shl    rax,0x4
  21ec30:	48 01 d0             	add    rax,rdx
  21ec33:	48 f7 de             	neg    rsi
  21ec36:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  21ec3d:	00 00 00 
    const tmp = a.*;
  21ec40:	c5 f8 10 00          	vmovups xmm0,XMMWORD PTR [rax]
  21ec44:	c5 f8 29 44 24 d8    	vmovaps XMMWORD PTR [rsp-0x28],xmm0
    a.* = b.*;
  21ec4a:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  21ec4e:	c5 f8 11 00          	vmovups XMMWORD PTR [rax],xmm0
    b.* = tmp;
  21ec52:	c5 f8 28 44 24 d8    	vmovaps xmm0,XMMWORD PTR [rsp-0x28]
  21ec58:	c5 f8 11 01          	vmovups XMMWORD PTR [rcx],xmm0
    while (i < end) : (i += 1) {
  21ec5c:	48 83 c1 f0          	add    rcx,0xfffffffffffffff0
  21ec60:	48 83 c0 10          	add    rax,0x10
  21ec64:	48 83 c6 01          	add    rsi,0x1
  21ec68:	75 d6                	jne    21ec40 <mergeInPlace+0x340>
    const end = items.len / 2;
  21ec6a:	4c 89 e9             	mov    rcx,r13
  21ec6d:	48 d1 e9             	shr    rcx,1
    while (i < end) : (i += 1) {
  21ec70:	0f 84 6a 01 00 00    	je     21ede0 <mergeInPlace+0x4e0>
    const tmp = a.*;
  21ec76:	c4 c1 78 10 03       	vmovups xmm0,XMMWORD PTR [r11]
  21ec7b:	c5 f8 29 44 24 d8    	vmovaps XMMWORD PTR [rsp-0x28],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  21ec81:	49 c1 e5 04          	shl    r13,0x4
    a.* = b.*;
  21ec85:	c4 81 78 10 44 2b f0 	vmovups xmm0,XMMWORD PTR [r11+r13*1-0x10]
  21ec8c:	c4 c1 78 11 03       	vmovups XMMWORD PTR [r11],xmm0
    b.* = tmp;
  21ec91:	c5 f8 28 44 24 d8    	vmovaps xmm0,XMMWORD PTR [rsp-0x28]
  21ec97:	c4 81 78 11 44 2b f0 	vmovups XMMWORD PTR [r11+r13*1-0x10],xmm0
    while (i < end) : (i += 1) {
  21ec9e:	48 83 f9 01          	cmp    rcx,0x1
  21eca2:	0f 84 38 01 00 00    	je     21ede0 <mergeInPlace+0x4e0>
        swap(T, &items[i], &items[items.len - i - 1]);
  21eca8:	8d 71 ff             	lea    esi,[rcx-0x1]
  21ecab:	48 8d 41 fe          	lea    rax,[rcx-0x2]
  21ecaf:	83 e6 03             	and    esi,0x3
  21ecb2:	48 83 f8 03          	cmp    rax,0x3
  21ecb6:	73 13                	jae    21eccb <mergeInPlace+0x3cb>
  21ecb8:	b8 01 00 00 00       	mov    eax,0x1
    while (i < end) : (i += 1) {
  21ecbd:	48 85 f6             	test   rsi,rsi
  21ecc0:	0f 85 c2 00 00 00    	jne    21ed88 <mergeInPlace+0x488>
  21ecc6:	e9 15 01 00 00       	jmp    21ede0 <mergeInPlace+0x4e0>
        swap(T, &items[i], &items[items.len - i - 1]);
  21eccb:	4c 89 e0             	mov    rax,r12
  21ecce:	48 c1 e0 04          	shl    rax,0x4
  21ecd2:	48 8d 2c 02          	lea    rbp,[rdx+rax*1]
  21ecd6:	48 83 c5 e0          	add    rbp,0xffffffffffffffe0
  21ecda:	4a 8d 1c 12          	lea    rbx,[rdx+r10*1]
  21ecde:	48 83 c3 40          	add    rbx,0x40
  21ece2:	48 29 f1             	sub    rcx,rsi
  21ece5:	b8 01 00 00 00       	mov    eax,0x1
  21ecea:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
    const tmp = a.*;
  21ecf0:	c5 f8 10 43 d0       	vmovups xmm0,XMMWORD PTR [rbx-0x30]
  21ecf5:	c5 f8 29 44 24 d8    	vmovaps XMMWORD PTR [rsp-0x28],xmm0
    a.* = b.*;
  21ecfb:	c5 f8 10 45 00       	vmovups xmm0,XMMWORD PTR [rbp+0x0]
  21ed00:	c5 f8 11 43 d0       	vmovups XMMWORD PTR [rbx-0x30],xmm0
    b.* = tmp;
  21ed05:	c5 f8 28 44 24 d8    	vmovaps xmm0,XMMWORD PTR [rsp-0x28]
  21ed0b:	c5 f8 11 45 00       	vmovups XMMWORD PTR [rbp+0x0],xmm0
    const tmp = a.*;
  21ed10:	c5 f8 10 43 e0       	vmovups xmm0,XMMWORD PTR [rbx-0x20]
  21ed15:	c5 f8 29 44 24 d8    	vmovaps XMMWORD PTR [rsp-0x28],xmm0
    a.* = b.*;
  21ed1b:	c5 f8 10 45 f0       	vmovups xmm0,XMMWORD PTR [rbp-0x10]
  21ed20:	c5 f8 11 43 e0       	vmovups XMMWORD PTR [rbx-0x20],xmm0
    b.* = tmp;
  21ed25:	c5 f8 28 44 24 d8    	vmovaps xmm0,XMMWORD PTR [rsp-0x28]
  21ed2b:	c5 f8 11 45 f0       	vmovups XMMWORD PTR [rbp-0x10],xmm0
    const tmp = a.*;
  21ed30:	c5 f8 10 43 f0       	vmovups xmm0,XMMWORD PTR [rbx-0x10]
  21ed35:	c5 f8 29 44 24 d8    	vmovaps XMMWORD PTR [rsp-0x28],xmm0
    a.* = b.*;
  21ed3b:	c5 f8 10 45 e0       	vmovups xmm0,XMMWORD PTR [rbp-0x20]
  21ed40:	c5 f8 11 43 f0       	vmovups XMMWORD PTR [rbx-0x10],xmm0
    b.* = tmp;
  21ed45:	c5 f8 28 44 24 d8    	vmovaps xmm0,XMMWORD PTR [rsp-0x28]
  21ed4b:	c5 f8 11 45 e0       	vmovups XMMWORD PTR [rbp-0x20],xmm0
    const tmp = a.*;
  21ed50:	c5 f8 10 03          	vmovups xmm0,XMMWORD PTR [rbx]
  21ed54:	c5 f8 29 44 24 d8    	vmovaps XMMWORD PTR [rsp-0x28],xmm0
    a.* = b.*;
  21ed5a:	c5 f8 10 45 d0       	vmovups xmm0,XMMWORD PTR [rbp-0x30]
  21ed5f:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
    b.* = tmp;
  21ed63:	c5 f8 28 44 24 d8    	vmovaps xmm0,XMMWORD PTR [rsp-0x28]
  21ed69:	c5 f8 11 45 d0       	vmovups XMMWORD PTR [rbp-0x30],xmm0
    while (i < end) : (i += 1) {
  21ed6e:	48 83 c0 04          	add    rax,0x4
  21ed72:	48 83 c5 c0          	add    rbp,0xffffffffffffffc0
  21ed76:	48 83 c3 40          	add    rbx,0x40
  21ed7a:	48 39 c1             	cmp    rcx,rax
  21ed7d:	0f 85 6d ff ff ff    	jne    21ecf0 <mergeInPlace+0x3f0>
  21ed83:	48 85 f6             	test   rsi,rsi
  21ed86:	74 58                	je     21ede0 <mergeInPlace+0x4e0>
  21ed88:	4c 89 e1             	mov    rcx,r12
  21ed8b:	48 29 c1             	sub    rcx,rax
  21ed8e:	48 c1 e1 04          	shl    rcx,0x4
  21ed92:	48 01 d1             	add    rcx,rdx
  21ed95:	48 83 c1 f0          	add    rcx,0xfffffffffffffff0
  21ed99:	4c 01 f8             	add    rax,r15
  21ed9c:	48 c1 e0 04          	shl    rax,0x4
  21eda0:	48 01 d0             	add    rax,rdx
  21eda3:	48 f7 de             	neg    rsi
  21eda6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  21edad:	00 00 00 
    const tmp = a.*;
  21edb0:	c5 f8 10 00          	vmovups xmm0,XMMWORD PTR [rax]
  21edb4:	c5 f8 29 44 24 d8    	vmovaps XMMWORD PTR [rsp-0x28],xmm0
    a.* = b.*;
  21edba:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  21edbe:	c5 f8 11 00          	vmovups XMMWORD PTR [rax],xmm0
    b.* = tmp;
  21edc2:	c5 f8 28 44 24 d8    	vmovaps xmm0,XMMWORD PTR [rsp-0x28]
  21edc8:	c5 f8 11 01          	vmovups XMMWORD PTR [rcx],xmm0
    while (i < end) : (i += 1) {
  21edcc:	48 83 c1 f0          	add    rcx,0xfffffffffffffff0
  21edd0:	48 83 c0 10          	add    rax,0x10
  21edd4:	48 83 c6 01          	add    rsi,0x1
  21edd8:	75 d6                	jne    21edb0 <mergeInPlace+0x4b0>
  21edda:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
        if (B.end == mid) break;
  21ede0:	4d 39 e1             	cmp    r9,r12
  21ede3:	0f 84 ac 00 00 00    	je     21ee95 <mergeInPlace+0x595>
        const amount = mid - A.end;
  21ede9:	4c 89 e0             	mov    rax,r12
  21edec:	4c 29 f0             	sub    rax,r14
        A = Range.init(A.start + amount, B.start);
  21edef:	4c 01 f8             	add    rax,r15
        A.start = binaryLast(T, items, items[A.start], A, lessThan);
  21edf2:	48 8b 4c 24 f0       	mov    rcx,QWORD PTR [rsp-0x10]
  21edf7:	48 8b 11             	mov    rdx,QWORD PTR [rcx]
  21edfa:	4d 89 e7             	mov    r15,r12
    if (range.start >= range.end) return range.end;
  21edfd:	4c 39 e0             	cmp    rax,r12
  21ee00:	0f 83 80 00 00 00    	jae    21ee86 <mergeInPlace+0x586>
  21ee06:	49 89 c2             	mov    r10,rax
  21ee09:	49 c1 e2 04          	shl    r10,0x4
  21ee0d:	49 01 d2             	add    r10,rdx
    var end = range.end - 1;
  21ee10:	4d 8d 44 24 ff       	lea    r8,[r12-0x1]
    while (start < end) {
  21ee15:	49 39 c0             	cmp    r8,rax
  21ee18:	76 3e                	jbe    21ee58 <mergeInPlace+0x558>
  21ee1a:	49 8b 2a             	mov    rbp,QWORD PTR [r10]
  21ee1d:	4c 89 c7             	mov    rdi,r8
        const mid = start + (end - start) / 2;
  21ee20:	48 89 fb             	mov    rbx,rdi
  21ee23:	48 29 c3             	sub    rbx,rax
  21ee26:	48 d1 eb             	shr    rbx,1
  21ee29:	48 8d 0c 03          	lea    rcx,[rbx+rax*1]
  21ee2d:	48 89 ce             	mov    rsi,rcx
  21ee30:	48 c1 e6 04          	shl    rsi,0x4
  21ee34:	48 3b 2c 32          	cmp    rbp,QWORD PTR [rdx+rsi*1]
        if (!lessThan(value, items[mid])) {
  21ee38:	72 16                	jb     21ee50 <mergeInPlace+0x550>
  21ee3a:	48 01 d8             	add    rax,rbx
  21ee3d:	48 83 c0 01          	add    rax,0x1
    while (start < end) {
  21ee41:	48 39 c7             	cmp    rdi,rax
  21ee44:	77 da                	ja     21ee20 <mergeInPlace+0x520>
  21ee46:	eb 10                	jmp    21ee58 <mergeInPlace+0x558>
  21ee48:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  21ee4f:	00 
        if (!lessThan(value, items[mid])) {
  21ee50:	48 89 cf             	mov    rdi,rcx
    while (start < end) {
  21ee53:	48 39 c7             	cmp    rdi,rax
  21ee56:	77 c8                	ja     21ee20 <mergeInPlace+0x520>
    if (start == range.end - 1 and !lessThan(value, items[start])) {
  21ee58:	4c 39 c0             	cmp    rax,r8
  21ee5b:	75 23                	jne    21ee80 <mergeInPlace+0x580>
  21ee5d:	49 8b 0a             	mov    rcx,QWORD PTR [r10]
  21ee60:	49 c1 e0 04          	shl    r8,0x4
  21ee64:	45 31 ff             	xor    r15d,r15d
  21ee67:	4a 3b 0c 02          	cmp    rcx,QWORD PTR [rdx+r8*1]
  21ee6b:	41 0f 93 c7          	setae  r15b
  21ee6f:	eb 12                	jmp    21ee83 <mergeInPlace+0x583>
  21ee71:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21ee78:	0f 1f 84 00 00 00 00 
  21ee7f:	00 
  21ee80:	45 31 ff             	xor    r15d,r15d
  21ee83:	49 01 c7             	add    r15,rax
  21ee86:	4d 89 e6             	mov    r14,r12
  21ee89:	4c 89 e1             	mov    rcx,r12
        if (A.length() == 0) break;
  21ee8c:	4d 39 fc             	cmp    r12,r15
  21ee8f:	0f 85 ab fa ff ff    	jne    21e940 <mergeInPlace+0x40>
    if (A_arg.length() == 0 or B_arg.length() == 0) return;
  21ee95:	5b                   	pop    rbx
  21ee96:	41 5c                	pop    r12
  21ee98:	41 5d                	pop    r13
  21ee9a:	41 5e                	pop    r14
  21ee9c:	41 5f                	pop    r15
  21ee9e:	5d                   	pop    rbp
  21ee9f:	c3                   	ret    

000000000021eea0 <FileOutStream_writeFn>:
    fn writeFn(out_stream: *Stream, bytes: []const u8) !void {
  21eea0:	53                   	push   rbx
  21eea1:	49 89 f0             	mov    r8,rsi
    while (index < bytes.len) {
  21eea4:	49 8b 50 08          	mov    rdx,QWORD PTR [r8+0x8]
  21eea8:	48 85 d2             	test   rdx,rdx
  21eeab:	0f 84 98 00 00 00    	je     21ef49 <FileOutStream_writeFn+0xa9>
        return self.file.write(bytes);
  21eeb1:	48 8b 47 f8          	mov    rax,QWORD PTR [rdi-0x8]
  21eeb5:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  21eeb8:	45 31 c9             	xor    r9d,r9d
  21eebb:	41 ba 00 f0 ff 7f    	mov    r10d,0x7ffff000
  21eec1:	48 8d 1d 5c 1e fe ff 	lea    rbx,[rip+0xfffffffffffe1e5c]        # 200d24 <__unnamed_621+0x6c>
  21eec8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  21eecf:	00 
        const amt_to_write = math.min(bytes.len - index, usize(max_bytes_len));
  21eed0:	4c 29 ca             	sub    rdx,r9
    return if (x < y) x else y;
  21eed3:	48 81 fa 00 f0 ff 7f 	cmp    rdx,0x7ffff000
  21eeda:	49 0f 43 d2          	cmovae rdx,r10
  21eede:	49 8b 30             	mov    rsi,QWORD PTR [r8]
        const rc = posix.write(fd, bytes.ptr + index, amt_to_write);
  21eee1:	4c 01 ce             	add    rsi,r9
  21eee4:	b8 01 00 00 00       	mov    eax,0x1
  21eee9:	0f 05                	syscall 
  21eeeb:	48 89 c1             	mov    rcx,rax
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  21eeee:	48 81 f9 00 f0 ff ff 	cmp    rcx,0xfffffffffffff000
  21eef5:	77 39                	ja     21ef30 <FileOutStream_writeFn+0x90>
  21eef7:	31 d2                	xor    edx,edx
        if (write_err > 0) {
  21eef9:	48 83 fa 04          	cmp    rdx,0x4
  21eefd:	74 3d                	je     21ef3c <FileOutStream_writeFn+0x9c>
  21eeff:	48 83 fa 59          	cmp    rdx,0x59
  21ef03:	77 48                	ja     21ef4d <FileOutStream_writeFn+0xad>
  21ef05:	66 b8 0f 00          	mov    ax,0xf
  21ef09:	48 63 14 93          	movsxd rdx,DWORD PTR [rbx+rdx*4]
  21ef0d:	48 01 da             	add    rdx,rbx
  21ef10:	ff e2                	jmp    rdx
        index += rc;
  21ef12:	49 01 c9             	add    r9,rcx
    while (index < bytes.len) {
  21ef15:	49 8b 50 08          	mov    rdx,QWORD PTR [r8+0x8]
  21ef19:	31 c0                	xor    eax,eax
  21ef1b:	4c 39 ca             	cmp    rdx,r9
  21ef1e:	77 b0                	ja     21eed0 <FileOutStream_writeFn+0x30>
  21ef20:	eb 25                	jmp    21ef47 <FileOutStream_writeFn+0xa7>
  21ef22:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21ef29:	1f 84 00 00 00 00 00 
  21ef30:	48 89 ca             	mov    rdx,rcx
  21ef33:	48 f7 da             	neg    rdx
        if (write_err > 0) {
  21ef36:	48 83 fa 04          	cmp    rdx,0x4
  21ef3a:	75 c3                	jne    21eeff <FileOutStream_writeFn+0x5f>
    while (index < bytes.len) {
  21ef3c:	49 8b 50 08          	mov    rdx,QWORD PTR [r8+0x8]
  21ef40:	4c 39 ca             	cmp    rdx,r9
  21ef43:	77 8b                	ja     21eed0 <FileOutStream_writeFn+0x30>
  21ef45:	31 c0                	xor    eax,eax
  21ef47:	5b                   	pop    rbx
  21ef48:	c3                   	ret    
  21ef49:	31 c0                	xor    eax,eax
  21ef4b:	5b                   	pop    rbx
  21ef4c:	c3                   	ret    
        if (write_err > 0) {
  21ef4d:	48 83 fa 7a          	cmp    rdx,0x7a
  21ef51:	75 06                	jne    21ef59 <FileOutStream_writeFn+0xb9>
  21ef53:	66 b8 12 00          	mov    ax,0x12
  21ef57:	5b                   	pop    rbx
  21ef58:	c3                   	ret    
  21ef59:	66 b8 03 00          	mov    ax,0x3
  21ef5d:	5b                   	pop    rbx
  21ef5e:	c3                   	ret    
  21ef5f:	66 b8 16 00          	mov    ax,0x16
  21ef63:	5b                   	pop    rbx
  21ef64:	c3                   	ret    
  21ef65:	66 b8 14 00          	mov    ax,0x14
  21ef69:	5b                   	pop    rbx
  21ef6a:	c3                   	ret    
  21ef6b:	66 b8 10 00          	mov    ax,0x10
  21ef6f:	5b                   	pop    rbx
  21ef70:	c3                   	ret    
  21ef71:	66 b8 13 00          	mov    ax,0x13
  21ef75:	5b                   	pop    rbx
  21ef76:	c3                   	ret    
  21ef77:	66 b8 15 00          	mov    ax,0x15
  21ef7b:	5b                   	pop    rbx
  21ef7c:	c3                   	ret    
  21ef7d:	66 b8 0e 00          	mov    ax,0xe
  21ef81:	5b                   	pop    rbx
  21ef82:	c3                   	ret    
  21ef83:	66 b8 11 00          	mov    ax,0x11
  21ef87:	5b                   	pop    rbx
  21ef88:	c3                   	ret    
  21ef89:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

000000000021ef90 <openSelfDebugInfoLinux>:
    var di = DebugInfo{
  21ef90:	55                   	push   rbp
  21ef91:	41 57                	push   r15
  21ef93:	41 56                	push   r14
  21ef95:	41 55                	push   r13
  21ef97:	41 54                	push   r12
  21ef99:	53                   	push   rbx
  21ef9a:	48 81 ec 08 0d 00 00 	sub    rsp,0xd08
  21efa1:	c5 fc 10 05 87 90 fe 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffe9087]        # 208030 <__unnamed_39>
  21efa8:	ff 
  21efa9:	c5 fc 11 84 24 40 06 	vmovups YMMWORD PTR [rsp+0x640],ymm0
  21efb0:	00 00 
  21efb2:	c5 fc 10 05 96 90 fe 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffe9096]        # 208050 <__unnamed_39+0x20>
  21efb9:	ff 
  21efba:	c5 fc 11 84 24 60 06 	vmovups YMMWORD PTR [rsp+0x660],ymm0
  21efc1:	00 00 
  21efc3:	c5 fc 10 05 9d 90 fe 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffe909d]        # 208068 <__unnamed_39+0x38>
  21efca:	ff 
  21efcb:	c5 fc 11 84 24 78 06 	vmovups YMMWORD PTR [rsp+0x678],ymm0
  21efd2:	00 00 
  21efd4:	c5 fc 10 84 24 38 06 	vmovups ymm0,YMMWORD PTR [rsp+0x638]
  21efdb:	00 00 
  21efdd:	c5 fc 11 84 24 70 01 	vmovups YMMWORD PTR [rsp+0x170],ymm0
  21efe4:	00 00 
  21efe6:	48 89 f5             	mov    rbp,rsi
  21efe9:	c5 fc 10 84 24 58 06 	vmovups ymm0,YMMWORD PTR [rsp+0x658]
  21eff0:	00 00 
  21eff2:	c5 fc 11 84 24 90 01 	vmovups YMMWORD PTR [rsp+0x190],ymm0
  21eff9:	00 00 
  21effb:	c5 fe 6f 84 24 78 06 	vmovdqu ymm0,YMMWORD PTR [rsp+0x678]
  21f002:	00 00 
  21f004:	c5 fe 7f 84 24 b0 01 	vmovdqu YMMWORD PTR [rsp+0x1b0],ymm0
  21f00b:	00 00 
  21f00d:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  21f011:	c5 fe 7f 84 24 f0 01 	vmovdqu YMMWORD PTR [rsp+0x1f0],ymm0
  21f018:	00 00 
  21f01a:	48 89 ac 24 10 02 00 	mov    QWORD PTR [rsp+0x210],rbp
  21f021:	00 
  21f022:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  21f026:	c5 fa 7f 84 24 18 02 	vmovdqu XMMWORD PTR [rsp+0x218],xmm0
  21f02d:	00 00 
  21f02f:	48 89 fb             	mov    rbx,rdi
  21f032:	48 c7 84 24 28 02 00 	mov    QWORD PTR [rsp+0x228],0x0
  21f039:	00 00 00 00 00 
  21f03e:	48 89 ac 24 30 02 00 	mov    QWORD PTR [rsp+0x230],rbp
  21f045:	00 
    return error.Unexpected;
}

pub fn openSelfExe() !os.File {
    switch (builtin.os) {
        Os.linux => return os.File.openReadC(c"/proc/self/exe"),
  21f046:	48 8d 35 16 a7 fe ff 	lea    rsi,[rip+0xfffffffffffea716]        # 209763 <__unnamed_40>
  21f04d:	48 8d bc 24 c0 00 00 	lea    rdi,[rsp+0xc0]
  21f054:	00 
  21f055:	c5 f8 77             	vzeroupper 
  21f058:	e8 d3 4d 00 00       	call   223e30 <File_openReadC>
  21f05d:	48 8b 84 24 c0 00 00 	mov    rax,QWORD PTR [rsp+0xc0]
  21f064:	00 
    di.self_exe_file = try os.openSelfExe();
  21f065:	66 85 c0             	test   ax,ax
  21f068:	74 5f                	je     21f0c9 <openSelfDebugInfoLinux+0x139>
  21f06a:	66 89 03             	mov    WORD PTR [rbx],ax
  21f06d:	c5 fc 10 84 24 e8 0c 	vmovups ymm0,YMMWORD PTR [rsp+0xce8]
  21f074:	00 00 
  21f076:	c5 fc 11 83 b0 00 00 	vmovups YMMWORD PTR [rbx+0xb0],ymm0
  21f07d:	00 
  21f07e:	c5 fc 10 84 24 da 0c 	vmovups ymm0,YMMWORD PTR [rsp+0xcda]
  21f085:	00 00 
  21f087:	c5 fc 11 83 a2 00 00 	vmovups YMMWORD PTR [rbx+0xa2],ymm0
  21f08e:	00 
  21f08f:	c5 fc 10 84 24 ba 0c 	vmovups ymm0,YMMWORD PTR [rsp+0xcba]
  21f096:	00 00 
  21f098:	c5 fc 11 83 82 00 00 	vmovups YMMWORD PTR [rbx+0x82],ymm0
  21f09f:	00 
  21f0a0:	c5 fc 10 84 24 3a 0c 	vmovups ymm0,YMMWORD PTR [rsp+0xc3a]
  21f0a7:	00 00 
  21f0a9:	c5 fc 10 8c 24 5a 0c 	vmovups ymm1,YMMWORD PTR [rsp+0xc5a]
  21f0b0:	00 00 
  21f0b2:	c5 fc 10 94 24 7a 0c 	vmovups ymm2,YMMWORD PTR [rsp+0xc7a]
  21f0b9:	00 00 
  21f0bb:	c5 fc 10 9c 24 9a 0c 	vmovups ymm3,YMMWORD PTR [rsp+0xc9a]
  21f0c2:	00 00 
  21f0c4:	e9 de 0b 00 00       	jmp    21fca7 <openSelfDebugInfoLinux+0xd17>
  21f0c9:	48 c1 e8 20          	shr    rax,0x20
  21f0cd:	89 84 24 70 01 00 00 	mov    DWORD PTR [rsp+0x170],eax
        elf.auto_close_stream = true;
    }

    /// Call close when done.
    pub fn openFile(elf: *Elf, allocator: *mem.Allocator, file: *os.File) !void {
        elf.allocator = allocator;
  21f0d4:	48 89 ac 24 c0 01 00 	mov    QWORD PTR [rsp+0x1c0],rbp
  21f0db:	00 
  21f0dc:	4c 8d ac 24 70 01 00 	lea    r13,[rsp+0x170]
  21f0e3:	00 
        elf.in_file = file;
  21f0e4:	4c 89 ac 24 78 01 00 	mov    QWORD PTR [rsp+0x178],r13
  21f0eb:	00 
        elf.auto_close_stream = false;
  21f0ec:	c6 84 24 80 01 00 00 	mov    BYTE PTR [rsp+0x180],0x0
  21f0f3:	00 

        var file_stream = io.FileInStream.init(elf.in_file);
  21f0f4:	4c 89 6c 24 40       	mov    QWORD PTR [rsp+0x40],r13
  21f0f9:	48 8d 05 60 50 00 00 	lea    rax,[rip+0x5060]        # 224160 <FileInStream_readFn>
  21f100:	48 89 44 24 48       	mov    QWORD PTR [rsp+0x48],rax
  21f105:	4c 8d a4 24 18 03 00 	lea    r12,[rsp+0x318]
  21f10c:	00 
        const in = &file_stream.stream;

        var magic: [4]u8 = undefined;
        try in.readNoEof(magic[0..]);
  21f10d:	4c 89 a4 24 b0 04 00 	mov    QWORD PTR [rsp+0x4b0],r12
  21f114:	00 
  21f115:	48 c7 84 24 b8 04 00 	mov    QWORD PTR [rsp+0x4b8],0x4
  21f11c:	00 04 00 00 00 
        return self.file.read(buffer);
  21f121:	48 8b 74 24 40       	mov    rsi,QWORD PTR [rsp+0x40]
  21f126:	4c 8d b4 24 c0 00 00 	lea    r14,[rsp+0xc0]
  21f12d:	00 
  21f12e:	4c 8d bc 24 b0 04 00 	lea    r15,[rsp+0x4b0]
  21f135:	00 
  21f136:	4c 89 f7             	mov    rdi,r14
  21f139:	4c 89 fa             	mov    rdx,r15
  21f13c:	e8 ef 4e 00 00       	call   224030 <File_read>
  21f141:	0f b7 ac 24 c0 00 00 	movzx  ebp,WORD PTR [rsp+0xc0]
  21f148:	00 
            const amt_read = try self.read(buf);
  21f149:	66 85 ed             	test   bp,bp
  21f14c:	75 16                	jne    21f164 <openSelfDebugInfoLinux+0x1d4>
  21f14e:	48 8b 84 24 c8 00 00 	mov    rax,QWORD PTR [rsp+0xc8]
  21f155:	00 
  21f156:	66 bd 25 00          	mov    bp,0x25
            if (amt_read < buf.len) return error.EndOfStream;
  21f15a:	48 3b 84 24 b8 04 00 	cmp    rax,QWORD PTR [rsp+0x4b8]
  21f161:	00 
  21f162:	73 56                	jae    21f1ba <openSelfDebugInfoLinux+0x22a>
    try di.elf.openFile(allocator, &di.self_exe_file);
  21f164:	66 85 ed             	test   bp,bp
  21f167:	0f 84 d7 06 00 00    	je     21f844 <openSelfDebugInfoLinux+0x8b4>
  21f16d:	48 63 bc 24 70 01 00 	movsxd rdi,DWORD PTR [rsp+0x170]
  21f174:	00 
  21f175:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21f17c:	00 00 00 00 
    return asm volatile ("syscall"
  21f180:	b8 03 00 00 00       	mov    eax,0x3
  21f185:	0f 05                	syscall 
            switch (err) {
  21f187:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  21f18b:	74 f3                	je     21f180 <openSelfDebugInfoLinux+0x1f0>
        /// Remove and return the first node in the list.
        ///
        /// Returns:
        ///     A pointer to the first node in the list.
        pub fn popFirst(list: *Self) ?*Node {
            const first = list.first orelse return null;
  21f18d:	48 8b 05 8c 1e 03 00 	mov    rax,QWORD PTR [rip+0x31e8c]        # 251020 <emfile_promise_queue>
  21f194:	48 85 c0             	test   rax,rax
  21f197:	0f 84 2b 01 00 00    	je     21f2c8 <openSelfDebugInfoLinux+0x338>
            if (node.prev) |prev_node| {
  21f19d:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  21f1a0:	48 85 c9             	test   rcx,rcx
  21f1a3:	0f 84 b5 00 00 00    	je     21f25e <openSelfDebugInfoLinux+0x2ce>
                prev_node.next = node.next;
  21f1a9:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  21f1ad:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  21f1b1:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  21f1b5:	e9 af 00 00 00       	jmp    21f269 <openSelfDebugInfoLinux+0x2d9>
        if (b[index] != item) return false;
  21f1ba:	80 bc 24 18 03 00 00 	cmp    BYTE PTR [rsp+0x318],0x7f
  21f1c1:	7f 
  21f1c2:	0f 85 6f 06 00 00    	jne    21f837 <openSelfDebugInfoLinux+0x8a7>
  21f1c8:	80 bc 24 19 03 00 00 	cmp    BYTE PTR [rsp+0x319],0x45
  21f1cf:	45 
  21f1d0:	0f 85 61 06 00 00    	jne    21f837 <openSelfDebugInfoLinux+0x8a7>
  21f1d6:	80 bc 24 1a 03 00 00 	cmp    BYTE PTR [rsp+0x31a],0x4c
  21f1dd:	4c 
  21f1de:	0f 85 53 06 00 00    	jne    21f837 <openSelfDebugInfoLinux+0x8a7>
  21f1e4:	80 bc 24 1b 03 00 00 	cmp    BYTE PTR [rsp+0x31b],0x46
  21f1eb:	46 
  21f1ec:	0f 85 35 01 00 00    	jne    21f327 <openSelfDebugInfoLinux+0x397>
  21f1f2:	48 8d 74 24 48       	lea    rsi,[rsp+0x48]
  21f1f7:	48 8d 44 24 0f       	lea    rax,[rsp+0xf]
            try self.readNoEof(result[0..]);
  21f1fc:	48 89 44 24 68       	mov    QWORD PTR [rsp+0x68],rax
  21f201:	48 c7 44 24 70 01 00 	mov    QWORD PTR [rsp+0x70],0x1
  21f208:	00 00 
  21f20a:	48 8d bc 24 c0 00 00 	lea    rdi,[rsp+0xc0]
  21f211:	00 
  21f212:	48 8d 54 24 68       	lea    rdx,[rsp+0x68]
            return self.readFn(self, buffer);
  21f217:	ff 54 24 48          	call   QWORD PTR [rsp+0x48]
  21f21b:	0f b7 ac 24 c0 00 00 	movzx  ebp,WORD PTR [rsp+0xc0]
  21f222:	00 
            const amt_read = try self.read(buf);
  21f223:	66 85 ed             	test   bp,bp
  21f226:	0f 85 38 ff ff ff    	jne    21f164 <openSelfDebugInfoLinux+0x1d4>
  21f22c:	48 8b 84 24 c8 00 00 	mov    rax,QWORD PTR [rsp+0xc8]
  21f233:	00 
  21f234:	66 bd 25 00          	mov    bp,0x25
            if (amt_read < buf.len) return error.EndOfStream;
  21f238:	48 3b 44 24 70       	cmp    rax,QWORD PTR [rsp+0x70]
  21f23d:	0f 82 21 ff ff ff    	jb     21f164 <openSelfDebugInfoLinux+0x1d4>
            return result[0];
  21f243:	8a 44 24 0f          	mov    al,BYTE PTR [rsp+0xf]
        if (!mem.eql(u8, magic, "\x7fELF")) return error.InvalidFormat;

        elf.is_64 = switch (try in.readByte()) {
  21f247:	3c 01                	cmp    al,0x1
  21f249:	0f 84 ea 00 00 00    	je     21f339 <openSelfDebugInfoLinux+0x3a9>
  21f24f:	3c 02                	cmp    al,0x2
  21f251:	0f 85 e0 05 00 00    	jne    21f837 <openSelfDebugInfoLinux+0x8a7>
  21f257:	b0 01                	mov    al,0x1
  21f259:	e9 dd 00 00 00       	jmp    21f33b <openSelfDebugInfoLinux+0x3ab>
                list.first = node.next;
  21f25e:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  21f262:	48 89 0d b7 1d 03 00 	mov    QWORD PTR [rip+0x31db7],rcx        # 251020 <emfile_promise_queue>
            if (node.next) |next_node| {
  21f269:	48 85 c9             	test   rcx,rcx
  21f26c:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  21f26f:	48 8d 35 b2 1d 03 00 	lea    rsi,[rip+0x31db2]        # 251028 <emfile_promise_queue+0x8>
  21f276:	48 0f 45 f1          	cmovne rsi,rcx
  21f27a:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  21f27d:	48 83 05 ab 1d 03 00 	add    QWORD PTR [rip+0x31dab],0xffffffffffffffff        # 251030 <emfile_promise_queue+0x10>
  21f284:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  21f285:	74 1e                	je     21f2a5 <openSelfDebugInfoLinux+0x315>
  21f287:	48 83 3d 91 1d 03 00 	cmp    QWORD PTR [rip+0x31d91],0x0        # 251020 <emfile_promise_queue>
  21f28e:	00 
  21f28f:	0f 84 41 3e 00 00    	je     2230d6 <openSelfDebugInfoLinux+0x4146>
  21f295:	48 8b 0d 8c 1d 03 00 	mov    rcx,QWORD PTR [rip+0x31d8c]        # 251028 <emfile_promise_queue+0x8>
  21f29c:	48 85 c9             	test   rcx,rcx
  21f29f:	0f 84 31 3e 00 00    	je     2230d6 <openSelfDebugInfoLinux+0x4146>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  21f2a5:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  21f2a9:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  21f2ad:	0f 1f 00             	nop    DWORD PTR [rax]
  21f2b0:	48 89 c1             	mov    rcx,rax
  21f2b3:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  21f2b7:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  21f2bd:	75 f1                	jne    21f2b0 <openSelfDebugInfoLinux+0x320>
  21f2bf:	a8 01                	test   al,0x1
  21f2c1:	75 05                	jne    21f2c8 <openSelfDebugInfoLinux+0x338>
  21f2c3:	c5 f8 77             	vzeroupper 
  21f2c6:	ff 17                	call   QWORD PTR [rdi]
  21f2c8:	66 89 2b             	mov    WORD PTR [rbx],bp
  21f2cb:	c5 fc 10 84 24 1a 0c 	vmovups ymm0,YMMWORD PTR [rsp+0xc1a]
  21f2d2:	00 00 
  21f2d4:	c5 fc 11 83 b0 00 00 	vmovups YMMWORD PTR [rbx+0xb0],ymm0
  21f2db:	00 
  21f2dc:	c5 fc 10 84 24 0c 0c 	vmovups ymm0,YMMWORD PTR [rsp+0xc0c]
  21f2e3:	00 00 
  21f2e5:	c5 fc 11 83 a2 00 00 	vmovups YMMWORD PTR [rbx+0xa2],ymm0
  21f2ec:	00 
  21f2ed:	c5 fc 10 84 24 ec 0b 	vmovups ymm0,YMMWORD PTR [rsp+0xbec]
  21f2f4:	00 00 
  21f2f6:	c5 fc 11 83 82 00 00 	vmovups YMMWORD PTR [rbx+0x82],ymm0
  21f2fd:	00 
  21f2fe:	c5 fc 10 84 24 6c 0b 	vmovups ymm0,YMMWORD PTR [rsp+0xb6c]
  21f305:	00 00 
  21f307:	c5 fc 10 8c 24 8c 0b 	vmovups ymm1,YMMWORD PTR [rsp+0xb8c]
  21f30e:	00 00 
  21f310:	c5 fc 10 94 24 ac 0b 	vmovups ymm2,YMMWORD PTR [rsp+0xbac]
  21f317:	00 00 
  21f319:	c5 fc 10 9c 24 cc 0b 	vmovups ymm3,YMMWORD PTR [rsp+0xbcc]
  21f320:	00 00 
  21f322:	e9 80 09 00 00       	jmp    21fca7 <openSelfDebugInfoLinux+0xd17>
  21f327:	66 bd 26 00          	mov    bp,0x26
  21f32b:	66 85 ed             	test   bp,bp
  21f32e:	0f 85 39 fe ff ff    	jne    21f16d <openSelfDebugInfoLinux+0x1dd>
  21f334:	e9 0b 05 00 00       	jmp    21f844 <openSelfDebugInfoLinux+0x8b4>
  21f339:	31 c0                	xor    eax,eax
  21f33b:	88 84 24 81 01 00 00 	mov    BYTE PTR [rsp+0x181],al
            try self.readNoEof(result[0..]);
  21f342:	48 8d 44 24 0f       	lea    rax,[rsp+0xf]
  21f347:	48 89 44 24 68       	mov    QWORD PTR [rsp+0x68],rax
  21f34c:	48 c7 44 24 70 01 00 	mov    QWORD PTR [rsp+0x70],0x1
  21f353:	00 00 
  21f355:	48 8d bc 24 c0 00 00 	lea    rdi,[rsp+0xc0]
  21f35c:	00 
  21f35d:	48 8d 54 24 68       	lea    rdx,[rsp+0x68]
            return self.readFn(self, buffer);
  21f362:	48 8d 74 24 48       	lea    rsi,[rsp+0x48]
  21f367:	ff 54 24 48          	call   QWORD PTR [rsp+0x48]
  21f36b:	0f b7 ac 24 c0 00 00 	movzx  ebp,WORD PTR [rsp+0xc0]
  21f372:	00 
            const amt_read = try self.read(buf);
  21f373:	66 85 ed             	test   bp,bp
  21f376:	0f 85 e8 fd ff ff    	jne    21f164 <openSelfDebugInfoLinux+0x1d4>
  21f37c:	48 8b 84 24 c8 00 00 	mov    rax,QWORD PTR [rsp+0xc8]
  21f383:	00 
  21f384:	66 bd 25 00          	mov    bp,0x25
            if (amt_read < buf.len) return error.EndOfStream;
  21f388:	48 3b 44 24 70       	cmp    rax,QWORD PTR [rsp+0x70]
  21f38d:	0f 82 d1 fd ff ff    	jb     21f164 <openSelfDebugInfoLinux+0x1d4>
            return result[0];
  21f393:	8a 44 24 0f          	mov    al,BYTE PTR [rsp+0xf]
            1 => false,
            2 => true,
            else => return error.InvalidFormat,
        };

        elf.endian = switch (try in.readByte()) {
  21f397:	3c 01                	cmp    al,0x1
  21f399:	74 0c                	je     21f3a7 <openSelfDebugInfoLinux+0x417>
  21f39b:	3c 02                	cmp    al,0x2
  21f39d:	0f 85 94 04 00 00    	jne    21f837 <openSelfDebugInfoLinux+0x8a7>
  21f3a3:	31 c0                	xor    eax,eax
  21f3a5:	eb 02                	jmp    21f3a9 <openSelfDebugInfoLinux+0x419>
  21f3a7:	b0 01                	mov    al,0x1
  21f3a9:	88 84 24 82 01 00 00 	mov    BYTE PTR [rsp+0x182],al
            try self.readNoEof(result[0..]);
  21f3b0:	48 8d 44 24 0f       	lea    rax,[rsp+0xf]
  21f3b5:	48 89 44 24 68       	mov    QWORD PTR [rsp+0x68],rax
  21f3ba:	48 c7 44 24 70 01 00 	mov    QWORD PTR [rsp+0x70],0x1
  21f3c1:	00 00 
  21f3c3:	48 8d bc 24 c0 00 00 	lea    rdi,[rsp+0xc0]
  21f3ca:	00 
  21f3cb:	48 8d 54 24 68       	lea    rdx,[rsp+0x68]
            return self.readFn(self, buffer);
  21f3d0:	48 8d 74 24 48       	lea    rsi,[rsp+0x48]
  21f3d5:	ff 54 24 48          	call   QWORD PTR [rsp+0x48]
  21f3d9:	0f b7 ac 24 c0 00 00 	movzx  ebp,WORD PTR [rsp+0xc0]
  21f3e0:	00 
            const amt_read = try self.read(buf);
  21f3e1:	66 85 ed             	test   bp,bp
  21f3e4:	0f 85 7a fd ff ff    	jne    21f164 <openSelfDebugInfoLinux+0x1d4>
  21f3ea:	48 8b 84 24 c8 00 00 	mov    rax,QWORD PTR [rsp+0xc8]
  21f3f1:	00 
  21f3f2:	66 bd 25 00          	mov    bp,0x25
            if (amt_read < buf.len) return error.EndOfStream;
  21f3f6:	48 3b 44 24 70       	cmp    rax,QWORD PTR [rsp+0x70]
  21f3fb:	0f 82 63 fd ff ff    	jb     21f164 <openSelfDebugInfoLinux+0x1d4>
            2 => builtin.Endian.Big,
            else => return error.InvalidFormat,
        };

        const version_byte = try in.readByte();
        if (version_byte != 1) return error.InvalidFormat;
  21f401:	80 7c 24 0f 01       	cmp    BYTE PTR [rsp+0xf],0x1
  21f406:	0f 85 2b 04 00 00    	jne    21f837 <openSelfDebugInfoLinux+0x8a7>

        // skip over padding
        try elf.in_file.seekForward(9);
  21f40c:	48 8b 84 24 78 01 00 	mov    rax,QWORD PTR [rsp+0x178]
  21f413:	00 
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  21f414:	48 63 38             	movsxd rdi,DWORD PTR [rax]
    return asm volatile ("syscall"
  21f417:	b8 08 00 00 00       	mov    eax,0x8
  21f41c:	be 09 00 00 00       	mov    esi,0x9
  21f421:	ba 01 00 00 00       	mov    edx,0x1
  21f426:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  21f428:	48 89 c2             	mov    rdx,rax
  21f42b:	48 f7 da             	neg    rdx
  21f42e:	31 c9                	xor    ecx,ecx
  21f430:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  21f436:	48 0f 47 ca          	cmova  rcx,rdx
    pub fn seekForward(self: *File, amount: isize) !void {
        switch (builtin.os) {
            Os.linux, Os.macosx, Os.ios => {
                const result = posix.lseek(self.handle, amount, posix.SEEK_CUR);
                const err = posix.getErrno(result);
                if (err > 0) {
  21f43a:	48 83 f9 1d          	cmp    rcx,0x1d
  21f43e:	0f 87 7f 3c 00 00    	ja     2230c3 <openSelfDebugInfoLinux+0x4133>
  21f444:	48 8d 05 41 1a fe ff 	lea    rax,[rip+0xfffffffffffe1a41]        # 200e8c <__unnamed_621+0x1d4>
  21f44b:	48 63 0c 88          	movsxd rcx,DWORD PTR [rax+rcx*4]
  21f44f:	48 01 c1             	add    rcx,rax
  21f452:	66 bd 03 00          	mov    bp,0x3
  21f456:	ff e1                	jmp    rcx
  21f458:	66 bd 27 00          	mov    bp,0x27
  21f45c:	66 85 ed             	test   bp,bp
  21f45f:	0f 85 08 fd ff ff    	jne    21f16d <openSelfDebugInfoLinux+0x1dd>
  21f465:	e9 da 03 00 00       	jmp    21f844 <openSelfDebugInfoLinux+0x8b4>

        elf.file_type = switch (try in.readInt(elf.endian, u16)) {
  21f46a:	8a 84 24 82 01 00 00 	mov    al,BYTE PTR [rsp+0x182]
  21f471:	88 44 24 30          	mov    BYTE PTR [rsp+0x30],al
  21f475:	48 8d 44 24 10       	lea    rax,[rsp+0x10]
            try self.readNoEof(bytes[0..]);
  21f47a:	48 89 44 24 68       	mov    QWORD PTR [rsp+0x68],rax
  21f47f:	48 c7 44 24 70 02 00 	mov    QWORD PTR [rsp+0x70],0x2
  21f486:	00 00 
  21f488:	48 8d bc 24 c0 00 00 	lea    rdi,[rsp+0xc0]
  21f48f:	00 
  21f490:	48 8d 54 24 68       	lea    rdx,[rsp+0x68]
            return self.readFn(self, buffer);
  21f495:	48 8d 74 24 48       	lea    rsi,[rsp+0x48]
  21f49a:	ff 54 24 48          	call   QWORD PTR [rsp+0x48]
  21f49e:	0f b7 ac 24 c0 00 00 	movzx  ebp,WORD PTR [rsp+0xc0]
  21f4a5:	00 
            const amt_read = try self.read(buf);
  21f4a6:	66 85 ed             	test   bp,bp
  21f4a9:	0f 85 b5 fc ff ff    	jne    21f164 <openSelfDebugInfoLinux+0x1d4>
  21f4af:	48 8b 84 24 c8 00 00 	mov    rax,QWORD PTR [rsp+0xc8]
  21f4b6:	00 
  21f4b7:	66 bd 25 00          	mov    bp,0x25
            if (amt_read < buf.len) return error.EndOfStream;
  21f4bb:	48 3b 44 24 70       	cmp    rax,QWORD PTR [rsp+0x70]
  21f4c0:	0f 82 9e fc ff ff    	jb     21f164 <openSelfDebugInfoLinux+0x1d4>
  21f4c6:	0f b6 44 24 10       	movzx  eax,BYTE PTR [rsp+0x10]
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  21f4cb:	0f b6 4c 24 11       	movzx  ecx,BYTE PTR [rsp+0x11]
  21f4d0:	89 ca                	mov    edx,ecx
  21f4d2:	c1 e2 08             	shl    edx,0x8
  21f4d5:	09 c2                	or     edx,eax
                result = (result << 8) | b;
  21f4d7:	c1 e0 08             	shl    eax,0x8
  21f4da:	09 c8                	or     eax,ecx
    switch (endian) {
  21f4dc:	f6 44 24 30 01       	test   BYTE PTR [rsp+0x30],0x1
  21f4e1:	66 0f 45 c2          	cmovne ax,dx
  21f4e5:	83 c0 ff             	add    eax,0xffffffff
  21f4e8:	0f b7 c8             	movzx  ecx,ax
  21f4eb:	83 f9 03             	cmp    ecx,0x3
  21f4ee:	0f 87 43 03 00 00    	ja     21f837 <openSelfDebugInfoLinux+0x8a7>
  21f4f4:	24 03                	and    al,0x3
  21f4f6:	88 84 24 83 01 00 00 	mov    BYTE PTR [rsp+0x183],al
            3 => FileType.Shared,
            4 => FileType.Core,
            else => return error.InvalidFormat,
        };

        elf.arch = switch (try in.readInt(elf.endian, u16)) {
  21f4fd:	8a 84 24 82 01 00 00 	mov    al,BYTE PTR [rsp+0x182]
            try self.readNoEof(bytes[0..]);
  21f504:	88 44 24 30          	mov    BYTE PTR [rsp+0x30],al
  21f508:	48 8d 44 24 10       	lea    rax,[rsp+0x10]
  21f50d:	48 89 44 24 68       	mov    QWORD PTR [rsp+0x68],rax
  21f512:	48 c7 44 24 70 02 00 	mov    QWORD PTR [rsp+0x70],0x2
  21f519:	00 00 
  21f51b:	48 8d bc 24 c0 00 00 	lea    rdi,[rsp+0xc0]
  21f522:	00 
  21f523:	48 8d 54 24 68       	lea    rdx,[rsp+0x68]
            return self.readFn(self, buffer);
  21f528:	48 8d 74 24 48       	lea    rsi,[rsp+0x48]
  21f52d:	ff 54 24 48          	call   QWORD PTR [rsp+0x48]
  21f531:	0f b7 ac 24 c0 00 00 	movzx  ebp,WORD PTR [rsp+0xc0]
  21f538:	00 
            const amt_read = try self.read(buf);
  21f539:	66 85 ed             	test   bp,bp
  21f53c:	0f 85 22 fc ff ff    	jne    21f164 <openSelfDebugInfoLinux+0x1d4>
  21f542:	48 8b 84 24 c8 00 00 	mov    rax,QWORD PTR [rsp+0xc8]
  21f549:	00 
  21f54a:	66 bd 25 00          	mov    bp,0x25
            if (amt_read < buf.len) return error.EndOfStream;
  21f54e:	48 3b 44 24 70       	cmp    rax,QWORD PTR [rsp+0x70]
  21f553:	0f 82 0b fc ff ff    	jb     21f164 <openSelfDebugInfoLinux+0x1d4>
  21f559:	0f b6 44 24 10       	movzx  eax,BYTE PTR [rsp+0x10]
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  21f55e:	0f b6 4c 24 11       	movzx  ecx,BYTE PTR [rsp+0x11]
  21f563:	89 ca                	mov    edx,ecx
  21f565:	c1 e2 08             	shl    edx,0x8
  21f568:	09 c2                	or     edx,eax
                result = (result << 8) | b;
  21f56a:	c1 e0 08             	shl    eax,0x8
  21f56d:	09 c8                	or     eax,ecx
    switch (endian) {
  21f56f:	f6 44 24 30 01       	test   BYTE PTR [rsp+0x30],0x1
  21f574:	66 0f 45 c2          	cmovne ax,dx
  21f578:	8d 48 fe             	lea    ecx,[rax-0x2]
  21f57b:	0f b7 c9             	movzx  ecx,cx
  21f57e:	83 f9 3c             	cmp    ecx,0x3c
  21f581:	77 1a                	ja     21f59d <openSelfDebugInfoLinux+0x60d>
  21f583:	31 c0                	xor    eax,eax
  21f585:	48 8d 15 78 19 fe ff 	lea    rdx,[rip+0xfffffffffffe1978]        # 200f04 <__unnamed_621+0x24c>
  21f58c:	48 63 0c 8a          	movsxd rcx,DWORD PTR [rdx+rcx*4]
  21f590:	48 01 d1             	add    rcx,rdx
  21f593:	66 bd 26 00          	mov    bp,0x26
  21f597:	ff e1                	jmp    rcx
  21f599:	b0 01                	mov    al,0x1
  21f59b:	eb 28                	jmp    21f5c5 <openSelfDebugInfoLinux+0x635>
  21f59d:	0f b7 c0             	movzx  eax,ax
  21f5a0:	3d b7 00 00 00       	cmp    eax,0xb7
  21f5a5:	0f 85 8c 02 00 00    	jne    21f837 <openSelfDebugInfoLinux+0x8a7>
  21f5ab:	b0 08                	mov    al,0x8
  21f5ad:	eb 16                	jmp    21f5c5 <openSelfDebugInfoLinux+0x635>
  21f5af:	b0 07                	mov    al,0x7
  21f5b1:	eb 12                	jmp    21f5c5 <openSelfDebugInfoLinux+0x635>
  21f5b3:	b0 06                	mov    al,0x6
  21f5b5:	eb 0e                	jmp    21f5c5 <openSelfDebugInfoLinux+0x635>
  21f5b7:	b0 02                	mov    al,0x2
  21f5b9:	eb 0a                	jmp    21f5c5 <openSelfDebugInfoLinux+0x635>
  21f5bb:	b0 04                	mov    al,0x4
  21f5bd:	eb 06                	jmp    21f5c5 <openSelfDebugInfoLinux+0x635>
  21f5bf:	b0 03                	mov    al,0x3
  21f5c1:	eb 02                	jmp    21f5c5 <openSelfDebugInfoLinux+0x635>
  21f5c3:	b0 05                	mov    al,0x5
  21f5c5:	24 0f                	and    al,0xf
  21f5c7:	88 84 24 84 01 00 00 	mov    BYTE PTR [rsp+0x184],al
            0x3E => Arch.x86_64,
            0xb7 => Arch.AArch64,
            else => return error.InvalidFormat,
        };

        const elf_version = try in.readInt(elf.endian, u32);
  21f5ce:	8a 84 24 82 01 00 00 	mov    al,BYTE PTR [rsp+0x182]
            try self.readNoEof(bytes[0..]);
  21f5d5:	88 44 24 30          	mov    BYTE PTR [rsp+0x30],al
  21f5d9:	48 8d 44 24 10       	lea    rax,[rsp+0x10]
  21f5de:	48 89 44 24 68       	mov    QWORD PTR [rsp+0x68],rax
  21f5e3:	48 c7 44 24 70 04 00 	mov    QWORD PTR [rsp+0x70],0x4
  21f5ea:	00 00 
  21f5ec:	48 8d bc 24 c0 00 00 	lea    rdi,[rsp+0xc0]
  21f5f3:	00 
  21f5f4:	48 8d 54 24 68       	lea    rdx,[rsp+0x68]
            return self.readFn(self, buffer);
  21f5f9:	48 8d 74 24 48       	lea    rsi,[rsp+0x48]
  21f5fe:	ff 54 24 48          	call   QWORD PTR [rsp+0x48]
  21f602:	0f b7 ac 24 c0 00 00 	movzx  ebp,WORD PTR [rsp+0xc0]
  21f609:	00 
            const amt_read = try self.read(buf);
  21f60a:	66 85 ed             	test   bp,bp
  21f60d:	0f 85 51 fb ff ff    	jne    21f164 <openSelfDebugInfoLinux+0x1d4>
  21f613:	48 8b 84 24 c8 00 00 	mov    rax,QWORD PTR [rsp+0xc8]
  21f61a:	00 
  21f61b:	66 bd 25 00          	mov    bp,0x25
            if (amt_read < buf.len) return error.EndOfStream;
  21f61f:	48 3b 44 24 70       	cmp    rax,QWORD PTR [rsp+0x70]
  21f624:	0f 82 3a fb ff ff    	jb     21f164 <openSelfDebugInfoLinux+0x1d4>
  21f62a:	0f b6 44 24 10       	movzx  eax,BYTE PTR [rsp+0x10]
  21f62f:	0f b6 4c 24 11       	movzx  ecx,BYTE PTR [rsp+0x11]
  21f634:	f6 44 24 30 01       	test   BYTE PTR [rsp+0x30],0x1
  21f639:	74 23                	je     21f65e <openSelfDebugInfoLinux+0x6ce>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  21f63b:	c1 e1 08             	shl    ecx,0x8
  21f63e:	09 c1                	or     ecx,eax
  21f640:	0f b6 54 24 12       	movzx  edx,BYTE PTR [rsp+0x12]
  21f645:	c1 e2 10             	shl    edx,0x10
  21f648:	09 ca                	or     edx,ecx
  21f64a:	0f b6 44 24 13       	movzx  eax,BYTE PTR [rsp+0x13]
  21f64f:	c1 e0 18             	shl    eax,0x18
  21f652:	09 d0                	or     eax,edx
        if (elf_version != 1) return error.InvalidFormat;
  21f654:	83 f8 01             	cmp    eax,0x1
  21f657:	74 27                	je     21f680 <openSelfDebugInfoLinux+0x6f0>
  21f659:	e9 d9 01 00 00       	jmp    21f837 <openSelfDebugInfoLinux+0x8a7>
                result = (result << 8) | b;
  21f65e:	c1 e0 08             	shl    eax,0x8
  21f661:	09 c8                	or     eax,ecx
  21f663:	c1 e0 08             	shl    eax,0x8
  21f666:	0f b6 4c 24 12       	movzx  ecx,BYTE PTR [rsp+0x12]
  21f66b:	09 c1                	or     ecx,eax
  21f66d:	c1 e1 08             	shl    ecx,0x8
  21f670:	0f b6 44 24 13       	movzx  eax,BYTE PTR [rsp+0x13]
  21f675:	09 c8                	or     eax,ecx
  21f677:	83 f8 01             	cmp    eax,0x1
  21f67a:	0f 85 b7 01 00 00    	jne    21f837 <openSelfDebugInfoLinux+0x8a7>
  21f680:	8a 84 24 82 01 00 00 	mov    al,BYTE PTR [rsp+0x182]

        if (elf.is_64) {
  21f687:	88 44 24 30          	mov    BYTE PTR [rsp+0x30],al
  21f68b:	80 bc 24 81 01 00 00 	cmp    BYTE PTR [rsp+0x181],0x1
  21f692:	01 
  21f693:	0f 85 49 2e 00 00    	jne    2224e2 <openSelfDebugInfoLinux+0x3552>
            elf.entry_addr = try in.readInt(elf.endian, u64);
  21f699:	0f b6 54 24 30       	movzx  edx,BYTE PTR [rsp+0x30]
  21f69e:	48 8d bc 24 e8 04 00 	lea    rdi,[rsp+0x4e8]
  21f6a5:	00 
  21f6a6:	48 8d 74 24 48       	lea    rsi,[rsp+0x48]
  21f6ab:	e8 50 48 00 00       	call   223f00 <InStream(ReadError)_readInt.143>
  21f6b0:	0f b7 ac 24 e8 04 00 	movzx  ebp,WORD PTR [rsp+0x4e8]
  21f6b7:	00 
  21f6b8:	66 85 ed             	test   bp,bp
  21f6bb:	0f 85 a3 fa ff ff    	jne    21f164 <openSelfDebugInfoLinux+0x1d4>
  21f6c1:	48 8b 84 24 f0 04 00 	mov    rax,QWORD PTR [rsp+0x4f0]
  21f6c8:	00 
  21f6c9:	48 89 84 24 88 01 00 	mov    QWORD PTR [rsp+0x188],rax
  21f6d0:	00 
            elf.program_header_offset = try in.readInt(elf.endian, u64);
  21f6d1:	0f b6 94 24 82 01 00 	movzx  edx,BYTE PTR [rsp+0x182]
  21f6d8:	00 
  21f6d9:	48 8d bc 24 60 03 00 	lea    rdi,[rsp+0x360]
  21f6e0:	00 
  21f6e1:	48 8d 74 24 48       	lea    rsi,[rsp+0x48]
  21f6e6:	e8 15 48 00 00       	call   223f00 <InStream(ReadError)_readInt.143>
  21f6eb:	0f b7 ac 24 60 03 00 	movzx  ebp,WORD PTR [rsp+0x360]
  21f6f2:	00 
  21f6f3:	66 85 ed             	test   bp,bp
  21f6f6:	0f 85 68 fa ff ff    	jne    21f164 <openSelfDebugInfoLinux+0x1d4>
  21f6fc:	48 8b 84 24 68 03 00 	mov    rax,QWORD PTR [rsp+0x368]
  21f703:	00 
  21f704:	48 89 84 24 90 01 00 	mov    QWORD PTR [rsp+0x190],rax
  21f70b:	00 
            elf.section_header_offset = try in.readInt(elf.endian, u64);
  21f70c:	0f b6 94 24 82 01 00 	movzx  edx,BYTE PTR [rsp+0x182]
  21f713:	00 
  21f714:	48 8d bc 24 30 03 00 	lea    rdi,[rsp+0x330]
  21f71b:	00 
  21f71c:	48 8d 74 24 48       	lea    rsi,[rsp+0x48]
  21f721:	e8 da 47 00 00       	call   223f00 <InStream(ReadError)_readInt.143>
  21f726:	0f b7 ac 24 30 03 00 	movzx  ebp,WORD PTR [rsp+0x330]
  21f72d:	00 
  21f72e:	66 85 ed             	test   bp,bp
  21f731:	0f 85 2d fa ff ff    	jne    21f164 <openSelfDebugInfoLinux+0x1d4>
  21f737:	48 8b 84 24 38 03 00 	mov    rax,QWORD PTR [rsp+0x338]
  21f73e:	00 
  21f73f:	48 89 84 24 98 01 00 	mov    QWORD PTR [rsp+0x198],rax
  21f746:	00 
            elf.program_header_offset = u64(try in.readInt(elf.endian, u32));
            elf.section_header_offset = u64(try in.readInt(elf.endian, u32));
        }

        // skip over flags
        try elf.in_file.seekForward(4);
  21f747:	48 8b 84 24 78 01 00 	mov    rax,QWORD PTR [rsp+0x178]
  21f74e:	00 
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  21f74f:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  21f752:	b8 08 00 00 00       	mov    eax,0x8
  21f757:	be 04 00 00 00       	mov    esi,0x4
  21f75c:	ba 01 00 00 00       	mov    edx,0x1
  21f761:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  21f763:	48 89 c2             	mov    rdx,rax
  21f766:	48 f7 da             	neg    rdx
  21f769:	31 c9                	xor    ecx,ecx
  21f76b:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  21f771:	48 0f 47 ca          	cmova  rcx,rdx
  21f775:	48 83 f9 1d          	cmp    rcx,0x1d
  21f779:	0f 87 44 39 00 00    	ja     2230c3 <openSelfDebugInfoLinux+0x4133>
  21f77f:	48 8d 05 72 18 fe ff 	lea    rax,[rip+0xfffffffffffe1872]        # 200ff8 <__unnamed_621+0x340>
  21f786:	48 63 0c 88          	movsxd rcx,DWORD PTR [rax+rcx*4]
  21f78a:	48 01 c1             	add    rcx,rax
  21f78d:	66 bd 03 00          	mov    bp,0x3
  21f791:	ff e1                	jmp    rcx

        const header_size = try in.readInt(elf.endian, u16);
  21f793:	8a 84 24 82 01 00 00 	mov    al,BYTE PTR [rsp+0x182]
            try self.readNoEof(bytes[0..]);
  21f79a:	88 44 24 30          	mov    BYTE PTR [rsp+0x30],al
  21f79e:	48 8d 44 24 10       	lea    rax,[rsp+0x10]
  21f7a3:	48 89 44 24 68       	mov    QWORD PTR [rsp+0x68],rax
  21f7a8:	48 c7 44 24 70 02 00 	mov    QWORD PTR [rsp+0x70],0x2
  21f7af:	00 00 
  21f7b1:	48 8d bc 24 c0 00 00 	lea    rdi,[rsp+0xc0]
  21f7b8:	00 
  21f7b9:	48 8d 54 24 68       	lea    rdx,[rsp+0x68]
            return self.readFn(self, buffer);
  21f7be:	48 8d 74 24 48       	lea    rsi,[rsp+0x48]
  21f7c3:	ff 54 24 48          	call   QWORD PTR [rsp+0x48]
  21f7c7:	0f b7 ac 24 c0 00 00 	movzx  ebp,WORD PTR [rsp+0xc0]
  21f7ce:	00 
            const amt_read = try self.read(buf);
  21f7cf:	66 85 ed             	test   bp,bp
  21f7d2:	0f 85 8c f9 ff ff    	jne    21f164 <openSelfDebugInfoLinux+0x1d4>
  21f7d8:	48 8b 84 24 c8 00 00 	mov    rax,QWORD PTR [rsp+0xc8]
  21f7df:	00 
  21f7e0:	66 bd 25 00          	mov    bp,0x25
            if (amt_read < buf.len) return error.EndOfStream;
  21f7e4:	48 3b 44 24 70       	cmp    rax,QWORD PTR [rsp+0x70]
  21f7e9:	0f 82 75 f9 ff ff    	jb     21f164 <openSelfDebugInfoLinux+0x1d4>
  21f7ef:	0f b6 44 24 10       	movzx  eax,BYTE PTR [rsp+0x10]
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  21f7f4:	0f b6 4c 24 11       	movzx  ecx,BYTE PTR [rsp+0x11]
  21f7f9:	89 ca                	mov    edx,ecx
  21f7fb:	c1 e2 08             	shl    edx,0x8
  21f7fe:	09 c2                	or     edx,eax
                result = (result << 8) | b;
  21f800:	c1 e0 08             	shl    eax,0x8
  21f803:	09 c8                	or     eax,ecx
    switch (endian) {
  21f805:	f6 44 24 30 01       	test   BYTE PTR [rsp+0x30],0x1
  21f80a:	66 0f 45 c2          	cmovne ax,dx
        if ((elf.is_64 and header_size != 64) or (!elf.is_64 and header_size != 52)) {
  21f80e:	8a 8c 24 81 01 00 00 	mov    cl,BYTE PTR [rsp+0x181]
  21f815:	80 f9 01             	cmp    cl,0x1
  21f818:	75 08                	jne    21f822 <openSelfDebugInfoLinux+0x892>
  21f81a:	0f b7 d0             	movzx  edx,ax
  21f81d:	83 fa 40             	cmp    edx,0x40
  21f820:	75 15                	jne    21f837 <openSelfDebugInfoLinux+0x8a7>
  21f822:	0f b7 c0             	movzx  eax,ax
  21f825:	83 f8 34             	cmp    eax,0x34
  21f828:	0f 84 a7 2e 00 00    	je     2226d5 <openSelfDebugInfoLinux+0x3745>
  21f82e:	80 f1 01             	xor    cl,0x1
  21f831:	0f 84 9e 2e 00 00    	je     2226d5 <openSelfDebugInfoLinux+0x3745>
  21f837:	66 bd 26 00          	mov    bp,0x26
  21f83b:	66 85 ed             	test   bp,bp
  21f83e:	0f 85 29 f9 ff ff    	jne    21f16d <openSelfDebugInfoLinux+0x1dd>
  21f844:	48 8d ac 24 78 01 00 	lea    rbp,[rsp+0x178]
  21f84b:	00 
    di.debug_info = (try di.elf.findSection(".debug_info")) orelse return error.MissingDebugInfo;
  21f84c:	48 8d 15 dd 05 03 00 	lea    rdx,[rip+0x305dd]        # 24fe30 <__unnamed_41>
  21f853:	48 8d bc 24 f0 03 00 	lea    rdi,[rsp+0x3f0]
  21f85a:	00 
  21f85b:	48 89 ee             	mov    rsi,rbp
  21f85e:	c5 f8 77             	vzeroupper 
  21f861:	e8 8a 43 00 00       	call   223bf0 <Elf_findSection>
  21f866:	66 83 bc 24 f0 03 00 	cmp    WORD PTR [rsp+0x3f0],0x0
  21f86d:	00 00 
  21f86f:	0f 84 95 00 00 00    	je     21f90a <openSelfDebugInfoLinux+0x97a>
        const bytes = @sliceToBytes(memory);
  21f875:	48 8b 84 24 b8 01 00 	mov    rax,QWORD PTR [rsp+0x1b8]
  21f87c:	00 
  21f87d:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  21f881:	74 2e                	je     21f8b1 <openSelfDebugInfoLinux+0x921>
  21f883:	48 8b bc 24 c0 01 00 	mov    rdi,QWORD PTR [rsp+0x1c0]
  21f88a:	00 
        const bytes = @sliceToBytes(memory);
  21f88b:	48 8b 8c 24 b0 01 00 	mov    rcx,QWORD PTR [rsp+0x1b0]
  21f892:	00 
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  21f893:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  21f897:	48 89 8c 24 c0 00 00 	mov    QWORD PTR [rsp+0xc0],rcx
  21f89e:	00 
  21f89f:	48 89 84 24 c8 00 00 	mov    QWORD PTR [rsp+0xc8],rax
  21f8a6:	00 
  21f8a7:	48 8d b4 24 c0 00 00 	lea    rsi,[rsp+0xc0]
  21f8ae:	00 
  21f8af:	ff d2                	call   rdx
    }

    pub fn close(elf: *Elf) void {
        elf.allocator.free(elf.section_headers);

        if (elf.auto_close_stream) elf.in_file.close();
  21f8b1:	80 bc 24 80 01 00 00 	cmp    BYTE PTR [rsp+0x180],0x1
  21f8b8:	01 
  21f8b9:	0f 85 e6 02 00 00    	jne    21fba5 <openSelfDebugInfoLinux+0xc15>
  21f8bf:	48 8b 84 24 78 01 00 	mov    rax,QWORD PTR [rsp+0x178]
  21f8c6:	00 
  21f8c7:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  21f8ca:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
    return asm volatile ("syscall"
  21f8d0:	b8 03 00 00 00       	mov    eax,0x3
  21f8d5:	0f 05                	syscall 
            switch (err) {
  21f8d7:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  21f8db:	74 f3                	je     21f8d0 <openSelfDebugInfoLinux+0x940>
            const first = list.first orelse return null;
  21f8dd:	48 8b 05 3c 17 03 00 	mov    rax,QWORD PTR [rip+0x3173c]        # 251020 <emfile_promise_queue>
  21f8e4:	48 85 c0             	test   rax,rax
  21f8e7:	0f 84 b8 02 00 00    	je     21fba5 <openSelfDebugInfoLinux+0xc15>
            if (node.prev) |prev_node| {
  21f8ed:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  21f8f0:	48 85 c9             	test   rcx,rcx
  21f8f3:	0f 84 3f 02 00 00    	je     21fb38 <openSelfDebugInfoLinux+0xba8>
                prev_node.next = node.next;
  21f8f9:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  21f8fd:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  21f901:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  21f905:	e9 39 02 00 00       	jmp    21fb43 <openSelfDebugInfoLinux+0xbb3>
  21f90a:	48 8b 84 24 f8 03 00 	mov    rax,QWORD PTR [rsp+0x3f8]
  21f911:	00 
  21f912:	48 85 c0             	test   rax,rax
  21f915:	0f 84 bf 00 00 00    	je     21f9da <openSelfDebugInfoLinux+0xa4a>
  21f91b:	48 89 84 24 d0 01 00 	mov    QWORD PTR [rsp+0x1d0],rax
  21f922:	00 
    di.debug_abbrev = (try di.elf.findSection(".debug_abbrev")) orelse return error.MissingDebugInfo;
  21f923:	48 8d 15 16 05 03 00 	lea    rdx,[rip+0x30516]        # 24fe40 <__unnamed_42>
  21f92a:	48 8d bc 24 e0 03 00 	lea    rdi,[rsp+0x3e0]
  21f931:	00 
  21f932:	48 89 ee             	mov    rsi,rbp
  21f935:	e8 b6 42 00 00       	call   223bf0 <Elf_findSection>
  21f93a:	66 83 bc 24 e0 03 00 	cmp    WORD PTR [rsp+0x3e0],0x0
  21f941:	00 00 
  21f943:	0f 84 21 01 00 00    	je     21fa6a <openSelfDebugInfoLinux+0xada>
        const bytes = @sliceToBytes(memory);
  21f949:	48 8b 84 24 b8 01 00 	mov    rax,QWORD PTR [rsp+0x1b8]
  21f950:	00 
  21f951:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  21f955:	74 2e                	je     21f985 <openSelfDebugInfoLinux+0x9f5>
  21f957:	48 8b bc 24 c0 01 00 	mov    rdi,QWORD PTR [rsp+0x1c0]
  21f95e:	00 
        const bytes = @sliceToBytes(memory);
  21f95f:	48 8b 8c 24 b0 01 00 	mov    rcx,QWORD PTR [rsp+0x1b0]
  21f966:	00 
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  21f967:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  21f96b:	48 89 8c 24 c0 00 00 	mov    QWORD PTR [rsp+0xc0],rcx
  21f972:	00 
  21f973:	48 89 84 24 c8 00 00 	mov    QWORD PTR [rsp+0xc8],rax
  21f97a:	00 
  21f97b:	48 8d b4 24 c0 00 00 	lea    rsi,[rsp+0xc0]
  21f982:	00 
  21f983:	ff d2                	call   rdx
  21f985:	80 bc 24 80 01 00 00 	cmp    BYTE PTR [rsp+0x180],0x1
  21f98c:	01 
  21f98d:	0f 85 02 05 00 00    	jne    21fe95 <openSelfDebugInfoLinux+0xf05>
  21f993:	48 8b 84 24 78 01 00 	mov    rax,QWORD PTR [rsp+0x178]
  21f99a:	00 
  21f99b:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  21f99e:	66 90                	xchg   ax,ax
  21f9a0:	b8 03 00 00 00       	mov    eax,0x3
  21f9a5:	0f 05                	syscall 
  21f9a7:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  21f9ab:	74 f3                	je     21f9a0 <openSelfDebugInfoLinux+0xa10>
            const first = list.first orelse return null;
  21f9ad:	48 8b 05 6c 16 03 00 	mov    rax,QWORD PTR [rip+0x3166c]        # 251020 <emfile_promise_queue>
  21f9b4:	48 85 c0             	test   rax,rax
  21f9b7:	0f 84 d8 04 00 00    	je     21fe95 <openSelfDebugInfoLinux+0xf05>
            if (node.prev) |prev_node| {
  21f9bd:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  21f9c0:	48 85 c9             	test   rcx,rcx
  21f9c3:	0f 84 64 04 00 00    	je     21fe2d <openSelfDebugInfoLinux+0xe9d>
                prev_node.next = node.next;
  21f9c9:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  21f9cd:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  21f9d1:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  21f9d5:	e9 5e 04 00 00       	jmp    21fe38 <openSelfDebugInfoLinux+0xea8>
        const bytes = @sliceToBytes(memory);
  21f9da:	48 8b 84 24 b8 01 00 	mov    rax,QWORD PTR [rsp+0x1b8]
  21f9e1:	00 
  21f9e2:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  21f9e6:	74 2e                	je     21fa16 <openSelfDebugInfoLinux+0xa86>
  21f9e8:	48 8b bc 24 c0 01 00 	mov    rdi,QWORD PTR [rsp+0x1c0]
  21f9ef:	00 
        const bytes = @sliceToBytes(memory);
  21f9f0:	48 8b 8c 24 b0 01 00 	mov    rcx,QWORD PTR [rsp+0x1b0]
  21f9f7:	00 
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  21f9f8:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  21f9fc:	48 89 8c 24 c0 00 00 	mov    QWORD PTR [rsp+0xc0],rcx
  21fa03:	00 
  21fa04:	48 89 84 24 c8 00 00 	mov    QWORD PTR [rsp+0xc8],rax
  21fa0b:	00 
  21fa0c:	48 8d b4 24 c0 00 00 	lea    rsi,[rsp+0xc0]
  21fa13:	00 
  21fa14:	ff d2                	call   rdx
  21fa16:	80 bc 24 80 01 00 00 	cmp    BYTE PTR [rsp+0x180],0x1
  21fa1d:	01 
  21fa1e:	0f 85 dc 05 00 00    	jne    220000 <openSelfDebugInfoLinux+0x1070>
  21fa24:	48 8b 84 24 78 01 00 	mov    rax,QWORD PTR [rsp+0x178]
  21fa2b:	00 
  21fa2c:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  21fa2f:	90                   	nop
  21fa30:	b8 03 00 00 00       	mov    eax,0x3
  21fa35:	0f 05                	syscall 
  21fa37:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  21fa3b:	74 f3                	je     21fa30 <openSelfDebugInfoLinux+0xaa0>
            const first = list.first orelse return null;
  21fa3d:	48 8b 05 dc 15 03 00 	mov    rax,QWORD PTR [rip+0x315dc]        # 251020 <emfile_promise_queue>
  21fa44:	48 85 c0             	test   rax,rax
  21fa47:	0f 84 b3 05 00 00    	je     220000 <openSelfDebugInfoLinux+0x1070>
            if (node.prev) |prev_node| {
  21fa4d:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  21fa50:	48 85 c9             	test   rcx,rcx
  21fa53:	0f 84 43 05 00 00    	je     21ff9c <openSelfDebugInfoLinux+0x100c>
                prev_node.next = node.next;
  21fa59:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  21fa5d:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  21fa61:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  21fa65:	e9 3d 05 00 00       	jmp    21ffa7 <openSelfDebugInfoLinux+0x1017>
  21fa6a:	48 8b 84 24 e8 03 00 	mov    rax,QWORD PTR [rsp+0x3e8]
  21fa71:	00 
  21fa72:	48 85 c0             	test   rax,rax
  21fa75:	0f 84 55 02 00 00    	je     21fcd0 <openSelfDebugInfoLinux+0xd40>
  21fa7b:	48 89 84 24 d8 01 00 	mov    QWORD PTR [rsp+0x1d8],rax
  21fa82:	00 
    di.debug_str = (try di.elf.findSection(".debug_str")) orelse return error.MissingDebugInfo;
  21fa83:	48 8d 15 c6 03 03 00 	lea    rdx,[rip+0x303c6]        # 24fe50 <__unnamed_43>
  21fa8a:	48 8d bc 24 d0 03 00 	lea    rdi,[rsp+0x3d0]
  21fa91:	00 
  21fa92:	48 89 ee             	mov    rsi,rbp
  21fa95:	e8 56 41 00 00       	call   223bf0 <Elf_findSection>
  21fa9a:	66 83 bc 24 d0 03 00 	cmp    WORD PTR [rsp+0x3d0],0x0
  21faa1:	00 00 
  21faa3:	0f 84 b6 02 00 00    	je     21fd5f <openSelfDebugInfoLinux+0xdcf>
        const bytes = @sliceToBytes(memory);
  21faa9:	48 8b 84 24 b8 01 00 	mov    rax,QWORD PTR [rsp+0x1b8]
  21fab0:	00 
  21fab1:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  21fab5:	74 2e                	je     21fae5 <openSelfDebugInfoLinux+0xb55>
  21fab7:	48 8b bc 24 c0 01 00 	mov    rdi,QWORD PTR [rsp+0x1c0]
  21fabe:	00 
        const bytes = @sliceToBytes(memory);
  21fabf:	48 8b 8c 24 b0 01 00 	mov    rcx,QWORD PTR [rsp+0x1b0]
  21fac6:	00 
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  21fac7:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  21facb:	48 89 8c 24 c0 00 00 	mov    QWORD PTR [rsp+0xc0],rcx
  21fad2:	00 
  21fad3:	48 89 84 24 c8 00 00 	mov    QWORD PTR [rsp+0xc8],rax
  21fada:	00 
  21fadb:	48 8d b4 24 c0 00 00 	lea    rsi,[rsp+0xc0]
  21fae2:	00 
  21fae3:	ff d2                	call   rdx
  21fae5:	80 bc 24 80 01 00 00 	cmp    BYTE PTR [rsp+0x180],0x1
  21faec:	01 
  21faed:	0f 85 db 07 00 00    	jne    2202ce <openSelfDebugInfoLinux+0x133e>
  21faf3:	48 8b 84 24 78 01 00 	mov    rax,QWORD PTR [rsp+0x178]
  21fafa:	00 
  21fafb:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  21fafe:	b8 03 00 00 00       	mov    eax,0x3
  21fb03:	0f 05                	syscall 
  21fb05:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  21fb09:	74 f3                	je     21fafe <openSelfDebugInfoLinux+0xb6e>
            const first = list.first orelse return null;
  21fb0b:	48 8b 05 0e 15 03 00 	mov    rax,QWORD PTR [rip+0x3150e]        # 251020 <emfile_promise_queue>
  21fb12:	48 85 c0             	test   rax,rax
  21fb15:	0f 84 b3 07 00 00    	je     2202ce <openSelfDebugInfoLinux+0x133e>
            if (node.prev) |prev_node| {
  21fb1b:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  21fb1e:	48 85 c9             	test   rcx,rcx
  21fb21:	0f 84 43 07 00 00    	je     22026a <openSelfDebugInfoLinux+0x12da>
                prev_node.next = node.next;
  21fb27:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  21fb2b:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  21fb2f:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  21fb33:	e9 3d 07 00 00       	jmp    220275 <openSelfDebugInfoLinux+0x12e5>
                list.first = node.next;
  21fb38:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  21fb3c:	48 89 0d dd 14 03 00 	mov    QWORD PTR [rip+0x314dd],rcx        # 251020 <emfile_promise_queue>
            if (node.next) |next_node| {
  21fb43:	48 85 c9             	test   rcx,rcx
  21fb46:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  21fb49:	48 8d 35 d8 14 03 00 	lea    rsi,[rip+0x314d8]        # 251028 <emfile_promise_queue+0x8>
  21fb50:	48 0f 45 f1          	cmovne rsi,rcx
  21fb54:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  21fb57:	48 83 05 d1 14 03 00 	add    QWORD PTR [rip+0x314d1],0xffffffffffffffff        # 251030 <emfile_promise_queue+0x10>
  21fb5e:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  21fb5f:	74 1e                	je     21fb7f <openSelfDebugInfoLinux+0xbef>
  21fb61:	48 83 3d b7 14 03 00 	cmp    QWORD PTR [rip+0x314b7],0x0        # 251020 <emfile_promise_queue>
  21fb68:	00 
  21fb69:	0f 84 67 35 00 00    	je     2230d6 <openSelfDebugInfoLinux+0x4146>
  21fb6f:	48 8b 0d b2 14 03 00 	mov    rcx,QWORD PTR [rip+0x314b2]        # 251028 <emfile_promise_queue+0x8>
  21fb76:	48 85 c9             	test   rcx,rcx
  21fb79:	0f 84 57 35 00 00    	je     2230d6 <openSelfDebugInfoLinux+0x4146>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  21fb7f:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  21fb83:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  21fb87:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  21fb8e:	00 00 
  21fb90:	48 89 c1             	mov    rcx,rax
  21fb93:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  21fb97:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  21fb9d:	75 f1                	jne    21fb90 <openSelfDebugInfoLinux+0xc00>
  21fb9f:	a8 01                	test   al,0x1
  21fba1:	75 02                	jne    21fba5 <openSelfDebugInfoLinux+0xc15>
  21fba3:	ff 17                	call   QWORD PTR [rdi]
  21fba5:	48 63 bc 24 70 01 00 	movsxd rdi,DWORD PTR [rsp+0x170]
  21fbac:	00 
  21fbad:	0f 1f 00             	nop    DWORD PTR [rax]
  21fbb0:	b8 03 00 00 00       	mov    eax,0x3
  21fbb5:	0f 05                	syscall 
            switch (err) {
  21fbb7:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  21fbbb:	74 f3                	je     21fbb0 <openSelfDebugInfoLinux+0xc20>
            const first = list.first orelse return null;
  21fbbd:	48 8b 05 5c 14 03 00 	mov    rax,QWORD PTR [rip+0x3145c]        # 251020 <emfile_promise_queue>
  21fbc4:	48 85 c0             	test   rax,rax
  21fbc7:	74 7c                	je     21fc45 <openSelfDebugInfoLinux+0xcb5>
            if (node.prev) |prev_node| {
  21fbc9:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  21fbcc:	48 85 c9             	test   rcx,rcx
  21fbcf:	74 0e                	je     21fbdf <openSelfDebugInfoLinux+0xc4f>
                prev_node.next = node.next;
  21fbd1:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  21fbd5:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  21fbd9:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  21fbdd:	eb 0b                	jmp    21fbea <openSelfDebugInfoLinux+0xc5a>
                list.first = node.next;
  21fbdf:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  21fbe3:	48 89 0d 36 14 03 00 	mov    QWORD PTR [rip+0x31436],rcx        # 251020 <emfile_promise_queue>
            if (node.next) |next_node| {
  21fbea:	48 85 c9             	test   rcx,rcx
  21fbed:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  21fbf0:	48 8d 35 31 14 03 00 	lea    rsi,[rip+0x31431]        # 251028 <emfile_promise_queue+0x8>
  21fbf7:	48 0f 45 f1          	cmovne rsi,rcx
  21fbfb:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  21fbfe:	48 83 05 2a 14 03 00 	add    QWORD PTR [rip+0x3142a],0xffffffffffffffff        # 251030 <emfile_promise_queue+0x10>
  21fc05:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  21fc06:	74 1e                	je     21fc26 <openSelfDebugInfoLinux+0xc96>
  21fc08:	48 83 3d 10 14 03 00 	cmp    QWORD PTR [rip+0x31410],0x0        # 251020 <emfile_promise_queue>
  21fc0f:	00 
  21fc10:	0f 84 c0 34 00 00    	je     2230d6 <openSelfDebugInfoLinux+0x4146>
  21fc16:	48 8b 0d 0b 14 03 00 	mov    rcx,QWORD PTR [rip+0x3140b]        # 251028 <emfile_promise_queue+0x8>
  21fc1d:	48 85 c9             	test   rcx,rcx
  21fc20:	0f 84 b0 34 00 00    	je     2230d6 <openSelfDebugInfoLinux+0x4146>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  21fc26:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  21fc2a:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  21fc2e:	66 90                	xchg   ax,ax
  21fc30:	48 89 c1             	mov    rcx,rax
  21fc33:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  21fc37:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  21fc3d:	75 f1                	jne    21fc30 <openSelfDebugInfoLinux+0xca0>
  21fc3f:	a8 01                	test   al,0x1
  21fc41:	75 02                	jne    21fc45 <openSelfDebugInfoLinux+0xcb5>
  21fc43:	ff 17                	call   QWORD PTR [rdi]
    di.debug_info = (try di.elf.findSection(".debug_info")) orelse return error.MissingDebugInfo;
  21fc45:	0f b7 84 24 f0 03 00 	movzx  eax,WORD PTR [rsp+0x3f0]
  21fc4c:	00 
  21fc4d:	66 89 03             	mov    WORD PTR [rbx],ax
  21fc50:	c5 fc 10 84 24 4c 0b 	vmovups ymm0,YMMWORD PTR [rsp+0xb4c]
  21fc57:	00 00 
  21fc59:	c5 fc 11 83 b0 00 00 	vmovups YMMWORD PTR [rbx+0xb0],ymm0
  21fc60:	00 
  21fc61:	c5 fc 10 84 24 3e 0b 	vmovups ymm0,YMMWORD PTR [rsp+0xb3e]
  21fc68:	00 00 
  21fc6a:	c5 fc 11 83 a2 00 00 	vmovups YMMWORD PTR [rbx+0xa2],ymm0
  21fc71:	00 
  21fc72:	c5 fc 10 84 24 1e 0b 	vmovups ymm0,YMMWORD PTR [rsp+0xb1e]
  21fc79:	00 00 
  21fc7b:	c5 fc 11 83 82 00 00 	vmovups YMMWORD PTR [rbx+0x82],ymm0
  21fc82:	00 
  21fc83:	c5 fc 10 84 24 9e 0a 	vmovups ymm0,YMMWORD PTR [rsp+0xa9e]
  21fc8a:	00 00 
  21fc8c:	c5 fc 10 8c 24 be 0a 	vmovups ymm1,YMMWORD PTR [rsp+0xabe]
  21fc93:	00 00 
  21fc95:	c5 fc 10 94 24 de 0a 	vmovups ymm2,YMMWORD PTR [rsp+0xade]
  21fc9c:	00 00 
  21fc9e:	c5 fc 10 9c 24 fe 0a 	vmovups ymm3,YMMWORD PTR [rsp+0xafe]
  21fca5:	00 00 
  21fca7:	c5 fc 11 5b 62       	vmovups YMMWORD PTR [rbx+0x62],ymm3
  21fcac:	c5 fc 11 53 42       	vmovups YMMWORD PTR [rbx+0x42],ymm2
  21fcb1:	c5 fc 11 4b 22       	vmovups YMMWORD PTR [rbx+0x22],ymm1
  21fcb6:	c5 fc 11 43 02       	vmovups YMMWORD PTR [rbx+0x2],ymm0
  21fcbb:	48 81 c4 08 0d 00 00 	add    rsp,0xd08
  21fcc2:	5b                   	pop    rbx
  21fcc3:	41 5c                	pop    r12
  21fcc5:	41 5d                	pop    r13
  21fcc7:	41 5e                	pop    r14
  21fcc9:	41 5f                	pop    r15
  21fccb:	5d                   	pop    rbp
  21fccc:	c5 f8 77             	vzeroupper 
  21fccf:	c3                   	ret    
        const bytes = @sliceToBytes(memory);
  21fcd0:	48 8b 84 24 b8 01 00 	mov    rax,QWORD PTR [rsp+0x1b8]
  21fcd7:	00 
  21fcd8:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  21fcdc:	74 2e                	je     21fd0c <openSelfDebugInfoLinux+0xd7c>
  21fcde:	48 8b bc 24 c0 01 00 	mov    rdi,QWORD PTR [rsp+0x1c0]
  21fce5:	00 
        const bytes = @sliceToBytes(memory);
  21fce6:	48 8b 8c 24 b0 01 00 	mov    rcx,QWORD PTR [rsp+0x1b0]
  21fced:	00 
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  21fcee:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  21fcf2:	48 89 8c 24 c0 00 00 	mov    QWORD PTR [rsp+0xc0],rcx
  21fcf9:	00 
  21fcfa:	48 89 84 24 c8 00 00 	mov    QWORD PTR [rsp+0xc8],rax
  21fd01:	00 
  21fd02:	48 8d b4 24 c0 00 00 	lea    rsi,[rsp+0xc0]
  21fd09:	00 
  21fd0a:	ff d2                	call   rdx
  21fd0c:	80 bc 24 80 01 00 00 	cmp    BYTE PTR [rsp+0x180],0x1
  21fd13:	01 
  21fd14:	0f 85 1a 07 00 00    	jne    220434 <openSelfDebugInfoLinux+0x14a4>
  21fd1a:	48 8b 84 24 78 01 00 	mov    rax,QWORD PTR [rsp+0x178]
  21fd21:	00 
  21fd22:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  21fd25:	b8 03 00 00 00       	mov    eax,0x3
  21fd2a:	0f 05                	syscall 
            switch (err) {
  21fd2c:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  21fd30:	74 f3                	je     21fd25 <openSelfDebugInfoLinux+0xd95>
            const first = list.first orelse return null;
  21fd32:	48 8b 05 e7 12 03 00 	mov    rax,QWORD PTR [rip+0x312e7]        # 251020 <emfile_promise_queue>
  21fd39:	48 85 c0             	test   rax,rax
  21fd3c:	0f 84 f2 06 00 00    	je     220434 <openSelfDebugInfoLinux+0x14a4>
            if (node.prev) |prev_node| {
  21fd42:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  21fd45:	48 85 c9             	test   rcx,rcx
  21fd48:	0f 84 82 06 00 00    	je     2203d0 <openSelfDebugInfoLinux+0x1440>
                prev_node.next = node.next;
  21fd4e:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  21fd52:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  21fd56:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  21fd5a:	e9 7c 06 00 00       	jmp    2203db <openSelfDebugInfoLinux+0x144b>
    di.debug_str = (try di.elf.findSection(".debug_str")) orelse return error.MissingDebugInfo;
  21fd5f:	48 8b 84 24 d8 03 00 	mov    rax,QWORD PTR [rsp+0x3d8]
  21fd66:	00 
  21fd67:	48 85 c0             	test   rax,rax
  21fd6a:	0f 84 9d 03 00 00    	je     22010d <openSelfDebugInfoLinux+0x117d>
  21fd70:	48 89 84 24 e0 01 00 	mov    QWORD PTR [rsp+0x1e0],rax
  21fd77:	00 
    di.debug_line = (try di.elf.findSection(".debug_line")) orelse return error.MissingDebugInfo;
  21fd78:	48 8d 15 e1 00 03 00 	lea    rdx,[rip+0x300e1]        # 24fe60 <__unnamed_44>
  21fd7f:	48 8d bc 24 c0 03 00 	lea    rdi,[rsp+0x3c0]
  21fd86:	00 
  21fd87:	48 89 ee             	mov    rsi,rbp
  21fd8a:	e8 61 3e 00 00       	call   223bf0 <Elf_findSection>
  21fd8f:	66 83 bc 24 c0 03 00 	cmp    WORD PTR [rsp+0x3c0],0x0
  21fd96:	00 00 
  21fd98:	0f 84 fe 03 00 00    	je     22019c <openSelfDebugInfoLinux+0x120c>
        const bytes = @sliceToBytes(memory);
  21fd9e:	48 8b 84 24 b8 01 00 	mov    rax,QWORD PTR [rsp+0x1b8]
  21fda5:	00 
  21fda6:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  21fdaa:	74 2e                	je     21fdda <openSelfDebugInfoLinux+0xe4a>
  21fdac:	48 8b bc 24 c0 01 00 	mov    rdi,QWORD PTR [rsp+0x1c0]
  21fdb3:	00 
        const bytes = @sliceToBytes(memory);
  21fdb4:	48 8b 8c 24 b0 01 00 	mov    rcx,QWORD PTR [rsp+0x1b0]
  21fdbb:	00 
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  21fdbc:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  21fdc0:	48 89 8c 24 c0 00 00 	mov    QWORD PTR [rsp+0xc0],rcx
  21fdc7:	00 
  21fdc8:	48 89 84 24 c8 00 00 	mov    QWORD PTR [rsp+0xc8],rax
  21fdcf:	00 
  21fdd0:	48 8d b4 24 c0 00 00 	lea    rsi,[rsp+0xc0]
  21fdd7:	00 
  21fdd8:	ff d2                	call   rdx
  21fdda:	80 bc 24 80 01 00 00 	cmp    BYTE PTR [rsp+0x180],0x1
  21fde1:	01 
  21fde2:	0f 85 0c 1d 00 00    	jne    221af4 <openSelfDebugInfoLinux+0x2b64>
  21fde8:	48 8b 84 24 78 01 00 	mov    rax,QWORD PTR [rsp+0x178]
  21fdef:	00 
  21fdf0:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  21fdf3:	b8 03 00 00 00       	mov    eax,0x3
  21fdf8:	0f 05                	syscall 
  21fdfa:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  21fdfe:	74 f3                	je     21fdf3 <openSelfDebugInfoLinux+0xe63>
            const first = list.first orelse return null;
  21fe00:	48 8b 05 19 12 03 00 	mov    rax,QWORD PTR [rip+0x31219]        # 251020 <emfile_promise_queue>
  21fe07:	48 85 c0             	test   rax,rax
  21fe0a:	0f 84 e4 1c 00 00    	je     221af4 <openSelfDebugInfoLinux+0x2b64>
            if (node.prev) |prev_node| {
  21fe10:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  21fe13:	48 85 c9             	test   rcx,rcx
  21fe16:	0f 84 74 1c 00 00    	je     221a90 <openSelfDebugInfoLinux+0x2b00>
                prev_node.next = node.next;
  21fe1c:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  21fe20:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  21fe24:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  21fe28:	e9 6e 1c 00 00       	jmp    221a9b <openSelfDebugInfoLinux+0x2b0b>
                list.first = node.next;
  21fe2d:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  21fe31:	48 89 0d e8 11 03 00 	mov    QWORD PTR [rip+0x311e8],rcx        # 251020 <emfile_promise_queue>
            if (node.next) |next_node| {
  21fe38:	48 85 c9             	test   rcx,rcx
  21fe3b:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  21fe3e:	48 8d 35 e3 11 03 00 	lea    rsi,[rip+0x311e3]        # 251028 <emfile_promise_queue+0x8>
  21fe45:	48 0f 45 f1          	cmovne rsi,rcx
  21fe49:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  21fe4c:	48 83 05 dc 11 03 00 	add    QWORD PTR [rip+0x311dc],0xffffffffffffffff        # 251030 <emfile_promise_queue+0x10>
  21fe53:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  21fe54:	74 1e                	je     21fe74 <openSelfDebugInfoLinux+0xee4>
  21fe56:	48 83 3d c2 11 03 00 	cmp    QWORD PTR [rip+0x311c2],0x0        # 251020 <emfile_promise_queue>
  21fe5d:	00 
  21fe5e:	0f 84 72 32 00 00    	je     2230d6 <openSelfDebugInfoLinux+0x4146>
  21fe64:	48 8b 0d bd 11 03 00 	mov    rcx,QWORD PTR [rip+0x311bd]        # 251028 <emfile_promise_queue+0x8>
  21fe6b:	48 85 c9             	test   rcx,rcx
  21fe6e:	0f 84 62 32 00 00    	je     2230d6 <openSelfDebugInfoLinux+0x4146>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  21fe74:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  21fe78:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  21fe7c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  21fe80:	48 89 c1             	mov    rcx,rax
  21fe83:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  21fe87:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  21fe8d:	75 f1                	jne    21fe80 <openSelfDebugInfoLinux+0xef0>
  21fe8f:	a8 01                	test   al,0x1
  21fe91:	75 02                	jne    21fe95 <openSelfDebugInfoLinux+0xf05>
  21fe93:	ff 17                	call   QWORD PTR [rdi]
  21fe95:	48 63 bc 24 70 01 00 	movsxd rdi,DWORD PTR [rsp+0x170]
  21fe9c:	00 
  21fe9d:	0f 1f 00             	nop    DWORD PTR [rax]
  21fea0:	b8 03 00 00 00       	mov    eax,0x3
  21fea5:	0f 05                	syscall 
            switch (err) {
  21fea7:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  21feab:	74 f3                	je     21fea0 <openSelfDebugInfoLinux+0xf10>
            const first = list.first orelse return null;
  21fead:	48 8b 05 6c 11 03 00 	mov    rax,QWORD PTR [rip+0x3116c]        # 251020 <emfile_promise_queue>
  21feb4:	48 85 c0             	test   rax,rax
  21feb7:	74 7c                	je     21ff35 <openSelfDebugInfoLinux+0xfa5>
            if (node.prev) |prev_node| {
  21feb9:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  21febc:	48 85 c9             	test   rcx,rcx
  21febf:	74 0e                	je     21fecf <openSelfDebugInfoLinux+0xf3f>
                prev_node.next = node.next;
  21fec1:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  21fec5:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  21fec9:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  21fecd:	eb 0b                	jmp    21feda <openSelfDebugInfoLinux+0xf4a>
                list.first = node.next;
  21fecf:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  21fed3:	48 89 0d 46 11 03 00 	mov    QWORD PTR [rip+0x31146],rcx        # 251020 <emfile_promise_queue>
            if (node.next) |next_node| {
  21feda:	48 85 c9             	test   rcx,rcx
  21fedd:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  21fee0:	48 8d 35 41 11 03 00 	lea    rsi,[rip+0x31141]        # 251028 <emfile_promise_queue+0x8>
  21fee7:	48 0f 45 f1          	cmovne rsi,rcx
  21feeb:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  21feee:	48 83 05 3a 11 03 00 	add    QWORD PTR [rip+0x3113a],0xffffffffffffffff        # 251030 <emfile_promise_queue+0x10>
  21fef5:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  21fef6:	74 1e                	je     21ff16 <openSelfDebugInfoLinux+0xf86>
  21fef8:	48 83 3d 20 11 03 00 	cmp    QWORD PTR [rip+0x31120],0x0        # 251020 <emfile_promise_queue>
  21feff:	00 
  21ff00:	0f 84 d0 31 00 00    	je     2230d6 <openSelfDebugInfoLinux+0x4146>
  21ff06:	48 8b 0d 1b 11 03 00 	mov    rcx,QWORD PTR [rip+0x3111b]        # 251028 <emfile_promise_queue+0x8>
  21ff0d:	48 85 c9             	test   rcx,rcx
  21ff10:	0f 84 c0 31 00 00    	je     2230d6 <openSelfDebugInfoLinux+0x4146>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  21ff16:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  21ff1a:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  21ff1e:	66 90                	xchg   ax,ax
  21ff20:	48 89 c1             	mov    rcx,rax
  21ff23:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  21ff27:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  21ff2d:	75 f1                	jne    21ff20 <openSelfDebugInfoLinux+0xf90>
  21ff2f:	a8 01                	test   al,0x1
  21ff31:	75 02                	jne    21ff35 <openSelfDebugInfoLinux+0xfa5>
  21ff33:	ff 17                	call   QWORD PTR [rdi]
    di.debug_abbrev = (try di.elf.findSection(".debug_abbrev")) orelse return error.MissingDebugInfo;
  21ff35:	0f b7 84 24 e0 03 00 	movzx  eax,WORD PTR [rsp+0x3e0]
  21ff3c:	00 
  21ff3d:	66 89 03             	mov    WORD PTR [rbx],ax
  21ff40:	c5 fc 10 84 24 7e 0a 	vmovups ymm0,YMMWORD PTR [rsp+0xa7e]
  21ff47:	00 00 
  21ff49:	c5 fc 11 83 b0 00 00 	vmovups YMMWORD PTR [rbx+0xb0],ymm0
  21ff50:	00 
  21ff51:	c5 fc 10 84 24 70 0a 	vmovups ymm0,YMMWORD PTR [rsp+0xa70]
  21ff58:	00 00 
  21ff5a:	c5 fc 11 83 a2 00 00 	vmovups YMMWORD PTR [rbx+0xa2],ymm0
  21ff61:	00 
  21ff62:	c5 fc 10 84 24 50 0a 	vmovups ymm0,YMMWORD PTR [rsp+0xa50]
  21ff69:	00 00 
  21ff6b:	c5 fc 11 83 82 00 00 	vmovups YMMWORD PTR [rbx+0x82],ymm0
  21ff72:	00 
  21ff73:	c5 fc 10 84 24 d0 09 	vmovups ymm0,YMMWORD PTR [rsp+0x9d0]
  21ff7a:	00 00 
  21ff7c:	c5 fc 10 8c 24 f0 09 	vmovups ymm1,YMMWORD PTR [rsp+0x9f0]
  21ff83:	00 00 
  21ff85:	c5 fc 10 94 24 10 0a 	vmovups ymm2,YMMWORD PTR [rsp+0xa10]
  21ff8c:	00 00 
  21ff8e:	c5 fc 10 9c 24 30 0a 	vmovups ymm3,YMMWORD PTR [rsp+0xa30]
  21ff95:	00 00 
  21ff97:	e9 0b fd ff ff       	jmp    21fca7 <openSelfDebugInfoLinux+0xd17>
                list.first = node.next;
  21ff9c:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  21ffa0:	48 89 0d 79 10 03 00 	mov    QWORD PTR [rip+0x31079],rcx        # 251020 <emfile_promise_queue>
            if (node.next) |next_node| {
  21ffa7:	48 85 c9             	test   rcx,rcx
  21ffaa:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  21ffad:	48 8d 35 74 10 03 00 	lea    rsi,[rip+0x31074]        # 251028 <emfile_promise_queue+0x8>
  21ffb4:	48 0f 45 f1          	cmovne rsi,rcx
  21ffb8:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  21ffbb:	48 83 05 6d 10 03 00 	add    QWORD PTR [rip+0x3106d],0xffffffffffffffff        # 251030 <emfile_promise_queue+0x10>
  21ffc2:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  21ffc3:	74 1e                	je     21ffe3 <openSelfDebugInfoLinux+0x1053>
  21ffc5:	48 83 3d 53 10 03 00 	cmp    QWORD PTR [rip+0x31053],0x0        # 251020 <emfile_promise_queue>
  21ffcc:	00 
  21ffcd:	0f 84 03 31 00 00    	je     2230d6 <openSelfDebugInfoLinux+0x4146>
  21ffd3:	48 8b 0d 4e 10 03 00 	mov    rcx,QWORD PTR [rip+0x3104e]        # 251028 <emfile_promise_queue+0x8>
  21ffda:	48 85 c9             	test   rcx,rcx
  21ffdd:	0f 84 f3 30 00 00    	je     2230d6 <openSelfDebugInfoLinux+0x4146>
  21ffe3:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  21ffe7:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  21ffeb:	48 89 c1             	mov    rcx,rax
  21ffee:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  21fff2:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  21fff8:	75 f1                	jne    21ffeb <openSelfDebugInfoLinux+0x105b>
  21fffa:	a8 01                	test   al,0x1
  21fffc:	75 02                	jne    220000 <openSelfDebugInfoLinux+0x1070>
  21fffe:	ff 17                	call   QWORD PTR [rdi]
  220000:	48 63 bc 24 70 01 00 	movsxd rdi,DWORD PTR [rsp+0x170]
  220007:	00 
  220008:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  22000f:	00 
  220010:	b8 03 00 00 00       	mov    eax,0x3
  220015:	0f 05                	syscall 
            switch (err) {
  220017:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  22001b:	74 f3                	je     220010 <openSelfDebugInfoLinux+0x1080>
            const first = list.first orelse return null;
  22001d:	48 8b 05 fc 0f 03 00 	mov    rax,QWORD PTR [rip+0x30ffc]        # 251020 <emfile_promise_queue>
  220024:	48 85 c0             	test   rax,rax
  220027:	74 7c                	je     2200a5 <openSelfDebugInfoLinux+0x1115>
            if (node.prev) |prev_node| {
  220029:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  22002c:	48 85 c9             	test   rcx,rcx
  22002f:	74 0e                	je     22003f <openSelfDebugInfoLinux+0x10af>
                prev_node.next = node.next;
  220031:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  220035:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  220039:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  22003d:	eb 0b                	jmp    22004a <openSelfDebugInfoLinux+0x10ba>
                list.first = node.next;
  22003f:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  220043:	48 89 0d d6 0f 03 00 	mov    QWORD PTR [rip+0x30fd6],rcx        # 251020 <emfile_promise_queue>
            if (node.next) |next_node| {
  22004a:	48 85 c9             	test   rcx,rcx
  22004d:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  220050:	48 8d 35 d1 0f 03 00 	lea    rsi,[rip+0x30fd1]        # 251028 <emfile_promise_queue+0x8>
  220057:	48 0f 45 f1          	cmovne rsi,rcx
  22005b:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  22005e:	48 83 05 ca 0f 03 00 	add    QWORD PTR [rip+0x30fca],0xffffffffffffffff        # 251030 <emfile_promise_queue+0x10>
  220065:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  220066:	74 1e                	je     220086 <openSelfDebugInfoLinux+0x10f6>
  220068:	48 83 3d b0 0f 03 00 	cmp    QWORD PTR [rip+0x30fb0],0x0        # 251020 <emfile_promise_queue>
  22006f:	00 
  220070:	0f 84 60 30 00 00    	je     2230d6 <openSelfDebugInfoLinux+0x4146>
  220076:	48 8b 0d ab 0f 03 00 	mov    rcx,QWORD PTR [rip+0x30fab]        # 251028 <emfile_promise_queue+0x8>
  22007d:	48 85 c9             	test   rcx,rcx
  220080:	0f 84 50 30 00 00    	je     2230d6 <openSelfDebugInfoLinux+0x4146>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  220086:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  22008a:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  22008e:	66 90                	xchg   ax,ax
  220090:	48 89 c1             	mov    rcx,rax
  220093:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  220097:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  22009d:	75 f1                	jne    220090 <openSelfDebugInfoLinux+0x1100>
  22009f:	a8 01                	test   al,0x1
  2200a1:	75 02                	jne    2200a5 <openSelfDebugInfoLinux+0x1115>
  2200a3:	ff 17                	call   QWORD PTR [rdi]
  2200a5:	c5 fc 10 05 bb 80 fe 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffe80bb]        # 208168 <__unnamed_45+0xb0>
  2200ac:	ff 
  2200ad:	c5 fc 11 83 b0 00 00 	vmovups YMMWORD PTR [rbx+0xb0],ymm0
  2200b4:	00 
  2200b5:	c5 fc 10 05 9b 80 fe 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffe809b]        # 208158 <__unnamed_45+0xa0>
  2200bc:	ff 
  2200bd:	c5 fc 11 83 a0 00 00 	vmovups YMMWORD PTR [rbx+0xa0],ymm0
  2200c4:	00 
  2200c5:	c5 fc 10 05 6b 80 fe 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffe806b]        # 208138 <__unnamed_45+0x80>
  2200cc:	ff 
  2200cd:	c5 fc 11 83 80 00 00 	vmovups YMMWORD PTR [rbx+0x80],ymm0
  2200d4:	00 
  2200d5:	c5 fc 10 05 3b 80 fe 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffe803b]        # 208118 <__unnamed_45+0x60>
  2200dc:	ff 
  2200dd:	c5 fc 11 43 60       	vmovups YMMWORD PTR [rbx+0x60],ymm0
  2200e2:	c5 fc 10 05 0e 80 fe 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffe800e]        # 2080f8 <__unnamed_45+0x40>
  2200e9:	ff 
  2200ea:	c5 fc 11 43 40       	vmovups YMMWORD PTR [rbx+0x40],ymm0
  2200ef:	c5 fc 10 05 e1 7f fe 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffe7fe1]        # 2080d8 <__unnamed_45+0x20>
  2200f6:	ff 
  2200f7:	c5 fc 11 43 20       	vmovups YMMWORD PTR [rbx+0x20],ymm0
  2200fc:	c5 fc 10 05 b4 7f fe 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffe7fb4]        # 2080b8 <__unnamed_45>
  220103:	ff 
  220104:	c5 fc 11 03          	vmovups YMMWORD PTR [rbx],ymm0
  220108:	e9 ae fb ff ff       	jmp    21fcbb <openSelfDebugInfoLinux+0xd2b>
        const bytes = @sliceToBytes(memory);
  22010d:	48 8b 84 24 b8 01 00 	mov    rax,QWORD PTR [rsp+0x1b8]
  220114:	00 
  220115:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  220119:	74 2e                	je     220149 <openSelfDebugInfoLinux+0x11b9>
  22011b:	48 8b bc 24 c0 01 00 	mov    rdi,QWORD PTR [rsp+0x1c0]
  220122:	00 
        const bytes = @sliceToBytes(memory);
  220123:	48 8b 8c 24 b0 01 00 	mov    rcx,QWORD PTR [rsp+0x1b0]
  22012a:	00 
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  22012b:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  22012f:	48 89 8c 24 c0 00 00 	mov    QWORD PTR [rsp+0xc0],rcx
  220136:	00 
  220137:	48 89 84 24 c8 00 00 	mov    QWORD PTR [rsp+0xc8],rax
  22013e:	00 
  22013f:	48 8d b4 24 c0 00 00 	lea    rsi,[rsp+0xc0]
  220146:	00 
  220147:	ff d2                	call   rdx
  220149:	80 bc 24 80 01 00 00 	cmp    BYTE PTR [rsp+0x180],0x1
  220150:	01 
  220151:	0f 85 03 1b 00 00    	jne    221c5a <openSelfDebugInfoLinux+0x2cca>
  220157:	48 8b 84 24 78 01 00 	mov    rax,QWORD PTR [rsp+0x178]
  22015e:	00 
  22015f:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  220162:	b8 03 00 00 00       	mov    eax,0x3
  220167:	0f 05                	syscall 
            switch (err) {
  220169:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  22016d:	74 f3                	je     220162 <openSelfDebugInfoLinux+0x11d2>
            const first = list.first orelse return null;
  22016f:	48 8b 05 aa 0e 03 00 	mov    rax,QWORD PTR [rip+0x30eaa]        # 251020 <emfile_promise_queue>
  220176:	48 85 c0             	test   rax,rax
  220179:	0f 84 db 1a 00 00    	je     221c5a <openSelfDebugInfoLinux+0x2cca>
            if (node.prev) |prev_node| {
  22017f:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  220182:	48 85 c9             	test   rcx,rcx
  220185:	0f 84 6b 1a 00 00    	je     221bf6 <openSelfDebugInfoLinux+0x2c66>
                prev_node.next = node.next;
  22018b:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  22018f:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  220193:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  220197:	e9 65 1a 00 00       	jmp    221c01 <openSelfDebugInfoLinux+0x2c71>
    di.debug_line = (try di.elf.findSection(".debug_line")) orelse return error.MissingDebugInfo;
  22019c:	48 8b 84 24 c8 03 00 	mov    rax,QWORD PTR [rsp+0x3c8]
  2201a3:	00 
  2201a4:	48 85 c0             	test   rax,rax
  2201a7:	0f 84 25 03 00 00    	je     2204d2 <openSelfDebugInfoLinux+0x1542>
  2201ad:	48 89 84 24 e8 01 00 	mov    QWORD PTR [rsp+0x1e8],rax
  2201b4:	00 
    di.debug_ranges = (try di.elf.findSection(".debug_ranges"));
  2201b5:	48 8d 15 b4 fc 02 00 	lea    rdx,[rip+0x2fcb4]        # 24fe70 <__unnamed_46>
  2201bc:	48 8d bc 24 b0 03 00 	lea    rdi,[rsp+0x3b0]
  2201c3:	00 
  2201c4:	48 89 ee             	mov    rsi,rbp
  2201c7:	e8 24 3a 00 00       	call   223bf0 <Elf_findSection>
  2201cc:	66 83 bc 24 b0 03 00 	cmp    WORD PTR [rsp+0x3b0],0x0
  2201d3:	00 00 
  2201d5:	0f 84 86 03 00 00    	je     220561 <openSelfDebugInfoLinux+0x15d1>
        const bytes = @sliceToBytes(memory);
  2201db:	48 8b 84 24 b8 01 00 	mov    rax,QWORD PTR [rsp+0x1b8]
  2201e2:	00 
  2201e3:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  2201e7:	74 2e                	je     220217 <openSelfDebugInfoLinux+0x1287>
  2201e9:	48 8b bc 24 c0 01 00 	mov    rdi,QWORD PTR [rsp+0x1c0]
  2201f0:	00 
        const bytes = @sliceToBytes(memory);
  2201f1:	48 8b 8c 24 b0 01 00 	mov    rcx,QWORD PTR [rsp+0x1b0]
  2201f8:	00 
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  2201f9:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  2201fd:	48 89 8c 24 c0 00 00 	mov    QWORD PTR [rsp+0xc0],rcx
  220204:	00 
  220205:	48 89 84 24 c8 00 00 	mov    QWORD PTR [rsp+0xc8],rax
  22020c:	00 
  22020d:	48 8d b4 24 c0 00 00 	lea    rsi,[rsp+0xc0]
  220214:	00 
  220215:	ff d2                	call   rdx
  220217:	80 bc 24 80 01 00 00 	cmp    BYTE PTR [rsp+0x180],0x1
  22021e:	01 
  22021f:	0f 85 1f 1c 00 00    	jne    221e44 <openSelfDebugInfoLinux+0x2eb4>
  220225:	48 8b 84 24 78 01 00 	mov    rax,QWORD PTR [rsp+0x178]
  22022c:	00 
  22022d:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  220230:	b8 03 00 00 00       	mov    eax,0x3
  220235:	0f 05                	syscall 
  220237:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  22023b:	74 f3                	je     220230 <openSelfDebugInfoLinux+0x12a0>
            const first = list.first orelse return null;
  22023d:	48 8b 05 dc 0d 03 00 	mov    rax,QWORD PTR [rip+0x30ddc]        # 251020 <emfile_promise_queue>
  220244:	48 85 c0             	test   rax,rax
  220247:	0f 84 f7 1b 00 00    	je     221e44 <openSelfDebugInfoLinux+0x2eb4>
            if (node.prev) |prev_node| {
  22024d:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  220250:	48 85 c9             	test   rcx,rcx
  220253:	0f 84 87 1b 00 00    	je     221de0 <openSelfDebugInfoLinux+0x2e50>
                prev_node.next = node.next;
  220259:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  22025d:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  220261:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  220265:	e9 81 1b 00 00       	jmp    221deb <openSelfDebugInfoLinux+0x2e5b>
                list.first = node.next;
  22026a:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  22026e:	48 89 0d ab 0d 03 00 	mov    QWORD PTR [rip+0x30dab],rcx        # 251020 <emfile_promise_queue>
            if (node.next) |next_node| {
  220275:	48 85 c9             	test   rcx,rcx
  220278:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  22027b:	48 8d 35 a6 0d 03 00 	lea    rsi,[rip+0x30da6]        # 251028 <emfile_promise_queue+0x8>
  220282:	48 0f 45 f1          	cmovne rsi,rcx
  220286:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  220289:	48 83 05 9f 0d 03 00 	add    QWORD PTR [rip+0x30d9f],0xffffffffffffffff        # 251030 <emfile_promise_queue+0x10>
  220290:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  220291:	74 1e                	je     2202b1 <openSelfDebugInfoLinux+0x1321>
  220293:	48 83 3d 85 0d 03 00 	cmp    QWORD PTR [rip+0x30d85],0x0        # 251020 <emfile_promise_queue>
  22029a:	00 
  22029b:	0f 84 35 2e 00 00    	je     2230d6 <openSelfDebugInfoLinux+0x4146>
  2202a1:	48 8b 0d 80 0d 03 00 	mov    rcx,QWORD PTR [rip+0x30d80]        # 251028 <emfile_promise_queue+0x8>
  2202a8:	48 85 c9             	test   rcx,rcx
  2202ab:	0f 84 25 2e 00 00    	je     2230d6 <openSelfDebugInfoLinux+0x4146>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  2202b1:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  2202b5:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  2202b9:	48 89 c1             	mov    rcx,rax
  2202bc:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  2202c0:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  2202c6:	75 f1                	jne    2202b9 <openSelfDebugInfoLinux+0x1329>
  2202c8:	a8 01                	test   al,0x1
  2202ca:	75 02                	jne    2202ce <openSelfDebugInfoLinux+0x133e>
  2202cc:	ff 17                	call   QWORD PTR [rdi]
  2202ce:	48 63 bc 24 70 01 00 	movsxd rdi,DWORD PTR [rsp+0x170]
  2202d5:	00 
  2202d6:	b8 03 00 00 00       	mov    eax,0x3
  2202db:	0f 05                	syscall 
            switch (err) {
  2202dd:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  2202e1:	74 f3                	je     2202d6 <openSelfDebugInfoLinux+0x1346>
            const first = list.first orelse return null;
  2202e3:	48 8b 05 36 0d 03 00 	mov    rax,QWORD PTR [rip+0x30d36]        # 251020 <emfile_promise_queue>
  2202ea:	48 85 c0             	test   rax,rax
  2202ed:	74 7a                	je     220369 <openSelfDebugInfoLinux+0x13d9>
            if (node.prev) |prev_node| {
  2202ef:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  2202f2:	48 85 c9             	test   rcx,rcx
  2202f5:	74 0e                	je     220305 <openSelfDebugInfoLinux+0x1375>
                prev_node.next = node.next;
  2202f7:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  2202fb:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  2202ff:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  220303:	eb 0b                	jmp    220310 <openSelfDebugInfoLinux+0x1380>
                list.first = node.next;
  220305:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  220309:	48 89 0d 10 0d 03 00 	mov    QWORD PTR [rip+0x30d10],rcx        # 251020 <emfile_promise_queue>
            if (node.next) |next_node| {
  220310:	48 85 c9             	test   rcx,rcx
  220313:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  220316:	48 8d 35 0b 0d 03 00 	lea    rsi,[rip+0x30d0b]        # 251028 <emfile_promise_queue+0x8>
  22031d:	48 0f 45 f1          	cmovne rsi,rcx
  220321:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  220324:	48 83 05 04 0d 03 00 	add    QWORD PTR [rip+0x30d04],0xffffffffffffffff        # 251030 <emfile_promise_queue+0x10>
  22032b:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  22032c:	74 1e                	je     22034c <openSelfDebugInfoLinux+0x13bc>
  22032e:	48 83 3d ea 0c 03 00 	cmp    QWORD PTR [rip+0x30cea],0x0        # 251020 <emfile_promise_queue>
  220335:	00 
  220336:	0f 84 9a 2d 00 00    	je     2230d6 <openSelfDebugInfoLinux+0x4146>
  22033c:	48 8b 0d e5 0c 03 00 	mov    rcx,QWORD PTR [rip+0x30ce5]        # 251028 <emfile_promise_queue+0x8>
  220343:	48 85 c9             	test   rcx,rcx
  220346:	0f 84 8a 2d 00 00    	je     2230d6 <openSelfDebugInfoLinux+0x4146>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  22034c:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  220350:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  220354:	48 89 c1             	mov    rcx,rax
  220357:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  22035b:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  220361:	75 f1                	jne    220354 <openSelfDebugInfoLinux+0x13c4>
  220363:	a8 01                	test   al,0x1
  220365:	75 02                	jne    220369 <openSelfDebugInfoLinux+0x13d9>
  220367:	ff 17                	call   QWORD PTR [rdi]
    di.debug_str = (try di.elf.findSection(".debug_str")) orelse return error.MissingDebugInfo;
  220369:	0f b7 84 24 d0 03 00 	movzx  eax,WORD PTR [rsp+0x3d0]
  220370:	00 
  220371:	66 89 03             	mov    WORD PTR [rbx],ax
  220374:	c5 fc 10 84 24 b0 09 	vmovups ymm0,YMMWORD PTR [rsp+0x9b0]
  22037b:	00 00 
  22037d:	c5 fc 11 83 b0 00 00 	vmovups YMMWORD PTR [rbx+0xb0],ymm0
  220384:	00 
  220385:	c5 fc 10 84 24 a2 09 	vmovups ymm0,YMMWORD PTR [rsp+0x9a2]
  22038c:	00 00 
  22038e:	c5 fc 11 83 a2 00 00 	vmovups YMMWORD PTR [rbx+0xa2],ymm0
  220395:	00 
  220396:	c5 fc 10 84 24 82 09 	vmovups ymm0,YMMWORD PTR [rsp+0x982]
  22039d:	00 00 
  22039f:	c5 fc 11 83 82 00 00 	vmovups YMMWORD PTR [rbx+0x82],ymm0
  2203a6:	00 
  2203a7:	c5 fc 10 84 24 02 09 	vmovups ymm0,YMMWORD PTR [rsp+0x902]
  2203ae:	00 00 
  2203b0:	c5 fc 10 8c 24 22 09 	vmovups ymm1,YMMWORD PTR [rsp+0x922]
  2203b7:	00 00 
  2203b9:	c5 fc 10 94 24 42 09 	vmovups ymm2,YMMWORD PTR [rsp+0x942]
  2203c0:	00 00 
  2203c2:	c5 fc 10 9c 24 62 09 	vmovups ymm3,YMMWORD PTR [rsp+0x962]
  2203c9:	00 00 
  2203cb:	e9 d7 f8 ff ff       	jmp    21fca7 <openSelfDebugInfoLinux+0xd17>
                list.first = node.next;
  2203d0:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  2203d4:	48 89 0d 45 0c 03 00 	mov    QWORD PTR [rip+0x30c45],rcx        # 251020 <emfile_promise_queue>
            if (node.next) |next_node| {
  2203db:	48 85 c9             	test   rcx,rcx
  2203de:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  2203e1:	48 8d 35 40 0c 03 00 	lea    rsi,[rip+0x30c40]        # 251028 <emfile_promise_queue+0x8>
  2203e8:	48 0f 45 f1          	cmovne rsi,rcx
  2203ec:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  2203ef:	48 83 05 39 0c 03 00 	add    QWORD PTR [rip+0x30c39],0xffffffffffffffff        # 251030 <emfile_promise_queue+0x10>
  2203f6:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  2203f7:	74 1e                	je     220417 <openSelfDebugInfoLinux+0x1487>
  2203f9:	48 83 3d 1f 0c 03 00 	cmp    QWORD PTR [rip+0x30c1f],0x0        # 251020 <emfile_promise_queue>
  220400:	00 
  220401:	0f 84 cf 2c 00 00    	je     2230d6 <openSelfDebugInfoLinux+0x4146>
  220407:	48 8b 0d 1a 0c 03 00 	mov    rcx,QWORD PTR [rip+0x30c1a]        # 251028 <emfile_promise_queue+0x8>
  22040e:	48 85 c9             	test   rcx,rcx
  220411:	0f 84 bf 2c 00 00    	je     2230d6 <openSelfDebugInfoLinux+0x4146>
  220417:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  22041b:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  22041f:	48 89 c1             	mov    rcx,rax
  220422:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  220426:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  22042c:	75 f1                	jne    22041f <openSelfDebugInfoLinux+0x148f>
  22042e:	a8 01                	test   al,0x1
  220430:	75 02                	jne    220434 <openSelfDebugInfoLinux+0x14a4>
  220432:	ff 17                	call   QWORD PTR [rdi]
  220434:	48 63 bc 24 70 01 00 	movsxd rdi,DWORD PTR [rsp+0x170]
  22043b:	00 
  22043c:	b8 03 00 00 00       	mov    eax,0x3
  220441:	0f 05                	syscall 
            switch (err) {
  220443:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  220447:	74 f3                	je     22043c <openSelfDebugInfoLinux+0x14ac>
            const first = list.first orelse return null;
  220449:	48 8b 05 d0 0b 03 00 	mov    rax,QWORD PTR [rip+0x30bd0]        # 251020 <emfile_promise_queue>
  220450:	48 85 c0             	test   rax,rax
  220453:	0f 84 4c fc ff ff    	je     2200a5 <openSelfDebugInfoLinux+0x1115>
            if (node.prev) |prev_node| {
  220459:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  22045c:	48 85 c9             	test   rcx,rcx
  22045f:	74 0e                	je     22046f <openSelfDebugInfoLinux+0x14df>
                prev_node.next = node.next;
  220461:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  220465:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  220469:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  22046d:	eb 0b                	jmp    22047a <openSelfDebugInfoLinux+0x14ea>
                list.first = node.next;
  22046f:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  220473:	48 89 0d a6 0b 03 00 	mov    QWORD PTR [rip+0x30ba6],rcx        # 251020 <emfile_promise_queue>
            if (node.next) |next_node| {
  22047a:	48 85 c9             	test   rcx,rcx
  22047d:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  220480:	48 8d 35 a1 0b 03 00 	lea    rsi,[rip+0x30ba1]        # 251028 <emfile_promise_queue+0x8>
  220487:	48 0f 45 f1          	cmovne rsi,rcx
  22048b:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  22048e:	48 83 05 9a 0b 03 00 	add    QWORD PTR [rip+0x30b9a],0xffffffffffffffff        # 251030 <emfile_promise_queue+0x10>
  220495:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  220496:	74 1e                	je     2204b6 <openSelfDebugInfoLinux+0x1526>
  220498:	48 83 3d 80 0b 03 00 	cmp    QWORD PTR [rip+0x30b80],0x0        # 251020 <emfile_promise_queue>
  22049f:	00 
  2204a0:	0f 84 30 2c 00 00    	je     2230d6 <openSelfDebugInfoLinux+0x4146>
  2204a6:	48 8b 0d 7b 0b 03 00 	mov    rcx,QWORD PTR [rip+0x30b7b]        # 251028 <emfile_promise_queue+0x8>
  2204ad:	48 85 c9             	test   rcx,rcx
  2204b0:	0f 84 20 2c 00 00    	je     2230d6 <openSelfDebugInfoLinux+0x4146>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  2204b6:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  2204ba:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  2204be:	48 89 c1             	mov    rcx,rax
  2204c1:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  2204c5:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  2204cb:	75 f1                	jne    2204be <openSelfDebugInfoLinux+0x152e>
  2204cd:	e9 cd fb ff ff       	jmp    22009f <openSelfDebugInfoLinux+0x110f>
        const bytes = @sliceToBytes(memory);
  2204d2:	48 8b 84 24 b8 01 00 	mov    rax,QWORD PTR [rsp+0x1b8]
  2204d9:	00 
  2204da:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  2204de:	74 2e                	je     22050e <openSelfDebugInfoLinux+0x157e>
  2204e0:	48 8b bc 24 c0 01 00 	mov    rdi,QWORD PTR [rsp+0x1c0]
  2204e7:	00 
        const bytes = @sliceToBytes(memory);
  2204e8:	48 8b 8c 24 b0 01 00 	mov    rcx,QWORD PTR [rsp+0x1b0]
  2204ef:	00 
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  2204f0:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  2204f4:	48 89 8c 24 c0 00 00 	mov    QWORD PTR [rsp+0xc0],rcx
  2204fb:	00 
  2204fc:	48 89 84 24 c8 00 00 	mov    QWORD PTR [rsp+0xc8],rax
  220503:	00 
  220504:	48 8d b4 24 c0 00 00 	lea    rsi,[rsp+0xc0]
  22050b:	00 
  22050c:	ff d2                	call   rdx
  22050e:	80 bc 24 80 01 00 00 	cmp    BYTE PTR [rsp+0x180],0x1
  220515:	01 
  220516:	0f 85 8e 1a 00 00    	jne    221faa <openSelfDebugInfoLinux+0x301a>
  22051c:	48 8b 84 24 78 01 00 	mov    rax,QWORD PTR [rsp+0x178]
  220523:	00 
  220524:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  220527:	b8 03 00 00 00       	mov    eax,0x3
  22052c:	0f 05                	syscall 
            switch (err) {
  22052e:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  220532:	74 f3                	je     220527 <openSelfDebugInfoLinux+0x1597>
            const first = list.first orelse return null;
  220534:	48 8b 05 e5 0a 03 00 	mov    rax,QWORD PTR [rip+0x30ae5]        # 251020 <emfile_promise_queue>
  22053b:	48 85 c0             	test   rax,rax
  22053e:	0f 84 66 1a 00 00    	je     221faa <openSelfDebugInfoLinux+0x301a>
            if (node.prev) |prev_node| {
  220544:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  220547:	48 85 c9             	test   rcx,rcx
  22054a:	0f 84 f6 19 00 00    	je     221f46 <openSelfDebugInfoLinux+0x2fb6>
                prev_node.next = node.next;
  220550:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  220554:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  220558:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  22055c:	e9 f0 19 00 00       	jmp    221f51 <openSelfDebugInfoLinux+0x2fc1>
    di.debug_ranges = (try di.elf.findSection(".debug_ranges"));
  220561:	48 8b 84 24 b8 03 00 	mov    rax,QWORD PTR [rsp+0x3b8]
  220568:	00 
  220569:	48 89 84 24 f0 01 00 	mov    QWORD PTR [rsp+0x1f0],rax
  220570:	00 
    const debug_info_end = st.debug_info.offset + st.debug_info.size;
  220571:	48 8b 84 24 d0 01 00 	mov    rax,QWORD PTR [rsp+0x1d0]
  220578:	00 
  220579:	48 8b 50 18          	mov    rdx,QWORD PTR [rax+0x18]
  22057d:	48 8b 48 20          	mov    rcx,QWORD PTR [rax+0x20]
    var in_file_stream = io.FileInStream.init(&st.self_exe_file);
  220581:	4c 89 ac 24 58 02 00 	mov    QWORD PTR [rsp+0x258],r13
  220588:	00 
  220589:	48 8d 05 d0 3b 00 00 	lea    rax,[rip+0x3bd0]        # 224160 <FileInStream_readFn>
  220590:	48 89 84 24 60 02 00 	mov    QWORD PTR [rsp+0x260],rax
  220597:	00 
    while (this_unit_offset < debug_info_end) {
  220598:	48 85 c9             	test   rcx,rcx
  22059b:	0f 84 57 17 00 00    	je     221cf8 <openSelfDebugInfoLinux+0x2d68>
  2205a1:	48 89 54 24 60       	mov    QWORD PTR [rsp+0x60],rdx
  2205a6:	48 01 d1             	add    rcx,rdx
  2205a9:	48 89 8c 24 a8 03 00 	mov    QWORD PTR [rsp+0x3a8],rcx
  2205b0:	00 
  2205b1:	c4 e2 7d 19 05 ce 06 	vbroadcastsd ymm0,QWORD PTR [rip+0xfffffffffffe06ce]        # 200c88 <__unnamed_622+0x10>
  2205b8:	fe ff 
  2205ba:	c5 fc 11 84 24 40 05 	vmovups YMMWORD PTR [rsp+0x540],ymm0
  2205c1:	00 00 
  2205c3:	c4 e2 7d 59 05 34 07 	vpbroadcastq ymm0,QWORD PTR [rip+0xfffffffffffe0734]        # 200d00 <__unnamed_621+0x48>
  2205ca:	fe ff 
  2205cc:	c5 fe 7f 84 24 20 05 	vmovdqu YMMWORD PTR [rsp+0x520],ymm0
  2205d3:	00 00 
  2205d5:	66 c7 84 24 5e 01 00 	mov    WORD PTR [rsp+0x15e],0x27
  2205dc:	00 27 00 
  2205df:	31 c0                	xor    eax,eax
  2205e1:	48 89 84 24 10 03 00 	mov    QWORD PTR [rsp+0x310],rax
  2205e8:	00 
  2205e9:	48 8b 4c 24 60       	mov    rcx,QWORD PTR [rsp+0x60]
    if (@maxValue(@typeOf(x)) > @maxValue(T) and x > @maxValue(T)) {
  2205ee:	48 85 c9             	test   rcx,rcx
  2205f1:	0f 88 df 1a 00 00    	js     2220d6 <openSelfDebugInfoLinux+0x3146>
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  2205f7:	48 63 bc 24 70 01 00 	movsxd rdi,DWORD PTR [rsp+0x170]
  2205fe:	00 
    return asm volatile ("syscall"
  2205ff:	b8 08 00 00 00       	mov    eax,0x8
  220604:	31 d2                	xor    edx,edx
  220606:	48 89 ce             	mov    rsi,rcx
  220609:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  22060b:	48 89 c1             	mov    rcx,rax
  22060e:	48 f7 d9             	neg    rcx
  220611:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  220617:	b8 00 00 00 00       	mov    eax,0x0
  22061c:	48 0f 46 c8          	cmovbe rcx,rax
        switch (builtin.os) {
            Os.linux, Os.macosx, Os.ios => {
                const ipos = try math.cast(isize, pos);
                const result = posix.lseek(self.handle, ipos, posix.SEEK_SET);
                const err = posix.getErrno(result);
                if (err > 0) {
  220620:	48 85 c9             	test   rcx,rcx
  220623:	0f 85 d1 1a 00 00    	jne    2220fa <openSelfDebugInfoLinux+0x316a>
            try self.readNoEof(bytes[0..]);
  220629:	48 8d 44 24 10       	lea    rax,[rsp+0x10]
  22062e:	48 89 44 24 68       	mov    QWORD PTR [rsp+0x68],rax
  220633:	48 c7 44 24 70 04 00 	mov    QWORD PTR [rsp+0x70],0x4
  22063a:	00 00 
            return self.readFn(self, buffer);
  22063c:	4c 89 f7             	mov    rdi,r14
  22063f:	48 8d b4 24 60 02 00 	lea    rsi,[rsp+0x260]
  220646:	00 
  220647:	48 8d 54 24 68       	lea    rdx,[rsp+0x68]
  22064c:	c5 f8 77             	vzeroupper 
  22064f:	ff 94 24 60 02 00 00 	call   QWORD PTR [rsp+0x260]
  220656:	0f b7 8c 24 c0 00 00 	movzx  ecx,WORD PTR [rsp+0xc0]
  22065d:	00 
  22065e:	89 c8                	mov    eax,ecx
            const amt_read = try self.read(buf);
  220660:	66 85 c9             	test   cx,cx
  220663:	0f 85 1f 1a 00 00    	jne    222088 <openSelfDebugInfoLinux+0x30f8>
  220669:	48 8b 84 24 c8 00 00 	mov    rax,QWORD PTR [rsp+0xc8]
  220670:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  220671:	48 3b 44 24 70       	cmp    rax,QWORD PTR [rsp+0x70]
  220676:	0f 82 08 1a 00 00    	jb     222084 <openSelfDebugInfoLinux+0x30f4>
  22067c:	0f b6 44 24 10       	movzx  eax,BYTE PTR [rsp+0x10]
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  220681:	0f b6 4c 24 11       	movzx  ecx,BYTE PTR [rsp+0x11]
  220686:	48 c1 e1 08          	shl    rcx,0x8
  22068a:	48 09 c1             	or     rcx,rax
  22068d:	0f b6 44 24 12       	movzx  eax,BYTE PTR [rsp+0x12]
  220692:	48 c1 e0 10          	shl    rax,0x10
  220696:	48 09 c8             	or     rax,rcx
  220699:	0f b6 4c 24 13       	movzx  ecx,BYTE PTR [rsp+0x13]
  22069e:	48 c1 e1 18          	shl    rcx,0x18
  2206a2:	48 09 c1             	or     rcx,rax
    is_64.* = (first_32_bits == 0xffffffff);
  2206a5:	83 f9 ff             	cmp    ecx,0xffffffff
    if (is_64.*) {
  2206a8:	74 2c                	je     2206d6 <openSelfDebugInfoLinux+0x1746>
  2206aa:	48 89 8c 24 48 02 00 	mov    QWORD PTR [rsp+0x248],rcx
  2206b1:	00 
        if (first_32_bits >= 0xfffffff0) return error.InvalidDebugInfo;
  2206b2:	83 f9 ef             	cmp    ecx,0xffffffef
  2206b5:	0f 87 2d 1a 00 00    	ja     2220e8 <openSelfDebugInfoLinux+0x3158>
  2206bb:	c7 84 24 b0 00 00 00 	mov    DWORD PTR [rsp+0xb0],0x0
  2206c2:	00 00 00 00 
        if (unit_length == 0) return;
  2206c6:	48 83 bc 24 48 02 00 	cmp    QWORD PTR [rsp+0x248],0x0
  2206cd:	00 00 
  2206cf:	75 78                	jne    220749 <openSelfDebugInfoLinux+0x17b9>
  2206d1:	e9 22 16 00 00       	jmp    221cf8 <openSelfDebugInfoLinux+0x2d68>
            try self.readNoEof(bytes[0..]);
  2206d6:	4c 89 7c 24 68       	mov    QWORD PTR [rsp+0x68],r15
  2206db:	48 c7 44 24 70 08 00 	mov    QWORD PTR [rsp+0x70],0x8
  2206e2:	00 00 
            return self.readFn(self, buffer);
  2206e4:	4c 89 f7             	mov    rdi,r14
  2206e7:	48 8d b4 24 60 02 00 	lea    rsi,[rsp+0x260]
  2206ee:	00 
  2206ef:	48 8d 54 24 68       	lea    rdx,[rsp+0x68]
  2206f4:	ff 94 24 60 02 00 00 	call   QWORD PTR [rsp+0x260]
  2206fb:	0f b7 8c 24 c0 00 00 	movzx  ecx,WORD PTR [rsp+0xc0]
  220702:	00 
  220703:	89 c8                	mov    eax,ecx
            const amt_read = try self.read(buf);
  220705:	66 85 c9             	test   cx,cx
  220708:	0f 85 7a 19 00 00    	jne    222088 <openSelfDebugInfoLinux+0x30f8>
  22070e:	48 8b 84 24 c8 00 00 	mov    rax,QWORD PTR [rsp+0xc8]
  220715:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  220716:	48 3b 44 24 70       	cmp    rax,QWORD PTR [rsp+0x70]
  22071b:	0f 82 63 19 00 00    	jb     222084 <openSelfDebugInfoLinux+0x30f4>
  220721:	48 8b 84 24 b0 04 00 	mov    rax,QWORD PTR [rsp+0x4b0]
  220728:	00 
  220729:	48 89 84 24 48 02 00 	mov    QWORD PTR [rsp+0x248],rax
  220730:	00 
  220731:	b0 01                	mov    al,0x1
        const unit_length = try readInitialLength(@typeOf(in_stream.readFn).ReturnType.ErrorSet, in_stream, &is_64);
  220733:	89 84 24 b0 00 00 00 	mov    DWORD PTR [rsp+0xb0],eax
        if (unit_length == 0) return;
  22073a:	48 83 bc 24 48 02 00 	cmp    QWORD PTR [rsp+0x248],0x0
  220741:	00 00 
  220743:	0f 84 af 15 00 00    	je     221cf8 <openSelfDebugInfoLinux+0x2d68>
        const version = try in_stream.readInt(st.elf.endian, u16);
  220749:	40 8a ac 24 82 01 00 	mov    bpl,BYTE PTR [rsp+0x182]
  220750:	00 
            try self.readNoEof(bytes[0..]);
  220751:	48 8d 44 24 10       	lea    rax,[rsp+0x10]
  220756:	48 89 44 24 68       	mov    QWORD PTR [rsp+0x68],rax
  22075b:	48 c7 44 24 70 02 00 	mov    QWORD PTR [rsp+0x70],0x2
  220762:	00 00 
            return self.readFn(self, buffer);
  220764:	4c 89 f7             	mov    rdi,r14
  220767:	48 8d b4 24 60 02 00 	lea    rsi,[rsp+0x260]
  22076e:	00 
  22076f:	48 8d 54 24 68       	lea    rdx,[rsp+0x68]
  220774:	ff 94 24 60 02 00 00 	call   QWORD PTR [rsp+0x260]
  22077b:	0f b7 8c 24 c0 00 00 	movzx  ecx,WORD PTR [rsp+0xc0]
  220782:	00 
  220783:	89 c8                	mov    eax,ecx
            const amt_read = try self.read(buf);
  220785:	66 85 c9             	test   cx,cx
  220788:	0f 85 fa 18 00 00    	jne    222088 <openSelfDebugInfoLinux+0x30f8>
  22078e:	48 8b 84 24 c8 00 00 	mov    rax,QWORD PTR [rsp+0xc8]
  220795:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  220796:	48 3b 44 24 70       	cmp    rax,QWORD PTR [rsp+0x70]
  22079b:	0f 82 e3 18 00 00    	jb     222084 <openSelfDebugInfoLinux+0x30f4>
  2207a1:	0f b6 54 24 10       	movzx  edx,BYTE PTR [rsp+0x10]
  2207a6:	0f b6 44 24 11       	movzx  eax,BYTE PTR [rsp+0x11]
  2207ab:	89 c1                	mov    ecx,eax
  2207ad:	c1 e1 08             	shl    ecx,0x8
  2207b0:	09 d1                	or     ecx,edx
                result = (result << 8) | b;
  2207b2:	c1 e2 08             	shl    edx,0x8
  2207b5:	09 c2                	or     edx,eax
    switch (endian) {
  2207b7:	40 f6 c5 01          	test   bpl,0x1
  2207bb:	66 0f 45 d1          	cmovne dx,cx
  2207bf:	48 89 94 24 a0 03 00 	mov    QWORD PTR [rsp+0x3a0],rdx
  2207c6:	00 
        if (version < 2 or version > 5) return error.InvalidDebugInfo;
  2207c7:	8d 42 fe             	lea    eax,[rdx-0x2]
  2207ca:	0f b7 c0             	movzx  eax,ax
  2207cd:	83 f8 03             	cmp    eax,0x3
  2207d0:	0f 87 12 19 00 00    	ja     2220e8 <openSelfDebugInfoLinux+0x3158>
  2207d6:	40 8a ac 24 82 01 00 	mov    bpl,BYTE PTR [rsp+0x182]
  2207dd:	00 
        const debug_abbrev_offset = if (is_64) try in_stream.readInt(st.elf.endian, u64) else try in_stream.readInt(st.elf.endian, u32);
  2207de:	80 bc 24 b0 00 00 00 	cmp    BYTE PTR [rsp+0xb0],0x0
  2207e5:	00 
  2207e6:	74 37                	je     22081f <openSelfDebugInfoLinux+0x188f>
  2207e8:	40 0f b6 d5          	movzx  edx,bpl
  2207ec:	48 8d bc 24 80 04 00 	lea    rdi,[rsp+0x480]
  2207f3:	00 
  2207f4:	48 8d b4 24 60 02 00 	lea    rsi,[rsp+0x260]
  2207fb:	00 
  2207fc:	e8 ff 36 00 00       	call   223f00 <InStream(ReadError)_readInt.143>
  220801:	0f b7 bc 24 80 04 00 	movzx  edi,WORD PTR [rsp+0x480]
  220808:	00 
  220809:	66 85 ff             	test   di,di
  22080c:	0f 85 ad 19 00 00    	jne    2221bf <openSelfDebugInfoLinux+0x322f>
  220812:	48 8b 84 24 88 04 00 	mov    rax,QWORD PTR [rsp+0x488]
  220819:	00 
  22081a:	e9 96 00 00 00       	jmp    2208b5 <openSelfDebugInfoLinux+0x1925>
            try self.readNoEof(bytes[0..]);
  22081f:	48 8d 44 24 10       	lea    rax,[rsp+0x10]
  220824:	48 89 44 24 68       	mov    QWORD PTR [rsp+0x68],rax
  220829:	48 c7 44 24 70 04 00 	mov    QWORD PTR [rsp+0x70],0x4
  220830:	00 00 
            return self.readFn(self, buffer);
  220832:	4c 89 f7             	mov    rdi,r14
  220835:	48 8d b4 24 60 02 00 	lea    rsi,[rsp+0x260]
  22083c:	00 
  22083d:	48 8d 54 24 68       	lea    rdx,[rsp+0x68]
  220842:	ff 94 24 60 02 00 00 	call   QWORD PTR [rsp+0x260]
  220849:	0f b7 8c 24 c0 00 00 	movzx  ecx,WORD PTR [rsp+0xc0]
  220850:	00 
  220851:	89 c8                	mov    eax,ecx
            const amt_read = try self.read(buf);
  220853:	66 85 c9             	test   cx,cx
  220856:	0f 85 2c 18 00 00    	jne    222088 <openSelfDebugInfoLinux+0x30f8>
  22085c:	48 8b 84 24 c8 00 00 	mov    rax,QWORD PTR [rsp+0xc8]
  220863:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  220864:	48 3b 44 24 70       	cmp    rax,QWORD PTR [rsp+0x70]
  220869:	0f 82 15 18 00 00    	jb     222084 <openSelfDebugInfoLinux+0x30f4>
  22086f:	0f b6 44 24 10       	movzx  eax,BYTE PTR [rsp+0x10]
  220874:	0f b6 4c 24 11       	movzx  ecx,BYTE PTR [rsp+0x11]
  220879:	40 f6 c5 01          	test   bpl,0x1
  22087d:	74 1b                	je     22089a <openSelfDebugInfoLinux+0x190a>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  22087f:	c1 e1 08             	shl    ecx,0x8
  220882:	09 c1                	or     ecx,eax
  220884:	0f b6 54 24 12       	movzx  edx,BYTE PTR [rsp+0x12]
  220889:	c1 e2 10             	shl    edx,0x10
  22088c:	09 ca                	or     edx,ecx
  22088e:	0f b6 44 24 13       	movzx  eax,BYTE PTR [rsp+0x13]
  220893:	c1 e0 18             	shl    eax,0x18
  220896:	09 d0                	or     eax,edx
  220898:	eb 19                	jmp    2208b3 <openSelfDebugInfoLinux+0x1923>
                result = (result << 8) | b;
  22089a:	c1 e0 08             	shl    eax,0x8
  22089d:	09 c8                	or     eax,ecx
  22089f:	c1 e0 08             	shl    eax,0x8
  2208a2:	0f b6 4c 24 12       	movzx  ecx,BYTE PTR [rsp+0x12]
  2208a7:	09 c1                	or     ecx,eax
  2208a9:	c1 e1 08             	shl    ecx,0x8
  2208ac:	0f b6 44 24 13       	movzx  eax,BYTE PTR [rsp+0x13]
  2208b1:	09 c8                	or     eax,ecx
  2208b3:	89 c0                	mov    eax,eax
  2208b5:	48 89 44 24 58       	mov    QWORD PTR [rsp+0x58],rax
            try self.readNoEof(result[0..]);
  2208ba:	48 8d 44 24 0f       	lea    rax,[rsp+0xf]
  2208bf:	48 89 44 24 68       	mov    QWORD PTR [rsp+0x68],rax
  2208c4:	48 c7 44 24 70 01 00 	mov    QWORD PTR [rsp+0x70],0x1
  2208cb:	00 00 
            return self.readFn(self, buffer);
  2208cd:	4c 89 f7             	mov    rdi,r14
  2208d0:	48 8d b4 24 60 02 00 	lea    rsi,[rsp+0x260]
  2208d7:	00 
  2208d8:	48 8d 54 24 68       	lea    rdx,[rsp+0x68]
  2208dd:	ff 94 24 60 02 00 00 	call   QWORD PTR [rsp+0x260]
  2208e4:	0f b7 8c 24 c0 00 00 	movzx  ecx,WORD PTR [rsp+0xc0]
  2208eb:	00 
  2208ec:	89 c8                	mov    eax,ecx
            const amt_read = try self.read(buf);
  2208ee:	66 85 c9             	test   cx,cx
  2208f1:	0f 85 91 17 00 00    	jne    222088 <openSelfDebugInfoLinux+0x30f8>
  2208f7:	48 8b 84 24 c8 00 00 	mov    rax,QWORD PTR [rsp+0xc8]
  2208fe:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  2208ff:	48 3b 44 24 70       	cmp    rax,QWORD PTR [rsp+0x70]
  220904:	0f 82 7a 17 00 00    	jb     222084 <openSelfDebugInfoLinux+0x30f4>
        if (address_size != @sizeOf(usize)) return error.InvalidDebugInfo;
  22090a:	80 7c 24 0f 08       	cmp    BYTE PTR [rsp+0xf],0x8
  22090f:	66 bf 29 00          	mov    di,0x29
  220913:	0f 85 a6 18 00 00    	jne    2221bf <openSelfDebugInfoLinux+0x322f>
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  220919:	48 63 bc 24 70 01 00 	movsxd rdi,DWORD PTR [rsp+0x170]
  220920:	00 
  220921:	b8 08 00 00 00       	mov    eax,0x8
  220926:	be 00 00 00 00       	mov    esi,0x0
  22092b:	ba 01 00 00 00       	mov    edx,0x1
  220930:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  220932:	48 89 c6             	mov    rsi,rax
  220935:	48 f7 de             	neg    rsi
  220938:	48 89 44 24 38       	mov    QWORD PTR [rsp+0x38],rax
  22093d:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  220943:	b9 00 00 00 00       	mov    ecx,0x0
  220948:	48 0f 46 f1          	cmovbe rsi,rcx
    pub fn getPos(self: *File) !usize {
        switch (builtin.os) {
            Os.linux, Os.macosx, Os.ios => {
                const result = posix.lseek(self.handle, 0, posix.SEEK_CUR);
                const err = posix.getErrno(result);
                if (err > 0) {
  22094c:	48 85 f6             	test   rsi,rsi
  22094f:	0f 85 2e 18 00 00    	jne    222183 <openSelfDebugInfoLinux+0x31f3>
  220955:	48 8b 84 24 08 02 00 	mov    rax,QWORD PTR [rsp+0x208]
  22095c:	00 
    for (st.abbrev_table_list.toSlice()) |*header| {
  22095d:	48 85 c0             	test   rax,rax
  220960:	48 8b 54 24 58       	mov    rdx,QWORD PTR [rsp+0x58]
  220965:	74 25                	je     22098c <openSelfDebugInfoLinux+0x19fc>
  220967:	48 8b ac 24 f8 01 00 	mov    rbp,QWORD PTR [rsp+0x1f8]
  22096e:	00 
        if (header.offset == abbrev_offset) {
  22096f:	48 83 c5 08          	add    rbp,0x8
  220973:	31 c9                	xor    ecx,ecx
  220975:	48 39 55 f8          	cmp    QWORD PTR [rbp-0x8],rdx
  220979:	0f 84 7b 08 00 00    	je     2211fa <openSelfDebugInfoLinux+0x226a>
    for (st.abbrev_table_list.toSlice()) |*header| {
  22097f:	48 83 c1 01          	add    rcx,0x1
  220983:	48 83 c5 28          	add    rbp,0x28
  220987:	48 39 c1             	cmp    rcx,rax
  22098a:	72 e9                	jb     220975 <openSelfDebugInfoLinux+0x19e5>
    try st.self_exe_file.seekTo(st.debug_abbrev.offset + abbrev_offset);
  22098c:	48 8b 84 24 d8 01 00 	mov    rax,QWORD PTR [rsp+0x1d8]
  220993:	00 
  220994:	48 8b 70 18          	mov    rsi,QWORD PTR [rax+0x18]
  220998:	48 01 d6             	add    rsi,rdx
  22099b:	0f 88 35 17 00 00    	js     2220d6 <openSelfDebugInfoLinux+0x3146>
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  2209a1:	48 63 bc 24 70 01 00 	movsxd rdi,DWORD PTR [rsp+0x170]
  2209a8:	00 
  2209a9:	b8 08 00 00 00       	mov    eax,0x8
  2209ae:	31 d2                	xor    edx,edx
  2209b0:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  2209b2:	48 89 c1             	mov    rcx,rax
  2209b5:	48 f7 d9             	neg    rcx
  2209b8:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  2209be:	b8 00 00 00 00       	mov    eax,0x0
  2209c3:	48 0f 46 c8          	cmovbe rcx,rax
                if (err > 0) {
  2209c7:	48 85 c9             	test   rcx,rcx
  2209ca:	0f 85 e5 19 00 00    	jne    2223b5 <openSelfDebugInfoLinux+0x3425>
    var in_file_stream = io.FileInStream.init(in_file);
  2209d0:	4c 89 ac 24 60 01 00 	mov    QWORD PTR [rsp+0x160],r13
  2209d7:	00 
  2209d8:	48 8d 05 81 37 00 00 	lea    rax,[rip+0x3781]        # 224160 <FileInStream_readFn>
  2209df:	48 89 84 24 68 01 00 	mov    QWORD PTR [rsp+0x168],rax
  2209e6:	00 
            return Self{
  2209e7:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  2209eb:	c5 f9 7f 84 24 b0 02 	vmovdqa XMMWORD PTR [rsp+0x2b0],xmm0
  2209f2:	00 00 
  2209f4:	48 8b 84 24 10 02 00 	mov    rax,QWORD PTR [rsp+0x210]
  2209fb:	00 
  2209fc:	48 c7 84 24 c0 02 00 	mov    QWORD PTR [rsp+0x2c0],0x0
  220a03:	00 00 00 00 00 
  220a08:	48 89 84 24 d0 02 00 	mov    QWORD PTR [rsp+0x2d0],rax
  220a0f:	00 
    var result = AbbrevTable.init(st.allocator());
  220a10:	48 89 84 24 c8 02 00 	mov    QWORD PTR [rsp+0x2c8],rax
  220a17:	00 
            try self.readNoEof(result[0..]);
  220a18:	48 8d 44 24 0f       	lea    rax,[rsp+0xf]
  220a1d:	48 89 84 24 a0 02 00 	mov    QWORD PTR [rsp+0x2a0],rax
  220a24:	00 
  220a25:	48 c7 84 24 a8 02 00 	mov    QWORD PTR [rsp+0x2a8],0x1
  220a2c:	00 01 00 00 00 
        return self.file.read(buffer);
  220a31:	48 8b b4 24 60 01 00 	mov    rsi,QWORD PTR [rsp+0x160]
  220a38:	00 
  220a39:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  220a3e:	48 8d 94 24 a0 02 00 	lea    rdx,[rsp+0x2a0]
  220a45:	00 
  220a46:	e8 e5 35 00 00       	call   224030 <File_read>
  220a4b:	c5 fa 6f 44 24 40    	vmovdqu xmm0,XMMWORD PTR [rsp+0x40]
  220a51:	c5 f9 7f 84 24 a0 00 	vmovdqa XMMWORD PTR [rsp+0xa0],xmm0
  220a58:	00 00 
            return self.readFn(self, buffer);
  220a5a:	0f b7 8c 24 a0 00 00 	movzx  ecx,WORD PTR [rsp+0xa0]
  220a61:	00 
            const amt_read = try self.read(buf);
  220a62:	66 85 c9             	test   cx,cx
  220a65:	0f 85 e7 15 00 00    	jne    222052 <openSelfDebugInfoLinux+0x30c2>
  220a6b:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  220a72:	00 
  220a73:	31 c9                	xor    ecx,ecx
  220a75:	48 89 8c 24 68 02 00 	mov    QWORD PTR [rsp+0x268],rcx
  220a7c:	00 
  220a7d:	31 c9                	xor    ecx,ecx
  220a7f:	48 89 8c 24 40 02 00 	mov    QWORD PTR [rsp+0x240],rcx
  220a86:	00 
  220a87:	31 c9                	xor    ecx,ecx
  220a89:	48 89 4c 24 30       	mov    QWORD PTR [rsp+0x30],rcx
  220a8e:	31 ed                	xor    ebp,ebp
            if (amt_read < buf.len) return error.EndOfStream;
  220a90:	48 3b 84 24 a8 02 00 	cmp    rax,QWORD PTR [rsp+0x2a8]
  220a97:	00 
  220a98:	0f 82 aa 15 00 00    	jb     222048 <openSelfDebugInfoLinux+0x30b8>
            return result[0];
  220a9e:	0f b6 44 24 0f       	movzx  eax,BYTE PTR [rsp+0xf]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  220aa3:	89 c2                	mov    edx,eax
  220aa5:	83 e2 7f             	and    edx,0x7f
  220aa8:	89 ee                	mov    esi,ebp
  220aaa:	83 e6 3f             	and    esi,0x3f
  220aad:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  220ab2:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  220ab7:	48 39 d6             	cmp    rsi,rdx
  220aba:	0f 85 8e 15 00 00    	jne    22204e <openSelfDebugInfoLinux+0x30be>
        result |= operand;
  220ac0:	48 09 4c 24 30       	or     QWORD PTR [rsp+0x30],rcx
        if ((byte & 0b10000000) == 0) return result;
  220ac5:	84 c0                	test   al,al
  220ac7:	79 5a                	jns    220b23 <openSelfDebugInfoLinux+0x1b93>
        shift += 7;
  220ac9:	48 83 c5 07          	add    rbp,0x7
            try self.readNoEof(result[0..]);
  220acd:	48 8d 44 24 0f       	lea    rax,[rsp+0xf]
  220ad2:	48 89 84 24 a0 02 00 	mov    QWORD PTR [rsp+0x2a0],rax
  220ad9:	00 
  220ada:	48 c7 84 24 a8 02 00 	mov    QWORD PTR [rsp+0x2a8],0x1
  220ae1:	00 01 00 00 00 
            return self.readFn(self, buffer);
  220ae6:	48 8d bc 24 a0 00 00 	lea    rdi,[rsp+0xa0]
  220aed:	00 
  220aee:	48 8d b4 24 68 01 00 	lea    rsi,[rsp+0x168]
  220af5:	00 
  220af6:	48 8d 94 24 a0 02 00 	lea    rdx,[rsp+0x2a0]
  220afd:	00 
  220afe:	ff 94 24 68 01 00 00 	call   QWORD PTR [rsp+0x168]
  220b05:	0f b7 8c 24 a0 00 00 	movzx  ecx,WORD PTR [rsp+0xa0]
  220b0c:	00 
  220b0d:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  220b14:	00 
            const amt_read = try self.read(buf);
  220b15:	66 85 c9             	test   cx,cx
  220b18:	0f 84 72 ff ff ff    	je     220a90 <openSelfDebugInfoLinux+0x1b00>
  220b1e:	e9 2f 15 00 00       	jmp    222052 <openSelfDebugInfoLinux+0x30c2>
        if (abbrev_code == 0) return result;
  220b23:	48 83 7c 24 30 00    	cmp    QWORD PTR [rsp+0x30],0x0
  220b29:	0f 84 bf 05 00 00    	je     2210ee <openSelfDebugInfoLinux+0x215e>
            try self.readNoEof(result[0..]);
  220b2f:	48 8d 44 24 0f       	lea    rax,[rsp+0xf]
  220b34:	48 89 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rax
  220b3b:	00 
  220b3c:	48 c7 84 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],0x1
  220b43:	00 01 00 00 00 
            return self.readFn(self, buffer);
  220b48:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  220b4d:	48 8d b4 24 68 01 00 	lea    rsi,[rsp+0x168]
  220b54:	00 
  220b55:	48 8d 94 24 a0 00 00 	lea    rdx,[rsp+0xa0]
  220b5c:	00 
  220b5d:	ff 94 24 68 01 00 00 	call   QWORD PTR [rsp+0x168]
  220b64:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
  220b69:	89 c1                	mov    ecx,eax
            const amt_read = try self.read(buf);
  220b6b:	66 85 c0             	test   ax,ax
  220b6e:	0f 85 f1 15 00 00    	jne    222165 <openSelfDebugInfoLinux+0x31d5>
  220b74:	48 8b 44 24 48       	mov    rax,QWORD PTR [rsp+0x48]
  220b79:	31 c9                	xor    ecx,ecx
  220b7b:	48 89 8c 24 38 02 00 	mov    QWORD PTR [rsp+0x238],rcx
  220b82:	00 
  220b83:	31 ed                	xor    ebp,ebp
            if (amt_read < buf.len) return error.EndOfStream;
  220b85:	48 3b 84 24 a8 00 00 	cmp    rax,QWORD PTR [rsp+0xa8]
  220b8c:	00 
  220b8d:	0f 82 c8 15 00 00    	jb     22215b <openSelfDebugInfoLinux+0x31cb>
            return result[0];
  220b93:	0f b6 44 24 0f       	movzx  eax,BYTE PTR [rsp+0xf]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  220b98:	89 c2                	mov    edx,eax
  220b9a:	83 e2 7f             	and    edx,0x7f
  220b9d:	89 ee                	mov    esi,ebp
  220b9f:	83 e6 3f             	and    esi,0x3f
  220ba2:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  220ba7:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  220bac:	48 39 d6             	cmp    rsi,rdx
  220baf:	0f 85 ac 15 00 00    	jne    222161 <openSelfDebugInfoLinux+0x31d1>
        result |= operand;
  220bb5:	48 09 8c 24 38 02 00 	or     QWORD PTR [rsp+0x238],rcx
  220bbc:	00 
        if ((byte & 0b10000000) == 0) return result;
  220bbd:	84 c0                	test   al,al
  220bbf:	79 53                	jns    220c14 <openSelfDebugInfoLinux+0x1c84>
        shift += 7;
  220bc1:	48 83 c5 07          	add    rbp,0x7
            try self.readNoEof(result[0..]);
  220bc5:	48 8d 44 24 0f       	lea    rax,[rsp+0xf]
  220bca:	48 89 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rax
  220bd1:	00 
  220bd2:	48 c7 84 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],0x1
  220bd9:	00 01 00 00 00 
            return self.readFn(self, buffer);
  220bde:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  220be3:	48 8d b4 24 68 01 00 	lea    rsi,[rsp+0x168]
  220bea:	00 
  220beb:	48 8d 94 24 a0 00 00 	lea    rdx,[rsp+0xa0]
  220bf2:	00 
  220bf3:	ff 94 24 68 01 00 00 	call   QWORD PTR [rsp+0x168]
  220bfa:	0f b7 54 24 40       	movzx  edx,WORD PTR [rsp+0x40]
  220bff:	48 8b 44 24 48       	mov    rax,QWORD PTR [rsp+0x48]
  220c04:	89 d1                	mov    ecx,edx
            const amt_read = try self.read(buf);
  220c06:	66 85 d2             	test   dx,dx
  220c09:	0f 84 76 ff ff ff    	je     220b85 <openSelfDebugInfoLinux+0x1bf5>
  220c0f:	e9 51 15 00 00       	jmp    222165 <openSelfDebugInfoLinux+0x31d5>
            try self.readNoEof(result[0..]);
  220c14:	48 8d 44 24 0f       	lea    rax,[rsp+0xf]
  220c19:	48 89 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rax
  220c20:	00 
  220c21:	48 c7 84 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],0x1
  220c28:	00 01 00 00 00 
            return self.readFn(self, buffer);
  220c2d:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  220c32:	48 8d b4 24 68 01 00 	lea    rsi,[rsp+0x168]
  220c39:	00 
  220c3a:	48 8d 94 24 a0 00 00 	lea    rdx,[rsp+0xa0]
  220c41:	00 
  220c42:	ff 94 24 68 01 00 00 	call   QWORD PTR [rsp+0x168]
  220c49:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
  220c4e:	89 c1                	mov    ecx,eax
            const amt_read = try self.read(buf);
  220c50:	66 85 c0             	test   ax,ax
  220c53:	0f 85 1e 18 00 00    	jne    222477 <openSelfDebugInfoLinux+0x34e7>
  220c59:	48 8b 44 24 48       	mov    rax,QWORD PTR [rsp+0x48]
            if (amt_read < buf.len) return error.EndOfStream;
  220c5e:	48 3b 84 24 a8 00 00 	cmp    rax,QWORD PTR [rsp+0xa8]
  220c65:	00 
  220c66:	0f 82 07 18 00 00    	jb     222473 <openSelfDebugInfoLinux+0x34e3>
            return result[0];
  220c6c:	8a 44 24 0f          	mov    al,BYTE PTR [rsp+0xf]
  220c70:	88 84 24 bf 00 00 00 	mov    BYTE PTR [rsp+0xbf],al
  220c77:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  220c7b:	c5 f9 7f 44 24 10    	vmovdqa XMMWORD PTR [rsp+0x10],xmm0
  220c81:	48 8b 84 24 10 02 00 	mov    rax,QWORD PTR [rsp+0x210]
  220c88:	00 
  220c89:	48 89 84 24 50 02 00 	mov    QWORD PTR [rsp+0x250],rax
  220c90:	00 
  220c91:	48 c7 44 24 20 00 00 	mov    QWORD PTR [rsp+0x20],0x0
  220c98:	00 00 
            var better_capacity = self.items.len;
  220c9a:	48 8b 8c 24 b8 02 00 	mov    rcx,QWORD PTR [rsp+0x2b8]
  220ca1:	00 
            if (better_capacity >= new_capacity) return;
  220ca2:	48 3b 8c 24 40 02 00 	cmp    rcx,QWORD PTR [rsp+0x240]
  220ca9:	00 
  220caa:	77 63                	ja     220d0f <openSelfDebugInfoLinux+0x1d7f>
                better_capacity += better_capacity / 2 + 8;
  220cac:	48 89 c8             	mov    rax,rcx
  220caf:	48 d1 e8             	shr    rax,1
  220cb2:	48 01 c1             	add    rcx,rax
  220cb5:	48 83 c1 08          	add    rcx,0x8
                if (better_capacity >= new_capacity) break;
  220cb9:	48 3b 8c 24 40 02 00 	cmp    rcx,QWORD PTR [rsp+0x240]
  220cc0:	00 
  220cc1:	76 e9                	jbe    220cac <openSelfDebugInfoLinux+0x1d1c>
            self.items = try self.allocator.alignedRealloc(T, A, self.items, better_capacity);
  220cc3:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  220cc8:	48 8b b4 24 d0 02 00 	mov    rsi,QWORD PTR [rsp+0x2d0]
  220ccf:	00 
  220cd0:	48 8d 94 24 b0 02 00 	lea    rdx,[rsp+0x2b0]
  220cd7:	00 
  220cd8:	e8 b3 34 00 00       	call   224190 <Allocator_alignedRealloc.149>
  220cdd:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
  220ce2:	89 c1                	mov    ecx,eax
  220ce4:	66 85 c0             	test   ax,ax
  220ce7:	0f 85 b9 17 00 00    	jne    2224a6 <openSelfDebugInfoLinux+0x3516>
  220ced:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  220cf2:	c5 fa 6f 00          	vmovdqu xmm0,XMMWORD PTR [rax]
  220cf6:	c5 f9 7f 84 24 b0 02 	vmovdqa XMMWORD PTR [rsp+0x2b0],xmm0
  220cfd:	00 00 
            const result = &self.items[self.len];
  220cff:	48 8b 84 24 b0 02 00 	mov    rax,QWORD PTR [rsp+0x2b0]
  220d06:	00 
            try self.ensureCapacity(new_length);
  220d07:	48 89 84 24 68 02 00 	mov    QWORD PTR [rsp+0x268],rax
  220d0e:	00 
  220d0f:	48 8b 84 24 40 02 00 	mov    rax,QWORD PTR [rsp+0x240]
  220d16:	00 
  220d17:	48 89 c1             	mov    rcx,rax
            const result = &self.items[self.len];
  220d1a:	48 6b e9 38          	imul   rbp,rcx,0x38
  220d1e:	48 83 c1 01          	add    rcx,0x1
  220d22:	48 89 c8             	mov    rax,rcx
            self.len = new_length;
  220d25:	48 89 84 24 40 02 00 	mov    QWORD PTR [rsp+0x240],rax
  220d2c:	00 
  220d2d:	48 89 8c 24 c0 02 00 	mov    QWORD PTR [rsp+0x2c0],rcx
  220d34:	00 
            .has_children = (try in_stream.readByte()) == DW.CHILDREN_yes,
  220d35:	80 bc 24 bf 00 00 00 	cmp    BYTE PTR [rsp+0xbf],0x1
  220d3c:	01 
  220d3d:	48 8b 84 24 68 02 00 	mov    rax,QWORD PTR [rsp+0x268]
  220d44:	00 
  220d45:	48 89 c1             	mov    rcx,rax
            new_item_ptr.* = item;
  220d48:	0f 94 04 29          	sete   BYTE PTR [rcx+rbp*1]
  220d4c:	8a 84 24 df 02 00 00 	mov    al,BYTE PTR [rsp+0x2df]
  220d53:	88 44 29 07          	mov    BYTE PTR [rcx+rbp*1+0x7],al
  220d57:	0f b7 84 24 dd 02 00 	movzx  eax,WORD PTR [rsp+0x2dd]
  220d5e:	00 
  220d5f:	66 89 44 29 05       	mov    WORD PTR [rcx+rbp*1+0x5],ax
  220d64:	8b 84 24 d9 02 00 00 	mov    eax,DWORD PTR [rsp+0x2d9]
  220d6b:	89 44 29 01          	mov    DWORD PTR [rcx+rbp*1+0x1],eax
  220d6f:	48 8b 44 24 30       	mov    rax,QWORD PTR [rsp+0x30]
  220d74:	48 89 44 29 08       	mov    QWORD PTR [rcx+rbp*1+0x8],rax
  220d79:	48 8b 84 24 38 02 00 	mov    rax,QWORD PTR [rsp+0x238]
  220d80:	00 
  220d81:	48 89 44 29 10       	mov    QWORD PTR [rcx+rbp*1+0x10],rax
  220d86:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
  220d8b:	48 89 44 29 28       	mov    QWORD PTR [rcx+rbp*1+0x28],rax
  220d90:	c5 f9 6f 44 24 10    	vmovdqa xmm0,XMMWORD PTR [rsp+0x10]
  220d96:	c5 fa 7f 44 29 18    	vmovdqu XMMWORD PTR [rcx+rbp*1+0x18],xmm0
  220d9c:	48 8b 84 24 50 02 00 	mov    rax,QWORD PTR [rsp+0x250]
  220da3:	00 
  220da4:	48 89 44 29 30       	mov    QWORD PTR [rcx+rbp*1+0x30],rax
            try self.readNoEof(result[0..]);
  220da9:	48 8d 44 24 0f       	lea    rax,[rsp+0xf]
  220dae:	48 89 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rax
  220db5:	00 
  220db6:	48 c7 84 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],0x1
  220dbd:	00 01 00 00 00 
            return self.readFn(self, buffer);
  220dc2:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  220dc7:	48 8d b4 24 68 01 00 	lea    rsi,[rsp+0x168]
  220dce:	00 
  220dcf:	48 8d 94 24 a0 00 00 	lea    rdx,[rsp+0xa0]
  220dd6:	00 
  220dd7:	ff 94 24 68 01 00 00 	call   QWORD PTR [rsp+0x168]
  220dde:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
  220de3:	89 c1                	mov    ecx,eax
            const amt_read = try self.read(buf);
  220de5:	66 85 c0             	test   ax,ax
  220de8:	0f 85 67 16 00 00    	jne    222455 <openSelfDebugInfoLinux+0x34c5>
  220dee:	48 8b 84 24 68 02 00 	mov    rax,QWORD PTR [rsp+0x268]
  220df5:	00 
  220df6:	48 01 e8             	add    rax,rbp
  220df9:	48 83 c0 18          	add    rax,0x18
  220dfd:	48 89 84 24 50 02 00 	mov    QWORD PTR [rsp+0x250],rax
  220e04:	00 
  220e05:	48 8b 44 24 48       	mov    rax,QWORD PTR [rsp+0x48]
  220e0a:	31 c9                	xor    ecx,ecx
  220e0c:	48 89 8c 24 38 02 00 	mov    QWORD PTR [rsp+0x238],rcx
  220e13:	00 
  220e14:	31 ed                	xor    ebp,ebp
            if (amt_read < buf.len) return error.EndOfStream;
  220e16:	48 3b 84 24 a8 00 00 	cmp    rax,QWORD PTR [rsp+0xa8]
  220e1d:	00 
  220e1e:	0f 82 27 16 00 00    	jb     22244b <openSelfDebugInfoLinux+0x34bb>
            return result[0];
  220e24:	0f b6 44 24 0f       	movzx  eax,BYTE PTR [rsp+0xf]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  220e29:	89 c2                	mov    edx,eax
  220e2b:	83 e2 7f             	and    edx,0x7f
  220e2e:	89 ee                	mov    esi,ebp
  220e30:	83 e6 3f             	and    esi,0x3f
  220e33:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  220e38:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  220e3d:	48 39 d6             	cmp    rsi,rdx
  220e40:	0f 85 0b 16 00 00    	jne    222451 <openSelfDebugInfoLinux+0x34c1>
        result |= operand;
  220e46:	48 09 8c 24 38 02 00 	or     QWORD PTR [rsp+0x238],rcx
  220e4d:	00 
        if ((byte & 0b10000000) == 0) return result;
  220e4e:	84 c0                	test   al,al
  220e50:	0f 88 e3 00 00 00    	js     220f39 <openSelfDebugInfoLinux+0x1fa9>
            try self.readNoEof(result[0..]);
  220e56:	48 8d 44 24 0f       	lea    rax,[rsp+0xf]
  220e5b:	48 89 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rax
  220e62:	00 
  220e63:	48 c7 84 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],0x1
  220e6a:	00 01 00 00 00 
            return self.readFn(self, buffer);
  220e6f:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  220e74:	48 8d b4 24 68 01 00 	lea    rsi,[rsp+0x168]
  220e7b:	00 
  220e7c:	48 8d 94 24 a0 00 00 	lea    rdx,[rsp+0xa0]
  220e83:	00 
  220e84:	ff 94 24 68 01 00 00 	call   QWORD PTR [rsp+0x168]
  220e8b:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
  220e90:	89 c1                	mov    ecx,eax
            const amt_read = try self.read(buf);
  220e92:	66 85 c0             	test   ax,ax
  220e95:	0f 85 92 15 00 00    	jne    22242d <openSelfDebugInfoLinux+0x349d>
  220e9b:	48 8b 44 24 48       	mov    rax,QWORD PTR [rsp+0x48]
  220ea0:	31 c9                	xor    ecx,ecx
  220ea2:	48 89 4c 24 30       	mov    QWORD PTR [rsp+0x30],rcx
  220ea7:	31 ed                	xor    ebp,ebp
            if (amt_read < buf.len) return error.EndOfStream;
  220ea9:	48 3b 84 24 a8 00 00 	cmp    rax,QWORD PTR [rsp+0xa8]
  220eb0:	00 
  220eb1:	0f 82 6c 15 00 00    	jb     222423 <openSelfDebugInfoLinux+0x3493>
            return result[0];
  220eb7:	0f b6 44 24 0f       	movzx  eax,BYTE PTR [rsp+0xf]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  220ebc:	89 c2                	mov    edx,eax
  220ebe:	83 e2 7f             	and    edx,0x7f
  220ec1:	89 ee                	mov    esi,ebp
  220ec3:	83 e6 3f             	and    esi,0x3f
  220ec6:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  220ecb:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  220ed0:	48 39 d6             	cmp    rsi,rdx
  220ed3:	0f 85 50 15 00 00    	jne    222429 <openSelfDebugInfoLinux+0x3499>
        result |= operand;
  220ed9:	48 09 4c 24 30       	or     QWORD PTR [rsp+0x30],rcx
        if ((byte & 0b10000000) == 0) return result;
  220ede:	84 c0                	test   al,al
  220ee0:	0f 89 a6 00 00 00    	jns    220f8c <openSelfDebugInfoLinux+0x1ffc>
        shift += 7;
  220ee6:	48 83 c5 07          	add    rbp,0x7
            try self.readNoEof(result[0..]);
  220eea:	48 8d 44 24 0f       	lea    rax,[rsp+0xf]
  220eef:	48 89 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rax
  220ef6:	00 
  220ef7:	48 c7 84 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],0x1
  220efe:	00 01 00 00 00 
            return self.readFn(self, buffer);
  220f03:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  220f08:	48 8d b4 24 68 01 00 	lea    rsi,[rsp+0x168]
  220f0f:	00 
  220f10:	48 8d 94 24 a0 00 00 	lea    rdx,[rsp+0xa0]
  220f17:	00 
  220f18:	ff 94 24 68 01 00 00 	call   QWORD PTR [rsp+0x168]
  220f1f:	0f b7 54 24 40       	movzx  edx,WORD PTR [rsp+0x40]
  220f24:	48 8b 44 24 48       	mov    rax,QWORD PTR [rsp+0x48]
  220f29:	89 d1                	mov    ecx,edx
            const amt_read = try self.read(buf);
  220f2b:	66 85 d2             	test   dx,dx
  220f2e:	0f 84 75 ff ff ff    	je     220ea9 <openSelfDebugInfoLinux+0x1f19>
  220f34:	e9 f4 14 00 00       	jmp    22242d <openSelfDebugInfoLinux+0x349d>
  220f39:	48 83 c5 07          	add    rbp,0x7
            try self.readNoEof(result[0..]);
  220f3d:	48 8d 44 24 0f       	lea    rax,[rsp+0xf]
  220f42:	48 89 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rax
  220f49:	00 
  220f4a:	48 c7 84 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],0x1
  220f51:	00 01 00 00 00 
            return self.readFn(self, buffer);
  220f56:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  220f5b:	48 8d b4 24 68 01 00 	lea    rsi,[rsp+0x168]
  220f62:	00 
  220f63:	48 8d 94 24 a0 00 00 	lea    rdx,[rsp+0xa0]
  220f6a:	00 
  220f6b:	ff 94 24 68 01 00 00 	call   QWORD PTR [rsp+0x168]
  220f72:	0f b7 54 24 40       	movzx  edx,WORD PTR [rsp+0x40]
  220f77:	48 8b 44 24 48       	mov    rax,QWORD PTR [rsp+0x48]
  220f7c:	89 d1                	mov    ecx,edx
            const amt_read = try self.read(buf);
  220f7e:	66 85 d2             	test   dx,dx
  220f81:	0f 84 8f fe ff ff    	je     220e16 <openSelfDebugInfoLinux+0x1e86>
  220f87:	e9 c9 14 00 00       	jmp    222455 <openSelfDebugInfoLinux+0x34c5>
            if (attr_id == 0 and form_id == 0) break;
  220f8c:	48 8b 44 24 30       	mov    rax,QWORD PTR [rsp+0x30]
  220f91:	48 0b 84 24 38 02 00 	or     rax,QWORD PTR [rsp+0x238]
  220f98:	00 
  220f99:	0f 84 f9 00 00 00    	je     221098 <openSelfDebugInfoLinux+0x2108>
  220f9f:	48 8b 84 24 50 02 00 	mov    rax,QWORD PTR [rsp+0x250]
  220fa6:	00 
            const new_length = self.len + 1;
  220fa7:	48 8b 68 10          	mov    rbp,QWORD PTR [rax+0x10]
            var better_capacity = self.items.len;
  220fab:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
            if (better_capacity >= new_capacity) return;
  220faf:	48 39 e9             	cmp    rcx,rbp
  220fb2:	76 05                	jbe    220fb9 <openSelfDebugInfoLinux+0x2029>
            const result = &self.items[self.len];
  220fb4:	48 89 e8             	mov    rax,rbp
  220fb7:	eb 51                	jmp    22100a <openSelfDebugInfoLinux+0x207a>
                better_capacity += better_capacity / 2 + 8;
  220fb9:	48 89 c8             	mov    rax,rcx
  220fbc:	48 d1 e8             	shr    rax,1
  220fbf:	48 01 c1             	add    rcx,rax
  220fc2:	48 83 c1 08          	add    rcx,0x8
                if (better_capacity >= new_capacity) break;
  220fc6:	48 39 e9             	cmp    rcx,rbp
  220fc9:	76 ee                	jbe    220fb9 <openSelfDebugInfoLinux+0x2029>
  220fcb:	48 8b 94 24 50 02 00 	mov    rdx,QWORD PTR [rsp+0x250]
  220fd2:	00 
            self.items = try self.allocator.alignedRealloc(T, A, self.items, better_capacity);
  220fd3:	48 8b 72 18          	mov    rsi,QWORD PTR [rdx+0x18]
  220fd7:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  220fdc:	e8 4f 34 00 00       	call   224430 <Allocator_alignedRealloc.152>
  220fe1:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
  220fe6:	89 c1                	mov    ecx,eax
  220fe8:	66 85 c0             	test   ax,ax
  220feb:	0f 85 d3 14 00 00    	jne    2224c4 <openSelfDebugInfoLinux+0x3534>
  220ff1:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  220ff6:	c5 fa 6f 00          	vmovdqu xmm0,XMMWORD PTR [rax]
  220ffa:	48 8b 84 24 50 02 00 	mov    rax,QWORD PTR [rsp+0x250]
  221001:	00 
  221002:	c5 fa 7f 00          	vmovdqu XMMWORD PTR [rax],xmm0
            const result = &self.items[self.len];
  221006:	48 8b 40 10          	mov    rax,QWORD PTR [rax+0x10]
  22100a:	48 83 c5 01          	add    rbp,0x1
  22100e:	48 8b 94 24 50 02 00 	mov    rdx,QWORD PTR [rsp+0x250]
  221015:	00 
  221016:	48 8b 0a             	mov    rcx,QWORD PTR [rdx]
            self.len = new_length;
  221019:	48 89 6a 10          	mov    QWORD PTR [rdx+0x10],rbp
            new_item_ptr.* = item;
  22101d:	48 c1 e0 04          	shl    rax,0x4
  221021:	48 8b 94 24 38 02 00 	mov    rdx,QWORD PTR [rsp+0x238]
  221028:	00 
  221029:	48 89 14 01          	mov    QWORD PTR [rcx+rax*1],rdx
  22102d:	48 8b 54 24 30       	mov    rdx,QWORD PTR [rsp+0x30]
  221032:	48 89 54 01 08       	mov    QWORD PTR [rcx+rax*1+0x8],rdx
            try self.readNoEof(result[0..]);
  221037:	48 8d 44 24 0f       	lea    rax,[rsp+0xf]
  22103c:	48 89 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rax
  221043:	00 
  221044:	48 c7 84 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],0x1
  22104b:	00 01 00 00 00 
            return self.readFn(self, buffer);
  221050:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  221055:	48 8d b4 24 68 01 00 	lea    rsi,[rsp+0x168]
  22105c:	00 
  22105d:	48 8d 94 24 a0 00 00 	lea    rdx,[rsp+0xa0]
  221064:	00 
  221065:	ff 94 24 68 01 00 00 	call   QWORD PTR [rsp+0x168]
  22106c:	0f b7 54 24 40       	movzx  edx,WORD PTR [rsp+0x40]
  221071:	48 8b 44 24 48       	mov    rax,QWORD PTR [rsp+0x48]
  221076:	b9 00 00 00 00       	mov    ecx,0x0
  22107b:	48 89 8c 24 38 02 00 	mov    QWORD PTR [rsp+0x238],rcx
  221082:	00 
  221083:	bd 00 00 00 00       	mov    ebp,0x0
  221088:	89 d1                	mov    ecx,edx
            const amt_read = try self.read(buf);
  22108a:	66 85 d2             	test   dx,dx
  22108d:	0f 84 83 fd ff ff    	je     220e16 <openSelfDebugInfoLinux+0x1e86>
  221093:	e9 bd 13 00 00       	jmp    222455 <openSelfDebugInfoLinux+0x34c5>
            try self.readNoEof(result[0..]);
  221098:	48 8d 44 24 0f       	lea    rax,[rsp+0xf]
  22109d:	48 89 84 24 a0 02 00 	mov    QWORD PTR [rsp+0x2a0],rax
  2210a4:	00 
  2210a5:	48 c7 84 24 a8 02 00 	mov    QWORD PTR [rsp+0x2a8],0x1
  2210ac:	00 01 00 00 00 
            return self.readFn(self, buffer);
  2210b1:	48 8d bc 24 a0 00 00 	lea    rdi,[rsp+0xa0]
  2210b8:	00 
  2210b9:	48 8d b4 24 68 01 00 	lea    rsi,[rsp+0x168]
  2210c0:	00 
  2210c1:	48 8d 94 24 a0 02 00 	lea    rdx,[rsp+0x2a0]
  2210c8:	00 
  2210c9:	ff 94 24 68 01 00 00 	call   QWORD PTR [rsp+0x168]
  2210d0:	0f b7 8c 24 a0 00 00 	movzx  ecx,WORD PTR [rsp+0xa0]
  2210d7:	00 
  2210d8:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  2210df:	00 
            const amt_read = try self.read(buf);
  2210e0:	66 85 c9             	test   cx,cx
  2210e3:	0f 84 9e f9 ff ff    	je     220a87 <openSelfDebugInfoLinux+0x1af7>
  2210e9:	e9 64 0f 00 00       	jmp    222052 <openSelfDebugInfoLinux+0x30c2>
        if (abbrev_code == 0) return result;
  2210ee:	c5 fc 10 84 24 b0 02 	vmovups ymm0,YMMWORD PTR [rsp+0x2b0]
  2210f5:	00 00 
  2210f7:	48 8d 44 24 6e       	lea    rax,[rsp+0x6e]
  2210fc:	c5 fc 11 00          	vmovups YMMWORD PTR [rax],ymm0
  221100:	c5 fc 10 44 24 68    	vmovups ymm0,YMMWORD PTR [rsp+0x68]
  221106:	c5 fc 11 84 24 70 02 	vmovups YMMWORD PTR [rsp+0x270],ymm0
  22110d:	00 00 
  22110f:	48 8b 84 24 86 00 00 	mov    rax,QWORD PTR [rsp+0x86]
  221116:	00 
  221117:	48 89 84 24 8e 02 00 	mov    QWORD PTR [rsp+0x28e],rax
  22111e:	00 
    try st.abbrev_table_list.append(AbbrevTableHeader{
  22111f:	48 8d 84 24 76 02 00 	lea    rax,[rsp+0x276]
  221126:	00 
  221127:	c5 fe 6f 00          	vmovdqu ymm0,YMMWORD PTR [rax]
  22112b:	c5 fe 7f 84 24 e0 02 	vmovdqu YMMWORD PTR [rsp+0x2e0],ymm0
  221132:	00 00 
            const new_length = self.len + 1;
  221134:	48 8b ac 24 08 02 00 	mov    rbp,QWORD PTR [rsp+0x208]
  22113b:	00 
            var better_capacity = self.items.len;
  22113c:	48 8b 8c 24 00 02 00 	mov    rcx,QWORD PTR [rsp+0x200]
  221143:	00 
            if (better_capacity >= new_capacity) return;
  221144:	48 39 e9             	cmp    rcx,rbp
  221147:	76 05                	jbe    22114e <openSelfDebugInfoLinux+0x21be>
            const result = &self.items[self.len];
  221149:	48 89 e8             	mov    rax,rbp
  22114c:	eb 60                	jmp    2211ae <openSelfDebugInfoLinux+0x221e>
                better_capacity += better_capacity / 2 + 8;
  22114e:	48 89 c8             	mov    rax,rcx
  221151:	48 d1 e8             	shr    rax,1
  221154:	48 01 c1             	add    rcx,rax
  221157:	48 83 c1 08          	add    rcx,0x8
                if (better_capacity >= new_capacity) break;
  22115b:	48 39 e9             	cmp    rcx,rbp
  22115e:	76 ee                	jbe    22114e <openSelfDebugInfoLinux+0x21be>
            self.items = try self.allocator.alignedRealloc(T, A, self.items, better_capacity);
  221160:	48 8b b4 24 10 02 00 	mov    rsi,QWORD PTR [rsp+0x210]
  221167:	00 
  221168:	4c 89 f7             	mov    rdi,r14
  22116b:	48 8d 94 24 f8 01 00 	lea    rdx,[rsp+0x1f8]
  221172:	00 
  221173:	c5 f8 77             	vzeroupper 
  221176:	e8 25 35 00 00       	call   2246a0 <Allocator_alignedRealloc.155>
  22117b:	0f b7 8c 24 c0 00 00 	movzx  ecx,WORD PTR [rsp+0xc0]
  221182:	00 
  221183:	89 c8                	mov    eax,ecx
  221185:	66 85 c9             	test   cx,cx
  221188:	0f 85 fa 0e 00 00    	jne    222088 <openSelfDebugInfoLinux+0x30f8>
  22118e:	48 8d 84 24 c8 00 00 	lea    rax,[rsp+0xc8]
  221195:	00 
  221196:	c5 fa 6f 00          	vmovdqu xmm0,XMMWORD PTR [rax]
  22119a:	48 8d 84 24 f8 01 00 	lea    rax,[rsp+0x1f8]
  2211a1:	00 
  2211a2:	c5 fa 7f 00          	vmovdqu XMMWORD PTR [rax],xmm0
            const result = &self.items[self.len];
  2211a6:	48 8b 84 24 08 02 00 	mov    rax,QWORD PTR [rsp+0x208]
  2211ad:	00 
  2211ae:	48 83 c5 01          	add    rbp,0x1
  2211b2:	48 8b 8c 24 f8 01 00 	mov    rcx,QWORD PTR [rsp+0x1f8]
  2211b9:	00 
            self.len = new_length;
  2211ba:	48 89 ac 24 08 02 00 	mov    QWORD PTR [rsp+0x208],rbp
  2211c1:	00 
            new_item_ptr.* = item;
  2211c2:	48 8d 04 80          	lea    rax,[rax+rax*4]
  2211c6:	48 8b 54 24 58       	mov    rdx,QWORD PTR [rsp+0x58]
  2211cb:	48 89 14 c1          	mov    QWORD PTR [rcx+rax*8],rdx
  2211cf:	c5 fe 6f 84 24 e0 02 	vmovdqu ymm0,YMMWORD PTR [rsp+0x2e0]
  2211d6:	00 00 
  2211d8:	c5 fe 7f 44 c1 08    	vmovdqu YMMWORD PTR [rcx+rax*8+0x8],ymm0
    return &st.abbrev_table_list.items[st.abbrev_table_list.len - 1].table;
  2211de:	48 8b 84 24 f8 01 00 	mov    rax,QWORD PTR [rsp+0x1f8]
  2211e5:	00 
  2211e6:	48 8b 8c 24 08 02 00 	mov    rcx,QWORD PTR [rsp+0x208]
  2211ed:	00 
  2211ee:	48 8d 0c 89          	lea    rcx,[rcx+rcx*4]
  2211f2:	48 8d 2c c8          	lea    rbp,[rax+rcx*8]
  2211f6:	48 83 c5 e0          	add    rbp,0xffffffffffffffe0
  2211fa:	66 bf 04 00          	mov    di,0x4
  2211fe:	48 83 7c 24 38 00    	cmp    QWORD PTR [rsp+0x38],0x0
  221204:	0f 88 b5 0f 00 00    	js     2221bf <openSelfDebugInfoLinux+0x322f>
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  22120a:	48 63 bc 24 70 01 00 	movsxd rdi,DWORD PTR [rsp+0x170]
  221211:	00 
  221212:	b8 08 00 00 00       	mov    eax,0x8
  221217:	31 d2                	xor    edx,edx
  221219:	48 8b 74 24 38       	mov    rsi,QWORD PTR [rsp+0x38]
  22121e:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  221220:	48 89 c1             	mov    rcx,rax
  221223:	48 f7 d9             	neg    rcx
  221226:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  22122c:	b8 00 00 00 00       	mov    eax,0x0
  221231:	48 0f 46 c8          	cmovbe rcx,rax
  221235:	48 85 c9             	test   rcx,rcx
  221238:	0f 85 bc 0e 00 00    	jne    2220fa <openSelfDebugInfoLinux+0x316a>
  22123e:	48 8b 84 24 10 02 00 	mov    rax,QWORD PTR [rsp+0x210]
  221245:	00 
    var in_file_stream = io.FileInStream.init(in_file);
  221246:	48 89 84 24 68 02 00 	mov    QWORD PTR [rsp+0x268],rax
  22124d:	00 
  22124e:	4c 89 6c 24 40       	mov    QWORD PTR [rsp+0x40],r13
  221253:	48 8d 05 06 2f 00 00 	lea    rax,[rip+0x2f06]        # 224160 <FileInStream_readFn>
  22125a:	48 89 44 24 48       	mov    QWORD PTR [rsp+0x48],rax
            try self.readNoEof(result[0..]);
  22125f:	48 8d 44 24 0f       	lea    rax,[rsp+0xf]
  221264:	48 89 84 24 e0 02 00 	mov    QWORD PTR [rsp+0x2e0],rax
  22126b:	00 
  22126c:	48 c7 84 24 e8 02 00 	mov    QWORD PTR [rsp+0x2e8],0x1
  221273:	00 01 00 00 00 
        return self.file.read(buffer);
  221278:	48 8b 74 24 40       	mov    rsi,QWORD PTR [rsp+0x40]
  22127d:	48 8d bc 24 70 02 00 	lea    rdi,[rsp+0x270]
  221284:	00 
  221285:	48 8d 94 24 e0 02 00 	lea    rdx,[rsp+0x2e0]
  22128c:	00 
  22128d:	c5 f8 77             	vzeroupper 
  221290:	e8 9b 2d 00 00       	call   224030 <File_read>
  221295:	c5 fa 6f 84 24 70 02 	vmovdqu xmm0,XMMWORD PTR [rsp+0x270]
  22129c:	00 00 
  22129e:	c5 f9 7f 84 24 b0 02 	vmovdqa XMMWORD PTR [rsp+0x2b0],xmm0
  2212a5:	00 00 
            return self.readFn(self, buffer);
  2212a7:	0f b7 8c 24 b0 02 00 	movzx  ecx,WORD PTR [rsp+0x2b0]
  2212ae:	00 
            const amt_read = try self.read(buf);
  2212af:	66 85 c9             	test   cx,cx
  2212b2:	0f 85 e4 0d 00 00    	jne    22209c <openSelfDebugInfoLinux+0x310c>
  2212b8:	0f b6 84 24 b0 00 00 	movzx  eax,BYTE PTR [rsp+0xb0]
  2212bf:	00 
  2212c0:	48 89 84 24 38 02 00 	mov    QWORD PTR [rsp+0x238],rax
  2212c7:	00 
  2212c8:	48 8d 04 c5 04 00 00 	lea    rax,[rax*8+0x4]
  2212cf:	00 
  2212d0:	48 89 84 24 d0 02 00 	mov    QWORD PTR [rsp+0x2d0],rax
  2212d7:	00 
  2212d8:	48 8b 84 24 b8 02 00 	mov    rax,QWORD PTR [rsp+0x2b8]
  2212df:	00 
  2212e0:	31 c9                	xor    ecx,ecx
  2212e2:	48 89 4c 24 58       	mov    QWORD PTR [rsp+0x58],rcx
  2212e7:	31 c9                	xor    ecx,ecx
            if (amt_read < buf.len) return error.EndOfStream;
  2212e9:	48 89 4c 24 30       	mov    QWORD PTR [rsp+0x30],rcx
  2212ee:	48 3b 84 24 e8 02 00 	cmp    rax,QWORD PTR [rsp+0x2e8]
  2212f5:	00 
  2212f6:	48 8b 7c 24 30       	mov    rdi,QWORD PTR [rsp+0x30]
  2212fb:	0f 82 97 0d 00 00    	jb     222098 <openSelfDebugInfoLinux+0x3108>
            return result[0];
  221301:	0f b6 44 24 0f       	movzx  eax,BYTE PTR [rsp+0xf]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  221306:	89 c2                	mov    edx,eax
  221308:	83 e2 7f             	and    edx,0x7f
  22130b:	89 fe                	mov    esi,edi
  22130d:	83 e6 3f             	and    esi,0x3f
  221310:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  221315:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  22131a:	48 39 d6             	cmp    rsi,rdx
  22131d:	0f 85 7d 0d 00 00    	jne    2220a0 <openSelfDebugInfoLinux+0x3110>
        result |= operand;
  221323:	48 09 4c 24 58       	or     QWORD PTR [rsp+0x58],rcx
        if ((byte & 0b10000000) == 0) return result;
  221328:	84 c0                	test   al,al
  22132a:	79 59                	jns    221385 <openSelfDebugInfoLinux+0x23f5>
        shift += 7;
  22132c:	48 83 c7 07          	add    rdi,0x7
  221330:	48 89 7c 24 30       	mov    QWORD PTR [rsp+0x30],rdi
            try self.readNoEof(result[0..]);
  221335:	48 8d 44 24 0f       	lea    rax,[rsp+0xf]
  22133a:	48 89 84 24 e0 02 00 	mov    QWORD PTR [rsp+0x2e0],rax
  221341:	00 
  221342:	48 c7 84 24 e8 02 00 	mov    QWORD PTR [rsp+0x2e8],0x1
  221349:	00 01 00 00 00 
            return self.readFn(self, buffer);
  22134e:	48 8d bc 24 b0 02 00 	lea    rdi,[rsp+0x2b0]
  221355:	00 
  221356:	48 8d 74 24 48       	lea    rsi,[rsp+0x48]
  22135b:	48 8d 94 24 e0 02 00 	lea    rdx,[rsp+0x2e0]
  221362:	00 
  221363:	ff 54 24 48          	call   QWORD PTR [rsp+0x48]
  221367:	0f b7 8c 24 b0 02 00 	movzx  ecx,WORD PTR [rsp+0x2b0]
  22136e:	00 
  22136f:	48 8b 84 24 b8 02 00 	mov    rax,QWORD PTR [rsp+0x2b8]
  221376:	00 
            const amt_read = try self.read(buf);
  221377:	66 85 c9             	test   cx,cx
  22137a:	0f 84 6e ff ff ff    	je     2212ee <openSelfDebugInfoLinux+0x235e>
  221380:	e9 17 0d 00 00       	jmp    22209c <openSelfDebugInfoLinux+0x310c>
            return self.items[0..self.len];
  221385:	48 8b 45 10          	mov    rax,QWORD PTR [rbp+0x10]
    for (abbrev_table.toSliceConst()) |*table_entry| {
  221389:	48 85 c0             	test   rax,rax
  22138c:	0f 84 99 0d 00 00    	je     22212b <openSelfDebugInfoLinux+0x319b>
  221392:	48 8b 6d 00          	mov    rbp,QWORD PTR [rbp+0x0]
  221396:	31 c9                	xor    ecx,ecx
        if (table_entry.abbrev_code == abbrev_code) return table_entry;
  221398:	48 8b 54 24 58       	mov    rdx,QWORD PTR [rsp+0x58]
  22139d:	48 39 55 08          	cmp    QWORD PTR [rbp+0x8],rdx
  2213a1:	74 12                	je     2213b5 <openSelfDebugInfoLinux+0x2425>
    for (abbrev_table.toSliceConst()) |*table_entry| {
  2213a3:	48 83 c1 01          	add    rcx,0x1
  2213a7:	48 83 c5 38          	add    rbp,0x38
  2213ab:	48 39 c1             	cmp    rcx,rax
  2213ae:	72 e8                	jb     221398 <openSelfDebugInfoLinux+0x2408>
  2213b0:	e9 76 0d 00 00       	jmp    22212b <openSelfDebugInfoLinux+0x319b>
    const table_entry = getAbbrevTableEntry(abbrev_table, abbrev_code) orelse return error.InvalidDebugInfo;
  2213b5:	48 85 ed             	test   rbp,rbp
  2213b8:	0f 84 6d 0d 00 00    	je     22212b <openSelfDebugInfoLinux+0x319b>
        .tag_id = table_entry.tag_id,
  2213be:	48 8b 45 10          	mov    rax,QWORD PTR [rbp+0x10]
        .has_children = table_entry.has_children,
  2213c2:	8a 4d 00             	mov    cl,BYTE PTR [rbp+0x0]
  2213c5:	48 8b b4 24 10 02 00 	mov    rsi,QWORD PTR [rsp+0x210]
  2213cc:	00 
  2213cd:	48 8d 94 24 07 04 00 	lea    rdx,[rsp+0x407]
  2213d4:	00 
    var result = Die{
  2213d5:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  2213d9:	c5 fa 7f 02          	vmovdqu XMMWORD PTR [rdx],xmm0
  2213dd:	48 c7 42 10 00 00 00 	mov    QWORD PTR [rdx+0x10],0x0
  2213e4:	00 
  2213e5:	48 89 84 24 30 03 00 	mov    QWORD PTR [rsp+0x330],rax
  2213ec:	00 
  2213ed:	88 8c 24 38 03 00 00 	mov    BYTE PTR [rsp+0x338],cl
  2213f4:	c5 fa 6f 84 24 00 04 	vmovdqu xmm0,XMMWORD PTR [rsp+0x400]
  2213fb:	00 00 
  2213fd:	c5 fa 6f 8c 24 0f 04 	vmovdqu xmm1,XMMWORD PTR [rsp+0x40f]
  221404:	00 00 
  221406:	48 8d 84 24 39 03 00 	lea    rax,[rsp+0x339]
  22140d:	00 
  22140e:	c5 fa 7f 48 0f       	vmovdqu XMMWORD PTR [rax+0xf],xmm1
  221413:	c5 fa 7f 00          	vmovdqu XMMWORD PTR [rax],xmm0
  221417:	48 89 b4 24 58 03 00 	mov    QWORD PTR [rsp+0x358],rsi
  22141e:	00 
    try result.attrs.resize(table_entry.attrs.len);
  22141f:	48 8b 45 28          	mov    rax,QWORD PTR [rbp+0x28]
            var better_capacity = self.items.len;
  221423:	48 8b 8c 24 48 03 00 	mov    rcx,QWORD PTR [rsp+0x348]
  22142a:	00 
  22142b:	48 89 44 24 30       	mov    QWORD PTR [rsp+0x30],rax
            if (better_capacity >= new_capacity) return;
  221430:	48 39 c1             	cmp    rcx,rax
  221433:	73 5b                	jae    221490 <openSelfDebugInfoLinux+0x2500>
                better_capacity += better_capacity / 2 + 8;
  221435:	48 89 c8             	mov    rax,rcx
  221438:	48 d1 e8             	shr    rax,1
  22143b:	48 01 c1             	add    rcx,rax
  22143e:	48 83 c1 08          	add    rcx,0x8
                if (better_capacity >= new_capacity) break;
  221442:	48 3b 4c 24 30       	cmp    rcx,QWORD PTR [rsp+0x30]
  221447:	72 ec                	jb     221435 <openSelfDebugInfoLinux+0x24a5>
            self.items = try self.allocator.alignedRealloc(T, A, self.items, better_capacity);
  221449:	48 8d bc 24 70 02 00 	lea    rdi,[rsp+0x270]
  221450:	00 
  221451:	48 8d 94 24 40 03 00 	lea    rdx,[rsp+0x340]
  221458:	00 
  221459:	e8 e2 5f 00 00       	call   227440 <Allocator_alignedRealloc.158>
  22145e:	0f b7 8c 24 70 02 00 	movzx  ecx,WORD PTR [rsp+0x270]
  221465:	00 
  221466:	89 c8                	mov    eax,ecx
  221468:	66 85 c9             	test   cx,cx
  22146b:	0f 85 24 10 00 00    	jne    222495 <openSelfDebugInfoLinux+0x3505>
  221471:	48 8d 84 24 76 02 00 	lea    rax,[rsp+0x276]
  221478:	00 
  221479:	c5 fa 6f 40 02       	vmovdqu xmm0,XMMWORD PTR [rax+0x2]
  22147e:	48 8d 84 24 40 03 00 	lea    rax,[rsp+0x340]
  221485:	00 
  221486:	c5 fa 7f 00          	vmovdqu XMMWORD PTR [rax],xmm0
            return self.items[0..self.len];
  22148a:	48 8b 45 28          	mov    rax,QWORD PTR [rbp+0x28]
  22148e:	eb 05                	jmp    221495 <openSelfDebugInfoLinux+0x2505>
  221490:	48 8b 44 24 30       	mov    rax,QWORD PTR [rsp+0x30]
  221495:	48 89 84 24 40 02 00 	mov    QWORD PTR [rsp+0x240],rax
  22149c:	00 
            self.len = new_len;
  22149d:	48 8b 44 24 30       	mov    rax,QWORD PTR [rsp+0x30]
  2214a2:	48 89 84 24 50 03 00 	mov    QWORD PTR [rsp+0x350],rax
  2214a9:	00 
    for (table_entry.attrs.toSliceConst()) |attr, i| {
  2214aa:	48 83 bc 24 40 02 00 	cmp    QWORD PTR [rsp+0x240],0x0
  2214b1:	00 00 
  2214b3:	0f 84 c1 00 00 00    	je     22157a <openSelfDebugInfoLinux+0x25ea>
  2214b9:	48 8b 45 18          	mov    rax,QWORD PTR [rbp+0x18]
  2214bd:	48 8b ac 24 40 03 00 	mov    rbp,QWORD PTR [rsp+0x340]
  2214c4:	00 
  2214c5:	48 83 c0 08          	add    rax,0x8
  2214c9:	48 89 44 24 30       	mov    QWORD PTR [rsp+0x30],rax
  2214ce:	48 83 c5 08          	add    rbp,0x8
  2214d2:	31 c0                	xor    eax,eax
  2214d4:	48 89 44 24 58       	mov    QWORD PTR [rsp+0x58],rax
  2214d9:	48 8b 44 24 30       	mov    rax,QWORD PTR [rsp+0x30]
  2214de:	48 8b 48 f8          	mov    rcx,QWORD PTR [rax-0x8]
  2214e2:	48 89 4c 24 38       	mov    QWORD PTR [rsp+0x38],rcx
  2214e7:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  2214ea:	48 8b b4 24 10 02 00 	mov    rsi,QWORD PTR [rsp+0x210]
  2214f1:	00 
            .value = try parseFormValue(st.allocator(), in_stream, attr.form_id, is_64),
  2214f2:	48 8d bc 24 28 04 00 	lea    rdi,[rsp+0x428]
  2214f9:	00 
  2214fa:	48 8d 54 24 48       	lea    rdx,[rsp+0x48]
  2214ff:	4c 8b 84 24 38 02 00 	mov    r8,QWORD PTR [rsp+0x238]
  221506:	00 
  221507:	c5 f8 77             	vzeroupper 
  22150a:	e8 31 34 00 00       	call   224940 <parseFormValue>
  22150f:	0f b7 8c 24 28 04 00 	movzx  ecx,WORD PTR [rsp+0x428]
  221516:	00 
  221517:	89 c8                	mov    eax,ecx
  221519:	66 85 c9             	test   cx,cx
  22151c:	0f 85 cd 0e 00 00    	jne    2223ef <openSelfDebugInfoLinux+0x345f>
        result.attrs.items[i] = Die.Attr{
  221522:	48 8d 84 24 30 04 00 	lea    rax,[rsp+0x430]
  221529:	00 
  22152a:	c5 fc 10 00          	vmovups ymm0,YMMWORD PTR [rax]
  22152e:	c5 fc 11 84 24 50 04 	vmovups YMMWORD PTR [rsp+0x450],ymm0
  221535:	00 00 
  221537:	48 8b 44 24 38       	mov    rax,QWORD PTR [rsp+0x38]
  22153c:	48 89 45 f8          	mov    QWORD PTR [rbp-0x8],rax
  221540:	c5 fe 6f 84 24 50 04 	vmovdqu ymm0,YMMWORD PTR [rsp+0x450]
  221547:	00 00 
  221549:	c5 fe 7f 45 00       	vmovdqu YMMWORD PTR [rbp+0x0],ymm0
  22154e:	48 8b 44 24 58       	mov    rax,QWORD PTR [rsp+0x58]
  221553:	48 89 c1             	mov    rcx,rax
    for (table_entry.attrs.toSliceConst()) |attr, i| {
  221556:	48 83 c1 01          	add    rcx,0x1
  22155a:	48 83 44 24 30 10    	add    QWORD PTR [rsp+0x30],0x10
  221560:	48 83 c5 28          	add    rbp,0x28
  221564:	48 89 c8             	mov    rax,rcx
  221567:	48 89 44 24 58       	mov    QWORD PTR [rsp+0x58],rax
  22156c:	48 3b 8c 24 40 02 00 	cmp    rcx,QWORD PTR [rsp+0x240]
  221573:	00 
  221574:	0f 82 5f ff ff ff    	jb     2214d9 <openSelfDebugInfoLinux+0x2549>
    return result;
  22157a:	c5 fc 10 84 24 30 03 	vmovups ymm0,YMMWORD PTR [rsp+0x330]
  221581:	00 00 
  221583:	c5 fc 10 8c 24 40 03 	vmovups ymm1,YMMWORD PTR [rsp+0x340]
  22158a:	00 00 
  22158c:	48 8d 84 24 ee 04 00 	lea    rax,[rsp+0x4ee]
  221593:	00 
  221594:	c5 fc 11 48 10       	vmovups YMMWORD PTR [rax+0x10],ymm1
  221599:	c5 fc 11 00          	vmovups YMMWORD PTR [rax],ymm0
  22159d:	c5 fc 10 84 24 e8 04 	vmovups ymm0,YMMWORD PTR [rsp+0x4e8]
  2215a4:	00 00 
  2215a6:	c5 fc 10 8c 24 fe 04 	vmovups ymm1,YMMWORD PTR [rsp+0x4fe]
  2215ad:	00 00 
  2215af:	c5 fc 11 84 24 60 03 	vmovups YMMWORD PTR [rsp+0x360],ymm0
  2215b6:	00 00 
  2215b8:	c5 fc 11 8c 24 76 03 	vmovups YMMWORD PTR [rsp+0x376],ymm1
  2215bf:	00 00 
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  2215c1:	ba 30 00 00 00       	mov    edx,0x30
  2215c6:	b9 08 00 00 00       	mov    ecx,0x8
  2215cb:	4c 89 f7             	mov    rdi,r14
  2215ce:	48 8b b4 24 68 02 00 	mov    rsi,QWORD PTR [rsp+0x268]
  2215d5:	00 
  2215d6:	c5 f8 77             	vzeroupper 
  2215d9:	ff 16                	call   QWORD PTR [rsi]
  2215db:	0f b7 8c 24 c0 00 00 	movzx  ecx,WORD PTR [rsp+0xc0]
  2215e2:	00 
  2215e3:	89 c8                	mov    eax,ecx
  2215e5:	66 85 c9             	test   cx,cx
  2215e8:	0f 85 9a 0a 00 00    	jne    222088 <openSelfDebugInfoLinux+0x30f8>
        assert(byte_slice.len == byte_count);
  2215ee:	48 83 bc 24 d0 00 00 	cmp    QWORD PTR [rsp+0xd0],0x30
  2215f5:	00 30 
    if (!ok) {
  2215f7:	0f 85 d9 1a 00 00    	jne    2230d6 <openSelfDebugInfoLinux+0x4146>
  2215fd:	48 8b 8c 24 c8 00 00 	mov    rcx,QWORD PTR [rsp+0xc8]
  221604:	00 
  221605:	48 8d 84 24 66 03 00 	lea    rax,[rsp+0x366]
  22160c:	00 
        ptr.* = init;
  22160d:	c5 fe 6f 00          	vmovdqu ymm0,YMMWORD PTR [rax]
  221611:	c5 fe 6f 48 10       	vmovdqu ymm1,YMMWORD PTR [rax+0x10]
  221616:	c5 fe 7f 01          	vmovdqu YMMWORD PTR [rcx],ymm0
  22161a:	c5 fe 7f 49 10       	vmovdqu YMMWORD PTR [rcx+0x10],ymm1
  22161f:	48 89 4c 24 30       	mov    QWORD PTR [rsp+0x30],rcx
        if (compile_unit_die.tag_id != DW.TAG_compile_unit) return error.InvalidDebugInfo;
  221624:	48 83 39 11          	cmp    QWORD PTR [rcx],0x11
  221628:	0f 85 ba 0a 00 00    	jne    2220e8 <openSelfDebugInfoLinux+0x3158>
  22162e:	48 8b 44 24 30       	mov    rax,QWORD PTR [rsp+0x30]
  221633:	48 8b 48 20          	mov    rcx,QWORD PTR [rax+0x20]
        for (self.attrs.toSliceConst()) |*attr| {
  221637:	48 85 c9             	test   rcx,rcx
  22163a:	74 25                	je     221661 <openSelfDebugInfoLinux+0x26d1>
  22163c:	48 8b 44 24 30       	mov    rax,QWORD PTR [rsp+0x30]
  221641:	48 8b 50 10          	mov    rdx,QWORD PTR [rax+0x10]
  221645:	48 89 d0             	mov    rax,rdx
  221648:	31 f6                	xor    esi,esi
            if (attr.id == id) return &attr.value;
  22164a:	48 83 38 11          	cmp    QWORD PTR [rax],0x11
  22164e:	0f 84 61 01 00 00    	je     2217b5 <openSelfDebugInfoLinux+0x2825>
        for (self.attrs.toSliceConst()) |*attr| {
  221654:	48 83 c6 01          	add    rsi,0x1
  221658:	48 83 c0 28          	add    rax,0x28
  22165c:	48 39 ce             	cmp    rsi,rcx
  22165f:	72 e9                	jb     22164a <openSelfDebugInfoLinux+0x26ba>
        const pc_range = x: {
  221661:	48 8d 05 c0 6b fe ff 	lea    rax,[rip+0xfffffffffffe6bc0]        # 208228 <__unnamed_47>
  221668:	48 8b 48 10          	mov    rcx,QWORD PTR [rax+0x10]
  22166c:	48 89 8c 24 a0 04 00 	mov    QWORD PTR [rsp+0x4a0],rcx
  221673:	00 
  221674:	c5 fa 6f 00          	vmovdqu xmm0,XMMWORD PTR [rax]
  221678:	c5 f9 7f 84 24 90 04 	vmovdqa XMMWORD PTR [rsp+0x490],xmm0
  22167f:	00 00 
            const new_length = self.len + 1;
  221681:	48 8b ac 24 28 02 00 	mov    rbp,QWORD PTR [rsp+0x228]
  221688:	00 
            var better_capacity = self.items.len;
  221689:	48 8b 8c 24 20 02 00 	mov    rcx,QWORD PTR [rsp+0x220]
  221690:	00 
            if (better_capacity >= new_capacity) return;
  221691:	48 39 e9             	cmp    rcx,rbp
  221694:	76 05                	jbe    22169b <openSelfDebugInfoLinux+0x270b>
            const result = &self.items[self.len];
  221696:	48 89 e8             	mov    rax,rbp
  221699:	eb 60                	jmp    2216fb <openSelfDebugInfoLinux+0x276b>
                better_capacity += better_capacity / 2 + 8;
  22169b:	48 89 c8             	mov    rax,rcx
  22169e:	48 d1 e8             	shr    rax,1
  2216a1:	48 01 c1             	add    rcx,rax
  2216a4:	48 83 c1 08          	add    rcx,0x8
                if (better_capacity >= new_capacity) break;
  2216a8:	48 39 e9             	cmp    rcx,rbp
  2216ab:	76 ee                	jbe    22169b <openSelfDebugInfoLinux+0x270b>
            self.items = try self.allocator.alignedRealloc(T, A, self.items, better_capacity);
  2216ad:	48 8b b4 24 30 02 00 	mov    rsi,QWORD PTR [rsp+0x230]
  2216b4:	00 
  2216b5:	4c 89 f7             	mov    rdi,r14
  2216b8:	48 8d 94 24 18 02 00 	lea    rdx,[rsp+0x218]
  2216bf:	00 
  2216c0:	c5 f8 77             	vzeroupper 
  2216c3:	e8 28 63 00 00       	call   2279f0 <Allocator_alignedRealloc.165>
  2216c8:	0f b7 8c 24 c0 00 00 	movzx  ecx,WORD PTR [rsp+0xc0]
  2216cf:	00 
  2216d0:	89 c8                	mov    eax,ecx
  2216d2:	66 85 c9             	test   cx,cx
  2216d5:	0f 85 ad 09 00 00    	jne    222088 <openSelfDebugInfoLinux+0x30f8>
  2216db:	48 8d 84 24 c8 00 00 	lea    rax,[rsp+0xc8]
  2216e2:	00 
  2216e3:	c5 fa 6f 00          	vmovdqu xmm0,XMMWORD PTR [rax]
  2216e7:	48 8d 84 24 18 02 00 	lea    rax,[rsp+0x218]
  2216ee:	00 
  2216ef:	c5 fa 7f 00          	vmovdqu XMMWORD PTR [rax],xmm0
            const result = &self.items[self.len];
  2216f3:	48 8b 84 24 28 02 00 	mov    rax,QWORD PTR [rsp+0x228]
  2216fa:	00 
  2216fb:	48 83 c5 01          	add    rbp,0x1
  2216ff:	48 8b 8c 24 18 02 00 	mov    rcx,QWORD PTR [rsp+0x218]
  221706:	00 
  221707:	48 8d 04 40          	lea    rax,[rax+rax*2]
  22170b:	48 c1 e0 04          	shl    rax,0x4
            self.len = new_length;
  22170f:	48 89 ac 24 28 02 00 	mov    QWORD PTR [rsp+0x228],rbp
  221716:	00 
            new_item_ptr.* = item;
  221717:	48 8b 94 24 a0 03 00 	mov    rdx,QWORD PTR [rsp+0x3a0]
  22171e:	00 
  22171f:	66 89 14 01          	mov    WORD PTR [rcx+rax*1],dx
  221723:	8b 94 24 b0 00 00 00 	mov    edx,DWORD PTR [rsp+0xb0]
  22172a:	88 54 01 02          	mov    BYTE PTR [rcx+rax*1+0x2],dl
  22172e:	8a 94 24 0f 03 00 00 	mov    dl,BYTE PTR [rsp+0x30f]
  221735:	88 54 01 07          	mov    BYTE PTR [rcx+rax*1+0x7],dl
  221739:	8b 94 24 0b 03 00 00 	mov    edx,DWORD PTR [rsp+0x30b]
  221740:	89 54 01 03          	mov    DWORD PTR [rcx+rax*1+0x3],edx
  221744:	48 8b 54 24 30       	mov    rdx,QWORD PTR [rsp+0x30]
  221749:	48 89 54 01 08       	mov    QWORD PTR [rcx+rax*1+0x8],rdx
  22174e:	48 8b 94 24 10 03 00 	mov    rdx,QWORD PTR [rsp+0x310]
  221755:	00 
  221756:	48 89 d6             	mov    rsi,rdx
  221759:	48 89 74 01 10       	mov    QWORD PTR [rcx+rax*1+0x10],rsi
  22175e:	48 8b 94 24 a0 04 00 	mov    rdx,QWORD PTR [rsp+0x4a0]
  221765:	00 
  221766:	48 89 54 01 28       	mov    QWORD PTR [rcx+rax*1+0x28],rdx
  22176b:	c5 f9 6f 84 24 90 04 	vmovdqa xmm0,XMMWORD PTR [rsp+0x490]
  221772:	00 00 
  221774:	c5 fa 7f 44 01 18    	vmovdqu XMMWORD PTR [rcx+rax*1+0x18],xmm0
  22177a:	48 8b 84 24 d0 02 00 	mov    rax,QWORD PTR [rsp+0x2d0]
  221781:	00 
        const next_offset = unit_length + (if (is_64) usize(12) else usize(4));
  221782:	48 03 44 24 60       	add    rax,QWORD PTR [rsp+0x60]
        this_unit_offset += next_offset;
  221787:	48 03 84 24 48 02 00 	add    rax,QWORD PTR [rsp+0x248]
  22178e:	00 
        cu_index += 1;
  22178f:	48 83 c6 01          	add    rsi,0x1
  221793:	48 89 b4 24 10 03 00 	mov    QWORD PTR [rsp+0x310],rsi
  22179a:	00 
  22179b:	31 ff                	xor    edi,edi
  22179d:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
    while (this_unit_offset < debug_info_end) {
  2217a2:	48 3b 84 24 a8 03 00 	cmp    rax,QWORD PTR [rsp+0x3a8]
  2217a9:	00 
  2217aa:	0f 82 39 ee ff ff    	jb     2205e9 <openSelfDebugInfoLinux+0x1659>
  2217b0:	e9 0a 0a 00 00       	jmp    2221bf <openSelfDebugInfoLinux+0x322f>
        return switch (form_value.*) {
  2217b5:	40 8a 78 20          	mov    dil,BYTE PTR [rax+0x20]
  2217b9:	48 8d 35 30 f2 fd ff 	lea    rsi,[rip+0xfffffffffffdf230]        # 2009f0 <__unnamed_48>
  2217c0:	40 84 ff             	test   dil,dil
  2217c3:	75 19                	jne    2217de <openSelfDebugInfoLinux+0x284e>
            FormValue.Address => |value| value,
  2217c5:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
  2217c9:	66 c7 84 24 c0 00 00 	mov    WORD PTR [rsp+0xc0],0x0
  2217d0:	00 00 00 
  2217d3:	48 89 84 24 c8 00 00 	mov    QWORD PTR [rsp+0xc8],rax
  2217da:	00 
  2217db:	4c 89 f6             	mov    rsi,r14
            if (compile_unit_die.getAttrAddr(DW.AT_low_pc)) |low_pc| {
  2217de:	0f b7 3e             	movzx  edi,WORD PTR [rsi]
        const pc_range = x: {
  2217e1:	48 8d 05 40 6a fe ff 	lea    rax,[rip+0xfffffffffffe6a40]        # 208228 <__unnamed_47>
  2217e8:	89 fd                	mov    ebp,edi
            if (compile_unit_die.getAttrAddr(DW.AT_low_pc)) |low_pc| {
  2217ea:	83 ff 28             	cmp    edi,0x28
  2217ed:	0f 84 75 fe ff ff    	je     221668 <openSelfDebugInfoLinux+0x26d8>
  2217f3:	89 ef                	mov    edi,ebp
  2217f5:	66 85 ff             	test   di,di
  2217f8:	0f 85 c1 09 00 00    	jne    2221bf <openSelfDebugInfoLinux+0x322f>
  2217fe:	4c 8b 4e 08          	mov    r9,QWORD PTR [rsi+0x8]
            if (attr.id == id) return &attr.value;
  221802:	48 83 c2 20          	add    rdx,0x20
  221806:	31 f6                	xor    esi,esi
  221808:	48 83 7a e0 12       	cmp    QWORD PTR [rdx-0x20],0x12
  22180d:	74 12                	je     221821 <openSelfDebugInfoLinux+0x2891>
        for (self.attrs.toSliceConst()) |*attr| {
  22180f:	48 83 c6 01          	add    rsi,0x1
  221813:	48 83 c2 28          	add    rdx,0x28
  221817:	48 39 ce             	cmp    rsi,rcx
  22181a:	72 ec                	jb     221808 <openSelfDebugInfoLinux+0x2878>
  22181c:	e9 40 fe ff ff       	jmp    221661 <openSelfDebugInfoLinux+0x26d1>
  221821:	8a 0a                	mov    cl,BYTE PTR [rdx]
  221823:	80 f9 02             	cmp    cl,0x2
                    const pc_end = switch (high_pc_value.*) {
  221826:	74 15                	je     22183d <openSelfDebugInfoLinux+0x28ad>
  221828:	66 bf 29 00          	mov    di,0x29
  22182c:	84 c9                	test   cl,cl
  22182e:	0f 85 8b 09 00 00    	jne    2221bf <openSelfDebugInfoLinux+0x322f>
                        FormValue.Address => |value| value,
  221834:	48 8b 7a e8          	mov    rdi,QWORD PTR [rdx-0x18]
  221838:	e9 33 02 00 00       	jmp    221a70 <openSelfDebugInfoLinux+0x2ae0>
                        FormValue.Const => |value| b: {
  22183d:	48 8b 4a f0          	mov    rcx,QWORD PTR [rdx-0x10]
        if (self.payload.len > @sizeOf(u64)) return error.InvalidDebugInfo;
  221841:	48 83 f9 08          	cmp    rcx,0x8
  221845:	0f 87 9d 08 00 00    	ja     2220e8 <openSelfDebugInfoLinux+0x3158>
  22184b:	f6 42 f8 01          	test   BYTE PTR [rdx-0x8],0x1
  22184f:	66 bf 29 00          	mov    di,0x29
  221853:	0f 85 66 09 00 00    	jne    2221bf <openSelfDebugInfoLinux+0x322f>
  221859:	48 85 c9             	test   rcx,rcx
            for (bytes) |b, index| {
  22185c:	74 13                	je     221871 <openSelfDebugInfoLinux+0x28e1>
  22185e:	48 8b 52 e8          	mov    rdx,QWORD PTR [rdx-0x18]
  221862:	48 83 f9 10          	cmp    rcx,0x10
  221866:	73 10                	jae    221878 <openSelfDebugInfoLinux+0x28e8>
  221868:	31 c0                	xor    eax,eax
  22186a:	31 ff                	xor    edi,edi
  22186c:	e9 d3 01 00 00       	jmp    221a44 <openSelfDebugInfoLinux+0x2ab4>
  221871:	31 ff                	xor    edi,edi
  221873:	e9 f5 01 00 00       	jmp    221a6d <openSelfDebugInfoLinux+0x2add>
  221878:	48 89 c8             	mov    rax,rcx
  22187b:	48 83 e0 f0          	and    rax,0xfffffffffffffff0
  22187f:	48 8d 78 f0          	lea    rdi,[rax-0x10]
  221883:	48 89 fd             	mov    rbp,rdi
  221886:	48 c1 ed 04          	shr    rbp,0x4
  22188a:	44 8d 45 01          	lea    r8d,[rbp+0x1]
  22188e:	41 83 e0 01          	and    r8d,0x1
  221892:	48 85 ff             	test   rdi,rdi
  221895:	0f 84 01 01 00 00    	je     22199c <openSelfDebugInfoLinux+0x2a0c>
  22189b:	49 8d 78 ff          	lea    rdi,[r8-0x1]
  22189f:	48 29 ef             	sub    rdi,rbp
  2218a2:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  2218a6:	31 ed                	xor    ebp,ebp
  2218a8:	c5 fd 6f 25 f0 e8 fd 	vmovdqa ymm4,YMMWORD PTR [rip+0xfffffffffffde8f0]        # 2001a0 <__unnamed_29-0x60>
  2218af:	ff 
  2218b0:	c5 f1 ef c9          	vpxor  xmm1,xmm1,xmm1
  2218b4:	c5 e1 ef db          	vpxor  xmm3,xmm3,xmm3
  2218b8:	c5 e9 ef d2          	vpxor  xmm2,xmm2,xmm2
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  2218bc:	c4 e2 7d 32 2c 2a    	vpmovzxbq ymm5,DWORD PTR [rdx+rbp*1]
  2218c2:	c4 e2 7d 32 74 2a 04 	vpmovzxbq ymm6,DWORD PTR [rdx+rbp*1+0x4]
  2218c9:	c4 e2 7d 32 7c 2a 08 	vpmovzxbq ymm7,DWORD PTR [rdx+rbp*1+0x8]
  2218d0:	c4 62 7d 32 44 2a 0c 	vpmovzxbq ymm8,DWORD PTR [rdx+rbp*1+0xc]
  2218d7:	c5 b5 73 f4 03       	vpsllq ymm9,ymm4,0x3
  2218dc:	c5 7e 6f a4 24 40 05 	vmovdqu ymm12,YMMWORD PTR [rsp+0x540]
  2218e3:	00 00 
  2218e5:	c4 41 35 d4 d4       	vpaddq ymm10,ymm9,ymm12
  2218ea:	c5 7e 6f ac 24 20 05 	vmovdqu ymm13,YMMWORD PTR [rsp+0x520]
  2218f1:	00 00 
  2218f3:	c4 41 35 db dd       	vpand  ymm11,ymm9,ymm13
  2218f8:	c4 41 2d db d5       	vpand  ymm10,ymm10,ymm13
  2218fd:	c4 c2 d5 47 eb       	vpsllvq ymm5,ymm5,ymm11
  221902:	c5 d5 eb c0          	vpor   ymm0,ymm5,ymm0
  221906:	c4 c2 cd 47 ea       	vpsllvq ymm5,ymm6,ymm10
  22190b:	c5 d5 eb c9          	vpor   ymm1,ymm5,ymm1
  22190f:	c4 c2 c5 47 eb       	vpsllvq ymm5,ymm7,ymm11
  221914:	c5 d5 eb db          	vpor   ymm3,ymm5,ymm3
  221918:	c4 c2 bd 47 ea       	vpsllvq ymm5,ymm8,ymm10
  22191d:	c4 e2 7d 32 74 2a 10 	vpmovzxbq ymm6,DWORD PTR [rdx+rbp*1+0x10]
  221924:	c4 e2 7d 32 7c 2a 14 	vpmovzxbq ymm7,DWORD PTR [rdx+rbp*1+0x14]
  22192b:	c4 62 7d 32 44 2a 18 	vpmovzxbq ymm8,DWORD PTR [rdx+rbp*1+0x18]
  221932:	c5 d5 eb d2          	vpor   ymm2,ymm5,ymm2
  221936:	c4 e2 7d 32 6c 2a 1c 	vpmovzxbq ymm5,DWORD PTR [rdx+rbp*1+0x1c]
  22193d:	c4 62 7d 59 15 aa f3 	vpbroadcastq ymm10,QWORD PTR [rip+0xfffffffffffdf3aa]        # 200cf0 <__unnamed_621+0x38>
  221944:	fd ff 
  221946:	c4 41 35 d4 d2       	vpaddq ymm10,ymm9,ymm10
  22194b:	c4 62 7d 59 1d d4 f2 	vpbroadcastq ymm11,QWORD PTR [rip+0xfffffffffffdf2d4]        # 200c28 <__unnamed_464+0x18>
  221952:	fd ff 
  221954:	c4 41 35 d4 cb       	vpaddq ymm9,ymm9,ymm11
  221959:	c4 41 2d db d5       	vpand  ymm10,ymm10,ymm13
  22195e:	c4 41 35 db cd       	vpand  ymm9,ymm9,ymm13
  221963:	c4 c2 cd 47 f2       	vpsllvq ymm6,ymm6,ymm10
  221968:	c5 cd eb c0          	vpor   ymm0,ymm6,ymm0
  22196c:	c4 c2 c5 47 f1       	vpsllvq ymm6,ymm7,ymm9
  221971:	c5 cd eb c9          	vpor   ymm1,ymm6,ymm1
  221975:	c4 c2 bd 47 f2       	vpsllvq ymm6,ymm8,ymm10
  22197a:	c5 cd eb db          	vpor   ymm3,ymm6,ymm3
  22197e:	c4 c2 d5 47 e9       	vpsllvq ymm5,ymm5,ymm9
  221983:	c5 d5 eb d2          	vpor   ymm2,ymm5,ymm2
            for (bytes) |b, index| {
  221987:	48 83 c5 20          	add    rbp,0x20
  22198b:	c4 c1 5d d4 e4       	vpaddq ymm4,ymm4,ymm12
  221990:	48 83 c7 02          	add    rdi,0x2
  221994:	0f 85 22 ff ff ff    	jne    2218bc <openSelfDebugInfoLinux+0x292c>
  22199a:	eb 1a                	jmp    2219b6 <openSelfDebugInfoLinux+0x2a26>
  22199c:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  2219a0:	31 ed                	xor    ebp,ebp
  2219a2:	c5 fd 6f 25 f6 e7 fd 	vmovdqa ymm4,YMMWORD PTR [rip+0xfffffffffffde7f6]        # 2001a0 <__unnamed_29-0x60>
  2219a9:	ff 
  2219aa:	c5 f1 ef c9          	vpxor  xmm1,xmm1,xmm1
  2219ae:	c5 e1 ef db          	vpxor  xmm3,xmm3,xmm3
  2219b2:	c5 e9 ef d2          	vpxor  xmm2,xmm2,xmm2
  2219b6:	4d 85 c0             	test   r8,r8
  2219b9:	74 60                	je     221a1b <openSelfDebugInfoLinux+0x2a8b>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  2219bb:	c4 e2 7d 32 6c 2a 0c 	vpmovzxbq ymm5,DWORD PTR [rdx+rbp*1+0xc]
  2219c2:	c5 dd 73 f4 03       	vpsllq ymm4,ymm4,0x3
  2219c7:	c5 dd d4 b4 24 40 05 	vpaddq ymm6,ymm4,YMMWORD PTR [rsp+0x540]
  2219ce:	00 00 
  2219d0:	c5 7e 6f 84 24 20 05 	vmovdqu ymm8,YMMWORD PTR [rsp+0x520]
  2219d7:	00 00 
  2219d9:	c4 c1 4d db f0       	vpand  ymm6,ymm6,ymm8
  2219de:	c4 e2 d5 47 ee       	vpsllvq ymm5,ymm5,ymm6
  2219e3:	c4 e2 7d 32 7c 2a 08 	vpmovzxbq ymm7,DWORD PTR [rdx+rbp*1+0x8]
  2219ea:	c5 d5 eb d2          	vpor   ymm2,ymm5,ymm2
  2219ee:	c4 c1 5d db e0       	vpand  ymm4,ymm4,ymm8
  2219f3:	c4 e2 c5 47 ec       	vpsllvq ymm5,ymm7,ymm4
  2219f8:	c5 d5 eb db          	vpor   ymm3,ymm5,ymm3
  2219fc:	c4 e2 7d 32 6c 2a 04 	vpmovzxbq ymm5,DWORD PTR [rdx+rbp*1+0x4]
  221a03:	c4 e2 d5 47 ee       	vpsllvq ymm5,ymm5,ymm6
  221a08:	c5 d5 eb c9          	vpor   ymm1,ymm5,ymm1
  221a0c:	c4 e2 7d 32 2c 2a    	vpmovzxbq ymm5,DWORD PTR [rdx+rbp*1]
  221a12:	c4 e2 d5 47 e4       	vpsllvq ymm4,ymm5,ymm4
  221a17:	c5 dd eb c0          	vpor   ymm0,ymm4,ymm0
  221a1b:	c5 f5 eb ca          	vpor   ymm1,ymm1,ymm2
  221a1f:	c5 fd eb c3          	vpor   ymm0,ymm0,ymm3
  221a23:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  221a27:	c4 e3 7d 39 c1 01    	vextracti128 xmm1,ymm0,0x1
  221a2d:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  221a31:	c5 f9 70 c8 4e       	vpshufd xmm1,xmm0,0x4e
  221a36:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  221a3a:	c4 e1 f9 7e c7       	vmovq  rdi,xmm0
  221a3f:	48 39 c1             	cmp    rcx,rax
            for (bytes) |b, index| {
  221a42:	74 29                	je     221a6d <openSelfDebugInfoLinux+0x2add>
  221a44:	48 29 c1             	sub    rcx,rax
  221a47:	48 01 c2             	add    rdx,rax
  221a4a:	48 c1 e0 03          	shl    rax,0x3
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  221a4e:	0f b6 2a             	movzx  ebp,BYTE PTR [rdx]
  221a51:	89 c6                	mov    esi,eax
  221a53:	40 80 e6 38          	and    sil,0x38
  221a57:	c4 e2 c9 f7 f5       	shlx   rsi,rbp,rsi
  221a5c:	48 09 f7             	or     rdi,rsi
            for (bytes) |b, index| {
  221a5f:	48 83 c0 08          	add    rax,0x8
  221a63:	48 83 c2 01          	add    rdx,0x1
  221a67:	48 83 c1 ff          	add    rcx,0xffffffffffffffff
  221a6b:	75 e1                	jne    221a4e <openSelfDebugInfoLinux+0x2abe>
                            break :b (low_pc + offset);
  221a6d:	4c 01 cf             	add    rdi,r9
                    break :x PcRange{
  221a70:	4c 89 8c 24 18 03 00 	mov    QWORD PTR [rsp+0x318],r9
  221a77:	00 
  221a78:	48 89 bc 24 20 03 00 	mov    QWORD PTR [rsp+0x320],rdi
  221a7f:	00 
  221a80:	c6 84 24 28 03 00 00 	mov    BYTE PTR [rsp+0x328],0x1
  221a87:	01 
        const pc_range = x: {
  221a88:	4c 89 e0             	mov    rax,r12
  221a8b:	e9 d8 fb ff ff       	jmp    221668 <openSelfDebugInfoLinux+0x26d8>
                list.first = node.next;
  221a90:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  221a94:	48 89 0d 85 f5 02 00 	mov    QWORD PTR [rip+0x2f585],rcx        # 251020 <emfile_promise_queue>
            if (node.next) |next_node| {
  221a9b:	48 85 c9             	test   rcx,rcx
  221a9e:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  221aa1:	48 8d 35 80 f5 02 00 	lea    rsi,[rip+0x2f580]        # 251028 <emfile_promise_queue+0x8>
  221aa8:	48 0f 45 f1          	cmovne rsi,rcx
  221aac:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  221aaf:	48 83 05 79 f5 02 00 	add    QWORD PTR [rip+0x2f579],0xffffffffffffffff        # 251030 <emfile_promise_queue+0x10>
  221ab6:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  221ab7:	74 1e                	je     221ad7 <openSelfDebugInfoLinux+0x2b47>
  221ab9:	48 83 3d 5f f5 02 00 	cmp    QWORD PTR [rip+0x2f55f],0x0        # 251020 <emfile_promise_queue>
  221ac0:	00 
  221ac1:	0f 84 0f 16 00 00    	je     2230d6 <openSelfDebugInfoLinux+0x4146>
  221ac7:	48 8b 0d 5a f5 02 00 	mov    rcx,QWORD PTR [rip+0x2f55a]        # 251028 <emfile_promise_queue+0x8>
  221ace:	48 85 c9             	test   rcx,rcx
  221ad1:	0f 84 ff 15 00 00    	je     2230d6 <openSelfDebugInfoLinux+0x4146>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  221ad7:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  221adb:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  221adf:	48 89 c1             	mov    rcx,rax
  221ae2:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  221ae6:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  221aec:	75 f1                	jne    221adf <openSelfDebugInfoLinux+0x2b4f>
  221aee:	a8 01                	test   al,0x1
  221af0:	75 02                	jne    221af4 <openSelfDebugInfoLinux+0x2b64>
  221af2:	ff 17                	call   QWORD PTR [rdi]
  221af4:	48 63 bc 24 70 01 00 	movsxd rdi,DWORD PTR [rsp+0x170]
  221afb:	00 
    return asm volatile ("syscall"
  221afc:	b8 03 00 00 00       	mov    eax,0x3
  221b01:	0f 05                	syscall 
            switch (err) {
  221b03:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  221b07:	74 f3                	je     221afc <openSelfDebugInfoLinux+0x2b6c>
            const first = list.first orelse return null;
  221b09:	48 8b 05 10 f5 02 00 	mov    rax,QWORD PTR [rip+0x2f510]        # 251020 <emfile_promise_queue>
  221b10:	48 85 c0             	test   rax,rax
  221b13:	74 7a                	je     221b8f <openSelfDebugInfoLinux+0x2bff>
            if (node.prev) |prev_node| {
  221b15:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  221b18:	48 85 c9             	test   rcx,rcx
  221b1b:	74 0e                	je     221b2b <openSelfDebugInfoLinux+0x2b9b>
                prev_node.next = node.next;
  221b1d:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  221b21:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  221b25:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  221b29:	eb 0b                	jmp    221b36 <openSelfDebugInfoLinux+0x2ba6>
                list.first = node.next;
  221b2b:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  221b2f:	48 89 0d ea f4 02 00 	mov    QWORD PTR [rip+0x2f4ea],rcx        # 251020 <emfile_promise_queue>
            if (node.next) |next_node| {
  221b36:	48 85 c9             	test   rcx,rcx
  221b39:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  221b3c:	48 8d 35 e5 f4 02 00 	lea    rsi,[rip+0x2f4e5]        # 251028 <emfile_promise_queue+0x8>
  221b43:	48 0f 45 f1          	cmovne rsi,rcx
  221b47:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  221b4a:	48 83 05 de f4 02 00 	add    QWORD PTR [rip+0x2f4de],0xffffffffffffffff        # 251030 <emfile_promise_queue+0x10>
  221b51:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  221b52:	74 1e                	je     221b72 <openSelfDebugInfoLinux+0x2be2>
  221b54:	48 83 3d c4 f4 02 00 	cmp    QWORD PTR [rip+0x2f4c4],0x0        # 251020 <emfile_promise_queue>
  221b5b:	00 
  221b5c:	0f 84 74 15 00 00    	je     2230d6 <openSelfDebugInfoLinux+0x4146>
  221b62:	48 8b 0d bf f4 02 00 	mov    rcx,QWORD PTR [rip+0x2f4bf]        # 251028 <emfile_promise_queue+0x8>
  221b69:	48 85 c9             	test   rcx,rcx
  221b6c:	0f 84 64 15 00 00    	je     2230d6 <openSelfDebugInfoLinux+0x4146>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  221b72:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  221b76:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  221b7a:	48 89 c1             	mov    rcx,rax
  221b7d:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  221b81:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  221b87:	75 f1                	jne    221b7a <openSelfDebugInfoLinux+0x2bea>
  221b89:	a8 01                	test   al,0x1
  221b8b:	75 02                	jne    221b8f <openSelfDebugInfoLinux+0x2bff>
  221b8d:	ff 17                	call   QWORD PTR [rdi]
    di.debug_line = (try di.elf.findSection(".debug_line")) orelse return error.MissingDebugInfo;
  221b8f:	0f b7 84 24 c0 03 00 	movzx  eax,WORD PTR [rsp+0x3c0]
  221b96:	00 
  221b97:	66 89 03             	mov    WORD PTR [rbx],ax
  221b9a:	c5 fc 10 84 24 e2 08 	vmovups ymm0,YMMWORD PTR [rsp+0x8e2]
  221ba1:	00 00 
  221ba3:	c5 fc 11 83 b0 00 00 	vmovups YMMWORD PTR [rbx+0xb0],ymm0
  221baa:	00 
  221bab:	c5 fc 10 84 24 d4 08 	vmovups ymm0,YMMWORD PTR [rsp+0x8d4]
  221bb2:	00 00 
  221bb4:	c5 fc 11 83 a2 00 00 	vmovups YMMWORD PTR [rbx+0xa2],ymm0
  221bbb:	00 
  221bbc:	c5 fc 10 84 24 b4 08 	vmovups ymm0,YMMWORD PTR [rsp+0x8b4]
  221bc3:	00 00 
  221bc5:	c5 fc 11 83 82 00 00 	vmovups YMMWORD PTR [rbx+0x82],ymm0
  221bcc:	00 
  221bcd:	c5 fc 10 84 24 34 08 	vmovups ymm0,YMMWORD PTR [rsp+0x834]
  221bd4:	00 00 
  221bd6:	c5 fc 10 8c 24 54 08 	vmovups ymm1,YMMWORD PTR [rsp+0x854]
  221bdd:	00 00 
  221bdf:	c5 fc 10 94 24 74 08 	vmovups ymm2,YMMWORD PTR [rsp+0x874]
  221be6:	00 00 
  221be8:	c5 fc 10 9c 24 94 08 	vmovups ymm3,YMMWORD PTR [rsp+0x894]
  221bef:	00 00 
  221bf1:	e9 b1 e0 ff ff       	jmp    21fca7 <openSelfDebugInfoLinux+0xd17>
                list.first = node.next;
  221bf6:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  221bfa:	48 89 0d 1f f4 02 00 	mov    QWORD PTR [rip+0x2f41f],rcx        # 251020 <emfile_promise_queue>
            if (node.next) |next_node| {
  221c01:	48 85 c9             	test   rcx,rcx
  221c04:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  221c07:	48 8d 35 1a f4 02 00 	lea    rsi,[rip+0x2f41a]        # 251028 <emfile_promise_queue+0x8>
  221c0e:	48 0f 45 f1          	cmovne rsi,rcx
  221c12:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  221c15:	48 83 05 13 f4 02 00 	add    QWORD PTR [rip+0x2f413],0xffffffffffffffff        # 251030 <emfile_promise_queue+0x10>
  221c1c:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  221c1d:	74 1e                	je     221c3d <openSelfDebugInfoLinux+0x2cad>
  221c1f:	48 83 3d f9 f3 02 00 	cmp    QWORD PTR [rip+0x2f3f9],0x0        # 251020 <emfile_promise_queue>
  221c26:	00 
  221c27:	0f 84 a9 14 00 00    	je     2230d6 <openSelfDebugInfoLinux+0x4146>
  221c2d:	48 8b 0d f4 f3 02 00 	mov    rcx,QWORD PTR [rip+0x2f3f4]        # 251028 <emfile_promise_queue+0x8>
  221c34:	48 85 c9             	test   rcx,rcx
  221c37:	0f 84 99 14 00 00    	je     2230d6 <openSelfDebugInfoLinux+0x4146>
  221c3d:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  221c41:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  221c45:	48 89 c1             	mov    rcx,rax
  221c48:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  221c4c:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  221c52:	75 f1                	jne    221c45 <openSelfDebugInfoLinux+0x2cb5>
  221c54:	a8 01                	test   al,0x1
  221c56:	75 02                	jne    221c5a <openSelfDebugInfoLinux+0x2cca>
  221c58:	ff 17                	call   QWORD PTR [rdi]
  221c5a:	48 63 bc 24 70 01 00 	movsxd rdi,DWORD PTR [rsp+0x170]
  221c61:	00 
  221c62:	b8 03 00 00 00       	mov    eax,0x3
  221c67:	0f 05                	syscall 
            switch (err) {
  221c69:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  221c6d:	74 f3                	je     221c62 <openSelfDebugInfoLinux+0x2cd2>
            const first = list.first orelse return null;
  221c6f:	48 8b 05 aa f3 02 00 	mov    rax,QWORD PTR [rip+0x2f3aa]        # 251020 <emfile_promise_queue>
  221c76:	48 85 c0             	test   rax,rax
  221c79:	0f 84 26 e4 ff ff    	je     2200a5 <openSelfDebugInfoLinux+0x1115>
            if (node.prev) |prev_node| {
  221c7f:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  221c82:	48 85 c9             	test   rcx,rcx
  221c85:	74 0e                	je     221c95 <openSelfDebugInfoLinux+0x2d05>
                prev_node.next = node.next;
  221c87:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  221c8b:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  221c8f:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  221c93:	eb 0b                	jmp    221ca0 <openSelfDebugInfoLinux+0x2d10>
                list.first = node.next;
  221c95:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  221c99:	48 89 0d 80 f3 02 00 	mov    QWORD PTR [rip+0x2f380],rcx        # 251020 <emfile_promise_queue>
            if (node.next) |next_node| {
  221ca0:	48 85 c9             	test   rcx,rcx
  221ca3:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  221ca6:	48 8d 35 7b f3 02 00 	lea    rsi,[rip+0x2f37b]        # 251028 <emfile_promise_queue+0x8>
  221cad:	48 0f 45 f1          	cmovne rsi,rcx
  221cb1:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  221cb4:	48 83 05 74 f3 02 00 	add    QWORD PTR [rip+0x2f374],0xffffffffffffffff        # 251030 <emfile_promise_queue+0x10>
  221cbb:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  221cbc:	74 1e                	je     221cdc <openSelfDebugInfoLinux+0x2d4c>
  221cbe:	48 83 3d 5a f3 02 00 	cmp    QWORD PTR [rip+0x2f35a],0x0        # 251020 <emfile_promise_queue>
  221cc5:	00 
  221cc6:	0f 84 0a 14 00 00    	je     2230d6 <openSelfDebugInfoLinux+0x4146>
  221ccc:	48 8b 0d 55 f3 02 00 	mov    rcx,QWORD PTR [rip+0x2f355]        # 251028 <emfile_promise_queue+0x8>
  221cd3:	48 85 c9             	test   rcx,rcx
  221cd6:	0f 84 fa 13 00 00    	je     2230d6 <openSelfDebugInfoLinux+0x4146>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  221cdc:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  221ce0:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  221ce4:	48 89 c1             	mov    rcx,rax
  221ce7:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  221ceb:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  221cf1:	75 f1                	jne    221ce4 <openSelfDebugInfoLinux+0x2d54>
  221cf3:	e9 a7 e3 ff ff       	jmp    22009f <openSelfDebugInfoLinux+0x110f>
  221cf8:	31 ff                	xor    edi,edi
    try scanAllCompileUnits(&di);
  221cfa:	66 85 ff             	test   di,di
  221cfd:	0f 85 c5 04 00 00    	jne    2221c8 <openSelfDebugInfoLinux+0x3238>
    return di;
  221d03:	48 8b 84 24 30 02 00 	mov    rax,QWORD PTR [rsp+0x230]
  221d0a:	00 
  221d0b:	48 89 84 24 30 06 00 	mov    QWORD PTR [rsp+0x630],rax
  221d12:	00 
  221d13:	c5 fc 10 84 24 10 02 	vmovups ymm0,YMMWORD PTR [rsp+0x210]
  221d1a:	00 00 
  221d1c:	c5 fc 11 84 24 10 06 	vmovups YMMWORD PTR [rsp+0x610],ymm0
  221d23:	00 00 
  221d25:	c5 fc 10 84 24 f0 01 	vmovups ymm0,YMMWORD PTR [rsp+0x1f0]
  221d2c:	00 00 
  221d2e:	c5 fc 11 84 24 f0 05 	vmovups YMMWORD PTR [rsp+0x5f0],ymm0
  221d35:	00 00 
  221d37:	c5 fc 10 84 24 70 01 	vmovups ymm0,YMMWORD PTR [rsp+0x170]
  221d3e:	00 00 
  221d40:	c5 fc 10 8c 24 90 01 	vmovups ymm1,YMMWORD PTR [rsp+0x190]
  221d47:	00 00 
  221d49:	c5 fc 10 94 24 b0 01 	vmovups ymm2,YMMWORD PTR [rsp+0x1b0]
  221d50:	00 00 
  221d52:	c5 fc 10 9c 24 d0 01 	vmovups ymm3,YMMWORD PTR [rsp+0x1d0]
  221d59:	00 00 
  221d5b:	c5 fc 11 9c 24 d0 05 	vmovups YMMWORD PTR [rsp+0x5d0],ymm3
  221d62:	00 00 
  221d64:	c5 fc 11 94 24 b0 05 	vmovups YMMWORD PTR [rsp+0x5b0],ymm2
  221d6b:	00 00 
  221d6d:	c5 fc 11 8c 24 90 05 	vmovups YMMWORD PTR [rsp+0x590],ymm1
  221d74:	00 00 
  221d76:	c5 fc 11 84 24 70 05 	vmovups YMMWORD PTR [rsp+0x570],ymm0
  221d7d:	00 00 
  221d7f:	66 c7 03 00 00       	mov    WORD PTR [rbx],0x0
  221d84:	c5 fc 10 84 24 18 06 	vmovups ymm0,YMMWORD PTR [rsp+0x618]
  221d8b:	00 00 
  221d8d:	c5 fc 11 83 b0 00 00 	vmovups YMMWORD PTR [rbx+0xb0],ymm0
  221d94:	00 
  221d95:	c5 fc 10 84 24 0a 06 	vmovups ymm0,YMMWORD PTR [rsp+0x60a]
  221d9c:	00 00 
  221d9e:	c5 fc 11 83 a2 00 00 	vmovups YMMWORD PTR [rbx+0xa2],ymm0
  221da5:	00 
  221da6:	c5 fc 10 84 24 ea 05 	vmovups ymm0,YMMWORD PTR [rsp+0x5ea]
  221dad:	00 00 
  221daf:	c5 fc 11 83 82 00 00 	vmovups YMMWORD PTR [rbx+0x82],ymm0
  221db6:	00 
  221db7:	c5 fc 10 84 24 6a 05 	vmovups ymm0,YMMWORD PTR [rsp+0x56a]
  221dbe:	00 00 
  221dc0:	c5 fc 10 8c 24 8a 05 	vmovups ymm1,YMMWORD PTR [rsp+0x58a]
  221dc7:	00 00 
  221dc9:	c5 fc 10 94 24 aa 05 	vmovups ymm2,YMMWORD PTR [rsp+0x5aa]
  221dd0:	00 00 
  221dd2:	c5 fc 10 9c 24 ca 05 	vmovups ymm3,YMMWORD PTR [rsp+0x5ca]
  221dd9:	00 00 
  221ddb:	e9 c7 de ff ff       	jmp    21fca7 <openSelfDebugInfoLinux+0xd17>
                list.first = node.next;
  221de0:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  221de4:	48 89 0d 35 f2 02 00 	mov    QWORD PTR [rip+0x2f235],rcx        # 251020 <emfile_promise_queue>
            if (node.next) |next_node| {
  221deb:	48 85 c9             	test   rcx,rcx
  221dee:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  221df1:	48 8d 35 30 f2 02 00 	lea    rsi,[rip+0x2f230]        # 251028 <emfile_promise_queue+0x8>
  221df8:	48 0f 45 f1          	cmovne rsi,rcx
  221dfc:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  221dff:	48 83 05 29 f2 02 00 	add    QWORD PTR [rip+0x2f229],0xffffffffffffffff        # 251030 <emfile_promise_queue+0x10>
  221e06:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  221e07:	74 1e                	je     221e27 <openSelfDebugInfoLinux+0x2e97>
  221e09:	48 83 3d 0f f2 02 00 	cmp    QWORD PTR [rip+0x2f20f],0x0        # 251020 <emfile_promise_queue>
  221e10:	00 
  221e11:	0f 84 bf 12 00 00    	je     2230d6 <openSelfDebugInfoLinux+0x4146>
  221e17:	48 8b 0d 0a f2 02 00 	mov    rcx,QWORD PTR [rip+0x2f20a]        # 251028 <emfile_promise_queue+0x8>
  221e1e:	48 85 c9             	test   rcx,rcx
  221e21:	0f 84 af 12 00 00    	je     2230d6 <openSelfDebugInfoLinux+0x4146>
  221e27:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  221e2b:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  221e2f:	48 89 c1             	mov    rcx,rax
  221e32:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  221e36:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  221e3c:	75 f1                	jne    221e2f <openSelfDebugInfoLinux+0x2e9f>
  221e3e:	a8 01                	test   al,0x1
  221e40:	75 02                	jne    221e44 <openSelfDebugInfoLinux+0x2eb4>
  221e42:	ff 17                	call   QWORD PTR [rdi]
  221e44:	48 63 bc 24 70 01 00 	movsxd rdi,DWORD PTR [rsp+0x170]
  221e4b:	00 
  221e4c:	b8 03 00 00 00       	mov    eax,0x3
  221e51:	0f 05                	syscall 
            switch (err) {
  221e53:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  221e57:	74 f3                	je     221e4c <openSelfDebugInfoLinux+0x2ebc>
            const first = list.first orelse return null;
  221e59:	48 8b 05 c0 f1 02 00 	mov    rax,QWORD PTR [rip+0x2f1c0]        # 251020 <emfile_promise_queue>
  221e60:	48 85 c0             	test   rax,rax
  221e63:	74 7a                	je     221edf <openSelfDebugInfoLinux+0x2f4f>
            if (node.prev) |prev_node| {
  221e65:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  221e68:	48 85 c9             	test   rcx,rcx
  221e6b:	74 0e                	je     221e7b <openSelfDebugInfoLinux+0x2eeb>
                prev_node.next = node.next;
  221e6d:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  221e71:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  221e75:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  221e79:	eb 0b                	jmp    221e86 <openSelfDebugInfoLinux+0x2ef6>
                list.first = node.next;
  221e7b:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  221e7f:	48 89 0d 9a f1 02 00 	mov    QWORD PTR [rip+0x2f19a],rcx        # 251020 <emfile_promise_queue>
            if (node.next) |next_node| {
  221e86:	48 85 c9             	test   rcx,rcx
  221e89:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  221e8c:	48 8d 35 95 f1 02 00 	lea    rsi,[rip+0x2f195]        # 251028 <emfile_promise_queue+0x8>
  221e93:	48 0f 45 f1          	cmovne rsi,rcx
  221e97:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  221e9a:	48 83 05 8e f1 02 00 	add    QWORD PTR [rip+0x2f18e],0xffffffffffffffff        # 251030 <emfile_promise_queue+0x10>
  221ea1:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  221ea2:	74 1e                	je     221ec2 <openSelfDebugInfoLinux+0x2f32>
  221ea4:	48 83 3d 74 f1 02 00 	cmp    QWORD PTR [rip+0x2f174],0x0        # 251020 <emfile_promise_queue>
  221eab:	00 
  221eac:	0f 84 24 12 00 00    	je     2230d6 <openSelfDebugInfoLinux+0x4146>
  221eb2:	48 8b 0d 6f f1 02 00 	mov    rcx,QWORD PTR [rip+0x2f16f]        # 251028 <emfile_promise_queue+0x8>
  221eb9:	48 85 c9             	test   rcx,rcx
  221ebc:	0f 84 14 12 00 00    	je     2230d6 <openSelfDebugInfoLinux+0x4146>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  221ec2:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  221ec6:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  221eca:	48 89 c1             	mov    rcx,rax
  221ecd:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  221ed1:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  221ed7:	75 f1                	jne    221eca <openSelfDebugInfoLinux+0x2f3a>
  221ed9:	a8 01                	test   al,0x1
  221edb:	75 02                	jne    221edf <openSelfDebugInfoLinux+0x2f4f>
  221edd:	ff 17                	call   QWORD PTR [rdi]
    di.debug_ranges = (try di.elf.findSection(".debug_ranges"));
  221edf:	0f b7 84 24 b0 03 00 	movzx  eax,WORD PTR [rsp+0x3b0]
  221ee6:	00 
  221ee7:	66 89 03             	mov    WORD PTR [rbx],ax
  221eea:	c5 fc 10 84 24 14 08 	vmovups ymm0,YMMWORD PTR [rsp+0x814]
  221ef1:	00 00 
  221ef3:	c5 fc 11 83 b0 00 00 	vmovups YMMWORD PTR [rbx+0xb0],ymm0
  221efa:	00 
  221efb:	c5 fc 10 84 24 06 08 	vmovups ymm0,YMMWORD PTR [rsp+0x806]
  221f02:	00 00 
  221f04:	c5 fc 11 83 a2 00 00 	vmovups YMMWORD PTR [rbx+0xa2],ymm0
  221f0b:	00 
  221f0c:	c5 fc 10 84 24 e6 07 	vmovups ymm0,YMMWORD PTR [rsp+0x7e6]
  221f13:	00 00 
  221f15:	c5 fc 11 83 82 00 00 	vmovups YMMWORD PTR [rbx+0x82],ymm0
  221f1c:	00 
  221f1d:	c5 fc 10 84 24 66 07 	vmovups ymm0,YMMWORD PTR [rsp+0x766]
  221f24:	00 00 
  221f26:	c5 fc 10 8c 24 86 07 	vmovups ymm1,YMMWORD PTR [rsp+0x786]
  221f2d:	00 00 
  221f2f:	c5 fc 10 94 24 a6 07 	vmovups ymm2,YMMWORD PTR [rsp+0x7a6]
  221f36:	00 00 
  221f38:	c5 fc 10 9c 24 c6 07 	vmovups ymm3,YMMWORD PTR [rsp+0x7c6]
  221f3f:	00 00 
  221f41:	e9 61 dd ff ff       	jmp    21fca7 <openSelfDebugInfoLinux+0xd17>
                list.first = node.next;
  221f46:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  221f4a:	48 89 0d cf f0 02 00 	mov    QWORD PTR [rip+0x2f0cf],rcx        # 251020 <emfile_promise_queue>
            if (node.next) |next_node| {
  221f51:	48 85 c9             	test   rcx,rcx
  221f54:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  221f57:	48 8d 35 ca f0 02 00 	lea    rsi,[rip+0x2f0ca]        # 251028 <emfile_promise_queue+0x8>
  221f5e:	48 0f 45 f1          	cmovne rsi,rcx
  221f62:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  221f65:	48 83 05 c3 f0 02 00 	add    QWORD PTR [rip+0x2f0c3],0xffffffffffffffff        # 251030 <emfile_promise_queue+0x10>
  221f6c:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  221f6d:	74 1e                	je     221f8d <openSelfDebugInfoLinux+0x2ffd>
  221f6f:	48 83 3d a9 f0 02 00 	cmp    QWORD PTR [rip+0x2f0a9],0x0        # 251020 <emfile_promise_queue>
  221f76:	00 
  221f77:	0f 84 59 11 00 00    	je     2230d6 <openSelfDebugInfoLinux+0x4146>
  221f7d:	48 8b 0d a4 f0 02 00 	mov    rcx,QWORD PTR [rip+0x2f0a4]        # 251028 <emfile_promise_queue+0x8>
  221f84:	48 85 c9             	test   rcx,rcx
  221f87:	0f 84 49 11 00 00    	je     2230d6 <openSelfDebugInfoLinux+0x4146>
  221f8d:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  221f91:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  221f95:	48 89 c1             	mov    rcx,rax
  221f98:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  221f9c:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  221fa2:	75 f1                	jne    221f95 <openSelfDebugInfoLinux+0x3005>
  221fa4:	a8 01                	test   al,0x1
  221fa6:	75 02                	jne    221faa <openSelfDebugInfoLinux+0x301a>
  221fa8:	ff 17                	call   QWORD PTR [rdi]
  221faa:	48 63 bc 24 70 01 00 	movsxd rdi,DWORD PTR [rsp+0x170]
  221fb1:	00 
  221fb2:	b8 03 00 00 00       	mov    eax,0x3
  221fb7:	0f 05                	syscall 
            switch (err) {
  221fb9:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  221fbd:	74 f3                	je     221fb2 <openSelfDebugInfoLinux+0x3022>
            const first = list.first orelse return null;
  221fbf:	48 8b 05 5a f0 02 00 	mov    rax,QWORD PTR [rip+0x2f05a]        # 251020 <emfile_promise_queue>
  221fc6:	48 85 c0             	test   rax,rax
  221fc9:	0f 84 d6 e0 ff ff    	je     2200a5 <openSelfDebugInfoLinux+0x1115>
            if (node.prev) |prev_node| {
  221fcf:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  221fd2:	48 85 c9             	test   rcx,rcx
  221fd5:	74 0e                	je     221fe5 <openSelfDebugInfoLinux+0x3055>
                prev_node.next = node.next;
  221fd7:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  221fdb:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  221fdf:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  221fe3:	eb 0b                	jmp    221ff0 <openSelfDebugInfoLinux+0x3060>
                list.first = node.next;
  221fe5:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  221fe9:	48 89 0d 30 f0 02 00 	mov    QWORD PTR [rip+0x2f030],rcx        # 251020 <emfile_promise_queue>
            if (node.next) |next_node| {
  221ff0:	48 85 c9             	test   rcx,rcx
  221ff3:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  221ff6:	48 8d 35 2b f0 02 00 	lea    rsi,[rip+0x2f02b]        # 251028 <emfile_promise_queue+0x8>
  221ffd:	48 0f 45 f1          	cmovne rsi,rcx
  222001:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  222004:	48 83 05 24 f0 02 00 	add    QWORD PTR [rip+0x2f024],0xffffffffffffffff        # 251030 <emfile_promise_queue+0x10>
  22200b:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  22200c:	74 1e                	je     22202c <openSelfDebugInfoLinux+0x309c>
  22200e:	48 83 3d 0a f0 02 00 	cmp    QWORD PTR [rip+0x2f00a],0x0        # 251020 <emfile_promise_queue>
  222015:	00 
  222016:	0f 84 ba 10 00 00    	je     2230d6 <openSelfDebugInfoLinux+0x4146>
  22201c:	48 8b 0d 05 f0 02 00 	mov    rcx,QWORD PTR [rip+0x2f005]        # 251028 <emfile_promise_queue+0x8>
  222023:	48 85 c9             	test   rcx,rcx
  222026:	0f 84 aa 10 00 00    	je     2230d6 <openSelfDebugInfoLinux+0x4146>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  22202c:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  222030:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  222034:	48 89 c1             	mov    rcx,rax
  222037:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  22203b:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  222041:	75 f1                	jne    222034 <openSelfDebugInfoLinux+0x30a4>
  222043:	e9 57 e0 ff ff       	jmp    22009f <openSelfDebugInfoLinux+0x110f>
  222048:	66 b9 25 00          	mov    cx,0x25
  22204c:	eb 04                	jmp    222052 <openSelfDebugInfoLinux+0x30c2>
  22204e:	66 b9 29 00          	mov    cx,0x29
        const abbrev_code = try readULeb128(in_stream);
  222052:	48 8b 84 24 de 00 00 	mov    rax,QWORD PTR [rsp+0xde]
  222059:	00 
  22205a:	48 89 84 24 8e 02 00 	mov    QWORD PTR [rsp+0x28e],rax
  222061:	00 
  222062:	c5 fe 6f 84 24 c0 00 	vmovdqu ymm0,YMMWORD PTR [rsp+0xc0]
  222069:	00 00 
  22206b:	c5 fe 7f 84 24 70 02 	vmovdqu YMMWORD PTR [rsp+0x270],ymm0
  222072:	00 00 
  222074:	89 cf                	mov    edi,ecx
    try scanAllCompileUnits(&di);
  222076:	66 85 ff             	test   di,di
  222079:	0f 85 49 01 00 00    	jne    2221c8 <openSelfDebugInfoLinux+0x3238>
  22207f:	e9 7f fc ff ff       	jmp    221d03 <openSelfDebugInfoLinux+0x2d73>
  222084:	66 b8 25 00          	mov    ax,0x25
  222088:	89 c7                	mov    edi,eax
  22208a:	66 85 ff             	test   di,di
  22208d:	0f 85 35 01 00 00    	jne    2221c8 <openSelfDebugInfoLinux+0x3238>
  222093:	e9 6b fc ff ff       	jmp    221d03 <openSelfDebugInfoLinux+0x2d73>
  222098:	66 b9 25 00          	mov    cx,0x25
  22209c:	89 cf                	mov    edi,ecx
  22209e:	eb 04                	jmp    2220a4 <openSelfDebugInfoLinux+0x3114>
  2220a0:	66 bf 29 00          	mov    di,0x29
    const abbrev_code = try readULeb128(in_stream);
  2220a4:	c5 fe 6f 84 24 c0 00 	vmovdqu ymm0,YMMWORD PTR [rsp+0xc0]
  2220ab:	00 00 
  2220ad:	c5 fe 6f 8c 24 d6 00 	vmovdqu ymm1,YMMWORD PTR [rsp+0xd6]
  2220b4:	00 00 
  2220b6:	c5 fe 7f 8c 24 76 03 	vmovdqu YMMWORD PTR [rsp+0x376],ymm1
  2220bd:	00 00 
  2220bf:	c5 fe 7f 84 24 60 03 	vmovdqu YMMWORD PTR [rsp+0x360],ymm0
  2220c6:	00 00 
    try scanAllCompileUnits(&di);
  2220c8:	66 85 ff             	test   di,di
  2220cb:	0f 85 f7 00 00 00    	jne    2221c8 <openSelfDebugInfoLinux+0x3238>
  2220d1:	e9 2d fc ff ff       	jmp    221d03 <openSelfDebugInfoLinux+0x2d73>
  2220d6:	66 bf 04 00          	mov    di,0x4
  2220da:	66 85 ff             	test   di,di
  2220dd:	0f 85 e5 00 00 00    	jne    2221c8 <openSelfDebugInfoLinux+0x3238>
  2220e3:	e9 1b fc ff ff       	jmp    221d03 <openSelfDebugInfoLinux+0x2d73>
  2220e8:	66 bf 29 00          	mov    di,0x29
  2220ec:	66 85 ff             	test   di,di
  2220ef:	0f 85 d3 00 00 00    	jne    2221c8 <openSelfDebugInfoLinux+0x3238>
  2220f5:	e9 09 fc ff ff       	jmp    221d03 <openSelfDebugInfoLinux+0x2d73>
  2220fa:	48 8d 41 ea          	lea    rax,[rcx-0x16]
  2220fe:	48 83 f8 35          	cmp    rax,0x35
  222102:	77 14                	ja     222118 <openSelfDebugInfoLinux+0x3188>
  222104:	48 ba 81 00 00 00 00 	movabs rdx,0x20000000000081
  22210b:	00 20 00 
  22210e:	48 0f a3 c2          	bt     rdx,rax
  222112:	0f 82 9d 00 00 00    	jb     2221b5 <openSelfDebugInfoLinux+0x3225>
  222118:	66 bf 03 00          	mov    di,0x3
  22211c:	48 83 f9 06          	cmp    rcx,0x6
  222120:	0f 84 8f 00 00 00    	je     2221b5 <openSelfDebugInfoLinux+0x3225>
  222126:	e9 94 00 00 00       	jmp    2221bf <openSelfDebugInfoLinux+0x322f>
    const table_entry = getAbbrevTableEntry(abbrev_table, abbrev_code) orelse return error.InvalidDebugInfo;
  22212b:	c5 fc 10 05 b5 61 fe 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffe61b5]        # 2082e8 <__unnamed_49+0x18>
  222132:	ff 
  222133:	c5 fc 11 84 24 76 03 	vmovups YMMWORD PTR [rsp+0x376],ymm0
  22213a:	00 00 
  22213c:	c5 fe 6f 05 8e 61 fe 	vmovdqu ymm0,YMMWORD PTR [rip+0xfffffffffffe618e]        # 2082d2 <__unnamed_49+0x2>
  222143:	ff 
  222144:	c5 fe 7f 84 24 60 03 	vmovdqu YMMWORD PTR [rsp+0x360],ymm0
  22214b:	00 00 
  22214d:	66 bf 29 00          	mov    di,0x29
    try scanAllCompileUnits(&di);
  222151:	66 85 ff             	test   di,di
  222154:	75 72                	jne    2221c8 <openSelfDebugInfoLinux+0x3238>
  222156:	e9 a8 fb ff ff       	jmp    221d03 <openSelfDebugInfoLinux+0x2d73>
  22215b:	66 b9 25 00          	mov    cx,0x25
  22215f:	eb 04                	jmp    222165 <openSelfDebugInfoLinux+0x31d5>
  222161:	66 b9 29 00          	mov    cx,0x29
            .tag_id = try readULeb128(in_stream),
  222165:	48 8b 84 24 ce 04 00 	mov    rax,QWORD PTR [rsp+0x4ce]
  22216c:	00 
  22216d:	48 89 84 24 8e 02 00 	mov    QWORD PTR [rsp+0x28e],rax
  222174:	00 
  222175:	c5 fc 10 84 24 b0 04 	vmovups ymm0,YMMWORD PTR [rsp+0x4b0]
  22217c:	00 00 
  22217e:	e9 e8 fe ff ff       	jmp    22206b <openSelfDebugInfoLinux+0x30db>
  222183:	48 8d 4e ea          	lea    rcx,[rsi-0x16]
  222187:	48 83 f9 35          	cmp    rcx,0x35
  22218b:	77 14                	ja     2221a1 <openSelfDebugInfoLinux+0x3211>
  22218d:	48 ba 81 00 00 00 00 	movabs rdx,0x20000000000081
  222194:	00 20 00 
  222197:	48 0f a3 ca          	bt     rdx,rcx
  22219b:	0f 82 3c 02 00 00    	jb     2223dd <openSelfDebugInfoLinux+0x344d>
  2221a1:	66 c7 84 24 5e 01 00 	mov    WORD PTR [rsp+0x15e],0x3
  2221a8:	00 03 00 
                if (err > 0) {
  2221ab:	48 83 fe 06          	cmp    rsi,0x6
  2221af:	66 bf 27 00          	mov    di,0x27
  2221b3:	74 0a                	je     2221bf <openSelfDebugInfoLinux+0x322f>
  2221b5:	0f b7 84 24 5e 01 00 	movzx  eax,WORD PTR [rsp+0x15e]
  2221bc:	00 
  2221bd:	89 c7                	mov    edi,eax
    try scanAllCompileUnits(&di);
  2221bf:	66 85 ff             	test   di,di
  2221c2:	0f 84 3b fb ff ff    	je     221d03 <openSelfDebugInfoLinux+0x2d73>
  2221c8:	89 fd                	mov    ebp,edi
        const bytes = @sliceToBytes(memory);
  2221ca:	48 8b 84 24 b8 01 00 	mov    rax,QWORD PTR [rsp+0x1b8]
  2221d1:	00 
  2221d2:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  2221d6:	74 31                	je     222209 <openSelfDebugInfoLinux+0x3279>
  2221d8:	48 8b bc 24 c0 01 00 	mov    rdi,QWORD PTR [rsp+0x1c0]
  2221df:	00 
        const bytes = @sliceToBytes(memory);
  2221e0:	48 8b 8c 24 b0 01 00 	mov    rcx,QWORD PTR [rsp+0x1b0]
  2221e7:	00 
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  2221e8:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  2221ec:	48 89 8c 24 c0 00 00 	mov    QWORD PTR [rsp+0xc0],rcx
  2221f3:	00 
  2221f4:	48 89 84 24 c8 00 00 	mov    QWORD PTR [rsp+0xc8],rax
  2221fb:	00 
  2221fc:	48 8d b4 24 c0 00 00 	lea    rsi,[rsp+0xc0]
  222203:	00 
  222204:	c5 f8 77             	vzeroupper 
  222207:	ff d2                	call   rdx
  222209:	80 bc 24 80 01 00 00 	cmp    BYTE PTR [rsp+0x180],0x1
  222210:	01 
  222211:	0f 85 a1 00 00 00    	jne    2222b8 <openSelfDebugInfoLinux+0x3328>
  222217:	48 8b 84 24 78 01 00 	mov    rax,QWORD PTR [rsp+0x178]
  22221e:	00 
  22221f:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  222222:	b8 03 00 00 00       	mov    eax,0x3
  222227:	0f 05                	syscall 
            switch (err) {
  222229:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  22222d:	74 f3                	je     222222 <openSelfDebugInfoLinux+0x3292>
            const first = list.first orelse return null;
  22222f:	48 8b 05 ea ed 02 00 	mov    rax,QWORD PTR [rip+0x2edea]        # 251020 <emfile_promise_queue>
  222236:	48 85 c0             	test   rax,rax
  222239:	74 7d                	je     2222b8 <openSelfDebugInfoLinux+0x3328>
            if (node.prev) |prev_node| {
  22223b:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  22223e:	48 85 c9             	test   rcx,rcx
  222241:	74 0e                	je     222251 <openSelfDebugInfoLinux+0x32c1>
                prev_node.next = node.next;
  222243:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  222247:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  22224b:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  22224f:	eb 0b                	jmp    22225c <openSelfDebugInfoLinux+0x32cc>
                list.first = node.next;
  222251:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  222255:	48 89 0d c4 ed 02 00 	mov    QWORD PTR [rip+0x2edc4],rcx        # 251020 <emfile_promise_queue>
            if (node.next) |next_node| {
  22225c:	48 85 c9             	test   rcx,rcx
  22225f:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  222262:	48 8d 35 bf ed 02 00 	lea    rsi,[rip+0x2edbf]        # 251028 <emfile_promise_queue+0x8>
  222269:	48 0f 45 f1          	cmovne rsi,rcx
  22226d:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  222270:	48 83 05 b8 ed 02 00 	add    QWORD PTR [rip+0x2edb8],0xffffffffffffffff        # 251030 <emfile_promise_queue+0x10>
  222277:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  222278:	74 1e                	je     222298 <openSelfDebugInfoLinux+0x3308>
  22227a:	48 83 3d 9e ed 02 00 	cmp    QWORD PTR [rip+0x2ed9e],0x0        # 251020 <emfile_promise_queue>
  222281:	00 
  222282:	0f 84 4e 0e 00 00    	je     2230d6 <openSelfDebugInfoLinux+0x4146>
  222288:	48 8b 0d 99 ed 02 00 	mov    rcx,QWORD PTR [rip+0x2ed99]        # 251028 <emfile_promise_queue+0x8>
  22228f:	48 85 c9             	test   rcx,rcx
  222292:	0f 84 3e 0e 00 00    	je     2230d6 <openSelfDebugInfoLinux+0x4146>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  222298:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  22229c:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  2222a0:	48 89 c1             	mov    rcx,rax
  2222a3:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  2222a7:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  2222ad:	75 f1                	jne    2222a0 <openSelfDebugInfoLinux+0x3310>
  2222af:	a8 01                	test   al,0x1
  2222b1:	75 05                	jne    2222b8 <openSelfDebugInfoLinux+0x3328>
  2222b3:	c5 f8 77             	vzeroupper 
  2222b6:	ff 17                	call   QWORD PTR [rdi]
  2222b8:	48 63 bc 24 70 01 00 	movsxd rdi,DWORD PTR [rsp+0x170]
  2222bf:	00 
  2222c0:	b8 03 00 00 00       	mov    eax,0x3
  2222c5:	0f 05                	syscall 
            switch (err) {
  2222c7:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  2222cb:	74 f3                	je     2222c0 <openSelfDebugInfoLinux+0x3330>
            const first = list.first orelse return null;
  2222cd:	48 8b 05 4c ed 02 00 	mov    rax,QWORD PTR [rip+0x2ed4c]        # 251020 <emfile_promise_queue>
  2222d4:	48 85 c0             	test   rax,rax
  2222d7:	74 7d                	je     222356 <openSelfDebugInfoLinux+0x33c6>
            if (node.prev) |prev_node| {
  2222d9:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  2222dc:	48 85 c9             	test   rcx,rcx
  2222df:	74 0e                	je     2222ef <openSelfDebugInfoLinux+0x335f>
                prev_node.next = node.next;
  2222e1:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  2222e5:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  2222e9:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  2222ed:	eb 0b                	jmp    2222fa <openSelfDebugInfoLinux+0x336a>
                list.first = node.next;
  2222ef:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  2222f3:	48 89 0d 26 ed 02 00 	mov    QWORD PTR [rip+0x2ed26],rcx        # 251020 <emfile_promise_queue>
            if (node.next) |next_node| {
  2222fa:	48 85 c9             	test   rcx,rcx
  2222fd:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  222300:	48 8d 35 21 ed 02 00 	lea    rsi,[rip+0x2ed21]        # 251028 <emfile_promise_queue+0x8>
  222307:	48 0f 45 f1          	cmovne rsi,rcx
  22230b:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  22230e:	48 83 05 1a ed 02 00 	add    QWORD PTR [rip+0x2ed1a],0xffffffffffffffff        # 251030 <emfile_promise_queue+0x10>
  222315:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  222316:	74 1e                	je     222336 <openSelfDebugInfoLinux+0x33a6>
  222318:	48 83 3d 00 ed 02 00 	cmp    QWORD PTR [rip+0x2ed00],0x0        # 251020 <emfile_promise_queue>
  22231f:	00 
  222320:	0f 84 b0 0d 00 00    	je     2230d6 <openSelfDebugInfoLinux+0x4146>
  222326:	48 8b 0d fb ec 02 00 	mov    rcx,QWORD PTR [rip+0x2ecfb]        # 251028 <emfile_promise_queue+0x8>
  22232d:	48 85 c9             	test   rcx,rcx
  222330:	0f 84 a0 0d 00 00    	je     2230d6 <openSelfDebugInfoLinux+0x4146>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  222336:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  22233a:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  22233e:	48 89 c1             	mov    rcx,rax
  222341:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  222345:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  22234b:	75 f1                	jne    22233e <openSelfDebugInfoLinux+0x33ae>
  22234d:	a8 01                	test   al,0x1
  22234f:	75 05                	jne    222356 <openSelfDebugInfoLinux+0x33c6>
  222351:	c5 f8 77             	vzeroupper 
  222354:	ff 17                	call   QWORD PTR [rdi]
  222356:	66 89 2b             	mov    WORD PTR [rbx],bp
  222359:	c5 fc 10 84 24 46 07 	vmovups ymm0,YMMWORD PTR [rsp+0x746]
  222360:	00 00 
  222362:	c5 fc 11 83 b0 00 00 	vmovups YMMWORD PTR [rbx+0xb0],ymm0
  222369:	00 
  22236a:	c5 fc 10 84 24 38 07 	vmovups ymm0,YMMWORD PTR [rsp+0x738]
  222371:	00 00 
  222373:	c5 fc 11 83 a2 00 00 	vmovups YMMWORD PTR [rbx+0xa2],ymm0
  22237a:	00 
  22237b:	c5 fc 10 84 24 18 07 	vmovups ymm0,YMMWORD PTR [rsp+0x718]
  222382:	00 00 
  222384:	c5 fc 11 83 82 00 00 	vmovups YMMWORD PTR [rbx+0x82],ymm0
  22238b:	00 
  22238c:	c5 fc 10 84 24 98 06 	vmovups ymm0,YMMWORD PTR [rsp+0x698]
  222393:	00 00 
  222395:	c5 fc 10 8c 24 b8 06 	vmovups ymm1,YMMWORD PTR [rsp+0x6b8]
  22239c:	00 00 
  22239e:	c5 fc 10 94 24 d8 06 	vmovups ymm2,YMMWORD PTR [rsp+0x6d8]
  2223a5:	00 00 
  2223a7:	c5 fc 10 9c 24 f8 06 	vmovups ymm3,YMMWORD PTR [rsp+0x6f8]
  2223ae:	00 00 
  2223b0:	e9 f2 d8 ff ff       	jmp    21fca7 <openSelfDebugInfoLinux+0xd17>
  2223b5:	48 8d 41 ea          	lea    rax,[rcx-0x16]
  2223b9:	48 83 f8 35          	cmp    rax,0x35
  2223bd:	77 10                	ja     2223cf <openSelfDebugInfoLinux+0x343f>
  2223bf:	48 ba 81 00 00 00 00 	movabs rdx,0x20000000000081
  2223c6:	00 20 00 
  2223c9:	48 0f a3 c2          	bt     rdx,rax
  2223cd:	72 0e                	jb     2223dd <openSelfDebugInfoLinux+0x344d>
  2223cf:	66 bf 03 00          	mov    di,0x3
                if (err > 0) {
  2223d3:	48 83 f9 06          	cmp    rcx,0x6
  2223d7:	0f 85 e2 fd ff ff    	jne    2221bf <openSelfDebugInfoLinux+0x322f>
  2223dd:	66 bf 27 00          	mov    di,0x27
  2223e1:	66 85 ff             	test   di,di
  2223e4:	0f 85 de fd ff ff    	jne    2221c8 <openSelfDebugInfoLinux+0x3238>
  2223ea:	e9 14 f9 ff ff       	jmp    221d03 <openSelfDebugInfoLinux+0x2d73>
            .value = try parseFormValue(st.allocator(), in_stream, attr.form_id, is_64),
  2223ef:	c5 fc 10 84 24 b0 04 	vmovups ymm0,YMMWORD PTR [rsp+0x4b0]
  2223f6:	00 00 
  2223f8:	c5 fc 10 8c 24 c6 04 	vmovups ymm1,YMMWORD PTR [rsp+0x4c6]
  2223ff:	00 00 
  222401:	c5 fc 11 8c 24 76 03 	vmovups YMMWORD PTR [rsp+0x376],ymm1
  222408:	00 00 
  22240a:	c5 fc 11 84 24 60 03 	vmovups YMMWORD PTR [rsp+0x360],ymm0
  222411:	00 00 
  222413:	89 c7                	mov    edi,eax
    try scanAllCompileUnits(&di);
  222415:	66 85 ff             	test   di,di
  222418:	0f 85 aa fd ff ff    	jne    2221c8 <openSelfDebugInfoLinux+0x3238>
  22241e:	e9 e0 f8 ff ff       	jmp    221d03 <openSelfDebugInfoLinux+0x2d73>
  222423:	66 b9 25 00          	mov    cx,0x25
  222427:	eb 04                	jmp    22242d <openSelfDebugInfoLinux+0x349d>
  222429:	66 b9 29 00          	mov    cx,0x29
            const form_id = try readULeb128(in_stream);
  22242d:	48 8b 84 24 6e 04 00 	mov    rax,QWORD PTR [rsp+0x46e]
  222434:	00 
  222435:	48 89 84 24 8e 02 00 	mov    QWORD PTR [rsp+0x28e],rax
  22243c:	00 
  22243d:	c5 fc 10 84 24 50 04 	vmovups ymm0,YMMWORD PTR [rsp+0x450]
  222444:	00 00 
  222446:	e9 20 fc ff ff       	jmp    22206b <openSelfDebugInfoLinux+0x30db>
  22244b:	66 b9 25 00          	mov    cx,0x25
  22244f:	eb 04                	jmp    222455 <openSelfDebugInfoLinux+0x34c5>
  222451:	66 b9 29 00          	mov    cx,0x29
            const attr_id = try readULeb128(in_stream);
  222455:	48 8b 84 24 46 04 00 	mov    rax,QWORD PTR [rsp+0x446]
  22245c:	00 
  22245d:	48 89 84 24 8e 02 00 	mov    QWORD PTR [rsp+0x28e],rax
  222464:	00 
  222465:	c5 fc 10 84 24 28 04 	vmovups ymm0,YMMWORD PTR [rsp+0x428]
  22246c:	00 00 
  22246e:	e9 f8 fb ff ff       	jmp    22206b <openSelfDebugInfoLinux+0x30db>
  222473:	66 b9 25 00          	mov    cx,0x25
            .has_children = (try in_stream.readByte()) == DW.CHILDREN_yes,
  222477:	48 8b 84 24 06 05 00 	mov    rax,QWORD PTR [rsp+0x506]
  22247e:	00 
  22247f:	48 89 84 24 8e 02 00 	mov    QWORD PTR [rsp+0x28e],rax
  222486:	00 
  222487:	c5 fc 10 84 24 e8 04 	vmovups ymm0,YMMWORD PTR [rsp+0x4e8]
  22248e:	00 00 
  222490:	e9 d6 fb ff ff       	jmp    22206b <openSelfDebugInfoLinux+0x30db>
    try result.attrs.resize(table_entry.attrs.len);
  222495:	c5 fc 10 44 24 68    	vmovups ymm0,YMMWORD PTR [rsp+0x68]
  22249b:	c5 fc 10 4c 24 7e    	vmovups ymm1,YMMWORD PTR [rsp+0x7e]
  2224a1:	e9 5b ff ff ff       	jmp    222401 <openSelfDebugInfoLinux+0x3471>
        try result.append(AbbrevTableEntry{
  2224a6:	48 8b 84 24 4e 03 00 	mov    rax,QWORD PTR [rsp+0x34e]
  2224ad:	00 
  2224ae:	48 89 84 24 8e 02 00 	mov    QWORD PTR [rsp+0x28e],rax
  2224b5:	00 
  2224b6:	c5 fc 10 84 24 30 03 	vmovups ymm0,YMMWORD PTR [rsp+0x330]
  2224bd:	00 00 
  2224bf:	e9 a7 fb ff ff       	jmp    22206b <openSelfDebugInfoLinux+0x30db>
            try attrs.append(AbbrevAttr{
  2224c4:	48 8b 84 24 1e 04 00 	mov    rax,QWORD PTR [rsp+0x41e]
  2224cb:	00 
  2224cc:	48 89 84 24 8e 02 00 	mov    QWORD PTR [rsp+0x28e],rax
  2224d3:	00 
  2224d4:	c5 fc 10 84 24 00 04 	vmovups ymm0,YMMWORD PTR [rsp+0x400]
  2224db:	00 00 
  2224dd:	e9 89 fb ff ff       	jmp    22206b <openSelfDebugInfoLinux+0x30db>
            try self.readNoEof(bytes[0..]);
  2224e2:	48 8d 44 24 10       	lea    rax,[rsp+0x10]
  2224e7:	48 89 44 24 68       	mov    QWORD PTR [rsp+0x68],rax
  2224ec:	48 c7 44 24 70 04 00 	mov    QWORD PTR [rsp+0x70],0x4
  2224f3:	00 00 
  2224f5:	48 8d bc 24 c0 00 00 	lea    rdi,[rsp+0xc0]
  2224fc:	00 
  2224fd:	48 8d 54 24 68       	lea    rdx,[rsp+0x68]
            return self.readFn(self, buffer);
  222502:	48 8d 74 24 48       	lea    rsi,[rsp+0x48]
  222507:	ff 54 24 48          	call   QWORD PTR [rsp+0x48]
  22250b:	0f b7 ac 24 c0 00 00 	movzx  ebp,WORD PTR [rsp+0xc0]
  222512:	00 
            const amt_read = try self.read(buf);
  222513:	66 85 ed             	test   bp,bp
  222516:	0f 85 48 cc ff ff    	jne    21f164 <openSelfDebugInfoLinux+0x1d4>
  22251c:	48 8b 84 24 c8 00 00 	mov    rax,QWORD PTR [rsp+0xc8]
  222523:	00 
  222524:	66 bd 25 00          	mov    bp,0x25
            if (amt_read < buf.len) return error.EndOfStream;
  222528:	48 3b 44 24 70       	cmp    rax,QWORD PTR [rsp+0x70]
  22252d:	0f 82 31 cc ff ff    	jb     21f164 <openSelfDebugInfoLinux+0x1d4>
  222533:	0f b6 44 24 10       	movzx  eax,BYTE PTR [rsp+0x10]
  222538:	0f b6 4c 24 11       	movzx  ecx,BYTE PTR [rsp+0x11]
    switch (endian) {
  22253d:	f6 44 24 30 01       	test   BYTE PTR [rsp+0x30],0x1
  222542:	74 1b                	je     22255f <openSelfDebugInfoLinux+0x35cf>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  222544:	c1 e1 08             	shl    ecx,0x8
  222547:	09 c1                	or     ecx,eax
  222549:	0f b6 54 24 12       	movzx  edx,BYTE PTR [rsp+0x12]
  22254e:	c1 e2 10             	shl    edx,0x10
  222551:	09 ca                	or     edx,ecx
  222553:	0f b6 44 24 13       	movzx  eax,BYTE PTR [rsp+0x13]
  222558:	c1 e0 18             	shl    eax,0x18
  22255b:	09 d0                	or     eax,edx
  22255d:	eb 19                	jmp    222578 <openSelfDebugInfoLinux+0x35e8>
                result = (result << 8) | b;
  22255f:	c1 e0 08             	shl    eax,0x8
  222562:	09 c8                	or     eax,ecx
  222564:	c1 e0 08             	shl    eax,0x8
  222567:	0f b6 4c 24 12       	movzx  ecx,BYTE PTR [rsp+0x12]
  22256c:	09 c1                	or     ecx,eax
  22256e:	c1 e1 08             	shl    ecx,0x8
  222571:	0f b6 44 24 13       	movzx  eax,BYTE PTR [rsp+0x13]
  222576:	09 c8                	or     eax,ecx
            elf.entry_addr = u64(try in.readInt(elf.endian, u32));
  222578:	89 c0                	mov    eax,eax
  22257a:	48 89 84 24 88 01 00 	mov    QWORD PTR [rsp+0x188],rax
  222581:	00 
            elf.program_header_offset = u64(try in.readInt(elf.endian, u32));
  222582:	8a 84 24 82 01 00 00 	mov    al,BYTE PTR [rsp+0x182]
            try self.readNoEof(bytes[0..]);
  222589:	88 44 24 30          	mov    BYTE PTR [rsp+0x30],al
  22258d:	48 8d 44 24 10       	lea    rax,[rsp+0x10]
  222592:	48 89 44 24 68       	mov    QWORD PTR [rsp+0x68],rax
  222597:	48 c7 44 24 70 04 00 	mov    QWORD PTR [rsp+0x70],0x4
  22259e:	00 00 
  2225a0:	48 8d bc 24 c0 00 00 	lea    rdi,[rsp+0xc0]
  2225a7:	00 
  2225a8:	48 8d 54 24 68       	lea    rdx,[rsp+0x68]
            return self.readFn(self, buffer);
  2225ad:	48 8d 74 24 48       	lea    rsi,[rsp+0x48]
  2225b2:	ff 54 24 48          	call   QWORD PTR [rsp+0x48]
  2225b6:	0f b7 ac 24 c0 00 00 	movzx  ebp,WORD PTR [rsp+0xc0]
  2225bd:	00 
            const amt_read = try self.read(buf);
  2225be:	66 85 ed             	test   bp,bp
  2225c1:	0f 85 9d cb ff ff    	jne    21f164 <openSelfDebugInfoLinux+0x1d4>
  2225c7:	48 8b 84 24 c8 00 00 	mov    rax,QWORD PTR [rsp+0xc8]
  2225ce:	00 
  2225cf:	66 bd 25 00          	mov    bp,0x25
            if (amt_read < buf.len) return error.EndOfStream;
  2225d3:	48 3b 44 24 70       	cmp    rax,QWORD PTR [rsp+0x70]
  2225d8:	0f 82 86 cb ff ff    	jb     21f164 <openSelfDebugInfoLinux+0x1d4>
  2225de:	0f b6 44 24 10       	movzx  eax,BYTE PTR [rsp+0x10]
  2225e3:	0f b6 4c 24 11       	movzx  ecx,BYTE PTR [rsp+0x11]
    switch (endian) {
  2225e8:	f6 44 24 30 01       	test   BYTE PTR [rsp+0x30],0x1
  2225ed:	74 1b                	je     22260a <openSelfDebugInfoLinux+0x367a>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  2225ef:	c1 e1 08             	shl    ecx,0x8
  2225f2:	09 c1                	or     ecx,eax
  2225f4:	0f b6 54 24 12       	movzx  edx,BYTE PTR [rsp+0x12]
  2225f9:	c1 e2 10             	shl    edx,0x10
  2225fc:	09 ca                	or     edx,ecx
  2225fe:	0f b6 44 24 13       	movzx  eax,BYTE PTR [rsp+0x13]
  222603:	c1 e0 18             	shl    eax,0x18
  222606:	09 d0                	or     eax,edx
  222608:	eb 19                	jmp    222623 <openSelfDebugInfoLinux+0x3693>
                result = (result << 8) | b;
  22260a:	c1 e0 08             	shl    eax,0x8
  22260d:	09 c8                	or     eax,ecx
  22260f:	c1 e0 08             	shl    eax,0x8
  222612:	0f b6 4c 24 12       	movzx  ecx,BYTE PTR [rsp+0x12]
  222617:	09 c1                	or     ecx,eax
  222619:	c1 e1 08             	shl    ecx,0x8
  22261c:	0f b6 44 24 13       	movzx  eax,BYTE PTR [rsp+0x13]
  222621:	09 c8                	or     eax,ecx
  222623:	89 c0                	mov    eax,eax
  222625:	48 89 84 24 90 01 00 	mov    QWORD PTR [rsp+0x190],rax
  22262c:	00 
            elf.section_header_offset = u64(try in.readInt(elf.endian, u32));
  22262d:	8a 84 24 82 01 00 00 	mov    al,BYTE PTR [rsp+0x182]
            try self.readNoEof(bytes[0..]);
  222634:	88 44 24 30          	mov    BYTE PTR [rsp+0x30],al
  222638:	48 8d 44 24 10       	lea    rax,[rsp+0x10]
  22263d:	48 89 44 24 68       	mov    QWORD PTR [rsp+0x68],rax
  222642:	48 c7 44 24 70 04 00 	mov    QWORD PTR [rsp+0x70],0x4
  222649:	00 00 
  22264b:	48 8d bc 24 c0 00 00 	lea    rdi,[rsp+0xc0]
  222652:	00 
  222653:	48 8d 54 24 68       	lea    rdx,[rsp+0x68]
            return self.readFn(self, buffer);
  222658:	48 8d 74 24 48       	lea    rsi,[rsp+0x48]
  22265d:	ff 54 24 48          	call   QWORD PTR [rsp+0x48]
  222661:	0f b7 ac 24 c0 00 00 	movzx  ebp,WORD PTR [rsp+0xc0]
  222668:	00 
            const amt_read = try self.read(buf);
  222669:	66 85 ed             	test   bp,bp
  22266c:	0f 85 f2 ca ff ff    	jne    21f164 <openSelfDebugInfoLinux+0x1d4>
  222672:	48 8b 84 24 c8 00 00 	mov    rax,QWORD PTR [rsp+0xc8]
  222679:	00 
  22267a:	66 bd 25 00          	mov    bp,0x25
            if (amt_read < buf.len) return error.EndOfStream;
  22267e:	48 3b 44 24 70       	cmp    rax,QWORD PTR [rsp+0x70]
  222683:	0f 82 db ca ff ff    	jb     21f164 <openSelfDebugInfoLinux+0x1d4>
  222689:	0f b6 44 24 10       	movzx  eax,BYTE PTR [rsp+0x10]
  22268e:	0f b6 4c 24 11       	movzx  ecx,BYTE PTR [rsp+0x11]
    switch (endian) {
  222693:	f6 44 24 30 01       	test   BYTE PTR [rsp+0x30],0x1
  222698:	74 1b                	je     2226b5 <openSelfDebugInfoLinux+0x3725>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  22269a:	c1 e1 08             	shl    ecx,0x8
  22269d:	09 c1                	or     ecx,eax
  22269f:	0f b6 54 24 12       	movzx  edx,BYTE PTR [rsp+0x12]
  2226a4:	c1 e2 10             	shl    edx,0x10
  2226a7:	09 ca                	or     edx,ecx
  2226a9:	0f b6 44 24 13       	movzx  eax,BYTE PTR [rsp+0x13]
  2226ae:	c1 e0 18             	shl    eax,0x18
  2226b1:	09 d0                	or     eax,edx
  2226b3:	eb 19                	jmp    2226ce <openSelfDebugInfoLinux+0x373e>
                result = (result << 8) | b;
  2226b5:	c1 e0 08             	shl    eax,0x8
  2226b8:	09 c8                	or     eax,ecx
  2226ba:	c1 e0 08             	shl    eax,0x8
  2226bd:	0f b6 4c 24 12       	movzx  ecx,BYTE PTR [rsp+0x12]
  2226c2:	09 c1                	or     ecx,eax
  2226c4:	c1 e1 08             	shl    ecx,0x8
  2226c7:	0f b6 44 24 13       	movzx  eax,BYTE PTR [rsp+0x13]
  2226cc:	09 c8                	or     eax,ecx
  2226ce:	89 c0                	mov    eax,eax
  2226d0:	e9 6a d0 ff ff       	jmp    21f73f <openSelfDebugInfoLinux+0x7af>
        const ph_entry_size = try in.readInt(elf.endian, u16);
  2226d5:	8a 84 24 82 01 00 00 	mov    al,BYTE PTR [rsp+0x182]
            try self.readNoEof(bytes[0..]);
  2226dc:	88 44 24 30          	mov    BYTE PTR [rsp+0x30],al
  2226e0:	48 8d 44 24 10       	lea    rax,[rsp+0x10]
  2226e5:	48 89 44 24 68       	mov    QWORD PTR [rsp+0x68],rax
  2226ea:	48 c7 44 24 70 02 00 	mov    QWORD PTR [rsp+0x70],0x2
  2226f1:	00 00 
  2226f3:	48 8d bc 24 c0 00 00 	lea    rdi,[rsp+0xc0]
  2226fa:	00 
  2226fb:	48 8d 54 24 68       	lea    rdx,[rsp+0x68]
            return self.readFn(self, buffer);
  222700:	48 8d 74 24 48       	lea    rsi,[rsp+0x48]
  222705:	ff 54 24 48          	call   QWORD PTR [rsp+0x48]
  222709:	0f b7 ac 24 c0 00 00 	movzx  ebp,WORD PTR [rsp+0xc0]
  222710:	00 
            const amt_read = try self.read(buf);
  222711:	66 85 ed             	test   bp,bp
  222714:	0f 85 4a ca ff ff    	jne    21f164 <openSelfDebugInfoLinux+0x1d4>
  22271a:	48 8b 84 24 c8 00 00 	mov    rax,QWORD PTR [rsp+0xc8]
  222721:	00 
  222722:	66 bd 25 00          	mov    bp,0x25
            if (amt_read < buf.len) return error.EndOfStream;
  222726:	48 3b 44 24 70       	cmp    rax,QWORD PTR [rsp+0x70]
  22272b:	0f 82 33 ca ff ff    	jb     21f164 <openSelfDebugInfoLinux+0x1d4>
  222731:	0f b6 54 24 10       	movzx  edx,BYTE PTR [rsp+0x10]
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  222736:	0f b6 44 24 11       	movzx  eax,BYTE PTR [rsp+0x11]
  22273b:	89 c1                	mov    ecx,eax
  22273d:	c1 e1 08             	shl    ecx,0x8
  222740:	09 d1                	or     ecx,edx
                result = (result << 8) | b;
  222742:	c1 e2 08             	shl    edx,0x8
  222745:	09 c2                	or     edx,eax
    switch (endian) {
  222747:	f6 44 24 30 01       	test   BYTE PTR [rsp+0x30],0x1
  22274c:	66 0f 45 d1          	cmovne dx,cx
  222750:	89 54 24 58          	mov    DWORD PTR [rsp+0x58],edx
        const ph_entry_count = try in.readInt(elf.endian, u16);
  222754:	8a 84 24 82 01 00 00 	mov    al,BYTE PTR [rsp+0x182]
            try self.readNoEof(bytes[0..]);
  22275b:	88 44 24 30          	mov    BYTE PTR [rsp+0x30],al
  22275f:	48 8d 44 24 10       	lea    rax,[rsp+0x10]
  222764:	48 89 44 24 68       	mov    QWORD PTR [rsp+0x68],rax
  222769:	48 c7 44 24 70 02 00 	mov    QWORD PTR [rsp+0x70],0x2
  222770:	00 00 
  222772:	48 8d bc 24 c0 00 00 	lea    rdi,[rsp+0xc0]
  222779:	00 
  22277a:	48 8d 54 24 68       	lea    rdx,[rsp+0x68]
            return self.readFn(self, buffer);
  22277f:	48 8d 74 24 48       	lea    rsi,[rsp+0x48]
  222784:	ff 54 24 48          	call   QWORD PTR [rsp+0x48]
  222788:	0f b7 ac 24 c0 00 00 	movzx  ebp,WORD PTR [rsp+0xc0]
  22278f:	00 
            const amt_read = try self.read(buf);
  222790:	66 85 ed             	test   bp,bp
  222793:	0f 85 cb c9 ff ff    	jne    21f164 <openSelfDebugInfoLinux+0x1d4>
  222799:	48 8b 84 24 c8 00 00 	mov    rax,QWORD PTR [rsp+0xc8]
  2227a0:	00 
  2227a1:	66 bd 25 00          	mov    bp,0x25
            if (amt_read < buf.len) return error.EndOfStream;
  2227a5:	48 3b 44 24 70       	cmp    rax,QWORD PTR [rsp+0x70]
  2227aa:	0f 82 b4 c9 ff ff    	jb     21f164 <openSelfDebugInfoLinux+0x1d4>
  2227b0:	0f b6 54 24 10       	movzx  edx,BYTE PTR [rsp+0x10]
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  2227b5:	0f b6 44 24 11       	movzx  eax,BYTE PTR [rsp+0x11]
  2227ba:	89 c1                	mov    ecx,eax
  2227bc:	c1 e1 08             	shl    ecx,0x8
  2227bf:	09 d1                	or     ecx,edx
                result = (result << 8) | b;
  2227c1:	c1 e2 08             	shl    edx,0x8
  2227c4:	09 c2                	or     edx,eax
    switch (endian) {
  2227c6:	f6 44 24 30 01       	test   BYTE PTR [rsp+0x30],0x1
  2227cb:	66 0f 45 d1          	cmovne dx,cx
  2227cf:	89 54 24 60          	mov    DWORD PTR [rsp+0x60],edx
        const sh_entry_size = try in.readInt(elf.endian, u16);
  2227d3:	8a 84 24 82 01 00 00 	mov    al,BYTE PTR [rsp+0x182]
            try self.readNoEof(bytes[0..]);
  2227da:	88 44 24 30          	mov    BYTE PTR [rsp+0x30],al
  2227de:	48 8d 44 24 10       	lea    rax,[rsp+0x10]
  2227e3:	48 89 44 24 68       	mov    QWORD PTR [rsp+0x68],rax
  2227e8:	48 c7 44 24 70 02 00 	mov    QWORD PTR [rsp+0x70],0x2
  2227ef:	00 00 
  2227f1:	48 8d bc 24 c0 00 00 	lea    rdi,[rsp+0xc0]
  2227f8:	00 
  2227f9:	48 8d 54 24 68       	lea    rdx,[rsp+0x68]
            return self.readFn(self, buffer);
  2227fe:	48 8d 74 24 48       	lea    rsi,[rsp+0x48]
  222803:	ff 54 24 48          	call   QWORD PTR [rsp+0x48]
  222807:	0f b7 ac 24 c0 00 00 	movzx  ebp,WORD PTR [rsp+0xc0]
  22280e:	00 
            const amt_read = try self.read(buf);
  22280f:	66 85 ed             	test   bp,bp
  222812:	0f 85 4c c9 ff ff    	jne    21f164 <openSelfDebugInfoLinux+0x1d4>
  222818:	48 8b 84 24 c8 00 00 	mov    rax,QWORD PTR [rsp+0xc8]
  22281f:	00 
  222820:	66 bd 25 00          	mov    bp,0x25
            if (amt_read < buf.len) return error.EndOfStream;
  222824:	48 3b 44 24 70       	cmp    rax,QWORD PTR [rsp+0x70]
  222829:	0f 82 35 c9 ff ff    	jb     21f164 <openSelfDebugInfoLinux+0x1d4>
  22282f:	0f b6 54 24 10       	movzx  edx,BYTE PTR [rsp+0x10]
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  222834:	0f b6 44 24 11       	movzx  eax,BYTE PTR [rsp+0x11]
  222839:	89 c1                	mov    ecx,eax
  22283b:	c1 e1 08             	shl    ecx,0x8
  22283e:	09 d1                	or     ecx,edx
                result = (result << 8) | b;
  222840:	c1 e2 08             	shl    edx,0x8
  222843:	09 c2                	or     edx,eax
    switch (endian) {
  222845:	f6 44 24 30 01       	test   BYTE PTR [rsp+0x30],0x1
  22284a:	66 0f 45 d1          	cmovne dx,cx
  22284e:	89 94 24 b0 00 00 00 	mov    DWORD PTR [rsp+0xb0],edx
        const sh_entry_count = try in.readInt(elf.endian, u16);
  222855:	8a 84 24 82 01 00 00 	mov    al,BYTE PTR [rsp+0x182]
            try self.readNoEof(bytes[0..]);
  22285c:	88 44 24 30          	mov    BYTE PTR [rsp+0x30],al
  222860:	48 8d 44 24 10       	lea    rax,[rsp+0x10]
  222865:	48 89 44 24 68       	mov    QWORD PTR [rsp+0x68],rax
  22286a:	48 c7 44 24 70 02 00 	mov    QWORD PTR [rsp+0x70],0x2
  222871:	00 00 
  222873:	48 8d bc 24 c0 00 00 	lea    rdi,[rsp+0xc0]
  22287a:	00 
  22287b:	48 8d 54 24 68       	lea    rdx,[rsp+0x68]
            return self.readFn(self, buffer);
  222880:	48 8d 74 24 48       	lea    rsi,[rsp+0x48]
  222885:	ff 54 24 48          	call   QWORD PTR [rsp+0x48]
  222889:	0f b7 ac 24 c0 00 00 	movzx  ebp,WORD PTR [rsp+0xc0]
  222890:	00 
            const amt_read = try self.read(buf);
  222891:	66 85 ed             	test   bp,bp
  222894:	0f 85 ca c8 ff ff    	jne    21f164 <openSelfDebugInfoLinux+0x1d4>
  22289a:	48 8b 84 24 c8 00 00 	mov    rax,QWORD PTR [rsp+0xc8]
  2228a1:	00 
  2228a2:	66 bd 25 00          	mov    bp,0x25
            if (amt_read < buf.len) return error.EndOfStream;
  2228a6:	48 3b 44 24 70       	cmp    rax,QWORD PTR [rsp+0x70]
  2228ab:	0f 82 b3 c8 ff ff    	jb     21f164 <openSelfDebugInfoLinux+0x1d4>
  2228b1:	0f b6 54 24 10       	movzx  edx,BYTE PTR [rsp+0x10]
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  2228b6:	0f b6 44 24 11       	movzx  eax,BYTE PTR [rsp+0x11]
  2228bb:	89 c1                	mov    ecx,eax
  2228bd:	c1 e1 08             	shl    ecx,0x8
  2228c0:	09 d1                	or     ecx,edx
                result = (result << 8) | b;
  2228c2:	c1 e2 08             	shl    edx,0x8
  2228c5:	09 c2                	or     edx,eax
    switch (endian) {
  2228c7:	f6 44 24 30 01       	test   BYTE PTR [rsp+0x30],0x1
  2228cc:	66 0f 45 d1          	cmovne dx,cx
  2228d0:	89 54 24 30          	mov    DWORD PTR [rsp+0x30],edx
        elf.string_section_index = u64(try in.readInt(elf.endian, u16));
  2228d4:	8a 84 24 82 01 00 00 	mov    al,BYTE PTR [rsp+0x182]
            try self.readNoEof(bytes[0..]);
  2228db:	88 84 24 48 02 00 00 	mov    BYTE PTR [rsp+0x248],al
  2228e2:	48 8d 44 24 10       	lea    rax,[rsp+0x10]
  2228e7:	48 89 44 24 68       	mov    QWORD PTR [rsp+0x68],rax
  2228ec:	48 c7 44 24 70 02 00 	mov    QWORD PTR [rsp+0x70],0x2
  2228f3:	00 00 
  2228f5:	48 8d bc 24 c0 00 00 	lea    rdi,[rsp+0xc0]
  2228fc:	00 
  2228fd:	48 8d 54 24 68       	lea    rdx,[rsp+0x68]
  222902:	48 89 7c 24 38       	mov    QWORD PTR [rsp+0x38],rdi
            return self.readFn(self, buffer);
  222907:	48 8d 74 24 48       	lea    rsi,[rsp+0x48]
  22290c:	ff 54 24 48          	call   QWORD PTR [rsp+0x48]
  222910:	0f b7 ac 24 c0 00 00 	movzx  ebp,WORD PTR [rsp+0xc0]
  222917:	00 
            const amt_read = try self.read(buf);
  222918:	66 85 ed             	test   bp,bp
  22291b:	0f 85 43 c8 ff ff    	jne    21f164 <openSelfDebugInfoLinux+0x1d4>
  222921:	48 8b 84 24 c8 00 00 	mov    rax,QWORD PTR [rsp+0xc8]
  222928:	00 
  222929:	66 bd 25 00          	mov    bp,0x25
            if (amt_read < buf.len) return error.EndOfStream;
  22292d:	48 3b 44 24 70       	cmp    rax,QWORD PTR [rsp+0x70]
  222932:	0f 82 2c c8 ff ff    	jb     21f164 <openSelfDebugInfoLinux+0x1d4>
  222938:	0f b6 44 24 10       	movzx  eax,BYTE PTR [rsp+0x10]
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  22293d:	0f b6 4c 24 11       	movzx  ecx,BYTE PTR [rsp+0x11]
  222942:	89 ca                	mov    edx,ecx
  222944:	c1 e2 08             	shl    edx,0x8
  222947:	09 c2                	or     edx,eax
                result = (result << 8) | b;
  222949:	c1 e0 08             	shl    eax,0x8
  22294c:	09 c8                	or     eax,ecx
    switch (endian) {
  22294e:	f6 84 24 48 02 00 00 	test   BYTE PTR [rsp+0x248],0x1
  222955:	01 
  222956:	66 0f 45 c2          	cmovne ax,dx
  22295a:	0f b7 c0             	movzx  eax,ax
  22295d:	48 89 84 24 a0 01 00 	mov    QWORD PTR [rsp+0x1a0],rax
  222964:	00 
        if (elf.string_section_index >= sh_entry_count) return error.InvalidFormat;
  222965:	66 3b 44 24 30       	cmp    ax,WORD PTR [rsp+0x30]
  22296a:	0f 83 c7 ce ff ff    	jae    21f837 <openSelfDebugInfoLinux+0x8a7>
  222970:	0f b7 4c 24 30       	movzx  ecx,WORD PTR [rsp+0x30]
        const sh_byte_count = u64(sh_entry_size) * u64(sh_entry_count);
  222975:	0f b7 84 24 b0 00 00 	movzx  eax,WORD PTR [rsp+0xb0]
  22297c:	00 
  22297d:	48 89 84 24 b0 00 00 	mov    QWORD PTR [rsp+0xb0],rax
  222984:	00 
  222985:	48 89 4c 24 30       	mov    QWORD PTR [rsp+0x30],rcx
  22298a:	48 0f af c1          	imul   rax,rcx
    return if (@addWithOverflow(T, a, b, &answer)) error.Overflow else answer;
  22298e:	48 03 84 24 98 01 00 	add    rax,QWORD PTR [rsp+0x198]
  222995:	00 
  222996:	73 1f                	jae    2229b7 <openSelfDebugInfoLinux+0x3a27>
  222998:	48 8d 05 21 db fd ff 	lea    rax,[rip+0xfffffffffffddb21]        # 2004c0 <__unnamed_27>
  22299f:	48 89 44 24 38       	mov    QWORD PTR [rsp+0x38],rax
  2229a4:	48 8b 44 24 38       	mov    rax,QWORD PTR [rsp+0x38]
  2229a9:	0f b7 28             	movzx  ebp,WORD PTR [rax]
        const end_sh = try math.add(u64, elf.section_header_offset, sh_byte_count);
  2229ac:	66 85 ed             	test   bp,bp
  2229af:	0f 85 af c7 ff ff    	jne    21f164 <openSelfDebugInfoLinux+0x1d4>
  2229b5:	eb 23                	jmp    2229da <openSelfDebugInfoLinux+0x3a4a>
  2229b7:	66 c7 84 24 c0 00 00 	mov    WORD PTR [rsp+0xc0],0x0
  2229be:	00 00 00 
  2229c1:	48 89 84 24 c8 00 00 	mov    QWORD PTR [rsp+0xc8],rax
  2229c8:	00 
  2229c9:	48 8b 44 24 38       	mov    rax,QWORD PTR [rsp+0x38]
  2229ce:	0f b7 28             	movzx  ebp,WORD PTR [rax]
  2229d1:	66 85 ed             	test   bp,bp
  2229d4:	0f 85 8a c7 ff ff    	jne    21f164 <openSelfDebugInfoLinux+0x1d4>
  2229da:	48 8b 44 24 38       	mov    rax,QWORD PTR [rsp+0x38]
  2229df:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
        const ph_byte_count = u64(ph_entry_size) * u64(ph_entry_count);
  2229e3:	0f b7 44 24 58       	movzx  eax,WORD PTR [rsp+0x58]
  2229e8:	0f b7 4c 24 60       	movzx  ecx,WORD PTR [rsp+0x60]
  2229ed:	48 0f af c8          	imul   rcx,rax
  2229f1:	48 03 8c 24 90 01 00 	add    rcx,QWORD PTR [rsp+0x190]
  2229f8:	00 
  2229f9:	73 15                	jae    222a10 <openSelfDebugInfoLinux+0x3a80>
  2229fb:	48 8d 05 be da fd ff 	lea    rax,[rip+0xfffffffffffddabe]        # 2004c0 <__unnamed_27>
  222a02:	0f b7 28             	movzx  ebp,WORD PTR [rax]
        const end_ph = try math.add(u64, elf.program_header_offset, ph_byte_count);
  222a05:	66 85 ed             	test   bp,bp
  222a08:	0f 85 56 c7 ff ff    	jne    21f164 <openSelfDebugInfoLinux+0x1d4>
  222a0e:	eb 26                	jmp    222a36 <openSelfDebugInfoLinux+0x3aa6>
  222a10:	48 8d 84 24 c0 00 00 	lea    rax,[rsp+0xc0]
  222a17:	00 
  222a18:	66 c7 84 24 c0 00 00 	mov    WORD PTR [rsp+0xc0],0x0
  222a1f:	00 00 00 
  222a22:	48 89 8c 24 c8 00 00 	mov    QWORD PTR [rsp+0xc8],rcx
  222a29:	00 
  222a2a:	0f b7 28             	movzx  ebp,WORD PTR [rax]
  222a2d:	66 85 ed             	test   bp,bp
  222a30:	0f 85 2e c7 ff ff    	jne    21f164 <openSelfDebugInfoLinux+0x1d4>
  222a36:	4c 8b 40 08          	mov    r8,QWORD PTR [rax+0x8]
        const stream_end = try elf.in_file.getEndPos();
  222a3a:	48 8b 84 24 78 01 00 	mov    rax,QWORD PTR [rsp+0x178]
  222a41:	00 
pub fn accept4(fd: i32, noalias addr: *sockaddr, noalias len: *socklen_t, flags: u32) usize {
    return syscall4(SYS_accept4, @intCast(usize, fd), @ptrToInt(addr), @ptrToInt(len), flags);
}

pub fn fstat(fd: i32, stat_buf: *Stat) usize {
    return syscall2(SYS_fstat, @intCast(usize, fd), @ptrToInt(stat_buf));
  222a42:	48 63 38             	movsxd rdi,DWORD PTR [rax]
        }
    }
}

pub fn posixFStat(fd: i32) !posix.Stat {
    var stat: posix.Stat = undefined;
  222a45:	c5 fc 10 05 bb 57 fe 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffe57bb]        # 208208 <__unnamed_50+0x70>
  222a4c:	ff 
  222a4d:	c5 fc 11 84 24 30 01 	vmovups YMMWORD PTR [rsp+0x130],ymm0
  222a54:	00 00 
  222a56:	c5 fc 10 05 9a 57 fe 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffe579a]        # 2081f8 <__unnamed_50+0x60>
  222a5d:	ff 
  222a5e:	c5 fc 11 84 24 20 01 	vmovups YMMWORD PTR [rsp+0x120],ymm0
  222a65:	00 00 
  222a67:	c5 fc 10 05 69 57 fe 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffe5769]        # 2081d8 <__unnamed_50+0x40>
  222a6e:	ff 
  222a6f:	c5 fc 11 84 24 00 01 	vmovups YMMWORD PTR [rsp+0x100],ymm0
  222a76:	00 00 
  222a78:	c5 fc 10 05 38 57 fe 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffe5738]        # 2081b8 <__unnamed_50+0x20>
  222a7f:	ff 
  222a80:	c5 fc 11 84 24 e0 00 	vmovups YMMWORD PTR [rsp+0xe0],ymm0
  222a87:	00 00 
  222a89:	c5 fe 6f 05 07 57 fe 	vmovdqu ymm0,YMMWORD PTR [rip+0xfffffffffffe5707]        # 208198 <__unnamed_50>
  222a90:	ff 
  222a91:	c5 fe 7f 84 24 c0 00 	vmovdqu YMMWORD PTR [rsp+0xc0],ymm0
  222a98:	00 00 
  222a9a:	48 8d b4 24 c0 00 00 	lea    rsi,[rsp+0xc0]
  222aa1:	00 
    return asm volatile ("syscall"
  222aa2:	b8 05 00 00 00       	mov    eax,0x5
  222aa7:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  222aa9:	48 89 c6             	mov    rsi,rax
  222aac:	48 f7 de             	neg    rsi
  222aaf:	31 c9                	xor    ecx,ecx
  222ab1:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  222ab7:	48 0f 47 ce          	cmova  rcx,rsi
    const err = posix.getErrno(posix.fstat(fd, &stat));
    if (err > 0) {
  222abb:	48 85 c9             	test   rcx,rcx
  222abe:	74 20                	je     222ae0 <openSelfDebugInfoLinux+0x3b50>
  222ac0:	66 bd 0c 00          	mov    bp,0xc
  222ac4:	48 83 f9 0c          	cmp    rcx,0xc
  222ac8:	0f 84 96 c6 ff ff    	je     21f164 <openSelfDebugInfoLinux+0x1d4>
  222ace:	66 bd 03 00          	mov    bp,0x3
    try di.elf.openFile(allocator, &di.self_exe_file);
  222ad2:	66 85 ed             	test   bp,bp
  222ad5:	0f 85 92 c6 ff ff    	jne    21f16d <openSelfDebugInfoLinux+0x1dd>
  222adb:	e9 64 cd ff ff       	jmp    21f844 <openSelfDebugInfoLinux+0x8b4>
            posix.ENOMEM => error.SystemResources,
            else => os.unexpectedErrorPosix(err),
        };
    }

    return stat;
  222ae0:	48 8b 84 24 f0 00 00 	mov    rax,QWORD PTR [rsp+0xf0]
  222ae7:	00 
  222ae8:	48 89 84 24 48 02 00 	mov    QWORD PTR [rsp+0x248],rax
  222aef:	00 
  222af0:	66 bd 26 00          	mov    bp,0x26
        if (stream_end < end_sh or stream_end < end_ph) {
  222af4:	48 39 d0             	cmp    rax,rdx
  222af7:	0f 82 67 c6 ff ff    	jb     21f164 <openSelfDebugInfoLinux+0x1d4>
  222afd:	4c 39 84 24 48 02 00 	cmp    QWORD PTR [rsp+0x248],r8
  222b04:	00 
  222b05:	0f 82 59 c6 ff ff    	jb     21f164 <openSelfDebugInfoLinux+0x1d4>
        try elf.in_file.seekTo(elf.section_header_offset);
  222b0b:	48 8b b4 24 98 01 00 	mov    rsi,QWORD PTR [rsp+0x198]
  222b12:	00 
    if (@maxValue(@typeOf(x)) > @maxValue(T) and x > @maxValue(T)) {
  222b13:	48 85 f6             	test   rsi,rsi
  222b16:	0f 88 c9 05 00 00    	js     2230e5 <openSelfDebugInfoLinux+0x4155>
  222b1c:	48 8b 84 24 78 01 00 	mov    rax,QWORD PTR [rsp+0x178]
  222b23:	00 
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  222b24:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  222b27:	31 ed                	xor    ebp,ebp
    return asm volatile ("syscall"
  222b29:	b8 08 00 00 00       	mov    eax,0x8
  222b2e:	31 d2                	xor    edx,edx
  222b30:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  222b32:	48 89 c1             	mov    rcx,rax
  222b35:	48 f7 d9             	neg    rcx
  222b38:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  222b3e:	48 0f 46 cd          	cmovbe rcx,rbp
  222b42:	48 83 f9 1d          	cmp    rcx,0x1d
  222b46:	0f 87 77 05 00 00    	ja     2230c3 <openSelfDebugInfoLinux+0x4133>
  222b4c:	48 8d 05 1d e5 fd ff 	lea    rax,[rip+0xfffffffffffde51d]        # 201070 <__unnamed_621+0x3b8>
  222b53:	48 63 0c 88          	movsxd rcx,DWORD PTR [rax+rcx*4]
  222b57:	48 01 c1             	add    rcx,rax
  222b5a:	66 bd 03 00          	mov    bp,0x3
  222b5e:	ff e1                	jmp    rcx
        elf.section_headers = try elf.allocator.alloc(SectionHeader, sh_entry_count);
  222b60:	48 8b b4 24 c0 01 00 	mov    rsi,QWORD PTR [rsp+0x1c0]
  222b67:	00 
    return if (@mulWithOverflow(T, a, b, &answer)) error.Overflow else answer;
  222b68:	48 8b 54 24 30       	mov    rdx,QWORD PTR [rsp+0x30]
  222b6d:	48 c1 e2 06          	shl    rdx,0x6
  222b71:	48 8d bc 24 c0 00 00 	lea    rdi,[rsp+0xc0]
  222b78:	00 
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  222b79:	b9 04 00 00 00       	mov    ecx,0x4
  222b7e:	48 89 54 24 60       	mov    QWORD PTR [rsp+0x60],rdx
  222b83:	c5 f8 77             	vzeroupper 
  222b86:	ff 16                	call   QWORD PTR [rsi]
  222b88:	0f b7 ac 24 c0 00 00 	movzx  ebp,WORD PTR [rsp+0xc0]
  222b8f:	00 
  222b90:	66 85 ed             	test   bp,bp
  222b93:	0f 85 cb c5 ff ff    	jne    21f164 <openSelfDebugInfoLinux+0x1d4>
        assert(byte_slice.len == byte_count);
  222b99:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
  222b9e:	48 39 84 24 d0 00 00 	cmp    QWORD PTR [rsp+0xd0],rax
  222ba5:	00 
    if (!ok) {
  222ba6:	0f 85 2a 05 00 00    	jne    2230d6 <openSelfDebugInfoLinux+0x4146>
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  222bac:	48 8b 84 24 c8 00 00 	mov    rax,QWORD PTR [rsp+0xc8]
  222bb3:	00 
  222bb4:	48 89 44 24 58       	mov    QWORD PTR [rsp+0x58],rax
  222bb9:	48 89 84 24 b0 01 00 	mov    QWORD PTR [rsp+0x1b0],rax
  222bc0:	00 
  222bc1:	48 8b 44 24 30       	mov    rax,QWORD PTR [rsp+0x30]
  222bc6:	48 89 84 24 b8 01 00 	mov    QWORD PTR [rsp+0x1b8],rax
  222bcd:	00 
        if (elf.is_64) {
  222bce:	80 bc 24 81 01 00 00 	cmp    BYTE PTR [rsp+0x181],0x1
  222bd5:	01 
  222bd6:	0f 85 1b 05 00 00    	jne    2230f7 <openSelfDebugInfoLinux+0x4167>
            if (sh_entry_size != 64) return error.InvalidFormat;
  222bdc:	83 bc 24 b0 00 00 00 	cmp    DWORD PTR [rsp+0xb0],0x40
  222be3:	40 
  222be4:	0f 85 86 0e 00 00    	jne    223a70 <openSelfDebugInfoLinux+0x4ae0>
                elf_section.name = try in.readInt(elf.endian, u32);
  222bea:	8a 84 24 82 01 00 00 	mov    al,BYTE PTR [rsp+0x182]
            try self.readNoEof(bytes[0..]);
  222bf1:	88 44 24 38          	mov    BYTE PTR [rsp+0x38],al
  222bf5:	48 8d 44 24 10       	lea    rax,[rsp+0x10]
  222bfa:	48 89 44 24 68       	mov    QWORD PTR [rsp+0x68],rax
  222bff:	48 c7 44 24 70 04 00 	mov    QWORD PTR [rsp+0x70],0x4
  222c06:	00 00 
  222c08:	48 8d bc 24 c0 00 00 	lea    rdi,[rsp+0xc0]
  222c0f:	00 
  222c10:	48 8d 54 24 68       	lea    rdx,[rsp+0x68]
            return self.readFn(self, buffer);
  222c15:	48 8d 74 24 48       	lea    rsi,[rsp+0x48]
  222c1a:	ff 54 24 48          	call   QWORD PTR [rsp+0x48]
  222c1e:	0f b7 ac 24 c0 00 00 	movzx  ebp,WORD PTR [rsp+0xc0]
  222c25:	00 
            const amt_read = try self.read(buf);
  222c26:	66 85 ed             	test   bp,bp
  222c29:	0f 85 7a 0e 00 00    	jne    223aa9 <openSelfDebugInfoLinux+0x4b19>
  222c2f:	48 8b 84 24 c8 00 00 	mov    rax,QWORD PTR [rsp+0xc8]
  222c36:	00 
  222c37:	31 c9                	xor    ecx,ecx
  222c39:	48 89 8c 24 b0 00 00 	mov    QWORD PTR [rsp+0xb0],rcx
  222c40:	00 
  222c41:	b9 38 00 00 00       	mov    ecx,0x38
  222c46:	48 89 4c 24 60       	mov    QWORD PTR [rsp+0x60],rcx
            if (amt_read < buf.len) return error.EndOfStream;
  222c4b:	48 3b 44 24 70       	cmp    rax,QWORD PTR [rsp+0x70]
  222c50:	0f 82 4f 0e 00 00    	jb     223aa5 <openSelfDebugInfoLinux+0x4b15>
  222c56:	0f b6 44 24 10       	movzx  eax,BYTE PTR [rsp+0x10]
  222c5b:	0f b6 4c 24 11       	movzx  ecx,BYTE PTR [rsp+0x11]
    switch (endian) {
  222c60:	f6 44 24 38 01       	test   BYTE PTR [rsp+0x38],0x1
  222c65:	74 1b                	je     222c82 <openSelfDebugInfoLinux+0x3cf2>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  222c67:	c1 e1 08             	shl    ecx,0x8
  222c6a:	09 c1                	or     ecx,eax
  222c6c:	0f b6 54 24 12       	movzx  edx,BYTE PTR [rsp+0x12]
  222c71:	c1 e2 10             	shl    edx,0x10
  222c74:	09 ca                	or     edx,ecx
  222c76:	0f b6 44 24 13       	movzx  eax,BYTE PTR [rsp+0x13]
  222c7b:	c1 e0 18             	shl    eax,0x18
  222c7e:	09 d0                	or     eax,edx
  222c80:	eb 19                	jmp    222c9b <openSelfDebugInfoLinux+0x3d0b>
                result = (result << 8) | b;
  222c82:	c1 e0 08             	shl    eax,0x8
  222c85:	09 c8                	or     eax,ecx
  222c87:	c1 e0 08             	shl    eax,0x8
  222c8a:	0f b6 4c 24 12       	movzx  ecx,BYTE PTR [rsp+0x12]
  222c8f:	09 c1                	or     ecx,eax
  222c91:	c1 e1 08             	shl    ecx,0x8
  222c94:	0f b6 44 24 13       	movzx  eax,BYTE PTR [rsp+0x13]
  222c99:	09 c8                	or     eax,ecx
  222c9b:	48 8b 4c 24 58       	mov    rcx,QWORD PTR [rsp+0x58]
  222ca0:	48 8b 54 24 60       	mov    rdx,QWORD PTR [rsp+0x60]
  222ca5:	89 44 11 c8          	mov    DWORD PTR [rcx+rdx*1-0x38],eax
                elf_section.sh_type = try in.readInt(elf.endian, u32);
  222ca9:	0f b6 84 24 82 01 00 	movzx  eax,BYTE PTR [rsp+0x182]
  222cb0:	00 
            try self.readNoEof(bytes[0..]);
  222cb1:	88 44 24 38          	mov    BYTE PTR [rsp+0x38],al
  222cb5:	48 8d 44 24 10       	lea    rax,[rsp+0x10]
  222cba:	48 89 44 24 68       	mov    QWORD PTR [rsp+0x68],rax
  222cbf:	48 c7 44 24 70 04 00 	mov    QWORD PTR [rsp+0x70],0x4
  222cc6:	00 00 
            return self.readFn(self, buffer);
  222cc8:	48 8d bc 24 c0 00 00 	lea    rdi,[rsp+0xc0]
  222ccf:	00 
  222cd0:	48 8d 74 24 48       	lea    rsi,[rsp+0x48]
  222cd5:	48 8d 54 24 68       	lea    rdx,[rsp+0x68]
  222cda:	ff 54 24 48          	call   QWORD PTR [rsp+0x48]
  222cde:	0f b7 ac 24 c0 00 00 	movzx  ebp,WORD PTR [rsp+0xc0]
  222ce5:	00 
            const amt_read = try self.read(buf);
  222ce6:	66 85 ed             	test   bp,bp
  222ce9:	0f 85 ba 0d 00 00    	jne    223aa9 <openSelfDebugInfoLinux+0x4b19>
  222cef:	48 8b 84 24 c8 00 00 	mov    rax,QWORD PTR [rsp+0xc8]
  222cf6:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  222cf7:	48 3b 44 24 70       	cmp    rax,QWORD PTR [rsp+0x70]
  222cfc:	0f 82 a3 0d 00 00    	jb     223aa5 <openSelfDebugInfoLinux+0x4b15>
  222d02:	0f b6 44 24 10       	movzx  eax,BYTE PTR [rsp+0x10]
  222d07:	0f b6 4c 24 11       	movzx  ecx,BYTE PTR [rsp+0x11]
    switch (endian) {
  222d0c:	f6 44 24 38 01       	test   BYTE PTR [rsp+0x38],0x1
  222d11:	74 1b                	je     222d2e <openSelfDebugInfoLinux+0x3d9e>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  222d13:	c1 e1 08             	shl    ecx,0x8
  222d16:	09 c1                	or     ecx,eax
  222d18:	0f b6 54 24 12       	movzx  edx,BYTE PTR [rsp+0x12]
  222d1d:	c1 e2 10             	shl    edx,0x10
  222d20:	09 ca                	or     edx,ecx
  222d22:	0f b6 44 24 13       	movzx  eax,BYTE PTR [rsp+0x13]
  222d27:	c1 e0 18             	shl    eax,0x18
  222d2a:	09 d0                	or     eax,edx
  222d2c:	eb 19                	jmp    222d47 <openSelfDebugInfoLinux+0x3db7>
                result = (result << 8) | b;
  222d2e:	c1 e0 08             	shl    eax,0x8
  222d31:	09 c8                	or     eax,ecx
  222d33:	c1 e0 08             	shl    eax,0x8
  222d36:	0f b6 4c 24 12       	movzx  ecx,BYTE PTR [rsp+0x12]
  222d3b:	09 c1                	or     ecx,eax
  222d3d:	c1 e1 08             	shl    ecx,0x8
  222d40:	0f b6 44 24 13       	movzx  eax,BYTE PTR [rsp+0x13]
  222d45:	09 c8                	or     eax,ecx
  222d47:	48 8b 4c 24 58       	mov    rcx,QWORD PTR [rsp+0x58]
  222d4c:	48 8b 54 24 60       	mov    rdx,QWORD PTR [rsp+0x60]
  222d51:	89 44 11 cc          	mov    DWORD PTR [rcx+rdx*1-0x34],eax
                elf_section.flags = try in.readInt(elf.endian, u64);
  222d55:	0f b6 94 24 82 01 00 	movzx  edx,BYTE PTR [rsp+0x182]
  222d5c:	00 
  222d5d:	48 8d bc 24 28 04 00 	lea    rdi,[rsp+0x428]
  222d64:	00 
  222d65:	48 8d 74 24 48       	lea    rsi,[rsp+0x48]
  222d6a:	e8 91 11 00 00       	call   223f00 <InStream(ReadError)_readInt.143>
  222d6f:	0f b7 ac 24 28 04 00 	movzx  ebp,WORD PTR [rsp+0x428]
  222d76:	00 
  222d77:	66 85 ed             	test   bp,bp
  222d7a:	0f 85 ec 0a 00 00    	jne    22386c <openSelfDebugInfoLinux+0x48dc>
  222d80:	48 8b 84 24 30 04 00 	mov    rax,QWORD PTR [rsp+0x430]
  222d87:	00 
  222d88:	48 8b 4c 24 58       	mov    rcx,QWORD PTR [rsp+0x58]
  222d8d:	48 8b 54 24 60       	mov    rdx,QWORD PTR [rsp+0x60]
  222d92:	48 89 44 11 d0       	mov    QWORD PTR [rcx+rdx*1-0x30],rax
                elf_section.addr = try in.readInt(elf.endian, u64);
  222d97:	0f b6 94 24 82 01 00 	movzx  edx,BYTE PTR [rsp+0x182]
  222d9e:	00 
  222d9f:	48 8d bc 24 50 04 00 	lea    rdi,[rsp+0x450]
  222da6:	00 
  222da7:	48 8d 74 24 48       	lea    rsi,[rsp+0x48]
  222dac:	e8 4f 11 00 00       	call   223f00 <InStream(ReadError)_readInt.143>
  222db1:	0f b7 ac 24 50 04 00 	movzx  ebp,WORD PTR [rsp+0x450]
  222db8:	00 
  222db9:	66 85 ed             	test   bp,bp
  222dbc:	0f 85 00 0b 00 00    	jne    2238c2 <openSelfDebugInfoLinux+0x4932>
  222dc2:	48 8b 84 24 58 04 00 	mov    rax,QWORD PTR [rsp+0x458]
  222dc9:	00 
  222dca:	48 8b 4c 24 58       	mov    rcx,QWORD PTR [rsp+0x58]
  222dcf:	48 8b 54 24 60       	mov    rdx,QWORD PTR [rsp+0x60]
  222dd4:	48 89 44 11 d8       	mov    QWORD PTR [rcx+rdx*1-0x28],rax
                elf_section.offset = try in.readInt(elf.endian, u64);
  222dd9:	0f b6 94 24 82 01 00 	movzx  edx,BYTE PTR [rsp+0x182]
  222de0:	00 
  222de1:	48 8d bc 24 00 04 00 	lea    rdi,[rsp+0x400]
  222de8:	00 
  222de9:	48 8d 74 24 48       	lea    rsi,[rsp+0x48]
  222dee:	e8 0d 11 00 00       	call   223f00 <InStream(ReadError)_readInt.143>
  222df3:	0f b7 ac 24 00 04 00 	movzx  ebp,WORD PTR [rsp+0x400]
  222dfa:	00 
  222dfb:	66 85 ed             	test   bp,bp
  222dfe:	0f 85 14 0b 00 00    	jne    223918 <openSelfDebugInfoLinux+0x4988>
  222e04:	48 8b 84 24 08 04 00 	mov    rax,QWORD PTR [rsp+0x408]
  222e0b:	00 
  222e0c:	48 8b 4c 24 58       	mov    rcx,QWORD PTR [rsp+0x58]
  222e11:	48 8b 54 24 60       	mov    rdx,QWORD PTR [rsp+0x60]
  222e16:	48 89 44 11 e0       	mov    QWORD PTR [rcx+rdx*1-0x20],rax
                elf_section.size = try in.readInt(elf.endian, u64);
  222e1b:	0f b6 94 24 82 01 00 	movzx  edx,BYTE PTR [rsp+0x182]
  222e22:	00 
  222e23:	48 8d bc 24 70 02 00 	lea    rdi,[rsp+0x270]
  222e2a:	00 
  222e2b:	48 8d 74 24 48       	lea    rsi,[rsp+0x48]
  222e30:	e8 cb 10 00 00       	call   223f00 <InStream(ReadError)_readInt.143>
  222e35:	0f b7 ac 24 70 02 00 	movzx  ebp,WORD PTR [rsp+0x270]
  222e3c:	00 
  222e3d:	66 85 ed             	test   bp,bp
  222e40:	0f 85 28 0b 00 00    	jne    22396e <openSelfDebugInfoLinux+0x49de>
  222e46:	48 8b 84 24 78 02 00 	mov    rax,QWORD PTR [rsp+0x278]
  222e4d:	00 
  222e4e:	48 8b 4c 24 58       	mov    rcx,QWORD PTR [rsp+0x58]
  222e53:	48 8b 54 24 60       	mov    rdx,QWORD PTR [rsp+0x60]
  222e58:	48 89 44 11 e8       	mov    QWORD PTR [rcx+rdx*1-0x18],rax
                elf_section.link = try in.readInt(elf.endian, u32);
  222e5d:	0f b6 84 24 82 01 00 	movzx  eax,BYTE PTR [rsp+0x182]
  222e64:	00 
            try self.readNoEof(bytes[0..]);
  222e65:	88 44 24 38          	mov    BYTE PTR [rsp+0x38],al
  222e69:	48 8d 44 24 10       	lea    rax,[rsp+0x10]
  222e6e:	48 89 44 24 68       	mov    QWORD PTR [rsp+0x68],rax
  222e73:	48 c7 44 24 70 04 00 	mov    QWORD PTR [rsp+0x70],0x4
  222e7a:	00 00 
            return self.readFn(self, buffer);
  222e7c:	48 8d bc 24 c0 00 00 	lea    rdi,[rsp+0xc0]
  222e83:	00 
  222e84:	48 8d 74 24 48       	lea    rsi,[rsp+0x48]
  222e89:	48 8d 54 24 68       	lea    rdx,[rsp+0x68]
  222e8e:	ff 54 24 48          	call   QWORD PTR [rsp+0x48]
  222e92:	0f b7 ac 24 c0 00 00 	movzx  ebp,WORD PTR [rsp+0xc0]
  222e99:	00 
            const amt_read = try self.read(buf);
  222e9a:	66 85 ed             	test   bp,bp
  222e9d:	0f 85 06 0c 00 00    	jne    223aa9 <openSelfDebugInfoLinux+0x4b19>
  222ea3:	48 8b 84 24 c8 00 00 	mov    rax,QWORD PTR [rsp+0xc8]
  222eaa:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  222eab:	48 3b 44 24 70       	cmp    rax,QWORD PTR [rsp+0x70]
  222eb0:	0f 82 ef 0b 00 00    	jb     223aa5 <openSelfDebugInfoLinux+0x4b15>
  222eb6:	0f b6 44 24 10       	movzx  eax,BYTE PTR [rsp+0x10]
  222ebb:	0f b6 4c 24 11       	movzx  ecx,BYTE PTR [rsp+0x11]
    switch (endian) {
  222ec0:	f6 44 24 38 01       	test   BYTE PTR [rsp+0x38],0x1
  222ec5:	74 1b                	je     222ee2 <openSelfDebugInfoLinux+0x3f52>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  222ec7:	c1 e1 08             	shl    ecx,0x8
  222eca:	09 c1                	or     ecx,eax
  222ecc:	0f b6 54 24 12       	movzx  edx,BYTE PTR [rsp+0x12]
  222ed1:	c1 e2 10             	shl    edx,0x10
  222ed4:	09 ca                	or     edx,ecx
  222ed6:	0f b6 44 24 13       	movzx  eax,BYTE PTR [rsp+0x13]
  222edb:	c1 e0 18             	shl    eax,0x18
  222ede:	09 d0                	or     eax,edx
  222ee0:	eb 19                	jmp    222efb <openSelfDebugInfoLinux+0x3f6b>
                result = (result << 8) | b;
  222ee2:	c1 e0 08             	shl    eax,0x8
  222ee5:	09 c8                	or     eax,ecx
  222ee7:	c1 e0 08             	shl    eax,0x8
  222eea:	0f b6 4c 24 12       	movzx  ecx,BYTE PTR [rsp+0x12]
  222eef:	09 c1                	or     ecx,eax
  222ef1:	c1 e1 08             	shl    ecx,0x8
  222ef4:	0f b6 44 24 13       	movzx  eax,BYTE PTR [rsp+0x13]
  222ef9:	09 c8                	or     eax,ecx
  222efb:	48 8b 4c 24 58       	mov    rcx,QWORD PTR [rsp+0x58]
  222f00:	48 8b 54 24 60       	mov    rdx,QWORD PTR [rsp+0x60]
  222f05:	89 44 11 f0          	mov    DWORD PTR [rcx+rdx*1-0x10],eax
                elf_section.info = try in.readInt(elf.endian, u32);
  222f09:	0f b6 84 24 82 01 00 	movzx  eax,BYTE PTR [rsp+0x182]
  222f10:	00 
            try self.readNoEof(bytes[0..]);
  222f11:	88 44 24 38          	mov    BYTE PTR [rsp+0x38],al
  222f15:	48 8d 44 24 10       	lea    rax,[rsp+0x10]
  222f1a:	48 89 44 24 68       	mov    QWORD PTR [rsp+0x68],rax
  222f1f:	48 c7 44 24 70 04 00 	mov    QWORD PTR [rsp+0x70],0x4
  222f26:	00 00 
            return self.readFn(self, buffer);
  222f28:	48 8d bc 24 c0 00 00 	lea    rdi,[rsp+0xc0]
  222f2f:	00 
  222f30:	48 8d 74 24 48       	lea    rsi,[rsp+0x48]
  222f35:	48 8d 54 24 68       	lea    rdx,[rsp+0x68]
  222f3a:	ff 54 24 48          	call   QWORD PTR [rsp+0x48]
  222f3e:	0f b7 ac 24 c0 00 00 	movzx  ebp,WORD PTR [rsp+0xc0]
  222f45:	00 
            const amt_read = try self.read(buf);
  222f46:	66 85 ed             	test   bp,bp
  222f49:	0f 85 5a 0b 00 00    	jne    223aa9 <openSelfDebugInfoLinux+0x4b19>
  222f4f:	48 8b 84 24 c8 00 00 	mov    rax,QWORD PTR [rsp+0xc8]
  222f56:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  222f57:	48 3b 44 24 70       	cmp    rax,QWORD PTR [rsp+0x70]
  222f5c:	0f 82 43 0b 00 00    	jb     223aa5 <openSelfDebugInfoLinux+0x4b15>
  222f62:	0f b6 44 24 10       	movzx  eax,BYTE PTR [rsp+0x10]
  222f67:	0f b6 4c 24 11       	movzx  ecx,BYTE PTR [rsp+0x11]
    switch (endian) {
  222f6c:	f6 44 24 38 01       	test   BYTE PTR [rsp+0x38],0x1
  222f71:	74 1b                	je     222f8e <openSelfDebugInfoLinux+0x3ffe>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  222f73:	c1 e1 08             	shl    ecx,0x8
  222f76:	09 c1                	or     ecx,eax
  222f78:	0f b6 54 24 12       	movzx  edx,BYTE PTR [rsp+0x12]
  222f7d:	c1 e2 10             	shl    edx,0x10
  222f80:	09 ca                	or     edx,ecx
  222f82:	0f b6 44 24 13       	movzx  eax,BYTE PTR [rsp+0x13]
  222f87:	c1 e0 18             	shl    eax,0x18
  222f8a:	09 d0                	or     eax,edx
  222f8c:	eb 19                	jmp    222fa7 <openSelfDebugInfoLinux+0x4017>
                result = (result << 8) | b;
  222f8e:	c1 e0 08             	shl    eax,0x8
  222f91:	09 c8                	or     eax,ecx
  222f93:	c1 e0 08             	shl    eax,0x8
  222f96:	0f b6 4c 24 12       	movzx  ecx,BYTE PTR [rsp+0x12]
  222f9b:	09 c1                	or     ecx,eax
  222f9d:	c1 e1 08             	shl    ecx,0x8
  222fa0:	0f b6 44 24 13       	movzx  eax,BYTE PTR [rsp+0x13]
  222fa5:	09 c8                	or     eax,ecx
  222fa7:	48 8b 4c 24 58       	mov    rcx,QWORD PTR [rsp+0x58]
  222fac:	48 8b 54 24 60       	mov    rdx,QWORD PTR [rsp+0x60]
  222fb1:	89 44 11 f4          	mov    DWORD PTR [rcx+rdx*1-0xc],eax
                elf_section.addr_align = try in.readInt(elf.endian, u64);
  222fb5:	0f b6 94 24 82 01 00 	movzx  edx,BYTE PTR [rsp+0x182]
  222fbc:	00 
  222fbd:	48 8d bc 24 b0 02 00 	lea    rdi,[rsp+0x2b0]
  222fc4:	00 
  222fc5:	48 8d 74 24 48       	lea    rsi,[rsp+0x48]
  222fca:	e8 31 0f 00 00       	call   223f00 <InStream(ReadError)_readInt.143>
  222fcf:	0f b7 ac 24 b0 02 00 	movzx  ebp,WORD PTR [rsp+0x2b0]
  222fd6:	00 
  222fd7:	66 85 ed             	test   bp,bp
  222fda:	0f 85 e4 09 00 00    	jne    2239c4 <openSelfDebugInfoLinux+0x4a34>
  222fe0:	48 8b 84 24 b8 02 00 	mov    rax,QWORD PTR [rsp+0x2b8]
  222fe7:	00 
  222fe8:	48 8b 4c 24 58       	mov    rcx,QWORD PTR [rsp+0x58]
  222fed:	48 8b 54 24 60       	mov    rdx,QWORD PTR [rsp+0x60]
  222ff2:	48 89 44 11 f8       	mov    QWORD PTR [rcx+rdx*1-0x8],rax
                elf_section.ent_size = try in.readInt(elf.endian, u64);
  222ff7:	0f b6 94 24 82 01 00 	movzx  edx,BYTE PTR [rsp+0x182]
  222ffe:	00 
  222fff:	48 8d bc 24 e0 02 00 	lea    rdi,[rsp+0x2e0]
  223006:	00 
  223007:	48 8d 74 24 48       	lea    rsi,[rsp+0x48]
  22300c:	e8 ef 0e 00 00       	call   223f00 <InStream(ReadError)_readInt.143>
  223011:	0f b7 ac 24 e0 02 00 	movzx  ebp,WORD PTR [rsp+0x2e0]
  223018:	00 
  223019:	66 85 ed             	test   bp,bp
  22301c:	0f 85 f8 09 00 00    	jne    223a1a <openSelfDebugInfoLinux+0x4a8a>
  223022:	48 8b 84 24 e8 02 00 	mov    rax,QWORD PTR [rsp+0x2e8]
  223029:	00 
  22302a:	48 8b 4c 24 58       	mov    rcx,QWORD PTR [rsp+0x58]
  22302f:	48 8b 54 24 60       	mov    rdx,QWORD PTR [rsp+0x60]
  223034:	48 89 04 11          	mov    QWORD PTR [rcx+rdx*1],rax
  223038:	48 8b 84 24 b0 00 00 	mov    rax,QWORD PTR [rsp+0xb0]
  22303f:	00 
  223040:	48 89 c1             	mov    rcx,rax
            for (elf.section_headers) |*elf_section| {
  223043:	48 83 c1 01          	add    rcx,0x1
  223047:	48 89 c8             	mov    rax,rcx
  22304a:	48 89 84 24 b0 00 00 	mov    QWORD PTR [rsp+0xb0],rax
  223051:	00 
  223052:	48 3b 4c 24 30       	cmp    rcx,QWORD PTR [rsp+0x30]
  223057:	0f 83 73 0a 00 00    	jae    223ad0 <openSelfDebugInfoLinux+0x4b40>
  22305d:	48 83 44 24 60 40    	add    QWORD PTR [rsp+0x60],0x40
  223063:	48 8b 84 24 b0 01 00 	mov    rax,QWORD PTR [rsp+0x1b0]
  22306a:	00 
                elf_section.name = try in.readInt(elf.endian, u32);
  22306b:	48 89 44 24 58       	mov    QWORD PTR [rsp+0x58],rax
  223070:	0f b6 84 24 82 01 00 	movzx  eax,BYTE PTR [rsp+0x182]
  223077:	00 
            try self.readNoEof(bytes[0..]);
  223078:	88 44 24 38          	mov    BYTE PTR [rsp+0x38],al
  22307c:	48 8d 44 24 10       	lea    rax,[rsp+0x10]
  223081:	48 89 44 24 68       	mov    QWORD PTR [rsp+0x68],rax
  223086:	48 c7 44 24 70 04 00 	mov    QWORD PTR [rsp+0x70],0x4
  22308d:	00 00 
            return self.readFn(self, buffer);
  22308f:	48 8d bc 24 c0 00 00 	lea    rdi,[rsp+0xc0]
  223096:	00 
  223097:	48 8d 74 24 48       	lea    rsi,[rsp+0x48]
  22309c:	48 8d 54 24 68       	lea    rdx,[rsp+0x68]
  2230a1:	ff 54 24 48          	call   QWORD PTR [rsp+0x48]
  2230a5:	0f b7 ac 24 c0 00 00 	movzx  ebp,WORD PTR [rsp+0xc0]
  2230ac:	00 
  2230ad:	48 8b 84 24 c8 00 00 	mov    rax,QWORD PTR [rsp+0xc8]
  2230b4:	00 
            const amt_read = try self.read(buf);
  2230b5:	66 85 ed             	test   bp,bp
  2230b8:	0f 84 8d fb ff ff    	je     222c4b <openSelfDebugInfoLinux+0x3cbb>
  2230be:	e9 e6 09 00 00       	jmp    223aa9 <openSelfDebugInfoLinux+0x4b19>
  2230c3:	66 bd 03 00          	mov    bp,0x3
  2230c7:	48 83 f9 4b          	cmp    rcx,0x4b
  2230cb:	0f 85 93 c0 ff ff    	jne    21f164 <openSelfDebugInfoLinux+0x1d4>
  2230d1:	e9 82 c3 ff ff       	jmp    21f458 <openSelfDebugInfoLinux+0x4c8>
            @panic("assertion failure");
  2230d6:	48 8d 3d b3 cc 02 00 	lea    rdi,[rip+0x2ccb3]        # 24fd90 <__unnamed_2>
  2230dd:	c5 f8 77             	vzeroupper 
  2230e0:	e8 3b f6 fe ff       	call   212720 <panic>
  2230e5:	66 bd 04 00          	mov    bp,0x4
    try di.elf.openFile(allocator, &di.self_exe_file);
  2230e9:	66 85 ed             	test   bp,bp
  2230ec:	0f 85 7b c0 ff ff    	jne    21f16d <openSelfDebugInfoLinux+0x1dd>
  2230f2:	e9 4d c7 ff ff       	jmp    21f844 <openSelfDebugInfoLinux+0x8b4>
            if (sh_entry_size != 40) return error.InvalidFormat;
  2230f7:	83 bc 24 b0 00 00 00 	cmp    DWORD PTR [rsp+0xb0],0x28
  2230fe:	28 
  2230ff:	0f 85 6b 09 00 00    	jne    223a70 <openSelfDebugInfoLinux+0x4ae0>
                elf_section.name = try in.readInt(elf.endian, u32);
  223105:	8a 84 24 82 01 00 00 	mov    al,BYTE PTR [rsp+0x182]
            try self.readNoEof(bytes[0..]);
  22310c:	88 44 24 38          	mov    BYTE PTR [rsp+0x38],al
  223110:	48 8d 44 24 10       	lea    rax,[rsp+0x10]
  223115:	48 89 44 24 68       	mov    QWORD PTR [rsp+0x68],rax
  22311a:	48 c7 44 24 70 04 00 	mov    QWORD PTR [rsp+0x70],0x4
  223121:	00 00 
  223123:	48 8d bc 24 c0 00 00 	lea    rdi,[rsp+0xc0]
  22312a:	00 
  22312b:	48 8d 54 24 68       	lea    rdx,[rsp+0x68]
            return self.readFn(self, buffer);
  223130:	48 8d 74 24 48       	lea    rsi,[rsp+0x48]
  223135:	ff 54 24 48          	call   QWORD PTR [rsp+0x48]
  223139:	0f b7 ac 24 c0 00 00 	movzx  ebp,WORD PTR [rsp+0xc0]
  223140:	00 
            const amt_read = try self.read(buf);
  223141:	66 85 ed             	test   bp,bp
  223144:	0f 85 5f 09 00 00    	jne    223aa9 <openSelfDebugInfoLinux+0x4b19>
  22314a:	48 8b 84 24 c8 00 00 	mov    rax,QWORD PTR [rsp+0xc8]
  223151:	00 
  223152:	31 c9                	xor    ecx,ecx
  223154:	48 89 8c 24 b0 00 00 	mov    QWORD PTR [rsp+0xb0],rcx
  22315b:	00 
  22315c:	b9 38 00 00 00       	mov    ecx,0x38
  223161:	48 89 4c 24 60       	mov    QWORD PTR [rsp+0x60],rcx
            if (amt_read < buf.len) return error.EndOfStream;
  223166:	48 3b 44 24 70       	cmp    rax,QWORD PTR [rsp+0x70]
  22316b:	0f 82 34 09 00 00    	jb     223aa5 <openSelfDebugInfoLinux+0x4b15>
  223171:	0f b6 44 24 10       	movzx  eax,BYTE PTR [rsp+0x10]
  223176:	0f b6 4c 24 11       	movzx  ecx,BYTE PTR [rsp+0x11]
    switch (endian) {
  22317b:	f6 44 24 38 01       	test   BYTE PTR [rsp+0x38],0x1
  223180:	74 1b                	je     22319d <openSelfDebugInfoLinux+0x420d>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  223182:	c1 e1 08             	shl    ecx,0x8
  223185:	09 c1                	or     ecx,eax
  223187:	0f b6 54 24 12       	movzx  edx,BYTE PTR [rsp+0x12]
  22318c:	c1 e2 10             	shl    edx,0x10
  22318f:	09 ca                	or     edx,ecx
  223191:	0f b6 44 24 13       	movzx  eax,BYTE PTR [rsp+0x13]
  223196:	c1 e0 18             	shl    eax,0x18
  223199:	09 d0                	or     eax,edx
  22319b:	eb 19                	jmp    2231b6 <openSelfDebugInfoLinux+0x4226>
                result = (result << 8) | b;
  22319d:	c1 e0 08             	shl    eax,0x8
  2231a0:	09 c8                	or     eax,ecx
  2231a2:	c1 e0 08             	shl    eax,0x8
  2231a5:	0f b6 4c 24 12       	movzx  ecx,BYTE PTR [rsp+0x12]
  2231aa:	09 c1                	or     ecx,eax
  2231ac:	c1 e1 08             	shl    ecx,0x8
  2231af:	0f b6 44 24 13       	movzx  eax,BYTE PTR [rsp+0x13]
  2231b4:	09 c8                	or     eax,ecx
  2231b6:	48 8b 4c 24 58       	mov    rcx,QWORD PTR [rsp+0x58]
  2231bb:	48 8b 54 24 60       	mov    rdx,QWORD PTR [rsp+0x60]
  2231c0:	89 44 11 c8          	mov    DWORD PTR [rcx+rdx*1-0x38],eax
                elf_section.sh_type = try in.readInt(elf.endian, u32);
  2231c4:	0f b6 84 24 82 01 00 	movzx  eax,BYTE PTR [rsp+0x182]
  2231cb:	00 
            try self.readNoEof(bytes[0..]);
  2231cc:	88 44 24 38          	mov    BYTE PTR [rsp+0x38],al
  2231d0:	48 8d 44 24 10       	lea    rax,[rsp+0x10]
  2231d5:	48 89 44 24 68       	mov    QWORD PTR [rsp+0x68],rax
  2231da:	48 c7 44 24 70 04 00 	mov    QWORD PTR [rsp+0x70],0x4
  2231e1:	00 00 
            return self.readFn(self, buffer);
  2231e3:	48 8d bc 24 c0 00 00 	lea    rdi,[rsp+0xc0]
  2231ea:	00 
  2231eb:	48 8d 74 24 48       	lea    rsi,[rsp+0x48]
  2231f0:	48 8d 54 24 68       	lea    rdx,[rsp+0x68]
  2231f5:	ff 54 24 48          	call   QWORD PTR [rsp+0x48]
  2231f9:	0f b7 ac 24 c0 00 00 	movzx  ebp,WORD PTR [rsp+0xc0]
  223200:	00 
            const amt_read = try self.read(buf);
  223201:	66 85 ed             	test   bp,bp
  223204:	0f 85 9f 08 00 00    	jne    223aa9 <openSelfDebugInfoLinux+0x4b19>
  22320a:	48 8b 84 24 c8 00 00 	mov    rax,QWORD PTR [rsp+0xc8]
  223211:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  223212:	48 3b 44 24 70       	cmp    rax,QWORD PTR [rsp+0x70]
  223217:	0f 82 88 08 00 00    	jb     223aa5 <openSelfDebugInfoLinux+0x4b15>
  22321d:	0f b6 44 24 10       	movzx  eax,BYTE PTR [rsp+0x10]
  223222:	0f b6 4c 24 11       	movzx  ecx,BYTE PTR [rsp+0x11]
    switch (endian) {
  223227:	f6 44 24 38 01       	test   BYTE PTR [rsp+0x38],0x1
  22322c:	74 1b                	je     223249 <openSelfDebugInfoLinux+0x42b9>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  22322e:	c1 e1 08             	shl    ecx,0x8
  223231:	09 c1                	or     ecx,eax
  223233:	0f b6 54 24 12       	movzx  edx,BYTE PTR [rsp+0x12]
  223238:	c1 e2 10             	shl    edx,0x10
  22323b:	09 ca                	or     edx,ecx
  22323d:	0f b6 44 24 13       	movzx  eax,BYTE PTR [rsp+0x13]
  223242:	c1 e0 18             	shl    eax,0x18
  223245:	09 d0                	or     eax,edx
  223247:	eb 19                	jmp    223262 <openSelfDebugInfoLinux+0x42d2>
                result = (result << 8) | b;
  223249:	c1 e0 08             	shl    eax,0x8
  22324c:	09 c8                	or     eax,ecx
  22324e:	c1 e0 08             	shl    eax,0x8
  223251:	0f b6 4c 24 12       	movzx  ecx,BYTE PTR [rsp+0x12]
  223256:	09 c1                	or     ecx,eax
  223258:	c1 e1 08             	shl    ecx,0x8
  22325b:	0f b6 44 24 13       	movzx  eax,BYTE PTR [rsp+0x13]
  223260:	09 c8                	or     eax,ecx
  223262:	48 8b 4c 24 58       	mov    rcx,QWORD PTR [rsp+0x58]
  223267:	48 8b 54 24 60       	mov    rdx,QWORD PTR [rsp+0x60]
  22326c:	89 44 11 cc          	mov    DWORD PTR [rcx+rdx*1-0x34],eax
                elf_section.flags = u64(try in.readInt(elf.endian, u32));
  223270:	0f b6 84 24 82 01 00 	movzx  eax,BYTE PTR [rsp+0x182]
  223277:	00 
            try self.readNoEof(bytes[0..]);
  223278:	88 44 24 38          	mov    BYTE PTR [rsp+0x38],al
  22327c:	48 8d 44 24 10       	lea    rax,[rsp+0x10]
  223281:	48 89 44 24 68       	mov    QWORD PTR [rsp+0x68],rax
  223286:	48 c7 44 24 70 04 00 	mov    QWORD PTR [rsp+0x70],0x4
  22328d:	00 00 
            return self.readFn(self, buffer);
  22328f:	48 8d bc 24 c0 00 00 	lea    rdi,[rsp+0xc0]
  223296:	00 
  223297:	48 8d 74 24 48       	lea    rsi,[rsp+0x48]
  22329c:	48 8d 54 24 68       	lea    rdx,[rsp+0x68]
  2232a1:	ff 54 24 48          	call   QWORD PTR [rsp+0x48]
  2232a5:	0f b7 ac 24 c0 00 00 	movzx  ebp,WORD PTR [rsp+0xc0]
  2232ac:	00 
            const amt_read = try self.read(buf);
  2232ad:	66 85 ed             	test   bp,bp
  2232b0:	0f 85 f3 07 00 00    	jne    223aa9 <openSelfDebugInfoLinux+0x4b19>
  2232b6:	48 8b 84 24 c8 00 00 	mov    rax,QWORD PTR [rsp+0xc8]
  2232bd:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  2232be:	48 3b 44 24 70       	cmp    rax,QWORD PTR [rsp+0x70]
  2232c3:	0f 82 dc 07 00 00    	jb     223aa5 <openSelfDebugInfoLinux+0x4b15>
  2232c9:	0f b6 44 24 10       	movzx  eax,BYTE PTR [rsp+0x10]
  2232ce:	0f b6 4c 24 11       	movzx  ecx,BYTE PTR [rsp+0x11]
    switch (endian) {
  2232d3:	f6 44 24 38 01       	test   BYTE PTR [rsp+0x38],0x1
  2232d8:	74 1b                	je     2232f5 <openSelfDebugInfoLinux+0x4365>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  2232da:	c1 e1 08             	shl    ecx,0x8
  2232dd:	09 c1                	or     ecx,eax
  2232df:	0f b6 54 24 12       	movzx  edx,BYTE PTR [rsp+0x12]
  2232e4:	c1 e2 10             	shl    edx,0x10
  2232e7:	09 ca                	or     edx,ecx
  2232e9:	0f b6 44 24 13       	movzx  eax,BYTE PTR [rsp+0x13]
  2232ee:	c1 e0 18             	shl    eax,0x18
  2232f1:	09 d0                	or     eax,edx
  2232f3:	eb 19                	jmp    22330e <openSelfDebugInfoLinux+0x437e>
                result = (result << 8) | b;
  2232f5:	c1 e0 08             	shl    eax,0x8
  2232f8:	09 c8                	or     eax,ecx
  2232fa:	c1 e0 08             	shl    eax,0x8
  2232fd:	0f b6 4c 24 12       	movzx  ecx,BYTE PTR [rsp+0x12]
  223302:	09 c1                	or     ecx,eax
  223304:	c1 e1 08             	shl    ecx,0x8
  223307:	0f b6 44 24 13       	movzx  eax,BYTE PTR [rsp+0x13]
  22330c:	09 c8                	or     eax,ecx
  22330e:	89 c0                	mov    eax,eax
  223310:	48 8b 4c 24 58       	mov    rcx,QWORD PTR [rsp+0x58]
  223315:	48 8b 54 24 60       	mov    rdx,QWORD PTR [rsp+0x60]
  22331a:	48 89 44 11 d0       	mov    QWORD PTR [rcx+rdx*1-0x30],rax
                elf_section.addr = u64(try in.readInt(elf.endian, u32));
  22331f:	0f b6 84 24 82 01 00 	movzx  eax,BYTE PTR [rsp+0x182]
  223326:	00 
            try self.readNoEof(bytes[0..]);
  223327:	88 44 24 38          	mov    BYTE PTR [rsp+0x38],al
  22332b:	48 8d 44 24 10       	lea    rax,[rsp+0x10]
  223330:	48 89 44 24 68       	mov    QWORD PTR [rsp+0x68],rax
  223335:	48 c7 44 24 70 04 00 	mov    QWORD PTR [rsp+0x70],0x4
  22333c:	00 00 
            return self.readFn(self, buffer);
  22333e:	48 8d bc 24 c0 00 00 	lea    rdi,[rsp+0xc0]
  223345:	00 
  223346:	48 8d 74 24 48       	lea    rsi,[rsp+0x48]
  22334b:	48 8d 54 24 68       	lea    rdx,[rsp+0x68]
  223350:	ff 54 24 48          	call   QWORD PTR [rsp+0x48]
  223354:	0f b7 ac 24 c0 00 00 	movzx  ebp,WORD PTR [rsp+0xc0]
  22335b:	00 
            const amt_read = try self.read(buf);
  22335c:	66 85 ed             	test   bp,bp
  22335f:	0f 85 44 07 00 00    	jne    223aa9 <openSelfDebugInfoLinux+0x4b19>
  223365:	48 8b 84 24 c8 00 00 	mov    rax,QWORD PTR [rsp+0xc8]
  22336c:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  22336d:	48 3b 44 24 70       	cmp    rax,QWORD PTR [rsp+0x70]
  223372:	0f 82 2d 07 00 00    	jb     223aa5 <openSelfDebugInfoLinux+0x4b15>
  223378:	0f b6 44 24 10       	movzx  eax,BYTE PTR [rsp+0x10]
  22337d:	0f b6 4c 24 11       	movzx  ecx,BYTE PTR [rsp+0x11]
    switch (endian) {
  223382:	f6 44 24 38 01       	test   BYTE PTR [rsp+0x38],0x1
  223387:	74 1b                	je     2233a4 <openSelfDebugInfoLinux+0x4414>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  223389:	c1 e1 08             	shl    ecx,0x8
  22338c:	09 c1                	or     ecx,eax
  22338e:	0f b6 54 24 12       	movzx  edx,BYTE PTR [rsp+0x12]
  223393:	c1 e2 10             	shl    edx,0x10
  223396:	09 ca                	or     edx,ecx
  223398:	0f b6 44 24 13       	movzx  eax,BYTE PTR [rsp+0x13]
  22339d:	c1 e0 18             	shl    eax,0x18
  2233a0:	09 d0                	or     eax,edx
  2233a2:	eb 19                	jmp    2233bd <openSelfDebugInfoLinux+0x442d>
                result = (result << 8) | b;
  2233a4:	c1 e0 08             	shl    eax,0x8
  2233a7:	09 c8                	or     eax,ecx
  2233a9:	c1 e0 08             	shl    eax,0x8
  2233ac:	0f b6 4c 24 12       	movzx  ecx,BYTE PTR [rsp+0x12]
  2233b1:	09 c1                	or     ecx,eax
  2233b3:	c1 e1 08             	shl    ecx,0x8
  2233b6:	0f b6 44 24 13       	movzx  eax,BYTE PTR [rsp+0x13]
  2233bb:	09 c8                	or     eax,ecx
  2233bd:	89 c0                	mov    eax,eax
  2233bf:	48 8b 4c 24 58       	mov    rcx,QWORD PTR [rsp+0x58]
  2233c4:	48 8b 54 24 60       	mov    rdx,QWORD PTR [rsp+0x60]
  2233c9:	48 89 44 11 d8       	mov    QWORD PTR [rcx+rdx*1-0x28],rax
                elf_section.offset = u64(try in.readInt(elf.endian, u32));
  2233ce:	0f b6 84 24 82 01 00 	movzx  eax,BYTE PTR [rsp+0x182]
  2233d5:	00 
            try self.readNoEof(bytes[0..]);
  2233d6:	88 44 24 38          	mov    BYTE PTR [rsp+0x38],al
  2233da:	48 8d 44 24 10       	lea    rax,[rsp+0x10]
  2233df:	48 89 44 24 68       	mov    QWORD PTR [rsp+0x68],rax
  2233e4:	48 c7 44 24 70 04 00 	mov    QWORD PTR [rsp+0x70],0x4
  2233eb:	00 00 
            return self.readFn(self, buffer);
  2233ed:	48 8d bc 24 c0 00 00 	lea    rdi,[rsp+0xc0]
  2233f4:	00 
  2233f5:	48 8d 74 24 48       	lea    rsi,[rsp+0x48]
  2233fa:	48 8d 54 24 68       	lea    rdx,[rsp+0x68]
  2233ff:	ff 54 24 48          	call   QWORD PTR [rsp+0x48]
  223403:	0f b7 ac 24 c0 00 00 	movzx  ebp,WORD PTR [rsp+0xc0]
  22340a:	00 
            const amt_read = try self.read(buf);
  22340b:	66 85 ed             	test   bp,bp
  22340e:	0f 85 95 06 00 00    	jne    223aa9 <openSelfDebugInfoLinux+0x4b19>
  223414:	48 8b 84 24 c8 00 00 	mov    rax,QWORD PTR [rsp+0xc8]
  22341b:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  22341c:	48 3b 44 24 70       	cmp    rax,QWORD PTR [rsp+0x70]
  223421:	0f 82 7e 06 00 00    	jb     223aa5 <openSelfDebugInfoLinux+0x4b15>
  223427:	0f b6 44 24 10       	movzx  eax,BYTE PTR [rsp+0x10]
  22342c:	0f b6 4c 24 11       	movzx  ecx,BYTE PTR [rsp+0x11]
    switch (endian) {
  223431:	f6 44 24 38 01       	test   BYTE PTR [rsp+0x38],0x1
  223436:	74 1b                	je     223453 <openSelfDebugInfoLinux+0x44c3>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  223438:	c1 e1 08             	shl    ecx,0x8
  22343b:	09 c1                	or     ecx,eax
  22343d:	0f b6 54 24 12       	movzx  edx,BYTE PTR [rsp+0x12]
  223442:	c1 e2 10             	shl    edx,0x10
  223445:	09 ca                	or     edx,ecx
  223447:	0f b6 44 24 13       	movzx  eax,BYTE PTR [rsp+0x13]
  22344c:	c1 e0 18             	shl    eax,0x18
  22344f:	09 d0                	or     eax,edx
  223451:	eb 19                	jmp    22346c <openSelfDebugInfoLinux+0x44dc>
                result = (result << 8) | b;
  223453:	c1 e0 08             	shl    eax,0x8
  223456:	09 c8                	or     eax,ecx
  223458:	c1 e0 08             	shl    eax,0x8
  22345b:	0f b6 4c 24 12       	movzx  ecx,BYTE PTR [rsp+0x12]
  223460:	09 c1                	or     ecx,eax
  223462:	c1 e1 08             	shl    ecx,0x8
  223465:	0f b6 44 24 13       	movzx  eax,BYTE PTR [rsp+0x13]
  22346a:	09 c8                	or     eax,ecx
  22346c:	89 c0                	mov    eax,eax
  22346e:	48 8b 4c 24 58       	mov    rcx,QWORD PTR [rsp+0x58]
  223473:	48 8b 54 24 60       	mov    rdx,QWORD PTR [rsp+0x60]
  223478:	48 89 44 11 e0       	mov    QWORD PTR [rcx+rdx*1-0x20],rax
                elf_section.size = u64(try in.readInt(elf.endian, u32));
  22347d:	0f b6 84 24 82 01 00 	movzx  eax,BYTE PTR [rsp+0x182]
  223484:	00 
            try self.readNoEof(bytes[0..]);
  223485:	88 44 24 38          	mov    BYTE PTR [rsp+0x38],al
  223489:	48 8d 44 24 10       	lea    rax,[rsp+0x10]
  22348e:	48 89 44 24 68       	mov    QWORD PTR [rsp+0x68],rax
  223493:	48 c7 44 24 70 04 00 	mov    QWORD PTR [rsp+0x70],0x4
  22349a:	00 00 
            return self.readFn(self, buffer);
  22349c:	48 8d bc 24 c0 00 00 	lea    rdi,[rsp+0xc0]
  2234a3:	00 
  2234a4:	48 8d 74 24 48       	lea    rsi,[rsp+0x48]
  2234a9:	48 8d 54 24 68       	lea    rdx,[rsp+0x68]
  2234ae:	ff 54 24 48          	call   QWORD PTR [rsp+0x48]
  2234b2:	0f b7 ac 24 c0 00 00 	movzx  ebp,WORD PTR [rsp+0xc0]
  2234b9:	00 
            const amt_read = try self.read(buf);
  2234ba:	66 85 ed             	test   bp,bp
  2234bd:	0f 85 e6 05 00 00    	jne    223aa9 <openSelfDebugInfoLinux+0x4b19>
  2234c3:	48 8b 84 24 c8 00 00 	mov    rax,QWORD PTR [rsp+0xc8]
  2234ca:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  2234cb:	48 3b 44 24 70       	cmp    rax,QWORD PTR [rsp+0x70]
  2234d0:	0f 82 cf 05 00 00    	jb     223aa5 <openSelfDebugInfoLinux+0x4b15>
  2234d6:	0f b6 44 24 10       	movzx  eax,BYTE PTR [rsp+0x10]
  2234db:	0f b6 4c 24 11       	movzx  ecx,BYTE PTR [rsp+0x11]
    switch (endian) {
  2234e0:	f6 44 24 38 01       	test   BYTE PTR [rsp+0x38],0x1
  2234e5:	74 1b                	je     223502 <openSelfDebugInfoLinux+0x4572>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  2234e7:	c1 e1 08             	shl    ecx,0x8
  2234ea:	09 c1                	or     ecx,eax
  2234ec:	0f b6 54 24 12       	movzx  edx,BYTE PTR [rsp+0x12]
  2234f1:	c1 e2 10             	shl    edx,0x10
  2234f4:	09 ca                	or     edx,ecx
  2234f6:	0f b6 44 24 13       	movzx  eax,BYTE PTR [rsp+0x13]
  2234fb:	c1 e0 18             	shl    eax,0x18
  2234fe:	09 d0                	or     eax,edx
  223500:	eb 19                	jmp    22351b <openSelfDebugInfoLinux+0x458b>
                result = (result << 8) | b;
  223502:	c1 e0 08             	shl    eax,0x8
  223505:	09 c8                	or     eax,ecx
  223507:	c1 e0 08             	shl    eax,0x8
  22350a:	0f b6 4c 24 12       	movzx  ecx,BYTE PTR [rsp+0x12]
  22350f:	09 c1                	or     ecx,eax
  223511:	c1 e1 08             	shl    ecx,0x8
  223514:	0f b6 44 24 13       	movzx  eax,BYTE PTR [rsp+0x13]
  223519:	09 c8                	or     eax,ecx
  22351b:	89 c0                	mov    eax,eax
  22351d:	48 8b 4c 24 58       	mov    rcx,QWORD PTR [rsp+0x58]
  223522:	48 8b 54 24 60       	mov    rdx,QWORD PTR [rsp+0x60]
  223527:	48 89 44 11 e8       	mov    QWORD PTR [rcx+rdx*1-0x18],rax
                elf_section.link = try in.readInt(elf.endian, u32);
  22352c:	0f b6 84 24 82 01 00 	movzx  eax,BYTE PTR [rsp+0x182]
  223533:	00 
            try self.readNoEof(bytes[0..]);
  223534:	88 44 24 38          	mov    BYTE PTR [rsp+0x38],al
  223538:	48 8d 44 24 10       	lea    rax,[rsp+0x10]
  22353d:	48 89 44 24 68       	mov    QWORD PTR [rsp+0x68],rax
  223542:	48 c7 44 24 70 04 00 	mov    QWORD PTR [rsp+0x70],0x4
  223549:	00 00 
            return self.readFn(self, buffer);
  22354b:	48 8d bc 24 c0 00 00 	lea    rdi,[rsp+0xc0]
  223552:	00 
  223553:	48 8d 74 24 48       	lea    rsi,[rsp+0x48]
  223558:	48 8d 54 24 68       	lea    rdx,[rsp+0x68]
  22355d:	ff 54 24 48          	call   QWORD PTR [rsp+0x48]
  223561:	0f b7 ac 24 c0 00 00 	movzx  ebp,WORD PTR [rsp+0xc0]
  223568:	00 
            const amt_read = try self.read(buf);
  223569:	66 85 ed             	test   bp,bp
  22356c:	0f 85 37 05 00 00    	jne    223aa9 <openSelfDebugInfoLinux+0x4b19>
  223572:	48 8b 84 24 c8 00 00 	mov    rax,QWORD PTR [rsp+0xc8]
  223579:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  22357a:	48 3b 44 24 70       	cmp    rax,QWORD PTR [rsp+0x70]
  22357f:	0f 82 20 05 00 00    	jb     223aa5 <openSelfDebugInfoLinux+0x4b15>
  223585:	0f b6 44 24 10       	movzx  eax,BYTE PTR [rsp+0x10]
  22358a:	0f b6 4c 24 11       	movzx  ecx,BYTE PTR [rsp+0x11]
    switch (endian) {
  22358f:	f6 44 24 38 01       	test   BYTE PTR [rsp+0x38],0x1
  223594:	74 1b                	je     2235b1 <openSelfDebugInfoLinux+0x4621>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  223596:	c1 e1 08             	shl    ecx,0x8
  223599:	09 c1                	or     ecx,eax
  22359b:	0f b6 54 24 12       	movzx  edx,BYTE PTR [rsp+0x12]
  2235a0:	c1 e2 10             	shl    edx,0x10
  2235a3:	09 ca                	or     edx,ecx
  2235a5:	0f b6 44 24 13       	movzx  eax,BYTE PTR [rsp+0x13]
  2235aa:	c1 e0 18             	shl    eax,0x18
  2235ad:	09 d0                	or     eax,edx
  2235af:	eb 19                	jmp    2235ca <openSelfDebugInfoLinux+0x463a>
                result = (result << 8) | b;
  2235b1:	c1 e0 08             	shl    eax,0x8
  2235b4:	09 c8                	or     eax,ecx
  2235b6:	c1 e0 08             	shl    eax,0x8
  2235b9:	0f b6 4c 24 12       	movzx  ecx,BYTE PTR [rsp+0x12]
  2235be:	09 c1                	or     ecx,eax
  2235c0:	c1 e1 08             	shl    ecx,0x8
  2235c3:	0f b6 44 24 13       	movzx  eax,BYTE PTR [rsp+0x13]
  2235c8:	09 c8                	or     eax,ecx
  2235ca:	48 8b 4c 24 58       	mov    rcx,QWORD PTR [rsp+0x58]
  2235cf:	48 8b 54 24 60       	mov    rdx,QWORD PTR [rsp+0x60]
  2235d4:	89 44 11 f0          	mov    DWORD PTR [rcx+rdx*1-0x10],eax
                elf_section.info = try in.readInt(elf.endian, u32);
  2235d8:	0f b6 84 24 82 01 00 	movzx  eax,BYTE PTR [rsp+0x182]
  2235df:	00 
            try self.readNoEof(bytes[0..]);
  2235e0:	88 44 24 38          	mov    BYTE PTR [rsp+0x38],al
  2235e4:	48 8d 44 24 10       	lea    rax,[rsp+0x10]
  2235e9:	48 89 44 24 68       	mov    QWORD PTR [rsp+0x68],rax
  2235ee:	48 c7 44 24 70 04 00 	mov    QWORD PTR [rsp+0x70],0x4
  2235f5:	00 00 
            return self.readFn(self, buffer);
  2235f7:	48 8d bc 24 c0 00 00 	lea    rdi,[rsp+0xc0]
  2235fe:	00 
  2235ff:	48 8d 74 24 48       	lea    rsi,[rsp+0x48]
  223604:	48 8d 54 24 68       	lea    rdx,[rsp+0x68]
  223609:	ff 54 24 48          	call   QWORD PTR [rsp+0x48]
  22360d:	0f b7 ac 24 c0 00 00 	movzx  ebp,WORD PTR [rsp+0xc0]
  223614:	00 
            const amt_read = try self.read(buf);
  223615:	66 85 ed             	test   bp,bp
  223618:	0f 85 8b 04 00 00    	jne    223aa9 <openSelfDebugInfoLinux+0x4b19>
  22361e:	48 8b 84 24 c8 00 00 	mov    rax,QWORD PTR [rsp+0xc8]
  223625:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  223626:	48 3b 44 24 70       	cmp    rax,QWORD PTR [rsp+0x70]
  22362b:	0f 82 74 04 00 00    	jb     223aa5 <openSelfDebugInfoLinux+0x4b15>
  223631:	0f b6 44 24 10       	movzx  eax,BYTE PTR [rsp+0x10]
  223636:	0f b6 4c 24 11       	movzx  ecx,BYTE PTR [rsp+0x11]
    switch (endian) {
  22363b:	f6 44 24 38 01       	test   BYTE PTR [rsp+0x38],0x1
  223640:	74 1b                	je     22365d <openSelfDebugInfoLinux+0x46cd>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  223642:	c1 e1 08             	shl    ecx,0x8
  223645:	09 c1                	or     ecx,eax
  223647:	0f b6 54 24 12       	movzx  edx,BYTE PTR [rsp+0x12]
  22364c:	c1 e2 10             	shl    edx,0x10
  22364f:	09 ca                	or     edx,ecx
  223651:	0f b6 44 24 13       	movzx  eax,BYTE PTR [rsp+0x13]
  223656:	c1 e0 18             	shl    eax,0x18
  223659:	09 d0                	or     eax,edx
  22365b:	eb 19                	jmp    223676 <openSelfDebugInfoLinux+0x46e6>
                result = (result << 8) | b;
  22365d:	c1 e0 08             	shl    eax,0x8
  223660:	09 c8                	or     eax,ecx
  223662:	c1 e0 08             	shl    eax,0x8
  223665:	0f b6 4c 24 12       	movzx  ecx,BYTE PTR [rsp+0x12]
  22366a:	09 c1                	or     ecx,eax
  22366c:	c1 e1 08             	shl    ecx,0x8
  22366f:	0f b6 44 24 13       	movzx  eax,BYTE PTR [rsp+0x13]
  223674:	09 c8                	or     eax,ecx
  223676:	48 8b 4c 24 58       	mov    rcx,QWORD PTR [rsp+0x58]
  22367b:	48 8b 54 24 60       	mov    rdx,QWORD PTR [rsp+0x60]
  223680:	89 44 11 f4          	mov    DWORD PTR [rcx+rdx*1-0xc],eax
                elf_section.addr_align = u64(try in.readInt(elf.endian, u32));
  223684:	0f b6 84 24 82 01 00 	movzx  eax,BYTE PTR [rsp+0x182]
  22368b:	00 
            try self.readNoEof(bytes[0..]);
  22368c:	88 44 24 38          	mov    BYTE PTR [rsp+0x38],al
  223690:	48 8d 44 24 10       	lea    rax,[rsp+0x10]
  223695:	48 89 44 24 68       	mov    QWORD PTR [rsp+0x68],rax
  22369a:	48 c7 44 24 70 04 00 	mov    QWORD PTR [rsp+0x70],0x4
  2236a1:	00 00 
            return self.readFn(self, buffer);
  2236a3:	48 8d bc 24 c0 00 00 	lea    rdi,[rsp+0xc0]
  2236aa:	00 
  2236ab:	48 8d 74 24 48       	lea    rsi,[rsp+0x48]
  2236b0:	48 8d 54 24 68       	lea    rdx,[rsp+0x68]
  2236b5:	ff 54 24 48          	call   QWORD PTR [rsp+0x48]
  2236b9:	0f b7 ac 24 c0 00 00 	movzx  ebp,WORD PTR [rsp+0xc0]
  2236c0:	00 
            const amt_read = try self.read(buf);
  2236c1:	66 85 ed             	test   bp,bp
  2236c4:	0f 85 df 03 00 00    	jne    223aa9 <openSelfDebugInfoLinux+0x4b19>
  2236ca:	48 8b 84 24 c8 00 00 	mov    rax,QWORD PTR [rsp+0xc8]
  2236d1:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  2236d2:	48 3b 44 24 70       	cmp    rax,QWORD PTR [rsp+0x70]
  2236d7:	0f 82 c8 03 00 00    	jb     223aa5 <openSelfDebugInfoLinux+0x4b15>
  2236dd:	0f b6 44 24 10       	movzx  eax,BYTE PTR [rsp+0x10]
  2236e2:	0f b6 4c 24 11       	movzx  ecx,BYTE PTR [rsp+0x11]
    switch (endian) {
  2236e7:	f6 44 24 38 01       	test   BYTE PTR [rsp+0x38],0x1
  2236ec:	74 1b                	je     223709 <openSelfDebugInfoLinux+0x4779>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  2236ee:	c1 e1 08             	shl    ecx,0x8
  2236f1:	09 c1                	or     ecx,eax
  2236f3:	0f b6 54 24 12       	movzx  edx,BYTE PTR [rsp+0x12]
  2236f8:	c1 e2 10             	shl    edx,0x10
  2236fb:	09 ca                	or     edx,ecx
  2236fd:	0f b6 44 24 13       	movzx  eax,BYTE PTR [rsp+0x13]
  223702:	c1 e0 18             	shl    eax,0x18
  223705:	09 d0                	or     eax,edx
  223707:	eb 19                	jmp    223722 <openSelfDebugInfoLinux+0x4792>
                result = (result << 8) | b;
  223709:	c1 e0 08             	shl    eax,0x8
  22370c:	09 c8                	or     eax,ecx
  22370e:	c1 e0 08             	shl    eax,0x8
  223711:	0f b6 4c 24 12       	movzx  ecx,BYTE PTR [rsp+0x12]
  223716:	09 c1                	or     ecx,eax
  223718:	c1 e1 08             	shl    ecx,0x8
  22371b:	0f b6 44 24 13       	movzx  eax,BYTE PTR [rsp+0x13]
  223720:	09 c8                	or     eax,ecx
  223722:	89 c0                	mov    eax,eax
  223724:	48 8b 4c 24 58       	mov    rcx,QWORD PTR [rsp+0x58]
  223729:	48 8b 54 24 60       	mov    rdx,QWORD PTR [rsp+0x60]
  22372e:	48 89 44 11 f8       	mov    QWORD PTR [rcx+rdx*1-0x8],rax
                elf_section.ent_size = u64(try in.readInt(elf.endian, u32));
  223733:	0f b6 84 24 82 01 00 	movzx  eax,BYTE PTR [rsp+0x182]
  22373a:	00 
            try self.readNoEof(bytes[0..]);
  22373b:	88 44 24 38          	mov    BYTE PTR [rsp+0x38],al
  22373f:	48 8d 44 24 10       	lea    rax,[rsp+0x10]
  223744:	48 89 44 24 68       	mov    QWORD PTR [rsp+0x68],rax
  223749:	48 c7 44 24 70 04 00 	mov    QWORD PTR [rsp+0x70],0x4
  223750:	00 00 
            return self.readFn(self, buffer);
  223752:	48 8d bc 24 c0 00 00 	lea    rdi,[rsp+0xc0]
  223759:	00 
  22375a:	48 8d 74 24 48       	lea    rsi,[rsp+0x48]
  22375f:	48 8d 54 24 68       	lea    rdx,[rsp+0x68]
  223764:	ff 54 24 48          	call   QWORD PTR [rsp+0x48]
  223768:	0f b7 ac 24 c0 00 00 	movzx  ebp,WORD PTR [rsp+0xc0]
  22376f:	00 
            const amt_read = try self.read(buf);
  223770:	66 85 ed             	test   bp,bp
  223773:	0f 85 30 03 00 00    	jne    223aa9 <openSelfDebugInfoLinux+0x4b19>
  223779:	48 8b 84 24 c8 00 00 	mov    rax,QWORD PTR [rsp+0xc8]
  223780:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  223781:	48 3b 44 24 70       	cmp    rax,QWORD PTR [rsp+0x70]
  223786:	0f 82 19 03 00 00    	jb     223aa5 <openSelfDebugInfoLinux+0x4b15>
  22378c:	0f b6 44 24 10       	movzx  eax,BYTE PTR [rsp+0x10]
  223791:	0f b6 4c 24 11       	movzx  ecx,BYTE PTR [rsp+0x11]
    switch (endian) {
  223796:	f6 44 24 38 01       	test   BYTE PTR [rsp+0x38],0x1
  22379b:	74 1b                	je     2237b8 <openSelfDebugInfoLinux+0x4828>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  22379d:	c1 e1 08             	shl    ecx,0x8
  2237a0:	09 c1                	or     ecx,eax
  2237a2:	0f b6 54 24 12       	movzx  edx,BYTE PTR [rsp+0x12]
  2237a7:	c1 e2 10             	shl    edx,0x10
  2237aa:	09 ca                	or     edx,ecx
  2237ac:	0f b6 44 24 13       	movzx  eax,BYTE PTR [rsp+0x13]
  2237b1:	c1 e0 18             	shl    eax,0x18
  2237b4:	09 d0                	or     eax,edx
  2237b6:	eb 19                	jmp    2237d1 <openSelfDebugInfoLinux+0x4841>
                result = (result << 8) | b;
  2237b8:	c1 e0 08             	shl    eax,0x8
  2237bb:	09 c8                	or     eax,ecx
  2237bd:	c1 e0 08             	shl    eax,0x8
  2237c0:	0f b6 4c 24 12       	movzx  ecx,BYTE PTR [rsp+0x12]
  2237c5:	09 c1                	or     ecx,eax
  2237c7:	c1 e1 08             	shl    ecx,0x8
  2237ca:	0f b6 44 24 13       	movzx  eax,BYTE PTR [rsp+0x13]
  2237cf:	09 c8                	or     eax,ecx
  2237d1:	89 c0                	mov    eax,eax
  2237d3:	48 8b 4c 24 58       	mov    rcx,QWORD PTR [rsp+0x58]
  2237d8:	48 8b 54 24 60       	mov    rdx,QWORD PTR [rsp+0x60]
  2237dd:	48 89 04 11          	mov    QWORD PTR [rcx+rdx*1],rax
  2237e1:	48 8b 84 24 b0 00 00 	mov    rax,QWORD PTR [rsp+0xb0]
  2237e8:	00 
  2237e9:	48 89 c1             	mov    rcx,rax
            for (elf.section_headers) |*elf_section| {
  2237ec:	48 83 c1 01          	add    rcx,0x1
  2237f0:	48 89 c8             	mov    rax,rcx
  2237f3:	48 89 84 24 b0 00 00 	mov    QWORD PTR [rsp+0xb0],rax
  2237fa:	00 
  2237fb:	48 3b 4c 24 30       	cmp    rcx,QWORD PTR [rsp+0x30]
  223800:	0f 83 ca 02 00 00    	jae    223ad0 <openSelfDebugInfoLinux+0x4b40>
  223806:	48 83 44 24 60 40    	add    QWORD PTR [rsp+0x60],0x40
  22380c:	48 8b 84 24 b0 01 00 	mov    rax,QWORD PTR [rsp+0x1b0]
  223813:	00 
                elf_section.name = try in.readInt(elf.endian, u32);
  223814:	48 89 44 24 58       	mov    QWORD PTR [rsp+0x58],rax
  223819:	0f b6 84 24 82 01 00 	movzx  eax,BYTE PTR [rsp+0x182]
  223820:	00 
            try self.readNoEof(bytes[0..]);
  223821:	88 44 24 38          	mov    BYTE PTR [rsp+0x38],al
  223825:	48 8d 44 24 10       	lea    rax,[rsp+0x10]
  22382a:	48 89 44 24 68       	mov    QWORD PTR [rsp+0x68],rax
  22382f:	48 c7 44 24 70 04 00 	mov    QWORD PTR [rsp+0x70],0x4
  223836:	00 00 
            return self.readFn(self, buffer);
  223838:	48 8d bc 24 c0 00 00 	lea    rdi,[rsp+0xc0]
  22383f:	00 
  223840:	48 8d 74 24 48       	lea    rsi,[rsp+0x48]
  223845:	48 8d 54 24 68       	lea    rdx,[rsp+0x68]
  22384a:	ff 54 24 48          	call   QWORD PTR [rsp+0x48]
  22384e:	0f b7 ac 24 c0 00 00 	movzx  ebp,WORD PTR [rsp+0xc0]
  223855:	00 
  223856:	48 8b 84 24 c8 00 00 	mov    rax,QWORD PTR [rsp+0xc8]
  22385d:	00 
            const amt_read = try self.read(buf);
  22385e:	66 85 ed             	test   bp,bp
  223861:	0f 84 ff f8 ff ff    	je     223166 <openSelfDebugInfoLinux+0x41d6>
  223867:	e9 3d 02 00 00       	jmp    223aa9 <openSelfDebugInfoLinux+0x4b19>
        const bytes = @sliceToBytes(memory);
  22386c:	48 8b 84 24 b8 01 00 	mov    rax,QWORD PTR [rsp+0x1b8]
  223873:	00 
  223874:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  223878:	0f 84 e6 b8 ff ff    	je     21f164 <openSelfDebugInfoLinux+0x1d4>
  22387e:	48 8b bc 24 c0 01 00 	mov    rdi,QWORD PTR [rsp+0x1c0]
  223885:	00 
        const bytes = @sliceToBytes(memory);
  223886:	48 8b 8c 24 b0 01 00 	mov    rcx,QWORD PTR [rsp+0x1b0]
  22388d:	00 
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  22388e:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  223892:	48 89 8c 24 c0 00 00 	mov    QWORD PTR [rsp+0xc0],rcx
  223899:	00 
  22389a:	48 89 84 24 c8 00 00 	mov    QWORD PTR [rsp+0xc8],rax
  2238a1:	00 
  2238a2:	48 8d b4 24 c0 00 00 	lea    rsi,[rsp+0xc0]
  2238a9:	00 
  2238aa:	ff d2                	call   rdx
                elf_section.flags = try in.readInt(elf.endian, u64);
  2238ac:	0f b7 ac 24 28 04 00 	movzx  ebp,WORD PTR [rsp+0x428]
  2238b3:	00 
  2238b4:	66 85 ed             	test   bp,bp
  2238b7:	0f 85 b0 b8 ff ff    	jne    21f16d <openSelfDebugInfoLinux+0x1dd>
  2238bd:	e9 82 bf ff ff       	jmp    21f844 <openSelfDebugInfoLinux+0x8b4>
        const bytes = @sliceToBytes(memory);
  2238c2:	48 8b 84 24 b8 01 00 	mov    rax,QWORD PTR [rsp+0x1b8]
  2238c9:	00 
  2238ca:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  2238ce:	0f 84 90 b8 ff ff    	je     21f164 <openSelfDebugInfoLinux+0x1d4>
  2238d4:	48 8b bc 24 c0 01 00 	mov    rdi,QWORD PTR [rsp+0x1c0]
  2238db:	00 
        const bytes = @sliceToBytes(memory);
  2238dc:	48 8b 8c 24 b0 01 00 	mov    rcx,QWORD PTR [rsp+0x1b0]
  2238e3:	00 
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  2238e4:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  2238e8:	48 89 8c 24 c0 00 00 	mov    QWORD PTR [rsp+0xc0],rcx
  2238ef:	00 
  2238f0:	48 89 84 24 c8 00 00 	mov    QWORD PTR [rsp+0xc8],rax
  2238f7:	00 
  2238f8:	48 8d b4 24 c0 00 00 	lea    rsi,[rsp+0xc0]
  2238ff:	00 
  223900:	ff d2                	call   rdx
                elf_section.addr = try in.readInt(elf.endian, u64);
  223902:	0f b7 ac 24 50 04 00 	movzx  ebp,WORD PTR [rsp+0x450]
  223909:	00 
  22390a:	66 85 ed             	test   bp,bp
  22390d:	0f 85 5a b8 ff ff    	jne    21f16d <openSelfDebugInfoLinux+0x1dd>
  223913:	e9 2c bf ff ff       	jmp    21f844 <openSelfDebugInfoLinux+0x8b4>
        const bytes = @sliceToBytes(memory);
  223918:	48 8b 84 24 b8 01 00 	mov    rax,QWORD PTR [rsp+0x1b8]
  22391f:	00 
  223920:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  223924:	0f 84 3a b8 ff ff    	je     21f164 <openSelfDebugInfoLinux+0x1d4>
  22392a:	48 8b bc 24 c0 01 00 	mov    rdi,QWORD PTR [rsp+0x1c0]
  223931:	00 
        const bytes = @sliceToBytes(memory);
  223932:	48 8b 8c 24 b0 01 00 	mov    rcx,QWORD PTR [rsp+0x1b0]
  223939:	00 
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  22393a:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  22393e:	48 89 8c 24 c0 00 00 	mov    QWORD PTR [rsp+0xc0],rcx
  223945:	00 
  223946:	48 89 84 24 c8 00 00 	mov    QWORD PTR [rsp+0xc8],rax
  22394d:	00 
  22394e:	48 8d b4 24 c0 00 00 	lea    rsi,[rsp+0xc0]
  223955:	00 
  223956:	ff d2                	call   rdx
                elf_section.offset = try in.readInt(elf.endian, u64);
  223958:	0f b7 ac 24 00 04 00 	movzx  ebp,WORD PTR [rsp+0x400]
  22395f:	00 
  223960:	66 85 ed             	test   bp,bp
  223963:	0f 85 04 b8 ff ff    	jne    21f16d <openSelfDebugInfoLinux+0x1dd>
  223969:	e9 d6 be ff ff       	jmp    21f844 <openSelfDebugInfoLinux+0x8b4>
        const bytes = @sliceToBytes(memory);
  22396e:	48 8b 84 24 b8 01 00 	mov    rax,QWORD PTR [rsp+0x1b8]
  223975:	00 
  223976:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  22397a:	0f 84 e4 b7 ff ff    	je     21f164 <openSelfDebugInfoLinux+0x1d4>
  223980:	48 8b bc 24 c0 01 00 	mov    rdi,QWORD PTR [rsp+0x1c0]
  223987:	00 
        const bytes = @sliceToBytes(memory);
  223988:	48 8b 8c 24 b0 01 00 	mov    rcx,QWORD PTR [rsp+0x1b0]
  22398f:	00 
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  223990:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  223994:	48 89 8c 24 c0 00 00 	mov    QWORD PTR [rsp+0xc0],rcx
  22399b:	00 
  22399c:	48 89 84 24 c8 00 00 	mov    QWORD PTR [rsp+0xc8],rax
  2239a3:	00 
  2239a4:	48 8d b4 24 c0 00 00 	lea    rsi,[rsp+0xc0]
  2239ab:	00 
  2239ac:	ff d2                	call   rdx
                elf_section.size = try in.readInt(elf.endian, u64);
  2239ae:	0f b7 ac 24 70 02 00 	movzx  ebp,WORD PTR [rsp+0x270]
  2239b5:	00 
  2239b6:	66 85 ed             	test   bp,bp
  2239b9:	0f 85 ae b7 ff ff    	jne    21f16d <openSelfDebugInfoLinux+0x1dd>
  2239bf:	e9 80 be ff ff       	jmp    21f844 <openSelfDebugInfoLinux+0x8b4>
        const bytes = @sliceToBytes(memory);
  2239c4:	48 8b 84 24 b8 01 00 	mov    rax,QWORD PTR [rsp+0x1b8]
  2239cb:	00 
  2239cc:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  2239d0:	0f 84 8e b7 ff ff    	je     21f164 <openSelfDebugInfoLinux+0x1d4>
  2239d6:	48 8b bc 24 c0 01 00 	mov    rdi,QWORD PTR [rsp+0x1c0]
  2239dd:	00 
        const bytes = @sliceToBytes(memory);
  2239de:	48 8b 8c 24 b0 01 00 	mov    rcx,QWORD PTR [rsp+0x1b0]
  2239e5:	00 
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  2239e6:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  2239ea:	48 89 8c 24 c0 00 00 	mov    QWORD PTR [rsp+0xc0],rcx
  2239f1:	00 
  2239f2:	48 89 84 24 c8 00 00 	mov    QWORD PTR [rsp+0xc8],rax
  2239f9:	00 
  2239fa:	48 8d b4 24 c0 00 00 	lea    rsi,[rsp+0xc0]
  223a01:	00 
  223a02:	ff d2                	call   rdx
                elf_section.addr_align = try in.readInt(elf.endian, u64);
  223a04:	0f b7 ac 24 b0 02 00 	movzx  ebp,WORD PTR [rsp+0x2b0]
  223a0b:	00 
  223a0c:	66 85 ed             	test   bp,bp
  223a0f:	0f 85 58 b7 ff ff    	jne    21f16d <openSelfDebugInfoLinux+0x1dd>
  223a15:	e9 2a be ff ff       	jmp    21f844 <openSelfDebugInfoLinux+0x8b4>
        const bytes = @sliceToBytes(memory);
  223a1a:	48 8b 84 24 b8 01 00 	mov    rax,QWORD PTR [rsp+0x1b8]
  223a21:	00 
  223a22:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  223a26:	0f 84 38 b7 ff ff    	je     21f164 <openSelfDebugInfoLinux+0x1d4>
  223a2c:	48 8b bc 24 c0 01 00 	mov    rdi,QWORD PTR [rsp+0x1c0]
  223a33:	00 
        const bytes = @sliceToBytes(memory);
  223a34:	48 8b 8c 24 b0 01 00 	mov    rcx,QWORD PTR [rsp+0x1b0]
  223a3b:	00 
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  223a3c:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  223a40:	48 89 8c 24 c0 00 00 	mov    QWORD PTR [rsp+0xc0],rcx
  223a47:	00 
  223a48:	48 89 84 24 c8 00 00 	mov    QWORD PTR [rsp+0xc8],rax
  223a4f:	00 
  223a50:	48 8d b4 24 c0 00 00 	lea    rsi,[rsp+0xc0]
  223a57:	00 
  223a58:	ff d2                	call   rdx
                elf_section.ent_size = try in.readInt(elf.endian, u64);
  223a5a:	0f b7 ac 24 e0 02 00 	movzx  ebp,WORD PTR [rsp+0x2e0]
  223a61:	00 
  223a62:	66 85 ed             	test   bp,bp
  223a65:	0f 85 02 b7 ff ff    	jne    21f16d <openSelfDebugInfoLinux+0x1dd>
  223a6b:	e9 d4 bd ff ff       	jmp    21f844 <openSelfDebugInfoLinux+0x8b4>
  223a70:	48 8b bc 24 c0 01 00 	mov    rdi,QWORD PTR [rsp+0x1c0]
  223a77:	00 
  223a78:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  223a7c:	48 8b 4c 24 58       	mov    rcx,QWORD PTR [rsp+0x58]
  223a81:	48 89 8c 24 c0 00 00 	mov    QWORD PTR [rsp+0xc0],rcx
  223a88:	00 
  223a89:	48 8b 4c 24 60       	mov    rcx,QWORD PTR [rsp+0x60]
  223a8e:	48 89 8c 24 c8 00 00 	mov    QWORD PTR [rsp+0xc8],rcx
  223a95:	00 
  223a96:	48 8d b4 24 c0 00 00 	lea    rsi,[rsp+0xc0]
  223a9d:	00 
  223a9e:	ff d0                	call   rax
  223aa0:	e9 36 01 00 00       	jmp    223bdb <openSelfDebugInfoLinux+0x4c4b>
  223aa5:	66 bd 25 00          	mov    bp,0x25
        const bytes = @sliceToBytes(memory);
  223aa9:	48 8b 84 24 b8 01 00 	mov    rax,QWORD PTR [rsp+0x1b8]
  223ab0:	00 
  223ab1:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  223ab5:	0f 84 b2 b6 ff ff    	je     21f16d <openSelfDebugInfoLinux+0x1dd>
  223abb:	48 8b bc 24 c0 01 00 	mov    rdi,QWORD PTR [rsp+0x1c0]
  223ac2:	00 
        const bytes = @sliceToBytes(memory);
  223ac3:	48 8b 8c 24 b0 01 00 	mov    rcx,QWORD PTR [rsp+0x1b0]
  223aca:	00 
  223acb:	e9 bc 00 00 00       	jmp    223b8c <openSelfDebugInfoLinux+0x4bfc>
        for (elf.section_headers) |*elf_section| {
  223ad0:	48 8b 84 24 b8 01 00 	mov    rax,QWORD PTR [rsp+0x1b8]
  223ad7:	00 
  223ad8:	48 85 c0             	test   rax,rax
  223adb:	74 66                	je     223b43 <openSelfDebugInfoLinux+0x4bb3>
  223add:	48 8b 8c 24 b0 01 00 	mov    rcx,QWORD PTR [rsp+0x1b0]
  223ae4:	00 
  223ae5:	48 8d 51 20          	lea    rdx,[rcx+0x20]
  223ae9:	31 f6                	xor    esi,esi
  223aeb:	4c 8d 05 ce c9 fd ff 	lea    r8,[rip+0xfffffffffffdc9ce]        # 2004c0 <__unnamed_27>
            if (elf_section.sh_type != SHT_NOBITS) {
  223af2:	83 7a e4 08          	cmp    DWORD PTR [rdx-0x1c],0x8
  223af6:	74 3c                	je     223b34 <openSelfDebugInfoLinux+0x4ba4>
                const file_end_offset = try math.add(u64, elf_section.offset, elf_section.size);
  223af8:	48 8b 6a f8          	mov    rbp,QWORD PTR [rdx-0x8]
  223afc:	4c 89 c7             	mov    rdi,r8
    return if (@addWithOverflow(T, a, b, &answer)) error.Overflow else answer;
  223aff:	48 03 2a             	add    rbp,QWORD PTR [rdx]
  223b02:	72 1a                	jb     223b1e <openSelfDebugInfoLinux+0x4b8e>
  223b04:	66 c7 84 24 c0 00 00 	mov    WORD PTR [rsp+0xc0],0x0
  223b0b:	00 00 00 
  223b0e:	48 89 ac 24 c8 00 00 	mov    QWORD PTR [rsp+0xc8],rbp
  223b15:	00 
  223b16:	48 8d bc 24 c0 00 00 	lea    rdi,[rsp+0xc0]
  223b1d:	00 
  223b1e:	0f b7 2f             	movzx  ebp,WORD PTR [rdi]
  223b21:	66 85 ed             	test   bp,bp
  223b24:	75 54                	jne    223b7a <openSelfDebugInfoLinux+0x4bea>
                if (stream_end < file_end_offset) return error.InvalidFormat;
  223b26:	48 8b ac 24 48 02 00 	mov    rbp,QWORD PTR [rsp+0x248]
  223b2d:	00 
  223b2e:	48 3b 6f 08          	cmp    rbp,QWORD PTR [rdi+0x8]
  223b32:	72 7b                	jb     223baf <openSelfDebugInfoLinux+0x4c1f>
        for (elf.section_headers) |*elf_section| {
  223b34:	48 83 c6 01          	add    rsi,0x1
  223b38:	48 83 c2 40          	add    rdx,0x40
  223b3c:	48 39 c6             	cmp    rsi,rax
  223b3f:	72 b1                	jb     223af2 <openSelfDebugInfoLinux+0x4b62>
  223b41:	eb 08                	jmp    223b4b <openSelfDebugInfoLinux+0x4bbb>
        elf.string_section = &elf.section_headers[elf.string_section_index];
  223b43:	48 8b 8c 24 b0 01 00 	mov    rcx,QWORD PTR [rsp+0x1b0]
  223b4a:	00 
  223b4b:	48 8b 94 24 a0 01 00 	mov    rdx,QWORD PTR [rsp+0x1a0]
  223b52:	00 
  223b53:	48 c1 e2 06          	shl    rdx,0x6
  223b57:	48 8d 34 11          	lea    rsi,[rcx+rdx*1]
  223b5b:	48 89 b4 24 a8 01 00 	mov    QWORD PTR [rsp+0x1a8],rsi
  223b62:	00 
        if (elf.string_section.sh_type != SHT_STRTAB) {
  223b63:	83 7c 11 04 03       	cmp    DWORD PTR [rcx+rdx*1+0x4],0x3
  223b68:	75 45                	jne    223baf <openSelfDebugInfoLinux+0x4c1f>
  223b6a:	31 ed                	xor    ebp,ebp
  223b6c:	66 85 ed             	test   bp,bp
  223b6f:	0f 85 f8 b5 ff ff    	jne    21f16d <openSelfDebugInfoLinux+0x1dd>
  223b75:	e9 ca bc ff ff       	jmp    21f844 <openSelfDebugInfoLinux+0x8b4>
  223b7a:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  223b7e:	0f 84 e9 b5 ff ff    	je     21f16d <openSelfDebugInfoLinux+0x1dd>
  223b84:	48 8b bc 24 c0 01 00 	mov    rdi,QWORD PTR [rsp+0x1c0]
  223b8b:	00 
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  223b8c:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  223b90:	48 89 8c 24 c0 00 00 	mov    QWORD PTR [rsp+0xc0],rcx
  223b97:	00 
  223b98:	48 89 84 24 c8 00 00 	mov    QWORD PTR [rsp+0xc8],rax
  223b9f:	00 
  223ba0:	48 8d b4 24 c0 00 00 	lea    rsi,[rsp+0xc0]
  223ba7:	00 
  223ba8:	ff d2                	call   rdx
  223baa:	e9 be b5 ff ff       	jmp    21f16d <openSelfDebugInfoLinux+0x1dd>
        const bytes = @sliceToBytes(memory);
  223baf:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  223bb3:	74 26                	je     223bdb <openSelfDebugInfoLinux+0x4c4b>
  223bb5:	48 8b bc 24 c0 01 00 	mov    rdi,QWORD PTR [rsp+0x1c0]
  223bbc:	00 
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  223bbd:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  223bc1:	48 89 8c 24 c0 00 00 	mov    QWORD PTR [rsp+0xc0],rcx
  223bc8:	00 
  223bc9:	48 89 84 24 c8 00 00 	mov    QWORD PTR [rsp+0xc8],rax
  223bd0:	00 
  223bd1:	48 8d b4 24 c0 00 00 	lea    rsi,[rsp+0xc0]
  223bd8:	00 
  223bd9:	ff d2                	call   rdx
  223bdb:	66 bd 26 00          	mov    bp,0x26
  223bdf:	e9 89 b5 ff ff       	jmp    21f16d <openSelfDebugInfoLinux+0x1dd>
  223be4:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  223beb:	00 00 00 00 00 

0000000000223bf0 <Elf_findSection>:
    }

    pub fn findSection(elf: *Elf, name: []const u8) !?*SectionHeader {
  223bf0:	55                   	push   rbp
  223bf1:	41 57                	push   r15
  223bf3:	41 56                	push   r14
  223bf5:	41 55                	push   r13
  223bf7:	41 54                	push   r12
  223bf9:	53                   	push   rbx
  223bfa:	48 81 ec 88 00 00 00 	sub    rsp,0x88
  223c01:	48 89 d3             	mov    rbx,rdx
  223c04:	48 89 7c 24 08       	mov    QWORD PTR [rsp+0x8],rdi
        var file_stream = io.FileInStream.init(elf.in_file);
  223c09:	48 8b 06             	mov    rax,QWORD PTR [rsi]
  223c0c:	48 89 44 24 28       	mov    QWORD PTR [rsp+0x28],rax
  223c11:	48 8d 05 48 05 00 00 	lea    rax,[rip+0x548]        # 224160 <FileInStream_readFn>
  223c18:	48 89 44 24 30       	mov    QWORD PTR [rsp+0x30],rax
        const in = &file_stream.stream;

        section_loop: for (elf.section_headers) |*elf_section| {
  223c1d:	48 8b 46 40          	mov    rax,QWORD PTR [rsi+0x40]
  223c21:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
  223c26:	48 85 c0             	test   rax,rax
  223c29:	0f 84 37 01 00 00    	je     223d66 <Elf_findSection+0x176>
  223c2f:	45 31 e4             	xor    r12d,r12d
  223c32:	48 89 74 24 20       	mov    QWORD PTR [rsp+0x20],rsi
  223c37:	4c 8b 76 38          	mov    r14,QWORD PTR [rsi+0x38]
  223c3b:	4c 89 e0             	mov    rax,r12
  223c3e:	48 c1 e0 06          	shl    rax,0x6
            if (elf_section.sh_type == SHT_NULL) continue;
  223c42:	41 83 7c 06 04 00    	cmp    DWORD PTR [r14+rax*1+0x4],0x0
  223c48:	0f 84 04 01 00 00    	je     223d52 <Elf_findSection+0x162>
  223c4e:	49 01 c6             	add    r14,rax
  223c51:	48 8b 4c 24 20       	mov    rcx,QWORD PTR [rsp+0x20]

            const name_offset = elf.string_section.offset + elf_section.name;
  223c56:	48 8b 41 30          	mov    rax,QWORD PTR [rcx+0x30]
  223c5a:	41 8b 36             	mov    esi,DWORD PTR [r14]
    if (@maxValue(@typeOf(x)) > @maxValue(T) and x > @maxValue(T)) {
  223c5d:	48 03 70 18          	add    rsi,QWORD PTR [rax+0x18]
  223c61:	0f 88 3e 01 00 00    	js     223da5 <Elf_findSection+0x1b5>
            try elf.in_file.seekTo(name_offset);
  223c67:	48 8b 01             	mov    rax,QWORD PTR [rcx]
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  223c6a:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  223c6d:	b8 08 00 00 00       	mov    eax,0x8
  223c72:	31 d2                	xor    edx,edx
  223c74:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  223c76:	48 89 c1             	mov    rcx,rax
  223c79:	48 f7 d9             	neg    rcx
  223c7c:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  223c82:	b8 00 00 00 00       	mov    eax,0x0
  223c87:	48 0f 46 c8          	cmovbe rcx,rax
  223c8b:	48 85 c9             	test   rcx,rcx
  223c8e:	0f 85 17 01 00 00    	jne    223dab <Elf_findSection+0x1bb>

            for (name) |expected_c| {
  223c94:	4c 8b 6b 08          	mov    r13,QWORD PTR [rbx+0x8]
  223c98:	4d 85 ed             	test   r13,r13
  223c9b:	74 66                	je     223d03 <Elf_findSection+0x113>
  223c9d:	31 ed                	xor    ebp,ebp
  223c9f:	90                   	nop
  223ca0:	48 8b 03             	mov    rax,QWORD PTR [rbx]
  223ca3:	44 0f b6 3c 28       	movzx  r15d,BYTE PTR [rax+rbp*1]
            try self.readNoEof(result[0..]);
  223ca8:	48 8d 44 24 07       	lea    rax,[rsp+0x7]
  223cad:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  223cb2:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  223cb9:	00 00 
            return self.readFn(self, buffer);
  223cbb:	48 8d 7c 24 38       	lea    rdi,[rsp+0x38]
  223cc0:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
  223cc5:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  223cca:	ff 54 24 30          	call   QWORD PTR [rsp+0x30]
  223cce:	0f b7 44 24 38       	movzx  eax,WORD PTR [rsp+0x38]
            const amt_read = try self.read(buf);
  223cd3:	66 85 c0             	test   ax,ax
  223cd6:	0f 85 9d 00 00 00    	jne    223d79 <Elf_findSection+0x189>
  223cdc:	48 8b 44 24 40       	mov    rax,QWORD PTR [rsp+0x40]
            if (amt_read < buf.len) return error.EndOfStream;
  223ce1:	48 3b 44 24 18       	cmp    rax,QWORD PTR [rsp+0x18]
  223ce6:	0f 82 89 00 00 00    	jb     223d75 <Elf_findSection+0x185>
            return result[0];
  223cec:	0f b6 44 24 07       	movzx  eax,BYTE PTR [rsp+0x7]
                const target_c = try in.readByte();
                if (target_c == 0 or expected_c != target_c) continue :section_loop;
  223cf1:	84 c0                	test   al,al
  223cf3:	74 5d                	je     223d52 <Elf_findSection+0x162>
  223cf5:	41 38 c7             	cmp    r15b,al
  223cf8:	75 58                	jne    223d52 <Elf_findSection+0x162>
  223cfa:	48 83 c5 01          	add    rbp,0x1
            for (name) |expected_c| {
  223cfe:	4c 39 ed             	cmp    rbp,r13
  223d01:	72 9d                	jb     223ca0 <Elf_findSection+0xb0>
            try self.readNoEof(result[0..]);
  223d03:	48 8d 44 24 07       	lea    rax,[rsp+0x7]
  223d08:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  223d0d:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  223d14:	00 00 
            return self.readFn(self, buffer);
  223d16:	48 8d 7c 24 38       	lea    rdi,[rsp+0x38]
  223d1b:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
  223d20:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  223d25:	ff 54 24 30          	call   QWORD PTR [rsp+0x30]
  223d29:	0f b7 44 24 38       	movzx  eax,WORD PTR [rsp+0x38]
            const amt_read = try self.read(buf);
  223d2e:	66 85 c0             	test   ax,ax
  223d31:	0f 85 b7 00 00 00    	jne    223dee <Elf_findSection+0x1fe>
  223d37:	48 8b 44 24 40       	mov    rax,QWORD PTR [rsp+0x40]
            if (amt_read < buf.len) return error.EndOfStream;
  223d3c:	48 3b 44 24 18       	cmp    rax,QWORD PTR [rsp+0x18]
  223d41:	0f 82 a3 00 00 00    	jb     223dea <Elf_findSection+0x1fa>
            }

            {
                const null_byte = try in.readByte();
                if (null_byte == 0) return elf_section;
  223d47:	80 7c 24 07 00       	cmp    BYTE PTR [rsp+0x7],0x0
  223d4c:	0f 84 b0 00 00 00    	je     223e02 <Elf_findSection+0x212>
        section_loop: for (elf.section_headers) |*elf_section| {
  223d52:	49 83 c4 01          	add    r12,0x1
  223d56:	4c 3b 64 24 50       	cmp    r12,QWORD PTR [rsp+0x50]
  223d5b:	48 8b 74 24 20       	mov    rsi,QWORD PTR [rsp+0x20]
  223d60:	0f 82 d1 fe ff ff    	jb     223c37 <Elf_findSection+0x47>
            }
        }

        return null;
  223d66:	c5 f8 57 c0          	vxorps xmm0,xmm0,xmm0
  223d6a:	48 8b 44 24 08       	mov    rax,QWORD PTR [rsp+0x8]
  223d6f:	c5 f8 11 00          	vmovups XMMWORD PTR [rax],xmm0
  223d73:	eb 1e                	jmp    223d93 <Elf_findSection+0x1a3>
  223d75:	66 b8 25 00          	mov    ax,0x25
  223d79:	48 8b 54 24 08       	mov    rdx,QWORD PTR [rsp+0x8]
                const target_c = try in.readByte();
  223d7e:	66 89 02             	mov    WORD PTR [rdx],ax
  223d81:	48 8b 44 24 6c       	mov    rax,QWORD PTR [rsp+0x6c]
  223d86:	48 8b 4c 24 72       	mov    rcx,QWORD PTR [rsp+0x72]
  223d8b:	48 89 4a 08          	mov    QWORD PTR [rdx+0x8],rcx
  223d8f:	48 89 42 02          	mov    QWORD PTR [rdx+0x2],rax
  223d93:	48 81 c4 88 00 00 00 	add    rsp,0x88
  223d9a:	5b                   	pop    rbx
  223d9b:	41 5c                	pop    r12
  223d9d:	41 5d                	pop    r13
  223d9f:	41 5e                	pop    r14
  223da1:	41 5f                	pop    r15
  223da3:	5d                   	pop    rbp
  223da4:	c3                   	ret    
  223da5:	66 b8 04 00          	mov    ax,0x4
  223da9:	eb 28                	jmp    223dd3 <Elf_findSection+0x1e3>
  223dab:	48 8d 41 ea          	lea    rax,[rcx-0x16]
  223daf:	48 83 f8 35          	cmp    rax,0x35
  223db3:	77 10                	ja     223dc5 <Elf_findSection+0x1d5>
  223db5:	48 ba 81 00 00 00 00 	movabs rdx,0x20000000000081
  223dbc:	00 20 00 
  223dbf:	48 0f a3 c2          	bt     rdx,rax
  223dc3:	72 0a                	jb     223dcf <Elf_findSection+0x1df>
  223dc5:	66 b8 03 00          	mov    ax,0x3
  223dc9:	48 83 f9 06          	cmp    rcx,0x6
  223dcd:	75 04                	jne    223dd3 <Elf_findSection+0x1e3>
  223dcf:	66 b8 27 00          	mov    ax,0x27
  223dd3:	48 8b 54 24 08       	mov    rdx,QWORD PTR [rsp+0x8]
            try elf.in_file.seekTo(name_offset);
  223dd8:	66 89 02             	mov    WORD PTR [rdx],ax
  223ddb:	48 8b 44 24 7a       	mov    rax,QWORD PTR [rsp+0x7a]
  223de0:	48 8b 8c 24 80 00 00 	mov    rcx,QWORD PTR [rsp+0x80]
  223de7:	00 
  223de8:	eb a1                	jmp    223d8b <Elf_findSection+0x19b>
  223dea:	66 b8 25 00          	mov    ax,0x25
  223dee:	48 8b 54 24 08       	mov    rdx,QWORD PTR [rsp+0x8]
                const null_byte = try in.readByte();
  223df3:	66 89 02             	mov    WORD PTR [rdx],ax
  223df6:	48 8b 44 24 5e       	mov    rax,QWORD PTR [rsp+0x5e]
  223dfb:	48 8b 4c 24 64       	mov    rcx,QWORD PTR [rsp+0x64]
  223e00:	eb 89                	jmp    223d8b <Elf_findSection+0x19b>
  223e02:	48 8b 4c 24 08       	mov    rcx,QWORD PTR [rsp+0x8]
                if (null_byte == 0) return elf_section;
  223e07:	66 c7 01 00 00       	mov    WORD PTR [rcx],0x0
  223e0c:	0f b7 44 24 4e       	movzx  eax,WORD PTR [rsp+0x4e]
  223e11:	66 89 41 06          	mov    WORD PTR [rcx+0x6],ax
  223e15:	8b 44 24 4a          	mov    eax,DWORD PTR [rsp+0x4a]
  223e19:	89 41 02             	mov    DWORD PTR [rcx+0x2],eax
  223e1c:	4c 89 71 08          	mov    QWORD PTR [rcx+0x8],r14
  223e20:	e9 6e ff ff ff       	jmp    223d93 <Elf_findSection+0x1a3>
  223e25:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  223e2c:	00 00 00 00 

0000000000223e30 <File_openReadC>:
    pub fn openReadC(path: [*]const u8) OpenError!File {
  223e30:	49 89 f1             	mov    r9,rsi
  223e33:	49 89 f8             	mov    r8,rdi
  223e36:	45 31 d2             	xor    r10d,r10d
  223e39:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  223e40:	b8 02 00 00 00       	mov    eax,0x2
  223e45:	be 00 00 00 00       	mov    esi,0x0
  223e4a:	31 d2                	xor    edx,edx
  223e4c:	4c 89 cf             	mov    rdi,r9
  223e4f:	0f 05                	syscall 
  223e51:	48 89 c1             	mov    rcx,rax
  223e54:	48 f7 d9             	neg    rcx
  223e57:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  223e5d:	49 0f 46 ca          	cmovbe rcx,r10
        if (err > 0) {
  223e61:	48 83 f9 04          	cmp    rcx,0x4
  223e65:	74 d9                	je     223e40 <File_openReadC+0x10>
  223e67:	48 83 f9 4b          	cmp    rcx,0x4b
  223e6b:	77 2d                	ja     223e9a <File_openReadC+0x6a>
  223e6d:	48 8d 15 74 d2 fd ff 	lea    rdx,[rip+0xfffffffffffdd274]        # 2010e8 <__unnamed_621+0x430>
  223e74:	48 63 0c 8a          	movsxd rcx,DWORD PTR [rdx+rcx*4]
  223e78:	48 01 d1             	add    rcx,rdx
  223e7b:	ff e1                	jmp    rcx
  223e7d:	66 b8 16 00          	mov    ax,0x16
  223e81:	eb 57                	jmp    223eda <File_openReadC+0xaa>
  223e83:	66 b8 13 00          	mov    ax,0x13
  223e87:	eb 51                	jmp    223eda <File_openReadC+0xaa>
            return openHandle(fd);
  223e89:	66 41 c7 00 00 00    	mov    WORD PTR [r8],0x0
  223e8f:	41 89 40 04          	mov    DWORD PTR [r8+0x4],eax
  223e93:	c3                   	ret    
  223e94:	66 b8 1a 00          	mov    ax,0x1a
  223e98:	eb 40                	jmp    223eda <File_openReadC+0xaa>
  223e9a:	66 b8 03 00          	mov    ax,0x3
  223e9e:	eb 3a                	jmp    223eda <File_openReadC+0xaa>
  223ea0:	66 b8 0c 00          	mov    ax,0xc
  223ea4:	eb 34                	jmp    223eda <File_openReadC+0xaa>
  223ea6:	66 b8 19 00          	mov    ax,0x19
  223eaa:	eb 2e                	jmp    223eda <File_openReadC+0xaa>
  223eac:	66 b8 23 00          	mov    ax,0x23
  223eb0:	eb 28                	jmp    223eda <File_openReadC+0xaa>
  223eb2:	66 b8 24 00          	mov    ax,0x24
  223eb6:	eb 22                	jmp    223eda <File_openReadC+0xaa>
  223eb8:	66 b8 1f 00          	mov    ax,0x1f
  223ebc:	eb 1c                	jmp    223eda <File_openReadC+0xaa>
  223ebe:	66 b8 22 00          	mov    ax,0x22
  223ec2:	eb 16                	jmp    223eda <File_openReadC+0xaa>
  223ec4:	66 b8 21 00          	mov    ax,0x21
  223ec8:	eb 10                	jmp    223eda <File_openReadC+0xaa>
  223eca:	66 b8 15 00          	mov    ax,0x15
  223ece:	eb 0a                	jmp    223eda <File_openReadC+0xaa>
  223ed0:	66 b8 1c 00          	mov    ax,0x1c
  223ed4:	eb 04                	jmp    223eda <File_openReadC+0xaa>
  223ed6:	66 b8 20 00          	mov    ax,0x20
            const fd = try os.posixOpenC(path, flags, 0);
  223eda:	66 41 89 00          	mov    WORD PTR [r8],ax
  223ede:	0f b7 44 24 fe       	movzx  eax,WORD PTR [rsp-0x2]
  223ee3:	66 41 89 40 06       	mov    WORD PTR [r8+0x6],ax
  223ee8:	8b 44 24 fa          	mov    eax,DWORD PTR [rsp-0x6]
  223eec:	41 89 40 02          	mov    DWORD PTR [r8+0x2],eax
  223ef0:	c3                   	ret    
  223ef1:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  223ef8:	0f 1f 84 00 00 00 00 
  223eff:	00 

0000000000223f00 <InStream(ReadError)_readInt.143>:
        pub fn readInt(self: *Self, endian: builtin.Endian, comptime T: type) !T {
  223f00:	55                   	push   rbp
  223f01:	53                   	push   rbx
  223f02:	48 83 ec 48          	sub    rsp,0x48
  223f06:	89 d5                	mov    ebp,edx
  223f08:	48 89 fb             	mov    rbx,rdi
  223f0b:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
            try self.readNoEof(bytes[0..]);
  223f10:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  223f15:	48 c7 44 24 20 08 00 	mov    QWORD PTR [rsp+0x20],0x8
  223f1c:	00 00 
  223f1e:	48 8d 7c 24 28       	lea    rdi,[rsp+0x28]
  223f23:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  223f28:	ff 16                	call   QWORD PTR [rsi]
  223f2a:	0f b7 44 24 28       	movzx  eax,WORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  223f2f:	66 85 c0             	test   ax,ax
  223f32:	75 10                	jne    223f44 <InStream(ReadError)_readInt.143+0x44>
  223f34:	48 8b 4c 24 30       	mov    rcx,QWORD PTR [rsp+0x30]
  223f39:	66 b8 25 00          	mov    ax,0x25
            if (amt_read < buf.len) return error.EndOfStream;
  223f3d:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  223f42:	73 1c                	jae    223f60 <InStream(ReadError)_readInt.143+0x60>
            try self.readNoEof(bytes[0..]);
  223f44:	66 89 03             	mov    WORD PTR [rbx],ax
  223f47:	48 8b 44 24 3a       	mov    rax,QWORD PTR [rsp+0x3a]
  223f4c:	48 8b 4c 24 40       	mov    rcx,QWORD PTR [rsp+0x40]
  223f51:	48 89 4b 08          	mov    QWORD PTR [rbx+0x8],rcx
  223f55:	48 89 43 02          	mov    QWORD PTR [rbx+0x2],rax
  223f59:	48 83 c4 48          	add    rsp,0x48
  223f5d:	5b                   	pop    rbx
  223f5e:	5d                   	pop    rbp
  223f5f:	c3                   	ret    
  223f60:	0f b6 44 24 08       	movzx  eax,BYTE PTR [rsp+0x8]
  223f65:	0f b6 4c 24 09       	movzx  ecx,BYTE PTR [rsp+0x9]
    switch (endian) {
  223f6a:	40 f6 c5 01          	test   bpl,0x1
  223f6e:	74 51                	je     223fc1 <InStream(ReadError)_readInt.143+0xc1>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  223f70:	48 c1 e1 08          	shl    rcx,0x8
  223f74:	48 09 c1             	or     rcx,rax
  223f77:	0f b6 44 24 0a       	movzx  eax,BYTE PTR [rsp+0xa]
  223f7c:	48 c1 e0 10          	shl    rax,0x10
  223f80:	48 09 c8             	or     rax,rcx
  223f83:	0f b6 4c 24 0b       	movzx  ecx,BYTE PTR [rsp+0xb]
  223f88:	48 c1 e1 18          	shl    rcx,0x18
  223f8c:	48 09 c1             	or     rcx,rax
  223f8f:	0f b6 44 24 0c       	movzx  eax,BYTE PTR [rsp+0xc]
  223f94:	48 c1 e0 20          	shl    rax,0x20
  223f98:	48 09 c8             	or     rax,rcx
  223f9b:	0f b6 4c 24 0d       	movzx  ecx,BYTE PTR [rsp+0xd]
  223fa0:	48 c1 e1 28          	shl    rcx,0x28
  223fa4:	48 09 c1             	or     rcx,rax
  223fa7:	0f b6 54 24 0e       	movzx  edx,BYTE PTR [rsp+0xe]
  223fac:	48 c1 e2 30          	shl    rdx,0x30
  223fb0:	0f b6 44 24 0f       	movzx  eax,BYTE PTR [rsp+0xf]
  223fb5:	48 c1 e0 38          	shl    rax,0x38
  223fb9:	48 09 d0             	or     rax,rdx
  223fbc:	48 09 c8             	or     rax,rcx
  223fbf:	eb 4f                	jmp    224010 <InStream(ReadError)_readInt.143+0x110>
                result = (result << 8) | b;
  223fc1:	48 c1 e0 08          	shl    rax,0x8
  223fc5:	48 09 c8             	or     rax,rcx
  223fc8:	48 c1 e0 08          	shl    rax,0x8
  223fcc:	0f b6 4c 24 0a       	movzx  ecx,BYTE PTR [rsp+0xa]
  223fd1:	48 09 c1             	or     rcx,rax
  223fd4:	48 c1 e1 08          	shl    rcx,0x8
  223fd8:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  223fdd:	48 09 c8             	or     rax,rcx
  223fe0:	48 c1 e0 08          	shl    rax,0x8
  223fe4:	0f b6 4c 24 0c       	movzx  ecx,BYTE PTR [rsp+0xc]
  223fe9:	48 09 c1             	or     rcx,rax
  223fec:	48 c1 e1 08          	shl    rcx,0x8
  223ff0:	0f b6 44 24 0d       	movzx  eax,BYTE PTR [rsp+0xd]
  223ff5:	48 09 c8             	or     rax,rcx
  223ff8:	48 c1 e0 08          	shl    rax,0x8
  223ffc:	0f b6 4c 24 0e       	movzx  ecx,BYTE PTR [rsp+0xe]
  224001:	48 09 c1             	or     rcx,rax
  224004:	48 c1 e1 08          	shl    rcx,0x8
  224008:	0f b6 44 24 0f       	movzx  eax,BYTE PTR [rsp+0xf]
  22400d:	48 09 c8             	or     rax,rcx
            return mem.readInt(bytes, T, endian);
  224010:	66 c7 03 00 00       	mov    WORD PTR [rbx],0x0
  224015:	0f b7 4c 24 16       	movzx  ecx,WORD PTR [rsp+0x16]
  22401a:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  22401e:	8b 4c 24 12          	mov    ecx,DWORD PTR [rsp+0x12]
  224022:	89 4b 02             	mov    DWORD PTR [rbx+0x2],ecx
  224025:	48 89 43 08          	mov    QWORD PTR [rbx+0x8],rax
  224029:	48 83 c4 48          	add    rsp,0x48
  22402d:	5b                   	pop    rbx
  22402e:	5d                   	pop    rbp
  22402f:	c3                   	ret    

0000000000224030 <File_read>:
        SystemResources,

        Unexpected,
    };

    pub fn read(self: *File, buffer: []u8) ReadError!usize {
  224030:	41 57                	push   r15
  224032:	41 56                	push   r14
  224034:	53                   	push   rbx
  224035:	49 89 d1             	mov    r9,rdx
  224038:	49 89 f2             	mov    r10,rsi
  22403b:	49 89 f8             	mov    r8,rdi
        if (is_posix) {
            var index: usize = 0;
            while (index < buffer.len) {
  22403e:	49 8b 51 08          	mov    rdx,QWORD PTR [r9+0x8]
  224042:	48 85 d2             	test   rdx,rdx
  224045:	74 70                	je     2240b7 <File_read+0x87>
  224047:	45 31 f6             	xor    r14d,r14d
  22404a:	4c 8d 3d c7 d1 fd ff 	lea    r15,[rip+0xfffffffffffdd1c7]        # 201218 <__unnamed_621+0x560>
  224051:	31 db                	xor    ebx,ebx
  224053:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  22405a:	84 00 00 00 00 00 
  224060:	49 8b 31             	mov    rsi,QWORD PTR [r9]
                const amt_read = posix.read(self.handle, buffer.ptr + index, buffer.len - index);
  224063:	48 01 de             	add    rsi,rbx
  224066:	48 29 da             	sub    rdx,rbx
    return syscall3(SYS_read, @intCast(usize, fd), @ptrToInt(buf), count);
  224069:	49 63 3a             	movsxd rdi,DWORD PTR [r10]
  22406c:	31 c0                	xor    eax,eax
  22406e:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  224070:	48 89 c1             	mov    rcx,rax
  224073:	48 f7 d9             	neg    rcx
  224076:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  22407c:	49 0f 46 ce          	cmovbe rcx,r14
                const read_err = posix.getErrno(amt_read);
                if (read_err > 0) {
  224080:	48 83 f9 04          	cmp    rcx,0x4
  224084:	75 0b                	jne    224091 <File_read+0x61>
            while (index < buffer.len) {
  224086:	49 8b 51 08          	mov    rdx,QWORD PTR [r9+0x8]
  22408a:	48 39 da             	cmp    rdx,rbx
  22408d:	77 d1                	ja     224060 <File_read+0x30>
  22408f:	eb 28                	jmp    2240b9 <File_read+0x89>
  224091:	48 83 f9 15          	cmp    rcx,0x15
  224095:	77 44                	ja     2240db <File_read+0xab>
  224097:	49 63 0c 8f          	movsxd rcx,DWORD PTR [r15+rcx*4]
  22409b:	4c 01 f9             	add    rcx,r15
  22409e:	ff e1                	jmp    rcx
                        posix.ENOBUFS => return error.SystemResources,
                        posix.ENOMEM => return error.SystemResources,
                        else => return os.unexpectedErrorPosix(read_err),
                    }
                }
                if (amt_read == 0) return index;
  2240a0:	48 85 c0             	test   rax,rax
  2240a3:	0f 84 91 00 00 00    	je     22413a <File_read+0x10a>
  2240a9:	48 01 c3             	add    rbx,rax
            while (index < buffer.len) {
  2240ac:	49 8b 51 08          	mov    rdx,QWORD PTR [r9+0x8]
  2240b0:	48 39 da             	cmp    rdx,rbx
  2240b3:	77 ab                	ja     224060 <File_read+0x30>
  2240b5:	eb 02                	jmp    2240b9 <File_read+0x89>
  2240b7:	31 db                	xor    ebx,ebx
                index += amt_read;
            }
            return index;
  2240b9:	66 41 c7 00 00 00    	mov    WORD PTR [r8],0x0
  2240bf:	0f b7 44 24 ea       	movzx  eax,WORD PTR [rsp-0x16]
  2240c4:	66 41 89 40 06       	mov    WORD PTR [r8+0x6],ax
  2240c9:	8b 44 24 e6          	mov    eax,DWORD PTR [rsp-0x1a]
  2240cd:	41 89 40 02          	mov    DWORD PTR [r8+0x2],eax
  2240d1:	49 89 58 08          	mov    QWORD PTR [r8+0x8],rbx
  2240d5:	5b                   	pop    rbx
  2240d6:	41 5e                	pop    r14
  2240d8:	41 5f                	pop    r15
  2240da:	c3                   	ret    
                if (read_err > 0) {
  2240db:	48 83 f9 69          	cmp    rcx,0x69
  2240df:	75 0a                	jne    2240eb <File_read+0xbb>
  2240e1:	c5 f8 10 05 37 ca fd 	vmovups xmm0,XMMWORD PTR [rip+0xfffffffffffdca37]        # 200b20 <__unnamed_51>
  2240e8:	ff 
  2240e9:	eb 44                	jmp    22412f <File_read+0xff>
                        else => return os.unexpectedErrorPosix(read_err),
  2240eb:	66 41 c7 00 03 00    	mov    WORD PTR [r8],0x3
  2240f1:	48 8b 44 24 f2       	mov    rax,QWORD PTR [rsp-0xe]
  2240f6:	48 8b 4c 24 f8       	mov    rcx,QWORD PTR [rsp-0x8]
  2240fb:	49 89 48 08          	mov    QWORD PTR [r8+0x8],rcx
  2240ff:	49 89 40 02          	mov    QWORD PTR [r8+0x2],rax
  224103:	5b                   	pop    rbx
  224104:	41 5e                	pop    r14
  224106:	41 5f                	pop    r15
  224108:	c3                   	ret    
                        posix.EIO => return error.InputOutput,
  224109:	c5 f8 10 05 7f ca fd 	vmovups xmm0,XMMWORD PTR [rip+0xfffffffffffdca7f]        # 200b90 <__unnamed_52>
  224110:	ff 
  224111:	eb 1c                	jmp    22412f <File_read+0xff>
                        posix.EBADF => return error.FileClosed,
  224113:	c5 f8 10 05 b5 c4 fd 	vmovups xmm0,XMMWORD PTR [rip+0xfffffffffffdc4b5]        # 2005d0 <__unnamed_53>
  22411a:	ff 
  22411b:	eb 12                	jmp    22412f <File_read+0xff>
                        posix.EAGAIN => return error.WouldBlock,
  22411d:	c5 f8 10 05 5b c5 fd 	vmovups xmm0,XMMWORD PTR [rip+0xfffffffffffdc55b]        # 200680 <__unnamed_54>
  224124:	ff 
  224125:	eb 08                	jmp    22412f <File_read+0xff>
                        posix.EISDIR => return error.IsDir,
  224127:	c5 f8 10 05 f1 c5 fd 	vmovups xmm0,XMMWORD PTR [rip+0xfffffffffffdc5f1]        # 200720 <__unnamed_55>
  22412e:	ff 
  22412f:	c4 c1 78 11 00       	vmovups XMMWORD PTR [r8],xmm0
  224134:	5b                   	pop    rbx
  224135:	41 5e                	pop    r14
  224137:	41 5f                	pop    r15
  224139:	c3                   	ret    
                if (amt_read == 0) return index;
  22413a:	66 41 c7 00 00 00    	mov    WORD PTR [r8],0x0
  224140:	0f b7 44 24 f0       	movzx  eax,WORD PTR [rsp-0x10]
  224145:	66 41 89 40 06       	mov    WORD PTR [r8+0x6],ax
  22414a:	8b 44 24 ec          	mov    eax,DWORD PTR [rsp-0x14]
  22414e:	e9 7a ff ff ff       	jmp    2240cd <File_read+0x9d>
  224153:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  22415a:	84 00 00 00 00 00 

0000000000224160 <FileInStream_readFn>:
    fn readFn(in_stream: *Stream, buffer: []u8) Error!usize {
  224160:	53                   	push   rbx
  224161:	48 83 ec 10          	sub    rsp,0x10
  224165:	48 89 fb             	mov    rbx,rdi
        return self.file.read(buffer);
  224168:	48 8b 76 f8          	mov    rsi,QWORD PTR [rsi-0x8]
  22416c:	48 89 e7             	mov    rdi,rsp
  22416f:	e8 bc fe ff ff       	call   224030 <File_read>
  224174:	c5 f8 10 04 24       	vmovups xmm0,XMMWORD PTR [rsp]
  224179:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  22417d:	48 89 d8             	mov    rax,rbx
  224180:	48 83 c4 10          	add    rsp,0x10
  224184:	5b                   	pop    rbx
  224185:	c3                   	ret    
  224186:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  22418d:	00 00 00 

0000000000224190 <Allocator_alignedRealloc.149>:
    pub fn alignedRealloc(self: *Allocator, comptime T: type, comptime alignment: u29, old_mem: []align(alignment) T, n: usize) ![]align(alignment) T {
  224190:	41 56                	push   r14
  224192:	53                   	push   rbx
  224193:	48 81 ec 88 00 00 00 	sub    rsp,0x88
  22419a:	48 89 fb             	mov    rbx,rdi
        if (old_mem.len == 0) {
  22419d:	48 8b 42 08          	mov    rax,QWORD PTR [rdx+0x8]
  2241a1:	48 85 c0             	test   rax,rax
  2241a4:	74 54                	je     2241fa <Allocator_alignedRealloc.149+0x6a>
        if (n == 0) {
  2241a6:	48 85 c9             	test   rcx,rcx
  2241a9:	0f 84 9b 00 00 00    	je     22424a <Allocator_alignedRealloc.149+0xba>
        const old_byte_slice = @sliceToBytes(old_mem);
  2241af:	48 8b 12             	mov    rdx,QWORD PTR [rdx]
  2241b2:	48 6b c0 38          	imul   rax,rax,0x38
  2241b6:	48 89 54 24 38       	mov    QWORD PTR [rsp+0x38],rdx
  2241bb:	48 89 44 24 40       	mov    QWORD PTR [rsp+0x40],rax
  2241c0:	ba 38 00 00 00       	mov    edx,0x38
    return if (@mulWithOverflow(T, a, b, &answer)) error.Overflow else answer;
  2241c5:	48 89 c8             	mov    rax,rcx
  2241c8:	48 f7 e2             	mul    rdx
  2241cb:	0f 81 c2 00 00 00    	jno    224293 <Allocator_alignedRealloc.149+0x103>
  2241d1:	48 8d 0d e8 c2 fd ff 	lea    rcx,[rip+0xfffffffffffdc2e8]        # 2004c0 <__unnamed_27>
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  2241d8:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  2241dc:	0f 84 cc 00 00 00    	je     2242ae <Allocator_alignedRealloc.149+0x11e>
  2241e2:	48 8b 05 7f 40 fe ff 	mov    rax,QWORD PTR [rip+0xfffffffffffe407f]        # 208268 <__unnamed_56+0x10>
  2241e9:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  2241ed:	c5 f8 10 05 63 40 fe 	vmovups xmm0,XMMWORD PTR [rip+0xfffffffffffe4063]        # 208258 <__unnamed_56>
  2241f4:	ff 
  2241f5:	e9 8a 00 00 00       	jmp    224284 <Allocator_alignedRealloc.149+0xf4>
        if (n == 0) {
  2241fa:	48 85 c9             	test   rcx,rcx
  2241fd:	0f 84 f8 00 00 00    	je     2242fb <Allocator_alignedRealloc.149+0x16b>
  224203:	ba 38 00 00 00       	mov    edx,0x38
  224208:	48 89 c8             	mov    rax,rcx
  22420b:	48 f7 e2             	mul    rdx
  22420e:	0f 81 08 01 00 00    	jno    22431c <Allocator_alignedRealloc.149+0x18c>
  224214:	48 8d 0d a5 c2 fd ff 	lea    rcx,[rip+0xfffffffffffdc2a5]        # 2004c0 <__unnamed_27>
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  22421b:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  22421f:	0f 84 12 01 00 00    	je     224337 <Allocator_alignedRealloc.149+0x1a7>
  224225:	0f b7 05 32 40 fe ff 	movzx  eax,WORD PTR [rip+0xfffffffffffe4032]        # 20825e <__unnamed_56+0x6>
  22422c:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  224231:	8b 05 23 40 fe ff    	mov    eax,DWORD PTR [rip+0xfffffffffffe4023]        # 20825a <__unnamed_56+0x2>
  224237:	89 04 24             	mov    DWORD PTR [rsp],eax
  22423a:	48 89 e0             	mov    rax,rsp
  22423d:	66 b9 01 00          	mov    cx,0x1
  224241:	31 f6                	xor    esi,esi
  224243:	31 d2                	xor    edx,edx
  224245:	e9 a9 01 00 00       	jmp    2243f3 <Allocator_alignedRealloc.149+0x263>
        const bytes = @sliceToBytes(memory);
  22424a:	48 6b c0 38          	imul   rax,rax,0x38
        if (bytes.len == 0) return;
  22424e:	48 85 c0             	test   rax,rax
  224251:	74 1e                	je     224271 <Allocator_alignedRealloc.149+0xe1>
        const bytes = @sliceToBytes(memory);
  224253:	48 8b 0a             	mov    rcx,QWORD PTR [rdx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  224256:	48 8b 56 10          	mov    rdx,QWORD PTR [rsi+0x10]
  22425a:	48 89 4c 24 08       	mov    QWORD PTR [rsp+0x8],rcx
  22425f:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  224264:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  224269:	48 89 f7             	mov    rdi,rsi
  22426c:	48 89 c6             	mov    rsi,rax
  22426f:	ff d2                	call   rdx
            return ([*]align(alignment) T)(undefined)[0..0];
  224271:	48 8b 05 d8 3f fe ff 	mov    rax,QWORD PTR [rip+0xfffffffffffe3fd8]        # 208250 <__unnamed_57+0x10>
  224278:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  22427c:	c5 f8 10 05 bc 3f fe 	vmovups xmm0,XMMWORD PTR [rip+0xfffffffffffe3fbc]        # 208240 <__unnamed_57>
  224283:	ff 
  224284:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  224288:	48 81 c4 88 00 00 00 	add    rsp,0x88
  22428f:	5b                   	pop    rbx
  224290:	41 5e                	pop    r14
  224292:	c3                   	ret    
  224293:	48 8d 4c 24 08       	lea    rcx,[rsp+0x8]
  224298:	66 c7 44 24 08 00 00 	mov    WORD PTR [rsp+0x8],0x0
  22429f:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  2242a4:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  2242a8:	0f 85 34 ff ff ff    	jne    2241e2 <Allocator_alignedRealloc.149+0x52>
  2242ae:	4c 8b 71 08          	mov    r14,QWORD PTR [rcx+0x8]
  2242b2:	48 8d 7c 24 58       	lea    rdi,[rsp+0x58]
  2242b7:	48 8d 54 24 38       	lea    rdx,[rsp+0x38]
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  2242bc:	41 b8 01 00 00 00    	mov    r8d,0x1
  2242c2:	4c 89 f1             	mov    rcx,r14
  2242c5:	ff 56 08             	call   QWORD PTR [rsi+0x8]
  2242c8:	0f b7 44 24 58       	movzx  eax,WORD PTR [rsp+0x58]
  2242cd:	66 85 c0             	test   ax,ax
  2242d0:	0f 84 97 00 00 00    	je     22436d <Allocator_alignedRealloc.149+0x1dd>
  2242d6:	66 89 03             	mov    WORD PTR [rbx],ax
  2242d9:	48 8b 84 24 80 00 00 	mov    rax,QWORD PTR [rsp+0x80]
  2242e0:	00 
  2242e1:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  2242e5:	c5 f8 10 44 24 72    	vmovups xmm0,XMMWORD PTR [rsp+0x72]
  2242eb:	c5 f8 11 43 02       	vmovups XMMWORD PTR [rbx+0x2],xmm0
  2242f0:	48 81 c4 88 00 00 00 	add    rsp,0x88
  2242f7:	5b                   	pop    rbx
  2242f8:	41 5e                	pop    r14
  2242fa:	c3                   	ret    
  2242fb:	48 89 e0             	mov    rax,rsp
            return ([*]align(alignment) T)(undefined)[0..0];
  2242fe:	0f b7 0d 41 3f fe ff 	movzx  ecx,WORD PTR [rip+0xfffffffffffe3f41]        # 208246 <__unnamed_57+0x6>
  224305:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  22430a:	8b 0d 32 3f fe ff    	mov    ecx,DWORD PTR [rip+0xfffffffffffe3f32]        # 208242 <__unnamed_57+0x2>
  224310:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  224313:	31 c9                	xor    ecx,ecx
  224315:	31 d2                	xor    edx,edx
  224317:	e9 d7 00 00 00       	jmp    2243f3 <Allocator_alignedRealloc.149+0x263>
  22431c:	48 8d 4c 24 48       	lea    rcx,[rsp+0x48]
  224321:	66 c7 44 24 48 00 00 	mov    WORD PTR [rsp+0x48],0x0
  224328:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  22432d:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  224331:	0f 85 ee fe ff ff    	jne    224225 <Allocator_alignedRealloc.149+0x95>
  224337:	4c 8b 71 08          	mov    r14,QWORD PTR [rcx+0x8]
  22433b:	48 8d 7c 24 08       	lea    rdi,[rsp+0x8]
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  224340:	b9 01 00 00 00       	mov    ecx,0x1
  224345:	4c 89 f2             	mov    rdx,r14
  224348:	ff 16                	call   QWORD PTR [rsi]
  22434a:	0f b7 4c 24 08       	movzx  ecx,WORD PTR [rsp+0x8]
  22434f:	66 85 c9             	test   cx,cx
  224352:	74 67                	je     2243bb <Allocator_alignedRealloc.149+0x22b>
  224354:	0f b7 44 24 36       	movzx  eax,WORD PTR [rsp+0x36]
  224359:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  22435e:	48 89 e0             	mov    rax,rsp
  224361:	8b 54 24 32          	mov    edx,DWORD PTR [rsp+0x32]
  224365:	89 14 24             	mov    DWORD PTR [rsp],edx
  224368:	e9 86 00 00 00       	jmp    2243f3 <Allocator_alignedRealloc.149+0x263>
        assert(byte_slice.len == byte_count);
  22436d:	4c 39 74 24 68       	cmp    QWORD PTR [rsp+0x68],r14
    if (!ok) {
  224372:	0f 85 9e 00 00 00    	jne    224416 <Allocator_alignedRealloc.149+0x286>
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  224378:	49 c1 ee 03          	shr    r14,0x3
  22437c:	48 b8 93 24 49 92 24 	movabs rax,0x2492492492492493
  224383:	49 92 24 
  224386:	4c 89 f2             	mov    rdx,r14
  224389:	c4 e2 f3 f6 c0       	mulx   rax,rcx,rax
  22438e:	66 c7 03 00 00       	mov    WORD PTR [rbx],0x0
  224393:	0f b7 4c 24 2a       	movzx  ecx,WORD PTR [rsp+0x2a]
  224398:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  22439c:	48 8b 4c 24 60       	mov    rcx,QWORD PTR [rsp+0x60]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  2243a1:	8b 54 24 26          	mov    edx,DWORD PTR [rsp+0x26]
  2243a5:	89 53 02             	mov    DWORD PTR [rbx+0x2],edx
  2243a8:	48 89 4b 08          	mov    QWORD PTR [rbx+0x8],rcx
  2243ac:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  2243b0:	48 81 c4 88 00 00 00 	add    rsp,0x88
  2243b7:	5b                   	pop    rbx
  2243b8:	41 5e                	pop    r14
  2243ba:	c3                   	ret    
        assert(byte_slice.len == byte_count);
  2243bb:	4c 39 74 24 18       	cmp    QWORD PTR [rsp+0x18],r14
  2243c0:	75 54                	jne    224416 <Allocator_alignedRealloc.149+0x286>
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  2243c2:	48 8b 74 24 10       	mov    rsi,QWORD PTR [rsp+0x10]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  2243c7:	49 c1 ee 03          	shr    r14,0x3
  2243cb:	48 b8 93 24 49 92 24 	movabs rax,0x2492492492492493
  2243d2:	49 92 24 
  2243d5:	4c 89 f2             	mov    rdx,r14
  2243d8:	c4 e2 fb f6 d0       	mulx   rdx,rax,rax
  2243dd:	48 89 e0             	mov    rax,rsp
  2243e0:	8b 4c 24 2c          	mov    ecx,DWORD PTR [rsp+0x2c]
  2243e4:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  2243e7:	0f b7 4c 24 30       	movzx  ecx,WORD PTR [rsp+0x30]
  2243ec:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  2243f1:	31 c9                	xor    ecx,ecx
            return self.alignedAlloc(T, alignment, n);
  2243f3:	66 89 0b             	mov    WORD PTR [rbx],cx
  2243f6:	0f b7 48 04          	movzx  ecx,WORD PTR [rax+0x4]
  2243fa:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  2243fe:	8b 00                	mov    eax,DWORD PTR [rax]
  224400:	89 43 02             	mov    DWORD PTR [rbx+0x2],eax
  224403:	48 89 73 08          	mov    QWORD PTR [rbx+0x8],rsi
  224407:	48 89 53 10          	mov    QWORD PTR [rbx+0x10],rdx
  22440b:	48 81 c4 88 00 00 00 	add    rsp,0x88
  224412:	5b                   	pop    rbx
  224413:	41 5e                	pop    r14
  224415:	c3                   	ret    
            @panic("assertion failure");
  224416:	48 8d 3d 73 b9 02 00 	lea    rdi,[rip+0x2b973]        # 24fd90 <__unnamed_2>
  22441d:	e8 fe e2 fe ff       	call   212720 <panic>
  224422:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  224429:	1f 84 00 00 00 00 00 

0000000000224430 <Allocator_alignedRealloc.152>:
    pub fn alignedRealloc(self: *Allocator, comptime T: type, comptime alignment: u29, old_mem: []align(alignment) T, n: usize) ![]align(alignment) T {
  224430:	41 56                	push   r14
  224432:	53                   	push   rbx
  224433:	48 81 ec 88 00 00 00 	sub    rsp,0x88
  22443a:	48 89 fb             	mov    rbx,rdi
        if (old_mem.len == 0) {
  22443d:	48 8b 42 08          	mov    rax,QWORD PTR [rdx+0x8]
  224441:	48 85 c0             	test   rax,rax
  224444:	74 5e                	je     2244a4 <Allocator_alignedRealloc.152+0x74>
        if (n == 0) {
  224446:	48 85 c9             	test   rcx,rcx
  224449:	0f 84 a6 00 00 00    	je     2244f5 <Allocator_alignedRealloc.152+0xc5>
        const old_byte_slice = @sliceToBytes(old_mem);
  22444f:	48 8b 12             	mov    rdx,QWORD PTR [rdx]
  224452:	48 c1 e0 04          	shl    rax,0x4
  224456:	48 89 54 24 38       	mov    QWORD PTR [rsp+0x38],rdx
  22445b:	48 89 44 24 40       	mov    QWORD PTR [rsp+0x40],rax
  224460:	ba 10 00 00 00       	mov    edx,0x10
  224465:	48 89 c8             	mov    rax,rcx
  224468:	48 f7 e2             	mul    rdx
  22446b:	0f 81 ca 00 00 00    	jno    22453b <Allocator_alignedRealloc.152+0x10b>
  224471:	48 8d 0d 48 c0 fd ff 	lea    rcx,[rip+0xfffffffffffdc048]        # 2004c0 <__unnamed_27>
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  224478:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  22447c:	0f 84 d4 00 00 00    	je     224556 <Allocator_alignedRealloc.152+0x126>
  224482:	48 8b 05 0f 3e fe ff 	mov    rax,QWORD PTR [rip+0xfffffffffffe3e0f]        # 208298 <__unnamed_58+0x10>
  224489:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  22448d:	c5 f8 10 05 f3 3d fe 	vmovups xmm0,XMMWORD PTR [rip+0xfffffffffffe3df3]        # 208288 <__unnamed_58>
  224494:	ff 
  224495:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  224499:	48 81 c4 88 00 00 00 	add    rsp,0x88
  2244a0:	5b                   	pop    rbx
  2244a1:	41 5e                	pop    r14
  2244a3:	c3                   	ret    
        if (n == 0) {
  2244a4:	48 85 c9             	test   rcx,rcx
  2244a7:	0f 84 f6 00 00 00    	je     2245a3 <Allocator_alignedRealloc.152+0x173>
  2244ad:	ba 10 00 00 00       	mov    edx,0x10
  2244b2:	48 89 c8             	mov    rax,rcx
  2244b5:	48 f7 e2             	mul    rdx
  2244b8:	0f 81 07 01 00 00    	jno    2245c5 <Allocator_alignedRealloc.152+0x195>
  2244be:	48 8d 0d fb bf fd ff 	lea    rcx,[rip+0xfffffffffffdbffb]        # 2004c0 <__unnamed_27>
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  2244c5:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  2244c9:	0f 84 11 01 00 00    	je     2245e0 <Allocator_alignedRealloc.152+0x1b0>
  2244cf:	0f b7 05 b8 3d fe ff 	movzx  eax,WORD PTR [rip+0xfffffffffffe3db8]        # 20828e <__unnamed_58+0x6>
  2244d6:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  2244db:	8b 05 a9 3d fe ff    	mov    eax,DWORD PTR [rip+0xfffffffffffe3da9]        # 20828a <__unnamed_58+0x2>
  2244e1:	89 04 24             	mov    DWORD PTR [rsp],eax
  2244e4:	48 89 e0             	mov    rax,rsp
  2244e7:	66 b9 01 00          	mov    cx,0x1
  2244eb:	31 d2                	xor    edx,edx
  2244ed:	45 31 f6             	xor    r14d,r14d
  2244f0:	e9 6f 01 00 00       	jmp    224664 <Allocator_alignedRealloc.152+0x234>
        const bytes = @sliceToBytes(memory);
  2244f5:	48 c1 e0 04          	shl    rax,0x4
        if (bytes.len == 0) return;
  2244f9:	74 1e                	je     224519 <Allocator_alignedRealloc.152+0xe9>
        const bytes = @sliceToBytes(memory);
  2244fb:	48 8b 0a             	mov    rcx,QWORD PTR [rdx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  2244fe:	48 8b 56 10          	mov    rdx,QWORD PTR [rsi+0x10]
  224502:	48 89 4c 24 08       	mov    QWORD PTR [rsp+0x8],rcx
  224507:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  22450c:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  224511:	48 89 f7             	mov    rdi,rsi
  224514:	48 89 c6             	mov    rsi,rax
  224517:	ff d2                	call   rdx
            return ([*]align(alignment) T)(undefined)[0..0];
  224519:	48 8b 05 60 3d fe ff 	mov    rax,QWORD PTR [rip+0xfffffffffffe3d60]        # 208280 <__unnamed_59+0x10>
  224520:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  224524:	c5 f8 10 05 44 3d fe 	vmovups xmm0,XMMWORD PTR [rip+0xfffffffffffe3d44]        # 208270 <__unnamed_59>
  22452b:	ff 
  22452c:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  224530:	48 81 c4 88 00 00 00 	add    rsp,0x88
  224537:	5b                   	pop    rbx
  224538:	41 5e                	pop    r14
  22453a:	c3                   	ret    
  22453b:	48 8d 4c 24 08       	lea    rcx,[rsp+0x8]
  224540:	66 c7 44 24 08 00 00 	mov    WORD PTR [rsp+0x8],0x0
  224547:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  22454c:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  224550:	0f 85 2c ff ff ff    	jne    224482 <Allocator_alignedRealloc.152+0x52>
  224556:	4c 8b 71 08          	mov    r14,QWORD PTR [rcx+0x8]
  22455a:	48 8d 7c 24 58       	lea    rdi,[rsp+0x58]
  22455f:	48 8d 54 24 38       	lea    rdx,[rsp+0x38]
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  224564:	41 b8 08 00 00 00    	mov    r8d,0x8
  22456a:	4c 89 f1             	mov    rcx,r14
  22456d:	ff 56 08             	call   QWORD PTR [rsi+0x8]
  224570:	0f b7 44 24 58       	movzx  eax,WORD PTR [rsp+0x58]
  224575:	66 85 c0             	test   ax,ax
  224578:	0f 84 95 00 00 00    	je     224613 <Allocator_alignedRealloc.152+0x1e3>
  22457e:	66 89 03             	mov    WORD PTR [rbx],ax
  224581:	48 8b 84 24 80 00 00 	mov    rax,QWORD PTR [rsp+0x80]
  224588:	00 
  224589:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  22458d:	c5 f8 10 44 24 72    	vmovups xmm0,XMMWORD PTR [rsp+0x72]
  224593:	c5 f8 11 43 02       	vmovups XMMWORD PTR [rbx+0x2],xmm0
  224598:	48 81 c4 88 00 00 00 	add    rsp,0x88
  22459f:	5b                   	pop    rbx
  2245a0:	41 5e                	pop    r14
  2245a2:	c3                   	ret    
  2245a3:	48 89 e0             	mov    rax,rsp
            return ([*]align(alignment) T)(undefined)[0..0];
  2245a6:	0f b7 0d c9 3c fe ff 	movzx  ecx,WORD PTR [rip+0xfffffffffffe3cc9]        # 208276 <__unnamed_59+0x6>
  2245ad:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  2245b2:	8b 0d ba 3c fe ff    	mov    ecx,DWORD PTR [rip+0xfffffffffffe3cba]        # 208272 <__unnamed_59+0x2>
  2245b8:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  2245bb:	31 c9                	xor    ecx,ecx
  2245bd:	45 31 f6             	xor    r14d,r14d
  2245c0:	e9 9f 00 00 00       	jmp    224664 <Allocator_alignedRealloc.152+0x234>
  2245c5:	48 8d 4c 24 48       	lea    rcx,[rsp+0x48]
  2245ca:	66 c7 44 24 48 00 00 	mov    WORD PTR [rsp+0x48],0x0
  2245d1:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  2245d6:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  2245da:	0f 85 ef fe ff ff    	jne    2244cf <Allocator_alignedRealloc.152+0x9f>
  2245e0:	4c 8b 71 08          	mov    r14,QWORD PTR [rcx+0x8]
  2245e4:	48 8d 7c 24 08       	lea    rdi,[rsp+0x8]
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  2245e9:	b9 08 00 00 00       	mov    ecx,0x8
  2245ee:	4c 89 f2             	mov    rdx,r14
  2245f1:	ff 16                	call   QWORD PTR [rsi]
  2245f3:	0f b7 4c 24 08       	movzx  ecx,WORD PTR [rsp+0x8]
  2245f8:	66 85 c9             	test   cx,cx
  2245fb:	74 41                	je     22463e <Allocator_alignedRealloc.152+0x20e>
  2245fd:	0f b7 44 24 36       	movzx  eax,WORD PTR [rsp+0x36]
  224602:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  224607:	48 89 e0             	mov    rax,rsp
  22460a:	8b 54 24 32          	mov    edx,DWORD PTR [rsp+0x32]
  22460e:	89 14 24             	mov    DWORD PTR [rsp],edx
  224611:	eb 51                	jmp    224664 <Allocator_alignedRealloc.152+0x234>
        assert(byte_slice.len == byte_count);
  224613:	4c 39 74 24 68       	cmp    QWORD PTR [rsp+0x68],r14
    if (!ok) {
  224618:	75 6d                	jne    224687 <Allocator_alignedRealloc.152+0x257>
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  22461a:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  22461f:	66 c7 03 00 00       	mov    WORD PTR [rbx],0x0
  224624:	0f b7 4c 24 2a       	movzx  ecx,WORD PTR [rsp+0x2a]
  224629:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  22462d:	49 c1 ee 04          	shr    r14,0x4
  224631:	8b 4c 24 26          	mov    ecx,DWORD PTR [rsp+0x26]
  224635:	89 4b 02             	mov    DWORD PTR [rbx+0x2],ecx
  224638:	48 89 43 08          	mov    QWORD PTR [rbx+0x8],rax
  22463c:	eb 3a                	jmp    224678 <Allocator_alignedRealloc.152+0x248>
        assert(byte_slice.len == byte_count);
  22463e:	4c 39 74 24 18       	cmp    QWORD PTR [rsp+0x18],r14
  224643:	75 42                	jne    224687 <Allocator_alignedRealloc.152+0x257>
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  224645:	48 8b 54 24 10       	mov    rdx,QWORD PTR [rsp+0x10]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  22464a:	49 c1 ee 04          	shr    r14,0x4
  22464e:	48 89 e0             	mov    rax,rsp
  224651:	8b 4c 24 2c          	mov    ecx,DWORD PTR [rsp+0x2c]
  224655:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  224658:	0f b7 4c 24 30       	movzx  ecx,WORD PTR [rsp+0x30]
  22465d:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  224662:	31 c9                	xor    ecx,ecx
            return self.alignedAlloc(T, alignment, n);
  224664:	66 89 0b             	mov    WORD PTR [rbx],cx
  224667:	0f b7 48 04          	movzx  ecx,WORD PTR [rax+0x4]
  22466b:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  22466f:	8b 00                	mov    eax,DWORD PTR [rax]
  224671:	89 43 02             	mov    DWORD PTR [rbx+0x2],eax
  224674:	48 89 53 08          	mov    QWORD PTR [rbx+0x8],rdx
  224678:	4c 89 73 10          	mov    QWORD PTR [rbx+0x10],r14
  22467c:	48 81 c4 88 00 00 00 	add    rsp,0x88
  224683:	5b                   	pop    rbx
  224684:	41 5e                	pop    r14
  224686:	c3                   	ret    
            @panic("assertion failure");
  224687:	48 8d 3d 02 b7 02 00 	lea    rdi,[rip+0x2b702]        # 24fd90 <__unnamed_2>
  22468e:	e8 8d e0 fe ff       	call   212720 <panic>
  224693:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  22469a:	84 00 00 00 00 00 

00000000002246a0 <Allocator_alignedRealloc.155>:
    pub fn alignedRealloc(self: *Allocator, comptime T: type, comptime alignment: u29, old_mem: []align(alignment) T, n: usize) ![]align(alignment) T {
  2246a0:	41 56                	push   r14
  2246a2:	53                   	push   rbx
  2246a3:	48 81 ec 88 00 00 00 	sub    rsp,0x88
  2246aa:	48 89 fb             	mov    rbx,rdi
        if (old_mem.len == 0) {
  2246ad:	48 8b 42 08          	mov    rax,QWORD PTR [rdx+0x8]
  2246b1:	48 85 c0             	test   rax,rax
  2246b4:	74 62                	je     224718 <Allocator_alignedRealloc.155+0x78>
        if (n == 0) {
  2246b6:	48 85 c9             	test   rcx,rcx
  2246b9:	0f 84 a9 00 00 00    	je     224768 <Allocator_alignedRealloc.155+0xc8>
        const old_byte_slice = @sliceToBytes(old_mem);
  2246bf:	48 8b 12             	mov    rdx,QWORD PTR [rdx]
  2246c2:	48 c1 e0 03          	shl    rax,0x3
  2246c6:	48 8d 04 80          	lea    rax,[rax+rax*4]
  2246ca:	48 89 54 24 38       	mov    QWORD PTR [rsp+0x38],rdx
  2246cf:	48 89 44 24 40       	mov    QWORD PTR [rsp+0x40],rax
  2246d4:	ba 28 00 00 00       	mov    edx,0x28
  2246d9:	48 89 c8             	mov    rax,rcx
  2246dc:	48 f7 e2             	mul    rdx
  2246df:	0f 81 d0 00 00 00    	jno    2247b5 <Allocator_alignedRealloc.155+0x115>
  2246e5:	48 8d 0d d4 bd fd ff 	lea    rcx,[rip+0xfffffffffffdbdd4]        # 2004c0 <__unnamed_27>
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  2246ec:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  2246f0:	0f 84 da 00 00 00    	je     2247d0 <Allocator_alignedRealloc.155+0x130>
  2246f6:	48 8b 05 cb 3b fe ff 	mov    rax,QWORD PTR [rip+0xfffffffffffe3bcb]        # 2082c8 <__unnamed_60+0x10>
  2246fd:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  224701:	c5 f8 10 05 af 3b fe 	vmovups xmm0,XMMWORD PTR [rip+0xfffffffffffe3baf]        # 2082b8 <__unnamed_60>
  224708:	ff 
  224709:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  22470d:	48 81 c4 88 00 00 00 	add    rsp,0x88
  224714:	5b                   	pop    rbx
  224715:	41 5e                	pop    r14
  224717:	c3                   	ret    
        if (n == 0) {
  224718:	48 85 c9             	test   rcx,rcx
  22471b:	0f 84 fc 00 00 00    	je     22481d <Allocator_alignedRealloc.155+0x17d>
  224721:	ba 28 00 00 00       	mov    edx,0x28
  224726:	48 89 c8             	mov    rax,rcx
  224729:	48 f7 e2             	mul    rdx
  22472c:	0f 81 0c 01 00 00    	jno    22483e <Allocator_alignedRealloc.155+0x19e>
  224732:	48 8d 0d 87 bd fd ff 	lea    rcx,[rip+0xfffffffffffdbd87]        # 2004c0 <__unnamed_27>
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  224739:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  22473d:	0f 84 16 01 00 00    	je     224859 <Allocator_alignedRealloc.155+0x1b9>
  224743:	0f b7 05 74 3b fe ff 	movzx  eax,WORD PTR [rip+0xfffffffffffe3b74]        # 2082be <__unnamed_60+0x6>
  22474a:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  22474f:	8b 05 65 3b fe ff    	mov    eax,DWORD PTR [rip+0xfffffffffffe3b65]        # 2082ba <__unnamed_60+0x2>
  224755:	89 04 24             	mov    DWORD PTR [rsp],eax
  224758:	48 89 e0             	mov    rax,rsp
  22475b:	66 b9 01 00          	mov    cx,0x1
  22475f:	31 f6                	xor    esi,esi
  224761:	31 d2                	xor    edx,edx
  224763:	e9 9d 01 00 00       	jmp    224905 <Allocator_alignedRealloc.155+0x265>
        const bytes = @sliceToBytes(memory);
  224768:	48 c1 e0 03          	shl    rax,0x3
  22476c:	48 8d 04 80          	lea    rax,[rax+rax*4]
        if (bytes.len == 0) return;
  224770:	48 85 c0             	test   rax,rax
  224773:	74 1e                	je     224793 <Allocator_alignedRealloc.155+0xf3>
        const bytes = @sliceToBytes(memory);
  224775:	48 8b 0a             	mov    rcx,QWORD PTR [rdx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  224778:	48 8b 56 10          	mov    rdx,QWORD PTR [rsi+0x10]
  22477c:	48 89 4c 24 08       	mov    QWORD PTR [rsp+0x8],rcx
  224781:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  224786:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  22478b:	48 89 f7             	mov    rdi,rsi
  22478e:	48 89 c6             	mov    rsi,rax
  224791:	ff d2                	call   rdx
            return ([*]align(alignment) T)(undefined)[0..0];
  224793:	48 8b 05 16 3b fe ff 	mov    rax,QWORD PTR [rip+0xfffffffffffe3b16]        # 2082b0 <__unnamed_61+0x10>
  22479a:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  22479e:	c5 f8 10 05 fa 3a fe 	vmovups xmm0,XMMWORD PTR [rip+0xfffffffffffe3afa]        # 2082a0 <__unnamed_61>
  2247a5:	ff 
  2247a6:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  2247aa:	48 81 c4 88 00 00 00 	add    rsp,0x88
  2247b1:	5b                   	pop    rbx
  2247b2:	41 5e                	pop    r14
  2247b4:	c3                   	ret    
  2247b5:	48 8d 4c 24 08       	lea    rcx,[rsp+0x8]
  2247ba:	66 c7 44 24 08 00 00 	mov    WORD PTR [rsp+0x8],0x0
  2247c1:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  2247c6:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  2247ca:	0f 85 26 ff ff ff    	jne    2246f6 <Allocator_alignedRealloc.155+0x56>
  2247d0:	4c 8b 71 08          	mov    r14,QWORD PTR [rcx+0x8]
  2247d4:	48 8d 7c 24 58       	lea    rdi,[rsp+0x58]
  2247d9:	48 8d 54 24 38       	lea    rdx,[rsp+0x38]
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  2247de:	41 b8 08 00 00 00    	mov    r8d,0x8
  2247e4:	4c 89 f1             	mov    rcx,r14
  2247e7:	ff 56 08             	call   QWORD PTR [rsi+0x8]
  2247ea:	0f b7 44 24 58       	movzx  eax,WORD PTR [rsp+0x58]
  2247ef:	66 85 c0             	test   ax,ax
  2247f2:	0f 84 94 00 00 00    	je     22488c <Allocator_alignedRealloc.155+0x1ec>
  2247f8:	66 89 03             	mov    WORD PTR [rbx],ax
  2247fb:	48 8b 84 24 80 00 00 	mov    rax,QWORD PTR [rsp+0x80]
  224802:	00 
  224803:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  224807:	c5 f8 10 44 24 72    	vmovups xmm0,XMMWORD PTR [rsp+0x72]
  22480d:	c5 f8 11 43 02       	vmovups XMMWORD PTR [rbx+0x2],xmm0
  224812:	48 81 c4 88 00 00 00 	add    rsp,0x88
  224819:	5b                   	pop    rbx
  22481a:	41 5e                	pop    r14
  22481c:	c3                   	ret    
  22481d:	48 89 e0             	mov    rax,rsp
            return ([*]align(alignment) T)(undefined)[0..0];
  224820:	0f b7 0d 7f 3a fe ff 	movzx  ecx,WORD PTR [rip+0xfffffffffffe3a7f]        # 2082a6 <__unnamed_61+0x6>
  224827:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  22482c:	8b 0d 70 3a fe ff    	mov    ecx,DWORD PTR [rip+0xfffffffffffe3a70]        # 2082a2 <__unnamed_61+0x2>
  224832:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  224835:	31 c9                	xor    ecx,ecx
  224837:	31 d2                	xor    edx,edx
  224839:	e9 c7 00 00 00       	jmp    224905 <Allocator_alignedRealloc.155+0x265>
  22483e:	48 8d 4c 24 48       	lea    rcx,[rsp+0x48]
  224843:	66 c7 44 24 48 00 00 	mov    WORD PTR [rsp+0x48],0x0
  22484a:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  22484f:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  224853:	0f 85 ea fe ff ff    	jne    224743 <Allocator_alignedRealloc.155+0xa3>
  224859:	4c 8b 71 08          	mov    r14,QWORD PTR [rcx+0x8]
  22485d:	48 8d 7c 24 08       	lea    rdi,[rsp+0x8]
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  224862:	b9 08 00 00 00       	mov    ecx,0x8
  224867:	4c 89 f2             	mov    rdx,r14
  22486a:	ff 16                	call   QWORD PTR [rsi]
  22486c:	0f b7 4c 24 08       	movzx  ecx,WORD PTR [rsp+0x8]
  224871:	66 85 c9             	test   cx,cx
  224874:	74 57                	je     2248cd <Allocator_alignedRealloc.155+0x22d>
  224876:	0f b7 44 24 36       	movzx  eax,WORD PTR [rsp+0x36]
  22487b:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  224880:	48 89 e0             	mov    rax,rsp
  224883:	8b 54 24 32          	mov    edx,DWORD PTR [rsp+0x32]
  224887:	89 14 24             	mov    DWORD PTR [rsp],edx
  22488a:	eb 79                	jmp    224905 <Allocator_alignedRealloc.155+0x265>
        assert(byte_slice.len == byte_count);
  22488c:	4c 39 74 24 68       	cmp    QWORD PTR [rsp+0x68],r14
    if (!ok) {
  224891:	0f 85 91 00 00 00    	jne    224928 <Allocator_alignedRealloc.155+0x288>
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  224897:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  22489c:	48 b9 cd cc cc cc cc 	movabs rcx,0xcccccccccccccccd
  2248a3:	cc cc cc 
  2248a6:	4c 89 f2             	mov    rdx,r14
  2248a9:	c4 e2 f3 f6 d1       	mulx   rdx,rcx,rcx
  2248ae:	66 c7 03 00 00       	mov    WORD PTR [rbx],0x0
  2248b3:	0f b7 4c 24 2a       	movzx  ecx,WORD PTR [rsp+0x2a]
  2248b8:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  2248bc:	48 c1 ea 05          	shr    rdx,0x5
  2248c0:	8b 4c 24 26          	mov    ecx,DWORD PTR [rsp+0x26]
  2248c4:	89 4b 02             	mov    DWORD PTR [rbx+0x2],ecx
  2248c7:	48 89 43 08          	mov    QWORD PTR [rbx+0x8],rax
  2248cb:	eb 4c                	jmp    224919 <Allocator_alignedRealloc.155+0x279>
        assert(byte_slice.len == byte_count);
  2248cd:	4c 39 74 24 18       	cmp    QWORD PTR [rsp+0x18],r14
  2248d2:	75 54                	jne    224928 <Allocator_alignedRealloc.155+0x288>
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  2248d4:	48 8b 74 24 10       	mov    rsi,QWORD PTR [rsp+0x10]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  2248d9:	48 b8 cd cc cc cc cc 	movabs rax,0xcccccccccccccccd
  2248e0:	cc cc cc 
  2248e3:	4c 89 f2             	mov    rdx,r14
  2248e6:	c4 e2 fb f6 d0       	mulx   rdx,rax,rax
  2248eb:	48 c1 ea 05          	shr    rdx,0x5
  2248ef:	48 89 e0             	mov    rax,rsp
  2248f2:	8b 4c 24 2c          	mov    ecx,DWORD PTR [rsp+0x2c]
  2248f6:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  2248f9:	0f b7 4c 24 30       	movzx  ecx,WORD PTR [rsp+0x30]
  2248fe:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  224903:	31 c9                	xor    ecx,ecx
            return self.alignedAlloc(T, alignment, n);
  224905:	66 89 0b             	mov    WORD PTR [rbx],cx
  224908:	0f b7 48 04          	movzx  ecx,WORD PTR [rax+0x4]
  22490c:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  224910:	8b 00                	mov    eax,DWORD PTR [rax]
  224912:	89 43 02             	mov    DWORD PTR [rbx+0x2],eax
  224915:	48 89 73 08          	mov    QWORD PTR [rbx+0x8],rsi
  224919:	48 89 53 10          	mov    QWORD PTR [rbx+0x10],rdx
  22491d:	48 81 c4 88 00 00 00 	add    rsp,0x88
  224924:	5b                   	pop    rbx
  224925:	41 5e                	pop    r14
  224927:	c3                   	ret    
            @panic("assertion failure");
  224928:	48 8d 3d 61 b4 02 00 	lea    rdi,[rip+0x2b461]        # 24fd90 <__unnamed_2>
  22492f:	e8 ec dd fe ff       	call   212720 <panic>
  224934:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  22493b:	00 00 00 00 00 

0000000000224940 <parseFormValue>:
fn parseFormValue(allocator: *mem.Allocator, in_stream: var, form_id: u64, is_64: bool) ParseFormValueError!FormValue {
  224940:	55                   	push   rbp
  224941:	41 57                	push   r15
  224943:	41 56                	push   r14
  224945:	41 55                	push   r13
  224947:	41 54                	push   r12
  224949:	53                   	push   rbx
  22494a:	48 81 ec 08 07 00 00 	sub    rsp,0x708
  224951:	44 89 c5             	mov    ebp,r8d
  224954:	48 89 cb             	mov    rbx,rcx
  224957:	49 89 d4             	mov    r12,rdx
  22495a:	49 89 f7             	mov    r15,rsi
  22495d:	49 89 fe             	mov    r14,rdi
  224960:	48 8d 05 d1 39 fe ff 	lea    rax,[rip+0xfffffffffffe39d1]        # 208338 <__unnamed_62>
    return switch (form_id) {
  224967:	48 8d 4b ff          	lea    rcx,[rbx-0x1]
  22496b:	48 83 f9 1f          	cmp    rcx,0x1f
  22496f:	0f 87 d1 19 00 00    	ja     226346 <parseFormValue+0x1a06>
  224975:	48 8d 15 f4 c8 fd ff 	lea    rdx,[rip+0xfffffffffffdc8f4]        # 201270 <__unnamed_621+0x5b8>
  22497c:	48 63 0c 8a          	movsxd rcx,DWORD PTR [rdx+rcx*4]
  224980:	48 01 d1             	add    rcx,rdx
  224983:	ff e1                	jmp    rcx
  224985:	4c 89 bc 24 d0 00 00 	mov    QWORD PTR [rsp+0xd0],r15
  22498c:	00 
  22498d:	4c 89 74 24 68       	mov    QWORD PTR [rsp+0x68],r14
  224992:	4c 8d b4 24 b0 00 00 	lea    r14,[rsp+0xb0]
  224999:	00 
            try self.readNoEof(result[0..]);
  22499a:	4c 89 74 24 18       	mov    QWORD PTR [rsp+0x18],r14
  22499f:	48 c7 44 24 20 01 00 	mov    QWORD PTR [rsp+0x20],0x1
  2249a6:	00 00 
  2249a8:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  2249ad:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  2249b2:	4c 89 e6             	mov    rsi,r12
  2249b5:	41 ff 14 24          	call   QWORD PTR [r12]
  2249b9:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  2249be:	66 85 c0             	test   ax,ax
  2249c1:	0f 84 f2 0b 00 00    	je     2255b9 <parseFormValue+0xc79>
  2249c7:	48 8b 4c 24 68       	mov    rcx,QWORD PTR [rsp+0x68]
            const block_len = try readULeb128(in_stream);
  2249cc:	66 89 01             	mov    WORD PTR [rcx],ax
  2249cf:	48 8b 84 24 b4 06 00 	mov    rax,QWORD PTR [rsp+0x6b4]
  2249d6:	00 
  2249d7:	48 89 41 20          	mov    QWORD PTR [rcx+0x20],rax
  2249db:	c5 fc 10 84 24 96 06 	vmovups ymm0,YMMWORD PTR [rsp+0x696]
  2249e2:	00 00 
  2249e4:	c5 fc 11 41 02       	vmovups YMMWORD PTR [rcx+0x2],ymm0
  2249e9:	e9 69 19 00 00       	jmp    226357 <parseFormValue+0x1a17>
  2249ee:	48 8d 44 24 78       	lea    rax,[rsp+0x78]
            try self.readNoEof(bytes[0..]);
  2249f3:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  2249f8:	48 c7 44 24 20 08 00 	mov    QWORD PTR [rsp+0x20],0x8
  2249ff:	00 00 
  224a01:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  224a06:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  224a0b:	4c 89 e6             	mov    rsi,r12
  224a0e:	41 ff 14 24          	call   QWORD PTR [r12]
  224a12:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  224a17:	66 85 c0             	test   ax,ax
  224a1a:	75 14                	jne    224a30 <parseFormValue+0xf0>
  224a1c:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  224a21:	66 b8 25 00          	mov    ax,0x25
            if (amt_read < buf.len) return error.EndOfStream;
  224a25:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  224a2a:	0f 83 ce 12 00 00    	jae    225cfe <parseFormValue+0x13be>
        DW.FORM_addr => FormValue{ .Address = try parseFormValueTargetAddrSize(in_stream) },
  224a30:	66 41 89 06          	mov    WORD PTR [r14],ax
  224a34:	48 8b 84 24 00 07 00 	mov    rax,QWORD PTR [rsp+0x700]
  224a3b:	00 
  224a3c:	49 89 46 20          	mov    QWORD PTR [r14+0x20],rax
  224a40:	c5 fc 10 84 24 e2 06 	vmovups ymm0,YMMWORD PTR [rsp+0x6e2]
  224a47:	00 00 
  224a49:	e9 0b 0d 00 00       	jmp    225759 <parseFormValue+0xe19>
  224a4e:	48 8d 44 24 78       	lea    rax,[rsp+0x78]
            const input_slice = input_buf[0..size];
  224a53:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  224a58:	48 c7 44 24 20 02 00 	mov    QWORD PTR [rsp+0x20],0x2
  224a5f:	00 00 
  224a61:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  224a66:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  224a6b:	4c 89 e6             	mov    rsi,r12
  224a6e:	41 ff 14 24          	call   QWORD PTR [r12]
  224a72:	0f b7 4c 24 40       	movzx  ecx,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  224a77:	66 85 c9             	test   cx,cx
  224a7a:	75 14                	jne    224a90 <parseFormValue+0x150>
            if (amt_read < buf.len) return error.EndOfStream;
  224a7c:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
  224a81:	66 b9 25 00          	mov    cx,0x25
  224a85:	48 39 44 24 48       	cmp    QWORD PTR [rsp+0x48],rax
  224a8a:	0f 83 d8 12 00 00    	jae    225d68 <parseFormValue+0x1428>
    const block_len = try in_stream.readVarInt(builtin.Endian.Little, usize, size);
  224a90:	66 89 8c 24 90 02 00 	mov    WORD PTR [rsp+0x290],cx
  224a97:	00 
  224a98:	8b 44 24 3a          	mov    eax,DWORD PTR [rsp+0x3a]
  224a9c:	89 84 24 92 02 00 00 	mov    DWORD PTR [rsp+0x292],eax
  224aa3:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  224aa8:	66 89 84 24 96 02 00 	mov    WORD PTR [rsp+0x296],ax
  224aaf:	00 
  224ab0:	8b 44 24 11          	mov    eax,DWORD PTR [rsp+0x11]
  224ab4:	89 84 24 a9 02 00 00 	mov    DWORD PTR [rsp+0x2a9],eax
  224abb:	0f b7 44 24 15       	movzx  eax,WORD PTR [rsp+0x15]
  224ac0:	66 89 84 24 ad 02 00 	mov    WORD PTR [rsp+0x2ad],ax
  224ac7:	00 
  224ac8:	8a 44 24 17          	mov    al,BYTE PTR [rsp+0x17]
  224acc:	88 84 24 af 02 00 00 	mov    BYTE PTR [rsp+0x2af],al
  224ad3:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  224ad7:	89 84 24 b1 02 00 00 	mov    DWORD PTR [rsp+0x2b1],eax
  224ade:	0f b7 44 24 0e       	movzx  eax,WORD PTR [rsp+0xe]
  224ae3:	66 89 84 24 b5 02 00 	mov    WORD PTR [rsp+0x2b5],ax
  224aea:	00 
  224aeb:	8a 44 24 10          	mov    al,BYTE PTR [rsp+0x10]
  224aef:	88 84 24 b7 02 00 00 	mov    BYTE PTR [rsp+0x2b7],al
  224af6:	48 8d 84 24 90 02 00 	lea    rax,[rsp+0x290]
  224afd:	00 
  224afe:	e9 43 18 00 00       	jmp    226346 <parseFormValue+0x1a06>
  224b03:	48 8d 44 24 78       	lea    rax,[rsp+0x78]
            const input_slice = input_buf[0..size];
  224b08:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  224b0d:	48 c7 44 24 20 04 00 	mov    QWORD PTR [rsp+0x20],0x4
  224b14:	00 00 
  224b16:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  224b1b:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  224b20:	4c 89 e6             	mov    rsi,r12
  224b23:	41 ff 14 24          	call   QWORD PTR [r12]
  224b27:	0f b7 4c 24 40       	movzx  ecx,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  224b2c:	66 85 c9             	test   cx,cx
  224b2f:	75 14                	jne    224b45 <parseFormValue+0x205>
            if (amt_read < buf.len) return error.EndOfStream;
  224b31:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
  224b36:	66 b9 25 00          	mov    cx,0x25
  224b3a:	48 39 44 24 48       	cmp    QWORD PTR [rsp+0x48],rax
  224b3f:	0f 83 44 12 00 00    	jae    225d89 <parseFormValue+0x1449>
  224b45:	66 89 8c 24 68 02 00 	mov    WORD PTR [rsp+0x268],cx
  224b4c:	00 
  224b4d:	8b 44 24 3a          	mov    eax,DWORD PTR [rsp+0x3a]
  224b51:	89 84 24 6a 02 00 00 	mov    DWORD PTR [rsp+0x26a],eax
  224b58:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  224b5d:	66 89 84 24 6e 02 00 	mov    WORD PTR [rsp+0x26e],ax
  224b64:	00 
  224b65:	8b 44 24 11          	mov    eax,DWORD PTR [rsp+0x11]
  224b69:	89 84 24 81 02 00 00 	mov    DWORD PTR [rsp+0x281],eax
  224b70:	0f b7 44 24 15       	movzx  eax,WORD PTR [rsp+0x15]
  224b75:	66 89 84 24 85 02 00 	mov    WORD PTR [rsp+0x285],ax
  224b7c:	00 
  224b7d:	8a 44 24 17          	mov    al,BYTE PTR [rsp+0x17]
  224b81:	88 84 24 87 02 00 00 	mov    BYTE PTR [rsp+0x287],al
  224b88:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  224b8c:	89 84 24 89 02 00 00 	mov    DWORD PTR [rsp+0x289],eax
  224b93:	0f b7 44 24 0e       	movzx  eax,WORD PTR [rsp+0xe]
  224b98:	66 89 84 24 8d 02 00 	mov    WORD PTR [rsp+0x28d],ax
  224b9f:	00 
  224ba0:	8a 44 24 10          	mov    al,BYTE PTR [rsp+0x10]
  224ba4:	88 84 24 8f 02 00 00 	mov    BYTE PTR [rsp+0x28f],al
  224bab:	48 8d 84 24 68 02 00 	lea    rax,[rsp+0x268]
  224bb2:	00 
  224bb3:	e9 8e 17 00 00       	jmp    226346 <parseFormValue+0x1a06>
  224bb8:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
            .payload = try readAllocBytes(allocator, in_stream, size),
  224bbd:	b9 02 00 00 00       	mov    ecx,0x2
  224bc2:	4c 89 fe             	mov    rsi,r15
  224bc5:	4c 89 e2             	mov    rdx,r12
  224bc8:	e8 13 2b 00 00       	call   2276e0 <readAllocBytes>
  224bcd:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
  224bd2:	66 85 c0             	test   ax,ax
  224bd5:	0f 84 89 0b 00 00    	je     225764 <parseFormValue+0xe24>
  224bdb:	66 89 84 24 78 01 00 	mov    WORD PTR [rsp+0x178],ax
  224be2:	00 
  224be3:	8b 44 24 3a          	mov    eax,DWORD PTR [rsp+0x3a]
  224be7:	89 84 24 7a 01 00 00 	mov    DWORD PTR [rsp+0x17a],eax
  224bee:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  224bf3:	66 89 84 24 7e 01 00 	mov    WORD PTR [rsp+0x17e],ax
  224bfa:	00 
  224bfb:	8b 44 24 11          	mov    eax,DWORD PTR [rsp+0x11]
  224bff:	89 84 24 91 01 00 00 	mov    DWORD PTR [rsp+0x191],eax
  224c06:	0f b7 44 24 15       	movzx  eax,WORD PTR [rsp+0x15]
  224c0b:	66 89 84 24 95 01 00 	mov    WORD PTR [rsp+0x195],ax
  224c12:	00 
  224c13:	8a 44 24 17          	mov    al,BYTE PTR [rsp+0x17]
  224c17:	88 84 24 97 01 00 00 	mov    BYTE PTR [rsp+0x197],al
  224c1e:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  224c22:	89 84 24 99 01 00 00 	mov    DWORD PTR [rsp+0x199],eax
  224c29:	0f b7 44 24 0e       	movzx  eax,WORD PTR [rsp+0xe]
  224c2e:	66 89 84 24 9d 01 00 	mov    WORD PTR [rsp+0x19d],ax
  224c35:	00 
  224c36:	8a 44 24 10          	mov    al,BYTE PTR [rsp+0x10]
  224c3a:	88 84 24 9f 01 00 00 	mov    BYTE PTR [rsp+0x19f],al
  224c41:	48 8d 84 24 78 01 00 	lea    rax,[rsp+0x178]
  224c48:	00 
  224c49:	e9 f8 16 00 00       	jmp    226346 <parseFormValue+0x1a06>
  224c4e:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  224c53:	b9 04 00 00 00       	mov    ecx,0x4
  224c58:	4c 89 fe             	mov    rsi,r15
  224c5b:	4c 89 e2             	mov    rdx,r12
  224c5e:	e8 7d 2a 00 00       	call   2276e0 <readAllocBytes>
  224c63:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
  224c68:	66 85 c0             	test   ax,ax
  224c6b:	0f 84 9d 0b 00 00    	je     22580e <parseFormValue+0xece>
  224c71:	66 89 84 24 50 01 00 	mov    WORD PTR [rsp+0x150],ax
  224c78:	00 
  224c79:	8b 44 24 3a          	mov    eax,DWORD PTR [rsp+0x3a]
  224c7d:	89 84 24 52 01 00 00 	mov    DWORD PTR [rsp+0x152],eax
  224c84:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  224c89:	66 89 84 24 56 01 00 	mov    WORD PTR [rsp+0x156],ax
  224c90:	00 
  224c91:	8b 44 24 11          	mov    eax,DWORD PTR [rsp+0x11]
  224c95:	89 84 24 69 01 00 00 	mov    DWORD PTR [rsp+0x169],eax
  224c9c:	0f b7 44 24 15       	movzx  eax,WORD PTR [rsp+0x15]
  224ca1:	66 89 84 24 6d 01 00 	mov    WORD PTR [rsp+0x16d],ax
  224ca8:	00 
  224ca9:	8a 44 24 17          	mov    al,BYTE PTR [rsp+0x17]
  224cad:	88 84 24 6f 01 00 00 	mov    BYTE PTR [rsp+0x16f],al
  224cb4:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  224cb8:	89 84 24 71 01 00 00 	mov    DWORD PTR [rsp+0x171],eax
  224cbf:	0f b7 44 24 0e       	movzx  eax,WORD PTR [rsp+0xe]
  224cc4:	66 89 84 24 75 01 00 	mov    WORD PTR [rsp+0x175],ax
  224ccb:	00 
  224ccc:	8a 44 24 10          	mov    al,BYTE PTR [rsp+0x10]
  224cd0:	88 84 24 77 01 00 00 	mov    BYTE PTR [rsp+0x177],al
  224cd7:	48 8d 84 24 50 01 00 	lea    rax,[rsp+0x150]
  224cde:	00 
  224cdf:	e9 62 16 00 00       	jmp    226346 <parseFormValue+0x1a06>
  224ce4:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  224ce9:	b9 08 00 00 00       	mov    ecx,0x8
  224cee:	4c 89 fe             	mov    rsi,r15
  224cf1:	4c 89 e2             	mov    rdx,r12
  224cf4:	e8 e7 29 00 00       	call   2276e0 <readAllocBytes>
  224cf9:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
  224cfe:	66 85 c0             	test   ax,ax
  224d01:	0f 84 b1 0b 00 00    	je     2258b8 <parseFormValue+0xf78>
  224d07:	66 89 84 24 28 01 00 	mov    WORD PTR [rsp+0x128],ax
  224d0e:	00 
  224d0f:	8b 44 24 3a          	mov    eax,DWORD PTR [rsp+0x3a]
  224d13:	89 84 24 2a 01 00 00 	mov    DWORD PTR [rsp+0x12a],eax
  224d1a:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  224d1f:	66 89 84 24 2e 01 00 	mov    WORD PTR [rsp+0x12e],ax
  224d26:	00 
  224d27:	8b 44 24 11          	mov    eax,DWORD PTR [rsp+0x11]
  224d2b:	89 84 24 41 01 00 00 	mov    DWORD PTR [rsp+0x141],eax
  224d32:	0f b7 44 24 15       	movzx  eax,WORD PTR [rsp+0x15]
  224d37:	66 89 84 24 45 01 00 	mov    WORD PTR [rsp+0x145],ax
  224d3e:	00 
  224d3f:	8a 44 24 17          	mov    al,BYTE PTR [rsp+0x17]
  224d43:	88 84 24 47 01 00 00 	mov    BYTE PTR [rsp+0x147],al
  224d4a:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  224d4e:	89 84 24 49 01 00 00 	mov    DWORD PTR [rsp+0x149],eax
  224d55:	0f b7 44 24 0e       	movzx  eax,WORD PTR [rsp+0xe]
  224d5a:	66 89 84 24 4d 01 00 	mov    WORD PTR [rsp+0x14d],ax
  224d61:	00 
  224d62:	8a 44 24 10          	mov    al,BYTE PTR [rsp+0x10]
  224d66:	88 84 24 4f 01 00 00 	mov    BYTE PTR [rsp+0x14f],al
  224d6d:	48 8d 84 24 28 01 00 	lea    rax,[rsp+0x128]
  224d74:	00 
  224d75:	e9 cc 15 00 00       	jmp    226346 <parseFormValue+0x1a06>
  224d7a:	4c 89 74 24 68       	mov    QWORD PTR [rsp+0x68],r14
            return Self{
  224d7f:	c5 f8 57 c0          	vxorps xmm0,xmm0,xmm0
  224d83:	c5 f8 29 44 24 40    	vmovaps XMMWORD PTR [rsp+0x40],xmm0
  224d89:	48 c7 44 24 50 00 00 	mov    QWORD PTR [rsp+0x50],0x0
  224d90:	00 00 
  224d92:	4c 89 bc 24 d0 00 00 	mov    QWORD PTR [rsp+0xd0],r15
  224d99:	00 
    var buf = ArrayList(u8).init(allocator);
  224d9a:	4c 89 7c 24 58       	mov    QWORD PTR [rsp+0x58],r15
  224d9f:	48 8d 84 24 b0 00 00 	lea    rax,[rsp+0xb0]
  224da6:	00 
            try self.readNoEof(result[0..]);
  224da7:	48 89 84 24 90 00 00 	mov    QWORD PTR [rsp+0x90],rax
  224dae:	00 
  224daf:	48 c7 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],0x1
  224db6:	00 01 00 00 00 
  224dbb:	48 8d 7c 24 18       	lea    rdi,[rsp+0x18]
  224dc0:	48 8d 94 24 90 00 00 	lea    rdx,[rsp+0x90]
  224dc7:	00 
            return self.readFn(self, buffer);
  224dc8:	4c 89 e6             	mov    rsi,r12
  224dcb:	41 ff 14 24          	call   QWORD PTR [r12]
  224dcf:	0f b7 44 24 18       	movzx  eax,WORD PTR [rsp+0x18]
            const amt_read = try self.read(buf);
  224dd4:	66 85 c0             	test   ax,ax
  224dd7:	0f 84 85 0b 00 00    	je     225962 <parseFormValue+0x1022>
  224ddd:	48 8b 4c 24 68       	mov    rcx,QWORD PTR [rsp+0x68]
        DW.FORM_string => FormValue{ .String = try readStringRaw(allocator, in_stream) },
  224de2:	66 89 01             	mov    WORD PTR [rcx],ax
  224de5:	48 8b 84 24 84 05 00 	mov    rax,QWORD PTR [rsp+0x584]
  224dec:	00 
  224ded:	48 89 41 20          	mov    QWORD PTR [rcx+0x20],rax
  224df1:	c5 fc 10 84 24 66 05 	vmovups ymm0,YMMWORD PTR [rsp+0x566]
  224df8:	00 00 
  224dfa:	c5 fc 11 41 02       	vmovups YMMWORD PTR [rcx+0x2],ymm0
  224dff:	e9 53 15 00 00       	jmp    226357 <parseFormValue+0x1a17>
  224e04:	4c 89 bc 24 d0 00 00 	mov    QWORD PTR [rsp+0xd0],r15
  224e0b:	00 
  224e0c:	4c 89 74 24 68       	mov    QWORD PTR [rsp+0x68],r14
  224e11:	4c 8d ac 24 b0 00 00 	lea    r13,[rsp+0xb0]
  224e18:	00 
            try self.readNoEof(result[0..]);
  224e19:	4c 89 6c 24 18       	mov    QWORD PTR [rsp+0x18],r13
  224e1e:	48 c7 44 24 20 01 00 	mov    QWORD PTR [rsp+0x20],0x1
  224e25:	00 00 
  224e27:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  224e2c:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  224e31:	4c 89 e6             	mov    rsi,r12
  224e34:	41 ff 14 24          	call   QWORD PTR [r12]
  224e38:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  224e3d:	66 85 c0             	test   ax,ax
  224e40:	0f 84 fa 0b 00 00    	je     225a40 <parseFormValue+0x1100>
  224e46:	48 8b 4c 24 68       	mov    rcx,QWORD PTR [rsp+0x68]
            const block_len = try readULeb128(in_stream);
  224e4b:	66 89 01             	mov    WORD PTR [rcx],ax
  224e4e:	48 8b 84 24 da 06 00 	mov    rax,QWORD PTR [rsp+0x6da]
  224e55:	00 
  224e56:	48 89 41 20          	mov    QWORD PTR [rcx+0x20],rax
  224e5a:	c5 fc 10 84 24 bc 06 	vmovups ymm0,YMMWORD PTR [rsp+0x6bc]
  224e61:	00 00 
  224e63:	c5 fc 11 41 02       	vmovups YMMWORD PTR [rcx+0x2],ymm0
  224e68:	e9 ea 14 00 00       	jmp    226357 <parseFormValue+0x1a17>
  224e6d:	48 8d 44 24 78       	lea    rax,[rsp+0x78]
            const input_slice = input_buf[0..size];
  224e72:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  224e77:	48 c7 44 24 20 01 00 	mov    QWORD PTR [rsp+0x20],0x1
  224e7e:	00 00 
  224e80:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  224e85:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  224e8a:	4c 89 e6             	mov    rsi,r12
  224e8d:	41 ff 14 24          	call   QWORD PTR [r12]
  224e91:	0f b7 4c 24 40       	movzx  ecx,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  224e96:	66 85 c9             	test   cx,cx
  224e99:	75 14                	jne    224eaf <parseFormValue+0x56f>
            if (amt_read < buf.len) return error.EndOfStream;
  224e9b:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
  224ea0:	66 b9 25 00          	mov    cx,0x25
  224ea4:	48 39 44 24 48       	cmp    QWORD PTR [rsp+0x48],rax
  224ea9:	0f 83 fb 0e 00 00    	jae    225daa <parseFormValue+0x146a>
    const block_len = try in_stream.readVarInt(builtin.Endian.Little, usize, size);
  224eaf:	66 89 8c 24 b8 02 00 	mov    WORD PTR [rsp+0x2b8],cx
  224eb6:	00 
  224eb7:	8b 44 24 3a          	mov    eax,DWORD PTR [rsp+0x3a]
  224ebb:	89 84 24 ba 02 00 00 	mov    DWORD PTR [rsp+0x2ba],eax
  224ec2:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  224ec7:	66 89 84 24 be 02 00 	mov    WORD PTR [rsp+0x2be],ax
  224ece:	00 
  224ecf:	8b 44 24 11          	mov    eax,DWORD PTR [rsp+0x11]
  224ed3:	89 84 24 d1 02 00 00 	mov    DWORD PTR [rsp+0x2d1],eax
  224eda:	0f b7 44 24 15       	movzx  eax,WORD PTR [rsp+0x15]
  224edf:	66 89 84 24 d5 02 00 	mov    WORD PTR [rsp+0x2d5],ax
  224ee6:	00 
  224ee7:	8a 44 24 17          	mov    al,BYTE PTR [rsp+0x17]
  224eeb:	88 84 24 d7 02 00 00 	mov    BYTE PTR [rsp+0x2d7],al
  224ef2:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  224ef6:	89 84 24 d9 02 00 00 	mov    DWORD PTR [rsp+0x2d9],eax
  224efd:	0f b7 44 24 0e       	movzx  eax,WORD PTR [rsp+0xe]
  224f02:	66 89 84 24 dd 02 00 	mov    WORD PTR [rsp+0x2dd],ax
  224f09:	00 
  224f0a:	8a 44 24 10          	mov    al,BYTE PTR [rsp+0x10]
  224f0e:	88 84 24 df 02 00 00 	mov    BYTE PTR [rsp+0x2df],al
  224f15:	48 8d 84 24 b8 02 00 	lea    rax,[rsp+0x2b8]
  224f1c:	00 
  224f1d:	e9 24 14 00 00       	jmp    226346 <parseFormValue+0x1a06>
  224f22:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
            .payload = try readAllocBytes(allocator, in_stream, size),
  224f27:	b9 01 00 00 00       	mov    ecx,0x1
  224f2c:	4c 89 fe             	mov    rsi,r15
  224f2f:	4c 89 e2             	mov    rdx,r12
  224f32:	e8 a9 27 00 00       	call   2276e0 <readAllocBytes>
  224f37:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
  224f3c:	66 85 c0             	test   ax,ax
  224f3f:	0f 84 7c 0b 00 00    	je     225ac1 <parseFormValue+0x1181>
  224f45:	66 89 84 24 a0 01 00 	mov    WORD PTR [rsp+0x1a0],ax
  224f4c:	00 
  224f4d:	8b 44 24 3a          	mov    eax,DWORD PTR [rsp+0x3a]
  224f51:	89 84 24 a2 01 00 00 	mov    DWORD PTR [rsp+0x1a2],eax
  224f58:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  224f5d:	66 89 84 24 a6 01 00 	mov    WORD PTR [rsp+0x1a6],ax
  224f64:	00 
  224f65:	8b 44 24 11          	mov    eax,DWORD PTR [rsp+0x11]
  224f69:	89 84 24 b9 01 00 00 	mov    DWORD PTR [rsp+0x1b9],eax
  224f70:	0f b7 44 24 15       	movzx  eax,WORD PTR [rsp+0x15]
  224f75:	66 89 84 24 bd 01 00 	mov    WORD PTR [rsp+0x1bd],ax
  224f7c:	00 
  224f7d:	8a 44 24 17          	mov    al,BYTE PTR [rsp+0x17]
  224f81:	88 84 24 bf 01 00 00 	mov    BYTE PTR [rsp+0x1bf],al
  224f88:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  224f8c:	89 84 24 c1 01 00 00 	mov    DWORD PTR [rsp+0x1c1],eax
  224f93:	0f b7 44 24 0e       	movzx  eax,WORD PTR [rsp+0xe]
  224f98:	66 89 84 24 c5 01 00 	mov    WORD PTR [rsp+0x1c5],ax
  224f9f:	00 
  224fa0:	8a 44 24 10          	mov    al,BYTE PTR [rsp+0x10]
  224fa4:	88 84 24 c7 01 00 00 	mov    BYTE PTR [rsp+0x1c7],al
  224fab:	48 8d 84 24 a0 01 00 	lea    rax,[rsp+0x1a0]
  224fb2:	00 
  224fb3:	e9 8e 13 00 00       	jmp    226346 <parseFormValue+0x1a06>
  224fb8:	48 8d 84 24 b0 00 00 	lea    rax,[rsp+0xb0]
  224fbf:	00 
            try self.readNoEof(result[0..]);
  224fc0:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  224fc5:	48 c7 44 24 20 01 00 	mov    QWORD PTR [rsp+0x20],0x1
  224fcc:	00 00 
  224fce:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  224fd3:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  224fd8:	4c 89 e6             	mov    rsi,r12
  224fdb:	41 ff 14 24          	call   QWORD PTR [r12]
  224fdf:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  224fe4:	66 85 c0             	test   ax,ax
  224fe7:	75 14                	jne    224ffd <parseFormValue+0x6bd>
  224fe9:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  224fee:	66 b8 25 00          	mov    ax,0x25
            if (amt_read < buf.len) return error.EndOfStream;
  224ff2:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  224ff7:	0f 83 ce 0d 00 00    	jae    225dcb <parseFormValue+0x148b>
        DW.FORM_flag => FormValue{ .Flag = (try in_stream.readByte()) != 0 },
  224ffd:	66 41 89 06          	mov    WORD PTR [r14],ax
  225001:	48 8b 84 24 42 06 00 	mov    rax,QWORD PTR [rsp+0x642]
  225008:	00 
  225009:	49 89 46 20          	mov    QWORD PTR [r14+0x20],rax
  22500d:	c5 fc 10 84 24 24 06 	vmovups ymm0,YMMWORD PTR [rsp+0x624]
  225014:	00 00 
  225016:	e9 3e 07 00 00       	jmp    225759 <parseFormValue+0xe19>
    return if (is_64) try in_stream.readIntLe(u64) else u64(try in_stream.readIntLe(u32));
  22501b:	40 f6 c5 01          	test   bpl,0x1
  22501f:	0f 84 1c 06 00 00    	je     225641 <parseFormValue+0xd01>
  225025:	48 8d 84 24 90 00 00 	lea    rax,[rsp+0x90]
  22502c:	00 
            try self.readNoEof(bytes[0..]);
  22502d:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  225032:	48 c7 44 24 20 08 00 	mov    QWORD PTR [rsp+0x20],0x8
  225039:	00 00 
  22503b:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  225040:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  225045:	4c 89 e6             	mov    rsi,r12
  225048:	41 ff 14 24          	call   QWORD PTR [r12]
  22504c:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  225051:	66 85 c0             	test   ax,ax
  225054:	0f 85 29 06 00 00    	jne    225683 <parseFormValue+0xd43>
  22505a:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  22505f:	66 b8 25 00          	mov    ax,0x25
            if (amt_read < buf.len) return error.EndOfStream;
  225063:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  225068:	0f 82 15 06 00 00    	jb     225683 <parseFormValue+0xd43>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  22506e:	48 8b 84 24 90 00 00 	mov    rax,QWORD PTR [rsp+0x90]
  225075:	00 
  225076:	e9 4f 11 00 00       	jmp    2261ca <parseFormValue+0x188a>
  22507b:	40 f6 c5 01          	test   bpl,0x1
  22507f:	0f 84 1c 06 00 00    	je     2256a1 <parseFormValue+0xd61>
  225085:	48 8d 84 24 90 00 00 	lea    rax,[rsp+0x90]
  22508c:	00 
            try self.readNoEof(bytes[0..]);
  22508d:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  225092:	48 c7 44 24 20 08 00 	mov    QWORD PTR [rsp+0x20],0x8
  225099:	00 00 
  22509b:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  2250a0:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  2250a5:	4c 89 e6             	mov    rsi,r12
  2250a8:	41 ff 14 24          	call   QWORD PTR [r12]
  2250ac:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  2250b1:	66 85 c0             	test   ax,ax
  2250b4:	0f 85 29 06 00 00    	jne    2256e3 <parseFormValue+0xda3>
  2250ba:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  2250bf:	66 b8 25 00          	mov    ax,0x25
            if (amt_read < buf.len) return error.EndOfStream;
  2250c3:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  2250c8:	0f 82 15 06 00 00    	jb     2256e3 <parseFormValue+0xda3>
  2250ce:	48 8b 84 24 90 00 00 	mov    rax,QWORD PTR [rsp+0x90]
  2250d5:	00 
  2250d6:	e9 7d 11 00 00       	jmp    226258 <parseFormValue+0x1918>
  2250db:	48 8d 84 24 b0 00 00 	lea    rax,[rsp+0xb0]
  2250e2:	00 
            try self.readNoEof(bytes[0..]);
  2250e3:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  2250e8:	48 c7 44 24 20 01 00 	mov    QWORD PTR [rsp+0x20],0x1
  2250ef:	00 00 
  2250f1:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  2250f6:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  2250fb:	4c 89 e6             	mov    rsi,r12
  2250fe:	41 ff 14 24          	call   QWORD PTR [r12]
  225102:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  225107:	66 85 c0             	test   ax,ax
  22510a:	75 14                	jne    225120 <parseFormValue+0x7e0>
  22510c:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  225111:	66 b8 25 00          	mov    ax,0x25
            if (amt_read < buf.len) return error.EndOfStream;
  225115:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  22511a:	0f 83 30 0d 00 00    	jae    225e50 <parseFormValue+0x1510>
    const block_len = try in_stream.readIntLe(T);
  225120:	66 89 84 24 40 02 00 	mov    WORD PTR [rsp+0x240],ax
  225127:	00 
  225128:	8b 44 24 3a          	mov    eax,DWORD PTR [rsp+0x3a]
  22512c:	89 84 24 42 02 00 00 	mov    DWORD PTR [rsp+0x242],eax
  225133:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  225138:	66 89 84 24 46 02 00 	mov    WORD PTR [rsp+0x246],ax
  22513f:	00 
  225140:	8b 44 24 11          	mov    eax,DWORD PTR [rsp+0x11]
  225144:	89 84 24 59 02 00 00 	mov    DWORD PTR [rsp+0x259],eax
  22514b:	0f b7 44 24 15       	movzx  eax,WORD PTR [rsp+0x15]
  225150:	66 89 84 24 5d 02 00 	mov    WORD PTR [rsp+0x25d],ax
  225157:	00 
  225158:	8a 44 24 17          	mov    al,BYTE PTR [rsp+0x17]
  22515c:	88 84 24 5f 02 00 00 	mov    BYTE PTR [rsp+0x25f],al
  225163:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  225167:	89 84 24 61 02 00 00 	mov    DWORD PTR [rsp+0x261],eax
  22516e:	0f b7 44 24 0e       	movzx  eax,WORD PTR [rsp+0xe]
  225173:	66 89 84 24 65 02 00 	mov    WORD PTR [rsp+0x265],ax
  22517a:	00 
  22517b:	8a 44 24 10          	mov    al,BYTE PTR [rsp+0x10]
  22517f:	88 84 24 67 02 00 00 	mov    BYTE PTR [rsp+0x267],al
  225186:	48 8d 84 24 40 02 00 	lea    rax,[rsp+0x240]
  22518d:	00 
  22518e:	e9 b3 11 00 00       	jmp    226346 <parseFormValue+0x1a06>
  225193:	48 8d 44 24 78       	lea    rax,[rsp+0x78]
            try self.readNoEof(bytes[0..]);
  225198:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  22519d:	48 c7 44 24 20 02 00 	mov    QWORD PTR [rsp+0x20],0x2
  2251a4:	00 00 
  2251a6:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  2251ab:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  2251b0:	4c 89 e6             	mov    rsi,r12
  2251b3:	41 ff 14 24          	call   QWORD PTR [r12]
  2251b7:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  2251bc:	66 85 c0             	test   ax,ax
  2251bf:	75 14                	jne    2251d5 <parseFormValue+0x895>
  2251c1:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  2251c6:	66 b8 25 00          	mov    ax,0x25
            if (amt_read < buf.len) return error.EndOfStream;
  2251ca:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  2251cf:	0f 83 dd 0c 00 00    	jae    225eb2 <parseFormValue+0x1572>
  2251d5:	66 89 84 24 18 02 00 	mov    WORD PTR [rsp+0x218],ax
  2251dc:	00 
  2251dd:	8b 44 24 3a          	mov    eax,DWORD PTR [rsp+0x3a]
  2251e1:	89 84 24 1a 02 00 00 	mov    DWORD PTR [rsp+0x21a],eax
  2251e8:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  2251ed:	66 89 84 24 1e 02 00 	mov    WORD PTR [rsp+0x21e],ax
  2251f4:	00 
  2251f5:	8b 44 24 11          	mov    eax,DWORD PTR [rsp+0x11]
  2251f9:	89 84 24 31 02 00 00 	mov    DWORD PTR [rsp+0x231],eax
  225200:	0f b7 44 24 15       	movzx  eax,WORD PTR [rsp+0x15]
  225205:	66 89 84 24 35 02 00 	mov    WORD PTR [rsp+0x235],ax
  22520c:	00 
  22520d:	8a 44 24 17          	mov    al,BYTE PTR [rsp+0x17]
  225211:	88 84 24 37 02 00 00 	mov    BYTE PTR [rsp+0x237],al
  225218:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  22521c:	89 84 24 39 02 00 00 	mov    DWORD PTR [rsp+0x239],eax
  225223:	0f b7 44 24 0e       	movzx  eax,WORD PTR [rsp+0xe]
  225228:	66 89 84 24 3d 02 00 	mov    WORD PTR [rsp+0x23d],ax
  22522f:	00 
  225230:	8a 44 24 10          	mov    al,BYTE PTR [rsp+0x10]
  225234:	88 84 24 3f 02 00 00 	mov    BYTE PTR [rsp+0x23f],al
  22523b:	48 8d 84 24 18 02 00 	lea    rax,[rsp+0x218]
  225242:	00 
  225243:	e9 fe 10 00 00       	jmp    226346 <parseFormValue+0x1a06>
  225248:	48 8d 44 24 78       	lea    rax,[rsp+0x78]
            try self.readNoEof(bytes[0..]);
  22524d:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  225252:	48 c7 44 24 20 04 00 	mov    QWORD PTR [rsp+0x20],0x4
  225259:	00 00 
  22525b:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  225260:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  225265:	4c 89 e6             	mov    rsi,r12
  225268:	41 ff 14 24          	call   QWORD PTR [r12]
  22526c:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  225271:	66 85 c0             	test   ax,ax
  225274:	75 14                	jne    22528a <parseFormValue+0x94a>
  225276:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  22527b:	66 b8 25 00          	mov    ax,0x25
            if (amt_read < buf.len) return error.EndOfStream;
  22527f:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  225284:	0f 83 93 0c 00 00    	jae    225f1d <parseFormValue+0x15dd>
  22528a:	66 89 84 24 f0 01 00 	mov    WORD PTR [rsp+0x1f0],ax
  225291:	00 
  225292:	8b 44 24 3a          	mov    eax,DWORD PTR [rsp+0x3a]
  225296:	89 84 24 f2 01 00 00 	mov    DWORD PTR [rsp+0x1f2],eax
  22529d:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  2252a2:	66 89 84 24 f6 01 00 	mov    WORD PTR [rsp+0x1f6],ax
  2252a9:	00 
  2252aa:	8b 44 24 11          	mov    eax,DWORD PTR [rsp+0x11]
  2252ae:	89 84 24 09 02 00 00 	mov    DWORD PTR [rsp+0x209],eax
  2252b5:	0f b7 44 24 15       	movzx  eax,WORD PTR [rsp+0x15]
  2252ba:	66 89 84 24 0d 02 00 	mov    WORD PTR [rsp+0x20d],ax
  2252c1:	00 
  2252c2:	8a 44 24 17          	mov    al,BYTE PTR [rsp+0x17]
  2252c6:	88 84 24 0f 02 00 00 	mov    BYTE PTR [rsp+0x20f],al
  2252cd:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  2252d1:	89 84 24 11 02 00 00 	mov    DWORD PTR [rsp+0x211],eax
  2252d8:	0f b7 44 24 0e       	movzx  eax,WORD PTR [rsp+0xe]
  2252dd:	66 89 84 24 15 02 00 	mov    WORD PTR [rsp+0x215],ax
  2252e4:	00 
  2252e5:	8a 44 24 10          	mov    al,BYTE PTR [rsp+0x10]
  2252e9:	88 84 24 17 02 00 00 	mov    BYTE PTR [rsp+0x217],al
  2252f0:	48 8d 84 24 f0 01 00 	lea    rax,[rsp+0x1f0]
  2252f7:	00 
  2252f8:	e9 49 10 00 00       	jmp    226346 <parseFormValue+0x1a06>
  2252fd:	48 8d 44 24 78       	lea    rax,[rsp+0x78]
            try self.readNoEof(bytes[0..]);
  225302:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  225307:	48 c7 44 24 20 08 00 	mov    QWORD PTR [rsp+0x20],0x8
  22530e:	00 00 
  225310:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  225315:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  22531a:	4c 89 e6             	mov    rsi,r12
  22531d:	41 ff 14 24          	call   QWORD PTR [r12]
  225321:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  225326:	66 85 c0             	test   ax,ax
  225329:	75 14                	jne    22533f <parseFormValue+0x9ff>
  22532b:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  225330:	66 b8 25 00          	mov    ax,0x25
            if (amt_read < buf.len) return error.EndOfStream;
  225334:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  225339:	0f 83 61 0c 00 00    	jae    225fa0 <parseFormValue+0x1660>
  22533f:	66 89 84 24 c8 01 00 	mov    WORD PTR [rsp+0x1c8],ax
  225346:	00 
  225347:	8b 44 24 3a          	mov    eax,DWORD PTR [rsp+0x3a]
  22534b:	89 84 24 ca 01 00 00 	mov    DWORD PTR [rsp+0x1ca],eax
  225352:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  225357:	66 89 84 24 ce 01 00 	mov    WORD PTR [rsp+0x1ce],ax
  22535e:	00 
  22535f:	8b 44 24 11          	mov    eax,DWORD PTR [rsp+0x11]
  225363:	89 84 24 e1 01 00 00 	mov    DWORD PTR [rsp+0x1e1],eax
  22536a:	0f b7 44 24 15       	movzx  eax,WORD PTR [rsp+0x15]
  22536f:	66 89 84 24 e5 01 00 	mov    WORD PTR [rsp+0x1e5],ax
  225376:	00 
  225377:	8a 44 24 17          	mov    al,BYTE PTR [rsp+0x17]
  22537b:	88 84 24 e7 01 00 00 	mov    BYTE PTR [rsp+0x1e7],al
  225382:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  225386:	89 84 24 e9 01 00 00 	mov    DWORD PTR [rsp+0x1e9],eax
  22538d:	0f b7 44 24 0e       	movzx  eax,WORD PTR [rsp+0xe]
  225392:	66 89 84 24 ed 01 00 	mov    WORD PTR [rsp+0x1ed],ax
  225399:	00 
  22539a:	8a 44 24 10          	mov    al,BYTE PTR [rsp+0x10]
  22539e:	88 84 24 ef 01 00 00 	mov    BYTE PTR [rsp+0x1ef],al
  2253a5:	48 8d 84 24 c8 01 00 	lea    rax,[rsp+0x1c8]
  2253ac:	00 
  2253ad:	e9 94 0f 00 00       	jmp    226346 <parseFormValue+0x1a06>
  2253b2:	4c 89 bc 24 d0 00 00 	mov    QWORD PTR [rsp+0xd0],r15
  2253b9:	00 
  2253ba:	4c 89 74 24 68       	mov    QWORD PTR [rsp+0x68],r14
  2253bf:	4c 8d b4 24 b0 00 00 	lea    r14,[rsp+0xb0]
  2253c6:	00 
            try self.readNoEof(result[0..]);
  2253c7:	4c 89 74 24 18       	mov    QWORD PTR [rsp+0x18],r14
  2253cc:	48 c7 44 24 20 01 00 	mov    QWORD PTR [rsp+0x20],0x1
  2253d3:	00 00 
  2253d5:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  2253da:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  2253df:	4c 89 e6             	mov    rsi,r12
  2253e2:	41 ff 14 24          	call   QWORD PTR [r12]
  2253e6:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  2253eb:	66 85 c0             	test   ax,ax
  2253ee:	0f 84 77 07 00 00    	je     225b6b <parseFormValue+0x122b>
  2253f4:	48 8b 4c 24 68       	mov    rcx,QWORD PTR [rsp+0x68]
            const ref_len = try readULeb128(in_stream);
  2253f9:	66 89 01             	mov    WORD PTR [rcx],ax
  2253fc:	48 8b 84 24 f6 05 00 	mov    rax,QWORD PTR [rsp+0x5f6]
  225403:	00 
  225404:	48 89 41 20          	mov    QWORD PTR [rcx+0x20],rax
  225408:	c5 fc 10 84 24 d8 05 	vmovups ymm0,YMMWORD PTR [rsp+0x5d8]
  22540f:	00 00 
  225411:	c5 fc 11 41 02       	vmovups YMMWORD PTR [rcx+0x2],ymm0
  225416:	e9 3c 0f 00 00       	jmp    226357 <parseFormValue+0x1a17>
  22541b:	4c 89 bc 24 d0 00 00 	mov    QWORD PTR [rsp+0xd0],r15
  225422:	00 
  225423:	4c 89 74 24 68       	mov    QWORD PTR [rsp+0x68],r14
  225428:	4c 8d bc 24 b0 00 00 	lea    r15,[rsp+0xb0]
  22542f:	00 
            try self.readNoEof(result[0..]);
  225430:	4c 89 7c 24 18       	mov    QWORD PTR [rsp+0x18],r15
  225435:	48 c7 44 24 20 01 00 	mov    QWORD PTR [rsp+0x20],0x1
  22543c:	00 00 
  22543e:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  225443:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  225448:	4c 89 e6             	mov    rsi,r12
  22544b:	41 ff 14 24          	call   QWORD PTR [r12]
  22544f:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  225454:	66 85 c0             	test   ax,ax
  225457:	0f 84 8f 07 00 00    	je     225bec <parseFormValue+0x12ac>
  22545d:	48 8b 4c 24 68       	mov    rcx,QWORD PTR [rsp+0x68]
            const child_form_id = try readULeb128(in_stream);
  225462:	66 89 01             	mov    WORD PTR [rcx],ax
  225465:	48 8b 84 24 38 05 00 	mov    rax,QWORD PTR [rsp+0x538]
  22546c:	00 
  22546d:	48 89 41 20          	mov    QWORD PTR [rcx+0x20],rax
  225471:	c5 fc 10 84 24 1a 05 	vmovups ymm0,YMMWORD PTR [rsp+0x51a]
  225478:	00 00 
  22547a:	c5 fc 11 41 02       	vmovups YMMWORD PTR [rcx+0x2],ymm0
  22547f:	e9 d3 0e 00 00       	jmp    226357 <parseFormValue+0x1a17>
    return if (is_64) try in_stream.readIntLe(u64) else u64(try in_stream.readIntLe(u32));
  225484:	40 f6 c5 01          	test   bpl,0x1
  225488:	0f 84 70 02 00 00    	je     2256fe <parseFormValue+0xdbe>
  22548e:	48 8d 84 24 90 00 00 	lea    rax,[rsp+0x90]
  225495:	00 
            try self.readNoEof(bytes[0..]);
  225496:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  22549b:	48 c7 44 24 20 08 00 	mov    QWORD PTR [rsp+0x20],0x8
  2254a2:	00 00 
  2254a4:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  2254a9:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  2254ae:	4c 89 e6             	mov    rsi,r12
  2254b1:	41 ff 14 24          	call   QWORD PTR [r12]
  2254b5:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  2254ba:	66 85 c0             	test   ax,ax
  2254bd:	0f 85 7d 02 00 00    	jne    225740 <parseFormValue+0xe00>
  2254c3:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  2254c8:	66 b8 25 00          	mov    ax,0x25
            if (amt_read < buf.len) return error.EndOfStream;
  2254cc:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  2254d1:	0f 82 69 02 00 00    	jb     225740 <parseFormValue+0xe00>
  2254d7:	48 8b 84 24 90 00 00 	mov    rax,QWORD PTR [rsp+0x90]
  2254de:	00 
  2254df:	e9 02 0e 00 00       	jmp    2262e6 <parseFormValue+0x19a6>
  2254e4:	4c 89 bc 24 d0 00 00 	mov    QWORD PTR [rsp+0xd0],r15
  2254eb:	00 
  2254ec:	4c 89 74 24 68       	mov    QWORD PTR [rsp+0x68],r14
  2254f1:	4c 8d b4 24 b0 00 00 	lea    r14,[rsp+0xb0]
  2254f8:	00 
            try self.readNoEof(result[0..]);
  2254f9:	4c 89 74 24 18       	mov    QWORD PTR [rsp+0x18],r14
  2254fe:	48 c7 44 24 20 01 00 	mov    QWORD PTR [rsp+0x20],0x1
  225505:	00 00 
  225507:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  22550c:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  225511:	4c 89 e6             	mov    rsi,r12
  225514:	41 ff 14 24          	call   QWORD PTR [r12]
  225518:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  22551d:	66 85 c0             	test   ax,ax
  225520:	0f 84 45 07 00 00    	je     225c6b <parseFormValue+0x132b>
  225526:	48 8b 4c 24 68       	mov    rcx,QWORD PTR [rsp+0x68]
            const size = try readULeb128(in_stream);
  22552b:	66 89 01             	mov    WORD PTR [rcx],ax
  22552e:	48 8b 84 24 8e 06 00 	mov    rax,QWORD PTR [rsp+0x68e]
  225535:	00 
  225536:	48 89 41 20          	mov    QWORD PTR [rcx+0x20],rax
  22553a:	c5 fc 10 84 24 70 06 	vmovups ymm0,YMMWORD PTR [rsp+0x670]
  225541:	00 00 
  225543:	c5 fc 11 41 02       	vmovups YMMWORD PTR [rcx+0x2],ymm0
  225548:	e9 0a 0e 00 00       	jmp    226357 <parseFormValue+0x1a17>
  22554d:	48 8d 05 0c 2e fe ff 	lea    rax,[rip+0xfffffffffffe2e0c]        # 208360 <__unnamed_63>
  225554:	e9 ed 0d 00 00       	jmp    226346 <parseFormValue+0x1a06>
  225559:	48 8d 44 24 78       	lea    rax,[rsp+0x78]
            try self.readNoEof(bytes[0..]);
  22555e:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  225563:	48 c7 44 24 20 08 00 	mov    QWORD PTR [rsp+0x20],0x8
  22556a:	00 00 
  22556c:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  225571:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  225576:	4c 89 e6             	mov    rsi,r12
  225579:	41 ff 14 24          	call   QWORD PTR [r12]
  22557d:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  225582:	66 85 c0             	test   ax,ax
  225585:	75 14                	jne    22559b <parseFormValue+0xc5b>
  225587:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  22558c:	66 b8 25 00          	mov    ax,0x25
            if (amt_read < buf.len) return error.EndOfStream;
  225590:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  225595:	0f 83 64 0a 00 00    	jae    225fff <parseFormValue+0x16bf>
        DW.FORM_ref_sig8 => FormValue{ .RefSig8 = try in_stream.readIntLe(u64) },
  22559b:	66 41 89 06          	mov    WORD PTR [r14],ax
  22559f:	48 8b 84 24 aa 05 00 	mov    rax,QWORD PTR [rsp+0x5aa]
  2255a6:	00 
  2255a7:	49 89 46 20          	mov    QWORD PTR [r14+0x20],rax
  2255ab:	c5 fc 10 84 24 8c 05 	vmovups ymm0,YMMWORD PTR [rsp+0x58c]
  2255b2:	00 00 
  2255b4:	e9 a0 01 00 00       	jmp    225759 <parseFormValue+0xe19>
  2255b9:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  2255be:	31 ed                	xor    ebp,ebp
  2255c0:	4c 8d 7c 24 18       	lea    r15,[rsp+0x18]
  2255c5:	45 31 ed             	xor    r13d,r13d
  2255c8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  2255cf:	00 
  2255d0:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  2255d5:	0f 82 11 07 00 00    	jb     225cec <parseFormValue+0x13ac>
            return result[0];
  2255db:	0f b6 84 24 b0 00 00 	movzx  eax,BYTE PTR [rsp+0xb0]
  2255e2:	00 
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  2255e3:	89 c2                	mov    edx,eax
  2255e5:	83 e2 7f             	and    edx,0x7f
  2255e8:	44 89 ee             	mov    esi,r13d
  2255eb:	83 e6 3f             	and    esi,0x3f
  2255ee:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  2255f3:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  2255f8:	48 39 d6             	cmp    rsi,rdx
  2255fb:	0f 85 f4 06 00 00    	jne    225cf5 <parseFormValue+0x13b5>
        result |= operand;
  225601:	48 09 cd             	or     rbp,rcx
        if ((byte & 0b10000000) == 0) return result;
  225604:	84 c0                	test   al,al
  225606:	0f 89 5d 0a 00 00    	jns    226069 <parseFormValue+0x1729>
        shift += 7;
  22560c:	49 83 c5 07          	add    r13,0x7
            try self.readNoEof(result[0..]);
  225610:	4c 89 74 24 18       	mov    QWORD PTR [rsp+0x18],r14
  225615:	48 c7 44 24 20 01 00 	mov    QWORD PTR [rsp+0x20],0x1
  22561c:	00 00 
            return self.readFn(self, buffer);
  22561e:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  225623:	4c 89 e6             	mov    rsi,r12
  225626:	4c 89 fa             	mov    rdx,r15
  225629:	41 ff 14 24          	call   QWORD PTR [r12]
  22562d:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
  225632:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
            const amt_read = try self.read(buf);
  225637:	66 85 c0             	test   ax,ax
  22563a:	74 94                	je     2255d0 <parseFormValue+0xc90>
  22563c:	e9 86 f3 ff ff       	jmp    2249c7 <parseFormValue+0x87>
  225641:	48 8d 44 24 78       	lea    rax,[rsp+0x78]
            try self.readNoEof(bytes[0..]);
  225646:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  22564b:	48 c7 44 24 20 04 00 	mov    QWORD PTR [rsp+0x20],0x4
  225652:	00 00 
  225654:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  225659:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  22565e:	4c 89 e6             	mov    rsi,r12
  225661:	41 ff 14 24          	call   QWORD PTR [r12]
  225665:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  22566a:	66 85 c0             	test   ax,ax
  22566d:	75 14                	jne    225683 <parseFormValue+0xd43>
  22566f:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  225674:	66 b8 25 00          	mov    ax,0x25
            if (amt_read < buf.len) return error.EndOfStream;
  225678:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  22567d:	0f 83 1e 0b 00 00    	jae    2261a1 <parseFormValue+0x1861>
        DW.FORM_strp => FormValue{ .StrPtr = try parseFormValueDwarfOffsetSize(in_stream, is_64) },
  225683:	66 41 89 06          	mov    WORD PTR [r14],ax
  225687:	48 8b 84 24 5e 05 00 	mov    rax,QWORD PTR [rsp+0x55e]
  22568e:	00 
  22568f:	49 89 46 20          	mov    QWORD PTR [r14+0x20],rax
  225693:	c5 fc 10 84 24 40 05 	vmovups ymm0,YMMWORD PTR [rsp+0x540]
  22569a:	00 00 
  22569c:	e9 b8 00 00 00       	jmp    225759 <parseFormValue+0xe19>
  2256a1:	48 8d 44 24 78       	lea    rax,[rsp+0x78]
            try self.readNoEof(bytes[0..]);
  2256a6:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  2256ab:	48 c7 44 24 20 04 00 	mov    QWORD PTR [rsp+0x20],0x4
  2256b2:	00 00 
  2256b4:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  2256b9:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  2256be:	4c 89 e6             	mov    rsi,r12
  2256c1:	41 ff 14 24          	call   QWORD PTR [r12]
  2256c5:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  2256ca:	66 85 c0             	test   ax,ax
  2256cd:	75 14                	jne    2256e3 <parseFormValue+0xda3>
  2256cf:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  2256d4:	66 b8 25 00          	mov    ax,0x25
            if (amt_read < buf.len) return error.EndOfStream;
  2256d8:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  2256dd:	0f 83 4c 0b 00 00    	jae    22622f <parseFormValue+0x18ef>
        DW.FORM_ref_addr => FormValue{ .RefAddr = try parseFormValueDwarfOffsetSize(in_stream, is_64) },
  2256e3:	66 41 89 06          	mov    WORD PTR [r14],ax
  2256e7:	48 8b 84 24 d0 05 00 	mov    rax,QWORD PTR [rsp+0x5d0]
  2256ee:	00 
  2256ef:	49 89 46 20          	mov    QWORD PTR [r14+0x20],rax
  2256f3:	c5 fc 10 84 24 b2 05 	vmovups ymm0,YMMWORD PTR [rsp+0x5b2]
  2256fa:	00 00 
  2256fc:	eb 5b                	jmp    225759 <parseFormValue+0xe19>
  2256fe:	48 8d 44 24 78       	lea    rax,[rsp+0x78]
            try self.readNoEof(bytes[0..]);
  225703:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  225708:	48 c7 44 24 20 04 00 	mov    QWORD PTR [rsp+0x20],0x4
  22570f:	00 00 
  225711:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  225716:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  22571b:	4c 89 e6             	mov    rsi,r12
  22571e:	41 ff 14 24          	call   QWORD PTR [r12]
  225722:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  225727:	66 85 c0             	test   ax,ax
  22572a:	75 14                	jne    225740 <parseFormValue+0xe00>
  22572c:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  225731:	66 b8 25 00          	mov    ax,0x25
            if (amt_read < buf.len) return error.EndOfStream;
  225735:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  22573a:	0f 83 7d 0b 00 00    	jae    2262bd <parseFormValue+0x197d>
        DW.FORM_sec_offset => FormValue{ .SecOffset = try parseFormValueDwarfOffsetSize(in_stream, is_64) },
  225740:	66 41 89 06          	mov    WORD PTR [r14],ax
  225744:	48 8b 84 24 1c 06 00 	mov    rax,QWORD PTR [rsp+0x61c]
  22574b:	00 
  22574c:	49 89 46 20          	mov    QWORD PTR [r14+0x20],rax
  225750:	c5 fc 10 84 24 fe 05 	vmovups ymm0,YMMWORD PTR [rsp+0x5fe]
  225757:	00 00 
  225759:	c4 c1 7c 11 46 02    	vmovups YMMWORD PTR [r14+0x2],ymm0
  22575f:	e9 f3 0b 00 00       	jmp    226357 <parseFormValue+0x1a17>
    return FormValue{
  225764:	c6 84 24 b0 00 00 00 	mov    BYTE PTR [rsp+0xb0],0x0
  22576b:	00 
  22576c:	c6 44 24 60 02       	mov    BYTE PTR [rsp+0x60],0x2
  225771:	66 c7 84 24 78 01 00 	mov    WORD PTR [rsp+0x178],0x0
  225778:	00 00 00 
  22577b:	8b 44 24 78          	mov    eax,DWORD PTR [rsp+0x78]
  22577f:	89 84 24 7a 01 00 00 	mov    DWORD PTR [rsp+0x17a],eax
        .Const = Constant{
  225786:	c5 f8 10 44 24 48    	vmovups xmm0,XMMWORD PTR [rsp+0x48]
    return FormValue{
  22578c:	0f b7 44 24 7c       	movzx  eax,WORD PTR [rsp+0x7c]
  225791:	66 89 84 24 7e 01 00 	mov    WORD PTR [rsp+0x17e],ax
  225798:	00 
  225799:	c5 f8 11 84 24 80 01 	vmovups XMMWORD PTR [rsp+0x180],xmm0
  2257a0:	00 00 
  2257a2:	c6 84 24 90 01 00 00 	mov    BYTE PTR [rsp+0x190],0x0
  2257a9:	00 
  2257aa:	8b 84 24 90 00 00 00 	mov    eax,DWORD PTR [rsp+0x90]
  2257b1:	89 84 24 91 01 00 00 	mov    DWORD PTR [rsp+0x191],eax
  2257b8:	0f b7 84 24 94 00 00 	movzx  eax,WORD PTR [rsp+0x94]
  2257bf:	00 
  2257c0:	66 89 84 24 95 01 00 	mov    WORD PTR [rsp+0x195],ax
  2257c7:	00 
  2257c8:	8a 84 24 96 00 00 00 	mov    al,BYTE PTR [rsp+0x96]
  2257cf:	88 84 24 97 01 00 00 	mov    BYTE PTR [rsp+0x197],al
  2257d6:	c6 84 24 98 01 00 00 	mov    BYTE PTR [rsp+0x198],0x2
  2257dd:	02 
  2257de:	8a 44 24 1e          	mov    al,BYTE PTR [rsp+0x1e]
  2257e2:	88 84 24 9f 01 00 00 	mov    BYTE PTR [rsp+0x19f],al
  2257e9:	0f b7 44 24 1c       	movzx  eax,WORD PTR [rsp+0x1c]
  2257ee:	66 89 84 24 9d 01 00 	mov    WORD PTR [rsp+0x19d],ax
  2257f5:	00 
  2257f6:	8b 44 24 18          	mov    eax,DWORD PTR [rsp+0x18]
  2257fa:	89 84 24 99 01 00 00 	mov    DWORD PTR [rsp+0x199],eax
  225801:	48 8d 84 24 78 01 00 	lea    rax,[rsp+0x178]
  225808:	00 
  225809:	e9 38 0b 00 00       	jmp    226346 <parseFormValue+0x1a06>
  22580e:	c6 84 24 b0 00 00 00 	mov    BYTE PTR [rsp+0xb0],0x0
  225815:	00 
  225816:	c6 44 24 60 02       	mov    BYTE PTR [rsp+0x60],0x2
  22581b:	66 c7 84 24 50 01 00 	mov    WORD PTR [rsp+0x150],0x0
  225822:	00 00 00 
  225825:	8b 44 24 78          	mov    eax,DWORD PTR [rsp+0x78]
  225829:	89 84 24 52 01 00 00 	mov    DWORD PTR [rsp+0x152],eax
        .Const = Constant{
  225830:	c5 f8 10 44 24 48    	vmovups xmm0,XMMWORD PTR [rsp+0x48]
    return FormValue{
  225836:	0f b7 44 24 7c       	movzx  eax,WORD PTR [rsp+0x7c]
  22583b:	66 89 84 24 56 01 00 	mov    WORD PTR [rsp+0x156],ax
  225842:	00 
  225843:	c5 f8 11 84 24 58 01 	vmovups XMMWORD PTR [rsp+0x158],xmm0
  22584a:	00 00 
  22584c:	c6 84 24 68 01 00 00 	mov    BYTE PTR [rsp+0x168],0x0
  225853:	00 
  225854:	8b 84 24 90 00 00 00 	mov    eax,DWORD PTR [rsp+0x90]
  22585b:	89 84 24 69 01 00 00 	mov    DWORD PTR [rsp+0x169],eax
  225862:	0f b7 84 24 94 00 00 	movzx  eax,WORD PTR [rsp+0x94]
  225869:	00 
  22586a:	66 89 84 24 6d 01 00 	mov    WORD PTR [rsp+0x16d],ax
  225871:	00 
  225872:	8a 84 24 96 00 00 00 	mov    al,BYTE PTR [rsp+0x96]
  225879:	88 84 24 6f 01 00 00 	mov    BYTE PTR [rsp+0x16f],al
  225880:	c6 84 24 70 01 00 00 	mov    BYTE PTR [rsp+0x170],0x2
  225887:	02 
  225888:	8a 44 24 1e          	mov    al,BYTE PTR [rsp+0x1e]
  22588c:	88 84 24 77 01 00 00 	mov    BYTE PTR [rsp+0x177],al
  225893:	0f b7 44 24 1c       	movzx  eax,WORD PTR [rsp+0x1c]
  225898:	66 89 84 24 75 01 00 	mov    WORD PTR [rsp+0x175],ax
  22589f:	00 
  2258a0:	8b 44 24 18          	mov    eax,DWORD PTR [rsp+0x18]
  2258a4:	89 84 24 71 01 00 00 	mov    DWORD PTR [rsp+0x171],eax
  2258ab:	48 8d 84 24 50 01 00 	lea    rax,[rsp+0x150]
  2258b2:	00 
  2258b3:	e9 8e 0a 00 00       	jmp    226346 <parseFormValue+0x1a06>
  2258b8:	c6 84 24 b0 00 00 00 	mov    BYTE PTR [rsp+0xb0],0x0
  2258bf:	00 
  2258c0:	c6 44 24 60 02       	mov    BYTE PTR [rsp+0x60],0x2
  2258c5:	66 c7 84 24 28 01 00 	mov    WORD PTR [rsp+0x128],0x0
  2258cc:	00 00 00 
  2258cf:	8b 44 24 78          	mov    eax,DWORD PTR [rsp+0x78]
  2258d3:	89 84 24 2a 01 00 00 	mov    DWORD PTR [rsp+0x12a],eax
        .Const = Constant{
  2258da:	c5 f8 10 44 24 48    	vmovups xmm0,XMMWORD PTR [rsp+0x48]
    return FormValue{
  2258e0:	0f b7 44 24 7c       	movzx  eax,WORD PTR [rsp+0x7c]
  2258e5:	66 89 84 24 2e 01 00 	mov    WORD PTR [rsp+0x12e],ax
  2258ec:	00 
  2258ed:	c5 f8 11 84 24 30 01 	vmovups XMMWORD PTR [rsp+0x130],xmm0
  2258f4:	00 00 
  2258f6:	c6 84 24 40 01 00 00 	mov    BYTE PTR [rsp+0x140],0x0
  2258fd:	00 
  2258fe:	8b 84 24 90 00 00 00 	mov    eax,DWORD PTR [rsp+0x90]
  225905:	89 84 24 41 01 00 00 	mov    DWORD PTR [rsp+0x141],eax
  22590c:	0f b7 84 24 94 00 00 	movzx  eax,WORD PTR [rsp+0x94]
  225913:	00 
  225914:	66 89 84 24 45 01 00 	mov    WORD PTR [rsp+0x145],ax
  22591b:	00 
  22591c:	8a 84 24 96 00 00 00 	mov    al,BYTE PTR [rsp+0x96]
  225923:	88 84 24 47 01 00 00 	mov    BYTE PTR [rsp+0x147],al
  22592a:	c6 84 24 48 01 00 00 	mov    BYTE PTR [rsp+0x148],0x2
  225931:	02 
  225932:	8a 44 24 1e          	mov    al,BYTE PTR [rsp+0x1e]
  225936:	88 84 24 4f 01 00 00 	mov    BYTE PTR [rsp+0x14f],al
  22593d:	0f b7 44 24 1c       	movzx  eax,WORD PTR [rsp+0x1c]
  225942:	66 89 84 24 4d 01 00 	mov    WORD PTR [rsp+0x14d],ax
  225949:	00 
  22594a:	8b 44 24 18          	mov    eax,DWORD PTR [rsp+0x18]
  22594e:	89 84 24 49 01 00 00 	mov    DWORD PTR [rsp+0x149],eax
  225955:	48 8d 84 24 28 01 00 	lea    rax,[rsp+0x128]
  22595c:	00 
  22595d:	e9 e4 09 00 00       	jmp    226346 <parseFormValue+0x1a06>
  225962:	48 8b 4c 24 20       	mov    rcx,QWORD PTR [rsp+0x20]
  225967:	45 31 ed             	xor    r13d,r13d
  22596a:	48 8d 5c 24 18       	lea    rbx,[rsp+0x18]
  22596f:	31 ed                	xor    ebp,ebp
  225971:	48 3b 8c 24 98 00 00 	cmp    rcx,QWORD PTR [rsp+0x98]
  225978:	00 
  225979:	0f 82 90 07 00 00    	jb     22610f <parseFormValue+0x17cf>
            return result[0];
  22597f:	44 8a bc 24 b0 00 00 	mov    r15b,BYTE PTR [rsp+0xb0]
  225986:	00 
        if (byte == 0) break;
  225987:	45 84 ff             	test   r15b,r15b
  22598a:	0f 84 88 07 00 00    	je     226118 <parseFormValue+0x17d8>
            var better_capacity = self.items.len;
  225990:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
            if (better_capacity >= new_capacity) return;
  225995:	48 39 e9             	cmp    rcx,rbp
  225998:	77 4f                	ja     2259e9 <parseFormValue+0x10a9>
  22599a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
                better_capacity += better_capacity / 2 + 8;
  2259a0:	48 89 c8             	mov    rax,rcx
  2259a3:	48 d1 e8             	shr    rax,1
  2259a6:	48 01 c1             	add    rcx,rax
  2259a9:	48 83 c1 08          	add    rcx,0x8
                if (better_capacity >= new_capacity) break;
  2259ad:	48 39 e9             	cmp    rcx,rbp
  2259b0:	76 ee                	jbe    2259a0 <parseFormValue+0x1060>
            self.items = try self.allocator.alignedRealloc(T, A, self.items, better_capacity);
  2259b2:	48 89 df             	mov    rdi,rbx
  2259b5:	48 8b b4 24 d0 00 00 	mov    rsi,QWORD PTR [rsp+0xd0]
  2259bc:	00 
  2259bd:	48 8d 54 24 40       	lea    rdx,[rsp+0x40]
  2259c2:	e8 89 57 00 00       	call   22b150 <Allocator_alignedRealloc.181>
  2259c7:	0f b7 44 24 18       	movzx  eax,WORD PTR [rsp+0x18]
  2259cc:	66 85 c0             	test   ax,ax
  2259cf:	0f 85 08 f4 ff ff    	jne    224ddd <parseFormValue+0x49d>
  2259d5:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  2259da:	c5 f8 10 00          	vmovups xmm0,XMMWORD PTR [rax]
  2259de:	c5 f8 29 44 24 40    	vmovaps XMMWORD PTR [rsp+0x40],xmm0
            const result = &self.items[self.len];
  2259e4:	4c 8b 6c 24 40       	mov    r13,QWORD PTR [rsp+0x40]
  2259e9:	4c 8d 75 01          	lea    r14,[rbp+0x1]
            self.len = new_length;
  2259ed:	4c 89 74 24 50       	mov    QWORD PTR [rsp+0x50],r14
            new_item_ptr.* = item;
  2259f2:	45 88 7c 2d 00       	mov    BYTE PTR [r13+rbp*1+0x0],r15b
            try self.readNoEof(result[0..]);
  2259f7:	48 8d 84 24 b0 00 00 	lea    rax,[rsp+0xb0]
  2259fe:	00 
  2259ff:	48 89 84 24 90 00 00 	mov    QWORD PTR [rsp+0x90],rax
  225a06:	00 
  225a07:	48 c7 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],0x1
  225a0e:	00 01 00 00 00 
            return self.readFn(self, buffer);
  225a13:	48 89 df             	mov    rdi,rbx
  225a16:	4c 89 e6             	mov    rsi,r12
  225a19:	48 8d 94 24 90 00 00 	lea    rdx,[rsp+0x90]
  225a20:	00 
  225a21:	41 ff 14 24          	call   QWORD PTR [r12]
  225a25:	0f b7 44 24 18       	movzx  eax,WORD PTR [rsp+0x18]
  225a2a:	48 8b 4c 24 20       	mov    rcx,QWORD PTR [rsp+0x20]
  225a2f:	4c 89 f5             	mov    rbp,r14
            const amt_read = try self.read(buf);
  225a32:	66 85 c0             	test   ax,ax
  225a35:	0f 84 36 ff ff ff    	je     225971 <parseFormValue+0x1031>
  225a3b:	e9 9d f3 ff ff       	jmp    224ddd <parseFormValue+0x49d>
  225a40:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  225a45:	31 db                	xor    ebx,ebx
  225a47:	4c 8d 7c 24 40       	lea    r15,[rsp+0x40]
  225a4c:	4c 8d 74 24 18       	lea    r14,[rsp+0x18]
  225a51:	31 ed                	xor    ebp,ebp
            if (amt_read < buf.len) return error.EndOfStream;
  225a53:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  225a58:	0f 82 1f 07 00 00    	jb     22617d <parseFormValue+0x183d>
            return result[0];
  225a5e:	0f b6 84 24 b0 00 00 	movzx  eax,BYTE PTR [rsp+0xb0]
  225a65:	00 
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  225a66:	89 c2                	mov    edx,eax
  225a68:	83 e2 7f             	and    edx,0x7f
  225a6b:	89 ee                	mov    esi,ebp
  225a6d:	83 e6 3f             	and    esi,0x3f
  225a70:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  225a75:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  225a7a:	48 39 d6             	cmp    rsi,rdx
  225a7d:	0f 85 e9 08 00 00    	jne    22636c <parseFormValue+0x1a2c>
        result |= operand;
  225a83:	48 09 cb             	or     rbx,rcx
        if ((byte & 0b10000000) == 0) return result;
  225a86:	84 c0                	test   al,al
  225a88:	0f 89 02 09 00 00    	jns    226390 <parseFormValue+0x1a50>
        shift += 7;
  225a8e:	48 83 c5 07          	add    rbp,0x7
            try self.readNoEof(result[0..]);
  225a92:	4c 89 6c 24 18       	mov    QWORD PTR [rsp+0x18],r13
  225a97:	48 c7 44 24 20 01 00 	mov    QWORD PTR [rsp+0x20],0x1
  225a9e:	00 00 
            return self.readFn(self, buffer);
  225aa0:	4c 89 ff             	mov    rdi,r15
  225aa3:	4c 89 e6             	mov    rsi,r12
  225aa6:	4c 89 f2             	mov    rdx,r14
  225aa9:	41 ff 14 24          	call   QWORD PTR [r12]
  225aad:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
  225ab2:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
            const amt_read = try self.read(buf);
  225ab7:	66 85 c0             	test   ax,ax
  225aba:	74 97                	je     225a53 <parseFormValue+0x1113>
  225abc:	e9 85 f3 ff ff       	jmp    224e46 <parseFormValue+0x506>
    return FormValue{
  225ac1:	c6 84 24 b0 00 00 00 	mov    BYTE PTR [rsp+0xb0],0x0
  225ac8:	00 
  225ac9:	c6 44 24 60 02       	mov    BYTE PTR [rsp+0x60],0x2
  225ace:	66 c7 84 24 a0 01 00 	mov    WORD PTR [rsp+0x1a0],0x0
  225ad5:	00 00 00 
  225ad8:	8b 44 24 78          	mov    eax,DWORD PTR [rsp+0x78]
  225adc:	89 84 24 a2 01 00 00 	mov    DWORD PTR [rsp+0x1a2],eax
        .Const = Constant{
  225ae3:	c5 f8 10 44 24 48    	vmovups xmm0,XMMWORD PTR [rsp+0x48]
    return FormValue{
  225ae9:	0f b7 44 24 7c       	movzx  eax,WORD PTR [rsp+0x7c]
  225aee:	66 89 84 24 a6 01 00 	mov    WORD PTR [rsp+0x1a6],ax
  225af5:	00 
  225af6:	c5 f8 11 84 24 a8 01 	vmovups XMMWORD PTR [rsp+0x1a8],xmm0
  225afd:	00 00 
  225aff:	c6 84 24 b8 01 00 00 	mov    BYTE PTR [rsp+0x1b8],0x0
  225b06:	00 
  225b07:	8b 84 24 90 00 00 00 	mov    eax,DWORD PTR [rsp+0x90]
  225b0e:	89 84 24 b9 01 00 00 	mov    DWORD PTR [rsp+0x1b9],eax
  225b15:	0f b7 84 24 94 00 00 	movzx  eax,WORD PTR [rsp+0x94]
  225b1c:	00 
  225b1d:	66 89 84 24 bd 01 00 	mov    WORD PTR [rsp+0x1bd],ax
  225b24:	00 
  225b25:	8a 84 24 96 00 00 00 	mov    al,BYTE PTR [rsp+0x96]
  225b2c:	88 84 24 bf 01 00 00 	mov    BYTE PTR [rsp+0x1bf],al
  225b33:	c6 84 24 c0 01 00 00 	mov    BYTE PTR [rsp+0x1c0],0x2
  225b3a:	02 
  225b3b:	8a 44 24 1e          	mov    al,BYTE PTR [rsp+0x1e]
  225b3f:	88 84 24 c7 01 00 00 	mov    BYTE PTR [rsp+0x1c7],al
  225b46:	0f b7 44 24 1c       	movzx  eax,WORD PTR [rsp+0x1c]
  225b4b:	66 89 84 24 c5 01 00 	mov    WORD PTR [rsp+0x1c5],ax
  225b52:	00 
  225b53:	8b 44 24 18          	mov    eax,DWORD PTR [rsp+0x18]
  225b57:	89 84 24 c1 01 00 00 	mov    DWORD PTR [rsp+0x1c1],eax
  225b5e:	48 8d 84 24 a0 01 00 	lea    rax,[rsp+0x1a0]
  225b65:	00 
  225b66:	e9 db 07 00 00       	jmp    226346 <parseFormValue+0x1a06>
  225b6b:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  225b70:	31 db                	xor    ebx,ebx
  225b72:	4c 8d 6c 24 40       	lea    r13,[rsp+0x40]
  225b77:	4c 8d 7c 24 18       	lea    r15,[rsp+0x18]
  225b7c:	31 ed                	xor    ebp,ebp
            if (amt_read < buf.len) return error.EndOfStream;
  225b7e:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  225b83:	0f 82 fd 05 00 00    	jb     226186 <parseFormValue+0x1846>
            return result[0];
  225b89:	0f b6 84 24 b0 00 00 	movzx  eax,BYTE PTR [rsp+0xb0]
  225b90:	00 
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  225b91:	89 c2                	mov    edx,eax
  225b93:	83 e2 7f             	and    edx,0x7f
  225b96:	89 ee                	mov    esi,ebp
  225b98:	83 e6 3f             	and    esi,0x3f
  225b9b:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  225ba0:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  225ba5:	48 39 d6             	cmp    rsi,rdx
  225ba8:	0f 85 c7 07 00 00    	jne    226375 <parseFormValue+0x1a35>
        result |= operand;
  225bae:	48 09 cb             	or     rbx,rcx
        if ((byte & 0b10000000) == 0) return result;
  225bb1:	84 c0                	test   al,al
  225bb3:	0f 89 7d 08 00 00    	jns    226436 <parseFormValue+0x1af6>
        shift += 7;
  225bb9:	48 83 c5 07          	add    rbp,0x7
            try self.readNoEof(result[0..]);
  225bbd:	4c 89 74 24 18       	mov    QWORD PTR [rsp+0x18],r14
  225bc2:	48 c7 44 24 20 01 00 	mov    QWORD PTR [rsp+0x20],0x1
  225bc9:	00 00 
            return self.readFn(self, buffer);
  225bcb:	4c 89 ef             	mov    rdi,r13
  225bce:	4c 89 e6             	mov    rsi,r12
  225bd1:	4c 89 fa             	mov    rdx,r15
  225bd4:	41 ff 14 24          	call   QWORD PTR [r12]
  225bd8:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
  225bdd:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
            const amt_read = try self.read(buf);
  225be2:	66 85 c0             	test   ax,ax
  225be5:	74 97                	je     225b7e <parseFormValue+0x123e>
  225be7:	e9 08 f8 ff ff       	jmp    2253f4 <parseFormValue+0xab4>
  225bec:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  225bf1:	45 31 f6             	xor    r14d,r14d
  225bf4:	4c 8d 6c 24 18       	lea    r13,[rsp+0x18]
  225bf9:	31 db                	xor    ebx,ebx
            if (amt_read < buf.len) return error.EndOfStream;
  225bfb:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  225c00:	0f 82 89 05 00 00    	jb     22618f <parseFormValue+0x184f>
            return result[0];
  225c06:	0f b6 84 24 b0 00 00 	movzx  eax,BYTE PTR [rsp+0xb0]
  225c0d:	00 
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  225c0e:	89 c2                	mov    edx,eax
  225c10:	83 e2 7f             	and    edx,0x7f
  225c13:	89 de                	mov    esi,ebx
  225c15:	83 e6 3f             	and    esi,0x3f
  225c18:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  225c1d:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  225c22:	48 39 d6             	cmp    rsi,rdx
  225c25:	0f 85 53 07 00 00    	jne    22637e <parseFormValue+0x1a3e>
        result |= operand;
  225c2b:	49 09 ce             	or     r14,rcx
        if ((byte & 0b10000000) == 0) return result;
  225c2e:	84 c0                	test   al,al
  225c30:	0f 89 a6 08 00 00    	jns    2264dc <parseFormValue+0x1b9c>
        shift += 7;
  225c36:	48 83 c3 07          	add    rbx,0x7
            try self.readNoEof(result[0..]);
  225c3a:	4c 89 7c 24 18       	mov    QWORD PTR [rsp+0x18],r15
  225c3f:	48 c7 44 24 20 01 00 	mov    QWORD PTR [rsp+0x20],0x1
  225c46:	00 00 
            return self.readFn(self, buffer);
  225c48:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  225c4d:	4c 89 e6             	mov    rsi,r12
  225c50:	4c 89 ea             	mov    rdx,r13
  225c53:	41 ff 14 24          	call   QWORD PTR [r12]
  225c57:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
  225c5c:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
            const amt_read = try self.read(buf);
  225c61:	66 85 c0             	test   ax,ax
  225c64:	74 95                	je     225bfb <parseFormValue+0x12bb>
  225c66:	e9 f2 f7 ff ff       	jmp    22545d <parseFormValue+0xb1d>
  225c6b:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  225c70:	31 db                	xor    ebx,ebx
  225c72:	4c 8d 6c 24 40       	lea    r13,[rsp+0x40]
  225c77:	4c 8d 7c 24 18       	lea    r15,[rsp+0x18]
  225c7c:	31 ed                	xor    ebp,ebp
            if (amt_read < buf.len) return error.EndOfStream;
  225c7e:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  225c83:	0f 82 0f 05 00 00    	jb     226198 <parseFormValue+0x1858>
            return result[0];
  225c89:	0f b6 84 24 b0 00 00 	movzx  eax,BYTE PTR [rsp+0xb0]
  225c90:	00 
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  225c91:	89 c2                	mov    edx,eax
  225c93:	83 e2 7f             	and    edx,0x7f
  225c96:	89 ee                	mov    esi,ebp
  225c98:	83 e6 3f             	and    esi,0x3f
  225c9b:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  225ca0:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  225ca5:	48 39 d6             	cmp    rsi,rdx
  225ca8:	0f 85 d9 06 00 00    	jne    226387 <parseFormValue+0x1a47>
        result |= operand;
  225cae:	48 09 cb             	or     rbx,rcx
        if ((byte & 0b10000000) == 0) return result;
  225cb1:	84 c0                	test   al,al
  225cb3:	0f 89 65 08 00 00    	jns    22651e <parseFormValue+0x1bde>
        shift += 7;
  225cb9:	48 83 c5 07          	add    rbp,0x7
            try self.readNoEof(result[0..]);
  225cbd:	4c 89 74 24 18       	mov    QWORD PTR [rsp+0x18],r14
  225cc2:	48 c7 44 24 20 01 00 	mov    QWORD PTR [rsp+0x20],0x1
  225cc9:	00 00 
            return self.readFn(self, buffer);
  225ccb:	4c 89 ef             	mov    rdi,r13
  225cce:	4c 89 e6             	mov    rsi,r12
  225cd1:	4c 89 fa             	mov    rdx,r15
  225cd4:	41 ff 14 24          	call   QWORD PTR [r12]
  225cd8:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
  225cdd:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
            const amt_read = try self.read(buf);
  225ce2:	66 85 c0             	test   ax,ax
  225ce5:	74 97                	je     225c7e <parseFormValue+0x133e>
  225ce7:	e9 3a f8 ff ff       	jmp    225526 <parseFormValue+0xbe6>
  225cec:	66 b8 25 00          	mov    ax,0x25
  225cf0:	e9 d2 ec ff ff       	jmp    2249c7 <parseFormValue+0x87>
  225cf5:	66 b8 29 00          	mov    ax,0x29
  225cf9:	e9 c9 ec ff ff       	jmp    2249c7 <parseFormValue+0x87>
  225cfe:	48 8b 44 24 78       	mov    rax,QWORD PTR [rsp+0x78]
        DW.FORM_addr => FormValue{ .Address = try parseFormValueTargetAddrSize(in_stream) },
  225d03:	66 c7 84 24 08 04 00 	mov    WORD PTR [rsp+0x408],0x0
  225d0a:	00 00 00 
  225d0d:	48 89 84 24 10 04 00 	mov    QWORD PTR [rsp+0x410],rax
  225d14:	00 
  225d15:	c5 f8 10 84 24 08 05 	vmovups xmm0,XMMWORD PTR [rsp+0x508]
  225d1c:	00 00 
  225d1e:	c5 f8 11 84 24 18 04 	vmovups XMMWORD PTR [rsp+0x418],xmm0
  225d25:	00 00 
  225d27:	c6 84 24 28 04 00 00 	mov    BYTE PTR [rsp+0x428],0x0
  225d2e:	00 
  225d2f:	8b 84 24 11 03 00 00 	mov    eax,DWORD PTR [rsp+0x311]
  225d36:	89 84 24 29 04 00 00 	mov    DWORD PTR [rsp+0x429],eax
  225d3d:	0f b7 84 24 15 03 00 	movzx  eax,WORD PTR [rsp+0x315]
  225d44:	00 
  225d45:	66 89 84 24 2d 04 00 	mov    WORD PTR [rsp+0x42d],ax
  225d4c:	00 
  225d4d:	8a 84 24 17 03 00 00 	mov    al,BYTE PTR [rsp+0x317]
  225d54:	88 84 24 2f 04 00 00 	mov    BYTE PTR [rsp+0x42f],al
  225d5b:	48 8d 84 24 08 04 00 	lea    rax,[rsp+0x408]
  225d62:	00 
  225d63:	e9 de 05 00 00       	jmp    226346 <parseFormValue+0x1a06>
  225d68:	48 85 c0             	test   rax,rax
            for (bytes) |b, index| {
  225d6b:	0f 84 00 08 00 00    	je     226571 <parseFormValue+0x1c31>
  225d71:	48 8b 54 24 18       	mov    rdx,QWORD PTR [rsp+0x18]
  225d76:	48 83 f8 10          	cmp    rax,0x10
  225d7a:	0f 83 cc 0b 00 00    	jae    22694c <parseFormValue+0x200c>
  225d80:	31 db                	xor    ebx,ebx
  225d82:	31 c9                	xor    ecx,ecx
  225d84:	e9 b7 11 00 00       	jmp    226f40 <parseFormValue+0x2600>
  225d89:	48 85 c0             	test   rax,rax
  225d8c:	0f 84 e6 07 00 00    	je     226578 <parseFormValue+0x1c38>
  225d92:	48 8b 54 24 18       	mov    rdx,QWORD PTR [rsp+0x18]
  225d97:	48 83 f8 10          	cmp    rax,0x10
  225d9b:	0f 83 c9 0c 00 00    	jae    226a6a <parseFormValue+0x212a>
  225da1:	31 db                	xor    ebx,ebx
  225da3:	31 c9                	xor    ecx,ecx
  225da5:	e9 77 13 00 00       	jmp    227121 <parseFormValue+0x27e1>
  225daa:	48 85 c0             	test   rax,rax
  225dad:	0f 84 cc 07 00 00    	je     22657f <parseFormValue+0x1c3f>
  225db3:	48 8b 54 24 18       	mov    rdx,QWORD PTR [rsp+0x18]
  225db8:	48 83 f8 10          	cmp    rax,0x10
  225dbc:	0f 83 c6 0d 00 00    	jae    226b88 <parseFormValue+0x2248>
  225dc2:	31 db                	xor    ebx,ebx
  225dc4:	31 c9                	xor    ecx,ecx
  225dc6:	e9 37 15 00 00       	jmp    227302 <parseFormValue+0x29c2>
        DW.FORM_flag => FormValue{ .Flag = (try in_stream.readByte()) != 0 },
  225dcb:	80 bc 24 b0 00 00 00 	cmp    BYTE PTR [rsp+0xb0],0x0
  225dd2:	00 
  225dd3:	0f 95 84 24 08 01 00 	setne  BYTE PTR [rsp+0x108]
  225dda:	00 
  225ddb:	66 c7 84 24 18 03 00 	mov    WORD PTR [rsp+0x318],0x0
  225de2:	00 00 00 
  225de5:	0f 95 84 24 20 03 00 	setne  BYTE PTR [rsp+0x320]
  225dec:	00 
  225ded:	c5 f8 10 84 24 69 04 	vmovups xmm0,XMMWORD PTR [rsp+0x469]
  225df4:	00 00 
  225df6:	c5 f8 11 84 24 21 03 	vmovups XMMWORD PTR [rsp+0x321],xmm0
  225dfd:	00 00 
  225dff:	48 8b 84 24 78 04 00 	mov    rax,QWORD PTR [rsp+0x478]
  225e06:	00 
  225e07:	48 89 84 24 30 03 00 	mov    QWORD PTR [rsp+0x330],rax
  225e0e:	00 
  225e0f:	c6 84 24 38 03 00 00 	mov    BYTE PTR [rsp+0x338],0x4
  225e16:	04 
  225e17:	8b 84 24 03 03 00 00 	mov    eax,DWORD PTR [rsp+0x303]
  225e1e:	89 84 24 39 03 00 00 	mov    DWORD PTR [rsp+0x339],eax
  225e25:	0f b7 84 24 07 03 00 	movzx  eax,WORD PTR [rsp+0x307]
  225e2c:	00 
  225e2d:	66 89 84 24 3d 03 00 	mov    WORD PTR [rsp+0x33d],ax
  225e34:	00 
  225e35:	8a 84 24 09 03 00 00 	mov    al,BYTE PTR [rsp+0x309]
  225e3c:	88 84 24 3f 03 00 00 	mov    BYTE PTR [rsp+0x33f],al
  225e43:	48 8d 84 24 18 03 00 	lea    rax,[rsp+0x318]
  225e4a:	00 
  225e4b:	e9 f6 04 00 00       	jmp    226346 <parseFormValue+0x1a06>
            return mem.readInt(bytes, T, endian);
  225e50:	0f b6 8c 24 b0 00 00 	movzx  ecx,BYTE PTR [rsp+0xb0]
  225e57:	00 
  225e58:	48 8d 7c 24 78       	lea    rdi,[rsp+0x78]
    const buf = try readAllocBytes(allocator, in_stream, size);
  225e5d:	4c 89 fe             	mov    rsi,r15
  225e60:	4c 89 e2             	mov    rdx,r12
  225e63:	e8 78 18 00 00       	call   2276e0 <readAllocBytes>
  225e68:	0f b7 44 24 78       	movzx  eax,WORD PTR [rsp+0x78]
  225e6d:	66 85 c0             	test   ax,ax
  225e70:	0f 84 10 07 00 00    	je     226586 <parseFormValue+0x1c46>
  225e76:	c5 f8 10 44 24 40    	vmovups xmm0,XMMWORD PTR [rsp+0x40]
  225e7c:	c5 fa 6f 4c 24 4e    	vmovdqu xmm1,XMMWORD PTR [rsp+0x4e]
  225e82:	c5 fa 7f 8c 24 9e 00 	vmovdqu XMMWORD PTR [rsp+0x9e],xmm1
  225e89:	00 00 
  225e8b:	c5 f8 29 84 24 90 00 	vmovaps XMMWORD PTR [rsp+0x90],xmm0
  225e92:	00 00 
  225e94:	8b 4c 24 60          	mov    ecx,DWORD PTR [rsp+0x60]
  225e98:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  225e9b:	0f b7 4c 24 64       	movzx  ecx,WORD PTR [rsp+0x64]
  225ea0:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  225ea5:	8a 4c 24 66          	mov    cl,BYTE PTR [rsp+0x66]
  225ea9:	88 4c 24 06          	mov    BYTE PTR [rsp+0x6],cl
  225ead:	e9 39 07 00 00       	jmp    2265eb <parseFormValue+0x1cab>
  225eb2:	0f b6 44 24 78       	movzx  eax,BYTE PTR [rsp+0x78]
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  225eb7:	0f b6 4c 24 79       	movzx  ecx,BYTE PTR [rsp+0x79]
  225ebc:	48 c1 e1 08          	shl    rcx,0x8
  225ec0:	48 09 c1             	or     rcx,rax
  225ec3:	48 8d 7c 24 78       	lea    rdi,[rsp+0x78]
  225ec8:	4c 89 fe             	mov    rsi,r15
  225ecb:	4c 89 e2             	mov    rdx,r12
  225ece:	e8 0d 18 00 00       	call   2276e0 <readAllocBytes>
  225ed3:	0f b7 44 24 78       	movzx  eax,WORD PTR [rsp+0x78]
  225ed8:	66 85 c0             	test   ax,ax
  225edb:	0f 84 5d 07 00 00    	je     22663e <parseFormValue+0x1cfe>
  225ee1:	c5 f8 10 44 24 40    	vmovups xmm0,XMMWORD PTR [rsp+0x40]
  225ee7:	c5 fa 6f 4c 24 4e    	vmovdqu xmm1,XMMWORD PTR [rsp+0x4e]
  225eed:	c5 fa 7f 8c 24 9e 00 	vmovdqu XMMWORD PTR [rsp+0x9e],xmm1
  225ef4:	00 00 
  225ef6:	c5 f8 29 84 24 90 00 	vmovaps XMMWORD PTR [rsp+0x90],xmm0
  225efd:	00 00 
  225eff:	8b 4c 24 60          	mov    ecx,DWORD PTR [rsp+0x60]
  225f03:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  225f06:	0f b7 4c 24 64       	movzx  ecx,WORD PTR [rsp+0x64]
  225f0b:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  225f10:	8a 4c 24 66          	mov    cl,BYTE PTR [rsp+0x66]
  225f14:	88 4c 24 06          	mov    BYTE PTR [rsp+0x6],cl
  225f18:	e9 86 07 00 00       	jmp    2266a3 <parseFormValue+0x1d63>
  225f1d:	0f b6 44 24 78       	movzx  eax,BYTE PTR [rsp+0x78]
  225f22:	0f b6 4c 24 79       	movzx  ecx,BYTE PTR [rsp+0x79]
  225f27:	48 c1 e1 08          	shl    rcx,0x8
  225f2b:	48 09 c1             	or     rcx,rax
  225f2e:	0f b6 44 24 7a       	movzx  eax,BYTE PTR [rsp+0x7a]
  225f33:	48 c1 e0 10          	shl    rax,0x10
  225f37:	48 09 c8             	or     rax,rcx
  225f3a:	0f b6 4c 24 7b       	movzx  ecx,BYTE PTR [rsp+0x7b]
  225f3f:	48 c1 e1 18          	shl    rcx,0x18
  225f43:	48 09 c1             	or     rcx,rax
  225f46:	48 8d 7c 24 78       	lea    rdi,[rsp+0x78]
  225f4b:	4c 89 fe             	mov    rsi,r15
  225f4e:	4c 89 e2             	mov    rdx,r12
  225f51:	e8 8a 17 00 00       	call   2276e0 <readAllocBytes>
  225f56:	0f b7 44 24 78       	movzx  eax,WORD PTR [rsp+0x78]
  225f5b:	66 85 c0             	test   ax,ax
  225f5e:	0f 84 92 07 00 00    	je     2266f6 <parseFormValue+0x1db6>
  225f64:	c5 f8 10 44 24 40    	vmovups xmm0,XMMWORD PTR [rsp+0x40]
  225f6a:	c5 fa 6f 4c 24 4e    	vmovdqu xmm1,XMMWORD PTR [rsp+0x4e]
  225f70:	c5 fa 7f 8c 24 9e 00 	vmovdqu XMMWORD PTR [rsp+0x9e],xmm1
  225f77:	00 00 
  225f79:	c5 f8 29 84 24 90 00 	vmovaps XMMWORD PTR [rsp+0x90],xmm0
  225f80:	00 00 
  225f82:	8b 4c 24 60          	mov    ecx,DWORD PTR [rsp+0x60]
  225f86:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  225f89:	0f b7 4c 24 64       	movzx  ecx,WORD PTR [rsp+0x64]
  225f8e:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  225f93:	8a 4c 24 66          	mov    cl,BYTE PTR [rsp+0x66]
  225f97:	88 4c 24 06          	mov    BYTE PTR [rsp+0x6],cl
  225f9b:	e9 bb 07 00 00       	jmp    22675b <parseFormValue+0x1e1b>
  225fa0:	48 8b 4c 24 78       	mov    rcx,QWORD PTR [rsp+0x78]
  225fa5:	48 8d 7c 24 78       	lea    rdi,[rsp+0x78]
  225faa:	4c 89 fe             	mov    rsi,r15
  225fad:	4c 89 e2             	mov    rdx,r12
  225fb0:	e8 2b 17 00 00       	call   2276e0 <readAllocBytes>
  225fb5:	0f b7 44 24 78       	movzx  eax,WORD PTR [rsp+0x78]
  225fba:	66 85 c0             	test   ax,ax
  225fbd:	0f 84 eb 07 00 00    	je     2267ae <parseFormValue+0x1e6e>
  225fc3:	c5 f8 10 44 24 40    	vmovups xmm0,XMMWORD PTR [rsp+0x40]
  225fc9:	c5 fa 6f 4c 24 4e    	vmovdqu xmm1,XMMWORD PTR [rsp+0x4e]
  225fcf:	c5 fa 7f 8c 24 9e 00 	vmovdqu XMMWORD PTR [rsp+0x9e],xmm1
  225fd6:	00 00 
  225fd8:	c5 f8 29 84 24 90 00 	vmovaps XMMWORD PTR [rsp+0x90],xmm0
  225fdf:	00 00 
  225fe1:	8b 4c 24 60          	mov    ecx,DWORD PTR [rsp+0x60]
  225fe5:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  225fe8:	0f b7 4c 24 64       	movzx  ecx,WORD PTR [rsp+0x64]
  225fed:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  225ff2:	8a 4c 24 66          	mov    cl,BYTE PTR [rsp+0x66]
  225ff6:	88 4c 24 06          	mov    BYTE PTR [rsp+0x6],cl
  225ffa:	e9 14 08 00 00       	jmp    226813 <parseFormValue+0x1ed3>
  225fff:	48 8b 44 24 78       	mov    rax,QWORD PTR [rsp+0x78]
        DW.FORM_ref_sig8 => FormValue{ .RefSig8 = try in_stream.readIntLe(u64) },
  226004:	66 c7 84 24 90 03 00 	mov    WORD PTR [rsp+0x390],0x0
  22600b:	00 00 00 
  22600e:	48 89 84 24 98 03 00 	mov    QWORD PTR [rsp+0x398],rax
  226015:	00 
  226016:	c5 f8 10 84 24 d8 04 	vmovups xmm0,XMMWORD PTR [rsp+0x4d8]
  22601d:	00 00 
  22601f:	c5 f8 11 84 24 a0 03 	vmovups XMMWORD PTR [rsp+0x3a0],xmm0
  226026:	00 00 
  226028:	c6 84 24 b0 03 00 00 	mov    BYTE PTR [rsp+0x3b0],0x8
  22602f:	08 
  226030:	8b 84 24 ee 02 00 00 	mov    eax,DWORD PTR [rsp+0x2ee]
  226037:	89 84 24 b1 03 00 00 	mov    DWORD PTR [rsp+0x3b1],eax
  22603e:	0f b7 84 24 f2 02 00 	movzx  eax,WORD PTR [rsp+0x2f2]
  226045:	00 
  226046:	66 89 84 24 b5 03 00 	mov    WORD PTR [rsp+0x3b5],ax
  22604d:	00 
  22604e:	8a 84 24 f4 02 00 00 	mov    al,BYTE PTR [rsp+0x2f4]
  226055:	88 84 24 b7 03 00 00 	mov    BYTE PTR [rsp+0x3b7],al
  22605c:	48 8d 84 24 90 03 00 	lea    rax,[rsp+0x390]
  226063:	00 
  226064:	e9 dd 02 00 00       	jmp    226346 <parseFormValue+0x1a06>
  226069:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
            .payload = try readAllocBytes(allocator, in_stream, size),
  22606e:	48 8b b4 24 d0 00 00 	mov    rsi,QWORD PTR [rsp+0xd0]
  226075:	00 
  226076:	4c 89 e2             	mov    rdx,r12
  226079:	48 89 e9             	mov    rcx,rbp
  22607c:	e8 5f 16 00 00       	call   2276e0 <readAllocBytes>
  226081:	0f b7 54 24 40       	movzx  edx,WORD PTR [rsp+0x40]
  226086:	66 85 d2             	test   dx,dx
  226089:	48 8b 6c 24 68       	mov    rbp,QWORD PTR [rsp+0x68]
  22608e:	0f 84 d2 07 00 00    	je     226866 <parseFormValue+0x1f26>
  226094:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  226099:	66 89 84 24 1c 01 00 	mov    WORD PTR [rsp+0x11c],ax
  2260a0:	00 
  2260a1:	8b 44 24 3a          	mov    eax,DWORD PTR [rsp+0x3a]
  2260a5:	89 84 24 18 01 00 00 	mov    DWORD PTR [rsp+0x118],eax
  2260ac:	8b 44 24 11          	mov    eax,DWORD PTR [rsp+0x11]
  2260b0:	89 84 24 f0 00 00 00 	mov    DWORD PTR [rsp+0xf0],eax
  2260b7:	0f b7 44 24 15       	movzx  eax,WORD PTR [rsp+0x15]
  2260bc:	66 89 84 24 f4 00 00 	mov    WORD PTR [rsp+0xf4],ax
  2260c3:	00 
  2260c4:	8a 44 24 17          	mov    al,BYTE PTR [rsp+0x17]
  2260c8:	88 84 24 f6 00 00 00 	mov    BYTE PTR [rsp+0xf6],al
  2260cf:	48 8d b4 24 18 01 00 	lea    rsi,[rsp+0x118]
  2260d6:	00 
  2260d7:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  2260db:	89 84 24 e8 00 00 00 	mov    DWORD PTR [rsp+0xe8],eax
  2260e2:	48 8d 84 24 f0 00 00 	lea    rax,[rsp+0xf0]
  2260e9:	00 
  2260ea:	0f b7 4c 24 0e       	movzx  ecx,WORD PTR [rsp+0xe]
  2260ef:	66 89 8c 24 ec 00 00 	mov    WORD PTR [rsp+0xec],cx
  2260f6:	00 
  2260f7:	48 8d 8c 24 e8 00 00 	lea    rcx,[rsp+0xe8]
  2260fe:	00 
  2260ff:	8a 5c 24 10          	mov    bl,BYTE PTR [rsp+0x10]
  226103:	88 9c 24 ee 00 00 00 	mov    BYTE PTR [rsp+0xee],bl
  22610a:	e9 f5 07 00 00       	jmp    226904 <parseFormValue+0x1fc4>
  22610f:	66 b8 25 00          	mov    ax,0x25
  226113:	e9 c5 ec ff ff       	jmp    224ddd <parseFormValue+0x49d>
            return self.items[0..self.len];
  226118:	48 8b 44 24 40       	mov    rax,QWORD PTR [rsp+0x40]
        DW.FORM_string => FormValue{ .String = try readStringRaw(allocator, in_stream) },
  22611d:	66 c7 84 24 68 03 00 	mov    WORD PTR [rsp+0x368],0x0
  226124:	00 00 00 
  226127:	48 89 84 24 70 03 00 	mov    QWORD PTR [rsp+0x370],rax
  22612e:	00 
  22612f:	48 89 ac 24 78 03 00 	mov    QWORD PTR [rsp+0x378],rbp
  226136:	00 
  226137:	c6 84 24 88 03 00 00 	mov    BYTE PTR [rsp+0x388],0x9
  22613e:	09 
  22613f:	8b 84 24 e7 02 00 00 	mov    eax,DWORD PTR [rsp+0x2e7]
  226146:	89 84 24 89 03 00 00 	mov    DWORD PTR [rsp+0x389],eax
  22614d:	0f b7 84 24 eb 02 00 	movzx  eax,WORD PTR [rsp+0x2eb]
  226154:	00 
  226155:	66 89 84 24 8d 03 00 	mov    WORD PTR [rsp+0x38d],ax
  22615c:	00 
  22615d:	8a 84 24 ed 02 00 00 	mov    al,BYTE PTR [rsp+0x2ed]
  226164:	88 84 24 8f 03 00 00 	mov    BYTE PTR [rsp+0x38f],al
  22616b:	48 8d 84 24 68 03 00 	lea    rax,[rsp+0x368]
  226172:	00 
  226173:	4c 8b 74 24 68       	mov    r14,QWORD PTR [rsp+0x68]
  226178:	e9 c9 01 00 00       	jmp    226346 <parseFormValue+0x1a06>
  22617d:	66 b8 25 00          	mov    ax,0x25
  226181:	e9 c0 ec ff ff       	jmp    224e46 <parseFormValue+0x506>
  226186:	66 b8 25 00          	mov    ax,0x25
  22618a:	e9 65 f2 ff ff       	jmp    2253f4 <parseFormValue+0xab4>
  22618f:	66 b8 25 00          	mov    ax,0x25
  226193:	e9 c5 f2 ff ff       	jmp    22545d <parseFormValue+0xb1d>
  226198:	66 b8 25 00          	mov    ax,0x25
  22619c:	e9 85 f3 ff ff       	jmp    225526 <parseFormValue+0xbe6>
  2261a1:	0f b6 44 24 78       	movzx  eax,BYTE PTR [rsp+0x78]
  2261a6:	0f b6 4c 24 79       	movzx  ecx,BYTE PTR [rsp+0x79]
  2261ab:	48 c1 e1 08          	shl    rcx,0x8
  2261af:	48 09 c1             	or     rcx,rax
  2261b2:	0f b6 54 24 7a       	movzx  edx,BYTE PTR [rsp+0x7a]
  2261b7:	48 c1 e2 10          	shl    rdx,0x10
  2261bb:	48 09 ca             	or     rdx,rcx
  2261be:	0f b6 44 24 7b       	movzx  eax,BYTE PTR [rsp+0x7b]
  2261c3:	48 c1 e0 18          	shl    rax,0x18
  2261c7:	48 09 d0             	or     rax,rdx
        DW.FORM_strp => FormValue{ .StrPtr = try parseFormValueDwarfOffsetSize(in_stream, is_64) },
  2261ca:	66 c7 84 24 40 03 00 	mov    WORD PTR [rsp+0x340],0x0
  2261d1:	00 00 00 
  2261d4:	48 89 84 24 48 03 00 	mov    QWORD PTR [rsp+0x348],rax
  2261db:	00 
  2261dc:	c5 f8 10 84 24 c8 04 	vmovups xmm0,XMMWORD PTR [rsp+0x4c8]
  2261e3:	00 00 
  2261e5:	c5 f8 11 84 24 50 03 	vmovups XMMWORD PTR [rsp+0x350],xmm0
  2261ec:	00 00 
  2261ee:	c6 84 24 60 03 00 00 	mov    BYTE PTR [rsp+0x360],0xa
  2261f5:	0a 
  2261f6:	8b 84 24 e0 02 00 00 	mov    eax,DWORD PTR [rsp+0x2e0]
  2261fd:	89 84 24 61 03 00 00 	mov    DWORD PTR [rsp+0x361],eax
  226204:	0f b7 84 24 e4 02 00 	movzx  eax,WORD PTR [rsp+0x2e4]
  22620b:	00 
  22620c:	66 89 84 24 65 03 00 	mov    WORD PTR [rsp+0x365],ax
  226213:	00 
  226214:	8a 84 24 e6 02 00 00 	mov    al,BYTE PTR [rsp+0x2e6]
  22621b:	88 84 24 67 03 00 00 	mov    BYTE PTR [rsp+0x367],al
  226222:	48 8d 84 24 40 03 00 	lea    rax,[rsp+0x340]
  226229:	00 
  22622a:	e9 17 01 00 00       	jmp    226346 <parseFormValue+0x1a06>
  22622f:	0f b6 44 24 78       	movzx  eax,BYTE PTR [rsp+0x78]
  226234:	0f b6 4c 24 79       	movzx  ecx,BYTE PTR [rsp+0x79]
  226239:	48 c1 e1 08          	shl    rcx,0x8
  22623d:	48 09 c1             	or     rcx,rax
  226240:	0f b6 54 24 7a       	movzx  edx,BYTE PTR [rsp+0x7a]
  226245:	48 c1 e2 10          	shl    rdx,0x10
  226249:	48 09 ca             	or     rdx,rcx
  22624c:	0f b6 44 24 7b       	movzx  eax,BYTE PTR [rsp+0x7b]
  226251:	48 c1 e0 18          	shl    rax,0x18
  226255:	48 09 d0             	or     rax,rdx
        DW.FORM_ref_addr => FormValue{ .RefAddr = try parseFormValueDwarfOffsetSize(in_stream, is_64) },
  226258:	66 c7 84 24 b8 03 00 	mov    WORD PTR [rsp+0x3b8],0x0
  22625f:	00 00 00 
  226262:	48 89 84 24 c0 03 00 	mov    QWORD PTR [rsp+0x3c0],rax
  226269:	00 
  22626a:	c5 f8 10 84 24 e8 04 	vmovups xmm0,XMMWORD PTR [rsp+0x4e8]
  226271:	00 00 
  226273:	c5 f8 11 84 24 c8 03 	vmovups XMMWORD PTR [rsp+0x3c8],xmm0
  22627a:	00 00 
  22627c:	c6 84 24 d8 03 00 00 	mov    BYTE PTR [rsp+0x3d8],0x7
  226283:	07 
  226284:	8b 84 24 f5 02 00 00 	mov    eax,DWORD PTR [rsp+0x2f5]
  22628b:	89 84 24 d9 03 00 00 	mov    DWORD PTR [rsp+0x3d9],eax
  226292:	0f b7 84 24 f9 02 00 	movzx  eax,WORD PTR [rsp+0x2f9]
  226299:	00 
  22629a:	66 89 84 24 dd 03 00 	mov    WORD PTR [rsp+0x3dd],ax
  2262a1:	00 
  2262a2:	8a 84 24 fb 02 00 00 	mov    al,BYTE PTR [rsp+0x2fb]
  2262a9:	88 84 24 df 03 00 00 	mov    BYTE PTR [rsp+0x3df],al
  2262b0:	48 8d 84 24 b8 03 00 	lea    rax,[rsp+0x3b8]
  2262b7:	00 
  2262b8:	e9 89 00 00 00       	jmp    226346 <parseFormValue+0x1a06>
  2262bd:	0f b6 44 24 78       	movzx  eax,BYTE PTR [rsp+0x78]
  2262c2:	0f b6 4c 24 79       	movzx  ecx,BYTE PTR [rsp+0x79]
  2262c7:	48 c1 e1 08          	shl    rcx,0x8
  2262cb:	48 09 c1             	or     rcx,rax
  2262ce:	0f b6 54 24 7a       	movzx  edx,BYTE PTR [rsp+0x7a]
  2262d3:	48 c1 e2 10          	shl    rdx,0x10
  2262d7:	48 09 ca             	or     rdx,rcx
  2262da:	0f b6 44 24 7b       	movzx  eax,BYTE PTR [rsp+0x7b]
  2262df:	48 c1 e0 18          	shl    rax,0x18
  2262e3:	48 09 d0             	or     rax,rdx
        DW.FORM_sec_offset => FormValue{ .SecOffset = try parseFormValueDwarfOffsetSize(in_stream, is_64) },
  2262e6:	66 c7 84 24 e0 03 00 	mov    WORD PTR [rsp+0x3e0],0x0
  2262ed:	00 00 00 
  2262f0:	48 89 84 24 e8 03 00 	mov    QWORD PTR [rsp+0x3e8],rax
  2262f7:	00 
  2262f8:	c5 f8 10 84 24 f8 04 	vmovups xmm0,XMMWORD PTR [rsp+0x4f8]
  2262ff:	00 00 
  226301:	c5 f8 11 84 24 f0 03 	vmovups XMMWORD PTR [rsp+0x3f0],xmm0
  226308:	00 00 
  22630a:	c6 84 24 00 04 00 00 	mov    BYTE PTR [rsp+0x400],0x5
  226311:	05 
  226312:	8b 84 24 fc 02 00 00 	mov    eax,DWORD PTR [rsp+0x2fc]
  226319:	89 84 24 01 04 00 00 	mov    DWORD PTR [rsp+0x401],eax
  226320:	0f b7 84 24 00 03 00 	movzx  eax,WORD PTR [rsp+0x300]
  226327:	00 
  226328:	66 89 84 24 05 04 00 	mov    WORD PTR [rsp+0x405],ax
  22632f:	00 
  226330:	8a 84 24 02 03 00 00 	mov    al,BYTE PTR [rsp+0x302]
  226337:	88 84 24 07 04 00 00 	mov    BYTE PTR [rsp+0x407],al
  22633e:	48 8d 84 24 e0 03 00 	lea    rax,[rsp+0x3e0]
  226345:	00 
    return switch (form_id) {
  226346:	48 8b 48 20          	mov    rcx,QWORD PTR [rax+0x20]
  22634a:	49 89 4e 20          	mov    QWORD PTR [r14+0x20],rcx
  22634e:	c5 fc 10 00          	vmovups ymm0,YMMWORD PTR [rax]
  226352:	c4 c1 7c 11 06       	vmovups YMMWORD PTR [r14],ymm0
  226357:	48 81 c4 08 07 00 00 	add    rsp,0x708
  22635e:	5b                   	pop    rbx
  22635f:	41 5c                	pop    r12
  226361:	41 5d                	pop    r13
  226363:	41 5e                	pop    r14
  226365:	41 5f                	pop    r15
  226367:	5d                   	pop    rbp
  226368:	c5 f8 77             	vzeroupper 
  22636b:	c3                   	ret    
  22636c:	66 b8 29 00          	mov    ax,0x29
  226370:	e9 d1 ea ff ff       	jmp    224e46 <parseFormValue+0x506>
  226375:	66 b8 29 00          	mov    ax,0x29
  226379:	e9 76 f0 ff ff       	jmp    2253f4 <parseFormValue+0xab4>
  22637e:	66 b8 29 00          	mov    ax,0x29
  226382:	e9 d6 f0 ff ff       	jmp    22545d <parseFormValue+0xb1d>
  226387:	66 b8 29 00          	mov    ax,0x29
  22638b:	e9 96 f1 ff ff       	jmp    225526 <parseFormValue+0xbe6>
  226390:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
    const buf = try readAllocBytes(allocator, in_stream, size);
  226395:	48 8b b4 24 d0 00 00 	mov    rsi,QWORD PTR [rsp+0xd0]
  22639c:	00 
  22639d:	4c 89 e2             	mov    rdx,r12
  2263a0:	48 89 d9             	mov    rcx,rbx
  2263a3:	e8 38 13 00 00       	call   2276e0 <readAllocBytes>
  2263a8:	0f b7 4c 24 40       	movzx  ecx,WORD PTR [rsp+0x40]
  2263ad:	66 85 c9             	test   cx,cx
  2263b0:	48 8b 7c 24 68       	mov    rdi,QWORD PTR [rsp+0x68]
  2263b5:	0f 84 eb 08 00 00    	je     226ca6 <parseFormValue+0x2366>
  2263bb:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  2263c0:	66 89 84 24 24 01 00 	mov    WORD PTR [rsp+0x124],ax
  2263c7:	00 
  2263c8:	8b 44 24 3a          	mov    eax,DWORD PTR [rsp+0x3a]
  2263cc:	89 84 24 20 01 00 00 	mov    DWORD PTR [rsp+0x120],eax
  2263d3:	8b 44 24 11          	mov    eax,DWORD PTR [rsp+0x11]
  2263d7:	89 84 24 00 01 00 00 	mov    DWORD PTR [rsp+0x100],eax
  2263de:	0f b7 44 24 15       	movzx  eax,WORD PTR [rsp+0x15]
  2263e3:	66 89 84 24 04 01 00 	mov    WORD PTR [rsp+0x104],ax
  2263ea:	00 
  2263eb:	8a 44 24 17          	mov    al,BYTE PTR [rsp+0x17]
  2263ef:	88 84 24 06 01 00 00 	mov    BYTE PTR [rsp+0x106],al
  2263f6:	48 8d b4 24 20 01 00 	lea    rsi,[rsp+0x120]
  2263fd:	00 
  2263fe:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  226402:	89 84 24 f8 00 00 00 	mov    DWORD PTR [rsp+0xf8],eax
  226409:	48 8d 84 24 00 01 00 	lea    rax,[rsp+0x100]
  226410:	00 
  226411:	0f b7 54 24 0e       	movzx  edx,WORD PTR [rsp+0xe]
  226416:	66 89 94 24 fc 00 00 	mov    WORD PTR [rsp+0xfc],dx
  22641d:	00 
  22641e:	48 8d 94 24 f8 00 00 	lea    rdx,[rsp+0xf8]
  226425:	00 
  226426:	8a 5c 24 10          	mov    bl,BYTE PTR [rsp+0x10]
  22642a:	88 9c 24 fe 00 00 00 	mov    BYTE PTR [rsp+0xfe],bl
  226431:	e9 a1 00 00 00       	jmp    2264d7 <parseFormValue+0x1b97>
  226436:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
    const buf = try readAllocBytes(allocator, in_stream, size);
  22643b:	48 8b b4 24 d0 00 00 	mov    rsi,QWORD PTR [rsp+0xd0]
  226442:	00 
  226443:	4c 89 e2             	mov    rdx,r12
  226446:	48 89 d9             	mov    rcx,rbx
  226449:	e8 92 12 00 00       	call   2276e0 <readAllocBytes>
  22644e:	0f b7 4c 24 40       	movzx  ecx,WORD PTR [rsp+0x40]
  226453:	66 85 c9             	test   cx,cx
  226456:	48 8b 7c 24 68       	mov    rdi,QWORD PTR [rsp+0x68]
  22645b:	0f 84 d9 08 00 00    	je     226d3a <parseFormValue+0x23fa>
  226461:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  226466:	66 89 84 24 14 01 00 	mov    WORD PTR [rsp+0x114],ax
  22646d:	00 
  22646e:	8b 44 24 3a          	mov    eax,DWORD PTR [rsp+0x3a]
  226472:	89 84 24 10 01 00 00 	mov    DWORD PTR [rsp+0x110],eax
  226479:	8b 44 24 11          	mov    eax,DWORD PTR [rsp+0x11]
  22647d:	89 84 24 e0 00 00 00 	mov    DWORD PTR [rsp+0xe0],eax
  226484:	0f b7 44 24 15       	movzx  eax,WORD PTR [rsp+0x15]
  226489:	66 89 84 24 e4 00 00 	mov    WORD PTR [rsp+0xe4],ax
  226490:	00 
  226491:	8a 44 24 17          	mov    al,BYTE PTR [rsp+0x17]
  226495:	88 84 24 e6 00 00 00 	mov    BYTE PTR [rsp+0xe6],al
  22649c:	48 8d b4 24 10 01 00 	lea    rsi,[rsp+0x110]
  2264a3:	00 
  2264a4:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  2264a8:	89 84 24 d8 00 00 00 	mov    DWORD PTR [rsp+0xd8],eax
  2264af:	48 8d 84 24 e0 00 00 	lea    rax,[rsp+0xe0]
  2264b6:	00 
  2264b7:	0f b7 54 24 0e       	movzx  edx,WORD PTR [rsp+0xe]
  2264bc:	66 89 94 24 dc 00 00 	mov    WORD PTR [rsp+0xdc],dx
  2264c3:	00 
  2264c4:	48 8d 94 24 d8 00 00 	lea    rdx,[rsp+0xd8]
  2264cb:	00 
  2264cc:	8a 5c 24 10          	mov    bl,BYTE PTR [rsp+0x10]
  2264d0:	88 9c 24 de 00 00 00 	mov    BYTE PTR [rsp+0xde],bl
  2264d7:	e9 ef 08 00 00       	jmp    226dcb <parseFormValue+0x248b>
            return parseFormValue(allocator, in_stream, child_form_id, is_64);
  2264dc:	44 0f b6 c5          	movzx  r8d,bpl
  2264e0:	48 8d bc 24 a0 04 00 	lea    rdi,[rsp+0x4a0]
  2264e7:	00 
  2264e8:	48 8b b4 24 d0 00 00 	mov    rsi,QWORD PTR [rsp+0xd0]
  2264ef:	00 
  2264f0:	4c 89 e2             	mov    rdx,r12
  2264f3:	4c 89 f1             	mov    rcx,r14
  2264f6:	e8 45 e4 ff ff       	call   224940 <parseFormValue>
  2264fb:	48 8b 84 24 c0 04 00 	mov    rax,QWORD PTR [rsp+0x4c0]
  226502:	00 
  226503:	48 8b 4c 24 68       	mov    rcx,QWORD PTR [rsp+0x68]
  226508:	48 89 41 20          	mov    QWORD PTR [rcx+0x20],rax
  22650c:	c5 fc 10 84 24 a0 04 	vmovups ymm0,YMMWORD PTR [rsp+0x4a0]
  226513:	00 00 
  226515:	c5 fc 11 01          	vmovups YMMWORD PTR [rcx],ymm0
  226519:	e9 39 fe ff ff       	jmp    226357 <parseFormValue+0x1a17>
  22651e:	48 8d bc 24 50 04 00 	lea    rdi,[rsp+0x450]
  226525:	00 
            const buf = try readAllocBytes(allocator, in_stream, size);
  226526:	48 8b b4 24 d0 00 00 	mov    rsi,QWORD PTR [rsp+0xd0]
  22652d:	00 
  22652e:	4c 89 e2             	mov    rdx,r12
  226531:	48 89 d9             	mov    rcx,rbx
  226534:	e8 a7 11 00 00       	call   2276e0 <readAllocBytes>
  226539:	0f b7 84 24 50 04 00 	movzx  eax,WORD PTR [rsp+0x450]
  226540:	00 
  226541:	66 85 c0             	test   ax,ax
  226544:	0f 84 c4 08 00 00    	je     226e0e <parseFormValue+0x24ce>
  22654a:	48 8b 4c 24 68       	mov    rcx,QWORD PTR [rsp+0x68]
  22654f:	66 89 01             	mov    WORD PTR [rcx],ax
  226552:	48 8b 84 24 68 06 00 	mov    rax,QWORD PTR [rsp+0x668]
  226559:	00 
  22655a:	48 89 41 20          	mov    QWORD PTR [rcx+0x20],rax
  22655e:	c5 fc 10 84 24 4a 06 	vmovups ymm0,YMMWORD PTR [rsp+0x64a]
  226565:	00 00 
  226567:	c5 fc 11 41 02       	vmovups YMMWORD PTR [rcx+0x2],ymm0
  22656c:	e9 e6 fd ff ff       	jmp    226357 <parseFormValue+0x1a17>
  226571:	31 c9                	xor    ecx,ecx
  226573:	e9 f1 09 00 00       	jmp    226f69 <parseFormValue+0x2629>
  226578:	31 c9                	xor    ecx,ecx
  22657a:	e9 cb 0b 00 00       	jmp    22714a <parseFormValue+0x280a>
  22657f:	31 c9                	xor    ecx,ecx
  226581:	e9 a5 0d 00 00       	jmp    22732b <parseFormValue+0x29eb>
    const buf = try readAllocBytes(allocator, in_stream, size);
  226586:	c5 f8 10 84 24 80 00 	vmovups xmm0,XMMWORD PTR [rsp+0x80]
  22658d:	00 00 
  22658f:	c5 f8 29 84 24 b0 00 	vmovaps XMMWORD PTR [rsp+0xb0],xmm0
  226596:	00 00 
    return FormValue{ .Ref = buf };
  226598:	c5 f8 11 44 24 1e    	vmovups XMMWORD PTR [rsp+0x1e],xmm0
  22659e:	48 8b 84 24 c0 00 00 	mov    rax,QWORD PTR [rsp+0xc0]
  2265a5:	00 
  2265a6:	48 89 44 24 2e       	mov    QWORD PTR [rsp+0x2e],rax
  2265ab:	c6 44 24 08 06       	mov    BYTE PTR [rsp+0x8],0x6
  2265b0:	8b 44 24 71          	mov    eax,DWORD PTR [rsp+0x71]
  2265b4:	89 04 24             	mov    DWORD PTR [rsp],eax
  2265b7:	0f b7 44 24 75       	movzx  eax,WORD PTR [rsp+0x75]
  2265bc:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  2265c1:	8a 44 24 77          	mov    al,BYTE PTR [rsp+0x77]
  2265c5:	88 44 24 06          	mov    BYTE PTR [rsp+0x6],al
  2265c9:	c5 f8 10 44 24 18    	vmovups xmm0,XMMWORD PTR [rsp+0x18]
  2265cf:	c5 f8 29 84 24 90 00 	vmovaps XMMWORD PTR [rsp+0x90],xmm0
  2265d6:	00 00 
  2265d8:	c5 f8 10 44 24 26    	vmovups xmm0,XMMWORD PTR [rsp+0x26]
  2265de:	c5 f8 11 84 24 9e 00 	vmovups XMMWORD PTR [rsp+0x9e],xmm0
  2265e5:	00 00 
  2265e7:	b1 06                	mov    cl,0x6
  2265e9:	31 c0                	xor    eax,eax
    return parseFormValueRefLen(allocator, in_stream, block_len);
  2265eb:	66 89 84 24 40 02 00 	mov    WORD PTR [rsp+0x240],ax
  2265f2:	00 
  2265f3:	c5 f8 28 84 24 90 00 	vmovaps xmm0,XMMWORD PTR [rsp+0x90]
  2265fa:	00 00 
  2265fc:	c5 f8 11 84 24 42 02 	vmovups XMMWORD PTR [rsp+0x242],xmm0
  226603:	00 00 
  226605:	c5 f8 10 84 24 9e 00 	vmovups xmm0,XMMWORD PTR [rsp+0x9e]
  22660c:	00 00 
  22660e:	c5 f8 11 84 24 50 02 	vmovups XMMWORD PTR [rsp+0x250],xmm0
  226615:	00 00 
  226617:	88 8c 24 60 02 00 00 	mov    BYTE PTR [rsp+0x260],cl
  22661e:	8b 04 24             	mov    eax,DWORD PTR [rsp]
  226621:	89 84 24 61 02 00 00 	mov    DWORD PTR [rsp+0x261],eax
  226628:	0f b7 44 24 04       	movzx  eax,WORD PTR [rsp+0x4]
  22662d:	66 89 84 24 65 02 00 	mov    WORD PTR [rsp+0x265],ax
  226634:	00 
  226635:	8a 44 24 06          	mov    al,BYTE PTR [rsp+0x6]
  226639:	e9 41 eb ff ff       	jmp    22517f <parseFormValue+0x83f>
    const buf = try readAllocBytes(allocator, in_stream, size);
  22663e:	c5 f8 10 84 24 80 00 	vmovups xmm0,XMMWORD PTR [rsp+0x80]
  226645:	00 00 
  226647:	c5 f8 29 84 24 b0 00 	vmovaps XMMWORD PTR [rsp+0xb0],xmm0
  22664e:	00 00 
    return FormValue{ .Ref = buf };
  226650:	c5 f8 11 44 24 1e    	vmovups XMMWORD PTR [rsp+0x1e],xmm0
  226656:	48 8b 84 24 c0 00 00 	mov    rax,QWORD PTR [rsp+0xc0]
  22665d:	00 
  22665e:	48 89 44 24 2e       	mov    QWORD PTR [rsp+0x2e],rax
  226663:	c6 44 24 08 06       	mov    BYTE PTR [rsp+0x8],0x6
  226668:	8b 44 24 71          	mov    eax,DWORD PTR [rsp+0x71]
  22666c:	89 04 24             	mov    DWORD PTR [rsp],eax
  22666f:	0f b7 44 24 75       	movzx  eax,WORD PTR [rsp+0x75]
  226674:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  226679:	8a 44 24 77          	mov    al,BYTE PTR [rsp+0x77]
  22667d:	88 44 24 06          	mov    BYTE PTR [rsp+0x6],al
  226681:	c5 f8 10 44 24 18    	vmovups xmm0,XMMWORD PTR [rsp+0x18]
  226687:	c5 f8 29 84 24 90 00 	vmovaps XMMWORD PTR [rsp+0x90],xmm0
  22668e:	00 00 
  226690:	c5 f8 10 44 24 26    	vmovups xmm0,XMMWORD PTR [rsp+0x26]
  226696:	c5 f8 11 84 24 9e 00 	vmovups XMMWORD PTR [rsp+0x9e],xmm0
  22669d:	00 00 
  22669f:	b1 06                	mov    cl,0x6
  2266a1:	31 c0                	xor    eax,eax
    return parseFormValueRefLen(allocator, in_stream, block_len);
  2266a3:	66 89 84 24 18 02 00 	mov    WORD PTR [rsp+0x218],ax
  2266aa:	00 
  2266ab:	c5 f8 28 84 24 90 00 	vmovaps xmm0,XMMWORD PTR [rsp+0x90]
  2266b2:	00 00 
  2266b4:	c5 f8 11 84 24 1a 02 	vmovups XMMWORD PTR [rsp+0x21a],xmm0
  2266bb:	00 00 
  2266bd:	c5 f8 10 84 24 9e 00 	vmovups xmm0,XMMWORD PTR [rsp+0x9e]
  2266c4:	00 00 
  2266c6:	c5 f8 11 84 24 28 02 	vmovups XMMWORD PTR [rsp+0x228],xmm0
  2266cd:	00 00 
  2266cf:	88 8c 24 38 02 00 00 	mov    BYTE PTR [rsp+0x238],cl
  2266d6:	8b 04 24             	mov    eax,DWORD PTR [rsp]
  2266d9:	89 84 24 39 02 00 00 	mov    DWORD PTR [rsp+0x239],eax
  2266e0:	0f b7 44 24 04       	movzx  eax,WORD PTR [rsp+0x4]
  2266e5:	66 89 84 24 3d 02 00 	mov    WORD PTR [rsp+0x23d],ax
  2266ec:	00 
  2266ed:	8a 44 24 06          	mov    al,BYTE PTR [rsp+0x6]
  2266f1:	e9 3e eb ff ff       	jmp    225234 <parseFormValue+0x8f4>
    const buf = try readAllocBytes(allocator, in_stream, size);
  2266f6:	c5 f8 10 84 24 80 00 	vmovups xmm0,XMMWORD PTR [rsp+0x80]
  2266fd:	00 00 
  2266ff:	c5 f8 29 84 24 b0 00 	vmovaps XMMWORD PTR [rsp+0xb0],xmm0
  226706:	00 00 
    return FormValue{ .Ref = buf };
  226708:	c5 f8 11 44 24 1e    	vmovups XMMWORD PTR [rsp+0x1e],xmm0
  22670e:	48 8b 84 24 c0 00 00 	mov    rax,QWORD PTR [rsp+0xc0]
  226715:	00 
  226716:	48 89 44 24 2e       	mov    QWORD PTR [rsp+0x2e],rax
  22671b:	c6 44 24 08 06       	mov    BYTE PTR [rsp+0x8],0x6
  226720:	8b 44 24 71          	mov    eax,DWORD PTR [rsp+0x71]
  226724:	89 04 24             	mov    DWORD PTR [rsp],eax
  226727:	0f b7 44 24 75       	movzx  eax,WORD PTR [rsp+0x75]
  22672c:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  226731:	8a 44 24 77          	mov    al,BYTE PTR [rsp+0x77]
  226735:	88 44 24 06          	mov    BYTE PTR [rsp+0x6],al
  226739:	c5 f8 10 44 24 18    	vmovups xmm0,XMMWORD PTR [rsp+0x18]
  22673f:	c5 f8 29 84 24 90 00 	vmovaps XMMWORD PTR [rsp+0x90],xmm0
  226746:	00 00 
  226748:	c5 f8 10 44 24 26    	vmovups xmm0,XMMWORD PTR [rsp+0x26]
  22674e:	c5 f8 11 84 24 9e 00 	vmovups XMMWORD PTR [rsp+0x9e],xmm0
  226755:	00 00 
  226757:	b1 06                	mov    cl,0x6
  226759:	31 c0                	xor    eax,eax
    return parseFormValueRefLen(allocator, in_stream, block_len);
  22675b:	66 89 84 24 f0 01 00 	mov    WORD PTR [rsp+0x1f0],ax
  226762:	00 
  226763:	c5 f8 28 84 24 90 00 	vmovaps xmm0,XMMWORD PTR [rsp+0x90]
  22676a:	00 00 
  22676c:	c5 f8 11 84 24 f2 01 	vmovups XMMWORD PTR [rsp+0x1f2],xmm0
  226773:	00 00 
  226775:	c5 f8 10 84 24 9e 00 	vmovups xmm0,XMMWORD PTR [rsp+0x9e]
  22677c:	00 00 
  22677e:	c5 f8 11 84 24 00 02 	vmovups XMMWORD PTR [rsp+0x200],xmm0
  226785:	00 00 
  226787:	88 8c 24 10 02 00 00 	mov    BYTE PTR [rsp+0x210],cl
  22678e:	8b 04 24             	mov    eax,DWORD PTR [rsp]
  226791:	89 84 24 11 02 00 00 	mov    DWORD PTR [rsp+0x211],eax
  226798:	0f b7 44 24 04       	movzx  eax,WORD PTR [rsp+0x4]
  22679d:	66 89 84 24 15 02 00 	mov    WORD PTR [rsp+0x215],ax
  2267a4:	00 
  2267a5:	8a 44 24 06          	mov    al,BYTE PTR [rsp+0x6]
  2267a9:	e9 3b eb ff ff       	jmp    2252e9 <parseFormValue+0x9a9>
    const buf = try readAllocBytes(allocator, in_stream, size);
  2267ae:	c5 f8 10 84 24 80 00 	vmovups xmm0,XMMWORD PTR [rsp+0x80]
  2267b5:	00 00 
  2267b7:	c5 f8 29 84 24 b0 00 	vmovaps XMMWORD PTR [rsp+0xb0],xmm0
  2267be:	00 00 
    return FormValue{ .Ref = buf };
  2267c0:	c5 f8 11 44 24 1e    	vmovups XMMWORD PTR [rsp+0x1e],xmm0
  2267c6:	48 8b 84 24 c0 00 00 	mov    rax,QWORD PTR [rsp+0xc0]
  2267cd:	00 
  2267ce:	48 89 44 24 2e       	mov    QWORD PTR [rsp+0x2e],rax
  2267d3:	c6 44 24 08 06       	mov    BYTE PTR [rsp+0x8],0x6
  2267d8:	8b 44 24 71          	mov    eax,DWORD PTR [rsp+0x71]
  2267dc:	89 04 24             	mov    DWORD PTR [rsp],eax
  2267df:	0f b7 44 24 75       	movzx  eax,WORD PTR [rsp+0x75]
  2267e4:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  2267e9:	8a 44 24 77          	mov    al,BYTE PTR [rsp+0x77]
  2267ed:	88 44 24 06          	mov    BYTE PTR [rsp+0x6],al
  2267f1:	c5 f8 10 44 24 18    	vmovups xmm0,XMMWORD PTR [rsp+0x18]
  2267f7:	c5 f8 29 84 24 90 00 	vmovaps XMMWORD PTR [rsp+0x90],xmm0
  2267fe:	00 00 
  226800:	c5 f8 10 44 24 26    	vmovups xmm0,XMMWORD PTR [rsp+0x26]
  226806:	c5 f8 11 84 24 9e 00 	vmovups XMMWORD PTR [rsp+0x9e],xmm0
  22680d:	00 00 
  22680f:	b1 06                	mov    cl,0x6
  226811:	31 c0                	xor    eax,eax
    return parseFormValueRefLen(allocator, in_stream, block_len);
  226813:	66 89 84 24 c8 01 00 	mov    WORD PTR [rsp+0x1c8],ax
  22681a:	00 
  22681b:	c5 f8 28 84 24 90 00 	vmovaps xmm0,XMMWORD PTR [rsp+0x90]
  226822:	00 00 
  226824:	c5 f8 11 84 24 ca 01 	vmovups XMMWORD PTR [rsp+0x1ca],xmm0
  22682b:	00 00 
  22682d:	c5 f8 10 84 24 9e 00 	vmovups xmm0,XMMWORD PTR [rsp+0x9e]
  226834:	00 00 
  226836:	c5 f8 11 84 24 d8 01 	vmovups XMMWORD PTR [rsp+0x1d8],xmm0
  22683d:	00 00 
  22683f:	88 8c 24 e8 01 00 00 	mov    BYTE PTR [rsp+0x1e8],cl
  226846:	8b 04 24             	mov    eax,DWORD PTR [rsp]
  226849:	89 84 24 e9 01 00 00 	mov    DWORD PTR [rsp+0x1e9],eax
  226850:	0f b7 44 24 04       	movzx  eax,WORD PTR [rsp+0x4]
  226855:	66 89 84 24 ed 01 00 	mov    WORD PTR [rsp+0x1ed],ax
  22685c:	00 
  22685d:	8a 44 24 06          	mov    al,BYTE PTR [rsp+0x6]
  226861:	e9 38 eb ff ff       	jmp    22539e <parseFormValue+0xa5e>
            const signed = form_id == DW.FORM_sdata;
  226866:	48 83 fb 0d          	cmp    rbx,0xd
    return FormValue{
  22686a:	0f 94 84 24 b0 00 00 	sete   BYTE PTR [rsp+0xb0]
  226871:	00 
  226872:	c6 44 24 60 02       	mov    BYTE PTR [rsp+0x60],0x2
  226877:	8b 44 24 78          	mov    eax,DWORD PTR [rsp+0x78]
  22687b:	89 84 24 18 01 00 00 	mov    DWORD PTR [rsp+0x118],eax
            const signed = form_id == DW.FORM_sdata;
  226882:	40 0f 94 c7          	sete   dil
    return FormValue{
  226886:	0f b7 44 24 7c       	movzx  eax,WORD PTR [rsp+0x7c]
  22688b:	66 89 84 24 1c 01 00 	mov    WORD PTR [rsp+0x11c],ax
  226892:	00 
        .Const = Constant{
  226893:	c5 f8 10 44 24 48    	vmovups xmm0,XMMWORD PTR [rsp+0x48]
    return FormValue{
  226899:	8b 84 24 90 00 00 00 	mov    eax,DWORD PTR [rsp+0x90]
  2268a0:	89 84 24 f0 00 00 00 	mov    DWORD PTR [rsp+0xf0],eax
  2268a7:	48 8d b4 24 18 01 00 	lea    rsi,[rsp+0x118]
  2268ae:	00 
  2268af:	0f b7 84 24 94 00 00 	movzx  eax,WORD PTR [rsp+0x94]
  2268b6:	00 
  2268b7:	66 89 84 24 f4 00 00 	mov    WORD PTR [rsp+0xf4],ax
  2268be:	00 
  2268bf:	48 8d 84 24 f0 00 00 	lea    rax,[rsp+0xf0]
  2268c6:	00 
  2268c7:	8a 8c 24 96 00 00 00 	mov    cl,BYTE PTR [rsp+0x96]
  2268ce:	88 8c 24 f6 00 00 00 	mov    BYTE PTR [rsp+0xf6],cl
  2268d5:	b3 02                	mov    bl,0x2
  2268d7:	8b 4c 24 18          	mov    ecx,DWORD PTR [rsp+0x18]
  2268db:	89 8c 24 e8 00 00 00 	mov    DWORD PTR [rsp+0xe8],ecx
  2268e2:	48 8d 8c 24 e8 00 00 	lea    rcx,[rsp+0xe8]
  2268e9:	00 
  2268ea:	0f b7 54 24 1c       	movzx  edx,WORD PTR [rsp+0x1c]
  2268ef:	66 89 94 24 ec 00 00 	mov    WORD PTR [rsp+0xec],dx
  2268f6:	00 
  2268f7:	8a 54 24 1e          	mov    dl,BYTE PTR [rsp+0x1e]
  2268fb:	88 94 24 ee 00 00 00 	mov    BYTE PTR [rsp+0xee],dl
  226902:	31 d2                	xor    edx,edx
            return parseFormValueConstant(allocator, in_stream, signed, block_len);
  226904:	66 89 55 00          	mov    WORD PTR [rbp+0x0],dx
  226908:	0f b7 56 04          	movzx  edx,WORD PTR [rsi+0x4]
  22690c:	66 89 55 06          	mov    WORD PTR [rbp+0x6],dx
  226910:	8b 16                	mov    edx,DWORD PTR [rsi]
  226912:	89 55 02             	mov    DWORD PTR [rbp+0x2],edx
  226915:	c5 f8 11 45 08       	vmovups XMMWORD PTR [rbp+0x8],xmm0
  22691a:	40 88 7d 18          	mov    BYTE PTR [rbp+0x18],dil
  22691e:	8a 50 06             	mov    dl,BYTE PTR [rax+0x6]
  226921:	88 55 1f             	mov    BYTE PTR [rbp+0x1f],dl
  226924:	0f b7 50 04          	movzx  edx,WORD PTR [rax+0x4]
  226928:	66 89 55 1d          	mov    WORD PTR [rbp+0x1d],dx
  22692c:	8b 00                	mov    eax,DWORD PTR [rax]
  22692e:	89 45 19             	mov    DWORD PTR [rbp+0x19],eax
  226931:	88 5d 20             	mov    BYTE PTR [rbp+0x20],bl
  226934:	0f b7 41 04          	movzx  eax,WORD PTR [rcx+0x4]
  226938:	66 89 45 25          	mov    WORD PTR [rbp+0x25],ax
  22693c:	8b 01                	mov    eax,DWORD PTR [rcx]
  22693e:	89 45 21             	mov    DWORD PTR [rbp+0x21],eax
  226941:	8a 41 06             	mov    al,BYTE PTR [rcx+0x6]
  226944:	88 45 27             	mov    BYTE PTR [rbp+0x27],al
  226947:	e9 0b fa ff ff       	jmp    226357 <parseFormValue+0x1a17>
            for (bytes) |b, index| {
  22694c:	48 89 c3             	mov    rbx,rax
  22694f:	48 83 e3 f0          	and    rbx,0xfffffffffffffff0
  226953:	48 8d 6b f0          	lea    rbp,[rbx-0x10]
  226957:	48 89 e9             	mov    rcx,rbp
  22695a:	48 c1 e9 04          	shr    rcx,0x4
  22695e:	8d 79 01             	lea    edi,[rcx+0x1]
  226961:	83 e7 01             	and    edi,0x1
  226964:	48 85 ed             	test   rbp,rbp
  226967:	0f 84 29 05 00 00    	je     226e96 <parseFormValue+0x2556>
  22696d:	48 8d 6f ff          	lea    rbp,[rdi-0x1]
  226971:	48 29 cd             	sub    rbp,rcx
  226974:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  226978:	c5 fd 6f 0d 20 98 fd 	vmovdqa ymm1,YMMWORD PTR [rip+0xfffffffffffd9820]        # 2001a0 <__unnamed_29-0x60>
  22697f:	ff 
  226980:	31 c9                	xor    ecx,ecx
  226982:	c4 e2 7d 59 2d fd a2 	vpbroadcastq ymm5,QWORD PTR [rip+0xfffffffffffda2fd]        # 200c88 <__unnamed_622+0x10>
  226989:	fd ff 
  22698b:	c4 e2 7d 59 35 6c a3 	vpbroadcastq ymm6,QWORD PTR [rip+0xfffffffffffda36c]        # 200d00 <__unnamed_621+0x48>
  226992:	fd ff 
  226994:	c4 e2 7d 59 3d 53 a3 	vpbroadcastq ymm7,QWORD PTR [rip+0xfffffffffffda353]        # 200cf0 <__unnamed_621+0x38>
  22699b:	fd ff 
  22699d:	c4 62 7d 59 05 82 a2 	vpbroadcastq ymm8,QWORD PTR [rip+0xfffffffffffda282]        # 200c28 <__unnamed_464+0x18>
  2269a4:	fd ff 
  2269a6:	c5 e1 ef db          	vpxor  xmm3,xmm3,xmm3
  2269aa:	c5 d9 ef e4          	vpxor  xmm4,xmm4,xmm4
  2269ae:	c5 e9 ef d2          	vpxor  xmm2,xmm2,xmm2
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  2269b2:	c4 62 7d 32 0c 0a    	vpmovzxbq ymm9,DWORD PTR [rdx+rcx*1]
  2269b8:	c4 62 7d 32 54 0a 04 	vpmovzxbq ymm10,DWORD PTR [rdx+rcx*1+0x4]
  2269bf:	c4 62 7d 32 5c 0a 08 	vpmovzxbq ymm11,DWORD PTR [rdx+rcx*1+0x8]
  2269c6:	c4 62 7d 32 64 0a 0c 	vpmovzxbq ymm12,DWORD PTR [rdx+rcx*1+0xc]
  2269cd:	c5 95 73 f1 03       	vpsllq ymm13,ymm1,0x3
  2269d2:	c5 15 d4 f5          	vpaddq ymm14,ymm13,ymm5
  2269d6:	c5 15 db fe          	vpand  ymm15,ymm13,ymm6
  2269da:	c5 0d db f6          	vpand  ymm14,ymm14,ymm6
  2269de:	c4 42 b5 47 cf       	vpsllvq ymm9,ymm9,ymm15
  2269e3:	c5 b5 eb c0          	vpor   ymm0,ymm9,ymm0
  2269e7:	c4 42 ad 47 ce       	vpsllvq ymm9,ymm10,ymm14
  2269ec:	c5 b5 eb db          	vpor   ymm3,ymm9,ymm3
  2269f0:	c4 42 a5 47 cf       	vpsllvq ymm9,ymm11,ymm15
  2269f5:	c5 b5 eb e4          	vpor   ymm4,ymm9,ymm4
  2269f9:	c4 42 9d 47 ce       	vpsllvq ymm9,ymm12,ymm14
  2269fe:	c4 62 7d 32 54 0a 10 	vpmovzxbq ymm10,DWORD PTR [rdx+rcx*1+0x10]
  226a05:	c4 62 7d 32 5c 0a 14 	vpmovzxbq ymm11,DWORD PTR [rdx+rcx*1+0x14]
  226a0c:	c4 62 7d 32 64 0a 18 	vpmovzxbq ymm12,DWORD PTR [rdx+rcx*1+0x18]
  226a13:	c4 62 7d 32 74 0a 1c 	vpmovzxbq ymm14,DWORD PTR [rdx+rcx*1+0x1c]
  226a1a:	c5 b5 eb d2          	vpor   ymm2,ymm9,ymm2
  226a1e:	c5 15 d4 cf          	vpaddq ymm9,ymm13,ymm7
  226a22:	c4 41 15 d4 e8       	vpaddq ymm13,ymm13,ymm8
  226a27:	c5 35 db ce          	vpand  ymm9,ymm9,ymm6
  226a2b:	c5 15 db ee          	vpand  ymm13,ymm13,ymm6
  226a2f:	c4 42 ad 47 d1       	vpsllvq ymm10,ymm10,ymm9
  226a34:	c5 ad eb c0          	vpor   ymm0,ymm10,ymm0
  226a38:	c4 42 a5 47 d5       	vpsllvq ymm10,ymm11,ymm13
  226a3d:	c5 ad eb db          	vpor   ymm3,ymm10,ymm3
  226a41:	c4 42 9d 47 c9       	vpsllvq ymm9,ymm12,ymm9
  226a46:	c5 b5 eb e4          	vpor   ymm4,ymm9,ymm4
  226a4a:	c4 42 8d 47 cd       	vpsllvq ymm9,ymm14,ymm13
  226a4f:	c5 b5 eb d2          	vpor   ymm2,ymm9,ymm2
            for (bytes) |b, index| {
  226a53:	48 83 c1 20          	add    rcx,0x20
  226a57:	c5 f5 d4 cd          	vpaddq ymm1,ymm1,ymm5
  226a5b:	48 83 c5 02          	add    rbp,0x2
  226a5f:	0f 85 4d ff ff ff    	jne    2269b2 <parseFormValue+0x2072>
  226a65:	e9 46 04 00 00       	jmp    226eb0 <parseFormValue+0x2570>
  226a6a:	48 89 c3             	mov    rbx,rax
  226a6d:	48 83 e3 f0          	and    rbx,0xfffffffffffffff0
  226a71:	48 8d 6b f0          	lea    rbp,[rbx-0x10]
  226a75:	48 89 e9             	mov    rcx,rbp
  226a78:	48 c1 e9 04          	shr    rcx,0x4
  226a7c:	8d 79 01             	lea    edi,[rcx+0x1]
  226a7f:	83 e7 01             	and    edi,0x1
  226a82:	48 85 ed             	test   rbp,rbp
  226a85:	0f 84 ec 05 00 00    	je     227077 <parseFormValue+0x2737>
  226a8b:	48 8d 6f ff          	lea    rbp,[rdi-0x1]
  226a8f:	48 29 cd             	sub    rbp,rcx
  226a92:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  226a96:	c5 fd 6f 0d 02 97 fd 	vmovdqa ymm1,YMMWORD PTR [rip+0xfffffffffffd9702]        # 2001a0 <__unnamed_29-0x60>
  226a9d:	ff 
  226a9e:	31 c9                	xor    ecx,ecx
  226aa0:	c4 e2 7d 59 2d df a1 	vpbroadcastq ymm5,QWORD PTR [rip+0xfffffffffffda1df]        # 200c88 <__unnamed_622+0x10>
  226aa7:	fd ff 
  226aa9:	c4 e2 7d 59 35 4e a2 	vpbroadcastq ymm6,QWORD PTR [rip+0xfffffffffffda24e]        # 200d00 <__unnamed_621+0x48>
  226ab0:	fd ff 
  226ab2:	c4 e2 7d 59 3d 35 a2 	vpbroadcastq ymm7,QWORD PTR [rip+0xfffffffffffda235]        # 200cf0 <__unnamed_621+0x38>
  226ab9:	fd ff 
  226abb:	c4 62 7d 59 05 64 a1 	vpbroadcastq ymm8,QWORD PTR [rip+0xfffffffffffda164]        # 200c28 <__unnamed_464+0x18>
  226ac2:	fd ff 
  226ac4:	c5 e1 ef db          	vpxor  xmm3,xmm3,xmm3
  226ac8:	c5 d9 ef e4          	vpxor  xmm4,xmm4,xmm4
  226acc:	c5 e9 ef d2          	vpxor  xmm2,xmm2,xmm2
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  226ad0:	c4 62 7d 32 0c 0a    	vpmovzxbq ymm9,DWORD PTR [rdx+rcx*1]
  226ad6:	c4 62 7d 32 54 0a 04 	vpmovzxbq ymm10,DWORD PTR [rdx+rcx*1+0x4]
  226add:	c4 62 7d 32 5c 0a 08 	vpmovzxbq ymm11,DWORD PTR [rdx+rcx*1+0x8]
  226ae4:	c4 62 7d 32 64 0a 0c 	vpmovzxbq ymm12,DWORD PTR [rdx+rcx*1+0xc]
  226aeb:	c5 95 73 f1 03       	vpsllq ymm13,ymm1,0x3
  226af0:	c5 15 d4 f5          	vpaddq ymm14,ymm13,ymm5
  226af4:	c5 15 db fe          	vpand  ymm15,ymm13,ymm6
  226af8:	c5 0d db f6          	vpand  ymm14,ymm14,ymm6
  226afc:	c4 42 b5 47 cf       	vpsllvq ymm9,ymm9,ymm15
  226b01:	c5 b5 eb c0          	vpor   ymm0,ymm9,ymm0
  226b05:	c4 42 ad 47 ce       	vpsllvq ymm9,ymm10,ymm14
  226b0a:	c5 b5 eb db          	vpor   ymm3,ymm9,ymm3
  226b0e:	c4 42 a5 47 cf       	vpsllvq ymm9,ymm11,ymm15
  226b13:	c5 b5 eb e4          	vpor   ymm4,ymm9,ymm4
  226b17:	c4 42 9d 47 ce       	vpsllvq ymm9,ymm12,ymm14
  226b1c:	c4 62 7d 32 54 0a 10 	vpmovzxbq ymm10,DWORD PTR [rdx+rcx*1+0x10]
  226b23:	c4 62 7d 32 5c 0a 14 	vpmovzxbq ymm11,DWORD PTR [rdx+rcx*1+0x14]
  226b2a:	c4 62 7d 32 64 0a 18 	vpmovzxbq ymm12,DWORD PTR [rdx+rcx*1+0x18]
  226b31:	c4 62 7d 32 74 0a 1c 	vpmovzxbq ymm14,DWORD PTR [rdx+rcx*1+0x1c]
  226b38:	c5 b5 eb d2          	vpor   ymm2,ymm9,ymm2
  226b3c:	c5 15 d4 cf          	vpaddq ymm9,ymm13,ymm7
  226b40:	c4 41 15 d4 e8       	vpaddq ymm13,ymm13,ymm8
  226b45:	c5 35 db ce          	vpand  ymm9,ymm9,ymm6
  226b49:	c5 15 db ee          	vpand  ymm13,ymm13,ymm6
  226b4d:	c4 42 ad 47 d1       	vpsllvq ymm10,ymm10,ymm9
  226b52:	c5 ad eb c0          	vpor   ymm0,ymm10,ymm0
  226b56:	c4 42 a5 47 d5       	vpsllvq ymm10,ymm11,ymm13
  226b5b:	c5 ad eb db          	vpor   ymm3,ymm10,ymm3
  226b5f:	c4 42 9d 47 c9       	vpsllvq ymm9,ymm12,ymm9
  226b64:	c5 b5 eb e4          	vpor   ymm4,ymm9,ymm4
  226b68:	c4 42 8d 47 cd       	vpsllvq ymm9,ymm14,ymm13
  226b6d:	c5 b5 eb d2          	vpor   ymm2,ymm9,ymm2
            for (bytes) |b, index| {
  226b71:	48 83 c1 20          	add    rcx,0x20
  226b75:	c5 f5 d4 cd          	vpaddq ymm1,ymm1,ymm5
  226b79:	48 83 c5 02          	add    rbp,0x2
  226b7d:	0f 85 4d ff ff ff    	jne    226ad0 <parseFormValue+0x2190>
  226b83:	e9 09 05 00 00       	jmp    227091 <parseFormValue+0x2751>
  226b88:	48 89 c3             	mov    rbx,rax
  226b8b:	48 83 e3 f0          	and    rbx,0xfffffffffffffff0
  226b8f:	48 8d 6b f0          	lea    rbp,[rbx-0x10]
  226b93:	48 89 e9             	mov    rcx,rbp
  226b96:	48 c1 e9 04          	shr    rcx,0x4
  226b9a:	8d 79 01             	lea    edi,[rcx+0x1]
  226b9d:	83 e7 01             	and    edi,0x1
  226ba0:	48 85 ed             	test   rbp,rbp
  226ba3:	0f 84 af 06 00 00    	je     227258 <parseFormValue+0x2918>
  226ba9:	48 8d 6f ff          	lea    rbp,[rdi-0x1]
  226bad:	48 29 cd             	sub    rbp,rcx
  226bb0:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  226bb4:	c5 fd 6f 0d e4 95 fd 	vmovdqa ymm1,YMMWORD PTR [rip+0xfffffffffffd95e4]        # 2001a0 <__unnamed_29-0x60>
  226bbb:	ff 
  226bbc:	31 c9                	xor    ecx,ecx
  226bbe:	c4 e2 7d 59 2d c1 a0 	vpbroadcastq ymm5,QWORD PTR [rip+0xfffffffffffda0c1]        # 200c88 <__unnamed_622+0x10>
  226bc5:	fd ff 
  226bc7:	c4 e2 7d 59 35 30 a1 	vpbroadcastq ymm6,QWORD PTR [rip+0xfffffffffffda130]        # 200d00 <__unnamed_621+0x48>
  226bce:	fd ff 
  226bd0:	c4 e2 7d 59 3d 17 a1 	vpbroadcastq ymm7,QWORD PTR [rip+0xfffffffffffda117]        # 200cf0 <__unnamed_621+0x38>
  226bd7:	fd ff 
  226bd9:	c4 62 7d 59 05 46 a0 	vpbroadcastq ymm8,QWORD PTR [rip+0xfffffffffffda046]        # 200c28 <__unnamed_464+0x18>
  226be0:	fd ff 
  226be2:	c5 e1 ef db          	vpxor  xmm3,xmm3,xmm3
  226be6:	c5 d9 ef e4          	vpxor  xmm4,xmm4,xmm4
  226bea:	c5 e9 ef d2          	vpxor  xmm2,xmm2,xmm2
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  226bee:	c4 62 7d 32 0c 0a    	vpmovzxbq ymm9,DWORD PTR [rdx+rcx*1]
  226bf4:	c4 62 7d 32 54 0a 04 	vpmovzxbq ymm10,DWORD PTR [rdx+rcx*1+0x4]
  226bfb:	c4 62 7d 32 5c 0a 08 	vpmovzxbq ymm11,DWORD PTR [rdx+rcx*1+0x8]
  226c02:	c4 62 7d 32 64 0a 0c 	vpmovzxbq ymm12,DWORD PTR [rdx+rcx*1+0xc]
  226c09:	c5 95 73 f1 03       	vpsllq ymm13,ymm1,0x3
  226c0e:	c5 15 d4 f5          	vpaddq ymm14,ymm13,ymm5
  226c12:	c5 15 db fe          	vpand  ymm15,ymm13,ymm6
  226c16:	c5 0d db f6          	vpand  ymm14,ymm14,ymm6
  226c1a:	c4 42 b5 47 cf       	vpsllvq ymm9,ymm9,ymm15
  226c1f:	c5 b5 eb c0          	vpor   ymm0,ymm9,ymm0
  226c23:	c4 42 ad 47 ce       	vpsllvq ymm9,ymm10,ymm14
  226c28:	c5 b5 eb db          	vpor   ymm3,ymm9,ymm3
  226c2c:	c4 42 a5 47 cf       	vpsllvq ymm9,ymm11,ymm15
  226c31:	c5 b5 eb e4          	vpor   ymm4,ymm9,ymm4
  226c35:	c4 42 9d 47 ce       	vpsllvq ymm9,ymm12,ymm14
  226c3a:	c4 62 7d 32 54 0a 10 	vpmovzxbq ymm10,DWORD PTR [rdx+rcx*1+0x10]
  226c41:	c4 62 7d 32 5c 0a 14 	vpmovzxbq ymm11,DWORD PTR [rdx+rcx*1+0x14]
  226c48:	c4 62 7d 32 64 0a 18 	vpmovzxbq ymm12,DWORD PTR [rdx+rcx*1+0x18]
  226c4f:	c4 62 7d 32 74 0a 1c 	vpmovzxbq ymm14,DWORD PTR [rdx+rcx*1+0x1c]
  226c56:	c5 b5 eb d2          	vpor   ymm2,ymm9,ymm2
  226c5a:	c5 15 d4 cf          	vpaddq ymm9,ymm13,ymm7
  226c5e:	c4 41 15 d4 e8       	vpaddq ymm13,ymm13,ymm8
  226c63:	c5 35 db ce          	vpand  ymm9,ymm9,ymm6
  226c67:	c5 15 db ee          	vpand  ymm13,ymm13,ymm6
  226c6b:	c4 42 ad 47 d1       	vpsllvq ymm10,ymm10,ymm9
  226c70:	c5 ad eb c0          	vpor   ymm0,ymm10,ymm0
  226c74:	c4 42 a5 47 d5       	vpsllvq ymm10,ymm11,ymm13
  226c79:	c5 ad eb db          	vpor   ymm3,ymm10,ymm3
  226c7d:	c4 42 9d 47 c9       	vpsllvq ymm9,ymm12,ymm9
  226c82:	c5 b5 eb e4          	vpor   ymm4,ymm9,ymm4
  226c86:	c4 42 8d 47 cd       	vpsllvq ymm9,ymm14,ymm13
  226c8b:	c5 b5 eb d2          	vpor   ymm2,ymm9,ymm2
            for (bytes) |b, index| {
  226c8f:	48 83 c1 20          	add    rcx,0x20
  226c93:	c5 f5 d4 cd          	vpaddq ymm1,ymm1,ymm5
  226c97:	48 83 c5 02          	add    rbp,0x2
  226c9b:	0f 85 4d ff ff ff    	jne    226bee <parseFormValue+0x22ae>
  226ca1:	e9 cc 05 00 00       	jmp    227272 <parseFormValue+0x2932>
    return FormValue{ .Block = buf };
  226ca6:	c6 84 24 b0 00 00 00 	mov    BYTE PTR [rsp+0xb0],0x1
  226cad:	01 
  226cae:	8b 44 24 78          	mov    eax,DWORD PTR [rsp+0x78]
  226cb2:	89 84 24 20 01 00 00 	mov    DWORD PTR [rsp+0x120],eax
  226cb9:	0f b7 44 24 7c       	movzx  eax,WORD PTR [rsp+0x7c]
  226cbe:	66 89 84 24 24 01 00 	mov    WORD PTR [rsp+0x124],ax
  226cc5:	00 
    const buf = try readAllocBytes(allocator, in_stream, size);
  226cc6:	c5 f8 10 44 24 48    	vmovups xmm0,XMMWORD PTR [rsp+0x48]
    return FormValue{ .Block = buf };
  226ccc:	8b 44 24 18          	mov    eax,DWORD PTR [rsp+0x18]
  226cd0:	89 84 24 00 01 00 00 	mov    DWORD PTR [rsp+0x100],eax
  226cd7:	48 8d b4 24 20 01 00 	lea    rsi,[rsp+0x120]
  226cde:	00 
  226cdf:	0f b7 44 24 1c       	movzx  eax,WORD PTR [rsp+0x1c]
  226ce4:	66 89 84 24 04 01 00 	mov    WORD PTR [rsp+0x104],ax
  226ceb:	00 
  226cec:	48 8d 84 24 00 01 00 	lea    rax,[rsp+0x100]
  226cf3:	00 
  226cf4:	8a 4c 24 1e          	mov    cl,BYTE PTR [rsp+0x1e]
  226cf8:	88 8c 24 06 01 00 00 	mov    BYTE PTR [rsp+0x106],cl
  226cff:	b3 01                	mov    bl,0x1
  226d01:	8b 8c 24 90 00 00 00 	mov    ecx,DWORD PTR [rsp+0x90]
  226d08:	89 8c 24 f8 00 00 00 	mov    DWORD PTR [rsp+0xf8],ecx
  226d0f:	48 8d 94 24 f8 00 00 	lea    rdx,[rsp+0xf8]
  226d16:	00 
  226d17:	0f b7 8c 24 94 00 00 	movzx  ecx,WORD PTR [rsp+0x94]
  226d1e:	00 
  226d1f:	66 89 8c 24 fc 00 00 	mov    WORD PTR [rsp+0xfc],cx
  226d26:	00 
  226d27:	8a 8c 24 96 00 00 00 	mov    cl,BYTE PTR [rsp+0x96]
  226d2e:	88 8c 24 fe 00 00 00 	mov    BYTE PTR [rsp+0xfe],cl
  226d35:	e9 8f 00 00 00       	jmp    226dc9 <parseFormValue+0x2489>
    return FormValue{ .Ref = buf };
  226d3a:	c6 84 24 b0 00 00 00 	mov    BYTE PTR [rsp+0xb0],0x6
  226d41:	06 
  226d42:	8b 44 24 78          	mov    eax,DWORD PTR [rsp+0x78]
  226d46:	89 84 24 10 01 00 00 	mov    DWORD PTR [rsp+0x110],eax
  226d4d:	0f b7 44 24 7c       	movzx  eax,WORD PTR [rsp+0x7c]
  226d52:	66 89 84 24 14 01 00 	mov    WORD PTR [rsp+0x114],ax
  226d59:	00 
    const buf = try readAllocBytes(allocator, in_stream, size);
  226d5a:	c5 f8 10 44 24 48    	vmovups xmm0,XMMWORD PTR [rsp+0x48]
    return FormValue{ .Ref = buf };
  226d60:	8b 44 24 18          	mov    eax,DWORD PTR [rsp+0x18]
  226d64:	89 84 24 e0 00 00 00 	mov    DWORD PTR [rsp+0xe0],eax
  226d6b:	48 8d b4 24 10 01 00 	lea    rsi,[rsp+0x110]
  226d72:	00 
  226d73:	0f b7 44 24 1c       	movzx  eax,WORD PTR [rsp+0x1c]
  226d78:	66 89 84 24 e4 00 00 	mov    WORD PTR [rsp+0xe4],ax
  226d7f:	00 
  226d80:	48 8d 84 24 e0 00 00 	lea    rax,[rsp+0xe0]
  226d87:	00 
  226d88:	8a 4c 24 1e          	mov    cl,BYTE PTR [rsp+0x1e]
  226d8c:	88 8c 24 e6 00 00 00 	mov    BYTE PTR [rsp+0xe6],cl
  226d93:	b3 06                	mov    bl,0x6
  226d95:	8b 8c 24 90 00 00 00 	mov    ecx,DWORD PTR [rsp+0x90]
  226d9c:	89 8c 24 d8 00 00 00 	mov    DWORD PTR [rsp+0xd8],ecx
  226da3:	48 8d 94 24 d8 00 00 	lea    rdx,[rsp+0xd8]
  226daa:	00 
  226dab:	0f b7 8c 24 94 00 00 	movzx  ecx,WORD PTR [rsp+0x94]
  226db2:	00 
  226db3:	66 89 8c 24 dc 00 00 	mov    WORD PTR [rsp+0xdc],cx
  226dba:	00 
  226dbb:	8a 8c 24 96 00 00 00 	mov    cl,BYTE PTR [rsp+0x96]
  226dc2:	88 8c 24 de 00 00 00 	mov    BYTE PTR [rsp+0xde],cl
  226dc9:	31 c9                	xor    ecx,ecx
  226dcb:	66 89 0f             	mov    WORD PTR [rdi],cx
  226dce:	0f b7 4e 04          	movzx  ecx,WORD PTR [rsi+0x4]
  226dd2:	66 89 4f 06          	mov    WORD PTR [rdi+0x6],cx
  226dd6:	8b 0e                	mov    ecx,DWORD PTR [rsi]
  226dd8:	89 4f 02             	mov    DWORD PTR [rdi+0x2],ecx
  226ddb:	c5 f8 11 47 08       	vmovups XMMWORD PTR [rdi+0x8],xmm0
  226de0:	8a 48 06             	mov    cl,BYTE PTR [rax+0x6]
  226de3:	88 4f 1f             	mov    BYTE PTR [rdi+0x1f],cl
  226de6:	0f b7 48 04          	movzx  ecx,WORD PTR [rax+0x4]
  226dea:	66 89 4f 1d          	mov    WORD PTR [rdi+0x1d],cx
  226dee:	8b 00                	mov    eax,DWORD PTR [rax]
  226df0:	89 47 19             	mov    DWORD PTR [rdi+0x19],eax
  226df3:	88 5f 20             	mov    BYTE PTR [rdi+0x20],bl
  226df6:	0f b7 42 04          	movzx  eax,WORD PTR [rdx+0x4]
  226dfa:	66 89 47 25          	mov    WORD PTR [rdi+0x25],ax
  226dfe:	8b 02                	mov    eax,DWORD PTR [rdx]
  226e00:	89 47 21             	mov    DWORD PTR [rdi+0x21],eax
  226e03:	8a 42 06             	mov    al,BYTE PTR [rdx+0x6]
  226e06:	88 47 27             	mov    BYTE PTR [rdi+0x27],al
  226e09:	e9 49 f5 ff ff       	jmp    226357 <parseFormValue+0x1a17>
            const buf = try readAllocBytes(allocator, in_stream, size);
  226e0e:	c5 f8 10 84 24 58 04 	vmovups xmm0,XMMWORD PTR [rsp+0x458]
  226e15:	00 00 
  226e17:	c5 f8 29 84 24 80 04 	vmovaps XMMWORD PTR [rsp+0x480],xmm0
  226e1e:	00 00 
            return FormValue{ .ExprLoc = buf };
  226e20:	c5 f8 11 84 24 38 04 	vmovups XMMWORD PTR [rsp+0x438],xmm0
  226e27:	00 00 
  226e29:	48 8b 84 24 90 04 00 	mov    rax,QWORD PTR [rsp+0x490]
  226e30:	00 
  226e31:	48 89 84 24 48 04 00 	mov    QWORD PTR [rsp+0x448],rax
  226e38:	00 
  226e39:	c6 84 24 ae 00 00 00 	mov    BYTE PTR [rsp+0xae],0x3
  226e40:	03 
  226e41:	48 8b 4c 24 68       	mov    rcx,QWORD PTR [rsp+0x68]
  226e46:	66 c7 01 00 00       	mov    WORD PTR [rcx],0x0
  226e4b:	c5 f8 10 84 24 32 04 	vmovups xmm0,XMMWORD PTR [rsp+0x432]
  226e52:	00 00 
  226e54:	c5 fa 6f 8c 24 40 04 	vmovdqu xmm1,XMMWORD PTR [rsp+0x440]
  226e5b:	00 00 
  226e5d:	c5 fa 7f 49 10       	vmovdqu XMMWORD PTR [rcx+0x10],xmm1
  226e62:	c5 f8 11 41 02       	vmovups XMMWORD PTR [rcx+0x2],xmm0
  226e67:	8a 84 24 ae 00 00 00 	mov    al,BYTE PTR [rsp+0xae]
  226e6e:	88 41 20             	mov    BYTE PTR [rcx+0x20],al
  226e71:	8a 84 24 10 03 00 00 	mov    al,BYTE PTR [rsp+0x310]
  226e78:	88 41 27             	mov    BYTE PTR [rcx+0x27],al
  226e7b:	0f b7 84 24 0e 03 00 	movzx  eax,WORD PTR [rsp+0x30e]
  226e82:	00 
  226e83:	66 89 41 25          	mov    WORD PTR [rcx+0x25],ax
  226e87:	8b 84 24 0a 03 00 00 	mov    eax,DWORD PTR [rsp+0x30a]
  226e8e:	89 41 21             	mov    DWORD PTR [rcx+0x21],eax
  226e91:	e9 c1 f4 ff ff       	jmp    226357 <parseFormValue+0x1a17>
  226e96:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  226e9a:	c5 fd 6f 0d fe 92 fd 	vmovdqa ymm1,YMMWORD PTR [rip+0xfffffffffffd92fe]        # 2001a0 <__unnamed_29-0x60>
  226ea1:	ff 
  226ea2:	31 c9                	xor    ecx,ecx
  226ea4:	c5 e1 ef db          	vpxor  xmm3,xmm3,xmm3
  226ea8:	c5 d9 ef e4          	vpxor  xmm4,xmm4,xmm4
  226eac:	c5 e9 ef d2          	vpxor  xmm2,xmm2,xmm2
  226eb0:	48 85 ff             	test   rdi,rdi
  226eb3:	74 62                	je     226f17 <parseFormValue+0x25d7>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  226eb5:	c4 e2 7d 32 6c 0a 0c 	vpmovzxbq ymm5,DWORD PTR [rdx+rcx*1+0xc]
  226ebc:	c5 f5 73 f1 03       	vpsllq ymm1,ymm1,0x3
  226ec1:	c4 e2 7d 59 35 be 9d 	vpbroadcastq ymm6,QWORD PTR [rip+0xfffffffffffd9dbe]        # 200c88 <__unnamed_622+0x10>
  226ec8:	fd ff 
  226eca:	c5 f5 d4 f6          	vpaddq ymm6,ymm1,ymm6
  226ece:	c4 e2 7d 59 3d 29 9e 	vpbroadcastq ymm7,QWORD PTR [rip+0xfffffffffffd9e29]        # 200d00 <__unnamed_621+0x48>
  226ed5:	fd ff 
  226ed7:	c5 cd db f7          	vpand  ymm6,ymm6,ymm7
  226edb:	c4 e2 d5 47 ee       	vpsllvq ymm5,ymm5,ymm6
  226ee0:	c4 62 7d 32 44 0a 08 	vpmovzxbq ymm8,DWORD PTR [rdx+rcx*1+0x8]
  226ee7:	c5 d5 eb d2          	vpor   ymm2,ymm5,ymm2
  226eeb:	c5 f5 db cf          	vpand  ymm1,ymm1,ymm7
  226eef:	c4 e2 bd 47 e9       	vpsllvq ymm5,ymm8,ymm1
  226ef4:	c5 d5 eb e4          	vpor   ymm4,ymm5,ymm4
  226ef8:	c4 e2 7d 32 6c 0a 04 	vpmovzxbq ymm5,DWORD PTR [rdx+rcx*1+0x4]
  226eff:	c4 e2 d5 47 ee       	vpsllvq ymm5,ymm5,ymm6
  226f04:	c5 d5 eb db          	vpor   ymm3,ymm5,ymm3
  226f08:	c4 e2 7d 32 2c 0a    	vpmovzxbq ymm5,DWORD PTR [rdx+rcx*1]
  226f0e:	c4 e2 d5 47 c9       	vpsllvq ymm1,ymm5,ymm1
  226f13:	c5 f5 eb c0          	vpor   ymm0,ymm1,ymm0
  226f17:	c5 e5 eb ca          	vpor   ymm1,ymm3,ymm2
  226f1b:	c5 fd eb c4          	vpor   ymm0,ymm0,ymm4
  226f1f:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  226f23:	c4 e3 7d 39 c1 01    	vextracti128 xmm1,ymm0,0x1
  226f29:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  226f2d:	c5 f9 70 c8 4e       	vpshufd xmm1,xmm0,0x4e
  226f32:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  226f36:	c4 e1 f9 7e c1       	vmovq  rcx,xmm0
  226f3b:	48 39 d8             	cmp    rax,rbx
            for (bytes) |b, index| {
  226f3e:	74 29                	je     226f69 <parseFormValue+0x2629>
  226f40:	48 29 d8             	sub    rax,rbx
  226f43:	48 01 da             	add    rdx,rbx
  226f46:	48 c1 e3 03          	shl    rbx,0x3
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  226f4a:	0f b6 3a             	movzx  edi,BYTE PTR [rdx]
  226f4d:	89 de                	mov    esi,ebx
  226f4f:	40 80 e6 38          	and    sil,0x38
  226f53:	c4 e2 c9 f7 f7       	shlx   rsi,rdi,rsi
  226f58:	48 09 f1             	or     rcx,rsi
            for (bytes) |b, index| {
  226f5b:	48 83 c3 08          	add    rbx,0x8
  226f5f:	48 83 c2 01          	add    rdx,0x1
  226f63:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  226f67:	75 e1                	jne    226f4a <parseFormValue+0x260a>
  226f69:	48 8d 7c 24 78       	lea    rdi,[rsp+0x78]
    const buf = try readAllocBytes(allocator, in_stream, size);
  226f6e:	4c 89 fe             	mov    rsi,r15
  226f71:	4c 89 e2             	mov    rdx,r12
  226f74:	c5 f8 77             	vzeroupper 
  226f77:	e8 64 07 00 00       	call   2276e0 <readAllocBytes>
  226f7c:	0f b7 44 24 78       	movzx  eax,WORD PTR [rsp+0x78]
  226f81:	66 85 c0             	test   ax,ax
  226f84:	74 39                	je     226fbf <parseFormValue+0x267f>
  226f86:	c5 f8 10 44 24 40    	vmovups xmm0,XMMWORD PTR [rsp+0x40]
  226f8c:	c5 fa 6f 4c 24 4e    	vmovdqu xmm1,XMMWORD PTR [rsp+0x4e]
  226f92:	c5 fa 7f 8c 24 9e 00 	vmovdqu XMMWORD PTR [rsp+0x9e],xmm1
  226f99:	00 00 
  226f9b:	c5 f8 29 84 24 90 00 	vmovaps XMMWORD PTR [rsp+0x90],xmm0
  226fa2:	00 00 
  226fa4:	8b 4c 24 60          	mov    ecx,DWORD PTR [rsp+0x60]
  226fa8:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  226fab:	0f b7 4c 24 64       	movzx  ecx,WORD PTR [rsp+0x64]
  226fb0:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  226fb5:	8a 4c 24 66          	mov    cl,BYTE PTR [rsp+0x66]
  226fb9:	88 4c 24 06          	mov    BYTE PTR [rsp+0x6],cl
  226fbd:	eb 65                	jmp    227024 <parseFormValue+0x26e4>
  226fbf:	c5 f8 10 84 24 80 00 	vmovups xmm0,XMMWORD PTR [rsp+0x80]
  226fc6:	00 00 
  226fc8:	c5 f8 29 84 24 b0 00 	vmovaps XMMWORD PTR [rsp+0xb0],xmm0
  226fcf:	00 00 
    return FormValue{ .Block = buf };
  226fd1:	c5 f8 11 44 24 1e    	vmovups XMMWORD PTR [rsp+0x1e],xmm0
  226fd7:	48 8b 84 24 c0 00 00 	mov    rax,QWORD PTR [rsp+0xc0]
  226fde:	00 
  226fdf:	48 89 44 24 2e       	mov    QWORD PTR [rsp+0x2e],rax
  226fe4:	c6 44 24 08 01       	mov    BYTE PTR [rsp+0x8],0x1
  226fe9:	8b 44 24 71          	mov    eax,DWORD PTR [rsp+0x71]
  226fed:	89 04 24             	mov    DWORD PTR [rsp],eax
  226ff0:	0f b7 44 24 75       	movzx  eax,WORD PTR [rsp+0x75]
  226ff5:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  226ffa:	8a 44 24 77          	mov    al,BYTE PTR [rsp+0x77]
  226ffe:	88 44 24 06          	mov    BYTE PTR [rsp+0x6],al
  227002:	c5 f8 10 44 24 18    	vmovups xmm0,XMMWORD PTR [rsp+0x18]
  227008:	c5 f8 29 84 24 90 00 	vmovaps XMMWORD PTR [rsp+0x90],xmm0
  22700f:	00 00 
  227011:	c5 f8 10 44 24 26    	vmovups xmm0,XMMWORD PTR [rsp+0x26]
  227017:	c5 f8 11 84 24 9e 00 	vmovups XMMWORD PTR [rsp+0x9e],xmm0
  22701e:	00 00 
  227020:	b1 01                	mov    cl,0x1
  227022:	31 c0                	xor    eax,eax
    return parseFormValueBlockLen(allocator, in_stream, block_len);
  227024:	66 89 84 24 90 02 00 	mov    WORD PTR [rsp+0x290],ax
  22702b:	00 
  22702c:	c5 f8 28 84 24 90 00 	vmovaps xmm0,XMMWORD PTR [rsp+0x90]
  227033:	00 00 
  227035:	c5 f8 11 84 24 92 02 	vmovups XMMWORD PTR [rsp+0x292],xmm0
  22703c:	00 00 
  22703e:	c5 f8 10 84 24 9e 00 	vmovups xmm0,XMMWORD PTR [rsp+0x9e]
  227045:	00 00 
  227047:	c5 f8 11 84 24 a0 02 	vmovups XMMWORD PTR [rsp+0x2a0],xmm0
  22704e:	00 00 
  227050:	88 8c 24 b0 02 00 00 	mov    BYTE PTR [rsp+0x2b0],cl
  227057:	8b 04 24             	mov    eax,DWORD PTR [rsp]
  22705a:	89 84 24 b1 02 00 00 	mov    DWORD PTR [rsp+0x2b1],eax
  227061:	0f b7 44 24 04       	movzx  eax,WORD PTR [rsp+0x4]
  227066:	66 89 84 24 b5 02 00 	mov    WORD PTR [rsp+0x2b5],ax
  22706d:	00 
  22706e:	8a 44 24 06          	mov    al,BYTE PTR [rsp+0x6]
  227072:	e9 78 da ff ff       	jmp    224aef <parseFormValue+0x1af>
  227077:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  22707b:	c5 fd 6f 0d 1d 91 fd 	vmovdqa ymm1,YMMWORD PTR [rip+0xfffffffffffd911d]        # 2001a0 <__unnamed_29-0x60>
  227082:	ff 
  227083:	31 c9                	xor    ecx,ecx
  227085:	c5 e1 ef db          	vpxor  xmm3,xmm3,xmm3
  227089:	c5 d9 ef e4          	vpxor  xmm4,xmm4,xmm4
  22708d:	c5 e9 ef d2          	vpxor  xmm2,xmm2,xmm2
  227091:	48 85 ff             	test   rdi,rdi
  227094:	74 62                	je     2270f8 <parseFormValue+0x27b8>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  227096:	c4 e2 7d 32 6c 0a 0c 	vpmovzxbq ymm5,DWORD PTR [rdx+rcx*1+0xc]
  22709d:	c5 f5 73 f1 03       	vpsllq ymm1,ymm1,0x3
  2270a2:	c4 e2 7d 59 35 dd 9b 	vpbroadcastq ymm6,QWORD PTR [rip+0xfffffffffffd9bdd]        # 200c88 <__unnamed_622+0x10>
  2270a9:	fd ff 
  2270ab:	c5 f5 d4 f6          	vpaddq ymm6,ymm1,ymm6
  2270af:	c4 e2 7d 59 3d 48 9c 	vpbroadcastq ymm7,QWORD PTR [rip+0xfffffffffffd9c48]        # 200d00 <__unnamed_621+0x48>
  2270b6:	fd ff 
  2270b8:	c5 cd db f7          	vpand  ymm6,ymm6,ymm7
  2270bc:	c4 e2 d5 47 ee       	vpsllvq ymm5,ymm5,ymm6
  2270c1:	c4 62 7d 32 44 0a 08 	vpmovzxbq ymm8,DWORD PTR [rdx+rcx*1+0x8]
  2270c8:	c5 d5 eb d2          	vpor   ymm2,ymm5,ymm2
  2270cc:	c5 f5 db cf          	vpand  ymm1,ymm1,ymm7
  2270d0:	c4 e2 bd 47 e9       	vpsllvq ymm5,ymm8,ymm1
  2270d5:	c5 d5 eb e4          	vpor   ymm4,ymm5,ymm4
  2270d9:	c4 e2 7d 32 6c 0a 04 	vpmovzxbq ymm5,DWORD PTR [rdx+rcx*1+0x4]
  2270e0:	c4 e2 d5 47 ee       	vpsllvq ymm5,ymm5,ymm6
  2270e5:	c5 d5 eb db          	vpor   ymm3,ymm5,ymm3
  2270e9:	c4 e2 7d 32 2c 0a    	vpmovzxbq ymm5,DWORD PTR [rdx+rcx*1]
  2270ef:	c4 e2 d5 47 c9       	vpsllvq ymm1,ymm5,ymm1
  2270f4:	c5 f5 eb c0          	vpor   ymm0,ymm1,ymm0
  2270f8:	c5 e5 eb ca          	vpor   ymm1,ymm3,ymm2
  2270fc:	c5 fd eb c4          	vpor   ymm0,ymm0,ymm4
  227100:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  227104:	c4 e3 7d 39 c1 01    	vextracti128 xmm1,ymm0,0x1
  22710a:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  22710e:	c5 f9 70 c8 4e       	vpshufd xmm1,xmm0,0x4e
  227113:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  227117:	c4 e1 f9 7e c1       	vmovq  rcx,xmm0
  22711c:	48 39 d8             	cmp    rax,rbx
            for (bytes) |b, index| {
  22711f:	74 29                	je     22714a <parseFormValue+0x280a>
  227121:	48 29 d8             	sub    rax,rbx
  227124:	48 01 da             	add    rdx,rbx
  227127:	48 c1 e3 03          	shl    rbx,0x3
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  22712b:	0f b6 3a             	movzx  edi,BYTE PTR [rdx]
  22712e:	89 de                	mov    esi,ebx
  227130:	40 80 e6 38          	and    sil,0x38
  227134:	c4 e2 c9 f7 f7       	shlx   rsi,rdi,rsi
  227139:	48 09 f1             	or     rcx,rsi
            for (bytes) |b, index| {
  22713c:	48 83 c3 08          	add    rbx,0x8
  227140:	48 83 c2 01          	add    rdx,0x1
  227144:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  227148:	75 e1                	jne    22712b <parseFormValue+0x27eb>
  22714a:	48 8d 7c 24 78       	lea    rdi,[rsp+0x78]
    const buf = try readAllocBytes(allocator, in_stream, size);
  22714f:	4c 89 fe             	mov    rsi,r15
  227152:	4c 89 e2             	mov    rdx,r12
  227155:	c5 f8 77             	vzeroupper 
  227158:	e8 83 05 00 00       	call   2276e0 <readAllocBytes>
  22715d:	0f b7 44 24 78       	movzx  eax,WORD PTR [rsp+0x78]
  227162:	66 85 c0             	test   ax,ax
  227165:	74 39                	je     2271a0 <parseFormValue+0x2860>
  227167:	c5 f8 10 44 24 40    	vmovups xmm0,XMMWORD PTR [rsp+0x40]
  22716d:	c5 fa 6f 4c 24 4e    	vmovdqu xmm1,XMMWORD PTR [rsp+0x4e]
  227173:	c5 fa 7f 8c 24 9e 00 	vmovdqu XMMWORD PTR [rsp+0x9e],xmm1
  22717a:	00 00 
  22717c:	c5 f8 29 84 24 90 00 	vmovaps XMMWORD PTR [rsp+0x90],xmm0
  227183:	00 00 
  227185:	8b 4c 24 60          	mov    ecx,DWORD PTR [rsp+0x60]
  227189:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  22718c:	0f b7 4c 24 64       	movzx  ecx,WORD PTR [rsp+0x64]
  227191:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  227196:	8a 4c 24 66          	mov    cl,BYTE PTR [rsp+0x66]
  22719a:	88 4c 24 06          	mov    BYTE PTR [rsp+0x6],cl
  22719e:	eb 65                	jmp    227205 <parseFormValue+0x28c5>
  2271a0:	c5 f8 10 84 24 80 00 	vmovups xmm0,XMMWORD PTR [rsp+0x80]
  2271a7:	00 00 
  2271a9:	c5 f8 29 84 24 b0 00 	vmovaps XMMWORD PTR [rsp+0xb0],xmm0
  2271b0:	00 00 
    return FormValue{ .Block = buf };
  2271b2:	c5 f8 11 44 24 1e    	vmovups XMMWORD PTR [rsp+0x1e],xmm0
  2271b8:	48 8b 84 24 c0 00 00 	mov    rax,QWORD PTR [rsp+0xc0]
  2271bf:	00 
  2271c0:	48 89 44 24 2e       	mov    QWORD PTR [rsp+0x2e],rax
  2271c5:	c6 44 24 08 01       	mov    BYTE PTR [rsp+0x8],0x1
  2271ca:	8b 44 24 71          	mov    eax,DWORD PTR [rsp+0x71]
  2271ce:	89 04 24             	mov    DWORD PTR [rsp],eax
  2271d1:	0f b7 44 24 75       	movzx  eax,WORD PTR [rsp+0x75]
  2271d6:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  2271db:	8a 44 24 77          	mov    al,BYTE PTR [rsp+0x77]
  2271df:	88 44 24 06          	mov    BYTE PTR [rsp+0x6],al
  2271e3:	c5 f8 10 44 24 18    	vmovups xmm0,XMMWORD PTR [rsp+0x18]
  2271e9:	c5 f8 29 84 24 90 00 	vmovaps XMMWORD PTR [rsp+0x90],xmm0
  2271f0:	00 00 
  2271f2:	c5 f8 10 44 24 26    	vmovups xmm0,XMMWORD PTR [rsp+0x26]
  2271f8:	c5 f8 11 84 24 9e 00 	vmovups XMMWORD PTR [rsp+0x9e],xmm0
  2271ff:	00 00 
  227201:	b1 01                	mov    cl,0x1
  227203:	31 c0                	xor    eax,eax
    return parseFormValueBlockLen(allocator, in_stream, block_len);
  227205:	66 89 84 24 68 02 00 	mov    WORD PTR [rsp+0x268],ax
  22720c:	00 
  22720d:	c5 f8 28 84 24 90 00 	vmovaps xmm0,XMMWORD PTR [rsp+0x90]
  227214:	00 00 
  227216:	c5 f8 11 84 24 6a 02 	vmovups XMMWORD PTR [rsp+0x26a],xmm0
  22721d:	00 00 
  22721f:	c5 f8 10 84 24 9e 00 	vmovups xmm0,XMMWORD PTR [rsp+0x9e]
  227226:	00 00 
  227228:	c5 f8 11 84 24 78 02 	vmovups XMMWORD PTR [rsp+0x278],xmm0
  22722f:	00 00 
  227231:	88 8c 24 88 02 00 00 	mov    BYTE PTR [rsp+0x288],cl
  227238:	8b 04 24             	mov    eax,DWORD PTR [rsp]
  22723b:	89 84 24 89 02 00 00 	mov    DWORD PTR [rsp+0x289],eax
  227242:	0f b7 44 24 04       	movzx  eax,WORD PTR [rsp+0x4]
  227247:	66 89 84 24 8d 02 00 	mov    WORD PTR [rsp+0x28d],ax
  22724e:	00 
  22724f:	8a 44 24 06          	mov    al,BYTE PTR [rsp+0x6]
  227253:	e9 4c d9 ff ff       	jmp    224ba4 <parseFormValue+0x264>
  227258:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  22725c:	c5 fd 6f 0d 3c 8f fd 	vmovdqa ymm1,YMMWORD PTR [rip+0xfffffffffffd8f3c]        # 2001a0 <__unnamed_29-0x60>
  227263:	ff 
  227264:	31 c9                	xor    ecx,ecx
  227266:	c5 e1 ef db          	vpxor  xmm3,xmm3,xmm3
  22726a:	c5 d9 ef e4          	vpxor  xmm4,xmm4,xmm4
  22726e:	c5 e9 ef d2          	vpxor  xmm2,xmm2,xmm2
  227272:	48 85 ff             	test   rdi,rdi
  227275:	74 62                	je     2272d9 <parseFormValue+0x2999>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  227277:	c4 e2 7d 32 6c 0a 0c 	vpmovzxbq ymm5,DWORD PTR [rdx+rcx*1+0xc]
  22727e:	c5 f5 73 f1 03       	vpsllq ymm1,ymm1,0x3
  227283:	c4 e2 7d 59 35 fc 99 	vpbroadcastq ymm6,QWORD PTR [rip+0xfffffffffffd99fc]        # 200c88 <__unnamed_622+0x10>
  22728a:	fd ff 
  22728c:	c5 f5 d4 f6          	vpaddq ymm6,ymm1,ymm6
  227290:	c4 e2 7d 59 3d 67 9a 	vpbroadcastq ymm7,QWORD PTR [rip+0xfffffffffffd9a67]        # 200d00 <__unnamed_621+0x48>
  227297:	fd ff 
  227299:	c5 cd db f7          	vpand  ymm6,ymm6,ymm7
  22729d:	c4 e2 d5 47 ee       	vpsllvq ymm5,ymm5,ymm6
  2272a2:	c4 62 7d 32 44 0a 08 	vpmovzxbq ymm8,DWORD PTR [rdx+rcx*1+0x8]
  2272a9:	c5 d5 eb d2          	vpor   ymm2,ymm5,ymm2
  2272ad:	c5 f5 db cf          	vpand  ymm1,ymm1,ymm7
  2272b1:	c4 e2 bd 47 e9       	vpsllvq ymm5,ymm8,ymm1
  2272b6:	c5 d5 eb e4          	vpor   ymm4,ymm5,ymm4
  2272ba:	c4 e2 7d 32 6c 0a 04 	vpmovzxbq ymm5,DWORD PTR [rdx+rcx*1+0x4]
  2272c1:	c4 e2 d5 47 ee       	vpsllvq ymm5,ymm5,ymm6
  2272c6:	c5 d5 eb db          	vpor   ymm3,ymm5,ymm3
  2272ca:	c4 e2 7d 32 2c 0a    	vpmovzxbq ymm5,DWORD PTR [rdx+rcx*1]
  2272d0:	c4 e2 d5 47 c9       	vpsllvq ymm1,ymm5,ymm1
  2272d5:	c5 f5 eb c0          	vpor   ymm0,ymm1,ymm0
  2272d9:	c5 e5 eb ca          	vpor   ymm1,ymm3,ymm2
  2272dd:	c5 fd eb c4          	vpor   ymm0,ymm0,ymm4
  2272e1:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  2272e5:	c4 e3 7d 39 c1 01    	vextracti128 xmm1,ymm0,0x1
  2272eb:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  2272ef:	c5 f9 70 c8 4e       	vpshufd xmm1,xmm0,0x4e
  2272f4:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  2272f8:	c4 e1 f9 7e c1       	vmovq  rcx,xmm0
  2272fd:	48 39 d8             	cmp    rax,rbx
            for (bytes) |b, index| {
  227300:	74 29                	je     22732b <parseFormValue+0x29eb>
  227302:	48 29 d8             	sub    rax,rbx
  227305:	48 01 da             	add    rdx,rbx
  227308:	48 c1 e3 03          	shl    rbx,0x3
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  22730c:	0f b6 3a             	movzx  edi,BYTE PTR [rdx]
  22730f:	89 de                	mov    esi,ebx
  227311:	40 80 e6 38          	and    sil,0x38
  227315:	c4 e2 c9 f7 f7       	shlx   rsi,rdi,rsi
  22731a:	48 09 f1             	or     rcx,rsi
            for (bytes) |b, index| {
  22731d:	48 83 c3 08          	add    rbx,0x8
  227321:	48 83 c2 01          	add    rdx,0x1
  227325:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  227329:	75 e1                	jne    22730c <parseFormValue+0x29cc>
  22732b:	48 8d 7c 24 78       	lea    rdi,[rsp+0x78]
    const buf = try readAllocBytes(allocator, in_stream, size);
  227330:	4c 89 fe             	mov    rsi,r15
  227333:	4c 89 e2             	mov    rdx,r12
  227336:	c5 f8 77             	vzeroupper 
  227339:	e8 a2 03 00 00       	call   2276e0 <readAllocBytes>
  22733e:	0f b7 44 24 78       	movzx  eax,WORD PTR [rsp+0x78]
  227343:	66 85 c0             	test   ax,ax
  227346:	74 39                	je     227381 <parseFormValue+0x2a41>
  227348:	c5 f8 10 44 24 40    	vmovups xmm0,XMMWORD PTR [rsp+0x40]
  22734e:	c5 fa 6f 4c 24 4e    	vmovdqu xmm1,XMMWORD PTR [rsp+0x4e]
  227354:	c5 fa 7f 8c 24 9e 00 	vmovdqu XMMWORD PTR [rsp+0x9e],xmm1
  22735b:	00 00 
  22735d:	c5 f8 29 84 24 90 00 	vmovaps XMMWORD PTR [rsp+0x90],xmm0
  227364:	00 00 
  227366:	8b 4c 24 60          	mov    ecx,DWORD PTR [rsp+0x60]
  22736a:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  22736d:	0f b7 4c 24 64       	movzx  ecx,WORD PTR [rsp+0x64]
  227372:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  227377:	8a 4c 24 66          	mov    cl,BYTE PTR [rsp+0x66]
  22737b:	88 4c 24 06          	mov    BYTE PTR [rsp+0x6],cl
  22737f:	eb 65                	jmp    2273e6 <parseFormValue+0x2aa6>
  227381:	c5 f8 10 84 24 80 00 	vmovups xmm0,XMMWORD PTR [rsp+0x80]
  227388:	00 00 
  22738a:	c5 f8 29 84 24 b0 00 	vmovaps XMMWORD PTR [rsp+0xb0],xmm0
  227391:	00 00 
    return FormValue{ .Block = buf };
  227393:	c5 f8 11 44 24 1e    	vmovups XMMWORD PTR [rsp+0x1e],xmm0
  227399:	48 8b 84 24 c0 00 00 	mov    rax,QWORD PTR [rsp+0xc0]
  2273a0:	00 
  2273a1:	48 89 44 24 2e       	mov    QWORD PTR [rsp+0x2e],rax
  2273a6:	c6 44 24 08 01       	mov    BYTE PTR [rsp+0x8],0x1
  2273ab:	8b 44 24 71          	mov    eax,DWORD PTR [rsp+0x71]
  2273af:	89 04 24             	mov    DWORD PTR [rsp],eax
  2273b2:	0f b7 44 24 75       	movzx  eax,WORD PTR [rsp+0x75]
  2273b7:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  2273bc:	8a 44 24 77          	mov    al,BYTE PTR [rsp+0x77]
  2273c0:	88 44 24 06          	mov    BYTE PTR [rsp+0x6],al
  2273c4:	c5 f8 10 44 24 18    	vmovups xmm0,XMMWORD PTR [rsp+0x18]
  2273ca:	c5 f8 29 84 24 90 00 	vmovaps XMMWORD PTR [rsp+0x90],xmm0
  2273d1:	00 00 
  2273d3:	c5 f8 10 44 24 26    	vmovups xmm0,XMMWORD PTR [rsp+0x26]
  2273d9:	c5 f8 11 84 24 9e 00 	vmovups XMMWORD PTR [rsp+0x9e],xmm0
  2273e0:	00 00 
  2273e2:	b1 01                	mov    cl,0x1
  2273e4:	31 c0                	xor    eax,eax
    return parseFormValueBlockLen(allocator, in_stream, block_len);
  2273e6:	66 89 84 24 b8 02 00 	mov    WORD PTR [rsp+0x2b8],ax
  2273ed:	00 
  2273ee:	c5 f8 28 84 24 90 00 	vmovaps xmm0,XMMWORD PTR [rsp+0x90]
  2273f5:	00 00 
  2273f7:	c5 f8 11 84 24 ba 02 	vmovups XMMWORD PTR [rsp+0x2ba],xmm0
  2273fe:	00 00 
  227400:	c5 f8 10 84 24 9e 00 	vmovups xmm0,XMMWORD PTR [rsp+0x9e]
  227407:	00 00 
  227409:	c5 f8 11 84 24 c8 02 	vmovups XMMWORD PTR [rsp+0x2c8],xmm0
  227410:	00 00 
  227412:	88 8c 24 d8 02 00 00 	mov    BYTE PTR [rsp+0x2d8],cl
  227419:	8b 04 24             	mov    eax,DWORD PTR [rsp]
  22741c:	89 84 24 d9 02 00 00 	mov    DWORD PTR [rsp+0x2d9],eax
  227423:	0f b7 44 24 04       	movzx  eax,WORD PTR [rsp+0x4]
  227428:	66 89 84 24 dd 02 00 	mov    WORD PTR [rsp+0x2dd],ax
  22742f:	00 
  227430:	8a 44 24 06          	mov    al,BYTE PTR [rsp+0x6]
  227434:	e9 d5 da ff ff       	jmp    224f0e <parseFormValue+0x5ce>
  227439:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

0000000000227440 <Allocator_alignedRealloc.158>:
    pub fn alignedRealloc(self: *Allocator, comptime T: type, comptime alignment: u29, old_mem: []align(alignment) T, n: usize) ![]align(alignment) T {
  227440:	41 56                	push   r14
  227442:	53                   	push   rbx
  227443:	48 81 ec 88 00 00 00 	sub    rsp,0x88
  22744a:	48 89 fb             	mov    rbx,rdi
        if (old_mem.len == 0) {
  22744d:	48 8b 42 08          	mov    rax,QWORD PTR [rdx+0x8]
  227451:	48 85 c0             	test   rax,rax
  227454:	74 62                	je     2274b8 <Allocator_alignedRealloc.158+0x78>
        if (n == 0) {
  227456:	48 85 c9             	test   rcx,rcx
  227459:	0f 84 a9 00 00 00    	je     227508 <Allocator_alignedRealloc.158+0xc8>
        const old_byte_slice = @sliceToBytes(old_mem);
  22745f:	48 8b 12             	mov    rdx,QWORD PTR [rdx]
  227462:	48 c1 e0 03          	shl    rax,0x3
  227466:	48 8d 04 80          	lea    rax,[rax+rax*4]
  22746a:	48 89 54 24 38       	mov    QWORD PTR [rsp+0x38],rdx
  22746f:	48 89 44 24 40       	mov    QWORD PTR [rsp+0x40],rax
  227474:	ba 28 00 00 00       	mov    edx,0x28
  227479:	48 89 c8             	mov    rax,rcx
  22747c:	48 f7 e2             	mul    rdx
  22747f:	0f 81 d0 00 00 00    	jno    227555 <Allocator_alignedRealloc.158+0x115>
  227485:	48 8d 0d 34 90 fd ff 	lea    rcx,[rip+0xfffffffffffd9034]        # 2004c0 <__unnamed_27>
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  22748c:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  227490:	0f 84 da 00 00 00    	je     227570 <Allocator_alignedRealloc.158+0x130>
  227496:	48 8b 05 93 0e fe ff 	mov    rax,QWORD PTR [rip+0xfffffffffffe0e93]        # 208330 <__unnamed_64+0x10>
  22749d:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  2274a1:	c5 f8 10 05 77 0e fe 	vmovups xmm0,XMMWORD PTR [rip+0xfffffffffffe0e77]        # 208320 <__unnamed_64>
  2274a8:	ff 
  2274a9:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  2274ad:	48 81 c4 88 00 00 00 	add    rsp,0x88
  2274b4:	5b                   	pop    rbx
  2274b5:	41 5e                	pop    r14
  2274b7:	c3                   	ret    
        if (n == 0) {
  2274b8:	48 85 c9             	test   rcx,rcx
  2274bb:	0f 84 fc 00 00 00    	je     2275bd <Allocator_alignedRealloc.158+0x17d>
  2274c1:	ba 28 00 00 00       	mov    edx,0x28
  2274c6:	48 89 c8             	mov    rax,rcx
  2274c9:	48 f7 e2             	mul    rdx
  2274cc:	0f 81 0c 01 00 00    	jno    2275de <Allocator_alignedRealloc.158+0x19e>
  2274d2:	48 8d 0d e7 8f fd ff 	lea    rcx,[rip+0xfffffffffffd8fe7]        # 2004c0 <__unnamed_27>
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  2274d9:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  2274dd:	0f 84 16 01 00 00    	je     2275f9 <Allocator_alignedRealloc.158+0x1b9>
  2274e3:	0f b7 05 3c 0e fe ff 	movzx  eax,WORD PTR [rip+0xfffffffffffe0e3c]        # 208326 <__unnamed_64+0x6>
  2274ea:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  2274ef:	8b 05 2d 0e fe ff    	mov    eax,DWORD PTR [rip+0xfffffffffffe0e2d]        # 208322 <__unnamed_64+0x2>
  2274f5:	89 04 24             	mov    DWORD PTR [rsp],eax
  2274f8:	48 89 e0             	mov    rax,rsp
  2274fb:	66 b9 01 00          	mov    cx,0x1
  2274ff:	31 f6                	xor    esi,esi
  227501:	31 d2                	xor    edx,edx
  227503:	e9 9d 01 00 00       	jmp    2276a5 <Allocator_alignedRealloc.158+0x265>
        const bytes = @sliceToBytes(memory);
  227508:	48 c1 e0 03          	shl    rax,0x3
  22750c:	48 8d 04 80          	lea    rax,[rax+rax*4]
        if (bytes.len == 0) return;
  227510:	48 85 c0             	test   rax,rax
  227513:	74 1e                	je     227533 <Allocator_alignedRealloc.158+0xf3>
        const bytes = @sliceToBytes(memory);
  227515:	48 8b 0a             	mov    rcx,QWORD PTR [rdx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  227518:	48 8b 56 10          	mov    rdx,QWORD PTR [rsi+0x10]
  22751c:	48 89 4c 24 08       	mov    QWORD PTR [rsp+0x8],rcx
  227521:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  227526:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  22752b:	48 89 f7             	mov    rdi,rsi
  22752e:	48 89 c6             	mov    rsi,rax
  227531:	ff d2                	call   rdx
            return ([*]align(alignment) T)(undefined)[0..0];
  227533:	48 8b 05 de 0d fe ff 	mov    rax,QWORD PTR [rip+0xfffffffffffe0dde]        # 208318 <__unnamed_65+0x10>
  22753a:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  22753e:	c5 f8 10 05 c2 0d fe 	vmovups xmm0,XMMWORD PTR [rip+0xfffffffffffe0dc2]        # 208308 <__unnamed_65>
  227545:	ff 
  227546:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  22754a:	48 81 c4 88 00 00 00 	add    rsp,0x88
  227551:	5b                   	pop    rbx
  227552:	41 5e                	pop    r14
  227554:	c3                   	ret    
  227555:	48 8d 4c 24 08       	lea    rcx,[rsp+0x8]
  22755a:	66 c7 44 24 08 00 00 	mov    WORD PTR [rsp+0x8],0x0
  227561:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  227566:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  22756a:	0f 85 26 ff ff ff    	jne    227496 <Allocator_alignedRealloc.158+0x56>
  227570:	4c 8b 71 08          	mov    r14,QWORD PTR [rcx+0x8]
  227574:	48 8d 7c 24 58       	lea    rdi,[rsp+0x58]
  227579:	48 8d 54 24 38       	lea    rdx,[rsp+0x38]
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  22757e:	41 b8 08 00 00 00    	mov    r8d,0x8
  227584:	4c 89 f1             	mov    rcx,r14
  227587:	ff 56 08             	call   QWORD PTR [rsi+0x8]
  22758a:	0f b7 44 24 58       	movzx  eax,WORD PTR [rsp+0x58]
  22758f:	66 85 c0             	test   ax,ax
  227592:	0f 84 94 00 00 00    	je     22762c <Allocator_alignedRealloc.158+0x1ec>
  227598:	66 89 03             	mov    WORD PTR [rbx],ax
  22759b:	48 8b 84 24 80 00 00 	mov    rax,QWORD PTR [rsp+0x80]
  2275a2:	00 
  2275a3:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  2275a7:	c5 f8 10 44 24 72    	vmovups xmm0,XMMWORD PTR [rsp+0x72]
  2275ad:	c5 f8 11 43 02       	vmovups XMMWORD PTR [rbx+0x2],xmm0
  2275b2:	48 81 c4 88 00 00 00 	add    rsp,0x88
  2275b9:	5b                   	pop    rbx
  2275ba:	41 5e                	pop    r14
  2275bc:	c3                   	ret    
  2275bd:	48 89 e0             	mov    rax,rsp
            return ([*]align(alignment) T)(undefined)[0..0];
  2275c0:	0f b7 0d 47 0d fe ff 	movzx  ecx,WORD PTR [rip+0xfffffffffffe0d47]        # 20830e <__unnamed_65+0x6>
  2275c7:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  2275cc:	8b 0d 38 0d fe ff    	mov    ecx,DWORD PTR [rip+0xfffffffffffe0d38]        # 20830a <__unnamed_65+0x2>
  2275d2:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  2275d5:	31 c9                	xor    ecx,ecx
  2275d7:	31 d2                	xor    edx,edx
  2275d9:	e9 c7 00 00 00       	jmp    2276a5 <Allocator_alignedRealloc.158+0x265>
  2275de:	48 8d 4c 24 48       	lea    rcx,[rsp+0x48]
  2275e3:	66 c7 44 24 48 00 00 	mov    WORD PTR [rsp+0x48],0x0
  2275ea:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  2275ef:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  2275f3:	0f 85 ea fe ff ff    	jne    2274e3 <Allocator_alignedRealloc.158+0xa3>
  2275f9:	4c 8b 71 08          	mov    r14,QWORD PTR [rcx+0x8]
  2275fd:	48 8d 7c 24 08       	lea    rdi,[rsp+0x8]
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  227602:	b9 08 00 00 00       	mov    ecx,0x8
  227607:	4c 89 f2             	mov    rdx,r14
  22760a:	ff 16                	call   QWORD PTR [rsi]
  22760c:	0f b7 4c 24 08       	movzx  ecx,WORD PTR [rsp+0x8]
  227611:	66 85 c9             	test   cx,cx
  227614:	74 57                	je     22766d <Allocator_alignedRealloc.158+0x22d>
  227616:	0f b7 44 24 36       	movzx  eax,WORD PTR [rsp+0x36]
  22761b:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  227620:	48 89 e0             	mov    rax,rsp
  227623:	8b 54 24 32          	mov    edx,DWORD PTR [rsp+0x32]
  227627:	89 14 24             	mov    DWORD PTR [rsp],edx
  22762a:	eb 79                	jmp    2276a5 <Allocator_alignedRealloc.158+0x265>
        assert(byte_slice.len == byte_count);
  22762c:	4c 39 74 24 68       	cmp    QWORD PTR [rsp+0x68],r14
    if (!ok) {
  227631:	0f 85 91 00 00 00    	jne    2276c8 <Allocator_alignedRealloc.158+0x288>
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  227637:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  22763c:	48 b9 cd cc cc cc cc 	movabs rcx,0xcccccccccccccccd
  227643:	cc cc cc 
  227646:	4c 89 f2             	mov    rdx,r14
  227649:	c4 e2 f3 f6 d1       	mulx   rdx,rcx,rcx
  22764e:	66 c7 03 00 00       	mov    WORD PTR [rbx],0x0
  227653:	0f b7 4c 24 2a       	movzx  ecx,WORD PTR [rsp+0x2a]
  227658:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  22765c:	48 c1 ea 05          	shr    rdx,0x5
  227660:	8b 4c 24 26          	mov    ecx,DWORD PTR [rsp+0x26]
  227664:	89 4b 02             	mov    DWORD PTR [rbx+0x2],ecx
  227667:	48 89 43 08          	mov    QWORD PTR [rbx+0x8],rax
  22766b:	eb 4c                	jmp    2276b9 <Allocator_alignedRealloc.158+0x279>
        assert(byte_slice.len == byte_count);
  22766d:	4c 39 74 24 18       	cmp    QWORD PTR [rsp+0x18],r14
  227672:	75 54                	jne    2276c8 <Allocator_alignedRealloc.158+0x288>
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  227674:	48 8b 74 24 10       	mov    rsi,QWORD PTR [rsp+0x10]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  227679:	48 b8 cd cc cc cc cc 	movabs rax,0xcccccccccccccccd
  227680:	cc cc cc 
  227683:	4c 89 f2             	mov    rdx,r14
  227686:	c4 e2 fb f6 d0       	mulx   rdx,rax,rax
  22768b:	48 c1 ea 05          	shr    rdx,0x5
  22768f:	48 89 e0             	mov    rax,rsp
  227692:	8b 4c 24 2c          	mov    ecx,DWORD PTR [rsp+0x2c]
  227696:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  227699:	0f b7 4c 24 30       	movzx  ecx,WORD PTR [rsp+0x30]
  22769e:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  2276a3:	31 c9                	xor    ecx,ecx
            return self.alignedAlloc(T, alignment, n);
  2276a5:	66 89 0b             	mov    WORD PTR [rbx],cx
  2276a8:	0f b7 48 04          	movzx  ecx,WORD PTR [rax+0x4]
  2276ac:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  2276b0:	8b 00                	mov    eax,DWORD PTR [rax]
  2276b2:	89 43 02             	mov    DWORD PTR [rbx+0x2],eax
  2276b5:	48 89 73 08          	mov    QWORD PTR [rbx+0x8],rsi
  2276b9:	48 89 53 10          	mov    QWORD PTR [rbx+0x10],rdx
  2276bd:	48 81 c4 88 00 00 00 	add    rsp,0x88
  2276c4:	5b                   	pop    rbx
  2276c5:	41 5e                	pop    r14
  2276c7:	c3                   	ret    
            @panic("assertion failure");
  2276c8:	48 8d 3d c1 86 02 00 	lea    rdi,[rip+0x286c1]        # 24fd90 <__unnamed_2>
  2276cf:	e8 4c b0 fe ff       	call   212720 <panic>
  2276d4:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  2276db:	00 00 00 00 00 

00000000002276e0 <readAllocBytes>:
fn readAllocBytes(allocator: *mem.Allocator, in_stream: var, size: usize) ![]u8 {
  2276e0:	55                   	push   rbp
  2276e1:	41 57                	push   r15
  2276e3:	41 56                	push   r14
  2276e5:	41 54                	push   r12
  2276e7:	53                   	push   rbx
  2276e8:	48 83 ec 70          	sub    rsp,0x70
  2276ec:	48 89 cb             	mov    rbx,rcx
  2276ef:	49 89 d4             	mov    r12,rdx
  2276f2:	49 89 f6             	mov    r14,rsi
  2276f5:	49 89 ff             	mov    r15,rdi
        if (n == 0) {
  2276f8:	48 85 db             	test   rbx,rbx
  2276fb:	74 32                	je     22772f <readAllocBytes+0x4f>
  2276fd:	48 89 e7             	mov    rdi,rsp
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  227700:	b9 01 00 00 00       	mov    ecx,0x1
  227705:	4c 89 f6             	mov    rsi,r14
  227708:	48 89 da             	mov    rdx,rbx
  22770b:	41 ff 16             	call   QWORD PTR [r14]
  22770e:	0f b7 04 24          	movzx  eax,WORD PTR [rsp]
  227712:	66 85 c0             	test   ax,ax
  227715:	74 1c                	je     227733 <readAllocBytes+0x53>
    const buf = try allocator.alloc(u8, size);
  227717:	66 41 89 07          	mov    WORD PTR [r15],ax
  22771b:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  227720:	49 89 47 10          	mov    QWORD PTR [r15+0x10],rax
  227724:	c5 f8 10 44 24 5a    	vmovups xmm0,XMMWORD PTR [rsp+0x5a]
  22772a:	e9 d8 00 00 00       	jmp    227807 <readAllocBytes+0x127>
  22772f:	31 c0                	xor    eax,eax
  227731:	eb 13                	jmp    227746 <readAllocBytes+0x66>
        assert(byte_slice.len == byte_count);
  227733:	48 39 5c 24 10       	cmp    QWORD PTR [rsp+0x10],rbx
    if (!ok) {
  227738:	0f 85 dc 00 00 00    	jne    22781a <readAllocBytes+0x13a>
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  22773e:	48 8b 4c 24 08       	mov    rcx,QWORD PTR [rsp+0x8]
  227743:	48 89 d8             	mov    rax,rbx
    const buf = try allocator.alloc(u8, size);
  227746:	48 89 4c 24 18       	mov    QWORD PTR [rsp+0x18],rcx
  22774b:	48 89 44 24 20       	mov    QWORD PTR [rsp+0x20],rax
  227750:	48 89 e7             	mov    rdi,rsp
  227753:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  227758:	4c 89 e6             	mov    rsi,r12
  22775b:	41 ff 14 24          	call   QWORD PTR [r12]
  22775f:	0f b7 2c 24          	movzx  ebp,WORD PTR [rsp]
    if ((try in_stream.read(buf)) < size) return error.EndOfFile;
  227763:	66 85 ed             	test   bp,bp
  227766:	74 39                	je     2277a1 <readAllocBytes+0xc1>
        const bytes = @sliceToBytes(memory);
  227768:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
        if (bytes.len == 0) return;
  22776d:	48 85 c0             	test   rax,rax
  227770:	74 1a                	je     22778c <readAllocBytes+0xac>
        const bytes = @sliceToBytes(memory);
  227772:	48 8b 4c 24 18       	mov    rcx,QWORD PTR [rsp+0x18]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  227777:	49 8b 56 10          	mov    rdx,QWORD PTR [r14+0x10]
  22777b:	48 89 0c 24          	mov    QWORD PTR [rsp],rcx
  22777f:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  227784:	48 89 e6             	mov    rsi,rsp
  227787:	4c 89 f7             	mov    rdi,r14
  22778a:	ff d2                	call   rdx
  22778c:	66 41 89 2f          	mov    WORD PTR [r15],bp
  227790:	48 8b 44 24 52       	mov    rax,QWORD PTR [rsp+0x52]
  227795:	49 89 47 10          	mov    QWORD PTR [r15+0x10],rax
  227799:	c5 f8 10 44 24 44    	vmovups xmm0,XMMWORD PTR [rsp+0x44]
  22779f:	eb 66                	jmp    227807 <readAllocBytes+0x127>
  2277a1:	48 39 5c 24 08       	cmp    QWORD PTR [rsp+0x8],rbx
  2277a6:	73 3e                	jae    2277e6 <readAllocBytes+0x106>
        const bytes = @sliceToBytes(memory);
  2277a8:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
        if (bytes.len == 0) return;
  2277ad:	48 85 c0             	test   rax,rax
  2277b0:	74 1a                	je     2277cc <readAllocBytes+0xec>
        const bytes = @sliceToBytes(memory);
  2277b2:	48 8b 4c 24 18       	mov    rcx,QWORD PTR [rsp+0x18]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  2277b7:	49 8b 56 10          	mov    rdx,QWORD PTR [r14+0x10]
  2277bb:	48 89 0c 24          	mov    QWORD PTR [rsp],rcx
  2277bf:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  2277c4:	48 89 e6             	mov    rsi,rsp
  2277c7:	4c 89 f7             	mov    rdi,r14
  2277ca:	ff d2                	call   rdx
  2277cc:	48 8b 05 dd 0e fe ff 	mov    rax,QWORD PTR [rip+0xfffffffffffe0edd]        # 2086b0 <__unnamed_66+0x10>
  2277d3:	49 89 47 10          	mov    QWORD PTR [r15+0x10],rax
  2277d7:	c5 f8 10 05 c1 0e fe 	vmovups xmm0,XMMWORD PTR [rip+0xfffffffffffe0ec1]        # 2086a0 <__unnamed_66>
  2277de:	ff 
  2277df:	c4 c1 78 11 07       	vmovups XMMWORD PTR [r15],xmm0
  2277e4:	eb 27                	jmp    22780d <readAllocBytes+0x12d>
    return buf;
  2277e6:	c5 f8 10 44 24 18    	vmovups xmm0,XMMWORD PTR [rsp+0x18]
  2277ec:	c5 f8 11 44 24 34    	vmovups XMMWORD PTR [rsp+0x34],xmm0
  2277f2:	66 41 c7 07 00 00    	mov    WORD PTR [r15],0x0
  2277f8:	48 8b 44 24 3c       	mov    rax,QWORD PTR [rsp+0x3c]
  2277fd:	49 89 47 10          	mov    QWORD PTR [r15+0x10],rax
  227801:	c5 f8 10 44 24 2e    	vmovups xmm0,XMMWORD PTR [rsp+0x2e]
  227807:	c4 c1 78 11 47 02    	vmovups XMMWORD PTR [r15+0x2],xmm0
  22780d:	48 83 c4 70          	add    rsp,0x70
  227811:	5b                   	pop    rbx
  227812:	41 5c                	pop    r12
  227814:	41 5e                	pop    r14
  227816:	41 5f                	pop    r15
  227818:	5d                   	pop    rbp
  227819:	c3                   	ret    
            @panic("assertion failure");
  22781a:	48 8d 3d 6f 85 02 00 	lea    rdi,[rip+0x2856f]        # 24fd90 <__unnamed_2>
  227821:	e8 fa ae fe ff       	call   212720 <panic>
  227826:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  22782d:	00 00 00 

0000000000227830 <readStringRaw>:
            return Self{
  227830:	55                   	push   rbp
  227831:	41 57                	push   r15
  227833:	41 56                	push   r14
  227835:	41 55                	push   r13
  227837:	41 54                	push   r12
  227839:	53                   	push   rbx
  22783a:	48 81 ec 98 00 00 00 	sub    rsp,0x98
  227841:	c5 f8 57 c0          	vxorps xmm0,xmm0,xmm0
  227845:	c5 f8 29 44 24 40    	vmovaps XMMWORD PTR [rsp+0x40],xmm0
  22784b:	48 89 d3             	mov    rbx,rdx
  22784e:	49 89 f7             	mov    r15,rsi
  227851:	48 89 7c 24 08       	mov    QWORD PTR [rsp+0x8],rdi
  227856:	48 c7 44 24 50 00 00 	mov    QWORD PTR [rsp+0x50],0x0
  22785d:	00 00 
    var buf = ArrayList(u8).init(allocator);
  22785f:	4c 89 7c 24 58       	mov    QWORD PTR [rsp+0x58],r15
  227864:	48 8d 44 24 07       	lea    rax,[rsp+0x7]
            try self.readNoEof(result[0..]);
  227869:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  22786e:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  227875:	00 00 
  227877:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  22787c:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
            return self.readFn(self, buffer);
  227881:	48 89 de             	mov    rsi,rbx
  227884:	ff 13                	call   QWORD PTR [rbx]
  227886:	0f b7 4c 24 20       	movzx  ecx,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  22788b:	66 85 c9             	test   cx,cx
  22788e:	74 34                	je     2278c4 <readStringRaw+0x94>
  227890:	48 8b 54 24 08       	mov    rdx,QWORD PTR [rsp+0x8]
        const byte = try in_stream.readByte();
  227895:	66 89 0a             	mov    WORD PTR [rdx],cx
  227898:	48 8b 84 24 90 00 00 	mov    rax,QWORD PTR [rsp+0x90]
  22789f:	00 
  2278a0:	48 89 42 10          	mov    QWORD PTR [rdx+0x10],rax
  2278a4:	c5 f8 10 84 24 82 00 	vmovups xmm0,XMMWORD PTR [rsp+0x82]
  2278ab:	00 00 
  2278ad:	c5 f8 11 42 02       	vmovups XMMWORD PTR [rdx+0x2],xmm0
  2278b2:	48 81 c4 98 00 00 00 	add    rsp,0x98
  2278b9:	5b                   	pop    rbx
  2278ba:	41 5c                	pop    r12
  2278bc:	41 5d                	pop    r13
  2278be:	41 5e                	pop    r14
  2278c0:	41 5f                	pop    r15
  2278c2:	5d                   	pop    rbp
  2278c3:	c3                   	ret    
  2278c4:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
  2278c9:	31 ed                	xor    ebp,ebp
  2278cb:	45 31 ed             	xor    r13d,r13d
  2278ce:	66 90                	xchg   ax,ax
            if (amt_read < buf.len) return error.EndOfStream;
  2278d0:	48 3b 44 24 18       	cmp    rax,QWORD PTR [rsp+0x18]
  2278d5:	0f 82 b6 00 00 00    	jb     227991 <readStringRaw+0x161>
            return result[0];
  2278db:	44 8a 64 24 07       	mov    r12b,BYTE PTR [rsp+0x7]
        if (byte == 0) break;
  2278e0:	45 84 e4             	test   r12b,r12b
  2278e3:	0f 84 b1 00 00 00    	je     22799a <readStringRaw+0x16a>
            var better_capacity = self.items.len;
  2278e9:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
            if (better_capacity >= new_capacity) return;
  2278ee:	4c 39 e9             	cmp    rcx,r13
  2278f1:	77 53                	ja     227946 <readStringRaw+0x116>
  2278f3:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  2278fa:	84 00 00 00 00 00 
                better_capacity += better_capacity / 2 + 8;
  227900:	48 89 c8             	mov    rax,rcx
  227903:	48 d1 e8             	shr    rax,1
  227906:	48 01 c1             	add    rcx,rax
  227909:	48 83 c1 08          	add    rcx,0x8
                if (better_capacity >= new_capacity) break;
  22790d:	4c 39 e9             	cmp    rcx,r13
  227910:	76 ee                	jbe    227900 <readStringRaw+0xd0>
            self.items = try self.allocator.alignedRealloc(T, A, self.items, better_capacity);
  227912:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  227917:	4c 89 fe             	mov    rsi,r15
  22791a:	48 8d 54 24 40       	lea    rdx,[rsp+0x40]
  22791f:	e8 2c 38 00 00       	call   22b150 <Allocator_alignedRealloc.181>
  227924:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  227929:	66 85 c0             	test   ax,ax
  22792c:	0f 85 94 00 00 00    	jne    2279c6 <readStringRaw+0x196>
  227932:	48 8d 44 24 28       	lea    rax,[rsp+0x28]
  227937:	c5 f8 10 00          	vmovups xmm0,XMMWORD PTR [rax]
  22793b:	c5 f8 29 44 24 40    	vmovaps XMMWORD PTR [rsp+0x40],xmm0
            const result = &self.items[self.len];
  227941:	48 8b 6c 24 40       	mov    rbp,QWORD PTR [rsp+0x40]
  227946:	4d 8d 75 01          	lea    r14,[r13+0x1]
            self.len = new_length;
  22794a:	4c 89 74 24 50       	mov    QWORD PTR [rsp+0x50],r14
            new_item_ptr.* = item;
  22794f:	46 88 64 2d 00       	mov    BYTE PTR [rbp+r13*1+0x0],r12b
            try self.readNoEof(result[0..]);
  227954:	48 8d 44 24 07       	lea    rax,[rsp+0x7]
  227959:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  22795e:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  227965:	00 00 
            return self.readFn(self, buffer);
  227967:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  22796c:	48 89 de             	mov    rsi,rbx
  22796f:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  227974:	ff 13                	call   QWORD PTR [rbx]
  227976:	0f b7 4c 24 20       	movzx  ecx,WORD PTR [rsp+0x20]
  22797b:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
  227980:	4d 89 f5             	mov    r13,r14
            const amt_read = try self.read(buf);
  227983:	66 85 c9             	test   cx,cx
  227986:	0f 84 44 ff ff ff    	je     2278d0 <readStringRaw+0xa0>
  22798c:	e9 ff fe ff ff       	jmp    227890 <readStringRaw+0x60>
  227991:	66 b9 25 00          	mov    cx,0x25
  227995:	e9 f6 fe ff ff       	jmp    227890 <readStringRaw+0x60>
  22799a:	48 8b 54 24 08       	mov    rdx,QWORD PTR [rsp+0x8]
    return buf.toSlice();
  22799f:	66 c7 02 00 00       	mov    WORD PTR [rdx],0x0
  2279a4:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  2279a9:	66 89 42 06          	mov    WORD PTR [rdx+0x6],ax
            return self.items[0..self.len];
  2279ad:	48 8b 44 24 40       	mov    rax,QWORD PTR [rsp+0x40]
  2279b2:	8b 4c 24 3a          	mov    ecx,DWORD PTR [rsp+0x3a]
  2279b6:	89 4a 02             	mov    DWORD PTR [rdx+0x2],ecx
  2279b9:	48 89 42 08          	mov    QWORD PTR [rdx+0x8],rax
  2279bd:	4c 89 6a 10          	mov    QWORD PTR [rdx+0x10],r13
  2279c1:	e9 ec fe ff ff       	jmp    2278b2 <readStringRaw+0x82>
  2279c6:	48 8b 4c 24 08       	mov    rcx,QWORD PTR [rsp+0x8]
        try buf.append(byte);
  2279cb:	66 89 01             	mov    WORD PTR [rcx],ax
  2279ce:	48 8b 44 24 7a       	mov    rax,QWORD PTR [rsp+0x7a]
  2279d3:	48 89 41 10          	mov    QWORD PTR [rcx+0x10],rax
  2279d7:	c5 f8 10 44 24 6c    	vmovups xmm0,XMMWORD PTR [rsp+0x6c]
  2279dd:	c5 f8 11 41 02       	vmovups XMMWORD PTR [rcx+0x2],xmm0
  2279e2:	e9 cb fe ff ff       	jmp    2278b2 <readStringRaw+0x82>
  2279e7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  2279ee:	00 00 

00000000002279f0 <Allocator_alignedRealloc.165>:
    pub fn alignedRealloc(self: *Allocator, comptime T: type, comptime alignment: u29, old_mem: []align(alignment) T, n: usize) ![]align(alignment) T {
  2279f0:	41 56                	push   r14
  2279f2:	53                   	push   rbx
  2279f3:	48 81 ec 88 00 00 00 	sub    rsp,0x88
  2279fa:	48 89 fb             	mov    rbx,rdi
        if (old_mem.len == 0) {
  2279fd:	48 8b 42 08          	mov    rax,QWORD PTR [rdx+0x8]
  227a01:	48 85 c0             	test   rax,rax
  227a04:	74 62                	je     227a68 <Allocator_alignedRealloc.165+0x78>
        if (n == 0) {
  227a06:	48 85 c9             	test   rcx,rcx
  227a09:	0f 84 a9 00 00 00    	je     227ab8 <Allocator_alignedRealloc.165+0xc8>
        const old_byte_slice = @sliceToBytes(old_mem);
  227a0f:	48 8b 12             	mov    rdx,QWORD PTR [rdx]
  227a12:	48 c1 e0 04          	shl    rax,0x4
  227a16:	48 8d 04 40          	lea    rax,[rax+rax*2]
  227a1a:	48 89 54 24 38       	mov    QWORD PTR [rsp+0x38],rdx
  227a1f:	48 89 44 24 40       	mov    QWORD PTR [rsp+0x40],rax
  227a24:	ba 30 00 00 00       	mov    edx,0x30
  227a29:	48 89 c8             	mov    rax,rcx
  227a2c:	48 f7 e2             	mul    rdx
  227a2f:	0f 81 d0 00 00 00    	jno    227b05 <Allocator_alignedRealloc.165+0x115>
  227a35:	48 8d 0d 84 8a fd ff 	lea    rcx,[rip+0xfffffffffffd8a84]        # 2004c0 <__unnamed_27>
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  227a3c:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  227a40:	0f 84 da 00 00 00    	je     227b20 <Allocator_alignedRealloc.165+0x130>
  227a46:	48 8b 05 5b 09 fe ff 	mov    rax,QWORD PTR [rip+0xfffffffffffe095b]        # 2083a8 <__unnamed_67+0x10>
  227a4d:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  227a51:	c5 f8 10 05 3f 09 fe 	vmovups xmm0,XMMWORD PTR [rip+0xfffffffffffe093f]        # 208398 <__unnamed_67>
  227a58:	ff 
  227a59:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  227a5d:	48 81 c4 88 00 00 00 	add    rsp,0x88
  227a64:	5b                   	pop    rbx
  227a65:	41 5e                	pop    r14
  227a67:	c3                   	ret    
        if (n == 0) {
  227a68:	48 85 c9             	test   rcx,rcx
  227a6b:	0f 84 fc 00 00 00    	je     227b6d <Allocator_alignedRealloc.165+0x17d>
  227a71:	ba 30 00 00 00       	mov    edx,0x30
  227a76:	48 89 c8             	mov    rax,rcx
  227a79:	48 f7 e2             	mul    rdx
  227a7c:	0f 81 0c 01 00 00    	jno    227b8e <Allocator_alignedRealloc.165+0x19e>
  227a82:	48 8d 0d 37 8a fd ff 	lea    rcx,[rip+0xfffffffffffd8a37]        # 2004c0 <__unnamed_27>
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  227a89:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  227a8d:	0f 84 16 01 00 00    	je     227ba9 <Allocator_alignedRealloc.165+0x1b9>
  227a93:	0f b7 05 04 09 fe ff 	movzx  eax,WORD PTR [rip+0xfffffffffffe0904]        # 20839e <__unnamed_67+0x6>
  227a9a:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  227a9f:	8b 05 f5 08 fe ff    	mov    eax,DWORD PTR [rip+0xfffffffffffe08f5]        # 20839a <__unnamed_67+0x2>
  227aa5:	89 04 24             	mov    DWORD PTR [rsp],eax
  227aa8:	48 89 e0             	mov    rax,rsp
  227aab:	66 b9 01 00          	mov    cx,0x1
  227aaf:	31 f6                	xor    esi,esi
  227ab1:	31 d2                	xor    edx,edx
  227ab3:	e9 9d 01 00 00       	jmp    227c55 <Allocator_alignedRealloc.165+0x265>
        const bytes = @sliceToBytes(memory);
  227ab8:	48 c1 e0 04          	shl    rax,0x4
  227abc:	48 8d 04 40          	lea    rax,[rax+rax*2]
        if (bytes.len == 0) return;
  227ac0:	48 85 c0             	test   rax,rax
  227ac3:	74 1e                	je     227ae3 <Allocator_alignedRealloc.165+0xf3>
        const bytes = @sliceToBytes(memory);
  227ac5:	48 8b 0a             	mov    rcx,QWORD PTR [rdx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  227ac8:	48 8b 56 10          	mov    rdx,QWORD PTR [rsi+0x10]
  227acc:	48 89 4c 24 08       	mov    QWORD PTR [rsp+0x8],rcx
  227ad1:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  227ad6:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  227adb:	48 89 f7             	mov    rdi,rsi
  227ade:	48 89 c6             	mov    rsi,rax
  227ae1:	ff d2                	call   rdx
            return ([*]align(alignment) T)(undefined)[0..0];
  227ae3:	48 8b 05 a6 08 fe ff 	mov    rax,QWORD PTR [rip+0xfffffffffffe08a6]        # 208390 <__unnamed_68+0x10>
  227aea:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  227aee:	c5 f8 10 05 8a 08 fe 	vmovups xmm0,XMMWORD PTR [rip+0xfffffffffffe088a]        # 208380 <__unnamed_68>
  227af5:	ff 
  227af6:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  227afa:	48 81 c4 88 00 00 00 	add    rsp,0x88
  227b01:	5b                   	pop    rbx
  227b02:	41 5e                	pop    r14
  227b04:	c3                   	ret    
  227b05:	48 8d 4c 24 08       	lea    rcx,[rsp+0x8]
  227b0a:	66 c7 44 24 08 00 00 	mov    WORD PTR [rsp+0x8],0x0
  227b11:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  227b16:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  227b1a:	0f 85 26 ff ff ff    	jne    227a46 <Allocator_alignedRealloc.165+0x56>
  227b20:	4c 8b 71 08          	mov    r14,QWORD PTR [rcx+0x8]
  227b24:	48 8d 7c 24 58       	lea    rdi,[rsp+0x58]
  227b29:	48 8d 54 24 38       	lea    rdx,[rsp+0x38]
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  227b2e:	41 b8 02 00 00 00    	mov    r8d,0x2
  227b34:	4c 89 f1             	mov    rcx,r14
  227b37:	ff 56 08             	call   QWORD PTR [rsi+0x8]
  227b3a:	0f b7 44 24 58       	movzx  eax,WORD PTR [rsp+0x58]
  227b3f:	66 85 c0             	test   ax,ax
  227b42:	0f 84 94 00 00 00    	je     227bdc <Allocator_alignedRealloc.165+0x1ec>
  227b48:	66 89 03             	mov    WORD PTR [rbx],ax
  227b4b:	48 8b 84 24 80 00 00 	mov    rax,QWORD PTR [rsp+0x80]
  227b52:	00 
  227b53:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  227b57:	c5 f8 10 44 24 72    	vmovups xmm0,XMMWORD PTR [rsp+0x72]
  227b5d:	c5 f8 11 43 02       	vmovups XMMWORD PTR [rbx+0x2],xmm0
  227b62:	48 81 c4 88 00 00 00 	add    rsp,0x88
  227b69:	5b                   	pop    rbx
  227b6a:	41 5e                	pop    r14
  227b6c:	c3                   	ret    
  227b6d:	48 89 e0             	mov    rax,rsp
            return ([*]align(alignment) T)(undefined)[0..0];
  227b70:	0f b7 0d 0f 08 fe ff 	movzx  ecx,WORD PTR [rip+0xfffffffffffe080f]        # 208386 <__unnamed_68+0x6>
  227b77:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  227b7c:	8b 0d 00 08 fe ff    	mov    ecx,DWORD PTR [rip+0xfffffffffffe0800]        # 208382 <__unnamed_68+0x2>
  227b82:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  227b85:	31 c9                	xor    ecx,ecx
  227b87:	31 d2                	xor    edx,edx
  227b89:	e9 c7 00 00 00       	jmp    227c55 <Allocator_alignedRealloc.165+0x265>
  227b8e:	48 8d 4c 24 48       	lea    rcx,[rsp+0x48]
  227b93:	66 c7 44 24 48 00 00 	mov    WORD PTR [rsp+0x48],0x0
  227b9a:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  227b9f:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  227ba3:	0f 85 ea fe ff ff    	jne    227a93 <Allocator_alignedRealloc.165+0xa3>
  227ba9:	4c 8b 71 08          	mov    r14,QWORD PTR [rcx+0x8]
  227bad:	48 8d 7c 24 08       	lea    rdi,[rsp+0x8]
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  227bb2:	b9 02 00 00 00       	mov    ecx,0x2
  227bb7:	4c 89 f2             	mov    rdx,r14
  227bba:	ff 16                	call   QWORD PTR [rsi]
  227bbc:	0f b7 4c 24 08       	movzx  ecx,WORD PTR [rsp+0x8]
  227bc1:	66 85 c9             	test   cx,cx
  227bc4:	74 57                	je     227c1d <Allocator_alignedRealloc.165+0x22d>
  227bc6:	0f b7 44 24 36       	movzx  eax,WORD PTR [rsp+0x36]
  227bcb:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  227bd0:	48 89 e0             	mov    rax,rsp
  227bd3:	8b 54 24 32          	mov    edx,DWORD PTR [rsp+0x32]
  227bd7:	89 14 24             	mov    DWORD PTR [rsp],edx
  227bda:	eb 79                	jmp    227c55 <Allocator_alignedRealloc.165+0x265>
        assert(byte_slice.len == byte_count);
  227bdc:	4c 39 74 24 68       	cmp    QWORD PTR [rsp+0x68],r14
    if (!ok) {
  227be1:	0f 85 91 00 00 00    	jne    227c78 <Allocator_alignedRealloc.165+0x288>
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  227be7:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  227bec:	48 b9 ab aa aa aa aa 	movabs rcx,0xaaaaaaaaaaaaaaab
  227bf3:	aa aa aa 
  227bf6:	4c 89 f2             	mov    rdx,r14
  227bf9:	c4 e2 f3 f6 d1       	mulx   rdx,rcx,rcx
  227bfe:	66 c7 03 00 00       	mov    WORD PTR [rbx],0x0
  227c03:	0f b7 4c 24 2a       	movzx  ecx,WORD PTR [rsp+0x2a]
  227c08:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  227c0c:	48 c1 ea 05          	shr    rdx,0x5
  227c10:	8b 4c 24 26          	mov    ecx,DWORD PTR [rsp+0x26]
  227c14:	89 4b 02             	mov    DWORD PTR [rbx+0x2],ecx
  227c17:	48 89 43 08          	mov    QWORD PTR [rbx+0x8],rax
  227c1b:	eb 4c                	jmp    227c69 <Allocator_alignedRealloc.165+0x279>
        assert(byte_slice.len == byte_count);
  227c1d:	4c 39 74 24 18       	cmp    QWORD PTR [rsp+0x18],r14
  227c22:	75 54                	jne    227c78 <Allocator_alignedRealloc.165+0x288>
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  227c24:	48 8b 74 24 10       	mov    rsi,QWORD PTR [rsp+0x10]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  227c29:	48 b8 ab aa aa aa aa 	movabs rax,0xaaaaaaaaaaaaaaab
  227c30:	aa aa aa 
  227c33:	4c 89 f2             	mov    rdx,r14
  227c36:	c4 e2 fb f6 d0       	mulx   rdx,rax,rax
  227c3b:	48 c1 ea 05          	shr    rdx,0x5
  227c3f:	48 89 e0             	mov    rax,rsp
  227c42:	8b 4c 24 2c          	mov    ecx,DWORD PTR [rsp+0x2c]
  227c46:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  227c49:	0f b7 4c 24 30       	movzx  ecx,WORD PTR [rsp+0x30]
  227c4e:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  227c53:	31 c9                	xor    ecx,ecx
            return self.alignedAlloc(T, alignment, n);
  227c55:	66 89 0b             	mov    WORD PTR [rbx],cx
  227c58:	0f b7 48 04          	movzx  ecx,WORD PTR [rax+0x4]
  227c5c:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  227c60:	8b 00                	mov    eax,DWORD PTR [rax]
  227c62:	89 43 02             	mov    DWORD PTR [rbx+0x2],eax
  227c65:	48 89 73 08          	mov    QWORD PTR [rbx+0x8],rsi
  227c69:	48 89 53 10          	mov    QWORD PTR [rbx+0x10],rdx
  227c6d:	48 81 c4 88 00 00 00 	add    rsp,0x88
  227c74:	5b                   	pop    rbx
  227c75:	41 5e                	pop    r14
  227c77:	c3                   	ret    
            @panic("assertion failure");
  227c78:	48 8d 3d 11 81 02 00 	lea    rdi,[rip+0x28111]        # 24fd90 <__unnamed_2>
  227c7f:	e8 9c aa fe ff       	call   212720 <panic>
  227c84:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  227c8b:	00 00 00 00 00 

0000000000227c90 <printSourceAtAddressLinux>:
pub fn printSourceAtAddressLinux(debug_info: *DebugInfo, out_stream: var, address: usize, tty_color: bool) !void {
  227c90:	55                   	push   rbp
  227c91:	41 57                	push   r15
  227c93:	41 56                	push   r14
  227c95:	41 55                	push   r13
  227c97:	41 54                	push   r12
  227c99:	53                   	push   rbx
  227c9a:	48 81 ec 08 0c 00 00 	sub    rsp,0xc08
  227ca1:	89 8c 24 2c 01 00 00 	mov    DWORD PTR [rsp+0x12c],ecx
  227ca8:	48 89 74 24 08       	mov    QWORD PTR [rsp+0x8],rsi
    var in_file_stream = io.FileInStream.init(&st.self_exe_file);
  227cad:	48 89 bc 24 28 02 00 	mov    QWORD PTR [rsp+0x228],rdi
  227cb4:	00 
  227cb5:	48 8d 05 a4 c4 ff ff 	lea    rax,[rip+0xffffffffffffc4a4]        # 224160 <FileInStream_readFn>
  227cbc:	48 89 84 24 30 02 00 	mov    QWORD PTR [rsp+0x230],rax
  227cc3:	00 
  227cc4:	48 8b 87 b8 00 00 00 	mov    rax,QWORD PTR [rdi+0xb8]
  227ccb:	48 89 84 24 98 01 00 	mov    QWORD PTR [rsp+0x198],rax
  227cd2:	00 
    for (st.compile_unit_list.toSlice()) |*compile_unit| {
  227cd3:	48 85 c0             	test   rax,rax
  227cd6:	48 89 d0             	mov    rax,rdx
  227cd9:	48 89 84 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],rax
  227ce0:	00 
  227ce1:	0f 84 9b 04 00 00    	je     228182 <printSourceAtAddressLinux+0x4f2>
  227ce7:	4c 8b b7 a8 00 00 00 	mov    r14,QWORD PTR [rdi+0xa8]
  227cee:	45 31 ed             	xor    r13d,r13d
  227cf1:	4c 8d bc 24 b0 00 00 	lea    r15,[rsp+0xb0]
  227cf8:	00 
  227cf9:	c4 62 7d 59 25 86 8f 	vpbroadcastq ymm12,QWORD PTR [rip+0xfffffffffffd8f86]        # 200c88 <__unnamed_622+0x10>
  227d00:	fd ff 
  227d02:	c4 62 7d 59 2d f5 8f 	vpbroadcastq ymm13,QWORD PTR [rip+0xfffffffffffd8ff5]        # 200d00 <__unnamed_621+0x48>
  227d09:	fd ff 
  227d0b:	48 89 7c 24 68       	mov    QWORD PTR [rsp+0x68],rdi
  227d10:	eb 2e                	jmp    227d40 <printSourceAtAddressLinux+0xb0>
  227d12:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  227d16:	31 ff                	xor    edi,edi
  227d18:	c5 fd 6f 25 80 84 fd 	vmovdqa ymm4,YMMWORD PTR [rip+0xfffffffffffd8480]        # 2001a0 <__unnamed_29-0x60>
  227d1f:	ff 
  227d20:	c5 f1 ef c9          	vpxor  xmm1,xmm1,xmm1
  227d24:	c5 e1 ef db          	vpxor  xmm3,xmm3,xmm3
  227d28:	c5 e9 ef d2          	vpxor  xmm2,xmm2,xmm2
            for (bytes) |b, index| {
  227d2c:	4d 85 c0             	test   r8,r8
  227d2f:	0f 85 fc 01 00 00    	jne    227f31 <printSourceAtAddressLinux+0x2a1>
  227d35:	e9 4a 02 00 00       	jmp    227f84 <printSourceAtAddressLinux+0x2f4>
  227d3a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
        if (compile_unit.pc_range) |range| {
  227d40:	4e 8d 24 6d 00 00 00 	lea    r12,[r13*2+0x0]
  227d47:	00 
  227d48:	4d 01 ec             	add    r12,r13
  227d4b:	49 c1 e4 04          	shl    r12,0x4
  227d4f:	43 80 7c 26 28 01    	cmp    BYTE PTR [r14+r12*1+0x28],0x1
  227d55:	75 12                	jne    227d69 <printSourceAtAddressLinux+0xd9>
            if (target_address >= range.start and target_address < range.end) return compile_unit;
  227d57:	4b 39 54 26 18       	cmp    QWORD PTR [r14+r12*1+0x18],rdx
  227d5c:	77 0b                	ja     227d69 <printSourceAtAddressLinux+0xd9>
  227d5e:	4b 39 54 26 20       	cmp    QWORD PTR [r14+r12*1+0x20],rdx
  227d63:	0f 87 32 06 00 00    	ja     22839b <printSourceAtAddressLinux+0x70b>
        if (compile_unit.die.getAttrSecOffset(DW.AT_ranges)) |ranges_offset| {
  227d69:	4b 8b 4c 26 08       	mov    rcx,QWORD PTR [r14+r12*1+0x8]
  227d6e:	48 8b 41 20          	mov    rax,QWORD PTR [rcx+0x20]
        for (self.attrs.toSliceConst()) |*attr| {
  227d72:	48 85 c0             	test   rax,rax
  227d75:	0f 84 f5 03 00 00    	je     228170 <printSourceAtAddressLinux+0x4e0>
  227d7b:	4b 8d 34 26          	lea    rsi,[r14+r12*1]
  227d7f:	48 83 c6 08          	add    rsi,0x8
  227d83:	48 89 b4 24 68 01 00 	mov    QWORD PTR [rsp+0x168],rsi
  227d8a:	00 
  227d8b:	48 8b 49 10          	mov    rcx,QWORD PTR [rcx+0x10]
            if (attr.id == id) return &attr.value;
  227d8f:	48 83 c1 20          	add    rcx,0x20
  227d93:	31 f6                	xor    esi,esi
  227d95:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  227d9c:	00 00 00 00 
  227da0:	48 83 79 e0 55       	cmp    QWORD PTR [rcx-0x20],0x55
  227da5:	74 19                	je     227dc0 <printSourceAtAddressLinux+0x130>
        for (self.attrs.toSliceConst()) |*attr| {
  227da7:	48 83 c6 01          	add    rsi,0x1
  227dab:	48 83 c1 28          	add    rcx,0x28
  227daf:	48 39 c6             	cmp    rsi,rax
  227db2:	72 ec                	jb     227da0 <printSourceAtAddressLinux+0x110>
  227db4:	e9 b7 03 00 00       	jmp    228170 <printSourceAtAddressLinux+0x4e0>
  227db9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  227dc0:	8a 01                	mov    al,BYTE PTR [rcx]
  227dc2:	3c 05                	cmp    al,0x5
        return switch (form_value.*) {
  227dc4:	74 39                	je     227dff <printSourceAtAddressLinux+0x16f>
  227dc6:	3c 02                	cmp    al,0x2
  227dc8:	0f 85 b4 03 00 00    	jne    228182 <printSourceAtAddressLinux+0x4f2>
            FormValue.Const => |value| value.asUnsignedLe(),
  227dce:	48 8b 41 f0          	mov    rax,QWORD PTR [rcx-0x10]
        if (self.payload.len > @sizeOf(u64)) return error.InvalidDebugInfo;
  227dd2:	48 83 f8 08          	cmp    rax,0x8
  227dd6:	0f 87 a6 03 00 00    	ja     228182 <printSourceAtAddressLinux+0x4f2>
            FormValue.Const => |value| value.asUnsignedLe(),
  227ddc:	8a 59 f8             	mov    bl,BYTE PTR [rcx-0x8]
        if (self.signed) return error.InvalidDebugInfo;
  227ddf:	84 db                	test   bl,bl
  227de1:	0f 85 9b 03 00 00    	jne    228182 <printSourceAtAddressLinux+0x4f2>
  227de7:	48 85 c0             	test   rax,rax
  227dea:	74 1c                	je     227e08 <printSourceAtAddressLinux+0x178>
  227dec:	48 8b 49 e8          	mov    rcx,QWORD PTR [rcx-0x18]
  227df0:	48 83 f8 10          	cmp    rax,0x10
  227df4:	73 19                	jae    227e0f <printSourceAtAddressLinux+0x17f>
  227df6:	31 ed                	xor    ebp,ebp
  227df8:	31 f6                	xor    esi,esi
  227dfa:	e9 ae 01 00 00       	jmp    227fad <printSourceAtAddressLinux+0x31d>
            FormValue.SecOffset => |value| value,
  227dff:	48 8b 71 e8          	mov    rsi,QWORD PTR [rcx-0x18]
  227e03:	e9 d6 01 00 00       	jmp    227fde <printSourceAtAddressLinux+0x34e>
        return switch (form_value.*) {
  227e08:	31 f6                	xor    esi,esi
  227e0a:	e9 cf 01 00 00       	jmp    227fde <printSourceAtAddressLinux+0x34e>
  227e0f:	48 89 c5             	mov    rbp,rax
  227e12:	48 83 e5 f0          	and    rbp,0xfffffffffffffff0
  227e16:	48 8d 75 f0          	lea    rsi,[rbp-0x10]
  227e1a:	48 89 f7             	mov    rdi,rsi
  227e1d:	48 c1 ef 04          	shr    rdi,0x4
  227e21:	44 8d 47 01          	lea    r8d,[rdi+0x1]
  227e25:	41 83 e0 01          	and    r8d,0x1
  227e29:	48 85 f6             	test   rsi,rsi
  227e2c:	0f 84 e0 fe ff ff    	je     227d12 <printSourceAtAddressLinux+0x82>
  227e32:	49 8d 70 ff          	lea    rsi,[r8-0x1]
  227e36:	48 29 fe             	sub    rsi,rdi
  227e39:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  227e3d:	31 ff                	xor    edi,edi
  227e3f:	c5 fd 6f 25 59 83 fd 	vmovdqa ymm4,YMMWORD PTR [rip+0xfffffffffffd8359]        # 2001a0 <__unnamed_29-0x60>
  227e46:	ff 
  227e47:	c5 f1 ef c9          	vpxor  xmm1,xmm1,xmm1
  227e4b:	c5 e1 ef db          	vpxor  xmm3,xmm3,xmm3
  227e4f:	c5 e9 ef d2          	vpxor  xmm2,xmm2,xmm2
  227e53:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  227e5a:	84 00 00 00 00 00 
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  227e60:	c4 e2 7d 32 2c 39    	vpmovzxbq ymm5,DWORD PTR [rcx+rdi*1]
  227e66:	c4 e2 7d 32 74 39 04 	vpmovzxbq ymm6,DWORD PTR [rcx+rdi*1+0x4]
  227e6d:	c4 e2 7d 32 7c 39 08 	vpmovzxbq ymm7,DWORD PTR [rcx+rdi*1+0x8]
  227e74:	c4 62 7d 32 44 39 0c 	vpmovzxbq ymm8,DWORD PTR [rcx+rdi*1+0xc]
  227e7b:	c5 b5 73 f4 03       	vpsllq ymm9,ymm4,0x3
  227e80:	c4 41 35 d4 d4       	vpaddq ymm10,ymm9,ymm12
  227e85:	c4 41 35 db dd       	vpand  ymm11,ymm9,ymm13
  227e8a:	c4 41 2d db d5       	vpand  ymm10,ymm10,ymm13
  227e8f:	c4 c2 d5 47 eb       	vpsllvq ymm5,ymm5,ymm11
  227e94:	c5 d5 eb c0          	vpor   ymm0,ymm5,ymm0
  227e98:	c4 c2 cd 47 ea       	vpsllvq ymm5,ymm6,ymm10
  227e9d:	c5 d5 eb c9          	vpor   ymm1,ymm5,ymm1
  227ea1:	c4 c2 c5 47 eb       	vpsllvq ymm5,ymm7,ymm11
  227ea6:	c5 d5 eb db          	vpor   ymm3,ymm5,ymm3
  227eaa:	c4 c2 bd 47 ea       	vpsllvq ymm5,ymm8,ymm10
  227eaf:	c4 e2 7d 32 74 39 10 	vpmovzxbq ymm6,DWORD PTR [rcx+rdi*1+0x10]
  227eb6:	c4 e2 7d 32 7c 39 14 	vpmovzxbq ymm7,DWORD PTR [rcx+rdi*1+0x14]
  227ebd:	c4 62 7d 32 44 39 18 	vpmovzxbq ymm8,DWORD PTR [rcx+rdi*1+0x18]
  227ec4:	c5 d5 eb d2          	vpor   ymm2,ymm5,ymm2
  227ec8:	c4 e2 7d 32 6c 39 1c 	vpmovzxbq ymm5,DWORD PTR [rcx+rdi*1+0x1c]
  227ecf:	c4 62 7d 59 15 18 8e 	vpbroadcastq ymm10,QWORD PTR [rip+0xfffffffffffd8e18]        # 200cf0 <__unnamed_621+0x38>
  227ed6:	fd ff 
  227ed8:	c4 41 35 d4 d2       	vpaddq ymm10,ymm9,ymm10
  227edd:	c4 62 7d 59 1d 42 8d 	vpbroadcastq ymm11,QWORD PTR [rip+0xfffffffffffd8d42]        # 200c28 <__unnamed_464+0x18>
  227ee4:	fd ff 
  227ee6:	c4 41 35 d4 cb       	vpaddq ymm9,ymm9,ymm11
  227eeb:	c4 41 2d db d5       	vpand  ymm10,ymm10,ymm13
  227ef0:	c4 41 35 db cd       	vpand  ymm9,ymm9,ymm13
  227ef5:	c4 c2 cd 47 f2       	vpsllvq ymm6,ymm6,ymm10
  227efa:	c5 cd eb c0          	vpor   ymm0,ymm6,ymm0
  227efe:	c4 c2 c5 47 f1       	vpsllvq ymm6,ymm7,ymm9
  227f03:	c5 cd eb c9          	vpor   ymm1,ymm6,ymm1
  227f07:	c4 c2 bd 47 f2       	vpsllvq ymm6,ymm8,ymm10
  227f0c:	c5 cd eb db          	vpor   ymm3,ymm6,ymm3
  227f10:	c4 c2 d5 47 e9       	vpsllvq ymm5,ymm5,ymm9
  227f15:	c5 d5 eb d2          	vpor   ymm2,ymm5,ymm2
            for (bytes) |b, index| {
  227f19:	48 83 c7 20          	add    rdi,0x20
  227f1d:	c4 c1 5d d4 e4       	vpaddq ymm4,ymm4,ymm12
  227f22:	48 83 c6 02          	add    rsi,0x2
  227f26:	0f 85 34 ff ff ff    	jne    227e60 <printSourceAtAddressLinux+0x1d0>
  227f2c:	4d 85 c0             	test   r8,r8
  227f2f:	74 53                	je     227f84 <printSourceAtAddressLinux+0x2f4>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  227f31:	c4 e2 7d 32 6c 39 0c 	vpmovzxbq ymm5,DWORD PTR [rcx+rdi*1+0xc]
  227f38:	c5 dd 73 f4 03       	vpsllq ymm4,ymm4,0x3
  227f3d:	c4 c1 5d d4 f4       	vpaddq ymm6,ymm4,ymm12
  227f42:	c4 c1 4d db f5       	vpand  ymm6,ymm6,ymm13
  227f47:	c4 e2 d5 47 ee       	vpsllvq ymm5,ymm5,ymm6
  227f4c:	c4 e2 7d 32 7c 39 08 	vpmovzxbq ymm7,DWORD PTR [rcx+rdi*1+0x8]
  227f53:	c5 d5 eb d2          	vpor   ymm2,ymm5,ymm2
  227f57:	c4 c1 5d db e5       	vpand  ymm4,ymm4,ymm13
  227f5c:	c4 e2 c5 47 ec       	vpsllvq ymm5,ymm7,ymm4
  227f61:	c5 d5 eb db          	vpor   ymm3,ymm5,ymm3
  227f65:	c4 e2 7d 32 6c 39 04 	vpmovzxbq ymm5,DWORD PTR [rcx+rdi*1+0x4]
  227f6c:	c4 e2 d5 47 ee       	vpsllvq ymm5,ymm5,ymm6
  227f71:	c5 d5 eb c9          	vpor   ymm1,ymm5,ymm1
  227f75:	c4 e2 7d 32 2c 39    	vpmovzxbq ymm5,DWORD PTR [rcx+rdi*1]
  227f7b:	c4 e2 d5 47 e4       	vpsllvq ymm4,ymm5,ymm4
  227f80:	c5 dd eb c0          	vpor   ymm0,ymm4,ymm0
  227f84:	c5 f5 eb ca          	vpor   ymm1,ymm1,ymm2
  227f88:	c5 fd eb c3          	vpor   ymm0,ymm0,ymm3
  227f8c:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  227f90:	c4 e3 7d 39 c1 01    	vextracti128 xmm1,ymm0,0x1
  227f96:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  227f9a:	c5 f9 70 c8 4e       	vpshufd xmm1,xmm0,0x4e
  227f9f:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  227fa3:	c4 e1 f9 7e c6       	vmovq  rsi,xmm0
  227fa8:	48 39 e8             	cmp    rax,rbp
            for (bytes) |b, index| {
  227fab:	74 31                	je     227fde <printSourceAtAddressLinux+0x34e>
  227fad:	48 29 e8             	sub    rax,rbp
  227fb0:	48 01 e9             	add    rcx,rbp
  227fb3:	48 c1 e5 03          	shl    rbp,0x3
  227fb7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  227fbe:	00 00 
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  227fc0:	0f b6 39             	movzx  edi,BYTE PTR [rcx]
  227fc3:	89 eb                	mov    ebx,ebp
  227fc5:	80 e3 38             	and    bl,0x38
  227fc8:	c4 e2 e1 f7 ff       	shlx   rdi,rdi,rbx
  227fcd:	48 09 fe             	or     rsi,rdi
            for (bytes) |b, index| {
  227fd0:	48 83 c5 08          	add    rbp,0x8
  227fd4:	48 83 c1 01          	add    rcx,0x1
  227fd8:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  227fdc:	75 e2                	jne    227fc0 <printSourceAtAddressLinux+0x330>
  227fde:	48 8b 4c 24 68       	mov    rcx,QWORD PTR [rsp+0x68]
            if (st.debug_ranges) |debug_ranges| {
  227fe3:	48 8b 81 80 00 00 00 	mov    rax,QWORD PTR [rcx+0x80]
  227fea:	48 85 c0             	test   rax,rax
  227fed:	48 8d 6c 24 50       	lea    rbp,[rsp+0x50]
  227ff2:	0f 84 78 01 00 00    	je     228170 <printSourceAtAddressLinux+0x4e0>
    if (@maxValue(@typeOf(x)) > @maxValue(T) and x > @maxValue(T)) {
  227ff8:	48 03 70 18          	add    rsi,QWORD PTR [rax+0x18]
  227ffc:	0f 88 80 01 00 00    	js     228182 <printSourceAtAddressLinux+0x4f2>
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  228002:	48 63 39             	movsxd rdi,DWORD PTR [rcx]
  228005:	b8 08 00 00 00       	mov    eax,0x8
  22800a:	31 d2                	xor    edx,edx
  22800c:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  22800e:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
                if (err > 0) {
  228014:	0f 83 68 01 00 00    	jae    228182 <printSourceAtAddressLinux+0x4f2>
  22801a:	c5 7e 7f ac 24 40 03 	vmovdqu YMMWORD PTR [rsp+0x340],ymm13
  228021:	00 00 
  228023:	c5 7e 7f a4 24 c0 01 	vmovdqu YMMWORD PTR [rsp+0x1c0],ymm12
  22802a:	00 00 
            try self.readNoEof(bytes[0..]);
  22802c:	48 89 ac 24 30 01 00 	mov    QWORD PTR [rsp+0x130],rbp
  228033:	00 
  228034:	48 c7 84 24 38 01 00 	mov    QWORD PTR [rsp+0x138],0x8
  22803b:	00 08 00 00 00 
            return self.readFn(self, buffer);
  228040:	4c 89 ff             	mov    rdi,r15
  228043:	48 8d b4 24 30 02 00 	lea    rsi,[rsp+0x230]
  22804a:	00 
  22804b:	48 8d 94 24 30 01 00 	lea    rdx,[rsp+0x130]
  228052:	00 
  228053:	c5 f8 77             	vzeroupper 
  228056:	ff 94 24 30 02 00 00 	call   QWORD PTR [rsp+0x230]
            const amt_read = try self.read(buf);
  22805d:	66 83 bc 24 b0 00 00 	cmp    WORD PTR [rsp+0xb0],0x0
  228064:	00 00 
  228066:	0f 85 16 01 00 00    	jne    228182 <printSourceAtAddressLinux+0x4f2>
  22806c:	48 8b 84 24 b8 00 00 	mov    rax,QWORD PTR [rsp+0xb8]
  228073:	00 
  228074:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  22807b:	00 00 00 00 00 
            if (amt_read < buf.len) return error.EndOfStream;
  228080:	48 3b 84 24 38 01 00 	cmp    rax,QWORD PTR [rsp+0x138]
  228087:	00 
  228088:	0f 82 f4 00 00 00    	jb     228182 <printSourceAtAddressLinux+0x4f2>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  22808e:	48 8b 5c 24 50       	mov    rbx,QWORD PTR [rsp+0x50]
            try self.readNoEof(bytes[0..]);
  228093:	48 89 ac 24 30 01 00 	mov    QWORD PTR [rsp+0x130],rbp
  22809a:	00 
  22809b:	48 c7 84 24 38 01 00 	mov    QWORD PTR [rsp+0x138],0x8
  2280a2:	00 08 00 00 00 
            return self.readFn(self, buffer);
  2280a7:	4c 89 ff             	mov    rdi,r15
  2280aa:	48 8d b4 24 30 02 00 	lea    rsi,[rsp+0x230]
  2280b1:	00 
  2280b2:	48 8d 94 24 30 01 00 	lea    rdx,[rsp+0x130]
  2280b9:	00 
  2280ba:	ff 94 24 30 02 00 00 	call   QWORD PTR [rsp+0x230]
            const amt_read = try self.read(buf);
  2280c1:	66 83 bc 24 b0 00 00 	cmp    WORD PTR [rsp+0xb0],0x0
  2280c8:	00 00 
  2280ca:	0f 85 b2 00 00 00    	jne    228182 <printSourceAtAddressLinux+0x4f2>
  2280d0:	48 8b 84 24 38 01 00 	mov    rax,QWORD PTR [rsp+0x138]
  2280d7:	00 
  2280d8:	48 39 84 24 b8 00 00 	cmp    QWORD PTR [rsp+0xb8],rax
  2280df:	00 
  2280e0:	0f 82 9c 00 00 00    	jb     228182 <printSourceAtAddressLinux+0x4f2>
  2280e6:	48 8b 44 24 50       	mov    rax,QWORD PTR [rsp+0x50]
                    if (begin_addr == 0 and end_addr == 0) {
  2280eb:	48 89 c1             	mov    rcx,rax
  2280ee:	48 09 d9             	or     rcx,rbx
  2280f1:	48 8b 94 24 a8 00 00 	mov    rdx,QWORD PTR [rsp+0xa8]
  2280f8:	00 
  2280f9:	c5 7e 6f a4 24 c0 01 	vmovdqu ymm12,YMMWORD PTR [rsp+0x1c0]
  228100:	00 00 
  228102:	c5 7e 6f ac 24 40 03 	vmovdqu ymm13,YMMWORD PTR [rsp+0x340]
  228109:	00 00 
  22810b:	74 63                	je     228170 <printSourceAtAddressLinux+0x4e0>
                    if (begin_addr == @maxValue(usize)) {
  22810d:	48 83 fb ff          	cmp    rbx,0xffffffffffffffff
  228111:	74 0e                	je     228121 <printSourceAtAddressLinux+0x491>
                    if (target_address >= begin_addr and target_address < end_addr) {
  228113:	48 39 d3             	cmp    rbx,rdx
  228116:	77 09                	ja     228121 <printSourceAtAddressLinux+0x491>
  228118:	48 39 d0             	cmp    rax,rdx
  22811b:	0f 87 70 02 00 00    	ja     228391 <printSourceAtAddressLinux+0x701>
            try self.readNoEof(bytes[0..]);
  228121:	48 89 ac 24 30 01 00 	mov    QWORD PTR [rsp+0x130],rbp
  228128:	00 
  228129:	48 c7 84 24 38 01 00 	mov    QWORD PTR [rsp+0x138],0x8
  228130:	00 08 00 00 00 
            return self.readFn(self, buffer);
  228135:	4c 89 ff             	mov    rdi,r15
  228138:	48 8d b4 24 30 02 00 	lea    rsi,[rsp+0x230]
  22813f:	00 
  228140:	48 8d 94 24 30 01 00 	lea    rdx,[rsp+0x130]
  228147:	00 
  228148:	c5 f8 77             	vzeroupper 
  22814b:	ff 94 24 30 02 00 00 	call   QWORD PTR [rsp+0x230]
  228152:	48 8b 84 24 b8 00 00 	mov    rax,QWORD PTR [rsp+0xb8]
  228159:	00 
            const amt_read = try self.read(buf);
  22815a:	66 83 bc 24 b0 00 00 	cmp    WORD PTR [rsp+0xb0],0x0
  228161:	00 00 
  228163:	0f 84 17 ff ff ff    	je     228080 <printSourceAtAddressLinux+0x3f0>
  228169:	eb 17                	jmp    228182 <printSourceAtAddressLinux+0x4f2>
  22816b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
    for (st.compile_unit_list.toSlice()) |*compile_unit| {
  228170:	49 83 c5 01          	add    r13,0x1
  228174:	4c 3b ac 24 98 01 00 	cmp    r13,QWORD PTR [rsp+0x198]
  22817b:	00 
  22817c:	0f 82 be fb ff ff    	jb     227d40 <printSourceAtAddressLinux+0xb0>
  228182:	48 8b 6c 24 08       	mov    rbp,QWORD PTR [rsp+0x8]
            return std.fmt.format(self, Error, self.writeFn, format, args);
  228187:	4c 8b 75 00          	mov    r14,QWORD PTR [rbp+0x0]
        if (tty_color) {
  22818b:	f6 84 24 2c 01 00 00 	test   BYTE PTR [rsp+0x12c],0x1
  228192:	01 
  228193:	74 78                	je     22820d <printSourceAtAddressLinux+0x57d>
                        try output(context, fmt[start_index..i]);
  228195:	48 8d 35 14 7d 02 00 	lea    rsi,[rip+0x27d14]        # 24feb0 <__unnamed_69>
  22819c:	48 89 ef             	mov    rdi,rbp
  22819f:	c5 f8 77             	vzeroupper 
  2281a2:	41 ff d6             	call   r14
  2281a5:	41 89 c5             	mov    r13d,eax
  2281a8:	66 45 85 ed          	test   r13w,r13w
  2281ac:	0f 85 69 0a 00 00    	jne    228c1b <printSourceAtAddressLinux+0xf8b>
    var buf: [max_int_digits - 1]u8 = undefined;
  2281b2:	c5 fc 10 05 35 15 fe 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffe1535]        # 2096ef <__unnamed_28+0x1f>
  2281b9:	ff 
  2281ba:	c5 fc 11 84 24 cf 00 	vmovups YMMWORD PTR [rsp+0xcf],ymm0
  2281c1:	00 00 
  2281c3:	c5 fe 6f 05 05 15 fe 	vmovdqu ymm0,YMMWORD PTR [rip+0xfffffffffffe1505]        # 2096d0 <__unnamed_28>
  2281ca:	ff 
  2281cb:	c5 fe 7f 84 24 b0 00 	vmovdqu YMMWORD PTR [rsp+0xb0],ymm0
  2281d2:	00 00 
  2281d4:	48 8b b4 24 a8 00 00 	mov    rsi,QWORD PTR [rsp+0xa8]
  2281db:	00 
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  2281dc:	89 f0                	mov    eax,esi
  2281de:	24 0f                	and    al,0xf
        0...9 => digit + '0',
  2281e0:	b1 30                	mov    cl,0x30
  2281e2:	3c 0a                	cmp    al,0xa
  2281e4:	72 02                	jb     2281e8 <printSourceAtAddressLinux+0x558>
  2281e6:	b1 57                	mov    cl,0x57
  2281e8:	00 c1                	add    cl,al
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  2281ea:	88 8c 24 ef 00 00 00 	mov    BYTE PTR [rsp+0xef],cl
        if (a == 0) break;
  2281f1:	48 83 fe 10          	cmp    rsi,0x10
  2281f5:	0f 83 8a 00 00 00    	jae    228285 <printSourceAtAddressLinux+0x5f5>
  2281fb:	48 8d 8c 24 ef 00 00 	lea    rcx,[rsp+0xef]
  228202:	00 
  228203:	b8 40 00 00 00       	mov    eax,0x40
  228208:	e9 b9 00 00 00       	jmp    2282c6 <printSourceAtAddressLinux+0x636>
                        try output(context, fmt[start_index..i]);
  22820d:	48 8d 35 bc 7c 02 00 	lea    rsi,[rip+0x27cbc]        # 24fed0 <__unnamed_70>
  228214:	48 89 ef             	mov    rdi,rbp
  228217:	c5 f8 77             	vzeroupper 
  22821a:	41 ff d6             	call   r14
  22821d:	41 89 c5             	mov    r13d,eax
  228220:	66 45 85 ed          	test   r13w,r13w
  228224:	0f 85 f1 09 00 00    	jne    228c1b <printSourceAtAddressLinux+0xf8b>
    var buf: [max_int_digits - 1]u8 = undefined;
  22822a:	c5 fc 10 05 bd 14 fe 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffe14bd]        # 2096ef <__unnamed_28+0x1f>
  228231:	ff 
  228232:	c5 fc 11 84 24 cf 00 	vmovups YMMWORD PTR [rsp+0xcf],ymm0
  228239:	00 00 
  22823b:	c5 fe 6f 05 8d 14 fe 	vmovdqu ymm0,YMMWORD PTR [rip+0xfffffffffffe148d]        # 2096d0 <__unnamed_28>
  228242:	ff 
  228243:	c5 fe 7f 84 24 b0 00 	vmovdqu YMMWORD PTR [rsp+0xb0],ymm0
  22824a:	00 00 
  22824c:	48 8b b4 24 a8 00 00 	mov    rsi,QWORD PTR [rsp+0xa8]
  228253:	00 
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  228254:	89 f0                	mov    eax,esi
  228256:	24 0f                	and    al,0xf
        0...9 => digit + '0',
  228258:	b1 30                	mov    cl,0x30
  22825a:	3c 0a                	cmp    al,0xa
  22825c:	72 02                	jb     228260 <printSourceAtAddressLinux+0x5d0>
  22825e:	b1 57                	mov    cl,0x57
  228260:	00 c1                	add    cl,al
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  228262:	88 8c 24 ef 00 00 00 	mov    BYTE PTR [rsp+0xef],cl
        if (a == 0) break;
  228269:	48 83 fe 10          	cmp    rsi,0x10
  22826d:	0f 83 92 00 00 00    	jae    228305 <printSourceAtAddressLinux+0x675>
  228273:	48 8d 8c 24 ef 00 00 	lea    rcx,[rsp+0xef]
  22827a:	00 
  22827b:	b8 40 00 00 00       	mov    eax,0x40
  228280:	e9 c1 00 00 00       	jmp    228346 <printSourceAtAddressLinux+0x6b6>
  228285:	b8 40 00 00 00       	mov    eax,0x40
        a /= base;
  22828a:	48 89 f1             	mov    rcx,rsi
  22828d:	0f 1f 00             	nop    DWORD PTR [rax]
  228290:	48 c1 e9 04          	shr    rcx,0x4
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  228294:	89 ca                	mov    edx,ecx
  228296:	80 e2 0f             	and    dl,0xf
        0...9 => digit + '0',
  228299:	b3 30                	mov    bl,0x30
  22829b:	80 fa 0a             	cmp    dl,0xa
  22829e:	72 02                	jb     2282a2 <printSourceAtAddressLinux+0x612>
  2282a0:	b3 57                	mov    bl,0x57
  2282a2:	00 d3                	add    bl,dl
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  2282a4:	88 9c 04 ae 00 00 00 	mov    BYTE PTR [rsp+rax*1+0xae],bl
        if (a == 0) break;
  2282ab:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  2282af:	48 81 fe ff 00 00 00 	cmp    rsi,0xff
  2282b6:	48 89 ce             	mov    rsi,rcx
  2282b9:	77 d5                	ja     228290 <printSourceAtAddressLinux+0x600>
        const padded_buf = buf[index - padding ..];
  2282bb:	48 8d 0c 04          	lea    rcx,[rsp+rax*1]
  2282bf:	48 81 c1 af 00 00 00 	add    rcx,0xaf
  2282c6:	ba 41 00 00 00       	mov    edx,0x41
  2282cb:	48 29 c2             	sub    rdx,rax
  2282ce:	48 89 8c 24 30 01 00 	mov    QWORD PTR [rsp+0x130],rcx
  2282d5:	00 
  2282d6:	48 89 94 24 38 01 00 	mov    QWORD PTR [rsp+0x138],rdx
  2282dd:	00 
  2282de:	48 8d b4 24 30 01 00 	lea    rsi,[rsp+0x130]
  2282e5:	00 
        return output(context, padded_buf);
  2282e6:	48 89 ef             	mov    rdi,rbp
  2282e9:	c5 f8 77             	vzeroupper 
  2282ec:	41 ff d6             	call   r14
  2282ef:	41 89 c5             	mov    r13d,eax
                    try formatType(args[next_arg], fmt[s..i], context, Errors, output);
  2282f2:	66 45 85 ed          	test   r13w,r13w
  2282f6:	0f 85 1f 09 00 00    	jne    228c1b <printSourceAtAddressLinux+0xf8b>
        try output(context, fmt[start_index..]);
  2282fc:	48 8d 35 bd 7b 02 00 	lea    rsi,[rip+0x27bbd]        # 24fec0 <__unnamed_71>
  228303:	eb 7e                	jmp    228383 <printSourceAtAddressLinux+0x6f3>
  228305:	b8 40 00 00 00       	mov    eax,0x40
        a /= base;
  22830a:	48 89 f1             	mov    rcx,rsi
  22830d:	0f 1f 00             	nop    DWORD PTR [rax]
  228310:	48 c1 e9 04          	shr    rcx,0x4
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  228314:	89 ca                	mov    edx,ecx
  228316:	80 e2 0f             	and    dl,0xf
        0...9 => digit + '0',
  228319:	b3 30                	mov    bl,0x30
  22831b:	80 fa 0a             	cmp    dl,0xa
  22831e:	72 02                	jb     228322 <printSourceAtAddressLinux+0x692>
  228320:	b3 57                	mov    bl,0x57
  228322:	00 d3                	add    bl,dl
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  228324:	88 9c 04 ae 00 00 00 	mov    BYTE PTR [rsp+rax*1+0xae],bl
        if (a == 0) break;
  22832b:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  22832f:	48 81 fe ff 00 00 00 	cmp    rsi,0xff
  228336:	48 89 ce             	mov    rsi,rcx
  228339:	77 d5                	ja     228310 <printSourceAtAddressLinux+0x680>
        const padded_buf = buf[index - padding ..];
  22833b:	48 8d 0c 04          	lea    rcx,[rsp+rax*1]
  22833f:	48 81 c1 af 00 00 00 	add    rcx,0xaf
  228346:	ba 41 00 00 00       	mov    edx,0x41
  22834b:	48 29 c2             	sub    rdx,rax
  22834e:	48 89 8c 24 30 01 00 	mov    QWORD PTR [rsp+0x130],rcx
  228355:	00 
  228356:	48 89 94 24 38 01 00 	mov    QWORD PTR [rsp+0x138],rdx
  22835d:	00 
  22835e:	48 8d b4 24 30 01 00 	lea    rsi,[rsp+0x130]
  228365:	00 
        return output(context, padded_buf);
  228366:	48 89 ef             	mov    rdi,rbp
  228369:	c5 f8 77             	vzeroupper 
  22836c:	41 ff d6             	call   r14
  22836f:	41 89 c5             	mov    r13d,eax
                    try formatType(args[next_arg], fmt[s..i], context, Errors, output);
  228372:	66 45 85 ed          	test   r13w,r13w
  228376:	0f 85 9f 08 00 00    	jne    228c1b <printSourceAtAddressLinux+0xf8b>
        try output(context, fmt[start_index..]);
  22837c:	48 8d 35 5d 7b 02 00 	lea    rsi,[rip+0x27b5d]        # 24fee0 <__unnamed_72>
  228383:	48 89 ef             	mov    rdi,rbp
  228386:	41 ff d6             	call   r14
  228389:	41 89 c5             	mov    r13d,eax
  22838c:	e9 8a 08 00 00       	jmp    228c1b <printSourceAtAddressLinux+0xf8b>
  228391:	48 8b 9c 24 68 01 00 	mov    rbx,QWORD PTR [rsp+0x168]
  228398:	00 
  228399:	eb 08                	jmp    2283a3 <printSourceAtAddressLinux+0x713>
    const compile_unit_name = try compile_unit.die.getAttrString(debug_info, DW.AT_name);
  22839b:	4b 8d 1c 26          	lea    rbx,[r14+r12*1]
  22839f:	48 83 c3 08          	add    rbx,0x8
  2283a3:	48 8b 03             	mov    rax,QWORD PTR [rbx]
            return self.items[0..self.len];
  2283a6:	48 8b 48 20          	mov    rcx,QWORD PTR [rax+0x20]
        for (self.attrs.toSliceConst()) |*attr| {
  2283aa:	48 85 c9             	test   rcx,rcx
  2283ad:	48 8b 6c 24 08       	mov    rbp,QWORD PTR [rsp+0x8]
  2283b2:	74 1f                	je     2283d3 <printSourceAtAddressLinux+0x743>
  2283b4:	48 8b 40 10          	mov    rax,QWORD PTR [rax+0x10]
  2283b8:	31 d2                	xor    edx,edx
  2283ba:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
            if (attr.id == id) return &attr.value;
  2283c0:	48 83 38 03          	cmp    QWORD PTR [rax],0x3
  2283c4:	74 37                	je     2283fd <printSourceAtAddressLinux+0x76d>
        for (self.attrs.toSliceConst()) |*attr| {
  2283c6:	48 83 c2 01          	add    rdx,0x1
  2283ca:	48 83 c0 28          	add    rax,0x28
  2283ce:	48 39 ca             	cmp    rdx,rcx
  2283d1:	72 ed                	jb     2283c0 <printSourceAtAddressLinux+0x730>
        const form_value = self.getAttr(id) orelse return error.MissingDebugInfo;
  2283d3:	48 8b 05 6e 00 fe ff 	mov    rax,QWORD PTR [rip+0xfffffffffffe006e]        # 208448 <__unnamed_73+0x10>
  2283da:	48 89 84 24 6e 02 00 	mov    QWORD PTR [rsp+0x26e],rax
  2283e1:	00 
  2283e2:	c5 f8 10 05 50 00 fe 	vmovups xmm0,XMMWORD PTR [rip+0xfffffffffffe0050]        # 20843a <__unnamed_73+0x2>
  2283e9:	ff 
  2283ea:	c5 f8 29 84 24 60 02 	vmovaps XMMWORD PTR [rsp+0x260],xmm0
  2283f1:	00 00 
  2283f3:	66 41 bd 28 00       	mov    r13w,0x28
  2283f8:	e9 1e 08 00 00       	jmp    228c1b <printSourceAtAddressLinux+0xf8b>
  2283fd:	8a 48 20             	mov    cl,BYTE PTR [rax+0x20]
  228400:	80 f9 0a             	cmp    cl,0xa
        return switch (form_value.*) {
  228403:	74 2a                	je     22842f <printSourceAtAddressLinux+0x79f>
  228405:	80 f9 09             	cmp    cl,0x9
  228408:	75 7b                	jne    228485 <printSourceAtAddressLinux+0x7f5>
            FormValue.String => |value| value,
  22840a:	66 c7 84 24 30 01 00 	mov    WORD PTR [rsp+0x130],0x0
  228411:	00 00 00 
  228414:	c5 fa 6f 40 08       	vmovdqu xmm0,XMMWORD PTR [rax+0x8]
  228419:	c5 fa 7f 84 24 38 01 	vmovdqu XMMWORD PTR [rsp+0x138],xmm0
  228420:	00 00 
        return switch (form_value.*) {
  228422:	4c 8d bc 24 30 01 00 	lea    r15,[rsp+0x130]
  228429:	00 
  22842a:	e9 8d 00 00 00       	jmp    2284bc <printSourceAtAddressLinux+0x82c>
            FormValue.StrPtr => |offset| getString(st, offset),
  22842f:	48 8b 70 08          	mov    rsi,QWORD PTR [rax+0x8]
  228433:	48 8b 4c 24 68       	mov    rcx,QWORD PTR [rsp+0x68]
    const pos = st.debug_str.offset + offset;
  228438:	48 8b 41 70          	mov    rax,QWORD PTR [rcx+0x70]
  22843c:	48 03 70 18          	add    rsi,QWORD PTR [rax+0x18]
  228440:	78 4c                	js     22848e <printSourceAtAddressLinux+0x7fe>
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  228442:	48 63 39             	movsxd rdi,DWORD PTR [rcx]
  228445:	45 31 c0             	xor    r8d,r8d
  228448:	b8 08 00 00 00       	mov    eax,0x8
  22844d:	31 d2                	xor    edx,edx
  22844f:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  228451:	48 89 c1             	mov    rcx,rax
  228454:	48 f7 d9             	neg    rcx
  228457:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  22845d:	49 0f 46 c8          	cmovbe rcx,r8
  228461:	66 b8 03 00          	mov    ax,0x3
  228465:	48 83 f9 1d          	cmp    rcx,0x1d
  228469:	0f 87 10 01 00 00    	ja     22857f <printSourceAtAddressLinux+0x8ef>
  22846f:	48 8d 15 7a 8e fd ff 	lea    rdx,[rip+0xfffffffffffd8e7a]        # 2012f0 <__unnamed_621+0x638>
  228476:	48 63 0c 8a          	movsxd rcx,DWORD PTR [rdx+rcx*4]
  22847a:	48 01 d1             	add    rcx,rdx
  22847d:	ff e1                	jmp    rcx
  22847f:	66 b8 27 00          	mov    ax,0x27
  228483:	eb 0d                	jmp    228492 <printSourceAtAddressLinux+0x802>
  228485:	4c 8d 3d c4 ff fd ff 	lea    r15,[rip+0xfffffffffffdffc4]        # 208450 <__unnamed_74>
  22848c:	eb 2e                	jmp    2284bc <printSourceAtAddressLinux+0x82c>
  22848e:	66 b8 04 00          	mov    ax,0x4
    try st.self_exe_file.seekTo(pos);
  228492:	66 89 84 24 b0 00 00 	mov    WORD PTR [rsp+0xb0],ax
  228499:	00 
  22849a:	c5 fa 6f 84 24 28 02 	vmovdqu xmm0,XMMWORD PTR [rsp+0x228]
  2284a1:	00 00 
  2284a3:	c5 fa 7f 84 24 b2 00 	vmovdqu XMMWORD PTR [rsp+0xb2],xmm0
  2284aa:	00 00 
  2284ac:	48 8b 84 24 36 02 00 	mov    rax,QWORD PTR [rsp+0x236]
  2284b3:	00 
  2284b4:	48 89 84 24 c0 00 00 	mov    QWORD PTR [rsp+0xc0],rax
  2284bb:	00 
        return switch (form_value.*) {
  2284bc:	45 0f b7 2f          	movzx  r13d,WORD PTR [r15]
  2284c0:	49 8b 47 10          	mov    rax,QWORD PTR [r15+0x10]
  2284c4:	48 89 84 24 6e 02 00 	mov    QWORD PTR [rsp+0x26e],rax
  2284cb:	00 
  2284cc:	c4 c1 78 10 47 02    	vmovups xmm0,XMMWORD PTR [r15+0x2]
  2284d2:	c5 f8 29 84 24 60 02 	vmovaps XMMWORD PTR [rsp+0x260],xmm0
  2284d9:	00 00 
    const compile_unit_name = try compile_unit.die.getAttrString(debug_info, DW.AT_name);
  2284db:	66 45 85 ed          	test   r13w,r13w
  2284df:	0f 85 36 07 00 00    	jne    228c1b <printSourceAtAddressLinux+0xf8b>
  2284e5:	c5 fa 6f 84 24 66 02 	vmovdqu xmm0,XMMWORD PTR [rsp+0x266]
  2284ec:	00 00 
  2284ee:	c5 f9 7f 84 24 10 02 	vmovdqa XMMWORD PTR [rsp+0x210],xmm0
  2284f5:	00 00 
    const compile_unit_cwd = try compile_unit.die.getAttrString(di, DW.AT_comp_dir);
  2284f7:	48 8b 03             	mov    rax,QWORD PTR [rbx]
  2284fa:	48 8b 48 20          	mov    rcx,QWORD PTR [rax+0x20]
        for (self.attrs.toSliceConst()) |*attr| {
  2284fe:	48 85 c9             	test   rcx,rcx
  228501:	48 8b 94 24 a8 00 00 	mov    rdx,QWORD PTR [rsp+0xa8]
  228508:	00 
  228509:	74 1d                	je     228528 <printSourceAtAddressLinux+0x898>
  22850b:	4c 8d 7a ff          	lea    r15,[rdx-0x1]
  22850f:	48 8b 40 10          	mov    rax,QWORD PTR [rax+0x10]
  228513:	31 d2                	xor    edx,edx
            if (attr.id == id) return &attr.value;
  228515:	48 83 38 1b          	cmp    QWORD PTR [rax],0x1b
  228519:	74 37                	je     228552 <printSourceAtAddressLinux+0x8c2>
        for (self.attrs.toSliceConst()) |*attr| {
  22851b:	48 83 c2 01          	add    rdx,0x1
  22851f:	48 83 c0 28          	add    rax,0x28
  228523:	48 39 ca             	cmp    rdx,rcx
  228526:	72 ed                	jb     228515 <printSourceAtAddressLinux+0x885>
        const form_value = self.getAttr(id) orelse return error.MissingDebugInfo;
  228528:	48 8b 05 19 ff fd ff 	mov    rax,QWORD PTR [rip+0xfffffffffffdff19]        # 208448 <__unnamed_73+0x10>
  22852f:	48 89 84 24 8e 02 00 	mov    QWORD PTR [rsp+0x28e],rax
  228536:	00 
  228537:	c5 f8 10 05 fb fe fd 	vmovups xmm0,XMMWORD PTR [rip+0xfffffffffffdfefb]        # 20843a <__unnamed_73+0x2>
  22853e:	ff 
  22853f:	c5 f8 29 84 24 80 02 	vmovaps XMMWORD PTR [rsp+0x280],xmm0
  228546:	00 00 
  228548:	66 41 bd 28 00       	mov    r13w,0x28
  22854d:	e9 25 01 00 00       	jmp    228677 <printSourceAtAddressLinux+0x9e7>
  228552:	8a 48 20             	mov    cl,BYTE PTR [rax+0x20]
  228555:	80 f9 0a             	cmp    cl,0xa
        return switch (form_value.*) {
  228558:	74 34                	je     22858e <printSourceAtAddressLinux+0x8fe>
  22855a:	80 f9 09             	cmp    cl,0x9
  22855d:	0f 85 84 00 00 00    	jne    2285e7 <printSourceAtAddressLinux+0x957>
            FormValue.String => |value| value,
  228563:	66 c7 44 24 10 00 00 	mov    WORD PTR [rsp+0x10],0x0
  22856a:	c5 fa 6f 40 08       	vmovdqu xmm0,XMMWORD PTR [rax+0x8]
  22856f:	c5 fa 7f 44 24 18    	vmovdqu XMMWORD PTR [rsp+0x18],xmm0
  228575:	48 8d 5c 24 10       	lea    rbx,[rsp+0x10]
  22857a:	e9 d0 00 00 00       	jmp    22864f <printSourceAtAddressLinux+0x9bf>
  22857f:	48 83 f9 4b          	cmp    rcx,0x4b
  228583:	0f 85 09 ff ff ff    	jne    228492 <printSourceAtAddressLinux+0x802>
  228589:	e9 f1 fe ff ff       	jmp    22847f <printSourceAtAddressLinux+0x7ef>
            FormValue.StrPtr => |offset| getString(st, offset),
  22858e:	48 8b 70 08          	mov    rsi,QWORD PTR [rax+0x8]
  228592:	48 8b 4c 24 68       	mov    rcx,QWORD PTR [rsp+0x68]
    const pos = st.debug_str.offset + offset;
  228597:	48 8b 41 70          	mov    rax,QWORD PTR [rcx+0x70]
  22859b:	48 03 70 18          	add    rsi,QWORD PTR [rax+0x18]
  22859f:	0f 88 86 00 00 00    	js     22862b <printSourceAtAddressLinux+0x99b>
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  2285a5:	48 63 39             	movsxd rdi,DWORD PTR [rcx]
  2285a8:	31 db                	xor    ebx,ebx
  2285aa:	b8 08 00 00 00       	mov    eax,0x8
  2285af:	31 d2                	xor    edx,edx
  2285b1:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  2285b3:	48 89 c1             	mov    rcx,rax
  2285b6:	48 f7 d9             	neg    rcx
  2285b9:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  2285bf:	48 0f 46 cb          	cmovbe rcx,rbx
  2285c3:	66 b8 03 00          	mov    ax,0x3
  2285c7:	48 83 f9 1d          	cmp    rcx,0x1d
  2285cb:	0f 87 2d 05 00 00    	ja     228afe <printSourceAtAddressLinux+0xe6e>
  2285d1:	48 8d 15 90 8d fd ff 	lea    rdx,[rip+0xfffffffffffd8d90]        # 201368 <__unnamed_621+0x6b0>
  2285d8:	48 63 0c 8a          	movsxd rcx,DWORD PTR [rdx+rcx*4]
  2285dc:	48 01 d1             	add    rcx,rdx
  2285df:	ff e1                	jmp    rcx
  2285e1:	66 b8 27 00          	mov    ax,0x27
  2285e5:	eb 48                	jmp    22862f <printSourceAtAddressLinux+0x99f>
  2285e7:	48 8d 1d 62 fe fd ff 	lea    rbx,[rip+0xfffffffffffdfe62]        # 208450 <__unnamed_74>
  2285ee:	eb 5f                	jmp    22864f <printSourceAtAddressLinux+0x9bf>
  2285f0:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
            var in_file_stream = io.FileInStream.init(&self.self_exe_file);
  2285f5:	48 89 84 24 e8 02 00 	mov    QWORD PTR [rsp+0x2e8],rax
  2285fc:	00 
  2285fd:	48 8d 94 24 f0 02 00 	lea    rdx,[rsp+0x2f0]
  228604:	00 
  228605:	48 8d 0d 54 bb ff ff 	lea    rcx,[rip+0xffffffffffffbb54]        # 224160 <FileInStream_readFn>
  22860c:	48 89 8c 24 f0 02 00 	mov    QWORD PTR [rsp+0x2f0],rcx
  228613:	00 
  228614:	48 8b b0 a0 00 00 00 	mov    rsi,QWORD PTR [rax+0xa0]
            return readStringRaw(self.allocator(), in_stream);
  22861b:	4c 89 ff             	mov    rdi,r15
  22861e:	c5 f8 77             	vzeroupper 
  228621:	e8 0a f2 ff ff       	call   227830 <readStringRaw>
  228626:	e9 91 fe ff ff       	jmp    2284bc <printSourceAtAddressLinux+0x82c>
  22862b:	66 b8 04 00          	mov    ax,0x4
    try st.self_exe_file.seekTo(pos);
  22862f:	66 89 44 24 28       	mov    WORD PTR [rsp+0x28],ax
  228634:	c5 fa 6f 44 24 50    	vmovdqu xmm0,XMMWORD PTR [rsp+0x50]
  22863a:	c5 fa 7f 44 24 2a    	vmovdqu XMMWORD PTR [rsp+0x2a],xmm0
  228640:	48 8b 44 24 5e       	mov    rax,QWORD PTR [rsp+0x5e]
  228645:	48 89 44 24 38       	mov    QWORD PTR [rsp+0x38],rax
  22864a:	48 8d 5c 24 28       	lea    rbx,[rsp+0x28]
        return switch (form_value.*) {
  22864f:	44 0f b7 2b          	movzx  r13d,WORD PTR [rbx]
  228653:	48 8b 43 10          	mov    rax,QWORD PTR [rbx+0x10]
  228657:	48 89 84 24 8e 02 00 	mov    QWORD PTR [rsp+0x28e],rax
  22865e:	00 
  22865f:	c5 f8 10 43 02       	vmovups xmm0,XMMWORD PTR [rbx+0x2]
  228664:	c5 f8 29 84 24 80 02 	vmovaps XMMWORD PTR [rsp+0x280],xmm0
  22866b:	00 00 
    const compile_unit_cwd = try compile_unit.die.getAttrString(di, DW.AT_comp_dir);
  22866d:	66 45 85 ed          	test   r13w,r13w
  228671:	0f 84 b9 00 00 00    	je     228730 <printSourceAtAddressLinux+0xaa0>
  228677:	c5 fc 10 84 24 ba 0b 	vmovups ymm0,YMMWORD PTR [rsp+0xbba]
  22867e:	00 00 
  228680:	c5 fe 6f 8c 24 c8 0b 	vmovdqu ymm1,YMMWORD PTR [rsp+0xbc8]
  228687:	00 00 
  228689:	c5 fe 7f 4c 24 7e    	vmovdqu YMMWORD PTR [rsp+0x7e],ymm1
  22868f:	c5 fc 11 44 24 70    	vmovups YMMWORD PTR [rsp+0x70],ymm0
    } else |err| switch (err) {
  228695:	44 89 e8             	mov    eax,r13d
  228698:	25 fe ff 00 00       	and    eax,0xfffe
  22869d:	83 f8 28             	cmp    eax,0x28
  2286a0:	0f 85 75 05 00 00    	jne    228c1b <printSourceAtAddressLinux+0xf8b>
  2286a6:	4c 8b 75 00          	mov    r14,QWORD PTR [rbp+0x0]
            if (tty_color) {
  2286aa:	f6 84 24 2c 01 00 00 	test   BYTE PTR [rsp+0x12c],0x1
  2286b1:	01 
  2286b2:	0f 84 40 02 00 00    	je     2288f8 <printSourceAtAddressLinux+0xc68>
                        try output(context, fmt[start_index..i]);
  2286b8:	48 8d 35 21 79 02 00 	lea    rsi,[rip+0x27921]        # 24ffe0 <__unnamed_75>
  2286bf:	48 89 ef             	mov    rdi,rbp
  2286c2:	c5 f8 77             	vzeroupper 
  2286c5:	41 ff d6             	call   r14
  2286c8:	41 89 c5             	mov    r13d,eax
  2286cb:	66 45 85 ed          	test   r13w,r13w
  2286cf:	0f 85 46 05 00 00    	jne    228c1b <printSourceAtAddressLinux+0xf8b>
    var buf: [max_int_digits - 1]u8 = undefined;
  2286d5:	c5 fc 10 05 12 10 fe 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffe1012]        # 2096ef <__unnamed_28+0x1f>
  2286dc:	ff 
  2286dd:	c5 fc 11 84 24 cf 00 	vmovups YMMWORD PTR [rsp+0xcf],ymm0
  2286e4:	00 00 
  2286e6:	c5 fe 6f 05 e2 0f fe 	vmovdqu ymm0,YMMWORD PTR [rip+0xfffffffffffe0fe2]        # 2096d0 <__unnamed_28>
  2286ed:	ff 
  2286ee:	c5 fe 7f 84 24 b0 00 	vmovdqu YMMWORD PTR [rsp+0xb0],ymm0
  2286f5:	00 00 
  2286f7:	48 8b b4 24 a8 00 00 	mov    rsi,QWORD PTR [rsp+0xa8]
  2286fe:	00 
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  2286ff:	89 f0                	mov    eax,esi
  228701:	24 0f                	and    al,0xf
        0...9 => digit + '0',
  228703:	b1 30                	mov    cl,0x30
  228705:	3c 0a                	cmp    al,0xa
  228707:	72 02                	jb     22870b <printSourceAtAddressLinux+0xa7b>
  228709:	b1 57                	mov    cl,0x57
  22870b:	00 c1                	add    cl,al
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  22870d:	88 8c 24 ef 00 00 00 	mov    BYTE PTR [rsp+0xef],cl
        if (a == 0) break;
  228714:	48 83 fe 10          	cmp    rsi,0x10
  228718:	0f 83 52 02 00 00    	jae    228970 <printSourceAtAddressLinux+0xce0>
  22871e:	48 8d 8c 24 ef 00 00 	lea    rcx,[rsp+0xef]
  228725:	00 
  228726:	b8 40 00 00 00       	mov    eax,0x40
  22872b:	e9 7e 02 00 00       	jmp    2289ae <printSourceAtAddressLinux+0xd1e>
  228730:	4c 89 bc 24 c0 01 00 	mov    QWORD PTR [rsp+0x1c0],r15
  228737:	00 
    const compile_unit_cwd = try compile_unit.die.getAttrString(di, DW.AT_comp_dir);
  228738:	c5 fa 6f 84 24 86 02 	vmovdqu xmm0,XMMWORD PTR [rsp+0x286]
  22873f:	00 00 
  228741:	c5 f9 7f 84 24 80 03 	vmovdqa XMMWORD PTR [rsp+0x380],xmm0
  228748:	00 00 
  22874a:	48 8b 4c 24 68       	mov    rcx,QWORD PTR [rsp+0x68]
    const debug_line_end = di.debug_line.offset + di.debug_line.size;
  22874f:	48 8b 41 78          	mov    rax,QWORD PTR [rcx+0x78]
  228753:	48 8b 58 18          	mov    rbx,QWORD PTR [rax+0x18]
  228757:	4c 8b 78 20          	mov    r15,QWORD PTR [rax+0x20]
    var in_file_stream = io.FileInStream.init(in_file);
  22875b:	48 89 4c 24 40       	mov    QWORD PTR [rsp+0x40],rcx
  228760:	48 8d 05 f9 b9 ff ff 	lea    rax,[rip+0xffffffffffffb9f9]        # 224160 <FileInStream_readFn>
  228767:	48 89 44 24 48       	mov    QWORD PTR [rsp+0x48],rax
    while (this_offset < debug_line_end) : (this_index += 1) {
  22876c:	4d 85 ff             	test   r15,r15
  22876f:	0f 84 50 01 00 00    	je     2288c5 <printSourceAtAddressLinux+0xc35>
  228775:	49 01 df             	add    r15,rbx
  228778:	4d 01 f4             	add    r12,r14
  22877b:	49 83 c4 10          	add    r12,0x10
  22877f:	48 c7 c5 ff ff ff ff 	mov    rbp,0xffffffffffffffff
  228786:	48 85 db             	test   rbx,rbx
  228789:	0f 88 c8 03 00 00    	js     228b57 <printSourceAtAddressLinux+0xec7>
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  22878f:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  228794:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  228797:	b8 08 00 00 00       	mov    eax,0x8
  22879c:	31 d2                	xor    edx,edx
  22879e:	48 89 de             	mov    rsi,rbx
  2287a1:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  2287a3:	48 89 c1             	mov    rcx,rax
  2287a6:	48 f7 d9             	neg    rcx
  2287a9:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  2287af:	b8 00 00 00 00       	mov    eax,0x0
  2287b4:	48 0f 46 c8          	cmovbe rcx,rax
  2287b8:	48 85 c9             	test   rcx,rcx
  2287bb:	0f 85 9d 03 00 00    	jne    228b5e <printSourceAtAddressLinux+0xece>
            try self.readNoEof(bytes[0..]);
  2287c1:	48 8d 44 24 50       	lea    rax,[rsp+0x50]
  2287c6:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  2287cb:	48 c7 44 24 18 04 00 	mov    QWORD PTR [rsp+0x18],0x4
  2287d2:	00 00 
            return self.readFn(self, buffer);
  2287d4:	48 8d 7c 24 28       	lea    rdi,[rsp+0x28]
  2287d9:	48 8d 74 24 48       	lea    rsi,[rsp+0x48]
  2287de:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  2287e3:	c5 f8 77             	vzeroupper 
  2287e6:	ff 54 24 48          	call   QWORD PTR [rsp+0x48]
  2287ea:	44 0f b7 6c 24 28    	movzx  r13d,WORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  2287f0:	66 45 85 ed          	test   r13w,r13w
  2287f4:	0f 85 3e 04 00 00    	jne    228c38 <printSourceAtAddressLinux+0xfa8>
  2287fa:	48 8b 44 24 30       	mov    rax,QWORD PTR [rsp+0x30]
            if (amt_read < buf.len) return error.EndOfStream;
  2287ff:	48 3b 44 24 18       	cmp    rax,QWORD PTR [rsp+0x18]
  228804:	0f 82 03 03 00 00    	jb     228b0d <printSourceAtAddressLinux+0xe7d>
  22880a:	0f b6 44 24 50       	movzx  eax,BYTE PTR [rsp+0x50]
  22880f:	0f b6 4c 24 51       	movzx  ecx,BYTE PTR [rsp+0x51]
  228814:	48 c1 e1 08          	shl    rcx,0x8
  228818:	48 09 c1             	or     rcx,rax
  22881b:	0f b6 54 24 52       	movzx  edx,BYTE PTR [rsp+0x52]
  228820:	48 c1 e2 10          	shl    rdx,0x10
  228824:	48 09 ca             	or     rdx,rcx
  228827:	0f b6 44 24 53       	movzx  eax,BYTE PTR [rsp+0x53]
  22882c:	48 c1 e0 18          	shl    rax,0x18
  228830:	48 09 d0             	or     rax,rdx
    is_64.* = (first_32_bits == 0xffffffff);
  228833:	83 f8 ff             	cmp    eax,0xffffffff
    if (is_64.*) {
  228836:	74 13                	je     22884b <printSourceAtAddressLinux+0xbbb>
        if (first_32_bits >= 0xfffffff0) return error.InvalidDebugInfo;
  228838:	83 f8 ef             	cmp    eax,0xffffffef
  22883b:	0f 87 f2 03 00 00    	ja     228c33 <printSourceAtAddressLinux+0xfa3>
  228841:	45 31 f6             	xor    r14d,r14d
        if (unit_length == 0) return error.MissingDebugInfo;
  228844:	48 85 c0             	test   rax,rax
  228847:	75 55                	jne    22889e <printSourceAtAddressLinux+0xc0e>
  228849:	eb 7a                	jmp    2288c5 <printSourceAtAddressLinux+0xc35>
            try self.readNoEof(bytes[0..]);
  22884b:	48 8d 44 24 50       	lea    rax,[rsp+0x50]
  228850:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  228855:	48 c7 44 24 18 08 00 	mov    QWORD PTR [rsp+0x18],0x8
  22885c:	00 00 
            return self.readFn(self, buffer);
  22885e:	48 8d 7c 24 28       	lea    rdi,[rsp+0x28]
  228863:	48 8d 74 24 48       	lea    rsi,[rsp+0x48]
  228868:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  22886d:	ff 54 24 48          	call   QWORD PTR [rsp+0x48]
  228871:	44 0f b7 6c 24 28    	movzx  r13d,WORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  228877:	66 45 85 ed          	test   r13w,r13w
  22887b:	0f 85 b7 03 00 00    	jne    228c38 <printSourceAtAddressLinux+0xfa8>
  228881:	48 8b 44 24 30       	mov    rax,QWORD PTR [rsp+0x30]
            if (amt_read < buf.len) return error.EndOfStream;
  228886:	48 3b 44 24 18       	cmp    rax,QWORD PTR [rsp+0x18]
  22888b:	0f 82 7c 02 00 00    	jb     228b0d <printSourceAtAddressLinux+0xe7d>
  228891:	48 8b 44 24 50       	mov    rax,QWORD PTR [rsp+0x50]
  228896:	41 b6 01             	mov    r14b,0x1
  228899:	48 85 c0             	test   rax,rax
  22889c:	74 27                	je     2288c5 <printSourceAtAddressLinux+0xc35>
        if (compile_unit.index != this_index) {
  22889e:	48 83 c5 01          	add    rbp,0x1
  2288a2:	49 3b 2c 24          	cmp    rbp,QWORD PTR [r12]
  2288a6:	0f 84 f0 02 00 00    	je     228b9c <printSourceAtAddressLinux+0xf0c>
        const next_offset = unit_length + (if (is_64) usize(12) else usize(4));
  2288ac:	41 0f b6 ce          	movzx  ecx,r14b
  2288b0:	48 8d 0c cb          	lea    rcx,[rbx+rcx*8]
            this_offset += next_offset;
  2288b4:	48 8d 1c 08          	lea    rbx,[rax+rcx*1]
  2288b8:	48 83 c3 04          	add    rbx,0x4
    while (this_offset < debug_line_end) : (this_index += 1) {
  2288bc:	4c 39 fb             	cmp    rbx,r15
  2288bf:	0f 82 c1 fe ff ff    	jb     228786 <printSourceAtAddressLinux+0xaf6>
  2288c5:	c5 fc 10 05 f3 fb fd 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffdfbf3]        # 2084c0 <__unnamed_76+0x10>
  2288cc:	ff 
  2288cd:	c5 fc 11 44 24 7e    	vmovups YMMWORD PTR [rsp+0x7e],ymm0
  2288d3:	c5 fc 10 05 d7 fb fd 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffdfbd7]        # 2084b2 <__unnamed_76+0x2>
  2288da:	ff 
  2288db:	c5 fc 11 44 24 70    	vmovups YMMWORD PTR [rsp+0x70],ymm0
  2288e1:	48 8b 6c 24 08       	mov    rbp,QWORD PTR [rsp+0x8]
            return std.fmt.format(self, Error, self.writeFn, format, args);
  2288e6:	4c 8b 75 00          	mov    r14,QWORD PTR [rbp+0x0]
            if (tty_color) {
  2288ea:	f6 84 24 2c 01 00 00 	test   BYTE PTR [rsp+0x12c],0x1
  2288f1:	01 
  2288f2:	0f 85 c0 fd ff ff    	jne    2286b8 <printSourceAtAddressLinux+0xa28>
                        try output(context, fmt[start_index..i]);
  2288f8:	48 8d 35 11 77 02 00 	lea    rsi,[rip+0x27711]        # 250010 <__unnamed_77>
  2288ff:	48 89 ef             	mov    rdi,rbp
  228902:	c5 f8 77             	vzeroupper 
  228905:	41 ff d6             	call   r14
  228908:	41 89 c5             	mov    r13d,eax
  22890b:	66 45 85 ed          	test   r13w,r13w
  22890f:	0f 85 06 03 00 00    	jne    228c1b <printSourceAtAddressLinux+0xf8b>
    var buf: [max_int_digits - 1]u8 = undefined;
  228915:	c5 fc 10 05 d2 0d fe 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffe0dd2]        # 2096ef <__unnamed_28+0x1f>
  22891c:	ff 
  22891d:	c5 fc 11 84 24 cf 00 	vmovups YMMWORD PTR [rsp+0xcf],ymm0
  228924:	00 00 
  228926:	c5 fe 6f 05 a2 0d fe 	vmovdqu ymm0,YMMWORD PTR [rip+0xfffffffffffe0da2]        # 2096d0 <__unnamed_28>
  22892d:	ff 
  22892e:	c5 fe 7f 84 24 b0 00 	vmovdqu YMMWORD PTR [rsp+0xb0],ymm0
  228935:	00 00 
  228937:	48 8b b4 24 a8 00 00 	mov    rsi,QWORD PTR [rsp+0xa8]
  22893e:	00 
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  22893f:	89 f0                	mov    eax,esi
  228941:	24 0f                	and    al,0xf
        0...9 => digit + '0',
  228943:	b1 30                	mov    cl,0x30
  228945:	3c 0a                	cmp    al,0xa
  228947:	72 02                	jb     22894b <printSourceAtAddressLinux+0xcbb>
  228949:	b1 57                	mov    cl,0x57
  22894b:	00 c1                	add    cl,al
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  22894d:	88 8c 24 ef 00 00 00 	mov    BYTE PTR [rsp+0xef],cl
        if (a == 0) break;
  228954:	48 83 fe 10          	cmp    rsi,0x10
  228958:	0f 83 d9 00 00 00    	jae    228a37 <printSourceAtAddressLinux+0xda7>
  22895e:	48 8d 8c 24 ef 00 00 	lea    rcx,[rsp+0xef]
  228965:	00 
  228966:	b8 40 00 00 00       	mov    eax,0x40
  22896b:	e9 05 01 00 00       	jmp    228a75 <printSourceAtAddressLinux+0xde5>
  228970:	b8 40 00 00 00       	mov    eax,0x40
        a /= base;
  228975:	48 89 f1             	mov    rcx,rsi
  228978:	48 c1 e9 04          	shr    rcx,0x4
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  22897c:	89 ca                	mov    edx,ecx
  22897e:	80 e2 0f             	and    dl,0xf
        0...9 => digit + '0',
  228981:	b3 30                	mov    bl,0x30
  228983:	80 fa 0a             	cmp    dl,0xa
  228986:	72 02                	jb     22898a <printSourceAtAddressLinux+0xcfa>
  228988:	b3 57                	mov    bl,0x57
  22898a:	00 d3                	add    bl,dl
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  22898c:	88 9c 04 ae 00 00 00 	mov    BYTE PTR [rsp+rax*1+0xae],bl
        if (a == 0) break;
  228993:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  228997:	48 81 fe ff 00 00 00 	cmp    rsi,0xff
  22899e:	48 89 ce             	mov    rsi,rcx
  2289a1:	77 d5                	ja     228978 <printSourceAtAddressLinux+0xce8>
        const padded_buf = buf[index - padding ..];
  2289a3:	48 8d 0c 04          	lea    rcx,[rsp+rax*1]
  2289a7:	48 81 c1 af 00 00 00 	add    rcx,0xaf
  2289ae:	ba 41 00 00 00       	mov    edx,0x41
  2289b3:	48 29 c2             	sub    rdx,rax
  2289b6:	48 89 8c 24 30 01 00 	mov    QWORD PTR [rsp+0x130],rcx
  2289bd:	00 
  2289be:	48 89 94 24 38 01 00 	mov    QWORD PTR [rsp+0x138],rdx
  2289c5:	00 
  2289c6:	48 8d b4 24 30 01 00 	lea    rsi,[rsp+0x130]
  2289cd:	00 
        return output(context, padded_buf);
  2289ce:	48 89 ef             	mov    rdi,rbp
  2289d1:	c5 f8 77             	vzeroupper 
  2289d4:	41 ff d6             	call   r14
  2289d7:	41 89 c5             	mov    r13d,eax
                    try formatType(args[next_arg], fmt[s..i], context, Errors, output);
  2289da:	66 45 85 ed          	test   r13w,r13w
  2289de:	0f 85 37 02 00 00    	jne    228c1b <printSourceAtAddressLinux+0xf8b>
                        try output(context, fmt[start_index..i]);
  2289e4:	48 8d 35 05 76 02 00 	lea    rsi,[rip+0x27605]        # 24fff0 <__unnamed_78>
  2289eb:	48 89 ef             	mov    rdi,rbp
  2289ee:	41 ff d6             	call   r14
  2289f1:	41 89 c5             	mov    r13d,eax
  2289f4:	66 45 85 ed          	test   r13w,r13w
  2289f8:	0f 85 1d 02 00 00    	jne    228c1b <printSourceAtAddressLinux+0xf8b>
                const casted_value = ([]const u8)(value);
  2289fe:	c5 f8 28 84 24 10 02 	vmovaps xmm0,XMMWORD PTR [rsp+0x210]
  228a05:	00 00 
  228a07:	c5 f8 29 84 24 b0 00 	vmovaps XMMWORD PTR [rsp+0xb0],xmm0
  228a0e:	00 00 
  228a10:	48 8d b4 24 b0 00 00 	lea    rsi,[rsp+0xb0]
  228a17:	00 
                return output(context, casted_value);
  228a18:	48 89 ef             	mov    rdi,rbp
  228a1b:	41 ff d6             	call   r14
  228a1e:	41 89 c5             	mov    r13d,eax
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  228a21:	66 45 85 ed          	test   r13w,r13w
  228a25:	0f 85 f0 01 00 00    	jne    228c1b <printSourceAtAddressLinux+0xf8b>
        try output(context, fmt[start_index..]);
  228a2b:	48 8d 35 ce 75 02 00 	lea    rsi,[rip+0x275ce]        # 250000 <__unnamed_79>
  228a32:	e9 4c f9 ff ff       	jmp    228383 <printSourceAtAddressLinux+0x6f3>
  228a37:	b8 40 00 00 00       	mov    eax,0x40
        a /= base;
  228a3c:	48 89 f1             	mov    rcx,rsi
  228a3f:	48 c1 e9 04          	shr    rcx,0x4
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  228a43:	89 ca                	mov    edx,ecx
  228a45:	80 e2 0f             	and    dl,0xf
        0...9 => digit + '0',
  228a48:	b3 30                	mov    bl,0x30
  228a4a:	80 fa 0a             	cmp    dl,0xa
  228a4d:	72 02                	jb     228a51 <printSourceAtAddressLinux+0xdc1>
  228a4f:	b3 57                	mov    bl,0x57
  228a51:	00 d3                	add    bl,dl
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  228a53:	88 9c 04 ae 00 00 00 	mov    BYTE PTR [rsp+rax*1+0xae],bl
        if (a == 0) break;
  228a5a:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  228a5e:	48 81 fe ff 00 00 00 	cmp    rsi,0xff
  228a65:	48 89 ce             	mov    rsi,rcx
  228a68:	77 d5                	ja     228a3f <printSourceAtAddressLinux+0xdaf>
        const padded_buf = buf[index - padding ..];
  228a6a:	48 8d 0c 04          	lea    rcx,[rsp+rax*1]
  228a6e:	48 81 c1 af 00 00 00 	add    rcx,0xaf
  228a75:	ba 41 00 00 00       	mov    edx,0x41
  228a7a:	48 29 c2             	sub    rdx,rax
  228a7d:	48 89 8c 24 30 01 00 	mov    QWORD PTR [rsp+0x130],rcx
  228a84:	00 
  228a85:	48 89 94 24 38 01 00 	mov    QWORD PTR [rsp+0x138],rdx
  228a8c:	00 
  228a8d:	48 8d b4 24 30 01 00 	lea    rsi,[rsp+0x130]
  228a94:	00 
        return output(context, padded_buf);
  228a95:	48 89 ef             	mov    rdi,rbp
  228a98:	c5 f8 77             	vzeroupper 
  228a9b:	41 ff d6             	call   r14
  228a9e:	41 89 c5             	mov    r13d,eax
                    try formatType(args[next_arg], fmt[s..i], context, Errors, output);
  228aa1:	66 45 85 ed          	test   r13w,r13w
  228aa5:	0f 85 70 01 00 00    	jne    228c1b <printSourceAtAddressLinux+0xf8b>
                        try output(context, fmt[start_index..i]);
  228aab:	48 8d 35 6e 75 02 00 	lea    rsi,[rip+0x2756e]        # 250020 <__unnamed_80>
  228ab2:	48 89 ef             	mov    rdi,rbp
  228ab5:	41 ff d6             	call   r14
  228ab8:	41 89 c5             	mov    r13d,eax
  228abb:	66 45 85 ed          	test   r13w,r13w
  228abf:	0f 85 56 01 00 00    	jne    228c1b <printSourceAtAddressLinux+0xf8b>
                const casted_value = ([]const u8)(value);
  228ac5:	c5 f8 28 84 24 10 02 	vmovaps xmm0,XMMWORD PTR [rsp+0x210]
  228acc:	00 00 
  228ace:	c5 f8 29 84 24 b0 00 	vmovaps XMMWORD PTR [rsp+0xb0],xmm0
  228ad5:	00 00 
  228ad7:	48 8d b4 24 b0 00 00 	lea    rsi,[rsp+0xb0]
  228ade:	00 
                return output(context, casted_value);
  228adf:	48 89 ef             	mov    rdi,rbp
  228ae2:	41 ff d6             	call   r14
  228ae5:	41 89 c5             	mov    r13d,eax
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  228ae8:	66 45 85 ed          	test   r13w,r13w
  228aec:	0f 85 29 01 00 00    	jne    228c1b <printSourceAtAddressLinux+0xf8b>
        try output(context, fmt[start_index..]);
  228af2:	48 8d 35 37 75 02 00 	lea    rsi,[rip+0x27537]        # 250030 <__unnamed_81>
  228af9:	e9 85 f8 ff ff       	jmp    228383 <printSourceAtAddressLinux+0x6f3>
  228afe:	48 83 f9 4b          	cmp    rcx,0x4b
  228b02:	0f 85 27 fb ff ff    	jne    22862f <printSourceAtAddressLinux+0x99f>
  228b08:	e9 d4 fa ff ff       	jmp    2285e1 <printSourceAtAddressLinux+0x951>
  228b0d:	66 41 bd 25 00       	mov    r13w,0x25
  228b12:	e9 21 01 00 00       	jmp    228c38 <printSourceAtAddressLinux+0xfa8>
  228b17:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
            var in_file_stream = io.FileInStream.init(&self.self_exe_file);
  228b1c:	48 89 84 24 d8 02 00 	mov    QWORD PTR [rsp+0x2d8],rax
  228b23:	00 
  228b24:	48 8d 94 24 e0 02 00 	lea    rdx,[rsp+0x2e0]
  228b2b:	00 
  228b2c:	48 8d 0d 2d b6 ff ff 	lea    rcx,[rip+0xffffffffffffb62d]        # 224160 <FileInStream_readFn>
  228b33:	48 89 8c 24 e0 02 00 	mov    QWORD PTR [rsp+0x2e0],rcx
  228b3a:	00 
  228b3b:	48 8b b0 a0 00 00 00 	mov    rsi,QWORD PTR [rax+0xa0]
  228b42:	48 8d 5c 24 28       	lea    rbx,[rsp+0x28]
            return readStringRaw(self.allocator(), in_stream);
  228b47:	48 89 df             	mov    rdi,rbx
  228b4a:	c5 f8 77             	vzeroupper 
  228b4d:	e8 de ec ff ff       	call   227830 <readStringRaw>
  228b52:	e9 f8 fa ff ff       	jmp    22864f <printSourceAtAddressLinux+0x9bf>
  228b57:	66 41 bd 04 00       	mov    r13w,0x4
  228b5c:	eb 2a                	jmp    228b88 <printSourceAtAddressLinux+0xef8>
  228b5e:	48 8d 41 ea          	lea    rax,[rcx-0x16]
  228b62:	48 83 f8 35          	cmp    rax,0x35
  228b66:	77 10                	ja     228b78 <printSourceAtAddressLinux+0xee8>
  228b68:	48 ba 81 00 00 00 00 	movabs rdx,0x20000000000081
  228b6f:	00 20 00 
  228b72:	48 0f a3 c2          	bt     rdx,rax
  228b76:	72 0b                	jb     228b83 <printSourceAtAddressLinux+0xef3>
  228b78:	66 41 bd 03 00       	mov    r13w,0x3
  228b7d:	48 83 f9 06          	cmp    rcx,0x6
  228b81:	75 05                	jne    228b88 <printSourceAtAddressLinux+0xef8>
  228b83:	66 41 bd 27 00       	mov    r13w,0x27
        try in_file.seekTo(this_offset);
  228b88:	c5 fc 10 84 24 8c 0b 	vmovups ymm0,YMMWORD PTR [rsp+0xb8c]
  228b8f:	00 00 
  228b91:	c5 fe 6f 8c 24 9a 0b 	vmovdqu ymm1,YMMWORD PTR [rsp+0xb9a]
  228b98:	00 00 
  228b9a:	eb 5d                	jmp    228bf9 <printSourceAtAddressLinux+0xf69>
        const version = try in_stream.readInt(di.elf.endian, u16);
  228b9c:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  228ba1:	8a 58 12             	mov    bl,BYTE PTR [rax+0x12]
            try self.readNoEof(bytes[0..]);
  228ba4:	48 8d 44 24 50       	lea    rax,[rsp+0x50]
  228ba9:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  228bae:	48 c7 44 24 18 02 00 	mov    QWORD PTR [rsp+0x18],0x2
  228bb5:	00 00 
  228bb7:	48 8d 7c 24 28       	lea    rdi,[rsp+0x28]
  228bbc:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
            return self.readFn(self, buffer);
  228bc1:	48 8d 74 24 48       	lea    rsi,[rsp+0x48]
  228bc6:	ff 54 24 48          	call   QWORD PTR [rsp+0x48]
  228bca:	44 0f b7 6c 24 28    	movzx  r13d,WORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  228bd0:	66 45 85 ed          	test   r13w,r13w
  228bd4:	75 11                	jne    228be7 <printSourceAtAddressLinux+0xf57>
  228bd6:	48 8b 44 24 30       	mov    rax,QWORD PTR [rsp+0x30]
  228bdb:	66 41 bd 25 00       	mov    r13w,0x25
            if (amt_read < buf.len) return error.EndOfStream;
  228be0:	48 3b 44 24 18       	cmp    rax,QWORD PTR [rsp+0x18]
  228be5:	73 6d                	jae    228c54 <printSourceAtAddressLinux+0xfc4>
  228be7:	c5 fc 10 84 24 30 0b 	vmovups ymm0,YMMWORD PTR [rsp+0xb30]
  228bee:	00 00 
  228bf0:	c5 fe 6f 8c 24 3e 0b 	vmovdqu ymm1,YMMWORD PTR [rsp+0xb3e]
  228bf7:	00 00 
  228bf9:	c5 fe 7f 4c 24 7e    	vmovdqu YMMWORD PTR [rsp+0x7e],ymm1
  228bff:	c5 fc 11 44 24 70    	vmovups YMMWORD PTR [rsp+0x70],ymm0
  228c05:	48 8b 6c 24 08       	mov    rbp,QWORD PTR [rsp+0x8]
    } else |err| switch (err) {
  228c0a:	44 89 e8             	mov    eax,r13d
  228c0d:	25 fe ff 00 00       	and    eax,0xfffe
  228c12:	83 f8 28             	cmp    eax,0x28
  228c15:	0f 84 8b fa ff ff    	je     2286a6 <printSourceAtAddressLinux+0xa16>
            try out_stream.print("???:?:?: " ++ DIM ++ "0x{x} in ??? (???)" ++ RESET ++ "\n\n\n", address);
  228c1b:	44 89 e8             	mov    eax,r13d
  228c1e:	48 81 c4 08 0c 00 00 	add    rsp,0xc08
  228c25:	5b                   	pop    rbx
  228c26:	41 5c                	pop    r12
  228c28:	41 5d                	pop    r13
  228c2a:	41 5e                	pop    r14
  228c2c:	41 5f                	pop    r15
  228c2e:	5d                   	pop    rbp
  228c2f:	c5 f8 77             	vzeroupper 
  228c32:	c3                   	ret    
  228c33:	66 41 bd 29 00       	mov    r13w,0x29
  228c38:	48 8b 6c 24 08       	mov    rbp,QWORD PTR [rsp+0x8]
        const unit_length = try readInitialLength(@typeOf(in_stream.readFn).ReturnType.ErrorSet, in_stream, &is_64);
  228c3d:	c5 fc 10 84 24 5e 0b 	vmovups ymm0,YMMWORD PTR [rsp+0xb5e]
  228c44:	00 00 
  228c46:	c5 fe 6f 8c 24 6c 0b 	vmovdqu ymm1,YMMWORD PTR [rsp+0xb6c]
  228c4d:	00 00 
  228c4f:	e9 35 fa ff ff       	jmp    228689 <printSourceAtAddressLinux+0x9f9>
  228c54:	0f b6 44 24 50       	movzx  eax,BYTE PTR [rsp+0x50]
  228c59:	0f b6 4c 24 51       	movzx  ecx,BYTE PTR [rsp+0x51]
  228c5e:	89 ca                	mov    edx,ecx
  228c60:	c1 e2 08             	shl    edx,0x8
  228c63:	09 c2                	or     edx,eax
                result = (result << 8) | b;
  228c65:	c1 e0 08             	shl    eax,0x8
  228c68:	09 c8                	or     eax,ecx
    switch (endian) {
  228c6a:	f6 c3 01             	test   bl,0x1
  228c6d:	66 0f 45 c2          	cmovne ax,dx
        if (version != 2 and version != 4) return error.InvalidDebugInfo;
  228c71:	0f b7 e8             	movzx  ebp,ax
  228c74:	83 fd 02             	cmp    ebp,0x2
  228c77:	74 09                	je     228c82 <printSourceAtAddressLinux+0xff2>
  228c79:	83 fd 04             	cmp    ebp,0x4
  228c7c:	0f 85 94 17 00 00    	jne    22a416 <printSourceAtAddressLinux+0x2786>
  228c82:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  228c87:	8a 58 12             	mov    bl,BYTE PTR [rax+0x12]
        const prologue_length = if (is_64) try in_stream.readInt(di.elf.endian, u64) else try in_stream.readInt(di.elf.endian, u32);
  228c8a:	45 84 f6             	test   r14b,r14b
  228c8d:	74 3b                	je     228cca <printSourceAtAddressLinux+0x103a>
  228c8f:	0f b6 d3             	movzx  edx,bl
  228c92:	48 8d bc 24 c8 02 00 	lea    rdi,[rsp+0x2c8]
  228c99:	00 
  228c9a:	48 8d 74 24 48       	lea    rsi,[rsp+0x48]
  228c9f:	e8 5c b2 ff ff       	call   223f00 <InStream(ReadError)_readInt.143>
  228ca4:	44 0f b7 ac 24 c8 02 	movzx  r13d,WORD PTR [rsp+0x2c8]
  228cab:	00 00 
  228cad:	66 45 85 ed          	test   r13w,r13w
  228cb1:	74 71                	je     228d24 <printSourceAtAddressLinux+0x1094>
  228cb3:	c5 fc 10 84 24 02 0b 	vmovups ymm0,YMMWORD PTR [rsp+0xb02]
  228cba:	00 00 
  228cbc:	c5 fe 6f 8c 24 10 0b 	vmovdqu ymm1,YMMWORD PTR [rsp+0xb10]
  228cc3:	00 00 
  228cc5:	e9 2f ff ff ff       	jmp    228bf9 <printSourceAtAddressLinux+0xf69>
            try self.readNoEof(bytes[0..]);
  228cca:	48 8d 44 24 50       	lea    rax,[rsp+0x50]
  228ccf:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  228cd4:	48 c7 44 24 18 04 00 	mov    QWORD PTR [rsp+0x18],0x4
  228cdb:	00 00 
  228cdd:	48 8d 7c 24 28       	lea    rdi,[rsp+0x28]
  228ce2:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
            return self.readFn(self, buffer);
  228ce7:	48 8d 74 24 48       	lea    rsi,[rsp+0x48]
  228cec:	ff 54 24 48          	call   QWORD PTR [rsp+0x48]
  228cf0:	44 0f b7 6c 24 28    	movzx  r13d,WORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  228cf6:	66 45 85 ed          	test   r13w,r13w
  228cfa:	75 11                	jne    228d0d <printSourceAtAddressLinux+0x107d>
  228cfc:	48 8b 44 24 30       	mov    rax,QWORD PTR [rsp+0x30]
  228d01:	66 41 bd 25 00       	mov    r13w,0x25
            if (amt_read < buf.len) return error.EndOfStream;
  228d06:	48 3b 44 24 18       	cmp    rax,QWORD PTR [rsp+0x18]
  228d0b:	73 21                	jae    228d2e <printSourceAtAddressLinux+0x109e>
  228d0d:	c5 fc 10 84 24 d4 0a 	vmovups ymm0,YMMWORD PTR [rsp+0xad4]
  228d14:	00 00 
  228d16:	c5 fe 6f 8c 24 e2 0a 	vmovdqu ymm1,YMMWORD PTR [rsp+0xae2]
  228d1d:	00 00 
  228d1f:	e9 d5 fe ff ff       	jmp    228bf9 <printSourceAtAddressLinux+0xf69>
  228d24:	4c 8b b4 24 d0 02 00 	mov    r14,QWORD PTR [rsp+0x2d0]
  228d2b:	00 
  228d2c:	eb 46                	jmp    228d74 <printSourceAtAddressLinux+0x10e4>
  228d2e:	0f b6 44 24 50       	movzx  eax,BYTE PTR [rsp+0x50]
  228d33:	0f b6 4c 24 51       	movzx  ecx,BYTE PTR [rsp+0x51]
  228d38:	f6 c3 01             	test   bl,0x1
  228d3b:	74 1b                	je     228d58 <printSourceAtAddressLinux+0x10c8>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  228d3d:	c1 e1 08             	shl    ecx,0x8
  228d40:	09 c1                	or     ecx,eax
  228d42:	0f b6 54 24 52       	movzx  edx,BYTE PTR [rsp+0x52]
  228d47:	c1 e2 10             	shl    edx,0x10
  228d4a:	09 ca                	or     edx,ecx
  228d4c:	0f b6 44 24 53       	movzx  eax,BYTE PTR [rsp+0x53]
  228d51:	c1 e0 18             	shl    eax,0x18
  228d54:	09 d0                	or     eax,edx
  228d56:	eb 19                	jmp    228d71 <printSourceAtAddressLinux+0x10e1>
                result = (result << 8) | b;
  228d58:	c1 e0 08             	shl    eax,0x8
  228d5b:	09 c8                	or     eax,ecx
  228d5d:	c1 e0 08             	shl    eax,0x8
  228d60:	0f b6 4c 24 52       	movzx  ecx,BYTE PTR [rsp+0x52]
  228d65:	09 c1                	or     ecx,eax
  228d67:	c1 e1 08             	shl    ecx,0x8
  228d6a:	0f b6 44 24 53       	movzx  eax,BYTE PTR [rsp+0x53]
  228d6f:	09 c8                	or     eax,ecx
  228d71:	41 89 c6             	mov    r14d,eax
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  228d74:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  228d79:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  228d7c:	31 db                	xor    ebx,ebx
  228d7e:	b8 08 00 00 00       	mov    eax,0x8
  228d83:	be 00 00 00 00       	mov    esi,0x0
  228d88:	ba 01 00 00 00       	mov    edx,0x1
  228d8d:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  228d8f:	48 89 c2             	mov    rdx,rax
  228d92:	48 f7 da             	neg    rdx
  228d95:	49 89 c7             	mov    r15,rax
  228d98:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  228d9e:	48 0f 46 d3          	cmovbe rdx,rbx
  228da2:	66 41 bd 27 00       	mov    r13w,0x27
                if (err > 0) {
  228da7:	48 83 fa 1d          	cmp    rdx,0x1d
  228dab:	77 6a                	ja     228e17 <printSourceAtAddressLinux+0x1187>
  228dad:	48 8d 0d 2c 86 fd ff 	lea    rcx,[rip+0xfffffffffffd862c]        # 2013e0 <__unnamed_621+0x728>
  228db4:	48 63 04 91          	movsxd rax,DWORD PTR [rcx+rdx*4]
  228db8:	48 01 c8             	add    rax,rcx
  228dbb:	ff e0                	jmp    rax
            try self.readNoEof(result[0..]);
  228dbd:	48 8d 44 24 50       	lea    rax,[rsp+0x50]
  228dc2:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  228dc7:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  228dce:	00 00 
  228dd0:	48 8d 7c 24 28       	lea    rdi,[rsp+0x28]
  228dd5:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
            return self.readFn(self, buffer);
  228dda:	48 8d 74 24 48       	lea    rsi,[rsp+0x48]
  228ddf:	ff 54 24 48          	call   QWORD PTR [rsp+0x48]
  228de3:	44 0f b7 6c 24 28    	movzx  r13d,WORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  228de9:	66 45 85 ed          	test   r13w,r13w
  228ded:	75 11                	jne    228e00 <printSourceAtAddressLinux+0x1170>
  228def:	48 8b 44 24 30       	mov    rax,QWORD PTR [rsp+0x30]
  228df4:	66 41 bd 25 00       	mov    r13w,0x25
            if (amt_read < buf.len) return error.EndOfStream;
  228df9:	48 3b 44 24 18       	cmp    rax,QWORD PTR [rsp+0x18]
  228dfe:	73 39                	jae    228e39 <printSourceAtAddressLinux+0x11a9>
        const minimum_instruction_length = try in_stream.readByte();
  228e00:	c5 fc 10 84 24 78 0a 	vmovups ymm0,YMMWORD PTR [rsp+0xa78]
  228e07:	00 00 
  228e09:	c5 fe 6f 8c 24 86 0a 	vmovdqu ymm1,YMMWORD PTR [rsp+0xa86]
  228e10:	00 00 
  228e12:	e9 e2 fd ff ff       	jmp    228bf9 <printSourceAtAddressLinux+0xf69>
  228e17:	48 83 fa 4b          	cmp    rdx,0x4b
  228e1b:	74 05                	je     228e22 <printSourceAtAddressLinux+0x1192>
  228e1d:	66 41 bd 03 00       	mov    r13w,0x3
        const prog_start_offset = (try in_file.getPos()) + prologue_length;
  228e22:	c5 fc 10 84 24 a6 0a 	vmovups ymm0,YMMWORD PTR [rsp+0xaa6]
  228e29:	00 00 
  228e2b:	c5 fe 6f 8c 24 b4 0a 	vmovdqu ymm1,YMMWORD PTR [rsp+0xab4]
  228e32:	00 00 
  228e34:	e9 c0 fd ff ff       	jmp    228bf9 <printSourceAtAddressLinux+0xf69>
            return result[0];
  228e39:	44 0f b6 64 24 50    	movzx  r12d,BYTE PTR [rsp+0x50]
  228e3f:	4d 85 e4             	test   r12,r12
        if (minimum_instruction_length == 0) return error.InvalidDebugInfo;
  228e42:	0f 84 ce 15 00 00    	je     22a416 <printSourceAtAddressLinux+0x2786>
        if (version >= 4) {
  228e48:	83 fd 04             	cmp    ebp,0x4
  228e4b:	72 5a                	jb     228ea7 <printSourceAtAddressLinux+0x1217>
            try self.readNoEof(result[0..]);
  228e4d:	48 8d 44 24 50       	lea    rax,[rsp+0x50]
  228e52:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  228e57:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  228e5e:	00 00 
  228e60:	48 8d 7c 24 28       	lea    rdi,[rsp+0x28]
  228e65:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
            return self.readFn(self, buffer);
  228e6a:	48 8d 74 24 48       	lea    rsi,[rsp+0x48]
  228e6f:	ff 54 24 48          	call   QWORD PTR [rsp+0x48]
  228e73:	44 0f b7 6c 24 28    	movzx  r13d,WORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  228e79:	66 45 85 ed          	test   r13w,r13w
  228e7d:	75 11                	jne    228e90 <printSourceAtAddressLinux+0x1200>
  228e7f:	48 8b 44 24 30       	mov    rax,QWORD PTR [rsp+0x30]
  228e84:	66 41 bd 25 00       	mov    r13w,0x25
            if (amt_read < buf.len) return error.EndOfStream;
  228e89:	48 3b 44 24 18       	cmp    rax,QWORD PTR [rsp+0x18]
  228e8e:	73 17                	jae    228ea7 <printSourceAtAddressLinux+0x1217>
            _ = try in_stream.readByte();
  228e90:	c5 fc 10 84 24 4a 0a 	vmovups ymm0,YMMWORD PTR [rsp+0xa4a]
  228e97:	00 00 
  228e99:	c5 fe 6f 8c 24 58 0a 	vmovdqu ymm1,YMMWORD PTR [rsp+0xa58]
  228ea0:	00 00 
  228ea2:	e9 52 fd ff ff       	jmp    228bf9 <printSourceAtAddressLinux+0xf69>
            try self.readNoEof(result[0..]);
  228ea7:	48 8d 44 24 50       	lea    rax,[rsp+0x50]
  228eac:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  228eb1:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  228eb8:	00 00 
  228eba:	48 8d 7c 24 28       	lea    rdi,[rsp+0x28]
  228ebf:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
            return self.readFn(self, buffer);
  228ec4:	48 8d 74 24 48       	lea    rsi,[rsp+0x48]
  228ec9:	ff 54 24 48          	call   QWORD PTR [rsp+0x48]
  228ecd:	44 0f b7 6c 24 28    	movzx  r13d,WORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  228ed3:	66 45 85 ed          	test   r13w,r13w
  228ed7:	75 11                	jne    228eea <printSourceAtAddressLinux+0x125a>
  228ed9:	48 8b 44 24 30       	mov    rax,QWORD PTR [rsp+0x30]
  228ede:	66 41 bd 25 00       	mov    r13w,0x25
            if (amt_read < buf.len) return error.EndOfStream;
  228ee3:	48 3b 44 24 18       	cmp    rax,QWORD PTR [rsp+0x18]
  228ee8:	73 17                	jae    228f01 <printSourceAtAddressLinux+0x1271>
        const default_is_stmt = (try in_stream.readByte()) != 0;
  228eea:	c5 fc 10 84 24 1c 0a 	vmovups ymm0,YMMWORD PTR [rsp+0xa1c]
  228ef1:	00 00 
  228ef3:	c5 fe 6f 8c 24 2a 0a 	vmovdqu ymm1,YMMWORD PTR [rsp+0xa2a]
  228efa:	00 00 
  228efc:	e9 f8 fc ff ff       	jmp    228bf9 <printSourceAtAddressLinux+0xf69>
            return result[0];
  228f01:	40 8a 6c 24 50       	mov    bpl,BYTE PTR [rsp+0x50]
            try self.readNoEof(result[0..]);
  228f06:	48 8d 44 24 50       	lea    rax,[rsp+0x50]
  228f0b:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  228f10:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  228f17:	00 00 
  228f19:	48 8d 7c 24 28       	lea    rdi,[rsp+0x28]
  228f1e:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
            return self.readFn(self, buffer);
  228f23:	48 8d 74 24 48       	lea    rsi,[rsp+0x48]
  228f28:	ff 54 24 48          	call   QWORD PTR [rsp+0x48]
  228f2c:	44 0f b7 6c 24 28    	movzx  r13d,WORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  228f32:	66 45 85 ed          	test   r13w,r13w
  228f36:	75 11                	jne    228f49 <printSourceAtAddressLinux+0x12b9>
  228f38:	48 8b 44 24 30       	mov    rax,QWORD PTR [rsp+0x30]
  228f3d:	66 41 bd 25 00       	mov    r13w,0x25
            if (amt_read < buf.len) return error.EndOfStream;
  228f42:	48 3b 44 24 18       	cmp    rax,QWORD PTR [rsp+0x18]
  228f47:	73 17                	jae    228f60 <printSourceAtAddressLinux+0x12d0>
        const line_base = try in_stream.readByteSigned();
  228f49:	c5 fc 10 84 24 ee 09 	vmovups ymm0,YMMWORD PTR [rsp+0x9ee]
  228f50:	00 00 
  228f52:	c5 fe 6f 8c 24 fc 09 	vmovdqu ymm1,YMMWORD PTR [rsp+0x9fc]
  228f59:	00 00 
  228f5b:	e9 99 fc ff ff       	jmp    228bf9 <printSourceAtAddressLinux+0xf69>
            return result[0];
  228f60:	48 0f be 44 24 50    	movsx  rax,BYTE PTR [rsp+0x50]
            try self.readNoEof(result[0..]);
  228f66:	48 89 84 24 40 03 00 	mov    QWORD PTR [rsp+0x340],rax
  228f6d:	00 
  228f6e:	48 8d 44 24 50       	lea    rax,[rsp+0x50]
  228f73:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  228f78:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  228f7f:	00 00 
  228f81:	48 8d 7c 24 28       	lea    rdi,[rsp+0x28]
  228f86:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
            return self.readFn(self, buffer);
  228f8b:	48 8d 74 24 48       	lea    rsi,[rsp+0x48]
  228f90:	ff 54 24 48          	call   QWORD PTR [rsp+0x48]
  228f94:	44 0f b7 6c 24 28    	movzx  r13d,WORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  228f9a:	66 45 85 ed          	test   r13w,r13w
  228f9e:	75 11                	jne    228fb1 <printSourceAtAddressLinux+0x1321>
  228fa0:	48 8b 44 24 30       	mov    rax,QWORD PTR [rsp+0x30]
  228fa5:	66 41 bd 25 00       	mov    r13w,0x25
            if (amt_read < buf.len) return error.EndOfStream;
  228faa:	48 3b 44 24 18       	cmp    rax,QWORD PTR [rsp+0x18]
  228faf:	73 17                	jae    228fc8 <printSourceAtAddressLinux+0x1338>
        const line_range = try in_stream.readByte();
  228fb1:	c5 fc 10 84 24 c0 09 	vmovups ymm0,YMMWORD PTR [rsp+0x9c0]
  228fb8:	00 00 
  228fba:	c5 fe 6f 8c 24 ce 09 	vmovdqu ymm1,YMMWORD PTR [rsp+0x9ce]
  228fc1:	00 00 
  228fc3:	e9 31 fc ff ff       	jmp    228bf9 <printSourceAtAddressLinux+0xf69>
            return result[0];
  228fc8:	8a 44 24 50          	mov    al,BYTE PTR [rsp+0x50]
  228fcc:	88 84 24 98 01 00 00 	mov    BYTE PTR [rsp+0x198],al
        if (line_range == 0) return error.InvalidDebugInfo;
  228fd3:	84 c0                	test   al,al
  228fd5:	0f 84 3b 14 00 00    	je     22a416 <printSourceAtAddressLinux+0x2786>
            try self.readNoEof(result[0..]);
  228fdb:	48 8d 44 24 50       	lea    rax,[rsp+0x50]
  228fe0:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  228fe5:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  228fec:	00 00 
  228fee:	48 8d 7c 24 28       	lea    rdi,[rsp+0x28]
  228ff3:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
            return self.readFn(self, buffer);
  228ff8:	48 8d 74 24 48       	lea    rsi,[rsp+0x48]
  228ffd:	ff 54 24 48          	call   QWORD PTR [rsp+0x48]
  229001:	44 0f b7 6c 24 28    	movzx  r13d,WORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  229007:	66 45 85 ed          	test   r13w,r13w
  22900b:	75 11                	jne    22901e <printSourceAtAddressLinux+0x138e>
  22900d:	48 8b 44 24 30       	mov    rax,QWORD PTR [rsp+0x30]
  229012:	66 41 bd 25 00       	mov    r13w,0x25
            if (amt_read < buf.len) return error.EndOfStream;
  229017:	48 3b 44 24 18       	cmp    rax,QWORD PTR [rsp+0x18]
  22901c:	73 17                	jae    229035 <printSourceAtAddressLinux+0x13a5>
        const opcode_base = try in_stream.readByte();
  22901e:	c5 fc 10 84 24 92 09 	vmovups ymm0,YMMWORD PTR [rsp+0x992]
  229025:	00 00 
  229027:	c5 fe 6f 8c 24 a0 09 	vmovdqu ymm1,YMMWORD PTR [rsp+0x9a0]
  22902e:	00 00 
  229030:	e9 c4 fb ff ff       	jmp    228bf9 <printSourceAtAddressLinux+0xf69>
            return result[0];
  229035:	8a 4c 24 50          	mov    cl,BYTE PTR [rsp+0x50]
  229039:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  22903e:	48 8b b0 a0 00 00 00 	mov    rsi,QWORD PTR [rax+0xa0]
  229045:	88 4c 24 67          	mov    BYTE PTR [rsp+0x67],cl
        const standard_opcode_lengths = try di.allocator().alloc(u8, opcode_base - 1);
  229049:	89 c8                	mov    eax,ecx
  22904b:	04 ff                	add    al,0xff
        if (n == 0) {
  22904d:	74 3e                	je     22908d <printSourceAtAddressLinux+0x13fd>
  22904f:	0f b6 d0             	movzx  edx,al
  229052:	48 8d 7c 24 28       	lea    rdi,[rsp+0x28]
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  229057:	b9 01 00 00 00       	mov    ecx,0x1
  22905c:	48 89 94 24 68 01 00 	mov    QWORD PTR [rsp+0x168],rdx
  229063:	00 
  229064:	ff 16                	call   QWORD PTR [rsi]
  229066:	44 0f b7 6c 24 28    	movzx  r13d,WORD PTR [rsp+0x28]
  22906c:	66 45 85 ed          	test   r13w,r13w
  229070:	0f 84 80 00 00 00    	je     2290f6 <printSourceAtAddressLinux+0x1466>
  229076:	c5 fc 10 84 24 64 09 	vmovups ymm0,YMMWORD PTR [rsp+0x964]
  22907d:	00 00 
  22907f:	c5 fe 6f 8c 24 72 09 	vmovdqu ymm1,YMMWORD PTR [rsp+0x972]
  229086:	00 00 
  229088:	e9 6c fb ff ff       	jmp    228bf9 <printSourceAtAddressLinux+0xf69>
  22908d:	31 c0                	xor    eax,eax
  22908f:	48 89 84 24 68 01 00 	mov    QWORD PTR [rsp+0x168],rax
  229096:	00 
            return Self{
  229097:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  22909b:	c5 f9 7f 84 24 a0 01 	vmovdqa XMMWORD PTR [rsp+0x1a0],xmm0
  2290a2:	00 00 
  2290a4:	48 c7 84 24 b0 01 00 	mov    QWORD PTR [rsp+0x1b0],0x0
  2290ab:	00 00 00 00 00 
        var include_directories = ArrayList([]u8).init(di.allocator());
  2290b0:	48 89 b4 24 b8 01 00 	mov    QWORD PTR [rsp+0x1b8],rsi
  2290b7:	00 
  2290b8:	48 8d 7c 24 28       	lea    rdi,[rsp+0x28]
  2290bd:	48 8d 94 24 a0 01 00 	lea    rdx,[rsp+0x1a0]
  2290c4:	00 
            self.items = try self.allocator.alignedRealloc(T, A, self.items, better_capacity);
  2290c5:	b9 08 00 00 00       	mov    ecx,0x8
  2290ca:	e8 f1 23 00 00       	call   22b4c0 <Allocator_alignedRealloc.186>
  2290cf:	44 0f b7 6c 24 28    	movzx  r13d,WORD PTR [rsp+0x28]
  2290d5:	66 45 85 ed          	test   r13w,r13w
  2290d9:	0f 84 ae 00 00 00    	je     22918d <printSourceAtAddressLinux+0x14fd>
        try include_directories.append(compile_unit_cwd);
  2290df:	c5 fc 10 84 24 08 09 	vmovups ymm0,YMMWORD PTR [rsp+0x908]
  2290e6:	00 00 
  2290e8:	c5 fe 6f 8c 24 16 09 	vmovdqu ymm1,YMMWORD PTR [rsp+0x916]
  2290ef:	00 00 
  2290f1:	e9 03 fb ff ff       	jmp    228bf9 <printSourceAtAddressLinux+0xf69>
        assert(byte_slice.len == byte_count);
  2290f6:	48 8b 84 24 68 01 00 	mov    rax,QWORD PTR [rsp+0x168]
  2290fd:	00 
  2290fe:	48 39 44 24 38       	cmp    QWORD PTR [rsp+0x38],rax
    if (!ok) {
  229103:	0f 85 71 14 00 00    	jne    22a57a <printSourceAtAddressLinux+0x28ea>
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  229109:	48 8b 44 24 30       	mov    rax,QWORD PTR [rsp+0x30]
  22910e:	48 89 84 24 08 02 00 	mov    QWORD PTR [rsp+0x208],rax
  229115:	00 
  229116:	31 db                	xor    ebx,ebx
            try self.readNoEof(result[0..]);
  229118:	48 8d 44 24 50       	lea    rax,[rsp+0x50]
  22911d:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  229122:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  229129:	00 00 
            return self.readFn(self, buffer);
  22912b:	48 8d 7c 24 28       	lea    rdi,[rsp+0x28]
  229130:	48 8d 74 24 48       	lea    rsi,[rsp+0x48]
  229135:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  22913a:	ff 54 24 48          	call   QWORD PTR [rsp+0x48]
  22913e:	44 0f b7 6c 24 28    	movzx  r13d,WORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  229144:	66 45 85 ed          	test   r13w,r13w
  229148:	0f 85 d0 00 00 00    	jne    22921e <printSourceAtAddressLinux+0x158e>
  22914e:	48 8b 44 24 30       	mov    rax,QWORD PTR [rsp+0x30]
            if (amt_read < buf.len) return error.EndOfStream;
  229153:	48 3b 44 24 18       	cmp    rax,QWORD PTR [rsp+0x18]
  229158:	0f 82 bb 00 00 00    	jb     229219 <printSourceAtAddressLinux+0x1589>
            return result[0];
  22915e:	0f b6 44 24 50       	movzx  eax,BYTE PTR [rsp+0x50]
                standard_opcode_lengths[i] = try in_stream.readByte();
  229163:	48 8b 8c 24 08 02 00 	mov    rcx,QWORD PTR [rsp+0x208]
  22916a:	00 
  22916b:	88 04 19             	mov    BYTE PTR [rcx+rbx*1],al
            while (i < opcode_base - 1) : (i += 1) {
  22916e:	48 83 c3 01          	add    rbx,0x1
  229172:	48 3b 9c 24 68 01 00 	cmp    rbx,QWORD PTR [rsp+0x168]
  229179:	00 
  22917a:	72 9c                	jb     229118 <printSourceAtAddressLinux+0x1488>
  22917c:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  229181:	48 8b b0 a0 00 00 00 	mov    rsi,QWORD PTR [rax+0xa0]
  229188:	e9 0a ff ff ff       	jmp    229097 <printSourceAtAddressLinux+0x1407>
  22918d:	c5 f8 10 44 24 30    	vmovups xmm0,XMMWORD PTR [rsp+0x30]
  229193:	c5 f8 29 84 24 a0 01 	vmovaps XMMWORD PTR [rsp+0x1a0],xmm0
  22919a:	00 00 
            const result = &self.items[self.len];
  22919c:	48 8b 84 24 a0 01 00 	mov    rax,QWORD PTR [rsp+0x1a0]
  2291a3:	00 
  2291a4:	48 8b 8c 24 b0 01 00 	mov    rcx,QWORD PTR [rsp+0x1b0]
  2291ab:	00 
  2291ac:	48 c1 e1 04          	shl    rcx,0x4
            self.len = new_length;
  2291b0:	48 c7 84 24 b0 01 00 	mov    QWORD PTR [rsp+0x1b0],0x1
  2291b7:	00 01 00 00 00 
            new_item_ptr.* = item;
  2291bc:	c5 f9 6f 84 24 80 03 	vmovdqa xmm0,XMMWORD PTR [rsp+0x380]
  2291c3:	00 00 
  2291c5:	c5 fa 7f 04 08       	vmovdqu XMMWORD PTR [rax+rcx*1],xmm0
  2291ca:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
            var in_file_stream = io.FileInStream.init(&self.self_exe_file);
  2291cf:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  2291d4:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
  2291d9:	48 8d 0d 80 af ff ff 	lea    rcx,[rip+0xffffffffffffaf80]        # 224160 <FileInStream_readFn>
  2291e0:	48 89 4c 24 18       	mov    QWORD PTR [rsp+0x18],rcx
  2291e5:	48 8b b0 a0 00 00 00 	mov    rsi,QWORD PTR [rax+0xa0]
  2291ec:	48 8d 7c 24 28       	lea    rdi,[rsp+0x28]
            return readStringRaw(self.allocator(), in_stream);
  2291f1:	e8 3a e6 ff ff       	call   227830 <readStringRaw>
  2291f6:	44 0f b7 6c 24 28    	movzx  r13d,WORD PTR [rsp+0x28]
            const dir = try di.readString();
  2291fc:	66 45 85 ed          	test   r13w,r13w
  229200:	74 33                	je     229235 <printSourceAtAddressLinux+0x15a5>
  229202:	c5 fc 10 84 24 da 08 	vmovups ymm0,YMMWORD PTR [rsp+0x8da]
  229209:	00 00 
  22920b:	c5 fe 6f 8c 24 e8 08 	vmovdqu ymm1,YMMWORD PTR [rsp+0x8e8]
  229212:	00 00 
  229214:	e9 e0 f9 ff ff       	jmp    228bf9 <printSourceAtAddressLinux+0xf69>
  229219:	66 41 bd 25 00       	mov    r13w,0x25
                standard_opcode_lengths[i] = try in_stream.readByte();
  22921e:	c5 fc 10 84 24 36 09 	vmovups ymm0,YMMWORD PTR [rsp+0x936]
  229225:	00 00 
  229227:	c5 fe 6f 8c 24 44 09 	vmovdqu ymm1,YMMWORD PTR [rsp+0x944]
  22922e:	00 00 
  229230:	e9 c4 f9 ff ff       	jmp    228bf9 <printSourceAtAddressLinux+0xf69>
  229235:	4d 01 f7             	add    r15,r14
  229238:	c5 f8 10 44 24 30    	vmovups xmm0,XMMWORD PTR [rsp+0x30]
  22923e:	c5 f8 29 84 24 f0 01 	vmovaps XMMWORD PTR [rsp+0x1f0],xmm0
  229245:	00 00 
  229247:	4c 8d 74 24 28       	lea    r14,[rsp+0x28]
            if (dir.len == 0) break;
  22924c:	c5 f9 6f 84 24 f0 01 	vmovdqa xmm0,XMMWORD PTR [rsp+0x1f0]
  229253:	00 00 
  229255:	c4 e3 f9 16 c0 01    	vpextrq rax,xmm0,0x1
  22925b:	48 85 c0             	test   rax,rax
  22925e:	0f 84 e2 00 00 00    	je     229346 <printSourceAtAddressLinux+0x16b6>
            const new_length = self.len + 1;
  229264:	48 8b 9c 24 b0 01 00 	mov    rbx,QWORD PTR [rsp+0x1b0]
  22926b:	00 
            var better_capacity = self.items.len;
  22926c:	48 8b 8c 24 a8 01 00 	mov    rcx,QWORD PTR [rsp+0x1a8]
  229273:	00 
            if (better_capacity >= new_capacity) return;
  229274:	48 39 d9             	cmp    rcx,rbx
  229277:	76 05                	jbe    22927e <printSourceAtAddressLinux+0x15ee>
            const result = &self.items[self.len];
  229279:	48 89 d8             	mov    rax,rbx
  22927c:	eb 54                	jmp    2292d2 <printSourceAtAddressLinux+0x1642>
                better_capacity += better_capacity / 2 + 8;
  22927e:	48 89 c8             	mov    rax,rcx
  229281:	48 d1 e8             	shr    rax,1
  229284:	48 01 c1             	add    rcx,rax
  229287:	48 83 c1 08          	add    rcx,0x8
                if (better_capacity >= new_capacity) break;
  22928b:	48 39 d9             	cmp    rcx,rbx
  22928e:	76 ee                	jbe    22927e <printSourceAtAddressLinux+0x15ee>
            self.items = try self.allocator.alignedRealloc(T, A, self.items, better_capacity);
  229290:	48 8b b4 24 b8 01 00 	mov    rsi,QWORD PTR [rsp+0x1b8]
  229297:	00 
  229298:	4c 89 f7             	mov    rdi,r14
  22929b:	48 8d 94 24 a0 01 00 	lea    rdx,[rsp+0x1a0]
  2292a2:	00 
  2292a3:	e8 18 22 00 00       	call   22b4c0 <Allocator_alignedRealloc.186>
  2292a8:	44 0f b7 6c 24 28    	movzx  r13d,WORD PTR [rsp+0x28]
  2292ae:	66 45 85 ed          	test   r13w,r13w
  2292b2:	0f 85 a1 01 00 00    	jne    229459 <printSourceAtAddressLinux+0x17c9>
  2292b8:	48 8d 44 24 30       	lea    rax,[rsp+0x30]
  2292bd:	c5 fa 6f 00          	vmovdqu xmm0,XMMWORD PTR [rax]
  2292c1:	c5 f9 7f 84 24 a0 01 	vmovdqa XMMWORD PTR [rsp+0x1a0],xmm0
  2292c8:	00 00 
            const result = &self.items[self.len];
  2292ca:	48 8b 84 24 b0 01 00 	mov    rax,QWORD PTR [rsp+0x1b0]
  2292d1:	00 
  2292d2:	48 83 c3 01          	add    rbx,0x1
  2292d6:	48 8b 8c 24 a0 01 00 	mov    rcx,QWORD PTR [rsp+0x1a0]
  2292dd:	00 
  2292de:	48 c1 e0 04          	shl    rax,0x4
            self.len = new_length;
  2292e2:	48 89 9c 24 b0 01 00 	mov    QWORD PTR [rsp+0x1b0],rbx
  2292e9:	00 
            new_item_ptr.* = item;
  2292ea:	c5 f8 28 84 24 f0 01 	vmovaps xmm0,XMMWORD PTR [rsp+0x1f0]
  2292f1:	00 00 
  2292f3:	c5 f8 11 04 01       	vmovups XMMWORD PTR [rcx+rax*1],xmm0
  2292f8:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
            var in_file_stream = io.FileInStream.init(&self.self_exe_file);
  2292fd:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  229302:	48 8d 0d 57 ae ff ff 	lea    rcx,[rip+0xffffffffffffae57]        # 224160 <FileInStream_readFn>
  229309:	48 89 4c 24 18       	mov    QWORD PTR [rsp+0x18],rcx
  22930e:	48 8b b0 a0 00 00 00 	mov    rsi,QWORD PTR [rax+0xa0]
            return readStringRaw(self.allocator(), in_stream);
  229315:	4c 89 f7             	mov    rdi,r14
  229318:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
  22931d:	e8 0e e5 ff ff       	call   227830 <readStringRaw>
  229322:	44 0f b7 6c 24 28    	movzx  r13d,WORD PTR [rsp+0x28]
  229328:	c5 fa 6f 44 24 30    	vmovdqu xmm0,XMMWORD PTR [rsp+0x30]
            const dir = try di.readString();
  22932e:	c5 f9 7f 84 24 f0 01 	vmovdqa XMMWORD PTR [rsp+0x1f0],xmm0
  229335:	00 00 
  229337:	66 45 85 ed          	test   r13w,r13w
  22933b:	0f 84 0b ff ff ff    	je     22924c <printSourceAtAddressLinux+0x15bc>
  229341:	e9 bc fe ff ff       	jmp    229202 <printSourceAtAddressLinux+0x1572>
  229346:	48 8b 54 24 68       	mov    rdx,QWORD PTR [rsp+0x68]
  22934b:	48 8b b2 a0 00 00 00 	mov    rsi,QWORD PTR [rdx+0xa0]
            return Self{
  229352:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  229356:	c5 f9 7f 84 24 70 01 	vmovdqa XMMWORD PTR [rsp+0x170],xmm0
  22935d:	00 00 
  22935f:	48 c7 84 24 80 01 00 	mov    QWORD PTR [rsp+0x180],0x0
  229366:	00 00 00 00 00 
        var file_entries = ArrayList(FileEntry).init(di.allocator());
  22936b:	48 89 b4 24 88 01 00 	mov    QWORD PTR [rsp+0x188],rsi
  229372:	00 
        var prog = LineNumberProgram.init(default_is_stmt, include_directories.toSliceConst(), &file_entries, target_address);
  229373:	c5 fc 28 05 65 6e fd 	vmovaps ymm0,YMMWORD PTR [rip+0xfffffffffffd6e65]        # 2001e0 <__unnamed_29-0x20>
  22937a:	ff 
  22937b:	c5 fc 11 84 24 b0 00 	vmovups YMMWORD PTR [rsp+0xb0],ymm0
  229382:	00 00 
        const default_is_stmt = (try in_stream.readByte()) != 0;
  229384:	40 84 ed             	test   bpl,bpl
        var prog = LineNumberProgram.init(default_is_stmt, include_directories.toSliceConst(), &file_entries, target_address);
  229387:	0f 95 84 24 d0 00 00 	setne  BYTE PTR [rsp+0xd0]
  22938e:	00 
  22938f:	66 c7 84 24 d1 00 00 	mov    WORD PTR [rsp+0xd1],0x0
  229396:	00 00 00 
  229399:	8b 84 24 03 02 00 00 	mov    eax,DWORD PTR [rsp+0x203]
  2293a0:	89 84 24 d3 00 00 00 	mov    DWORD PTR [rsp+0xd3],eax
            return self.items[0..self.len];
  2293a7:	48 8b 84 24 a0 01 00 	mov    rax,QWORD PTR [rsp+0x1a0]
  2293ae:	00 
  2293af:	8a 8c 24 07 02 00 00 	mov    cl,BYTE PTR [rsp+0x207]
  2293b6:	88 8c 24 d7 00 00 00 	mov    BYTE PTR [rsp+0xd7],cl
  2293bd:	48 8b 8c 24 c0 01 00 	mov    rcx,QWORD PTR [rsp+0x1c0]
  2293c4:	00 
  2293c5:	48 89 8c 24 d8 00 00 	mov    QWORD PTR [rsp+0xd8],rcx
  2293cc:	00 
  2293cd:	48 89 84 24 e0 00 00 	mov    QWORD PTR [rsp+0xe0],rax
  2293d4:	00 
  2293d5:	48 8b 84 24 b0 01 00 	mov    rax,QWORD PTR [rsp+0x1b0]
  2293dc:	00 
  2293dd:	48 89 84 24 e8 00 00 	mov    QWORD PTR [rsp+0xe8],rax
  2293e4:	00 
  2293e5:	48 8d 84 24 70 01 00 	lea    rax,[rsp+0x170]
  2293ec:	00 
  2293ed:	48 89 84 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rax
  2293f4:	00 
  2293f5:	48 c7 84 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],0x0
  2293fc:	00 00 00 00 00 
  229401:	c5 fe 6f 84 24 e8 0b 	vmovdqu ymm0,YMMWORD PTR [rsp+0xbe8]
  229408:	00 00 
  22940a:	c5 fe 7f 84 24 00 01 	vmovdqu YMMWORD PTR [rsp+0x100],ymm0
  229411:	00 00 
            var in_file_stream = io.FileInStream.init(&self.self_exe_file);
  229413:	48 89 54 24 10       	mov    QWORD PTR [rsp+0x10],rdx
  229418:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
  22941d:	48 8d 05 3c ad ff ff 	lea    rax,[rip+0xffffffffffffad3c]        # 224160 <FileInStream_readFn>
  229424:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  229429:	48 8d 7c 24 28       	lea    rdi,[rsp+0x28]
            return readStringRaw(self.allocator(), in_stream);
  22942e:	c5 f8 77             	vzeroupper 
  229431:	e8 fa e3 ff ff       	call   227830 <readStringRaw>
  229436:	44 0f b7 6c 24 28    	movzx  r13d,WORD PTR [rsp+0x28]
            const file_name = try di.readString();
  22943c:	66 45 85 ed          	test   r13w,r13w
  229440:	74 2e                	je     229470 <printSourceAtAddressLinux+0x17e0>
  229442:	c5 fc 10 84 24 7e 08 	vmovups ymm0,YMMWORD PTR [rsp+0x87e]
  229449:	00 00 
  22944b:	c5 fe 6f 8c 24 8c 08 	vmovdqu ymm1,YMMWORD PTR [rsp+0x88c]
  229452:	00 00 
  229454:	e9 a0 f7 ff ff       	jmp    228bf9 <printSourceAtAddressLinux+0xf69>
            try include_directories.append(dir);
  229459:	c5 fc 10 84 24 ac 08 	vmovups ymm0,YMMWORD PTR [rsp+0x8ac]
  229460:	00 00 
  229462:	c5 fe 6f 8c 24 ba 08 	vmovdqu ymm1,YMMWORD PTR [rsp+0x8ba]
  229469:	00 00 
  22946b:	e9 89 f7 ff ff       	jmp    228bf9 <printSourceAtAddressLinux+0xf69>
  229470:	c5 f8 10 44 24 30    	vmovups xmm0,XMMWORD PTR [rsp+0x30]
  229476:	c5 f8 29 84 24 c0 01 	vmovaps XMMWORD PTR [rsp+0x1c0],xmm0
  22947d:	00 00 
            if (file_name.len == 0) break;
  22947f:	c5 f9 6f 84 24 c0 01 	vmovdqa xmm0,XMMWORD PTR [rsp+0x1c0]
  229486:	00 00 
  229488:	c4 e3 f9 16 c0 01    	vpextrq rax,xmm0,0x1
  22948e:	48 85 c0             	test   rax,rax
  229491:	0f 84 6a 03 00 00    	je     229801 <printSourceAtAddressLinux+0x1b71>
            try self.readNoEof(result[0..]);
  229497:	48 8d 44 24 50       	lea    rax,[rsp+0x50]
  22949c:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  2294a1:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  2294a8:	00 00 
            return self.readFn(self, buffer);
  2294aa:	48 8d 7c 24 28       	lea    rdi,[rsp+0x28]
  2294af:	48 8d 74 24 48       	lea    rsi,[rsp+0x48]
  2294b4:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  2294b9:	ff 54 24 48          	call   QWORD PTR [rsp+0x48]
  2294bd:	44 0f b7 6c 24 28    	movzx  r13d,WORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  2294c3:	66 45 85 ed          	test   r13w,r13w
  2294c7:	0f 85 fa 02 00 00    	jne    2297c7 <printSourceAtAddressLinux+0x1b37>
  2294cd:	48 8b 44 24 30       	mov    rax,QWORD PTR [rsp+0x30]
  2294d2:	45 31 f6             	xor    r14d,r14d
  2294d5:	31 db                	xor    ebx,ebx
            if (amt_read < buf.len) return error.EndOfStream;
  2294d7:	48 3b 44 24 18       	cmp    rax,QWORD PTR [rsp+0x18]
  2294dc:	0f 82 d9 02 00 00    	jb     2297bb <printSourceAtAddressLinux+0x1b2b>
            return result[0];
  2294e2:	0f b6 44 24 50       	movzx  eax,BYTE PTR [rsp+0x50]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  2294e7:	89 c2                	mov    edx,eax
  2294e9:	83 e2 7f             	and    edx,0x7f
  2294ec:	89 de                	mov    esi,ebx
  2294ee:	83 e6 3f             	and    esi,0x3f
  2294f1:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  2294f6:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  2294fb:	48 39 d6             	cmp    rsi,rdx
  2294fe:	0f 85 be 02 00 00    	jne    2297c2 <printSourceAtAddressLinux+0x1b32>
        result |= operand;
  229504:	49 09 ce             	or     r14,rcx
        if ((byte & 0b10000000) == 0) return result;
  229507:	84 c0                	test   al,al
  229509:	79 40                	jns    22954b <printSourceAtAddressLinux+0x18bb>
        shift += 7;
  22950b:	48 83 c3 07          	add    rbx,0x7
            try self.readNoEof(result[0..]);
  22950f:	48 8d 44 24 50       	lea    rax,[rsp+0x50]
  229514:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  229519:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  229520:	00 00 
            return self.readFn(self, buffer);
  229522:	48 8d 7c 24 28       	lea    rdi,[rsp+0x28]
  229527:	48 8d 74 24 48       	lea    rsi,[rsp+0x48]
  22952c:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  229531:	ff 54 24 48          	call   QWORD PTR [rsp+0x48]
  229535:	44 0f b7 6c 24 28    	movzx  r13d,WORD PTR [rsp+0x28]
  22953b:	48 8b 44 24 30       	mov    rax,QWORD PTR [rsp+0x30]
            const amt_read = try self.read(buf);
  229540:	66 45 85 ed          	test   r13w,r13w
  229544:	74 91                	je     2294d7 <printSourceAtAddressLinux+0x1847>
  229546:	e9 7c 02 00 00       	jmp    2297c7 <printSourceAtAddressLinux+0x1b37>
            try self.readNoEof(result[0..]);
  22954b:	48 8d 44 24 50       	lea    rax,[rsp+0x50]
  229550:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  229555:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  22955c:	00 00 
            return self.readFn(self, buffer);
  22955e:	48 8d 7c 24 28       	lea    rdi,[rsp+0x28]
  229563:	48 8d 74 24 48       	lea    rsi,[rsp+0x48]
  229568:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  22956d:	ff 54 24 48          	call   QWORD PTR [rsp+0x48]
  229571:	44 0f b7 6c 24 28    	movzx  r13d,WORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  229577:	66 45 85 ed          	test   r13w,r13w
  22957b:	0f 85 69 02 00 00    	jne    2297ea <printSourceAtAddressLinux+0x1b5a>
  229581:	48 8b 44 24 30       	mov    rax,QWORD PTR [rsp+0x30]
  229586:	31 ed                	xor    ebp,ebp
  229588:	31 db                	xor    ebx,ebx
            if (amt_read < buf.len) return error.EndOfStream;
  22958a:	48 3b 44 24 18       	cmp    rax,QWORD PTR [rsp+0x18]
  22958f:	0f 82 49 02 00 00    	jb     2297de <printSourceAtAddressLinux+0x1b4e>
            return result[0];
  229595:	0f b6 44 24 50       	movzx  eax,BYTE PTR [rsp+0x50]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  22959a:	89 c2                	mov    edx,eax
  22959c:	83 e2 7f             	and    edx,0x7f
  22959f:	89 de                	mov    esi,ebx
  2295a1:	83 e6 3f             	and    esi,0x3f
  2295a4:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  2295a9:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  2295ae:	48 39 d6             	cmp    rsi,rdx
  2295b1:	0f 85 2e 02 00 00    	jne    2297e5 <printSourceAtAddressLinux+0x1b55>
        result |= operand;
  2295b7:	48 09 cd             	or     rbp,rcx
        if ((byte & 0b10000000) == 0) return result;
  2295ba:	84 c0                	test   al,al
  2295bc:	79 40                	jns    2295fe <printSourceAtAddressLinux+0x196e>
        shift += 7;
  2295be:	48 83 c3 07          	add    rbx,0x7
            try self.readNoEof(result[0..]);
  2295c2:	48 8d 44 24 50       	lea    rax,[rsp+0x50]
  2295c7:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  2295cc:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  2295d3:	00 00 
            return self.readFn(self, buffer);
  2295d5:	48 8d 7c 24 28       	lea    rdi,[rsp+0x28]
  2295da:	48 8d 74 24 48       	lea    rsi,[rsp+0x48]
  2295df:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  2295e4:	ff 54 24 48          	call   QWORD PTR [rsp+0x48]
  2295e8:	44 0f b7 6c 24 28    	movzx  r13d,WORD PTR [rsp+0x28]
  2295ee:	48 8b 44 24 30       	mov    rax,QWORD PTR [rsp+0x30]
            const amt_read = try self.read(buf);
  2295f3:	66 45 85 ed          	test   r13w,r13w
  2295f7:	74 91                	je     22958a <printSourceAtAddressLinux+0x18fa>
  2295f9:	e9 ec 01 00 00       	jmp    2297ea <printSourceAtAddressLinux+0x1b5a>
            try self.readNoEof(result[0..]);
  2295fe:	48 8d 44 24 50       	lea    rax,[rsp+0x50]
  229603:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  229608:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  22960f:	00 00 
            return self.readFn(self, buffer);
  229611:	48 8d 7c 24 28       	lea    rdi,[rsp+0x28]
  229616:	48 8d 74 24 48       	lea    rsi,[rsp+0x48]
  22961b:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  229620:	ff 54 24 48          	call   QWORD PTR [rsp+0x48]
  229624:	44 0f b7 6c 24 28    	movzx  r13d,WORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  22962a:	66 45 85 ed          	test   r13w,r13w
  22962e:	0f 85 26 02 00 00    	jne    22985a <printSourceAtAddressLinux+0x1bca>
  229634:	48 8b 44 24 30       	mov    rax,QWORD PTR [rsp+0x30]
  229639:	31 c9                	xor    ecx,ecx
  22963b:	48 89 8c 24 f0 01 00 	mov    QWORD PTR [rsp+0x1f0],rcx
  229642:	00 
  229643:	31 db                	xor    ebx,ebx
            if (amt_read < buf.len) return error.EndOfStream;
  229645:	48 3b 44 24 18       	cmp    rax,QWORD PTR [rsp+0x18]
  22964a:	0f 82 fe 01 00 00    	jb     22984e <printSourceAtAddressLinux+0x1bbe>
            return result[0];
  229650:	0f b6 44 24 50       	movzx  eax,BYTE PTR [rsp+0x50]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  229655:	89 c2                	mov    edx,eax
  229657:	83 e2 7f             	and    edx,0x7f
  22965a:	89 de                	mov    esi,ebx
  22965c:	83 e6 3f             	and    esi,0x3f
  22965f:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  229664:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  229669:	48 39 d6             	cmp    rsi,rdx
  22966c:	0f 85 e3 01 00 00    	jne    229855 <printSourceAtAddressLinux+0x1bc5>
        result |= operand;
  229672:	48 09 8c 24 f0 01 00 	or     QWORD PTR [rsp+0x1f0],rcx
  229679:	00 
        if ((byte & 0b10000000) == 0) return result;
  22967a:	84 c0                	test   al,al
  22967c:	79 40                	jns    2296be <printSourceAtAddressLinux+0x1a2e>
        shift += 7;
  22967e:	48 83 c3 07          	add    rbx,0x7
            try self.readNoEof(result[0..]);
  229682:	48 8d 44 24 50       	lea    rax,[rsp+0x50]
  229687:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  22968c:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  229693:	00 00 
            return self.readFn(self, buffer);
  229695:	48 8d 7c 24 28       	lea    rdi,[rsp+0x28]
  22969a:	48 8d 74 24 48       	lea    rsi,[rsp+0x48]
  22969f:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  2296a4:	ff 54 24 48          	call   QWORD PTR [rsp+0x48]
  2296a8:	44 0f b7 6c 24 28    	movzx  r13d,WORD PTR [rsp+0x28]
  2296ae:	48 8b 44 24 30       	mov    rax,QWORD PTR [rsp+0x30]
            const amt_read = try self.read(buf);
  2296b3:	66 45 85 ed          	test   r13w,r13w
  2296b7:	74 8c                	je     229645 <printSourceAtAddressLinux+0x19b5>
  2296b9:	e9 9c 01 00 00       	jmp    22985a <printSourceAtAddressLinux+0x1bca>
            const new_length = self.len + 1;
  2296be:	48 8b 9c 24 80 01 00 	mov    rbx,QWORD PTR [rsp+0x180]
  2296c5:	00 
            var better_capacity = self.items.len;
  2296c6:	48 8b 8c 24 78 01 00 	mov    rcx,QWORD PTR [rsp+0x178]
  2296cd:	00 
            if (better_capacity >= new_capacity) return;
  2296ce:	48 39 d9             	cmp    rcx,rbx
  2296d1:	76 05                	jbe    2296d8 <printSourceAtAddressLinux+0x1a48>
            const result = &self.items[self.len];
  2296d3:	48 89 d8             	mov    rax,rbx
  2296d6:	eb 56                	jmp    22972e <printSourceAtAddressLinux+0x1a9e>
                better_capacity += better_capacity / 2 + 8;
  2296d8:	48 89 c8             	mov    rax,rcx
  2296db:	48 d1 e8             	shr    rax,1
  2296de:	48 01 c1             	add    rcx,rax
  2296e1:	48 83 c1 08          	add    rcx,0x8
                if (better_capacity >= new_capacity) break;
  2296e5:	48 39 d9             	cmp    rcx,rbx
  2296e8:	76 ee                	jbe    2296d8 <printSourceAtAddressLinux+0x1a48>
            self.items = try self.allocator.alignedRealloc(T, A, self.items, better_capacity);
  2296ea:	48 8b b4 24 88 01 00 	mov    rsi,QWORD PTR [rsp+0x188]
  2296f1:	00 
  2296f2:	48 8d 7c 24 28       	lea    rdi,[rsp+0x28]
  2296f7:	48 8d 94 24 70 01 00 	lea    rdx,[rsp+0x170]
  2296fe:	00 
  2296ff:	e8 2c 20 00 00       	call   22b730 <Allocator_alignedRealloc.189>
  229704:	44 0f b7 6c 24 28    	movzx  r13d,WORD PTR [rsp+0x28]
  22970a:	66 45 85 ed          	test   r13w,r13w
  22970e:	0f 85 40 0d 00 00    	jne    22a454 <printSourceAtAddressLinux+0x27c4>
  229714:	48 8d 44 24 30       	lea    rax,[rsp+0x30]
  229719:	c5 fa 6f 00          	vmovdqu xmm0,XMMWORD PTR [rax]
  22971d:	c5 f9 7f 84 24 70 01 	vmovdqa XMMWORD PTR [rsp+0x170],xmm0
  229724:	00 00 
            const result = &self.items[self.len];
  229726:	48 8b 84 24 80 01 00 	mov    rax,QWORD PTR [rsp+0x180]
  22972d:	00 
  22972e:	48 83 c3 01          	add    rbx,0x1
  229732:	48 8b 8c 24 70 01 00 	mov    rcx,QWORD PTR [rsp+0x170]
  229739:	00 
  22973a:	48 8d 04 80          	lea    rax,[rax+rax*4]
            self.len = new_length;
  22973e:	48 89 9c 24 80 01 00 	mov    QWORD PTR [rsp+0x180],rbx
  229745:	00 
            new_item_ptr.* = item;
  229746:	c5 f8 28 84 24 c0 01 	vmovaps xmm0,XMMWORD PTR [rsp+0x1c0]
  22974d:	00 00 
  22974f:	c5 f8 11 04 c1       	vmovups XMMWORD PTR [rcx+rax*8],xmm0
  229754:	4c 89 74 c1 10       	mov    QWORD PTR [rcx+rax*8+0x10],r14
  229759:	48 89 6c c1 18       	mov    QWORD PTR [rcx+rax*8+0x18],rbp
  22975e:	48 8b 94 24 f0 01 00 	mov    rdx,QWORD PTR [rsp+0x1f0]
  229765:	00 
  229766:	48 89 54 c1 20       	mov    QWORD PTR [rcx+rax*8+0x20],rdx
  22976b:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
            var in_file_stream = io.FileInStream.init(&self.self_exe_file);
  229770:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  229775:	48 8d 0d e4 a9 ff ff 	lea    rcx,[rip+0xffffffffffffa9e4]        # 224160 <FileInStream_readFn>
  22977c:	48 89 4c 24 18       	mov    QWORD PTR [rsp+0x18],rcx
  229781:	48 8b b0 a0 00 00 00 	mov    rsi,QWORD PTR [rax+0xa0]
            return readStringRaw(self.allocator(), in_stream);
  229788:	48 8d 7c 24 28       	lea    rdi,[rsp+0x28]
  22978d:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
  229792:	e8 99 e0 ff ff       	call   227830 <readStringRaw>
  229797:	44 0f b7 6c 24 28    	movzx  r13d,WORD PTR [rsp+0x28]
  22979d:	c5 fa 6f 44 24 30    	vmovdqu xmm0,XMMWORD PTR [rsp+0x30]
            const file_name = try di.readString();
  2297a3:	c5 f9 7f 84 24 c0 01 	vmovdqa XMMWORD PTR [rsp+0x1c0],xmm0
  2297aa:	00 00 
  2297ac:	66 45 85 ed          	test   r13w,r13w
  2297b0:	0f 84 c9 fc ff ff    	je     22947f <printSourceAtAddressLinux+0x17ef>
  2297b6:	e9 87 fc ff ff       	jmp    229442 <printSourceAtAddressLinux+0x17b2>
  2297bb:	66 41 bd 25 00       	mov    r13w,0x25
  2297c0:	eb 05                	jmp    2297c7 <printSourceAtAddressLinux+0x1b37>
  2297c2:	66 41 bd 29 00       	mov    r13w,0x29
            const dir_index = try readULeb128(in_stream);
  2297c7:	c5 fc 10 84 24 50 08 	vmovups ymm0,YMMWORD PTR [rsp+0x850]
  2297ce:	00 00 
  2297d0:	c5 fe 6f 8c 24 5e 08 	vmovdqu ymm1,YMMWORD PTR [rsp+0x85e]
  2297d7:	00 00 
  2297d9:	e9 1b f4 ff ff       	jmp    228bf9 <printSourceAtAddressLinux+0xf69>
  2297de:	66 41 bd 25 00       	mov    r13w,0x25
  2297e3:	eb 05                	jmp    2297ea <printSourceAtAddressLinux+0x1b5a>
  2297e5:	66 41 bd 29 00       	mov    r13w,0x29
            const mtime = try readULeb128(in_stream);
  2297ea:	c5 fc 10 84 24 22 08 	vmovups ymm0,YMMWORD PTR [rsp+0x822]
  2297f1:	00 00 
  2297f3:	c5 fe 6f 8c 24 30 08 	vmovdqu ymm1,YMMWORD PTR [rsp+0x830]
  2297fa:	00 00 
  2297fc:	e9 f8 f3 ff ff       	jmp    228bf9 <printSourceAtAddressLinux+0xf69>
  229801:	4d 85 ff             	test   r15,r15
  229804:	78 6b                	js     229871 <printSourceAtAddressLinux+0x1be1>
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  229806:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  22980b:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  22980e:	31 db                	xor    ebx,ebx
  229810:	b8 08 00 00 00       	mov    eax,0x8
  229815:	31 d2                	xor    edx,edx
  229817:	4c 89 fe             	mov    rsi,r15
  22981a:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  22981c:	48 89 c1             	mov    rcx,rax
  22981f:	48 f7 d9             	neg    rcx
  229822:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  229828:	48 0f 46 cb          	cmovbe rcx,rbx
  22982c:	66 41 bd 03 00       	mov    r13w,0x3
                if (err > 0) {
  229831:	48 83 f9 1d          	cmp    rcx,0x1d
  229835:	77 56                	ja     22988d <printSourceAtAddressLinux+0x1bfd>
  229837:	48 8d 05 1a 7c fd ff 	lea    rax,[rip+0xfffffffffffd7c1a]        # 201458 <__unnamed_621+0x7a0>
  22983e:	48 63 0c 88          	movsxd rcx,DWORD PTR [rax+rcx*4]
  229842:	48 01 c1             	add    rcx,rax
  229845:	ff e1                	jmp    rcx
  229847:	66 41 bd 27 00       	mov    r13w,0x27
  22984c:	eb 28                	jmp    229876 <printSourceAtAddressLinux+0x1be6>
  22984e:	66 41 bd 25 00       	mov    r13w,0x25
  229853:	eb 05                	jmp    22985a <printSourceAtAddressLinux+0x1bca>
  229855:	66 41 bd 29 00       	mov    r13w,0x29
            const len_bytes = try readULeb128(in_stream);
  22985a:	c5 fc 10 84 24 f4 07 	vmovups ymm0,YMMWORD PTR [rsp+0x7f4]
  229861:	00 00 
  229863:	c5 fe 6f 8c 24 02 08 	vmovdqu ymm1,YMMWORD PTR [rsp+0x802]
  22986a:	00 00 
  22986c:	e9 88 f3 ff ff       	jmp    228bf9 <printSourceAtAddressLinux+0xf69>
  229871:	66 41 bd 04 00       	mov    r13w,0x4
        try in_file.seekTo(prog_start_offset);
  229876:	c5 fc 10 84 24 98 07 	vmovups ymm0,YMMWORD PTR [rsp+0x798]
  22987d:	00 00 
  22987f:	c5 fe 6f 8c 24 a6 07 	vmovdqu ymm1,YMMWORD PTR [rsp+0x7a6]
  229886:	00 00 
  229888:	e9 6c f3 ff ff       	jmp    228bf9 <printSourceAtAddressLinux+0xf69>
  22988d:	48 83 f9 4b          	cmp    rcx,0x4b
  229891:	75 e3                	jne    229876 <printSourceAtAddressLinux+0x1be6>
  229893:	eb b2                	jmp    229847 <printSourceAtAddressLinux+0x1bb7>
            try self.readNoEof(result[0..]);
  229895:	48 8d 44 24 50       	lea    rax,[rsp+0x50]
  22989a:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  22989f:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  2298a6:	00 00 
  2298a8:	48 8d 7c 24 28       	lea    rdi,[rsp+0x28]
  2298ad:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
            return self.readFn(self, buffer);
  2298b2:	48 8d 74 24 48       	lea    rsi,[rsp+0x48]
  2298b7:	ff 54 24 48          	call   QWORD PTR [rsp+0x48]
  2298bb:	44 0f b7 6c 24 28    	movzx  r13d,WORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  2298c1:	66 45 85 ed          	test   r13w,r13w
  2298c5:	74 17                	je     2298de <printSourceAtAddressLinux+0x1c4e>
            const opcode = try in_stream.readByte();
  2298c7:	c5 fc 10 84 24 6a 07 	vmovups ymm0,YMMWORD PTR [rsp+0x76a]
  2298ce:	00 00 
  2298d0:	c5 fe 6f 8c 24 78 07 	vmovdqu ymm1,YMMWORD PTR [rsp+0x778]
  2298d7:	00 00 
  2298d9:	e9 1b f3 ff ff       	jmp    228bf9 <printSourceAtAddressLinux+0xf69>
  2298de:	48 8b 44 24 30       	mov    rax,QWORD PTR [rsp+0x30]
  2298e3:	8a 4c 24 67          	mov    cl,BYTE PTR [rsp+0x67]
  2298e7:	f6 d1                	not    cl
  2298e9:	88 8c 24 c0 01 00 00 	mov    BYTE PTR [rsp+0x1c0],cl
            if (amt_read < buf.len) return error.EndOfStream;
  2298f0:	48 3b 44 24 18       	cmp    rax,QWORD PTR [rsp+0x18]
  2298f5:	0f 82 70 0b 00 00    	jb     22a46b <printSourceAtAddressLinux+0x27db>
            return result[0];
  2298fb:	8a 44 24 50          	mov    al,BYTE PTR [rsp+0x50]
            if (opcode == DW.LNS_extended_op) {
  2298ff:	84 c0                	test   al,al
  229901:	74 64                	je     229967 <printSourceAtAddressLinux+0x1cd7>
            } else if (opcode >= opcode_base) {
  229903:	89 c1                	mov    ecx,eax
  229905:	2a 4c 24 67          	sub    cl,BYTE PTR [rsp+0x67]
  229909:	0f 83 0f 01 00 00    	jae    229a1e <printSourceAtAddressLinux+0x1d8e>
                switch (opcode) {
  22990f:	04 ff                	add    al,0xff
  229911:	0f b6 c0             	movzx  eax,al
  229914:	3c 09                	cmp    al,0x9
  229916:	0f 87 5a 02 00 00    	ja     229b76 <printSourceAtAddressLinux+0x1ee6>
  22991c:	48 8d 0d ad 7b fd ff 	lea    rcx,[rip+0xfffffffffffd7bad]        # 2014d0 <__unnamed_621+0x818>
  229923:	48 63 04 81          	movsxd rax,DWORD PTR [rcx+rax*4]
  229927:	48 01 c8             	add    rax,rcx
  22992a:	ff e0                	jmp    rax
                        if (try prog.checkLineMatch()) |info| return info;
  22992c:	48 8d bc 24 e8 02 00 	lea    rdi,[rsp+0x2e8]
  229933:	00 
  229934:	48 8d b4 24 b0 00 00 	lea    rsi,[rsp+0xb0]
  22993b:	00 
  22993c:	e8 9f 19 00 00       	call   22b2e0 <LineNumberProgram_checkLineMatch>
  229941:	44 0f b7 ac 24 e8 02 	movzx  r13d,WORD PTR [rsp+0x2e8]
  229948:	00 00 
  22994a:	66 45 85 ed          	test   r13w,r13w
  22994e:	0f 85 32 0c 00 00    	jne    22a586 <printSourceAtAddressLinux+0x28f6>
  229954:	80 bc 24 18 03 00 00 	cmp    BYTE PTR [rsp+0x318],0x1
  22995b:	01 
  22995c:	0f 85 1d 01 00 00    	jne    229a7f <printSourceAtAddressLinux+0x1def>
  229962:	e9 36 0c 00 00       	jmp    22a59d <printSourceAtAddressLinux+0x290d>
            try self.readNoEof(result[0..]);
  229967:	48 8d 44 24 50       	lea    rax,[rsp+0x50]
  22996c:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  229971:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  229978:	00 00 
            return self.readFn(self, buffer);
  22997a:	48 8d 7c 24 28       	lea    rdi,[rsp+0x28]
  22997f:	48 8d 74 24 48       	lea    rsi,[rsp+0x48]
  229984:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  229989:	ff 54 24 48          	call   QWORD PTR [rsp+0x48]
  22998d:	44 0f b7 6c 24 28    	movzx  r13d,WORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  229993:	66 45 85 ed          	test   r13w,r13w
  229997:	0f 85 a0 0a 00 00    	jne    22a43d <printSourceAtAddressLinux+0x27ad>
  22999d:	48 8b 44 24 30       	mov    rax,QWORD PTR [rsp+0x30]
  2299a2:	31 ed                	xor    ebp,ebp
  2299a4:	31 db                	xor    ebx,ebx
            if (amt_read < buf.len) return error.EndOfStream;
  2299a6:	48 3b 44 24 18       	cmp    rax,QWORD PTR [rsp+0x18]
  2299ab:	0f 82 80 0a 00 00    	jb     22a431 <printSourceAtAddressLinux+0x27a1>
            return result[0];
  2299b1:	0f b6 44 24 50       	movzx  eax,BYTE PTR [rsp+0x50]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  2299b6:	89 c2                	mov    edx,eax
  2299b8:	83 e2 7f             	and    edx,0x7f
  2299bb:	89 de                	mov    esi,ebx
  2299bd:	83 e6 3f             	and    esi,0x3f
  2299c0:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  2299c5:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  2299ca:	48 39 d6             	cmp    rsi,rdx
  2299cd:	0f 85 65 0a 00 00    	jne    22a438 <printSourceAtAddressLinux+0x27a8>
        result |= operand;
  2299d3:	48 09 cd             	or     rbp,rcx
        if ((byte & 0b10000000) == 0) return result;
  2299d6:	84 c0                	test   al,al
  2299d8:	0f 89 e9 00 00 00    	jns    229ac7 <printSourceAtAddressLinux+0x1e37>
        shift += 7;
  2299de:	48 83 c3 07          	add    rbx,0x7
            try self.readNoEof(result[0..]);
  2299e2:	48 8d 44 24 50       	lea    rax,[rsp+0x50]
  2299e7:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  2299ec:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  2299f3:	00 00 
            return self.readFn(self, buffer);
  2299f5:	48 8d 7c 24 28       	lea    rdi,[rsp+0x28]
  2299fa:	48 8d 74 24 48       	lea    rsi,[rsp+0x48]
  2299ff:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  229a04:	ff 54 24 48          	call   QWORD PTR [rsp+0x48]
  229a08:	44 0f b7 6c 24 28    	movzx  r13d,WORD PTR [rsp+0x28]
  229a0e:	48 8b 44 24 30       	mov    rax,QWORD PTR [rsp+0x30]
            const amt_read = try self.read(buf);
  229a13:	66 45 85 ed          	test   r13w,r13w
  229a17:	74 8d                	je     2299a6 <printSourceAtAddressLinux+0x1d16>
  229a19:	e9 1f 0a 00 00       	jmp    22a43d <printSourceAtAddressLinux+0x27ad>
                const inc_line = i32(line_base) + i32(adjusted_opcode % line_range);
  229a1e:	0f b6 c1             	movzx  eax,cl
  229a21:	f6 b4 24 98 01 00 00 	div    BYTE PTR [rsp+0x198]
  229a28:	0f b6 cc             	movzx  ecx,ah
  229a2b:	48 03 8c 24 40 03 00 	add    rcx,QWORD PTR [rsp+0x340]
  229a32:	00 
                prog.line += inc_line;
  229a33:	48 01 8c 24 c0 00 00 	add    QWORD PTR [rsp+0xc0],rcx
  229a3a:	00 
                const inc_addr = minimum_instruction_length * (adjusted_opcode / line_range);
  229a3b:	41 f6 e4             	mul    r12b
                prog.address += inc_addr;
  229a3e:	0f b6 c0             	movzx  eax,al
  229a41:	48 01 84 24 b0 00 00 	add    QWORD PTR [rsp+0xb0],rax
  229a48:	00 
                if (try prog.checkLineMatch()) |info| return info;
  229a49:	48 8d bc 24 28 02 00 	lea    rdi,[rsp+0x228]
  229a50:	00 
  229a51:	48 8d b4 24 b0 00 00 	lea    rsi,[rsp+0xb0]
  229a58:	00 
  229a59:	e8 82 18 00 00       	call   22b2e0 <LineNumberProgram_checkLineMatch>
  229a5e:	44 0f b7 ac 24 28 02 	movzx  r13d,WORD PTR [rsp+0x228]
  229a65:	00 00 
  229a67:	66 45 85 ed          	test   r13w,r13w
  229a6b:	0f 85 04 0a 00 00    	jne    22a475 <printSourceAtAddressLinux+0x27e5>
  229a71:	80 bc 24 58 02 00 00 	cmp    BYTE PTR [rsp+0x258],0x1
  229a78:	01 
  229a79:	0f 84 0d 0a 00 00    	je     22a48c <printSourceAtAddressLinux+0x27fc>
  229a7f:	c6 84 24 d1 00 00 00 	mov    BYTE PTR [rsp+0xd1],0x0
  229a86:	00 
            try self.readNoEof(result[0..]);
  229a87:	48 8d 44 24 50       	lea    rax,[rsp+0x50]
  229a8c:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  229a91:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  229a98:	00 00 
            return self.readFn(self, buffer);
  229a9a:	48 8d 7c 24 28       	lea    rdi,[rsp+0x28]
  229a9f:	48 8d 74 24 48       	lea    rsi,[rsp+0x48]
  229aa4:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  229aa9:	ff 54 24 48          	call   QWORD PTR [rsp+0x48]
  229aad:	44 0f b7 6c 24 28    	movzx  r13d,WORD PTR [rsp+0x28]
  229ab3:	48 8b 44 24 30       	mov    rax,QWORD PTR [rsp+0x30]
            const amt_read = try self.read(buf);
  229ab8:	66 45 85 ed          	test   r13w,r13w
  229abc:	0f 84 2e fe ff ff    	je     2298f0 <printSourceAtAddressLinux+0x1c60>
  229ac2:	e9 00 fe ff ff       	jmp    2298c7 <printSourceAtAddressLinux+0x1c37>
                if (op_size < 1) return error.InvalidDebugInfo;
  229ac7:	48 85 ed             	test   rbp,rbp
  229aca:	0f 84 46 09 00 00    	je     22a416 <printSourceAtAddressLinux+0x2786>
            try self.readNoEof(result[0..]);
  229ad0:	48 8d 44 24 50       	lea    rax,[rsp+0x50]
  229ad5:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  229ada:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  229ae1:	00 00 
            return self.readFn(self, buffer);
  229ae3:	48 8d 7c 24 28       	lea    rdi,[rsp+0x28]
  229ae8:	48 8d 74 24 48       	lea    rsi,[rsp+0x48]
  229aed:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  229af2:	ff 54 24 48          	call   QWORD PTR [rsp+0x48]
  229af6:	44 0f b7 6c 24 28    	movzx  r13d,WORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  229afc:	66 45 85 ed          	test   r13w,r13w
  229b00:	0f 85 db 0a 00 00    	jne    22a5e1 <printSourceAtAddressLinux+0x2951>
  229b06:	48 8b 44 24 30       	mov    rax,QWORD PTR [rsp+0x30]
            if (amt_read < buf.len) return error.EndOfStream;
  229b0b:	48 3b 44 24 18       	cmp    rax,QWORD PTR [rsp+0x18]
  229b10:	0f 82 c6 0a 00 00    	jb     22a5dc <printSourceAtAddressLinux+0x294c>
            return result[0];
  229b16:	8a 44 24 50          	mov    al,BYTE PTR [rsp+0x50]
                switch (sub_op) {
  229b1a:	3c 02                	cmp    al,0x2
  229b1c:	0f 84 40 04 00 00    	je     229f62 <printSourceAtAddressLinux+0x22d2>
  229b22:	3c 03                	cmp    al,0x3
  229b24:	0f 84 f5 04 00 00    	je     22a01f <printSourceAtAddressLinux+0x238f>
  229b2a:	3c 01                	cmp    al,0x1
  229b2c:	0f 84 c6 0a 00 00    	je     22a5f8 <printSourceAtAddressLinux+0x2968>
  229b32:	48 83 c5 ff          	add    rbp,0xffffffffffffffff
  229b36:	0f 88 da 08 00 00    	js     22a416 <printSourceAtAddressLinux+0x2786>
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  229b3c:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  229b41:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  229b44:	b8 08 00 00 00       	mov    eax,0x8
  229b49:	ba 01 00 00 00       	mov    edx,0x1
  229b4e:	48 89 ee             	mov    rsi,rbp
  229b51:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  229b53:	48 89 c1             	mov    rcx,rax
  229b56:	48 f7 d9             	neg    rcx
  229b59:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  229b5f:	b8 00 00 00 00       	mov    eax,0x0
  229b64:	48 0f 46 c8          	cmovbe rcx,rax
                if (err > 0) {
  229b68:	48 85 c9             	test   rcx,rcx
  229b6b:	0f 84 16 ff ff ff    	je     229a87 <printSourceAtAddressLinux+0x1df7>
  229b71:	e9 c9 0a 00 00       	jmp    22a63f <printSourceAtAddressLinux+0x29af>
                        if (opcode - 1 >= standard_opcode_lengths.len) return error.InvalidDebugInfo;
  229b76:	48 39 84 24 68 01 00 	cmp    QWORD PTR [rsp+0x168],rax
  229b7d:	00 
  229b7e:	0f 86 92 08 00 00    	jbe    22a416 <printSourceAtAddressLinux+0x2786>
                        try in_file.seekForward(len_bytes);
  229b84:	48 8b 8c 24 08 02 00 	mov    rcx,QWORD PTR [rsp+0x208]
  229b8b:	00 
  229b8c:	0f b6 34 01          	movzx  esi,BYTE PTR [rcx+rax*1]
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  229b90:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  229b95:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  229b98:	b8 08 00 00 00       	mov    eax,0x8
  229b9d:	ba 01 00 00 00       	mov    edx,0x1
  229ba2:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  229ba4:	48 89 c1             	mov    rcx,rax
  229ba7:	48 f7 d9             	neg    rcx
  229baa:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  229bb0:	b8 00 00 00 00       	mov    eax,0x0
  229bb5:	48 0f 46 c8          	cmovbe rcx,rax
  229bb9:	48 85 c9             	test   rcx,rcx
  229bbc:	0f 84 c5 fe ff ff    	je     229a87 <printSourceAtAddressLinux+0x1df7>
  229bc2:	e9 a6 0a 00 00       	jmp    22a66d <printSourceAtAddressLinux+0x29dd>
            try self.readNoEof(result[0..]);
  229bc7:	48 8d 44 24 50       	lea    rax,[rsp+0x50]
  229bcc:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  229bd1:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  229bd8:	00 00 
            return self.readFn(self, buffer);
  229bda:	48 8d 7c 24 28       	lea    rdi,[rsp+0x28]
  229bdf:	48 8d 74 24 48       	lea    rsi,[rsp+0x48]
  229be4:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  229be9:	ff 54 24 48          	call   QWORD PTR [rsp+0x48]
  229bed:	44 0f b7 6c 24 28    	movzx  r13d,WORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  229bf3:	66 45 85 ed          	test   r13w,r13w
  229bf7:	0f 85 da 08 00 00    	jne    22a4d7 <printSourceAtAddressLinux+0x2847>
  229bfd:	48 8b 44 24 30       	mov    rax,QWORD PTR [rsp+0x30]
  229c02:	45 31 f6             	xor    r14d,r14d
  229c05:	31 db                	xor    ebx,ebx
            if (amt_read < buf.len) return error.EndOfStream;
  229c07:	48 3b 44 24 18       	cmp    rax,QWORD PTR [rsp+0x18]
  229c0c:	0f 82 b9 08 00 00    	jb     22a4cb <printSourceAtAddressLinux+0x283b>
            return result[0];
  229c12:	0f b6 44 24 50       	movzx  eax,BYTE PTR [rsp+0x50]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  229c17:	89 c2                	mov    edx,eax
  229c19:	83 e2 7f             	and    edx,0x7f
  229c1c:	89 de                	mov    esi,ebx
  229c1e:	83 e6 3f             	and    esi,0x3f
  229c21:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  229c26:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  229c2b:	48 39 d6             	cmp    rsi,rdx
  229c2e:	0f 85 9e 08 00 00    	jne    22a4d2 <printSourceAtAddressLinux+0x2842>
        result |= operand;
  229c34:	49 09 ce             	or     r14,rcx
        if ((byte & 0b10000000) == 0) return result;
  229c37:	84 c0                	test   al,al
  229c39:	0f 89 63 05 00 00    	jns    22a1a2 <printSourceAtAddressLinux+0x2512>
        shift += 7;
  229c3f:	48 83 c3 07          	add    rbx,0x7
            try self.readNoEof(result[0..]);
  229c43:	48 8d 44 24 50       	lea    rax,[rsp+0x50]
  229c48:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  229c4d:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  229c54:	00 00 
            return self.readFn(self, buffer);
  229c56:	48 8d 7c 24 28       	lea    rdi,[rsp+0x28]
  229c5b:	48 8d 74 24 48       	lea    rsi,[rsp+0x48]
  229c60:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  229c65:	ff 54 24 48          	call   QWORD PTR [rsp+0x48]
  229c69:	44 0f b7 6c 24 28    	movzx  r13d,WORD PTR [rsp+0x28]
  229c6f:	48 8b 44 24 30       	mov    rax,QWORD PTR [rsp+0x30]
            const amt_read = try self.read(buf);
  229c74:	66 45 85 ed          	test   r13w,r13w
  229c78:	74 8d                	je     229c07 <printSourceAtAddressLinux+0x1f77>
  229c7a:	e9 58 08 00 00       	jmp    22a4d7 <printSourceAtAddressLinux+0x2847>
            try self.readNoEof(result[0..]);
  229c7f:	48 8d 44 24 50       	lea    rax,[rsp+0x50]
  229c84:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  229c89:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  229c90:	00 00 
            return self.readFn(self, buffer);
  229c92:	48 8d 7c 24 28       	lea    rdi,[rsp+0x28]
  229c97:	48 8d 74 24 48       	lea    rsi,[rsp+0x48]
  229c9c:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  229ca1:	ff 54 24 48          	call   QWORD PTR [rsp+0x48]
  229ca5:	44 0f b7 6c 24 28    	movzx  r13d,WORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  229cab:	66 45 85 ed          	test   r13w,r13w
  229caf:	0f 85 45 08 00 00    	jne    22a4fa <printSourceAtAddressLinux+0x286a>
  229cb5:	48 8b 44 24 30       	mov    rax,QWORD PTR [rsp+0x30]
  229cba:	bb 07 00 00 00       	mov    ebx,0x7
  229cbf:	45 31 f6             	xor    r14d,r14d
            if (amt_read < buf.len) return error.EndOfStream;
  229cc2:	48 3b 44 24 18       	cmp    rax,QWORD PTR [rsp+0x18]
  229cc7:	0f 82 21 08 00 00    	jb     22a4ee <printSourceAtAddressLinux+0x285e>
  229ccd:	48 8d 53 f9          	lea    rdx,[rbx-0x7]
            return result[0];
  229cd1:	0f b6 44 24 50       	movzx  eax,BYTE PTR [rsp+0x50]
        if (@shlWithOverflow(i64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  229cd6:	89 c6                	mov    esi,eax
  229cd8:	83 e6 7f             	and    esi,0x7f
  229cdb:	83 e2 3f             	and    edx,0x3f
  229cde:	c4 e2 e9 f7 ce       	shlx   rcx,rsi,rdx
  229ce3:	c4 e2 ea f7 d1       	sarx   rdx,rcx,rdx
  229ce8:	48 39 f2             	cmp    rdx,rsi
  229ceb:	0f 85 04 08 00 00    	jne    22a4f5 <printSourceAtAddressLinux+0x2865>
        result |= operand;
  229cf1:	49 09 ce             	or     r14,rcx
        if ((byte & 0b10000000) == 0) {
  229cf4:	84 c0                	test   al,al
  229cf6:	0f 89 b7 04 00 00    	jns    22a1b3 <printSourceAtAddressLinux+0x2523>
            try self.readNoEof(result[0..]);
  229cfc:	48 8d 44 24 50       	lea    rax,[rsp+0x50]
  229d01:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  229d06:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  229d0d:	00 00 
            return self.readFn(self, buffer);
  229d0f:	48 8d 7c 24 28       	lea    rdi,[rsp+0x28]
  229d14:	48 8d 74 24 48       	lea    rsi,[rsp+0x48]
  229d19:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  229d1e:	ff 54 24 48          	call   QWORD PTR [rsp+0x48]
  229d22:	44 0f b7 6c 24 28    	movzx  r13d,WORD PTR [rsp+0x28]
  229d28:	48 8b 44 24 30       	mov    rax,QWORD PTR [rsp+0x30]
            const amt_read = try self.read(buf);
  229d2d:	48 83 c3 07          	add    rbx,0x7
  229d31:	66 45 85 ed          	test   r13w,r13w
  229d35:	74 8b                	je     229cc2 <printSourceAtAddressLinux+0x2032>
  229d37:	e9 be 07 00 00       	jmp    22a4fa <printSourceAtAddressLinux+0x286a>
            try self.readNoEof(result[0..]);
  229d3c:	48 8d 44 24 50       	lea    rax,[rsp+0x50]
  229d41:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  229d46:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  229d4d:	00 00 
            return self.readFn(self, buffer);
  229d4f:	48 8d 7c 24 28       	lea    rdi,[rsp+0x28]
  229d54:	48 8d 74 24 48       	lea    rsi,[rsp+0x48]
  229d59:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  229d5e:	ff 54 24 48          	call   QWORD PTR [rsp+0x48]
  229d62:	44 0f b7 6c 24 28    	movzx  r13d,WORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  229d68:	66 45 85 ed          	test   r13w,r13w
  229d6c:	0f 85 ab 07 00 00    	jne    22a51d <printSourceAtAddressLinux+0x288d>
  229d72:	48 8b 44 24 30       	mov    rax,QWORD PTR [rsp+0x30]
  229d77:	45 31 f6             	xor    r14d,r14d
  229d7a:	31 db                	xor    ebx,ebx
            if (amt_read < buf.len) return error.EndOfStream;
  229d7c:	48 3b 44 24 18       	cmp    rax,QWORD PTR [rsp+0x18]
  229d81:	0f 82 8a 07 00 00    	jb     22a511 <printSourceAtAddressLinux+0x2881>
            return result[0];
  229d87:	0f b6 44 24 50       	movzx  eax,BYTE PTR [rsp+0x50]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  229d8c:	89 c2                	mov    edx,eax
  229d8e:	83 e2 7f             	and    edx,0x7f
  229d91:	89 de                	mov    esi,ebx
  229d93:	83 e6 3f             	and    esi,0x3f
  229d96:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  229d9b:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  229da0:	48 39 d6             	cmp    rsi,rdx
  229da3:	0f 85 6f 07 00 00    	jne    22a518 <printSourceAtAddressLinux+0x2888>
        result |= operand;
  229da9:	49 09 ce             	or     r14,rcx
        if ((byte & 0b10000000) == 0) return result;
  229dac:	84 c0                	test   al,al
  229dae:	0f 89 25 04 00 00    	jns    22a1d9 <printSourceAtAddressLinux+0x2549>
        shift += 7;
  229db4:	48 83 c3 07          	add    rbx,0x7
            try self.readNoEof(result[0..]);
  229db8:	48 8d 44 24 50       	lea    rax,[rsp+0x50]
  229dbd:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  229dc2:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  229dc9:	00 00 
            return self.readFn(self, buffer);
  229dcb:	48 8d 7c 24 28       	lea    rdi,[rsp+0x28]
  229dd0:	48 8d 74 24 48       	lea    rsi,[rsp+0x48]
  229dd5:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  229dda:	ff 54 24 48          	call   QWORD PTR [rsp+0x48]
  229dde:	44 0f b7 6c 24 28    	movzx  r13d,WORD PTR [rsp+0x28]
  229de4:	48 8b 44 24 30       	mov    rax,QWORD PTR [rsp+0x30]
            const amt_read = try self.read(buf);
  229de9:	66 45 85 ed          	test   r13w,r13w
  229ded:	74 8d                	je     229d7c <printSourceAtAddressLinux+0x20ec>
  229def:	e9 29 07 00 00       	jmp    22a51d <printSourceAtAddressLinux+0x288d>
            try self.readNoEof(result[0..]);
  229df4:	48 8d 44 24 50       	lea    rax,[rsp+0x50]
  229df9:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  229dfe:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  229e05:	00 00 
            return self.readFn(self, buffer);
  229e07:	48 8d 7c 24 28       	lea    rdi,[rsp+0x28]
  229e0c:	48 8d 74 24 48       	lea    rsi,[rsp+0x48]
  229e11:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  229e16:	ff 54 24 48          	call   QWORD PTR [rsp+0x48]
  229e1a:	44 0f b7 6c 24 28    	movzx  r13d,WORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  229e20:	66 45 85 ed          	test   r13w,r13w
  229e24:	0f 85 16 07 00 00    	jne    22a540 <printSourceAtAddressLinux+0x28b0>
  229e2a:	48 8b 44 24 30       	mov    rax,QWORD PTR [rsp+0x30]
  229e2f:	45 31 f6             	xor    r14d,r14d
  229e32:	31 db                	xor    ebx,ebx
            if (amt_read < buf.len) return error.EndOfStream;
  229e34:	48 3b 44 24 18       	cmp    rax,QWORD PTR [rsp+0x18]
  229e39:	0f 82 f5 06 00 00    	jb     22a534 <printSourceAtAddressLinux+0x28a4>
            return result[0];
  229e3f:	0f b6 44 24 50       	movzx  eax,BYTE PTR [rsp+0x50]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  229e44:	89 c2                	mov    edx,eax
  229e46:	83 e2 7f             	and    edx,0x7f
  229e49:	89 de                	mov    esi,ebx
  229e4b:	83 e6 3f             	and    esi,0x3f
  229e4e:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  229e53:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  229e58:	48 39 d6             	cmp    rsi,rdx
  229e5b:	0f 85 da 06 00 00    	jne    22a53b <printSourceAtAddressLinux+0x28ab>
        result |= operand;
  229e61:	49 09 ce             	or     r14,rcx
        if ((byte & 0b10000000) == 0) return result;
  229e64:	84 c0                	test   al,al
  229e66:	0f 89 7a 03 00 00    	jns    22a1e6 <printSourceAtAddressLinux+0x2556>
        shift += 7;
  229e6c:	48 83 c3 07          	add    rbx,0x7
            try self.readNoEof(result[0..]);
  229e70:	48 8d 44 24 50       	lea    rax,[rsp+0x50]
  229e75:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  229e7a:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  229e81:	00 00 
            return self.readFn(self, buffer);
  229e83:	48 8d 7c 24 28       	lea    rdi,[rsp+0x28]
  229e88:	48 8d 74 24 48       	lea    rsi,[rsp+0x48]
  229e8d:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  229e92:	ff 54 24 48          	call   QWORD PTR [rsp+0x48]
  229e96:	44 0f b7 6c 24 28    	movzx  r13d,WORD PTR [rsp+0x28]
  229e9c:	48 8b 44 24 30       	mov    rax,QWORD PTR [rsp+0x30]
            const amt_read = try self.read(buf);
  229ea1:	66 45 85 ed          	test   r13w,r13w
  229ea5:	74 8d                	je     229e34 <printSourceAtAddressLinux+0x21a4>
  229ea7:	e9 94 06 00 00       	jmp    22a540 <printSourceAtAddressLinux+0x28b0>
                        prog.is_stmt = !prog.is_stmt;
  229eac:	8a 84 24 d0 00 00 00 	mov    al,BYTE PTR [rsp+0xd0]
  229eb3:	f6 d0                	not    al
  229eb5:	24 01                	and    al,0x1
  229eb7:	88 84 24 d0 00 00 00 	mov    BYTE PTR [rsp+0xd0],al
  229ebe:	e9 c4 fb ff ff       	jmp    229a87 <printSourceAtAddressLinux+0x1df7>
                        prog.basic_block = true;
  229ec3:	c6 84 24 d1 00 00 00 	mov    BYTE PTR [rsp+0xd1],0x1
  229eca:	01 
  229ecb:	e9 b7 fb ff ff       	jmp    229a87 <printSourceAtAddressLinux+0x1df7>
                        const inc_addr = minimum_instruction_length * ((255 - opcode_base) / line_range);
  229ed0:	0f b6 84 24 c0 01 00 	movzx  eax,BYTE PTR [rsp+0x1c0]
  229ed7:	00 
  229ed8:	f6 b4 24 98 01 00 00 	div    BYTE PTR [rsp+0x198]
  229edf:	41 f6 e4             	mul    r12b
                        prog.address += inc_addr;
  229ee2:	0f b6 c0             	movzx  eax,al
  229ee5:	eb 6e                	jmp    229f55 <printSourceAtAddressLinux+0x22c5>
                        const arg = try in_stream.readInt(di.elf.endian, u16);
  229ee7:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  229eec:	8a 58 12             	mov    bl,BYTE PTR [rax+0x12]
            try self.readNoEof(bytes[0..]);
  229eef:	48 8d 44 24 50       	lea    rax,[rsp+0x50]
  229ef4:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  229ef9:	48 c7 44 24 18 02 00 	mov    QWORD PTR [rsp+0x18],0x2
  229f00:	00 00 
            return self.readFn(self, buffer);
  229f02:	48 8d 7c 24 28       	lea    rdi,[rsp+0x28]
  229f07:	48 8d 74 24 48       	lea    rsi,[rsp+0x48]
  229f0c:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  229f11:	ff 54 24 48          	call   QWORD PTR [rsp+0x48]
  229f15:	44 0f b7 6c 24 28    	movzx  r13d,WORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  229f1b:	66 45 85 ed          	test   r13w,r13w
  229f1f:	0f 85 7b 07 00 00    	jne    22a6a0 <printSourceAtAddressLinux+0x2a10>
  229f25:	48 8b 44 24 30       	mov    rax,QWORD PTR [rsp+0x30]
            if (amt_read < buf.len) return error.EndOfStream;
  229f2a:	48 3b 44 24 18       	cmp    rax,QWORD PTR [rsp+0x18]
  229f2f:	0f 82 66 07 00 00    	jb     22a69b <printSourceAtAddressLinux+0x2a0b>
  229f35:	0f b6 44 24 50       	movzx  eax,BYTE PTR [rsp+0x50]
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  229f3a:	0f b6 4c 24 51       	movzx  ecx,BYTE PTR [rsp+0x51]
  229f3f:	89 ca                	mov    edx,ecx
  229f41:	c1 e2 08             	shl    edx,0x8
  229f44:	09 c2                	or     edx,eax
                result = (result << 8) | b;
  229f46:	c1 e0 08             	shl    eax,0x8
  229f49:	09 c8                	or     eax,ecx
    switch (endian) {
  229f4b:	f6 c3 01             	test   bl,0x1
  229f4e:	66 0f 45 c2          	cmovne ax,dx
                        prog.address += arg;
  229f52:	0f b7 c0             	movzx  eax,ax
  229f55:	48 01 84 24 b0 00 00 	add    QWORD PTR [rsp+0xb0],rax
  229f5c:	00 
  229f5d:	e9 25 fb ff ff       	jmp    229a87 <printSourceAtAddressLinux+0x1df7>
                        const addr = try in_stream.readInt(di.elf.endian, usize);
  229f62:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  229f67:	8a 58 12             	mov    bl,BYTE PTR [rax+0x12]
            try self.readNoEof(bytes[0..]);
  229f6a:	48 8d 44 24 50       	lea    rax,[rsp+0x50]
  229f6f:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  229f74:	48 c7 44 24 18 08 00 	mov    QWORD PTR [rsp+0x18],0x8
  229f7b:	00 00 
            return self.readFn(self, buffer);
  229f7d:	48 8d 7c 24 28       	lea    rdi,[rsp+0x28]
  229f82:	48 8d 74 24 48       	lea    rsi,[rsp+0x48]
  229f87:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  229f8c:	ff 54 24 48          	call   QWORD PTR [rsp+0x48]
  229f90:	44 0f b7 6c 24 28    	movzx  r13d,WORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  229f96:	66 45 85 ed          	test   r13w,r13w
  229f9a:	0f 85 1c 07 00 00    	jne    22a6bc <printSourceAtAddressLinux+0x2a2c>
  229fa0:	48 8b 44 24 30       	mov    rax,QWORD PTR [rsp+0x30]
            if (amt_read < buf.len) return error.EndOfStream;
  229fa5:	48 3b 44 24 18       	cmp    rax,QWORD PTR [rsp+0x18]
  229faa:	0f 82 07 07 00 00    	jb     22a6b7 <printSourceAtAddressLinux+0x2a27>
  229fb0:	0f b6 44 24 50       	movzx  eax,BYTE PTR [rsp+0x50]
  229fb5:	0f b6 4c 24 51       	movzx  ecx,BYTE PTR [rsp+0x51]
  229fba:	f6 c3 01             	test   bl,0x1
  229fbd:	0f 84 83 01 00 00    	je     22a146 <printSourceAtAddressLinux+0x24b6>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  229fc3:	48 c1 e1 08          	shl    rcx,0x8
  229fc7:	48 09 c1             	or     rcx,rax
  229fca:	0f b6 44 24 52       	movzx  eax,BYTE PTR [rsp+0x52]
  229fcf:	48 c1 e0 10          	shl    rax,0x10
  229fd3:	48 09 c8             	or     rax,rcx
  229fd6:	0f b6 4c 24 53       	movzx  ecx,BYTE PTR [rsp+0x53]
  229fdb:	48 c1 e1 18          	shl    rcx,0x18
  229fdf:	48 09 c1             	or     rcx,rax
  229fe2:	0f b6 44 24 54       	movzx  eax,BYTE PTR [rsp+0x54]
  229fe7:	48 c1 e0 20          	shl    rax,0x20
  229feb:	48 09 c8             	or     rax,rcx
  229fee:	0f b6 4c 24 55       	movzx  ecx,BYTE PTR [rsp+0x55]
  229ff3:	48 c1 e1 28          	shl    rcx,0x28
  229ff7:	48 09 c1             	or     rcx,rax
  229ffa:	0f b6 54 24 56       	movzx  edx,BYTE PTR [rsp+0x56]
  229fff:	48 c1 e2 30          	shl    rdx,0x30
  22a003:	0f b6 44 24 57       	movzx  eax,BYTE PTR [rsp+0x57]
  22a008:	48 c1 e0 38          	shl    rax,0x38
  22a00c:	48 09 d0             	or     rax,rdx
  22a00f:	48 09 c8             	or     rax,rcx
                        prog.address = addr;
  22a012:	48 89 84 24 b0 00 00 	mov    QWORD PTR [rsp+0xb0],rax
  22a019:	00 
  22a01a:	e9 68 fa ff ff       	jmp    229a87 <printSourceAtAddressLinux+0x1df7>
  22a01f:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
            var in_file_stream = io.FileInStream.init(&self.self_exe_file);
  22a024:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  22a029:	48 8d 0d 30 a1 ff ff 	lea    rcx,[rip+0xffffffffffffa130]        # 224160 <FileInStream_readFn>
  22a030:	48 89 4c 24 18       	mov    QWORD PTR [rsp+0x18],rcx
  22a035:	48 8b b0 a0 00 00 00 	mov    rsi,QWORD PTR [rax+0xa0]
            return readStringRaw(self.allocator(), in_stream);
  22a03c:	48 8d 7c 24 28       	lea    rdi,[rsp+0x28]
  22a041:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
  22a046:	e8 e5 d7 ff ff       	call   227830 <readStringRaw>
  22a04b:	44 0f b7 6c 24 28    	movzx  r13d,WORD PTR [rsp+0x28]
  22a051:	48 8d 44 24 2a       	lea    rax,[rsp+0x2a]
  22a056:	c5 f8 10 00          	vmovups xmm0,XMMWORD PTR [rax]
  22a05a:	c5 f8 29 84 24 20 03 	vmovaps XMMWORD PTR [rsp+0x320],xmm0
  22a061:	00 00 
  22a063:	48 8b 40 0e          	mov    rax,QWORD PTR [rax+0xe]
  22a067:	48 89 84 24 2e 03 00 	mov    QWORD PTR [rsp+0x32e],rax
  22a06e:	00 
                        const file_name = try di.readString();
  22a06f:	66 45 85 ed          	test   r13w,r13w
  22a073:	0f 85 5a 06 00 00    	jne    22a6d3 <printSourceAtAddressLinux+0x2a43>
  22a079:	48 8d 84 24 26 03 00 	lea    rax,[rsp+0x326]
  22a080:	00 
  22a081:	c5 fa 6f 00          	vmovdqu xmm0,XMMWORD PTR [rax]
  22a085:	c5 f9 7f 84 24 70 03 	vmovdqa XMMWORD PTR [rsp+0x370],xmm0
  22a08c:	00 00 
            try self.readNoEof(result[0..]);
  22a08e:	48 8d 44 24 50       	lea    rax,[rsp+0x50]
  22a093:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  22a098:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  22a09f:	00 00 
            return self.readFn(self, buffer);
  22a0a1:	48 8d 7c 24 28       	lea    rdi,[rsp+0x28]
  22a0a6:	48 8d 74 24 48       	lea    rsi,[rsp+0x48]
  22a0ab:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  22a0b0:	ff 54 24 48          	call   QWORD PTR [rsp+0x48]
  22a0b4:	44 0f b7 6c 24 28    	movzx  r13d,WORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  22a0ba:	66 45 85 ed          	test   r13w,r13w
  22a0be:	0f 85 9f 04 00 00    	jne    22a563 <printSourceAtAddressLinux+0x28d3>
  22a0c4:	48 8b 44 24 30       	mov    rax,QWORD PTR [rsp+0x30]
  22a0c9:	45 31 f6             	xor    r14d,r14d
  22a0cc:	31 db                	xor    ebx,ebx
            if (amt_read < buf.len) return error.EndOfStream;
  22a0ce:	48 3b 44 24 18       	cmp    rax,QWORD PTR [rsp+0x18]
  22a0d3:	0f 82 7e 04 00 00    	jb     22a557 <printSourceAtAddressLinux+0x28c7>
            return result[0];
  22a0d9:	0f b6 44 24 50       	movzx  eax,BYTE PTR [rsp+0x50]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  22a0de:	89 c2                	mov    edx,eax
  22a0e0:	83 e2 7f             	and    edx,0x7f
  22a0e3:	89 de                	mov    esi,ebx
  22a0e5:	83 e6 3f             	and    esi,0x3f
  22a0e8:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  22a0ed:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  22a0f2:	48 39 d6             	cmp    rsi,rdx
  22a0f5:	0f 85 63 04 00 00    	jne    22a55e <printSourceAtAddressLinux+0x28ce>
        result |= operand;
  22a0fb:	49 09 ce             	or     r14,rcx
        if ((byte & 0b10000000) == 0) return result;
  22a0fe:	84 c0                	test   al,al
  22a100:	0f 89 ed 00 00 00    	jns    22a1f3 <printSourceAtAddressLinux+0x2563>
        shift += 7;
  22a106:	48 83 c3 07          	add    rbx,0x7
            try self.readNoEof(result[0..]);
  22a10a:	48 8d 44 24 50       	lea    rax,[rsp+0x50]
  22a10f:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  22a114:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  22a11b:	00 00 
            return self.readFn(self, buffer);
  22a11d:	48 8d 7c 24 28       	lea    rdi,[rsp+0x28]
  22a122:	48 8d 74 24 48       	lea    rsi,[rsp+0x48]
  22a127:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  22a12c:	ff 54 24 48          	call   QWORD PTR [rsp+0x48]
  22a130:	44 0f b7 6c 24 28    	movzx  r13d,WORD PTR [rsp+0x28]
  22a136:	48 8b 44 24 30       	mov    rax,QWORD PTR [rsp+0x30]
            const amt_read = try self.read(buf);
  22a13b:	66 45 85 ed          	test   r13w,r13w
  22a13f:	74 8d                	je     22a0ce <printSourceAtAddressLinux+0x243e>
  22a141:	e9 1d 04 00 00       	jmp    22a563 <printSourceAtAddressLinux+0x28d3>
                result = (result << 8) | b;
  22a146:	48 c1 e0 08          	shl    rax,0x8
  22a14a:	48 09 c8             	or     rax,rcx
  22a14d:	48 c1 e0 08          	shl    rax,0x8
  22a151:	0f b6 4c 24 52       	movzx  ecx,BYTE PTR [rsp+0x52]
  22a156:	48 09 c1             	or     rcx,rax
  22a159:	48 c1 e1 08          	shl    rcx,0x8
  22a15d:	0f b6 44 24 53       	movzx  eax,BYTE PTR [rsp+0x53]
  22a162:	48 09 c8             	or     rax,rcx
  22a165:	48 c1 e0 08          	shl    rax,0x8
  22a169:	0f b6 4c 24 54       	movzx  ecx,BYTE PTR [rsp+0x54]
  22a16e:	48 09 c1             	or     rcx,rax
  22a171:	48 c1 e1 08          	shl    rcx,0x8
  22a175:	0f b6 44 24 55       	movzx  eax,BYTE PTR [rsp+0x55]
  22a17a:	48 09 c8             	or     rax,rcx
  22a17d:	48 c1 e0 08          	shl    rax,0x8
  22a181:	0f b6 4c 24 56       	movzx  ecx,BYTE PTR [rsp+0x56]
  22a186:	48 09 c1             	or     rcx,rax
  22a189:	48 c1 e1 08          	shl    rcx,0x8
  22a18d:	0f b6 44 24 57       	movzx  eax,BYTE PTR [rsp+0x57]
  22a192:	48 09 c8             	or     rax,rcx
                        prog.address = addr;
  22a195:	48 89 84 24 b0 00 00 	mov    QWORD PTR [rsp+0xb0],rax
  22a19c:	00 
  22a19d:	e9 e5 f8 ff ff       	jmp    229a87 <printSourceAtAddressLinux+0x1df7>
                        prog.address += arg * minimum_instruction_length;
  22a1a2:	4d 0f af f4          	imul   r14,r12
  22a1a6:	4c 01 b4 24 b0 00 00 	add    QWORD PTR [rsp+0xb0],r14
  22a1ad:	00 
  22a1ae:	e9 d4 f8 ff ff       	jmp    229a87 <printSourceAtAddressLinux+0x1df7>
            if (shift < @sizeOf(i64) * 8 and (byte & 0b01000000) != 0) result |= -(i64(1) << @intCast(u6, shift));
  22a1b3:	48 83 fb 3f          	cmp    rbx,0x3f
  22a1b7:	77 13                	ja     22a1cc <printSourceAtAddressLinux+0x253c>
  22a1b9:	24 40                	and    al,0x40
  22a1bb:	74 0f                	je     22a1cc <printSourceAtAddressLinux+0x253c>
  22a1bd:	48 c7 c0 ff ff ff ff 	mov    rax,0xffffffffffffffff
  22a1c4:	c4 e2 e1 f7 c0       	shlx   rax,rax,rbx
  22a1c9:	49 09 c6             	or     r14,rax
                        prog.line += arg;
  22a1cc:	4c 01 b4 24 c0 00 00 	add    QWORD PTR [rsp+0xc0],r14
  22a1d3:	00 
  22a1d4:	e9 ae f8 ff ff       	jmp    229a87 <printSourceAtAddressLinux+0x1df7>
                        prog.file = arg;
  22a1d9:	4c 89 b4 24 b8 00 00 	mov    QWORD PTR [rsp+0xb8],r14
  22a1e0:	00 
  22a1e1:	e9 a1 f8 ff ff       	jmp    229a87 <printSourceAtAddressLinux+0x1df7>
                        prog.column = arg;
  22a1e6:	4c 89 b4 24 c8 00 00 	mov    QWORD PTR [rsp+0xc8],r14
  22a1ed:	00 
  22a1ee:	e9 94 f8 ff ff       	jmp    229a87 <printSourceAtAddressLinux+0x1df7>
            try self.readNoEof(result[0..]);
  22a1f3:	48 8d 44 24 50       	lea    rax,[rsp+0x50]
  22a1f8:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  22a1fd:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  22a204:	00 00 
            return self.readFn(self, buffer);
  22a206:	48 8d 7c 24 28       	lea    rdi,[rsp+0x28]
  22a20b:	48 8d 74 24 48       	lea    rsi,[rsp+0x48]
  22a210:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  22a215:	ff 54 24 48          	call   QWORD PTR [rsp+0x48]
  22a219:	44 0f b7 6c 24 28    	movzx  r13d,WORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  22a21f:	66 45 85 ed          	test   r13w,r13w
  22a223:	0f 85 cd 04 00 00    	jne    22a6f6 <printSourceAtAddressLinux+0x2a66>
  22a229:	48 8b 44 24 30       	mov    rax,QWORD PTR [rsp+0x30]
  22a22e:	45 31 ff             	xor    r15d,r15d
  22a231:	31 db                	xor    ebx,ebx
            if (amt_read < buf.len) return error.EndOfStream;
  22a233:	48 3b 44 24 18       	cmp    rax,QWORD PTR [rsp+0x18]
  22a238:	0f 82 ac 04 00 00    	jb     22a6ea <printSourceAtAddressLinux+0x2a5a>
            return result[0];
  22a23e:	0f b6 44 24 50       	movzx  eax,BYTE PTR [rsp+0x50]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  22a243:	89 c2                	mov    edx,eax
  22a245:	83 e2 7f             	and    edx,0x7f
  22a248:	89 de                	mov    esi,ebx
  22a24a:	83 e6 3f             	and    esi,0x3f
  22a24d:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  22a252:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  22a257:	48 39 d6             	cmp    rsi,rdx
  22a25a:	0f 85 91 04 00 00    	jne    22a6f1 <printSourceAtAddressLinux+0x2a61>
        result |= operand;
  22a260:	49 09 cf             	or     r15,rcx
        if ((byte & 0b10000000) == 0) return result;
  22a263:	84 c0                	test   al,al
  22a265:	79 40                	jns    22a2a7 <printSourceAtAddressLinux+0x2617>
        shift += 7;
  22a267:	48 83 c3 07          	add    rbx,0x7
            try self.readNoEof(result[0..]);
  22a26b:	48 8d 44 24 50       	lea    rax,[rsp+0x50]
  22a270:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  22a275:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  22a27c:	00 00 
            return self.readFn(self, buffer);
  22a27e:	48 8d 7c 24 28       	lea    rdi,[rsp+0x28]
  22a283:	48 8d 74 24 48       	lea    rsi,[rsp+0x48]
  22a288:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  22a28d:	ff 54 24 48          	call   QWORD PTR [rsp+0x48]
  22a291:	44 0f b7 6c 24 28    	movzx  r13d,WORD PTR [rsp+0x28]
  22a297:	48 8b 44 24 30       	mov    rax,QWORD PTR [rsp+0x30]
            const amt_read = try self.read(buf);
  22a29c:	66 45 85 ed          	test   r13w,r13w
  22a2a0:	74 91                	je     22a233 <printSourceAtAddressLinux+0x25a3>
  22a2a2:	e9 4f 04 00 00       	jmp    22a6f6 <printSourceAtAddressLinux+0x2a66>
            try self.readNoEof(result[0..]);
  22a2a7:	48 8d 44 24 50       	lea    rax,[rsp+0x50]
  22a2ac:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  22a2b1:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  22a2b8:	00 00 
            return self.readFn(self, buffer);
  22a2ba:	48 8d 7c 24 28       	lea    rdi,[rsp+0x28]
  22a2bf:	48 8d 74 24 48       	lea    rsi,[rsp+0x48]
  22a2c4:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  22a2c9:	ff 54 24 48          	call   QWORD PTR [rsp+0x48]
  22a2cd:	44 0f b7 6c 24 28    	movzx  r13d,WORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  22a2d3:	66 45 85 ed          	test   r13w,r13w
  22a2d7:	0f 85 3c 04 00 00    	jne    22a719 <printSourceAtAddressLinux+0x2a89>
  22a2dd:	48 8b 44 24 30       	mov    rax,QWORD PTR [rsp+0x30]
  22a2e2:	31 ed                	xor    ebp,ebp
  22a2e4:	31 db                	xor    ebx,ebx
            if (amt_read < buf.len) return error.EndOfStream;
  22a2e6:	48 3b 44 24 18       	cmp    rax,QWORD PTR [rsp+0x18]
  22a2eb:	0f 82 1c 04 00 00    	jb     22a70d <printSourceAtAddressLinux+0x2a7d>
            return result[0];
  22a2f1:	0f b6 44 24 50       	movzx  eax,BYTE PTR [rsp+0x50]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  22a2f6:	89 c2                	mov    edx,eax
  22a2f8:	83 e2 7f             	and    edx,0x7f
  22a2fb:	89 de                	mov    esi,ebx
  22a2fd:	83 e6 3f             	and    esi,0x3f
  22a300:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  22a305:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  22a30a:	48 39 d6             	cmp    rsi,rdx
  22a30d:	0f 85 01 04 00 00    	jne    22a714 <printSourceAtAddressLinux+0x2a84>
        result |= operand;
  22a313:	48 09 cd             	or     rbp,rcx
        if ((byte & 0b10000000) == 0) return result;
  22a316:	84 c0                	test   al,al
  22a318:	79 40                	jns    22a35a <printSourceAtAddressLinux+0x26ca>
        shift += 7;
  22a31a:	48 83 c3 07          	add    rbx,0x7
            try self.readNoEof(result[0..]);
  22a31e:	48 8d 44 24 50       	lea    rax,[rsp+0x50]
  22a323:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  22a328:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  22a32f:	00 00 
            return self.readFn(self, buffer);
  22a331:	48 8d 7c 24 28       	lea    rdi,[rsp+0x28]
  22a336:	48 8d 74 24 48       	lea    rsi,[rsp+0x48]
  22a33b:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  22a340:	ff 54 24 48          	call   QWORD PTR [rsp+0x48]
  22a344:	44 0f b7 6c 24 28    	movzx  r13d,WORD PTR [rsp+0x28]
  22a34a:	48 8b 44 24 30       	mov    rax,QWORD PTR [rsp+0x30]
            const amt_read = try self.read(buf);
  22a34f:	66 45 85 ed          	test   r13w,r13w
  22a353:	74 91                	je     22a2e6 <printSourceAtAddressLinux+0x2656>
  22a355:	e9 bf 03 00 00       	jmp    22a719 <printSourceAtAddressLinux+0x2a89>
                        try file_entries.append(FileEntry{
  22a35a:	c5 f9 6f 84 24 70 03 	vmovdqa xmm0,XMMWORD PTR [rsp+0x370]
  22a361:	00 00 
  22a363:	c5 f9 7f 84 24 90 03 	vmovdqa XMMWORD PTR [rsp+0x390],xmm0
  22a36a:	00 00 
            const new_length = self.len + 1;
  22a36c:	48 8b 9c 24 80 01 00 	mov    rbx,QWORD PTR [rsp+0x180]
  22a373:	00 
            var better_capacity = self.items.len;
  22a374:	48 8b 8c 24 78 01 00 	mov    rcx,QWORD PTR [rsp+0x178]
  22a37b:	00 
            if (better_capacity >= new_capacity) return;
  22a37c:	48 39 d9             	cmp    rcx,rbx
  22a37f:	76 05                	jbe    22a386 <printSourceAtAddressLinux+0x26f6>
            const result = &self.items[self.len];
  22a381:	48 89 d8             	mov    rax,rbx
  22a384:	eb 56                	jmp    22a3dc <printSourceAtAddressLinux+0x274c>
                better_capacity += better_capacity / 2 + 8;
  22a386:	48 89 c8             	mov    rax,rcx
  22a389:	48 d1 e8             	shr    rax,1
  22a38c:	48 01 c1             	add    rcx,rax
  22a38f:	48 83 c1 08          	add    rcx,0x8
                if (better_capacity >= new_capacity) break;
  22a393:	48 39 d9             	cmp    rcx,rbx
  22a396:	76 ee                	jbe    22a386 <printSourceAtAddressLinux+0x26f6>
            self.items = try self.allocator.alignedRealloc(T, A, self.items, better_capacity);
  22a398:	48 8b b4 24 88 01 00 	mov    rsi,QWORD PTR [rsp+0x188]
  22a39f:	00 
  22a3a0:	48 8d 7c 24 28       	lea    rdi,[rsp+0x28]
  22a3a5:	48 8d 94 24 70 01 00 	lea    rdx,[rsp+0x170]
  22a3ac:	00 
  22a3ad:	e8 7e 13 00 00       	call   22b730 <Allocator_alignedRealloc.189>
  22a3b2:	44 0f b7 6c 24 28    	movzx  r13d,WORD PTR [rsp+0x28]
  22a3b8:	66 45 85 ed          	test   r13w,r13w
  22a3bc:	0f 85 6e 03 00 00    	jne    22a730 <printSourceAtAddressLinux+0x2aa0>
  22a3c2:	48 8d 44 24 30       	lea    rax,[rsp+0x30]
  22a3c7:	c5 fa 6f 00          	vmovdqu xmm0,XMMWORD PTR [rax]
  22a3cb:	c5 f9 7f 84 24 70 01 	vmovdqa XMMWORD PTR [rsp+0x170],xmm0
  22a3d2:	00 00 
            const result = &self.items[self.len];
  22a3d4:	48 8b 84 24 80 01 00 	mov    rax,QWORD PTR [rsp+0x180]
  22a3db:	00 
  22a3dc:	48 83 c3 01          	add    rbx,0x1
  22a3e0:	48 8b 8c 24 70 01 00 	mov    rcx,QWORD PTR [rsp+0x170]
  22a3e7:	00 
  22a3e8:	48 8d 04 80          	lea    rax,[rax+rax*4]
            self.len = new_length;
  22a3ec:	48 89 9c 24 80 01 00 	mov    QWORD PTR [rsp+0x180],rbx
  22a3f3:	00 
            new_item_ptr.* = item;
  22a3f4:	c5 f9 6f 84 24 90 03 	vmovdqa xmm0,XMMWORD PTR [rsp+0x390]
  22a3fb:	00 00 
  22a3fd:	c5 fa 7f 04 c1       	vmovdqu XMMWORD PTR [rcx+rax*8],xmm0
  22a402:	4c 89 74 c1 10       	mov    QWORD PTR [rcx+rax*8+0x10],r14
  22a407:	4c 89 7c c1 18       	mov    QWORD PTR [rcx+rax*8+0x18],r15
  22a40c:	48 89 6c c1 20       	mov    QWORD PTR [rcx+rax*8+0x20],rbp
  22a411:	e9 71 f6 ff ff       	jmp    229a87 <printSourceAtAddressLinux+0x1df7>
  22a416:	c5 fc 10 05 72 e0 fd 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffde072]        # 208490 <__unnamed_82+0x10>
  22a41d:	ff 
  22a41e:	c5 fc 11 44 24 7e    	vmovups YMMWORD PTR [rsp+0x7e],ymm0
  22a424:	c5 fc 10 05 56 e0 fd 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffde056]        # 208482 <__unnamed_82+0x2>
  22a42b:	ff 
  22a42c:	e9 aa e4 ff ff       	jmp    2288db <printSourceAtAddressLinux+0xc4b>
  22a431:	66 41 bd 25 00       	mov    r13w,0x25
  22a436:	eb 05                	jmp    22a43d <printSourceAtAddressLinux+0x27ad>
  22a438:	66 41 bd 29 00       	mov    r13w,0x29
                const op_size = try readULeb128(in_stream);
  22a43d:	c5 fc 10 84 24 3c 07 	vmovups ymm0,YMMWORD PTR [rsp+0x73c]
  22a444:	00 00 
  22a446:	c5 fe 6f 8c 24 4a 07 	vmovdqu ymm1,YMMWORD PTR [rsp+0x74a]
  22a44d:	00 00 
  22a44f:	e9 a5 e7 ff ff       	jmp    228bf9 <printSourceAtAddressLinux+0xf69>
            try file_entries.append(FileEntry{
  22a454:	c5 fc 10 84 24 c6 07 	vmovups ymm0,YMMWORD PTR [rsp+0x7c6]
  22a45b:	00 00 
  22a45d:	c5 fe 6f 8c 24 d4 07 	vmovdqu ymm1,YMMWORD PTR [rsp+0x7d4]
  22a464:	00 00 
  22a466:	e9 8e e7 ff ff       	jmp    228bf9 <printSourceAtAddressLinux+0xf69>
  22a46b:	66 41 bd 25 00       	mov    r13w,0x25
  22a470:	e9 52 f4 ff ff       	jmp    2298c7 <printSourceAtAddressLinux+0x1c37>
                if (try prog.checkLineMatch()) |info| return info;
  22a475:	c5 fc 10 84 24 70 05 	vmovups ymm0,YMMWORD PTR [rsp+0x570]
  22a47c:	00 00 
  22a47e:	c5 fe 6f 8c 24 7e 05 	vmovdqu ymm1,YMMWORD PTR [rsp+0x57e]
  22a485:	00 00 
  22a487:	e9 6d e7 ff ff       	jmp    228bf9 <printSourceAtAddressLinux+0xf69>
  22a48c:	c5 fc 10 84 24 30 02 	vmovups ymm0,YMMWORD PTR [rsp+0x230]
  22a493:	00 00 
  22a495:	c5 fc 11 84 24 d8 03 	vmovups YMMWORD PTR [rsp+0x3d8],ymm0
  22a49c:	00 00 
  22a49e:	48 8b 84 24 50 02 00 	mov    rax,QWORD PTR [rsp+0x250]
  22a4a5:	00 
  22a4a6:	48 89 84 24 f8 03 00 	mov    QWORD PTR [rsp+0x3f8],rax
  22a4ad:	00 
  22a4ae:	c5 fc 10 84 24 d2 03 	vmovups ymm0,YMMWORD PTR [rsp+0x3d2]
  22a4b5:	00 00 
  22a4b7:	c5 fc 11 44 24 70    	vmovups YMMWORD PTR [rsp+0x70],ymm0
  22a4bd:	c5 fc 10 84 24 e0 03 	vmovups ymm0,YMMWORD PTR [rsp+0x3e0]
  22a4c4:	00 00 
  22a4c6:	e9 c4 02 00 00       	jmp    22a78f <printSourceAtAddressLinux+0x2aff>
  22a4cb:	66 41 bd 25 00       	mov    r13w,0x25
  22a4d0:	eb 05                	jmp    22a4d7 <printSourceAtAddressLinux+0x2847>
  22a4d2:	66 41 bd 29 00       	mov    r13w,0x29
                        const arg = try readULeb128(in_stream);
  22a4d7:	c5 fc 10 84 24 e6 04 	vmovups ymm0,YMMWORD PTR [rsp+0x4e6]
  22a4de:	00 00 
  22a4e0:	c5 fe 6f 8c 24 f4 04 	vmovdqu ymm1,YMMWORD PTR [rsp+0x4f4]
  22a4e7:	00 00 
  22a4e9:	e9 0b e7 ff ff       	jmp    228bf9 <printSourceAtAddressLinux+0xf69>
  22a4ee:	66 41 bd 25 00       	mov    r13w,0x25
  22a4f3:	eb 05                	jmp    22a4fa <printSourceAtAddressLinux+0x286a>
  22a4f5:	66 41 bd 29 00       	mov    r13w,0x29
                        const arg = try readILeb128(in_stream);
  22a4fa:	c5 fc 10 84 24 b8 04 	vmovups ymm0,YMMWORD PTR [rsp+0x4b8]
  22a501:	00 00 
  22a503:	c5 fe 6f 8c 24 c6 04 	vmovdqu ymm1,YMMWORD PTR [rsp+0x4c6]
  22a50a:	00 00 
  22a50c:	e9 e8 e6 ff ff       	jmp    228bf9 <printSourceAtAddressLinux+0xf69>
  22a511:	66 41 bd 25 00       	mov    r13w,0x25
  22a516:	eb 05                	jmp    22a51d <printSourceAtAddressLinux+0x288d>
  22a518:	66 41 bd 29 00       	mov    r13w,0x29
                        const arg = try readULeb128(in_stream);
  22a51d:	c5 fc 10 84 24 8a 04 	vmovups ymm0,YMMWORD PTR [rsp+0x48a]
  22a524:	00 00 
  22a526:	c5 fe 6f 8c 24 98 04 	vmovdqu ymm1,YMMWORD PTR [rsp+0x498]
  22a52d:	00 00 
  22a52f:	e9 c5 e6 ff ff       	jmp    228bf9 <printSourceAtAddressLinux+0xf69>
  22a534:	66 41 bd 25 00       	mov    r13w,0x25
  22a539:	eb 05                	jmp    22a540 <printSourceAtAddressLinux+0x28b0>
  22a53b:	66 41 bd 29 00       	mov    r13w,0x29
                        const arg = try readULeb128(in_stream);
  22a540:	c5 fc 10 84 24 5c 04 	vmovups ymm0,YMMWORD PTR [rsp+0x45c]
  22a547:	00 00 
  22a549:	c5 fe 6f 8c 24 6a 04 	vmovdqu ymm1,YMMWORD PTR [rsp+0x46a]
  22a550:	00 00 
  22a552:	e9 a2 e6 ff ff       	jmp    228bf9 <printSourceAtAddressLinux+0xf69>
  22a557:	66 41 bd 25 00       	mov    r13w,0x25
  22a55c:	eb 05                	jmp    22a563 <printSourceAtAddressLinux+0x28d3>
  22a55e:	66 41 bd 29 00       	mov    r13w,0x29
                        const dir_index = try readULeb128(in_stream);
  22a563:	c5 fc 10 84 24 28 06 	vmovups ymm0,YMMWORD PTR [rsp+0x628]
  22a56a:	00 00 
  22a56c:	c5 fe 6f 8c 24 36 06 	vmovdqu ymm1,YMMWORD PTR [rsp+0x636]
  22a573:	00 00 
  22a575:	e9 7f e6 ff ff       	jmp    228bf9 <printSourceAtAddressLinux+0xf69>
            @panic("assertion failure");
  22a57a:	48 8d 3d 0f 58 02 00 	lea    rdi,[rip+0x2580f]        # 24fd90 <__unnamed_2>
  22a581:	e8 9a 81 fe ff       	call   212720 <panic>
                        if (try prog.checkLineMatch()) |info| return info;
  22a586:	c5 fc 10 84 24 14 05 	vmovups ymm0,YMMWORD PTR [rsp+0x514]
  22a58d:	00 00 
  22a58f:	c5 fe 6f 8c 24 22 05 	vmovdqu ymm1,YMMWORD PTR [rsp+0x522]
  22a596:	00 00 
  22a598:	e9 5c e6 ff ff       	jmp    228bf9 <printSourceAtAddressLinux+0xf69>
  22a59d:	c5 fc 10 84 24 f0 02 	vmovups ymm0,YMMWORD PTR [rsp+0x2f0]
  22a5a4:	00 00 
  22a5a6:	c5 fc 11 84 24 aa 03 	vmovups YMMWORD PTR [rsp+0x3aa],ymm0
  22a5ad:	00 00 
  22a5af:	48 8b 84 24 10 03 00 	mov    rax,QWORD PTR [rsp+0x310]
  22a5b6:	00 
  22a5b7:	48 89 84 24 ca 03 00 	mov    QWORD PTR [rsp+0x3ca],rax
  22a5be:	00 
  22a5bf:	c5 fc 10 84 24 a4 03 	vmovups ymm0,YMMWORD PTR [rsp+0x3a4]
  22a5c6:	00 00 
  22a5c8:	c5 fc 11 44 24 70    	vmovups YMMWORD PTR [rsp+0x70],ymm0
  22a5ce:	c5 fc 10 84 24 b2 03 	vmovups ymm0,YMMWORD PTR [rsp+0x3b2]
  22a5d5:	00 00 
  22a5d7:	e9 b3 01 00 00       	jmp    22a78f <printSourceAtAddressLinux+0x2aff>
  22a5dc:	66 41 bd 25 00       	mov    r13w,0x25
                var sub_op = try in_stream.readByte();
  22a5e1:	c5 fc 10 84 24 0e 07 	vmovups ymm0,YMMWORD PTR [rsp+0x70e]
  22a5e8:	00 00 
  22a5ea:	c5 fe 6f 8c 24 1c 07 	vmovdqu ymm1,YMMWORD PTR [rsp+0x71c]
  22a5f1:	00 00 
  22a5f3:	e9 01 e6 ff ff       	jmp    228bf9 <printSourceAtAddressLinux+0xf69>
                        prog.end_sequence = true;
  22a5f8:	c6 84 24 d2 00 00 00 	mov    BYTE PTR [rsp+0xd2],0x1
  22a5ff:	01 
  22a600:	48 8d bc 24 30 01 00 	lea    rdi,[rsp+0x130]
  22a607:	00 
  22a608:	48 8d b4 24 b0 00 00 	lea    rsi,[rsp+0xb0]
  22a60f:	00 
                        if (try prog.checkLineMatch()) |info| return info;
  22a610:	e8 cb 0c 00 00       	call   22b2e0 <LineNumberProgram_checkLineMatch>
  22a615:	44 0f b7 ac 24 30 01 	movzx  r13d,WORD PTR [rsp+0x130]
  22a61c:	00 00 
  22a61e:	66 45 85 ed          	test   r13w,r13w
  22a622:	0f 84 1f 01 00 00    	je     22a747 <printSourceAtAddressLinux+0x2ab7>
  22a628:	c5 fc 10 84 24 b2 06 	vmovups ymm0,YMMWORD PTR [rsp+0x6b2]
  22a62f:	00 00 
  22a631:	c5 fe 6f 8c 24 c0 06 	vmovdqu ymm1,YMMWORD PTR [rsp+0x6c0]
  22a638:	00 00 
  22a63a:	e9 ba e5 ff ff       	jmp    228bf9 <printSourceAtAddressLinux+0xf69>
  22a63f:	48 8d 41 ea          	lea    rax,[rcx-0x16]
  22a643:	48 83 f8 35          	cmp    rax,0x35
  22a647:	77 10                	ja     22a659 <printSourceAtAddressLinux+0x29c9>
  22a649:	48 ba 81 00 00 00 00 	movabs rdx,0x20000000000081
  22a650:	00 20 00 
  22a653:	48 0f a3 c2          	bt     rdx,rax
  22a657:	72 0a                	jb     22a663 <printSourceAtAddressLinux+0x29d3>
  22a659:	48 83 f9 06          	cmp    rcx,0x6
  22a65d:	0f 85 3a 05 00 00    	jne    22ab9d <printSourceAtAddressLinux+0x2f0d>
  22a663:	66 41 bd 27 00       	mov    r13w,0x27
  22a668:	e9 35 05 00 00       	jmp    22aba2 <printSourceAtAddressLinux+0x2f12>
  22a66d:	48 8d 41 ea          	lea    rax,[rcx-0x16]
  22a671:	48 83 f8 35          	cmp    rax,0x35
  22a675:	77 10                	ja     22a687 <printSourceAtAddressLinux+0x29f7>
  22a677:	48 ba 81 00 00 00 00 	movabs rdx,0x20000000000081
  22a67e:	00 20 00 
  22a681:	48 0f a3 c2          	bt     rdx,rax
  22a685:	72 0a                	jb     22a691 <printSourceAtAddressLinux+0x2a01>
  22a687:	48 83 f9 06          	cmp    rcx,0x6
  22a68b:	0f 85 28 05 00 00    	jne    22abb9 <printSourceAtAddressLinux+0x2f29>
  22a691:	66 41 bd 27 00       	mov    r13w,0x27
  22a696:	e9 23 05 00 00       	jmp    22abbe <printSourceAtAddressLinux+0x2f2e>
  22a69b:	66 41 bd 25 00       	mov    r13w,0x25
                        const arg = try in_stream.readInt(di.elf.endian, u16);
  22a6a0:	c5 fc 10 84 24 2e 04 	vmovups ymm0,YMMWORD PTR [rsp+0x42e]
  22a6a7:	00 00 
  22a6a9:	c5 fe 6f 8c 24 3c 04 	vmovdqu ymm1,YMMWORD PTR [rsp+0x43c]
  22a6b0:	00 00 
  22a6b2:	e9 42 e5 ff ff       	jmp    228bf9 <printSourceAtAddressLinux+0xf69>
  22a6b7:	66 41 bd 25 00       	mov    r13w,0x25
                        const addr = try in_stream.readInt(di.elf.endian, usize);
  22a6bc:	c5 fc 10 84 24 84 06 	vmovups ymm0,YMMWORD PTR [rsp+0x684]
  22a6c3:	00 00 
  22a6c5:	c5 fe 6f 8c 24 92 06 	vmovdqu ymm1,YMMWORD PTR [rsp+0x692]
  22a6cc:	00 00 
  22a6ce:	e9 26 e5 ff ff       	jmp    228bf9 <printSourceAtAddressLinux+0xf69>
                        const file_name = try di.readString();
  22a6d3:	c5 fc 10 84 24 56 06 	vmovups ymm0,YMMWORD PTR [rsp+0x656]
  22a6da:	00 00 
  22a6dc:	c5 fe 6f 8c 24 64 06 	vmovdqu ymm1,YMMWORD PTR [rsp+0x664]
  22a6e3:	00 00 
  22a6e5:	e9 0f e5 ff ff       	jmp    228bf9 <printSourceAtAddressLinux+0xf69>
  22a6ea:	66 41 bd 25 00       	mov    r13w,0x25
  22a6ef:	eb 05                	jmp    22a6f6 <printSourceAtAddressLinux+0x2a66>
  22a6f1:	66 41 bd 29 00       	mov    r13w,0x29
                        const mtime = try readULeb128(in_stream);
  22a6f6:	c5 fc 10 84 24 fa 05 	vmovups ymm0,YMMWORD PTR [rsp+0x5fa]
  22a6fd:	00 00 
  22a6ff:	c5 fe 6f 8c 24 08 06 	vmovdqu ymm1,YMMWORD PTR [rsp+0x608]
  22a706:	00 00 
  22a708:	e9 ec e4 ff ff       	jmp    228bf9 <printSourceAtAddressLinux+0xf69>
  22a70d:	66 41 bd 25 00       	mov    r13w,0x25
  22a712:	eb 05                	jmp    22a719 <printSourceAtAddressLinux+0x2a89>
  22a714:	66 41 bd 29 00       	mov    r13w,0x29
                        const len_bytes = try readULeb128(in_stream);
  22a719:	c5 fc 10 84 24 cc 05 	vmovups ymm0,YMMWORD PTR [rsp+0x5cc]
  22a720:	00 00 
  22a722:	c5 fe 6f 8c 24 da 05 	vmovdqu ymm1,YMMWORD PTR [rsp+0x5da]
  22a729:	00 00 
  22a72b:	e9 c9 e4 ff ff       	jmp    228bf9 <printSourceAtAddressLinux+0xf69>
                        try file_entries.append(FileEntry{
  22a730:	c5 fc 10 84 24 9e 05 	vmovups ymm0,YMMWORD PTR [rsp+0x59e]
  22a737:	00 00 
  22a739:	c5 fe 6f 8c 24 ac 05 	vmovdqu ymm1,YMMWORD PTR [rsp+0x5ac]
  22a740:	00 00 
  22a742:	e9 b2 e4 ff ff       	jmp    228bf9 <printSourceAtAddressLinux+0xf69>
                        if (try prog.checkLineMatch()) |info| return info;
  22a747:	80 bc 24 60 01 00 00 	cmp    BYTE PTR [rsp+0x160],0x1
  22a74e:	01 
  22a74f:	0f 85 70 e1 ff ff    	jne    2288c5 <printSourceAtAddressLinux+0xc35>
  22a755:	c5 fc 10 84 24 38 01 	vmovups ymm0,YMMWORD PTR [rsp+0x138]
  22a75c:	00 00 
  22a75e:	c5 fc 11 84 24 06 04 	vmovups YMMWORD PTR [rsp+0x406],ymm0
  22a765:	00 00 
  22a767:	48 8b 84 24 58 01 00 	mov    rax,QWORD PTR [rsp+0x158]
  22a76e:	00 
  22a76f:	48 89 84 24 26 04 00 	mov    QWORD PTR [rsp+0x426],rax
  22a776:	00 
  22a777:	c5 fc 10 84 24 00 04 	vmovups ymm0,YMMWORD PTR [rsp+0x400]
  22a77e:	00 00 
  22a780:	c5 fc 11 44 24 70    	vmovups YMMWORD PTR [rsp+0x70],ymm0
  22a786:	c5 fc 10 84 24 0e 04 	vmovups ymm0,YMMWORD PTR [rsp+0x40e]
  22a78d:	00 00 
  22a78f:	c5 fc 11 44 24 7e    	vmovups YMMWORD PTR [rsp+0x7e],ymm0
    if (getLineNumberInfoLinux(debug_info, compile_unit, address - 1)) |line_info| {
  22a795:	c5 fe 6f 44 24 76    	vmovdqu ymm0,YMMWORD PTR [rsp+0x76]
  22a79b:	c5 fe 7f 84 24 a0 02 	vmovdqu YMMWORD PTR [rsp+0x2a0],ymm0
  22a7a2:	00 00 
  22a7a4:	48 8b 84 24 96 00 00 	mov    rax,QWORD PTR [rsp+0x96]
  22a7ab:	00 
  22a7ac:	48 89 84 24 c0 02 00 	mov    QWORD PTR [rsp+0x2c0],rax
  22a7b3:	00 
  22a7b4:	48 8d ac 24 b0 02 00 	lea    rbp,[rsp+0x2b0]
  22a7bb:	00 
  22a7bc:	4c 8b bc 24 a0 02 00 	mov    r15,QWORD PTR [rsp+0x2a0]
  22a7c3:	00 
  22a7c4:	4c 8b b4 24 a8 02 00 	mov    r14,QWORD PTR [rsp+0x2a8]
  22a7cb:	00 
            return std.fmt.format(self, Error, self.writeFn, format, args);
  22a7cc:	48 8b 44 24 08       	mov    rax,QWORD PTR [rsp+0x8]
  22a7d1:	4c 8b 20             	mov    r12,QWORD PTR [rax]
    if (tty_color) {
  22a7d4:	f6 84 24 2c 01 00 00 	test   BYTE PTR [rsp+0x12c],0x1
  22a7db:	01 
  22a7dc:	0f 84 e8 00 00 00    	je     22a8ca <printSourceAtAddressLinux+0x2c3a>
                        try output(context, fmt[start_index..i]);
  22a7e2:	48 8d 35 27 57 02 00 	lea    rsi,[rip+0x25727]        # 24ff10 <__unnamed_83>
  22a7e9:	48 8b 7c 24 08       	mov    rdi,QWORD PTR [rsp+0x8]
  22a7ee:	c5 f8 77             	vzeroupper 
  22a7f1:	41 ff d4             	call   r12
  22a7f4:	41 89 c5             	mov    r13d,eax
  22a7f7:	66 45 85 ed          	test   r13w,r13w
  22a7fb:	0f 85 00 09 00 00    	jne    22b101 <printSourceAtAddressLinux+0x3471>
                const casted_value = ([]const u8)(value);
  22a801:	c5 fa 6f 45 00       	vmovdqu xmm0,XMMWORD PTR [rbp+0x0]
  22a806:	c5 f9 7f 84 24 b0 00 	vmovdqa XMMWORD PTR [rsp+0xb0],xmm0
  22a80d:	00 00 
  22a80f:	48 8d b4 24 b0 00 00 	lea    rsi,[rsp+0xb0]
  22a816:	00 
                return output(context, casted_value);
  22a817:	48 8b 7c 24 08       	mov    rdi,QWORD PTR [rsp+0x8]
  22a81c:	41 ff d4             	call   r12
  22a81f:	41 89 c5             	mov    r13d,eax
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  22a822:	66 45 85 ed          	test   r13w,r13w
  22a826:	0f 85 d5 08 00 00    	jne    22b101 <printSourceAtAddressLinux+0x3471>
                        try output(context, fmt[start_index..i]);
  22a82c:	48 8d 35 ed 56 02 00 	lea    rsi,[rip+0x256ed]        # 24ff20 <__unnamed_84>
  22a833:	48 8b 7c 24 08       	mov    rdi,QWORD PTR [rsp+0x8]
  22a838:	41 ff d4             	call   r12
  22a83b:	41 89 c5             	mov    r13d,eax
  22a83e:	66 45 85 ed          	test   r13w,r13w
  22a842:	0f 85 b9 08 00 00    	jne    22b101 <printSourceAtAddressLinux+0x3471>
    var buf: [max_int_digits - 1]u8 = undefined;
  22a848:	c5 fc 10 05 9f ee fd 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffdee9f]        # 2096ef <__unnamed_28+0x1f>
  22a84f:	ff 
  22a850:	c5 fc 11 84 24 cf 00 	vmovups YMMWORD PTR [rsp+0xcf],ymm0
  22a857:	00 00 
  22a859:	c5 fe 6f 05 6f ee fd 	vmovdqu ymm0,YMMWORD PTR [rip+0xfffffffffffdee6f]        # 2096d0 <__unnamed_28>
  22a860:	ff 
  22a861:	c5 fe 7f 84 24 b0 00 	vmovdqu YMMWORD PTR [rsp+0xb0],ymm0
  22a868:	00 00 
        const digit = a % base;
  22a86a:	48 bd cd cc cc cc cc 	movabs rbp,0xcccccccccccccccd
  22a871:	cc cc cc 
  22a874:	4c 89 fa             	mov    rdx,r15
  22a877:	c4 e2 fb f6 cd       	mulx   rcx,rax,rbp
  22a87c:	c1 e9 02             	shr    ecx,0x2
  22a87f:	81 e1 fe ff ff 3f    	and    ecx,0x3ffffffe
  22a885:	8d 0c 89             	lea    ecx,[rcx+rcx*4]
  22a888:	44 89 f8             	mov    eax,r15d
  22a88b:	29 c8                	sub    eax,ecx
        0...9 => digit + '0',
  22a88d:	b1 30                	mov    cl,0x30
  22a88f:	3c 0a                	cmp    al,0xa
  22a891:	72 02                	jb     22a895 <printSourceAtAddressLinux+0x2c05>
  22a893:	b1 57                	mov    cl,0x57
  22a895:	48 8d 94 24 ef 00 00 	lea    rdx,[rsp+0xef]
  22a89c:	00 
  22a89d:	48 89 94 24 c0 01 00 	mov    QWORD PTR [rsp+0x1c0],rdx
  22a8a4:	00 
  22a8a5:	00 c1                	add    cl,al
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  22a8a7:	88 8c 24 ef 00 00 00 	mov    BYTE PTR [rsp+0xef],cl
  22a8ae:	b8 40 00 00 00       	mov    eax,0x40
        if (a == 0) break;
  22a8b3:	49 83 ff 0a          	cmp    r15,0xa
  22a8b7:	0f 83 d9 01 00 00    	jae    22aa96 <printSourceAtAddressLinux+0x2e06>
  22a8bd:	48 8d 8c 24 ef 00 00 	lea    rcx,[rsp+0xef]
  22a8c4:	00 
  22a8c5:	e9 17 02 00 00       	jmp    22aae1 <printSourceAtAddressLinux+0x2e51>
                const casted_value = ([]const u8)(value);
  22a8ca:	c5 fa 6f 45 00       	vmovdqu xmm0,XMMWORD PTR [rbp+0x0]
  22a8cf:	c5 f9 7f 84 24 b0 00 	vmovdqa XMMWORD PTR [rsp+0xb0],xmm0
  22a8d6:	00 00 
  22a8d8:	48 8d b4 24 b0 00 00 	lea    rsi,[rsp+0xb0]
  22a8df:	00 
                return output(context, casted_value);
  22a8e0:	48 8b 7c 24 08       	mov    rdi,QWORD PTR [rsp+0x8]
  22a8e5:	c5 f8 77             	vzeroupper 
  22a8e8:	41 ff d4             	call   r12
  22a8eb:	41 89 c5             	mov    r13d,eax
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  22a8ee:	66 45 85 ed          	test   r13w,r13w
  22a8f2:	0f 85 09 08 00 00    	jne    22b101 <printSourceAtAddressLinux+0x3471>
                        try output(context, fmt[start_index..i]);
  22a8f8:	48 8d 35 81 56 02 00 	lea    rsi,[rip+0x25681]        # 24ff80 <__unnamed_85>
  22a8ff:	48 8b 7c 24 08       	mov    rdi,QWORD PTR [rsp+0x8]
  22a904:	41 ff d4             	call   r12
  22a907:	41 89 c5             	mov    r13d,eax
  22a90a:	66 45 85 ed          	test   r13w,r13w
  22a90e:	0f 85 ed 07 00 00    	jne    22b101 <printSourceAtAddressLinux+0x3471>
    var buf: [max_int_digits - 1]u8 = undefined;
  22a914:	c5 fc 10 05 d3 ed fd 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffdedd3]        # 2096ef <__unnamed_28+0x1f>
  22a91b:	ff 
  22a91c:	c5 fc 11 84 24 cf 00 	vmovups YMMWORD PTR [rsp+0xcf],ymm0
  22a923:	00 00 
  22a925:	c5 fe 6f 05 a3 ed fd 	vmovdqu ymm0,YMMWORD PTR [rip+0xfffffffffffdeda3]        # 2096d0 <__unnamed_28>
  22a92c:	ff 
  22a92d:	c5 fe 7f 84 24 b0 00 	vmovdqu YMMWORD PTR [rsp+0xb0],ymm0
  22a934:	00 00 
        const digit = a % base;
  22a936:	48 bd cd cc cc cc cc 	movabs rbp,0xcccccccccccccccd
  22a93d:	cc cc cc 
  22a940:	4c 89 fa             	mov    rdx,r15
  22a943:	c4 e2 fb f6 cd       	mulx   rcx,rax,rbp
  22a948:	c1 e9 02             	shr    ecx,0x2
  22a94b:	81 e1 fe ff ff 3f    	and    ecx,0x3ffffffe
  22a951:	8d 0c 89             	lea    ecx,[rcx+rcx*4]
  22a954:	44 89 f8             	mov    eax,r15d
  22a957:	29 c8                	sub    eax,ecx
        0...9 => digit + '0',
  22a959:	b1 30                	mov    cl,0x30
  22a95b:	3c 0a                	cmp    al,0xa
  22a95d:	72 02                	jb     22a961 <printSourceAtAddressLinux+0x2cd1>
  22a95f:	b1 57                	mov    cl,0x57
  22a961:	48 8d 94 24 ef 00 00 	lea    rdx,[rsp+0xef]
  22a968:	00 
  22a969:	48 89 94 24 c0 01 00 	mov    QWORD PTR [rsp+0x1c0],rdx
  22a970:	00 
  22a971:	00 c1                	add    cl,al
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  22a973:	88 8c 24 ef 00 00 00 	mov    BYTE PTR [rsp+0xef],cl
  22a97a:	b8 40 00 00 00       	mov    eax,0x40
        if (a == 0) break;
  22a97f:	49 83 ff 0a          	cmp    r15,0xa
  22a983:	73 0a                	jae    22a98f <printSourceAtAddressLinux+0x2cff>
  22a985:	48 8d 8c 24 ef 00 00 	lea    rcx,[rsp+0xef]
  22a98c:	00 
  22a98d:	eb 4b                	jmp    22a9da <printSourceAtAddressLinux+0x2d4a>
        a /= base;
  22a98f:	4c 89 fa             	mov    rdx,r15
  22a992:	c4 e2 f3 f6 d5       	mulx   rdx,rcx,rbp
  22a997:	48 c1 ea 03          	shr    rdx,0x3
        const digit = a % base;
  22a99b:	c4 e2 f3 f6 f5       	mulx   rsi,rcx,rbp
  22a9a0:	c1 ee 02             	shr    esi,0x2
  22a9a3:	81 e6 fe ff ff 3f    	and    esi,0x3ffffffe
  22a9a9:	8d 34 b6             	lea    esi,[rsi+rsi*4]
  22a9ac:	89 d1                	mov    ecx,edx
  22a9ae:	29 f1                	sub    ecx,esi
        0...9 => digit + '0',
  22a9b0:	b3 30                	mov    bl,0x30
  22a9b2:	80 f9 0a             	cmp    cl,0xa
  22a9b5:	72 02                	jb     22a9b9 <printSourceAtAddressLinux+0x2d29>
  22a9b7:	b3 57                	mov    bl,0x57
  22a9b9:	00 cb                	add    bl,cl
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  22a9bb:	88 9c 04 ae 00 00 00 	mov    BYTE PTR [rsp+rax*1+0xae],bl
        if (a == 0) break;
  22a9c2:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  22a9c6:	49 83 ff 63          	cmp    r15,0x63
  22a9ca:	49 89 d7             	mov    r15,rdx
  22a9cd:	77 c0                	ja     22a98f <printSourceAtAddressLinux+0x2cff>
        const padded_buf = buf[index - padding ..];
  22a9cf:	48 8d 0c 04          	lea    rcx,[rsp+rax*1]
  22a9d3:	48 81 c1 af 00 00 00 	add    rcx,0xaf
  22a9da:	ba 41 00 00 00       	mov    edx,0x41
  22a9df:	48 29 c2             	sub    rdx,rax
  22a9e2:	48 89 8c 24 30 01 00 	mov    QWORD PTR [rsp+0x130],rcx
  22a9e9:	00 
  22a9ea:	48 89 94 24 38 01 00 	mov    QWORD PTR [rsp+0x138],rdx
  22a9f1:	00 
  22a9f2:	48 8d b4 24 30 01 00 	lea    rsi,[rsp+0x130]
  22a9f9:	00 
        return output(context, padded_buf);
  22a9fa:	48 8b 7c 24 08       	mov    rdi,QWORD PTR [rsp+0x8]
  22a9ff:	c5 f8 77             	vzeroupper 
  22aa02:	41 ff d4             	call   r12
  22aa05:	41 89 c5             	mov    r13d,eax
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  22aa08:	66 45 85 ed          	test   r13w,r13w
  22aa0c:	0f 85 ef 06 00 00    	jne    22b101 <printSourceAtAddressLinux+0x3471>
                        try output(context, fmt[start_index..i]);
  22aa12:	48 8d 35 77 55 02 00 	lea    rsi,[rip+0x25577]        # 24ff90 <__unnamed_86>
  22aa19:	48 8b 7c 24 08       	mov    rdi,QWORD PTR [rsp+0x8]
  22aa1e:	41 ff d4             	call   r12
  22aa21:	41 89 c5             	mov    r13d,eax
  22aa24:	66 45 85 ed          	test   r13w,r13w
  22aa28:	0f 85 d3 06 00 00    	jne    22b101 <printSourceAtAddressLinux+0x3471>
    var buf: [max_int_digits - 1]u8 = undefined;
  22aa2e:	c5 fc 10 05 b9 ec fd 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffdecb9]        # 2096ef <__unnamed_28+0x1f>
  22aa35:	ff 
  22aa36:	c5 fc 11 84 24 cf 00 	vmovups YMMWORD PTR [rsp+0xcf],ymm0
  22aa3d:	00 00 
  22aa3f:	c5 fe 6f 05 89 ec fd 	vmovdqu ymm0,YMMWORD PTR [rip+0xfffffffffffdec89]        # 2096d0 <__unnamed_28>
  22aa46:	ff 
  22aa47:	c5 fe 7f 84 24 b0 00 	vmovdqu YMMWORD PTR [rsp+0xb0],ymm0
  22aa4e:	00 00 
        const digit = a % base;
  22aa50:	4c 89 f2             	mov    rdx,r14
  22aa53:	c4 e2 fb f6 cd       	mulx   rcx,rax,rbp
  22aa58:	c1 e9 02             	shr    ecx,0x2
  22aa5b:	81 e1 fe ff ff 3f    	and    ecx,0x3ffffffe
  22aa61:	8d 0c 89             	lea    ecx,[rcx+rcx*4]
  22aa64:	44 89 f0             	mov    eax,r14d
  22aa67:	29 c8                	sub    eax,ecx
        0...9 => digit + '0',
  22aa69:	b1 30                	mov    cl,0x30
  22aa6b:	3c 0a                	cmp    al,0xa
  22aa6d:	72 02                	jb     22aa71 <printSourceAtAddressLinux+0x2de1>
  22aa6f:	b1 57                	mov    cl,0x57
  22aa71:	00 c1                	add    cl,al
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  22aa73:	88 8c 24 ef 00 00 00 	mov    BYTE PTR [rsp+0xef],cl
  22aa7a:	b8 40 00 00 00       	mov    eax,0x40
        if (a == 0) break;
  22aa7f:	49 83 fe 0a          	cmp    r14,0xa
  22aa83:	0f 83 4c 01 00 00    	jae    22abd5 <printSourceAtAddressLinux+0x2f45>
  22aa89:	48 8d 8c 24 ef 00 00 	lea    rcx,[rsp+0xef]
  22aa90:	00 
  22aa91:	e9 8a 01 00 00       	jmp    22ac20 <printSourceAtAddressLinux+0x2f90>
        a /= base;
  22aa96:	4c 89 fa             	mov    rdx,r15
  22aa99:	c4 e2 f3 f6 d5       	mulx   rdx,rcx,rbp
  22aa9e:	48 c1 ea 03          	shr    rdx,0x3
        const digit = a % base;
  22aaa2:	c4 e2 f3 f6 f5       	mulx   rsi,rcx,rbp
  22aaa7:	c1 ee 02             	shr    esi,0x2
  22aaaa:	81 e6 fe ff ff 3f    	and    esi,0x3ffffffe
  22aab0:	8d 34 b6             	lea    esi,[rsi+rsi*4]
  22aab3:	89 d1                	mov    ecx,edx
  22aab5:	29 f1                	sub    ecx,esi
        0...9 => digit + '0',
  22aab7:	b3 30                	mov    bl,0x30
  22aab9:	80 f9 0a             	cmp    cl,0xa
  22aabc:	72 02                	jb     22aac0 <printSourceAtAddressLinux+0x2e30>
  22aabe:	b3 57                	mov    bl,0x57
  22aac0:	00 cb                	add    bl,cl
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  22aac2:	88 9c 04 ae 00 00 00 	mov    BYTE PTR [rsp+rax*1+0xae],bl
        if (a == 0) break;
  22aac9:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  22aacd:	49 83 ff 63          	cmp    r15,0x63
  22aad1:	49 89 d7             	mov    r15,rdx
  22aad4:	77 c0                	ja     22aa96 <printSourceAtAddressLinux+0x2e06>
        const padded_buf = buf[index - padding ..];
  22aad6:	48 8d 0c 04          	lea    rcx,[rsp+rax*1]
  22aada:	48 81 c1 af 00 00 00 	add    rcx,0xaf
  22aae1:	ba 41 00 00 00       	mov    edx,0x41
  22aae6:	48 29 c2             	sub    rdx,rax
  22aae9:	48 89 8c 24 30 01 00 	mov    QWORD PTR [rsp+0x130],rcx
  22aaf0:	00 
  22aaf1:	48 89 94 24 38 01 00 	mov    QWORD PTR [rsp+0x138],rdx
  22aaf8:	00 
  22aaf9:	48 8d b4 24 30 01 00 	lea    rsi,[rsp+0x130]
  22ab00:	00 
        return output(context, padded_buf);
  22ab01:	48 8b 7c 24 08       	mov    rdi,QWORD PTR [rsp+0x8]
  22ab06:	c5 f8 77             	vzeroupper 
  22ab09:	41 ff d4             	call   r12
  22ab0c:	41 89 c5             	mov    r13d,eax
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  22ab0f:	66 45 85 ed          	test   r13w,r13w
  22ab13:	0f 85 e8 05 00 00    	jne    22b101 <printSourceAtAddressLinux+0x3471>
                        try output(context, fmt[start_index..i]);
  22ab19:	48 8d 35 10 54 02 00 	lea    rsi,[rip+0x25410]        # 24ff30 <__unnamed_87>
  22ab20:	48 8b 7c 24 08       	mov    rdi,QWORD PTR [rsp+0x8]
  22ab25:	41 ff d4             	call   r12
  22ab28:	41 89 c5             	mov    r13d,eax
  22ab2b:	66 45 85 ed          	test   r13w,r13w
  22ab2f:	0f 85 cc 05 00 00    	jne    22b101 <printSourceAtAddressLinux+0x3471>
    var buf: [max_int_digits - 1]u8 = undefined;
  22ab35:	c5 fc 10 05 b2 eb fd 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffdebb2]        # 2096ef <__unnamed_28+0x1f>
  22ab3c:	ff 
  22ab3d:	c5 fc 11 84 24 cf 00 	vmovups YMMWORD PTR [rsp+0xcf],ymm0
  22ab44:	00 00 
  22ab46:	c5 fe 6f 05 82 eb fd 	vmovdqu ymm0,YMMWORD PTR [rip+0xfffffffffffdeb82]        # 2096d0 <__unnamed_28>
  22ab4d:	ff 
  22ab4e:	c5 fe 7f 84 24 b0 00 	vmovdqu YMMWORD PTR [rsp+0xb0],ymm0
  22ab55:	00 00 
        const digit = a % base;
  22ab57:	4c 89 f2             	mov    rdx,r14
  22ab5a:	c4 e2 fb f6 cd       	mulx   rcx,rax,rbp
  22ab5f:	c1 e9 02             	shr    ecx,0x2
  22ab62:	81 e1 fe ff ff 3f    	and    ecx,0x3ffffffe
  22ab68:	8d 0c 89             	lea    ecx,[rcx+rcx*4]
  22ab6b:	44 89 f0             	mov    eax,r14d
  22ab6e:	29 c8                	sub    eax,ecx
        0...9 => digit + '0',
  22ab70:	b1 30                	mov    cl,0x30
  22ab72:	3c 0a                	cmp    al,0xa
  22ab74:	72 02                	jb     22ab78 <printSourceAtAddressLinux+0x2ee8>
  22ab76:	b1 57                	mov    cl,0x57
  22ab78:	00 c1                	add    cl,al
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  22ab7a:	88 8c 24 ef 00 00 00 	mov    BYTE PTR [rsp+0xef],cl
  22ab81:	b9 40 00 00 00       	mov    ecx,0x40
        if (a == 0) break;
  22ab86:	49 83 fe 0a          	cmp    r14,0xa
  22ab8a:	0f 83 3a 01 00 00    	jae    22acca <printSourceAtAddressLinux+0x303a>
  22ab90:	48 8d 84 24 ef 00 00 	lea    rax,[rsp+0xef]
  22ab97:	00 
  22ab98:	e9 7c 01 00 00       	jmp    22ad19 <printSourceAtAddressLinux+0x3089>
  22ab9d:	66 41 bd 03 00       	mov    r13w,0x3
                        try in_file.seekForward(fwd_amt);
  22aba2:	c5 fc 10 84 24 e0 06 	vmovups ymm0,YMMWORD PTR [rsp+0x6e0]
  22aba9:	00 00 
  22abab:	c5 fe 6f 8c 24 ee 06 	vmovdqu ymm1,YMMWORD PTR [rsp+0x6ee]
  22abb2:	00 00 
  22abb4:	e9 40 e0 ff ff       	jmp    228bf9 <printSourceAtAddressLinux+0xf69>
  22abb9:	66 41 bd 03 00       	mov    r13w,0x3
                        try in_file.seekForward(len_bytes);
  22abbe:	c5 fc 10 84 24 42 05 	vmovups ymm0,YMMWORD PTR [rsp+0x542]
  22abc5:	00 00 
  22abc7:	c5 fe 6f 8c 24 50 05 	vmovdqu ymm1,YMMWORD PTR [rsp+0x550]
  22abce:	00 00 
  22abd0:	e9 24 e0 ff ff       	jmp    228bf9 <printSourceAtAddressLinux+0xf69>
        a /= base;
  22abd5:	4c 89 f2             	mov    rdx,r14
  22abd8:	c4 e2 f3 f6 d5       	mulx   rdx,rcx,rbp
  22abdd:	48 c1 ea 03          	shr    rdx,0x3
        const digit = a % base;
  22abe1:	c4 e2 f3 f6 f5       	mulx   rsi,rcx,rbp
  22abe6:	c1 ee 02             	shr    esi,0x2
  22abe9:	81 e6 fe ff ff 3f    	and    esi,0x3ffffffe
  22abef:	8d 34 b6             	lea    esi,[rsi+rsi*4]
  22abf2:	89 d1                	mov    ecx,edx
  22abf4:	29 f1                	sub    ecx,esi
        0...9 => digit + '0',
  22abf6:	b3 30                	mov    bl,0x30
  22abf8:	80 f9 0a             	cmp    cl,0xa
  22abfb:	72 02                	jb     22abff <printSourceAtAddressLinux+0x2f6f>
  22abfd:	b3 57                	mov    bl,0x57
  22abff:	00 cb                	add    bl,cl
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  22ac01:	88 9c 04 ae 00 00 00 	mov    BYTE PTR [rsp+rax*1+0xae],bl
        if (a == 0) break;
  22ac08:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  22ac0c:	49 83 fe 63          	cmp    r14,0x63
  22ac10:	49 89 d6             	mov    r14,rdx
  22ac13:	77 c0                	ja     22abd5 <printSourceAtAddressLinux+0x2f45>
        const padded_buf = buf[index - padding ..];
  22ac15:	48 8d 0c 04          	lea    rcx,[rsp+rax*1]
  22ac19:	48 81 c1 af 00 00 00 	add    rcx,0xaf
  22ac20:	ba 41 00 00 00       	mov    edx,0x41
  22ac25:	48 29 c2             	sub    rdx,rax
  22ac28:	48 89 8c 24 30 01 00 	mov    QWORD PTR [rsp+0x130],rcx
  22ac2f:	00 
  22ac30:	48 89 94 24 38 01 00 	mov    QWORD PTR [rsp+0x138],rdx
  22ac37:	00 
  22ac38:	48 8d b4 24 30 01 00 	lea    rsi,[rsp+0x130]
  22ac3f:	00 
        return output(context, padded_buf);
  22ac40:	48 8b 7c 24 08       	mov    rdi,QWORD PTR [rsp+0x8]
  22ac45:	c5 f8 77             	vzeroupper 
  22ac48:	41 ff d4             	call   r12
  22ac4b:	41 89 c5             	mov    r13d,eax
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  22ac4e:	66 45 85 ed          	test   r13w,r13w
  22ac52:	0f 85 a9 04 00 00    	jne    22b101 <printSourceAtAddressLinux+0x3471>
                        try output(context, fmt[start_index..i]);
  22ac58:	48 8d 35 41 53 02 00 	lea    rsi,[rip+0x25341]        # 24ffa0 <__unnamed_88>
  22ac5f:	48 8b 7c 24 08       	mov    rdi,QWORD PTR [rsp+0x8]
  22ac64:	41 ff d4             	call   r12
  22ac67:	41 89 c5             	mov    r13d,eax
  22ac6a:	66 45 85 ed          	test   r13w,r13w
  22ac6e:	0f 85 8d 04 00 00    	jne    22b101 <printSourceAtAddressLinux+0x3471>
    var buf: [max_int_digits - 1]u8 = undefined;
  22ac74:	c5 fc 10 05 73 ea fd 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffdea73]        # 2096ef <__unnamed_28+0x1f>
  22ac7b:	ff 
  22ac7c:	c5 fc 11 84 24 cf 00 	vmovups YMMWORD PTR [rsp+0xcf],ymm0
  22ac83:	00 00 
  22ac85:	c5 fe 6f 05 43 ea fd 	vmovdqu ymm0,YMMWORD PTR [rip+0xfffffffffffdea43]        # 2096d0 <__unnamed_28>
  22ac8c:	ff 
  22ac8d:	c5 fe 7f 84 24 b0 00 	vmovdqu YMMWORD PTR [rsp+0xb0],ymm0
  22ac94:	00 00 
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  22ac96:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  22ac9d:	00 
  22ac9e:	24 0f                	and    al,0xf
        0...9 => digit + '0',
  22aca0:	b1 30                	mov    cl,0x30
  22aca2:	3c 0a                	cmp    al,0xa
  22aca4:	72 02                	jb     22aca8 <printSourceAtAddressLinux+0x3018>
  22aca6:	b1 57                	mov    cl,0x57
  22aca8:	00 c1                	add    cl,al
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  22acaa:	88 8c 24 ef 00 00 00 	mov    BYTE PTR [rsp+0xef],cl
        if (a == 0) break;
  22acb1:	48 83 bc 24 a8 00 00 	cmp    QWORD PTR [rsp+0xa8],0x10
  22acb8:	00 10 
  22acba:	0f 83 03 01 00 00    	jae    22adc3 <printSourceAtAddressLinux+0x3133>
  22acc0:	b8 40 00 00 00       	mov    eax,0x40
  22acc5:	e9 4e 01 00 00       	jmp    22ae18 <printSourceAtAddressLinux+0x3188>
  22acca:	4c 89 f0             	mov    rax,r14
        a /= base;
  22accd:	48 89 c2             	mov    rdx,rax
  22acd0:	c4 e2 cb f6 d5       	mulx   rdx,rsi,rbp
  22acd5:	48 c1 ea 03          	shr    rdx,0x3
        const digit = a % base;
  22acd9:	c4 e2 cb f6 fd       	mulx   rdi,rsi,rbp
  22acde:	c1 ef 02             	shr    edi,0x2
  22ace1:	81 e7 fe ff ff 3f    	and    edi,0x3ffffffe
  22ace7:	8d 3c bf             	lea    edi,[rdi+rdi*4]
  22acea:	89 d6                	mov    esi,edx
  22acec:	29 fe                	sub    esi,edi
        0...9 => digit + '0',
  22acee:	b3 30                	mov    bl,0x30
  22acf0:	40 80 fe 0a          	cmp    sil,0xa
  22acf4:	72 02                	jb     22acf8 <printSourceAtAddressLinux+0x3068>
  22acf6:	b3 57                	mov    bl,0x57
  22acf8:	40 00 f3             	add    bl,sil
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  22acfb:	88 9c 0c ae 00 00 00 	mov    BYTE PTR [rsp+rcx*1+0xae],bl
        if (a == 0) break;
  22ad02:	48 83 c1 ff          	add    rcx,0xffffffffffffffff
  22ad06:	48 83 f8 63          	cmp    rax,0x63
  22ad0a:	48 89 d0             	mov    rax,rdx
  22ad0d:	77 be                	ja     22accd <printSourceAtAddressLinux+0x303d>
        const padded_buf = buf[index - padding ..];
  22ad0f:	48 8d 04 0c          	lea    rax,[rsp+rcx*1]
  22ad13:	48 05 af 00 00 00    	add    rax,0xaf
  22ad19:	ba 41 00 00 00       	mov    edx,0x41
  22ad1e:	48 29 ca             	sub    rdx,rcx
  22ad21:	48 89 84 24 30 01 00 	mov    QWORD PTR [rsp+0x130],rax
  22ad28:	00 
  22ad29:	48 89 94 24 38 01 00 	mov    QWORD PTR [rsp+0x138],rdx
  22ad30:	00 
  22ad31:	48 8d b4 24 30 01 00 	lea    rsi,[rsp+0x130]
  22ad38:	00 
        return output(context, padded_buf);
  22ad39:	48 8b 7c 24 08       	mov    rdi,QWORD PTR [rsp+0x8]
  22ad3e:	c5 f8 77             	vzeroupper 
  22ad41:	41 ff d4             	call   r12
  22ad44:	41 89 c5             	mov    r13d,eax
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  22ad47:	66 45 85 ed          	test   r13w,r13w
  22ad4b:	0f 85 b0 03 00 00    	jne    22b101 <printSourceAtAddressLinux+0x3471>
                        try output(context, fmt[start_index..i]);
  22ad51:	48 8d 35 e8 51 02 00 	lea    rsi,[rip+0x251e8]        # 24ff40 <__unnamed_89>
  22ad58:	48 8b 7c 24 08       	mov    rdi,QWORD PTR [rsp+0x8]
  22ad5d:	41 ff d4             	call   r12
  22ad60:	41 89 c5             	mov    r13d,eax
  22ad63:	66 45 85 ed          	test   r13w,r13w
  22ad67:	0f 85 94 03 00 00    	jne    22b101 <printSourceAtAddressLinux+0x3471>
    var buf: [max_int_digits - 1]u8 = undefined;
  22ad6d:	c5 fc 10 05 7a e9 fd 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffde97a]        # 2096ef <__unnamed_28+0x1f>
  22ad74:	ff 
  22ad75:	c5 fc 11 84 24 cf 00 	vmovups YMMWORD PTR [rsp+0xcf],ymm0
  22ad7c:	00 00 
  22ad7e:	c5 fe 6f 05 4a e9 fd 	vmovdqu ymm0,YMMWORD PTR [rip+0xfffffffffffde94a]        # 2096d0 <__unnamed_28>
  22ad85:	ff 
  22ad86:	c5 fe 7f 84 24 b0 00 	vmovdqu YMMWORD PTR [rsp+0xb0],ymm0
  22ad8d:	00 00 
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  22ad8f:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  22ad96:	00 
  22ad97:	24 0f                	and    al,0xf
        0...9 => digit + '0',
  22ad99:	b1 30                	mov    cl,0x30
  22ad9b:	3c 0a                	cmp    al,0xa
  22ad9d:	72 02                	jb     22ada1 <printSourceAtAddressLinux+0x3111>
  22ad9f:	b1 57                	mov    cl,0x57
  22ada1:	00 c1                	add    cl,al
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  22ada3:	88 8c 24 ef 00 00 00 	mov    BYTE PTR [rsp+0xef],cl
        if (a == 0) break;
  22adaa:	48 83 bc 24 a8 00 00 	cmp    QWORD PTR [rsp+0xa8],0x10
  22adb1:	00 10 
  22adb3:	0f 83 5c 01 00 00    	jae    22af15 <printSourceAtAddressLinux+0x3285>
  22adb9:	b8 40 00 00 00       	mov    eax,0x40
  22adbe:	e9 a7 01 00 00       	jmp    22af6a <printSourceAtAddressLinux+0x32da>
  22adc3:	b8 40 00 00 00       	mov    eax,0x40
        a /= base;
  22adc8:	48 8b 8c 24 a8 00 00 	mov    rcx,QWORD PTR [rsp+0xa8]
  22adcf:	00 
  22add0:	48 c1 e9 04          	shr    rcx,0x4
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  22add4:	89 ca                	mov    edx,ecx
  22add6:	80 e2 0f             	and    dl,0xf
        0...9 => digit + '0',
  22add9:	b3 30                	mov    bl,0x30
  22addb:	80 fa 0a             	cmp    dl,0xa
  22adde:	72 02                	jb     22ade2 <printSourceAtAddressLinux+0x3152>
  22ade0:	b3 57                	mov    bl,0x57
  22ade2:	00 d3                	add    bl,dl
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  22ade4:	88 9c 04 ae 00 00 00 	mov    BYTE PTR [rsp+rax*1+0xae],bl
        if (a == 0) break;
  22adeb:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  22adef:	48 81 bc 24 a8 00 00 	cmp    QWORD PTR [rsp+0xa8],0xff
  22adf6:	00 ff 00 00 00 
  22adfb:	48 89 8c 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],rcx
  22ae02:	00 
  22ae03:	77 cb                	ja     22add0 <printSourceAtAddressLinux+0x3140>
        const padded_buf = buf[index - padding ..];
  22ae05:	48 8d 0c 04          	lea    rcx,[rsp+rax*1]
  22ae09:	48 81 c1 af 00 00 00 	add    rcx,0xaf
  22ae10:	48 89 8c 24 c0 01 00 	mov    QWORD PTR [rsp+0x1c0],rcx
  22ae17:	00 
  22ae18:	b9 41 00 00 00       	mov    ecx,0x41
  22ae1d:	48 29 c1             	sub    rcx,rax
  22ae20:	48 8b 84 24 c0 01 00 	mov    rax,QWORD PTR [rsp+0x1c0]
  22ae27:	00 
  22ae28:	48 89 84 24 30 01 00 	mov    QWORD PTR [rsp+0x130],rax
  22ae2f:	00 
  22ae30:	48 89 8c 24 38 01 00 	mov    QWORD PTR [rsp+0x138],rcx
  22ae37:	00 
  22ae38:	48 8d b4 24 30 01 00 	lea    rsi,[rsp+0x130]
  22ae3f:	00 
        return output(context, padded_buf);
  22ae40:	48 8b 7c 24 08       	mov    rdi,QWORD PTR [rsp+0x8]
  22ae45:	c5 f8 77             	vzeroupper 
  22ae48:	41 ff d4             	call   r12
  22ae4b:	41 89 c5             	mov    r13d,eax
                    try formatType(args[next_arg], fmt[s..i], context, Errors, output);
  22ae4e:	66 45 85 ed          	test   r13w,r13w
  22ae52:	0f 85 a9 02 00 00    	jne    22b101 <printSourceAtAddressLinux+0x3471>
                        try output(context, fmt[start_index..i]);
  22ae58:	48 8d 35 51 51 02 00 	lea    rsi,[rip+0x25151]        # 24ffb0 <__unnamed_90>
  22ae5f:	48 8b 7c 24 08       	mov    rdi,QWORD PTR [rsp+0x8]
  22ae64:	41 ff d4             	call   r12
  22ae67:	41 89 c5             	mov    r13d,eax
  22ae6a:	66 45 85 ed          	test   r13w,r13w
  22ae6e:	0f 85 8d 02 00 00    	jne    22b101 <printSourceAtAddressLinux+0x3471>
                const casted_value = ([]const u8)(value);
  22ae74:	c5 fa 6f 05 24 50 02 	vmovdqu xmm0,XMMWORD PTR [rip+0x25024]        # 24fea0 <__unnamed_91>
  22ae7b:	00 
  22ae7c:	c5 f9 7f 84 24 b0 00 	vmovdqa XMMWORD PTR [rsp+0xb0],xmm0
  22ae83:	00 00 
  22ae85:	48 8d b4 24 b0 00 00 	lea    rsi,[rsp+0xb0]
  22ae8c:	00 
                return output(context, casted_value);
  22ae8d:	48 8b 7c 24 08       	mov    rdi,QWORD PTR [rsp+0x8]
  22ae92:	41 ff d4             	call   r12
  22ae95:	41 89 c5             	mov    r13d,eax
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  22ae98:	66 45 85 ed          	test   r13w,r13w
  22ae9c:	0f 85 5f 02 00 00    	jne    22b101 <printSourceAtAddressLinux+0x3471>
                        try output(context, fmt[start_index..i]);
  22aea2:	48 8d 35 17 51 02 00 	lea    rsi,[rip+0x25117]        # 24ffc0 <__unnamed_92>
  22aea9:	48 8b 7c 24 08       	mov    rdi,QWORD PTR [rsp+0x8]
  22aeae:	41 ff d4             	call   r12
  22aeb1:	41 89 c5             	mov    r13d,eax
  22aeb4:	66 45 85 ed          	test   r13w,r13w
  22aeb8:	0f 85 43 02 00 00    	jne    22b101 <printSourceAtAddressLinux+0x3471>
                const casted_value = ([]const u8)(value);
  22aebe:	c5 f9 6f 84 24 10 02 	vmovdqa xmm0,XMMWORD PTR [rsp+0x210]
  22aec5:	00 00 
  22aec7:	c5 f9 7f 84 24 b0 00 	vmovdqa XMMWORD PTR [rsp+0xb0],xmm0
  22aece:	00 00 
  22aed0:	48 8d b4 24 b0 00 00 	lea    rsi,[rsp+0xb0]
  22aed7:	00 
                return output(context, casted_value);
  22aed8:	48 8b 7c 24 08       	mov    rdi,QWORD PTR [rsp+0x8]
  22aedd:	41 ff d4             	call   r12
  22aee0:	41 89 c5             	mov    r13d,eax
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  22aee3:	66 45 85 ed          	test   r13w,r13w
  22aee7:	0f 85 14 02 00 00    	jne    22b101 <printSourceAtAddressLinux+0x3471>
        try output(context, fmt[start_index..]);
  22aeed:	48 8d 35 dc 50 02 00 	lea    rsi,[rip+0x250dc]        # 24ffd0 <__unnamed_93>
  22aef4:	48 8b 7c 24 08       	mov    rdi,QWORD PTR [rsp+0x8]
  22aef9:	41 ff d4             	call   r12
  22aefc:	41 89 c5             	mov    r13d,eax
        const bytes = @sliceToBytes(memory);
  22aeff:	48 8b 84 24 b8 02 00 	mov    rax,QWORD PTR [rsp+0x2b8]
  22af06:	00 
        if (bytes.len == 0) return;
  22af07:	48 85 c0             	test   rax,rax
  22af0a:	0f 85 02 02 00 00    	jne    22b112 <printSourceAtAddressLinux+0x3482>
  22af10:	e9 06 dd ff ff       	jmp    228c1b <printSourceAtAddressLinux+0xf8b>
  22af15:	b8 40 00 00 00       	mov    eax,0x40
        a /= base;
  22af1a:	48 8b 8c 24 a8 00 00 	mov    rcx,QWORD PTR [rsp+0xa8]
  22af21:	00 
  22af22:	48 c1 e9 04          	shr    rcx,0x4
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  22af26:	89 ca                	mov    edx,ecx
  22af28:	80 e2 0f             	and    dl,0xf
        0...9 => digit + '0',
  22af2b:	b3 30                	mov    bl,0x30
  22af2d:	80 fa 0a             	cmp    dl,0xa
  22af30:	72 02                	jb     22af34 <printSourceAtAddressLinux+0x32a4>
  22af32:	b3 57                	mov    bl,0x57
  22af34:	00 d3                	add    bl,dl
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  22af36:	88 9c 04 ae 00 00 00 	mov    BYTE PTR [rsp+rax*1+0xae],bl
        if (a == 0) break;
  22af3d:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  22af41:	48 81 bc 24 a8 00 00 	cmp    QWORD PTR [rsp+0xa8],0xff
  22af48:	00 ff 00 00 00 
  22af4d:	48 89 8c 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],rcx
  22af54:	00 
  22af55:	77 cb                	ja     22af22 <printSourceAtAddressLinux+0x3292>
        const padded_buf = buf[index - padding ..];
  22af57:	48 8d 0c 04          	lea    rcx,[rsp+rax*1]
  22af5b:	48 81 c1 af 00 00 00 	add    rcx,0xaf
  22af62:	48 89 8c 24 c0 01 00 	mov    QWORD PTR [rsp+0x1c0],rcx
  22af69:	00 
  22af6a:	b9 41 00 00 00       	mov    ecx,0x41
  22af6f:	48 29 c1             	sub    rcx,rax
  22af72:	48 8b 84 24 c0 01 00 	mov    rax,QWORD PTR [rsp+0x1c0]
  22af79:	00 
  22af7a:	48 89 84 24 30 01 00 	mov    QWORD PTR [rsp+0x130],rax
  22af81:	00 
  22af82:	48 89 8c 24 38 01 00 	mov    QWORD PTR [rsp+0x138],rcx
  22af89:	00 
  22af8a:	4c 8d bc 24 30 01 00 	lea    r15,[rsp+0x130]
  22af91:	00 
        return output(context, padded_buf);
  22af92:	48 8b 7c 24 08       	mov    rdi,QWORD PTR [rsp+0x8]
  22af97:	4c 89 fe             	mov    rsi,r15
  22af9a:	c5 f8 77             	vzeroupper 
  22af9d:	41 ff d4             	call   r12
  22afa0:	41 89 c5             	mov    r13d,eax
                    try formatType(args[next_arg], fmt[s..i], context, Errors, output);
  22afa3:	66 45 85 ed          	test   r13w,r13w
  22afa7:	0f 85 54 01 00 00    	jne    22b101 <printSourceAtAddressLinux+0x3471>
                        try output(context, fmt[start_index..i]);
  22afad:	48 8d 35 9c 4f 02 00 	lea    rsi,[rip+0x24f9c]        # 24ff50 <__unnamed_94>
  22afb4:	48 8b 7c 24 08       	mov    rdi,QWORD PTR [rsp+0x8]
  22afb9:	41 ff d4             	call   r12
  22afbc:	41 89 c5             	mov    r13d,eax
  22afbf:	66 45 85 ed          	test   r13w,r13w
  22afc3:	0f 85 38 01 00 00    	jne    22b101 <printSourceAtAddressLinux+0x3471>
                const casted_value = ([]const u8)(value);
  22afc9:	c5 fa 6f 05 cf 4e 02 	vmovdqu xmm0,XMMWORD PTR [rip+0x24ecf]        # 24fea0 <__unnamed_91>
  22afd0:	00 
  22afd1:	c5 f9 7f 84 24 b0 00 	vmovdqa XMMWORD PTR [rsp+0xb0],xmm0
  22afd8:	00 00 
  22afda:	48 8d b4 24 b0 00 00 	lea    rsi,[rsp+0xb0]
  22afe1:	00 
                return output(context, casted_value);
  22afe2:	48 8b 7c 24 08       	mov    rdi,QWORD PTR [rsp+0x8]
  22afe7:	41 ff d4             	call   r12
  22afea:	41 89 c5             	mov    r13d,eax
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  22afed:	66 45 85 ed          	test   r13w,r13w
  22aff1:	0f 85 0a 01 00 00    	jne    22b101 <printSourceAtAddressLinux+0x3471>
                        try output(context, fmt[start_index..i]);
  22aff7:	48 8d 35 62 4f 02 00 	lea    rsi,[rip+0x24f62]        # 24ff60 <__unnamed_95>
  22affe:	48 8b 7c 24 08       	mov    rdi,QWORD PTR [rsp+0x8]
  22b003:	41 ff d4             	call   r12
  22b006:	41 89 c5             	mov    r13d,eax
  22b009:	66 45 85 ed          	test   r13w,r13w
  22b00d:	0f 85 ee 00 00 00    	jne    22b101 <printSourceAtAddressLinux+0x3471>
                const casted_value = ([]const u8)(value);
  22b013:	c5 f9 6f 84 24 10 02 	vmovdqa xmm0,XMMWORD PTR [rsp+0x210]
  22b01a:	00 00 
  22b01c:	c5 f9 7f 84 24 b0 00 	vmovdqa XMMWORD PTR [rsp+0xb0],xmm0
  22b023:	00 00 
  22b025:	48 8d b4 24 b0 00 00 	lea    rsi,[rsp+0xb0]
  22b02c:	00 
                return output(context, casted_value);
  22b02d:	48 8b 7c 24 08       	mov    rdi,QWORD PTR [rsp+0x8]
  22b032:	41 ff d4             	call   r12
  22b035:	41 89 c5             	mov    r13d,eax
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  22b038:	66 45 85 ed          	test   r13w,r13w
  22b03c:	0f 85 bf 00 00 00    	jne    22b101 <printSourceAtAddressLinux+0x3471>
        try output(context, fmt[start_index..]);
  22b042:	48 8d 35 27 4f 02 00 	lea    rsi,[rip+0x24f27]        # 24ff70 <__unnamed_96>
  22b049:	48 8b 7c 24 08       	mov    rdi,QWORD PTR [rsp+0x8]
  22b04e:	41 ff d4             	call   r12
  22b051:	41 89 c5             	mov    r13d,eax
        try out_stream.print(
  22b054:	66 45 85 ed          	test   r13w,r13w
  22b058:	0f 85 a3 00 00 00    	jne    22b101 <printSourceAtAddressLinux+0x3471>
  22b05e:	48 8d b4 24 a0 02 00 	lea    rsi,[rsp+0x2a0]
  22b065:	00 
        if (printLineFromFile(out_stream, line_info)) {
  22b066:	48 8b 7c 24 08       	mov    rdi,QWORD PTR [rsp+0x8]
  22b06b:	e8 d0 0f 00 00       	call   22c040 <printLineFromFile>
  22b070:	41 89 c5             	mov    r13d,eax
  22b073:	41 0f b7 c5          	movzx  eax,r13w
  22b077:	83 f8 2a             	cmp    eax,0x2a
  22b07a:	74 1a                	je     22b096 <printSourceAtAddressLinux+0x3406>
  22b07c:	66 45 85 ed          	test   r13w,r13w
  22b080:	75 7f                	jne    22b101 <printSourceAtAddressLinux+0x3471>
            if (line_info.column == 0) {
  22b082:	49 83 fe 01          	cmp    r14,0x1
  22b086:	74 68                	je     22b0f0 <printSourceAtAddressLinux+0x3460>
  22b088:	4d 85 f6             	test   r14,r14
  22b08b:	75 1e                	jne    22b0ab <printSourceAtAddressLinux+0x341b>
        }

        pub fn write(self: *Self, bytes: []const u8) !void {
            return self.writeFn(self, bytes);
  22b08d:	48 8d 35 5c 4e 02 00 	lea    rsi,[rip+0x24e5c]        # 24fef0 <__unnamed_3>
  22b094:	eb 61                	jmp    22b0f7 <printSourceAtAddressLinux+0x3467>
  22b096:	45 31 ed             	xor    r13d,r13d
        const bytes = @sliceToBytes(memory);
  22b099:	48 8b 84 24 b8 02 00 	mov    rax,QWORD PTR [rsp+0x2b8]
  22b0a0:	00 
        if (bytes.len == 0) return;
  22b0a1:	48 85 c0             	test   rax,rax
  22b0a4:	75 6c                	jne    22b112 <printSourceAtAddressLinux+0x3482>
  22b0a6:	e9 70 db ff ff       	jmp    228c1b <printSourceAtAddressLinux+0xf8b>
  22b0ab:	bd 01 00 00 00       	mov    ebp,0x1
  22b0b0:	48 8d 9c 24 b0 00 00 	lea    rbx,[rsp+0xb0]
  22b0b7:	00 
  22b0b8:	c6 84 24 30 01 00 00 	mov    BYTE PTR [rsp+0x130],0x20
  22b0bf:	20 
        }

        pub fn writeByte(self: *Self, byte: u8) !void {
            const slice = (*[1]u8)(&byte)[0..];
  22b0c0:	4c 89 bc 24 b0 00 00 	mov    QWORD PTR [rsp+0xb0],r15
  22b0c7:	00 
  22b0c8:	48 c7 84 24 b8 00 00 	mov    QWORD PTR [rsp+0xb8],0x1
  22b0cf:	00 01 00 00 00 
  22b0d4:	48 8b 7c 24 08       	mov    rdi,QWORD PTR [rsp+0x8]
            return self.writeFn(self, slice);
  22b0d9:	48 89 de             	mov    rsi,rbx
  22b0dc:	ff 17                	call   QWORD PTR [rdi]
  22b0de:	41 89 c5             	mov    r13d,eax
                        try out_stream.writeByte(' ');
  22b0e1:	66 45 85 ed          	test   r13w,r13w
  22b0e5:	75 1a                	jne    22b101 <printSourceAtAddressLinux+0x3471>
  22b0e7:	48 83 c5 01          	add    rbp,0x1
                    while (col_i < line_info.column) : (col_i += 1) {
  22b0eb:	4c 39 f5             	cmp    rbp,r14
  22b0ee:	72 c8                	jb     22b0b8 <printSourceAtAddressLinux+0x3428>
            return self.writeFn(self, bytes);
  22b0f0:	48 8d 35 09 4e 02 00 	lea    rsi,[rip+0x24e09]        # 24ff00 <__unnamed_97>
  22b0f7:	48 8b 7c 24 08       	mov    rdi,QWORD PTR [rsp+0x8]
  22b0fc:	ff 17                	call   QWORD PTR [rdi]
  22b0fe:	41 89 c5             	mov    r13d,eax
        const bytes = @sliceToBytes(memory);
  22b101:	48 8b 84 24 b8 02 00 	mov    rax,QWORD PTR [rsp+0x2b8]
  22b108:	00 
        if (bytes.len == 0) return;
  22b109:	48 85 c0             	test   rax,rax
  22b10c:	0f 84 09 db ff ff    	je     228c1b <printSourceAtAddressLinux+0xf8b>
  22b112:	48 8b bc 24 c0 02 00 	mov    rdi,QWORD PTR [rsp+0x2c0]
  22b119:	00 
        const bytes = @sliceToBytes(memory);
  22b11a:	48 8b 8c 24 b0 02 00 	mov    rcx,QWORD PTR [rsp+0x2b0]
  22b121:	00 
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  22b122:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  22b126:	48 89 8c 24 b0 00 00 	mov    QWORD PTR [rsp+0xb0],rcx
  22b12d:	00 
  22b12e:	48 89 84 24 b8 00 00 	mov    QWORD PTR [rsp+0xb8],rax
  22b135:	00 
  22b136:	48 8d b4 24 b0 00 00 	lea    rsi,[rsp+0xb0]
  22b13d:	00 
  22b13e:	ff d2                	call   rdx
  22b140:	e9 d6 da ff ff       	jmp    228c1b <printSourceAtAddressLinux+0xf8b>
  22b145:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  22b14c:	00 00 00 00 

000000000022b150 <Allocator_alignedRealloc.181>:
    pub fn alignedRealloc(self: *Allocator, comptime T: type, comptime alignment: u29, old_mem: []align(alignment) T, n: usize) ![]align(alignment) T {
  22b150:	41 56                	push   r14
  22b152:	53                   	push   rbx
  22b153:	48 83 ec 78          	sub    rsp,0x78
  22b157:	49 89 ce             	mov    r14,rcx
  22b15a:	48 89 fb             	mov    rbx,rdi
        if (old_mem.len == 0) {
  22b15d:	48 8b 42 08          	mov    rax,QWORD PTR [rdx+0x8]
  22b161:	48 85 c0             	test   rax,rax
  22b164:	74 59                	je     22b1bf <Allocator_alignedRealloc.181+0x6f>
        if (n == 0) {
  22b166:	4d 85 f6             	test   r14,r14
  22b169:	0f 84 92 00 00 00    	je     22b201 <Allocator_alignedRealloc.181+0xb1>
        const old_byte_slice = @sliceToBytes(old_mem);
  22b16f:	48 8b 0a             	mov    rcx,QWORD PTR [rdx]
  22b172:	48 89 4c 24 38       	mov    QWORD PTR [rsp+0x38],rcx
  22b177:	48 89 44 24 40       	mov    QWORD PTR [rsp+0x40],rax
  22b17c:	48 8d 7c 24 48       	lea    rdi,[rsp+0x48]
  22b181:	48 8d 54 24 38       	lea    rdx,[rsp+0x38]
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  22b186:	41 b8 01 00 00 00    	mov    r8d,0x1
  22b18c:	4c 89 f1             	mov    rcx,r14
  22b18f:	ff 56 08             	call   QWORD PTR [rsi+0x8]
  22b192:	0f b7 44 24 48       	movzx  eax,WORD PTR [rsp+0x48]
  22b197:	66 85 c0             	test   ax,ax
  22b19a:	0f 84 9e 00 00 00    	je     22b23e <Allocator_alignedRealloc.181+0xee>
  22b1a0:	66 89 03             	mov    WORD PTR [rbx],ax
  22b1a3:	48 8b 44 24 70       	mov    rax,QWORD PTR [rsp+0x70]
  22b1a8:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  22b1ac:	c5 f8 10 44 24 62    	vmovups xmm0,XMMWORD PTR [rsp+0x62]
  22b1b2:	c5 f8 11 43 02       	vmovups XMMWORD PTR [rbx+0x2],xmm0
  22b1b7:	48 83 c4 78          	add    rsp,0x78
  22b1bb:	5b                   	pop    rbx
  22b1bc:	41 5e                	pop    r14
  22b1be:	c3                   	ret    
        if (n == 0) {
  22b1bf:	4d 85 f6             	test   r14,r14
  22b1c2:	0f 84 a1 00 00 00    	je     22b269 <Allocator_alignedRealloc.181+0x119>
  22b1c8:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  22b1cd:	b9 01 00 00 00       	mov    ecx,0x1
  22b1d2:	4c 89 f2             	mov    rdx,r14
  22b1d5:	ff 16                	call   QWORD PTR [rsi]
  22b1d7:	0f b7 4c 24 20       	movzx  ecx,WORD PTR [rsp+0x20]
  22b1dc:	66 85 c9             	test   cx,cx
  22b1df:	0f 84 a6 00 00 00    	je     22b28b <Allocator_alignedRealloc.181+0x13b>
  22b1e5:	0f b7 44 24 1e       	movzx  eax,WORD PTR [rsp+0x1e]
  22b1ea:	66 89 44 24 0c       	mov    WORD PTR [rsp+0xc],ax
  22b1ef:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  22b1f4:	8b 54 24 1a          	mov    edx,DWORD PTR [rsp+0x1a]
  22b1f8:	89 54 24 08          	mov    DWORD PTR [rsp+0x8],edx
  22b1fc:	e9 af 00 00 00       	jmp    22b2b0 <Allocator_alignedRealloc.181+0x160>
        const bytes = @sliceToBytes(memory);
  22b201:	48 8b 0a             	mov    rcx,QWORD PTR [rdx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  22b204:	48 8b 56 10          	mov    rdx,QWORD PTR [rsi+0x10]
  22b208:	48 89 4c 24 20       	mov    QWORD PTR [rsp+0x20],rcx
  22b20d:	48 89 44 24 28       	mov    QWORD PTR [rsp+0x28],rax
  22b212:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  22b217:	48 89 f7             	mov    rdi,rsi
  22b21a:	48 89 c6             	mov    rsi,rax
  22b21d:	ff d2                	call   rdx
            return ([*]align(alignment) T)(undefined)[0..0];
  22b21f:	48 8b 05 52 d2 fd ff 	mov    rax,QWORD PTR [rip+0xfffffffffffdd252]        # 208478 <__unnamed_98+0x10>
  22b226:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  22b22a:	c5 f8 10 05 36 d2 fd 	vmovups xmm0,XMMWORD PTR [rip+0xfffffffffffdd236]        # 208468 <__unnamed_98>
  22b231:	ff 
  22b232:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  22b236:	48 83 c4 78          	add    rsp,0x78
  22b23a:	5b                   	pop    rbx
  22b23b:	41 5e                	pop    r14
  22b23d:	c3                   	ret    
        assert(byte_slice.len == byte_count);
  22b23e:	4c 39 74 24 58       	cmp    QWORD PTR [rsp+0x58],r14
    if (!ok) {
  22b243:	0f 85 87 00 00 00    	jne    22b2d0 <Allocator_alignedRealloc.181+0x180>
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  22b249:	66 c7 03 00 00       	mov    WORD PTR [rbx],0x0
  22b24e:	0f b7 44 24 12       	movzx  eax,WORD PTR [rsp+0x12]
  22b253:	66 89 43 06          	mov    WORD PTR [rbx+0x6],ax
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  22b257:	48 8b 44 24 50       	mov    rax,QWORD PTR [rsp+0x50]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  22b25c:	8b 4c 24 0e          	mov    ecx,DWORD PTR [rsp+0xe]
  22b260:	89 4b 02             	mov    DWORD PTR [rbx+0x2],ecx
  22b263:	48 89 43 08          	mov    QWORD PTR [rbx+0x8],rax
  22b267:	eb 5b                	jmp    22b2c4 <Allocator_alignedRealloc.181+0x174>
  22b269:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
            return ([*]align(alignment) T)(undefined)[0..0];
  22b26e:	0f b7 0d f9 d1 fd ff 	movzx  ecx,WORD PTR [rip+0xfffffffffffdd1f9]        # 20846e <__unnamed_98+0x6>
  22b275:	66 89 4c 24 0c       	mov    WORD PTR [rsp+0xc],cx
  22b27a:	8b 0d ea d1 fd ff    	mov    ecx,DWORD PTR [rip+0xfffffffffffdd1ea]        # 20846a <__unnamed_98+0x2>
  22b280:	89 4c 24 08          	mov    DWORD PTR [rsp+0x8],ecx
  22b284:	31 c9                	xor    ecx,ecx
  22b286:	45 31 f6             	xor    r14d,r14d
  22b289:	eb 25                	jmp    22b2b0 <Allocator_alignedRealloc.181+0x160>
        assert(byte_slice.len == byte_count);
  22b28b:	4c 39 74 24 30       	cmp    QWORD PTR [rsp+0x30],r14
  22b290:	75 3e                	jne    22b2d0 <Allocator_alignedRealloc.181+0x180>
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  22b292:	48 8b 54 24 28       	mov    rdx,QWORD PTR [rsp+0x28]
  22b297:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  22b29c:	8b 4c 24 14          	mov    ecx,DWORD PTR [rsp+0x14]
  22b2a0:	89 4c 24 08          	mov    DWORD PTR [rsp+0x8],ecx
  22b2a4:	0f b7 4c 24 18       	movzx  ecx,WORD PTR [rsp+0x18]
  22b2a9:	66 89 4c 24 0c       	mov    WORD PTR [rsp+0xc],cx
  22b2ae:	31 c9                	xor    ecx,ecx
            return self.alignedAlloc(T, alignment, n);
  22b2b0:	66 89 0b             	mov    WORD PTR [rbx],cx
  22b2b3:	0f b7 48 04          	movzx  ecx,WORD PTR [rax+0x4]
  22b2b7:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  22b2bb:	8b 00                	mov    eax,DWORD PTR [rax]
  22b2bd:	89 43 02             	mov    DWORD PTR [rbx+0x2],eax
  22b2c0:	48 89 53 08          	mov    QWORD PTR [rbx+0x8],rdx
  22b2c4:	4c 89 73 10          	mov    QWORD PTR [rbx+0x10],r14
  22b2c8:	48 83 c4 78          	add    rsp,0x78
  22b2cc:	5b                   	pop    rbx
  22b2cd:	41 5e                	pop    r14
  22b2cf:	c3                   	ret    
            @panic("assertion failure");
  22b2d0:	48 8d 3d b9 4a 02 00 	lea    rdi,[rip+0x24ab9]        # 24fd90 <__unnamed_2>
  22b2d7:	e8 44 74 fe ff       	call   212720 <panic>
  22b2dc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

000000000022b2e0 <LineNumberProgram_checkLineMatch>:
    pub fn checkLineMatch(self: *LineNumberProgram) !?LineInfo {
  22b2e0:	41 56                	push   r14
  22b2e2:	53                   	push   rbx
  22b2e3:	48 81 ec 98 00 00 00 	sub    rsp,0x98
  22b2ea:	48 89 f3             	mov    rbx,rsi
  22b2ed:	49 89 fe             	mov    r14,rdi
  22b2f0:	48 8b 03             	mov    rax,QWORD PTR [rbx]
        if (self.target_address >= self.prev_address and self.target_address < self.address) {
  22b2f3:	48 8b 4b 28          	mov    rcx,QWORD PTR [rbx+0x28]
  22b2f7:	48 3b 4b 48          	cmp    rcx,QWORD PTR [rbx+0x48]
  22b2fb:	0f 82 b6 00 00 00    	jb     22b3b7 <LineNumberProgram_checkLineMatch+0xd7>
  22b301:	48 39 c1             	cmp    rcx,rax
  22b304:	0f 83 ad 00 00 00    	jae    22b3b7 <LineNumberProgram_checkLineMatch+0xd7>
            const file_entry = if (self.prev_file == 0) {
  22b30a:	48 8b 4b 50          	mov    rcx,QWORD PTR [rbx+0x50]
  22b30e:	48 85 c9             	test   rcx,rcx
  22b311:	0f 84 f8 00 00 00    	je     22b40f <LineNumberProgram_checkLineMatch+0x12f>
            } else if (self.prev_file - 1 >= self.file_entries.len) {
  22b317:	48 83 c1 ff          	add    rcx,0xffffffffffffffff
  22b31b:	48 8b 43 40          	mov    rax,QWORD PTR [rbx+0x40]
  22b31f:	48 3b 48 10          	cmp    rcx,QWORD PTR [rax+0x10]
  22b323:	0f 83 ce 00 00 00    	jae    22b3f7 <LineNumberProgram_checkLineMatch+0x117>
                &self.file_entries.items[self.prev_file - 1];
  22b329:	48 8b 10             	mov    rdx,QWORD PTR [rax]
            const dir_name = if (file_entry.dir_index >= self.include_dirs.len) {
  22b32c:	48 8d 0c 89          	lea    rcx,[rcx+rcx*4]
  22b330:	48 8b 74 ca 10       	mov    rsi,QWORD PTR [rdx+rcx*8+0x10]
  22b335:	48 3b 73 38          	cmp    rsi,QWORD PTR [rbx+0x38]
  22b339:	0f 83 b8 00 00 00    	jae    22b3f7 <LineNumberProgram_checkLineMatch+0x117>
                self.include_dirs[file_entry.dir_index];
  22b33f:	48 8b 7b 30          	mov    rdi,QWORD PTR [rbx+0x30]
  22b343:	48 c1 e6 04          	shl    rsi,0x4
            const dir_name = if (file_entry.dir_index >= self.include_dirs.len) {
  22b347:	c5 f8 10 04 37       	vmovups xmm0,XMMWORD PTR [rdi+rsi*1]
  22b34c:	c5 f8 29 44 24 50    	vmovaps XMMWORD PTR [rsp+0x50],xmm0
            const file_name = try os.path.join(self.file_entries.allocator, dir_name, file_entry.file_name);
  22b352:	48 8b 70 18          	mov    rsi,QWORD PTR [rax+0x18]
  22b356:	48 8d 0c ca          	lea    rcx,[rdx+rcx*8]
  22b35a:	48 8d 7c 24 18       	lea    rdi,[rsp+0x18]
  22b35f:	48 8d 54 24 50       	lea    rdx,[rsp+0x50]
pub fn joinWindows(allocator: *Allocator, paths: ...) ![]u8 {
    return mem.join(allocator, sep_windows, paths);
}

pub fn joinPosix(allocator: *Allocator, paths: ...) ![]u8 {
    return mem.join(allocator, sep_posix, paths);
  22b364:	e8 67 06 00 00       	call   22b9d0 <join.192>
  22b369:	0f b7 44 24 18       	movzx  eax,WORD PTR [rsp+0x18]
  22b36e:	c5 f8 10 44 24 1a    	vmovups xmm0,XMMWORD PTR [rsp+0x1a]
  22b374:	c5 f8 29 44 24 30    	vmovaps XMMWORD PTR [rsp+0x30],xmm0
  22b37a:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  22b37f:	48 89 4c 24 3e       	mov    QWORD PTR [rsp+0x3e],rcx
  22b384:	66 85 c0             	test   ax,ax
  22b387:	0f 84 ab 00 00 00    	je     22b438 <LineNumberProgram_checkLineMatch+0x158>
  22b38d:	66 41 89 06          	mov    WORD PTR [r14],ax
  22b391:	c5 fc 10 44 24 62    	vmovups ymm0,YMMWORD PTR [rsp+0x62]
  22b397:	c5 fc 10 4c 24 78    	vmovups ymm1,YMMWORD PTR [rsp+0x78]
  22b39d:	c4 c1 7c 11 4e 18    	vmovups YMMWORD PTR [r14+0x18],ymm1
  22b3a3:	c4 c1 7c 11 46 02    	vmovups YMMWORD PTR [r14+0x2],ymm0
  22b3a9:	48 81 c4 98 00 00 00 	add    rsp,0x98
  22b3b0:	5b                   	pop    rbx
  22b3b1:	41 5e                	pop    r14
  22b3b3:	c5 f8 77             	vzeroupper 
  22b3b6:	c3                   	ret    
        self.prev_address = self.address;
  22b3b7:	48 89 43 48          	mov    QWORD PTR [rbx+0x48],rax
        self.prev_file = self.file;
  22b3bb:	c5 f8 10 43 08       	vmovups xmm0,XMMWORD PTR [rbx+0x8]
  22b3c0:	c5 f8 11 43 50       	vmovups XMMWORD PTR [rbx+0x50],xmm0
        self.prev_column = self.column;
  22b3c5:	48 8b 43 18          	mov    rax,QWORD PTR [rbx+0x18]
  22b3c9:	48 89 43 60          	mov    QWORD PTR [rbx+0x60],rax
        self.prev_is_stmt = self.is_stmt;
  22b3cd:	8a 43 20             	mov    al,BYTE PTR [rbx+0x20]
  22b3d0:	88 43 68             	mov    BYTE PTR [rbx+0x68],al
        self.prev_basic_block = self.basic_block;
  22b3d3:	8a 43 21             	mov    al,BYTE PTR [rbx+0x21]
  22b3d6:	88 43 69             	mov    BYTE PTR [rbx+0x69],al
        self.prev_end_sequence = self.end_sequence;
  22b3d9:	8a 43 22             	mov    al,BYTE PTR [rbx+0x22]
  22b3dc:	88 43 6a             	mov    BYTE PTR [rbx+0x6a],al
        return null;
  22b3df:	c5 fc 10 05 e1 d1 fd 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffdd1e1]        # 2085c8 <__unnamed_99+0x18>
  22b3e6:	ff 
  22b3e7:	c4 c1 7c 11 46 18    	vmovups YMMWORD PTR [r14+0x18],ymm0
  22b3ed:	c5 fc 10 05 bb d1 fd 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffdd1bb]        # 2085b0 <__unnamed_99>
  22b3f4:	ff 
  22b3f5:	eb 2e                	jmp    22b425 <LineNumberProgram_checkLineMatch+0x145>
  22b3f7:	c5 fc 10 05 91 d1 fd 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffdd191]        # 208590 <__unnamed_100+0x18>
  22b3fe:	ff 
  22b3ff:	c4 c1 7c 11 46 18    	vmovups YMMWORD PTR [r14+0x18],ymm0
  22b405:	c5 fc 10 05 6b d1 fd 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffdd16b]        # 208578 <__unnamed_100>
  22b40c:	ff 
  22b40d:	eb 16                	jmp    22b425 <LineNumberProgram_checkLineMatch+0x145>
                return error.MissingDebugInfo;
  22b40f:	c5 fc 10 05 41 d1 fd 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffdd141]        # 208558 <__unnamed_101+0x18>
  22b416:	ff 
  22b417:	c4 c1 7c 11 46 18    	vmovups YMMWORD PTR [r14+0x18],ymm0
  22b41d:	c5 fc 10 05 1b d1 fd 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffdd11b]        # 208540 <__unnamed_101>
  22b424:	ff 
  22b425:	c4 c1 7c 11 06       	vmovups YMMWORD PTR [r14],ymm0
  22b42a:	48 81 c4 98 00 00 00 	add    rsp,0x98
  22b431:	5b                   	pop    rbx
  22b432:	41 5e                	pop    r14
  22b434:	c5 f8 77             	vzeroupper 
  22b437:	c3                   	ret    
                .allocator = self.file_entries.allocator,
  22b438:	48 8b 43 40          	mov    rax,QWORD PTR [rbx+0x40]
                .line = if (self.prev_line >= 0) @intCast(usize, self.prev_line) else 0,
  22b43c:	48 8b 4b 58          	mov    rcx,QWORD PTR [rbx+0x58]
  22b440:	48 89 ca             	mov    rdx,rcx
  22b443:	48 c1 fa 3f          	sar    rdx,0x3f
  22b447:	c4 e2 e8 f2 c9       	andn   rcx,rdx,rcx
                .column = self.prev_column,
  22b44c:	48 8b 53 60          	mov    rdx,QWORD PTR [rbx+0x60]
                .allocator = self.file_entries.allocator,
  22b450:	48 8b 40 18          	mov    rax,QWORD PTR [rax+0x18]
            return LineInfo{
  22b454:	c6 44 24 0a 01       	mov    BYTE PTR [rsp+0xa],0x1
  22b459:	66 41 c7 06 00 00    	mov    WORD PTR [r14],0x0
  22b45f:	0f b7 74 24 16       	movzx  esi,WORD PTR [rsp+0x16]
  22b464:	66 41 89 76 06       	mov    WORD PTR [r14+0x6],si
  22b469:	8b 74 24 12          	mov    esi,DWORD PTR [rsp+0x12]
  22b46d:	41 89 76 02          	mov    DWORD PTR [r14+0x2],esi
  22b471:	49 89 4e 08          	mov    QWORD PTR [r14+0x8],rcx
  22b475:	49 89 56 10          	mov    QWORD PTR [r14+0x10],rdx
  22b479:	c5 f8 10 44 24 36    	vmovups xmm0,XMMWORD PTR [rsp+0x36]
  22b47f:	c4 c1 78 11 46 18    	vmovups XMMWORD PTR [r14+0x18],xmm0
  22b485:	49 89 46 28          	mov    QWORD PTR [r14+0x28],rax
  22b489:	8a 44 24 0a          	mov    al,BYTE PTR [rsp+0xa]
  22b48d:	41 88 46 30          	mov    BYTE PTR [r14+0x30],al
  22b491:	8a 44 24 11          	mov    al,BYTE PTR [rsp+0x11]
  22b495:	41 88 46 37          	mov    BYTE PTR [r14+0x37],al
  22b499:	0f b7 44 24 0f       	movzx  eax,WORD PTR [rsp+0xf]
  22b49e:	66 41 89 46 35       	mov    WORD PTR [r14+0x35],ax
  22b4a3:	8b 44 24 0b          	mov    eax,DWORD PTR [rsp+0xb]
  22b4a7:	41 89 46 31          	mov    DWORD PTR [r14+0x31],eax
  22b4ab:	48 81 c4 98 00 00 00 	add    rsp,0x98
  22b4b2:	5b                   	pop    rbx
  22b4b3:	41 5e                	pop    r14
  22b4b5:	c3                   	ret    
  22b4b6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  22b4bd:	00 00 00 

000000000022b4c0 <Allocator_alignedRealloc.186>:
    pub fn alignedRealloc(self: *Allocator, comptime T: type, comptime alignment: u29, old_mem: []align(alignment) T, n: usize) ![]align(alignment) T {
  22b4c0:	41 56                	push   r14
  22b4c2:	53                   	push   rbx
  22b4c3:	48 81 ec 88 00 00 00 	sub    rsp,0x88
  22b4ca:	48 89 fb             	mov    rbx,rdi
        if (old_mem.len == 0) {
  22b4cd:	48 8b 42 08          	mov    rax,QWORD PTR [rdx+0x8]
  22b4d1:	48 85 c0             	test   rax,rax
  22b4d4:	74 5e                	je     22b534 <Allocator_alignedRealloc.186+0x74>
        if (n == 0) {
  22b4d6:	48 85 c9             	test   rcx,rcx
  22b4d9:	0f 84 a6 00 00 00    	je     22b585 <Allocator_alignedRealloc.186+0xc5>
        const old_byte_slice = @sliceToBytes(old_mem);
  22b4df:	48 8b 12             	mov    rdx,QWORD PTR [rdx]
  22b4e2:	48 c1 e0 04          	shl    rax,0x4
  22b4e6:	48 89 54 24 38       	mov    QWORD PTR [rsp+0x38],rdx
  22b4eb:	48 89 44 24 40       	mov    QWORD PTR [rsp+0x40],rax
    return if (@mulWithOverflow(T, a, b, &answer)) error.Overflow else answer;
  22b4f0:	ba 10 00 00 00       	mov    edx,0x10
  22b4f5:	48 89 c8             	mov    rax,rcx
  22b4f8:	48 f7 e2             	mul    rdx
  22b4fb:	0f 81 ca 00 00 00    	jno    22b5cb <Allocator_alignedRealloc.186+0x10b>
  22b501:	48 8d 0d b8 4f fd ff 	lea    rcx,[rip+0xfffffffffffd4fb8]        # 2004c0 <__unnamed_27>
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  22b508:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  22b50c:	0f 84 d4 00 00 00    	je     22b5e6 <Allocator_alignedRealloc.186+0x126>
  22b512:	48 8b 05 ef cf fd ff 	mov    rax,QWORD PTR [rip+0xfffffffffffdcfef]        # 208508 <__unnamed_102+0x10>
  22b519:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  22b51d:	c5 f8 10 05 d3 cf fd 	vmovups xmm0,XMMWORD PTR [rip+0xfffffffffffdcfd3]        # 2084f8 <__unnamed_102>
  22b524:	ff 
  22b525:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  22b529:	48 81 c4 88 00 00 00 	add    rsp,0x88
  22b530:	5b                   	pop    rbx
  22b531:	41 5e                	pop    r14
  22b533:	c3                   	ret    
        if (n == 0) {
  22b534:	48 85 c9             	test   rcx,rcx
  22b537:	0f 84 f6 00 00 00    	je     22b633 <Allocator_alignedRealloc.186+0x173>
  22b53d:	ba 10 00 00 00       	mov    edx,0x10
  22b542:	48 89 c8             	mov    rax,rcx
  22b545:	48 f7 e2             	mul    rdx
  22b548:	0f 81 07 01 00 00    	jno    22b655 <Allocator_alignedRealloc.186+0x195>
  22b54e:	48 8d 0d 6b 4f fd ff 	lea    rcx,[rip+0xfffffffffffd4f6b]        # 2004c0 <__unnamed_27>
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  22b555:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  22b559:	0f 84 11 01 00 00    	je     22b670 <Allocator_alignedRealloc.186+0x1b0>
  22b55f:	0f b7 05 98 cf fd ff 	movzx  eax,WORD PTR [rip+0xfffffffffffdcf98]        # 2084fe <__unnamed_102+0x6>
  22b566:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  22b56b:	8b 05 89 cf fd ff    	mov    eax,DWORD PTR [rip+0xfffffffffffdcf89]        # 2084fa <__unnamed_102+0x2>
  22b571:	89 04 24             	mov    DWORD PTR [rsp],eax
  22b574:	48 89 e0             	mov    rax,rsp
  22b577:	66 b9 01 00          	mov    cx,0x1
  22b57b:	31 d2                	xor    edx,edx
  22b57d:	45 31 f6             	xor    r14d,r14d
  22b580:	e9 6f 01 00 00       	jmp    22b6f4 <Allocator_alignedRealloc.186+0x234>
        const bytes = @sliceToBytes(memory);
  22b585:	48 c1 e0 04          	shl    rax,0x4
        if (bytes.len == 0) return;
  22b589:	74 1e                	je     22b5a9 <Allocator_alignedRealloc.186+0xe9>
        const bytes = @sliceToBytes(memory);
  22b58b:	48 8b 0a             	mov    rcx,QWORD PTR [rdx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  22b58e:	48 8b 56 10          	mov    rdx,QWORD PTR [rsi+0x10]
  22b592:	48 89 4c 24 08       	mov    QWORD PTR [rsp+0x8],rcx
  22b597:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  22b59c:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  22b5a1:	48 89 f7             	mov    rdi,rsi
  22b5a4:	48 89 c6             	mov    rsi,rax
  22b5a7:	ff d2                	call   rdx
            return ([*]align(alignment) T)(undefined)[0..0];
  22b5a9:	48 8b 05 40 cf fd ff 	mov    rax,QWORD PTR [rip+0xfffffffffffdcf40]        # 2084f0 <__unnamed_103+0x10>
  22b5b0:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  22b5b4:	c5 f8 10 05 24 cf fd 	vmovups xmm0,XMMWORD PTR [rip+0xfffffffffffdcf24]        # 2084e0 <__unnamed_103>
  22b5bb:	ff 
  22b5bc:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  22b5c0:	48 81 c4 88 00 00 00 	add    rsp,0x88
  22b5c7:	5b                   	pop    rbx
  22b5c8:	41 5e                	pop    r14
  22b5ca:	c3                   	ret    
  22b5cb:	48 8d 4c 24 08       	lea    rcx,[rsp+0x8]
  22b5d0:	66 c7 44 24 08 00 00 	mov    WORD PTR [rsp+0x8],0x0
  22b5d7:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  22b5dc:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  22b5e0:	0f 85 2c ff ff ff    	jne    22b512 <Allocator_alignedRealloc.186+0x52>
  22b5e6:	4c 8b 71 08          	mov    r14,QWORD PTR [rcx+0x8]
  22b5ea:	48 8d 7c 24 58       	lea    rdi,[rsp+0x58]
  22b5ef:	48 8d 54 24 38       	lea    rdx,[rsp+0x38]
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  22b5f4:	41 b8 08 00 00 00    	mov    r8d,0x8
  22b5fa:	4c 89 f1             	mov    rcx,r14
  22b5fd:	ff 56 08             	call   QWORD PTR [rsi+0x8]
  22b600:	0f b7 44 24 58       	movzx  eax,WORD PTR [rsp+0x58]
  22b605:	66 85 c0             	test   ax,ax
  22b608:	0f 84 95 00 00 00    	je     22b6a3 <Allocator_alignedRealloc.186+0x1e3>
  22b60e:	66 89 03             	mov    WORD PTR [rbx],ax
  22b611:	48 8b 84 24 80 00 00 	mov    rax,QWORD PTR [rsp+0x80]
  22b618:	00 
  22b619:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  22b61d:	c5 f8 10 44 24 72    	vmovups xmm0,XMMWORD PTR [rsp+0x72]
  22b623:	c5 f8 11 43 02       	vmovups XMMWORD PTR [rbx+0x2],xmm0
  22b628:	48 81 c4 88 00 00 00 	add    rsp,0x88
  22b62f:	5b                   	pop    rbx
  22b630:	41 5e                	pop    r14
  22b632:	c3                   	ret    
  22b633:	48 89 e0             	mov    rax,rsp
            return ([*]align(alignment) T)(undefined)[0..0];
  22b636:	0f b7 0d a9 ce fd ff 	movzx  ecx,WORD PTR [rip+0xfffffffffffdcea9]        # 2084e6 <__unnamed_103+0x6>
  22b63d:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  22b642:	8b 0d 9a ce fd ff    	mov    ecx,DWORD PTR [rip+0xfffffffffffdce9a]        # 2084e2 <__unnamed_103+0x2>
  22b648:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  22b64b:	31 c9                	xor    ecx,ecx
  22b64d:	45 31 f6             	xor    r14d,r14d
  22b650:	e9 9f 00 00 00       	jmp    22b6f4 <Allocator_alignedRealloc.186+0x234>
  22b655:	48 8d 4c 24 48       	lea    rcx,[rsp+0x48]
  22b65a:	66 c7 44 24 48 00 00 	mov    WORD PTR [rsp+0x48],0x0
  22b661:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  22b666:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  22b66a:	0f 85 ef fe ff ff    	jne    22b55f <Allocator_alignedRealloc.186+0x9f>
  22b670:	4c 8b 71 08          	mov    r14,QWORD PTR [rcx+0x8]
  22b674:	48 8d 7c 24 08       	lea    rdi,[rsp+0x8]
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  22b679:	b9 08 00 00 00       	mov    ecx,0x8
  22b67e:	4c 89 f2             	mov    rdx,r14
  22b681:	ff 16                	call   QWORD PTR [rsi]
  22b683:	0f b7 4c 24 08       	movzx  ecx,WORD PTR [rsp+0x8]
  22b688:	66 85 c9             	test   cx,cx
  22b68b:	74 41                	je     22b6ce <Allocator_alignedRealloc.186+0x20e>
  22b68d:	0f b7 44 24 36       	movzx  eax,WORD PTR [rsp+0x36]
  22b692:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  22b697:	48 89 e0             	mov    rax,rsp
  22b69a:	8b 54 24 32          	mov    edx,DWORD PTR [rsp+0x32]
  22b69e:	89 14 24             	mov    DWORD PTR [rsp],edx
  22b6a1:	eb 51                	jmp    22b6f4 <Allocator_alignedRealloc.186+0x234>
        assert(byte_slice.len == byte_count);
  22b6a3:	4c 39 74 24 68       	cmp    QWORD PTR [rsp+0x68],r14
    if (!ok) {
  22b6a8:	75 6d                	jne    22b717 <Allocator_alignedRealloc.186+0x257>
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  22b6aa:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  22b6af:	66 c7 03 00 00       	mov    WORD PTR [rbx],0x0
  22b6b4:	0f b7 4c 24 2a       	movzx  ecx,WORD PTR [rsp+0x2a]
  22b6b9:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  22b6bd:	49 c1 ee 04          	shr    r14,0x4
  22b6c1:	8b 4c 24 26          	mov    ecx,DWORD PTR [rsp+0x26]
  22b6c5:	89 4b 02             	mov    DWORD PTR [rbx+0x2],ecx
  22b6c8:	48 89 43 08          	mov    QWORD PTR [rbx+0x8],rax
  22b6cc:	eb 3a                	jmp    22b708 <Allocator_alignedRealloc.186+0x248>
        assert(byte_slice.len == byte_count);
  22b6ce:	4c 39 74 24 18       	cmp    QWORD PTR [rsp+0x18],r14
  22b6d3:	75 42                	jne    22b717 <Allocator_alignedRealloc.186+0x257>
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  22b6d5:	48 8b 54 24 10       	mov    rdx,QWORD PTR [rsp+0x10]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  22b6da:	49 c1 ee 04          	shr    r14,0x4
  22b6de:	48 89 e0             	mov    rax,rsp
  22b6e1:	8b 4c 24 2c          	mov    ecx,DWORD PTR [rsp+0x2c]
  22b6e5:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  22b6e8:	0f b7 4c 24 30       	movzx  ecx,WORD PTR [rsp+0x30]
  22b6ed:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  22b6f2:	31 c9                	xor    ecx,ecx
            return self.alignedAlloc(T, alignment, n);
  22b6f4:	66 89 0b             	mov    WORD PTR [rbx],cx
  22b6f7:	0f b7 48 04          	movzx  ecx,WORD PTR [rax+0x4]
  22b6fb:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  22b6ff:	8b 00                	mov    eax,DWORD PTR [rax]
  22b701:	89 43 02             	mov    DWORD PTR [rbx+0x2],eax
  22b704:	48 89 53 08          	mov    QWORD PTR [rbx+0x8],rdx
  22b708:	4c 89 73 10          	mov    QWORD PTR [rbx+0x10],r14
  22b70c:	48 81 c4 88 00 00 00 	add    rsp,0x88
  22b713:	5b                   	pop    rbx
  22b714:	41 5e                	pop    r14
  22b716:	c3                   	ret    
            @panic("assertion failure");
  22b717:	48 8d 3d 72 46 02 00 	lea    rdi,[rip+0x24672]        # 24fd90 <__unnamed_2>
  22b71e:	e8 fd 6f fe ff       	call   212720 <panic>
  22b723:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  22b72a:	84 00 00 00 00 00 

000000000022b730 <Allocator_alignedRealloc.189>:
    pub fn alignedRealloc(self: *Allocator, comptime T: type, comptime alignment: u29, old_mem: []align(alignment) T, n: usize) ![]align(alignment) T {
  22b730:	41 56                	push   r14
  22b732:	53                   	push   rbx
  22b733:	48 81 ec 88 00 00 00 	sub    rsp,0x88
  22b73a:	48 89 fb             	mov    rbx,rdi
        if (old_mem.len == 0) {
  22b73d:	48 8b 42 08          	mov    rax,QWORD PTR [rdx+0x8]
  22b741:	48 85 c0             	test   rax,rax
  22b744:	74 62                	je     22b7a8 <Allocator_alignedRealloc.189+0x78>
        if (n == 0) {
  22b746:	48 85 c9             	test   rcx,rcx
  22b749:	0f 84 a9 00 00 00    	je     22b7f8 <Allocator_alignedRealloc.189+0xc8>
        const old_byte_slice = @sliceToBytes(old_mem);
  22b74f:	48 8b 12             	mov    rdx,QWORD PTR [rdx]
  22b752:	48 c1 e0 03          	shl    rax,0x3
  22b756:	48 8d 04 80          	lea    rax,[rax+rax*4]
  22b75a:	48 89 54 24 38       	mov    QWORD PTR [rsp+0x38],rdx
  22b75f:	48 89 44 24 40       	mov    QWORD PTR [rsp+0x40],rax
  22b764:	ba 28 00 00 00       	mov    edx,0x28
  22b769:	48 89 c8             	mov    rax,rcx
  22b76c:	48 f7 e2             	mul    rdx
  22b76f:	0f 81 d0 00 00 00    	jno    22b845 <Allocator_alignedRealloc.189+0x115>
  22b775:	48 8d 0d 44 4d fd ff 	lea    rcx,[rip+0xfffffffffffd4d44]        # 2004c0 <__unnamed_27>
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  22b77c:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  22b780:	0f 84 da 00 00 00    	je     22b860 <Allocator_alignedRealloc.189+0x130>
  22b786:	48 8b 05 ab cd fd ff 	mov    rax,QWORD PTR [rip+0xfffffffffffdcdab]        # 208538 <__unnamed_104+0x10>
  22b78d:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  22b791:	c5 f8 10 05 8f cd fd 	vmovups xmm0,XMMWORD PTR [rip+0xfffffffffffdcd8f]        # 208528 <__unnamed_104>
  22b798:	ff 
  22b799:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  22b79d:	48 81 c4 88 00 00 00 	add    rsp,0x88
  22b7a4:	5b                   	pop    rbx
  22b7a5:	41 5e                	pop    r14
  22b7a7:	c3                   	ret    
        if (n == 0) {
  22b7a8:	48 85 c9             	test   rcx,rcx
  22b7ab:	0f 84 fc 00 00 00    	je     22b8ad <Allocator_alignedRealloc.189+0x17d>
  22b7b1:	ba 28 00 00 00       	mov    edx,0x28
  22b7b6:	48 89 c8             	mov    rax,rcx
  22b7b9:	48 f7 e2             	mul    rdx
  22b7bc:	0f 81 0c 01 00 00    	jno    22b8ce <Allocator_alignedRealloc.189+0x19e>
  22b7c2:	48 8d 0d f7 4c fd ff 	lea    rcx,[rip+0xfffffffffffd4cf7]        # 2004c0 <__unnamed_27>
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  22b7c9:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  22b7cd:	0f 84 16 01 00 00    	je     22b8e9 <Allocator_alignedRealloc.189+0x1b9>
  22b7d3:	0f b7 05 54 cd fd ff 	movzx  eax,WORD PTR [rip+0xfffffffffffdcd54]        # 20852e <__unnamed_104+0x6>
  22b7da:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  22b7df:	8b 05 45 cd fd ff    	mov    eax,DWORD PTR [rip+0xfffffffffffdcd45]        # 20852a <__unnamed_104+0x2>
  22b7e5:	89 04 24             	mov    DWORD PTR [rsp],eax
  22b7e8:	48 89 e0             	mov    rax,rsp
  22b7eb:	66 b9 01 00          	mov    cx,0x1
  22b7ef:	31 f6                	xor    esi,esi
  22b7f1:	31 d2                	xor    edx,edx
  22b7f3:	e9 9d 01 00 00       	jmp    22b995 <Allocator_alignedRealloc.189+0x265>
        const bytes = @sliceToBytes(memory);
  22b7f8:	48 c1 e0 03          	shl    rax,0x3
  22b7fc:	48 8d 04 80          	lea    rax,[rax+rax*4]
        if (bytes.len == 0) return;
  22b800:	48 85 c0             	test   rax,rax
  22b803:	74 1e                	je     22b823 <Allocator_alignedRealloc.189+0xf3>
        const bytes = @sliceToBytes(memory);
  22b805:	48 8b 0a             	mov    rcx,QWORD PTR [rdx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  22b808:	48 8b 56 10          	mov    rdx,QWORD PTR [rsi+0x10]
  22b80c:	48 89 4c 24 08       	mov    QWORD PTR [rsp+0x8],rcx
  22b811:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  22b816:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  22b81b:	48 89 f7             	mov    rdi,rsi
  22b81e:	48 89 c6             	mov    rsi,rax
  22b821:	ff d2                	call   rdx
            return ([*]align(alignment) T)(undefined)[0..0];
  22b823:	48 8b 05 f6 cc fd ff 	mov    rax,QWORD PTR [rip+0xfffffffffffdccf6]        # 208520 <__unnamed_105+0x10>
  22b82a:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  22b82e:	c5 f8 10 05 da cc fd 	vmovups xmm0,XMMWORD PTR [rip+0xfffffffffffdccda]        # 208510 <__unnamed_105>
  22b835:	ff 
  22b836:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  22b83a:	48 81 c4 88 00 00 00 	add    rsp,0x88
  22b841:	5b                   	pop    rbx
  22b842:	41 5e                	pop    r14
  22b844:	c3                   	ret    
  22b845:	48 8d 4c 24 08       	lea    rcx,[rsp+0x8]
  22b84a:	66 c7 44 24 08 00 00 	mov    WORD PTR [rsp+0x8],0x0
  22b851:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  22b856:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  22b85a:	0f 85 26 ff ff ff    	jne    22b786 <Allocator_alignedRealloc.189+0x56>
  22b860:	4c 8b 71 08          	mov    r14,QWORD PTR [rcx+0x8]
  22b864:	48 8d 7c 24 58       	lea    rdi,[rsp+0x58]
  22b869:	48 8d 54 24 38       	lea    rdx,[rsp+0x38]
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  22b86e:	41 b8 08 00 00 00    	mov    r8d,0x8
  22b874:	4c 89 f1             	mov    rcx,r14
  22b877:	ff 56 08             	call   QWORD PTR [rsi+0x8]
  22b87a:	0f b7 44 24 58       	movzx  eax,WORD PTR [rsp+0x58]
  22b87f:	66 85 c0             	test   ax,ax
  22b882:	0f 84 94 00 00 00    	je     22b91c <Allocator_alignedRealloc.189+0x1ec>
  22b888:	66 89 03             	mov    WORD PTR [rbx],ax
  22b88b:	48 8b 84 24 80 00 00 	mov    rax,QWORD PTR [rsp+0x80]
  22b892:	00 
  22b893:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  22b897:	c5 f8 10 44 24 72    	vmovups xmm0,XMMWORD PTR [rsp+0x72]
  22b89d:	c5 f8 11 43 02       	vmovups XMMWORD PTR [rbx+0x2],xmm0
  22b8a2:	48 81 c4 88 00 00 00 	add    rsp,0x88
  22b8a9:	5b                   	pop    rbx
  22b8aa:	41 5e                	pop    r14
  22b8ac:	c3                   	ret    
  22b8ad:	48 89 e0             	mov    rax,rsp
            return ([*]align(alignment) T)(undefined)[0..0];
  22b8b0:	0f b7 0d 5f cc fd ff 	movzx  ecx,WORD PTR [rip+0xfffffffffffdcc5f]        # 208516 <__unnamed_105+0x6>
  22b8b7:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  22b8bc:	8b 0d 50 cc fd ff    	mov    ecx,DWORD PTR [rip+0xfffffffffffdcc50]        # 208512 <__unnamed_105+0x2>
  22b8c2:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  22b8c5:	31 c9                	xor    ecx,ecx
  22b8c7:	31 d2                	xor    edx,edx
  22b8c9:	e9 c7 00 00 00       	jmp    22b995 <Allocator_alignedRealloc.189+0x265>
  22b8ce:	48 8d 4c 24 48       	lea    rcx,[rsp+0x48]
  22b8d3:	66 c7 44 24 48 00 00 	mov    WORD PTR [rsp+0x48],0x0
  22b8da:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  22b8df:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  22b8e3:	0f 85 ea fe ff ff    	jne    22b7d3 <Allocator_alignedRealloc.189+0xa3>
  22b8e9:	4c 8b 71 08          	mov    r14,QWORD PTR [rcx+0x8]
  22b8ed:	48 8d 7c 24 08       	lea    rdi,[rsp+0x8]
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  22b8f2:	b9 08 00 00 00       	mov    ecx,0x8
  22b8f7:	4c 89 f2             	mov    rdx,r14
  22b8fa:	ff 16                	call   QWORD PTR [rsi]
  22b8fc:	0f b7 4c 24 08       	movzx  ecx,WORD PTR [rsp+0x8]
  22b901:	66 85 c9             	test   cx,cx
  22b904:	74 57                	je     22b95d <Allocator_alignedRealloc.189+0x22d>
  22b906:	0f b7 44 24 36       	movzx  eax,WORD PTR [rsp+0x36]
  22b90b:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  22b910:	48 89 e0             	mov    rax,rsp
  22b913:	8b 54 24 32          	mov    edx,DWORD PTR [rsp+0x32]
  22b917:	89 14 24             	mov    DWORD PTR [rsp],edx
  22b91a:	eb 79                	jmp    22b995 <Allocator_alignedRealloc.189+0x265>
        assert(byte_slice.len == byte_count);
  22b91c:	4c 39 74 24 68       	cmp    QWORD PTR [rsp+0x68],r14
    if (!ok) {
  22b921:	0f 85 91 00 00 00    	jne    22b9b8 <Allocator_alignedRealloc.189+0x288>
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  22b927:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  22b92c:	48 b9 cd cc cc cc cc 	movabs rcx,0xcccccccccccccccd
  22b933:	cc cc cc 
  22b936:	4c 89 f2             	mov    rdx,r14
  22b939:	c4 e2 f3 f6 d1       	mulx   rdx,rcx,rcx
  22b93e:	66 c7 03 00 00       	mov    WORD PTR [rbx],0x0
  22b943:	0f b7 4c 24 2a       	movzx  ecx,WORD PTR [rsp+0x2a]
  22b948:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  22b94c:	48 c1 ea 05          	shr    rdx,0x5
  22b950:	8b 4c 24 26          	mov    ecx,DWORD PTR [rsp+0x26]
  22b954:	89 4b 02             	mov    DWORD PTR [rbx+0x2],ecx
  22b957:	48 89 43 08          	mov    QWORD PTR [rbx+0x8],rax
  22b95b:	eb 4c                	jmp    22b9a9 <Allocator_alignedRealloc.189+0x279>
        assert(byte_slice.len == byte_count);
  22b95d:	4c 39 74 24 18       	cmp    QWORD PTR [rsp+0x18],r14
  22b962:	75 54                	jne    22b9b8 <Allocator_alignedRealloc.189+0x288>
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  22b964:	48 8b 74 24 10       	mov    rsi,QWORD PTR [rsp+0x10]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  22b969:	48 b8 cd cc cc cc cc 	movabs rax,0xcccccccccccccccd
  22b970:	cc cc cc 
  22b973:	4c 89 f2             	mov    rdx,r14
  22b976:	c4 e2 fb f6 d0       	mulx   rdx,rax,rax
  22b97b:	48 c1 ea 05          	shr    rdx,0x5
  22b97f:	48 89 e0             	mov    rax,rsp
  22b982:	8b 4c 24 2c          	mov    ecx,DWORD PTR [rsp+0x2c]
  22b986:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  22b989:	0f b7 4c 24 30       	movzx  ecx,WORD PTR [rsp+0x30]
  22b98e:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  22b993:	31 c9                	xor    ecx,ecx
            return self.alignedAlloc(T, alignment, n);
  22b995:	66 89 0b             	mov    WORD PTR [rbx],cx
  22b998:	0f b7 48 04          	movzx  ecx,WORD PTR [rax+0x4]
  22b99c:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  22b9a0:	8b 00                	mov    eax,DWORD PTR [rax]
  22b9a2:	89 43 02             	mov    DWORD PTR [rbx+0x2],eax
  22b9a5:	48 89 73 08          	mov    QWORD PTR [rbx+0x8],rsi
  22b9a9:	48 89 53 10          	mov    QWORD PTR [rbx+0x10],rdx
  22b9ad:	48 81 c4 88 00 00 00 	add    rsp,0x88
  22b9b4:	5b                   	pop    rbx
  22b9b5:	41 5e                	pop    r14
  22b9b7:	c3                   	ret    
            @panic("assertion failure");
  22b9b8:	48 8d 3d d1 43 02 00 	lea    rdi,[rip+0x243d1]        # 24fd90 <__unnamed_2>
  22b9bf:	e8 5c 6d fe ff       	call   212720 <panic>
  22b9c4:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  22b9cb:	00 00 00 00 00 

000000000022b9d0 <join.192>:
pub fn join(allocator: *Allocator, sep: u8, strings: ...) ![]u8 {
  22b9d0:	55                   	push   rbp
  22b9d1:	41 57                	push   r15
  22b9d3:	41 56                	push   r14
  22b9d5:	41 55                	push   r13
  22b9d7:	41 54                	push   r12
  22b9d9:	53                   	push   rbx
  22b9da:	48 83 ec 58          	sub    rsp,0x58
  22b9de:	49 89 cc             	mov    r12,rcx
  22b9e1:	48 89 d3             	mov    rbx,rdx
  22b9e4:	49 89 f2             	mov    r10,rsi
  22b9e7:	49 89 ff             	mov    r15,rdi
            const arg = ([]const u8)(strings[string_i]);
  22b9ea:	4c 8b 43 08          	mov    r8,QWORD PTR [rbx+0x8]
  22b9ee:	4d 8b 6c 24 08       	mov    r13,QWORD PTR [r12+0x8]
            total_strings_len += arg.len;
  22b9f3:	4d 01 c5             	add    r13,r8
        if (n == 0) {
  22b9f6:	49 83 c5 02          	add    r13,0x2
  22b9fa:	74 42                	je     22ba3e <join.192+0x6e>
  22b9fc:	48 8d 7c 24 08       	lea    rdi,[rsp+0x8]
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  22ba01:	b9 01 00 00 00       	mov    ecx,0x1
  22ba06:	4c 89 d6             	mov    rsi,r10
  22ba09:	4c 89 ea             	mov    rdx,r13
  22ba0c:	4c 89 d5             	mov    rbp,r10
  22ba0f:	ff 55 00             	call   QWORD PTR [rbp+0x0]
  22ba12:	0f b7 44 24 08       	movzx  eax,WORD PTR [rsp+0x8]
  22ba17:	66 85 c0             	test   ax,ax
  22ba1a:	0f 84 e5 00 00 00    	je     22bb05 <join.192+0x135>
    const buf = try allocator.alloc(u8, total_strings_len);
  22ba20:	66 41 89 07          	mov    WORD PTR [r15],ax
  22ba24:	48 8b 44 24 50       	mov    rax,QWORD PTR [rsp+0x50]
  22ba29:	49 89 47 10          	mov    QWORD PTR [r15+0x10],rax
  22ba2d:	c5 f8 10 44 24 42    	vmovups xmm0,XMMWORD PTR [rsp+0x42]
  22ba33:	c4 c1 78 11 47 02    	vmovups XMMWORD PTR [r15+0x2],xmm0
  22ba39:	e9 df 05 00 00       	jmp    22c01d <join.192+0x64d>
  22ba3e:	45 31 ed             	xor    r13d,r13d
    assert(dest.len >= source.len);
  22ba41:	4d 39 c5             	cmp    r13,r8
    if (!ok) {
  22ba44:	0f 82 e5 05 00 00    	jb     22c02f <join.192+0x65f>
    for (source) |s, i|
  22ba4a:	4d 85 c0             	test   r8,r8
  22ba4d:	0f 84 8f 02 00 00    	je     22bce2 <join.192+0x312>
  22ba53:	48 8b 0b             	mov    rcx,QWORD PTR [rbx]
  22ba56:	49 81 f8 80 00 00 00 	cmp    r8,0x80
  22ba5d:	72 1a                	jb     22ba79 <join.192+0xa9>
  22ba5f:	4a 8d 04 01          	lea    rax,[rcx+r8*1]
  22ba63:	48 39 e8             	cmp    rax,rbp
  22ba66:	0f 86 be 00 00 00    	jbe    22bb2a <join.192+0x15a>
  22ba6c:	49 8d 04 28          	lea    rax,[r8+rbp*1]
  22ba70:	48 39 c1             	cmp    rcx,rax
  22ba73:	0f 83 b1 00 00 00    	jae    22bb2a <join.192+0x15a>
  22ba79:	31 d2                	xor    edx,edx
  22ba7b:	49 8d 40 ff          	lea    rax,[r8-0x1]
  22ba7f:	48 29 d0             	sub    rax,rdx
  22ba82:	4c 89 c6             	mov    rsi,r8
  22ba85:	48 83 e6 07          	and    rsi,0x7
  22ba89:	74 17                	je     22baa2 <join.192+0xd2>
  22ba8b:	48 f7 de             	neg    rsi
  22ba8e:	66 90                	xchg   ax,ax
  22ba90:	0f b6 1c 11          	movzx  ebx,BYTE PTR [rcx+rdx*1]
        dest[i] = s;
  22ba94:	88 5c 15 00          	mov    BYTE PTR [rbp+rdx*1+0x0],bl
    for (source) |s, i|
  22ba98:	48 83 c2 01          	add    rdx,0x1
  22ba9c:	48 83 c6 01          	add    rsi,0x1
  22baa0:	75 ee                	jne    22ba90 <join.192+0xc0>
  22baa2:	48 83 f8 07          	cmp    rax,0x7
  22baa6:	0f 82 36 02 00 00    	jb     22bce2 <join.192+0x312>
  22baac:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  22bab0:	0f b6 04 11          	movzx  eax,BYTE PTR [rcx+rdx*1]
        dest[i] = s;
  22bab4:	88 44 15 00          	mov    BYTE PTR [rbp+rdx*1+0x0],al
    for (source) |s, i|
  22bab8:	0f b6 44 11 01       	movzx  eax,BYTE PTR [rcx+rdx*1+0x1]
        dest[i] = s;
  22babd:	88 44 15 01          	mov    BYTE PTR [rbp+rdx*1+0x1],al
    for (source) |s, i|
  22bac1:	0f b6 44 11 02       	movzx  eax,BYTE PTR [rcx+rdx*1+0x2]
        dest[i] = s;
  22bac6:	88 44 15 02          	mov    BYTE PTR [rbp+rdx*1+0x2],al
    for (source) |s, i|
  22baca:	0f b6 44 11 03       	movzx  eax,BYTE PTR [rcx+rdx*1+0x3]
        dest[i] = s;
  22bacf:	88 44 15 03          	mov    BYTE PTR [rbp+rdx*1+0x3],al
    for (source) |s, i|
  22bad3:	0f b6 44 11 04       	movzx  eax,BYTE PTR [rcx+rdx*1+0x4]
        dest[i] = s;
  22bad8:	88 44 15 04          	mov    BYTE PTR [rbp+rdx*1+0x4],al
    for (source) |s, i|
  22badc:	0f b6 44 11 05       	movzx  eax,BYTE PTR [rcx+rdx*1+0x5]
        dest[i] = s;
  22bae1:	88 44 15 05          	mov    BYTE PTR [rbp+rdx*1+0x5],al
    for (source) |s, i|
  22bae5:	0f b6 44 11 06       	movzx  eax,BYTE PTR [rcx+rdx*1+0x6]
        dest[i] = s;
  22baea:	88 44 15 06          	mov    BYTE PTR [rbp+rdx*1+0x6],al
    for (source) |s, i|
  22baee:	0f b6 44 11 07       	movzx  eax,BYTE PTR [rcx+rdx*1+0x7]
        dest[i] = s;
  22baf3:	88 44 15 07          	mov    BYTE PTR [rbp+rdx*1+0x7],al
    for (source) |s, i|
  22baf7:	48 83 c2 08          	add    rdx,0x8
  22bafb:	49 39 d0             	cmp    r8,rdx
  22bafe:	75 b0                	jne    22bab0 <join.192+0xe0>
  22bb00:	e9 dd 01 00 00       	jmp    22bce2 <join.192+0x312>
  22bb05:	49 89 ea             	mov    r10,rbp
        assert(byte_slice.len == byte_count);
  22bb08:	4c 39 6c 24 18       	cmp    QWORD PTR [rsp+0x18],r13
  22bb0d:	0f 85 1c 05 00 00    	jne    22c02f <join.192+0x65f>
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  22bb13:	48 8b 6c 24 10       	mov    rbp,QWORD PTR [rsp+0x10]
        const arg = ([]const u8)(strings[string_i]);
  22bb18:	4c 8b 43 08          	mov    r8,QWORD PTR [rbx+0x8]
    assert(dest.len >= source.len);
  22bb1c:	4d 39 c5             	cmp    r13,r8
  22bb1f:	0f 83 25 ff ff ff    	jae    22ba4a <join.192+0x7a>
  22bb25:	e9 05 05 00 00       	jmp    22c02f <join.192+0x65f>
    for (source) |s, i|
  22bb2a:	4c 89 c2             	mov    rdx,r8
  22bb2d:	48 83 e2 80          	and    rdx,0xffffffffffffff80
  22bb31:	48 8d 42 80          	lea    rax,[rdx-0x80]
  22bb35:	48 89 c7             	mov    rdi,rax
  22bb38:	48 c1 ef 07          	shr    rdi,0x7
  22bb3c:	8d 77 01             	lea    esi,[rdi+0x1]
  22bb3f:	83 e6 03             	and    esi,0x3
  22bb42:	48 3d 80 01 00 00    	cmp    rax,0x180
  22bb48:	73 10                	jae    22bb5a <join.192+0x18a>
  22bb4a:	31 ff                	xor    edi,edi
  22bb4c:	48 85 f6             	test   rsi,rsi
  22bb4f:	0f 85 38 01 00 00    	jne    22bc8d <join.192+0x2bd>
  22bb55:	e9 7f 01 00 00       	jmp    22bcd9 <join.192+0x309>
  22bb5a:	48 8d 46 ff          	lea    rax,[rsi-0x1]
  22bb5e:	48 29 f8             	sub    rax,rdi
  22bb61:	31 ff                	xor    edi,edi
  22bb63:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  22bb6a:	84 00 00 00 00 00 
  22bb70:	c5 fc 10 04 39       	vmovups ymm0,YMMWORD PTR [rcx+rdi*1]
  22bb75:	c5 fc 10 4c 39 20    	vmovups ymm1,YMMWORD PTR [rcx+rdi*1+0x20]
  22bb7b:	c5 fc 10 54 39 40    	vmovups ymm2,YMMWORD PTR [rcx+rdi*1+0x40]
  22bb81:	c5 fc 10 5c 39 60    	vmovups ymm3,YMMWORD PTR [rcx+rdi*1+0x60]
        dest[i] = s;
  22bb87:	c5 fc 11 44 3d 00    	vmovups YMMWORD PTR [rbp+rdi*1+0x0],ymm0
  22bb8d:	c5 fc 11 4c 3d 20    	vmovups YMMWORD PTR [rbp+rdi*1+0x20],ymm1
  22bb93:	c5 fc 11 54 3d 40    	vmovups YMMWORD PTR [rbp+rdi*1+0x40],ymm2
  22bb99:	c5 fc 11 5c 3d 60    	vmovups YMMWORD PTR [rbp+rdi*1+0x60],ymm3
    for (source) |s, i|
  22bb9f:	c5 fc 10 84 39 80 00 	vmovups ymm0,YMMWORD PTR [rcx+rdi*1+0x80]
  22bba6:	00 00 
  22bba8:	c5 fc 10 8c 39 a0 00 	vmovups ymm1,YMMWORD PTR [rcx+rdi*1+0xa0]
  22bbaf:	00 00 
  22bbb1:	c5 fc 10 94 39 c0 00 	vmovups ymm2,YMMWORD PTR [rcx+rdi*1+0xc0]
  22bbb8:	00 00 
  22bbba:	c5 fc 10 9c 39 e0 00 	vmovups ymm3,YMMWORD PTR [rcx+rdi*1+0xe0]
  22bbc1:	00 00 
        dest[i] = s;
  22bbc3:	c5 fc 11 84 3d 80 00 	vmovups YMMWORD PTR [rbp+rdi*1+0x80],ymm0
  22bbca:	00 00 
  22bbcc:	c5 fc 11 8c 3d a0 00 	vmovups YMMWORD PTR [rbp+rdi*1+0xa0],ymm1
  22bbd3:	00 00 
  22bbd5:	c5 fc 11 94 3d c0 00 	vmovups YMMWORD PTR [rbp+rdi*1+0xc0],ymm2
  22bbdc:	00 00 
  22bbde:	c5 fc 11 9c 3d e0 00 	vmovups YMMWORD PTR [rbp+rdi*1+0xe0],ymm3
  22bbe5:	00 00 
    for (source) |s, i|
  22bbe7:	c5 fc 10 84 39 00 01 	vmovups ymm0,YMMWORD PTR [rcx+rdi*1+0x100]
  22bbee:	00 00 
  22bbf0:	c5 fc 10 8c 39 20 01 	vmovups ymm1,YMMWORD PTR [rcx+rdi*1+0x120]
  22bbf7:	00 00 
  22bbf9:	c5 fc 10 94 39 40 01 	vmovups ymm2,YMMWORD PTR [rcx+rdi*1+0x140]
  22bc00:	00 00 
  22bc02:	c5 fc 10 9c 39 60 01 	vmovups ymm3,YMMWORD PTR [rcx+rdi*1+0x160]
  22bc09:	00 00 
        dest[i] = s;
  22bc0b:	c5 fc 11 84 3d 00 01 	vmovups YMMWORD PTR [rbp+rdi*1+0x100],ymm0
  22bc12:	00 00 
  22bc14:	c5 fc 11 8c 3d 20 01 	vmovups YMMWORD PTR [rbp+rdi*1+0x120],ymm1
  22bc1b:	00 00 
  22bc1d:	c5 fc 11 94 3d 40 01 	vmovups YMMWORD PTR [rbp+rdi*1+0x140],ymm2
  22bc24:	00 00 
  22bc26:	c5 fc 11 9c 3d 60 01 	vmovups YMMWORD PTR [rbp+rdi*1+0x160],ymm3
  22bc2d:	00 00 
    for (source) |s, i|
  22bc2f:	c5 fc 10 84 39 80 01 	vmovups ymm0,YMMWORD PTR [rcx+rdi*1+0x180]
  22bc36:	00 00 
  22bc38:	c5 fc 10 8c 39 a0 01 	vmovups ymm1,YMMWORD PTR [rcx+rdi*1+0x1a0]
  22bc3f:	00 00 
  22bc41:	c5 fc 10 94 39 c0 01 	vmovups ymm2,YMMWORD PTR [rcx+rdi*1+0x1c0]
  22bc48:	00 00 
  22bc4a:	c5 fc 10 9c 39 e0 01 	vmovups ymm3,YMMWORD PTR [rcx+rdi*1+0x1e0]
  22bc51:	00 00 
        dest[i] = s;
  22bc53:	c5 fc 11 84 3d 80 01 	vmovups YMMWORD PTR [rbp+rdi*1+0x180],ymm0
  22bc5a:	00 00 
  22bc5c:	c5 fc 11 8c 3d a0 01 	vmovups YMMWORD PTR [rbp+rdi*1+0x1a0],ymm1
  22bc63:	00 00 
  22bc65:	c5 fc 11 94 3d c0 01 	vmovups YMMWORD PTR [rbp+rdi*1+0x1c0],ymm2
  22bc6c:	00 00 
  22bc6e:	c5 fc 11 9c 3d e0 01 	vmovups YMMWORD PTR [rbp+rdi*1+0x1e0],ymm3
  22bc75:	00 00 
    for (source) |s, i|
  22bc77:	48 81 c7 00 02 00 00 	add    rdi,0x200
  22bc7e:	48 83 c0 04          	add    rax,0x4
  22bc82:	0f 85 e8 fe ff ff    	jne    22bb70 <join.192+0x1a0>
  22bc88:	48 85 f6             	test   rsi,rsi
  22bc8b:	74 4c                	je     22bcd9 <join.192+0x309>
  22bc8d:	48 83 c7 60          	add    rdi,0x60
  22bc91:	48 f7 de             	neg    rsi
  22bc94:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  22bc9b:	00 00 00 00 00 
  22bca0:	c5 fc 10 44 39 a0    	vmovups ymm0,YMMWORD PTR [rcx+rdi*1-0x60]
  22bca6:	c5 fc 10 4c 39 c0    	vmovups ymm1,YMMWORD PTR [rcx+rdi*1-0x40]
  22bcac:	c5 fc 10 54 39 e0    	vmovups ymm2,YMMWORD PTR [rcx+rdi*1-0x20]
  22bcb2:	c5 fc 10 1c 39       	vmovups ymm3,YMMWORD PTR [rcx+rdi*1]
        dest[i] = s;
  22bcb7:	c5 fc 11 44 3d a0    	vmovups YMMWORD PTR [rbp+rdi*1-0x60],ymm0
  22bcbd:	c5 fc 11 4c 3d c0    	vmovups YMMWORD PTR [rbp+rdi*1-0x40],ymm1
  22bcc3:	c5 fc 11 54 3d e0    	vmovups YMMWORD PTR [rbp+rdi*1-0x20],ymm2
  22bcc9:	c5 fc 11 5c 3d 00    	vmovups YMMWORD PTR [rbp+rdi*1+0x0],ymm3
    for (source) |s, i|
  22bccf:	48 83 ef 80          	sub    rdi,0xffffffffffffff80
  22bcd3:	48 83 c6 01          	add    rsi,0x1
  22bcd7:	75 c7                	jne    22bca0 <join.192+0x2d0>
  22bcd9:	49 39 d0             	cmp    r8,rdx
  22bcdc:	0f 85 99 fd ff ff    	jne    22ba7b <join.192+0xab>
        if (buf[buf_index - 1] != sep) {
  22bce2:	42 80 7c 05 ff 2f    	cmp    BYTE PTR [rbp+r8*1-0x1],0x2f
  22bce8:	74 0a                	je     22bcf4 <join.192+0x324>
            buf[buf_index] = sep;
  22bcea:	42 c6 44 05 00 2f    	mov    BYTE PTR [rbp+r8*1+0x0],0x2f
            buf_index += 1;
  22bcf0:	49 83 c0 01          	add    r8,0x1
        const arg = ([]const u8)(strings[string_i]);
  22bcf4:	4d 8b 74 24 08       	mov    r14,QWORD PTR [r12+0x8]
        copy(u8, buf[buf_index..], arg);
  22bcf9:	4c 89 e8             	mov    rax,r13
  22bcfc:	4c 29 c0             	sub    rax,r8
    assert(dest.len >= source.len);
  22bcff:	4c 39 f0             	cmp    rax,r14
  22bd02:	0f 82 27 03 00 00    	jb     22c02f <join.192+0x65f>
    for (source) |s, i|
  22bd08:	4d 85 f6             	test   r14,r14
  22bd0b:	0f 84 84 02 00 00    	je     22bf95 <join.192+0x5c5>
  22bd11:	49 8b 0c 24          	mov    rcx,QWORD PTR [r12]
  22bd15:	4d 8d 0c 28          	lea    r9,[r8+rbp*1]
  22bd19:	49 81 fe 80 00 00 00 	cmp    r14,0x80
  22bd20:	72 1d                	jb     22bd3f <join.192+0x36f>
  22bd22:	4a 8d 04 31          	lea    rax,[rcx+r14*1]
  22bd26:	49 39 c1             	cmp    r9,rax
  22bd29:	0f 83 b5 00 00 00    	jae    22bde4 <join.192+0x414>
  22bd2f:	4b 8d 04 30          	lea    rax,[r8+r14*1]
  22bd33:	48 01 e8             	add    rax,rbp
  22bd36:	48 39 c1             	cmp    rcx,rax
  22bd39:	0f 83 a5 00 00 00    	jae    22bde4 <join.192+0x414>
  22bd3f:	31 d2                	xor    edx,edx
  22bd41:	49 8d 46 ff          	lea    rax,[r14-0x1]
  22bd45:	48 29 d0             	sub    rax,rdx
  22bd48:	4c 89 f6             	mov    rsi,r14
  22bd4b:	48 83 e6 07          	and    rsi,0x7
  22bd4f:	74 21                	je     22bd72 <join.192+0x3a2>
  22bd51:	48 f7 de             	neg    rsi
  22bd54:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  22bd5b:	00 00 00 00 00 
  22bd60:	0f b6 1c 11          	movzx  ebx,BYTE PTR [rcx+rdx*1]
        dest[i] = s;
  22bd64:	41 88 1c 11          	mov    BYTE PTR [r9+rdx*1],bl
    for (source) |s, i|
  22bd68:	48 83 c2 01          	add    rdx,0x1
  22bd6c:	48 83 c6 01          	add    rsi,0x1
  22bd70:	75 ee                	jne    22bd60 <join.192+0x390>
  22bd72:	48 83 f8 07          	cmp    rax,0x7
  22bd76:	0f 82 19 02 00 00    	jb     22bf95 <join.192+0x5c5>
  22bd7c:	49 8d 04 28          	lea    rax,[r8+rbp*1]
  22bd80:	48 83 c0 07          	add    rax,0x7
  22bd84:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  22bd8b:	00 00 00 00 00 
  22bd90:	0f b6 1c 11          	movzx  ebx,BYTE PTR [rcx+rdx*1]
        dest[i] = s;
  22bd94:	88 5c 10 f9          	mov    BYTE PTR [rax+rdx*1-0x7],bl
    for (source) |s, i|
  22bd98:	0f b6 5c 11 01       	movzx  ebx,BYTE PTR [rcx+rdx*1+0x1]
        dest[i] = s;
  22bd9d:	88 5c 10 fa          	mov    BYTE PTR [rax+rdx*1-0x6],bl
    for (source) |s, i|
  22bda1:	0f b6 5c 11 02       	movzx  ebx,BYTE PTR [rcx+rdx*1+0x2]
        dest[i] = s;
  22bda6:	88 5c 10 fb          	mov    BYTE PTR [rax+rdx*1-0x5],bl
    for (source) |s, i|
  22bdaa:	0f b6 5c 11 03       	movzx  ebx,BYTE PTR [rcx+rdx*1+0x3]
        dest[i] = s;
  22bdaf:	88 5c 10 fc          	mov    BYTE PTR [rax+rdx*1-0x4],bl
    for (source) |s, i|
  22bdb3:	0f b6 5c 11 04       	movzx  ebx,BYTE PTR [rcx+rdx*1+0x4]
        dest[i] = s;
  22bdb8:	88 5c 10 fd          	mov    BYTE PTR [rax+rdx*1-0x3],bl
    for (source) |s, i|
  22bdbc:	0f b6 5c 11 05       	movzx  ebx,BYTE PTR [rcx+rdx*1+0x5]
        dest[i] = s;
  22bdc1:	88 5c 10 fe          	mov    BYTE PTR [rax+rdx*1-0x2],bl
    for (source) |s, i|
  22bdc5:	0f b6 5c 11 06       	movzx  ebx,BYTE PTR [rcx+rdx*1+0x6]
        dest[i] = s;
  22bdca:	88 5c 10 ff          	mov    BYTE PTR [rax+rdx*1-0x1],bl
    for (source) |s, i|
  22bdce:	0f b6 5c 11 07       	movzx  ebx,BYTE PTR [rcx+rdx*1+0x7]
        dest[i] = s;
  22bdd3:	88 1c 10             	mov    BYTE PTR [rax+rdx*1],bl
    for (source) |s, i|
  22bdd6:	48 83 c2 08          	add    rdx,0x8
  22bdda:	49 39 d6             	cmp    r14,rdx
  22bddd:	75 b1                	jne    22bd90 <join.192+0x3c0>
  22bddf:	e9 b1 01 00 00       	jmp    22bf95 <join.192+0x5c5>
  22bde4:	4c 89 f2             	mov    rdx,r14
  22bde7:	48 83 e2 80          	and    rdx,0xffffffffffffff80
  22bdeb:	48 8d 72 80          	lea    rsi,[rdx-0x80]
  22bdef:	48 89 f0             	mov    rax,rsi
  22bdf2:	48 c1 e8 07          	shr    rax,0x7
  22bdf6:	8d 78 01             	lea    edi,[rax+0x1]
  22bdf9:	83 e7 03             	and    edi,0x3
  22bdfc:	48 81 fe 80 01 00 00 	cmp    rsi,0x180
  22be03:	73 10                	jae    22be15 <join.192+0x445>
  22be05:	31 c0                	xor    eax,eax
  22be07:	48 85 ff             	test   rdi,rdi
  22be0a:	0f 85 38 01 00 00    	jne    22bf48 <join.192+0x578>
  22be10:	e9 77 01 00 00       	jmp    22bf8c <join.192+0x5bc>
  22be15:	49 8d 1c 28          	lea    rbx,[r8+rbp*1]
  22be19:	48 81 c3 e0 01 00 00 	add    rbx,0x1e0
  22be20:	48 8d 77 ff          	lea    rsi,[rdi-0x1]
  22be24:	48 29 c6             	sub    rsi,rax
  22be27:	31 c0                	xor    eax,eax
  22be29:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  22be30:	c5 fc 10 04 01       	vmovups ymm0,YMMWORD PTR [rcx+rax*1]
  22be35:	c5 fc 10 4c 01 20    	vmovups ymm1,YMMWORD PTR [rcx+rax*1+0x20]
  22be3b:	c5 fc 10 54 01 40    	vmovups ymm2,YMMWORD PTR [rcx+rax*1+0x40]
  22be41:	c5 fc 10 5c 01 60    	vmovups ymm3,YMMWORD PTR [rcx+rax*1+0x60]
        dest[i] = s;
  22be47:	c5 fc 11 84 03 20 fe 	vmovups YMMWORD PTR [rbx+rax*1-0x1e0],ymm0
  22be4e:	ff ff 
  22be50:	c5 fc 11 8c 03 40 fe 	vmovups YMMWORD PTR [rbx+rax*1-0x1c0],ymm1
  22be57:	ff ff 
  22be59:	c5 fc 11 94 03 60 fe 	vmovups YMMWORD PTR [rbx+rax*1-0x1a0],ymm2
  22be60:	ff ff 
  22be62:	c5 fc 11 9c 03 80 fe 	vmovups YMMWORD PTR [rbx+rax*1-0x180],ymm3
  22be69:	ff ff 
    for (source) |s, i|
  22be6b:	c5 fc 10 84 01 80 00 	vmovups ymm0,YMMWORD PTR [rcx+rax*1+0x80]
  22be72:	00 00 
  22be74:	c5 fc 10 8c 01 a0 00 	vmovups ymm1,YMMWORD PTR [rcx+rax*1+0xa0]
  22be7b:	00 00 
  22be7d:	c5 fc 10 94 01 c0 00 	vmovups ymm2,YMMWORD PTR [rcx+rax*1+0xc0]
  22be84:	00 00 
  22be86:	c5 fc 10 9c 01 e0 00 	vmovups ymm3,YMMWORD PTR [rcx+rax*1+0xe0]
  22be8d:	00 00 
        dest[i] = s;
  22be8f:	c5 fc 11 84 03 a0 fe 	vmovups YMMWORD PTR [rbx+rax*1-0x160],ymm0
  22be96:	ff ff 
  22be98:	c5 fc 11 8c 03 c0 fe 	vmovups YMMWORD PTR [rbx+rax*1-0x140],ymm1
  22be9f:	ff ff 
  22bea1:	c5 fc 11 94 03 e0 fe 	vmovups YMMWORD PTR [rbx+rax*1-0x120],ymm2
  22bea8:	ff ff 
  22beaa:	c5 fc 11 9c 03 00 ff 	vmovups YMMWORD PTR [rbx+rax*1-0x100],ymm3
  22beb1:	ff ff 
    for (source) |s, i|
  22beb3:	c5 fc 10 84 01 00 01 	vmovups ymm0,YMMWORD PTR [rcx+rax*1+0x100]
  22beba:	00 00 
  22bebc:	c5 fc 10 8c 01 20 01 	vmovups ymm1,YMMWORD PTR [rcx+rax*1+0x120]
  22bec3:	00 00 
  22bec5:	c5 fc 10 94 01 40 01 	vmovups ymm2,YMMWORD PTR [rcx+rax*1+0x140]
  22becc:	00 00 
  22bece:	c5 fc 10 9c 01 60 01 	vmovups ymm3,YMMWORD PTR [rcx+rax*1+0x160]
  22bed5:	00 00 
        dest[i] = s;
  22bed7:	c5 fc 11 84 03 20 ff 	vmovups YMMWORD PTR [rbx+rax*1-0xe0],ymm0
  22bede:	ff ff 
  22bee0:	c5 fc 11 8c 03 40 ff 	vmovups YMMWORD PTR [rbx+rax*1-0xc0],ymm1
  22bee7:	ff ff 
  22bee9:	c5 fc 11 94 03 60 ff 	vmovups YMMWORD PTR [rbx+rax*1-0xa0],ymm2
  22bef0:	ff ff 
  22bef2:	c5 fc 11 5c 03 80    	vmovups YMMWORD PTR [rbx+rax*1-0x80],ymm3
    for (source) |s, i|
  22bef8:	c5 fc 10 84 01 80 01 	vmovups ymm0,YMMWORD PTR [rcx+rax*1+0x180]
  22beff:	00 00 
  22bf01:	c5 fc 10 8c 01 a0 01 	vmovups ymm1,YMMWORD PTR [rcx+rax*1+0x1a0]
  22bf08:	00 00 
  22bf0a:	c5 fc 10 94 01 c0 01 	vmovups ymm2,YMMWORD PTR [rcx+rax*1+0x1c0]
  22bf11:	00 00 
  22bf13:	c5 fc 10 9c 01 e0 01 	vmovups ymm3,YMMWORD PTR [rcx+rax*1+0x1e0]
  22bf1a:	00 00 
        dest[i] = s;
  22bf1c:	c5 fc 11 44 03 a0    	vmovups YMMWORD PTR [rbx+rax*1-0x60],ymm0
  22bf22:	c5 fc 11 4c 03 c0    	vmovups YMMWORD PTR [rbx+rax*1-0x40],ymm1
  22bf28:	c5 fc 11 54 03 e0    	vmovups YMMWORD PTR [rbx+rax*1-0x20],ymm2
  22bf2e:	c5 fc 11 1c 03       	vmovups YMMWORD PTR [rbx+rax*1],ymm3
    for (source) |s, i|
  22bf33:	48 05 00 02 00 00    	add    rax,0x200
  22bf39:	48 83 c6 04          	add    rsi,0x4
  22bf3d:	0f 85 ed fe ff ff    	jne    22be30 <join.192+0x460>
  22bf43:	48 85 ff             	test   rdi,rdi
  22bf46:	74 44                	je     22bf8c <join.192+0x5bc>
  22bf48:	48 83 c0 60          	add    rax,0x60
  22bf4c:	48 f7 df             	neg    rdi
  22bf4f:	90                   	nop
  22bf50:	c5 fc 10 44 01 a0    	vmovups ymm0,YMMWORD PTR [rcx+rax*1-0x60]
  22bf56:	c5 fc 10 4c 01 c0    	vmovups ymm1,YMMWORD PTR [rcx+rax*1-0x40]
  22bf5c:	c5 fc 10 54 01 e0    	vmovups ymm2,YMMWORD PTR [rcx+rax*1-0x20]
  22bf62:	c5 fc 10 1c 01       	vmovups ymm3,YMMWORD PTR [rcx+rax*1]
        dest[i] = s;
  22bf67:	c4 c1 7c 11 44 01 a0 	vmovups YMMWORD PTR [r9+rax*1-0x60],ymm0
  22bf6e:	c4 c1 7c 11 4c 01 c0 	vmovups YMMWORD PTR [r9+rax*1-0x40],ymm1
  22bf75:	c4 c1 7c 11 54 01 e0 	vmovups YMMWORD PTR [r9+rax*1-0x20],ymm2
  22bf7c:	c4 c1 7c 11 1c 01    	vmovups YMMWORD PTR [r9+rax*1],ymm3
    for (source) |s, i|
  22bf82:	48 83 e8 80          	sub    rax,0xffffffffffffff80
  22bf86:	48 83 c7 01          	add    rdi,0x1
  22bf8a:	75 c4                	jne    22bf50 <join.192+0x580>
  22bf8c:	49 39 d6             	cmp    r14,rdx
  22bf8f:	0f 85 ac fd ff ff    	jne    22bd41 <join.192+0x371>
        if (n == 0) {
  22bf95:	4d 01 c6             	add    r14,r8
  22bf98:	74 40                	je     22bfda <join.192+0x60a>
        assert(n <= old_mem.len);
  22bf9a:	4d 39 f5             	cmp    r13,r14
  22bf9d:	0f 82 8c 00 00 00    	jb     22c02f <join.192+0x65f>
        const byte_slice = self.reallocFn(self, @sliceToBytes(old_mem), byte_count, alignment) catch unreachable;
  22bfa3:	49 8b 42 08          	mov    rax,QWORD PTR [r10+0x8]
  22bfa7:	48 89 6c 24 20       	mov    QWORD PTR [rsp+0x20],rbp
  22bfac:	4c 89 6c 24 28       	mov    QWORD PTR [rsp+0x28],r13
  22bfb1:	48 8d 7c 24 08       	lea    rdi,[rsp+0x8]
  22bfb6:	48 8d 54 24 20       	lea    rdx,[rsp+0x20]
  22bfbb:	41 b8 01 00 00 00    	mov    r8d,0x1
  22bfc1:	4c 89 d6             	mov    rsi,r10
  22bfc4:	4c 89 f1             	mov    rcx,r14
  22bfc7:	c5 f8 77             	vzeroupper 
  22bfca:	ff d0                	call   rax
        assert(byte_slice.len == byte_count);
  22bfcc:	4c 39 74 24 18       	cmp    QWORD PTR [rsp+0x18],r14
  22bfd1:	75 5c                	jne    22c02f <join.192+0x65f>
        const byte_slice = self.reallocFn(self, @sliceToBytes(old_mem), byte_count, alignment) catch unreachable;
  22bfd3:	48 8b 6c 24 10       	mov    rbp,QWORD PTR [rsp+0x10]
  22bfd8:	eb 23                	jmp    22bffd <join.192+0x62d>
        if (bytes.len == 0) return;
  22bfda:	4d 85 ed             	test   r13,r13
  22bfdd:	74 1b                	je     22bffa <join.192+0x62a>
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  22bfdf:	49 8b 42 10          	mov    rax,QWORD PTR [r10+0x10]
  22bfe3:	48 89 6c 24 30       	mov    QWORD PTR [rsp+0x30],rbp
  22bfe8:	4c 89 6c 24 38       	mov    QWORD PTR [rsp+0x38],r13
  22bfed:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
  22bff2:	4c 89 d7             	mov    rdi,r10
  22bff5:	c5 f8 77             	vzeroupper 
  22bff8:	ff d0                	call   rax
  22bffa:	45 31 f6             	xor    r14d,r14d
    return allocator.shrink(u8, buf, buf_index);
  22bffd:	66 41 c7 07 00 00    	mov    WORD PTR [r15],0x0
  22c003:	0f b7 44 24 06       	movzx  eax,WORD PTR [rsp+0x6]
  22c008:	66 41 89 47 06       	mov    WORD PTR [r15+0x6],ax
  22c00d:	8b 44 24 02          	mov    eax,DWORD PTR [rsp+0x2]
  22c011:	41 89 47 02          	mov    DWORD PTR [r15+0x2],eax
  22c015:	49 89 6f 08          	mov    QWORD PTR [r15+0x8],rbp
  22c019:	4d 89 77 10          	mov    QWORD PTR [r15+0x10],r14
  22c01d:	48 83 c4 58          	add    rsp,0x58
  22c021:	5b                   	pop    rbx
  22c022:	41 5c                	pop    r12
  22c024:	41 5d                	pop    r13
  22c026:	41 5e                	pop    r14
  22c028:	41 5f                	pop    r15
  22c02a:	5d                   	pop    rbp
  22c02b:	c5 f8 77             	vzeroupper 
  22c02e:	c3                   	ret    
            @panic("assertion failure");
  22c02f:	48 8d 3d 5a 3d 02 00 	lea    rdi,[rip+0x23d5a]        # 24fd90 <__unnamed_2>
  22c036:	c5 f8 77             	vzeroupper 
  22c039:	e8 e2 66 fe ff       	call   212720 <panic>
  22c03e:	66 90                	xchg   ax,ax

000000000022c040 <printLineFromFile>:
fn printLineFromFile(out_stream: var, line_info: *const LineInfo) !void {
  22c040:	55                   	push   rbp
  22c041:	41 57                	push   r15
  22c043:	41 56                	push   r14
  22c045:	41 55                	push   r13
  22c047:	41 54                	push   r12
  22c049:	53                   	push   rbx
  22c04a:	48 81 ec 48 30 00 00 	sub    rsp,0x3048
  22c051:	48 89 f5             	mov    rbp,rsi
  22c054:	48 89 7c 24 38       	mov    QWORD PTR [rsp+0x38],rdi
    var path_with_null: [posix.PATH_MAX]u8 = undefined;
  22c059:	48 8d 35 58 c6 fd ff 	lea    rsi,[rip+0xfffffffffffdc658]        # 2086b8 <__unnamed_106>
  22c060:	48 8d 7c 24 48       	lea    rdi,[rsp+0x48]
  22c065:	ba 00 10 00 00       	mov    edx,0x1000
  22c06a:	e8 11 2e 00 00       	call   22ee80 <memcpy>
    if (file_path.len >= posix.PATH_MAX) return error.NameTooLong;
  22c06f:	48 8b 5d 18          	mov    rbx,QWORD PTR [rbp+0x18]
  22c073:	48 81 fb ff 0f 00 00 	cmp    rbx,0xfff
  22c07a:	76 06                	jbe    22c082 <printLineFromFile+0x42>
  22c07c:	66 bd 1c 00          	mov    bp,0x1c
  22c080:	eb 53                	jmp    22c0d5 <printLineFromFile+0x95>
    for (source) |s, i|
  22c082:	48 85 db             	test   rbx,rbx
  22c085:	74 11                	je     22c098 <printLineFromFile+0x58>
  22c087:	48 8b 75 10          	mov    rsi,QWORD PTR [rbp+0x10]
  22c08b:	48 8d 7c 24 48       	lea    rdi,[rsp+0x48]
        dest[i] = s;
  22c090:	48 89 da             	mov    rdx,rbx
  22c093:	e8 e8 2d 00 00       	call   22ee80 <memcpy>
  22c098:	48 89 6c 24 10       	mov    QWORD PTR [rsp+0x10],rbp
    path_with_null[file_path.len] = 0;
  22c09d:	c6 44 1c 48 00       	mov    BYTE PTR [rsp+rbx*1+0x48],0x0
  22c0a2:	48 8d 9c 24 48 10 00 	lea    rbx,[rsp+0x1048]
  22c0a9:	00 
  22c0aa:	48 8d 74 24 48       	lea    rsi,[rsp+0x48]
    return path_with_null;
  22c0af:	ba 00 10 00 00       	mov    edx,0x1000
  22c0b4:	48 89 df             	mov    rdi,rbx
  22c0b7:	e8 c4 2d 00 00       	call   22ee80 <memcpy>
  22c0bc:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
            return openReadC(&path_c);
  22c0c1:	48 89 de             	mov    rsi,rbx
  22c0c4:	e8 67 7d ff ff       	call   223e30 <File_openReadC>
  22c0c9:	48 8b 5c 24 40       	mov    rbx,QWORD PTR [rsp+0x40]
  22c0ce:	89 dd                	mov    ebp,ebx
    var f = try os.File.openRead(line_info.file_name);
  22c0d0:	66 85 db             	test   bx,bx
  22c0d3:	74 14                	je     22c0e9 <printLineFromFile+0xa9>
  22c0d5:	89 e8                	mov    eax,ebp
  22c0d7:	48 81 c4 48 30 00 00 	add    rsp,0x3048
  22c0de:	5b                   	pop    rbx
  22c0df:	41 5c                	pop    r12
  22c0e1:	41 5d                	pop    r13
  22c0e3:	41 5e                	pop    r14
  22c0e5:	41 5f                	pop    r15
  22c0e7:	5d                   	pop    rbp
  22c0e8:	c3                   	ret    
  22c0e9:	48 89 d8             	mov    rax,rbx
  22c0ec:	48 c1 e8 20          	shr    rax,0x20
  22c0f0:	89 44 24 08          	mov    DWORD PTR [rsp+0x8],eax
    var buf: [os.page_size]u8 = undefined;
  22c0f4:	48 8d 35 bd c5 fd ff 	lea    rsi,[rip+0xfffffffffffdc5bd]        # 2086b8 <__unnamed_106>
  22c0fb:	48 8d ac 24 48 20 00 	lea    rbp,[rsp+0x2048]
  22c102:	00 
  22c103:	ba 00 10 00 00       	mov    edx,0x1000
  22c108:	48 89 ef             	mov    rdi,rbp
  22c10b:	e8 70 2d 00 00       	call   22ee80 <memcpy>
        const amt_read = try f.read(buf[0..]);
  22c110:	48 89 6c 24 28       	mov    QWORD PTR [rsp+0x28],rbp
  22c115:	48 c7 44 24 30 00 10 	mov    QWORD PTR [rsp+0x30],0x1000
  22c11c:	00 00 
  22c11e:	48 8d 7c 24 18       	lea    rdi,[rsp+0x18]
  22c123:	48 8d 74 24 08       	lea    rsi,[rsp+0x8]
  22c128:	48 8d 54 24 28       	lea    rdx,[rsp+0x28]
  22c12d:	e8 fe 7e ff ff       	call   224030 <File_read>
  22c132:	66 83 7c 24 18 00    	cmp    WORD PTR [rsp+0x18],0x0
  22c138:	48 8b 6c 24 10       	mov    rbp,QWORD PTR [rsp+0x10]
  22c13d:	74 4e                	je     22c18d <printLineFromFile+0x14d>
  22c13f:	48 c1 fb 20          	sar    rbx,0x20
  22c143:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  22c14a:	84 00 00 00 00 00 
    return asm volatile ("syscall"
  22c150:	b8 03 00 00 00       	mov    eax,0x3
  22c155:	48 89 df             	mov    rdi,rbx
  22c158:	0f 05                	syscall 
            switch (err) {
  22c15a:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  22c15e:	74 f0                	je     22c150 <printLineFromFile+0x110>
            const first = list.first orelse return null;
  22c160:	48 8b 05 b9 4e 02 00 	mov    rax,QWORD PTR [rip+0x24eb9]        # 251020 <emfile_promise_queue>
  22c167:	48 85 c0             	test   rax,rax
  22c16a:	0f 84 05 02 00 00    	je     22c375 <printLineFromFile+0x335>
            if (node.prev) |prev_node| {
  22c170:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  22c173:	48 85 c9             	test   rcx,rcx
  22c176:	0f 84 91 01 00 00    	je     22c30d <printLineFromFile+0x2cd>
                prev_node.next = node.next;
  22c17c:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  22c180:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  22c184:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  22c188:	e9 8b 01 00 00       	jmp    22c318 <printLineFromFile+0x2d8>
  22c18d:	41 bd 01 00 00 00    	mov    r13d,0x1
  22c193:	4c 8b 64 24 20       	mov    r12,QWORD PTR [rsp+0x20]
        for (slice) |byte| {
  22c198:	4d 85 e4             	test   r12,r12
  22c19b:	0f 84 bb 02 00 00    	je     22c45c <printLineFromFile+0x41c>
  22c1a1:	45 31 ff             	xor    r15d,r15d
  22c1a4:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  22c1ab:	00 00 00 00 00 
  22c1b0:	46 0f b6 b4 3c 48 20 	movzx  r14d,BYTE PTR [rsp+r15*1+0x2048]
  22c1b7:	00 00 
            if (line == line_info.line) {
  22c1b9:	4c 3b 6d 00          	cmp    r13,QWORD PTR [rbp+0x0]
  22c1bd:	75 51                	jne    22c210 <printLineFromFile+0x1d0>
  22c1bf:	44 88 b4 24 48 10 00 	mov    BYTE PTR [rsp+0x1048],r14b
  22c1c6:	00 
            const slice = (*[1]u8)(&byte)[0..];
  22c1c7:	48 8d 84 24 48 10 00 	lea    rax,[rsp+0x1048]
  22c1ce:	00 
  22c1cf:	48 89 44 24 48       	mov    QWORD PTR [rsp+0x48],rax
  22c1d4:	48 c7 44 24 50 01 00 	mov    QWORD PTR [rsp+0x50],0x1
  22c1db:	00 00 
  22c1dd:	48 8b 7c 24 38       	mov    rdi,QWORD PTR [rsp+0x38]
            return self.writeFn(self, slice);
  22c1e2:	48 8d 74 24 48       	lea    rsi,[rsp+0x48]
  22c1e7:	ff 17                	call   QWORD PTR [rdi]
  22c1e9:	89 c5                	mov    ebp,eax
                try out_stream.writeByte(byte);
  22c1eb:	66 85 ed             	test   bp,bp
  22c1ee:	75 7d                	jne    22c26d <printLineFromFile+0x22d>
                if (byte == '\n') {
  22c1f0:	41 80 fe 0a          	cmp    r14b,0xa
  22c1f4:	48 8b 6c 24 10       	mov    rbp,QWORD PTR [rsp+0x10]
  22c1f9:	0f 84 be 00 00 00    	je     22c2bd <printLineFromFile+0x27d>
        for (slice) |byte| {
  22c1ff:	49 83 c7 01          	add    r15,0x1
  22c203:	4d 39 e7             	cmp    r15,r12
  22c206:	72 a8                	jb     22c1b0 <printLineFromFile+0x170>
  22c208:	eb 1b                	jmp    22c225 <printLineFromFile+0x1e5>
  22c20a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
            if (byte == '\n') {
  22c210:	31 c0                	xor    eax,eax
  22c212:	41 80 fe 0a          	cmp    r14b,0xa
  22c216:	0f 94 c0             	sete   al
  22c219:	49 01 c5             	add    r13,rax
        for (slice) |byte| {
  22c21c:	49 83 c7 01          	add    r15,0x1
  22c220:	4d 39 e7             	cmp    r15,r12
  22c223:	72 8b                	jb     22c1b0 <printLineFromFile+0x170>
        if (amt_read < buf.len) return error.EndOfFile;
  22c225:	49 81 fc ff 0f 00 00 	cmp    r12,0xfff
  22c22c:	48 8d 84 24 48 20 00 	lea    rax,[rsp+0x2048]
  22c233:	00 
  22c234:	0f 86 22 02 00 00    	jbe    22c45c <printLineFromFile+0x41c>
        const amt_read = try f.read(buf[0..]);
  22c23a:	48 89 44 24 28       	mov    QWORD PTR [rsp+0x28],rax
  22c23f:	48 c7 44 24 30 00 10 	mov    QWORD PTR [rsp+0x30],0x1000
  22c246:	00 00 
  22c248:	48 8d 7c 24 18       	lea    rdi,[rsp+0x18]
  22c24d:	48 8d 74 24 08       	lea    rsi,[rsp+0x8]
  22c252:	48 8d 54 24 28       	lea    rdx,[rsp+0x28]
  22c257:	e8 d4 7d ff ff       	call   224030 <File_read>
  22c25c:	66 83 7c 24 18 00    	cmp    WORD PTR [rsp+0x18],0x0
  22c262:	0f 84 2b ff ff ff    	je     22c193 <printLineFromFile+0x153>
  22c268:	e9 d2 fe ff ff       	jmp    22c13f <printLineFromFile+0xff>
  22c26d:	48 c1 fb 20          	sar    rbx,0x20
  22c271:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  22c278:	0f 1f 84 00 00 00 00 
  22c27f:	00 
  22c280:	b8 03 00 00 00       	mov    eax,0x3
  22c285:	48 89 df             	mov    rdi,rbx
  22c288:	0f 05                	syscall 
  22c28a:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  22c28e:	74 f0                	je     22c280 <printLineFromFile+0x240>
            const first = list.first orelse return null;
  22c290:	48 8b 05 89 4d 02 00 	mov    rax,QWORD PTR [rip+0x24d89]        # 251020 <emfile_promise_queue>
  22c297:	48 85 c0             	test   rax,rax
  22c29a:	0f 84 35 fe ff ff    	je     22c0d5 <printLineFromFile+0x95>
            if (node.prev) |prev_node| {
  22c2a0:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  22c2a3:	48 85 c9             	test   rcx,rcx
  22c2a6:	0f 84 d3 00 00 00    	je     22c37f <printLineFromFile+0x33f>
                prev_node.next = node.next;
  22c2ac:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  22c2b0:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  22c2b4:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  22c2b8:	e9 cd 00 00 00       	jmp    22c38a <printLineFromFile+0x34a>
  22c2bd:	48 c1 fb 20          	sar    rbx,0x20
  22c2c1:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  22c2c8:	0f 1f 84 00 00 00 00 
  22c2cf:	00 
  22c2d0:	b8 03 00 00 00       	mov    eax,0x3
  22c2d5:	48 89 df             	mov    rdi,rbx
  22c2d8:	0f 05                	syscall 
  22c2da:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  22c2de:	74 f0                	je     22c2d0 <printLineFromFile+0x290>
            const first = list.first orelse return null;
  22c2e0:	48 8b 05 39 4d 02 00 	mov    rax,QWORD PTR [rip+0x24d39]        # 251020 <emfile_promise_queue>
  22c2e7:	48 85 c0             	test   rax,rax
  22c2ea:	0f 84 65 01 00 00    	je     22c455 <printLineFromFile+0x415>
            if (node.prev) |prev_node| {
  22c2f0:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  22c2f3:	48 85 c9             	test   rcx,rcx
  22c2f6:	0f 84 f2 00 00 00    	je     22c3ee <printLineFromFile+0x3ae>
                prev_node.next = node.next;
  22c2fc:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  22c300:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  22c304:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  22c308:	e9 ec 00 00 00       	jmp    22c3f9 <printLineFromFile+0x3b9>
                list.first = node.next;
  22c30d:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  22c311:	48 89 0d 08 4d 02 00 	mov    QWORD PTR [rip+0x24d08],rcx        # 251020 <emfile_promise_queue>
            if (node.next) |next_node| {
  22c318:	48 85 c9             	test   rcx,rcx
  22c31b:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  22c31e:	48 8d 35 03 4d 02 00 	lea    rsi,[rip+0x24d03]        # 251028 <emfile_promise_queue+0x8>
  22c325:	48 0f 45 f1          	cmovne rsi,rcx
  22c329:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  22c32c:	48 83 05 fc 4c 02 00 	add    QWORD PTR [rip+0x24cfc],0xffffffffffffffff        # 251030 <emfile_promise_queue+0x10>
  22c333:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  22c334:	74 1e                	je     22c354 <printLineFromFile+0x314>
  22c336:	48 83 3d e2 4c 02 00 	cmp    QWORD PTR [rip+0x24ce2],0x0        # 251020 <emfile_promise_queue>
  22c33d:	00 
  22c33e:	0f 84 b1 01 00 00    	je     22c4f5 <printLineFromFile+0x4b5>
  22c344:	48 8b 0d dd 4c 02 00 	mov    rcx,QWORD PTR [rip+0x24cdd]        # 251028 <emfile_promise_queue+0x8>
  22c34b:	48 85 c9             	test   rcx,rcx
  22c34e:	0f 84 a1 01 00 00    	je     22c4f5 <printLineFromFile+0x4b5>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  22c354:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  22c358:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  22c35c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  22c360:	48 89 c1             	mov    rcx,rax
  22c363:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  22c367:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  22c36d:	75 f1                	jne    22c360 <printLineFromFile+0x320>
  22c36f:	a8 01                	test   al,0x1
  22c371:	75 02                	jne    22c375 <printLineFromFile+0x335>
  22c373:	ff 17                	call   QWORD PTR [rdi]
  22c375:	0f b7 44 24 18       	movzx  eax,WORD PTR [rsp+0x18]
  22c37a:	e9 58 fd ff ff       	jmp    22c0d7 <printLineFromFile+0x97>
                list.first = node.next;
  22c37f:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  22c383:	48 89 0d 96 4c 02 00 	mov    QWORD PTR [rip+0x24c96],rcx        # 251020 <emfile_promise_queue>
            if (node.next) |next_node| {
  22c38a:	48 85 c9             	test   rcx,rcx
  22c38d:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  22c390:	48 8d 35 91 4c 02 00 	lea    rsi,[rip+0x24c91]        # 251028 <emfile_promise_queue+0x8>
  22c397:	48 0f 45 f1          	cmovne rsi,rcx
  22c39b:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  22c39e:	48 83 05 8a 4c 02 00 	add    QWORD PTR [rip+0x24c8a],0xffffffffffffffff        # 251030 <emfile_promise_queue+0x10>
  22c3a5:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  22c3a6:	74 1e                	je     22c3c6 <printLineFromFile+0x386>
  22c3a8:	48 83 3d 70 4c 02 00 	cmp    QWORD PTR [rip+0x24c70],0x0        # 251020 <emfile_promise_queue>
  22c3af:	00 
  22c3b0:	0f 84 3f 01 00 00    	je     22c4f5 <printLineFromFile+0x4b5>
  22c3b6:	48 8b 0d 6b 4c 02 00 	mov    rcx,QWORD PTR [rip+0x24c6b]        # 251028 <emfile_promise_queue+0x8>
  22c3bd:	48 85 c9             	test   rcx,rcx
  22c3c0:	0f 84 2f 01 00 00    	je     22c4f5 <printLineFromFile+0x4b5>
  22c3c6:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  22c3ca:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  22c3ce:	66 90                	xchg   ax,ax
  22c3d0:	48 89 c1             	mov    rcx,rax
  22c3d3:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  22c3d7:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  22c3dd:	75 f1                	jne    22c3d0 <printLineFromFile+0x390>
  22c3df:	a8 01                	test   al,0x1
  22c3e1:	0f 85 ee fc ff ff    	jne    22c0d5 <printLineFromFile+0x95>
  22c3e7:	ff 17                	call   QWORD PTR [rdi]
  22c3e9:	e9 e7 fc ff ff       	jmp    22c0d5 <printLineFromFile+0x95>
                list.first = node.next;
  22c3ee:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  22c3f2:	48 89 0d 27 4c 02 00 	mov    QWORD PTR [rip+0x24c27],rcx        # 251020 <emfile_promise_queue>
            if (node.next) |next_node| {
  22c3f9:	48 85 c9             	test   rcx,rcx
  22c3fc:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  22c3ff:	48 8d 35 22 4c 02 00 	lea    rsi,[rip+0x24c22]        # 251028 <emfile_promise_queue+0x8>
  22c406:	48 0f 45 f1          	cmovne rsi,rcx
  22c40a:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  22c40d:	48 83 05 1b 4c 02 00 	add    QWORD PTR [rip+0x24c1b],0xffffffffffffffff        # 251030 <emfile_promise_queue+0x10>
  22c414:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  22c415:	74 1e                	je     22c435 <printLineFromFile+0x3f5>
  22c417:	48 83 3d 01 4c 02 00 	cmp    QWORD PTR [rip+0x24c01],0x0        # 251020 <emfile_promise_queue>
  22c41e:	00 
  22c41f:	0f 84 d0 00 00 00    	je     22c4f5 <printLineFromFile+0x4b5>
  22c425:	48 8b 0d fc 4b 02 00 	mov    rcx,QWORD PTR [rip+0x24bfc]        # 251028 <emfile_promise_queue+0x8>
  22c42c:	48 85 c9             	test   rcx,rcx
  22c42f:	0f 84 c0 00 00 00    	je     22c4f5 <printLineFromFile+0x4b5>
  22c435:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  22c439:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  22c43d:	0f 1f 00             	nop    DWORD PTR [rax]
  22c440:	48 89 c1             	mov    rcx,rax
  22c443:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  22c447:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  22c44d:	75 f1                	jne    22c440 <printLineFromFile+0x400>
  22c44f:	a8 01                	test   al,0x1
  22c451:	75 02                	jne    22c455 <printLineFromFile+0x415>
  22c453:	ff 17                	call   QWORD PTR [rdi]
  22c455:	31 ed                	xor    ebp,ebp
  22c457:	e9 79 fc ff ff       	jmp    22c0d5 <printLineFromFile+0x95>
  22c45c:	48 c1 fb 20          	sar    rbx,0x20
  22c460:	b8 03 00 00 00       	mov    eax,0x3
  22c465:	48 89 df             	mov    rdi,rbx
  22c468:	0f 05                	syscall 
            switch (err) {
  22c46a:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  22c46e:	74 f0                	je     22c460 <printLineFromFile+0x420>
            const first = list.first orelse return null;
  22c470:	48 8b 05 a9 4b 02 00 	mov    rax,QWORD PTR [rip+0x24ba9]        # 251020 <emfile_promise_queue>
  22c477:	66 bd 2a 00          	mov    bp,0x2a
  22c47b:	48 85 c0             	test   rax,rax
  22c47e:	0f 84 51 fc ff ff    	je     22c0d5 <printLineFromFile+0x95>
            if (node.prev) |prev_node| {
  22c484:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  22c487:	48 85 c9             	test   rcx,rcx
  22c48a:	74 0e                	je     22c49a <printLineFromFile+0x45a>
                prev_node.next = node.next;
  22c48c:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  22c490:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  22c494:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  22c498:	eb 0b                	jmp    22c4a5 <printLineFromFile+0x465>
                list.first = node.next;
  22c49a:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  22c49e:	48 89 0d 7b 4b 02 00 	mov    QWORD PTR [rip+0x24b7b],rcx        # 251020 <emfile_promise_queue>
            if (node.next) |next_node| {
  22c4a5:	48 85 c9             	test   rcx,rcx
  22c4a8:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  22c4ab:	48 8d 35 76 4b 02 00 	lea    rsi,[rip+0x24b76]        # 251028 <emfile_promise_queue+0x8>
  22c4b2:	48 0f 45 f1          	cmovne rsi,rcx
  22c4b6:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  22c4b9:	48 83 05 6f 4b 02 00 	add    QWORD PTR [rip+0x24b6f],0xffffffffffffffff        # 251030 <emfile_promise_queue+0x10>
  22c4c0:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  22c4c1:	74 16                	je     22c4d9 <printLineFromFile+0x499>
  22c4c3:	48 83 3d 55 4b 02 00 	cmp    QWORD PTR [rip+0x24b55],0x0        # 251020 <emfile_promise_queue>
  22c4ca:	00 
  22c4cb:	74 28                	je     22c4f5 <printLineFromFile+0x4b5>
  22c4cd:	48 8b 0d 54 4b 02 00 	mov    rcx,QWORD PTR [rip+0x24b54]        # 251028 <emfile_promise_queue+0x8>
  22c4d4:	48 85 c9             	test   rcx,rcx
  22c4d7:	74 1c                	je     22c4f5 <printLineFromFile+0x4b5>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  22c4d9:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  22c4dd:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  22c4e1:	48 89 c1             	mov    rcx,rax
  22c4e4:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  22c4e8:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  22c4ee:	75 f1                	jne    22c4e1 <printLineFromFile+0x4a1>
  22c4f0:	e9 ea fe ff ff       	jmp    22c3df <printLineFromFile+0x39f>
            @panic("assertion failure");
  22c4f5:	48 8d 3d 94 38 02 00 	lea    rdi,[rip+0x23894]        # 24fd90 <__unnamed_2>
  22c4fc:	e8 1f 62 fe ff       	call   212720 <panic>
  22c501:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  22c508:	0f 1f 84 00 00 00 00 
  22c50f:	00 

000000000022c510 <DirectAllocator_alloc>:
    fn alloc(allocator: *Allocator, n: usize, alignment: u29) ![]u8 {
  22c510:	41 57                	push   r15
  22c512:	41 56                	push   r14
  22c514:	41 55                	push   r13
  22c516:	41 54                	push   r12
  22c518:	53                   	push   rbx
  22c519:	48 83 ec 10          	sub    rsp,0x10
  22c51d:	41 89 cc             	mov    r12d,ecx
  22c520:	49 89 d6             	mov    r14,rdx
  22c523:	49 89 ff             	mov    r15,rdi
  22c526:	45 89 e5             	mov    r13d,r12d
  22c529:	41 81 e5 ff ff ff 1f 	and    r13d,0x1fffffff
                const alloc_size = if (alignment <= os.page_size) n else n + alignment;
  22c530:	31 c0                	xor    eax,eax
  22c532:	41 81 fd 01 10 00 00 	cmp    r13d,0x1001
  22c539:	4c 89 eb             	mov    rbx,r13
  22c53c:	48 0f 42 d8          	cmovb  rbx,rax
  22c540:	4a 8d 34 33          	lea    rsi,[rbx+r14*1]
    arg3: usize,
    arg4: usize,
    arg5: usize,
    arg6: usize,
) usize {
    return asm volatile ("syscall"
  22c544:	b8 09 00 00 00       	mov    eax,0x9
  22c549:	bf 00 00 00 00       	mov    edi,0x0
  22c54e:	ba 03 00 00 00       	mov    edx,0x3
  22c553:	41 ba 22 00 00 00    	mov    r10d,0x22
  22c559:	49 c7 c0 ff ff ff ff 	mov    r8,0xffffffffffffffff
  22c560:	45 31 c9             	xor    r9d,r9d
  22c563:	0f 05                	syscall 
  22c565:	48 89 c1             	mov    rcx,rax
                if (addr == p.MAP_FAILED) return error.OutOfMemory;
  22c568:	48 83 f9 ff          	cmp    rcx,0xffffffffffffffff
  22c56c:	74 55                	je     22c5c3 <DirectAllocator_alloc+0xb3>
                if (alloc_size == n) return @intToPtr([*]u8, addr)[0..n];
  22c56e:	48 85 db             	test   rbx,rbx
  22c571:	74 6a                	je     22c5dd <DirectAllocator_alloc+0xcd>
                const aligned_addr = (addr & ~usize(alignment - 1)) + alignment;
  22c573:	41 81 c4 ff ff ff 1f 	add    r12d,0x1fffffff
  22c57a:	41 f7 d4             	not    r12d
  22c57d:	49 81 cc 00 00 00 e0 	or     r12,0xffffffffe0000000
  22c584:	49 21 cc             	and    r12,rcx
  22c587:	4d 01 ec             	add    r12,r13
                const unused_len = aligned_addr - 1 - unused_start;
  22c58a:	48 89 ce             	mov    rsi,rcx
  22c58d:	48 f7 d6             	not    rsi
  22c590:	4c 01 e6             	add    rsi,r12
    return asm volatile ("syscall"
  22c593:	b8 0b 00 00 00       	mov    eax,0xb
  22c598:	48 89 cf             	mov    rdi,rcx
  22c59b:	0f 05                	syscall 
  22c59d:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
    if (!ok) {
  22c5a3:	73 69                	jae    22c60e <DirectAllocator_alloc+0xfe>
                return @intToPtr([*]u8, aligned_addr)[0..n];
  22c5a5:	66 41 c7 07 00 00    	mov    WORD PTR [r15],0x0
  22c5ab:	0f b7 44 24 08       	movzx  eax,WORD PTR [rsp+0x8]
  22c5b0:	66 41 89 47 06       	mov    WORD PTR [r15+0x6],ax
  22c5b5:	8b 44 24 04          	mov    eax,DWORD PTR [rsp+0x4]
  22c5b9:	41 89 47 02          	mov    DWORD PTR [r15+0x2],eax
  22c5bd:	4d 89 67 08          	mov    QWORD PTR [r15+0x8],r12
  22c5c1:	eb 36                	jmp    22c5f9 <DirectAllocator_alloc+0xe9>
                if (addr == p.MAP_FAILED) return error.OutOfMemory;
  22c5c3:	48 8b 05 fe d0 fd ff 	mov    rax,QWORD PTR [rip+0xfffffffffffdd0fe]        # 2096c8 <__unnamed_1+0x10>
  22c5ca:	49 89 47 10          	mov    QWORD PTR [r15+0x10],rax
  22c5ce:	c5 f8 10 05 e2 d0 fd 	vmovups xmm0,XMMWORD PTR [rip+0xfffffffffffdd0e2]        # 2096b8 <__unnamed_1>
  22c5d5:	ff 
  22c5d6:	c4 c1 78 11 07       	vmovups XMMWORD PTR [r15],xmm0
  22c5db:	eb 20                	jmp    22c5fd <DirectAllocator_alloc+0xed>
                if (alloc_size == n) return @intToPtr([*]u8, addr)[0..n];
  22c5dd:	66 41 c7 07 00 00    	mov    WORD PTR [r15],0x0
  22c5e3:	0f b7 44 24 0e       	movzx  eax,WORD PTR [rsp+0xe]
  22c5e8:	66 41 89 47 06       	mov    WORD PTR [r15+0x6],ax
  22c5ed:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  22c5f1:	41 89 47 02          	mov    DWORD PTR [r15+0x2],eax
  22c5f5:	49 89 4f 08          	mov    QWORD PTR [r15+0x8],rcx
  22c5f9:	4d 89 77 10          	mov    QWORD PTR [r15+0x10],r14
  22c5fd:	4c 89 f8             	mov    rax,r15
  22c600:	48 83 c4 10          	add    rsp,0x10
  22c604:	5b                   	pop    rbx
  22c605:	41 5c                	pop    r12
  22c607:	41 5d                	pop    r13
  22c609:	41 5e                	pop    r14
  22c60b:	41 5f                	pop    r15
  22c60d:	c3                   	ret    
            @panic("assertion failure");
  22c60e:	48 8d 3d 7b 37 02 00 	lea    rdi,[rip+0x2377b]        # 24fd90 <__unnamed_2>
  22c615:	e8 06 61 fe ff       	call   212720 <panic>
  22c61a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

000000000022c620 <DirectAllocator_realloc>:
    fn realloc(allocator: *Allocator, old_mem: []u8, new_size: usize, alignment: u29) ![]u8 {
  22c620:	55                   	push   rbp
  22c621:	41 57                	push   r15
  22c623:	41 56                	push   r14
  22c625:	41 55                	push   r13
  22c627:	41 54                	push   r12
  22c629:	53                   	push   rbx
  22c62a:	48 83 ec 28          	sub    rsp,0x28
  22c62e:	45 89 c4             	mov    r12d,r8d
  22c631:	48 89 cb             	mov    rbx,rcx
  22c634:	49 89 d6             	mov    r14,rdx
  22c637:	49 89 ff             	mov    r15,rdi
                if (new_size <= old_mem.len) {
  22c63a:	49 8b 76 08          	mov    rsi,QWORD PTR [r14+0x8]
  22c63e:	48 39 de             	cmp    rsi,rbx
  22c641:	0f 83 c7 00 00 00    	jae    22c70e <DirectAllocator_realloc+0xee>
                const alloc_size = if (alignment <= os.page_size) n else n + alignment;
  22c647:	45 89 e5             	mov    r13d,r12d
  22c64a:	41 81 e5 ff ff ff 1f 	and    r13d,0x1fffffff
  22c651:	31 c0                	xor    eax,eax
  22c653:	41 81 fd 01 10 00 00 	cmp    r13d,0x1001
  22c65a:	4c 89 ed             	mov    rbp,r13
  22c65d:	48 0f 42 e8          	cmovb  rbp,rax
  22c661:	48 8d 74 1d 00       	lea    rsi,[rbp+rbx*1+0x0]
    return asm volatile ("syscall"
  22c666:	b8 09 00 00 00       	mov    eax,0x9
  22c66b:	bf 00 00 00 00       	mov    edi,0x0
  22c670:	ba 03 00 00 00       	mov    edx,0x3
  22c675:	41 ba 22 00 00 00    	mov    r10d,0x22
  22c67b:	49 c7 c0 ff ff ff ff 	mov    r8,0xffffffffffffffff
  22c682:	45 31 c9             	xor    r9d,r9d
  22c685:	0f 05                	syscall 
  22c687:	48 89 c1             	mov    rcx,rax
                if (addr == p.MAP_FAILED) return error.OutOfMemory;
  22c68a:	48 83 f9 ff          	cmp    rcx,0xffffffffffffffff
  22c68e:	0f 84 d2 00 00 00    	je     22c766 <DirectAllocator_realloc+0x146>
                if (alloc_size == n) return @intToPtr([*]u8, addr)[0..n];
  22c694:	48 85 ed             	test   rbp,rbp
  22c697:	74 39                	je     22c6d2 <DirectAllocator_realloc+0xb2>
                const aligned_addr = (addr & ~usize(alignment - 1)) + alignment;
  22c699:	41 81 c4 ff ff ff 1f 	add    r12d,0x1fffffff
  22c6a0:	41 f7 d4             	not    r12d
  22c6a3:	49 81 cc 00 00 00 e0 	or     r12,0xffffffffe0000000
  22c6aa:	49 21 cc             	and    r12,rcx
  22c6ad:	4d 01 ec             	add    r12,r13
                const unused_len = aligned_addr - 1 - unused_start;
  22c6b0:	48 89 ce             	mov    rsi,rcx
  22c6b3:	48 f7 d6             	not    rsi
  22c6b6:	4c 01 e6             	add    rsi,r12
    return asm volatile ("syscall"
  22c6b9:	b8 0b 00 00 00       	mov    eax,0xb
  22c6be:	48 89 cf             	mov    rdi,rcx
  22c6c1:	0f 05                	syscall 
  22c6c3:	4c 89 e1             	mov    rcx,r12
  22c6c6:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
    if (!ok) {
  22c6cc:	0f 83 74 01 00 00    	jae    22c846 <DirectAllocator_realloc+0x226>
    assert(dest.len >= source.len);
  22c6d2:	49 8b 76 08          	mov    rsi,QWORD PTR [r14+0x8]
  22c6d6:	48 89 dd             	mov    rbp,rbx
  22c6d9:	48 39 de             	cmp    rsi,rbx
  22c6dc:	0f 87 64 01 00 00    	ja     22c846 <DirectAllocator_realloc+0x226>
    for (source) |s, i|
  22c6e2:	48 85 f6             	test   rsi,rsi
  22c6e5:	0f 84 29 01 00 00    	je     22c814 <DirectAllocator_realloc+0x1f4>
  22c6eb:	48 8d 56 ff          	lea    rdx,[rsi-0x1]
  22c6ef:	89 f0                	mov    eax,esi
  22c6f1:	83 e0 07             	and    eax,0x7
  22c6f4:	48 83 fa 07          	cmp    rdx,0x7
  22c6f8:	0f 83 88 00 00 00    	jae    22c786 <DirectAllocator_realloc+0x166>
  22c6fe:	31 d2                	xor    edx,edx
  22c700:	48 85 c0             	test   rax,rax
  22c703:	0f 85 f3 00 00 00    	jne    22c7fc <DirectAllocator_realloc+0x1dc>
  22c709:	e9 06 01 00 00       	jmp    22c814 <DirectAllocator_realloc+0x1f4>
                    const base_addr = @ptrToInt(old_mem.ptr);
  22c70e:	49 8b 06             	mov    rax,QWORD PTR [r14]
                    const old_addr_end = base_addr + old_mem.len;
  22c711:	48 01 c6             	add    rsi,rax
                    const new_addr_end = base_addr + new_size;
  22c714:	48 8d 0c 18          	lea    rcx,[rax+rbx*1]
                    const rem = @rem(new_addr_end, os.page_size);
  22c718:	89 ca                	mov    edx,ecx
  22c71a:	81 e2 ff 0f 00 00    	and    edx,0xfff
                    const new_addr_end_rounded = new_addr_end + if (rem == 0) 0 else (os.page_size - rem);
  22c720:	bf 00 10 00 00       	mov    edi,0x1000
  22c725:	48 29 d7             	sub    rdi,rdx
  22c728:	48 85 d2             	test   rdx,rdx
  22c72b:	48 0f 44 fa          	cmove  rdi,rdx
  22c72f:	48 01 cf             	add    rdi,rcx
                    if (old_addr_end > new_addr_end_rounded) {
  22c732:	48 29 fe             	sub    rsi,rdi
  22c735:	76 0a                	jbe    22c741 <DirectAllocator_realloc+0x121>
  22c737:	b8 0b 00 00 00       	mov    eax,0xb
  22c73c:	0f 05                	syscall 
                    return old_mem[0..new_size];
  22c73e:	49 8b 06             	mov    rax,QWORD PTR [r14]
  22c741:	66 41 c7 07 00 00    	mov    WORD PTR [r15],0x0
  22c747:	0f b7 4c 24 10       	movzx  ecx,WORD PTR [rsp+0x10]
  22c74c:	66 41 89 4f 06       	mov    WORD PTR [r15+0x6],cx
  22c751:	8b 4c 24 0c          	mov    ecx,DWORD PTR [rsp+0xc]
  22c755:	41 89 4f 02          	mov    DWORD PTR [r15+0x2],ecx
  22c759:	49 89 47 08          	mov    QWORD PTR [r15+0x8],rax
  22c75d:	49 89 5f 10          	mov    QWORD PTR [r15+0x10],rbx
  22c761:	e9 ce 00 00 00       	jmp    22c834 <DirectAllocator_realloc+0x214>
                const result = try alloc(allocator, new_size, alignment);
  22c766:	66 41 c7 07 01 00    	mov    WORD PTR [r15],0x1
  22c76c:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
  22c771:	49 89 47 10          	mov    QWORD PTR [r15+0x10],rax
  22c775:	c5 f8 10 44 24 12    	vmovups xmm0,XMMWORD PTR [rsp+0x12]
  22c77b:	c4 c1 78 11 47 02    	vmovups XMMWORD PTR [r15+0x2],xmm0
  22c781:	e9 ae 00 00 00       	jmp    22c834 <DirectAllocator_realloc+0x214>
  22c786:	48 29 c6             	sub    rsi,rax
  22c789:	31 d2                	xor    edx,edx
  22c78b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  22c790:	49 8b 3e             	mov    rdi,QWORD PTR [r14]
  22c793:	0f b6 1c 17          	movzx  ebx,BYTE PTR [rdi+rdx*1]
        dest[i] = s;
  22c797:	88 1c 11             	mov    BYTE PTR [rcx+rdx*1],bl
    for (source) |s, i|
  22c79a:	49 8b 3e             	mov    rdi,QWORD PTR [r14]
  22c79d:	0f b6 5c 17 01       	movzx  ebx,BYTE PTR [rdi+rdx*1+0x1]
        dest[i] = s;
  22c7a2:	88 5c 11 01          	mov    BYTE PTR [rcx+rdx*1+0x1],bl
    for (source) |s, i|
  22c7a6:	49 8b 3e             	mov    rdi,QWORD PTR [r14]
  22c7a9:	0f b6 5c 17 02       	movzx  ebx,BYTE PTR [rdi+rdx*1+0x2]
        dest[i] = s;
  22c7ae:	88 5c 11 02          	mov    BYTE PTR [rcx+rdx*1+0x2],bl
    for (source) |s, i|
  22c7b2:	49 8b 3e             	mov    rdi,QWORD PTR [r14]
  22c7b5:	0f b6 5c 17 03       	movzx  ebx,BYTE PTR [rdi+rdx*1+0x3]
        dest[i] = s;
  22c7ba:	88 5c 11 03          	mov    BYTE PTR [rcx+rdx*1+0x3],bl
    for (source) |s, i|
  22c7be:	49 8b 3e             	mov    rdi,QWORD PTR [r14]
  22c7c1:	0f b6 5c 17 04       	movzx  ebx,BYTE PTR [rdi+rdx*1+0x4]
        dest[i] = s;
  22c7c6:	88 5c 11 04          	mov    BYTE PTR [rcx+rdx*1+0x4],bl
    for (source) |s, i|
  22c7ca:	49 8b 3e             	mov    rdi,QWORD PTR [r14]
  22c7cd:	0f b6 5c 17 05       	movzx  ebx,BYTE PTR [rdi+rdx*1+0x5]
        dest[i] = s;
  22c7d2:	88 5c 11 05          	mov    BYTE PTR [rcx+rdx*1+0x5],bl
    for (source) |s, i|
  22c7d6:	49 8b 3e             	mov    rdi,QWORD PTR [r14]
  22c7d9:	0f b6 5c 17 06       	movzx  ebx,BYTE PTR [rdi+rdx*1+0x6]
        dest[i] = s;
  22c7de:	88 5c 11 06          	mov    BYTE PTR [rcx+rdx*1+0x6],bl
    for (source) |s, i|
  22c7e2:	49 8b 3e             	mov    rdi,QWORD PTR [r14]
  22c7e5:	0f b6 5c 17 07       	movzx  ebx,BYTE PTR [rdi+rdx*1+0x7]
        dest[i] = s;
  22c7ea:	88 5c 11 07          	mov    BYTE PTR [rcx+rdx*1+0x7],bl
    for (source) |s, i|
  22c7ee:	48 83 c2 08          	add    rdx,0x8
  22c7f2:	48 39 d6             	cmp    rsi,rdx
  22c7f5:	75 99                	jne    22c790 <DirectAllocator_realloc+0x170>
  22c7f7:	48 85 c0             	test   rax,rax
  22c7fa:	74 18                	je     22c814 <DirectAllocator_realloc+0x1f4>
  22c7fc:	48 f7 d8             	neg    rax
  22c7ff:	90                   	nop
  22c800:	49 8b 36             	mov    rsi,QWORD PTR [r14]
  22c803:	0f b6 1c 16          	movzx  ebx,BYTE PTR [rsi+rdx*1]
        dest[i] = s;
  22c807:	88 1c 11             	mov    BYTE PTR [rcx+rdx*1],bl
    for (source) |s, i|
  22c80a:	48 83 c2 01          	add    rdx,0x1
  22c80e:	48 83 c0 01          	add    rax,0x1
  22c812:	75 ec                	jne    22c800 <DirectAllocator_realloc+0x1e0>
                return result;
  22c814:	66 41 c7 07 00 00    	mov    WORD PTR [r15],0x0
  22c81a:	0f b7 44 24 0a       	movzx  eax,WORD PTR [rsp+0xa]
  22c81f:	66 41 89 47 06       	mov    WORD PTR [r15+0x6],ax
  22c824:	8b 44 24 06          	mov    eax,DWORD PTR [rsp+0x6]
  22c828:	41 89 47 02          	mov    DWORD PTR [r15+0x2],eax
  22c82c:	49 89 4f 08          	mov    QWORD PTR [r15+0x8],rcx
  22c830:	49 89 6f 10          	mov    QWORD PTR [r15+0x10],rbp
  22c834:	4c 89 f8             	mov    rax,r15
  22c837:	48 83 c4 28          	add    rsp,0x28
  22c83b:	5b                   	pop    rbx
  22c83c:	41 5c                	pop    r12
  22c83e:	41 5d                	pop    r13
  22c840:	41 5e                	pop    r14
  22c842:	41 5f                	pop    r15
  22c844:	5d                   	pop    rbp
  22c845:	c3                   	ret    
            @panic("assertion failure");
  22c846:	48 8d 3d 43 35 02 00 	lea    rdi,[rip+0x23543]        # 24fd90 <__unnamed_2>
  22c84d:	e8 ce 5e fe ff       	call   212720 <panic>
  22c852:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  22c859:	1f 84 00 00 00 00 00 

000000000022c860 <DirectAllocator_free>:
                _ = os.posix.munmap(@ptrToInt(bytes.ptr), bytes.len);
  22c860:	48 8b 3e             	mov    rdi,QWORD PTR [rsi]
  22c863:	48 8b 76 08          	mov    rsi,QWORD PTR [rsi+0x8]
  22c867:	b8 0b 00 00 00       	mov    eax,0xb
  22c86c:	0f 05                	syscall 
    fn free(allocator: *Allocator, bytes: []u8) void {
  22c86e:	c3                   	ret    
  22c86f:	90                   	nop

000000000022c870 <ArenaAllocator_alloc>:
    fn alloc(allocator: *Allocator, n: usize, alignment: u29) ![]u8 {
  22c870:	55                   	push   rbp
  22c871:	41 57                	push   r15
  22c873:	41 56                	push   r14
  22c875:	41 55                	push   r13
  22c877:	41 54                	push   r12
  22c879:	53                   	push   rbx
  22c87a:	48 83 ec 58          	sub    rsp,0x58
  22c87e:	89 cb                	mov    ebx,ecx
  22c880:	49 89 d7             	mov    r15,rdx
  22c883:	49 89 f4             	mov    r12,rsi
  22c886:	49 89 fe             	mov    r14,rdi
        var cur_node = if (self.buffer_list.last) |last_node| last_node else try self.createNode(0, n + alignment);
  22c889:	49 8b 44 24 28       	mov    rax,QWORD PTR [r12+0x28]
  22c88e:	81 e3 ff ff ff 1f    	and    ebx,0x1fffffff
  22c894:	4e 8d 2c 3b          	lea    r13,[rbx+r15*1]
  22c898:	48 85 c0             	test   rax,rax
  22c89b:	74 29                	je     22c8c6 <ArenaAllocator_alloc+0x56>
            const cur_buf = cur_node.data[@sizeOf(BufNode)..];
  22c89d:	48 8b 70 10          	mov    rsi,QWORD PTR [rax+0x10]
  22c8a1:	48 8b 48 18          	mov    rcx,QWORD PTR [rax+0x18]
  22c8a5:	48 83 c1 e0          	add    rcx,0xffffffffffffffe0
            const addr = @ptrToInt(cur_buf.ptr) + self.end_index;
  22c8a9:	49 8b 7c 24 38       	mov    rdi,QWORD PTR [r12+0x38]
  22c8ae:	48 8d 04 37          	lea    rax,[rdi+rsi*1]
  22c8b2:	48 83 c0 20          	add    rax,0x20
  22c8b6:	48 89 c2             	mov    rdx,rax
  22c8b9:	48 c1 ea 20          	shr    rdx,0x20
  22c8bd:	74 3f                	je     22c8fe <ArenaAllocator_alloc+0x8e>
  22c8bf:	31 d2                	xor    edx,edx
  22c8c1:	48 f7 f3             	div    rbx
  22c8c4:	eb 3c                	jmp    22c902 <ArenaAllocator_alloc+0x92>
  22c8c6:	48 8d 7c 24 18       	lea    rdi,[rsp+0x18]
        var cur_node = if (self.buffer_list.last) |last_node| last_node else try self.createNode(0, n + alignment);
  22c8cb:	31 d2                	xor    edx,edx
  22c8cd:	4c 89 e6             	mov    rsi,r12
  22c8d0:	4c 89 e9             	mov    rcx,r13
  22c8d3:	e8 78 03 00 00       	call   22cc50 <ArenaAllocator_createNode>
  22c8d8:	0f b7 44 24 18       	movzx  eax,WORD PTR [rsp+0x18]
  22c8dd:	66 85 c0             	test   ax,ax
  22c8e0:	0f 84 fe 00 00 00    	je     22c9e4 <ArenaAllocator_alloc+0x174>
  22c8e6:	66 41 89 06          	mov    WORD PTR [r14],ax
  22c8ea:	48 8b 44 24 50       	mov    rax,QWORD PTR [rsp+0x50]
  22c8ef:	49 89 46 10          	mov    QWORD PTR [r14+0x10],rax
  22c8f3:	c5 f8 10 44 24 42    	vmovups xmm0,XMMWORD PTR [rsp+0x42]
  22c8f9:	e9 ce 00 00 00       	jmp    22c9cc <ArenaAllocator_alloc+0x15c>
  22c8fe:	31 d2                	xor    edx,edx
  22c900:	f7 f3                	div    ebx
            const march_forward_bytes = if (rem == 0) 0 else (alignment - rem);
  22c902:	48 89 d8             	mov    rax,rbx
  22c905:	48 29 d0             	sub    rax,rdx
  22c908:	48 85 d2             	test   rdx,rdx
  22c90b:	48 0f 44 c2          	cmove  rax,rdx
            const adjusted_index = self.end_index + march_forward_bytes;
  22c90f:	48 01 f8             	add    rax,rdi
            const new_end_index = adjusted_index + n;
  22c912:	4a 8d 14 38          	lea    rdx,[rax+r15*1]
            if (new_end_index > cur_buf.len) {
  22c916:	48 39 ca             	cmp    rdx,rcx
  22c919:	76 72                	jbe    22c98d <ArenaAllocator_alloc+0x11d>
  22c91b:	48 8d 6c 24 08       	lea    rbp,[rsp+0x8]
                cur_node = try self.createNode(cur_buf.len, n + alignment);
  22c920:	48 89 ef             	mov    rdi,rbp
  22c923:	4c 89 e6             	mov    rsi,r12
  22c926:	48 89 ca             	mov    rdx,rcx
  22c929:	4c 89 e9             	mov    rcx,r13
  22c92c:	e8 1f 03 00 00       	call   22cc50 <ArenaAllocator_createNode>
  22c931:	0f b7 44 24 08       	movzx  eax,WORD PTR [rsp+0x8]
  22c936:	66 85 c0             	test   ax,ax
  22c939:	75 7e                	jne    22c9b9 <ArenaAllocator_alloc+0x149>
  22c93b:	48 8b 44 24 10       	mov    rax,QWORD PTR [rsp+0x10]
            const cur_buf = cur_node.data[@sizeOf(BufNode)..];
  22c940:	48 8b 70 10          	mov    rsi,QWORD PTR [rax+0x10]
  22c944:	48 8b 48 18          	mov    rcx,QWORD PTR [rax+0x18]
  22c948:	48 83 c1 e0          	add    rcx,0xffffffffffffffe0
            const addr = @ptrToInt(cur_buf.ptr) + self.end_index;
  22c94c:	49 8b 7c 24 38       	mov    rdi,QWORD PTR [r12+0x38]
  22c951:	48 8d 04 37          	lea    rax,[rdi+rsi*1]
  22c955:	48 83 c0 20          	add    rax,0x20
  22c959:	48 89 c2             	mov    rdx,rax
  22c95c:	48 c1 ea 20          	shr    rdx,0x20
  22c960:	74 0e                	je     22c970 <ArenaAllocator_alloc+0x100>
  22c962:	31 d2                	xor    edx,edx
  22c964:	48 f7 f3             	div    rbx
  22c967:	eb 0b                	jmp    22c974 <ArenaAllocator_alloc+0x104>
  22c969:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  22c970:	31 d2                	xor    edx,edx
  22c972:	f7 f3                	div    ebx
            const march_forward_bytes = if (rem == 0) 0 else (alignment - rem);
  22c974:	48 89 d8             	mov    rax,rbx
  22c977:	48 29 d0             	sub    rax,rdx
  22c97a:	48 85 d2             	test   rdx,rdx
  22c97d:	48 0f 44 c2          	cmove  rax,rdx
            const adjusted_index = self.end_index + march_forward_bytes;
  22c981:	48 01 f8             	add    rax,rdi
            const new_end_index = adjusted_index + n;
  22c984:	4a 8d 14 38          	lea    rdx,[rax+r15*1]
            if (new_end_index > cur_buf.len) {
  22c988:	48 39 ca             	cmp    rdx,rcx
  22c98b:	77 93                	ja     22c920 <ArenaAllocator_alloc+0xb0>
            self.end_index = new_end_index;
  22c98d:	49 89 54 24 38       	mov    QWORD PTR [r12+0x38],rdx
            return result;
  22c992:	66 41 c7 06 00 00    	mov    WORD PTR [r14],0x0
  22c998:	0f b7 4c 24 06       	movzx  ecx,WORD PTR [rsp+0x6]
  22c99d:	66 41 89 4e 06       	mov    WORD PTR [r14+0x6],cx
            const result = cur_buf[adjusted_index..new_end_index];
  22c9a2:	48 8d 44 06 20       	lea    rax,[rsi+rax*1+0x20]
            return result;
  22c9a7:	8b 4c 24 02          	mov    ecx,DWORD PTR [rsp+0x2]
  22c9ab:	41 89 4e 02          	mov    DWORD PTR [r14+0x2],ecx
  22c9af:	49 89 46 08          	mov    QWORD PTR [r14+0x8],rax
  22c9b3:	4d 89 7e 10          	mov    QWORD PTR [r14+0x10],r15
  22c9b7:	eb 19                	jmp    22c9d2 <ArenaAllocator_alloc+0x162>
                cur_node = try self.createNode(cur_buf.len, n + alignment);
  22c9b9:	66 41 89 06          	mov    WORD PTR [r14],ax
  22c9bd:	48 8b 44 24 3a       	mov    rax,QWORD PTR [rsp+0x3a]
  22c9c2:	49 89 46 10          	mov    QWORD PTR [r14+0x10],rax
  22c9c6:	c5 f8 10 44 24 2c    	vmovups xmm0,XMMWORD PTR [rsp+0x2c]
  22c9cc:	c4 c1 78 11 46 02    	vmovups XMMWORD PTR [r14+0x2],xmm0
  22c9d2:	4c 89 f0             	mov    rax,r14
  22c9d5:	48 83 c4 58          	add    rsp,0x58
  22c9d9:	5b                   	pop    rbx
  22c9da:	41 5c                	pop    r12
  22c9dc:	41 5d                	pop    r13
  22c9de:	41 5e                	pop    r14
  22c9e0:	41 5f                	pop    r15
  22c9e2:	5d                   	pop    rbp
  22c9e3:	c3                   	ret    
        var cur_node = if (self.buffer_list.last) |last_node| last_node else try self.createNode(0, n + alignment);
  22c9e4:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
  22c9e9:	e9 af fe ff ff       	jmp    22c89d <ArenaAllocator_alloc+0x2d>
  22c9ee:	66 90                	xchg   ax,ax

000000000022c9f0 <ArenaAllocator_realloc>:
    fn realloc(allocator: *Allocator, old_mem: []u8, new_size: usize, alignment: u29) ![]u8 {
  22c9f0:	55                   	push   rbp
  22c9f1:	41 57                	push   r15
  22c9f3:	41 56                	push   r14
  22c9f5:	41 55                	push   r13
  22c9f7:	41 54                	push   r12
  22c9f9:	53                   	push   rbx
  22c9fa:	48 83 ec 58          	sub    rsp,0x58
  22c9fe:	45 89 c5             	mov    r13d,r8d
  22ca01:	49 89 cf             	mov    r15,rcx
  22ca04:	48 89 d3             	mov    rbx,rdx
  22ca07:	49 89 f4             	mov    r12,rsi
  22ca0a:	48 89 fd             	mov    rbp,rdi
        if (new_size <= old_mem.len) {
  22ca0d:	4c 39 7b 08          	cmp    QWORD PTR [rbx+0x8],r15
  22ca11:	73 43                	jae    22ca56 <ArenaAllocator_realloc+0x66>
        var cur_node = if (self.buffer_list.last) |last_node| last_node else try self.createNode(0, n + alignment);
  22ca13:	49 8b 44 24 28       	mov    rax,QWORD PTR [r12+0x28]
  22ca18:	41 81 e5 ff ff ff 1f 	and    r13d,0x1fffffff
  22ca1f:	4f 8d 34 2f          	lea    r14,[r15+r13*1]
  22ca23:	48 85 c0             	test   rax,rax
  22ca26:	74 54                	je     22ca7c <ArenaAllocator_realloc+0x8c>
            const cur_buf = cur_node.data[@sizeOf(BufNode)..];
  22ca28:	48 8b 70 10          	mov    rsi,QWORD PTR [rax+0x10]
  22ca2c:	48 8b 48 18          	mov    rcx,QWORD PTR [rax+0x18]
  22ca30:	48 83 c1 e0          	add    rcx,0xffffffffffffffe0
            const addr = @ptrToInt(cur_buf.ptr) + self.end_index;
  22ca34:	49 8b 7c 24 38       	mov    rdi,QWORD PTR [r12+0x38]
  22ca39:	48 8d 04 37          	lea    rax,[rdi+rsi*1]
  22ca3d:	48 83 c0 20          	add    rax,0x20
  22ca41:	48 89 c2             	mov    rdx,rax
  22ca44:	48 c1 ea 20          	shr    rdx,0x20
  22ca48:	48 89 6c 24 08       	mov    QWORD PTR [rsp+0x8],rbp
  22ca4d:	75 77                	jne    22cac6 <ArenaAllocator_realloc+0xd6>
  22ca4f:	31 d2                	xor    edx,edx
  22ca51:	41 f7 f5             	div    r13d
  22ca54:	eb 75                	jmp    22cacb <ArenaAllocator_realloc+0xdb>
            return old_mem[0..new_size];
  22ca56:	48 8b 03             	mov    rax,QWORD PTR [rbx]
  22ca59:	66 c7 45 00 00 00    	mov    WORD PTR [rbp+0x0],0x0
  22ca5f:	0f b7 4c 24 1e       	movzx  ecx,WORD PTR [rsp+0x1e]
  22ca64:	66 89 4d 06          	mov    WORD PTR [rbp+0x6],cx
  22ca68:	8b 4c 24 1a          	mov    ecx,DWORD PTR [rsp+0x1a]
  22ca6c:	89 4d 02             	mov    DWORD PTR [rbp+0x2],ecx
  22ca6f:	48 89 45 08          	mov    QWORD PTR [rbp+0x8],rax
  22ca73:	4c 89 7d 10          	mov    QWORD PTR [rbp+0x10],r15
  22ca77:	e9 a2 00 00 00       	jmp    22cb1e <ArenaAllocator_realloc+0x12e>
  22ca7c:	48 8d 7c 24 30       	lea    rdi,[rsp+0x30]
        var cur_node = if (self.buffer_list.last) |last_node| last_node else try self.createNode(0, n + alignment);
  22ca81:	31 d2                	xor    edx,edx
  22ca83:	4c 89 e6             	mov    rsi,r12
  22ca86:	4c 89 f1             	mov    rcx,r14
  22ca89:	e8 c2 01 00 00       	call   22cc50 <ArenaAllocator_createNode>
  22ca8e:	0f b7 44 24 30       	movzx  eax,WORD PTR [rsp+0x30]
  22ca93:	66 85 c0             	test   ax,ax
  22ca96:	75 6e                	jne    22cb06 <ArenaAllocator_realloc+0x116>
  22ca98:	48 8b 44 24 38       	mov    rax,QWORD PTR [rsp+0x38]
  22ca9d:	eb 89                	jmp    22ca28 <ArenaAllocator_realloc+0x38>
                cur_node = try self.createNode(cur_buf.len, n + alignment);
  22ca9f:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
            const cur_buf = cur_node.data[@sizeOf(BufNode)..];
  22caa4:	48 8b 70 10          	mov    rsi,QWORD PTR [rax+0x10]
  22caa8:	48 8b 48 18          	mov    rcx,QWORD PTR [rax+0x18]
  22caac:	48 83 c1 e0          	add    rcx,0xffffffffffffffe0
            const addr = @ptrToInt(cur_buf.ptr) + self.end_index;
  22cab0:	49 8b 7c 24 38       	mov    rdi,QWORD PTR [r12+0x38]
  22cab5:	48 8d 04 37          	lea    rax,[rdi+rsi*1]
  22cab9:	48 83 c0 20          	add    rax,0x20
  22cabd:	48 89 c2             	mov    rdx,rax
  22cac0:	48 c1 ea 20          	shr    rdx,0x20
  22cac4:	74 89                	je     22ca4f <ArenaAllocator_realloc+0x5f>
  22cac6:	31 d2                	xor    edx,edx
  22cac8:	49 f7 f5             	div    r13
            const march_forward_bytes = if (rem == 0) 0 else (alignment - rem);
  22cacb:	4c 89 ed             	mov    rbp,r13
  22cace:	48 29 d5             	sub    rbp,rdx
  22cad1:	48 85 d2             	test   rdx,rdx
  22cad4:	48 0f 44 ea          	cmove  rbp,rdx
            const adjusted_index = self.end_index + march_forward_bytes;
  22cad8:	48 01 fd             	add    rbp,rdi
            const new_end_index = adjusted_index + n;
  22cadb:	49 8d 04 2f          	lea    rax,[r15+rbp*1]
            if (new_end_index > cur_buf.len) {
  22cadf:	48 39 c8             	cmp    rax,rcx
  22cae2:	76 42                	jbe    22cb26 <ArenaAllocator_realloc+0x136>
                cur_node = try self.createNode(cur_buf.len, n + alignment);
  22cae4:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  22cae9:	4c 89 e6             	mov    rsi,r12
  22caec:	48 89 ca             	mov    rdx,rcx
  22caef:	4c 89 f1             	mov    rcx,r14
  22caf2:	e8 59 01 00 00       	call   22cc50 <ArenaAllocator_createNode>
  22caf7:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  22cafc:	66 85 c0             	test   ax,ax
  22caff:	74 9e                	je     22ca9f <ArenaAllocator_realloc+0xaf>
  22cb01:	48 8b 6c 24 08       	mov    rbp,QWORD PTR [rsp+0x8]
            const result = try alloc(allocator, new_size, alignment);
  22cb06:	66 89 45 00          	mov    WORD PTR [rbp+0x0],ax
  22cb0a:	48 8b 44 24 50       	mov    rax,QWORD PTR [rsp+0x50]
  22cb0f:	48 89 45 10          	mov    QWORD PTR [rbp+0x10],rax
  22cb13:	c5 f8 10 44 24 42    	vmovups xmm0,XMMWORD PTR [rsp+0x42]
  22cb19:	c5 f8 11 45 02       	vmovups XMMWORD PTR [rbp+0x2],xmm0
  22cb1e:	48 89 e8             	mov    rax,rbp
  22cb21:	e9 f1 00 00 00       	jmp    22cc17 <ArenaAllocator_realloc+0x227>
            self.end_index = new_end_index;
  22cb26:	49 89 44 24 38       	mov    QWORD PTR [r12+0x38],rax
    assert(dest.len >= source.len);
  22cb2b:	48 8b 7b 08          	mov    rdi,QWORD PTR [rbx+0x8]
  22cb2f:	4c 39 ff             	cmp    rdi,r15
    if (!ok) {
  22cb32:	0f 87 ee 00 00 00    	ja     22cc26 <ArenaAllocator_realloc+0x236>
  22cb38:	4c 8d 04 2e          	lea    r8,[rsi+rbp*1]
  22cb3c:	49 83 c0 20          	add    r8,0x20
    for (source) |s, i|
  22cb40:	48 85 ff             	test   rdi,rdi
  22cb43:	0f 84 ac 00 00 00    	je     22cbf5 <ArenaAllocator_realloc+0x205>
  22cb49:	48 8d 57 ff          	lea    rdx,[rdi-0x1]
  22cb4d:	89 f9                	mov    ecx,edi
  22cb4f:	83 e1 07             	and    ecx,0x7
  22cb52:	48 83 fa 07          	cmp    rdx,0x7
  22cb56:	73 0c                	jae    22cb64 <ArenaAllocator_realloc+0x174>
  22cb58:	31 d2                	xor    edx,edx
  22cb5a:	48 85 c9             	test   rcx,rcx
  22cb5d:	75 7e                	jne    22cbdd <ArenaAllocator_realloc+0x1ed>
  22cb5f:	e9 91 00 00 00       	jmp    22cbf5 <ArenaAllocator_realloc+0x205>
  22cb64:	48 29 cf             	sub    rdi,rcx
  22cb67:	48 01 ee             	add    rsi,rbp
  22cb6a:	48 83 c6 27          	add    rsi,0x27
  22cb6e:	31 d2                	xor    edx,edx
  22cb70:	48 8b 2b             	mov    rbp,QWORD PTR [rbx]
  22cb73:	0f b6 44 15 00       	movzx  eax,BYTE PTR [rbp+rdx*1+0x0]
        dest[i] = s;
  22cb78:	88 44 16 f9          	mov    BYTE PTR [rsi+rdx*1-0x7],al
    for (source) |s, i|
  22cb7c:	48 8b 03             	mov    rax,QWORD PTR [rbx]
  22cb7f:	0f b6 44 10 01       	movzx  eax,BYTE PTR [rax+rdx*1+0x1]
        dest[i] = s;
  22cb84:	88 44 16 fa          	mov    BYTE PTR [rsi+rdx*1-0x6],al
    for (source) |s, i|
  22cb88:	48 8b 03             	mov    rax,QWORD PTR [rbx]
  22cb8b:	0f b6 44 10 02       	movzx  eax,BYTE PTR [rax+rdx*1+0x2]
        dest[i] = s;
  22cb90:	88 44 16 fb          	mov    BYTE PTR [rsi+rdx*1-0x5],al
    for (source) |s, i|
  22cb94:	48 8b 03             	mov    rax,QWORD PTR [rbx]
  22cb97:	0f b6 44 10 03       	movzx  eax,BYTE PTR [rax+rdx*1+0x3]
        dest[i] = s;
  22cb9c:	88 44 16 fc          	mov    BYTE PTR [rsi+rdx*1-0x4],al
    for (source) |s, i|
  22cba0:	48 8b 03             	mov    rax,QWORD PTR [rbx]
  22cba3:	0f b6 44 10 04       	movzx  eax,BYTE PTR [rax+rdx*1+0x4]
        dest[i] = s;
  22cba8:	88 44 16 fd          	mov    BYTE PTR [rsi+rdx*1-0x3],al
    for (source) |s, i|
  22cbac:	48 8b 03             	mov    rax,QWORD PTR [rbx]
  22cbaf:	0f b6 44 10 05       	movzx  eax,BYTE PTR [rax+rdx*1+0x5]
        dest[i] = s;
  22cbb4:	88 44 16 fe          	mov    BYTE PTR [rsi+rdx*1-0x2],al
    for (source) |s, i|
  22cbb8:	48 8b 03             	mov    rax,QWORD PTR [rbx]
  22cbbb:	0f b6 44 10 06       	movzx  eax,BYTE PTR [rax+rdx*1+0x6]
        dest[i] = s;
  22cbc0:	88 44 16 ff          	mov    BYTE PTR [rsi+rdx*1-0x1],al
    for (source) |s, i|
  22cbc4:	48 8b 03             	mov    rax,QWORD PTR [rbx]
  22cbc7:	0f b6 44 10 07       	movzx  eax,BYTE PTR [rax+rdx*1+0x7]
        dest[i] = s;
  22cbcc:	88 04 16             	mov    BYTE PTR [rsi+rdx*1],al
    for (source) |s, i|
  22cbcf:	48 83 c2 08          	add    rdx,0x8
  22cbd3:	48 39 d7             	cmp    rdi,rdx
  22cbd6:	75 98                	jne    22cb70 <ArenaAllocator_realloc+0x180>
  22cbd8:	48 85 c9             	test   rcx,rcx
  22cbdb:	74 18                	je     22cbf5 <ArenaAllocator_realloc+0x205>
  22cbdd:	48 f7 d9             	neg    rcx
  22cbe0:	48 8b 03             	mov    rax,QWORD PTR [rbx]
  22cbe3:	0f b6 04 10          	movzx  eax,BYTE PTR [rax+rdx*1]
        dest[i] = s;
  22cbe7:	41 88 04 10          	mov    BYTE PTR [r8+rdx*1],al
    for (source) |s, i|
  22cbeb:	48 83 c2 01          	add    rdx,0x1
  22cbef:	48 83 c1 01          	add    rcx,0x1
  22cbf3:	75 eb                	jne    22cbe0 <ArenaAllocator_realloc+0x1f0>
  22cbf5:	48 8b 44 24 08       	mov    rax,QWORD PTR [rsp+0x8]
            return result;
  22cbfa:	66 c7 00 00 00       	mov    WORD PTR [rax],0x0
  22cbff:	0f b7 4c 24 18       	movzx  ecx,WORD PTR [rsp+0x18]
  22cc04:	66 89 48 06          	mov    WORD PTR [rax+0x6],cx
  22cc08:	8b 4c 24 14          	mov    ecx,DWORD PTR [rsp+0x14]
  22cc0c:	89 48 02             	mov    DWORD PTR [rax+0x2],ecx
  22cc0f:	4c 89 40 08          	mov    QWORD PTR [rax+0x8],r8
  22cc13:	4c 89 78 10          	mov    QWORD PTR [rax+0x10],r15
  22cc17:	48 83 c4 58          	add    rsp,0x58
  22cc1b:	5b                   	pop    rbx
  22cc1c:	41 5c                	pop    r12
  22cc1e:	41 5d                	pop    r13
  22cc20:	41 5e                	pop    r14
  22cc22:	41 5f                	pop    r15
  22cc24:	5d                   	pop    rbp
  22cc25:	c3                   	ret    
            @panic("assertion failure");
  22cc26:	48 8d 3d 63 31 02 00 	lea    rdi,[rip+0x23163]        # 24fd90 <__unnamed_2>
  22cc2d:	e8 ee 5a fe ff       	call   212720 <panic>
  22cc32:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  22cc39:	1f 84 00 00 00 00 00 

000000000022cc40 <ArenaAllocator_free>:
    fn free(allocator: *Allocator, bytes: []u8) void {}
  22cc40:	c3                   	ret    
  22cc41:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  22cc48:	0f 1f 84 00 00 00 00 
  22cc4f:	00 

000000000022cc50 <ArenaAllocator_createNode>:
    fn createNode(self: *ArenaAllocator, prev_len: usize, minimum_size: usize) !*BufNode {
  22cc50:	41 57                	push   r15
  22cc52:	41 56                	push   r14
  22cc54:	53                   	push   rbx
  22cc55:	48 83 ec 30          	sub    rsp,0x30
  22cc59:	48 89 d3             	mov    rbx,rdx
  22cc5c:	49 89 f6             	mov    r14,rsi
  22cc5f:	49 89 ff             	mov    r15,rdi
        const actual_min_size = minimum_size + @sizeOf(BufNode);
  22cc62:	48 83 c1 20          	add    rcx,0x20
  22cc66:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  22cc6d:	00 00 00 
            len += len / 2;
  22cc70:	48 89 d8             	mov    rax,rbx
  22cc73:	48 d1 e8             	shr    rax,1
  22cc76:	48 01 d8             	add    rax,rbx
            len += os.page_size - @rem(len, os.page_size);
  22cc79:	89 c2                	mov    edx,eax
  22cc7b:	81 e2 ff 0f 00 00    	and    edx,0xfff
  22cc81:	bb 00 10 00 00       	mov    ebx,0x1000
  22cc86:	48 29 d3             	sub    rbx,rdx
  22cc89:	48 01 c3             	add    rbx,rax
            if (len >= actual_min_size) break;
  22cc8c:	48 39 cb             	cmp    rbx,rcx
  22cc8f:	72 df                	jb     22cc70 <ArenaAllocator_createNode+0x20>
        if (n == 0) {
  22cc91:	48 85 db             	test   rbx,rbx
  22cc94:	74 38                	je     22ccce <ArenaAllocator_createNode+0x7e>
  22cc96:	49 8b 76 18          	mov    rsi,QWORD PTR [r14+0x18]
  22cc9a:	48 8d 7c 24 08       	lea    rdi,[rsp+0x8]
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  22cc9f:	b9 08 00 00 00       	mov    ecx,0x8
  22cca4:	48 89 da             	mov    rdx,rbx
  22cca7:	ff 16                	call   QWORD PTR [rsi]
  22cca9:	0f b7 44 24 08       	movzx  eax,WORD PTR [rsp+0x8]
  22ccae:	66 85 c0             	test   ax,ax
  22ccb1:	74 1f                	je     22ccd2 <ArenaAllocator_createNode+0x82>
        const buf = try self.child_allocator.alignedAlloc(u8, @alignOf(BufNode), len);
  22ccb3:	66 41 89 07          	mov    WORD PTR [r15],ax
  22ccb7:	48 8b 44 24 22       	mov    rax,QWORD PTR [rsp+0x22]
  22ccbc:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  22ccc1:	49 89 4f 08          	mov    QWORD PTR [r15+0x8],rcx
  22ccc5:	49 89 47 02          	mov    QWORD PTR [r15+0x2],rax
  22ccc9:	e9 c6 00 00 00       	jmp    22cd94 <ArenaAllocator_createNode+0x144>
  22ccce:	31 db                	xor    ebx,ebx
  22ccd0:	eb 10                	jmp    22cce2 <ArenaAllocator_createNode+0x92>
        assert(byte_slice.len == byte_count);
  22ccd2:	48 39 5c 24 18       	cmp    QWORD PTR [rsp+0x18],rbx
    if (!ok) {
  22ccd7:	0f 85 c1 00 00 00    	jne    22cd9e <ArenaAllocator_createNode+0x14e>
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  22ccdd:	48 8b 44 24 10       	mov    rax,QWORD PTR [rsp+0x10]
        buf_node.* = BufNode{
  22cce2:	c5 f8 57 c0          	vxorps xmm0,xmm0,xmm0
  22cce6:	c5 f8 11 00          	vmovups XMMWORD PTR [rax],xmm0
  22ccea:	48 89 40 10          	mov    QWORD PTR [rax+0x10],rax
  22ccee:	48 89 58 18          	mov    QWORD PTR [rax+0x18],rbx
            if (list.last) |last| {
  22ccf2:	49 8b 4e 28          	mov    rcx,QWORD PTR [r14+0x28]
  22ccf6:	48 85 c9             	test   rcx,rcx
  22ccf9:	74 12                	je     22cd0d <ArenaAllocator_createNode+0xbd>
            new_node.prev = node;
  22ccfb:	48 89 08             	mov    QWORD PTR [rax],rcx
            if (node.next) |next_node| {
  22ccfe:	48 8b 51 08          	mov    rdx,QWORD PTR [rcx+0x8]
  22cd02:	48 85 d2             	test   rdx,rdx
  22cd05:	74 24                	je     22cd2b <ArenaAllocator_createNode+0xdb>
                new_node.next = next_node;
  22cd07:	48 89 50 08          	mov    QWORD PTR [rax+0x8],rdx
  22cd0b:	eb 2a                	jmp    22cd37 <ArenaAllocator_createNode+0xe7>
            if (list.first) |first| {
  22cd0d:	49 8b 4e 20          	mov    rcx,QWORD PTR [r14+0x20]
  22cd11:	48 85 c9             	test   rcx,rcx
  22cd14:	74 2a                	je     22cd40 <ArenaAllocator_createNode+0xf0>
            new_node.next = node;
  22cd16:	48 89 48 08          	mov    QWORD PTR [rax+0x8],rcx
            if (node.prev) |prev_node| {
  22cd1a:	48 8b 11             	mov    rdx,QWORD PTR [rcx]
  22cd1d:	48 85 d2             	test   rdx,rdx
  22cd20:	74 38                	je     22cd5a <ArenaAllocator_createNode+0x10a>
                new_node.prev = prev_node;
  22cd22:	48 89 10             	mov    QWORD PTR [rax],rdx
                prev_node.next = new_node;
  22cd25:	48 83 c2 08          	add    rdx,0x8
  22cd29:	eb 3a                	jmp    22cd65 <ArenaAllocator_createNode+0x115>
  22cd2b:	49 8d 56 28          	lea    rdx,[r14+0x28]
                new_node.next = null;
  22cd2f:	48 c7 40 08 00 00 00 	mov    QWORD PTR [rax+0x8],0x0
  22cd36:	00 
  22cd37:	48 89 02             	mov    QWORD PTR [rdx],rax
            node.next = new_node;
  22cd3a:	48 89 41 08          	mov    QWORD PTR [rcx+0x8],rax
  22cd3e:	eb 2b                	jmp    22cd6b <ArenaAllocator_createNode+0x11b>
                list.first = new_node;
  22cd40:	49 89 46 20          	mov    QWORD PTR [r14+0x20],rax
                list.last = new_node;
  22cd44:	49 89 46 28          	mov    QWORD PTR [r14+0x28],rax
                new_node.next = null;
  22cd48:	c5 f8 57 c0          	vxorps xmm0,xmm0,xmm0
  22cd4c:	c5 f8 11 00          	vmovups XMMWORD PTR [rax],xmm0
                list.len = 1;
  22cd50:	49 c7 46 30 01 00 00 	mov    QWORD PTR [r14+0x30],0x1
  22cd57:	00 
  22cd58:	eb 16                	jmp    22cd70 <ArenaAllocator_createNode+0x120>
  22cd5a:	49 8d 56 20          	lea    rdx,[r14+0x20]
                new_node.prev = null;
  22cd5e:	48 c7 00 00 00 00 00 	mov    QWORD PTR [rax],0x0
  22cd65:	48 89 02             	mov    QWORD PTR [rdx],rax
            node.prev = new_node;
  22cd68:	48 89 01             	mov    QWORD PTR [rcx],rax
  22cd6b:	49 83 46 30 01       	add    QWORD PTR [r14+0x30],0x1
        self.end_index = 0;
  22cd70:	49 c7 46 38 00 00 00 	mov    QWORD PTR [r14+0x38],0x0
  22cd77:	00 
        return buf_node;
  22cd78:	66 41 c7 07 00 00    	mov    WORD PTR [r15],0x0
  22cd7e:	0f b7 4c 24 06       	movzx  ecx,WORD PTR [rsp+0x6]
  22cd83:	66 41 89 4f 06       	mov    WORD PTR [r15+0x6],cx
  22cd88:	8b 4c 24 02          	mov    ecx,DWORD PTR [rsp+0x2]
  22cd8c:	41 89 4f 02          	mov    DWORD PTR [r15+0x2],ecx
  22cd90:	49 89 47 08          	mov    QWORD PTR [r15+0x8],rax
  22cd94:	48 83 c4 30          	add    rsp,0x30
  22cd98:	5b                   	pop    rbx
  22cd99:	41 5e                	pop    r14
  22cd9b:	41 5f                	pop    r15
  22cd9d:	c3                   	ret    
            @panic("assertion failure");
  22cd9e:	48 8d 3d eb 2f 02 00 	lea    rdi,[rip+0x22feb]        # 24fd90 <__unnamed_2>
  22cda5:	e8 76 59 fe ff       	call   212720 <panic>
  22cdaa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

000000000022cdb0 <errol3>:
        }
    }
}

/// Corrected Errol3 double to ASCII conversion.
pub fn errol3(value: f64, buffer: []u8) FloatDecimal {
  22cdb0:	55                   	push   rbp
  22cdb1:	41 57                	push   r15
  22cdb3:	41 56                	push   r14
  22cdb5:	41 55                	push   r13
  22cdb7:	41 54                	push   r12
  22cdb9:	53                   	push   rbx
  22cdba:	48 83 ec 68          	sub    rsp,0x68
  22cdbe:	49 89 f7             	mov    r15,rsi
  22cdc1:	49 89 fe             	mov    r14,rdi
    const bits = @bitCast(u64, value);
  22cdc4:	c4 e1 f9 7e c5       	vmovq  rbp,xmm0
  22cdc9:	b8 b0 01 00 00       	mov    eax,0x1b0
  22cdce:	31 d2                	xor    edx,edx
  22cdd0:	48 8d 0d d9 48 fd ff 	lea    rcx,[rip+0xfffffffffffd48d9]        # 2016b0 <enum3.11>
  22cdd7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  22cdde:	00 00 
fn tableLowerBound(k: u64) usize {
    var i = enum3.len;
    var j: usize = 0;

    while (j < enum3.len) {
        if (enum3[j] < k) {
  22cde0:	48 39 2c d1          	cmp    QWORD PTR [rcx+rdx*8],rbp
  22cde4:	72 1a                	jb     22ce00 <errol3+0x50>
  22cde6:	48 89 d0             	mov    rax,rdx
  22cde9:	48 01 d2             	add    rdx,rdx
  22cdec:	48 83 c2 01          	add    rdx,0x1
    while (j < enum3.len) {
  22cdf0:	48 81 fa b0 01 00 00 	cmp    rdx,0x1b0
  22cdf7:	72 e7                	jb     22cde0 <errol3+0x30>
  22cdf9:	eb 15                	jmp    22ce10 <errol3+0x60>
  22cdfb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  22ce00:	48 01 d2             	add    rdx,rdx
  22ce03:	48 83 c2 02          	add    rdx,0x2
  22ce07:	48 81 fa b0 01 00 00 	cmp    rdx,0x1b0
  22ce0e:	72 d0                	jb     22cde0 <errol3+0x30>
    if (i < enum3.len and enum3[i] == bits) {
  22ce10:	48 3d af 01 00 00    	cmp    rax,0x1af
  22ce16:	77 4a                	ja     22ce62 <errol3+0xb2>
  22ce18:	48 39 2c c1          	cmp    QWORD PTR [rcx+rax*8],rbp
  22ce1c:	75 44                	jne    22ce62 <errol3+0xb2>
        const data = enum3_data[i];
  22ce1e:	48 8d 3c 40          	lea    rdi,[rax+rax*2]
  22ce22:	4c 8d 05 b7 04 02 00 	lea    r8,[rip+0x204b7]        # 24d2e0 <enum3_data.12>
  22ce29:	49 8b 0c f8          	mov    rcx,QWORD PTR [r8+rdi*8]
  22ce2d:	4d 8b 4c f8 08       	mov    r9,QWORD PTR [r8+rdi*8+0x8]
        const digits = buffer[1 .. data.str.len + 1];
  22ce32:	49 8b 37             	mov    rsi,QWORD PTR [r15]
    for (source) |s, i|
  22ce35:	49 8d 41 ff          	lea    rax,[r9-0x1]
  22ce39:	44 89 cd             	mov    ebp,r9d
  22ce3c:	83 e5 07             	and    ebp,0x7
  22ce3f:	48 83 f8 07          	cmp    rax,0x7
  22ce43:	0f 83 69 04 00 00    	jae    22d2b2 <errol3+0x502>
  22ce49:	31 db                	xor    ebx,ebx
  22ce4b:	41 8b 44 f8 10       	mov    eax,DWORD PTR [r8+rdi*8+0x10]
  22ce50:	48 8d 7e 01          	lea    rdi,[rsi+0x1]
  22ce54:	48 85 ed             	test   rbp,rbp
  22ce57:	0f 85 c1 04 00 00    	jne    22d31e <errol3+0x56e>
  22ce5d:	e9 de 04 00 00       	jmp    22d340 <errol3+0x590>
    if (val > 9.007199254740992e15 and val < 3.40282366920938e+38) {
  22ce62:	c5 f9 2e 05 9e 3e fd 	vucomisd xmm0,QWORD PTR [rip+0xfffffffffffd3e9e]        # 200d08 <__unnamed_621+0x50>
  22ce69:	ff 
  22ce6a:	c5 f9 7f 04 24       	vmovdqa XMMWORD PTR [rsp],xmm0
  22ce6f:	0f 86 0f 02 00 00    	jbe    22d084 <errol3+0x2d4>
  22ce75:	c5 fb 10 0d 4b 3e fd 	vmovsd xmm1,QWORD PTR [rip+0xfffffffffffd3e4b]        # 200cc8 <__unnamed_621+0x10>
  22ce7c:	ff 
  22ce7d:	c5 f9 2e c8          	vucomisd xmm1,xmm0
  22ce81:	0f 86 fd 01 00 00    	jbe    22d084 <errol3+0x2d4>
fn errolInt(val: f64, buffer: []u8) FloatDecimal {
    const pow19 = u128(1e19);

    assert((val > 9.007199254740992e15) and val < (3.40282366920938e38));

    var mid = @floatToInt(u128, val);
  22ce87:	e8 c4 4a 00 00       	call   231950 <__fixunsdfti>
  22ce8c:	c5 f9 28 0c 24       	vmovapd xmm1,XMMWORD PTR [rsp]
        .exp = exp,
    };
}

fn fpnext(val: f64) f64 {
    return @bitCast(f64, @bitCast(u64, val) +% 1);
  22ce91:	48 8d 4d 01          	lea    rcx,[rbp+0x1]
  22ce95:	c4 e1 f9 6e c1       	vmovq  xmm0,rcx
    var low: u128 = mid - fpeint((fpnext(val) - val) / 2.0);
  22ce9a:	c5 fb 5c c1          	vsubsd xmm0,xmm0,xmm1
  22ce9e:	c5 fb 59 05 da 3d fd 	vmulsd xmm0,xmm0,QWORD PTR [rip+0xfffffffffffd3dda]        # 200c80 <__unnamed_622+0x8>
  22cea5:	ff 

    return buf_index;
}

fn fpeint(from: f64) u128 {
    const bits = @bitCast(u64, from);
  22cea6:	c4 e1 f9 7e c1       	vmovq  rcx,xmm0
    assert((bits & ((1 << 52) - 1)) == 0);
  22ceab:	48 89 ce             	mov    rsi,rcx
  22ceae:	48 c1 e6 0c          	shl    rsi,0xc
    if (!ok) {
  22ceb2:	0f 85 1c 0e 00 00    	jne    22dcd4 <errol3+0xf24>
  22ceb8:	4c 89 74 24 20       	mov    QWORD PTR [rsp+0x20],r14
  22cebd:	48 be ff ff ff ff ff 	movabs rsi,0xfffffffffffff
  22cec4:	ff 0f 00 
    return @bitCast(f64, @bitCast(u64, val) -% 1);
  22cec7:	48 8d 7d ff          	lea    rdi,[rbp-0x1]
  22cecb:	c4 e1 f9 6e c7       	vmovq  xmm0,rdi
    var high: u128 = mid + fpeint((val - fpprev(val)) / 2.0);
  22ced0:	c5 f3 5c c0          	vsubsd xmm0,xmm1,xmm0
  22ced4:	c5 fb 59 05 a4 3d fd 	vmulsd xmm0,xmm0,QWORD PTR [rip+0xfffffffffffd3da4]        # 200c80 <__unnamed_622+0x8>
  22cedb:	ff 
    const bits = @bitCast(u64, from);
  22cedc:	c4 e1 f9 7e c3       	vmovq  rbx,xmm0
    assert((bits & ((1 << 52) - 1)) == 0);
  22cee1:	48 85 f3             	test   rbx,rsi
  22cee4:	0f 85 ea 0d 00 00    	jne    22dcd4 <errol3+0xf24>

    return u128(1) << @truncate(u7, (bits >> 52) -% 1023);
  22ceea:	48 c1 e9 34          	shr    rcx,0x34
  22ceee:	83 c1 01             	add    ecx,0x1
  22cef1:	83 e1 7f             	and    ecx,0x7f
  22cef4:	41 b8 01 00 00 00    	mov    r8d,0x1
  22cefa:	31 ff                	xor    edi,edi
  22cefc:	4c 0f a5 c7          	shld   rdi,r8,cl

    var i: i32 = 0;
    var a_copy = a;
    var b_copy = b;

    if (af != bf) {
  22cf00:	45 31 c9             	xor    r9d,r9d
    return u128(1) << @truncate(u7, (bits >> 52) -% 1023);
  22cf03:	c4 c2 f1 f7 f0       	shlx   rsi,r8,rcx
  22cf08:	f6 c1 40             	test   cl,0x40
  22cf0b:	48 0f 45 fe          	cmovne rdi,rsi
  22cf0f:	49 0f 45 f1          	cmovne rsi,r9
    if (af != bf) {
  22cf13:	45 31 c9             	xor    r9d,r9d
    var low: u128 = mid - fpeint((fpnext(val) - val) / 2.0);
  22cf16:	49 89 c5             	mov    r13,rax
  22cf19:	49 29 f5             	sub    r13,rsi
  22cf1c:	48 89 d6             	mov    rsi,rdx
  22cf1f:	48 19 fe             	sbb    rsi,rdi
    return u128(1) << @truncate(u7, (bits >> 52) -% 1023);
  22cf22:	48 c1 eb 34          	shr    rbx,0x34
  22cf26:	83 c3 01             	add    ebx,0x1
  22cf29:	83 e3 7f             	and    ebx,0x7f
  22cf2c:	31 ff                	xor    edi,edi
  22cf2e:	89 d9                	mov    ecx,ebx
  22cf30:	4c 0f a5 c7          	shld   rdi,r8,cl
  22cf34:	c4 c2 e1 f7 c8       	shlx   rcx,r8,rbx
  22cf39:	f6 c3 40             	test   bl,0x40
  22cf3c:	48 0f 45 f9          	cmovne rdi,rcx
  22cf40:	49 0f 45 c9          	cmovne rcx,r9
    if (@bitCast(u64, val) & 0x1 != 0) {
  22cf44:	83 e5 01             	and    ebp,0x1
  22cf47:	31 db                	xor    ebx,ebx
  22cf49:	48 85 ed             	test   rbp,rbp
  22cf4c:	0f 94 c3             	sete   bl
  22cf4f:	48 89 04 24          	mov    QWORD PTR [rsp],rax
    var high: u128 = mid + fpeint((val - fpprev(val)) / 2.0);
  22cf53:	49 89 c4             	mov    r12,rax
  22cf56:	49 29 ec             	sub    r12,rbp
  22cf59:	48 89 54 24 10       	mov    QWORD PTR [rsp+0x10],rdx
  22cf5e:	48 89 d5             	mov    rbp,rdx
  22cf61:	48 83 dd 00          	sbb    rbp,0x0
    if (@bitCast(u64, val) & 0x1 != 0) {
  22cf65:	49 01 cc             	add    r12,rcx
  22cf68:	48 11 fd             	adc    rbp,rdi
  22cf6b:	49 29 dd             	sub    r13,rbx
  22cf6e:	48 83 de 00          	sbb    rsi,0x0
  22cf72:	49 be 00 00 e8 89 04 	movabs r14,0x8ac7230489e80000
  22cf79:	23 c7 8a 
    const lf = @intCast(u64, (low / pow19) % pow19);
  22cf7c:	31 c9                	xor    ecx,ecx
  22cf7e:	4c 89 ef             	mov    rdi,r13
  22cf81:	4c 89 f2             	mov    rdx,r14
  22cf84:	e8 c7 54 00 00       	call   232450 <__udivti3>
  22cf89:	48 89 c1             	mov    rcx,rax
  22cf8c:	49 0f af ce          	imul   rcx,r14
  22cf90:	49 29 cd             	sub    r13,rcx
  22cf93:	31 c9                	xor    ecx,ecx
  22cf95:	48 89 c7             	mov    rdi,rax
  22cf98:	48 89 d6             	mov    rsi,rdx
  22cf9b:	4c 89 f2             	mov    rdx,r14
  22cf9e:	e8 cd 54 00 00       	call   232470 <__umodti3>
  22cfa3:	48 89 c3             	mov    rbx,rax
    const hf = @intCast(u64, (high / pow19) % pow19);
  22cfa6:	31 c9                	xor    ecx,ecx
  22cfa8:	4c 89 e7             	mov    rdi,r12
  22cfab:	48 89 ee             	mov    rsi,rbp
  22cfae:	4c 89 f2             	mov    rdx,r14
  22cfb1:	e8 9a 54 00 00       	call   232450 <__udivti3>
  22cfb6:	48 89 c1             	mov    rcx,rax
  22cfb9:	49 0f af ce          	imul   rcx,r14
  22cfbd:	49 29 cc             	sub    r12,rcx
  22cfc0:	31 c9                	xor    ecx,ecx
  22cfc2:	48 89 c7             	mov    rdi,rax
  22cfc5:	48 89 d6             	mov    rsi,rdx
  22cfc8:	4c 89 f2             	mov    rdx,r14
  22cfcb:	e8 a0 54 00 00       	call   232470 <__umodti3>
  22cfd0:	49 89 c6             	mov    r14,rax
    if (lf != hf) {
  22cfd3:	4c 39 f3             	cmp    rbx,r14
  22cfd6:	48 89 df             	mov    rdi,rbx
  22cfd9:	4c 0f 45 eb          	cmovne r13,rbx
  22cfdd:	4d 0f 45 e6          	cmovne r12,r14
  22cfe1:	48 b9 bf d5 ed bd ce 	movabs rcx,0xdbe6fecebdedd5bf
  22cfe8:	fe e6 db 
    const af = a / pow10;
  22cfeb:	4c 89 ea             	mov    rdx,r13
  22cfee:	c4 e2 eb f6 c1       	mulx   rax,rdx,rcx
  22cff3:	48 c1 e8 21          	shr    rax,0x21
    const bf = b / pow10;
  22cff7:	4c 89 e2             	mov    rdx,r12
  22cffa:	c4 e2 eb f6 c9       	mulx   rcx,rdx,rcx
  22cfff:	48 c1 e9 21          	shr    rcx,0x21
    if (af != bf) {
  22d003:	48 39 c8             	cmp    rax,rcx
  22d006:	bd 0a 00 00 00       	mov    ebp,0xa
  22d00b:	ba 00 00 00 00       	mov    edx,0x0
  22d010:	0f 44 ea             	cmove  ebp,edx
  22d013:	49 0f 44 c5          	cmove  rax,r13
  22d017:	49 0f 44 cc          	cmove  rcx,r12
  22d01b:	bb 01 00 00 00       	mov    ebx,0x1
        i = 10;
        a_copy = af;
        b_copy = bf;
    }

    while (true) : (i += 1) {
  22d020:	29 eb                	sub    ebx,ebp
  22d022:	83 c5 12             	add    ebp,0x12
  22d025:	48 be cd cc cc cc cc 	movabs rsi,0xcccccccccccccccd
  22d02c:	cc cc cc 
  22d02f:	90                   	nop
        a_copy /= 10;
  22d030:	48 89 c2             	mov    rdx,rax
  22d033:	c4 e2 eb f6 c6       	mulx   rax,rdx,rsi
  22d038:	48 c1 e8 03          	shr    rax,0x3
        b_copy /= 10;
  22d03c:	48 89 ca             	mov    rdx,rcx
  22d03f:	c4 e2 eb f6 ce       	mulx   rcx,rdx,rsi
  22d044:	48 c1 e9 03          	shr    rcx,0x3

        if (a_copy == b_copy) return i;
  22d048:	83 c3 ff             	add    ebx,0xffffffff
  22d04b:	83 c5 01             	add    ebp,0x1
  22d04e:	48 39 c8             	cmp    rax,rcx
  22d051:	75 dd                	jne    22d030 <errol3+0x280>
  22d053:	49 89 fd             	mov    r13,rdi
    if (lf != hf) {
  22d056:	4d 39 f5             	cmp    r13,r14
  22d059:	0f 84 0e 02 00 00    	je     22d26d <errol3+0x4bd>
        mid = mid / (pow19 / 10);
  22d05f:	48 ba 00 00 64 a7 b3 	movabs rdx,0xde0b6b3a7640000
  22d066:	b6 e0 0d 
  22d069:	31 c9                	xor    ecx,ecx
  22d06b:	48 8b 3c 24          	mov    rdi,QWORD PTR [rsp]
  22d06f:	48 8b 74 24 10       	mov    rsi,QWORD PTR [rsp+0x10]
  22d074:	e8 d7 53 00 00       	call   232450 <__udivti3>
  22d079:	48 89 c7             	mov    rdi,rax
  22d07c:	48 89 d6             	mov    rsi,rdx
  22d07f:	e9 f2 01 00 00       	jmp    22d276 <errol3+0x4c6>
    } else if (val >= 16.0 and val < 9.007199254740992e15) {
  22d084:	c5 f9 2e 05 d4 3b fd 	vucomisd xmm0,QWORD PTR [rip+0xfffffffffffd3bd4]        # 200c60 <__unnamed_464+0x50>
  22d08b:	ff 
  22d08c:	0f 82 39 01 00 00    	jb     22d1cb <errol3+0x41b>
  22d092:	c5 fb 10 0d 6e 3c fd 	vmovsd xmm1,QWORD PTR [rip+0xfffffffffffd3c6e]        # 200d08 <__unnamed_621+0x50>
  22d099:	ff 
  22d09a:	c5 f9 2e c8          	vucomisd xmm1,xmm0
  22d09e:	0f 86 27 01 00 00    	jbe    22d1cb <errol3+0x41b>
    const u = @floatToInt(u64, val);
  22d0a4:	c5 fb 10 15 14 3c fd 	vmovsd xmm2,QWORD PTR [rip+0xfffffffffffd3c14]        # 200cc0 <__unnamed_621+0x8>
  22d0ab:	ff 
  22d0ac:	c5 fb 5c ca          	vsubsd xmm1,xmm0,xmm2
  22d0b0:	c4 e1 fb 2c c1       	vcvttsd2si rax,xmm1
  22d0b5:	48 b9 00 00 00 00 00 	movabs rcx,0x8000000000000000
  22d0bc:	00 00 80 
  22d0bf:	48 31 c1             	xor    rcx,rax
  22d0c2:	c4 e1 fb 2c f8       	vcvttsd2si rdi,xmm0
  22d0c7:	c5 f9 2e c2          	vucomisd xmm0,xmm2
  22d0cb:	48 0f 43 f9          	cmovae rdi,rcx
    const n = @intToFloat(f64, u);
  22d0cf:	c4 e1 f9 6e cf       	vmovq  xmm1,rdi
  22d0d4:	c5 f1 62 0d 44 31 fd 	vpunpckldq xmm1,xmm1,XMMWORD PTR [rip+0xfffffffffffd3144]        # 200220 <__unnamed_29+0x20>
  22d0db:	ff 
  22d0dc:	c5 f1 5c 0d 4c 36 fd 	vsubpd xmm1,xmm1,XMMWORD PTR [rip+0xfffffffffffd364c]        # 200730 <__unnamed_55+0x10>
  22d0e3:	ff 
  22d0e4:	c5 f1 7c c9          	vhaddpd xmm1,xmm1,xmm1
  22d0e8:	c5 f9 29 4c 24 10    	vmovapd XMMWORD PTR [rsp+0x10],xmm1
    var mid = val - n;
  22d0ee:	c5 fb 5c c9          	vsubsd xmm1,xmm0,xmm1
    var buf_index = u64toa(u, buffer);
  22d0f2:	c5 f9 29 4c 24 20    	vmovapd XMMWORD PTR [rsp+0x20],xmm1
  22d0f8:	4c 89 fe             	mov    rsi,r15
  22d0fb:	e8 e0 0b 00 00       	call   22dce0 <u64toa>
  22d100:	c5 f9 28 6c 24 20    	vmovapd xmm5,XMMWORD PTR [rsp+0x20]
  22d106:	49 89 c4             	mov    r12,rax
    buffer[j] = 0;
  22d109:	49 8b 07             	mov    rax,QWORD PTR [r15]
  22d10c:	42 c6 04 20 00       	mov    BYTE PTR [rax+r12*1],0x0
    if (mid != 0.0) {
  22d111:	c5 f9 57 c0          	vxorpd xmm0,xmm0,xmm0
  22d115:	c5 f9 2e e8          	vucomisd xmm5,xmm0
  22d119:	0f 84 48 08 00 00    	je     22d967 <errol3+0xbb7>
    return @bitCast(f64, @bitCast(u64, val) -% 1);
  22d11f:	c4 e2 79 59 0c 24    	vpbroadcastq xmm1,QWORD PTR [rsp]
  22d125:	c5 f1 d4 0d 93 37 fd 	vpaddq xmm1,xmm1,XMMWORD PTR [rip+0xfffffffffffd3793]        # 2008c0 <__unnamed_534+0x10>
  22d12c:	ff 
    var lo = ((fpprev(val) - n) + mid) / 2.0;
  22d12d:	c5 fb 12 54 24 10    	vmovddup xmm2,QWORD PTR [rsp+0x10]
  22d133:	c5 f1 5c ca          	vsubpd xmm1,xmm1,xmm2
  22d137:	c5 fb 12 d5          	vmovddup xmm2,xmm5
  22d13b:	c5 e9 58 c9          	vaddpd xmm1,xmm2,xmm1
  22d13f:	c5 f1 59 1d 89 33 fd 	vmulpd xmm3,xmm1,XMMWORD PTR [rip+0xfffffffffffd3389]        # 2004d0 <__unnamed_27+0x10>
  22d146:	ff 
  22d147:	c5 f9 28 0d d1 31 fd 	vmovapd xmm1,XMMWORD PTR [rip+0xfffffffffffd31d1]        # 200320 <__unnamed_35+0x10>
  22d14e:	ff 
  22d14f:	c5 fb 10 15 e1 3a fd 	vmovsd xmm2,QWORD PTR [rip+0xfffffffffffd3ae1]        # 200c38 <__unnamed_464+0x28>
  22d156:	ff 
  22d157:	4c 89 e0             	mov    rax,r12
  22d15a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  22d160:	48 89 c1             	mov    rcx,rax
            mid *= 10.0;
  22d163:	c5 d3 59 e2          	vmulsd xmm4,xmm5,xmm2
            const mdig = @floatToInt(i32, mid);
  22d167:	c5 fb 2c c4          	vcvttsd2si eax,xmm4
            mid -= @intToFloat(f64, mdig);
  22d16b:	c5 cb 2a e8          	vcvtsi2sd xmm5,xmm6,eax
  22d16f:	c5 db 5c ed          	vsubsd xmm5,xmm4,xmm5
            buffer[j] = @intCast(u8, mdig + '0');
  22d173:	49 8b 17             	mov    rdx,QWORD PTR [r15]
  22d176:	04 30                	add    al,0x30
  22d178:	88 04 0a             	mov    BYTE PTR [rdx+rcx*1],al
            if (hdig != ldig or j > 50) break;
  22d17b:	48 83 f9 31          	cmp    rcx,0x31
  22d17f:	77 2c                	ja     22d1ad <errol3+0x3fd>
  22d181:	c5 e1 59 d9          	vmulpd xmm3,xmm3,xmm1
  22d185:	c5 fb 2c c3          	vcvttsd2si eax,xmm3
  22d189:	c4 e3 79 05 e3 01    	vpermilpd xmm4,xmm3,0x1
  22d18f:	c5 fb 2c d4          	vcvttsd2si edx,xmm4
  22d193:	39 c2                	cmp    edx,eax
  22d195:	75 16                	jne    22d1ad <errol3+0x3fd>
            hi -= @intToFloat(f64, hdig);
  22d197:	c5 cb 2a e0          	vcvtsi2sd xmm4,xmm6,eax
  22d19b:	48 8d 41 01          	lea    rax,[rcx+0x1]
            lo -= @intToFloat(f64, ldig);
  22d19f:	c5 fb 12 e4          	vmovddup xmm4,xmm4
  22d1a3:	c5 e1 5c dc          	vsubpd xmm3,xmm3,xmm4
        while (mid != 0.0) {
  22d1a7:	c5 f9 2e e8          	vucomisd xmm5,xmm0
  22d1ab:	75 b3                	jne    22d160 <errol3+0x3b0>
        if (mid > 0.5) {
  22d1ad:	48 8d 41 01          	lea    rax,[rcx+0x1]
  22d1b1:	c5 f9 2e 2d c7 3a fd 	vucomisd xmm5,QWORD PTR [rip+0xfffffffffffd3ac7]        # 200c80 <__unnamed_622+0x8>
  22d1b8:	ff 
  22d1b9:	0f 86 f3 07 00 00    	jbe    22d9b2 <errol3+0xc02>
            buffer[j - 1] += 1;
  22d1bf:	49 8b 17             	mov    rdx,QWORD PTR [r15]
  22d1c2:	80 04 0a 01          	add    BYTE PTR [rdx+rcx*1],0x1
  22d1c6:	e9 9b 0a 00 00       	jmp    22dc66 <errol3+0xeb6>
  22d1cb:	48 8d 7c 24 38       	lea    rdi,[rsp+0x38]

pub fn frexp(x: var) frexp_result(@typeOf(x)) {
    const T = @typeOf(x);
    return switch (T) {
        f32 => frexp32(x),
        f64 => frexp64(x),
  22d1d0:	e8 fb 11 00 00       	call   22e3d0 <frexp64>
    var exp = @floatToInt(i16, math.floor(307 + @intToFloat(f64, e) * 0.30103));
  22d1d5:	c5 eb 2a 44 24 40    	vcvtsi2sd xmm0,xmm2,DWORD PTR [rsp+0x40]
  22d1db:	c5 fb 59 05 85 3a fd 	vmulsd xmm0,xmm0,QWORD PTR [rip+0xfffffffffffd3a85]        # 200c68 <__unnamed_464+0x58>
  22d1e2:	ff 
  22d1e3:	c5 fb 58 05 a5 3a fd 	vaddsd xmm0,xmm0,QWORD PTR [rip+0xfffffffffffd3aa5]        # 200c90 <__unnamed_622+0x18>
  22d1ea:	ff 
fn floor64(x: f64) f64 {
    const u = @bitCast(u64, x);
    const e = (u >> 52) & 0x7FF;
    var y: f64 = undefined;

    if (e >= 0x3FF + 52 or x == 0) {
  22d1eb:	c5 f1 57 c9          	vxorpd xmm1,xmm1,xmm1
  22d1ef:	c5 f9 2e c1          	vucomisd xmm0,xmm1
  22d1f3:	75 06                	jne    22d1fb <errol3+0x44b>
  22d1f5:	0f 8b 55 01 00 00    	jnp    22d350 <errol3+0x5a0>
  22d1fb:	c4 e1 f9 7e c0       	vmovq  rax,xmm0
  22d200:	b9 34 0b 00 00       	mov    ecx,0xb34
  22d205:	c4 e2 f0 f7 c8       	bextr  rcx,rax,rcx
  22d20a:	48 81 f9 32 04 00 00 	cmp    rcx,0x432
  22d211:	0f 87 39 01 00 00    	ja     22d350 <errol3+0x5a0>
        return x;
    }

    if (u >> 63 != 0) {
        y = x - math.f64_toint + math.f64_toint - x;
  22d217:	c5 fb 10 15 39 3a fd 	vmovsd xmm2,QWORD PTR [rip+0xfffffffffffd3a39]        # 200c58 <__unnamed_464+0x48>
  22d21e:	ff 
  22d21f:	c5 fb 10 1d 71 3a fd 	vmovsd xmm3,QWORD PTR [rip+0xfffffffffffd3a71]        # 200c98 <__unnamed_622+0x20>
  22d226:	ff 
    if (u >> 63 != 0) {
  22d227:	48 85 c0             	test   rax,rax
  22d22a:	c5 79 28 1c 24       	vmovapd xmm11,XMMWORD PTR [rsp]
  22d22f:	0f 88 a3 07 00 00    	js     22d9d8 <errol3+0xc28>
  22d235:	c5 fb 58 db          	vaddsd xmm3,xmm0,xmm3
  22d239:	c5 e3 58 d2          	vaddsd xmm2,xmm3,xmm2
    } else {
        y = x + math.f64_toint - math.f64_toint - x;
    }

    if (e <= 0x3FF - 1) {
  22d23d:	48 81 f9 fe 03 00 00 	cmp    rcx,0x3fe
  22d244:	0f 86 a3 07 00 00    	jbe    22d9ed <errol3+0xc3d>
  22d24a:	c5 eb 5c d0          	vsubsd xmm2,xmm2,xmm0
        if (u >> 63 != 0) {
            return -1.0;
        } else {
            return 0.0;
        }
    } else if (y > 0) {
  22d24e:	c5 e1 57 db          	vxorpd xmm3,xmm3,xmm3
  22d252:	c5 f9 2e d3          	vucomisd xmm2,xmm3
  22d256:	c5 fb 58 c2          	vaddsd xmm0,xmm0,xmm2
  22d25a:	0f 86 f5 00 00 00    	jbe    22d355 <errol3+0x5a5>
        return x + y - 1;
  22d260:	c5 fb 58 05 08 3a fd 	vaddsd xmm0,xmm0,QWORD PTR [rip+0xfffffffffffd3a08]        # 200c70 <__unnamed_464+0x60>
  22d267:	ff 
  22d268:	e9 e8 00 00 00       	jmp    22d355 <errol3+0x5a5>
  22d26d:	48 8b 3c 24          	mov    rdi,QWORD PTR [rsp]
  22d271:	48 8b 74 24 10       	mov    rsi,QWORD PTR [rsp+0x10]
        var i: i32 = @boolToInt(lf == hf);
  22d276:	31 c0                	xor    eax,eax
  22d278:	4d 39 f5             	cmp    r13,r14
  22d27b:	0f 94 c0             	sete   al
        while (i < mi) : (i += 1) {
  22d27e:	41 89 dc             	mov    r12d,ebx
  22d281:	41 f7 dc             	neg    r12d
  22d284:	41 39 c4             	cmp    r12d,eax
  22d287:	76 1d                	jbe    22d2a6 <errol3+0x4f6>
  22d289:	41 89 c2             	mov    r10d,eax
  22d28c:	41 f7 da             	neg    r10d
  22d28f:	41 29 da             	sub    r10d,ebx
  22d292:	41 83 fa 10          	cmp    r10d,0x10
  22d296:	0f 83 8a 06 00 00    	jae    22d926 <errol3+0xb76>
  22d29c:	ba 01 00 00 00       	mov    edx,0x1
  22d2a1:	e9 61 09 00 00       	jmp    22dc07 <errol3+0xe57>
  22d2a6:	31 c9                	xor    ecx,ecx
  22d2a8:	ba 01 00 00 00       	mov    edx,0x1
  22d2ad:	e9 6c 09 00 00       	jmp    22dc1e <errol3+0xe6e>
  22d2b2:	4c 89 c8             	mov    rax,r9
  22d2b5:	48 29 e8             	sub    rax,rbp
  22d2b8:	31 db                	xor    ebx,ebx
  22d2ba:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  22d2c0:	0f b6 14 19          	movzx  edx,BYTE PTR [rcx+rbx*1]
        dest[i] = s;
  22d2c4:	88 54 1e 01          	mov    BYTE PTR [rsi+rbx*1+0x1],dl
    for (source) |s, i|
  22d2c8:	0f b6 54 19 01       	movzx  edx,BYTE PTR [rcx+rbx*1+0x1]
        dest[i] = s;
  22d2cd:	88 54 1e 02          	mov    BYTE PTR [rsi+rbx*1+0x2],dl
    for (source) |s, i|
  22d2d1:	0f b6 54 19 02       	movzx  edx,BYTE PTR [rcx+rbx*1+0x2]
        dest[i] = s;
  22d2d6:	88 54 1e 03          	mov    BYTE PTR [rsi+rbx*1+0x3],dl
    for (source) |s, i|
  22d2da:	0f b6 54 19 03       	movzx  edx,BYTE PTR [rcx+rbx*1+0x3]
        dest[i] = s;
  22d2df:	88 54 1e 04          	mov    BYTE PTR [rsi+rbx*1+0x4],dl
    for (source) |s, i|
  22d2e3:	0f b6 54 19 04       	movzx  edx,BYTE PTR [rcx+rbx*1+0x4]
        dest[i] = s;
  22d2e8:	88 54 1e 05          	mov    BYTE PTR [rsi+rbx*1+0x5],dl
    for (source) |s, i|
  22d2ec:	0f b6 54 19 05       	movzx  edx,BYTE PTR [rcx+rbx*1+0x5]
        dest[i] = s;
  22d2f1:	88 54 1e 06          	mov    BYTE PTR [rsi+rbx*1+0x6],dl
    for (source) |s, i|
  22d2f5:	0f b6 54 19 06       	movzx  edx,BYTE PTR [rcx+rbx*1+0x6]
        dest[i] = s;
  22d2fa:	88 54 1e 07          	mov    BYTE PTR [rsi+rbx*1+0x7],dl
    for (source) |s, i|
  22d2fe:	0f b6 54 19 07       	movzx  edx,BYTE PTR [rcx+rbx*1+0x7]
        dest[i] = s;
  22d303:	88 54 1e 08          	mov    BYTE PTR [rsi+rbx*1+0x8],dl
    for (source) |s, i|
  22d307:	48 83 c3 08          	add    rbx,0x8
  22d30b:	48 39 d8             	cmp    rax,rbx
  22d30e:	75 b0                	jne    22d2c0 <errol3+0x510>
  22d310:	41 8b 44 f8 10       	mov    eax,DWORD PTR [r8+rdi*8+0x10]
  22d315:	48 8d 7e 01          	lea    rdi,[rsi+0x1]
  22d319:	48 85 ed             	test   rbp,rbp
  22d31c:	74 22                	je     22d340 <errol3+0x590>
  22d31e:	48 01 de             	add    rsi,rbx
  22d321:	48 83 c6 01          	add    rsi,0x1
  22d325:	48 01 d9             	add    rcx,rbx
  22d328:	31 db                	xor    ebx,ebx
  22d32a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  22d330:	0f b6 14 19          	movzx  edx,BYTE PTR [rcx+rbx*1]
        dest[i] = s;
  22d334:	88 14 1e             	mov    BYTE PTR [rsi+rbx*1],dl
    for (source) |s, i|
  22d337:	48 83 c3 01          	add    rbx,0x1
  22d33b:	48 39 dd             	cmp    rbp,rbx
  22d33e:	75 f0                	jne    22d330 <errol3+0x580>
        return FloatDecimal{
  22d340:	49 89 3e             	mov    QWORD PTR [r14],rdi
  22d343:	4d 89 4e 08          	mov    QWORD PTR [r14+0x8],r9
  22d347:	41 89 46 10          	mov    DWORD PTR [r14+0x10],eax
  22d34b:	e9 75 09 00 00       	jmp    22dcc5 <errol3+0xf15>
  22d350:	c5 79 28 1c 24       	vmovapd xmm11,XMMWORD PTR [rsp]
    var exp = @floatToInt(i16, math.floor(307 + @intToFloat(f64, e) * 0.30103));
  22d355:	c5 fb 2c c0          	vcvttsd2si eax,xmm0
    if (exp < 20) {
  22d359:	98                   	cwde   
    } else if (@intCast(usize, exp) >= lookup_table.len) {
  22d35a:	0f b7 c8             	movzx  ecx,ax
  22d35d:	81 f9 57 02 00 00    	cmp    ecx,0x257
  22d363:	66 b9 57 02          	mov    cx,0x257
  22d367:	66 0f 42 c8          	cmovb  cx,ax
    if (exp < 20) {
  22d36b:	83 f8 14             	cmp    eax,0x14
  22d36e:	66 b8 14 00          	mov    ax,0x14
  22d372:	66 0f 4d c1          	cmovge ax,cx
    var mid = lookup_table[@intCast(usize, exp)];
  22d376:	0f b7 c8             	movzx  ecx,ax
  22d379:	48 c1 e1 04          	shl    rcx,0x4
  22d37d:	48 8d 15 14 64 fd ff 	lea    rdx,[rip+0xfffffffffffd6414]        # 203798 <lookup_table.14>
  22d384:	48 8b 34 11          	mov    rsi,QWORD PTR [rcx+rdx*1]
  22d388:	c4 61 f9 6e c6       	vmovq  xmm8,rsi
    const new_bits = bits & 0xFFFFFFFFF8000000;
  22d38d:	48 81 e6 00 00 00 f8 	and    rsi,0xfffffffff8000000
    return @bitCast(f64, new_bits);
  22d394:	c4 e1 f9 6e c6       	vmovq  xmm0,rsi
    lo.* = val - hi.*;
  22d399:	c5 bb 5c e0          	vsubsd xmm4,xmm8,xmm0
    const new_bits = bits & 0xFFFFFFFFF8000000;
  22d39d:	48 89 ee             	mov    rsi,rbp
  22d3a0:	48 81 e6 00 00 00 f8 	and    rsi,0xfffffffff8000000
    return @bitCast(f64, new_bits);
  22d3a7:	c4 e1 f9 6e ee       	vmovq  xmm5,rsi
    lo.* = val - hi.*;
  22d3ac:	c5 a3 5c f5          	vsubsd xmm6,xmm11,xmm5
    const p = in.val * val;
  22d3b0:	c4 c1 3b 59 db       	vmulsd xmm3,xmm8,xmm11
    const e = ((hi * hi2 - p) + lo * hi2 + hi * lo2) + lo * lo2;
  22d3b5:	c5 d3 59 f8          	vmulsd xmm7,xmm5,xmm0
  22d3b9:	c5 c3 5c fb          	vsubsd xmm7,xmm7,xmm3
  22d3bd:	c5 db 59 ed          	vmulsd xmm5,xmm4,xmm5
  22d3c1:	c5 d3 58 ef          	vaddsd xmm5,xmm5,xmm7
  22d3c5:	c5 cb 59 c0          	vmulsd xmm0,xmm6,xmm0
  22d3c9:	c5 fb 58 c5          	vaddsd xmm0,xmm0,xmm5
  22d3cd:	c5 cb 59 e4          	vmulsd xmm4,xmm6,xmm4
  22d3d1:	c5 db 58 c0          	vaddsd xmm0,xmm4,xmm0
        .off = in.off * val + e,
  22d3d5:	c5 a3 59 64 11 08    	vmulsd xmm4,xmm11,QWORD PTR [rcx+rdx*1+0x8]
  22d3db:	c5 db 58 f0          	vaddsd xmm6,xmm4,xmm0
    exp -= 307;
  22d3df:	8d 80 cd fe ff ff    	lea    eax,[rax-0x133]
    while (mid.val > 10.0 or (mid.val == 10.0 and mid.off >= 0.0)) {
  22d3e5:	44 0f bf e0          	movsx  r12d,ax
  22d3e9:	c5 fb 10 25 57 38 fd 	vmovsd xmm4,QWORD PTR [rip+0xfffffffffffd3857]        # 200c48 <__unnamed_464+0x38>
  22d3f0:	ff 
  22d3f1:	c5 7b 10 35 3f 38 fd 	vmovsd xmm14,QWORD PTR [rip+0xfffffffffffd383f]        # 200c38 <__unnamed_464+0x28>
  22d3f8:	ff 
  22d3f9:	c5 fb 10 2d e7 38 fd 	vmovsd xmm5,QWORD PTR [rip+0xfffffffffffd38e7]        # 200ce8 <__unnamed_621+0x30>
  22d400:	ff 
  22d401:	c4 c1 79 2e de       	vucomisd xmm3,xmm14
  22d406:	76 47                	jbe    22d44f <errol3+0x69f>
  22d408:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  22d40f:	00 
    hp.val /= 10.0;
  22d410:	c4 c1 63 5e fe       	vdivsd xmm7,xmm3,xmm14
    hp.off /= 10.0;
  22d415:	c4 c1 4b 5e f6       	vdivsd xmm6,xmm6,xmm14
    val -= hp.val * 8.0;
  22d41a:	c5 c3 59 d5          	vmulsd xmm2,xmm7,xmm5
  22d41e:	c5 e3 58 d2          	vaddsd xmm2,xmm3,xmm2
    val -= hp.val * 2.0;
  22d422:	c5 c3 58 df          	vaddsd xmm3,xmm7,xmm7
  22d426:	c5 eb 5c d3          	vsubsd xmm2,xmm2,xmm3
    hp.off += val / 10.0;
  22d42a:	c4 c1 6b 5e d6       	vdivsd xmm2,xmm2,xmm14
  22d42f:	c5 cb 58 d2          	vaddsd xmm2,xmm6,xmm2
    hp.val += hp.off;
  22d433:	c5 c3 58 da          	vaddsd xmm3,xmm7,xmm2
    hp.off += val - hp.val;
  22d437:	c5 c3 5c f3          	vsubsd xmm6,xmm7,xmm3
  22d43b:	c5 eb 58 f6          	vaddsd xmm6,xmm2,xmm6
        ten /= 10.0;
  22d43f:	c4 c1 5b 5e e6       	vdivsd xmm4,xmm4,xmm14
    while (mid.val > 10.0 or (mid.val == 10.0 and mid.off >= 0.0)) {
  22d444:	41 83 c4 01          	add    r12d,0x1
  22d448:	c4 c1 79 2e de       	vucomisd xmm3,xmm14
  22d44d:	77 c1                	ja     22d410 <errol3+0x660>
  22d44f:	c5 f9 2e f1          	vucomisd xmm6,xmm1
  22d453:	72 42                	jb     22d497 <errol3+0x6e7>
  22d455:	c4 c1 79 2e de       	vucomisd xmm3,xmm14
  22d45a:	75 3b                	jne    22d497 <errol3+0x6e7>
  22d45c:	7b b2                	jnp    22d410 <errol3+0x660>
  22d45e:	eb 37                	jmp    22d497 <errol3+0x6e7>
    hp.val *= 10.0;
  22d460:	c4 c1 63 59 ce       	vmulsd xmm1,xmm3,xmm14
    hp.off *= 10.0;
  22d465:	c4 c1 4b 59 d6       	vmulsd xmm2,xmm6,xmm14
    off -= val * 8.0;
  22d46a:	c5 e3 59 2d 76 38 fd 	vmulsd xmm5,xmm3,QWORD PTR [rip+0xfffffffffffd3876]        # 200ce8 <__unnamed_621+0x30>
  22d471:	ff 
  22d472:	c5 f3 58 ed          	vaddsd xmm5,xmm1,xmm5
    off -= val * 2.0;
  22d476:	c5 e3 58 db          	vaddsd xmm3,xmm3,xmm3
  22d47a:	c5 d3 5c db          	vsubsd xmm3,xmm5,xmm3
    hp.off -= off;
  22d47e:	c5 eb 5c d3          	vsubsd xmm2,xmm2,xmm3
    hp.val += hp.off;
  22d482:	c5 f3 58 da          	vaddsd xmm3,xmm1,xmm2
    hp.off += val - hp.val;
  22d486:	c5 f3 5c cb          	vsubsd xmm1,xmm1,xmm3
  22d48a:	c5 eb 58 f1          	vaddsd xmm6,xmm2,xmm1
        ten *= 10.0;
  22d48e:	c4 c1 5b 59 e6       	vmulsd xmm4,xmm4,xmm14
    while (mid.val < 1.0 or (mid.val == 1.0 and mid.off < 0.0)) {
  22d493:	41 83 c4 ff          	add    r12d,0xffffffff
  22d497:	c5 7b 10 0d a9 37 fd 	vmovsd xmm9,QWORD PTR [rip+0xfffffffffffd37a9]        # 200c48 <__unnamed_464+0x38>
  22d49e:	ff 
  22d49f:	c5 79 2e cb          	vucomisd xmm9,xmm3
  22d4a3:	77 bb                	ja     22d460 <errol3+0x6b0>
  22d4a5:	c4 41 29 57 d2       	vxorpd xmm10,xmm10,xmm10
  22d4aa:	c5 79 2e d6          	vucomisd xmm10,xmm6
  22d4ae:	76 0c                	jbe    22d4bc <errol3+0x70c>
  22d4b0:	c5 f9 2e 1d 90 37 fd 	vucomisd xmm3,QWORD PTR [rip+0xfffffffffffd3790]        # 200c48 <__unnamed_464+0x38>
  22d4b7:	ff 
  22d4b8:	75 02                	jne    22d4bc <errol3+0x70c>
  22d4ba:	7b a4                	jnp    22d460 <errol3+0x6b0>
    return @bitCast(f64, @bitCast(u64, val) +% 1);
  22d4bc:	48 8d 45 01          	lea    rax,[rbp+0x1]
  22d4c0:	c4 e1 f9 6e c8       	vmovq  xmm1,rax
        .off = mid.off + (fpnext(val) - val) * lten * ten / 2.0,
  22d4c5:	c4 c1 73 5c cb       	vsubsd xmm1,xmm1,xmm11
    return @bitCast(f64, @bitCast(u64, val) -% 1);
  22d4ca:	48 83 c5 ff          	add    rbp,0xffffffffffffffff
  22d4ce:	c4 e1 f9 6e d5       	vmovq  xmm2,rbp
        .off = mid.off + (fpprev(val) - val) * lten * ten / 2.0,
  22d4d3:	c4 c1 6b 5c d3       	vsubsd xmm2,xmm2,xmm11
        .off = mid.off + (fpnext(val) - val) * lten * ten / 2.0,
  22d4d8:	c5 f1 14 ca          	vunpcklpd xmm1,xmm1,xmm2
  22d4dc:	c4 c1 7b 12 d0       	vmovddup xmm2,xmm8
  22d4e1:	c5 f1 59 ca          	vmulpd xmm1,xmm1,xmm2
  22d4e5:	c5 fb 12 d4          	vmovddup xmm2,xmm4
  22d4e9:	c5 f1 59 ca          	vmulpd xmm1,xmm1,xmm2
  22d4ed:	c5 f1 59 0d db 2f fd 	vmulpd xmm1,xmm1,XMMWORD PTR [rip+0xfffffffffffd2fdb]        # 2004d0 <__unnamed_27+0x10>
  22d4f4:	ff 
  22d4f5:	c5 fb 12 d6          	vmovddup xmm2,xmm6
  22d4f9:	c5 e9 58 c9          	vaddpd xmm1,xmm2,xmm1
    hp.val += hp.off;
  22d4fd:	c5 e3 58 e1          	vaddsd xmm4,xmm3,xmm1
    hp.off += val - hp.val;
  22d501:	c5 e3 5c d4          	vsubsd xmm2,xmm3,xmm4
  22d505:	c5 e9 14 d3          	vunpcklpd xmm2,xmm2,xmm3
  22d509:	c5 f1 58 d2          	vaddpd xmm2,xmm1,xmm2
  22d50d:	c4 e3 79 05 f2 01    	vpermilpd xmm6,xmm2,0x1
  22d513:	c5 e3 5c f6          	vsubsd xmm6,xmm3,xmm6
    while (high.val > 10.0 or (high.val == 10.0 and high.off >= 0.0)) {
  22d517:	c4 e3 79 05 c9 01    	vpermilpd xmm1,xmm1,0x1
  22d51d:	c5 7b 10 1d d3 37 fd 	vmovsd xmm11,QWORD PTR [rip+0xfffffffffffd37d3]        # 200cf8 <__unnamed_621+0x40>
  22d524:	ff 
  22d525:	c5 79 28 05 f3 2d fd 	vmovapd xmm8,XMMWORD PTR [rip+0xfffffffffffd2df3]        # 200320 <__unnamed_35+0x10>
  22d52c:	ff 
    hp.off += val - hp.val;
  22d52d:	c5 f3 58 ce          	vaddsd xmm1,xmm1,xmm6
    while (high.val > 10.0 or (high.val == 10.0 and high.off >= 0.0)) {
  22d531:	c4 c1 79 2e e6       	vucomisd xmm4,xmm14
  22d536:	0f 86 8a 00 00 00    	jbe    22d5c6 <errol3+0x816>
  22d53c:	eb 13                	jmp    22d551 <errol3+0x7a1>
  22d53e:	66 90                	xchg   ax,ax
  22d540:	c4 c1 79 2e e6       	vucomisd xmm4,xmm14
  22d545:	0f 85 86 00 00 00    	jne    22d5d1 <errol3+0x821>
  22d54b:	0f 8a 80 00 00 00    	jp     22d5d1 <errol3+0x821>
    hp.val /= 10.0;
  22d551:	c4 c1 5b 5e f6       	vdivsd xmm6,xmm4,xmm14
    val -= hp.val * 8.0;
  22d556:	c4 c1 4b 59 eb       	vmulsd xmm5,xmm6,xmm11
    hp.val /= 10.0;
  22d55b:	c4 e3 79 05 fa 01    	vpermilpd xmm7,xmm2,0x1
  22d561:	c4 c1 43 5e fe       	vdivsd xmm7,xmm7,xmm14
    hp.off /= 10.0;
  22d566:	c5 e9 14 c9          	vunpcklpd xmm1,xmm2,xmm1
  22d56a:	c4 c1 71 5e c8       	vdivpd xmm1,xmm1,xmm8
    val -= hp.val * 8.0;
  22d56f:	c4 c1 43 59 db       	vmulsd xmm3,xmm7,xmm11
  22d574:	c4 e3 69 0d d4 01    	vblendpd xmm2,xmm2,xmm4,0x1
  22d57a:	c5 d1 14 db          	vunpcklpd xmm3,xmm5,xmm3
  22d57e:	c5 e9 5c d3          	vsubpd xmm2,xmm2,xmm3
    val -= hp.val * 2.0;
  22d582:	c5 c9 14 df          	vunpcklpd xmm3,xmm6,xmm7
  22d586:	c5 e1 58 db          	vaddpd xmm3,xmm3,xmm3
  22d58a:	c5 e9 5c d3          	vsubpd xmm2,xmm2,xmm3
    hp.off += val / 10.0;
  22d58e:	c4 c1 69 5e d0       	vdivpd xmm2,xmm2,xmm8
  22d593:	c5 f1 58 ca          	vaddpd xmm1,xmm1,xmm2
    hp.val += hp.off;
  22d597:	c5 cb 58 e1          	vaddsd xmm4,xmm6,xmm1
    hp.off += val - hp.val;
  22d59b:	c5 cb 5c d4          	vsubsd xmm2,xmm6,xmm4
  22d59f:	c5 e9 14 d7          	vunpcklpd xmm2,xmm2,xmm7
  22d5a3:	c5 f1 58 d2          	vaddpd xmm2,xmm1,xmm2
  22d5a7:	c4 e3 79 05 da 01    	vpermilpd xmm3,xmm2,0x1
  22d5ad:	c5 c3 5c f3          	vsubsd xmm6,xmm7,xmm3
    while (high.val > 10.0 or (high.val == 10.0 and high.off >= 0.0)) {
  22d5b1:	c4 e3 79 05 c9 01    	vpermilpd xmm1,xmm1,0x1
  22d5b7:	41 83 c4 01          	add    r12d,0x1
    hp.off += val - hp.val;
  22d5bb:	c5 f3 58 ce          	vaddsd xmm1,xmm1,xmm6
    while (high.val > 10.0 or (high.val == 10.0 and high.off >= 0.0)) {
  22d5bf:	c4 c1 79 2e e6       	vucomisd xmm4,xmm14
  22d5c4:	77 8b                	ja     22d551 <errol3+0x7a1>
  22d5c6:	c4 c1 79 2e d2       	vucomisd xmm2,xmm10
  22d5cb:	0f 83 6f ff ff ff    	jae    22d540 <errol3+0x790>
  22d5d1:	c5 d9 14 e1          	vunpcklpd xmm4,xmm4,xmm1
  22d5d5:	c5 79 28 25 43 2d fd 	vmovapd xmm12,XMMWORD PTR [rip+0xfffffffffffd2d43]        # 200320 <__unnamed_35+0x10>
  22d5dc:	ff 
  22d5dd:	c4 41 39 57 c0       	vxorpd xmm8,xmm8,xmm8
    while (high.val < 1.0 or (high.val == 1.0 and high.off < 0.0)) {
  22d5e2:	c5 79 2e cc          	vucomisd xmm9,xmm4
  22d5e6:	0f 86 7e 00 00 00    	jbe    22d66a <errol3+0x8ba>
  22d5ec:	eb 0b                	jmp    22d5f9 <errol3+0x849>
  22d5ee:	66 90                	xchg   ax,ax
  22d5f0:	c4 c1 79 2e e1       	vucomisd xmm4,xmm9
  22d5f5:	75 79                	jne    22d670 <errol3+0x8c0>
  22d5f7:	7a 77                	jp     22d670 <errol3+0x8c0>
    hp.val *= 10.0;
  22d5f9:	c4 c1 5b 59 ce       	vmulsd xmm1,xmm4,xmm14
    off -= val * 8.0;
  22d5fe:	c4 c1 5b 59 eb       	vmulsd xmm5,xmm4,xmm11
  22d603:	c5 f3 5c ed          	vsubsd xmm5,xmm1,xmm5
    off -= val * 2.0;
  22d607:	c5 db 58 fc          	vaddsd xmm7,xmm4,xmm4
  22d60b:	c5 d3 5c ef          	vsubsd xmm5,xmm5,xmm7
    hp.off *= 10.0;
  22d60f:	c4 c1 69 59 fc       	vmulpd xmm7,xmm2,xmm12
  22d614:	c4 e3 79 05 e4 01    	vpermilpd xmm4,xmm4,0x1
  22d61a:	c4 c1 5b 59 e6       	vmulsd xmm4,xmm4,xmm14
    off -= val * 8.0;
  22d61f:	c4 e3 79 05 d2 01    	vpermilpd xmm2,xmm2,0x1
  22d625:	c4 c1 6b 59 db       	vmulsd xmm3,xmm2,xmm11
  22d62a:	c4 e3 79 05 f7 01    	vpermilpd xmm6,xmm7,0x1
  22d630:	c5 cb 5c db          	vsubsd xmm3,xmm6,xmm3
    off -= val * 2.0;
  22d634:	c5 eb 58 d2          	vaddsd xmm2,xmm2,xmm2
  22d638:	c5 e3 5c d2          	vsubsd xmm2,xmm3,xmm2
    hp.off -= off;
  22d63c:	c5 db 5c d2          	vsubsd xmm2,xmm4,xmm2
    hp.val += hp.off;
  22d640:	c5 cb 58 da          	vaddsd xmm3,xmm6,xmm2
    hp.off -= off;
  22d644:	c5 d1 14 e3          	vunpcklpd xmm4,xmm5,xmm3
  22d648:	c5 c1 5c ec          	vsubpd xmm5,xmm7,xmm4
    hp.val += hp.off;
  22d64c:	c5 f1 14 d2          	vunpcklpd xmm2,xmm1,xmm2
  22d650:	c5 e9 58 e5          	vaddpd xmm4,xmm2,xmm5
    hp.off += val - hp.val;
  22d654:	c5 f3 5c cc          	vsubsd xmm1,xmm1,xmm4
  22d658:	c5 d3 58 c9          	vaddsd xmm1,xmm5,xmm1
  22d65c:	c5 f1 14 d3          	vunpcklpd xmm2,xmm1,xmm3
    while (high.val < 1.0 or (high.val == 1.0 and high.off < 0.0)) {
  22d660:	41 83 c4 ff          	add    r12d,0xffffffff
  22d664:	c5 79 2e cc          	vucomisd xmm9,xmm4
  22d668:	77 8f                	ja     22d5f9 <errol3+0x849>
  22d66a:	c5 79 2e c2          	vucomisd xmm8,xmm2
  22d66e:	77 80                	ja     22d5f0 <errol3+0x840>
    while (true) {
  22d670:	c4 e3 79 05 ea 01    	vpermilpd xmm5,xmm2,0x1
  22d676:	b8 01 00 00 00       	mov    eax,0x1
  22d67b:	41 b8 34 0b 00 00    	mov    r8d,0xb34
  22d681:	c4 41 10 57 ed       	vxorps xmm13,xmm13,xmm13
  22d686:	c5 7b 10 0d ca 35 fd 	vmovsd xmm9,QWORD PTR [rip+0xfffffffffffd35ca]        # 200c58 <__unnamed_464+0x48>
  22d68d:	ff 
  22d68e:	c5 7b 10 15 02 36 fd 	vmovsd xmm10,QWORD PTR [rip+0xfffffffffffd3602]        # 200c98 <__unnamed_622+0x20>
  22d695:	ff 
  22d696:	c5 7b 10 05 d2 35 fd 	vmovsd xmm8,QWORD PTR [rip+0xfffffffffffd35d2]        # 200c70 <__unnamed_464+0x60>
  22d69d:	ff 
    if (e >= 0x3FF + 52 or x == 0) {
  22d69e:	c4 c1 79 2e e5       	vucomisd xmm4,xmm13
  22d6a3:	0f 85 ac 00 00 00    	jne    22d755 <errol3+0x9a5>
  22d6a9:	0f 8a a6 00 00 00    	jp     22d755 <errol3+0x9a5>
  22d6af:	e9 1c 01 00 00       	jmp    22d7d0 <errol3+0xa20>
  22d6b4:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  22d6bb:	00 00 00 00 00 
        buffer[buf_index] = hdig + '0';
  22d6c0:	49 8b 0f             	mov    rcx,QWORD PTR [r15]
        high.val -= @intToFloat(f64, hdig);
  22d6c3:	40 0f b6 d5          	movzx  edx,bpl
        buffer[buf_index] = hdig + '0';
  22d6c7:	40 80 c5 30          	add    bpl,0x30
  22d6cb:	40 88 2c 01          	mov    BYTE PTR [rcx+rax*1],bpl
        buf_index += 1;
  22d6cf:	48 83 c0 01          	add    rax,0x1
        high.val -= @intToFloat(f64, hdig);
  22d6d3:	c5 83 2a ca          	vcvtsi2sd xmm1,xmm15,edx
  22d6d7:	c5 db 5c d9          	vsubsd xmm3,xmm4,xmm1
        low.val -= @intToFloat(f64, ldig);
  22d6db:	c5 d3 5c c9          	vsubsd xmm1,xmm5,xmm1
    hp.val *= 10.0;
  22d6df:	c4 c1 63 59 ee       	vmulsd xmm5,xmm3,xmm14
    off -= val * 8.0;
  22d6e4:	c4 c1 63 59 e3       	vmulsd xmm4,xmm3,xmm11
  22d6e9:	c5 d3 5c e4          	vsubsd xmm4,xmm5,xmm4
    off -= val * 2.0;
  22d6ed:	c5 e3 58 db          	vaddsd xmm3,xmm3,xmm3
    hp.off *= 10.0;
  22d6f1:	c5 e9 14 d1          	vunpcklpd xmm2,xmm2,xmm1
  22d6f5:	c4 c1 69 59 d4       	vmulpd xmm2,xmm2,xmm12
  22d6fa:	c4 c1 4b 59 f6       	vmulsd xmm6,xmm6,xmm14
    off -= val * 8.0;
  22d6ff:	c4 c1 73 59 fb       	vmulsd xmm7,xmm1,xmm11
  22d704:	c4 e3 79 05 c2 01    	vpermilpd xmm0,xmm2,0x1
  22d70a:	c5 fb 5c c7          	vsubsd xmm0,xmm0,xmm7
    off -= val * 2.0;
  22d70e:	c5 f3 58 c9          	vaddsd xmm1,xmm1,xmm1
  22d712:	c5 fb 5c c1          	vsubsd xmm0,xmm0,xmm1
    hp.off -= off;
  22d716:	c5 cb 5c c0          	vsubsd xmm0,xmm6,xmm0
    off -= val * 2.0;
  22d71a:	c4 e3 69 0d cc 01    	vblendpd xmm1,xmm2,xmm4,0x1
  22d720:	c5 e1 14 d8          	vunpcklpd xmm3,xmm3,xmm0
  22d724:	c5 f1 5c e3          	vsubpd xmm4,xmm1,xmm3
  22d728:	c5 f1 58 cb          	vaddpd xmm1,xmm1,xmm3
  22d72c:	c4 e3 71 0d dc 01    	vblendpd xmm3,xmm1,xmm4,0x1
    hp.off -= off;
  22d732:	c5 e9 5c d3          	vsubpd xmm2,xmm2,xmm3
    hp.val += hp.off;
  22d736:	c5 d1 14 c0          	vunpcklpd xmm0,xmm5,xmm0
  22d73a:	c5 f9 58 e2          	vaddpd xmm4,xmm0,xmm2
    hp.off += val - hp.val;
  22d73e:	c5 d3 5c c4          	vsubsd xmm0,xmm5,xmm4
  22d742:	c5 eb 58 d0          	vaddsd xmm2,xmm2,xmm0
    while (true) {
  22d746:	c4 e3 79 05 e9 01    	vpermilpd xmm5,xmm1,0x1
  22d74c:	c4 c1 79 2e e5       	vucomisd xmm4,xmm13
  22d751:	75 02                	jne    22d755 <errol3+0x9a5>
  22d753:	7b 7b                	jnp    22d7d0 <errol3+0xa20>
  22d755:	c4 e1 f9 7e e2       	vmovq  rdx,xmm4
  22d75a:	c4 e2 b8 f7 f2       	bextr  rsi,rdx,r8
  22d75f:	c5 f9 28 cc          	vmovapd xmm1,xmm4
  22d763:	48 81 fe 32 04 00 00 	cmp    rsi,0x432
  22d76a:	77 68                	ja     22d7d4 <errol3+0xa24>
    if (u >> 63 != 0) {
  22d76c:	48 85 d2             	test   rdx,rdx
  22d76f:	78 2f                	js     22d7a0 <errol3+0x9f0>
  22d771:	c4 c1 5b 58 ca       	vaddsd xmm1,xmm4,xmm10
  22d776:	c4 c1 73 58 c9       	vaddsd xmm1,xmm1,xmm9
    if (e <= 0x3FF - 1) {
  22d77b:	48 81 fe fe 03 00 00 	cmp    rsi,0x3fe
  22d782:	76 2f                	jbe    22d7b3 <errol3+0xa03>
  22d784:	c5 f3 5c cc          	vsubsd xmm1,xmm1,xmm4
    } else if (y > 0) {
  22d788:	c4 c1 79 2e cd       	vucomisd xmm1,xmm13
  22d78d:	c5 db 58 c9          	vaddsd xmm1,xmm4,xmm1
  22d791:	76 41                	jbe    22d7d4 <errol3+0xa24>
        return x + y - 1;
  22d793:	c4 c1 73 58 c8       	vaddsd xmm1,xmm1,xmm8
  22d798:	eb 3a                	jmp    22d7d4 <errol3+0xa24>
  22d79a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  22d7a0:	c4 c1 5b 58 c9       	vaddsd xmm1,xmm4,xmm9
  22d7a5:	c4 c1 73 58 ca       	vaddsd xmm1,xmm1,xmm10
    if (e <= 0x3FF - 1) {
  22d7aa:	48 81 fe fe 03 00 00 	cmp    rsi,0x3fe
  22d7b1:	77 d1                	ja     22d784 <errol3+0x9d4>
        if (u >> 63 != 0) {
  22d7b3:	c5 79 29 c1          	vmovapd xmm1,xmm8
    if (u >> 63 != 0) {
  22d7b7:	48 85 d2             	test   rdx,rdx
        if (u >> 63 != 0) {
  22d7ba:	78 18                	js     22d7d4 <errol3+0xa24>
  22d7bc:	c5 f1 57 c9          	vxorpd xmm1,xmm1,xmm1
  22d7c0:	eb 12                	jmp    22d7d4 <errol3+0xa24>
  22d7c2:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  22d7c9:	1f 84 00 00 00 00 00 
  22d7d0:	c5 f9 28 cc          	vmovapd xmm1,xmm4
        var hdig = @floatToInt(u8, math.floor(high.val));
  22d7d4:	c5 fb 2c d1          	vcvttsd2si edx,xmm1
        if ((high.val == @intToFloat(f64, hdig)) and (high.off < 0)) hdig -= 1;
  22d7d8:	0f b6 ea             	movzx  ebp,dl
  22d7db:	c5 83 2a cd          	vcvtsi2sd xmm1,xmm15,ebp
  22d7df:	c5 f9 2e e1          	vucomisd xmm4,xmm1
  22d7e3:	0f 9b c3             	setnp  bl
  22d7e6:	0f 94 c1             	sete   cl
  22d7e9:	20 d9                	and    cl,bl
  22d7eb:	c5 79 2e ea          	vucomisd xmm13,xmm2
  22d7ef:	0f 97 c3             	seta   bl
  22d7f2:	20 cb                	and    bl,cl
  22d7f4:	40 28 dd             	sub    bpl,bl
    if (e >= 0x3FF + 52 or x == 0) {
  22d7f7:	c4 c1 79 2e ed       	vucomisd xmm5,xmm13
  22d7fc:	c5 f9 28 cd          	vmovapd xmm1,xmm5
  22d800:	75 02                	jne    22d804 <errol3+0xa54>
  22d802:	7b 6c                	jnp    22d870 <errol3+0xac0>
  22d804:	c4 e1 f9 7e ee       	vmovq  rsi,xmm5
  22d809:	c4 e2 b8 f7 fe       	bextr  rdi,rsi,r8
  22d80e:	c5 f9 28 cd          	vmovapd xmm1,xmm5
  22d812:	48 81 ff 32 04 00 00 	cmp    rdi,0x432
  22d819:	77 55                	ja     22d870 <errol3+0xac0>
    if (u >> 63 != 0) {
  22d81b:	48 85 f6             	test   rsi,rsi
  22d81e:	78 30                	js     22d850 <errol3+0xaa0>
  22d820:	c4 c1 53 58 ca       	vaddsd xmm1,xmm5,xmm10
  22d825:	c4 c1 73 58 c9       	vaddsd xmm1,xmm1,xmm9
    if (e <= 0x3FF - 1) {
  22d82a:	48 81 ff fe 03 00 00 	cmp    rdi,0x3fe
  22d831:	76 30                	jbe    22d863 <errol3+0xab3>
  22d833:	c5 f3 5c cd          	vsubsd xmm1,xmm1,xmm5
    } else if (y > 0) {
  22d837:	c4 c1 79 2e cd       	vucomisd xmm1,xmm13
  22d83c:	c5 d3 58 c9          	vaddsd xmm1,xmm5,xmm1
  22d840:	76 2e                	jbe    22d870 <errol3+0xac0>
        return x + y - 1;
  22d842:	c4 c1 73 58 c8       	vaddsd xmm1,xmm1,xmm8
  22d847:	eb 27                	jmp    22d870 <errol3+0xac0>
  22d849:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  22d850:	c4 c1 53 58 c9       	vaddsd xmm1,xmm5,xmm9
  22d855:	c4 c1 73 58 ca       	vaddsd xmm1,xmm1,xmm10
    if (e <= 0x3FF - 1) {
  22d85a:	48 81 ff fe 03 00 00 	cmp    rdi,0x3fe
  22d861:	77 d0                	ja     22d833 <errol3+0xa83>
        if (u >> 63 != 0) {
  22d863:	c5 79 29 c1          	vmovapd xmm1,xmm8
    if (u >> 63 != 0) {
  22d867:	48 85 f6             	test   rsi,rsi
        if (u >> 63 != 0) {
  22d86a:	78 04                	js     22d870 <errol3+0xac0>
  22d86c:	c5 f1 57 c9          	vxorpd xmm1,xmm1,xmm1
        var ldig = @floatToInt(u8, math.floor(low.val));
  22d870:	c5 fb 2c c9          	vcvttsd2si ecx,xmm1
        if ((low.val == @intToFloat(f64, ldig)) and (low.off < 0)) ldig -= 1;
  22d874:	0f b6 c9             	movzx  ecx,cl
  22d877:	c5 83 2a c9          	vcvtsi2sd xmm1,xmm15,ecx
  22d87b:	c5 f9 2e e9          	vucomisd xmm5,xmm1
  22d87f:	40 0f 9b c6          	setnp  sil
  22d883:	0f 94 c3             	sete   bl
  22d886:	40 20 f3             	and    bl,sil
  22d889:	c4 e3 79 05 f4 01    	vpermilpd xmm6,xmm4,0x1
  22d88f:	c5 79 2e ee          	vucomisd xmm13,xmm6
  22d893:	0f 97 c2             	seta   dl
  22d896:	20 da                	and    dl,bl
  22d898:	28 d1                	sub    cl,dl
        if (ldig != hdig) break;
  22d89a:	40 38 e9             	cmp    cl,bpl
  22d89d:	0f 84 1d fe ff ff    	je     22d6c0 <errol3+0x910>
    const tmp = (high.val + low.val) / 2.0;
  22d8a3:	c5 db 58 c5          	vaddsd xmm0,xmm4,xmm5
  22d8a7:	c5 fb 10 0d d1 33 fd 	vmovsd xmm1,QWORD PTR [rip+0xfffffffffffd33d1]        # 200c80 <__unnamed_622+0x8>
  22d8ae:	ff 
  22d8af:	c5 fb 59 c1          	vmulsd xmm0,xmm0,xmm1
    var mdig = @floatToInt(u8, math.floor(tmp + 0.5));
  22d8b3:	c5 fb 58 c9          	vaddsd xmm1,xmm0,xmm1
    if (e >= 0x3FF + 52 or x == 0) {
  22d8b7:	c5 e9 57 d2          	vxorpd xmm2,xmm2,xmm2
  22d8bb:	c5 f9 2e ca          	vucomisd xmm1,xmm2
  22d8bf:	75 06                	jne    22d8c7 <errol3+0xb17>
  22d8c1:	0f 8b c0 03 00 00    	jnp    22dc87 <errol3+0xed7>
  22d8c7:	c4 e1 f9 7e c9       	vmovq  rcx,xmm1
  22d8cc:	ba 34 0b 00 00       	mov    edx,0xb34
  22d8d1:	c4 e2 e8 f7 d1       	bextr  rdx,rcx,rdx
  22d8d6:	48 81 fa 32 04 00 00 	cmp    rdx,0x432
  22d8dd:	0f 87 a4 03 00 00    	ja     22dc87 <errol3+0xed7>
    if (u >> 63 != 0) {
  22d8e3:	48 85 c9             	test   rcx,rcx
  22d8e6:	0f 88 13 01 00 00    	js     22d9ff <errol3+0xc4f>
  22d8ec:	c4 c1 73 58 d2       	vaddsd xmm2,xmm1,xmm10
  22d8f1:	c4 c1 6b 58 d1       	vaddsd xmm2,xmm2,xmm9
    if (e <= 0x3FF - 1) {
  22d8f6:	48 81 fa fe 03 00 00 	cmp    rdx,0x3fe
  22d8fd:	0f 86 13 01 00 00    	jbe    22da16 <errol3+0xc66>
  22d903:	c5 eb 5c d1          	vsubsd xmm2,xmm2,xmm1
    } else if (y > 0) {
  22d907:	c5 e1 57 db          	vxorpd xmm3,xmm3,xmm3
  22d90b:	c5 f9 2e d3          	vucomisd xmm2,xmm3
  22d90f:	c5 f3 58 ca          	vaddsd xmm1,xmm1,xmm2
  22d913:	0f 86 6e 03 00 00    	jbe    22dc87 <errol3+0xed7>
        return x + y - 1;
  22d919:	c5 f3 58 0d 4f 33 fd 	vaddsd xmm1,xmm1,QWORD PTR [rip+0xfffffffffffd334f]        # 200c70 <__unnamed_464+0x60>
  22d920:	ff 
  22d921:	e9 61 03 00 00       	jmp    22dc87 <errol3+0xed7>
        while (i < mi) : (i += 1) {
  22d926:	45 89 d1             	mov    r9d,r10d
  22d929:	41 83 e1 f0          	and    r9d,0xfffffff0
  22d92d:	41 8d 49 f0          	lea    ecx,[r9-0x10]
  22d931:	89 ca                	mov    edx,ecx
  22d933:	c1 ea 04             	shr    edx,0x4
  22d936:	44 8d 42 01          	lea    r8d,[rdx+0x1]
  22d93a:	83 f9 70             	cmp    ecx,0x70
  22d93d:	0f 83 e5 00 00 00    	jae    22da28 <errol3+0xc78>
  22d943:	c4 e2 7d 59 0d 64 33 	vpbroadcastq ymm1,QWORD PTR [rip+0xfffffffffffd3364]        # 200cb0 <app_mask+0x8>
  22d94a:	fd ff 
  22d94c:	c5 fd 6f d9          	vmovdqa ymm3,ymm1
  22d950:	c5 fd 6f d1          	vmovdqa ymm2,ymm1
  22d954:	c5 fd 6f c1          	vmovdqa ymm0,ymm1
  22d958:	41 f6 c0 07          	test   r8b,0x7
  22d95c:	0f 85 61 01 00 00    	jne    22dac3 <errol3+0xd13>
  22d962:	e9 d6 01 00 00       	jmp    22db3d <errol3+0xd8d>
        while (buffer[j - 1] == '0') {
  22d967:	49 8b 07             	mov    rax,QWORD PTR [r15]
  22d96a:	42 80 7c 20 ff 30    	cmp    BYTE PTR [rax+r12*1-0x1],0x30
  22d970:	0f 85 ed 02 00 00    	jne    22dc63 <errol3+0xeb3>
  22d976:	49 8d 4c 24 ff       	lea    rcx,[r12-0x1]
  22d97b:	4a 8d 14 20          	lea    rdx,[rax+r12*1]
  22d97f:	48 83 c2 ff          	add    rdx,0xffffffffffffffff
  22d983:	4c 89 e0             	mov    rax,r12
  22d986:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  22d98d:	00 00 00 
            buffer[j - 1] = 0;
  22d990:	c6 02 00             	mov    BYTE PTR [rdx],0x0
        while (buffer[j - 1] == '0') {
  22d993:	49 8b 37             	mov    rsi,QWORD PTR [r15]
  22d996:	48 8d 14 0e          	lea    rdx,[rsi+rcx*1]
  22d99a:	48 83 c2 ff          	add    rdx,0xffffffffffffffff
  22d99e:	48 83 c1 ff          	add    rcx,0xffffffffffffffff
  22d9a2:	80 7c 06 fe 30       	cmp    BYTE PTR [rsi+rax*1-0x2],0x30
  22d9a7:	48 8d 40 ff          	lea    rax,[rax-0x1]
  22d9ab:	74 e3                	je     22d990 <errol3+0xbe0>
  22d9ad:	e9 b4 02 00 00       	jmp    22dc66 <errol3+0xeb6>
        } else if ((mid == 0.5) and (buffer[j - 1] & 0x1) != 0) {
  22d9b2:	0f 85 ae 02 00 00    	jne    22dc66 <errol3+0xeb6>
  22d9b8:	0f 8a a8 02 00 00    	jp     22dc66 <errol3+0xeb6>
  22d9be:	49 8b 17             	mov    rdx,QWORD PTR [r15]
  22d9c1:	8a 1c 0a             	mov    bl,BYTE PTR [rdx+rcx*1]
  22d9c4:	f6 c3 01             	test   bl,0x1
  22d9c7:	0f 84 99 02 00 00    	je     22dc66 <errol3+0xeb6>
            buffer[j - 1] += 1;
  22d9cd:	80 c3 01             	add    bl,0x1
  22d9d0:	88 1c 0a             	mov    BYTE PTR [rdx+rcx*1],bl
  22d9d3:	e9 8e 02 00 00       	jmp    22dc66 <errol3+0xeb6>
  22d9d8:	c5 fb 58 d2          	vaddsd xmm2,xmm0,xmm2
  22d9dc:	c5 eb 58 d3          	vaddsd xmm2,xmm2,xmm3
    if (e <= 0x3FF - 1) {
  22d9e0:	48 81 f9 fe 03 00 00 	cmp    rcx,0x3fe
  22d9e7:	0f 87 5d f8 ff ff    	ja     22d24a <errol3+0x49a>
    if (u >> 63 != 0) {
  22d9ed:	48 85 c0             	test   rax,rax
        if (u >> 63 != 0) {
  22d9f0:	0f 88 7c 02 00 00    	js     22dc72 <errol3+0xec2>
  22d9f6:	c5 f9 57 c0          	vxorpd xmm0,xmm0,xmm0
  22d9fa:	e9 56 f9 ff ff       	jmp    22d355 <errol3+0x5a5>
  22d9ff:	c4 c1 73 58 d1       	vaddsd xmm2,xmm1,xmm9
  22da04:	c4 c1 6b 58 d2       	vaddsd xmm2,xmm2,xmm10
    if (e <= 0x3FF - 1) {
  22da09:	48 81 fa fe 03 00 00 	cmp    rdx,0x3fe
  22da10:	0f 87 ed fe ff ff    	ja     22d903 <errol3+0xb53>
    if (u >> 63 != 0) {
  22da16:	48 85 c9             	test   rcx,rcx
        if (u >> 63 != 0) {
  22da19:	0f 88 60 02 00 00    	js     22dc7f <errol3+0xecf>
  22da1f:	c5 f1 57 c9          	vxorpd xmm1,xmm1,xmm1
  22da23:	e9 5f 02 00 00       	jmp    22dc87 <errol3+0xed7>
        while (i < mi) : (i += 1) {
  22da28:	44 89 c1             	mov    ecx,r8d
  22da2b:	83 e1 07             	and    ecx,0x7
  22da2e:	83 c1 ff             	add    ecx,0xffffffff
  22da31:	29 d1                	sub    ecx,edx
  22da33:	c4 e2 7d 59 0d 74 32 	vpbroadcastq ymm1,QWORD PTR [rip+0xfffffffffffd3274]        # 200cb0 <app_mask+0x8>
  22da3a:	fd ff 
  22da3c:	c4 e2 7d 59 25 0b 32 	vpbroadcastq ymm4,QWORD PTR [rip+0xfffffffffffd320b]        # 200c50 <__unnamed_464+0x40>
  22da43:	fd ff 
  22da45:	c5 fd 6f d9          	vmovdqa ymm3,ymm1
  22da49:	c5 fd 6f d1          	vmovdqa ymm2,ymm1
  22da4d:	c5 fd 6f c1          	vmovdqa ymm0,ymm1
  22da51:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  22da58:	0f 1f 84 00 00 00 00 
  22da5f:	00 
            x *= 10;
  22da60:	c5 f5 f4 ec          	vpmuludq ymm5,ymm1,ymm4
  22da64:	c5 f5 73 d1 20       	vpsrlq ymm1,ymm1,0x20
  22da69:	c5 f5 f4 cc          	vpmuludq ymm1,ymm1,ymm4
  22da6d:	c5 f5 73 f1 20       	vpsllq ymm1,ymm1,0x20
  22da72:	c5 d5 d4 c9          	vpaddq ymm1,ymm5,ymm1
  22da76:	c5 e5 f4 ec          	vpmuludq ymm5,ymm3,ymm4
  22da7a:	c5 e5 73 d3 20       	vpsrlq ymm3,ymm3,0x20
  22da7f:	c5 e5 f4 dc          	vpmuludq ymm3,ymm3,ymm4
  22da83:	c5 e5 73 f3 20       	vpsllq ymm3,ymm3,0x20
  22da88:	c5 d5 d4 db          	vpaddq ymm3,ymm5,ymm3
  22da8c:	c5 ed f4 ec          	vpmuludq ymm5,ymm2,ymm4
  22da90:	c5 ed 73 d2 20       	vpsrlq ymm2,ymm2,0x20
  22da95:	c5 ed f4 d4          	vpmuludq ymm2,ymm2,ymm4
  22da99:	c5 ed 73 f2 20       	vpsllq ymm2,ymm2,0x20
  22da9e:	c5 d5 d4 d2          	vpaddq ymm2,ymm5,ymm2
  22daa2:	c5 fd f4 ec          	vpmuludq ymm5,ymm0,ymm4
  22daa6:	c5 fd 73 d0 20       	vpsrlq ymm0,ymm0,0x20
  22daab:	c5 fd f4 c4          	vpmuludq ymm0,ymm0,ymm4
  22daaf:	c5 fd 73 f0 20       	vpsllq ymm0,ymm0,0x20
  22dab4:	c5 d5 d4 c0          	vpaddq ymm0,ymm5,ymm0
  22dab8:	83 c1 08             	add    ecx,0x8
  22dabb:	75 a3                	jne    22da60 <errol3+0xcb0>
  22dabd:	41 f6 c0 07          	test   r8b,0x7
  22dac1:	74 7a                	je     22db3d <errol3+0xd8d>
  22dac3:	44 89 d2             	mov    edx,r10d
  22dac6:	83 e2 70             	and    edx,0x70
  22dac9:	83 c2 f0             	add    edx,0xfffffff0
  22dacc:	c1 ea 04             	shr    edx,0x4
  22dacf:	83 c2 01             	add    edx,0x1
  22dad2:	83 e2 07             	and    edx,0x7
  22dad5:	f7 da                	neg    edx
  22dad7:	c4 e2 7d 59 25 60 31 	vpbroadcastq ymm4,QWORD PTR [rip+0xfffffffffffd3160]        # 200c40 <__unnamed_464+0x30>
  22dade:	fd ff 
  22dae0:	c5 f5 f4 ec          	vpmuludq ymm5,ymm1,ymm4
  22dae4:	c5 f5 73 d1 20       	vpsrlq ymm1,ymm1,0x20
  22dae9:	c5 f5 f4 cc          	vpmuludq ymm1,ymm1,ymm4
  22daed:	c5 f5 73 f1 20       	vpsllq ymm1,ymm1,0x20
  22daf2:	c5 d5 d4 c9          	vpaddq ymm1,ymm5,ymm1
  22daf6:	c5 e5 f4 ec          	vpmuludq ymm5,ymm3,ymm4
  22dafa:	c5 e5 73 d3 20       	vpsrlq ymm3,ymm3,0x20
  22daff:	c5 e5 f4 dc          	vpmuludq ymm3,ymm3,ymm4
  22db03:	c5 e5 73 f3 20       	vpsllq ymm3,ymm3,0x20
  22db08:	c5 d5 d4 db          	vpaddq ymm3,ymm5,ymm3
  22db0c:	c5 ed f4 ec          	vpmuludq ymm5,ymm2,ymm4
  22db10:	c5 ed 73 d2 20       	vpsrlq ymm2,ymm2,0x20
  22db15:	c5 ed f4 d4          	vpmuludq ymm2,ymm2,ymm4
  22db19:	c5 ed 73 f2 20       	vpsllq ymm2,ymm2,0x20
  22db1e:	c5 d5 d4 d2          	vpaddq ymm2,ymm5,ymm2
  22db22:	c5 fd f4 ec          	vpmuludq ymm5,ymm0,ymm4
  22db26:	c5 fd 73 d0 20       	vpsrlq ymm0,ymm0,0x20
  22db2b:	c5 fd f4 c4          	vpmuludq ymm0,ymm0,ymm4
  22db2f:	c5 fd 73 f0 20       	vpsllq ymm0,ymm0,0x20
  22db34:	c5 d5 d4 c0          	vpaddq ymm0,ymm5,ymm0
  22db38:	83 c2 01             	add    edx,0x1
  22db3b:	75 a3                	jne    22dae0 <errol3+0xd30>
  22db3d:	c5 dd 73 d3 20       	vpsrlq ymm4,ymm3,0x20
  22db42:	c5 dd f4 e1          	vpmuludq ymm4,ymm4,ymm1
  22db46:	c5 d5 73 d1 20       	vpsrlq ymm5,ymm1,0x20
  22db4b:	c5 e5 f4 ed          	vpmuludq ymm5,ymm3,ymm5
  22db4f:	c5 d5 d4 e4          	vpaddq ymm4,ymm5,ymm4
  22db53:	c5 dd 73 f4 20       	vpsllq ymm4,ymm4,0x20
  22db58:	c5 e5 f4 c9          	vpmuludq ymm1,ymm3,ymm1
  22db5c:	c5 f5 d4 cc          	vpaddq ymm1,ymm1,ymm4
  22db60:	c5 e5 73 d2 20       	vpsrlq ymm3,ymm2,0x20
  22db65:	c5 e5 f4 d9          	vpmuludq ymm3,ymm3,ymm1
  22db69:	c5 dd 73 d1 20       	vpsrlq ymm4,ymm1,0x20
  22db6e:	c5 ed f4 e4          	vpmuludq ymm4,ymm2,ymm4
  22db72:	c5 dd d4 db          	vpaddq ymm3,ymm4,ymm3
  22db76:	c5 e5 73 f3 20       	vpsllq ymm3,ymm3,0x20
  22db7b:	c5 ed f4 c9          	vpmuludq ymm1,ymm2,ymm1
  22db7f:	c5 f5 d4 cb          	vpaddq ymm1,ymm1,ymm3
  22db83:	c5 ed 73 d0 20       	vpsrlq ymm2,ymm0,0x20
  22db88:	c5 ed f4 d1          	vpmuludq ymm2,ymm2,ymm1
  22db8c:	c5 e5 73 d1 20       	vpsrlq ymm3,ymm1,0x20
  22db91:	c5 fd f4 db          	vpmuludq ymm3,ymm0,ymm3
  22db95:	c5 e5 d4 d2          	vpaddq ymm2,ymm3,ymm2
  22db99:	c5 ed 73 f2 20       	vpsllq ymm2,ymm2,0x20
  22db9e:	c5 fd f4 c1          	vpmuludq ymm0,ymm0,ymm1
  22dba2:	c5 fd d4 c2          	vpaddq ymm0,ymm0,ymm2
  22dba6:	c4 e3 7d 39 c1 01    	vextracti128 xmm1,ymm0,0x1
  22dbac:	c5 ed 73 d0 20       	vpsrlq ymm2,ymm0,0x20
  22dbb1:	c5 ed f4 d1          	vpmuludq ymm2,ymm2,ymm1
  22dbb5:	c5 e5 73 d1 20       	vpsrlq ymm3,ymm1,0x20
  22dbba:	c5 fd f4 db          	vpmuludq ymm3,ymm0,ymm3
  22dbbe:	c5 e5 d4 d2          	vpaddq ymm2,ymm3,ymm2
  22dbc2:	c5 ed 73 f2 20       	vpsllq ymm2,ymm2,0x20
  22dbc7:	c5 fd f4 c1          	vpmuludq ymm0,ymm0,ymm1
  22dbcb:	c5 fd d4 c2          	vpaddq ymm0,ymm0,ymm2
  22dbcf:	c5 f9 70 c8 4e       	vpshufd xmm1,xmm0,0x4e
  22dbd4:	c5 ed 73 d0 20       	vpsrlq ymm2,ymm0,0x20
  22dbd9:	c5 ed f4 d1          	vpmuludq ymm2,ymm2,ymm1
  22dbdd:	c5 e5 73 d1 20       	vpsrlq ymm3,ymm1,0x20
  22dbe2:	c5 fd f4 db          	vpmuludq ymm3,ymm0,ymm3
  22dbe6:	c5 e5 d4 d2          	vpaddq ymm2,ymm3,ymm2
  22dbea:	c5 ed 73 f2 20       	vpsllq ymm2,ymm2,0x20
  22dbef:	c5 fd f4 c1          	vpmuludq ymm0,ymm0,ymm1
  22dbf3:	c5 fd d4 c2          	vpaddq ymm0,ymm0,ymm2
  22dbf7:	c4 e1 f9 7e c2       	vmovq  rdx,xmm0
  22dbfc:	45 39 ca             	cmp    r10d,r9d
        while (i < mi) : (i += 1) {
  22dbff:	74 1b                	je     22dc1c <errol3+0xe6c>
  22dc01:	41 09 c1             	or     r9d,eax
  22dc04:	44 89 c8             	mov    eax,r9d
            x *= 10;
  22dc07:	f7 d8                	neg    eax
  22dc09:	29 d8                	sub    eax,ebx
  22dc0b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  22dc10:	48 01 d2             	add    rdx,rdx
  22dc13:	48 8d 14 92          	lea    rdx,[rdx+rdx*4]
        while (i < mi) : (i += 1) {
  22dc17:	83 c0 ff             	add    eax,0xffffffff
  22dc1a:	75 f4                	jne    22dc10 <errol3+0xe60>
    const m64 = @truncate(u64, @divTrunc(mid, x));
  22dc1c:	31 c9                	xor    ecx,ecx
  22dc1e:	c5 f8 77             	vzeroupper 
  22dc21:	e8 2a 48 00 00       	call   232450 <__udivti3>
    if (lf != hf) {
  22dc26:	4d 39 f5             	cmp    r13,r14
    if (lf != hf) mi += 19;
  22dc29:	44 0f 45 e5          	cmovne r12d,ebp
    var buf_index = u64toa(m64, buffer) - 1;
  22dc2d:	48 89 c7             	mov    rdi,rax
  22dc30:	4c 89 fe             	mov    rsi,r15
  22dc33:	e8 a8 00 00 00       	call   22dce0 <u64toa>
    if (mi != 0) {
  22dc38:	45 85 e4             	test   r12d,r12d
  22dc3b:	74 19                	je     22dc56 <errol3+0xea6>
  22dc3d:	48 89 c1             	mov    rcx,rax
  22dc40:	48 83 c1 ff          	add    rcx,0xffffffffffffffff
        buffer[buf_index - 1] += @boolToInt(buffer[buf_index] >= '5');
  22dc44:	49 8b 17             	mov    rdx,QWORD PTR [r15]
  22dc47:	80 7c 02 ff 34       	cmp    BYTE PTR [rdx+rax*1-0x1],0x34
  22dc4c:	0f 97 c3             	seta   bl
  22dc4f:	00 5c 02 fe          	add    BYTE PTR [rdx+rax*1-0x2],bl
  22dc53:	48 89 c8             	mov    rax,rcx
  22dc56:	4c 8b 74 24 20       	mov    r14,QWORD PTR [rsp+0x20]
        .digits = buffer[0..buf_index],
  22dc5b:	49 8b 0f             	mov    rcx,QWORD PTR [r15]
        .exp = @intCast(i32, buf_index) + mi,
  22dc5e:	41 01 c4             	add    r12d,eax
  22dc61:	eb 57                	jmp    22dcba <errol3+0xf0a>
  22dc63:	4c 89 e0             	mov    rax,r12
    buffer[j] = 0;
  22dc66:	49 8b 0f             	mov    rcx,QWORD PTR [r15]
  22dc69:	c6 04 01 00          	mov    BYTE PTR [rcx+rax*1],0x0
        .digits = buffer[0..j],
  22dc6d:	49 8b 0f             	mov    rcx,QWORD PTR [r15]
  22dc70:	eb 48                	jmp    22dcba <errol3+0xf0a>
  22dc72:	c5 fb 10 05 f6 2f fd 	vmovsd xmm0,QWORD PTR [rip+0xfffffffffffd2ff6]        # 200c70 <__unnamed_464+0x60>
  22dc79:	ff 
  22dc7a:	e9 d6 f6 ff ff       	jmp    22d355 <errol3+0x5a5>
  22dc7f:	c5 fb 10 0d e9 2f fd 	vmovsd xmm1,QWORD PTR [rip+0xfffffffffffd2fe9]        # 200c70 <__unnamed_464+0x60>
  22dc86:	ff 
    var mdig = @floatToInt(u8, math.floor(tmp + 0.5));
  22dc87:	c5 fb 2c c9          	vcvttsd2si ecx,xmm1
    if ((@intToFloat(f64, mdig) - tmp) == 0.5 and (mdig & 0x1) != 0) mdig -= 1;
  22dc8b:	0f b6 c9             	movzx  ecx,cl
  22dc8e:	c5 83 2a c9          	vcvtsi2sd xmm1,xmm15,ecx
  22dc92:	c5 f3 5c c0          	vsubsd xmm0,xmm1,xmm0
  22dc96:	c5 f9 2e 05 e2 2f fd 	vucomisd xmm0,QWORD PTR [rip+0xfffffffffffd2fe2]        # 200c80 <__unnamed_622+0x8>
  22dc9d:	ff 
  22dc9e:	0f 9b c2             	setnp  dl
  22dca1:	0f 94 c3             	sete   bl
  22dca4:	20 d3                	and    bl,dl
  22dca6:	20 cb                	and    bl,cl
    buffer[buf_index] = mdig + '0';
  22dca8:	49 8b 17             	mov    rdx,QWORD PTR [r15]
    if ((@intToFloat(f64, mdig) - tmp) == 0.5 and (mdig & 0x1) != 0) mdig -= 1;
  22dcab:	28 d9                	sub    cl,bl
    buffer[buf_index] = mdig + '0';
  22dcad:	80 c1 30             	add    cl,0x30
  22dcb0:	88 0c 02             	mov    BYTE PTR [rdx+rax*1],cl
        .digits = buffer[1..buf_index],
  22dcb3:	49 8b 0f             	mov    rcx,QWORD PTR [r15]
  22dcb6:	48 83 c1 01          	add    rcx,0x1
    return errol3u(value, buffer);
  22dcba:	49 89 0e             	mov    QWORD PTR [r14],rcx
  22dcbd:	49 89 46 08          	mov    QWORD PTR [r14+0x8],rax
  22dcc1:	45 89 66 10          	mov    DWORD PTR [r14+0x10],r12d
  22dcc5:	48 83 c4 68          	add    rsp,0x68
  22dcc9:	5b                   	pop    rbx
  22dcca:	41 5c                	pop    r12
  22dccc:	41 5d                	pop    r13
  22dcce:	41 5e                	pop    r14
  22dcd0:	41 5f                	pop    r15
  22dcd2:	5d                   	pop    rbp
  22dcd3:	c3                   	ret    
            @panic("assertion failure");
  22dcd4:	48 8d 3d b5 20 02 00 	lea    rdi,[rip+0x220b5]        # 24fd90 <__unnamed_2>
  22dcdb:	e8 40 4a fe ff       	call   212720 <panic>

000000000022dce0 <u64toa>:
    if (value < kTen8) {
  22dce0:	41 57                	push   r15
  22dce2:	41 56                	push   r14
  22dce4:	53                   	push   rbx
  22dce5:	48 81 ff ff e0 f5 05 	cmp    rdi,0x5f5e0ff
  22dcec:	77 4b                	ja     22dd39 <u64toa+0x59>
            const b: u32 = v / 10000;
  22dcee:	89 f8                	mov    eax,edi
        if (v < 10000) {
  22dcf0:	81 ff 0f 27 00 00    	cmp    edi,0x270f
  22dcf6:	0f 87 48 01 00 00    	ja     22de44 <u64toa+0x164>
            const d1: u32 = (v / 100) << 1;
  22dcfc:	48 69 d0 1f 85 eb 51 	imul   rdx,rax,0x51eb851f
  22dd03:	48 c1 ea 25          	shr    rdx,0x25
            const d2: u32 = (v % 100) << 1;
  22dd07:	6b c2 64             	imul   eax,edx,0x64
            const d1: u32 = (v / 100) << 1;
  22dd0a:	48 01 d2             	add    rdx,rdx
            const d2: u32 = (v % 100) << 1;
  22dd0d:	89 f9                	mov    ecx,edi
  22dd0f:	29 c1                	sub    ecx,eax
  22dd11:	48 01 c9             	add    rcx,rcx
            if (v >= 1000) {
  22dd14:	81 ff e8 03 00 00    	cmp    edi,0x3e8
  22dd1a:	0f 82 bf 01 00 00    	jb     22dedf <u64toa+0x1ff>
                buffer[buf_index] = c_digits_lut[d1];
  22dd20:	48 8b 06             	mov    rax,QWORD PTR [rsi]
  22dd23:	48 8d 3d ee 7f fd ff 	lea    rdi,[rip+0xfffffffffffd7fee]        # 205d18 <c_digits_lut>
  22dd2a:	8a 1c 3a             	mov    bl,BYTE PTR [rdx+rdi*1]
  22dd2d:	88 18                	mov    BYTE PTR [rax],bl
  22dd2f:	b8 01 00 00 00       	mov    eax,0x1
  22dd34:	e9 b1 01 00 00       	jmp    22deea <u64toa+0x20a>
  22dd39:	48 b9 00 00 c1 6f f2 	movabs rcx,0x2386f26fc10000
  22dd40:	86 23 00 
    } else if (value < kTen16) {
  22dd43:	48 39 cf             	cmp    rdi,rcx
  22dd46:	0f 83 71 01 00 00    	jae    22debd <u64toa+0x1dd>
        const v0: u32 = @intCast(u32, value / kTen8);
  22dd4c:	48 b8 fd ce 61 84 11 	movabs rax,0xabcc77118461cefd
  22dd53:	77 cc ab 
  22dd56:	48 89 fa             	mov    rdx,rdi
  22dd59:	c4 62 fb f6 f8       	mulx   r15,rax,rax
  22dd5e:	49 c1 ef 1a          	shr    r15,0x1a
        const v1: u32 = @intCast(u32, value % kTen8);
  22dd62:	49 69 cf 00 e1 f5 05 	imul   rcx,r15,0x5f5e100
  22dd69:	48 89 f8             	mov    rax,rdi
  22dd6c:	48 29 c8             	sub    rax,rcx
        const b0: u32 = v0 / 10000;
  22dd6f:	44 89 fb             	mov    ebx,r15d
  22dd72:	41 be 59 17 b7 d1    	mov    r14d,0xd1b71759
        const d1: u32 = (b0 / 100) << 1;
  22dd78:	48 69 cb 83 de 1b 43 	imul   rcx,rbx,0x431bde83
        const b0: u32 = v0 / 10000;
  22dd7f:	49 0f af de          	imul   rbx,r14
  22dd83:	48 c1 eb 2d          	shr    rbx,0x2d
        const c0: u32 = v0 % 10000;
  22dd87:	69 d3 10 27 00 00    	imul   edx,ebx,0x2710
  22dd8d:	41 29 d7             	sub    r15d,edx
        const d1: u32 = (b0 / 100) << 1;
  22dd90:	48 c1 e9 31          	shr    rcx,0x31
  22dd94:	81 e1 fe 3f 00 00    	and    ecx,0x3ffe
        const d2: u32 = (b0 % 100) << 1;
  22dd9a:	48 69 d3 1f 85 eb 51 	imul   rdx,rbx,0x51eb851f
  22dda1:	48 c1 ea 25          	shr    rdx,0x25
  22dda5:	6b d2 64             	imul   edx,edx,0x64
  22dda8:	29 d3                	sub    ebx,edx
  22ddaa:	48 01 db             	add    rbx,rbx
        const d3: u32 = (c0 / 100) << 1;
  22ddad:	4d 69 df 1f 85 eb 51 	imul   r11,r15,0x51eb851f
  22ddb4:	49 c1 eb 25          	shr    r11,0x25
        const d4: u32 = (c0 % 100) << 1;
  22ddb8:	41 6b d3 64          	imul   edx,r11d,0x64
        const d3: u32 = (c0 / 100) << 1;
  22ddbc:	4d 01 db             	add    r11,r11
        const d4: u32 = (c0 % 100) << 1;
  22ddbf:	41 29 d7             	sub    r15d,edx
  22ddc2:	4d 01 ff             	add    r15,r15
        const b1: u32 = v1 / 10000;
  22ddc5:	4c 0f af f0          	imul   r14,rax
  22ddc9:	49 c1 ee 2d          	shr    r14,0x2d
        const c1: u32 = v1 % 10000;
  22ddcd:	41 69 d6 10 27 00 00 	imul   edx,r14d,0x2710
        const d5: u32 = (b1 / 100) << 1;
  22ddd4:	4c 69 c8 83 de 1b 43 	imul   r9,rax,0x431bde83
        const c1: u32 = v1 % 10000;
  22dddb:	41 89 c0             	mov    r8d,eax
  22ddde:	41 29 d0             	sub    r8d,edx
        const d5: u32 = (b1 / 100) << 1;
  22dde1:	49 c1 e9 31          	shr    r9,0x31
  22dde5:	41 81 e1 fe 01 00 00 	and    r9d,0x1fe
        const d6: u32 = (b1 % 100) << 1;
  22ddec:	49 69 c6 1f 85 eb 51 	imul   rax,r14,0x51eb851f
  22ddf3:	48 c1 e8 25          	shr    rax,0x25
  22ddf7:	6b c0 64             	imul   eax,eax,0x64
  22ddfa:	41 29 c6             	sub    r14d,eax
  22ddfd:	4d 01 f6             	add    r14,r14
        const d7: u32 = (c1 / 100) << 1;
  22de00:	4d 69 d0 1f 85 eb 51 	imul   r10,r8,0x51eb851f
  22de07:	49 c1 ea 25          	shr    r10,0x25
        const d8: u32 = (c1 % 100) << 1;
  22de0b:	41 6b c2 64          	imul   eax,r10d,0x64
        const d7: u32 = (c1 / 100) << 1;
  22de0f:	4d 01 d2             	add    r10,r10
        const d8: u32 = (c1 % 100) << 1;
  22de12:	41 29 c0             	sub    r8d,eax
  22de15:	4d 01 c0             	add    r8,r8
        if (value >= kTen15) {
  22de18:	48 b8 00 80 c6 a4 7e 	movabs rax,0x38d7ea4c68000
  22de1f:	8d 03 00 
  22de22:	48 39 c7             	cmp    rdi,rax
  22de25:	0f 82 07 01 00 00    	jb     22df32 <u64toa+0x252>
            buffer[buf_index] = c_digits_lut[d1];
  22de2b:	48 8b 06             	mov    rax,QWORD PTR [rsi]
  22de2e:	48 8d 15 e3 7e fd ff 	lea    rdx,[rip+0xfffffffffffd7ee3]        # 205d18 <c_digits_lut>
  22de35:	8a 14 11             	mov    dl,BYTE PTR [rcx+rdx*1]
  22de38:	88 10                	mov    BYTE PTR [rax],dl
  22de3a:	b8 01 00 00 00       	mov    eax,0x1
  22de3f:	e9 03 01 00 00       	jmp    22df47 <u64toa+0x267>
            const b: u32 = v / 10000;
  22de44:	ba 59 17 b7 d1       	mov    edx,0xd1b71759
  22de49:	48 0f af d0          	imul   rdx,rax
  22de4d:	48 c1 ea 2d          	shr    rdx,0x2d
            const c: u32 = v % 10000;
  22de51:	69 da 10 27 00 00    	imul   ebx,edx,0x2710
  22de57:	89 f9                	mov    ecx,edi
  22de59:	29 d9                	sub    ecx,ebx
            const d1: u32 = (b / 100) << 1;
  22de5b:	48 69 d8 83 de 1b 43 	imul   rbx,rax,0x431bde83
  22de62:	48 c1 eb 31          	shr    rbx,0x31
            const d2: u32 = (b % 100) << 1;
  22de66:	48 69 c2 1f 85 eb 51 	imul   rax,rdx,0x51eb851f
  22de6d:	48 c1 e8 25          	shr    rax,0x25
  22de71:	6b c0 64             	imul   eax,eax,0x64
            const d1: u32 = (b / 100) << 1;
  22de74:	81 e3 fe 3f 00 00    	and    ebx,0x3ffe
            const d2: u32 = (b % 100) << 1;
  22de7a:	29 c2                	sub    edx,eax
  22de7c:	48 01 d2             	add    rdx,rdx
            const d3: u32 = (c / 100) << 1;
  22de7f:	4c 69 c1 1f 85 eb 51 	imul   r8,rcx,0x51eb851f
  22de86:	49 c1 e8 25          	shr    r8,0x25
            const d4: u32 = (c % 100) << 1;
  22de8a:	41 6b c0 64          	imul   eax,r8d,0x64
            const d3: u32 = (c / 100) << 1;
  22de8e:	4d 01 c0             	add    r8,r8
            const d4: u32 = (c % 100) << 1;
  22de91:	29 c1                	sub    ecx,eax
  22de93:	48 01 c9             	add    rcx,rcx
            if (value >= 10000000) {
  22de96:	48 81 ff 80 96 98 00 	cmp    rdi,0x989680
  22de9d:	0f 82 b0 01 00 00    	jb     22e053 <u64toa+0x373>
                buffer[buf_index] = c_digits_lut[d1];
  22dea3:	4c 8b 0e             	mov    r9,QWORD PTR [rsi]
  22dea6:	48 8d 3d 6b 7e fd ff 	lea    rdi,[rip+0xfffffffffffd7e6b]        # 205d18 <c_digits_lut>
  22dead:	8a 04 3b             	mov    al,BYTE PTR [rbx+rdi*1]
  22deb0:	41 88 01             	mov    BYTE PTR [r9],al
  22deb3:	b8 01 00 00 00       	mov    eax,0x1
  22deb8:	e9 a5 01 00 00       	jmp    22e062 <u64toa+0x382>
        value %= kTen16;
  22debd:	31 d2                	xor    edx,edx
  22debf:	48 89 f8             	mov    rax,rdi
  22dec2:	48 f7 f1             	div    rcx
        if (a < 10) {
  22dec5:	83 f8 09             	cmp    eax,0x9
  22dec8:	0f 87 0e 02 00 00    	ja     22e0dc <u64toa+0x3fc>
            buffer[buf_index] = '0' + @intCast(u8, a);
  22dece:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  22ded1:	04 30                	add    al,0x30
  22ded3:	88 01                	mov    BYTE PTR [rcx],al
  22ded5:	b8 01 00 00 00       	mov    eax,0x1
  22deda:	e9 06 03 00 00       	jmp    22e1e5 <u64toa+0x505>
  22dedf:	31 c0                	xor    eax,eax
            if (v >= 100) {
  22dee1:	83 ff 64             	cmp    edi,0x64
  22dee4:	0f 82 21 02 00 00    	jb     22e10b <u64toa+0x42b>
                buffer[buf_index] = c_digits_lut[d1 + 1];
  22deea:	48 8b 3e             	mov    rdi,QWORD PTR [rsi]
  22deed:	83 ca 01             	or     edx,0x1
  22def0:	48 8d 1d 21 7e fd ff 	lea    rbx,[rip+0xfffffffffffd7e21]        # 205d18 <c_digits_lut>
  22def7:	8a 14 1a             	mov    dl,BYTE PTR [rdx+rbx*1]
  22defa:	88 14 07             	mov    BYTE PTR [rdi+rax*1],dl
                buf_index += 1;
  22defd:	48 83 c0 01          	add    rax,0x1
                buffer[buf_index] = c_digits_lut[d2];
  22df01:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  22df04:	48 8d 3d 0d 7e fd ff 	lea    rdi,[rip+0xfffffffffffd7e0d]        # 205d18 <c_digits_lut>
  22df0b:	8a 1c 39             	mov    bl,BYTE PTR [rcx+rdi*1]
  22df0e:	88 1c 02             	mov    BYTE PTR [rdx+rax*1],bl
                buf_index += 1;
  22df11:	48 83 c0 01          	add    rax,0x1
            buffer[buf_index] = c_digits_lut[d2 + 1];
  22df15:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  22df18:	83 c9 01             	or     ecx,0x1
  22df1b:	48 8d 35 f6 7d fd ff 	lea    rsi,[rip+0xfffffffffffd7df6]        # 205d18 <c_digits_lut>
  22df22:	8a 0c 31             	mov    cl,BYTE PTR [rcx+rsi*1]
  22df25:	88 0c 02             	mov    BYTE PTR [rdx+rax*1],cl
            buf_index += 1;
  22df28:	48 83 c0 01          	add    rax,0x1
    return buf_index;
  22df2c:	5b                   	pop    rbx
  22df2d:	41 5e                	pop    r14
  22df2f:	41 5f                	pop    r15
  22df31:	c3                   	ret    
        if (value >= kTen14) {
  22df32:	48 b8 00 40 7a 10 f3 	movabs rax,0x5af3107a4000
  22df39:	5a 00 00 
  22df3c:	48 39 c7             	cmp    rdi,rax
  22df3f:	0f 82 d4 01 00 00    	jb     22e119 <u64toa+0x439>
  22df45:	31 c0                	xor    eax,eax
            buffer[buf_index] = c_digits_lut[d1 + 1];
  22df47:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  22df4a:	83 c9 01             	or     ecx,0x1
  22df4d:	48 8d 3d c4 7d fd ff 	lea    rdi,[rip+0xfffffffffffd7dc4]        # 205d18 <c_digits_lut>
  22df54:	8a 0c 39             	mov    cl,BYTE PTR [rcx+rdi*1]
  22df57:	88 0c 02             	mov    BYTE PTR [rdx+rax*1],cl
            buf_index += 1;
  22df5a:	48 83 c0 01          	add    rax,0x1
            buffer[buf_index] = c_digits_lut[d2];
  22df5e:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  22df61:	48 8d 15 b0 7d fd ff 	lea    rdx,[rip+0xfffffffffffd7db0]        # 205d18 <c_digits_lut>
  22df68:	8a 14 13             	mov    dl,BYTE PTR [rbx+rdx*1]
  22df6b:	88 14 01             	mov    BYTE PTR [rcx+rax*1],dl
            buf_index += 1;
  22df6e:	48 83 c0 01          	add    rax,0x1
            buffer[buf_index] = c_digits_lut[d2 + 1];
  22df72:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  22df75:	83 cb 01             	or     ebx,0x1
  22df78:	48 8d 15 99 7d fd ff 	lea    rdx,[rip+0xfffffffffffd7d99]        # 205d18 <c_digits_lut>
  22df7f:	8a 14 13             	mov    dl,BYTE PTR [rbx+rdx*1]
  22df82:	88 14 01             	mov    BYTE PTR [rcx+rax*1],dl
            buf_index += 1;
  22df85:	48 83 c0 01          	add    rax,0x1
            buffer[buf_index] = c_digits_lut[d3];
  22df89:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  22df8c:	48 8d 15 85 7d fd ff 	lea    rdx,[rip+0xfffffffffffd7d85]        # 205d18 <c_digits_lut>
  22df93:	41 8a 14 13          	mov    dl,BYTE PTR [r11+rdx*1]
  22df97:	88 14 01             	mov    BYTE PTR [rcx+rax*1],dl
            buf_index += 1;
  22df9a:	48 83 c0 01          	add    rax,0x1
            buffer[buf_index] = c_digits_lut[d3 + 1];
  22df9e:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  22dfa1:	41 83 cb 01          	or     r11d,0x1
  22dfa5:	48 8d 15 6c 7d fd ff 	lea    rdx,[rip+0xfffffffffffd7d6c]        # 205d18 <c_digits_lut>
  22dfac:	41 8a 14 13          	mov    dl,BYTE PTR [r11+rdx*1]
  22dfb0:	88 14 01             	mov    BYTE PTR [rcx+rax*1],dl
            buf_index += 1;
  22dfb3:	48 83 c0 01          	add    rax,0x1
            buffer[buf_index] = c_digits_lut[d4];
  22dfb7:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  22dfba:	48 8d 15 57 7d fd ff 	lea    rdx,[rip+0xfffffffffffd7d57]        # 205d18 <c_digits_lut>
  22dfc1:	41 8a 14 17          	mov    dl,BYTE PTR [r15+rdx*1]
  22dfc5:	88 14 01             	mov    BYTE PTR [rcx+rax*1],dl
            buf_index += 1;
  22dfc8:	48 83 c0 01          	add    rax,0x1
            buffer[buf_index] = c_digits_lut[d4 + 1];
  22dfcc:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  22dfcf:	41 83 cf 01          	or     r15d,0x1
  22dfd3:	48 8d 0d 3e 7d fd ff 	lea    rcx,[rip+0xfffffffffffd7d3e]        # 205d18 <c_digits_lut>
  22dfda:	41 8a 1c 0f          	mov    bl,BYTE PTR [r15+rcx*1]
  22dfde:	88 1c 02             	mov    BYTE PTR [rdx+rax*1],bl
        buffer[buf_index] = c_digits_lut[d5];
  22dfe1:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  22dfe4:	41 8a 1c 09          	mov    bl,BYTE PTR [r9+rcx*1]
  22dfe8:	88 5c 02 01          	mov    BYTE PTR [rdx+rax*1+0x1],bl
        buffer[buf_index] = c_digits_lut[d5 + 1];
  22dfec:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  22dfef:	41 83 c9 01          	or     r9d,0x1
  22dff3:	41 8a 1c 09          	mov    bl,BYTE PTR [r9+rcx*1]
  22dff7:	88 5c 02 02          	mov    BYTE PTR [rdx+rax*1+0x2],bl
        buffer[buf_index] = c_digits_lut[d6];
  22dffb:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  22dffe:	41 8a 1c 0e          	mov    bl,BYTE PTR [r14+rcx*1]
  22e002:	88 5c 02 03          	mov    BYTE PTR [rdx+rax*1+0x3],bl
        buffer[buf_index] = c_digits_lut[d6 + 1];
  22e006:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  22e009:	41 83 ce 01          	or     r14d,0x1
  22e00d:	41 8a 1c 0e          	mov    bl,BYTE PTR [r14+rcx*1]
  22e011:	88 5c 02 04          	mov    BYTE PTR [rdx+rax*1+0x4],bl
        buffer[buf_index] = c_digits_lut[d7];
  22e015:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  22e018:	41 8a 1c 0a          	mov    bl,BYTE PTR [r10+rcx*1]
  22e01c:	88 5c 02 05          	mov    BYTE PTR [rdx+rax*1+0x5],bl
        buffer[buf_index] = c_digits_lut[d7 + 1];
  22e020:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  22e023:	41 83 ca 01          	or     r10d,0x1
  22e027:	41 8a 1c 0a          	mov    bl,BYTE PTR [r10+rcx*1]
  22e02b:	88 5c 02 06          	mov    BYTE PTR [rdx+rax*1+0x6],bl
        buffer[buf_index] = c_digits_lut[d8];
  22e02f:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  22e032:	41 8a 1c 08          	mov    bl,BYTE PTR [r8+rcx*1]
  22e036:	88 5c 02 07          	mov    BYTE PTR [rdx+rax*1+0x7],bl
        buffer[buf_index] = c_digits_lut[d8 + 1];
  22e03a:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  22e03d:	41 83 c8 01          	or     r8d,0x1
  22e041:	41 8a 0c 08          	mov    cl,BYTE PTR [r8+rcx*1]
  22e045:	88 4c 02 08          	mov    BYTE PTR [rdx+rax*1+0x8],cl
        buf_index += 1;
  22e049:	48 83 c0 09          	add    rax,0x9
    return buf_index;
  22e04d:	5b                   	pop    rbx
  22e04e:	41 5e                	pop    r14
  22e050:	41 5f                	pop    r15
  22e052:	c3                   	ret    
  22e053:	31 c0                	xor    eax,eax
            if (value >= 1000000) {
  22e055:	48 81 ff 40 42 0f 00 	cmp    rdi,0xf4240
  22e05c:	0f 82 cd 00 00 00    	jb     22e12f <u64toa+0x44f>
                buffer[buf_index] = c_digits_lut[d1 + 1];
  22e062:	4c 8b 0e             	mov    r9,QWORD PTR [rsi]
  22e065:	83 cb 01             	or     ebx,0x1
  22e068:	48 8d 3d a9 7c fd ff 	lea    rdi,[rip+0xfffffffffffd7ca9]        # 205d18 <c_digits_lut>
  22e06f:	8a 1c 3b             	mov    bl,BYTE PTR [rbx+rdi*1]
  22e072:	41 88 1c 01          	mov    BYTE PTR [r9+rax*1],bl
                buf_index += 1;
  22e076:	48 83 c0 01          	add    rax,0x1
                buffer[buf_index] = c_digits_lut[d2];
  22e07a:	48 8b 3e             	mov    rdi,QWORD PTR [rsi]
  22e07d:	48 8d 1d 94 7c fd ff 	lea    rbx,[rip+0xfffffffffffd7c94]        # 205d18 <c_digits_lut>
  22e084:	8a 1c 1a             	mov    bl,BYTE PTR [rdx+rbx*1]
  22e087:	88 1c 07             	mov    BYTE PTR [rdi+rax*1],bl
                buf_index += 1;
  22e08a:	48 83 c0 01          	add    rax,0x1
            buffer[buf_index] = c_digits_lut[d2 + 1];
  22e08e:	48 8b 1e             	mov    rbx,QWORD PTR [rsi]
  22e091:	83 ca 01             	or     edx,0x1
  22e094:	48 8d 3d 7d 7c fd ff 	lea    rdi,[rip+0xfffffffffffd7c7d]        # 205d18 <c_digits_lut>
  22e09b:	8a 14 3a             	mov    dl,BYTE PTR [rdx+rdi*1]
  22e09e:	88 14 03             	mov    BYTE PTR [rbx+rax*1],dl
            buffer[buf_index] = c_digits_lut[d3];
  22e0a1:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  22e0a4:	41 8a 1c 38          	mov    bl,BYTE PTR [r8+rdi*1]
  22e0a8:	88 5c 02 01          	mov    BYTE PTR [rdx+rax*1+0x1],bl
            buffer[buf_index] = c_digits_lut[d3 + 1];
  22e0ac:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  22e0af:	41 83 c8 01          	or     r8d,0x1
  22e0b3:	41 8a 1c 38          	mov    bl,BYTE PTR [r8+rdi*1]
  22e0b7:	88 5c 02 02          	mov    BYTE PTR [rdx+rax*1+0x2],bl
            buffer[buf_index] = c_digits_lut[d4];
  22e0bb:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  22e0be:	8a 1c 39             	mov    bl,BYTE PTR [rcx+rdi*1]
  22e0c1:	88 5c 02 03          	mov    BYTE PTR [rdx+rax*1+0x3],bl
            buffer[buf_index] = c_digits_lut[d4 + 1];
  22e0c5:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  22e0c8:	83 c9 01             	or     ecx,0x1
  22e0cb:	8a 0c 39             	mov    cl,BYTE PTR [rcx+rdi*1]
  22e0ce:	88 4c 02 04          	mov    BYTE PTR [rdx+rax*1+0x4],cl
            buf_index += 1;
  22e0d2:	48 83 c0 05          	add    rax,0x5
    return buf_index;
  22e0d6:	5b                   	pop    rbx
  22e0d7:	41 5e                	pop    r14
  22e0d9:	41 5f                	pop    r15
  22e0db:	c3                   	ret    
        } else if (a < 100) {
  22e0dc:	83 f8 63             	cmp    eax,0x63
  22e0df:	77 60                	ja     22e141 <u64toa+0x461>
            buffer[buf_index] = c_digits_lut[i];
  22e0e1:	89 c0                	mov    eax,eax
  22e0e3:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  22e0e6:	48 8d 3d 2b 7c fd ff 	lea    rdi,[rip+0xfffffffffffd7c2b]        # 205d18 <c_digits_lut>
  22e0ed:	8a 1c 47             	mov    bl,BYTE PTR [rdi+rax*2]
            const i: u32 = a << 1;
  22e0f0:	48 01 c0             	add    rax,rax
            buffer[buf_index] = c_digits_lut[i];
  22e0f3:	88 19                	mov    BYTE PTR [rcx],bl
            buffer[buf_index] = c_digits_lut[i + 1];
  22e0f5:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  22e0f8:	83 c8 01             	or     eax,0x1
  22e0fb:	8a 04 38             	mov    al,BYTE PTR [rax+rdi*1]
  22e0fe:	88 41 01             	mov    BYTE PTR [rcx+0x1],al
  22e101:	b8 02 00 00 00       	mov    eax,0x2
  22e106:	e9 da 00 00 00       	jmp    22e1e5 <u64toa+0x505>
            if (v >= 10) {
  22e10b:	83 ff 0a             	cmp    edi,0xa
  22e10e:	0f 83 ed fd ff ff    	jae    22df01 <u64toa+0x221>
  22e114:	e9 fc fd ff ff       	jmp    22df15 <u64toa+0x235>
        if (value >= kTen13) {
  22e119:	48 89 f8             	mov    rax,rdi
  22e11c:	48 c1 e8 0d          	shr    rax,0xd
  22e120:	48 3d 95 73 c2 48    	cmp    rax,0x48c27395
  22e126:	72 60                	jb     22e188 <u64toa+0x4a8>
  22e128:	31 c0                	xor    eax,eax
  22e12a:	e9 2f fe ff ff       	jmp    22df5e <u64toa+0x27e>
            if (value >= 100000) {
  22e12f:	48 81 ff a0 86 01 00 	cmp    rdi,0x186a0
  22e136:	0f 83 3e ff ff ff    	jae    22e07a <u64toa+0x39a>
  22e13c:	e9 4d ff ff ff       	jmp    22e08e <u64toa+0x3ae>
            const i: u32 = (a / 100) << 1;
  22e141:	89 c1                	mov    ecx,eax
  22e143:	48 69 c9 1f 85 eb 51 	imul   rcx,rcx,0x51eb851f
  22e14a:	48 c1 e9 25          	shr    rcx,0x25
            const j: u32 = (a % 100) << 1;
  22e14e:	6b f9 64             	imul   edi,ecx,0x64
        } else if (a < 1000) {
  22e151:	3d e7 03 00 00       	cmp    eax,0x3e7
  22e156:	77 4a                	ja     22e1a2 <u64toa+0x4c2>
            buffer[buf_index] = '0' + @intCast(u8, a / 100);
  22e158:	48 8b 1e             	mov    rbx,QWORD PTR [rsi]
  22e15b:	80 c1 30             	add    cl,0x30
  22e15e:	88 0b                	mov    BYTE PTR [rbx],cl
            const i: u32 = (a % 100) << 1;
  22e160:	29 f8                	sub    eax,edi
            buffer[buf_index] = c_digits_lut[i];
  22e162:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  22e165:	48 8d 3d ac 7b fd ff 	lea    rdi,[rip+0xfffffffffffd7bac]        # 205d18 <c_digits_lut>
  22e16c:	8a 1c 47             	mov    bl,BYTE PTR [rdi+rax*2]
            const i: u32 = (a % 100) << 1;
  22e16f:	48 01 c0             	add    rax,rax
            buffer[buf_index] = c_digits_lut[i];
  22e172:	88 59 01             	mov    BYTE PTR [rcx+0x1],bl
            buffer[buf_index] = c_digits_lut[i + 1];
  22e175:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  22e178:	83 c8 01             	or     eax,0x1
  22e17b:	8a 04 38             	mov    al,BYTE PTR [rax+rdi*1]
  22e17e:	88 41 02             	mov    BYTE PTR [rcx+0x2],al
  22e181:	b8 03 00 00 00       	mov    eax,0x3
  22e186:	eb 5d                	jmp    22e1e5 <u64toa+0x505>
        if (value >= kTen12) {
  22e188:	48 89 f8             	mov    rax,rdi
  22e18b:	48 c1 e8 0c          	shr    rax,0xc
  22e18f:	48 3d 51 4a 8d 0e    	cmp    rax,0xe8d4a51
  22e195:	0f 82 e9 01 00 00    	jb     22e384 <u64toa+0x6a4>
  22e19b:	31 c0                	xor    eax,eax
  22e19d:	e9 d0 fd ff ff       	jmp    22df72 <u64toa+0x292>
            const j: u32 = (a % 100) << 1;
  22e1a2:	29 f8                	sub    eax,edi
  22e1a4:	48 8d 3c 00          	lea    rdi,[rax+rax*1]
            buffer[buf_index] = c_digits_lut[i];
  22e1a8:	4c 8b 0e             	mov    r9,QWORD PTR [rsi]
  22e1ab:	4c 8d 05 66 7b fd ff 	lea    r8,[rip+0xfffffffffffd7b66]        # 205d18 <c_digits_lut>
  22e1b2:	41 8a 1c 48          	mov    bl,BYTE PTR [r8+rcx*2]
  22e1b6:	41 88 19             	mov    BYTE PTR [r9],bl
            const i: u32 = (a / 100) << 1;
  22e1b9:	48 01 c9             	add    rcx,rcx
            buffer[buf_index] = c_digits_lut[i + 1];
  22e1bc:	48 8b 1e             	mov    rbx,QWORD PTR [rsi]
  22e1bf:	83 c9 01             	or     ecx,0x1
  22e1c2:	42 8a 0c 01          	mov    cl,BYTE PTR [rcx+r8*1]
  22e1c6:	88 4b 01             	mov    BYTE PTR [rbx+0x1],cl
            buffer[buf_index] = c_digits_lut[j];
  22e1c9:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  22e1cc:	41 8a 04 40          	mov    al,BYTE PTR [r8+rax*2]
  22e1d0:	88 41 02             	mov    BYTE PTR [rcx+0x2],al
            buffer[buf_index] = c_digits_lut[j + 1];
  22e1d3:	48 8b 06             	mov    rax,QWORD PTR [rsi]
  22e1d6:	83 cf 01             	or     edi,0x1
  22e1d9:	42 8a 0c 07          	mov    cl,BYTE PTR [rdi+r8*1]
  22e1dd:	88 48 03             	mov    BYTE PTR [rax+0x3],cl
  22e1e0:	b8 04 00 00 00       	mov    eax,0x4
        const v0 = @intCast(u32, value / kTen8);
  22e1e5:	48 b9 fd ce 61 84 11 	movabs rcx,0xabcc77118461cefd
  22e1ec:	77 cc ab 
  22e1ef:	c4 62 f3 f6 f1       	mulx   r14,rcx,rcx
  22e1f4:	49 c1 ee 1a          	shr    r14,0x1a
        const v1 = @intCast(u32, value % kTen8);
  22e1f8:	4d 69 c6 00 e1 f5 05 	imul   r8,r14,0x5f5e100
        const b0: u32 = v0 / 10000;
  22e1ff:	44 89 f3             	mov    ebx,r14d
  22e202:	41 ba 59 17 b7 d1    	mov    r10d,0xd1b71759
        const d1: u32 = (b0 / 100) << 1;
  22e208:	4c 69 cb 83 de 1b 43 	imul   r9,rbx,0x431bde83
        const b0: u32 = v0 / 10000;
  22e20f:	49 0f af da          	imul   rbx,r10
  22e213:	48 c1 eb 2d          	shr    rbx,0x2d
        const d1: u32 = (b0 / 100) << 1;
  22e217:	49 c1 e9 32          	shr    r9,0x32
        buffer[buf_index] = c_digits_lut[d1];
  22e21b:	4c 8b 1e             	mov    r11,QWORD PTR [rsi]
  22e21e:	48 8d 3d f3 7a fd ff 	lea    rdi,[rip+0xfffffffffffd7af3]        # 205d18 <c_digits_lut>
  22e225:	42 8a 0c 4f          	mov    cl,BYTE PTR [rdi+r9*2]
  22e229:	41 88 0c 03          	mov    BYTE PTR [r11+rax*1],cl
        const c0: u32 = v0 % 10000;
  22e22d:	44 69 db 10 27 00 00 	imul   r11d,ebx,0x2710
        const d2: u32 = (b0 % 100) << 1;
  22e234:	48 69 cb 1f 85 eb 51 	imul   rcx,rbx,0x51eb851f
  22e23b:	48 c1 e9 25          	shr    rcx,0x25
  22e23f:	6b c9 64             	imul   ecx,ecx,0x64
        const c0: u32 = v0 % 10000;
  22e242:	45 29 de             	sub    r14d,r11d
        const d2: u32 = (b0 % 100) << 1;
  22e245:	29 cb                	sub    ebx,ecx
        const d1: u32 = (b0 / 100) << 1;
  22e247:	4b 8d 0c 09          	lea    rcx,[r9+r9*1]
        buffer[buf_index] = c_digits_lut[d1 + 1];
  22e24b:	83 c9 01             	or     ecx,0x1
  22e24e:	44 8a 0c 39          	mov    r9b,BYTE PTR [rcx+rdi*1]
  22e252:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  22e255:	44 88 4c 01 01       	mov    BYTE PTR [rcx+rax*1+0x1],r9b
        buffer[buf_index] = c_digits_lut[d2];
  22e25a:	4c 8b 0e             	mov    r9,QWORD PTR [rsi]
  22e25d:	8a 0c 5f             	mov    cl,BYTE PTR [rdi+rbx*2]
  22e260:	41 88 4c 01 02       	mov    BYTE PTR [r9+rax*1+0x2],cl
        const d2: u32 = (b0 % 100) << 1;
  22e265:	48 8d 0c 1b          	lea    rcx,[rbx+rbx*1]
        const d3: u32 = (c0 / 100) << 1;
  22e269:	49 69 de 1f 85 eb 51 	imul   rbx,r14,0x51eb851f
  22e270:	48 c1 eb 25          	shr    rbx,0x25
        buffer[buf_index] = c_digits_lut[d2 + 1];
  22e274:	83 c9 01             	or     ecx,0x1
  22e277:	44 8a 0c 39          	mov    r9b,BYTE PTR [rcx+rdi*1]
  22e27b:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  22e27e:	44 88 4c 01 03       	mov    BYTE PTR [rcx+rax*1+0x3],r9b
        buffer[buf_index] = c_digits_lut[d3];
  22e283:	4c 8b 0e             	mov    r9,QWORD PTR [rsi]
  22e286:	8a 0c 5f             	mov    cl,BYTE PTR [rdi+rbx*2]
  22e289:	41 88 4c 01 04       	mov    BYTE PTR [r9+rax*1+0x4],cl
        const d4: u32 = (c0 % 100) << 1;
  22e28e:	6b cb 64             	imul   ecx,ebx,0x64
        const v1 = @intCast(u32, value % kTen8);
  22e291:	4c 29 c2             	sub    rdx,r8
        const d3: u32 = (c0 / 100) << 1;
  22e294:	48 8d 1c 1b          	lea    rbx,[rbx+rbx*1]
        const d4: u32 = (c0 % 100) << 1;
  22e298:	41 29 ce             	sub    r14d,ecx
        buffer[buf_index] = c_digits_lut[d3 + 1];
  22e29b:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  22e29e:	83 cb 01             	or     ebx,0x1
  22e2a1:	8a 1c 3b             	mov    bl,BYTE PTR [rbx+rdi*1]
  22e2a4:	88 5c 01 05          	mov    BYTE PTR [rcx+rax*1+0x5],bl
        const d4: u32 = (c0 % 100) << 1;
  22e2a8:	4b 8d 0c 36          	lea    rcx,[r14+r14*1]
        const b1: u32 = v1 / 10000;
  22e2ac:	4c 0f af d2          	imul   r10,rdx
  22e2b0:	49 c1 ea 2d          	shr    r10,0x2d
        buffer[buf_index] = c_digits_lut[d4];
  22e2b4:	4c 8b 06             	mov    r8,QWORD PTR [rsi]
  22e2b7:	42 8a 1c 77          	mov    bl,BYTE PTR [rdi+r14*2]
  22e2bb:	41 88 5c 00 06       	mov    BYTE PTR [r8+rax*1+0x6],bl
        const d5: u32 = (b1 / 100) << 1;
  22e2c0:	48 69 da 83 de 1b 43 	imul   rbx,rdx,0x431bde83
  22e2c7:	48 c1 eb 31          	shr    rbx,0x31
  22e2cb:	81 e3 fe 01 00 00    	and    ebx,0x1fe
        buffer[buf_index] = c_digits_lut[d4 + 1];
  22e2d1:	4c 8b 06             	mov    r8,QWORD PTR [rsi]
  22e2d4:	83 c9 01             	or     ecx,0x1
  22e2d7:	8a 0c 39             	mov    cl,BYTE PTR [rcx+rdi*1]
  22e2da:	41 88 4c 00 07       	mov    BYTE PTR [r8+rax*1+0x7],cl
        buf_index += 1;
  22e2df:	48 83 c8 08          	or     rax,0x8
        buffer[buf_index] = c_digits_lut[d5];
  22e2e3:	4c 8b 06             	mov    r8,QWORD PTR [rsi]
  22e2e6:	8a 0c 3b             	mov    cl,BYTE PTR [rbx+rdi*1]
  22e2e9:	41 88 0c 00          	mov    BYTE PTR [r8+rax*1],cl
        const c1: u32 = v1 % 10000;
  22e2ed:	45 69 c2 10 27 00 00 	imul   r8d,r10d,0x2710
        const d6: u32 = (b1 % 100) << 1;
  22e2f4:	49 69 ca 1f 85 eb 51 	imul   rcx,r10,0x51eb851f
  22e2fb:	48 c1 e9 25          	shr    rcx,0x25
  22e2ff:	6b c9 64             	imul   ecx,ecx,0x64
        const c1: u32 = v1 % 10000;
  22e302:	44 29 c2             	sub    edx,r8d
        const d6: u32 = (b1 % 100) << 1;
  22e305:	41 29 ca             	sub    r10d,ecx
        buffer[buf_index] = c_digits_lut[d5 + 1];
  22e308:	8d 4b 01             	lea    ecx,[rbx+0x1]
  22e30b:	8a 0c 39             	mov    cl,BYTE PTR [rcx+rdi*1]
  22e30e:	48 8b 1e             	mov    rbx,QWORD PTR [rsi]
  22e311:	88 4c 03 01          	mov    BYTE PTR [rbx+rax*1+0x1],cl
        buffer[buf_index] = c_digits_lut[d6];
  22e315:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  22e318:	42 8a 1c 57          	mov    bl,BYTE PTR [rdi+r10*2]
  22e31c:	88 5c 01 02          	mov    BYTE PTR [rcx+rax*1+0x2],bl
        const d6: u32 = (b1 % 100) << 1;
  22e320:	4b 8d 0c 12          	lea    rcx,[r10+r10*1]
        const d7: u32 = (c1 / 100) << 1;
  22e324:	48 69 da 1f 85 eb 51 	imul   rbx,rdx,0x51eb851f
  22e32b:	48 c1 eb 25          	shr    rbx,0x25
        buffer[buf_index] = c_digits_lut[d6 + 1];
  22e32f:	83 c9 01             	or     ecx,0x1
  22e332:	44 8a 04 39          	mov    r8b,BYTE PTR [rcx+rdi*1]
  22e336:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  22e339:	44 88 44 01 03       	mov    BYTE PTR [rcx+rax*1+0x3],r8b
        buffer[buf_index] = c_digits_lut[d7];
  22e33e:	4c 8b 06             	mov    r8,QWORD PTR [rsi]
  22e341:	8a 0c 5f             	mov    cl,BYTE PTR [rdi+rbx*2]
  22e344:	41 88 4c 00 04       	mov    BYTE PTR [r8+rax*1+0x4],cl
        const d8: u32 = (c1 % 100) << 1;
  22e349:	6b cb 64             	imul   ecx,ebx,0x64
  22e34c:	29 ca                	sub    edx,ecx
        const d7: u32 = (c1 / 100) << 1;
  22e34e:	48 8d 0c 1b          	lea    rcx,[rbx+rbx*1]
        buffer[buf_index] = c_digits_lut[d7 + 1];
  22e352:	83 c9 01             	or     ecx,0x1
  22e355:	8a 0c 39             	mov    cl,BYTE PTR [rcx+rdi*1]
  22e358:	48 8b 1e             	mov    rbx,QWORD PTR [rsi]
  22e35b:	88 4c 03 05          	mov    BYTE PTR [rbx+rax*1+0x5],cl
        buffer[buf_index] = c_digits_lut[d8];
  22e35f:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  22e362:	8a 1c 57             	mov    bl,BYTE PTR [rdi+rdx*2]
  22e365:	88 5c 01 06          	mov    BYTE PTR [rcx+rax*1+0x6],bl
        const d8: u32 = (c1 % 100) << 1;
  22e369:	48 8d 0c 12          	lea    rcx,[rdx+rdx*1]
        buffer[buf_index] = c_digits_lut[d8 + 1];
  22e36d:	83 c9 01             	or     ecx,0x1
  22e370:	8a 0c 39             	mov    cl,BYTE PTR [rcx+rdi*1]
  22e373:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  22e376:	88 4c 02 07          	mov    BYTE PTR [rdx+rax*1+0x7],cl
        buf_index += 1;
  22e37a:	48 83 c0 08          	add    rax,0x8
    return buf_index;
  22e37e:	5b                   	pop    rbx
  22e37f:	41 5e                	pop    r14
  22e381:	41 5f                	pop    r15
  22e383:	c3                   	ret    
        if (value >= kTen11) {
  22e384:	48 89 f8             	mov    rax,rdi
  22e387:	48 c1 e8 0b          	shr    rax,0xb
  22e38b:	48 3d dd 0e e9 02    	cmp    rax,0x2e90edd
  22e391:	72 07                	jb     22e39a <u64toa+0x6ba>
  22e393:	31 c0                	xor    eax,eax
  22e395:	e9 ef fb ff ff       	jmp    22df89 <u64toa+0x2a9>
        if (value >= kTen10) {
  22e39a:	48 89 f8             	mov    rax,rdi
  22e39d:	48 c1 e8 0a          	shr    rax,0xa
  22e3a1:	48 3d f9 02 95 00    	cmp    rax,0x9502f9
  22e3a7:	72 07                	jb     22e3b0 <u64toa+0x6d0>
  22e3a9:	31 c0                	xor    eax,eax
  22e3ab:	e9 ee fb ff ff       	jmp    22df9e <u64toa+0x2be>
  22e3b0:	31 c0                	xor    eax,eax
        if (value >= kTen9) {
  22e3b2:	48 81 ff 00 ca 9a 3b 	cmp    rdi,0x3b9aca00
  22e3b9:	0f 83 f8 fb ff ff    	jae    22dfb7 <u64toa+0x2d7>
  22e3bf:	e9 08 fc ff ff       	jmp    22dfcc <u64toa+0x2ec>
  22e3c4:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  22e3cb:	00 00 00 00 00 

000000000022e3d0 <frexp64>:
    y |= 0x3F000000;
    result.significand = @bitCast(f32, y);
    return result;
}

fn frexp64(x: f64) frexp64_result {
  22e3d0:	53                   	push   rbx
  22e3d1:	48 83 ec 10          	sub    rsp,0x10
  22e3d5:	48 89 fb             	mov    rbx,rdi
    var result: frexp64_result = undefined;

    var y = @bitCast(u64, x);
  22e3d8:	c4 e1 f9 7e c1       	vmovq  rcx,xmm0
    const e = @intCast(i32, y >> 52) & 0x7FF;
  22e3dd:	48 89 c8             	mov    rax,rcx
  22e3e0:	48 c1 e8 34          	shr    rax,0x34

    if (e == 0) {
  22e3e4:	89 c2                	mov    edx,eax
  22e3e6:	81 e2 ff 07 00 00    	and    edx,0x7ff
  22e3ec:	81 fa ff 07 00 00    	cmp    edx,0x7ff
  22e3f2:	74 31                	je     22e425 <frexp64+0x55>
  22e3f4:	66 85 d2             	test   dx,dx
  22e3f7:	75 3d                	jne    22e436 <frexp64+0x66>
        if (x != 0) {
  22e3f9:	c5 f0 57 c9          	vxorps xmm1,xmm1,xmm1
  22e3fd:	c5 f9 2e c1          	vucomisd xmm0,xmm1
  22e401:	74 63                	je     22e466 <frexp64+0x96>
            // subnormal
            result = frexp64(x * 0x1.0p64);
  22e403:	c5 fb 59 05 cd 28 fd 	vmulsd xmm0,xmm0,QWORD PTR [rip+0xfffffffffffd28cd]        # 200cd8 <__unnamed_621+0x20>
  22e40a:	ff 
  22e40b:	48 89 e7             	mov    rdi,rsp
  22e40e:	e8 bd ff ff ff       	call   22e3d0 <frexp64>
  22e413:	c5 fb 10 04 24       	vmovsd xmm0,QWORD PTR [rsp]
  22e418:	8b 44 24 08          	mov    eax,DWORD PTR [rsp+0x8]
  22e41c:	8b 4c 24 0c          	mov    ecx,DWORD PTR [rsp+0xc]
            result.exponent -= 64;
  22e420:	83 c0 c0             	add    eax,0xffffffc0
  22e423:	eb 43                	jmp    22e468 <frexp64+0x98>
        // frexp(+-inf) = (+-inf, 0)
        if (math.isInf(x)) {
            result.exponent = 0;
        }

        return result;
  22e425:	c5 fb 11 03          	vmovsd QWORD PTR [rbx],xmm0
  22e429:	c7 43 08 00 00 00 00 	mov    DWORD PTR [rbx+0x8],0x0
  22e430:	48 83 c4 10          	add    rsp,0x10
  22e434:	5b                   	pop    rbx
  22e435:	c3                   	ret    
    const e = @intCast(i32, y >> 52) & 0x7FF;
  22e436:	25 ff 07 00 00       	and    eax,0x7ff
    }

    result.exponent = e - 0x3FE;
  22e43b:	05 02 fc ff ff       	add    eax,0xfffffc02
    y &= 0x800FFFFFFFFFFFFF;
  22e440:	48 ba ff ff ff ff ff 	movabs rdx,0x800fffffffffffff
  22e447:	ff 0f 80 
  22e44a:	48 21 d1             	and    rcx,rdx
    y |= 0x3FE0000000000000;
  22e44d:	48 ba 00 00 00 00 00 	movabs rdx,0x3fe0000000000000
  22e454:	00 e0 3f 
  22e457:	48 09 ca             	or     rdx,rcx
    result.significand = @bitCast(f64, y);
    return result;
  22e45a:	48 89 13             	mov    QWORD PTR [rbx],rdx
  22e45d:	89 43 08             	mov    DWORD PTR [rbx+0x8],eax
  22e460:	48 83 c4 10          	add    rsp,0x10
  22e464:	5b                   	pop    rbx
  22e465:	c3                   	ret    
  22e466:	31 c0                	xor    eax,eax
        return result;
  22e468:	c5 fb 11 03          	vmovsd QWORD PTR [rbx],xmm0
  22e46c:	89 43 08             	mov    DWORD PTR [rbx+0x8],eax
  22e46f:	89 4b 0c             	mov    DWORD PTR [rbx+0xc],ecx
  22e472:	48 83 c4 10          	add    rsp,0x10
  22e476:	5b                   	pop    rbx
  22e477:	c3                   	ret    
  22e478:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  22e47f:	00 

000000000022e480 <_start>:
}

nakedcc fn _start() noreturn {
    switch (builtin.arch) {
        builtin.Arch.x86_64 => {
            argc_ptr = asm ("lea (%%rsp), %[argc]"
  22e480:	48 8d 04 24          	lea    rax,[rsp]
  22e484:	48 89 05 05 dd 01 00 	mov    QWORD PTR [rip+0x1dd05],rax        # 24c190 <argc_ptr>
        },
        else => @compileError("unsupported arch"),
    }
    // If LLVM inlines stack variables into _start, they will overwrite
    // the command line argument data.
    @noInlineCall(posixCallMainAndExit);
  22e48b:	e8 00 00 00 00       	call   22e490 <posixCallMainAndExit>

000000000022e490 <posixCallMainAndExit>:
    std.os.windows.ExitProcess(callMain());
}

// TODO https://github.com/ziglang/zig/issues/265
fn posixCallMainAndExit() noreturn {
    const argc = argc_ptr[0];
  22e490:	41 56                	push   r14
  22e492:	53                   	push   rbx
  22e493:	48 83 ec 18          	sub    rsp,0x18
  22e497:	48 8b 15 f2 dc 01 00 	mov    rdx,QWORD PTR [rip+0x1dcf2]        # 24c190 <argc_ptr>
  22e49e:	48 8b 1a             	mov    rbx,QWORD PTR [rdx]
    const argv = @ptrCast([*][*]u8, argc_ptr + 1);

    const envp_optional = @ptrCast([*]?[*]u8, argv + argc + 1);
  22e4a1:	48 8d 0c da          	lea    rcx,[rdx+rbx*8]
  22e4a5:	48 83 c1 10          	add    rcx,0x10
    var envp_count: usize = 0;
    while (envp_optional[envp_count]) |_| : (envp_count += 1) {}
  22e4a9:	48 8d 04 da          	lea    rax,[rdx+rbx*8]
  22e4ad:	48 83 c0 20          	add    rax,0x20
    const argv = @ptrCast([*][*]u8, argc_ptr + 1);
  22e4b1:	4c 8d 72 08          	lea    r14,[rdx+0x8]
  22e4b5:	48 c7 c2 ff ff ff ff 	mov    rdx,0xffffffffffffffff
  22e4bc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
    while (envp_optional[envp_count]) |_| : (envp_count += 1) {}
  22e4c0:	48 83 c2 01          	add    rdx,0x1
  22e4c4:	48 83 78 f0 00       	cmp    QWORD PTR [rax-0x10],0x0
  22e4c9:	48 8d 40 08          	lea    rax,[rax+0x8]
  22e4cd:	75 f1                	jne    22e4c0 <posixCallMainAndExit+0x30>
    const envp = @ptrCast([*][*]u8, envp_optional)[0..envp_count];
  22e4cf:	48 89 4c 24 08       	mov    QWORD PTR [rsp+0x8],rcx
  22e4d4:	48 89 54 24 10       	mov    QWORD PTR [rsp+0x10],rdx
    if (builtin.os == builtin.Os.linux) {
        const auxv = @ptrCast([*]usize, envp.ptr + envp_count + 1);
        var i: usize = 0;
        while (auxv[i] != 0) : (i += 2) {
  22e4d9:	48 8b 48 f0          	mov    rcx,QWORD PTR [rax-0x10]
  22e4dd:	48 85 c9             	test   rcx,rcx
  22e4e0:	74 28                	je     22e50a <posixCallMainAndExit+0x7a>
  22e4e2:	48 8d 15 4f 2b 02 00 	lea    rdx,[rip+0x22b4f]        # 251038 <linux_aux_raw>
  22e4e9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
            if (auxv[i] < std.os.linux_aux_raw.len) std.os.linux_aux_raw[auxv[i]] = auxv[i + 1];
  22e4f0:	48 83 f9 25          	cmp    rcx,0x25
  22e4f4:	77 08                	ja     22e4fe <posixCallMainAndExit+0x6e>
  22e4f6:	48 8b 70 f8          	mov    rsi,QWORD PTR [rax-0x8]
  22e4fa:	48 89 34 ca          	mov    QWORD PTR [rdx+rcx*8],rsi
        while (auxv[i] != 0) : (i += 2) {
  22e4fe:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  22e501:	48 83 c0 10          	add    rax,0x10
  22e505:	48 85 c9             	test   rcx,rcx
  22e508:	75 e6                	jne    22e4f0 <posixCallMainAndExit+0x60>
        }
        std.debug.assert(std.os.linux_aux_raw[std.elf.AT_PAGESZ] == std.os.page_size);
  22e50a:	31 ff                	xor    edi,edi
  22e50c:	48 81 3d 51 2b 02 00 	cmp    QWORD PTR [rip+0x22b51],0x1000        # 251068 <linux_aux_raw+0x30>
  22e513:	00 10 00 00 
  22e517:	40 0f 94 c7          	sete   dil
  22e51b:	e8 60 bd fd ff       	call   20a280 <assert>
  22e520:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
    }

    std.os.posix.exit(callMainWithArgs(argc, argv, envp));
  22e525:	48 89 df             	mov    rdi,rbx
  22e528:	4c 89 f6             	mov    rsi,r14
  22e52b:	e8 10 00 00 00       	call   22e540 <callMainWithArgs>
    _ = syscall1(SYS_exit, @bitCast(usize, isize(status)));
  22e530:	0f b6 f8             	movzx  edi,al
    return asm volatile ("syscall"
  22e533:	b8 3c 00 00 00       	mov    eax,0x3c
  22e538:	0f 05                	syscall 
  22e53a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

000000000022e540 <callMainWithArgs>:
}

fn callMainWithArgs(argc: usize, argv: [*][*]u8, envp: [][*]u8) u8 {
    std.os.ArgIteratorPosix.raw = argv[0..argc];
  22e540:	55                   	push   rbp
  22e541:	41 57                	push   r15
  22e543:	41 56                	push   r14
  22e545:	41 55                	push   r13
  22e547:	41 54                	push   r12
  22e549:	53                   	push   rbx
  22e54a:	48 83 ec 78          	sub    rsp,0x78
  22e54e:	48 89 35 43 dc 01 00 	mov    QWORD PTR [rip+0x1dc43],rsi        # 24c198 <raw>
  22e555:	48 89 3d 44 dc 01 00 	mov    QWORD PTR [rip+0x1dc44],rdi        # 24c1a0 <raw+0x8>
    std.os.posix_environ_raw = envp;
  22e55c:	c5 f8 10 02          	vmovups xmm0,XMMWORD PTR [rdx]
  22e560:	c5 f8 11 05 18 dc 01 	vmovups XMMWORD PTR [rip+0x1dc18],xmm0        # 24c180 <posix_environ_raw>
  22e567:	00 
const warn = std.debug.warn;

pub fn main() !void {
    var ok_count: usize = 0;
    var skip_count: usize = 0;
    for (test_fn_list) |test_fn, i| {
  22e568:	c5 f8 10 05 a0 b1 fd 	vmovups xmm0,XMMWORD PTR [rip+0xfffffffffffdb1a0]        # 209710 <__unnamed_107>
  22e56f:	ff 
  22e570:	c5 f8 29 44 24 60    	vmovaps XMMWORD PTR [rsp+0x60],xmm0
  22e576:	31 c0                	xor    eax,eax
  22e578:	48 89 44 24 58       	mov    QWORD PTR [rsp+0x58],rax
  22e57d:	49 bd cd cc cc cc cc 	movabs r13,0xcccccccccccccccd
  22e584:	cc cc cc 
  22e587:	45 31 e4             	xor    r12d,r12d
  22e58a:	31 db                	xor    ebx,ebx
  22e58c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  22e590:	4b 8d 04 64          	lea    rax,[r12+r12*2]
  22e594:	48 8d 0d c5 15 02 00 	lea    rcx,[rip+0x215c5]        # 24fb60 <__unnamed_108>
  22e59b:	c5 f8 10 04 c1       	vmovups xmm0,XMMWORD PTR [rcx+rax*8]
  22e5a0:	c5 f8 29 44 24 60    	vmovaps XMMWORD PTR [rsp+0x60],xmm0
  22e5a6:	4c 8b 74 c1 10       	mov    r14,QWORD PTR [rcx+rax*8+0x10]
  22e5ab:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  22e5b0:	b0 01                	mov    al,0x1
  22e5b2:	86 05 58 2a 02 00    	xchg   BYTE PTR [rip+0x22a58],al        # 251010 <stderr_mutex>
  22e5b8:	84 c0                	test   al,al
  22e5ba:	75 f4                	jne    22e5b0 <callMainWithArgs+0x70>
    if (stderr_stream) |st| {
  22e5bc:	48 8b 2d 45 2a 02 00 	mov    rbp,QWORD PTR [rip+0x22a45]        # 251008 <stderr_stream>
  22e5c3:	48 85 ed             	test   rbp,rbp
  22e5c6:	74 18                	je     22e5e0 <callMainWithArgs+0xa0>
            return std.fmt.format(self, Error, self.writeFn, format, args);
  22e5c8:	4c 8b 3d 71 da 01 00 	mov    r15,QWORD PTR [rip+0x1da71]        # 24c040 <stderr_file_out_stream+0x8>
  22e5cf:	eb 43                	jmp    22e614 <callMainWithArgs+0xd4>
  22e5d1:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  22e5d8:	0f 1f 84 00 00 00 00 
  22e5df:	00 
        stderr_file = try io.getStdErr();
  22e5e0:	c7 05 46 da 01 00 02 	mov    DWORD PTR [rip+0x1da46],0x2        # 24c030 <stderr_file>
  22e5e7:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  22e5ea:	48 8d 05 3f da 01 00 	lea    rax,[rip+0x1da3f]        # 24c030 <stderr_file>
  22e5f1:	48 89 05 40 da 01 00 	mov    QWORD PTR [rip+0x1da40],rax        # 24c038 <stderr_file_out_stream>
  22e5f8:	4c 8d 3d a1 08 ff ff 	lea    r15,[rip+0xffffffffffff08a1]        # 21eea0 <FileOutStream_writeFn>
  22e5ff:	4c 89 3d 3a da 01 00 	mov    QWORD PTR [rip+0x1da3a],r15        # 24c040 <stderr_file_out_stream+0x8>
  22e606:	48 8d 2d 33 da 01 00 	lea    rbp,[rip+0x1da33]        # 24c040 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  22e60d:	48 89 2d f4 29 02 00 	mov    QWORD PTR [rip+0x229f4],rbp        # 251008 <stderr_stream>
  22e614:	49 83 c4 01          	add    r12,0x1
                        try output(context, fmt[start_index..i]);
  22e618:	48 89 ef             	mov    rdi,rbp
  22e61b:	48 8d 35 76 1a 02 00 	lea    rsi,[rip+0x21a76]        # 250098 <__unnamed_109>
  22e622:	41 ff d7             	call   r15
  22e625:	66 85 c0             	test   ax,ax
  22e628:	0f 85 72 01 00 00    	jne    22e7a0 <callMainWithArgs+0x260>
    var buf: [max_int_digits - 1]u8 = undefined;
  22e62e:	c5 fc 10 05 b9 b0 fd 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffdb0b9]        # 2096ef <__unnamed_28+0x1f>
  22e635:	ff 
  22e636:	c5 fc 11 44 24 2f    	vmovups YMMWORD PTR [rsp+0x2f],ymm0
  22e63c:	c5 fc 10 05 8c b0 fd 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffdb08c]        # 2096d0 <__unnamed_28>
  22e643:	ff 
  22e644:	c5 fc 11 44 24 10    	vmovups YMMWORD PTR [rsp+0x10],ymm0
        const digit = a % base;
  22e64a:	4c 89 e2             	mov    rdx,r12
  22e64d:	c4 c2 fb f6 cd       	mulx   rcx,rax,r13
  22e652:	c1 e9 02             	shr    ecx,0x2
  22e655:	81 e1 fe ff ff 3f    	and    ecx,0x3ffffffe
  22e65b:	8d 0c 89             	lea    ecx,[rcx+rcx*4]
  22e65e:	44 89 e0             	mov    eax,r12d
  22e661:	29 c8                	sub    eax,ecx
        0...9 => digit + '0',
  22e663:	b1 30                	mov    cl,0x30
  22e665:	3c 0a                	cmp    al,0xa
  22e667:	72 02                	jb     22e66b <callMainWithArgs+0x12b>
  22e669:	b1 57                	mov    cl,0x57
  22e66b:	00 c1                	add    cl,al
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  22e66d:	88 4c 24 4f          	mov    BYTE PTR [rsp+0x4f],cl
        if (a == 0) break;
  22e671:	49 83 fc 0a          	cmp    r12,0xa
  22e675:	73 0c                	jae    22e683 <callMainWithArgs+0x143>
  22e677:	b9 40 00 00 00       	mov    ecx,0x40
  22e67c:	48 8d 44 24 4f       	lea    rax,[rsp+0x4f]
  22e681:	eb 57                	jmp    22e6da <callMainWithArgs+0x19a>
  22e683:	49 89 d8             	mov    r8,rbx
  22e686:	b9 40 00 00 00       	mov    ecx,0x40
  22e68b:	4c 89 e0             	mov    rax,r12
  22e68e:	66 90                	xchg   ax,ax
        a /= base;
  22e690:	48 89 c2             	mov    rdx,rax
  22e693:	c4 c2 cb f6 d5       	mulx   rdx,rsi,r13
  22e698:	48 c1 ea 03          	shr    rdx,0x3
        const digit = a % base;
  22e69c:	c4 c2 cb f6 fd       	mulx   rdi,rsi,r13
  22e6a1:	c1 ef 02             	shr    edi,0x2
  22e6a4:	81 e7 fe ff ff 3f    	and    edi,0x3ffffffe
  22e6aa:	8d 3c bf             	lea    edi,[rdi+rdi*4]
  22e6ad:	89 d6                	mov    esi,edx
  22e6af:	29 fe                	sub    esi,edi
        0...9 => digit + '0',
  22e6b1:	b3 30                	mov    bl,0x30
  22e6b3:	40 80 fe 0a          	cmp    sil,0xa
  22e6b7:	72 02                	jb     22e6bb <callMainWithArgs+0x17b>
  22e6b9:	b3 57                	mov    bl,0x57
  22e6bb:	40 00 f3             	add    bl,sil
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  22e6be:	88 5c 0c 0e          	mov    BYTE PTR [rsp+rcx*1+0xe],bl
        if (a == 0) break;
  22e6c2:	48 83 c1 ff          	add    rcx,0xffffffffffffffff
  22e6c6:	48 83 f8 63          	cmp    rax,0x63
  22e6ca:	48 89 d0             	mov    rax,rdx
  22e6cd:	77 c1                	ja     22e690 <callMainWithArgs+0x150>
        const padded_buf = buf[index - padding ..];
  22e6cf:	48 8d 04 0c          	lea    rax,[rsp+rcx*1]
  22e6d3:	48 83 c0 0f          	add    rax,0xf
  22e6d7:	4c 89 c3             	mov    rbx,r8
  22e6da:	ba 41 00 00 00       	mov    edx,0x41
  22e6df:	48 29 ca             	sub    rdx,rcx
  22e6e2:	48 89 04 24          	mov    QWORD PTR [rsp],rax
  22e6e6:	48 89 54 24 08       	mov    QWORD PTR [rsp+0x8],rdx
        return output(context, padded_buf);
  22e6eb:	48 89 ef             	mov    rdi,rbp
  22e6ee:	48 89 e6             	mov    rsi,rsp
  22e6f1:	c5 f8 77             	vzeroupper 
  22e6f4:	41 ff d7             	call   r15
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  22e6f7:	66 85 c0             	test   ax,ax
  22e6fa:	0f 85 a0 00 00 00    	jne    22e7a0 <callMainWithArgs+0x260>
                        try output(context, fmt[start_index..i]);
  22e700:	48 89 ef             	mov    rdi,rbp
  22e703:	48 8d 35 9e 19 02 00 	lea    rsi,[rip+0x2199e]        # 2500a8 <__unnamed_110>
  22e70a:	41 ff d7             	call   r15
  22e70d:	66 85 c0             	test   ax,ax
  22e710:	0f 85 8a 00 00 00    	jne    22e7a0 <callMainWithArgs+0x260>
    var buf: [max_int_digits - 1]u8 = undefined;
  22e716:	c5 fc 10 05 d0 af fd 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffdafd0]        # 2096ee <__unnamed_28+0x1e>
  22e71d:	ff 
  22e71e:	c5 fc 11 44 24 2e    	vmovups YMMWORD PTR [rsp+0x2e],ymm0
  22e724:	c5 fc 10 05 a4 af fd 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffdafa4]        # 2096d0 <__unnamed_28>
  22e72b:	ff 
  22e72c:	c5 fc 11 44 24 10    	vmovups YMMWORD PTR [rsp+0x10],ymm0
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  22e732:	66 c7 44 24 4e 31 36 	mov    WORD PTR [rsp+0x4e],0x3631
        const padded_buf = buf[index - padding ..];
  22e739:	48 8d 44 24 4e       	lea    rax,[rsp+0x4e]
  22e73e:	48 89 04 24          	mov    QWORD PTR [rsp],rax
  22e742:	48 c7 44 24 08 02 00 	mov    QWORD PTR [rsp+0x8],0x2
  22e749:	00 00 
        return output(context, padded_buf);
  22e74b:	48 89 ef             	mov    rdi,rbp
  22e74e:	48 89 e6             	mov    rsi,rsp
  22e751:	c5 f8 77             	vzeroupper 
  22e754:	41 ff d7             	call   r15
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  22e757:	66 85 c0             	test   ax,ax
  22e75a:	75 44                	jne    22e7a0 <callMainWithArgs+0x260>
                        try output(context, fmt[start_index..i]);
  22e75c:	48 89 ef             	mov    rdi,rbp
  22e75f:	48 8d 35 52 19 02 00 	lea    rsi,[rip+0x21952]        # 2500b8 <__unnamed_111>
  22e766:	41 ff d7             	call   r15
  22e769:	66 85 c0             	test   ax,ax
  22e76c:	75 32                	jne    22e7a0 <callMainWithArgs+0x260>
                const casted_value = ([]const u8)(value);
  22e76e:	c5 f8 28 44 24 60    	vmovaps xmm0,XMMWORD PTR [rsp+0x60]
  22e774:	c5 f8 29 44 24 10    	vmovaps XMMWORD PTR [rsp+0x10],xmm0
                return output(context, casted_value);
  22e77a:	48 89 ef             	mov    rdi,rbp
  22e77d:	48 8d 74 24 10       	lea    rsi,[rsp+0x10]
  22e782:	41 ff d7             	call   r15
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  22e785:	66 85 c0             	test   ax,ax
  22e788:	75 16                	jne    22e7a0 <callMainWithArgs+0x260>
        try output(context, fmt[start_index..]);
  22e78a:	48 89 ef             	mov    rdi,rbp
  22e78d:	48 8d 35 34 19 02 00 	lea    rsi,[rip+0x21934]        # 2500c8 <__unnamed_112>
  22e794:	41 ff d7             	call   r15
  22e797:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  22e79e:	00 00 
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  22e7a0:	31 c0                	xor    eax,eax
  22e7a2:	86 05 68 28 02 00    	xchg   BYTE PTR [rip+0x22868],al        # 251010 <stderr_mutex>
  22e7a8:	3c 01                	cmp    al,0x1
    if (!ok) {
  22e7aa:	0f 85 d4 04 00 00    	jne    22ec84 <callMainWithArgs+0x744>
        warn("Test {}/{} {}...", i + 1, test_fn_list.len, test_fn.name);

        if (test_fn.func()) |_| {
  22e7b0:	41 ff d6             	call   r14
  22e7b3:	89 c5                	mov    ebp,eax
  22e7b5:	66 85 ed             	test   bp,bp
  22e7b8:	74 46                	je     22e800 <callMainWithArgs+0x2c0>
  22e7ba:	0f b7 c5             	movzx  eax,bp
  22e7bd:	83 f8 2d             	cmp    eax,0x2d
  22e7c0:	0f 85 6a 01 00 00    	jne    22e930 <callMainWithArgs+0x3f0>
  22e7c6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  22e7cd:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  22e7d0:	b0 01                	mov    al,0x1
  22e7d2:	86 05 38 28 02 00    	xchg   BYTE PTR [rip+0x22838],al        # 251010 <stderr_mutex>
  22e7d8:	84 c0                	test   al,al
  22e7da:	75 f4                	jne    22e7d0 <callMainWithArgs+0x290>
    if (stderr_stream) |st| {
  22e7dc:	48 8b 3d 25 28 02 00 	mov    rdi,QWORD PTR [rip+0x22825]        # 251008 <stderr_stream>
  22e7e3:	48 85 ff             	test   rdi,rdi
  22e7e6:	74 3c                	je     22e824 <callMainWithArgs+0x2e4>
  22e7e8:	48 8b 0d 51 d8 01 00 	mov    rcx,QWORD PTR [rip+0x1d851]        # 24c040 <stderr_file_out_stream+0x8>
  22e7ef:	eb 70                	jmp    22e861 <callMainWithArgs+0x321>
  22e7f1:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  22e7f8:	0f 1f 84 00 00 00 00 
  22e7ff:	00 
  22e800:	b0 01                	mov    al,0x1
  22e802:	86 05 08 28 02 00    	xchg   BYTE PTR [rip+0x22808],al        # 251010 <stderr_mutex>
  22e808:	84 c0                	test   al,al
  22e80a:	75 f4                	jne    22e800 <callMainWithArgs+0x2c0>
  22e80c:	48 8b 3d f5 27 02 00 	mov    rdi,QWORD PTR [rip+0x227f5]        # 251008 <stderr_stream>
  22e813:	48 85 ff             	test   rdi,rdi
  22e816:	74 72                	je     22e88a <callMainWithArgs+0x34a>
  22e818:	48 8b 0d 21 d8 01 00 	mov    rcx,QWORD PTR [rip+0x1d821]        # 24c040 <stderr_file_out_stream+0x8>
  22e81f:	e9 a3 00 00 00       	jmp    22e8c7 <callMainWithArgs+0x387>
        stderr_file = try io.getStdErr();
  22e824:	c7 05 02 d8 01 00 02 	mov    DWORD PTR [rip+0x1d802],0x2        # 24c030 <stderr_file>
  22e82b:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  22e82e:	48 8d 05 fb d7 01 00 	lea    rax,[rip+0x1d7fb]        # 24c030 <stderr_file>
  22e835:	48 89 05 fc d7 01 00 	mov    QWORD PTR [rip+0x1d7fc],rax        # 24c038 <stderr_file_out_stream>
  22e83c:	48 8d 05 5d 06 ff ff 	lea    rax,[rip+0xffffffffffff065d]        # 21eea0 <FileOutStream_writeFn>
  22e843:	48 89 05 f6 d7 01 00 	mov    QWORD PTR [rip+0x1d7f6],rax        # 24c040 <stderr_file_out_stream+0x8>
  22e84a:	48 8d 0d ef d7 01 00 	lea    rcx,[rip+0x1d7ef]        # 24c040 <stderr_file_out_stream+0x8>
  22e851:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  22e854:	48 89 15 ad 27 02 00 	mov    QWORD PTR [rip+0x227ad],rdx        # 251008 <stderr_stream>
  22e85b:	48 89 c1             	mov    rcx,rax
  22e85e:	48 89 d7             	mov    rdi,rdx
  22e861:	48 8d 35 80 18 02 00 	lea    rsi,[rip+0x21880]        # 2500e8 <__unnamed_113>
  22e868:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  22e86a:	31 c0                	xor    eax,eax
  22e86c:	86 05 9e 27 02 00    	xchg   BYTE PTR [rip+0x2279e],al        # 251010 <stderr_mutex>
  22e872:	3c 01                	cmp    al,0x1
    if (!ok) {
  22e874:	0f 85 0a 04 00 00    	jne    22ec84 <callMainWithArgs+0x744>
  22e87a:	48 83 c3 01          	add    rbx,0x1
    for (test_fn_list) |test_fn, i| {
  22e87e:	49 83 fc 10          	cmp    r12,0x10
  22e882:	0f 82 08 fd ff ff    	jb     22e590 <callMainWithArgs+0x50>
  22e888:	eb 66                	jmp    22e8f0 <callMainWithArgs+0x3b0>
        stderr_file = try io.getStdErr();
  22e88a:	c7 05 9c d7 01 00 02 	mov    DWORD PTR [rip+0x1d79c],0x2        # 24c030 <stderr_file>
  22e891:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  22e894:	48 8d 05 95 d7 01 00 	lea    rax,[rip+0x1d795]        # 24c030 <stderr_file>
  22e89b:	48 89 05 96 d7 01 00 	mov    QWORD PTR [rip+0x1d796],rax        # 24c038 <stderr_file_out_stream>
  22e8a2:	48 8d 05 f7 05 ff ff 	lea    rax,[rip+0xffffffffffff05f7]        # 21eea0 <FileOutStream_writeFn>
  22e8a9:	48 89 05 90 d7 01 00 	mov    QWORD PTR [rip+0x1d790],rax        # 24c040 <stderr_file_out_stream+0x8>
  22e8b0:	48 8d 0d 89 d7 01 00 	lea    rcx,[rip+0x1d789]        # 24c040 <stderr_file_out_stream+0x8>
  22e8b7:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  22e8ba:	48 89 15 47 27 02 00 	mov    QWORD PTR [rip+0x22747],rdx        # 251008 <stderr_stream>
  22e8c1:	48 89 c1             	mov    rcx,rax
  22e8c4:	48 89 d7             	mov    rdi,rdx
  22e8c7:	48 8d 35 0a 18 02 00 	lea    rsi,[rip+0x2180a]        # 2500d8 <__unnamed_114>
  22e8ce:	ff d1                	call   rcx
  22e8d0:	31 c0                	xor    eax,eax
  22e8d2:	86 05 38 27 02 00    	xchg   BYTE PTR [rip+0x22738],al        # 251010 <stderr_mutex>
  22e8d8:	3c 01                	cmp    al,0x1
    if (!ok) {
  22e8da:	0f 85 a4 03 00 00    	jne    22ec84 <callMainWithArgs+0x744>
  22e8e0:	48 83 44 24 58 01    	add    QWORD PTR [rsp+0x58],0x1
  22e8e6:	49 83 fc 10          	cmp    r12,0x10
  22e8ea:	0f 82 a0 fc ff ff    	jb     22e590 <callMainWithArgs+0x50>
  22e8f0:	48 8b 7c 24 58       	mov    rdi,QWORD PTR [rsp+0x58]
                warn("SKIP\n");
            },
            else => return err,
        }
    }
    if (ok_count == test_fn_list.len) {
  22e8f5:	48 83 ff 10          	cmp    rdi,0x10
  22e8f9:	75 65                	jne    22e960 <callMainWithArgs+0x420>
  22e8fb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  22e900:	b0 01                	mov    al,0x1
  22e902:	86 05 08 27 02 00    	xchg   BYTE PTR [rip+0x22708],al        # 251010 <stderr_mutex>
  22e908:	84 c0                	test   al,al
  22e90a:	75 f4                	jne    22e900 <callMainWithArgs+0x3c0>
    if (stderr_stream) |st| {
  22e90c:	48 8b 3d f5 26 02 00 	mov    rdi,QWORD PTR [rip+0x226f5]        # 251008 <stderr_stream>
  22e913:	48 85 ff             	test   rdi,rdi
  22e916:	0f 84 08 01 00 00    	je     22ea24 <callMainWithArgs+0x4e4>
  22e91c:	48 8b 0d 1d d7 01 00 	mov    rcx,QWORD PTR [rip+0x1d71d]        # 24c040 <stderr_file_out_stream+0x8>
  22e923:	e9 30 01 00 00       	jmp    22ea58 <callMainWithArgs+0x518>
  22e928:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  22e92f:	00 
  22e930:	b0 01                	mov    al,0x1
  22e932:	86 05 d8 26 02 00    	xchg   BYTE PTR [rip+0x226d8],al        # 251010 <stderr_mutex>
  22e938:	84 c0                	test   al,al
  22e93a:	75 f4                	jne    22e930 <callMainWithArgs+0x3f0>
  22e93c:	48 8b 1d c5 26 02 00 	mov    rbx,QWORD PTR [rip+0x226c5]        # 251008 <stderr_stream>
  22e943:	48 85 db             	test   rbx,rbx
  22e946:	74 45                	je     22e98d <callMainWithArgs+0x44d>
  22e948:	4c 8b 35 f1 d6 01 00 	mov    r14,QWORD PTR [rip+0x1d6f1]        # 24c040 <stderr_file_out_stream+0x8>
  22e94f:	eb 70                	jmp    22e9c1 <callMainWithArgs+0x481>
  22e951:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  22e958:	0f 1f 84 00 00 00 00 
  22e95f:	00 
  22e960:	b0 01                	mov    al,0x1
  22e962:	86 05 a8 26 02 00    	xchg   BYTE PTR [rip+0x226a8],al        # 251010 <stderr_mutex>
  22e968:	84 c0                	test   al,al
  22e96a:	75 f4                	jne    22e960 <callMainWithArgs+0x420>
  22e96c:	48 8b 2d 95 26 02 00 	mov    rbp,QWORD PTR [rip+0x22695]        # 251008 <stderr_stream>
  22e973:	48 85 ed             	test   rbp,rbp
  22e976:	4c 8d 7c 24 4f       	lea    r15,[rsp+0x4f]
  22e97b:	0f 84 f5 00 00 00    	je     22ea76 <callMainWithArgs+0x536>
  22e981:	4c 8b 35 b8 d6 01 00 	mov    r14,QWORD PTR [rip+0x1d6b8]        # 24c040 <stderr_file_out_stream+0x8>
  22e988:	e9 1d 01 00 00       	jmp    22eaaa <callMainWithArgs+0x56a>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  22e98d:	48 8d 05 9c d6 01 00 	lea    rax,[rip+0x1d69c]        # 24c030 <stderr_file>
  22e994:	48 89 05 9d d6 01 00 	mov    QWORD PTR [rip+0x1d69d],rax        # 24c038 <stderr_file_out_stream>
  22e99b:	4c 8d 35 fe 04 ff ff 	lea    r14,[rip+0xffffffffffff04fe]        # 21eea0 <FileOutStream_writeFn>
  22e9a2:	4c 89 35 97 d6 01 00 	mov    QWORD PTR [rip+0x1d697],r14        # 24c040 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  22e9a9:	c7 05 7d d6 01 00 02 	mov    DWORD PTR [rip+0x1d67d],0x2        # 24c030 <stderr_file>
  22e9b0:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  22e9b3:	48 8d 1d 86 d6 01 00 	lea    rbx,[rip+0x1d686]        # 24c040 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  22e9ba:	48 89 1d 47 26 02 00 	mov    QWORD PTR [rip+0x22647],rbx        # 251008 <stderr_stream>
                        try output(context, fmt[start_index..i]);
  22e9c1:	48 8d 35 60 17 02 00 	lea    rsi,[rip+0x21760]        # 250128 <__unnamed_115>
  22e9c8:	48 89 df             	mov    rdi,rbx
  22e9cb:	41 ff d6             	call   r14
  22e9ce:	66 85 c0             	test   ax,ax
  22e9d1:	75 39                	jne    22ea0c <callMainWithArgs+0x4cc>
  22e9d3:	48 0f bf c5          	movsx  rax,bp
  22e9d7:	48 c1 e0 04          	shl    rax,0x4
  22e9db:	48 8d 0d 1e e6 01 00 	lea    rcx,[rip+0x1e61e]        # 24d000 <raw+0xe68>
  22e9e2:	48 01 c1             	add    rcx,rax
                const casted_value = ([]const u8)(value);
  22e9e5:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  22e9e9:	c5 f8 29 44 24 10    	vmovaps XMMWORD PTR [rsp+0x10],xmm0
  22e9ef:	48 8d 74 24 10       	lea    rsi,[rsp+0x10]
                return output(context, casted_value);
  22e9f4:	48 89 df             	mov    rdi,rbx
  22e9f7:	41 ff d6             	call   r14
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  22e9fa:	66 85 c0             	test   ax,ax
  22e9fd:	75 0d                	jne    22ea0c <callMainWithArgs+0x4cc>
        try output(context, fmt[start_index..]);
  22e9ff:	48 8d 35 32 17 02 00 	lea    rsi,[rip+0x21732]        # 250138 <__unnamed_116>
  22ea06:	48 89 df             	mov    rdi,rbx
  22ea09:	41 ff d6             	call   r14
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  22ea0c:	31 c9                	xor    ecx,ecx
  22ea0e:	86 0d fc 25 02 00    	xchg   BYTE PTR [rip+0x225fc],cl        # 251010 <stderr_mutex>
  22ea14:	b0 01                	mov    al,0x1
  22ea16:	80 f9 01             	cmp    cl,0x1
    if (!ok) {
  22ea19:	0f 84 56 02 00 00    	je     22ec75 <callMainWithArgs+0x735>
  22ea1f:	e9 60 02 00 00       	jmp    22ec84 <callMainWithArgs+0x744>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  22ea24:	48 8d 05 05 d6 01 00 	lea    rax,[rip+0x1d605]        # 24c030 <stderr_file>
  22ea2b:	48 89 05 06 d6 01 00 	mov    QWORD PTR [rip+0x1d606],rax        # 24c038 <stderr_file_out_stream>
  22ea32:	48 8d 0d 67 04 ff ff 	lea    rcx,[rip+0xffffffffffff0467]        # 21eea0 <FileOutStream_writeFn>
  22ea39:	48 89 0d 00 d6 01 00 	mov    QWORD PTR [rip+0x1d600],rcx        # 24c040 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  22ea40:	c7 05 e6 d5 01 00 02 	mov    DWORD PTR [rip+0x1d5e6],0x2        # 24c030 <stderr_file>
  22ea47:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  22ea4a:	48 8d 3d ef d5 01 00 	lea    rdi,[rip+0x1d5ef]        # 24c040 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  22ea51:	48 89 3d b0 25 02 00 	mov    QWORD PTR [rip+0x225b0],rdi        # 251008 <stderr_stream>
  22ea58:	48 8d 35 99 16 02 00 	lea    rsi,[rip+0x21699]        # 2500f8 <__unnamed_117>
  22ea5f:	ff d1                	call   rcx
  22ea61:	31 c0                	xor    eax,eax
  22ea63:	86 05 a7 25 02 00    	xchg   BYTE PTR [rip+0x225a7],al        # 251010 <stderr_mutex>
  22ea69:	3c 01                	cmp    al,0x1
    if (!ok) {
  22ea6b:	0f 84 02 02 00 00    	je     22ec73 <callMainWithArgs+0x733>
  22ea71:	e9 0e 02 00 00       	jmp    22ec84 <callMainWithArgs+0x744>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  22ea76:	48 8d 05 b3 d5 01 00 	lea    rax,[rip+0x1d5b3]        # 24c030 <stderr_file>
  22ea7d:	48 89 05 b4 d5 01 00 	mov    QWORD PTR [rip+0x1d5b4],rax        # 24c038 <stderr_file_out_stream>
  22ea84:	4c 8d 35 15 04 ff ff 	lea    r14,[rip+0xffffffffffff0415]        # 21eea0 <FileOutStream_writeFn>
  22ea8b:	4c 89 35 ae d5 01 00 	mov    QWORD PTR [rip+0x1d5ae],r14        # 24c040 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  22ea92:	c7 05 94 d5 01 00 02 	mov    DWORD PTR [rip+0x1d594],0x2        # 24c030 <stderr_file>
  22ea99:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  22ea9c:	48 8d 2d 9d d5 01 00 	lea    rbp,[rip+0x1d59d]        # 24c040 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  22eaa3:	48 89 2d 5e 25 02 00 	mov    QWORD PTR [rip+0x2255e],rbp        # 251008 <stderr_stream>
    var buf: [max_int_digits - 1]u8 = undefined;
  22eaaa:	c5 fc 10 05 3d ac fd 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffdac3d]        # 2096ef <__unnamed_28+0x1f>
  22eab1:	ff 
  22eab2:	c5 fc 11 44 24 2f    	vmovups YMMWORD PTR [rsp+0x2f],ymm0
  22eab8:	c5 fc 10 05 10 ac fd 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffdac10]        # 2096d0 <__unnamed_28>
  22eabf:	ff 
  22eac0:	c5 fc 11 44 24 10    	vmovups YMMWORD PTR [rsp+0x10],ymm0
        const digit = a % base;
  22eac6:	48 89 fa             	mov    rdx,rdi
  22eac9:	c4 c2 fb f6 cd       	mulx   rcx,rax,r13
  22eace:	c1 e9 02             	shr    ecx,0x2
  22ead1:	81 e1 fe ff ff 3f    	and    ecx,0x3ffffffe
  22ead7:	8d 0c 89             	lea    ecx,[rcx+rcx*4]
  22eada:	89 f8                	mov    eax,edi
  22eadc:	29 c8                	sub    eax,ecx
        0...9 => digit + '0',
  22eade:	b1 30                	mov    cl,0x30
  22eae0:	3c 0a                	cmp    al,0xa
  22eae2:	72 02                	jb     22eae6 <callMainWithArgs+0x5a6>
  22eae4:	b1 57                	mov    cl,0x57
  22eae6:	00 c1                	add    cl,al
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  22eae8:	88 4c 24 4f          	mov    BYTE PTR [rsp+0x4f],cl
        if (a == 0) break;
  22eaec:	48 83 ff 0a          	cmp    rdi,0xa
  22eaf0:	73 0a                	jae    22eafc <callMainWithArgs+0x5bc>
  22eaf2:	b8 40 00 00 00       	mov    eax,0x40
  22eaf7:	4c 89 f9             	mov    rcx,r15
  22eafa:	eb 5c                	jmp    22eb58 <callMainWithArgs+0x618>
  22eafc:	49 89 d8             	mov    r8,rbx
  22eaff:	b8 40 00 00 00       	mov    eax,0x40
  22eb04:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  22eb0b:	00 00 00 00 00 
        a /= base;
  22eb10:	48 89 fa             	mov    rdx,rdi
  22eb13:	c4 c2 f3 f6 d5       	mulx   rdx,rcx,r13
  22eb18:	48 c1 ea 03          	shr    rdx,0x3
        const digit = a % base;
  22eb1c:	c4 c2 f3 f6 f5       	mulx   rsi,rcx,r13
  22eb21:	c1 ee 02             	shr    esi,0x2
  22eb24:	81 e6 fe ff ff 3f    	and    esi,0x3ffffffe
  22eb2a:	8d 34 b6             	lea    esi,[rsi+rsi*4]
  22eb2d:	89 d1                	mov    ecx,edx
  22eb2f:	29 f1                	sub    ecx,esi
        0...9 => digit + '0',
  22eb31:	b3 30                	mov    bl,0x30
  22eb33:	80 f9 0a             	cmp    cl,0xa
  22eb36:	72 02                	jb     22eb3a <callMainWithArgs+0x5fa>
  22eb38:	b3 57                	mov    bl,0x57
  22eb3a:	00 cb                	add    bl,cl
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  22eb3c:	88 5c 04 0e          	mov    BYTE PTR [rsp+rax*1+0xe],bl
        if (a == 0) break;
  22eb40:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  22eb44:	48 83 ff 63          	cmp    rdi,0x63
  22eb48:	48 89 d7             	mov    rdi,rdx
  22eb4b:	77 c3                	ja     22eb10 <callMainWithArgs+0x5d0>
        const padded_buf = buf[index - padding ..];
  22eb4d:	48 8d 0c 04          	lea    rcx,[rsp+rax*1]
  22eb51:	48 83 c1 0f          	add    rcx,0xf
  22eb55:	4c 89 c3             	mov    rbx,r8
  22eb58:	ba 41 00 00 00       	mov    edx,0x41
  22eb5d:	48 29 c2             	sub    rdx,rax
  22eb60:	48 89 0c 24          	mov    QWORD PTR [rsp],rcx
  22eb64:	48 89 54 24 08       	mov    QWORD PTR [rsp+0x8],rdx
  22eb69:	48 89 e6             	mov    rsi,rsp
        return output(context, padded_buf);
  22eb6c:	48 89 ef             	mov    rdi,rbp
  22eb6f:	c5 f8 77             	vzeroupper 
  22eb72:	41 ff d6             	call   r14
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  22eb75:	66 85 c0             	test   ax,ax
  22eb78:	0f 85 e9 00 00 00    	jne    22ec67 <callMainWithArgs+0x727>
                        try output(context, fmt[start_index..i]);
  22eb7e:	48 8d 35 83 15 02 00 	lea    rsi,[rip+0x21583]        # 250108 <__unnamed_118>
  22eb85:	48 89 ef             	mov    rdi,rbp
  22eb88:	41 ff d6             	call   r14
  22eb8b:	66 85 c0             	test   ax,ax
  22eb8e:	0f 85 d3 00 00 00    	jne    22ec67 <callMainWithArgs+0x727>
    var buf: [max_int_digits - 1]u8 = undefined;
  22eb94:	c5 fc 10 05 53 ab fd 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffdab53]        # 2096ef <__unnamed_28+0x1f>
  22eb9b:	ff 
  22eb9c:	c5 fc 11 44 24 2f    	vmovups YMMWORD PTR [rsp+0x2f],ymm0
  22eba2:	c5 fc 10 05 26 ab fd 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffdab26]        # 2096d0 <__unnamed_28>
  22eba9:	ff 
  22ebaa:	c5 fc 11 44 24 10    	vmovups YMMWORD PTR [rsp+0x10],ymm0
        const digit = a % base;
  22ebb0:	48 89 da             	mov    rdx,rbx
  22ebb3:	c4 c2 fb f6 cd       	mulx   rcx,rax,r13
  22ebb8:	c1 e9 02             	shr    ecx,0x2
  22ebbb:	81 e1 fe ff ff 3f    	and    ecx,0x3ffffffe
  22ebc1:	8d 0c 89             	lea    ecx,[rcx+rcx*4]
  22ebc4:	89 d8                	mov    eax,ebx
  22ebc6:	29 c8                	sub    eax,ecx
        0...9 => digit + '0',
  22ebc8:	b1 30                	mov    cl,0x30
  22ebca:	3c 0a                	cmp    al,0xa
  22ebcc:	72 02                	jb     22ebd0 <callMainWithArgs+0x690>
  22ebce:	b1 57                	mov    cl,0x57
  22ebd0:	00 c1                	add    cl,al
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  22ebd2:	88 4c 24 4f          	mov    BYTE PTR [rsp+0x4f],cl
  22ebd6:	b8 40 00 00 00       	mov    eax,0x40
        if (a == 0) break;
  22ebdb:	48 83 fb 0a          	cmp    rbx,0xa
  22ebdf:	72 57                	jb     22ec38 <callMainWithArgs+0x6f8>
  22ebe1:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  22ebe8:	0f 1f 84 00 00 00 00 
  22ebef:	00 
  22ebf0:	48 89 df             	mov    rdi,rbx
        a /= base;
  22ebf3:	48 89 da             	mov    rdx,rbx
  22ebf6:	c4 c2 f3 f6 d5       	mulx   rdx,rcx,r13
  22ebfb:	48 c1 ea 03          	shr    rdx,0x3
        const digit = a % base;
  22ebff:	c4 c2 f3 f6 f5       	mulx   rsi,rcx,r13
  22ec04:	c1 ee 02             	shr    esi,0x2
  22ec07:	81 e6 fe ff ff 3f    	and    esi,0x3ffffffe
  22ec0d:	8d 34 b6             	lea    esi,[rsi+rsi*4]
  22ec10:	89 d1                	mov    ecx,edx
  22ec12:	29 f1                	sub    ecx,esi
        0...9 => digit + '0',
  22ec14:	b3 30                	mov    bl,0x30
  22ec16:	80 f9 0a             	cmp    cl,0xa
  22ec19:	72 02                	jb     22ec1d <callMainWithArgs+0x6dd>
  22ec1b:	b3 57                	mov    bl,0x57
  22ec1d:	00 cb                	add    bl,cl
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  22ec1f:	88 5c 04 0e          	mov    BYTE PTR [rsp+rax*1+0xe],bl
        if (a == 0) break;
  22ec23:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  22ec27:	48 83 ff 63          	cmp    rdi,0x63
  22ec2b:	48 89 d3             	mov    rbx,rdx
  22ec2e:	77 c0                	ja     22ebf0 <callMainWithArgs+0x6b0>
        const padded_buf = buf[index - padding ..];
  22ec30:	4c 8d 3c 04          	lea    r15,[rsp+rax*1]
  22ec34:	49 83 c7 0f          	add    r15,0xf
  22ec38:	b9 41 00 00 00       	mov    ecx,0x41
  22ec3d:	48 29 c1             	sub    rcx,rax
  22ec40:	4c 89 3c 24          	mov    QWORD PTR [rsp],r15
  22ec44:	48 89 4c 24 08       	mov    QWORD PTR [rsp+0x8],rcx
  22ec49:	48 89 e6             	mov    rsi,rsp
        return output(context, padded_buf);
  22ec4c:	48 89 ef             	mov    rdi,rbp
  22ec4f:	c5 f8 77             	vzeroupper 
  22ec52:	41 ff d6             	call   r14
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  22ec55:	66 85 c0             	test   ax,ax
  22ec58:	75 0d                	jne    22ec67 <callMainWithArgs+0x727>
        try output(context, fmt[start_index..]);
  22ec5a:	48 8d 35 b7 14 02 00 	lea    rsi,[rip+0x214b7]        # 250118 <__unnamed_119>
  22ec61:	48 89 ef             	mov    rdi,rbp
  22ec64:	41 ff d6             	call   r14
  22ec67:	31 c0                	xor    eax,eax
  22ec69:	86 05 a1 23 02 00    	xchg   BYTE PTR [rip+0x223a1],al        # 251010 <stderr_mutex>
  22ec6f:	3c 01                	cmp    al,0x1
    if (!ok) {
  22ec71:	75 11                	jne    22ec84 <callMainWithArgs+0x744>
  22ec73:	31 c0                	xor    eax,eax
    return callMain();
  22ec75:	48 83 c4 78          	add    rsp,0x78
  22ec79:	5b                   	pop    rbx
  22ec7a:	41 5c                	pop    r12
  22ec7c:	41 5d                	pop    r13
  22ec7e:	41 5e                	pop    r14
  22ec80:	41 5f                	pop    r15
  22ec82:	5d                   	pop    rbp
  22ec83:	c3                   	ret    
            @panic("assertion failure");
  22ec84:	48 8d 3d 05 11 02 00 	lea    rdi,[rip+0x21105]        # 24fd90 <__unnamed_2>
  22ec8b:	e8 90 3a fe ff       	call   212720 <panic>

000000000022ec90 <memset>:

export fn memset(dest: ?[*]u8, c: u8, n: usize) ?[*]u8 {
    @setRuntimeSafety(false);

    var index: usize = 0;
    while (index != n) : (index += 1)
  22ec90:	48 85 d2             	test   rdx,rdx
  22ec93:	0f 84 d4 01 00 00    	je     22ee6d <memset+0x1dd>
  22ec99:	48 81 fa 80 00 00 00 	cmp    rdx,0x80
  22eca0:	73 08                	jae    22ecaa <memset+0x1a>
  22eca2:	45 31 c0             	xor    r8d,r8d
  22eca5:	e9 a8 01 00 00       	jmp    22ee52 <memset+0x1c2>
  22ecaa:	49 89 d0             	mov    r8,rdx
  22ecad:	49 83 e0 80          	and    r8,0xffffffffffffff80
  22ecb1:	c5 f9 6e c6          	vmovd  xmm0,esi
  22ecb5:	c4 e2 7d 78 c0       	vpbroadcastb ymm0,xmm0
  22ecba:	49 8d 48 80          	lea    rcx,[r8-0x80]
  22ecbe:	48 89 c8             	mov    rax,rcx
  22ecc1:	48 c1 e8 07          	shr    rax,0x7
  22ecc5:	44 8d 48 01          	lea    r9d,[rax+0x1]
  22ecc9:	41 83 e1 07          	and    r9d,0x7
  22eccd:	48 81 f9 80 03 00 00 	cmp    rcx,0x380
  22ecd4:	73 10                	jae    22ece6 <memset+0x56>
  22ecd6:	31 c0                	xor    eax,eax
  22ecd8:	4d 85 c9             	test   r9,r9
  22ecdb:	0f 85 44 01 00 00    	jne    22ee25 <memset+0x195>
  22ece1:	e9 67 01 00 00       	jmp    22ee4d <memset+0x1bd>
  22ece6:	48 8d 8f e0 03 00 00 	lea    rcx,[rdi+0x3e0]
  22eced:	4d 8d 51 ff          	lea    r10,[r9-0x1]
  22ecf1:	49 29 c2             	sub    r10,rax
  22ecf4:	31 c0                	xor    eax,eax
  22ecf6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  22ecfd:	00 00 00 
        dest.?[index] = c;
  22ed00:	c5 fe 7f 84 01 20 fc 	vmovdqu YMMWORD PTR [rcx+rax*1-0x3e0],ymm0
  22ed07:	ff ff 
  22ed09:	c5 fe 7f 84 01 40 fc 	vmovdqu YMMWORD PTR [rcx+rax*1-0x3c0],ymm0
  22ed10:	ff ff 
  22ed12:	c5 fe 7f 84 01 60 fc 	vmovdqu YMMWORD PTR [rcx+rax*1-0x3a0],ymm0
  22ed19:	ff ff 
  22ed1b:	c5 fe 7f 84 01 80 fc 	vmovdqu YMMWORD PTR [rcx+rax*1-0x380],ymm0
  22ed22:	ff ff 
  22ed24:	c5 fe 7f 84 01 a0 fc 	vmovdqu YMMWORD PTR [rcx+rax*1-0x360],ymm0
  22ed2b:	ff ff 
  22ed2d:	c5 fe 7f 84 01 c0 fc 	vmovdqu YMMWORD PTR [rcx+rax*1-0x340],ymm0
  22ed34:	ff ff 
  22ed36:	c5 fe 7f 84 01 e0 fc 	vmovdqu YMMWORD PTR [rcx+rax*1-0x320],ymm0
  22ed3d:	ff ff 
  22ed3f:	c5 fe 7f 84 01 00 fd 	vmovdqu YMMWORD PTR [rcx+rax*1-0x300],ymm0
  22ed46:	ff ff 
  22ed48:	c5 fe 7f 84 01 20 fd 	vmovdqu YMMWORD PTR [rcx+rax*1-0x2e0],ymm0
  22ed4f:	ff ff 
  22ed51:	c5 fe 7f 84 01 40 fd 	vmovdqu YMMWORD PTR [rcx+rax*1-0x2c0],ymm0
  22ed58:	ff ff 
  22ed5a:	c5 fe 7f 84 01 60 fd 	vmovdqu YMMWORD PTR [rcx+rax*1-0x2a0],ymm0
  22ed61:	ff ff 
  22ed63:	c5 fe 7f 84 01 80 fd 	vmovdqu YMMWORD PTR [rcx+rax*1-0x280],ymm0
  22ed6a:	ff ff 
  22ed6c:	c5 fe 7f 84 01 a0 fd 	vmovdqu YMMWORD PTR [rcx+rax*1-0x260],ymm0
  22ed73:	ff ff 
  22ed75:	c5 fe 7f 84 01 c0 fd 	vmovdqu YMMWORD PTR [rcx+rax*1-0x240],ymm0
  22ed7c:	ff ff 
  22ed7e:	c5 fe 7f 84 01 e0 fd 	vmovdqu YMMWORD PTR [rcx+rax*1-0x220],ymm0
  22ed85:	ff ff 
  22ed87:	c5 fe 7f 84 01 00 fe 	vmovdqu YMMWORD PTR [rcx+rax*1-0x200],ymm0
  22ed8e:	ff ff 
  22ed90:	c5 fe 7f 84 01 20 fe 	vmovdqu YMMWORD PTR [rcx+rax*1-0x1e0],ymm0
  22ed97:	ff ff 
  22ed99:	c5 fe 7f 84 01 40 fe 	vmovdqu YMMWORD PTR [rcx+rax*1-0x1c0],ymm0
  22eda0:	ff ff 
  22eda2:	c5 fe 7f 84 01 60 fe 	vmovdqu YMMWORD PTR [rcx+rax*1-0x1a0],ymm0
  22eda9:	ff ff 
  22edab:	c5 fe 7f 84 01 80 fe 	vmovdqu YMMWORD PTR [rcx+rax*1-0x180],ymm0
  22edb2:	ff ff 
  22edb4:	c5 fe 7f 84 01 a0 fe 	vmovdqu YMMWORD PTR [rcx+rax*1-0x160],ymm0
  22edbb:	ff ff 
  22edbd:	c5 fe 7f 84 01 c0 fe 	vmovdqu YMMWORD PTR [rcx+rax*1-0x140],ymm0
  22edc4:	ff ff 
  22edc6:	c5 fe 7f 84 01 e0 fe 	vmovdqu YMMWORD PTR [rcx+rax*1-0x120],ymm0
  22edcd:	ff ff 
  22edcf:	c5 fe 7f 84 01 00 ff 	vmovdqu YMMWORD PTR [rcx+rax*1-0x100],ymm0
  22edd6:	ff ff 
  22edd8:	c5 fe 7f 84 01 20 ff 	vmovdqu YMMWORD PTR [rcx+rax*1-0xe0],ymm0
  22eddf:	ff ff 
  22ede1:	c5 fe 7f 84 01 40 ff 	vmovdqu YMMWORD PTR [rcx+rax*1-0xc0],ymm0
  22ede8:	ff ff 
  22edea:	c5 fe 7f 84 01 60 ff 	vmovdqu YMMWORD PTR [rcx+rax*1-0xa0],ymm0
  22edf1:	ff ff 
  22edf3:	c5 fe 7f 44 01 80    	vmovdqu YMMWORD PTR [rcx+rax*1-0x80],ymm0
  22edf9:	c5 fe 7f 44 01 a0    	vmovdqu YMMWORD PTR [rcx+rax*1-0x60],ymm0
  22edff:	c5 fe 7f 44 01 c0    	vmovdqu YMMWORD PTR [rcx+rax*1-0x40],ymm0
  22ee05:	c5 fe 7f 44 01 e0    	vmovdqu YMMWORD PTR [rcx+rax*1-0x20],ymm0
  22ee0b:	c5 fe 7f 04 01       	vmovdqu YMMWORD PTR [rcx+rax*1],ymm0
    while (index != n) : (index += 1)
  22ee10:	48 05 00 04 00 00    	add    rax,0x400
  22ee16:	49 83 c2 08          	add    r10,0x8
  22ee1a:	0f 85 e0 fe ff ff    	jne    22ed00 <memset+0x70>
  22ee20:	4d 85 c9             	test   r9,r9
  22ee23:	74 28                	je     22ee4d <memset+0x1bd>
  22ee25:	48 01 f8             	add    rax,rdi
  22ee28:	48 83 c0 60          	add    rax,0x60
  22ee2c:	49 f7 d9             	neg    r9
  22ee2f:	90                   	nop
        dest.?[index] = c;
  22ee30:	c5 fe 7f 40 a0       	vmovdqu YMMWORD PTR [rax-0x60],ymm0
  22ee35:	c5 fe 7f 40 c0       	vmovdqu YMMWORD PTR [rax-0x40],ymm0
  22ee3a:	c5 fe 7f 40 e0       	vmovdqu YMMWORD PTR [rax-0x20],ymm0
  22ee3f:	c5 fe 7f 00          	vmovdqu YMMWORD PTR [rax],ymm0
    while (index != n) : (index += 1)
  22ee43:	48 83 e8 80          	sub    rax,0xffffffffffffff80
  22ee47:	49 83 c1 01          	add    r9,0x1
  22ee4b:	75 e3                	jne    22ee30 <memset+0x1a0>
  22ee4d:	49 39 d0             	cmp    r8,rdx
  22ee50:	74 1b                	je     22ee6d <memset+0x1dd>
        dest.?[index] = c;
  22ee52:	4a 8d 04 07          	lea    rax,[rdi+r8*1]
  22ee56:	4c 29 c2             	sub    rdx,r8
  22ee59:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  22ee60:	40 88 30             	mov    BYTE PTR [rax],sil
    while (index != n) : (index += 1)
  22ee63:	48 83 c0 01          	add    rax,0x1
  22ee67:	48 83 c2 ff          	add    rdx,0xffffffffffffffff
  22ee6b:	75 f3                	jne    22ee60 <memset+0x1d0>

    return dest;
  22ee6d:	48 89 f8             	mov    rax,rdi
  22ee70:	c5 f8 77             	vzeroupper 
  22ee73:	c3                   	ret    
  22ee74:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  22ee7b:	00 00 00 00 00 

000000000022ee80 <memcpy>:

export fn memcpy(noalias dest: ?[*]u8, noalias src: ?[*]const u8, n: usize) ?[*]u8 {
    @setRuntimeSafety(false);

    var index: usize = 0;
    while (index != n) : (index += 1)
  22ee80:	48 85 d2             	test   rdx,rdx
  22ee83:	0f 84 d7 01 00 00    	je     22f060 <memcpy+0x1e0>
  22ee89:	48 81 fa 80 00 00 00 	cmp    rdx,0x80
  22ee90:	73 07                	jae    22ee99 <memcpy+0x19>
  22ee92:	31 c0                	xor    eax,eax
  22ee94:	e9 b7 01 00 00       	jmp    22f050 <memcpy+0x1d0>
  22ee99:	48 89 d0             	mov    rax,rdx
  22ee9c:	48 83 e0 80          	and    rax,0xffffffffffffff80
  22eea0:	4c 8d 48 80          	lea    r9,[rax-0x80]
  22eea4:	4c 89 c9             	mov    rcx,r9
  22eea7:	48 c1 e9 07          	shr    rcx,0x7
  22eeab:	44 8d 41 01          	lea    r8d,[rcx+0x1]
  22eeaf:	41 83 e0 03          	and    r8d,0x3
  22eeb3:	49 81 f9 80 01 00 00 	cmp    r9,0x180
  22eeba:	73 10                	jae    22eecc <memcpy+0x4c>
  22eebc:	31 c9                	xor    ecx,ecx
  22eebe:	4d 85 c0             	test   r8,r8
  22eec1:	0f 85 35 01 00 00    	jne    22effc <memcpy+0x17c>
  22eec7:	e9 7c 01 00 00       	jmp    22f048 <memcpy+0x1c8>
  22eecc:	4d 8d 48 ff          	lea    r9,[r8-0x1]
  22eed0:	49 29 c9             	sub    r9,rcx
  22eed3:	31 c9                	xor    ecx,ecx
  22eed5:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  22eedc:	00 00 00 00 
        dest.?[index] = src.?[index];
  22eee0:	c5 fc 10 04 0e       	vmovups ymm0,YMMWORD PTR [rsi+rcx*1]
  22eee5:	c5 fc 10 4c 0e 20    	vmovups ymm1,YMMWORD PTR [rsi+rcx*1+0x20]
  22eeeb:	c5 fc 10 54 0e 40    	vmovups ymm2,YMMWORD PTR [rsi+rcx*1+0x40]
  22eef1:	c5 fc 10 5c 0e 60    	vmovups ymm3,YMMWORD PTR [rsi+rcx*1+0x60]
  22eef7:	c5 fc 11 04 0f       	vmovups YMMWORD PTR [rdi+rcx*1],ymm0
  22eefc:	c5 fc 11 4c 0f 20    	vmovups YMMWORD PTR [rdi+rcx*1+0x20],ymm1
  22ef02:	c5 fc 11 54 0f 40    	vmovups YMMWORD PTR [rdi+rcx*1+0x40],ymm2
  22ef08:	c5 fc 11 5c 0f 60    	vmovups YMMWORD PTR [rdi+rcx*1+0x60],ymm3
  22ef0e:	c5 fc 10 84 0e 80 00 	vmovups ymm0,YMMWORD PTR [rsi+rcx*1+0x80]
  22ef15:	00 00 
  22ef17:	c5 fc 10 8c 0e a0 00 	vmovups ymm1,YMMWORD PTR [rsi+rcx*1+0xa0]
  22ef1e:	00 00 
  22ef20:	c5 fc 10 94 0e c0 00 	vmovups ymm2,YMMWORD PTR [rsi+rcx*1+0xc0]
  22ef27:	00 00 
  22ef29:	c5 fc 10 9c 0e e0 00 	vmovups ymm3,YMMWORD PTR [rsi+rcx*1+0xe0]
  22ef30:	00 00 
  22ef32:	c5 fc 11 84 0f 80 00 	vmovups YMMWORD PTR [rdi+rcx*1+0x80],ymm0
  22ef39:	00 00 
  22ef3b:	c5 fc 11 8c 0f a0 00 	vmovups YMMWORD PTR [rdi+rcx*1+0xa0],ymm1
  22ef42:	00 00 
  22ef44:	c5 fc 11 94 0f c0 00 	vmovups YMMWORD PTR [rdi+rcx*1+0xc0],ymm2
  22ef4b:	00 00 
  22ef4d:	c5 fc 11 9c 0f e0 00 	vmovups YMMWORD PTR [rdi+rcx*1+0xe0],ymm3
  22ef54:	00 00 
  22ef56:	c5 fc 10 84 0e 00 01 	vmovups ymm0,YMMWORD PTR [rsi+rcx*1+0x100]
  22ef5d:	00 00 
  22ef5f:	c5 fc 10 8c 0e 20 01 	vmovups ymm1,YMMWORD PTR [rsi+rcx*1+0x120]
  22ef66:	00 00 
  22ef68:	c5 fc 10 94 0e 40 01 	vmovups ymm2,YMMWORD PTR [rsi+rcx*1+0x140]
  22ef6f:	00 00 
  22ef71:	c5 fc 10 9c 0e 60 01 	vmovups ymm3,YMMWORD PTR [rsi+rcx*1+0x160]
  22ef78:	00 00 
  22ef7a:	c5 fc 11 84 0f 00 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x100],ymm0
  22ef81:	00 00 
  22ef83:	c5 fc 11 8c 0f 20 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x120],ymm1
  22ef8a:	00 00 
  22ef8c:	c5 fc 11 94 0f 40 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x140],ymm2
  22ef93:	00 00 
  22ef95:	c5 fc 11 9c 0f 60 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x160],ymm3
  22ef9c:	00 00 
  22ef9e:	c5 fc 10 84 0e 80 01 	vmovups ymm0,YMMWORD PTR [rsi+rcx*1+0x180]
  22efa5:	00 00 
  22efa7:	c5 fc 10 8c 0e a0 01 	vmovups ymm1,YMMWORD PTR [rsi+rcx*1+0x1a0]
  22efae:	00 00 
  22efb0:	c5 fc 10 94 0e c0 01 	vmovups ymm2,YMMWORD PTR [rsi+rcx*1+0x1c0]
  22efb7:	00 00 
  22efb9:	c5 fc 10 9c 0e e0 01 	vmovups ymm3,YMMWORD PTR [rsi+rcx*1+0x1e0]
  22efc0:	00 00 
  22efc2:	c5 fc 11 84 0f 80 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x180],ymm0
  22efc9:	00 00 
  22efcb:	c5 fc 11 8c 0f a0 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x1a0],ymm1
  22efd2:	00 00 
  22efd4:	c5 fc 11 94 0f c0 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x1c0],ymm2
  22efdb:	00 00 
  22efdd:	c5 fc 11 9c 0f e0 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x1e0],ymm3
  22efe4:	00 00 
    while (index != n) : (index += 1)
  22efe6:	48 81 c1 00 02 00 00 	add    rcx,0x200
  22efed:	49 83 c1 04          	add    r9,0x4
  22eff1:	0f 85 e9 fe ff ff    	jne    22eee0 <memcpy+0x60>
  22eff7:	4d 85 c0             	test   r8,r8
  22effa:	74 4c                	je     22f048 <memcpy+0x1c8>
  22effc:	48 83 c1 60          	add    rcx,0x60
  22f000:	49 f7 d8             	neg    r8
  22f003:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  22f00a:	84 00 00 00 00 00 
        dest.?[index] = src.?[index];
  22f010:	c5 fc 10 44 0e a0    	vmovups ymm0,YMMWORD PTR [rsi+rcx*1-0x60]
  22f016:	c5 fc 10 4c 0e c0    	vmovups ymm1,YMMWORD PTR [rsi+rcx*1-0x40]
  22f01c:	c5 fc 10 54 0e e0    	vmovups ymm2,YMMWORD PTR [rsi+rcx*1-0x20]
  22f022:	c5 fc 10 1c 0e       	vmovups ymm3,YMMWORD PTR [rsi+rcx*1]
  22f027:	c5 fc 11 44 0f a0    	vmovups YMMWORD PTR [rdi+rcx*1-0x60],ymm0
  22f02d:	c5 fc 11 4c 0f c0    	vmovups YMMWORD PTR [rdi+rcx*1-0x40],ymm1
  22f033:	c5 fc 11 54 0f e0    	vmovups YMMWORD PTR [rdi+rcx*1-0x20],ymm2
  22f039:	c5 fc 11 1c 0f       	vmovups YMMWORD PTR [rdi+rcx*1],ymm3
    while (index != n) : (index += 1)
  22f03e:	48 83 e9 80          	sub    rcx,0xffffffffffffff80
  22f042:	49 83 c0 01          	add    r8,0x1
  22f046:	75 c8                	jne    22f010 <memcpy+0x190>
  22f048:	48 39 d0             	cmp    rax,rdx
  22f04b:	74 13                	je     22f060 <memcpy+0x1e0>
  22f04d:	0f 1f 00             	nop    DWORD PTR [rax]
        dest.?[index] = src.?[index];
  22f050:	0f b6 0c 06          	movzx  ecx,BYTE PTR [rsi+rax*1]
  22f054:	88 0c 07             	mov    BYTE PTR [rdi+rax*1],cl
    while (index != n) : (index += 1)
  22f057:	48 83 c0 01          	add    rax,0x1
  22f05b:	48 39 c2             	cmp    rdx,rax
  22f05e:	75 f0                	jne    22f050 <memcpy+0x1d0>

    return dest;
  22f060:	48 89 f8             	mov    rax,rdi
  22f063:	c5 f8 77             	vzeroupper 
  22f066:	c3                   	ret    
  22f067:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  22f06e:	00 00 

000000000022f070 <memmove>:
}

export fn memmove(dest: ?[*]u8, src: ?[*]const u8, n: usize) ?[*]u8 {
    @setRuntimeSafety(false);

    if (@ptrToInt(dest) < @ptrToInt(src)) {
  22f070:	48 39 f7             	cmp    rdi,rsi
  22f073:	0f 83 cb 00 00 00    	jae    22f144 <memmove+0xd4>
  22f079:	48 85 d2             	test   rdx,rdx
        var index: usize = 0;
        while (index != n) : (index += 1) {
  22f07c:	0f 84 0f 05 00 00    	je     22f591 <memmove+0x521>
  22f082:	48 81 fa 80 00 00 00 	cmp    rdx,0x80
  22f089:	72 1a                	jb     22f0a5 <memmove+0x35>
  22f08b:	48 8d 04 16          	lea    rax,[rsi+rdx*1]
  22f08f:	48 39 f8             	cmp    rax,rdi
  22f092:	0f 86 0b 01 00 00    	jbe    22f1a3 <memmove+0x133>
  22f098:	48 8d 04 17          	lea    rax,[rdi+rdx*1]
  22f09c:	48 39 f0             	cmp    rax,rsi
  22f09f:	0f 86 fe 00 00 00    	jbe    22f1a3 <memmove+0x133>
  22f0a5:	45 31 d2             	xor    r10d,r10d
            dest.?[index] = src.?[index];
  22f0a8:	4c 8d 42 ff          	lea    r8,[rdx-0x1]
  22f0ac:	4d 29 d0             	sub    r8,r10
  22f0af:	48 89 d1             	mov    rcx,rdx
  22f0b2:	48 83 e1 07          	and    rcx,0x7
  22f0b6:	74 1b                	je     22f0d3 <memmove+0x63>
  22f0b8:	48 f7 d9             	neg    rcx
  22f0bb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  22f0c0:	42 0f b6 04 16       	movzx  eax,BYTE PTR [rsi+r10*1]
  22f0c5:	42 88 04 17          	mov    BYTE PTR [rdi+r10*1],al
        while (index != n) : (index += 1) {
  22f0c9:	49 83 c2 01          	add    r10,0x1
  22f0cd:	48 83 c1 01          	add    rcx,0x1
  22f0d1:	75 ed                	jne    22f0c0 <memmove+0x50>
            dest.?[index] = src.?[index];
  22f0d3:	49 83 f8 07          	cmp    r8,0x7
  22f0d7:	0f 82 b4 04 00 00    	jb     22f591 <memmove+0x521>
  22f0dd:	0f 1f 00             	nop    DWORD PTR [rax]
  22f0e0:	42 0f b6 04 16       	movzx  eax,BYTE PTR [rsi+r10*1]
  22f0e5:	42 88 04 17          	mov    BYTE PTR [rdi+r10*1],al
  22f0e9:	42 0f b6 44 16 01    	movzx  eax,BYTE PTR [rsi+r10*1+0x1]
  22f0ef:	42 88 44 17 01       	mov    BYTE PTR [rdi+r10*1+0x1],al
  22f0f4:	42 0f b6 44 16 02    	movzx  eax,BYTE PTR [rsi+r10*1+0x2]
  22f0fa:	42 88 44 17 02       	mov    BYTE PTR [rdi+r10*1+0x2],al
  22f0ff:	42 0f b6 44 16 03    	movzx  eax,BYTE PTR [rsi+r10*1+0x3]
  22f105:	42 88 44 17 03       	mov    BYTE PTR [rdi+r10*1+0x3],al
  22f10a:	42 0f b6 44 16 04    	movzx  eax,BYTE PTR [rsi+r10*1+0x4]
  22f110:	42 88 44 17 04       	mov    BYTE PTR [rdi+r10*1+0x4],al
  22f115:	42 0f b6 44 16 05    	movzx  eax,BYTE PTR [rsi+r10*1+0x5]
  22f11b:	42 88 44 17 05       	mov    BYTE PTR [rdi+r10*1+0x5],al
  22f120:	42 0f b6 44 16 06    	movzx  eax,BYTE PTR [rsi+r10*1+0x6]
  22f126:	42 88 44 17 06       	mov    BYTE PTR [rdi+r10*1+0x6],al
  22f12b:	42 0f b6 44 16 07    	movzx  eax,BYTE PTR [rsi+r10*1+0x7]
  22f131:	42 88 44 17 07       	mov    BYTE PTR [rdi+r10*1+0x7],al
        while (index != n) : (index += 1) {
  22f136:	49 83 c2 08          	add    r10,0x8
  22f13a:	4c 39 d2             	cmp    rdx,r10
  22f13d:	75 a1                	jne    22f0e0 <memmove+0x70>
  22f13f:	e9 4d 04 00 00       	jmp    22f591 <memmove+0x521>
  22f144:	48 85 d2             	test   rdx,rdx
        }
    } else {
        var index = n;
        while (index != 0) {
  22f147:	0f 84 44 04 00 00    	je     22f591 <memmove+0x521>
  22f14d:	48 81 fa 80 00 00 00 	cmp    rdx,0x80
  22f154:	0f 82 2a 02 00 00    	jb     22f384 <memmove+0x314>
  22f15a:	48 8d 04 16          	lea    rax,[rsi+rdx*1]
  22f15e:	48 39 f8             	cmp    rax,rdi
  22f161:	76 0d                	jbe    22f170 <memmove+0x100>
  22f163:	48 8d 04 17          	lea    rax,[rdi+rdx*1]
  22f167:	48 39 f0             	cmp    rax,rsi
  22f16a:	0f 87 14 02 00 00    	ja     22f384 <memmove+0x314>
  22f170:	49 89 d0             	mov    r8,rdx
  22f173:	49 83 e0 80          	and    r8,0xffffffffffffff80
  22f177:	49 8d 48 80          	lea    rcx,[r8-0x80]
  22f17b:	48 89 c8             	mov    rax,rcx
  22f17e:	48 c1 e8 07          	shr    rax,0x7
  22f182:	44 8d 48 01          	lea    r9d,[rax+0x1]
  22f186:	41 83 e1 03          	and    r9d,0x3
  22f18a:	48 81 f9 80 01 00 00 	cmp    rcx,0x180
  22f191:	73 47                	jae    22f1da <memmove+0x16a>
  22f193:	31 c0                	xor    eax,eax
  22f195:	4d 85 c9             	test   r9,r9
  22f198:	0f 85 8a 01 00 00    	jne    22f328 <memmove+0x2b8>
  22f19e:	e9 d5 01 00 00       	jmp    22f378 <memmove+0x308>
        while (index != n) : (index += 1) {
  22f1a3:	49 89 d2             	mov    r10,rdx
  22f1a6:	49 83 e2 80          	and    r10,0xffffffffffffff80
  22f1aa:	4d 8d 4a 80          	lea    r9,[r10-0x80]
  22f1ae:	4c 89 c9             	mov    rcx,r9
  22f1b1:	48 c1 e9 07          	shr    rcx,0x7
  22f1b5:	44 8d 41 01          	lea    r8d,[rcx+0x1]
  22f1b9:	41 83 e0 03          	and    r8d,0x3
  22f1bd:	49 81 f9 80 01 00 00 	cmp    r9,0x180
  22f1c4:	0f 83 4c 02 00 00    	jae    22f416 <memmove+0x3a6>
  22f1ca:	31 c9                	xor    ecx,ecx
  22f1cc:	4d 85 c0             	test   r8,r8
  22f1cf:	0f 85 67 03 00 00    	jne    22f53c <memmove+0x4cc>
  22f1d5:	e9 ae 03 00 00       	jmp    22f588 <memmove+0x518>
        while (index != 0) {
  22f1da:	4c 8d 14 16          	lea    r10,[rsi+rdx*1]
  22f1de:	49 83 c2 e0          	add    r10,0xffffffffffffffe0
  22f1e2:	48 8d 0c 17          	lea    rcx,[rdi+rdx*1]
  22f1e6:	48 83 c1 e0          	add    rcx,0xffffffffffffffe0
  22f1ea:	4d 8d 59 ff          	lea    r11,[r9-0x1]
  22f1ee:	49 29 c3             	sub    r11,rax
  22f1f1:	31 c0                	xor    eax,eax
  22f1f3:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  22f1fa:	84 00 00 00 00 00 
            index -= 1;
            dest.?[index] = src.?[index];
  22f200:	c4 c1 7c 10 44 02 a0 	vmovups ymm0,YMMWORD PTR [r10+rax*1-0x60]
  22f207:	c4 c1 7c 10 4c 02 c0 	vmovups ymm1,YMMWORD PTR [r10+rax*1-0x40]
  22f20e:	c4 c1 7c 10 54 02 e0 	vmovups ymm2,YMMWORD PTR [r10+rax*1-0x20]
  22f215:	c4 c1 7c 10 1c 02    	vmovups ymm3,YMMWORD PTR [r10+rax*1]
  22f21b:	c5 fc 11 1c 01       	vmovups YMMWORD PTR [rcx+rax*1],ymm3
  22f220:	c5 fc 11 54 01 e0    	vmovups YMMWORD PTR [rcx+rax*1-0x20],ymm2
  22f226:	c5 fc 11 4c 01 c0    	vmovups YMMWORD PTR [rcx+rax*1-0x40],ymm1
  22f22c:	c5 fc 11 44 01 a0    	vmovups YMMWORD PTR [rcx+rax*1-0x60],ymm0
  22f232:	c4 c1 7c 10 84 02 20 	vmovups ymm0,YMMWORD PTR [r10+rax*1-0xe0]
  22f239:	ff ff ff 
  22f23c:	c4 c1 7c 10 8c 02 40 	vmovups ymm1,YMMWORD PTR [r10+rax*1-0xc0]
  22f243:	ff ff ff 
  22f246:	c4 c1 7c 10 94 02 60 	vmovups ymm2,YMMWORD PTR [r10+rax*1-0xa0]
  22f24d:	ff ff ff 
  22f250:	c4 c1 7c 10 5c 02 80 	vmovups ymm3,YMMWORD PTR [r10+rax*1-0x80]
  22f257:	c5 fc 11 5c 01 80    	vmovups YMMWORD PTR [rcx+rax*1-0x80],ymm3
  22f25d:	c5 fc 11 94 01 60 ff 	vmovups YMMWORD PTR [rcx+rax*1-0xa0],ymm2
  22f264:	ff ff 
  22f266:	c5 fc 11 8c 01 40 ff 	vmovups YMMWORD PTR [rcx+rax*1-0xc0],ymm1
  22f26d:	ff ff 
  22f26f:	c5 fc 11 84 01 20 ff 	vmovups YMMWORD PTR [rcx+rax*1-0xe0],ymm0
  22f276:	ff ff 
  22f278:	c4 c1 7c 10 84 02 a0 	vmovups ymm0,YMMWORD PTR [r10+rax*1-0x160]
  22f27f:	fe ff ff 
  22f282:	c4 c1 7c 10 8c 02 c0 	vmovups ymm1,YMMWORD PTR [r10+rax*1-0x140]
  22f289:	fe ff ff 
  22f28c:	c4 c1 7c 10 94 02 e0 	vmovups ymm2,YMMWORD PTR [r10+rax*1-0x120]
  22f293:	fe ff ff 
  22f296:	c4 c1 7c 10 9c 02 00 	vmovups ymm3,YMMWORD PTR [r10+rax*1-0x100]
  22f29d:	ff ff ff 
  22f2a0:	c5 fc 11 9c 01 00 ff 	vmovups YMMWORD PTR [rcx+rax*1-0x100],ymm3
  22f2a7:	ff ff 
  22f2a9:	c5 fc 11 94 01 e0 fe 	vmovups YMMWORD PTR [rcx+rax*1-0x120],ymm2
  22f2b0:	ff ff 
  22f2b2:	c5 fc 11 8c 01 c0 fe 	vmovups YMMWORD PTR [rcx+rax*1-0x140],ymm1
  22f2b9:	ff ff 
  22f2bb:	c5 fc 11 84 01 a0 fe 	vmovups YMMWORD PTR [rcx+rax*1-0x160],ymm0
  22f2c2:	ff ff 
  22f2c4:	c4 c1 7c 10 84 02 20 	vmovups ymm0,YMMWORD PTR [r10+rax*1-0x1e0]
  22f2cb:	fe ff ff 
  22f2ce:	c4 c1 7c 10 8c 02 40 	vmovups ymm1,YMMWORD PTR [r10+rax*1-0x1c0]
  22f2d5:	fe ff ff 
  22f2d8:	c4 c1 7c 10 94 02 60 	vmovups ymm2,YMMWORD PTR [r10+rax*1-0x1a0]
  22f2df:	fe ff ff 
  22f2e2:	c4 c1 7c 10 9c 02 80 	vmovups ymm3,YMMWORD PTR [r10+rax*1-0x180]
  22f2e9:	fe ff ff 
  22f2ec:	c5 fc 11 9c 01 80 fe 	vmovups YMMWORD PTR [rcx+rax*1-0x180],ymm3
  22f2f3:	ff ff 
  22f2f5:	c5 fc 11 94 01 60 fe 	vmovups YMMWORD PTR [rcx+rax*1-0x1a0],ymm2
  22f2fc:	ff ff 
  22f2fe:	c5 fc 11 8c 01 40 fe 	vmovups YMMWORD PTR [rcx+rax*1-0x1c0],ymm1
  22f305:	ff ff 
  22f307:	c5 fc 11 84 01 20 fe 	vmovups YMMWORD PTR [rcx+rax*1-0x1e0],ymm0
  22f30e:	ff ff 
  22f310:	48 05 00 fe ff ff    	add    rax,0xfffffffffffffe00
  22f316:	49 83 c3 04          	add    r11,0x4
  22f31a:	0f 85 e0 fe ff ff    	jne    22f200 <memmove+0x190>
  22f320:	48 f7 d8             	neg    rax
  22f323:	4d 85 c9             	test   r9,r9
  22f326:	74 50                	je     22f378 <memmove+0x308>
  22f328:	48 8d 4a e0          	lea    rcx,[rdx-0x20]
  22f32c:	48 29 c1             	sub    rcx,rax
  22f32f:	49 f7 d9             	neg    r9
  22f332:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  22f339:	1f 84 00 00 00 00 00 
  22f340:	c5 fc 10 44 0e a0    	vmovups ymm0,YMMWORD PTR [rsi+rcx*1-0x60]
  22f346:	c5 fc 10 4c 0e c0    	vmovups ymm1,YMMWORD PTR [rsi+rcx*1-0x40]
  22f34c:	c5 fc 10 54 0e e0    	vmovups ymm2,YMMWORD PTR [rsi+rcx*1-0x20]
  22f352:	c5 fc 10 1c 0e       	vmovups ymm3,YMMWORD PTR [rsi+rcx*1]
  22f357:	c5 fc 11 1c 0f       	vmovups YMMWORD PTR [rdi+rcx*1],ymm3
  22f35c:	c5 fc 11 54 0f e0    	vmovups YMMWORD PTR [rdi+rcx*1-0x20],ymm2
  22f362:	c5 fc 11 4c 0f c0    	vmovups YMMWORD PTR [rdi+rcx*1-0x40],ymm1
  22f368:	c5 fc 11 44 0f a0    	vmovups YMMWORD PTR [rdi+rcx*1-0x60],ymm0
  22f36e:	48 83 c1 80          	add    rcx,0xffffffffffffff80
  22f372:	49 83 c1 01          	add    r9,0x1
  22f376:	75 c8                	jne    22f340 <memmove+0x2d0>
  22f378:	49 39 d0             	cmp    r8,rdx
        while (index != 0) {
  22f37b:	0f 84 10 02 00 00    	je     22f591 <memmove+0x521>
  22f381:	4c 29 c2             	sub    rdx,r8
            index -= 1;
  22f384:	4c 8d 42 ff          	lea    r8,[rdx-0x1]
  22f388:	48 89 d1             	mov    rcx,rdx
  22f38b:	48 83 e1 07          	and    rcx,0x7
  22f38f:	74 22                	je     22f3b3 <memmove+0x343>
  22f391:	48 f7 d9             	neg    rcx
  22f394:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  22f39b:	00 00 00 00 00 
            dest.?[index] = src.?[index];
  22f3a0:	0f b6 44 16 ff       	movzx  eax,BYTE PTR [rsi+rdx*1-0x1]
  22f3a5:	88 44 17 ff          	mov    BYTE PTR [rdi+rdx*1-0x1],al
            index -= 1;
  22f3a9:	48 8d 52 ff          	lea    rdx,[rdx-0x1]
        while (index != 0) {
  22f3ad:	48 83 c1 01          	add    rcx,0x1
  22f3b1:	75 ed                	jne    22f3a0 <memmove+0x330>
            index -= 1;
  22f3b3:	49 83 f8 07          	cmp    r8,0x7
  22f3b7:	0f 82 d4 01 00 00    	jb     22f591 <memmove+0x521>
        while (index != 0) {
  22f3bd:	48 89 d0             	mov    rax,rdx
            dest.?[index] = src.?[index];
  22f3c0:	0f b6 4c 16 ff       	movzx  ecx,BYTE PTR [rsi+rdx*1-0x1]
  22f3c5:	88 4c 17 ff          	mov    BYTE PTR [rdi+rdx*1-0x1],cl
  22f3c9:	0f b6 4c 16 fe       	movzx  ecx,BYTE PTR [rsi+rdx*1-0x2]
  22f3ce:	88 4c 17 fe          	mov    BYTE PTR [rdi+rdx*1-0x2],cl
  22f3d2:	0f b6 4c 16 fd       	movzx  ecx,BYTE PTR [rsi+rdx*1-0x3]
  22f3d7:	88 4c 17 fd          	mov    BYTE PTR [rdi+rdx*1-0x3],cl
  22f3db:	0f b6 4c 16 fc       	movzx  ecx,BYTE PTR [rsi+rdx*1-0x4]
  22f3e0:	88 4c 17 fc          	mov    BYTE PTR [rdi+rdx*1-0x4],cl
  22f3e4:	0f b6 4c 16 fb       	movzx  ecx,BYTE PTR [rsi+rdx*1-0x5]
  22f3e9:	88 4c 17 fb          	mov    BYTE PTR [rdi+rdx*1-0x5],cl
  22f3ed:	0f b6 4c 16 fa       	movzx  ecx,BYTE PTR [rsi+rdx*1-0x6]
  22f3f2:	88 4c 17 fa          	mov    BYTE PTR [rdi+rdx*1-0x6],cl
  22f3f6:	0f b6 4c 16 f9       	movzx  ecx,BYTE PTR [rsi+rdx*1-0x7]
  22f3fb:	88 4c 17 f9          	mov    BYTE PTR [rdi+rdx*1-0x7],cl
  22f3ff:	0f b6 4c 16 f8       	movzx  ecx,BYTE PTR [rsi+rdx*1-0x8]
  22f404:	88 4c 17 f8          	mov    BYTE PTR [rdi+rdx*1-0x8],cl
        while (index != 0) {
  22f408:	48 83 c0 f8          	add    rax,0xfffffffffffffff8
  22f40c:	48 89 c2             	mov    rdx,rax
  22f40f:	75 af                	jne    22f3c0 <memmove+0x350>
  22f411:	e9 7b 01 00 00       	jmp    22f591 <memmove+0x521>
        while (index != n) : (index += 1) {
  22f416:	4d 8d 48 ff          	lea    r9,[r8-0x1]
  22f41a:	49 29 c9             	sub    r9,rcx
  22f41d:	31 c9                	xor    ecx,ecx
  22f41f:	90                   	nop
            dest.?[index] = src.?[index];
  22f420:	c5 fc 10 04 0e       	vmovups ymm0,YMMWORD PTR [rsi+rcx*1]
  22f425:	c5 fc 10 4c 0e 20    	vmovups ymm1,YMMWORD PTR [rsi+rcx*1+0x20]
  22f42b:	c5 fc 10 54 0e 40    	vmovups ymm2,YMMWORD PTR [rsi+rcx*1+0x40]
  22f431:	c5 fc 10 5c 0e 60    	vmovups ymm3,YMMWORD PTR [rsi+rcx*1+0x60]
  22f437:	c5 fc 11 04 0f       	vmovups YMMWORD PTR [rdi+rcx*1],ymm0
  22f43c:	c5 fc 11 4c 0f 20    	vmovups YMMWORD PTR [rdi+rcx*1+0x20],ymm1
  22f442:	c5 fc 11 54 0f 40    	vmovups YMMWORD PTR [rdi+rcx*1+0x40],ymm2
  22f448:	c5 fc 11 5c 0f 60    	vmovups YMMWORD PTR [rdi+rcx*1+0x60],ymm3
  22f44e:	c5 fc 10 84 0e 80 00 	vmovups ymm0,YMMWORD PTR [rsi+rcx*1+0x80]
  22f455:	00 00 
  22f457:	c5 fc 10 8c 0e a0 00 	vmovups ymm1,YMMWORD PTR [rsi+rcx*1+0xa0]
  22f45e:	00 00 
  22f460:	c5 fc 10 94 0e c0 00 	vmovups ymm2,YMMWORD PTR [rsi+rcx*1+0xc0]
  22f467:	00 00 
  22f469:	c5 fc 10 9c 0e e0 00 	vmovups ymm3,YMMWORD PTR [rsi+rcx*1+0xe0]
  22f470:	00 00 
  22f472:	c5 fc 11 84 0f 80 00 	vmovups YMMWORD PTR [rdi+rcx*1+0x80],ymm0
  22f479:	00 00 
  22f47b:	c5 fc 11 8c 0f a0 00 	vmovups YMMWORD PTR [rdi+rcx*1+0xa0],ymm1
  22f482:	00 00 
  22f484:	c5 fc 11 94 0f c0 00 	vmovups YMMWORD PTR [rdi+rcx*1+0xc0],ymm2
  22f48b:	00 00 
  22f48d:	c5 fc 11 9c 0f e0 00 	vmovups YMMWORD PTR [rdi+rcx*1+0xe0],ymm3
  22f494:	00 00 
  22f496:	c5 fc 10 84 0e 00 01 	vmovups ymm0,YMMWORD PTR [rsi+rcx*1+0x100]
  22f49d:	00 00 
  22f49f:	c5 fc 10 8c 0e 20 01 	vmovups ymm1,YMMWORD PTR [rsi+rcx*1+0x120]
  22f4a6:	00 00 
  22f4a8:	c5 fc 10 94 0e 40 01 	vmovups ymm2,YMMWORD PTR [rsi+rcx*1+0x140]
  22f4af:	00 00 
  22f4b1:	c5 fc 10 9c 0e 60 01 	vmovups ymm3,YMMWORD PTR [rsi+rcx*1+0x160]
  22f4b8:	00 00 
  22f4ba:	c5 fc 11 84 0f 00 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x100],ymm0
  22f4c1:	00 00 
  22f4c3:	c5 fc 11 8c 0f 20 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x120],ymm1
  22f4ca:	00 00 
  22f4cc:	c5 fc 11 94 0f 40 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x140],ymm2
  22f4d3:	00 00 
  22f4d5:	c5 fc 11 9c 0f 60 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x160],ymm3
  22f4dc:	00 00 
  22f4de:	c5 fc 10 84 0e 80 01 	vmovups ymm0,YMMWORD PTR [rsi+rcx*1+0x180]
  22f4e5:	00 00 
  22f4e7:	c5 fc 10 8c 0e a0 01 	vmovups ymm1,YMMWORD PTR [rsi+rcx*1+0x1a0]
  22f4ee:	00 00 
  22f4f0:	c5 fc 10 94 0e c0 01 	vmovups ymm2,YMMWORD PTR [rsi+rcx*1+0x1c0]
  22f4f7:	00 00 
  22f4f9:	c5 fc 10 9c 0e e0 01 	vmovups ymm3,YMMWORD PTR [rsi+rcx*1+0x1e0]
  22f500:	00 00 
  22f502:	c5 fc 11 84 0f 80 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x180],ymm0
  22f509:	00 00 
  22f50b:	c5 fc 11 8c 0f a0 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x1a0],ymm1
  22f512:	00 00 
  22f514:	c5 fc 11 94 0f c0 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x1c0],ymm2
  22f51b:	00 00 
  22f51d:	c5 fc 11 9c 0f e0 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x1e0],ymm3
  22f524:	00 00 
        while (index != n) : (index += 1) {
  22f526:	48 81 c1 00 02 00 00 	add    rcx,0x200
  22f52d:	49 83 c1 04          	add    r9,0x4
  22f531:	0f 85 e9 fe ff ff    	jne    22f420 <memmove+0x3b0>
  22f537:	4d 85 c0             	test   r8,r8
  22f53a:	74 4c                	je     22f588 <memmove+0x518>
  22f53c:	48 83 c1 60          	add    rcx,0x60
  22f540:	49 f7 d8             	neg    r8
  22f543:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  22f54a:	84 00 00 00 00 00 
            dest.?[index] = src.?[index];
  22f550:	c5 fc 10 44 0e a0    	vmovups ymm0,YMMWORD PTR [rsi+rcx*1-0x60]
  22f556:	c5 fc 10 4c 0e c0    	vmovups ymm1,YMMWORD PTR [rsi+rcx*1-0x40]
  22f55c:	c5 fc 10 54 0e e0    	vmovups ymm2,YMMWORD PTR [rsi+rcx*1-0x20]
  22f562:	c5 fc 10 1c 0e       	vmovups ymm3,YMMWORD PTR [rsi+rcx*1]
  22f567:	c5 fc 11 44 0f a0    	vmovups YMMWORD PTR [rdi+rcx*1-0x60],ymm0
  22f56d:	c5 fc 11 4c 0f c0    	vmovups YMMWORD PTR [rdi+rcx*1-0x40],ymm1
  22f573:	c5 fc 11 54 0f e0    	vmovups YMMWORD PTR [rdi+rcx*1-0x20],ymm2
  22f579:	c5 fc 11 1c 0f       	vmovups YMMWORD PTR [rdi+rcx*1],ymm3
        while (index != n) : (index += 1) {
  22f57e:	48 83 e9 80          	sub    rcx,0xffffffffffffff80
  22f582:	49 83 c0 01          	add    r8,0x1
  22f586:	75 c8                	jne    22f550 <memmove+0x4e0>
  22f588:	49 39 d2             	cmp    r10,rdx
  22f58b:	0f 85 17 fb ff ff    	jne    22f0a8 <memmove+0x38>
        }
    }

    return dest;
  22f591:	48 89 f8             	mov    rax,rdi
  22f594:	c5 f8 77             	vzeroupper 
  22f597:	c3                   	ret    
  22f598:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  22f59f:	00 

000000000022f5a0 <clone>:

// TODO we should be able to put this directly in std/linux/x86_64.zig but
// it causes a segfault in release mode. this is a workaround of calling it
// across .o file boundaries. fix comptime @ptrCast of nakedcc functions.
nakedcc fn clone() void {
    asm volatile (
  22f5a0:	31 c0                	xor    eax,eax
  22f5a2:	b0 38                	mov    al,0x38
  22f5a4:	49 89 fb             	mov    r11,rdi
  22f5a7:	48 89 d7             	mov    rdi,rdx
  22f5aa:	4c 89 c2             	mov    rdx,r8
  22f5ad:	4d 89 c8             	mov    r8,r9
  22f5b0:	4c 8b 54 24 08       	mov    r10,QWORD PTR [rsp+0x8]
  22f5b5:	4d 89 d9             	mov    r9,r11
  22f5b8:	48 83 e6 f0          	and    rsi,0xfffffffffffffff0
  22f5bc:	48 83 ee 08          	sub    rsi,0x8
  22f5c0:	48 89 0e             	mov    QWORD PTR [rsi],rcx
  22f5c3:	0f 05                	syscall 
  22f5c5:	85 c0                	test   eax,eax
  22f5c7:	75 0f                	jne    22f5d8 <clone+0x38>
  22f5c9:	31 ed                	xor    ebp,ebp
  22f5cb:	5f                   	pop    rdi
  22f5cc:	41 ff d1             	call   r9
  22f5cf:	89 c7                	mov    edi,eax
  22f5d1:	31 c0                	xor    eax,eax
  22f5d3:	b0 3c                	mov    al,0x3c
  22f5d5:	0f 05                	syscall 
  22f5d7:	f4                   	hlt    
  22f5d8:	c3                   	ret    
nakedcc fn clone() void {
  22f5d9:	c3                   	ret    
  22f5da:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

000000000022f5e0 <fmodf>:
    const digits = if (T == f32) 23 else 52;
    const exp_bits = if (T == f32) 9 else 12;
    const bits_minus_1 = T.bit_count - 1;
    const mask = if (T == f32) 0xff else 0x7ff;
    var ux = @bitCast(uint, x);
    var uy = @bitCast(uint, y);
  22f5e0:	c4 c1 79 7e c9       	vmovd  r9d,xmm1
    var ex = @intCast(i32, (ux >> digits) & mask);
    var ey = @intCast(i32, (uy >> digits) & mask);
    const sx = if (T == f32) @intCast(u32, ux & 0x80000000) else @intCast(i32, ux >> bits_minus_1);
    var i: uint = undefined;

    if (uy << 1 == 0 or isNan(uint, uy) or ex == mask)
  22f5e5:	44 89 c8             	mov    eax,r9d
  22f5e8:	01 c0                	add    eax,eax
  22f5ea:	74 5a                	je     22f646 <fmodf+0x66>

fn isNan(comptime T: type, bits: T) bool {
    if (T == u16) {
        return (bits & 0x7fff) > 0x7c00;
    } else if (T == u32) {
        return (bits & 0x7fffffff) > 0x7f800000;
  22f5ec:	44 89 c9             	mov    ecx,r9d
  22f5ef:	81 e1 ff ff ff 7f    	and    ecx,0x7fffffff
  22f5f5:	81 f9 00 00 80 7f    	cmp    ecx,0x7f800000
    if (uy << 1 == 0 or isNan(uint, uy) or ex == mask)
  22f5fb:	77 49                	ja     22f646 <fmodf+0x66>
  22f5fd:	c4 c1 79 7e c0       	vmovd  r8d,xmm0
  22f602:	ba 17 08 00 00       	mov    edx,0x817
  22f607:	c4 c2 68 f7 c8       	bextr  ecx,r8d,edx
  22f60c:	81 f9 ff 00 00 00    	cmp    ecx,0xff
  22f612:	74 32                	je     22f646 <fmodf+0x66>
    if (ux << 1 <= uy << 1) {
  22f614:	43 8d 34 00          	lea    esi,[r8+r8*1]
  22f618:	39 c6                	cmp    esi,eax
  22f61a:	76 33                	jbe    22f64f <fmodf+0x6f>
  22f61c:	c4 c2 68 f7 f9       	bextr  edi,r9d,edx
        ux &= @maxValue(uint) >> exp_bits;
  22f621:	44 89 c0             	mov    eax,r8d
    if (ex == 0) {
  22f624:	85 c9                	test   ecx,ecx
  22f626:	74 32                	je     22f65a <fmodf+0x7a>
        ux &= @maxValue(uint) >> exp_bits;
  22f628:	25 ff ff 7f 00       	and    eax,0x7fffff
        ux |= 1 << digits;
  22f62d:	0d 00 00 80 00       	or     eax,0x800000
    if (ey == 0) {
  22f632:	85 ff                	test   edi,edi
  22f634:	74 51                	je     22f687 <fmodf+0xa7>
        uy &= @maxValue(uint) >> exp_bits;
  22f636:	41 81 e1 ff ff 7f 00 	and    r9d,0x7fffff
        uy |= 1 << digits;
  22f63d:	41 81 c9 00 00 80 00 	or     r9d,0x800000
  22f644:	eb 7f                	jmp    22f6c5 <fmodf+0xe5>
        return (x * y) / (x * y);
  22f646:	c5 fa 59 c1          	vmulss xmm0,xmm0,xmm1
  22f64a:	c5 fa 5e c0          	vdivss xmm0,xmm0,xmm0
    return generic_fmod(f32, x, y);
  22f64e:	c3                   	ret    
        if (ux << 1 == uy << 1)
  22f64f:	75 08                	jne    22f659 <fmodf+0x79>
  22f651:	c5 f1 ef c9          	vpxor  xmm1,xmm1,xmm1
  22f655:	c5 fa 59 c1          	vmulss xmm0,xmm0,xmm1
  22f659:	c3                   	ret    
  22f65a:	31 c9                	xor    ecx,ecx
        i = ux << exp_bits;
  22f65c:	c1 e0 09             	shl    eax,0x9
        while (i >> bits_minus_1 == 0) : (b: {
  22f65f:	78 16                	js     22f677 <fmodf+0x97>
  22f661:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  22f668:	0f 1f 84 00 00 00 00 
  22f66f:	00 
            ex -= 1;
  22f670:	83 c1 ff             	add    ecx,0xffffffff
            i <<= 1;
  22f673:	01 c0                	add    eax,eax
        while (i >> bits_minus_1 == 0) : (b: {
  22f675:	79 f9                	jns    22f670 <fmodf+0x90>
        ux <<= @intCast(log2uint, @bitCast(u32, -ex + 1));
  22f677:	b8 01 00 00 00       	mov    eax,0x1
  22f67c:	29 c8                	sub    eax,ecx
  22f67e:	c4 c2 79 f7 c0       	shlx   eax,r8d,eax
    if (ey == 0) {
  22f683:	85 ff                	test   edi,edi
  22f685:	75 af                	jne    22f636 <fmodf+0x56>
        i = uy << exp_bits;
  22f687:	44 89 ca             	mov    edx,r9d
  22f68a:	31 ff                	xor    edi,edi
  22f68c:	c1 e2 09             	shl    edx,0x9
        while (i >> bits_minus_1 == 0) : (b: {
  22f68f:	78 16                	js     22f6a7 <fmodf+0xc7>
  22f691:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  22f698:	0f 1f 84 00 00 00 00 
  22f69f:	00 
            ey -= 1;
  22f6a0:	83 c7 ff             	add    edi,0xffffffff
            i <<= 1;
  22f6a3:	01 d2                	add    edx,edx
        while (i >> bits_minus_1 == 0) : (b: {
  22f6a5:	79 f9                	jns    22f6a0 <fmodf+0xc0>
        uy <<= @intCast(log2uint, @bitCast(u32, -ey + 1));
  22f6a7:	ba 01 00 00 00       	mov    edx,0x1
  22f6ac:	29 fa                	sub    edx,edi
  22f6ae:	c4 42 69 f7 c9       	shlx   r9d,r9d,edx
  22f6b3:	eb 10                	jmp    22f6c5 <fmodf+0xe5>
  22f6b5:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  22f6bc:	00 00 00 00 
        ux <<= 1;
  22f6c0:	01 c0                	add    eax,eax
    while (ex > ey) : (ex -= 1) {
  22f6c2:	83 c1 ff             	add    ecx,0xffffffff
  22f6c5:	89 c6                	mov    esi,eax
  22f6c7:	44 29 ce             	sub    esi,r9d
  22f6ca:	0f 99 c2             	setns  dl
  22f6cd:	39 f9                	cmp    ecx,edi
  22f6cf:	7e 0d                	jle    22f6de <fmodf+0xfe>
        if (i >> bits_minus_1 == 0) {
  22f6d1:	f6 c2 01             	test   dl,0x1
  22f6d4:	74 ea                	je     22f6c0 <fmodf+0xe0>
  22f6d6:	89 f0                	mov    eax,esi
            if (i == 0)
  22f6d8:	85 f6                	test   esi,esi
  22f6da:	75 e4                	jne    22f6c0 <fmodf+0xe0>
  22f6dc:	eb 3b                	jmp    22f719 <fmodf+0x139>
    if (i >> bits_minus_1 == 0) {
  22f6de:	84 d2                	test   dl,dl
  22f6e0:	74 06                	je     22f6e8 <fmodf+0x108>
  22f6e2:	89 f0                	mov    eax,esi
        if (i == 0)
  22f6e4:	85 f6                	test   esi,esi
  22f6e6:	74 31                	je     22f719 <fmodf+0x139>
    while (ux >> digits == 0) : (b: {
  22f6e8:	3d ff ff 7f 00       	cmp    eax,0x7fffff
  22f6ed:	77 0d                	ja     22f6fc <fmodf+0x11c>
  22f6ef:	90                   	nop
        ux <<= 1;
  22f6f0:	01 c0                	add    eax,eax
        ex -= 1;
  22f6f2:	83 c1 ff             	add    ecx,0xffffffff
    while (ux >> digits == 0) : (b: {
  22f6f5:	3d 00 00 80 00       	cmp    eax,0x800000
  22f6fa:	72 f4                	jb     22f6f0 <fmodf+0x110>
  22f6fc:	41 81 e0 00 00 00 80 	and    r8d,0x80000000
    if (ex > 0) {
  22f703:	85 c9                	test   ecx,ecx
  22f705:	7e 1b                	jle    22f722 <fmodf+0x142>
        ux -%= 1 << digits;
  22f707:	05 00 00 80 ff       	add    eax,0xff800000
        ux |= uint(@bitCast(u32, ex)) << digits;
  22f70c:	c1 e1 17             	shl    ecx,0x17
  22f70f:	09 c1                	or     ecx,eax
        ux |= sx;
  22f711:	44 09 c1             	or     ecx,r8d
    return @bitCast(T, ux);
  22f714:	c5 f9 6e c1          	vmovd  xmm0,ecx
    return generic_fmod(f32, x, y);
  22f718:	c3                   	ret    
  22f719:	c5 f1 ef c9          	vpxor  xmm1,xmm1,xmm1
  22f71d:	c5 fa 59 c1          	vmulss xmm0,xmm0,xmm1
  22f721:	c3                   	ret    
        ux >>= @intCast(log2uint, @bitCast(u32, -ex + 1));
  22f722:	ba 01 00 00 00       	mov    edx,0x1
  22f727:	29 ca                	sub    edx,ecx
  22f729:	c4 e2 6b f7 c8       	shrx   ecx,eax,edx
        ux |= sx;
  22f72e:	44 09 c1             	or     ecx,r8d
    return @bitCast(T, ux);
  22f731:	c5 f9 6e c1          	vmovd  xmm0,ecx
    return generic_fmod(f32, x, y);
  22f735:	c3                   	ret    
  22f736:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  22f73d:	00 00 00 

000000000022f740 <fmod>:
    var uy = @bitCast(uint, y);
  22f740:	c4 c1 f9 7e cb       	vmovq  r11,xmm1
    if (uy << 1 == 0 or isNan(uint, uy) or ex == mask)
  22f745:	4c 89 d8             	mov    rax,r11
  22f748:	48 01 c0             	add    rax,rax
  22f74b:	74 7a                	je     22f7c7 <fmod+0x87>
  22f74d:	49 b9 ff ff ff ff ff 	movabs r9,0x7fffffffffffffff
  22f754:	ff ff 7f 
    } else if (T == u64) {
        return (bits & (@maxValue(u64) >> 1)) > (u64(0x7ff) << 52);
  22f757:	4c 89 d9             	mov    rcx,r11
  22f75a:	4c 21 c9             	and    rcx,r9
  22f75d:	48 ba 00 00 00 00 00 	movabs rdx,0x7ff0000000000000
  22f764:	00 f0 7f 
  22f767:	48 39 d1             	cmp    rcx,rdx
    if (uy << 1 == 0 or isNan(uint, uy) or ex == mask)
  22f76a:	77 5b                	ja     22f7c7 <fmod+0x87>
  22f76c:	c4 c1 f9 7e c2       	vmovq  r10,xmm0
  22f771:	4c 89 d1             	mov    rcx,r10
  22f774:	48 c1 e9 34          	shr    rcx,0x34
  22f778:	81 e1 ff 07 00 00    	and    ecx,0x7ff
  22f77e:	81 f9 ff 07 00 00    	cmp    ecx,0x7ff
  22f784:	74 41                	je     22f7c7 <fmod+0x87>
    if (ux << 1 <= uy << 1) {
  22f786:	4b 8d 14 12          	lea    rdx,[r10+r10*1]
  22f78a:	48 39 c2             	cmp    rdx,rax
  22f78d:	76 41                	jbe    22f7d0 <fmod+0x90>
  22f78f:	4c 89 df             	mov    rdi,r11
  22f792:	48 c1 ef 34          	shr    rdi,0x34
  22f796:	81 e7 ff 07 00 00    	and    edi,0x7ff
  22f79c:	49 b8 00 00 00 00 00 	movabs r8,0x10000000000000
  22f7a3:	00 10 00 
    if (ex == 0) {
  22f7a6:	85 c9                	test   ecx,ecx
  22f7a8:	74 31                	je     22f7db <fmod+0x9b>
        ux &= @maxValue(uint) >> exp_bits;
  22f7aa:	49 8d 40 ff          	lea    rax,[r8-0x1]
  22f7ae:	4c 21 d0             	and    rax,r10
        ux |= 1 << digits;
  22f7b1:	4c 09 c0             	or     rax,r8
    if (ey == 0) {
  22f7b4:	85 ff                	test   edi,edi
  22f7b6:	74 50                	je     22f808 <fmod+0xc8>
        uy &= @maxValue(uint) >> exp_bits;
  22f7b8:	49 8d 50 ff          	lea    rdx,[r8-0x1]
  22f7bc:	49 21 d3             	and    r11,rdx
        uy |= 1 << digits;
  22f7bf:	4d 09 c3             	or     r11,r8
  22f7c2:	e9 7f 00 00 00       	jmp    22f846 <fmod+0x106>
        return (x * y) / (x * y);
  22f7c7:	c5 fb 59 c1          	vmulsd xmm0,xmm0,xmm1
  22f7cb:	c5 fb 5e c0          	vdivsd xmm0,xmm0,xmm0
    return generic_fmod(f64, x, y);
  22f7cf:	c3                   	ret    
        if (ux << 1 == uy << 1)
  22f7d0:	75 08                	jne    22f7da <fmod+0x9a>
  22f7d2:	c5 f1 ef c9          	vpxor  xmm1,xmm1,xmm1
  22f7d6:	c5 fb 59 c1          	vmulsd xmm0,xmm0,xmm1
  22f7da:	c3                   	ret    
        i = ux << exp_bits;
  22f7db:	4c 89 d0             	mov    rax,r10
  22f7de:	31 c9                	xor    ecx,ecx
  22f7e0:	48 c1 e0 0c          	shl    rax,0xc
        while (i >> bits_minus_1 == 0) : (b: {
  22f7e4:	78 12                	js     22f7f8 <fmod+0xb8>
  22f7e6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  22f7ed:	00 00 00 
            ex -= 1;
  22f7f0:	83 c1 ff             	add    ecx,0xffffffff
            i <<= 1;
  22f7f3:	48 01 c0             	add    rax,rax
        while (i >> bits_minus_1 == 0) : (b: {
  22f7f6:	79 f8                	jns    22f7f0 <fmod+0xb0>
        ux <<= @intCast(log2uint, @bitCast(u32, -ex + 1));
  22f7f8:	b8 01 00 00 00       	mov    eax,0x1
  22f7fd:	29 c8                	sub    eax,ecx
  22f7ff:	c4 c2 f9 f7 c2       	shlx   rax,r10,rax
    if (ey == 0) {
  22f804:	85 ff                	test   edi,edi
  22f806:	75 b0                	jne    22f7b8 <fmod+0x78>
        i = uy << exp_bits;
  22f808:	4c 89 da             	mov    rdx,r11
  22f80b:	31 ff                	xor    edi,edi
  22f80d:	48 c1 e2 0c          	shl    rdx,0xc
        while (i >> bits_minus_1 == 0) : (b: {
  22f811:	78 15                	js     22f828 <fmod+0xe8>
  22f813:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  22f81a:	84 00 00 00 00 00 
            ey -= 1;
  22f820:	83 c7 ff             	add    edi,0xffffffff
            i <<= 1;
  22f823:	48 01 d2             	add    rdx,rdx
        while (i >> bits_minus_1 == 0) : (b: {
  22f826:	79 f8                	jns    22f820 <fmod+0xe0>
        uy <<= @intCast(log2uint, @bitCast(u32, -ey + 1));
  22f828:	ba 01 00 00 00       	mov    edx,0x1
  22f82d:	29 fa                	sub    edx,edi
  22f82f:	c4 42 e9 f7 db       	shlx   r11,r11,rdx
  22f834:	eb 10                	jmp    22f846 <fmod+0x106>
  22f836:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  22f83d:	00 00 00 
        ux <<= 1;
  22f840:	48 01 c0             	add    rax,rax
    while (ex > ey) : (ex -= 1) {
  22f843:	83 c1 ff             	add    ecx,0xffffffff
  22f846:	48 89 c6             	mov    rsi,rax
  22f849:	4c 29 de             	sub    rsi,r11
  22f84c:	0f 99 c2             	setns  dl
  22f84f:	39 f9                	cmp    ecx,edi
  22f851:	7e 0f                	jle    22f862 <fmod+0x122>
        if (i >> bits_minus_1 == 0) {
  22f853:	f6 c2 01             	test   dl,0x1
  22f856:	74 e8                	je     22f840 <fmod+0x100>
  22f858:	48 89 f0             	mov    rax,rsi
            if (i == 0)
  22f85b:	48 85 f6             	test   rsi,rsi
  22f85e:	75 e0                	jne    22f840 <fmod+0x100>
  22f860:	eb 4d                	jmp    22f8af <fmod+0x16f>
    if (i >> bits_minus_1 == 0) {
  22f862:	84 d2                	test   dl,dl
  22f864:	74 08                	je     22f86e <fmod+0x12e>
  22f866:	48 89 f0             	mov    rax,rsi
        if (i == 0)
  22f869:	48 85 f6             	test   rsi,rsi
  22f86c:	74 41                	je     22f8af <fmod+0x16f>
  22f86e:	49 83 c1 01          	add    r9,0x1
    while (ux >> digits == 0) : (b: {
  22f872:	4c 39 c0             	cmp    rax,r8
  22f875:	73 14                	jae    22f88b <fmod+0x14b>
  22f877:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  22f87e:	00 00 
        ux <<= 1;
  22f880:	48 01 c0             	add    rax,rax
        ex -= 1;
  22f883:	83 c1 ff             	add    ecx,0xffffffff
    while (ux >> digits == 0) : (b: {
  22f886:	4c 39 c0             	cmp    rax,r8
  22f889:	72 f5                	jb     22f880 <fmod+0x140>
  22f88b:	4d 21 ca             	and    r10,r9
    if (ex > 0) {
  22f88e:	85 c9                	test   ecx,ecx
  22f890:	7e 26                	jle    22f8b8 <fmod+0x178>
        ux -%= 1 << digits;
  22f892:	48 ba 00 00 00 00 00 	movabs rdx,0xfff0000000000000
  22f899:	00 f0 ff 
  22f89c:	48 01 d0             	add    rax,rdx
        ux |= uint(@bitCast(u32, ex)) << digits;
  22f89f:	48 c1 e1 34          	shl    rcx,0x34
  22f8a3:	48 09 c1             	or     rcx,rax
        ux |= @intCast(uint, sx) << bits_minus_1;
  22f8a6:	4c 09 d1             	or     rcx,r10
    return @bitCast(T, ux);
  22f8a9:	c4 e1 f9 6e c1       	vmovq  xmm0,rcx
    return generic_fmod(f64, x, y);
  22f8ae:	c3                   	ret    
  22f8af:	c5 f1 ef c9          	vpxor  xmm1,xmm1,xmm1
  22f8b3:	c5 fb 59 c1          	vmulsd xmm0,xmm0,xmm1
  22f8b7:	c3                   	ret    
        ux >>= @intCast(log2uint, @bitCast(u32, -ex + 1));
  22f8b8:	ba 01 00 00 00       	mov    edx,0x1
  22f8bd:	29 ca                	sub    edx,ecx
  22f8bf:	c4 e2 eb f7 c8       	shrx   rcx,rax,rdx
        ux |= @intCast(uint, sx) << bits_minus_1;
  22f8c4:	4c 09 d1             	or     rcx,r10
    return @bitCast(T, ux);
  22f8c7:	c4 e1 f9 6e c1       	vmovq  xmm0,rcx
    return generic_fmod(f64, x, y);
  22f8cc:	c3                   	ret    
  22f8cd:	0f 1f 00             	nop    DWORD PTR [rax]

000000000022f8d0 <floorf>:
    if (x == 0.0) {
  22f8d0:	c5 f0 57 c9          	vxorps xmm1,xmm1,xmm1
  22f8d4:	c5 f8 2e c1          	vucomiss xmm0,xmm1
  22f8d8:	75 02                	jne    22f8dc <floorf+0xc>
  22f8da:	7b 57                	jnp    22f933 <floorf+0x63>
  22f8dc:	c5 f9 7e c1          	vmovd  ecx,xmm0
  22f8e0:	89 c8                	mov    eax,ecx
  22f8e2:	c1 e8 17             	shr    eax,0x17
  22f8e5:	0f b6 d0             	movzx  edx,al
  22f8e8:	81 fa 95 00 00 00    	cmp    edx,0x95
  22f8ee:	77 43                	ja     22f933 <floorf+0x63>
    if (e >= 0) {
  22f8f0:	83 fa 7f             	cmp    edx,0x7f
  22f8f3:	72 2e                	jb     22f923 <floorf+0x53>
  22f8f5:	83 c0 01             	add    eax,0x1
        m = u32(0x007FFFFF) >> @intCast(u5, e);
  22f8f8:	83 e0 1f             	and    eax,0x1f
  22f8fb:	ba ff ff 7f 00       	mov    edx,0x7fffff
  22f900:	c4 e2 7b f7 d2       	shrx   edx,edx,eax
        if (u & m == 0) {
  22f905:	85 ca                	test   edx,ecx
  22f907:	74 2a                	je     22f933 <floorf+0x63>
        if (u >> 31 != 0) {
  22f909:	89 ce                	mov    esi,ecx
  22f90b:	c1 fe 1f             	sar    esi,0x1f
  22f90e:	21 d6                	and    esi,edx
  22f910:	01 ce                	add    esi,ecx
        return @bitCast(f32, u & ~m);
  22f912:	b9 00 00 80 ff       	mov    ecx,0xff800000
  22f917:	c4 e2 7a f7 c1       	sarx   eax,ecx,eax
  22f91c:	21 f0                	and    eax,esi
  22f91e:	c5 f9 6e c0          	vmovd  xmm0,eax
    return math.floor(x);
  22f922:	c3                   	ret    
        if (u >> 31 == 0) {
  22f923:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  22f927:	85 c9                	test   ecx,ecx
  22f929:	79 08                	jns    22f933 <floorf+0x63>
  22f92b:	c5 f9 6e 05 45 9e fd 	vmovd  xmm0,DWORD PTR [rip+0xfffffffffffd9e45]        # 209778 <__unnamed_40+0x15>
  22f932:	ff 
  22f933:	c3                   	ret    
  22f934:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  22f93b:	00 00 00 00 00 

000000000022f940 <ceilf>:
    var u = @bitCast(u32, x);
    var e = @intCast(i32, (u >> 23) & 0xFF) - 0x7F;
    var m: u32 = undefined;

    // TODO: Shouldn't need this explicit check.
    if (x == 0.0) {
  22f940:	c5 f0 57 c9          	vxorps xmm1,xmm1,xmm1
  22f944:	c5 f8 2e c1          	vucomiss xmm0,xmm1
  22f948:	75 02                	jne    22f94c <ceilf+0xc>
  22f94a:	7b 5a                	jnp    22f9a6 <ceilf+0x66>
  22f94c:	c5 f9 7e c1          	vmovd  ecx,xmm0
  22f950:	89 c8                	mov    eax,ecx
  22f952:	c1 e8 17             	shr    eax,0x17
  22f955:	0f b6 d0             	movzx  edx,al
  22f958:	81 fa 95 00 00 00    	cmp    edx,0x95
  22f95e:	77 46                	ja     22f9a6 <ceilf+0x66>
        return x;
    }

    if (e >= 23) {
        return x;
    } else if (e >= 0) {
  22f960:	83 fa 7f             	cmp    edx,0x7f
  22f963:	72 31                	jb     22f996 <ceilf+0x56>
  22f965:	83 c0 01             	add    eax,0x1
        m = u32(0x007FFFFF) >> @intCast(u5, e);
  22f968:	83 e0 1f             	and    eax,0x1f
  22f96b:	ba ff ff 7f 00       	mov    edx,0x7fffff
  22f970:	c4 e2 7b f7 d2       	shrx   edx,edx,eax
        if (u & m == 0) {
  22f975:	85 ca                	test   edx,ecx
  22f977:	74 2d                	je     22f9a6 <ceilf+0x66>
            return x;
        }
        math.forceEval(x + 0x1.0p120);
        if (u >> 31 == 0) {
  22f979:	89 ce                	mov    esi,ecx
  22f97b:	c1 fe 1f             	sar    esi,0x1f
  22f97e:	c4 e2 48 f2 d2       	andn   edx,esi,edx
  22f983:	01 ca                	add    edx,ecx
            u += m;
        }
        u &= ~m;
  22f985:	b9 00 00 80 ff       	mov    ecx,0xff800000
  22f98a:	c4 e2 7a f7 c1       	sarx   eax,ecx,eax
  22f98f:	21 d0                	and    eax,edx
        return @bitCast(f32, u);
  22f991:	c5 f9 6e c0          	vmovd  xmm0,eax
    return math.ceil(x);
  22f995:	c3                   	ret    
    } else {
        math.forceEval(x + 0x1.0p120);
        if (u >> 31 != 0) {
  22f996:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  22f99a:	85 c9                	test   ecx,ecx
  22f99c:	78 08                	js     22f9a6 <ceilf+0x66>
  22f99e:	c5 f9 6e 05 ce 9d fd 	vmovd  xmm0,DWORD PTR [rip+0xfffffffffffd9dce]        # 209774 <__unnamed_40+0x11>
  22f9a5:	ff 
  22f9a6:	c3                   	ret    
  22f9a7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  22f9ae:	00 00 

000000000022f9b0 <floor>:
    if (e >= 0x3FF + 52 or x == 0) {
  22f9b0:	c5 f1 57 c9          	vxorpd xmm1,xmm1,xmm1
  22f9b4:	c5 f9 2e c1          	vucomisd xmm0,xmm1
  22f9b8:	75 02                	jne    22f9bc <floor+0xc>
  22f9ba:	7b 58                	jnp    22fa14 <floor+0x64>
  22f9bc:	c4 e1 f9 7e c0       	vmovq  rax,xmm0
  22f9c1:	b9 34 0b 00 00       	mov    ecx,0xb34
  22f9c6:	c4 e2 f0 f7 c8       	bextr  rcx,rax,rcx
  22f9cb:	48 81 f9 32 04 00 00 	cmp    rcx,0x432
  22f9d2:	77 40                	ja     22fa14 <floor+0x64>
        y = x - math.f64_toint + math.f64_toint - x;
  22f9d4:	c5 fb 10 0d 7c 12 fd 	vmovsd xmm1,QWORD PTR [rip+0xfffffffffffd127c]        # 200c58 <__unnamed_464+0x48>
  22f9db:	ff 
  22f9dc:	c5 fb 10 15 b4 12 fd 	vmovsd xmm2,QWORD PTR [rip+0xfffffffffffd12b4]        # 200c98 <__unnamed_622+0x20>
  22f9e3:	ff 
    if (u >> 63 != 0) {
  22f9e4:	48 85 c0             	test   rax,rax
  22f9e7:	78 2c                	js     22fa15 <floor+0x65>
  22f9e9:	c5 fb 58 d2          	vaddsd xmm2,xmm0,xmm2
  22f9ed:	c5 eb 58 c9          	vaddsd xmm1,xmm2,xmm1
    if (e <= 0x3FF - 1) {
  22f9f1:	48 81 f9 fe 03 00 00 	cmp    rcx,0x3fe
  22f9f8:	76 2c                	jbe    22fa26 <floor+0x76>
  22f9fa:	c5 f3 5c c8          	vsubsd xmm1,xmm1,xmm0
    } else if (y > 0) {
  22f9fe:	c5 e9 57 d2          	vxorpd xmm2,xmm2,xmm2
  22fa02:	c5 f9 2e ca          	vucomisd xmm1,xmm2
  22fa06:	c5 f3 58 c0          	vaddsd xmm0,xmm1,xmm0
  22fa0a:	76 08                	jbe    22fa14 <floor+0x64>
        return x + y - 1;
  22fa0c:	c5 fb 58 05 5c 12 fd 	vaddsd xmm0,xmm0,QWORD PTR [rip+0xfffffffffffd125c]        # 200c70 <__unnamed_464+0x60>
  22fa13:	ff 
    return math.floor(x);
  22fa14:	c3                   	ret    
  22fa15:	c5 fb 58 c9          	vaddsd xmm1,xmm0,xmm1
  22fa19:	c5 f3 58 ca          	vaddsd xmm1,xmm1,xmm2
    if (e <= 0x3FF - 1) {
  22fa1d:	48 81 f9 fe 03 00 00 	cmp    rcx,0x3fe
  22fa24:	77 d4                	ja     22f9fa <floor+0x4a>
    if (u >> 63 != 0) {
  22fa26:	48 85 c0             	test   rax,rax
        if (u >> 63 != 0) {
  22fa29:	78 05                	js     22fa30 <floor+0x80>
  22fa2b:	c5 f9 57 c0          	vxorpd xmm0,xmm0,xmm0
  22fa2f:	c3                   	ret    
  22fa30:	c5 fb 10 05 38 12 fd 	vmovsd xmm0,QWORD PTR [rip+0xfffffffffffd1238]        # 200c70 <__unnamed_464+0x60>
  22fa37:	ff 
  22fa38:	c3                   	ret    
  22fa39:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

000000000022fa40 <ceil>:
fn ceil64(x: f64) f64 {
    const u = @bitCast(u64, x);
    const e = (u >> 52) & 0x7FF;
    var y: f64 = undefined;

    if (e >= 0x3FF + 52 or x == 0) {
  22fa40:	c5 f1 57 c9          	vxorpd xmm1,xmm1,xmm1
  22fa44:	c5 f9 2e c1          	vucomisd xmm0,xmm1
  22fa48:	75 02                	jne    22fa4c <ceil+0xc>
  22fa4a:	7b 7d                	jnp    22fac9 <ceil+0x89>
  22fa4c:	c4 e1 f9 7e c0       	vmovq  rax,xmm0
  22fa51:	b9 34 0b 00 00       	mov    ecx,0xb34
  22fa56:	c4 e2 f0 f7 c8       	bextr  rcx,rax,rcx
  22fa5b:	48 81 f9 32 04 00 00 	cmp    rcx,0x432
  22fa62:	77 65                	ja     22fac9 <ceil+0x89>
        return x;
    }

    if (u >> 63 != 0) {
        y = x - math.f64_toint + math.f64_toint - x;
  22fa64:	c5 fb 10 0d ec 11 fd 	vmovsd xmm1,QWORD PTR [rip+0xfffffffffffd11ec]        # 200c58 <__unnamed_464+0x48>
  22fa6b:	ff 
  22fa6c:	c5 fb 10 15 24 12 fd 	vmovsd xmm2,QWORD PTR [rip+0xfffffffffffd1224]        # 200c98 <__unnamed_622+0x20>
  22fa73:	ff 
    if (u >> 63 != 0) {
  22fa74:	48 85 c0             	test   rax,rax
  22fa77:	78 2d                	js     22faa6 <ceil+0x66>
  22fa79:	c5 fb 58 d2          	vaddsd xmm2,xmm0,xmm2
  22fa7d:	c5 eb 58 c9          	vaddsd xmm1,xmm2,xmm1
    } else {
        y = x + math.f64_toint - math.f64_toint - x;
    }

    if (e <= 0x3FF - 1) {
  22fa81:	48 81 f9 fe 03 00 00 	cmp    rcx,0x3fe
  22fa88:	76 2d                	jbe    22fab7 <ceil+0x77>
  22fa8a:	c5 f3 5c c8          	vsubsd xmm1,xmm1,xmm0
        if (u >> 63 != 0) {
            return -0.0;
        } else {
            return 1.0;
        }
    } else if (y < 0) {
  22fa8e:	c5 e9 57 d2          	vxorpd xmm2,xmm2,xmm2
  22fa92:	c5 f9 2e d1          	vucomisd xmm2,xmm1
  22fa96:	c5 f3 58 c0          	vaddsd xmm0,xmm1,xmm0
  22fa9a:	76 2d                	jbe    22fac9 <ceil+0x89>
        return x + y + 1;
  22fa9c:	c5 fb 58 05 a4 11 fd 	vaddsd xmm0,xmm0,QWORD PTR [rip+0xfffffffffffd11a4]        # 200c48 <__unnamed_464+0x38>
  22faa3:	ff 
  22faa4:	eb 23                	jmp    22fac9 <ceil+0x89>
  22faa6:	c5 fb 58 c9          	vaddsd xmm1,xmm0,xmm1
  22faaa:	c5 f3 58 ca          	vaddsd xmm1,xmm1,xmm2
    if (e <= 0x3FF - 1) {
  22faae:	48 81 f9 fe 03 00 00 	cmp    rcx,0x3fe
  22fab5:	77 d3                	ja     22fa8a <ceil+0x4a>
        if (u >> 63 != 0) {
  22fab7:	c5 f9 57 c0          	vxorpd xmm0,xmm0,xmm0
    if (u >> 63 != 0) {
  22fabb:	48 85 c0             	test   rax,rax
        if (u >> 63 != 0) {
  22fabe:	78 09                	js     22fac9 <ceil+0x89>
  22fac0:	c5 fb 10 05 80 11 fd 	vmovsd xmm0,QWORD PTR [rip+0xfffffffffffd1180]        # 200c48 <__unnamed_464+0x38>
  22fac7:	ff 
    return math.ceil(x);
  22fac8:	c3                   	ret    
  22fac9:	c3                   	ret    
  22faca:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

000000000022fad0 <sqrt>:
// behaviour. Most intermediate i32 values are changed to u32 where appropriate but there are
// potentially some edge cases remaining that are not handled in the same way.
export fn sqrt(x: f64) f64 {
    const tiny: f64 = 1.0e-300;
    const sign: u32 = 0x80000000;
    const u = @bitCast(u64, x);
  22fad0:	c4 e1 f9 7e c0       	vmovq  rax,xmm0

    var ix0 = @intCast(u32, u >> 32);
  22fad5:	48 89 c7             	mov    rdi,rax
  22fad8:	48 c1 ef 20          	shr    rdi,0x20
    var ix1 = @intCast(u32, u & 0xFFFFFFFF);

    // sqrt(nan) = nan, sqrt(+inf) = +inf, sqrt(-inf) = nan
    if (ix0 & 0x7FF00000 == 0x7FF00000) {
  22fadc:	b9 00 00 f0 7f       	mov    ecx,0x7ff00000
  22fae1:	c4 e2 40 f2 c9       	andn   ecx,edi,ecx
  22fae6:	75 09                	jne    22faf1 <sqrt+0x21>
        return x * x + x;
  22fae8:	c5 fb 59 c8          	vmulsd xmm1,xmm0,xmm0
  22faec:	c5 f3 58 c0          	vaddsd xmm0,xmm1,xmm0
  22faf0:	c3                   	ret    
    }

    // sqrt(+-0) = +-0
    if (x == 0.0) {
  22faf1:	c5 f0 57 c9          	vxorps xmm1,xmm1,xmm1
  22faf5:	c5 f9 2e c1          	vucomisd xmm0,xmm1
  22faf9:	75 03                	jne    22fafe <sqrt+0x2e>
  22fafb:	7a 01                	jp     22fafe <sqrt+0x2e>
        return x;
  22fafd:	c3                   	ret    
    }
    // sqrt(-ve) = snan
    if (ix0 & sign != 0) {
  22fafe:	85 ff                	test   edi,edi
  22fb00:	0f 88 cf 00 00 00    	js     22fbd5 <sqrt+0x105>
        return math.snan(f64);
    }

    // normalize x
    var m = @intCast(i32, ix0 >> 20);
  22fb06:	49 89 c0             	mov    r8,rax
  22fb09:	49 c1 e8 34          	shr    r8,0x34
    if (m == 0) {
  22fb0d:	45 85 c0             	test   r8d,r8d
  22fb10:	75 5b                	jne    22fb6d <sqrt+0x9d>
  22fb12:	31 d2                	xor    edx,edx
  22fb14:	31 c9                	xor    ecx,ecx
        // subnormal
        while (ix0 == 0) {
  22fb16:	85 ff                	test   edi,edi
  22fb18:	75 15                	jne    22fb2f <sqrt+0x5f>
  22fb1a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
            m -= 21;
  22fb20:	83 c1 eb             	add    ecx,0xffffffeb
            ix0 |= ix1 >> 11;
  22fb23:	89 c7                	mov    edi,eax
  22fb25:	c1 ef 0b             	shr    edi,0xb
            ix1 <<= 21;
  22fb28:	c1 e0 15             	shl    eax,0x15
        while (ix0 == 0) {
  22fb2b:	85 ff                	test   edi,edi
  22fb2d:	74 f1                	je     22fb20 <sqrt+0x50>
  22fb2f:	31 f6                	xor    esi,esi
        }

        // subnormal
        var i: u32 = 0;
        while (ix0 & 0x00100000 == 0) : (i += 1) {
  22fb31:	0f ba e7 14          	bt     edi,0x14
  22fb35:	72 20                	jb     22fb57 <sqrt+0x87>
  22fb37:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  22fb3e:	00 00 
  22fb40:	89 fa                	mov    edx,edi
            ix0 <<= 1;
  22fb42:	8d 3c 12             	lea    edi,[rdx+rdx*1]
        while (ix0 & 0x00100000 == 0) : (i += 1) {
  22fb45:	83 c6 ff             	add    esi,0xffffffff
  22fb48:	f7 c2 00 00 08 00    	test   edx,0x80000
  22fb4e:	74 f0                	je     22fb40 <sqrt+0x70>
  22fb50:	89 f2                	mov    edx,esi
  22fb52:	f7 da                	neg    edx
  22fb54:	83 e2 1f             	and    edx,0x1f
        }
        m -= @intCast(i32, i) - 1;
  22fb57:	44 8d 04 31          	lea    r8d,[rcx+rsi*1]
  22fb5b:	41 83 c0 01          	add    r8d,0x1
        ix0 |= ix1 >> @intCast(u5, 32 - i);
  22fb5f:	c4 e2 4b f7 c8       	shrx   ecx,eax,esi
  22fb64:	09 f9                	or     ecx,edi
        ix1 <<= @intCast(u5, i);
  22fb66:	c4 e2 69 f7 c0       	shlx   eax,eax,edx
  22fb6b:	89 cf                	mov    edi,ecx
    }

    // unbias exponent
    m -= 1023;
  22fb6d:	41 81 c0 01 fc ff ff 	add    r8d,0xfffffc01
    ix0 = (ix0 & 0x000FFFFF) | 0x00100000;
  22fb74:	81 e7 ff ff 0f 00    	and    edi,0xfffff
  22fb7a:	81 cf 00 00 10 00    	or     edi,0x100000
    if (m & 1 != 0) {
  22fb80:	41 f6 c0 01          	test   r8b,0x1
  22fb84:	74 06                	je     22fb8c <sqrt+0xbc>
        ix0 += ix0 + (ix1 >> 31);
  22fb86:	0f a4 c7 01          	shld   edi,eax,0x1
        ix1 = ix1 +% ix1;
  22fb8a:	01 c0                	add    eax,eax
    }
    m >>= 1;

    // sqrt(x) bit by bit
    ix0 += ix0 + (ix1 >> 31);
  22fb8c:	0f a4 c7 01          	shld   edi,eax,0x1
    var t: u32 = undefined;
    var t1: u32 = undefined;

    while (r != 0) {
        t = s0 +% r;
        if (t <= ix0) {
  22fb90:	31 f6                	xor    esi,esi
  22fb92:	81 ff ff ff 1f 00    	cmp    edi,0x1fffff
  22fb98:	40 0f 97 c6          	seta   sil
  22fb9c:	41 89 f1             	mov    r9d,esi
  22fb9f:	41 c1 e1 15          	shl    r9d,0x15
  22fba3:	c1 e6 16             	shl    esi,0x16
            s0 = t + r;
            ix0 -= t;
            q += r;
        }
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  22fba6:	8d 0c 3f             	lea    ecx,[rdi+rdi*1]
        if (t <= ix0) {
  22fba9:	81 ff 00 00 20 00    	cmp    edi,0x200000
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  22fbaf:	8d bc 3f 00 00 c0 ff 	lea    edi,[rdi+rdi*1-0x400000]
  22fbb6:	0f 42 f9             	cmovb  edi,ecx
  22fbb9:	b9 1e 01 00 00       	mov    ecx,0x11e
  22fbbe:	c4 e2 70 f7 d0       	bextr  edx,eax,ecx
  22fbc3:	09 fa                	or     edx,edi
        t = s0 +% r;
  22fbc5:	8d be 00 00 10 00    	lea    edi,[rsi+0x100000]
        if (t <= ix0) {
  22fbcb:	89 d1                	mov    ecx,edx
  22fbcd:	29 f9                	sub    ecx,edi
  22fbcf:	73 0d                	jae    22fbde <sqrt+0x10e>
  22fbd1:	89 d1                	mov    ecx,edx
  22fbd3:	eb 18                	jmp    22fbed <sqrt+0x11d>
  22fbd5:	c5 fb 10 05 03 11 fd 	vmovsd xmm0,QWORD PTR [rip+0xfffffffffffd1103]        # 200ce0 <__unnamed_621+0x28>
  22fbdc:	ff 
        return x;
  22fbdd:	c3                   	ret    
            s0 = t + r;
  22fbde:	81 c7 00 00 10 00    	add    edi,0x100000
            q += r;
  22fbe4:	41 81 c9 00 00 10 00 	or     r9d,0x100000
  22fbeb:	89 fe                	mov    esi,edi
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  22fbed:	ba 1d 01 00 00       	mov    edx,0x11d
  22fbf2:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  22fbf7:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  22fbfa:	8d be 00 00 08 00    	lea    edi,[rsi+0x80000]
        if (t <= ix0) {
  22fc00:	89 d1                	mov    ecx,edx
  22fc02:	29 f9                	sub    ecx,edi
  22fc04:	73 04                	jae    22fc0a <sqrt+0x13a>
  22fc06:	89 d1                	mov    ecx,edx
  22fc08:	eb 0d                	jmp    22fc17 <sqrt+0x147>
            s0 = t + r;
  22fc0a:	81 c6 00 00 10 00    	add    esi,0x100000
            q += r;
  22fc10:	41 81 c1 00 00 08 00 	add    r9d,0x80000
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  22fc17:	ba 1c 01 00 00       	mov    edx,0x11c
  22fc1c:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  22fc21:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  22fc24:	8d be 00 00 04 00    	lea    edi,[rsi+0x40000]
        if (t <= ix0) {
  22fc2a:	89 d1                	mov    ecx,edx
  22fc2c:	29 f9                	sub    ecx,edi
  22fc2e:	73 04                	jae    22fc34 <sqrt+0x164>
  22fc30:	89 d1                	mov    ecx,edx
  22fc32:	eb 0d                	jmp    22fc41 <sqrt+0x171>
            s0 = t + r;
  22fc34:	81 c6 00 00 08 00    	add    esi,0x80000
            q += r;
  22fc3a:	41 81 c1 00 00 04 00 	add    r9d,0x40000
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  22fc41:	ba 1b 01 00 00       	mov    edx,0x11b
  22fc46:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  22fc4b:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  22fc4e:	8d be 00 00 02 00    	lea    edi,[rsi+0x20000]
        if (t <= ix0) {
  22fc54:	89 d1                	mov    ecx,edx
  22fc56:	29 f9                	sub    ecx,edi
  22fc58:	73 04                	jae    22fc5e <sqrt+0x18e>
  22fc5a:	89 d1                	mov    ecx,edx
  22fc5c:	eb 0d                	jmp    22fc6b <sqrt+0x19b>
            s0 = t + r;
  22fc5e:	81 c6 00 00 04 00    	add    esi,0x40000
            q += r;
  22fc64:	41 81 c1 00 00 02 00 	add    r9d,0x20000
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  22fc6b:	ba 1a 01 00 00       	mov    edx,0x11a
  22fc70:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  22fc75:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  22fc78:	8d be 00 00 01 00    	lea    edi,[rsi+0x10000]
        if (t <= ix0) {
  22fc7e:	89 d1                	mov    ecx,edx
  22fc80:	29 f9                	sub    ecx,edi
  22fc82:	73 04                	jae    22fc88 <sqrt+0x1b8>
  22fc84:	89 d1                	mov    ecx,edx
  22fc86:	eb 0d                	jmp    22fc95 <sqrt+0x1c5>
            s0 = t + r;
  22fc88:	81 c6 00 00 02 00    	add    esi,0x20000
            q += r;
  22fc8e:	41 81 c1 00 00 01 00 	add    r9d,0x10000
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  22fc95:	ba 19 01 00 00       	mov    edx,0x119
  22fc9a:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  22fc9f:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  22fca2:	8d be 00 80 00 00    	lea    edi,[rsi+0x8000]
        if (t <= ix0) {
  22fca8:	89 d1                	mov    ecx,edx
  22fcaa:	29 f9                	sub    ecx,edi
  22fcac:	73 04                	jae    22fcb2 <sqrt+0x1e2>
  22fcae:	89 d1                	mov    ecx,edx
  22fcb0:	eb 0d                	jmp    22fcbf <sqrt+0x1ef>
            s0 = t + r;
  22fcb2:	81 c6 00 00 01 00    	add    esi,0x10000
            q += r;
  22fcb8:	41 81 c1 00 80 00 00 	add    r9d,0x8000
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  22fcbf:	ba 18 01 00 00       	mov    edx,0x118
  22fcc4:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  22fcc9:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  22fccc:	8d be 00 40 00 00    	lea    edi,[rsi+0x4000]
        if (t <= ix0) {
  22fcd2:	89 d1                	mov    ecx,edx
  22fcd4:	29 f9                	sub    ecx,edi
  22fcd6:	73 04                	jae    22fcdc <sqrt+0x20c>
  22fcd8:	89 d1                	mov    ecx,edx
  22fcda:	eb 0d                	jmp    22fce9 <sqrt+0x219>
            s0 = t + r;
  22fcdc:	81 c6 00 80 00 00    	add    esi,0x8000
            q += r;
  22fce2:	41 81 c1 00 40 00 00 	add    r9d,0x4000
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  22fce9:	ba 17 01 00 00       	mov    edx,0x117
  22fcee:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  22fcf3:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  22fcf6:	8d be 00 20 00 00    	lea    edi,[rsi+0x2000]
        if (t <= ix0) {
  22fcfc:	89 d1                	mov    ecx,edx
  22fcfe:	29 f9                	sub    ecx,edi
  22fd00:	73 04                	jae    22fd06 <sqrt+0x236>
  22fd02:	89 d1                	mov    ecx,edx
  22fd04:	eb 0d                	jmp    22fd13 <sqrt+0x243>
            s0 = t + r;
  22fd06:	81 c6 00 40 00 00    	add    esi,0x4000
            q += r;
  22fd0c:	41 81 c1 00 20 00 00 	add    r9d,0x2000
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  22fd13:	ba 16 01 00 00       	mov    edx,0x116
  22fd18:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  22fd1d:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  22fd20:	8d be 00 10 00 00    	lea    edi,[rsi+0x1000]
        if (t <= ix0) {
  22fd26:	89 d1                	mov    ecx,edx
  22fd28:	29 f9                	sub    ecx,edi
  22fd2a:	73 04                	jae    22fd30 <sqrt+0x260>
  22fd2c:	89 d1                	mov    ecx,edx
  22fd2e:	eb 0d                	jmp    22fd3d <sqrt+0x26d>
            s0 = t + r;
  22fd30:	81 c6 00 20 00 00    	add    esi,0x2000
            q += r;
  22fd36:	41 81 c1 00 10 00 00 	add    r9d,0x1000
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  22fd3d:	ba 15 01 00 00       	mov    edx,0x115
  22fd42:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  22fd47:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  22fd4a:	8d be 00 08 00 00    	lea    edi,[rsi+0x800]
        if (t <= ix0) {
  22fd50:	89 d1                	mov    ecx,edx
  22fd52:	29 f9                	sub    ecx,edi
  22fd54:	73 04                	jae    22fd5a <sqrt+0x28a>
  22fd56:	89 d1                	mov    ecx,edx
  22fd58:	eb 0d                	jmp    22fd67 <sqrt+0x297>
            s0 = t + r;
  22fd5a:	81 c6 00 10 00 00    	add    esi,0x1000
            q += r;
  22fd60:	41 81 c1 00 08 00 00 	add    r9d,0x800
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  22fd67:	ba 14 01 00 00       	mov    edx,0x114
  22fd6c:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  22fd71:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  22fd74:	8d be 00 04 00 00    	lea    edi,[rsi+0x400]
        if (t <= ix0) {
  22fd7a:	89 d1                	mov    ecx,edx
  22fd7c:	29 f9                	sub    ecx,edi
  22fd7e:	73 04                	jae    22fd84 <sqrt+0x2b4>
  22fd80:	89 d1                	mov    ecx,edx
  22fd82:	eb 0d                	jmp    22fd91 <sqrt+0x2c1>
            s0 = t + r;
  22fd84:	81 c6 00 08 00 00    	add    esi,0x800
            q += r;
  22fd8a:	41 81 c1 00 04 00 00 	add    r9d,0x400
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  22fd91:	ba 13 01 00 00       	mov    edx,0x113
  22fd96:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  22fd9b:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  22fd9e:	8d be 00 02 00 00    	lea    edi,[rsi+0x200]
        if (t <= ix0) {
  22fda4:	89 d1                	mov    ecx,edx
  22fda6:	29 f9                	sub    ecx,edi
  22fda8:	73 04                	jae    22fdae <sqrt+0x2de>
  22fdaa:	89 d1                	mov    ecx,edx
  22fdac:	eb 0d                	jmp    22fdbb <sqrt+0x2eb>
            s0 = t + r;
  22fdae:	81 c6 00 04 00 00    	add    esi,0x400
            q += r;
  22fdb4:	41 81 c1 00 02 00 00 	add    r9d,0x200
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  22fdbb:	ba 12 01 00 00       	mov    edx,0x112
  22fdc0:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  22fdc5:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  22fdc8:	8d be 00 01 00 00    	lea    edi,[rsi+0x100]
        if (t <= ix0) {
  22fdce:	89 d1                	mov    ecx,edx
  22fdd0:	29 f9                	sub    ecx,edi
  22fdd2:	73 04                	jae    22fdd8 <sqrt+0x308>
  22fdd4:	89 d1                	mov    ecx,edx
  22fdd6:	eb 0d                	jmp    22fde5 <sqrt+0x315>
            s0 = t + r;
  22fdd8:	81 c6 00 02 00 00    	add    esi,0x200
            q += r;
  22fdde:	41 81 c1 00 01 00 00 	add    r9d,0x100
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  22fde5:	ba 11 01 00 00       	mov    edx,0x111
  22fdea:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  22fdef:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  22fdf2:	89 f7                	mov    edi,esi
  22fdf4:	83 ef 80             	sub    edi,0xffffff80
        if (t <= ix0) {
  22fdf7:	89 d1                	mov    ecx,edx
  22fdf9:	29 f9                	sub    ecx,edi
  22fdfb:	73 04                	jae    22fe01 <sqrt+0x331>
  22fdfd:	89 d1                	mov    ecx,edx
  22fdff:	eb 0a                	jmp    22fe0b <sqrt+0x33b>
            s0 = t + r;
  22fe01:	81 c6 00 01 00 00    	add    esi,0x100
            q += r;
  22fe07:	41 83 e9 80          	sub    r9d,0xffffff80
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  22fe0b:	ba 10 01 00 00       	mov    edx,0x110
  22fe10:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  22fe15:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  22fe18:	8d 7e 40             	lea    edi,[rsi+0x40]
        if (t <= ix0) {
  22fe1b:	89 d1                	mov    ecx,edx
  22fe1d:	29 f9                	sub    ecx,edi
  22fe1f:	73 04                	jae    22fe25 <sqrt+0x355>
  22fe21:	89 d1                	mov    ecx,edx
  22fe23:	eb 07                	jmp    22fe2c <sqrt+0x35c>
            s0 = t + r;
  22fe25:	83 ee 80             	sub    esi,0xffffff80
            q += r;
  22fe28:	41 83 c1 40          	add    r9d,0x40
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  22fe2c:	ba 0f 01 00 00       	mov    edx,0x10f
  22fe31:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  22fe36:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  22fe39:	8d 7e 20             	lea    edi,[rsi+0x20]
        if (t <= ix0) {
  22fe3c:	89 d1                	mov    ecx,edx
  22fe3e:	29 f9                	sub    ecx,edi
  22fe40:	73 04                	jae    22fe46 <sqrt+0x376>
  22fe42:	89 d1                	mov    ecx,edx
  22fe44:	eb 07                	jmp    22fe4d <sqrt+0x37d>
            s0 = t + r;
  22fe46:	83 c6 40             	add    esi,0x40
            q += r;
  22fe49:	41 83 c1 20          	add    r9d,0x20
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  22fe4d:	ba 0e 01 00 00       	mov    edx,0x10e
  22fe52:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  22fe57:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  22fe5a:	8d 7e 10             	lea    edi,[rsi+0x10]
        if (t <= ix0) {
  22fe5d:	89 d1                	mov    ecx,edx
  22fe5f:	29 f9                	sub    ecx,edi
  22fe61:	73 04                	jae    22fe67 <sqrt+0x397>
  22fe63:	89 d1                	mov    ecx,edx
  22fe65:	eb 07                	jmp    22fe6e <sqrt+0x39e>
            s0 = t + r;
  22fe67:	83 c6 20             	add    esi,0x20
            q += r;
  22fe6a:	41 83 c1 10          	add    r9d,0x10
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  22fe6e:	ba 0d 01 00 00       	mov    edx,0x10d
  22fe73:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  22fe78:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  22fe7b:	8d 7e 08             	lea    edi,[rsi+0x8]
        if (t <= ix0) {
  22fe7e:	89 d1                	mov    ecx,edx
  22fe80:	29 f9                	sub    ecx,edi
  22fe82:	73 04                	jae    22fe88 <sqrt+0x3b8>
  22fe84:	89 d1                	mov    ecx,edx
  22fe86:	eb 07                	jmp    22fe8f <sqrt+0x3bf>
            s0 = t + r;
  22fe88:	83 c6 10             	add    esi,0x10
            q += r;
  22fe8b:	41 83 c1 08          	add    r9d,0x8
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  22fe8f:	ba 0c 01 00 00       	mov    edx,0x10c
  22fe94:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  22fe99:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  22fe9c:	8d 7e 04             	lea    edi,[rsi+0x4]
        if (t <= ix0) {
  22fe9f:	89 d1                	mov    ecx,edx
  22fea1:	29 f9                	sub    ecx,edi
  22fea3:	73 04                	jae    22fea9 <sqrt+0x3d9>
  22fea5:	89 d1                	mov    ecx,edx
  22fea7:	eb 07                	jmp    22feb0 <sqrt+0x3e0>
            s0 = t + r;
  22fea9:	83 c6 08             	add    esi,0x8
            q += r;
  22feac:	41 83 c1 04          	add    r9d,0x4
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  22feb0:	ba 0b 01 00 00       	mov    edx,0x10b
  22feb5:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  22feba:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  22febd:	8d 7e 02             	lea    edi,[rsi+0x2]
        if (t <= ix0) {
  22fec0:	89 d1                	mov    ecx,edx
  22fec2:	29 f9                	sub    ecx,edi
  22fec4:	73 04                	jae    22feca <sqrt+0x3fa>
  22fec6:	89 d1                	mov    ecx,edx
  22fec8:	eb 07                	jmp    22fed1 <sqrt+0x401>
            s0 = t + r;
  22feca:	83 c6 04             	add    esi,0x4
            q += r;
  22fecd:	41 83 c1 02          	add    r9d,0x2
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  22fed1:	ba 0a 01 00 00       	mov    edx,0x10a
  22fed6:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  22fedb:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  22fede:	8d 7e 01             	lea    edi,[rsi+0x1]
        if (t <= ix0) {
  22fee1:	89 d1                	mov    ecx,edx
  22fee3:	29 f9                	sub    ecx,edi
  22fee5:	73 04                	jae    22feeb <sqrt+0x41b>
  22fee7:	89 d1                	mov    ecx,edx
  22fee9:	eb 07                	jmp    22fef2 <sqrt+0x422>
            s0 = t + r;
  22feeb:	83 c6 02             	add    esi,0x2
            q += r;
  22feee:	41 83 c1 01          	add    r9d,0x1
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  22fef2:	55                   	push   rbp
  22fef3:	41 56                	push   r14
  22fef5:	53                   	push   rbx
  22fef6:	ba 09 01 00 00       	mov    edx,0x109
  22fefb:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  22ff00:	c1 e0 17             	shl    eax,0x17
  22ff03:	8d 1c 4a             	lea    ebx,[rdx+rcx*2]
    m >>= 1;
  22ff06:	41 d1 e8             	shr    r8d,1
  22ff09:	31 d2                	xor    edx,edx
  22ff0b:	bf 00 00 00 80       	mov    edi,0x80000000
  22ff10:	41 ba 1e 01 00 00    	mov    r10d,0x11e
  22ff16:	41 bb 1d 01 00 00    	mov    r11d,0x11d
  22ff1c:	41 be 1c 01 00 00    	mov    r14d,0x11c
  22ff22:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  22ff29:	1f 84 00 00 00 00 00 

    r = sign;
    while (r != 0) {
        t = s1 +% r;
        t = s0;
        if (t < ix0 or (t == ix0 and t1 <= ix1)) {
  22ff30:	89 fd                	mov    ebp,edi
  22ff32:	89 f1                	mov    ecx,esi
  22ff34:	39 f3                	cmp    ebx,esi
  22ff36:	73 04                	jae    22ff3c <sqrt+0x46c>
  22ff38:	31 ed                	xor    ebp,ebp
  22ff3a:	31 c9                	xor    ecx,ecx
  22ff3c:	01 d5                	add    ebp,edx
  22ff3e:	29 cb                	sub    ebx,ecx
                ix0 -= 1;
            }
            ix1 = ix1 -% t1;
            q1 += r;
        }
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  22ff40:	0f a4 c3 01          	shld   ebx,eax,0x1
        if (t < ix0 or (t == ix0 and t1 <= ix1)) {
  22ff44:	39 f3                	cmp    ebx,esi
  22ff46:	73 08                	jae    22ff50 <sqrt+0x480>
  22ff48:	31 d2                	xor    edx,edx
  22ff4a:	31 c9                	xor    ecx,ecx
  22ff4c:	eb 08                	jmp    22ff56 <sqrt+0x486>
  22ff4e:	66 90                	xchg   ax,ax
  22ff50:	89 fa                	mov    edx,edi
  22ff52:	d1 ea                	shr    edx,1
  22ff54:	89 f1                	mov    ecx,esi
  22ff56:	01 ea                	add    edx,ebp
  22ff58:	29 cb                	sub    ebx,ecx
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  22ff5a:	c4 e2 28 f7 c8       	bextr  ecx,eax,r10d
  22ff5f:	8d 2c 59             	lea    ebp,[rcx+rbx*2]
        if (t < ix0 or (t == ix0 and t1 <= ix1)) {
  22ff62:	39 f5                	cmp    ebp,esi
  22ff64:	73 0a                	jae    22ff70 <sqrt+0x4a0>
  22ff66:	31 db                	xor    ebx,ebx
  22ff68:	31 c9                	xor    ecx,ecx
  22ff6a:	eb 0b                	jmp    22ff77 <sqrt+0x4a7>
  22ff6c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  22ff70:	89 fb                	mov    ebx,edi
  22ff72:	c1 eb 02             	shr    ebx,0x2
  22ff75:	89 f1                	mov    ecx,esi
  22ff77:	01 d3                	add    ebx,edx
  22ff79:	29 cd                	sub    ebp,ecx
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  22ff7b:	c4 e2 20 f7 c8       	bextr  ecx,eax,r11d
  22ff80:	8d 2c 69             	lea    ebp,[rcx+rbp*2]
        if (t < ix0 or (t == ix0 and t1 <= ix1)) {
  22ff83:	39 f5                	cmp    ebp,esi
  22ff85:	73 09                	jae    22ff90 <sqrt+0x4c0>
  22ff87:	31 d2                	xor    edx,edx
  22ff89:	31 c9                	xor    ecx,ecx
  22ff8b:	eb 0a                	jmp    22ff97 <sqrt+0x4c7>
  22ff8d:	0f 1f 00             	nop    DWORD PTR [rax]
  22ff90:	89 fa                	mov    edx,edi
  22ff92:	c1 ea 03             	shr    edx,0x3
  22ff95:	89 f1                	mov    ecx,esi
  22ff97:	01 da                	add    edx,ebx
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  22ff99:	c4 e2 08 f7 d8       	bextr  ebx,eax,r14d
        if (t < ix0 or (t == ix0 and t1 <= ix1)) {
  22ff9e:	29 cd                	sub    ebp,ecx
  22ffa0:	c1 e0 04             	shl    eax,0x4
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  22ffa3:	8d 1c 6b             	lea    ebx,[rbx+rbp*2]
        ix1 = ix1 +% ix1;
        r >>= 1;
  22ffa6:	c1 ef 04             	shr    edi,0x4
    while (r != 0) {
  22ffa9:	75 85                	jne    22ff30 <sqrt+0x460>
    }

    // rounding direction
    if (ix0 | ix1 != 0) {
  22ffab:	09 c3                	or     ebx,eax
  22ffad:	5b                   	pop    rbx
  22ffae:	41 5e                	pop    r14
  22ffb0:	5d                   	pop    rbp
  22ffb1:	74 16                	je     22ffc9 <sqrt+0x4f9>
        var z = 1.0 - tiny; // raise inexact
        if (z >= 1.0) {
            z = 1.0 + tiny;
            if (q1 == 0xFFFFFFFF) {
  22ffb3:	83 fa ff             	cmp    edx,0xffffffff
  22ffb6:	74 0b                	je     22ffc3 <sqrt+0x4f3>
                if (q1 == 0xFFFFFFFE) {
                    q += 1;
                }
                q1 += 2;
            } else {
                q1 += q1 & 1;
  22ffb8:	89 d0                	mov    eax,edx
  22ffba:	83 e0 01             	and    eax,0x1
  22ffbd:	01 d0                	add    eax,edx
  22ffbf:	89 c2                	mov    edx,eax
  22ffc1:	eb 06                	jmp    22ffc9 <sqrt+0x4f9>
                q += 1;
  22ffc3:	41 83 c1 01          	add    r9d,0x1
  22ffc7:	31 d2                	xor    edx,edx
            }
        }
    }

    ix0 = (q >> 1) + 0x3FE00000;
  22ffc9:	44 89 c8             	mov    eax,r9d
  22ffcc:	d1 e8                	shr    eax,1
    ix1 = q1 >> 1;
    if (q & 1 != 0) {
  22ffce:	44 0f ac ca 01       	shrd   edx,r9d,0x1
    }

    // NOTE: musl here appears to rely on signed twos-complement wraparound. +% has the same
    // behaviour at least.
    var iix0 = @intCast(i32, ix0);
    iix0 = iix0 +% (m << 20);
  22ffd3:	41 c1 e0 14          	shl    r8d,0x14
  22ffd7:	41 8d 04 00          	lea    eax,[r8+rax*1]
  22ffdb:	05 00 00 e0 3f       	add    eax,0x3fe00000

    const uz = (@intCast(u64, iix0) << 32) | ix1;
  22ffe0:	48 c1 e0 20          	shl    rax,0x20
  22ffe4:	48 09 c2             	or     rdx,rax
    return @bitCast(f64, uz);
  22ffe7:	c4 e1 f9 6e c2       	vmovq  xmm0,rdx
  22ffec:	c3                   	ret    
  22ffed:	0f 1f 00             	nop    DWORD PTR [rax]

000000000022fff0 <sqrtf>:
}

export fn sqrtf(x: f32) f32 {
    const tiny: f32 = 1.0e-30;
    const sign: i32 = @bitCast(i32, u32(0x80000000));
    var ix: i32 = @bitCast(i32, x);
  22fff0:	c5 f9 7e c1          	vmovd  ecx,xmm0

    if ((ix & 0x7F800000) == 0x7F800000) {
  22fff4:	b8 00 00 80 7f       	mov    eax,0x7f800000
  22fff9:	c4 e2 70 f2 c0       	andn   eax,ecx,eax
  22fffe:	75 09                	jne    230009 <sqrtf+0x19>
        return x * x + x; // sqrt(nan) = nan, sqrt(+inf) = +inf, sqrt(-inf) = snan
  230000:	c5 fa 59 c8          	vmulss xmm1,xmm0,xmm0
  230004:	c5 f2 58 c0          	vaddss xmm0,xmm1,xmm0
  230008:	c3                   	ret    
    }

    // zero
    if (ix <= 0) {
  230009:	85 c9                	test   ecx,ecx
  23000b:	7e 15                	jle    230022 <sqrtf+0x32>
  23000d:	41 89 c8             	mov    r8d,ecx
  230010:	41 c1 e8 17          	shr    r8d,0x17
        }
    }

    // normalize
    var m = ix >> 23;
    if (m == 0) {
  230014:	75 45                	jne    23005b <sqrtf+0x6b>
  230016:	31 d2                	xor    edx,edx
        // subnormal
        var i: i32 = 0;
        while (ix & 0x00800000 == 0) : (i += 1) {
  230018:	0f ba e1 17          	bt     ecx,0x17
  23001c:	73 18                	jae    230036 <sqrtf+0x46>
  23001e:	89 ce                	mov    esi,ecx
  230020:	eb 2e                	jmp    230050 <sqrtf+0x60>
        if (ix & ~sign == 0) {
  230022:	f7 c1 ff ff ff 7f    	test   ecx,0x7fffffff
  230028:	0f 84 26 03 00 00    	je     230354 <sqrtf+0x364>
        if (ix < 0) {
  23002e:	85 c9                	test   ecx,ecx
  230030:	0f 88 16 03 00 00    	js     23034c <sqrtf+0x35c>
  230036:	31 d2                	xor    edx,edx
  230038:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  23003f:	00 
            ix <<= 1;
  230040:	8d 34 09             	lea    esi,[rcx+rcx*1]
        while (ix & 0x00800000 == 0) : (i += 1) {
  230043:	83 c2 01             	add    edx,0x1
  230046:	f7 c1 00 00 40 00    	test   ecx,0x400000
  23004c:	89 f1                	mov    ecx,esi
  23004e:	74 f0                	je     230040 <sqrtf+0x50>
        }
        m -= i - 1;
  230050:	41 b8 01 00 00 00    	mov    r8d,0x1
  230056:	41 29 d0             	sub    r8d,edx
  230059:	89 f1                	mov    ecx,esi
    }

    m -= 127; // unbias exponent
  23005b:	41 83 c0 81          	add    r8d,0xffffff81
    ix = (ix & 0x007FFFFF) | 0x00800000;
  23005f:	81 e1 ff ff 7f 00    	and    ecx,0x7fffff
  230065:	81 c9 00 00 80 00    	or     ecx,0x800000

    if (m & 1 != 0) { // odd m, double x to even
  23006b:	44 89 c0             	mov    eax,r8d
  23006e:	24 01                	and    al,0x1
  230070:	c4 e2 79 f7 c1       	shlx   eax,ecx,eax
  230075:	8d 34 85 00 00 00 00 	lea    esi,[rax*4+0x0]
    var s: i32 = 0;
    var r: i32 = 0x01000000; // r = moving bit right -> left

    while (r != 0) {
        const t = s + r;
        if (t <= ix) {
  23007c:	31 d2                	xor    edx,edx
  23007e:	3d ff ff 7f 00       	cmp    eax,0x7fffff
  230083:	0f 9f c2             	setg   dl
  230086:	89 d1                	mov    ecx,edx
  230088:	c1 e1 18             	shl    ecx,0x18
  23008b:	c1 e2 19             	shl    edx,0x19
  23008e:	3d 00 00 80 00       	cmp    eax,0x800000
  230093:	8d 3c 85 00 00 00 fe 	lea    edi,[rax*4-0x2000000]
  23009a:	0f 4c fe             	cmovl  edi,esi
        const t = s + r;
  23009d:	8d 82 00 00 80 00    	lea    eax,[rdx+0x800000]
        if (t <= ix) {
  2300a3:	89 fe                	mov    esi,edi
  2300a5:	29 c6                	sub    esi,eax
  2300a7:	7d 04                	jge    2300ad <sqrtf+0xbd>
  2300a9:	89 fe                	mov    esi,edi
  2300ab:	eb 0d                	jmp    2300ba <sqrtf+0xca>
            s = t + r;
  2300ad:	05 00 00 80 00       	add    eax,0x800000
            ix -= t;
            q += r;
  2300b2:	81 c9 00 00 80 00    	or     ecx,0x800000
  2300b8:	89 c2                	mov    edx,eax
  2300ba:	01 f6                	add    esi,esi
        const t = s + r;
  2300bc:	8d 82 00 00 40 00    	lea    eax,[rdx+0x400000]
        if (t <= ix) {
  2300c2:	89 f7                	mov    edi,esi
  2300c4:	29 c7                	sub    edi,eax
  2300c6:	7d 04                	jge    2300cc <sqrtf+0xdc>
  2300c8:	89 f7                	mov    edi,esi
  2300ca:	eb 0c                	jmp    2300d8 <sqrtf+0xe8>
            s = t + r;
  2300cc:	81 c2 00 00 80 00    	add    edx,0x800000
            q += r;
  2300d2:	81 c1 00 00 40 00    	add    ecx,0x400000
  2300d8:	01 ff                	add    edi,edi
        const t = s + r;
  2300da:	8d 82 00 00 20 00    	lea    eax,[rdx+0x200000]
        if (t <= ix) {
  2300e0:	89 fe                	mov    esi,edi
  2300e2:	29 c6                	sub    esi,eax
  2300e4:	7d 04                	jge    2300ea <sqrtf+0xfa>
  2300e6:	89 fe                	mov    esi,edi
  2300e8:	eb 0c                	jmp    2300f6 <sqrtf+0x106>
            s = t + r;
  2300ea:	81 c2 00 00 40 00    	add    edx,0x400000
            q += r;
  2300f0:	81 c1 00 00 20 00    	add    ecx,0x200000
  2300f6:	01 f6                	add    esi,esi
        const t = s + r;
  2300f8:	8d 82 00 00 10 00    	lea    eax,[rdx+0x100000]
        if (t <= ix) {
  2300fe:	89 f7                	mov    edi,esi
  230100:	29 c7                	sub    edi,eax
  230102:	7d 04                	jge    230108 <sqrtf+0x118>
  230104:	89 f7                	mov    edi,esi
  230106:	eb 0c                	jmp    230114 <sqrtf+0x124>
            s = t + r;
  230108:	81 c2 00 00 20 00    	add    edx,0x200000
            q += r;
  23010e:	81 c1 00 00 10 00    	add    ecx,0x100000
  230114:	01 ff                	add    edi,edi
        const t = s + r;
  230116:	8d 82 00 00 08 00    	lea    eax,[rdx+0x80000]
        if (t <= ix) {
  23011c:	89 fe                	mov    esi,edi
  23011e:	29 c6                	sub    esi,eax
  230120:	7d 04                	jge    230126 <sqrtf+0x136>
  230122:	89 fe                	mov    esi,edi
  230124:	eb 0c                	jmp    230132 <sqrtf+0x142>
            s = t + r;
  230126:	81 c2 00 00 10 00    	add    edx,0x100000
            q += r;
  23012c:	81 c1 00 00 08 00    	add    ecx,0x80000
  230132:	01 f6                	add    esi,esi
        const t = s + r;
  230134:	8d 82 00 00 04 00    	lea    eax,[rdx+0x40000]
        if (t <= ix) {
  23013a:	89 f7                	mov    edi,esi
  23013c:	29 c7                	sub    edi,eax
  23013e:	7d 04                	jge    230144 <sqrtf+0x154>
  230140:	89 f7                	mov    edi,esi
  230142:	eb 0c                	jmp    230150 <sqrtf+0x160>
            s = t + r;
  230144:	81 c2 00 00 08 00    	add    edx,0x80000
            q += r;
  23014a:	81 c1 00 00 04 00    	add    ecx,0x40000
  230150:	01 ff                	add    edi,edi
        const t = s + r;
  230152:	8d 82 00 00 02 00    	lea    eax,[rdx+0x20000]
        if (t <= ix) {
  230158:	89 fe                	mov    esi,edi
  23015a:	29 c6                	sub    esi,eax
  23015c:	7d 04                	jge    230162 <sqrtf+0x172>
  23015e:	89 fe                	mov    esi,edi
  230160:	eb 0c                	jmp    23016e <sqrtf+0x17e>
            s = t + r;
  230162:	81 c2 00 00 04 00    	add    edx,0x40000
            q += r;
  230168:	81 c1 00 00 02 00    	add    ecx,0x20000
  23016e:	01 f6                	add    esi,esi
        const t = s + r;
  230170:	8d 82 00 00 01 00    	lea    eax,[rdx+0x10000]
        if (t <= ix) {
  230176:	89 f7                	mov    edi,esi
  230178:	29 c7                	sub    edi,eax
  23017a:	7d 04                	jge    230180 <sqrtf+0x190>
  23017c:	89 f7                	mov    edi,esi
  23017e:	eb 0c                	jmp    23018c <sqrtf+0x19c>
            s = t + r;
  230180:	81 c2 00 00 02 00    	add    edx,0x20000
            q += r;
  230186:	81 c1 00 00 01 00    	add    ecx,0x10000
  23018c:	01 ff                	add    edi,edi
        const t = s + r;
  23018e:	8d 82 00 80 00 00    	lea    eax,[rdx+0x8000]
        if (t <= ix) {
  230194:	89 fe                	mov    esi,edi
  230196:	29 c6                	sub    esi,eax
  230198:	7d 04                	jge    23019e <sqrtf+0x1ae>
  23019a:	89 fe                	mov    esi,edi
  23019c:	eb 0c                	jmp    2301aa <sqrtf+0x1ba>
            s = t + r;
  23019e:	81 c2 00 00 01 00    	add    edx,0x10000
            q += r;
  2301a4:	81 c1 00 80 00 00    	add    ecx,0x8000
  2301aa:	01 f6                	add    esi,esi
        const t = s + r;
  2301ac:	8d 82 00 40 00 00    	lea    eax,[rdx+0x4000]
        if (t <= ix) {
  2301b2:	89 f7                	mov    edi,esi
  2301b4:	29 c7                	sub    edi,eax
  2301b6:	7d 04                	jge    2301bc <sqrtf+0x1cc>
  2301b8:	89 f7                	mov    edi,esi
  2301ba:	eb 0c                	jmp    2301c8 <sqrtf+0x1d8>
            s = t + r;
  2301bc:	81 c2 00 80 00 00    	add    edx,0x8000
            q += r;
  2301c2:	81 c1 00 40 00 00    	add    ecx,0x4000
  2301c8:	01 ff                	add    edi,edi
        const t = s + r;
  2301ca:	8d 82 00 20 00 00    	lea    eax,[rdx+0x2000]
        if (t <= ix) {
  2301d0:	89 fe                	mov    esi,edi
  2301d2:	29 c6                	sub    esi,eax
  2301d4:	7d 04                	jge    2301da <sqrtf+0x1ea>
  2301d6:	89 fe                	mov    esi,edi
  2301d8:	eb 0c                	jmp    2301e6 <sqrtf+0x1f6>
            s = t + r;
  2301da:	81 c2 00 40 00 00    	add    edx,0x4000
            q += r;
  2301e0:	81 c1 00 20 00 00    	add    ecx,0x2000
  2301e6:	01 f6                	add    esi,esi
        const t = s + r;
  2301e8:	8d 82 00 10 00 00    	lea    eax,[rdx+0x1000]
        if (t <= ix) {
  2301ee:	89 f7                	mov    edi,esi
  2301f0:	29 c7                	sub    edi,eax
  2301f2:	7d 04                	jge    2301f8 <sqrtf+0x208>
  2301f4:	89 f7                	mov    edi,esi
  2301f6:	eb 0c                	jmp    230204 <sqrtf+0x214>
            s = t + r;
  2301f8:	81 c2 00 20 00 00    	add    edx,0x2000
            q += r;
  2301fe:	81 c1 00 10 00 00    	add    ecx,0x1000
  230204:	01 ff                	add    edi,edi
        const t = s + r;
  230206:	8d 82 00 08 00 00    	lea    eax,[rdx+0x800]
        if (t <= ix) {
  23020c:	89 fe                	mov    esi,edi
  23020e:	29 c6                	sub    esi,eax
  230210:	7d 04                	jge    230216 <sqrtf+0x226>
  230212:	89 fe                	mov    esi,edi
  230214:	eb 0c                	jmp    230222 <sqrtf+0x232>
            s = t + r;
  230216:	81 c2 00 10 00 00    	add    edx,0x1000
            q += r;
  23021c:	81 c1 00 08 00 00    	add    ecx,0x800
  230222:	01 f6                	add    esi,esi
        const t = s + r;
  230224:	8d 82 00 04 00 00    	lea    eax,[rdx+0x400]
        if (t <= ix) {
  23022a:	89 f7                	mov    edi,esi
  23022c:	29 c7                	sub    edi,eax
  23022e:	7d 04                	jge    230234 <sqrtf+0x244>
  230230:	89 f7                	mov    edi,esi
  230232:	eb 0c                	jmp    230240 <sqrtf+0x250>
            s = t + r;
  230234:	81 c2 00 08 00 00    	add    edx,0x800
            q += r;
  23023a:	81 c1 00 04 00 00    	add    ecx,0x400
  230240:	01 ff                	add    edi,edi
        const t = s + r;
  230242:	8d 82 00 02 00 00    	lea    eax,[rdx+0x200]
        if (t <= ix) {
  230248:	89 fe                	mov    esi,edi
  23024a:	29 c6                	sub    esi,eax
  23024c:	7d 04                	jge    230252 <sqrtf+0x262>
  23024e:	89 fe                	mov    esi,edi
  230250:	eb 0c                	jmp    23025e <sqrtf+0x26e>
            s = t + r;
  230252:	81 c2 00 04 00 00    	add    edx,0x400
            q += r;
  230258:	81 c1 00 02 00 00    	add    ecx,0x200
  23025e:	01 f6                	add    esi,esi
        const t = s + r;
  230260:	8d 82 00 01 00 00    	lea    eax,[rdx+0x100]
        if (t <= ix) {
  230266:	89 f7                	mov    edi,esi
  230268:	29 c7                	sub    edi,eax
  23026a:	7d 04                	jge    230270 <sqrtf+0x280>
  23026c:	89 f7                	mov    edi,esi
  23026e:	eb 0c                	jmp    23027c <sqrtf+0x28c>
            s = t + r;
  230270:	81 c2 00 02 00 00    	add    edx,0x200
            q += r;
  230276:	81 c1 00 01 00 00    	add    ecx,0x100
  23027c:	01 ff                	add    edi,edi
        const t = s + r;
  23027e:	89 d0                	mov    eax,edx
  230280:	83 e8 80             	sub    eax,0xffffff80
        if (t <= ix) {
  230283:	89 fe                	mov    esi,edi
  230285:	29 c6                	sub    esi,eax
  230287:	7d 04                	jge    23028d <sqrtf+0x29d>
  230289:	89 fe                	mov    esi,edi
  23028b:	eb 09                	jmp    230296 <sqrtf+0x2a6>
            s = t + r;
  23028d:	81 c2 00 01 00 00    	add    edx,0x100
            q += r;
  230293:	83 e9 80             	sub    ecx,0xffffff80
  230296:	01 f6                	add    esi,esi
        const t = s + r;
  230298:	8d 42 40             	lea    eax,[rdx+0x40]
        if (t <= ix) {
  23029b:	89 f7                	mov    edi,esi
  23029d:	29 c7                	sub    edi,eax
  23029f:	7d 04                	jge    2302a5 <sqrtf+0x2b5>
  2302a1:	89 f7                	mov    edi,esi
  2302a3:	eb 06                	jmp    2302ab <sqrtf+0x2bb>
            s = t + r;
  2302a5:	83 ea 80             	sub    edx,0xffffff80
            q += r;
  2302a8:	83 c1 40             	add    ecx,0x40
  2302ab:	01 ff                	add    edi,edi
        const t = s + r;
  2302ad:	8d 42 20             	lea    eax,[rdx+0x20]
        if (t <= ix) {
  2302b0:	89 fe                	mov    esi,edi
  2302b2:	29 c6                	sub    esi,eax
  2302b4:	7d 04                	jge    2302ba <sqrtf+0x2ca>
  2302b6:	89 fe                	mov    esi,edi
  2302b8:	eb 06                	jmp    2302c0 <sqrtf+0x2d0>
            s = t + r;
  2302ba:	83 c2 40             	add    edx,0x40
            q += r;
  2302bd:	83 c1 20             	add    ecx,0x20
  2302c0:	01 f6                	add    esi,esi
        const t = s + r;
  2302c2:	8d 42 10             	lea    eax,[rdx+0x10]
        if (t <= ix) {
  2302c5:	89 f7                	mov    edi,esi
  2302c7:	29 c7                	sub    edi,eax
  2302c9:	7d 04                	jge    2302cf <sqrtf+0x2df>
  2302cb:	89 f7                	mov    edi,esi
  2302cd:	eb 06                	jmp    2302d5 <sqrtf+0x2e5>
            s = t + r;
  2302cf:	83 c2 20             	add    edx,0x20
            q += r;
  2302d2:	83 c1 10             	add    ecx,0x10
  2302d5:	01 ff                	add    edi,edi
        const t = s + r;
  2302d7:	8d 42 08             	lea    eax,[rdx+0x8]
        if (t <= ix) {
  2302da:	89 fe                	mov    esi,edi
  2302dc:	29 c6                	sub    esi,eax
  2302de:	7d 04                	jge    2302e4 <sqrtf+0x2f4>
  2302e0:	89 fe                	mov    esi,edi
  2302e2:	eb 06                	jmp    2302ea <sqrtf+0x2fa>
            s = t + r;
  2302e4:	83 c2 10             	add    edx,0x10
            q += r;
  2302e7:	83 c1 08             	add    ecx,0x8
  2302ea:	01 f6                	add    esi,esi
        const t = s + r;
  2302ec:	8d 42 04             	lea    eax,[rdx+0x4]
        if (t <= ix) {
  2302ef:	89 f7                	mov    edi,esi
  2302f1:	29 c7                	sub    edi,eax
  2302f3:	7d 04                	jge    2302f9 <sqrtf+0x309>
  2302f5:	89 f7                	mov    edi,esi
  2302f7:	eb 06                	jmp    2302ff <sqrtf+0x30f>
            s = t + r;
  2302f9:	83 c2 08             	add    edx,0x8
            q += r;
  2302fc:	83 c1 04             	add    ecx,0x4
  2302ff:	01 ff                	add    edi,edi
        const t = s + r;
  230301:	8d 42 02             	lea    eax,[rdx+0x2]
        if (t <= ix) {
  230304:	89 fe                	mov    esi,edi
  230306:	29 c6                	sub    esi,eax
  230308:	7d 0a                	jge    230314 <sqrtf+0x324>
  23030a:	89 fe                	mov    esi,edi
  23030c:	01 f6                	add    esi,esi
  23030e:	39 d6                	cmp    esi,edx
  230310:	7f 0e                	jg     230320 <sqrtf+0x330>
  230312:	eb 14                	jmp    230328 <sqrtf+0x338>
            s = t + r;
  230314:	83 c2 04             	add    edx,0x4
            q += r;
  230317:	83 c1 02             	add    ecx,0x2
  23031a:	01 f6                	add    esi,esi
        if (t <= ix) {
  23031c:	39 d6                	cmp    esi,edx
  23031e:	7e 08                	jle    230328 <sqrtf+0x338>
        const t = s + r;
  230320:	83 c2 01             	add    edx,0x1
            ix -= t;
  230323:	29 d6                	sub    esi,edx
            q += r;
  230325:	83 c1 01             	add    ecx,0x1
    m >>= 1; // m = [m / 2]
  230328:	41 83 e0 fe          	and    r8d,0xfffffffe
  23032c:	41 c1 e0 16          	shl    r8d,0x16
        ix += ix;
        r >>= 1;
    }

    // floating add to find rounding direction
    if (ix != 0) {
  230330:	85 f6                	test   esi,esi
  230332:	0f 95 c0             	setne  al
  230335:	20 c8                	and    al,cl
  230337:	0f b6 c0             	movzx  eax,al
  23033a:	01 c8                	add    eax,ecx
                }
            }
        }
    }

    ix = (q >> 1) + 0x3f000000;
  23033c:	d1 f8                	sar    eax,1
    ix += m << 23;
  23033e:	41 8d 04 00          	lea    eax,[r8+rax*1]
  230342:	05 00 00 00 3f       	add    eax,0x3f000000
    return @bitCast(f32, ix);
  230347:	c5 f9 6e c0          	vmovd  xmm0,eax
  23034b:	c3                   	ret    
  23034c:	c5 f9 6e 05 28 94 fd 	vmovd  xmm0,DWORD PTR [rip+0xfffffffffffd9428]        # 20977c <__unnamed_40+0x19>
  230353:	ff 
            return x; // sqrt (+-0) = +-0
  230354:	c3                   	ret    
  230355:	cc                   	int3   
  230356:	cc                   	int3   
  230357:	cc                   	int3   
  230358:	cc                   	int3   
  230359:	cc                   	int3   
  23035a:	cc                   	int3   
  23035b:	cc                   	int3   
  23035c:	cc                   	int3   
  23035d:	cc                   	int3   
  23035e:	cc                   	int3   
  23035f:	cc                   	int3   

0000000000230360 <__udivmoddi4>:
const udivmod = @import("udivmod.zig").udivmod;
const builtin = @import("builtin");

pub extern fn __udivmoddi4(a: u64, b: u64, maybe_rem: ?*u64) u64 {
  230360:	55                   	push   rbp
  230361:	41 57                	push   r15
  230363:	41 56                	push   r14
  230365:	41 54                	push   r12
  230367:	53                   	push   rbx
  230368:	49 89 d0             	mov    r8,rdx
  23036b:	49 89 fa             	mov    r10,rdi
  23036e:	4c 89 d3             	mov    rbx,r10
  230371:	48 c1 eb 20          	shr    rbx,0x20
  230375:	48 89 f1             	mov    rcx,rsi
  230378:	48 c1 e9 20          	shr    rcx,0x20
    const d = @ptrCast(*const [2]SingleInt, &b).*; // TODO issue #421
    var q: [2]SingleInt = undefined;
    var r: [2]SingleInt = undefined;
    var sr: c_uint = undefined;
    // special cases, X is unknown, K != 0
    if (n[high] == 0) {
  23037c:	85 db                	test   ebx,ebx
  23037e:	74 2f                	je     2303af <__udivmoddi4+0x4f>
            rem.* = n[low];
        }
        return 0;
    }
    // n[high] != 0
    if (d[low] == 0) {
  230380:	85 f6                	test   esi,esi
  230382:	74 46                	je     2303ca <__udivmoddi4+0x6a>
  230384:	85 c9                	test   ecx,ecx
        // r.all = a >> sr;
        r[high] = n[high] >> @intCast(Log2SingleInt, sr);
        r[low] = (n[high] << @intCast(Log2SingleInt, SingleInt.bit_count - sr)) | (n[low] >> @intCast(Log2SingleInt, sr));
    } else {
        // d[low] != 0
        if (d[high] == 0) {
  230386:	74 78                	je     230400 <__udivmoddi4+0xa0>
            }
        } else {
            // K X
            // ---
            // K K
            sr = @bitCast(c_uint, c_int(@clz(d[high])) - c_int(@clz(n[high])));
  230388:	f3 0f bd e9          	lzcnt  ebp,ecx
  23038c:	f3 0f bd c3          	lzcnt  eax,ebx
  230390:	29 c5                	sub    ebp,eax
            // 0 <= sr <= SingleInt.bit_count - 1 or sr large
            if (sr > SingleInt.bit_count - 1) {
  230392:	83 fd 20             	cmp    ebp,0x20
  230395:	0f 82 b3 00 00 00    	jb     23044e <__udivmoddi4+0xee>
                if (maybe_rem) |rem| {
  23039b:	4d 85 c0             	test   r8,r8
  23039e:	0f 84 d5 00 00 00    	je     230479 <__udivmoddi4+0x119>
  2303a4:	4d 89 10             	mov    QWORD PTR [r8],r10
  2303a7:	45 31 d2             	xor    r10d,r10d
  2303aa:	e9 06 03 00 00       	jmp    2306b5 <__udivmoddi4+0x355>
        if (d[high] == 0) {
  2303af:	85 c9                	test   ecx,ecx
  2303b1:	74 7d                	je     230430 <__udivmoddi4+0xd0>
  2303b3:	4d 85 c0             	test   r8,r8
        if (maybe_rem) |rem| {
  2303b6:	0f 84 bd 00 00 00    	je     230479 <__udivmoddi4+0x119>
            rem.* = n[low];
  2303bc:	44 89 d0             	mov    eax,r10d
  2303bf:	49 89 00             	mov    QWORD PTR [r8],rax
  2303c2:	45 31 d2             	xor    r10d,r10d
  2303c5:	e9 eb 02 00 00       	jmp    2306b5 <__udivmoddi4+0x355>
  2303ca:	85 c9                	test   ecx,ecx
        if (d[high] == 0) {
  2303cc:	0f 84 93 00 00 00    	je     230465 <__udivmoddi4+0x105>
        if (n[low] == 0) {
  2303d2:	45 85 d2             	test   r10d,r10d
  2303d5:	0f 84 d2 00 00 00    	je     2304ad <__udivmoddi4+0x14d>
        if ((d[high] & (d[high] - 1)) == 0) {
  2303db:	8d 41 ff             	lea    eax,[rcx-0x1]
  2303de:	85 c8                	test   eax,ecx
  2303e0:	0f 84 5d 01 00 00    	je     230543 <__udivmoddi4+0x1e3>
        sr = @bitCast(c_uint, c_int(@clz(d[high])) - c_int(@clz(n[high])));
  2303e6:	f3 0f bd c9          	lzcnt  ecx,ecx
  2303ea:	f3 0f bd c3          	lzcnt  eax,ebx
  2303ee:	29 c1                	sub    ecx,eax
        if (sr > SingleInt.bit_count - 2) {
  2303f0:	83 f9 1f             	cmp    ecx,0x1f
  2303f3:	0f 82 6c 01 00 00    	jb     230565 <__udivmoddi4+0x205>
            if (maybe_rem) |rem| {
  2303f9:	4d 85 c0             	test   r8,r8
  2303fc:	75 a6                	jne    2303a4 <__udivmoddi4+0x44>
  2303fe:	eb 79                	jmp    230479 <__udivmoddi4+0x119>
            if ((d[low] & (d[low] - 1)) == 0) {
  230400:	8d 46 ff             	lea    eax,[rsi-0x1]
  230403:	85 f0                	test   eax,esi
  230405:	0f 84 c2 00 00 00    	je     2304cd <__udivmoddi4+0x16d>
            sr = 1 + SingleInt.bit_count + c_uint(@clz(d[low])) - c_uint(@clz(n[high]));
  23040b:	f3 0f bd ce          	lzcnt  ecx,esi
  23040f:	83 c1 21             	add    ecx,0x21
  230412:	f3 0f bd c3          	lzcnt  eax,ebx
  230416:	29 c1                	sub    ecx,eax
  230418:	31 d2                	xor    edx,edx
            if (sr == SingleInt.bit_count) {
  23041a:	83 f9 20             	cmp    ecx,0x20
  23041d:	0f 85 e7 00 00 00    	jne    23050a <__udivmoddi4+0x1aa>
  230423:	45 31 ff             	xor    r15d,r15d
  230426:	b9 20 00 00 00       	mov    ecx,0x20
  23042b:	e9 7c 01 00 00       	jmp    2305ac <__udivmoddi4+0x24c>
  230430:	4d 85 c0             	test   r8,r8
            if (maybe_rem) |rem| {
  230433:	74 0a                	je     23043f <__udivmoddi4+0xdf>
                rem.* = n[low] % d[low];
  230435:	31 d2                	xor    edx,edx
  230437:	44 89 d0             	mov    eax,r10d
  23043a:	f7 f6                	div    esi
  23043c:	49 89 10             	mov    QWORD PTR [r8],rdx
            return n[low] / d[low];
  23043f:	31 d2                	xor    edx,edx
  230441:	44 89 d0             	mov    eax,r10d
  230444:	f7 f6                	div    esi
  230446:	41 89 c2             	mov    r10d,eax
  230449:	e9 67 02 00 00       	jmp    2306b5 <__udivmoddi4+0x355>
                    rem.* = a;
                }
                return 0;
            }
            sr += 1;
  23044e:	8d 4d 01             	lea    ecx,[rbp+0x1]
  230451:	45 31 ff             	xor    r15d,r15d
            // 1 <= sr <= SingleInt.bit_count
            // q.all = a << (DoubleInt.bit_count - sr);
            // r.all = a >> sr;
            q[low] = 0;
            if (sr == SingleInt.bit_count) {
  230454:	83 f9 20             	cmp    ecx,0x20
  230457:	75 28                	jne    230481 <__udivmoddi4+0x121>
  230459:	31 d2                	xor    edx,edx
  23045b:	b9 20 00 00 00       	mov    ecx,0x20
  230460:	e9 47 01 00 00       	jmp    2305ac <__udivmoddi4+0x24c>
            if (maybe_rem) |rem| {
  230465:	4d 85 c0             	test   r8,r8
  230468:	74 0f                	je     230479 <__udivmoddi4+0x119>
                rem.* = n[high] % d[low];
  23046a:	49 c7 00 00 00 00 00 	mov    QWORD PTR [r8],0x0
  230471:	45 31 d2             	xor    r10d,r10d
  230474:	e9 3c 02 00 00       	jmp    2306b5 <__udivmoddi4+0x355>
  230479:	45 31 d2             	xor    r10d,r10d
  23047c:	e9 34 02 00 00       	jmp    2306b5 <__udivmoddi4+0x355>
                q[high] = n[low];
                r[high] = 0;
                r[low] = n[high];
            } else {
                r[high] = n[high] >> @intCast(Log2SingleInt, sr);
  230481:	41 89 c9             	mov    r9d,ecx
  230484:	41 83 e1 1f          	and    r9d,0x1f
  230488:	c4 e2 33 f7 d3       	shrx   edx,ebx,r9d
  23048d:	b8 1f 00 00 00       	mov    eax,0x1f
                r[low] = (n[high] << @intCast(Log2SingleInt, SingleInt.bit_count - sr)) | (n[low] >> @intCast(Log2SingleInt, sr));
  230492:	29 e8                	sub    eax,ebp
  230494:	83 e0 1f             	and    eax,0x1f
  230497:	c4 e2 79 f7 eb       	shlx   ebp,ebx,eax
  23049c:	c4 c2 33 f7 da       	shrx   ebx,r10d,r9d
  2304a1:	09 eb                	or     ebx,ebp
                q[high] = n[low] << @intCast(Log2SingleInt, SingleInt.bit_count - sr);
  2304a3:	c4 42 79 f7 d2       	shlx   r10d,r10d,eax
  2304a8:	e9 ff 00 00 00       	jmp    2305ac <__udivmoddi4+0x24c>
            if (maybe_rem) |rem| {
  2304ad:	4d 85 c0             	test   r8,r8
  2304b0:	74 0d                	je     2304bf <__udivmoddi4+0x15f>
                r[high] = n[high] % d[high];
  2304b2:	31 d2                	xor    edx,edx
  2304b4:	89 d8                	mov    eax,ebx
  2304b6:	f7 f1                	div    ecx
                rem.* = @ptrCast(*align(@alignOf(SingleInt)) DoubleInt, &r[0]).*; // TODO issue #421
  2304b8:	48 c1 e2 20          	shl    rdx,0x20
  2304bc:	49 89 10             	mov    QWORD PTR [r8],rdx
            return n[high] / d[high];
  2304bf:	31 d2                	xor    edx,edx
  2304c1:	89 d8                	mov    eax,ebx
  2304c3:	f7 f1                	div    ecx
  2304c5:	41 89 c2             	mov    r10d,eax
  2304c8:	e9 e8 01 00 00       	jmp    2306b5 <__udivmoddi4+0x355>
                if (maybe_rem) |rem| {
  2304cd:	4d 85 c0             	test   r8,r8
  2304d0:	74 06                	je     2304d8 <__udivmoddi4+0x178>
                    rem.* = n[low] & (d[low] - 1);
  2304d2:	44 21 d0             	and    eax,r10d
  2304d5:	49 89 00             	mov    QWORD PTR [r8],rax
                if (d[low] == 1) {
  2304d8:	83 fe 01             	cmp    esi,0x1
  2304db:	0f 84 d4 01 00 00    	je     2306b5 <__udivmoddi4+0x355>
                sr = @ctz(d[low]);
  2304e1:	f3 0f bc c6          	tzcnt  eax,esi
                q[high] = n[high] >> @intCast(Log2SingleInt, sr);
  2304e5:	89 c1                	mov    ecx,eax
  2304e7:	83 e1 1f             	and    ecx,0x1f
  2304ea:	c4 e2 73 f7 d3       	shrx   edx,ebx,ecx
                q[low] = (n[high] << @intCast(Log2SingleInt, SingleInt.bit_count - sr)) | (n[low] >> @intCast(Log2SingleInt, sr));
  2304ef:	f7 d8                	neg    eax
  2304f1:	c4 e2 79 f7 c3       	shlx   eax,ebx,eax
  2304f6:	c4 42 73 f7 d2       	shrx   r10d,r10d,ecx
  2304fb:	41 09 c2             	or     r10d,eax
                return @ptrCast(*align(@alignOf(SingleInt)) DoubleInt, &q[0]).*; // TODO issue #421
  2304fe:	48 c1 e2 20          	shl    rdx,0x20
  230502:	49 09 d2             	or     r10,rdx
  230505:	e9 ab 01 00 00       	jmp    2306b5 <__udivmoddi4+0x355>
  23050a:	89 cd                	mov    ebp,ecx
  23050c:	f7 dd                	neg    ebp
  23050e:	83 e5 1f             	and    ebp,0x1f
  230511:	c4 42 51 f7 fa       	shlx   r15d,r10d,ebp
            } else if (sr < SingleInt.bit_count) {
  230516:	83 f9 20             	cmp    ecx,0x20
  230519:	73 7a                	jae    230595 <__udivmoddi4+0x235>
  23051b:	31 d2                	xor    edx,edx
    // q.all = a << (DoubleInt.bit_count - sr);
    // r.all = a >> sr;
    // 1 <= sr <= DoubleInt.bit_count - 1
    var carry: u32 = 0;
    var r_all: DoubleInt = undefined;
    while (sr > 0) : (sr -= 1) {
  23051d:	85 c9                	test   ecx,ecx
  23051f:	0f 84 9c 01 00 00    	je     2306c1 <__udivmoddi4+0x361>
  230525:	89 c8                	mov    eax,ecx
  230527:	83 e0 1f             	and    eax,0x1f
  23052a:	c4 e2 7b f7 d3       	shrx   edx,ebx,eax
  23052f:	c4 e2 51 f7 eb       	shlx   ebp,ebx,ebp
  230534:	c4 c2 7b f7 da       	shrx   ebx,r10d,eax
  230539:	09 eb                	or     ebx,ebp
  23053b:	45 89 fa             	mov    r10d,r15d
  23053e:	45 31 ff             	xor    r15d,r15d
  230541:	eb 69                	jmp    2305ac <__udivmoddi4+0x24c>
            if (maybe_rem) |rem| {
  230543:	4d 85 c0             	test   r8,r8
  230546:	74 0f                	je     230557 <__udivmoddi4+0x1f7>
                r[high] = n[high] & (d[high] - 1);
  230548:	21 d8                	and    eax,ebx
                rem.* = @ptrCast(*align(@alignOf(SingleInt)) DoubleInt, &r[0]).*; // TODO issue #421
  23054a:	48 c1 e0 20          	shl    rax,0x20
  23054e:	44 89 d2             	mov    edx,r10d
  230551:	48 09 c2             	or     rdx,rax
  230554:	49 89 10             	mov    QWORD PTR [r8],rdx
            return n[high] >> @intCast(Log2SingleInt, @ctz(d[high]));
  230557:	f3 0f bc c1          	tzcnt  eax,ecx
  23055b:	c4 62 7b f7 d3       	shrx   r10d,ebx,eax
  230560:	e9 50 01 00 00       	jmp    2306b5 <__udivmoddi4+0x355>
        q[high] = n[low] << @intCast(Log2SingleInt, SingleInt.bit_count - sr);
  230565:	b8 1f 00 00 00       	mov    eax,0x1f
  23056a:	29 c8                	sub    eax,ecx
        sr += 1;
  23056c:	83 c1 01             	add    ecx,0x1
        q[high] = n[low] << @intCast(Log2SingleInt, SingleInt.bit_count - sr);
  23056f:	83 e0 1f             	and    eax,0x1f
        r[high] = n[high] >> @intCast(Log2SingleInt, sr);
  230572:	89 cd                	mov    ebp,ecx
  230574:	83 e5 1f             	and    ebp,0x1f
  230577:	c4 e2 53 f7 d3       	shrx   edx,ebx,ebp
        r[low] = (n[high] << @intCast(Log2SingleInt, SingleInt.bit_count - sr)) | (n[low] >> @intCast(Log2SingleInt, sr));
  23057c:	c4 e2 79 f7 fb       	shlx   edi,ebx,eax
  230581:	c4 c2 53 f7 da       	shrx   ebx,r10d,ebp
        q[high] = n[low] << @intCast(Log2SingleInt, SingleInt.bit_count - sr);
  230586:	c4 c2 79 f7 ea       	shlx   ebp,r10d,eax
        r[low] = (n[high] << @intCast(Log2SingleInt, SingleInt.bit_count - sr)) | (n[low] >> @intCast(Log2SingleInt, sr));
  23058b:	09 fb                	or     ebx,edi
  23058d:	45 31 ff             	xor    r15d,r15d
  230590:	41 89 ea             	mov    r10d,ebp
  230593:	eb 17                	jmp    2305ac <__udivmoddi4+0x24c>
                q[high] = (n[high] << @intCast(Log2SingleInt, DoubleInt.bit_count - sr)) | (n[low] >> @intCast(Log2SingleInt, sr - SingleInt.bit_count));
  230595:	c4 e2 51 f7 eb       	shlx   ebp,ebx,ebp
  23059a:	89 c8                	mov    eax,ecx
  23059c:	83 e0 1f             	and    eax,0x1f
  23059f:	c4 42 7b f7 d2       	shrx   r10d,r10d,eax
  2305a4:	41 09 ea             	or     r10d,ebp
                r[low] = n[high] >> @intCast(Log2SingleInt, sr - SingleInt.bit_count);
  2305a7:	c4 e2 7b f7 db       	shrx   ebx,ebx,eax
  2305ac:	4c 8d 4e ff          	lea    r9,[rsi-0x1]
    while (sr > 0) : (sr -= 1) {
  2305b0:	41 89 cb             	mov    r11d,ecx
  2305b3:	41 83 e3 01          	and    r11d,0x1
  2305b7:	83 f9 01             	cmp    ecx,0x1
  2305ba:	75 10                	jne    2305cc <__udivmoddi4+0x26c>
  2305bc:	31 c9                	xor    ecx,ecx
  2305be:	45 85 db             	test   r11d,r11d
  2305c1:	0f 85 9e 00 00 00    	jne    230665 <__udivmoddi4+0x305>
  2305c7:	e9 c9 00 00 00       	jmp    230695 <__udivmoddi4+0x335>
  2305cc:	45 89 dc             	mov    r12d,r11d
  2305cf:	41 29 cc             	sub    r12d,ecx
  2305d2:	31 c9                	xor    ecx,ecx
  2305d4:	41 be 1e 01 00 00    	mov    r14d,0x11e
  2305da:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
        // r:q = ((r:q)  << 1) | carry
        r[high] = (r[high] << 1) | (r[low] >> (SingleInt.bit_count - 1));
  2305e0:	0f a4 da 01          	shld   edx,ebx,0x1
        r[low] = (r[low] << 1) | (q[high] >> (SingleInt.bit_count - 1));
  2305e4:	44 0f a4 d3 01       	shld   ebx,r10d,0x1
  2305e9:	c4 c2 08 f7 ea       	bextr  ebp,r10d,r14d
        q[high] = (q[high] << 1) | (q[low] >> (SingleInt.bit_count - 1));
  2305ee:	45 0f a4 fa 01       	shld   r10d,r15d,0x1
        q[low] = (q[low] << 1) | carry;
  2305f3:	43 8d 04 3f          	lea    eax,[r15+r15*1]
  2305f7:	09 c8                	or     eax,ecx
        // if (r.all >= b)
        // {
        //     r.all -= b;
        //      carry = 1;
        // }
        r_all = @ptrCast(*align(@alignOf(SingleInt)) DoubleInt, &r[0]).*; // TODO issue #421
  2305f9:	48 c1 e2 20          	shl    rdx,0x20
  2305fd:	48 09 d3             	or     rbx,rdx
        const s: SignedDoubleInt = @intCast(SignedDoubleInt, b -% r_all -% 1) >> (DoubleInt.bit_count - 1);
  230600:	4c 89 c9             	mov    rcx,r9
  230603:	48 29 d9             	sub    rcx,rbx
  230606:	48 c1 f9 3f          	sar    rcx,0x3f
        carry = @intCast(u32, s & 1);
  23060a:	89 ca                	mov    edx,ecx
  23060c:	83 e2 01             	and    edx,0x1
        r_all -= b & @bitCast(DoubleInt, s);
  23060f:	48 21 f1             	and    rcx,rsi
  230612:	48 29 cb             	sub    rbx,rcx
        r[high] = (r[high] << 1) | (r[low] >> (SingleInt.bit_count - 1));
  230615:	48 89 d9             	mov    rcx,rbx
  230618:	48 c1 e9 1f          	shr    rcx,0x1f
  23061c:	83 e1 fe             	and    ecx,0xfffffffe
  23061f:	89 df                	mov    edi,ebx
  230621:	c1 ef 1f             	shr    edi,0x1f
  230624:	09 cf                	or     edi,ecx
        q[high] = (q[high] << 1) | (q[low] >> (SingleInt.bit_count - 1));
  230626:	c4 c2 08 f7 cf       	bextr  ecx,r15d,r14d
        r[low] = (r[low] << 1) | (q[high] >> (SingleInt.bit_count - 1));
  23062b:	8d 5c 5d 00          	lea    ebx,[rbp+rbx*2+0x0]
        q[high] = (q[high] << 1) | (q[low] >> (SingleInt.bit_count - 1));
  23062f:	46 8d 14 51          	lea    r10d,[rcx+r10*2]
        q[low] = (q[low] << 1) | carry;
  230633:	44 8d 3c 42          	lea    r15d,[rdx+rax*2]
        r_all = @ptrCast(*align(@alignOf(SingleInt)) DoubleInt, &r[0]).*; // TODO issue #421
  230637:	48 c1 e7 20          	shl    rdi,0x20
  23063b:	48 09 fb             	or     rbx,rdi
        const s: SignedDoubleInt = @intCast(SignedDoubleInt, b -% r_all -% 1) >> (DoubleInt.bit_count - 1);
  23063e:	4c 89 c8             	mov    rax,r9
  230641:	48 29 d8             	sub    rax,rbx
  230644:	48 c1 f8 3f          	sar    rax,0x3f
        carry = @intCast(u32, s & 1);
  230648:	89 c1                	mov    ecx,eax
  23064a:	83 e1 01             	and    ecx,0x1
        r_all -= b & @bitCast(DoubleInt, s);
  23064d:	48 21 f0             	and    rax,rsi
  230650:	48 29 c3             	sub    rbx,rax
        r = @ptrCast(*[2]SingleInt, &r_all).*; // TODO issue #421
  230653:	48 89 da             	mov    rdx,rbx
  230656:	48 c1 ea 20          	shr    rdx,0x20
    while (sr > 0) : (sr -= 1) {
  23065a:	41 83 c4 02          	add    r12d,0x2
  23065e:	75 80                	jne    2305e0 <__udivmoddi4+0x280>
  230660:	45 85 db             	test   r11d,r11d
  230663:	74 30                	je     230695 <__udivmoddi4+0x335>
        r[high] = (r[high] << 1) | (r[low] >> (SingleInt.bit_count - 1));
  230665:	0f a4 da 01          	shld   edx,ebx,0x1
        r[low] = (r[low] << 1) | (q[high] >> (SingleInt.bit_count - 1));
  230669:	44 0f a4 d3 01       	shld   ebx,r10d,0x1
        r_all = @ptrCast(*align(@alignOf(SingleInt)) DoubleInt, &r[0]).*; // TODO issue #421
  23066e:	48 c1 e2 20          	shl    rdx,0x20
  230672:	48 09 d3             	or     rbx,rdx
        const s: SignedDoubleInt = @intCast(SignedDoubleInt, b -% r_all -% 1) >> (DoubleInt.bit_count - 1);
  230675:	49 29 d9             	sub    r9,rbx
  230678:	49 c1 f9 3f          	sar    r9,0x3f
        r_all -= b & @bitCast(DoubleInt, s);
  23067c:	4c 21 ce             	and    rsi,r9
  23067f:	48 29 f3             	sub    rbx,rsi
        carry = @intCast(u32, s & 1);
  230682:	41 83 e1 01          	and    r9d,0x1
        q[high] = (q[high] << 1) | (q[low] >> (SingleInt.bit_count - 1));
  230686:	45 0f a4 fa 01       	shld   r10d,r15d,0x1
        q[low] = (q[low] << 1) | carry;
  23068b:	42 8d 04 79          	lea    eax,[rcx+r15*2]
  23068f:	41 89 c7             	mov    r15d,eax
  230692:	44 89 c9             	mov    ecx,r9d
    }
    const q_all = ((@ptrCast(*align(@alignOf(SingleInt)) DoubleInt, &q[0]).*) << 1) | carry; // TODO issue #421
  230695:	89 ca                	mov    edx,ecx
  230697:	44 89 f9             	mov    ecx,r15d
  23069a:	45 89 d7             	mov    r15d,r10d
  23069d:	49 c1 e7 20          	shl    r15,0x20
  2306a1:	49 09 cf             	or     r15,rcx
  2306a4:	4d 01 ff             	add    r15,r15
  2306a7:	4d 89 fa             	mov    r10,r15
  2306aa:	49 09 d2             	or     r10,rdx
    if (maybe_rem) |rem| {
  2306ad:	4d 85 c0             	test   r8,r8
  2306b0:	74 03                	je     2306b5 <__udivmoddi4+0x355>
        rem.* = r_all;
  2306b2:	49 89 18             	mov    QWORD PTR [r8],rbx
    @setRuntimeSafety(builtin.is_test);
    return udivmod(u64, a, b, maybe_rem);
  2306b5:	4c 89 d0             	mov    rax,r10
  2306b8:	5b                   	pop    rbx
  2306b9:	41 5c                	pop    r12
  2306bb:	41 5e                	pop    r14
  2306bd:	41 5f                	pop    r15
  2306bf:	5d                   	pop    rbp
  2306c0:	c3                   	ret    
  2306c1:	31 c9                	xor    ecx,ecx
  2306c3:	eb d8                	jmp    23069d <__udivmoddi4+0x33d>
  2306c5:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  2306cc:	00 00 00 00 

00000000002306d0 <__cmptf2>:
const is_test = builtin.is_test;

pub extern fn __letf2(a: f128, b: f128) c_int {
    @setRuntimeSafety(is_test);

    const aInt = @bitCast(rep_t, a);
  2306d0:	66 0f 7f 44 24 e8    	movdqa XMMWORD PTR [rsp-0x18],xmm0
  2306d6:	4c 8b 5c 24 e8       	mov    r11,QWORD PTR [rsp-0x18]
  2306db:	4c 8b 44 24 f0       	mov    r8,QWORD PTR [rsp-0x10]
    const bInt = @bitCast(rep_t, b);
  2306e0:	66 0f 7f 4c 24 d8    	movdqa XMMWORD PTR [rsp-0x28],xmm1

    const aAbs: rep_t = aInt & absMask;
  2306e6:	40 b6 3f             	mov    sil,0x3f
  2306e9:	c4 c2 c8 f5 c8       	bzhi   rcx,r8,rsi
    const bAbs: rep_t = bInt & absMask;

    // If either a or b is NaN, they are unordered.
    if (aAbs > infRep or bAbs > infRep) return LE_UNORDERED;
  2306ee:	4c 89 d8             	mov    rax,r11
  2306f1:	48 f7 d8             	neg    rax
  2306f4:	49 ba 00 00 00 00 00 	movabs r10,0x7fff000000000000
  2306fb:	00 ff 7f 
  2306fe:	4c 89 d0             	mov    rax,r10
  230701:	48 19 c8             	sbb    rax,rcx
  230704:	b8 01 00 00 00       	mov    eax,0x1
  230709:	72 68                	jb     230773 <__cmptf2+0xa3>
  23070b:	48 8b 7c 24 d8       	mov    rdi,QWORD PTR [rsp-0x28]
  230710:	4c 8b 4c 24 e0       	mov    r9,QWORD PTR [rsp-0x20]
  230715:	c4 c2 c8 f5 d1       	bzhi   rdx,r9,rsi
  23071a:	48 83 ff 01          	cmp    rdi,0x1
  23071e:	48 89 d6             	mov    rsi,rdx
  230721:	4c 19 d6             	sbb    rsi,r10
  230724:	73 4d                	jae    230773 <__cmptf2+0xa3>

    // If a and b are both zeros, they are equal.
    if ((aAbs | bAbs) == 0) return LE_EQUAL;
  230726:	48 89 f8             	mov    rax,rdi
  230729:	4c 09 d8             	or     rax,r11
  23072c:	48 09 ca             	or     rdx,rcx
  23072f:	48 09 c2             	or     rdx,rax
  230732:	74 40                	je     230774 <__cmptf2+0xa4>
  230734:	b8 ff ff ff ff       	mov    eax,0xffffffff

    // If at least one of a and b is positive, we get the same result comparing
    // a and b as signed integers as we would with a floating-point compare.
    return if ((aInt & bInt) >= 0) if (aInt < bInt)
  230739:	49 39 fb             	cmp    r11,rdi
  23073c:	4c 89 c1             	mov    rcx,r8
  23073f:	4c 19 c9             	sbb    rcx,r9
  230742:	72 2f                	jb     230773 <__cmptf2+0xa3>
        LE_LESS
    else if (aInt == bInt)
  230744:	c4 e1 f9 6e c7       	vmovq  xmm0,rdi
  230749:	c4 c1 f9 6e c9       	vmovq  xmm1,r9
  23074e:	c5 f9 6c c1          	vpunpcklqdq xmm0,xmm0,xmm1
  230752:	c4 c1 f9 6e cb       	vmovq  xmm1,r11
  230757:	c4 c1 f9 6e d0       	vmovq  xmm2,r8
  23075c:	c5 f1 6c ca          	vpunpcklqdq xmm1,xmm1,xmm2
  230760:	c5 f1 74 c0          	vpcmpeqb xmm0,xmm1,xmm0
  230764:	c5 f9 d7 c8          	vpmovmskb ecx,xmm0
  230768:	31 c0                	xor    eax,eax
  23076a:	81 f9 ff ff 00 00    	cmp    ecx,0xffff
  230770:	0f 95 c0             	setne  al
    if (aAbs > infRep or bAbs > infRep) return LE_UNORDERED;
  230773:	c3                   	ret    
  230774:	31 c0                	xor    eax,eax
  230776:	c3                   	ret    
  230777:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  23077e:	00 00 

0000000000230780 <__gttf2>:
const GE_UNORDERED = c_int(-1); // Note: different from LE_UNORDERED

pub extern fn __getf2(a: f128, b: f128) c_int {
    @setRuntimeSafety(is_test);

    const aInt = @bitCast(srep_t, a);
  230780:	53                   	push   rbx
  230781:	0f 29 44 24 f0       	movaps XMMWORD PTR [rsp-0x10],xmm0
  230786:	4c 8b 54 24 f0       	mov    r10,QWORD PTR [rsp-0x10]
  23078b:	4c 8b 44 24 f8       	mov    r8,QWORD PTR [rsp-0x8]
    const bInt = @bitCast(srep_t, b);
  230790:	0f 29 4c 24 e0       	movaps XMMWORD PTR [rsp-0x20],xmm1
    const aAbs = @bitCast(rep_t, aInt) & absMask;
  230795:	41 b1 3f             	mov    r9b,0x3f
  230798:	c4 c2 b0 f5 c8       	bzhi   rcx,r8,r9
    const bAbs = @bitCast(rep_t, bInt) & absMask;

    if (aAbs > infRep or bAbs > infRep) return GE_UNORDERED;
  23079d:	4c 89 d0             	mov    rax,r10
  2307a0:	48 f7 d8             	neg    rax
  2307a3:	48 bb 00 00 00 00 00 	movabs rbx,0x7fff000000000000
  2307aa:	00 ff 7f 
  2307ad:	48 89 d8             	mov    rax,rbx
  2307b0:	48 19 c8             	sbb    rax,rcx
  2307b3:	b8 ff ff ff ff       	mov    eax,0xffffffff
  2307b8:	72 39                	jb     2307f3 <__gttf2+0x73>
  2307ba:	48 8b 7c 24 e0       	mov    rdi,QWORD PTR [rsp-0x20]
  2307bf:	4c 8b 5c 24 e8       	mov    r11,QWORD PTR [rsp-0x18]
  2307c4:	c4 c2 b0 f5 f3       	bzhi   rsi,r11,r9
  2307c9:	48 83 ff 01          	cmp    rdi,0x1
  2307cd:	48 89 f2             	mov    rdx,rsi
  2307d0:	48 19 da             	sbb    rdx,rbx
  2307d3:	73 1e                	jae    2307f3 <__gttf2+0x73>
    if ((aAbs | bAbs) == 0) return GE_EQUAL;
  2307d5:	48 89 fa             	mov    rdx,rdi
  2307d8:	4c 09 d2             	or     rdx,r10
  2307db:	48 09 ce             	or     rsi,rcx
  2307de:	48 09 d6             	or     rsi,rdx
  2307e1:	74 12                	je     2307f5 <__gttf2+0x75>
    return if ((aInt & bInt) >= 0) if (aInt < bInt)
  2307e3:	4d 85 c3             	test   r11,r8
  2307e6:	78 11                	js     2307f9 <__gttf2+0x79>
  2307e8:	49 39 fa             	cmp    r10,rdi
  2307eb:	4c 89 c1             	mov    rcx,r8
  2307ee:	4c 19 d9             	sbb    rcx,r11
  2307f1:	7d 11                	jge    230804 <__gttf2+0x84>
    if (aAbs > infRep or bAbs > infRep) return GE_UNORDERED;
  2307f3:	5b                   	pop    rbx
  2307f4:	c3                   	ret    
  2307f5:	31 c0                	xor    eax,eax
  2307f7:	5b                   	pop    rbx
  2307f8:	c3                   	ret    
        GE_LESS
    else if (aInt == bInt)
        GE_EQUAL
    else
        GE_GREATER else if (aInt > bInt)
  2307f9:	4c 39 d7             	cmp    rdi,r10
  2307fc:	4c 89 d9             	mov    rcx,r11
  2307ff:	4c 19 c1             	sbb    rcx,r8
  230802:	7c ef                	jl     2307f3 <__gttf2+0x73>
  230804:	c4 e1 f9 6e c7       	vmovq  xmm0,rdi
  230809:	c4 c1 f9 6e cb       	vmovq  xmm1,r11
  23080e:	c5 f9 6c c1          	vpunpcklqdq xmm0,xmm0,xmm1
  230812:	c4 c1 f9 6e ca       	vmovq  xmm1,r10
  230817:	c4 c1 f9 6e d0       	vmovq  xmm2,r8
  23081c:	c5 f1 6c ca          	vpunpcklqdq xmm1,xmm1,xmm2
  230820:	c5 f1 74 c0          	vpcmpeqb xmm0,xmm1,xmm0
  230824:	c5 f9 d7 c8          	vpmovmskb ecx,xmm0
  230828:	31 c0                	xor    eax,eax
  23082a:	81 f9 ff ff 00 00    	cmp    ecx,0xffff
  230830:	0f 95 c0             	setne  al
    if (aAbs > infRep or bAbs > infRep) return GE_UNORDERED;
  230833:	5b                   	pop    rbx
  230834:	c3                   	ret    
  230835:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  23083c:	00 00 00 00 

0000000000230840 <__extendhfsf2>:

    const dstMinNormal: dst_rep_t = dst_rep_t(1) << dstSigBits;

    // Break a into a sign and representation of the absolute value
    const aRep: src_rep_t = @bitCast(src_rep_t, a);
    const aAbs: src_rep_t = aRep & srcAbsMask;
  230840:	89 f9                	mov    ecx,edi
  230842:	81 e1 ff 7f 00 00    	and    ecx,0x7fff
    const sign: src_rep_t = aRep & srcSignMask;
  230848:	89 f8                	mov    eax,edi
  23084a:	25 00 80 00 00       	and    eax,0x8000
    var absResult: dst_rep_t = undefined;

    if (aAbs -% srcMinNormal < srcInfinity - srcMinNormal) {
  23084f:	89 ca                	mov    edx,ecx
  230851:	81 c2 00 fc ff ff    	add    edx,0xfffffc00
  230857:	0f b7 d2             	movzx  edx,dx
  23085a:	81 fa ff 77 00 00    	cmp    edx,0x77ff
  230860:	77 16                	ja     230878 <__extendhfsf2+0x38>
        // a is a normal number.
        // Extend to the destination type by shifting the significand and
        // exponent into the proper position and rebiasing the exponent.
        absResult = dst_rep_t(aAbs) << (dstSigBits - srcSigBits);
  230862:	0f b7 c9             	movzx  ecx,cx
  230865:	c1 e1 0d             	shl    ecx,0xd
        absResult += (dstExpBias - srcExpBias) << dstSigBits;
  230868:	81 c1 00 00 00 38    	add    ecx,0x38000000
        // a is zero.
        absResult = 0;
    }

    // Apply the signbit to (dst_t)abs(a).
    const result: dst_rep_t align(@alignOf(dst_t)) = absResult | dst_rep_t(sign) << (dstBits - srcBits);
  23086e:	c1 e0 10             	shl    eax,0x10
  230871:	09 c8                	or     eax,ecx
    return @bitCast(dst_t, result);
  230873:	c5 f9 6e c0          	vmovd  xmm0,eax
    return extendXfYf2(f32, f16, @bitCast(f16, a));
  230877:	c3                   	ret    
    } else if (aAbs >= srcInfinity) {
  230878:	0f b7 d1             	movzx  edx,cx
  23087b:	81 fa 00 7c 00 00    	cmp    edx,0x7c00
  230881:	72 16                	jb     230899 <__extendhfsf2+0x59>
        absResult |= dst_rep_t(aAbs & srcNaNCode) << (dstSigBits - srcSigBits);
  230883:	0f b7 cf             	movzx  ecx,di
  230886:	c1 e1 0d             	shl    ecx,0xd
  230889:	81 c9 00 00 80 7f    	or     ecx,0x7f800000
    const result: dst_rep_t align(@alignOf(dst_t)) = absResult | dst_rep_t(sign) << (dstBits - srcBits);
  23088f:	c1 e0 10             	shl    eax,0x10
  230892:	09 c8                	or     eax,ecx
    return @bitCast(dst_t, result);
  230894:	c5 f9 6e c0          	vmovd  xmm0,eax
    return extendXfYf2(f32, f16, @bitCast(f16, a));
  230898:	c3                   	ret    
    } else if (aAbs != 0) {
  230899:	66 85 c9             	test   cx,cx
  23089c:	74 2f                	je     2308cd <__extendhfsf2+0x8d>
        const scale: u32 = @clz(aAbs) - @clz(src_rep_t(srcMinNormal));
  23089e:	66 f3 0f bd c9       	lzcnt  cx,cx
  2308a3:	8d 71 1b             	lea    esi,[rcx+0x1b]
  2308a6:	83 e6 1f             	and    esi,0x1f
        absResult = dst_rep_t(aAbs) << @intCast(DstShift, dstSigBits - srcSigBits + scale);
  2308a9:	83 c1 08             	add    ecx,0x8
  2308ac:	c4 e2 71 f7 d2       	shlx   edx,edx,ecx
        absResult ^= dstMinNormal;
  2308b1:	81 f2 00 00 80 00    	xor    edx,0x800000
        absResult |= @intCast(dst_rep_t, resultExponent) << dstSigBits;
  2308b7:	c1 e6 17             	shl    esi,0x17
  2308ba:	b9 00 00 80 38       	mov    ecx,0x38800000
  2308bf:	29 f1                	sub    ecx,esi
  2308c1:	09 d1                	or     ecx,edx
    const result: dst_rep_t align(@alignOf(dst_t)) = absResult | dst_rep_t(sign) << (dstBits - srcBits);
  2308c3:	c1 e0 10             	shl    eax,0x10
  2308c6:	09 c8                	or     eax,ecx
    return @bitCast(dst_t, result);
  2308c8:	c5 f9 6e c0          	vmovd  xmm0,eax
    return extendXfYf2(f32, f16, @bitCast(f16, a));
  2308cc:	c3                   	ret    
  2308cd:	31 c9                	xor    ecx,ecx
    const result: dst_rep_t align(@alignOf(dst_t)) = absResult | dst_rep_t(sign) << (dstBits - srcBits);
  2308cf:	c1 e0 10             	shl    eax,0x10
  2308d2:	09 c8                	or     eax,ecx
    return @bitCast(dst_t, result);
  2308d4:	c5 f9 6e c0          	vmovd  xmm0,eax
    return extendXfYf2(f32, f16, @bitCast(f16, a));
  2308d8:	c3                   	ret    
  2308d9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

00000000002308e0 <__truncsfhf2>:

    const dstQNaN = 1 << (dstSigBits - 1);
    const dstNaNCode = dstQNaN - 1;

    // Break a into a sign and representation of the absolute value
    const aRep: src_rep_t = @bitCast(src_rep_t, a);
  2308e0:	c5 f9 7e c2          	vmovd  edx,xmm0
    const aAbs: src_rep_t = aRep & srcAbsMask;
  2308e4:	89 d6                	mov    esi,edx
  2308e6:	81 e6 ff ff ff 7f    	and    esi,0x7fffffff
    const sign: src_rep_t = aRep & srcSignMask;
    var absResult: dst_rep_t = undefined;

    if (aAbs -% underflow < aAbs -% overflow) {
  2308ec:	8d 86 00 00 80 c7    	lea    eax,[rsi-0x38800000]
  2308f2:	8d 8e 00 00 80 b8    	lea    ecx,[rsi-0x47800000]
  2308f8:	39 c8                	cmp    eax,ecx
  2308fa:	73 1f                	jae    23091b <__truncsfhf2+0x3b>
        // The exponent of a is within the range of normal numbers in the
        // destination format.  We can convert by simply right-shifting with
        // rounding and adjusting the exponent.
        absResult = @truncate(dst_rep_t, aAbs >> (srcSigBits - dstSigBits));
  2308fc:	89 d0                	mov    eax,edx
  2308fe:	c1 e8 0d             	shr    eax,0xd
        absResult -%= dst_rep_t(srcExpBias - dstExpBias) << dstSigBits;

        const roundBits: src_rep_t = aAbs & roundMask;
  230901:	89 d1                	mov    ecx,edx
  230903:	81 e1 ff 1f 00 00    	and    ecx,0x1fff
        if (roundBits > halfway) {
  230909:	81 f9 01 10 00 00    	cmp    ecx,0x1001
  23090f:	72 23                	jb     230934 <__truncsfhf2+0x54>
            // Round to nearest
            absResult += 1;
  230911:	05 01 40 00 00       	add    eax,0x4001
  230916:	e9 83 00 00 00       	jmp    23099e <__truncsfhf2+0xbe>
        } else if (roundBits == halfway) {
            // Ties to even
            absResult += absResult & 1;
        }
    } else if (aAbs > srcInfinity) {
  23091b:	81 fe 01 00 80 7f    	cmp    esi,0x7f800001
  230921:	72 29                	jb     23094c <__truncsfhf2+0x6c>
        // a is NaN.
        // Conjure the result by beginning with infinity, setting the qNaN
        // bit and inserting the (truncated) trailing NaN field.
        absResult = @intCast(dst_rep_t, dstInfExp) << dstSigBits;
        absResult |= dstQNaN;
        absResult |= @intCast(dst_rep_t, ((aAbs & srcNaNCode) >> (srcSigBits - dstSigBits)) & dstNaNCode);
  230923:	b8 0d 09 00 00       	mov    eax,0x90d
  230928:	c4 e2 78 f7 c2       	bextr  eax,edx,eax
  23092d:	0d 00 7e 00 00       	or     eax,0x7e00
  230932:	eb 6a                	jmp    23099e <__truncsfhf2+0xbe>
  230934:	05 00 40 00 00       	add    eax,0x4000
        } else if (roundBits == halfway) {
  230939:	81 f9 00 10 00 00    	cmp    ecx,0x1000
  23093f:	75 5d                	jne    23099e <__truncsfhf2+0xbe>
  230941:	89 c1                	mov    ecx,eax
  230943:	83 e1 01             	and    ecx,0x1
  230946:	01 c1                	add    ecx,eax
  230948:	89 c8                	mov    eax,ecx
  23094a:	eb 52                	jmp    23099e <__truncsfhf2+0xbe>
  23094c:	66 b8 00 7c          	mov    ax,0x7c00
    } else if (aAbs >= overflow) {
  230950:	81 fe ff ff 7f 47    	cmp    esi,0x477fffff
  230956:	77 46                	ja     23099e <__truncsfhf2+0xbe>
        absResult = @intCast(dst_rep_t, dstInfExp) << dstSigBits;
    } else {
        // a underflows on conversion to the destination type or is an exact
        // zero.  The result may be a denormal or zero.  Extract the exponent
        // to get the shift amount for the denormalization.
        const aExp = @intCast(u32, aAbs >> srcSigBits);
  230958:	c1 ee 17             	shr    esi,0x17
        const shift = @intCast(u32, srcExpBias - dstExpBias - aExp + 1);
  23095b:	b9 70 00 00 00       	mov    ecx,0x70
  230960:	29 f1                	sub    ecx,esi

        const significand: src_rep_t = (aRep & srcSignificandMask) | srcMinNormal;

        // Right shift by the denormalization amount with sticky.
        if (shift > srcSigBits) {
  230962:	83 f9 16             	cmp    ecx,0x16
  230965:	76 04                	jbe    23096b <__truncsfhf2+0x8b>
  230967:	31 c0                	xor    eax,eax
  230969:	eb 33                	jmp    23099e <__truncsfhf2+0xbe>
  23096b:	89 d6                	mov    esi,edx
  23096d:	81 e6 ff ff 7f 00    	and    esi,0x7fffff
  230973:	81 ce 00 00 80 00    	or     esi,0x800000
        const shift = @intCast(u32, srcExpBias - dstExpBias - aExp + 1);
  230979:	83 c1 01             	add    ecx,0x1
            absResult = 0;
        } else {
            const sticky: src_rep_t = significand << @intCast(SrcShift, srcBits - shift);
            const denormalizedSignificand: src_rep_t = significand >> @intCast(SrcShift, shift) | sticky;
  23097c:	d3 ce                	ror    esi,cl
            absResult = @intCast(dst_rep_t, denormalizedSignificand >> (srcSigBits - dstSigBits));
  23097e:	89 f0                	mov    eax,esi
  230980:	c1 e8 0d             	shr    eax,0xd
            const roundBits: src_rep_t = denormalizedSignificand & roundMask;
  230983:	81 e6 ff 1f 00 00    	and    esi,0x1fff
            if (roundBits > halfway) {
  230989:	81 fe 01 10 00 00    	cmp    esi,0x1001
  23098f:	72 05                	jb     230996 <__truncsfhf2+0xb6>
                // Round to nearest
                absResult += 1;
  230991:	83 c0 01             	add    eax,0x1
  230994:	eb 08                	jmp    23099e <__truncsfhf2+0xbe>
            } else if (roundBits == halfway) {
  230996:	81 fe 00 10 00 00    	cmp    esi,0x1000
  23099c:	74 a3                	je     230941 <__truncsfhf2+0x61>
                absResult += absResult & 1;
            }
        }
    }

    const result: dst_rep_t align(@alignOf(dst_t)) = absResult | @truncate(dst_rep_t, sign >> @intCast(SrcShift, srcBits - dstBits));
  23099e:	c1 ea 10             	shr    edx,0x10
  2309a1:	81 e2 00 80 00 00    	and    edx,0x8000
  2309a7:	09 d0                	or     eax,edx
    return @bitCast(u16, truncXfYf2(f16, f32, a));
  2309a9:	c3                   	ret    
  2309aa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

00000000002309b0 <__unordtf2>:
}

pub extern fn __unordtf2(a: f128, b: f128) c_int {
    @setRuntimeSafety(is_test);

    const aAbs = @bitCast(rep_t, a) & absMask;
  2309b0:	0f 29 44 24 e8       	movaps XMMWORD PTR [rsp-0x18],xmm0
  2309b5:	b0 3f                	mov    al,0x3f
  2309b7:	c4 e2 f8 f5 4c 24 f0 	bzhi   rcx,QWORD PTR [rsp-0x10],rax
    const bAbs = @bitCast(rep_t, b) & absMask;
  2309be:	0f 29 4c 24 d8       	movaps XMMWORD PTR [rsp-0x28],xmm1
  2309c3:	c4 e2 f8 f5 44 24 e0 	bzhi   rax,QWORD PTR [rsp-0x20],rax
    return @boolToInt(aAbs > infRep or bAbs > infRep);
  2309ca:	31 d2                	xor    edx,edx
  2309cc:	48 3b 54 24 e8       	cmp    rdx,QWORD PTR [rsp-0x18]
  2309d1:	48 be 00 00 00 00 00 	movabs rsi,0x7fff000000000000
  2309d8:	00 ff 7f 
  2309db:	48 89 f7             	mov    rdi,rsi
  2309de:	48 19 cf             	sbb    rdi,rcx
  2309e1:	0f 92 c1             	setb   cl
  2309e4:	48 3b 54 24 d8       	cmp    rdx,QWORD PTR [rsp-0x28]
  2309e9:	48 19 c6             	sbb    rsi,rax
  2309ec:	0f 92 c0             	setb   al
  2309ef:	08 c8                	or     al,cl
  2309f1:	0f b6 c0             	movzx  eax,al
  2309f4:	c3                   	ret    
  2309f5:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  2309fc:	00 00 00 00 

0000000000230a00 <__floattitf>:
const LDBL_MANT_DIG = 113;

pub extern fn __floattitf(arg: i128) f128 {
    @setRuntimeSafety(is_test);

    if (arg == 0)
  230a00:	48 89 f8             	mov    rax,rdi
  230a03:	48 09 f0             	or     rax,rsi
  230a06:	0f 84 ba 00 00 00    	je     230ac6 <__floattitf+0xc6>
        return 0.0;

    var ai = arg;
    const N: u32 = 128;
    const si = ai >> @intCast(u7, (N - 1));
  230a0c:	41 57                	push   r15
  230a0e:	41 56                	push   r14
  230a10:	53                   	push   rbx
  230a11:	48 89 f0             	mov    rax,rsi
  230a14:	48 c1 f8 3f          	sar    rax,0x3f
    ai = ((ai ^ si) -% si);
  230a18:	48 89 c2             	mov    rdx,rax
  230a1b:	48 31 f2             	xor    rdx,rsi
  230a1e:	48 31 c7             	xor    rdi,rax
  230a21:	48 29 c7             	sub    rdi,rax
  230a24:	48 19 c2             	sbb    rdx,rax
    var a = @bitCast(u128, ai);

    const sd = @bitCast(i32, N - @clz(a)); // number of significant digits
  230a27:	f3 48 0f bd c2       	lzcnt  rax,rdx
  230a2c:	f3 48 0f bd cf       	lzcnt  rcx,rdi
  230a31:	83 c1 40             	add    ecx,0x40
  230a34:	48 85 d2             	test   rdx,rdx
  230a37:	0f 45 c8             	cmovne ecx,eax
  230a3a:	41 b9 80 00 00 00    	mov    r9d,0x80
  230a40:	41 29 c9             	sub    r9d,ecx
    var e: i32 = sd - 1; // exponent
  230a43:	41 ba 7f 00 00 00    	mov    r10d,0x7f
  230a49:	41 29 ca             	sub    r10d,ecx
    if (sd > LDBL_MANT_DIG) {
  230a4c:	41 83 f9 72          	cmp    r9d,0x72
  230a50:	7c 7c                	jl     230ace <__floattitf+0xce>
        //                                                12345678901234567890123456
        //  1 = msb 1 bit
        //  P = bit LDBL_MANT_DIG-1 bits to the right of 1
        //  Q = bit LDBL_MANT_DIG bits to the right of 1
        //  R = "or" of all bits to the right of Q
        switch (sd) {
  230a52:	0f 84 99 00 00 00    	je     230af1 <__floattitf+0xf1>
  230a58:	41 83 f9 73          	cmp    r9d,0x73
  230a5c:	0f 84 97 00 00 00    	je     230af9 <__floattitf+0xf9>
            LDBL_MANT_DIG + 1 => {
                a <<= 1;
            },
            LDBL_MANT_DIG + 2 => {},
            else => {
                const shift1_amt = @intCast(i32, sd - (LDBL_MANT_DIG + 2));
  230a62:	41 8d 49 0d          	lea    ecx,[r9+0xd]
                const shift1_amt_u7 = @intCast(u7, shift1_amt);

                const shift2_amt = @intCast(i32, N + (LDBL_MANT_DIG + 2)) - sd;
  230a66:	41 b8 73 00 00 00    	mov    r8d,0x73
                const shift2_amt_u7 = @intCast(u7, shift2_amt);

                a = (a >> shift1_amt_u7) | @boolToInt((a & (@intCast(u128, @maxValue(u128)) >> shift2_amt_u7)) != 0);
  230a6c:	83 e1 7f             	and    ecx,0x7f
  230a6f:	49 89 ff             	mov    r15,rdi
  230a72:	49 0f ad d7          	shrd   r15,rdx,cl
                const shift2_amt = @intCast(i32, N + (LDBL_MANT_DIG + 2)) - sd;
  230a76:	45 29 c8             	sub    r8d,r9d
                a = (a >> shift1_amt_u7) | @boolToInt((a & (@intCast(u128, @maxValue(u128)) >> shift2_amt_u7)) != 0);
  230a79:	c4 62 f3 f7 da       	shrx   r11,rdx,rcx
  230a7e:	45 31 f6             	xor    r14d,r14d
  230a81:	f6 c1 40             	test   cl,0x40
  230a84:	4d 0f 45 fb          	cmovne r15,r11
  230a88:	4d 0f 45 de          	cmovne r11,r14
  230a8c:	41 83 e0 7f          	and    r8d,0x7f
  230a90:	48 c7 c3 ff ff ff ff 	mov    rbx,0xffffffffffffffff
  230a97:	c4 e2 bb f7 c3       	shrx   rax,rbx,r8
  230a9c:	44 89 c1             	mov    ecx,r8d
  230a9f:	48 0f ad db          	shrd   rbx,rbx,cl
  230aa3:	41 f6 c0 40          	test   r8b,0x40
  230aa7:	48 0f 45 d8          	cmovne rbx,rax
  230aab:	49 0f 45 c6          	cmovne rax,r14
  230aaf:	48 21 fb             	and    rbx,rdi
  230ab2:	48 21 d0             	and    rax,rdx
  230ab5:	31 ff                	xor    edi,edi
  230ab7:	48 09 d8             	or     rax,rbx
  230aba:	40 0f 95 c7          	setne  dil
  230abe:	4c 09 ff             	or     rdi,r15
  230ac1:	4c 89 da             	mov    rdx,r11
  230ac4:	eb 33                	jmp    230af9 <__floattitf+0xf9>
        return 0.0;
  230ac6:	0f 28 05 43 f8 fc ff 	movaps xmm0,XMMWORD PTR [rip+0xfffffffffffcf843]        # 200310 <__unnamed_35>
  230acd:	c3                   	ret    
            a >>= 1;
            e += 1;
        }
        // a is now rounded to LDBL_MANT_DIG bits
    } else {
        a <<= @intCast(u7, LDBL_MANT_DIG - sd);
  230ace:	b9 71 00 00 00       	mov    ecx,0x71
  230ad3:	44 29 c9             	sub    ecx,r9d
  230ad6:	83 e1 7f             	and    ecx,0x7f
  230ad9:	48 0f a5 fa          	shld   rdx,rdi,cl
  230add:	c4 e2 f1 f7 ff       	shlx   rdi,rdi,rcx
  230ae2:	31 c0                	xor    eax,eax
  230ae4:	f6 c1 40             	test   cl,0x40
  230ae7:	48 0f 45 d7          	cmovne rdx,rdi
  230aeb:	48 0f 44 c7          	cmove  rax,rdi
  230aef:	eb 3b                	jmp    230b2c <__floattitf+0x12c>
                a <<= 1;
  230af1:	48 0f a4 fa 01       	shld   rdx,rdi,0x1
  230af6:	48 01 ff             	add    rdi,rdi
        a |= @boolToInt((a & 4) != 0); // Or P into R
  230af9:	b8 02 01 00 00       	mov    eax,0x102
  230afe:	c4 e2 78 f7 c7       	bextr  eax,edi,eax
  230b03:	48 09 f8             	or     rax,rdi
        a += 1; // round - this step may add a significant bit
  230b06:	48 83 c0 01          	add    rax,0x1
  230b0a:	48 83 d2 00          	adc    rdx,0x0
        if ((a & (u128(1) << LDBL_MANT_DIG)) != 0) {
  230b0e:	48 0f ba e2 33       	bt     rdx,0x33
  230b13:	72 0b                	jb     230b20 <__floattitf+0x120>
  230b15:	48 0f ac d0 02       	shrd   rax,rdx,0x2
  230b1a:	48 c1 ea 02          	shr    rdx,0x2
  230b1e:	eb 0c                	jmp    230b2c <__floattitf+0x12c>
            a >>= 1;
  230b20:	48 0f ac d0 03       	shrd   rax,rdx,0x3
  230b25:	48 c1 ea 03          	shr    rdx,0x3
  230b29:	45 89 ca             	mov    r10d,r9d
        // a is now rounded to LDBL_MANT_DIG bits
    }

    const s = @bitCast(u128, arg) >> (128 - 64);
    const high: u128 = (@intCast(u64, s) & 0x8000000000000000) | // sign
  230b2c:	48 b9 00 00 00 00 00 	movabs rcx,0x8000000000000000
  230b33:	00 00 80 
  230b36:	48 21 ce             	and    rsi,rcx
        (@intCast(u64, (e + 16383)) << 48) | // exponent
  230b39:	41 81 c2 ff 3f 00 00 	add    r10d,0x3fff
  230b40:	49 c1 e2 30          	shl    r10,0x30
    const high: u128 = (@intCast(u64, s) & 0x8000000000000000) | // sign
  230b44:	49 09 f2             	or     r10,rsi
        (@truncate(u64, a >> 64) & 0x0000ffffffffffff); // mantissa-high
  230b47:	b1 30                	mov    cl,0x30
  230b49:	c4 e2 f0 f5 ca       	bzhi   rcx,rdx,rcx
    const low = @truncate(u64, a); // mantissa-low

    return @bitCast(f128, low | (high << 64));
  230b4e:	48 89 44 24 f0       	mov    QWORD PTR [rsp-0x10],rax
        (@intCast(u64, (e + 16383)) << 48) | // exponent
  230b53:	4c 09 d1             	or     rcx,r10
    return @bitCast(f128, low | (high << 64));
  230b56:	48 89 4c 24 f8       	mov    QWORD PTR [rsp-0x8],rcx
  230b5b:	0f 28 44 24 f0       	movaps xmm0,XMMWORD PTR [rsp-0x10]
  230b60:	5b                   	pop    rbx
  230b61:	41 5e                	pop    r14
  230b63:	41 5f                	pop    r15
  230b65:	c3                   	ret    
  230b66:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  230b6d:	00 00 00 

0000000000230b70 <__floattidf>:
const DBL_MANT_DIG = 53;

pub extern fn __floattidf(arg: i128) f64 {
    @setRuntimeSafety(is_test);

    if (arg == 0)
  230b70:	48 89 f8             	mov    rax,rdi
  230b73:	48 09 f0             	or     rax,rsi
  230b76:	0f 84 b8 00 00 00    	je     230c34 <__floattidf+0xc4>
        return 0.0;

    var ai = arg;
    const N: u32 = 128;
    const si = ai >> @intCast(u7, (N - 1));
  230b7c:	41 57                	push   r15
  230b7e:	41 56                	push   r14
  230b80:	53                   	push   rbx
  230b81:	48 89 f0             	mov    rax,rsi
  230b84:	48 c1 f8 3f          	sar    rax,0x3f
    ai = ((ai ^ si) -% si);
  230b88:	48 89 c2             	mov    rdx,rax
  230b8b:	48 31 f2             	xor    rdx,rsi
  230b8e:	48 31 c7             	xor    rdi,rax
  230b91:	48 29 c7             	sub    rdi,rax
  230b94:	48 19 c2             	sbb    rdx,rax
    var a = @bitCast(u128, ai);

    const sd = @bitCast(i32, N - @clz(a)); // number of significant digits
  230b97:	f3 48 0f bd c2       	lzcnt  rax,rdx
  230b9c:	f3 48 0f bd cf       	lzcnt  rcx,rdi
  230ba1:	83 c1 40             	add    ecx,0x40
  230ba4:	48 85 d2             	test   rdx,rdx
  230ba7:	0f 45 c8             	cmovne ecx,eax
  230baa:	41 b9 80 00 00 00    	mov    r9d,0x80
  230bb0:	41 29 c9             	sub    r9d,ecx
    var e: i32 = sd - 1; // exponent
  230bb3:	b8 7f 00 00 00       	mov    eax,0x7f
  230bb8:	29 c8                	sub    eax,ecx
    if (sd > DBL_MANT_DIG) {
  230bba:	41 83 f9 36          	cmp    r9d,0x36
  230bbe:	7c 79                	jl     230c39 <__floattidf+0xc9>
        //                                                12345678901234567890123456
        //  1 = msb 1 bit
        //  P = bit DBL_MANT_DIG-1 bits to the right of 1
        //  Q = bit DBL_MANT_DIG bits to the right of 1
        //  R = "or" of all bits to the right of Q
        switch (sd) {
  230bc0:	0f 84 9b 00 00 00    	je     230c61 <__floattidf+0xf1>
  230bc6:	41 83 f9 37          	cmp    r9d,0x37
  230bca:	0f 84 99 00 00 00    	je     230c69 <__floattidf+0xf9>
            DBL_MANT_DIG + 1 => {
                a <<= 1;
            },
            DBL_MANT_DIG + 2 => {},
            else => {
                const shift1_amt = @intCast(i32, sd - (DBL_MANT_DIG + 2));
  230bd0:	41 8d 49 49          	lea    ecx,[r9+0x49]
                const shift1_amt_u7 = @intCast(u7, shift1_amt);

                const shift2_amt = @intCast(i32, N + (DBL_MANT_DIG + 2)) - sd;
  230bd4:	41 b8 37 00 00 00    	mov    r8d,0x37
                const shift2_amt_u7 = @intCast(u7, shift2_amt);

                a = (a >> shift1_amt_u7) | @boolToInt((a & (@intCast(u128, @maxValue(u128)) >> shift2_amt_u7)) != 0);
  230bda:	83 e1 7f             	and    ecx,0x7f
  230bdd:	49 89 fa             	mov    r10,rdi
  230be0:	49 0f ad d2          	shrd   r10,rdx,cl
                const shift2_amt = @intCast(i32, N + (DBL_MANT_DIG + 2)) - sd;
  230be4:	45 29 c8             	sub    r8d,r9d
                a = (a >> shift1_amt_u7) | @boolToInt((a & (@intCast(u128, @maxValue(u128)) >> shift2_amt_u7)) != 0);
  230be7:	c4 62 f3 f7 da       	shrx   r11,rdx,rcx
  230bec:	45 31 f6             	xor    r14d,r14d
  230bef:	f6 c1 40             	test   cl,0x40
  230bf2:	4d 0f 45 d3          	cmovne r10,r11
  230bf6:	4d 0f 45 de          	cmovne r11,r14
  230bfa:	41 83 e0 7f          	and    r8d,0x7f
  230bfe:	48 c7 c3 ff ff ff ff 	mov    rbx,0xffffffffffffffff
  230c05:	c4 62 bb f7 fb       	shrx   r15,rbx,r8
  230c0a:	44 89 c1             	mov    ecx,r8d
  230c0d:	48 0f ad db          	shrd   rbx,rbx,cl
  230c11:	41 f6 c0 40          	test   r8b,0x40
  230c15:	49 0f 45 df          	cmovne rbx,r15
  230c19:	4d 0f 45 fe          	cmovne r15,r14
  230c1d:	48 21 fb             	and    rbx,rdi
  230c20:	49 21 d7             	and    r15,rdx
  230c23:	31 ff                	xor    edi,edi
  230c25:	49 09 df             	or     r15,rbx
  230c28:	40 0f 95 c7          	setne  dil
  230c2c:	4c 09 d7             	or     rdi,r10
  230c2f:	4c 89 da             	mov    rdx,r11
  230c32:	eb 35                	jmp    230c69 <__floattidf+0xf9>
        return 0.0;
  230c34:	c5 f8 57 c0          	vxorps xmm0,xmm0,xmm0
  230c38:	c3                   	ret    
            a >>= 1;
            e += 1;
        }
        // a is now rounded to DBL_MANT_DIG bits
    } else {
        a <<= @intCast(u7, DBL_MANT_DIG - sd);
  230c39:	b9 35 00 00 00       	mov    ecx,0x35
  230c3e:	44 29 c9             	sub    ecx,r9d
  230c41:	83 e1 7f             	and    ecx,0x7f
  230c44:	48 0f a5 fa          	shld   rdx,rdi,cl
  230c48:	c4 e2 f1 f7 df       	shlx   rbx,rdi,rcx
  230c4d:	31 ff                	xor    edi,edi
  230c4f:	f6 c1 40             	test   cl,0x40
  230c52:	48 0f 45 d3          	cmovne rdx,rbx
  230c56:	48 0f 44 fb          	cmove  rdi,rbx
    if (sd > DBL_MANT_DIG) {
  230c5a:	48 0f a4 fa 20       	shld   rdx,rdi,0x20
  230c5f:	eb 40                	jmp    230ca1 <__floattidf+0x131>
                a <<= 1;
  230c61:	48 0f a4 fa 01       	shld   rdx,rdi,0x1
  230c66:	48 01 ff             	add    rdi,rdi
        a |= @boolToInt((a & 4) != 0); // Or P into R
  230c69:	b9 02 01 00 00       	mov    ecx,0x102
  230c6e:	c4 e2 70 f7 cf       	bextr  ecx,edi,ecx
  230c73:	48 09 f9             	or     rcx,rdi
        a += 1; // round - this step may add a significant bit
  230c76:	48 83 c1 01          	add    rcx,0x1
  230c7a:	48 83 d2 00          	adc    rdx,0x0
            a >>= 1;
  230c7e:	48 89 d7             	mov    rdi,rdx
        if ((a & (u128(1) << DBL_MANT_DIG)) != 0) {
  230c81:	48 0f ba e1 37       	bt     rcx,0x37
  230c86:	72 0c                	jb     230c94 <__floattidf+0x124>
  230c88:	48 0f a4 cf 3e       	shld   rdi,rcx,0x3e
  230c8d:	48 0f a4 ca 1e       	shld   rdx,rcx,0x1e
  230c92:	eb 0d                	jmp    230ca1 <__floattidf+0x131>
            a >>= 1;
  230c94:	48 0f a4 cf 3d       	shld   rdi,rcx,0x3d
        if ((a & (u128(1) << DBL_MANT_DIG)) != 0) {
  230c99:	48 0f a4 ca 1d       	shld   rdx,rcx,0x1d
  230c9e:	44 89 c8             	mov    eax,r9d
        // a is now rounded to DBL_MANT_DIG bits
    }

    const s = @bitCast(u128, arg) >> (128 - 32);
  230ca1:	48 c1 ee 20          	shr    rsi,0x20
    const high: u64 = (@intCast(u64, s) & 0x80000000) | // sign
  230ca5:	81 e6 00 00 00 80    	and    esi,0x80000000
        (@intCast(u32, (e + 1023)) << 20) | // exponent
  230cab:	c1 e0 14             	shl    eax,0x14
  230cae:	05 00 00 f0 3f       	add    eax,0x3ff00000
    const high: u64 = (@intCast(u64, s) & 0x80000000) | // sign
  230cb3:	09 f0                	or     eax,esi
        (@truncate(u32, a >> 32) & 0x000fffff); // mantissa-high
  230cb5:	81 e2 ff ff 0f 00    	and    edx,0xfffff
        (@intCast(u32, (e + 1023)) << 20) | // exponent
  230cbb:	09 c2                	or     edx,eax
    const low: u64 = @truncate(u32, a); // mantissa-low
  230cbd:	89 f8                	mov    eax,edi

    return @bitCast(f64, low | (high << 32));
  230cbf:	48 c1 e2 20          	shl    rdx,0x20
  230cc3:	48 09 c2             	or     rdx,rax
  230cc6:	c4 e1 f9 6e c2       	vmovq  xmm0,rdx
  230ccb:	5b                   	pop    rbx
  230ccc:	41 5e                	pop    r14
  230cce:	41 5f                	pop    r15
  230cd0:	c3                   	ret    
  230cd1:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  230cd8:	0f 1f 84 00 00 00 00 
  230cdf:	00 

0000000000230ce0 <__floattisf>:
const FLT_MANT_DIG = 24;

pub extern fn __floattisf(arg: i128) f32 {
    @setRuntimeSafety(is_test);

    if (arg == 0)
  230ce0:	48 89 f8             	mov    rax,rdi
  230ce3:	48 09 f0             	or     rax,rsi
  230ce6:	0f 84 b2 00 00 00    	je     230d9e <__floattisf+0xbe>
        return 0.0;

    var ai = arg;
    const N: u32 = 128;
    const si = ai >> @intCast(u7, (N - 1));
  230cec:	48 89 f1             	mov    rcx,rsi
  230cef:	48 c1 f9 3f          	sar    rcx,0x3f
    ai = ((ai ^ si) -% si);
  230cf3:	48 89 c8             	mov    rax,rcx
  230cf6:	48 31 f0             	xor    rax,rsi
  230cf9:	48 31 cf             	xor    rdi,rcx
  230cfc:	48 29 cf             	sub    rdi,rcx
  230cff:	48 19 c8             	sbb    rax,rcx
    var a = @bitCast(u128, ai);

    const sd = @bitCast(i32, N - @clz(a)); // number of significant digits
  230d02:	f3 48 0f bd d0       	lzcnt  rdx,rax
  230d07:	f3 48 0f bd cf       	lzcnt  rcx,rdi
  230d0c:	83 c1 40             	add    ecx,0x40
  230d0f:	48 85 c0             	test   rax,rax
  230d12:	0f 45 ca             	cmovne ecx,edx
  230d15:	41 b9 80 00 00 00    	mov    r9d,0x80
  230d1b:	41 29 c9             	sub    r9d,ecx
    var e: i32 = sd - 1; // exponent
  230d1e:	ba 7f 00 00 00       	mov    edx,0x7f
  230d23:	29 ca                	sub    edx,ecx

    if (sd > FLT_MANT_DIG) {
  230d25:	41 83 f9 19          	cmp    r9d,0x19
  230d29:	7c 78                	jl     230da3 <__floattisf+0xc3>
        //                                                12345678901234567890123456
        //  1 = msb 1 bit
        //  P = bit FLT_MANT_DIG-1 bits to the right of 1
        //  Q = bit FLT_MANT_DIG bits to the right of 1
        //  R = "or" of all bits to the right of Q
        switch (sd) {
  230d2b:	0f 84 8d 00 00 00    	je     230dbe <__floattisf+0xde>
  230d31:	41 83 f9 1a          	cmp    r9d,0x1a
  230d35:	0f 84 86 00 00 00    	je     230dc1 <__floattisf+0xe1>
            FLT_MANT_DIG + 1 => {
                a <<= 1;
            },
            FLT_MANT_DIG + 2 => {},
            else => {
                const shift1_amt = @intCast(i32, sd - (FLT_MANT_DIG + 2));
  230d3b:	41 56                	push   r14
  230d3d:	53                   	push   rbx
  230d3e:	41 8d 49 66          	lea    ecx,[r9+0x66]
                const shift1_amt_u7 = @intCast(u7, shift1_amt);

                const shift2_amt = @intCast(i32, N + (FLT_MANT_DIG + 2)) - sd;
                const shift2_amt_u7 = @intCast(u7, shift2_amt);

                a = (a >> shift1_amt_u7) | @boolToInt((a & (@intCast(u128, @maxValue(u128)) >> shift2_amt_u7)) != 0);
  230d42:	83 e1 7f             	and    ecx,0x7f
  230d45:	49 89 fa             	mov    r10,rdi
  230d48:	49 0f ad c2          	shrd   r10,rax,cl
                const shift2_amt = @intCast(i32, N + (FLT_MANT_DIG + 2)) - sd;
  230d4c:	41 b8 1a 00 00 00    	mov    r8d,0x1a
  230d52:	45 29 c8             	sub    r8d,r9d
                a = (a >> shift1_amt_u7) | @boolToInt((a & (@intCast(u128, @maxValue(u128)) >> shift2_amt_u7)) != 0);
  230d55:	c4 62 f3 f7 d8       	shrx   r11,rax,rcx
  230d5a:	45 31 f6             	xor    r14d,r14d
  230d5d:	f6 c1 40             	test   cl,0x40
  230d60:	4d 0f 44 da          	cmove  r11,r10
  230d64:	41 83 e0 7f          	and    r8d,0x7f
  230d68:	48 c7 c3 ff ff ff ff 	mov    rbx,0xffffffffffffffff
  230d6f:	c4 62 bb f7 d3       	shrx   r10,rbx,r8
  230d74:	44 89 c1             	mov    ecx,r8d
  230d77:	48 0f ad db          	shrd   rbx,rbx,cl
  230d7b:	41 f6 c0 40          	test   r8b,0x40
  230d7f:	49 0f 45 da          	cmovne rbx,r10
  230d83:	4d 0f 44 f2          	cmove  r14,r10
  230d87:	48 21 fb             	and    rbx,rdi
  230d8a:	49 21 c6             	and    r14,rax
  230d8d:	31 ff                	xor    edi,edi
  230d8f:	49 09 de             	or     r14,rbx
  230d92:	40 0f 95 c7          	setne  dil
  230d96:	4c 09 df             	or     rdi,r11
        switch (sd) {
  230d99:	5b                   	pop    rbx
  230d9a:	41 5e                	pop    r14
  230d9c:	eb 23                	jmp    230dc1 <__floattisf+0xe1>
        return 0.0;
  230d9e:	c5 f8 57 c0          	vxorps xmm0,xmm0,xmm0
  230da2:	c3                   	ret    
            a >>= 1;
            e += 1;
        }
        // a is now rounded to FLT_MANT_DIG bits
    } else {
        a <<= @intCast(u7, FLT_MANT_DIG - sd);
  230da3:	b9 18 00 00 00       	mov    ecx,0x18
  230da8:	44 29 c9             	sub    ecx,r9d
  230dab:	83 e1 7f             	and    ecx,0x7f
  230dae:	c4 e2 f1 f7 ff       	shlx   rdi,rdi,rcx
  230db3:	31 c0                	xor    eax,eax
  230db5:	f6 c1 40             	test   cl,0x40
  230db8:	48 0f 44 c7          	cmove  rax,rdi
  230dbc:	eb 28                	jmp    230de6 <__floattisf+0x106>
                a <<= 1;
  230dbe:	48 01 ff             	add    rdi,rdi
        a |= @boolToInt((a & 4) != 0); // Or P into R
  230dc1:	b8 02 01 00 00       	mov    eax,0x102
  230dc6:	c4 e2 78 f7 c7       	bextr  eax,edi,eax
  230dcb:	48 09 f8             	or     rax,rdi
        a += 1; // round - this step may add a significant bit
  230dce:	48 83 c0 01          	add    rax,0x1
        if ((a & (u128(1) << FLT_MANT_DIG)) != 0) {
  230dd2:	a9 00 00 00 04       	test   eax,0x4000000
  230dd7:	75 06                	jne    230ddf <__floattisf+0xff>
  230dd9:	48 c1 e8 02          	shr    rax,0x2
  230ddd:	eb 07                	jmp    230de6 <__floattisf+0x106>
            a >>= 1;
  230ddf:	48 c1 e8 03          	shr    rax,0x3
  230de3:	44 89 ca             	mov    edx,r9d
        // a is now rounded to FLT_MANT_DIG bits
    }

    const s = @bitCast(u128, arg) >> (128 - 32);
  230de6:	48 c1 ee 20          	shr    rsi,0x20
    const r = (@intCast(u32, s) & 0x80000000) | // sign
  230dea:	81 e6 00 00 00 80    	and    esi,0x80000000
        (@intCast(u32, (e + 127)) << 23) | // exponent
  230df0:	c1 e2 17             	shl    edx,0x17
  230df3:	81 c2 00 00 80 3f    	add    edx,0x3f800000
    const r = (@intCast(u32, s) & 0x80000000) | // sign
  230df9:	09 f2                	or     edx,esi
        (@truncate(u32, a) & 0x007fffff); // mantissa-high
  230dfb:	25 ff ff 7f 00       	and    eax,0x7fffff
        (@intCast(u32, (e + 127)) << 23) | // exponent
  230e00:	09 d0                	or     eax,edx

    return @bitCast(f32, r);
  230e02:	c5 f9 6e c0          	vmovd  xmm0,eax
  230e06:	c3                   	ret    
  230e07:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  230e0e:	00 00 

0000000000230e10 <__floatunditf>:
const std = @import("std");

pub extern fn __floatunditf(a: u128) f128 {
    @setRuntimeSafety(is_test);

    if (a == 0) {
  230e10:	48 89 f8             	mov    rax,rdi
  230e13:	48 09 f0             	or     rax,rsi
  230e16:	74 0f                	je     230e27 <__floatunditf+0x17>
    const mantissa_bits = std.math.floatMantissaBits(f128);
    const exponent_bits = std.math.floatExponentBits(f128);
    const exponent_bias = (1 << (exponent_bits - 1)) - 1;
    const implicit_bit = 1 << mantissa_bits;

    const exp = (u128.bit_count - 1) - @clz(a);
  230e18:	48 85 f6             	test   rsi,rsi
  230e1b:	75 12                	jne    230e2f <__floatunditf+0x1f>
  230e1d:	f3 48 0f bd c7       	lzcnt  rax,rdi
  230e22:	83 c0 40             	add    eax,0x40
  230e25:	eb 0d                	jmp    230e34 <__floatunditf+0x24>
        return 0;
  230e27:	0f 28 05 e2 f4 fc ff 	movaps xmm0,XMMWORD PTR [rip+0xfffffffffffcf4e2]        # 200310 <__unnamed_35>
  230e2e:	c3                   	ret    
  230e2f:	f3 48 0f bd c6       	lzcnt  rax,rsi
  230e34:	b2 7f                	mov    dl,0x7f
    const exp = (u128.bit_count - 1) - @clz(a);
  230e36:	28 c2                	sub    dl,al
  230e38:	b1 70                	mov    cl,0x70
    const shift = mantissa_bits - @intCast(u7, exp);
  230e3a:	28 d1                	sub    cl,dl

    var result: u128 align(16) = (a << shift) ^ implicit_bit;
  230e3c:	48 0f a5 fe          	shld   rsi,rdi,cl
  230e40:	c4 e2 f1 f7 c7       	shlx   rax,rdi,rcx
  230e45:	31 ff                	xor    edi,edi
  230e47:	f6 c1 40             	test   cl,0x40
  230e4a:	48 0f 45 f0          	cmovne rsi,rax
  230e4e:	48 0f 44 f8          	cmove  rdi,rax
  230e52:	48 b8 00 00 00 00 00 	movabs rax,0x1000000000000
  230e59:	00 01 00 
  230e5c:	48 31 f0             	xor    rax,rsi
    result += (@intCast(u128, exp) + exponent_bias) << mantissa_bits;
  230e5f:	0f b6 ca             	movzx  ecx,dl
  230e62:	48 c1 e1 30          	shl    rcx,0x30
  230e66:	48 01 c1             	add    rcx,rax
  230e69:	48 89 7c 24 e8       	mov    QWORD PTR [rsp-0x18],rdi
  230e6e:	48 b8 00 00 00 00 00 	movabs rax,0x3fff000000000000
  230e75:	00 ff 3f 
  230e78:	48 01 c8             	add    rax,rcx
  230e7b:	48 89 44 24 f0       	mov    QWORD PTR [rsp-0x10],rax
  230e80:	0f 28 44 24 e8       	movaps xmm0,XMMWORD PTR [rsp-0x18]

    return @bitCast(f128, result);
  230e85:	c3                   	ret    
  230e86:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  230e8d:	00 00 00 

0000000000230e90 <__floatunsitf>:
const std = @import("std");

pub extern fn __floatunsitf(a: u64) f128 {
    @setRuntimeSafety(is_test);

    if (a == 0) {
  230e90:	48 85 ff             	test   rdi,rdi
  230e93:	74 5c                	je     230ef1 <__floatunsitf+0x61>
    const mantissa_bits = std.math.floatMantissaBits(f128);
    const exponent_bits = std.math.floatExponentBits(f128);
    const exponent_bias = (1 << (exponent_bits - 1)) - 1;
    const implicit_bit = 1 << mantissa_bits;

    const exp = (u64.bit_count - 1) - @clz(a);
  230e95:	f3 48 0f bd c7       	lzcnt  rax,rdi
  230e9a:	b2 3f                	mov    dl,0x3f
  230e9c:	28 c2                	sub    dl,al
  230e9e:	b1 70                	mov    cl,0x70
    const shift = mantissa_bits - @intCast(u7, exp);
  230ea0:	28 d1                	sub    cl,dl
  230ea2:	31 c0                	xor    eax,eax

    // TODO(#1148): @bitCast alignment error
    var result align(16) = (@intCast(u128, a) << shift) ^ implicit_bit;
  230ea4:	31 f6                	xor    esi,esi
  230ea6:	48 0f a5 fe          	shld   rsi,rdi,cl
  230eaa:	c4 e2 f1 f7 ff       	shlx   rdi,rdi,rcx
  230eaf:	f6 c1 40             	test   cl,0x40
  230eb2:	48 0f 45 f7          	cmovne rsi,rdi
  230eb6:	48 0f 45 f8          	cmovne rdi,rax
  230eba:	48 b8 00 00 00 00 00 	movabs rax,0x1000000000000
  230ec1:	00 01 00 
  230ec4:	48 31 f0             	xor    rax,rsi
    result += (@intCast(u128, exp) + exponent_bias) << mantissa_bits;
  230ec7:	0f b6 ca             	movzx  ecx,dl
  230eca:	83 e1 7f             	and    ecx,0x7f
  230ecd:	48 c1 e1 30          	shl    rcx,0x30
  230ed1:	48 01 c1             	add    rcx,rax
  230ed4:	48 89 7c 24 e8       	mov    QWORD PTR [rsp-0x18],rdi
  230ed9:	48 b8 00 00 00 00 00 	movabs rax,0x3fff000000000000
  230ee0:	00 ff 3f 
  230ee3:	48 01 c8             	add    rax,rcx
  230ee6:	48 89 44 24 f0       	mov    QWORD PTR [rsp-0x10],rax
  230eeb:	0f 28 44 24 e8       	movaps xmm0,XMMWORD PTR [rsp-0x18]

    return @bitCast(f128, result);
  230ef0:	c3                   	ret    
        return 0;
  230ef1:	0f 28 05 18 f4 fc ff 	movaps xmm0,XMMWORD PTR [rip+0xfffffffffffcf418]        # 200310 <__unnamed_35>
  230ef8:	c3                   	ret    
  230ef9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

0000000000230f00 <__floatuntitf>:
const LDBL_MANT_DIG = 113;

pub extern fn __floatuntitf(arg: u128) f128 {
    @setRuntimeSafety(is_test);

    if (arg == 0)
  230f00:	48 89 f8             	mov    rax,rdi
  230f03:	48 09 f0             	or     rax,rsi
  230f06:	0f 84 a0 00 00 00    	je     230fac <__floatuntitf+0xac>
        return 0.0;

    var a = arg;
    const N: u32 = @sizeOf(u128) * 8;
    const sd = @bitCast(i32, N - @clz(a)); // number of significant digits
  230f0c:	41 56                	push   r14
  230f0e:	53                   	push   rbx
  230f0f:	f3 48 0f bd c6       	lzcnt  rax,rsi
  230f14:	f3 48 0f bd cf       	lzcnt  rcx,rdi
  230f19:	83 c1 40             	add    ecx,0x40
  230f1c:	48 85 f6             	test   rsi,rsi
  230f1f:	0f 45 c8             	cmovne ecx,eax
  230f22:	41 b9 80 00 00 00    	mov    r9d,0x80
  230f28:	41 29 c9             	sub    r9d,ecx
    var e: i32 = sd - 1; // exponent
  230f2b:	ba 7f 00 00 00       	mov    edx,0x7f
  230f30:	29 ca                	sub    edx,ecx
    if (sd > LDBL_MANT_DIG) {
  230f32:	41 83 f9 72          	cmp    r9d,0x72
  230f36:	7c 7c                	jl     230fb4 <__floatuntitf+0xb4>
        //                                                12345678901234567890123456
        //  1 = msb 1 bit
        //  P = bit LDBL_MANT_DIG-1 bits to the right of 1
        //  Q = bit LDBL_MANT_DIG bits to the right of 1
        //  R = "or" of all bits to the right of Q
        switch (sd) {
  230f38:	0f 84 99 00 00 00    	je     230fd7 <__floatuntitf+0xd7>
  230f3e:	41 83 f9 73          	cmp    r9d,0x73
  230f42:	0f 84 97 00 00 00    	je     230fdf <__floatuntitf+0xdf>
            LDBL_MANT_DIG + 1 => {
                a <<= 1;
            },
            LDBL_MANT_DIG + 2 => {},
            else => {
                const shift_amt = @bitCast(i32, N + (LDBL_MANT_DIG + 2)) - sd;
  230f48:	41 b8 73 00 00 00    	mov    r8d,0x73
                const shift_amt_u7 = @intCast(u7, shift_amt);
                a = (a >> @intCast(u7, sd - (LDBL_MANT_DIG + 2))) |
  230f4e:	41 8d 49 0d          	lea    ecx,[r9+0xd]
  230f52:	83 e1 7f             	and    ecx,0x7f
  230f55:	49 89 fe             	mov    r14,rdi
  230f58:	49 0f ad f6          	shrd   r14,rsi,cl
                const shift_amt = @bitCast(i32, N + (LDBL_MANT_DIG + 2)) - sd;
  230f5c:	45 29 c8             	sub    r8d,r9d
                a = (a >> @intCast(u7, sd - (LDBL_MANT_DIG + 2))) |
  230f5f:	c4 62 f3 f7 d6       	shrx   r10,rsi,rcx
  230f64:	45 31 db             	xor    r11d,r11d
  230f67:	f6 c1 40             	test   cl,0x40
  230f6a:	4d 0f 45 f2          	cmovne r14,r10
  230f6e:	4d 0f 45 d3          	cmovne r10,r11
                    @boolToInt((a & (u128(@maxValue(u128)) >> shift_amt_u7)) != 0);
  230f72:	41 83 e0 7f          	and    r8d,0x7f
  230f76:	48 c7 c3 ff ff ff ff 	mov    rbx,0xffffffffffffffff
  230f7d:	c4 e2 bb f7 c3       	shrx   rax,rbx,r8
  230f82:	44 89 c1             	mov    ecx,r8d
  230f85:	48 0f ad db          	shrd   rbx,rbx,cl
  230f89:	41 f6 c0 40          	test   r8b,0x40
  230f8d:	48 0f 45 d8          	cmovne rbx,rax
  230f91:	49 0f 45 c3          	cmovne rax,r11
  230f95:	48 21 fb             	and    rbx,rdi
  230f98:	48 21 f0             	and    rax,rsi
  230f9b:	31 ff                	xor    edi,edi
  230f9d:	48 09 d8             	or     rax,rbx
  230fa0:	40 0f 95 c7          	setne  dil
                a = (a >> @intCast(u7, sd - (LDBL_MANT_DIG + 2))) |
  230fa4:	4c 09 f7             	or     rdi,r14
  230fa7:	4c 89 d6             	mov    rsi,r10
  230faa:	eb 33                	jmp    230fdf <__floatuntitf+0xdf>
        return 0.0;
  230fac:	0f 28 05 5d f3 fc ff 	movaps xmm0,XMMWORD PTR [rip+0xfffffffffffcf35d]        # 200310 <__unnamed_35>
  230fb3:	c3                   	ret    
            a >>= 1;
            e += 1;
        }
        // a is now rounded to LDBL_MANT_DIG bits
    } else {
        a <<= @intCast(u7, LDBL_MANT_DIG - sd);
  230fb4:	b9 71 00 00 00       	mov    ecx,0x71
  230fb9:	44 29 c9             	sub    ecx,r9d
  230fbc:	83 e1 7f             	and    ecx,0x7f
  230fbf:	48 0f a5 fe          	shld   rsi,rdi,cl
  230fc3:	c4 e2 f1 f7 ff       	shlx   rdi,rdi,rcx
  230fc8:	31 c0                	xor    eax,eax
  230fca:	f6 c1 40             	test   cl,0x40
  230fcd:	48 0f 45 f7          	cmovne rsi,rdi
  230fd1:	48 0f 44 c7          	cmove  rax,rdi
  230fd5:	eb 3b                	jmp    231012 <__floatuntitf+0x112>
                a <<= 1;
  230fd7:	48 0f a4 fe 01       	shld   rsi,rdi,0x1
  230fdc:	48 01 ff             	add    rdi,rdi
        a |= @boolToInt((a & 4) != 0); // Or P into R
  230fdf:	b8 02 01 00 00       	mov    eax,0x102
  230fe4:	c4 e2 78 f7 c7       	bextr  eax,edi,eax
  230fe9:	48 09 f8             	or     rax,rdi
        a += 1; // round - this step may add a significant bit
  230fec:	48 83 c0 01          	add    rax,0x1
  230ff0:	48 83 d6 00          	adc    rsi,0x0
        if ((a & (u128(1) << LDBL_MANT_DIG)) != 0) {
  230ff4:	48 0f ba e6 33       	bt     rsi,0x33
  230ff9:	72 0b                	jb     231006 <__floatuntitf+0x106>
  230ffb:	48 0f ac f0 02       	shrd   rax,rsi,0x2
  231000:	48 c1 ee 02          	shr    rsi,0x2
  231004:	eb 0c                	jmp    231012 <__floatuntitf+0x112>
            a >>= 1;
  231006:	48 0f ac f0 03       	shrd   rax,rsi,0x3
  23100b:	48 c1 ee 03          	shr    rsi,0x3
  23100f:	44 89 ca             	mov    edx,r9d
        // a is now rounded to LDBL_MANT_DIG bits
    }

    const high: u128 = (@intCast(u64, (e + 16383)) << 48) | // exponent
  231012:	81 c2 ff 3f 00 00    	add    edx,0x3fff
  231018:	48 c1 e2 30          	shl    rdx,0x30
        (@truncate(u64, a >> 64) & 0x0000ffffffffffff); // mantissa-high
  23101c:	b1 30                	mov    cl,0x30
  23101e:	c4 e2 f0 f5 ce       	bzhi   rcx,rsi,rcx
    const low = @truncate(u64, a); // mantissa-low

    return @bitCast(f128, low | (high << 64));
  231023:	48 89 44 24 e8       	mov    QWORD PTR [rsp-0x18],rax
    const high: u128 = (@intCast(u64, (e + 16383)) << 48) | // exponent
  231028:	48 09 d1             	or     rcx,rdx
    return @bitCast(f128, low | (high << 64));
  23102b:	48 89 4c 24 f0       	mov    QWORD PTR [rsp-0x10],rcx
  231030:	0f 28 44 24 e8       	movaps xmm0,XMMWORD PTR [rsp-0x18]
  231035:	5b                   	pop    rbx
  231036:	41 5e                	pop    r14
  231038:	c3                   	ret    
  231039:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

0000000000231040 <__floatuntidf>:
const DBL_MANT_DIG = 53;

pub extern fn __floatuntidf(arg: u128) f64 {
    @setRuntimeSafety(is_test);

    if (arg == 0)
  231040:	48 89 f8             	mov    rax,rdi
  231043:	48 09 f0             	or     rax,rsi
  231046:	0f 84 a0 00 00 00    	je     2310ec <__floatuntidf+0xac>
        return 0.0;

    var a = arg;
    const N: u32 = @sizeOf(u128) * 8;
    const sd = @bitCast(i32, N - @clz(a)); // number of significant digits
  23104c:	f3 48 0f bd c6       	lzcnt  rax,rsi
  231051:	f3 48 0f bd cf       	lzcnt  rcx,rdi
  231056:	83 c1 40             	add    ecx,0x40
  231059:	48 85 f6             	test   rsi,rsi
  23105c:	0f 45 c8             	cmovne ecx,eax
  23105f:	ba 80 00 00 00       	mov    edx,0x80
  231064:	29 ca                	sub    edx,ecx
    var e: i32 = sd - 1; // exponent
  231066:	41 bb 7f 00 00 00    	mov    r11d,0x7f
  23106c:	41 29 cb             	sub    r11d,ecx
    if (sd > DBL_MANT_DIG) {
  23106f:	83 fa 36             	cmp    edx,0x36
  231072:	7c 7d                	jl     2310f1 <__floatuntidf+0xb1>
        //                                                12345678901234567890123456
        //  1 = msb 1 bit
        //  P = bit DBL_MANT_DIG-1 bits to the right of 1
        //  Q = bit DBL_MANT_DIG bits to the right of 1
        //  R = "or" of all bits to the right of Q
        switch (sd) {
  231074:	0f 84 97 00 00 00    	je     231111 <__floatuntidf+0xd1>
  23107a:	83 fa 37             	cmp    edx,0x37
  23107d:	0f 84 96 00 00 00    	je     231119 <__floatuntidf+0xd9>
            DBL_MANT_DIG + 1 => {
                a <<= 1;
            },
            DBL_MANT_DIG + 2 => {},
            else => {
                const shift_amt = @bitCast(i32, N + (DBL_MANT_DIG + 2)) - sd;
  231083:	41 56                	push   r14
  231085:	53                   	push   rbx
  231086:	41 b8 37 00 00 00    	mov    r8d,0x37
                const shift_amt_u7 = @intCast(u7, shift_amt);
                a = (a >> @intCast(u7, sd - (DBL_MANT_DIG + 2))) |
  23108c:	8d 4a 49             	lea    ecx,[rdx+0x49]
  23108f:	83 e1 7f             	and    ecx,0x7f
  231092:	49 89 f9             	mov    r9,rdi
  231095:	49 0f ad f1          	shrd   r9,rsi,cl
                const shift_amt = @bitCast(i32, N + (DBL_MANT_DIG + 2)) - sd;
  231099:	41 29 d0             	sub    r8d,edx
                a = (a >> @intCast(u7, sd - (DBL_MANT_DIG + 2))) |
  23109c:	c4 62 f3 f7 d6       	shrx   r10,rsi,rcx
  2310a1:	45 31 f6             	xor    r14d,r14d
  2310a4:	f6 c1 40             	test   cl,0x40
  2310a7:	4d 0f 45 ca          	cmovne r9,r10
  2310ab:	4d 0f 45 d6          	cmovne r10,r14
                    @boolToInt((a & (u128(@maxValue(u128)) >> shift_amt_u7)) != 0);
  2310af:	41 83 e0 7f          	and    r8d,0x7f
  2310b3:	48 c7 c3 ff ff ff ff 	mov    rbx,0xffffffffffffffff
  2310ba:	c4 e2 bb f7 c3       	shrx   rax,rbx,r8
  2310bf:	44 89 c1             	mov    ecx,r8d
  2310c2:	48 0f ad db          	shrd   rbx,rbx,cl
  2310c6:	41 f6 c0 40          	test   r8b,0x40
  2310ca:	48 0f 45 d8          	cmovne rbx,rax
  2310ce:	49 0f 45 c6          	cmovne rax,r14
  2310d2:	48 21 fb             	and    rbx,rdi
  2310d5:	48 21 f0             	and    rax,rsi
  2310d8:	31 ff                	xor    edi,edi
  2310da:	48 09 d8             	or     rax,rbx
  2310dd:	40 0f 95 c7          	setne  dil
                a = (a >> @intCast(u7, sd - (DBL_MANT_DIG + 2))) |
  2310e1:	4c 09 cf             	or     rdi,r9
  2310e4:	4c 89 d6             	mov    rsi,r10
        switch (sd) {
  2310e7:	5b                   	pop    rbx
  2310e8:	41 5e                	pop    r14
  2310ea:	eb 2d                	jmp    231119 <__floatuntidf+0xd9>
        return 0.0;
  2310ec:	c5 f8 57 c0          	vxorps xmm0,xmm0,xmm0
  2310f0:	c3                   	ret    
            a >>= 1;
            e += 1;
        }
        // a is now rounded to DBL_MANT_DIG bits
    } else {
        a <<= @intCast(u7, DBL_MANT_DIG - sd);
  2310f1:	b8 35 00 00 00       	mov    eax,0x35
  2310f6:	29 d0                	sub    eax,edx
  2310f8:	83 e0 7f             	and    eax,0x7f
  2310fb:	c4 e2 f9 f7 d7       	shlx   rdx,rdi,rax
  231100:	31 c9                	xor    ecx,ecx
  231102:	a8 40                	test   al,0x40
  231104:	48 0f 44 ca          	cmove  rcx,rdx
    if (sd > DBL_MANT_DIG) {
  231108:	48 89 ce             	mov    rsi,rcx
  23110b:	48 c1 ee 20          	shr    rsi,0x20
  23110f:	eb 48                	jmp    231159 <__floatuntidf+0x119>
                a <<= 1;
  231111:	48 0f a4 fe 01       	shld   rsi,rdi,0x1
  231116:	48 01 ff             	add    rdi,rdi
        a |= @boolToInt((a & 4) != 0); // Or P into R
  231119:	b8 02 01 00 00       	mov    eax,0x102
  23111e:	c4 e2 78 f7 c7       	bextr  eax,edi,eax
  231123:	48 09 f8             	or     rax,rdi
        a += 1; // round - this step may add a significant bit
  231126:	48 83 c0 01          	add    rax,0x1
  23112a:	48 83 d6 00          	adc    rsi,0x0
            a >>= 1;
  23112e:	48 89 f1             	mov    rcx,rsi
        if ((a & (u128(1) << DBL_MANT_DIG)) != 0) {
  231131:	48 0f ba e0 37       	bt     rax,0x37
  231136:	72 10                	jb     231148 <__floatuntidf+0x108>
  231138:	48 0f a4 c1 3e       	shld   rcx,rax,0x3e
  23113d:	48 c1 e8 22          	shr    rax,0x22
  231141:	c1 e6 1e             	shl    esi,0x1e
  231144:	09 c6                	or     esi,eax
  231146:	eb 11                	jmp    231159 <__floatuntidf+0x119>
            a >>= 1;
  231148:	48 0f a4 c1 3d       	shld   rcx,rax,0x3d
        if ((a & (u128(1) << DBL_MANT_DIG)) != 0) {
  23114d:	48 c1 e8 23          	shr    rax,0x23
  231151:	c1 e6 1d             	shl    esi,0x1d
  231154:	09 c6                	or     esi,eax
  231156:	41 89 d3             	mov    r11d,edx
        // a is now rounded to DBL_MANT_DIG bits
    }

    const high: u64 = @bitCast(u32, (e + 1023) << 20) | // exponent
  231159:	41 c1 e3 14          	shl    r11d,0x14
        (@truncate(u32, a >> 32) & 0x000FFFFF); // mantissa-high
  23115d:	81 e6 ff ff 0f 00    	and    esi,0xfffff
    const high: u64 = @bitCast(u32, (e + 1023) << 20) | // exponent
  231163:	42 8d 04 1e          	lea    eax,[rsi+r11*1]
  231167:	05 00 00 f0 3f       	add    eax,0x3ff00000
    const low = @truncate(u32, a); // mantissa-low

    return @bitCast(f64, low | (high << 32));
  23116c:	48 c1 e0 20          	shl    rax,0x20
  231170:	89 c9                	mov    ecx,ecx
  231172:	48 09 c1             	or     rcx,rax
  231175:	c4 e1 f9 6e c1       	vmovq  xmm0,rcx
  23117a:	c3                   	ret    
  23117b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000231180 <__floatuntisf>:
const FLT_MANT_DIG = 24;

pub extern fn __floatuntisf(arg: u128) f32 {
    @setRuntimeSafety(is_test);

    if (arg == 0)
  231180:	48 89 f8             	mov    rax,rdi
  231183:	48 09 f0             	or     rax,rsi
  231186:	0f 84 93 00 00 00    	je     23121f <__floatuntisf+0x9f>
        return 0.0;

    var a = arg;
    const N: u32 = @sizeOf(u128) * 8;
    const sd = @bitCast(i32, N - @clz(a)); // number of significant digits
  23118c:	f3 48 0f bd c6       	lzcnt  rax,rsi
  231191:	f3 48 0f bd cf       	lzcnt  rcx,rdi
  231196:	83 c1 40             	add    ecx,0x40
  231199:	48 85 f6             	test   rsi,rsi
  23119c:	0f 45 c8             	cmovne ecx,eax
  23119f:	ba 80 00 00 00       	mov    edx,0x80
  2311a4:	29 ca                	sub    edx,ecx
    var e: i32 = sd - 1; // exponent
  2311a6:	b8 7f 00 00 00       	mov    eax,0x7f
  2311ab:	29 c8                	sub    eax,ecx
    if (sd > FLT_MANT_DIG) {
  2311ad:	83 fa 19             	cmp    edx,0x19
  2311b0:	7c 72                	jl     231224 <__floatuntisf+0xa4>
        //                                                12345678901234567890123456
        //  1 = msb 1 bit
        //  P = bit FLT_MANT_DIG-1 bits to the right of 1
        //  Q = bit FLT_MANT_DIG bits to the right of 1
        //  R = "or" of all bits to the right of Q
        switch (sd) {
  2311b2:	0f 84 87 00 00 00    	je     23123f <__floatuntisf+0xbf>
  2311b8:	83 fa 1a             	cmp    edx,0x1a
  2311bb:	0f 84 81 00 00 00    	je     231242 <__floatuntisf+0xc2>
            },
            FLT_MANT_DIG + 2 => {},
            else => {
                const shift_amt = @bitCast(i32, N + (FLT_MANT_DIG + 2)) - sd;
                const shift_amt_u7 = @intCast(u7, shift_amt);
                a = (a >> @intCast(u7, sd - (FLT_MANT_DIG + 2))) |
  2311c1:	53                   	push   rbx
  2311c2:	8d 4a 66             	lea    ecx,[rdx+0x66]
  2311c5:	83 e1 7f             	and    ecx,0x7f
  2311c8:	49 89 f9             	mov    r9,rdi
  2311cb:	49 0f ad f1          	shrd   r9,rsi,cl
                const shift_amt = @bitCast(i32, N + (FLT_MANT_DIG + 2)) - sd;
  2311cf:	41 b8 1a 00 00 00    	mov    r8d,0x1a
  2311d5:	41 29 d0             	sub    r8d,edx
                a = (a >> @intCast(u7, sd - (FLT_MANT_DIG + 2))) |
  2311d8:	c4 62 f3 f7 d6       	shrx   r10,rsi,rcx
  2311dd:	45 31 db             	xor    r11d,r11d
  2311e0:	f6 c1 40             	test   cl,0x40
  2311e3:	4d 0f 44 d1          	cmove  r10,r9
                    @boolToInt((a & (u128(@maxValue(u128)) >> shift_amt_u7)) != 0);
  2311e7:	41 83 e0 7f          	and    r8d,0x7f
  2311eb:	49 c7 c1 ff ff ff ff 	mov    r9,0xffffffffffffffff
  2311f2:	c4 c2 bb f7 d9       	shrx   rbx,r9,r8
  2311f7:	44 89 c1             	mov    ecx,r8d
  2311fa:	4d 0f ad c9          	shrd   r9,r9,cl
  2311fe:	41 f6 c0 40          	test   r8b,0x40
  231202:	4c 0f 45 cb          	cmovne r9,rbx
  231206:	4c 0f 44 db          	cmove  r11,rbx
  23120a:	49 21 f9             	and    r9,rdi
  23120d:	49 21 f3             	and    r11,rsi
  231210:	31 ff                	xor    edi,edi
  231212:	4d 09 cb             	or     r11,r9
  231215:	40 0f 95 c7          	setne  dil
                a = (a >> @intCast(u7, sd - (FLT_MANT_DIG + 2))) |
  231219:	4c 09 d7             	or     rdi,r10
        switch (sd) {
  23121c:	5b                   	pop    rbx
  23121d:	eb 23                	jmp    231242 <__floatuntisf+0xc2>
        return 0.0;
  23121f:	c5 f8 57 c0          	vxorps xmm0,xmm0,xmm0
  231223:	c3                   	ret    
            a >>= 1;
            e += 1;
        }
        // a is now rounded to FLT_MANT_DIG bits
    } else {
        a <<= @intCast(u7, FLT_MANT_DIG - sd);
  231224:	be 18 00 00 00       	mov    esi,0x18
  231229:	29 d6                	sub    esi,edx
  23122b:	83 e6 7f             	and    esi,0x7f
  23122e:	c4 e2 c9 f7 d7       	shlx   rdx,rdi,rsi
  231233:	31 c9                	xor    ecx,ecx
  231235:	40 f6 c6 40          	test   sil,0x40
  231239:	48 0f 44 ca          	cmove  rcx,rdx
  23123d:	eb 28                	jmp    231267 <__floatuntisf+0xe7>
                a <<= 1;
  23123f:	48 01 ff             	add    rdi,rdi
        a |= @boolToInt((a & 4) != 0); // Or P into R
  231242:	b9 02 01 00 00       	mov    ecx,0x102
  231247:	c4 e2 70 f7 cf       	bextr  ecx,edi,ecx
  23124c:	48 09 f9             	or     rcx,rdi
        a += 1; // round - this step may add a significant bit
  23124f:	48 83 c1 01          	add    rcx,0x1
        if ((a & (u128(1) << FLT_MANT_DIG)) != 0) {
  231253:	f7 c1 00 00 00 04    	test   ecx,0x4000000
  231259:	75 06                	jne    231261 <__floatuntisf+0xe1>
  23125b:	48 c1 e9 02          	shr    rcx,0x2
  23125f:	eb 06                	jmp    231267 <__floatuntisf+0xe7>
            a >>= 1;
  231261:	48 c1 e9 03          	shr    rcx,0x3
  231265:	89 d0                	mov    eax,edx
        // a is now rounded to FLT_MANT_DIG bits
    }

    const high = @bitCast(u32, (e + 127) << 23); // exponent
  231267:	c1 e0 17             	shl    eax,0x17
    const low = @truncate(u32, a) & 0x007fffff; // mantissa
  23126a:	81 e1 ff ff 7f 00    	and    ecx,0x7fffff

    return @bitCast(f32, high | low);
  231270:	8d 04 08             	lea    eax,[rax+rcx*1]
  231273:	05 00 00 80 3f       	add    eax,0x3f800000
  231278:	c5 f9 6e c0          	vmovd  xmm0,eax
  23127c:	c3                   	ret    
  23127d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000231280 <__extenddftf2>:
    const aRep: src_rep_t = @bitCast(src_rep_t, a);
  231280:	c4 e1 f9 7e c1       	vmovq  rcx,xmm0
    const aAbs: src_rep_t = aRep & srcAbsMask;
  231285:	b0 3f                	mov    al,0x3f
  231287:	c4 e2 f8 f5 f1       	bzhi   rsi,rcx,rax
  23128c:	48 b8 ff ff ff ff ff 	movabs rax,0x7fffffffffffffff
  231293:	ff ff 7f 
    const sign: src_rep_t = aRep & srcSignMask;
  231296:	48 83 c0 01          	add    rax,0x1
  23129a:	48 21 c8             	and    rax,rcx
    if (aAbs -% srcMinNormal < srcInfinity - srcMinNormal) {
  23129d:	48 ba 00 00 00 00 00 	movabs rdx,0xfff0000000000000
  2312a4:	00 f0 ff 
  2312a7:	48 01 f2             	add    rdx,rsi
  2312aa:	48 c1 ea 35          	shr    rdx,0x35
  2312ae:	48 81 fa fe 03 00 00 	cmp    rdx,0x3fe
  2312b5:	77 1a                	ja     2312d1 <__extenddftf2+0x51>
        absResult = dst_rep_t(aAbs) << (dstSigBits - srcSigBits);
  2312b7:	48 89 f2             	mov    rdx,rsi
  2312ba:	48 c1 e2 3c          	shl    rdx,0x3c
  2312be:	48 c1 ee 04          	shr    rsi,0x4
        absResult += (dstExpBias - srcExpBias) << dstSigBits;
  2312c2:	48 bf 00 00 00 00 00 	movabs rdi,0x3c00000000000000
  2312c9:	00 00 3c 
  2312cc:	48 01 f7             	add    rdi,rsi
  2312cf:	eb 7a                	jmp    23134b <__extenddftf2+0xcb>
    } else if (aAbs >= srcInfinity) {
  2312d1:	48 89 f2             	mov    rdx,rsi
  2312d4:	48 c1 ea 34          	shr    rdx,0x34
  2312d8:	48 81 fa ff 07 00 00 	cmp    rdx,0x7ff
  2312df:	72 17                	jb     2312f8 <__extenddftf2+0x78>
        absResult |= dst_rep_t(aAbs & srcNaNCode) << (dstSigBits - srcSigBits);
  2312e1:	48 89 ca             	mov    rdx,rcx
  2312e4:	48 c1 e2 3c          	shl    rdx,0x3c
  2312e8:	48 c1 e9 04          	shr    rcx,0x4
  2312ec:	48 bf 00 00 00 00 00 	movabs rdi,0x7fff000000000000
  2312f3:	00 ff 7f 
  2312f6:	eb 4a                	jmp    231342 <__extenddftf2+0xc2>
    } else if (aAbs != 0) {
  2312f8:	48 85 f6             	test   rsi,rsi
  2312fb:	74 4a                	je     231347 <__extenddftf2+0xc7>
        const scale: u32 = @clz(aAbs) - @clz(src_rep_t(srcMinNormal));
  2312fd:	f3 48 0f bd ce       	lzcnt  rcx,rsi
  231302:	44 8d 41 75          	lea    r8d,[rcx+0x75]
  231306:	41 83 e0 7f          	and    r8d,0x7f
        absResult = dst_rep_t(aAbs) << @intCast(DstShift, dstSigBits - srcSigBits + scale);
  23130a:	83 c1 31             	add    ecx,0x31
  23130d:	83 e1 7f             	and    ecx,0x7f
  231310:	45 31 c9             	xor    r9d,r9d
  231313:	31 ff                	xor    edi,edi
  231315:	48 0f a5 f7          	shld   rdi,rsi,cl
  231319:	c4 e2 f1 f7 d6       	shlx   rdx,rsi,rcx
  23131e:	f6 c1 40             	test   cl,0x40
  231321:	48 0f 45 fa          	cmovne rdi,rdx
  231325:	49 0f 45 d1          	cmovne rdx,r9
        absResult ^= dstMinNormal;
  231329:	48 b9 00 00 00 00 00 	movabs rcx,0x1000000000000
  231330:	00 01 00 
  231333:	48 31 f9             	xor    rcx,rdi
        const resultExponent: u32 = dstExpBias - srcExpBias - scale + 1;
  231336:	bf 01 3c 00 00       	mov    edi,0x3c01
  23133b:	44 29 c7             	sub    edi,r8d
        absResult |= @intCast(dst_rep_t, resultExponent) << dstSigBits;
  23133e:	48 c1 e7 30          	shl    rdi,0x30
  231342:	48 09 cf             	or     rdi,rcx
  231345:	eb 04                	jmp    23134b <__extenddftf2+0xcb>
  231347:	31 d2                	xor    edx,edx
  231349:	31 ff                	xor    edi,edi
    const result: dst_rep_t align(@alignOf(dst_t)) = absResult | dst_rep_t(sign) << (dstBits - srcBits);
  23134b:	48 89 54 24 e8       	mov    QWORD PTR [rsp-0x18],rdx
  231350:	48 09 c7             	or     rdi,rax
  231353:	48 89 7c 24 f0       	mov    QWORD PTR [rsp-0x10],rdi
  231358:	0f 28 44 24 e8       	movaps xmm0,XMMWORD PTR [rsp-0x18]
    return extendXfYf2(f128, f64, a);
  23135d:	c3                   	ret    
  23135e:	66 90                	xchg   ax,ax

0000000000231360 <__extendsftf2>:
    const aRep: src_rep_t = @bitCast(src_rep_t, a);
  231360:	c5 f9 7e c2          	vmovd  edx,xmm0
    const aAbs: src_rep_t = aRep & srcAbsMask;
  231364:	89 d1                	mov    ecx,edx
  231366:	81 e1 ff ff ff 7f    	and    ecx,0x7fffffff
    const sign: src_rep_t = aRep & srcSignMask;
  23136c:	89 d0                	mov    eax,edx
  23136e:	25 00 00 00 80       	and    eax,0x80000000
    if (aAbs -% srcMinNormal < srcInfinity - srcMinNormal) {
  231373:	8d b1 00 00 80 ff    	lea    esi,[rcx-0x800000]
  231379:	81 fe ff ff ff 7e    	cmp    esi,0x7effffff
  23137f:	77 17                	ja     231398 <__extendsftf2+0x38>
        absResult = dst_rep_t(aAbs) << (dstSigBits - srcSigBits);
  231381:	89 ca                	mov    edx,ecx
  231383:	48 c1 e2 19          	shl    rdx,0x19
        absResult += (dstExpBias - srcExpBias) << dstSigBits;
  231387:	48 b9 00 00 00 00 00 	movabs rcx,0x3f80000000000000
  23138e:	00 80 3f 
  231391:	48 01 d1             	add    rcx,rdx
  231394:	31 d2                	xor    edx,edx
  231396:	eb 6f                	jmp    231407 <__extendsftf2+0xa7>
    } else if (aAbs >= srcInfinity) {
  231398:	81 f9 00 00 80 7f    	cmp    ecx,0x7f800000
  23139e:	72 17                	jb     2313b7 <__extendsftf2+0x57>
        absResult |= dst_rep_t(aAbs & srcNaNCode) << (dstSigBits - srcSigBits);
  2313a0:	89 d2                	mov    edx,edx
  2313a2:	48 c1 e2 19          	shl    rdx,0x19
  2313a6:	48 b9 00 00 00 00 00 	movabs rcx,0x7fff000000000000
  2313ad:	00 ff 7f 
  2313b0:	48 09 d1             	or     rcx,rdx
  2313b3:	31 d2                	xor    edx,edx
  2313b5:	eb 50                	jmp    231407 <__extendsftf2+0xa7>
    } else if (aAbs != 0) {
  2313b7:	85 c9                	test   ecx,ecx
  2313b9:	74 48                	je     231403 <__extendsftf2+0xa3>
        const scale: u32 = @clz(aAbs) - @clz(src_rep_t(srcMinNormal));
  2313bb:	f3 0f bd f1          	lzcnt  esi,ecx
  2313bf:	83 c6 38             	add    esi,0x38
  2313c2:	83 e6 3f             	and    esi,0x3f
        absResult = dst_rep_t(aAbs) << @intCast(DstShift, dstSigBits - srcSigBits + scale);
  2313c5:	89 ca                	mov    edx,ecx
  2313c7:	8d 4e 59             	lea    ecx,[rsi+0x59]
  2313ca:	83 e1 7f             	and    ecx,0x7f
  2313cd:	45 31 c0             	xor    r8d,r8d
  2313d0:	31 ff                	xor    edi,edi
  2313d2:	48 0f a5 d7          	shld   rdi,rdx,cl
  2313d6:	c4 e2 f1 f7 d2       	shlx   rdx,rdx,rcx
  2313db:	f6 c1 40             	test   cl,0x40
  2313de:	48 0f 45 fa          	cmovne rdi,rdx
  2313e2:	49 0f 45 d0          	cmovne rdx,r8
        absResult ^= dstMinNormal;
  2313e6:	49 b8 00 00 00 00 00 	movabs r8,0x1000000000000
  2313ed:	00 01 00 
  2313f0:	49 31 f8             	xor    r8,rdi
        const resultExponent: u32 = dstExpBias - srcExpBias - scale + 1;
  2313f3:	b9 81 3f 00 00       	mov    ecx,0x3f81
  2313f8:	29 f1                	sub    ecx,esi
        absResult |= @intCast(dst_rep_t, resultExponent) << dstSigBits;
  2313fa:	48 c1 e1 30          	shl    rcx,0x30
  2313fe:	4c 09 c1             	or     rcx,r8
  231401:	eb 04                	jmp    231407 <__extendsftf2+0xa7>
  231403:	31 d2                	xor    edx,edx
  231405:	31 c9                	xor    ecx,ecx
    const result: dst_rep_t align(@alignOf(dst_t)) = absResult | dst_rep_t(sign) << (dstBits - srcBits);
  231407:	48 c1 e0 20          	shl    rax,0x20
  23140b:	48 89 54 24 e8       	mov    QWORD PTR [rsp-0x18],rdx
  231410:	48 09 c8             	or     rax,rcx
  231413:	48 89 44 24 f0       	mov    QWORD PTR [rsp-0x10],rax
  231418:	0f 28 44 24 e8       	movaps xmm0,XMMWORD PTR [rsp-0x18]
    return extendXfYf2(f128, f32, a);
  23141d:	c3                   	ret    
  23141e:	66 90                	xchg   ax,ax

0000000000231420 <__trunctfdf2>:
    const aRep: src_rep_t = @bitCast(src_rep_t, a);
  231420:	66 0f 7f 44 24 e8    	movdqa XMMWORD PTR [rsp-0x18],xmm0
  231426:	48 8b 74 24 e8       	mov    rsi,QWORD PTR [rsp-0x18]
  23142b:	48 8b 54 24 f0       	mov    rdx,QWORD PTR [rsp-0x10]
    const aAbs: src_rep_t = aRep & srcAbsMask;
  231430:	b0 3f                	mov    al,0x3f
  231432:	c4 e2 f8 f5 ca       	bzhi   rcx,rdx,rax
    if (aAbs -% underflow < aAbs -% overflow) {
  231437:	48 b8 00 00 00 00 00 	movabs rax,0xc3ff000000000000
  23143e:	00 ff c3 
  231441:	48 01 c8             	add    rax,rcx
  231444:	48 bf 00 00 00 00 00 	movabs rdi,0xbc01000000000000
  23144b:	00 01 bc 
  23144e:	48 01 cf             	add    rdi,rcx
  231451:	48 39 f8             	cmp    rax,rdi
  231454:	73 35                	jae    23148b <__trunctfdf2+0x6b>
  231456:	48 b8 00 00 00 00 00 	movabs rax,0x4000000000000000
  23145d:	00 00 40 
        absResult = @truncate(dst_rep_t, aAbs >> (srcSigBits - dstSigBits));
  231460:	48 89 d1             	mov    rcx,rdx
  231463:	48 0f a4 f1 04       	shld   rcx,rsi,0x4
        const roundBits: src_rep_t = aAbs & roundMask;
  231468:	40 b7 3c             	mov    dil,0x3c
  23146b:	c4 e2 c0 f5 f6       	bzhi   rsi,rsi,rdi
        if (roundBits > halfway) {
  231470:	48 bf 01 00 00 00 00 	movabs rdi,0x800000000000001
  231477:	00 00 08 
  23147a:	48 39 fe             	cmp    rsi,rdi
  23147d:	72 40                	jb     2314bf <__trunctfdf2+0x9f>
            absResult += 1;
  23147f:	48 01 c1             	add    rcx,rax
  231482:	48 83 c1 01          	add    rcx,0x1
  231486:	e9 0f 01 00 00       	jmp    23159a <__trunctfdf2+0x17a>
    } else if (aAbs > srcInfinity) {
  23148b:	48 83 fe 01          	cmp    rsi,0x1
  23148f:	48 b8 00 00 00 00 00 	movabs rax,0x7fff000000000000
  231496:	00 ff 7f 
  231499:	48 89 cf             	mov    rdi,rcx
  23149c:	48 19 c7             	sbb    rdi,rax
  23149f:	72 55                	jb     2314f6 <__trunctfdf2+0xd6>
        absResult |= @intCast(dst_rep_t, ((aAbs & srcNaNCode) >> (srcSigBits - dstSigBits)) & dstNaNCode);
  2314a1:	48 0f ac d6 3c       	shrd   rsi,rdx,0x3c
  2314a6:	b0 33                	mov    al,0x33
  2314a8:	c4 e2 f8 f5 c6       	bzhi   rax,rsi,rax
  2314ad:	48 b9 00 00 00 00 00 	movabs rcx,0x7ff8000000000000
  2314b4:	00 f8 7f 
  2314b7:	48 09 c1             	or     rcx,rax
  2314ba:	e9 db 00 00 00       	jmp    23159a <__trunctfdf2+0x17a>
  2314bf:	48 01 c1             	add    rcx,rax
        } else if (roundBits == halfway) {
  2314c2:	c4 e1 f9 6e c6       	vmovq  xmm0,rsi
  2314c7:	48 b8 00 00 00 00 00 	movabs rax,0x800000000000000
  2314ce:	00 00 08 
  2314d1:	c4 e1 f9 6e c8       	vmovq  xmm1,rax
  2314d6:	c5 f9 74 c1          	vpcmpeqb xmm0,xmm0,xmm1
  2314da:	c5 f9 d7 c0          	vpmovmskb eax,xmm0
  2314de:	3d ff ff 00 00       	cmp    eax,0xffff
  2314e3:	0f 85 b1 00 00 00    	jne    23159a <__trunctfdf2+0x17a>
  2314e9:	89 c8                	mov    eax,ecx
  2314eb:	83 e0 01             	and    eax,0x1
  2314ee:	48 01 c1             	add    rcx,rax
  2314f1:	e9 a4 00 00 00       	jmp    23159a <__trunctfdf2+0x17a>
    } else if (aAbs >= overflow) {
  2314f6:	48 c1 e9 30          	shr    rcx,0x30
  2314fa:	48 81 f9 fe 43 00 00 	cmp    rcx,0x43fe
  231501:	76 0f                	jbe    231512 <__trunctfdf2+0xf2>
  231503:	48 b9 00 00 00 00 00 	movabs rcx,0x7ff0000000000000
  23150a:	00 f0 7f 
  23150d:	e9 88 00 00 00       	jmp    23159a <__trunctfdf2+0x17a>
        const shift = @intCast(u32, srcExpBias - dstExpBias - aExp + 1);
  231512:	b8 00 3c 00 00       	mov    eax,0x3c00
  231517:	29 c8                	sub    eax,ecx
        if (shift > srcSigBits) {
  231519:	83 f8 6f             	cmp    eax,0x6f
  23151c:	76 04                	jbe    231522 <__trunctfdf2+0x102>
  23151e:	31 c9                	xor    ecx,ecx
  231520:	eb 78                	jmp    23159a <__trunctfdf2+0x17a>
  231522:	b1 30                	mov    cl,0x30
  231524:	c4 e2 f0 f5 ca       	bzhi   rcx,rdx,rcx
  231529:	49 b8 00 00 00 00 00 	movabs r8,0x1000000000000
  231530:	00 01 00 
  231533:	49 09 c8             	or     r8,rcx
            const sticky: src_rep_t = significand << @intCast(SrcShift, srcBits - shift);
  231536:	b9 7f 00 00 00       	mov    ecx,0x7f
  23153b:	29 c1                	sub    ecx,eax
  23153d:	83 e1 7f             	and    ecx,0x7f
  231540:	4c 89 c7             	mov    rdi,r8
  231543:	48 0f a5 f7          	shld   rdi,rsi,cl
        const shift = @intCast(u32, srcExpBias - dstExpBias - aExp + 1);
  231547:	83 c0 01             	add    eax,0x1
            const sticky: src_rep_t = significand << @intCast(SrcShift, srcBits - shift);
  23154a:	c4 62 f1 f7 ce       	shlx   r9,rsi,rcx
  23154f:	45 31 d2             	xor    r10d,r10d
  231552:	f6 c1 40             	test   cl,0x40
  231555:	49 0f 45 f9          	cmovne rdi,r9
  231559:	4d 0f 45 ca          	cmovne r9,r10
            const denormalizedSignificand: src_rep_t = significand >> @intCast(SrcShift, shift) | sticky;
  23155d:	83 e0 7f             	and    eax,0x7f
  231560:	89 c1                	mov    ecx,eax
  231562:	4c 0f ad c6          	shrd   rsi,r8,cl
  231566:	c4 c2 fb f7 c8       	shrx   rcx,r8,rax
  23156b:	a8 40                	test   al,0x40
  23156d:	48 0f 45 f1          	cmovne rsi,rcx
  231571:	49 0f 45 ca          	cmovne rcx,r10
  231575:	4c 09 ce             	or     rsi,r9
  231578:	48 09 f9             	or     rcx,rdi
            absResult = @intCast(dst_rep_t, denormalizedSignificand >> (srcSigBits - dstSigBits));
  23157b:	48 0f a4 f1 04       	shld   rcx,rsi,0x4
            const roundBits: src_rep_t = denormalizedSignificand & roundMask;
  231580:	b0 3c                	mov    al,0x3c
  231582:	c4 e2 f8 f5 c6       	bzhi   rax,rsi,rax
            if (roundBits > halfway) {
  231587:	48 be 01 00 00 00 00 	movabs rsi,0x800000000000001
  23158e:	00 00 08 
  231591:	48 39 f0             	cmp    rax,rsi
  231594:	72 1a                	jb     2315b0 <__trunctfdf2+0x190>
                absResult += 1;
  231596:	48 83 c1 01          	add    rcx,0x1
    const result: dst_rep_t align(@alignOf(dst_t)) = absResult | @truncate(dst_rep_t, sign >> @intCast(SrcShift, srcBits - dstBits));
  23159a:	48 b8 00 00 00 00 00 	movabs rax,0x8000000000000000
  2315a1:	00 00 80 
  2315a4:	48 21 c2             	and    rdx,rax
  2315a7:	48 09 ca             	or     rdx,rcx
    return @bitCast(dst_t, result);
  2315aa:	c4 e1 f9 6e c2       	vmovq  xmm0,rdx
    return truncXfYf2(f64, f128, a);
  2315af:	c3                   	ret    
            } else if (roundBits == halfway) {
  2315b0:	c4 e1 f9 6e c0       	vmovq  xmm0,rax
  2315b5:	e9 0d ff ff ff       	jmp    2314c7 <__trunctfdf2+0xa7>
  2315ba:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

00000000002315c0 <__trunctfsf2>:
    const aRep: src_rep_t = @bitCast(src_rep_t, a);
  2315c0:	66 0f 7f 44 24 e8    	movdqa XMMWORD PTR [rsp-0x18],xmm0
  2315c6:	48 8b 74 24 e8       	mov    rsi,QWORD PTR [rsp-0x18]
  2315cb:	48 8b 54 24 f0       	mov    rdx,QWORD PTR [rsp-0x10]
    const aAbs: src_rep_t = aRep & srcAbsMask;
  2315d0:	b0 3f                	mov    al,0x3f
  2315d2:	c4 e2 f8 f5 fa       	bzhi   rdi,rdx,rax
    if (aAbs -% underflow < aAbs -% overflow) {
  2315d7:	48 b8 00 00 00 00 00 	movabs rax,0xc07f000000000000
  2315de:	00 7f c0 
  2315e1:	48 01 f8             	add    rax,rdi
  2315e4:	48 b9 00 00 00 00 00 	movabs rcx,0xbf81000000000000
  2315eb:	00 81 bf 
  2315ee:	48 01 f9             	add    rcx,rdi
  2315f1:	48 39 c8             	cmp    rax,rcx
  2315f4:	73 29                	jae    23161f <__trunctfsf2+0x5f>
        absResult = @truncate(dst_rep_t, aAbs >> (srcSigBits - dstSigBits));
  2315f6:	48 89 d1             	mov    rcx,rdx
  2315f9:	48 c1 e9 19          	shr    rcx,0x19
        const roundBits: src_rep_t = aAbs & roundMask;
  2315fd:	89 d0                	mov    eax,edx
  2315ff:	25 ff ff ff 01       	and    eax,0x1ffffff
        if (roundBits > halfway) {
  231604:	48 83 fe 01          	cmp    rsi,0x1
  231608:	48 89 c7             	mov    rdi,rax
  23160b:	48 81 df 00 00 00 01 	sbb    rdi,0x1000000
  231612:	72 39                	jb     23164d <__trunctfsf2+0x8d>
            absResult += 1;
  231614:	81 c1 01 00 00 40    	add    ecx,0x40000001
  23161a:	e9 0e 01 00 00       	jmp    23172d <__trunctfsf2+0x16d>
    } else if (aAbs > srcInfinity) {
  23161f:	48 83 fe 01          	cmp    rsi,0x1
  231623:	48 b8 00 00 00 00 00 	movabs rax,0x7fff000000000000
  23162a:	00 ff 7f 
  23162d:	48 89 f9             	mov    rcx,rdi
  231630:	48 19 c1             	sbb    rcx,rax
  231633:	72 5c                	jb     231691 <__trunctfsf2+0xd1>
        absResult |= @intCast(dst_rep_t, ((aAbs & srcNaNCode) >> (srcSigBits - dstSigBits)) & dstNaNCode);
  231635:	48 89 d1             	mov    rcx,rdx
  231638:	48 c1 e9 19          	shr    rcx,0x19
  23163c:	81 e1 ff ff 3f 00    	and    ecx,0x3fffff
  231642:	81 c9 00 00 c0 7f    	or     ecx,0x7fc00000
  231648:	e9 e0 00 00 00       	jmp    23172d <__trunctfsf2+0x16d>
  23164d:	81 c1 00 00 00 40    	add    ecx,0x40000000
        } else if (roundBits == halfway) {
  231653:	c4 e1 f9 6e c6       	vmovq  xmm0,rsi
  231658:	c4 e1 f9 6e c8       	vmovq  xmm1,rax
  23165d:	c5 f9 6c c1          	vpunpcklqdq xmm0,xmm0,xmm1
  231661:	b8 00 00 00 01       	mov    eax,0x1000000
  231666:	c4 e1 f9 6e c8       	vmovq  xmm1,rax
  23166b:	c5 f1 73 f9 08       	vpslldq xmm1,xmm1,0x8
  231670:	c5 f9 74 c1          	vpcmpeqb xmm0,xmm0,xmm1
  231674:	c5 f9 d7 c0          	vpmovmskb eax,xmm0
  231678:	3d ff ff 00 00       	cmp    eax,0xffff
  23167d:	0f 85 aa 00 00 00    	jne    23172d <__trunctfsf2+0x16d>
  231683:	89 c8                	mov    eax,ecx
  231685:	83 e0 01             	and    eax,0x1
  231688:	01 c8                	add    eax,ecx
  23168a:	89 c1                	mov    ecx,eax
  23168c:	e9 9c 00 00 00       	jmp    23172d <__trunctfsf2+0x16d>
    } else if (aAbs >= overflow) {
  231691:	48 c1 ef 30          	shr    rdi,0x30
  231695:	b9 00 00 80 7f       	mov    ecx,0x7f800000
  23169a:	48 81 ff 7e 40 00 00 	cmp    rdi,0x407e
  2316a1:	0f 87 86 00 00 00    	ja     23172d <__trunctfsf2+0x16d>
        const shift = @intCast(u32, srcExpBias - dstExpBias - aExp + 1);
  2316a7:	b8 80 3f 00 00       	mov    eax,0x3f80
  2316ac:	29 f8                	sub    eax,edi
  2316ae:	31 c9                	xor    ecx,ecx
        if (shift > srcSigBits) {
  2316b0:	83 f8 6f             	cmp    eax,0x6f
  2316b3:	77 78                	ja     23172d <__trunctfsf2+0x16d>
  2316b5:	b1 30                	mov    cl,0x30
  2316b7:	c4 e2 f0 f5 ca       	bzhi   rcx,rdx,rcx
  2316bc:	48 bf 00 00 00 00 00 	movabs rdi,0x1000000000000
  2316c3:	00 01 00 
  2316c6:	48 09 cf             	or     rdi,rcx
            const sticky: src_rep_t = significand << @intCast(SrcShift, srcBits - shift);
  2316c9:	b9 7f 00 00 00       	mov    ecx,0x7f
  2316ce:	29 c1                	sub    ecx,eax
  2316d0:	83 e1 7f             	and    ecx,0x7f
  2316d3:	49 89 f8             	mov    r8,rdi
  2316d6:	49 0f a5 f0          	shld   r8,rsi,cl
        const shift = @intCast(u32, srcExpBias - dstExpBias - aExp + 1);
  2316da:	83 c0 01             	add    eax,0x1
            const sticky: src_rep_t = significand << @intCast(SrcShift, srcBits - shift);
  2316dd:	c4 62 f1 f7 ce       	shlx   r9,rsi,rcx
  2316e2:	45 31 d2             	xor    r10d,r10d
  2316e5:	f6 c1 40             	test   cl,0x40
  2316e8:	4d 0f 45 c1          	cmovne r8,r9
  2316ec:	4d 0f 45 ca          	cmovne r9,r10
            const denormalizedSignificand: src_rep_t = significand >> @intCast(SrcShift, shift) | sticky;
  2316f0:	83 e0 7f             	and    eax,0x7f
  2316f3:	89 c1                	mov    ecx,eax
  2316f5:	48 0f ad fe          	shrd   rsi,rdi,cl
  2316f9:	c4 e2 fb f7 ff       	shrx   rdi,rdi,rax
  2316fe:	a8 40                	test   al,0x40
  231700:	48 0f 45 f7          	cmovne rsi,rdi
  231704:	49 0f 45 fa          	cmovne rdi,r10
  231708:	4c 09 ce             	or     rsi,r9
  23170b:	4c 09 c7             	or     rdi,r8
            absResult = @intCast(dst_rep_t, denormalizedSignificand >> (srcSigBits - dstSigBits));
  23170e:	48 89 f9             	mov    rcx,rdi
  231711:	48 c1 e9 19          	shr    rcx,0x19
            const roundBits: src_rep_t = denormalizedSignificand & roundMask;
  231715:	81 e7 ff ff ff 01    	and    edi,0x1ffffff
            if (roundBits > halfway) {
  23171b:	48 83 fe 01          	cmp    rsi,0x1
  23171f:	48 89 f8             	mov    rax,rdi
  231722:	48 1d 00 00 00 01    	sbb    rax,0x1000000
  231728:	72 14                	jb     23173e <__trunctfsf2+0x17e>
                absResult += 1;
  23172a:	83 c1 01             	add    ecx,0x1
    const result: dst_rep_t align(@alignOf(dst_t)) = absResult | @truncate(dst_rep_t, sign >> @intCast(SrcShift, srcBits - dstBits));
  23172d:	48 c1 ea 20          	shr    rdx,0x20
  231731:	81 e2 00 00 00 80    	and    edx,0x80000000
  231737:	09 ca                	or     edx,ecx
    return @bitCast(dst_t, result);
  231739:	c5 f9 6e c2          	vmovd  xmm0,edx
    return truncXfYf2(f32, f128, a);
  23173d:	c3                   	ret    
            } else if (roundBits == halfway) {
  23173e:	c4 e1 f9 6e c6       	vmovq  xmm0,rsi
  231743:	c4 e1 f9 6e cf       	vmovq  xmm1,rdi
  231748:	e9 10 ff ff ff       	jmp    23165d <__trunctfsf2+0x9d>
  23174d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000231750 <__fixunssfsi>:

    const implicitBit = (rep_t(1) << significandBits);
    const significandMask = (implicitBit - 1);

    // Break a into sign, exponent, significand
    const aRep: rep_t = @bitCast(rep_t, a);
  231750:	c5 f9 7e c1          	vmovd  ecx,xmm0
  231754:	31 c0                	xor    eax,eax
    const absMask = signBit - 1;
    const aAbs: rep_t = aRep & absMask;

    const sign = if ((aRep & signBit) != 0) i32(-1) else i32(1);
  231756:	85 c9                	test   ecx,ecx
    const exponent = @intCast(i32, aAbs >> significandBits) - exponentBias;
    const significand: rep_t = (aAbs & significandMask) | implicitBit;

    // If either the value or the exponent is negative, the result is zero.
    if (sign == -1 or exponent < 0) return 0;
  231758:	78 43                	js     23179d <__fixunssfsi+0x4d>
  23175a:	89 ca                	mov    edx,ecx
  23175c:	c1 ea 17             	shr    edx,0x17
  23175f:	0f b6 f2             	movzx  esi,dl
  231762:	83 fe 7f             	cmp    esi,0x7f
  231765:	72 36                	jb     23179d <__fixunssfsi+0x4d>
    const exponent = @intCast(i32, aAbs >> significandBits) - exponentBias;
  231767:	8d 7e 81             	lea    edi,[rsi-0x7f]
  23176a:	b8 ff ff ff ff       	mov    eax,0xffffffff

    // If the value is too large for the integer type, saturate.
    if (@intCast(c_uint, exponent) >= fixuint_t.bit_count) return ~fixuint_t(0);
  23176f:	83 ff 1f             	cmp    edi,0x1f
  231772:	77 29                	ja     23179d <__fixunssfsi+0x4d>
  231774:	81 e1 ff ff 7f 00    	and    ecx,0x7fffff
  23177a:	81 c9 00 00 80 00    	or     ecx,0x800000

    // If 0 <= exponent < significandBits, right shift to get the result.
    // Otherwise, shift left.
    if (exponent < significandBits) {
  231780:	81 fe 95 00 00 00    	cmp    esi,0x95
  231786:	77 0d                	ja     231795 <__fixunssfsi+0x45>
        return @intCast(fixuint_t, significand >> @intCast(Log2Int(rep_t), significandBits - exponent));
  231788:	b8 16 00 00 00       	mov    eax,0x16
  23178d:	29 d0                	sub    eax,edx
  23178f:	c4 e2 7b f7 c1       	shrx   eax,ecx,eax
const fixuint = @import("fixuint.zig").fixuint;
const builtin = @import("builtin");

pub extern fn __fixunssfsi(a: f32) u32 {
    @setRuntimeSafety(builtin.is_test);
    return fixuint(f32, u32, a);
  231794:	c3                   	ret    
    } else {
        return @intCast(fixuint_t, significand) << @intCast(Log2Int(fixuint_t), exponent - significandBits);
  231795:	83 c2 0a             	add    edx,0xa
  231798:	c4 e2 69 f7 c1       	shlx   eax,ecx,edx
  23179d:	c3                   	ret    
  23179e:	66 90                	xchg   ax,ax

00000000002317a0 <__fixunssfdi>:
    const aRep: rep_t = @bitCast(rep_t, a);
  2317a0:	c5 f9 7e c1          	vmovd  ecx,xmm0
  2317a4:	31 c0                	xor    eax,eax
    const sign = if ((aRep & signBit) != 0) i32(-1) else i32(1);
  2317a6:	85 c9                	test   ecx,ecx
    if (sign == -1 or exponent < 0) return 0;
  2317a8:	78 47                	js     2317f1 <__fixunssfdi+0x51>
  2317aa:	89 ca                	mov    edx,ecx
  2317ac:	c1 ea 17             	shr    edx,0x17
  2317af:	0f b6 f2             	movzx  esi,dl
  2317b2:	83 fe 7f             	cmp    esi,0x7f
  2317b5:	72 3a                	jb     2317f1 <__fixunssfdi+0x51>
    const exponent = @intCast(i32, aAbs >> significandBits) - exponentBias;
  2317b7:	8d 7e 81             	lea    edi,[rsi-0x7f]
  2317ba:	48 c7 c0 ff ff ff ff 	mov    rax,0xffffffffffffffff
    if (@intCast(c_uint, exponent) >= fixuint_t.bit_count) return ~fixuint_t(0);
  2317c1:	83 ff 3f             	cmp    edi,0x3f
  2317c4:	77 2b                	ja     2317f1 <__fixunssfdi+0x51>
  2317c6:	81 e1 ff ff 7f 00    	and    ecx,0x7fffff
  2317cc:	81 c9 00 00 80 00    	or     ecx,0x800000
    if (exponent < significandBits) {
  2317d2:	81 fe 95 00 00 00    	cmp    esi,0x95
  2317d8:	77 0d                	ja     2317e7 <__fixunssfdi+0x47>
        return @intCast(fixuint_t, significand >> @intCast(Log2Int(rep_t), significandBits - exponent));
  2317da:	b8 16 00 00 00       	mov    eax,0x16
  2317df:	29 d0                	sub    eax,edx
  2317e1:	c4 e2 7b f7 c1       	shrx   eax,ecx,eax
const fixuint = @import("fixuint.zig").fixuint;
const builtin = @import("builtin");

pub extern fn __fixunssfdi(a: f32) u64 {
    @setRuntimeSafety(builtin.is_test);
    return fixuint(f32, u64, a);
  2317e6:	c3                   	ret    
        return @intCast(fixuint_t, significand) << @intCast(Log2Int(fixuint_t), exponent - significandBits);
  2317e7:	89 c8                	mov    eax,ecx
  2317e9:	83 c2 2a             	add    edx,0x2a
  2317ec:	c4 e2 e9 f7 c0       	shlx   rax,rax,rdx
  2317f1:	c3                   	ret    
  2317f2:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  2317f9:	1f 84 00 00 00 00 00 

0000000000231800 <__fixunssfti>:
    const aRep: rep_t = @bitCast(rep_t, a);
  231800:	c5 f9 7e c6          	vmovd  esi,xmm0
  231804:	31 d2                	xor    edx,edx
  231806:	b8 00 00 00 00       	mov    eax,0x0
    const sign = if ((aRep & signBit) != 0) i32(-1) else i32(1);
  23180b:	85 f6                	test   esi,esi
    if (sign == -1 or exponent < 0) return 0;
  23180d:	78 68                	js     231877 <__fixunssfti+0x77>
  23180f:	89 f1                	mov    ecx,esi
  231811:	c1 e9 17             	shr    ecx,0x17
  231814:	0f b6 f9             	movzx  edi,cl
  231817:	83 ff 7f             	cmp    edi,0x7f
  23181a:	72 5b                	jb     231877 <__fixunssfti+0x77>
    const exponent = @intCast(i32, aAbs >> significandBits) - exponentBias;
  23181c:	44 8d 47 81          	lea    r8d,[rdi-0x7f]
  231820:	48 c7 c0 ff ff ff ff 	mov    rax,0xffffffffffffffff
  231827:	48 c7 c2 ff ff ff ff 	mov    rdx,0xffffffffffffffff
    if (@intCast(c_uint, exponent) >= fixuint_t.bit_count) return ~fixuint_t(0);
  23182e:	41 83 f8 7f          	cmp    r8d,0x7f
  231832:	77 43                	ja     231877 <__fixunssfti+0x77>
  231834:	81 e6 ff ff 7f 00    	and    esi,0x7fffff
  23183a:	81 ce 00 00 80 00    	or     esi,0x800000
    if (exponent < significandBits) {
  231840:	81 ff 95 00 00 00    	cmp    edi,0x95
  231846:	77 0f                	ja     231857 <__fixunssfti+0x57>
        return @intCast(fixuint_t, significand >> @intCast(Log2Int(rep_t), significandBits - exponent));
  231848:	b8 16 00 00 00       	mov    eax,0x16
  23184d:	29 c8                	sub    eax,ecx
  23184f:	c4 e2 7b f7 c6       	shrx   eax,esi,eax
  231854:	31 d2                	xor    edx,edx
const fixuint = @import("fixuint.zig").fixuint;
const builtin = @import("builtin");

pub extern fn __fixunssfti(a: f32) u128 {
    @setRuntimeSafety(builtin.is_test);
    return fixuint(f32, u128, a);
  231856:	c3                   	ret    
        return @intCast(fixuint_t, significand) << @intCast(Log2Int(fixuint_t), exponent - significandBits);
  231857:	89 f0                	mov    eax,esi
  231859:	83 c1 6a             	add    ecx,0x6a
  23185c:	83 e1 7f             	and    ecx,0x7f
  23185f:	31 d2                	xor    edx,edx
  231861:	48 0f a5 c2          	shld   rdx,rax,cl
  231865:	31 f6                	xor    esi,esi
  231867:	c4 e2 f1 f7 c0       	shlx   rax,rax,rcx
  23186c:	f6 c1 40             	test   cl,0x40
  23186f:	48 0f 45 d0          	cmovne rdx,rax
  231873:	48 0f 45 c6          	cmovne rax,rsi
  231877:	c3                   	ret    
  231878:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  23187f:	00 

0000000000231880 <__fixunsdfsi>:
    const aRep: rep_t = @bitCast(rep_t, a);
  231880:	c4 e1 f9 7e c2       	vmovq  rdx,xmm0
  231885:	31 c0                	xor    eax,eax
    const sign = if ((aRep & signBit) != 0) i32(-1) else i32(1);
  231887:	48 85 d2             	test   rdx,rdx
    if (sign == -1 or exponent < 0) return 0;
  23188a:	78 4b                	js     2318d7 <__fixunsdfsi+0x57>
  23188c:	48 89 d1             	mov    rcx,rdx
  23188f:	48 c1 e9 34          	shr    rcx,0x34
  231893:	89 ce                	mov    esi,ecx
  231895:	81 e6 ff 07 00 00    	and    esi,0x7ff
  23189b:	81 fe ff 03 00 00    	cmp    esi,0x3ff
  2318a1:	72 34                	jb     2318d7 <__fixunsdfsi+0x57>
    const exponent = @intCast(i32, aAbs >> significandBits) - exponentBias;
  2318a3:	81 c6 01 fc ff ff    	add    esi,0xfffffc01
  2318a9:	b8 ff ff ff ff       	mov    eax,0xffffffff
    if (@intCast(c_uint, exponent) >= fixuint_t.bit_count) return ~fixuint_t(0);
  2318ae:	83 fe 1f             	cmp    esi,0x1f
  2318b1:	77 24                	ja     2318d7 <__fixunsdfsi+0x57>
  2318b3:	b0 34                	mov    al,0x34
  2318b5:	c4 e2 f8 f5 c2       	bzhi   rax,rdx,rax
  2318ba:	48 ba ff ff ff ff ff 	movabs rdx,0xfffffffffffff
  2318c1:	ff 0f 00 
  2318c4:	48 83 c2 01          	add    rdx,0x1
  2318c8:	48 09 c2             	or     rdx,rax
        return @intCast(fixuint_t, significand >> @intCast(Log2Int(rep_t), significandBits - exponent));
  2318cb:	b8 33 00 00 00       	mov    eax,0x33
  2318d0:	29 c8                	sub    eax,ecx
  2318d2:	c4 e2 fb f7 c2       	shrx   rax,rdx,rax
const fixuint = @import("fixuint.zig").fixuint;
const builtin = @import("builtin");

pub extern fn __fixunsdfsi(a: f64) u32 {
    @setRuntimeSafety(builtin.is_test);
    return fixuint(f64, u32, a);
  2318d7:	c3                   	ret    
  2318d8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  2318df:	00 

00000000002318e0 <__fixunsdfdi>:
    const aRep: rep_t = @bitCast(rep_t, a);
  2318e0:	c4 e1 f9 7e c2       	vmovq  rdx,xmm0
  2318e5:	31 c0                	xor    eax,eax
    const sign = if ((aRep & signBit) != 0) i32(-1) else i32(1);
  2318e7:	48 85 d2             	test   rdx,rdx
    if (sign == -1 or exponent < 0) return 0;
  2318ea:	78 5e                	js     23194a <__fixunsdfdi+0x6a>
  2318ec:	48 89 d1             	mov    rcx,rdx
  2318ef:	48 c1 e9 34          	shr    rcx,0x34
  2318f3:	89 ce                	mov    esi,ecx
  2318f5:	81 e6 ff 07 00 00    	and    esi,0x7ff
  2318fb:	81 fe ff 03 00 00    	cmp    esi,0x3ff
  231901:	72 47                	jb     23194a <__fixunsdfdi+0x6a>
    const exponent = @intCast(i32, aAbs >> significandBits) - exponentBias;
  231903:	8d be 01 fc ff ff    	lea    edi,[rsi-0x3ff]
  231909:	48 c7 c0 ff ff ff ff 	mov    rax,0xffffffffffffffff
    if (@intCast(c_uint, exponent) >= fixuint_t.bit_count) return ~fixuint_t(0);
  231910:	83 ff 3f             	cmp    edi,0x3f
  231913:	77 35                	ja     23194a <__fixunsdfdi+0x6a>
  231915:	b0 34                	mov    al,0x34
  231917:	c4 e2 f8 f5 d2       	bzhi   rdx,rdx,rax
  23191c:	48 b8 ff ff ff ff ff 	movabs rax,0xfffffffffffff
  231923:	ff 0f 00 
  231926:	48 83 c0 01          	add    rax,0x1
  23192a:	48 09 d0             	or     rax,rdx
    if (exponent < significandBits) {
  23192d:	81 fe 32 04 00 00    	cmp    esi,0x432
  231933:	77 0d                	ja     231942 <__fixunsdfdi+0x62>
        return @intCast(fixuint_t, significand >> @intCast(Log2Int(rep_t), significandBits - exponent));
  231935:	ba 33 00 00 00       	mov    edx,0x33
  23193a:	29 ca                	sub    edx,ecx
  23193c:	c4 e2 eb f7 c0       	shrx   rax,rax,rdx
const fixuint = @import("fixuint.zig").fixuint;
const builtin = @import("builtin");

pub extern fn __fixunsdfdi(a: f64) u64 {
    @setRuntimeSafety(builtin.is_test);
    return fixuint(f64, u64, a);
  231941:	c3                   	ret    
        return @intCast(fixuint_t, significand) << @intCast(Log2Int(fixuint_t), exponent - significandBits);
  231942:	83 c1 0d             	add    ecx,0xd
  231945:	c4 e2 f1 f7 c0       	shlx   rax,rax,rcx
  23194a:	c3                   	ret    
  23194b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000231950 <__fixunsdfti>:
    const aRep: rep_t = @bitCast(rep_t, a);
  231950:	c4 e1 f9 7e c6       	vmovq  rsi,xmm0
  231955:	31 d2                	xor    edx,edx
  231957:	b8 00 00 00 00       	mov    eax,0x0
    const sign = if ((aRep & signBit) != 0) i32(-1) else i32(1);
  23195c:	48 85 f6             	test   rsi,rsi
    if (sign == -1 or exponent < 0) return 0;
  23195f:	78 7f                	js     2319e0 <__fixunsdfti+0x90>
  231961:	48 89 f1             	mov    rcx,rsi
  231964:	48 c1 e9 34          	shr    rcx,0x34
  231968:	89 cf                	mov    edi,ecx
  23196a:	81 e7 ff 07 00 00    	and    edi,0x7ff
  231970:	81 ff ff 03 00 00    	cmp    edi,0x3ff
  231976:	72 68                	jb     2319e0 <__fixunsdfti+0x90>
    const exponent = @intCast(i32, aAbs >> significandBits) - exponentBias;
  231978:	44 8d 87 01 fc ff ff 	lea    r8d,[rdi-0x3ff]
  23197f:	48 c7 c0 ff ff ff ff 	mov    rax,0xffffffffffffffff
  231986:	48 c7 c2 ff ff ff ff 	mov    rdx,0xffffffffffffffff
    if (@intCast(c_uint, exponent) >= fixuint_t.bit_count) return ~fixuint_t(0);
  23198d:	41 83 f8 7f          	cmp    r8d,0x7f
  231991:	77 4d                	ja     2319e0 <__fixunsdfti+0x90>
  231993:	b0 34                	mov    al,0x34
  231995:	c4 e2 f8 f5 d6       	bzhi   rdx,rsi,rax
  23199a:	48 b8 ff ff ff ff ff 	movabs rax,0xfffffffffffff
  2319a1:	ff 0f 00 
  2319a4:	48 83 c0 01          	add    rax,0x1
  2319a8:	48 09 d0             	or     rax,rdx
    if (exponent < significandBits) {
  2319ab:	81 ff 32 04 00 00    	cmp    edi,0x432
  2319b1:	77 0f                	ja     2319c2 <__fixunsdfti+0x72>
        return @intCast(fixuint_t, significand >> @intCast(Log2Int(rep_t), significandBits - exponent));
  2319b3:	ba 33 00 00 00       	mov    edx,0x33
  2319b8:	29 ca                	sub    edx,ecx
  2319ba:	c4 e2 eb f7 c0       	shrx   rax,rax,rdx
  2319bf:	31 d2                	xor    edx,edx
const fixuint = @import("fixuint.zig").fixuint;
const builtin = @import("builtin");

pub extern fn __fixunsdfti(a: f64) u128 {
    @setRuntimeSafety(builtin.is_test);
    return fixuint(f64, u128, a);
  2319c1:	c3                   	ret    
        return @intCast(fixuint_t, significand) << @intCast(Log2Int(fixuint_t), exponent - significandBits);
  2319c2:	8d 49 4d             	lea    ecx,[rcx+0x4d]
  2319c5:	83 e1 7f             	and    ecx,0x7f
  2319c8:	31 d2                	xor    edx,edx
  2319ca:	48 0f a5 c2          	shld   rdx,rax,cl
  2319ce:	31 f6                	xor    esi,esi
  2319d0:	c4 e2 f1 f7 c0       	shlx   rax,rax,rcx
  2319d5:	f6 c1 40             	test   cl,0x40
  2319d8:	48 0f 45 d0          	cmovne rdx,rax
  2319dc:	48 0f 45 c6          	cmovne rax,rsi
  2319e0:	c3                   	ret    
  2319e1:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  2319e8:	0f 1f 84 00 00 00 00 
  2319ef:	00 

00000000002319f0 <__fixunstfsi>:
    const aRep: rep_t = @bitCast(rep_t, a);
  2319f0:	0f 29 44 24 e8       	movaps XMMWORD PTR [rsp-0x18],xmm0
  2319f5:	48 8b 4c 24 f0       	mov    rcx,QWORD PTR [rsp-0x10]
  2319fa:	31 c0                	xor    eax,eax
    const sign = if ((aRep & signBit) != 0) i32(-1) else i32(1);
  2319fc:	48 85 c9             	test   rcx,rcx
    if (sign == -1 or exponent < 0) return 0;
  2319ff:	78 5a                	js     231a5b <__fixunstfsi+0x6b>
  231a01:	48 89 ca             	mov    rdx,rcx
  231a04:	48 c1 ea 30          	shr    rdx,0x30
  231a08:	89 d6                	mov    esi,edx
  231a0a:	81 e6 ff 7f 00 00    	and    esi,0x7fff
  231a10:	81 fe ff 3f 00 00    	cmp    esi,0x3fff
  231a16:	72 43                	jb     231a5b <__fixunstfsi+0x6b>
    const exponent = @intCast(i32, aAbs >> significandBits) - exponentBias;
  231a18:	81 c6 01 c0 ff ff    	add    esi,0xffffc001
  231a1e:	b8 ff ff ff ff       	mov    eax,0xffffffff
    if (@intCast(c_uint, exponent) >= fixuint_t.bit_count) return ~fixuint_t(0);
  231a23:	83 fe 1f             	cmp    esi,0x1f
  231a26:	77 33                	ja     231a5b <__fixunstfsi+0x6b>
  231a28:	48 8b 74 24 e8       	mov    rsi,QWORD PTR [rsp-0x18]
  231a2d:	b0 30                	mov    al,0x30
  231a2f:	c4 e2 f8 f5 c1       	bzhi   rax,rcx,rax
  231a34:	48 bf 00 00 00 00 00 	movabs rdi,0x1000000000000
  231a3b:	00 01 00 
  231a3e:	48 09 c7             	or     rdi,rax
        return @intCast(fixuint_t, significand >> @intCast(Log2Int(rep_t), significandBits - exponent));
  231a41:	b9 6f 00 00 00       	mov    ecx,0x6f
  231a46:	29 d1                	sub    ecx,edx
  231a48:	83 e1 7f             	and    ecx,0x7f
  231a4b:	48 0f ad fe          	shrd   rsi,rdi,cl
  231a4f:	c4 e2 f3 f7 c7       	shrx   rax,rdi,rcx
  231a54:	f6 c1 40             	test   cl,0x40
  231a57:	48 0f 44 c6          	cmove  rax,rsi
const fixuint = @import("fixuint.zig").fixuint;
const builtin = @import("builtin");

pub extern fn __fixunstfsi(a: f128) u32 {
    @setRuntimeSafety(builtin.is_test);
    return fixuint(f128, u32, a);
  231a5b:	c3                   	ret    
  231a5c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

0000000000231a60 <__fixunstfdi>:
    const aRep: rep_t = @bitCast(rep_t, a);
  231a60:	0f 29 44 24 e8       	movaps XMMWORD PTR [rsp-0x18],xmm0
  231a65:	48 8b 4c 24 f0       	mov    rcx,QWORD PTR [rsp-0x10]
  231a6a:	31 c0                	xor    eax,eax
    const sign = if ((aRep & signBit) != 0) i32(-1) else i32(1);
  231a6c:	48 85 c9             	test   rcx,rcx
    if (sign == -1 or exponent < 0) return 0;
  231a6f:	78 5c                	js     231acd <__fixunstfdi+0x6d>
  231a71:	48 89 ca             	mov    rdx,rcx
  231a74:	48 c1 ea 30          	shr    rdx,0x30
  231a78:	89 d6                	mov    esi,edx
  231a7a:	81 e6 ff 7f 00 00    	and    esi,0x7fff
  231a80:	81 fe ff 3f 00 00    	cmp    esi,0x3fff
  231a86:	72 45                	jb     231acd <__fixunstfdi+0x6d>
    const exponent = @intCast(i32, aAbs >> significandBits) - exponentBias;
  231a88:	81 c6 01 c0 ff ff    	add    esi,0xffffc001
  231a8e:	48 c7 c0 ff ff ff ff 	mov    rax,0xffffffffffffffff
    if (@intCast(c_uint, exponent) >= fixuint_t.bit_count) return ~fixuint_t(0);
  231a95:	83 fe 3f             	cmp    esi,0x3f
  231a98:	77 33                	ja     231acd <__fixunstfdi+0x6d>
  231a9a:	48 8b 74 24 e8       	mov    rsi,QWORD PTR [rsp-0x18]
  231a9f:	b0 30                	mov    al,0x30
  231aa1:	c4 e2 f8 f5 c1       	bzhi   rax,rcx,rax
  231aa6:	48 bf 00 00 00 00 00 	movabs rdi,0x1000000000000
  231aad:	00 01 00 
  231ab0:	48 09 c7             	or     rdi,rax
        return @intCast(fixuint_t, significand >> @intCast(Log2Int(rep_t), significandBits - exponent));
  231ab3:	b9 6f 00 00 00       	mov    ecx,0x6f
  231ab8:	29 d1                	sub    ecx,edx
  231aba:	83 e1 7f             	and    ecx,0x7f
  231abd:	48 0f ad fe          	shrd   rsi,rdi,cl
  231ac1:	c4 e2 f3 f7 c7       	shrx   rax,rdi,rcx
  231ac6:	f6 c1 40             	test   cl,0x40
  231ac9:	48 0f 44 c6          	cmove  rax,rsi
const fixuint = @import("fixuint.zig").fixuint;
const builtin = @import("builtin");

pub extern fn __fixunstfdi(a: f128) u64 {
    @setRuntimeSafety(builtin.is_test);
    return fixuint(f128, u64, a);
  231acd:	c3                   	ret    
  231ace:	66 90                	xchg   ax,ax

0000000000231ad0 <__fixunstfti>:
    const aRep: rep_t = @bitCast(rep_t, a);
  231ad0:	0f 29 44 24 e8       	movaps XMMWORD PTR [rsp-0x18],xmm0
  231ad5:	48 8b 74 24 f0       	mov    rsi,QWORD PTR [rsp-0x10]
  231ada:	31 d2                	xor    edx,edx
  231adc:	b8 00 00 00 00       	mov    eax,0x0
    const sign = if ((aRep & signBit) != 0) i32(-1) else i32(1);
  231ae1:	48 85 f6             	test   rsi,rsi
    if (sign == -1 or exponent < 0) return 0;
  231ae4:	0f 88 93 00 00 00    	js     231b7d <__fixunstfti+0xad>
  231aea:	48 89 f1             	mov    rcx,rsi
  231aed:	48 c1 e9 30          	shr    rcx,0x30
  231af1:	89 cf                	mov    edi,ecx
  231af3:	81 e7 ff 7f 00 00    	and    edi,0x7fff
  231af9:	81 ff ff 3f 00 00    	cmp    edi,0x3fff
  231aff:	72 7c                	jb     231b7d <__fixunstfti+0xad>
    const exponent = @intCast(i32, aAbs >> significandBits) - exponentBias;
  231b01:	44 8d 87 01 c0 ff ff 	lea    r8d,[rdi-0x3fff]
  231b08:	48 c7 c0 ff ff ff ff 	mov    rax,0xffffffffffffffff
  231b0f:	48 c7 c2 ff ff ff ff 	mov    rdx,0xffffffffffffffff
    if (@intCast(c_uint, exponent) >= fixuint_t.bit_count) return ~fixuint_t(0);
  231b16:	41 83 f8 7f          	cmp    r8d,0x7f
  231b1a:	77 61                	ja     231b7d <__fixunstfti+0xad>
  231b1c:	48 8b 44 24 e8       	mov    rax,QWORD PTR [rsp-0x18]
  231b21:	b2 30                	mov    dl,0x30
  231b23:	c4 e2 e8 f5 f6       	bzhi   rsi,rsi,rdx
  231b28:	48 ba 00 00 00 00 00 	movabs rdx,0x1000000000000
  231b2f:	00 01 00 
  231b32:	48 09 f2             	or     rdx,rsi
    if (exponent < significandBits) {
  231b35:	81 ff 6e 40 00 00    	cmp    edi,0x406e
  231b3b:	77 24                	ja     231b61 <__fixunstfti+0x91>
        return @intCast(fixuint_t, significand >> @intCast(Log2Int(rep_t), significandBits - exponent));
  231b3d:	be 6f 00 00 00       	mov    esi,0x6f
  231b42:	29 ce                	sub    esi,ecx
  231b44:	83 e6 7f             	and    esi,0x7f
  231b47:	89 f1                	mov    ecx,esi
  231b49:	48 0f ad d0          	shrd   rax,rdx,cl
  231b4d:	c4 e2 cb f7 ca       	shrx   rcx,rdx,rsi
  231b52:	31 d2                	xor    edx,edx
  231b54:	40 f6 c6 40          	test   sil,0x40
  231b58:	48 0f 45 c1          	cmovne rax,rcx
  231b5c:	48 0f 44 d1          	cmove  rdx,rcx
const fixuint = @import("fixuint.zig").fixuint;
const builtin = @import("builtin");

pub extern fn __fixunstfti(a: f128) u128 {
    @setRuntimeSafety(builtin.is_test);
    return fixuint(f128, u128, a);
  231b60:	c3                   	ret    
        return @intCast(fixuint_t, significand) << @intCast(Log2Int(fixuint_t), exponent - significandBits);
  231b61:	83 c1 11             	add    ecx,0x11
  231b64:	83 e1 7f             	and    ecx,0x7f
  231b67:	48 0f a5 c2          	shld   rdx,rax,cl
  231b6b:	c4 e2 f1 f7 f0       	shlx   rsi,rax,rcx
  231b70:	31 c0                	xor    eax,eax
  231b72:	f6 c1 40             	test   cl,0x40
  231b75:	48 0f 45 d6          	cmovne rdx,rsi
  231b79:	48 0f 44 c6          	cmove  rax,rsi
  231b7d:	c3                   	ret    
  231b7e:	66 90                	xchg   ax,ax

0000000000231b80 <__udivsi3>:
    const d = __udivsi3(a, b);
    rem.* = @bitCast(u32, @bitCast(i32, a) -% (@bitCast(i32, d) * @bitCast(i32, b)));
    return d;
}

extern fn __udivsi3(n: u32, d: u32) u32 {
  231b80:	55                   	push   rbp
  231b81:	41 56                	push   r14
  231b83:	53                   	push   rbx
  231b84:	31 c0                	xor    eax,eax
    @setRuntimeSafety(is_test);

    const n_uword_bits: c_uint = u32.bit_count;
    // special cases
    if (d == 0) return 0; // ?!
    if (n == 0) return 0;
  231b86:	85 ff                	test   edi,edi
    if (d == 0) return 0; // ?!
  231b88:	74 19                	je     231ba3 <__udivsi3+0x23>
  231b8a:	85 f6                	test   esi,esi
  231b8c:	74 15                	je     231ba3 <__udivsi3+0x23>
    var sr = @bitCast(c_uint, c_int(@clz(d)) - c_int(@clz(n)));
  231b8e:	f3 0f bd ce          	lzcnt  ecx,esi
  231b92:	f3 0f bd d7          	lzcnt  edx,edi
  231b96:	89 cb                	mov    ebx,ecx
  231b98:	29 d3                	sub    ebx,edx
    // 0 <= sr <= n_uword_bits - 1 or sr large
    if (sr > n_uword_bits - 1) {
  231b9a:	83 fb 1f             	cmp    ebx,0x1f
  231b9d:	77 04                	ja     231ba3 <__udivsi3+0x23>
        // d > r
        return 0;
    }
    if (sr == n_uword_bits - 1) {
  231b9f:	75 07                	jne    231ba8 <__udivsi3+0x28>
  231ba1:	89 f8                	mov    eax,edi
  231ba3:	5b                   	pop    rbx
  231ba4:	41 5e                	pop    r14
  231ba6:	5d                   	pop    rbp
  231ba7:	c3                   	ret    
        // d == 1
        return n;
    }
    sr += 1;
  231ba8:	44 8d 4b 01          	lea    r9d,[rbx+0x1]
    // 1 <= sr <= n_uword_bits - 1
    // Not a special case
    var q: u32 = n << @intCast(u5, n_uword_bits - sr);
  231bac:	b8 1f 00 00 00       	mov    eax,0x1f
  231bb1:	29 d8                	sub    eax,ebx
  231bb3:	c4 e2 79 f7 c7       	shlx   eax,edi,eax
    var r: u32 = n >> @intCast(u5, sr);
  231bb8:	c4 e2 33 f7 ff       	shrx   edi,edi,r9d
  231bbd:	44 8d 46 ff          	lea    r8d,[rsi-0x1]
    var carry: u32 = 0;
    while (sr > 0) : (sr -= 1) {
  231bc1:	41 83 e1 03          	and    r9d,0x3
  231bc5:	83 fb 03             	cmp    ebx,0x3
  231bc8:	73 10                	jae    231bda <__udivsi3+0x5a>
  231bca:	31 c9                	xor    ecx,ecx
  231bcc:	45 85 c9             	test   r9d,r9d
  231bcf:	0f 85 a6 00 00 00    	jne    231c7b <__udivsi3+0xfb>
  231bd5:	e9 c5 00 00 00       	jmp    231c9f <__udivsi3+0x11f>
  231bda:	42 8d 14 0a          	lea    edx,[rdx+r9*1]
  231bde:	83 c2 ff             	add    edx,0xffffffff
  231be1:	29 ca                	sub    edx,ecx
  231be3:	31 c9                	xor    ecx,ecx
  231be5:	41 ba 1e 01 00 00    	mov    r10d,0x11e
  231beb:	41 bb 1d 01 00 00    	mov    r11d,0x11d
  231bf1:	41 be 1c 01 00 00    	mov    r14d,0x11c
  231bf7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  231bfe:	00 00 
        // r:q = ((r:q)  << 1) | carry
        r = (r << 1) | (q >> @intCast(u5, n_uword_bits - 1));
  231c00:	0f a4 c7 01          	shld   edi,eax,0x1
        q = (q << 1) | carry;
  231c04:	8d 1c 00             	lea    ebx,[rax+rax*1]
  231c07:	09 cb                	or     ebx,ecx
        // if (r.all >= d.all)
        // {
        //      r.all -= d.all;
        //      carry = 1;
        // }
        const s = @intCast(i32, d -% r -% 1) >> @intCast(u5, n_uword_bits - 1);
  231c09:	44 89 c1             	mov    ecx,r8d
  231c0c:	29 f9                	sub    ecx,edi
  231c0e:	c1 f9 1f             	sar    ecx,0x1f
        carry = @intCast(u32, s & 1);
  231c11:	89 cd                	mov    ebp,ecx
  231c13:	83 e5 01             	and    ebp,0x1
        r -= d & @bitCast(u32, s);
  231c16:	21 f1                	and    ecx,esi
  231c18:	29 cf                	sub    edi,ecx
        r = (r << 1) | (q >> @intCast(u5, n_uword_bits - 1));
  231c1a:	c4 e2 28 f7 c8       	bextr  ecx,eax,r10d
  231c1f:	8d 0c 79             	lea    ecx,[rcx+rdi*2]
        q = (q << 1) | carry;
  231c22:	8d 7c 5d 00          	lea    edi,[rbp+rbx*2+0x0]
        const s = @intCast(i32, d -% r -% 1) >> @intCast(u5, n_uword_bits - 1);
  231c26:	44 89 c3             	mov    ebx,r8d
  231c29:	29 cb                	sub    ebx,ecx
  231c2b:	c1 fb 1f             	sar    ebx,0x1f
        carry = @intCast(u32, s & 1);
  231c2e:	89 dd                	mov    ebp,ebx
  231c30:	83 e5 01             	and    ebp,0x1
        r -= d & @bitCast(u32, s);
  231c33:	21 f3                	and    ebx,esi
  231c35:	29 d9                	sub    ecx,ebx
        r = (r << 1) | (q >> @intCast(u5, n_uword_bits - 1));
  231c37:	c4 e2 20 f7 d8       	bextr  ebx,eax,r11d
  231c3c:	8d 0c 4b             	lea    ecx,[rbx+rcx*2]
        q = (q << 1) | carry;
  231c3f:	8d 5c 7d 00          	lea    ebx,[rbp+rdi*2+0x0]
        const s = @intCast(i32, d -% r -% 1) >> @intCast(u5, n_uword_bits - 1);
  231c43:	44 89 c7             	mov    edi,r8d
  231c46:	29 cf                	sub    edi,ecx
  231c48:	c1 ff 1f             	sar    edi,0x1f
        carry = @intCast(u32, s & 1);
  231c4b:	89 fd                	mov    ebp,edi
  231c4d:	83 e5 01             	and    ebp,0x1
        r -= d & @bitCast(u32, s);
  231c50:	21 f7                	and    edi,esi
  231c52:	29 f9                	sub    ecx,edi
        r = (r << 1) | (q >> @intCast(u5, n_uword_bits - 1));
  231c54:	c4 e2 08 f7 c0       	bextr  eax,eax,r14d
  231c59:	8d 3c 48             	lea    edi,[rax+rcx*2]
        q = (q << 1) | carry;
  231c5c:	8d 44 5d 00          	lea    eax,[rbp+rbx*2+0x0]
        const s = @intCast(i32, d -% r -% 1) >> @intCast(u5, n_uword_bits - 1);
  231c60:	44 89 c3             	mov    ebx,r8d
  231c63:	29 fb                	sub    ebx,edi
  231c65:	c1 fb 1f             	sar    ebx,0x1f
        carry = @intCast(u32, s & 1);
  231c68:	89 d9                	mov    ecx,ebx
  231c6a:	83 e1 01             	and    ecx,0x1
        r -= d & @bitCast(u32, s);
  231c6d:	21 f3                	and    ebx,esi
  231c6f:	29 df                	sub    edi,ebx
    while (sr > 0) : (sr -= 1) {
  231c71:	83 c2 04             	add    edx,0x4
  231c74:	75 8a                	jne    231c00 <__udivsi3+0x80>
  231c76:	45 85 c9             	test   r9d,r9d
  231c79:	74 24                	je     231c9f <__udivsi3+0x11f>
  231c7b:	41 f7 d9             	neg    r9d
  231c7e:	66 90                	xchg   ax,ax
        r = (r << 1) | (q >> @intCast(u5, n_uword_bits - 1));
  231c80:	0f a4 c7 01          	shld   edi,eax,0x1
        q = (q << 1) | carry;
  231c84:	01 c0                	add    eax,eax
  231c86:	09 c8                	or     eax,ecx
        const s = @intCast(i32, d -% r -% 1) >> @intCast(u5, n_uword_bits - 1);
  231c88:	44 89 c2             	mov    edx,r8d
  231c8b:	29 fa                	sub    edx,edi
  231c8d:	c1 fa 1f             	sar    edx,0x1f
        carry = @intCast(u32, s & 1);
  231c90:	89 d1                	mov    ecx,edx
  231c92:	83 e1 01             	and    ecx,0x1
        r -= d & @bitCast(u32, s);
  231c95:	21 f2                	and    edx,esi
  231c97:	29 d7                	sub    edi,edx
    while (sr > 0) : (sr -= 1) {
  231c99:	41 83 c1 01          	add    r9d,0x1
  231c9d:	75 e1                	jne    231c80 <__udivsi3+0x100>
    }
    q = (q << 1) | carry;
  231c9f:	01 c0                	add    eax,eax
  231ca1:	09 c8                	or     eax,ecx
  231ca3:	5b                   	pop    rbx
  231ca4:	41 5e                	pop    r14
  231ca6:	5d                   	pop    rbp
  231ca7:	c3                   	ret    
  231ca8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  231caf:	00 

0000000000231cb0 <__udivdi3>:
    return __udivmoddi4(a, b, null);
  231cb0:	31 d2                	xor    edx,edx
  231cb2:	e9 a9 e6 ff ff       	jmp    230360 <__udivmoddi4>
  231cb7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  231cbe:	00 00 

0000000000231cc0 <__umoddi3>:
extern fn __umoddi3(a: u64, b: u64) u64 {
  231cc0:	50                   	push   rax
  231cc1:	48 89 e2             	mov    rdx,rsp
    _ = __udivmoddi4(a, b, &r);
  231cc4:	e8 97 e6 ff ff       	call   230360 <__udivmoddi4>
    return r;
  231cc9:	48 8b 04 24          	mov    rax,QWORD PTR [rsp]
  231ccd:	59                   	pop    rcx
  231cce:	c3                   	ret    
  231ccf:	90                   	nop

0000000000231cd0 <__udivmodsi4>:
extern fn __udivmodsi4(a: u32, b: u32, rem: *u32) u32 {
  231cd0:	55                   	push   rbp
  231cd1:	41 57                	push   r15
  231cd3:	41 56                	push   r14
  231cd5:	41 55                	push   r13
  231cd7:	41 54                	push   r12
  231cd9:	53                   	push   rbx
  231cda:	31 c0                	xor    eax,eax
    if (n == 0) return 0;
  231cdc:	85 ff                	test   edi,edi
    if (d == 0) return 0; // ?!
  231cde:	0f 84 33 01 00 00    	je     231e17 <__udivmodsi4+0x147>
  231ce4:	85 f6                	test   esi,esi
  231ce6:	0f 84 2b 01 00 00    	je     231e17 <__udivmodsi4+0x147>
    var sr = @bitCast(c_uint, c_int(@clz(d)) - c_int(@clz(n)));
  231cec:	f3 44 0f bd de       	lzcnt  r11d,esi
  231cf1:	f3 0f bd df          	lzcnt  ebx,edi
  231cf5:	44 89 dd             	mov    ebp,r11d
  231cf8:	29 dd                	sub    ebp,ebx
    if (sr > n_uword_bits - 1) {
  231cfa:	83 fd 1f             	cmp    ebp,0x1f
  231cfd:	0f 87 14 01 00 00    	ja     231e17 <__udivmodsi4+0x147>
  231d03:	89 f8                	mov    eax,edi
    if (sr == n_uword_bits - 1) {
  231d05:	0f 84 0c 01 00 00    	je     231e17 <__udivmodsi4+0x147>
    sr += 1;
  231d0b:	44 8d 4d 01          	lea    r9d,[rbp+0x1]
    var q: u32 = n << @intCast(u5, n_uword_bits - sr);
  231d0f:	b8 1f 00 00 00       	mov    eax,0x1f
  231d14:	29 e8                	sub    eax,ebp
  231d16:	c4 e2 79 f7 c7       	shlx   eax,edi,eax
    var r: u32 = n >> @intCast(u5, sr);
  231d1b:	c4 e2 33 f7 cf       	shrx   ecx,edi,r9d
  231d20:	44 8d 46 ff          	lea    r8d,[rsi-0x1]
    while (sr > 0) : (sr -= 1) {
  231d24:	41 83 e1 03          	and    r9d,0x3
  231d28:	83 fd 03             	cmp    ebp,0x3
  231d2b:	73 11                	jae    231d3e <__udivmodsi4+0x6e>
  231d2d:	45 31 db             	xor    r11d,r11d
  231d30:	45 85 c9             	test   r9d,r9d
  231d33:	0f 85 aa 00 00 00    	jne    231de3 <__udivmodsi4+0x113>
  231d39:	e9 d4 00 00 00       	jmp    231e12 <__udivmodsi4+0x142>
  231d3e:	46 8d 14 0b          	lea    r10d,[rbx+r9*1]
  231d42:	41 83 c2 ff          	add    r10d,0xffffffff
  231d46:	45 29 da             	sub    r10d,r11d
  231d49:	45 31 db             	xor    r11d,r11d
  231d4c:	41 be 1e 01 00 00    	mov    r14d,0x11e
  231d52:	41 bf 1d 01 00 00    	mov    r15d,0x11d
  231d58:	41 bc 1c 01 00 00    	mov    r12d,0x11c
  231d5e:	66 90                	xchg   ax,ax
        r = (r << 1) | (q >> @intCast(u5, n_uword_bits - 1));
  231d60:	0f a4 c1 01          	shld   ecx,eax,0x1
        q = (q << 1) | carry;
  231d64:	44 8d 2c 00          	lea    r13d,[rax+rax*1]
  231d68:	45 09 dd             	or     r13d,r11d
        const s = @intCast(i32, d -% r -% 1) >> @intCast(u5, n_uword_bits - 1);
  231d6b:	44 89 c3             	mov    ebx,r8d
  231d6e:	29 cb                	sub    ebx,ecx
  231d70:	c1 fb 1f             	sar    ebx,0x1f
        carry = @intCast(u32, s & 1);
  231d73:	89 dd                	mov    ebp,ebx
  231d75:	83 e5 01             	and    ebp,0x1
        r -= d & @bitCast(u32, s);
  231d78:	21 f3                	and    ebx,esi
  231d7a:	29 d9                	sub    ecx,ebx
        r = (r << 1) | (q >> @intCast(u5, n_uword_bits - 1));
  231d7c:	c4 e2 08 f7 d8       	bextr  ebx,eax,r14d
  231d81:	8d 0c 4b             	lea    ecx,[rbx+rcx*2]
        q = (q << 1) | carry;
  231d84:	46 8d 5c 6d 00       	lea    r11d,[rbp+r13*2+0x0]
        const s = @intCast(i32, d -% r -% 1) >> @intCast(u5, n_uword_bits - 1);
  231d89:	44 89 c3             	mov    ebx,r8d
  231d8c:	29 cb                	sub    ebx,ecx
  231d8e:	c1 fb 1f             	sar    ebx,0x1f
        carry = @intCast(u32, s & 1);
  231d91:	89 dd                	mov    ebp,ebx
  231d93:	83 e5 01             	and    ebp,0x1
        r -= d & @bitCast(u32, s);
  231d96:	21 f3                	and    ebx,esi
  231d98:	29 d9                	sub    ecx,ebx
        r = (r << 1) | (q >> @intCast(u5, n_uword_bits - 1));
  231d9a:	c4 e2 00 f7 d8       	bextr  ebx,eax,r15d
  231d9f:	8d 0c 4b             	lea    ecx,[rbx+rcx*2]
        q = (q << 1) | carry;
  231da2:	46 8d 5c 5d 00       	lea    r11d,[rbp+r11*2+0x0]
        const s = @intCast(i32, d -% r -% 1) >> @intCast(u5, n_uword_bits - 1);
  231da7:	44 89 c3             	mov    ebx,r8d
  231daa:	29 cb                	sub    ebx,ecx
  231dac:	c1 fb 1f             	sar    ebx,0x1f
        carry = @intCast(u32, s & 1);
  231daf:	89 dd                	mov    ebp,ebx
  231db1:	83 e5 01             	and    ebp,0x1
        r -= d & @bitCast(u32, s);
  231db4:	21 f3                	and    ebx,esi
  231db6:	29 d9                	sub    ecx,ebx
        r = (r << 1) | (q >> @intCast(u5, n_uword_bits - 1));
  231db8:	c4 e2 18 f7 c0       	bextr  eax,eax,r12d
  231dbd:	8d 0c 48             	lea    ecx,[rax+rcx*2]
        q = (q << 1) | carry;
  231dc0:	42 8d 44 5d 00       	lea    eax,[rbp+r11*2+0x0]
        const s = @intCast(i32, d -% r -% 1) >> @intCast(u5, n_uword_bits - 1);
  231dc5:	44 89 c3             	mov    ebx,r8d
  231dc8:	29 cb                	sub    ebx,ecx
  231dca:	c1 fb 1f             	sar    ebx,0x1f
        carry = @intCast(u32, s & 1);
  231dcd:	41 89 db             	mov    r11d,ebx
  231dd0:	41 83 e3 01          	and    r11d,0x1
        r -= d & @bitCast(u32, s);
  231dd4:	21 f3                	and    ebx,esi
  231dd6:	29 d9                	sub    ecx,ebx
    while (sr > 0) : (sr -= 1) {
  231dd8:	41 83 c2 04          	add    r10d,0x4
  231ddc:	75 82                	jne    231d60 <__udivmodsi4+0x90>
  231dde:	45 85 c9             	test   r9d,r9d
  231de1:	74 2f                	je     231e12 <__udivmodsi4+0x142>
  231de3:	41 f7 d9             	neg    r9d
  231de6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  231ded:	00 00 00 
        r = (r << 1) | (q >> @intCast(u5, n_uword_bits - 1));
  231df0:	0f a4 c1 01          	shld   ecx,eax,0x1
        q = (q << 1) | carry;
  231df4:	01 c0                	add    eax,eax
  231df6:	44 09 d8             	or     eax,r11d
        const s = @intCast(i32, d -% r -% 1) >> @intCast(u5, n_uword_bits - 1);
  231df9:	44 89 c5             	mov    ebp,r8d
  231dfc:	29 cd                	sub    ebp,ecx
  231dfe:	c1 fd 1f             	sar    ebp,0x1f
        carry = @intCast(u32, s & 1);
  231e01:	41 89 eb             	mov    r11d,ebp
  231e04:	41 83 e3 01          	and    r11d,0x1
        r -= d & @bitCast(u32, s);
  231e08:	21 f5                	and    ebp,esi
  231e0a:	29 e9                	sub    ecx,ebp
    while (sr > 0) : (sr -= 1) {
  231e0c:	41 83 c1 01          	add    r9d,0x1
  231e10:	75 de                	jne    231df0 <__udivmodsi4+0x120>
    q = (q << 1) | carry;
  231e12:	01 c0                	add    eax,eax
  231e14:	44 09 d8             	or     eax,r11d
    rem.* = @bitCast(u32, @bitCast(i32, a) -% (@bitCast(i32, d) * @bitCast(i32, b)));
  231e17:	0f af f0             	imul   esi,eax
  231e1a:	29 f7                	sub    edi,esi
  231e1c:	89 3a                	mov    DWORD PTR [rdx],edi
    return d;
  231e1e:	5b                   	pop    rbx
  231e1f:	41 5c                	pop    r12
  231e21:	41 5d                	pop    r13
  231e23:	41 5e                	pop    r14
  231e25:	41 5f                	pop    r15
  231e27:	5d                   	pop    rbp
  231e28:	c3                   	ret    
  231e29:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

0000000000231e30 <__divti3>:
const compiler_rt = @import("index.zig");

pub extern fn __divti3(a: i128, b: i128) i128 {
    @setRuntimeSafety(builtin.is_test);

    const s_a = a >> (i128.bit_count - 1);
  231e30:	41 56                	push   r14
  231e32:	53                   	push   rbx
  231e33:	50                   	push   rax
  231e34:	48 89 f0             	mov    rax,rsi
  231e37:	48 c1 f8 3f          	sar    rax,0x3f
    const s_b = b >> (i128.bit_count - 1);
  231e3b:	49 89 ce             	mov    r14,rcx
  231e3e:	49 31 f6             	xor    r14,rsi
  231e41:	48 89 cb             	mov    rbx,rcx
  231e44:	48 c1 fb 3f          	sar    rbx,0x3f

    const an = (a ^ s_a) -% s_a;
  231e48:	48 31 c6             	xor    rsi,rax
  231e4b:	48 31 c7             	xor    rdi,rax
  231e4e:	48 29 c7             	sub    rdi,rax
  231e51:	48 19 c6             	sbb    rsi,rax
    const bn = (b ^ s_b) -% s_b;
  231e54:	48 31 d9             	xor    rcx,rbx
  231e57:	48 31 da             	xor    rdx,rbx
  231e5a:	48 29 da             	sub    rdx,rbx
  231e5d:	48 19 d9             	sbb    rcx,rbx

    const r = udivmod(u128, @bitCast(u128, an), @bitCast(u128, bn), null);
  231e60:	45 31 c0             	xor    r8d,r8d
  231e63:	e8 18 00 00 00       	call   231e80 <udivmod.14>
    const s = s_a ^ s_b;
  231e68:	49 c1 fe 3f          	sar    r14,0x3f
    return (@bitCast(i128, r) ^ s) -% s;
  231e6c:	4c 31 f2             	xor    rdx,r14
  231e6f:	4c 31 f0             	xor    rax,r14
  231e72:	4c 29 f0             	sub    rax,r14
  231e75:	4c 19 f2             	sbb    rdx,r14
  231e78:	48 83 c4 08          	add    rsp,0x8
  231e7c:	5b                   	pop    rbx
  231e7d:	41 5e                	pop    r14
  231e7f:	c3                   	ret    

0000000000231e80 <udivmod.14>:
pub fn udivmod(comptime DoubleInt: type, a: DoubleInt, b: DoubleInt, maybe_rem: ?*DoubleInt) DoubleInt {
  231e80:	55                   	push   rbp
  231e81:	41 57                	push   r15
  231e83:	41 56                	push   r14
  231e85:	41 55                	push   r13
  231e87:	41 54                	push   r12
  231e89:	53                   	push   rbx
  231e8a:	49 89 d1             	mov    r9,rdx
    if (n[high] == 0) {
  231e8d:	48 85 f6             	test   rsi,rsi
  231e90:	74 38                	je     231eca <udivmod.14+0x4a>
    if (d[low] == 0) {
  231e92:	4d 85 c9             	test   r9,r9
  231e95:	74 55                	je     231eec <udivmod.14+0x6c>
  231e97:	48 85 c9             	test   rcx,rcx
        if (d[high] == 0) {
  231e9a:	0f 84 af 00 00 00    	je     231f4f <udivmod.14+0xcf>
            sr = @bitCast(c_uint, c_int(@clz(d[high])) - c_int(@clz(n[high])));
  231ea0:	f3 48 0f bd c1       	lzcnt  rax,rcx
  231ea5:	f3 48 0f bd d6       	lzcnt  rdx,rsi
  231eaa:	29 d0                	sub    eax,edx
            if (sr > SingleInt.bit_count - 1) {
  231eac:	83 f8 40             	cmp    eax,0x40
  231eaf:	0f 82 23 01 00 00    	jb     231fd8 <udivmod.14+0x158>
  231eb5:	4d 85 c0             	test   r8,r8
  231eb8:	0f 84 3f 01 00 00    	je     231ffd <udivmod.14+0x17d>
  231ebe:	49 89 38             	mov    QWORD PTR [r8],rdi
  231ec1:	49 89 70 08          	mov    QWORD PTR [r8+0x8],rsi
  231ec5:	e9 33 01 00 00       	jmp    231ffd <udivmod.14+0x17d>
        if (d[high] == 0) {
  231eca:	48 85 c9             	test   rcx,rcx
  231ecd:	0f 84 df 00 00 00    	je     231fb2 <udivmod.14+0x132>
  231ed3:	4d 85 c0             	test   r8,r8
        if (maybe_rem) |rem| {
  231ed6:	0f 84 21 01 00 00    	je     231ffd <udivmod.14+0x17d>
            rem.* = n[low];
  231edc:	49 89 38             	mov    QWORD PTR [r8],rdi
  231edf:	49 c7 40 08 00 00 00 	mov    QWORD PTR [r8+0x8],0x0
  231ee6:	00 
  231ee7:	e9 11 01 00 00       	jmp    231ffd <udivmod.14+0x17d>
  231eec:	48 85 c9             	test   rcx,rcx
        if (d[high] == 0) {
  231eef:	0f 84 fa 00 00 00    	je     231fef <udivmod.14+0x16f>
        if (n[low] == 0) {
  231ef5:	48 85 ff             	test   rdi,rdi
  231ef8:	0f 84 6e 02 00 00    	je     23216c <udivmod.14+0x2ec>
        if ((d[high] & (d[high] - 1)) == 0) {
  231efe:	48 8d 41 ff          	lea    rax,[rcx-0x1]
  231f02:	48 85 c8             	test   rax,rcx
  231f05:	0f 84 c3 02 00 00    	je     2321ce <udivmod.14+0x34e>
        sr = @bitCast(c_uint, c_int(@clz(d[high])) - c_int(@clz(n[high])));
  231f0b:	f3 4c 0f bd d1       	lzcnt  r10,rcx
  231f10:	f3 48 0f bd c6       	lzcnt  rax,rsi
  231f15:	41 29 c2             	sub    r10d,eax
        if (sr > SingleInt.bit_count - 2) {
  231f18:	41 83 fa 3f          	cmp    r10d,0x3f
  231f1c:	73 97                	jae    231eb5 <udivmod.14+0x35>
        q[high] = n[low] << @intCast(Log2SingleInt, SingleInt.bit_count - sr);
  231f1e:	b8 3f 00 00 00       	mov    eax,0x3f
  231f23:	44 29 d0             	sub    eax,r10d
        sr += 1;
  231f26:	41 83 c2 01          	add    r10d,0x1
        q[high] = n[low] << @intCast(Log2SingleInt, SingleInt.bit_count - sr);
  231f2a:	83 e0 3f             	and    eax,0x3f
        r[high] = n[high] >> @intCast(Log2SingleInt, sr);
  231f2d:	44 89 d5             	mov    ebp,r10d
  231f30:	83 e5 3f             	and    ebp,0x3f
  231f33:	c4 e2 d3 f7 d6       	shrx   rdx,rsi,rbp
        r[low] = (n[high] << @intCast(Log2SingleInt, SingleInt.bit_count - sr)) | (n[low] >> @intCast(Log2SingleInt, sr));
  231f38:	c4 e2 f9 f7 de       	shlx   rbx,rsi,rax
  231f3d:	c4 e2 d3 f7 f7       	shrx   rsi,rdi,rbp
        q[high] = n[low] << @intCast(Log2SingleInt, SingleInt.bit_count - sr);
  231f42:	c4 e2 f9 f7 ff       	shlx   rdi,rdi,rax
        r[low] = (n[high] << @intCast(Log2SingleInt, SingleInt.bit_count - sr)) | (n[low] >> @intCast(Log2SingleInt, sr));
  231f47:	48 09 de             	or     rsi,rbx
  231f4a:	e9 de 00 00 00       	jmp    23202d <udivmod.14+0x1ad>
            if ((d[low] & (d[low] - 1)) == 0) {
  231f4f:	49 8d 41 ff          	lea    rax,[r9-0x1]
  231f53:	4c 85 c8             	test   rax,r9
  231f56:	0f 84 36 02 00 00    	je     232192 <udivmod.14+0x312>
            sr = 1 + SingleInt.bit_count + c_uint(@clz(d[low])) - c_uint(@clz(n[high]));
  231f5c:	f3 4d 0f bd d1       	lzcnt  r10,r9
  231f61:	41 83 c2 41          	add    r10d,0x41
  231f65:	f3 48 0f bd c6       	lzcnt  rax,rsi
  231f6a:	41 29 c2             	sub    r10d,eax
            if (sr == SingleInt.bit_count) {
  231f6d:	41 83 fa 40          	cmp    r10d,0x40
  231f71:	74 6f                	je     231fe2 <udivmod.14+0x162>
  231f73:	44 89 d3             	mov    ebx,r10d
  231f76:	f7 db                	neg    ebx
  231f78:	83 e3 3f             	and    ebx,0x3f
  231f7b:	c4 62 e1 f7 e7       	shlx   r12,rdi,rbx
            } else if (sr < SingleInt.bit_count) {
  231f80:	41 83 fa 40          	cmp    r10d,0x40
  231f84:	0f 83 90 02 00 00    	jae    23221a <udivmod.14+0x39a>
  231f8a:	31 ed                	xor    ebp,ebp
    while (sr > 0) : (sr -= 1) {
  231f8c:	45 85 d2             	test   r10d,r10d
  231f8f:	0f 84 de 02 00 00    	je     232273 <udivmod.14+0x3f3>
  231f95:	44 89 d5             	mov    ebp,r10d
  231f98:	83 e5 3f             	and    ebp,0x3f
  231f9b:	c4 e2 d3 f7 d6       	shrx   rdx,rsi,rbp
  231fa0:	c4 e2 e1 f7 de       	shlx   rbx,rsi,rbx
  231fa5:	c4 e2 d3 f7 f7       	shrx   rsi,rdi,rbp
  231faa:	48 09 de             	or     rsi,rbx
  231fad:	4c 89 e7             	mov    rdi,r12
  231fb0:	eb 7b                	jmp    23202d <udivmod.14+0x1ad>
  231fb2:	4d 85 c0             	test   r8,r8
            if (maybe_rem) |rem| {
  231fb5:	0f 84 40 02 00 00    	je     2321fb <udivmod.14+0x37b>
  231fbb:	48 89 f8             	mov    rax,rdi
  231fbe:	4c 09 c8             	or     rax,r9
  231fc1:	48 c1 e8 20          	shr    rax,0x20
  231fc5:	0f 84 1e 02 00 00    	je     2321e9 <udivmod.14+0x369>
  231fcb:	31 d2                	xor    edx,edx
  231fcd:	48 89 f8             	mov    rax,rdi
  231fd0:	49 f7 f1             	div    r9
  231fd3:	e9 18 02 00 00       	jmp    2321f0 <udivmod.14+0x370>
            sr += 1;
  231fd8:	44 8d 50 01          	lea    r10d,[rax+0x1]
            if (sr == SingleInt.bit_count) {
  231fdc:	41 83 fa 40          	cmp    r10d,0x40
  231fe0:	75 24                	jne    232006 <udivmod.14+0x186>
  231fe2:	41 ba 40 00 00 00    	mov    r10d,0x40
  231fe8:	45 31 e4             	xor    r12d,r12d
  231feb:	31 d2                	xor    edx,edx
  231fed:	eb 41                	jmp    232030 <udivmod.14+0x1b0>
            if (maybe_rem) |rem| {
  231fef:	4d 85 c0             	test   r8,r8
  231ff2:	74 09                	je     231ffd <udivmod.14+0x17d>
                rem.* = n[high] % d[low];
  231ff4:	c5 f8 57 c0          	vxorps xmm0,xmm0,xmm0
  231ff8:	c4 c1 78 11 00       	vmovups XMMWORD PTR [r8],xmm0
  231ffd:	31 ff                	xor    edi,edi
  231fff:	31 f6                	xor    esi,esi
  232001:	e9 5b 01 00 00       	jmp    232161 <udivmod.14+0x2e1>
                r[high] = n[high] >> @intCast(Log2SingleInt, sr);
  232006:	44 89 d5             	mov    ebp,r10d
  232009:	83 e5 3f             	and    ebp,0x3f
  23200c:	c4 e2 d3 f7 d6       	shrx   rdx,rsi,rbp
  232011:	bb 3f 00 00 00       	mov    ebx,0x3f
                r[low] = (n[high] << @intCast(Log2SingleInt, SingleInt.bit_count - sr)) | (n[low] >> @intCast(Log2SingleInt, sr));
  232016:	29 c3                	sub    ebx,eax
  232018:	83 e3 3f             	and    ebx,0x3f
  23201b:	c4 e2 e1 f7 c6       	shlx   rax,rsi,rbx
  232020:	c4 e2 d3 f7 f7       	shrx   rsi,rdi,rbp
  232025:	48 09 c6             	or     rsi,rax
                q[high] = n[low] << @intCast(Log2SingleInt, SingleInt.bit_count - sr);
  232028:	c4 e2 e1 f7 ff       	shlx   rdi,rdi,rbx
  23202d:	45 31 e4             	xor    r12d,r12d
  232030:	4d 89 cf             	mov    r15,r9
  232033:	49 83 c7 ff          	add    r15,0xffffffffffffffff
  232037:	49 89 cb             	mov    r11,rcx
  23203a:	49 83 d3 ff          	adc    r11,0xffffffffffffffff
    while (sr > 0) : (sr -= 1) {
  23203e:	44 89 d0             	mov    eax,r10d
  232041:	83 e0 01             	and    eax,0x1
  232044:	31 ed                	xor    ebp,ebp
  232046:	41 83 fa 01          	cmp    r10d,0x1
  23204a:	75 0f                	jne    23205b <udivmod.14+0x1db>
  23204c:	31 db                	xor    ebx,ebx
  23204e:	85 c0                	test   eax,eax
  232050:	0f 85 ac 00 00 00    	jne    232102 <udivmod.14+0x282>
  232056:	e9 da 00 00 00       	jmp    232135 <udivmod.14+0x2b5>
  23205b:	4c 89 44 24 f8       	mov    QWORD PTR [rsp-0x8],r8
  232060:	89 44 24 f4          	mov    DWORD PTR [rsp-0xc],eax
  232064:	41 89 c5             	mov    r13d,eax
  232067:	45 29 d5             	sub    r13d,r10d
  23206a:	41 ba 3e 01 00 00    	mov    r10d,0x13e
        r[high] = (r[high] << 1) | (r[low] >> (SingleInt.bit_count - 1));
  232070:	48 0f a4 f2 01       	shld   rdx,rsi,0x1
        r[low] = (r[low] << 1) | (q[high] >> (SingleInt.bit_count - 1));
  232075:	48 0f a4 fe 01       	shld   rsi,rdi,0x1
        q[high] = (q[high] << 1) | (q[low] >> (SingleInt.bit_count - 1));
  23207a:	48 89 f8             	mov    rax,rdi
  23207d:	4c 0f a4 e0 01       	shld   rax,r12,0x1
        q[low] = (q[low] << 1) | carry;
  232082:	4b 8d 1c 24          	lea    rbx,[r12+r12*1]
  232086:	89 ed                	mov    ebp,ebp
  232088:	48 09 dd             	or     rbp,rbx
        const s: SignedDoubleInt = @intCast(SignedDoubleInt, b -% r_all -% 1) >> (DoubleInt.bit_count - 1);
  23208b:	49 39 f7             	cmp    r15,rsi
  23208e:	4c 89 db             	mov    rbx,r11
  232091:	48 19 d3             	sbb    rbx,rdx
  232094:	48 c1 fb 3f          	sar    rbx,0x3f
        carry = @intCast(u32, s & 1);
  232098:	41 89 de             	mov    r14d,ebx
  23209b:	41 83 e6 01          	and    r14d,0x1
        r_all -= b & @bitCast(DoubleInt, s);
  23209f:	49 89 d8             	mov    r8,rbx
  2320a2:	49 21 c8             	and    r8,rcx
  2320a5:	4c 21 cb             	and    rbx,r9
  2320a8:	48 29 de             	sub    rsi,rbx
  2320ab:	4c 19 c2             	sbb    rdx,r8
        r[high] = (r[high] << 1) | (r[low] >> (SingleInt.bit_count - 1));
  2320ae:	48 0f a4 f2 01       	shld   rdx,rsi,0x1
        r[low] = (r[low] << 1) | (q[high] >> (SingleInt.bit_count - 1));
  2320b3:	c4 e2 a8 f7 ff       	bextr  rdi,rdi,r10
  2320b8:	48 8d 34 77          	lea    rsi,[rdi+rsi*2]
        q[high] = (q[high] << 1) | (q[low] >> (SingleInt.bit_count - 1));
  2320bc:	c4 c2 a8 f7 fc       	bextr  rdi,r12,r10
  2320c1:	48 8d 3c 47          	lea    rdi,[rdi+rax*2]
        q[low] = (q[low] << 1) | carry;
  2320c5:	4d 8d 24 6e          	lea    r12,[r14+rbp*2]
        const s: SignedDoubleInt = @intCast(SignedDoubleInt, b -% r_all -% 1) >> (DoubleInt.bit_count - 1);
  2320c9:	49 39 f7             	cmp    r15,rsi
  2320cc:	4c 89 d8             	mov    rax,r11
  2320cf:	48 19 d0             	sbb    rax,rdx
  2320d2:	48 c1 f8 3f          	sar    rax,0x3f
        carry = @intCast(u32, s & 1);
  2320d6:	89 c5                	mov    ebp,eax
  2320d8:	83 e5 01             	and    ebp,0x1
        r_all -= b & @bitCast(DoubleInt, s);
  2320db:	48 89 c3             	mov    rbx,rax
  2320de:	48 21 cb             	and    rbx,rcx
  2320e1:	4c 21 c8             	and    rax,r9
  2320e4:	48 29 c6             	sub    rsi,rax
  2320e7:	48 19 da             	sbb    rdx,rbx
    while (sr > 0) : (sr -= 1) {
  2320ea:	41 83 c5 02          	add    r13d,0x2
  2320ee:	75 80                	jne    232070 <udivmod.14+0x1f0>
  2320f0:	89 eb                	mov    ebx,ebp
  2320f2:	49 89 f2             	mov    r10,rsi
  2320f5:	4c 8b 44 24 f8       	mov    r8,QWORD PTR [rsp-0x8]
  2320fa:	8b 44 24 f4          	mov    eax,DWORD PTR [rsp-0xc]
  2320fe:	85 c0                	test   eax,eax
  232100:	74 33                	je     232135 <udivmod.14+0x2b5>
        r[high] = (r[high] << 1) | (r[low] >> (SingleInt.bit_count - 1));
  232102:	48 0f a4 f2 01       	shld   rdx,rsi,0x1
        r[low] = (r[low] << 1) | (q[high] >> (SingleInt.bit_count - 1));
  232107:	48 0f a4 fe 01       	shld   rsi,rdi,0x1
        const s: SignedDoubleInt = @intCast(SignedDoubleInt, b -% r_all -% 1) >> (DoubleInt.bit_count - 1);
  23210c:	49 39 f7             	cmp    r15,rsi
  23210f:	49 19 d3             	sbb    r11,rdx
  232112:	49 c1 fb 3f          	sar    r11,0x3f
        r_all -= b & @bitCast(DoubleInt, s);
  232116:	4c 21 d9             	and    rcx,r11
  232119:	4d 21 d9             	and    r9,r11
  23211c:	4c 29 ce             	sub    rsi,r9
  23211f:	48 19 ca             	sbb    rdx,rcx
        carry = @intCast(u32, s & 1);
  232122:	41 83 e3 01          	and    r11d,0x1
        q[high] = (q[high] << 1) | (q[low] >> (SingleInt.bit_count - 1));
  232126:	4c 0f a4 e7 01       	shld   rdi,r12,0x1
        q[low] = (q[low] << 1) | carry;
  23212b:	4e 8d 24 63          	lea    r12,[rbx+r12*2]
  23212f:	44 89 dd             	mov    ebp,r11d
  232132:	49 89 f2             	mov    r10,rsi
  232135:	48 89 f8             	mov    rax,rdi
    const q_all = ((@ptrCast(*align(@alignOf(SingleInt)) DoubleInt, &q[0]).*) << 1) | carry; // TODO issue #421
  232138:	89 ed                	mov    ebp,ebp
  23213a:	31 c9                	xor    ecx,ecx
  23213c:	4c 89 e7             	mov    rdi,r12
  23213f:	31 f6                	xor    esi,esi
  232141:	49 89 c4             	mov    r12,rax
  232144:	4c 09 e6             	or     rsi,r12
  232147:	48 0f a4 fe 01       	shld   rsi,rdi,0x1
  23214c:	48 09 ce             	or     rsi,rcx
  23214f:	48 01 ff             	add    rdi,rdi
  232152:	48 09 ef             	or     rdi,rbp
    if (maybe_rem) |rem| {
  232155:	4d 85 c0             	test   r8,r8
  232158:	74 07                	je     232161 <udivmod.14+0x2e1>
        rem.* = r_all;
  23215a:	4d 89 10             	mov    QWORD PTR [r8],r10
  23215d:	49 89 50 08          	mov    QWORD PTR [r8+0x8],rdx
        return 0;
  232161:	48 89 f8             	mov    rax,rdi
  232164:	48 89 f2             	mov    rdx,rsi
  232167:	e9 fc 00 00 00       	jmp    232268 <udivmod.14+0x3e8>
            if (maybe_rem) |rem| {
  23216c:	4d 85 c0             	test   r8,r8
  23216f:	0f 84 d5 00 00 00    	je     23224a <udivmod.14+0x3ca>
  232175:	48 89 f0             	mov    rax,rsi
  232178:	48 09 c8             	or     rax,rcx
  23217b:	48 c1 e8 20          	shr    rax,0x20
  23217f:	0f 84 b4 00 00 00    	je     232239 <udivmod.14+0x3b9>
  232185:	31 d2                	xor    edx,edx
  232187:	48 89 f0             	mov    rax,rsi
  23218a:	48 f7 f1             	div    rcx
  23218d:	e9 ad 00 00 00       	jmp    23223f <udivmod.14+0x3bf>
                if (maybe_rem) |rem| {
  232192:	4d 85 c0             	test   r8,r8
  232195:	74 0e                	je     2321a5 <udivmod.14+0x325>
                    rem.* = n[low] & (d[low] - 1);
  232197:	48 21 f8             	and    rax,rdi
  23219a:	49 89 00             	mov    QWORD PTR [r8],rax
  23219d:	49 c7 40 08 00 00 00 	mov    QWORD PTR [r8+0x8],0x0
  2321a4:	00 
                if (d[low] == 1) {
  2321a5:	49 83 f9 01          	cmp    r9,0x1
  2321a9:	74 b6                	je     232161 <udivmod.14+0x2e1>
                sr = @ctz(d[low]);
  2321ab:	f3 49 0f bc c1       	tzcnt  rax,r9
                q[high] = n[high] >> @intCast(Log2SingleInt, sr);
  2321b0:	89 c1                	mov    ecx,eax
  2321b2:	83 e1 3f             	and    ecx,0x3f
  2321b5:	c4 e2 f3 f7 d6       	shrx   rdx,rsi,rcx
                q[low] = (n[high] << @intCast(Log2SingleInt, SingleInt.bit_count - sr)) | (n[low] >> @intCast(Log2SingleInt, sr));
  2321ba:	f7 d8                	neg    eax
  2321bc:	c4 e2 f9 f7 f6       	shlx   rsi,rsi,rax
  2321c1:	c4 e2 f3 f7 c7       	shrx   rax,rdi,rcx
  2321c6:	48 09 f0             	or     rax,rsi
  2321c9:	e9 9a 00 00 00       	jmp    232268 <udivmod.14+0x3e8>
            if (maybe_rem) |rem| {
  2321ce:	4d 85 c0             	test   r8,r8
  2321d1:	74 0a                	je     2321dd <udivmod.14+0x35d>
                r[high] = n[high] & (d[high] - 1);
  2321d3:	48 21 f0             	and    rax,rsi
                rem.* = @ptrCast(*align(@alignOf(SingleInt)) DoubleInt, &r[0]).*; // TODO issue #421
  2321d6:	49 89 38             	mov    QWORD PTR [r8],rdi
  2321d9:	49 89 40 08          	mov    QWORD PTR [r8+0x8],rax
            return n[high] >> @intCast(Log2SingleInt, @ctz(d[high]));
  2321dd:	f3 48 0f bc c1       	tzcnt  rax,rcx
  2321e2:	c4 e2 fb f7 c6       	shrx   rax,rsi,rax
  2321e7:	eb 7d                	jmp    232266 <udivmod.14+0x3e6>
  2321e9:	31 d2                	xor    edx,edx
  2321eb:	89 f8                	mov    eax,edi
  2321ed:	41 f7 f1             	div    r9d
                rem.* = n[low] % d[low];
  2321f0:	49 89 10             	mov    QWORD PTR [r8],rdx
  2321f3:	49 c7 40 08 00 00 00 	mov    QWORD PTR [r8+0x8],0x0
  2321fa:	00 
  2321fb:	48 89 f8             	mov    rax,rdi
  2321fe:	4c 09 c8             	or     rax,r9
  232201:	48 c1 e8 20          	shr    rax,0x20
  232205:	74 0a                	je     232211 <udivmod.14+0x391>
  232207:	31 d2                	xor    edx,edx
  232209:	48 89 f8             	mov    rax,rdi
  23220c:	49 f7 f1             	div    r9
  23220f:	eb 55                	jmp    232266 <udivmod.14+0x3e6>
  232211:	31 d2                	xor    edx,edx
  232213:	89 f8                	mov    eax,edi
  232215:	41 f7 f1             	div    r9d
  232218:	eb 4c                	jmp    232266 <udivmod.14+0x3e6>
                q[high] = (n[high] << @intCast(Log2SingleInt, DoubleInt.bit_count - sr)) | (n[low] >> @intCast(Log2SingleInt, sr - SingleInt.bit_count));
  23221a:	c4 e2 e1 f7 d6       	shlx   rdx,rsi,rbx
  23221f:	44 89 d5             	mov    ebp,r10d
  232222:	83 e5 3f             	and    ebp,0x3f
  232225:	c4 e2 d3 f7 ff       	shrx   rdi,rdi,rbp
  23222a:	48 09 d7             	or     rdi,rdx
                r[low] = n[high] >> @intCast(Log2SingleInt, sr - SingleInt.bit_count);
  23222d:	c4 e2 d3 f7 f6       	shrx   rsi,rsi,rbp
  232232:	31 d2                	xor    edx,edx
  232234:	e9 f7 fd ff ff       	jmp    232030 <udivmod.14+0x1b0>
  232239:	31 d2                	xor    edx,edx
  23223b:	89 f0                	mov    eax,esi
  23223d:	f7 f1                	div    ecx
                rem.* = @ptrCast(*align(@alignOf(SingleInt)) DoubleInt, &r[0]).*; // TODO issue #421
  23223f:	49 89 50 08          	mov    QWORD PTR [r8+0x8],rdx
  232243:	49 c7 00 00 00 00 00 	mov    QWORD PTR [r8],0x0
  23224a:	48 89 f0             	mov    rax,rsi
  23224d:	48 09 c8             	or     rax,rcx
  232250:	48 c1 e8 20          	shr    rax,0x20
  232254:	74 0a                	je     232260 <udivmod.14+0x3e0>
  232256:	31 d2                	xor    edx,edx
  232258:	48 89 f0             	mov    rax,rsi
  23225b:	48 f7 f1             	div    rcx
  23225e:	eb 06                	jmp    232266 <udivmod.14+0x3e6>
  232260:	31 d2                	xor    edx,edx
  232262:	89 f0                	mov    eax,esi
  232264:	f7 f1                	div    ecx
  232266:	31 d2                	xor    edx,edx
  232268:	5b                   	pop    rbx
  232269:	41 5c                	pop    r12
  23226b:	41 5d                	pop    r13
  23226d:	41 5e                	pop    r14
  23226f:	41 5f                	pop    r15
  232271:	5d                   	pop    rbp
  232272:	c3                   	ret    
  232273:	31 c9                	xor    ecx,ecx
  232275:	31 ff                	xor    edi,edi
  232277:	31 f6                	xor    esi,esi
  232279:	e9 c6 fe ff ff       	jmp    232144 <udivmod.14+0x2c4>
  23227e:	66 90                	xchg   ax,ax

0000000000232280 <__muloti4>:
const udivmod = @import("udivmod.zig").udivmod;
const builtin = @import("builtin");
const compiler_rt = @import("index.zig");

pub extern fn __muloti4(a: i128, b: i128, overflow: *c_int) i128 {
  232280:	55                   	push   rbp
  232281:	41 57                	push   r15
  232283:	41 56                	push   r14
  232285:	41 55                	push   r13
  232287:	41 54                	push   r12
  232289:	53                   	push   rbx
  23228a:	48 83 ec 28          	sub    rsp,0x28
  23228e:	4d 89 c7             	mov    r15,r8
  232291:	48 89 d5             	mov    rbp,rdx
  232294:	49 89 f4             	mov    r12,rsi
  232297:	48 89 fb             	mov    rbx,rdi
  23229a:	c4 c1 f9 6e c4       	vmovq  xmm0,r12
  23229f:	c4 e1 f9 6e cb       	vmovq  xmm1,rbx
  2322a4:	c5 f1 6c c0          	vpunpcklqdq xmm0,xmm1,xmm0
    @setRuntimeSafety(builtin.is_test);

    const min = @bitCast(i128, u128(1 << (i128.bit_count - 1)));
    const max = ~min;
    overflow.* = 0;
  2322a8:	41 c7 07 00 00 00 00 	mov    DWORD PTR [r15],0x0

    const r = a *% b;
  2322af:	48 89 e8             	mov    rax,rbp
  2322b2:	49 0f af c4          	imul   rax,r12
  2322b6:	c4 e2 8b f6 d3       	mulx   rdx,r14,rbx
  2322bb:	48 01 c2             	add    rdx,rax
  2322be:	49 89 cd             	mov    r13,rcx
  2322c1:	4c 0f af eb          	imul   r13,rbx
  2322c5:	49 01 d5             	add    r13,rdx
    if (a == min) {
  2322c8:	48 be 00 00 00 00 00 	movabs rsi,0x8000000000000000
  2322cf:	00 00 80 
  2322d2:	c4 e1 f9 6e ce       	vmovq  xmm1,rsi
  2322d7:	c5 e9 73 f9 08       	vpslldq xmm2,xmm1,0x8
  2322dc:	c5 f9 74 c2          	vpcmpeqb xmm0,xmm0,xmm2
  2322e0:	c5 f9 d7 c0          	vpmovmskb eax,xmm0
  2322e4:	3d ff ff 00 00       	cmp    eax,0xffff
  2322e9:	75 13                	jne    2322fe <__muloti4+0x7e>
        if (b != 0 and b != 1) {
  2322eb:	48 83 fd 02          	cmp    rbp,0x2
  2322ef:	48 83 d9 00          	sbb    rcx,0x0
  2322f3:	0f 83 b7 00 00 00    	jae    2323b0 <__muloti4+0x130>
  2322f9:	e9 b9 00 00 00       	jmp    2323b7 <__muloti4+0x137>
            overflow.* = 1;
        }
        return r;
    }
    if (b == min) {
  2322fe:	c4 e1 f9 6e c5       	vmovq  xmm0,rbp
  232303:	c4 e1 f9 6e c9       	vmovq  xmm1,rcx
  232308:	c5 f9 6c c1          	vpunpcklqdq xmm0,xmm0,xmm1
  23230c:	c5 f9 74 c2          	vpcmpeqb xmm0,xmm0,xmm2
  232310:	c5 f9 d7 c0          	vpmovmskb eax,xmm0
  232314:	3d ff ff 00 00       	cmp    eax,0xffff
  232319:	75 13                	jne    23232e <__muloti4+0xae>
        if (a != 0 and a != 1) {
  23231b:	48 83 fb 02          	cmp    rbx,0x2
  23231f:	49 83 dc 00          	sbb    r12,0x0
  232323:	0f 83 87 00 00 00    	jae    2323b0 <__muloti4+0x130>
  232329:	e9 89 00 00 00       	jmp    2323b7 <__muloti4+0x137>
            overflow.* = 1;
        }
        return r;
    }

    const sa = a >> (i128.bit_count - 1);
  23232e:	4c 89 e0             	mov    rax,r12
  232331:	48 c1 f8 3f          	sar    rax,0x3f
    const abs_a = (a ^ sa) -% sa;
  232335:	49 31 c4             	xor    r12,rax
  232338:	48 31 c3             	xor    rbx,rax
  23233b:	48 29 c3             	sub    rbx,rax
  23233e:	49 19 c4             	sbb    r12,rax
    const sb = b >> (i128.bit_count - 1);
  232341:	48 89 ca             	mov    rdx,rcx
  232344:	48 c1 fa 3f          	sar    rdx,0x3f
    const abs_b = (b ^ sb) -% sb;
  232348:	48 31 d1             	xor    rcx,rdx
  23234b:	48 31 d5             	xor    rbp,rdx
  23234e:	48 29 d5             	sub    rbp,rdx
  232351:	48 19 d1             	sbb    rcx,rdx

    if (abs_a < 2 or abs_b < 2) {
  232354:	48 83 fb 02          	cmp    rbx,0x2
  232358:	4c 89 e7             	mov    rdi,r12
  23235b:	48 83 df 00          	sbb    rdi,0x0
  23235f:	7c 56                	jl     2323b7 <__muloti4+0x137>
  232361:	48 83 fd 02          	cmp    rbp,0x2
  232365:	48 89 cf             	mov    rdi,rcx
  232368:	48 83 df 00          	sbb    rdi,0x0
  23236c:	7c 49                	jl     2323b7 <__muloti4+0x137>
        return r;
    }

    if (sa == sb) {
  23236e:	c4 e1 f9 6e c2       	vmovq  xmm0,rdx
  232373:	c5 f9 6c c0          	vpunpcklqdq xmm0,xmm0,xmm0
  232377:	c4 e1 f9 6e c8       	vmovq  xmm1,rax
  23237c:	c5 f1 6c c9          	vpunpcklqdq xmm1,xmm1,xmm1
  232380:	c5 f1 74 c0          	vpcmpeqb xmm0,xmm1,xmm0
  232384:	c5 f9 d7 c0          	vpmovmskb eax,xmm0
  232388:	3d ff ff 00 00       	cmp    eax,0xffff
  23238d:	75 3d                	jne    2323cc <__muloti4+0x14c>
  23238f:	48 be ff ff ff ff ff 	movabs rsi,0x7fffffffffffffff
  232396:	ff ff 7f 
  232399:	48 c7 c7 ff ff ff ff 	mov    rdi,0xffffffffffffffff
  2323a0:	48 89 ea             	mov    rdx,rbp
  2323a3:	e8 a8 00 00 00       	call   232450 <__udivti3>
        if (abs_a > @divFloor(max, abs_b)) {
  2323a8:	48 39 d8             	cmp    rax,rbx
  2323ab:	4c 19 e2             	sbb    rdx,r12
  2323ae:	7d 07                	jge    2323b7 <__muloti4+0x137>
  2323b0:	41 c7 07 01 00 00 00 	mov    DWORD PTR [r15],0x1
        return r;
  2323b7:	4c 89 f0             	mov    rax,r14
  2323ba:	4c 89 ea             	mov    rdx,r13
  2323bd:	48 83 c4 28          	add    rsp,0x28
  2323c1:	5b                   	pop    rbx
  2323c2:	41 5c                	pop    r12
  2323c4:	41 5d                	pop    r13
  2323c6:	41 5e                	pop    r14
  2323c8:	41 5f                	pop    r15
  2323ca:	5d                   	pop    rbp
  2323cb:	c3                   	ret    
  2323cc:	31 c0                	xor    eax,eax
            overflow.* = 1;
        }
    } else {
        if (abs_a > @divFloor(min, -abs_b)) {
  2323ce:	48 f7 dd             	neg    rbp
  2323d1:	48 19 c8             	sbb    rax,rcx
  2323d4:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  2323d9:	31 ff                	xor    edi,edi
  2323db:	48 89 ea             	mov    rdx,rbp
  2323de:	48 89 c1             	mov    rcx,rax
  2323e1:	c5 f9 7f 54 24 10    	vmovdqa XMMWORD PTR [rsp+0x10],xmm2
  2323e7:	e8 44 fa ff ff       	call   231e30 <__divti3>
  2323ec:	48 89 d1             	mov    rcx,rdx
  2323ef:	48 85 c9             	test   rcx,rcx
  2323f2:	41 0f 98 c0          	sets   r8b
  2323f6:	48 89 c2             	mov    rdx,rax
  2323f9:	c4 e2 eb f6 fd       	mulx   rdi,rdx,rbp
  2323fe:	48 8b 74 24 08       	mov    rsi,QWORD PTR [rsp+0x8]
  232403:	48 0f af f0          	imul   rsi,rax
  232407:	48 01 f7             	add    rdi,rsi
  23240a:	48 0f af e9          	imul   rbp,rcx
  23240e:	48 01 fd             	add    rbp,rdi
  232411:	c4 e1 f9 6e c5       	vmovq  xmm0,rbp
  232416:	c4 e1 f9 6e ca       	vmovq  xmm1,rdx
  23241b:	c5 f1 6c c0          	vpunpcklqdq xmm0,xmm1,xmm0
  23241f:	c5 f9 74 44 24 10    	vpcmpeqb xmm0,xmm0,XMMWORD PTR [rsp+0x10]
  232425:	c5 f9 d7 d0          	vpmovmskb edx,xmm0
  232429:	81 fa ff ff 00 00    	cmp    edx,0xffff
  23242f:	0f 95 c2             	setne  dl
  232432:	44 20 c2             	and    dl,r8b
  232435:	0f b6 d2             	movzx  edx,dl
  232438:	48 29 d0             	sub    rax,rdx
  23243b:	48 83 d9 00          	sbb    rcx,0x0
  23243f:	48 39 d8             	cmp    rax,rbx
  232442:	4c 19 e1             	sbb    rcx,r12
  232445:	0f 8c 65 ff ff ff    	jl     2323b0 <__muloti4+0x130>
  23244b:	e9 67 ff ff ff       	jmp    2323b7 <__muloti4+0x137>

0000000000232450 <__udivti3>:
const builtin = @import("builtin");
const compiler_rt = @import("index.zig");

pub extern fn __udivmodti4(a: u128, b: u128, maybe_rem: ?*u128) u128 {
    @setRuntimeSafety(builtin.is_test);
    return udivmod(u128, a, b, maybe_rem);
  232450:	45 31 c0             	xor    r8d,r8d
  232453:	e9 28 fa ff ff       	jmp    231e80 <udivmod.14>
  232458:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  23245f:	00 

0000000000232460 <__udivmodti4>:
  232460:	e9 1b fa ff ff       	jmp    231e80 <udivmod.14>
  232465:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  23246c:	00 00 00 00 

0000000000232470 <__umodti3>:
const udivmodti4 = @import("udivmodti4.zig");
const builtin = @import("builtin");
const compiler_rt = @import("index.zig");

pub extern fn __umodti3(a: u128, b: u128) u128 {
  232470:	48 83 ec 18          	sub    rsp,0x18
  232474:	4c 8d 44 24 08       	lea    r8,[rsp+0x8]
  232479:	e8 02 fa ff ff       	call   231e80 <udivmod.14>
    @setRuntimeSafety(builtin.is_test);
    var r: u128 = undefined;
    _ = udivmodti4.__udivmodti4(a, b, &r);
    return r;
  23247e:	48 8b 44 24 08       	mov    rax,QWORD PTR [rsp+0x8]
  232483:	48 8b 54 24 10       	mov    rdx,QWORD PTR [rsp+0x10]
  232488:	48 83 c4 18          	add    rsp,0x18
  23248c:	c3                   	ret    
