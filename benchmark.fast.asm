
./zig-cache/test:     file format elf64-x86-64


Disassembly of section .text:

000000000020a000 <ThreadSafeFixedBufferAllocator_alloc>:
            .buffer = buffer,
            .end_index = 0,
        };
    }

    fn alloc(allocator: *Allocator, n: usize, alignment: u29) ![]u8 {
  20a000:	49 89 d0             	mov    r8,rdx
        const self = @fieldParentPtr(ThreadSafeFixedBufferAllocator, "allocator", allocator);
        var end_index = @atomicLoad(usize, &self.end_index, builtin.AtomicOrder.SeqCst);
  20a003:	4c 8b 4e 18          	mov    r9,QWORD PTR [rsi+0x18]
  20a007:	48 8b 46 20          	mov    rax,QWORD PTR [rsi+0x20]
        while (true) {
            const addr = @ptrToInt(self.buffer.ptr) + end_index;
  20a00b:	4c 01 c8             	add    rax,r9
            const rem = @rem(addr, alignment);
  20a00e:	81 e1 ff ff ff 1f    	and    ecx,0x1fffffff
  20a014:	48 89 c2             	mov    rdx,rax
  20a017:	48 c1 ea 20          	shr    rdx,0x20
  20a01b:	75 13                	jne    20a030 <ThreadSafeFixedBufferAllocator_alloc+0x30>
  20a01d:	eb 21                	jmp    20a040 <ThreadSafeFixedBufferAllocator_alloc+0x40>
  20a01f:	90                   	nop
  20a020:	48 8b 46 20          	mov    rax,QWORD PTR [rsi+0x20]
            const addr = @ptrToInt(self.buffer.ptr) + end_index;
  20a024:	4c 01 c8             	add    rax,r9
  20a027:	48 89 c2             	mov    rdx,rax
  20a02a:	48 c1 ea 20          	shr    rdx,0x20
  20a02e:	74 10                	je     20a040 <ThreadSafeFixedBufferAllocator_alloc+0x40>
  20a030:	31 d2                	xor    edx,edx
  20a032:	48 f7 f1             	div    rcx
  20a035:	eb 0d                	jmp    20a044 <ThreadSafeFixedBufferAllocator_alloc+0x44>
  20a037:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  20a03e:	00 00 
  20a040:	31 d2                	xor    edx,edx
  20a042:	f7 f1                	div    ecx
            const march_forward_bytes = if (rem == 0) 0 else (alignment - rem);
  20a044:	49 89 ca             	mov    r10,rcx
  20a047:	49 29 d2             	sub    r10,rdx
  20a04a:	48 85 d2             	test   rdx,rdx
  20a04d:	4c 0f 44 d2          	cmove  r10,rdx
            const adjusted_index = end_index + march_forward_bytes;
  20a051:	4d 01 ca             	add    r10,r9
            const new_end_index = adjusted_index + n;
  20a054:	4b 8d 14 02          	lea    rdx,[r10+r8*1]
            if (new_end_index > self.buffer.len) {
  20a058:	48 3b 56 28          	cmp    rdx,QWORD PTR [rsi+0x28]
  20a05c:	77 33                	ja     20a091 <ThreadSafeFixedBufferAllocator_alloc+0x91>
                return error.OutOfMemory;
            }
            end_index = @cmpxchgWeak(usize, &self.end_index, end_index, new_end_index, builtin.AtomicOrder.SeqCst, builtin.AtomicOrder.SeqCst) orelse return self.buffer[adjusted_index..new_end_index];
  20a05e:	4c 89 c8             	mov    rax,r9
  20a061:	f0 48 0f b1 56 18    	lock cmpxchg QWORD PTR [rsi+0x18],rdx
  20a067:	49 89 c1             	mov    r9,rax
  20a06a:	75 b4                	jne    20a020 <ThreadSafeFixedBufferAllocator_alloc+0x20>
  20a06c:	4c 03 56 20          	add    r10,QWORD PTR [rsi+0x20]
  20a070:	66 c7 07 00 00       	mov    WORD PTR [rdi],0x0
  20a075:	0f b7 44 24 fe       	movzx  eax,WORD PTR [rsp-0x2]
  20a07a:	66 89 47 06          	mov    WORD PTR [rdi+0x6],ax
  20a07e:	8b 44 24 fa          	mov    eax,DWORD PTR [rsp-0x6]
  20a082:	89 47 02             	mov    DWORD PTR [rdi+0x2],eax
  20a085:	4c 89 57 08          	mov    QWORD PTR [rdi+0x8],r10
  20a089:	4c 89 47 10          	mov    QWORD PTR [rdi+0x10],r8
  20a08d:	48 89 f8             	mov    rax,rdi
  20a090:	c3                   	ret    
                return error.OutOfMemory;
  20a091:	48 8b 05 90 eb ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffffeb90]        # 208c28 <__unnamed_1+0x10>
  20a098:	48 89 47 10          	mov    QWORD PTR [rdi+0x10],rax
  20a09c:	c5 f8 10 05 74 eb ff 	vmovups xmm0,XMMWORD PTR [rip+0xffffffffffffeb74]        # 208c18 <__unnamed_1>
  20a0a3:	ff 
  20a0a4:	c5 f8 11 07          	vmovups XMMWORD PTR [rdi],xmm0
  20a0a8:	48 89 f8             	mov    rax,rdi
  20a0ab:	c3                   	ret    
  20a0ac:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

000000000020a0b0 <ThreadSafeFixedBufferAllocator_realloc>:
        }
    }

    fn realloc(allocator: *Allocator, old_mem: []u8, new_size: usize, alignment: u29) ![]u8 {
  20a0b0:	53                   	push   rbx
  20a0b1:	48 83 ec 30          	sub    rsp,0x30
  20a0b5:	49 89 d1             	mov    r9,rdx
        if (new_size <= old_mem.len) {
  20a0b8:	49 39 49 08          	cmp    QWORD PTR [r9+0x8],rcx
  20a0bc:	0f 83 a9 00 00 00    	jae    20a16b <ThreadSafeFixedBufferAllocator_realloc+0xbb>
        var end_index = @atomicLoad(usize, &self.end_index, builtin.AtomicOrder.SeqCst);
  20a0c2:	4c 8b 56 18          	mov    r10,QWORD PTR [rsi+0x18]
  20a0c6:	48 8b 46 20          	mov    rax,QWORD PTR [rsi+0x20]
            const addr = @ptrToInt(self.buffer.ptr) + end_index;
  20a0ca:	4c 01 d0             	add    rax,r10
            const rem = @rem(addr, alignment);
  20a0cd:	41 81 e0 ff ff ff 1f 	and    r8d,0x1fffffff
  20a0d4:	48 89 c2             	mov    rdx,rax
  20a0d7:	48 c1 ea 20          	shr    rdx,0x20
  20a0db:	75 13                	jne    20a0f0 <ThreadSafeFixedBufferAllocator_realloc+0x40>
  20a0dd:	eb 21                	jmp    20a100 <ThreadSafeFixedBufferAllocator_realloc+0x50>
  20a0df:	90                   	nop
  20a0e0:	48 8b 46 20          	mov    rax,QWORD PTR [rsi+0x20]
            const addr = @ptrToInt(self.buffer.ptr) + end_index;
  20a0e4:	4c 01 d0             	add    rax,r10
  20a0e7:	48 89 c2             	mov    rdx,rax
  20a0ea:	48 c1 ea 20          	shr    rdx,0x20
  20a0ee:	74 10                	je     20a100 <ThreadSafeFixedBufferAllocator_realloc+0x50>
  20a0f0:	31 d2                	xor    edx,edx
  20a0f2:	49 f7 f0             	div    r8
  20a0f5:	eb 0e                	jmp    20a105 <ThreadSafeFixedBufferAllocator_realloc+0x55>
  20a0f7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  20a0fe:	00 00 
  20a100:	31 d2                	xor    edx,edx
  20a102:	41 f7 f0             	div    r8d
            const march_forward_bytes = if (rem == 0) 0 else (alignment - rem);
  20a105:	4d 89 c3             	mov    r11,r8
  20a108:	49 29 d3             	sub    r11,rdx
  20a10b:	48 85 d2             	test   rdx,rdx
  20a10e:	4c 0f 44 da          	cmove  r11,rdx
            const adjusted_index = end_index + march_forward_bytes;
  20a112:	4d 01 d3             	add    r11,r10
            const new_end_index = adjusted_index + n;
  20a115:	49 8d 14 0b          	lea    rdx,[r11+rcx*1]
            if (new_end_index > self.buffer.len) {
  20a119:	48 3b 56 28          	cmp    rdx,QWORD PTR [rsi+0x28]
  20a11d:	77 6d                	ja     20a18c <ThreadSafeFixedBufferAllocator_realloc+0xdc>
            end_index = @cmpxchgWeak(usize, &self.end_index, end_index, new_end_index, builtin.AtomicOrder.SeqCst, builtin.AtomicOrder.SeqCst) orelse return self.buffer[adjusted_index..new_end_index];
  20a11f:	4c 89 d0             	mov    rax,r10
  20a122:	f0 48 0f b1 56 18    	lock cmpxchg QWORD PTR [rsi+0x18],rdx
  20a128:	49 89 c2             	mov    r10,rax
  20a12b:	75 b3                	jne    20a0e0 <ThreadSafeFixedBufferAllocator_realloc+0x30>
pub fn copy(comptime T: type, dest: []T, source: []const T) void {
    // TODO instead of manually doing this check for the whole array
    // and turning off runtime safety, the compiler should detect loops like
    // this and automatically omit safety checks for loops
    @setRuntimeSafety(false);
    assert(dest.len >= source.len);
  20a12d:	4d 8b 51 08          	mov    r10,QWORD PTR [r9+0x8]
  20a131:	49 39 ca             	cmp    r10,rcx
/// In Debug and ReleaseSafe modes, calls to this function are always
/// generated, and the `unreachable` statement triggers a panic.
/// In ReleaseFast and ReleaseSmall modes, calls to this function can be
/// optimized away.
pub fn assert(ok: bool) void {
    if (!ok) {
  20a134:	0f 87 31 01 00 00    	ja     20a26b <ThreadSafeFixedBufferAllocator_realloc+0x1bb>
  20a13a:	48 8b 46 20          	mov    rax,QWORD PTR [rsi+0x20]
  20a13e:	4e 8d 04 18          	lea    r8,[rax+r11*1]
    for (source) |s, i|
  20a142:	4d 85 d2             	test   r10,r10
  20a145:	0f 84 fa 00 00 00    	je     20a245 <ThreadSafeFixedBufferAllocator_realloc+0x195>
  20a14b:	49 8d 72 ff          	lea    rsi,[r10-0x1]
  20a14f:	44 89 d3             	mov    ebx,r10d
  20a152:	83 e3 07             	and    ebx,0x7
  20a155:	48 83 fe 07          	cmp    rsi,0x7
  20a159:	73 53                	jae    20a1ae <ThreadSafeFixedBufferAllocator_realloc+0xfe>
  20a15b:	31 f6                	xor    esi,esi
  20a15d:	48 85 db             	test   rbx,rbx
  20a160:	0f 85 c6 00 00 00    	jne    20a22c <ThreadSafeFixedBufferAllocator_realloc+0x17c>
  20a166:	e9 da 00 00 00       	jmp    20a245 <ThreadSafeFixedBufferAllocator_realloc+0x195>
            return old_mem[0..new_size];
  20a16b:	49 8b 01             	mov    rax,QWORD PTR [r9]
  20a16e:	66 c7 07 00 00       	mov    WORD PTR [rdi],0x0
  20a173:	0f b7 54 24 18       	movzx  edx,WORD PTR [rsp+0x18]
  20a178:	66 89 57 06          	mov    WORD PTR [rdi+0x6],dx
  20a17c:	8b 54 24 14          	mov    edx,DWORD PTR [rsp+0x14]
  20a180:	89 57 02             	mov    DWORD PTR [rdi+0x2],edx
  20a183:	48 89 47 08          	mov    QWORD PTR [rdi+0x8],rax
  20a187:	e9 d2 00 00 00       	jmp    20a25e <ThreadSafeFixedBufferAllocator_realloc+0x1ae>
        } else {
            const result = try alloc(allocator, new_size, alignment);
  20a18c:	66 c7 07 01 00       	mov    WORD PTR [rdi],0x1
  20a191:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
  20a196:	48 89 47 10          	mov    QWORD PTR [rdi+0x10],rax
  20a19a:	c5 f8 10 44 24 1a    	vmovups xmm0,XMMWORD PTR [rsp+0x1a]
  20a1a0:	c5 f8 11 47 02       	vmovups XMMWORD PTR [rdi+0x2],xmm0
  20a1a5:	48 89 f8             	mov    rax,rdi
  20a1a8:	48 83 c4 30          	add    rsp,0x30
  20a1ac:	5b                   	pop    rbx
  20a1ad:	c3                   	ret    
  20a1ae:	49 29 da             	sub    r10,rbx
  20a1b1:	4c 01 d8             	add    rax,r11
  20a1b4:	48 83 c0 07          	add    rax,0x7
  20a1b8:	31 f6                	xor    esi,esi
  20a1ba:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  20a1c0:	49 8b 11             	mov    rdx,QWORD PTR [r9]
  20a1c3:	0f b6 14 32          	movzx  edx,BYTE PTR [rdx+rsi*1]
        dest[i] = s;
  20a1c7:	88 54 30 f9          	mov    BYTE PTR [rax+rsi*1-0x7],dl
    for (source) |s, i|
  20a1cb:	49 8b 11             	mov    rdx,QWORD PTR [r9]
  20a1ce:	0f b6 54 32 01       	movzx  edx,BYTE PTR [rdx+rsi*1+0x1]
        dest[i] = s;
  20a1d3:	88 54 30 fa          	mov    BYTE PTR [rax+rsi*1-0x6],dl
    for (source) |s, i|
  20a1d7:	49 8b 11             	mov    rdx,QWORD PTR [r9]
  20a1da:	0f b6 54 32 02       	movzx  edx,BYTE PTR [rdx+rsi*1+0x2]
        dest[i] = s;
  20a1df:	88 54 30 fb          	mov    BYTE PTR [rax+rsi*1-0x5],dl
    for (source) |s, i|
  20a1e3:	49 8b 11             	mov    rdx,QWORD PTR [r9]
  20a1e6:	0f b6 54 32 03       	movzx  edx,BYTE PTR [rdx+rsi*1+0x3]
        dest[i] = s;
  20a1eb:	88 54 30 fc          	mov    BYTE PTR [rax+rsi*1-0x4],dl
    for (source) |s, i|
  20a1ef:	49 8b 11             	mov    rdx,QWORD PTR [r9]
  20a1f2:	0f b6 54 32 04       	movzx  edx,BYTE PTR [rdx+rsi*1+0x4]
        dest[i] = s;
  20a1f7:	88 54 30 fd          	mov    BYTE PTR [rax+rsi*1-0x3],dl
    for (source) |s, i|
  20a1fb:	49 8b 11             	mov    rdx,QWORD PTR [r9]
  20a1fe:	0f b6 54 32 05       	movzx  edx,BYTE PTR [rdx+rsi*1+0x5]
        dest[i] = s;
  20a203:	88 54 30 fe          	mov    BYTE PTR [rax+rsi*1-0x2],dl
    for (source) |s, i|
  20a207:	49 8b 11             	mov    rdx,QWORD PTR [r9]
  20a20a:	0f b6 54 32 06       	movzx  edx,BYTE PTR [rdx+rsi*1+0x6]
        dest[i] = s;
  20a20f:	88 54 30 ff          	mov    BYTE PTR [rax+rsi*1-0x1],dl
    for (source) |s, i|
  20a213:	49 8b 11             	mov    rdx,QWORD PTR [r9]
  20a216:	0f b6 54 32 07       	movzx  edx,BYTE PTR [rdx+rsi*1+0x7]
        dest[i] = s;
  20a21b:	88 14 30             	mov    BYTE PTR [rax+rsi*1],dl
    for (source) |s, i|
  20a21e:	48 83 c6 08          	add    rsi,0x8
  20a222:	49 39 f2             	cmp    r10,rsi
  20a225:	75 99                	jne    20a1c0 <ThreadSafeFixedBufferAllocator_realloc+0x110>
  20a227:	48 85 db             	test   rbx,rbx
  20a22a:	74 19                	je     20a245 <ThreadSafeFixedBufferAllocator_realloc+0x195>
  20a22c:	48 f7 db             	neg    rbx
  20a22f:	90                   	nop
  20a230:	49 8b 01             	mov    rax,QWORD PTR [r9]
  20a233:	0f b6 04 30          	movzx  eax,BYTE PTR [rax+rsi*1]
        dest[i] = s;
  20a237:	41 88 04 30          	mov    BYTE PTR [r8+rsi*1],al
    for (source) |s, i|
  20a23b:	48 83 c6 01          	add    rsi,0x1
  20a23f:	48 83 c3 01          	add    rbx,0x1
  20a243:	75 eb                	jne    20a230 <ThreadSafeFixedBufferAllocator_realloc+0x180>
            mem.copy(u8, result, old_mem);
            return result;
  20a245:	66 c7 07 00 00       	mov    WORD PTR [rdi],0x0
  20a24a:	0f b7 44 24 12       	movzx  eax,WORD PTR [rsp+0x12]
  20a24f:	66 89 47 06          	mov    WORD PTR [rdi+0x6],ax
  20a253:	8b 44 24 0e          	mov    eax,DWORD PTR [rsp+0xe]
  20a257:	89 47 02             	mov    DWORD PTR [rdi+0x2],eax
  20a25a:	4c 89 47 08          	mov    QWORD PTR [rdi+0x8],r8
  20a25e:	48 89 4f 10          	mov    QWORD PTR [rdi+0x10],rcx
  20a262:	48 89 f8             	mov    rax,rdi
  20a265:	48 83 c4 30          	add    rsp,0x30
  20a269:	5b                   	pop    rbx
  20a26a:	c3                   	ret    
        // In ReleaseFast test mode, we still want assert(false) to crash, so
        // we insert an explicit call to @panic instead of unreachable.
        // TODO we should use `assertOrPanic` in tests and remove this logic.
        if (builtin.is_test) {
            @panic("assertion failure");
  20a26b:	48 8d 3d 96 4a 04 00 	lea    rdi,[rip+0x44a96]        # 24ed08 <__unnamed_2>
  20a272:	e8 a9 7d 00 00       	call   212020 <panic>
  20a277:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  20a27e:	00 00 

000000000020a280 <assert>:
    if (!ok) {
  20a280:	40 f6 c7 01          	test   dil,0x1
  20a284:	74 01                	je     20a287 <assert+0x7>
pub fn assert(ok: bool) void {
  20a286:	c3                   	ret    
            @panic("assertion failure");
  20a287:	50                   	push   rax
  20a288:	48 8d 3d 79 4a 04 00 	lea    rdi,[rip+0x44a79]        # 24ed08 <__unnamed_2>
  20a28f:	e8 8c 7d 00 00       	call   212020 <panic>
  20a294:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20a29b:	00 00 00 00 00 

000000000020a2a0 <init_vdso_clock_gettime>:
const linux = std.os.linux;
const cstr = std.cstr;
const mem = std.mem;

pub fn lookup(vername: []const u8, name: []const u8) usize {
    const vdso_addr = std.os.linux_aux_raw[std.elf.AT_SYSINFO_EHDR];
  20a2a0:	55                   	push   rbp
  20a2a1:	41 57                	push   r15
  20a2a3:	41 56                	push   r14
  20a2a5:	41 55                	push   r13
  20a2a7:	41 54                	push   r12
  20a2a9:	53                   	push   rbx
  20a2aa:	4c 8b 0d 97 5e 04 00 	mov    r9,QWORD PTR [rip+0x45e97]        # 250148 <linux_aux_raw+0x108>
    if (vdso_addr == 0) return 0;
  20a2b1:	4d 85 c9             	test   r9,r9
  20a2b4:	0f 84 53 05 00 00    	je     20a80d <init_vdso_clock_gettime+0x56d>

    var maybe_dynv: ?[*]usize = null;
    var base: usize = @maxValue(usize);
    {
        var i: usize = 0;
        while (i < eh.e_phnum) : ({
  20a2ba:	41 0f b7 51 38       	movzx  edx,WORD PTR [r9+0x38]
  20a2bf:	48 85 d2             	test   rdx,rdx
  20a2c2:	0f 84 45 05 00 00    	je     20a80d <init_vdso_clock_gettime+0x56d>
  20a2c8:	49 8b 59 20          	mov    rbx,QWORD PTR [r9+0x20]
    var ph_addr: usize = vdso_addr + eh.e_phoff;
  20a2cc:	4c 01 cb             	add    rbx,r9
  20a2cf:	41 0f b7 49 36       	movzx  ecx,WORD PTR [r9+0x36]
        while (i < eh.e_phnum) : ({
  20a2d4:	48 8d 42 ff          	lea    rax,[rdx-0x1]
  20a2d8:	89 d5                	mov    ebp,edx
  20a2da:	83 e5 03             	and    ebp,0x3
  20a2dd:	48 83 f8 03          	cmp    rax,0x3
  20a2e1:	73 18                	jae    20a2fb <init_vdso_clock_gettime+0x5b>
  20a2e3:	49 c7 c0 ff ff ff ff 	mov    r8,0xffffffffffffffff
  20a2ea:	45 31 f6             	xor    r14d,r14d
            i += 1;
            ph_addr += eh.e_phentsize;
        }) {
            const this_ph = @intToPtr(*elf.Phdr, ph_addr);
            switch (this_ph.p_type) {
  20a2ed:	48 85 ed             	test   rbp,rbp
  20a2f0:	0f 85 ec 00 00 00    	jne    20a3e2 <init_vdso_clock_gettime+0x142>
  20a2f6:	e9 29 01 00 00       	jmp    20a424 <init_vdso_clock_gettime+0x184>
        while (i < eh.e_phnum) : ({
  20a2fb:	48 89 e8             	mov    rax,rbp
  20a2fe:	48 29 d0             	sub    rax,rdx
  20a301:	49 c7 c0 ff ff ff ff 	mov    r8,0xffffffffffffffff
  20a308:	45 31 f6             	xor    r14d,r14d
  20a30b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  20a310:	48 89 da             	mov    rdx,rbx
            switch (this_ph.p_type) {
  20a313:	8b 1a                	mov    ebx,DWORD PTR [rdx]
  20a315:	83 fb 02             	cmp    ebx,0x2
  20a318:	74 66                	je     20a380 <init_vdso_clock_gettime+0xe0>
  20a31a:	83 fb 01             	cmp    ebx,0x1
  20a31d:	75 0b                	jne    20a32a <init_vdso_clock_gettime+0x8a>
  20a31f:	4c 8b 42 08          	mov    r8,QWORD PTR [rdx+0x8]
                elf.PT_LOAD => base = vdso_addr + this_ph.p_offset - this_ph.p_vaddr,
  20a323:	4d 01 c8             	add    r8,r9
  20a326:	4c 2b 42 10          	sub    r8,QWORD PTR [rdx+0x10]
            switch (this_ph.p_type) {
  20a32a:	8b 1c 0a             	mov    ebx,DWORD PTR [rdx+rcx*1]
            ph_addr += eh.e_phentsize;
  20a32d:	48 01 ca             	add    rdx,rcx
            switch (this_ph.p_type) {
  20a330:	83 fb 01             	cmp    ebx,0x1
  20a333:	74 5d                	je     20a392 <init_vdso_clock_gettime+0xf2>
  20a335:	83 fb 02             	cmp    ebx,0x2
  20a338:	75 07                	jne    20a341 <init_vdso_clock_gettime+0xa1>
  20a33a:	4c 8b 72 08          	mov    r14,QWORD PTR [rdx+0x8]
                elf.PT_DYNAMIC => maybe_dynv = @intToPtr([*]usize, vdso_addr + this_ph.p_offset),
  20a33e:	4d 01 ce             	add    r14,r9
            switch (this_ph.p_type) {
  20a341:	8b 1c 11             	mov    ebx,DWORD PTR [rcx+rdx*1]
            ph_addr += eh.e_phentsize;
  20a344:	48 01 ca             	add    rdx,rcx
            switch (this_ph.p_type) {
  20a347:	83 fb 01             	cmp    ebx,0x1
  20a34a:	74 5c                	je     20a3a8 <init_vdso_clock_gettime+0x108>
  20a34c:	83 fb 02             	cmp    ebx,0x2
  20a34f:	75 07                	jne    20a358 <init_vdso_clock_gettime+0xb8>
  20a351:	4c 8b 72 08          	mov    r14,QWORD PTR [rdx+0x8]
                elf.PT_DYNAMIC => maybe_dynv = @intToPtr([*]usize, vdso_addr + this_ph.p_offset),
  20a355:	4d 01 ce             	add    r14,r9
            switch (this_ph.p_type) {
  20a358:	8b 1c 11             	mov    ebx,DWORD PTR [rcx+rdx*1]
            ph_addr += eh.e_phentsize;
  20a35b:	48 01 ca             	add    rdx,rcx
            switch (this_ph.p_type) {
  20a35e:	83 fb 01             	cmp    ebx,0x1
  20a361:	74 5b                	je     20a3be <init_vdso_clock_gettime+0x11e>
  20a363:	83 fb 02             	cmp    ebx,0x2
  20a366:	75 07                	jne    20a36f <init_vdso_clock_gettime+0xcf>
  20a368:	4c 8b 72 08          	mov    r14,QWORD PTR [rdx+0x8]
                elf.PT_DYNAMIC => maybe_dynv = @intToPtr([*]usize, vdso_addr + this_ph.p_offset),
  20a36c:	4d 01 ce             	add    r14,r9
        while (i < eh.e_phnum) : ({
  20a36f:	48 8d 1c 0a          	lea    rbx,[rdx+rcx*1]
  20a373:	48 83 c0 04          	add    rax,0x4
  20a377:	75 97                	jne    20a310 <init_vdso_clock_gettime+0x70>
  20a379:	eb 5c                	jmp    20a3d7 <init_vdso_clock_gettime+0x137>
  20a37b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  20a380:	4c 8b 72 08          	mov    r14,QWORD PTR [rdx+0x8]
                elf.PT_DYNAMIC => maybe_dynv = @intToPtr([*]usize, vdso_addr + this_ph.p_offset),
  20a384:	4d 01 ce             	add    r14,r9
            switch (this_ph.p_type) {
  20a387:	8b 1c 0a             	mov    ebx,DWORD PTR [rdx+rcx*1]
            ph_addr += eh.e_phentsize;
  20a38a:	48 01 ca             	add    rdx,rcx
            switch (this_ph.p_type) {
  20a38d:	83 fb 01             	cmp    ebx,0x1
  20a390:	75 a3                	jne    20a335 <init_vdso_clock_gettime+0x95>
  20a392:	4c 8b 42 08          	mov    r8,QWORD PTR [rdx+0x8]
                elf.PT_LOAD => base = vdso_addr + this_ph.p_offset - this_ph.p_vaddr,
  20a396:	4d 01 c8             	add    r8,r9
  20a399:	4c 2b 42 10          	sub    r8,QWORD PTR [rdx+0x10]
            switch (this_ph.p_type) {
  20a39d:	8b 1c 11             	mov    ebx,DWORD PTR [rcx+rdx*1]
            ph_addr += eh.e_phentsize;
  20a3a0:	48 01 ca             	add    rdx,rcx
            switch (this_ph.p_type) {
  20a3a3:	83 fb 01             	cmp    ebx,0x1
  20a3a6:	75 a4                	jne    20a34c <init_vdso_clock_gettime+0xac>
  20a3a8:	4c 8b 42 08          	mov    r8,QWORD PTR [rdx+0x8]
                elf.PT_LOAD => base = vdso_addr + this_ph.p_offset - this_ph.p_vaddr,
  20a3ac:	4d 01 c8             	add    r8,r9
  20a3af:	4c 2b 42 10          	sub    r8,QWORD PTR [rdx+0x10]
            switch (this_ph.p_type) {
  20a3b3:	8b 1c 11             	mov    ebx,DWORD PTR [rcx+rdx*1]
            ph_addr += eh.e_phentsize;
  20a3b6:	48 01 ca             	add    rdx,rcx
            switch (this_ph.p_type) {
  20a3b9:	83 fb 01             	cmp    ebx,0x1
  20a3bc:	75 a5                	jne    20a363 <init_vdso_clock_gettime+0xc3>
  20a3be:	4c 8b 42 08          	mov    r8,QWORD PTR [rdx+0x8]
                elf.PT_LOAD => base = vdso_addr + this_ph.p_offset - this_ph.p_vaddr,
  20a3c2:	4d 01 c8             	add    r8,r9
  20a3c5:	4c 2b 42 10          	sub    r8,QWORD PTR [rdx+0x10]
        while (i < eh.e_phnum) : ({
  20a3c9:	48 8d 1c 0a          	lea    rbx,[rdx+rcx*1]
  20a3cd:	48 83 c0 04          	add    rax,0x4
  20a3d1:	0f 85 39 ff ff ff    	jne    20a310 <init_vdso_clock_gettime+0x70>
  20a3d7:	48 01 ca             	add    rdx,rcx
  20a3da:	48 89 d3             	mov    rbx,rdx
            switch (this_ph.p_type) {
  20a3dd:	48 85 ed             	test   rbp,rbp
  20a3e0:	74 42                	je     20a424 <init_vdso_clock_gettime+0x184>
  20a3e2:	48 f7 dd             	neg    rbp
  20a3e5:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20a3ec:	00 00 00 00 
  20a3f0:	8b 03                	mov    eax,DWORD PTR [rbx]
  20a3f2:	83 f8 01             	cmp    eax,0x1
  20a3f5:	74 19                	je     20a410 <init_vdso_clock_gettime+0x170>
  20a3f7:	83 f8 02             	cmp    eax,0x2
  20a3fa:	75 07                	jne    20a403 <init_vdso_clock_gettime+0x163>
  20a3fc:	4c 8b 73 08          	mov    r14,QWORD PTR [rbx+0x8]
                elf.PT_DYNAMIC => maybe_dynv = @intToPtr([*]usize, vdso_addr + this_ph.p_offset),
  20a400:	4d 01 ce             	add    r14,r9
            ph_addr += eh.e_phentsize;
  20a403:	48 01 cb             	add    rbx,rcx
        while (i < eh.e_phnum) : ({
  20a406:	48 83 c5 01          	add    rbp,0x1
  20a40a:	75 e4                	jne    20a3f0 <init_vdso_clock_gettime+0x150>
  20a40c:	eb 16                	jmp    20a424 <init_vdso_clock_gettime+0x184>
  20a40e:	66 90                	xchg   ax,ax
  20a410:	4c 8b 43 08          	mov    r8,QWORD PTR [rbx+0x8]
                elf.PT_LOAD => base = vdso_addr + this_ph.p_offset - this_ph.p_vaddr,
  20a414:	4d 01 c8             	add    r8,r9
  20a417:	4c 2b 43 10          	sub    r8,QWORD PTR [rbx+0x10]
            ph_addr += eh.e_phentsize;
  20a41b:	48 01 cb             	add    rbx,rcx
        while (i < eh.e_phnum) : ({
  20a41e:	48 83 c5 01          	add    rbp,0x1
  20a422:	75 cc                	jne    20a3f0 <init_vdso_clock_gettime+0x150>
                else => {},
            }
        }
    }
    const dynv = maybe_dynv orelse return 0;
    if (base == @maxValue(usize)) return 0;
  20a424:	49 83 f8 ff          	cmp    r8,0xffffffffffffffff
    const dynv = maybe_dynv orelse return 0;
  20a428:	0f 84 df 03 00 00    	je     20a80d <init_vdso_clock_gettime+0x56d>
  20a42e:	4d 85 f6             	test   r14,r14
  20a431:	0f 84 d6 03 00 00    	je     20a80d <init_vdso_clock_gettime+0x56d>
    var maybe_versym: ?[*]u16 = null;
    var maybe_verdef: ?*elf.Verdef = null;

    {
        var i: usize = 0;
        while (dynv[i] != 0) : (i += 2) {
  20a437:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  20a43a:	48 85 d2             	test   rdx,rdx
  20a43d:	0f 84 ca 03 00 00    	je     20a80d <init_vdso_clock_gettime+0x56d>
            const p = base + dynv[i + 1];
  20a443:	49 83 c6 10          	add    r14,0x10
  20a447:	45 31 ff             	xor    r15d,r15d
  20a44a:	45 31 db             	xor    r11d,r11d
  20a44d:	45 31 d2             	xor    r10d,r10d
  20a450:	31 ed                	xor    ebp,ebp
  20a452:	45 31 ed             	xor    r13d,r13d
  20a455:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20a45c:	00 00 00 00 
  20a460:	49 8b 4e f8          	mov    rcx,QWORD PTR [r14-0x8]
  20a464:	4c 01 c1             	add    rcx,r8
            switch (dynv[i]) {
  20a467:	48 83 fa 05          	cmp    rdx,0x5
  20a46b:	7e 33                	jle    20a4a0 <init_vdso_clock_gettime+0x200>
  20a46d:	48 83 fa 06          	cmp    rdx,0x6
  20a471:	74 4b                	je     20a4be <init_vdso_clock_gettime+0x21e>
  20a473:	48 81 fa f0 ff ff 6f 	cmp    rdx,0x6ffffff0
  20a47a:	74 53                	je     20a4cf <init_vdso_clock_gettime+0x22f>
  20a47c:	48 81 fa fc ff ff 6f 	cmp    rdx,0x6ffffffc
  20a483:	75 2b                	jne    20a4b0 <init_vdso_clock_gettime+0x210>
  20a485:	49 89 cb             	mov    r11,rcx
        while (dynv[i] != 0) : (i += 2) {
  20a488:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  20a48b:	49 83 c6 10          	add    r14,0x10
  20a48f:	48 85 d2             	test   rdx,rdx
  20a492:	75 cc                	jne    20a460 <init_vdso_clock_gettime+0x1c0>
  20a494:	eb 5d                	jmp    20a4f3 <init_vdso_clock_gettime+0x253>
  20a496:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  20a49d:	00 00 00 
            switch (dynv[i]) {
  20a4a0:	48 83 fa 04          	cmp    rdx,0x4
  20a4a4:	74 3a                	je     20a4e0 <init_vdso_clock_gettime+0x240>
  20a4a6:	48 83 fa 05          	cmp    rdx,0x5
  20a4aa:	75 04                	jne    20a4b0 <init_vdso_clock_gettime+0x210>
  20a4ac:	49 89 cf             	mov    r15,rcx
  20a4af:	90                   	nop
        while (dynv[i] != 0) : (i += 2) {
  20a4b0:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  20a4b3:	49 83 c6 10          	add    r14,0x10
  20a4b7:	48 85 d2             	test   rdx,rdx
  20a4ba:	75 a4                	jne    20a460 <init_vdso_clock_gettime+0x1c0>
  20a4bc:	eb 35                	jmp    20a4f3 <init_vdso_clock_gettime+0x253>
  20a4be:	49 89 cd             	mov    r13,rcx
  20a4c1:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  20a4c4:	49 83 c6 10          	add    r14,0x10
  20a4c8:	48 85 d2             	test   rdx,rdx
  20a4cb:	75 93                	jne    20a460 <init_vdso_clock_gettime+0x1c0>
  20a4cd:	eb 24                	jmp    20a4f3 <init_vdso_clock_gettime+0x253>
  20a4cf:	49 89 ca             	mov    r10,rcx
  20a4d2:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  20a4d5:	49 83 c6 10          	add    r14,0x10
  20a4d9:	48 85 d2             	test   rdx,rdx
  20a4dc:	75 82                	jne    20a460 <init_vdso_clock_gettime+0x1c0>
  20a4de:	eb 13                	jmp    20a4f3 <init_vdso_clock_gettime+0x253>
  20a4e0:	48 89 cd             	mov    rbp,rcx
  20a4e3:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  20a4e6:	49 83 c6 10          	add    r14,0x10
  20a4ea:	48 85 d2             	test   rdx,rdx
  20a4ed:	0f 85 6d ff ff ff    	jne    20a460 <init_vdso_clock_gettime+0x1c0>
        }
    }

    const strings = maybe_strings orelse return 0;
    const syms = maybe_syms orelse return 0;
    const hashtab = maybe_hashtab orelse return 0;
  20a4f3:	48 85 ed             	test   rbp,rbp
    const strings = maybe_strings orelse return 0;
  20a4f6:	0f 84 11 03 00 00    	je     20a80d <init_vdso_clock_gettime+0x56d>
  20a4fc:	4d 85 ed             	test   r13,r13
  20a4ff:	0f 84 08 03 00 00    	je     20a80d <init_vdso_clock_gettime+0x56d>
  20a505:	4d 85 ff             	test   r15,r15
  20a508:	0f 84 ff 02 00 00    	je     20a80d <init_vdso_clock_gettime+0x56d>
    if (maybe_verdef == null) maybe_versym = null;
  20a50e:	4d 85 db             	test   r11,r11
  20a511:	4d 0f 44 d3          	cmove  r10,r11

    const OK_TYPES = (1 << elf.STT_NOTYPE | 1 << elf.STT_OBJECT | 1 << elf.STT_FUNC | 1 << elf.STT_COMMON);
    const OK_BINDS = (1 << elf.STB_GLOBAL | 1 << elf.STB_WEAK | 1 << elf.STB_GNU_UNIQUE);

    var i: usize = 0;
    while (i < hashtab[1]) : (i += 1) {
  20a515:	44 8b 4d 04          	mov    r9d,DWORD PTR [rbp+0x4]
  20a519:	4d 85 c9             	test   r9,r9
  20a51c:	0f 84 eb 02 00 00    	je     20a80d <init_vdso_clock_gettime+0x56d>
  20a522:	31 d2                	xor    edx,edx
  20a524:	4d 85 d2             	test   r10,r10
  20a527:	0f 84 e5 01 00 00    	je     20a712 <init_vdso_clock_gettime+0x472>
  20a52d:	41 bc 27 00 00 00    	mov    r12d,0x27
  20a533:	41 be 06 04 00 00    	mov    r14d,0x406
  20a539:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
        if (0 == (u32(1) << @intCast(u5, syms[i].st_info & 0xf) & OK_TYPES)) continue;
  20a540:	48 8d 0c 52          	lea    rcx,[rdx+rdx*2]
  20a544:	41 8a 5c cd 04       	mov    bl,BYTE PTR [r13+rcx*8+0x4]
  20a549:	89 d8                	mov    eax,ebx
  20a54b:	24 0f                	and    al,0xf
  20a54d:	0f b6 c0             	movzx  eax,al
  20a550:	41 0f a3 c4          	bt     r12d,eax
  20a554:	0f 83 a6 01 00 00    	jae    20a700 <init_vdso_clock_gettime+0x460>
        if (0 == (u32(1) << @intCast(u5, syms[i].st_info >> 4) & OK_BINDS)) continue;
  20a55a:	c0 eb 04             	shr    bl,0x4
  20a55d:	0f b6 c3             	movzx  eax,bl
  20a560:	41 0f a3 c6          	bt     r14d,eax
  20a564:	0f 83 96 01 00 00    	jae    20a700 <init_vdso_clock_gettime+0x460>
        if (0 == syms[i].st_shndx) continue;
  20a56a:	66 41 83 7c cd 06 00 	cmp    WORD PTR [r13+rcx*8+0x6],0x0
  20a571:	0f 84 89 01 00 00    	je     20a700 <init_vdso_clock_gettime+0x460>
        if (!mem.eql(u8, name, cstr.toSliceConst(strings + syms[i].st_name))) continue;
  20a577:	41 8b 6c cd 00       	mov    ebp,DWORD PTR [r13+rcx*8+0x0]
  20a57c:	4c 01 fd             	add    rbp,r15
  20a57f:	48 c7 c1 eb ff ff ff 	mov    rcx,0xffffffffffffffeb
  20a586:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  20a58d:	00 00 00 
    return true;
}

pub fn len(comptime T: type, ptr: [*]const T) usize {
    var count: usize = 0;
    while (ptr[count] != 0) : (count += 1) {}
  20a590:	80 7c 0d 15 00       	cmp    BYTE PTR [rbp+rcx*1+0x15],0x0
  20a595:	48 8d 49 01          	lea    rcx,[rcx+0x1]
  20a599:	75 f5                	jne    20a590 <init_vdso_clock_gettime+0x2f0>
    if (a.len != b.len) return false;
  20a59b:	48 85 c9             	test   rcx,rcx
  20a59e:	0f 85 5c 01 00 00    	jne    20a700 <init_vdso_clock_gettime+0x460>
        if (b[index] != item) return false;
  20a5a4:	80 7d 00 5f          	cmp    BYTE PTR [rbp+0x0],0x5f
  20a5a8:	0f 85 52 01 00 00    	jne    20a700 <init_vdso_clock_gettime+0x460>
  20a5ae:	80 7d 01 5f          	cmp    BYTE PTR [rbp+0x1],0x5f
  20a5b2:	0f 85 48 01 00 00    	jne    20a700 <init_vdso_clock_gettime+0x460>
  20a5b8:	80 7d 02 76          	cmp    BYTE PTR [rbp+0x2],0x76
  20a5bc:	0f 85 3e 01 00 00    	jne    20a700 <init_vdso_clock_gettime+0x460>
  20a5c2:	80 7d 03 64          	cmp    BYTE PTR [rbp+0x3],0x64
  20a5c6:	0f 85 34 01 00 00    	jne    20a700 <init_vdso_clock_gettime+0x460>
  20a5cc:	80 7d 04 73          	cmp    BYTE PTR [rbp+0x4],0x73
  20a5d0:	0f 85 2a 01 00 00    	jne    20a700 <init_vdso_clock_gettime+0x460>
  20a5d6:	80 7d 05 6f          	cmp    BYTE PTR [rbp+0x5],0x6f
  20a5da:	0f 85 20 01 00 00    	jne    20a700 <init_vdso_clock_gettime+0x460>
  20a5e0:	80 7d 06 5f          	cmp    BYTE PTR [rbp+0x6],0x5f
  20a5e4:	0f 85 16 01 00 00    	jne    20a700 <init_vdso_clock_gettime+0x460>
  20a5ea:	80 7d 07 63          	cmp    BYTE PTR [rbp+0x7],0x63
  20a5ee:	0f 85 0c 01 00 00    	jne    20a700 <init_vdso_clock_gettime+0x460>
  20a5f4:	80 7d 08 6c          	cmp    BYTE PTR [rbp+0x8],0x6c
  20a5f8:	0f 85 02 01 00 00    	jne    20a700 <init_vdso_clock_gettime+0x460>
  20a5fe:	80 7d 09 6f          	cmp    BYTE PTR [rbp+0x9],0x6f
  20a602:	0f 85 f8 00 00 00    	jne    20a700 <init_vdso_clock_gettime+0x460>
  20a608:	80 7d 0a 63          	cmp    BYTE PTR [rbp+0xa],0x63
  20a60c:	0f 85 ee 00 00 00    	jne    20a700 <init_vdso_clock_gettime+0x460>
  20a612:	80 7d 0b 6b          	cmp    BYTE PTR [rbp+0xb],0x6b
  20a616:	0f 85 e4 00 00 00    	jne    20a700 <init_vdso_clock_gettime+0x460>
  20a61c:	80 7d 0c 5f          	cmp    BYTE PTR [rbp+0xc],0x5f
  20a620:	0f 85 da 00 00 00    	jne    20a700 <init_vdso_clock_gettime+0x460>
  20a626:	80 7d 0d 67          	cmp    BYTE PTR [rbp+0xd],0x67
  20a62a:	0f 85 d0 00 00 00    	jne    20a700 <init_vdso_clock_gettime+0x460>
  20a630:	80 7d 0e 65          	cmp    BYTE PTR [rbp+0xe],0x65
  20a634:	0f 85 c6 00 00 00    	jne    20a700 <init_vdso_clock_gettime+0x460>
  20a63a:	80 7d 0f 74          	cmp    BYTE PTR [rbp+0xf],0x74
  20a63e:	0f 85 bc 00 00 00    	jne    20a700 <init_vdso_clock_gettime+0x460>
  20a644:	80 7d 10 74          	cmp    BYTE PTR [rbp+0x10],0x74
  20a648:	0f 85 b2 00 00 00    	jne    20a700 <init_vdso_clock_gettime+0x460>
  20a64e:	80 7d 11 69          	cmp    BYTE PTR [rbp+0x11],0x69
  20a652:	0f 85 a8 00 00 00    	jne    20a700 <init_vdso_clock_gettime+0x460>
  20a658:	80 7d 12 6d          	cmp    BYTE PTR [rbp+0x12],0x6d
  20a65c:	0f 85 9e 00 00 00    	jne    20a700 <init_vdso_clock_gettime+0x460>
  20a662:	80 7d 13 65          	cmp    BYTE PTR [rbp+0x13],0x65
  20a666:	0f 85 94 00 00 00    	jne    20a700 <init_vdso_clock_gettime+0x460>
        if (maybe_versym) |versym| {
            if (!checkver(maybe_verdef.?, versym[i], vername, strings))
  20a66c:	41 0f b7 2c 52       	movzx  ebp,WORD PTR [r10+rdx*2]
  20a671:	4c 89 d9             	mov    rcx,r11

fn checkver(def_arg: *elf.Verdef, vsym_arg: i32, vername: []const u8, strings: [*]u8) bool {
    var def = def_arg;
    const vsym = @bitCast(u32, vsym_arg) & 0x7fff;
    while (true) {
        if (0 == (def.vd_flags & elf.VER_FLG_BASE) and (def.vd_ndx & 0x7fff) == vsym)
  20a674:	f6 41 02 01          	test   BYTE PTR [rcx+0x2],0x1
  20a678:	75 1c                	jne    20a696 <init_vdso_clock_gettime+0x3f6>
  20a67a:	eb 09                	jmp    20a685 <init_vdso_clock_gettime+0x3e5>
            break;
        if (def.vd_next == 0)
            return false;
        def = @intToPtr(*elf.Verdef, @ptrToInt(def) + def.vd_next);
  20a67c:	48 01 d9             	add    rcx,rbx
        if (0 == (def.vd_flags & elf.VER_FLG_BASE) and (def.vd_ndx & 0x7fff) == vsym)
  20a67f:	f6 41 02 01          	test   BYTE PTR [rcx+0x2],0x1
  20a683:	75 11                	jne    20a696 <init_vdso_clock_gettime+0x3f6>
  20a685:	0f b7 41 04          	movzx  eax,WORD PTR [rcx+0x4]
  20a689:	66 31 e8             	xor    ax,bp
  20a68c:	25 ff 7f 00 00       	and    eax,0x7fff
  20a691:	66 85 c0             	test   ax,ax
  20a694:	74 0a                	je     20a6a0 <init_vdso_clock_gettime+0x400>
        if (def.vd_next == 0)
  20a696:	8b 59 10             	mov    ebx,DWORD PTR [rcx+0x10]
  20a699:	48 85 db             	test   rbx,rbx
  20a69c:	75 de                	jne    20a67c <init_vdso_clock_gettime+0x3dc>
  20a69e:	eb 60                	jmp    20a700 <init_vdso_clock_gettime+0x460>
    }
    const aux = @intToPtr(*elf.Verdaux, @ptrToInt(def) + def.vd_aux);
  20a6a0:	8b 41 0c             	mov    eax,DWORD PTR [rcx+0xc]
    return mem.eql(u8, vername, cstr.toSliceConst(strings + aux.vda_name));
  20a6a3:	8b 2c 08             	mov    ebp,DWORD PTR [rax+rcx*1]
  20a6a6:	4c 01 fd             	add    rbp,r15
  20a6a9:	48 c7 c1 f6 ff ff ff 	mov    rcx,0xfffffffffffffff6
    while (ptr[count] != 0) : (count += 1) {}
  20a6b0:	80 7c 0d 0a 00       	cmp    BYTE PTR [rbp+rcx*1+0xa],0x0
  20a6b5:	48 8d 49 01          	lea    rcx,[rcx+0x1]
  20a6b9:	75 f5                	jne    20a6b0 <init_vdso_clock_gettime+0x410>
    if (a.len != b.len) return false;
  20a6bb:	48 85 c9             	test   rcx,rcx
  20a6be:	75 40                	jne    20a700 <init_vdso_clock_gettime+0x460>
        if (b[index] != item) return false;
  20a6c0:	80 7d 00 4c          	cmp    BYTE PTR [rbp+0x0],0x4c
  20a6c4:	75 3a                	jne    20a700 <init_vdso_clock_gettime+0x460>
  20a6c6:	80 7d 01 49          	cmp    BYTE PTR [rbp+0x1],0x49
  20a6ca:	75 34                	jne    20a700 <init_vdso_clock_gettime+0x460>
  20a6cc:	80 7d 02 4e          	cmp    BYTE PTR [rbp+0x2],0x4e
  20a6d0:	75 2e                	jne    20a700 <init_vdso_clock_gettime+0x460>
  20a6d2:	80 7d 03 55          	cmp    BYTE PTR [rbp+0x3],0x55
  20a6d6:	75 28                	jne    20a700 <init_vdso_clock_gettime+0x460>
  20a6d8:	80 7d 04 58          	cmp    BYTE PTR [rbp+0x4],0x58
  20a6dc:	75 22                	jne    20a700 <init_vdso_clock_gettime+0x460>
  20a6de:	80 7d 05 5f          	cmp    BYTE PTR [rbp+0x5],0x5f
  20a6e2:	75 1c                	jne    20a700 <init_vdso_clock_gettime+0x460>
  20a6e4:	80 7d 06 32          	cmp    BYTE PTR [rbp+0x6],0x32
  20a6e8:	75 16                	jne    20a700 <init_vdso_clock_gettime+0x460>
  20a6ea:	80 7d 07 2e          	cmp    BYTE PTR [rbp+0x7],0x2e
  20a6ee:	75 10                	jne    20a700 <init_vdso_clock_gettime+0x460>
  20a6f0:	80 7d 08 36          	cmp    BYTE PTR [rbp+0x8],0x36
            if (!checkver(maybe_verdef.?, versym[i], vername, strings))
  20a6f4:	0f 84 37 01 00 00    	je     20a831 <init_vdso_clock_gettime+0x591>
  20a6fa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
    while (i < hashtab[1]) : (i += 1) {
  20a700:	48 83 c2 01          	add    rdx,0x1
  20a704:	4c 39 ca             	cmp    rdx,r9
  20a707:	0f 82 33 fe ff ff    	jb     20a540 <init_vdso_clock_gettime+0x2a0>
  20a70d:	e9 fb 00 00 00       	jmp    20a80d <init_vdso_clock_gettime+0x56d>
  20a712:	bd 27 00 00 00       	mov    ebp,0x27
  20a717:	41 ba 06 04 00 00    	mov    r10d,0x406
  20a71d:	0f 1f 00             	nop    DWORD PTR [rax]
        if (0 == (u32(1) << @intCast(u5, syms[i].st_info & 0xf) & OK_TYPES)) continue;
  20a720:	48 8d 0c 52          	lea    rcx,[rdx+rdx*2]
  20a724:	41 8a 44 cd 04       	mov    al,BYTE PTR [r13+rcx*8+0x4]
  20a729:	89 c3                	mov    ebx,eax
  20a72b:	80 e3 0f             	and    bl,0xf
  20a72e:	0f b6 db             	movzx  ebx,bl
  20a731:	0f a3 dd             	bt     ebp,ebx
  20a734:	0f 83 c6 00 00 00    	jae    20a800 <init_vdso_clock_gettime+0x560>
        if (0 == (u32(1) << @intCast(u5, syms[i].st_info >> 4) & OK_BINDS)) continue;
  20a73a:	c0 e8 04             	shr    al,0x4
  20a73d:	0f b6 c0             	movzx  eax,al
  20a740:	41 0f a3 c2          	bt     r10d,eax
  20a744:	0f 83 b6 00 00 00    	jae    20a800 <init_vdso_clock_gettime+0x560>
        if (0 == syms[i].st_shndx) continue;
  20a74a:	66 41 83 7c cd 06 00 	cmp    WORD PTR [r13+rcx*8+0x6],0x0
  20a751:	0f 84 a9 00 00 00    	je     20a800 <init_vdso_clock_gettime+0x560>
        if (!mem.eql(u8, name, cstr.toSliceConst(strings + syms[i].st_name))) continue;
  20a757:	41 8b 5c cd 00       	mov    ebx,DWORD PTR [r13+rcx*8+0x0]
  20a75c:	4c 01 fb             	add    rbx,r15
  20a75f:	48 c7 c1 eb ff ff ff 	mov    rcx,0xffffffffffffffeb
  20a766:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  20a76d:	00 00 00 
    while (ptr[count] != 0) : (count += 1) {}
  20a770:	80 7c 0b 15 00       	cmp    BYTE PTR [rbx+rcx*1+0x15],0x0
  20a775:	48 8d 49 01          	lea    rcx,[rcx+0x1]
  20a779:	75 f5                	jne    20a770 <init_vdso_clock_gettime+0x4d0>
    if (a.len != b.len) return false;
  20a77b:	48 85 c9             	test   rcx,rcx
  20a77e:	0f 85 7c 00 00 00    	jne    20a800 <init_vdso_clock_gettime+0x560>
        if (b[index] != item) return false;
  20a784:	80 3b 5f             	cmp    BYTE PTR [rbx],0x5f
  20a787:	75 77                	jne    20a800 <init_vdso_clock_gettime+0x560>
  20a789:	80 7b 01 5f          	cmp    BYTE PTR [rbx+0x1],0x5f
  20a78d:	75 71                	jne    20a800 <init_vdso_clock_gettime+0x560>
  20a78f:	80 7b 02 76          	cmp    BYTE PTR [rbx+0x2],0x76
  20a793:	75 6b                	jne    20a800 <init_vdso_clock_gettime+0x560>
  20a795:	80 7b 03 64          	cmp    BYTE PTR [rbx+0x3],0x64
  20a799:	75 65                	jne    20a800 <init_vdso_clock_gettime+0x560>
  20a79b:	80 7b 04 73          	cmp    BYTE PTR [rbx+0x4],0x73
  20a79f:	75 5f                	jne    20a800 <init_vdso_clock_gettime+0x560>
  20a7a1:	80 7b 05 6f          	cmp    BYTE PTR [rbx+0x5],0x6f
  20a7a5:	75 59                	jne    20a800 <init_vdso_clock_gettime+0x560>
  20a7a7:	80 7b 06 5f          	cmp    BYTE PTR [rbx+0x6],0x5f
  20a7ab:	75 53                	jne    20a800 <init_vdso_clock_gettime+0x560>
  20a7ad:	80 7b 07 63          	cmp    BYTE PTR [rbx+0x7],0x63
  20a7b1:	75 4d                	jne    20a800 <init_vdso_clock_gettime+0x560>
  20a7b3:	80 7b 08 6c          	cmp    BYTE PTR [rbx+0x8],0x6c
  20a7b7:	75 47                	jne    20a800 <init_vdso_clock_gettime+0x560>
  20a7b9:	80 7b 09 6f          	cmp    BYTE PTR [rbx+0x9],0x6f
  20a7bd:	75 41                	jne    20a800 <init_vdso_clock_gettime+0x560>
  20a7bf:	80 7b 0a 63          	cmp    BYTE PTR [rbx+0xa],0x63
  20a7c3:	75 3b                	jne    20a800 <init_vdso_clock_gettime+0x560>
  20a7c5:	80 7b 0b 6b          	cmp    BYTE PTR [rbx+0xb],0x6b
  20a7c9:	75 35                	jne    20a800 <init_vdso_clock_gettime+0x560>
  20a7cb:	80 7b 0c 5f          	cmp    BYTE PTR [rbx+0xc],0x5f
  20a7cf:	75 2f                	jne    20a800 <init_vdso_clock_gettime+0x560>
  20a7d1:	80 7b 0d 67          	cmp    BYTE PTR [rbx+0xd],0x67
  20a7d5:	75 29                	jne    20a800 <init_vdso_clock_gettime+0x560>
  20a7d7:	80 7b 0e 65          	cmp    BYTE PTR [rbx+0xe],0x65
  20a7db:	75 23                	jne    20a800 <init_vdso_clock_gettime+0x560>
  20a7dd:	80 7b 0f 74          	cmp    BYTE PTR [rbx+0xf],0x74
  20a7e1:	75 1d                	jne    20a800 <init_vdso_clock_gettime+0x560>
  20a7e3:	80 7b 10 74          	cmp    BYTE PTR [rbx+0x10],0x74
  20a7e7:	75 17                	jne    20a800 <init_vdso_clock_gettime+0x560>
  20a7e9:	80 7b 11 69          	cmp    BYTE PTR [rbx+0x11],0x69
  20a7ed:	75 11                	jne    20a800 <init_vdso_clock_gettime+0x560>
  20a7ef:	80 7b 12 6d          	cmp    BYTE PTR [rbx+0x12],0x6d
  20a7f3:	75 0b                	jne    20a800 <init_vdso_clock_gettime+0x560>
  20a7f5:	80 7b 13 65          	cmp    BYTE PTR [rbx+0x13],0x65
  20a7f9:	74 36                	je     20a831 <init_vdso_clock_gettime+0x591>
  20a7fb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
    while (i < hashtab[1]) : (i += 1) {
  20a800:	48 83 c2 01          	add    rdx,0x1
  20a804:	4c 39 ca             	cmp    rdx,r9
  20a807:	0f 82 13 ff ff ff    	jb     20a720 <init_vdso_clock_gettime+0x480>
}
var vdso_clock_gettime = init_vdso_clock_gettime;
extern fn init_vdso_clock_gettime(clk: i32, ts: *timespec) usize {
    const addr = vdso.lookup(VDSO_CGT_VER, VDSO_CGT_SYM);
    var f = @intToPtr(@typeOf(init_vdso_clock_gettime), addr);
    _ = @cmpxchgStrong(@typeOf(init_vdso_clock_gettime), &vdso_clock_gettime, init_vdso_clock_gettime, f, builtin.AtomicOrder.Monotonic, builtin.AtomicOrder.Monotonic);
  20a80d:	48 8d 05 8c fa ff ff 	lea    rax,[rip+0xfffffffffffffa8c]        # 20a2a0 <init_vdso_clock_gettime>
  20a814:	31 c9                	xor    ecx,ecx
  20a816:	f0 48 0f b1 0d 29 08 	lock cmpxchg QWORD PTR [rip+0x40829],rcx        # 24b048 <vdso_clock_gettime>
  20a81d:	04 00 
    if (@ptrToInt(f) == 0) return @bitCast(usize, isize(-ENOSYS));
  20a81f:	48 c7 c0 da ff ff ff 	mov    rax,0xffffffffffffffda
  20a826:	5b                   	pop    rbx
  20a827:	41 5c                	pop    r12
  20a829:	41 5d                	pop    r13
  20a82b:	41 5e                	pop    r14
  20a82d:	41 5f                	pop    r15
  20a82f:	5d                   	pop    rbp
  20a830:	c3                   	ret    
        return base + syms[i].st_value;
  20a831:	48 8d 04 52          	lea    rax,[rdx+rdx*2]
  20a835:	4d 03 44 c5 08       	add    r8,QWORD PTR [r13+rax*8+0x8]
    _ = @cmpxchgStrong(@typeOf(init_vdso_clock_gettime), &vdso_clock_gettime, init_vdso_clock_gettime, f, builtin.AtomicOrder.Monotonic, builtin.AtomicOrder.Monotonic);
  20a83a:	48 8d 05 5f fa ff ff 	lea    rax,[rip+0xfffffffffffffa5f]        # 20a2a0 <init_vdso_clock_gettime>
  20a841:	f0 4c 0f b1 05 fe 07 	lock cmpxchg QWORD PTR [rip+0x407fe],r8        # 24b048 <vdso_clock_gettime>
  20a848:	04 00 
    if (@ptrToInt(f) == 0) return @bitCast(usize, isize(-ENOSYS));
  20a84a:	4d 85 c0             	test   r8,r8
  20a84d:	74 d0                	je     20a81f <init_vdso_clock_gettime+0x57f>
    return f(clk, ts);
  20a84f:	5b                   	pop    rbx
  20a850:	41 5c                	pop    r12
  20a852:	41 5d                	pop    r13
  20a854:	41 5e                	pop    r14
  20a856:	41 5f                	pop    r15
  20a858:	5d                   	pop    rbp
  20a859:	41 ff e0             	jmp    r8
  20a85c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

000000000020a860 <BmNoSelf.lfence>:
        }
        return std_dev;
    }
};

test "BmNoSelf.lfence" {
  20a860:	55                   	push   rbp
  20a861:	41 57                	push   r15
  20a863:	41 56                	push   r14
  20a865:	41 55                	push   r13
  20a867:	41 54                	push   r12
  20a869:	53                   	push   rbx
  20a86a:	48 81 ec f8 00 00 00 	sub    rsp,0xf8
  20a871:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20a878:	0f 1f 84 00 00 00 00 
  20a87f:	00 
    pub fn init() Mutex {
        return Mutex{ .lock = 0 };
    }

    pub fn acquire(self: *Mutex) Held {
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20a880:	b0 01                	mov    al,0x1
  20a882:	86 05 88 57 04 00    	xchg   BYTE PTR [rip+0x45788],al        # 250010 <stderr_mutex>
  20a888:	84 c0                	test   al,al
  20a88a:	75 f4                	jne    20a880 <BmNoSelf.lfence+0x20>
    if (stderr_stream) |st| {
  20a88c:	48 8b 3d 75 57 04 00 	mov    rdi,QWORD PTR [rip+0x45775]        # 250008 <stderr_stream>
  20a893:	48 85 ff             	test   rdi,rdi
  20a896:	74 09                	je     20a8a1 <BmNoSelf.lfence+0x41>
        pub const Error = WriteError;

        writeFn: fn (self: *Self, bytes: []const u8) Error!void,

        pub fn print(self: *Self, comptime format: []const u8, args: ...) !void {
            return std.fmt.format(self, Error, self.writeFn, format, args);
  20a898:	48 8b 05 a1 07 04 00 	mov    rax,QWORD PTR [rip+0x407a1]        # 24b040 <stderr_file_out_stream+0x8>
  20a89f:	eb 34                	jmp    20a8d5 <BmNoSelf.lfence+0x75>
        stderr_file = try io.getStdErr();
  20a8a1:	48 8d 05 88 07 04 00 	lea    rax,[rip+0x40788]        # 24b030 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20a8a8:	48 89 05 89 07 04 00 	mov    QWORD PTR [rip+0x40789],rax        # 24b038 <stderr_file_out_stream>
  20a8af:	48 8d 05 2a 51 01 00 	lea    rax,[rip+0x1512a]        # 21f9e0 <FileOutStream_writeFn>
  20a8b6:	48 89 05 83 07 04 00 	mov    QWORD PTR [rip+0x40783],rax        # 24b040 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  20a8bd:	c7 05 69 07 04 00 02 	mov    DWORD PTR [rip+0x40769],0x2        # 24b030 <stderr_file>
  20a8c4:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20a8c7:	48 8d 3d 72 07 04 00 	lea    rdi,[rip+0x40772]        # 24b040 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  20a8ce:	48 89 3d 33 57 04 00 	mov    QWORD PTR [rip+0x45733],rdi        # 250008 <stderr_stream>
        if (state != State.Start) {
            @compileError("Incomplete format string: " ++ fmt);
        }
    }
    if (start_index < fmt.len) {
        try output(context, fmt[start_index..]);
  20a8d5:	48 8d 35 3c 45 04 00 	lea    rsi,[rip+0x4453c]        # 24ee18 <__unnamed_3>
  20a8dc:	ff d0                	call   rax
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20a8de:	31 c0                	xor    eax,eax
  20a8e0:	86 05 2a 57 04 00    	xchg   BYTE PTR [rip+0x4572a],al        # 250010 <stderr_mutex>
  20a8e6:	3c 01                	cmp    al,0x1
    if (!ok) {
  20a8e8:	0f 85 8a 0a 00 00    	jne    20b378 <BmNoSelf.lfence+0xb18>
    // Since this is a test print a \n before we run
    warn("\n");

    // Create an instance of Benchmark and run
    var bm = Benchmark.init("BmNoSelf", std.debug.global_allocator);
  20a8ee:	c5 f8 10 05 d2 43 04 	vmovups xmm0,XMMWORD PTR [rip+0x443d2]        # 24ecc8 <__unnamed_4>
  20a8f5:	00 
  20a8f6:	c5 f8 29 44 24 20    	vmovaps XMMWORD PTR [rsp+0x20],xmm0
  20a8fc:	c5 fc 28 05 bc 58 ff 	vmovaps ymm0,YMMWORD PTR [rip+0xffffffffffff58bc]        # 2001c0 <__unnamed_44-0x40>
  20a903:	ff 
  20a904:	c5 fc 11 44 24 30    	vmovups YMMWORD PTR [rsp+0x30],ymm0
  20a90a:	c5 fa 6f 05 ae e4 ff 	vmovdqu xmm0,XMMWORD PTR [rip+0xffffffffffffe4ae]        # 208dc0 <__unnamed_5>
  20a911:	ff 
  20a912:	c5 f9 7f 44 24 50    	vmovdqa XMMWORD PTR [rsp+0x50],xmm0
  20a918:	48 8d 05 e1 06 04 00 	lea    rax,[rip+0x406e1]        # 24b000 <global_fixed_allocator>
  20a91f:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  20a924:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  20a928:	c5 fa 7f 44 24 68    	vmovdqu XMMWORD PTR [rsp+0x68],xmm0
  20a92e:	48 c7 44 24 78 00 00 	mov    QWORD PTR [rsp+0x78],0x0
  20a935:	00 00 
  20a937:	48 89 84 24 80 00 00 	mov    QWORD PTR [rsp+0x80],rax
  20a93e:	00 
  20a93f:	41 b6 01             	mov    r14b,0x1
  20a942:	49 bf 00 e8 76 48 17 	movabs r15,0x174876e800
  20a949:	00 00 00 
  20a94c:	bb 01 00 00 00       	mov    ebx,0x1
  20a951:	4c 8d a4 24 90 00 00 	lea    r12,[rsp+0x90]
  20a958:	00 
  20a959:	45 31 ed             	xor    r13d,r13d
            while (iterations <= pSelf.max_iterations) {
  20a95c:	4c 39 fb             	cmp    rbx,r15
  20a95f:	0f 87 2e 03 00 00    	ja     20ac93 <BmNoSelf.lfence+0x433>
  20a965:	eb 17                	jmp    20a97e <BmNoSelf.lfence+0x11e>
  20a967:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  20a96e:	00 00 
                        warn("iteratons:{} numer:{} denom:{}\n", iterations, numer, denom);
  20a970:	48 89 df             	mov    rdi,rbx
  20a973:	48 89 ca             	mov    rdx,rcx
  20a976:	c5 f8 77             	vzeroupper 
  20a979:	e8 f2 b1 00 00       	call   215b70 <warn.36>
                //On Linux, seccomp can do arbitrary things to our ability to call
                //  syscalls, including return any errno value it wants and
                //  inconsistently throwing errors. Since we can't account for
                //  abuses of seccomp in a reasonable way, we'll assume that if
                //  seccomp is going to block us it will at least do so consistently
                var ts: posix.timespec = undefined;
  20a97e:	c5 fa 6f 05 3a e4 ff 	vmovdqu xmm0,XMMWORD PTR [rip+0xffffffffffffe43a]        # 208dc0 <__unnamed_5>
  20a985:	ff 
  20a986:	c5 f9 7f 84 24 90 00 	vmovdqa XMMWORD PTR [rsp+0x90],xmm0
  20a98d:	00 00 
        : "rcx", "r11"
    );
}

pub fn syscall2(number: usize, arg1: usize, arg2: usize) usize {
    return asm volatile ("syscall"
  20a98f:	b8 e5 00 00 00       	mov    eax,0xe5
  20a994:	bf 01 00 00 00       	mov    edi,0x1
  20a999:	4c 89 e6             	mov    rsi,r12
  20a99c:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  20a99e:	48 89 c1             	mov    rcx,rax
  20a9a1:	48 f7 d9             	neg    rcx
  20a9a4:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  20a9aa:	b8 00 00 00 00       	mov    eax,0x0
  20a9af:	48 0f 46 c8          	cmovbe rcx,rax
                var result = posix.clock_getres(monotonic_clock_id, &ts);
                var errno = posix.getErrno(result);
                switch (errno) {
  20a9b3:	48 85 c9             	test   rcx,rcx
  20a9b6:	0f 85 97 09 00 00    	jne    20b353 <BmNoSelf.lfence+0xaf3>
        const f = @atomicLoad(@typeOf(init_vdso_clock_gettime), &vdso_clock_gettime, builtin.AtomicOrder.Unordered);
  20a9bc:	48 8b 05 85 06 04 00 	mov    rax,QWORD PTR [rip+0x40685]        # 24b048 <vdso_clock_gettime>
        if (@ptrToInt(f) != 0) {
  20a9c3:	48 85 c0             	test   rax,rax
  20a9c6:	74 24                	je     20a9ec <BmNoSelf.lfence+0x18c>
            const rc = f(clk_id, tp);
  20a9c8:	bf 01 00 00 00       	mov    edi,0x1
  20a9cd:	4c 89 e6             	mov    rsi,r12
  20a9d0:	c5 f8 77             	vzeroupper 
  20a9d3:	ff d0                	call   rax
            switch (rc) {
  20a9d5:	48 83 f8 ea          	cmp    rax,0xffffffffffffffea
  20a9d9:	0f 84 41 02 00 00    	je     20ac20 <BmNoSelf.lfence+0x3c0>
  20a9df:	48 85 c0             	test   rax,rax
  20a9e2:	c5 fa 6f 05 d6 e3 ff 	vmovdqu xmm0,XMMWORD PTR [rip+0xffffffffffffe3d6]        # 208dc0 <__unnamed_5>
  20a9e9:	ff 
  20a9ea:	74 0f                	je     20a9fb <BmNoSelf.lfence+0x19b>
  20a9ec:	b8 e4 00 00 00       	mov    eax,0xe4
  20a9f1:	bf 01 00 00 00       	mov    edi,0x1
  20a9f6:	4c 89 e6             	mov    rsi,r12
  20a9f9:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  20a9fb:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
                }
                self.resolution = @intCast(u64, ts.tv_sec) * u64(ns_per_s) + @intCast(u64, ts.tv_nsec);

                result = posix.clock_gettime(monotonic_clock_id, &ts);
                errno = posix.getErrno(result);
                if (errno != 0) return std.os.unexpectedErrorPosix(errno);
  20aa01:	0f 83 58 09 00 00    	jae    20b35f <BmNoSelf.lfence+0xaff>
                self.start_time = @intCast(u64, ts.tv_sec) * u64(ns_per_s) + @intCast(u64, ts.tv_nsec);
  20aa07:	c5 f9 6f 8c 24 90 00 	vmovdqa xmm1,XMMWORD PTR [rsp+0x90]
  20aa0e:	00 00 
        while (iter > 0) : (iter -= 1) {
  20aa10:	48 85 db             	test   rbx,rbx
  20aa13:	74 14                	je     20aa29 <BmNoSelf.lfence+0x1c9>
  20aa15:	48 89 d8             	mov    rax,rbx
  20aa18:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  20aa1f:	00 
    asm volatile ("lfence": : :"memory");
  20aa20:	0f ae e8             	lfence 
        while (iter > 0) : (iter -= 1) {
  20aa23:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  20aa27:	75 f7                	jne    20aa20 <BmNoSelf.lfence+0x1c0>
    fn clockDarwin() u64 {
        return darwin.mach_absolute_time();
    }

    fn clockLinux() u64 {
        var ts: posix.timespec = undefined;
  20aa29:	c5 f9 7f 84 24 90 00 	vmovdqa XMMWORD PTR [rsp+0x90],xmm0
  20aa30:	00 00 
        const f = @atomicLoad(@typeOf(init_vdso_clock_gettime), &vdso_clock_gettime, builtin.AtomicOrder.Unordered);
  20aa32:	48 8b 05 0f 06 04 00 	mov    rax,QWORD PTR [rip+0x4060f]        # 24b048 <vdso_clock_gettime>
        if (@ptrToInt(f) != 0) {
  20aa39:	48 85 c0             	test   rax,rax
  20aa3c:	74 2e                	je     20aa6c <BmNoSelf.lfence+0x20c>
  20aa3e:	c5 f9 7f 8c 24 c0 00 	vmovdqa XMMWORD PTR [rsp+0xc0],xmm1
  20aa45:	00 00 
            const rc = f(clk_id, tp);
  20aa47:	bf 01 00 00 00       	mov    edi,0x1
  20aa4c:	4c 89 e6             	mov    rsi,r12
  20aa4f:	c5 f8 77             	vzeroupper 
  20aa52:	ff d0                	call   rax
            switch (rc) {
  20aa54:	48 83 f8 ea          	cmp    rax,0xffffffffffffffea
  20aa58:	0f 84 db 01 00 00    	je     20ac39 <BmNoSelf.lfence+0x3d9>
  20aa5e:	48 85 c0             	test   rax,rax
  20aa61:	c5 f9 6f 8c 24 c0 00 	vmovdqa xmm1,XMMWORD PTR [rsp+0xc0]
  20aa68:	00 00 
  20aa6a:	74 0f                	je     20aa7b <BmNoSelf.lfence+0x21b>
  20aa6c:	b8 e4 00 00 00       	mov    eax,0xe4
  20aa71:	bf 01 00 00 00       	mov    edi,0x1
  20aa76:	4c 89 e6             	mov    rsi,r12
  20aa79:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  20aa7b:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
  20aa81:	0f 83 f1 08 00 00    	jae    20b378 <BmNoSelf.lfence+0xb18>
        var result = posix.clock_gettime(monotonic_clock_id, &ts);
        debug.assert(posix.getErrno(result) == 0);
        return @intCast(u64, ts.tv_sec) * u64(ns_per_s) + @intCast(u64, ts.tv_nsec);
  20aa87:	c5 f9 6f 84 24 90 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x90]
  20aa8e:	00 00 
  20aa90:	c5 f9 fb c1          	vpsubq xmm0,xmm0,xmm1
  20aa94:	c4 e1 f9 7e c0       	vmovq  rax,xmm0
        var clock = clockNative() - self.start_time;
  20aa99:	c4 e3 f9 16 c5 01    	vpextrq rbp,xmm0,0x1
  20aa9f:	48 69 c0 00 ca 9a 3b 	imul   rax,rax,0x3b9aca00
  20aaa6:	48 01 c5             	add    rbp,rax
                if ((run_time_ns >= pSelf.min_runtime_ns) or (iterations >= pSelf.max_iterations)) {
  20aaa9:	48 3b 6c 24 38       	cmp    rbp,QWORD PTR [rsp+0x38]
  20aaae:	0f 83 9f 01 00 00    	jae    20ac53 <BmNoSelf.lfence+0x3f3>
  20aab4:	4c 39 fb             	cmp    rbx,r15
  20aab7:	0f 83 96 01 00 00    	jae    20ac53 <BmNoSelf.lfence+0x3f3>
                    if (pSelf.logl >= 1) {
  20aabd:	48 83 7c 24 30 00    	cmp    QWORD PTR [rsp+0x30],0x0
  20aac3:	0f 84 bd 00 00 00    	je     20ab86 <BmNoSelf.lfence+0x326>
                            Result {.run_time_ns = run_time_ns, .iterations = iterations});
  20aac9:	48 89 ac 24 d8 00 00 	mov    QWORD PTR [rsp+0xd8],rbp
  20aad0:	00 
  20aad1:	48 89 9c 24 e0 00 00 	mov    QWORD PTR [rsp+0xe0],rbx
  20aad8:	00 
                        try pSelf.report(
  20aad9:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  20aade:	48 8d b4 24 d8 00 00 	lea    rsi,[rsp+0xd8]
  20aae5:	00 
  20aae6:	c5 f8 77             	vzeroupper 
  20aae9:	e8 72 8f 00 00       	call   213a60 <Benchmark_report>
  20aaee:	66 85 c0             	test   ax,ax
  20aaf1:	0f 85 6c 08 00 00    	jne    20b363 <BmNoSelf.lfence+0xb03>
  20aaf7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  20aafe:	00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20ab00:	b0 01                	mov    al,0x1
  20ab02:	86 05 08 55 04 00    	xchg   BYTE PTR [rip+0x45508],al        # 250010 <stderr_mutex>
  20ab08:	84 c0                	test   al,al
  20ab0a:	75 f4                	jne    20ab00 <BmNoSelf.lfence+0x2a0>
    if (stderr_stream) |st| {
  20ab0c:	48 8b 3d f5 54 04 00 	mov    rdi,QWORD PTR [rip+0x454f5]        # 250008 <stderr_stream>
  20ab13:	48 85 ff             	test   rdi,rdi
  20ab16:	74 18                	je     20ab30 <BmNoSelf.lfence+0x2d0>
  20ab18:	48 8b 0d 21 05 04 00 	mov    rcx,QWORD PTR [rip+0x40521]        # 24b040 <stderr_file_out_stream+0x8>
  20ab1f:	eb 4c                	jmp    20ab6d <BmNoSelf.lfence+0x30d>
  20ab21:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20ab28:	0f 1f 84 00 00 00 00 
  20ab2f:	00 
        stderr_file = try io.getStdErr();
  20ab30:	c7 05 f6 04 04 00 02 	mov    DWORD PTR [rip+0x404f6],0x2        # 24b030 <stderr_file>
  20ab37:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20ab3a:	48 8d 05 ef 04 04 00 	lea    rax,[rip+0x404ef]        # 24b030 <stderr_file>
  20ab41:	48 89 05 f0 04 04 00 	mov    QWORD PTR [rip+0x404f0],rax        # 24b038 <stderr_file_out_stream>
  20ab48:	48 8d 05 91 4e 01 00 	lea    rax,[rip+0x14e91]        # 21f9e0 <FileOutStream_writeFn>
  20ab4f:	48 89 05 ea 04 04 00 	mov    QWORD PTR [rip+0x404ea],rax        # 24b040 <stderr_file_out_stream+0x8>
  20ab56:	48 8d 0d e3 04 04 00 	lea    rcx,[rip+0x404e3]        # 24b040 <stderr_file_out_stream+0x8>
  20ab5d:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20ab60:	48 89 15 a1 54 04 00 	mov    QWORD PTR [rip+0x454a1],rdx        # 250008 <stderr_stream>
  20ab67:	48 89 c1             	mov    rcx,rax
  20ab6a:	48 89 d7             	mov    rdi,rdx
  20ab6d:	48 8d 35 a4 42 04 00 	lea    rsi,[rip+0x442a4]        # 24ee18 <__unnamed_3>
  20ab74:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20ab76:	31 c0                	xor    eax,eax
  20ab78:	86 05 92 54 04 00    	xchg   BYTE PTR [rip+0x45492],al        # 250010 <stderr_mutex>
  20ab7e:	3c 01                	cmp    al,0x1
    if (!ok) {
  20ab80:	0f 85 f2 07 00 00    	jne    20b378 <BmNoSelf.lfence+0xb18>
                    if (run_time_ns < 1000) {
  20ab86:	48 81 fd e8 03 00 00 	cmp    rbp,0x3e8
  20ab8d:	73 31                	jae    20abc0 <BmNoSelf.lfence+0x360>
  20ab8f:	b9 01 00 00 00       	mov    ecx,0x1
  20ab94:	be e8 03 00 00       	mov    esi,0x3e8
                    iterations = (iterations * numer) / denom;
  20ab99:	48 0f af de          	imul   rbx,rsi
  20ab9d:	48 89 d8             	mov    rax,rbx
  20aba0:	48 c1 e8 20          	shr    rax,0x20
  20aba4:	74 54                	je     20abfa <BmNoSelf.lfence+0x39a>
  20aba6:	31 d2                	xor    edx,edx
  20aba8:	48 89 d8             	mov    rax,rbx
  20abab:	48 f7 f1             	div    rcx
  20abae:	48 89 c3             	mov    rbx,rax
  20abb1:	eb 4f                	jmp    20ac02 <BmNoSelf.lfence+0x3a2>
  20abb3:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20abba:	84 00 00 00 00 00 
                    } else if (run_time_ns < (pSelf.min_runtime_ns / 10)) {
  20abc0:	48 ba cd cc cc cc cc 	movabs rdx,0xcccccccccccccccd
  20abc7:	cc cc cc 
  20abca:	c4 e2 fb f6 4c 24 38 	mulx   rcx,rax,QWORD PTR [rsp+0x38]
  20abd1:	48 c1 e9 03          	shr    rcx,0x3
  20abd5:	31 c0                	xor    eax,eax
  20abd7:	48 39 cd             	cmp    rbp,rcx
  20abda:	0f 93 c0             	setae  al
  20abdd:	48 8d 0c c0          	lea    rcx,[rax+rax*8]
  20abe1:	48 83 c1 01          	add    rcx,0x1
  20abe5:	48 8d 34 85 0a 00 00 	lea    rsi,[rax*4+0xa]
  20abec:	00 
                    iterations = (iterations * numer) / denom;
  20abed:	48 0f af de          	imul   rbx,rsi
  20abf1:	48 89 d8             	mov    rax,rbx
  20abf4:	48 c1 e8 20          	shr    rax,0x20
  20abf8:	75 ac                	jne    20aba6 <BmNoSelf.lfence+0x346>
  20abfa:	31 d2                	xor    edx,edx
  20abfc:	89 d8                	mov    eax,ebx
  20abfe:	f7 f1                	div    ecx
  20ac00:	89 c3                	mov    ebx,eax
                    if (iterations > pSelf.max_iterations) {
  20ac02:	4c 8b 7c 24 48       	mov    r15,QWORD PTR [rsp+0x48]
  20ac07:	4c 39 fb             	cmp    rbx,r15
  20ac0a:	49 0f 47 df          	cmova  rbx,r15
                    if (pSelf.logl >= 2) {
  20ac0e:	48 83 7c 24 30 02    	cmp    QWORD PTR [rsp+0x30],0x2
  20ac14:	0f 82 64 fd ff ff    	jb     20a97e <BmNoSelf.lfence+0x11e>
  20ac1a:	e9 51 fd ff ff       	jmp    20a970 <BmNoSelf.lfence+0x110>
  20ac1f:	90                   	nop
  20ac20:	c5 fa 6f 05 98 e1 ff 	vmovdqu xmm0,XMMWORD PTR [rip+0xffffffffffffe198]        # 208dc0 <__unnamed_5>
  20ac27:	ff 
  20ac28:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
                if (errno != 0) return std.os.unexpectedErrorPosix(errno);
  20ac2e:	0f 82 d3 fd ff ff    	jb     20aa07 <BmNoSelf.lfence+0x1a7>
  20ac34:	e9 26 07 00 00       	jmp    20b35f <BmNoSelf.lfence+0xaff>
  20ac39:	c5 f9 6f 8c 24 c0 00 	vmovdqa xmm1,XMMWORD PTR [rsp+0xc0]
  20ac40:	00 00 
  20ac42:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
  20ac48:	0f 82 39 fe ff ff    	jb     20aa87 <BmNoSelf.lfence+0x227>
  20ac4e:	e9 25 07 00 00       	jmp    20b378 <BmNoSelf.lfence+0xb18>
                            Result { .run_time_ns = run_time_ns, .iterations = iterations});
  20ac53:	48 89 ac 24 e8 00 00 	mov    QWORD PTR [rsp+0xe8],rbp
  20ac5a:	00 
  20ac5b:	48 89 9c 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rbx
  20ac62:	00 
                    try pSelf.results.append(
  20ac63:	48 8d 7c 24 68       	lea    rdi,[rsp+0x68]
  20ac68:	48 8d b4 24 e8 00 00 	lea    rsi,[rsp+0xe8]
  20ac6f:	00 
  20ac70:	c5 f8 77             	vzeroupper 
  20ac73:	e8 78 8c 00 00       	call   2138f0 <AlignedArrayList(Result,8)_append>
  20ac78:	66 85 c0             	test   ax,ax
  20ac7b:	74 16                	je     20ac93 <BmNoSelf.lfence+0x433>
  20ac7d:	e9 e1 06 00 00       	jmp    20b363 <BmNoSelf.lfence+0xb03>
            while (iterations <= pSelf.max_iterations) {
  20ac82:	4c 8b 7c 24 48       	mov    r15,QWORD PTR [rsp+0x48]
  20ac87:	45 31 f6             	xor    r14d,r14d
  20ac8a:	4c 39 fb             	cmp    rbx,r15
  20ac8d:	0f 86 eb fc ff ff    	jbe    20a97e <BmNoSelf.lfence+0x11e>
            if (once) {
  20ac93:	41 f6 c6 01          	test   r14b,0x1
  20ac97:	48 8d 6c 24 0f       	lea    rbp,[rsp+0xf]
  20ac9c:	4c 8d 74 24 10       	lea    r14,[rsp+0x10]
  20aca1:	0f 84 e0 05 00 00    	je     20b287 <BmNoSelf.lfence+0xa27>
                try leftJustified(22, "name repetitions:{}", pSelf.repetitions);
  20aca7:	48 8b 7c 24 40       	mov    rdi,QWORD PTR [rsp+0x40]
  20acac:	c5 f8 77             	vzeroupper 
  20acaf:	e8 2c b2 00 00       	call   215ee0 <Benchmark_leftJustified>
  20acb4:	66 85 c0             	test   ax,ax
  20acb7:	0f 85 a6 06 00 00    	jne    20b363 <BmNoSelf.lfence+0xb03>
                try rightJustified(14, "{}", "iterations");
  20acbd:	e8 be b4 00 00       	call   216180 <Benchmark_rightJustified>
  20acc2:	66 85 c0             	test   ax,ax
  20acc5:	0f 85 98 06 00 00    	jne    20b363 <BmNoSelf.lfence+0xb03>
        var buffer: [40]u8 = undefined;
  20accb:	c5 fe 6f 05 c8 a8 ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffffa8c8]        # 20559b <__unnamed_7>
  20acd2:	ff 
  20acd3:	c5 fe 7f 84 24 90 00 	vmovdqu YMMWORD PTR [rsp+0x90],ymm0
  20acda:	00 00 
  20acdc:	48 8b 05 d8 a8 ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffffa8d8]        # 2055bb <__unnamed_7+0x20>
  20ace3:	48 89 84 24 b0 00 00 	mov    QWORD PTR [rsp+0xb0],rax
  20acea:	00 
        dest[i] = s;
  20aceb:	c7 84 24 90 00 00 00 	mov    DWORD PTR [rsp+0x90],0x656d6974
  20acf2:	74 69 6d 65 
  20acf6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  20acfd:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20ad00:	b0 01                	mov    al,0x1
  20ad02:	86 05 08 53 04 00    	xchg   BYTE PTR [rip+0x45308],al        # 250010 <stderr_mutex>
  20ad08:	84 c0                	test   al,al
  20ad0a:	75 f4                	jne    20ad00 <BmNoSelf.lfence+0x4a0>
    if (stderr_stream) |st| {
  20ad0c:	48 8b 3d f5 52 04 00 	mov    rdi,QWORD PTR [rip+0x452f5]        # 250008 <stderr_stream>
  20ad13:	48 85 ff             	test   rdi,rdi
  20ad16:	74 09                	je     20ad21 <BmNoSelf.lfence+0x4c1>
  20ad18:	48 8b 0d 21 03 04 00 	mov    rcx,QWORD PTR [rip+0x40321]        # 24b040 <stderr_file_out_stream+0x8>
  20ad1f:	eb 3d                	jmp    20ad5e <BmNoSelf.lfence+0x4fe>
        stderr_file = try io.getStdErr();
  20ad21:	c7 05 05 03 04 00 02 	mov    DWORD PTR [rip+0x40305],0x2        # 24b030 <stderr_file>
  20ad28:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20ad2b:	48 8d 05 fe 02 04 00 	lea    rax,[rip+0x402fe]        # 24b030 <stderr_file>
  20ad32:	48 89 05 ff 02 04 00 	mov    QWORD PTR [rip+0x402ff],rax        # 24b038 <stderr_file_out_stream>
  20ad39:	48 8d 05 a0 4c 01 00 	lea    rax,[rip+0x14ca0]        # 21f9e0 <FileOutStream_writeFn>
  20ad40:	48 89 05 f9 02 04 00 	mov    QWORD PTR [rip+0x402f9],rax        # 24b040 <stderr_file_out_stream+0x8>
  20ad47:	48 8d 0d f2 02 04 00 	lea    rcx,[rip+0x402f2]        # 24b040 <stderr_file_out_stream+0x8>
  20ad4e:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20ad51:	48 89 15 b0 52 04 00 	mov    QWORD PTR [rip+0x452b0],rdx        # 250008 <stderr_stream>
  20ad58:	48 89 c1             	mov    rcx,rax
  20ad5b:	48 89 d7             	mov    rdi,rdx
  20ad5e:	c6 44 24 0f 20       	mov    BYTE PTR [rsp+0xf],0x20
    c: u8,
    context: var,
    comptime Errors: type,
    output: fn (@typeOf(context), []const u8) Errors!void,
) Errors!void {
    return output(context, (*[1]u8)(&c)[0..]);
  20ad63:	48 89 6c 24 10       	mov    QWORD PTR [rsp+0x10],rbp
  20ad68:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  20ad6f:	00 00 
  20ad71:	4c 89 f6             	mov    rsi,r14
  20ad74:	c5 f8 77             	vzeroupper 
  20ad77:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20ad79:	31 c0                	xor    eax,eax
  20ad7b:	86 05 8f 52 04 00    	xchg   BYTE PTR [rip+0x4528f],al        # 250010 <stderr_mutex>
  20ad81:	3c 01                	cmp    al,0x1
    if (!ok) {
  20ad83:	0f 85 ef 05 00 00    	jne    20b378 <BmNoSelf.lfence+0xb18>
  20ad89:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20ad90:	b0 01                	mov    al,0x1
  20ad92:	86 05 78 52 04 00    	xchg   BYTE PTR [rip+0x45278],al        # 250010 <stderr_mutex>
  20ad98:	84 c0                	test   al,al
  20ad9a:	75 f4                	jne    20ad90 <BmNoSelf.lfence+0x530>
    if (stderr_stream) |st| {
  20ad9c:	48 8b 3d 65 52 04 00 	mov    rdi,QWORD PTR [rip+0x45265]        # 250008 <stderr_stream>
  20ada3:	48 85 ff             	test   rdi,rdi
  20ada6:	74 09                	je     20adb1 <BmNoSelf.lfence+0x551>
  20ada8:	48 8b 0d 91 02 04 00 	mov    rcx,QWORD PTR [rip+0x40291]        # 24b040 <stderr_file_out_stream+0x8>
  20adaf:	eb 3d                	jmp    20adee <BmNoSelf.lfence+0x58e>
        stderr_file = try io.getStdErr();
  20adb1:	c7 05 75 02 04 00 02 	mov    DWORD PTR [rip+0x40275],0x2        # 24b030 <stderr_file>
  20adb8:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20adbb:	48 8d 05 6e 02 04 00 	lea    rax,[rip+0x4026e]        # 24b030 <stderr_file>
  20adc2:	48 89 05 6f 02 04 00 	mov    QWORD PTR [rip+0x4026f],rax        # 24b038 <stderr_file_out_stream>
  20adc9:	48 8d 05 10 4c 01 00 	lea    rax,[rip+0x14c10]        # 21f9e0 <FileOutStream_writeFn>
  20add0:	48 89 05 69 02 04 00 	mov    QWORD PTR [rip+0x40269],rax        # 24b040 <stderr_file_out_stream+0x8>
  20add7:	48 8d 0d 62 02 04 00 	lea    rcx,[rip+0x40262]        # 24b040 <stderr_file_out_stream+0x8>
  20adde:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20ade1:	48 89 15 20 52 04 00 	mov    QWORD PTR [rip+0x45220],rdx        # 250008 <stderr_stream>
  20ade8:	48 89 c1             	mov    rcx,rax
  20adeb:	48 89 d7             	mov    rdi,rdx
  20adee:	c6 44 24 0f 20       	mov    BYTE PTR [rsp+0xf],0x20
  20adf3:	48 89 6c 24 10       	mov    QWORD PTR [rsp+0x10],rbp
  20adf8:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  20adff:	00 00 
  20ae01:	4c 89 f6             	mov    rsi,r14
  20ae04:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20ae06:	31 c0                	xor    eax,eax
  20ae08:	86 05 02 52 04 00    	xchg   BYTE PTR [rip+0x45202],al        # 250010 <stderr_mutex>
  20ae0e:	3c 01                	cmp    al,0x1
    if (!ok) {
  20ae10:	0f 85 62 05 00 00    	jne    20b378 <BmNoSelf.lfence+0xb18>
  20ae16:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  20ae1d:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20ae20:	b0 01                	mov    al,0x1
  20ae22:	86 05 e8 51 04 00    	xchg   BYTE PTR [rip+0x451e8],al        # 250010 <stderr_mutex>
  20ae28:	84 c0                	test   al,al
  20ae2a:	75 f4                	jne    20ae20 <BmNoSelf.lfence+0x5c0>
    if (stderr_stream) |st| {
  20ae2c:	48 8b 3d d5 51 04 00 	mov    rdi,QWORD PTR [rip+0x451d5]        # 250008 <stderr_stream>
  20ae33:	48 85 ff             	test   rdi,rdi
  20ae36:	74 09                	je     20ae41 <BmNoSelf.lfence+0x5e1>
  20ae38:	48 8b 0d 01 02 04 00 	mov    rcx,QWORD PTR [rip+0x40201]        # 24b040 <stderr_file_out_stream+0x8>
  20ae3f:	eb 3d                	jmp    20ae7e <BmNoSelf.lfence+0x61e>
        stderr_file = try io.getStdErr();
  20ae41:	c7 05 e5 01 04 00 02 	mov    DWORD PTR [rip+0x401e5],0x2        # 24b030 <stderr_file>
  20ae48:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20ae4b:	48 8d 05 de 01 04 00 	lea    rax,[rip+0x401de]        # 24b030 <stderr_file>
  20ae52:	48 89 05 df 01 04 00 	mov    QWORD PTR [rip+0x401df],rax        # 24b038 <stderr_file_out_stream>
  20ae59:	48 8d 05 80 4b 01 00 	lea    rax,[rip+0x14b80]        # 21f9e0 <FileOutStream_writeFn>
  20ae60:	48 89 05 d9 01 04 00 	mov    QWORD PTR [rip+0x401d9],rax        # 24b040 <stderr_file_out_stream+0x8>
  20ae67:	48 8d 0d d2 01 04 00 	lea    rcx,[rip+0x401d2]        # 24b040 <stderr_file_out_stream+0x8>
  20ae6e:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20ae71:	48 89 15 90 51 04 00 	mov    QWORD PTR [rip+0x45190],rdx        # 250008 <stderr_stream>
  20ae78:	48 89 c1             	mov    rcx,rax
  20ae7b:	48 89 d7             	mov    rdi,rdx
  20ae7e:	c6 44 24 0f 20       	mov    BYTE PTR [rsp+0xf],0x20
  20ae83:	48 89 6c 24 10       	mov    QWORD PTR [rsp+0x10],rbp
  20ae88:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  20ae8f:	00 00 
  20ae91:	4c 89 f6             	mov    rsi,r14
  20ae94:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20ae96:	31 c0                	xor    eax,eax
  20ae98:	86 05 72 51 04 00    	xchg   BYTE PTR [rip+0x45172],al        # 250010 <stderr_mutex>
  20ae9e:	3c 01                	cmp    al,0x1
    if (!ok) {
  20aea0:	0f 85 d2 04 00 00    	jne    20b378 <BmNoSelf.lfence+0xb18>
  20aea6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  20aead:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20aeb0:	b0 01                	mov    al,0x1
  20aeb2:	86 05 58 51 04 00    	xchg   BYTE PTR [rip+0x45158],al        # 250010 <stderr_mutex>
  20aeb8:	84 c0                	test   al,al
  20aeba:	75 f4                	jne    20aeb0 <BmNoSelf.lfence+0x650>
    if (stderr_stream) |st| {
  20aebc:	48 8b 3d 45 51 04 00 	mov    rdi,QWORD PTR [rip+0x45145]        # 250008 <stderr_stream>
  20aec3:	48 85 ff             	test   rdi,rdi
  20aec6:	74 09                	je     20aed1 <BmNoSelf.lfence+0x671>
  20aec8:	48 8b 0d 71 01 04 00 	mov    rcx,QWORD PTR [rip+0x40171]        # 24b040 <stderr_file_out_stream+0x8>
  20aecf:	eb 3d                	jmp    20af0e <BmNoSelf.lfence+0x6ae>
        stderr_file = try io.getStdErr();
  20aed1:	c7 05 55 01 04 00 02 	mov    DWORD PTR [rip+0x40155],0x2        # 24b030 <stderr_file>
  20aed8:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20aedb:	48 8d 05 4e 01 04 00 	lea    rax,[rip+0x4014e]        # 24b030 <stderr_file>
  20aee2:	48 89 05 4f 01 04 00 	mov    QWORD PTR [rip+0x4014f],rax        # 24b038 <stderr_file_out_stream>
  20aee9:	48 8d 05 f0 4a 01 00 	lea    rax,[rip+0x14af0]        # 21f9e0 <FileOutStream_writeFn>
  20aef0:	48 89 05 49 01 04 00 	mov    QWORD PTR [rip+0x40149],rax        # 24b040 <stderr_file_out_stream+0x8>
  20aef7:	48 8d 0d 42 01 04 00 	lea    rcx,[rip+0x40142]        # 24b040 <stderr_file_out_stream+0x8>
  20aefe:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20af01:	48 89 15 00 51 04 00 	mov    QWORD PTR [rip+0x45100],rdx        # 250008 <stderr_stream>
  20af08:	48 89 c1             	mov    rcx,rax
  20af0b:	48 89 d7             	mov    rdi,rdx
  20af0e:	c6 44 24 0f 20       	mov    BYTE PTR [rsp+0xf],0x20
  20af13:	48 89 6c 24 10       	mov    QWORD PTR [rsp+0x10],rbp
  20af18:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  20af1f:	00 00 
  20af21:	4c 89 f6             	mov    rsi,r14
  20af24:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20af26:	31 c0                	xor    eax,eax
  20af28:	86 05 e2 50 04 00    	xchg   BYTE PTR [rip+0x450e2],al        # 250010 <stderr_mutex>
  20af2e:	3c 01                	cmp    al,0x1
    if (!ok) {
  20af30:	0f 85 42 04 00 00    	jne    20b378 <BmNoSelf.lfence+0xb18>
  20af36:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  20af3d:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20af40:	b0 01                	mov    al,0x1
  20af42:	86 05 c8 50 04 00    	xchg   BYTE PTR [rip+0x450c8],al        # 250010 <stderr_mutex>
  20af48:	84 c0                	test   al,al
  20af4a:	75 f4                	jne    20af40 <BmNoSelf.lfence+0x6e0>
    if (stderr_stream) |st| {
  20af4c:	48 8b 3d b5 50 04 00 	mov    rdi,QWORD PTR [rip+0x450b5]        # 250008 <stderr_stream>
  20af53:	48 85 ff             	test   rdi,rdi
  20af56:	74 09                	je     20af61 <BmNoSelf.lfence+0x701>
  20af58:	48 8b 0d e1 00 04 00 	mov    rcx,QWORD PTR [rip+0x400e1]        # 24b040 <stderr_file_out_stream+0x8>
  20af5f:	eb 3d                	jmp    20af9e <BmNoSelf.lfence+0x73e>
        stderr_file = try io.getStdErr();
  20af61:	c7 05 c5 00 04 00 02 	mov    DWORD PTR [rip+0x400c5],0x2        # 24b030 <stderr_file>
  20af68:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20af6b:	48 8d 05 be 00 04 00 	lea    rax,[rip+0x400be]        # 24b030 <stderr_file>
  20af72:	48 89 05 bf 00 04 00 	mov    QWORD PTR [rip+0x400bf],rax        # 24b038 <stderr_file_out_stream>
  20af79:	48 8d 05 60 4a 01 00 	lea    rax,[rip+0x14a60]        # 21f9e0 <FileOutStream_writeFn>
  20af80:	48 89 05 b9 00 04 00 	mov    QWORD PTR [rip+0x400b9],rax        # 24b040 <stderr_file_out_stream+0x8>
  20af87:	48 8d 0d b2 00 04 00 	lea    rcx,[rip+0x400b2]        # 24b040 <stderr_file_out_stream+0x8>
  20af8e:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20af91:	48 89 15 70 50 04 00 	mov    QWORD PTR [rip+0x45070],rdx        # 250008 <stderr_stream>
  20af98:	48 89 c1             	mov    rcx,rax
  20af9b:	48 89 d7             	mov    rdi,rdx
  20af9e:	c6 44 24 0f 20       	mov    BYTE PTR [rsp+0xf],0x20
  20afa3:	48 89 6c 24 10       	mov    QWORD PTR [rsp+0x10],rbp
  20afa8:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  20afaf:	00 00 
  20afb1:	4c 89 f6             	mov    rsi,r14
  20afb4:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20afb6:	31 c0                	xor    eax,eax
  20afb8:	86 05 52 50 04 00    	xchg   BYTE PTR [rip+0x45052],al        # 250010 <stderr_mutex>
  20afbe:	3c 01                	cmp    al,0x1
    if (!ok) {
  20afc0:	0f 85 b2 03 00 00    	jne    20b378 <BmNoSelf.lfence+0xb18>
  20afc6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  20afcd:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20afd0:	b0 01                	mov    al,0x1
  20afd2:	86 05 38 50 04 00    	xchg   BYTE PTR [rip+0x45038],al        # 250010 <stderr_mutex>
  20afd8:	84 c0                	test   al,al
  20afda:	75 f4                	jne    20afd0 <BmNoSelf.lfence+0x770>
    if (stderr_stream) |st| {
  20afdc:	48 8b 3d 25 50 04 00 	mov    rdi,QWORD PTR [rip+0x45025]        # 250008 <stderr_stream>
  20afe3:	48 85 ff             	test   rdi,rdi
  20afe6:	74 09                	je     20aff1 <BmNoSelf.lfence+0x791>
  20afe8:	48 8b 0d 51 00 04 00 	mov    rcx,QWORD PTR [rip+0x40051]        # 24b040 <stderr_file_out_stream+0x8>
  20afef:	eb 3d                	jmp    20b02e <BmNoSelf.lfence+0x7ce>
        stderr_file = try io.getStdErr();
  20aff1:	c7 05 35 00 04 00 02 	mov    DWORD PTR [rip+0x40035],0x2        # 24b030 <stderr_file>
  20aff8:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20affb:	48 8d 05 2e 00 04 00 	lea    rax,[rip+0x4002e]        # 24b030 <stderr_file>
  20b002:	48 89 05 2f 00 04 00 	mov    QWORD PTR [rip+0x4002f],rax        # 24b038 <stderr_file_out_stream>
  20b009:	48 8d 05 d0 49 01 00 	lea    rax,[rip+0x149d0]        # 21f9e0 <FileOutStream_writeFn>
  20b010:	48 89 05 29 00 04 00 	mov    QWORD PTR [rip+0x40029],rax        # 24b040 <stderr_file_out_stream+0x8>
  20b017:	48 8d 0d 22 00 04 00 	lea    rcx,[rip+0x40022]        # 24b040 <stderr_file_out_stream+0x8>
  20b01e:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20b021:	48 89 15 e0 4f 04 00 	mov    QWORD PTR [rip+0x44fe0],rdx        # 250008 <stderr_stream>
  20b028:	48 89 c1             	mov    rcx,rax
  20b02b:	48 89 d7             	mov    rdi,rdx
  20b02e:	c6 44 24 0f 20       	mov    BYTE PTR [rsp+0xf],0x20
  20b033:	48 89 6c 24 10       	mov    QWORD PTR [rsp+0x10],rbp
  20b038:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  20b03f:	00 00 
  20b041:	4c 89 f6             	mov    rsi,r14
  20b044:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20b046:	31 c0                	xor    eax,eax
  20b048:	86 05 c2 4f 04 00    	xchg   BYTE PTR [rip+0x44fc2],al        # 250010 <stderr_mutex>
  20b04e:	3c 01                	cmp    al,0x1
    if (!ok) {
  20b050:	0f 85 22 03 00 00    	jne    20b378 <BmNoSelf.lfence+0xb18>
  20b056:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  20b05d:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20b060:	b0 01                	mov    al,0x1
  20b062:	86 05 a8 4f 04 00    	xchg   BYTE PTR [rip+0x44fa8],al        # 250010 <stderr_mutex>
  20b068:	84 c0                	test   al,al
  20b06a:	75 f4                	jne    20b060 <BmNoSelf.lfence+0x800>
    if (stderr_stream) |st| {
  20b06c:	48 8b 3d 95 4f 04 00 	mov    rdi,QWORD PTR [rip+0x44f95]        # 250008 <stderr_stream>
  20b073:	48 85 ff             	test   rdi,rdi
  20b076:	74 09                	je     20b081 <BmNoSelf.lfence+0x821>
  20b078:	48 8b 0d c1 ff 03 00 	mov    rcx,QWORD PTR [rip+0x3ffc1]        # 24b040 <stderr_file_out_stream+0x8>
  20b07f:	eb 3d                	jmp    20b0be <BmNoSelf.lfence+0x85e>
        stderr_file = try io.getStdErr();
  20b081:	c7 05 a5 ff 03 00 02 	mov    DWORD PTR [rip+0x3ffa5],0x2        # 24b030 <stderr_file>
  20b088:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20b08b:	48 8d 05 9e ff 03 00 	lea    rax,[rip+0x3ff9e]        # 24b030 <stderr_file>
  20b092:	48 89 05 9f ff 03 00 	mov    QWORD PTR [rip+0x3ff9f],rax        # 24b038 <stderr_file_out_stream>
  20b099:	48 8d 05 40 49 01 00 	lea    rax,[rip+0x14940]        # 21f9e0 <FileOutStream_writeFn>
  20b0a0:	48 89 05 99 ff 03 00 	mov    QWORD PTR [rip+0x3ff99],rax        # 24b040 <stderr_file_out_stream+0x8>
  20b0a7:	48 8d 0d 92 ff 03 00 	lea    rcx,[rip+0x3ff92]        # 24b040 <stderr_file_out_stream+0x8>
  20b0ae:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20b0b1:	48 89 15 50 4f 04 00 	mov    QWORD PTR [rip+0x44f50],rdx        # 250008 <stderr_stream>
  20b0b8:	48 89 c1             	mov    rcx,rax
  20b0bb:	48 89 d7             	mov    rdi,rdx
  20b0be:	c6 44 24 0f 20       	mov    BYTE PTR [rsp+0xf],0x20
  20b0c3:	48 89 6c 24 10       	mov    QWORD PTR [rsp+0x10],rbp
  20b0c8:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  20b0cf:	00 00 
  20b0d1:	4c 89 f6             	mov    rsi,r14
  20b0d4:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20b0d6:	31 c0                	xor    eax,eax
  20b0d8:	86 05 32 4f 04 00    	xchg   BYTE PTR [rip+0x44f32],al        # 250010 <stderr_mutex>
  20b0de:	3c 01                	cmp    al,0x1
    if (!ok) {
  20b0e0:	0f 85 92 02 00 00    	jne    20b378 <BmNoSelf.lfence+0xb18>
  20b0e6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  20b0ed:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20b0f0:	b0 01                	mov    al,0x1
  20b0f2:	86 05 18 4f 04 00    	xchg   BYTE PTR [rip+0x44f18],al        # 250010 <stderr_mutex>
  20b0f8:	84 c0                	test   al,al
  20b0fa:	75 f4                	jne    20b0f0 <BmNoSelf.lfence+0x890>
    if (stderr_stream) |st| {
  20b0fc:	48 8b 3d 05 4f 04 00 	mov    rdi,QWORD PTR [rip+0x44f05]        # 250008 <stderr_stream>
  20b103:	48 85 ff             	test   rdi,rdi
  20b106:	74 09                	je     20b111 <BmNoSelf.lfence+0x8b1>
  20b108:	48 8b 0d 31 ff 03 00 	mov    rcx,QWORD PTR [rip+0x3ff31]        # 24b040 <stderr_file_out_stream+0x8>
  20b10f:	eb 3d                	jmp    20b14e <BmNoSelf.lfence+0x8ee>
        stderr_file = try io.getStdErr();
  20b111:	c7 05 15 ff 03 00 02 	mov    DWORD PTR [rip+0x3ff15],0x2        # 24b030 <stderr_file>
  20b118:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20b11b:	48 8d 05 0e ff 03 00 	lea    rax,[rip+0x3ff0e]        # 24b030 <stderr_file>
  20b122:	48 89 05 0f ff 03 00 	mov    QWORD PTR [rip+0x3ff0f],rax        # 24b038 <stderr_file_out_stream>
  20b129:	48 8d 05 b0 48 01 00 	lea    rax,[rip+0x148b0]        # 21f9e0 <FileOutStream_writeFn>
  20b130:	48 89 05 09 ff 03 00 	mov    QWORD PTR [rip+0x3ff09],rax        # 24b040 <stderr_file_out_stream+0x8>
  20b137:	48 8d 0d 02 ff 03 00 	lea    rcx,[rip+0x3ff02]        # 24b040 <stderr_file_out_stream+0x8>
  20b13e:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20b141:	48 89 15 c0 4e 04 00 	mov    QWORD PTR [rip+0x44ec0],rdx        # 250008 <stderr_stream>
  20b148:	48 89 c1             	mov    rcx,rax
  20b14b:	48 89 d7             	mov    rdi,rdx
  20b14e:	c6 44 24 0f 20       	mov    BYTE PTR [rsp+0xf],0x20
  20b153:	48 89 6c 24 10       	mov    QWORD PTR [rsp+0x10],rbp
  20b158:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  20b15f:	00 00 
  20b161:	4c 89 f6             	mov    rsi,r14
  20b164:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20b166:	31 c0                	xor    eax,eax
  20b168:	86 05 a2 4e 04 00    	xchg   BYTE PTR [rip+0x44ea2],al        # 250010 <stderr_mutex>
  20b16e:	3c 01                	cmp    al,0x1
    if (!ok) {
  20b170:	0f 85 02 02 00 00    	jne    20b378 <BmNoSelf.lfence+0xb18>
  20b176:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  20b17d:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20b180:	b0 01                	mov    al,0x1
  20b182:	86 05 88 4e 04 00    	xchg   BYTE PTR [rip+0x44e88],al        # 250010 <stderr_mutex>
  20b188:	84 c0                	test   al,al
  20b18a:	75 f4                	jne    20b180 <BmNoSelf.lfence+0x920>
    if (stderr_stream) |st| {
  20b18c:	48 8b 3d 75 4e 04 00 	mov    rdi,QWORD PTR [rip+0x44e75]        # 250008 <stderr_stream>
  20b193:	48 85 ff             	test   rdi,rdi
  20b196:	74 09                	je     20b1a1 <BmNoSelf.lfence+0x941>
  20b198:	48 8b 0d a1 fe 03 00 	mov    rcx,QWORD PTR [rip+0x3fea1]        # 24b040 <stderr_file_out_stream+0x8>
  20b19f:	eb 3d                	jmp    20b1de <BmNoSelf.lfence+0x97e>
        stderr_file = try io.getStdErr();
  20b1a1:	c7 05 85 fe 03 00 02 	mov    DWORD PTR [rip+0x3fe85],0x2        # 24b030 <stderr_file>
  20b1a8:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20b1ab:	48 8d 05 7e fe 03 00 	lea    rax,[rip+0x3fe7e]        # 24b030 <stderr_file>
  20b1b2:	48 89 05 7f fe 03 00 	mov    QWORD PTR [rip+0x3fe7f],rax        # 24b038 <stderr_file_out_stream>
  20b1b9:	48 8d 05 20 48 01 00 	lea    rax,[rip+0x14820]        # 21f9e0 <FileOutStream_writeFn>
  20b1c0:	48 89 05 79 fe 03 00 	mov    QWORD PTR [rip+0x3fe79],rax        # 24b040 <stderr_file_out_stream+0x8>
  20b1c7:	48 8d 0d 72 fe 03 00 	lea    rcx,[rip+0x3fe72]        # 24b040 <stderr_file_out_stream+0x8>
  20b1ce:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20b1d1:	48 89 15 30 4e 04 00 	mov    QWORD PTR [rip+0x44e30],rdx        # 250008 <stderr_stream>
  20b1d8:	48 89 c1             	mov    rcx,rax
  20b1db:	48 89 d7             	mov    rdi,rdx
                const casted_value = ([]const u8)(value);
  20b1de:	4c 89 64 24 10       	mov    QWORD PTR [rsp+0x10],r12
  20b1e3:	48 c7 44 24 18 04 00 	mov    QWORD PTR [rsp+0x18],0x4
  20b1ea:	00 00 
                return output(context, casted_value);
  20b1ec:	4c 89 f6             	mov    rsi,r14
  20b1ef:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20b1f1:	31 c0                	xor    eax,eax
  20b1f3:	86 05 17 4e 04 00    	xchg   BYTE PTR [rip+0x44e17],al        # 250010 <stderr_mutex>
  20b1f9:	3c 01                	cmp    al,0x1
    if (!ok) {
  20b1fb:	0f 85 77 01 00 00    	jne    20b378 <BmNoSelf.lfence+0xb18>
                try rightJustified(18, "{}", "time/operation");
  20b201:	e8 5a b2 00 00       	call   216460 <Benchmark_rightJustified.38>
  20b206:	66 85 c0             	test   ax,ax
  20b209:	0f 85 54 01 00 00    	jne    20b363 <BmNoSelf.lfence+0xb03>
  20b20f:	90                   	nop
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20b210:	b0 01                	mov    al,0x1
  20b212:	86 05 f8 4d 04 00    	xchg   BYTE PTR [rip+0x44df8],al        # 250010 <stderr_mutex>
  20b218:	84 c0                	test   al,al
  20b21a:	75 f4                	jne    20b210 <BmNoSelf.lfence+0x9b0>
    if (stderr_stream) |st| {
  20b21c:	48 8b 3d e5 4d 04 00 	mov    rdi,QWORD PTR [rip+0x44de5]        # 250008 <stderr_stream>
  20b223:	48 85 ff             	test   rdi,rdi
  20b226:	74 09                	je     20b231 <BmNoSelf.lfence+0x9d1>
  20b228:	48 8b 0d 11 fe 03 00 	mov    rcx,QWORD PTR [rip+0x3fe11]        # 24b040 <stderr_file_out_stream+0x8>
  20b22f:	eb 3d                	jmp    20b26e <BmNoSelf.lfence+0xa0e>
        stderr_file = try io.getStdErr();
  20b231:	c7 05 f5 fd 03 00 02 	mov    DWORD PTR [rip+0x3fdf5],0x2        # 24b030 <stderr_file>
  20b238:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20b23b:	48 8d 05 ee fd 03 00 	lea    rax,[rip+0x3fdee]        # 24b030 <stderr_file>
  20b242:	48 89 05 ef fd 03 00 	mov    QWORD PTR [rip+0x3fdef],rax        # 24b038 <stderr_file_out_stream>
  20b249:	48 8d 05 90 47 01 00 	lea    rax,[rip+0x14790]        # 21f9e0 <FileOutStream_writeFn>
  20b250:	48 89 05 e9 fd 03 00 	mov    QWORD PTR [rip+0x3fde9],rax        # 24b040 <stderr_file_out_stream+0x8>
  20b257:	48 8d 0d e2 fd 03 00 	lea    rcx,[rip+0x3fde2]        # 24b040 <stderr_file_out_stream+0x8>
  20b25e:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20b261:	48 89 15 a0 4d 04 00 	mov    QWORD PTR [rip+0x44da0],rdx        # 250008 <stderr_stream>
  20b268:	48 89 c1             	mov    rcx,rax
  20b26b:	48 89 d7             	mov    rdi,rdx
        try output(context, fmt[start_index..]);
  20b26e:	48 8d 35 a3 3b 04 00 	lea    rsi,[rip+0x43ba3]        # 24ee18 <__unnamed_3>
  20b275:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20b277:	31 c0                	xor    eax,eax
  20b279:	86 05 91 4d 04 00    	xchg   BYTE PTR [rip+0x44d91],al        # 250010 <stderr_mutex>
  20b27f:	3c 01                	cmp    al,0x1
    if (!ok) {
  20b281:	0f 85 f1 00 00 00    	jne    20b378 <BmNoSelf.lfence+0xb18>
            try pSelf.report(pSelf.results.items[pSelf.results.len - 1]); warn("\n");
  20b287:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  20b28c:	48 8b 4c 24 78       	mov    rcx,QWORD PTR [rsp+0x78]
  20b291:	48 c1 e1 04          	shl    rcx,0x4
  20b295:	48 8d 34 08          	lea    rsi,[rax+rcx*1]
  20b299:	48 83 c6 f0          	add    rsi,0xfffffffffffffff0
  20b29d:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  20b2a2:	c5 f8 77             	vzeroupper 
  20b2a5:	e8 b6 87 00 00       	call   213a60 <Benchmark_report>
  20b2aa:	66 85 c0             	test   ax,ax
  20b2ad:	0f 85 b0 00 00 00    	jne    20b363 <BmNoSelf.lfence+0xb03>
  20b2b3:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20b2ba:	84 00 00 00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20b2c0:	b0 01                	mov    al,0x1
  20b2c2:	86 05 48 4d 04 00    	xchg   BYTE PTR [rip+0x44d48],al        # 250010 <stderr_mutex>
  20b2c8:	84 c0                	test   al,al
  20b2ca:	75 f4                	jne    20b2c0 <BmNoSelf.lfence+0xa60>
    if (stderr_stream) |st| {
  20b2cc:	48 8b 3d 35 4d 04 00 	mov    rdi,QWORD PTR [rip+0x44d35]        # 250008 <stderr_stream>
  20b2d3:	48 85 ff             	test   rdi,rdi
  20b2d6:	74 09                	je     20b2e1 <BmNoSelf.lfence+0xa81>
  20b2d8:	48 8b 0d 61 fd 03 00 	mov    rcx,QWORD PTR [rip+0x3fd61]        # 24b040 <stderr_file_out_stream+0x8>
  20b2df:	eb 3d                	jmp    20b31e <BmNoSelf.lfence+0xabe>
        stderr_file = try io.getStdErr();
  20b2e1:	c7 05 45 fd 03 00 02 	mov    DWORD PTR [rip+0x3fd45],0x2        # 24b030 <stderr_file>
  20b2e8:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20b2eb:	48 8d 05 3e fd 03 00 	lea    rax,[rip+0x3fd3e]        # 24b030 <stderr_file>
  20b2f2:	48 89 05 3f fd 03 00 	mov    QWORD PTR [rip+0x3fd3f],rax        # 24b038 <stderr_file_out_stream>
  20b2f9:	48 8d 05 e0 46 01 00 	lea    rax,[rip+0x146e0]        # 21f9e0 <FileOutStream_writeFn>
  20b300:	48 89 05 39 fd 03 00 	mov    QWORD PTR [rip+0x3fd39],rax        # 24b040 <stderr_file_out_stream+0x8>
  20b307:	48 8d 0d 32 fd 03 00 	lea    rcx,[rip+0x3fd32]        # 24b040 <stderr_file_out_stream+0x8>
  20b30e:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20b311:	48 89 15 f0 4c 04 00 	mov    QWORD PTR [rip+0x44cf0],rdx        # 250008 <stderr_stream>
  20b318:	48 89 c1             	mov    rcx,rax
  20b31b:	48 89 d7             	mov    rdi,rdx
  20b31e:	48 8d 35 f3 3a 04 00 	lea    rsi,[rip+0x43af3]        # 24ee18 <__unnamed_3>
  20b325:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20b327:	31 c0                	xor    eax,eax
  20b329:	86 05 e1 4c 04 00    	xchg   BYTE PTR [rip+0x44ce1],al        # 250010 <stderr_mutex>
  20b32f:	3c 01                	cmp    al,0x1
    if (!ok) {
  20b331:	75 45                	jne    20b378 <BmNoSelf.lfence+0xb18>
  20b333:	49 83 c5 01          	add    r13,0x1
        while (rep < pSelf.repetitions) : (rep += 1) {
  20b337:	4c 3b 6c 24 40       	cmp    r13,QWORD PTR [rsp+0x40]
  20b33c:	0f 82 40 f9 ff ff    	jb     20ac82 <BmNoSelf.lfence+0x422>
  20b342:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
        try pSelf.reportStats(pSelf.results);
  20b347:	48 8d 74 24 68       	lea    rsi,[rsp+0x68]
  20b34c:	e8 ef b3 00 00       	call   216740 <Benchmark_reportStats>
  20b351:	eb 10                	jmp    20b363 <BmNoSelf.lfence+0xb03>
                switch (errno) {
  20b353:	48 83 f9 16          	cmp    rcx,0x16
  20b357:	75 06                	jne    20b35f <BmNoSelf.lfence+0xaff>
  20b359:	66 b8 02 00          	mov    ax,0x2
  20b35d:	eb 04                	jmp    20b363 <BmNoSelf.lfence+0xb03>
  20b35f:	66 b8 03 00          	mov    ax,0x3
    _ = try bm.run(struct {
  20b363:	48 81 c4 f8 00 00 00 	add    rsp,0xf8
  20b36a:	5b                   	pop    rbx
  20b36b:	41 5c                	pop    r12
  20b36d:	41 5d                	pop    r13
  20b36f:	41 5e                	pop    r14
  20b371:	41 5f                	pop    r15
  20b373:	5d                   	pop    rbp
  20b374:	c5 f8 77             	vzeroupper 
  20b377:	c3                   	ret    
            @panic("assertion failure");
  20b378:	48 8d 3d 89 39 04 00 	lea    rdi,[rip+0x43989]        # 24ed08 <__unnamed_2>
  20b37f:	c5 f8 77             	vzeroupper 
  20b382:	e8 99 6c 00 00       	call   212020 <panic>
  20b387:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  20b38e:	00 00 

000000000020b390 <BmSelf.sfence>:
            lfence();
        }
    });
}

test "BmSelf.sfence" {
  20b390:	55                   	push   rbp
  20b391:	41 57                	push   r15
  20b393:	41 56                	push   r14
  20b395:	41 55                	push   r13
  20b397:	41 54                	push   r12
  20b399:	53                   	push   rbx
  20b39a:	48 81 ec f8 00 00 00 	sub    rsp,0xf8
  20b3a1:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20b3a8:	0f 1f 84 00 00 00 00 
  20b3af:	00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20b3b0:	b0 01                	mov    al,0x1
  20b3b2:	86 05 58 4c 04 00    	xchg   BYTE PTR [rip+0x44c58],al        # 250010 <stderr_mutex>
  20b3b8:	84 c0                	test   al,al
  20b3ba:	75 f4                	jne    20b3b0 <BmSelf.sfence+0x20>
    if (stderr_stream) |st| {
  20b3bc:	48 8b 3d 45 4c 04 00 	mov    rdi,QWORD PTR [rip+0x44c45]        # 250008 <stderr_stream>
  20b3c3:	48 85 ff             	test   rdi,rdi
  20b3c6:	74 09                	je     20b3d1 <BmSelf.sfence+0x41>
  20b3c8:	48 8b 05 71 fc 03 00 	mov    rax,QWORD PTR [rip+0x3fc71]        # 24b040 <stderr_file_out_stream+0x8>
  20b3cf:	eb 34                	jmp    20b405 <BmSelf.sfence+0x75>
        stderr_file = try io.getStdErr();
  20b3d1:	48 8d 05 58 fc 03 00 	lea    rax,[rip+0x3fc58]        # 24b030 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20b3d8:	48 89 05 59 fc 03 00 	mov    QWORD PTR [rip+0x3fc59],rax        # 24b038 <stderr_file_out_stream>
  20b3df:	48 8d 05 fa 45 01 00 	lea    rax,[rip+0x145fa]        # 21f9e0 <FileOutStream_writeFn>
  20b3e6:	48 89 05 53 fc 03 00 	mov    QWORD PTR [rip+0x3fc53],rax        # 24b040 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  20b3ed:	c7 05 39 fc 03 00 02 	mov    DWORD PTR [rip+0x3fc39],0x2        # 24b030 <stderr_file>
  20b3f4:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20b3f7:	48 8d 3d 42 fc 03 00 	lea    rdi,[rip+0x3fc42]        # 24b040 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  20b3fe:	48 89 3d 03 4c 04 00 	mov    QWORD PTR [rip+0x44c03],rdi        # 250008 <stderr_stream>
  20b405:	48 8d 35 0c 3a 04 00 	lea    rsi,[rip+0x43a0c]        # 24ee18 <__unnamed_3>
  20b40c:	ff d0                	call   rax
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20b40e:	31 c0                	xor    eax,eax
  20b410:	86 05 fa 4b 04 00    	xchg   BYTE PTR [rip+0x44bfa],al        # 250010 <stderr_mutex>
  20b416:	3c 01                	cmp    al,0x1
    if (!ok) {
  20b418:	0f 85 8a 0a 00 00    	jne    20bea8 <BmSelf.sfence+0xb18>
    // Since this is a test print a \n before we run
    warn("\n");

    // Create an instance of Benchmark and run
    var bm = Benchmark.init("BmSelf", std.debug.global_allocator);
  20b41e:	c5 f8 10 05 b2 38 04 	vmovups xmm0,XMMWORD PTR [rip+0x438b2]        # 24ecd8 <__unnamed_8>
  20b425:	00 
  20b426:	c5 f8 29 44 24 20    	vmovaps XMMWORD PTR [rsp+0x20],xmm0
  20b42c:	c5 fc 28 05 8c 4d ff 	vmovaps ymm0,YMMWORD PTR [rip+0xffffffffffff4d8c]        # 2001c0 <__unnamed_44-0x40>
  20b433:	ff 
  20b434:	c5 fc 11 44 24 30    	vmovups YMMWORD PTR [rsp+0x30],ymm0
  20b43a:	c5 fa 6f 05 7e d9 ff 	vmovdqu xmm0,XMMWORD PTR [rip+0xffffffffffffd97e]        # 208dc0 <__unnamed_5>
  20b441:	ff 
  20b442:	c5 f9 7f 44 24 50    	vmovdqa XMMWORD PTR [rsp+0x50],xmm0
  20b448:	48 8d 05 b1 fb 03 00 	lea    rax,[rip+0x3fbb1]        # 24b000 <global_fixed_allocator>
  20b44f:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  20b454:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  20b458:	c5 fa 7f 44 24 68    	vmovdqu XMMWORD PTR [rsp+0x68],xmm0
  20b45e:	48 c7 44 24 78 00 00 	mov    QWORD PTR [rsp+0x78],0x0
  20b465:	00 00 
  20b467:	48 89 84 24 80 00 00 	mov    QWORD PTR [rsp+0x80],rax
  20b46e:	00 
  20b46f:	41 b6 01             	mov    r14b,0x1
  20b472:	49 bf 00 e8 76 48 17 	movabs r15,0x174876e800
  20b479:	00 00 00 
  20b47c:	bb 01 00 00 00       	mov    ebx,0x1
  20b481:	4c 8d a4 24 90 00 00 	lea    r12,[rsp+0x90]
  20b488:	00 
  20b489:	45 31 ed             	xor    r13d,r13d
            while (iterations <= pSelf.max_iterations) {
  20b48c:	4c 39 fb             	cmp    rbx,r15
  20b48f:	0f 87 2e 03 00 00    	ja     20b7c3 <BmSelf.sfence+0x433>
  20b495:	eb 17                	jmp    20b4ae <BmSelf.sfence+0x11e>
  20b497:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  20b49e:	00 00 
                        warn("iteratons:{} numer:{} denom:{}\n", iterations, numer, denom);
  20b4a0:	48 89 df             	mov    rdi,rbx
  20b4a3:	48 89 ca             	mov    rdx,rcx
  20b4a6:	c5 f8 77             	vzeroupper 
  20b4a9:	e8 c2 a6 00 00       	call   215b70 <warn.36>
                var ts: posix.timespec = undefined;
  20b4ae:	c5 fa 6f 05 0a d9 ff 	vmovdqu xmm0,XMMWORD PTR [rip+0xffffffffffffd90a]        # 208dc0 <__unnamed_5>
  20b4b5:	ff 
  20b4b6:	c5 f9 7f 84 24 90 00 	vmovdqa XMMWORD PTR [rsp+0x90],xmm0
  20b4bd:	00 00 
  20b4bf:	b8 e5 00 00 00       	mov    eax,0xe5
  20b4c4:	bf 01 00 00 00       	mov    edi,0x1
  20b4c9:	4c 89 e6             	mov    rsi,r12
  20b4cc:	0f 05                	syscall 
  20b4ce:	48 89 c1             	mov    rcx,rax
  20b4d1:	48 f7 d9             	neg    rcx
  20b4d4:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  20b4da:	b8 00 00 00 00       	mov    eax,0x0
  20b4df:	48 0f 46 c8          	cmovbe rcx,rax
                switch (errno) {
  20b4e3:	48 85 c9             	test   rcx,rcx
  20b4e6:	0f 85 97 09 00 00    	jne    20be83 <BmSelf.sfence+0xaf3>
        const f = @atomicLoad(@typeOf(init_vdso_clock_gettime), &vdso_clock_gettime, builtin.AtomicOrder.Unordered);
  20b4ec:	48 8b 05 55 fb 03 00 	mov    rax,QWORD PTR [rip+0x3fb55]        # 24b048 <vdso_clock_gettime>
        if (@ptrToInt(f) != 0) {
  20b4f3:	48 85 c0             	test   rax,rax
  20b4f6:	74 24                	je     20b51c <BmSelf.sfence+0x18c>
            const rc = f(clk_id, tp);
  20b4f8:	bf 01 00 00 00       	mov    edi,0x1
  20b4fd:	4c 89 e6             	mov    rsi,r12
  20b500:	c5 f8 77             	vzeroupper 
  20b503:	ff d0                	call   rax
            switch (rc) {
  20b505:	48 83 f8 ea          	cmp    rax,0xffffffffffffffea
  20b509:	0f 84 41 02 00 00    	je     20b750 <BmSelf.sfence+0x3c0>
  20b50f:	48 85 c0             	test   rax,rax
  20b512:	c5 fa 6f 05 a6 d8 ff 	vmovdqu xmm0,XMMWORD PTR [rip+0xffffffffffffd8a6]        # 208dc0 <__unnamed_5>
  20b519:	ff 
  20b51a:	74 0f                	je     20b52b <BmSelf.sfence+0x19b>
  20b51c:	b8 e4 00 00 00       	mov    eax,0xe4
  20b521:	bf 01 00 00 00       	mov    edi,0x1
  20b526:	4c 89 e6             	mov    rsi,r12
  20b529:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  20b52b:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
                if (errno != 0) return std.os.unexpectedErrorPosix(errno);
  20b531:	0f 83 58 09 00 00    	jae    20be8f <BmSelf.sfence+0xaff>
                self.start_time = @intCast(u64, ts.tv_sec) * u64(ns_per_s) + @intCast(u64, ts.tv_nsec);
  20b537:	c5 f9 6f 8c 24 90 00 	vmovdqa xmm1,XMMWORD PTR [rsp+0x90]
  20b53e:	00 00 
        while (iter > 0) : (iter -= 1) {
  20b540:	48 85 db             	test   rbx,rbx
  20b543:	74 14                	je     20b559 <BmSelf.sfence+0x1c9>
  20b545:	48 89 d8             	mov    rax,rbx
  20b548:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  20b54f:	00 
    asm volatile ("sfence": : :"memory");
  20b550:	0f ae f8             	sfence 
        while (iter > 0) : (iter -= 1) {
  20b553:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  20b557:	75 f7                	jne    20b550 <BmSelf.sfence+0x1c0>
        var ts: posix.timespec = undefined;
  20b559:	c5 f9 7f 84 24 90 00 	vmovdqa XMMWORD PTR [rsp+0x90],xmm0
  20b560:	00 00 
        const f = @atomicLoad(@typeOf(init_vdso_clock_gettime), &vdso_clock_gettime, builtin.AtomicOrder.Unordered);
  20b562:	48 8b 05 df fa 03 00 	mov    rax,QWORD PTR [rip+0x3fadf]        # 24b048 <vdso_clock_gettime>
        if (@ptrToInt(f) != 0) {
  20b569:	48 85 c0             	test   rax,rax
  20b56c:	74 2e                	je     20b59c <BmSelf.sfence+0x20c>
  20b56e:	c5 f9 7f 8c 24 c0 00 	vmovdqa XMMWORD PTR [rsp+0xc0],xmm1
  20b575:	00 00 
            const rc = f(clk_id, tp);
  20b577:	bf 01 00 00 00       	mov    edi,0x1
  20b57c:	4c 89 e6             	mov    rsi,r12
  20b57f:	c5 f8 77             	vzeroupper 
  20b582:	ff d0                	call   rax
            switch (rc) {
  20b584:	48 83 f8 ea          	cmp    rax,0xffffffffffffffea
  20b588:	0f 84 db 01 00 00    	je     20b769 <BmSelf.sfence+0x3d9>
  20b58e:	48 85 c0             	test   rax,rax
  20b591:	c5 f9 6f 8c 24 c0 00 	vmovdqa xmm1,XMMWORD PTR [rsp+0xc0]
  20b598:	00 00 
  20b59a:	74 0f                	je     20b5ab <BmSelf.sfence+0x21b>
  20b59c:	b8 e4 00 00 00       	mov    eax,0xe4
  20b5a1:	bf 01 00 00 00       	mov    edi,0x1
  20b5a6:	4c 89 e6             	mov    rsi,r12
  20b5a9:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  20b5ab:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
  20b5b1:	0f 83 f1 08 00 00    	jae    20bea8 <BmSelf.sfence+0xb18>
        return @intCast(u64, ts.tv_sec) * u64(ns_per_s) + @intCast(u64, ts.tv_nsec);
  20b5b7:	c5 f9 6f 84 24 90 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x90]
  20b5be:	00 00 
  20b5c0:	c5 f9 fb c1          	vpsubq xmm0,xmm0,xmm1
  20b5c4:	c4 e1 f9 7e c0       	vmovq  rax,xmm0
        var clock = clockNative() - self.start_time;
  20b5c9:	c4 e3 f9 16 c5 01    	vpextrq rbp,xmm0,0x1
  20b5cf:	48 69 c0 00 ca 9a 3b 	imul   rax,rax,0x3b9aca00
  20b5d6:	48 01 c5             	add    rbp,rax
                if ((run_time_ns >= pSelf.min_runtime_ns) or (iterations >= pSelf.max_iterations)) {
  20b5d9:	48 3b 6c 24 38       	cmp    rbp,QWORD PTR [rsp+0x38]
  20b5de:	0f 83 9f 01 00 00    	jae    20b783 <BmSelf.sfence+0x3f3>
  20b5e4:	4c 39 fb             	cmp    rbx,r15
  20b5e7:	0f 83 96 01 00 00    	jae    20b783 <BmSelf.sfence+0x3f3>
                    if (pSelf.logl >= 1) {
  20b5ed:	48 83 7c 24 30 00    	cmp    QWORD PTR [rsp+0x30],0x0
  20b5f3:	0f 84 bd 00 00 00    	je     20b6b6 <BmSelf.sfence+0x326>
                            Result {.run_time_ns = run_time_ns, .iterations = iterations});
  20b5f9:	48 89 ac 24 d8 00 00 	mov    QWORD PTR [rsp+0xd8],rbp
  20b600:	00 
  20b601:	48 89 9c 24 e0 00 00 	mov    QWORD PTR [rsp+0xe0],rbx
  20b608:	00 
                        try pSelf.report(
  20b609:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  20b60e:	48 8d b4 24 d8 00 00 	lea    rsi,[rsp+0xd8]
  20b615:	00 
  20b616:	c5 f8 77             	vzeroupper 
  20b619:	e8 42 84 00 00       	call   213a60 <Benchmark_report>
  20b61e:	66 85 c0             	test   ax,ax
  20b621:	0f 85 6c 08 00 00    	jne    20be93 <BmSelf.sfence+0xb03>
  20b627:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  20b62e:	00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20b630:	b0 01                	mov    al,0x1
  20b632:	86 05 d8 49 04 00    	xchg   BYTE PTR [rip+0x449d8],al        # 250010 <stderr_mutex>
  20b638:	84 c0                	test   al,al
  20b63a:	75 f4                	jne    20b630 <BmSelf.sfence+0x2a0>
    if (stderr_stream) |st| {
  20b63c:	48 8b 3d c5 49 04 00 	mov    rdi,QWORD PTR [rip+0x449c5]        # 250008 <stderr_stream>
  20b643:	48 85 ff             	test   rdi,rdi
  20b646:	74 18                	je     20b660 <BmSelf.sfence+0x2d0>
  20b648:	48 8b 0d f1 f9 03 00 	mov    rcx,QWORD PTR [rip+0x3f9f1]        # 24b040 <stderr_file_out_stream+0x8>
  20b64f:	eb 4c                	jmp    20b69d <BmSelf.sfence+0x30d>
  20b651:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20b658:	0f 1f 84 00 00 00 00 
  20b65f:	00 
        stderr_file = try io.getStdErr();
  20b660:	c7 05 c6 f9 03 00 02 	mov    DWORD PTR [rip+0x3f9c6],0x2        # 24b030 <stderr_file>
  20b667:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20b66a:	48 8d 05 bf f9 03 00 	lea    rax,[rip+0x3f9bf]        # 24b030 <stderr_file>
  20b671:	48 89 05 c0 f9 03 00 	mov    QWORD PTR [rip+0x3f9c0],rax        # 24b038 <stderr_file_out_stream>
  20b678:	48 8d 05 61 43 01 00 	lea    rax,[rip+0x14361]        # 21f9e0 <FileOutStream_writeFn>
  20b67f:	48 89 05 ba f9 03 00 	mov    QWORD PTR [rip+0x3f9ba],rax        # 24b040 <stderr_file_out_stream+0x8>
  20b686:	48 8d 0d b3 f9 03 00 	lea    rcx,[rip+0x3f9b3]        # 24b040 <stderr_file_out_stream+0x8>
  20b68d:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20b690:	48 89 15 71 49 04 00 	mov    QWORD PTR [rip+0x44971],rdx        # 250008 <stderr_stream>
  20b697:	48 89 c1             	mov    rcx,rax
  20b69a:	48 89 d7             	mov    rdi,rdx
  20b69d:	48 8d 35 74 37 04 00 	lea    rsi,[rip+0x43774]        # 24ee18 <__unnamed_3>
  20b6a4:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20b6a6:	31 c0                	xor    eax,eax
  20b6a8:	86 05 62 49 04 00    	xchg   BYTE PTR [rip+0x44962],al        # 250010 <stderr_mutex>
  20b6ae:	3c 01                	cmp    al,0x1
    if (!ok) {
  20b6b0:	0f 85 f2 07 00 00    	jne    20bea8 <BmSelf.sfence+0xb18>
                    if (run_time_ns < 1000) {
  20b6b6:	48 81 fd e8 03 00 00 	cmp    rbp,0x3e8
  20b6bd:	73 31                	jae    20b6f0 <BmSelf.sfence+0x360>
  20b6bf:	b9 01 00 00 00       	mov    ecx,0x1
  20b6c4:	be e8 03 00 00       	mov    esi,0x3e8
                    iterations = (iterations * numer) / denom;
  20b6c9:	48 0f af de          	imul   rbx,rsi
  20b6cd:	48 89 d8             	mov    rax,rbx
  20b6d0:	48 c1 e8 20          	shr    rax,0x20
  20b6d4:	74 54                	je     20b72a <BmSelf.sfence+0x39a>
  20b6d6:	31 d2                	xor    edx,edx
  20b6d8:	48 89 d8             	mov    rax,rbx
  20b6db:	48 f7 f1             	div    rcx
  20b6de:	48 89 c3             	mov    rbx,rax
  20b6e1:	eb 4f                	jmp    20b732 <BmSelf.sfence+0x3a2>
  20b6e3:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20b6ea:	84 00 00 00 00 00 
                    } else if (run_time_ns < (pSelf.min_runtime_ns / 10)) {
  20b6f0:	48 ba cd cc cc cc cc 	movabs rdx,0xcccccccccccccccd
  20b6f7:	cc cc cc 
  20b6fa:	c4 e2 fb f6 4c 24 38 	mulx   rcx,rax,QWORD PTR [rsp+0x38]
  20b701:	48 c1 e9 03          	shr    rcx,0x3
  20b705:	31 c0                	xor    eax,eax
  20b707:	48 39 cd             	cmp    rbp,rcx
  20b70a:	0f 93 c0             	setae  al
  20b70d:	48 8d 0c c0          	lea    rcx,[rax+rax*8]
  20b711:	48 83 c1 01          	add    rcx,0x1
  20b715:	48 8d 34 85 0a 00 00 	lea    rsi,[rax*4+0xa]
  20b71c:	00 
                    iterations = (iterations * numer) / denom;
  20b71d:	48 0f af de          	imul   rbx,rsi
  20b721:	48 89 d8             	mov    rax,rbx
  20b724:	48 c1 e8 20          	shr    rax,0x20
  20b728:	75 ac                	jne    20b6d6 <BmSelf.sfence+0x346>
  20b72a:	31 d2                	xor    edx,edx
  20b72c:	89 d8                	mov    eax,ebx
  20b72e:	f7 f1                	div    ecx
  20b730:	89 c3                	mov    ebx,eax
                    if (iterations > pSelf.max_iterations) {
  20b732:	4c 8b 7c 24 48       	mov    r15,QWORD PTR [rsp+0x48]
  20b737:	4c 39 fb             	cmp    rbx,r15
  20b73a:	49 0f 47 df          	cmova  rbx,r15
                    if (pSelf.logl >= 2) {
  20b73e:	48 83 7c 24 30 02    	cmp    QWORD PTR [rsp+0x30],0x2
  20b744:	0f 82 64 fd ff ff    	jb     20b4ae <BmSelf.sfence+0x11e>
  20b74a:	e9 51 fd ff ff       	jmp    20b4a0 <BmSelf.sfence+0x110>
  20b74f:	90                   	nop
  20b750:	c5 fa 6f 05 68 d6 ff 	vmovdqu xmm0,XMMWORD PTR [rip+0xffffffffffffd668]        # 208dc0 <__unnamed_5>
  20b757:	ff 
  20b758:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
                if (errno != 0) return std.os.unexpectedErrorPosix(errno);
  20b75e:	0f 82 d3 fd ff ff    	jb     20b537 <BmSelf.sfence+0x1a7>
  20b764:	e9 26 07 00 00       	jmp    20be8f <BmSelf.sfence+0xaff>
  20b769:	c5 f9 6f 8c 24 c0 00 	vmovdqa xmm1,XMMWORD PTR [rsp+0xc0]
  20b770:	00 00 
  20b772:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
  20b778:	0f 82 39 fe ff ff    	jb     20b5b7 <BmSelf.sfence+0x227>
  20b77e:	e9 25 07 00 00       	jmp    20bea8 <BmSelf.sfence+0xb18>
                            Result { .run_time_ns = run_time_ns, .iterations = iterations});
  20b783:	48 89 ac 24 e8 00 00 	mov    QWORD PTR [rsp+0xe8],rbp
  20b78a:	00 
  20b78b:	48 89 9c 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rbx
  20b792:	00 
                    try pSelf.results.append(
  20b793:	48 8d 7c 24 68       	lea    rdi,[rsp+0x68]
  20b798:	48 8d b4 24 e8 00 00 	lea    rsi,[rsp+0xe8]
  20b79f:	00 
  20b7a0:	c5 f8 77             	vzeroupper 
  20b7a3:	e8 48 81 00 00       	call   2138f0 <AlignedArrayList(Result,8)_append>
  20b7a8:	66 85 c0             	test   ax,ax
  20b7ab:	74 16                	je     20b7c3 <BmSelf.sfence+0x433>
  20b7ad:	e9 e1 06 00 00       	jmp    20be93 <BmSelf.sfence+0xb03>
            while (iterations <= pSelf.max_iterations) {
  20b7b2:	4c 8b 7c 24 48       	mov    r15,QWORD PTR [rsp+0x48]
  20b7b7:	45 31 f6             	xor    r14d,r14d
  20b7ba:	4c 39 fb             	cmp    rbx,r15
  20b7bd:	0f 86 eb fc ff ff    	jbe    20b4ae <BmSelf.sfence+0x11e>
            if (once) {
  20b7c3:	41 f6 c6 01          	test   r14b,0x1
  20b7c7:	48 8d 6c 24 0f       	lea    rbp,[rsp+0xf]
  20b7cc:	4c 8d 74 24 10       	lea    r14,[rsp+0x10]
  20b7d1:	0f 84 e0 05 00 00    	je     20bdb7 <BmSelf.sfence+0xa27>
                try leftJustified(22, "name repetitions:{}", pSelf.repetitions);
  20b7d7:	48 8b 7c 24 40       	mov    rdi,QWORD PTR [rsp+0x40]
  20b7dc:	c5 f8 77             	vzeroupper 
  20b7df:	e8 fc a6 00 00       	call   215ee0 <Benchmark_leftJustified>
  20b7e4:	66 85 c0             	test   ax,ax
  20b7e7:	0f 85 a6 06 00 00    	jne    20be93 <BmSelf.sfence+0xb03>
                try rightJustified(14, "{}", "iterations");
  20b7ed:	e8 8e a9 00 00       	call   216180 <Benchmark_rightJustified>
  20b7f2:	66 85 c0             	test   ax,ax
  20b7f5:	0f 85 98 06 00 00    	jne    20be93 <BmSelf.sfence+0xb03>
        var buffer: [40]u8 = undefined;
  20b7fb:	c5 fe 6f 05 98 9d ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffff9d98]        # 20559b <__unnamed_7>
  20b802:	ff 
  20b803:	c5 fe 7f 84 24 90 00 	vmovdqu YMMWORD PTR [rsp+0x90],ymm0
  20b80a:	00 00 
  20b80c:	48 8b 05 a8 9d ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffff9da8]        # 2055bb <__unnamed_7+0x20>
  20b813:	48 89 84 24 b0 00 00 	mov    QWORD PTR [rsp+0xb0],rax
  20b81a:	00 
  20b81b:	c7 84 24 90 00 00 00 	mov    DWORD PTR [rsp+0x90],0x656d6974
  20b822:	74 69 6d 65 
  20b826:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  20b82d:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20b830:	b0 01                	mov    al,0x1
  20b832:	86 05 d8 47 04 00    	xchg   BYTE PTR [rip+0x447d8],al        # 250010 <stderr_mutex>
  20b838:	84 c0                	test   al,al
  20b83a:	75 f4                	jne    20b830 <BmSelf.sfence+0x4a0>
    if (stderr_stream) |st| {
  20b83c:	48 8b 3d c5 47 04 00 	mov    rdi,QWORD PTR [rip+0x447c5]        # 250008 <stderr_stream>
  20b843:	48 85 ff             	test   rdi,rdi
  20b846:	74 09                	je     20b851 <BmSelf.sfence+0x4c1>
  20b848:	48 8b 0d f1 f7 03 00 	mov    rcx,QWORD PTR [rip+0x3f7f1]        # 24b040 <stderr_file_out_stream+0x8>
  20b84f:	eb 3d                	jmp    20b88e <BmSelf.sfence+0x4fe>
        stderr_file = try io.getStdErr();
  20b851:	c7 05 d5 f7 03 00 02 	mov    DWORD PTR [rip+0x3f7d5],0x2        # 24b030 <stderr_file>
  20b858:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20b85b:	48 8d 05 ce f7 03 00 	lea    rax,[rip+0x3f7ce]        # 24b030 <stderr_file>
  20b862:	48 89 05 cf f7 03 00 	mov    QWORD PTR [rip+0x3f7cf],rax        # 24b038 <stderr_file_out_stream>
  20b869:	48 8d 05 70 41 01 00 	lea    rax,[rip+0x14170]        # 21f9e0 <FileOutStream_writeFn>
  20b870:	48 89 05 c9 f7 03 00 	mov    QWORD PTR [rip+0x3f7c9],rax        # 24b040 <stderr_file_out_stream+0x8>
  20b877:	48 8d 0d c2 f7 03 00 	lea    rcx,[rip+0x3f7c2]        # 24b040 <stderr_file_out_stream+0x8>
  20b87e:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20b881:	48 89 15 80 47 04 00 	mov    QWORD PTR [rip+0x44780],rdx        # 250008 <stderr_stream>
  20b888:	48 89 c1             	mov    rcx,rax
  20b88b:	48 89 d7             	mov    rdi,rdx
  20b88e:	c6 44 24 0f 20       	mov    BYTE PTR [rsp+0xf],0x20
    return output(context, (*[1]u8)(&c)[0..]);
  20b893:	48 89 6c 24 10       	mov    QWORD PTR [rsp+0x10],rbp
  20b898:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  20b89f:	00 00 
  20b8a1:	4c 89 f6             	mov    rsi,r14
  20b8a4:	c5 f8 77             	vzeroupper 
  20b8a7:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20b8a9:	31 c0                	xor    eax,eax
  20b8ab:	86 05 5f 47 04 00    	xchg   BYTE PTR [rip+0x4475f],al        # 250010 <stderr_mutex>
  20b8b1:	3c 01                	cmp    al,0x1
    if (!ok) {
  20b8b3:	0f 85 ef 05 00 00    	jne    20bea8 <BmSelf.sfence+0xb18>
  20b8b9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20b8c0:	b0 01                	mov    al,0x1
  20b8c2:	86 05 48 47 04 00    	xchg   BYTE PTR [rip+0x44748],al        # 250010 <stderr_mutex>
  20b8c8:	84 c0                	test   al,al
  20b8ca:	75 f4                	jne    20b8c0 <BmSelf.sfence+0x530>
    if (stderr_stream) |st| {
  20b8cc:	48 8b 3d 35 47 04 00 	mov    rdi,QWORD PTR [rip+0x44735]        # 250008 <stderr_stream>
  20b8d3:	48 85 ff             	test   rdi,rdi
  20b8d6:	74 09                	je     20b8e1 <BmSelf.sfence+0x551>
  20b8d8:	48 8b 0d 61 f7 03 00 	mov    rcx,QWORD PTR [rip+0x3f761]        # 24b040 <stderr_file_out_stream+0x8>
  20b8df:	eb 3d                	jmp    20b91e <BmSelf.sfence+0x58e>
        stderr_file = try io.getStdErr();
  20b8e1:	c7 05 45 f7 03 00 02 	mov    DWORD PTR [rip+0x3f745],0x2        # 24b030 <stderr_file>
  20b8e8:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20b8eb:	48 8d 05 3e f7 03 00 	lea    rax,[rip+0x3f73e]        # 24b030 <stderr_file>
  20b8f2:	48 89 05 3f f7 03 00 	mov    QWORD PTR [rip+0x3f73f],rax        # 24b038 <stderr_file_out_stream>
  20b8f9:	48 8d 05 e0 40 01 00 	lea    rax,[rip+0x140e0]        # 21f9e0 <FileOutStream_writeFn>
  20b900:	48 89 05 39 f7 03 00 	mov    QWORD PTR [rip+0x3f739],rax        # 24b040 <stderr_file_out_stream+0x8>
  20b907:	48 8d 0d 32 f7 03 00 	lea    rcx,[rip+0x3f732]        # 24b040 <stderr_file_out_stream+0x8>
  20b90e:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20b911:	48 89 15 f0 46 04 00 	mov    QWORD PTR [rip+0x446f0],rdx        # 250008 <stderr_stream>
  20b918:	48 89 c1             	mov    rcx,rax
  20b91b:	48 89 d7             	mov    rdi,rdx
  20b91e:	c6 44 24 0f 20       	mov    BYTE PTR [rsp+0xf],0x20
  20b923:	48 89 6c 24 10       	mov    QWORD PTR [rsp+0x10],rbp
  20b928:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  20b92f:	00 00 
  20b931:	4c 89 f6             	mov    rsi,r14
  20b934:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20b936:	31 c0                	xor    eax,eax
  20b938:	86 05 d2 46 04 00    	xchg   BYTE PTR [rip+0x446d2],al        # 250010 <stderr_mutex>
  20b93e:	3c 01                	cmp    al,0x1
    if (!ok) {
  20b940:	0f 85 62 05 00 00    	jne    20bea8 <BmSelf.sfence+0xb18>
  20b946:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  20b94d:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20b950:	b0 01                	mov    al,0x1
  20b952:	86 05 b8 46 04 00    	xchg   BYTE PTR [rip+0x446b8],al        # 250010 <stderr_mutex>
  20b958:	84 c0                	test   al,al
  20b95a:	75 f4                	jne    20b950 <BmSelf.sfence+0x5c0>
    if (stderr_stream) |st| {
  20b95c:	48 8b 3d a5 46 04 00 	mov    rdi,QWORD PTR [rip+0x446a5]        # 250008 <stderr_stream>
  20b963:	48 85 ff             	test   rdi,rdi
  20b966:	74 09                	je     20b971 <BmSelf.sfence+0x5e1>
  20b968:	48 8b 0d d1 f6 03 00 	mov    rcx,QWORD PTR [rip+0x3f6d1]        # 24b040 <stderr_file_out_stream+0x8>
  20b96f:	eb 3d                	jmp    20b9ae <BmSelf.sfence+0x61e>
        stderr_file = try io.getStdErr();
  20b971:	c7 05 b5 f6 03 00 02 	mov    DWORD PTR [rip+0x3f6b5],0x2        # 24b030 <stderr_file>
  20b978:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20b97b:	48 8d 05 ae f6 03 00 	lea    rax,[rip+0x3f6ae]        # 24b030 <stderr_file>
  20b982:	48 89 05 af f6 03 00 	mov    QWORD PTR [rip+0x3f6af],rax        # 24b038 <stderr_file_out_stream>
  20b989:	48 8d 05 50 40 01 00 	lea    rax,[rip+0x14050]        # 21f9e0 <FileOutStream_writeFn>
  20b990:	48 89 05 a9 f6 03 00 	mov    QWORD PTR [rip+0x3f6a9],rax        # 24b040 <stderr_file_out_stream+0x8>
  20b997:	48 8d 0d a2 f6 03 00 	lea    rcx,[rip+0x3f6a2]        # 24b040 <stderr_file_out_stream+0x8>
  20b99e:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20b9a1:	48 89 15 60 46 04 00 	mov    QWORD PTR [rip+0x44660],rdx        # 250008 <stderr_stream>
  20b9a8:	48 89 c1             	mov    rcx,rax
  20b9ab:	48 89 d7             	mov    rdi,rdx
  20b9ae:	c6 44 24 0f 20       	mov    BYTE PTR [rsp+0xf],0x20
  20b9b3:	48 89 6c 24 10       	mov    QWORD PTR [rsp+0x10],rbp
  20b9b8:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  20b9bf:	00 00 
  20b9c1:	4c 89 f6             	mov    rsi,r14
  20b9c4:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20b9c6:	31 c0                	xor    eax,eax
  20b9c8:	86 05 42 46 04 00    	xchg   BYTE PTR [rip+0x44642],al        # 250010 <stderr_mutex>
  20b9ce:	3c 01                	cmp    al,0x1
    if (!ok) {
  20b9d0:	0f 85 d2 04 00 00    	jne    20bea8 <BmSelf.sfence+0xb18>
  20b9d6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  20b9dd:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20b9e0:	b0 01                	mov    al,0x1
  20b9e2:	86 05 28 46 04 00    	xchg   BYTE PTR [rip+0x44628],al        # 250010 <stderr_mutex>
  20b9e8:	84 c0                	test   al,al
  20b9ea:	75 f4                	jne    20b9e0 <BmSelf.sfence+0x650>
    if (stderr_stream) |st| {
  20b9ec:	48 8b 3d 15 46 04 00 	mov    rdi,QWORD PTR [rip+0x44615]        # 250008 <stderr_stream>
  20b9f3:	48 85 ff             	test   rdi,rdi
  20b9f6:	74 09                	je     20ba01 <BmSelf.sfence+0x671>
  20b9f8:	48 8b 0d 41 f6 03 00 	mov    rcx,QWORD PTR [rip+0x3f641]        # 24b040 <stderr_file_out_stream+0x8>
  20b9ff:	eb 3d                	jmp    20ba3e <BmSelf.sfence+0x6ae>
        stderr_file = try io.getStdErr();
  20ba01:	c7 05 25 f6 03 00 02 	mov    DWORD PTR [rip+0x3f625],0x2        # 24b030 <stderr_file>
  20ba08:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20ba0b:	48 8d 05 1e f6 03 00 	lea    rax,[rip+0x3f61e]        # 24b030 <stderr_file>
  20ba12:	48 89 05 1f f6 03 00 	mov    QWORD PTR [rip+0x3f61f],rax        # 24b038 <stderr_file_out_stream>
  20ba19:	48 8d 05 c0 3f 01 00 	lea    rax,[rip+0x13fc0]        # 21f9e0 <FileOutStream_writeFn>
  20ba20:	48 89 05 19 f6 03 00 	mov    QWORD PTR [rip+0x3f619],rax        # 24b040 <stderr_file_out_stream+0x8>
  20ba27:	48 8d 0d 12 f6 03 00 	lea    rcx,[rip+0x3f612]        # 24b040 <stderr_file_out_stream+0x8>
  20ba2e:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20ba31:	48 89 15 d0 45 04 00 	mov    QWORD PTR [rip+0x445d0],rdx        # 250008 <stderr_stream>
  20ba38:	48 89 c1             	mov    rcx,rax
  20ba3b:	48 89 d7             	mov    rdi,rdx
  20ba3e:	c6 44 24 0f 20       	mov    BYTE PTR [rsp+0xf],0x20
  20ba43:	48 89 6c 24 10       	mov    QWORD PTR [rsp+0x10],rbp
  20ba48:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  20ba4f:	00 00 
  20ba51:	4c 89 f6             	mov    rsi,r14
  20ba54:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20ba56:	31 c0                	xor    eax,eax
  20ba58:	86 05 b2 45 04 00    	xchg   BYTE PTR [rip+0x445b2],al        # 250010 <stderr_mutex>
  20ba5e:	3c 01                	cmp    al,0x1
    if (!ok) {
  20ba60:	0f 85 42 04 00 00    	jne    20bea8 <BmSelf.sfence+0xb18>
  20ba66:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  20ba6d:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20ba70:	b0 01                	mov    al,0x1
  20ba72:	86 05 98 45 04 00    	xchg   BYTE PTR [rip+0x44598],al        # 250010 <stderr_mutex>
  20ba78:	84 c0                	test   al,al
  20ba7a:	75 f4                	jne    20ba70 <BmSelf.sfence+0x6e0>
    if (stderr_stream) |st| {
  20ba7c:	48 8b 3d 85 45 04 00 	mov    rdi,QWORD PTR [rip+0x44585]        # 250008 <stderr_stream>
  20ba83:	48 85 ff             	test   rdi,rdi
  20ba86:	74 09                	je     20ba91 <BmSelf.sfence+0x701>
  20ba88:	48 8b 0d b1 f5 03 00 	mov    rcx,QWORD PTR [rip+0x3f5b1]        # 24b040 <stderr_file_out_stream+0x8>
  20ba8f:	eb 3d                	jmp    20bace <BmSelf.sfence+0x73e>
        stderr_file = try io.getStdErr();
  20ba91:	c7 05 95 f5 03 00 02 	mov    DWORD PTR [rip+0x3f595],0x2        # 24b030 <stderr_file>
  20ba98:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20ba9b:	48 8d 05 8e f5 03 00 	lea    rax,[rip+0x3f58e]        # 24b030 <stderr_file>
  20baa2:	48 89 05 8f f5 03 00 	mov    QWORD PTR [rip+0x3f58f],rax        # 24b038 <stderr_file_out_stream>
  20baa9:	48 8d 05 30 3f 01 00 	lea    rax,[rip+0x13f30]        # 21f9e0 <FileOutStream_writeFn>
  20bab0:	48 89 05 89 f5 03 00 	mov    QWORD PTR [rip+0x3f589],rax        # 24b040 <stderr_file_out_stream+0x8>
  20bab7:	48 8d 0d 82 f5 03 00 	lea    rcx,[rip+0x3f582]        # 24b040 <stderr_file_out_stream+0x8>
  20babe:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20bac1:	48 89 15 40 45 04 00 	mov    QWORD PTR [rip+0x44540],rdx        # 250008 <stderr_stream>
  20bac8:	48 89 c1             	mov    rcx,rax
  20bacb:	48 89 d7             	mov    rdi,rdx
  20bace:	c6 44 24 0f 20       	mov    BYTE PTR [rsp+0xf],0x20
  20bad3:	48 89 6c 24 10       	mov    QWORD PTR [rsp+0x10],rbp
  20bad8:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  20badf:	00 00 
  20bae1:	4c 89 f6             	mov    rsi,r14
  20bae4:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20bae6:	31 c0                	xor    eax,eax
  20bae8:	86 05 22 45 04 00    	xchg   BYTE PTR [rip+0x44522],al        # 250010 <stderr_mutex>
  20baee:	3c 01                	cmp    al,0x1
    if (!ok) {
  20baf0:	0f 85 b2 03 00 00    	jne    20bea8 <BmSelf.sfence+0xb18>
  20baf6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  20bafd:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20bb00:	b0 01                	mov    al,0x1
  20bb02:	86 05 08 45 04 00    	xchg   BYTE PTR [rip+0x44508],al        # 250010 <stderr_mutex>
  20bb08:	84 c0                	test   al,al
  20bb0a:	75 f4                	jne    20bb00 <BmSelf.sfence+0x770>
    if (stderr_stream) |st| {
  20bb0c:	48 8b 3d f5 44 04 00 	mov    rdi,QWORD PTR [rip+0x444f5]        # 250008 <stderr_stream>
  20bb13:	48 85 ff             	test   rdi,rdi
  20bb16:	74 09                	je     20bb21 <BmSelf.sfence+0x791>
  20bb18:	48 8b 0d 21 f5 03 00 	mov    rcx,QWORD PTR [rip+0x3f521]        # 24b040 <stderr_file_out_stream+0x8>
  20bb1f:	eb 3d                	jmp    20bb5e <BmSelf.sfence+0x7ce>
        stderr_file = try io.getStdErr();
  20bb21:	c7 05 05 f5 03 00 02 	mov    DWORD PTR [rip+0x3f505],0x2        # 24b030 <stderr_file>
  20bb28:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20bb2b:	48 8d 05 fe f4 03 00 	lea    rax,[rip+0x3f4fe]        # 24b030 <stderr_file>
  20bb32:	48 89 05 ff f4 03 00 	mov    QWORD PTR [rip+0x3f4ff],rax        # 24b038 <stderr_file_out_stream>
  20bb39:	48 8d 05 a0 3e 01 00 	lea    rax,[rip+0x13ea0]        # 21f9e0 <FileOutStream_writeFn>
  20bb40:	48 89 05 f9 f4 03 00 	mov    QWORD PTR [rip+0x3f4f9],rax        # 24b040 <stderr_file_out_stream+0x8>
  20bb47:	48 8d 0d f2 f4 03 00 	lea    rcx,[rip+0x3f4f2]        # 24b040 <stderr_file_out_stream+0x8>
  20bb4e:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20bb51:	48 89 15 b0 44 04 00 	mov    QWORD PTR [rip+0x444b0],rdx        # 250008 <stderr_stream>
  20bb58:	48 89 c1             	mov    rcx,rax
  20bb5b:	48 89 d7             	mov    rdi,rdx
  20bb5e:	c6 44 24 0f 20       	mov    BYTE PTR [rsp+0xf],0x20
  20bb63:	48 89 6c 24 10       	mov    QWORD PTR [rsp+0x10],rbp
  20bb68:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  20bb6f:	00 00 
  20bb71:	4c 89 f6             	mov    rsi,r14
  20bb74:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20bb76:	31 c0                	xor    eax,eax
  20bb78:	86 05 92 44 04 00    	xchg   BYTE PTR [rip+0x44492],al        # 250010 <stderr_mutex>
  20bb7e:	3c 01                	cmp    al,0x1
    if (!ok) {
  20bb80:	0f 85 22 03 00 00    	jne    20bea8 <BmSelf.sfence+0xb18>
  20bb86:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  20bb8d:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20bb90:	b0 01                	mov    al,0x1
  20bb92:	86 05 78 44 04 00    	xchg   BYTE PTR [rip+0x44478],al        # 250010 <stderr_mutex>
  20bb98:	84 c0                	test   al,al
  20bb9a:	75 f4                	jne    20bb90 <BmSelf.sfence+0x800>
    if (stderr_stream) |st| {
  20bb9c:	48 8b 3d 65 44 04 00 	mov    rdi,QWORD PTR [rip+0x44465]        # 250008 <stderr_stream>
  20bba3:	48 85 ff             	test   rdi,rdi
  20bba6:	74 09                	je     20bbb1 <BmSelf.sfence+0x821>
  20bba8:	48 8b 0d 91 f4 03 00 	mov    rcx,QWORD PTR [rip+0x3f491]        # 24b040 <stderr_file_out_stream+0x8>
  20bbaf:	eb 3d                	jmp    20bbee <BmSelf.sfence+0x85e>
        stderr_file = try io.getStdErr();
  20bbb1:	c7 05 75 f4 03 00 02 	mov    DWORD PTR [rip+0x3f475],0x2        # 24b030 <stderr_file>
  20bbb8:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20bbbb:	48 8d 05 6e f4 03 00 	lea    rax,[rip+0x3f46e]        # 24b030 <stderr_file>
  20bbc2:	48 89 05 6f f4 03 00 	mov    QWORD PTR [rip+0x3f46f],rax        # 24b038 <stderr_file_out_stream>
  20bbc9:	48 8d 05 10 3e 01 00 	lea    rax,[rip+0x13e10]        # 21f9e0 <FileOutStream_writeFn>
  20bbd0:	48 89 05 69 f4 03 00 	mov    QWORD PTR [rip+0x3f469],rax        # 24b040 <stderr_file_out_stream+0x8>
  20bbd7:	48 8d 0d 62 f4 03 00 	lea    rcx,[rip+0x3f462]        # 24b040 <stderr_file_out_stream+0x8>
  20bbde:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20bbe1:	48 89 15 20 44 04 00 	mov    QWORD PTR [rip+0x44420],rdx        # 250008 <stderr_stream>
  20bbe8:	48 89 c1             	mov    rcx,rax
  20bbeb:	48 89 d7             	mov    rdi,rdx
  20bbee:	c6 44 24 0f 20       	mov    BYTE PTR [rsp+0xf],0x20
  20bbf3:	48 89 6c 24 10       	mov    QWORD PTR [rsp+0x10],rbp
  20bbf8:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  20bbff:	00 00 
  20bc01:	4c 89 f6             	mov    rsi,r14
  20bc04:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20bc06:	31 c0                	xor    eax,eax
  20bc08:	86 05 02 44 04 00    	xchg   BYTE PTR [rip+0x44402],al        # 250010 <stderr_mutex>
  20bc0e:	3c 01                	cmp    al,0x1
    if (!ok) {
  20bc10:	0f 85 92 02 00 00    	jne    20bea8 <BmSelf.sfence+0xb18>
  20bc16:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  20bc1d:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20bc20:	b0 01                	mov    al,0x1
  20bc22:	86 05 e8 43 04 00    	xchg   BYTE PTR [rip+0x443e8],al        # 250010 <stderr_mutex>
  20bc28:	84 c0                	test   al,al
  20bc2a:	75 f4                	jne    20bc20 <BmSelf.sfence+0x890>
    if (stderr_stream) |st| {
  20bc2c:	48 8b 3d d5 43 04 00 	mov    rdi,QWORD PTR [rip+0x443d5]        # 250008 <stderr_stream>
  20bc33:	48 85 ff             	test   rdi,rdi
  20bc36:	74 09                	je     20bc41 <BmSelf.sfence+0x8b1>
  20bc38:	48 8b 0d 01 f4 03 00 	mov    rcx,QWORD PTR [rip+0x3f401]        # 24b040 <stderr_file_out_stream+0x8>
  20bc3f:	eb 3d                	jmp    20bc7e <BmSelf.sfence+0x8ee>
        stderr_file = try io.getStdErr();
  20bc41:	c7 05 e5 f3 03 00 02 	mov    DWORD PTR [rip+0x3f3e5],0x2        # 24b030 <stderr_file>
  20bc48:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20bc4b:	48 8d 05 de f3 03 00 	lea    rax,[rip+0x3f3de]        # 24b030 <stderr_file>
  20bc52:	48 89 05 df f3 03 00 	mov    QWORD PTR [rip+0x3f3df],rax        # 24b038 <stderr_file_out_stream>
  20bc59:	48 8d 05 80 3d 01 00 	lea    rax,[rip+0x13d80]        # 21f9e0 <FileOutStream_writeFn>
  20bc60:	48 89 05 d9 f3 03 00 	mov    QWORD PTR [rip+0x3f3d9],rax        # 24b040 <stderr_file_out_stream+0x8>
  20bc67:	48 8d 0d d2 f3 03 00 	lea    rcx,[rip+0x3f3d2]        # 24b040 <stderr_file_out_stream+0x8>
  20bc6e:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20bc71:	48 89 15 90 43 04 00 	mov    QWORD PTR [rip+0x44390],rdx        # 250008 <stderr_stream>
  20bc78:	48 89 c1             	mov    rcx,rax
  20bc7b:	48 89 d7             	mov    rdi,rdx
  20bc7e:	c6 44 24 0f 20       	mov    BYTE PTR [rsp+0xf],0x20
  20bc83:	48 89 6c 24 10       	mov    QWORD PTR [rsp+0x10],rbp
  20bc88:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  20bc8f:	00 00 
  20bc91:	4c 89 f6             	mov    rsi,r14
  20bc94:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20bc96:	31 c0                	xor    eax,eax
  20bc98:	86 05 72 43 04 00    	xchg   BYTE PTR [rip+0x44372],al        # 250010 <stderr_mutex>
  20bc9e:	3c 01                	cmp    al,0x1
    if (!ok) {
  20bca0:	0f 85 02 02 00 00    	jne    20bea8 <BmSelf.sfence+0xb18>
  20bca6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  20bcad:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20bcb0:	b0 01                	mov    al,0x1
  20bcb2:	86 05 58 43 04 00    	xchg   BYTE PTR [rip+0x44358],al        # 250010 <stderr_mutex>
  20bcb8:	84 c0                	test   al,al
  20bcba:	75 f4                	jne    20bcb0 <BmSelf.sfence+0x920>
    if (stderr_stream) |st| {
  20bcbc:	48 8b 3d 45 43 04 00 	mov    rdi,QWORD PTR [rip+0x44345]        # 250008 <stderr_stream>
  20bcc3:	48 85 ff             	test   rdi,rdi
  20bcc6:	74 09                	je     20bcd1 <BmSelf.sfence+0x941>
  20bcc8:	48 8b 0d 71 f3 03 00 	mov    rcx,QWORD PTR [rip+0x3f371]        # 24b040 <stderr_file_out_stream+0x8>
  20bccf:	eb 3d                	jmp    20bd0e <BmSelf.sfence+0x97e>
        stderr_file = try io.getStdErr();
  20bcd1:	c7 05 55 f3 03 00 02 	mov    DWORD PTR [rip+0x3f355],0x2        # 24b030 <stderr_file>
  20bcd8:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20bcdb:	48 8d 05 4e f3 03 00 	lea    rax,[rip+0x3f34e]        # 24b030 <stderr_file>
  20bce2:	48 89 05 4f f3 03 00 	mov    QWORD PTR [rip+0x3f34f],rax        # 24b038 <stderr_file_out_stream>
  20bce9:	48 8d 05 f0 3c 01 00 	lea    rax,[rip+0x13cf0]        # 21f9e0 <FileOutStream_writeFn>
  20bcf0:	48 89 05 49 f3 03 00 	mov    QWORD PTR [rip+0x3f349],rax        # 24b040 <stderr_file_out_stream+0x8>
  20bcf7:	48 8d 0d 42 f3 03 00 	lea    rcx,[rip+0x3f342]        # 24b040 <stderr_file_out_stream+0x8>
  20bcfe:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20bd01:	48 89 15 00 43 04 00 	mov    QWORD PTR [rip+0x44300],rdx        # 250008 <stderr_stream>
  20bd08:	48 89 c1             	mov    rcx,rax
  20bd0b:	48 89 d7             	mov    rdi,rdx
                const casted_value = ([]const u8)(value);
  20bd0e:	4c 89 64 24 10       	mov    QWORD PTR [rsp+0x10],r12
  20bd13:	48 c7 44 24 18 04 00 	mov    QWORD PTR [rsp+0x18],0x4
  20bd1a:	00 00 
                return output(context, casted_value);
  20bd1c:	4c 89 f6             	mov    rsi,r14
  20bd1f:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20bd21:	31 c0                	xor    eax,eax
  20bd23:	86 05 e7 42 04 00    	xchg   BYTE PTR [rip+0x442e7],al        # 250010 <stderr_mutex>
  20bd29:	3c 01                	cmp    al,0x1
    if (!ok) {
  20bd2b:	0f 85 77 01 00 00    	jne    20bea8 <BmSelf.sfence+0xb18>
                try rightJustified(18, "{}", "time/operation");
  20bd31:	e8 2a a7 00 00       	call   216460 <Benchmark_rightJustified.38>
  20bd36:	66 85 c0             	test   ax,ax
  20bd39:	0f 85 54 01 00 00    	jne    20be93 <BmSelf.sfence+0xb03>
  20bd3f:	90                   	nop
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20bd40:	b0 01                	mov    al,0x1
  20bd42:	86 05 c8 42 04 00    	xchg   BYTE PTR [rip+0x442c8],al        # 250010 <stderr_mutex>
  20bd48:	84 c0                	test   al,al
  20bd4a:	75 f4                	jne    20bd40 <BmSelf.sfence+0x9b0>
    if (stderr_stream) |st| {
  20bd4c:	48 8b 3d b5 42 04 00 	mov    rdi,QWORD PTR [rip+0x442b5]        # 250008 <stderr_stream>
  20bd53:	48 85 ff             	test   rdi,rdi
  20bd56:	74 09                	je     20bd61 <BmSelf.sfence+0x9d1>
  20bd58:	48 8b 0d e1 f2 03 00 	mov    rcx,QWORD PTR [rip+0x3f2e1]        # 24b040 <stderr_file_out_stream+0x8>
  20bd5f:	eb 3d                	jmp    20bd9e <BmSelf.sfence+0xa0e>
        stderr_file = try io.getStdErr();
  20bd61:	c7 05 c5 f2 03 00 02 	mov    DWORD PTR [rip+0x3f2c5],0x2        # 24b030 <stderr_file>
  20bd68:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20bd6b:	48 8d 05 be f2 03 00 	lea    rax,[rip+0x3f2be]        # 24b030 <stderr_file>
  20bd72:	48 89 05 bf f2 03 00 	mov    QWORD PTR [rip+0x3f2bf],rax        # 24b038 <stderr_file_out_stream>
  20bd79:	48 8d 05 60 3c 01 00 	lea    rax,[rip+0x13c60]        # 21f9e0 <FileOutStream_writeFn>
  20bd80:	48 89 05 b9 f2 03 00 	mov    QWORD PTR [rip+0x3f2b9],rax        # 24b040 <stderr_file_out_stream+0x8>
  20bd87:	48 8d 0d b2 f2 03 00 	lea    rcx,[rip+0x3f2b2]        # 24b040 <stderr_file_out_stream+0x8>
  20bd8e:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20bd91:	48 89 15 70 42 04 00 	mov    QWORD PTR [rip+0x44270],rdx        # 250008 <stderr_stream>
  20bd98:	48 89 c1             	mov    rcx,rax
  20bd9b:	48 89 d7             	mov    rdi,rdx
        try output(context, fmt[start_index..]);
  20bd9e:	48 8d 35 73 30 04 00 	lea    rsi,[rip+0x43073]        # 24ee18 <__unnamed_3>
  20bda5:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20bda7:	31 c0                	xor    eax,eax
  20bda9:	86 05 61 42 04 00    	xchg   BYTE PTR [rip+0x44261],al        # 250010 <stderr_mutex>
  20bdaf:	3c 01                	cmp    al,0x1
    if (!ok) {
  20bdb1:	0f 85 f1 00 00 00    	jne    20bea8 <BmSelf.sfence+0xb18>
            try pSelf.report(pSelf.results.items[pSelf.results.len - 1]); warn("\n");
  20bdb7:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  20bdbc:	48 8b 4c 24 78       	mov    rcx,QWORD PTR [rsp+0x78]
  20bdc1:	48 c1 e1 04          	shl    rcx,0x4
  20bdc5:	48 8d 34 08          	lea    rsi,[rax+rcx*1]
  20bdc9:	48 83 c6 f0          	add    rsi,0xfffffffffffffff0
  20bdcd:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  20bdd2:	c5 f8 77             	vzeroupper 
  20bdd5:	e8 86 7c 00 00       	call   213a60 <Benchmark_report>
  20bdda:	66 85 c0             	test   ax,ax
  20bddd:	0f 85 b0 00 00 00    	jne    20be93 <BmSelf.sfence+0xb03>
  20bde3:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20bdea:	84 00 00 00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20bdf0:	b0 01                	mov    al,0x1
  20bdf2:	86 05 18 42 04 00    	xchg   BYTE PTR [rip+0x44218],al        # 250010 <stderr_mutex>
  20bdf8:	84 c0                	test   al,al
  20bdfa:	75 f4                	jne    20bdf0 <BmSelf.sfence+0xa60>
    if (stderr_stream) |st| {
  20bdfc:	48 8b 3d 05 42 04 00 	mov    rdi,QWORD PTR [rip+0x44205]        # 250008 <stderr_stream>
  20be03:	48 85 ff             	test   rdi,rdi
  20be06:	74 09                	je     20be11 <BmSelf.sfence+0xa81>
  20be08:	48 8b 0d 31 f2 03 00 	mov    rcx,QWORD PTR [rip+0x3f231]        # 24b040 <stderr_file_out_stream+0x8>
  20be0f:	eb 3d                	jmp    20be4e <BmSelf.sfence+0xabe>
        stderr_file = try io.getStdErr();
  20be11:	c7 05 15 f2 03 00 02 	mov    DWORD PTR [rip+0x3f215],0x2        # 24b030 <stderr_file>
  20be18:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20be1b:	48 8d 05 0e f2 03 00 	lea    rax,[rip+0x3f20e]        # 24b030 <stderr_file>
  20be22:	48 89 05 0f f2 03 00 	mov    QWORD PTR [rip+0x3f20f],rax        # 24b038 <stderr_file_out_stream>
  20be29:	48 8d 05 b0 3b 01 00 	lea    rax,[rip+0x13bb0]        # 21f9e0 <FileOutStream_writeFn>
  20be30:	48 89 05 09 f2 03 00 	mov    QWORD PTR [rip+0x3f209],rax        # 24b040 <stderr_file_out_stream+0x8>
  20be37:	48 8d 0d 02 f2 03 00 	lea    rcx,[rip+0x3f202]        # 24b040 <stderr_file_out_stream+0x8>
  20be3e:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20be41:	48 89 15 c0 41 04 00 	mov    QWORD PTR [rip+0x441c0],rdx        # 250008 <stderr_stream>
  20be48:	48 89 c1             	mov    rcx,rax
  20be4b:	48 89 d7             	mov    rdi,rdx
  20be4e:	48 8d 35 c3 2f 04 00 	lea    rsi,[rip+0x42fc3]        # 24ee18 <__unnamed_3>
  20be55:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20be57:	31 c0                	xor    eax,eax
  20be59:	86 05 b1 41 04 00    	xchg   BYTE PTR [rip+0x441b1],al        # 250010 <stderr_mutex>
  20be5f:	3c 01                	cmp    al,0x1
    if (!ok) {
  20be61:	75 45                	jne    20bea8 <BmSelf.sfence+0xb18>
  20be63:	49 83 c5 01          	add    r13,0x1
        while (rep < pSelf.repetitions) : (rep += 1) {
  20be67:	4c 3b 6c 24 40       	cmp    r13,QWORD PTR [rsp+0x40]
  20be6c:	0f 82 40 f9 ff ff    	jb     20b7b2 <BmSelf.sfence+0x422>
  20be72:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
        try pSelf.reportStats(pSelf.results);
  20be77:	48 8d 74 24 68       	lea    rsi,[rsp+0x68]
  20be7c:	e8 bf a8 00 00       	call   216740 <Benchmark_reportStats>
  20be81:	eb 10                	jmp    20be93 <BmSelf.sfence+0xb03>
                switch (errno) {
  20be83:	48 83 f9 16          	cmp    rcx,0x16
  20be87:	75 06                	jne    20be8f <BmSelf.sfence+0xaff>
  20be89:	66 b8 02 00          	mov    ax,0x2
  20be8d:	eb 04                	jmp    20be93 <BmSelf.sfence+0xb03>
  20be8f:	66 b8 03 00          	mov    ax,0x3
    _ = try bm.run(struct {
  20be93:	48 81 c4 f8 00 00 00 	add    rsp,0xf8
  20be9a:	5b                   	pop    rbx
  20be9b:	41 5c                	pop    r12
  20be9d:	41 5d                	pop    r13
  20be9f:	41 5e                	pop    r14
  20bea1:	41 5f                	pop    r15
  20bea3:	5d                   	pop    rbp
  20bea4:	c5 f8 77             	vzeroupper 
  20bea7:	c3                   	ret    
            @panic("assertion failure");
  20bea8:	48 8d 3d 59 2e 04 00 	lea    rdi,[rip+0x42e59]        # 24ed08 <__unnamed_2>
  20beaf:	c5 f8 77             	vzeroupper 
  20beb2:	e8 69 61 00 00       	call   212020 <panic>
  20beb7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  20bebe:	00 00 

000000000020bec0 <BmSelf.mfence.init>:
            sfence();
        }
    });
}

test "BmSelf.mfence.init" {
  20bec0:	55                   	push   rbp
  20bec1:	41 57                	push   r15
  20bec3:	41 56                	push   r14
  20bec5:	41 55                	push   r13
  20bec7:	41 54                	push   r12
  20bec9:	53                   	push   rbx
  20beca:	48 81 ec f8 00 00 00 	sub    rsp,0xf8
  20bed1:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20bed8:	0f 1f 84 00 00 00 00 
  20bedf:	00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20bee0:	b0 01                	mov    al,0x1
  20bee2:	86 05 28 41 04 00    	xchg   BYTE PTR [rip+0x44128],al        # 250010 <stderr_mutex>
  20bee8:	84 c0                	test   al,al
  20beea:	75 f4                	jne    20bee0 <BmSelf.mfence.init+0x20>
    if (stderr_stream) |st| {
  20beec:	48 8b 3d 15 41 04 00 	mov    rdi,QWORD PTR [rip+0x44115]        # 250008 <stderr_stream>
  20bef3:	48 85 ff             	test   rdi,rdi
  20bef6:	74 09                	je     20bf01 <BmSelf.mfence.init+0x41>
  20bef8:	48 8b 05 41 f1 03 00 	mov    rax,QWORD PTR [rip+0x3f141]        # 24b040 <stderr_file_out_stream+0x8>
  20beff:	eb 34                	jmp    20bf35 <BmSelf.mfence.init+0x75>
        stderr_file = try io.getStdErr();
  20bf01:	48 8d 05 28 f1 03 00 	lea    rax,[rip+0x3f128]        # 24b030 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20bf08:	48 89 05 29 f1 03 00 	mov    QWORD PTR [rip+0x3f129],rax        # 24b038 <stderr_file_out_stream>
  20bf0f:	48 8d 05 ca 3a 01 00 	lea    rax,[rip+0x13aca]        # 21f9e0 <FileOutStream_writeFn>
  20bf16:	48 89 05 23 f1 03 00 	mov    QWORD PTR [rip+0x3f123],rax        # 24b040 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  20bf1d:	c7 05 09 f1 03 00 02 	mov    DWORD PTR [rip+0x3f109],0x2        # 24b030 <stderr_file>
  20bf24:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20bf27:	48 8d 3d 12 f1 03 00 	lea    rdi,[rip+0x3f112]        # 24b040 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  20bf2e:	48 89 3d d3 40 04 00 	mov    QWORD PTR [rip+0x440d3],rdi        # 250008 <stderr_stream>
  20bf35:	48 8d 35 dc 2e 04 00 	lea    rsi,[rip+0x42edc]        # 24ee18 <__unnamed_3>
  20bf3c:	ff d0                	call   rax
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20bf3e:	31 c0                	xor    eax,eax
  20bf40:	86 05 ca 40 04 00    	xchg   BYTE PTR [rip+0x440ca],al        # 250010 <stderr_mutex>
  20bf46:	3c 01                	cmp    al,0x1
    if (!ok) {
  20bf48:	0f 85 59 0b 00 00    	jne    20caa7 <BmSelf.mfence.init+0xbe7>
    // Since this is a test print a \n before we run
    warn("\n");

    // Test fn benchmark(pSelf) can return an error
    var bm = Benchmark.init("BmEmpty.error", std.debug.global_allocator);
  20bf4e:	c5 f8 10 05 a2 2d 04 	vmovups xmm0,XMMWORD PTR [rip+0x42da2]        # 24ecf8 <__unnamed_9>
  20bf55:	00 
  20bf56:	c5 f8 29 44 24 20    	vmovaps XMMWORD PTR [rsp+0x20],xmm0
  20bf5c:	c5 fc 28 05 5c 42 ff 	vmovaps ymm0,YMMWORD PTR [rip+0xffffffffffff425c]        # 2001c0 <__unnamed_44-0x40>
  20bf63:	ff 
  20bf64:	c5 fc 11 44 24 30    	vmovups YMMWORD PTR [rsp+0x30],ymm0
  20bf6a:	c5 fa 6f 05 4e ce ff 	vmovdqu xmm0,XMMWORD PTR [rip+0xffffffffffffce4e]        # 208dc0 <__unnamed_5>
  20bf71:	ff 
  20bf72:	c5 f9 7f 44 24 50    	vmovdqa XMMWORD PTR [rsp+0x50],xmm0
  20bf78:	48 8d 05 81 f0 03 00 	lea    rax,[rip+0x3f081]        # 24b000 <global_fixed_allocator>
  20bf7f:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  20bf84:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  20bf88:	c5 fa 7f 44 24 68    	vmovdqu XMMWORD PTR [rsp+0x68],xmm0
  20bf8e:	48 c7 44 24 78 00 00 	mov    QWORD PTR [rsp+0x78],0x0
  20bf95:	00 00 
  20bf97:	48 89 84 24 80 00 00 	mov    QWORD PTR [rsp+0x80],rax
  20bf9e:	00 
  20bf9f:	b1 01                	mov    cl,0x1
  20bfa1:	48 bd 00 e8 76 48 17 	movabs rbp,0x174876e800
  20bfa8:	00 00 00 
  20bfab:	bb 01 00 00 00       	mov    ebx,0x1
  20bfb0:	4c 8d a4 24 90 00 00 	lea    r12,[rsp+0x90]
  20bfb7:	00 
  20bfb8:	45 31 f6             	xor    r14d,r14d
  20bfbb:	45 31 ed             	xor    r13d,r13d
            while (iterations <= pSelf.max_iterations) {
  20bfbe:	48 39 eb             	cmp    rbx,rbp
  20bfc1:	0f 87 49 03 00 00    	ja     20c310 <BmSelf.mfence.init+0x450>
  20bfc7:	89 4c 24 1c          	mov    DWORD PTR [rsp+0x1c],ecx
  20bfcb:	eb 11                	jmp    20bfde <BmSelf.mfence.init+0x11e>
  20bfcd:	0f 1f 00             	nop    DWORD PTR [rax]
                        warn("iteratons:{} numer:{} denom:{}\n", iterations, numer, denom);
  20bfd0:	48 89 df             	mov    rdi,rbx
  20bfd3:	48 89 ca             	mov    rdx,rcx
  20bfd6:	c5 f8 77             	vzeroupper 
  20bfd9:	e8 92 9b 00 00       	call   215b70 <warn.36>
                var ts: posix.timespec = undefined;
  20bfde:	c5 fa 6f 05 da cd ff 	vmovdqu xmm0,XMMWORD PTR [rip+0xffffffffffffcdda]        # 208dc0 <__unnamed_5>
  20bfe5:	ff 
  20bfe6:	c5 f9 7f 84 24 90 00 	vmovdqa XMMWORD PTR [rsp+0x90],xmm0
  20bfed:	00 00 
  20bfef:	b8 e5 00 00 00       	mov    eax,0xe5
  20bff4:	bf 01 00 00 00       	mov    edi,0x1
  20bff9:	4c 89 e6             	mov    rsi,r12
  20bffc:	0f 05                	syscall 
  20bffe:	48 89 c1             	mov    rcx,rax
  20c001:	48 f7 d9             	neg    rcx
  20c004:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  20c00a:	b8 00 00 00 00       	mov    eax,0x0
  20c00f:	48 0f 46 c8          	cmovbe rcx,rax
                switch (errno) {
  20c013:	48 85 c9             	test   rcx,rcx
  20c016:	0f 85 66 0a 00 00    	jne    20ca82 <BmSelf.mfence.init+0xbc2>
        const f = @atomicLoad(@typeOf(init_vdso_clock_gettime), &vdso_clock_gettime, builtin.AtomicOrder.Unordered);
  20c01c:	48 8b 05 25 f0 03 00 	mov    rax,QWORD PTR [rip+0x3f025]        # 24b048 <vdso_clock_gettime>
        if (@ptrToInt(f) != 0) {
  20c023:	48 85 c0             	test   rax,rax
  20c026:	74 24                	je     20c04c <BmSelf.mfence.init+0x18c>
            const rc = f(clk_id, tp);
  20c028:	bf 01 00 00 00       	mov    edi,0x1
  20c02d:	4c 89 e6             	mov    rsi,r12
  20c030:	c5 f8 77             	vzeroupper 
  20c033:	ff d0                	call   rax
            switch (rc) {
  20c035:	48 83 f8 ea          	cmp    rax,0xffffffffffffffea
  20c039:	0f 84 41 02 00 00    	je     20c280 <BmSelf.mfence.init+0x3c0>
  20c03f:	48 85 c0             	test   rax,rax
  20c042:	c5 fa 6f 05 76 cd ff 	vmovdqu xmm0,XMMWORD PTR [rip+0xffffffffffffcd76]        # 208dc0 <__unnamed_5>
  20c049:	ff 
  20c04a:	74 0f                	je     20c05b <BmSelf.mfence.init+0x19b>
  20c04c:	b8 e4 00 00 00       	mov    eax,0xe4
  20c051:	bf 01 00 00 00       	mov    edi,0x1
  20c056:	4c 89 e6             	mov    rsi,r12
  20c059:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  20c05b:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
                if (errno != 0) return std.os.unexpectedErrorPosix(errno);
  20c061:	0f 83 27 0a 00 00    	jae    20ca8e <BmSelf.mfence.init+0xbce>
                self.start_time = @intCast(u64, ts.tv_sec) * u64(ns_per_s) + @intCast(u64, ts.tv_nsec);
  20c067:	c5 f9 6f 8c 24 90 00 	vmovdqa xmm1,XMMWORD PTR [rsp+0x90]
  20c06e:	00 00 
        while (iter > 0) : (iter -= 1) {
  20c070:	48 85 db             	test   rbx,rbx
  20c073:	74 17                	je     20c08c <BmSelf.mfence.init+0x1cc>
  20c075:	48 89 d8             	mov    rax,rbx
  20c078:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  20c07f:	00 
    asm volatile ("mfence": : :"memory");
  20c080:	0f ae f0             	mfence 
        while (iter > 0) : (iter -= 1) {
  20c083:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  20c087:	75 f7                	jne    20c080 <BmSelf.mfence.init+0x1c0>
  20c089:	49 01 dd             	add    r13,rbx
        var ts: posix.timespec = undefined;
  20c08c:	c5 f9 7f 84 24 90 00 	vmovdqa XMMWORD PTR [rsp+0x90],xmm0
  20c093:	00 00 
        const f = @atomicLoad(@typeOf(init_vdso_clock_gettime), &vdso_clock_gettime, builtin.AtomicOrder.Unordered);
  20c095:	48 8b 05 ac ef 03 00 	mov    rax,QWORD PTR [rip+0x3efac]        # 24b048 <vdso_clock_gettime>
        if (@ptrToInt(f) != 0) {
  20c09c:	48 85 c0             	test   rax,rax
  20c09f:	74 2e                	je     20c0cf <BmSelf.mfence.init+0x20f>
  20c0a1:	c5 f9 7f 8c 24 c0 00 	vmovdqa XMMWORD PTR [rsp+0xc0],xmm1
  20c0a8:	00 00 
            const rc = f(clk_id, tp);
  20c0aa:	bf 01 00 00 00       	mov    edi,0x1
  20c0af:	4c 89 e6             	mov    rsi,r12
  20c0b2:	c5 f8 77             	vzeroupper 
  20c0b5:	ff d0                	call   rax
            switch (rc) {
  20c0b7:	48 83 f8 ea          	cmp    rax,0xffffffffffffffea
  20c0bb:	0f 84 d8 01 00 00    	je     20c299 <BmSelf.mfence.init+0x3d9>
  20c0c1:	48 85 c0             	test   rax,rax
  20c0c4:	c5 f9 6f 8c 24 c0 00 	vmovdqa xmm1,XMMWORD PTR [rsp+0xc0]
  20c0cb:	00 00 
  20c0cd:	74 0f                	je     20c0de <BmSelf.mfence.init+0x21e>
  20c0cf:	b8 e4 00 00 00       	mov    eax,0xe4
  20c0d4:	bf 01 00 00 00       	mov    edi,0x1
  20c0d9:	4c 89 e6             	mov    rsi,r12
  20c0dc:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  20c0de:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
  20c0e4:	0f 83 bd 09 00 00    	jae    20caa7 <BmSelf.mfence.init+0xbe7>
        return @intCast(u64, ts.tv_sec) * u64(ns_per_s) + @intCast(u64, ts.tv_nsec);
  20c0ea:	c5 f9 6f 84 24 90 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x90]
  20c0f1:	00 00 
  20c0f3:	c5 f9 fb c1          	vpsubq xmm0,xmm0,xmm1
  20c0f7:	c4 e1 f9 7e c0       	vmovq  rax,xmm0
        var clock = clockNative() - self.start_time;
  20c0fc:	c4 c3 f9 16 c7 01    	vpextrq r15,xmm0,0x1
  20c102:	48 69 c0 00 ca 9a 3b 	imul   rax,rax,0x3b9aca00
  20c109:	49 01 c7             	add    r15,rax
                if ((run_time_ns >= pSelf.min_runtime_ns) or (iterations >= pSelf.max_iterations)) {
  20c10c:	4c 3b 7c 24 38       	cmp    r15,QWORD PTR [rsp+0x38]
  20c111:	0f 83 a9 01 00 00    	jae    20c2c0 <BmSelf.mfence.init+0x400>
  20c117:	48 39 eb             	cmp    rbx,rbp
  20c11a:	0f 83 a0 01 00 00    	jae    20c2c0 <BmSelf.mfence.init+0x400>
                    if (pSelf.logl >= 1) {
  20c120:	48 83 7c 24 30 00    	cmp    QWORD PTR [rsp+0x30],0x0
  20c126:	0f 84 ba 00 00 00    	je     20c1e6 <BmSelf.mfence.init+0x326>
                            Result {.run_time_ns = run_time_ns, .iterations = iterations});
  20c12c:	4c 89 bc 24 d8 00 00 	mov    QWORD PTR [rsp+0xd8],r15
  20c133:	00 
  20c134:	48 89 9c 24 e0 00 00 	mov    QWORD PTR [rsp+0xe0],rbx
  20c13b:	00 
                        try pSelf.report(
  20c13c:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  20c141:	48 8d b4 24 d8 00 00 	lea    rsi,[rsp+0xd8]
  20c148:	00 
  20c149:	c5 f8 77             	vzeroupper 
  20c14c:	e8 0f 79 00 00       	call   213a60 <Benchmark_report>
  20c151:	66 85 c0             	test   ax,ax
  20c154:	0f 85 38 09 00 00    	jne    20ca92 <BmSelf.mfence.init+0xbd2>
  20c15a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20c160:	b0 01                	mov    al,0x1
  20c162:	86 05 a8 3e 04 00    	xchg   BYTE PTR [rip+0x43ea8],al        # 250010 <stderr_mutex>
  20c168:	84 c0                	test   al,al
  20c16a:	75 f4                	jne    20c160 <BmSelf.mfence.init+0x2a0>
    if (stderr_stream) |st| {
  20c16c:	48 8b 3d 95 3e 04 00 	mov    rdi,QWORD PTR [rip+0x43e95]        # 250008 <stderr_stream>
  20c173:	48 85 ff             	test   rdi,rdi
  20c176:	74 18                	je     20c190 <BmSelf.mfence.init+0x2d0>
  20c178:	48 8b 0d c1 ee 03 00 	mov    rcx,QWORD PTR [rip+0x3eec1]        # 24b040 <stderr_file_out_stream+0x8>
  20c17f:	eb 4c                	jmp    20c1cd <BmSelf.mfence.init+0x30d>
  20c181:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20c188:	0f 1f 84 00 00 00 00 
  20c18f:	00 
        stderr_file = try io.getStdErr();
  20c190:	c7 05 96 ee 03 00 02 	mov    DWORD PTR [rip+0x3ee96],0x2        # 24b030 <stderr_file>
  20c197:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20c19a:	48 8d 05 8f ee 03 00 	lea    rax,[rip+0x3ee8f]        # 24b030 <stderr_file>
  20c1a1:	48 89 05 90 ee 03 00 	mov    QWORD PTR [rip+0x3ee90],rax        # 24b038 <stderr_file_out_stream>
  20c1a8:	48 8d 05 31 38 01 00 	lea    rax,[rip+0x13831]        # 21f9e0 <FileOutStream_writeFn>
  20c1af:	48 89 05 8a ee 03 00 	mov    QWORD PTR [rip+0x3ee8a],rax        # 24b040 <stderr_file_out_stream+0x8>
  20c1b6:	48 8d 0d 83 ee 03 00 	lea    rcx,[rip+0x3ee83]        # 24b040 <stderr_file_out_stream+0x8>
  20c1bd:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20c1c0:	48 89 15 41 3e 04 00 	mov    QWORD PTR [rip+0x43e41],rdx        # 250008 <stderr_stream>
  20c1c7:	48 89 c1             	mov    rcx,rax
  20c1ca:	48 89 d7             	mov    rdi,rdx
  20c1cd:	48 8d 35 44 2c 04 00 	lea    rsi,[rip+0x42c44]        # 24ee18 <__unnamed_3>
  20c1d4:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20c1d6:	31 c0                	xor    eax,eax
  20c1d8:	86 05 32 3e 04 00    	xchg   BYTE PTR [rip+0x43e32],al        # 250010 <stderr_mutex>
  20c1de:	3c 01                	cmp    al,0x1
    if (!ok) {
  20c1e0:	0f 85 c1 08 00 00    	jne    20caa7 <BmSelf.mfence.init+0xbe7>
                    if (run_time_ns < 1000) {
  20c1e6:	49 81 ff e8 03 00 00 	cmp    r15,0x3e8
  20c1ed:	73 31                	jae    20c220 <BmSelf.mfence.init+0x360>
  20c1ef:	b9 01 00 00 00       	mov    ecx,0x1
  20c1f4:	be e8 03 00 00       	mov    esi,0x3e8
                    iterations = (iterations * numer) / denom;
  20c1f9:	48 0f af de          	imul   rbx,rsi
  20c1fd:	48 89 d8             	mov    rax,rbx
  20c200:	48 c1 e8 20          	shr    rax,0x20
  20c204:	74 54                	je     20c25a <BmSelf.mfence.init+0x39a>
  20c206:	31 d2                	xor    edx,edx
  20c208:	48 89 d8             	mov    rax,rbx
  20c20b:	48 f7 f1             	div    rcx
  20c20e:	48 89 c3             	mov    rbx,rax
  20c211:	eb 4f                	jmp    20c262 <BmSelf.mfence.init+0x3a2>
  20c213:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20c21a:	84 00 00 00 00 00 
                    } else if (run_time_ns < (pSelf.min_runtime_ns / 10)) {
  20c220:	48 ba cd cc cc cc cc 	movabs rdx,0xcccccccccccccccd
  20c227:	cc cc cc 
  20c22a:	c4 e2 fb f6 4c 24 38 	mulx   rcx,rax,QWORD PTR [rsp+0x38]
  20c231:	48 c1 e9 03          	shr    rcx,0x3
  20c235:	31 c0                	xor    eax,eax
  20c237:	49 39 cf             	cmp    r15,rcx
  20c23a:	0f 93 c0             	setae  al
  20c23d:	48 8d 0c c0          	lea    rcx,[rax+rax*8]
  20c241:	48 83 c1 01          	add    rcx,0x1
  20c245:	48 8d 34 85 0a 00 00 	lea    rsi,[rax*4+0xa]
  20c24c:	00 
                    iterations = (iterations * numer) / denom;
  20c24d:	48 0f af de          	imul   rbx,rsi
  20c251:	48 89 d8             	mov    rax,rbx
  20c254:	48 c1 e8 20          	shr    rax,0x20
  20c258:	75 ac                	jne    20c206 <BmSelf.mfence.init+0x346>
  20c25a:	31 d2                	xor    edx,edx
  20c25c:	89 d8                	mov    eax,ebx
  20c25e:	f7 f1                	div    ecx
  20c260:	89 c3                	mov    ebx,eax
                    if (iterations > pSelf.max_iterations) {
  20c262:	48 8b 6c 24 48       	mov    rbp,QWORD PTR [rsp+0x48]
  20c267:	48 39 eb             	cmp    rbx,rbp
  20c26a:	48 0f 47 dd          	cmova  rbx,rbp
                    if (pSelf.logl >= 2) {
  20c26e:	48 83 7c 24 30 02    	cmp    QWORD PTR [rsp+0x30],0x2
  20c274:	0f 82 64 fd ff ff    	jb     20bfde <BmSelf.mfence.init+0x11e>
  20c27a:	e9 51 fd ff ff       	jmp    20bfd0 <BmSelf.mfence.init+0x110>
  20c27f:	90                   	nop
  20c280:	c5 fa 6f 05 38 cb ff 	vmovdqu xmm0,XMMWORD PTR [rip+0xffffffffffffcb38]        # 208dc0 <__unnamed_5>
  20c287:	ff 
  20c288:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
                if (errno != 0) return std.os.unexpectedErrorPosix(errno);
  20c28e:	0f 82 d3 fd ff ff    	jb     20c067 <BmSelf.mfence.init+0x1a7>
  20c294:	e9 f5 07 00 00       	jmp    20ca8e <BmSelf.mfence.init+0xbce>
  20c299:	c5 f9 6f 8c 24 c0 00 	vmovdqa xmm1,XMMWORD PTR [rsp+0xc0]
  20c2a0:	00 00 
  20c2a2:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
  20c2a8:	0f 82 3c fe ff ff    	jb     20c0ea <BmSelf.mfence.init+0x22a>
  20c2ae:	e9 f4 07 00 00       	jmp    20caa7 <BmSelf.mfence.init+0xbe7>
  20c2b3:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20c2ba:	84 00 00 00 00 00 
                            Result { .run_time_ns = run_time_ns, .iterations = iterations});
  20c2c0:	4c 89 bc 24 e8 00 00 	mov    QWORD PTR [rsp+0xe8],r15
  20c2c7:	00 
  20c2c8:	48 89 9c 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rbx
  20c2cf:	00 
                    try pSelf.results.append(
  20c2d0:	48 8d 7c 24 68       	lea    rdi,[rsp+0x68]
  20c2d5:	48 8d b4 24 e8 00 00 	lea    rsi,[rsp+0xe8]
  20c2dc:	00 
  20c2dd:	c5 f8 77             	vzeroupper 
  20c2e0:	e8 0b 76 00 00       	call   2138f0 <AlignedArrayList(Result,8)_append>
  20c2e5:	66 85 c0             	test   ax,ax
  20c2e8:	8b 4c 24 1c          	mov    ecx,DWORD PTR [rsp+0x1c]
  20c2ec:	74 22                	je     20c310 <BmSelf.mfence.init+0x450>
  20c2ee:	e9 9f 07 00 00       	jmp    20ca92 <BmSelf.mfence.init+0xbd2>
  20c2f3:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20c2fa:	84 00 00 00 00 00 
            while (iterations <= pSelf.max_iterations) {
  20c300:	48 8b 6c 24 48       	mov    rbp,QWORD PTR [rsp+0x48]
  20c305:	31 c9                	xor    ecx,ecx
  20c307:	48 39 eb             	cmp    rbx,rbp
  20c30a:	0f 86 b7 fc ff ff    	jbe    20bfc7 <BmSelf.mfence.init+0x107>
            if (once) {
  20c310:	f6 c1 01             	test   cl,0x1
  20c313:	48 8d 6c 24 07       	lea    rbp,[rsp+0x7]
  20c318:	0f 84 78 06 00 00    	je     20c996 <BmSelf.mfence.init+0xad6>
                try leftJustified(22, "name repetitions:{}", pSelf.repetitions);
  20c31e:	48 8b 7c 24 40       	mov    rdi,QWORD PTR [rsp+0x40]
  20c323:	c5 f8 77             	vzeroupper 
  20c326:	e8 b5 9b 00 00       	call   215ee0 <Benchmark_leftJustified>
  20c32b:	66 85 c0             	test   ax,ax
  20c32e:	0f 85 5e 07 00 00    	jne    20ca92 <BmSelf.mfence.init+0xbd2>
                try rightJustified(14, "{}", "iterations");
  20c334:	e8 47 9e 00 00       	call   216180 <Benchmark_rightJustified>
  20c339:	66 85 c0             	test   ax,ax
  20c33c:	0f 85 50 07 00 00    	jne    20ca92 <BmSelf.mfence.init+0xbd2>
        var buffer: [40]u8 = undefined;
  20c342:	c5 fe 6f 05 51 92 ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffff9251]        # 20559b <__unnamed_7>
  20c349:	ff 
  20c34a:	c5 fe 7f 84 24 90 00 	vmovdqu YMMWORD PTR [rsp+0x90],ymm0
  20c351:	00 00 
  20c353:	48 8b 05 61 92 ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffff9261]        # 2055bb <__unnamed_7+0x20>
  20c35a:	48 89 84 24 b0 00 00 	mov    QWORD PTR [rsp+0xb0],rax
  20c361:	00 
  20c362:	c7 84 24 90 00 00 00 	mov    DWORD PTR [rsp+0x90],0x656d6974
  20c369:	74 69 6d 65 
  20c36d:	0f 1f 00             	nop    DWORD PTR [rax]
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20c370:	b0 01                	mov    al,0x1
  20c372:	86 05 98 3c 04 00    	xchg   BYTE PTR [rip+0x43c98],al        # 250010 <stderr_mutex>
  20c378:	84 c0                	test   al,al
  20c37a:	75 f4                	jne    20c370 <BmSelf.mfence.init+0x4b0>
    if (stderr_stream) |st| {
  20c37c:	48 8b 3d 85 3c 04 00 	mov    rdi,QWORD PTR [rip+0x43c85]        # 250008 <stderr_stream>
  20c383:	48 85 ff             	test   rdi,rdi
  20c386:	74 18                	je     20c3a0 <BmSelf.mfence.init+0x4e0>
  20c388:	48 8b 0d b1 ec 03 00 	mov    rcx,QWORD PTR [rip+0x3ecb1]        # 24b040 <stderr_file_out_stream+0x8>
  20c38f:	eb 4c                	jmp    20c3dd <BmSelf.mfence.init+0x51d>
  20c391:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20c398:	0f 1f 84 00 00 00 00 
  20c39f:	00 
        stderr_file = try io.getStdErr();
  20c3a0:	c7 05 86 ec 03 00 02 	mov    DWORD PTR [rip+0x3ec86],0x2        # 24b030 <stderr_file>
  20c3a7:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20c3aa:	48 8d 05 7f ec 03 00 	lea    rax,[rip+0x3ec7f]        # 24b030 <stderr_file>
  20c3b1:	48 89 05 80 ec 03 00 	mov    QWORD PTR [rip+0x3ec80],rax        # 24b038 <stderr_file_out_stream>
  20c3b8:	48 8d 05 21 36 01 00 	lea    rax,[rip+0x13621]        # 21f9e0 <FileOutStream_writeFn>
  20c3bf:	48 89 05 7a ec 03 00 	mov    QWORD PTR [rip+0x3ec7a],rax        # 24b040 <stderr_file_out_stream+0x8>
  20c3c6:	48 8d 0d 73 ec 03 00 	lea    rcx,[rip+0x3ec73]        # 24b040 <stderr_file_out_stream+0x8>
  20c3cd:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20c3d0:	48 89 15 31 3c 04 00 	mov    QWORD PTR [rip+0x43c31],rdx        # 250008 <stderr_stream>
  20c3d7:	48 89 c1             	mov    rcx,rax
  20c3da:	48 89 d7             	mov    rdi,rdx
  20c3dd:	c6 44 24 07 20       	mov    BYTE PTR [rsp+0x7],0x20
    return output(context, (*[1]u8)(&c)[0..]);
  20c3e2:	48 89 6c 24 08       	mov    QWORD PTR [rsp+0x8],rbp
  20c3e7:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  20c3ee:	00 00 
  20c3f0:	48 8d 74 24 08       	lea    rsi,[rsp+0x8]
  20c3f5:	c5 f8 77             	vzeroupper 
  20c3f8:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20c3fa:	31 c0                	xor    eax,eax
  20c3fc:	86 05 0e 3c 04 00    	xchg   BYTE PTR [rip+0x43c0e],al        # 250010 <stderr_mutex>
  20c402:	3c 01                	cmp    al,0x1
    if (!ok) {
  20c404:	0f 85 9d 06 00 00    	jne    20caa7 <BmSelf.mfence.init+0xbe7>
  20c40a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20c410:	b0 01                	mov    al,0x1
  20c412:	86 05 f8 3b 04 00    	xchg   BYTE PTR [rip+0x43bf8],al        # 250010 <stderr_mutex>
  20c418:	84 c0                	test   al,al
  20c41a:	75 f4                	jne    20c410 <BmSelf.mfence.init+0x550>
    if (stderr_stream) |st| {
  20c41c:	48 8b 3d e5 3b 04 00 	mov    rdi,QWORD PTR [rip+0x43be5]        # 250008 <stderr_stream>
  20c423:	48 85 ff             	test   rdi,rdi
  20c426:	74 18                	je     20c440 <BmSelf.mfence.init+0x580>
  20c428:	48 8b 0d 11 ec 03 00 	mov    rcx,QWORD PTR [rip+0x3ec11]        # 24b040 <stderr_file_out_stream+0x8>
  20c42f:	eb 4c                	jmp    20c47d <BmSelf.mfence.init+0x5bd>
  20c431:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20c438:	0f 1f 84 00 00 00 00 
  20c43f:	00 
        stderr_file = try io.getStdErr();
  20c440:	c7 05 e6 eb 03 00 02 	mov    DWORD PTR [rip+0x3ebe6],0x2        # 24b030 <stderr_file>
  20c447:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20c44a:	48 8d 05 df eb 03 00 	lea    rax,[rip+0x3ebdf]        # 24b030 <stderr_file>
  20c451:	48 89 05 e0 eb 03 00 	mov    QWORD PTR [rip+0x3ebe0],rax        # 24b038 <stderr_file_out_stream>
  20c458:	48 8d 05 81 35 01 00 	lea    rax,[rip+0x13581]        # 21f9e0 <FileOutStream_writeFn>
  20c45f:	48 89 05 da eb 03 00 	mov    QWORD PTR [rip+0x3ebda],rax        # 24b040 <stderr_file_out_stream+0x8>
  20c466:	48 8d 0d d3 eb 03 00 	lea    rcx,[rip+0x3ebd3]        # 24b040 <stderr_file_out_stream+0x8>
  20c46d:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20c470:	48 89 15 91 3b 04 00 	mov    QWORD PTR [rip+0x43b91],rdx        # 250008 <stderr_stream>
  20c477:	48 89 c1             	mov    rcx,rax
  20c47a:	48 89 d7             	mov    rdi,rdx
  20c47d:	c6 44 24 07 20       	mov    BYTE PTR [rsp+0x7],0x20
  20c482:	48 89 6c 24 08       	mov    QWORD PTR [rsp+0x8],rbp
  20c487:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  20c48e:	00 00 
  20c490:	48 8d 74 24 08       	lea    rsi,[rsp+0x8]
  20c495:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20c497:	31 c0                	xor    eax,eax
  20c499:	86 05 71 3b 04 00    	xchg   BYTE PTR [rip+0x43b71],al        # 250010 <stderr_mutex>
  20c49f:	3c 01                	cmp    al,0x1
    if (!ok) {
  20c4a1:	0f 85 00 06 00 00    	jne    20caa7 <BmSelf.mfence.init+0xbe7>
  20c4a7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  20c4ae:	00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20c4b0:	b0 01                	mov    al,0x1
  20c4b2:	86 05 58 3b 04 00    	xchg   BYTE PTR [rip+0x43b58],al        # 250010 <stderr_mutex>
  20c4b8:	84 c0                	test   al,al
  20c4ba:	75 f4                	jne    20c4b0 <BmSelf.mfence.init+0x5f0>
    if (stderr_stream) |st| {
  20c4bc:	48 8b 3d 45 3b 04 00 	mov    rdi,QWORD PTR [rip+0x43b45]        # 250008 <stderr_stream>
  20c4c3:	48 85 ff             	test   rdi,rdi
  20c4c6:	74 18                	je     20c4e0 <BmSelf.mfence.init+0x620>
  20c4c8:	48 8b 0d 71 eb 03 00 	mov    rcx,QWORD PTR [rip+0x3eb71]        # 24b040 <stderr_file_out_stream+0x8>
  20c4cf:	eb 4c                	jmp    20c51d <BmSelf.mfence.init+0x65d>
  20c4d1:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20c4d8:	0f 1f 84 00 00 00 00 
  20c4df:	00 
        stderr_file = try io.getStdErr();
  20c4e0:	c7 05 46 eb 03 00 02 	mov    DWORD PTR [rip+0x3eb46],0x2        # 24b030 <stderr_file>
  20c4e7:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20c4ea:	48 8d 05 3f eb 03 00 	lea    rax,[rip+0x3eb3f]        # 24b030 <stderr_file>
  20c4f1:	48 89 05 40 eb 03 00 	mov    QWORD PTR [rip+0x3eb40],rax        # 24b038 <stderr_file_out_stream>
  20c4f8:	48 8d 05 e1 34 01 00 	lea    rax,[rip+0x134e1]        # 21f9e0 <FileOutStream_writeFn>
  20c4ff:	48 89 05 3a eb 03 00 	mov    QWORD PTR [rip+0x3eb3a],rax        # 24b040 <stderr_file_out_stream+0x8>
  20c506:	48 8d 0d 33 eb 03 00 	lea    rcx,[rip+0x3eb33]        # 24b040 <stderr_file_out_stream+0x8>
  20c50d:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20c510:	48 89 15 f1 3a 04 00 	mov    QWORD PTR [rip+0x43af1],rdx        # 250008 <stderr_stream>
  20c517:	48 89 c1             	mov    rcx,rax
  20c51a:	48 89 d7             	mov    rdi,rdx
  20c51d:	c6 44 24 07 20       	mov    BYTE PTR [rsp+0x7],0x20
  20c522:	48 89 6c 24 08       	mov    QWORD PTR [rsp+0x8],rbp
  20c527:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  20c52e:	00 00 
  20c530:	48 8d 74 24 08       	lea    rsi,[rsp+0x8]
  20c535:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20c537:	31 c0                	xor    eax,eax
  20c539:	86 05 d1 3a 04 00    	xchg   BYTE PTR [rip+0x43ad1],al        # 250010 <stderr_mutex>
  20c53f:	3c 01                	cmp    al,0x1
    if (!ok) {
  20c541:	0f 85 60 05 00 00    	jne    20caa7 <BmSelf.mfence.init+0xbe7>
  20c547:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  20c54e:	00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20c550:	b0 01                	mov    al,0x1
  20c552:	86 05 b8 3a 04 00    	xchg   BYTE PTR [rip+0x43ab8],al        # 250010 <stderr_mutex>
  20c558:	84 c0                	test   al,al
  20c55a:	75 f4                	jne    20c550 <BmSelf.mfence.init+0x690>
    if (stderr_stream) |st| {
  20c55c:	48 8b 3d a5 3a 04 00 	mov    rdi,QWORD PTR [rip+0x43aa5]        # 250008 <stderr_stream>
  20c563:	48 85 ff             	test   rdi,rdi
  20c566:	74 18                	je     20c580 <BmSelf.mfence.init+0x6c0>
  20c568:	48 8b 0d d1 ea 03 00 	mov    rcx,QWORD PTR [rip+0x3ead1]        # 24b040 <stderr_file_out_stream+0x8>
  20c56f:	eb 4c                	jmp    20c5bd <BmSelf.mfence.init+0x6fd>
  20c571:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20c578:	0f 1f 84 00 00 00 00 
  20c57f:	00 
        stderr_file = try io.getStdErr();
  20c580:	c7 05 a6 ea 03 00 02 	mov    DWORD PTR [rip+0x3eaa6],0x2        # 24b030 <stderr_file>
  20c587:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20c58a:	48 8d 05 9f ea 03 00 	lea    rax,[rip+0x3ea9f]        # 24b030 <stderr_file>
  20c591:	48 89 05 a0 ea 03 00 	mov    QWORD PTR [rip+0x3eaa0],rax        # 24b038 <stderr_file_out_stream>
  20c598:	48 8d 05 41 34 01 00 	lea    rax,[rip+0x13441]        # 21f9e0 <FileOutStream_writeFn>
  20c59f:	48 89 05 9a ea 03 00 	mov    QWORD PTR [rip+0x3ea9a],rax        # 24b040 <stderr_file_out_stream+0x8>
  20c5a6:	48 8d 0d 93 ea 03 00 	lea    rcx,[rip+0x3ea93]        # 24b040 <stderr_file_out_stream+0x8>
  20c5ad:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20c5b0:	48 89 15 51 3a 04 00 	mov    QWORD PTR [rip+0x43a51],rdx        # 250008 <stderr_stream>
  20c5b7:	48 89 c1             	mov    rcx,rax
  20c5ba:	48 89 d7             	mov    rdi,rdx
  20c5bd:	c6 44 24 07 20       	mov    BYTE PTR [rsp+0x7],0x20
  20c5c2:	48 89 6c 24 08       	mov    QWORD PTR [rsp+0x8],rbp
  20c5c7:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  20c5ce:	00 00 
  20c5d0:	48 8d 74 24 08       	lea    rsi,[rsp+0x8]
  20c5d5:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20c5d7:	31 c0                	xor    eax,eax
  20c5d9:	86 05 31 3a 04 00    	xchg   BYTE PTR [rip+0x43a31],al        # 250010 <stderr_mutex>
  20c5df:	3c 01                	cmp    al,0x1
    if (!ok) {
  20c5e1:	0f 85 c0 04 00 00    	jne    20caa7 <BmSelf.mfence.init+0xbe7>
  20c5e7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  20c5ee:	00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20c5f0:	b0 01                	mov    al,0x1
  20c5f2:	86 05 18 3a 04 00    	xchg   BYTE PTR [rip+0x43a18],al        # 250010 <stderr_mutex>
  20c5f8:	84 c0                	test   al,al
  20c5fa:	75 f4                	jne    20c5f0 <BmSelf.mfence.init+0x730>
    if (stderr_stream) |st| {
  20c5fc:	48 8b 3d 05 3a 04 00 	mov    rdi,QWORD PTR [rip+0x43a05]        # 250008 <stderr_stream>
  20c603:	48 85 ff             	test   rdi,rdi
  20c606:	74 18                	je     20c620 <BmSelf.mfence.init+0x760>
  20c608:	48 8b 0d 31 ea 03 00 	mov    rcx,QWORD PTR [rip+0x3ea31]        # 24b040 <stderr_file_out_stream+0x8>
  20c60f:	eb 4c                	jmp    20c65d <BmSelf.mfence.init+0x79d>
  20c611:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20c618:	0f 1f 84 00 00 00 00 
  20c61f:	00 
        stderr_file = try io.getStdErr();
  20c620:	c7 05 06 ea 03 00 02 	mov    DWORD PTR [rip+0x3ea06],0x2        # 24b030 <stderr_file>
  20c627:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20c62a:	48 8d 05 ff e9 03 00 	lea    rax,[rip+0x3e9ff]        # 24b030 <stderr_file>
  20c631:	48 89 05 00 ea 03 00 	mov    QWORD PTR [rip+0x3ea00],rax        # 24b038 <stderr_file_out_stream>
  20c638:	48 8d 05 a1 33 01 00 	lea    rax,[rip+0x133a1]        # 21f9e0 <FileOutStream_writeFn>
  20c63f:	48 89 05 fa e9 03 00 	mov    QWORD PTR [rip+0x3e9fa],rax        # 24b040 <stderr_file_out_stream+0x8>
  20c646:	48 8d 0d f3 e9 03 00 	lea    rcx,[rip+0x3e9f3]        # 24b040 <stderr_file_out_stream+0x8>
  20c64d:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20c650:	48 89 15 b1 39 04 00 	mov    QWORD PTR [rip+0x439b1],rdx        # 250008 <stderr_stream>
  20c657:	48 89 c1             	mov    rcx,rax
  20c65a:	48 89 d7             	mov    rdi,rdx
  20c65d:	c6 44 24 07 20       	mov    BYTE PTR [rsp+0x7],0x20
  20c662:	48 89 6c 24 08       	mov    QWORD PTR [rsp+0x8],rbp
  20c667:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  20c66e:	00 00 
  20c670:	48 8d 74 24 08       	lea    rsi,[rsp+0x8]
  20c675:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20c677:	31 c0                	xor    eax,eax
  20c679:	86 05 91 39 04 00    	xchg   BYTE PTR [rip+0x43991],al        # 250010 <stderr_mutex>
  20c67f:	3c 01                	cmp    al,0x1
    if (!ok) {
  20c681:	0f 85 20 04 00 00    	jne    20caa7 <BmSelf.mfence.init+0xbe7>
  20c687:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  20c68e:	00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20c690:	b0 01                	mov    al,0x1
  20c692:	86 05 78 39 04 00    	xchg   BYTE PTR [rip+0x43978],al        # 250010 <stderr_mutex>
  20c698:	84 c0                	test   al,al
  20c69a:	75 f4                	jne    20c690 <BmSelf.mfence.init+0x7d0>
    if (stderr_stream) |st| {
  20c69c:	48 8b 3d 65 39 04 00 	mov    rdi,QWORD PTR [rip+0x43965]        # 250008 <stderr_stream>
  20c6a3:	48 85 ff             	test   rdi,rdi
  20c6a6:	74 18                	je     20c6c0 <BmSelf.mfence.init+0x800>
  20c6a8:	48 8b 0d 91 e9 03 00 	mov    rcx,QWORD PTR [rip+0x3e991]        # 24b040 <stderr_file_out_stream+0x8>
  20c6af:	eb 4c                	jmp    20c6fd <BmSelf.mfence.init+0x83d>
  20c6b1:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20c6b8:	0f 1f 84 00 00 00 00 
  20c6bf:	00 
        stderr_file = try io.getStdErr();
  20c6c0:	c7 05 66 e9 03 00 02 	mov    DWORD PTR [rip+0x3e966],0x2        # 24b030 <stderr_file>
  20c6c7:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20c6ca:	48 8d 05 5f e9 03 00 	lea    rax,[rip+0x3e95f]        # 24b030 <stderr_file>
  20c6d1:	48 89 05 60 e9 03 00 	mov    QWORD PTR [rip+0x3e960],rax        # 24b038 <stderr_file_out_stream>
  20c6d8:	48 8d 05 01 33 01 00 	lea    rax,[rip+0x13301]        # 21f9e0 <FileOutStream_writeFn>
  20c6df:	48 89 05 5a e9 03 00 	mov    QWORD PTR [rip+0x3e95a],rax        # 24b040 <stderr_file_out_stream+0x8>
  20c6e6:	48 8d 0d 53 e9 03 00 	lea    rcx,[rip+0x3e953]        # 24b040 <stderr_file_out_stream+0x8>
  20c6ed:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20c6f0:	48 89 15 11 39 04 00 	mov    QWORD PTR [rip+0x43911],rdx        # 250008 <stderr_stream>
  20c6f7:	48 89 c1             	mov    rcx,rax
  20c6fa:	48 89 d7             	mov    rdi,rdx
  20c6fd:	c6 44 24 07 20       	mov    BYTE PTR [rsp+0x7],0x20
  20c702:	48 89 6c 24 08       	mov    QWORD PTR [rsp+0x8],rbp
  20c707:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  20c70e:	00 00 
  20c710:	48 8d 74 24 08       	lea    rsi,[rsp+0x8]
  20c715:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20c717:	31 c0                	xor    eax,eax
  20c719:	86 05 f1 38 04 00    	xchg   BYTE PTR [rip+0x438f1],al        # 250010 <stderr_mutex>
  20c71f:	3c 01                	cmp    al,0x1
    if (!ok) {
  20c721:	0f 85 80 03 00 00    	jne    20caa7 <BmSelf.mfence.init+0xbe7>
  20c727:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  20c72e:	00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20c730:	b0 01                	mov    al,0x1
  20c732:	86 05 d8 38 04 00    	xchg   BYTE PTR [rip+0x438d8],al        # 250010 <stderr_mutex>
  20c738:	84 c0                	test   al,al
  20c73a:	75 f4                	jne    20c730 <BmSelf.mfence.init+0x870>
    if (stderr_stream) |st| {
  20c73c:	48 8b 3d c5 38 04 00 	mov    rdi,QWORD PTR [rip+0x438c5]        # 250008 <stderr_stream>
  20c743:	48 85 ff             	test   rdi,rdi
  20c746:	74 18                	je     20c760 <BmSelf.mfence.init+0x8a0>
  20c748:	48 8b 0d f1 e8 03 00 	mov    rcx,QWORD PTR [rip+0x3e8f1]        # 24b040 <stderr_file_out_stream+0x8>
  20c74f:	eb 4c                	jmp    20c79d <BmSelf.mfence.init+0x8dd>
  20c751:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20c758:	0f 1f 84 00 00 00 00 
  20c75f:	00 
        stderr_file = try io.getStdErr();
  20c760:	c7 05 c6 e8 03 00 02 	mov    DWORD PTR [rip+0x3e8c6],0x2        # 24b030 <stderr_file>
  20c767:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20c76a:	48 8d 05 bf e8 03 00 	lea    rax,[rip+0x3e8bf]        # 24b030 <stderr_file>
  20c771:	48 89 05 c0 e8 03 00 	mov    QWORD PTR [rip+0x3e8c0],rax        # 24b038 <stderr_file_out_stream>
  20c778:	48 8d 05 61 32 01 00 	lea    rax,[rip+0x13261]        # 21f9e0 <FileOutStream_writeFn>
  20c77f:	48 89 05 ba e8 03 00 	mov    QWORD PTR [rip+0x3e8ba],rax        # 24b040 <stderr_file_out_stream+0x8>
  20c786:	48 8d 0d b3 e8 03 00 	lea    rcx,[rip+0x3e8b3]        # 24b040 <stderr_file_out_stream+0x8>
  20c78d:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20c790:	48 89 15 71 38 04 00 	mov    QWORD PTR [rip+0x43871],rdx        # 250008 <stderr_stream>
  20c797:	48 89 c1             	mov    rcx,rax
  20c79a:	48 89 d7             	mov    rdi,rdx
  20c79d:	c6 44 24 07 20       	mov    BYTE PTR [rsp+0x7],0x20
  20c7a2:	48 89 6c 24 08       	mov    QWORD PTR [rsp+0x8],rbp
  20c7a7:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  20c7ae:	00 00 
  20c7b0:	48 8d 74 24 08       	lea    rsi,[rsp+0x8]
  20c7b5:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20c7b7:	31 c0                	xor    eax,eax
  20c7b9:	86 05 51 38 04 00    	xchg   BYTE PTR [rip+0x43851],al        # 250010 <stderr_mutex>
  20c7bf:	3c 01                	cmp    al,0x1
    if (!ok) {
  20c7c1:	0f 85 e0 02 00 00    	jne    20caa7 <BmSelf.mfence.init+0xbe7>
  20c7c7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  20c7ce:	00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20c7d0:	b0 01                	mov    al,0x1
  20c7d2:	86 05 38 38 04 00    	xchg   BYTE PTR [rip+0x43838],al        # 250010 <stderr_mutex>
  20c7d8:	84 c0                	test   al,al
  20c7da:	75 f4                	jne    20c7d0 <BmSelf.mfence.init+0x910>
    if (stderr_stream) |st| {
  20c7dc:	48 8b 3d 25 38 04 00 	mov    rdi,QWORD PTR [rip+0x43825]        # 250008 <stderr_stream>
  20c7e3:	48 85 ff             	test   rdi,rdi
  20c7e6:	74 18                	je     20c800 <BmSelf.mfence.init+0x940>
  20c7e8:	48 8b 0d 51 e8 03 00 	mov    rcx,QWORD PTR [rip+0x3e851]        # 24b040 <stderr_file_out_stream+0x8>
  20c7ef:	eb 4c                	jmp    20c83d <BmSelf.mfence.init+0x97d>
  20c7f1:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20c7f8:	0f 1f 84 00 00 00 00 
  20c7ff:	00 
        stderr_file = try io.getStdErr();
  20c800:	c7 05 26 e8 03 00 02 	mov    DWORD PTR [rip+0x3e826],0x2        # 24b030 <stderr_file>
  20c807:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20c80a:	48 8d 05 1f e8 03 00 	lea    rax,[rip+0x3e81f]        # 24b030 <stderr_file>
  20c811:	48 89 05 20 e8 03 00 	mov    QWORD PTR [rip+0x3e820],rax        # 24b038 <stderr_file_out_stream>
  20c818:	48 8d 05 c1 31 01 00 	lea    rax,[rip+0x131c1]        # 21f9e0 <FileOutStream_writeFn>
  20c81f:	48 89 05 1a e8 03 00 	mov    QWORD PTR [rip+0x3e81a],rax        # 24b040 <stderr_file_out_stream+0x8>
  20c826:	48 8d 0d 13 e8 03 00 	lea    rcx,[rip+0x3e813]        # 24b040 <stderr_file_out_stream+0x8>
  20c82d:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20c830:	48 89 15 d1 37 04 00 	mov    QWORD PTR [rip+0x437d1],rdx        # 250008 <stderr_stream>
  20c837:	48 89 c1             	mov    rcx,rax
  20c83a:	48 89 d7             	mov    rdi,rdx
  20c83d:	c6 44 24 07 20       	mov    BYTE PTR [rsp+0x7],0x20
  20c842:	48 89 6c 24 08       	mov    QWORD PTR [rsp+0x8],rbp
  20c847:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  20c84e:	00 00 
  20c850:	48 8d 74 24 08       	lea    rsi,[rsp+0x8]
  20c855:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20c857:	31 c0                	xor    eax,eax
  20c859:	86 05 b1 37 04 00    	xchg   BYTE PTR [rip+0x437b1],al        # 250010 <stderr_mutex>
  20c85f:	3c 01                	cmp    al,0x1
    if (!ok) {
  20c861:	0f 85 40 02 00 00    	jne    20caa7 <BmSelf.mfence.init+0xbe7>
  20c867:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  20c86e:	00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20c870:	b0 01                	mov    al,0x1
  20c872:	86 05 98 37 04 00    	xchg   BYTE PTR [rip+0x43798],al        # 250010 <stderr_mutex>
  20c878:	84 c0                	test   al,al
  20c87a:	75 f4                	jne    20c870 <BmSelf.mfence.init+0x9b0>
    if (stderr_stream) |st| {
  20c87c:	48 8b 3d 85 37 04 00 	mov    rdi,QWORD PTR [rip+0x43785]        # 250008 <stderr_stream>
  20c883:	48 85 ff             	test   rdi,rdi
  20c886:	74 18                	je     20c8a0 <BmSelf.mfence.init+0x9e0>
  20c888:	48 8b 0d b1 e7 03 00 	mov    rcx,QWORD PTR [rip+0x3e7b1]        # 24b040 <stderr_file_out_stream+0x8>
  20c88f:	eb 4c                	jmp    20c8dd <BmSelf.mfence.init+0xa1d>
  20c891:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20c898:	0f 1f 84 00 00 00 00 
  20c89f:	00 
        stderr_file = try io.getStdErr();
  20c8a0:	c7 05 86 e7 03 00 02 	mov    DWORD PTR [rip+0x3e786],0x2        # 24b030 <stderr_file>
  20c8a7:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20c8aa:	48 8d 05 7f e7 03 00 	lea    rax,[rip+0x3e77f]        # 24b030 <stderr_file>
  20c8b1:	48 89 05 80 e7 03 00 	mov    QWORD PTR [rip+0x3e780],rax        # 24b038 <stderr_file_out_stream>
  20c8b8:	48 8d 05 21 31 01 00 	lea    rax,[rip+0x13121]        # 21f9e0 <FileOutStream_writeFn>
  20c8bf:	48 89 05 7a e7 03 00 	mov    QWORD PTR [rip+0x3e77a],rax        # 24b040 <stderr_file_out_stream+0x8>
  20c8c6:	48 8d 0d 73 e7 03 00 	lea    rcx,[rip+0x3e773]        # 24b040 <stderr_file_out_stream+0x8>
  20c8cd:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20c8d0:	48 89 15 31 37 04 00 	mov    QWORD PTR [rip+0x43731],rdx        # 250008 <stderr_stream>
  20c8d7:	48 89 c1             	mov    rcx,rax
  20c8da:	48 89 d7             	mov    rdi,rdx
                const casted_value = ([]const u8)(value);
  20c8dd:	4c 89 64 24 08       	mov    QWORD PTR [rsp+0x8],r12
  20c8e2:	48 c7 44 24 10 04 00 	mov    QWORD PTR [rsp+0x10],0x4
  20c8e9:	00 00 
                return output(context, casted_value);
  20c8eb:	48 8d 74 24 08       	lea    rsi,[rsp+0x8]
  20c8f0:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20c8f2:	31 c0                	xor    eax,eax
  20c8f4:	86 05 16 37 04 00    	xchg   BYTE PTR [rip+0x43716],al        # 250010 <stderr_mutex>
  20c8fa:	3c 01                	cmp    al,0x1
    if (!ok) {
  20c8fc:	0f 85 a5 01 00 00    	jne    20caa7 <BmSelf.mfence.init+0xbe7>
                try rightJustified(18, "{}", "time/operation");
  20c902:	e8 59 9b 00 00       	call   216460 <Benchmark_rightJustified.38>
  20c907:	66 85 c0             	test   ax,ax
  20c90a:	0f 85 82 01 00 00    	jne    20ca92 <BmSelf.mfence.init+0xbd2>
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20c910:	b0 01                	mov    al,0x1
  20c912:	86 05 f8 36 04 00    	xchg   BYTE PTR [rip+0x436f8],al        # 250010 <stderr_mutex>
  20c918:	84 c0                	test   al,al
  20c91a:	75 f4                	jne    20c910 <BmSelf.mfence.init+0xa50>
    if (stderr_stream) |st| {
  20c91c:	48 8b 3d e5 36 04 00 	mov    rdi,QWORD PTR [rip+0x436e5]        # 250008 <stderr_stream>
  20c923:	48 85 ff             	test   rdi,rdi
  20c926:	74 18                	je     20c940 <BmSelf.mfence.init+0xa80>
  20c928:	48 8b 0d 11 e7 03 00 	mov    rcx,QWORD PTR [rip+0x3e711]        # 24b040 <stderr_file_out_stream+0x8>
  20c92f:	eb 4c                	jmp    20c97d <BmSelf.mfence.init+0xabd>
  20c931:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20c938:	0f 1f 84 00 00 00 00 
  20c93f:	00 
        stderr_file = try io.getStdErr();
  20c940:	c7 05 e6 e6 03 00 02 	mov    DWORD PTR [rip+0x3e6e6],0x2        # 24b030 <stderr_file>
  20c947:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20c94a:	48 8d 05 df e6 03 00 	lea    rax,[rip+0x3e6df]        # 24b030 <stderr_file>
  20c951:	48 89 05 e0 e6 03 00 	mov    QWORD PTR [rip+0x3e6e0],rax        # 24b038 <stderr_file_out_stream>
  20c958:	48 8d 05 81 30 01 00 	lea    rax,[rip+0x13081]        # 21f9e0 <FileOutStream_writeFn>
  20c95f:	48 89 05 da e6 03 00 	mov    QWORD PTR [rip+0x3e6da],rax        # 24b040 <stderr_file_out_stream+0x8>
  20c966:	48 8d 0d d3 e6 03 00 	lea    rcx,[rip+0x3e6d3]        # 24b040 <stderr_file_out_stream+0x8>
  20c96d:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20c970:	48 89 15 91 36 04 00 	mov    QWORD PTR [rip+0x43691],rdx        # 250008 <stderr_stream>
  20c977:	48 89 c1             	mov    rcx,rax
  20c97a:	48 89 d7             	mov    rdi,rdx
        try output(context, fmt[start_index..]);
  20c97d:	48 8d 35 94 24 04 00 	lea    rsi,[rip+0x42494]        # 24ee18 <__unnamed_3>
  20c984:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20c986:	31 c0                	xor    eax,eax
  20c988:	86 05 82 36 04 00    	xchg   BYTE PTR [rip+0x43682],al        # 250010 <stderr_mutex>
  20c98e:	3c 01                	cmp    al,0x1
    if (!ok) {
  20c990:	0f 85 11 01 00 00    	jne    20caa7 <BmSelf.mfence.init+0xbe7>
            try pSelf.report(pSelf.results.items[pSelf.results.len - 1]); warn("\n");
  20c996:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  20c99b:	48 8b 4c 24 78       	mov    rcx,QWORD PTR [rsp+0x78]
  20c9a0:	48 c1 e1 04          	shl    rcx,0x4
  20c9a4:	48 8d 34 08          	lea    rsi,[rax+rcx*1]
  20c9a8:	48 83 c6 f0          	add    rsi,0xfffffffffffffff0
  20c9ac:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  20c9b1:	c5 f8 77             	vzeroupper 
  20c9b4:	e8 a7 70 00 00       	call   213a60 <Benchmark_report>
  20c9b9:	66 85 c0             	test   ax,ax
  20c9bc:	0f 85 d0 00 00 00    	jne    20ca92 <BmSelf.mfence.init+0xbd2>
  20c9c2:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20c9c9:	1f 84 00 00 00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20c9d0:	b0 01                	mov    al,0x1
  20c9d2:	86 05 38 36 04 00    	xchg   BYTE PTR [rip+0x43638],al        # 250010 <stderr_mutex>
  20c9d8:	84 c0                	test   al,al
  20c9da:	75 f4                	jne    20c9d0 <BmSelf.mfence.init+0xb10>
    if (stderr_stream) |st| {
  20c9dc:	48 8b 3d 25 36 04 00 	mov    rdi,QWORD PTR [rip+0x43625]        # 250008 <stderr_stream>
  20c9e3:	48 85 ff             	test   rdi,rdi
  20c9e6:	74 18                	je     20ca00 <BmSelf.mfence.init+0xb40>
  20c9e8:	48 8b 0d 51 e6 03 00 	mov    rcx,QWORD PTR [rip+0x3e651]        # 24b040 <stderr_file_out_stream+0x8>
  20c9ef:	eb 4c                	jmp    20ca3d <BmSelf.mfence.init+0xb7d>
  20c9f1:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20c9f8:	0f 1f 84 00 00 00 00 
  20c9ff:	00 
        stderr_file = try io.getStdErr();
  20ca00:	c7 05 26 e6 03 00 02 	mov    DWORD PTR [rip+0x3e626],0x2        # 24b030 <stderr_file>
  20ca07:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20ca0a:	48 8d 05 1f e6 03 00 	lea    rax,[rip+0x3e61f]        # 24b030 <stderr_file>
  20ca11:	48 89 05 20 e6 03 00 	mov    QWORD PTR [rip+0x3e620],rax        # 24b038 <stderr_file_out_stream>
  20ca18:	48 8d 05 c1 2f 01 00 	lea    rax,[rip+0x12fc1]        # 21f9e0 <FileOutStream_writeFn>
  20ca1f:	48 89 05 1a e6 03 00 	mov    QWORD PTR [rip+0x3e61a],rax        # 24b040 <stderr_file_out_stream+0x8>
  20ca26:	48 8d 0d 13 e6 03 00 	lea    rcx,[rip+0x3e613]        # 24b040 <stderr_file_out_stream+0x8>
  20ca2d:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20ca30:	48 89 15 d1 35 04 00 	mov    QWORD PTR [rip+0x435d1],rdx        # 250008 <stderr_stream>
  20ca37:	48 89 c1             	mov    rcx,rax
  20ca3a:	48 89 d7             	mov    rdi,rdx
  20ca3d:	48 8d 35 d4 23 04 00 	lea    rsi,[rip+0x423d4]        # 24ee18 <__unnamed_3>
  20ca44:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20ca46:	31 c0                	xor    eax,eax
  20ca48:	86 05 c2 35 04 00    	xchg   BYTE PTR [rip+0x435c2],al        # 250010 <stderr_mutex>
  20ca4e:	3c 01                	cmp    al,0x1
    if (!ok) {
  20ca50:	75 55                	jne    20caa7 <BmSelf.mfence.init+0xbe7>
  20ca52:	49 83 c6 01          	add    r14,0x1
        while (rep < pSelf.repetitions) : (rep += 1) {
  20ca56:	4c 3b 74 24 40       	cmp    r14,QWORD PTR [rsp+0x40]
  20ca5b:	0f 82 9f f8 ff ff    	jb     20c300 <BmSelf.mfence.init+0x440>
  20ca61:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
        try pSelf.reportStats(pSelf.results);
  20ca66:	48 8d 74 24 68       	lea    rsi,[rsp+0x68]
  20ca6b:	e8 d0 9c 00 00       	call   216740 <Benchmark_reportStats>
  20ca70:	66 85 c0             	test   ax,ax
  20ca73:	75 1d                	jne    20ca92 <BmSelf.mfence.init+0xbd2>
    };

    var bmSelf = try bm.run(BmSelf);
    assert(bmSelf.init_count == 1);
    assert(bmSelf.setup_count == 0);
    assert(bmSelf.benchmark_count > 1000000);
  20ca75:	49 81 fd 40 42 0f 00 	cmp    r13,0xf4240
  20ca7c:	76 29                	jbe    20caa7 <BmSelf.mfence.init+0xbe7>
  20ca7e:	31 c0                	xor    eax,eax
  20ca80:	eb 10                	jmp    20ca92 <BmSelf.mfence.init+0xbd2>
                switch (errno) {
  20ca82:	48 83 f9 16          	cmp    rcx,0x16
  20ca86:	75 06                	jne    20ca8e <BmSelf.mfence.init+0xbce>
  20ca88:	66 b8 02 00          	mov    ax,0x2
  20ca8c:	eb 04                	jmp    20ca92 <BmSelf.mfence.init+0xbd2>
  20ca8e:	66 b8 03 00          	mov    ax,0x3
    var bmSelf = try bm.run(BmSelf);
  20ca92:	48 81 c4 f8 00 00 00 	add    rsp,0xf8
  20ca99:	5b                   	pop    rbx
  20ca9a:	41 5c                	pop    r12
  20ca9c:	41 5d                	pop    r13
  20ca9e:	41 5e                	pop    r14
  20caa0:	41 5f                	pop    r15
  20caa2:	5d                   	pop    rbp
  20caa3:	c5 f8 77             	vzeroupper 
  20caa6:	c3                   	ret    
            @panic("assertion failure");
  20caa7:	48 8d 3d 5a 22 04 00 	lea    rdi,[rip+0x4225a]        # 24ed08 <__unnamed_2>
  20caae:	c5 f8 77             	vzeroupper 
  20cab1:	e8 6a 55 00 00       	call   212020 <panic>
  20cab6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  20cabd:	00 00 00 

000000000020cac0 <BmSelf.init.setup>:
    assert(bmSelf.tearDown_count == 0);
}

test "BmSelf.init.setup" {
  20cac0:	55                   	push   rbp
  20cac1:	41 57                	push   r15
  20cac3:	41 56                	push   r14
  20cac5:	41 55                	push   r13
  20cac7:	41 54                	push   r12
  20cac9:	53                   	push   rbx
  20caca:	48 81 ec f8 00 00 00 	sub    rsp,0xf8
  20cad1:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20cad8:	0f 1f 84 00 00 00 00 
  20cadf:	00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20cae0:	b0 01                	mov    al,0x1
  20cae2:	86 05 28 35 04 00    	xchg   BYTE PTR [rip+0x43528],al        # 250010 <stderr_mutex>
  20cae8:	84 c0                	test   al,al
  20caea:	75 f4                	jne    20cae0 <BmSelf.init.setup+0x20>
    if (stderr_stream) |st| {
  20caec:	48 8b 3d 15 35 04 00 	mov    rdi,QWORD PTR [rip+0x43515]        # 250008 <stderr_stream>
  20caf3:	48 85 ff             	test   rdi,rdi
  20caf6:	74 09                	je     20cb01 <BmSelf.init.setup+0x41>
  20caf8:	48 8b 05 41 e5 03 00 	mov    rax,QWORD PTR [rip+0x3e541]        # 24b040 <stderr_file_out_stream+0x8>
  20caff:	eb 34                	jmp    20cb35 <BmSelf.init.setup+0x75>
        stderr_file = try io.getStdErr();
  20cb01:	48 8d 05 28 e5 03 00 	lea    rax,[rip+0x3e528]        # 24b030 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20cb08:	48 89 05 29 e5 03 00 	mov    QWORD PTR [rip+0x3e529],rax        # 24b038 <stderr_file_out_stream>
  20cb0f:	48 8d 05 ca 2e 01 00 	lea    rax,[rip+0x12eca]        # 21f9e0 <FileOutStream_writeFn>
  20cb16:	48 89 05 23 e5 03 00 	mov    QWORD PTR [rip+0x3e523],rax        # 24b040 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  20cb1d:	c7 05 09 e5 03 00 02 	mov    DWORD PTR [rip+0x3e509],0x2        # 24b030 <stderr_file>
  20cb24:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20cb27:	48 8d 3d 12 e5 03 00 	lea    rdi,[rip+0x3e512]        # 24b040 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  20cb2e:	48 89 3d d3 34 04 00 	mov    QWORD PTR [rip+0x434d3],rdi        # 250008 <stderr_stream>
  20cb35:	48 8d 35 dc 22 04 00 	lea    rsi,[rip+0x422dc]        # 24ee18 <__unnamed_3>
  20cb3c:	ff d0                	call   rax
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20cb3e:	31 c0                	xor    eax,eax
  20cb40:	86 05 ca 34 04 00    	xchg   BYTE PTR [rip+0x434ca],al        # 250010 <stderr_mutex>
  20cb46:	3c 01                	cmp    al,0x1
    if (!ok) {
  20cb48:	0f 85 58 0b 00 00    	jne    20d6a6 <BmSelf.init.setup+0xbe6>
    // Since this is a test print a \n before we run
    warn("\n");

    // Test fn benchmark(pSelf) can return an error
    var bm = Benchmark.init("BmEmpty.error", std.debug.global_allocator);
  20cb4e:	c5 f8 10 05 a2 21 04 	vmovups xmm0,XMMWORD PTR [rip+0x421a2]        # 24ecf8 <__unnamed_9>
  20cb55:	00 
  20cb56:	c5 f8 29 44 24 20    	vmovaps XMMWORD PTR [rsp+0x20],xmm0
  20cb5c:	49 bf 00 e8 76 48 17 	movabs r15,0x174876e800
  20cb63:	00 00 00 
  20cb66:	b8 00 65 cd 1d       	mov    eax,0x1dcd6500
  20cb6b:	c4 e1 f9 6e c0       	vmovq  xmm0,rax
  20cb70:	c5 f9 73 f8 08       	vpslldq xmm0,xmm0,0x8
  20cb75:	c5 f9 7f 44 24 30    	vmovdqa XMMWORD PTR [rsp+0x30],xmm0
  20cb7b:	4c 89 7c 24 48       	mov    QWORD PTR [rsp+0x48],r15
  20cb80:	c5 fa 6f 05 38 c2 ff 	vmovdqu xmm0,XMMWORD PTR [rip+0xffffffffffffc238]        # 208dc0 <__unnamed_5>
  20cb87:	ff 
  20cb88:	c5 f9 7f 44 24 50    	vmovdqa XMMWORD PTR [rsp+0x50],xmm0
  20cb8e:	48 8d 05 6b e4 03 00 	lea    rax,[rip+0x3e46b]        # 24b000 <global_fixed_allocator>
  20cb95:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  20cb9a:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  20cb9e:	c5 fa 7f 44 24 68    	vmovdqu XMMWORD PTR [rsp+0x68],xmm0
  20cba4:	48 c7 44 24 78 00 00 	mov    QWORD PTR [rsp+0x78],0x0
  20cbab:	00 00 
  20cbad:	48 89 84 24 80 00 00 	mov    QWORD PTR [rsp+0x80],rax
  20cbb4:	00 
        fn benchmark(pSelf: *Self) void {
            pSelf.benchmark_count += 1;
        }
    };

    bm.repetitions = 3;
  20cbb5:	48 c7 44 24 40 03 00 	mov    QWORD PTR [rsp+0x40],0x3
  20cbbc:	00 00 
  20cbbe:	b1 01                	mov    cl,0x1
  20cbc0:	bb 01 00 00 00       	mov    ebx,0x1
  20cbc5:	4c 8d a4 24 90 00 00 	lea    r12,[rsp+0x90]
  20cbcc:	00 
  20cbcd:	45 31 f6             	xor    r14d,r14d
  20cbd0:	45 31 ed             	xor    r13d,r13d
            while (iterations <= pSelf.max_iterations) {
  20cbd3:	4c 39 fb             	cmp    rbx,r15
  20cbd6:	0f 87 27 03 00 00    	ja     20cf03 <BmSelf.init.setup+0x443>
  20cbdc:	89 4c 24 1c          	mov    DWORD PTR [rsp+0x1c],ecx
  20cbe0:	eb 19                	jmp    20cbfb <BmSelf.init.setup+0x13b>
  20cbe2:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20cbe9:	1f 84 00 00 00 00 00 
                        warn("iteratons:{} numer:{} denom:{}\n", iterations, numer, denom);
  20cbf0:	48 89 df             	mov    rdi,rbx
  20cbf3:	48 89 ca             	mov    rdx,rcx
  20cbf6:	e8 75 8f 00 00       	call   215b70 <warn.36>
                var ts: posix.timespec = undefined;
  20cbfb:	c5 fa 6f 05 bd c1 ff 	vmovdqu xmm0,XMMWORD PTR [rip+0xffffffffffffc1bd]        # 208dc0 <__unnamed_5>
  20cc02:	ff 
  20cc03:	c5 f9 7f 84 24 90 00 	vmovdqa XMMWORD PTR [rsp+0x90],xmm0
  20cc0a:	00 00 
  20cc0c:	b8 e5 00 00 00       	mov    eax,0xe5
  20cc11:	bf 01 00 00 00       	mov    edi,0x1
  20cc16:	4c 89 e6             	mov    rsi,r12
  20cc19:	0f 05                	syscall 
  20cc1b:	48 89 c1             	mov    rcx,rax
  20cc1e:	48 f7 d9             	neg    rcx
  20cc21:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  20cc27:	b8 00 00 00 00       	mov    eax,0x0
  20cc2c:	48 0f 46 c8          	cmovbe rcx,rax
                switch (errno) {
  20cc30:	48 85 c9             	test   rcx,rcx
  20cc33:	0f 85 4b 0a 00 00    	jne    20d684 <BmSelf.init.setup+0xbc4>
        const f = @atomicLoad(@typeOf(init_vdso_clock_gettime), &vdso_clock_gettime, builtin.AtomicOrder.Unordered);
  20cc39:	48 8b 05 08 e4 03 00 	mov    rax,QWORD PTR [rip+0x3e408]        # 24b048 <vdso_clock_gettime>
        if (@ptrToInt(f) != 0) {
  20cc40:	48 85 c0             	test   rax,rax
  20cc43:	74 21                	je     20cc66 <BmSelf.init.setup+0x1a6>
            const rc = f(clk_id, tp);
  20cc45:	bf 01 00 00 00       	mov    edi,0x1
  20cc4a:	4c 89 e6             	mov    rsi,r12
  20cc4d:	ff d0                	call   rax
            switch (rc) {
  20cc4f:	48 83 f8 ea          	cmp    rax,0xffffffffffffffea
  20cc53:	0f 84 27 02 00 00    	je     20ce80 <BmSelf.init.setup+0x3c0>
  20cc59:	48 85 c0             	test   rax,rax
  20cc5c:	c5 fa 6f 05 5c c1 ff 	vmovdqu xmm0,XMMWORD PTR [rip+0xffffffffffffc15c]        # 208dc0 <__unnamed_5>
  20cc63:	ff 
  20cc64:	74 0f                	je     20cc75 <BmSelf.init.setup+0x1b5>
  20cc66:	b8 e4 00 00 00       	mov    eax,0xe4
  20cc6b:	bf 01 00 00 00       	mov    edi,0x1
  20cc70:	4c 89 e6             	mov    rsi,r12
  20cc73:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  20cc75:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
                if (errno != 0) return std.os.unexpectedErrorPosix(errno);
  20cc7b:	0f 83 0f 0a 00 00    	jae    20d690 <BmSelf.init.setup+0xbd0>
                self.start_time = @intCast(u64, ts.tv_sec) * u64(ns_per_s) + @intCast(u64, ts.tv_nsec);
  20cc81:	c5 f9 6f 8c 24 90 00 	vmovdqa xmm1,XMMWORD PTR [rsp+0x90]
  20cc88:	00 00 
        var ts: posix.timespec = undefined;
  20cc8a:	c5 f9 7f 84 24 90 00 	vmovdqa XMMWORD PTR [rsp+0x90],xmm0
  20cc91:	00 00 
        const f = @atomicLoad(@typeOf(init_vdso_clock_gettime), &vdso_clock_gettime, builtin.AtomicOrder.Unordered);
  20cc93:	48 8b 05 ae e3 03 00 	mov    rax,QWORD PTR [rip+0x3e3ae]        # 24b048 <vdso_clock_gettime>
        if (@ptrToInt(f) != 0) {
  20cc9a:	48 85 c0             	test   rax,rax
  20cc9d:	74 2b                	je     20ccca <BmSelf.init.setup+0x20a>
  20cc9f:	c5 f9 7f 8c 24 c0 00 	vmovdqa XMMWORD PTR [rsp+0xc0],xmm1
  20cca6:	00 00 
            const rc = f(clk_id, tp);
  20cca8:	bf 01 00 00 00       	mov    edi,0x1
  20ccad:	4c 89 e6             	mov    rsi,r12
  20ccb0:	ff d0                	call   rax
            switch (rc) {
  20ccb2:	48 83 f8 ea          	cmp    rax,0xffffffffffffffea
  20ccb6:	0f 84 dd 01 00 00    	je     20ce99 <BmSelf.init.setup+0x3d9>
  20ccbc:	48 85 c0             	test   rax,rax
  20ccbf:	c5 f9 6f 8c 24 c0 00 	vmovdqa xmm1,XMMWORD PTR [rsp+0xc0]
  20ccc6:	00 00 
  20ccc8:	74 0f                	je     20ccd9 <BmSelf.init.setup+0x219>
  20ccca:	b8 e4 00 00 00       	mov    eax,0xe4
  20cccf:	bf 01 00 00 00       	mov    edi,0x1
  20ccd4:	4c 89 e6             	mov    rsi,r12
  20ccd7:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  20ccd9:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
  20ccdf:	0f 83 c1 09 00 00    	jae    20d6a6 <BmSelf.init.setup+0xbe6>
  20cce5:	49 01 dd             	add    r13,rbx
        return @intCast(u64, ts.tv_sec) * u64(ns_per_s) + @intCast(u64, ts.tv_nsec);
  20cce8:	c5 f9 6f 84 24 90 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x90]
  20ccef:	00 00 
  20ccf1:	c5 f9 fb c1          	vpsubq xmm0,xmm0,xmm1
  20ccf5:	c4 e1 f9 7e c0       	vmovq  rax,xmm0
        var clock = clockNative() - self.start_time;
  20ccfa:	c4 e3 f9 16 c5 01    	vpextrq rbp,xmm0,0x1
  20cd00:	48 69 c0 00 ca 9a 3b 	imul   rax,rax,0x3b9aca00
  20cd07:	48 01 c5             	add    rbp,rax
                if ((run_time_ns >= pSelf.min_runtime_ns) or (iterations >= pSelf.max_iterations)) {
  20cd0a:	48 3b 6c 24 38       	cmp    rbp,QWORD PTR [rsp+0x38]
  20cd0f:	0f 83 ab 01 00 00    	jae    20cec0 <BmSelf.init.setup+0x400>
  20cd15:	4c 39 fb             	cmp    rbx,r15
  20cd18:	0f 83 a2 01 00 00    	jae    20cec0 <BmSelf.init.setup+0x400>
                    if (pSelf.logl >= 1) {
  20cd1e:	48 83 7c 24 30 00    	cmp    QWORD PTR [rsp+0x30],0x0
  20cd24:	0f 84 bc 00 00 00    	je     20cde6 <BmSelf.init.setup+0x326>
                            Result {.run_time_ns = run_time_ns, .iterations = iterations});
  20cd2a:	48 89 ac 24 d8 00 00 	mov    QWORD PTR [rsp+0xd8],rbp
  20cd31:	00 
  20cd32:	48 89 9c 24 e0 00 00 	mov    QWORD PTR [rsp+0xe0],rbx
  20cd39:	00 
                        try pSelf.report(
  20cd3a:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  20cd3f:	48 8d b4 24 d8 00 00 	lea    rsi,[rsp+0xd8]
  20cd46:	00 
  20cd47:	e8 14 6d 00 00       	call   213a60 <Benchmark_report>
  20cd4c:	66 85 c0             	test   ax,ax
  20cd4f:	0f 85 3f 09 00 00    	jne    20d694 <BmSelf.init.setup+0xbd4>
  20cd55:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20cd5c:	00 00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20cd60:	b0 01                	mov    al,0x1
  20cd62:	86 05 a8 32 04 00    	xchg   BYTE PTR [rip+0x432a8],al        # 250010 <stderr_mutex>
  20cd68:	84 c0                	test   al,al
  20cd6a:	75 f4                	jne    20cd60 <BmSelf.init.setup+0x2a0>
    if (stderr_stream) |st| {
  20cd6c:	48 8b 3d 95 32 04 00 	mov    rdi,QWORD PTR [rip+0x43295]        # 250008 <stderr_stream>
  20cd73:	48 85 ff             	test   rdi,rdi
  20cd76:	74 18                	je     20cd90 <BmSelf.init.setup+0x2d0>
  20cd78:	48 8b 0d c1 e2 03 00 	mov    rcx,QWORD PTR [rip+0x3e2c1]        # 24b040 <stderr_file_out_stream+0x8>
  20cd7f:	eb 4c                	jmp    20cdcd <BmSelf.init.setup+0x30d>
  20cd81:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20cd88:	0f 1f 84 00 00 00 00 
  20cd8f:	00 
        stderr_file = try io.getStdErr();
  20cd90:	c7 05 96 e2 03 00 02 	mov    DWORD PTR [rip+0x3e296],0x2        # 24b030 <stderr_file>
  20cd97:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20cd9a:	48 8d 05 8f e2 03 00 	lea    rax,[rip+0x3e28f]        # 24b030 <stderr_file>
  20cda1:	48 89 05 90 e2 03 00 	mov    QWORD PTR [rip+0x3e290],rax        # 24b038 <stderr_file_out_stream>
  20cda8:	48 8d 05 31 2c 01 00 	lea    rax,[rip+0x12c31]        # 21f9e0 <FileOutStream_writeFn>
  20cdaf:	48 89 05 8a e2 03 00 	mov    QWORD PTR [rip+0x3e28a],rax        # 24b040 <stderr_file_out_stream+0x8>
  20cdb6:	48 8d 0d 83 e2 03 00 	lea    rcx,[rip+0x3e283]        # 24b040 <stderr_file_out_stream+0x8>
  20cdbd:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20cdc0:	48 89 15 41 32 04 00 	mov    QWORD PTR [rip+0x43241],rdx        # 250008 <stderr_stream>
  20cdc7:	48 89 c1             	mov    rcx,rax
  20cdca:	48 89 d7             	mov    rdi,rdx
  20cdcd:	48 8d 35 44 20 04 00 	lea    rsi,[rip+0x42044]        # 24ee18 <__unnamed_3>
  20cdd4:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20cdd6:	31 c0                	xor    eax,eax
  20cdd8:	86 05 32 32 04 00    	xchg   BYTE PTR [rip+0x43232],al        # 250010 <stderr_mutex>
  20cdde:	3c 01                	cmp    al,0x1
    if (!ok) {
  20cde0:	0f 85 c0 08 00 00    	jne    20d6a6 <BmSelf.init.setup+0xbe6>
                    if (run_time_ns < 1000) {
  20cde6:	48 81 fd e8 03 00 00 	cmp    rbp,0x3e8
  20cded:	73 31                	jae    20ce20 <BmSelf.init.setup+0x360>
  20cdef:	b9 01 00 00 00       	mov    ecx,0x1
  20cdf4:	be e8 03 00 00       	mov    esi,0x3e8
                    iterations = (iterations * numer) / denom;
  20cdf9:	48 0f af de          	imul   rbx,rsi
  20cdfd:	48 89 d8             	mov    rax,rbx
  20ce00:	48 c1 e8 20          	shr    rax,0x20
  20ce04:	74 54                	je     20ce5a <BmSelf.init.setup+0x39a>
  20ce06:	31 d2                	xor    edx,edx
  20ce08:	48 89 d8             	mov    rax,rbx
  20ce0b:	48 f7 f1             	div    rcx
  20ce0e:	48 89 c3             	mov    rbx,rax
  20ce11:	eb 4f                	jmp    20ce62 <BmSelf.init.setup+0x3a2>
  20ce13:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20ce1a:	84 00 00 00 00 00 
                    } else if (run_time_ns < (pSelf.min_runtime_ns / 10)) {
  20ce20:	48 ba cd cc cc cc cc 	movabs rdx,0xcccccccccccccccd
  20ce27:	cc cc cc 
  20ce2a:	c4 e2 fb f6 4c 24 38 	mulx   rcx,rax,QWORD PTR [rsp+0x38]
  20ce31:	48 c1 e9 03          	shr    rcx,0x3
  20ce35:	31 c0                	xor    eax,eax
  20ce37:	48 39 cd             	cmp    rbp,rcx
  20ce3a:	0f 93 c0             	setae  al
  20ce3d:	48 8d 0c c0          	lea    rcx,[rax+rax*8]
  20ce41:	48 83 c1 01          	add    rcx,0x1
  20ce45:	48 8d 34 85 0a 00 00 	lea    rsi,[rax*4+0xa]
  20ce4c:	00 
                    iterations = (iterations * numer) / denom;
  20ce4d:	48 0f af de          	imul   rbx,rsi
  20ce51:	48 89 d8             	mov    rax,rbx
  20ce54:	48 c1 e8 20          	shr    rax,0x20
  20ce58:	75 ac                	jne    20ce06 <BmSelf.init.setup+0x346>
  20ce5a:	31 d2                	xor    edx,edx
  20ce5c:	89 d8                	mov    eax,ebx
  20ce5e:	f7 f1                	div    ecx
  20ce60:	89 c3                	mov    ebx,eax
                    if (iterations > pSelf.max_iterations) {
  20ce62:	4c 8b 7c 24 48       	mov    r15,QWORD PTR [rsp+0x48]
  20ce67:	4c 39 fb             	cmp    rbx,r15
  20ce6a:	49 0f 47 df          	cmova  rbx,r15
                    if (pSelf.logl >= 2) {
  20ce6e:	48 83 7c 24 30 02    	cmp    QWORD PTR [rsp+0x30],0x2
  20ce74:	0f 82 81 fd ff ff    	jb     20cbfb <BmSelf.init.setup+0x13b>
  20ce7a:	e9 71 fd ff ff       	jmp    20cbf0 <BmSelf.init.setup+0x130>
  20ce7f:	90                   	nop
  20ce80:	c5 fa 6f 05 38 bf ff 	vmovdqu xmm0,XMMWORD PTR [rip+0xffffffffffffbf38]        # 208dc0 <__unnamed_5>
  20ce87:	ff 
  20ce88:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
                if (errno != 0) return std.os.unexpectedErrorPosix(errno);
  20ce8e:	0f 82 ed fd ff ff    	jb     20cc81 <BmSelf.init.setup+0x1c1>
  20ce94:	e9 f7 07 00 00       	jmp    20d690 <BmSelf.init.setup+0xbd0>
  20ce99:	c5 f9 6f 8c 24 c0 00 	vmovdqa xmm1,XMMWORD PTR [rsp+0xc0]
  20cea0:	00 00 
  20cea2:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
  20cea8:	0f 82 37 fe ff ff    	jb     20cce5 <BmSelf.init.setup+0x225>
  20ceae:	e9 f3 07 00 00       	jmp    20d6a6 <BmSelf.init.setup+0xbe6>
  20ceb3:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20ceba:	84 00 00 00 00 00 
                            Result { .run_time_ns = run_time_ns, .iterations = iterations});
  20cec0:	48 89 ac 24 e8 00 00 	mov    QWORD PTR [rsp+0xe8],rbp
  20cec7:	00 
  20cec8:	48 89 9c 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rbx
  20cecf:	00 
                    try pSelf.results.append(
  20ced0:	48 8d 7c 24 68       	lea    rdi,[rsp+0x68]
  20ced5:	48 8d b4 24 e8 00 00 	lea    rsi,[rsp+0xe8]
  20cedc:	00 
  20cedd:	e8 0e 6a 00 00       	call   2138f0 <AlignedArrayList(Result,8)_append>
  20cee2:	66 85 c0             	test   ax,ax
  20cee5:	8b 4c 24 1c          	mov    ecx,DWORD PTR [rsp+0x1c]
  20cee9:	74 18                	je     20cf03 <BmSelf.init.setup+0x443>
  20ceeb:	e9 a4 07 00 00       	jmp    20d694 <BmSelf.init.setup+0xbd4>
  20cef0:	49 89 ee             	mov    r14,rbp
            while (iterations <= pSelf.max_iterations) {
  20cef3:	4c 8b 7c 24 48       	mov    r15,QWORD PTR [rsp+0x48]
  20cef8:	31 c9                	xor    ecx,ecx
  20cefa:	4c 39 fb             	cmp    rbx,r15
  20cefd:	0f 86 d9 fc ff ff    	jbe    20cbdc <BmSelf.init.setup+0x11c>
            if (once) {
  20cf03:	f6 c1 01             	test   cl,0x1
  20cf06:	48 8d 6c 24 07       	lea    rbp,[rsp+0x7]
  20cf0b:	49 89 ef             	mov    r15,rbp
  20cf0e:	4c 89 f5             	mov    rbp,r14
  20cf11:	4c 8d 74 24 08       	lea    r14,[rsp+0x8]
  20cf16:	0f 84 7a 06 00 00    	je     20d596 <BmSelf.init.setup+0xad6>
                try leftJustified(22, "name repetitions:{}", pSelf.repetitions);
  20cf1c:	48 8b 7c 24 40       	mov    rdi,QWORD PTR [rsp+0x40]
  20cf21:	e8 ba 8f 00 00       	call   215ee0 <Benchmark_leftJustified>
  20cf26:	66 85 c0             	test   ax,ax
  20cf29:	0f 85 65 07 00 00    	jne    20d694 <BmSelf.init.setup+0xbd4>
                try rightJustified(14, "{}", "iterations");
  20cf2f:	e8 4c 92 00 00       	call   216180 <Benchmark_rightJustified>
  20cf34:	66 85 c0             	test   ax,ax
  20cf37:	0f 85 57 07 00 00    	jne    20d694 <BmSelf.init.setup+0xbd4>
        var buffer: [40]u8 = undefined;
  20cf3d:	c5 fe 6f 05 56 86 ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffff8656]        # 20559b <__unnamed_7>
  20cf44:	ff 
  20cf45:	c5 fe 7f 84 24 90 00 	vmovdqu YMMWORD PTR [rsp+0x90],ymm0
  20cf4c:	00 00 
  20cf4e:	48 8b 05 66 86 ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffff8666]        # 2055bb <__unnamed_7+0x20>
  20cf55:	48 89 84 24 b0 00 00 	mov    QWORD PTR [rsp+0xb0],rax
  20cf5c:	00 
  20cf5d:	c7 84 24 90 00 00 00 	mov    DWORD PTR [rsp+0x90],0x656d6974
  20cf64:	74 69 6d 65 
  20cf68:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  20cf6f:	00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20cf70:	b0 01                	mov    al,0x1
  20cf72:	86 05 98 30 04 00    	xchg   BYTE PTR [rip+0x43098],al        # 250010 <stderr_mutex>
  20cf78:	84 c0                	test   al,al
  20cf7a:	75 f4                	jne    20cf70 <BmSelf.init.setup+0x4b0>
    if (stderr_stream) |st| {
  20cf7c:	48 8b 3d 85 30 04 00 	mov    rdi,QWORD PTR [rip+0x43085]        # 250008 <stderr_stream>
  20cf83:	48 85 ff             	test   rdi,rdi
  20cf86:	74 18                	je     20cfa0 <BmSelf.init.setup+0x4e0>
  20cf88:	48 8b 0d b1 e0 03 00 	mov    rcx,QWORD PTR [rip+0x3e0b1]        # 24b040 <stderr_file_out_stream+0x8>
  20cf8f:	eb 4c                	jmp    20cfdd <BmSelf.init.setup+0x51d>
  20cf91:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20cf98:	0f 1f 84 00 00 00 00 
  20cf9f:	00 
        stderr_file = try io.getStdErr();
  20cfa0:	c7 05 86 e0 03 00 02 	mov    DWORD PTR [rip+0x3e086],0x2        # 24b030 <stderr_file>
  20cfa7:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20cfaa:	48 8d 05 7f e0 03 00 	lea    rax,[rip+0x3e07f]        # 24b030 <stderr_file>
  20cfb1:	48 89 05 80 e0 03 00 	mov    QWORD PTR [rip+0x3e080],rax        # 24b038 <stderr_file_out_stream>
  20cfb8:	48 8d 05 21 2a 01 00 	lea    rax,[rip+0x12a21]        # 21f9e0 <FileOutStream_writeFn>
  20cfbf:	48 89 05 7a e0 03 00 	mov    QWORD PTR [rip+0x3e07a],rax        # 24b040 <stderr_file_out_stream+0x8>
  20cfc6:	48 8d 0d 73 e0 03 00 	lea    rcx,[rip+0x3e073]        # 24b040 <stderr_file_out_stream+0x8>
  20cfcd:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20cfd0:	48 89 15 31 30 04 00 	mov    QWORD PTR [rip+0x43031],rdx        # 250008 <stderr_stream>
  20cfd7:	48 89 c1             	mov    rcx,rax
  20cfda:	48 89 d7             	mov    rdi,rdx
  20cfdd:	c6 44 24 07 20       	mov    BYTE PTR [rsp+0x7],0x20
    return output(context, (*[1]u8)(&c)[0..]);
  20cfe2:	4c 89 7c 24 08       	mov    QWORD PTR [rsp+0x8],r15
  20cfe7:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  20cfee:	00 00 
  20cff0:	4c 89 f6             	mov    rsi,r14
  20cff3:	c5 f8 77             	vzeroupper 
  20cff6:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20cff8:	31 c0                	xor    eax,eax
  20cffa:	86 05 10 30 04 00    	xchg   BYTE PTR [rip+0x43010],al        # 250010 <stderr_mutex>
  20d000:	3c 01                	cmp    al,0x1
    if (!ok) {
  20d002:	0f 85 9e 06 00 00    	jne    20d6a6 <BmSelf.init.setup+0xbe6>
  20d008:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  20d00f:	00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20d010:	b0 01                	mov    al,0x1
  20d012:	86 05 f8 2f 04 00    	xchg   BYTE PTR [rip+0x42ff8],al        # 250010 <stderr_mutex>
  20d018:	84 c0                	test   al,al
  20d01a:	75 f4                	jne    20d010 <BmSelf.init.setup+0x550>
    if (stderr_stream) |st| {
  20d01c:	48 8b 3d e5 2f 04 00 	mov    rdi,QWORD PTR [rip+0x42fe5]        # 250008 <stderr_stream>
  20d023:	48 85 ff             	test   rdi,rdi
  20d026:	74 18                	je     20d040 <BmSelf.init.setup+0x580>
  20d028:	48 8b 0d 11 e0 03 00 	mov    rcx,QWORD PTR [rip+0x3e011]        # 24b040 <stderr_file_out_stream+0x8>
  20d02f:	eb 4c                	jmp    20d07d <BmSelf.init.setup+0x5bd>
  20d031:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20d038:	0f 1f 84 00 00 00 00 
  20d03f:	00 
        stderr_file = try io.getStdErr();
  20d040:	c7 05 e6 df 03 00 02 	mov    DWORD PTR [rip+0x3dfe6],0x2        # 24b030 <stderr_file>
  20d047:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20d04a:	48 8d 05 df df 03 00 	lea    rax,[rip+0x3dfdf]        # 24b030 <stderr_file>
  20d051:	48 89 05 e0 df 03 00 	mov    QWORD PTR [rip+0x3dfe0],rax        # 24b038 <stderr_file_out_stream>
  20d058:	48 8d 05 81 29 01 00 	lea    rax,[rip+0x12981]        # 21f9e0 <FileOutStream_writeFn>
  20d05f:	48 89 05 da df 03 00 	mov    QWORD PTR [rip+0x3dfda],rax        # 24b040 <stderr_file_out_stream+0x8>
  20d066:	48 8d 0d d3 df 03 00 	lea    rcx,[rip+0x3dfd3]        # 24b040 <stderr_file_out_stream+0x8>
  20d06d:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20d070:	48 89 15 91 2f 04 00 	mov    QWORD PTR [rip+0x42f91],rdx        # 250008 <stderr_stream>
  20d077:	48 89 c1             	mov    rcx,rax
  20d07a:	48 89 d7             	mov    rdi,rdx
  20d07d:	c6 44 24 07 20       	mov    BYTE PTR [rsp+0x7],0x20
  20d082:	4c 89 7c 24 08       	mov    QWORD PTR [rsp+0x8],r15
  20d087:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  20d08e:	00 00 
  20d090:	4c 89 f6             	mov    rsi,r14
  20d093:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20d095:	31 c0                	xor    eax,eax
  20d097:	86 05 73 2f 04 00    	xchg   BYTE PTR [rip+0x42f73],al        # 250010 <stderr_mutex>
  20d09d:	3c 01                	cmp    al,0x1
    if (!ok) {
  20d09f:	0f 85 01 06 00 00    	jne    20d6a6 <BmSelf.init.setup+0xbe6>
  20d0a5:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20d0ac:	00 00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20d0b0:	b0 01                	mov    al,0x1
  20d0b2:	86 05 58 2f 04 00    	xchg   BYTE PTR [rip+0x42f58],al        # 250010 <stderr_mutex>
  20d0b8:	84 c0                	test   al,al
  20d0ba:	75 f4                	jne    20d0b0 <BmSelf.init.setup+0x5f0>
    if (stderr_stream) |st| {
  20d0bc:	48 8b 3d 45 2f 04 00 	mov    rdi,QWORD PTR [rip+0x42f45]        # 250008 <stderr_stream>
  20d0c3:	48 85 ff             	test   rdi,rdi
  20d0c6:	74 18                	je     20d0e0 <BmSelf.init.setup+0x620>
  20d0c8:	48 8b 0d 71 df 03 00 	mov    rcx,QWORD PTR [rip+0x3df71]        # 24b040 <stderr_file_out_stream+0x8>
  20d0cf:	eb 4c                	jmp    20d11d <BmSelf.init.setup+0x65d>
  20d0d1:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20d0d8:	0f 1f 84 00 00 00 00 
  20d0df:	00 
        stderr_file = try io.getStdErr();
  20d0e0:	c7 05 46 df 03 00 02 	mov    DWORD PTR [rip+0x3df46],0x2        # 24b030 <stderr_file>
  20d0e7:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20d0ea:	48 8d 05 3f df 03 00 	lea    rax,[rip+0x3df3f]        # 24b030 <stderr_file>
  20d0f1:	48 89 05 40 df 03 00 	mov    QWORD PTR [rip+0x3df40],rax        # 24b038 <stderr_file_out_stream>
  20d0f8:	48 8d 05 e1 28 01 00 	lea    rax,[rip+0x128e1]        # 21f9e0 <FileOutStream_writeFn>
  20d0ff:	48 89 05 3a df 03 00 	mov    QWORD PTR [rip+0x3df3a],rax        # 24b040 <stderr_file_out_stream+0x8>
  20d106:	48 8d 0d 33 df 03 00 	lea    rcx,[rip+0x3df33]        # 24b040 <stderr_file_out_stream+0x8>
  20d10d:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20d110:	48 89 15 f1 2e 04 00 	mov    QWORD PTR [rip+0x42ef1],rdx        # 250008 <stderr_stream>
  20d117:	48 89 c1             	mov    rcx,rax
  20d11a:	48 89 d7             	mov    rdi,rdx
  20d11d:	c6 44 24 07 20       	mov    BYTE PTR [rsp+0x7],0x20
  20d122:	4c 89 7c 24 08       	mov    QWORD PTR [rsp+0x8],r15
  20d127:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  20d12e:	00 00 
  20d130:	4c 89 f6             	mov    rsi,r14
  20d133:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20d135:	31 c0                	xor    eax,eax
  20d137:	86 05 d3 2e 04 00    	xchg   BYTE PTR [rip+0x42ed3],al        # 250010 <stderr_mutex>
  20d13d:	3c 01                	cmp    al,0x1
    if (!ok) {
  20d13f:	0f 85 61 05 00 00    	jne    20d6a6 <BmSelf.init.setup+0xbe6>
  20d145:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20d14c:	00 00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20d150:	b0 01                	mov    al,0x1
  20d152:	86 05 b8 2e 04 00    	xchg   BYTE PTR [rip+0x42eb8],al        # 250010 <stderr_mutex>
  20d158:	84 c0                	test   al,al
  20d15a:	75 f4                	jne    20d150 <BmSelf.init.setup+0x690>
    if (stderr_stream) |st| {
  20d15c:	48 8b 3d a5 2e 04 00 	mov    rdi,QWORD PTR [rip+0x42ea5]        # 250008 <stderr_stream>
  20d163:	48 85 ff             	test   rdi,rdi
  20d166:	74 18                	je     20d180 <BmSelf.init.setup+0x6c0>
  20d168:	48 8b 0d d1 de 03 00 	mov    rcx,QWORD PTR [rip+0x3ded1]        # 24b040 <stderr_file_out_stream+0x8>
  20d16f:	eb 4c                	jmp    20d1bd <BmSelf.init.setup+0x6fd>
  20d171:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20d178:	0f 1f 84 00 00 00 00 
  20d17f:	00 
        stderr_file = try io.getStdErr();
  20d180:	c7 05 a6 de 03 00 02 	mov    DWORD PTR [rip+0x3dea6],0x2        # 24b030 <stderr_file>
  20d187:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20d18a:	48 8d 05 9f de 03 00 	lea    rax,[rip+0x3de9f]        # 24b030 <stderr_file>
  20d191:	48 89 05 a0 de 03 00 	mov    QWORD PTR [rip+0x3dea0],rax        # 24b038 <stderr_file_out_stream>
  20d198:	48 8d 05 41 28 01 00 	lea    rax,[rip+0x12841]        # 21f9e0 <FileOutStream_writeFn>
  20d19f:	48 89 05 9a de 03 00 	mov    QWORD PTR [rip+0x3de9a],rax        # 24b040 <stderr_file_out_stream+0x8>
  20d1a6:	48 8d 0d 93 de 03 00 	lea    rcx,[rip+0x3de93]        # 24b040 <stderr_file_out_stream+0x8>
  20d1ad:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20d1b0:	48 89 15 51 2e 04 00 	mov    QWORD PTR [rip+0x42e51],rdx        # 250008 <stderr_stream>
  20d1b7:	48 89 c1             	mov    rcx,rax
  20d1ba:	48 89 d7             	mov    rdi,rdx
  20d1bd:	c6 44 24 07 20       	mov    BYTE PTR [rsp+0x7],0x20
  20d1c2:	4c 89 7c 24 08       	mov    QWORD PTR [rsp+0x8],r15
  20d1c7:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  20d1ce:	00 00 
  20d1d0:	4c 89 f6             	mov    rsi,r14
  20d1d3:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20d1d5:	31 c0                	xor    eax,eax
  20d1d7:	86 05 33 2e 04 00    	xchg   BYTE PTR [rip+0x42e33],al        # 250010 <stderr_mutex>
  20d1dd:	3c 01                	cmp    al,0x1
    if (!ok) {
  20d1df:	0f 85 c1 04 00 00    	jne    20d6a6 <BmSelf.init.setup+0xbe6>
  20d1e5:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20d1ec:	00 00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20d1f0:	b0 01                	mov    al,0x1
  20d1f2:	86 05 18 2e 04 00    	xchg   BYTE PTR [rip+0x42e18],al        # 250010 <stderr_mutex>
  20d1f8:	84 c0                	test   al,al
  20d1fa:	75 f4                	jne    20d1f0 <BmSelf.init.setup+0x730>
    if (stderr_stream) |st| {
  20d1fc:	48 8b 3d 05 2e 04 00 	mov    rdi,QWORD PTR [rip+0x42e05]        # 250008 <stderr_stream>
  20d203:	48 85 ff             	test   rdi,rdi
  20d206:	74 18                	je     20d220 <BmSelf.init.setup+0x760>
  20d208:	48 8b 0d 31 de 03 00 	mov    rcx,QWORD PTR [rip+0x3de31]        # 24b040 <stderr_file_out_stream+0x8>
  20d20f:	eb 4c                	jmp    20d25d <BmSelf.init.setup+0x79d>
  20d211:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20d218:	0f 1f 84 00 00 00 00 
  20d21f:	00 
        stderr_file = try io.getStdErr();
  20d220:	c7 05 06 de 03 00 02 	mov    DWORD PTR [rip+0x3de06],0x2        # 24b030 <stderr_file>
  20d227:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20d22a:	48 8d 05 ff dd 03 00 	lea    rax,[rip+0x3ddff]        # 24b030 <stderr_file>
  20d231:	48 89 05 00 de 03 00 	mov    QWORD PTR [rip+0x3de00],rax        # 24b038 <stderr_file_out_stream>
  20d238:	48 8d 05 a1 27 01 00 	lea    rax,[rip+0x127a1]        # 21f9e0 <FileOutStream_writeFn>
  20d23f:	48 89 05 fa dd 03 00 	mov    QWORD PTR [rip+0x3ddfa],rax        # 24b040 <stderr_file_out_stream+0x8>
  20d246:	48 8d 0d f3 dd 03 00 	lea    rcx,[rip+0x3ddf3]        # 24b040 <stderr_file_out_stream+0x8>
  20d24d:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20d250:	48 89 15 b1 2d 04 00 	mov    QWORD PTR [rip+0x42db1],rdx        # 250008 <stderr_stream>
  20d257:	48 89 c1             	mov    rcx,rax
  20d25a:	48 89 d7             	mov    rdi,rdx
  20d25d:	c6 44 24 07 20       	mov    BYTE PTR [rsp+0x7],0x20
  20d262:	4c 89 7c 24 08       	mov    QWORD PTR [rsp+0x8],r15
  20d267:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  20d26e:	00 00 
  20d270:	4c 89 f6             	mov    rsi,r14
  20d273:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20d275:	31 c0                	xor    eax,eax
  20d277:	86 05 93 2d 04 00    	xchg   BYTE PTR [rip+0x42d93],al        # 250010 <stderr_mutex>
  20d27d:	3c 01                	cmp    al,0x1
    if (!ok) {
  20d27f:	0f 85 21 04 00 00    	jne    20d6a6 <BmSelf.init.setup+0xbe6>
  20d285:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20d28c:	00 00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20d290:	b0 01                	mov    al,0x1
  20d292:	86 05 78 2d 04 00    	xchg   BYTE PTR [rip+0x42d78],al        # 250010 <stderr_mutex>
  20d298:	84 c0                	test   al,al
  20d29a:	75 f4                	jne    20d290 <BmSelf.init.setup+0x7d0>
    if (stderr_stream) |st| {
  20d29c:	48 8b 3d 65 2d 04 00 	mov    rdi,QWORD PTR [rip+0x42d65]        # 250008 <stderr_stream>
  20d2a3:	48 85 ff             	test   rdi,rdi
  20d2a6:	74 18                	je     20d2c0 <BmSelf.init.setup+0x800>
  20d2a8:	48 8b 0d 91 dd 03 00 	mov    rcx,QWORD PTR [rip+0x3dd91]        # 24b040 <stderr_file_out_stream+0x8>
  20d2af:	eb 4c                	jmp    20d2fd <BmSelf.init.setup+0x83d>
  20d2b1:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20d2b8:	0f 1f 84 00 00 00 00 
  20d2bf:	00 
        stderr_file = try io.getStdErr();
  20d2c0:	c7 05 66 dd 03 00 02 	mov    DWORD PTR [rip+0x3dd66],0x2        # 24b030 <stderr_file>
  20d2c7:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20d2ca:	48 8d 05 5f dd 03 00 	lea    rax,[rip+0x3dd5f]        # 24b030 <stderr_file>
  20d2d1:	48 89 05 60 dd 03 00 	mov    QWORD PTR [rip+0x3dd60],rax        # 24b038 <stderr_file_out_stream>
  20d2d8:	48 8d 05 01 27 01 00 	lea    rax,[rip+0x12701]        # 21f9e0 <FileOutStream_writeFn>
  20d2df:	48 89 05 5a dd 03 00 	mov    QWORD PTR [rip+0x3dd5a],rax        # 24b040 <stderr_file_out_stream+0x8>
  20d2e6:	48 8d 0d 53 dd 03 00 	lea    rcx,[rip+0x3dd53]        # 24b040 <stderr_file_out_stream+0x8>
  20d2ed:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20d2f0:	48 89 15 11 2d 04 00 	mov    QWORD PTR [rip+0x42d11],rdx        # 250008 <stderr_stream>
  20d2f7:	48 89 c1             	mov    rcx,rax
  20d2fa:	48 89 d7             	mov    rdi,rdx
  20d2fd:	c6 44 24 07 20       	mov    BYTE PTR [rsp+0x7],0x20
  20d302:	4c 89 7c 24 08       	mov    QWORD PTR [rsp+0x8],r15
  20d307:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  20d30e:	00 00 
  20d310:	4c 89 f6             	mov    rsi,r14
  20d313:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20d315:	31 c0                	xor    eax,eax
  20d317:	86 05 f3 2c 04 00    	xchg   BYTE PTR [rip+0x42cf3],al        # 250010 <stderr_mutex>
  20d31d:	3c 01                	cmp    al,0x1
    if (!ok) {
  20d31f:	0f 85 81 03 00 00    	jne    20d6a6 <BmSelf.init.setup+0xbe6>
  20d325:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20d32c:	00 00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20d330:	b0 01                	mov    al,0x1
  20d332:	86 05 d8 2c 04 00    	xchg   BYTE PTR [rip+0x42cd8],al        # 250010 <stderr_mutex>
  20d338:	84 c0                	test   al,al
  20d33a:	75 f4                	jne    20d330 <BmSelf.init.setup+0x870>
    if (stderr_stream) |st| {
  20d33c:	48 8b 3d c5 2c 04 00 	mov    rdi,QWORD PTR [rip+0x42cc5]        # 250008 <stderr_stream>
  20d343:	48 85 ff             	test   rdi,rdi
  20d346:	74 18                	je     20d360 <BmSelf.init.setup+0x8a0>
  20d348:	48 8b 0d f1 dc 03 00 	mov    rcx,QWORD PTR [rip+0x3dcf1]        # 24b040 <stderr_file_out_stream+0x8>
  20d34f:	eb 4c                	jmp    20d39d <BmSelf.init.setup+0x8dd>
  20d351:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20d358:	0f 1f 84 00 00 00 00 
  20d35f:	00 
        stderr_file = try io.getStdErr();
  20d360:	c7 05 c6 dc 03 00 02 	mov    DWORD PTR [rip+0x3dcc6],0x2        # 24b030 <stderr_file>
  20d367:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20d36a:	48 8d 05 bf dc 03 00 	lea    rax,[rip+0x3dcbf]        # 24b030 <stderr_file>
  20d371:	48 89 05 c0 dc 03 00 	mov    QWORD PTR [rip+0x3dcc0],rax        # 24b038 <stderr_file_out_stream>
  20d378:	48 8d 05 61 26 01 00 	lea    rax,[rip+0x12661]        # 21f9e0 <FileOutStream_writeFn>
  20d37f:	48 89 05 ba dc 03 00 	mov    QWORD PTR [rip+0x3dcba],rax        # 24b040 <stderr_file_out_stream+0x8>
  20d386:	48 8d 0d b3 dc 03 00 	lea    rcx,[rip+0x3dcb3]        # 24b040 <stderr_file_out_stream+0x8>
  20d38d:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20d390:	48 89 15 71 2c 04 00 	mov    QWORD PTR [rip+0x42c71],rdx        # 250008 <stderr_stream>
  20d397:	48 89 c1             	mov    rcx,rax
  20d39a:	48 89 d7             	mov    rdi,rdx
  20d39d:	c6 44 24 07 20       	mov    BYTE PTR [rsp+0x7],0x20
  20d3a2:	4c 89 7c 24 08       	mov    QWORD PTR [rsp+0x8],r15
  20d3a7:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  20d3ae:	00 00 
  20d3b0:	4c 89 f6             	mov    rsi,r14
  20d3b3:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20d3b5:	31 c0                	xor    eax,eax
  20d3b7:	86 05 53 2c 04 00    	xchg   BYTE PTR [rip+0x42c53],al        # 250010 <stderr_mutex>
  20d3bd:	3c 01                	cmp    al,0x1
    if (!ok) {
  20d3bf:	0f 85 e1 02 00 00    	jne    20d6a6 <BmSelf.init.setup+0xbe6>
  20d3c5:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20d3cc:	00 00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20d3d0:	b0 01                	mov    al,0x1
  20d3d2:	86 05 38 2c 04 00    	xchg   BYTE PTR [rip+0x42c38],al        # 250010 <stderr_mutex>
  20d3d8:	84 c0                	test   al,al
  20d3da:	75 f4                	jne    20d3d0 <BmSelf.init.setup+0x910>
    if (stderr_stream) |st| {
  20d3dc:	48 8b 3d 25 2c 04 00 	mov    rdi,QWORD PTR [rip+0x42c25]        # 250008 <stderr_stream>
  20d3e3:	48 85 ff             	test   rdi,rdi
  20d3e6:	74 18                	je     20d400 <BmSelf.init.setup+0x940>
  20d3e8:	48 8b 0d 51 dc 03 00 	mov    rcx,QWORD PTR [rip+0x3dc51]        # 24b040 <stderr_file_out_stream+0x8>
  20d3ef:	eb 4c                	jmp    20d43d <BmSelf.init.setup+0x97d>
  20d3f1:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20d3f8:	0f 1f 84 00 00 00 00 
  20d3ff:	00 
        stderr_file = try io.getStdErr();
  20d400:	c7 05 26 dc 03 00 02 	mov    DWORD PTR [rip+0x3dc26],0x2        # 24b030 <stderr_file>
  20d407:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20d40a:	48 8d 05 1f dc 03 00 	lea    rax,[rip+0x3dc1f]        # 24b030 <stderr_file>
  20d411:	48 89 05 20 dc 03 00 	mov    QWORD PTR [rip+0x3dc20],rax        # 24b038 <stderr_file_out_stream>
  20d418:	48 8d 05 c1 25 01 00 	lea    rax,[rip+0x125c1]        # 21f9e0 <FileOutStream_writeFn>
  20d41f:	48 89 05 1a dc 03 00 	mov    QWORD PTR [rip+0x3dc1a],rax        # 24b040 <stderr_file_out_stream+0x8>
  20d426:	48 8d 0d 13 dc 03 00 	lea    rcx,[rip+0x3dc13]        # 24b040 <stderr_file_out_stream+0x8>
  20d42d:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20d430:	48 89 15 d1 2b 04 00 	mov    QWORD PTR [rip+0x42bd1],rdx        # 250008 <stderr_stream>
  20d437:	48 89 c1             	mov    rcx,rax
  20d43a:	48 89 d7             	mov    rdi,rdx
  20d43d:	c6 44 24 07 20       	mov    BYTE PTR [rsp+0x7],0x20
  20d442:	4c 89 7c 24 08       	mov    QWORD PTR [rsp+0x8],r15
  20d447:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  20d44e:	00 00 
  20d450:	4c 89 f6             	mov    rsi,r14
  20d453:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20d455:	31 c0                	xor    eax,eax
  20d457:	86 05 b3 2b 04 00    	xchg   BYTE PTR [rip+0x42bb3],al        # 250010 <stderr_mutex>
  20d45d:	3c 01                	cmp    al,0x1
    if (!ok) {
  20d45f:	0f 85 41 02 00 00    	jne    20d6a6 <BmSelf.init.setup+0xbe6>
  20d465:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20d46c:	00 00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20d470:	b0 01                	mov    al,0x1
  20d472:	86 05 98 2b 04 00    	xchg   BYTE PTR [rip+0x42b98],al        # 250010 <stderr_mutex>
  20d478:	84 c0                	test   al,al
  20d47a:	75 f4                	jne    20d470 <BmSelf.init.setup+0x9b0>
    if (stderr_stream) |st| {
  20d47c:	48 8b 3d 85 2b 04 00 	mov    rdi,QWORD PTR [rip+0x42b85]        # 250008 <stderr_stream>
  20d483:	48 85 ff             	test   rdi,rdi
  20d486:	74 18                	je     20d4a0 <BmSelf.init.setup+0x9e0>
  20d488:	48 8b 0d b1 db 03 00 	mov    rcx,QWORD PTR [rip+0x3dbb1]        # 24b040 <stderr_file_out_stream+0x8>
  20d48f:	eb 4c                	jmp    20d4dd <BmSelf.init.setup+0xa1d>
  20d491:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20d498:	0f 1f 84 00 00 00 00 
  20d49f:	00 
        stderr_file = try io.getStdErr();
  20d4a0:	c7 05 86 db 03 00 02 	mov    DWORD PTR [rip+0x3db86],0x2        # 24b030 <stderr_file>
  20d4a7:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20d4aa:	48 8d 05 7f db 03 00 	lea    rax,[rip+0x3db7f]        # 24b030 <stderr_file>
  20d4b1:	48 89 05 80 db 03 00 	mov    QWORD PTR [rip+0x3db80],rax        # 24b038 <stderr_file_out_stream>
  20d4b8:	48 8d 05 21 25 01 00 	lea    rax,[rip+0x12521]        # 21f9e0 <FileOutStream_writeFn>
  20d4bf:	48 89 05 7a db 03 00 	mov    QWORD PTR [rip+0x3db7a],rax        # 24b040 <stderr_file_out_stream+0x8>
  20d4c6:	48 8d 0d 73 db 03 00 	lea    rcx,[rip+0x3db73]        # 24b040 <stderr_file_out_stream+0x8>
  20d4cd:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20d4d0:	48 89 15 31 2b 04 00 	mov    QWORD PTR [rip+0x42b31],rdx        # 250008 <stderr_stream>
  20d4d7:	48 89 c1             	mov    rcx,rax
  20d4da:	48 89 d7             	mov    rdi,rdx
                const casted_value = ([]const u8)(value);
  20d4dd:	4c 89 64 24 08       	mov    QWORD PTR [rsp+0x8],r12
  20d4e2:	48 c7 44 24 10 04 00 	mov    QWORD PTR [rsp+0x10],0x4
  20d4e9:	00 00 
                return output(context, casted_value);
  20d4eb:	4c 89 f6             	mov    rsi,r14
  20d4ee:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20d4f0:	31 c0                	xor    eax,eax
  20d4f2:	86 05 18 2b 04 00    	xchg   BYTE PTR [rip+0x42b18],al        # 250010 <stderr_mutex>
  20d4f8:	3c 01                	cmp    al,0x1
    if (!ok) {
  20d4fa:	0f 85 a6 01 00 00    	jne    20d6a6 <BmSelf.init.setup+0xbe6>
                try rightJustified(18, "{}", "time/operation");
  20d500:	e8 5b 8f 00 00       	call   216460 <Benchmark_rightJustified.38>
  20d505:	66 85 c0             	test   ax,ax
  20d508:	0f 85 86 01 00 00    	jne    20d694 <BmSelf.init.setup+0xbd4>
  20d50e:	66 90                	xchg   ax,ax
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20d510:	b0 01                	mov    al,0x1
  20d512:	86 05 f8 2a 04 00    	xchg   BYTE PTR [rip+0x42af8],al        # 250010 <stderr_mutex>
  20d518:	84 c0                	test   al,al
  20d51a:	75 f4                	jne    20d510 <BmSelf.init.setup+0xa50>
    if (stderr_stream) |st| {
  20d51c:	48 8b 3d e5 2a 04 00 	mov    rdi,QWORD PTR [rip+0x42ae5]        # 250008 <stderr_stream>
  20d523:	48 85 ff             	test   rdi,rdi
  20d526:	74 18                	je     20d540 <BmSelf.init.setup+0xa80>
  20d528:	48 8b 0d 11 db 03 00 	mov    rcx,QWORD PTR [rip+0x3db11]        # 24b040 <stderr_file_out_stream+0x8>
  20d52f:	eb 4c                	jmp    20d57d <BmSelf.init.setup+0xabd>
  20d531:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20d538:	0f 1f 84 00 00 00 00 
  20d53f:	00 
        stderr_file = try io.getStdErr();
  20d540:	c7 05 e6 da 03 00 02 	mov    DWORD PTR [rip+0x3dae6],0x2        # 24b030 <stderr_file>
  20d547:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20d54a:	48 8d 05 df da 03 00 	lea    rax,[rip+0x3dadf]        # 24b030 <stderr_file>
  20d551:	48 89 05 e0 da 03 00 	mov    QWORD PTR [rip+0x3dae0],rax        # 24b038 <stderr_file_out_stream>
  20d558:	48 8d 05 81 24 01 00 	lea    rax,[rip+0x12481]        # 21f9e0 <FileOutStream_writeFn>
  20d55f:	48 89 05 da da 03 00 	mov    QWORD PTR [rip+0x3dada],rax        # 24b040 <stderr_file_out_stream+0x8>
  20d566:	48 8d 0d d3 da 03 00 	lea    rcx,[rip+0x3dad3]        # 24b040 <stderr_file_out_stream+0x8>
  20d56d:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20d570:	48 89 15 91 2a 04 00 	mov    QWORD PTR [rip+0x42a91],rdx        # 250008 <stderr_stream>
  20d577:	48 89 c1             	mov    rcx,rax
  20d57a:	48 89 d7             	mov    rdi,rdx
        try output(context, fmt[start_index..]);
  20d57d:	48 8d 35 94 18 04 00 	lea    rsi,[rip+0x41894]        # 24ee18 <__unnamed_3>
  20d584:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20d586:	31 c0                	xor    eax,eax
  20d588:	86 05 82 2a 04 00    	xchg   BYTE PTR [rip+0x42a82],al        # 250010 <stderr_mutex>
  20d58e:	3c 01                	cmp    al,0x1
    if (!ok) {
  20d590:	0f 85 10 01 00 00    	jne    20d6a6 <BmSelf.init.setup+0xbe6>
            try pSelf.report(pSelf.results.items[pSelf.results.len - 1]); warn("\n");
  20d596:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  20d59b:	48 8b 4c 24 78       	mov    rcx,QWORD PTR [rsp+0x78]
  20d5a0:	48 c1 e1 04          	shl    rcx,0x4
  20d5a4:	48 8d 34 08          	lea    rsi,[rax+rcx*1]
  20d5a8:	48 83 c6 f0          	add    rsi,0xfffffffffffffff0
  20d5ac:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  20d5b1:	e8 aa 64 00 00       	call   213a60 <Benchmark_report>
  20d5b6:	66 85 c0             	test   ax,ax
  20d5b9:	0f 85 d5 00 00 00    	jne    20d694 <BmSelf.init.setup+0xbd4>
  20d5bf:	48 83 c5 01          	add    rbp,0x1
  20d5c3:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20d5ca:	84 00 00 00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20d5d0:	b0 01                	mov    al,0x1
  20d5d2:	86 05 38 2a 04 00    	xchg   BYTE PTR [rip+0x42a38],al        # 250010 <stderr_mutex>
  20d5d8:	84 c0                	test   al,al
  20d5da:	75 f4                	jne    20d5d0 <BmSelf.init.setup+0xb10>
    if (stderr_stream) |st| {
  20d5dc:	48 8b 3d 25 2a 04 00 	mov    rdi,QWORD PTR [rip+0x42a25]        # 250008 <stderr_stream>
  20d5e3:	48 85 ff             	test   rdi,rdi
  20d5e6:	74 18                	je     20d600 <BmSelf.init.setup+0xb40>
  20d5e8:	48 8b 0d 51 da 03 00 	mov    rcx,QWORD PTR [rip+0x3da51]        # 24b040 <stderr_file_out_stream+0x8>
  20d5ef:	eb 4c                	jmp    20d63d <BmSelf.init.setup+0xb7d>
  20d5f1:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20d5f8:	0f 1f 84 00 00 00 00 
  20d5ff:	00 
        stderr_file = try io.getStdErr();
  20d600:	c7 05 26 da 03 00 02 	mov    DWORD PTR [rip+0x3da26],0x2        # 24b030 <stderr_file>
  20d607:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20d60a:	48 8d 05 1f da 03 00 	lea    rax,[rip+0x3da1f]        # 24b030 <stderr_file>
  20d611:	48 89 05 20 da 03 00 	mov    QWORD PTR [rip+0x3da20],rax        # 24b038 <stderr_file_out_stream>
  20d618:	48 8d 05 c1 23 01 00 	lea    rax,[rip+0x123c1]        # 21f9e0 <FileOutStream_writeFn>
  20d61f:	48 89 05 1a da 03 00 	mov    QWORD PTR [rip+0x3da1a],rax        # 24b040 <stderr_file_out_stream+0x8>
  20d626:	48 8d 0d 13 da 03 00 	lea    rcx,[rip+0x3da13]        # 24b040 <stderr_file_out_stream+0x8>
  20d62d:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20d630:	48 89 15 d1 29 04 00 	mov    QWORD PTR [rip+0x429d1],rdx        # 250008 <stderr_stream>
  20d637:	48 89 c1             	mov    rcx,rax
  20d63a:	48 89 d7             	mov    rdi,rdx
  20d63d:	48 8d 35 d4 17 04 00 	lea    rsi,[rip+0x417d4]        # 24ee18 <__unnamed_3>
  20d644:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20d646:	31 c0                	xor    eax,eax
  20d648:	86 05 c2 29 04 00    	xchg   BYTE PTR [rip+0x429c2],al        # 250010 <stderr_mutex>
  20d64e:	3c 01                	cmp    al,0x1
    if (!ok) {
  20d650:	75 54                	jne    20d6a6 <BmSelf.init.setup+0xbe6>
        while (rep < pSelf.repetitions) : (rep += 1) {
  20d652:	48 3b 6c 24 40       	cmp    rbp,QWORD PTR [rsp+0x40]
  20d657:	0f 82 93 f8 ff ff    	jb     20cef0 <BmSelf.init.setup+0x430>
  20d65d:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
        try pSelf.reportStats(pSelf.results);
  20d662:	48 8d 74 24 68       	lea    rsi,[rsp+0x68]
  20d667:	e8 d4 90 00 00       	call   216740 <Benchmark_reportStats>
  20d66c:	66 85 c0             	test   ax,ax
  20d66f:	75 23                	jne    20d694 <BmSelf.init.setup+0xbd4>
    var bmSelf = try bm.run(BmSelf);
    assert(bmSelf.init_count == 1);
    assert(bmSelf.setup_count == 3);
  20d671:	48 83 fd 03          	cmp    rbp,0x3
  20d675:	75 2f                	jne    20d6a6 <BmSelf.init.setup+0xbe6>
    assert(bmSelf.benchmark_count > 1000000);
  20d677:	49 81 fd 40 42 0f 00 	cmp    r13,0xf4240
  20d67e:	76 26                	jbe    20d6a6 <BmSelf.init.setup+0xbe6>
  20d680:	31 c0                	xor    eax,eax
  20d682:	eb 10                	jmp    20d694 <BmSelf.init.setup+0xbd4>
                switch (errno) {
  20d684:	48 83 f9 16          	cmp    rcx,0x16
  20d688:	75 06                	jne    20d690 <BmSelf.init.setup+0xbd0>
  20d68a:	66 b8 02 00          	mov    ax,0x2
  20d68e:	eb 04                	jmp    20d694 <BmSelf.init.setup+0xbd4>
  20d690:	66 b8 03 00          	mov    ax,0x3
    var bmSelf = try bm.run(BmSelf);
  20d694:	48 81 c4 f8 00 00 00 	add    rsp,0xf8
  20d69b:	5b                   	pop    rbx
  20d69c:	41 5c                	pop    r12
  20d69e:	41 5d                	pop    r13
  20d6a0:	41 5e                	pop    r14
  20d6a2:	41 5f                	pop    r15
  20d6a4:	5d                   	pop    rbp
  20d6a5:	c3                   	ret    
            @panic("assertion failure");
  20d6a6:	48 8d 3d 5b 16 04 00 	lea    rdi,[rip+0x4165b]        # 24ed08 <__unnamed_2>
  20d6ad:	e8 6e 49 00 00       	call   212020 <panic>
  20d6b2:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20d6b9:	1f 84 00 00 00 00 00 

000000000020d6c0 <BmSelf.init.setup.tearDown.AtomicRmwOp.Add>:
    assert(bmSelf.tearDown_count == 0);
}

// Measure @atomicRmw Add operation
test "BmSelf.init.setup.tearDown.AtomicRmwOp.Add" {
  20d6c0:	55                   	push   rbp
  20d6c1:	41 57                	push   r15
  20d6c3:	41 56                	push   r14
  20d6c5:	41 55                	push   r13
  20d6c7:	41 54                	push   r12
  20d6c9:	53                   	push   rbx
  20d6ca:	48 81 ec 18 01 00 00 	sub    rsp,0x118
  20d6d1:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20d6d8:	0f 1f 84 00 00 00 00 
  20d6df:	00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20d6e0:	b0 01                	mov    al,0x1
  20d6e2:	86 05 28 29 04 00    	xchg   BYTE PTR [rip+0x42928],al        # 250010 <stderr_mutex>
  20d6e8:	84 c0                	test   al,al
  20d6ea:	75 f4                	jne    20d6e0 <BmSelf.init.setup.tearDown.AtomicRmwOp.Add+0x20>
    if (stderr_stream) |st| {
  20d6ec:	48 8b 3d 15 29 04 00 	mov    rdi,QWORD PTR [rip+0x42915]        # 250008 <stderr_stream>
  20d6f3:	48 85 ff             	test   rdi,rdi
  20d6f6:	74 09                	je     20d701 <BmSelf.init.setup.tearDown.AtomicRmwOp.Add+0x41>
  20d6f8:	48 8b 05 41 d9 03 00 	mov    rax,QWORD PTR [rip+0x3d941]        # 24b040 <stderr_file_out_stream+0x8>
  20d6ff:	eb 34                	jmp    20d735 <BmSelf.init.setup.tearDown.AtomicRmwOp.Add+0x75>
        stderr_file = try io.getStdErr();
  20d701:	48 8d 05 28 d9 03 00 	lea    rax,[rip+0x3d928]        # 24b030 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20d708:	48 89 05 29 d9 03 00 	mov    QWORD PTR [rip+0x3d929],rax        # 24b038 <stderr_file_out_stream>
  20d70f:	48 8d 05 ca 22 01 00 	lea    rax,[rip+0x122ca]        # 21f9e0 <FileOutStream_writeFn>
  20d716:	48 89 05 23 d9 03 00 	mov    QWORD PTR [rip+0x3d923],rax        # 24b040 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  20d71d:	c7 05 09 d9 03 00 02 	mov    DWORD PTR [rip+0x3d909],0x2        # 24b030 <stderr_file>
  20d724:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20d727:	48 8d 3d 12 d9 03 00 	lea    rdi,[rip+0x3d912]        # 24b040 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  20d72e:	48 89 3d d3 28 04 00 	mov    QWORD PTR [rip+0x428d3],rdi        # 250008 <stderr_stream>
  20d735:	48 8d 35 dc 16 04 00 	lea    rsi,[rip+0x416dc]        # 24ee18 <__unnamed_3>
  20d73c:	ff d0                	call   rax
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20d73e:	31 c0                	xor    eax,eax
  20d740:	86 05 ca 28 04 00    	xchg   BYTE PTR [rip+0x428ca],al        # 250010 <stderr_mutex>
  20d746:	3c 01                	cmp    al,0x1
    if (!ok) {
  20d748:	0f 85 86 0b 00 00    	jne    20e2d4 <BmSelf.init.setup.tearDown.AtomicRmwOp.Add+0xc14>
    // Since this is a test print a \n before we run
    warn("\n");

    // Test fn benchmark(pSelf) can return an error
    var bm = Benchmark.init("BmEmpty.error", std.debug.global_allocator);
  20d74e:	c5 f8 10 05 a2 15 04 	vmovups xmm0,XMMWORD PTR [rip+0x415a2]        # 24ecf8 <__unnamed_9>
  20d755:	00 
  20d756:	c5 f8 29 44 24 40    	vmovaps XMMWORD PTR [rsp+0x40],xmm0
  20d75c:	48 b8 00 e8 76 48 17 	movabs rax,0x174876e800
  20d763:	00 00 00 
  20d766:	b9 00 65 cd 1d       	mov    ecx,0x1dcd6500
  20d76b:	c4 e1 f9 6e c1       	vmovq  xmm0,rcx
  20d770:	c5 f9 73 f8 08       	vpslldq xmm0,xmm0,0x8
  20d775:	c5 f9 7f 44 24 50    	vmovdqa XMMWORD PTR [rsp+0x50],xmm0
  20d77b:	48 89 44 24 68       	mov    QWORD PTR [rsp+0x68],rax
  20d780:	c5 f8 10 05 38 b6 ff 	vmovups xmm0,XMMWORD PTR [rip+0xffffffffffffb638]        # 208dc0 <__unnamed_5>
  20d787:	ff 
  20d788:	c5 f8 29 44 24 70    	vmovaps XMMWORD PTR [rsp+0x70],xmm0
  20d78e:	48 8d 0d 6b d8 03 00 	lea    rcx,[rip+0x3d86b]        # 24b000 <global_fixed_allocator>
  20d795:	48 89 8c 24 80 00 00 	mov    QWORD PTR [rsp+0x80],rcx
  20d79c:	00 
  20d79d:	c5 f8 57 c0          	vxorps xmm0,xmm0,xmm0
  20d7a1:	c5 f8 11 84 24 88 00 	vmovups XMMWORD PTR [rsp+0x88],xmm0
  20d7a8:	00 00 
  20d7aa:	48 c7 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],0x0
  20d7b1:	00 00 00 00 00 
  20d7b6:	48 89 8c 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rcx
  20d7bd:	00 
        fn tearDown(pSelf: *Self) void {
            pSelf.tearDown_count += 1;
        }
    };

    bm.repetitions = 10;
  20d7be:	48 c7 44 24 60 0a 00 	mov    QWORD PTR [rsp+0x60],0xa
  20d7c5:	00 00 
                bm = T.init();
  20d7c7:	c5 fe 6f 05 b1 2a ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffff2ab1]        # 200280 <__unnamed_10>
  20d7ce:	ff 
  20d7cf:	c5 fe 7f 44 24 20    	vmovdqu YMMWORD PTR [rsp+0x20],ymm0
  20d7d5:	41 b6 01             	mov    r14b,0x1
  20d7d8:	bb 01 00 00 00       	mov    ebx,0x1
  20d7dd:	4c 8d a4 24 b0 00 00 	lea    r12,[rsp+0xb0]
  20d7e4:	00 
  20d7e5:	48 8d 2d 2c 16 04 00 	lea    rbp,[rip+0x4162c]        # 24ee18 <__unnamed_3>
            pSelf.setup_count += 1;
  20d7ec:	31 c9                	xor    ecx,ecx
  20d7ee:	45 31 ed             	xor    r13d,r13d
  20d7f1:	48 83 c1 01          	add    rcx,0x1
  20d7f5:	48 89 4c 24 28       	mov    QWORD PTR [rsp+0x28],rcx
            while (iterations <= pSelf.max_iterations) {
  20d7fa:	48 39 c3             	cmp    rbx,rax
  20d7fd:	0f 87 b1 03 00 00    	ja     20dbb4 <BmSelf.init.setup.tearDown.AtomicRmwOp.Add+0x4f4>
  20d803:	eb 19                	jmp    20d81e <BmSelf.init.setup.tearDown.AtomicRmwOp.Add+0x15e>
  20d805:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20d80c:	00 00 00 00 
                        warn("iteratons:{} numer:{} denom:{}\n", iterations, numer, denom);
  20d810:	48 89 df             	mov    rdi,rbx
  20d813:	48 89 ca             	mov    rdx,rcx
  20d816:	c5 f8 77             	vzeroupper 
  20d819:	e8 52 83 00 00       	call   215b70 <warn.36>
                var ts: posix.timespec = undefined;
  20d81e:	c5 fa 6f 05 9a b5 ff 	vmovdqu xmm0,XMMWORD PTR [rip+0xffffffffffffb59a]        # 208dc0 <__unnamed_5>
  20d825:	ff 
  20d826:	c5 f9 7f 84 24 b0 00 	vmovdqa XMMWORD PTR [rsp+0xb0],xmm0
  20d82d:	00 00 
  20d82f:	b8 e5 00 00 00       	mov    eax,0xe5
  20d834:	bf 01 00 00 00       	mov    edi,0x1
  20d839:	4c 89 e6             	mov    rsi,r12
  20d83c:	0f 05                	syscall 
  20d83e:	48 89 c1             	mov    rcx,rax
  20d841:	48 f7 d9             	neg    rcx
  20d844:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  20d84a:	b8 00 00 00 00       	mov    eax,0x0
  20d84f:	48 0f 46 c8          	cmovbe rcx,rax
                switch (errno) {
  20d853:	48 85 c9             	test   rcx,rcx
  20d856:	0f 85 53 0a 00 00    	jne    20e2af <BmSelf.init.setup.tearDown.AtomicRmwOp.Add+0xbef>
        const f = @atomicLoad(@typeOf(init_vdso_clock_gettime), &vdso_clock_gettime, builtin.AtomicOrder.Unordered);
  20d85c:	48 8b 05 e5 d7 03 00 	mov    rax,QWORD PTR [rip+0x3d7e5]        # 24b048 <vdso_clock_gettime>
        if (@ptrToInt(f) != 0) {
  20d863:	48 85 c0             	test   rax,rax
  20d866:	74 24                	je     20d88c <BmSelf.init.setup.tearDown.AtomicRmwOp.Add+0x1cc>
            const rc = f(clk_id, tp);
  20d868:	bf 01 00 00 00       	mov    edi,0x1
  20d86d:	4c 89 e6             	mov    rsi,r12
  20d870:	c5 f8 77             	vzeroupper 
  20d873:	ff d0                	call   rax
            switch (rc) {
  20d875:	48 83 f8 ea          	cmp    rax,0xffffffffffffffea
  20d879:	0f 84 b1 02 00 00    	je     20db30 <BmSelf.init.setup.tearDown.AtomicRmwOp.Add+0x470>
  20d87f:	48 85 c0             	test   rax,rax
  20d882:	c5 fa 6f 05 36 b5 ff 	vmovdqu xmm0,XMMWORD PTR [rip+0xffffffffffffb536]        # 208dc0 <__unnamed_5>
  20d889:	ff 
  20d88a:	74 0f                	je     20d89b <BmSelf.init.setup.tearDown.AtomicRmwOp.Add+0x1db>
  20d88c:	b8 e4 00 00 00       	mov    eax,0xe4
  20d891:	bf 01 00 00 00       	mov    edi,0x1
  20d896:	4c 89 e6             	mov    rsi,r12
  20d899:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  20d89b:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
                if (errno != 0) return std.os.unexpectedErrorPosix(errno);
  20d8a1:	0f 83 14 0a 00 00    	jae    20e2bb <BmSelf.init.setup.tearDown.AtomicRmwOp.Add+0xbfb>
                self.start_time = @intCast(u64, ts.tv_sec) * u64(ns_per_s) + @intCast(u64, ts.tv_nsec);
  20d8a7:	c5 f9 6f 8c 24 b0 00 	vmovdqa xmm1,XMMWORD PTR [rsp+0xb0]
  20d8ae:	00 00 
        while (iter > 0) : (iter -= 1) {
  20d8b0:	48 85 db             	test   rbx,rbx
  20d8b3:	0f 84 8d 00 00 00    	je     20d946 <BmSelf.init.setup.tearDown.AtomicRmwOp.Add+0x286>
            _ = @atomicRmw(u64, &pSelf.benchmark_count, AtomicRmwOp.Add, 1, AtomicOrder.Release);
  20d8b9:	48 8d 4b ff          	lea    rcx,[rbx-0x1]
  20d8bd:	48 89 da             	mov    rdx,rbx
  20d8c0:	48 89 d8             	mov    rax,rbx
  20d8c3:	48 83 e2 07          	and    rdx,0x7
  20d8c7:	74 1b                	je     20d8e4 <BmSelf.init.setup.tearDown.AtomicRmwOp.Add+0x224>
  20d8c9:	48 f7 da             	neg    rdx
  20d8cc:	48 89 d8             	mov    rax,rbx
  20d8cf:	90                   	nop
  20d8d0:	f0 48 81 44 24 30 01 	lock add QWORD PTR [rsp+0x30],0x1
  20d8d7:	00 00 00 
        while (iter > 0) : (iter -= 1) {
  20d8da:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  20d8de:	48 83 c2 01          	add    rdx,0x1
  20d8e2:	75 ec                	jne    20d8d0 <BmSelf.init.setup.tearDown.AtomicRmwOp.Add+0x210>
            _ = @atomicRmw(u64, &pSelf.benchmark_count, AtomicRmwOp.Add, 1, AtomicOrder.Release);
  20d8e4:	48 83 f9 07          	cmp    rcx,0x7
  20d8e8:	72 5c                	jb     20d946 <BmSelf.init.setup.tearDown.AtomicRmwOp.Add+0x286>
  20d8ea:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  20d8f0:	f0 48 81 44 24 30 01 	lock add QWORD PTR [rsp+0x30],0x1
  20d8f7:	00 00 00 
  20d8fa:	f0 48 81 44 24 30 01 	lock add QWORD PTR [rsp+0x30],0x1
  20d901:	00 00 00 
  20d904:	f0 48 81 44 24 30 01 	lock add QWORD PTR [rsp+0x30],0x1
  20d90b:	00 00 00 
  20d90e:	f0 48 81 44 24 30 01 	lock add QWORD PTR [rsp+0x30],0x1
  20d915:	00 00 00 
  20d918:	f0 48 81 44 24 30 01 	lock add QWORD PTR [rsp+0x30],0x1
  20d91f:	00 00 00 
  20d922:	f0 48 81 44 24 30 01 	lock add QWORD PTR [rsp+0x30],0x1
  20d929:	00 00 00 
  20d92c:	f0 48 81 44 24 30 01 	lock add QWORD PTR [rsp+0x30],0x1
  20d933:	00 00 00 
  20d936:	f0 48 81 44 24 30 01 	lock add QWORD PTR [rsp+0x30],0x1
  20d93d:	00 00 00 
        while (iter > 0) : (iter -= 1) {
  20d940:	48 83 c0 f8          	add    rax,0xfffffffffffffff8
  20d944:	75 aa                	jne    20d8f0 <BmSelf.init.setup.tearDown.AtomicRmwOp.Add+0x230>
        var ts: posix.timespec = undefined;
  20d946:	c5 f9 7f 84 24 b0 00 	vmovdqa XMMWORD PTR [rsp+0xb0],xmm0
  20d94d:	00 00 
        const f = @atomicLoad(@typeOf(init_vdso_clock_gettime), &vdso_clock_gettime, builtin.AtomicOrder.Unordered);
  20d94f:	48 8b 05 f2 d6 03 00 	mov    rax,QWORD PTR [rip+0x3d6f2]        # 24b048 <vdso_clock_gettime>
        if (@ptrToInt(f) != 0) {
  20d956:	48 85 c0             	test   rax,rax
  20d959:	74 2e                	je     20d989 <BmSelf.init.setup.tearDown.AtomicRmwOp.Add+0x2c9>
  20d95b:	c5 f9 7f 8c 24 e0 00 	vmovdqa XMMWORD PTR [rsp+0xe0],xmm1
  20d962:	00 00 
            const rc = f(clk_id, tp);
  20d964:	bf 01 00 00 00       	mov    edi,0x1
  20d969:	4c 89 e6             	mov    rsi,r12
  20d96c:	c5 f8 77             	vzeroupper 
  20d96f:	ff d0                	call   rax
            switch (rc) {
  20d971:	48 83 f8 ea          	cmp    rax,0xffffffffffffffea
  20d975:	0f 84 ce 01 00 00    	je     20db49 <BmSelf.init.setup.tearDown.AtomicRmwOp.Add+0x489>
  20d97b:	48 85 c0             	test   rax,rax
  20d97e:	c5 f9 6f 8c 24 e0 00 	vmovdqa xmm1,XMMWORD PTR [rsp+0xe0]
  20d985:	00 00 
  20d987:	74 0f                	je     20d998 <BmSelf.init.setup.tearDown.AtomicRmwOp.Add+0x2d8>
  20d989:	b8 e4 00 00 00       	mov    eax,0xe4
  20d98e:	bf 01 00 00 00       	mov    edi,0x1
  20d993:	4c 89 e6             	mov    rsi,r12
  20d996:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  20d998:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
  20d99e:	0f 83 30 09 00 00    	jae    20e2d4 <BmSelf.init.setup.tearDown.AtomicRmwOp.Add+0xc14>
        return @intCast(u64, ts.tv_sec) * u64(ns_per_s) + @intCast(u64, ts.tv_nsec);
  20d9a4:	c5 f9 6f 84 24 b0 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0xb0]
  20d9ab:	00 00 
  20d9ad:	c5 f9 fb c1          	vpsubq xmm0,xmm0,xmm1
  20d9b1:	c4 e1 f9 7e c0       	vmovq  rax,xmm0
        var clock = clockNative() - self.start_time;
  20d9b6:	c4 c3 f9 16 c7 01    	vpextrq r15,xmm0,0x1
  20d9bc:	48 69 c0 00 ca 9a 3b 	imul   rax,rax,0x3b9aca00
  20d9c3:	49 01 c7             	add    r15,rax
                if ((run_time_ns >= pSelf.min_runtime_ns) or (iterations >= pSelf.max_iterations)) {
  20d9c6:	4c 3b 7c 24 58       	cmp    r15,QWORD PTR [rsp+0x58]
  20d9cb:	0f 83 92 01 00 00    	jae    20db63 <BmSelf.init.setup.tearDown.AtomicRmwOp.Add+0x4a3>
  20d9d1:	48 3b 5c 24 68       	cmp    rbx,QWORD PTR [rsp+0x68]
  20d9d6:	0f 83 87 01 00 00    	jae    20db63 <BmSelf.init.setup.tearDown.AtomicRmwOp.Add+0x4a3>
                    if (pSelf.logl >= 1) {
  20d9dc:	48 83 7c 24 50 00    	cmp    QWORD PTR [rsp+0x50],0x0
  20d9e2:	0f 84 ba 00 00 00    	je     20daa2 <BmSelf.init.setup.tearDown.AtomicRmwOp.Add+0x3e2>
                            Result {.run_time_ns = run_time_ns, .iterations = iterations});
  20d9e8:	4c 89 bc 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],r15
  20d9ef:	00 
  20d9f0:	48 89 9c 24 00 01 00 	mov    QWORD PTR [rsp+0x100],rbx
  20d9f7:	00 
                        try pSelf.report(
  20d9f8:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  20d9fd:	48 8d b4 24 f8 00 00 	lea    rsi,[rsp+0xf8]
  20da04:	00 
  20da05:	c5 f8 77             	vzeroupper 
  20da08:	e8 53 60 00 00       	call   213a60 <Benchmark_report>
  20da0d:	66 85 c0             	test   ax,ax
  20da10:	0f 85 a9 08 00 00    	jne    20e2bf <BmSelf.init.setup.tearDown.AtomicRmwOp.Add+0xbff>
  20da16:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  20da1d:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20da20:	b0 01                	mov    al,0x1
  20da22:	86 05 e8 25 04 00    	xchg   BYTE PTR [rip+0x425e8],al        # 250010 <stderr_mutex>
  20da28:	84 c0                	test   al,al
  20da2a:	75 f4                	jne    20da20 <BmSelf.init.setup.tearDown.AtomicRmwOp.Add+0x360>
    if (stderr_stream) |st| {
  20da2c:	48 8b 3d d5 25 04 00 	mov    rdi,QWORD PTR [rip+0x425d5]        # 250008 <stderr_stream>
  20da33:	48 85 ff             	test   rdi,rdi
  20da36:	74 18                	je     20da50 <BmSelf.init.setup.tearDown.AtomicRmwOp.Add+0x390>
  20da38:	48 8b 0d 01 d6 03 00 	mov    rcx,QWORD PTR [rip+0x3d601]        # 24b040 <stderr_file_out_stream+0x8>
  20da3f:	eb 4c                	jmp    20da8d <BmSelf.init.setup.tearDown.AtomicRmwOp.Add+0x3cd>
  20da41:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20da48:	0f 1f 84 00 00 00 00 
  20da4f:	00 
        stderr_file = try io.getStdErr();
  20da50:	c7 05 d6 d5 03 00 02 	mov    DWORD PTR [rip+0x3d5d6],0x2        # 24b030 <stderr_file>
  20da57:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20da5a:	48 8d 05 cf d5 03 00 	lea    rax,[rip+0x3d5cf]        # 24b030 <stderr_file>
  20da61:	48 89 05 d0 d5 03 00 	mov    QWORD PTR [rip+0x3d5d0],rax        # 24b038 <stderr_file_out_stream>
  20da68:	48 8d 05 71 1f 01 00 	lea    rax,[rip+0x11f71]        # 21f9e0 <FileOutStream_writeFn>
  20da6f:	48 89 05 ca d5 03 00 	mov    QWORD PTR [rip+0x3d5ca],rax        # 24b040 <stderr_file_out_stream+0x8>
  20da76:	48 8d 0d c3 d5 03 00 	lea    rcx,[rip+0x3d5c3]        # 24b040 <stderr_file_out_stream+0x8>
  20da7d:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20da80:	48 89 15 81 25 04 00 	mov    QWORD PTR [rip+0x42581],rdx        # 250008 <stderr_stream>
  20da87:	48 89 c1             	mov    rcx,rax
  20da8a:	48 89 d7             	mov    rdi,rdx
  20da8d:	48 89 ee             	mov    rsi,rbp
  20da90:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20da92:	31 c0                	xor    eax,eax
  20da94:	86 05 76 25 04 00    	xchg   BYTE PTR [rip+0x42576],al        # 250010 <stderr_mutex>
  20da9a:	3c 01                	cmp    al,0x1
    if (!ok) {
  20da9c:	0f 85 32 08 00 00    	jne    20e2d4 <BmSelf.init.setup.tearDown.AtomicRmwOp.Add+0xc14>
                    if (run_time_ns < 1000) {
  20daa2:	49 81 ff e8 03 00 00 	cmp    r15,0x3e8
  20daa9:	73 25                	jae    20dad0 <BmSelf.init.setup.tearDown.AtomicRmwOp.Add+0x410>
  20daab:	b9 01 00 00 00       	mov    ecx,0x1
  20dab0:	be e8 03 00 00       	mov    esi,0x3e8
                    iterations = (iterations * numer) / denom;
  20dab5:	48 0f af de          	imul   rbx,rsi
  20dab9:	48 89 d8             	mov    rax,rbx
  20dabc:	48 c1 e8 20          	shr    rax,0x20
  20dac0:	74 48                	je     20db0a <BmSelf.init.setup.tearDown.AtomicRmwOp.Add+0x44a>
  20dac2:	31 d2                	xor    edx,edx
  20dac4:	48 89 d8             	mov    rax,rbx
  20dac7:	48 f7 f1             	div    rcx
  20daca:	48 89 c3             	mov    rbx,rax
  20dacd:	eb 43                	jmp    20db12 <BmSelf.init.setup.tearDown.AtomicRmwOp.Add+0x452>
  20dacf:	90                   	nop
                    } else if (run_time_ns < (pSelf.min_runtime_ns / 10)) {
  20dad0:	48 ba cd cc cc cc cc 	movabs rdx,0xcccccccccccccccd
  20dad7:	cc cc cc 
  20dada:	c4 e2 fb f6 4c 24 58 	mulx   rcx,rax,QWORD PTR [rsp+0x58]
  20dae1:	48 c1 e9 03          	shr    rcx,0x3
  20dae5:	31 c0                	xor    eax,eax
  20dae7:	49 39 cf             	cmp    r15,rcx
  20daea:	0f 93 c0             	setae  al
  20daed:	48 8d 0c c0          	lea    rcx,[rax+rax*8]
  20daf1:	48 83 c1 01          	add    rcx,0x1
  20daf5:	48 8d 34 85 0a 00 00 	lea    rsi,[rax*4+0xa]
  20dafc:	00 
                    iterations = (iterations * numer) / denom;
  20dafd:	48 0f af de          	imul   rbx,rsi
  20db01:	48 89 d8             	mov    rax,rbx
  20db04:	48 c1 e8 20          	shr    rax,0x20
  20db08:	75 b8                	jne    20dac2 <BmSelf.init.setup.tearDown.AtomicRmwOp.Add+0x402>
  20db0a:	31 d2                	xor    edx,edx
  20db0c:	89 d8                	mov    eax,ebx
  20db0e:	f7 f1                	div    ecx
  20db10:	89 c3                	mov    ebx,eax
                    if (iterations > pSelf.max_iterations) {
  20db12:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  20db17:	48 39 c3             	cmp    rbx,rax
  20db1a:	48 0f 47 d8          	cmova  rbx,rax
                    if (pSelf.logl >= 2) {
  20db1e:	48 83 7c 24 50 02    	cmp    QWORD PTR [rsp+0x50],0x2
  20db24:	0f 82 f4 fc ff ff    	jb     20d81e <BmSelf.init.setup.tearDown.AtomicRmwOp.Add+0x15e>
  20db2a:	e9 e1 fc ff ff       	jmp    20d810 <BmSelf.init.setup.tearDown.AtomicRmwOp.Add+0x150>
  20db2f:	90                   	nop
  20db30:	c5 fa 6f 05 88 b2 ff 	vmovdqu xmm0,XMMWORD PTR [rip+0xffffffffffffb288]        # 208dc0 <__unnamed_5>
  20db37:	ff 
  20db38:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
                if (errno != 0) return std.os.unexpectedErrorPosix(errno);
  20db3e:	0f 82 63 fd ff ff    	jb     20d8a7 <BmSelf.init.setup.tearDown.AtomicRmwOp.Add+0x1e7>
  20db44:	e9 72 07 00 00       	jmp    20e2bb <BmSelf.init.setup.tearDown.AtomicRmwOp.Add+0xbfb>
  20db49:	c5 f9 6f 8c 24 e0 00 	vmovdqa xmm1,XMMWORD PTR [rsp+0xe0]
  20db50:	00 00 
  20db52:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
  20db58:	0f 82 46 fe ff ff    	jb     20d9a4 <BmSelf.init.setup.tearDown.AtomicRmwOp.Add+0x2e4>
  20db5e:	e9 71 07 00 00       	jmp    20e2d4 <BmSelf.init.setup.tearDown.AtomicRmwOp.Add+0xc14>
                            Result { .run_time_ns = run_time_ns, .iterations = iterations});
  20db63:	4c 89 bc 24 08 01 00 	mov    QWORD PTR [rsp+0x108],r15
  20db6a:	00 
  20db6b:	48 89 9c 24 10 01 00 	mov    QWORD PTR [rsp+0x110],rbx
  20db72:	00 
                    try pSelf.results.append(
  20db73:	48 8d bc 24 88 00 00 	lea    rdi,[rsp+0x88]
  20db7a:	00 
  20db7b:	48 8d b4 24 08 01 00 	lea    rsi,[rsp+0x108]
  20db82:	00 
  20db83:	c5 f8 77             	vzeroupper 
  20db86:	e8 65 5d 00 00       	call   2138f0 <AlignedArrayList(Result,8)_append>
  20db8b:	66 85 c0             	test   ax,ax
  20db8e:	74 24                	je     20dbb4 <BmSelf.init.setup.tearDown.AtomicRmwOp.Add+0x4f4>
  20db90:	e9 2a 07 00 00       	jmp    20e2bf <BmSelf.init.setup.tearDown.AtomicRmwOp.Add+0xbff>
            pSelf.setup_count += 1;
  20db95:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
            while (iterations <= pSelf.max_iterations) {
  20db9a:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  20db9f:	45 31 f6             	xor    r14d,r14d
            pSelf.setup_count += 1;
  20dba2:	48 83 c1 01          	add    rcx,0x1
  20dba6:	48 89 4c 24 28       	mov    QWORD PTR [rsp+0x28],rcx
            while (iterations <= pSelf.max_iterations) {
  20dbab:	48 39 c3             	cmp    rbx,rax
  20dbae:	0f 86 6a fc ff ff    	jbe    20d81e <BmSelf.init.setup.tearDown.AtomicRmwOp.Add+0x15e>
  20dbb4:	49 89 ef             	mov    r15,rbp
            pSelf.tearDown_count += 1;
  20dbb7:	48 83 44 24 38 01    	add    QWORD PTR [rsp+0x38],0x1
            if (once) {
  20dbbd:	41 f6 c6 01          	test   r14b,0x1
  20dbc1:	48 8d 6c 24 0f       	lea    rbp,[rsp+0xf]
  20dbc6:	4c 8d 74 24 10       	lea    r14,[rsp+0x10]
  20dbcb:	0f 84 e2 05 00 00    	je     20e1b3 <BmSelf.init.setup.tearDown.AtomicRmwOp.Add+0xaf3>
                try leftJustified(22, "name repetitions:{}", pSelf.repetitions);
  20dbd1:	48 8b 7c 24 60       	mov    rdi,QWORD PTR [rsp+0x60]
  20dbd6:	c5 f8 77             	vzeroupper 
  20dbd9:	e8 02 83 00 00       	call   215ee0 <Benchmark_leftJustified>
  20dbde:	66 85 c0             	test   ax,ax
  20dbe1:	0f 85 d8 06 00 00    	jne    20e2bf <BmSelf.init.setup.tearDown.AtomicRmwOp.Add+0xbff>
                try rightJustified(14, "{}", "iterations");
  20dbe7:	e8 94 85 00 00       	call   216180 <Benchmark_rightJustified>
  20dbec:	66 85 c0             	test   ax,ax
  20dbef:	0f 85 ca 06 00 00    	jne    20e2bf <BmSelf.init.setup.tearDown.AtomicRmwOp.Add+0xbff>
        var buffer: [40]u8 = undefined;
  20dbf5:	c5 fe 6f 05 9e 79 ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffff799e]        # 20559b <__unnamed_7>
  20dbfc:	ff 
  20dbfd:	c5 fe 7f 84 24 b0 00 	vmovdqu YMMWORD PTR [rsp+0xb0],ymm0
  20dc04:	00 00 
  20dc06:	48 8b 05 ae 79 ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffff79ae]        # 2055bb <__unnamed_7+0x20>
  20dc0d:	48 89 84 24 d0 00 00 	mov    QWORD PTR [rsp+0xd0],rax
  20dc14:	00 
  20dc15:	c7 84 24 b0 00 00 00 	mov    DWORD PTR [rsp+0xb0],0x656d6974
  20dc1c:	74 69 6d 65 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20dc20:	b0 01                	mov    al,0x1
  20dc22:	86 05 e8 23 04 00    	xchg   BYTE PTR [rip+0x423e8],al        # 250010 <stderr_mutex>
  20dc28:	84 c0                	test   al,al
  20dc2a:	75 f4                	jne    20dc20 <BmSelf.init.setup.tearDown.AtomicRmwOp.Add+0x560>
    if (stderr_stream) |st| {
  20dc2c:	48 8b 3d d5 23 04 00 	mov    rdi,QWORD PTR [rip+0x423d5]        # 250008 <stderr_stream>
  20dc33:	48 85 ff             	test   rdi,rdi
  20dc36:	74 09                	je     20dc41 <BmSelf.init.setup.tearDown.AtomicRmwOp.Add+0x581>
  20dc38:	48 8b 0d 01 d4 03 00 	mov    rcx,QWORD PTR [rip+0x3d401]        # 24b040 <stderr_file_out_stream+0x8>
  20dc3f:	eb 3d                	jmp    20dc7e <BmSelf.init.setup.tearDown.AtomicRmwOp.Add+0x5be>
        stderr_file = try io.getStdErr();
  20dc41:	c7 05 e5 d3 03 00 02 	mov    DWORD PTR [rip+0x3d3e5],0x2        # 24b030 <stderr_file>
  20dc48:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20dc4b:	48 8d 05 de d3 03 00 	lea    rax,[rip+0x3d3de]        # 24b030 <stderr_file>
  20dc52:	48 89 05 df d3 03 00 	mov    QWORD PTR [rip+0x3d3df],rax        # 24b038 <stderr_file_out_stream>
  20dc59:	48 8d 05 80 1d 01 00 	lea    rax,[rip+0x11d80]        # 21f9e0 <FileOutStream_writeFn>
  20dc60:	48 89 05 d9 d3 03 00 	mov    QWORD PTR [rip+0x3d3d9],rax        # 24b040 <stderr_file_out_stream+0x8>
  20dc67:	48 8d 0d d2 d3 03 00 	lea    rcx,[rip+0x3d3d2]        # 24b040 <stderr_file_out_stream+0x8>
  20dc6e:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20dc71:	48 89 15 90 23 04 00 	mov    QWORD PTR [rip+0x42390],rdx        # 250008 <stderr_stream>
  20dc78:	48 89 c1             	mov    rcx,rax
  20dc7b:	48 89 d7             	mov    rdi,rdx
  20dc7e:	c6 44 24 0f 20       	mov    BYTE PTR [rsp+0xf],0x20
    return output(context, (*[1]u8)(&c)[0..]);
  20dc83:	48 89 6c 24 10       	mov    QWORD PTR [rsp+0x10],rbp
  20dc88:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  20dc8f:	00 00 
  20dc91:	4c 89 f6             	mov    rsi,r14
  20dc94:	c5 f8 77             	vzeroupper 
  20dc97:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20dc99:	31 c0                	xor    eax,eax
  20dc9b:	86 05 6f 23 04 00    	xchg   BYTE PTR [rip+0x4236f],al        # 250010 <stderr_mutex>
  20dca1:	3c 01                	cmp    al,0x1
    if (!ok) {
  20dca3:	0f 85 2b 06 00 00    	jne    20e2d4 <BmSelf.init.setup.tearDown.AtomicRmwOp.Add+0xc14>
  20dca9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20dcb0:	b0 01                	mov    al,0x1
  20dcb2:	86 05 58 23 04 00    	xchg   BYTE PTR [rip+0x42358],al        # 250010 <stderr_mutex>
  20dcb8:	84 c0                	test   al,al
  20dcba:	75 f4                	jne    20dcb0 <BmSelf.init.setup.tearDown.AtomicRmwOp.Add+0x5f0>
    if (stderr_stream) |st| {
  20dcbc:	48 8b 3d 45 23 04 00 	mov    rdi,QWORD PTR [rip+0x42345]        # 250008 <stderr_stream>
  20dcc3:	48 85 ff             	test   rdi,rdi
  20dcc6:	74 09                	je     20dcd1 <BmSelf.init.setup.tearDown.AtomicRmwOp.Add+0x611>
  20dcc8:	48 8b 0d 71 d3 03 00 	mov    rcx,QWORD PTR [rip+0x3d371]        # 24b040 <stderr_file_out_stream+0x8>
  20dccf:	eb 3d                	jmp    20dd0e <BmSelf.init.setup.tearDown.AtomicRmwOp.Add+0x64e>
        stderr_file = try io.getStdErr();
  20dcd1:	c7 05 55 d3 03 00 02 	mov    DWORD PTR [rip+0x3d355],0x2        # 24b030 <stderr_file>
  20dcd8:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20dcdb:	48 8d 05 4e d3 03 00 	lea    rax,[rip+0x3d34e]        # 24b030 <stderr_file>
  20dce2:	48 89 05 4f d3 03 00 	mov    QWORD PTR [rip+0x3d34f],rax        # 24b038 <stderr_file_out_stream>
  20dce9:	48 8d 05 f0 1c 01 00 	lea    rax,[rip+0x11cf0]        # 21f9e0 <FileOutStream_writeFn>
  20dcf0:	48 89 05 49 d3 03 00 	mov    QWORD PTR [rip+0x3d349],rax        # 24b040 <stderr_file_out_stream+0x8>
  20dcf7:	48 8d 0d 42 d3 03 00 	lea    rcx,[rip+0x3d342]        # 24b040 <stderr_file_out_stream+0x8>
  20dcfe:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20dd01:	48 89 15 00 23 04 00 	mov    QWORD PTR [rip+0x42300],rdx        # 250008 <stderr_stream>
  20dd08:	48 89 c1             	mov    rcx,rax
  20dd0b:	48 89 d7             	mov    rdi,rdx
  20dd0e:	c6 44 24 0f 20       	mov    BYTE PTR [rsp+0xf],0x20
  20dd13:	48 89 6c 24 10       	mov    QWORD PTR [rsp+0x10],rbp
  20dd18:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  20dd1f:	00 00 
  20dd21:	4c 89 f6             	mov    rsi,r14
  20dd24:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20dd26:	31 c0                	xor    eax,eax
  20dd28:	86 05 e2 22 04 00    	xchg   BYTE PTR [rip+0x422e2],al        # 250010 <stderr_mutex>
  20dd2e:	3c 01                	cmp    al,0x1
    if (!ok) {
  20dd30:	0f 85 9e 05 00 00    	jne    20e2d4 <BmSelf.init.setup.tearDown.AtomicRmwOp.Add+0xc14>
  20dd36:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  20dd3d:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20dd40:	b0 01                	mov    al,0x1
  20dd42:	86 05 c8 22 04 00    	xchg   BYTE PTR [rip+0x422c8],al        # 250010 <stderr_mutex>
  20dd48:	84 c0                	test   al,al
  20dd4a:	75 f4                	jne    20dd40 <BmSelf.init.setup.tearDown.AtomicRmwOp.Add+0x680>
    if (stderr_stream) |st| {
  20dd4c:	48 8b 3d b5 22 04 00 	mov    rdi,QWORD PTR [rip+0x422b5]        # 250008 <stderr_stream>
  20dd53:	48 85 ff             	test   rdi,rdi
  20dd56:	74 09                	je     20dd61 <BmSelf.init.setup.tearDown.AtomicRmwOp.Add+0x6a1>
  20dd58:	48 8b 0d e1 d2 03 00 	mov    rcx,QWORD PTR [rip+0x3d2e1]        # 24b040 <stderr_file_out_stream+0x8>
  20dd5f:	eb 3d                	jmp    20dd9e <BmSelf.init.setup.tearDown.AtomicRmwOp.Add+0x6de>
        stderr_file = try io.getStdErr();
  20dd61:	c7 05 c5 d2 03 00 02 	mov    DWORD PTR [rip+0x3d2c5],0x2        # 24b030 <stderr_file>
  20dd68:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20dd6b:	48 8d 05 be d2 03 00 	lea    rax,[rip+0x3d2be]        # 24b030 <stderr_file>
  20dd72:	48 89 05 bf d2 03 00 	mov    QWORD PTR [rip+0x3d2bf],rax        # 24b038 <stderr_file_out_stream>
  20dd79:	48 8d 05 60 1c 01 00 	lea    rax,[rip+0x11c60]        # 21f9e0 <FileOutStream_writeFn>
  20dd80:	48 89 05 b9 d2 03 00 	mov    QWORD PTR [rip+0x3d2b9],rax        # 24b040 <stderr_file_out_stream+0x8>
  20dd87:	48 8d 0d b2 d2 03 00 	lea    rcx,[rip+0x3d2b2]        # 24b040 <stderr_file_out_stream+0x8>
  20dd8e:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20dd91:	48 89 15 70 22 04 00 	mov    QWORD PTR [rip+0x42270],rdx        # 250008 <stderr_stream>
  20dd98:	48 89 c1             	mov    rcx,rax
  20dd9b:	48 89 d7             	mov    rdi,rdx
  20dd9e:	c6 44 24 0f 20       	mov    BYTE PTR [rsp+0xf],0x20
  20dda3:	48 89 6c 24 10       	mov    QWORD PTR [rsp+0x10],rbp
  20dda8:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  20ddaf:	00 00 
  20ddb1:	4c 89 f6             	mov    rsi,r14
  20ddb4:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20ddb6:	31 c0                	xor    eax,eax
  20ddb8:	86 05 52 22 04 00    	xchg   BYTE PTR [rip+0x42252],al        # 250010 <stderr_mutex>
  20ddbe:	3c 01                	cmp    al,0x1
    if (!ok) {
  20ddc0:	0f 85 0e 05 00 00    	jne    20e2d4 <BmSelf.init.setup.tearDown.AtomicRmwOp.Add+0xc14>
  20ddc6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  20ddcd:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20ddd0:	b0 01                	mov    al,0x1
  20ddd2:	86 05 38 22 04 00    	xchg   BYTE PTR [rip+0x42238],al        # 250010 <stderr_mutex>
  20ddd8:	84 c0                	test   al,al
  20ddda:	75 f4                	jne    20ddd0 <BmSelf.init.setup.tearDown.AtomicRmwOp.Add+0x710>
    if (stderr_stream) |st| {
  20dddc:	48 8b 3d 25 22 04 00 	mov    rdi,QWORD PTR [rip+0x42225]        # 250008 <stderr_stream>
  20dde3:	48 85 ff             	test   rdi,rdi
  20dde6:	74 09                	je     20ddf1 <BmSelf.init.setup.tearDown.AtomicRmwOp.Add+0x731>
  20dde8:	48 8b 0d 51 d2 03 00 	mov    rcx,QWORD PTR [rip+0x3d251]        # 24b040 <stderr_file_out_stream+0x8>
  20ddef:	eb 3d                	jmp    20de2e <BmSelf.init.setup.tearDown.AtomicRmwOp.Add+0x76e>
        stderr_file = try io.getStdErr();
  20ddf1:	c7 05 35 d2 03 00 02 	mov    DWORD PTR [rip+0x3d235],0x2        # 24b030 <stderr_file>
  20ddf8:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20ddfb:	48 8d 05 2e d2 03 00 	lea    rax,[rip+0x3d22e]        # 24b030 <stderr_file>
  20de02:	48 89 05 2f d2 03 00 	mov    QWORD PTR [rip+0x3d22f],rax        # 24b038 <stderr_file_out_stream>
  20de09:	48 8d 05 d0 1b 01 00 	lea    rax,[rip+0x11bd0]        # 21f9e0 <FileOutStream_writeFn>
  20de10:	48 89 05 29 d2 03 00 	mov    QWORD PTR [rip+0x3d229],rax        # 24b040 <stderr_file_out_stream+0x8>
  20de17:	48 8d 0d 22 d2 03 00 	lea    rcx,[rip+0x3d222]        # 24b040 <stderr_file_out_stream+0x8>
  20de1e:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20de21:	48 89 15 e0 21 04 00 	mov    QWORD PTR [rip+0x421e0],rdx        # 250008 <stderr_stream>
  20de28:	48 89 c1             	mov    rcx,rax
  20de2b:	48 89 d7             	mov    rdi,rdx
  20de2e:	c6 44 24 0f 20       	mov    BYTE PTR [rsp+0xf],0x20
  20de33:	48 89 6c 24 10       	mov    QWORD PTR [rsp+0x10],rbp
  20de38:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  20de3f:	00 00 
  20de41:	4c 89 f6             	mov    rsi,r14
  20de44:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20de46:	31 c0                	xor    eax,eax
  20de48:	86 05 c2 21 04 00    	xchg   BYTE PTR [rip+0x421c2],al        # 250010 <stderr_mutex>
  20de4e:	3c 01                	cmp    al,0x1
    if (!ok) {
  20de50:	0f 85 7e 04 00 00    	jne    20e2d4 <BmSelf.init.setup.tearDown.AtomicRmwOp.Add+0xc14>
  20de56:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  20de5d:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20de60:	b0 01                	mov    al,0x1
  20de62:	86 05 a8 21 04 00    	xchg   BYTE PTR [rip+0x421a8],al        # 250010 <stderr_mutex>
  20de68:	84 c0                	test   al,al
  20de6a:	75 f4                	jne    20de60 <BmSelf.init.setup.tearDown.AtomicRmwOp.Add+0x7a0>
    if (stderr_stream) |st| {
  20de6c:	48 8b 3d 95 21 04 00 	mov    rdi,QWORD PTR [rip+0x42195]        # 250008 <stderr_stream>
  20de73:	48 85 ff             	test   rdi,rdi
  20de76:	74 09                	je     20de81 <BmSelf.init.setup.tearDown.AtomicRmwOp.Add+0x7c1>
  20de78:	48 8b 0d c1 d1 03 00 	mov    rcx,QWORD PTR [rip+0x3d1c1]        # 24b040 <stderr_file_out_stream+0x8>
  20de7f:	eb 3d                	jmp    20debe <BmSelf.init.setup.tearDown.AtomicRmwOp.Add+0x7fe>
        stderr_file = try io.getStdErr();
  20de81:	c7 05 a5 d1 03 00 02 	mov    DWORD PTR [rip+0x3d1a5],0x2        # 24b030 <stderr_file>
  20de88:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20de8b:	48 8d 05 9e d1 03 00 	lea    rax,[rip+0x3d19e]        # 24b030 <stderr_file>
  20de92:	48 89 05 9f d1 03 00 	mov    QWORD PTR [rip+0x3d19f],rax        # 24b038 <stderr_file_out_stream>
  20de99:	48 8d 05 40 1b 01 00 	lea    rax,[rip+0x11b40]        # 21f9e0 <FileOutStream_writeFn>
  20dea0:	48 89 05 99 d1 03 00 	mov    QWORD PTR [rip+0x3d199],rax        # 24b040 <stderr_file_out_stream+0x8>
  20dea7:	48 8d 0d 92 d1 03 00 	lea    rcx,[rip+0x3d192]        # 24b040 <stderr_file_out_stream+0x8>
  20deae:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20deb1:	48 89 15 50 21 04 00 	mov    QWORD PTR [rip+0x42150],rdx        # 250008 <stderr_stream>
  20deb8:	48 89 c1             	mov    rcx,rax
  20debb:	48 89 d7             	mov    rdi,rdx
  20debe:	c6 44 24 0f 20       	mov    BYTE PTR [rsp+0xf],0x20
  20dec3:	48 89 6c 24 10       	mov    QWORD PTR [rsp+0x10],rbp
  20dec8:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  20decf:	00 00 
  20ded1:	4c 89 f6             	mov    rsi,r14
  20ded4:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20ded6:	31 c0                	xor    eax,eax
  20ded8:	86 05 32 21 04 00    	xchg   BYTE PTR [rip+0x42132],al        # 250010 <stderr_mutex>
  20dede:	3c 01                	cmp    al,0x1
    if (!ok) {
  20dee0:	0f 85 ee 03 00 00    	jne    20e2d4 <BmSelf.init.setup.tearDown.AtomicRmwOp.Add+0xc14>
  20dee6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  20deed:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20def0:	b0 01                	mov    al,0x1
  20def2:	86 05 18 21 04 00    	xchg   BYTE PTR [rip+0x42118],al        # 250010 <stderr_mutex>
  20def8:	84 c0                	test   al,al
  20defa:	75 f4                	jne    20def0 <BmSelf.init.setup.tearDown.AtomicRmwOp.Add+0x830>
    if (stderr_stream) |st| {
  20defc:	48 8b 3d 05 21 04 00 	mov    rdi,QWORD PTR [rip+0x42105]        # 250008 <stderr_stream>
  20df03:	48 85 ff             	test   rdi,rdi
  20df06:	74 09                	je     20df11 <BmSelf.init.setup.tearDown.AtomicRmwOp.Add+0x851>
  20df08:	48 8b 0d 31 d1 03 00 	mov    rcx,QWORD PTR [rip+0x3d131]        # 24b040 <stderr_file_out_stream+0x8>
  20df0f:	eb 3d                	jmp    20df4e <BmSelf.init.setup.tearDown.AtomicRmwOp.Add+0x88e>
        stderr_file = try io.getStdErr();
  20df11:	c7 05 15 d1 03 00 02 	mov    DWORD PTR [rip+0x3d115],0x2        # 24b030 <stderr_file>
  20df18:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20df1b:	48 8d 05 0e d1 03 00 	lea    rax,[rip+0x3d10e]        # 24b030 <stderr_file>
  20df22:	48 89 05 0f d1 03 00 	mov    QWORD PTR [rip+0x3d10f],rax        # 24b038 <stderr_file_out_stream>
  20df29:	48 8d 05 b0 1a 01 00 	lea    rax,[rip+0x11ab0]        # 21f9e0 <FileOutStream_writeFn>
  20df30:	48 89 05 09 d1 03 00 	mov    QWORD PTR [rip+0x3d109],rax        # 24b040 <stderr_file_out_stream+0x8>
  20df37:	48 8d 0d 02 d1 03 00 	lea    rcx,[rip+0x3d102]        # 24b040 <stderr_file_out_stream+0x8>
  20df3e:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20df41:	48 89 15 c0 20 04 00 	mov    QWORD PTR [rip+0x420c0],rdx        # 250008 <stderr_stream>
  20df48:	48 89 c1             	mov    rcx,rax
  20df4b:	48 89 d7             	mov    rdi,rdx
  20df4e:	c6 44 24 0f 20       	mov    BYTE PTR [rsp+0xf],0x20
  20df53:	48 89 6c 24 10       	mov    QWORD PTR [rsp+0x10],rbp
  20df58:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  20df5f:	00 00 
  20df61:	4c 89 f6             	mov    rsi,r14
  20df64:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20df66:	31 c0                	xor    eax,eax
  20df68:	86 05 a2 20 04 00    	xchg   BYTE PTR [rip+0x420a2],al        # 250010 <stderr_mutex>
  20df6e:	3c 01                	cmp    al,0x1
    if (!ok) {
  20df70:	0f 85 5e 03 00 00    	jne    20e2d4 <BmSelf.init.setup.tearDown.AtomicRmwOp.Add+0xc14>
  20df76:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  20df7d:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20df80:	b0 01                	mov    al,0x1
  20df82:	86 05 88 20 04 00    	xchg   BYTE PTR [rip+0x42088],al        # 250010 <stderr_mutex>
  20df88:	84 c0                	test   al,al
  20df8a:	75 f4                	jne    20df80 <BmSelf.init.setup.tearDown.AtomicRmwOp.Add+0x8c0>
    if (stderr_stream) |st| {
  20df8c:	48 8b 3d 75 20 04 00 	mov    rdi,QWORD PTR [rip+0x42075]        # 250008 <stderr_stream>
  20df93:	48 85 ff             	test   rdi,rdi
  20df96:	74 09                	je     20dfa1 <BmSelf.init.setup.tearDown.AtomicRmwOp.Add+0x8e1>
  20df98:	48 8b 0d a1 d0 03 00 	mov    rcx,QWORD PTR [rip+0x3d0a1]        # 24b040 <stderr_file_out_stream+0x8>
  20df9f:	eb 3d                	jmp    20dfde <BmSelf.init.setup.tearDown.AtomicRmwOp.Add+0x91e>
        stderr_file = try io.getStdErr();
  20dfa1:	c7 05 85 d0 03 00 02 	mov    DWORD PTR [rip+0x3d085],0x2        # 24b030 <stderr_file>
  20dfa8:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20dfab:	48 8d 05 7e d0 03 00 	lea    rax,[rip+0x3d07e]        # 24b030 <stderr_file>
  20dfb2:	48 89 05 7f d0 03 00 	mov    QWORD PTR [rip+0x3d07f],rax        # 24b038 <stderr_file_out_stream>
  20dfb9:	48 8d 05 20 1a 01 00 	lea    rax,[rip+0x11a20]        # 21f9e0 <FileOutStream_writeFn>
  20dfc0:	48 89 05 79 d0 03 00 	mov    QWORD PTR [rip+0x3d079],rax        # 24b040 <stderr_file_out_stream+0x8>
  20dfc7:	48 8d 0d 72 d0 03 00 	lea    rcx,[rip+0x3d072]        # 24b040 <stderr_file_out_stream+0x8>
  20dfce:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20dfd1:	48 89 15 30 20 04 00 	mov    QWORD PTR [rip+0x42030],rdx        # 250008 <stderr_stream>
  20dfd8:	48 89 c1             	mov    rcx,rax
  20dfdb:	48 89 d7             	mov    rdi,rdx
  20dfde:	c6 44 24 0f 20       	mov    BYTE PTR [rsp+0xf],0x20
  20dfe3:	48 89 6c 24 10       	mov    QWORD PTR [rsp+0x10],rbp
  20dfe8:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  20dfef:	00 00 
  20dff1:	4c 89 f6             	mov    rsi,r14
  20dff4:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20dff6:	31 c0                	xor    eax,eax
  20dff8:	86 05 12 20 04 00    	xchg   BYTE PTR [rip+0x42012],al        # 250010 <stderr_mutex>
  20dffe:	3c 01                	cmp    al,0x1
    if (!ok) {
  20e000:	0f 85 ce 02 00 00    	jne    20e2d4 <BmSelf.init.setup.tearDown.AtomicRmwOp.Add+0xc14>
  20e006:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  20e00d:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20e010:	b0 01                	mov    al,0x1
  20e012:	86 05 f8 1f 04 00    	xchg   BYTE PTR [rip+0x41ff8],al        # 250010 <stderr_mutex>
  20e018:	84 c0                	test   al,al
  20e01a:	75 f4                	jne    20e010 <BmSelf.init.setup.tearDown.AtomicRmwOp.Add+0x950>
    if (stderr_stream) |st| {
  20e01c:	48 8b 3d e5 1f 04 00 	mov    rdi,QWORD PTR [rip+0x41fe5]        # 250008 <stderr_stream>
  20e023:	48 85 ff             	test   rdi,rdi
  20e026:	74 09                	je     20e031 <BmSelf.init.setup.tearDown.AtomicRmwOp.Add+0x971>
  20e028:	48 8b 0d 11 d0 03 00 	mov    rcx,QWORD PTR [rip+0x3d011]        # 24b040 <stderr_file_out_stream+0x8>
  20e02f:	eb 3d                	jmp    20e06e <BmSelf.init.setup.tearDown.AtomicRmwOp.Add+0x9ae>
        stderr_file = try io.getStdErr();
  20e031:	c7 05 f5 cf 03 00 02 	mov    DWORD PTR [rip+0x3cff5],0x2        # 24b030 <stderr_file>
  20e038:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20e03b:	48 8d 05 ee cf 03 00 	lea    rax,[rip+0x3cfee]        # 24b030 <stderr_file>
  20e042:	48 89 05 ef cf 03 00 	mov    QWORD PTR [rip+0x3cfef],rax        # 24b038 <stderr_file_out_stream>
  20e049:	48 8d 05 90 19 01 00 	lea    rax,[rip+0x11990]        # 21f9e0 <FileOutStream_writeFn>
  20e050:	48 89 05 e9 cf 03 00 	mov    QWORD PTR [rip+0x3cfe9],rax        # 24b040 <stderr_file_out_stream+0x8>
  20e057:	48 8d 0d e2 cf 03 00 	lea    rcx,[rip+0x3cfe2]        # 24b040 <stderr_file_out_stream+0x8>
  20e05e:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20e061:	48 89 15 a0 1f 04 00 	mov    QWORD PTR [rip+0x41fa0],rdx        # 250008 <stderr_stream>
  20e068:	48 89 c1             	mov    rcx,rax
  20e06b:	48 89 d7             	mov    rdi,rdx
  20e06e:	c6 44 24 0f 20       	mov    BYTE PTR [rsp+0xf],0x20
  20e073:	48 89 6c 24 10       	mov    QWORD PTR [rsp+0x10],rbp
  20e078:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  20e07f:	00 00 
  20e081:	4c 89 f6             	mov    rsi,r14
  20e084:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20e086:	31 c0                	xor    eax,eax
  20e088:	86 05 82 1f 04 00    	xchg   BYTE PTR [rip+0x41f82],al        # 250010 <stderr_mutex>
  20e08e:	3c 01                	cmp    al,0x1
    if (!ok) {
  20e090:	0f 85 3e 02 00 00    	jne    20e2d4 <BmSelf.init.setup.tearDown.AtomicRmwOp.Add+0xc14>
  20e096:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  20e09d:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20e0a0:	b0 01                	mov    al,0x1
  20e0a2:	86 05 68 1f 04 00    	xchg   BYTE PTR [rip+0x41f68],al        # 250010 <stderr_mutex>
  20e0a8:	84 c0                	test   al,al
  20e0aa:	75 f4                	jne    20e0a0 <BmSelf.init.setup.tearDown.AtomicRmwOp.Add+0x9e0>
    if (stderr_stream) |st| {
  20e0ac:	48 8b 3d 55 1f 04 00 	mov    rdi,QWORD PTR [rip+0x41f55]        # 250008 <stderr_stream>
  20e0b3:	48 85 ff             	test   rdi,rdi
  20e0b6:	74 09                	je     20e0c1 <BmSelf.init.setup.tearDown.AtomicRmwOp.Add+0xa01>
  20e0b8:	48 8b 0d 81 cf 03 00 	mov    rcx,QWORD PTR [rip+0x3cf81]        # 24b040 <stderr_file_out_stream+0x8>
  20e0bf:	eb 3d                	jmp    20e0fe <BmSelf.init.setup.tearDown.AtomicRmwOp.Add+0xa3e>
        stderr_file = try io.getStdErr();
  20e0c1:	c7 05 65 cf 03 00 02 	mov    DWORD PTR [rip+0x3cf65],0x2        # 24b030 <stderr_file>
  20e0c8:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20e0cb:	48 8d 05 5e cf 03 00 	lea    rax,[rip+0x3cf5e]        # 24b030 <stderr_file>
  20e0d2:	48 89 05 5f cf 03 00 	mov    QWORD PTR [rip+0x3cf5f],rax        # 24b038 <stderr_file_out_stream>
  20e0d9:	48 8d 05 00 19 01 00 	lea    rax,[rip+0x11900]        # 21f9e0 <FileOutStream_writeFn>
  20e0e0:	48 89 05 59 cf 03 00 	mov    QWORD PTR [rip+0x3cf59],rax        # 24b040 <stderr_file_out_stream+0x8>
  20e0e7:	48 8d 0d 52 cf 03 00 	lea    rcx,[rip+0x3cf52]        # 24b040 <stderr_file_out_stream+0x8>
  20e0ee:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20e0f1:	48 89 15 10 1f 04 00 	mov    QWORD PTR [rip+0x41f10],rdx        # 250008 <stderr_stream>
  20e0f8:	48 89 c1             	mov    rcx,rax
  20e0fb:	48 89 d7             	mov    rdi,rdx
  20e0fe:	4c 89 fd             	mov    rbp,r15
                const casted_value = ([]const u8)(value);
  20e101:	4c 89 64 24 10       	mov    QWORD PTR [rsp+0x10],r12
  20e106:	48 c7 44 24 18 04 00 	mov    QWORD PTR [rsp+0x18],0x4
  20e10d:	00 00 
                return output(context, casted_value);
  20e10f:	4c 89 f6             	mov    rsi,r14
  20e112:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20e114:	31 c0                	xor    eax,eax
  20e116:	86 05 f4 1e 04 00    	xchg   BYTE PTR [rip+0x41ef4],al        # 250010 <stderr_mutex>
  20e11c:	3c 01                	cmp    al,0x1
    if (!ok) {
  20e11e:	0f 85 b0 01 00 00    	jne    20e2d4 <BmSelf.init.setup.tearDown.AtomicRmwOp.Add+0xc14>
                try rightJustified(18, "{}", "time/operation");
  20e124:	e8 37 83 00 00       	call   216460 <Benchmark_rightJustified.38>
  20e129:	66 85 c0             	test   ax,ax
  20e12c:	0f 85 8d 01 00 00    	jne    20e2bf <BmSelf.init.setup.tearDown.AtomicRmwOp.Add+0xbff>
  20e132:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20e139:	1f 84 00 00 00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20e140:	b0 01                	mov    al,0x1
  20e142:	86 05 c8 1e 04 00    	xchg   BYTE PTR [rip+0x41ec8],al        # 250010 <stderr_mutex>
  20e148:	84 c0                	test   al,al
  20e14a:	75 f4                	jne    20e140 <BmSelf.init.setup.tearDown.AtomicRmwOp.Add+0xa80>
    if (stderr_stream) |st| {
  20e14c:	48 8b 3d b5 1e 04 00 	mov    rdi,QWORD PTR [rip+0x41eb5]        # 250008 <stderr_stream>
  20e153:	48 85 ff             	test   rdi,rdi
  20e156:	74 09                	je     20e161 <BmSelf.init.setup.tearDown.AtomicRmwOp.Add+0xaa1>
  20e158:	48 8b 0d e1 ce 03 00 	mov    rcx,QWORD PTR [rip+0x3cee1]        # 24b040 <stderr_file_out_stream+0x8>
  20e15f:	eb 3d                	jmp    20e19e <BmSelf.init.setup.tearDown.AtomicRmwOp.Add+0xade>
        stderr_file = try io.getStdErr();
  20e161:	c7 05 c5 ce 03 00 02 	mov    DWORD PTR [rip+0x3cec5],0x2        # 24b030 <stderr_file>
  20e168:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20e16b:	48 8d 05 be ce 03 00 	lea    rax,[rip+0x3cebe]        # 24b030 <stderr_file>
  20e172:	48 89 05 bf ce 03 00 	mov    QWORD PTR [rip+0x3cebf],rax        # 24b038 <stderr_file_out_stream>
  20e179:	48 8d 05 60 18 01 00 	lea    rax,[rip+0x11860]        # 21f9e0 <FileOutStream_writeFn>
  20e180:	48 89 05 b9 ce 03 00 	mov    QWORD PTR [rip+0x3ceb9],rax        # 24b040 <stderr_file_out_stream+0x8>
  20e187:	48 8d 0d b2 ce 03 00 	lea    rcx,[rip+0x3ceb2]        # 24b040 <stderr_file_out_stream+0x8>
  20e18e:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20e191:	48 89 15 70 1e 04 00 	mov    QWORD PTR [rip+0x41e70],rdx        # 250008 <stderr_stream>
  20e198:	48 89 c1             	mov    rcx,rax
  20e19b:	48 89 d7             	mov    rdi,rdx
        try output(context, fmt[start_index..]);
  20e19e:	48 89 ee             	mov    rsi,rbp
  20e1a1:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20e1a3:	31 c0                	xor    eax,eax
  20e1a5:	86 05 65 1e 04 00    	xchg   BYTE PTR [rip+0x41e65],al        # 250010 <stderr_mutex>
  20e1ab:	3c 01                	cmp    al,0x1
    if (!ok) {
  20e1ad:	0f 85 21 01 00 00    	jne    20e2d4 <BmSelf.init.setup.tearDown.AtomicRmwOp.Add+0xc14>
            try pSelf.report(pSelf.results.items[pSelf.results.len - 1]); warn("\n");
  20e1b3:	48 8b 84 24 88 00 00 	mov    rax,QWORD PTR [rsp+0x88]
  20e1ba:	00 
  20e1bb:	48 8b 8c 24 98 00 00 	mov    rcx,QWORD PTR [rsp+0x98]
  20e1c2:	00 
  20e1c3:	48 c1 e1 04          	shl    rcx,0x4
  20e1c7:	48 8d 34 08          	lea    rsi,[rax+rcx*1]
  20e1cb:	48 83 c6 f0          	add    rsi,0xfffffffffffffff0
  20e1cf:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  20e1d4:	c5 f8 77             	vzeroupper 
  20e1d7:	e8 84 58 00 00       	call   213a60 <Benchmark_report>
  20e1dc:	66 85 c0             	test   ax,ax
  20e1df:	0f 85 da 00 00 00    	jne    20e2bf <BmSelf.init.setup.tearDown.AtomicRmwOp.Add+0xbff>
  20e1e5:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20e1ec:	00 00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20e1f0:	b0 01                	mov    al,0x1
  20e1f2:	86 05 18 1e 04 00    	xchg   BYTE PTR [rip+0x41e18],al        # 250010 <stderr_mutex>
  20e1f8:	84 c0                	test   al,al
  20e1fa:	75 f4                	jne    20e1f0 <BmSelf.init.setup.tearDown.AtomicRmwOp.Add+0xb30>
    if (stderr_stream) |st| {
  20e1fc:	48 8b 3d 05 1e 04 00 	mov    rdi,QWORD PTR [rip+0x41e05]        # 250008 <stderr_stream>
  20e203:	48 85 ff             	test   rdi,rdi
  20e206:	74 09                	je     20e211 <BmSelf.init.setup.tearDown.AtomicRmwOp.Add+0xb51>
  20e208:	48 8b 0d 31 ce 03 00 	mov    rcx,QWORD PTR [rip+0x3ce31]        # 24b040 <stderr_file_out_stream+0x8>
  20e20f:	eb 3d                	jmp    20e24e <BmSelf.init.setup.tearDown.AtomicRmwOp.Add+0xb8e>
        stderr_file = try io.getStdErr();
  20e211:	c7 05 15 ce 03 00 02 	mov    DWORD PTR [rip+0x3ce15],0x2        # 24b030 <stderr_file>
  20e218:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20e21b:	48 8d 05 0e ce 03 00 	lea    rax,[rip+0x3ce0e]        # 24b030 <stderr_file>
  20e222:	48 89 05 0f ce 03 00 	mov    QWORD PTR [rip+0x3ce0f],rax        # 24b038 <stderr_file_out_stream>
  20e229:	48 8d 05 b0 17 01 00 	lea    rax,[rip+0x117b0]        # 21f9e0 <FileOutStream_writeFn>
  20e230:	48 89 05 09 ce 03 00 	mov    QWORD PTR [rip+0x3ce09],rax        # 24b040 <stderr_file_out_stream+0x8>
  20e237:	48 8d 0d 02 ce 03 00 	lea    rcx,[rip+0x3ce02]        # 24b040 <stderr_file_out_stream+0x8>
  20e23e:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20e241:	48 89 15 c0 1d 04 00 	mov    QWORD PTR [rip+0x41dc0],rdx        # 250008 <stderr_stream>
  20e248:	48 89 c1             	mov    rcx,rax
  20e24b:	48 89 d7             	mov    rdi,rdx
  20e24e:	4c 89 fd             	mov    rbp,r15
  20e251:	48 89 ee             	mov    rsi,rbp
  20e254:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20e256:	31 c0                	xor    eax,eax
  20e258:	86 05 b2 1d 04 00    	xchg   BYTE PTR [rip+0x41db2],al        # 250010 <stderr_mutex>
  20e25e:	3c 01                	cmp    al,0x1
    if (!ok) {
  20e260:	75 72                	jne    20e2d4 <BmSelf.init.setup.tearDown.AtomicRmwOp.Add+0xc14>
  20e262:	49 83 c5 01          	add    r13,0x1
        while (rep < pSelf.repetitions) : (rep += 1) {
  20e266:	4c 3b 6c 24 60       	cmp    r13,QWORD PTR [rsp+0x60]
  20e26b:	0f 82 24 f9 ff ff    	jb     20db95 <BmSelf.init.setup.tearDown.AtomicRmwOp.Add+0x4d5>
  20e271:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
        try pSelf.reportStats(pSelf.results);
  20e276:	48 8d b4 24 88 00 00 	lea    rsi,[rsp+0x88]
  20e27d:	00 
  20e27e:	e8 bd 84 00 00       	call   216740 <Benchmark_reportStats>
  20e283:	66 85 c0             	test   ax,ax
  20e286:	75 37                	jne    20e2bf <BmSelf.init.setup.tearDown.AtomicRmwOp.Add+0xbff>
    var bmSelf = try bm.run(BmSelf);
    assert(bmSelf.init_count == 1);
  20e288:	48 83 7c 24 20 01    	cmp    QWORD PTR [rsp+0x20],0x1
  20e28e:	75 44                	jne    20e2d4 <BmSelf.init.setup.tearDown.AtomicRmwOp.Add+0xc14>
    assert(bmSelf.setup_count == 10);
  20e290:	48 83 7c 24 28 0a    	cmp    QWORD PTR [rsp+0x28],0xa
  20e296:	75 3c                	jne    20e2d4 <BmSelf.init.setup.tearDown.AtomicRmwOp.Add+0xc14>
    assert(bmSelf.benchmark_count > 1000000);
  20e298:	48 81 7c 24 30 40 42 	cmp    QWORD PTR [rsp+0x30],0xf4240
  20e29f:	0f 00 
  20e2a1:	76 31                	jbe    20e2d4 <BmSelf.init.setup.tearDown.AtomicRmwOp.Add+0xc14>
    assert(bmSelf.tearDown_count == 10);
  20e2a3:	48 83 7c 24 38 0a    	cmp    QWORD PTR [rsp+0x38],0xa
  20e2a9:	75 29                	jne    20e2d4 <BmSelf.init.setup.tearDown.AtomicRmwOp.Add+0xc14>
  20e2ab:	31 c0                	xor    eax,eax
  20e2ad:	eb 10                	jmp    20e2bf <BmSelf.init.setup.tearDown.AtomicRmwOp.Add+0xbff>
                switch (errno) {
  20e2af:	48 83 f9 16          	cmp    rcx,0x16
  20e2b3:	75 06                	jne    20e2bb <BmSelf.init.setup.tearDown.AtomicRmwOp.Add+0xbfb>
  20e2b5:	66 b8 02 00          	mov    ax,0x2
  20e2b9:	eb 04                	jmp    20e2bf <BmSelf.init.setup.tearDown.AtomicRmwOp.Add+0xbff>
  20e2bb:	66 b8 03 00          	mov    ax,0x3
    var bmSelf = try bm.run(BmSelf);
  20e2bf:	48 81 c4 18 01 00 00 	add    rsp,0x118
  20e2c6:	5b                   	pop    rbx
  20e2c7:	41 5c                	pop    r12
  20e2c9:	41 5d                	pop    r13
  20e2cb:	41 5e                	pop    r14
  20e2cd:	41 5f                	pop    r15
  20e2cf:	5d                   	pop    rbp
  20e2d0:	c5 f8 77             	vzeroupper 
  20e2d3:	c3                   	ret    
            @panic("assertion failure");
  20e2d4:	48 8d 3d 2d 0a 04 00 	lea    rdi,[rip+0x40a2d]        # 24ed08 <__unnamed_2>
  20e2db:	c5 f8 77             	vzeroupper 
  20e2de:	e8 3d 3d 00 00       	call   212020 <panic>
  20e2e3:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20e2ea:	84 00 00 00 00 00 

000000000020e2f0 <BmAdd>:
}

/// The inner loop is optimized away.
test "BmAdd" {
  20e2f0:	55                   	push   rbp
  20e2f1:	41 57                	push   r15
  20e2f3:	41 56                	push   r14
  20e2f5:	41 55                	push   r13
  20e2f7:	41 54                	push   r12
  20e2f9:	53                   	push   rbx
  20e2fa:	48 81 ec 08 01 00 00 	sub    rsp,0x108
  20e301:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20e308:	0f 1f 84 00 00 00 00 
  20e30f:	00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20e310:	b0 01                	mov    al,0x1
  20e312:	86 05 f8 1c 04 00    	xchg   BYTE PTR [rip+0x41cf8],al        # 250010 <stderr_mutex>
  20e318:	84 c0                	test   al,al
  20e31a:	75 f4                	jne    20e310 <BmAdd+0x20>
    if (stderr_stream) |st| {
  20e31c:	48 8b 3d e5 1c 04 00 	mov    rdi,QWORD PTR [rip+0x41ce5]        # 250008 <stderr_stream>
  20e323:	48 85 ff             	test   rdi,rdi
  20e326:	74 09                	je     20e331 <BmAdd+0x41>
  20e328:	48 8b 05 11 cd 03 00 	mov    rax,QWORD PTR [rip+0x3cd11]        # 24b040 <stderr_file_out_stream+0x8>
  20e32f:	eb 34                	jmp    20e365 <BmAdd+0x75>
        stderr_file = try io.getStdErr();
  20e331:	48 8d 05 f8 cc 03 00 	lea    rax,[rip+0x3ccf8]        # 24b030 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20e338:	48 89 05 f9 cc 03 00 	mov    QWORD PTR [rip+0x3ccf9],rax        # 24b038 <stderr_file_out_stream>
  20e33f:	48 8d 05 9a 16 01 00 	lea    rax,[rip+0x1169a]        # 21f9e0 <FileOutStream_writeFn>
  20e346:	48 89 05 f3 cc 03 00 	mov    QWORD PTR [rip+0x3ccf3],rax        # 24b040 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  20e34d:	c7 05 d9 cc 03 00 02 	mov    DWORD PTR [rip+0x3ccd9],0x2        # 24b030 <stderr_file>
  20e354:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20e357:	48 8d 3d e2 cc 03 00 	lea    rdi,[rip+0x3cce2]        # 24b040 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  20e35e:	48 89 3d a3 1c 04 00 	mov    QWORD PTR [rip+0x41ca3],rdi        # 250008 <stderr_stream>
  20e365:	48 8d 35 ac 0a 04 00 	lea    rsi,[rip+0x40aac]        # 24ee18 <__unnamed_3>
  20e36c:	ff d0                	call   rax
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20e36e:	31 c0                	xor    eax,eax
  20e370:	86 05 9a 1c 04 00    	xchg   BYTE PTR [rip+0x41c9a],al        # 250010 <stderr_mutex>
  20e376:	3c 01                	cmp    al,0x1
    if (!ok) {
  20e378:	0f 85 98 0c 00 00    	jne    20f016 <BmAdd+0xd26>

    // Since this is a test print a \n before we run
    warn("\n");

    // Create an instance of Benchmark, set 10 iterations and run
    var bm = Benchmark.init("BmAdd", std.debug.global_allocator);
  20e37e:	c5 f8 10 05 62 09 04 	vmovups xmm0,XMMWORD PTR [rip+0x40962]        # 24ece8 <__unnamed_11>
  20e385:	00 
  20e386:	c5 f8 29 44 24 60    	vmovaps XMMWORD PTR [rsp+0x60],xmm0
  20e38c:	b8 00 65 cd 1d       	mov    eax,0x1dcd6500
  20e391:	c4 e1 f9 6e c0       	vmovq  xmm0,rax
  20e396:	c5 f9 73 f8 08       	vpslldq xmm0,xmm0,0x8
  20e39b:	c5 f9 7f 44 24 70    	vmovdqa XMMWORD PTR [rsp+0x70],xmm0
  20e3a1:	48 b8 00 e8 76 48 17 	movabs rax,0x174876e800
  20e3a8:	00 00 00 
  20e3ab:	48 89 84 24 88 00 00 	mov    QWORD PTR [rsp+0x88],rax
  20e3b2:	00 
  20e3b3:	c5 fa 6f 05 05 aa ff 	vmovdqu xmm0,XMMWORD PTR [rip+0xffffffffffffaa05]        # 208dc0 <__unnamed_5>
  20e3ba:	ff 
  20e3bb:	c5 f9 7f 84 24 90 00 	vmovdqa XMMWORD PTR [rsp+0x90],xmm0
  20e3c2:	00 00 
  20e3c4:	48 8d 05 35 cc 03 00 	lea    rax,[rip+0x3cc35]        # 24b000 <global_fixed_allocator>
  20e3cb:	48 89 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rax
  20e3d2:	00 
  20e3d3:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  20e3d7:	c5 fa 7f 84 24 a8 00 	vmovdqu XMMWORD PTR [rsp+0xa8],xmm0
  20e3de:	00 00 
  20e3e0:	48 c7 84 24 b8 00 00 	mov    QWORD PTR [rsp+0xb8],0x0
  20e3e7:	00 00 00 00 00 
  20e3ec:	48 89 84 24 c0 00 00 	mov    QWORD PTR [rsp+0xc0],rax
  20e3f3:	00 
    bm.repetitions = 10;
  20e3f4:	48 c7 84 24 80 00 00 	mov    QWORD PTR [rsp+0x80],0xa
  20e3fb:	00 0a 00 00 00 
  20e400:	b0 01                	mov    al,0x1
  20e402:	bb 01 00 00 00       	mov    ebx,0x1
  20e407:	31 ed                	xor    ebp,ebp
  20e409:	c5 f8 10 0d af a9 ff 	vmovups xmm1,XMMWORD PTR [rip+0xffffffffffffa9af]        # 208dc0 <__unnamed_5>
  20e410:	ff 
  20e411:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
  20e416:	45 31 ed             	xor    r13d,r13d
  20e419:	89 44 24 24          	mov    DWORD PTR [rsp+0x24],eax
                var ts: posix.timespec = undefined;
  20e41d:	c5 f8 29 4c 24 30    	vmovaps XMMWORD PTR [rsp+0x30],xmm1
  20e423:	b8 e5 00 00 00       	mov    eax,0xe5
  20e428:	bf 01 00 00 00       	mov    edi,0x1
  20e42d:	49 89 f7             	mov    r15,rsi
  20e430:	0f 05                	syscall 
  20e432:	48 89 c1             	mov    rcx,rax
  20e435:	48 f7 d9             	neg    rcx
  20e438:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  20e43e:	48 0f 46 cd          	cmovbe rcx,rbp
                switch (errno) {
  20e442:	48 85 c9             	test   rcx,rcx
  20e445:	0f 85 a3 0b 00 00    	jne    20efee <BmAdd+0xcfe>
        const f = @atomicLoad(@typeOf(init_vdso_clock_gettime), &vdso_clock_gettime, builtin.AtomicOrder.Unordered);
  20e44b:	48 8b 05 f6 cb 03 00 	mov    rax,QWORD PTR [rip+0x3cbf6]        # 24b048 <vdso_clock_gettime>
        if (@ptrToInt(f) != 0) {
  20e452:	48 85 c0             	test   rax,rax
  20e455:	4c 89 fd             	mov    rbp,r15
  20e458:	74 21                	je     20e47b <BmAdd+0x18b>
            const rc = f(clk_id, tp);
  20e45a:	bf 01 00 00 00       	mov    edi,0x1
  20e45f:	48 89 ee             	mov    rsi,rbp
  20e462:	ff d0                	call   rax
            switch (rc) {
  20e464:	48 83 f8 ea          	cmp    rax,0xffffffffffffffea
  20e468:	0f 84 42 04 00 00    	je     20e8b0 <BmAdd+0x5c0>
  20e46e:	48 85 c0             	test   rax,rax
  20e471:	c5 f8 10 0d 47 a9 ff 	vmovups xmm1,XMMWORD PTR [rip+0xffffffffffffa947]        # 208dc0 <__unnamed_5>
  20e478:	ff 
  20e479:	74 0f                	je     20e48a <BmAdd+0x19a>
  20e47b:	b8 e4 00 00 00       	mov    eax,0xe4
  20e480:	bf 01 00 00 00       	mov    edi,0x1
  20e485:	48 89 ee             	mov    rsi,rbp
  20e488:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  20e48a:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
                if (errno != 0) return std.os.unexpectedErrorPosix(errno);
  20e490:	0f 83 64 0b 00 00    	jae    20effa <BmAdd+0xd0a>
                self.start_time = @intCast(u64, ts.tv_sec) * u64(ns_per_s) + @intCast(u64, ts.tv_nsec);
  20e496:	48 8b 6c 24 30       	mov    rbp,QWORD PTR [rsp+0x30]
  20e49b:	4c 8b 64 24 38       	mov    r12,QWORD PTR [rsp+0x38]
        var ts: posix.timespec = undefined;
  20e4a0:	c5 f8 29 4c 24 30    	vmovaps XMMWORD PTR [rsp+0x30],xmm1
        const f = @atomicLoad(@typeOf(init_vdso_clock_gettime), &vdso_clock_gettime, builtin.AtomicOrder.Unordered);
  20e4a6:	48 8b 05 9b cb 03 00 	mov    rax,QWORD PTR [rip+0x3cb9b]        # 24b048 <vdso_clock_gettime>
        if (@ptrToInt(f) != 0) {
  20e4ad:	48 85 c0             	test   rax,rax
  20e4b0:	74 21                	je     20e4d3 <BmAdd+0x1e3>
            const rc = f(clk_id, tp);
  20e4b2:	bf 01 00 00 00       	mov    edi,0x1
  20e4b7:	4c 89 fe             	mov    rsi,r15
  20e4ba:	ff d0                	call   rax
            switch (rc) {
  20e4bc:	48 83 f8 ea          	cmp    rax,0xffffffffffffffea
  20e4c0:	0f 84 03 04 00 00    	je     20e8c9 <BmAdd+0x5d9>
  20e4c6:	48 85 c0             	test   rax,rax
  20e4c9:	c5 f8 10 0d ef a8 ff 	vmovups xmm1,XMMWORD PTR [rip+0xffffffffffffa8ef]        # 208dc0 <__unnamed_5>
  20e4d0:	ff 
  20e4d1:	74 0f                	je     20e4e2 <BmAdd+0x1f2>
  20e4d3:	b8 e4 00 00 00       	mov    eax,0xe4
  20e4d8:	bf 01 00 00 00       	mov    edi,0x1
  20e4dd:	4c 89 fe             	mov    rsi,r15
  20e4e0:	0f 05                	syscall 
  20e4e2:	4c 89 6c 24 28       	mov    QWORD PTR [rsp+0x28],r13
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  20e4e7:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
  20e4ed:	0f 83 23 0b 00 00    	jae    20f016 <BmAdd+0xd26>
        return @intCast(u64, ts.tv_sec) * u64(ns_per_s) + @intCast(u64, ts.tv_nsec);
  20e4f3:	48 8b 44 24 30       	mov    rax,QWORD PTR [rsp+0x30]
  20e4f8:	48 29 e8             	sub    rax,rbp
  20e4fb:	48 8b 4c 24 38       	mov    rcx,QWORD PTR [rsp+0x38]
  20e500:	4c 29 e1             	sub    rcx,r12
  20e503:	48 69 c0 00 ca 9a 3b 	imul   rax,rax,0x3b9aca00
        var clock = clockNative() - self.start_time;
  20e50a:	48 01 c8             	add    rax,rcx
    pub fn init(seed: u64) SplitMix64 {
        return SplitMix64{ .s = seed };
    }

    pub fn next(self: *SplitMix64) u64 {
        self.s +%= 0x9e3779b97f4a7c15;
  20e50d:	48 b9 15 7c 4a 7f b9 	movabs rcx,0x9e3779b97f4a7c15
  20e514:	79 37 9e 
  20e517:	48 8d 0c 08          	lea    rcx,[rax+rcx*1]

        var z = self.s;
        z = (z ^ (z >> 30)) *% 0xbf58476d1ce4e5b9;
  20e51b:	48 89 ca             	mov    rdx,rcx
  20e51e:	48 c1 ea 1e          	shr    rdx,0x1e
  20e522:	48 31 ca             	xor    rdx,rcx
  20e525:	48 b9 b9 e5 e4 1c 6d 	movabs rcx,0xbf58476d1ce4e5b9
  20e52c:	47 58 bf 
  20e52f:	48 89 ce             	mov    rsi,rcx
  20e532:	48 0f af d6          	imul   rdx,rsi
        z = (z ^ (z >> 27)) *% 0x94d049bb133111eb;
  20e536:	48 89 d1             	mov    rcx,rdx
  20e539:	48 c1 e9 1b          	shr    rcx,0x1b
  20e53d:	48 31 d1             	xor    rcx,rdx
  20e540:	48 ba eb 11 31 13 bb 	movabs rdx,0x94d049bb133111eb
  20e547:	49 d0 94 
  20e54a:	48 89 d7             	mov    rdi,rdx
  20e54d:	48 0f af cf          	imul   rcx,rdi
        return z ^ (z >> 31);
  20e551:	48 89 ca             	mov    rdx,rcx
  20e554:	48 c1 ea 1f          	shr    rdx,0x1f
  20e558:	48 31 ca             	xor    rdx,rcx
        self.s +%= 0x9e3779b97f4a7c15;
  20e55b:	48 b9 2a f8 94 fe 72 	movabs rcx,0x3c6ef372fe94f82a
  20e562:	f3 6e 3c 
  20e565:	48 01 c8             	add    rax,rcx
        z = (z ^ (z >> 30)) *% 0xbf58476d1ce4e5b9;
  20e568:	48 89 c1             	mov    rcx,rax
  20e56b:	48 c1 e9 1e          	shr    rcx,0x1e
  20e56f:	48 31 c1             	xor    rcx,rax
  20e572:	48 0f af ce          	imul   rcx,rsi
        z = (z ^ (z >> 27)) *% 0x94d049bb133111eb;
  20e576:	48 89 c8             	mov    rax,rcx
  20e579:	48 c1 e8 1b          	shr    rax,0x1b
  20e57d:	48 31 c8             	xor    rax,rcx
  20e580:	48 0f af c7          	imul   rax,rdi
        return z ^ (z >> 31);
  20e584:	49 89 c4             	mov    r12,rax
  20e587:	49 c1 ec 1f          	shr    r12,0x1f
  20e58b:	49 31 c4             	xor    r12,rax
    fn next(self: *Xoroshiro128) u64 {
        const s0 = self.s[0];
        var s1 = self.s[1];
        const r = s0 +% s1;

        s1 ^= s0;
  20e58e:	4c 89 e0             	mov    rax,r12
  20e591:	48 31 d0             	xor    rax,rdx
pub fn rotl(comptime T: type, x: T, r: var) T {
    if (T.is_signed) {
        @compileError("cannot rotate signed integer");
    } else {
        const ar = @mod(r, T.bit_count);
        return shl(T, x, ar) | shr(T, x, T.bit_count - ar);
  20e594:	c4 e3 fb f0 ca 09    	rorx   rcx,rdx,0x9
        self.s[0] = math.rotl(u64, s0, u8(55)) ^ s1 ^ (s1 << 14);
  20e59a:	48 31 c1             	xor    rcx,rax
  20e59d:	c4 e3 fb f0 f0 1c    	rorx   rsi,rax,0x1c
  20e5a3:	48 c1 e0 0e          	shl    rax,0xe
  20e5a7:	48 31 c8             	xor    rax,rcx
            while (iterations <= pSelf.max_iterations) {
  20e5aa:	4c 8b ac 24 88 00 00 	mov    r13,QWORD PTR [rsp+0x88]
  20e5b1:	00 
        const r = s0 +% s1;
  20e5b2:	49 01 d4             	add    r12,rdx
  20e5b5:	49 01 f4             	add    r12,rsi
  20e5b8:	49 01 c4             	add    r12,rax
  20e5bb:	4c 39 eb             	cmp    rbx,r13
  20e5be:	bd 00 00 00 00       	mov    ebp,0x0
  20e5c3:	76 1e                	jbe    20e5e3 <BmAdd+0x2f3>
  20e5c5:	e9 50 03 00 00       	jmp    20e91a <BmAdd+0x62a>
  20e5ca:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
                        warn("iteratons:{} numer:{} denom:{}\n", iterations, numer, denom);
  20e5d0:	48 89 df             	mov    rdi,rbx
  20e5d3:	48 89 ca             	mov    rdx,rcx
  20e5d6:	e8 95 75 00 00       	call   215b70 <warn.36>
  20e5db:	c5 f8 10 0d dd a7 ff 	vmovups xmm1,XMMWORD PTR [rip+0xffffffffffffa7dd]        # 208dc0 <__unnamed_5>
  20e5e2:	ff 
                var ts: posix.timespec = undefined;
  20e5e3:	c5 f8 29 4c 24 30    	vmovaps XMMWORD PTR [rsp+0x30],xmm1
  20e5e9:	b8 e5 00 00 00       	mov    eax,0xe5
  20e5ee:	bf 01 00 00 00       	mov    edi,0x1
  20e5f3:	4c 89 fe             	mov    rsi,r15
  20e5f6:	0f 05                	syscall 
  20e5f8:	48 89 c1             	mov    rcx,rax
  20e5fb:	48 f7 d9             	neg    rcx
  20e5fe:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  20e604:	48 0f 46 cd          	cmovbe rcx,rbp
                switch (errno) {
  20e608:	48 85 c9             	test   rcx,rcx
  20e60b:	0f 85 dd 09 00 00    	jne    20efee <BmAdd+0xcfe>
        const f = @atomicLoad(@typeOf(init_vdso_clock_gettime), &vdso_clock_gettime, builtin.AtomicOrder.Unordered);
  20e611:	48 8b 05 30 ca 03 00 	mov    rax,QWORD PTR [rip+0x3ca30]        # 24b048 <vdso_clock_gettime>
        if (@ptrToInt(f) != 0) {
  20e618:	48 85 c0             	test   rax,rax
  20e61b:	4c 89 fd             	mov    rbp,r15
  20e61e:	74 21                	je     20e641 <BmAdd+0x351>
            const rc = f(clk_id, tp);
  20e620:	bf 01 00 00 00       	mov    edi,0x1
  20e625:	48 89 ee             	mov    rsi,rbp
  20e628:	ff d0                	call   rax
            switch (rc) {
  20e62a:	48 83 f8 ea          	cmp    rax,0xffffffffffffffea
  20e62e:	0f 84 3c 02 00 00    	je     20e870 <BmAdd+0x580>
  20e634:	48 85 c0             	test   rax,rax
  20e637:	c5 f8 10 0d 81 a7 ff 	vmovups xmm1,XMMWORD PTR [rip+0xffffffffffffa781]        # 208dc0 <__unnamed_5>
  20e63e:	ff 
  20e63f:	74 0f                	je     20e650 <BmAdd+0x360>
  20e641:	b8 e4 00 00 00       	mov    eax,0xe4
  20e646:	bf 01 00 00 00       	mov    edi,0x1
  20e64b:	48 89 ee             	mov    rsi,rbp
  20e64e:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  20e650:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
                if (errno != 0) return std.os.unexpectedErrorPosix(errno);
  20e656:	0f 83 9e 09 00 00    	jae    20effa <BmAdd+0xd0a>
                self.start_time = @intCast(u64, ts.tv_sec) * u64(ns_per_s) + @intCast(u64, ts.tv_nsec);
  20e65c:	c5 f9 6f 54 24 30    	vmovdqa xmm2,XMMWORD PTR [rsp+0x30]
        while (iter > 0) : (iter -= 1) {
  20e662:	48 85 db             	test   rbx,rbx
  20e665:	4d 0f 45 f4          	cmovne r14,r12
        var ts: posix.timespec = undefined;
  20e669:	c5 f8 29 4c 24 30    	vmovaps XMMWORD PTR [rsp+0x30],xmm1
        const f = @atomicLoad(@typeOf(init_vdso_clock_gettime), &vdso_clock_gettime, builtin.AtomicOrder.Unordered);
  20e66f:	48 8b 05 d2 c9 03 00 	mov    rax,QWORD PTR [rip+0x3c9d2]        # 24b048 <vdso_clock_gettime>
        if (@ptrToInt(f) != 0) {
  20e676:	48 85 c0             	test   rax,rax
  20e679:	74 33                	je     20e6ae <BmAdd+0x3be>
  20e67b:	c5 f9 7f 94 24 d0 00 	vmovdqa XMMWORD PTR [rsp+0xd0],xmm2
  20e682:	00 00 
            const rc = f(clk_id, tp);
  20e684:	bf 01 00 00 00       	mov    edi,0x1
  20e689:	48 89 ee             	mov    rsi,rbp
  20e68c:	ff d0                	call   rax
            switch (rc) {
  20e68e:	48 83 f8 ea          	cmp    rax,0xffffffffffffffea
  20e692:	0f 84 f1 01 00 00    	je     20e889 <BmAdd+0x599>
  20e698:	48 85 c0             	test   rax,rax
  20e69b:	c5 f8 10 0d 1d a7 ff 	vmovups xmm1,XMMWORD PTR [rip+0xffffffffffffa71d]        # 208dc0 <__unnamed_5>
  20e6a2:	ff 
  20e6a3:	c5 f9 6f 94 24 d0 00 	vmovdqa xmm2,XMMWORD PTR [rsp+0xd0]
  20e6aa:	00 00 
  20e6ac:	74 0f                	je     20e6bd <BmAdd+0x3cd>
  20e6ae:	b8 e4 00 00 00       	mov    eax,0xe4
  20e6b3:	bf 01 00 00 00       	mov    edi,0x1
  20e6b8:	48 89 ee             	mov    rsi,rbp
  20e6bb:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  20e6bd:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
  20e6c3:	0f 83 4d 09 00 00    	jae    20f016 <BmAdd+0xd26>
        return @intCast(u64, ts.tv_sec) * u64(ns_per_s) + @intCast(u64, ts.tv_nsec);
  20e6c9:	c5 f9 6f 44 24 30    	vmovdqa xmm0,XMMWORD PTR [rsp+0x30]
  20e6cf:	c5 f9 fb c2          	vpsubq xmm0,xmm0,xmm2
  20e6d3:	c4 e1 f9 7e c0       	vmovq  rax,xmm0
        var clock = clockNative() - self.start_time;
  20e6d8:	c4 e3 f9 16 c5 01    	vpextrq rbp,xmm0,0x1
  20e6de:	48 69 c0 00 ca 9a 3b 	imul   rax,rax,0x3b9aca00
  20e6e5:	48 01 c5             	add    rbp,rax
                if ((run_time_ns >= pSelf.min_runtime_ns) or (iterations >= pSelf.max_iterations)) {
  20e6e8:	48 3b 6c 24 78       	cmp    rbp,QWORD PTR [rsp+0x78]
  20e6ed:	0f 83 f4 01 00 00    	jae    20e8e7 <BmAdd+0x5f7>
  20e6f3:	4c 39 eb             	cmp    rbx,r13
  20e6f6:	0f 83 eb 01 00 00    	jae    20e8e7 <BmAdd+0x5f7>
                    if (pSelf.logl >= 1) {
  20e6fc:	48 83 7c 24 70 00    	cmp    QWORD PTR [rsp+0x70],0x0
  20e702:	0f 84 c6 00 00 00    	je     20e7ce <BmAdd+0x4de>
                            Result {.run_time_ns = run_time_ns, .iterations = iterations});
  20e708:	48 89 ac 24 e8 00 00 	mov    QWORD PTR [rsp+0xe8],rbp
  20e70f:	00 
  20e710:	48 89 9c 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rbx
  20e717:	00 
                        try pSelf.report(
  20e718:	48 8d 7c 24 60       	lea    rdi,[rsp+0x60]
  20e71d:	48 8d b4 24 e8 00 00 	lea    rsi,[rsp+0xe8]
  20e724:	00 
  20e725:	e8 36 53 00 00       	call   213a60 <Benchmark_report>
  20e72a:	66 85 c0             	test   ax,ax
  20e72d:	0f 85 cb 08 00 00    	jne    20effe <BmAdd+0xd0e>
  20e733:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20e73a:	84 00 00 00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20e740:	b0 01                	mov    al,0x1
  20e742:	86 05 c8 18 04 00    	xchg   BYTE PTR [rip+0x418c8],al        # 250010 <stderr_mutex>
  20e748:	84 c0                	test   al,al
  20e74a:	75 f4                	jne    20e740 <BmAdd+0x450>
    if (stderr_stream) |st| {
  20e74c:	48 8b 3d b5 18 04 00 	mov    rdi,QWORD PTR [rip+0x418b5]        # 250008 <stderr_stream>
  20e753:	48 85 ff             	test   rdi,rdi
  20e756:	74 18                	je     20e770 <BmAdd+0x480>
  20e758:	48 8b 0d e1 c8 03 00 	mov    rcx,QWORD PTR [rip+0x3c8e1]        # 24b040 <stderr_file_out_stream+0x8>
  20e75f:	eb 4c                	jmp    20e7ad <BmAdd+0x4bd>
  20e761:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20e768:	0f 1f 84 00 00 00 00 
  20e76f:	00 
        stderr_file = try io.getStdErr();
  20e770:	c7 05 b6 c8 03 00 02 	mov    DWORD PTR [rip+0x3c8b6],0x2        # 24b030 <stderr_file>
  20e777:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20e77a:	48 8d 05 af c8 03 00 	lea    rax,[rip+0x3c8af]        # 24b030 <stderr_file>
  20e781:	48 89 05 b0 c8 03 00 	mov    QWORD PTR [rip+0x3c8b0],rax        # 24b038 <stderr_file_out_stream>
  20e788:	48 8d 05 51 12 01 00 	lea    rax,[rip+0x11251]        # 21f9e0 <FileOutStream_writeFn>
  20e78f:	48 89 05 aa c8 03 00 	mov    QWORD PTR [rip+0x3c8aa],rax        # 24b040 <stderr_file_out_stream+0x8>
  20e796:	48 8d 0d a3 c8 03 00 	lea    rcx,[rip+0x3c8a3]        # 24b040 <stderr_file_out_stream+0x8>
  20e79d:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20e7a0:	48 89 15 61 18 04 00 	mov    QWORD PTR [rip+0x41861],rdx        # 250008 <stderr_stream>
  20e7a7:	48 89 c1             	mov    rcx,rax
  20e7aa:	48 89 d7             	mov    rdi,rdx
  20e7ad:	48 8d 35 64 06 04 00 	lea    rsi,[rip+0x40664]        # 24ee18 <__unnamed_3>
  20e7b4:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20e7b6:	31 c0                	xor    eax,eax
  20e7b8:	86 05 52 18 04 00    	xchg   BYTE PTR [rip+0x41852],al        # 250010 <stderr_mutex>
  20e7be:	3c 01                	cmp    al,0x1
  20e7c0:	c5 f8 10 0d f8 a5 ff 	vmovups xmm1,XMMWORD PTR [rip+0xffffffffffffa5f8]        # 208dc0 <__unnamed_5>
  20e7c7:	ff 
    if (!ok) {
  20e7c8:	0f 85 48 08 00 00    	jne    20f016 <BmAdd+0xd26>
                    if (run_time_ns < 1000) {
  20e7ce:	48 81 fd e8 03 00 00 	cmp    rbp,0x3e8
  20e7d5:	73 19                	jae    20e7f0 <BmAdd+0x500>
  20e7d7:	b9 01 00 00 00       	mov    ecx,0x1
  20e7dc:	be e8 03 00 00       	mov    esi,0x3e8
  20e7e1:	eb 3a                	jmp    20e81d <BmAdd+0x52d>
  20e7e3:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20e7ea:	84 00 00 00 00 00 
                    } else if (run_time_ns < (pSelf.min_runtime_ns / 10)) {
  20e7f0:	48 ba cd cc cc cc cc 	movabs rdx,0xcccccccccccccccd
  20e7f7:	cc cc cc 
  20e7fa:	c4 e2 fb f6 4c 24 78 	mulx   rcx,rax,QWORD PTR [rsp+0x78]
  20e801:	48 c1 e9 03          	shr    rcx,0x3
  20e805:	31 c0                	xor    eax,eax
  20e807:	48 39 cd             	cmp    rbp,rcx
  20e80a:	0f 93 c0             	setae  al
  20e80d:	48 8d 0c c0          	lea    rcx,[rax+rax*8]
  20e811:	48 83 c1 01          	add    rcx,0x1
  20e815:	48 8d 34 85 0a 00 00 	lea    rsi,[rax*4+0xa]
  20e81c:	00 
  20e81d:	31 ed                	xor    ebp,ebp
                    iterations = (iterations * numer) / denom;
  20e81f:	48 0f af de          	imul   rbx,rsi
  20e823:	48 89 d8             	mov    rax,rbx
  20e826:	48 c1 e8 20          	shr    rax,0x20
  20e82a:	74 14                	je     20e840 <BmAdd+0x550>
  20e82c:	31 d2                	xor    edx,edx
  20e82e:	48 89 d8             	mov    rax,rbx
  20e831:	48 f7 f1             	div    rcx
  20e834:	48 89 c3             	mov    rbx,rax
  20e837:	eb 0f                	jmp    20e848 <BmAdd+0x558>
  20e839:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  20e840:	31 d2                	xor    edx,edx
  20e842:	89 d8                	mov    eax,ebx
  20e844:	f7 f1                	div    ecx
  20e846:	89 c3                	mov    ebx,eax
                    if (iterations > pSelf.max_iterations) {
  20e848:	4c 8b ac 24 88 00 00 	mov    r13,QWORD PTR [rsp+0x88]
  20e84f:	00 
  20e850:	4c 39 eb             	cmp    rbx,r13
  20e853:	49 0f 47 dd          	cmova  rbx,r13
                    if (pSelf.logl >= 2) {
  20e857:	48 83 7c 24 70 02    	cmp    QWORD PTR [rsp+0x70],0x2
  20e85d:	0f 82 80 fd ff ff    	jb     20e5e3 <BmAdd+0x2f3>
  20e863:	e9 68 fd ff ff       	jmp    20e5d0 <BmAdd+0x2e0>
  20e868:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  20e86f:	00 
  20e870:	c5 f8 10 0d 48 a5 ff 	vmovups xmm1,XMMWORD PTR [rip+0xffffffffffffa548]        # 208dc0 <__unnamed_5>
  20e877:	ff 
  20e878:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
  20e87e:	0f 82 d8 fd ff ff    	jb     20e65c <BmAdd+0x36c>
  20e884:	e9 71 07 00 00       	jmp    20effa <BmAdd+0xd0a>
  20e889:	c5 f8 10 0d 2f a5 ff 	vmovups xmm1,XMMWORD PTR [rip+0xffffffffffffa52f]        # 208dc0 <__unnamed_5>
  20e890:	ff 
  20e891:	c5 f9 6f 94 24 d0 00 	vmovdqa xmm2,XMMWORD PTR [rsp+0xd0]
  20e898:	00 00 
  20e89a:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
  20e8a0:	0f 82 23 fe ff ff    	jb     20e6c9 <BmAdd+0x3d9>
  20e8a6:	e9 6b 07 00 00       	jmp    20f016 <BmAdd+0xd26>
  20e8ab:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  20e8b0:	c5 f8 10 0d 08 a5 ff 	vmovups xmm1,XMMWORD PTR [rip+0xffffffffffffa508]        # 208dc0 <__unnamed_5>
  20e8b7:	ff 
  20e8b8:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
                if (errno != 0) return std.os.unexpectedErrorPosix(errno);
  20e8be:	0f 82 d2 fb ff ff    	jb     20e496 <BmAdd+0x1a6>
  20e8c4:	e9 31 07 00 00       	jmp    20effa <BmAdd+0xd0a>
  20e8c9:	c5 f8 10 0d ef a4 ff 	vmovups xmm1,XMMWORD PTR [rip+0xffffffffffffa4ef]        # 208dc0 <__unnamed_5>
  20e8d0:	ff 
  20e8d1:	4c 89 6c 24 28       	mov    QWORD PTR [rsp+0x28],r13
  20e8d6:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
  20e8dc:	0f 82 11 fc ff ff    	jb     20e4f3 <BmAdd+0x203>
  20e8e2:	e9 2f 07 00 00       	jmp    20f016 <BmAdd+0xd26>
                            Result { .run_time_ns = run_time_ns, .iterations = iterations});
  20e8e7:	48 89 ac 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],rbp
  20e8ee:	00 
  20e8ef:	48 89 9c 24 00 01 00 	mov    QWORD PTR [rsp+0x100],rbx
  20e8f6:	00 
                    try pSelf.results.append(
  20e8f7:	48 8d bc 24 a8 00 00 	lea    rdi,[rsp+0xa8]
  20e8fe:	00 
  20e8ff:	48 8d b4 24 f8 00 00 	lea    rsi,[rsp+0xf8]
  20e906:	00 
  20e907:	e8 e4 4f 00 00       	call   2138f0 <AlignedArrayList(Result,8)_append>
  20e90c:	66 85 c0             	test   ax,ax
  20e90f:	bd 00 00 00 00       	mov    ebp,0x0
  20e914:	0f 85 e4 06 00 00    	jne    20effe <BmAdd+0xd0e>
            if (pSelf.r != (u64(pSelf.a) + u64(pSelf.b))) return error.Failed;
  20e91a:	4d 39 f4             	cmp    r12,r14
  20e91d:	4c 8d 6c 24 10       	lea    r13,[rsp+0x10]
                    try bm.tearDown();
  20e922:	0f 85 e8 06 00 00    	jne    20f010 <BmAdd+0xd20>
            if (once) {
  20e928:	f6 44 24 24 01       	test   BYTE PTR [rsp+0x24],0x1
  20e92d:	4c 8d 74 24 0f       	lea    r14,[rsp+0xf]
  20e932:	0f 84 cf 05 00 00    	je     20ef07 <BmAdd+0xc17>
                try leftJustified(22, "name repetitions:{}", pSelf.repetitions);
  20e938:	48 8b bc 24 80 00 00 	mov    rdi,QWORD PTR [rsp+0x80]
  20e93f:	00 
  20e940:	e8 9b 75 00 00       	call   215ee0 <Benchmark_leftJustified>
  20e945:	66 85 c0             	test   ax,ax
  20e948:	0f 85 b0 06 00 00    	jne    20effe <BmAdd+0xd0e>
                try rightJustified(14, "{}", "iterations");
  20e94e:	e8 2d 78 00 00       	call   216180 <Benchmark_rightJustified>
  20e953:	66 85 c0             	test   ax,ax
  20e956:	0f 85 a2 06 00 00    	jne    20effe <BmAdd+0xd0e>
        var buffer: [40]u8 = undefined;
  20e95c:	c5 fe 6f 05 37 6c ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffff6c37]        # 20559b <__unnamed_7>
  20e963:	ff 
  20e964:	c5 fe 7f 44 24 30    	vmovdqu YMMWORD PTR [rsp+0x30],ymm0
  20e96a:	48 8b 05 4a 6c ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffff6c4a]        # 2055bb <__unnamed_7+0x20>
  20e971:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
  20e976:	c7 44 24 30 74 69 6d 	mov    DWORD PTR [rsp+0x30],0x656d6974
  20e97d:	65 
  20e97e:	66 90                	xchg   ax,ax
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20e980:	b0 01                	mov    al,0x1
  20e982:	86 05 88 16 04 00    	xchg   BYTE PTR [rip+0x41688],al        # 250010 <stderr_mutex>
  20e988:	84 c0                	test   al,al
  20e98a:	75 f4                	jne    20e980 <BmAdd+0x690>
    if (stderr_stream) |st| {
  20e98c:	48 8b 3d 75 16 04 00 	mov    rdi,QWORD PTR [rip+0x41675]        # 250008 <stderr_stream>
  20e993:	48 85 ff             	test   rdi,rdi
  20e996:	74 09                	je     20e9a1 <BmAdd+0x6b1>
  20e998:	48 8b 0d a1 c6 03 00 	mov    rcx,QWORD PTR [rip+0x3c6a1]        # 24b040 <stderr_file_out_stream+0x8>
  20e99f:	eb 3d                	jmp    20e9de <BmAdd+0x6ee>
        stderr_file = try io.getStdErr();
  20e9a1:	c7 05 85 c6 03 00 02 	mov    DWORD PTR [rip+0x3c685],0x2        # 24b030 <stderr_file>
  20e9a8:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20e9ab:	48 8d 05 7e c6 03 00 	lea    rax,[rip+0x3c67e]        # 24b030 <stderr_file>
  20e9b2:	48 89 05 7f c6 03 00 	mov    QWORD PTR [rip+0x3c67f],rax        # 24b038 <stderr_file_out_stream>
  20e9b9:	48 8d 05 20 10 01 00 	lea    rax,[rip+0x11020]        # 21f9e0 <FileOutStream_writeFn>
  20e9c0:	48 89 05 79 c6 03 00 	mov    QWORD PTR [rip+0x3c679],rax        # 24b040 <stderr_file_out_stream+0x8>
  20e9c7:	48 8d 0d 72 c6 03 00 	lea    rcx,[rip+0x3c672]        # 24b040 <stderr_file_out_stream+0x8>
  20e9ce:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20e9d1:	48 89 15 30 16 04 00 	mov    QWORD PTR [rip+0x41630],rdx        # 250008 <stderr_stream>
  20e9d8:	48 89 c1             	mov    rcx,rax
  20e9db:	48 89 d7             	mov    rdi,rdx
  20e9de:	c6 44 24 0f 20       	mov    BYTE PTR [rsp+0xf],0x20
    return output(context, (*[1]u8)(&c)[0..]);
  20e9e3:	4c 89 74 24 10       	mov    QWORD PTR [rsp+0x10],r14
  20e9e8:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  20e9ef:	00 00 
  20e9f1:	4c 89 ee             	mov    rsi,r13
  20e9f4:	c5 f8 77             	vzeroupper 
  20e9f7:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20e9f9:	31 c0                	xor    eax,eax
  20e9fb:	86 05 0f 16 04 00    	xchg   BYTE PTR [rip+0x4160f],al        # 250010 <stderr_mutex>
  20ea01:	3c 01                	cmp    al,0x1
    if (!ok) {
  20ea03:	0f 85 0d 06 00 00    	jne    20f016 <BmAdd+0xd26>
  20ea09:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20ea10:	b0 01                	mov    al,0x1
  20ea12:	86 05 f8 15 04 00    	xchg   BYTE PTR [rip+0x415f8],al        # 250010 <stderr_mutex>
  20ea18:	84 c0                	test   al,al
  20ea1a:	75 f4                	jne    20ea10 <BmAdd+0x720>
    if (stderr_stream) |st| {
  20ea1c:	48 8b 3d e5 15 04 00 	mov    rdi,QWORD PTR [rip+0x415e5]        # 250008 <stderr_stream>
  20ea23:	48 85 ff             	test   rdi,rdi
  20ea26:	74 09                	je     20ea31 <BmAdd+0x741>
  20ea28:	48 8b 0d 11 c6 03 00 	mov    rcx,QWORD PTR [rip+0x3c611]        # 24b040 <stderr_file_out_stream+0x8>
  20ea2f:	eb 3d                	jmp    20ea6e <BmAdd+0x77e>
        stderr_file = try io.getStdErr();
  20ea31:	c7 05 f5 c5 03 00 02 	mov    DWORD PTR [rip+0x3c5f5],0x2        # 24b030 <stderr_file>
  20ea38:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20ea3b:	48 8d 05 ee c5 03 00 	lea    rax,[rip+0x3c5ee]        # 24b030 <stderr_file>
  20ea42:	48 89 05 ef c5 03 00 	mov    QWORD PTR [rip+0x3c5ef],rax        # 24b038 <stderr_file_out_stream>
  20ea49:	48 8d 05 90 0f 01 00 	lea    rax,[rip+0x10f90]        # 21f9e0 <FileOutStream_writeFn>
  20ea50:	48 89 05 e9 c5 03 00 	mov    QWORD PTR [rip+0x3c5e9],rax        # 24b040 <stderr_file_out_stream+0x8>
  20ea57:	48 8d 0d e2 c5 03 00 	lea    rcx,[rip+0x3c5e2]        # 24b040 <stderr_file_out_stream+0x8>
  20ea5e:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20ea61:	48 89 15 a0 15 04 00 	mov    QWORD PTR [rip+0x415a0],rdx        # 250008 <stderr_stream>
  20ea68:	48 89 c1             	mov    rcx,rax
  20ea6b:	48 89 d7             	mov    rdi,rdx
  20ea6e:	c6 44 24 0f 20       	mov    BYTE PTR [rsp+0xf],0x20
  20ea73:	4c 89 74 24 10       	mov    QWORD PTR [rsp+0x10],r14
  20ea78:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  20ea7f:	00 00 
  20ea81:	4c 89 ee             	mov    rsi,r13
  20ea84:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20ea86:	31 c0                	xor    eax,eax
  20ea88:	86 05 82 15 04 00    	xchg   BYTE PTR [rip+0x41582],al        # 250010 <stderr_mutex>
  20ea8e:	3c 01                	cmp    al,0x1
    if (!ok) {
  20ea90:	0f 85 80 05 00 00    	jne    20f016 <BmAdd+0xd26>
  20ea96:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  20ea9d:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20eaa0:	b0 01                	mov    al,0x1
  20eaa2:	86 05 68 15 04 00    	xchg   BYTE PTR [rip+0x41568],al        # 250010 <stderr_mutex>
  20eaa8:	84 c0                	test   al,al
  20eaaa:	75 f4                	jne    20eaa0 <BmAdd+0x7b0>
    if (stderr_stream) |st| {
  20eaac:	48 8b 3d 55 15 04 00 	mov    rdi,QWORD PTR [rip+0x41555]        # 250008 <stderr_stream>
  20eab3:	48 85 ff             	test   rdi,rdi
  20eab6:	74 09                	je     20eac1 <BmAdd+0x7d1>
  20eab8:	48 8b 0d 81 c5 03 00 	mov    rcx,QWORD PTR [rip+0x3c581]        # 24b040 <stderr_file_out_stream+0x8>
  20eabf:	eb 3d                	jmp    20eafe <BmAdd+0x80e>
        stderr_file = try io.getStdErr();
  20eac1:	c7 05 65 c5 03 00 02 	mov    DWORD PTR [rip+0x3c565],0x2        # 24b030 <stderr_file>
  20eac8:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20eacb:	48 8d 05 5e c5 03 00 	lea    rax,[rip+0x3c55e]        # 24b030 <stderr_file>
  20ead2:	48 89 05 5f c5 03 00 	mov    QWORD PTR [rip+0x3c55f],rax        # 24b038 <stderr_file_out_stream>
  20ead9:	48 8d 05 00 0f 01 00 	lea    rax,[rip+0x10f00]        # 21f9e0 <FileOutStream_writeFn>
  20eae0:	48 89 05 59 c5 03 00 	mov    QWORD PTR [rip+0x3c559],rax        # 24b040 <stderr_file_out_stream+0x8>
  20eae7:	48 8d 0d 52 c5 03 00 	lea    rcx,[rip+0x3c552]        # 24b040 <stderr_file_out_stream+0x8>
  20eaee:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20eaf1:	48 89 15 10 15 04 00 	mov    QWORD PTR [rip+0x41510],rdx        # 250008 <stderr_stream>
  20eaf8:	48 89 c1             	mov    rcx,rax
  20eafb:	48 89 d7             	mov    rdi,rdx
  20eafe:	c6 44 24 0f 20       	mov    BYTE PTR [rsp+0xf],0x20
  20eb03:	4c 89 74 24 10       	mov    QWORD PTR [rsp+0x10],r14
  20eb08:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  20eb0f:	00 00 
  20eb11:	4c 89 ee             	mov    rsi,r13
  20eb14:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20eb16:	31 c0                	xor    eax,eax
  20eb18:	86 05 f2 14 04 00    	xchg   BYTE PTR [rip+0x414f2],al        # 250010 <stderr_mutex>
  20eb1e:	3c 01                	cmp    al,0x1
    if (!ok) {
  20eb20:	0f 85 f0 04 00 00    	jne    20f016 <BmAdd+0xd26>
  20eb26:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  20eb2d:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20eb30:	b0 01                	mov    al,0x1
  20eb32:	86 05 d8 14 04 00    	xchg   BYTE PTR [rip+0x414d8],al        # 250010 <stderr_mutex>
  20eb38:	84 c0                	test   al,al
  20eb3a:	75 f4                	jne    20eb30 <BmAdd+0x840>
    if (stderr_stream) |st| {
  20eb3c:	48 8b 3d c5 14 04 00 	mov    rdi,QWORD PTR [rip+0x414c5]        # 250008 <stderr_stream>
  20eb43:	48 85 ff             	test   rdi,rdi
  20eb46:	74 09                	je     20eb51 <BmAdd+0x861>
  20eb48:	48 8b 0d f1 c4 03 00 	mov    rcx,QWORD PTR [rip+0x3c4f1]        # 24b040 <stderr_file_out_stream+0x8>
  20eb4f:	eb 3d                	jmp    20eb8e <BmAdd+0x89e>
        stderr_file = try io.getStdErr();
  20eb51:	c7 05 d5 c4 03 00 02 	mov    DWORD PTR [rip+0x3c4d5],0x2        # 24b030 <stderr_file>
  20eb58:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20eb5b:	48 8d 05 ce c4 03 00 	lea    rax,[rip+0x3c4ce]        # 24b030 <stderr_file>
  20eb62:	48 89 05 cf c4 03 00 	mov    QWORD PTR [rip+0x3c4cf],rax        # 24b038 <stderr_file_out_stream>
  20eb69:	48 8d 05 70 0e 01 00 	lea    rax,[rip+0x10e70]        # 21f9e0 <FileOutStream_writeFn>
  20eb70:	48 89 05 c9 c4 03 00 	mov    QWORD PTR [rip+0x3c4c9],rax        # 24b040 <stderr_file_out_stream+0x8>
  20eb77:	48 8d 0d c2 c4 03 00 	lea    rcx,[rip+0x3c4c2]        # 24b040 <stderr_file_out_stream+0x8>
  20eb7e:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20eb81:	48 89 15 80 14 04 00 	mov    QWORD PTR [rip+0x41480],rdx        # 250008 <stderr_stream>
  20eb88:	48 89 c1             	mov    rcx,rax
  20eb8b:	48 89 d7             	mov    rdi,rdx
  20eb8e:	c6 44 24 0f 20       	mov    BYTE PTR [rsp+0xf],0x20
  20eb93:	4c 89 74 24 10       	mov    QWORD PTR [rsp+0x10],r14
  20eb98:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  20eb9f:	00 00 
  20eba1:	4c 89 ee             	mov    rsi,r13
  20eba4:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20eba6:	31 c0                	xor    eax,eax
  20eba8:	86 05 62 14 04 00    	xchg   BYTE PTR [rip+0x41462],al        # 250010 <stderr_mutex>
  20ebae:	3c 01                	cmp    al,0x1
    if (!ok) {
  20ebb0:	0f 85 60 04 00 00    	jne    20f016 <BmAdd+0xd26>
  20ebb6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  20ebbd:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20ebc0:	b0 01                	mov    al,0x1
  20ebc2:	86 05 48 14 04 00    	xchg   BYTE PTR [rip+0x41448],al        # 250010 <stderr_mutex>
  20ebc8:	84 c0                	test   al,al
  20ebca:	75 f4                	jne    20ebc0 <BmAdd+0x8d0>
    if (stderr_stream) |st| {
  20ebcc:	48 8b 3d 35 14 04 00 	mov    rdi,QWORD PTR [rip+0x41435]        # 250008 <stderr_stream>
  20ebd3:	48 85 ff             	test   rdi,rdi
  20ebd6:	74 09                	je     20ebe1 <BmAdd+0x8f1>
  20ebd8:	48 8b 0d 61 c4 03 00 	mov    rcx,QWORD PTR [rip+0x3c461]        # 24b040 <stderr_file_out_stream+0x8>
  20ebdf:	eb 3d                	jmp    20ec1e <BmAdd+0x92e>
        stderr_file = try io.getStdErr();
  20ebe1:	c7 05 45 c4 03 00 02 	mov    DWORD PTR [rip+0x3c445],0x2        # 24b030 <stderr_file>
  20ebe8:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20ebeb:	48 8d 05 3e c4 03 00 	lea    rax,[rip+0x3c43e]        # 24b030 <stderr_file>
  20ebf2:	48 89 05 3f c4 03 00 	mov    QWORD PTR [rip+0x3c43f],rax        # 24b038 <stderr_file_out_stream>
  20ebf9:	48 8d 05 e0 0d 01 00 	lea    rax,[rip+0x10de0]        # 21f9e0 <FileOutStream_writeFn>
  20ec00:	48 89 05 39 c4 03 00 	mov    QWORD PTR [rip+0x3c439],rax        # 24b040 <stderr_file_out_stream+0x8>
  20ec07:	48 8d 0d 32 c4 03 00 	lea    rcx,[rip+0x3c432]        # 24b040 <stderr_file_out_stream+0x8>
  20ec0e:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20ec11:	48 89 15 f0 13 04 00 	mov    QWORD PTR [rip+0x413f0],rdx        # 250008 <stderr_stream>
  20ec18:	48 89 c1             	mov    rcx,rax
  20ec1b:	48 89 d7             	mov    rdi,rdx
  20ec1e:	c6 44 24 0f 20       	mov    BYTE PTR [rsp+0xf],0x20
  20ec23:	4c 89 74 24 10       	mov    QWORD PTR [rsp+0x10],r14
  20ec28:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  20ec2f:	00 00 
  20ec31:	4c 89 ee             	mov    rsi,r13
  20ec34:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20ec36:	31 c0                	xor    eax,eax
  20ec38:	86 05 d2 13 04 00    	xchg   BYTE PTR [rip+0x413d2],al        # 250010 <stderr_mutex>
  20ec3e:	3c 01                	cmp    al,0x1
    if (!ok) {
  20ec40:	0f 85 d0 03 00 00    	jne    20f016 <BmAdd+0xd26>
  20ec46:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  20ec4d:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20ec50:	b0 01                	mov    al,0x1
  20ec52:	86 05 b8 13 04 00    	xchg   BYTE PTR [rip+0x413b8],al        # 250010 <stderr_mutex>
  20ec58:	84 c0                	test   al,al
  20ec5a:	75 f4                	jne    20ec50 <BmAdd+0x960>
    if (stderr_stream) |st| {
  20ec5c:	48 8b 3d a5 13 04 00 	mov    rdi,QWORD PTR [rip+0x413a5]        # 250008 <stderr_stream>
  20ec63:	48 85 ff             	test   rdi,rdi
  20ec66:	74 09                	je     20ec71 <BmAdd+0x981>
  20ec68:	48 8b 0d d1 c3 03 00 	mov    rcx,QWORD PTR [rip+0x3c3d1]        # 24b040 <stderr_file_out_stream+0x8>
  20ec6f:	eb 3d                	jmp    20ecae <BmAdd+0x9be>
        stderr_file = try io.getStdErr();
  20ec71:	c7 05 b5 c3 03 00 02 	mov    DWORD PTR [rip+0x3c3b5],0x2        # 24b030 <stderr_file>
  20ec78:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20ec7b:	48 8d 05 ae c3 03 00 	lea    rax,[rip+0x3c3ae]        # 24b030 <stderr_file>
  20ec82:	48 89 05 af c3 03 00 	mov    QWORD PTR [rip+0x3c3af],rax        # 24b038 <stderr_file_out_stream>
  20ec89:	48 8d 05 50 0d 01 00 	lea    rax,[rip+0x10d50]        # 21f9e0 <FileOutStream_writeFn>
  20ec90:	48 89 05 a9 c3 03 00 	mov    QWORD PTR [rip+0x3c3a9],rax        # 24b040 <stderr_file_out_stream+0x8>
  20ec97:	48 8d 0d a2 c3 03 00 	lea    rcx,[rip+0x3c3a2]        # 24b040 <stderr_file_out_stream+0x8>
  20ec9e:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20eca1:	48 89 15 60 13 04 00 	mov    QWORD PTR [rip+0x41360],rdx        # 250008 <stderr_stream>
  20eca8:	48 89 c1             	mov    rcx,rax
  20ecab:	48 89 d7             	mov    rdi,rdx
  20ecae:	c6 44 24 0f 20       	mov    BYTE PTR [rsp+0xf],0x20
  20ecb3:	4c 89 74 24 10       	mov    QWORD PTR [rsp+0x10],r14
  20ecb8:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  20ecbf:	00 00 
  20ecc1:	4c 89 ee             	mov    rsi,r13
  20ecc4:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20ecc6:	31 c0                	xor    eax,eax
  20ecc8:	86 05 42 13 04 00    	xchg   BYTE PTR [rip+0x41342],al        # 250010 <stderr_mutex>
  20ecce:	3c 01                	cmp    al,0x1
    if (!ok) {
  20ecd0:	0f 85 40 03 00 00    	jne    20f016 <BmAdd+0xd26>
  20ecd6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  20ecdd:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20ece0:	b0 01                	mov    al,0x1
  20ece2:	86 05 28 13 04 00    	xchg   BYTE PTR [rip+0x41328],al        # 250010 <stderr_mutex>
  20ece8:	84 c0                	test   al,al
  20ecea:	75 f4                	jne    20ece0 <BmAdd+0x9f0>
    if (stderr_stream) |st| {
  20ecec:	48 8b 3d 15 13 04 00 	mov    rdi,QWORD PTR [rip+0x41315]        # 250008 <stderr_stream>
  20ecf3:	48 85 ff             	test   rdi,rdi
  20ecf6:	74 09                	je     20ed01 <BmAdd+0xa11>
  20ecf8:	48 8b 0d 41 c3 03 00 	mov    rcx,QWORD PTR [rip+0x3c341]        # 24b040 <stderr_file_out_stream+0x8>
  20ecff:	eb 3d                	jmp    20ed3e <BmAdd+0xa4e>
        stderr_file = try io.getStdErr();
  20ed01:	c7 05 25 c3 03 00 02 	mov    DWORD PTR [rip+0x3c325],0x2        # 24b030 <stderr_file>
  20ed08:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20ed0b:	48 8d 05 1e c3 03 00 	lea    rax,[rip+0x3c31e]        # 24b030 <stderr_file>
  20ed12:	48 89 05 1f c3 03 00 	mov    QWORD PTR [rip+0x3c31f],rax        # 24b038 <stderr_file_out_stream>
  20ed19:	48 8d 05 c0 0c 01 00 	lea    rax,[rip+0x10cc0]        # 21f9e0 <FileOutStream_writeFn>
  20ed20:	48 89 05 19 c3 03 00 	mov    QWORD PTR [rip+0x3c319],rax        # 24b040 <stderr_file_out_stream+0x8>
  20ed27:	48 8d 0d 12 c3 03 00 	lea    rcx,[rip+0x3c312]        # 24b040 <stderr_file_out_stream+0x8>
  20ed2e:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20ed31:	48 89 15 d0 12 04 00 	mov    QWORD PTR [rip+0x412d0],rdx        # 250008 <stderr_stream>
  20ed38:	48 89 c1             	mov    rcx,rax
  20ed3b:	48 89 d7             	mov    rdi,rdx
  20ed3e:	c6 44 24 0f 20       	mov    BYTE PTR [rsp+0xf],0x20
  20ed43:	4c 89 74 24 10       	mov    QWORD PTR [rsp+0x10],r14
  20ed48:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  20ed4f:	00 00 
  20ed51:	4c 89 ee             	mov    rsi,r13
  20ed54:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20ed56:	31 c0                	xor    eax,eax
  20ed58:	86 05 b2 12 04 00    	xchg   BYTE PTR [rip+0x412b2],al        # 250010 <stderr_mutex>
  20ed5e:	3c 01                	cmp    al,0x1
    if (!ok) {
  20ed60:	0f 85 b0 02 00 00    	jne    20f016 <BmAdd+0xd26>
  20ed66:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  20ed6d:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20ed70:	b0 01                	mov    al,0x1
  20ed72:	86 05 98 12 04 00    	xchg   BYTE PTR [rip+0x41298],al        # 250010 <stderr_mutex>
  20ed78:	84 c0                	test   al,al
  20ed7a:	75 f4                	jne    20ed70 <BmAdd+0xa80>
    if (stderr_stream) |st| {
  20ed7c:	48 8b 3d 85 12 04 00 	mov    rdi,QWORD PTR [rip+0x41285]        # 250008 <stderr_stream>
  20ed83:	48 85 ff             	test   rdi,rdi
  20ed86:	74 09                	je     20ed91 <BmAdd+0xaa1>
  20ed88:	48 8b 0d b1 c2 03 00 	mov    rcx,QWORD PTR [rip+0x3c2b1]        # 24b040 <stderr_file_out_stream+0x8>
  20ed8f:	eb 3d                	jmp    20edce <BmAdd+0xade>
        stderr_file = try io.getStdErr();
  20ed91:	c7 05 95 c2 03 00 02 	mov    DWORD PTR [rip+0x3c295],0x2        # 24b030 <stderr_file>
  20ed98:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20ed9b:	48 8d 05 8e c2 03 00 	lea    rax,[rip+0x3c28e]        # 24b030 <stderr_file>
  20eda2:	48 89 05 8f c2 03 00 	mov    QWORD PTR [rip+0x3c28f],rax        # 24b038 <stderr_file_out_stream>
  20eda9:	48 8d 05 30 0c 01 00 	lea    rax,[rip+0x10c30]        # 21f9e0 <FileOutStream_writeFn>
  20edb0:	48 89 05 89 c2 03 00 	mov    QWORD PTR [rip+0x3c289],rax        # 24b040 <stderr_file_out_stream+0x8>
  20edb7:	48 8d 0d 82 c2 03 00 	lea    rcx,[rip+0x3c282]        # 24b040 <stderr_file_out_stream+0x8>
  20edbe:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20edc1:	48 89 15 40 12 04 00 	mov    QWORD PTR [rip+0x41240],rdx        # 250008 <stderr_stream>
  20edc8:	48 89 c1             	mov    rcx,rax
  20edcb:	48 89 d7             	mov    rdi,rdx
  20edce:	c6 44 24 0f 20       	mov    BYTE PTR [rsp+0xf],0x20
  20edd3:	4c 89 74 24 10       	mov    QWORD PTR [rsp+0x10],r14
  20edd8:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  20eddf:	00 00 
  20ede1:	4c 89 ee             	mov    rsi,r13
  20ede4:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20ede6:	31 c0                	xor    eax,eax
  20ede8:	86 05 22 12 04 00    	xchg   BYTE PTR [rip+0x41222],al        # 250010 <stderr_mutex>
  20edee:	3c 01                	cmp    al,0x1
    if (!ok) {
  20edf0:	0f 85 20 02 00 00    	jne    20f016 <BmAdd+0xd26>
  20edf6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  20edfd:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20ee00:	b0 01                	mov    al,0x1
  20ee02:	86 05 08 12 04 00    	xchg   BYTE PTR [rip+0x41208],al        # 250010 <stderr_mutex>
  20ee08:	84 c0                	test   al,al
  20ee0a:	75 f4                	jne    20ee00 <BmAdd+0xb10>
    if (stderr_stream) |st| {
  20ee0c:	48 8b 3d f5 11 04 00 	mov    rdi,QWORD PTR [rip+0x411f5]        # 250008 <stderr_stream>
  20ee13:	48 85 ff             	test   rdi,rdi
  20ee16:	74 09                	je     20ee21 <BmAdd+0xb31>
  20ee18:	48 8b 0d 21 c2 03 00 	mov    rcx,QWORD PTR [rip+0x3c221]        # 24b040 <stderr_file_out_stream+0x8>
  20ee1f:	eb 3d                	jmp    20ee5e <BmAdd+0xb6e>
        stderr_file = try io.getStdErr();
  20ee21:	c7 05 05 c2 03 00 02 	mov    DWORD PTR [rip+0x3c205],0x2        # 24b030 <stderr_file>
  20ee28:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20ee2b:	48 8d 05 fe c1 03 00 	lea    rax,[rip+0x3c1fe]        # 24b030 <stderr_file>
  20ee32:	48 89 05 ff c1 03 00 	mov    QWORD PTR [rip+0x3c1ff],rax        # 24b038 <stderr_file_out_stream>
  20ee39:	48 8d 05 a0 0b 01 00 	lea    rax,[rip+0x10ba0]        # 21f9e0 <FileOutStream_writeFn>
  20ee40:	48 89 05 f9 c1 03 00 	mov    QWORD PTR [rip+0x3c1f9],rax        # 24b040 <stderr_file_out_stream+0x8>
  20ee47:	48 8d 0d f2 c1 03 00 	lea    rcx,[rip+0x3c1f2]        # 24b040 <stderr_file_out_stream+0x8>
  20ee4e:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20ee51:	48 89 15 b0 11 04 00 	mov    QWORD PTR [rip+0x411b0],rdx        # 250008 <stderr_stream>
  20ee58:	48 89 c1             	mov    rcx,rax
  20ee5b:	48 89 d7             	mov    rdi,rdx
                const casted_value = ([]const u8)(value);
  20ee5e:	4c 89 7c 24 10       	mov    QWORD PTR [rsp+0x10],r15
  20ee63:	48 c7 44 24 18 04 00 	mov    QWORD PTR [rsp+0x18],0x4
  20ee6a:	00 00 
                return output(context, casted_value);
  20ee6c:	4c 89 ee             	mov    rsi,r13
  20ee6f:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20ee71:	31 c0                	xor    eax,eax
  20ee73:	86 05 97 11 04 00    	xchg   BYTE PTR [rip+0x41197],al        # 250010 <stderr_mutex>
  20ee79:	3c 01                	cmp    al,0x1
    if (!ok) {
  20ee7b:	0f 85 95 01 00 00    	jne    20f016 <BmAdd+0xd26>
                try rightJustified(18, "{}", "time/operation");
  20ee81:	e8 da 75 00 00       	call   216460 <Benchmark_rightJustified.38>
  20ee86:	66 85 c0             	test   ax,ax
  20ee89:	0f 85 6f 01 00 00    	jne    20effe <BmAdd+0xd0e>
  20ee8f:	90                   	nop
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20ee90:	b0 01                	mov    al,0x1
  20ee92:	86 05 78 11 04 00    	xchg   BYTE PTR [rip+0x41178],al        # 250010 <stderr_mutex>
  20ee98:	84 c0                	test   al,al
  20ee9a:	75 f4                	jne    20ee90 <BmAdd+0xba0>
    if (stderr_stream) |st| {
  20ee9c:	48 8b 3d 65 11 04 00 	mov    rdi,QWORD PTR [rip+0x41165]        # 250008 <stderr_stream>
  20eea3:	48 85 ff             	test   rdi,rdi
  20eea6:	74 09                	je     20eeb1 <BmAdd+0xbc1>
  20eea8:	48 8b 0d 91 c1 03 00 	mov    rcx,QWORD PTR [rip+0x3c191]        # 24b040 <stderr_file_out_stream+0x8>
  20eeaf:	eb 3d                	jmp    20eeee <BmAdd+0xbfe>
        stderr_file = try io.getStdErr();
  20eeb1:	c7 05 75 c1 03 00 02 	mov    DWORD PTR [rip+0x3c175],0x2        # 24b030 <stderr_file>
  20eeb8:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20eebb:	48 8d 05 6e c1 03 00 	lea    rax,[rip+0x3c16e]        # 24b030 <stderr_file>
  20eec2:	48 89 05 6f c1 03 00 	mov    QWORD PTR [rip+0x3c16f],rax        # 24b038 <stderr_file_out_stream>
  20eec9:	48 8d 05 10 0b 01 00 	lea    rax,[rip+0x10b10]        # 21f9e0 <FileOutStream_writeFn>
  20eed0:	48 89 05 69 c1 03 00 	mov    QWORD PTR [rip+0x3c169],rax        # 24b040 <stderr_file_out_stream+0x8>
  20eed7:	48 8d 0d 62 c1 03 00 	lea    rcx,[rip+0x3c162]        # 24b040 <stderr_file_out_stream+0x8>
  20eede:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20eee1:	48 89 15 20 11 04 00 	mov    QWORD PTR [rip+0x41120],rdx        # 250008 <stderr_stream>
  20eee8:	48 89 c1             	mov    rcx,rax
  20eeeb:	48 89 d7             	mov    rdi,rdx
        try output(context, fmt[start_index..]);
  20eeee:	48 8d 35 23 ff 03 00 	lea    rsi,[rip+0x3ff23]        # 24ee18 <__unnamed_3>
  20eef5:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20eef7:	31 c0                	xor    eax,eax
  20eef9:	86 05 11 11 04 00    	xchg   BYTE PTR [rip+0x41111],al        # 250010 <stderr_mutex>
  20eeff:	3c 01                	cmp    al,0x1
    if (!ok) {
  20ef01:	0f 85 0f 01 00 00    	jne    20f016 <BmAdd+0xd26>
            try pSelf.report(pSelf.results.items[pSelf.results.len - 1]); warn("\n");
  20ef07:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  20ef0e:	00 
  20ef0f:	48 8b 8c 24 b8 00 00 	mov    rcx,QWORD PTR [rsp+0xb8]
  20ef16:	00 
  20ef17:	48 c1 e1 04          	shl    rcx,0x4
  20ef1b:	48 8d 34 08          	lea    rsi,[rax+rcx*1]
  20ef1f:	48 83 c6 f0          	add    rsi,0xfffffffffffffff0
  20ef23:	48 8d 7c 24 60       	lea    rdi,[rsp+0x60]
  20ef28:	e8 33 4b 00 00       	call   213a60 <Benchmark_report>
  20ef2d:	66 85 c0             	test   ax,ax
  20ef30:	0f 85 c8 00 00 00    	jne    20effe <BmAdd+0xd0e>
  20ef36:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  20ef3d:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20ef40:	b0 01                	mov    al,0x1
  20ef42:	86 05 c8 10 04 00    	xchg   BYTE PTR [rip+0x410c8],al        # 250010 <stderr_mutex>
  20ef48:	84 c0                	test   al,al
  20ef4a:	75 f4                	jne    20ef40 <BmAdd+0xc50>
    if (stderr_stream) |st| {
  20ef4c:	48 8b 3d b5 10 04 00 	mov    rdi,QWORD PTR [rip+0x410b5]        # 250008 <stderr_stream>
  20ef53:	48 85 ff             	test   rdi,rdi
  20ef56:	74 09                	je     20ef61 <BmAdd+0xc71>
  20ef58:	48 8b 0d e1 c0 03 00 	mov    rcx,QWORD PTR [rip+0x3c0e1]        # 24b040 <stderr_file_out_stream+0x8>
  20ef5f:	eb 3d                	jmp    20ef9e <BmAdd+0xcae>
        stderr_file = try io.getStdErr();
  20ef61:	c7 05 c5 c0 03 00 02 	mov    DWORD PTR [rip+0x3c0c5],0x2        # 24b030 <stderr_file>
  20ef68:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20ef6b:	48 8d 05 be c0 03 00 	lea    rax,[rip+0x3c0be]        # 24b030 <stderr_file>
  20ef72:	48 89 05 bf c0 03 00 	mov    QWORD PTR [rip+0x3c0bf],rax        # 24b038 <stderr_file_out_stream>
  20ef79:	48 8d 05 60 0a 01 00 	lea    rax,[rip+0x10a60]        # 21f9e0 <FileOutStream_writeFn>
  20ef80:	48 89 05 b9 c0 03 00 	mov    QWORD PTR [rip+0x3c0b9],rax        # 24b040 <stderr_file_out_stream+0x8>
  20ef87:	48 8d 0d b2 c0 03 00 	lea    rcx,[rip+0x3c0b2]        # 24b040 <stderr_file_out_stream+0x8>
  20ef8e:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20ef91:	48 89 15 70 10 04 00 	mov    QWORD PTR [rip+0x41070],rdx        # 250008 <stderr_stream>
  20ef98:	48 89 c1             	mov    rcx,rax
  20ef9b:	48 89 d7             	mov    rdi,rdx
  20ef9e:	4c 8b 6c 24 28       	mov    r13,QWORD PTR [rsp+0x28]
  20efa3:	48 8d 35 6e fe 03 00 	lea    rsi,[rip+0x3fe6e]        # 24ee18 <__unnamed_3>
  20efaa:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20efac:	31 c0                	xor    eax,eax
  20efae:	86 05 5c 10 04 00    	xchg   BYTE PTR [rip+0x4105c],al        # 250010 <stderr_mutex>
  20efb4:	3c 01                	cmp    al,0x1
    if (!ok) {
  20efb6:	75 5e                	jne    20f016 <BmAdd+0xd26>
  20efb8:	49 83 c5 01          	add    r13,0x1
  20efbc:	31 c0                	xor    eax,eax
  20efbe:	4d 89 e6             	mov    r14,r12
        while (rep < pSelf.repetitions) : (rep += 1) {
  20efc1:	4c 3b ac 24 80 00 00 	cmp    r13,QWORD PTR [rsp+0x80]
  20efc8:	00 
  20efc9:	c5 f8 10 0d ef 9d ff 	vmovups xmm1,XMMWORD PTR [rip+0xffffffffffff9def]        # 208dc0 <__unnamed_5>
  20efd0:	ff 
  20efd1:	4c 89 fe             	mov    rsi,r15
  20efd4:	0f 82 3f f4 ff ff    	jb     20e419 <BmAdd+0x129>
  20efda:	48 8d 7c 24 60       	lea    rdi,[rsp+0x60]
        try pSelf.reportStats(pSelf.results);
  20efdf:	48 8d b4 24 a8 00 00 	lea    rsi,[rsp+0xa8]
  20efe6:	00 
  20efe7:	e8 54 77 00 00       	call   216740 <Benchmark_reportStats>
  20efec:	eb 10                	jmp    20effe <BmAdd+0xd0e>
                switch (errno) {
  20efee:	48 83 f9 16          	cmp    rcx,0x16
  20eff2:	75 06                	jne    20effa <BmAdd+0xd0a>
  20eff4:	66 b8 02 00          	mov    ax,0x2
  20eff8:	eb 04                	jmp    20effe <BmAdd+0xd0e>
  20effa:	66 b8 03 00          	mov    ax,0x3
    _ = try bm.run(BmAdd);
  20effe:	48 81 c4 08 01 00 00 	add    rsp,0x108
  20f005:	5b                   	pop    rbx
  20f006:	41 5c                	pop    r12
  20f008:	41 5d                	pop    r13
  20f00a:	41 5e                	pop    r14
  20f00c:	41 5f                	pop    r15
  20f00e:	5d                   	pop    rbp
  20f00f:	c3                   	ret    
  20f010:	66 b8 06 00          	mov    ax,0x6
  20f014:	eb e8                	jmp    20effe <BmAdd+0xd0e>
            @panic("assertion failure");
  20f016:	48 8d 3d eb fc 03 00 	lea    rdi,[rip+0x3fceb]        # 24ed08 <__unnamed_2>
  20f01d:	e8 fe 2f 00 00       	call   212020 <panic>
  20f022:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20f029:	1f 84 00 00 00 00 00 

000000000020f030 <BmAdd.Acquire.Release>:
}

/// The inner loop is empty
test "BmAdd.Acquire.Release" {
  20f030:	55                   	push   rbp
  20f031:	41 57                	push   r15
  20f033:	41 56                	push   r14
  20f035:	41 55                	push   r13
  20f037:	41 54                	push   r12
  20f039:	53                   	push   rbx
  20f03a:	48 81 ec f8 00 00 00 	sub    rsp,0xf8
  20f041:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20f048:	0f 1f 84 00 00 00 00 
  20f04f:	00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20f050:	b0 01                	mov    al,0x1
  20f052:	86 05 b8 0f 04 00    	xchg   BYTE PTR [rip+0x40fb8],al        # 250010 <stderr_mutex>
  20f058:	84 c0                	test   al,al
  20f05a:	75 f4                	jne    20f050 <BmAdd.Acquire.Release+0x20>
    if (stderr_stream) |st| {
  20f05c:	48 8b 3d a5 0f 04 00 	mov    rdi,QWORD PTR [rip+0x40fa5]        # 250008 <stderr_stream>
  20f063:	48 85 ff             	test   rdi,rdi
  20f066:	74 09                	je     20f071 <BmAdd.Acquire.Release+0x41>
  20f068:	48 8b 05 d1 bf 03 00 	mov    rax,QWORD PTR [rip+0x3bfd1]        # 24b040 <stderr_file_out_stream+0x8>
  20f06f:	eb 34                	jmp    20f0a5 <BmAdd.Acquire.Release+0x75>
        stderr_file = try io.getStdErr();
  20f071:	48 8d 05 b8 bf 03 00 	lea    rax,[rip+0x3bfb8]        # 24b030 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20f078:	48 89 05 b9 bf 03 00 	mov    QWORD PTR [rip+0x3bfb9],rax        # 24b038 <stderr_file_out_stream>
  20f07f:	48 8d 05 5a 09 01 00 	lea    rax,[rip+0x1095a]        # 21f9e0 <FileOutStream_writeFn>
  20f086:	48 89 05 b3 bf 03 00 	mov    QWORD PTR [rip+0x3bfb3],rax        # 24b040 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  20f08d:	c7 05 99 bf 03 00 02 	mov    DWORD PTR [rip+0x3bf99],0x2        # 24b030 <stderr_file>
  20f094:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20f097:	48 8d 3d a2 bf 03 00 	lea    rdi,[rip+0x3bfa2]        # 24b040 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  20f09e:	48 89 3d 63 0f 04 00 	mov    QWORD PTR [rip+0x40f63],rdi        # 250008 <stderr_stream>
  20f0a5:	48 8d 35 6c fd 03 00 	lea    rsi,[rip+0x3fd6c]        # 24ee18 <__unnamed_3>
  20f0ac:	ff d0                	call   rax
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20f0ae:	31 c0                	xor    eax,eax
  20f0b0:	86 05 5a 0f 04 00    	xchg   BYTE PTR [rip+0x40f5a],al        # 250010 <stderr_mutex>
  20f0b6:	3c 01                	cmp    al,0x1
    if (!ok) {
  20f0b8:	0f 85 b2 0c 00 00    	jne    20fd70 <BmAdd.Acquire.Release+0xd40>

    // Since this is a test print a \n before we run
    warn("\n");

    // Create an instance of Benchmark, set 10 iterations and run
    var bm = Benchmark.init("BmAdd", std.debug.global_allocator);
  20f0be:	c5 f8 10 05 22 fc 03 	vmovups xmm0,XMMWORD PTR [rip+0x3fc22]        # 24ece8 <__unnamed_11>
  20f0c5:	00 
  20f0c6:	c5 f8 29 44 24 50    	vmovaps XMMWORD PTR [rsp+0x50],xmm0
  20f0cc:	b8 00 65 cd 1d       	mov    eax,0x1dcd6500
  20f0d1:	c4 e1 f9 6e c0       	vmovq  xmm0,rax
  20f0d6:	c5 f9 73 f8 08       	vpslldq xmm0,xmm0,0x8
  20f0db:	c5 f9 7f 44 24 60    	vmovdqa XMMWORD PTR [rsp+0x60],xmm0
  20f0e1:	48 b8 00 e8 76 48 17 	movabs rax,0x174876e800
  20f0e8:	00 00 00 
  20f0eb:	48 89 44 24 78       	mov    QWORD PTR [rsp+0x78],rax
  20f0f0:	c5 fa 6f 05 c8 9c ff 	vmovdqu xmm0,XMMWORD PTR [rip+0xffffffffffff9cc8]        # 208dc0 <__unnamed_5>
  20f0f7:	ff 
  20f0f8:	c5 f9 7f 84 24 80 00 	vmovdqa XMMWORD PTR [rsp+0x80],xmm0
  20f0ff:	00 00 
  20f101:	48 8d 05 f8 be 03 00 	lea    rax,[rip+0x3bef8]        # 24b000 <global_fixed_allocator>
  20f108:	48 89 84 24 90 00 00 	mov    QWORD PTR [rsp+0x90],rax
  20f10f:	00 
  20f110:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  20f114:	c5 fa 7f 84 24 98 00 	vmovdqu XMMWORD PTR [rsp+0x98],xmm0
  20f11b:	00 00 
  20f11d:	48 c7 84 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],0x0
  20f124:	00 00 00 00 00 
  20f129:	48 89 84 24 b0 00 00 	mov    QWORD PTR [rsp+0xb0],rax
  20f130:	00 
    bm.repetitions = 10;
  20f131:	48 c7 44 24 70 0a 00 	mov    QWORD PTR [rsp+0x70],0xa
  20f138:	00 00 
  20f13a:	b1 01                	mov    cl,0x1
  20f13c:	bb 01 00 00 00       	mov    ebx,0x1
  20f141:	31 ed                	xor    ebp,ebp
  20f143:	c5 f8 10 0d 75 9c ff 	vmovups xmm1,XMMWORD PTR [rip+0xffffffffffff9c75]        # 208dc0 <__unnamed_5>
  20f14a:	ff 
  20f14b:	4c 8d 7c 24 20       	lea    r15,[rsp+0x20]
  20f150:	31 c0                	xor    eax,eax
  20f152:	89 4c 24 1c          	mov    DWORD PTR [rsp+0x1c],ecx
  20f156:	48 89 44 24 48       	mov    QWORD PTR [rsp+0x48],rax
                var ts: posix.timespec = undefined;
  20f15b:	c5 f8 29 4c 24 20    	vmovaps XMMWORD PTR [rsp+0x20],xmm1
  20f161:	b8 e5 00 00 00       	mov    eax,0xe5
  20f166:	bf 01 00 00 00       	mov    edi,0x1
  20f16b:	4c 89 fe             	mov    rsi,r15
  20f16e:	0f 05                	syscall 
  20f170:	48 89 c1             	mov    rcx,rax
  20f173:	48 f7 d9             	neg    rcx
  20f176:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  20f17c:	48 0f 46 cd          	cmovbe rcx,rbp
                switch (errno) {
  20f180:	48 85 c9             	test   rcx,rcx
  20f183:	0f 85 bf 0b 00 00    	jne    20fd48 <BmAdd.Acquire.Release+0xd18>
        const f = @atomicLoad(@typeOf(init_vdso_clock_gettime), &vdso_clock_gettime, builtin.AtomicOrder.Unordered);
  20f189:	48 8b 05 b8 be 03 00 	mov    rax,QWORD PTR [rip+0x3beb8]        # 24b048 <vdso_clock_gettime>
        if (@ptrToInt(f) != 0) {
  20f190:	48 85 c0             	test   rax,rax
  20f193:	74 21                	je     20f1b6 <BmAdd.Acquire.Release+0x186>
            const rc = f(clk_id, tp);
  20f195:	bf 01 00 00 00       	mov    edi,0x1
  20f19a:	4c 89 fe             	mov    rsi,r15
  20f19d:	ff d0                	call   rax
            switch (rc) {
  20f19f:	48 83 f8 ea          	cmp    rax,0xffffffffffffffea
  20f1a3:	0f 84 67 04 00 00    	je     20f610 <BmAdd.Acquire.Release+0x5e0>
  20f1a9:	48 85 c0             	test   rax,rax
  20f1ac:	c5 f8 10 0d 0c 9c ff 	vmovups xmm1,XMMWORD PTR [rip+0xffffffffffff9c0c]        # 208dc0 <__unnamed_5>
  20f1b3:	ff 
  20f1b4:	74 0f                	je     20f1c5 <BmAdd.Acquire.Release+0x195>
  20f1b6:	b8 e4 00 00 00       	mov    eax,0xe4
  20f1bb:	bf 01 00 00 00       	mov    edi,0x1
  20f1c0:	4c 89 fe             	mov    rsi,r15
  20f1c3:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  20f1c5:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
                if (errno != 0) return std.os.unexpectedErrorPosix(errno);
  20f1cb:	0f 83 83 0b 00 00    	jae    20fd54 <BmAdd.Acquire.Release+0xd24>
                self.start_time = @intCast(u64, ts.tv_sec) * u64(ns_per_s) + @intCast(u64, ts.tv_nsec);
  20f1d1:	48 8b 6c 24 20       	mov    rbp,QWORD PTR [rsp+0x20]
  20f1d6:	4c 8b 74 24 28       	mov    r14,QWORD PTR [rsp+0x28]
        var ts: posix.timespec = undefined;
  20f1db:	c5 f8 29 4c 24 20    	vmovaps XMMWORD PTR [rsp+0x20],xmm1
        const f = @atomicLoad(@typeOf(init_vdso_clock_gettime), &vdso_clock_gettime, builtin.AtomicOrder.Unordered);
  20f1e1:	48 8b 05 60 be 03 00 	mov    rax,QWORD PTR [rip+0x3be60]        # 24b048 <vdso_clock_gettime>
        if (@ptrToInt(f) != 0) {
  20f1e8:	48 85 c0             	test   rax,rax
  20f1eb:	74 21                	je     20f20e <BmAdd.Acquire.Release+0x1de>
            const rc = f(clk_id, tp);
  20f1ed:	bf 01 00 00 00       	mov    edi,0x1
  20f1f2:	4c 89 fe             	mov    rsi,r15
  20f1f5:	ff d0                	call   rax
            switch (rc) {
  20f1f7:	48 83 f8 ea          	cmp    rax,0xffffffffffffffea
  20f1fb:	0f 84 28 04 00 00    	je     20f629 <BmAdd.Acquire.Release+0x5f9>
  20f201:	48 85 c0             	test   rax,rax
  20f204:	c5 f8 10 0d b4 9b ff 	vmovups xmm1,XMMWORD PTR [rip+0xffffffffffff9bb4]        # 208dc0 <__unnamed_5>
  20f20b:	ff 
  20f20c:	74 0f                	je     20f21d <BmAdd.Acquire.Release+0x1ed>
  20f20e:	b8 e4 00 00 00       	mov    eax,0xe4
  20f213:	bf 01 00 00 00       	mov    edi,0x1
  20f218:	4c 89 fe             	mov    rsi,r15
  20f21b:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  20f21d:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
  20f223:	0f 83 47 0b 00 00    	jae    20fd70 <BmAdd.Acquire.Release+0xd40>
        return @intCast(u64, ts.tv_sec) * u64(ns_per_s) + @intCast(u64, ts.tv_nsec);
  20f229:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
  20f22e:	48 29 e8             	sub    rax,rbp
  20f231:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  20f236:	4c 29 f1             	sub    rcx,r14
  20f239:	48 69 c0 00 ca 9a 3b 	imul   rax,rax,0x3b9aca00
        var clock = clockNative() - self.start_time;
  20f240:	48 01 c8             	add    rax,rcx
        self.s +%= 0x9e3779b97f4a7c15;
  20f243:	48 b9 15 7c 4a 7f b9 	movabs rcx,0x9e3779b97f4a7c15
  20f24a:	79 37 9e 
  20f24d:	48 8d 0c 08          	lea    rcx,[rax+rcx*1]
        z = (z ^ (z >> 30)) *% 0xbf58476d1ce4e5b9;
  20f251:	48 89 ca             	mov    rdx,rcx
  20f254:	48 c1 ea 1e          	shr    rdx,0x1e
  20f258:	48 31 ca             	xor    rdx,rcx
  20f25b:	48 b9 b9 e5 e4 1c 6d 	movabs rcx,0xbf58476d1ce4e5b9
  20f262:	47 58 bf 
  20f265:	48 89 ce             	mov    rsi,rcx
  20f268:	48 0f af d6          	imul   rdx,rsi
        z = (z ^ (z >> 27)) *% 0x94d049bb133111eb;
  20f26c:	48 89 d1             	mov    rcx,rdx
  20f26f:	48 c1 e9 1b          	shr    rcx,0x1b
  20f273:	48 31 d1             	xor    rcx,rdx
  20f276:	48 ba eb 11 31 13 bb 	movabs rdx,0x94d049bb133111eb
  20f27d:	49 d0 94 
  20f280:	48 89 d7             	mov    rdi,rdx
  20f283:	48 0f af cf          	imul   rcx,rdi
        return z ^ (z >> 31);
  20f287:	48 89 ca             	mov    rdx,rcx
  20f28a:	48 c1 ea 1f          	shr    rdx,0x1f
  20f28e:	48 31 ca             	xor    rdx,rcx
        self.s +%= 0x9e3779b97f4a7c15;
  20f291:	48 b9 2a f8 94 fe 72 	movabs rcx,0x3c6ef372fe94f82a
  20f298:	f3 6e 3c 
  20f29b:	48 01 c8             	add    rax,rcx
        z = (z ^ (z >> 30)) *% 0xbf58476d1ce4e5b9;
  20f29e:	48 89 c1             	mov    rcx,rax
  20f2a1:	48 c1 e9 1e          	shr    rcx,0x1e
  20f2a5:	48 31 c1             	xor    rcx,rax
  20f2a8:	48 0f af ce          	imul   rcx,rsi
        z = (z ^ (z >> 27)) *% 0x94d049bb133111eb;
  20f2ac:	48 89 c8             	mov    rax,rcx
  20f2af:	48 c1 e8 1b          	shr    rax,0x1b
  20f2b3:	48 31 c8             	xor    rax,rcx
  20f2b6:	48 0f af c7          	imul   rax,rdi
        return z ^ (z >> 31);
  20f2ba:	49 89 c6             	mov    r14,rax
  20f2bd:	49 c1 ee 1f          	shr    r14,0x1f
  20f2c1:	49 31 c6             	xor    r14,rax
        s1 ^= s0;
  20f2c4:	4c 89 f0             	mov    rax,r14
  20f2c7:	48 31 d0             	xor    rax,rdx
  20f2ca:	c4 e3 fb f0 ca 09    	rorx   rcx,rdx,0x9
        self.s[0] = math.rotl(u64, s0, u8(55)) ^ s1 ^ (s1 << 14);
  20f2d0:	48 31 c1             	xor    rcx,rax
  20f2d3:	c4 e3 fb f0 f0 1c    	rorx   rsi,rax,0x1c
  20f2d9:	48 c1 e0 0e          	shl    rax,0xe
  20f2dd:	48 31 c8             	xor    rax,rcx
        const r = s0 +% s1;
  20f2e0:	49 01 d6             	add    r14,rdx
  20f2e3:	49 01 f6             	add    r14,rsi
  20f2e6:	49 01 c6             	add    r14,rax
            while (iterations <= pSelf.max_iterations) {
  20f2e9:	48 3b 5c 24 78       	cmp    rbx,QWORD PTR [rsp+0x78]
  20f2ee:	bd 00 00 00 00       	mov    ebp,0x0
  20f2f3:	76 1e                	jbe    20f313 <BmAdd.Acquire.Release+0x2e3>
  20f2f5:	e9 76 03 00 00       	jmp    20f670 <BmAdd.Acquire.Release+0x640>
  20f2fa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
                        warn("iteratons:{} numer:{} denom:{}\n", iterations, numer, denom);
  20f300:	48 89 df             	mov    rdi,rbx
  20f303:	48 89 ca             	mov    rdx,rcx
  20f306:	e8 65 68 00 00       	call   215b70 <warn.36>
  20f30b:	c5 f8 10 0d ad 9a ff 	vmovups xmm1,XMMWORD PTR [rip+0xffffffffffff9aad]        # 208dc0 <__unnamed_5>
  20f312:	ff 
                var ts: posix.timespec = undefined;
  20f313:	c5 f8 29 4c 24 20    	vmovaps XMMWORD PTR [rsp+0x20],xmm1
  20f319:	b8 e5 00 00 00       	mov    eax,0xe5
  20f31e:	bf 01 00 00 00       	mov    edi,0x1
  20f323:	4c 89 fe             	mov    rsi,r15
  20f326:	0f 05                	syscall 
  20f328:	48 89 c1             	mov    rcx,rax
  20f32b:	48 f7 d9             	neg    rcx
  20f32e:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  20f334:	48 0f 46 cd          	cmovbe rcx,rbp
                switch (errno) {
  20f338:	48 85 c9             	test   rcx,rcx
  20f33b:	0f 85 07 0a 00 00    	jne    20fd48 <BmAdd.Acquire.Release+0xd18>
        const f = @atomicLoad(@typeOf(init_vdso_clock_gettime), &vdso_clock_gettime, builtin.AtomicOrder.Unordered);
  20f341:	48 8b 05 00 bd 03 00 	mov    rax,QWORD PTR [rip+0x3bd00]        # 24b048 <vdso_clock_gettime>
        if (@ptrToInt(f) != 0) {
  20f348:	48 85 c0             	test   rax,rax
  20f34b:	74 21                	je     20f36e <BmAdd.Acquire.Release+0x33e>
            const rc = f(clk_id, tp);
  20f34d:	bf 01 00 00 00       	mov    edi,0x1
  20f352:	4c 89 fe             	mov    rsi,r15
  20f355:	ff d0                	call   rax
            switch (rc) {
  20f357:	48 83 f8 ea          	cmp    rax,0xffffffffffffffea
  20f35b:	0f 84 6f 02 00 00    	je     20f5d0 <BmAdd.Acquire.Release+0x5a0>
  20f361:	48 85 c0             	test   rax,rax
  20f364:	c5 f8 10 0d 54 9a ff 	vmovups xmm1,XMMWORD PTR [rip+0xffffffffffff9a54]        # 208dc0 <__unnamed_5>
  20f36b:	ff 
  20f36c:	74 0f                	je     20f37d <BmAdd.Acquire.Release+0x34d>
  20f36e:	b8 e4 00 00 00       	mov    eax,0xe4
  20f373:	bf 01 00 00 00       	mov    edi,0x1
  20f378:	4c 89 fe             	mov    rsi,r15
  20f37b:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  20f37d:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
                if (errno != 0) return std.os.unexpectedErrorPosix(errno);
  20f383:	0f 83 cb 09 00 00    	jae    20fd54 <BmAdd.Acquire.Release+0xd24>
                self.start_time = @intCast(u64, ts.tv_sec) * u64(ns_per_s) + @intCast(u64, ts.tv_nsec);
  20f389:	c5 f9 6f 54 24 20    	vmovdqa xmm2,XMMWORD PTR [rsp+0x20]
        while (iter > 0) : (iter -= 1) {
  20f38f:	48 85 db             	test   rbx,rbx
  20f392:	74 45                	je     20f3d9 <BmAdd.Acquire.Release+0x3a9>
            @fence(AtomicOrder.Acquire);
  20f394:	48 8d 4b ff          	lea    rcx,[rbx-0x1]
  20f398:	48 89 da             	mov    rdx,rbx
  20f39b:	48 89 d8             	mov    rax,rbx
  20f39e:	48 83 e2 07          	and    rdx,0x7
  20f3a2:	74 16                	je     20f3ba <BmAdd.Acquire.Release+0x38a>
  20f3a4:	48 f7 da             	neg    rdx
  20f3a7:	48 89 d8             	mov    rax,rbx
  20f3aa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
        while (iter > 0) : (iter -= 1) {
  20f3b0:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  20f3b4:	48 83 c2 01          	add    rdx,0x1
  20f3b8:	75 f6                	jne    20f3b0 <BmAdd.Acquire.Release+0x380>
  20f3ba:	4d 89 f4             	mov    r12,r14
            @fence(AtomicOrder.Acquire);
  20f3bd:	48 83 f9 07          	cmp    rcx,0x7
  20f3c1:	72 16                	jb     20f3d9 <BmAdd.Acquire.Release+0x3a9>
  20f3c3:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20f3ca:	84 00 00 00 00 00 
        while (iter > 0) : (iter -= 1) {
  20f3d0:	48 83 c0 f8          	add    rax,0xfffffffffffffff8
  20f3d4:	75 fa                	jne    20f3d0 <BmAdd.Acquire.Release+0x3a0>
  20f3d6:	4d 89 f4             	mov    r12,r14
        var ts: posix.timespec = undefined;
  20f3d9:	c5 f8 29 4c 24 20    	vmovaps XMMWORD PTR [rsp+0x20],xmm1
        const f = @atomicLoad(@typeOf(init_vdso_clock_gettime), &vdso_clock_gettime, builtin.AtomicOrder.Unordered);
  20f3df:	48 8b 05 62 bc 03 00 	mov    rax,QWORD PTR [rip+0x3bc62]        # 24b048 <vdso_clock_gettime>
        if (@ptrToInt(f) != 0) {
  20f3e6:	48 85 c0             	test   rax,rax
  20f3e9:	74 33                	je     20f41e <BmAdd.Acquire.Release+0x3ee>
  20f3eb:	c5 f9 7f 94 24 c0 00 	vmovdqa XMMWORD PTR [rsp+0xc0],xmm2
  20f3f2:	00 00 
            const rc = f(clk_id, tp);
  20f3f4:	bf 01 00 00 00       	mov    edi,0x1
  20f3f9:	4c 89 fe             	mov    rsi,r15
  20f3fc:	ff d0                	call   rax
            switch (rc) {
  20f3fe:	48 83 f8 ea          	cmp    rax,0xffffffffffffffea
  20f402:	0f 84 e1 01 00 00    	je     20f5e9 <BmAdd.Acquire.Release+0x5b9>
  20f408:	48 85 c0             	test   rax,rax
  20f40b:	c5 f8 10 0d ad 99 ff 	vmovups xmm1,XMMWORD PTR [rip+0xffffffffffff99ad]        # 208dc0 <__unnamed_5>
  20f412:	ff 
  20f413:	c5 f9 6f 94 24 c0 00 	vmovdqa xmm2,XMMWORD PTR [rsp+0xc0]
  20f41a:	00 00 
  20f41c:	74 0f                	je     20f42d <BmAdd.Acquire.Release+0x3fd>
  20f41e:	b8 e4 00 00 00       	mov    eax,0xe4
  20f423:	bf 01 00 00 00       	mov    edi,0x1
  20f428:	4c 89 fe             	mov    rsi,r15
  20f42b:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  20f42d:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
  20f433:	0f 83 37 09 00 00    	jae    20fd70 <BmAdd.Acquire.Release+0xd40>
        return @intCast(u64, ts.tv_sec) * u64(ns_per_s) + @intCast(u64, ts.tv_nsec);
  20f439:	c5 f9 6f 44 24 20    	vmovdqa xmm0,XMMWORD PTR [rsp+0x20]
  20f43f:	c5 f9 fb c2          	vpsubq xmm0,xmm0,xmm2
  20f443:	c4 e1 f9 7e c0       	vmovq  rax,xmm0
        var clock = clockNative() - self.start_time;
  20f448:	c4 c3 f9 16 c5 01    	vpextrq r13,xmm0,0x1
  20f44e:	48 69 c0 00 ca 9a 3b 	imul   rax,rax,0x3b9aca00
  20f455:	49 01 c5             	add    r13,rax
                if ((run_time_ns >= pSelf.min_runtime_ns) or (iterations >= pSelf.max_iterations)) {
  20f458:	4c 3b 6c 24 68       	cmp    r13,QWORD PTR [rsp+0x68]
  20f45d:	0f 83 df 01 00 00    	jae    20f642 <BmAdd.Acquire.Release+0x612>
  20f463:	48 3b 5c 24 78       	cmp    rbx,QWORD PTR [rsp+0x78]
  20f468:	0f 83 d4 01 00 00    	jae    20f642 <BmAdd.Acquire.Release+0x612>
                    if (pSelf.logl >= 1) {
  20f46e:	48 83 7c 24 60 00    	cmp    QWORD PTR [rsp+0x60],0x0
  20f474:	0f 84 c4 00 00 00    	je     20f53e <BmAdd.Acquire.Release+0x50e>
                            Result {.run_time_ns = run_time_ns, .iterations = iterations});
  20f47a:	4c 89 ac 24 d8 00 00 	mov    QWORD PTR [rsp+0xd8],r13
  20f481:	00 
  20f482:	48 89 9c 24 e0 00 00 	mov    QWORD PTR [rsp+0xe0],rbx
  20f489:	00 
                        try pSelf.report(
  20f48a:	48 8d 7c 24 50       	lea    rdi,[rsp+0x50]
  20f48f:	48 8d b4 24 d8 00 00 	lea    rsi,[rsp+0xd8]
  20f496:	00 
  20f497:	e8 c4 45 00 00       	call   213a60 <Benchmark_report>
  20f49c:	66 85 c0             	test   ax,ax
  20f49f:	0f 85 b3 08 00 00    	jne    20fd58 <BmAdd.Acquire.Release+0xd28>
  20f4a5:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20f4ac:	00 00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20f4b0:	b0 01                	mov    al,0x1
  20f4b2:	86 05 58 0b 04 00    	xchg   BYTE PTR [rip+0x40b58],al        # 250010 <stderr_mutex>
  20f4b8:	84 c0                	test   al,al
  20f4ba:	75 f4                	jne    20f4b0 <BmAdd.Acquire.Release+0x480>
    if (stderr_stream) |st| {
  20f4bc:	48 8b 3d 45 0b 04 00 	mov    rdi,QWORD PTR [rip+0x40b45]        # 250008 <stderr_stream>
  20f4c3:	48 85 ff             	test   rdi,rdi
  20f4c6:	74 18                	je     20f4e0 <BmAdd.Acquire.Release+0x4b0>
  20f4c8:	48 8b 0d 71 bb 03 00 	mov    rcx,QWORD PTR [rip+0x3bb71]        # 24b040 <stderr_file_out_stream+0x8>
  20f4cf:	eb 4c                	jmp    20f51d <BmAdd.Acquire.Release+0x4ed>
  20f4d1:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20f4d8:	0f 1f 84 00 00 00 00 
  20f4df:	00 
        stderr_file = try io.getStdErr();
  20f4e0:	c7 05 46 bb 03 00 02 	mov    DWORD PTR [rip+0x3bb46],0x2        # 24b030 <stderr_file>
  20f4e7:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20f4ea:	48 8d 05 3f bb 03 00 	lea    rax,[rip+0x3bb3f]        # 24b030 <stderr_file>
  20f4f1:	48 89 05 40 bb 03 00 	mov    QWORD PTR [rip+0x3bb40],rax        # 24b038 <stderr_file_out_stream>
  20f4f8:	48 8d 05 e1 04 01 00 	lea    rax,[rip+0x104e1]        # 21f9e0 <FileOutStream_writeFn>
  20f4ff:	48 89 05 3a bb 03 00 	mov    QWORD PTR [rip+0x3bb3a],rax        # 24b040 <stderr_file_out_stream+0x8>
  20f506:	48 8d 0d 33 bb 03 00 	lea    rcx,[rip+0x3bb33]        # 24b040 <stderr_file_out_stream+0x8>
  20f50d:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20f510:	48 89 15 f1 0a 04 00 	mov    QWORD PTR [rip+0x40af1],rdx        # 250008 <stderr_stream>
  20f517:	48 89 c1             	mov    rcx,rax
  20f51a:	48 89 d7             	mov    rdi,rdx
  20f51d:	48 8d 35 f4 f8 03 00 	lea    rsi,[rip+0x3f8f4]        # 24ee18 <__unnamed_3>
  20f524:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20f526:	31 c0                	xor    eax,eax
  20f528:	86 05 e2 0a 04 00    	xchg   BYTE PTR [rip+0x40ae2],al        # 250010 <stderr_mutex>
  20f52e:	3c 01                	cmp    al,0x1
  20f530:	c5 f8 10 0d 88 98 ff 	vmovups xmm1,XMMWORD PTR [rip+0xffffffffffff9888]        # 208dc0 <__unnamed_5>
  20f537:	ff 
    if (!ok) {
  20f538:	0f 85 32 08 00 00    	jne    20fd70 <BmAdd.Acquire.Release+0xd40>
                    if (run_time_ns < 1000) {
  20f53e:	49 81 fd e8 03 00 00 	cmp    r13,0x3e8
  20f545:	73 29                	jae    20f570 <BmAdd.Acquire.Release+0x540>
  20f547:	b9 01 00 00 00       	mov    ecx,0x1
  20f54c:	be e8 03 00 00       	mov    esi,0x3e8
                    iterations = (iterations * numer) / denom;
  20f551:	48 0f af de          	imul   rbx,rsi
  20f555:	48 89 d8             	mov    rax,rbx
  20f558:	48 c1 e8 20          	shr    rax,0x20
  20f55c:	74 4c                	je     20f5aa <BmAdd.Acquire.Release+0x57a>
  20f55e:	31 d2                	xor    edx,edx
  20f560:	48 89 d8             	mov    rax,rbx
  20f563:	48 f7 f1             	div    rcx
  20f566:	48 89 c3             	mov    rbx,rax
  20f569:	eb 47                	jmp    20f5b2 <BmAdd.Acquire.Release+0x582>
  20f56b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
                    } else if (run_time_ns < (pSelf.min_runtime_ns / 10)) {
  20f570:	48 ba cd cc cc cc cc 	movabs rdx,0xcccccccccccccccd
  20f577:	cc cc cc 
  20f57a:	c4 e2 fb f6 4c 24 68 	mulx   rcx,rax,QWORD PTR [rsp+0x68]
  20f581:	48 c1 e9 03          	shr    rcx,0x3
  20f585:	31 c0                	xor    eax,eax
  20f587:	49 39 cd             	cmp    r13,rcx
  20f58a:	0f 93 c0             	setae  al
  20f58d:	48 8d 0c c0          	lea    rcx,[rax+rax*8]
  20f591:	48 83 c1 01          	add    rcx,0x1
  20f595:	48 8d 34 85 0a 00 00 	lea    rsi,[rax*4+0xa]
  20f59c:	00 
                    iterations = (iterations * numer) / denom;
  20f59d:	48 0f af de          	imul   rbx,rsi
  20f5a1:	48 89 d8             	mov    rax,rbx
  20f5a4:	48 c1 e8 20          	shr    rax,0x20
  20f5a8:	75 b4                	jne    20f55e <BmAdd.Acquire.Release+0x52e>
  20f5aa:	31 d2                	xor    edx,edx
  20f5ac:	89 d8                	mov    eax,ebx
  20f5ae:	f7 f1                	div    ecx
  20f5b0:	89 c3                	mov    ebx,eax
                    if (iterations > pSelf.max_iterations) {
  20f5b2:	48 8b 44 24 78       	mov    rax,QWORD PTR [rsp+0x78]
  20f5b7:	48 39 c3             	cmp    rbx,rax
  20f5ba:	48 0f 47 d8          	cmova  rbx,rax
                    if (pSelf.logl >= 2) {
  20f5be:	48 83 7c 24 60 02    	cmp    QWORD PTR [rsp+0x60],0x2
  20f5c4:	0f 82 49 fd ff ff    	jb     20f313 <BmAdd.Acquire.Release+0x2e3>
  20f5ca:	e9 31 fd ff ff       	jmp    20f300 <BmAdd.Acquire.Release+0x2d0>
  20f5cf:	90                   	nop
  20f5d0:	c5 f8 10 0d e8 97 ff 	vmovups xmm1,XMMWORD PTR [rip+0xffffffffffff97e8]        # 208dc0 <__unnamed_5>
  20f5d7:	ff 
  20f5d8:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
  20f5de:	0f 82 a5 fd ff ff    	jb     20f389 <BmAdd.Acquire.Release+0x359>
  20f5e4:	e9 6b 07 00 00       	jmp    20fd54 <BmAdd.Acquire.Release+0xd24>
  20f5e9:	c5 f8 10 0d cf 97 ff 	vmovups xmm1,XMMWORD PTR [rip+0xffffffffffff97cf]        # 208dc0 <__unnamed_5>
  20f5f0:	ff 
  20f5f1:	c5 f9 6f 94 24 c0 00 	vmovdqa xmm2,XMMWORD PTR [rsp+0xc0]
  20f5f8:	00 00 
  20f5fa:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
  20f600:	0f 82 33 fe ff ff    	jb     20f439 <BmAdd.Acquire.Release+0x409>
  20f606:	e9 65 07 00 00       	jmp    20fd70 <BmAdd.Acquire.Release+0xd40>
  20f60b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  20f610:	c5 f8 10 0d a8 97 ff 	vmovups xmm1,XMMWORD PTR [rip+0xffffffffffff97a8]        # 208dc0 <__unnamed_5>
  20f617:	ff 
  20f618:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
                if (errno != 0) return std.os.unexpectedErrorPosix(errno);
  20f61e:	0f 82 ad fb ff ff    	jb     20f1d1 <BmAdd.Acquire.Release+0x1a1>
  20f624:	e9 2b 07 00 00       	jmp    20fd54 <BmAdd.Acquire.Release+0xd24>
  20f629:	c5 f8 10 0d 8f 97 ff 	vmovups xmm1,XMMWORD PTR [rip+0xffffffffffff978f]        # 208dc0 <__unnamed_5>
  20f630:	ff 
  20f631:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
  20f637:	0f 82 ec fb ff ff    	jb     20f229 <BmAdd.Acquire.Release+0x1f9>
  20f63d:	e9 2e 07 00 00       	jmp    20fd70 <BmAdd.Acquire.Release+0xd40>
                            Result { .run_time_ns = run_time_ns, .iterations = iterations});
  20f642:	4c 89 ac 24 e8 00 00 	mov    QWORD PTR [rsp+0xe8],r13
  20f649:	00 
  20f64a:	48 89 9c 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rbx
  20f651:	00 
                    try pSelf.results.append(
  20f652:	48 8d bc 24 98 00 00 	lea    rdi,[rsp+0x98]
  20f659:	00 
  20f65a:	48 8d b4 24 e8 00 00 	lea    rsi,[rsp+0xe8]
  20f661:	00 
  20f662:	e8 89 42 00 00       	call   2138f0 <AlignedArrayList(Result,8)_append>
  20f667:	66 85 c0             	test   ax,ax
  20f66a:	0f 85 e8 06 00 00    	jne    20fd58 <BmAdd.Acquire.Release+0xd28>
            if (pSelf.r != (u64(pSelf.a) + u64(pSelf.b))) return error.Failed;
  20f670:	4d 39 e6             	cmp    r14,r12
                    try bm.tearDown();
  20f673:	0f 85 f1 06 00 00    	jne    20fd6a <BmAdd.Acquire.Release+0xd3a>
            if (once) {
  20f679:	f6 44 24 1c 01       	test   BYTE PTR [rsp+0x1c],0x1
  20f67e:	4c 8d 64 24 07       	lea    r12,[rsp+0x7]
  20f683:	0f 84 de 05 00 00    	je     20fc67 <BmAdd.Acquire.Release+0xc37>
                try leftJustified(22, "name repetitions:{}", pSelf.repetitions);
  20f689:	48 8b 7c 24 70       	mov    rdi,QWORD PTR [rsp+0x70]
  20f68e:	e8 4d 68 00 00       	call   215ee0 <Benchmark_leftJustified>
  20f693:	66 85 c0             	test   ax,ax
  20f696:	0f 85 bc 06 00 00    	jne    20fd58 <BmAdd.Acquire.Release+0xd28>
                try rightJustified(14, "{}", "iterations");
  20f69c:	e8 df 6a 00 00       	call   216180 <Benchmark_rightJustified>
  20f6a1:	66 85 c0             	test   ax,ax
  20f6a4:	0f 85 ae 06 00 00    	jne    20fd58 <BmAdd.Acquire.Release+0xd28>
        var buffer: [40]u8 = undefined;
  20f6aa:	c5 fe 6f 05 e9 5e ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffff5ee9]        # 20559b <__unnamed_7>
  20f6b1:	ff 
  20f6b2:	c5 fe 7f 44 24 20    	vmovdqu YMMWORD PTR [rsp+0x20],ymm0
  20f6b8:	48 8b 05 fc 5e ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffff5efc]        # 2055bb <__unnamed_7+0x20>
  20f6bf:	48 89 44 24 40       	mov    QWORD PTR [rsp+0x40],rax
  20f6c4:	c7 44 24 20 74 69 6d 	mov    DWORD PTR [rsp+0x20],0x656d6974
  20f6cb:	65 
  20f6cc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20f6d0:	b0 01                	mov    al,0x1
  20f6d2:	86 05 38 09 04 00    	xchg   BYTE PTR [rip+0x40938],al        # 250010 <stderr_mutex>
  20f6d8:	84 c0                	test   al,al
  20f6da:	75 f4                	jne    20f6d0 <BmAdd.Acquire.Release+0x6a0>
    if (stderr_stream) |st| {
  20f6dc:	48 8b 3d 25 09 04 00 	mov    rdi,QWORD PTR [rip+0x40925]        # 250008 <stderr_stream>
  20f6e3:	48 85 ff             	test   rdi,rdi
  20f6e6:	74 09                	je     20f6f1 <BmAdd.Acquire.Release+0x6c1>
  20f6e8:	48 8b 0d 51 b9 03 00 	mov    rcx,QWORD PTR [rip+0x3b951]        # 24b040 <stderr_file_out_stream+0x8>
  20f6ef:	eb 3d                	jmp    20f72e <BmAdd.Acquire.Release+0x6fe>
        stderr_file = try io.getStdErr();
  20f6f1:	c7 05 35 b9 03 00 02 	mov    DWORD PTR [rip+0x3b935],0x2        # 24b030 <stderr_file>
  20f6f8:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20f6fb:	48 8d 05 2e b9 03 00 	lea    rax,[rip+0x3b92e]        # 24b030 <stderr_file>
  20f702:	48 89 05 2f b9 03 00 	mov    QWORD PTR [rip+0x3b92f],rax        # 24b038 <stderr_file_out_stream>
  20f709:	48 8d 05 d0 02 01 00 	lea    rax,[rip+0x102d0]        # 21f9e0 <FileOutStream_writeFn>
  20f710:	48 89 05 29 b9 03 00 	mov    QWORD PTR [rip+0x3b929],rax        # 24b040 <stderr_file_out_stream+0x8>
  20f717:	48 8d 0d 22 b9 03 00 	lea    rcx,[rip+0x3b922]        # 24b040 <stderr_file_out_stream+0x8>
  20f71e:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20f721:	48 89 15 e0 08 04 00 	mov    QWORD PTR [rip+0x408e0],rdx        # 250008 <stderr_stream>
  20f728:	48 89 c1             	mov    rcx,rax
  20f72b:	48 89 d7             	mov    rdi,rdx
  20f72e:	c6 44 24 07 20       	mov    BYTE PTR [rsp+0x7],0x20
    return output(context, (*[1]u8)(&c)[0..]);
  20f733:	4c 89 64 24 08       	mov    QWORD PTR [rsp+0x8],r12
  20f738:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  20f73f:	00 00 
  20f741:	48 8d 74 24 08       	lea    rsi,[rsp+0x8]
  20f746:	c5 f8 77             	vzeroupper 
  20f749:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20f74b:	31 c0                	xor    eax,eax
  20f74d:	86 05 bd 08 04 00    	xchg   BYTE PTR [rip+0x408bd],al        # 250010 <stderr_mutex>
  20f753:	3c 01                	cmp    al,0x1
    if (!ok) {
  20f755:	0f 85 15 06 00 00    	jne    20fd70 <BmAdd.Acquire.Release+0xd40>
  20f75b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20f760:	b0 01                	mov    al,0x1
  20f762:	86 05 a8 08 04 00    	xchg   BYTE PTR [rip+0x408a8],al        # 250010 <stderr_mutex>
  20f768:	84 c0                	test   al,al
  20f76a:	75 f4                	jne    20f760 <BmAdd.Acquire.Release+0x730>
    if (stderr_stream) |st| {
  20f76c:	48 8b 3d 95 08 04 00 	mov    rdi,QWORD PTR [rip+0x40895]        # 250008 <stderr_stream>
  20f773:	48 85 ff             	test   rdi,rdi
  20f776:	74 09                	je     20f781 <BmAdd.Acquire.Release+0x751>
  20f778:	48 8b 0d c1 b8 03 00 	mov    rcx,QWORD PTR [rip+0x3b8c1]        # 24b040 <stderr_file_out_stream+0x8>
  20f77f:	eb 3d                	jmp    20f7be <BmAdd.Acquire.Release+0x78e>
        stderr_file = try io.getStdErr();
  20f781:	c7 05 a5 b8 03 00 02 	mov    DWORD PTR [rip+0x3b8a5],0x2        # 24b030 <stderr_file>
  20f788:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20f78b:	48 8d 05 9e b8 03 00 	lea    rax,[rip+0x3b89e]        # 24b030 <stderr_file>
  20f792:	48 89 05 9f b8 03 00 	mov    QWORD PTR [rip+0x3b89f],rax        # 24b038 <stderr_file_out_stream>
  20f799:	48 8d 05 40 02 01 00 	lea    rax,[rip+0x10240]        # 21f9e0 <FileOutStream_writeFn>
  20f7a0:	48 89 05 99 b8 03 00 	mov    QWORD PTR [rip+0x3b899],rax        # 24b040 <stderr_file_out_stream+0x8>
  20f7a7:	48 8d 0d 92 b8 03 00 	lea    rcx,[rip+0x3b892]        # 24b040 <stderr_file_out_stream+0x8>
  20f7ae:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20f7b1:	48 89 15 50 08 04 00 	mov    QWORD PTR [rip+0x40850],rdx        # 250008 <stderr_stream>
  20f7b8:	48 89 c1             	mov    rcx,rax
  20f7bb:	48 89 d7             	mov    rdi,rdx
  20f7be:	c6 44 24 07 20       	mov    BYTE PTR [rsp+0x7],0x20
  20f7c3:	4c 89 64 24 08       	mov    QWORD PTR [rsp+0x8],r12
  20f7c8:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  20f7cf:	00 00 
  20f7d1:	48 8d 74 24 08       	lea    rsi,[rsp+0x8]
  20f7d6:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20f7d8:	31 c0                	xor    eax,eax
  20f7da:	86 05 30 08 04 00    	xchg   BYTE PTR [rip+0x40830],al        # 250010 <stderr_mutex>
  20f7e0:	3c 01                	cmp    al,0x1
    if (!ok) {
  20f7e2:	0f 85 88 05 00 00    	jne    20fd70 <BmAdd.Acquire.Release+0xd40>
  20f7e8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  20f7ef:	00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20f7f0:	b0 01                	mov    al,0x1
  20f7f2:	86 05 18 08 04 00    	xchg   BYTE PTR [rip+0x40818],al        # 250010 <stderr_mutex>
  20f7f8:	84 c0                	test   al,al
  20f7fa:	75 f4                	jne    20f7f0 <BmAdd.Acquire.Release+0x7c0>
    if (stderr_stream) |st| {
  20f7fc:	48 8b 3d 05 08 04 00 	mov    rdi,QWORD PTR [rip+0x40805]        # 250008 <stderr_stream>
  20f803:	48 85 ff             	test   rdi,rdi
  20f806:	74 09                	je     20f811 <BmAdd.Acquire.Release+0x7e1>
  20f808:	48 8b 0d 31 b8 03 00 	mov    rcx,QWORD PTR [rip+0x3b831]        # 24b040 <stderr_file_out_stream+0x8>
  20f80f:	eb 3d                	jmp    20f84e <BmAdd.Acquire.Release+0x81e>
        stderr_file = try io.getStdErr();
  20f811:	c7 05 15 b8 03 00 02 	mov    DWORD PTR [rip+0x3b815],0x2        # 24b030 <stderr_file>
  20f818:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20f81b:	48 8d 05 0e b8 03 00 	lea    rax,[rip+0x3b80e]        # 24b030 <stderr_file>
  20f822:	48 89 05 0f b8 03 00 	mov    QWORD PTR [rip+0x3b80f],rax        # 24b038 <stderr_file_out_stream>
  20f829:	48 8d 05 b0 01 01 00 	lea    rax,[rip+0x101b0]        # 21f9e0 <FileOutStream_writeFn>
  20f830:	48 89 05 09 b8 03 00 	mov    QWORD PTR [rip+0x3b809],rax        # 24b040 <stderr_file_out_stream+0x8>
  20f837:	48 8d 0d 02 b8 03 00 	lea    rcx,[rip+0x3b802]        # 24b040 <stderr_file_out_stream+0x8>
  20f83e:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20f841:	48 89 15 c0 07 04 00 	mov    QWORD PTR [rip+0x407c0],rdx        # 250008 <stderr_stream>
  20f848:	48 89 c1             	mov    rcx,rax
  20f84b:	48 89 d7             	mov    rdi,rdx
  20f84e:	c6 44 24 07 20       	mov    BYTE PTR [rsp+0x7],0x20
  20f853:	4c 89 64 24 08       	mov    QWORD PTR [rsp+0x8],r12
  20f858:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  20f85f:	00 00 
  20f861:	48 8d 74 24 08       	lea    rsi,[rsp+0x8]
  20f866:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20f868:	31 c0                	xor    eax,eax
  20f86a:	86 05 a0 07 04 00    	xchg   BYTE PTR [rip+0x407a0],al        # 250010 <stderr_mutex>
  20f870:	3c 01                	cmp    al,0x1
    if (!ok) {
  20f872:	0f 85 f8 04 00 00    	jne    20fd70 <BmAdd.Acquire.Release+0xd40>
  20f878:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  20f87f:	00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20f880:	b0 01                	mov    al,0x1
  20f882:	86 05 88 07 04 00    	xchg   BYTE PTR [rip+0x40788],al        # 250010 <stderr_mutex>
  20f888:	84 c0                	test   al,al
  20f88a:	75 f4                	jne    20f880 <BmAdd.Acquire.Release+0x850>
    if (stderr_stream) |st| {
  20f88c:	48 8b 3d 75 07 04 00 	mov    rdi,QWORD PTR [rip+0x40775]        # 250008 <stderr_stream>
  20f893:	48 85 ff             	test   rdi,rdi
  20f896:	74 09                	je     20f8a1 <BmAdd.Acquire.Release+0x871>
  20f898:	48 8b 0d a1 b7 03 00 	mov    rcx,QWORD PTR [rip+0x3b7a1]        # 24b040 <stderr_file_out_stream+0x8>
  20f89f:	eb 3d                	jmp    20f8de <BmAdd.Acquire.Release+0x8ae>
        stderr_file = try io.getStdErr();
  20f8a1:	c7 05 85 b7 03 00 02 	mov    DWORD PTR [rip+0x3b785],0x2        # 24b030 <stderr_file>
  20f8a8:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20f8ab:	48 8d 05 7e b7 03 00 	lea    rax,[rip+0x3b77e]        # 24b030 <stderr_file>
  20f8b2:	48 89 05 7f b7 03 00 	mov    QWORD PTR [rip+0x3b77f],rax        # 24b038 <stderr_file_out_stream>
  20f8b9:	48 8d 05 20 01 01 00 	lea    rax,[rip+0x10120]        # 21f9e0 <FileOutStream_writeFn>
  20f8c0:	48 89 05 79 b7 03 00 	mov    QWORD PTR [rip+0x3b779],rax        # 24b040 <stderr_file_out_stream+0x8>
  20f8c7:	48 8d 0d 72 b7 03 00 	lea    rcx,[rip+0x3b772]        # 24b040 <stderr_file_out_stream+0x8>
  20f8ce:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20f8d1:	48 89 15 30 07 04 00 	mov    QWORD PTR [rip+0x40730],rdx        # 250008 <stderr_stream>
  20f8d8:	48 89 c1             	mov    rcx,rax
  20f8db:	48 89 d7             	mov    rdi,rdx
  20f8de:	c6 44 24 07 20       	mov    BYTE PTR [rsp+0x7],0x20
  20f8e3:	4c 89 64 24 08       	mov    QWORD PTR [rsp+0x8],r12
  20f8e8:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  20f8ef:	00 00 
  20f8f1:	48 8d 74 24 08       	lea    rsi,[rsp+0x8]
  20f8f6:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20f8f8:	31 c0                	xor    eax,eax
  20f8fa:	86 05 10 07 04 00    	xchg   BYTE PTR [rip+0x40710],al        # 250010 <stderr_mutex>
  20f900:	3c 01                	cmp    al,0x1
    if (!ok) {
  20f902:	0f 85 68 04 00 00    	jne    20fd70 <BmAdd.Acquire.Release+0xd40>
  20f908:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  20f90f:	00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20f910:	b0 01                	mov    al,0x1
  20f912:	86 05 f8 06 04 00    	xchg   BYTE PTR [rip+0x406f8],al        # 250010 <stderr_mutex>
  20f918:	84 c0                	test   al,al
  20f91a:	75 f4                	jne    20f910 <BmAdd.Acquire.Release+0x8e0>
    if (stderr_stream) |st| {
  20f91c:	48 8b 3d e5 06 04 00 	mov    rdi,QWORD PTR [rip+0x406e5]        # 250008 <stderr_stream>
  20f923:	48 85 ff             	test   rdi,rdi
  20f926:	74 09                	je     20f931 <BmAdd.Acquire.Release+0x901>
  20f928:	48 8b 0d 11 b7 03 00 	mov    rcx,QWORD PTR [rip+0x3b711]        # 24b040 <stderr_file_out_stream+0x8>
  20f92f:	eb 3d                	jmp    20f96e <BmAdd.Acquire.Release+0x93e>
        stderr_file = try io.getStdErr();
  20f931:	c7 05 f5 b6 03 00 02 	mov    DWORD PTR [rip+0x3b6f5],0x2        # 24b030 <stderr_file>
  20f938:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20f93b:	48 8d 05 ee b6 03 00 	lea    rax,[rip+0x3b6ee]        # 24b030 <stderr_file>
  20f942:	48 89 05 ef b6 03 00 	mov    QWORD PTR [rip+0x3b6ef],rax        # 24b038 <stderr_file_out_stream>
  20f949:	48 8d 05 90 00 01 00 	lea    rax,[rip+0x10090]        # 21f9e0 <FileOutStream_writeFn>
  20f950:	48 89 05 e9 b6 03 00 	mov    QWORD PTR [rip+0x3b6e9],rax        # 24b040 <stderr_file_out_stream+0x8>
  20f957:	48 8d 0d e2 b6 03 00 	lea    rcx,[rip+0x3b6e2]        # 24b040 <stderr_file_out_stream+0x8>
  20f95e:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20f961:	48 89 15 a0 06 04 00 	mov    QWORD PTR [rip+0x406a0],rdx        # 250008 <stderr_stream>
  20f968:	48 89 c1             	mov    rcx,rax
  20f96b:	48 89 d7             	mov    rdi,rdx
  20f96e:	c6 44 24 07 20       	mov    BYTE PTR [rsp+0x7],0x20
  20f973:	4c 89 64 24 08       	mov    QWORD PTR [rsp+0x8],r12
  20f978:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  20f97f:	00 00 
  20f981:	48 8d 74 24 08       	lea    rsi,[rsp+0x8]
  20f986:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20f988:	31 c0                	xor    eax,eax
  20f98a:	86 05 80 06 04 00    	xchg   BYTE PTR [rip+0x40680],al        # 250010 <stderr_mutex>
  20f990:	3c 01                	cmp    al,0x1
    if (!ok) {
  20f992:	0f 85 d8 03 00 00    	jne    20fd70 <BmAdd.Acquire.Release+0xd40>
  20f998:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  20f99f:	00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20f9a0:	b0 01                	mov    al,0x1
  20f9a2:	86 05 68 06 04 00    	xchg   BYTE PTR [rip+0x40668],al        # 250010 <stderr_mutex>
  20f9a8:	84 c0                	test   al,al
  20f9aa:	75 f4                	jne    20f9a0 <BmAdd.Acquire.Release+0x970>
    if (stderr_stream) |st| {
  20f9ac:	48 8b 3d 55 06 04 00 	mov    rdi,QWORD PTR [rip+0x40655]        # 250008 <stderr_stream>
  20f9b3:	48 85 ff             	test   rdi,rdi
  20f9b6:	74 09                	je     20f9c1 <BmAdd.Acquire.Release+0x991>
  20f9b8:	48 8b 0d 81 b6 03 00 	mov    rcx,QWORD PTR [rip+0x3b681]        # 24b040 <stderr_file_out_stream+0x8>
  20f9bf:	eb 3d                	jmp    20f9fe <BmAdd.Acquire.Release+0x9ce>
        stderr_file = try io.getStdErr();
  20f9c1:	c7 05 65 b6 03 00 02 	mov    DWORD PTR [rip+0x3b665],0x2        # 24b030 <stderr_file>
  20f9c8:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20f9cb:	48 8d 05 5e b6 03 00 	lea    rax,[rip+0x3b65e]        # 24b030 <stderr_file>
  20f9d2:	48 89 05 5f b6 03 00 	mov    QWORD PTR [rip+0x3b65f],rax        # 24b038 <stderr_file_out_stream>
  20f9d9:	48 8d 05 00 00 01 00 	lea    rax,[rip+0x10000]        # 21f9e0 <FileOutStream_writeFn>
  20f9e0:	48 89 05 59 b6 03 00 	mov    QWORD PTR [rip+0x3b659],rax        # 24b040 <stderr_file_out_stream+0x8>
  20f9e7:	48 8d 0d 52 b6 03 00 	lea    rcx,[rip+0x3b652]        # 24b040 <stderr_file_out_stream+0x8>
  20f9ee:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20f9f1:	48 89 15 10 06 04 00 	mov    QWORD PTR [rip+0x40610],rdx        # 250008 <stderr_stream>
  20f9f8:	48 89 c1             	mov    rcx,rax
  20f9fb:	48 89 d7             	mov    rdi,rdx
  20f9fe:	c6 44 24 07 20       	mov    BYTE PTR [rsp+0x7],0x20
  20fa03:	4c 89 64 24 08       	mov    QWORD PTR [rsp+0x8],r12
  20fa08:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  20fa0f:	00 00 
  20fa11:	48 8d 74 24 08       	lea    rsi,[rsp+0x8]
  20fa16:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20fa18:	31 c0                	xor    eax,eax
  20fa1a:	86 05 f0 05 04 00    	xchg   BYTE PTR [rip+0x405f0],al        # 250010 <stderr_mutex>
  20fa20:	3c 01                	cmp    al,0x1
    if (!ok) {
  20fa22:	0f 85 48 03 00 00    	jne    20fd70 <BmAdd.Acquire.Release+0xd40>
  20fa28:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  20fa2f:	00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20fa30:	b0 01                	mov    al,0x1
  20fa32:	86 05 d8 05 04 00    	xchg   BYTE PTR [rip+0x405d8],al        # 250010 <stderr_mutex>
  20fa38:	84 c0                	test   al,al
  20fa3a:	75 f4                	jne    20fa30 <BmAdd.Acquire.Release+0xa00>
    if (stderr_stream) |st| {
  20fa3c:	48 8b 3d c5 05 04 00 	mov    rdi,QWORD PTR [rip+0x405c5]        # 250008 <stderr_stream>
  20fa43:	48 85 ff             	test   rdi,rdi
  20fa46:	74 09                	je     20fa51 <BmAdd.Acquire.Release+0xa21>
  20fa48:	48 8b 0d f1 b5 03 00 	mov    rcx,QWORD PTR [rip+0x3b5f1]        # 24b040 <stderr_file_out_stream+0x8>
  20fa4f:	eb 3d                	jmp    20fa8e <BmAdd.Acquire.Release+0xa5e>
        stderr_file = try io.getStdErr();
  20fa51:	c7 05 d5 b5 03 00 02 	mov    DWORD PTR [rip+0x3b5d5],0x2        # 24b030 <stderr_file>
  20fa58:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20fa5b:	48 8d 05 ce b5 03 00 	lea    rax,[rip+0x3b5ce]        # 24b030 <stderr_file>
  20fa62:	48 89 05 cf b5 03 00 	mov    QWORD PTR [rip+0x3b5cf],rax        # 24b038 <stderr_file_out_stream>
  20fa69:	48 8d 05 70 ff 00 00 	lea    rax,[rip+0xff70]        # 21f9e0 <FileOutStream_writeFn>
  20fa70:	48 89 05 c9 b5 03 00 	mov    QWORD PTR [rip+0x3b5c9],rax        # 24b040 <stderr_file_out_stream+0x8>
  20fa77:	48 8d 0d c2 b5 03 00 	lea    rcx,[rip+0x3b5c2]        # 24b040 <stderr_file_out_stream+0x8>
  20fa7e:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20fa81:	48 89 15 80 05 04 00 	mov    QWORD PTR [rip+0x40580],rdx        # 250008 <stderr_stream>
  20fa88:	48 89 c1             	mov    rcx,rax
  20fa8b:	48 89 d7             	mov    rdi,rdx
  20fa8e:	c6 44 24 07 20       	mov    BYTE PTR [rsp+0x7],0x20
  20fa93:	4c 89 64 24 08       	mov    QWORD PTR [rsp+0x8],r12
  20fa98:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  20fa9f:	00 00 
  20faa1:	48 8d 74 24 08       	lea    rsi,[rsp+0x8]
  20faa6:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20faa8:	31 c0                	xor    eax,eax
  20faaa:	86 05 60 05 04 00    	xchg   BYTE PTR [rip+0x40560],al        # 250010 <stderr_mutex>
  20fab0:	3c 01                	cmp    al,0x1
    if (!ok) {
  20fab2:	0f 85 b8 02 00 00    	jne    20fd70 <BmAdd.Acquire.Release+0xd40>
  20fab8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  20fabf:	00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20fac0:	b0 01                	mov    al,0x1
  20fac2:	86 05 48 05 04 00    	xchg   BYTE PTR [rip+0x40548],al        # 250010 <stderr_mutex>
  20fac8:	84 c0                	test   al,al
  20faca:	75 f4                	jne    20fac0 <BmAdd.Acquire.Release+0xa90>
    if (stderr_stream) |st| {
  20facc:	48 8b 3d 35 05 04 00 	mov    rdi,QWORD PTR [rip+0x40535]        # 250008 <stderr_stream>
  20fad3:	48 85 ff             	test   rdi,rdi
  20fad6:	74 09                	je     20fae1 <BmAdd.Acquire.Release+0xab1>
  20fad8:	48 8b 0d 61 b5 03 00 	mov    rcx,QWORD PTR [rip+0x3b561]        # 24b040 <stderr_file_out_stream+0x8>
  20fadf:	eb 3d                	jmp    20fb1e <BmAdd.Acquire.Release+0xaee>
        stderr_file = try io.getStdErr();
  20fae1:	c7 05 45 b5 03 00 02 	mov    DWORD PTR [rip+0x3b545],0x2        # 24b030 <stderr_file>
  20fae8:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20faeb:	48 8d 05 3e b5 03 00 	lea    rax,[rip+0x3b53e]        # 24b030 <stderr_file>
  20faf2:	48 89 05 3f b5 03 00 	mov    QWORD PTR [rip+0x3b53f],rax        # 24b038 <stderr_file_out_stream>
  20faf9:	48 8d 05 e0 fe 00 00 	lea    rax,[rip+0xfee0]        # 21f9e0 <FileOutStream_writeFn>
  20fb00:	48 89 05 39 b5 03 00 	mov    QWORD PTR [rip+0x3b539],rax        # 24b040 <stderr_file_out_stream+0x8>
  20fb07:	48 8d 0d 32 b5 03 00 	lea    rcx,[rip+0x3b532]        # 24b040 <stderr_file_out_stream+0x8>
  20fb0e:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20fb11:	48 89 15 f0 04 04 00 	mov    QWORD PTR [rip+0x404f0],rdx        # 250008 <stderr_stream>
  20fb18:	48 89 c1             	mov    rcx,rax
  20fb1b:	48 89 d7             	mov    rdi,rdx
  20fb1e:	c6 44 24 07 20       	mov    BYTE PTR [rsp+0x7],0x20
  20fb23:	4c 89 64 24 08       	mov    QWORD PTR [rsp+0x8],r12
  20fb28:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  20fb2f:	00 00 
  20fb31:	48 8d 74 24 08       	lea    rsi,[rsp+0x8]
  20fb36:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20fb38:	31 c0                	xor    eax,eax
  20fb3a:	86 05 d0 04 04 00    	xchg   BYTE PTR [rip+0x404d0],al        # 250010 <stderr_mutex>
  20fb40:	3c 01                	cmp    al,0x1
    if (!ok) {
  20fb42:	0f 85 28 02 00 00    	jne    20fd70 <BmAdd.Acquire.Release+0xd40>
  20fb48:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  20fb4f:	00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20fb50:	b0 01                	mov    al,0x1
  20fb52:	86 05 b8 04 04 00    	xchg   BYTE PTR [rip+0x404b8],al        # 250010 <stderr_mutex>
  20fb58:	84 c0                	test   al,al
  20fb5a:	75 f4                	jne    20fb50 <BmAdd.Acquire.Release+0xb20>
    if (stderr_stream) |st| {
  20fb5c:	48 8b 3d a5 04 04 00 	mov    rdi,QWORD PTR [rip+0x404a5]        # 250008 <stderr_stream>
  20fb63:	48 85 ff             	test   rdi,rdi
  20fb66:	74 09                	je     20fb71 <BmAdd.Acquire.Release+0xb41>
  20fb68:	48 8b 0d d1 b4 03 00 	mov    rcx,QWORD PTR [rip+0x3b4d1]        # 24b040 <stderr_file_out_stream+0x8>
  20fb6f:	eb 3d                	jmp    20fbae <BmAdd.Acquire.Release+0xb7e>
        stderr_file = try io.getStdErr();
  20fb71:	c7 05 b5 b4 03 00 02 	mov    DWORD PTR [rip+0x3b4b5],0x2        # 24b030 <stderr_file>
  20fb78:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20fb7b:	48 8d 05 ae b4 03 00 	lea    rax,[rip+0x3b4ae]        # 24b030 <stderr_file>
  20fb82:	48 89 05 af b4 03 00 	mov    QWORD PTR [rip+0x3b4af],rax        # 24b038 <stderr_file_out_stream>
  20fb89:	48 8d 05 50 fe 00 00 	lea    rax,[rip+0xfe50]        # 21f9e0 <FileOutStream_writeFn>
  20fb90:	48 89 05 a9 b4 03 00 	mov    QWORD PTR [rip+0x3b4a9],rax        # 24b040 <stderr_file_out_stream+0x8>
  20fb97:	48 8d 0d a2 b4 03 00 	lea    rcx,[rip+0x3b4a2]        # 24b040 <stderr_file_out_stream+0x8>
  20fb9e:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20fba1:	48 89 15 60 04 04 00 	mov    QWORD PTR [rip+0x40460],rdx        # 250008 <stderr_stream>
  20fba8:	48 89 c1             	mov    rcx,rax
  20fbab:	48 89 d7             	mov    rdi,rdx
                const casted_value = ([]const u8)(value);
  20fbae:	4c 89 7c 24 08       	mov    QWORD PTR [rsp+0x8],r15
  20fbb3:	48 c7 44 24 10 04 00 	mov    QWORD PTR [rsp+0x10],0x4
  20fbba:	00 00 
                return output(context, casted_value);
  20fbbc:	48 8d 74 24 08       	lea    rsi,[rsp+0x8]
  20fbc1:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20fbc3:	31 c0                	xor    eax,eax
  20fbc5:	86 05 45 04 04 00    	xchg   BYTE PTR [rip+0x40445],al        # 250010 <stderr_mutex>
  20fbcb:	3c 01                	cmp    al,0x1
    if (!ok) {
  20fbcd:	0f 85 9d 01 00 00    	jne    20fd70 <BmAdd.Acquire.Release+0xd40>
                try rightJustified(18, "{}", "time/operation");
  20fbd3:	e8 88 68 00 00       	call   216460 <Benchmark_rightJustified.38>
  20fbd8:	66 85 c0             	test   ax,ax
  20fbdb:	0f 85 77 01 00 00    	jne    20fd58 <BmAdd.Acquire.Release+0xd28>
  20fbe1:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20fbe8:	0f 1f 84 00 00 00 00 
  20fbef:	00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20fbf0:	b0 01                	mov    al,0x1
  20fbf2:	86 05 18 04 04 00    	xchg   BYTE PTR [rip+0x40418],al        # 250010 <stderr_mutex>
  20fbf8:	84 c0                	test   al,al
  20fbfa:	75 f4                	jne    20fbf0 <BmAdd.Acquire.Release+0xbc0>
    if (stderr_stream) |st| {
  20fbfc:	48 8b 3d 05 04 04 00 	mov    rdi,QWORD PTR [rip+0x40405]        # 250008 <stderr_stream>
  20fc03:	48 85 ff             	test   rdi,rdi
  20fc06:	74 09                	je     20fc11 <BmAdd.Acquire.Release+0xbe1>
  20fc08:	48 8b 0d 31 b4 03 00 	mov    rcx,QWORD PTR [rip+0x3b431]        # 24b040 <stderr_file_out_stream+0x8>
  20fc0f:	eb 3d                	jmp    20fc4e <BmAdd.Acquire.Release+0xc1e>
        stderr_file = try io.getStdErr();
  20fc11:	c7 05 15 b4 03 00 02 	mov    DWORD PTR [rip+0x3b415],0x2        # 24b030 <stderr_file>
  20fc18:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20fc1b:	48 8d 05 0e b4 03 00 	lea    rax,[rip+0x3b40e]        # 24b030 <stderr_file>
  20fc22:	48 89 05 0f b4 03 00 	mov    QWORD PTR [rip+0x3b40f],rax        # 24b038 <stderr_file_out_stream>
  20fc29:	48 8d 05 b0 fd 00 00 	lea    rax,[rip+0xfdb0]        # 21f9e0 <FileOutStream_writeFn>
  20fc30:	48 89 05 09 b4 03 00 	mov    QWORD PTR [rip+0x3b409],rax        # 24b040 <stderr_file_out_stream+0x8>
  20fc37:	48 8d 0d 02 b4 03 00 	lea    rcx,[rip+0x3b402]        # 24b040 <stderr_file_out_stream+0x8>
  20fc3e:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20fc41:	48 89 15 c0 03 04 00 	mov    QWORD PTR [rip+0x403c0],rdx        # 250008 <stderr_stream>
  20fc48:	48 89 c1             	mov    rcx,rax
  20fc4b:	48 89 d7             	mov    rdi,rdx
        try output(context, fmt[start_index..]);
  20fc4e:	48 8d 35 c3 f1 03 00 	lea    rsi,[rip+0x3f1c3]        # 24ee18 <__unnamed_3>
  20fc55:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20fc57:	31 c0                	xor    eax,eax
  20fc59:	86 05 b1 03 04 00    	xchg   BYTE PTR [rip+0x403b1],al        # 250010 <stderr_mutex>
  20fc5f:	3c 01                	cmp    al,0x1
    if (!ok) {
  20fc61:	0f 85 09 01 00 00    	jne    20fd70 <BmAdd.Acquire.Release+0xd40>
            try pSelf.report(pSelf.results.items[pSelf.results.len - 1]); warn("\n");
  20fc67:	48 8b 84 24 98 00 00 	mov    rax,QWORD PTR [rsp+0x98]
  20fc6e:	00 
  20fc6f:	48 8b 8c 24 a8 00 00 	mov    rcx,QWORD PTR [rsp+0xa8]
  20fc76:	00 
  20fc77:	48 c1 e1 04          	shl    rcx,0x4
  20fc7b:	48 8d 34 08          	lea    rsi,[rax+rcx*1]
  20fc7f:	48 83 c6 f0          	add    rsi,0xfffffffffffffff0
  20fc83:	48 8d 7c 24 50       	lea    rdi,[rsp+0x50]
  20fc88:	e8 d3 3d 00 00       	call   213a60 <Benchmark_report>
  20fc8d:	66 85 c0             	test   ax,ax
  20fc90:	0f 85 c2 00 00 00    	jne    20fd58 <BmAdd.Acquire.Release+0xd28>
  20fc96:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  20fc9d:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20fca0:	b0 01                	mov    al,0x1
  20fca2:	86 05 68 03 04 00    	xchg   BYTE PTR [rip+0x40368],al        # 250010 <stderr_mutex>
  20fca8:	84 c0                	test   al,al
  20fcaa:	75 f4                	jne    20fca0 <BmAdd.Acquire.Release+0xc70>
    if (stderr_stream) |st| {
  20fcac:	48 8b 3d 55 03 04 00 	mov    rdi,QWORD PTR [rip+0x40355]        # 250008 <stderr_stream>
  20fcb3:	48 85 ff             	test   rdi,rdi
  20fcb6:	74 09                	je     20fcc1 <BmAdd.Acquire.Release+0xc91>
  20fcb8:	48 8b 0d 81 b3 03 00 	mov    rcx,QWORD PTR [rip+0x3b381]        # 24b040 <stderr_file_out_stream+0x8>
  20fcbf:	eb 3d                	jmp    20fcfe <BmAdd.Acquire.Release+0xcce>
        stderr_file = try io.getStdErr();
  20fcc1:	c7 05 65 b3 03 00 02 	mov    DWORD PTR [rip+0x3b365],0x2        # 24b030 <stderr_file>
  20fcc8:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20fccb:	48 8d 05 5e b3 03 00 	lea    rax,[rip+0x3b35e]        # 24b030 <stderr_file>
  20fcd2:	48 89 05 5f b3 03 00 	mov    QWORD PTR [rip+0x3b35f],rax        # 24b038 <stderr_file_out_stream>
  20fcd9:	48 8d 05 00 fd 00 00 	lea    rax,[rip+0xfd00]        # 21f9e0 <FileOutStream_writeFn>
  20fce0:	48 89 05 59 b3 03 00 	mov    QWORD PTR [rip+0x3b359],rax        # 24b040 <stderr_file_out_stream+0x8>
  20fce7:	48 8d 0d 52 b3 03 00 	lea    rcx,[rip+0x3b352]        # 24b040 <stderr_file_out_stream+0x8>
  20fcee:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  20fcf1:	48 89 15 10 03 04 00 	mov    QWORD PTR [rip+0x40310],rdx        # 250008 <stderr_stream>
  20fcf8:	48 89 c1             	mov    rcx,rax
  20fcfb:	48 89 d7             	mov    rdi,rdx
  20fcfe:	48 8d 35 13 f1 03 00 	lea    rsi,[rip+0x3f113]        # 24ee18 <__unnamed_3>
  20fd05:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20fd07:	31 c0                	xor    eax,eax
  20fd09:	86 05 01 03 04 00    	xchg   BYTE PTR [rip+0x40301],al        # 250010 <stderr_mutex>
  20fd0f:	3c 01                	cmp    al,0x1
    if (!ok) {
  20fd11:	75 5d                	jne    20fd70 <BmAdd.Acquire.Release+0xd40>
  20fd13:	48 8b 44 24 48       	mov    rax,QWORD PTR [rsp+0x48]
  20fd18:	48 83 c0 01          	add    rax,0x1
  20fd1c:	31 c9                	xor    ecx,ecx
  20fd1e:	4d 89 f4             	mov    r12,r14
        while (rep < pSelf.repetitions) : (rep += 1) {
  20fd21:	48 3b 44 24 70       	cmp    rax,QWORD PTR [rsp+0x70]
  20fd26:	c5 f8 10 0d 92 90 ff 	vmovups xmm1,XMMWORD PTR [rip+0xffffffffffff9092]        # 208dc0 <__unnamed_5>
  20fd2d:	ff 
  20fd2e:	0f 82 1e f4 ff ff    	jb     20f152 <BmAdd.Acquire.Release+0x122>
  20fd34:	48 8d 7c 24 50       	lea    rdi,[rsp+0x50]
        try pSelf.reportStats(pSelf.results);
  20fd39:	48 8d b4 24 98 00 00 	lea    rsi,[rsp+0x98]
  20fd40:	00 
  20fd41:	e8 fa 69 00 00       	call   216740 <Benchmark_reportStats>
  20fd46:	eb 10                	jmp    20fd58 <BmAdd.Acquire.Release+0xd28>
                switch (errno) {
  20fd48:	48 83 f9 16          	cmp    rcx,0x16
  20fd4c:	75 06                	jne    20fd54 <BmAdd.Acquire.Release+0xd24>
  20fd4e:	66 b8 02 00          	mov    ax,0x2
  20fd52:	eb 04                	jmp    20fd58 <BmAdd.Acquire.Release+0xd28>
  20fd54:	66 b8 03 00          	mov    ax,0x3
    _ = try bm.run(BmAdd);
  20fd58:	48 81 c4 f8 00 00 00 	add    rsp,0xf8
  20fd5f:	5b                   	pop    rbx
  20fd60:	41 5c                	pop    r12
  20fd62:	41 5d                	pop    r13
  20fd64:	41 5e                	pop    r14
  20fd66:	41 5f                	pop    r15
  20fd68:	5d                   	pop    rbp
  20fd69:	c3                   	ret    
  20fd6a:	66 b8 06 00          	mov    ax,0x6
  20fd6e:	eb e8                	jmp    20fd58 <BmAdd.Acquire.Release+0xd28>
            @panic("assertion failure");
  20fd70:	48 8d 3d 91 ef 03 00 	lea    rdi,[rip+0x3ef91]        # 24ed08 <__unnamed_2>
  20fd77:	e8 a4 22 00 00       	call   212020 <panic>
  20fd7c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

000000000020fd80 <BmAdd.lfence.sfence>:
}

/// This measures lfence sfence in the loop
test "BmAdd.lfence.sfence" {
  20fd80:	55                   	push   rbp
  20fd81:	41 57                	push   r15
  20fd83:	41 56                	push   r14
  20fd85:	41 55                	push   r13
  20fd87:	41 54                	push   r12
  20fd89:	53                   	push   rbx
  20fd8a:	48 81 ec 08 01 00 00 	sub    rsp,0x108
  20fd91:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20fd98:	0f 1f 84 00 00 00 00 
  20fd9f:	00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20fda0:	b0 01                	mov    al,0x1
  20fda2:	86 05 68 02 04 00    	xchg   BYTE PTR [rip+0x40268],al        # 250010 <stderr_mutex>
  20fda8:	84 c0                	test   al,al
  20fdaa:	75 f4                	jne    20fda0 <BmAdd.lfence.sfence+0x20>
    if (stderr_stream) |st| {
  20fdac:	48 8b 3d 55 02 04 00 	mov    rdi,QWORD PTR [rip+0x40255]        # 250008 <stderr_stream>
  20fdb3:	48 85 ff             	test   rdi,rdi
  20fdb6:	74 09                	je     20fdc1 <BmAdd.lfence.sfence+0x41>
  20fdb8:	48 8b 05 81 b2 03 00 	mov    rax,QWORD PTR [rip+0x3b281]        # 24b040 <stderr_file_out_stream+0x8>
  20fdbf:	eb 34                	jmp    20fdf5 <BmAdd.lfence.sfence+0x75>
        stderr_file = try io.getStdErr();
  20fdc1:	48 8d 05 68 b2 03 00 	lea    rax,[rip+0x3b268]        # 24b030 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20fdc8:	48 89 05 69 b2 03 00 	mov    QWORD PTR [rip+0x3b269],rax        # 24b038 <stderr_file_out_stream>
  20fdcf:	48 8d 05 0a fc 00 00 	lea    rax,[rip+0xfc0a]        # 21f9e0 <FileOutStream_writeFn>
  20fdd6:	48 89 05 63 b2 03 00 	mov    QWORD PTR [rip+0x3b263],rax        # 24b040 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  20fddd:	c7 05 49 b2 03 00 02 	mov    DWORD PTR [rip+0x3b249],0x2        # 24b030 <stderr_file>
  20fde4:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20fde7:	48 8d 3d 52 b2 03 00 	lea    rdi,[rip+0x3b252]        # 24b040 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  20fdee:	48 89 3d 13 02 04 00 	mov    QWORD PTR [rip+0x40213],rdi        # 250008 <stderr_stream>
  20fdf5:	48 8d 35 1c f0 03 00 	lea    rsi,[rip+0x3f01c]        # 24ee18 <__unnamed_3>
  20fdfc:	ff d0                	call   rax
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20fdfe:	31 c0                	xor    eax,eax
  20fe00:	86 05 0a 02 04 00    	xchg   BYTE PTR [rip+0x4020a],al        # 250010 <stderr_mutex>
  20fe06:	3c 01                	cmp    al,0x1
    if (!ok) {
  20fe08:	0f 85 cb 0c 00 00    	jne    210ad9 <BmAdd.lfence.sfence+0xd59>

    // Since this is a test print a \n before we run
    warn("\n");

    // Create an instance of Benchmark, set 10 iterations and run
    var bm = Benchmark.init("BmAdd", std.debug.global_allocator);
  20fe0e:	c5 f8 10 05 d2 ee 03 	vmovups xmm0,XMMWORD PTR [rip+0x3eed2]        # 24ece8 <__unnamed_11>
  20fe15:	00 
  20fe16:	c5 f8 29 44 24 60    	vmovaps XMMWORD PTR [rsp+0x60],xmm0
  20fe1c:	b8 00 65 cd 1d       	mov    eax,0x1dcd6500
  20fe21:	c4 e1 f9 6e c0       	vmovq  xmm0,rax
  20fe26:	c5 f9 73 f8 08       	vpslldq xmm0,xmm0,0x8
  20fe2b:	c5 f9 7f 44 24 70    	vmovdqa XMMWORD PTR [rsp+0x70],xmm0
  20fe31:	48 b8 00 e8 76 48 17 	movabs rax,0x174876e800
  20fe38:	00 00 00 
  20fe3b:	48 89 84 24 88 00 00 	mov    QWORD PTR [rsp+0x88],rax
  20fe42:	00 
  20fe43:	c5 fa 6f 05 75 8f ff 	vmovdqu xmm0,XMMWORD PTR [rip+0xffffffffffff8f75]        # 208dc0 <__unnamed_5>
  20fe4a:	ff 
  20fe4b:	c5 f9 7f 84 24 90 00 	vmovdqa XMMWORD PTR [rsp+0x90],xmm0
  20fe52:	00 00 
  20fe54:	48 8d 05 a5 b1 03 00 	lea    rax,[rip+0x3b1a5]        # 24b000 <global_fixed_allocator>
  20fe5b:	48 89 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rax
  20fe62:	00 
  20fe63:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  20fe67:	c5 fa 7f 84 24 a8 00 	vmovdqu XMMWORD PTR [rsp+0xa8],xmm0
  20fe6e:	00 00 
  20fe70:	48 c7 84 24 b8 00 00 	mov    QWORD PTR [rsp+0xb8],0x0
  20fe77:	00 00 00 00 00 
  20fe7c:	48 89 84 24 c0 00 00 	mov    QWORD PTR [rsp+0xc0],rax
  20fe83:	00 
    bm.repetitions = 10;
  20fe84:	48 c7 84 24 80 00 00 	mov    QWORD PTR [rsp+0x80],0xa
  20fe8b:	00 0a 00 00 00 
  20fe90:	41 b5 01             	mov    r13b,0x1
  20fe93:	bb 01 00 00 00       	mov    ebx,0x1
  20fe98:	45 31 ff             	xor    r15d,r15d
  20fe9b:	c5 f8 10 0d 1d 8f ff 	vmovups xmm1,XMMWORD PTR [rip+0xffffffffffff8f1d]        # 208dc0 <__unnamed_5>
  20fea2:	ff 
  20fea3:	48 8d 74 24 20       	lea    rsi,[rsp+0x20]
  20fea8:	31 ed                	xor    ebp,ebp
                var ts: posix.timespec = undefined;
  20feaa:	c5 f8 29 4c 24 20    	vmovaps XMMWORD PTR [rsp+0x20],xmm1
  20feb0:	b8 e5 00 00 00       	mov    eax,0xe5
  20feb5:	bf 01 00 00 00       	mov    edi,0x1
  20feba:	0f 05                	syscall 
  20febc:	48 89 c1             	mov    rcx,rax
  20febf:	48 f7 d9             	neg    rcx
  20fec2:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  20fec8:	49 0f 46 cf          	cmovbe rcx,r15
                switch (errno) {
  20fecc:	48 85 c9             	test   rcx,rcx
  20fecf:	0f 85 dc 0b 00 00    	jne    210ab1 <BmAdd.lfence.sfence+0xd31>
        const f = @atomicLoad(@typeOf(init_vdso_clock_gettime), &vdso_clock_gettime, builtin.AtomicOrder.Unordered);
  20fed5:	48 8b 05 6c b1 03 00 	mov    rax,QWORD PTR [rip+0x3b16c]        # 24b048 <vdso_clock_gettime>
        if (@ptrToInt(f) != 0) {
  20fedc:	48 85 c0             	test   rax,rax
  20fedf:	74 23                	je     20ff04 <BmAdd.lfence.sfence+0x184>
            const rc = f(clk_id, tp);
  20fee1:	bf 01 00 00 00       	mov    edi,0x1
  20fee6:	48 8d 74 24 20       	lea    rsi,[rsp+0x20]
  20feeb:	ff d0                	call   rax
            switch (rc) {
  20feed:	48 83 f8 ea          	cmp    rax,0xffffffffffffffea
  20fef1:	0f 84 69 04 00 00    	je     210360 <BmAdd.lfence.sfence+0x5e0>
  20fef7:	48 85 c0             	test   rax,rax
  20fefa:	c5 f8 10 0d be 8e ff 	vmovups xmm1,XMMWORD PTR [rip+0xffffffffffff8ebe]        # 208dc0 <__unnamed_5>
  20ff01:	ff 
  20ff02:	74 11                	je     20ff15 <BmAdd.lfence.sfence+0x195>
  20ff04:	b8 e4 00 00 00       	mov    eax,0xe4
  20ff09:	bf 01 00 00 00       	mov    edi,0x1
  20ff0e:	48 8d 74 24 20       	lea    rsi,[rsp+0x20]
  20ff13:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  20ff15:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
                if (errno != 0) return std.os.unexpectedErrorPosix(errno);
  20ff1b:	0f 83 9c 0b 00 00    	jae    210abd <BmAdd.lfence.sfence+0xd3d>
                self.start_time = @intCast(u64, ts.tv_sec) * u64(ns_per_s) + @intCast(u64, ts.tv_nsec);
  20ff21:	4c 8b 7c 24 20       	mov    r15,QWORD PTR [rsp+0x20]
  20ff26:	4c 8b 74 24 28       	mov    r14,QWORD PTR [rsp+0x28]
        var ts: posix.timespec = undefined;
  20ff2b:	c5 f8 29 4c 24 20    	vmovaps XMMWORD PTR [rsp+0x20],xmm1
        const f = @atomicLoad(@typeOf(init_vdso_clock_gettime), &vdso_clock_gettime, builtin.AtomicOrder.Unordered);
  20ff31:	48 8b 05 10 b1 03 00 	mov    rax,QWORD PTR [rip+0x3b110]        # 24b048 <vdso_clock_gettime>
        if (@ptrToInt(f) != 0) {
  20ff38:	48 85 c0             	test   rax,rax
  20ff3b:	74 23                	je     20ff60 <BmAdd.lfence.sfence+0x1e0>
            const rc = f(clk_id, tp);
  20ff3d:	bf 01 00 00 00       	mov    edi,0x1
  20ff42:	48 8d 74 24 20       	lea    rsi,[rsp+0x20]
  20ff47:	ff d0                	call   rax
            switch (rc) {
  20ff49:	48 83 f8 ea          	cmp    rax,0xffffffffffffffea
  20ff4d:	0f 84 26 04 00 00    	je     210379 <BmAdd.lfence.sfence+0x5f9>
  20ff53:	48 85 c0             	test   rax,rax
  20ff56:	c5 f8 10 0d 62 8e ff 	vmovups xmm1,XMMWORD PTR [rip+0xffffffffffff8e62]        # 208dc0 <__unnamed_5>
  20ff5d:	ff 
  20ff5e:	74 11                	je     20ff71 <BmAdd.lfence.sfence+0x1f1>
  20ff60:	b8 e4 00 00 00       	mov    eax,0xe4
  20ff65:	bf 01 00 00 00       	mov    edi,0x1
  20ff6a:	48 8d 74 24 20       	lea    rsi,[rsp+0x20]
  20ff6f:	0f 05                	syscall 
  20ff71:	44 89 6c 24 54       	mov    DWORD PTR [rsp+0x54],r13d
  20ff76:	48 89 6c 24 58       	mov    QWORD PTR [rsp+0x58],rbp
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  20ff7b:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
  20ff81:	0f 83 52 0b 00 00    	jae    210ad9 <BmAdd.lfence.sfence+0xd59>
        return @intCast(u64, ts.tv_sec) * u64(ns_per_s) + @intCast(u64, ts.tv_nsec);
  20ff87:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
  20ff8c:	4c 29 f8             	sub    rax,r15
  20ff8f:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  20ff94:	4c 29 f1             	sub    rcx,r14
  20ff97:	48 69 c0 00 ca 9a 3b 	imul   rax,rax,0x3b9aca00
        var clock = clockNative() - self.start_time;
  20ff9e:	48 01 c8             	add    rax,rcx
        self.s +%= 0x9e3779b97f4a7c15;
  20ffa1:	48 b9 15 7c 4a 7f b9 	movabs rcx,0x9e3779b97f4a7c15
  20ffa8:	79 37 9e 
  20ffab:	48 8d 0c 08          	lea    rcx,[rax+rcx*1]
        z = (z ^ (z >> 30)) *% 0xbf58476d1ce4e5b9;
  20ffaf:	48 89 ca             	mov    rdx,rcx
  20ffb2:	48 c1 ea 1e          	shr    rdx,0x1e
  20ffb6:	48 31 ca             	xor    rdx,rcx
  20ffb9:	48 b9 b9 e5 e4 1c 6d 	movabs rcx,0xbf58476d1ce4e5b9
  20ffc0:	47 58 bf 
  20ffc3:	48 89 ce             	mov    rsi,rcx
  20ffc6:	48 0f af d6          	imul   rdx,rsi
        z = (z ^ (z >> 27)) *% 0x94d049bb133111eb;
  20ffca:	48 89 d1             	mov    rcx,rdx
  20ffcd:	48 c1 e9 1b          	shr    rcx,0x1b
  20ffd1:	48 31 d1             	xor    rcx,rdx
  20ffd4:	48 ba eb 11 31 13 bb 	movabs rdx,0x94d049bb133111eb
  20ffdb:	49 d0 94 
  20ffde:	48 89 d7             	mov    rdi,rdx
  20ffe1:	48 0f af cf          	imul   rcx,rdi
        return z ^ (z >> 31);
  20ffe5:	48 89 ca             	mov    rdx,rcx
  20ffe8:	48 c1 ea 1f          	shr    rdx,0x1f
  20ffec:	48 31 ca             	xor    rdx,rcx
        self.s +%= 0x9e3779b97f4a7c15;
  20ffef:	48 b9 2a f8 94 fe 72 	movabs rcx,0x3c6ef372fe94f82a
  20fff6:	f3 6e 3c 
  20fff9:	48 01 c8             	add    rax,rcx
        z = (z ^ (z >> 30)) *% 0xbf58476d1ce4e5b9;
  20fffc:	48 89 c1             	mov    rcx,rax
  20ffff:	48 c1 e9 1e          	shr    rcx,0x1e
  210003:	48 31 c1             	xor    rcx,rax
  210006:	48 0f af ce          	imul   rcx,rsi
        z = (z ^ (z >> 27)) *% 0x94d049bb133111eb;
  21000a:	48 89 c8             	mov    rax,rcx
  21000d:	48 c1 e8 1b          	shr    rax,0x1b
  210011:	48 31 c8             	xor    rax,rcx
  210014:	48 0f af c7          	imul   rax,rdi
        return z ^ (z >> 31);
  210018:	49 89 c6             	mov    r14,rax
  21001b:	49 c1 ee 1f          	shr    r14,0x1f
  21001f:	49 31 c6             	xor    r14,rax
        s1 ^= s0;
  210022:	4c 89 f0             	mov    rax,r14
  210025:	48 31 d0             	xor    rax,rdx
  210028:	c4 e3 fb f0 ca 09    	rorx   rcx,rdx,0x9
        self.s[0] = math.rotl(u64, s0, u8(55)) ^ s1 ^ (s1 << 14);
  21002e:	48 31 c1             	xor    rcx,rax
  210031:	c4 e3 fb f0 f0 1c    	rorx   rsi,rax,0x1c
  210037:	48 c1 e0 0e          	shl    rax,0xe
  21003b:	48 31 c8             	xor    rax,rcx
            while (iterations <= pSelf.max_iterations) {
  21003e:	4c 8b ac 24 88 00 00 	mov    r13,QWORD PTR [rsp+0x88]
  210045:	00 
        const r = s0 +% s1;
  210046:	49 01 d6             	add    r14,rdx
  210049:	49 01 f6             	add    r14,rsi
  21004c:	49 01 c6             	add    r14,rax
  21004f:	4c 39 eb             	cmp    rbx,r13
  210052:	41 bf 00 00 00 00    	mov    r15d,0x0
  210058:	48 8d 6c 24 20       	lea    rbp,[rsp+0x20]
  21005d:	76 24                	jbe    210083 <BmAdd.lfence.sfence+0x303>
  21005f:	e9 71 03 00 00       	jmp    2103d5 <BmAdd.lfence.sfence+0x655>
  210064:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21006b:	00 00 00 00 00 
                        warn("iteratons:{} numer:{} denom:{}\n", iterations, numer, denom);
  210070:	48 89 df             	mov    rdi,rbx
  210073:	48 89 ca             	mov    rdx,rcx
  210076:	e8 f5 5a 00 00       	call   215b70 <warn.36>
  21007b:	c5 f8 10 0d 3d 8d ff 	vmovups xmm1,XMMWORD PTR [rip+0xffffffffffff8d3d]        # 208dc0 <__unnamed_5>
  210082:	ff 
                var ts: posix.timespec = undefined;
  210083:	c5 f8 29 4c 24 20    	vmovaps XMMWORD PTR [rsp+0x20],xmm1
  210089:	b8 e5 00 00 00       	mov    eax,0xe5
  21008e:	bf 01 00 00 00       	mov    edi,0x1
  210093:	48 89 ee             	mov    rsi,rbp
  210096:	0f 05                	syscall 
  210098:	48 89 c1             	mov    rcx,rax
  21009b:	48 f7 d9             	neg    rcx
  21009e:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  2100a4:	49 0f 46 cf          	cmovbe rcx,r15
                switch (errno) {
  2100a8:	48 85 c9             	test   rcx,rcx
  2100ab:	0f 85 00 0a 00 00    	jne    210ab1 <BmAdd.lfence.sfence+0xd31>
        const f = @atomicLoad(@typeOf(init_vdso_clock_gettime), &vdso_clock_gettime, builtin.AtomicOrder.Unordered);
  2100b1:	48 8b 05 90 af 03 00 	mov    rax,QWORD PTR [rip+0x3af90]        # 24b048 <vdso_clock_gettime>
        if (@ptrToInt(f) != 0) {
  2100b8:	48 85 c0             	test   rax,rax
  2100bb:	74 21                	je     2100de <BmAdd.lfence.sfence+0x35e>
            const rc = f(clk_id, tp);
  2100bd:	bf 01 00 00 00       	mov    edi,0x1
  2100c2:	48 89 ee             	mov    rsi,rbp
  2100c5:	ff d0                	call   rax
            switch (rc) {
  2100c7:	48 83 f8 ea          	cmp    rax,0xffffffffffffffea
  2100cb:	0f 84 4f 02 00 00    	je     210320 <BmAdd.lfence.sfence+0x5a0>
  2100d1:	48 85 c0             	test   rax,rax
  2100d4:	c5 f8 10 0d e4 8c ff 	vmovups xmm1,XMMWORD PTR [rip+0xffffffffffff8ce4]        # 208dc0 <__unnamed_5>
  2100db:	ff 
  2100dc:	74 0f                	je     2100ed <BmAdd.lfence.sfence+0x36d>
  2100de:	b8 e4 00 00 00       	mov    eax,0xe4
  2100e3:	bf 01 00 00 00       	mov    edi,0x1
  2100e8:	48 89 ee             	mov    rsi,rbp
  2100eb:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  2100ed:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
                if (errno != 0) return std.os.unexpectedErrorPosix(errno);
  2100f3:	0f 83 c4 09 00 00    	jae    210abd <BmAdd.lfence.sfence+0xd3d>
                self.start_time = @intCast(u64, ts.tv_sec) * u64(ns_per_s) + @intCast(u64, ts.tv_nsec);
  2100f9:	c5 f9 6f 54 24 20    	vmovdqa xmm2,XMMWORD PTR [rsp+0x20]
        while (iter > 0) : (iter -= 1) {
  2100ff:	48 85 db             	test   rbx,rbx
  210102:	74 1b                	je     21011f <BmAdd.lfence.sfence+0x39f>
  210104:	48 89 d8             	mov    rax,rbx
  210107:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  21010e:	00 00 
    asm volatile ("lfence": : :"memory");
  210110:	0f ae e8             	lfence 
    asm volatile ("sfence": : :"memory");
  210113:	0f ae f8             	sfence 
        while (iter > 0) : (iter -= 1) {
  210116:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  21011a:	75 f4                	jne    210110 <BmAdd.lfence.sfence+0x390>
  21011c:	4d 89 f4             	mov    r12,r14
        var ts: posix.timespec = undefined;
  21011f:	c5 f8 29 4c 24 20    	vmovaps XMMWORD PTR [rsp+0x20],xmm1
        const f = @atomicLoad(@typeOf(init_vdso_clock_gettime), &vdso_clock_gettime, builtin.AtomicOrder.Unordered);
  210125:	48 8b 05 1c af 03 00 	mov    rax,QWORD PTR [rip+0x3af1c]        # 24b048 <vdso_clock_gettime>
        if (@ptrToInt(f) != 0) {
  21012c:	48 85 c0             	test   rax,rax
  21012f:	74 33                	je     210164 <BmAdd.lfence.sfence+0x3e4>
  210131:	c5 f9 7f 94 24 d0 00 	vmovdqa XMMWORD PTR [rsp+0xd0],xmm2
  210138:	00 00 
            const rc = f(clk_id, tp);
  21013a:	bf 01 00 00 00       	mov    edi,0x1
  21013f:	48 89 ee             	mov    rsi,rbp
  210142:	ff d0                	call   rax
            switch (rc) {
  210144:	48 83 f8 ea          	cmp    rax,0xffffffffffffffea
  210148:	0f 84 eb 01 00 00    	je     210339 <BmAdd.lfence.sfence+0x5b9>
  21014e:	48 85 c0             	test   rax,rax
  210151:	c5 f8 10 0d 67 8c ff 	vmovups xmm1,XMMWORD PTR [rip+0xffffffffffff8c67]        # 208dc0 <__unnamed_5>
  210158:	ff 
  210159:	c5 f9 6f 94 24 d0 00 	vmovdqa xmm2,XMMWORD PTR [rsp+0xd0]
  210160:	00 00 
  210162:	74 0f                	je     210173 <BmAdd.lfence.sfence+0x3f3>
  210164:	b8 e4 00 00 00       	mov    eax,0xe4
  210169:	bf 01 00 00 00       	mov    edi,0x1
  21016e:	48 89 ee             	mov    rsi,rbp
  210171:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  210173:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
  210179:	0f 83 5a 09 00 00    	jae    210ad9 <BmAdd.lfence.sfence+0xd59>
        return @intCast(u64, ts.tv_sec) * u64(ns_per_s) + @intCast(u64, ts.tv_nsec);
  21017f:	c5 f9 6f 44 24 20    	vmovdqa xmm0,XMMWORD PTR [rsp+0x20]
  210185:	c5 f9 fb c2          	vpsubq xmm0,xmm0,xmm2
  210189:	c4 e1 f9 7e c0       	vmovq  rax,xmm0
        var clock = clockNative() - self.start_time;
  21018e:	c4 e3 f9 16 c5 01    	vpextrq rbp,xmm0,0x1
  210194:	48 69 c0 00 ca 9a 3b 	imul   rax,rax,0x3b9aca00
  21019b:	48 01 c5             	add    rbp,rax
                if ((run_time_ns >= pSelf.min_runtime_ns) or (iterations >= pSelf.max_iterations)) {
  21019e:	48 3b 6c 24 78       	cmp    rbp,QWORD PTR [rsp+0x78]
  2101a3:	0f 83 f3 01 00 00    	jae    21039c <BmAdd.lfence.sfence+0x61c>
  2101a9:	4c 39 eb             	cmp    rbx,r13
  2101ac:	0f 83 ea 01 00 00    	jae    21039c <BmAdd.lfence.sfence+0x61c>
                    if (pSelf.logl >= 1) {
  2101b2:	48 83 7c 24 70 00    	cmp    QWORD PTR [rsp+0x70],0x0
  2101b8:	0f 84 c0 00 00 00    	je     21027e <BmAdd.lfence.sfence+0x4fe>
                            Result {.run_time_ns = run_time_ns, .iterations = iterations});
  2101be:	48 89 ac 24 e8 00 00 	mov    QWORD PTR [rsp+0xe8],rbp
  2101c5:	00 
  2101c6:	48 89 9c 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rbx
  2101cd:	00 
                        try pSelf.report(
  2101ce:	48 8d 7c 24 60       	lea    rdi,[rsp+0x60]
  2101d3:	48 8d b4 24 e8 00 00 	lea    rsi,[rsp+0xe8]
  2101da:	00 
  2101db:	e8 80 38 00 00       	call   213a60 <Benchmark_report>
  2101e0:	66 85 c0             	test   ax,ax
  2101e3:	0f 85 d8 08 00 00    	jne    210ac1 <BmAdd.lfence.sfence+0xd41>
  2101e9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  2101f0:	b0 01                	mov    al,0x1
  2101f2:	86 05 18 fe 03 00    	xchg   BYTE PTR [rip+0x3fe18],al        # 250010 <stderr_mutex>
  2101f8:	84 c0                	test   al,al
  2101fa:	75 f4                	jne    2101f0 <BmAdd.lfence.sfence+0x470>
    if (stderr_stream) |st| {
  2101fc:	48 8b 3d 05 fe 03 00 	mov    rdi,QWORD PTR [rip+0x3fe05]        # 250008 <stderr_stream>
  210203:	48 85 ff             	test   rdi,rdi
  210206:	74 18                	je     210220 <BmAdd.lfence.sfence+0x4a0>
  210208:	48 8b 0d 31 ae 03 00 	mov    rcx,QWORD PTR [rip+0x3ae31]        # 24b040 <stderr_file_out_stream+0x8>
  21020f:	eb 4c                	jmp    21025d <BmAdd.lfence.sfence+0x4dd>
  210211:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  210218:	0f 1f 84 00 00 00 00 
  21021f:	00 
        stderr_file = try io.getStdErr();
  210220:	c7 05 06 ae 03 00 02 	mov    DWORD PTR [rip+0x3ae06],0x2        # 24b030 <stderr_file>
  210227:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  21022a:	48 8d 05 ff ad 03 00 	lea    rax,[rip+0x3adff]        # 24b030 <stderr_file>
  210231:	48 89 05 00 ae 03 00 	mov    QWORD PTR [rip+0x3ae00],rax        # 24b038 <stderr_file_out_stream>
  210238:	48 8d 05 a1 f7 00 00 	lea    rax,[rip+0xf7a1]        # 21f9e0 <FileOutStream_writeFn>
  21023f:	48 89 05 fa ad 03 00 	mov    QWORD PTR [rip+0x3adfa],rax        # 24b040 <stderr_file_out_stream+0x8>
  210246:	48 8d 0d f3 ad 03 00 	lea    rcx,[rip+0x3adf3]        # 24b040 <stderr_file_out_stream+0x8>
  21024d:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  210250:	48 89 15 b1 fd 03 00 	mov    QWORD PTR [rip+0x3fdb1],rdx        # 250008 <stderr_stream>
  210257:	48 89 c1             	mov    rcx,rax
  21025a:	48 89 d7             	mov    rdi,rdx
  21025d:	48 8d 35 b4 eb 03 00 	lea    rsi,[rip+0x3ebb4]        # 24ee18 <__unnamed_3>
  210264:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  210266:	31 c0                	xor    eax,eax
  210268:	86 05 a2 fd 03 00    	xchg   BYTE PTR [rip+0x3fda2],al        # 250010 <stderr_mutex>
  21026e:	3c 01                	cmp    al,0x1
  210270:	c5 f8 10 0d 48 8b ff 	vmovups xmm1,XMMWORD PTR [rip+0xffffffffffff8b48]        # 208dc0 <__unnamed_5>
  210277:	ff 
    if (!ok) {
  210278:	0f 85 5b 08 00 00    	jne    210ad9 <BmAdd.lfence.sfence+0xd59>
                    if (run_time_ns < 1000) {
  21027e:	48 81 fd e8 03 00 00 	cmp    rbp,0x3e8
  210285:	73 19                	jae    2102a0 <BmAdd.lfence.sfence+0x520>
  210287:	b9 01 00 00 00       	mov    ecx,0x1
  21028c:	be e8 03 00 00       	mov    esi,0x3e8
  210291:	eb 3a                	jmp    2102cd <BmAdd.lfence.sfence+0x54d>
  210293:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21029a:	84 00 00 00 00 00 
                    } else if (run_time_ns < (pSelf.min_runtime_ns / 10)) {
  2102a0:	48 ba cd cc cc cc cc 	movabs rdx,0xcccccccccccccccd
  2102a7:	cc cc cc 
  2102aa:	c4 e2 fb f6 4c 24 78 	mulx   rcx,rax,QWORD PTR [rsp+0x78]
  2102b1:	48 c1 e9 03          	shr    rcx,0x3
  2102b5:	31 c0                	xor    eax,eax
  2102b7:	48 39 cd             	cmp    rbp,rcx
  2102ba:	0f 93 c0             	setae  al
  2102bd:	48 8d 0c c0          	lea    rcx,[rax+rax*8]
  2102c1:	48 83 c1 01          	add    rcx,0x1
  2102c5:	48 8d 34 85 0a 00 00 	lea    rsi,[rax*4+0xa]
  2102cc:	00 
  2102cd:	45 31 ff             	xor    r15d,r15d
  2102d0:	48 8d 6c 24 20       	lea    rbp,[rsp+0x20]
                    iterations = (iterations * numer) / denom;
  2102d5:	48 0f af de          	imul   rbx,rsi
  2102d9:	48 89 d8             	mov    rax,rbx
  2102dc:	48 c1 e8 20          	shr    rax,0x20
  2102e0:	74 0e                	je     2102f0 <BmAdd.lfence.sfence+0x570>
  2102e2:	31 d2                	xor    edx,edx
  2102e4:	48 89 d8             	mov    rax,rbx
  2102e7:	48 f7 f1             	div    rcx
  2102ea:	48 89 c3             	mov    rbx,rax
  2102ed:	eb 09                	jmp    2102f8 <BmAdd.lfence.sfence+0x578>
  2102ef:	90                   	nop
  2102f0:	31 d2                	xor    edx,edx
  2102f2:	89 d8                	mov    eax,ebx
  2102f4:	f7 f1                	div    ecx
  2102f6:	89 c3                	mov    ebx,eax
                    if (iterations > pSelf.max_iterations) {
  2102f8:	4c 8b ac 24 88 00 00 	mov    r13,QWORD PTR [rsp+0x88]
  2102ff:	00 
  210300:	4c 39 eb             	cmp    rbx,r13
  210303:	49 0f 47 dd          	cmova  rbx,r13
                    if (pSelf.logl >= 2) {
  210307:	48 83 7c 24 70 02    	cmp    QWORD PTR [rsp+0x70],0x2
  21030d:	0f 82 70 fd ff ff    	jb     210083 <BmAdd.lfence.sfence+0x303>
  210313:	e9 58 fd ff ff       	jmp    210070 <BmAdd.lfence.sfence+0x2f0>
  210318:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  21031f:	00 
  210320:	c5 f8 10 0d 98 8a ff 	vmovups xmm1,XMMWORD PTR [rip+0xffffffffffff8a98]        # 208dc0 <__unnamed_5>
  210327:	ff 
  210328:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
  21032e:	0f 82 c5 fd ff ff    	jb     2100f9 <BmAdd.lfence.sfence+0x379>
  210334:	e9 84 07 00 00       	jmp    210abd <BmAdd.lfence.sfence+0xd3d>
  210339:	c5 f8 10 0d 7f 8a ff 	vmovups xmm1,XMMWORD PTR [rip+0xffffffffffff8a7f]        # 208dc0 <__unnamed_5>
  210340:	ff 
  210341:	c5 f9 6f 94 24 d0 00 	vmovdqa xmm2,XMMWORD PTR [rsp+0xd0]
  210348:	00 00 
  21034a:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
  210350:	0f 82 29 fe ff ff    	jb     21017f <BmAdd.lfence.sfence+0x3ff>
  210356:	e9 7e 07 00 00       	jmp    210ad9 <BmAdd.lfence.sfence+0xd59>
  21035b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  210360:	c5 f8 10 0d 58 8a ff 	vmovups xmm1,XMMWORD PTR [rip+0xffffffffffff8a58]        # 208dc0 <__unnamed_5>
  210367:	ff 
  210368:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
                if (errno != 0) return std.os.unexpectedErrorPosix(errno);
  21036e:	0f 82 ad fb ff ff    	jb     20ff21 <BmAdd.lfence.sfence+0x1a1>
  210374:	e9 44 07 00 00       	jmp    210abd <BmAdd.lfence.sfence+0xd3d>
  210379:	c5 f8 10 0d 3f 8a ff 	vmovups xmm1,XMMWORD PTR [rip+0xffffffffffff8a3f]        # 208dc0 <__unnamed_5>
  210380:	ff 
  210381:	44 89 6c 24 54       	mov    DWORD PTR [rsp+0x54],r13d
  210386:	48 89 6c 24 58       	mov    QWORD PTR [rsp+0x58],rbp
  21038b:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
  210391:	0f 82 f0 fb ff ff    	jb     20ff87 <BmAdd.lfence.sfence+0x207>
  210397:	e9 3d 07 00 00       	jmp    210ad9 <BmAdd.lfence.sfence+0xd59>
                            Result { .run_time_ns = run_time_ns, .iterations = iterations});
  21039c:	48 89 ac 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],rbp
  2103a3:	00 
  2103a4:	48 89 9c 24 00 01 00 	mov    QWORD PTR [rsp+0x100],rbx
  2103ab:	00 
                    try pSelf.results.append(
  2103ac:	48 8d bc 24 a8 00 00 	lea    rdi,[rsp+0xa8]
  2103b3:	00 
  2103b4:	48 8d b4 24 f8 00 00 	lea    rsi,[rsp+0xf8]
  2103bb:	00 
  2103bc:	e8 2f 35 00 00       	call   2138f0 <AlignedArrayList(Result,8)_append>
  2103c1:	66 85 c0             	test   ax,ax
  2103c4:	41 bf 00 00 00 00    	mov    r15d,0x0
  2103ca:	48 8d 6c 24 20       	lea    rbp,[rsp+0x20]
  2103cf:	0f 85 ec 06 00 00    	jne    210ac1 <BmAdd.lfence.sfence+0xd41>
            if (pSelf.r != (u64(pSelf.a) + u64(pSelf.b))) return error.Failed;
  2103d5:	4d 39 e6             	cmp    r14,r12
  2103d8:	4c 8d 6c 24 10       	lea    r13,[rsp+0x10]
                    try bm.tearDown();
  2103dd:	0f 85 f0 06 00 00    	jne    210ad3 <BmAdd.lfence.sfence+0xd53>
            if (once) {
  2103e3:	f6 44 24 54 01       	test   BYTE PTR [rsp+0x54],0x1
  2103e8:	4c 8d 64 24 0f       	lea    r12,[rsp+0xf]
  2103ed:	0f 84 d4 05 00 00    	je     2109c7 <BmAdd.lfence.sfence+0xc47>
                try leftJustified(22, "name repetitions:{}", pSelf.repetitions);
  2103f3:	48 8b bc 24 80 00 00 	mov    rdi,QWORD PTR [rsp+0x80]
  2103fa:	00 
  2103fb:	e8 e0 5a 00 00       	call   215ee0 <Benchmark_leftJustified>
  210400:	66 85 c0             	test   ax,ax
  210403:	0f 85 b8 06 00 00    	jne    210ac1 <BmAdd.lfence.sfence+0xd41>
                try rightJustified(14, "{}", "iterations");
  210409:	e8 72 5d 00 00       	call   216180 <Benchmark_rightJustified>
  21040e:	66 85 c0             	test   ax,ax
  210411:	0f 85 aa 06 00 00    	jne    210ac1 <BmAdd.lfence.sfence+0xd41>
        var buffer: [40]u8 = undefined;
  210417:	c5 fe 6f 05 7c 51 ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffff517c]        # 20559b <__unnamed_7>
  21041e:	ff 
  21041f:	c5 fe 7f 44 24 20    	vmovdqu YMMWORD PTR [rsp+0x20],ymm0
  210425:	48 8b 05 8f 51 ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffff518f]        # 2055bb <__unnamed_7+0x20>
  21042c:	48 89 44 24 40       	mov    QWORD PTR [rsp+0x40],rax
  210431:	c7 44 24 20 74 69 6d 	mov    DWORD PTR [rsp+0x20],0x656d6974
  210438:	65 
  210439:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  210440:	b0 01                	mov    al,0x1
  210442:	86 05 c8 fb 03 00    	xchg   BYTE PTR [rip+0x3fbc8],al        # 250010 <stderr_mutex>
  210448:	84 c0                	test   al,al
  21044a:	75 f4                	jne    210440 <BmAdd.lfence.sfence+0x6c0>
    if (stderr_stream) |st| {
  21044c:	48 8b 3d b5 fb 03 00 	mov    rdi,QWORD PTR [rip+0x3fbb5]        # 250008 <stderr_stream>
  210453:	48 85 ff             	test   rdi,rdi
  210456:	74 09                	je     210461 <BmAdd.lfence.sfence+0x6e1>
  210458:	48 8b 0d e1 ab 03 00 	mov    rcx,QWORD PTR [rip+0x3abe1]        # 24b040 <stderr_file_out_stream+0x8>
  21045f:	eb 3d                	jmp    21049e <BmAdd.lfence.sfence+0x71e>
        stderr_file = try io.getStdErr();
  210461:	c7 05 c5 ab 03 00 02 	mov    DWORD PTR [rip+0x3abc5],0x2        # 24b030 <stderr_file>
  210468:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  21046b:	48 8d 05 be ab 03 00 	lea    rax,[rip+0x3abbe]        # 24b030 <stderr_file>
  210472:	48 89 05 bf ab 03 00 	mov    QWORD PTR [rip+0x3abbf],rax        # 24b038 <stderr_file_out_stream>
  210479:	48 8d 05 60 f5 00 00 	lea    rax,[rip+0xf560]        # 21f9e0 <FileOutStream_writeFn>
  210480:	48 89 05 b9 ab 03 00 	mov    QWORD PTR [rip+0x3abb9],rax        # 24b040 <stderr_file_out_stream+0x8>
  210487:	48 8d 0d b2 ab 03 00 	lea    rcx,[rip+0x3abb2]        # 24b040 <stderr_file_out_stream+0x8>
  21048e:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  210491:	48 89 15 70 fb 03 00 	mov    QWORD PTR [rip+0x3fb70],rdx        # 250008 <stderr_stream>
  210498:	48 89 c1             	mov    rcx,rax
  21049b:	48 89 d7             	mov    rdi,rdx
  21049e:	c6 44 24 0f 20       	mov    BYTE PTR [rsp+0xf],0x20
    return output(context, (*[1]u8)(&c)[0..]);
  2104a3:	4c 89 64 24 10       	mov    QWORD PTR [rsp+0x10],r12
  2104a8:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  2104af:	00 00 
  2104b1:	4c 89 ee             	mov    rsi,r13
  2104b4:	c5 f8 77             	vzeroupper 
  2104b7:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  2104b9:	31 c0                	xor    eax,eax
  2104bb:	86 05 4f fb 03 00    	xchg   BYTE PTR [rip+0x3fb4f],al        # 250010 <stderr_mutex>
  2104c1:	3c 01                	cmp    al,0x1
    if (!ok) {
  2104c3:	0f 85 10 06 00 00    	jne    210ad9 <BmAdd.lfence.sfence+0xd59>
  2104c9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  2104d0:	b0 01                	mov    al,0x1
  2104d2:	86 05 38 fb 03 00    	xchg   BYTE PTR [rip+0x3fb38],al        # 250010 <stderr_mutex>
  2104d8:	84 c0                	test   al,al
  2104da:	75 f4                	jne    2104d0 <BmAdd.lfence.sfence+0x750>
    if (stderr_stream) |st| {
  2104dc:	48 8b 3d 25 fb 03 00 	mov    rdi,QWORD PTR [rip+0x3fb25]        # 250008 <stderr_stream>
  2104e3:	48 85 ff             	test   rdi,rdi
  2104e6:	74 09                	je     2104f1 <BmAdd.lfence.sfence+0x771>
  2104e8:	48 8b 0d 51 ab 03 00 	mov    rcx,QWORD PTR [rip+0x3ab51]        # 24b040 <stderr_file_out_stream+0x8>
  2104ef:	eb 3d                	jmp    21052e <BmAdd.lfence.sfence+0x7ae>
        stderr_file = try io.getStdErr();
  2104f1:	c7 05 35 ab 03 00 02 	mov    DWORD PTR [rip+0x3ab35],0x2        # 24b030 <stderr_file>
  2104f8:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  2104fb:	48 8d 05 2e ab 03 00 	lea    rax,[rip+0x3ab2e]        # 24b030 <stderr_file>
  210502:	48 89 05 2f ab 03 00 	mov    QWORD PTR [rip+0x3ab2f],rax        # 24b038 <stderr_file_out_stream>
  210509:	48 8d 05 d0 f4 00 00 	lea    rax,[rip+0xf4d0]        # 21f9e0 <FileOutStream_writeFn>
  210510:	48 89 05 29 ab 03 00 	mov    QWORD PTR [rip+0x3ab29],rax        # 24b040 <stderr_file_out_stream+0x8>
  210517:	48 8d 0d 22 ab 03 00 	lea    rcx,[rip+0x3ab22]        # 24b040 <stderr_file_out_stream+0x8>
  21051e:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  210521:	48 89 15 e0 fa 03 00 	mov    QWORD PTR [rip+0x3fae0],rdx        # 250008 <stderr_stream>
  210528:	48 89 c1             	mov    rcx,rax
  21052b:	48 89 d7             	mov    rdi,rdx
  21052e:	c6 44 24 0f 20       	mov    BYTE PTR [rsp+0xf],0x20
  210533:	4c 89 64 24 10       	mov    QWORD PTR [rsp+0x10],r12
  210538:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  21053f:	00 00 
  210541:	4c 89 ee             	mov    rsi,r13
  210544:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  210546:	31 c0                	xor    eax,eax
  210548:	86 05 c2 fa 03 00    	xchg   BYTE PTR [rip+0x3fac2],al        # 250010 <stderr_mutex>
  21054e:	3c 01                	cmp    al,0x1
    if (!ok) {
  210550:	0f 85 83 05 00 00    	jne    210ad9 <BmAdd.lfence.sfence+0xd59>
  210556:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  21055d:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  210560:	b0 01                	mov    al,0x1
  210562:	86 05 a8 fa 03 00    	xchg   BYTE PTR [rip+0x3faa8],al        # 250010 <stderr_mutex>
  210568:	84 c0                	test   al,al
  21056a:	75 f4                	jne    210560 <BmAdd.lfence.sfence+0x7e0>
    if (stderr_stream) |st| {
  21056c:	48 8b 3d 95 fa 03 00 	mov    rdi,QWORD PTR [rip+0x3fa95]        # 250008 <stderr_stream>
  210573:	48 85 ff             	test   rdi,rdi
  210576:	74 09                	je     210581 <BmAdd.lfence.sfence+0x801>
  210578:	48 8b 0d c1 aa 03 00 	mov    rcx,QWORD PTR [rip+0x3aac1]        # 24b040 <stderr_file_out_stream+0x8>
  21057f:	eb 3d                	jmp    2105be <BmAdd.lfence.sfence+0x83e>
        stderr_file = try io.getStdErr();
  210581:	c7 05 a5 aa 03 00 02 	mov    DWORD PTR [rip+0x3aaa5],0x2        # 24b030 <stderr_file>
  210588:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  21058b:	48 8d 05 9e aa 03 00 	lea    rax,[rip+0x3aa9e]        # 24b030 <stderr_file>
  210592:	48 89 05 9f aa 03 00 	mov    QWORD PTR [rip+0x3aa9f],rax        # 24b038 <stderr_file_out_stream>
  210599:	48 8d 05 40 f4 00 00 	lea    rax,[rip+0xf440]        # 21f9e0 <FileOutStream_writeFn>
  2105a0:	48 89 05 99 aa 03 00 	mov    QWORD PTR [rip+0x3aa99],rax        # 24b040 <stderr_file_out_stream+0x8>
  2105a7:	48 8d 0d 92 aa 03 00 	lea    rcx,[rip+0x3aa92]        # 24b040 <stderr_file_out_stream+0x8>
  2105ae:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  2105b1:	48 89 15 50 fa 03 00 	mov    QWORD PTR [rip+0x3fa50],rdx        # 250008 <stderr_stream>
  2105b8:	48 89 c1             	mov    rcx,rax
  2105bb:	48 89 d7             	mov    rdi,rdx
  2105be:	c6 44 24 0f 20       	mov    BYTE PTR [rsp+0xf],0x20
  2105c3:	4c 89 64 24 10       	mov    QWORD PTR [rsp+0x10],r12
  2105c8:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  2105cf:	00 00 
  2105d1:	4c 89 ee             	mov    rsi,r13
  2105d4:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  2105d6:	31 c0                	xor    eax,eax
  2105d8:	86 05 32 fa 03 00    	xchg   BYTE PTR [rip+0x3fa32],al        # 250010 <stderr_mutex>
  2105de:	3c 01                	cmp    al,0x1
    if (!ok) {
  2105e0:	0f 85 f3 04 00 00    	jne    210ad9 <BmAdd.lfence.sfence+0xd59>
  2105e6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  2105ed:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  2105f0:	b0 01                	mov    al,0x1
  2105f2:	86 05 18 fa 03 00    	xchg   BYTE PTR [rip+0x3fa18],al        # 250010 <stderr_mutex>
  2105f8:	84 c0                	test   al,al
  2105fa:	75 f4                	jne    2105f0 <BmAdd.lfence.sfence+0x870>
    if (stderr_stream) |st| {
  2105fc:	48 8b 3d 05 fa 03 00 	mov    rdi,QWORD PTR [rip+0x3fa05]        # 250008 <stderr_stream>
  210603:	48 85 ff             	test   rdi,rdi
  210606:	74 09                	je     210611 <BmAdd.lfence.sfence+0x891>
  210608:	48 8b 0d 31 aa 03 00 	mov    rcx,QWORD PTR [rip+0x3aa31]        # 24b040 <stderr_file_out_stream+0x8>
  21060f:	eb 3d                	jmp    21064e <BmAdd.lfence.sfence+0x8ce>
        stderr_file = try io.getStdErr();
  210611:	c7 05 15 aa 03 00 02 	mov    DWORD PTR [rip+0x3aa15],0x2        # 24b030 <stderr_file>
  210618:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  21061b:	48 8d 05 0e aa 03 00 	lea    rax,[rip+0x3aa0e]        # 24b030 <stderr_file>
  210622:	48 89 05 0f aa 03 00 	mov    QWORD PTR [rip+0x3aa0f],rax        # 24b038 <stderr_file_out_stream>
  210629:	48 8d 05 b0 f3 00 00 	lea    rax,[rip+0xf3b0]        # 21f9e0 <FileOutStream_writeFn>
  210630:	48 89 05 09 aa 03 00 	mov    QWORD PTR [rip+0x3aa09],rax        # 24b040 <stderr_file_out_stream+0x8>
  210637:	48 8d 0d 02 aa 03 00 	lea    rcx,[rip+0x3aa02]        # 24b040 <stderr_file_out_stream+0x8>
  21063e:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  210641:	48 89 15 c0 f9 03 00 	mov    QWORD PTR [rip+0x3f9c0],rdx        # 250008 <stderr_stream>
  210648:	48 89 c1             	mov    rcx,rax
  21064b:	48 89 d7             	mov    rdi,rdx
  21064e:	c6 44 24 0f 20       	mov    BYTE PTR [rsp+0xf],0x20
  210653:	4c 89 64 24 10       	mov    QWORD PTR [rsp+0x10],r12
  210658:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  21065f:	00 00 
  210661:	4c 89 ee             	mov    rsi,r13
  210664:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  210666:	31 c0                	xor    eax,eax
  210668:	86 05 a2 f9 03 00    	xchg   BYTE PTR [rip+0x3f9a2],al        # 250010 <stderr_mutex>
  21066e:	3c 01                	cmp    al,0x1
    if (!ok) {
  210670:	0f 85 63 04 00 00    	jne    210ad9 <BmAdd.lfence.sfence+0xd59>
  210676:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  21067d:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  210680:	b0 01                	mov    al,0x1
  210682:	86 05 88 f9 03 00    	xchg   BYTE PTR [rip+0x3f988],al        # 250010 <stderr_mutex>
  210688:	84 c0                	test   al,al
  21068a:	75 f4                	jne    210680 <BmAdd.lfence.sfence+0x900>
    if (stderr_stream) |st| {
  21068c:	48 8b 3d 75 f9 03 00 	mov    rdi,QWORD PTR [rip+0x3f975]        # 250008 <stderr_stream>
  210693:	48 85 ff             	test   rdi,rdi
  210696:	74 09                	je     2106a1 <BmAdd.lfence.sfence+0x921>
  210698:	48 8b 0d a1 a9 03 00 	mov    rcx,QWORD PTR [rip+0x3a9a1]        # 24b040 <stderr_file_out_stream+0x8>
  21069f:	eb 3d                	jmp    2106de <BmAdd.lfence.sfence+0x95e>
        stderr_file = try io.getStdErr();
  2106a1:	c7 05 85 a9 03 00 02 	mov    DWORD PTR [rip+0x3a985],0x2        # 24b030 <stderr_file>
  2106a8:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  2106ab:	48 8d 05 7e a9 03 00 	lea    rax,[rip+0x3a97e]        # 24b030 <stderr_file>
  2106b2:	48 89 05 7f a9 03 00 	mov    QWORD PTR [rip+0x3a97f],rax        # 24b038 <stderr_file_out_stream>
  2106b9:	48 8d 05 20 f3 00 00 	lea    rax,[rip+0xf320]        # 21f9e0 <FileOutStream_writeFn>
  2106c0:	48 89 05 79 a9 03 00 	mov    QWORD PTR [rip+0x3a979],rax        # 24b040 <stderr_file_out_stream+0x8>
  2106c7:	48 8d 0d 72 a9 03 00 	lea    rcx,[rip+0x3a972]        # 24b040 <stderr_file_out_stream+0x8>
  2106ce:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  2106d1:	48 89 15 30 f9 03 00 	mov    QWORD PTR [rip+0x3f930],rdx        # 250008 <stderr_stream>
  2106d8:	48 89 c1             	mov    rcx,rax
  2106db:	48 89 d7             	mov    rdi,rdx
  2106de:	c6 44 24 0f 20       	mov    BYTE PTR [rsp+0xf],0x20
  2106e3:	4c 89 64 24 10       	mov    QWORD PTR [rsp+0x10],r12
  2106e8:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  2106ef:	00 00 
  2106f1:	4c 89 ee             	mov    rsi,r13
  2106f4:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  2106f6:	31 c0                	xor    eax,eax
  2106f8:	86 05 12 f9 03 00    	xchg   BYTE PTR [rip+0x3f912],al        # 250010 <stderr_mutex>
  2106fe:	3c 01                	cmp    al,0x1
    if (!ok) {
  210700:	0f 85 d3 03 00 00    	jne    210ad9 <BmAdd.lfence.sfence+0xd59>
  210706:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  21070d:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  210710:	b0 01                	mov    al,0x1
  210712:	86 05 f8 f8 03 00    	xchg   BYTE PTR [rip+0x3f8f8],al        # 250010 <stderr_mutex>
  210718:	84 c0                	test   al,al
  21071a:	75 f4                	jne    210710 <BmAdd.lfence.sfence+0x990>
    if (stderr_stream) |st| {
  21071c:	48 8b 3d e5 f8 03 00 	mov    rdi,QWORD PTR [rip+0x3f8e5]        # 250008 <stderr_stream>
  210723:	48 85 ff             	test   rdi,rdi
  210726:	74 09                	je     210731 <BmAdd.lfence.sfence+0x9b1>
  210728:	48 8b 0d 11 a9 03 00 	mov    rcx,QWORD PTR [rip+0x3a911]        # 24b040 <stderr_file_out_stream+0x8>
  21072f:	eb 3d                	jmp    21076e <BmAdd.lfence.sfence+0x9ee>
        stderr_file = try io.getStdErr();
  210731:	c7 05 f5 a8 03 00 02 	mov    DWORD PTR [rip+0x3a8f5],0x2        # 24b030 <stderr_file>
  210738:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  21073b:	48 8d 05 ee a8 03 00 	lea    rax,[rip+0x3a8ee]        # 24b030 <stderr_file>
  210742:	48 89 05 ef a8 03 00 	mov    QWORD PTR [rip+0x3a8ef],rax        # 24b038 <stderr_file_out_stream>
  210749:	48 8d 05 90 f2 00 00 	lea    rax,[rip+0xf290]        # 21f9e0 <FileOutStream_writeFn>
  210750:	48 89 05 e9 a8 03 00 	mov    QWORD PTR [rip+0x3a8e9],rax        # 24b040 <stderr_file_out_stream+0x8>
  210757:	48 8d 0d e2 a8 03 00 	lea    rcx,[rip+0x3a8e2]        # 24b040 <stderr_file_out_stream+0x8>
  21075e:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  210761:	48 89 15 a0 f8 03 00 	mov    QWORD PTR [rip+0x3f8a0],rdx        # 250008 <stderr_stream>
  210768:	48 89 c1             	mov    rcx,rax
  21076b:	48 89 d7             	mov    rdi,rdx
  21076e:	c6 44 24 0f 20       	mov    BYTE PTR [rsp+0xf],0x20
  210773:	4c 89 64 24 10       	mov    QWORD PTR [rsp+0x10],r12
  210778:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  21077f:	00 00 
  210781:	4c 89 ee             	mov    rsi,r13
  210784:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  210786:	31 c0                	xor    eax,eax
  210788:	86 05 82 f8 03 00    	xchg   BYTE PTR [rip+0x3f882],al        # 250010 <stderr_mutex>
  21078e:	3c 01                	cmp    al,0x1
    if (!ok) {
  210790:	0f 85 43 03 00 00    	jne    210ad9 <BmAdd.lfence.sfence+0xd59>
  210796:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  21079d:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  2107a0:	b0 01                	mov    al,0x1
  2107a2:	86 05 68 f8 03 00    	xchg   BYTE PTR [rip+0x3f868],al        # 250010 <stderr_mutex>
  2107a8:	84 c0                	test   al,al
  2107aa:	75 f4                	jne    2107a0 <BmAdd.lfence.sfence+0xa20>
    if (stderr_stream) |st| {
  2107ac:	48 8b 3d 55 f8 03 00 	mov    rdi,QWORD PTR [rip+0x3f855]        # 250008 <stderr_stream>
  2107b3:	48 85 ff             	test   rdi,rdi
  2107b6:	74 09                	je     2107c1 <BmAdd.lfence.sfence+0xa41>
  2107b8:	48 8b 0d 81 a8 03 00 	mov    rcx,QWORD PTR [rip+0x3a881]        # 24b040 <stderr_file_out_stream+0x8>
  2107bf:	eb 3d                	jmp    2107fe <BmAdd.lfence.sfence+0xa7e>
        stderr_file = try io.getStdErr();
  2107c1:	c7 05 65 a8 03 00 02 	mov    DWORD PTR [rip+0x3a865],0x2        # 24b030 <stderr_file>
  2107c8:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  2107cb:	48 8d 05 5e a8 03 00 	lea    rax,[rip+0x3a85e]        # 24b030 <stderr_file>
  2107d2:	48 89 05 5f a8 03 00 	mov    QWORD PTR [rip+0x3a85f],rax        # 24b038 <stderr_file_out_stream>
  2107d9:	48 8d 05 00 f2 00 00 	lea    rax,[rip+0xf200]        # 21f9e0 <FileOutStream_writeFn>
  2107e0:	48 89 05 59 a8 03 00 	mov    QWORD PTR [rip+0x3a859],rax        # 24b040 <stderr_file_out_stream+0x8>
  2107e7:	48 8d 0d 52 a8 03 00 	lea    rcx,[rip+0x3a852]        # 24b040 <stderr_file_out_stream+0x8>
  2107ee:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  2107f1:	48 89 15 10 f8 03 00 	mov    QWORD PTR [rip+0x3f810],rdx        # 250008 <stderr_stream>
  2107f8:	48 89 c1             	mov    rcx,rax
  2107fb:	48 89 d7             	mov    rdi,rdx
  2107fe:	c6 44 24 0f 20       	mov    BYTE PTR [rsp+0xf],0x20
  210803:	4c 89 64 24 10       	mov    QWORD PTR [rsp+0x10],r12
  210808:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  21080f:	00 00 
  210811:	4c 89 ee             	mov    rsi,r13
  210814:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  210816:	31 c0                	xor    eax,eax
  210818:	86 05 f2 f7 03 00    	xchg   BYTE PTR [rip+0x3f7f2],al        # 250010 <stderr_mutex>
  21081e:	3c 01                	cmp    al,0x1
    if (!ok) {
  210820:	0f 85 b3 02 00 00    	jne    210ad9 <BmAdd.lfence.sfence+0xd59>
  210826:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  21082d:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  210830:	b0 01                	mov    al,0x1
  210832:	86 05 d8 f7 03 00    	xchg   BYTE PTR [rip+0x3f7d8],al        # 250010 <stderr_mutex>
  210838:	84 c0                	test   al,al
  21083a:	75 f4                	jne    210830 <BmAdd.lfence.sfence+0xab0>
    if (stderr_stream) |st| {
  21083c:	48 8b 3d c5 f7 03 00 	mov    rdi,QWORD PTR [rip+0x3f7c5]        # 250008 <stderr_stream>
  210843:	48 85 ff             	test   rdi,rdi
  210846:	74 09                	je     210851 <BmAdd.lfence.sfence+0xad1>
  210848:	48 8b 0d f1 a7 03 00 	mov    rcx,QWORD PTR [rip+0x3a7f1]        # 24b040 <stderr_file_out_stream+0x8>
  21084f:	eb 3d                	jmp    21088e <BmAdd.lfence.sfence+0xb0e>
        stderr_file = try io.getStdErr();
  210851:	c7 05 d5 a7 03 00 02 	mov    DWORD PTR [rip+0x3a7d5],0x2        # 24b030 <stderr_file>
  210858:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  21085b:	48 8d 05 ce a7 03 00 	lea    rax,[rip+0x3a7ce]        # 24b030 <stderr_file>
  210862:	48 89 05 cf a7 03 00 	mov    QWORD PTR [rip+0x3a7cf],rax        # 24b038 <stderr_file_out_stream>
  210869:	48 8d 05 70 f1 00 00 	lea    rax,[rip+0xf170]        # 21f9e0 <FileOutStream_writeFn>
  210870:	48 89 05 c9 a7 03 00 	mov    QWORD PTR [rip+0x3a7c9],rax        # 24b040 <stderr_file_out_stream+0x8>
  210877:	48 8d 0d c2 a7 03 00 	lea    rcx,[rip+0x3a7c2]        # 24b040 <stderr_file_out_stream+0x8>
  21087e:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  210881:	48 89 15 80 f7 03 00 	mov    QWORD PTR [rip+0x3f780],rdx        # 250008 <stderr_stream>
  210888:	48 89 c1             	mov    rcx,rax
  21088b:	48 89 d7             	mov    rdi,rdx
  21088e:	c6 44 24 0f 20       	mov    BYTE PTR [rsp+0xf],0x20
  210893:	4c 89 64 24 10       	mov    QWORD PTR [rsp+0x10],r12
  210898:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  21089f:	00 00 
  2108a1:	4c 89 ee             	mov    rsi,r13
  2108a4:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  2108a6:	31 c0                	xor    eax,eax
  2108a8:	86 05 62 f7 03 00    	xchg   BYTE PTR [rip+0x3f762],al        # 250010 <stderr_mutex>
  2108ae:	3c 01                	cmp    al,0x1
    if (!ok) {
  2108b0:	0f 85 23 02 00 00    	jne    210ad9 <BmAdd.lfence.sfence+0xd59>
  2108b6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  2108bd:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  2108c0:	b0 01                	mov    al,0x1
  2108c2:	86 05 48 f7 03 00    	xchg   BYTE PTR [rip+0x3f748],al        # 250010 <stderr_mutex>
  2108c8:	84 c0                	test   al,al
  2108ca:	75 f4                	jne    2108c0 <BmAdd.lfence.sfence+0xb40>
    if (stderr_stream) |st| {
  2108cc:	48 8b 3d 35 f7 03 00 	mov    rdi,QWORD PTR [rip+0x3f735]        # 250008 <stderr_stream>
  2108d3:	48 85 ff             	test   rdi,rdi
  2108d6:	74 09                	je     2108e1 <BmAdd.lfence.sfence+0xb61>
  2108d8:	48 8b 0d 61 a7 03 00 	mov    rcx,QWORD PTR [rip+0x3a761]        # 24b040 <stderr_file_out_stream+0x8>
  2108df:	eb 3d                	jmp    21091e <BmAdd.lfence.sfence+0xb9e>
        stderr_file = try io.getStdErr();
  2108e1:	c7 05 45 a7 03 00 02 	mov    DWORD PTR [rip+0x3a745],0x2        # 24b030 <stderr_file>
  2108e8:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  2108eb:	48 8d 05 3e a7 03 00 	lea    rax,[rip+0x3a73e]        # 24b030 <stderr_file>
  2108f2:	48 89 05 3f a7 03 00 	mov    QWORD PTR [rip+0x3a73f],rax        # 24b038 <stderr_file_out_stream>
  2108f9:	48 8d 05 e0 f0 00 00 	lea    rax,[rip+0xf0e0]        # 21f9e0 <FileOutStream_writeFn>
  210900:	48 89 05 39 a7 03 00 	mov    QWORD PTR [rip+0x3a739],rax        # 24b040 <stderr_file_out_stream+0x8>
  210907:	48 8d 0d 32 a7 03 00 	lea    rcx,[rip+0x3a732]        # 24b040 <stderr_file_out_stream+0x8>
  21090e:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  210911:	48 89 15 f0 f6 03 00 	mov    QWORD PTR [rip+0x3f6f0],rdx        # 250008 <stderr_stream>
  210918:	48 89 c1             	mov    rcx,rax
  21091b:	48 89 d7             	mov    rdi,rdx
                const casted_value = ([]const u8)(value);
  21091e:	48 89 6c 24 10       	mov    QWORD PTR [rsp+0x10],rbp
  210923:	48 c7 44 24 18 04 00 	mov    QWORD PTR [rsp+0x18],0x4
  21092a:	00 00 
                return output(context, casted_value);
  21092c:	4c 89 ee             	mov    rsi,r13
  21092f:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  210931:	31 c0                	xor    eax,eax
  210933:	86 05 d7 f6 03 00    	xchg   BYTE PTR [rip+0x3f6d7],al        # 250010 <stderr_mutex>
  210939:	3c 01                	cmp    al,0x1
    if (!ok) {
  21093b:	0f 85 98 01 00 00    	jne    210ad9 <BmAdd.lfence.sfence+0xd59>
                try rightJustified(18, "{}", "time/operation");
  210941:	e8 1a 5b 00 00       	call   216460 <Benchmark_rightJustified.38>
  210946:	66 85 c0             	test   ax,ax
  210949:	0f 85 72 01 00 00    	jne    210ac1 <BmAdd.lfence.sfence+0xd41>
  21094f:	90                   	nop
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  210950:	b0 01                	mov    al,0x1
  210952:	86 05 b8 f6 03 00    	xchg   BYTE PTR [rip+0x3f6b8],al        # 250010 <stderr_mutex>
  210958:	84 c0                	test   al,al
  21095a:	75 f4                	jne    210950 <BmAdd.lfence.sfence+0xbd0>
    if (stderr_stream) |st| {
  21095c:	48 8b 3d a5 f6 03 00 	mov    rdi,QWORD PTR [rip+0x3f6a5]        # 250008 <stderr_stream>
  210963:	48 85 ff             	test   rdi,rdi
  210966:	74 09                	je     210971 <BmAdd.lfence.sfence+0xbf1>
  210968:	48 8b 0d d1 a6 03 00 	mov    rcx,QWORD PTR [rip+0x3a6d1]        # 24b040 <stderr_file_out_stream+0x8>
  21096f:	eb 3d                	jmp    2109ae <BmAdd.lfence.sfence+0xc2e>
        stderr_file = try io.getStdErr();
  210971:	c7 05 b5 a6 03 00 02 	mov    DWORD PTR [rip+0x3a6b5],0x2        # 24b030 <stderr_file>
  210978:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  21097b:	48 8d 05 ae a6 03 00 	lea    rax,[rip+0x3a6ae]        # 24b030 <stderr_file>
  210982:	48 89 05 af a6 03 00 	mov    QWORD PTR [rip+0x3a6af],rax        # 24b038 <stderr_file_out_stream>
  210989:	48 8d 05 50 f0 00 00 	lea    rax,[rip+0xf050]        # 21f9e0 <FileOutStream_writeFn>
  210990:	48 89 05 a9 a6 03 00 	mov    QWORD PTR [rip+0x3a6a9],rax        # 24b040 <stderr_file_out_stream+0x8>
  210997:	48 8d 0d a2 a6 03 00 	lea    rcx,[rip+0x3a6a2]        # 24b040 <stderr_file_out_stream+0x8>
  21099e:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  2109a1:	48 89 15 60 f6 03 00 	mov    QWORD PTR [rip+0x3f660],rdx        # 250008 <stderr_stream>
  2109a8:	48 89 c1             	mov    rcx,rax
  2109ab:	48 89 d7             	mov    rdi,rdx
        try output(context, fmt[start_index..]);
  2109ae:	48 8d 35 63 e4 03 00 	lea    rsi,[rip+0x3e463]        # 24ee18 <__unnamed_3>
  2109b5:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  2109b7:	31 c0                	xor    eax,eax
  2109b9:	86 05 51 f6 03 00    	xchg   BYTE PTR [rip+0x3f651],al        # 250010 <stderr_mutex>
  2109bf:	3c 01                	cmp    al,0x1
    if (!ok) {
  2109c1:	0f 85 12 01 00 00    	jne    210ad9 <BmAdd.lfence.sfence+0xd59>
            try pSelf.report(pSelf.results.items[pSelf.results.len - 1]); warn("\n");
  2109c7:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  2109ce:	00 
  2109cf:	48 8b 8c 24 b8 00 00 	mov    rcx,QWORD PTR [rsp+0xb8]
  2109d6:	00 
  2109d7:	48 c1 e1 04          	shl    rcx,0x4
  2109db:	48 8d 34 08          	lea    rsi,[rax+rcx*1]
  2109df:	48 83 c6 f0          	add    rsi,0xfffffffffffffff0
  2109e3:	48 8d 7c 24 60       	lea    rdi,[rsp+0x60]
  2109e8:	e8 73 30 00 00       	call   213a60 <Benchmark_report>
  2109ed:	66 85 c0             	test   ax,ax
  2109f0:	0f 85 cb 00 00 00    	jne    210ac1 <BmAdd.lfence.sfence+0xd41>
  2109f6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  2109fd:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  210a00:	b0 01                	mov    al,0x1
  210a02:	86 05 08 f6 03 00    	xchg   BYTE PTR [rip+0x3f608],al        # 250010 <stderr_mutex>
  210a08:	84 c0                	test   al,al
  210a0a:	75 f4                	jne    210a00 <BmAdd.lfence.sfence+0xc80>
    if (stderr_stream) |st| {
  210a0c:	48 8b 3d f5 f5 03 00 	mov    rdi,QWORD PTR [rip+0x3f5f5]        # 250008 <stderr_stream>
  210a13:	48 85 ff             	test   rdi,rdi
  210a16:	74 09                	je     210a21 <BmAdd.lfence.sfence+0xca1>
  210a18:	48 8b 0d 21 a6 03 00 	mov    rcx,QWORD PTR [rip+0x3a621]        # 24b040 <stderr_file_out_stream+0x8>
  210a1f:	eb 3d                	jmp    210a5e <BmAdd.lfence.sfence+0xcde>
        stderr_file = try io.getStdErr();
  210a21:	c7 05 05 a6 03 00 02 	mov    DWORD PTR [rip+0x3a605],0x2        # 24b030 <stderr_file>
  210a28:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  210a2b:	48 8d 05 fe a5 03 00 	lea    rax,[rip+0x3a5fe]        # 24b030 <stderr_file>
  210a32:	48 89 05 ff a5 03 00 	mov    QWORD PTR [rip+0x3a5ff],rax        # 24b038 <stderr_file_out_stream>
  210a39:	48 8d 05 a0 ef 00 00 	lea    rax,[rip+0xefa0]        # 21f9e0 <FileOutStream_writeFn>
  210a40:	48 89 05 f9 a5 03 00 	mov    QWORD PTR [rip+0x3a5f9],rax        # 24b040 <stderr_file_out_stream+0x8>
  210a47:	48 8d 0d f2 a5 03 00 	lea    rcx,[rip+0x3a5f2]        # 24b040 <stderr_file_out_stream+0x8>
  210a4e:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  210a51:	48 89 15 b0 f5 03 00 	mov    QWORD PTR [rip+0x3f5b0],rdx        # 250008 <stderr_stream>
  210a58:	48 89 c1             	mov    rcx,rax
  210a5b:	48 89 d7             	mov    rdi,rdx
  210a5e:	48 8b 6c 24 58       	mov    rbp,QWORD PTR [rsp+0x58]
  210a63:	48 8d 35 ae e3 03 00 	lea    rsi,[rip+0x3e3ae]        # 24ee18 <__unnamed_3>
  210a6a:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  210a6c:	31 c0                	xor    eax,eax
  210a6e:	86 05 9c f5 03 00    	xchg   BYTE PTR [rip+0x3f59c],al        # 250010 <stderr_mutex>
  210a74:	3c 01                	cmp    al,0x1
    if (!ok) {
  210a76:	75 61                	jne    210ad9 <BmAdd.lfence.sfence+0xd59>
  210a78:	48 83 c5 01          	add    rbp,0x1
  210a7c:	45 31 ed             	xor    r13d,r13d
  210a7f:	4d 89 f4             	mov    r12,r14
        while (rep < pSelf.repetitions) : (rep += 1) {
  210a82:	48 3b ac 24 80 00 00 	cmp    rbp,QWORD PTR [rsp+0x80]
  210a89:	00 
  210a8a:	c5 f8 10 0d 2e 83 ff 	vmovups xmm1,XMMWORD PTR [rip+0xffffffffffff832e]        # 208dc0 <__unnamed_5>
  210a91:	ff 
  210a92:	48 8d 74 24 20       	lea    rsi,[rsp+0x20]
  210a97:	0f 82 0d f4 ff ff    	jb     20feaa <BmAdd.lfence.sfence+0x12a>
  210a9d:	48 8d 7c 24 60       	lea    rdi,[rsp+0x60]
        try pSelf.reportStats(pSelf.results);
  210aa2:	48 8d b4 24 a8 00 00 	lea    rsi,[rsp+0xa8]
  210aa9:	00 
  210aaa:	e8 91 5c 00 00       	call   216740 <Benchmark_reportStats>
  210aaf:	eb 10                	jmp    210ac1 <BmAdd.lfence.sfence+0xd41>
                switch (errno) {
  210ab1:	48 83 f9 16          	cmp    rcx,0x16
  210ab5:	75 06                	jne    210abd <BmAdd.lfence.sfence+0xd3d>
  210ab7:	66 b8 02 00          	mov    ax,0x2
  210abb:	eb 04                	jmp    210ac1 <BmAdd.lfence.sfence+0xd41>
  210abd:	66 b8 03 00          	mov    ax,0x3
    _ = try bm.run(BmAdd);
  210ac1:	48 81 c4 08 01 00 00 	add    rsp,0x108
  210ac8:	5b                   	pop    rbx
  210ac9:	41 5c                	pop    r12
  210acb:	41 5d                	pop    r13
  210acd:	41 5e                	pop    r14
  210acf:	41 5f                	pop    r15
  210ad1:	5d                   	pop    rbp
  210ad2:	c3                   	ret    
  210ad3:	66 b8 06 00          	mov    ax,0x6
  210ad7:	eb e8                	jmp    210ac1 <BmAdd.lfence.sfence+0xd41>
            @panic("assertion failure");
  210ad9:	48 8d 3d 28 e2 03 00 	lea    rdi,[rip+0x3e228]        # 24ed08 <__unnamed_2>
  210ae0:	e8 3b 15 00 00       	call   212020 <panic>
  210ae5:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  210aec:	00 00 00 00 

0000000000210af0 <BmAdd.volatile>:
}

/// Use volatile to actually measure r = a + b
test "BmAdd.volatile" {
  210af0:	55                   	push   rbp
  210af1:	41 57                	push   r15
  210af3:	41 56                	push   r14
  210af5:	41 55                	push   r13
  210af7:	41 54                	push   r12
  210af9:	53                   	push   rbx
  210afa:	48 81 ec 08 01 00 00 	sub    rsp,0x108
  210b01:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  210b08:	0f 1f 84 00 00 00 00 
  210b0f:	00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  210b10:	b0 01                	mov    al,0x1
  210b12:	86 05 f8 f4 03 00    	xchg   BYTE PTR [rip+0x3f4f8],al        # 250010 <stderr_mutex>
  210b18:	84 c0                	test   al,al
  210b1a:	75 f4                	jne    210b10 <BmAdd.volatile+0x20>
    if (stderr_stream) |st| {
  210b1c:	48 8b 3d e5 f4 03 00 	mov    rdi,QWORD PTR [rip+0x3f4e5]        # 250008 <stderr_stream>
  210b23:	48 85 ff             	test   rdi,rdi
  210b26:	74 09                	je     210b31 <BmAdd.volatile+0x41>
  210b28:	48 8b 05 11 a5 03 00 	mov    rax,QWORD PTR [rip+0x3a511]        # 24b040 <stderr_file_out_stream+0x8>
  210b2f:	eb 34                	jmp    210b65 <BmAdd.volatile+0x75>
        stderr_file = try io.getStdErr();
  210b31:	48 8d 05 f8 a4 03 00 	lea    rax,[rip+0x3a4f8]        # 24b030 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  210b38:	48 89 05 f9 a4 03 00 	mov    QWORD PTR [rip+0x3a4f9],rax        # 24b038 <stderr_file_out_stream>
  210b3f:	48 8d 05 9a ee 00 00 	lea    rax,[rip+0xee9a]        # 21f9e0 <FileOutStream_writeFn>
  210b46:	48 89 05 f3 a4 03 00 	mov    QWORD PTR [rip+0x3a4f3],rax        # 24b040 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  210b4d:	c7 05 d9 a4 03 00 02 	mov    DWORD PTR [rip+0x3a4d9],0x2        # 24b030 <stderr_file>
  210b54:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  210b57:	48 8d 3d e2 a4 03 00 	lea    rdi,[rip+0x3a4e2]        # 24b040 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  210b5e:	48 89 3d a3 f4 03 00 	mov    QWORD PTR [rip+0x3f4a3],rdi        # 250008 <stderr_stream>
  210b65:	48 8d 35 ac e2 03 00 	lea    rsi,[rip+0x3e2ac]        # 24ee18 <__unnamed_3>
  210b6c:	ff d0                	call   rax
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  210b6e:	31 c0                	xor    eax,eax
  210b70:	86 05 9a f4 03 00    	xchg   BYTE PTR [rip+0x3f49a],al        # 250010 <stderr_mutex>
  210b76:	3c 01                	cmp    al,0x1
    if (!ok) {
  210b78:	0f 85 4e 0d 00 00    	jne    2118cc <BmAdd.volatile+0xddc>

    // Since this is a test print a \n before we run
    warn("\n");

    // Create an instance of Benchmark, set 10 iterations and run
    var bm = Benchmark.init("BmAdd", std.debug.global_allocator);
  210b7e:	c5 f8 10 05 62 e1 03 	vmovups xmm0,XMMWORD PTR [rip+0x3e162]        # 24ece8 <__unnamed_11>
  210b85:	00 
  210b86:	c5 f8 29 44 24 60    	vmovaps XMMWORD PTR [rsp+0x60],xmm0
  210b8c:	b8 00 65 cd 1d       	mov    eax,0x1dcd6500
  210b91:	c4 e1 f9 6e c0       	vmovq  xmm0,rax
  210b96:	c5 f9 73 f8 08       	vpslldq xmm0,xmm0,0x8
  210b9b:	c5 f9 7f 44 24 70    	vmovdqa XMMWORD PTR [rsp+0x70],xmm0
  210ba1:	48 b8 00 e8 76 48 17 	movabs rax,0x174876e800
  210ba8:	00 00 00 
  210bab:	48 89 84 24 88 00 00 	mov    QWORD PTR [rsp+0x88],rax
  210bb2:	00 
  210bb3:	c5 fa 6f 05 05 82 ff 	vmovdqu xmm0,XMMWORD PTR [rip+0xffffffffffff8205]        # 208dc0 <__unnamed_5>
  210bba:	ff 
  210bbb:	c5 f9 7f 84 24 90 00 	vmovdqa XMMWORD PTR [rsp+0x90],xmm0
  210bc2:	00 00 
  210bc4:	48 8d 05 35 a4 03 00 	lea    rax,[rip+0x3a435]        # 24b000 <global_fixed_allocator>
  210bcb:	48 89 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rax
  210bd2:	00 
  210bd3:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  210bd7:	c5 fa 7f 84 24 a8 00 	vmovdqu XMMWORD PTR [rsp+0xa8],xmm0
  210bde:	00 00 
  210be0:	48 c7 84 24 b8 00 00 	mov    QWORD PTR [rsp+0xb8],0x0
  210be7:	00 00 00 00 00 
  210bec:	48 89 84 24 c0 00 00 	mov    QWORD PTR [rsp+0xc0],rax
  210bf3:	00 
    bm.repetitions = 10;
  210bf4:	48 c7 84 24 80 00 00 	mov    QWORD PTR [rsp+0x80],0xa
  210bfb:	00 0a 00 00 00 
  210c00:	41 b6 01             	mov    r14b,0x1
  210c03:	bb 01 00 00 00       	mov    ebx,0x1
  210c08:	45 31 e4             	xor    r12d,r12d
  210c0b:	c5 f8 10 0d ad 81 ff 	vmovups xmm1,XMMWORD PTR [rip+0xffffffffffff81ad]        # 208dc0 <__unnamed_5>
  210c12:	ff 
  210c13:	4c 8d 7c 24 30       	lea    r15,[rsp+0x30]
  210c18:	45 31 ed             	xor    r13d,r13d
                var ts: posix.timespec = undefined;
  210c1b:	c5 f8 29 4c 24 30    	vmovaps XMMWORD PTR [rsp+0x30],xmm1
  210c21:	b8 e5 00 00 00       	mov    eax,0xe5
  210c26:	bf 01 00 00 00       	mov    edi,0x1
  210c2b:	4c 89 fe             	mov    rsi,r15
  210c2e:	0f 05                	syscall 
  210c30:	48 89 c1             	mov    rcx,rax
  210c33:	48 f7 d9             	neg    rcx
  210c36:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  210c3c:	49 0f 46 cc          	cmovbe rcx,r12
                switch (errno) {
  210c40:	48 85 c9             	test   rcx,rcx
  210c43:	0f 85 5b 0c 00 00    	jne    2118a4 <BmAdd.volatile+0xdb4>
        const f = @atomicLoad(@typeOf(init_vdso_clock_gettime), &vdso_clock_gettime, builtin.AtomicOrder.Unordered);
  210c49:	48 8b 05 f8 a3 03 00 	mov    rax,QWORD PTR [rip+0x3a3f8]        # 24b048 <vdso_clock_gettime>
        if (@ptrToInt(f) != 0) {
  210c50:	48 85 c0             	test   rax,rax
  210c53:	74 21                	je     210c76 <BmAdd.volatile+0x186>
            const rc = f(clk_id, tp);
  210c55:	bf 01 00 00 00       	mov    edi,0x1
  210c5a:	4c 89 fe             	mov    rsi,r15
  210c5d:	ff d0                	call   rax
            switch (rc) {
  210c5f:	48 83 f8 ea          	cmp    rax,0xffffffffffffffea
  210c63:	0f 84 f7 04 00 00    	je     211160 <BmAdd.volatile+0x670>
  210c69:	48 85 c0             	test   rax,rax
  210c6c:	c5 f8 10 0d 4c 81 ff 	vmovups xmm1,XMMWORD PTR [rip+0xffffffffffff814c]        # 208dc0 <__unnamed_5>
  210c73:	ff 
  210c74:	74 0f                	je     210c85 <BmAdd.volatile+0x195>
  210c76:	b8 e4 00 00 00       	mov    eax,0xe4
  210c7b:	bf 01 00 00 00       	mov    edi,0x1
  210c80:	4c 89 fe             	mov    rsi,r15
  210c83:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  210c85:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
                if (errno != 0) return std.os.unexpectedErrorPosix(errno);
  210c8b:	0f 83 1f 0c 00 00    	jae    2118b0 <BmAdd.volatile+0xdc0>
                self.start_time = @intCast(u64, ts.tv_sec) * u64(ns_per_s) + @intCast(u64, ts.tv_nsec);
  210c91:	48 8b 6c 24 30       	mov    rbp,QWORD PTR [rsp+0x30]
  210c96:	4c 8b 64 24 38       	mov    r12,QWORD PTR [rsp+0x38]
        var ts: posix.timespec = undefined;
  210c9b:	c5 f8 29 4c 24 30    	vmovaps XMMWORD PTR [rsp+0x30],xmm1
        const f = @atomicLoad(@typeOf(init_vdso_clock_gettime), &vdso_clock_gettime, builtin.AtomicOrder.Unordered);
  210ca1:	48 8b 05 a0 a3 03 00 	mov    rax,QWORD PTR [rip+0x3a3a0]        # 24b048 <vdso_clock_gettime>
        if (@ptrToInt(f) != 0) {
  210ca8:	48 85 c0             	test   rax,rax
  210cab:	74 21                	je     210cce <BmAdd.volatile+0x1de>
            const rc = f(clk_id, tp);
  210cad:	bf 01 00 00 00       	mov    edi,0x1
  210cb2:	4c 89 fe             	mov    rsi,r15
  210cb5:	ff d0                	call   rax
            switch (rc) {
  210cb7:	48 83 f8 ea          	cmp    rax,0xffffffffffffffea
  210cbb:	0f 84 b8 04 00 00    	je     211179 <BmAdd.volatile+0x689>
  210cc1:	48 85 c0             	test   rax,rax
  210cc4:	c5 f8 10 0d f4 80 ff 	vmovups xmm1,XMMWORD PTR [rip+0xffffffffffff80f4]        # 208dc0 <__unnamed_5>
  210ccb:	ff 
  210ccc:	74 0f                	je     210cdd <BmAdd.volatile+0x1ed>
  210cce:	b8 e4 00 00 00       	mov    eax,0xe4
  210cd3:	bf 01 00 00 00       	mov    edi,0x1
  210cd8:	4c 89 fe             	mov    rsi,r15
  210cdb:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  210cdd:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
  210ce3:	0f 83 e3 0b 00 00    	jae    2118cc <BmAdd.volatile+0xddc>
        return @intCast(u64, ts.tv_sec) * u64(ns_per_s) + @intCast(u64, ts.tv_nsec);
  210ce9:	48 8b 44 24 30       	mov    rax,QWORD PTR [rsp+0x30]
  210cee:	48 29 e8             	sub    rax,rbp
  210cf1:	48 8b 4c 24 38       	mov    rcx,QWORD PTR [rsp+0x38]
  210cf6:	4c 29 e1             	sub    rcx,r12
  210cf9:	48 69 c0 00 ca 9a 3b 	imul   rax,rax,0x3b9aca00
        var clock = clockNative() - self.start_time;
  210d00:	48 01 c8             	add    rax,rcx
        self.s +%= 0x9e3779b97f4a7c15;
  210d03:	48 b9 15 7c 4a 7f b9 	movabs rcx,0x9e3779b97f4a7c15
  210d0a:	79 37 9e 
  210d0d:	48 8d 0c 08          	lea    rcx,[rax+rcx*1]
        z = (z ^ (z >> 30)) *% 0xbf58476d1ce4e5b9;
  210d11:	48 89 ca             	mov    rdx,rcx
  210d14:	48 c1 ea 1e          	shr    rdx,0x1e
  210d18:	48 31 ca             	xor    rdx,rcx
  210d1b:	48 b9 b9 e5 e4 1c 6d 	movabs rcx,0xbf58476d1ce4e5b9
  210d22:	47 58 bf 
  210d25:	48 89 ce             	mov    rsi,rcx
  210d28:	48 0f af d6          	imul   rdx,rsi
        z = (z ^ (z >> 27)) *% 0x94d049bb133111eb;
  210d2c:	48 89 d1             	mov    rcx,rdx
  210d2f:	48 c1 e9 1b          	shr    rcx,0x1b
  210d33:	48 31 d1             	xor    rcx,rdx
  210d36:	48 ba eb 11 31 13 bb 	movabs rdx,0x94d049bb133111eb
  210d3d:	49 d0 94 
  210d40:	48 89 d7             	mov    rdi,rdx
  210d43:	48 0f af cf          	imul   rcx,rdi
        return z ^ (z >> 31);
  210d47:	48 89 ca             	mov    rdx,rcx
  210d4a:	48 c1 ea 1f          	shr    rdx,0x1f
  210d4e:	48 31 ca             	xor    rdx,rcx
        self.s +%= 0x9e3779b97f4a7c15;
  210d51:	48 b9 2a f8 94 fe 72 	movabs rcx,0x3c6ef372fe94f82a
  210d58:	f3 6e 3c 
  210d5b:	48 01 c8             	add    rax,rcx
        z = (z ^ (z >> 30)) *% 0xbf58476d1ce4e5b9;
  210d5e:	48 89 c1             	mov    rcx,rax
  210d61:	48 c1 e9 1e          	shr    rcx,0x1e
  210d65:	48 31 c1             	xor    rcx,rax
  210d68:	48 0f af ce          	imul   rcx,rsi
        z = (z ^ (z >> 27)) *% 0x94d049bb133111eb;
  210d6c:	48 89 c8             	mov    rax,rcx
  210d6f:	48 c1 e8 1b          	shr    rax,0x1b
  210d73:	48 31 c8             	xor    rax,rcx
  210d76:	48 0f af c7          	imul   rax,rdi
        return z ^ (z >> 31);
  210d7a:	48 89 c1             	mov    rcx,rax
  210d7d:	48 c1 e9 1f          	shr    rcx,0x1f
  210d81:	48 31 c1             	xor    rcx,rax
        const r = s0 +% s1;
  210d84:	48 8d 04 11          	lea    rax,[rcx+rdx*1]
        s1 ^= s0;
  210d88:	48 31 d1             	xor    rcx,rdx
  210d8b:	c4 e3 fb f0 d2 09    	rorx   rdx,rdx,0x9
        self.s[0] = math.rotl(u64, s0, u8(55)) ^ s1 ^ (s1 << 14);
  210d91:	48 31 ca             	xor    rdx,rcx
  210d94:	c4 e3 fb f0 f1 1c    	rorx   rsi,rcx,0x1c
  210d9a:	48 c1 e1 0e          	shl    rcx,0xe
  210d9e:	48 31 d1             	xor    rcx,rdx
        const r = s0 +% s1;
  210da1:	48 01 f1             	add    rcx,rsi
            pSelf.a = prng.random.scalar(u64);
  210da4:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
            pSelf.b = prng.random.scalar(u64);
  210da9:	48 89 4c 24 08       	mov    QWORD PTR [rsp+0x8],rcx
            while (iterations <= pSelf.max_iterations) {
  210dae:	48 8b ac 24 88 00 00 	mov    rbp,QWORD PTR [rsp+0x88]
  210db5:	00 
  210db6:	48 39 eb             	cmp    rbx,rbp
  210db9:	41 bc 00 00 00 00    	mov    r12d,0x0
  210dbf:	76 22                	jbe    210de3 <BmAdd.volatile+0x2f3>
  210dc1:	e9 00 04 00 00       	jmp    2111c6 <BmAdd.volatile+0x6d6>
  210dc6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  210dcd:	00 00 00 
                        warn("iteratons:{} numer:{} denom:{}\n", iterations, numer, denom);
  210dd0:	48 89 df             	mov    rdi,rbx
  210dd3:	48 89 ca             	mov    rdx,rcx
  210dd6:	e8 95 4d 00 00       	call   215b70 <warn.36>
  210ddb:	c5 f8 10 0d dd 7f ff 	vmovups xmm1,XMMWORD PTR [rip+0xffffffffffff7fdd]        # 208dc0 <__unnamed_5>
  210de2:	ff 
                var ts: posix.timespec = undefined;
  210de3:	c5 f8 29 4c 24 30    	vmovaps XMMWORD PTR [rsp+0x30],xmm1
  210de9:	b8 e5 00 00 00       	mov    eax,0xe5
  210dee:	bf 01 00 00 00       	mov    edi,0x1
  210df3:	4c 89 fe             	mov    rsi,r15
  210df6:	0f 05                	syscall 
  210df8:	48 89 c1             	mov    rcx,rax
  210dfb:	48 f7 d9             	neg    rcx
  210dfe:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  210e04:	49 0f 46 cc          	cmovbe rcx,r12
                switch (errno) {
  210e08:	48 85 c9             	test   rcx,rcx
  210e0b:	0f 85 93 0a 00 00    	jne    2118a4 <BmAdd.volatile+0xdb4>
        const f = @atomicLoad(@typeOf(init_vdso_clock_gettime), &vdso_clock_gettime, builtin.AtomicOrder.Unordered);
  210e11:	48 8b 05 30 a2 03 00 	mov    rax,QWORD PTR [rip+0x3a230]        # 24b048 <vdso_clock_gettime>
        if (@ptrToInt(f) != 0) {
  210e18:	48 85 c0             	test   rax,rax
  210e1b:	74 21                	je     210e3e <BmAdd.volatile+0x34e>
            const rc = f(clk_id, tp);
  210e1d:	bf 01 00 00 00       	mov    edi,0x1
  210e22:	4c 89 fe             	mov    rsi,r15
  210e25:	ff d0                	call   rax
            switch (rc) {
  210e27:	48 83 f8 ea          	cmp    rax,0xffffffffffffffea
  210e2b:	0f 84 ef 02 00 00    	je     211120 <BmAdd.volatile+0x630>
  210e31:	48 85 c0             	test   rax,rax
  210e34:	c5 f8 10 0d 84 7f ff 	vmovups xmm1,XMMWORD PTR [rip+0xffffffffffff7f84]        # 208dc0 <__unnamed_5>
  210e3b:	ff 
  210e3c:	74 0f                	je     210e4d <BmAdd.volatile+0x35d>
  210e3e:	b8 e4 00 00 00       	mov    eax,0xe4
  210e43:	bf 01 00 00 00       	mov    edi,0x1
  210e48:	4c 89 fe             	mov    rsi,r15
  210e4b:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  210e4d:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
                if (errno != 0) return std.os.unexpectedErrorPosix(errno);
  210e53:	0f 83 57 0a 00 00    	jae    2118b0 <BmAdd.volatile+0xdc0>
                self.start_time = @intCast(u64, ts.tv_sec) * u64(ns_per_s) + @intCast(u64, ts.tv_nsec);
  210e59:	c5 f9 6f 54 24 30    	vmovdqa xmm2,XMMWORD PTR [rsp+0x30]
        while (iter > 0) : (iter -= 1) {
  210e5f:	48 85 db             	test   rbx,rbx
  210e62:	0f 84 b6 00 00 00    	je     210f1e <BmAdd.volatile+0x42e>
            pR.* = (pA.* + pB.*);
  210e68:	48 8d 4b ff          	lea    rcx,[rbx-0x1]
  210e6c:	48 89 da             	mov    rdx,rbx
  210e6f:	48 89 d8             	mov    rax,rbx
  210e72:	48 83 e2 07          	and    rdx,0x7
  210e76:	74 21                	je     210e99 <BmAdd.volatile+0x3a9>
  210e78:	48 f7 da             	neg    rdx
  210e7b:	48 89 d8             	mov    rax,rbx
  210e7e:	66 90                	xchg   ax,ax
  210e80:	48 8b 74 24 10       	mov    rsi,QWORD PTR [rsp+0x10]
  210e85:	48 03 74 24 08       	add    rsi,QWORD PTR [rsp+0x8]
  210e8a:	48 89 74 24 18       	mov    QWORD PTR [rsp+0x18],rsi
        while (iter > 0) : (iter -= 1) {
  210e8f:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  210e93:	48 83 c2 01          	add    rdx,0x1
  210e97:	75 e7                	jne    210e80 <BmAdd.volatile+0x390>
            pR.* = (pA.* + pB.*);
  210e99:	48 83 f9 07          	cmp    rcx,0x7
  210e9d:	72 7f                	jb     210f1e <BmAdd.volatile+0x42e>
  210e9f:	90                   	nop
  210ea0:	48 8b 4c 24 10       	mov    rcx,QWORD PTR [rsp+0x10]
  210ea5:	48 03 4c 24 08       	add    rcx,QWORD PTR [rsp+0x8]
  210eaa:	48 89 4c 24 18       	mov    QWORD PTR [rsp+0x18],rcx
  210eaf:	48 8b 4c 24 10       	mov    rcx,QWORD PTR [rsp+0x10]
  210eb4:	48 03 4c 24 08       	add    rcx,QWORD PTR [rsp+0x8]
  210eb9:	48 89 4c 24 18       	mov    QWORD PTR [rsp+0x18],rcx
  210ebe:	48 8b 4c 24 10       	mov    rcx,QWORD PTR [rsp+0x10]
  210ec3:	48 03 4c 24 08       	add    rcx,QWORD PTR [rsp+0x8]
  210ec8:	48 89 4c 24 18       	mov    QWORD PTR [rsp+0x18],rcx
  210ecd:	48 8b 4c 24 10       	mov    rcx,QWORD PTR [rsp+0x10]
  210ed2:	48 03 4c 24 08       	add    rcx,QWORD PTR [rsp+0x8]
  210ed7:	48 89 4c 24 18       	mov    QWORD PTR [rsp+0x18],rcx
  210edc:	48 8b 4c 24 10       	mov    rcx,QWORD PTR [rsp+0x10]
  210ee1:	48 03 4c 24 08       	add    rcx,QWORD PTR [rsp+0x8]
  210ee6:	48 89 4c 24 18       	mov    QWORD PTR [rsp+0x18],rcx
  210eeb:	48 8b 4c 24 10       	mov    rcx,QWORD PTR [rsp+0x10]
  210ef0:	48 03 4c 24 08       	add    rcx,QWORD PTR [rsp+0x8]
  210ef5:	48 89 4c 24 18       	mov    QWORD PTR [rsp+0x18],rcx
  210efa:	48 8b 4c 24 10       	mov    rcx,QWORD PTR [rsp+0x10]
  210eff:	48 03 4c 24 08       	add    rcx,QWORD PTR [rsp+0x8]
  210f04:	48 89 4c 24 18       	mov    QWORD PTR [rsp+0x18],rcx
  210f09:	48 8b 4c 24 10       	mov    rcx,QWORD PTR [rsp+0x10]
  210f0e:	48 03 4c 24 08       	add    rcx,QWORD PTR [rsp+0x8]
        while (iter > 0) : (iter -= 1) {
  210f13:	48 83 c0 f8          	add    rax,0xfffffffffffffff8
            pR.* = (pA.* + pB.*);
  210f17:	48 89 4c 24 18       	mov    QWORD PTR [rsp+0x18],rcx
        while (iter > 0) : (iter -= 1) {
  210f1c:	75 82                	jne    210ea0 <BmAdd.volatile+0x3b0>
        var ts: posix.timespec = undefined;
  210f1e:	c5 f8 29 4c 24 30    	vmovaps XMMWORD PTR [rsp+0x30],xmm1
        const f = @atomicLoad(@typeOf(init_vdso_clock_gettime), &vdso_clock_gettime, builtin.AtomicOrder.Unordered);
  210f24:	48 8b 05 1d a1 03 00 	mov    rax,QWORD PTR [rip+0x3a11d]        # 24b048 <vdso_clock_gettime>
        if (@ptrToInt(f) != 0) {
  210f2b:	48 85 c0             	test   rax,rax
  210f2e:	74 33                	je     210f63 <BmAdd.volatile+0x473>
  210f30:	c5 f9 7f 94 24 d0 00 	vmovdqa XMMWORD PTR [rsp+0xd0],xmm2
  210f37:	00 00 
            const rc = f(clk_id, tp);
  210f39:	bf 01 00 00 00       	mov    edi,0x1
  210f3e:	4c 89 fe             	mov    rsi,r15
  210f41:	ff d0                	call   rax
            switch (rc) {
  210f43:	48 83 f8 ea          	cmp    rax,0xffffffffffffffea
  210f47:	0f 84 ec 01 00 00    	je     211139 <BmAdd.volatile+0x649>
  210f4d:	48 85 c0             	test   rax,rax
  210f50:	c5 f8 10 0d 68 7e ff 	vmovups xmm1,XMMWORD PTR [rip+0xffffffffffff7e68]        # 208dc0 <__unnamed_5>
  210f57:	ff 
  210f58:	c5 f9 6f 94 24 d0 00 	vmovdqa xmm2,XMMWORD PTR [rsp+0xd0]
  210f5f:	00 00 
  210f61:	74 0f                	je     210f72 <BmAdd.volatile+0x482>
  210f63:	b8 e4 00 00 00       	mov    eax,0xe4
  210f68:	bf 01 00 00 00       	mov    edi,0x1
  210f6d:	4c 89 fe             	mov    rsi,r15
  210f70:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  210f72:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
  210f78:	0f 83 4e 09 00 00    	jae    2118cc <BmAdd.volatile+0xddc>
        return @intCast(u64, ts.tv_sec) * u64(ns_per_s) + @intCast(u64, ts.tv_nsec);
  210f7e:	c5 f9 6f 44 24 30    	vmovdqa xmm0,XMMWORD PTR [rsp+0x30]
  210f84:	c5 f9 fb c2          	vpsubq xmm0,xmm0,xmm2
  210f88:	c4 e1 f9 7e c0       	vmovq  rax,xmm0
        var clock = clockNative() - self.start_time;
  210f8d:	c4 c3 f9 16 c4 01    	vpextrq r12,xmm0,0x1
  210f93:	48 69 c0 00 ca 9a 3b 	imul   rax,rax,0x3b9aca00
  210f9a:	49 01 c4             	add    r12,rax
                if ((run_time_ns >= pSelf.min_runtime_ns) or (iterations >= pSelf.max_iterations)) {
  210f9d:	4c 3b 64 24 78       	cmp    r12,QWORD PTR [rsp+0x78]
  210fa2:	0f 83 ea 01 00 00    	jae    211192 <BmAdd.volatile+0x6a2>
  210fa8:	48 39 eb             	cmp    rbx,rbp
  210fab:	0f 83 e1 01 00 00    	jae    211192 <BmAdd.volatile+0x6a2>
                    if (pSelf.logl >= 1) {
  210fb1:	48 83 7c 24 70 00    	cmp    QWORD PTR [rsp+0x70],0x0
  210fb7:	0f 84 c1 00 00 00    	je     21107e <BmAdd.volatile+0x58e>
                            Result {.run_time_ns = run_time_ns, .iterations = iterations});
  210fbd:	4c 89 a4 24 e8 00 00 	mov    QWORD PTR [rsp+0xe8],r12
  210fc4:	00 
  210fc5:	48 89 9c 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rbx
  210fcc:	00 
                        try pSelf.report(
  210fcd:	48 8d 7c 24 60       	lea    rdi,[rsp+0x60]
  210fd2:	48 8d b4 24 e8 00 00 	lea    rsi,[rsp+0xe8]
  210fd9:	00 
  210fda:	e8 81 2a 00 00       	call   213a60 <Benchmark_report>
  210fdf:	66 85 c0             	test   ax,ax
  210fe2:	0f 85 cc 08 00 00    	jne    2118b4 <BmAdd.volatile+0xdc4>
  210fe8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  210fef:	00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  210ff0:	b0 01                	mov    al,0x1
  210ff2:	86 05 18 f0 03 00    	xchg   BYTE PTR [rip+0x3f018],al        # 250010 <stderr_mutex>
  210ff8:	84 c0                	test   al,al
  210ffa:	75 f4                	jne    210ff0 <BmAdd.volatile+0x500>
    if (stderr_stream) |st| {
  210ffc:	48 8b 3d 05 f0 03 00 	mov    rdi,QWORD PTR [rip+0x3f005]        # 250008 <stderr_stream>
  211003:	48 85 ff             	test   rdi,rdi
  211006:	74 18                	je     211020 <BmAdd.volatile+0x530>
  211008:	48 8b 0d 31 a0 03 00 	mov    rcx,QWORD PTR [rip+0x3a031]        # 24b040 <stderr_file_out_stream+0x8>
  21100f:	eb 4c                	jmp    21105d <BmAdd.volatile+0x56d>
  211011:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  211018:	0f 1f 84 00 00 00 00 
  21101f:	00 
        stderr_file = try io.getStdErr();
  211020:	c7 05 06 a0 03 00 02 	mov    DWORD PTR [rip+0x3a006],0x2        # 24b030 <stderr_file>
  211027:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  21102a:	48 8d 05 ff 9f 03 00 	lea    rax,[rip+0x39fff]        # 24b030 <stderr_file>
  211031:	48 89 05 00 a0 03 00 	mov    QWORD PTR [rip+0x3a000],rax        # 24b038 <stderr_file_out_stream>
  211038:	48 8d 05 a1 e9 00 00 	lea    rax,[rip+0xe9a1]        # 21f9e0 <FileOutStream_writeFn>
  21103f:	48 89 05 fa 9f 03 00 	mov    QWORD PTR [rip+0x39ffa],rax        # 24b040 <stderr_file_out_stream+0x8>
  211046:	48 8d 0d f3 9f 03 00 	lea    rcx,[rip+0x39ff3]        # 24b040 <stderr_file_out_stream+0x8>
  21104d:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  211050:	48 89 15 b1 ef 03 00 	mov    QWORD PTR [rip+0x3efb1],rdx        # 250008 <stderr_stream>
  211057:	48 89 c1             	mov    rcx,rax
  21105a:	48 89 d7             	mov    rdi,rdx
  21105d:	48 8d 35 b4 dd 03 00 	lea    rsi,[rip+0x3ddb4]        # 24ee18 <__unnamed_3>
  211064:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  211066:	31 c0                	xor    eax,eax
  211068:	86 05 a2 ef 03 00    	xchg   BYTE PTR [rip+0x3efa2],al        # 250010 <stderr_mutex>
  21106e:	3c 01                	cmp    al,0x1
  211070:	c5 f8 10 0d 48 7d ff 	vmovups xmm1,XMMWORD PTR [rip+0xffffffffffff7d48]        # 208dc0 <__unnamed_5>
  211077:	ff 
    if (!ok) {
  211078:	0f 85 4e 08 00 00    	jne    2118cc <BmAdd.volatile+0xddc>
                    if (run_time_ns < 1000) {
  21107e:	49 81 fc e8 03 00 00 	cmp    r12,0x3e8
  211085:	73 19                	jae    2110a0 <BmAdd.volatile+0x5b0>
  211087:	b9 01 00 00 00       	mov    ecx,0x1
  21108c:	be e8 03 00 00       	mov    esi,0x3e8
  211091:	eb 3a                	jmp    2110cd <BmAdd.volatile+0x5dd>
  211093:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21109a:	84 00 00 00 00 00 
                    } else if (run_time_ns < (pSelf.min_runtime_ns / 10)) {
  2110a0:	48 ba cd cc cc cc cc 	movabs rdx,0xcccccccccccccccd
  2110a7:	cc cc cc 
  2110aa:	c4 e2 fb f6 4c 24 78 	mulx   rcx,rax,QWORD PTR [rsp+0x78]
  2110b1:	48 c1 e9 03          	shr    rcx,0x3
  2110b5:	31 c0                	xor    eax,eax
  2110b7:	49 39 cc             	cmp    r12,rcx
  2110ba:	0f 93 c0             	setae  al
  2110bd:	48 8d 0c c0          	lea    rcx,[rax+rax*8]
  2110c1:	48 83 c1 01          	add    rcx,0x1
  2110c5:	48 8d 34 85 0a 00 00 	lea    rsi,[rax*4+0xa]
  2110cc:	00 
  2110cd:	45 31 e4             	xor    r12d,r12d
                    iterations = (iterations * numer) / denom;
  2110d0:	48 0f af de          	imul   rbx,rsi
  2110d4:	48 89 d8             	mov    rax,rbx
  2110d7:	48 c1 e8 20          	shr    rax,0x20
  2110db:	74 13                	je     2110f0 <BmAdd.volatile+0x600>
  2110dd:	31 d2                	xor    edx,edx
  2110df:	48 89 d8             	mov    rax,rbx
  2110e2:	48 f7 f1             	div    rcx
  2110e5:	48 89 c3             	mov    rbx,rax
  2110e8:	eb 0e                	jmp    2110f8 <BmAdd.volatile+0x608>
  2110ea:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  2110f0:	31 d2                	xor    edx,edx
  2110f2:	89 d8                	mov    eax,ebx
  2110f4:	f7 f1                	div    ecx
  2110f6:	89 c3                	mov    ebx,eax
                    if (iterations > pSelf.max_iterations) {
  2110f8:	48 8b ac 24 88 00 00 	mov    rbp,QWORD PTR [rsp+0x88]
  2110ff:	00 
  211100:	48 39 eb             	cmp    rbx,rbp
  211103:	48 0f 47 dd          	cmova  rbx,rbp
                    if (pSelf.logl >= 2) {
  211107:	48 83 7c 24 70 02    	cmp    QWORD PTR [rsp+0x70],0x2
  21110d:	0f 82 d0 fc ff ff    	jb     210de3 <BmAdd.volatile+0x2f3>
  211113:	e9 b8 fc ff ff       	jmp    210dd0 <BmAdd.volatile+0x2e0>
  211118:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  21111f:	00 
  211120:	c5 f8 10 0d 98 7c ff 	vmovups xmm1,XMMWORD PTR [rip+0xffffffffffff7c98]        # 208dc0 <__unnamed_5>
  211127:	ff 
  211128:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
  21112e:	0f 82 25 fd ff ff    	jb     210e59 <BmAdd.volatile+0x369>
  211134:	e9 77 07 00 00       	jmp    2118b0 <BmAdd.volatile+0xdc0>
  211139:	c5 f8 10 0d 7f 7c ff 	vmovups xmm1,XMMWORD PTR [rip+0xffffffffffff7c7f]        # 208dc0 <__unnamed_5>
  211140:	ff 
  211141:	c5 f9 6f 94 24 d0 00 	vmovdqa xmm2,XMMWORD PTR [rsp+0xd0]
  211148:	00 00 
  21114a:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
  211150:	0f 82 28 fe ff ff    	jb     210f7e <BmAdd.volatile+0x48e>
  211156:	e9 71 07 00 00       	jmp    2118cc <BmAdd.volatile+0xddc>
  21115b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  211160:	c5 f8 10 0d 58 7c ff 	vmovups xmm1,XMMWORD PTR [rip+0xffffffffffff7c58]        # 208dc0 <__unnamed_5>
  211167:	ff 
  211168:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
                if (errno != 0) return std.os.unexpectedErrorPosix(errno);
  21116e:	0f 82 1d fb ff ff    	jb     210c91 <BmAdd.volatile+0x1a1>
  211174:	e9 37 07 00 00       	jmp    2118b0 <BmAdd.volatile+0xdc0>
  211179:	c5 f8 10 0d 3f 7c ff 	vmovups xmm1,XMMWORD PTR [rip+0xffffffffffff7c3f]        # 208dc0 <__unnamed_5>
  211180:	ff 
  211181:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
  211187:	0f 82 5c fb ff ff    	jb     210ce9 <BmAdd.volatile+0x1f9>
  21118d:	e9 3a 07 00 00       	jmp    2118cc <BmAdd.volatile+0xddc>
                            Result { .run_time_ns = run_time_ns, .iterations = iterations});
  211192:	4c 89 a4 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],r12
  211199:	00 
  21119a:	48 89 9c 24 00 01 00 	mov    QWORD PTR [rsp+0x100],rbx
  2111a1:	00 
                    try pSelf.results.append(
  2111a2:	48 8d bc 24 a8 00 00 	lea    rdi,[rsp+0xa8]
  2111a9:	00 
  2111aa:	48 8d b4 24 f8 00 00 	lea    rsi,[rsp+0xf8]
  2111b1:	00 
  2111b2:	e8 39 27 00 00       	call   2138f0 <AlignedArrayList(Result,8)_append>
  2111b7:	66 85 c0             	test   ax,ax
  2111ba:	41 bc 00 00 00 00    	mov    r12d,0x0
  2111c0:	0f 85 ee 06 00 00    	jne    2118b4 <BmAdd.volatile+0xdc4>
  2111c6:	48 8b 44 24 08       	mov    rax,QWORD PTR [rsp+0x8]
            if (pSelf.r != (u64(pSelf.a) + u64(pSelf.b))) return error.Failed;
  2111cb:	48 03 44 24 10       	add    rax,QWORD PTR [rsp+0x10]
  2111d0:	48 3b 44 24 18       	cmp    rax,QWORD PTR [rsp+0x18]
                    try bm.tearDown();
  2111d5:	0f 85 eb 06 00 00    	jne    2118c6 <BmAdd.volatile+0xdd6>
            if (once) {
  2111db:	41 f6 c6 01          	test   r14b,0x1
  2111df:	48 8d 6c 24 07       	lea    rbp,[rsp+0x7]
  2111e4:	4c 8d 74 24 20       	lea    r14,[rsp+0x20]
  2111e9:	0f 84 d8 05 00 00    	je     2117c7 <BmAdd.volatile+0xcd7>
                try leftJustified(22, "name repetitions:{}", pSelf.repetitions);
  2111ef:	48 8b bc 24 80 00 00 	mov    rdi,QWORD PTR [rsp+0x80]
  2111f6:	00 
  2111f7:	e8 e4 4c 00 00       	call   215ee0 <Benchmark_leftJustified>
  2111fc:	66 85 c0             	test   ax,ax
  2111ff:	0f 85 af 06 00 00    	jne    2118b4 <BmAdd.volatile+0xdc4>
                try rightJustified(14, "{}", "iterations");
  211205:	e8 76 4f 00 00       	call   216180 <Benchmark_rightJustified>
  21120a:	66 85 c0             	test   ax,ax
  21120d:	0f 85 a1 06 00 00    	jne    2118b4 <BmAdd.volatile+0xdc4>
        var buffer: [40]u8 = undefined;
  211213:	c5 fe 6f 05 80 43 ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffff4380]        # 20559b <__unnamed_7>
  21121a:	ff 
  21121b:	c5 fe 7f 44 24 30    	vmovdqu YMMWORD PTR [rsp+0x30],ymm0
  211221:	48 8b 05 93 43 ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffff4393]        # 2055bb <__unnamed_7+0x20>
  211228:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
  21122d:	c7 44 24 30 74 69 6d 	mov    DWORD PTR [rsp+0x30],0x656d6974
  211234:	65 
  211235:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21123c:	00 00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  211240:	b0 01                	mov    al,0x1
  211242:	86 05 c8 ed 03 00    	xchg   BYTE PTR [rip+0x3edc8],al        # 250010 <stderr_mutex>
  211248:	84 c0                	test   al,al
  21124a:	75 f4                	jne    211240 <BmAdd.volatile+0x750>
    if (stderr_stream) |st| {
  21124c:	48 8b 3d b5 ed 03 00 	mov    rdi,QWORD PTR [rip+0x3edb5]        # 250008 <stderr_stream>
  211253:	48 85 ff             	test   rdi,rdi
  211256:	74 09                	je     211261 <BmAdd.volatile+0x771>
  211258:	48 8b 0d e1 9d 03 00 	mov    rcx,QWORD PTR [rip+0x39de1]        # 24b040 <stderr_file_out_stream+0x8>
  21125f:	eb 3d                	jmp    21129e <BmAdd.volatile+0x7ae>
        stderr_file = try io.getStdErr();
  211261:	c7 05 c5 9d 03 00 02 	mov    DWORD PTR [rip+0x39dc5],0x2        # 24b030 <stderr_file>
  211268:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  21126b:	48 8d 05 be 9d 03 00 	lea    rax,[rip+0x39dbe]        # 24b030 <stderr_file>
  211272:	48 89 05 bf 9d 03 00 	mov    QWORD PTR [rip+0x39dbf],rax        # 24b038 <stderr_file_out_stream>
  211279:	48 8d 05 60 e7 00 00 	lea    rax,[rip+0xe760]        # 21f9e0 <FileOutStream_writeFn>
  211280:	48 89 05 b9 9d 03 00 	mov    QWORD PTR [rip+0x39db9],rax        # 24b040 <stderr_file_out_stream+0x8>
  211287:	48 8d 0d b2 9d 03 00 	lea    rcx,[rip+0x39db2]        # 24b040 <stderr_file_out_stream+0x8>
  21128e:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  211291:	48 89 15 70 ed 03 00 	mov    QWORD PTR [rip+0x3ed70],rdx        # 250008 <stderr_stream>
  211298:	48 89 c1             	mov    rcx,rax
  21129b:	48 89 d7             	mov    rdi,rdx
  21129e:	c6 44 24 07 20       	mov    BYTE PTR [rsp+0x7],0x20
    return output(context, (*[1]u8)(&c)[0..]);
  2112a3:	48 89 6c 24 20       	mov    QWORD PTR [rsp+0x20],rbp
  2112a8:	48 c7 44 24 28 01 00 	mov    QWORD PTR [rsp+0x28],0x1
  2112af:	00 00 
  2112b1:	4c 89 f6             	mov    rsi,r14
  2112b4:	c5 f8 77             	vzeroupper 
  2112b7:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  2112b9:	31 c0                	xor    eax,eax
  2112bb:	86 05 4f ed 03 00    	xchg   BYTE PTR [rip+0x3ed4f],al        # 250010 <stderr_mutex>
  2112c1:	3c 01                	cmp    al,0x1
    if (!ok) {
  2112c3:	0f 85 03 06 00 00    	jne    2118cc <BmAdd.volatile+0xddc>
  2112c9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  2112d0:	b0 01                	mov    al,0x1
  2112d2:	86 05 38 ed 03 00    	xchg   BYTE PTR [rip+0x3ed38],al        # 250010 <stderr_mutex>
  2112d8:	84 c0                	test   al,al
  2112da:	75 f4                	jne    2112d0 <BmAdd.volatile+0x7e0>
    if (stderr_stream) |st| {
  2112dc:	48 8b 3d 25 ed 03 00 	mov    rdi,QWORD PTR [rip+0x3ed25]        # 250008 <stderr_stream>
  2112e3:	48 85 ff             	test   rdi,rdi
  2112e6:	74 09                	je     2112f1 <BmAdd.volatile+0x801>
  2112e8:	48 8b 0d 51 9d 03 00 	mov    rcx,QWORD PTR [rip+0x39d51]        # 24b040 <stderr_file_out_stream+0x8>
  2112ef:	eb 3d                	jmp    21132e <BmAdd.volatile+0x83e>
        stderr_file = try io.getStdErr();
  2112f1:	c7 05 35 9d 03 00 02 	mov    DWORD PTR [rip+0x39d35],0x2        # 24b030 <stderr_file>
  2112f8:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  2112fb:	48 8d 05 2e 9d 03 00 	lea    rax,[rip+0x39d2e]        # 24b030 <stderr_file>
  211302:	48 89 05 2f 9d 03 00 	mov    QWORD PTR [rip+0x39d2f],rax        # 24b038 <stderr_file_out_stream>
  211309:	48 8d 05 d0 e6 00 00 	lea    rax,[rip+0xe6d0]        # 21f9e0 <FileOutStream_writeFn>
  211310:	48 89 05 29 9d 03 00 	mov    QWORD PTR [rip+0x39d29],rax        # 24b040 <stderr_file_out_stream+0x8>
  211317:	48 8d 0d 22 9d 03 00 	lea    rcx,[rip+0x39d22]        # 24b040 <stderr_file_out_stream+0x8>
  21131e:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  211321:	48 89 15 e0 ec 03 00 	mov    QWORD PTR [rip+0x3ece0],rdx        # 250008 <stderr_stream>
  211328:	48 89 c1             	mov    rcx,rax
  21132b:	48 89 d7             	mov    rdi,rdx
  21132e:	c6 44 24 07 20       	mov    BYTE PTR [rsp+0x7],0x20
  211333:	48 89 6c 24 20       	mov    QWORD PTR [rsp+0x20],rbp
  211338:	48 c7 44 24 28 01 00 	mov    QWORD PTR [rsp+0x28],0x1
  21133f:	00 00 
  211341:	4c 89 f6             	mov    rsi,r14
  211344:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  211346:	31 c0                	xor    eax,eax
  211348:	86 05 c2 ec 03 00    	xchg   BYTE PTR [rip+0x3ecc2],al        # 250010 <stderr_mutex>
  21134e:	3c 01                	cmp    al,0x1
    if (!ok) {
  211350:	0f 85 76 05 00 00    	jne    2118cc <BmAdd.volatile+0xddc>
  211356:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  21135d:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  211360:	b0 01                	mov    al,0x1
  211362:	86 05 a8 ec 03 00    	xchg   BYTE PTR [rip+0x3eca8],al        # 250010 <stderr_mutex>
  211368:	84 c0                	test   al,al
  21136a:	75 f4                	jne    211360 <BmAdd.volatile+0x870>
    if (stderr_stream) |st| {
  21136c:	48 8b 3d 95 ec 03 00 	mov    rdi,QWORD PTR [rip+0x3ec95]        # 250008 <stderr_stream>
  211373:	48 85 ff             	test   rdi,rdi
  211376:	74 09                	je     211381 <BmAdd.volatile+0x891>
  211378:	48 8b 0d c1 9c 03 00 	mov    rcx,QWORD PTR [rip+0x39cc1]        # 24b040 <stderr_file_out_stream+0x8>
  21137f:	eb 3d                	jmp    2113be <BmAdd.volatile+0x8ce>
        stderr_file = try io.getStdErr();
  211381:	c7 05 a5 9c 03 00 02 	mov    DWORD PTR [rip+0x39ca5],0x2        # 24b030 <stderr_file>
  211388:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  21138b:	48 8d 05 9e 9c 03 00 	lea    rax,[rip+0x39c9e]        # 24b030 <stderr_file>
  211392:	48 89 05 9f 9c 03 00 	mov    QWORD PTR [rip+0x39c9f],rax        # 24b038 <stderr_file_out_stream>
  211399:	48 8d 05 40 e6 00 00 	lea    rax,[rip+0xe640]        # 21f9e0 <FileOutStream_writeFn>
  2113a0:	48 89 05 99 9c 03 00 	mov    QWORD PTR [rip+0x39c99],rax        # 24b040 <stderr_file_out_stream+0x8>
  2113a7:	48 8d 0d 92 9c 03 00 	lea    rcx,[rip+0x39c92]        # 24b040 <stderr_file_out_stream+0x8>
  2113ae:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  2113b1:	48 89 15 50 ec 03 00 	mov    QWORD PTR [rip+0x3ec50],rdx        # 250008 <stderr_stream>
  2113b8:	48 89 c1             	mov    rcx,rax
  2113bb:	48 89 d7             	mov    rdi,rdx
  2113be:	c6 44 24 07 20       	mov    BYTE PTR [rsp+0x7],0x20
  2113c3:	48 89 6c 24 20       	mov    QWORD PTR [rsp+0x20],rbp
  2113c8:	48 c7 44 24 28 01 00 	mov    QWORD PTR [rsp+0x28],0x1
  2113cf:	00 00 
  2113d1:	4c 89 f6             	mov    rsi,r14
  2113d4:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  2113d6:	31 c0                	xor    eax,eax
  2113d8:	86 05 32 ec 03 00    	xchg   BYTE PTR [rip+0x3ec32],al        # 250010 <stderr_mutex>
  2113de:	3c 01                	cmp    al,0x1
    if (!ok) {
  2113e0:	0f 85 e6 04 00 00    	jne    2118cc <BmAdd.volatile+0xddc>
  2113e6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  2113ed:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  2113f0:	b0 01                	mov    al,0x1
  2113f2:	86 05 18 ec 03 00    	xchg   BYTE PTR [rip+0x3ec18],al        # 250010 <stderr_mutex>
  2113f8:	84 c0                	test   al,al
  2113fa:	75 f4                	jne    2113f0 <BmAdd.volatile+0x900>
    if (stderr_stream) |st| {
  2113fc:	48 8b 3d 05 ec 03 00 	mov    rdi,QWORD PTR [rip+0x3ec05]        # 250008 <stderr_stream>
  211403:	48 85 ff             	test   rdi,rdi
  211406:	74 09                	je     211411 <BmAdd.volatile+0x921>
  211408:	48 8b 0d 31 9c 03 00 	mov    rcx,QWORD PTR [rip+0x39c31]        # 24b040 <stderr_file_out_stream+0x8>
  21140f:	eb 3d                	jmp    21144e <BmAdd.volatile+0x95e>
        stderr_file = try io.getStdErr();
  211411:	c7 05 15 9c 03 00 02 	mov    DWORD PTR [rip+0x39c15],0x2        # 24b030 <stderr_file>
  211418:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  21141b:	48 8d 05 0e 9c 03 00 	lea    rax,[rip+0x39c0e]        # 24b030 <stderr_file>
  211422:	48 89 05 0f 9c 03 00 	mov    QWORD PTR [rip+0x39c0f],rax        # 24b038 <stderr_file_out_stream>
  211429:	48 8d 05 b0 e5 00 00 	lea    rax,[rip+0xe5b0]        # 21f9e0 <FileOutStream_writeFn>
  211430:	48 89 05 09 9c 03 00 	mov    QWORD PTR [rip+0x39c09],rax        # 24b040 <stderr_file_out_stream+0x8>
  211437:	48 8d 0d 02 9c 03 00 	lea    rcx,[rip+0x39c02]        # 24b040 <stderr_file_out_stream+0x8>
  21143e:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  211441:	48 89 15 c0 eb 03 00 	mov    QWORD PTR [rip+0x3ebc0],rdx        # 250008 <stderr_stream>
  211448:	48 89 c1             	mov    rcx,rax
  21144b:	48 89 d7             	mov    rdi,rdx
  21144e:	c6 44 24 07 20       	mov    BYTE PTR [rsp+0x7],0x20
  211453:	48 89 6c 24 20       	mov    QWORD PTR [rsp+0x20],rbp
  211458:	48 c7 44 24 28 01 00 	mov    QWORD PTR [rsp+0x28],0x1
  21145f:	00 00 
  211461:	4c 89 f6             	mov    rsi,r14
  211464:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  211466:	31 c0                	xor    eax,eax
  211468:	86 05 a2 eb 03 00    	xchg   BYTE PTR [rip+0x3eba2],al        # 250010 <stderr_mutex>
  21146e:	3c 01                	cmp    al,0x1
    if (!ok) {
  211470:	0f 85 56 04 00 00    	jne    2118cc <BmAdd.volatile+0xddc>
  211476:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  21147d:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  211480:	b0 01                	mov    al,0x1
  211482:	86 05 88 eb 03 00    	xchg   BYTE PTR [rip+0x3eb88],al        # 250010 <stderr_mutex>
  211488:	84 c0                	test   al,al
  21148a:	75 f4                	jne    211480 <BmAdd.volatile+0x990>
    if (stderr_stream) |st| {
  21148c:	48 8b 3d 75 eb 03 00 	mov    rdi,QWORD PTR [rip+0x3eb75]        # 250008 <stderr_stream>
  211493:	48 85 ff             	test   rdi,rdi
  211496:	74 09                	je     2114a1 <BmAdd.volatile+0x9b1>
  211498:	48 8b 0d a1 9b 03 00 	mov    rcx,QWORD PTR [rip+0x39ba1]        # 24b040 <stderr_file_out_stream+0x8>
  21149f:	eb 3d                	jmp    2114de <BmAdd.volatile+0x9ee>
        stderr_file = try io.getStdErr();
  2114a1:	c7 05 85 9b 03 00 02 	mov    DWORD PTR [rip+0x39b85],0x2        # 24b030 <stderr_file>
  2114a8:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  2114ab:	48 8d 05 7e 9b 03 00 	lea    rax,[rip+0x39b7e]        # 24b030 <stderr_file>
  2114b2:	48 89 05 7f 9b 03 00 	mov    QWORD PTR [rip+0x39b7f],rax        # 24b038 <stderr_file_out_stream>
  2114b9:	48 8d 05 20 e5 00 00 	lea    rax,[rip+0xe520]        # 21f9e0 <FileOutStream_writeFn>
  2114c0:	48 89 05 79 9b 03 00 	mov    QWORD PTR [rip+0x39b79],rax        # 24b040 <stderr_file_out_stream+0x8>
  2114c7:	48 8d 0d 72 9b 03 00 	lea    rcx,[rip+0x39b72]        # 24b040 <stderr_file_out_stream+0x8>
  2114ce:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  2114d1:	48 89 15 30 eb 03 00 	mov    QWORD PTR [rip+0x3eb30],rdx        # 250008 <stderr_stream>
  2114d8:	48 89 c1             	mov    rcx,rax
  2114db:	48 89 d7             	mov    rdi,rdx
  2114de:	c6 44 24 07 20       	mov    BYTE PTR [rsp+0x7],0x20
  2114e3:	48 89 6c 24 20       	mov    QWORD PTR [rsp+0x20],rbp
  2114e8:	48 c7 44 24 28 01 00 	mov    QWORD PTR [rsp+0x28],0x1
  2114ef:	00 00 
  2114f1:	4c 89 f6             	mov    rsi,r14
  2114f4:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  2114f6:	31 c0                	xor    eax,eax
  2114f8:	86 05 12 eb 03 00    	xchg   BYTE PTR [rip+0x3eb12],al        # 250010 <stderr_mutex>
  2114fe:	3c 01                	cmp    al,0x1
    if (!ok) {
  211500:	0f 85 c6 03 00 00    	jne    2118cc <BmAdd.volatile+0xddc>
  211506:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  21150d:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  211510:	b0 01                	mov    al,0x1
  211512:	86 05 f8 ea 03 00    	xchg   BYTE PTR [rip+0x3eaf8],al        # 250010 <stderr_mutex>
  211518:	84 c0                	test   al,al
  21151a:	75 f4                	jne    211510 <BmAdd.volatile+0xa20>
    if (stderr_stream) |st| {
  21151c:	48 8b 3d e5 ea 03 00 	mov    rdi,QWORD PTR [rip+0x3eae5]        # 250008 <stderr_stream>
  211523:	48 85 ff             	test   rdi,rdi
  211526:	74 09                	je     211531 <BmAdd.volatile+0xa41>
  211528:	48 8b 0d 11 9b 03 00 	mov    rcx,QWORD PTR [rip+0x39b11]        # 24b040 <stderr_file_out_stream+0x8>
  21152f:	eb 3d                	jmp    21156e <BmAdd.volatile+0xa7e>
        stderr_file = try io.getStdErr();
  211531:	c7 05 f5 9a 03 00 02 	mov    DWORD PTR [rip+0x39af5],0x2        # 24b030 <stderr_file>
  211538:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  21153b:	48 8d 05 ee 9a 03 00 	lea    rax,[rip+0x39aee]        # 24b030 <stderr_file>
  211542:	48 89 05 ef 9a 03 00 	mov    QWORD PTR [rip+0x39aef],rax        # 24b038 <stderr_file_out_stream>
  211549:	48 8d 05 90 e4 00 00 	lea    rax,[rip+0xe490]        # 21f9e0 <FileOutStream_writeFn>
  211550:	48 89 05 e9 9a 03 00 	mov    QWORD PTR [rip+0x39ae9],rax        # 24b040 <stderr_file_out_stream+0x8>
  211557:	48 8d 0d e2 9a 03 00 	lea    rcx,[rip+0x39ae2]        # 24b040 <stderr_file_out_stream+0x8>
  21155e:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  211561:	48 89 15 a0 ea 03 00 	mov    QWORD PTR [rip+0x3eaa0],rdx        # 250008 <stderr_stream>
  211568:	48 89 c1             	mov    rcx,rax
  21156b:	48 89 d7             	mov    rdi,rdx
  21156e:	c6 44 24 07 20       	mov    BYTE PTR [rsp+0x7],0x20
  211573:	48 89 6c 24 20       	mov    QWORD PTR [rsp+0x20],rbp
  211578:	48 c7 44 24 28 01 00 	mov    QWORD PTR [rsp+0x28],0x1
  21157f:	00 00 
  211581:	4c 89 f6             	mov    rsi,r14
  211584:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  211586:	31 c0                	xor    eax,eax
  211588:	86 05 82 ea 03 00    	xchg   BYTE PTR [rip+0x3ea82],al        # 250010 <stderr_mutex>
  21158e:	3c 01                	cmp    al,0x1
    if (!ok) {
  211590:	0f 85 36 03 00 00    	jne    2118cc <BmAdd.volatile+0xddc>
  211596:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  21159d:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  2115a0:	b0 01                	mov    al,0x1
  2115a2:	86 05 68 ea 03 00    	xchg   BYTE PTR [rip+0x3ea68],al        # 250010 <stderr_mutex>
  2115a8:	84 c0                	test   al,al
  2115aa:	75 f4                	jne    2115a0 <BmAdd.volatile+0xab0>
    if (stderr_stream) |st| {
  2115ac:	48 8b 3d 55 ea 03 00 	mov    rdi,QWORD PTR [rip+0x3ea55]        # 250008 <stderr_stream>
  2115b3:	48 85 ff             	test   rdi,rdi
  2115b6:	74 09                	je     2115c1 <BmAdd.volatile+0xad1>
  2115b8:	48 8b 0d 81 9a 03 00 	mov    rcx,QWORD PTR [rip+0x39a81]        # 24b040 <stderr_file_out_stream+0x8>
  2115bf:	eb 3d                	jmp    2115fe <BmAdd.volatile+0xb0e>
        stderr_file = try io.getStdErr();
  2115c1:	c7 05 65 9a 03 00 02 	mov    DWORD PTR [rip+0x39a65],0x2        # 24b030 <stderr_file>
  2115c8:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  2115cb:	48 8d 05 5e 9a 03 00 	lea    rax,[rip+0x39a5e]        # 24b030 <stderr_file>
  2115d2:	48 89 05 5f 9a 03 00 	mov    QWORD PTR [rip+0x39a5f],rax        # 24b038 <stderr_file_out_stream>
  2115d9:	48 8d 05 00 e4 00 00 	lea    rax,[rip+0xe400]        # 21f9e0 <FileOutStream_writeFn>
  2115e0:	48 89 05 59 9a 03 00 	mov    QWORD PTR [rip+0x39a59],rax        # 24b040 <stderr_file_out_stream+0x8>
  2115e7:	48 8d 0d 52 9a 03 00 	lea    rcx,[rip+0x39a52]        # 24b040 <stderr_file_out_stream+0x8>
  2115ee:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  2115f1:	48 89 15 10 ea 03 00 	mov    QWORD PTR [rip+0x3ea10],rdx        # 250008 <stderr_stream>
  2115f8:	48 89 c1             	mov    rcx,rax
  2115fb:	48 89 d7             	mov    rdi,rdx
  2115fe:	c6 44 24 07 20       	mov    BYTE PTR [rsp+0x7],0x20
  211603:	48 89 6c 24 20       	mov    QWORD PTR [rsp+0x20],rbp
  211608:	48 c7 44 24 28 01 00 	mov    QWORD PTR [rsp+0x28],0x1
  21160f:	00 00 
  211611:	4c 89 f6             	mov    rsi,r14
  211614:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  211616:	31 c0                	xor    eax,eax
  211618:	86 05 f2 e9 03 00    	xchg   BYTE PTR [rip+0x3e9f2],al        # 250010 <stderr_mutex>
  21161e:	3c 01                	cmp    al,0x1
    if (!ok) {
  211620:	0f 85 a6 02 00 00    	jne    2118cc <BmAdd.volatile+0xddc>
  211626:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  21162d:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  211630:	b0 01                	mov    al,0x1
  211632:	86 05 d8 e9 03 00    	xchg   BYTE PTR [rip+0x3e9d8],al        # 250010 <stderr_mutex>
  211638:	84 c0                	test   al,al
  21163a:	75 f4                	jne    211630 <BmAdd.volatile+0xb40>
    if (stderr_stream) |st| {
  21163c:	48 8b 3d c5 e9 03 00 	mov    rdi,QWORD PTR [rip+0x3e9c5]        # 250008 <stderr_stream>
  211643:	48 85 ff             	test   rdi,rdi
  211646:	74 09                	je     211651 <BmAdd.volatile+0xb61>
  211648:	48 8b 0d f1 99 03 00 	mov    rcx,QWORD PTR [rip+0x399f1]        # 24b040 <stderr_file_out_stream+0x8>
  21164f:	eb 3d                	jmp    21168e <BmAdd.volatile+0xb9e>
        stderr_file = try io.getStdErr();
  211651:	c7 05 d5 99 03 00 02 	mov    DWORD PTR [rip+0x399d5],0x2        # 24b030 <stderr_file>
  211658:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  21165b:	48 8d 05 ce 99 03 00 	lea    rax,[rip+0x399ce]        # 24b030 <stderr_file>
  211662:	48 89 05 cf 99 03 00 	mov    QWORD PTR [rip+0x399cf],rax        # 24b038 <stderr_file_out_stream>
  211669:	48 8d 05 70 e3 00 00 	lea    rax,[rip+0xe370]        # 21f9e0 <FileOutStream_writeFn>
  211670:	48 89 05 c9 99 03 00 	mov    QWORD PTR [rip+0x399c9],rax        # 24b040 <stderr_file_out_stream+0x8>
  211677:	48 8d 0d c2 99 03 00 	lea    rcx,[rip+0x399c2]        # 24b040 <stderr_file_out_stream+0x8>
  21167e:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  211681:	48 89 15 80 e9 03 00 	mov    QWORD PTR [rip+0x3e980],rdx        # 250008 <stderr_stream>
  211688:	48 89 c1             	mov    rcx,rax
  21168b:	48 89 d7             	mov    rdi,rdx
  21168e:	c6 44 24 07 20       	mov    BYTE PTR [rsp+0x7],0x20
  211693:	48 89 6c 24 20       	mov    QWORD PTR [rsp+0x20],rbp
  211698:	48 c7 44 24 28 01 00 	mov    QWORD PTR [rsp+0x28],0x1
  21169f:	00 00 
  2116a1:	4c 89 f6             	mov    rsi,r14
  2116a4:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  2116a6:	31 c0                	xor    eax,eax
  2116a8:	86 05 62 e9 03 00    	xchg   BYTE PTR [rip+0x3e962],al        # 250010 <stderr_mutex>
  2116ae:	3c 01                	cmp    al,0x1
    if (!ok) {
  2116b0:	0f 85 16 02 00 00    	jne    2118cc <BmAdd.volatile+0xddc>
  2116b6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  2116bd:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  2116c0:	b0 01                	mov    al,0x1
  2116c2:	86 05 48 e9 03 00    	xchg   BYTE PTR [rip+0x3e948],al        # 250010 <stderr_mutex>
  2116c8:	84 c0                	test   al,al
  2116ca:	75 f4                	jne    2116c0 <BmAdd.volatile+0xbd0>
    if (stderr_stream) |st| {
  2116cc:	48 8b 3d 35 e9 03 00 	mov    rdi,QWORD PTR [rip+0x3e935]        # 250008 <stderr_stream>
  2116d3:	48 85 ff             	test   rdi,rdi
  2116d6:	74 09                	je     2116e1 <BmAdd.volatile+0xbf1>
  2116d8:	48 8b 0d 61 99 03 00 	mov    rcx,QWORD PTR [rip+0x39961]        # 24b040 <stderr_file_out_stream+0x8>
  2116df:	eb 3d                	jmp    21171e <BmAdd.volatile+0xc2e>
        stderr_file = try io.getStdErr();
  2116e1:	c7 05 45 99 03 00 02 	mov    DWORD PTR [rip+0x39945],0x2        # 24b030 <stderr_file>
  2116e8:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  2116eb:	48 8d 05 3e 99 03 00 	lea    rax,[rip+0x3993e]        # 24b030 <stderr_file>
  2116f2:	48 89 05 3f 99 03 00 	mov    QWORD PTR [rip+0x3993f],rax        # 24b038 <stderr_file_out_stream>
  2116f9:	48 8d 05 e0 e2 00 00 	lea    rax,[rip+0xe2e0]        # 21f9e0 <FileOutStream_writeFn>
  211700:	48 89 05 39 99 03 00 	mov    QWORD PTR [rip+0x39939],rax        # 24b040 <stderr_file_out_stream+0x8>
  211707:	48 8d 0d 32 99 03 00 	lea    rcx,[rip+0x39932]        # 24b040 <stderr_file_out_stream+0x8>
  21170e:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  211711:	48 89 15 f0 e8 03 00 	mov    QWORD PTR [rip+0x3e8f0],rdx        # 250008 <stderr_stream>
  211718:	48 89 c1             	mov    rcx,rax
  21171b:	48 89 d7             	mov    rdi,rdx
                const casted_value = ([]const u8)(value);
  21171e:	4c 89 7c 24 20       	mov    QWORD PTR [rsp+0x20],r15
  211723:	48 c7 44 24 28 04 00 	mov    QWORD PTR [rsp+0x28],0x4
  21172a:	00 00 
                return output(context, casted_value);
  21172c:	4c 89 f6             	mov    rsi,r14
  21172f:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  211731:	31 c0                	xor    eax,eax
  211733:	86 05 d7 e8 03 00    	xchg   BYTE PTR [rip+0x3e8d7],al        # 250010 <stderr_mutex>
  211739:	3c 01                	cmp    al,0x1
    if (!ok) {
  21173b:	0f 85 8b 01 00 00    	jne    2118cc <BmAdd.volatile+0xddc>
                try rightJustified(18, "{}", "time/operation");
  211741:	e8 1a 4d 00 00       	call   216460 <Benchmark_rightJustified.38>
  211746:	66 85 c0             	test   ax,ax
  211749:	0f 85 65 01 00 00    	jne    2118b4 <BmAdd.volatile+0xdc4>
  21174f:	90                   	nop
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  211750:	b0 01                	mov    al,0x1
  211752:	86 05 b8 e8 03 00    	xchg   BYTE PTR [rip+0x3e8b8],al        # 250010 <stderr_mutex>
  211758:	84 c0                	test   al,al
  21175a:	75 f4                	jne    211750 <BmAdd.volatile+0xc60>
    if (stderr_stream) |st| {
  21175c:	48 8b 3d a5 e8 03 00 	mov    rdi,QWORD PTR [rip+0x3e8a5]        # 250008 <stderr_stream>
  211763:	48 85 ff             	test   rdi,rdi
  211766:	74 09                	je     211771 <BmAdd.volatile+0xc81>
  211768:	48 8b 0d d1 98 03 00 	mov    rcx,QWORD PTR [rip+0x398d1]        # 24b040 <stderr_file_out_stream+0x8>
  21176f:	eb 3d                	jmp    2117ae <BmAdd.volatile+0xcbe>
        stderr_file = try io.getStdErr();
  211771:	c7 05 b5 98 03 00 02 	mov    DWORD PTR [rip+0x398b5],0x2        # 24b030 <stderr_file>
  211778:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  21177b:	48 8d 05 ae 98 03 00 	lea    rax,[rip+0x398ae]        # 24b030 <stderr_file>
  211782:	48 89 05 af 98 03 00 	mov    QWORD PTR [rip+0x398af],rax        # 24b038 <stderr_file_out_stream>
  211789:	48 8d 05 50 e2 00 00 	lea    rax,[rip+0xe250]        # 21f9e0 <FileOutStream_writeFn>
  211790:	48 89 05 a9 98 03 00 	mov    QWORD PTR [rip+0x398a9],rax        # 24b040 <stderr_file_out_stream+0x8>
  211797:	48 8d 0d a2 98 03 00 	lea    rcx,[rip+0x398a2]        # 24b040 <stderr_file_out_stream+0x8>
  21179e:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  2117a1:	48 89 15 60 e8 03 00 	mov    QWORD PTR [rip+0x3e860],rdx        # 250008 <stderr_stream>
  2117a8:	48 89 c1             	mov    rcx,rax
  2117ab:	48 89 d7             	mov    rdi,rdx
        try output(context, fmt[start_index..]);
  2117ae:	48 8d 35 63 d6 03 00 	lea    rsi,[rip+0x3d663]        # 24ee18 <__unnamed_3>
  2117b5:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  2117b7:	31 c0                	xor    eax,eax
  2117b9:	86 05 51 e8 03 00    	xchg   BYTE PTR [rip+0x3e851],al        # 250010 <stderr_mutex>
  2117bf:	3c 01                	cmp    al,0x1
    if (!ok) {
  2117c1:	0f 85 05 01 00 00    	jne    2118cc <BmAdd.volatile+0xddc>
            try pSelf.report(pSelf.results.items[pSelf.results.len - 1]); warn("\n");
  2117c7:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  2117ce:	00 
  2117cf:	48 8b 8c 24 b8 00 00 	mov    rcx,QWORD PTR [rsp+0xb8]
  2117d6:	00 
  2117d7:	48 c1 e1 04          	shl    rcx,0x4
  2117db:	48 8d 34 08          	lea    rsi,[rax+rcx*1]
  2117df:	48 83 c6 f0          	add    rsi,0xfffffffffffffff0
  2117e3:	48 8d 7c 24 60       	lea    rdi,[rsp+0x60]
  2117e8:	e8 73 22 00 00       	call   213a60 <Benchmark_report>
  2117ed:	66 85 c0             	test   ax,ax
  2117f0:	0f 85 be 00 00 00    	jne    2118b4 <BmAdd.volatile+0xdc4>
  2117f6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  2117fd:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  211800:	b0 01                	mov    al,0x1
  211802:	86 05 08 e8 03 00    	xchg   BYTE PTR [rip+0x3e808],al        # 250010 <stderr_mutex>
  211808:	84 c0                	test   al,al
  21180a:	75 f4                	jne    211800 <BmAdd.volatile+0xd10>
    if (stderr_stream) |st| {
  21180c:	48 8b 3d f5 e7 03 00 	mov    rdi,QWORD PTR [rip+0x3e7f5]        # 250008 <stderr_stream>
  211813:	48 85 ff             	test   rdi,rdi
  211816:	74 09                	je     211821 <BmAdd.volatile+0xd31>
  211818:	48 8b 0d 21 98 03 00 	mov    rcx,QWORD PTR [rip+0x39821]        # 24b040 <stderr_file_out_stream+0x8>
  21181f:	eb 3d                	jmp    21185e <BmAdd.volatile+0xd6e>
        stderr_file = try io.getStdErr();
  211821:	c7 05 05 98 03 00 02 	mov    DWORD PTR [rip+0x39805],0x2        # 24b030 <stderr_file>
  211828:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  21182b:	48 8d 05 fe 97 03 00 	lea    rax,[rip+0x397fe]        # 24b030 <stderr_file>
  211832:	48 89 05 ff 97 03 00 	mov    QWORD PTR [rip+0x397ff],rax        # 24b038 <stderr_file_out_stream>
  211839:	48 8d 05 a0 e1 00 00 	lea    rax,[rip+0xe1a0]        # 21f9e0 <FileOutStream_writeFn>
  211840:	48 89 05 f9 97 03 00 	mov    QWORD PTR [rip+0x397f9],rax        # 24b040 <stderr_file_out_stream+0x8>
  211847:	48 8d 0d f2 97 03 00 	lea    rcx,[rip+0x397f2]        # 24b040 <stderr_file_out_stream+0x8>
  21184e:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  211851:	48 89 15 b0 e7 03 00 	mov    QWORD PTR [rip+0x3e7b0],rdx        # 250008 <stderr_stream>
  211858:	48 89 c1             	mov    rcx,rax
  21185b:	48 89 d7             	mov    rdi,rdx
  21185e:	48 8d 35 b3 d5 03 00 	lea    rsi,[rip+0x3d5b3]        # 24ee18 <__unnamed_3>
  211865:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  211867:	31 c0                	xor    eax,eax
  211869:	86 05 a1 e7 03 00    	xchg   BYTE PTR [rip+0x3e7a1],al        # 250010 <stderr_mutex>
  21186f:	3c 01                	cmp    al,0x1
    if (!ok) {
  211871:	75 59                	jne    2118cc <BmAdd.volatile+0xddc>
  211873:	49 83 c5 01          	add    r13,0x1
  211877:	45 31 f6             	xor    r14d,r14d
        while (rep < pSelf.repetitions) : (rep += 1) {
  21187a:	4c 3b ac 24 80 00 00 	cmp    r13,QWORD PTR [rsp+0x80]
  211881:	00 
  211882:	c5 f8 10 0d 36 75 ff 	vmovups xmm1,XMMWORD PTR [rip+0xffffffffffff7536]        # 208dc0 <__unnamed_5>
  211889:	ff 
  21188a:	0f 82 8b f3 ff ff    	jb     210c1b <BmAdd.volatile+0x12b>
  211890:	48 8d 7c 24 60       	lea    rdi,[rsp+0x60]
        try pSelf.reportStats(pSelf.results);
  211895:	48 8d b4 24 a8 00 00 	lea    rsi,[rsp+0xa8]
  21189c:	00 
  21189d:	e8 9e 4e 00 00       	call   216740 <Benchmark_reportStats>
  2118a2:	eb 10                	jmp    2118b4 <BmAdd.volatile+0xdc4>
                switch (errno) {
  2118a4:	48 83 f9 16          	cmp    rcx,0x16
  2118a8:	75 06                	jne    2118b0 <BmAdd.volatile+0xdc0>
  2118aa:	66 b8 02 00          	mov    ax,0x2
  2118ae:	eb 04                	jmp    2118b4 <BmAdd.volatile+0xdc4>
  2118b0:	66 b8 03 00          	mov    ax,0x3
    _ = try bm.run(BmAdd);
  2118b4:	48 81 c4 08 01 00 00 	add    rsp,0x108
  2118bb:	5b                   	pop    rbx
  2118bc:	41 5c                	pop    r12
  2118be:	41 5d                	pop    r13
  2118c0:	41 5e                	pop    r14
  2118c2:	41 5f                	pop    r15
  2118c4:	5d                   	pop    rbp
  2118c5:	c3                   	ret    
  2118c6:	66 b8 06 00          	mov    ax,0x6
  2118ca:	eb e8                	jmp    2118b4 <BmAdd.volatile+0xdc4>
            @panic("assertion failure");
  2118cc:	48 8d 3d 35 d4 03 00 	lea    rdi,[rip+0x3d435]        # 24ed08 <__unnamed_2>
  2118d3:	e8 48 07 00 00       	call   212020 <panic>
  2118d8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  2118df:	00 

00000000002118e0 <BmNoSelf.error>:
}

test "BmNoSelf.error" {
  2118e0:	48 83 ec 18          	sub    rsp,0x18
  2118e4:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  2118eb:	00 00 00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  2118f0:	b0 01                	mov    al,0x1
  2118f2:	86 05 18 e7 03 00    	xchg   BYTE PTR [rip+0x3e718],al        # 250010 <stderr_mutex>
  2118f8:	84 c0                	test   al,al
  2118fa:	75 f4                	jne    2118f0 <BmNoSelf.error+0x10>
    if (stderr_stream) |st| {
  2118fc:	48 8b 3d 05 e7 03 00 	mov    rdi,QWORD PTR [rip+0x3e705]        # 250008 <stderr_stream>
  211903:	48 85 ff             	test   rdi,rdi
  211906:	74 09                	je     211911 <BmNoSelf.error+0x31>
  211908:	48 8b 05 31 97 03 00 	mov    rax,QWORD PTR [rip+0x39731]        # 24b040 <stderr_file_out_stream+0x8>
  21190f:	eb 34                	jmp    211945 <BmNoSelf.error+0x65>
        stderr_file = try io.getStdErr();
  211911:	48 8d 05 18 97 03 00 	lea    rax,[rip+0x39718]        # 24b030 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  211918:	48 89 05 19 97 03 00 	mov    QWORD PTR [rip+0x39719],rax        # 24b038 <stderr_file_out_stream>
  21191f:	48 8d 05 ba e0 00 00 	lea    rax,[rip+0xe0ba]        # 21f9e0 <FileOutStream_writeFn>
  211926:	48 89 05 13 97 03 00 	mov    QWORD PTR [rip+0x39713],rax        # 24b040 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  21192d:	c7 05 f9 96 03 00 02 	mov    DWORD PTR [rip+0x396f9],0x2        # 24b030 <stderr_file>
  211934:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  211937:	48 8d 3d 02 97 03 00 	lea    rdi,[rip+0x39702]        # 24b040 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  21193e:	48 89 3d c3 e6 03 00 	mov    QWORD PTR [rip+0x3e6c3],rdi        # 250008 <stderr_stream>
  211945:	48 8d 35 cc d4 03 00 	lea    rsi,[rip+0x3d4cc]        # 24ee18 <__unnamed_3>
  21194c:	ff d0                	call   rax
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  21194e:	31 c0                	xor    eax,eax
  211950:	86 05 ba e6 03 00    	xchg   BYTE PTR [rip+0x3e6ba],al        # 250010 <stderr_mutex>
  211956:	3c 01                	cmp    al,0x1
    if (!ok) {
  211958:	75 76                	jne    2119d0 <BmNoSelf.error+0xf0>
                var ts: posix.timespec = undefined;
  21195a:	c5 f8 10 05 5e 74 ff 	vmovups xmm0,XMMWORD PTR [rip+0xffffffffffff745e]        # 208dc0 <__unnamed_5>
  211961:	ff 
  211962:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
  211967:	48 89 e6             	mov    rsi,rsp
  21196a:	b8 e5 00 00 00       	mov    eax,0xe5
  21196f:	bf 01 00 00 00       	mov    edi,0x1
  211974:	0f 05                	syscall 
  211976:	48 89 c2             	mov    rdx,rax
  211979:	48 f7 da             	neg    rdx
  21197c:	31 c9                	xor    ecx,ecx
  21197e:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  211984:	48 0f 47 ca          	cmova  rcx,rdx
                switch (errno) {
  211988:	48 85 c9             	test   rcx,rcx
  21198b:	75 3f                	jne    2119cc <BmNoSelf.error+0xec>
        const f = @atomicLoad(@typeOf(init_vdso_clock_gettime), &vdso_clock_gettime, builtin.AtomicOrder.Unordered);
  21198d:	48 8b 05 b4 96 03 00 	mov    rax,QWORD PTR [rip+0x396b4]        # 24b048 <vdso_clock_gettime>
        if (@ptrToInt(f) != 0) {
  211994:	48 85 c0             	test   rax,rax
  211997:	74 15                	je     2119ae <BmNoSelf.error+0xce>
  211999:	48 89 e6             	mov    rsi,rsp
            const rc = f(clk_id, tp);
  21199c:	bf 01 00 00 00       	mov    edi,0x1
  2119a1:	ff d0                	call   rax
            switch (rc) {
  2119a3:	48 83 f8 ea          	cmp    rax,0xffffffffffffffea
  2119a7:	74 14                	je     2119bd <BmNoSelf.error+0xdd>
  2119a9:	48 85 c0             	test   rax,rax
  2119ac:	74 0f                	je     2119bd <BmNoSelf.error+0xdd>
  2119ae:	48 89 e6             	mov    rsi,rsp
  2119b1:	b8 e4 00 00 00       	mov    eax,0xe4
  2119b6:	bf 01 00 00 00       	mov    edi,0x1
  2119bb:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  2119bd:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
}

/// TODO: add `==` operator for `error_union == error_set`, and then
/// remove this function
pub fn assertError(value: var, expected_error: error) void {
    if (value) {
  2119c3:	73 0b                	jae    2119d0 <BmNoSelf.error+0xf0>
  2119c5:	31 c0                	xor    eax,eax
  2119c7:	48 83 c4 18          	add    rsp,0x18
  2119cb:	c3                   	ret    
  2119cc:	48 83 f9 16          	cmp    rcx,0x16
            @panic("assertion failure");
  2119d0:	48 8d 3d 31 d3 03 00 	lea    rdi,[rip+0x3d331]        # 24ed08 <__unnamed_2>
  2119d7:	e8 44 06 00 00       	call   212020 <panic>
  2119dc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

00000000002119e0 <BmSelf.init_error.setup.tearDown>:
            return error.TestError;
        }
    }), error.TestError);
}

test "BmSelf.init_error.setup.tearDown" {
  2119e0:	50                   	push   rax
  2119e1:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  2119e8:	0f 1f 84 00 00 00 00 
  2119ef:	00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  2119f0:	b0 01                	mov    al,0x1
  2119f2:	86 05 18 e6 03 00    	xchg   BYTE PTR [rip+0x3e618],al        # 250010 <stderr_mutex>
  2119f8:	84 c0                	test   al,al
  2119fa:	75 f4                	jne    2119f0 <BmSelf.init_error.setup.tearDown+0x10>
    if (stderr_stream) |st| {
  2119fc:	48 8b 3d 05 e6 03 00 	mov    rdi,QWORD PTR [rip+0x3e605]        # 250008 <stderr_stream>
  211a03:	48 85 ff             	test   rdi,rdi
  211a06:	74 09                	je     211a11 <BmSelf.init_error.setup.tearDown+0x31>
  211a08:	48 8b 05 31 96 03 00 	mov    rax,QWORD PTR [rip+0x39631]        # 24b040 <stderr_file_out_stream+0x8>
  211a0f:	eb 34                	jmp    211a45 <BmSelf.init_error.setup.tearDown+0x65>
        stderr_file = try io.getStdErr();
  211a11:	48 8d 05 18 96 03 00 	lea    rax,[rip+0x39618]        # 24b030 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  211a18:	48 89 05 19 96 03 00 	mov    QWORD PTR [rip+0x39619],rax        # 24b038 <stderr_file_out_stream>
  211a1f:	48 8d 05 ba df 00 00 	lea    rax,[rip+0xdfba]        # 21f9e0 <FileOutStream_writeFn>
  211a26:	48 89 05 13 96 03 00 	mov    QWORD PTR [rip+0x39613],rax        # 24b040 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  211a2d:	c7 05 f9 95 03 00 02 	mov    DWORD PTR [rip+0x395f9],0x2        # 24b030 <stderr_file>
  211a34:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  211a37:	48 8d 3d 02 96 03 00 	lea    rdi,[rip+0x39602]        # 24b040 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  211a3e:	48 89 3d c3 e5 03 00 	mov    QWORD PTR [rip+0x3e5c3],rdi        # 250008 <stderr_stream>
  211a45:	48 8d 35 cc d3 03 00 	lea    rsi,[rip+0x3d3cc]        # 24ee18 <__unnamed_3>
  211a4c:	ff d0                	call   rax
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  211a4e:	31 c0                	xor    eax,eax
  211a50:	86 05 ba e5 03 00    	xchg   BYTE PTR [rip+0x3e5ba],al        # 250010 <stderr_mutex>
  211a56:	3c 01                	cmp    al,0x1
    if (!ok) {
  211a58:	75 04                	jne    211a5e <BmSelf.init_error.setup.tearDown+0x7e>
  211a5a:	31 c0                	xor    eax,eax
  211a5c:	59                   	pop    rcx
  211a5d:	c3                   	ret    
            @panic("assertion failure");
  211a5e:	48 8d 3d a3 d2 03 00 	lea    rdi,[rip+0x3d2a3]        # 24ed08 <__unnamed_2>
  211a65:	e8 b6 05 00 00       	call   212020 <panic>
  211a6a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000211a70 <BmSelf.init.setup_error.tearDown>:
    };

    assertError(bm.run(BmSelf), error.InitError);
}

test "BmSelf.init.setup_error.tearDown" {
  211a70:	50                   	push   rax
  211a71:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  211a78:	0f 1f 84 00 00 00 00 
  211a7f:	00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  211a80:	b0 01                	mov    al,0x1
  211a82:	86 05 88 e5 03 00    	xchg   BYTE PTR [rip+0x3e588],al        # 250010 <stderr_mutex>
  211a88:	84 c0                	test   al,al
  211a8a:	75 f4                	jne    211a80 <BmSelf.init.setup_error.tearDown+0x10>
    if (stderr_stream) |st| {
  211a8c:	48 8b 3d 75 e5 03 00 	mov    rdi,QWORD PTR [rip+0x3e575]        # 250008 <stderr_stream>
  211a93:	48 85 ff             	test   rdi,rdi
  211a96:	74 09                	je     211aa1 <BmSelf.init.setup_error.tearDown+0x31>
  211a98:	48 8b 05 a1 95 03 00 	mov    rax,QWORD PTR [rip+0x395a1]        # 24b040 <stderr_file_out_stream+0x8>
  211a9f:	eb 34                	jmp    211ad5 <BmSelf.init.setup_error.tearDown+0x65>
        stderr_file = try io.getStdErr();
  211aa1:	48 8d 05 88 95 03 00 	lea    rax,[rip+0x39588]        # 24b030 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  211aa8:	48 89 05 89 95 03 00 	mov    QWORD PTR [rip+0x39589],rax        # 24b038 <stderr_file_out_stream>
  211aaf:	48 8d 05 2a df 00 00 	lea    rax,[rip+0xdf2a]        # 21f9e0 <FileOutStream_writeFn>
  211ab6:	48 89 05 83 95 03 00 	mov    QWORD PTR [rip+0x39583],rax        # 24b040 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  211abd:	c7 05 69 95 03 00 02 	mov    DWORD PTR [rip+0x39569],0x2        # 24b030 <stderr_file>
  211ac4:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  211ac7:	48 8d 3d 72 95 03 00 	lea    rdi,[rip+0x39572]        # 24b040 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  211ace:	48 89 3d 33 e5 03 00 	mov    QWORD PTR [rip+0x3e533],rdi        # 250008 <stderr_stream>
  211ad5:	48 8d 35 3c d3 03 00 	lea    rsi,[rip+0x3d33c]        # 24ee18 <__unnamed_3>
  211adc:	ff d0                	call   rax
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  211ade:	31 c0                	xor    eax,eax
  211ae0:	86 05 2a e5 03 00    	xchg   BYTE PTR [rip+0x3e52a],al        # 250010 <stderr_mutex>
  211ae6:	3c 01                	cmp    al,0x1
    if (!ok) {
  211ae8:	75 04                	jne    211aee <BmSelf.init.setup_error.tearDown+0x7e>
  211aea:	31 c0                	xor    eax,eax
  211aec:	59                   	pop    rcx
  211aed:	c3                   	ret    
            @panic("assertion failure");
  211aee:	48 8d 3d 13 d2 03 00 	lea    rdi,[rip+0x3d213]        # 24ed08 <__unnamed_2>
  211af5:	e8 26 05 00 00       	call   212020 <panic>
  211afa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000211b00 <BmSelf.init.setup.tearDown_error>:
    };

    assertError(bm.run(BmSelf), error.SetupError);
}

test "BmSelf.init.setup.tearDown_error" {
  211b00:	55                   	push   rbp
  211b01:	41 57                	push   r15
  211b03:	41 56                	push   r14
  211b05:	41 55                	push   r13
  211b07:	41 54                	push   r12
  211b09:	53                   	push   rbx
  211b0a:	48 81 ec a8 00 00 00 	sub    rsp,0xa8
  211b11:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  211b18:	0f 1f 84 00 00 00 00 
  211b1f:	00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  211b20:	b0 01                	mov    al,0x1
  211b22:	86 05 e8 e4 03 00    	xchg   BYTE PTR [rip+0x3e4e8],al        # 250010 <stderr_mutex>
  211b28:	84 c0                	test   al,al
  211b2a:	75 f4                	jne    211b20 <BmSelf.init.setup.tearDown_error+0x20>
    if (stderr_stream) |st| {
  211b2c:	48 8b 3d d5 e4 03 00 	mov    rdi,QWORD PTR [rip+0x3e4d5]        # 250008 <stderr_stream>
  211b33:	48 85 ff             	test   rdi,rdi
  211b36:	74 09                	je     211b41 <BmSelf.init.setup.tearDown_error+0x41>
  211b38:	48 8b 05 01 95 03 00 	mov    rax,QWORD PTR [rip+0x39501]        # 24b040 <stderr_file_out_stream+0x8>
  211b3f:	eb 34                	jmp    211b75 <BmSelf.init.setup.tearDown_error+0x75>
        stderr_file = try io.getStdErr();
  211b41:	48 8d 05 e8 94 03 00 	lea    rax,[rip+0x394e8]        # 24b030 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  211b48:	48 89 05 e9 94 03 00 	mov    QWORD PTR [rip+0x394e9],rax        # 24b038 <stderr_file_out_stream>
  211b4f:	48 8d 05 8a de 00 00 	lea    rax,[rip+0xde8a]        # 21f9e0 <FileOutStream_writeFn>
  211b56:	48 89 05 e3 94 03 00 	mov    QWORD PTR [rip+0x394e3],rax        # 24b040 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  211b5d:	c7 05 c9 94 03 00 02 	mov    DWORD PTR [rip+0x394c9],0x2        # 24b030 <stderr_file>
  211b64:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  211b67:	48 8d 3d d2 94 03 00 	lea    rdi,[rip+0x394d2]        # 24b040 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  211b6e:	48 89 3d 93 e4 03 00 	mov    QWORD PTR [rip+0x3e493],rdi        # 250008 <stderr_stream>
  211b75:	48 8d 35 9c d2 03 00 	lea    rsi,[rip+0x3d29c]        # 24ee18 <__unnamed_3>
  211b7c:	ff d0                	call   rax
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  211b7e:	31 c0                	xor    eax,eax
  211b80:	86 05 8a e4 03 00    	xchg   BYTE PTR [rip+0x3e48a],al        # 250010 <stderr_mutex>
  211b86:	3c 01                	cmp    al,0x1
    if (!ok) {
  211b88:	0f 85 81 03 00 00    	jne    211f0f <BmSelf.init.setup.tearDown_error+0x40f>
    // Since this is a test print a \n before we run
    warn("\n");

    // Test fn benchmark(pSelf) can return an error
    var bm = Benchmark.init("BmEmpty.error", std.debug.global_allocator);
  211b8e:	c5 f8 10 05 62 d1 03 	vmovups xmm0,XMMWORD PTR [rip+0x3d162]        # 24ecf8 <__unnamed_9>
  211b95:	00 
  211b96:	c5 f8 29 44 24 40    	vmovaps XMMWORD PTR [rsp+0x40],xmm0
  211b9c:	c5 fc 28 05 1c e6 fe 	vmovaps ymm0,YMMWORD PTR [rip+0xfffffffffffee61c]        # 2001c0 <__unnamed_44-0x40>
  211ba3:	ff 
  211ba4:	c5 fc 11 44 24 50    	vmovups YMMWORD PTR [rsp+0x50],ymm0
  211baa:	c5 fa 6f 05 0e 72 ff 	vmovdqu xmm0,XMMWORD PTR [rip+0xffffffffffff720e]        # 208dc0 <__unnamed_5>
  211bb1:	ff 
  211bb2:	c5 f9 7f 44 24 70    	vmovdqa XMMWORD PTR [rsp+0x70],xmm0
  211bb8:	48 8d 05 41 94 03 00 	lea    rax,[rip+0x39441]        # 24b000 <global_fixed_allocator>
  211bbf:	48 89 84 24 80 00 00 	mov    QWORD PTR [rsp+0x80],rax
  211bc6:	00 
  211bc7:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  211bcb:	c5 fa 7f 84 24 88 00 	vmovdqu XMMWORD PTR [rsp+0x88],xmm0
  211bd2:	00 00 
  211bd4:	48 c7 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],0x0
  211bdb:	00 00 00 00 00 
  211be0:	48 89 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rax
  211be7:	00 
  211be8:	49 be 00 e8 76 48 17 	movabs r14,0x174876e800
  211bef:	00 00 00 
  211bf2:	bb 01 00 00 00       	mov    ebx,0x1
  211bf7:	45 31 e4             	xor    r12d,r12d
  211bfa:	49 89 e7             	mov    r15,rsp
  211bfd:	45 31 ed             	xor    r13d,r13d
  211c00:	eb 1c                	jmp    211c1e <BmSelf.init.setup.tearDown_error+0x11e>
  211c02:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  211c09:	1f 84 00 00 00 00 00 
                        warn("iteratons:{} numer:{} denom:{}\n", iterations, numer, denom);
  211c10:	48 89 df             	mov    rdi,rbx
  211c13:	48 89 ca             	mov    rdx,rcx
  211c16:	c5 f8 77             	vzeroupper 
  211c19:	e8 52 3f 00 00       	call   215b70 <warn.36>
                var ts: posix.timespec = undefined;
  211c1e:	c5 fa 6f 05 9a 71 ff 	vmovdqu xmm0,XMMWORD PTR [rip+0xffffffffffff719a]        # 208dc0 <__unnamed_5>
  211c25:	ff 
  211c26:	c5 f9 7f 04 24       	vmovdqa XMMWORD PTR [rsp],xmm0
  211c2b:	b8 e5 00 00 00       	mov    eax,0xe5
  211c30:	bf 01 00 00 00       	mov    edi,0x1
  211c35:	4c 89 fe             	mov    rsi,r15
  211c38:	0f 05                	syscall 
  211c3a:	48 89 c1             	mov    rcx,rax
  211c3d:	48 f7 d9             	neg    rcx
  211c40:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  211c46:	49 0f 46 cc          	cmovbe rcx,r12
                switch (errno) {
  211c4a:	48 85 c9             	test   rcx,rcx
  211c4d:	0f 85 43 02 00 00    	jne    211e96 <BmSelf.init.setup.tearDown_error+0x396>
        const f = @atomicLoad(@typeOf(init_vdso_clock_gettime), &vdso_clock_gettime, builtin.AtomicOrder.Unordered);
  211c53:	48 8b 05 ee 93 03 00 	mov    rax,QWORD PTR [rip+0x393ee]        # 24b048 <vdso_clock_gettime>
        if (@ptrToInt(f) != 0) {
  211c5a:	48 85 c0             	test   rax,rax
  211c5d:	74 18                	je     211c77 <BmSelf.init.setup.tearDown_error+0x177>
            const rc = f(clk_id, tp);
  211c5f:	bf 01 00 00 00       	mov    edi,0x1
  211c64:	4c 89 fe             	mov    rsi,r15
  211c67:	c5 f8 77             	vzeroupper 
  211c6a:	ff d0                	call   rax
            switch (rc) {
  211c6c:	48 83 f8 ea          	cmp    rax,0xffffffffffffffea
  211c70:	74 14                	je     211c86 <BmSelf.init.setup.tearDown_error+0x186>
  211c72:	48 85 c0             	test   rax,rax
  211c75:	74 0f                	je     211c86 <BmSelf.init.setup.tearDown_error+0x186>
  211c77:	b8 e4 00 00 00       	mov    eax,0xe4
  211c7c:	bf 01 00 00 00       	mov    edi,0x1
  211c81:	4c 89 fe             	mov    rsi,r15
  211c84:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  211c86:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
                if (errno != 0) return std.os.unexpectedErrorPosix(errno);
  211c8c:	0f 83 18 02 00 00    	jae    211eaa <BmSelf.init.setup.tearDown_error+0x3aa>
                self.start_time = @intCast(u64, ts.tv_sec) * u64(ns_per_s) + @intCast(u64, ts.tv_nsec);
  211c92:	c5 f9 6f 0c 24       	vmovdqa xmm1,XMMWORD PTR [rsp]
        var ts: posix.timespec = undefined;
  211c97:	c5 fa 6f 05 21 71 ff 	vmovdqu xmm0,XMMWORD PTR [rip+0xffffffffffff7121]        # 208dc0 <__unnamed_5>
  211c9e:	ff 
  211c9f:	c5 f9 7f 04 24       	vmovdqa XMMWORD PTR [rsp],xmm0
        const f = @atomicLoad(@typeOf(init_vdso_clock_gettime), &vdso_clock_gettime, builtin.AtomicOrder.Unordered);
  211ca4:	48 8b 05 9d 93 03 00 	mov    rax,QWORD PTR [rip+0x3939d]        # 24b048 <vdso_clock_gettime>
        if (@ptrToInt(f) != 0) {
  211cab:	48 85 c0             	test   rax,rax
  211cae:	74 28                	je     211cd8 <BmSelf.init.setup.tearDown_error+0x1d8>
  211cb0:	c5 f9 7f 4c 24 10    	vmovdqa XMMWORD PTR [rsp+0x10],xmm1
            const rc = f(clk_id, tp);
  211cb6:	bf 01 00 00 00       	mov    edi,0x1
  211cbb:	4c 89 fe             	mov    rsi,r15
  211cbe:	c5 f8 77             	vzeroupper 
  211cc1:	ff d0                	call   rax
            switch (rc) {
  211cc3:	48 83 f8 ea          	cmp    rax,0xffffffffffffffea
  211cc7:	0f 84 b5 01 00 00    	je     211e82 <BmSelf.init.setup.tearDown_error+0x382>
  211ccd:	48 85 c0             	test   rax,rax
  211cd0:	c5 f9 6f 4c 24 10    	vmovdqa xmm1,XMMWORD PTR [rsp+0x10]
  211cd6:	74 0f                	je     211ce7 <BmSelf.init.setup.tearDown_error+0x1e7>
  211cd8:	b8 e4 00 00 00       	mov    eax,0xe4
  211cdd:	bf 01 00 00 00       	mov    edi,0x1
  211ce2:	4c 89 fe             	mov    rsi,r15
  211ce5:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  211ce7:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
  211ced:	0f 83 1c 02 00 00    	jae    211f0f <BmSelf.init.setup.tearDown_error+0x40f>
        return @intCast(u64, ts.tv_sec) * u64(ns_per_s) + @intCast(u64, ts.tv_nsec);
  211cf3:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  211cf8:	c5 f9 fb c1          	vpsubq xmm0,xmm0,xmm1
  211cfc:	c4 e1 f9 7e c0       	vmovq  rax,xmm0
        var clock = clockNative() - self.start_time;
  211d01:	c4 e3 f9 16 c5 01    	vpextrq rbp,xmm0,0x1
  211d07:	48 69 c0 00 ca 9a 3b 	imul   rax,rax,0x3b9aca00
  211d0e:	48 01 c5             	add    rbp,rax
                if ((run_time_ns >= pSelf.min_runtime_ns) or (iterations >= pSelf.max_iterations)) {
  211d11:	48 3b 6c 24 58       	cmp    rbp,QWORD PTR [rsp+0x58]
  211d16:	0f 83 9c 01 00 00    	jae    211eb8 <BmSelf.init.setup.tearDown_error+0x3b8>
  211d1c:	4c 39 f3             	cmp    rbx,r14
  211d1f:	0f 83 93 01 00 00    	jae    211eb8 <BmSelf.init.setup.tearDown_error+0x3b8>
                    if (pSelf.logl >= 1) {
  211d25:	4d 85 ed             	test   r13,r13
  211d28:	0f 84 b8 00 00 00    	je     211de6 <BmSelf.init.setup.tearDown_error+0x2e6>
                            Result {.run_time_ns = run_time_ns, .iterations = iterations});
  211d2e:	48 89 6c 24 20       	mov    QWORD PTR [rsp+0x20],rbp
  211d33:	48 89 5c 24 28       	mov    QWORD PTR [rsp+0x28],rbx
                        try pSelf.report(
  211d38:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  211d3d:	48 8d 74 24 20       	lea    rsi,[rsp+0x20]
  211d42:	c5 f8 77             	vzeroupper 
  211d45:	e8 16 1d 00 00       	call   213a60 <Benchmark_report>
  211d4a:	66 85 c0             	test   ax,ax
  211d4d:	0f 85 89 01 00 00    	jne    211edc <BmSelf.init.setup.tearDown_error+0x3dc>
  211d53:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  211d5a:	84 00 00 00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  211d60:	b0 01                	mov    al,0x1
  211d62:	86 05 a8 e2 03 00    	xchg   BYTE PTR [rip+0x3e2a8],al        # 250010 <stderr_mutex>
  211d68:	84 c0                	test   al,al
  211d6a:	75 f4                	jne    211d60 <BmSelf.init.setup.tearDown_error+0x260>
    if (stderr_stream) |st| {
  211d6c:	48 8b 3d 95 e2 03 00 	mov    rdi,QWORD PTR [rip+0x3e295]        # 250008 <stderr_stream>
  211d73:	48 85 ff             	test   rdi,rdi
  211d76:	74 18                	je     211d90 <BmSelf.init.setup.tearDown_error+0x290>
  211d78:	48 8b 0d c1 92 03 00 	mov    rcx,QWORD PTR [rip+0x392c1]        # 24b040 <stderr_file_out_stream+0x8>
  211d7f:	eb 4c                	jmp    211dcd <BmSelf.init.setup.tearDown_error+0x2cd>
  211d81:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  211d88:	0f 1f 84 00 00 00 00 
  211d8f:	00 
        stderr_file = try io.getStdErr();
  211d90:	c7 05 96 92 03 00 02 	mov    DWORD PTR [rip+0x39296],0x2        # 24b030 <stderr_file>
  211d97:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  211d9a:	48 8d 05 8f 92 03 00 	lea    rax,[rip+0x3928f]        # 24b030 <stderr_file>
  211da1:	48 89 05 90 92 03 00 	mov    QWORD PTR [rip+0x39290],rax        # 24b038 <stderr_file_out_stream>
  211da8:	48 8d 05 31 dc 00 00 	lea    rax,[rip+0xdc31]        # 21f9e0 <FileOutStream_writeFn>
  211daf:	48 89 05 8a 92 03 00 	mov    QWORD PTR [rip+0x3928a],rax        # 24b040 <stderr_file_out_stream+0x8>
  211db6:	48 8d 0d 83 92 03 00 	lea    rcx,[rip+0x39283]        # 24b040 <stderr_file_out_stream+0x8>
  211dbd:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  211dc0:	48 89 15 41 e2 03 00 	mov    QWORD PTR [rip+0x3e241],rdx        # 250008 <stderr_stream>
  211dc7:	48 89 c1             	mov    rcx,rax
  211dca:	48 89 d7             	mov    rdi,rdx
  211dcd:	48 8d 35 44 d0 03 00 	lea    rsi,[rip+0x3d044]        # 24ee18 <__unnamed_3>
  211dd4:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  211dd6:	31 c0                	xor    eax,eax
  211dd8:	86 05 32 e2 03 00    	xchg   BYTE PTR [rip+0x3e232],al        # 250010 <stderr_mutex>
  211dde:	3c 01                	cmp    al,0x1
    if (!ok) {
  211de0:	0f 85 29 01 00 00    	jne    211f0f <BmSelf.init.setup.tearDown_error+0x40f>
                    if (run_time_ns < 1000) {
  211de6:	48 81 fd e8 03 00 00 	cmp    rbp,0x3e8
  211ded:	73 31                	jae    211e20 <BmSelf.init.setup.tearDown_error+0x320>
  211def:	b9 01 00 00 00       	mov    ecx,0x1
  211df4:	be e8 03 00 00       	mov    esi,0x3e8
                    iterations = (iterations * numer) / denom;
  211df9:	48 0f af de          	imul   rbx,rsi
  211dfd:	48 89 d8             	mov    rax,rbx
  211e00:	48 c1 e8 20          	shr    rax,0x20
  211e04:	74 54                	je     211e5a <BmSelf.init.setup.tearDown_error+0x35a>
  211e06:	31 d2                	xor    edx,edx
  211e08:	48 89 d8             	mov    rax,rbx
  211e0b:	48 f7 f1             	div    rcx
  211e0e:	48 89 c3             	mov    rbx,rax
  211e11:	eb 4f                	jmp    211e62 <BmSelf.init.setup.tearDown_error+0x362>
  211e13:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  211e1a:	84 00 00 00 00 00 
                    } else if (run_time_ns < (pSelf.min_runtime_ns / 10)) {
  211e20:	48 ba cd cc cc cc cc 	movabs rdx,0xcccccccccccccccd
  211e27:	cc cc cc 
  211e2a:	c4 e2 fb f6 4c 24 58 	mulx   rcx,rax,QWORD PTR [rsp+0x58]
  211e31:	48 c1 e9 03          	shr    rcx,0x3
  211e35:	31 c0                	xor    eax,eax
  211e37:	48 39 cd             	cmp    rbp,rcx
  211e3a:	0f 93 c0             	setae  al
  211e3d:	48 8d 0c c0          	lea    rcx,[rax+rax*8]
  211e41:	48 83 c1 01          	add    rcx,0x1
  211e45:	48 8d 34 85 0a 00 00 	lea    rsi,[rax*4+0xa]
  211e4c:	00 
                    iterations = (iterations * numer) / denom;
  211e4d:	48 0f af de          	imul   rbx,rsi
  211e51:	48 89 d8             	mov    rax,rbx
  211e54:	48 c1 e8 20          	shr    rax,0x20
  211e58:	75 ac                	jne    211e06 <BmSelf.init.setup.tearDown_error+0x306>
  211e5a:	31 d2                	xor    edx,edx
  211e5c:	89 d8                	mov    eax,ebx
  211e5e:	f7 f1                	div    ecx
  211e60:	89 c3                	mov    ebx,eax
                    if (pSelf.logl >= 2) {
  211e62:	4c 8b 6c 24 50       	mov    r13,QWORD PTR [rsp+0x50]
                    if (iterations > pSelf.max_iterations) {
  211e67:	4c 8b 74 24 68       	mov    r14,QWORD PTR [rsp+0x68]
  211e6c:	4c 39 f3             	cmp    rbx,r14
  211e6f:	49 0f 47 de          	cmova  rbx,r14
                    if (pSelf.logl >= 2) {
  211e73:	49 83 fd 02          	cmp    r13,0x2
  211e77:	0f 82 a1 fd ff ff    	jb     211c1e <BmSelf.init.setup.tearDown_error+0x11e>
  211e7d:	e9 8e fd ff ff       	jmp    211c10 <BmSelf.init.setup.tearDown_error+0x110>
  211e82:	c5 f9 6f 4c 24 10    	vmovdqa xmm1,XMMWORD PTR [rsp+0x10]
  211e88:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
  211e8e:	0f 82 5f fe ff ff    	jb     211cf3 <BmSelf.init.setup.tearDown_error+0x1f3>
  211e94:	eb 79                	jmp    211f0f <BmSelf.init.setup.tearDown_error+0x40f>
                switch (errno) {
  211e96:	48 83 f9 16          	cmp    rcx,0x16
  211e9a:	75 0e                	jne    211eaa <BmSelf.init.setup.tearDown_error+0x3aa>
  211e9c:	66 b8 02 00          	mov    ax,0x2
    if (value) {
  211ea0:	0f b7 c8             	movzx  ecx,ax
  211ea3:	83 f9 0a             	cmp    ecx,0xa
  211ea6:	74 3c                	je     211ee4 <BmSelf.init.setup.tearDown_error+0x3e4>
  211ea8:	eb 51                	jmp    211efb <BmSelf.init.setup.tearDown_error+0x3fb>
  211eaa:	66 b8 03 00          	mov    ax,0x3
  211eae:	0f b7 c8             	movzx  ecx,ax
  211eb1:	83 f9 0a             	cmp    ecx,0xa
  211eb4:	74 2e                	je     211ee4 <BmSelf.init.setup.tearDown_error+0x3e4>
  211eb6:	eb 43                	jmp    211efb <BmSelf.init.setup.tearDown_error+0x3fb>
                            Result { .run_time_ns = run_time_ns, .iterations = iterations});
  211eb8:	48 89 6c 24 30       	mov    QWORD PTR [rsp+0x30],rbp
  211ebd:	48 89 5c 24 38       	mov    QWORD PTR [rsp+0x38],rbx
  211ec2:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
                    try pSelf.results.append(
  211ec7:	48 8d bc 24 88 00 00 	lea    rdi,[rsp+0x88]
  211ece:	00 
  211ecf:	c5 f8 77             	vzeroupper 
  211ed2:	e8 19 1a 00 00       	call   2138f0 <AlignedArrayList(Result,8)_append>
  211ed7:	66 85 c0             	test   ax,ax
  211eda:	74 08                	je     211ee4 <BmSelf.init.setup.tearDown_error+0x3e4>
  211edc:	0f b7 c8             	movzx  ecx,ax
  211edf:	83 f9 0a             	cmp    ecx,0xa
  211ee2:	75 17                	jne    211efb <BmSelf.init.setup.tearDown_error+0x3fb>
test "BmSelf.init.setup.tearDown_error" {
  211ee4:	31 c0                	xor    eax,eax
  211ee6:	48 81 c4 a8 00 00 00 	add    rsp,0xa8
  211eed:	5b                   	pop    rbx
  211eee:	41 5c                	pop    r12
  211ef0:	41 5d                	pop    r13
  211ef2:	41 5e                	pop    r14
  211ef4:	41 5f                	pop    r15
  211ef6:	5d                   	pop    rbp
  211ef7:	c5 f8 77             	vzeroupper 
  211efa:	c3                   	ret    
  211efb:	66 85 c0             	test   ax,ax
  211efe:	75 0f                	jne    211f0f <BmSelf.init.setup.tearDown_error+0x40f>
        @panic("expected error");
  211f00:	48 8d 3d 11 ce 03 00 	lea    rdi,[rip+0x3ce11]        # 24ed18 <__unnamed_12>
  211f07:	c5 f8 77             	vzeroupper 
  211f0a:	e8 11 01 00 00       	call   212020 <panic>
            @panic("assertion failure");
  211f0f:	48 8d 3d f2 cd 03 00 	lea    rdi,[rip+0x3cdf2]        # 24ed08 <__unnamed_2>
  211f16:	c5 f8 77             	vzeroupper 
  211f19:	e8 02 01 00 00       	call   212020 <panic>
  211f1e:	66 90                	xchg   ax,ax

0000000000211f20 <BmSelf.init.setup.tearDown.benchmark_error>:
    };

    assertError(bm.run(BmSelf), error.TearDownError);
}

test "BmSelf.init.setup.tearDown.benchmark_error" {
  211f20:	48 83 ec 18          	sub    rsp,0x18
  211f24:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  211f2b:	00 00 00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  211f30:	b0 01                	mov    al,0x1
  211f32:	86 05 d8 e0 03 00    	xchg   BYTE PTR [rip+0x3e0d8],al        # 250010 <stderr_mutex>
  211f38:	84 c0                	test   al,al
  211f3a:	75 f4                	jne    211f30 <BmSelf.init.setup.tearDown.benchmark_error+0x10>
    if (stderr_stream) |st| {
  211f3c:	48 8b 3d c5 e0 03 00 	mov    rdi,QWORD PTR [rip+0x3e0c5]        # 250008 <stderr_stream>
  211f43:	48 85 ff             	test   rdi,rdi
  211f46:	74 09                	je     211f51 <BmSelf.init.setup.tearDown.benchmark_error+0x31>
  211f48:	48 8b 05 f1 90 03 00 	mov    rax,QWORD PTR [rip+0x390f1]        # 24b040 <stderr_file_out_stream+0x8>
  211f4f:	eb 34                	jmp    211f85 <BmSelf.init.setup.tearDown.benchmark_error+0x65>
        stderr_file = try io.getStdErr();
  211f51:	48 8d 05 d8 90 03 00 	lea    rax,[rip+0x390d8]        # 24b030 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  211f58:	48 89 05 d9 90 03 00 	mov    QWORD PTR [rip+0x390d9],rax        # 24b038 <stderr_file_out_stream>
  211f5f:	48 8d 05 7a da 00 00 	lea    rax,[rip+0xda7a]        # 21f9e0 <FileOutStream_writeFn>
  211f66:	48 89 05 d3 90 03 00 	mov    QWORD PTR [rip+0x390d3],rax        # 24b040 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  211f6d:	c7 05 b9 90 03 00 02 	mov    DWORD PTR [rip+0x390b9],0x2        # 24b030 <stderr_file>
  211f74:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  211f77:	48 8d 3d c2 90 03 00 	lea    rdi,[rip+0x390c2]        # 24b040 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  211f7e:	48 89 3d 83 e0 03 00 	mov    QWORD PTR [rip+0x3e083],rdi        # 250008 <stderr_stream>
  211f85:	48 8d 35 8c ce 03 00 	lea    rsi,[rip+0x3ce8c]        # 24ee18 <__unnamed_3>
  211f8c:	ff d0                	call   rax
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  211f8e:	31 c0                	xor    eax,eax
  211f90:	86 05 7a e0 03 00    	xchg   BYTE PTR [rip+0x3e07a],al        # 250010 <stderr_mutex>
  211f96:	3c 01                	cmp    al,0x1
    if (!ok) {
  211f98:	75 76                	jne    212010 <BmSelf.init.setup.tearDown.benchmark_error+0xf0>
                var ts: posix.timespec = undefined;
  211f9a:	c5 f8 10 05 1e 6e ff 	vmovups xmm0,XMMWORD PTR [rip+0xffffffffffff6e1e]        # 208dc0 <__unnamed_5>
  211fa1:	ff 
  211fa2:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
  211fa7:	48 89 e6             	mov    rsi,rsp
  211faa:	b8 e5 00 00 00       	mov    eax,0xe5
  211faf:	bf 01 00 00 00       	mov    edi,0x1
  211fb4:	0f 05                	syscall 
  211fb6:	48 89 c2             	mov    rdx,rax
  211fb9:	48 f7 da             	neg    rdx
  211fbc:	31 c9                	xor    ecx,ecx
  211fbe:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  211fc4:	48 0f 47 ca          	cmova  rcx,rdx
                switch (errno) {
  211fc8:	48 85 c9             	test   rcx,rcx
  211fcb:	75 3f                	jne    21200c <BmSelf.init.setup.tearDown.benchmark_error+0xec>
        const f = @atomicLoad(@typeOf(init_vdso_clock_gettime), &vdso_clock_gettime, builtin.AtomicOrder.Unordered);
  211fcd:	48 8b 05 74 90 03 00 	mov    rax,QWORD PTR [rip+0x39074]        # 24b048 <vdso_clock_gettime>
        if (@ptrToInt(f) != 0) {
  211fd4:	48 85 c0             	test   rax,rax
  211fd7:	74 15                	je     211fee <BmSelf.init.setup.tearDown.benchmark_error+0xce>
  211fd9:	48 89 e6             	mov    rsi,rsp
            const rc = f(clk_id, tp);
  211fdc:	bf 01 00 00 00       	mov    edi,0x1
  211fe1:	ff d0                	call   rax
            switch (rc) {
  211fe3:	48 83 f8 ea          	cmp    rax,0xffffffffffffffea
  211fe7:	74 14                	je     211ffd <BmSelf.init.setup.tearDown.benchmark_error+0xdd>
  211fe9:	48 85 c0             	test   rax,rax
  211fec:	74 0f                	je     211ffd <BmSelf.init.setup.tearDown.benchmark_error+0xdd>
  211fee:	48 89 e6             	mov    rsi,rsp
  211ff1:	b8 e4 00 00 00       	mov    eax,0xe4
  211ff6:	bf 01 00 00 00       	mov    edi,0x1
  211ffb:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  211ffd:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
    if (value) {
  212003:	73 0b                	jae    212010 <BmSelf.init.setup.tearDown.benchmark_error+0xf0>
  212005:	31 c0                	xor    eax,eax
  212007:	48 83 c4 18          	add    rsp,0x18
  21200b:	c3                   	ret    
  21200c:	48 83 f9 16          	cmp    rcx,0x16
            @panic("assertion failure");
  212010:	48 8d 3d f1 cc 03 00 	lea    rdi,[rip+0x3ccf1]        # 24ed08 <__unnamed_2>
  212017:	e8 04 00 00 00       	call   212020 <panic>
  21201c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

0000000000212020 <panic>:
// have to be added in the compiler.

const builtin = @import("builtin");
const std = @import("std");

pub fn panic(msg: []const u8, error_return_trace: ?*builtin.StackTrace) noreturn {
  212020:	48 83 ec 18          	sub    rsp,0x18
  212024:	48 89 f8             	mov    rax,rdi
        // TODO: fix panic in zen.
        builtin.Os.freestanding, builtin.Os.zen => {
            while (true) {}
        },
        else => {
            const first_trace_addr = @ptrToInt(@returnAddress());
  212027:	48 8b 4c 24 18       	mov    rcx,QWORD PTR [rsp+0x18]
            std.debug.panicExtra(error_return_trace, first_trace_addr, "{}", msg);
  21202c:	48 89 4c 24 08       	mov    QWORD PTR [rsp+0x8],rcx
  212031:	c6 44 24 10 01       	mov    BYTE PTR [rsp+0x10],0x1
  212036:	48 8d 7c 24 08       	lea    rdi,[rsp+0x8]
  21203b:	48 89 c6             	mov    rsi,rax
  21203e:	e8 0d 00 00 00       	call   212050 <panicExtra>
  212043:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21204a:	84 00 00 00 00 00 

0000000000212050 <panicExtra>:
    panicExtra(null, first_trace_addr, format, args);
}

var panicking: u8 = 0; // TODO make this a bool

pub fn panicExtra(trace: ?*const builtin.StackTrace, first_trace_addr: ?usize, comptime format: []const u8, args: ...) noreturn {
  212050:	41 57                	push   r15
  212052:	41 56                	push   r14
  212054:	53                   	push   rbx
  212055:	48 83 ec 10          	sub    rsp,0x10
  212059:	b0 01                	mov    al,0x1
    @setCold(true);

    if (@atomicRmw(u8, &panicking, builtin.AtomicRmwOp.Xchg, 1, builtin.AtomicOrder.SeqCst) == 1) {
  21205b:	86 05 9f df 03 00    	xchg   BYTE PTR [rip+0x3df9f],al        # 250000 <panicking>
  212061:	49 89 fe             	mov    r14,rdi
  212064:	3c 01                	cmp    al,0x1
  212066:	74 7a                	je     2120e2 <panicExtra+0x92>
    if (stderr_stream) |st| {
  212068:	48 8b 1d 99 df 03 00 	mov    rbx,QWORD PTR [rip+0x3df99]        # 250008 <stderr_stream>
  21206f:	48 85 db             	test   rbx,rbx
  212072:	75 36                	jne    2120aa <panicExtra+0x5a>
        stderr_file = try io.getStdErr();
  212074:	48 8d 05 b5 8f 03 00 	lea    rax,[rip+0x38fb5]        # 24b030 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  21207b:	48 89 05 b6 8f 03 00 	mov    QWORD PTR [rip+0x38fb6],rax        # 24b038 <stderr_file_out_stream>
  212082:	4c 8d 3d 57 d9 00 00 	lea    r15,[rip+0xd957]        # 21f9e0 <FileOutStream_writeFn>
  212089:	4c 89 3d b0 8f 03 00 	mov    QWORD PTR [rip+0x38fb0],r15        # 24b040 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  212090:	c7 05 96 8f 03 00 02 	mov    DWORD PTR [rip+0x38f96],0x2        # 24b030 <stderr_file>
  212097:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  21209a:	48 8d 1d 9f 8f 03 00 	lea    rbx,[rip+0x38f9f]        # 24b040 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  2120a1:	48 89 1d 60 df 03 00 	mov    QWORD PTR [rip+0x3df60],rbx        # 250008 <stderr_stream>
  2120a8:	eb 07                	jmp    2120b1 <panicExtra+0x61>
  2120aa:	4c 8b 3d 8f 8f 03 00 	mov    r15,QWORD PTR [rip+0x38f8f]        # 24b040 <stderr_file_out_stream+0x8>
                const casted_value = ([]const u8)(value);
  2120b1:	c5 f8 10 06          	vmovups xmm0,XMMWORD PTR [rsi]
  2120b5:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
  2120ba:	48 89 e6             	mov    rsi,rsp
                return output(context, casted_value);
  2120bd:	48 89 df             	mov    rdi,rbx
  2120c0:	41 ff d7             	call   r15
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  2120c3:	66 85 c0             	test   ax,ax
  2120c6:	75 1a                	jne    2120e2 <panicExtra+0x92>
        try output(context, fmt[start_index..]);
  2120c8:	48 8d 35 59 cc 03 00 	lea    rsi,[rip+0x3cc59]        # 24ed28 <__unnamed_13>
  2120cf:	48 89 df             	mov    rdi,rbx
  2120d2:	41 ff d7             	call   r15
        // we would want to return here instead of calling abort, so that the thread
        // which first called panic can finish printing a stack trace.
        os.abort();
    }
    const stderr = getStderrStream() catch os.abort();
    stderr.print(format ++ "\n", args) catch os.abort();
  2120d5:	66 85 c0             	test   ax,ax
  2120d8:	75 08                	jne    2120e2 <panicExtra+0x92>
    if (trace) |t| {
        dumpStackTrace(t);
    }
    dumpCurrentStackTrace(first_trace_addr);
  2120da:	4c 89 f7             	mov    rdi,r14
  2120dd:	e8 0e 01 00 00       	call   2121f0 <dumpCurrentStackTrace>
  2120e2:	e8 09 00 00 00       	call   2120f0 <abort>
  2120e7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  2120ee:	00 00 

00000000002120f0 <abort>:
pub const SIG_DFL = @intToPtr(extern fn (i32) void, 0);
pub const SIG_IGN = @intToPtr(extern fn (i32) void, 1);
pub const empty_sigset = []usize{0} ** sigset_t.len;

pub fn raise(sig: i32) usize {
    var set: sigset_t = undefined;
  2120f0:	50                   	push   rax
  2120f1:	c5 fc 10 05 67 55 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffff5567]        # 207660 <__unnamed_14+0x60>
  2120f8:	ff 
  2120f9:	c5 fc 11 44 24 e0    	vmovups YMMWORD PTR [rsp-0x20],ymm0
  2120ff:	c5 fc 10 0d 39 55 ff 	vmovups ymm1,YMMWORD PTR [rip+0xffffffffffff5539]        # 207640 <__unnamed_14+0x40>
  212106:	ff 
  212107:	c5 fc 11 4c 24 c0    	vmovups YMMWORD PTR [rsp-0x40],ymm1
  21210d:	c5 fc 10 15 0b 55 ff 	vmovups ymm2,YMMWORD PTR [rip+0xffffffffffff550b]        # 207620 <__unnamed_14+0x20>
  212114:	ff 
  212115:	c5 fc 11 54 24 a0    	vmovups YMMWORD PTR [rsp-0x60],ymm2
  21211b:	c5 fc 10 1d dd 54 ff 	vmovups ymm3,YMMWORD PTR [rip+0xffffffffffff54dd]        # 207600 <__unnamed_14>
  212122:	ff 
  212123:	c5 fc 11 5c 24 80    	vmovups YMMWORD PTR [rsp-0x80],ymm3
        : "rcx", "r11"
    );
}

pub fn syscall4(number: usize, arg1: usize, arg2: usize, arg3: usize, arg4: usize) usize {
    return asm volatile ("syscall"
  212129:	4c 8d 0d 00 e2 fe ff 	lea    r9,[rip+0xfffffffffffee200]        # 200330 <app_mask>
  212130:	4c 8d 44 24 80       	lea    r8,[rsp-0x80]
  212135:	b8 0e 00 00 00       	mov    eax,0xe
  21213a:	bf 00 00 00 00       	mov    edi,0x0
  21213f:	41 ba 08 00 00 00    	mov    r10d,0x8
  212145:	4c 89 ce             	mov    rsi,r9
  212148:	4c 89 c2             	mov    rdx,r8
  21214b:	0f 05                	syscall 
    return asm volatile ("syscall"
  21214d:	b8 ba 00 00 00       	mov    eax,0xba
  212152:	0f 05                	syscall 
    blockAppSignals(&set);
    const tid = @intCast(i32, syscall0(SYS_gettid));
    const ret = syscall2(SYS_tkill, @intCast(usize, tid), @intCast(usize, sig));
  212154:	48 63 f8             	movsxd rdi,eax
    return asm volatile ("syscall"
  212157:	b8 c8 00 00 00       	mov    eax,0xc8
  21215c:	be 06 00 00 00       	mov    esi,0x6
  212161:	0f 05                	syscall 
    return asm volatile ("syscall"
  212163:	b8 0e 00 00 00       	mov    eax,0xe
  212168:	bf 02 00 00 00       	mov    edi,0x2
  21216d:	ba 00 00 00 00       	mov    edx,0x0
  212172:	41 ba 08 00 00 00    	mov    r10d,0x8
  212178:	4c 89 c6             	mov    rsi,r8
  21217b:	0f 05                	syscall 
    var set: sigset_t = undefined;
  21217d:	c5 fc 11 44 24 e0    	vmovups YMMWORD PTR [rsp-0x20],ymm0
  212183:	c5 fc 11 4c 24 c0    	vmovups YMMWORD PTR [rsp-0x40],ymm1
  212189:	c5 fc 11 54 24 a0    	vmovups YMMWORD PTR [rsp-0x60],ymm2
  21218f:	c5 fc 11 5c 24 80    	vmovups YMMWORD PTR [rsp-0x80],ymm3
  212195:	b8 0e 00 00 00       	mov    eax,0xe
  21219a:	bf 00 00 00 00       	mov    edi,0x0
  21219f:	41 ba 08 00 00 00    	mov    r10d,0x8
  2121a5:	4c 89 ce             	mov    rsi,r9
  2121a8:	4c 89 c2             	mov    rdx,r8
  2121ab:	0f 05                	syscall 
    return asm volatile ("syscall"
  2121ad:	b8 ba 00 00 00       	mov    eax,0xba
  2121b2:	0f 05                	syscall 
    const ret = syscall2(SYS_tkill, @intCast(usize, tid), @intCast(usize, sig));
  2121b4:	48 63 f8             	movsxd rdi,eax
    return asm volatile ("syscall"
  2121b7:	b8 c8 00 00 00       	mov    eax,0xc8
  2121bc:	be 09 00 00 00       	mov    esi,0x9
  2121c1:	0f 05                	syscall 
    return asm volatile ("syscall"
  2121c3:	b8 0e 00 00 00       	mov    eax,0xe
  2121c8:	bf 02 00 00 00       	mov    edi,0x2
  2121cd:	31 d2                	xor    edx,edx
  2121cf:	41 ba 08 00 00 00    	mov    r10d,0x8
  2121d5:	4c 89 c6             	mov    rsi,r8
  2121d8:	0f 05                	syscall 
  2121da:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
    }
    switch (builtin.os) {
        Os.linux, Os.macosx, Os.ios => {
            _ = posix.raise(posix.SIGABRT);
            _ = posix.raise(posix.SIGKILL);
            while (true) {}
  2121e0:	eb fe                	jmp    2121e0 <abort+0xf0>
  2121e2:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  2121e9:	1f 84 00 00 00 00 00 

00000000002121f0 <dumpCurrentStackTrace>:
pub fn dumpCurrentStackTrace(start_addr: ?usize) void {
  2121f0:	55                   	push   rbp
  2121f1:	48 89 e5             	mov    rbp,rsp
  2121f4:	41 57                	push   r15
  2121f6:	41 56                	push   r14
  2121f8:	41 55                	push   r13
  2121fa:	41 54                	push   r12
  2121fc:	53                   	push   rbx
  2121fd:	48 83 e4 e0          	and    rsp,0xffffffffffffffe0
  212201:	48 81 ec a0 01 00 00 	sub    rsp,0x1a0
  212208:	49 89 fe             	mov    r14,rdi
    if (stderr_stream) |st| {
  21220b:	48 8b 1d f6 dd 03 00 	mov    rbx,QWORD PTR [rip+0x3ddf6]        # 250008 <stderr_stream>
  212212:	48 85 db             	test   rbx,rbx
  212215:	74 39                	je     212250 <dumpCurrentStackTrace+0x60>
    if (self_debug_info) |info| {
  212217:	48 8b 05 fa dd 03 00 	mov    rax,QWORD PTR [rip+0x3ddfa]        # 250018 <self_debug_info>
  21221e:	48 89 44 24 68       	mov    QWORD PTR [rsp+0x68],rax
  212223:	48 85 c0             	test   rax,rax
  212226:	74 6d                	je     212295 <dumpCurrentStackTrace+0xa5>
// TODO make thread safe
var debug_info_allocator: ?*mem.Allocator = null;
var debug_info_direct_allocator: std.heap.DirectAllocator = undefined;
var debug_info_arena_allocator: std.heap.ArenaAllocator = undefined;
fn getDebugInfoAllocator() *mem.Allocator {
    if (debug_info_allocator) |a| return a;
  212228:	48 83 3d f0 dd 03 00 	cmp    QWORD PTR [rip+0x3ddf0],0x0        # 250020 <debug_info_allocator>
  21222f:	00 
  212230:	0f 84 4e 01 00 00    	je     212384 <dumpCurrentStackTrace+0x194>
    }
}

/// TODO make this go through libc when we have it
pub fn getEnvPosix(key: []const u8) ?[]const u8 {
    for (posix_environ_raw) |ptr| {
  212236:	48 8b 05 7b 8e 03 00 	mov    rax,QWORD PTR [rip+0x38e7b]        # 24b0b8 <posix_environ_raw+0x8>
  21223d:	48 85 c0             	test   rax,rax
  212240:	48 89 5c 24 70       	mov    QWORD PTR [rsp+0x70],rbx
  212245:	0f 85 a4 01 00 00    	jne    2123ef <dumpCurrentStackTrace+0x1ff>
  21224b:	e9 5d 02 00 00       	jmp    2124ad <dumpCurrentStackTrace+0x2bd>
        stderr_file = try io.getStdErr();
  212250:	48 8d 05 d9 8d 03 00 	lea    rax,[rip+0x38dd9]        # 24b030 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  212257:	48 89 05 da 8d 03 00 	mov    QWORD PTR [rip+0x38dda],rax        # 24b038 <stderr_file_out_stream>
  21225e:	48 8d 05 7b d7 00 00 	lea    rax,[rip+0xd77b]        # 21f9e0 <FileOutStream_writeFn>
  212265:	48 89 05 d4 8d 03 00 	mov    QWORD PTR [rip+0x38dd4],rax        # 24b040 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  21226c:	c7 05 ba 8d 03 00 02 	mov    DWORD PTR [rip+0x38dba],0x2        # 24b030 <stderr_file>
  212273:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  212276:	48 8d 1d c3 8d 03 00 	lea    rbx,[rip+0x38dc3]        # 24b040 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  21227d:	48 89 1d 84 dd 03 00 	mov    QWORD PTR [rip+0x3dd84],rbx        # 250008 <stderr_stream>
    if (self_debug_info) |info| {
  212284:	48 8b 05 8d dd 03 00 	mov    rax,QWORD PTR [rip+0x3dd8d]        # 250018 <self_debug_info>
  21228b:	48 89 44 24 68       	mov    QWORD PTR [rsp+0x68],rax
  212290:	48 85 c0             	test   rax,rax
  212293:	75 93                	jne    212228 <dumpCurrentStackTrace+0x38>
    if (debug_info_allocator) |a| return a;
  212295:	48 8b 35 84 dd 03 00 	mov    rsi,QWORD PTR [rip+0x3dd84]        # 250020 <debug_info_allocator>
  21229c:	48 85 f6             	test   rsi,rsi
  21229f:	75 56                	jne    2122f7 <dumpCurrentStackTrace+0x107>

    debug_info_direct_allocator = std.heap.DirectAllocator.init();
  2122a1:	c5 fc 10 05 cf cc 03 	vmovups ymm0,YMMWORD PTR [rip+0x3cccf]        # 24ef78 <__unnamed_15>
  2122a8:	00 
  2122a9:	c5 fc 11 05 9f 8d 03 	vmovups YMMWORD PTR [rip+0x38d9f],ymm0        # 24b050 <debug_info_direct_allocator>
  2122b0:	00 
    debug_info_arena_allocator = std.heap.ArenaAllocator.init(&debug_info_direct_allocator.allocator);
  2122b1:	c5 fa 6f 05 df cc 03 	vmovdqu xmm0,XMMWORD PTR [rip+0x3ccdf]        # 24ef98 <__unnamed_16>
  2122b8:	00 
  2122b9:	c5 fa 7f 05 af 8d 03 	vmovdqu XMMWORD PTR [rip+0x38daf],xmm0        # 24b070 <debug_info_arena_allocator>
  2122c0:	00 
    debug_info_direct_allocator = std.heap.DirectAllocator.init();
  2122c1:	48 8d 05 88 8d 03 00 	lea    rax,[rip+0x38d88]        # 24b050 <debug_info_direct_allocator>
    debug_info_arena_allocator = std.heap.ArenaAllocator.init(&debug_info_direct_allocator.allocator);
  2122c8:	48 8b 0d d9 cc 03 00 	mov    rcx,QWORD PTR [rip+0x3ccd9]        # 24efa8 <__unnamed_16+0x10>
  2122cf:	48 89 0d aa 8d 03 00 	mov    QWORD PTR [rip+0x38daa],rcx        # 24b080 <debug_info_arena_allocator+0x10>
  2122d6:	48 8d 35 93 8d 03 00 	lea    rsi,[rip+0x38d93]        # 24b070 <debug_info_arena_allocator>
  2122dd:	48 89 05 a4 8d 03 00 	mov    QWORD PTR [rip+0x38da4],rax        # 24b088 <debug_info_arena_allocator+0x18>
  2122e4:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  2122e8:	c5 fe 7f 05 a0 8d 03 	vmovdqu YMMWORD PTR [rip+0x38da0],ymm0        # 24b090 <debug_info_arena_allocator+0x20>
  2122ef:	00 
    debug_info_allocator = &debug_info_arena_allocator.allocator;
  2122f0:	48 89 35 29 dd 03 00 	mov    QWORD PTR [rip+0x3dd29],rsi        # 250020 <debug_info_allocator>
  2122f7:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
        const info = try openSelfDebugInfo(getDebugInfoAllocator());
  2122fc:	c5 f8 77             	vzeroupper 
  2122ff:	e8 cc d7 00 00       	call   21fad0 <openSelfDebugInfo>
  212304:	4c 0f bf 7c 24 20    	movsx  r15,WORD PTR [rsp+0x20]
  21230a:	4d 85 ff             	test   r15,r15
  21230d:	74 56                	je     212365 <dumpCurrentStackTrace+0x175>
  21230f:	4c 8b 33             	mov    r14,QWORD PTR [rbx]
                        try output(context, fmt[start_index..i]);
  212312:	48 8d 35 df ca 03 00 	lea    rsi,[rip+0x3cadf]        # 24edf8 <__unnamed_17>
  212319:	48 89 df             	mov    rdi,rbx
  21231c:	41 ff d6             	call   r14
  21231f:	66 85 c0             	test   ax,ax
  212322:	0f 85 dd 14 00 00    	jne    213805 <dumpCurrentStackTrace+0x1615>
        stderr.print("Unable to dump stack trace: Unable to open debug info: {}\n", @errorName(err)) catch return;
  212328:	49 c1 e7 04          	shl    r15,0x4
  21232c:	48 8d 05 cd 9c 03 00 	lea    rax,[rip+0x39ccd]        # 24c000 <raw+0xf38>
                const casted_value = ([]const u8)(value);
  212333:	c4 c1 7a 6f 04 07    	vmovdqu xmm0,XMMWORD PTR [r15+rax*1]
  212339:	c5 f9 7f 44 24 20    	vmovdqa XMMWORD PTR [rsp+0x20],xmm0
  21233f:	48 8d 74 24 20       	lea    rsi,[rsp+0x20]
                return output(context, casted_value);
  212344:	48 89 df             	mov    rdi,rbx
  212347:	41 ff d6             	call   r14
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  21234a:	66 85 c0             	test   ax,ax
  21234d:	0f 85 b2 14 00 00    	jne    213805 <dumpCurrentStackTrace+0x1615>
        try output(context, fmt[start_index..]);
  212353:	48 8d 35 ae ca 03 00 	lea    rsi,[rip+0x3caae]        # 24ee08 <__unnamed_18>
  21235a:	48 89 df             	mov    rdi,rbx
  21235d:	41 ff d6             	call   r14
  212360:	e9 a0 14 00 00       	jmp    213805 <dumpCurrentStackTrace+0x1615>
        const info = try openSelfDebugInfo(getDebugInfoAllocator());
  212365:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
  21236a:	48 89 44 24 68       	mov    QWORD PTR [rsp+0x68],rax
        self_debug_info = info;
  21236f:	48 89 05 a2 dc 03 00 	mov    QWORD PTR [rip+0x3dca2],rax        # 250018 <self_debug_info>
    if (debug_info_allocator) |a| return a;
  212376:	48 83 3d a2 dc 03 00 	cmp    QWORD PTR [rip+0x3dca2],0x0        # 250020 <debug_info_allocator>
  21237d:	00 
  21237e:	0f 85 b2 fe ff ff    	jne    212236 <dumpCurrentStackTrace+0x46>
    debug_info_direct_allocator = std.heap.DirectAllocator.init();
  212384:	c5 fc 10 05 ec cb 03 	vmovups ymm0,YMMWORD PTR [rip+0x3cbec]        # 24ef78 <__unnamed_15>
  21238b:	00 
  21238c:	c5 fc 11 05 bc 8c 03 	vmovups YMMWORD PTR [rip+0x38cbc],ymm0        # 24b050 <debug_info_direct_allocator>
  212393:	00 
    debug_info_arena_allocator = std.heap.ArenaAllocator.init(&debug_info_direct_allocator.allocator);
  212394:	c5 fa 6f 05 fc cb 03 	vmovdqu xmm0,XMMWORD PTR [rip+0x3cbfc]        # 24ef98 <__unnamed_16>
  21239b:	00 
  21239c:	c5 fa 7f 05 cc 8c 03 	vmovdqu XMMWORD PTR [rip+0x38ccc],xmm0        # 24b070 <debug_info_arena_allocator>
  2123a3:	00 
    debug_info_direct_allocator = std.heap.DirectAllocator.init();
  2123a4:	48 8d 05 a5 8c 03 00 	lea    rax,[rip+0x38ca5]        # 24b050 <debug_info_direct_allocator>
    debug_info_arena_allocator = std.heap.ArenaAllocator.init(&debug_info_direct_allocator.allocator);
  2123ab:	48 8b 0d f6 cb 03 00 	mov    rcx,QWORD PTR [rip+0x3cbf6]        # 24efa8 <__unnamed_16+0x10>
  2123b2:	48 89 0d c7 8c 03 00 	mov    QWORD PTR [rip+0x38cc7],rcx        # 24b080 <debug_info_arena_allocator+0x10>
  2123b9:	48 8d 0d b0 8c 03 00 	lea    rcx,[rip+0x38cb0]        # 24b070 <debug_info_arena_allocator>
  2123c0:	48 89 05 c1 8c 03 00 	mov    QWORD PTR [rip+0x38cc1],rax        # 24b088 <debug_info_arena_allocator+0x18>
  2123c7:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  2123cb:	c5 fe 7f 05 bd 8c 03 	vmovdqu YMMWORD PTR [rip+0x38cbd],ymm0        # 24b090 <debug_info_arena_allocator+0x20>
  2123d2:	00 
    debug_info_allocator = &debug_info_arena_allocator.allocator;
  2123d3:	48 89 0d 46 dc 03 00 	mov    QWORD PTR [rip+0x3dc46],rcx        # 250020 <debug_info_allocator>
  2123da:	48 8b 05 d7 8c 03 00 	mov    rax,QWORD PTR [rip+0x38cd7]        # 24b0b8 <posix_environ_raw+0x8>
  2123e1:	48 85 c0             	test   rax,rax
  2123e4:	48 89 5c 24 70       	mov    QWORD PTR [rsp+0x70],rbx
  2123e9:	0f 84 be 00 00 00    	je     2124ad <dumpCurrentStackTrace+0x2bd>
  2123ef:	48 8b 0d ba 8c 03 00 	mov    rcx,QWORD PTR [rip+0x38cba]        # 24b0b0 <posix_environ_raw>
  2123f6:	31 d2                	xor    edx,edx
  2123f8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  2123ff:	00 
  212400:	48 8b 34 d1          	mov    rsi,QWORD PTR [rcx+rdx*8]
  212404:	48 c7 c7 f1 ff ff ff 	mov    rdi,0xfffffffffffffff1
        var line_i: usize = 0;
        while (ptr[line_i] != 0 and ptr[line_i] != '=') : (line_i += 1) {}
  21240b:	8a 5c 3e 0f          	mov    bl,BYTE PTR [rsi+rdi*1+0xf]
  21240f:	84 db                	test   bl,bl
  212411:	74 1f                	je     212432 <dumpCurrentStackTrace+0x242>
  212413:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21241a:	84 00 00 00 00 00 
  212420:	80 fb 3d             	cmp    bl,0x3d
  212423:	74 0d                	je     212432 <dumpCurrentStackTrace+0x242>
  212425:	48 83 c7 01          	add    rdi,0x1
  212429:	0f b6 5c 3e 0f       	movzx  ebx,BYTE PTR [rsi+rdi*1+0xf]
  21242e:	84 db                	test   bl,bl
  212430:	75 ee                	jne    212420 <dumpCurrentStackTrace+0x230>
    if (a.len != b.len) return false;
  212432:	48 85 ff             	test   rdi,rdi
  212435:	75 69                	jne    2124a0 <dumpCurrentStackTrace+0x2b0>
        if (b[index] != item) return false;
  212437:	80 3e 5a             	cmp    BYTE PTR [rsi],0x5a
  21243a:	75 64                	jne    2124a0 <dumpCurrentStackTrace+0x2b0>
  21243c:	80 7e 01 49          	cmp    BYTE PTR [rsi+0x1],0x49
  212440:	75 5e                	jne    2124a0 <dumpCurrentStackTrace+0x2b0>
  212442:	80 7e 02 47          	cmp    BYTE PTR [rsi+0x2],0x47
  212446:	75 58                	jne    2124a0 <dumpCurrentStackTrace+0x2b0>
  212448:	80 7e 03 5f          	cmp    BYTE PTR [rsi+0x3],0x5f
  21244c:	75 52                	jne    2124a0 <dumpCurrentStackTrace+0x2b0>
  21244e:	80 7e 04 44          	cmp    BYTE PTR [rsi+0x4],0x44
  212452:	75 4c                	jne    2124a0 <dumpCurrentStackTrace+0x2b0>
  212454:	80 7e 05 45          	cmp    BYTE PTR [rsi+0x5],0x45
  212458:	75 46                	jne    2124a0 <dumpCurrentStackTrace+0x2b0>
  21245a:	80 7e 06 42          	cmp    BYTE PTR [rsi+0x6],0x42
  21245e:	75 40                	jne    2124a0 <dumpCurrentStackTrace+0x2b0>
  212460:	80 7e 07 55          	cmp    BYTE PTR [rsi+0x7],0x55
  212464:	75 3a                	jne    2124a0 <dumpCurrentStackTrace+0x2b0>
  212466:	80 7e 08 47          	cmp    BYTE PTR [rsi+0x8],0x47
  21246a:	75 34                	jne    2124a0 <dumpCurrentStackTrace+0x2b0>
  21246c:	80 7e 09 5f          	cmp    BYTE PTR [rsi+0x9],0x5f
  212470:	75 2e                	jne    2124a0 <dumpCurrentStackTrace+0x2b0>
  212472:	80 7e 0a 43          	cmp    BYTE PTR [rsi+0xa],0x43
  212476:	75 28                	jne    2124a0 <dumpCurrentStackTrace+0x2b0>
  212478:	80 7e 0b 4f          	cmp    BYTE PTR [rsi+0xb],0x4f
  21247c:	75 22                	jne    2124a0 <dumpCurrentStackTrace+0x2b0>
  21247e:	80 7e 0c 4c          	cmp    BYTE PTR [rsi+0xc],0x4c
  212482:	75 1c                	jne    2124a0 <dumpCurrentStackTrace+0x2b0>
  212484:	80 7e 0d 4f          	cmp    BYTE PTR [rsi+0xd],0x4f
  212488:	75 16                	jne    2124a0 <dumpCurrentStackTrace+0x2b0>
  21248a:	80 7e 0e 52          	cmp    BYTE PTR [rsi+0xe],0x52
  21248e:	0f 84 28 14 00 00    	je     2138bc <dumpCurrentStackTrace+0x16cc>
  212494:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21249b:	00 00 00 00 00 
    for (posix_environ_raw) |ptr| {
  2124a0:	48 83 c2 01          	add    rdx,0x1
  2124a4:	48 39 c2             	cmp    rdx,rax
  2124a7:	0f 82 53 ff ff ff    	jb     212400 <dumpCurrentStackTrace+0x210>
    return syscall3(SYS_ioctl, @intCast(usize, fd), TIOCGWINSZ, @ptrToInt(&wsz)) == 0;
  2124ad:	48 63 3d 7c 8b 03 00 	movsxd rdi,DWORD PTR [rip+0x38b7c]        # 24b030 <stderr_file>
  2124b4:	48 8d 54 24 20       	lea    rdx,[rsp+0x20]
    return asm volatile ("syscall"
  2124b9:	b8 10 00 00 00       	mov    eax,0x10
  2124be:	be 13 54 00 00       	mov    esi,0x5413
  2124c3:	0f 05                	syscall 
  2124c5:	48 85 c0             	test   rax,rax
  2124c8:	0f 94 44 24 07       	sete   BYTE PTR [rsp+0x7]
    if (start_addr) |addr| {
  2124cd:	41 80 7e 08 01       	cmp    BYTE PTR [r14+0x8],0x1
  2124d2:	48 8b 74 24 68       	mov    rsi,QWORD PTR [rsp+0x68]
  2124d7:	75 0f                	jne    2124e8 <dumpCurrentStackTrace+0x2f8>
  2124d9:	49 8b 0e             	mov    rcx,QWORD PTR [r14]
  2124dc:	b0 01                	mov    al,0x1
    while (fp != 0) : (fp = @intToPtr(*const usize, fp).*) {
  2124de:	48 85 ed             	test   rbp,rbp
  2124e1:	75 10                	jne    2124f3 <dumpCurrentStackTrace+0x303>
  2124e3:	e9 1d 13 00 00       	jmp    213805 <dumpCurrentStackTrace+0x1615>
  2124e8:	31 c0                	xor    eax,eax
  2124ea:	48 85 ed             	test   rbp,rbp
  2124ed:	0f 84 12 13 00 00    	je     213805 <dumpCurrentStackTrace+0x1615>
  2124f3:	48 89 ea             	mov    rdx,rbp
  2124f6:	c4 62 7d 59 25 11 de 	vpbroadcastq ymm12,QWORD PTR [rip+0xfffffffffffede11]        # 200310 <__unnamed_610+0x10>
  2124fd:	fe ff 
  2124ff:	c4 62 7d 59 2d 80 de 	vpbroadcastq ymm13,QWORD PTR [rip+0xfffffffffffede80]        # 200388 <__unnamed_609+0x48>
  212506:	fe ff 
  212508:	c5 7d 7f a4 24 00 01 	vmovdqa YMMWORD PTR [rsp+0x100],ymm12
  21250f:	00 00 
  212511:	c5 7d 7f ac 24 e0 00 	vmovdqa YMMWORD PTR [rsp+0xe0],ymm13
  212518:	00 00 
  21251a:	48 89 8c 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],rcx
  212521:	00 
  212522:	48 89 74 24 68       	mov    QWORD PTR [rsp+0x68],rsi
  212527:	e9 44 12 00 00       	jmp    213770 <dumpCurrentStackTrace+0x1580>
  21252c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  212530:	48 89 94 24 b0 00 00 	mov    QWORD PTR [rsp+0xb0],rdx
  212537:	00 
    var in_file_stream = io.FileInStream.init(&st.self_exe_file);
  212538:	48 89 b4 24 c8 00 00 	mov    QWORD PTR [rsp+0xc8],rsi
  21253f:	00 
  212540:	48 8d 05 89 27 01 00 	lea    rax,[rip+0x12789]        # 224cd0 <FileInStream_readFn>
  212547:	48 89 84 24 d0 00 00 	mov    QWORD PTR [rsp+0xd0],rax
  21254e:	00 
        pub fn deinit(self: Self) void {
            self.allocator.free(self.items);
        }

        pub fn toSlice(self: Self) []align(A) T {
            return self.items[0..self.len];
  21254f:	48 8b 86 b8 00 00 00 	mov    rax,QWORD PTR [rsi+0xb8]
  212556:	48 89 44 24 78       	mov    QWORD PTR [rsp+0x78],rax
    for (st.compile_unit_list.toSlice()) |*compile_unit| {
  21255b:	48 85 c0             	test   rax,rax
  21255e:	0f 84 6c 04 00 00    	je     2129d0 <dumpCurrentStackTrace+0x7e0>
  212564:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  212569:	4c 8b 88 a8 00 00 00 	mov    r9,QWORD PTR [rax+0xa8]
  212570:	45 31 e4             	xor    r12d,r12d
  212573:	e9 08 02 00 00       	jmp    212780 <dumpCurrentStackTrace+0x590>
                result = (result << 8) | b;
            }
        },
        builtin.Endian.Little => {
            const ShiftType = math.Log2Int(T);
            for (bytes) |b, index| {
  212578:	48 89 c3             	mov    rbx,rax
  21257b:	48 83 e3 f0          	and    rbx,0xfffffffffffffff0
  21257f:	48 8d 73 f0          	lea    rsi,[rbx-0x10]
  212583:	48 89 f7             	mov    rdi,rsi
  212586:	48 c1 ef 04          	shr    rdi,0x4
  21258a:	44 8d 47 01          	lea    r8d,[rdi+0x1]
  21258e:	41 83 e0 01          	and    r8d,0x1
  212592:	48 85 f6             	test   rsi,rsi
  212595:	0f 84 bd 01 00 00    	je     212758 <dumpCurrentStackTrace+0x568>
  21259b:	49 8d 70 ff          	lea    rsi,[r8-0x1]
  21259f:	48 29 fe             	sub    rsi,rdi
  2125a2:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  2125a6:	31 ff                	xor    edi,edi
  2125a8:	c5 fd 6f 25 f0 db fe 	vmovdqa ymm4,YMMWORD PTR [rip+0xfffffffffffedbf0]        # 2001a0 <__unnamed_44-0x60>
  2125af:	ff 
  2125b0:	c5 f1 ef c9          	vpxor  xmm1,xmm1,xmm1
  2125b4:	c5 e1 ef db          	vpxor  xmm3,xmm3,xmm3
  2125b8:	c5 e9 ef d2          	vpxor  xmm2,xmm2,xmm2
  2125bc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  2125c0:	c4 e2 7d 32 2c 39    	vpmovzxbq ymm5,DWORD PTR [rcx+rdi*1]
  2125c6:	c4 e2 7d 32 74 39 04 	vpmovzxbq ymm6,DWORD PTR [rcx+rdi*1+0x4]
  2125cd:	c4 e2 7d 32 7c 39 08 	vpmovzxbq ymm7,DWORD PTR [rcx+rdi*1+0x8]
  2125d4:	c4 62 7d 32 44 39 0c 	vpmovzxbq ymm8,DWORD PTR [rcx+rdi*1+0xc]
  2125db:	c5 b5 73 f4 03       	vpsllq ymm9,ymm4,0x3
  2125e0:	c4 41 35 d4 d4       	vpaddq ymm10,ymm9,ymm12
  2125e5:	c4 41 35 db dd       	vpand  ymm11,ymm9,ymm13
  2125ea:	c4 41 2d db d5       	vpand  ymm10,ymm10,ymm13
  2125ef:	c4 c2 d5 47 eb       	vpsllvq ymm5,ymm5,ymm11
  2125f4:	c5 d5 eb c0          	vpor   ymm0,ymm5,ymm0
  2125f8:	c4 c2 cd 47 ea       	vpsllvq ymm5,ymm6,ymm10
  2125fd:	c5 d5 eb c9          	vpor   ymm1,ymm5,ymm1
  212601:	c4 c2 c5 47 eb       	vpsllvq ymm5,ymm7,ymm11
  212606:	c5 d5 eb db          	vpor   ymm3,ymm5,ymm3
  21260a:	c4 c2 bd 47 ea       	vpsllvq ymm5,ymm8,ymm10
  21260f:	c4 e2 7d 32 74 39 10 	vpmovzxbq ymm6,DWORD PTR [rcx+rdi*1+0x10]
  212616:	c4 e2 7d 32 7c 39 14 	vpmovzxbq ymm7,DWORD PTR [rcx+rdi*1+0x14]
  21261d:	c4 62 7d 32 44 39 18 	vpmovzxbq ymm8,DWORD PTR [rcx+rdi*1+0x18]
  212624:	c5 d5 eb d2          	vpor   ymm2,ymm5,ymm2
  212628:	c4 e2 7d 32 6c 39 1c 	vpmovzxbq ymm5,DWORD PTR [rcx+rdi*1+0x1c]
  21262f:	c4 62 7d 59 15 40 dd 	vpbroadcastq ymm10,QWORD PTR [rip+0xfffffffffffedd40]        # 200378 <__unnamed_609+0x38>
  212636:	fe ff 
  212638:	c4 41 35 d4 d2       	vpaddq ymm10,ymm9,ymm10
  21263d:	c4 62 7d 59 1d 62 dc 	vpbroadcastq ymm11,QWORD PTR [rip+0xfffffffffffedc62]        # 2002a8 <__unnamed_10+0x28>
  212644:	fe ff 
  212646:	c4 41 35 d4 cb       	vpaddq ymm9,ymm9,ymm11
  21264b:	c4 41 2d db d5       	vpand  ymm10,ymm10,ymm13
  212650:	c4 41 35 db cd       	vpand  ymm9,ymm9,ymm13
  212655:	c4 c2 cd 47 f2       	vpsllvq ymm6,ymm6,ymm10
  21265a:	c5 cd eb c0          	vpor   ymm0,ymm6,ymm0
  21265e:	c4 c2 c5 47 f1       	vpsllvq ymm6,ymm7,ymm9
  212663:	c5 cd eb c9          	vpor   ymm1,ymm6,ymm1
  212667:	c4 c2 bd 47 f2       	vpsllvq ymm6,ymm8,ymm10
  21266c:	c5 cd eb db          	vpor   ymm3,ymm6,ymm3
  212670:	c4 c2 d5 47 e9       	vpsllvq ymm5,ymm5,ymm9
  212675:	c5 d5 eb d2          	vpor   ymm2,ymm5,ymm2
            for (bytes) |b, index| {
  212679:	48 83 c7 20          	add    rdi,0x20
  21267d:	c4 c1 5d d4 e4       	vpaddq ymm4,ymm4,ymm12
  212682:	48 83 c6 02          	add    rsi,0x2
  212686:	0f 85 34 ff ff ff    	jne    2125c0 <dumpCurrentStackTrace+0x3d0>
  21268c:	4d 85 c0             	test   r8,r8
  21268f:	74 53                	je     2126e4 <dumpCurrentStackTrace+0x4f4>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  212691:	c4 e2 7d 32 6c 39 0c 	vpmovzxbq ymm5,DWORD PTR [rcx+rdi*1+0xc]
  212698:	c5 dd 73 f4 03       	vpsllq ymm4,ymm4,0x3
  21269d:	c4 c1 5d d4 f4       	vpaddq ymm6,ymm4,ymm12
  2126a2:	c4 c1 4d db f5       	vpand  ymm6,ymm6,ymm13
  2126a7:	c4 e2 d5 47 ee       	vpsllvq ymm5,ymm5,ymm6
  2126ac:	c4 e2 7d 32 7c 39 08 	vpmovzxbq ymm7,DWORD PTR [rcx+rdi*1+0x8]
  2126b3:	c5 d5 eb d2          	vpor   ymm2,ymm5,ymm2
  2126b7:	c4 c1 5d db e5       	vpand  ymm4,ymm4,ymm13
  2126bc:	c4 e2 c5 47 ec       	vpsllvq ymm5,ymm7,ymm4
  2126c1:	c5 d5 eb db          	vpor   ymm3,ymm5,ymm3
  2126c5:	c4 e2 7d 32 6c 39 04 	vpmovzxbq ymm5,DWORD PTR [rcx+rdi*1+0x4]
  2126cc:	c4 e2 d5 47 ee       	vpsllvq ymm5,ymm5,ymm6
  2126d1:	c5 d5 eb c9          	vpor   ymm1,ymm5,ymm1
  2126d5:	c4 e2 7d 32 2c 39    	vpmovzxbq ymm5,DWORD PTR [rcx+rdi*1]
  2126db:	c4 e2 d5 47 e4       	vpsllvq ymm4,ymm5,ymm4
  2126e0:	c5 dd eb c0          	vpor   ymm0,ymm4,ymm0
  2126e4:	c5 f5 eb ca          	vpor   ymm1,ymm1,ymm2
  2126e8:	c5 fd eb c3          	vpor   ymm0,ymm0,ymm3
  2126ec:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  2126f0:	c4 e3 7d 39 c1 01    	vextracti128 xmm1,ymm0,0x1
  2126f6:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  2126fa:	c5 f9 70 c8 4e       	vpshufd xmm1,xmm0,0x4e
  2126ff:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  212703:	c4 e1 f9 7e c6       	vmovq  rsi,xmm0
  212708:	48 39 d8             	cmp    rax,rbx
            for (bytes) |b, index| {
  21270b:	74 31                	je     21273e <dumpCurrentStackTrace+0x54e>
  21270d:	48 29 d8             	sub    rax,rbx
  212710:	48 01 d9             	add    rcx,rbx
  212713:	48 c1 e3 03          	shl    rbx,0x3
  212717:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  21271e:	00 00 
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  212720:	0f b6 39             	movzx  edi,BYTE PTR [rcx]
  212723:	89 da                	mov    edx,ebx
  212725:	80 e2 38             	and    dl,0x38
  212728:	c4 e2 e9 f7 d7       	shlx   rdx,rdi,rdx
  21272d:	48 09 d6             	or     rsi,rdx
            for (bytes) |b, index| {
  212730:	48 83 c3 08          	add    rbx,0x8
  212734:	48 83 c1 01          	add    rcx,0x1
  212738:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  21273c:	75 e2                	jne    212720 <dumpCurrentStackTrace+0x530>
            if (st.debug_ranges) |debug_ranges| {
  21273e:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  212743:	48 8b 80 80 00 00 00 	mov    rax,QWORD PTR [rax+0x80]
  21274a:	48 85 c0             	test   rax,rax
  21274d:	0f 85 fd 00 00 00    	jne    212850 <dumpCurrentStackTrace+0x660>
  212753:	e9 68 02 00 00       	jmp    2129c0 <dumpCurrentStackTrace+0x7d0>
  212758:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  21275c:	31 ff                	xor    edi,edi
  21275e:	c5 fd 6f 25 3a da fe 	vmovdqa ymm4,YMMWORD PTR [rip+0xfffffffffffeda3a]        # 2001a0 <__unnamed_44-0x60>
  212765:	ff 
  212766:	c5 f1 ef c9          	vpxor  xmm1,xmm1,xmm1
  21276a:	c5 e1 ef db          	vpxor  xmm3,xmm3,xmm3
  21276e:	c5 e9 ef d2          	vpxor  xmm2,xmm2,xmm2
  212772:	4d 85 c0             	test   r8,r8
  212775:	0f 85 16 ff ff ff    	jne    212691 <dumpCurrentStackTrace+0x4a1>
  21277b:	e9 64 ff ff ff       	jmp    2126e4 <dumpCurrentStackTrace+0x4f4>
        if (compile_unit.pc_range) |range| {
  212780:	4f 8d 34 64          	lea    r14,[r12+r12*2]
  212784:	49 c1 e6 04          	shl    r14,0x4
  212788:	43 80 7c 31 28 01    	cmp    BYTE PTR [r9+r14*1+0x28],0x1
  21278e:	75 12                	jne    2127a2 <dumpCurrentStackTrace+0x5b2>
            if (target_address >= range.start and target_address < range.end) return compile_unit;
  212790:	4f 39 6c 31 18       	cmp    QWORD PTR [r9+r14*1+0x18],r13
  212795:	77 0b                	ja     2127a2 <dumpCurrentStackTrace+0x5b2>
  212797:	4f 39 6c 31 20       	cmp    QWORD PTR [r9+r14*1+0x20],r13
  21279c:	0f 87 4c 04 00 00    	ja     212bee <dumpCurrentStackTrace+0x9fe>
        if (compile_unit.die.getAttrSecOffset(DW.AT_ranges)) |ranges_offset| {
  2127a2:	4b 8b 4c 31 08       	mov    rcx,QWORD PTR [r9+r14*1+0x8]
  2127a7:	48 8b 41 20          	mov    rax,QWORD PTR [rcx+0x20]
        for (self.attrs.toSliceConst()) |*attr| {
  2127ab:	48 85 c0             	test   rax,rax
  2127ae:	0f 84 0c 02 00 00    	je     2129c0 <dumpCurrentStackTrace+0x7d0>
  2127b4:	4b 8d 14 31          	lea    rdx,[r9+r14*1]
  2127b8:	48 83 c2 08          	add    rdx,0x8
  2127bc:	48 89 94 24 38 01 00 	mov    QWORD PTR [rsp+0x138],rdx
  2127c3:	00 
  2127c4:	48 8b 49 10          	mov    rcx,QWORD PTR [rcx+0x10]
            if (attr.id == id) return &attr.value;
  2127c8:	48 83 c1 20          	add    rcx,0x20
  2127cc:	31 d2                	xor    edx,edx
  2127ce:	66 90                	xchg   ax,ax
  2127d0:	48 83 79 e0 55       	cmp    QWORD PTR [rcx-0x20],0x55
  2127d5:	74 19                	je     2127f0 <dumpCurrentStackTrace+0x600>
        for (self.attrs.toSliceConst()) |*attr| {
  2127d7:	48 83 c2 01          	add    rdx,0x1
  2127db:	48 83 c1 28          	add    rcx,0x28
  2127df:	48 39 c2             	cmp    rdx,rax
  2127e2:	72 ec                	jb     2127d0 <dumpCurrentStackTrace+0x5e0>
  2127e4:	e9 d7 01 00 00       	jmp    2129c0 <dumpCurrentStackTrace+0x7d0>
  2127e9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  2127f0:	8a 01                	mov    al,BYTE PTR [rcx]
  2127f2:	3c 05                	cmp    al,0x5
        return switch (form_value.*) {
  2127f4:	74 41                	je     212837 <dumpCurrentStackTrace+0x647>
  2127f6:	3c 02                	cmp    al,0x2
  2127f8:	0f 85 d2 01 00 00    	jne    2129d0 <dumpCurrentStackTrace+0x7e0>
            FormValue.Const => |value| value.asUnsignedLe(),
  2127fe:	48 8b 41 f0          	mov    rax,QWORD PTR [rcx-0x10]
        if (self.payload.len > @sizeOf(u64)) return error.InvalidDebugInfo;
  212802:	48 83 f8 08          	cmp    rax,0x8
  212806:	0f 87 c4 01 00 00    	ja     2129d0 <dumpCurrentStackTrace+0x7e0>
            FormValue.Const => |value| value.asUnsignedLe(),
  21280c:	8a 51 f8             	mov    dl,BYTE PTR [rcx-0x8]
        if (self.signed) return error.InvalidDebugInfo;
  21280f:	84 d2                	test   dl,dl
  212811:	0f 85 b9 01 00 00    	jne    2129d0 <dumpCurrentStackTrace+0x7e0>
  212817:	48 85 c0             	test   rax,rax
  21281a:	0f 84 7c 01 00 00    	je     21299c <dumpCurrentStackTrace+0x7ac>
  212820:	48 8b 49 e8          	mov    rcx,QWORD PTR [rcx-0x18]
  212824:	48 83 f8 10          	cmp    rax,0x10
  212828:	0f 83 4a fd ff ff    	jae    212578 <dumpCurrentStackTrace+0x388>
  21282e:	31 db                	xor    ebx,ebx
  212830:	31 f6                	xor    esi,esi
  212832:	e9 d6 fe ff ff       	jmp    21270d <dumpCurrentStackTrace+0x51d>
            FormValue.SecOffset => |value| value,
  212837:	48 8b 71 e8          	mov    rsi,QWORD PTR [rcx-0x18]
            if (st.debug_ranges) |debug_ranges| {
  21283b:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  212840:	48 8b 80 80 00 00 00 	mov    rax,QWORD PTR [rax+0x80]
  212847:	48 85 c0             	test   rax,rax
  21284a:	0f 84 70 01 00 00    	je     2129c0 <dumpCurrentStackTrace+0x7d0>
/// Cast an integer to a different integer type. If the value doesn't fit,
/// return an error.
pub fn cast(comptime T: type, x: var) (error{Overflow}!T) {
    comptime assert(@typeId(T) == builtin.TypeId.Int); // must pass an integer
    comptime assert(@typeId(@typeOf(x)) == builtin.TypeId.Int); // must pass an integer
    if (@maxValue(@typeOf(x)) > @maxValue(T) and x > @maxValue(T)) {
  212850:	48 03 70 18          	add    rsi,QWORD PTR [rax+0x18]
  212854:	0f 88 76 01 00 00    	js     2129d0 <dumpCurrentStackTrace+0x7e0>
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  21285a:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  21285f:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  212862:	b8 08 00 00 00       	mov    eax,0x8
  212867:	31 d2                	xor    edx,edx
  212869:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  21286b:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
        switch (builtin.os) {
            Os.linux, Os.macosx, Os.ios => {
                const ipos = try math.cast(isize, pos);
                const result = posix.lseek(self.handle, ipos, posix.SEEK_SET);
                const err = posix.getErrno(result);
                if (err > 0) {
  212871:	0f 83 59 01 00 00    	jae    2129d0 <dumpCurrentStackTrace+0x7e0>
  212877:	4c 89 cb             	mov    rbx,r9
            try self.readNoEof(bytes[0..]);
  21287a:	48 8d 84 24 b8 00 00 	lea    rax,[rsp+0xb8]
  212881:	00 
  212882:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  212887:	48 c7 44 24 10 08 00 	mov    QWORD PTR [rsp+0x10],0x8
  21288e:	00 00 
            return self.readFn(self, buffer);
  212890:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  212895:	48 8d b4 24 d0 00 00 	lea    rsi,[rsp+0xd0]
  21289c:	00 
  21289d:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
  2128a2:	c5 f8 77             	vzeroupper 
  2128a5:	ff 94 24 d0 00 00 00 	call   QWORD PTR [rsp+0xd0]
            const amt_read = try self.read(buf);
  2128ac:	66 83 7c 24 20 00    	cmp    WORD PTR [rsp+0x20],0x0
  2128b2:	0f 85 18 01 00 00    	jne    2129d0 <dumpCurrentStackTrace+0x7e0>
  2128b8:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
  2128bd:	0f 1f 00             	nop    DWORD PTR [rax]
            if (amt_read < buf.len) return error.EndOfStream;
  2128c0:	48 3b 44 24 10       	cmp    rax,QWORD PTR [rsp+0x10]
  2128c5:	0f 82 05 01 00 00    	jb     2129d0 <dumpCurrentStackTrace+0x7e0>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  2128cb:	4c 8b bc 24 b8 00 00 	mov    r15,QWORD PTR [rsp+0xb8]
  2128d2:	00 
            try self.readNoEof(bytes[0..]);
  2128d3:	48 8d 84 24 b8 00 00 	lea    rax,[rsp+0xb8]
  2128da:	00 
  2128db:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  2128e0:	48 c7 44 24 10 08 00 	mov    QWORD PTR [rsp+0x10],0x8
  2128e7:	00 00 
            return self.readFn(self, buffer);
  2128e9:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  2128ee:	48 8d b4 24 d0 00 00 	lea    rsi,[rsp+0xd0]
  2128f5:	00 
  2128f6:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
  2128fb:	ff 94 24 d0 00 00 00 	call   QWORD PTR [rsp+0xd0]
            const amt_read = try self.read(buf);
  212902:	66 83 7c 24 20 00    	cmp    WORD PTR [rsp+0x20],0x0
  212908:	0f 85 c2 00 00 00    	jne    2129d0 <dumpCurrentStackTrace+0x7e0>
  21290e:	48 8b 44 24 10       	mov    rax,QWORD PTR [rsp+0x10]
  212913:	48 39 44 24 28       	cmp    QWORD PTR [rsp+0x28],rax
  212918:	0f 82 b2 00 00 00    	jb     2129d0 <dumpCurrentStackTrace+0x7e0>
  21291e:	48 8b 84 24 b8 00 00 	mov    rax,QWORD PTR [rsp+0xb8]
  212925:	00 
                    if (begin_addr == 0 and end_addr == 0) {
  212926:	48 89 c1             	mov    rcx,rax
  212929:	4c 09 f9             	or     rcx,r15
  21292c:	c5 7d 6f a4 24 00 01 	vmovdqa ymm12,YMMWORD PTR [rsp+0x100]
  212933:	00 00 
  212935:	c5 7d 6f ac 24 e0 00 	vmovdqa ymm13,YMMWORD PTR [rsp+0xe0]
  21293c:	00 00 
  21293e:	49 89 d9             	mov    r9,rbx
  212941:	74 7d                	je     2129c0 <dumpCurrentStackTrace+0x7d0>
                    if (begin_addr == @maxValue(usize)) {
  212943:	49 83 ff ff          	cmp    r15,0xffffffffffffffff
  212947:	74 0e                	je     212957 <dumpCurrentStackTrace+0x767>
                    if (target_address >= begin_addr and target_address < end_addr) {
  212949:	4d 39 ef             	cmp    r15,r13
  21294c:	77 09                	ja     212957 <dumpCurrentStackTrace+0x767>
  21294e:	4c 39 e8             	cmp    rax,r13
  212951:	0f 87 8d 02 00 00    	ja     212be4 <dumpCurrentStackTrace+0x9f4>
            try self.readNoEof(bytes[0..]);
  212957:	48 8d 84 24 b8 00 00 	lea    rax,[rsp+0xb8]
  21295e:	00 
  21295f:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  212964:	48 c7 44 24 10 08 00 	mov    QWORD PTR [rsp+0x10],0x8
  21296b:	00 00 
            return self.readFn(self, buffer);
  21296d:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  212972:	48 8d b4 24 d0 00 00 	lea    rsi,[rsp+0xd0]
  212979:	00 
  21297a:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
  21297f:	c5 f8 77             	vzeroupper 
  212982:	ff 94 24 d0 00 00 00 	call   QWORD PTR [rsp+0xd0]
  212989:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  21298e:	66 83 7c 24 20 00    	cmp    WORD PTR [rsp+0x20],0x0
  212994:	0f 84 26 ff ff ff    	je     2128c0 <dumpCurrentStackTrace+0x6d0>
  21299a:	eb 34                	jmp    2129d0 <dumpCurrentStackTrace+0x7e0>
        return switch (form_value.*) {
  21299c:	31 f6                	xor    esi,esi
            if (st.debug_ranges) |debug_ranges| {
  21299e:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  2129a3:	48 8b 80 80 00 00 00 	mov    rax,QWORD PTR [rax+0x80]
  2129aa:	48 85 c0             	test   rax,rax
  2129ad:	0f 85 9d fe ff ff    	jne    212850 <dumpCurrentStackTrace+0x660>
  2129b3:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  2129ba:	84 00 00 00 00 00 
    for (st.compile_unit_list.toSlice()) |*compile_unit| {
  2129c0:	49 83 c4 01          	add    r12,0x1
  2129c4:	4c 3b 64 24 78       	cmp    r12,QWORD PTR [rsp+0x78]
  2129c9:	0f 82 b1 fd ff ff    	jb     212780 <dumpCurrentStackTrace+0x590>
  2129cf:	90                   	nop
  2129d0:	4c 8b 64 24 70       	mov    r12,QWORD PTR [rsp+0x70]
            return std.fmt.format(self, Error, self.writeFn, format, args);
  2129d5:	4d 8b 34 24          	mov    r14,QWORD PTR [r12]
                if (tty_color) {
  2129d9:	80 7c 24 07 00       	cmp    BYTE PTR [rsp+0x7],0x0
  2129de:	74 70                	je     212a50 <dumpCurrentStackTrace+0x860>
                        try output(context, fmt[start_index..i]);
  2129e0:	4c 89 e7             	mov    rdi,r12
  2129e3:	48 8d 35 4e c4 03 00 	lea    rsi,[rip+0x3c44e]        # 24ee38 <__unnamed_19>
  2129ea:	c5 f8 77             	vzeroupper 
  2129ed:	41 ff d6             	call   r14
  2129f0:	41 89 c7             	mov    r15d,eax
  2129f3:	66 45 85 ff          	test   r15w,r15w
  2129f7:	0f 85 a3 01 00 00    	jne    212ba0 <dumpCurrentStackTrace+0x9b0>
    comptime Errors: type,
    output: fn (@typeOf(context), []const u8) Errors!void,
) Errors!void {
    // max_int_digits accounts for the minus sign. when printing an unsigned
    // number we don't need to do that.
    var buf: [max_int_digits - 1]u8 = undefined;
  2129fd:	c5 fc 10 05 4a 62 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffff624a]        # 208c4f <__unnamed_20+0x1f>
  212a04:	ff 
  212a05:	c5 fc 11 44 24 3f    	vmovups YMMWORD PTR [rsp+0x3f],ymm0
  212a0b:	c5 fe 6f 05 1d 62 ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffff621d]        # 208c30 <__unnamed_20>
  212a12:	ff 
  212a13:	c5 fe 7f 44 24 20    	vmovdqu YMMWORD PTR [rsp+0x20],ymm0
    var index: usize = buf.len;

    while (true) {
        const digit = a % base;
        index -= 1;
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  212a19:	44 89 e8             	mov    eax,r13d
  212a1c:	24 0f                	and    al,0xf
    return value;
}

fn digitToChar(digit: u8, uppercase: bool) u8 {
    return switch (digit) {
        0...9 => digit + '0',
  212a1e:	b1 30                	mov    cl,0x30
  212a20:	3c 0a                	cmp    al,0xa
  212a22:	72 02                	jb     212a26 <dumpCurrentStackTrace+0x836>
  212a24:	b1 57                	mov    cl,0x57
  212a26:	00 c1                	add    cl,al
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  212a28:	88 4c 24 5f          	mov    BYTE PTR [rsp+0x5f],cl
  212a2c:	b8 40 00 00 00       	mov    eax,0x40
        if (a == 0) break;
  212a31:	49 83 fd 10          	cmp    r13,0x10
  212a35:	73 7e                	jae    212ab5 <dumpCurrentStackTrace+0x8c5>
  212a37:	48 8d 4c 24 5f       	lea    rcx,[rsp+0x5f]
  212a3c:	e9 af 00 00 00       	jmp    212af0 <dumpCurrentStackTrace+0x900>
  212a41:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  212a48:	0f 1f 84 00 00 00 00 
  212a4f:	00 
                        try output(context, fmt[start_index..i]);
  212a50:	4c 89 e7             	mov    rdi,r12
  212a53:	48 8d 35 fe c3 03 00 	lea    rsi,[rip+0x3c3fe]        # 24ee58 <__unnamed_21>
  212a5a:	c5 f8 77             	vzeroupper 
  212a5d:	41 ff d6             	call   r14
  212a60:	41 89 c7             	mov    r15d,eax
  212a63:	66 45 85 ff          	test   r15w,r15w
  212a67:	0f 85 33 01 00 00    	jne    212ba0 <dumpCurrentStackTrace+0x9b0>
    var buf: [max_int_digits - 1]u8 = undefined;
  212a6d:	c5 fc 10 05 da 61 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffff61da]        # 208c4f <__unnamed_20+0x1f>
  212a74:	ff 
  212a75:	c5 fc 11 44 24 3f    	vmovups YMMWORD PTR [rsp+0x3f],ymm0
  212a7b:	c5 fe 6f 05 ad 61 ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffff61ad]        # 208c30 <__unnamed_20>
  212a82:	ff 
  212a83:	c5 fe 7f 44 24 20    	vmovdqu YMMWORD PTR [rsp+0x20],ymm0
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  212a89:	44 89 e8             	mov    eax,r13d
  212a8c:	24 0f                	and    al,0xf
        0...9 => digit + '0',
  212a8e:	b1 30                	mov    cl,0x30
  212a90:	3c 0a                	cmp    al,0xa
  212a92:	72 02                	jb     212a96 <dumpCurrentStackTrace+0x8a6>
  212a94:	b1 57                	mov    cl,0x57
  212a96:	00 c1                	add    cl,al
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  212a98:	88 4c 24 5f          	mov    BYTE PTR [rsp+0x5f],cl
  212a9c:	b8 40 00 00 00       	mov    eax,0x40
        if (a == 0) break;
  212aa1:	49 83 fd 10          	cmp    r13,0x10
  212aa5:	0f 83 7e 00 00 00    	jae    212b29 <dumpCurrentStackTrace+0x939>
  212aab:	48 8d 4c 24 5f       	lea    rcx,[rsp+0x5f]
  212ab0:	e9 ab 00 00 00       	jmp    212b60 <dumpCurrentStackTrace+0x970>
        a /= base;
  212ab5:	4c 89 e9             	mov    rcx,r13
  212ab8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  212abf:	00 
  212ac0:	48 c1 e9 04          	shr    rcx,0x4
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  212ac4:	89 ca                	mov    edx,ecx
  212ac6:	80 e2 0f             	and    dl,0xf
        0...9 => digit + '0',
  212ac9:	b3 30                	mov    bl,0x30
  212acb:	80 fa 0a             	cmp    dl,0xa
  212ace:	72 02                	jb     212ad2 <dumpCurrentStackTrace+0x8e2>
  212ad0:	b3 57                	mov    bl,0x57
  212ad2:	00 d3                	add    bl,dl
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  212ad4:	88 5c 04 1e          	mov    BYTE PTR [rsp+rax*1+0x1e],bl
        if (a == 0) break;
  212ad8:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  212adc:	49 81 fd ff 00 00 00 	cmp    r13,0xff
  212ae3:	49 89 cd             	mov    r13,rcx
  212ae6:	77 d8                	ja     212ac0 <dumpCurrentStackTrace+0x8d0>
        const padded_buf = buf[index - padding ..];
  212ae8:	48 8d 0c 04          	lea    rcx,[rsp+rax*1]
  212aec:	48 83 c1 1f          	add    rcx,0x1f
  212af0:	ba 41 00 00 00       	mov    edx,0x41
  212af5:	48 29 c2             	sub    rdx,rax
  212af8:	48 89 4c 24 08       	mov    QWORD PTR [rsp+0x8],rcx
  212afd:	48 89 54 24 10       	mov    QWORD PTR [rsp+0x10],rdx
        return output(context, padded_buf);
  212b02:	4c 89 e7             	mov    rdi,r12
  212b05:	48 8d 74 24 08       	lea    rsi,[rsp+0x8]
  212b0a:	c5 f8 77             	vzeroupper 
  212b0d:	41 ff d6             	call   r14
  212b10:	41 89 c7             	mov    r15d,eax
                    try formatType(args[next_arg], fmt[s..i], context, Errors, output);
  212b13:	66 45 85 ff          	test   r15w,r15w
  212b17:	0f 85 83 00 00 00    	jne    212ba0 <dumpCurrentStackTrace+0x9b0>
        try output(context, fmt[start_index..]);
  212b1d:	4c 89 e7             	mov    rdi,r12
  212b20:	48 8d 35 21 c3 03 00 	lea    rsi,[rip+0x3c321]        # 24ee48 <__unnamed_22>
  212b27:	eb 6a                	jmp    212b93 <dumpCurrentStackTrace+0x9a3>
        a /= base;
  212b29:	4c 89 e9             	mov    rcx,r13
  212b2c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  212b30:	48 c1 e9 04          	shr    rcx,0x4
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  212b34:	89 ca                	mov    edx,ecx
  212b36:	80 e2 0f             	and    dl,0xf
        0...9 => digit + '0',
  212b39:	b3 30                	mov    bl,0x30
  212b3b:	80 fa 0a             	cmp    dl,0xa
  212b3e:	72 02                	jb     212b42 <dumpCurrentStackTrace+0x952>
  212b40:	b3 57                	mov    bl,0x57
  212b42:	00 d3                	add    bl,dl
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  212b44:	88 5c 04 1e          	mov    BYTE PTR [rsp+rax*1+0x1e],bl
        if (a == 0) break;
  212b48:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  212b4c:	49 81 fd ff 00 00 00 	cmp    r13,0xff
  212b53:	49 89 cd             	mov    r13,rcx
  212b56:	77 d8                	ja     212b30 <dumpCurrentStackTrace+0x940>
        const padded_buf = buf[index - padding ..];
  212b58:	48 8d 0c 04          	lea    rcx,[rsp+rax*1]
  212b5c:	48 83 c1 1f          	add    rcx,0x1f
  212b60:	ba 41 00 00 00       	mov    edx,0x41
  212b65:	48 29 c2             	sub    rdx,rax
  212b68:	48 89 4c 24 08       	mov    QWORD PTR [rsp+0x8],rcx
  212b6d:	48 89 54 24 10       	mov    QWORD PTR [rsp+0x10],rdx
        return output(context, padded_buf);
  212b72:	4c 89 e7             	mov    rdi,r12
  212b75:	48 8d 74 24 08       	lea    rsi,[rsp+0x8]
  212b7a:	c5 f8 77             	vzeroupper 
  212b7d:	41 ff d6             	call   r14
  212b80:	41 89 c7             	mov    r15d,eax
                    try formatType(args[next_arg], fmt[s..i], context, Errors, output);
  212b83:	66 45 85 ff          	test   r15w,r15w
  212b87:	75 17                	jne    212ba0 <dumpCurrentStackTrace+0x9b0>
        try output(context, fmt[start_index..]);
  212b89:	4c 89 e7             	mov    rdi,r12
  212b8c:	48 8d 35 d5 c2 03 00 	lea    rsi,[rip+0x3c2d5]        # 24ee68 <__unnamed_23>
  212b93:	41 ff d6             	call   r14
  212b96:	41 89 c7             	mov    r15d,eax
  212b99:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  212ba0:	c5 7d 6f a4 24 00 01 	vmovdqa ymm12,YMMWORD PTR [rsp+0x100]
  212ba7:	00 00 
  212ba9:	c5 7d 6f ac 24 e0 00 	vmovdqa ymm13,YMMWORD PTR [rsp+0xe0]
  212bb0:	00 00 
        try printSourceAtAddress(debug_info, out_stream, return_address, tty_color);
  212bb2:	66 45 85 ff          	test   r15w,r15w
  212bb6:	0f 85 fc 0b 00 00    	jne    2137b8 <dumpCurrentStackTrace+0x15c8>
  212bbc:	31 c0                	xor    eax,eax
  212bbe:	48 8b 8c 24 a8 00 00 	mov    rcx,QWORD PTR [rsp+0xa8]
  212bc5:	00 
  212bc6:	48 8b 94 24 b0 00 00 	mov    rdx,QWORD PTR [rsp+0xb0]
  212bcd:	00 
  212bce:	48 8b 74 24 68       	mov    rsi,QWORD PTR [rsp+0x68]
    while (fp != 0) : (fp = @intToPtr(*const usize, fp).*) {
  212bd3:	48 8b 12             	mov    rdx,QWORD PTR [rdx]
  212bd6:	48 85 d2             	test   rdx,rdx
  212bd9:	0f 85 91 0b 00 00    	jne    213770 <dumpCurrentStackTrace+0x1580>
  212bdf:	e9 21 0c 00 00       	jmp    213805 <dumpCurrentStackTrace+0x1615>
  212be4:	48 8b 84 24 38 01 00 	mov    rax,QWORD PTR [rsp+0x138]
  212beb:	00 
  212bec:	eb 08                	jmp    212bf6 <dumpCurrentStackTrace+0xa06>
            const compile_unit_name = try compile_unit.die.getAttrString(debug_info, DW.AT_name);
  212bee:	4b 8d 04 31          	lea    rax,[r9+r14*1]
  212bf2:	48 83 c0 08          	add    rax,0x8
  212bf6:	48 8b 00             	mov    rax,QWORD PTR [rax]
        }

        pub fn toSliceConst(self: Self) []align(A) const T {
            return self.items[0..self.len];
  212bf9:	48 8b 48 20          	mov    rcx,QWORD PTR [rax+0x20]
        for (self.attrs.toSliceConst()) |*attr| {
  212bfd:	48 85 c9             	test   rcx,rcx
  212c00:	4c 8b 64 24 70       	mov    r12,QWORD PTR [rsp+0x70]
  212c05:	0f 84 88 0b 00 00    	je     213793 <dumpCurrentStackTrace+0x15a3>
  212c0b:	4d 01 f1             	add    r9,r14
  212c0e:	48 8b 40 10          	mov    rax,QWORD PTR [rax+0x10]
  212c12:	31 d2                	xor    edx,edx
  212c14:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  212c1b:	00 00 00 00 00 
            if (attr.id == id) return &attr.value;
  212c20:	48 83 38 03          	cmp    QWORD PTR [rax],0x3
  212c24:	74 12                	je     212c38 <dumpCurrentStackTrace+0xa48>
        for (self.attrs.toSliceConst()) |*attr| {
  212c26:	48 83 c2 01          	add    rdx,0x1
  212c2a:	48 83 c0 28          	add    rax,0x28
  212c2e:	48 39 ca             	cmp    rdx,rcx
  212c31:	72 ed                	jb     212c20 <dumpCurrentStackTrace+0xa30>
  212c33:	e9 5b 0b 00 00       	jmp    213793 <dumpCurrentStackTrace+0x15a3>
  212c38:	8a 50 20             	mov    dl,BYTE PTR [rax+0x20]
  212c3b:	80 fa 0a             	cmp    dl,0xa
        return switch (form_value.*) {
  212c3e:	74 2f                	je     212c6f <dumpCurrentStackTrace+0xa7f>
  212c40:	48 8d 0d a1 4d ff ff 	lea    rcx,[rip+0xffffffffffff4da1]        # 2079e8 <__unnamed_24>
  212c47:	80 fa 09             	cmp    dl,0x9
  212c4a:	0f 85 a4 00 00 00    	jne    212cf4 <dumpCurrentStackTrace+0xb04>
            FormValue.String => |value| value,
  212c50:	66 c7 44 24 08 00 00 	mov    WORD PTR [rsp+0x8],0x0
  212c57:	c5 fa 6f 40 08       	vmovdqu xmm0,XMMWORD PTR [rax+0x8]
  212c5c:	48 8d 44 24 10       	lea    rax,[rsp+0x10]
  212c61:	c5 fa 7f 00          	vmovdqu XMMWORD PTR [rax],xmm0
        return switch (form_value.*) {
  212c65:	48 8d 4c 24 08       	lea    rcx,[rsp+0x8]
  212c6a:	e9 85 00 00 00       	jmp    212cf4 <dumpCurrentStackTrace+0xb04>
            FormValue.StrPtr => |offset| getString(st, offset),
  212c6f:	48 8b 70 08          	mov    rsi,QWORD PTR [rax+0x8]
  212c73:	48 8b 4c 24 68       	mov    rcx,QWORD PTR [rsp+0x68]
    const pos = st.debug_str.offset + offset;
  212c78:	48 8b 41 70          	mov    rax,QWORD PTR [rcx+0x70]
  212c7c:	48 03 70 18          	add    rsi,QWORD PTR [rax+0x18]
  212c80:	78 45                	js     212cc7 <dumpCurrentStackTrace+0xad7>
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  212c82:	48 63 39             	movsxd rdi,DWORD PTR [rcx]
  212c85:	b8 08 00 00 00       	mov    eax,0x8
  212c8a:	31 d2                	xor    edx,edx
  212c8c:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  212c8e:	48 89 c1             	mov    rcx,rax
  212c91:	48 f7 d9             	neg    rcx
  212c94:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  212c9a:	b8 00 00 00 00       	mov    eax,0x0
  212c9f:	48 0f 46 c8          	cmovbe rcx,rax
  212ca3:	66 b8 03 00          	mov    ax,0x3
  212ca7:	48 83 f9 1d          	cmp    rcx,0x1d
  212cab:	0f 87 96 09 00 00    	ja     213647 <dumpCurrentStackTrace+0x1457>
  212cb1:	48 8d 15 e0 d6 fe ff 	lea    rdx,[rip+0xfffffffffffed6e0]        # 200398 <__unnamed_609+0x58>
  212cb8:	48 63 0c 8a          	movsxd rcx,DWORD PTR [rdx+rcx*4]
  212cbc:	48 01 d1             	add    rcx,rdx
  212cbf:	ff e1                	jmp    rcx
  212cc1:	66 b8 27 00          	mov    ax,0x27
  212cc5:	eb 04                	jmp    212ccb <dumpCurrentStackTrace+0xadb>
  212cc7:	66 b8 04 00          	mov    ax,0x4
    try st.self_exe_file.seekTo(pos);
  212ccb:	66 89 44 24 20       	mov    WORD PTR [rsp+0x20],ax
  212cd0:	48 8b 84 24 d6 00 00 	mov    rax,QWORD PTR [rsp+0xd6]
  212cd7:	00 
  212cd8:	48 8d 4c 24 5f       	lea    rcx,[rsp+0x5f]
  212cdd:	48 89 41 d1          	mov    QWORD PTR [rcx-0x2f],rax
  212ce1:	c5 fa 6f 84 24 c8 00 	vmovdqu xmm0,XMMWORD PTR [rsp+0xc8]
  212ce8:	00 00 
  212cea:	c5 fa 7f 41 c3       	vmovdqu XMMWORD PTR [rcx-0x3d],xmm0
        return switch (form_value.*) {
  212cef:	48 8d 4c 24 20       	lea    rcx,[rsp+0x20]
  212cf4:	44 0f b7 39          	movzx  r15d,WORD PTR [rcx]
  212cf8:	48 8b 41 10          	mov    rax,QWORD PTR [rcx+0x10]
  212cfc:	48 89 84 24 4e 01 00 	mov    QWORD PTR [rsp+0x14e],rax
  212d03:	00 
  212d04:	c5 fa 6f 41 02       	vmovdqu xmm0,XMMWORD PTR [rcx+0x2]
  212d09:	c5 f9 7f 84 24 40 01 	vmovdqa XMMWORD PTR [rsp+0x140],xmm0
  212d10:	00 00 
            const compile_unit_name = try compile_unit.die.getAttrString(debug_info, DW.AT_name);
  212d12:	66 45 85 ff          	test   r15w,r15w
  212d16:	0f 85 9c 0a 00 00    	jne    2137b8 <dumpCurrentStackTrace+0x15c8>
  212d1c:	48 8d 84 24 46 01 00 	lea    rax,[rsp+0x146]
  212d23:	00 
  212d24:	c5 fa 6f 00          	vmovdqu xmm0,XMMWORD PTR [rax]
  212d28:	c5 f9 7f 84 24 20 01 	vmovdqa XMMWORD PTR [rsp+0x120],xmm0
  212d2f:	00 00 
            if (getLineNumberInfo(debug_info, compile_unit, address - 1)) |line_info| {
  212d31:	49 8d 4d ff          	lea    rcx,[r13-0x1]
  212d35:	48 8d bc 24 58 01 00 	lea    rdi,[rsp+0x158]
  212d3c:	00 
  212d3d:	48 8b 74 24 68       	mov    rsi,QWORD PTR [rsp+0x68]
  212d42:	4c 89 ca             	mov    rdx,r9
  212d45:	c5 f8 77             	vzeroupper 
  212d48:	e8 b3 5a 01 00       	call   228800 <getLineNumberInfo>
  212d4d:	44 0f b7 bc 24 58 01 	movzx  r15d,WORD PTR [rsp+0x158]
  212d54:	00 00 
  212d56:	66 45 85 ff          	test   r15w,r15w
  212d5a:	74 77                	je     212dd3 <dumpCurrentStackTrace+0xbe3>
            } else |err| switch (err) {
  212d5c:	44 89 f8             	mov    eax,r15d
  212d5f:	25 fe ff 00 00       	and    eax,0xfffe
  212d64:	83 f8 28             	cmp    eax,0x28
  212d67:	0f 85 4b 0a 00 00    	jne    2137b8 <dumpCurrentStackTrace+0x15c8>
  212d6d:	4d 8b 34 24          	mov    r14,QWORD PTR [r12]
                        try output(context, fmt[start_index..i]);
  212d71:	4c 89 e7             	mov    rdi,r12
  212d74:	48 8d 35 ad c1 03 00 	lea    rsi,[rip+0x3c1ad]        # 24ef28 <__unnamed_25>
  212d7b:	41 ff d6             	call   r14
  212d7e:	41 89 c7             	mov    r15d,eax
  212d81:	66 45 85 ff          	test   r15w,r15w
  212d85:	0f 85 15 fe ff ff    	jne    212ba0 <dumpCurrentStackTrace+0x9b0>
    var buf: [max_int_digits - 1]u8 = undefined;
  212d8b:	c5 fc 10 05 bc 5e ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffff5ebc]        # 208c4f <__unnamed_20+0x1f>
  212d92:	ff 
  212d93:	c5 fc 11 44 24 3f    	vmovups YMMWORD PTR [rsp+0x3f],ymm0
  212d99:	c5 fe 6f 05 8f 5e ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffff5e8f]        # 208c30 <__unnamed_20>
  212da0:	ff 
  212da1:	c5 fe 7f 44 24 20    	vmovdqu YMMWORD PTR [rsp+0x20],ymm0
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  212da7:	44 89 e8             	mov    eax,r13d
  212daa:	24 0f                	and    al,0xf
        0...9 => digit + '0',
  212dac:	b1 30                	mov    cl,0x30
  212dae:	3c 0a                	cmp    al,0xa
  212db0:	72 02                	jb     212db4 <dumpCurrentStackTrace+0xbc4>
  212db2:	b1 57                	mov    cl,0x57
  212db4:	00 c1                	add    cl,al
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  212db6:	88 4c 24 5f          	mov    BYTE PTR [rsp+0x5f],cl
  212dba:	b8 40 00 00 00       	mov    eax,0x40
        if (a == 0) break;
  212dbf:	49 83 fd 10          	cmp    r13,0x10
  212dc3:	0f 83 b8 04 00 00    	jae    213281 <dumpCurrentStackTrace+0x1091>
  212dc9:	48 8d 4c 24 5f       	lea    rcx,[rsp+0x5f]
  212dce:	e9 ed 04 00 00       	jmp    2132c0 <dumpCurrentStackTrace+0x10d0>
  212dd3:	48 8d 84 24 60 01 00 	lea    rax,[rsp+0x160]
  212dda:	00 
            if (getLineNumberInfo(debug_info, compile_unit, address - 1)) |line_info| {
  212ddb:	c5 fe 6f 00          	vmovdqu ymm0,YMMWORD PTR [rax]
  212ddf:	c5 fe 7f 84 24 80 00 	vmovdqu YMMWORD PTR [rsp+0x80],ymm0
  212de6:	00 00 
  212de8:	48 8b 40 20          	mov    rax,QWORD PTR [rax+0x20]
  212dec:	48 89 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rax
  212df3:	00 
  212df4:	4c 89 e3             	mov    rbx,r12
  212df7:	4c 8b a4 24 80 00 00 	mov    r12,QWORD PTR [rsp+0x80]
  212dfe:	00 
  212dff:	48 8b 84 24 88 00 00 	mov    rax,QWORD PTR [rsp+0x88]
  212e06:	00 
  212e07:	48 89 44 24 78       	mov    QWORD PTR [rsp+0x78],rax
  212e0c:	4c 8b 33             	mov    r14,QWORD PTR [rbx]
                if (tty_color) {
  212e0f:	80 7c 24 07 00       	cmp    BYTE PTR [rsp+0x7],0x0
  212e14:	0f 84 cb 01 00 00    	je     212fe5 <dumpCurrentStackTrace+0xdf5>
                        try output(context, fmt[start_index..i]);
  212e1a:	48 89 df             	mov    rdi,rbx
  212e1d:	48 8d 35 54 c0 03 00 	lea    rsi,[rip+0x3c054]        # 24ee78 <__unnamed_26>
  212e24:	c5 f8 77             	vzeroupper 
  212e27:	41 ff d6             	call   r14
  212e2a:	41 89 c7             	mov    r15d,eax
  212e2d:	66 45 85 ff          	test   r15w,r15w
  212e31:	0f 85 e0 09 00 00    	jne    213817 <dumpCurrentStackTrace+0x1627>
                const casted_value = ([]const u8)(value);
  212e37:	48 8d 84 24 90 00 00 	lea    rax,[rsp+0x90]
  212e3e:	00 
  212e3f:	c5 fa 6f 00          	vmovdqu xmm0,XMMWORD PTR [rax]
  212e43:	c5 f9 7f 44 24 20    	vmovdqa XMMWORD PTR [rsp+0x20],xmm0
                return output(context, casted_value);
  212e49:	48 89 df             	mov    rdi,rbx
  212e4c:	48 8d 74 24 20       	lea    rsi,[rsp+0x20]
  212e51:	41 ff d6             	call   r14
  212e54:	41 89 c7             	mov    r15d,eax
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  212e57:	66 45 85 ff          	test   r15w,r15w
  212e5b:	0f 85 b6 09 00 00    	jne    213817 <dumpCurrentStackTrace+0x1627>
                        try output(context, fmt[start_index..i]);
  212e61:	48 89 df             	mov    rdi,rbx
  212e64:	48 8d 35 1d c0 03 00 	lea    rsi,[rip+0x3c01d]        # 24ee88 <__unnamed_27>
  212e6b:	41 ff d6             	call   r14
  212e6e:	41 89 c7             	mov    r15d,eax
  212e71:	66 45 85 ff          	test   r15w,r15w
  212e75:	0f 85 c5 09 00 00    	jne    213840 <dumpCurrentStackTrace+0x1650>
    var buf: [max_int_digits - 1]u8 = undefined;
  212e7b:	c5 fc 10 05 cc 5d ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffff5dcc]        # 208c4f <__unnamed_20+0x1f>
  212e82:	ff 
  212e83:	c5 fc 11 44 24 3f    	vmovups YMMWORD PTR [rsp+0x3f],ymm0
  212e89:	c5 fe 6f 05 9f 5d ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffff5d9f]        # 208c30 <__unnamed_20>
  212e90:	ff 
  212e91:	c5 fe 7f 44 24 20    	vmovdqu YMMWORD PTR [rsp+0x20],ymm0
        const digit = a % base;
  212e97:	4c 89 e2             	mov    rdx,r12
  212e9a:	48 b8 cd cc cc cc cc 	movabs rax,0xcccccccccccccccd
  212ea1:	cc cc cc 
  212ea4:	c4 e2 fb f6 c8       	mulx   rcx,rax,rax
  212ea9:	c1 e9 02             	shr    ecx,0x2
  212eac:	81 e1 fe ff ff 3f    	and    ecx,0x3ffffffe
  212eb2:	8d 0c 89             	lea    ecx,[rcx+rcx*4]
  212eb5:	44 89 e0             	mov    eax,r12d
  212eb8:	29 c8                	sub    eax,ecx
        0...9 => digit + '0',
  212eba:	b1 30                	mov    cl,0x30
  212ebc:	3c 0a                	cmp    al,0xa
  212ebe:	72 02                	jb     212ec2 <dumpCurrentStackTrace+0xcd2>
  212ec0:	b1 57                	mov    cl,0x57
  212ec2:	00 c1                	add    cl,al
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  212ec4:	88 4c 24 5f          	mov    BYTE PTR [rsp+0x5f],cl
  212ec8:	b8 40 00 00 00       	mov    eax,0x40
        if (a == 0) break;
  212ecd:	49 83 fc 0a          	cmp    r12,0xa
  212ed1:	73 0d                	jae    212ee0 <dumpCurrentStackTrace+0xcf0>
  212ed3:	48 8d 4c 24 5f       	lea    rcx,[rsp+0x5f]
  212ed8:	eb 58                	jmp    212f32 <dumpCurrentStackTrace+0xd42>
  212eda:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
        a /= base;
  212ee0:	4c 89 e2             	mov    rdx,r12
  212ee3:	48 b9 cd cc cc cc cc 	movabs rcx,0xcccccccccccccccd
  212eea:	cc cc cc 
  212eed:	48 89 ce             	mov    rsi,rcx
  212ef0:	c4 e2 f3 f6 d6       	mulx   rdx,rcx,rsi
  212ef5:	48 c1 ea 03          	shr    rdx,0x3
        const digit = a % base;
  212ef9:	c4 e2 f3 f6 f6       	mulx   rsi,rcx,rsi
  212efe:	c1 ee 02             	shr    esi,0x2
  212f01:	81 e6 fe ff ff 3f    	and    esi,0x3ffffffe
  212f07:	8d 34 b6             	lea    esi,[rsi+rsi*4]
  212f0a:	89 d1                	mov    ecx,edx
  212f0c:	29 f1                	sub    ecx,esi
        0...9 => digit + '0',
  212f0e:	b3 30                	mov    bl,0x30
  212f10:	80 f9 0a             	cmp    cl,0xa
  212f13:	72 02                	jb     212f17 <dumpCurrentStackTrace+0xd27>
  212f15:	b3 57                	mov    bl,0x57
  212f17:	00 cb                	add    bl,cl
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  212f19:	88 5c 04 1e          	mov    BYTE PTR [rsp+rax*1+0x1e],bl
        if (a == 0) break;
  212f1d:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  212f21:	49 83 fc 63          	cmp    r12,0x63
  212f25:	49 89 d4             	mov    r12,rdx
  212f28:	77 b6                	ja     212ee0 <dumpCurrentStackTrace+0xcf0>
        const padded_buf = buf[index - padding ..];
  212f2a:	48 8d 0c 04          	lea    rcx,[rsp+rax*1]
  212f2e:	48 83 c1 1f          	add    rcx,0x1f
  212f32:	ba 41 00 00 00       	mov    edx,0x41
  212f37:	48 29 c2             	sub    rdx,rax
  212f3a:	48 89 4c 24 08       	mov    QWORD PTR [rsp+0x8],rcx
  212f3f:	48 89 54 24 10       	mov    QWORD PTR [rsp+0x10],rdx
  212f44:	4c 8b 64 24 70       	mov    r12,QWORD PTR [rsp+0x70]
        return output(context, padded_buf);
  212f49:	4c 89 e7             	mov    rdi,r12
  212f4c:	48 8d 74 24 08       	lea    rsi,[rsp+0x8]
  212f51:	c5 f8 77             	vzeroupper 
  212f54:	41 ff d6             	call   r14
  212f57:	41 89 c7             	mov    r15d,eax
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  212f5a:	66 45 85 ff          	test   r15w,r15w
  212f5e:	0f 85 e1 08 00 00    	jne    213845 <dumpCurrentStackTrace+0x1655>
                        try output(context, fmt[start_index..i]);
  212f64:	4c 89 e7             	mov    rdi,r12
  212f67:	48 8d 35 2a bf 03 00 	lea    rsi,[rip+0x3bf2a]        # 24ee98 <__unnamed_28>
  212f6e:	41 ff d6             	call   r14
  212f71:	41 89 c7             	mov    r15d,eax
  212f74:	66 45 85 ff          	test   r15w,r15w
  212f78:	0f 85 c7 08 00 00    	jne    213845 <dumpCurrentStackTrace+0x1655>
    var buf: [max_int_digits - 1]u8 = undefined;
  212f7e:	c5 fc 10 05 c9 5c ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffff5cc9]        # 208c4f <__unnamed_20+0x1f>
  212f85:	ff 
  212f86:	c5 fc 11 44 24 3f    	vmovups YMMWORD PTR [rsp+0x3f],ymm0
  212f8c:	c5 fe 6f 05 9c 5c ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffff5c9c]        # 208c30 <__unnamed_20>
  212f93:	ff 
  212f94:	c5 fe 7f 44 24 20    	vmovdqu YMMWORD PTR [rsp+0x20],ymm0
  212f9a:	48 8b 54 24 78       	mov    rdx,QWORD PTR [rsp+0x78]
        const digit = a % base;
  212f9f:	48 b8 cd cc cc cc cc 	movabs rax,0xcccccccccccccccd
  212fa6:	cc cc cc 
  212fa9:	c4 e2 fb f6 c8       	mulx   rcx,rax,rax
  212fae:	c1 e9 02             	shr    ecx,0x2
  212fb1:	81 e1 fe ff ff 3f    	and    ecx,0x3ffffffe
  212fb7:	8d 0c 89             	lea    ecx,[rcx+rcx*4]
  212fba:	89 d0                	mov    eax,edx
  212fbc:	29 c8                	sub    eax,ecx
        0...9 => digit + '0',
  212fbe:	b1 30                	mov    cl,0x30
  212fc0:	3c 0a                	cmp    al,0xa
  212fc2:	72 02                	jb     212fc6 <dumpCurrentStackTrace+0xdd6>
  212fc4:	b1 57                	mov    cl,0x57
  212fc6:	00 c1                	add    cl,al
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  212fc8:	88 4c 24 5f          	mov    BYTE PTR [rsp+0x5f],cl
  212fcc:	b9 40 00 00 00       	mov    ecx,0x40
        if (a == 0) break;
  212fd1:	48 83 fa 0a          	cmp    rdx,0xa
  212fd5:	0f 83 62 03 00 00    	jae    21333d <dumpCurrentStackTrace+0x114d>
  212fdb:	48 8d 44 24 5f       	lea    rax,[rsp+0x5f]
  212fe0:	e9 af 03 00 00       	jmp    213394 <dumpCurrentStackTrace+0x11a4>
                const casted_value = ([]const u8)(value);
  212fe5:	48 8d 84 24 90 00 00 	lea    rax,[rsp+0x90]
  212fec:	00 
  212fed:	c5 fa 6f 00          	vmovdqu xmm0,XMMWORD PTR [rax]
  212ff1:	c5 f9 7f 44 24 20    	vmovdqa XMMWORD PTR [rsp+0x20],xmm0
                return output(context, casted_value);
  212ff7:	48 89 df             	mov    rdi,rbx
  212ffa:	48 8d 74 24 20       	lea    rsi,[rsp+0x20]
  212fff:	c5 f8 77             	vzeroupper 
  213002:	41 ff d6             	call   r14
  213005:	41 89 c7             	mov    r15d,eax
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  213008:	66 45 85 ff          	test   r15w,r15w
  21300c:	0f 85 05 08 00 00    	jne    213817 <dumpCurrentStackTrace+0x1627>
                        try output(context, fmt[start_index..i]);
  213012:	48 89 df             	mov    rdi,rbx
  213015:	48 8d 35 bc be 03 00 	lea    rsi,[rip+0x3bebc]        # 24eed8 <__unnamed_29>
  21301c:	41 ff d6             	call   r14
  21301f:	41 89 c7             	mov    r15d,eax
  213022:	66 45 85 ff          	test   r15w,r15w
  213026:	0f 85 fd 07 00 00    	jne    213829 <dumpCurrentStackTrace+0x1639>
    var buf: [max_int_digits - 1]u8 = undefined;
  21302c:	c5 fc 10 05 1b 5c ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffff5c1b]        # 208c4f <__unnamed_20+0x1f>
  213033:	ff 
  213034:	c5 fc 11 44 24 3f    	vmovups YMMWORD PTR [rsp+0x3f],ymm0
  21303a:	c5 fe 6f 05 ee 5b ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffff5bee]        # 208c30 <__unnamed_20>
  213041:	ff 
  213042:	c5 fe 7f 44 24 20    	vmovdqu YMMWORD PTR [rsp+0x20],ymm0
        const digit = a % base;
  213048:	4c 89 e2             	mov    rdx,r12
  21304b:	48 b8 cd cc cc cc cc 	movabs rax,0xcccccccccccccccd
  213052:	cc cc cc 
  213055:	c4 e2 fb f6 c8       	mulx   rcx,rax,rax
  21305a:	c1 e9 02             	shr    ecx,0x2
  21305d:	81 e1 fe ff ff 3f    	and    ecx,0x3ffffffe
  213063:	8d 0c 89             	lea    ecx,[rcx+rcx*4]
  213066:	44 89 e0             	mov    eax,r12d
  213069:	29 c8                	sub    eax,ecx
        0...9 => digit + '0',
  21306b:	b1 30                	mov    cl,0x30
  21306d:	3c 0a                	cmp    al,0xa
  21306f:	72 02                	jb     213073 <dumpCurrentStackTrace+0xe83>
  213071:	b1 57                	mov    cl,0x57
  213073:	00 c1                	add    cl,al
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  213075:	88 4c 24 5f          	mov    BYTE PTR [rsp+0x5f],cl
  213079:	b8 40 00 00 00       	mov    eax,0x40
        if (a == 0) break;
  21307e:	49 83 fc 0a          	cmp    r12,0xa
  213082:	73 0c                	jae    213090 <dumpCurrentStackTrace+0xea0>
  213084:	48 8d 4c 24 5f       	lea    rcx,[rsp+0x5f]
  213089:	eb 57                	jmp    2130e2 <dumpCurrentStackTrace+0xef2>
  21308b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
        a /= base;
  213090:	4c 89 e2             	mov    rdx,r12
  213093:	48 b9 cd cc cc cc cc 	movabs rcx,0xcccccccccccccccd
  21309a:	cc cc cc 
  21309d:	48 89 ce             	mov    rsi,rcx
  2130a0:	c4 e2 f3 f6 d6       	mulx   rdx,rcx,rsi
  2130a5:	48 c1 ea 03          	shr    rdx,0x3
        const digit = a % base;
  2130a9:	c4 e2 f3 f6 f6       	mulx   rsi,rcx,rsi
  2130ae:	c1 ee 02             	shr    esi,0x2
  2130b1:	81 e6 fe ff ff 3f    	and    esi,0x3ffffffe
  2130b7:	8d 34 b6             	lea    esi,[rsi+rsi*4]
  2130ba:	89 d1                	mov    ecx,edx
  2130bc:	29 f1                	sub    ecx,esi
        0...9 => digit + '0',
  2130be:	b3 30                	mov    bl,0x30
  2130c0:	80 f9 0a             	cmp    cl,0xa
  2130c3:	72 02                	jb     2130c7 <dumpCurrentStackTrace+0xed7>
  2130c5:	b3 57                	mov    bl,0x57
  2130c7:	00 cb                	add    bl,cl
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  2130c9:	88 5c 04 1e          	mov    BYTE PTR [rsp+rax*1+0x1e],bl
        if (a == 0) break;
  2130cd:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  2130d1:	49 83 fc 63          	cmp    r12,0x63
  2130d5:	49 89 d4             	mov    r12,rdx
  2130d8:	77 b6                	ja     213090 <dumpCurrentStackTrace+0xea0>
        const padded_buf = buf[index - padding ..];
  2130da:	48 8d 0c 04          	lea    rcx,[rsp+rax*1]
  2130de:	48 83 c1 1f          	add    rcx,0x1f
  2130e2:	ba 41 00 00 00       	mov    edx,0x41
  2130e7:	48 29 c2             	sub    rdx,rax
  2130ea:	48 89 4c 24 08       	mov    QWORD PTR [rsp+0x8],rcx
  2130ef:	48 89 54 24 10       	mov    QWORD PTR [rsp+0x10],rdx
  2130f4:	4c 8b 64 24 70       	mov    r12,QWORD PTR [rsp+0x70]
        return output(context, padded_buf);
  2130f9:	4c 89 e7             	mov    rdi,r12
  2130fc:	48 8d 74 24 08       	lea    rsi,[rsp+0x8]
  213101:	c5 f8 77             	vzeroupper 
  213104:	41 ff d6             	call   r14
  213107:	41 89 c7             	mov    r15d,eax
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  21310a:	66 45 85 ff          	test   r15w,r15w
  21310e:	0f 85 31 07 00 00    	jne    213845 <dumpCurrentStackTrace+0x1655>
                        try output(context, fmt[start_index..i]);
  213114:	4c 89 e7             	mov    rdi,r12
  213117:	48 8d 35 ca bd 03 00 	lea    rsi,[rip+0x3bdca]        # 24eee8 <__unnamed_30>
  21311e:	41 ff d6             	call   r14
  213121:	41 89 c7             	mov    r15d,eax
  213124:	66 45 85 ff          	test   r15w,r15w
  213128:	0f 85 17 07 00 00    	jne    213845 <dumpCurrentStackTrace+0x1655>
    var buf: [max_int_digits - 1]u8 = undefined;
  21312e:	c5 fc 10 05 19 5b ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffff5b19]        # 208c4f <__unnamed_20+0x1f>
  213135:	ff 
  213136:	c5 fc 11 44 24 3f    	vmovups YMMWORD PTR [rsp+0x3f],ymm0
  21313c:	c5 fe 6f 05 ec 5a ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffff5aec]        # 208c30 <__unnamed_20>
  213143:	ff 
  213144:	c5 fe 7f 44 24 20    	vmovdqu YMMWORD PTR [rsp+0x20],ymm0
  21314a:	48 8b 7c 24 78       	mov    rdi,QWORD PTR [rsp+0x78]
        const digit = a % base;
  21314f:	48 89 fa             	mov    rdx,rdi
  213152:	48 b8 cd cc cc cc cc 	movabs rax,0xcccccccccccccccd
  213159:	cc cc cc 
  21315c:	c4 e2 fb f6 c8       	mulx   rcx,rax,rax
  213161:	c1 e9 02             	shr    ecx,0x2
  213164:	81 e1 fe ff ff 3f    	and    ecx,0x3ffffffe
  21316a:	8d 0c 89             	lea    ecx,[rcx+rcx*4]
  21316d:	89 f8                	mov    eax,edi
  21316f:	29 c8                	sub    eax,ecx
        0...9 => digit + '0',
  213171:	b1 30                	mov    cl,0x30
  213173:	3c 0a                	cmp    al,0xa
  213175:	72 02                	jb     213179 <dumpCurrentStackTrace+0xf89>
  213177:	b1 57                	mov    cl,0x57
  213179:	00 c1                	add    cl,al
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  21317b:	88 4c 24 5f          	mov    BYTE PTR [rsp+0x5f],cl
  21317f:	b8 40 00 00 00       	mov    eax,0x40
        if (a == 0) break;
  213184:	48 83 ff 0a          	cmp    rdi,0xa
  213188:	73 16                	jae    2131a0 <dumpCurrentStackTrace+0xfb0>
  21318a:	48 8d 4c 24 5f       	lea    rcx,[rsp+0x5f]
  21318f:	eb 61                	jmp    2131f2 <dumpCurrentStackTrace+0x1002>
  213191:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  213198:	0f 1f 84 00 00 00 00 
  21319f:	00 
        a /= base;
  2131a0:	48 89 fa             	mov    rdx,rdi
  2131a3:	48 b9 cd cc cc cc cc 	movabs rcx,0xcccccccccccccccd
  2131aa:	cc cc cc 
  2131ad:	48 89 ce             	mov    rsi,rcx
  2131b0:	c4 e2 f3 f6 d6       	mulx   rdx,rcx,rsi
  2131b5:	48 c1 ea 03          	shr    rdx,0x3
        const digit = a % base;
  2131b9:	c4 e2 f3 f6 f6       	mulx   rsi,rcx,rsi
  2131be:	c1 ee 02             	shr    esi,0x2
  2131c1:	81 e6 fe ff ff 3f    	and    esi,0x3ffffffe
  2131c7:	8d 34 b6             	lea    esi,[rsi+rsi*4]
  2131ca:	89 d1                	mov    ecx,edx
  2131cc:	29 f1                	sub    ecx,esi
        0...9 => digit + '0',
  2131ce:	b3 30                	mov    bl,0x30
  2131d0:	80 f9 0a             	cmp    cl,0xa
  2131d3:	72 02                	jb     2131d7 <dumpCurrentStackTrace+0xfe7>
  2131d5:	b3 57                	mov    bl,0x57
  2131d7:	00 cb                	add    bl,cl
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  2131d9:	88 5c 04 1e          	mov    BYTE PTR [rsp+rax*1+0x1e],bl
        if (a == 0) break;
  2131dd:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  2131e1:	48 83 ff 63          	cmp    rdi,0x63
  2131e5:	48 89 d7             	mov    rdi,rdx
  2131e8:	77 b6                	ja     2131a0 <dumpCurrentStackTrace+0xfb0>
        const padded_buf = buf[index - padding ..];
  2131ea:	48 8d 0c 04          	lea    rcx,[rsp+rax*1]
  2131ee:	48 83 c1 1f          	add    rcx,0x1f
  2131f2:	ba 41 00 00 00       	mov    edx,0x41
  2131f7:	48 29 c2             	sub    rdx,rax
  2131fa:	48 89 4c 24 08       	mov    QWORD PTR [rsp+0x8],rcx
  2131ff:	48 89 54 24 10       	mov    QWORD PTR [rsp+0x10],rdx
        return output(context, padded_buf);
  213204:	4c 89 e7             	mov    rdi,r12
  213207:	48 8d 74 24 08       	lea    rsi,[rsp+0x8]
  21320c:	c5 f8 77             	vzeroupper 
  21320f:	41 ff d6             	call   r14
  213212:	41 89 c7             	mov    r15d,eax
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  213215:	66 45 85 ff          	test   r15w,r15w
  213219:	0f 85 26 06 00 00    	jne    213845 <dumpCurrentStackTrace+0x1655>
                        try output(context, fmt[start_index..i]);
  21321f:	4c 89 e7             	mov    rdi,r12
  213222:	48 8d 35 cf bc 03 00 	lea    rsi,[rip+0x3bccf]        # 24eef8 <__unnamed_31>
  213229:	41 ff d6             	call   r14
  21322c:	41 89 c7             	mov    r15d,eax
  21322f:	66 45 85 ff          	test   r15w,r15w
  213233:	0f 85 0c 06 00 00    	jne    213845 <dumpCurrentStackTrace+0x1655>
    var buf: [max_int_digits - 1]u8 = undefined;
  213239:	c5 fc 10 05 0e 5a ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffff5a0e]        # 208c4f <__unnamed_20+0x1f>
  213240:	ff 
  213241:	c5 fc 11 44 24 3f    	vmovups YMMWORD PTR [rsp+0x3f],ymm0
  213247:	c5 fe 6f 05 e1 59 ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffff59e1]        # 208c30 <__unnamed_20>
  21324e:	ff 
  21324f:	c5 fe 7f 44 24 20    	vmovdqu YMMWORD PTR [rsp+0x20],ymm0
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  213255:	44 89 e8             	mov    eax,r13d
  213258:	24 0f                	and    al,0xf
        0...9 => digit + '0',
  21325a:	b1 30                	mov    cl,0x30
  21325c:	3c 0a                	cmp    al,0xa
  21325e:	72 02                	jb     213262 <dumpCurrentStackTrace+0x1072>
  213260:	b1 57                	mov    cl,0x57
  213262:	00 c1                	add    cl,al
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  213264:	88 4c 24 5f          	mov    BYTE PTR [rsp+0x5f],cl
  213268:	b8 40 00 00 00       	mov    eax,0x40
        if (a == 0) break;
  21326d:	49 83 fd 10          	cmp    r13,0x10
  213271:	0f 83 ac 01 00 00    	jae    213423 <dumpCurrentStackTrace+0x1233>
  213277:	48 8d 4c 24 5f       	lea    rcx,[rsp+0x5f]
  21327c:	e9 df 01 00 00       	jmp    213460 <dumpCurrentStackTrace+0x1270>
        a /= base;
  213281:	4c 89 e9             	mov    rcx,r13
  213284:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21328b:	00 00 00 00 00 
  213290:	48 c1 e9 04          	shr    rcx,0x4
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  213294:	89 ca                	mov    edx,ecx
  213296:	80 e2 0f             	and    dl,0xf
        0...9 => digit + '0',
  213299:	b3 30                	mov    bl,0x30
  21329b:	80 fa 0a             	cmp    dl,0xa
  21329e:	72 02                	jb     2132a2 <dumpCurrentStackTrace+0x10b2>
  2132a0:	b3 57                	mov    bl,0x57
  2132a2:	00 d3                	add    bl,dl
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  2132a4:	88 5c 04 1e          	mov    BYTE PTR [rsp+rax*1+0x1e],bl
        if (a == 0) break;
  2132a8:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  2132ac:	49 81 fd ff 00 00 00 	cmp    r13,0xff
  2132b3:	49 89 cd             	mov    r13,rcx
  2132b6:	77 d8                	ja     213290 <dumpCurrentStackTrace+0x10a0>
        const padded_buf = buf[index - padding ..];
  2132b8:	48 8d 0c 04          	lea    rcx,[rsp+rax*1]
  2132bc:	48 83 c1 1f          	add    rcx,0x1f
  2132c0:	ba 41 00 00 00       	mov    edx,0x41
  2132c5:	48 29 c2             	sub    rdx,rax
  2132c8:	48 89 4c 24 08       	mov    QWORD PTR [rsp+0x8],rcx
  2132cd:	48 89 54 24 10       	mov    QWORD PTR [rsp+0x10],rdx
        return output(context, padded_buf);
  2132d2:	4c 89 e7             	mov    rdi,r12
  2132d5:	48 8d 74 24 08       	lea    rsi,[rsp+0x8]
  2132da:	c5 f8 77             	vzeroupper 
  2132dd:	41 ff d6             	call   r14
  2132e0:	41 89 c7             	mov    r15d,eax
                    try formatType(args[next_arg], fmt[s..i], context, Errors, output);
  2132e3:	66 45 85 ff          	test   r15w,r15w
  2132e7:	0f 85 b3 f8 ff ff    	jne    212ba0 <dumpCurrentStackTrace+0x9b0>
                        try output(context, fmt[start_index..i]);
  2132ed:	4c 89 e7             	mov    rdi,r12
  2132f0:	48 8d 35 41 bc 03 00 	lea    rsi,[rip+0x3bc41]        # 24ef38 <__unnamed_32>
  2132f7:	41 ff d6             	call   r14
  2132fa:	41 89 c7             	mov    r15d,eax
  2132fd:	66 45 85 ff          	test   r15w,r15w
  213301:	0f 85 99 f8 ff ff    	jne    212ba0 <dumpCurrentStackTrace+0x9b0>
                const casted_value = ([]const u8)(value);
  213307:	c5 f9 6f 84 24 20 01 	vmovdqa xmm0,XMMWORD PTR [rsp+0x120]
  21330e:	00 00 
  213310:	c5 f9 7f 44 24 20    	vmovdqa XMMWORD PTR [rsp+0x20],xmm0
                return output(context, casted_value);
  213316:	4c 89 e7             	mov    rdi,r12
  213319:	48 8d 74 24 20       	lea    rsi,[rsp+0x20]
  21331e:	41 ff d6             	call   r14
  213321:	41 89 c7             	mov    r15d,eax
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  213324:	66 45 85 ff          	test   r15w,r15w
  213328:	0f 85 72 f8 ff ff    	jne    212ba0 <dumpCurrentStackTrace+0x9b0>
        try output(context, fmt[start_index..]);
  21332e:	4c 89 e7             	mov    rdi,r12
  213331:	48 8d 35 10 bc 03 00 	lea    rsi,[rip+0x3bc10]        # 24ef48 <__unnamed_33>
  213338:	e9 56 f8 ff ff       	jmp    212b93 <dumpCurrentStackTrace+0x9a3>
  21333d:	48 89 d0             	mov    rax,rdx
        a /= base;
  213340:	48 89 c2             	mov    rdx,rax
  213343:	48 be cd cc cc cc cc 	movabs rsi,0xcccccccccccccccd
  21334a:	cc cc cc 
  21334d:	48 89 f7             	mov    rdi,rsi
  213350:	c4 e2 cb f6 d7       	mulx   rdx,rsi,rdi
  213355:	48 c1 ea 03          	shr    rdx,0x3
        const digit = a % base;
  213359:	c4 e2 cb f6 ff       	mulx   rdi,rsi,rdi
  21335e:	c1 ef 02             	shr    edi,0x2
  213361:	81 e7 fe ff ff 3f    	and    edi,0x3ffffffe
  213367:	8d 3c bf             	lea    edi,[rdi+rdi*4]
  21336a:	89 d6                	mov    esi,edx
  21336c:	29 fe                	sub    esi,edi
        0...9 => digit + '0',
  21336e:	b3 30                	mov    bl,0x30
  213370:	40 80 fe 0a          	cmp    sil,0xa
  213374:	72 02                	jb     213378 <dumpCurrentStackTrace+0x1188>
  213376:	b3 57                	mov    bl,0x57
  213378:	40 00 f3             	add    bl,sil
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  21337b:	88 5c 0c 1e          	mov    BYTE PTR [rsp+rcx*1+0x1e],bl
        if (a == 0) break;
  21337f:	48 83 c1 ff          	add    rcx,0xffffffffffffffff
  213383:	48 83 f8 63          	cmp    rax,0x63
  213387:	48 89 d0             	mov    rax,rdx
  21338a:	77 b4                	ja     213340 <dumpCurrentStackTrace+0x1150>
        const padded_buf = buf[index - padding ..];
  21338c:	48 8d 04 0c          	lea    rax,[rsp+rcx*1]
  213390:	48 83 c0 1f          	add    rax,0x1f
  213394:	ba 41 00 00 00       	mov    edx,0x41
  213399:	48 29 ca             	sub    rdx,rcx
  21339c:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  2133a1:	48 89 54 24 10       	mov    QWORD PTR [rsp+0x10],rdx
        return output(context, padded_buf);
  2133a6:	4c 89 e7             	mov    rdi,r12
  2133a9:	48 8d 74 24 08       	lea    rsi,[rsp+0x8]
  2133ae:	c5 f8 77             	vzeroupper 
  2133b1:	41 ff d6             	call   r14
  2133b4:	41 89 c7             	mov    r15d,eax
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  2133b7:	66 45 85 ff          	test   r15w,r15w
  2133bb:	0f 85 84 04 00 00    	jne    213845 <dumpCurrentStackTrace+0x1655>
                        try output(context, fmt[start_index..i]);
  2133c1:	4c 89 e7             	mov    rdi,r12
  2133c4:	48 8d 35 dd ba 03 00 	lea    rsi,[rip+0x3badd]        # 24eea8 <__unnamed_34>
  2133cb:	41 ff d6             	call   r14
  2133ce:	41 89 c7             	mov    r15d,eax
  2133d1:	66 45 85 ff          	test   r15w,r15w
  2133d5:	0f 85 6a 04 00 00    	jne    213845 <dumpCurrentStackTrace+0x1655>
    var buf: [max_int_digits - 1]u8 = undefined;
  2133db:	c5 fc 10 05 6c 58 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffff586c]        # 208c4f <__unnamed_20+0x1f>
  2133e2:	ff 
  2133e3:	c5 fc 11 44 24 3f    	vmovups YMMWORD PTR [rsp+0x3f],ymm0
  2133e9:	c5 fe 6f 05 3f 58 ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffff583f]        # 208c30 <__unnamed_20>
  2133f0:	ff 
  2133f1:	c5 fe 7f 44 24 20    	vmovdqu YMMWORD PTR [rsp+0x20],ymm0
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  2133f7:	44 89 e8             	mov    eax,r13d
  2133fa:	24 0f                	and    al,0xf
        0...9 => digit + '0',
  2133fc:	b1 30                	mov    cl,0x30
  2133fe:	3c 0a                	cmp    al,0xa
  213400:	72 02                	jb     213404 <dumpCurrentStackTrace+0x1214>
  213402:	b1 57                	mov    cl,0x57
  213404:	00 c1                	add    cl,al
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  213406:	88 4c 24 5f          	mov    BYTE PTR [rsp+0x5f],cl
  21340a:	b8 40 00 00 00       	mov    eax,0x40
        if (a == 0) break;
  21340f:	49 83 fd 10          	cmp    r13,0x10
  213413:	0f 83 d4 00 00 00    	jae    2134ed <dumpCurrentStackTrace+0x12fd>
  213419:	48 8d 4c 24 5f       	lea    rcx,[rsp+0x5f]
  21341e:	e9 fd 00 00 00       	jmp    213520 <dumpCurrentStackTrace+0x1330>
        a /= base;
  213423:	4c 89 e9             	mov    rcx,r13
  213426:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  21342d:	00 00 00 
  213430:	48 c1 e9 04          	shr    rcx,0x4
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  213434:	89 ca                	mov    edx,ecx
  213436:	80 e2 0f             	and    dl,0xf
        0...9 => digit + '0',
  213439:	b3 30                	mov    bl,0x30
  21343b:	80 fa 0a             	cmp    dl,0xa
  21343e:	72 02                	jb     213442 <dumpCurrentStackTrace+0x1252>
  213440:	b3 57                	mov    bl,0x57
  213442:	00 d3                	add    bl,dl
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  213444:	88 5c 04 1e          	mov    BYTE PTR [rsp+rax*1+0x1e],bl
        if (a == 0) break;
  213448:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  21344c:	49 81 fd ff 00 00 00 	cmp    r13,0xff
  213453:	49 89 cd             	mov    r13,rcx
  213456:	77 d8                	ja     213430 <dumpCurrentStackTrace+0x1240>
        const padded_buf = buf[index - padding ..];
  213458:	48 8d 0c 04          	lea    rcx,[rsp+rax*1]
  21345c:	48 83 c1 1f          	add    rcx,0x1f
  213460:	ba 41 00 00 00       	mov    edx,0x41
  213465:	48 29 c2             	sub    rdx,rax
  213468:	48 89 4c 24 08       	mov    QWORD PTR [rsp+0x8],rcx
  21346d:	48 89 54 24 10       	mov    QWORD PTR [rsp+0x10],rdx
        return output(context, padded_buf);
  213472:	4c 89 e7             	mov    rdi,r12
  213475:	48 8d 74 24 08       	lea    rsi,[rsp+0x8]
  21347a:	c5 f8 77             	vzeroupper 
  21347d:	41 ff d6             	call   r14
  213480:	41 89 c7             	mov    r15d,eax
                    try formatType(args[next_arg], fmt[s..i], context, Errors, output);
  213483:	66 45 85 ff          	test   r15w,r15w
  213487:	0f 85 b8 03 00 00    	jne    213845 <dumpCurrentStackTrace+0x1655>
                        try output(context, fmt[start_index..i]);
  21348d:	4c 89 e7             	mov    rdi,r12
  213490:	48 8d 35 71 ba 03 00 	lea    rsi,[rip+0x3ba71]        # 24ef08 <__unnamed_35>
  213497:	41 ff d6             	call   r14
  21349a:	41 89 c7             	mov    r15d,eax
  21349d:	66 45 85 ff          	test   r15w,r15w
  2134a1:	0f 85 9e 03 00 00    	jne    213845 <dumpCurrentStackTrace+0x1655>
                const casted_value = ([]const u8)(value);
  2134a7:	c5 f9 6f 84 24 20 01 	vmovdqa xmm0,XMMWORD PTR [rsp+0x120]
  2134ae:	00 00 
  2134b0:	c5 f9 7f 44 24 20    	vmovdqa XMMWORD PTR [rsp+0x20],xmm0
                return output(context, casted_value);
  2134b6:	4c 89 e7             	mov    rdi,r12
  2134b9:	48 8d 74 24 20       	lea    rsi,[rsp+0x20]
  2134be:	41 ff d6             	call   r14
  2134c1:	41 89 c7             	mov    r15d,eax
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  2134c4:	66 45 85 ff          	test   r15w,r15w
  2134c8:	0f 85 77 03 00 00    	jne    213845 <dumpCurrentStackTrace+0x1655>
        try output(context, fmt[start_index..]);
  2134ce:	4c 89 e7             	mov    rdi,r12
  2134d1:	48 8d 35 40 ba 03 00 	lea    rsi,[rip+0x3ba40]        # 24ef18 <__unnamed_36>
  2134d8:	41 ff d6             	call   r14
  2134db:	41 89 c7             	mov    r15d,eax
                    try out_stream.print(
  2134de:	66 45 85 ff          	test   r15w,r15w
  2134e2:	0f 84 29 02 00 00    	je     213711 <dumpCurrentStackTrace+0x1521>
  2134e8:	e9 58 03 00 00       	jmp    213845 <dumpCurrentStackTrace+0x1655>
        a /= base;
  2134ed:	4c 89 e9             	mov    rcx,r13
  2134f0:	48 c1 e9 04          	shr    rcx,0x4
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  2134f4:	89 ca                	mov    edx,ecx
  2134f6:	80 e2 0f             	and    dl,0xf
        0...9 => digit + '0',
  2134f9:	b3 30                	mov    bl,0x30
  2134fb:	80 fa 0a             	cmp    dl,0xa
  2134fe:	72 02                	jb     213502 <dumpCurrentStackTrace+0x1312>
  213500:	b3 57                	mov    bl,0x57
  213502:	00 d3                	add    bl,dl
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  213504:	88 5c 04 1e          	mov    BYTE PTR [rsp+rax*1+0x1e],bl
        if (a == 0) break;
  213508:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  21350c:	49 81 fd ff 00 00 00 	cmp    r13,0xff
  213513:	49 89 cd             	mov    r13,rcx
  213516:	77 d8                	ja     2134f0 <dumpCurrentStackTrace+0x1300>
        const padded_buf = buf[index - padding ..];
  213518:	48 8d 0c 04          	lea    rcx,[rsp+rax*1]
  21351c:	48 83 c1 1f          	add    rcx,0x1f
  213520:	ba 41 00 00 00       	mov    edx,0x41
  213525:	48 29 c2             	sub    rdx,rax
  213528:	48 89 4c 24 08       	mov    QWORD PTR [rsp+0x8],rcx
  21352d:	48 89 54 24 10       	mov    QWORD PTR [rsp+0x10],rdx
        return output(context, padded_buf);
  213532:	4c 89 e7             	mov    rdi,r12
  213535:	48 8d 74 24 08       	lea    rsi,[rsp+0x8]
  21353a:	c5 f8 77             	vzeroupper 
  21353d:	41 ff d6             	call   r14
  213540:	41 89 c7             	mov    r15d,eax
                    try formatType(args[next_arg], fmt[s..i], context, Errors, output);
  213543:	66 45 85 ff          	test   r15w,r15w
  213547:	0f 85 f8 02 00 00    	jne    213845 <dumpCurrentStackTrace+0x1655>
                        try output(context, fmt[start_index..i]);
  21354d:	4c 89 e7             	mov    rdi,r12
  213550:	48 8d 35 61 b9 03 00 	lea    rsi,[rip+0x3b961]        # 24eeb8 <__unnamed_37>
  213557:	41 ff d6             	call   r14
  21355a:	41 89 c7             	mov    r15d,eax
  21355d:	66 45 85 ff          	test   r15w,r15w
  213561:	0f 85 de 02 00 00    	jne    213845 <dumpCurrentStackTrace+0x1655>
                const casted_value = ([]const u8)(value);
  213567:	c5 f9 6f 84 24 20 01 	vmovdqa xmm0,XMMWORD PTR [rsp+0x120]
  21356e:	00 00 
  213570:	c5 f9 7f 44 24 20    	vmovdqa XMMWORD PTR [rsp+0x20],xmm0
                return output(context, casted_value);
  213576:	4c 89 e7             	mov    rdi,r12
  213579:	48 8d 74 24 20       	lea    rsi,[rsp+0x20]
  21357e:	41 ff d6             	call   r14
  213581:	41 89 c7             	mov    r15d,eax
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  213584:	66 45 85 ff          	test   r15w,r15w
  213588:	0f 85 b7 02 00 00    	jne    213845 <dumpCurrentStackTrace+0x1655>
        try output(context, fmt[start_index..]);
  21358e:	4c 89 e7             	mov    rdi,r12
  213591:	48 8d 35 30 b9 03 00 	lea    rsi,[rip+0x3b930]        # 24eec8 <__unnamed_38>
  213598:	41 ff d6             	call   r14
  21359b:	41 89 c7             	mov    r15d,eax
                    try out_stream.print(
  21359e:	66 45 85 ff          	test   r15w,r15w
  2135a2:	0f 85 9d 02 00 00    	jne    213845 <dumpCurrentStackTrace+0x1655>
                    if (printLineFromFile(out_stream, line_info)) {
  2135a8:	4c 89 e7             	mov    rdi,r12
  2135ab:	48 8d b4 24 80 00 00 	lea    rsi,[rsp+0x80]
  2135b2:	00 
  2135b3:	e8 38 72 01 00       	call   22a7f0 <printLineFromFile>
  2135b8:	41 89 c7             	mov    r15d,eax
  2135bb:	41 0f b7 c7          	movzx  eax,r15w
  2135bf:	83 f8 2a             	cmp    eax,0x2a
  2135c2:	0f 84 49 01 00 00    	je     213711 <dumpCurrentStackTrace+0x1521>
  2135c8:	66 45 85 ff          	test   r15w,r15w
  2135cc:	0f 85 84 00 00 00    	jne    213656 <dumpCurrentStackTrace+0x1466>
  2135d2:	48 8b 44 24 78       	mov    rax,QWORD PTR [rsp+0x78]
                        if (line_info.column == 0) {
  2135d7:	48 85 c0             	test   rax,rax
  2135da:	0f 84 16 01 00 00    	je     2136f6 <dumpCurrentStackTrace+0x1506>
  2135e0:	48 83 f8 01          	cmp    rax,0x1
  2135e4:	74 41                	je     213627 <dumpCurrentStackTrace+0x1437>
  2135e6:	bb 01 00 00 00       	mov    ebx,0x1
  2135eb:	c6 44 24 08 20       	mov    BYTE PTR [rsp+0x8],0x20
        pub fn write(self: *Self, bytes: []const u8) !void {
            return self.writeFn(self, bytes);
        }

        pub fn writeByte(self: *Self, byte: u8) !void {
            const slice = (*[1]u8)(&byte)[0..];
  2135f0:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  2135f5:	48 89 44 24 20       	mov    QWORD PTR [rsp+0x20],rax
  2135fa:	48 c7 44 24 28 01 00 	mov    QWORD PTR [rsp+0x28],0x1
  213601:	00 00 
            return self.writeFn(self, slice);
  213603:	4c 89 e7             	mov    rdi,r12
  213606:	48 8d 74 24 20       	lea    rsi,[rsp+0x20]
  21360b:	41 ff 14 24          	call   QWORD PTR [r12]
  21360f:	41 89 c7             	mov    r15d,eax
                                    try out_stream.writeByte(' ');
  213612:	66 45 85 ff          	test   r15w,r15w
  213616:	0f 85 29 02 00 00    	jne    213845 <dumpCurrentStackTrace+0x1655>
  21361c:	48 83 c3 01          	add    rbx,0x1
                                while (col_i < line_info.column) : (col_i += 1) {
  213620:	48 3b 5c 24 78       	cmp    rbx,QWORD PTR [rsp+0x78]
  213625:	72 c4                	jb     2135eb <dumpCurrentStackTrace+0x13fb>
            return self.writeFn(self, bytes);
  213627:	4c 89 e7             	mov    rdi,r12
  21362a:	48 8d 35 f7 b7 03 00 	lea    rsi,[rip+0x3b7f7]        # 24ee28 <__unnamed_39>
  213631:	41 ff 14 24          	call   QWORD PTR [r12]
  213635:	41 89 c7             	mov    r15d,eax
  213638:	66 45 85 ff          	test   r15w,r15w
  21363c:	0f 84 cf 00 00 00    	je     213711 <dumpCurrentStackTrace+0x1521>
  213642:	e9 39 02 00 00       	jmp    213880 <dumpCurrentStackTrace+0x1690>
  213647:	48 83 f9 4b          	cmp    rcx,0x4b
  21364b:	0f 85 7a f6 ff ff    	jne    212ccb <dumpCurrentStackTrace+0xadb>
  213651:	e9 6b f6 ff ff       	jmp    212cc1 <dumpCurrentStackTrace+0xad1>
        const bytes = @sliceToBytes(memory);
  213656:	48 8b 84 24 98 00 00 	mov    rax,QWORD PTR [rsp+0x98]
  21365d:	00 
        if (bytes.len == 0) return;
  21365e:	48 85 c0             	test   rax,rax
  213661:	0f 84 39 f5 ff ff    	je     212ba0 <dumpCurrentStackTrace+0x9b0>
  213667:	48 8b bc 24 a0 00 00 	mov    rdi,QWORD PTR [rsp+0xa0]
  21366e:	00 
        const bytes = @sliceToBytes(memory);
  21366f:	48 8b 8c 24 90 00 00 	mov    rcx,QWORD PTR [rsp+0x90]
  213676:	00 
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  213677:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  21367b:	48 89 4c 24 20       	mov    QWORD PTR [rsp+0x20],rcx
  213680:	48 89 44 24 28       	mov    QWORD PTR [rsp+0x28],rax
  213685:	48 8d 74 24 20       	lea    rsi,[rsp+0x20]
  21368a:	ff d2                	call   rdx
  21368c:	c5 7d 6f a4 24 00 01 	vmovdqa ymm12,YMMWORD PTR [rsp+0x100]
  213693:	00 00 
  213695:	c5 7d 6f ac 24 e0 00 	vmovdqa ymm13,YMMWORD PTR [rsp+0xe0]
  21369c:	00 00 
        try printSourceAtAddress(debug_info, out_stream, return_address, tty_color);
  21369e:	66 45 85 ff          	test   r15w,r15w
  2136a2:	0f 84 14 f5 ff ff    	je     212bbc <dumpCurrentStackTrace+0x9cc>
  2136a8:	e9 0b 01 00 00       	jmp    2137b8 <dumpCurrentStackTrace+0x15c8>
  2136ad:	48 8b 4c 24 68       	mov    rcx,QWORD PTR [rsp+0x68]
            var in_file_stream = io.FileInStream.init(&self.self_exe_file);
  2136b2:	48 89 8c 24 b8 00 00 	mov    QWORD PTR [rsp+0xb8],rcx
  2136b9:	00 
  2136ba:	48 8d 05 0f 16 01 00 	lea    rax,[rip+0x1160f]        # 224cd0 <FileInStream_readFn>
  2136c1:	48 89 84 24 c0 00 00 	mov    QWORD PTR [rsp+0xc0],rax
  2136c8:	00 
  2136c9:	48 8b b1 a0 00 00 00 	mov    rsi,QWORD PTR [rcx+0xa0]
  2136d0:	4c 8d 74 24 20       	lea    r14,[rsp+0x20]
            return readStringRaw(self.allocator(), in_stream);
  2136d5:	4c 89 f7             	mov    rdi,r14
  2136d8:	48 8d 94 24 c0 00 00 	lea    rdx,[rsp+0xc0]
  2136df:	00 
  2136e0:	4c 89 cb             	mov    rbx,r9
  2136e3:	c5 f8 77             	vzeroupper 
  2136e6:	e8 b5 4c 01 00       	call   2283a0 <readStringRaw>
  2136eb:	49 89 d9             	mov    r9,rbx
        return switch (form_value.*) {
  2136ee:	4c 89 f1             	mov    rcx,r14
  2136f1:	e9 fe f5 ff ff       	jmp    212cf4 <dumpCurrentStackTrace+0xb04>
  2136f6:	4c 89 e7             	mov    rdi,r12
  2136f9:	48 8d 35 18 b7 03 00 	lea    rsi,[rip+0x3b718]        # 24ee18 <__unnamed_3>
  213700:	41 ff 14 24          	call   QWORD PTR [r12]
  213704:	41 89 c7             	mov    r15d,eax
  213707:	66 45 85 ff          	test   r15w,r15w
  21370b:	0f 85 6f 01 00 00    	jne    213880 <dumpCurrentStackTrace+0x1690>
        const bytes = @sliceToBytes(memory);
  213711:	48 8b 84 24 98 00 00 	mov    rax,QWORD PTR [rsp+0x98]
  213718:	00 
        if (bytes.len == 0) return;
  213719:	48 85 c0             	test   rax,rax
  21371c:	74 25                	je     213743 <dumpCurrentStackTrace+0x1553>
  21371e:	48 8b bc 24 a0 00 00 	mov    rdi,QWORD PTR [rsp+0xa0]
  213725:	00 
        const bytes = @sliceToBytes(memory);
  213726:	48 8b 8c 24 90 00 00 	mov    rcx,QWORD PTR [rsp+0x90]
  21372d:	00 
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  21372e:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  213732:	48 89 4c 24 20       	mov    QWORD PTR [rsp+0x20],rcx
  213737:	48 89 44 24 28       	mov    QWORD PTR [rsp+0x28],rax
  21373c:	48 8d 74 24 20       	lea    rsi,[rsp+0x20]
  213741:	ff d2                	call   rdx
  213743:	48 8b 8c 24 a8 00 00 	mov    rcx,QWORD PTR [rsp+0xa8]
  21374a:	00 
  21374b:	48 8b 94 24 b0 00 00 	mov    rdx,QWORD PTR [rsp+0xb0]
  213752:	00 
  213753:	c5 7d 6f a4 24 00 01 	vmovdqa ymm12,YMMWORD PTR [rsp+0x100]
  21375a:	00 00 
  21375c:	c5 7d 6f ac 24 e0 00 	vmovdqa ymm13,YMMWORD PTR [rsp+0xe0]
  213763:	00 00 
  213765:	31 c0                	xor    eax,eax
  213767:	e9 62 f4 ff ff       	jmp    212bce <dumpCurrentStackTrace+0x9de>
  21376c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
        const return_address = @intToPtr(*const usize, fp + @sizeOf(usize)).*;
  213770:	4c 8b 6a 08          	mov    r13,QWORD PTR [rdx+0x8]
                if (return_address == addr) {
  213774:	49 39 cd             	cmp    r13,rcx
        switch (addr_state) {
  213777:	0f 84 b3 ed ff ff    	je     212530 <dumpCurrentStackTrace+0x340>
  21377d:	f6 d0                	not    al
  21377f:	a8 01                	test   al,0x1
  213781:	b0 01                	mov    al,0x1
  213783:	0f 85 a7 ed ff ff    	jne    212530 <dumpCurrentStackTrace+0x340>
    while (fp != 0) : (fp = @intToPtr(*const usize, fp).*) {
  213789:	48 8b 12             	mov    rdx,QWORD PTR [rdx]
  21378c:	48 85 d2             	test   rdx,rdx
  21378f:	75 df                	jne    213770 <dumpCurrentStackTrace+0x1580>
  213791:	eb 72                	jmp    213805 <dumpCurrentStackTrace+0x1615>
        const form_value = self.getAttr(id) orelse return error.MissingDebugInfo;
  213793:	48 8b 05 46 42 ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffff4246]        # 2079e0 <__unnamed_40+0x10>
  21379a:	48 89 84 24 4e 01 00 	mov    QWORD PTR [rsp+0x14e],rax
  2137a1:	00 
  2137a2:	c5 fa 6f 05 28 42 ff 	vmovdqu xmm0,XMMWORD PTR [rip+0xffffffffffff4228]        # 2079d2 <__unnamed_40+0x2>
  2137a9:	ff 
  2137aa:	c5 f9 7f 84 24 40 01 	vmovdqa XMMWORD PTR [rsp+0x140],xmm0
  2137b1:	00 00 
  2137b3:	66 41 bf 28 00       	mov    r15w,0x28
            return std.fmt.format(self, Error, self.writeFn, format, args);
  2137b8:	49 8b 1c 24          	mov    rbx,QWORD PTR [r12]
                        try output(context, fmt[start_index..i]);
  2137bc:	48 8d 35 95 b7 03 00 	lea    rsi,[rip+0x3b795]        # 24ef58 <__unnamed_41>
  2137c3:	4c 89 e7             	mov    rdi,r12
  2137c6:	c5 f8 77             	vzeroupper 
  2137c9:	ff d3                	call   rbx
  2137cb:	66 85 c0             	test   ax,ax
  2137ce:	75 35                	jne    213805 <dumpCurrentStackTrace+0x1615>
        stderr.print("Unable to dump stack trace: {}\n", @errorName(err)) catch return;
  2137d0:	49 0f bf c7          	movsx  rax,r15w
  2137d4:	48 c1 e0 04          	shl    rax,0x4
  2137d8:	48 8d 0d 21 88 03 00 	lea    rcx,[rip+0x38821]        # 24c000 <raw+0xf38>
                const casted_value = ([]const u8)(value);
  2137df:	c5 f8 10 04 08       	vmovups xmm0,XMMWORD PTR [rax+rcx*1]
  2137e4:	c5 f8 29 44 24 20    	vmovaps XMMWORD PTR [rsp+0x20],xmm0
  2137ea:	48 8d 74 24 20       	lea    rsi,[rsp+0x20]
                return output(context, casted_value);
  2137ef:	4c 89 e7             	mov    rdi,r12
  2137f2:	ff d3                	call   rbx
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  2137f4:	66 85 c0             	test   ax,ax
  2137f7:	75 0c                	jne    213805 <dumpCurrentStackTrace+0x1615>
        try output(context, fmt[start_index..]);
  2137f9:	48 8d 35 68 b7 03 00 	lea    rsi,[rip+0x3b768]        # 24ef68 <__unnamed_42>
  213800:	4c 89 e7             	mov    rdi,r12
  213803:	ff d3                	call   rbx
    const stderr = getStderrStream() catch return;
  213805:	48 8d 65 d8          	lea    rsp,[rbp-0x28]
  213809:	5b                   	pop    rbx
  21380a:	41 5c                	pop    r12
  21380c:	41 5d                	pop    r13
  21380e:	41 5e                	pop    r14
  213810:	41 5f                	pop    r15
  213812:	5d                   	pop    rbp
  213813:	c5 f8 77             	vzeroupper 
  213816:	c3                   	ret    
  213817:	49 89 dc             	mov    r12,rbx
        const bytes = @sliceToBytes(memory);
  21381a:	48 8b 84 24 98 00 00 	mov    rax,QWORD PTR [rsp+0x98]
  213821:	00 
        if (bytes.len == 0) return;
  213822:	48 85 c0             	test   rax,rax
  213825:	75 2f                	jne    213856 <dumpCurrentStackTrace+0x1666>
  213827:	eb 8f                	jmp    2137b8 <dumpCurrentStackTrace+0x15c8>
  213829:	4c 8b 64 24 70       	mov    r12,QWORD PTR [rsp+0x70]
        const bytes = @sliceToBytes(memory);
  21382e:	48 8b 84 24 98 00 00 	mov    rax,QWORD PTR [rsp+0x98]
  213835:	00 
        if (bytes.len == 0) return;
  213836:	48 85 c0             	test   rax,rax
  213839:	75 1b                	jne    213856 <dumpCurrentStackTrace+0x1666>
  21383b:	e9 78 ff ff ff       	jmp    2137b8 <dumpCurrentStackTrace+0x15c8>
  213840:	4c 8b 64 24 70       	mov    r12,QWORD PTR [rsp+0x70]
        const bytes = @sliceToBytes(memory);
  213845:	48 8b 84 24 98 00 00 	mov    rax,QWORD PTR [rsp+0x98]
  21384c:	00 
        if (bytes.len == 0) return;
  21384d:	48 85 c0             	test   rax,rax
  213850:	0f 84 62 ff ff ff    	je     2137b8 <dumpCurrentStackTrace+0x15c8>
  213856:	48 8b bc 24 a0 00 00 	mov    rdi,QWORD PTR [rsp+0xa0]
  21385d:	00 
        const bytes = @sliceToBytes(memory);
  21385e:	48 8b 8c 24 90 00 00 	mov    rcx,QWORD PTR [rsp+0x90]
  213865:	00 
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  213866:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  21386a:	48 89 4c 24 20       	mov    QWORD PTR [rsp+0x20],rcx
  21386f:	48 89 44 24 28       	mov    QWORD PTR [rsp+0x28],rax
  213874:	48 8d 74 24 20       	lea    rsi,[rsp+0x20]
  213879:	ff d2                	call   rdx
  21387b:	e9 38 ff ff ff       	jmp    2137b8 <dumpCurrentStackTrace+0x15c8>
        const bytes = @sliceToBytes(memory);
  213880:	48 8b 84 24 98 00 00 	mov    rax,QWORD PTR [rsp+0x98]
  213887:	00 
        if (bytes.len == 0) return;
  213888:	48 85 c0             	test   rax,rax
  21388b:	74 25                	je     2138b2 <dumpCurrentStackTrace+0x16c2>
  21388d:	48 8b bc 24 a0 00 00 	mov    rdi,QWORD PTR [rsp+0xa0]
  213894:	00 
        const bytes = @sliceToBytes(memory);
  213895:	48 8b 8c 24 90 00 00 	mov    rcx,QWORD PTR [rsp+0x90]
  21389c:	00 
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  21389d:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  2138a1:	48 89 4c 24 20       	mov    QWORD PTR [rsp+0x20],rcx
  2138a6:	48 89 44 24 28       	mov    QWORD PTR [rsp+0x28],rax
  2138ab:	48 8d 74 24 20       	lea    rsi,[rsp+0x20]
  2138b0:	ff d2                	call   rdx
  2138b2:	4c 8b 64 24 70       	mov    r12,QWORD PTR [rsp+0x70]
  2138b7:	e9 fc fe ff ff       	jmp    2137b8 <dumpCurrentStackTrace+0x15c8>
  2138bc:	48 c7 c0 fe ff ff ff 	mov    rax,0xfffffffffffffffe
        const this_key = ptr[0..line_i];
        if (!mem.eql(u8, key, this_key)) continue;

        var end_i: usize = line_i;
        while (ptr[end_i] != 0) : (end_i += 1) {}
  2138c3:	80 7c 06 11 00       	cmp    BYTE PTR [rsi+rax*1+0x11],0x0
  2138c8:	48 8d 40 01          	lea    rax,[rax+0x1]
  2138cc:	75 f5                	jne    2138c3 <dumpCurrentStackTrace+0x16d3>
  2138ce:	c6 44 24 07 01       	mov    BYTE PTR [rsp+0x7],0x1
        if (new_end_index > self.buffer.len) {
  2138d3:	48 3d 81 00 00 00    	cmp    rax,0x81
        if (n == 0) {
  2138d9:	0f 83 ce eb ff ff    	jae    2124ad <dumpCurrentStackTrace+0x2bd>
  2138df:	e9 e9 eb ff ff       	jmp    2124cd <dumpCurrentStackTrace+0x2dd>
  2138e4:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  2138eb:	00 00 00 00 00 

00000000002138f0 <AlignedArrayList(Result,8)_append>:

            mem.copyBackwards(T, self.items[n + items.len .. self.len], self.items[n .. self.len - items.len]);
            mem.copy(T, self.items[n .. n + items.len], items);
        }

        pub fn append(self: *Self, item: T) !void {
  2138f0:	41 57                	push   r15
  2138f2:	41 56                	push   r14
  2138f4:	41 54                	push   r12
  2138f6:	53                   	push   rbx
  2138f7:	48 83 ec 58          	sub    rsp,0x58
  2138fb:	49 89 f6             	mov    r14,rsi
  2138fe:	49 89 fc             	mov    r12,rdi
            assert(new_len <= self.len);
            self.len = new_len;
        }

        pub fn ensureCapacity(self: *Self, new_capacity: usize) !void {
            var better_capacity = self.items.len;
  213901:	49 8b 4c 24 08       	mov    rcx,QWORD PTR [r12+0x8]
            }
            self.items = try self.allocator.alignedRealloc(T, A, self.items, better_capacity);
        }

        pub fn addOne(self: *Self) !*T {
            const new_length = self.len + 1;
  213906:	49 8b 5c 24 10       	mov    rbx,QWORD PTR [r12+0x10]
            if (better_capacity >= new_capacity) return;
  21390b:	48 39 d9             	cmp    rcx,rbx
  21390e:	76 25                	jbe    213935 <AlignedArrayList(Result,8)_append+0x45>
            try self.ensureCapacity(new_length);
            const result = &self.items[self.len];
  213910:	49 8b 04 24          	mov    rax,QWORD PTR [r12]
  213914:	48 89 d9             	mov    rcx,rbx
  213917:	48 83 c3 01          	add    rbx,0x1
  21391b:	48 c1 e1 04          	shl    rcx,0x4
            self.len = new_length;
  21391f:	49 89 5c 24 10       	mov    QWORD PTR [r12+0x10],rbx
            new_item_ptr.* = item;
  213924:	c4 c1 78 10 06       	vmovups xmm0,XMMWORD PTR [r14]
  213929:	c5 f8 11 04 08       	vmovups XMMWORD PTR [rax+rcx*1],xmm0
        pub fn append(self: *Self, item: T) !void {
  21392e:	31 c0                	xor    eax,eax
  213930:	e9 cf 00 00 00       	jmp    213a04 <AlignedArrayList(Result,8)_append+0x114>
  213935:	48 89 c8             	mov    rax,rcx
  213938:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  21393f:	00 
                better_capacity += better_capacity / 2 + 8;
  213940:	48 89 c2             	mov    rdx,rax
  213943:	48 d1 ea             	shr    rdx,1
  213946:	48 01 d0             	add    rax,rdx
  213949:	48 83 c0 08          	add    rax,0x8
                if (better_capacity >= new_capacity) break;
  21394d:	48 39 d8             	cmp    rax,rbx
  213950:	76 ee                	jbe    213940 <AlignedArrayList(Result,8)_append+0x50>
            self.items = try self.allocator.alignedRealloc(T, A, self.items, better_capacity);
  213952:	49 8b 74 24 18       	mov    rsi,QWORD PTR [r12+0x18]
        if (old_mem.len == 0) {
  213957:	48 85 c9             	test   rcx,rcx
  21395a:	74 2b                	je     213987 <AlignedArrayList(Result,8)_append+0x97>
        const old_byte_slice = @sliceToBytes(old_mem);
  21395c:	49 8b 14 24          	mov    rdx,QWORD PTR [r12]
  213960:	48 c1 e1 04          	shl    rcx,0x4
  213964:	48 89 54 24 20       	mov    QWORD PTR [rsp+0x20],rdx
  213969:	48 89 4c 24 28       	mov    QWORD PTR [rsp+0x28],rcx
    return if (@mulWithOverflow(T, a, b, &answer)) error.Overflow else answer;
  21396e:	b9 10 00 00 00       	mov    ecx,0x10
  213973:	48 f7 e1             	mul    rcx
  213976:	71 28                	jno    2139a0 <AlignedArrayList(Result,8)_append+0xb0>
  213978:	48 8d 0d 01 56 ff ff 	lea    rcx,[rip+0xffffffffffff5601]        # 208f80 <__unnamed_43>
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  21397f:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  213983:	75 7b                	jne    213a00 <AlignedArrayList(Result,8)_append+0x110>
  213985:	eb 30                	jmp    2139b7 <AlignedArrayList(Result,8)_append+0xc7>
  213987:	b9 10 00 00 00       	mov    ecx,0x10
  21398c:	48 f7 e1             	mul    rcx
  21398f:	71 58                	jno    2139e9 <AlignedArrayList(Result,8)_append+0xf9>
  213991:	48 8d 0d e8 55 ff ff 	lea    rcx,[rip+0xffffffffffff55e8]        # 208f80 <__unnamed_43>
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  213998:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  21399c:	75 62                	jne    213a00 <AlignedArrayList(Result,8)_append+0x110>
  21399e:	eb 70                	jmp    213a10 <AlignedArrayList(Result,8)_append+0x120>
  2139a0:	48 8d 4c 24 08       	lea    rcx,[rsp+0x8]
  2139a5:	66 c7 44 24 08 00 00 	mov    WORD PTR [rsp+0x8],0x0
  2139ac:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  2139b1:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  2139b5:	75 49                	jne    213a00 <AlignedArrayList(Result,8)_append+0x110>
  2139b7:	4c 8b 79 08          	mov    r15,QWORD PTR [rcx+0x8]
  2139bb:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  2139c0:	48 8d 54 24 20       	lea    rdx,[rsp+0x20]
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  2139c5:	41 b8 08 00 00 00    	mov    r8d,0x8
  2139cb:	4c 89 f9             	mov    rcx,r15
  2139ce:	ff 56 08             	call   QWORD PTR [rsi+0x8]
  2139d1:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
  2139d6:	66 85 c0             	test   ax,ax
  2139d9:	75 29                	jne    213a04 <AlignedArrayList(Result,8)_append+0x114>
        assert(byte_slice.len == byte_count);
  2139db:	4c 39 7c 24 50       	cmp    QWORD PTR [rsp+0x50],r15
    if (!ok) {
  2139e0:	75 6e                	jne    213a50 <AlignedArrayList(Result,8)_append+0x160>
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  2139e2:	48 8b 44 24 48       	mov    rax,QWORD PTR [rsp+0x48]
  2139e7:	eb 50                	jmp    213a39 <AlignedArrayList(Result,8)_append+0x149>
  2139e9:	48 8d 4c 24 30       	lea    rcx,[rsp+0x30]
  2139ee:	66 c7 44 24 30 00 00 	mov    WORD PTR [rsp+0x30],0x0
  2139f5:	48 89 44 24 38       	mov    QWORD PTR [rsp+0x38],rax
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  2139fa:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  2139fe:	74 10                	je     213a10 <AlignedArrayList(Result,8)_append+0x120>
  213a00:	66 b8 01 00          	mov    ax,0x1
  213a04:	48 83 c4 58          	add    rsp,0x58
  213a08:	5b                   	pop    rbx
  213a09:	41 5c                	pop    r12
  213a0b:	41 5e                	pop    r14
  213a0d:	41 5f                	pop    r15
  213a0f:	c3                   	ret    
  213a10:	4c 8b 79 08          	mov    r15,QWORD PTR [rcx+0x8]
  213a14:	48 8d 7c 24 08       	lea    rdi,[rsp+0x8]
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  213a19:	b9 08 00 00 00       	mov    ecx,0x8
  213a1e:	4c 89 fa             	mov    rdx,r15
  213a21:	ff 16                	call   QWORD PTR [rsi]
  213a23:	0f b7 44 24 08       	movzx  eax,WORD PTR [rsp+0x8]
  213a28:	66 85 c0             	test   ax,ax
  213a2b:	75 d7                	jne    213a04 <AlignedArrayList(Result,8)_append+0x114>
        assert(byte_slice.len == byte_count);
  213a2d:	4c 39 7c 24 18       	cmp    QWORD PTR [rsp+0x18],r15
  213a32:	75 1c                	jne    213a50 <AlignedArrayList(Result,8)_append+0x160>
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  213a34:	48 8b 44 24 10       	mov    rax,QWORD PTR [rsp+0x10]
  213a39:	49 89 04 24          	mov    QWORD PTR [r12],rax
  213a3d:	49 c1 ef 04          	shr    r15,0x4
  213a41:	4d 89 7c 24 08       	mov    QWORD PTR [r12+0x8],r15
            const result = &self.items[self.len];
  213a46:	49 8b 4c 24 10       	mov    rcx,QWORD PTR [r12+0x10]
  213a4b:	e9 c7 fe ff ff       	jmp    213917 <AlignedArrayList(Result,8)_append+0x27>
            @panic("assertion failure");
  213a50:	48 8d 3d b1 b2 03 00 	lea    rdi,[rip+0x3b2b1]        # 24ed08 <__unnamed_2>
  213a57:	e8 c4 e5 ff ff       	call   212020 <panic>
  213a5c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

0000000000213a60 <Benchmark_report>:
    fn report(pSelf: *Self, result: Result) !void {
  213a60:	55                   	push   rbp
  213a61:	41 57                	push   r15
  213a63:	41 56                	push   r14
  213a65:	41 55                	push   r13
  213a67:	41 54                	push   r12
  213a69:	53                   	push   rbx
  213a6a:	48 81 ec b8 00 00 00 	sub    rsp,0xb8
  213a71:	48 89 f5             	mov    rbp,rsi
  213a74:	48 8b 37             	mov    rsi,QWORD PTR [rdi]
  213a77:	48 8b 5f 08          	mov    rbx,QWORD PTR [rdi+0x8]
        var buffer: [40]u8 = undefined;
  213a7b:	48 8b 05 39 1b ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffff1b39]        # 2055bb <__unnamed_7+0x20>
  213a82:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
  213a87:	c5 fd 10 05 0c 1b ff 	vmovupd ymm0,YMMWORD PTR [rip+0xffffffffffff1b0c]        # 20559b <__unnamed_7>
  213a8e:	ff 
  213a8f:	c5 fd 11 44 24 30    	vmovupd YMMWORD PTR [rsp+0x30],ymm0
const BufPrintContext = struct {
    remaining: []u8,
};

fn bufPrintWrite(context: *BufPrintContext, bytes: []const u8) !void {
    if (context.remaining.len < bytes.len) return error.BufferTooSmall;
  213a95:	48 83 fb 28          	cmp    rbx,0x28
  213a99:	0f 87 2f 02 00 00    	ja     213cce <Benchmark_report+0x26e>
    for (source) |s, i|
  213a9f:	48 85 db             	test   rbx,rbx
  213aa2:	74 12                	je     213ab6 <Benchmark_report+0x56>
  213aa4:	48 8d 7c 24 30       	lea    rdi,[rsp+0x30]
        dest[i] = s;
  213aa9:	48 89 da             	mov    rdx,rbx
  213aac:	c5 f8 77             	vzeroupper 
  213aaf:	e8 6c aa 01 00       	call   22e520 <memcpy>
  213ab4:	eb 0a                	jmp    213ac0 <Benchmark_report+0x60>
  213ab6:	31 db                	xor    ebx,ebx
  213ab8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  213abf:	00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  213ac0:	b0 01                	mov    al,0x1
  213ac2:	86 05 48 c5 03 00    	xchg   BYTE PTR [rip+0x3c548],al        # 250010 <stderr_mutex>
  213ac8:	84 c0                	test   al,al
  213aca:	75 f4                	jne    213ac0 <Benchmark_report+0x60>
    if (stderr_stream) |st| {
  213acc:	48 8b 3d 35 c5 03 00 	mov    rdi,QWORD PTR [rip+0x3c535]        # 250008 <stderr_stream>
  213ad3:	48 85 ff             	test   rdi,rdi
  213ad6:	48 89 6c 24 08       	mov    QWORD PTR [rsp+0x8],rbp
  213adb:	74 09                	je     213ae6 <Benchmark_report+0x86>
  213add:	48 8b 0d 5c 75 03 00 	mov    rcx,QWORD PTR [rip+0x3755c]        # 24b040 <stderr_file_out_stream+0x8>
  213ae4:	eb 34                	jmp    213b1a <Benchmark_report+0xba>
        stderr_file = try io.getStdErr();
  213ae6:	48 8d 05 43 75 03 00 	lea    rax,[rip+0x37543]        # 24b030 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  213aed:	48 89 05 44 75 03 00 	mov    QWORD PTR [rip+0x37544],rax        # 24b038 <stderr_file_out_stream>
  213af4:	48 8d 0d e5 be 00 00 	lea    rcx,[rip+0xbee5]        # 21f9e0 <FileOutStream_writeFn>
  213afb:	48 89 0d 3e 75 03 00 	mov    QWORD PTR [rip+0x3753e],rcx        # 24b040 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  213b02:	c7 05 24 75 03 00 02 	mov    DWORD PTR [rip+0x37524],0x2        # 24b030 <stderr_file>
  213b09:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  213b0c:	48 8d 3d 2d 75 03 00 	lea    rdi,[rip+0x3752d]        # 24b040 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  213b13:	48 89 3d ee c4 03 00 	mov    QWORD PTR [rip+0x3c4ee],rdi        # 250008 <stderr_stream>
  213b1a:	48 8d 44 24 30       	lea    rax,[rsp+0x30]
                const casted_value = ([]const u8)(value);
  213b1f:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  213b24:	48 89 5c 24 68       	mov    QWORD PTR [rsp+0x68],rbx
  213b29:	48 8d 74 24 60       	lea    rsi,[rsp+0x60]
                return output(context, casted_value);
  213b2e:	c5 f8 77             	vzeroupper 
  213b31:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  213b33:	31 c0                	xor    eax,eax
  213b35:	86 05 d5 c4 03 00    	xchg   BYTE PTR [rip+0x3c4d5],al        # 250010 <stderr_mutex>
  213b3b:	3c 01                	cmp    al,0x1
    if (!ok) {
  213b3d:	0f 85 af 09 00 00    	jne    2144f2 <Benchmark_report+0xa92>
        if (width > str.len) {
  213b43:	48 83 fb 15          	cmp    rbx,0x15
  213b47:	0f 87 b1 00 00 00    	ja     213bfe <Benchmark_report+0x19e>
            pad(width - str.len, ' ');
  213b4d:	bd 16 00 00 00       	mov    ebp,0x16
        while (i < count) : (i += 1) {
  213b52:	48 29 dd             	sub    rbp,rbx
  213b55:	0f 84 a3 00 00 00    	je     213bfe <Benchmark_report+0x19e>
  213b5b:	31 db                	xor    ebx,ebx
  213b5d:	4c 8d 35 7c be 00 00 	lea    r14,[rip+0xbe7c]        # 21f9e0 <FileOutStream_writeFn>
  213b64:	4c 8d 2d d5 74 03 00 	lea    r13,[rip+0x374d5]        # 24b040 <stderr_file_out_stream+0x8>
  213b6b:	4c 8d 7c 24 18       	lea    r15,[rsp+0x18]
  213b70:	4c 8d 64 24 60       	lea    r12,[rsp+0x60]
  213b75:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  213b7c:	00 00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  213b80:	b0 01                	mov    al,0x1
  213b82:	86 05 88 c4 03 00    	xchg   BYTE PTR [rip+0x3c488],al        # 250010 <stderr_mutex>
  213b88:	84 c0                	test   al,al
  213b8a:	75 f4                	jne    213b80 <Benchmark_report+0x120>
    if (stderr_stream) |st| {
  213b8c:	48 8b 3d 75 c4 03 00 	mov    rdi,QWORD PTR [rip+0x3c475]        # 250008 <stderr_stream>
  213b93:	48 85 ff             	test   rdi,rdi
  213b96:	74 09                	je     213ba1 <Benchmark_report+0x141>
  213b98:	48 8b 0d a1 74 03 00 	mov    rcx,QWORD PTR [rip+0x374a1]        # 24b040 <stderr_file_out_stream+0x8>
  213b9f:	eb 2c                	jmp    213bcd <Benchmark_report+0x16d>
        stderr_file = try io.getStdErr();
  213ba1:	c7 05 85 74 03 00 02 	mov    DWORD PTR [rip+0x37485],0x2        # 24b030 <stderr_file>
  213ba8:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  213bab:	48 8d 05 7e 74 03 00 	lea    rax,[rip+0x3747e]        # 24b030 <stderr_file>
  213bb2:	48 89 05 7f 74 03 00 	mov    QWORD PTR [rip+0x3747f],rax        # 24b038 <stderr_file_out_stream>
  213bb9:	4c 89 35 80 74 03 00 	mov    QWORD PTR [rip+0x37480],r14        # 24b040 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  213bc0:	4c 89 2d 41 c4 03 00 	mov    QWORD PTR [rip+0x3c441],r13        # 250008 <stderr_stream>
  213bc7:	4c 89 f1             	mov    rcx,r14
  213bca:	4c 89 ef             	mov    rdi,r13
  213bcd:	c6 44 24 18 20       	mov    BYTE PTR [rsp+0x18],0x20
    return output(context, (*[1]u8)(&c)[0..]);
  213bd2:	4c 89 7c 24 60       	mov    QWORD PTR [rsp+0x60],r15
  213bd7:	48 c7 44 24 68 01 00 	mov    QWORD PTR [rsp+0x68],0x1
  213bde:	00 00 
  213be0:	4c 89 e6             	mov    rsi,r12
  213be3:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  213be5:	31 c0                	xor    eax,eax
  213be7:	86 05 23 c4 03 00    	xchg   BYTE PTR [rip+0x3c423],al        # 250010 <stderr_mutex>
  213bed:	3c 01                	cmp    al,0x1
    if (!ok) {
  213bef:	0f 85 fd 08 00 00    	jne    2144f2 <Benchmark_report+0xa92>
  213bf5:	48 83 c3 01          	add    rbx,0x1
  213bf9:	48 39 eb             	cmp    rbx,rbp
  213bfc:	72 82                	jb     213b80 <Benchmark_report+0x120>
  213bfe:	4c 8b 7c 24 08       	mov    r15,QWORD PTR [rsp+0x8]
        try rightJustified(14, "{}", result.iterations);
  213c03:	49 8b 47 08          	mov    rax,QWORD PTR [r15+0x8]
  213c07:	4c 8b 35 ad 19 ff ff 	mov    r14,QWORD PTR [rip+0xffffffffffff19ad]        # 2055bb <__unnamed_7+0x20>
        var buffer: [40]u8 = undefined;
  213c0e:	4c 89 74 24 50       	mov    QWORD PTR [rsp+0x50],r14
  213c13:	c5 fc 10 05 80 19 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffff1980]        # 20559b <__unnamed_7>
  213c1a:	ff 
  213c1b:	c5 fc 11 44 24 30    	vmovups YMMWORD PTR [rsp+0x30],ymm0
    var buf: [max_int_digits - 1]u8 = undefined;
  213c21:	c5 fc 10 05 26 50 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffff5026]        # 208c4f <__unnamed_20+0x1f>
  213c28:	ff 
  213c29:	c5 fc 11 44 24 7f    	vmovups YMMWORD PTR [rsp+0x7f],ymm0
  213c2f:	c5 fd 10 05 f9 4f ff 	vmovupd ymm0,YMMWORD PTR [rip+0xffffffffffff4ff9]        # 208c30 <__unnamed_20>
  213c36:	ff 
  213c37:	c5 fd 11 44 24 60    	vmovupd YMMWORD PTR [rsp+0x60],ymm0
        const digit = a % base;
  213c3d:	48 be cd cc cc cc cc 	movabs rsi,0xcccccccccccccccd
  213c44:	cc cc cc 
  213c47:	48 89 c2             	mov    rdx,rax
  213c4a:	c4 e2 f3 f6 d6       	mulx   rdx,rcx,rsi
  213c4f:	c1 ea 02             	shr    edx,0x2
  213c52:	81 e2 fe ff ff 3f    	and    edx,0x3ffffffe
  213c58:	8d 0c 92             	lea    ecx,[rdx+rdx*4]
  213c5b:	89 c2                	mov    edx,eax
  213c5d:	29 ca                	sub    edx,ecx
        0...9 => digit + '0',
  213c5f:	b1 30                	mov    cl,0x30
  213c61:	80 fa 0a             	cmp    dl,0xa
  213c64:	72 02                	jb     213c68 <Benchmark_report+0x208>
  213c66:	b1 57                	mov    cl,0x57
  213c68:	00 d1                	add    cl,dl
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  213c6a:	88 8c 24 9f 00 00 00 	mov    BYTE PTR [rsp+0x9f],cl
  213c71:	bb 40 00 00 00       	mov    ebx,0x40
        if (a == 0) break;
  213c76:	48 83 f8 0a          	cmp    rax,0xa
  213c7a:	72 43                	jb     213cbf <Benchmark_report+0x25f>
  213c7c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
        a /= base;
  213c80:	48 89 c2             	mov    rdx,rax
  213c83:	c4 e2 f3 f6 d6       	mulx   rdx,rcx,rsi
  213c88:	48 c1 ea 03          	shr    rdx,0x3
        const digit = a % base;
  213c8c:	c4 e2 f3 f6 fe       	mulx   rdi,rcx,rsi
  213c91:	c1 ef 02             	shr    edi,0x2
  213c94:	81 e7 fe ff ff 3f    	and    edi,0x3ffffffe
  213c9a:	8d 0c bf             	lea    ecx,[rdi+rdi*4]
  213c9d:	89 d7                	mov    edi,edx
  213c9f:	29 cf                	sub    edi,ecx
        0...9 => digit + '0',
  213ca1:	b1 30                	mov    cl,0x30
  213ca3:	40 80 ff 0a          	cmp    dil,0xa
  213ca7:	72 02                	jb     213cab <Benchmark_report+0x24b>
  213ca9:	b1 57                	mov    cl,0x57
  213cab:	40 00 f9             	add    cl,dil
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  213cae:	88 4c 1c 5e          	mov    BYTE PTR [rsp+rbx*1+0x5e],cl
        if (a == 0) break;
  213cb2:	48 83 c3 ff          	add    rbx,0xffffffffffffffff
  213cb6:	48 83 f8 63          	cmp    rax,0x63
  213cba:	48 89 d0             	mov    rax,rdx
  213cbd:	77 c1                	ja     213c80 <Benchmark_report+0x220>
        const padded_buf = buf[index - padding ..];
  213cbf:	41 bc 41 00 00 00    	mov    r12d,0x41
  213cc5:	49 29 dc             	sub    r12,rbx
    if (context.remaining.len < bytes.len) return error.BufferTooSmall;
  213cc8:	49 83 fc 28          	cmp    r12,0x28
  213ccc:	76 19                	jbe    213ce7 <Benchmark_report+0x287>
  213cce:	66 b8 05 00          	mov    ax,0x5
  213cd2:	48 81 c4 b8 00 00 00 	add    rsp,0xb8
  213cd9:	5b                   	pop    rbx
  213cda:	41 5c                	pop    r12
  213cdc:	41 5d                	pop    r13
  213cde:	41 5e                	pop    r14
  213ce0:	41 5f                	pop    r15
  213ce2:	5d                   	pop    rbp
  213ce3:	c5 f8 77             	vzeroupper 
  213ce6:	c3                   	ret    
    for (source) |s, i|
  213ce7:	4d 85 e4             	test   r12,r12
  213cea:	74 1f                	je     213d0b <Benchmark_report+0x2ab>
        dest[i] = s;
  213cec:	88 4c 24 30          	mov    BYTE PTR [rsp+0x30],cl
    for (source) |s, i|
  213cf0:	49 83 fc 01          	cmp    r12,0x1
  213cf4:	75 27                	jne    213d1d <Benchmark_report+0x2bd>
  213cf6:	41 bc 01 00 00 00    	mov    r12d,0x1
            pad(width - str.len, ' ');
  213cfc:	bd 0e 00 00 00       	mov    ebp,0xe
        while (i < count) : (i += 1) {
  213d01:	4c 29 e5             	sub    rbp,r12
  213d04:	75 4c                	jne    213d52 <Benchmark_report+0x2f2>
  213d06:	e9 15 01 00 00       	jmp    213e20 <Benchmark_report+0x3c0>
  213d0b:	45 31 e4             	xor    r12d,r12d
            pad(width - str.len, ' ');
  213d0e:	bd 0e 00 00 00       	mov    ebp,0xe
        while (i < count) : (i += 1) {
  213d13:	4c 29 e5             	sub    rbp,r12
  213d16:	75 3a                	jne    213d52 <Benchmark_report+0x2f2>
  213d18:	e9 03 01 00 00       	jmp    213e20 <Benchmark_report+0x3c0>
  213d1d:	48 8d 7c 24 31       	lea    rdi,[rsp+0x31]
  213d22:	48 8d 34 1c          	lea    rsi,[rsp+rbx*1]
  213d26:	48 83 c6 60          	add    rsi,0x60
  213d2a:	ba 40 00 00 00       	mov    edx,0x40
  213d2f:	48 29 da             	sub    rdx,rbx
        dest[i] = s;
  213d32:	c5 f8 77             	vzeroupper 
  213d35:	e8 e6 a7 01 00       	call   22e520 <memcpy>
        if (width > str.len) {
  213d3a:	49 83 fc 0d          	cmp    r12,0xd
  213d3e:	0f 87 dc 00 00 00    	ja     213e20 <Benchmark_report+0x3c0>
            pad(width - str.len, ' ');
  213d44:	bd 0e 00 00 00       	mov    ebp,0xe
        while (i < count) : (i += 1) {
  213d49:	4c 29 e5             	sub    rbp,r12
  213d4c:	0f 84 ce 00 00 00    	je     213e20 <Benchmark_report+0x3c0>
  213d52:	4c 89 64 24 10       	mov    QWORD PTR [rsp+0x10],r12
  213d57:	45 31 ff             	xor    r15d,r15d
  213d5a:	4c 8d 2d 7f bc 00 00 	lea    r13,[rip+0xbc7f]        # 21f9e0 <FileOutStream_writeFn>
  213d61:	4c 8d 35 d8 72 03 00 	lea    r14,[rip+0x372d8]        # 24b040 <stderr_file_out_stream+0x8>
  213d68:	4c 8d 64 24 18       	lea    r12,[rsp+0x18]
  213d6d:	48 8d 5c 24 60       	lea    rbx,[rsp+0x60]
  213d72:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  213d79:	1f 84 00 00 00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  213d80:	b0 01                	mov    al,0x1
  213d82:	86 05 88 c2 03 00    	xchg   BYTE PTR [rip+0x3c288],al        # 250010 <stderr_mutex>
  213d88:	84 c0                	test   al,al
  213d8a:	75 f4                	jne    213d80 <Benchmark_report+0x320>
    if (stderr_stream) |st| {
  213d8c:	48 8b 3d 75 c2 03 00 	mov    rdi,QWORD PTR [rip+0x3c275]        # 250008 <stderr_stream>
  213d93:	48 85 ff             	test   rdi,rdi
  213d96:	74 09                	je     213da1 <Benchmark_report+0x341>
  213d98:	48 8b 0d a1 72 03 00 	mov    rcx,QWORD PTR [rip+0x372a1]        # 24b040 <stderr_file_out_stream+0x8>
  213d9f:	eb 2c                	jmp    213dcd <Benchmark_report+0x36d>
        stderr_file = try io.getStdErr();
  213da1:	c7 05 85 72 03 00 02 	mov    DWORD PTR [rip+0x37285],0x2        # 24b030 <stderr_file>
  213da8:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  213dab:	48 8d 05 7e 72 03 00 	lea    rax,[rip+0x3727e]        # 24b030 <stderr_file>
  213db2:	48 89 05 7f 72 03 00 	mov    QWORD PTR [rip+0x3727f],rax        # 24b038 <stderr_file_out_stream>
  213db9:	4c 89 2d 80 72 03 00 	mov    QWORD PTR [rip+0x37280],r13        # 24b040 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  213dc0:	4c 89 35 41 c2 03 00 	mov    QWORD PTR [rip+0x3c241],r14        # 250008 <stderr_stream>
  213dc7:	4c 89 e9             	mov    rcx,r13
  213dca:	4c 89 f7             	mov    rdi,r14
  213dcd:	c6 44 24 18 20       	mov    BYTE PTR [rsp+0x18],0x20
    return output(context, (*[1]u8)(&c)[0..]);
  213dd2:	4c 89 64 24 60       	mov    QWORD PTR [rsp+0x60],r12
  213dd7:	48 c7 44 24 68 01 00 	mov    QWORD PTR [rsp+0x68],0x1
  213dde:	00 00 
  213de0:	48 89 de             	mov    rsi,rbx
  213de3:	c5 f8 77             	vzeroupper 
  213de6:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  213de8:	31 c0                	xor    eax,eax
  213dea:	86 05 20 c2 03 00    	xchg   BYTE PTR [rip+0x3c220],al        # 250010 <stderr_mutex>
  213df0:	3c 01                	cmp    al,0x1
    if (!ok) {
  213df2:	0f 85 fa 06 00 00    	jne    2144f2 <Benchmark_report+0xa92>
  213df8:	49 83 c7 01          	add    r15,0x1
  213dfc:	49 39 ef             	cmp    r15,rbp
  213dff:	0f 82 7b ff ff ff    	jb     213d80 <Benchmark_report+0x320>
  213e05:	4c 8b 35 af 17 ff ff 	mov    r14,QWORD PTR [rip+0xffffffffffff17af]        # 2055bb <__unnamed_7+0x20>
  213e0c:	4c 8b 7c 24 08       	mov    r15,QWORD PTR [rsp+0x8]
  213e11:	4c 8b 64 24 10       	mov    r12,QWORD PTR [rsp+0x10]
  213e16:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  213e1d:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  213e20:	b0 01                	mov    al,0x1
  213e22:	86 05 e8 c1 03 00    	xchg   BYTE PTR [rip+0x3c1e8],al        # 250010 <stderr_mutex>
  213e28:	84 c0                	test   al,al
  213e2a:	75 f4                	jne    213e20 <Benchmark_report+0x3c0>
    if (stderr_stream) |st| {
  213e2c:	48 8b 3d d5 c1 03 00 	mov    rdi,QWORD PTR [rip+0x3c1d5]        # 250008 <stderr_stream>
  213e33:	48 85 ff             	test   rdi,rdi
  213e36:	74 09                	je     213e41 <Benchmark_report+0x3e1>
  213e38:	48 8b 0d 01 72 03 00 	mov    rcx,QWORD PTR [rip+0x37201]        # 24b040 <stderr_file_out_stream+0x8>
  213e3f:	eb 34                	jmp    213e75 <Benchmark_report+0x415>
        stderr_file = try io.getStdErr();
  213e41:	48 8d 05 e8 71 03 00 	lea    rax,[rip+0x371e8]        # 24b030 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  213e48:	48 89 05 e9 71 03 00 	mov    QWORD PTR [rip+0x371e9],rax        # 24b038 <stderr_file_out_stream>
  213e4f:	48 8d 0d 8a bb 00 00 	lea    rcx,[rip+0xbb8a]        # 21f9e0 <FileOutStream_writeFn>
  213e56:	48 89 0d e3 71 03 00 	mov    QWORD PTR [rip+0x371e3],rcx        # 24b040 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  213e5d:	c7 05 c9 71 03 00 02 	mov    DWORD PTR [rip+0x371c9],0x2        # 24b030 <stderr_file>
  213e64:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  213e67:	48 8d 3d d2 71 03 00 	lea    rdi,[rip+0x371d2]        # 24b040 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  213e6e:	48 89 3d 93 c1 03 00 	mov    QWORD PTR [rip+0x3c193],rdi        # 250008 <stderr_stream>
                const casted_value = ([]const u8)(value);
  213e75:	48 8d 44 24 30       	lea    rax,[rsp+0x30]
  213e7a:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  213e7f:	4c 89 64 24 68       	mov    QWORD PTR [rsp+0x68],r12
  213e84:	48 8d 5c 24 60       	lea    rbx,[rsp+0x60]
                return output(context, casted_value);
  213e89:	48 89 de             	mov    rsi,rbx
  213e8c:	c5 f8 77             	vzeroupper 
  213e8f:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  213e91:	31 c0                	xor    eax,eax
  213e93:	86 05 77 c1 03 00    	xchg   BYTE PTR [rip+0x3c177],al        # 250010 <stderr_mutex>
  213e99:	3c 01                	cmp    al,0x1
    if (!ok) {
  213e9b:	0f 85 51 06 00 00    	jne    2144f2 <Benchmark_report+0xa92>
                @intToFloat(f64, result.run_time_ns)/@intToFloat(f64, ns_per_s));
  213ea1:	c4 c1 7b 10 07       	vmovsd xmm0,QWORD PTR [r15]
  213ea6:	c5 f8 14 05 22 4e ff 	vunpcklps xmm0,xmm0,XMMWORD PTR [rip+0xffffffffffff4e22]        # 208cd0 <__unnamed_629+0x17>
  213ead:	ff 
  213eae:	c5 f9 5c 05 3a 53 ff 	vsubpd xmm0,xmm0,XMMWORD PTR [rip+0xffffffffffff533a]        # 2091f0 <__unnamed_70+0x10>
  213eb5:	ff 
  213eb6:	c5 f9 7c c0          	vhaddpd xmm0,xmm0,xmm0
  213eba:	c5 fb 5e 05 ee c3 fe 	vdivsd xmm0,xmm0,QWORD PTR [rip+0xfffffffffffec3ee]        # 2002b0 <__unnamed_10+0x30>
  213ec1:	ff 
        var buffer: [40]u8 = undefined;
  213ec2:	4c 89 74 24 50       	mov    QWORD PTR [rsp+0x50],r14
  213ec7:	c5 fc 10 0d cc 16 ff 	vmovups ymm1,YMMWORD PTR [rip+0xffffffffffff16cc]        # 20559b <__unnamed_7>
  213ece:	ff 
  213ecf:	c5 fc 11 4c 24 30    	vmovups YMMWORD PTR [rsp+0x30],ymm1
    const bits = @bitCast(u32, x);
    return bits >> 31 != 0;
}

fn signbit64(x: f64) bool {
    const bits = @bitCast(u64, x);
  213ed5:	c4 e1 f9 7e c0       	vmovq  rax,xmm0
    return bits >> 63 != 0;
  213eda:	48 85 c0             	test   rax,rax
    if (math.signbit(x)) {
  213edd:	78 0d                	js     213eec <Benchmark_report+0x48c>
  213edf:	41 be 28 00 00 00    	mov    r14d,0x28
  213ee5:	48 8d 6c 24 30       	lea    rbp,[rsp+0x30]
  213eea:	eb 18                	jmp    213f04 <Benchmark_report+0x4a4>
  213eec:	c6 44 24 30 2d       	mov    BYTE PTR [rsp+0x30],0x2d
    mem.copy(u8, context.remaining, bytes);
    context.remaining = context.remaining[bytes.len..];
  213ef1:	48 8d 6c 24 31       	lea    rbp,[rsp+0x31]
        x = -x;
  213ef6:	c5 f9 57 05 12 53 ff 	vxorpd xmm0,xmm0,XMMWORD PTR [rip+0xffffffffffff5312]        # 209210 <__unnamed_551+0x10>
  213efd:	ff 
  213efe:	41 be 27 00 00 00    	mov    r14d,0x27
  213f04:	48 ba 00 00 00 00 00 	movabs rdx,0x7ff0000000000000
  213f0b:	00 f0 7f 
        f32 => {
            const bits = @bitCast(u32, x);
            return bits & 0x7FFFFFFF > 0x7F800000;
        },
        f64 => {
            const bits = @bitCast(u64, x);
  213f0e:	c4 e1 f9 7e c0       	vmovq  rax,xmm0
            return (bits & (@maxValue(u64) >> 1)) > (u64(0x7FF) << 52);
  213f13:	b1 3f                	mov    cl,0x3f
  213f15:	c4 e2 f0 f5 c8       	bzhi   rcx,rax,rcx
  213f1a:	48 39 d1             	cmp    rcx,rdx
    if (math.isNan(x)) {
  213f1d:	76 0c                	jbe    213f2b <Benchmark_report+0x4cb>
  213f1f:	66 c7 45 00 6e 61    	mov    WORD PTR [rbp+0x0],0x616e
  213f25:	c6 45 02 6e          	mov    BYTE PTR [rbp+0x2],0x6e
  213f29:	eb 13                	jmp    213f3e <Benchmark_report+0x4de>
        },
        f32 => {
            return @bitCast(u32, x) == 0x7F800000;
        },
        f64 => {
            return @bitCast(u64, x) == 0x7FF << 52;
  213f2b:	48 39 d0             	cmp    rax,rdx
    if (math.isPositiveInf(x)) {
  213f2e:	0f 85 44 01 00 00    	jne    214078 <Benchmark_report+0x618>
  213f34:	66 c7 45 00 69 6e    	mov    WORD PTR [rbp+0x0],0x6e69
  213f3a:	c6 45 02 66          	mov    BYTE PTR [rbp+0x2],0x66
    context.remaining = context.remaining[bytes.len..];
  213f3e:	48 83 c5 03          	add    rbp,0x3
  213f42:	49 83 c6 fd          	add    r14,0xfffffffffffffffd
  213f46:	31 c0                	xor    eax,eax
  213f48:	4c 89 f7             	mov    rdi,r14
                    try formatType(args[next_arg], fmt[s..i], context, Errors, output);
  213f4b:	66 85 c0             	test   ax,ax
  213f4e:	0f 85 7e fd ff ff    	jne    213cd2 <Benchmark_report+0x272>
  213f54:	66 b8 05 00          	mov    ax,0x5
    if (context.remaining.len < bytes.len) return error.BufferTooSmall;
  213f58:	48 83 ff 02          	cmp    rdi,0x2
  213f5c:	0f 82 70 fd ff ff    	jb     213cd2 <Benchmark_report+0x272>
  213f62:	66 c7 45 00 20 73    	mov    WORD PTR [rbp+0x0],0x7320
}

pub fn bufPrint(buf: []u8, comptime fmt: []const u8, args: ...) ![]u8 {
    var context = BufPrintContext{ .remaining = buf };
    try format(&context, error{BufferTooSmall}, bufPrintWrite, fmt, args);
    return buf[0 .. buf.len - context.remaining.len];
  213f68:	b8 2a 00 00 00       	mov    eax,0x2a
  213f6d:	48 29 f8             	sub    rax,rdi
  213f70:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
        if (width > str.len) {
  213f75:	48 83 f8 0c          	cmp    rax,0xc
  213f79:	0f 83 d1 00 00 00    	jae    214050 <Benchmark_report+0x5f0>
  213f7f:	b8 02 00 00 00       	mov    eax,0x2
  213f84:	48 29 f8             	sub    rax,rdi
            pad(width - str.len, ' ');
  213f87:	48 c7 c5 e4 ff ff ff 	mov    rbp,0xffffffffffffffe4
        while (i < count) : (i += 1) {
  213f8e:	48 29 c5             	sub    rbp,rax
  213f91:	0f 84 b9 00 00 00    	je     214050 <Benchmark_report+0x5f0>
  213f97:	31 db                	xor    ebx,ebx
  213f99:	4c 8d 25 40 ba 00 00 	lea    r12,[rip+0xba40]        # 21f9e0 <FileOutStream_writeFn>
  213fa0:	4c 8d 35 99 70 03 00 	lea    r14,[rip+0x37099]        # 24b040 <stderr_file_out_stream+0x8>
  213fa7:	4c 8d 6c 24 18       	lea    r13,[rsp+0x18]
  213fac:	4c 8d 7c 24 60       	lea    r15,[rsp+0x60]
  213fb1:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  213fb8:	0f 1f 84 00 00 00 00 
  213fbf:	00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  213fc0:	b0 01                	mov    al,0x1
  213fc2:	86 05 48 c0 03 00    	xchg   BYTE PTR [rip+0x3c048],al        # 250010 <stderr_mutex>
  213fc8:	84 c0                	test   al,al
  213fca:	75 f4                	jne    213fc0 <Benchmark_report+0x560>
    if (stderr_stream) |st| {
  213fcc:	48 8b 3d 35 c0 03 00 	mov    rdi,QWORD PTR [rip+0x3c035]        # 250008 <stderr_stream>
  213fd3:	48 85 ff             	test   rdi,rdi
  213fd6:	74 09                	je     213fe1 <Benchmark_report+0x581>
  213fd8:	48 8b 0d 61 70 03 00 	mov    rcx,QWORD PTR [rip+0x37061]        # 24b040 <stderr_file_out_stream+0x8>
  213fdf:	eb 2c                	jmp    21400d <Benchmark_report+0x5ad>
        stderr_file = try io.getStdErr();
  213fe1:	c7 05 45 70 03 00 02 	mov    DWORD PTR [rip+0x37045],0x2        # 24b030 <stderr_file>
  213fe8:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  213feb:	48 8d 05 3e 70 03 00 	lea    rax,[rip+0x3703e]        # 24b030 <stderr_file>
  213ff2:	48 89 05 3f 70 03 00 	mov    QWORD PTR [rip+0x3703f],rax        # 24b038 <stderr_file_out_stream>
  213ff9:	4c 89 25 40 70 03 00 	mov    QWORD PTR [rip+0x37040],r12        # 24b040 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  214000:	4c 89 35 01 c0 03 00 	mov    QWORD PTR [rip+0x3c001],r14        # 250008 <stderr_stream>
  214007:	4c 89 e1             	mov    rcx,r12
  21400a:	4c 89 f7             	mov    rdi,r14
  21400d:	c6 44 24 18 20       	mov    BYTE PTR [rsp+0x18],0x20
    return output(context, (*[1]u8)(&c)[0..]);
  214012:	4c 89 6c 24 60       	mov    QWORD PTR [rsp+0x60],r13
  214017:	48 c7 44 24 68 01 00 	mov    QWORD PTR [rsp+0x68],0x1
  21401e:	00 00 
  214020:	4c 89 fe             	mov    rsi,r15
  214023:	c5 f8 77             	vzeroupper 
  214026:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  214028:	31 c0                	xor    eax,eax
  21402a:	86 05 e0 bf 03 00    	xchg   BYTE PTR [rip+0x3bfe0],al        # 250010 <stderr_mutex>
  214030:	3c 01                	cmp    al,0x1
    if (!ok) {
  214032:	0f 85 ba 04 00 00    	jne    2144f2 <Benchmark_report+0xa92>
  214038:	48 83 c3 01          	add    rbx,0x1
  21403c:	48 39 eb             	cmp    rbx,rbp
  21403f:	0f 82 7b ff ff ff    	jb     213fc0 <Benchmark_report+0x560>
  214045:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21404c:	00 00 00 00 
  214050:	b0 01                	mov    al,0x1
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  214052:	86 05 b8 bf 03 00    	xchg   BYTE PTR [rip+0x3bfb8],al        # 250010 <stderr_mutex>
  214058:	84 c0                	test   al,al
  21405a:	75 f4                	jne    214050 <Benchmark_report+0x5f0>
    if (stderr_stream) |st| {
  21405c:	48 8b 3d a5 bf 03 00 	mov    rdi,QWORD PTR [rip+0x3bfa5]        # 250008 <stderr_stream>
  214063:	48 85 ff             	test   rdi,rdi
  214066:	0f 84 91 00 00 00    	je     2140fd <Benchmark_report+0x69d>
  21406c:	48 8b 0d cd 6f 03 00 	mov    rcx,QWORD PTR [rip+0x36fcd]        # 24b040 <stderr_file_out_stream+0x8>
  214073:	e9 b9 00 00 00       	jmp    214131 <Benchmark_report+0x6d1>
    if (x == 0.0) {
  214078:	c5 f0 57 c9          	vxorps xmm1,xmm1,xmm1
  21407c:	c5 f9 2e c1          	vucomisd xmm0,xmm1
  214080:	75 1a                	jne    21409c <Benchmark_report+0x63c>
  214082:	7a 18                	jp     21409c <Benchmark_report+0x63c>
  214084:	c7 45 00 30 2e 30 30 	mov    DWORD PTR [rbp+0x0],0x30302e30
  21408b:	c6 45 04 30          	mov    BYTE PTR [rbp+0x4],0x30
    context.remaining = context.remaining[bytes.len..];
  21408f:	48 83 c5 05          	add    rbp,0x5
  214093:	49 83 c6 fb          	add    r14,0xfffffffffffffffb
  214097:	e9 aa fe ff ff       	jmp    213f46 <Benchmark_report+0x4e6>
    var buffer: [32]u8 = undefined;
  21409c:	c5 fc 10 0d 5c c1 fe 	vmovups ymm1,YMMWORD PTR [rip+0xfffffffffffec15c]        # 200200 <__unnamed_44>
  2140a3:	ff 
  2140a4:	c5 fc 11 4c 24 60    	vmovups YMMWORD PTR [rsp+0x60],ymm1
    var float_decimal = errol.errol3(x, buffer[0..]);
  2140aa:	48 89 9c 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],rbx
  2140b1:	00 
  2140b2:	48 c7 84 24 b0 00 00 	mov    QWORD PTR [rsp+0xb0],0x20
  2140b9:	00 20 00 00 00 
  2140be:	48 8d 7c 24 18       	lea    rdi,[rsp+0x18]
  2140c3:	48 8d b4 24 a8 00 00 	lea    rsi,[rsp+0xa8]
  2140ca:	00 
  2140cb:	c5 f8 77             	vzeroupper 
  2140ce:	e8 7d 83 01 00       	call   22c450 <errol3>
  2140d3:	4c 8b 6c 24 18       	mov    r13,QWORD PTR [rsp+0x18]
  2140d8:	4c 8b 4c 24 20       	mov    r9,QWORD PTR [rsp+0x20]
  2140dd:	4c 63 44 24 28       	movsxd r8,DWORD PTR [rsp+0x28]
  2140e2:	4d 85 c0             	test   r8,r8
    // whether we need to round to match the specified precision.
    var round_digit: usize = 0;

    switch (mode) {
        RoundMode.Decimal => {
            if (float_decimal.exp >= 0) {
  2140e5:	0f 88 92 02 00 00    	js     21437d <Benchmark_report+0x91d>
                round_digit = precision + @intCast(usize, float_decimal.exp);
  2140eb:	49 8d 50 03          	lea    rdx,[r8+0x3]

    // It suffices to look at just this digit. We don't round and propagate say 0.04999 to 0.05
    // first, and then to 0.1 in the case of a {.1} single precision.

    // Find the digit which will signify the round point and start rounding backwards.
    if (round_digit < float_decimal.digits.len and float_decimal.digits[round_digit] - '0' >= 5) {
  2140ef:	4c 39 ca             	cmp    rdx,r9
  2140f2:	0f 82 0e 03 00 00    	jb     214406 <Benchmark_report+0x9a6>
  2140f8:	e9 12 04 00 00       	jmp    21450f <Benchmark_report+0xaaf>
        stderr_file = try io.getStdErr();
  2140fd:	48 8d 05 2c 6f 03 00 	lea    rax,[rip+0x36f2c]        # 24b030 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  214104:	48 89 05 2d 6f 03 00 	mov    QWORD PTR [rip+0x36f2d],rax        # 24b038 <stderr_file_out_stream>
  21410b:	48 8d 0d ce b8 00 00 	lea    rcx,[rip+0xb8ce]        # 21f9e0 <FileOutStream_writeFn>
  214112:	48 89 0d 27 6f 03 00 	mov    QWORD PTR [rip+0x36f27],rcx        # 24b040 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  214119:	c7 05 0d 6f 03 00 02 	mov    DWORD PTR [rip+0x36f0d],0x2        # 24b030 <stderr_file>
  214120:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  214123:	48 8d 3d 16 6f 03 00 	lea    rdi,[rip+0x36f16]        # 24b040 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  21412a:	48 89 3d d7 be 03 00 	mov    QWORD PTR [rip+0x3bed7],rdi        # 250008 <stderr_stream>
  214131:	48 8b 2d 83 14 ff ff 	mov    rbp,QWORD PTR [rip+0xffffffffffff1483]        # 2055bb <__unnamed_7+0x20>
  214138:	48 8b 5c 24 08       	mov    rbx,QWORD PTR [rsp+0x8]
  21413d:	49 bf 00 00 00 00 00 	movabs r15,0x7ff0000000000000
  214144:	00 f0 7f 
  214147:	4c 8d 74 24 30       	lea    r14,[rsp+0x30]
                const casted_value = ([]const u8)(value);
  21414c:	4c 89 74 24 60       	mov    QWORD PTR [rsp+0x60],r14
  214151:	48 8b 44 24 10       	mov    rax,QWORD PTR [rsp+0x10]
  214156:	48 89 44 24 68       	mov    QWORD PTR [rsp+0x68],rax
  21415b:	4c 8d 6c 24 60       	lea    r13,[rsp+0x60]
                return output(context, casted_value);
  214160:	4c 89 ee             	mov    rsi,r13
  214163:	c5 f8 77             	vzeroupper 
  214166:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  214168:	31 c0                	xor    eax,eax
  21416a:	86 05 a0 be 03 00    	xchg   BYTE PTR [rip+0x3bea0],al        # 250010 <stderr_mutex>
  214170:	3c 01                	cmp    al,0x1
    if (!ok) {
  214172:	0f 85 7a 03 00 00    	jne    2144f2 <Benchmark_report+0xa92>
                @intToFloat(f64, result.run_time_ns)/@intToFloat(f64, result.iterations));
  214178:	c5 fb 10 03          	vmovsd xmm0,QWORD PTR [rbx]
  21417c:	c5 f9 28 0d 4c 4b ff 	vmovapd xmm1,XMMWORD PTR [rip+0xffffffffffff4b4c]        # 208cd0 <__unnamed_629+0x17>
  214183:	ff 
  214184:	c5 f8 14 c1          	vunpcklps xmm0,xmm0,xmm1
  214188:	c5 f9 28 15 60 50 ff 	vmovapd xmm2,XMMWORD PTR [rip+0xffffffffffff5060]        # 2091f0 <__unnamed_70+0x10>
  21418f:	ff 
  214190:	c5 f9 5c c2          	vsubpd xmm0,xmm0,xmm2
  214194:	c5 f9 7c c0          	vhaddpd xmm0,xmm0,xmm0
  214198:	c5 fb 10 5b 08       	vmovsd xmm3,QWORD PTR [rbx+0x8]
  21419d:	c5 e0 14 c9          	vunpcklps xmm1,xmm3,xmm1
  2141a1:	c5 f1 5c ca          	vsubpd xmm1,xmm1,xmm2
  2141a5:	c5 f1 7c c9          	vhaddpd xmm1,xmm1,xmm1
  2141a9:	c5 fb 5e c1          	vdivsd xmm0,xmm0,xmm1
        var buffer: [40]u8 = undefined;
  2141ad:	48 89 6c 24 50       	mov    QWORD PTR [rsp+0x50],rbp
  2141b2:	c5 fc 10 0d e1 13 ff 	vmovups ymm1,YMMWORD PTR [rip+0xffffffffffff13e1]        # 20559b <__unnamed_7>
  2141b9:	ff 
  2141ba:	c5 fc 11 4c 24 30    	vmovups YMMWORD PTR [rsp+0x30],ymm1
    const bits = @bitCast(u64, x);
  2141c0:	c4 e1 f9 7e c0       	vmovq  rax,xmm0
    return bits >> 63 != 0;
  2141c5:	48 85 c0             	test   rax,rax
    if (math.signbit(x)) {
  2141c8:	78 07                	js     2141d1 <Benchmark_report+0x771>
  2141ca:	bd 28 00 00 00       	mov    ebp,0x28
  2141cf:	eb 17                	jmp    2141e8 <Benchmark_report+0x788>
  2141d1:	c6 44 24 30 2d       	mov    BYTE PTR [rsp+0x30],0x2d
    context.remaining = context.remaining[bytes.len..];
  2141d6:	4c 8d 74 24 31       	lea    r14,[rsp+0x31]
        x = -x;
  2141db:	c5 f9 57 05 2d 50 ff 	vxorpd xmm0,xmm0,XMMWORD PTR [rip+0xffffffffffff502d]        # 209210 <__unnamed_551+0x10>
  2141e2:	ff 
  2141e3:	bd 27 00 00 00       	mov    ebp,0x27
            const bits = @bitCast(u64, x);
  2141e8:	c4 e1 f9 7e c0       	vmovq  rax,xmm0
  2141ed:	48 b9 ff ff ff ff ff 	movabs rcx,0x7fffffffffffffff
  2141f4:	ff ff 7f 
            return (bits & (@maxValue(u64) >> 1)) > (u64(0x7FF) << 52);
  2141f7:	48 21 c1             	and    rcx,rax
  2141fa:	4c 39 f9             	cmp    rcx,r15
    if (math.isNan(x)) {
  2141fd:	76 0d                	jbe    21420c <Benchmark_report+0x7ac>
  2141ff:	66 41 c7 06 6e 61    	mov    WORD PTR [r14],0x616e
  214205:	41 c6 46 02 6e       	mov    BYTE PTR [r14+0x2],0x6e
  21420a:	eb 14                	jmp    214220 <Benchmark_report+0x7c0>
  21420c:	4c 39 f8             	cmp    rax,r15
    if (math.isPositiveInf(x)) {
  21420f:	0f 85 43 01 00 00    	jne    214358 <Benchmark_report+0x8f8>
  214215:	66 41 c7 06 69 6e    	mov    WORD PTR [r14],0x6e69
  21421b:	41 c6 46 02 66       	mov    BYTE PTR [r14+0x2],0x66
    context.remaining = context.remaining[bytes.len..];
  214220:	49 83 c6 03          	add    r14,0x3
  214224:	48 83 c5 fd          	add    rbp,0xfffffffffffffffd
  214228:	31 c0                	xor    eax,eax
  21422a:	48 89 ef             	mov    rdi,rbp
                    try formatType(args[next_arg], fmt[s..i], context, Errors, output);
  21422d:	66 85 c0             	test   ax,ax
  214230:	0f 85 9c fa ff ff    	jne    213cd2 <Benchmark_report+0x272>
  214236:	66 b8 05 00          	mov    ax,0x5
    if (context.remaining.len < bytes.len) return error.BufferTooSmall;
  21423a:	48 83 ff 06          	cmp    rdi,0x6
  21423e:	0f 82 8e fa ff ff    	jb     213cd2 <Benchmark_report+0x272>
  214244:	41 c7 06 20 6e 73 2f 	mov    DWORD PTR [r14],0x2f736e20
  21424b:	66 41 c7 46 04 6f 70 	mov    WORD PTR [r14+0x4],0x706f
    return buf[0 .. buf.len - context.remaining.len];
  214252:	b8 2e 00 00 00       	mov    eax,0x2e
  214257:	48 29 f8             	sub    rax,rdi
  21425a:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
        if (width > str.len) {
  21425f:	48 83 f8 12          	cmp    rax,0x12
  214263:	0f 83 c7 00 00 00    	jae    214330 <Benchmark_report+0x8d0>
  214269:	b8 06 00 00 00       	mov    eax,0x6
  21426e:	48 29 f8             	sub    rax,rdi
            pad(width - str.len, ' ');
  214271:	48 c7 c5 ea ff ff ff 	mov    rbp,0xffffffffffffffea
        while (i < count) : (i += 1) {
  214278:	48 29 c5             	sub    rbp,rax
  21427b:	0f 84 af 00 00 00    	je     214330 <Benchmark_report+0x8d0>
  214281:	31 db                	xor    ebx,ebx
  214283:	4c 8d 2d 56 b7 00 00 	lea    r13,[rip+0xb756]        # 21f9e0 <FileOutStream_writeFn>
  21428a:	4c 8d 25 af 6d 03 00 	lea    r12,[rip+0x36daf]        # 24b040 <stderr_file_out_stream+0x8>
  214291:	4c 8d 74 24 18       	lea    r14,[rsp+0x18]
  214296:	4c 8d 7c 24 60       	lea    r15,[rsp+0x60]
  21429b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  2142a0:	b0 01                	mov    al,0x1
  2142a2:	86 05 68 bd 03 00    	xchg   BYTE PTR [rip+0x3bd68],al        # 250010 <stderr_mutex>
  2142a8:	84 c0                	test   al,al
  2142aa:	75 f4                	jne    2142a0 <Benchmark_report+0x840>
    if (stderr_stream) |st| {
  2142ac:	48 8b 3d 55 bd 03 00 	mov    rdi,QWORD PTR [rip+0x3bd55]        # 250008 <stderr_stream>
  2142b3:	48 85 ff             	test   rdi,rdi
  2142b6:	74 09                	je     2142c1 <Benchmark_report+0x861>
  2142b8:	48 8b 0d 81 6d 03 00 	mov    rcx,QWORD PTR [rip+0x36d81]        # 24b040 <stderr_file_out_stream+0x8>
  2142bf:	eb 2c                	jmp    2142ed <Benchmark_report+0x88d>
        stderr_file = try io.getStdErr();
  2142c1:	c7 05 65 6d 03 00 02 	mov    DWORD PTR [rip+0x36d65],0x2        # 24b030 <stderr_file>
  2142c8:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  2142cb:	48 8d 05 5e 6d 03 00 	lea    rax,[rip+0x36d5e]        # 24b030 <stderr_file>
  2142d2:	48 89 05 5f 6d 03 00 	mov    QWORD PTR [rip+0x36d5f],rax        # 24b038 <stderr_file_out_stream>
  2142d9:	4c 89 2d 60 6d 03 00 	mov    QWORD PTR [rip+0x36d60],r13        # 24b040 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  2142e0:	4c 89 25 21 bd 03 00 	mov    QWORD PTR [rip+0x3bd21],r12        # 250008 <stderr_stream>
  2142e7:	4c 89 e9             	mov    rcx,r13
  2142ea:	4c 89 e7             	mov    rdi,r12
  2142ed:	c6 44 24 18 20       	mov    BYTE PTR [rsp+0x18],0x20
    return output(context, (*[1]u8)(&c)[0..]);
  2142f2:	4c 89 74 24 60       	mov    QWORD PTR [rsp+0x60],r14
  2142f7:	48 c7 44 24 68 01 00 	mov    QWORD PTR [rsp+0x68],0x1
  2142fe:	00 00 
  214300:	4c 89 fe             	mov    rsi,r15
  214303:	c5 f8 77             	vzeroupper 
  214306:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  214308:	31 c0                	xor    eax,eax
  21430a:	86 05 00 bd 03 00    	xchg   BYTE PTR [rip+0x3bd00],al        # 250010 <stderr_mutex>
  214310:	3c 01                	cmp    al,0x1
    if (!ok) {
  214312:	0f 85 da 01 00 00    	jne    2144f2 <Benchmark_report+0xa92>
  214318:	48 83 c3 01          	add    rbx,0x1
  21431c:	48 39 eb             	cmp    rbx,rbp
  21431f:	0f 82 7b ff ff ff    	jb     2142a0 <Benchmark_report+0x840>
  214325:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21432c:	00 00 00 00 
  214330:	b0 01                	mov    al,0x1
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  214332:	86 05 d8 bc 03 00    	xchg   BYTE PTR [rip+0x3bcd8],al        # 250010 <stderr_mutex>
  214338:	84 c0                	test   al,al
  21433a:	75 f4                	jne    214330 <Benchmark_report+0x8d0>
    if (stderr_stream) |st| {
  21433c:	48 8b 3d c5 bc 03 00 	mov    rdi,QWORD PTR [rip+0x3bcc5]        # 250008 <stderr_stream>
  214343:	48 85 ff             	test   rdi,rdi
  214346:	0f 84 41 01 00 00    	je     21448d <Benchmark_report+0xa2d>
  21434c:	48 8b 0d ed 6c 03 00 	mov    rcx,QWORD PTR [rip+0x36ced]        # 24b040 <stderr_file_out_stream+0x8>
  214353:	e9 69 01 00 00       	jmp    2144c1 <Benchmark_report+0xa61>
    if (x == 0.0) {
  214358:	c5 f0 57 c9          	vxorps xmm1,xmm1,xmm1
  21435c:	c5 f9 2e c1          	vucomisd xmm0,xmm1
  214360:	75 38                	jne    21439a <Benchmark_report+0x93a>
  214362:	7a 36                	jp     21439a <Benchmark_report+0x93a>
  214364:	41 c7 06 30 2e 30 30 	mov    DWORD PTR [r14],0x30302e30
  21436b:	41 c6 46 04 30       	mov    BYTE PTR [r14+0x4],0x30
    context.remaining = context.remaining[bytes.len..];
  214370:	49 83 c6 05          	add    r14,0x5
  214374:	48 83 c5 fb          	add    rbp,0xfffffffffffffffb
  214378:	e9 ab fe ff ff       	jmp    214228 <Benchmark_report+0x7c8>
                const min_exp_required = @intCast(usize, -float_decimal.exp);
  21437d:	4c 89 c0             	mov    rax,r8
  214380:	48 f7 d8             	neg    rax
                if (precision > min_exp_required) {
  214383:	83 f8 02             	cmp    eax,0x2
  214386:	77 73                	ja     2143fb <Benchmark_report+0x99b>
                    round_digit = precision - min_exp_required;
  214388:	ba 03 00 00 00       	mov    edx,0x3
  21438d:	48 29 c2             	sub    rdx,rax
    if (round_digit < float_decimal.digits.len and float_decimal.digits[round_digit] - '0' >= 5) {
  214390:	4c 39 ca             	cmp    rdx,r9
  214393:	72 71                	jb     214406 <Benchmark_report+0x9a6>
  214395:	e9 75 01 00 00       	jmp    21450f <Benchmark_report+0xaaf>
    var buffer: [32]u8 = undefined;
  21439a:	c5 fc 10 0d 5e be fe 	vmovups ymm1,YMMWORD PTR [rip+0xfffffffffffebe5e]        # 200200 <__unnamed_44>
  2143a1:	ff 
  2143a2:	c5 fc 11 4c 24 60    	vmovups YMMWORD PTR [rsp+0x60],ymm1
    var float_decimal = errol.errol3(x, buffer[0..]);
  2143a8:	4c 89 ac 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],r13
  2143af:	00 
  2143b0:	48 c7 84 24 b0 00 00 	mov    QWORD PTR [rsp+0xb0],0x20
  2143b7:	00 20 00 00 00 
  2143bc:	48 8d 7c 24 18       	lea    rdi,[rsp+0x18]
  2143c1:	48 8d b4 24 a8 00 00 	lea    rsi,[rsp+0xa8]
  2143c8:	00 
  2143c9:	c5 f8 77             	vzeroupper 
  2143cc:	e8 7f 80 01 00       	call   22c450 <errol3>
  2143d1:	4c 8b 6c 24 18       	mov    r13,QWORD PTR [rsp+0x18]
  2143d6:	4c 8b 44 24 20       	mov    r8,QWORD PTR [rsp+0x20]
  2143db:	4c 63 4c 24 28       	movsxd r9,DWORD PTR [rsp+0x28]
  2143e0:	4d 85 c9             	test   r9,r9
            if (float_decimal.exp >= 0) {
  2143e3:	0f 88 9a 02 00 00    	js     214683 <Benchmark_report+0xc23>
                round_digit = precision + @intCast(usize, float_decimal.exp);
  2143e9:	49 8d 51 03          	lea    rdx,[r9+0x3]
    if (round_digit < float_decimal.digits.len and float_decimal.digits[round_digit] - '0' >= 5) {
  2143ed:	4c 39 c2             	cmp    rdx,r8
  2143f0:	0f 82 e9 02 00 00    	jb     2146df <Benchmark_report+0xc7f>
  2143f6:	e9 98 08 00 00       	jmp    214c93 <Benchmark_report+0x1233>
  2143fb:	31 d2                	xor    edx,edx
  2143fd:	4c 39 ca             	cmp    rdx,r9
  214400:	0f 83 09 01 00 00    	jae    21450f <Benchmark_report+0xaaf>
  214406:	41 8a 44 15 00       	mov    al,BYTE PTR [r13+rdx*1+0x0]
  21440b:	04 d0                	add    al,0xd0
  21440d:	3c 05                	cmp    al,0x5
  21440f:	0f 82 fa 00 00 00    	jb     21450f <Benchmark_report+0xaaf>
        assert(round_digit >= 0);

        var i = round_digit;
        while (true) {
            if (i == 0) {
  214415:	48 85 d2             	test   rdx,rdx
  214418:	0f 84 e0 00 00 00    	je     2144fe <Benchmark_report+0xa9e>
                return;
            }

            i -= 1;

            const new_value = (float_decimal.digits[i] - '0' + 1) % 10;
  21441e:	41 8a 44 15 ff       	mov    al,BYTE PTR [r13+rdx*1-0x1]
  214423:	04 d1                	add    al,0xd1
  214425:	0f b6 f8             	movzx  edi,al
  214428:	69 c7 cd 00 00 00    	imul   eax,edi,0xcd
  21442e:	be 0b 05 00 00       	mov    esi,0x50b
  214433:	c4 e2 48 f7 c0       	bextr  eax,eax,esi
  214438:	b3 0a                	mov    bl,0xa
  21443a:	f6 e3                	mul    bl
  21443c:	40 28 c7             	sub    dil,al
            float_decimal.digits[i] = new_value + '0';
  21443f:	89 f8                	mov    eax,edi
  214441:	0c 30                	or     al,0x30
  214443:	41 88 44 15 ff       	mov    BYTE PTR [r13+rdx*1-0x1],al

            // must continue rounding until non-9
            if (new_value != 0) {
  214448:	40 84 ff             	test   dil,dil
  21444b:	0f 85 be 00 00 00    	jne    21450f <Benchmark_report+0xaaf>
            if (i == 0) {
  214451:	48 83 fa 01          	cmp    rdx,0x1
  214455:	0f 84 a3 00 00 00    	je     2144fe <Benchmark_report+0xa9e>
            const new_value = (float_decimal.digits[i] - '0' + 1) % 10;
  21445b:	41 0f b6 44 15 fe    	movzx  eax,BYTE PTR [r13+rdx*1-0x2]
  214461:	04 d1                	add    al,0xd1
  214463:	0f b6 f8             	movzx  edi,al
  214466:	69 c7 cd 00 00 00    	imul   eax,edi,0xcd
  21446c:	c4 e2 48 f7 c0       	bextr  eax,eax,esi
  214471:	f6 e3                	mul    bl
  214473:	40 28 c7             	sub    dil,al
            float_decimal.digits[i] = new_value + '0';
  214476:	89 f8                	mov    eax,edi
  214478:	0c 30                	or     al,0x30
  21447a:	41 88 44 15 fe       	mov    BYTE PTR [r13+rdx*1-0x2],al
            if (new_value != 0) {
  21447f:	48 83 c2 ff          	add    rdx,0xffffffffffffffff
  214483:	40 84 ff             	test   dil,dil
  214486:	74 c9                	je     214451 <Benchmark_report+0x9f1>
  214488:	e9 82 00 00 00       	jmp    21450f <Benchmark_report+0xaaf>
        stderr_file = try io.getStdErr();
  21448d:	48 8d 05 9c 6b 03 00 	lea    rax,[rip+0x36b9c]        # 24b030 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  214494:	48 89 05 9d 6b 03 00 	mov    QWORD PTR [rip+0x36b9d],rax        # 24b038 <stderr_file_out_stream>
  21449b:	48 8d 0d 3e b5 00 00 	lea    rcx,[rip+0xb53e]        # 21f9e0 <FileOutStream_writeFn>
  2144a2:	48 89 0d 97 6b 03 00 	mov    QWORD PTR [rip+0x36b97],rcx        # 24b040 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  2144a9:	c7 05 7d 6b 03 00 02 	mov    DWORD PTR [rip+0x36b7d],0x2        # 24b030 <stderr_file>
  2144b0:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  2144b3:	48 8d 3d 86 6b 03 00 	lea    rdi,[rip+0x36b86]        # 24b040 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  2144ba:	48 89 3d 47 bb 03 00 	mov    QWORD PTR [rip+0x3bb47],rdi        # 250008 <stderr_stream>
  2144c1:	48 8b 54 24 08       	mov    rdx,QWORD PTR [rsp+0x8]
  2144c6:	48 8d 44 24 30       	lea    rax,[rsp+0x30]
                const casted_value = ([]const u8)(value);
  2144cb:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  2144d0:	48 89 54 24 68       	mov    QWORD PTR [rsp+0x68],rdx
  2144d5:	48 8d 74 24 60       	lea    rsi,[rsp+0x60]
                return output(context, casted_value);
  2144da:	c5 f8 77             	vzeroupper 
  2144dd:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  2144df:	31 c9                	xor    ecx,ecx
  2144e1:	86 0d 29 bb 03 00    	xchg   BYTE PTR [rip+0x3bb29],cl        # 250010 <stderr_mutex>
  2144e7:	31 c0                	xor    eax,eax
  2144e9:	80 f9 01             	cmp    cl,0x1
    if (!ok) {
  2144ec:	0f 84 e0 f7 ff ff    	je     213cd2 <Benchmark_report+0x272>
            @panic("assertion failure");
  2144f2:	48 8d 3d 0f a8 03 00 	lea    rdi,[rip+0x3a80f]        # 24ed08 <__unnamed_2>
  2144f9:	e8 22 db ff ff       	call   212020 <panic>
                float_decimal.exp += 1;
  2144fe:	41 83 c0 01          	add    r8d,0x1
                float_decimal.digits = one_before[0 .. float_decimal.digits.len + 1];
  214502:	49 83 c1 01          	add    r9,0x1
                float_decimal.digits[0] = '1';
  214506:	41 c6 45 ff 31       	mov    BYTE PTR [r13-0x1],0x31
                const one_before = @intToPtr([*]u8, @ptrToInt(&float_decimal.digits[0]) - 1);
  21450b:	49 83 c5 ff          	add    r13,0xffffffffffffffff
        var num_digits_whole = if (float_decimal.exp > 0) @intCast(usize, float_decimal.exp) else 0;
  21450f:	45 31 db             	xor    r11d,r11d
  214512:	45 85 c0             	test   r8d,r8d
  214515:	44 89 c0             	mov    eax,r8d
  214518:	4c 0f 4f d8          	cmovg  r11,rax
    return if (x < y) x else y;
  21451c:	4d 39 cb             	cmp    r11,r9
  21451f:	4d 89 cc             	mov    r12,r9
  214522:	4d 0f 42 e3          	cmovb  r12,r11
  214526:	45 85 c0             	test   r8d,r8d
        if (num_digits_whole > 0) {
  214529:	0f 8e 15 01 00 00    	jle    214644 <Benchmark_report+0xbe4>
  21452f:	66 b8 05 00          	mov    ax,0x5
    if (context.remaining.len < bytes.len) return error.BufferTooSmall;
  214533:	4d 39 e6             	cmp    r14,r12
  214536:	0f 82 0c fa ff ff    	jb     213f48 <Benchmark_report+0x4e8>
    for (source) |s, i|
  21453c:	4d 85 e4             	test   r12,r12
  21453f:	0f 84 28 01 00 00    	je     21466d <Benchmark_report+0xc0d>
  214545:	49 81 fc 80 00 00 00 	cmp    r12,0x80
  21454c:	72 1a                	jb     214568 <Benchmark_report+0xb08>
  21454e:	4b 8d 14 2c          	lea    rdx,[r12+r13*1]
  214552:	48 39 d5             	cmp    rbp,rdx
  214555:	0f 83 45 01 00 00    	jae    2146a0 <Benchmark_report+0xc40>
  21455b:	49 8d 14 2c          	lea    rdx,[r12+rbp*1]
  21455f:	4c 39 ea             	cmp    rdx,r13
  214562:	0f 86 38 01 00 00    	jbe    2146a0 <Benchmark_report+0xc40>
  214568:	31 ff                	xor    edi,edi
  21456a:	4d 39 d9             	cmp    r9,r11
  21456d:	4c 89 ce             	mov    rsi,r9
  214570:	49 0f 47 f3          	cmova  rsi,r11
  214574:	48 89 f3             	mov    rbx,rsi
  214577:	48 f7 d3             	not    rbx
  21457a:	48 c7 c2 fe ff ff ff 	mov    rdx,0xfffffffffffffffe
  214581:	48 29 fa             	sub    rdx,rdi
  214584:	48 29 da             	sub    rdx,rbx
  214587:	48 83 e6 07          	and    rsi,0x7
  21458b:	74 17                	je     2145a4 <Benchmark_report+0xb44>
  21458d:	48 f7 de             	neg    rsi
  214590:	41 0f b6 5c 3d 00    	movzx  ebx,BYTE PTR [r13+rdi*1+0x0]
        dest[i] = s;
  214596:	88 5c 3d 00          	mov    BYTE PTR [rbp+rdi*1+0x0],bl
    for (source) |s, i|
  21459a:	48 83 c7 01          	add    rdi,0x1
  21459e:	48 83 c6 01          	add    rsi,0x1
  2145a2:	75 ec                	jne    214590 <Benchmark_report+0xb30>
    context.remaining = context.remaining[bytes.len..];
  2145a4:	4c 89 e6             	mov    rsi,r12
  2145a7:	48 83 fa 07          	cmp    rdx,0x7
  2145ab:	0f 82 3d 03 00 00    	jb     2148ee <Benchmark_report+0xe8e>
  2145b1:	48 89 fa             	mov    rdx,rdi
  2145b4:	48 f7 d2             	not    rdx
  2145b7:	4c 89 de             	mov    rsi,r11
  2145ba:	48 f7 d6             	not    rsi
  2145bd:	4c 89 cb             	mov    rbx,r9
  2145c0:	48 f7 d3             	not    rbx
  2145c3:	48 39 de             	cmp    rsi,rbx
  2145c6:	48 0f 47 de          	cmova  rbx,rsi
  2145ca:	48 29 da             	sub    rdx,rbx
  2145cd:	48 8d 34 2f          	lea    rsi,[rdi+rbp*1]
  2145d1:	48 83 c6 07          	add    rsi,0x7
  2145d5:	4c 01 ef             	add    rdi,r13
  2145d8:	48 83 c7 07          	add    rdi,0x7
  2145dc:	31 db                	xor    ebx,ebx
  2145de:	0f b6 4c 1f f9       	movzx  ecx,BYTE PTR [rdi+rbx*1-0x7]
        dest[i] = s;
  2145e3:	88 4c 1e f9          	mov    BYTE PTR [rsi+rbx*1-0x7],cl
    for (source) |s, i|
  2145e7:	0f b6 4c 1f fa       	movzx  ecx,BYTE PTR [rdi+rbx*1-0x6]
        dest[i] = s;
  2145ec:	88 4c 1e fa          	mov    BYTE PTR [rsi+rbx*1-0x6],cl
    for (source) |s, i|
  2145f0:	0f b6 4c 1f fb       	movzx  ecx,BYTE PTR [rdi+rbx*1-0x5]
        dest[i] = s;
  2145f5:	88 4c 1e fb          	mov    BYTE PTR [rsi+rbx*1-0x5],cl
    for (source) |s, i|
  2145f9:	0f b6 4c 1f fc       	movzx  ecx,BYTE PTR [rdi+rbx*1-0x4]
        dest[i] = s;
  2145fe:	88 4c 1e fc          	mov    BYTE PTR [rsi+rbx*1-0x4],cl
    for (source) |s, i|
  214602:	0f b6 4c 1f fd       	movzx  ecx,BYTE PTR [rdi+rbx*1-0x3]
        dest[i] = s;
  214607:	88 4c 1e fd          	mov    BYTE PTR [rsi+rbx*1-0x3],cl
    for (source) |s, i|
  21460b:	0f b6 4c 1f fe       	movzx  ecx,BYTE PTR [rdi+rbx*1-0x2]
        dest[i] = s;
  214610:	88 4c 1e fe          	mov    BYTE PTR [rsi+rbx*1-0x2],cl
    for (source) |s, i|
  214614:	0f b6 4c 1f ff       	movzx  ecx,BYTE PTR [rdi+rbx*1-0x1]
        dest[i] = s;
  214619:	88 4c 1e ff          	mov    BYTE PTR [rsi+rbx*1-0x1],cl
    for (source) |s, i|
  21461d:	0f b6 0c 1f          	movzx  ecx,BYTE PTR [rdi+rbx*1]
        dest[i] = s;
  214621:	88 0c 1e             	mov    BYTE PTR [rsi+rbx*1],cl
    for (source) |s, i|
  214624:	48 83 c3 08          	add    rbx,0x8
  214628:	48 39 da             	cmp    rdx,rbx
  21462b:	75 b1                	jne    2145de <Benchmark_report+0xb7e>
  21462d:	4c 89 e6             	mov    rsi,r12
  214630:	48 01 f5             	add    rbp,rsi
  214633:	49 29 f6             	sub    r14,rsi
            while (i < num_digits_whole) : (i += 1) {
  214636:	4d 39 cb             	cmp    r11,r9
  214639:	0f 86 dd 02 00 00    	jbe    21491c <Benchmark_report+0xebc>
  21463f:	e9 b5 02 00 00       	jmp    2148f9 <Benchmark_report+0xe99>
        dest[i] = s;
  214644:	c6 45 00 30          	mov    BYTE PTR [rbp+0x0],0x30
    context.remaining = context.remaining[bytes.len..];
  214648:	48 83 c5 01          	add    rbp,0x1
  21464c:	49 83 c6 ff          	add    r14,0xffffffffffffffff
  214650:	66 b8 05 00          	mov    ax,0x5
    if (context.remaining.len < bytes.len) return error.BufferTooSmall;
  214654:	4d 85 f6             	test   r14,r14
  214657:	0f 85 cc 02 00 00    	jne    214929 <Benchmark_report+0xec9>
  21465d:	31 ff                	xor    edi,edi
                    try formatType(args[next_arg], fmt[s..i], context, Errors, output);
  21465f:	66 85 c0             	test   ax,ax
  214662:	0f 85 6a f6 ff ff    	jne    213cd2 <Benchmark_report+0x272>
  214668:	e9 e7 f8 ff ff       	jmp    213f54 <Benchmark_report+0x4f4>
  21466d:	31 f6                	xor    esi,esi
    context.remaining = context.remaining[bytes.len..];
  21466f:	48 01 f5             	add    rbp,rsi
  214672:	49 29 f6             	sub    r14,rsi
            while (i < num_digits_whole) : (i += 1) {
  214675:	4d 39 cb             	cmp    r11,r9
  214678:	0f 87 7b 02 00 00    	ja     2148f9 <Benchmark_report+0xe99>
  21467e:	e9 99 02 00 00       	jmp    21491c <Benchmark_report+0xebc>
                const min_exp_required = @intCast(usize, -float_decimal.exp);
  214683:	4c 89 c8             	mov    rax,r9
  214686:	48 f7 d8             	neg    rax
                if (precision > min_exp_required) {
  214689:	83 f8 02             	cmp    eax,0x2
  21468c:	77 46                	ja     2146d4 <Benchmark_report+0xc74>
                    round_digit = precision - min_exp_required;
  21468e:	ba 03 00 00 00       	mov    edx,0x3
  214693:	48 29 c2             	sub    rdx,rax
    if (round_digit < float_decimal.digits.len and float_decimal.digits[round_digit] - '0' >= 5) {
  214696:	4c 39 c2             	cmp    rdx,r8
  214699:	72 44                	jb     2146df <Benchmark_report+0xc7f>
  21469b:	e9 f3 05 00 00       	jmp    214c93 <Benchmark_report+0x1233>
    for (source) |s, i|
  2146a0:	44 89 e7             	mov    edi,r12d
  2146a3:	83 e7 80             	and    edi,0xffffff80
  2146a6:	48 8d 5f 80          	lea    rbx,[rdi-0x80]
  2146aa:	48 89 da             	mov    rdx,rbx
  2146ad:	48 c1 ea 07          	shr    rdx,0x7
  2146b1:	8d 72 01             	lea    esi,[rdx+0x1]
  2146b4:	83 e6 03             	and    esi,0x3
  2146b7:	48 81 fb 80 01 00 00 	cmp    rbx,0x180
  2146be:	0f 83 a2 00 00 00    	jae    214766 <Benchmark_report+0xd06>
  2146c4:	31 d2                	xor    edx,edx
  2146c6:	48 85 f6             	test   rsi,rsi
  2146c9:	0f 85 ce 01 00 00    	jne    21489d <Benchmark_report+0xe3d>
  2146cf:	e9 0e 02 00 00       	jmp    2148e2 <Benchmark_report+0xe82>
  2146d4:	31 d2                	xor    edx,edx
  2146d6:	4c 39 c2             	cmp    rdx,r8
  2146d9:	0f 83 b4 05 00 00    	jae    214c93 <Benchmark_report+0x1233>
  2146df:	41 8a 44 15 00       	mov    al,BYTE PTR [r13+rdx*1+0x0]
  2146e4:	04 d0                	add    al,0xd0
  2146e6:	3c 05                	cmp    al,0x5
  2146e8:	0f 82 a5 05 00 00    	jb     214c93 <Benchmark_report+0x1233>
            if (i == 0) {
  2146ee:	48 85 d2             	test   rdx,rdx
  2146f1:	0f 84 8b 05 00 00    	je     214c82 <Benchmark_report+0x1222>
            const new_value = (float_decimal.digits[i] - '0' + 1) % 10;
  2146f7:	41 8a 44 15 ff       	mov    al,BYTE PTR [r13+rdx*1-0x1]
  2146fc:	04 d1                	add    al,0xd1
  2146fe:	0f b6 f8             	movzx  edi,al
  214701:	69 c7 cd 00 00 00    	imul   eax,edi,0xcd
  214707:	be 0b 05 00 00       	mov    esi,0x50b
  21470c:	c4 e2 48 f7 c0       	bextr  eax,eax,esi
  214711:	b1 0a                	mov    cl,0xa
  214713:	f6 e1                	mul    cl
  214715:	40 28 c7             	sub    dil,al
            float_decimal.digits[i] = new_value + '0';
  214718:	89 f8                	mov    eax,edi
  21471a:	0c 30                	or     al,0x30
  21471c:	41 88 44 15 ff       	mov    BYTE PTR [r13+rdx*1-0x1],al
            if (new_value != 0) {
  214721:	40 84 ff             	test   dil,dil
  214724:	0f 85 69 05 00 00    	jne    214c93 <Benchmark_report+0x1233>
            if (i == 0) {
  21472a:	48 83 fa 01          	cmp    rdx,0x1
  21472e:	0f 84 4e 05 00 00    	je     214c82 <Benchmark_report+0x1222>
            const new_value = (float_decimal.digits[i] - '0' + 1) % 10;
  214734:	41 0f b6 44 15 fe    	movzx  eax,BYTE PTR [r13+rdx*1-0x2]
  21473a:	04 d1                	add    al,0xd1
  21473c:	0f b6 f8             	movzx  edi,al
  21473f:	69 c7 cd 00 00 00    	imul   eax,edi,0xcd
  214745:	c4 e2 48 f7 c0       	bextr  eax,eax,esi
  21474a:	f6 e1                	mul    cl
  21474c:	40 28 c7             	sub    dil,al
            float_decimal.digits[i] = new_value + '0';
  21474f:	89 f8                	mov    eax,edi
  214751:	0c 30                	or     al,0x30
  214753:	41 88 44 15 fe       	mov    BYTE PTR [r13+rdx*1-0x2],al
            if (new_value != 0) {
  214758:	48 83 c2 ff          	add    rdx,0xffffffffffffffff
  21475c:	40 84 ff             	test   dil,dil
  21475f:	74 c9                	je     21472a <Benchmark_report+0xcca>
  214761:	e9 2d 05 00 00       	jmp    214c93 <Benchmark_report+0x1233>
  214766:	48 8d 5e ff          	lea    rbx,[rsi-0x1]
  21476a:	48 29 d3             	sub    rbx,rdx
  21476d:	31 d2                	xor    edx,edx
  21476f:	c4 c1 7c 10 44 15 00 	vmovups ymm0,YMMWORD PTR [r13+rdx*1+0x0]
  214776:	c4 c1 7c 10 4c 15 20 	vmovups ymm1,YMMWORD PTR [r13+rdx*1+0x20]
  21477d:	c4 c1 7c 10 54 15 40 	vmovups ymm2,YMMWORD PTR [r13+rdx*1+0x40]
  214784:	c4 c1 7c 10 5c 15 60 	vmovups ymm3,YMMWORD PTR [r13+rdx*1+0x60]
        dest[i] = s;
  21478b:	c5 fc 11 44 15 00    	vmovups YMMWORD PTR [rbp+rdx*1+0x0],ymm0
  214791:	c5 fc 11 4c 15 20    	vmovups YMMWORD PTR [rbp+rdx*1+0x20],ymm1
  214797:	c5 fc 11 54 15 40    	vmovups YMMWORD PTR [rbp+rdx*1+0x40],ymm2
  21479d:	c5 fc 11 5c 15 60    	vmovups YMMWORD PTR [rbp+rdx*1+0x60],ymm3
    for (source) |s, i|
  2147a3:	c4 c1 7c 10 84 15 80 	vmovups ymm0,YMMWORD PTR [r13+rdx*1+0x80]
  2147aa:	00 00 00 
  2147ad:	c4 c1 7c 10 8c 15 a0 	vmovups ymm1,YMMWORD PTR [r13+rdx*1+0xa0]
  2147b4:	00 00 00 
  2147b7:	c4 c1 7c 10 94 15 c0 	vmovups ymm2,YMMWORD PTR [r13+rdx*1+0xc0]
  2147be:	00 00 00 
  2147c1:	c4 c1 7c 10 9c 15 e0 	vmovups ymm3,YMMWORD PTR [r13+rdx*1+0xe0]
  2147c8:	00 00 00 
        dest[i] = s;
  2147cb:	c5 fc 11 84 15 80 00 	vmovups YMMWORD PTR [rbp+rdx*1+0x80],ymm0
  2147d2:	00 00 
  2147d4:	c5 fc 11 8c 15 a0 00 	vmovups YMMWORD PTR [rbp+rdx*1+0xa0],ymm1
  2147db:	00 00 
  2147dd:	c5 fc 11 94 15 c0 00 	vmovups YMMWORD PTR [rbp+rdx*1+0xc0],ymm2
  2147e4:	00 00 
  2147e6:	c5 fc 11 9c 15 e0 00 	vmovups YMMWORD PTR [rbp+rdx*1+0xe0],ymm3
  2147ed:	00 00 
    for (source) |s, i|
  2147ef:	c4 c1 7c 10 84 15 00 	vmovups ymm0,YMMWORD PTR [r13+rdx*1+0x100]
  2147f6:	01 00 00 
  2147f9:	c4 c1 7c 10 8c 15 20 	vmovups ymm1,YMMWORD PTR [r13+rdx*1+0x120]
  214800:	01 00 00 
  214803:	c4 c1 7c 10 94 15 40 	vmovups ymm2,YMMWORD PTR [r13+rdx*1+0x140]
  21480a:	01 00 00 
  21480d:	c4 c1 7c 10 9c 15 60 	vmovups ymm3,YMMWORD PTR [r13+rdx*1+0x160]
  214814:	01 00 00 
        dest[i] = s;
  214817:	c5 fc 11 84 15 00 01 	vmovups YMMWORD PTR [rbp+rdx*1+0x100],ymm0
  21481e:	00 00 
  214820:	c5 fc 11 8c 15 20 01 	vmovups YMMWORD PTR [rbp+rdx*1+0x120],ymm1
  214827:	00 00 
  214829:	c5 fc 11 94 15 40 01 	vmovups YMMWORD PTR [rbp+rdx*1+0x140],ymm2
  214830:	00 00 
  214832:	c5 fc 11 9c 15 60 01 	vmovups YMMWORD PTR [rbp+rdx*1+0x160],ymm3
  214839:	00 00 
    for (source) |s, i|
  21483b:	c4 c1 7d 10 84 15 80 	vmovupd ymm0,YMMWORD PTR [r13+rdx*1+0x180]
  214842:	01 00 00 
  214845:	c4 c1 7c 10 8c 15 a0 	vmovups ymm1,YMMWORD PTR [r13+rdx*1+0x1a0]
  21484c:	01 00 00 
  21484f:	c4 c1 7d 10 94 15 c0 	vmovupd ymm2,YMMWORD PTR [r13+rdx*1+0x1c0]
  214856:	01 00 00 
  214859:	c4 c1 7d 10 9c 15 e0 	vmovupd ymm3,YMMWORD PTR [r13+rdx*1+0x1e0]
  214860:	01 00 00 
        dest[i] = s;
  214863:	c5 fd 11 84 15 80 01 	vmovupd YMMWORD PTR [rbp+rdx*1+0x180],ymm0
  21486a:	00 00 
  21486c:	c5 fc 11 8c 15 a0 01 	vmovups YMMWORD PTR [rbp+rdx*1+0x1a0],ymm1
  214873:	00 00 
  214875:	c5 fd 11 94 15 c0 01 	vmovupd YMMWORD PTR [rbp+rdx*1+0x1c0],ymm2
  21487c:	00 00 
  21487e:	c5 fd 11 9c 15 e0 01 	vmovupd YMMWORD PTR [rbp+rdx*1+0x1e0],ymm3
  214885:	00 00 
    for (source) |s, i|
  214887:	48 81 c2 00 02 00 00 	add    rdx,0x200
  21488e:	48 83 c3 04          	add    rbx,0x4
  214892:	0f 85 d7 fe ff ff    	jne    21476f <Benchmark_report+0xd0f>
  214898:	48 85 f6             	test   rsi,rsi
  21489b:	74 45                	je     2148e2 <Benchmark_report+0xe82>
  21489d:	48 83 c2 60          	add    rdx,0x60
  2148a1:	48 f7 de             	neg    rsi
  2148a4:	c4 c1 7d 10 44 15 a0 	vmovupd ymm0,YMMWORD PTR [r13+rdx*1-0x60]
  2148ab:	c4 c1 7c 10 4c 15 c0 	vmovups ymm1,YMMWORD PTR [r13+rdx*1-0x40]
  2148b2:	c4 c1 7d 10 54 15 e0 	vmovupd ymm2,YMMWORD PTR [r13+rdx*1-0x20]
  2148b9:	c4 c1 7d 10 5c 15 00 	vmovupd ymm3,YMMWORD PTR [r13+rdx*1+0x0]
        dest[i] = s;
  2148c0:	c5 fd 11 44 15 a0    	vmovupd YMMWORD PTR [rbp+rdx*1-0x60],ymm0
  2148c6:	c5 fc 11 4c 15 c0    	vmovups YMMWORD PTR [rbp+rdx*1-0x40],ymm1
  2148cc:	c5 fd 11 54 15 e0    	vmovupd YMMWORD PTR [rbp+rdx*1-0x20],ymm2
  2148d2:	c5 fd 11 5c 15 00    	vmovupd YMMWORD PTR [rbp+rdx*1+0x0],ymm3
    for (source) |s, i|
  2148d8:	48 83 ea 80          	sub    rdx,0xffffffffffffff80
  2148dc:	48 83 c6 01          	add    rsi,0x1
  2148e0:	75 c2                	jne    2148a4 <Benchmark_report+0xe44>
    context.remaining = context.remaining[bytes.len..];
  2148e2:	4c 89 e6             	mov    rsi,r12
  2148e5:	49 39 fc             	cmp    r12,rdi
  2148e8:	0f 85 7c fc ff ff    	jne    21456a <Benchmark_report+0xb0a>
  2148ee:	48 01 f5             	add    rbp,rsi
  2148f1:	49 29 f6             	sub    r14,rsi
            while (i < num_digits_whole) : (i += 1) {
  2148f4:	4d 39 cb             	cmp    r11,r9
  2148f7:	76 23                	jbe    21491c <Benchmark_report+0xebc>
  2148f9:	31 ff                	xor    edi,edi
  2148fb:	4c 89 e2             	mov    rdx,r12
    if (context.remaining.len < bytes.len) return error.BufferTooSmall;
  2148fe:	4d 85 f6             	test   r14,r14
  214901:	0f 84 44 f6 ff ff    	je     213f4b <Benchmark_report+0x4eb>
        dest[i] = s;
  214907:	c6 45 00 30          	mov    BYTE PTR [rbp+0x0],0x30
    context.remaining = context.remaining[bytes.len..];
  21490b:	48 83 c5 01          	add    rbp,0x1
  21490f:	49 83 c6 ff          	add    r14,0xffffffffffffffff
            while (i < num_digits_whole) : (i += 1) {
  214913:	48 83 c2 01          	add    rdx,0x1
  214917:	4c 39 da             	cmp    rdx,r11
  21491a:	72 e2                	jb     2148fe <Benchmark_report+0xe9e>
  21491c:	66 b8 05 00          	mov    ax,0x5
    if (context.remaining.len < bytes.len) return error.BufferTooSmall;
  214920:	4d 85 f6             	test   r14,r14
  214923:	0f 84 34 fd ff ff    	je     21465d <Benchmark_report+0xbfd>
  214929:	c6 45 00 2e          	mov    BYTE PTR [rbp+0x0],0x2e
    context.remaining = context.remaining[bytes.len..];
  21492d:	4c 8d 55 01          	lea    r10,[rbp+0x1]
  214931:	49 8d 7e ff          	lea    rdi,[r14-0x1]
        if (float_decimal.exp <= 0) {
  214935:	45 85 c0             	test   r8d,r8d
  214938:	7e 69                	jle    2149a3 <Benchmark_report+0xf43>
  21493a:	45 31 c0             	xor    r8d,r8d
        if (num_digits_whole_no_pad + precision - printed < float_decimal.digits.len) {
  21493d:	4c 89 c1             	mov    rcx,r8
  214940:	48 f7 d9             	neg    rcx
  214943:	49 8d 14 0c          	lea    rdx,[r12+rcx*1]
  214947:	48 83 c2 03          	add    rdx,0x3
  21494b:	4f 8d 34 2c          	lea    r14,[r12+r13*1]
  21494f:	4c 39 ca             	cmp    rdx,r9
  214952:	73 2f                	jae    214983 <Benchmark_report+0xf23>
            try output(context, float_decimal.digits[num_digits_whole_no_pad .. num_digits_whole_no_pad + precision - printed]);
  214954:	49 89 d7             	mov    r15,rdx
  214957:	4d 29 e7             	sub    r15,r12
    if (context.remaining.len < bytes.len) return error.BufferTooSmall;
  21495a:	4c 39 ff             	cmp    rdi,r15
  21495d:	72 33                	jb     214992 <Benchmark_report+0xf32>
    for (source) |s, i|
  21495f:	4d 85 ff             	test   r15,r15
  214962:	0f 84 e0 00 00 00    	je     214a48 <Benchmark_report+0xfe8>
  214968:	41 8a 06             	mov    al,BYTE PTR [r14]
        dest[i] = s;
  21496b:	41 88 02             	mov    BYTE PTR [r10],al
    for (source) |s, i|
  21496e:	49 83 ff 01          	cmp    r15,0x1
  214972:	0f 85 f4 00 00 00    	jne    214a6c <Benchmark_report+0x100c>
  214978:	41 bf 01 00 00 00    	mov    r15d,0x1
  21497e:	e9 3a 0c 00 00       	jmp    2155bd <Benchmark_report+0x1b5d>
            try output(context, float_decimal.digits[num_digits_whole_no_pad..]);
  214983:	4d 89 cf             	mov    r15,r9
  214986:	4d 29 e7             	sub    r15,r12
    if (context.remaining.len < bytes.len) return error.BufferTooSmall;
  214989:	4c 39 ff             	cmp    rdi,r15
  21498c:	0f 83 97 00 00 00    	jae    214a29 <Benchmark_report+0xfc9>
  214992:	4c 89 d5             	mov    rbp,r10
                    try formatType(args[next_arg], fmt[s..i], context, Errors, output);
  214995:	66 85 c0             	test   ax,ax
  214998:	0f 85 34 f3 ff ff    	jne    213cd2 <Benchmark_report+0x272>
  21499e:	e9 b1 f5 ff ff       	jmp    213f54 <Benchmark_report+0x4f4>
            const zero_digit_count = @intCast(usize, -float_decimal.exp);
  2149a3:	41 f7 d8             	neg    r8d
  2149a6:	49 63 c8             	movsxd rcx,r8d
  2149a9:	48 83 f9 03          	cmp    rcx,0x3
  2149ad:	ba 03 00 00 00       	mov    edx,0x3
  2149b2:	48 0f 42 d1          	cmovb  rdx,rcx
            while (i < zeros_to_print) : (i += 1) {
  2149b6:	48 85 d2             	test   rdx,rdx
  2149b9:	0f 84 7b ff ff ff    	je     21493a <Benchmark_report+0xeda>
    if (context.remaining.len < bytes.len) return error.BufferTooSmall;
  2149bf:	48 85 ff             	test   rdi,rdi
  2149c2:	0f 84 a7 02 00 00    	je     214c6f <Benchmark_report+0x120f>
        dest[i] = s;
  2149c8:	c6 45 01 30          	mov    BYTE PTR [rbp+0x1],0x30
    context.remaining = context.remaining[bytes.len..];
  2149cc:	4c 8d 55 02          	lea    r10,[rbp+0x2]
  2149d0:	49 8d 7e fe          	lea    rdi,[r14-0x2]
            while (i < zeros_to_print) : (i += 1) {
  2149d4:	48 83 fa 01          	cmp    rdx,0x1
  2149d8:	76 7d                	jbe    214a57 <Benchmark_report+0xff7>
    if (context.remaining.len < bytes.len) return error.BufferTooSmall;
  2149da:	48 85 ff             	test   rdi,rdi
  2149dd:	0f 84 8c 02 00 00    	je     214c6f <Benchmark_report+0x120f>
  2149e3:	c6 45 02 30          	mov    BYTE PTR [rbp+0x2],0x30
    context.remaining = context.remaining[bytes.len..];
  2149e7:	4c 8d 55 03          	lea    r10,[rbp+0x3]
  2149eb:	49 8d 7e fd          	lea    rdi,[r14-0x3]
            while (i < zeros_to_print) : (i += 1) {
  2149ef:	48 83 fa 03          	cmp    rdx,0x3
  2149f3:	0f 82 59 04 00 00    	jb     214e52 <Benchmark_report+0x13f2>
    if (context.remaining.len < bytes.len) return error.BufferTooSmall;
  2149f9:	48 85 ff             	test   rdi,rdi
  2149fc:	0f 84 6d 02 00 00    	je     214c6f <Benchmark_report+0x120f>
  214a02:	c6 45 03 30          	mov    BYTE PTR [rbp+0x3],0x30
    context.remaining = context.remaining[bytes.len..];
  214a06:	48 83 c5 04          	add    rbp,0x4
  214a0a:	49 83 c6 fc          	add    r14,0xfffffffffffffffc
  214a0e:	b2 01                	mov    dl,0x1
  214a10:	41 b8 03 00 00 00    	mov    r8d,0x3
  214a16:	49 89 ea             	mov    r10,rbp
  214a19:	4c 89 f7             	mov    rdi,r14
            if (printed >= precision) {
  214a1c:	84 d2                	test   dl,dl
  214a1e:	0f 84 19 ff ff ff    	je     21493d <Benchmark_report+0xedd>
  214a24:	e9 39 04 00 00       	jmp    214e62 <Benchmark_report+0x1402>
    for (source) |s, i|
  214a29:	4d 85 ff             	test   r15,r15
  214a2c:	74 22                	je     214a50 <Benchmark_report+0xff0>
  214a2e:	41 8a 0e             	mov    cl,BYTE PTR [r14]
        dest[i] = s;
  214a31:	41 88 0a             	mov    BYTE PTR [r10],cl
    for (source) |s, i|
  214a34:	49 83 ff 01          	cmp    r15,0x1
  214a38:	0f 85 29 01 00 00    	jne    214b67 <Benchmark_report+0x1107>
  214a3e:	ba 01 00 00 00       	mov    edx,0x1
  214a43:	e9 a5 01 00 00       	jmp    214bed <Benchmark_report+0x118d>
  214a48:	45 31 ff             	xor    r15d,r15d
  214a4b:	e9 6d 0b 00 00       	jmp    2155bd <Benchmark_report+0x1b5d>
  214a50:	31 d2                	xor    edx,edx
  214a52:	e9 96 01 00 00       	jmp    214bed <Benchmark_report+0x118d>
  214a57:	31 d2                	xor    edx,edx
  214a59:	41 b8 01 00 00 00    	mov    r8d,0x1
  214a5f:	84 d2                	test   dl,dl
  214a61:	0f 84 d6 fe ff ff    	je     21493d <Benchmark_report+0xedd>
  214a67:	e9 f6 03 00 00       	jmp    214e62 <Benchmark_report+0x1402>
  214a6c:	b9 02 00 00 00       	mov    ecx,0x2
  214a71:	4c 29 c1             	sub    rcx,r8
  214a74:	48 81 f9 80 00 00 00 	cmp    rcx,0x80
  214a7b:	72 25                	jb     214aa2 <Benchmark_report+0x1042>
  214a7d:	49 8d 42 01          	lea    rax,[r10+0x1]
  214a81:	4c 01 ea             	add    rdx,r13
  214a84:	48 39 d0             	cmp    rax,rdx
  214a87:	0f 83 e8 03 00 00    	jae    214e75 <Benchmark_report+0x1415>
  214a8d:	4b 8d 04 3a          	lea    rax,[r10+r15*1]
  214a91:	4b 8d 14 2c          	lea    rdx,[r12+r13*1]
  214a95:	48 83 c2 01          	add    rdx,0x1
  214a99:	48 39 c2             	cmp    rdx,rax
  214a9c:	0f 83 d3 03 00 00    	jae    214e75 <Benchmark_report+0x1415>
  214aa2:	b8 01 00 00 00       	mov    eax,0x1
  214aa7:	ba 03 00 00 00       	mov    edx,0x3
  214aac:	44 29 c2             	sub    edx,r8d
  214aaf:	29 c2                	sub    edx,eax
  214ab1:	be 02 00 00 00       	mov    esi,0x2
  214ab6:	4c 29 c6             	sub    rsi,r8
  214ab9:	48 29 c6             	sub    rsi,rax
  214abc:	48 83 e2 07          	and    rdx,0x7
  214ac0:	74 16                	je     214ad8 <Benchmark_report+0x1078>
  214ac2:	48 f7 da             	neg    rdx
  214ac5:	41 0f b6 0c 06       	movzx  ecx,BYTE PTR [r14+rax*1]
        dest[i] = s;
  214aca:	41 88 0c 02          	mov    BYTE PTR [r10+rax*1],cl
    for (source) |s, i|
  214ace:	48 83 c0 01          	add    rax,0x1
  214ad2:	48 83 c2 01          	add    rdx,0x1
  214ad6:	75 ed                	jne    214ac5 <Benchmark_report+0x1065>
  214ad8:	48 83 fe 07          	cmp    rsi,0x7
  214adc:	0f 82 db 0a 00 00    	jb     2155bd <Benchmark_report+0x1b5d>
  214ae2:	ba 03 00 00 00       	mov    edx,0x3
  214ae7:	4c 29 c2             	sub    rdx,r8
  214aea:	48 29 c2             	sub    rdx,rax
  214aed:	49 f7 d3             	not    r11
  214af0:	49 f7 d1             	not    r9
  214af3:	4d 39 cb             	cmp    r11,r9
  214af6:	4d 0f 47 cb          	cmova  r9,r11
  214afa:	49 8d 34 02          	lea    rsi,[r10+rax*1]
  214afe:	48 83 c6 07          	add    rsi,0x7
  214b02:	4c 29 c8             	sub    rax,r9
  214b05:	49 01 c5             	add    r13,rax
  214b08:	31 c0                	xor    eax,eax
  214b0a:	41 0f b6 4c 05 ff    	movzx  ecx,BYTE PTR [r13+rax*1-0x1]
        dest[i] = s;
  214b10:	88 4c 06 f9          	mov    BYTE PTR [rsi+rax*1-0x7],cl
    for (source) |s, i|
  214b14:	41 0f b6 4c 05 00    	movzx  ecx,BYTE PTR [r13+rax*1+0x0]
        dest[i] = s;
  214b1a:	88 4c 06 fa          	mov    BYTE PTR [rsi+rax*1-0x6],cl
    for (source) |s, i|
  214b1e:	41 0f b6 4c 05 01    	movzx  ecx,BYTE PTR [r13+rax*1+0x1]
        dest[i] = s;
  214b24:	88 4c 06 fb          	mov    BYTE PTR [rsi+rax*1-0x5],cl
    for (source) |s, i|
  214b28:	41 0f b6 4c 05 02    	movzx  ecx,BYTE PTR [r13+rax*1+0x2]
        dest[i] = s;
  214b2e:	88 4c 06 fc          	mov    BYTE PTR [rsi+rax*1-0x4],cl
    for (source) |s, i|
  214b32:	41 0f b6 4c 05 03    	movzx  ecx,BYTE PTR [r13+rax*1+0x3]
        dest[i] = s;
  214b38:	88 4c 06 fd          	mov    BYTE PTR [rsi+rax*1-0x3],cl
    for (source) |s, i|
  214b3c:	41 0f b6 4c 05 04    	movzx  ecx,BYTE PTR [r13+rax*1+0x4]
        dest[i] = s;
  214b42:	88 4c 06 fe          	mov    BYTE PTR [rsi+rax*1-0x2],cl
    for (source) |s, i|
  214b46:	41 0f b6 4c 05 05    	movzx  ecx,BYTE PTR [r13+rax*1+0x5]
        dest[i] = s;
  214b4c:	88 4c 06 ff          	mov    BYTE PTR [rsi+rax*1-0x1],cl
    for (source) |s, i|
  214b50:	41 0f b6 4c 05 06    	movzx  ecx,BYTE PTR [r13+rax*1+0x6]
        dest[i] = s;
  214b56:	88 0c 06             	mov    BYTE PTR [rsi+rax*1],cl
    for (source) |s, i|
  214b59:	48 83 c0 08          	add    rax,0x8
  214b5d:	48 39 c2             	cmp    rdx,rax
  214b60:	75 a8                	jne    214b0a <Benchmark_report+0x10aa>
  214b62:	e9 56 0a 00 00       	jmp    2155bd <Benchmark_report+0x1b5d>
  214b67:	4d 39 d9             	cmp    r9,r11
  214b6a:	4c 89 ce             	mov    rsi,r9
  214b6d:	49 0f 47 f3          	cmova  rsi,r11
  214b71:	48 f7 d6             	not    rsi
  214b74:	49 8d 1c 31          	lea    rbx,[r9+rsi*1]
  214b78:	48 81 fb 80 00 00 00 	cmp    rbx,0x80
  214b7f:	72 26                	jb     214ba7 <Benchmark_report+0x1147>
  214b81:	49 8d 4a 01          	lea    rcx,[r10+0x1]
  214b85:	4b 8d 14 29          	lea    rdx,[r9+r13*1]
  214b89:	48 39 d1             	cmp    rcx,rdx
  214b8c:	0f 83 18 03 00 00    	jae    214eaa <Benchmark_report+0x144a>
  214b92:	4b 8d 0c 3a          	lea    rcx,[r10+r15*1]
  214b96:	4b 8d 14 2c          	lea    rdx,[r12+r13*1]
  214b9a:	48 83 c2 01          	add    rdx,0x1
  214b9e:	48 39 ca             	cmp    rdx,rcx
  214ba1:	0f 83 03 03 00 00    	jae    214eaa <Benchmark_report+0x144a>
  214ba7:	41 bc 01 00 00 00    	mov    r12d,0x1
  214bad:	49 f7 d3             	not    r11
  214bb0:	4c 89 c9             	mov    rcx,r9
  214bb3:	48 f7 d1             	not    rcx
  214bb6:	49 39 cb             	cmp    r11,rcx
  214bb9:	49 0f 47 cb          	cmova  rcx,r11
  214bbd:	49 8d 14 09          	lea    rdx,[r9+rcx*1]
  214bc1:	48 83 c2 01          	add    rdx,0x1
  214bc5:	4c 29 e2             	sub    rdx,r12
  214bc8:	4b 8d 34 22          	lea    rsi,[r10+r12*1]
  214bcc:	49 83 c4 ff          	add    r12,0xffffffffffffffff
  214bd0:	49 29 cc             	sub    r12,rcx
  214bd3:	4d 01 e5             	add    r13,r12
  214bd6:	31 ed                	xor    ebp,ebp
  214bd8:	41 0f b6 4c 2d 00    	movzx  ecx,BYTE PTR [r13+rbp*1+0x0]
        dest[i] = s;
  214bde:	88 0c 2e             	mov    BYTE PTR [rsi+rbp*1],cl
    for (source) |s, i|
  214be1:	48 83 c5 01          	add    rbp,0x1
  214be5:	48 39 ea             	cmp    rdx,rbp
  214be8:	75 ee                	jne    214bd8 <Benchmark_report+0x1178>
    context.remaining = context.remaining[bytes.len..];
  214bea:	4c 89 fa             	mov    rdx,r15
  214bed:	49 01 d2             	add    r10,rdx
  214bf0:	48 29 d7             	sub    rdi,rdx
            printed += float_decimal.digits.len - num_digits_whole_no_pad;
  214bf3:	4d 01 f8             	add    r8,r15
            while (printed < precision) : (printed += 1) {
  214bf6:	49 83 f8 02          	cmp    r8,0x2
  214bfa:	0f 87 62 02 00 00    	ja     214e62 <Benchmark_report+0x1402>
    if (context.remaining.len < bytes.len) return error.BufferTooSmall;
  214c00:	48 85 ff             	test   rdi,rdi
  214c03:	74 6a                	je     214c6f <Benchmark_report+0x120f>
        dest[i] = s;
  214c05:	41 c6 02 30          	mov    BYTE PTR [r10],0x30
    context.remaining = context.remaining[bytes.len..];
  214c09:	49 83 c2 01          	add    r10,0x1
  214c0d:	48 8d 4f ff          	lea    rcx,[rdi-0x1]
            while (printed < precision) : (printed += 1) {
  214c11:	49 8d 50 01          	lea    rdx,[r8+0x1]
  214c15:	48 83 fa 03          	cmp    rdx,0x3
  214c19:	0f 83 e9 01 00 00    	jae    214e08 <Benchmark_report+0x13a8>
    if (context.remaining.len < bytes.len) return error.BufferTooSmall;
  214c1f:	48 85 c9             	test   rcx,rcx
  214c22:	74 4b                	je     214c6f <Benchmark_report+0x120f>
  214c24:	41 c6 02 30          	mov    BYTE PTR [r10],0x30
    context.remaining = context.remaining[bytes.len..];
  214c28:	49 83 c2 01          	add    r10,0x1
  214c2c:	48 8d 4f fe          	lea    rcx,[rdi-0x2]
            while (printed < precision) : (printed += 1) {
  214c30:	49 8d 50 02          	lea    rdx,[r8+0x2]
  214c34:	48 83 fa 02          	cmp    rdx,0x2
  214c38:	0f 87 ca 01 00 00    	ja     214e08 <Benchmark_report+0x13a8>
    if (context.remaining.len < bytes.len) return error.BufferTooSmall;
  214c3e:	48 85 c9             	test   rcx,rcx
  214c41:	74 2c                	je     214c6f <Benchmark_report+0x120f>
  214c43:	41 c6 02 30          	mov    BYTE PTR [r10],0x30
    context.remaining = context.remaining[bytes.len..];
  214c47:	49 83 c2 01          	add    r10,0x1
  214c4b:	48 8d 4f fd          	lea    rcx,[rdi-0x3]
            while (printed < precision) : (printed += 1) {
  214c4f:	49 83 f8 fd          	cmp    r8,0xfffffffffffffffd
  214c53:	0f 82 af 01 00 00    	jb     214e08 <Benchmark_report+0x13a8>
    if (context.remaining.len < bytes.len) return error.BufferTooSmall;
  214c59:	48 85 c9             	test   rcx,rcx
  214c5c:	74 11                	je     214c6f <Benchmark_report+0x120f>
  214c5e:	41 c6 02 30          	mov    BYTE PTR [r10],0x30
    context.remaining = context.remaining[bytes.len..];
  214c62:	49 83 c2 01          	add    r10,0x1
  214c66:	48 83 c7 fc          	add    rdi,0xfffffffffffffffc
  214c6a:	e9 f3 01 00 00       	jmp    214e62 <Benchmark_report+0x1402>
  214c6f:	31 ff                	xor    edi,edi
  214c71:	4c 89 d5             	mov    rbp,r10
                    try formatType(args[next_arg], fmt[s..i], context, Errors, output);
  214c74:	66 85 c0             	test   ax,ax
  214c77:	0f 85 55 f0 ff ff    	jne    213cd2 <Benchmark_report+0x272>
  214c7d:	e9 d2 f2 ff ff       	jmp    213f54 <Benchmark_report+0x4f4>
                float_decimal.exp += 1;
  214c82:	41 83 c1 01          	add    r9d,0x1
                float_decimal.digits = one_before[0 .. float_decimal.digits.len + 1];
  214c86:	49 83 c0 01          	add    r8,0x1
                float_decimal.digits[0] = '1';
  214c8a:	41 c6 45 ff 31       	mov    BYTE PTR [r13-0x1],0x31
                const one_before = @intToPtr([*]u8, @ptrToInt(&float_decimal.digits[0]) - 1);
  214c8f:	49 83 c5 ff          	add    r13,0xffffffffffffffff
        var num_digits_whole = if (float_decimal.exp > 0) @intCast(usize, float_decimal.exp) else 0;
  214c93:	45 31 db             	xor    r11d,r11d
  214c96:	45 85 c9             	test   r9d,r9d
  214c99:	44 89 c8             	mov    eax,r9d
  214c9c:	4c 0f 4f d8          	cmovg  r11,rax
  214ca0:	4d 39 c3             	cmp    r11,r8
  214ca3:	4d 89 c7             	mov    r15,r8
  214ca6:	4d 0f 42 fb          	cmovb  r15,r11
  214caa:	45 85 c9             	test   r9d,r9d
        if (num_digits_whole > 0) {
  214cad:	0f 8e 16 01 00 00    	jle    214dc9 <Benchmark_report+0x1369>
  214cb3:	66 b8 05 00          	mov    ax,0x5
    if (context.remaining.len < bytes.len) return error.BufferTooSmall;
  214cb7:	4c 39 fd             	cmp    rbp,r15
  214cba:	0f 82 6a f5 ff ff    	jb     21422a <Benchmark_report+0x7ca>
    for (source) |s, i|
  214cc0:	4d 85 ff             	test   r15,r15
  214cc3:	0f 84 29 01 00 00    	je     214df2 <Benchmark_report+0x1392>
  214cc9:	49 81 ff 80 00 00 00 	cmp    r15,0x80
  214cd0:	72 1a                	jb     214cec <Benchmark_report+0x128c>
  214cd2:	4b 8d 0c 2f          	lea    rcx,[r15+r13*1]
  214cd6:	49 39 ce             	cmp    r14,rcx
  214cd9:	0f 83 3f 01 00 00    	jae    214e1e <Benchmark_report+0x13be>
  214cdf:	4b 8d 0c 3e          	lea    rcx,[r14+r15*1]
  214ce3:	4c 39 e9             	cmp    rcx,r13
  214ce6:	0f 86 32 01 00 00    	jbe    214e1e <Benchmark_report+0x13be>
  214cec:	31 ff                	xor    edi,edi
  214cee:	4d 39 d8             	cmp    r8,r11
  214cf1:	4c 89 c2             	mov    rdx,r8
  214cf4:	49 0f 47 d3          	cmova  rdx,r11
  214cf8:	48 89 d6             	mov    rsi,rdx
  214cfb:	48 f7 d6             	not    rsi
  214cfe:	49 c7 c2 fe ff ff ff 	mov    r10,0xfffffffffffffffe
  214d05:	49 29 fa             	sub    r10,rdi
  214d08:	49 29 f2             	sub    r10,rsi
  214d0b:	48 83 e2 07          	and    rdx,0x7
  214d0f:	74 17                	je     214d28 <Benchmark_report+0x12c8>
  214d11:	48 f7 da             	neg    rdx
  214d14:	41 0f b6 4c 3d 00    	movzx  ecx,BYTE PTR [r13+rdi*1+0x0]
        dest[i] = s;
  214d1a:	41 88 0c 3e          	mov    BYTE PTR [r14+rdi*1],cl
    for (source) |s, i|
  214d1e:	48 83 c7 01          	add    rdi,0x1
  214d22:	48 83 c2 01          	add    rdx,0x1
  214d26:	75 ec                	jne    214d14 <Benchmark_report+0x12b4>
    context.remaining = context.remaining[bytes.len..];
  214d28:	4c 89 fa             	mov    rdx,r15
  214d2b:	49 83 fa 07          	cmp    r10,0x7
  214d2f:	0f 82 4a 03 00 00    	jb     21507f <Benchmark_report+0x161f>
  214d35:	49 89 fa             	mov    r10,rdi
  214d38:	49 f7 d2             	not    r10
  214d3b:	4c 89 da             	mov    rdx,r11
  214d3e:	48 f7 d2             	not    rdx
  214d41:	4c 89 c6             	mov    rsi,r8
  214d44:	48 f7 d6             	not    rsi
  214d47:	48 39 f2             	cmp    rdx,rsi
  214d4a:	48 0f 47 f2          	cmova  rsi,rdx
  214d4e:	49 29 f2             	sub    r10,rsi
  214d51:	49 8d 14 3e          	lea    rdx,[r14+rdi*1]
  214d55:	48 83 c2 07          	add    rdx,0x7
  214d59:	4a 8d 34 2f          	lea    rsi,[rdi+r13*1]
  214d5d:	48 83 c6 07          	add    rsi,0x7
  214d61:	31 ff                	xor    edi,edi
  214d63:	0f b6 4c 3e f9       	movzx  ecx,BYTE PTR [rsi+rdi*1-0x7]
        dest[i] = s;
  214d68:	88 4c 3a f9          	mov    BYTE PTR [rdx+rdi*1-0x7],cl
    for (source) |s, i|
  214d6c:	0f b6 4c 3e fa       	movzx  ecx,BYTE PTR [rsi+rdi*1-0x6]
        dest[i] = s;
  214d71:	88 4c 3a fa          	mov    BYTE PTR [rdx+rdi*1-0x6],cl
    for (source) |s, i|
  214d75:	0f b6 4c 3e fb       	movzx  ecx,BYTE PTR [rsi+rdi*1-0x5]
        dest[i] = s;
  214d7a:	88 4c 3a fb          	mov    BYTE PTR [rdx+rdi*1-0x5],cl
    for (source) |s, i|
  214d7e:	0f b6 4c 3e fc       	movzx  ecx,BYTE PTR [rsi+rdi*1-0x4]
        dest[i] = s;
  214d83:	88 4c 3a fc          	mov    BYTE PTR [rdx+rdi*1-0x4],cl
    for (source) |s, i|
  214d87:	0f b6 4c 3e fd       	movzx  ecx,BYTE PTR [rsi+rdi*1-0x3]
        dest[i] = s;
  214d8c:	88 4c 3a fd          	mov    BYTE PTR [rdx+rdi*1-0x3],cl
    for (source) |s, i|
  214d90:	0f b6 4c 3e fe       	movzx  ecx,BYTE PTR [rsi+rdi*1-0x2]
        dest[i] = s;
  214d95:	88 4c 3a fe          	mov    BYTE PTR [rdx+rdi*1-0x2],cl
    for (source) |s, i|
  214d99:	0f b6 4c 3e ff       	movzx  ecx,BYTE PTR [rsi+rdi*1-0x1]
        dest[i] = s;
  214d9e:	88 4c 3a ff          	mov    BYTE PTR [rdx+rdi*1-0x1],cl
    for (source) |s, i|
  214da2:	0f b6 0c 3e          	movzx  ecx,BYTE PTR [rsi+rdi*1]
        dest[i] = s;
  214da6:	88 0c 3a             	mov    BYTE PTR [rdx+rdi*1],cl
    for (source) |s, i|
  214da9:	48 83 c7 08          	add    rdi,0x8
  214dad:	49 39 fa             	cmp    r10,rdi
  214db0:	75 b1                	jne    214d63 <Benchmark_report+0x1303>
  214db2:	4c 89 fa             	mov    rdx,r15
  214db5:	49 01 d6             	add    r14,rdx
  214db8:	48 29 d5             	sub    rbp,rdx
            while (i < num_digits_whole) : (i += 1) {
  214dbb:	4d 39 c3             	cmp    r11,r8
  214dbe:	0f 86 e9 02 00 00    	jbe    2150ad <Benchmark_report+0x164d>
  214dc4:	e9 c1 02 00 00       	jmp    21508a <Benchmark_report+0x162a>
        dest[i] = s;
  214dc9:	41 c6 06 30          	mov    BYTE PTR [r14],0x30
    context.remaining = context.remaining[bytes.len..];
  214dcd:	49 83 c6 01          	add    r14,0x1
  214dd1:	48 83 c5 ff          	add    rbp,0xffffffffffffffff
  214dd5:	66 b8 05 00          	mov    ax,0x5
    if (context.remaining.len < bytes.len) return error.BufferTooSmall;
  214dd9:	48 85 ed             	test   rbp,rbp
  214ddc:	0f 85 d8 02 00 00    	jne    2150ba <Benchmark_report+0x165a>
  214de2:	31 ff                	xor    edi,edi
                    try formatType(args[next_arg], fmt[s..i], context, Errors, output);
  214de4:	66 85 c0             	test   ax,ax
  214de7:	0f 85 e5 ee ff ff    	jne    213cd2 <Benchmark_report+0x272>
  214ded:	e9 44 f4 ff ff       	jmp    214236 <Benchmark_report+0x7d6>
  214df2:	31 d2                	xor    edx,edx
    context.remaining = context.remaining[bytes.len..];
  214df4:	49 01 d6             	add    r14,rdx
  214df7:	48 29 d5             	sub    rbp,rdx
            while (i < num_digits_whole) : (i += 1) {
  214dfa:	4d 39 c3             	cmp    r11,r8
  214dfd:	0f 87 87 02 00 00    	ja     21508a <Benchmark_report+0x162a>
  214e03:	e9 a5 02 00 00       	jmp    2150ad <Benchmark_report+0x164d>
  214e08:	31 c0                	xor    eax,eax
  214e0a:	48 89 cf             	mov    rdi,rcx
  214e0d:	4c 89 d5             	mov    rbp,r10
                    try formatType(args[next_arg], fmt[s..i], context, Errors, output);
  214e10:	66 85 c0             	test   ax,ax
  214e13:	0f 85 b9 ee ff ff    	jne    213cd2 <Benchmark_report+0x272>
  214e19:	e9 36 f1 ff ff       	jmp    213f54 <Benchmark_report+0x4f4>
    for (source) |s, i|
  214e1e:	44 89 ff             	mov    edi,r15d
  214e21:	83 e7 80             	and    edi,0xffffff80
  214e24:	48 8d 4f 80          	lea    rcx,[rdi-0x80]
  214e28:	48 89 ce             	mov    rsi,rcx
  214e2b:	48 c1 ee 07          	shr    rsi,0x7
  214e2f:	8d 56 01             	lea    edx,[rsi+0x1]
  214e32:	83 e2 03             	and    edx,0x3
  214e35:	48 81 f9 80 01 00 00 	cmp    rcx,0x180
  214e3c:	0f 83 a3 00 00 00    	jae    214ee5 <Benchmark_report+0x1485>
  214e42:	31 f6                	xor    esi,esi
  214e44:	48 85 d2             	test   rdx,rdx
  214e47:	0f 85 de 01 00 00    	jne    21502b <Benchmark_report+0x15cb>
  214e4d:	e9 21 02 00 00       	jmp    215073 <Benchmark_report+0x1613>
  214e52:	31 d2                	xor    edx,edx
  214e54:	41 b8 02 00 00 00    	mov    r8d,0x2
            if (printed >= precision) {
  214e5a:	84 d2                	test   dl,dl
  214e5c:	0f 84 db fa ff ff    	je     21493d <Benchmark_report+0xedd>
  214e62:	31 c0                	xor    eax,eax
  214e64:	4c 89 d5             	mov    rbp,r10
                    try formatType(args[next_arg], fmt[s..i], context, Errors, output);
  214e67:	66 85 c0             	test   ax,ax
  214e6a:	0f 85 62 ee ff ff    	jne    213cd2 <Benchmark_report+0x272>
  214e70:	e9 df f0 ff ff       	jmp    213f54 <Benchmark_report+0x4f4>
  214e75:	48 89 c8             	mov    rax,rcx
  214e78:	48 83 e0 80          	and    rax,0xffffffffffffff80
  214e7c:	48 8d 58 80          	lea    rbx,[rax-0x80]
  214e80:	48 89 de             	mov    rsi,rbx
  214e83:	48 c1 ee 07          	shr    rsi,0x7
  214e87:	8d 56 01             	lea    edx,[rsi+0x1]
  214e8a:	83 e2 03             	and    edx,0x3
  214e8d:	48 81 fb 80 01 00 00 	cmp    rbx,0x180
  214e94:	0f 83 7f 05 00 00    	jae    215419 <Benchmark_report+0x19b9>
  214e9a:	31 f6                	xor    esi,esi
  214e9c:	48 85 d2             	test   rdx,rdx
  214e9f:	0f 85 c5 06 00 00    	jne    21556a <Benchmark_report+0x1b0a>
  214ea5:	e9 0a 07 00 00       	jmp    2155b4 <Benchmark_report+0x1b54>
  214eaa:	48 89 5c 24 10       	mov    QWORD PTR [rsp+0x10],rbx
  214eaf:	49 89 dc             	mov    r12,rbx
  214eb2:	49 83 e4 80          	and    r12,0xffffffffffffff80
  214eb6:	49 8d 5c 24 80       	lea    rbx,[r12-0x80]
  214ebb:	48 89 d9             	mov    rcx,rbx
  214ebe:	48 c1 e9 07          	shr    rcx,0x7
  214ec2:	8d 51 01             	lea    edx,[rcx+0x1]
  214ec5:	83 e2 03             	and    edx,0x3
  214ec8:	48 81 fb 80 01 00 00 	cmp    rbx,0x180
  214ecf:	0f 83 01 07 00 00    	jae    2155d6 <Benchmark_report+0x1b76>
  214ed5:	31 f6                	xor    esi,esi
  214ed7:	48 85 d2             	test   rdx,rdx
  214eda:	0f 85 34 08 00 00    	jne    215714 <Benchmark_report+0x1cb4>
  214ee0:	e9 79 08 00 00       	jmp    21575e <Benchmark_report+0x1cfe>
  214ee5:	48 8d 4a ff          	lea    rcx,[rdx-0x1]
  214ee9:	48 29 f1             	sub    rcx,rsi
  214eec:	31 f6                	xor    esi,esi
  214eee:	c4 c1 7c 10 44 35 00 	vmovups ymm0,YMMWORD PTR [r13+rsi*1+0x0]
  214ef5:	c4 c1 7c 10 4c 35 20 	vmovups ymm1,YMMWORD PTR [r13+rsi*1+0x20]
  214efc:	c4 c1 7c 10 54 35 40 	vmovups ymm2,YMMWORD PTR [r13+rsi*1+0x40]
  214f03:	c4 c1 7c 10 5c 35 60 	vmovups ymm3,YMMWORD PTR [r13+rsi*1+0x60]
        dest[i] = s;
  214f0a:	c4 c1 7c 11 04 36    	vmovups YMMWORD PTR [r14+rsi*1],ymm0
  214f10:	c4 c1 7c 11 4c 36 20 	vmovups YMMWORD PTR [r14+rsi*1+0x20],ymm1
  214f17:	c4 c1 7c 11 54 36 40 	vmovups YMMWORD PTR [r14+rsi*1+0x40],ymm2
  214f1e:	c4 c1 7c 11 5c 36 60 	vmovups YMMWORD PTR [r14+rsi*1+0x60],ymm3
    for (source) |s, i|
  214f25:	c4 c1 7c 10 84 35 80 	vmovups ymm0,YMMWORD PTR [r13+rsi*1+0x80]
  214f2c:	00 00 00 
  214f2f:	c4 c1 7c 10 8c 35 a0 	vmovups ymm1,YMMWORD PTR [r13+rsi*1+0xa0]
  214f36:	00 00 00 
  214f39:	c4 c1 7c 10 94 35 c0 	vmovups ymm2,YMMWORD PTR [r13+rsi*1+0xc0]
  214f40:	00 00 00 
  214f43:	c4 c1 7c 10 9c 35 e0 	vmovups ymm3,YMMWORD PTR [r13+rsi*1+0xe0]
  214f4a:	00 00 00 
        dest[i] = s;
  214f4d:	c4 c1 7c 11 84 36 80 	vmovups YMMWORD PTR [r14+rsi*1+0x80],ymm0
  214f54:	00 00 00 
  214f57:	c4 c1 7c 11 8c 36 a0 	vmovups YMMWORD PTR [r14+rsi*1+0xa0],ymm1
  214f5e:	00 00 00 
  214f61:	c4 c1 7c 11 94 36 c0 	vmovups YMMWORD PTR [r14+rsi*1+0xc0],ymm2
  214f68:	00 00 00 
  214f6b:	c4 c1 7c 11 9c 36 e0 	vmovups YMMWORD PTR [r14+rsi*1+0xe0],ymm3
  214f72:	00 00 00 
    for (source) |s, i|
  214f75:	c4 c1 7c 10 84 35 00 	vmovups ymm0,YMMWORD PTR [r13+rsi*1+0x100]
  214f7c:	01 00 00 
  214f7f:	c4 c1 7c 10 8c 35 20 	vmovups ymm1,YMMWORD PTR [r13+rsi*1+0x120]
  214f86:	01 00 00 
  214f89:	c4 c1 7c 10 94 35 40 	vmovups ymm2,YMMWORD PTR [r13+rsi*1+0x140]
  214f90:	01 00 00 
  214f93:	c4 c1 7c 10 9c 35 60 	vmovups ymm3,YMMWORD PTR [r13+rsi*1+0x160]
  214f9a:	01 00 00 
        dest[i] = s;
  214f9d:	c4 c1 7c 11 84 36 00 	vmovups YMMWORD PTR [r14+rsi*1+0x100],ymm0
  214fa4:	01 00 00 
  214fa7:	c4 c1 7c 11 8c 36 20 	vmovups YMMWORD PTR [r14+rsi*1+0x120],ymm1
  214fae:	01 00 00 
  214fb1:	c4 c1 7c 11 94 36 40 	vmovups YMMWORD PTR [r14+rsi*1+0x140],ymm2
  214fb8:	01 00 00 
  214fbb:	c4 c1 7c 11 9c 36 60 	vmovups YMMWORD PTR [r14+rsi*1+0x160],ymm3
  214fc2:	01 00 00 
    for (source) |s, i|
  214fc5:	c4 c1 7d 10 84 35 80 	vmovupd ymm0,YMMWORD PTR [r13+rsi*1+0x180]
  214fcc:	01 00 00 
  214fcf:	c4 c1 7c 10 8c 35 a0 	vmovups ymm1,YMMWORD PTR [r13+rsi*1+0x1a0]
  214fd6:	01 00 00 
  214fd9:	c4 c1 7d 10 94 35 c0 	vmovupd ymm2,YMMWORD PTR [r13+rsi*1+0x1c0]
  214fe0:	01 00 00 
  214fe3:	c4 c1 7d 10 9c 35 e0 	vmovupd ymm3,YMMWORD PTR [r13+rsi*1+0x1e0]
  214fea:	01 00 00 
        dest[i] = s;
  214fed:	c4 c1 7d 11 84 36 80 	vmovupd YMMWORD PTR [r14+rsi*1+0x180],ymm0
  214ff4:	01 00 00 
  214ff7:	c4 c1 7c 11 8c 36 a0 	vmovups YMMWORD PTR [r14+rsi*1+0x1a0],ymm1
  214ffe:	01 00 00 
  215001:	c4 c1 7d 11 94 36 c0 	vmovupd YMMWORD PTR [r14+rsi*1+0x1c0],ymm2
  215008:	01 00 00 
  21500b:	c4 c1 7d 11 9c 36 e0 	vmovupd YMMWORD PTR [r14+rsi*1+0x1e0],ymm3
  215012:	01 00 00 
    for (source) |s, i|
  215015:	48 81 c6 00 02 00 00 	add    rsi,0x200
  21501c:	48 83 c1 04          	add    rcx,0x4
  215020:	0f 85 c8 fe ff ff    	jne    214eee <Benchmark_report+0x148e>
  215026:	48 85 d2             	test   rdx,rdx
  215029:	74 48                	je     215073 <Benchmark_report+0x1613>
  21502b:	48 83 c6 60          	add    rsi,0x60
  21502f:	48 f7 da             	neg    rdx
  215032:	c4 c1 7d 10 44 35 a0 	vmovupd ymm0,YMMWORD PTR [r13+rsi*1-0x60]
  215039:	c4 c1 7c 10 4c 35 c0 	vmovups ymm1,YMMWORD PTR [r13+rsi*1-0x40]
  215040:	c4 c1 7d 10 54 35 e0 	vmovupd ymm2,YMMWORD PTR [r13+rsi*1-0x20]
  215047:	c4 c1 7d 10 5c 35 00 	vmovupd ymm3,YMMWORD PTR [r13+rsi*1+0x0]
        dest[i] = s;
  21504e:	c4 c1 7d 11 44 36 a0 	vmovupd YMMWORD PTR [r14+rsi*1-0x60],ymm0
  215055:	c4 c1 7c 11 4c 36 c0 	vmovups YMMWORD PTR [r14+rsi*1-0x40],ymm1
  21505c:	c4 c1 7d 11 54 36 e0 	vmovupd YMMWORD PTR [r14+rsi*1-0x20],ymm2
  215063:	c4 c1 7d 11 1c 36    	vmovupd YMMWORD PTR [r14+rsi*1],ymm3
    for (source) |s, i|
  215069:	48 83 ee 80          	sub    rsi,0xffffffffffffff80
  21506d:	48 83 c2 01          	add    rdx,0x1
  215071:	75 bf                	jne    215032 <Benchmark_report+0x15d2>
    context.remaining = context.remaining[bytes.len..];
  215073:	4c 89 fa             	mov    rdx,r15
  215076:	49 39 ff             	cmp    r15,rdi
  215079:	0f 85 6f fc ff ff    	jne    214cee <Benchmark_report+0x128e>
  21507f:	49 01 d6             	add    r14,rdx
  215082:	48 29 d5             	sub    rbp,rdx
            while (i < num_digits_whole) : (i += 1) {
  215085:	4d 39 c3             	cmp    r11,r8
  215088:	76 23                	jbe    2150ad <Benchmark_report+0x164d>
  21508a:	31 ff                	xor    edi,edi
  21508c:	4c 89 f9             	mov    rcx,r15
    if (context.remaining.len < bytes.len) return error.BufferTooSmall;
  21508f:	48 85 ed             	test   rbp,rbp
  215092:	0f 84 95 f1 ff ff    	je     21422d <Benchmark_report+0x7cd>
        dest[i] = s;
  215098:	41 c6 06 30          	mov    BYTE PTR [r14],0x30
    context.remaining = context.remaining[bytes.len..];
  21509c:	49 83 c6 01          	add    r14,0x1
  2150a0:	48 83 c5 ff          	add    rbp,0xffffffffffffffff
            while (i < num_digits_whole) : (i += 1) {
  2150a4:	48 83 c1 01          	add    rcx,0x1
  2150a8:	4c 39 d9             	cmp    rcx,r11
  2150ab:	72 e2                	jb     21508f <Benchmark_report+0x162f>
  2150ad:	66 b8 05 00          	mov    ax,0x5
    if (context.remaining.len < bytes.len) return error.BufferTooSmall;
  2150b1:	48 85 ed             	test   rbp,rbp
  2150b4:	0f 84 28 fd ff ff    	je     214de2 <Benchmark_report+0x1382>
  2150ba:	41 c6 06 2e          	mov    BYTE PTR [r14],0x2e
    context.remaining = context.remaining[bytes.len..];
  2150be:	4d 8d 56 01          	lea    r10,[r14+0x1]
  2150c2:	48 8d 7d ff          	lea    rdi,[rbp-0x1]
        if (float_decimal.exp <= 0) {
  2150c6:	45 85 c9             	test   r9d,r9d
  2150c9:	7e 67                	jle    215132 <Benchmark_report+0x16d2>
  2150cb:	45 31 c9             	xor    r9d,r9d
        if (num_digits_whole_no_pad + precision - printed < float_decimal.digits.len) {
  2150ce:	4c 89 c9             	mov    rcx,r9
  2150d1:	48 f7 d9             	neg    rcx
  2150d4:	4c 01 f9             	add    rcx,r15
  2150d7:	48 83 c1 03          	add    rcx,0x3
  2150db:	4b 8d 34 2f          	lea    rsi,[r15+r13*1]
  2150df:	4c 39 c1             	cmp    rcx,r8
  2150e2:	73 2e                	jae    215112 <Benchmark_report+0x16b2>
            try output(context, float_decimal.digits[num_digits_whole_no_pad .. num_digits_whole_no_pad + precision - printed]);
  2150e4:	49 89 cc             	mov    r12,rcx
  2150e7:	4d 29 fc             	sub    r12,r15
    if (context.remaining.len < bytes.len) return error.BufferTooSmall;
  2150ea:	4c 39 e7             	cmp    rdi,r12
  2150ed:	72 32                	jb     215121 <Benchmark_report+0x16c1>
    for (source) |s, i|
  2150ef:	4d 85 e4             	test   r12,r12
  2150f2:	0f 84 dd 00 00 00    	je     2151d5 <Benchmark_report+0x1775>
  2150f8:	8a 06                	mov    al,BYTE PTR [rsi]
        dest[i] = s;
  2150fa:	41 88 02             	mov    BYTE PTR [r10],al
    for (source) |s, i|
  2150fd:	49 83 fc 01          	cmp    r12,0x1
  215101:	0f 85 f2 00 00 00    	jne    2151f9 <Benchmark_report+0x1799>
  215107:	41 bc 01 00 00 00    	mov    r12d,0x1
  21510d:	e9 95 08 00 00       	jmp    2159a7 <Benchmark_report+0x1f47>
            try output(context, float_decimal.digits[num_digits_whole_no_pad..]);
  215112:	4d 89 c4             	mov    r12,r8
  215115:	4d 29 fc             	sub    r12,r15
    if (context.remaining.len < bytes.len) return error.BufferTooSmall;
  215118:	4c 39 e7             	cmp    rdi,r12
  21511b:	0f 83 96 00 00 00    	jae    2151b7 <Benchmark_report+0x1757>
  215121:	4d 89 d6             	mov    r14,r10
                    try formatType(args[next_arg], fmt[s..i], context, Errors, output);
  215124:	66 85 c0             	test   ax,ax
  215127:	0f 85 a5 eb ff ff    	jne    213cd2 <Benchmark_report+0x272>
  21512d:	e9 04 f1 ff ff       	jmp    214236 <Benchmark_report+0x7d6>
            const zero_digit_count = @intCast(usize, -float_decimal.exp);
  215132:	41 f7 d9             	neg    r9d
  215135:	49 63 d1             	movsxd rdx,r9d
  215138:	48 83 fa 03          	cmp    rdx,0x3
  21513c:	b9 03 00 00 00       	mov    ecx,0x3
  215141:	48 0f 42 ca          	cmovb  rcx,rdx
            while (i < zeros_to_print) : (i += 1) {
  215145:	48 85 c9             	test   rcx,rcx
  215148:	74 81                	je     2150cb <Benchmark_report+0x166b>
    if (context.remaining.len < bytes.len) return error.BufferTooSmall;
  21514a:	48 85 ff             	test   rdi,rdi
  21514d:	0f 84 9d 02 00 00    	je     2153f0 <Benchmark_report+0x1990>
        dest[i] = s;
  215153:	41 c6 46 01 30       	mov    BYTE PTR [r14+0x1],0x30
    context.remaining = context.remaining[bytes.len..];
  215158:	4d 8d 56 02          	lea    r10,[r14+0x2]
  21515c:	48 8d 7d fe          	lea    rdi,[rbp-0x2]
            while (i < zeros_to_print) : (i += 1) {
  215160:	48 83 f9 01          	cmp    rcx,0x1
  215164:	76 7e                	jbe    2151e4 <Benchmark_report+0x1784>
    if (context.remaining.len < bytes.len) return error.BufferTooSmall;
  215166:	48 85 ff             	test   rdi,rdi
  215169:	0f 84 81 02 00 00    	je     2153f0 <Benchmark_report+0x1990>
  21516f:	41 c6 46 02 30       	mov    BYTE PTR [r14+0x2],0x30
    context.remaining = context.remaining[bytes.len..];
  215174:	4d 8d 56 03          	lea    r10,[r14+0x3]
  215178:	48 8d 7d fd          	lea    rdi,[rbp-0x3]
            while (i < zeros_to_print) : (i += 1) {
  21517c:	48 83 f9 03          	cmp    rcx,0x3
  215180:	0f 82 f8 05 00 00    	jb     21577e <Benchmark_report+0x1d1e>
    if (context.remaining.len < bytes.len) return error.BufferTooSmall;
  215186:	48 85 ff             	test   rdi,rdi
  215189:	0f 84 61 02 00 00    	je     2153f0 <Benchmark_report+0x1990>
  21518f:	41 c6 46 03 30       	mov    BYTE PTR [r14+0x3],0x30
    context.remaining = context.remaining[bytes.len..];
  215194:	49 83 c6 04          	add    r14,0x4
  215198:	48 83 c5 fc          	add    rbp,0xfffffffffffffffc
  21519c:	b1 01                	mov    cl,0x1
  21519e:	41 b9 03 00 00 00    	mov    r9d,0x3
  2151a4:	4d 89 f2             	mov    r10,r14
  2151a7:	48 89 ef             	mov    rdi,rbp
            if (printed >= precision) {
  2151aa:	84 c9                	test   cl,cl
  2151ac:	0f 84 1c ff ff ff    	je     2150ce <Benchmark_report+0x166e>
  2151b2:	e9 d7 05 00 00       	jmp    21578e <Benchmark_report+0x1d2e>
    for (source) |s, i|
  2151b7:	4d 85 e4             	test   r12,r12
  2151ba:	74 21                	je     2151dd <Benchmark_report+0x177d>
  2151bc:	8a 0e                	mov    cl,BYTE PTR [rsi]
        dest[i] = s;
  2151be:	41 88 0a             	mov    BYTE PTR [r10],cl
    for (source) |s, i|
  2151c1:	49 83 fc 01          	cmp    r12,0x1
  2151c5:	0f 85 29 01 00 00    	jne    2152f4 <Benchmark_report+0x1894>
  2151cb:	b9 01 00 00 00       	mov    ecx,0x1
  2151d0:	e9 a5 01 00 00       	jmp    21537a <Benchmark_report+0x191a>
  2151d5:	45 31 e4             	xor    r12d,r12d
  2151d8:	e9 ca 07 00 00       	jmp    2159a7 <Benchmark_report+0x1f47>
  2151dd:	31 c9                	xor    ecx,ecx
  2151df:	e9 96 01 00 00       	jmp    21537a <Benchmark_report+0x191a>
  2151e4:	31 c9                	xor    ecx,ecx
  2151e6:	41 b9 01 00 00 00    	mov    r9d,0x1
  2151ec:	84 c9                	test   cl,cl
  2151ee:	0f 84 da fe ff ff    	je     2150ce <Benchmark_report+0x166e>
  2151f4:	e9 95 05 00 00       	jmp    21578e <Benchmark_report+0x1d2e>
  2151f9:	41 be 02 00 00 00    	mov    r14d,0x2
  2151ff:	4d 29 ce             	sub    r14,r9
  215202:	49 81 fe 80 00 00 00 	cmp    r14,0x80
  215209:	72 25                	jb     215230 <Benchmark_report+0x17d0>
  21520b:	49 8d 42 01          	lea    rax,[r10+0x1]
  21520f:	4c 01 e9             	add    rcx,r13
  215212:	48 39 c8             	cmp    rax,rcx
  215215:	0f 83 86 05 00 00    	jae    2157a1 <Benchmark_report+0x1d41>
  21521b:	4b 8d 04 22          	lea    rax,[r10+r12*1]
  21521f:	4b 8d 0c 2f          	lea    rcx,[r15+r13*1]
  215223:	48 83 c1 01          	add    rcx,0x1
  215227:	48 39 c1             	cmp    rcx,rax
  21522a:	0f 83 71 05 00 00    	jae    2157a1 <Benchmark_report+0x1d41>
  215230:	b8 01 00 00 00       	mov    eax,0x1
  215235:	b9 03 00 00 00       	mov    ecx,0x3
  21523a:	44 29 c9             	sub    ecx,r9d
  21523d:	29 c1                	sub    ecx,eax
  21523f:	ba 02 00 00 00       	mov    edx,0x2
  215244:	4c 29 ca             	sub    rdx,r9
  215247:	48 29 c2             	sub    rdx,rax
  21524a:	48 83 e1 07          	and    rcx,0x7
  21524e:	74 15                	je     215265 <Benchmark_report+0x1805>
  215250:	48 f7 d9             	neg    rcx
  215253:	0f b6 1c 06          	movzx  ebx,BYTE PTR [rsi+rax*1]
        dest[i] = s;
  215257:	41 88 1c 02          	mov    BYTE PTR [r10+rax*1],bl
    for (source) |s, i|
  21525b:	48 83 c0 01          	add    rax,0x1
  21525f:	48 83 c1 01          	add    rcx,0x1
  215263:	75 ee                	jne    215253 <Benchmark_report+0x17f3>
  215265:	48 83 fa 07          	cmp    rdx,0x7
  215269:	0f 82 38 07 00 00    	jb     2159a7 <Benchmark_report+0x1f47>
  21526f:	b9 03 00 00 00       	mov    ecx,0x3
  215274:	4c 29 c9             	sub    rcx,r9
  215277:	48 29 c1             	sub    rcx,rax
  21527a:	49 f7 d3             	not    r11
  21527d:	49 f7 d0             	not    r8
  215280:	4d 39 c3             	cmp    r11,r8
  215283:	4d 0f 47 c3          	cmova  r8,r11
  215287:	49 8d 14 02          	lea    rdx,[r10+rax*1]
  21528b:	48 83 c2 07          	add    rdx,0x7
  21528f:	4c 29 c0             	sub    rax,r8
  215292:	49 01 c5             	add    r13,rax
  215295:	31 c0                	xor    eax,eax
  215297:	41 0f b6 5c 05 ff    	movzx  ebx,BYTE PTR [r13+rax*1-0x1]
        dest[i] = s;
  21529d:	88 5c 02 f9          	mov    BYTE PTR [rdx+rax*1-0x7],bl
    for (source) |s, i|
  2152a1:	41 0f b6 5c 05 00    	movzx  ebx,BYTE PTR [r13+rax*1+0x0]
        dest[i] = s;
  2152a7:	88 5c 02 fa          	mov    BYTE PTR [rdx+rax*1-0x6],bl
    for (source) |s, i|
  2152ab:	41 0f b6 5c 05 01    	movzx  ebx,BYTE PTR [r13+rax*1+0x1]
        dest[i] = s;
  2152b1:	88 5c 02 fb          	mov    BYTE PTR [rdx+rax*1-0x5],bl
    for (source) |s, i|
  2152b5:	41 0f b6 5c 05 02    	movzx  ebx,BYTE PTR [r13+rax*1+0x2]
        dest[i] = s;
  2152bb:	88 5c 02 fc          	mov    BYTE PTR [rdx+rax*1-0x4],bl
    for (source) |s, i|
  2152bf:	41 0f b6 5c 05 03    	movzx  ebx,BYTE PTR [r13+rax*1+0x3]
        dest[i] = s;
  2152c5:	88 5c 02 fd          	mov    BYTE PTR [rdx+rax*1-0x3],bl
    for (source) |s, i|
  2152c9:	41 0f b6 5c 05 04    	movzx  ebx,BYTE PTR [r13+rax*1+0x4]
        dest[i] = s;
  2152cf:	88 5c 02 fe          	mov    BYTE PTR [rdx+rax*1-0x2],bl
    for (source) |s, i|
  2152d3:	41 0f b6 5c 05 05    	movzx  ebx,BYTE PTR [r13+rax*1+0x5]
        dest[i] = s;
  2152d9:	88 5c 02 ff          	mov    BYTE PTR [rdx+rax*1-0x1],bl
    for (source) |s, i|
  2152dd:	41 0f b6 5c 05 06    	movzx  ebx,BYTE PTR [r13+rax*1+0x6]
        dest[i] = s;
  2152e3:	88 1c 02             	mov    BYTE PTR [rdx+rax*1],bl
    for (source) |s, i|
  2152e6:	48 83 c0 08          	add    rax,0x8
  2152ea:	48 39 c1             	cmp    rcx,rax
  2152ed:	75 a8                	jne    215297 <Benchmark_report+0x1837>
  2152ef:	e9 b3 06 00 00       	jmp    2159a7 <Benchmark_report+0x1f47>
  2152f4:	4d 39 d8             	cmp    r8,r11
  2152f7:	4c 89 c1             	mov    rcx,r8
  2152fa:	49 0f 47 cb          	cmova  rcx,r11
  2152fe:	48 f7 d1             	not    rcx
  215301:	4d 8d 34 08          	lea    r14,[r8+rcx*1]
  215305:	49 81 fe 80 00 00 00 	cmp    r14,0x80
  21530c:	72 26                	jb     215334 <Benchmark_report+0x18d4>
  21530e:	49 8d 52 01          	lea    rdx,[r10+0x1]
  215312:	4b 8d 1c 28          	lea    rbx,[r8+r13*1]
  215316:	48 39 da             	cmp    rdx,rbx
  215319:	0f 83 b3 04 00 00    	jae    2157d2 <Benchmark_report+0x1d72>
  21531f:	4b 8d 14 22          	lea    rdx,[r10+r12*1]
  215323:	4b 8d 1c 2f          	lea    rbx,[r15+r13*1]
  215327:	48 83 c3 01          	add    rbx,0x1
  21532b:	48 39 d3             	cmp    rbx,rdx
  21532e:	0f 83 9e 04 00 00    	jae    2157d2 <Benchmark_report+0x1d72>
  215334:	41 bf 01 00 00 00    	mov    r15d,0x1
  21533a:	49 f7 d3             	not    r11
  21533d:	4c 89 c6             	mov    rsi,r8
  215340:	48 f7 d6             	not    rsi
  215343:	49 39 f3             	cmp    r11,rsi
  215346:	49 0f 47 f3          	cmova  rsi,r11
  21534a:	49 8d 0c 30          	lea    rcx,[r8+rsi*1]
  21534e:	48 83 c1 01          	add    rcx,0x1
  215352:	4c 29 f9             	sub    rcx,r15
  215355:	4b 8d 14 3a          	lea    rdx,[r10+r15*1]
  215359:	49 83 c7 ff          	add    r15,0xffffffffffffffff
  21535d:	49 29 f7             	sub    r15,rsi
  215360:	4d 01 fd             	add    r13,r15
  215363:	31 f6                	xor    esi,esi
  215365:	41 0f b6 5c 35 00    	movzx  ebx,BYTE PTR [r13+rsi*1+0x0]
        dest[i] = s;
  21536b:	88 1c 32             	mov    BYTE PTR [rdx+rsi*1],bl
    for (source) |s, i|
  21536e:	48 83 c6 01          	add    rsi,0x1
  215372:	48 39 f1             	cmp    rcx,rsi
  215375:	75 ee                	jne    215365 <Benchmark_report+0x1905>
    context.remaining = context.remaining[bytes.len..];
  215377:	4c 89 e1             	mov    rcx,r12
  21537a:	49 01 ca             	add    r10,rcx
  21537d:	48 29 cf             	sub    rdi,rcx
            printed += float_decimal.digits.len - num_digits_whole_no_pad;
  215380:	4d 01 e1             	add    r9,r12
            while (printed < precision) : (printed += 1) {
  215383:	49 83 f9 02          	cmp    r9,0x2
  215387:	0f 87 01 04 00 00    	ja     21578e <Benchmark_report+0x1d2e>
    if (context.remaining.len < bytes.len) return error.BufferTooSmall;
  21538d:	48 85 ff             	test   rdi,rdi
  215390:	74 5e                	je     2153f0 <Benchmark_report+0x1990>
        dest[i] = s;
  215392:	41 c6 02 30          	mov    BYTE PTR [r10],0x30
    context.remaining = context.remaining[bytes.len..];
  215396:	49 83 c2 01          	add    r10,0x1
  21539a:	48 8d 4f ff          	lea    rcx,[rdi-0x1]
            while (printed < precision) : (printed += 1) {
  21539e:	49 8d 51 01          	lea    rdx,[r9+0x1]
  2153a2:	48 83 fa 03          	cmp    rdx,0x3
  2153a6:	73 5b                	jae    215403 <Benchmark_report+0x19a3>
    if (context.remaining.len < bytes.len) return error.BufferTooSmall;
  2153a8:	48 85 c9             	test   rcx,rcx
  2153ab:	74 43                	je     2153f0 <Benchmark_report+0x1990>
  2153ad:	41 c6 02 30          	mov    BYTE PTR [r10],0x30
    context.remaining = context.remaining[bytes.len..];
  2153b1:	49 83 c2 01          	add    r10,0x1
  2153b5:	48 8d 4f fe          	lea    rcx,[rdi-0x2]
            while (printed < precision) : (printed += 1) {
  2153b9:	49 8d 51 02          	lea    rdx,[r9+0x2]
  2153bd:	48 83 fa 02          	cmp    rdx,0x2
  2153c1:	77 40                	ja     215403 <Benchmark_report+0x19a3>
    if (context.remaining.len < bytes.len) return error.BufferTooSmall;
  2153c3:	48 85 c9             	test   rcx,rcx
  2153c6:	74 28                	je     2153f0 <Benchmark_report+0x1990>
  2153c8:	41 c6 02 30          	mov    BYTE PTR [r10],0x30
    context.remaining = context.remaining[bytes.len..];
  2153cc:	49 83 c2 01          	add    r10,0x1
  2153d0:	48 8d 4f fd          	lea    rcx,[rdi-0x3]
            while (printed < precision) : (printed += 1) {
  2153d4:	49 83 f9 fd          	cmp    r9,0xfffffffffffffffd
  2153d8:	72 29                	jb     215403 <Benchmark_report+0x19a3>
    if (context.remaining.len < bytes.len) return error.BufferTooSmall;
  2153da:	48 85 c9             	test   rcx,rcx
  2153dd:	74 11                	je     2153f0 <Benchmark_report+0x1990>
  2153df:	41 c6 02 30          	mov    BYTE PTR [r10],0x30
    context.remaining = context.remaining[bytes.len..];
  2153e3:	49 83 c2 01          	add    r10,0x1
  2153e7:	48 83 c7 fc          	add    rdi,0xfffffffffffffffc
  2153eb:	e9 9e 03 00 00       	jmp    21578e <Benchmark_report+0x1d2e>
  2153f0:	31 ff                	xor    edi,edi
  2153f2:	4d 89 d6             	mov    r14,r10
                    try formatType(args[next_arg], fmt[s..i], context, Errors, output);
  2153f5:	66 85 c0             	test   ax,ax
  2153f8:	0f 85 d4 e8 ff ff    	jne    213cd2 <Benchmark_report+0x272>
  2153fe:	e9 33 ee ff ff       	jmp    214236 <Benchmark_report+0x7d6>
  215403:	31 c0                	xor    eax,eax
  215405:	48 89 cf             	mov    rdi,rcx
  215408:	4d 89 d6             	mov    r14,r10
  21540b:	66 85 c0             	test   ax,ax
  21540e:	0f 85 be e8 ff ff    	jne    213cd2 <Benchmark_report+0x272>
  215414:	e9 1d ee ff ff       	jmp    214236 <Benchmark_report+0x7d6>
    for (source) |s, i|
  215419:	4c 89 db             	mov    rbx,r11
  21541c:	48 f7 d3             	not    rbx
  21541f:	4c 89 cd             	mov    rbp,r9
  215422:	48 f7 d5             	not    rbp
  215425:	48 39 eb             	cmp    rbx,rbp
  215428:	48 0f 47 eb          	cmova  rbp,rbx
  21542c:	bb e0 01 00 00       	mov    ebx,0x1e0
  215431:	48 29 eb             	sub    rbx,rbp
  215434:	4c 01 eb             	add    rbx,r13
  215437:	48 8d 6a ff          	lea    rbp,[rdx-0x1]
  21543b:	48 29 f5             	sub    rbp,rsi
  21543e:	31 f6                	xor    esi,esi
  215440:	c5 fc 10 84 33 20 fe 	vmovups ymm0,YMMWORD PTR [rbx+rsi*1-0x1e0]
  215447:	ff ff 
  215449:	c5 fc 10 8c 33 40 fe 	vmovups ymm1,YMMWORD PTR [rbx+rsi*1-0x1c0]
  215450:	ff ff 
  215452:	c5 fc 10 94 33 60 fe 	vmovups ymm2,YMMWORD PTR [rbx+rsi*1-0x1a0]
  215459:	ff ff 
  21545b:	c5 fc 10 9c 33 80 fe 	vmovups ymm3,YMMWORD PTR [rbx+rsi*1-0x180]
  215462:	ff ff 
        dest[i] = s;
  215464:	c4 c1 7c 11 44 32 01 	vmovups YMMWORD PTR [r10+rsi*1+0x1],ymm0
  21546b:	c4 c1 7c 11 4c 32 21 	vmovups YMMWORD PTR [r10+rsi*1+0x21],ymm1
  215472:	c4 c1 7c 11 54 32 41 	vmovups YMMWORD PTR [r10+rsi*1+0x41],ymm2
  215479:	c4 c1 7c 11 5c 32 61 	vmovups YMMWORD PTR [r10+rsi*1+0x61],ymm3
    for (source) |s, i|
  215480:	c5 fc 10 84 33 a0 fe 	vmovups ymm0,YMMWORD PTR [rbx+rsi*1-0x160]
  215487:	ff ff 
  215489:	c5 fc 10 8c 33 c0 fe 	vmovups ymm1,YMMWORD PTR [rbx+rsi*1-0x140]
  215490:	ff ff 
  215492:	c5 fc 10 94 33 e0 fe 	vmovups ymm2,YMMWORD PTR [rbx+rsi*1-0x120]
  215499:	ff ff 
  21549b:	c5 fc 10 9c 33 00 ff 	vmovups ymm3,YMMWORD PTR [rbx+rsi*1-0x100]
  2154a2:	ff ff 
        dest[i] = s;
  2154a4:	c4 c1 7c 11 84 32 81 	vmovups YMMWORD PTR [r10+rsi*1+0x81],ymm0
  2154ab:	00 00 00 
  2154ae:	c4 c1 7c 11 8c 32 a1 	vmovups YMMWORD PTR [r10+rsi*1+0xa1],ymm1
  2154b5:	00 00 00 
  2154b8:	c4 c1 7c 11 94 32 c1 	vmovups YMMWORD PTR [r10+rsi*1+0xc1],ymm2
  2154bf:	00 00 00 
  2154c2:	c4 c1 7c 11 9c 32 e1 	vmovups YMMWORD PTR [r10+rsi*1+0xe1],ymm3
  2154c9:	00 00 00 
    for (source) |s, i|
  2154cc:	c5 fc 10 84 33 20 ff 	vmovups ymm0,YMMWORD PTR [rbx+rsi*1-0xe0]
  2154d3:	ff ff 
  2154d5:	c5 fc 10 8c 33 40 ff 	vmovups ymm1,YMMWORD PTR [rbx+rsi*1-0xc0]
  2154dc:	ff ff 
  2154de:	c5 fc 10 94 33 60 ff 	vmovups ymm2,YMMWORD PTR [rbx+rsi*1-0xa0]
  2154e5:	ff ff 
  2154e7:	c5 fc 10 5c 33 80    	vmovups ymm3,YMMWORD PTR [rbx+rsi*1-0x80]
        dest[i] = s;
  2154ed:	c4 c1 7c 11 84 32 01 	vmovups YMMWORD PTR [r10+rsi*1+0x101],ymm0
  2154f4:	01 00 00 
  2154f7:	c4 c1 7c 11 8c 32 21 	vmovups YMMWORD PTR [r10+rsi*1+0x121],ymm1
  2154fe:	01 00 00 
  215501:	c4 c1 7c 11 94 32 41 	vmovups YMMWORD PTR [r10+rsi*1+0x141],ymm2
  215508:	01 00 00 
  21550b:	c4 c1 7c 11 9c 32 61 	vmovups YMMWORD PTR [r10+rsi*1+0x161],ymm3
  215512:	01 00 00 
    for (source) |s, i|
  215515:	c5 fd 10 44 33 a0    	vmovupd ymm0,YMMWORD PTR [rbx+rsi*1-0x60]
  21551b:	c5 fc 10 4c 33 c0    	vmovups ymm1,YMMWORD PTR [rbx+rsi*1-0x40]
  215521:	c5 fd 10 54 33 e0    	vmovupd ymm2,YMMWORD PTR [rbx+rsi*1-0x20]
  215527:	c5 fd 10 1c 33       	vmovupd ymm3,YMMWORD PTR [rbx+rsi*1]
        dest[i] = s;
  21552c:	c4 c1 7d 11 84 32 81 	vmovupd YMMWORD PTR [r10+rsi*1+0x181],ymm0
  215533:	01 00 00 
  215536:	c4 c1 7c 11 8c 32 a1 	vmovups YMMWORD PTR [r10+rsi*1+0x1a1],ymm1
  21553d:	01 00 00 
  215540:	c4 c1 7d 11 94 32 c1 	vmovupd YMMWORD PTR [r10+rsi*1+0x1c1],ymm2
  215547:	01 00 00 
  21554a:	c4 c1 7d 11 9c 32 e1 	vmovupd YMMWORD PTR [r10+rsi*1+0x1e1],ymm3
  215551:	01 00 00 
  215554:	48 81 c6 00 02 00 00 	add    rsi,0x200
  21555b:	48 83 c5 04          	add    rbp,0x4
  21555f:	0f 85 db fe ff ff    	jne    215440 <Benchmark_report+0x19e0>
  215565:	48 85 d2             	test   rdx,rdx
  215568:	74 4a                	je     2155b4 <Benchmark_report+0x1b54>
  21556a:	48 f7 da             	neg    rdx
  21556d:	48 89 f3             	mov    rbx,rsi
  215570:	48 83 cb 01          	or     rbx,0x1
    for (source) |s, i|
  215574:	c4 c1 7d 10 04 1e    	vmovupd ymm0,YMMWORD PTR [r14+rbx*1]
  21557a:	c4 c1 7c 10 4c 1e 20 	vmovups ymm1,YMMWORD PTR [r14+rbx*1+0x20]
  215581:	c4 c1 7d 10 54 1e 40 	vmovupd ymm2,YMMWORD PTR [r14+rbx*1+0x40]
  215588:	c4 c1 7d 10 5c 1e 60 	vmovupd ymm3,YMMWORD PTR [r14+rbx*1+0x60]
        dest[i] = s;
  21558f:	c4 c1 7d 11 04 1a    	vmovupd YMMWORD PTR [r10+rbx*1],ymm0
  215595:	c4 c1 7c 11 4c 1a 20 	vmovups YMMWORD PTR [r10+rbx*1+0x20],ymm1
  21559c:	c4 c1 7d 11 54 1a 40 	vmovupd YMMWORD PTR [r10+rbx*1+0x40],ymm2
  2155a3:	c4 c1 7d 11 5c 1a 60 	vmovupd YMMWORD PTR [r10+rbx*1+0x60],ymm3
  2155aa:	48 83 ee 80          	sub    rsi,0xffffffffffffff80
  2155ae:	48 83 c2 01          	add    rdx,0x1
  2155b2:	75 b9                	jne    21556d <Benchmark_report+0x1b0d>
  2155b4:	48 39 c1             	cmp    rcx,rax
    for (source) |s, i|
  2155b7:	0f 85 b8 01 00 00    	jne    215775 <Benchmark_report+0x1d15>
    context.remaining = context.remaining[bytes.len..];
  2155bd:	4d 01 fa             	add    r10,r15
  2155c0:	4c 29 ff             	sub    rdi,r15
  2155c3:	31 c0                	xor    eax,eax
  2155c5:	4c 89 d5             	mov    rbp,r10
                    try formatType(args[next_arg], fmt[s..i], context, Errors, output);
  2155c8:	66 85 c0             	test   ax,ax
  2155cb:	0f 85 01 e7 ff ff    	jne    213cd2 <Benchmark_report+0x272>
  2155d1:	e9 7e e9 ff ff       	jmp    213f54 <Benchmark_report+0x4f4>
  2155d6:	bb e0 01 00 00       	mov    ebx,0x1e0
  2155db:	48 29 f3             	sub    rbx,rsi
  2155de:	4c 01 eb             	add    rbx,r13
  2155e1:	48 8d 6a ff          	lea    rbp,[rdx-0x1]
  2155e5:	48 29 cd             	sub    rbp,rcx
  2155e8:	31 f6                	xor    esi,esi
  2155ea:	c5 fc 10 84 33 20 fe 	vmovups ymm0,YMMWORD PTR [rbx+rsi*1-0x1e0]
  2155f1:	ff ff 
  2155f3:	c5 fc 10 8c 33 40 fe 	vmovups ymm1,YMMWORD PTR [rbx+rsi*1-0x1c0]
  2155fa:	ff ff 
  2155fc:	c5 fc 10 94 33 60 fe 	vmovups ymm2,YMMWORD PTR [rbx+rsi*1-0x1a0]
  215603:	ff ff 
  215605:	c5 fc 10 9c 33 80 fe 	vmovups ymm3,YMMWORD PTR [rbx+rsi*1-0x180]
  21560c:	ff ff 
        dest[i] = s;
  21560e:	c4 c1 7c 11 44 32 01 	vmovups YMMWORD PTR [r10+rsi*1+0x1],ymm0
  215615:	c4 c1 7c 11 4c 32 21 	vmovups YMMWORD PTR [r10+rsi*1+0x21],ymm1
  21561c:	c4 c1 7c 11 54 32 41 	vmovups YMMWORD PTR [r10+rsi*1+0x41],ymm2
  215623:	c4 c1 7c 11 5c 32 61 	vmovups YMMWORD PTR [r10+rsi*1+0x61],ymm3
    for (source) |s, i|
  21562a:	c5 fc 10 84 33 a0 fe 	vmovups ymm0,YMMWORD PTR [rbx+rsi*1-0x160]
  215631:	ff ff 
  215633:	c5 fc 10 8c 33 c0 fe 	vmovups ymm1,YMMWORD PTR [rbx+rsi*1-0x140]
  21563a:	ff ff 
  21563c:	c5 fc 10 94 33 e0 fe 	vmovups ymm2,YMMWORD PTR [rbx+rsi*1-0x120]
  215643:	ff ff 
  215645:	c5 fc 10 9c 33 00 ff 	vmovups ymm3,YMMWORD PTR [rbx+rsi*1-0x100]
  21564c:	ff ff 
        dest[i] = s;
  21564e:	c4 c1 7c 11 84 32 81 	vmovups YMMWORD PTR [r10+rsi*1+0x81],ymm0
  215655:	00 00 00 
  215658:	c4 c1 7c 11 8c 32 a1 	vmovups YMMWORD PTR [r10+rsi*1+0xa1],ymm1
  21565f:	00 00 00 
  215662:	c4 c1 7c 11 94 32 c1 	vmovups YMMWORD PTR [r10+rsi*1+0xc1],ymm2
  215669:	00 00 00 
  21566c:	c4 c1 7c 11 9c 32 e1 	vmovups YMMWORD PTR [r10+rsi*1+0xe1],ymm3
  215673:	00 00 00 
    for (source) |s, i|
  215676:	c5 fc 10 84 33 20 ff 	vmovups ymm0,YMMWORD PTR [rbx+rsi*1-0xe0]
  21567d:	ff ff 
  21567f:	c5 fc 10 8c 33 40 ff 	vmovups ymm1,YMMWORD PTR [rbx+rsi*1-0xc0]
  215686:	ff ff 
  215688:	c5 fc 10 94 33 60 ff 	vmovups ymm2,YMMWORD PTR [rbx+rsi*1-0xa0]
  21568f:	ff ff 
  215691:	c5 fc 10 5c 33 80    	vmovups ymm3,YMMWORD PTR [rbx+rsi*1-0x80]
        dest[i] = s;
  215697:	c4 c1 7c 11 84 32 01 	vmovups YMMWORD PTR [r10+rsi*1+0x101],ymm0
  21569e:	01 00 00 
  2156a1:	c4 c1 7c 11 8c 32 21 	vmovups YMMWORD PTR [r10+rsi*1+0x121],ymm1
  2156a8:	01 00 00 
  2156ab:	c4 c1 7c 11 94 32 41 	vmovups YMMWORD PTR [r10+rsi*1+0x141],ymm2
  2156b2:	01 00 00 
  2156b5:	c4 c1 7c 11 9c 32 61 	vmovups YMMWORD PTR [r10+rsi*1+0x161],ymm3
  2156bc:	01 00 00 
    for (source) |s, i|
  2156bf:	c5 fd 10 44 33 a0    	vmovupd ymm0,YMMWORD PTR [rbx+rsi*1-0x60]
  2156c5:	c5 fc 10 4c 33 c0    	vmovups ymm1,YMMWORD PTR [rbx+rsi*1-0x40]
  2156cb:	c5 fd 10 54 33 e0    	vmovupd ymm2,YMMWORD PTR [rbx+rsi*1-0x20]
  2156d1:	c5 fd 10 1c 33       	vmovupd ymm3,YMMWORD PTR [rbx+rsi*1]
        dest[i] = s;
  2156d6:	c4 c1 7d 11 84 32 81 	vmovupd YMMWORD PTR [r10+rsi*1+0x181],ymm0
  2156dd:	01 00 00 
  2156e0:	c4 c1 7c 11 8c 32 a1 	vmovups YMMWORD PTR [r10+rsi*1+0x1a1],ymm1
  2156e7:	01 00 00 
  2156ea:	c4 c1 7d 11 94 32 c1 	vmovupd YMMWORD PTR [r10+rsi*1+0x1c1],ymm2
  2156f1:	01 00 00 
  2156f4:	c4 c1 7d 11 9c 32 e1 	vmovupd YMMWORD PTR [r10+rsi*1+0x1e1],ymm3
  2156fb:	01 00 00 
  2156fe:	48 81 c6 00 02 00 00 	add    rsi,0x200
  215705:	48 83 c5 04          	add    rbp,0x4
  215709:	0f 85 db fe ff ff    	jne    2155ea <Benchmark_report+0x1b8a>
  21570f:	48 85 d2             	test   rdx,rdx
  215712:	74 4a                	je     21575e <Benchmark_report+0x1cfe>
  215714:	48 f7 da             	neg    rdx
  215717:	48 89 f1             	mov    rcx,rsi
  21571a:	48 83 c9 01          	or     rcx,0x1
    for (source) |s, i|
  21571e:	c4 c1 7d 10 04 0e    	vmovupd ymm0,YMMWORD PTR [r14+rcx*1]
  215724:	c4 c1 7c 10 4c 0e 20 	vmovups ymm1,YMMWORD PTR [r14+rcx*1+0x20]
  21572b:	c4 c1 7d 10 54 0e 40 	vmovupd ymm2,YMMWORD PTR [r14+rcx*1+0x40]
  215732:	c4 c1 7d 10 5c 0e 60 	vmovupd ymm3,YMMWORD PTR [r14+rcx*1+0x60]
        dest[i] = s;
  215739:	c4 c1 7d 11 04 0a    	vmovupd YMMWORD PTR [r10+rcx*1],ymm0
  21573f:	c4 c1 7c 11 4c 0a 20 	vmovups YMMWORD PTR [r10+rcx*1+0x20],ymm1
  215746:	c4 c1 7d 11 54 0a 40 	vmovupd YMMWORD PTR [r10+rcx*1+0x40],ymm2
  21574d:	c4 c1 7d 11 5c 0a 60 	vmovupd YMMWORD PTR [r10+rcx*1+0x60],ymm3
  215754:	48 83 ee 80          	sub    rsi,0xffffffffffffff80
  215758:	48 83 c2 01          	add    rdx,0x1
  21575c:	75 b9                	jne    215717 <Benchmark_report+0x1cb7>
    context.remaining = context.remaining[bytes.len..];
  21575e:	4c 89 fa             	mov    rdx,r15
  215761:	4c 39 64 24 10       	cmp    QWORD PTR [rsp+0x10],r12
    for (source) |s, i|
  215766:	0f 84 81 f4 ff ff    	je     214bed <Benchmark_report+0x118d>
  21576c:	49 83 cc 01          	or     r12,0x1
  215770:	e9 38 f4 ff ff       	jmp    214bad <Benchmark_report+0x114d>
  215775:	48 83 c8 01          	or     rax,0x1
  215779:	e9 29 f3 ff ff       	jmp    214aa7 <Benchmark_report+0x1047>
  21577e:	31 c9                	xor    ecx,ecx
  215780:	41 b9 02 00 00 00    	mov    r9d,0x2
            if (printed >= precision) {
  215786:	84 c9                	test   cl,cl
  215788:	0f 84 40 f9 ff ff    	je     2150ce <Benchmark_report+0x166e>
  21578e:	31 c0                	xor    eax,eax
  215790:	4d 89 d6             	mov    r14,r10
                    try formatType(args[next_arg], fmt[s..i], context, Errors, output);
  215793:	66 85 c0             	test   ax,ax
  215796:	0f 85 36 e5 ff ff    	jne    213cd2 <Benchmark_report+0x272>
  21579c:	e9 95 ea ff ff       	jmp    214236 <Benchmark_report+0x7d6>
  2157a1:	4c 89 f0             	mov    rax,r14
  2157a4:	48 83 e0 80          	and    rax,0xffffffffffffff80
  2157a8:	48 8d 48 80          	lea    rcx,[rax-0x80]
  2157ac:	48 89 cd             	mov    rbp,rcx
  2157af:	48 c1 ed 07          	shr    rbp,0x7
  2157b3:	8d 55 01             	lea    edx,[rbp+0x1]
  2157b6:	83 e2 03             	and    edx,0x3
  2157b9:	48 81 f9 80 01 00 00 	cmp    rcx,0x180
  2157c0:	73 45                	jae    215807 <Benchmark_report+0x1da7>
  2157c2:	31 ed                	xor    ebp,ebp
  2157c4:	48 85 d2             	test   rdx,rdx
  2157c7:	0f 85 8b 01 00 00    	jne    215958 <Benchmark_report+0x1ef8>
  2157cd:	e9 cc 01 00 00       	jmp    21599e <Benchmark_report+0x1f3e>
  2157d2:	4d 89 f7             	mov    r15,r14
  2157d5:	49 83 e7 80          	and    r15,0xffffffffffffff80
  2157d9:	49 8d 5f 80          	lea    rbx,[r15-0x80]
  2157dd:	48 89 da             	mov    rdx,rbx
  2157e0:	48 c1 ea 07          	shr    rdx,0x7
  2157e4:	8d 6a 01             	lea    ebp,[rdx+0x1]
  2157e7:	83 e5 03             	and    ebp,0x3
  2157ea:	48 81 fb 80 01 00 00 	cmp    rbx,0x180
  2157f1:	0f 83 c9 01 00 00    	jae    2159c0 <Benchmark_report+0x1f60>
  2157f7:	31 d2                	xor    edx,edx
  2157f9:	48 85 ed             	test   rbp,rbp
  2157fc:	0f 85 fc 02 00 00    	jne    215afe <Benchmark_report+0x209e>
  215802:	e9 3d 03 00 00       	jmp    215b44 <Benchmark_report+0x20e4>
  215807:	4c 89 db             	mov    rbx,r11
  21580a:	48 f7 d3             	not    rbx
  21580d:	4c 89 c1             	mov    rcx,r8
  215810:	48 f7 d1             	not    rcx
  215813:	48 39 cb             	cmp    rbx,rcx
  215816:	48 0f 47 cb          	cmova  rcx,rbx
  21581a:	bb e0 01 00 00       	mov    ebx,0x1e0
  21581f:	48 29 cb             	sub    rbx,rcx
  215822:	4c 01 eb             	add    rbx,r13
  215825:	48 8d 4a ff          	lea    rcx,[rdx-0x1]
  215829:	48 29 e9             	sub    rcx,rbp
  21582c:	31 ed                	xor    ebp,ebp
  21582e:	c5 fc 10 84 2b 20 fe 	vmovups ymm0,YMMWORD PTR [rbx+rbp*1-0x1e0]
  215835:	ff ff 
  215837:	c5 fc 10 8c 2b 40 fe 	vmovups ymm1,YMMWORD PTR [rbx+rbp*1-0x1c0]
  21583e:	ff ff 
  215840:	c5 fc 10 94 2b 60 fe 	vmovups ymm2,YMMWORD PTR [rbx+rbp*1-0x1a0]
  215847:	ff ff 
  215849:	c5 fc 10 9c 2b 80 fe 	vmovups ymm3,YMMWORD PTR [rbx+rbp*1-0x180]
  215850:	ff ff 
        dest[i] = s;
  215852:	c4 c1 7c 11 44 2a 01 	vmovups YMMWORD PTR [r10+rbp*1+0x1],ymm0
  215859:	c4 c1 7c 11 4c 2a 21 	vmovups YMMWORD PTR [r10+rbp*1+0x21],ymm1
  215860:	c4 c1 7c 11 54 2a 41 	vmovups YMMWORD PTR [r10+rbp*1+0x41],ymm2
  215867:	c4 c1 7c 11 5c 2a 61 	vmovups YMMWORD PTR [r10+rbp*1+0x61],ymm3
    for (source) |s, i|
  21586e:	c5 fc 10 84 2b a0 fe 	vmovups ymm0,YMMWORD PTR [rbx+rbp*1-0x160]
  215875:	ff ff 
  215877:	c5 fc 10 8c 2b c0 fe 	vmovups ymm1,YMMWORD PTR [rbx+rbp*1-0x140]
  21587e:	ff ff 
  215880:	c5 fc 10 94 2b e0 fe 	vmovups ymm2,YMMWORD PTR [rbx+rbp*1-0x120]
  215887:	ff ff 
  215889:	c5 fc 10 9c 2b 00 ff 	vmovups ymm3,YMMWORD PTR [rbx+rbp*1-0x100]
  215890:	ff ff 
        dest[i] = s;
  215892:	c4 c1 7c 11 84 2a 81 	vmovups YMMWORD PTR [r10+rbp*1+0x81],ymm0
  215899:	00 00 00 
  21589c:	c4 c1 7c 11 8c 2a a1 	vmovups YMMWORD PTR [r10+rbp*1+0xa1],ymm1
  2158a3:	00 00 00 
  2158a6:	c4 c1 7c 11 94 2a c1 	vmovups YMMWORD PTR [r10+rbp*1+0xc1],ymm2
  2158ad:	00 00 00 
  2158b0:	c4 c1 7c 11 9c 2a e1 	vmovups YMMWORD PTR [r10+rbp*1+0xe1],ymm3
  2158b7:	00 00 00 
    for (source) |s, i|
  2158ba:	c5 fc 10 84 2b 20 ff 	vmovups ymm0,YMMWORD PTR [rbx+rbp*1-0xe0]
  2158c1:	ff ff 
  2158c3:	c5 fc 10 8c 2b 40 ff 	vmovups ymm1,YMMWORD PTR [rbx+rbp*1-0xc0]
  2158ca:	ff ff 
  2158cc:	c5 fc 10 94 2b 60 ff 	vmovups ymm2,YMMWORD PTR [rbx+rbp*1-0xa0]
  2158d3:	ff ff 
  2158d5:	c5 fc 10 5c 2b 80    	vmovups ymm3,YMMWORD PTR [rbx+rbp*1-0x80]
        dest[i] = s;
  2158db:	c4 c1 7c 11 84 2a 01 	vmovups YMMWORD PTR [r10+rbp*1+0x101],ymm0
  2158e2:	01 00 00 
  2158e5:	c4 c1 7c 11 8c 2a 21 	vmovups YMMWORD PTR [r10+rbp*1+0x121],ymm1
  2158ec:	01 00 00 
  2158ef:	c4 c1 7c 11 94 2a 41 	vmovups YMMWORD PTR [r10+rbp*1+0x141],ymm2
  2158f6:	01 00 00 
  2158f9:	c4 c1 7c 11 9c 2a 61 	vmovups YMMWORD PTR [r10+rbp*1+0x161],ymm3
  215900:	01 00 00 
    for (source) |s, i|
  215903:	c5 fd 10 44 2b a0    	vmovupd ymm0,YMMWORD PTR [rbx+rbp*1-0x60]
  215909:	c5 fc 10 4c 2b c0    	vmovups ymm1,YMMWORD PTR [rbx+rbp*1-0x40]
  21590f:	c5 fd 10 54 2b e0    	vmovupd ymm2,YMMWORD PTR [rbx+rbp*1-0x20]
  215915:	c5 fd 10 1c 2b       	vmovupd ymm3,YMMWORD PTR [rbx+rbp*1]
        dest[i] = s;
  21591a:	c4 c1 7d 11 84 2a 81 	vmovupd YMMWORD PTR [r10+rbp*1+0x181],ymm0
  215921:	01 00 00 
  215924:	c4 c1 7c 11 8c 2a a1 	vmovups YMMWORD PTR [r10+rbp*1+0x1a1],ymm1
  21592b:	01 00 00 
  21592e:	c4 c1 7d 11 94 2a c1 	vmovupd YMMWORD PTR [r10+rbp*1+0x1c1],ymm2
  215935:	01 00 00 
  215938:	c4 c1 7d 11 9c 2a e1 	vmovupd YMMWORD PTR [r10+rbp*1+0x1e1],ymm3
  21593f:	01 00 00 
  215942:	48 81 c5 00 02 00 00 	add    rbp,0x200
  215949:	48 83 c1 04          	add    rcx,0x4
  21594d:	0f 85 db fe ff ff    	jne    21582e <Benchmark_report+0x1dce>
  215953:	48 85 d2             	test   rdx,rdx
  215956:	74 46                	je     21599e <Benchmark_report+0x1f3e>
  215958:	48 f7 da             	neg    rdx
  21595b:	48 89 e9             	mov    rcx,rbp
  21595e:	48 83 c9 01          	or     rcx,0x1
    for (source) |s, i|
  215962:	c5 fd 10 04 0e       	vmovupd ymm0,YMMWORD PTR [rsi+rcx*1]
  215967:	c5 fc 10 4c 0e 20    	vmovups ymm1,YMMWORD PTR [rsi+rcx*1+0x20]
  21596d:	c5 fd 10 54 0e 40    	vmovupd ymm2,YMMWORD PTR [rsi+rcx*1+0x40]
  215973:	c5 fd 10 5c 0e 60    	vmovupd ymm3,YMMWORD PTR [rsi+rcx*1+0x60]
        dest[i] = s;
  215979:	c4 c1 7d 11 04 0a    	vmovupd YMMWORD PTR [r10+rcx*1],ymm0
  21597f:	c4 c1 7c 11 4c 0a 20 	vmovups YMMWORD PTR [r10+rcx*1+0x20],ymm1
  215986:	c4 c1 7d 11 54 0a 40 	vmovupd YMMWORD PTR [r10+rcx*1+0x40],ymm2
  21598d:	c4 c1 7d 11 5c 0a 60 	vmovupd YMMWORD PTR [r10+rcx*1+0x60],ymm3
  215994:	48 83 ed 80          	sub    rbp,0xffffffffffffff80
  215998:	48 83 c2 01          	add    rdx,0x1
  21599c:	75 bd                	jne    21595b <Benchmark_report+0x1efb>
  21599e:	49 39 c6             	cmp    r14,rax
    for (source) |s, i|
  2159a1:	0f 85 b2 01 00 00    	jne    215b59 <Benchmark_report+0x20f9>
    context.remaining = context.remaining[bytes.len..];
  2159a7:	4d 01 e2             	add    r10,r12
  2159aa:	4c 29 e7             	sub    rdi,r12
  2159ad:	31 c0                	xor    eax,eax
  2159af:	4d 89 d6             	mov    r14,r10
                    try formatType(args[next_arg], fmt[s..i], context, Errors, output);
  2159b2:	66 85 c0             	test   ax,ax
  2159b5:	0f 85 17 e3 ff ff    	jne    213cd2 <Benchmark_report+0x272>
  2159bb:	e9 76 e8 ff ff       	jmp    214236 <Benchmark_report+0x7d6>
  2159c0:	bb e0 01 00 00       	mov    ebx,0x1e0
  2159c5:	48 29 cb             	sub    rbx,rcx
  2159c8:	4c 01 eb             	add    rbx,r13
  2159cb:	48 8d 4d ff          	lea    rcx,[rbp-0x1]
  2159cf:	48 29 d1             	sub    rcx,rdx
  2159d2:	31 d2                	xor    edx,edx
  2159d4:	c5 fc 10 84 13 20 fe 	vmovups ymm0,YMMWORD PTR [rbx+rdx*1-0x1e0]
  2159db:	ff ff 
  2159dd:	c5 fc 10 8c 13 40 fe 	vmovups ymm1,YMMWORD PTR [rbx+rdx*1-0x1c0]
  2159e4:	ff ff 
  2159e6:	c5 fc 10 94 13 60 fe 	vmovups ymm2,YMMWORD PTR [rbx+rdx*1-0x1a0]
  2159ed:	ff ff 
  2159ef:	c5 fc 10 9c 13 80 fe 	vmovups ymm3,YMMWORD PTR [rbx+rdx*1-0x180]
  2159f6:	ff ff 
        dest[i] = s;
  2159f8:	c4 c1 7c 11 44 12 01 	vmovups YMMWORD PTR [r10+rdx*1+0x1],ymm0
  2159ff:	c4 c1 7c 11 4c 12 21 	vmovups YMMWORD PTR [r10+rdx*1+0x21],ymm1
  215a06:	c4 c1 7c 11 54 12 41 	vmovups YMMWORD PTR [r10+rdx*1+0x41],ymm2
  215a0d:	c4 c1 7c 11 5c 12 61 	vmovups YMMWORD PTR [r10+rdx*1+0x61],ymm3
    for (source) |s, i|
  215a14:	c5 fc 10 84 13 a0 fe 	vmovups ymm0,YMMWORD PTR [rbx+rdx*1-0x160]
  215a1b:	ff ff 
  215a1d:	c5 fc 10 8c 13 c0 fe 	vmovups ymm1,YMMWORD PTR [rbx+rdx*1-0x140]
  215a24:	ff ff 
  215a26:	c5 fc 10 94 13 e0 fe 	vmovups ymm2,YMMWORD PTR [rbx+rdx*1-0x120]
  215a2d:	ff ff 
  215a2f:	c5 fc 10 9c 13 00 ff 	vmovups ymm3,YMMWORD PTR [rbx+rdx*1-0x100]
  215a36:	ff ff 
        dest[i] = s;
  215a38:	c4 c1 7c 11 84 12 81 	vmovups YMMWORD PTR [r10+rdx*1+0x81],ymm0
  215a3f:	00 00 00 
  215a42:	c4 c1 7c 11 8c 12 a1 	vmovups YMMWORD PTR [r10+rdx*1+0xa1],ymm1
  215a49:	00 00 00 
  215a4c:	c4 c1 7c 11 94 12 c1 	vmovups YMMWORD PTR [r10+rdx*1+0xc1],ymm2
  215a53:	00 00 00 
  215a56:	c4 c1 7c 11 9c 12 e1 	vmovups YMMWORD PTR [r10+rdx*1+0xe1],ymm3
  215a5d:	00 00 00 
    for (source) |s, i|
  215a60:	c5 fc 10 84 13 20 ff 	vmovups ymm0,YMMWORD PTR [rbx+rdx*1-0xe0]
  215a67:	ff ff 
  215a69:	c5 fc 10 8c 13 40 ff 	vmovups ymm1,YMMWORD PTR [rbx+rdx*1-0xc0]
  215a70:	ff ff 
  215a72:	c5 fc 10 94 13 60 ff 	vmovups ymm2,YMMWORD PTR [rbx+rdx*1-0xa0]
  215a79:	ff ff 
  215a7b:	c5 fc 10 5c 13 80    	vmovups ymm3,YMMWORD PTR [rbx+rdx*1-0x80]
        dest[i] = s;
  215a81:	c4 c1 7c 11 84 12 01 	vmovups YMMWORD PTR [r10+rdx*1+0x101],ymm0
  215a88:	01 00 00 
  215a8b:	c4 c1 7c 11 8c 12 21 	vmovups YMMWORD PTR [r10+rdx*1+0x121],ymm1
  215a92:	01 00 00 
  215a95:	c4 c1 7c 11 94 12 41 	vmovups YMMWORD PTR [r10+rdx*1+0x141],ymm2
  215a9c:	01 00 00 
  215a9f:	c4 c1 7c 11 9c 12 61 	vmovups YMMWORD PTR [r10+rdx*1+0x161],ymm3
  215aa6:	01 00 00 
    for (source) |s, i|
  215aa9:	c5 fd 10 44 13 a0    	vmovupd ymm0,YMMWORD PTR [rbx+rdx*1-0x60]
  215aaf:	c5 fc 10 4c 13 c0    	vmovups ymm1,YMMWORD PTR [rbx+rdx*1-0x40]
  215ab5:	c5 fd 10 54 13 e0    	vmovupd ymm2,YMMWORD PTR [rbx+rdx*1-0x20]
  215abb:	c5 fd 10 1c 13       	vmovupd ymm3,YMMWORD PTR [rbx+rdx*1]
        dest[i] = s;
  215ac0:	c4 c1 7d 11 84 12 81 	vmovupd YMMWORD PTR [r10+rdx*1+0x181],ymm0
  215ac7:	01 00 00 
  215aca:	c4 c1 7c 11 8c 12 a1 	vmovups YMMWORD PTR [r10+rdx*1+0x1a1],ymm1
  215ad1:	01 00 00 
  215ad4:	c4 c1 7d 11 94 12 c1 	vmovupd YMMWORD PTR [r10+rdx*1+0x1c1],ymm2
  215adb:	01 00 00 
  215ade:	c4 c1 7d 11 9c 12 e1 	vmovupd YMMWORD PTR [r10+rdx*1+0x1e1],ymm3
  215ae5:	01 00 00 
  215ae8:	48 81 c2 00 02 00 00 	add    rdx,0x200
  215aef:	48 83 c1 04          	add    rcx,0x4
  215af3:	0f 85 db fe ff ff    	jne    2159d4 <Benchmark_report+0x1f74>
  215af9:	48 85 ed             	test   rbp,rbp
  215afc:	74 46                	je     215b44 <Benchmark_report+0x20e4>
  215afe:	48 f7 dd             	neg    rbp
  215b01:	48 89 d1             	mov    rcx,rdx
  215b04:	48 83 c9 01          	or     rcx,0x1
    for (source) |s, i|
  215b08:	c5 fd 10 04 0e       	vmovupd ymm0,YMMWORD PTR [rsi+rcx*1]
  215b0d:	c5 fc 10 4c 0e 20    	vmovups ymm1,YMMWORD PTR [rsi+rcx*1+0x20]
  215b13:	c5 fd 10 54 0e 40    	vmovupd ymm2,YMMWORD PTR [rsi+rcx*1+0x40]
  215b19:	c5 fd 10 5c 0e 60    	vmovupd ymm3,YMMWORD PTR [rsi+rcx*1+0x60]
        dest[i] = s;
  215b1f:	c4 c1 7d 11 04 0a    	vmovupd YMMWORD PTR [r10+rcx*1],ymm0
  215b25:	c4 c1 7c 11 4c 0a 20 	vmovups YMMWORD PTR [r10+rcx*1+0x20],ymm1
  215b2c:	c4 c1 7d 11 54 0a 40 	vmovupd YMMWORD PTR [r10+rcx*1+0x40],ymm2
  215b33:	c4 c1 7d 11 5c 0a 60 	vmovupd YMMWORD PTR [r10+rcx*1+0x60],ymm3
  215b3a:	48 83 ea 80          	sub    rdx,0xffffffffffffff80
  215b3e:	48 83 c5 01          	add    rbp,0x1
  215b42:	75 bd                	jne    215b01 <Benchmark_report+0x20a1>
    context.remaining = context.remaining[bytes.len..];
  215b44:	4c 89 e1             	mov    rcx,r12
  215b47:	4d 39 fe             	cmp    r14,r15
    for (source) |s, i|
  215b4a:	0f 84 2a f8 ff ff    	je     21537a <Benchmark_report+0x191a>
  215b50:	49 83 cf 01          	or     r15,0x1
  215b54:	e9 e1 f7 ff ff       	jmp    21533a <Benchmark_report+0x18da>
  215b59:	48 83 c8 01          	or     rax,0x1
  215b5d:	e9 d3 f6 ff ff       	jmp    215235 <Benchmark_report+0x17d5>
  215b62:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  215b69:	1f 84 00 00 00 00 00 

0000000000215b70 <warn.36>:
pub fn warn(comptime fmt: []const u8, args: ...) void {
  215b70:	55                   	push   rbp
  215b71:	41 57                	push   r15
  215b73:	41 56                	push   r14
  215b75:	41 55                	push   r13
  215b77:	41 54                	push   r12
  215b79:	53                   	push   rbx
  215b7a:	48 83 ec 58          	sub    rsp,0x58
  215b7e:	48 89 d3             	mov    rbx,rdx
  215b81:	49 89 f4             	mov    r12,rsi
  215b84:	49 89 fe             	mov    r14,rdi
  215b87:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  215b8e:	00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  215b90:	b0 01                	mov    al,0x1
  215b92:	86 05 78 a4 03 00    	xchg   BYTE PTR [rip+0x3a478],al        # 250010 <stderr_mutex>
  215b98:	84 c0                	test   al,al
  215b9a:	75 f4                	jne    215b90 <warn.36+0x20>
    if (stderr_stream) |st| {
  215b9c:	4c 8b 3d 65 a4 03 00 	mov    r15,QWORD PTR [rip+0x3a465]        # 250008 <stderr_stream>
  215ba3:	4d 85 ff             	test   r15,r15
  215ba6:	74 09                	je     215bb1 <warn.36+0x41>
  215ba8:	4c 8b 2d 91 54 03 00 	mov    r13,QWORD PTR [rip+0x35491]        # 24b040 <stderr_file_out_stream+0x8>
  215baf:	eb 34                	jmp    215be5 <warn.36+0x75>
        stderr_file = try io.getStdErr();
  215bb1:	48 8d 05 78 54 03 00 	lea    rax,[rip+0x35478]        # 24b030 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  215bb8:	48 89 05 79 54 03 00 	mov    QWORD PTR [rip+0x35479],rax        # 24b038 <stderr_file_out_stream>
  215bbf:	4c 8d 2d 1a 9e 00 00 	lea    r13,[rip+0x9e1a]        # 21f9e0 <FileOutStream_writeFn>
  215bc6:	4c 89 2d 73 54 03 00 	mov    QWORD PTR [rip+0x35473],r13        # 24b040 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  215bcd:	c7 05 59 54 03 00 02 	mov    DWORD PTR [rip+0x35459],0x2        # 24b030 <stderr_file>
  215bd4:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  215bd7:	4c 8d 3d 62 54 03 00 	lea    r15,[rip+0x35462]        # 24b040 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  215bde:	4c 89 3d 23 a4 03 00 	mov    QWORD PTR [rip+0x3a423],r15        # 250008 <stderr_stream>
                        try output(context, fmt[start_index..i]);
  215be5:	48 8d 35 4c 91 03 00 	lea    rsi,[rip+0x3914c]        # 24ed38 <__unnamed_45>
  215bec:	4c 89 ff             	mov    rdi,r15
  215bef:	41 ff d5             	call   r13
  215bf2:	66 85 c0             	test   ax,ax
  215bf5:	0f 85 b2 02 00 00    	jne    215ead <warn.36+0x33d>
    var buf: [max_int_digits - 1]u8 = undefined;
  215bfb:	c5 fc 10 05 4c 30 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffff304c]        # 208c4f <__unnamed_20+0x1f>
  215c02:	ff 
  215c03:	c5 fc 11 44 24 2f    	vmovups YMMWORD PTR [rsp+0x2f],ymm0
  215c09:	c5 fc 10 05 1f 30 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffff301f]        # 208c30 <__unnamed_20>
  215c10:	ff 
  215c11:	c5 fc 11 44 24 10    	vmovups YMMWORD PTR [rsp+0x10],ymm0
        const digit = a % base;
  215c17:	48 bd cd cc cc cc cc 	movabs rbp,0xcccccccccccccccd
  215c1e:	cc cc cc 
  215c21:	4c 89 f2             	mov    rdx,r14
  215c24:	c4 e2 fb f6 cd       	mulx   rcx,rax,rbp
  215c29:	c1 e9 02             	shr    ecx,0x2
  215c2c:	81 e1 fe ff ff 3f    	and    ecx,0x3ffffffe
  215c32:	8d 0c 89             	lea    ecx,[rcx+rcx*4]
  215c35:	44 89 f0             	mov    eax,r14d
  215c38:	29 c8                	sub    eax,ecx
        0...9 => digit + '0',
  215c3a:	b1 30                	mov    cl,0x30
  215c3c:	3c 0a                	cmp    al,0xa
  215c3e:	72 02                	jb     215c42 <warn.36+0xd2>
  215c40:	b1 57                	mov    cl,0x57
  215c42:	48 8d 54 24 4f       	lea    rdx,[rsp+0x4f]
  215c47:	00 c1                	add    cl,al
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  215c49:	88 4c 24 4f          	mov    BYTE PTR [rsp+0x4f],cl
        if (a == 0) break;
  215c4d:	49 83 fe 0a          	cmp    r14,0xa
  215c51:	73 0a                	jae    215c5d <warn.36+0xed>
  215c53:	b8 40 00 00 00       	mov    eax,0x40
  215c58:	48 89 d1             	mov    rcx,rdx
  215c5b:	eb 5b                	jmp    215cb8 <warn.36+0x148>
  215c5d:	48 89 df             	mov    rdi,rbx
  215c60:	b8 40 00 00 00       	mov    eax,0x40
  215c65:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  215c6c:	00 00 00 00 
        a /= base;
  215c70:	4c 89 f2             	mov    rdx,r14
  215c73:	c4 e2 f3 f6 d5       	mulx   rdx,rcx,rbp
  215c78:	48 c1 ea 03          	shr    rdx,0x3
        const digit = a % base;
  215c7c:	c4 e2 f3 f6 f5       	mulx   rsi,rcx,rbp
  215c81:	c1 ee 02             	shr    esi,0x2
  215c84:	81 e6 fe ff ff 3f    	and    esi,0x3ffffffe
  215c8a:	8d 34 b6             	lea    esi,[rsi+rsi*4]
  215c8d:	89 d1                	mov    ecx,edx
  215c8f:	29 f1                	sub    ecx,esi
        0...9 => digit + '0',
  215c91:	b3 30                	mov    bl,0x30
  215c93:	80 f9 0a             	cmp    cl,0xa
  215c96:	72 02                	jb     215c9a <warn.36+0x12a>
  215c98:	b3 57                	mov    bl,0x57
  215c9a:	00 cb                	add    bl,cl
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  215c9c:	88 5c 04 0e          	mov    BYTE PTR [rsp+rax*1+0xe],bl
        if (a == 0) break;
  215ca0:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  215ca4:	49 83 fe 63          	cmp    r14,0x63
  215ca8:	49 89 d6             	mov    r14,rdx
  215cab:	77 c3                	ja     215c70 <warn.36+0x100>
        const padded_buf = buf[index - padding ..];
  215cad:	48 8d 0c 04          	lea    rcx,[rsp+rax*1]
  215cb1:	48 83 c1 0f          	add    rcx,0xf
  215cb5:	48 89 fb             	mov    rbx,rdi
  215cb8:	ba 41 00 00 00       	mov    edx,0x41
  215cbd:	48 29 c2             	sub    rdx,rax
  215cc0:	48 89 0c 24          	mov    QWORD PTR [rsp],rcx
  215cc4:	48 89 54 24 08       	mov    QWORD PTR [rsp+0x8],rdx
  215cc9:	48 89 e6             	mov    rsi,rsp
        return output(context, padded_buf);
  215ccc:	4c 89 ff             	mov    rdi,r15
  215ccf:	c5 f8 77             	vzeroupper 
  215cd2:	41 ff d5             	call   r13
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  215cd5:	66 85 c0             	test   ax,ax
  215cd8:	0f 85 cf 01 00 00    	jne    215ead <warn.36+0x33d>
                        try output(context, fmt[start_index..i]);
  215cde:	48 8d 35 63 90 03 00 	lea    rsi,[rip+0x39063]        # 24ed48 <__unnamed_46>
  215ce5:	4c 89 ff             	mov    rdi,r15
  215ce8:	41 ff d5             	call   r13
  215ceb:	66 85 c0             	test   ax,ax
  215cee:	0f 85 b9 01 00 00    	jne    215ead <warn.36+0x33d>
    var buf: [max_int_digits - 1]u8 = undefined;
  215cf4:	c5 fc 10 05 53 2f ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffff2f53]        # 208c4f <__unnamed_20+0x1f>
  215cfb:	ff 
  215cfc:	c5 fc 11 44 24 2f    	vmovups YMMWORD PTR [rsp+0x2f],ymm0
  215d02:	c5 fc 10 05 26 2f ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffff2f26]        # 208c30 <__unnamed_20>
  215d09:	ff 
  215d0a:	c5 fc 11 44 24 10    	vmovups YMMWORD PTR [rsp+0x10],ymm0
        const digit = a % base;
  215d10:	4c 89 e2             	mov    rdx,r12
  215d13:	c4 e2 fb f6 cd       	mulx   rcx,rax,rbp
  215d18:	c1 e9 02             	shr    ecx,0x2
  215d1b:	81 e1 fe ff ff 3f    	and    ecx,0x3ffffffe
  215d21:	8d 0c 89             	lea    ecx,[rcx+rcx*4]
  215d24:	44 89 e0             	mov    eax,r12d
  215d27:	29 c8                	sub    eax,ecx
        0...9 => digit + '0',
  215d29:	b1 30                	mov    cl,0x30
  215d2b:	3c 0a                	cmp    al,0xa
  215d2d:	72 02                	jb     215d31 <warn.36+0x1c1>
  215d2f:	b1 57                	mov    cl,0x57
  215d31:	00 c1                	add    cl,al
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  215d33:	88 4c 24 4f          	mov    BYTE PTR [rsp+0x4f],cl
        if (a == 0) break;
  215d37:	49 83 fc 0a          	cmp    r12,0xa
  215d3b:	73 0c                	jae    215d49 <warn.36+0x1d9>
  215d3d:	b8 40 00 00 00       	mov    eax,0x40
  215d42:	48 8d 4c 24 4f       	lea    rcx,[rsp+0x4f]
  215d47:	eb 5f                	jmp    215da8 <warn.36+0x238>
  215d49:	48 89 df             	mov    rdi,rbx
  215d4c:	b8 40 00 00 00       	mov    eax,0x40
  215d51:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  215d58:	0f 1f 84 00 00 00 00 
  215d5f:	00 
        a /= base;
  215d60:	4c 89 e2             	mov    rdx,r12
  215d63:	c4 e2 f3 f6 d5       	mulx   rdx,rcx,rbp
  215d68:	48 c1 ea 03          	shr    rdx,0x3
        const digit = a % base;
  215d6c:	c4 e2 f3 f6 f5       	mulx   rsi,rcx,rbp
  215d71:	c1 ee 02             	shr    esi,0x2
  215d74:	81 e6 fe ff ff 3f    	and    esi,0x3ffffffe
  215d7a:	8d 34 b6             	lea    esi,[rsi+rsi*4]
  215d7d:	89 d1                	mov    ecx,edx
  215d7f:	29 f1                	sub    ecx,esi
        0...9 => digit + '0',
  215d81:	b3 30                	mov    bl,0x30
  215d83:	80 f9 0a             	cmp    cl,0xa
  215d86:	72 02                	jb     215d8a <warn.36+0x21a>
  215d88:	b3 57                	mov    bl,0x57
  215d8a:	00 cb                	add    bl,cl
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  215d8c:	88 5c 04 0e          	mov    BYTE PTR [rsp+rax*1+0xe],bl
        if (a == 0) break;
  215d90:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  215d94:	49 83 fc 63          	cmp    r12,0x63
  215d98:	49 89 d4             	mov    r12,rdx
  215d9b:	77 c3                	ja     215d60 <warn.36+0x1f0>
        const padded_buf = buf[index - padding ..];
  215d9d:	48 8d 0c 04          	lea    rcx,[rsp+rax*1]
  215da1:	48 83 c1 0f          	add    rcx,0xf
  215da5:	48 89 fb             	mov    rbx,rdi
  215da8:	ba 41 00 00 00       	mov    edx,0x41
  215dad:	48 29 c2             	sub    rdx,rax
  215db0:	48 89 0c 24          	mov    QWORD PTR [rsp],rcx
  215db4:	48 89 54 24 08       	mov    QWORD PTR [rsp+0x8],rdx
  215db9:	48 89 e6             	mov    rsi,rsp
        return output(context, padded_buf);
  215dbc:	4c 89 ff             	mov    rdi,r15
  215dbf:	c5 f8 77             	vzeroupper 
  215dc2:	41 ff d5             	call   r13
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  215dc5:	66 85 c0             	test   ax,ax
  215dc8:	0f 85 df 00 00 00    	jne    215ead <warn.36+0x33d>
                        try output(context, fmt[start_index..i]);
  215dce:	48 8d 35 83 8f 03 00 	lea    rsi,[rip+0x38f83]        # 24ed58 <__unnamed_47>
  215dd5:	4c 89 ff             	mov    rdi,r15
  215dd8:	41 ff d5             	call   r13
  215ddb:	66 85 c0             	test   ax,ax
  215dde:	0f 85 c9 00 00 00    	jne    215ead <warn.36+0x33d>
    var buf: [max_int_digits - 1]u8 = undefined;
  215de4:	c5 fc 10 05 63 2e ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffff2e63]        # 208c4f <__unnamed_20+0x1f>
  215deb:	ff 
  215dec:	c5 fc 11 44 24 2f    	vmovups YMMWORD PTR [rsp+0x2f],ymm0
  215df2:	c5 fc 10 05 36 2e ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffff2e36]        # 208c30 <__unnamed_20>
  215df9:	ff 
  215dfa:	c5 fc 11 44 24 10    	vmovups YMMWORD PTR [rsp+0x10],ymm0
        const digit = a % base;
  215e00:	48 89 da             	mov    rdx,rbx
  215e03:	c4 e2 fb f6 cd       	mulx   rcx,rax,rbp
  215e08:	c1 e9 02             	shr    ecx,0x2
  215e0b:	81 e1 fe ff ff 3f    	and    ecx,0x3ffffffe
  215e11:	8d 0c 89             	lea    ecx,[rcx+rcx*4]
  215e14:	89 d8                	mov    eax,ebx
  215e16:	29 c8                	sub    eax,ecx
        0...9 => digit + '0',
  215e18:	b1 30                	mov    cl,0x30
  215e1a:	3c 0a                	cmp    al,0xa
  215e1c:	72 02                	jb     215e20 <warn.36+0x2b0>
  215e1e:	b1 57                	mov    cl,0x57
  215e20:	00 c1                	add    cl,al
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  215e22:	88 4c 24 4f          	mov    BYTE PTR [rsp+0x4f],cl
        if (a == 0) break;
  215e26:	48 83 fb 0a          	cmp    rbx,0xa
  215e2a:	48 8d 54 24 4f       	lea    rdx,[rsp+0x4f]
  215e2f:	b8 40 00 00 00       	mov    eax,0x40
  215e34:	72 48                	jb     215e7e <warn.36+0x30e>
  215e36:	48 89 df             	mov    rdi,rbx
        a /= base;
  215e39:	48 89 da             	mov    rdx,rbx
  215e3c:	c4 e2 f3 f6 d5       	mulx   rdx,rcx,rbp
  215e41:	48 c1 ea 03          	shr    rdx,0x3
        const digit = a % base;
  215e45:	c4 e2 f3 f6 f5       	mulx   rsi,rcx,rbp
  215e4a:	c1 ee 02             	shr    esi,0x2
  215e4d:	81 e6 fe ff ff 3f    	and    esi,0x3ffffffe
  215e53:	8d 34 b6             	lea    esi,[rsi+rsi*4]
  215e56:	89 d1                	mov    ecx,edx
  215e58:	29 f1                	sub    ecx,esi
        0...9 => digit + '0',
  215e5a:	b3 30                	mov    bl,0x30
  215e5c:	80 f9 0a             	cmp    cl,0xa
  215e5f:	72 02                	jb     215e63 <warn.36+0x2f3>
  215e61:	b3 57                	mov    bl,0x57
  215e63:	00 cb                	add    bl,cl
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  215e65:	88 5c 04 0e          	mov    BYTE PTR [rsp+rax*1+0xe],bl
        if (a == 0) break;
  215e69:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  215e6d:	48 83 ff 63          	cmp    rdi,0x63
  215e71:	48 89 d3             	mov    rbx,rdx
  215e74:	77 c0                	ja     215e36 <warn.36+0x2c6>
        const padded_buf = buf[index - padding ..];
  215e76:	48 8d 14 04          	lea    rdx,[rsp+rax*1]
  215e7a:	48 83 c2 0f          	add    rdx,0xf
  215e7e:	b9 41 00 00 00       	mov    ecx,0x41
  215e83:	48 29 c1             	sub    rcx,rax
  215e86:	48 89 14 24          	mov    QWORD PTR [rsp],rdx
  215e8a:	48 89 4c 24 08       	mov    QWORD PTR [rsp+0x8],rcx
  215e8f:	48 89 e6             	mov    rsi,rsp
        return output(context, padded_buf);
  215e92:	4c 89 ff             	mov    rdi,r15
  215e95:	c5 f8 77             	vzeroupper 
  215e98:	41 ff d5             	call   r13
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  215e9b:	66 85 c0             	test   ax,ax
  215e9e:	75 0d                	jne    215ead <warn.36+0x33d>
        try output(context, fmt[start_index..]);
  215ea0:	48 8d 35 c1 8e 03 00 	lea    rsi,[rip+0x38ec1]        # 24ed68 <__unnamed_48>
  215ea7:	4c 89 ff             	mov    rdi,r15
  215eaa:	41 ff d5             	call   r13
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  215ead:	31 c0                	xor    eax,eax
  215eaf:	86 05 5b a1 03 00    	xchg   BYTE PTR [rip+0x3a15b],al        # 250010 <stderr_mutex>
  215eb5:	3c 01                	cmp    al,0x1
    if (!ok) {
  215eb7:	75 0f                	jne    215ec8 <warn.36+0x358>
pub fn warn(comptime fmt: []const u8, args: ...) void {
  215eb9:	48 83 c4 58          	add    rsp,0x58
  215ebd:	5b                   	pop    rbx
  215ebe:	41 5c                	pop    r12
  215ec0:	41 5d                	pop    r13
  215ec2:	41 5e                	pop    r14
  215ec4:	41 5f                	pop    r15
  215ec6:	5d                   	pop    rbp
  215ec7:	c3                   	ret    
            @panic("assertion failure");
  215ec8:	48 8d 3d 39 8e 03 00 	lea    rdi,[rip+0x38e39]        # 24ed08 <__unnamed_2>
  215ecf:	e8 4c c1 ff ff       	call   212020 <panic>
  215ed4:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  215edb:	00 00 00 00 00 

0000000000215ee0 <Benchmark_leftJustified>:
        var buffer: [40]u8 = undefined;
  215ee0:	55                   	push   rbp
  215ee1:	41 57                	push   r15
  215ee3:	41 56                	push   r14
  215ee5:	41 55                	push   r13
  215ee7:	41 54                	push   r12
  215ee9:	53                   	push   rbx
  215eea:	48 81 ec 88 00 00 00 	sub    rsp,0x88
  215ef1:	c5 fc 10 05 a2 f6 fe 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffef6a2]        # 20559b <__unnamed_7>
  215ef8:	ff 
  215ef9:	c5 fc 11 44 24 10    	vmovups YMMWORD PTR [rsp+0x10],ymm0
  215eff:	48 8b 05 b5 f6 fe ff 	mov    rax,QWORD PTR [rip+0xfffffffffffef6b5]        # 2055bb <__unnamed_7+0x20>
  215f06:	48 89 44 24 30       	mov    QWORD PTR [rsp+0x30],rax
        dest[i] = s;
  215f0b:	c5 f8 28 05 4d 37 ff 	vmovaps xmm0,XMMWORD PTR [rip+0xffffffffffff374d]        # 209660 <__unnamed_67+0x10>
  215f12:	ff 
  215f13:	c5 f8 29 44 24 10    	vmovaps XMMWORD PTR [rsp+0x10],xmm0
  215f19:	c6 44 24 20 3a       	mov    BYTE PTR [rsp+0x20],0x3a
  215f1e:	48 89 f8             	mov    rax,rdi
    var buf: [max_int_digits - 1]u8 = undefined;
  215f21:	c5 fc 10 05 26 2d ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffff2d26]        # 208c4f <__unnamed_20+0x1f>
  215f28:	ff 
  215f29:	c5 fc 11 44 24 5f    	vmovups YMMWORD PTR [rsp+0x5f],ymm0
  215f2f:	c5 fc 10 05 f9 2c ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffff2cf9]        # 208c30 <__unnamed_20>
  215f36:	ff 
  215f37:	c5 fc 11 44 24 40    	vmovups YMMWORD PTR [rsp+0x40],ymm0
        const digit = a % base;
  215f3d:	48 be cd cc cc cc cc 	movabs rsi,0xcccccccccccccccd
  215f44:	cc cc cc 
  215f47:	48 89 c2             	mov    rdx,rax
  215f4a:	c4 e2 f3 f6 d6       	mulx   rdx,rcx,rsi
  215f4f:	c1 ea 02             	shr    edx,0x2
  215f52:	81 e2 fe ff ff 3f    	and    edx,0x3ffffffe
  215f58:	8d 0c 92             	lea    ecx,[rdx+rdx*4]
  215f5b:	89 c2                	mov    edx,eax
  215f5d:	29 ca                	sub    edx,ecx
        0...9 => digit + '0',
  215f5f:	b1 30                	mov    cl,0x30
  215f61:	80 fa 0a             	cmp    dl,0xa
  215f64:	72 02                	jb     215f68 <Benchmark_leftJustified+0x88>
  215f66:	b1 57                	mov    cl,0x57
  215f68:	00 d1                	add    cl,dl
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  215f6a:	88 4c 24 7f          	mov    BYTE PTR [rsp+0x7f],cl
  215f6e:	bb 40 00 00 00       	mov    ebx,0x40
        if (a == 0) break;
  215f73:	48 83 f8 0a          	cmp    rax,0xa
  215f77:	72 46                	jb     215fbf <Benchmark_leftJustified+0xdf>
  215f79:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
        a /= base;
  215f80:	48 89 c2             	mov    rdx,rax
  215f83:	c4 e2 f3 f6 d6       	mulx   rdx,rcx,rsi
  215f88:	48 c1 ea 03          	shr    rdx,0x3
        const digit = a % base;
  215f8c:	c4 e2 f3 f6 fe       	mulx   rdi,rcx,rsi
  215f91:	c1 ef 02             	shr    edi,0x2
  215f94:	81 e7 fe ff ff 3f    	and    edi,0x3ffffffe
  215f9a:	8d 0c bf             	lea    ecx,[rdi+rdi*4]
  215f9d:	89 d7                	mov    edi,edx
  215f9f:	29 cf                	sub    edi,ecx
        0...9 => digit + '0',
  215fa1:	b1 30                	mov    cl,0x30
  215fa3:	40 80 ff 0a          	cmp    dil,0xa
  215fa7:	72 02                	jb     215fab <Benchmark_leftJustified+0xcb>
  215fa9:	b1 57                	mov    cl,0x57
  215fab:	40 00 f9             	add    cl,dil
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  215fae:	88 4c 1c 3e          	mov    BYTE PTR [rsp+rbx*1+0x3e],cl
        if (a == 0) break;
  215fb2:	48 83 c3 ff          	add    rbx,0xffffffffffffffff
  215fb6:	48 83 f8 63          	cmp    rax,0x63
  215fba:	48 89 d0             	mov    rax,rdx
  215fbd:	77 c1                	ja     215f80 <Benchmark_leftJustified+0xa0>
        const padded_buf = buf[index - padding ..];
  215fbf:	41 be 41 00 00 00    	mov    r14d,0x41
  215fc5:	49 29 de             	sub    r14,rbx
    if (context.remaining.len < bytes.len) return error.BufferTooSmall;
  215fc8:	49 83 fe 17          	cmp    r14,0x17
  215fcc:	76 09                	jbe    215fd7 <Benchmark_leftJustified+0xf7>
  215fce:	66 b8 05 00          	mov    ax,0x5
  215fd2:	e9 85 01 00 00       	jmp    21615c <Benchmark_leftJustified+0x27c>
    for (source) |s, i|
  215fd7:	4d 85 f6             	test   r14,r14
  215fda:	74 12                	je     215fee <Benchmark_leftJustified+0x10e>
        dest[i] = s;
  215fdc:	88 4c 24 21          	mov    BYTE PTR [rsp+0x21],cl
    for (source) |s, i|
  215fe0:	49 83 fe 01          	cmp    r14,0x1
  215fe4:	75 10                	jne    215ff6 <Benchmark_leftJustified+0x116>
  215fe6:	41 be 12 00 00 00    	mov    r14d,0x12
  215fec:	eb 32                	jmp    216020 <Benchmark_leftJustified+0x140>
  215fee:	41 be 11 00 00 00    	mov    r14d,0x11
  215ff4:	eb 2a                	jmp    216020 <Benchmark_leftJustified+0x140>
  215ff6:	48 8d 7c 24 22       	lea    rdi,[rsp+0x22]
  215ffb:	48 8d 34 1c          	lea    rsi,[rsp+rbx*1]
  215fff:	48 83 c6 40          	add    rsi,0x40
  216003:	ba 40 00 00 00       	mov    edx,0x40
  216008:	48 29 da             	sub    rdx,rbx
        dest[i] = s;
  21600b:	c5 f8 77             	vzeroupper 
  21600e:	e8 0d 85 01 00       	call   22e520 <memcpy>
        return output(context, padded_buf);
  216013:	49 83 c6 11          	add    r14,0x11
  216017:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  21601e:	00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  216020:	b0 01                	mov    al,0x1
  216022:	86 05 e8 9f 03 00    	xchg   BYTE PTR [rip+0x39fe8],al        # 250010 <stderr_mutex>
  216028:	84 c0                	test   al,al
  21602a:	75 f4                	jne    216020 <Benchmark_leftJustified+0x140>
    if (stderr_stream) |st| {
  21602c:	48 8b 3d d5 9f 03 00 	mov    rdi,QWORD PTR [rip+0x39fd5]        # 250008 <stderr_stream>
  216033:	48 85 ff             	test   rdi,rdi
  216036:	74 09                	je     216041 <Benchmark_leftJustified+0x161>
  216038:	48 8b 0d 01 50 03 00 	mov    rcx,QWORD PTR [rip+0x35001]        # 24b040 <stderr_file_out_stream+0x8>
  21603f:	eb 34                	jmp    216075 <Benchmark_leftJustified+0x195>
        stderr_file = try io.getStdErr();
  216041:	48 8d 05 e8 4f 03 00 	lea    rax,[rip+0x34fe8]        # 24b030 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  216048:	48 89 05 e9 4f 03 00 	mov    QWORD PTR [rip+0x34fe9],rax        # 24b038 <stderr_file_out_stream>
  21604f:	48 8d 0d 8a 99 00 00 	lea    rcx,[rip+0x998a]        # 21f9e0 <FileOutStream_writeFn>
  216056:	48 89 0d e3 4f 03 00 	mov    QWORD PTR [rip+0x34fe3],rcx        # 24b040 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  21605d:	c7 05 c9 4f 03 00 02 	mov    DWORD PTR [rip+0x34fc9],0x2        # 24b030 <stderr_file>
  216064:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  216067:	48 8d 3d d2 4f 03 00 	lea    rdi,[rip+0x34fd2]        # 24b040 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  21606e:	48 89 3d 93 9f 03 00 	mov    QWORD PTR [rip+0x39f93],rdi        # 250008 <stderr_stream>
  216075:	48 8d 44 24 10       	lea    rax,[rsp+0x10]
                const casted_value = ([]const u8)(value);
  21607a:	48 89 44 24 40       	mov    QWORD PTR [rsp+0x40],rax
  21607f:	4c 89 74 24 48       	mov    QWORD PTR [rsp+0x48],r14
  216084:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
                return output(context, casted_value);
  216089:	c5 f8 77             	vzeroupper 
  21608c:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  21608e:	31 c0                	xor    eax,eax
  216090:	86 05 7a 9f 03 00    	xchg   BYTE PTR [rip+0x39f7a],al        # 250010 <stderr_mutex>
  216096:	3c 01                	cmp    al,0x1
    if (!ok) {
  216098:	0f 85 d3 00 00 00    	jne    216171 <Benchmark_leftJustified+0x291>
        if (width > str.len) {
  21609e:	49 83 fe 15          	cmp    r14,0x15
  2160a2:	0f 87 b2 00 00 00    	ja     21615a <Benchmark_leftJustified+0x27a>
            pad(width - str.len, ' ');
  2160a8:	41 bf 16 00 00 00    	mov    r15d,0x16
        while (i < count) : (i += 1) {
  2160ae:	4d 29 f7             	sub    r15,r14
  2160b1:	0f 84 a3 00 00 00    	je     21615a <Benchmark_leftJustified+0x27a>
  2160b7:	31 db                	xor    ebx,ebx
  2160b9:	4c 8d 2d 20 99 00 00 	lea    r13,[rip+0x9920]        # 21f9e0 <FileOutStream_writeFn>
  2160c0:	48 8d 2d 79 4f 03 00 	lea    rbp,[rip+0x34f79]        # 24b040 <stderr_file_out_stream+0x8>
  2160c7:	4c 8d 64 24 0f       	lea    r12,[rsp+0xf]
  2160cc:	4c 8d 74 24 40       	lea    r14,[rsp+0x40]
  2160d1:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  2160d8:	0f 1f 84 00 00 00 00 
  2160df:	00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  2160e0:	b0 01                	mov    al,0x1
  2160e2:	86 05 28 9f 03 00    	xchg   BYTE PTR [rip+0x39f28],al        # 250010 <stderr_mutex>
  2160e8:	84 c0                	test   al,al
  2160ea:	75 f4                	jne    2160e0 <Benchmark_leftJustified+0x200>
    if (stderr_stream) |st| {
  2160ec:	48 8b 3d 15 9f 03 00 	mov    rdi,QWORD PTR [rip+0x39f15]        # 250008 <stderr_stream>
  2160f3:	48 85 ff             	test   rdi,rdi
  2160f6:	74 09                	je     216101 <Benchmark_leftJustified+0x221>
  2160f8:	48 8b 0d 41 4f 03 00 	mov    rcx,QWORD PTR [rip+0x34f41]        # 24b040 <stderr_file_out_stream+0x8>
  2160ff:	eb 2c                	jmp    21612d <Benchmark_leftJustified+0x24d>
        stderr_file = try io.getStdErr();
  216101:	c7 05 25 4f 03 00 02 	mov    DWORD PTR [rip+0x34f25],0x2        # 24b030 <stderr_file>
  216108:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  21610b:	48 8d 05 1e 4f 03 00 	lea    rax,[rip+0x34f1e]        # 24b030 <stderr_file>
  216112:	48 89 05 1f 4f 03 00 	mov    QWORD PTR [rip+0x34f1f],rax        # 24b038 <stderr_file_out_stream>
  216119:	4c 89 2d 20 4f 03 00 	mov    QWORD PTR [rip+0x34f20],r13        # 24b040 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  216120:	48 89 2d e1 9e 03 00 	mov    QWORD PTR [rip+0x39ee1],rbp        # 250008 <stderr_stream>
  216127:	4c 89 e9             	mov    rcx,r13
  21612a:	48 89 ef             	mov    rdi,rbp
  21612d:	c6 44 24 0f 20       	mov    BYTE PTR [rsp+0xf],0x20
    return output(context, (*[1]u8)(&c)[0..]);
  216132:	4c 89 64 24 40       	mov    QWORD PTR [rsp+0x40],r12
  216137:	48 c7 44 24 48 01 00 	mov    QWORD PTR [rsp+0x48],0x1
  21613e:	00 00 
  216140:	4c 89 f6             	mov    rsi,r14
  216143:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  216145:	31 c0                	xor    eax,eax
  216147:	86 05 c3 9e 03 00    	xchg   BYTE PTR [rip+0x39ec3],al        # 250010 <stderr_mutex>
  21614d:	3c 01                	cmp    al,0x1
    if (!ok) {
  21614f:	75 20                	jne    216171 <Benchmark_leftJustified+0x291>
  216151:	48 83 c3 01          	add    rbx,0x1
  216155:	4c 39 fb             	cmp    rbx,r15
  216158:	72 86                	jb     2160e0 <Benchmark_leftJustified+0x200>
  21615a:	31 c0                	xor    eax,eax
        var str = try bufPrint(buffer[0..], fmt, args);
  21615c:	48 81 c4 88 00 00 00 	add    rsp,0x88
  216163:	5b                   	pop    rbx
  216164:	41 5c                	pop    r12
  216166:	41 5d                	pop    r13
  216168:	41 5e                	pop    r14
  21616a:	41 5f                	pop    r15
  21616c:	5d                   	pop    rbp
  21616d:	c5 f8 77             	vzeroupper 
  216170:	c3                   	ret    
            @panic("assertion failure");
  216171:	48 8d 3d 90 8b 03 00 	lea    rdi,[rip+0x38b90]        # 24ed08 <__unnamed_2>
  216178:	e8 a3 be ff ff       	call   212020 <panic>
  21617d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000216180 <Benchmark_rightJustified>:
        var buffer: [40]u8 = undefined;
  216180:	53                   	push   rbx
  216181:	48 83 ec 50          	sub    rsp,0x50
  216185:	c5 fc 10 05 0e f4 fe 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffef40e]        # 20559b <__unnamed_7>
  21618c:	ff 
  21618d:	c5 fc 11 44 24 20    	vmovups YMMWORD PTR [rsp+0x20],ymm0
  216193:	48 8b 05 21 f4 fe ff 	mov    rax,QWORD PTR [rip+0xfffffffffffef421]        # 2055bb <__unnamed_7+0x20>
  21619a:	48 89 44 24 40       	mov    QWORD PTR [rsp+0x40],rax
  21619f:	48 b8 69 74 65 72 61 	movabs rax,0x6f69746172657469
  2161a6:	74 69 6f 
  2161a9:	48 89 44 24 20       	mov    QWORD PTR [rsp+0x20],rax
  2161ae:	66 c7 44 24 28 6e 73 	mov    WORD PTR [rsp+0x28],0x736e
  2161b5:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  2161bc:	00 00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  2161c0:	b0 01                	mov    al,0x1
  2161c2:	86 05 48 9e 03 00    	xchg   BYTE PTR [rip+0x39e48],al        # 250010 <stderr_mutex>
  2161c8:	84 c0                	test   al,al
  2161ca:	75 f4                	jne    2161c0 <Benchmark_rightJustified+0x40>
    if (stderr_stream) |st| {
  2161cc:	48 8b 3d 35 9e 03 00 	mov    rdi,QWORD PTR [rip+0x39e35]        # 250008 <stderr_stream>
  2161d3:	48 85 ff             	test   rdi,rdi
  2161d6:	74 09                	je     2161e1 <Benchmark_rightJustified+0x61>
  2161d8:	48 8b 05 61 4e 03 00 	mov    rax,QWORD PTR [rip+0x34e61]        # 24b040 <stderr_file_out_stream+0x8>
  2161df:	eb 34                	jmp    216215 <Benchmark_rightJustified+0x95>
        stderr_file = try io.getStdErr();
  2161e1:	48 8d 05 48 4e 03 00 	lea    rax,[rip+0x34e48]        # 24b030 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  2161e8:	48 89 05 49 4e 03 00 	mov    QWORD PTR [rip+0x34e49],rax        # 24b038 <stderr_file_out_stream>
  2161ef:	48 8d 05 ea 97 00 00 	lea    rax,[rip+0x97ea]        # 21f9e0 <FileOutStream_writeFn>
  2161f6:	48 89 05 43 4e 03 00 	mov    QWORD PTR [rip+0x34e43],rax        # 24b040 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  2161fd:	c7 05 29 4e 03 00 02 	mov    DWORD PTR [rip+0x34e29],0x2        # 24b030 <stderr_file>
  216204:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  216207:	48 8d 3d 32 4e 03 00 	lea    rdi,[rip+0x34e32]        # 24b040 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  21620e:	48 89 3d f3 9d 03 00 	mov    QWORD PTR [rip+0x39df3],rdi        # 250008 <stderr_stream>
  216215:	c6 44 24 0f 20       	mov    BYTE PTR [rsp+0xf],0x20
  21621a:	48 8d 5c 24 0f       	lea    rbx,[rsp+0xf]
  21621f:	48 89 5c 24 10       	mov    QWORD PTR [rsp+0x10],rbx
  216224:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  21622b:	00 00 
  21622d:	48 8d 74 24 10       	lea    rsi,[rsp+0x10]
  216232:	c5 f8 77             	vzeroupper 
  216235:	ff d0                	call   rax
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  216237:	31 c0                	xor    eax,eax
  216239:	86 05 d1 9d 03 00    	xchg   BYTE PTR [rip+0x39dd1],al        # 250010 <stderr_mutex>
  21623f:	3c 01                	cmp    al,0x1
    if (!ok) {
  216241:	0f 85 0c 02 00 00    	jne    216453 <Benchmark_rightJustified+0x2d3>
  216247:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  21624e:	00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  216250:	b0 01                	mov    al,0x1
  216252:	86 05 b8 9d 03 00    	xchg   BYTE PTR [rip+0x39db8],al        # 250010 <stderr_mutex>
  216258:	84 c0                	test   al,al
  21625a:	75 f4                	jne    216250 <Benchmark_rightJustified+0xd0>
    if (stderr_stream) |st| {
  21625c:	48 8b 3d a5 9d 03 00 	mov    rdi,QWORD PTR [rip+0x39da5]        # 250008 <stderr_stream>
  216263:	48 85 ff             	test   rdi,rdi
  216266:	74 09                	je     216271 <Benchmark_rightJustified+0xf1>
  216268:	48 8b 0d d1 4d 03 00 	mov    rcx,QWORD PTR [rip+0x34dd1]        # 24b040 <stderr_file_out_stream+0x8>
  21626f:	eb 34                	jmp    2162a5 <Benchmark_rightJustified+0x125>
        stderr_file = try io.getStdErr();
  216271:	48 8d 05 b8 4d 03 00 	lea    rax,[rip+0x34db8]        # 24b030 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  216278:	48 89 05 b9 4d 03 00 	mov    QWORD PTR [rip+0x34db9],rax        # 24b038 <stderr_file_out_stream>
  21627f:	48 8d 0d 5a 97 00 00 	lea    rcx,[rip+0x975a]        # 21f9e0 <FileOutStream_writeFn>
  216286:	48 89 0d b3 4d 03 00 	mov    QWORD PTR [rip+0x34db3],rcx        # 24b040 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  21628d:	c7 05 99 4d 03 00 02 	mov    DWORD PTR [rip+0x34d99],0x2        # 24b030 <stderr_file>
  216294:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  216297:	48 8d 3d a2 4d 03 00 	lea    rdi,[rip+0x34da2]        # 24b040 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  21629e:	48 89 3d 63 9d 03 00 	mov    QWORD PTR [rip+0x39d63],rdi        # 250008 <stderr_stream>
  2162a5:	c6 44 24 0f 20       	mov    BYTE PTR [rsp+0xf],0x20
  2162aa:	48 89 5c 24 10       	mov    QWORD PTR [rsp+0x10],rbx
  2162af:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  2162b6:	00 00 
  2162b8:	48 8d 74 24 10       	lea    rsi,[rsp+0x10]
  2162bd:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  2162bf:	31 c0                	xor    eax,eax
  2162c1:	86 05 49 9d 03 00    	xchg   BYTE PTR [rip+0x39d49],al        # 250010 <stderr_mutex>
  2162c7:	3c 01                	cmp    al,0x1
    if (!ok) {
  2162c9:	0f 85 84 01 00 00    	jne    216453 <Benchmark_rightJustified+0x2d3>
  2162cf:	90                   	nop
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  2162d0:	b0 01                	mov    al,0x1
  2162d2:	86 05 38 9d 03 00    	xchg   BYTE PTR [rip+0x39d38],al        # 250010 <stderr_mutex>
  2162d8:	84 c0                	test   al,al
  2162da:	75 f4                	jne    2162d0 <Benchmark_rightJustified+0x150>
    if (stderr_stream) |st| {
  2162dc:	48 8b 3d 25 9d 03 00 	mov    rdi,QWORD PTR [rip+0x39d25]        # 250008 <stderr_stream>
  2162e3:	48 85 ff             	test   rdi,rdi
  2162e6:	74 09                	je     2162f1 <Benchmark_rightJustified+0x171>
  2162e8:	48 8b 0d 51 4d 03 00 	mov    rcx,QWORD PTR [rip+0x34d51]        # 24b040 <stderr_file_out_stream+0x8>
  2162ef:	eb 34                	jmp    216325 <Benchmark_rightJustified+0x1a5>
        stderr_file = try io.getStdErr();
  2162f1:	48 8d 05 38 4d 03 00 	lea    rax,[rip+0x34d38]        # 24b030 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  2162f8:	48 89 05 39 4d 03 00 	mov    QWORD PTR [rip+0x34d39],rax        # 24b038 <stderr_file_out_stream>
  2162ff:	48 8d 0d da 96 00 00 	lea    rcx,[rip+0x96da]        # 21f9e0 <FileOutStream_writeFn>
  216306:	48 89 0d 33 4d 03 00 	mov    QWORD PTR [rip+0x34d33],rcx        # 24b040 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  21630d:	c7 05 19 4d 03 00 02 	mov    DWORD PTR [rip+0x34d19],0x2        # 24b030 <stderr_file>
  216314:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  216317:	48 8d 3d 22 4d 03 00 	lea    rdi,[rip+0x34d22]        # 24b040 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  21631e:	48 89 3d e3 9c 03 00 	mov    QWORD PTR [rip+0x39ce3],rdi        # 250008 <stderr_stream>
  216325:	c6 44 24 0f 20       	mov    BYTE PTR [rsp+0xf],0x20
  21632a:	48 89 5c 24 10       	mov    QWORD PTR [rsp+0x10],rbx
  21632f:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  216336:	00 00 
  216338:	48 8d 74 24 10       	lea    rsi,[rsp+0x10]
  21633d:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  21633f:	31 c0                	xor    eax,eax
  216341:	86 05 c9 9c 03 00    	xchg   BYTE PTR [rip+0x39cc9],al        # 250010 <stderr_mutex>
  216347:	3c 01                	cmp    al,0x1
    if (!ok) {
  216349:	0f 85 04 01 00 00    	jne    216453 <Benchmark_rightJustified+0x2d3>
  21634f:	90                   	nop
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  216350:	b0 01                	mov    al,0x1
  216352:	86 05 b8 9c 03 00    	xchg   BYTE PTR [rip+0x39cb8],al        # 250010 <stderr_mutex>
  216358:	84 c0                	test   al,al
  21635a:	75 f4                	jne    216350 <Benchmark_rightJustified+0x1d0>
    if (stderr_stream) |st| {
  21635c:	48 8b 3d a5 9c 03 00 	mov    rdi,QWORD PTR [rip+0x39ca5]        # 250008 <stderr_stream>
  216363:	48 85 ff             	test   rdi,rdi
  216366:	74 09                	je     216371 <Benchmark_rightJustified+0x1f1>
  216368:	48 8b 0d d1 4c 03 00 	mov    rcx,QWORD PTR [rip+0x34cd1]        # 24b040 <stderr_file_out_stream+0x8>
  21636f:	eb 34                	jmp    2163a5 <Benchmark_rightJustified+0x225>
        stderr_file = try io.getStdErr();
  216371:	48 8d 05 b8 4c 03 00 	lea    rax,[rip+0x34cb8]        # 24b030 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  216378:	48 89 05 b9 4c 03 00 	mov    QWORD PTR [rip+0x34cb9],rax        # 24b038 <stderr_file_out_stream>
  21637f:	48 8d 0d 5a 96 00 00 	lea    rcx,[rip+0x965a]        # 21f9e0 <FileOutStream_writeFn>
  216386:	48 89 0d b3 4c 03 00 	mov    QWORD PTR [rip+0x34cb3],rcx        # 24b040 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  21638d:	c7 05 99 4c 03 00 02 	mov    DWORD PTR [rip+0x34c99],0x2        # 24b030 <stderr_file>
  216394:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  216397:	48 8d 3d a2 4c 03 00 	lea    rdi,[rip+0x34ca2]        # 24b040 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  21639e:	48 89 3d 63 9c 03 00 	mov    QWORD PTR [rip+0x39c63],rdi        # 250008 <stderr_stream>
  2163a5:	c6 44 24 0f 20       	mov    BYTE PTR [rsp+0xf],0x20
  2163aa:	48 89 5c 24 10       	mov    QWORD PTR [rsp+0x10],rbx
  2163af:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  2163b6:	00 00 
  2163b8:	48 8d 74 24 10       	lea    rsi,[rsp+0x10]
  2163bd:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  2163bf:	31 c0                	xor    eax,eax
  2163c1:	86 05 49 9c 03 00    	xchg   BYTE PTR [rip+0x39c49],al        # 250010 <stderr_mutex>
  2163c7:	3c 01                	cmp    al,0x1
    if (!ok) {
  2163c9:	0f 85 84 00 00 00    	jne    216453 <Benchmark_rightJustified+0x2d3>
  2163cf:	90                   	nop
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  2163d0:	b0 01                	mov    al,0x1
  2163d2:	86 05 38 9c 03 00    	xchg   BYTE PTR [rip+0x39c38],al        # 250010 <stderr_mutex>
  2163d8:	84 c0                	test   al,al
  2163da:	75 f4                	jne    2163d0 <Benchmark_rightJustified+0x250>
    if (stderr_stream) |st| {
  2163dc:	48 8b 3d 25 9c 03 00 	mov    rdi,QWORD PTR [rip+0x39c25]        # 250008 <stderr_stream>
  2163e3:	48 85 ff             	test   rdi,rdi
  2163e6:	74 09                	je     2163f1 <Benchmark_rightJustified+0x271>
  2163e8:	48 8b 0d 51 4c 03 00 	mov    rcx,QWORD PTR [rip+0x34c51]        # 24b040 <stderr_file_out_stream+0x8>
  2163ef:	eb 34                	jmp    216425 <Benchmark_rightJustified+0x2a5>
        stderr_file = try io.getStdErr();
  2163f1:	48 8d 05 38 4c 03 00 	lea    rax,[rip+0x34c38]        # 24b030 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  2163f8:	48 89 05 39 4c 03 00 	mov    QWORD PTR [rip+0x34c39],rax        # 24b038 <stderr_file_out_stream>
  2163ff:	48 8d 0d da 95 00 00 	lea    rcx,[rip+0x95da]        # 21f9e0 <FileOutStream_writeFn>
  216406:	48 89 0d 33 4c 03 00 	mov    QWORD PTR [rip+0x34c33],rcx        # 24b040 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  21640d:	c7 05 19 4c 03 00 02 	mov    DWORD PTR [rip+0x34c19],0x2        # 24b030 <stderr_file>
  216414:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  216417:	48 8d 3d 22 4c 03 00 	lea    rdi,[rip+0x34c22]        # 24b040 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  21641e:	48 89 3d e3 9b 03 00 	mov    QWORD PTR [rip+0x39be3],rdi        # 250008 <stderr_stream>
  216425:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
                const casted_value = ([]const u8)(value);
  21642a:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  21642f:	48 c7 44 24 18 0a 00 	mov    QWORD PTR [rsp+0x18],0xa
  216436:	00 00 
  216438:	48 8d 74 24 10       	lea    rsi,[rsp+0x10]
                return output(context, casted_value);
  21643d:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  21643f:	31 c0                	xor    eax,eax
  216441:	86 05 c9 9b 03 00    	xchg   BYTE PTR [rip+0x39bc9],al        # 250010 <stderr_mutex>
  216447:	3c 01                	cmp    al,0x1
    if (!ok) {
  216449:	75 08                	jne    216453 <Benchmark_rightJustified+0x2d3>
    fn rightJustified(width: usize, comptime fmt: []const u8, args: ...) !void {
  21644b:	31 c0                	xor    eax,eax
  21644d:	48 83 c4 50          	add    rsp,0x50
  216451:	5b                   	pop    rbx
  216452:	c3                   	ret    
            @panic("assertion failure");
  216453:	48 8d 3d ae 88 03 00 	lea    rdi,[rip+0x388ae]        # 24ed08 <__unnamed_2>
  21645a:	e8 c1 bb ff ff       	call   212020 <panic>
  21645f:	90                   	nop

0000000000216460 <Benchmark_rightJustified.38>:
        var buffer: [40]u8 = undefined;
  216460:	53                   	push   rbx
  216461:	48 83 ec 50          	sub    rsp,0x50
  216465:	c5 fc 10 05 2e f1 fe 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffef12e]        # 20559b <__unnamed_7>
  21646c:	ff 
  21646d:	c5 fc 11 44 24 20    	vmovups YMMWORD PTR [rsp+0x20],ymm0
  216473:	48 8b 05 41 f1 fe ff 	mov    rax,QWORD PTR [rip+0xfffffffffffef141]        # 2055bb <__unnamed_7+0x20>
  21647a:	48 89 44 24 40       	mov    QWORD PTR [rsp+0x40],rax
  21647f:	48 b8 74 69 6d 65 2f 	movabs rax,0x65706f2f656d6974
  216486:	6f 70 65 
  216489:	48 89 44 24 20       	mov    QWORD PTR [rsp+0x20],rax
  21648e:	c7 44 24 28 72 61 74 	mov    DWORD PTR [rsp+0x28],0x69746172
  216495:	69 
  216496:	66 c7 44 24 2c 6f 6e 	mov    WORD PTR [rsp+0x2c],0x6e6f
  21649d:	0f 1f 00             	nop    DWORD PTR [rax]
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  2164a0:	b0 01                	mov    al,0x1
  2164a2:	86 05 68 9b 03 00    	xchg   BYTE PTR [rip+0x39b68],al        # 250010 <stderr_mutex>
  2164a8:	84 c0                	test   al,al
  2164aa:	75 f4                	jne    2164a0 <Benchmark_rightJustified.38+0x40>
    if (stderr_stream) |st| {
  2164ac:	48 8b 3d 55 9b 03 00 	mov    rdi,QWORD PTR [rip+0x39b55]        # 250008 <stderr_stream>
  2164b3:	48 85 ff             	test   rdi,rdi
  2164b6:	74 09                	je     2164c1 <Benchmark_rightJustified.38+0x61>
  2164b8:	48 8b 05 81 4b 03 00 	mov    rax,QWORD PTR [rip+0x34b81]        # 24b040 <stderr_file_out_stream+0x8>
  2164bf:	eb 34                	jmp    2164f5 <Benchmark_rightJustified.38+0x95>
        stderr_file = try io.getStdErr();
  2164c1:	48 8d 05 68 4b 03 00 	lea    rax,[rip+0x34b68]        # 24b030 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  2164c8:	48 89 05 69 4b 03 00 	mov    QWORD PTR [rip+0x34b69],rax        # 24b038 <stderr_file_out_stream>
  2164cf:	48 8d 05 0a 95 00 00 	lea    rax,[rip+0x950a]        # 21f9e0 <FileOutStream_writeFn>
  2164d6:	48 89 05 63 4b 03 00 	mov    QWORD PTR [rip+0x34b63],rax        # 24b040 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  2164dd:	c7 05 49 4b 03 00 02 	mov    DWORD PTR [rip+0x34b49],0x2        # 24b030 <stderr_file>
  2164e4:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  2164e7:	48 8d 3d 52 4b 03 00 	lea    rdi,[rip+0x34b52]        # 24b040 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  2164ee:	48 89 3d 13 9b 03 00 	mov    QWORD PTR [rip+0x39b13],rdi        # 250008 <stderr_stream>
  2164f5:	c6 44 24 0f 20       	mov    BYTE PTR [rsp+0xf],0x20
  2164fa:	48 8d 5c 24 0f       	lea    rbx,[rsp+0xf]
    return output(context, (*[1]u8)(&c)[0..]);
  2164ff:	48 89 5c 24 10       	mov    QWORD PTR [rsp+0x10],rbx
  216504:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  21650b:	00 00 
  21650d:	48 8d 74 24 10       	lea    rsi,[rsp+0x10]
  216512:	c5 f8 77             	vzeroupper 
  216515:	ff d0                	call   rax
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  216517:	31 c0                	xor    eax,eax
  216519:	86 05 f1 9a 03 00    	xchg   BYTE PTR [rip+0x39af1],al        # 250010 <stderr_mutex>
  21651f:	3c 01                	cmp    al,0x1
    if (!ok) {
  216521:	0f 85 0c 02 00 00    	jne    216733 <Benchmark_rightJustified.38+0x2d3>
  216527:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  21652e:	00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  216530:	b0 01                	mov    al,0x1
  216532:	86 05 d8 9a 03 00    	xchg   BYTE PTR [rip+0x39ad8],al        # 250010 <stderr_mutex>
  216538:	84 c0                	test   al,al
  21653a:	75 f4                	jne    216530 <Benchmark_rightJustified.38+0xd0>
    if (stderr_stream) |st| {
  21653c:	48 8b 3d c5 9a 03 00 	mov    rdi,QWORD PTR [rip+0x39ac5]        # 250008 <stderr_stream>
  216543:	48 85 ff             	test   rdi,rdi
  216546:	74 09                	je     216551 <Benchmark_rightJustified.38+0xf1>
  216548:	48 8b 0d f1 4a 03 00 	mov    rcx,QWORD PTR [rip+0x34af1]        # 24b040 <stderr_file_out_stream+0x8>
  21654f:	eb 34                	jmp    216585 <Benchmark_rightJustified.38+0x125>
        stderr_file = try io.getStdErr();
  216551:	48 8d 05 d8 4a 03 00 	lea    rax,[rip+0x34ad8]        # 24b030 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  216558:	48 89 05 d9 4a 03 00 	mov    QWORD PTR [rip+0x34ad9],rax        # 24b038 <stderr_file_out_stream>
  21655f:	48 8d 0d 7a 94 00 00 	lea    rcx,[rip+0x947a]        # 21f9e0 <FileOutStream_writeFn>
  216566:	48 89 0d d3 4a 03 00 	mov    QWORD PTR [rip+0x34ad3],rcx        # 24b040 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  21656d:	c7 05 b9 4a 03 00 02 	mov    DWORD PTR [rip+0x34ab9],0x2        # 24b030 <stderr_file>
  216574:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  216577:	48 8d 3d c2 4a 03 00 	lea    rdi,[rip+0x34ac2]        # 24b040 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  21657e:	48 89 3d 83 9a 03 00 	mov    QWORD PTR [rip+0x39a83],rdi        # 250008 <stderr_stream>
  216585:	c6 44 24 0f 20       	mov    BYTE PTR [rsp+0xf],0x20
  21658a:	48 89 5c 24 10       	mov    QWORD PTR [rsp+0x10],rbx
  21658f:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  216596:	00 00 
  216598:	48 8d 74 24 10       	lea    rsi,[rsp+0x10]
  21659d:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  21659f:	31 c0                	xor    eax,eax
  2165a1:	86 05 69 9a 03 00    	xchg   BYTE PTR [rip+0x39a69],al        # 250010 <stderr_mutex>
  2165a7:	3c 01                	cmp    al,0x1
    if (!ok) {
  2165a9:	0f 85 84 01 00 00    	jne    216733 <Benchmark_rightJustified.38+0x2d3>
  2165af:	90                   	nop
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  2165b0:	b0 01                	mov    al,0x1
  2165b2:	86 05 58 9a 03 00    	xchg   BYTE PTR [rip+0x39a58],al        # 250010 <stderr_mutex>
  2165b8:	84 c0                	test   al,al
  2165ba:	75 f4                	jne    2165b0 <Benchmark_rightJustified.38+0x150>
    if (stderr_stream) |st| {
  2165bc:	48 8b 3d 45 9a 03 00 	mov    rdi,QWORD PTR [rip+0x39a45]        # 250008 <stderr_stream>
  2165c3:	48 85 ff             	test   rdi,rdi
  2165c6:	74 09                	je     2165d1 <Benchmark_rightJustified.38+0x171>
  2165c8:	48 8b 0d 71 4a 03 00 	mov    rcx,QWORD PTR [rip+0x34a71]        # 24b040 <stderr_file_out_stream+0x8>
  2165cf:	eb 34                	jmp    216605 <Benchmark_rightJustified.38+0x1a5>
        stderr_file = try io.getStdErr();
  2165d1:	48 8d 05 58 4a 03 00 	lea    rax,[rip+0x34a58]        # 24b030 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  2165d8:	48 89 05 59 4a 03 00 	mov    QWORD PTR [rip+0x34a59],rax        # 24b038 <stderr_file_out_stream>
  2165df:	48 8d 0d fa 93 00 00 	lea    rcx,[rip+0x93fa]        # 21f9e0 <FileOutStream_writeFn>
  2165e6:	48 89 0d 53 4a 03 00 	mov    QWORD PTR [rip+0x34a53],rcx        # 24b040 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  2165ed:	c7 05 39 4a 03 00 02 	mov    DWORD PTR [rip+0x34a39],0x2        # 24b030 <stderr_file>
  2165f4:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  2165f7:	48 8d 3d 42 4a 03 00 	lea    rdi,[rip+0x34a42]        # 24b040 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  2165fe:	48 89 3d 03 9a 03 00 	mov    QWORD PTR [rip+0x39a03],rdi        # 250008 <stderr_stream>
  216605:	c6 44 24 0f 20       	mov    BYTE PTR [rsp+0xf],0x20
  21660a:	48 89 5c 24 10       	mov    QWORD PTR [rsp+0x10],rbx
  21660f:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  216616:	00 00 
  216618:	48 8d 74 24 10       	lea    rsi,[rsp+0x10]
  21661d:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  21661f:	31 c0                	xor    eax,eax
  216621:	86 05 e9 99 03 00    	xchg   BYTE PTR [rip+0x399e9],al        # 250010 <stderr_mutex>
  216627:	3c 01                	cmp    al,0x1
    if (!ok) {
  216629:	0f 85 04 01 00 00    	jne    216733 <Benchmark_rightJustified.38+0x2d3>
  21662f:	90                   	nop
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  216630:	b0 01                	mov    al,0x1
  216632:	86 05 d8 99 03 00    	xchg   BYTE PTR [rip+0x399d8],al        # 250010 <stderr_mutex>
  216638:	84 c0                	test   al,al
  21663a:	75 f4                	jne    216630 <Benchmark_rightJustified.38+0x1d0>
    if (stderr_stream) |st| {
  21663c:	48 8b 3d c5 99 03 00 	mov    rdi,QWORD PTR [rip+0x399c5]        # 250008 <stderr_stream>
  216643:	48 85 ff             	test   rdi,rdi
  216646:	74 09                	je     216651 <Benchmark_rightJustified.38+0x1f1>
  216648:	48 8b 0d f1 49 03 00 	mov    rcx,QWORD PTR [rip+0x349f1]        # 24b040 <stderr_file_out_stream+0x8>
  21664f:	eb 34                	jmp    216685 <Benchmark_rightJustified.38+0x225>
        stderr_file = try io.getStdErr();
  216651:	48 8d 05 d8 49 03 00 	lea    rax,[rip+0x349d8]        # 24b030 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  216658:	48 89 05 d9 49 03 00 	mov    QWORD PTR [rip+0x349d9],rax        # 24b038 <stderr_file_out_stream>
  21665f:	48 8d 0d 7a 93 00 00 	lea    rcx,[rip+0x937a]        # 21f9e0 <FileOutStream_writeFn>
  216666:	48 89 0d d3 49 03 00 	mov    QWORD PTR [rip+0x349d3],rcx        # 24b040 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  21666d:	c7 05 b9 49 03 00 02 	mov    DWORD PTR [rip+0x349b9],0x2        # 24b030 <stderr_file>
  216674:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  216677:	48 8d 3d c2 49 03 00 	lea    rdi,[rip+0x349c2]        # 24b040 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  21667e:	48 89 3d 83 99 03 00 	mov    QWORD PTR [rip+0x39983],rdi        # 250008 <stderr_stream>
  216685:	c6 44 24 0f 20       	mov    BYTE PTR [rsp+0xf],0x20
  21668a:	48 89 5c 24 10       	mov    QWORD PTR [rsp+0x10],rbx
  21668f:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  216696:	00 00 
  216698:	48 8d 74 24 10       	lea    rsi,[rsp+0x10]
  21669d:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  21669f:	31 c0                	xor    eax,eax
  2166a1:	86 05 69 99 03 00    	xchg   BYTE PTR [rip+0x39969],al        # 250010 <stderr_mutex>
  2166a7:	3c 01                	cmp    al,0x1
    if (!ok) {
  2166a9:	0f 85 84 00 00 00    	jne    216733 <Benchmark_rightJustified.38+0x2d3>
  2166af:	90                   	nop
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  2166b0:	b0 01                	mov    al,0x1
  2166b2:	86 05 58 99 03 00    	xchg   BYTE PTR [rip+0x39958],al        # 250010 <stderr_mutex>
  2166b8:	84 c0                	test   al,al
  2166ba:	75 f4                	jne    2166b0 <Benchmark_rightJustified.38+0x250>
    if (stderr_stream) |st| {
  2166bc:	48 8b 3d 45 99 03 00 	mov    rdi,QWORD PTR [rip+0x39945]        # 250008 <stderr_stream>
  2166c3:	48 85 ff             	test   rdi,rdi
  2166c6:	74 09                	je     2166d1 <Benchmark_rightJustified.38+0x271>
  2166c8:	48 8b 0d 71 49 03 00 	mov    rcx,QWORD PTR [rip+0x34971]        # 24b040 <stderr_file_out_stream+0x8>
  2166cf:	eb 34                	jmp    216705 <Benchmark_rightJustified.38+0x2a5>
        stderr_file = try io.getStdErr();
  2166d1:	48 8d 05 58 49 03 00 	lea    rax,[rip+0x34958]        # 24b030 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  2166d8:	48 89 05 59 49 03 00 	mov    QWORD PTR [rip+0x34959],rax        # 24b038 <stderr_file_out_stream>
  2166df:	48 8d 0d fa 92 00 00 	lea    rcx,[rip+0x92fa]        # 21f9e0 <FileOutStream_writeFn>
  2166e6:	48 89 0d 53 49 03 00 	mov    QWORD PTR [rip+0x34953],rcx        # 24b040 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  2166ed:	c7 05 39 49 03 00 02 	mov    DWORD PTR [rip+0x34939],0x2        # 24b030 <stderr_file>
  2166f4:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  2166f7:	48 8d 3d 42 49 03 00 	lea    rdi,[rip+0x34942]        # 24b040 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  2166fe:	48 89 3d 03 99 03 00 	mov    QWORD PTR [rip+0x39903],rdi        # 250008 <stderr_stream>
  216705:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
                const casted_value = ([]const u8)(value);
  21670a:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  21670f:	48 c7 44 24 18 0e 00 	mov    QWORD PTR [rsp+0x18],0xe
  216716:	00 00 
  216718:	48 8d 74 24 10       	lea    rsi,[rsp+0x10]
                return output(context, casted_value);
  21671d:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  21671f:	31 c0                	xor    eax,eax
  216721:	86 05 e9 98 03 00    	xchg   BYTE PTR [rip+0x398e9],al        # 250010 <stderr_mutex>
  216727:	3c 01                	cmp    al,0x1
    if (!ok) {
  216729:	75 08                	jne    216733 <Benchmark_rightJustified.38+0x2d3>
    fn rightJustified(width: usize, comptime fmt: []const u8, args: ...) !void {
  21672b:	31 c0                	xor    eax,eax
  21672d:	48 83 c4 50          	add    rsp,0x50
  216731:	5b                   	pop    rbx
  216732:	c3                   	ret    
            @panic("assertion failure");
  216733:	48 8d 3d ce 85 03 00 	lea    rdi,[rip+0x385ce]        # 24ed08 <__unnamed_2>
  21673a:	e8 e1 b8 ff ff       	call   212020 <panic>
  21673f:	90                   	nop

0000000000216740 <Benchmark_reportStats>:
    fn reportStats(pSelf: *Self, results: ArrayList(Result)) !void {
  216740:	55                   	push   rbp
  216741:	48 89 e5             	mov    rbp,rsp
  216744:	41 57                	push   r15
  216746:	41 56                	push   r14
  216748:	41 55                	push   r13
  21674a:	41 54                	push   r12
  21674c:	53                   	push   rbx
  21674d:	48 83 e4 e0          	and    rsp,0xffffffffffffffe0
  216751:	48 81 ec 40 22 00 00 	sub    rsp,0x2240
  216758:	48 89 fb             	mov    rbx,rdi
            return self.items[0..self.len];
  21675b:	48 8b 7e 10          	mov    rdi,QWORD PTR [rsi+0x10]
        for (results.toSlice()) |result, i| {
  21675f:	48 85 ff             	test   rdi,rdi
  216762:	74 26                	je     21678a <Benchmark_reportStats+0x4a>
  216764:	48 8b 06             	mov    rax,QWORD PTR [rsi]
  216767:	48 8d 57 ff          	lea    rdx,[rdi-0x1]
  21676b:	89 f9                	mov    ecx,edi
  21676d:	83 e1 07             	and    ecx,0x7
  216770:	48 83 fa 07          	cmp    rdx,0x7
  216774:	73 1d                	jae    216793 <Benchmark_reportStats+0x53>
  216776:	c5 c9 57 f6          	vxorpd xmm6,xmm6,xmm6
  21677a:	31 d2                	xor    edx,edx
  21677c:	48 85 c9             	test   rcx,rcx
  21677f:	0f 85 e8 00 00 00    	jne    21686d <Benchmark_reportStats+0x12d>
  216785:	e9 24 01 00 00       	jmp    2168ae <Benchmark_reportStats+0x16e>
  21678a:	c5 c9 57 f6          	vxorpd xmm6,xmm6,xmm6
  21678e:	e9 1b 01 00 00       	jmp    2168ae <Benchmark_reportStats+0x16e>
  216793:	48 29 cf             	sub    rdi,rcx
  216796:	48 8d 70 70          	lea    rsi,[rax+0x70]
  21679a:	c5 c9 57 f6          	vxorpd xmm6,xmm6,xmm6
  21679e:	31 d2                	xor    edx,edx
  2167a0:	c5 f9 28 05 28 25 ff 	vmovapd xmm0,XMMWORD PTR [rip+0xffffffffffff2528]        # 208cd0 <__unnamed_629+0x17>
  2167a7:	ff 
  2167a8:	c5 f9 28 0d 40 2a ff 	vmovapd xmm1,XMMWORD PTR [rip+0xffffffffffff2a40]        # 2091f0 <__unnamed_70+0x10>
  2167af:	ff 
            sum += @intToFloat(f64, result.run_time_ns);
  2167b0:	c5 fb 10 56 90       	vmovsd xmm2,QWORD PTR [rsi-0x70]
  2167b5:	c5 e8 14 d0          	vunpcklps xmm2,xmm2,xmm0
  2167b9:	c5 e9 5c d1          	vsubpd xmm2,xmm2,xmm1
  2167bd:	c5 e9 7c d2          	vhaddpd xmm2,xmm2,xmm2
  2167c1:	c5 fb 10 5e a0       	vmovsd xmm3,QWORD PTR [rsi-0x60]
  2167c6:	c5 e0 14 d8          	vunpcklps xmm3,xmm3,xmm0
  2167ca:	c5 e1 5c d9          	vsubpd xmm3,xmm3,xmm1
  2167ce:	c5 e1 7c db          	vhaddpd xmm3,xmm3,xmm3
  2167d2:	c5 fb 10 66 b0       	vmovsd xmm4,QWORD PTR [rsi-0x50]
  2167d7:	c5 d8 14 e0          	vunpcklps xmm4,xmm4,xmm0
  2167db:	c5 d9 5c e1          	vsubpd xmm4,xmm4,xmm1
  2167df:	c5 d9 7c e4          	vhaddpd xmm4,xmm4,xmm4
  2167e3:	c5 fb 10 6e c0       	vmovsd xmm5,QWORD PTR [rsi-0x40]
  2167e8:	c5 d0 14 e8          	vunpcklps xmm5,xmm5,xmm0
  2167ec:	c5 d1 5c e9          	vsubpd xmm5,xmm5,xmm1
  2167f0:	c5 d1 7c ed          	vhaddpd xmm5,xmm5,xmm5
  2167f4:	c5 cb 58 d2          	vaddsd xmm2,xmm6,xmm2
  2167f8:	c5 fb 10 76 d0       	vmovsd xmm6,QWORD PTR [rsi-0x30]
  2167fd:	c5 c8 14 f0          	vunpcklps xmm6,xmm6,xmm0
  216801:	c5 c9 5c f1          	vsubpd xmm6,xmm6,xmm1
  216805:	c5 c9 7c f6          	vhaddpd xmm6,xmm6,xmm6
  216809:	c5 eb 58 d3          	vaddsd xmm2,xmm2,xmm3
  21680d:	c5 eb 58 d4          	vaddsd xmm2,xmm2,xmm4
  216811:	c5 fb 10 5e e0       	vmovsd xmm3,QWORD PTR [rsi-0x20]
  216816:	c5 e0 14 d8          	vunpcklps xmm3,xmm3,xmm0
  21681a:	c5 e1 5c d9          	vsubpd xmm3,xmm3,xmm1
  21681e:	c5 e1 7c db          	vhaddpd xmm3,xmm3,xmm3
  216822:	c5 eb 58 d5          	vaddsd xmm2,xmm2,xmm5
  216826:	c5 eb 58 d6          	vaddsd xmm2,xmm2,xmm6
  21682a:	c5 fb 10 66 f0       	vmovsd xmm4,QWORD PTR [rsi-0x10]
  21682f:	c5 d8 14 e0          	vunpcklps xmm4,xmm4,xmm0
  216833:	c5 d9 5c e1          	vsubpd xmm4,xmm4,xmm1
  216837:	c5 d9 7c e4          	vhaddpd xmm4,xmm4,xmm4
  21683b:	c5 eb 58 d3          	vaddsd xmm2,xmm2,xmm3
  21683f:	c5 eb 58 d4          	vaddsd xmm2,xmm2,xmm4
  216843:	c5 fb 10 1e          	vmovsd xmm3,QWORD PTR [rsi]
  216847:	c5 e0 14 d8          	vunpcklps xmm3,xmm3,xmm0
  21684b:	c5 e1 5c d9          	vsubpd xmm3,xmm3,xmm1
  21684f:	c5 e1 7c db          	vhaddpd xmm3,xmm3,xmm3
  216853:	c5 eb 58 f3          	vaddsd xmm6,xmm2,xmm3
        for (results.toSlice()) |result, i| {
  216857:	48 83 c2 08          	add    rdx,0x8
  21685b:	48 83 ee 80          	sub    rsi,0xffffffffffffff80
  21685f:	48 39 d7             	cmp    rdi,rdx
  216862:	0f 85 48 ff ff ff    	jne    2167b0 <Benchmark_reportStats+0x70>
  216868:	48 85 c9             	test   rcx,rcx
  21686b:	74 41                	je     2168ae <Benchmark_reportStats+0x16e>
  21686d:	48 c1 e2 04          	shl    rdx,0x4
  216871:	48 01 d0             	add    rax,rdx
  216874:	48 f7 d9             	neg    rcx
  216877:	c5 f9 28 05 51 24 ff 	vmovapd xmm0,XMMWORD PTR [rip+0xffffffffffff2451]        # 208cd0 <__unnamed_629+0x17>
  21687e:	ff 
  21687f:	c5 f9 28 0d 69 29 ff 	vmovapd xmm1,XMMWORD PTR [rip+0xffffffffffff2969]        # 2091f0 <__unnamed_70+0x10>
  216886:	ff 
  216887:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  21688e:	00 00 
            sum += @intToFloat(f64, result.run_time_ns);
  216890:	c5 fb 10 10          	vmovsd xmm2,QWORD PTR [rax]
  216894:	c5 e8 14 d0          	vunpcklps xmm2,xmm2,xmm0
  216898:	c5 e9 5c d1          	vsubpd xmm2,xmm2,xmm1
  21689c:	c5 e9 7c d2          	vhaddpd xmm2,xmm2,xmm2
  2168a0:	c5 cb 58 f2          	vaddsd xmm6,xmm6,xmm2
        for (results.toSlice()) |result, i| {
  2168a4:	48 83 c0 10          	add    rax,0x10
  2168a8:	48 83 c1 01          	add    rcx,0x1
  2168ac:	75 e2                	jne    216890 <Benchmark_reportStats+0x150>
  2168ae:	48 8b 43 48          	mov    rax,QWORD PTR [rbx+0x48]
            .run_time_ns = @floatToInt(u64, sum / @intToFloat(f64, results.len)),
  2168b2:	c5 fb 10 43 58       	vmovsd xmm0,QWORD PTR [rbx+0x58]
  2168b7:	c5 f8 14 05 11 24 ff 	vunpcklps xmm0,xmm0,XMMWORD PTR [rip+0xffffffffffff2411]        # 208cd0 <__unnamed_629+0x17>
  2168be:	ff 
  2168bf:	c5 f9 5c 05 29 29 ff 	vsubpd xmm0,xmm0,XMMWORD PTR [rip+0xffffffffffff2929]        # 2091f0 <__unnamed_70+0x10>
  2168c6:	ff 
  2168c7:	c5 f9 7c c0          	vhaddpd xmm0,xmm0,xmm0
  2168cb:	c5 fb 11 b4 24 90 01 	vmovsd QWORD PTR [rsp+0x190],xmm6
  2168d2:	00 00 
  2168d4:	c5 cb 5e c0          	vdivsd xmm0,xmm6,xmm0
  2168d8:	c5 fb 10 15 68 9a fe 	vmovsd xmm2,QWORD PTR [rip+0xfffffffffffe9a68]        # 200348 <__unnamed_609+0x8>
  2168df:	ff 
  2168e0:	c5 fb 5c ca          	vsubsd xmm1,xmm0,xmm2
  2168e4:	c4 e1 fb 2c c9       	vcvttsd2si rcx,xmm1
  2168e9:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
  2168ed:	48 be 00 00 00 00 00 	movabs rsi,0x8000000000000000
  2168f4:	00 00 80 
  2168f7:	c4 e1 fb 2c d0       	vcvttsd2si rdx,xmm0
  2168fc:	48 31 f1             	xor    rcx,rsi
  2168ff:	c5 f9 2e c2          	vucomisd xmm0,xmm2
  216903:	48 0f 43 d1          	cmovae rdx,rcx
        try pSelf.report(Result {
  216907:	48 89 94 24 28 02 00 	mov    QWORD PTR [rsp+0x228],rdx
  21690e:	00 
  21690f:	48 89 84 24 30 02 00 	mov    QWORD PTR [rsp+0x230],rax
  216916:	00 
  216917:	48 8d b4 24 28 02 00 	lea    rsi,[rsp+0x228]
  21691e:	00 
  21691f:	48 89 df             	mov    rdi,rbx
  216922:	e8 39 d1 ff ff       	call   213a60 <Benchmark_report>
        try pSelf.reportStatsMean(sum, pSelf.results); warn(" mean\n");
  216927:	66 85 c0             	test   ax,ax
  21692a:	0f 85 6d 89 00 00    	jne    21f29d <Benchmark_reportStats+0x8b5d>
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  216930:	b0 01                	mov    al,0x1
  216932:	86 05 d8 96 03 00    	xchg   BYTE PTR [rip+0x396d8],al        # 250010 <stderr_mutex>
  216938:	84 c0                	test   al,al
  21693a:	75 f4                	jne    216930 <Benchmark_reportStats+0x1f0>
    if (stderr_stream) |st| {
  21693c:	48 8b 3d c5 96 03 00 	mov    rdi,QWORD PTR [rip+0x396c5]        # 250008 <stderr_stream>
  216943:	48 85 ff             	test   rdi,rdi
  216946:	74 09                	je     216951 <Benchmark_reportStats+0x211>
  216948:	48 8b 0d f1 46 03 00 	mov    rcx,QWORD PTR [rip+0x346f1]        # 24b040 <stderr_file_out_stream+0x8>
  21694f:	eb 34                	jmp    216985 <Benchmark_reportStats+0x245>
        stderr_file = try io.getStdErr();
  216951:	48 8d 05 d8 46 03 00 	lea    rax,[rip+0x346d8]        # 24b030 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  216958:	48 89 05 d9 46 03 00 	mov    QWORD PTR [rip+0x346d9],rax        # 24b038 <stderr_file_out_stream>
  21695f:	48 8d 0d 7a 90 00 00 	lea    rcx,[rip+0x907a]        # 21f9e0 <FileOutStream_writeFn>
  216966:	48 89 0d d3 46 03 00 	mov    QWORD PTR [rip+0x346d3],rcx        # 24b040 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  21696d:	c7 05 b9 46 03 00 02 	mov    DWORD PTR [rip+0x346b9],0x2        # 24b030 <stderr_file>
  216974:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  216977:	48 8d 3d c2 46 03 00 	lea    rdi,[rip+0x346c2]        # 24b040 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  21697e:	48 89 3d 83 96 03 00 	mov    QWORD PTR [rip+0x39683],rdi        # 250008 <stderr_stream>
        try output(context, fmt[start_index..]);
  216985:	48 8d 35 ec 83 03 00 	lea    rsi,[rip+0x383ec]        # 24ed78 <__unnamed_49>
  21698c:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  21698e:	31 c0                	xor    eax,eax
  216990:	86 05 7a 96 03 00    	xchg   BYTE PTR [rip+0x3967a],al        # 250010 <stderr_mutex>
  216996:	3c 01                	cmp    al,0x1
    if (!ok) {
  216998:	0f 85 0e 89 00 00    	jne    21f2ac <Benchmark_reportStats+0x8b6c>
        if (results.len < 3) {
  21699e:	4c 8b 63 58          	mov    r12,QWORD PTR [rbx+0x58]
  2169a2:	49 83 fc 02          	cmp    r12,0x2
  2169a6:	77 7a                	ja     216a22 <Benchmark_reportStats+0x2e2>
            .run_time_ns = @floatToInt(u64, sum / @intToFloat(f64, results.len)),
  2169a8:	c4 c1 f9 6e c4       	vmovq  xmm0,r12
  2169ad:	c5 f9 62 05 1b 23 ff 	vpunpckldq xmm0,xmm0,XMMWORD PTR [rip+0xffffffffffff231b]        # 208cd0 <__unnamed_629+0x17>
  2169b4:	ff 
  2169b5:	c5 f9 5c 05 33 28 ff 	vsubpd xmm0,xmm0,XMMWORD PTR [rip+0xffffffffffff2833]        # 2091f0 <__unnamed_70+0x10>
  2169bc:	ff 
  2169bd:	c5 f9 7c c0          	vhaddpd xmm0,xmm0,xmm0
  2169c1:	48 8b 43 48          	mov    rax,QWORD PTR [rbx+0x48]
  2169c5:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
  2169c9:	c5 fb 10 8c 24 90 01 	vmovsd xmm1,QWORD PTR [rsp+0x190]
  2169d0:	00 00 
  2169d2:	c5 f3 5e c0          	vdivsd xmm0,xmm1,xmm0
  2169d6:	c5 fb 10 0d 6a 99 fe 	vmovsd xmm1,QWORD PTR [rip+0xfffffffffffe996a]        # 200348 <__unnamed_609+0x8>
  2169dd:	ff 
  2169de:	c5 f9 28 d1          	vmovapd xmm2,xmm1
  2169e2:	c5 fb 5c ca          	vsubsd xmm1,xmm0,xmm2
  2169e6:	c4 e1 fb 2c c9       	vcvttsd2si rcx,xmm1
  2169eb:	c4 e1 fb 2c d0       	vcvttsd2si rdx,xmm0
  2169f0:	48 be 00 00 00 00 00 	movabs rsi,0x8000000000000000
  2169f7:	00 00 80 
  2169fa:	48 31 f1             	xor    rcx,rsi
  2169fd:	c5 f9 2e c2          	vucomisd xmm0,xmm2
  216a01:	48 0f 43 d1          	cmovae rdx,rcx
        try pSelf.report(Result {
  216a05:	48 89 94 24 28 02 00 	mov    QWORD PTR [rsp+0x228],rdx
  216a0c:	00 
  216a0d:	48 89 84 24 30 02 00 	mov    QWORD PTR [rsp+0x230],rax
  216a14:	00 
  216a15:	48 8d b4 24 28 02 00 	lea    rsi,[rsp+0x228]
  216a1c:	00 
  216a1d:	e9 b3 85 00 00       	jmp    21efd5 <Benchmark_reportStats+0x8895>
        var copy = ArrayList(Result).init(pSelf.pAllocator);
  216a22:	48 8b 43 40          	mov    rax,QWORD PTR [rbx+0x40]
            return Self{
  216a26:	c5 f9 57 c0          	vxorpd xmm0,xmm0,xmm0
  216a2a:	c5 f9 29 84 24 a0 01 	vmovapd XMMWORD PTR [rsp+0x1a0],xmm0
  216a31:	00 00 
  216a33:	48 c7 84 24 b0 01 00 	mov    QWORD PTR [rsp+0x1b0],0x0
  216a3a:	00 00 00 00 00 
  216a3f:	48 89 84 24 b8 01 00 	mov    QWORD PTR [rsp+0x1b8],rax
  216a46:	00 
  216a47:	48 89 9c 24 88 01 00 	mov    QWORD PTR [rsp+0x188],rbx
  216a4e:	00 
            return self.items[0..self.len];
  216a4f:	4c 8b 6b 48          	mov    r13,QWORD PTR [rbx+0x48]
        for (results.toSlice()) |result| {
  216a53:	c5 fa 6f 05 65 23 ff 	vmovdqu xmm0,XMMWORD PTR [rip+0xffffffffffff2365]        # 208dc0 <__unnamed_5>
  216a5a:	ff 
  216a5b:	c5 f9 7f 84 24 e0 01 	vmovdqa XMMWORD PTR [rsp+0x1e0],xmm0
  216a62:	00 00 
  216a64:	31 db                	xor    ebx,ebx
  216a66:	4c 8d b4 24 a0 01 00 	lea    r14,[rsp+0x1a0]
  216a6d:	00 
  216a6e:	4c 8d bc 24 e0 01 00 	lea    r15,[rsp+0x1e0]
  216a75:	00 
  216a76:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  216a7d:	00 00 00 
  216a80:	c4 c1 7a 6f 45 00    	vmovdqu xmm0,XMMWORD PTR [r13+0x0]
  216a86:	c5 f9 7f 84 24 e0 01 	vmovdqa XMMWORD PTR [rsp+0x1e0],xmm0
  216a8d:	00 00 
            try copy.append(result);
  216a8f:	4c 89 f7             	mov    rdi,r14
  216a92:	4c 89 fe             	mov    rsi,r15
  216a95:	e8 56 ce ff ff       	call   2138f0 <AlignedArrayList(Result,8)_append>
  216a9a:	66 85 c0             	test   ax,ax
  216a9d:	0f 85 fa 87 00 00    	jne    21f29d <Benchmark_reportStats+0x8b5d>
  216aa3:	48 83 c3 01          	add    rbx,0x1
        for (results.toSlice()) |result| {
  216aa7:	49 83 c5 10          	add    r13,0x10
  216aab:	4c 39 e3             	cmp    rbx,r12
  216aae:	72 d0                	jb     216a80 <Benchmark_reportStats+0x340>
  216ab0:	48 8b 9c 24 a0 01 00 	mov    rbx,QWORD PTR [rsp+0x1a0]
  216ab7:	00 
  216ab8:	4c 8b b4 24 b0 01 00 	mov    r14,QWORD PTR [rsp+0x1b0]
  216abf:	00 
  216ac0:	48 89 5c 24 40       	mov    QWORD PTR [rsp+0x40],rbx
  216ac5:	4c 89 74 24 48       	mov    QWORD PTR [rsp+0x48],r14

/// Stable in-place sort. O(n) best case, O(n*log(n)) worst case and average case. O(1) memory (no allocator required).
/// Currently implemented as block sort.
pub fn sort(comptime T: type, items: []T, lessThan: fn (lhs: T, rhs: T) bool) void {
    // Implementation ported from https://github.com/BonzaiThePenguin/WikiSort/blob/master/WikiSort.c
    var cache: [512]T = undefined;
  216aca:	48 8d 35 f7 ea fe ff 	lea    rsi,[rip+0xfffffffffffeeaf7]        # 2055c8 <__unnamed_51>
  216ad1:	48 8d bc 24 28 02 00 	lea    rdi,[rsp+0x228]
  216ad8:	00 
  216ad9:	ba 00 20 00 00       	mov    edx,0x2000
  216ade:	e8 3d 7a 01 00       	call   22e520 <memcpy>
  216ae3:	4c 89 f0             	mov    rax,r14

    if (items.len < 4) {
  216ae6:	48 83 f8 03          	cmp    rax,0x3
  216aea:	0f 87 96 00 00 00    	ja     216b86 <Benchmark_reportStats+0x446>
        if (items.len == 3) {
  216af0:	48 83 f8 02          	cmp    rax,0x2
  216af4:	0f 84 e5 83 00 00    	je     21eedf <Benchmark_reportStats+0x879f>
  216afa:	48 83 f8 03          	cmp    rax,0x3
  216afe:	0f 85 0a 84 00 00    	jne    21ef0e <Benchmark_reportStats+0x87ce>
            // hard coded insertion sort
            if (lessThan(items[1], items[0])) mem.swap(T, &items[0], &items[1]);
  216b04:	48 8d 43 10          	lea    rax,[rbx+0x10]
  216b08:	48 8b 4b 10          	mov    rcx,QWORD PTR [rbx+0x10]
            return lhs.run_time_ns < rhs.run_time_ns;
  216b0c:	48 3b 0b             	cmp    rcx,QWORD PTR [rbx]
  216b0f:	73 26                	jae    216b37 <Benchmark_reportStats+0x3f7>
test "mem.max" {
    assert(max(u8, "abcdefg") == 'g');
}

pub fn swap(comptime T: type, a: *T, b: *T) void {
    const tmp = a.*;
  216b11:	c5 f8 10 03          	vmovups xmm0,XMMWORD PTR [rbx]
  216b15:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  216b1c:	00 00 
    a.* = b.*;
  216b1e:	c5 f8 10 00          	vmovups xmm0,XMMWORD PTR [rax]
  216b22:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
    b.* = tmp;
  216b26:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  216b2d:	00 00 
  216b2f:	c5 fa 7f 00          	vmovdqu XMMWORD PTR [rax],xmm0
  216b33:	48 8b 4b 10          	mov    rcx,QWORD PTR [rbx+0x10]
  216b37:	48 39 4b 20          	cmp    QWORD PTR [rbx+0x20],rcx
            if (lessThan(items[2], items[1])) {
  216b3b:	0f 83 cd 83 00 00    	jae    21ef0e <Benchmark_reportStats+0x87ce>
    const tmp = a.*;
  216b41:	c5 f8 10 00          	vmovups xmm0,XMMWORD PTR [rax]
  216b45:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  216b4c:	00 00 
  216b4e:	48 8d 4b 20          	lea    rcx,[rbx+0x20]
    a.* = b.*;
  216b52:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  216b56:	c5 f8 11 00          	vmovups XMMWORD PTR [rax],xmm0
    b.* = tmp;
  216b5a:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  216b61:	00 00 
  216b63:	c5 fa 7f 01          	vmovdqu XMMWORD PTR [rcx],xmm0
  216b67:	48 8b 4b 10          	mov    rcx,QWORD PTR [rbx+0x10]
  216b6b:	48 3b 0b             	cmp    rcx,QWORD PTR [rbx]
                mem.swap(T, &items[1], &items[2]);
                if (lessThan(items[1], items[0])) mem.swap(T, &items[0], &items[1]);
  216b6e:	0f 83 9a 83 00 00    	jae    21ef0e <Benchmark_reportStats+0x87ce>
    const tmp = a.*;
  216b74:	c5 f8 10 03          	vmovups xmm0,XMMWORD PTR [rbx]
  216b78:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  216b7f:	00 00 
  216b81:	e9 73 83 00 00       	jmp    21eef9 <Benchmark_reportStats+0x87b9>
pub fn floorPowerOfTwo(comptime T: type, value: T) T {
    var x = value;

    comptime var i = 1;
    inline while (T.bit_count > i) : (i *= 2) {
        x |= (x >> i);
  216b86:	48 89 c2             	mov    rdx,rax
  216b89:	48 d1 ea             	shr    rdx,1
  216b8c:	48 09 c2             	or     rdx,rax
  216b8f:	48 89 d1             	mov    rcx,rdx
  216b92:	48 c1 e9 02          	shr    rcx,0x2
  216b96:	48 09 d1             	or     rcx,rdx
  216b99:	48 89 ca             	mov    rdx,rcx
  216b9c:	48 c1 ea 04          	shr    rdx,0x4
  216ba0:	48 09 ca             	or     rdx,rcx
  216ba3:	48 89 d1             	mov    rcx,rdx
  216ba6:	48 c1 e9 08          	shr    rcx,0x8
  216baa:	48 09 d1             	or     rcx,rdx
  216bad:	48 89 ca             	mov    rdx,rcx
  216bb0:	48 c1 ea 10          	shr    rdx,0x10
  216bb4:	48 09 ca             	or     rdx,rcx
  216bb7:	49 89 d7             	mov    r15,rdx
  216bba:	49 c1 ef 20          	shr    r15,0x20
  216bbe:	49 09 d7             	or     r15,rdx
    }

    return x - (x >> 1);
  216bc1:	4c 89 f9             	mov    rcx,r15
  216bc4:	48 d1 e9             	shr    rcx,1
  216bc7:	49 29 cf             	sub    r15,rcx
        const denominator = power_of_two / min_level;
  216bca:	49 c1 ef 02          	shr    r15,0x2
  216bce:	48 89 c1             	mov    rcx,rax
  216bd1:	4c 09 f9             	or     rcx,r15
  216bd4:	48 c1 e9 20          	shr    rcx,0x20
  216bd8:	48 89 84 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rax
  216bdf:	00 
  216be0:	74 07                	je     216be9 <Benchmark_reportStats+0x4a9>
  216be2:	31 d2                	xor    edx,edx
  216be4:	49 f7 f7             	div    r15
  216be7:	eb 05                	jmp    216bee <Benchmark_reportStats+0x4ae>
  216be9:	31 d2                	xor    edx,edx
  216beb:	41 f7 f7             	div    r15d
  216bee:	31 ff                	xor    edi,edi
  216bf0:	31 f6                	xor    esi,esi
  216bf2:	4c 89 bc 24 00 01 00 	mov    QWORD PTR [rsp+0x100],r15
  216bf9:	00 
  216bfa:	48 89 84 24 d8 00 00 	mov    QWORD PTR [rsp+0xd8],rax
  216c01:	00 
  216c02:	48 89 94 24 e0 00 00 	mov    QWORD PTR [rsp+0xe0],rdx
  216c09:	00 
  216c0a:	eb 1f                	jmp    216c2b <Benchmark_reportStats+0x4eb>
  216c0c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  216c10:	4c 29 ee             	sub    rsi,r13
    var iterator = Iterator.init(items.len, 4);
    while (!iterator.finished()) {
        var order = []u8{ 0, 1, 2, 3, 4, 5, 6, 7 };
        const range = iterator.nextRange();

        const sliced_items = items[range.start..];
  216c13:	48 8b 5c 24 40       	mov    rbx,QWORD PTR [rsp+0x40]
  216c18:	4c 89 d7             	mov    rdi,r10
  216c1b:	48 8b 84 24 d8 00 00 	mov    rax,QWORD PTR [rsp+0xd8]
  216c22:	00 
  216c23:	48 8b 94 24 e0 00 00 	mov    rdx,QWORD PTR [rsp+0xe0]
  216c2a:	00 
        self.decimal += self.decimal_step;
  216c2b:	48 8d 0c 07          	lea    rcx,[rdi+rax*1]
        self.numerator += self.numerator_step;
  216c2f:	48 01 d6             	add    rsi,rdx
        if (self.numerator >= self.denominator) {
  216c32:	45 31 d2             	xor    r10d,r10d
  216c35:	4c 39 fe             	cmp    rsi,r15
  216c38:	41 0f 93 c2          	setae  r10b
  216c3c:	41 bd 00 00 00 00    	mov    r13d,0x0
  216c42:	4d 0f 43 ef          	cmovae r13,r15
  216c46:	49 01 ca             	add    r10,rcx
        return self.end - self.start;
  216c49:	4c 89 d1             	mov    rcx,r10
  216c4c:	48 29 f9             	sub    rcx,rdi
        switch (range.length()) {
  216c4f:	48 83 c1 fc          	add    rcx,0xfffffffffffffffc
  216c53:	48 83 f9 04          	cmp    rcx,0x4
  216c57:	0f 87 93 13 00 00    	ja     217ff0 <Benchmark_reportStats+0x18b0>
  216c5d:	48 c1 e7 04          	shl    rdi,0x4
  216c61:	48 01 fb             	add    rbx,rdi
  216c64:	48 8d 05 a5 97 fe ff 	lea    rax,[rip+0xfffffffffffe97a5]        # 200410 <__unnamed_609+0xd0>
  216c6b:	48 89 c2             	mov    rdx,rax
  216c6e:	48 63 04 8a          	movsxd rax,DWORD PTR [rdx+rcx*4]
  216c72:	48 01 d0             	add    rax,rdx
  216c75:	ff e0                	jmp    rax
    // copy the remainder of A into the final array
    mem.copy(T, items[insert_index..], cache[A_index..A_last]);
}

fn swap(comptime T: type, items: []T, lessThan: fn (lhs: T, rhs: T) bool, order: *[8]u8, x: usize, y: usize) void {
    if (lessThan(items[y], items[x]) or ((order.*)[x] > (order.*)[y] and !lessThan(items[x], items[y]))) {
  216c77:	48 8d 43 10          	lea    rax,[rbx+0x10]
  216c7b:	48 8b 4b 10          	mov    rcx,QWORD PTR [rbx+0x10]
  216c7f:	48 3b 0b             	cmp    rcx,QWORD PTR [rbx]
  216c82:	0f 83 48 01 00 00    	jae    216dd0 <Benchmark_reportStats+0x690>
  216c88:	c5 f8 10 03          	vmovups xmm0,XMMWORD PTR [rbx]
  216c8c:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  216c93:	00 00 
    a.* = b.*;
  216c95:	c5 f8 10 00          	vmovups xmm0,XMMWORD PTR [rax]
  216c99:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
    b.* = tmp;
  216c9d:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  216ca4:	00 00 
  216ca6:	c5 fa 7f 00          	vmovdqu XMMWORD PTR [rax],xmm0
  216caa:	41 b3 01             	mov    r11b,0x1
  216cad:	45 31 f6             	xor    r14d,r14d
  216cb0:	e9 21 01 00 00       	jmp    216dd6 <Benchmark_reportStats+0x696>
  216cb5:	4c 8d 63 10          	lea    r12,[rbx+0x10]
  216cb9:	48 8b 43 10          	mov    rax,QWORD PTR [rbx+0x10]
  216cbd:	48 3b 03             	cmp    rax,QWORD PTR [rbx]
  216cc0:	48 89 74 24 38       	mov    QWORD PTR [rsp+0x38],rsi
  216cc5:	4c 89 6c 24 18       	mov    QWORD PTR [rsp+0x18],r13
  216cca:	0f 83 55 01 00 00    	jae    216e25 <Benchmark_reportStats+0x6e5>
    const tmp = a.*;
  216cd0:	c5 f8 10 03          	vmovups xmm0,XMMWORD PTR [rbx]
  216cd4:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  216cdb:	00 00 
    a.* = b.*;
  216cdd:	c4 c1 78 10 04 24    	vmovups xmm0,XMMWORD PTR [r12]
  216ce3:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
    b.* = tmp;
  216ce7:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  216cee:	00 00 
  216cf0:	c4 c1 7a 7f 04 24    	vmovdqu XMMWORD PTR [r12],xmm0
  216cf6:	41 b0 01             	mov    r8b,0x1
  216cf9:	45 31 db             	xor    r11d,r11d
  216cfc:	e9 2a 01 00 00       	jmp    216e2b <Benchmark_reportStats+0x6eb>
  216d01:	4c 8d 43 20          	lea    r8,[rbx+0x20]
  216d05:	4c 8d 4b 10          	lea    r9,[rbx+0x10]
  216d09:	48 8b 43 20          	mov    rax,QWORD PTR [rbx+0x20]
  216d0d:	48 3b 43 10          	cmp    rax,QWORD PTR [rbx+0x10]
  216d11:	0f 83 a4 01 00 00    	jae    216ebb <Benchmark_reportStats+0x77b>
    const tmp = a.*;
  216d17:	c4 c1 78 10 01       	vmovups xmm0,XMMWORD PTR [r9]
  216d1c:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  216d23:	00 00 
    a.* = b.*;
  216d25:	c4 c1 78 10 00       	vmovups xmm0,XMMWORD PTR [r8]
  216d2a:	c4 c1 78 11 01       	vmovups XMMWORD PTR [r9],xmm0
    b.* = tmp;
  216d2f:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  216d36:	00 00 
  216d38:	c4 c1 7a 7f 00       	vmovdqu XMMWORD PTR [r8],xmm0
  216d3d:	41 b7 02             	mov    r15b,0x2
  216d40:	b0 01                	mov    al,0x1
  216d42:	e9 79 01 00 00       	jmp    216ec0 <Benchmark_reportStats+0x780>
  216d47:	48 8d 7b 20          	lea    rdi,[rbx+0x20]
  216d4b:	4c 8d 7b 10          	lea    r15,[rbx+0x10]
  216d4f:	48 8b 43 20          	mov    rax,QWORD PTR [rbx+0x20]
  216d53:	48 3b 43 10          	cmp    rax,QWORD PTR [rbx+0x10]
  216d57:	0f 83 bd 01 00 00    	jae    216f1a <Benchmark_reportStats+0x7da>
    const tmp = a.*;
  216d5d:	c4 c1 78 10 07       	vmovups xmm0,XMMWORD PTR [r15]
  216d62:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  216d69:	00 00 
    a.* = b.*;
  216d6b:	c5 f8 10 07          	vmovups xmm0,XMMWORD PTR [rdi]
  216d6f:	c4 c1 78 11 07       	vmovups XMMWORD PTR [r15],xmm0
    b.* = tmp;
  216d74:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  216d7b:	00 00 
  216d7d:	c5 fa 7f 07          	vmovdqu XMMWORD PTR [rdi],xmm0
  216d81:	b0 02                	mov    al,0x2
  216d83:	41 b4 01             	mov    r12b,0x1
  216d86:	e9 94 01 00 00       	jmp    216f1f <Benchmark_reportStats+0x7df>
  216d8b:	4c 8d 63 10          	lea    r12,[rbx+0x10]
  216d8f:	48 8b 43 10          	mov    rax,QWORD PTR [rbx+0x10]
  216d93:	48 3b 03             	cmp    rax,QWORD PTR [rbx]
  216d96:	0f 83 cd 01 00 00    	jae    216f69 <Benchmark_reportStats+0x829>
    const tmp = a.*;
  216d9c:	c5 f8 10 03          	vmovups xmm0,XMMWORD PTR [rbx]
  216da0:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  216da7:	00 00 
    a.* = b.*;
  216da9:	c4 c1 78 10 04 24    	vmovups xmm0,XMMWORD PTR [r12]
  216daf:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
    b.* = tmp;
  216db3:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  216dba:	00 00 
  216dbc:	c4 c1 7a 7f 04 24    	vmovdqu XMMWORD PTR [r12],xmm0
  216dc2:	b0 01                	mov    al,0x1
  216dc4:	89 44 24 20          	mov    DWORD PTR [rsp+0x20],eax
  216dc8:	45 31 c9             	xor    r9d,r9d
  216dcb:	e9 a4 01 00 00       	jmp    216f74 <Benchmark_reportStats+0x834>
  216dd0:	41 b6 01             	mov    r14b,0x1
  216dd3:	45 31 db             	xor    r11d,r11d
  216dd6:	48 8d 53 30          	lea    rdx,[rbx+0x30]
  216dda:	48 8d 4b 20          	lea    rcx,[rbx+0x20]
  216dde:	48 8b 7b 20          	mov    rdi,QWORD PTR [rbx+0x20]
  216de2:	48 39 7b 30          	cmp    QWORD PTR [rbx+0x30],rdi
  216de6:	0f 83 cf 01 00 00    	jae    216fbb <Benchmark_reportStats+0x87b>
    const tmp = a.*;
  216dec:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  216df0:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  216df7:	00 00 
    a.* = b.*;
  216df9:	c5 f8 10 02          	vmovups xmm0,XMMWORD PTR [rdx]
  216dfd:	c5 f8 11 01          	vmovups XMMWORD PTR [rcx],xmm0
    b.* = tmp;
  216e01:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  216e08:	00 00 
  216e0a:	c5 fa 7f 02          	vmovdqu XMMWORD PTR [rdx],xmm0
  216e0e:	48 8b 39             	mov    rdi,QWORD PTR [rcx]
  216e11:	41 b0 03             	mov    r8b,0x3
  216e14:	41 b1 02             	mov    r9b,0x2
  216e17:	48 3b 3b             	cmp    rdi,QWORD PTR [rbx]
  216e1a:	0f 82 a6 01 00 00    	jb     216fc6 <Benchmark_reportStats+0x886>
  216e20:	e9 c6 01 00 00       	jmp    216feb <Benchmark_reportStats+0x8ab>
  216e25:	41 b3 01             	mov    r11b,0x1
  216e28:	45 31 c0             	xor    r8d,r8d
  216e2b:	48 8d 73 40          	lea    rsi,[rbx+0x40]
  216e2f:	4c 8d 6b 30          	lea    r13,[rbx+0x30]
  216e33:	48 8b 4b 40          	mov    rcx,QWORD PTR [rbx+0x40]
  216e37:	48 3b 4b 30          	cmp    rcx,QWORD PTR [rbx+0x30]
  216e3b:	0f 83 32 02 00 00    	jae    217073 <Benchmark_reportStats+0x933>
    const tmp = a.*;
  216e41:	c4 c1 78 10 45 00    	vmovups xmm0,XMMWORD PTR [r13+0x0]
  216e47:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  216e4e:	00 00 
    a.* = b.*;
  216e50:	c5 f8 10 06          	vmovups xmm0,XMMWORD PTR [rsi]
  216e54:	c4 c1 78 11 45 00    	vmovups XMMWORD PTR [r13+0x0],xmm0
    b.* = tmp;
  216e5a:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  216e61:	00 00 
  216e63:	c5 fa 7f 06          	vmovdqu XMMWORD PTR [rsi],xmm0
  216e67:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  216e6a:	41 b1 04             	mov    r9b,0x4
  216e6d:	b2 03                	mov    dl,0x3
  216e6f:	48 8d 7b 20          	lea    rdi,[rbx+0x20]
  216e73:	48 8b 43 20          	mov    rax,QWORD PTR [rbx+0x20]
  216e77:	48 39 c1             	cmp    rcx,rax
  216e7a:	0f 82 09 02 00 00    	jb     217089 <Benchmark_reportStats+0x949>
  216e80:	41 89 d7             	mov    r15d,edx
  216e83:	b2 02                	mov    dl,0x2
  216e85:	49 8b 4d 00          	mov    rcx,QWORD PTR [r13+0x0]
  216e89:	48 39 c1             	cmp    rcx,rax
  216e8c:	0f 82 2c 02 00 00    	jb     2170be <Benchmark_reportStats+0x97e>
  216e92:	44 38 ca             	cmp    dl,r9b
  216e95:	76 09                	jbe    216ea0 <Benchmark_reportStats+0x760>
  216e97:	48 39 c8             	cmp    rax,rcx
  216e9a:	0f 83 1e 02 00 00    	jae    2170be <Benchmark_reportStats+0x97e>
  216ea0:	45 89 ce             	mov    r14d,r9d
  216ea3:	41 89 d1             	mov    r9d,edx
  216ea6:	48 8b 06             	mov    rax,QWORD PTR [rsi]
  216ea9:	49 8b 0c 24          	mov    rcx,QWORD PTR [r12]
  216ead:	48 39 c8             	cmp    rax,rcx
  216eb0:	0f 83 3d 02 00 00    	jae    2170f3 <Benchmark_reportStats+0x9b3>
  216eb6:	e9 42 02 00 00       	jmp    2170fd <Benchmark_reportStats+0x9bd>
  216ebb:	41 b7 01             	mov    r15b,0x1
  216ebe:	b0 02                	mov    al,0x2
  216ec0:	89 44 24 10          	mov    DWORD PTR [rsp+0x10],eax
  216ec4:	4c 8d 73 50          	lea    r14,[rbx+0x50]
  216ec8:	48 8d 7b 40          	lea    rdi,[rbx+0x40]
  216ecc:	48 8b 43 50          	mov    rax,QWORD PTR [rbx+0x50]
  216ed0:	48 3b 43 40          	cmp    rax,QWORD PTR [rbx+0x40]
  216ed4:	0f 83 04 03 00 00    	jae    2171de <Benchmark_reportStats+0xa9e>
    const tmp = a.*;
  216eda:	c5 f8 10 07          	vmovups xmm0,XMMWORD PTR [rdi]
  216ede:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  216ee5:	00 00 
    a.* = b.*;
  216ee7:	c4 c1 78 10 06       	vmovups xmm0,XMMWORD PTR [r14]
  216eec:	c5 f8 11 07          	vmovups XMMWORD PTR [rdi],xmm0
    b.* = tmp;
  216ef0:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  216ef7:	00 00 
  216ef9:	c4 c1 7a 7f 06       	vmovdqu XMMWORD PTR [r14],xmm0
  216efe:	c6 44 24 20 05       	mov    BYTE PTR [rsp+0x20],0x5
  216f03:	41 b4 04             	mov    r12b,0x4
  216f06:	48 8b 43 20          	mov    rax,QWORD PTR [rbx+0x20]
  216f0a:	48 3b 03             	cmp    rax,QWORD PTR [rbx]
  216f0d:	0f 82 e0 02 00 00    	jb     2171f3 <Benchmark_reportStats+0xab3>
  216f13:	31 c9                	xor    ecx,ecx
  216f15:	e9 0b 03 00 00       	jmp    217225 <Benchmark_reportStats+0xae5>
  216f1a:	b0 01                	mov    al,0x1
  216f1c:	41 b4 02             	mov    r12b,0x2
  216f1f:	88 44 24 58          	mov    BYTE PTR [rsp+0x58],al
  216f23:	4c 8d 5b 40          	lea    r11,[rbx+0x40]
  216f27:	4c 8d 4b 30          	lea    r9,[rbx+0x30]
  216f2b:	48 8b 43 40          	mov    rax,QWORD PTR [rbx+0x40]
  216f2f:	48 3b 43 30          	cmp    rax,QWORD PTR [rbx+0x30]
  216f33:	0f 83 68 03 00 00    	jae    2172a1 <Benchmark_reportStats+0xb61>
    const tmp = a.*;
  216f39:	c4 c1 78 10 01       	vmovups xmm0,XMMWORD PTR [r9]
  216f3e:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  216f45:	00 00 
    a.* = b.*;
  216f47:	c4 c1 78 10 03       	vmovups xmm0,XMMWORD PTR [r11]
  216f4c:	c4 c1 78 11 01       	vmovups XMMWORD PTR [r9],xmm0
    b.* = tmp;
  216f51:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  216f58:	00 00 
  216f5a:	c4 c1 7a 7f 03       	vmovdqu XMMWORD PTR [r11],xmm0
  216f5f:	41 b6 04             	mov    r14b,0x4
  216f62:	b0 03                	mov    al,0x3
  216f64:	e9 3d 03 00 00       	jmp    2172a6 <Benchmark_reportStats+0xb66>
  216f69:	41 b1 01             	mov    r9b,0x1
  216f6c:	c7 44 24 20 00 00 00 	mov    DWORD PTR [rsp+0x20],0x0
  216f73:	00 
  216f74:	48 8d 7b 30          	lea    rdi,[rbx+0x30]
  216f78:	4c 8d 5b 20          	lea    r11,[rbx+0x20]
  216f7c:	48 8b 43 30          	mov    rax,QWORD PTR [rbx+0x30]
  216f80:	48 3b 43 20          	cmp    rax,QWORD PTR [rbx+0x20]
  216f84:	0f 83 82 03 00 00    	jae    21730c <Benchmark_reportStats+0xbcc>
    const tmp = a.*;
  216f8a:	c4 c1 78 10 03       	vmovups xmm0,XMMWORD PTR [r11]
  216f8f:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  216f96:	00 00 
    a.* = b.*;
  216f98:	c5 f8 10 07          	vmovups xmm0,XMMWORD PTR [rdi]
  216f9c:	c4 c1 78 11 03       	vmovups XMMWORD PTR [r11],xmm0
    b.* = tmp;
  216fa1:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  216fa8:	00 00 
  216faa:	c5 fa 7f 07          	vmovdqu XMMWORD PTR [rdi],xmm0
  216fae:	41 b0 03             	mov    r8b,0x3
  216fb1:	c6 44 24 10 02       	mov    BYTE PTR [rsp+0x10],0x2
  216fb6:	e9 59 03 00 00       	jmp    217314 <Benchmark_reportStats+0xbd4>
  216fbb:	41 b0 02             	mov    r8b,0x2
  216fbe:	41 b1 03             	mov    r9b,0x3
  216fc1:	48 3b 3b             	cmp    rdi,QWORD PTR [rbx]
  216fc4:	73 25                	jae    216feb <Benchmark_reportStats+0x8ab>
    const tmp = a.*;
  216fc6:	c5 f8 10 03          	vmovups xmm0,XMMWORD PTR [rbx]
  216fca:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  216fd1:	00 00 
    a.* = b.*;
  216fd3:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  216fd7:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
    b.* = tmp;
  216fdb:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  216fe2:	00 00 
  216fe4:	c5 fa 7f 01          	vmovdqu XMMWORD PTR [rcx],xmm0
  216fe8:	45 89 d8             	mov    r8d,r11d
  216feb:	48 8b 38             	mov    rdi,QWORD PTR [rax]
  216fee:	48 39 3a             	cmp    QWORD PTR [rdx],rdi
  216ff1:	73 43                	jae    217036 <Benchmark_reportStats+0x8f6>
    const tmp = a.*;
  216ff3:	c5 f8 10 00          	vmovups xmm0,XMMWORD PTR [rax]
  216ff7:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  216ffe:	00 00 
    a.* = b.*;
  217000:	c5 f8 10 02          	vmovups xmm0,XMMWORD PTR [rdx]
  217004:	c5 f8 11 00          	vmovups XMMWORD PTR [rax],xmm0
    b.* = tmp;
  217008:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  21700f:	00 00 
  217011:	c5 fa 7f 02          	vmovdqu XMMWORD PTR [rdx],xmm0
  217015:	48 8b 38             	mov    rdi,QWORD PTR [rax]
  217018:	45 89 ce             	mov    r14d,r9d
  21701b:	48 8b 11             	mov    rdx,QWORD PTR [rcx]
  21701e:	48 39 fa             	cmp    rdx,rdi
  217021:	72 1b                	jb     21703e <Benchmark_reportStats+0x8fe>
  217023:	45 38 c6             	cmp    r14b,r8b
  217026:	0f 86 c4 0f 00 00    	jbe    217ff0 <Benchmark_reportStats+0x18b0>
  21702c:	48 39 d7             	cmp    rdi,rdx
  21702f:	73 0d                	jae    21703e <Benchmark_reportStats+0x8fe>
  217031:	e9 ba 0f 00 00       	jmp    217ff0 <Benchmark_reportStats+0x18b0>
  217036:	48 8b 11             	mov    rdx,QWORD PTR [rcx]
  217039:	48 39 fa             	cmp    rdx,rdi
  21703c:	73 e5                	jae    217023 <Benchmark_reportStats+0x8e3>
    const tmp = a.*;
  21703e:	c5 f8 10 00          	vmovups xmm0,XMMWORD PTR [rax]
  217042:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  217049:	00 00 
    a.* = b.*;
  21704b:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  21704f:	c5 f8 11 00          	vmovups XMMWORD PTR [rax],xmm0
    b.* = tmp;
  217053:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  21705a:	00 00 
  21705c:	c5 fa 7f 01          	vmovdqu XMMWORD PTR [rcx],xmm0
        return self.decimal >= self.size;
  217060:	4c 3b 94 24 f0 00 00 	cmp    r10,QWORD PTR [rsp+0xf0]
  217067:	00 
  217068:	0f 82 a2 fb ff ff    	jb     216c10 <Benchmark_reportStats+0x4d0>
  21706e:	e9 a6 0f 00 00       	jmp    218019 <Benchmark_reportStats+0x18d9>
  217073:	41 b1 03             	mov    r9b,0x3
  217076:	b2 04                	mov    dl,0x4
    if (lessThan(items[y], items[x]) or ((order.*)[x] > (order.*)[y] and !lessThan(items[x], items[y]))) {
  217078:	48 8d 7b 20          	lea    rdi,[rbx+0x20]
  21707c:	48 8b 43 20          	mov    rax,QWORD PTR [rbx+0x20]
  217080:	48 39 c1             	cmp    rcx,rax
  217083:	0f 83 f7 fd ff ff    	jae    216e80 <Benchmark_reportStats+0x740>
    const tmp = a.*;
  217089:	c5 f8 10 07          	vmovups xmm0,XMMWORD PTR [rdi]
  21708d:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  217094:	00 00 
    a.* = b.*;
  217096:	c5 f8 10 06          	vmovups xmm0,XMMWORD PTR [rsi]
  21709a:	c5 f8 11 07          	vmovups XMMWORD PTR [rdi],xmm0
    b.* = tmp;
  21709e:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  2170a5:	00 00 
  2170a7:	c5 fa 7f 06          	vmovdqu XMMWORD PTR [rsi],xmm0
  2170ab:	48 8b 07             	mov    rax,QWORD PTR [rdi]
  2170ae:	41 b7 02             	mov    r15b,0x2
  2170b1:	49 8b 4d 00          	mov    rcx,QWORD PTR [r13+0x0]
  2170b5:	48 39 c1             	cmp    rcx,rax
  2170b8:	0f 83 d4 fd ff ff    	jae    216e92 <Benchmark_reportStats+0x752>
    const tmp = a.*;
  2170be:	c5 f8 10 07          	vmovups xmm0,XMMWORD PTR [rdi]
  2170c2:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  2170c9:	00 00 
    a.* = b.*;
  2170cb:	c4 c1 78 10 45 00    	vmovups xmm0,XMMWORD PTR [r13+0x0]
  2170d1:	c5 f8 11 07          	vmovups XMMWORD PTR [rdi],xmm0
    b.* = tmp;
  2170d5:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  2170dc:	00 00 
  2170de:	c4 c1 7a 7f 45 00    	vmovdqu XMMWORD PTR [r13+0x0],xmm0
  2170e4:	41 89 d6             	mov    r14d,edx
  2170e7:	48 8b 06             	mov    rax,QWORD PTR [rsi]
  2170ea:	49 8b 0c 24          	mov    rcx,QWORD PTR [r12]
  2170ee:	48 39 c8             	cmp    rax,rcx
  2170f1:	72 0a                	jb     2170fd <Benchmark_reportStats+0x9bd>
  2170f3:	45 38 fb             	cmp    r11b,r15b
  2170f6:	76 2e                	jbe    217126 <Benchmark_reportStats+0x9e6>
  2170f8:	48 39 c1             	cmp    rcx,rax
  2170fb:	72 29                	jb     217126 <Benchmark_reportStats+0x9e6>
    const tmp = a.*;
  2170fd:	c4 c1 78 10 04 24    	vmovups xmm0,XMMWORD PTR [r12]
  217103:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  21710a:	00 00 
    a.* = b.*;
  21710c:	c5 f8 10 06          	vmovups xmm0,XMMWORD PTR [rsi]
  217110:	c4 c1 78 11 04 24    	vmovups XMMWORD PTR [r12],xmm0
    b.* = tmp;
  217116:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  21711d:	00 00 
  21711f:	c5 fa 7f 06          	vmovdqu XMMWORD PTR [rsi],xmm0
  217123:	45 89 fb             	mov    r11d,r15d
  217126:	48 8b 13             	mov    rdx,QWORD PTR [rbx]
  217129:	48 8b 43 30          	mov    rax,QWORD PTR [rbx+0x30]
  21712d:	48 39 d0             	cmp    rax,rdx
  217130:	4c 8b bc 24 00 01 00 	mov    r15,QWORD PTR [rsp+0x100]
  217137:	00 
  217138:	48 8b 74 24 38       	mov    rsi,QWORD PTR [rsp+0x38]
  21713d:	72 12                	jb     217151 <Benchmark_reportStats+0xa11>
  21713f:	45 38 f0             	cmp    r8b,r14b
  217142:	0f 86 de 05 00 00    	jbe    217726 <Benchmark_reportStats+0xfe6>
  217148:	48 39 c2             	cmp    rdx,rax
  21714b:	0f 82 d5 05 00 00    	jb     217726 <Benchmark_reportStats+0xfe6>
    const tmp = a.*;
  217151:	c5 f8 10 03          	vmovups xmm0,XMMWORD PTR [rbx]
  217155:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  21715c:	00 00 
    a.* = b.*;
  21715e:	c4 c1 78 10 45 00    	vmovups xmm0,XMMWORD PTR [r13+0x0]
  217164:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
    b.* = tmp;
  217168:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  21716f:	00 00 
  217171:	c4 c1 7a 7f 45 00    	vmovdqu XMMWORD PTR [r13+0x0],xmm0
  217177:	48 8b 13             	mov    rdx,QWORD PTR [rbx]
  21717a:	44 89 f0             	mov    eax,r14d
  21717d:	48 8b 0f             	mov    rcx,QWORD PTR [rdi]
  217180:	48 39 d1             	cmp    rcx,rdx
  217183:	0f 82 af 05 00 00    	jb     217738 <Benchmark_reportStats+0xff8>
  217189:	44 38 c8             	cmp    al,r9b
  21718c:	76 09                	jbe    217197 <Benchmark_reportStats+0xa57>
  21718e:	48 39 ca             	cmp    rdx,rcx
  217191:	0f 83 a1 05 00 00    	jae    217738 <Benchmark_reportStats+0xff8>
  217197:	49 8b 45 00          	mov    rax,QWORD PTR [r13+0x0]
  21719b:	49 8b 14 24          	mov    rdx,QWORD PTR [r12]
  21719f:	48 39 d0             	cmp    rax,rdx
  2171a2:	0f 82 c6 05 00 00    	jb     21776e <Benchmark_reportStats+0x102e>
  2171a8:	45 38 c3             	cmp    r11b,r8b
  2171ab:	76 09                	jbe    2171b6 <Benchmark_reportStats+0xa76>
  2171ad:	48 39 c2             	cmp    rdx,rax
  2171b0:	0f 83 b8 05 00 00    	jae    21776e <Benchmark_reportStats+0x102e>
  2171b6:	48 8b 07             	mov    rax,QWORD PTR [rdi]
  2171b9:	48 39 d0             	cmp    rax,rdx
  2171bc:	4c 8b 6c 24 18       	mov    r13,QWORD PTR [rsp+0x18]
  2171c1:	0f 82 e9 05 00 00    	jb     2177b0 <Benchmark_reportStats+0x1070>
  2171c7:	45 38 cb             	cmp    r11b,r9b
  2171ca:	0f 86 20 0e 00 00    	jbe    217ff0 <Benchmark_reportStats+0x18b0>
  2171d0:	48 39 c2             	cmp    rdx,rax
  2171d3:	0f 83 d7 05 00 00    	jae    2177b0 <Benchmark_reportStats+0x1070>
  2171d9:	e9 12 0e 00 00       	jmp    217ff0 <Benchmark_reportStats+0x18b0>
  2171de:	c6 44 24 20 04       	mov    BYTE PTR [rsp+0x20],0x4
  2171e3:	41 b4 05             	mov    r12b,0x5
  2171e6:	48 8b 43 20          	mov    rax,QWORD PTR [rbx+0x20]
  2171ea:	48 3b 03             	cmp    rax,QWORD PTR [rbx]
  2171ed:	0f 83 20 fd ff ff    	jae    216f13 <Benchmark_reportStats+0x7d3>
    const tmp = a.*;
  2171f3:	c5 f8 10 03          	vmovups xmm0,XMMWORD PTR [rbx]
  2171f7:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  2171fe:	00 00 
    a.* = b.*;
  217200:	c4 c1 78 10 00       	vmovups xmm0,XMMWORD PTR [r8]
  217205:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
    b.* = tmp;
  217209:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  217210:	00 00 
  217212:	c4 c1 7a 7f 00       	vmovdqu XMMWORD PTR [r8],xmm0
  217217:	8b 44 24 10          	mov    eax,DWORD PTR [rsp+0x10]
  21721b:	89 c1                	mov    ecx,eax
  21721d:	c7 44 24 10 00 00 00 	mov    DWORD PTR [rsp+0x10],0x0
  217224:	00 
  217225:	4c 89 6c 24 18       	mov    QWORD PTR [rsp+0x18],r13
  21722a:	4c 8d 5b 30          	lea    r11,[rbx+0x30]
  21722e:	48 8b 43 50          	mov    rax,QWORD PTR [rbx+0x50]
  217232:	48 3b 43 30          	cmp    rax,QWORD PTR [rbx+0x30]
  217236:	0f 83 2d 01 00 00    	jae    217369 <Benchmark_reportStats+0xc29>
    const tmp = a.*;
  21723c:	c4 c1 78 10 03       	vmovups xmm0,XMMWORD PTR [r11]
  217241:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  217248:	00 00 
    a.* = b.*;
  21724a:	c4 c1 78 10 06       	vmovups xmm0,XMMWORD PTR [r14]
  21724f:	c4 c1 78 11 03       	vmovups XMMWORD PTR [r11],xmm0
    b.* = tmp;
  217254:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  21725b:	00 00 
  21725d:	c4 c1 7a 7f 06       	vmovdqu XMMWORD PTR [r14],xmm0
  217262:	41 b5 03             	mov    r13b,0x3
  217265:	48 8b 13             	mov    rdx,QWORD PTR [rbx]
  217268:	48 8b 43 10          	mov    rax,QWORD PTR [rbx+0x10]
  21726c:	48 39 d0             	cmp    rax,rdx
  21726f:	0f 82 0a 01 00 00    	jb     21737f <Benchmark_reportStats+0xc3f>
  217275:	44 38 f9             	cmp    cl,r15b
  217278:	76 09                	jbe    217283 <Benchmark_reportStats+0xb43>
  21727a:	48 39 c2             	cmp    rdx,rax
  21727d:	0f 83 fc 00 00 00    	jae    21737f <Benchmark_reportStats+0xc3f>
  217283:	44 89 f8             	mov    eax,r15d
  217286:	41 89 cf             	mov    r15d,ecx
  217289:	89 44 24 30          	mov    DWORD PTR [rsp+0x30],eax
  21728d:	48 8b 17             	mov    rdx,QWORD PTR [rdi]
  217290:	49 8b 03             	mov    rax,QWORD PTR [r11]
  217293:	48 39 c2             	cmp    rdx,rax
  217296:	0f 83 16 01 00 00    	jae    2173b2 <Benchmark_reportStats+0xc72>
  21729c:	e9 25 01 00 00       	jmp    2173c6 <Benchmark_reportStats+0xc86>
  2172a1:	41 b6 03             	mov    r14b,0x3
  2172a4:	b0 04                	mov    al,0x4
  2172a6:	4c 89 6c 24 18       	mov    QWORD PTR [rsp+0x18],r13
  2172ab:	4c 8d 43 60          	lea    r8,[rbx+0x60]
  2172af:	48 8d 4b 50          	lea    rcx,[rbx+0x50]
  2172b3:	48 8b 53 60          	mov    rdx,QWORD PTR [rbx+0x60]
  2172b7:	48 3b 53 50          	cmp    rdx,QWORD PTR [rbx+0x50]
  2172bb:	0f 83 33 01 00 00    	jae    2173f4 <Benchmark_reportStats+0xcb4>
    const tmp = a.*;
  2172c1:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  2172c5:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  2172cc:	00 00 
    a.* = b.*;
  2172ce:	c4 c1 78 10 00       	vmovups xmm0,XMMWORD PTR [r8]
  2172d3:	c5 f8 11 01          	vmovups XMMWORD PTR [rcx],xmm0
    b.* = tmp;
  2172d7:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  2172de:	00 00 
  2172e0:	c4 c1 7a 7f 00       	vmovdqu XMMWORD PTR [r8],xmm0
  2172e5:	c6 44 24 20 06       	mov    BYTE PTR [rsp+0x20],0x6
  2172ea:	41 b5 05             	mov    r13b,0x5
  2172ed:	48 8b 53 20          	mov    rdx,QWORD PTR [rbx+0x20]
  2172f1:	48 3b 13             	cmp    rdx,QWORD PTR [rbx]
  2172f4:	48 89 74 24 38       	mov    QWORD PTR [rsp+0x38],rsi
  2172f9:	0f 82 0f 01 00 00    	jb     21740e <Benchmark_reportStats+0xcce>
  2172ff:	c7 44 24 10 00 00 00 	mov    DWORD PTR [rsp+0x10],0x0
  217306:	00 
  217307:	e9 2c 01 00 00       	jmp    217438 <Benchmark_reportStats+0xcf8>
  21730c:	41 b0 02             	mov    r8b,0x2
  21730f:	c6 44 24 10 03       	mov    BYTE PTR [rsp+0x10],0x3
  217314:	4c 8d 7b 50          	lea    r15,[rbx+0x50]
  217318:	4c 8d 73 40          	lea    r14,[rbx+0x40]
  21731c:	48 8b 43 50          	mov    rax,QWORD PTR [rbx+0x50]
  217320:	48 3b 43 40          	cmp    rax,QWORD PTR [rbx+0x40]
  217324:	48 89 74 24 38       	mov    QWORD PTR [rsp+0x38],rsi
  217329:	4c 89 6c 24 18       	mov    QWORD PTR [rsp+0x18],r13
  21732e:	0f 83 77 01 00 00    	jae    2174ab <Benchmark_reportStats+0xd6b>
    const tmp = a.*;
  217334:	c4 c1 78 10 06       	vmovups xmm0,XMMWORD PTR [r14]
  217339:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  217340:	00 00 
    a.* = b.*;
  217342:	c4 c1 78 10 07       	vmovups xmm0,XMMWORD PTR [r15]
  217347:	c4 c1 78 11 06       	vmovups XMMWORD PTR [r14],xmm0
    b.* = tmp;
  21734c:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  217353:	00 00 
  217355:	c4 c1 7a 7f 07       	vmovdqu XMMWORD PTR [r15],xmm0
  21735a:	c6 44 24 50 05       	mov    BYTE PTR [rsp+0x50],0x5
  21735f:	c6 44 24 58 04       	mov    BYTE PTR [rsp+0x58],0x4
  217364:	e9 4c 01 00 00       	jmp    2174b5 <Benchmark_reportStats+0xd75>
  217369:	45 89 e5             	mov    r13d,r12d
  21736c:	41 b4 03             	mov    r12b,0x3
  21736f:	48 8b 13             	mov    rdx,QWORD PTR [rbx]
  217372:	48 8b 43 10          	mov    rax,QWORD PTR [rbx+0x10]
  217376:	48 39 d0             	cmp    rax,rdx
  217379:	0f 83 f6 fe ff ff    	jae    217275 <Benchmark_reportStats+0xb35>
  21737f:	89 4c 24 30          	mov    DWORD PTR [rsp+0x30],ecx
    const tmp = a.*;
  217383:	c5 f8 10 03          	vmovups xmm0,XMMWORD PTR [rbx]
  217387:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  21738e:	00 00 
    a.* = b.*;
  217390:	c4 c1 78 10 01       	vmovups xmm0,XMMWORD PTR [r9]
  217395:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
    b.* = tmp;
  217399:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  2173a0:	00 00 
  2173a2:	c4 c1 7a 7f 01       	vmovdqu XMMWORD PTR [r9],xmm0
  2173a7:	48 8b 17             	mov    rdx,QWORD PTR [rdi]
  2173aa:	49 8b 03             	mov    rax,QWORD PTR [r11]
  2173ad:	48 39 c2             	cmp    rdx,rax
  2173b0:	72 14                	jb     2173c6 <Benchmark_reportStats+0xc86>
  2173b2:	44 3a 64 24 20       	cmp    r12b,BYTE PTR [rsp+0x20]
  2173b7:	0f 86 2c 04 00 00    	jbe    2177e9 <Benchmark_reportStats+0x10a9>
  2173bd:	48 39 d0             	cmp    rax,rdx
  2173c0:	0f 82 23 04 00 00    	jb     2177e9 <Benchmark_reportStats+0x10a9>
    const tmp = a.*;
  2173c6:	c4 c1 78 10 03       	vmovups xmm0,XMMWORD PTR [r11]
  2173cb:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  2173d2:	00 00 
    a.* = b.*;
  2173d4:	c5 f8 10 07          	vmovups xmm0,XMMWORD PTR [rdi]
  2173d8:	c4 c1 78 11 03       	vmovups XMMWORD PTR [r11],xmm0
    b.* = tmp;
  2173dd:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  2173e4:	00 00 
  2173e6:	c5 fa 7f 07          	vmovdqu XMMWORD PTR [rdi],xmm0
  2173ea:	44 88 64 24 28       	mov    BYTE PTR [rsp+0x28],r12b
  2173ef:	e9 03 04 00 00       	jmp    2177f7 <Benchmark_reportStats+0x10b7>
  2173f4:	c6 44 24 20 05       	mov    BYTE PTR [rsp+0x20],0x5
  2173f9:	41 b5 06             	mov    r13b,0x6
  2173fc:	48 8b 53 20          	mov    rdx,QWORD PTR [rbx+0x20]
  217400:	48 3b 13             	cmp    rdx,QWORD PTR [rbx]
  217403:	48 89 74 24 38       	mov    QWORD PTR [rsp+0x38],rsi
  217408:	0f 83 f1 fe ff ff    	jae    2172ff <Benchmark_reportStats+0xbbf>
    const tmp = a.*;
  21740e:	c5 f8 10 03          	vmovups xmm0,XMMWORD PTR [rbx]
  217412:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  217419:	00 00 
    a.* = b.*;
  21741b:	c5 f8 10 07          	vmovups xmm0,XMMWORD PTR [rdi]
  21741f:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
    b.* = tmp;
  217423:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  21742a:	00 00 
  21742c:	c5 fa 7f 07          	vmovdqu XMMWORD PTR [rdi],xmm0
  217430:	44 89 64 24 10       	mov    DWORD PTR [rsp+0x10],r12d
  217435:	45 31 e4             	xor    r12d,r12d
  217438:	48 8b 11             	mov    rdx,QWORD PTR [rcx]
  21743b:	49 8b 31             	mov    rsi,QWORD PTR [r9]
  21743e:	48 39 f2             	cmp    rdx,rsi
  217441:	44 89 64 24 30       	mov    DWORD PTR [rsp+0x30],r12d
  217446:	72 14                	jb     21745c <Benchmark_reportStats+0xd1c>
  217448:	44 3a 74 24 20       	cmp    r14b,BYTE PTR [rsp+0x20]
  21744d:	0f 86 e2 04 00 00    	jbe    217935 <Benchmark_reportStats+0x11f5>
  217453:	48 39 d6             	cmp    rsi,rdx
  217456:	0f 82 d9 04 00 00    	jb     217935 <Benchmark_reportStats+0x11f5>
    const tmp = a.*;
  21745c:	c4 c1 78 10 01       	vmovups xmm0,XMMWORD PTR [r9]
  217461:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  217468:	00 00 
    a.* = b.*;
  21746a:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  21746e:	c4 c1 78 11 01       	vmovups XMMWORD PTR [r9],xmm0
    b.* = tmp;
  217473:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  21747a:	00 00 
  21747c:	c5 fa 7f 01          	vmovdqu XMMWORD PTR [rcx],xmm0
  217480:	45 89 f4             	mov    r12d,r14d
  217483:	49 8b 10             	mov    rdx,QWORD PTR [r8]
  217486:	49 8b 33             	mov    rsi,QWORD PTR [r11]
  217489:	48 39 f2             	cmp    rdx,rsi
  21748c:	0f 82 bd 04 00 00    	jb     21794f <Benchmark_reportStats+0x120f>
  217492:	44 38 e8             	cmp    al,r13b
  217495:	76 09                	jbe    2174a0 <Benchmark_reportStats+0xd60>
  217497:	48 39 d6             	cmp    rsi,rdx
  21749a:	0f 83 af 04 00 00    	jae    21794f <Benchmark_reportStats+0x120f>
  2174a0:	45 89 ee             	mov    r14d,r13d
  2174a3:	41 89 c5             	mov    r13d,eax
  2174a6:	e9 cd 04 00 00       	jmp    217978 <Benchmark_reportStats+0x1238>
  2174ab:	c6 44 24 50 04       	mov    BYTE PTR [rsp+0x50],0x4
  2174b0:	c6 44 24 58 05       	mov    BYTE PTR [rsp+0x58],0x5
  2174b5:	4c 8d 6b 70          	lea    r13,[rbx+0x70]
  2174b9:	48 8d 73 60          	lea    rsi,[rbx+0x60]
  2174bd:	48 8b 53 70          	mov    rdx,QWORD PTR [rbx+0x70]
  2174c1:	48 3b 53 60          	cmp    rdx,QWORD PTR [rbx+0x60]
  2174c5:	0f 83 df 00 00 00    	jae    2175aa <Benchmark_reportStats+0xe6a>
    const tmp = a.*;
  2174cb:	c5 f8 10 06          	vmovups xmm0,XMMWORD PTR [rsi]
  2174cf:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  2174d6:	00 00 
    a.* = b.*;
  2174d8:	c4 c1 78 10 45 00    	vmovups xmm0,XMMWORD PTR [r13+0x0]
  2174de:	c5 f8 11 06          	vmovups XMMWORD PTR [rsi],xmm0
    b.* = tmp;
  2174e2:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  2174e9:	00 00 
  2174eb:	c4 c1 7a 7f 45 00    	vmovdqu XMMWORD PTR [r13+0x0],xmm0
  2174f1:	c6 44 24 28 07       	mov    BYTE PTR [rsp+0x28],0x7
  2174f6:	b1 06                	mov    cl,0x6
  2174f8:	48 8b 53 20          	mov    rdx,QWORD PTR [rbx+0x20]
  2174fc:	48 3b 13             	cmp    rdx,QWORD PTR [rbx]
  2174ff:	0f 82 b9 00 00 00    	jb     2175be <Benchmark_reportStats+0xe7e>
  217505:	8b 54 24 20          	mov    edx,DWORD PTR [rsp+0x20]
  217509:	89 d0                	mov    eax,edx
  21750b:	88 44 24 60          	mov    BYTE PTR [rsp+0x60],al
  21750f:	44 89 c2             	mov    edx,r8d
  217512:	89 54 24 20          	mov    DWORD PTR [rsp+0x20],edx
  217516:	48 8b 17             	mov    rdx,QWORD PTR [rdi]
  217519:	49 3b 14 24          	cmp    rdx,QWORD PTR [r12]
  21751d:	0f 82 d1 00 00 00    	jb     2175f4 <Benchmark_reportStats+0xeb4>
  217523:	0f b6 54 24 10       	movzx  edx,BYTE PTR [rsp+0x10]
  217528:	44 89 c8             	mov    eax,r9d
  21752b:	88 44 24 10          	mov    BYTE PTR [rsp+0x10],al
  21752f:	88 54 24 30          	mov    BYTE PTR [rsp+0x30],dl
  217533:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  217536:	49 3b 16             	cmp    rdx,QWORD PTR [r14]
  217539:	0f 82 ee 00 00 00    	jb     21762d <Benchmark_reportStats+0xeed>
  21753f:	44 0f b6 44 24 28    	movzx  r8d,BYTE PTR [rsp+0x28]
  217545:	0f b6 44 24 50       	movzx  eax,BYTE PTR [rsp+0x50]
  21754a:	88 44 24 28          	mov    BYTE PTR [rsp+0x28],al
  21754e:	49 8b 45 00          	mov    rax,QWORD PTR [r13+0x0]
  217552:	49 3b 07             	cmp    rax,QWORD PTR [r15]
  217555:	0f 82 09 01 00 00    	jb     217664 <Benchmark_reportStats+0xf24>
  21755b:	88 4c 24 50          	mov    BYTE PTR [rsp+0x50],cl
  21755f:	0f b6 4c 24 58       	movzx  ecx,BYTE PTR [rsp+0x58]
  217564:	49 8b 13             	mov    rdx,QWORD PTR [r11]
  217567:	49 8b 04 24          	mov    rax,QWORD PTR [r12]
  21756b:	48 39 c2             	cmp    rdx,rax
  21756e:	0f 82 31 01 00 00    	jb     2176a5 <Benchmark_reportStats+0xf65>
  217574:	45 89 c1             	mov    r9d,r8d
  217577:	44 0f b6 44 24 10    	movzx  r8d,BYTE PTR [rsp+0x10]
  21757d:	44 3a 44 24 20       	cmp    r8b,BYTE PTR [rsp+0x20]
  217582:	0f 86 78 0a 00 00    	jbe    218000 <Benchmark_reportStats+0x18c0>
  217588:	48 39 d0             	cmp    rax,rdx
  21758b:	45 89 c8             	mov    r8d,r9d
  21758e:	0f 83 11 01 00 00    	jae    2176a5 <Benchmark_reportStats+0xf65>
  217594:	8b 44 24 20          	mov    eax,DWORD PTR [rsp+0x20]
  217598:	88 44 24 58          	mov    BYTE PTR [rsp+0x58],al
  21759c:	0f b6 44 24 10       	movzx  eax,BYTE PTR [rsp+0x10]
  2175a1:	89 44 24 20          	mov    DWORD PTR [rsp+0x20],eax
  2175a5:	e9 2c 01 00 00       	jmp    2176d6 <Benchmark_reportStats+0xf96>
  2175aa:	c6 44 24 28 06       	mov    BYTE PTR [rsp+0x28],0x6
  2175af:	b1 07                	mov    cl,0x7
  2175b1:	48 8b 53 20          	mov    rdx,QWORD PTR [rbx+0x20]
  2175b5:	48 3b 13             	cmp    rdx,QWORD PTR [rbx]
  2175b8:	0f 83 47 ff ff ff    	jae    217505 <Benchmark_reportStats+0xdc5>
    const tmp = a.*;
  2175be:	c5 f8 10 03          	vmovups xmm0,XMMWORD PTR [rbx]
  2175c2:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  2175c9:	00 00 
    a.* = b.*;
  2175cb:	c4 c1 78 10 03       	vmovups xmm0,XMMWORD PTR [r11]
  2175d0:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
    b.* = tmp;
  2175d4:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  2175db:	00 00 
  2175dd:	c4 c1 7a 7f 03       	vmovdqu XMMWORD PTR [r11],xmm0
  2175e2:	44 88 44 24 60       	mov    BYTE PTR [rsp+0x60],r8b
  2175e7:	48 8b 17             	mov    rdx,QWORD PTR [rdi]
  2175ea:	49 3b 14 24          	cmp    rdx,QWORD PTR [r12]
  2175ee:	0f 83 2f ff ff ff    	jae    217523 <Benchmark_reportStats+0xde3>
    const tmp = a.*;
  2175f4:	c4 c1 78 10 04 24    	vmovups xmm0,XMMWORD PTR [r12]
  2175fa:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  217601:	00 00 
    a.* = b.*;
  217603:	c5 f8 10 07          	vmovups xmm0,XMMWORD PTR [rdi]
  217607:	c4 c1 78 11 04 24    	vmovups XMMWORD PTR [r12],xmm0
    b.* = tmp;
  21760d:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  217614:	00 00 
  217616:	c5 fa 7f 07          	vmovdqu XMMWORD PTR [rdi],xmm0
  21761a:	44 89 ca             	mov    edx,r9d
  21761d:	88 54 24 30          	mov    BYTE PTR [rsp+0x30],dl
  217621:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  217624:	49 3b 16             	cmp    rdx,QWORD PTR [r14]
  217627:	0f 83 12 ff ff ff    	jae    21753f <Benchmark_reportStats+0xdff>
    const tmp = a.*;
  21762d:	c4 c1 78 10 06       	vmovups xmm0,XMMWORD PTR [r14]
  217632:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  217639:	00 00 
    a.* = b.*;
  21763b:	c5 f8 10 06          	vmovups xmm0,XMMWORD PTR [rsi]
  21763f:	c4 c1 78 11 06       	vmovups XMMWORD PTR [r14],xmm0
    b.* = tmp;
  217644:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  21764b:	00 00 
  21764d:	c5 fa 7f 06          	vmovdqu XMMWORD PTR [rsi],xmm0
  217651:	44 0f b6 44 24 50    	movzx  r8d,BYTE PTR [rsp+0x50]
  217657:	49 8b 45 00          	mov    rax,QWORD PTR [r13+0x0]
  21765b:	49 3b 07             	cmp    rax,QWORD PTR [r15]
  21765e:	0f 83 f7 fe ff ff    	jae    21755b <Benchmark_reportStats+0xe1b>
    const tmp = a.*;
  217664:	c4 c1 78 10 07       	vmovups xmm0,XMMWORD PTR [r15]
  217669:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  217670:	00 00 
    a.* = b.*;
  217672:	c4 c1 78 10 45 00    	vmovups xmm0,XMMWORD PTR [r13+0x0]
  217678:	c4 c1 78 11 07       	vmovups XMMWORD PTR [r15],xmm0
    b.* = tmp;
  21767d:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  217684:	00 00 
  217686:	c4 c1 7a 7f 45 00    	vmovdqu XMMWORD PTR [r13+0x0],xmm0
  21768c:	0f b6 44 24 58       	movzx  eax,BYTE PTR [rsp+0x58]
  217691:	88 44 24 50          	mov    BYTE PTR [rsp+0x50],al
  217695:	49 8b 13             	mov    rdx,QWORD PTR [r11]
  217698:	49 8b 04 24          	mov    rax,QWORD PTR [r12]
  21769c:	48 39 c2             	cmp    rdx,rax
  21769f:	0f 83 cf fe ff ff    	jae    217574 <Benchmark_reportStats+0xe34>
    const tmp = a.*;
  2176a5:	c4 c1 78 10 04 24    	vmovups xmm0,XMMWORD PTR [r12]
  2176ab:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  2176b2:	00 00 
    a.* = b.*;
  2176b4:	c4 c1 78 10 03       	vmovups xmm0,XMMWORD PTR [r11]
  2176b9:	c4 c1 78 11 04 24    	vmovups XMMWORD PTR [r12],xmm0
    b.* = tmp;
  2176bf:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  2176c6:	00 00 
  2176c8:	c4 c1 7a 7f 03       	vmovdqu XMMWORD PTR [r11],xmm0
  2176cd:	0f b6 44 24 10       	movzx  eax,BYTE PTR [rsp+0x10]
  2176d2:	88 44 24 58          	mov    BYTE PTR [rsp+0x58],al
  2176d6:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  2176d9:	49 8b 07             	mov    rax,QWORD PTR [r15]
  2176dc:	48 39 c2             	cmp    rdx,rax
  2176df:	44 0f b6 4c 24 28    	movzx  r9d,BYTE PTR [rsp+0x28]
  2176e5:	72 12                	jb     2176f9 <Benchmark_reportStats+0xfb9>
  2176e7:	44 38 c1             	cmp    cl,r8b
  2176ea:	0f 86 d9 02 00 00    	jbe    2179c9 <Benchmark_reportStats+0x1289>
  2176f0:	48 39 d0             	cmp    rax,rdx
  2176f3:	0f 82 d0 02 00 00    	jb     2179c9 <Benchmark_reportStats+0x1289>
    const tmp = a.*;
  2176f9:	c4 c1 78 10 07       	vmovups xmm0,XMMWORD PTR [r15]
  2176fe:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  217705:	00 00 
    a.* = b.*;
  217707:	c5 f8 10 06          	vmovups xmm0,XMMWORD PTR [rsi]
  21770b:	c4 c1 78 11 07       	vmovups XMMWORD PTR [r15],xmm0
    b.* = tmp;
  217710:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  217717:	00 00 
  217719:	c5 fa 7f 06          	vmovdqu XMMWORD PTR [rsi],xmm0
  21771d:	88 4c 24 10          	mov    BYTE PTR [rsp+0x10],cl
  217721:	e9 ab 02 00 00       	jmp    2179d1 <Benchmark_reportStats+0x1291>
  217726:	44 89 c0             	mov    eax,r8d
  217729:	45 89 f0             	mov    r8d,r14d
  21772c:	48 8b 0f             	mov    rcx,QWORD PTR [rdi]
  21772f:	48 39 d1             	cmp    rcx,rdx
  217732:	0f 83 51 fa ff ff    	jae    217189 <Benchmark_reportStats+0xa49>
    const tmp = a.*;
  217738:	c5 f8 10 03          	vmovups xmm0,XMMWORD PTR [rbx]
  21773c:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  217743:	00 00 
    a.* = b.*;
  217745:	c5 f8 10 07          	vmovups xmm0,XMMWORD PTR [rdi]
  217749:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
    b.* = tmp;
  21774d:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  217754:	00 00 
  217756:	c5 fa 7f 07          	vmovdqu XMMWORD PTR [rdi],xmm0
  21775a:	41 89 c1             	mov    r9d,eax
  21775d:	49 8b 45 00          	mov    rax,QWORD PTR [r13+0x0]
  217761:	49 8b 14 24          	mov    rdx,QWORD PTR [r12]
  217765:	48 39 d0             	cmp    rax,rdx
  217768:	0f 83 3a fa ff ff    	jae    2171a8 <Benchmark_reportStats+0xa68>
    const tmp = a.*;
  21776e:	c4 c1 78 10 04 24    	vmovups xmm0,XMMWORD PTR [r12]
  217774:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  21777b:	00 00 
    a.* = b.*;
  21777d:	c4 c1 78 10 45 00    	vmovups xmm0,XMMWORD PTR [r13+0x0]
  217783:	c4 c1 78 11 04 24    	vmovups XMMWORD PTR [r12],xmm0
    b.* = tmp;
  217789:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  217790:	00 00 
  217792:	c4 c1 7a 7f 45 00    	vmovdqu XMMWORD PTR [r13+0x0],xmm0
  217798:	49 8b 14 24          	mov    rdx,QWORD PTR [r12]
  21779c:	45 89 c3             	mov    r11d,r8d
  21779f:	48 8b 07             	mov    rax,QWORD PTR [rdi]
  2177a2:	48 39 d0             	cmp    rax,rdx
  2177a5:	4c 8b 6c 24 18       	mov    r13,QWORD PTR [rsp+0x18]
  2177aa:	0f 83 17 fa ff ff    	jae    2171c7 <Benchmark_reportStats+0xa87>
    const tmp = a.*;
  2177b0:	c4 c1 78 10 04 24    	vmovups xmm0,XMMWORD PTR [r12]
  2177b6:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  2177bd:	00 00 
    a.* = b.*;
  2177bf:	c5 f8 10 07          	vmovups xmm0,XMMWORD PTR [rdi]
  2177c3:	c4 c1 78 11 04 24    	vmovups XMMWORD PTR [r12],xmm0
    b.* = tmp;
  2177c9:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  2177d0:	00 00 
  2177d2:	c5 fa 7f 07          	vmovdqu XMMWORD PTR [rdi],xmm0
        return self.decimal >= self.size;
  2177d6:	4c 3b 94 24 f0 00 00 	cmp    r10,QWORD PTR [rsp+0xf0]
  2177dd:	00 
  2177de:	0f 82 2c f4 ff ff    	jb     216c10 <Benchmark_reportStats+0x4d0>
  2177e4:	e9 30 08 00 00       	jmp    218019 <Benchmark_reportStats+0x18d9>
  2177e9:	0f b6 44 24 20       	movzx  eax,BYTE PTR [rsp+0x20]
  2177ee:	88 44 24 28          	mov    BYTE PTR [rsp+0x28],al
  2177f2:	44 88 64 24 20       	mov    BYTE PTR [rsp+0x20],r12b
  2177f7:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  2177fa:	49 8b 00             	mov    rax,QWORD PTR [r8]
  2177fd:	48 39 c2             	cmp    rdx,rax
  217800:	44 8b 64 24 10       	mov    r12d,DWORD PTR [rsp+0x10]
    if (lessThan(items[y], items[x]) or ((order.*)[x] > (order.*)[y] and !lessThan(items[x], items[y]))) {
  217805:	72 0a                	jb     217811 <Benchmark_reportStats+0x10d1>
  217807:	45 38 ec             	cmp    r12b,r13b
  21780a:	76 2e                	jbe    21783a <Benchmark_reportStats+0x10fa>
  21780c:	48 39 d0             	cmp    rax,rdx
  21780f:	72 29                	jb     21783a <Benchmark_reportStats+0x10fa>
    const tmp = a.*;
  217811:	c4 c1 78 10 00       	vmovups xmm0,XMMWORD PTR [r8]
  217816:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  21781d:	00 00 
    a.* = b.*;
  21781f:	c4 c1 78 10 06       	vmovups xmm0,XMMWORD PTR [r14]
  217824:	c4 c1 78 11 00       	vmovups XMMWORD PTR [r8],xmm0
    b.* = tmp;
  217829:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  217830:	00 00 
  217832:	c4 c1 7a 7f 06       	vmovdqu XMMWORD PTR [r14],xmm0
  217837:	45 89 ec             	mov    r12d,r13d
  21783a:	48 8b 0b             	mov    rcx,QWORD PTR [rbx]
  21783d:	48 8b 43 30          	mov    rax,QWORD PTR [rbx+0x30]
  217841:	48 39 c8             	cmp    rax,rcx
  217844:	4c 8b 6c 24 18       	mov    r13,QWORD PTR [rsp+0x18]
  217849:	72 0c                	jb     217857 <Benchmark_reportStats+0x1117>
  21784b:	44 3a 7c 24 20       	cmp    r15b,BYTE PTR [rsp+0x20]
  217850:	76 2e                	jbe    217880 <Benchmark_reportStats+0x1140>
  217852:	48 39 c1             	cmp    rcx,rax
  217855:	72 29                	jb     217880 <Benchmark_reportStats+0x1140>
    const tmp = a.*;
  217857:	c5 f8 10 03          	vmovups xmm0,XMMWORD PTR [rbx]
  21785b:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  217862:	00 00 
    a.* = b.*;
  217864:	c4 c1 78 10 03       	vmovups xmm0,XMMWORD PTR [r11]
  217869:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
    b.* = tmp;
  21786d:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  217874:	00 00 
  217876:	c4 c1 7a 7f 03       	vmovdqu XMMWORD PTR [r11],xmm0
  21787b:	44 88 7c 24 20       	mov    BYTE PTR [rsp+0x20],r15b
  217880:	48 8b 0f             	mov    rcx,QWORD PTR [rdi]
  217883:	49 8b 01             	mov    rax,QWORD PTR [r9]
  217886:	48 39 c1             	cmp    rcx,rax
  217889:	4c 8b bc 24 00 01 00 	mov    r15,QWORD PTR [rsp+0x100]
  217890:	00 
  217891:	0f b6 5c 24 28       	movzx  ebx,BYTE PTR [rsp+0x28]
  217896:	72 13                	jb     2178ab <Benchmark_reportStats+0x116b>
  217898:	38 5c 24 30          	cmp    BYTE PTR [rsp+0x30],bl
  21789c:	0f 86 4d 02 00 00    	jbe    217aef <Benchmark_reportStats+0x13af>
  2178a2:	48 39 c8             	cmp    rax,rcx
  2178a5:	0f 82 44 02 00 00    	jb     217aef <Benchmark_reportStats+0x13af>
    const tmp = a.*;
  2178ab:	c4 c1 78 10 01       	vmovups xmm0,XMMWORD PTR [r9]
  2178b0:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  2178b7:	00 00 
    a.* = b.*;
  2178b9:	c5 f8 10 07          	vmovups xmm0,XMMWORD PTR [rdi]
  2178bd:	c4 c1 78 11 01       	vmovups XMMWORD PTR [r9],xmm0
    b.* = tmp;
  2178c2:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  2178c9:	00 00 
  2178cb:	c5 fa 7f 07          	vmovdqu XMMWORD PTR [rdi],xmm0
  2178cf:	48 8b 0f             	mov    rcx,QWORD PTR [rdi]
  2178d2:	8b 44 24 30          	mov    eax,DWORD PTR [rsp+0x30]
  2178d6:	89 c2                	mov    edx,eax
  2178d8:	49 8b 00             	mov    rax,QWORD PTR [r8]
  2178db:	48 39 c1             	cmp    rcx,rax
  2178de:	0f 82 1f 02 00 00    	jb     217b03 <Benchmark_reportStats+0x13c3>
  2178e4:	41 38 d4             	cmp    r12b,dl
  2178e7:	76 09                	jbe    2178f2 <Benchmark_reportStats+0x11b2>
  2178e9:	48 39 c8             	cmp    rax,rcx
  2178ec:	0f 83 11 02 00 00    	jae    217b03 <Benchmark_reportStats+0x13c3>
  2178f2:	49 8b 0b             	mov    rcx,QWORD PTR [r11]
  2178f5:	49 8b 01             	mov    rax,QWORD PTR [r9]
  2178f8:	48 39 c1             	cmp    rcx,rax
  2178fb:	0f 82 38 02 00 00    	jb     217b39 <Benchmark_reportStats+0x13f9>
  217901:	3a 5c 24 20          	cmp    bl,BYTE PTR [rsp+0x20]
  217905:	76 09                	jbe    217910 <Benchmark_reportStats+0x11d0>
  217907:	48 39 c8             	cmp    rax,rcx
  21790a:	0f 83 29 02 00 00    	jae    217b39 <Benchmark_reportStats+0x13f9>
  217910:	49 8b 10             	mov    rdx,QWORD PTR [r8]
  217913:	48 39 d1             	cmp    rcx,rdx
  217916:	0f 82 56 02 00 00    	jb     217b72 <Benchmark_reportStats+0x1432>
  21791c:	44 3a 64 24 20       	cmp    r12b,BYTE PTR [rsp+0x20]
  217921:	0f 86 c9 06 00 00    	jbe    217ff0 <Benchmark_reportStats+0x18b0>
  217927:	48 39 ca             	cmp    rdx,rcx
  21792a:	0f 83 42 02 00 00    	jae    217b72 <Benchmark_reportStats+0x1432>
  217930:	e9 bb 06 00 00       	jmp    217ff0 <Benchmark_reportStats+0x18b0>
  217935:	44 0f b6 64 24 20    	movzx  r12d,BYTE PTR [rsp+0x20]
  21793b:	44 88 74 24 20       	mov    BYTE PTR [rsp+0x20],r14b
  217940:	49 8b 10             	mov    rdx,QWORD PTR [r8]
  217943:	49 8b 33             	mov    rsi,QWORD PTR [r11]
  217946:	48 39 f2             	cmp    rdx,rsi
  217949:	0f 83 43 fb ff ff    	jae    217492 <Benchmark_reportStats+0xd52>
    const tmp = a.*;
  21794f:	c4 c1 78 10 03       	vmovups xmm0,XMMWORD PTR [r11]
  217954:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  21795b:	00 00 
    a.* = b.*;
  21795d:	c4 c1 78 10 00       	vmovups xmm0,XMMWORD PTR [r8]
  217962:	c4 c1 78 11 03       	vmovups XMMWORD PTR [r11],xmm0
    b.* = tmp;
  217967:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  21796e:	00 00 
  217970:	c4 c1 7a 7f 00       	vmovdqu XMMWORD PTR [r8],xmm0
  217975:	41 89 c6             	mov    r14d,eax
  217978:	48 8b 13             	mov    rdx,QWORD PTR [rbx]
  21797b:	48 8b 73 10          	mov    rsi,QWORD PTR [rbx+0x10]
  21797f:	48 39 d6             	cmp    rsi,rdx
  217982:	0f b6 44 24 58       	movzx  eax,BYTE PTR [rsp+0x58]
  217987:	72 13                	jb     21799c <Benchmark_reportStats+0x125c>
  217989:	38 44 24 10          	cmp    BYTE PTR [rsp+0x10],al
  21798d:	0f 86 18 02 00 00    	jbe    217bab <Benchmark_reportStats+0x146b>
  217993:	48 39 f2             	cmp    rdx,rsi
  217996:	0f 82 0f 02 00 00    	jb     217bab <Benchmark_reportStats+0x146b>
    const tmp = a.*;
  21799c:	c5 f8 10 03          	vmovups xmm0,XMMWORD PTR [rbx]
  2179a0:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  2179a7:	00 00 
    a.* = b.*;
  2179a9:	c4 c1 78 10 07       	vmovups xmm0,XMMWORD PTR [r15]
  2179ae:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
    b.* = tmp;
  2179b2:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  2179b9:	00 00 
  2179bb:	c4 c1 7a 7f 07       	vmovdqu XMMWORD PTR [r15],xmm0
  2179c0:	88 44 24 28          	mov    BYTE PTR [rsp+0x28],al
  2179c4:	e9 f0 01 00 00       	jmp    217bb9 <Benchmark_reportStats+0x1479>
  2179c9:	44 88 44 24 10       	mov    BYTE PTR [rsp+0x10],r8b
  2179ce:	41 89 c8             	mov    r8d,ecx
  2179d1:	48 8b 13             	mov    rdx,QWORD PTR [rbx]
  2179d4:	48 8b 43 40          	mov    rax,QWORD PTR [rbx+0x40]
  2179d8:	48 39 d0             	cmp    rax,rdx
  2179db:	0f b6 4c 24 60       	movzx  ecx,BYTE PTR [rsp+0x60]
  2179e0:	72 0a                	jb     2179ec <Benchmark_reportStats+0x12ac>
  2179e2:	44 38 c9             	cmp    cl,r9b
  2179e5:	76 2c                	jbe    217a13 <Benchmark_reportStats+0x12d3>
  2179e7:	48 39 c2             	cmp    rdx,rax
  2179ea:	72 27                	jb     217a13 <Benchmark_reportStats+0x12d3>
    const tmp = a.*;
  2179ec:	c5 f8 10 03          	vmovups xmm0,XMMWORD PTR [rbx]
  2179f0:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  2179f7:	00 00 
    a.* = b.*;
  2179f9:	c4 c1 78 10 06       	vmovups xmm0,XMMWORD PTR [r14]
  2179fe:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
    b.* = tmp;
  217a02:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  217a09:	00 00 
  217a0b:	c4 c1 7a 7f 06       	vmovdqu XMMWORD PTR [r14],xmm0
  217a10:	41 89 c9             	mov    r9d,ecx
  217a13:	49 8b 55 00          	mov    rdx,QWORD PTR [r13+0x0]
  217a17:	48 8b 07             	mov    rax,QWORD PTR [rdi]
  217a1a:	48 39 c2             	cmp    rdx,rax
  217a1d:	0f b6 5c 24 58       	movzx  ebx,BYTE PTR [rsp+0x58]
  217a22:	0f b6 4c 24 50       	movzx  ecx,BYTE PTR [rsp+0x50]
  217a27:	72 0b                	jb     217a34 <Benchmark_reportStats+0x12f4>
  217a29:	38 4c 24 30          	cmp    BYTE PTR [rsp+0x30],cl
  217a2d:	76 2f                	jbe    217a5e <Benchmark_reportStats+0x131e>
  217a2f:	48 39 d0             	cmp    rax,rdx
  217a32:	72 2a                	jb     217a5e <Benchmark_reportStats+0x131e>
    const tmp = a.*;
  217a34:	c5 f8 10 07          	vmovups xmm0,XMMWORD PTR [rdi]
  217a38:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  217a3f:	00 00 
    a.* = b.*;
  217a41:	c4 c1 78 10 45 00    	vmovups xmm0,XMMWORD PTR [r13+0x0]
  217a47:	c5 f8 11 07          	vmovups XMMWORD PTR [rdi],xmm0
    b.* = tmp;
  217a4b:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  217a52:	00 00 
  217a54:	c4 c1 7a 7f 45 00    	vmovdqu XMMWORD PTR [r13+0x0],xmm0
  217a5a:	88 4c 24 30          	mov    BYTE PTR [rsp+0x30],cl
  217a5e:	49 8b 17             	mov    rdx,QWORD PTR [r15]
  217a61:	49 8b 04 24          	mov    rax,QWORD PTR [r12]
  217a65:	48 39 c2             	cmp    rdx,rax
  217a68:	4c 8b 6c 24 18       	mov    r13,QWORD PTR [rsp+0x18]
  217a6d:	72 14                	jb     217a83 <Benchmark_reportStats+0x1343>
  217a6f:	44 38 44 24 20       	cmp    BYTE PTR [rsp+0x20],r8b
  217a74:	0f 86 8b 01 00 00    	jbe    217c05 <Benchmark_reportStats+0x14c5>
  217a7a:	48 39 d0             	cmp    rax,rdx
  217a7d:	0f 82 82 01 00 00    	jb     217c05 <Benchmark_reportStats+0x14c5>
    const tmp = a.*;
  217a83:	c4 c1 78 10 04 24    	vmovups xmm0,XMMWORD PTR [r12]
  217a89:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  217a90:	00 00 
    a.* = b.*;
  217a92:	c4 c1 78 10 07       	vmovups xmm0,XMMWORD PTR [r15]
  217a97:	c4 c1 78 11 04 24    	vmovups XMMWORD PTR [r12],xmm0
    b.* = tmp;
  217a9d:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  217aa4:	00 00 
  217aa6:	c4 c1 7a 7f 07       	vmovdqu XMMWORD PTR [r15],xmm0
  217aab:	8b 44 24 20          	mov    eax,DWORD PTR [rsp+0x20]
  217aaf:	88 44 24 28          	mov    BYTE PTR [rsp+0x28],al
  217ab3:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  217ab6:	49 8b 03             	mov    rax,QWORD PTR [r11]
  217ab9:	48 39 c2             	cmp    rdx,rax
  217abc:	0f 82 5e 01 00 00    	jb     217c20 <Benchmark_reportStats+0x14e0>
  217ac2:	3a 5c 24 10          	cmp    bl,BYTE PTR [rsp+0x10]
  217ac6:	76 09                	jbe    217ad1 <Benchmark_reportStats+0x1391>
  217ac8:	48 39 d0             	cmp    rax,rdx
  217acb:	0f 83 4f 01 00 00    	jae    217c20 <Benchmark_reportStats+0x14e0>
  217ad1:	0f b6 54 24 10       	movzx  edx,BYTE PTR [rsp+0x10]
  217ad6:	88 5c 24 10          	mov    BYTE PTR [rsp+0x10],bl
  217ada:	49 8b 1e             	mov    rbx,QWORD PTR [r14]
  217add:	49 8b 04 24          	mov    rax,QWORD PTR [r12]
  217ae1:	48 39 c3             	cmp    rbx,rax
  217ae4:	0f 83 68 01 00 00    	jae    217c52 <Benchmark_reportStats+0x1512>
  217aea:	e9 6d 01 00 00       	jmp    217c5c <Benchmark_reportStats+0x151c>
  217aef:	89 da                	mov    edx,ebx
  217af1:	8b 44 24 30          	mov    eax,DWORD PTR [rsp+0x30]
  217af5:	89 c3                	mov    ebx,eax
  217af7:	49 8b 00             	mov    rax,QWORD PTR [r8]
  217afa:	48 39 c1             	cmp    rcx,rax
  217afd:	0f 83 e1 fd ff ff    	jae    2178e4 <Benchmark_reportStats+0x11a4>
    const tmp = a.*;
  217b03:	c4 c1 78 10 00       	vmovups xmm0,XMMWORD PTR [r8]
  217b08:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  217b0f:	00 00 
    a.* = b.*;
  217b11:	c5 f8 10 07          	vmovups xmm0,XMMWORD PTR [rdi]
  217b15:	c4 c1 78 11 00       	vmovups XMMWORD PTR [r8],xmm0
    b.* = tmp;
  217b1a:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  217b21:	00 00 
  217b23:	c5 fa 7f 07          	vmovdqu XMMWORD PTR [rdi],xmm0
  217b27:	41 89 d4             	mov    r12d,edx
  217b2a:	49 8b 0b             	mov    rcx,QWORD PTR [r11]
  217b2d:	49 8b 01             	mov    rax,QWORD PTR [r9]
  217b30:	48 39 c1             	cmp    rcx,rax
  217b33:	0f 83 c8 fd ff ff    	jae    217901 <Benchmark_reportStats+0x11c1>
    const tmp = a.*;
  217b39:	c4 c1 78 10 01       	vmovups xmm0,XMMWORD PTR [r9]
  217b3e:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  217b45:	00 00 
    a.* = b.*;
  217b47:	c4 c1 78 10 03       	vmovups xmm0,XMMWORD PTR [r11]
  217b4c:	c4 c1 78 11 01       	vmovups XMMWORD PTR [r9],xmm0
    b.* = tmp;
  217b51:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  217b58:	00 00 
  217b5a:	c4 c1 7a 7f 03       	vmovdqu XMMWORD PTR [r11],xmm0
  217b5f:	49 8b 0b             	mov    rcx,QWORD PTR [r11]
  217b62:	88 5c 24 20          	mov    BYTE PTR [rsp+0x20],bl
  217b66:	49 8b 10             	mov    rdx,QWORD PTR [r8]
  217b69:	48 39 d1             	cmp    rcx,rdx
  217b6c:	0f 83 aa fd ff ff    	jae    21791c <Benchmark_reportStats+0x11dc>
    const tmp = a.*;
  217b72:	c4 c1 78 10 00       	vmovups xmm0,XMMWORD PTR [r8]
  217b77:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  217b7e:	00 00 
    a.* = b.*;
  217b80:	c4 c1 78 10 03       	vmovups xmm0,XMMWORD PTR [r11]
  217b85:	c4 c1 78 11 00       	vmovups XMMWORD PTR [r8],xmm0
    b.* = tmp;
  217b8a:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  217b91:	00 00 
  217b93:	c4 c1 7a 7f 03       	vmovdqu XMMWORD PTR [r11],xmm0
        return self.decimal >= self.size;
  217b98:	4c 3b 94 24 f0 00 00 	cmp    r10,QWORD PTR [rsp+0xf0]
  217b9f:	00 
  217ba0:	0f 82 6a f0 ff ff    	jb     216c10 <Benchmark_reportStats+0x4d0>
  217ba6:	e9 6e 04 00 00       	jmp    218019 <Benchmark_reportStats+0x18d9>
  217bab:	8b 54 24 10          	mov    edx,DWORD PTR [rsp+0x10]
  217baf:	88 54 24 28          	mov    BYTE PTR [rsp+0x28],dl
  217bb3:	89 c2                	mov    edx,eax
  217bb5:	89 54 24 10          	mov    DWORD PTR [rsp+0x10],edx
  217bb9:	48 8b 11             	mov    rdx,QWORD PTR [rcx]
  217bbc:	49 8b 33             	mov    rsi,QWORD PTR [r11]
  217bbf:	48 39 f2             	cmp    rdx,rsi
  217bc2:	44 89 f0             	mov    eax,r14d
    if (lessThan(items[y], items[x]) or ((order.*)[x] > (order.*)[y] and !lessThan(items[x], items[y]))) {
  217bc5:	72 12                	jb     217bd9 <Benchmark_reportStats+0x1499>
  217bc7:	45 38 e5             	cmp    r13b,r12b
  217bca:	0f 86 d7 01 00 00    	jbe    217da7 <Benchmark_reportStats+0x1667>
  217bd0:	48 39 d6             	cmp    rsi,rdx
  217bd3:	0f 82 ce 01 00 00    	jb     217da7 <Benchmark_reportStats+0x1667>
    const tmp = a.*;
  217bd9:	c4 c1 78 10 03       	vmovups xmm0,XMMWORD PTR [r11]
  217bde:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  217be5:	00 00 
    a.* = b.*;
  217be7:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  217beb:	c4 c1 78 11 03       	vmovups XMMWORD PTR [r11],xmm0
    b.* = tmp;
  217bf0:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  217bf7:	00 00 
  217bf9:	c5 fa 7f 01          	vmovdqu XMMWORD PTR [rcx],xmm0
  217bfd:	45 89 ee             	mov    r14d,r13d
  217c00:	e9 a8 01 00 00       	jmp    217dad <Benchmark_reportStats+0x166d>
  217c05:	44 88 44 24 28       	mov    BYTE PTR [rsp+0x28],r8b
  217c0a:	8b 44 24 20          	mov    eax,DWORD PTR [rsp+0x20]
  217c0e:	41 89 c0             	mov    r8d,eax
  217c11:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  217c14:	49 8b 03             	mov    rax,QWORD PTR [r11]
  217c17:	48 39 c2             	cmp    rdx,rax
  217c1a:	0f 83 a2 fe ff ff    	jae    217ac2 <Benchmark_reportStats+0x1382>
    const tmp = a.*;
  217c20:	c4 c1 78 10 03       	vmovups xmm0,XMMWORD PTR [r11]
  217c25:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  217c2c:	00 00 
    a.* = b.*;
  217c2e:	c5 f8 10 06          	vmovups xmm0,XMMWORD PTR [rsi]
  217c32:	c4 c1 78 11 03       	vmovups XMMWORD PTR [r11],xmm0
    b.* = tmp;
  217c37:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  217c3e:	00 00 
  217c40:	c5 fa 7f 06          	vmovdqu XMMWORD PTR [rsi],xmm0
  217c44:	89 da                	mov    edx,ebx
  217c46:	49 8b 1e             	mov    rbx,QWORD PTR [r14]
  217c49:	49 8b 04 24          	mov    rax,QWORD PTR [r12]
  217c4d:	48 39 c3             	cmp    rbx,rax
  217c50:	72 0a                	jb     217c5c <Benchmark_reportStats+0x151c>
  217c52:	45 38 c8             	cmp    r8b,r9b
  217c55:	76 30                	jbe    217c87 <Benchmark_reportStats+0x1547>
  217c57:	48 39 d8             	cmp    rax,rbx
  217c5a:	72 2b                	jb     217c87 <Benchmark_reportStats+0x1547>
    const tmp = a.*;
  217c5c:	c4 c1 78 10 04 24    	vmovups xmm0,XMMWORD PTR [r12]
  217c62:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  217c69:	00 00 
    a.* = b.*;
  217c6b:	c4 c1 78 10 06       	vmovups xmm0,XMMWORD PTR [r14]
  217c70:	c4 c1 78 11 04 24    	vmovups XMMWORD PTR [r12],xmm0
    b.* = tmp;
  217c76:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  217c7d:	00 00 
  217c7f:	c4 c1 7a 7f 06       	vmovdqu XMMWORD PTR [r14],xmm0
  217c84:	45 89 c1             	mov    r9d,r8d
  217c87:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  217c8a:	48 8b 07             	mov    rax,QWORD PTR [rdi]
  217c8d:	48 39 c1             	cmp    rcx,rax
  217c90:	0f b6 5c 24 30       	movzx  ebx,BYTE PTR [rsp+0x30]
  217c95:	72 09                	jb     217ca0 <Benchmark_reportStats+0x1560>
  217c97:	38 d3                	cmp    bl,dl
  217c99:	76 29                	jbe    217cc4 <Benchmark_reportStats+0x1584>
  217c9b:	48 39 c8             	cmp    rax,rcx
  217c9e:	72 24                	jb     217cc4 <Benchmark_reportStats+0x1584>
    const tmp = a.*;
  217ca0:	c5 f8 10 07          	vmovups xmm0,XMMWORD PTR [rdi]
  217ca4:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  217cab:	00 00 
    a.* = b.*;
  217cad:	c5 f8 10 06          	vmovups xmm0,XMMWORD PTR [rsi]
  217cb1:	c5 f8 11 07          	vmovups XMMWORD PTR [rdi],xmm0
    b.* = tmp;
  217cb5:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  217cbc:	00 00 
  217cbe:	c5 fa 7f 06          	vmovdqu XMMWORD PTR [rsi],xmm0
  217cc2:	89 d3                	mov    ebx,edx
  217cc4:	49 8b 0e             	mov    rcx,QWORD PTR [r14]
  217cc7:	49 8b 03             	mov    rax,QWORD PTR [r11]
  217cca:	48 39 c1             	cmp    rcx,rax
  217ccd:	48 8b 74 24 38       	mov    rsi,QWORD PTR [rsp+0x38]
  217cd2:	72 0c                	jb     217ce0 <Benchmark_reportStats+0x15a0>
  217cd4:	44 38 4c 24 10       	cmp    BYTE PTR [rsp+0x10],r9b
  217cd9:	76 31                	jbe    217d0c <Benchmark_reportStats+0x15cc>
  217cdb:	48 39 c8             	cmp    rax,rcx
  217cde:	72 2c                	jb     217d0c <Benchmark_reportStats+0x15cc>
    const tmp = a.*;
  217ce0:	c4 c1 78 10 03       	vmovups xmm0,XMMWORD PTR [r11]
  217ce5:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  217cec:	00 00 
    a.* = b.*;
  217cee:	c4 c1 78 10 06       	vmovups xmm0,XMMWORD PTR [r14]
  217cf3:	c4 c1 78 11 03       	vmovups XMMWORD PTR [r11],xmm0
    b.* = tmp;
  217cf8:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  217cff:	00 00 
  217d01:	c4 c1 7a 7f 06       	vmovdqu XMMWORD PTR [r14],xmm0
  217d06:	44 0f b6 4c 24 10    	movzx  r9d,BYTE PTR [rsp+0x10]
  217d0c:	49 8b 17             	mov    rdx,QWORD PTR [r15]
  217d0f:	48 8b 0f             	mov    rcx,QWORD PTR [rdi]
  217d12:	48 39 ca             	cmp    rdx,rcx
  217d15:	0f b6 44 24 28       	movzx  eax,BYTE PTR [rsp+0x28]
  217d1a:	72 09                	jb     217d25 <Benchmark_reportStats+0x15e5>
  217d1c:	38 c3                	cmp    bl,al
  217d1e:	76 2e                	jbe    217d4e <Benchmark_reportStats+0x160e>
  217d20:	48 39 d1             	cmp    rcx,rdx
  217d23:	72 29                	jb     217d4e <Benchmark_reportStats+0x160e>
    const tmp = a.*;
  217d25:	c5 f8 10 07          	vmovups xmm0,XMMWORD PTR [rdi]
  217d29:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  217d30:	00 00 
    a.* = b.*;
  217d32:	c4 c1 78 10 07       	vmovups xmm0,XMMWORD PTR [r15]
  217d37:	c5 f8 11 07          	vmovups XMMWORD PTR [rdi],xmm0
    b.* = tmp;
  217d3b:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  217d42:	00 00 
  217d44:	c4 c1 7a 7f 07       	vmovdqu XMMWORD PTR [r15],xmm0
  217d49:	48 8b 0f             	mov    rcx,QWORD PTR [rdi]
  217d4c:	89 c3                	mov    ebx,eax
  217d4e:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  217d51:	48 39 ca             	cmp    rdx,rcx
  217d54:	4c 8b bc 24 00 01 00 	mov    r15,QWORD PTR [rsp+0x100]
  217d5b:	00 
  217d5c:	72 12                	jb     217d70 <Benchmark_reportStats+0x1630>
  217d5e:	44 38 cb             	cmp    bl,r9b
  217d61:	0f 86 89 02 00 00    	jbe    217ff0 <Benchmark_reportStats+0x18b0>
  217d67:	48 39 d1             	cmp    rcx,rdx
  217d6a:	0f 82 80 02 00 00    	jb     217ff0 <Benchmark_reportStats+0x18b0>
    const tmp = a.*;
  217d70:	c5 f8 10 07          	vmovups xmm0,XMMWORD PTR [rdi]
  217d74:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  217d7b:	00 00 
    a.* = b.*;
  217d7d:	c4 c1 78 10 06       	vmovups xmm0,XMMWORD PTR [r14]
  217d82:	c5 f8 11 07          	vmovups XMMWORD PTR [rdi],xmm0
    b.* = tmp;
  217d86:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  217d8d:	00 00 
  217d8f:	c4 c1 7a 7f 06       	vmovdqu XMMWORD PTR [r14],xmm0
        return self.decimal >= self.size;
  217d94:	4c 3b 94 24 f0 00 00 	cmp    r10,QWORD PTR [rsp+0xf0]
  217d9b:	00 
  217d9c:	0f 82 6e ee ff ff    	jb     216c10 <Benchmark_reportStats+0x4d0>
  217da2:	e9 72 02 00 00       	jmp    218019 <Benchmark_reportStats+0x18d9>
  217da7:	45 89 e6             	mov    r14d,r12d
  217daa:	45 89 ec             	mov    r12d,r13d
  217dad:	49 8b 10             	mov    rdx,QWORD PTR [r8]
  217db0:	48 8b 37             	mov    rsi,QWORD PTR [rdi]
  217db3:	48 39 f2             	cmp    rdx,rsi
  217db6:	4c 8b 6c 24 18       	mov    r13,QWORD PTR [rsp+0x18]
    if (lessThan(items[y], items[x]) or ((order.*)[x] > (order.*)[y] and !lessThan(items[x], items[y]))) {
  217dbb:	72 0b                	jb     217dc8 <Benchmark_reportStats+0x1688>
  217dbd:	38 44 24 30          	cmp    BYTE PTR [rsp+0x30],al
  217dc1:	76 2d                	jbe    217df0 <Benchmark_reportStats+0x16b0>
  217dc3:	48 39 d6             	cmp    rsi,rdx
  217dc6:	72 28                	jb     217df0 <Benchmark_reportStats+0x16b0>
    const tmp = a.*;
  217dc8:	c5 f8 10 07          	vmovups xmm0,XMMWORD PTR [rdi]
  217dcc:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  217dd3:	00 00 
    a.* = b.*;
  217dd5:	c4 c1 78 10 00       	vmovups xmm0,XMMWORD PTR [r8]
  217dda:	c5 f8 11 07          	vmovups XMMWORD PTR [rdi],xmm0
    b.* = tmp;
  217dde:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  217de5:	00 00 
  217de7:	c4 c1 7a 7f 00       	vmovdqu XMMWORD PTR [r8],xmm0
  217dec:	89 44 24 30          	mov    DWORD PTR [rsp+0x30],eax
  217df0:	48 8b 03             	mov    rax,QWORD PTR [rbx]
  217df3:	48 8b 53 40          	mov    rdx,QWORD PTR [rbx+0x40]
  217df7:	48 39 c2             	cmp    rdx,rax
  217dfa:	45 89 f0             	mov    r8d,r14d
  217dfd:	72 0c                	jb     217e0b <Benchmark_reportStats+0x16cb>
  217dff:	44 38 64 24 28       	cmp    BYTE PTR [rsp+0x28],r12b
  217e04:	76 2e                	jbe    217e34 <Benchmark_reportStats+0x16f4>
  217e06:	48 39 d0             	cmp    rax,rdx
  217e09:	72 29                	jb     217e34 <Benchmark_reportStats+0x16f4>
    const tmp = a.*;
  217e0b:	c5 f8 10 03          	vmovups xmm0,XMMWORD PTR [rbx]
  217e0f:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  217e16:	00 00 
    a.* = b.*;
  217e18:	c4 c1 78 10 03       	vmovups xmm0,XMMWORD PTR [r11]
  217e1d:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
    b.* = tmp;
  217e21:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  217e28:	00 00 
  217e2a:	c4 c1 7a 7f 03       	vmovdqu XMMWORD PTR [r11],xmm0
  217e2f:	45 89 e6             	mov    r14d,r12d
  217e32:	eb 0b                	jmp    217e3f <Benchmark_reportStats+0x16ff>
  217e34:	44 0f b6 74 24 28    	movzx  r14d,BYTE PTR [rsp+0x28]
  217e3a:	44 88 64 24 28       	mov    BYTE PTR [rsp+0x28],r12b
  217e3f:	48 8b 11             	mov    rdx,QWORD PTR [rcx]
  217e42:	49 8b 07             	mov    rax,QWORD PTR [r15]
  217e45:	48 39 c2             	cmp    rdx,rax
  217e48:	44 8b 64 24 30       	mov    r12d,DWORD PTR [rsp+0x30]
  217e4d:	72 0c                	jb     217e5b <Benchmark_reportStats+0x171b>
  217e4f:	44 38 44 24 10       	cmp    BYTE PTR [rsp+0x10],r8b
  217e54:	76 5e                	jbe    217eb4 <Benchmark_reportStats+0x1774>
  217e56:	48 39 d0             	cmp    rax,rdx
  217e59:	72 59                	jb     217eb4 <Benchmark_reportStats+0x1774>
    const tmp = a.*;
  217e5b:	c4 c1 78 10 07       	vmovups xmm0,XMMWORD PTR [r15]
  217e60:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  217e67:	00 00 
    a.* = b.*;
  217e69:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  217e6d:	c4 c1 78 11 07       	vmovups XMMWORD PTR [r15],xmm0
    b.* = tmp;
  217e72:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  217e79:	00 00 
  217e7b:	c5 fa 7f 01          	vmovdqu XMMWORD PTR [rcx],xmm0
  217e7f:	8b 44 24 10          	mov    eax,DWORD PTR [rsp+0x10]
  217e83:	89 c2                	mov    edx,eax
  217e85:	48 8b 03             	mov    rax,QWORD PTR [rbx]
  217e88:	48 8b 73 30          	mov    rsi,QWORD PTR [rbx+0x30]
  217e8c:	48 39 c6             	cmp    rsi,rax
  217e8f:	72 39                	jb     217eca <Benchmark_reportStats+0x178a>
  217e91:	44 3a 74 24 20       	cmp    r14b,BYTE PTR [rsp+0x20]
  217e96:	76 05                	jbe    217e9d <Benchmark_reportStats+0x175d>
  217e98:	48 39 f0             	cmp    rax,rsi
  217e9b:	73 2d                	jae    217eca <Benchmark_reportStats+0x178a>
  217e9d:	48 8b 01             	mov    rax,QWORD PTR [rcx]
  217ea0:	48 8b 37             	mov    rsi,QWORD PTR [rdi]
  217ea3:	48 39 f0             	cmp    rax,rsi
  217ea6:	72 56                	jb     217efe <Benchmark_reportStats+0x17be>
  217ea8:	41 38 d4             	cmp    r12b,dl
  217eab:	76 76                	jbe    217f23 <Benchmark_reportStats+0x17e3>
  217ead:	48 39 c6             	cmp    rsi,rax
  217eb0:	73 4c                	jae    217efe <Benchmark_reportStats+0x17be>
  217eb2:	eb 6f                	jmp    217f23 <Benchmark_reportStats+0x17e3>
  217eb4:	44 89 c2             	mov    edx,r8d
  217eb7:	8b 44 24 10          	mov    eax,DWORD PTR [rsp+0x10]
  217ebb:	41 89 c0             	mov    r8d,eax
  217ebe:	48 8b 03             	mov    rax,QWORD PTR [rbx]
  217ec1:	48 8b 73 30          	mov    rsi,QWORD PTR [rbx+0x30]
  217ec5:	48 39 c6             	cmp    rsi,rax
  217ec8:	73 c7                	jae    217e91 <Benchmark_reportStats+0x1751>
    const tmp = a.*;
  217eca:	c5 f8 10 03          	vmovups xmm0,XMMWORD PTR [rbx]
  217ece:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  217ed5:	00 00 
    a.* = b.*;
  217ed7:	c4 c1 78 10 01       	vmovups xmm0,XMMWORD PTR [r9]
  217edc:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
    b.* = tmp;
  217ee0:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  217ee7:	00 00 
  217ee9:	c4 c1 7a 7f 01       	vmovdqu XMMWORD PTR [r9],xmm0
  217eee:	44 88 74 24 20       	mov    BYTE PTR [rsp+0x20],r14b
  217ef3:	48 8b 01             	mov    rax,QWORD PTR [rcx]
  217ef6:	48 8b 37             	mov    rsi,QWORD PTR [rdi]
  217ef9:	48 39 f0             	cmp    rax,rsi
  217efc:	73 aa                	jae    217ea8 <Benchmark_reportStats+0x1768>
    const tmp = a.*;
  217efe:	c5 f8 10 07          	vmovups xmm0,XMMWORD PTR [rdi]
  217f02:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  217f09:	00 00 
    a.* = b.*;
  217f0b:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  217f0f:	c5 f8 11 07          	vmovups XMMWORD PTR [rdi],xmm0
    b.* = tmp;
  217f13:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  217f1a:	00 00 
  217f1c:	c5 fa 7f 01          	vmovdqu XMMWORD PTR [rcx],xmm0
  217f20:	41 89 d4             	mov    r12d,edx
  217f23:	49 8b 01             	mov    rax,QWORD PTR [r9]
  217f26:	49 8b 0f             	mov    rcx,QWORD PTR [r15]
  217f29:	48 39 c8             	cmp    rax,rcx
  217f2c:	48 8b 74 24 38       	mov    rsi,QWORD PTR [rsp+0x38]
  217f31:	72 0c                	jb     217f3f <Benchmark_reportStats+0x17ff>
  217f33:	44 3a 44 24 20       	cmp    r8b,BYTE PTR [rsp+0x20]
  217f38:	76 30                	jbe    217f6a <Benchmark_reportStats+0x182a>
  217f3a:	48 39 c1             	cmp    rcx,rax
  217f3d:	72 2b                	jb     217f6a <Benchmark_reportStats+0x182a>
    const tmp = a.*;
  217f3f:	c4 c1 78 10 07       	vmovups xmm0,XMMWORD PTR [r15]
  217f44:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  217f4b:	00 00 
    a.* = b.*;
  217f4d:	c4 c1 78 10 01       	vmovups xmm0,XMMWORD PTR [r9]
  217f52:	c4 c1 78 11 07       	vmovups XMMWORD PTR [r15],xmm0
    b.* = tmp;
  217f57:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  217f5e:	00 00 
  217f60:	c4 c1 7a 7f 01       	vmovdqu XMMWORD PTR [r9],xmm0
  217f65:	44 88 44 24 20       	mov    BYTE PTR [rsp+0x20],r8b
  217f6a:	49 8b 0b             	mov    rcx,QWORD PTR [r11]
  217f6d:	48 8b 07             	mov    rax,QWORD PTR [rdi]
  217f70:	48 39 c1             	cmp    rcx,rax
  217f73:	4c 8b bc 24 00 01 00 	mov    r15,QWORD PTR [rsp+0x100]
  217f7a:	00 
  217f7b:	72 0c                	jb     217f89 <Benchmark_reportStats+0x1849>
  217f7d:	44 3a 64 24 28       	cmp    r12b,BYTE PTR [rsp+0x28]
  217f82:	76 34                	jbe    217fb8 <Benchmark_reportStats+0x1878>
  217f84:	48 39 c8             	cmp    rax,rcx
  217f87:	72 2f                	jb     217fb8 <Benchmark_reportStats+0x1878>
    const tmp = a.*;
  217f89:	c5 f8 10 07          	vmovups xmm0,XMMWORD PTR [rdi]
  217f8d:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  217f94:	00 00 
    a.* = b.*;
  217f96:	c4 c1 78 10 03       	vmovups xmm0,XMMWORD PTR [r11]
  217f9b:	c5 f8 11 07          	vmovups XMMWORD PTR [rdi],xmm0
    b.* = tmp;
  217f9f:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  217fa6:	00 00 
  217fa8:	c4 c1 7a 7f 03       	vmovdqu XMMWORD PTR [r11],xmm0
  217fad:	48 8b 07             	mov    rax,QWORD PTR [rdi]
  217fb0:	0f b6 4c 24 28       	movzx  ecx,BYTE PTR [rsp+0x28]
  217fb5:	41 89 cc             	mov    r12d,ecx
  217fb8:	49 8b 09             	mov    rcx,QWORD PTR [r9]
  217fbb:	48 39 c1             	cmp    rcx,rax
  217fbe:	72 0c                	jb     217fcc <Benchmark_reportStats+0x188c>
  217fc0:	44 3a 64 24 20       	cmp    r12b,BYTE PTR [rsp+0x20]
  217fc5:	76 29                	jbe    217ff0 <Benchmark_reportStats+0x18b0>
  217fc7:	48 39 c8             	cmp    rax,rcx
  217fca:	72 24                	jb     217ff0 <Benchmark_reportStats+0x18b0>
    const tmp = a.*;
  217fcc:	c5 f8 10 07          	vmovups xmm0,XMMWORD PTR [rdi]
  217fd0:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  217fd7:	00 00 
    a.* = b.*;
  217fd9:	c4 c1 78 10 01       	vmovups xmm0,XMMWORD PTR [r9]
  217fde:	c5 f8 11 07          	vmovups XMMWORD PTR [rdi],xmm0
    b.* = tmp;
  217fe2:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  217fe9:	00 00 
  217feb:	c4 c1 7a 7f 01       	vmovdqu XMMWORD PTR [r9],xmm0
        return self.decimal >= self.size;
  217ff0:	4c 3b 94 24 f0 00 00 	cmp    r10,QWORD PTR [rsp+0xf0]
  217ff7:	00 
    while (!iterator.finished()) {
  217ff8:	0f 82 12 ec ff ff    	jb     216c10 <Benchmark_reportStats+0x4d0>
  217ffe:	eb 19                	jmp    218019 <Benchmark_reportStats+0x18d9>
  218000:	8b 44 24 20          	mov    eax,DWORD PTR [rsp+0x20]
  218004:	88 44 24 58          	mov    BYTE PTR [rsp+0x58],al
  218008:	0f b6 44 24 10       	movzx  eax,BYTE PTR [rsp+0x10]
  21800d:	89 44 24 20          	mov    DWORD PTR [rsp+0x20],eax
  218011:	45 89 c8             	mov    r8d,r9d
  218014:	e9 bd f6 ff ff       	jmp    2176d6 <Benchmark_reportStats+0xf96>
    if (items.len < 8) return;
  218019:	48 83 7c 24 48 08    	cmp    QWORD PTR [rsp+0x48],0x8
  21801f:	4c 8b a4 24 d8 00 00 	mov    r12,QWORD PTR [rsp+0xd8]
  218026:	00 
  218027:	0f 82 e1 6e 00 00    	jb     21ef0e <Benchmark_reportStats+0x87ce>
  21802d:	4c 8b 8c 24 e0 00 00 	mov    r9,QWORD PTR [rsp+0xe0]
  218034:	00 
        if (iterator.length() < cache.len) {
  218035:	49 81 fc 00 02 00 00 	cmp    r12,0x200
  21803c:	4c 89 a4 24 d8 00 00 	mov    QWORD PTR [rsp+0xd8],r12
  218043:	00 
  218044:	4c 89 8c 24 e0 00 00 	mov    QWORD PTR [rsp+0xe0],r9
  21804b:	00 
  21804c:	0f 82 2d 49 00 00    	jb     21c97f <Benchmark_reportStats+0x623f>
  218052:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  218059:	1f 84 00 00 00 00 00 
  218060:	48 b9 00 00 00 00 00 	movabs rcx,0x4000000000000000
  218067:	00 00 40 
  21806a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  218070:	48 89 c8             	mov    rax,rcx
    var res: T = 0;
    var one: T = 1 << (T.bit_count - 2);

    // "one" starts at the highest power of four <= than the argument.
    while (one > op) {
        one >>= 2;
  218073:	48 c1 e9 02          	shr    rcx,0x2
    while (one > op) {
  218077:	4c 39 e0             	cmp    rax,r12
  21807a:	77 f4                	ja     218070 <Benchmark_reportStats+0x1930>
  21807c:	31 c9                	xor    ecx,ecx
    }

    while (one != 0) {
  21807e:	48 85 c0             	test   rax,rax
  218081:	74 29                	je     2180ac <Benchmark_reportStats+0x196c>
  218083:	4c 89 e2             	mov    rdx,r12
  218086:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  21808d:	00 00 00 
        if (op >= res + one) {
  218090:	48 8d 3c 01          	lea    rdi,[rcx+rax*1]
  218094:	48 89 d6             	mov    rsi,rdx
  218097:	48 29 fe             	sub    rsi,rdi
  21809a:	72 07                	jb     2180a3 <Benchmark_reportStats+0x1963>
            op -= res + one;
            res += 2 * one;
  21809c:	48 8d 0c 41          	lea    rcx,[rcx+rax*2]
  2180a0:	48 89 f2             	mov    rdx,rsi
        }
        res >>= 1;
  2180a3:	48 d1 e9             	shr    rcx,1
        one >>= 2;
  2180a6:	48 c1 e8 02          	shr    rax,0x2
    while (one != 0) {
  2180aa:	75 e4                	jne    218090 <Benchmark_reportStats+0x1950>
            var block_size: usize = math.sqrt(iterator.length());
  2180ac:	89 c9                	mov    ecx,ecx
  2180ae:	4c 89 e0             	mov    rax,r12
  2180b1:	48 c1 e8 20          	shr    rax,0x20
  2180b5:	74 0d                	je     2180c4 <Benchmark_reportStats+0x1984>
  2180b7:	31 d2                	xor    edx,edx
  2180b9:	4c 89 e0             	mov    rax,r12
  2180bc:	48 f7 f1             	div    rcx
  2180bf:	48 89 c7             	mov    rdi,rax
  2180c2:	eb 09                	jmp    2180cd <Benchmark_reportStats+0x198d>
  2180c4:	31 d2                	xor    edx,edx
  2180c6:	44 89 e0             	mov    eax,r12d
  2180c9:	f7 f1                	div    ecx
  2180cb:	89 c7                	mov    edi,eax
            if (block_size <= cache.len) {
  2180cd:	81 f9 00 02 00 00    	cmp    ecx,0x200
  2180d3:	0f 97 c0             	seta   al
            find = buffer_size + buffer_size;
  2180d6:	48 8d 34 3f          	lea    rsi,[rdi+rdi*1]
  2180da:	48 83 c6 02          	add    rsi,0x2
            } else if (find > iterator.length()) {
  2180de:	4c 39 e6             	cmp    rsi,r12
  2180e1:	0f 97 c3             	seta   bl
            var buffer_size = iterator.length() / block_size + 1;
  2180e4:	48 8d 57 01          	lea    rdx,[rdi+0x1]
  2180e8:	48 89 74 24 58       	mov    QWORD PTR [rsp+0x58],rsi
            if (block_size <= cache.len) {
  2180ed:	49 89 f6             	mov    r14,rsi
  2180f0:	4c 0f 47 f2          	cmova  r14,rdx
  2180f4:	48 89 8c 24 08 01 00 	mov    QWORD PTR [rsp+0x108],rcx
  2180fb:	00 
  2180fc:	81 f9 01 02 00 00    	cmp    ecx,0x201
  218102:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
            var pull = []Pull{
  218106:	c5 fe 7f 84 24 b0 00 	vmovdqu YMMWORD PTR [rsp+0xb0],ymm0
  21810d:	00 00 
  21810f:	c5 fd 7f 84 24 a0 00 	vmovdqa YMMWORD PTR [rsp+0xa0],ymm0
  218116:	00 00 
  218118:	c5 fd 7f 84 24 80 00 	vmovdqa YMMWORD PTR [rsp+0x80],ymm0
  21811f:	00 00 
  218121:	48 89 54 24 78       	mov    QWORD PTR [rsp+0x78],rdx
            if (block_size <= cache.len) {
  218126:	4c 0f 42 f2          	cmovb  r14,rdx
  21812a:	20 c3                	and    bl,al
  21812c:	89 9c 24 f8 00 00 00 	mov    DWORD PTR [rsp+0xf8],ebx
  218133:	31 c0                	xor    eax,eax
  218135:	48 89 44 24 38       	mov    QWORD PTR [rsp+0x38],rax
  21813a:	31 c9                	xor    ecx,ecx
  21813c:	31 db                	xor    ebx,ebx
  21813e:	31 c0                	xor    eax,eax
  218140:	48 89 44 24 70       	mov    QWORD PTR [rsp+0x70],rax
  218145:	45 31 ed             	xor    r13d,r13d
  218148:	48 89 7c 24 20       	mov    QWORD PTR [rsp+0x20],rdi
  21814d:	e9 de 00 00 00       	jmp    218230 <Benchmark_reportStats+0x1af0>
  218152:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  218159:	1f 84 00 00 00 00 00 
  218160:	4c 89 ca             	mov    rdx,r9
  218163:	48 8b 7c 24 20       	mov    rdi,QWORD PTR [rsp+0x20]
                if (count >= buffer_size) {
  218168:	49 39 f8             	cmp    r8,rdi
  21816b:	0f 87 1d 05 00 00    	ja     21868e <Benchmark_reportStats+0x1f4e>
  218171:	e9 ae 05 00 00       	jmp    218724 <Benchmark_reportStats+0x1fe4>
  218176:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  21817d:	00 00 00 
            if (block_size <= cache.len) {
  218180:	81 bc 24 08 01 00 00 	cmp    DWORD PTR [rsp+0x108],0x200
  218187:	00 02 00 00 
  21818b:	48 8b 84 24 f0 00 00 	mov    rax,QWORD PTR [rsp+0xf0]
  218192:	00 
                    } else if (block_size <= cache.len) {
  218193:	0f 86 70 06 00 00    	jbe    218809 <Benchmark_reportStats+0x20c9>
                    } else if (find_separately) {
  218199:	f6 84 24 f8 00 00 00 	test   BYTE PTR [rsp+0xf8],0x1
  2181a0:	01 
  2181a1:	0f 84 38 3b 00 00    	je     21bcdf <Benchmark_reportStats+0x559f>
                        buffer1 = Range.init(B.end - count, B.end);
  2181a7:	48 89 ca             	mov    rdx,rcx
  2181aa:	4c 29 c2             	sub    rdx,r8
  2181ad:	48 89 54 24 70       	mov    QWORD PTR [rsp+0x70],rdx
  2181b2:	c7 84 24 f8 00 00 00 	mov    DWORD PTR [rsp+0xf8],0x0
  2181b9:	00 00 00 00 
  2181bd:	49 89 cd             	mov    r13,rcx
  2181c0:	be 01 00 00 00       	mov    esi,0x1
                    } else if (find == buffer_size + buffer_size) {
  2181c5:	48 89 74 24 38       	mov    QWORD PTR [rsp+0x38],rsi
  2181ca:	48 8b 5c 24 30       	mov    rbx,QWORD PTR [rsp+0x30]
  2181cf:	48 2b 5c 24 28       	sub    rbx,QWORD PTR [rsp+0x28]
        return self.decimal >= self.size;
  2181d4:	48 39 c1             	cmp    rcx,rax
            while (!iterator.finished()) {
  2181d7:	72 57                	jb     218230 <Benchmark_reportStats+0x1af0>
  2181d9:	e9 d0 05 00 00       	jmp    2187ae <Benchmark_reportStats+0x206e>
  2181de:	31 c0                	xor    eax,eax
  2181e0:	48 89 44 24 38       	mov    QWORD PTR [rsp+0x38],rax
  2181e5:	48 8b 84 24 f0 00 00 	mov    rax,QWORD PTR [rsp+0xf0]
  2181ec:	00 
  2181ed:	48 8b 4c 24 50       	mov    rcx,QWORD PTR [rsp+0x50]
  2181f2:	48 8b 5c 24 30       	mov    rbx,QWORD PTR [rsp+0x30]
  2181f7:	48 2b 5c 24 28       	sub    rbx,QWORD PTR [rsp+0x28]
        return self.decimal >= self.size;
  2181fc:	48 39 c1             	cmp    rcx,rax
            while (!iterator.finished()) {
  2181ff:	72 2f                	jb     218230 <Benchmark_reportStats+0x1af0>
  218201:	e9 a8 05 00 00       	jmp    2187ae <Benchmark_reportStats+0x206e>
  218206:	4c 89 ca             	mov    rdx,r9
  218209:	4c 8b 74 24 18       	mov    r14,QWORD PTR [rsp+0x18]
  21820e:	48 8b 7c 24 20       	mov    rdi,QWORD PTR [rsp+0x20]
                if (count >= buffer_size) {
  218213:	49 39 f8             	cmp    r8,rdi
  218216:	0f 87 72 04 00 00    	ja     21868e <Benchmark_reportStats+0x1f4e>
  21821c:	e9 03 05 00 00       	jmp    218724 <Benchmark_reportStats+0x1fe4>
  218221:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  218228:	0f 1f 84 00 00 00 00 
  21822f:	00 
  218230:	4c 89 ac 24 d0 00 00 	mov    QWORD PTR [rsp+0xd0],r13
  218237:	00 
  218238:	48 89 cf             	mov    rdi,rcx
        self.decimal += self.decimal_step;
  21823b:	4a 8d 04 27          	lea    rax,[rdi+r12*1]
        self.numerator += self.numerator_step;
  21823f:	4c 01 cb             	add    rbx,r9
        if (self.numerator >= self.denominator) {
  218242:	45 31 ff             	xor    r15d,r15d
  218245:	48 8b 94 24 00 01 00 	mov    rdx,QWORD PTR [rsp+0x100]
  21824c:	00 
  21824d:	48 39 d3             	cmp    rbx,rdx
  218250:	41 0f 93 c7          	setae  r15b
  218254:	48 89 d1             	mov    rcx,rdx
  218257:	be 00 00 00 00       	mov    esi,0x0
  21825c:	48 0f 42 ce          	cmovb  rcx,rsi
  218260:	48 29 cb             	sub    rbx,rcx
  218263:	49 01 c7             	add    r15,rax
        self.decimal += self.decimal_step;
  218266:	4b 8d 04 27          	lea    rax,[r15+r12*1]
        self.numerator += self.numerator_step;
  21826a:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
  21826f:	4c 01 cb             	add    rbx,r9
        if (self.numerator >= self.denominator) {
  218272:	31 c0                	xor    eax,eax
  218274:	48 89 5c 24 30       	mov    QWORD PTR [rsp+0x30],rbx
  218279:	48 39 d3             	cmp    rbx,rdx
  21827c:	0f 93 c0             	setae  al
  21827f:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  218284:	48 0f 42 d6          	cmovb  rdx,rsi
  218288:	48 89 54 24 28       	mov    QWORD PTR [rsp+0x28],rdx
                while (count < find) : ({
  21828d:	49 83 fe 02          	cmp    r14,0x2
  218291:	48 89 7c 24 60       	mov    QWORD PTR [rsp+0x60],rdi
  218296:	4c 89 74 24 18       	mov    QWORD PTR [rsp+0x18],r14
  21829b:	0f 82 df 00 00 00    	jb     218380 <Benchmark_reportStats+0x1c40>
  2182a1:	48 8b 5c 24 40       	mov    rbx,QWORD PTR [rsp+0x40]
  2182a6:	4d 8d 66 ff          	lea    r12,[r14-0x1]
  2182aa:	49 89 fe             	mov    r14,rdi
  2182ad:	41 bd 01 00 00 00    	mov    r13d,0x1
  2182b3:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  2182ba:	84 00 00 00 00 00 
                    index = findLastForward(T, items, items[last], Range.init(last + 1, A.end), lessThan, find - count);
  2182c0:	4c 89 f6             	mov    rsi,r14
  2182c3:	48 c1 e6 04          	shl    rsi,0x4
  2182c7:	48 01 de             	add    rsi,rbx
  2182ca:	49 8d 56 01          	lea    rdx,[r14+0x1]
  2182ce:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  2182d3:	4c 89 f9             	mov    rcx,r15
  2182d6:	4d 89 e0             	mov    r8,r12
  2182d9:	c5 f8 77             	vzeroupper 
  2182dc:	e8 df 6f 00 00       	call   21f2c0 <findLastForward>
                    if (index == A.end) break;
  2182e1:	4c 39 f8             	cmp    rax,r15
  2182e4:	0f 84 d6 00 00 00    	je     2183c0 <Benchmark_reportStats+0x1c80>
                    count += 1;
  2182ea:	49 83 c5 01          	add    r13,0x1
                while (count < find) : ({
  2182ee:	49 83 c4 ff          	add    r12,0xffffffffffffffff
  2182f2:	49 89 c6             	mov    r14,rax
  2182f5:	4c 39 6c 24 18       	cmp    QWORD PTR [rsp+0x18],r13
  2182fa:	77 c4                	ja     2182c0 <Benchmark_reportStats+0x1b80>
  2182fc:	48 8b 54 24 50       	mov    rdx,QWORD PTR [rsp+0x50]
  218301:	48 03 54 24 10       	add    rdx,QWORD PTR [rsp+0x10]
                if (count >= buffer_size) {
  218306:	4c 3b 6c 24 20       	cmp    r13,QWORD PTR [rsp+0x20]
  21830b:	0f 86 8d 00 00 00    	jbe    21839e <Benchmark_reportStats+0x1c5e>
                    pull[pull_index] = Pull{
  218311:	48 8b 4c 24 38       	mov    rcx,QWORD PTR [rsp+0x38]
  218316:	48 8d 0c 89          	lea    rcx,[rcx+rcx*4]
  21831a:	48 89 84 cc 80 00 00 	mov    QWORD PTR [rsp+rcx*8+0x80],rax
  218321:	00 
  218322:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
  218327:	48 89 84 cc 88 00 00 	mov    QWORD PTR [rsp+rcx*8+0x88],rax
  21832e:	00 
  21832f:	4c 89 ac cc 90 00 00 	mov    QWORD PTR [rsp+rcx*8+0x90],r13
  218336:	00 
  218337:	48 89 84 cc 98 00 00 	mov    QWORD PTR [rsp+rcx*8+0x98],rax
  21833e:	00 
  21833f:	48 89 94 cc a0 00 00 	mov    QWORD PTR [rsp+rcx*8+0xa0],rdx
  218346:	00 
  218347:	48 8b 74 24 58       	mov    rsi,QWORD PTR [rsp+0x58]
                    if (count == buffer_size + buffer_size) {
  21834c:	49 39 f5             	cmp    r13,rsi
  21834f:	4c 8b 74 24 18       	mov    r14,QWORD PTR [rsp+0x18]
  218354:	0f 84 5e 04 00 00    	je     2187b8 <Benchmark_reportStats+0x2078>
  21835a:	49 01 c5             	add    r13,rax
                    } else if (find == buffer_size + buffer_size) {
  21835d:	49 39 f6             	cmp    r14,rsi
  218360:	75 7e                	jne    2183e0 <Benchmark_reportStats+0x1ca0>
  218362:	48 89 44 24 70       	mov    QWORD PTR [rsp+0x70],rax
  218367:	b8 01 00 00 00       	mov    eax,0x1
  21836c:	48 89 44 24 38       	mov    QWORD PTR [rsp+0x38],rax
  218371:	4c 8b 74 24 78       	mov    r14,QWORD PTR [rsp+0x78]
  218376:	e9 fe 00 00 00       	jmp    218479 <Benchmark_reportStats+0x1d39>
  21837b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  218380:	41 bd 01 00 00 00    	mov    r13d,0x1
  218386:	48 89 f8             	mov    rax,rdi
  218389:	48 8b 54 24 50       	mov    rdx,QWORD PTR [rsp+0x50]
  21838e:	48 03 54 24 10       	add    rdx,QWORD PTR [rsp+0x10]
                if (count >= buffer_size) {
  218393:	4c 3b 6c 24 20       	cmp    r13,QWORD PTR [rsp+0x20]
  218398:	0f 87 73 ff ff ff    	ja     218311 <Benchmark_reportStats+0x1bd1>
                } else if (pull_index == 0 and count > buffer1.length()) {
  21839e:	48 83 7c 24 38 00    	cmp    QWORD PTR [rsp+0x38],0x0
  2183a4:	4c 8b 74 24 18       	mov    r14,QWORD PTR [rsp+0x18]
  2183a9:	74 78                	je     218423 <Benchmark_reportStats+0x1ce3>
  2183ab:	4c 8b ac 24 d0 00 00 	mov    r13,QWORD PTR [rsp+0xd0]
  2183b2:	00 
  2183b3:	e9 c1 00 00 00       	jmp    218479 <Benchmark_reportStats+0x1d39>
  2183b8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  2183bf:	00 
  2183c0:	4c 89 f0             	mov    rax,r14
  2183c3:	48 8b 54 24 50       	mov    rdx,QWORD PTR [rsp+0x50]
  2183c8:	48 03 54 24 10       	add    rdx,QWORD PTR [rsp+0x10]
                if (count >= buffer_size) {
  2183cd:	4c 3b 6c 24 20       	cmp    r13,QWORD PTR [rsp+0x20]
  2183d2:	0f 87 39 ff ff ff    	ja     218311 <Benchmark_reportStats+0x1bd1>
  2183d8:	eb c4                	jmp    21839e <Benchmark_reportStats+0x1c5e>
  2183da:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
            if (block_size <= cache.len) {
  2183e0:	81 bc 24 08 01 00 00 	cmp    DWORD PTR [rsp+0x108],0x201
  2183e7:	01 02 00 00 
  2183eb:	4c 8b a4 24 d8 00 00 	mov    r12,QWORD PTR [rsp+0xd8]
  2183f2:	00 
                    } else if (block_size <= cache.len) {
  2183f3:	0f 82 01 04 00 00    	jb     2187fa <Benchmark_reportStats+0x20ba>
                    } else if (find_separately) {
  2183f9:	f6 84 24 f8 00 00 00 	test   BYTE PTR [rsp+0xf8],0x1
  218400:	01 
  218401:	0f 84 ce 38 00 00    	je     21bcd5 <Benchmark_reportStats+0x5595>
  218407:	c7 84 24 f8 00 00 00 	mov    DWORD PTR [rsp+0xf8],0x0
  21840e:	00 00 00 00 
  218412:	48 89 44 24 70       	mov    QWORD PTR [rsp+0x70],rax
  218417:	b8 01 00 00 00       	mov    eax,0x1
  21841c:	48 89 44 24 38       	mov    QWORD PTR [rsp+0x38],rax
  218421:	eb 5e                	jmp    218481 <Benchmark_reportStats+0x1d41>
  218423:	48 8b b4 24 d0 00 00 	mov    rsi,QWORD PTR [rsp+0xd0]
  21842a:	00 
        return self.end - self.start;
  21842b:	48 89 f1             	mov    rcx,rsi
  21842e:	48 2b 4c 24 70       	sub    rcx,QWORD PTR [rsp+0x70]
                } else if (pull_index == 0 and count > buffer1.length()) {
  218433:	49 39 cd             	cmp    r13,rcx
  218436:	76 37                	jbe    21846f <Benchmark_reportStats+0x1d2f>
                    pull[pull_index] = Pull{
  218438:	48 89 84 24 80 00 00 	mov    QWORD PTR [rsp+0x80],rax
  21843f:	00 
  218440:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
  218445:	48 89 84 24 88 00 00 	mov    QWORD PTR [rsp+0x88],rax
  21844c:	00 
  21844d:	4c 89 ac 24 90 00 00 	mov    QWORD PTR [rsp+0x90],r13
  218454:	00 
  218455:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  21845c:	00 
                    buffer1 = Range.init(A.start, A.start + count);
  21845d:	49 01 c5             	add    r13,rax
                    pull[pull_index] = Pull{
  218460:	48 89 94 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rdx
  218467:	00 
  218468:	48 89 44 24 70       	mov    QWORD PTR [rsp+0x70],rax
  21846d:	eb 03                	jmp    218472 <Benchmark_reportStats+0x1d32>
  21846f:	49 89 f5             	mov    r13,rsi
  218472:	31 c0                	xor    eax,eax
  218474:	48 89 44 24 38       	mov    QWORD PTR [rsp+0x38],rax
  218479:	4c 8b a4 24 d8 00 00 	mov    r12,QWORD PTR [rsp+0xd8]
  218480:	00 
  218481:	48 89 d0             	mov    rax,rdx
  218484:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
  218489:	48 8d 52 ff          	lea    rdx,[rdx-0x1]
                while (count < find) : ({
  21848d:	49 83 fe 02          	cmp    r14,0x2
  218491:	0f 82 79 02 00 00    	jb     218710 <Benchmark_reportStats+0x1fd0>
  218497:	4c 8b 5c 24 40       	mov    r11,QWORD PTR [rsp+0x40]
  21849c:	49 89 d1             	mov    r9,rdx
  21849f:	41 b8 01 00 00 00    	mov    r8d,0x1
  2184a5:	4c 89 74 24 18       	mov    QWORD PTR [rsp+0x18],r14
  2184aa:	eb 74                	jmp    218520 <Benchmark_reportStats+0x1de0>
  2184ac:	48 89 ce             	mov    rsi,rcx
    if (range.start >= range.end) return range.end;
  2184af:	48 85 c0             	test   rax,rax
  2184b2:	0f 85 01 01 00 00    	jne    2185b9 <Benchmark_reportStats+0x1e79>
  2184b8:	e9 7f 01 00 00       	jmp    21863c <Benchmark_reportStats+0x1efc>
    while (start < end) {
  2184bd:	4c 39 ff             	cmp    rdi,r15
  2184c0:	0f 86 40 fd ff ff    	jbe    218206 <Benchmark_reportStats+0x1ac6>
  2184c6:	4c 89 fa             	mov    rdx,r15
  2184c9:	4c 8b 74 24 18       	mov    r14,QWORD PTR [rsp+0x18]
  2184ce:	66 90                	xchg   ax,ax
        const mid = start + (end - start) / 2;
  2184d0:	48 89 f8             	mov    rax,rdi
  2184d3:	48 29 d0             	sub    rax,rdx
  2184d6:	48 d1 e8             	shr    rax,1
  2184d9:	48 8d 0c 10          	lea    rcx,[rax+rdx*1]
  2184dd:	48 89 ce             	mov    rsi,rcx
  2184e0:	48 c1 e6 04          	shl    rsi,0x4
  2184e4:	49 39 1c 33          	cmp    QWORD PTR [r11+rsi*1],rbx
        if (lessThan(items[mid], value)) {
  2184e8:	72 16                	jb     218500 <Benchmark_reportStats+0x1dc0>
  2184ea:	48 89 cf             	mov    rdi,rcx
    while (start < end) {
  2184ed:	48 39 d7             	cmp    rdi,rdx
  2184f0:	77 de                	ja     2184d0 <Benchmark_reportStats+0x1d90>
  2184f2:	e9 5e 01 00 00       	jmp    218655 <Benchmark_reportStats+0x1f15>
  2184f7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  2184fe:	00 00 
  218500:	48 01 c2             	add    rdx,rax
  218503:	48 83 c2 01          	add    rdx,0x1
  218507:	48 39 d7             	cmp    rdi,rdx
  21850a:	77 c4                	ja     2184d0 <Benchmark_reportStats+0x1d90>
  21850c:	e9 44 01 00 00       	jmp    218655 <Benchmark_reportStats+0x1f15>
  218511:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  218518:	0f 1f 84 00 00 00 00 
  21851f:	00 
    if (range.length() == 0) return range.start;
  218520:	4c 89 c8             	mov    rax,r9
  218523:	4c 29 f8             	sub    rax,r15
  218526:	0f 84 34 fc ff ff    	je     218160 <Benchmark_reportStats+0x1a20>
  21852c:	4d 89 ca             	mov    r10,r9
  21852f:	49 c1 e2 04          	shl    r10,0x4
                    index = findFirstBackward(T, items, items[last], Range.init(B.start, last), lessThan, find - count);
  218533:	4c 89 f1             	mov    rcx,r14
  218536:	4c 29 c1             	sub    rcx,r8
  218539:	48 89 c2             	mov    rdx,rax
  21853c:	48 09 ca             	or     rdx,rcx
  21853f:	48 c1 ea 20          	shr    rdx,0x20
  218543:	74 0b                	je     218550 <Benchmark_reportStats+0x1e10>
  218545:	31 d2                	xor    edx,edx
  218547:	48 f7 f1             	div    rcx
  21854a:	eb 08                	jmp    218554 <Benchmark_reportStats+0x1e14>
  21854c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  218550:	31 d2                	xor    edx,edx
  218552:	f7 f1                	div    ecx
  218554:	4d 01 da             	add    r10,r11
    return if (x > y) x else y;
  218557:	48 83 f8 01          	cmp    rax,0x1
  21855b:	b9 01 00 00 00       	mov    ecx,0x1
  218560:	48 0f 46 c1          	cmovbe rax,rcx
  218564:	4c 89 ce             	mov    rsi,r9
  218567:	48 29 c6             	sub    rsi,rax
    while (index > range.start and !lessThan(items[index - 1], value)) : (index -= skip) {
  21856a:	4c 39 fe             	cmp    rsi,r15
  21856d:	0f 86 bd 00 00 00    	jbe    218630 <Benchmark_reportStats+0x1ef0>
  218573:	49 8b 1a             	mov    rbx,QWORD PTR [r10]
  218576:	4e 8d 34 38          	lea    r14,[rax+r15*1]
  21857a:	4c 89 ca             	mov    rdx,r9
  21857d:	0f 1f 00             	nop    DWORD PTR [rax]
  218580:	48 89 f1             	mov    rcx,rsi
  218583:	48 8d 79 ff          	lea    rdi,[rcx-0x1]
  218587:	48 89 fe             	mov    rsi,rdi
  21858a:	48 c1 e6 04          	shl    rsi,0x4
  21858e:	49 39 1c 33          	cmp    QWORD PTR [r11+rsi*1],rbx
  218592:	0f 82 14 ff ff ff    	jb     2184ac <Benchmark_reportStats+0x1d6c>
        if (index < range.start + skip) {
  218598:	4c 39 f1             	cmp    rcx,r14
  21859b:	0f 82 1c ff ff ff    	jb     2184bd <Benchmark_reportStats+0x1d7d>
  2185a1:	48 89 ce             	mov    rsi,rcx
  2185a4:	48 29 c6             	sub    rsi,rax
  2185a7:	48 89 ca             	mov    rdx,rcx
    while (index > range.start and !lessThan(items[index - 1], value)) : (index -= skip) {
  2185aa:	4c 39 fe             	cmp    rsi,r15
  2185ad:	77 d1                	ja     218580 <Benchmark_reportStats+0x1e40>
  2185af:	90                   	nop
    if (range.start >= range.end) return range.end;
  2185b0:	48 85 c0             	test   rax,rax
  2185b3:	0f 84 83 00 00 00    	je     21863c <Benchmark_reportStats+0x1efc>
    var end = range.end - 1;
  2185b9:	48 83 c2 ff          	add    rdx,0xffffffffffffffff
    while (start < end) {
  2185bd:	48 39 f2             	cmp    rdx,rsi
  2185c0:	76 4a                	jbe    21860c <Benchmark_reportStats+0x1ecc>
  2185c2:	4d 8b 32             	mov    r14,QWORD PTR [r10]
  2185c5:	48 89 d3             	mov    rbx,rdx
  2185c8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  2185cf:	00 
        const mid = start + (end - start) / 2;
  2185d0:	48 89 d9             	mov    rcx,rbx
  2185d3:	48 29 f1             	sub    rcx,rsi
  2185d6:	48 d1 e9             	shr    rcx,1
  2185d9:	48 8d 04 31          	lea    rax,[rcx+rsi*1]
  2185dd:	48 89 c7             	mov    rdi,rax
  2185e0:	48 c1 e7 04          	shl    rdi,0x4
  2185e4:	4d 39 34 3b          	cmp    QWORD PTR [r11+rdi*1],r14
        if (lessThan(items[mid], value)) {
  2185e8:	72 16                	jb     218600 <Benchmark_reportStats+0x1ec0>
  2185ea:	48 89 c3             	mov    rbx,rax
    while (start < end) {
  2185ed:	48 39 f3             	cmp    rbx,rsi
  2185f0:	77 de                	ja     2185d0 <Benchmark_reportStats+0x1e90>
  2185f2:	eb 18                	jmp    21860c <Benchmark_reportStats+0x1ecc>
  2185f4:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  2185fb:	00 00 00 00 00 
  218600:	48 01 ce             	add    rsi,rcx
  218603:	48 83 c6 01          	add    rsi,0x1
  218607:	48 39 f3             	cmp    rbx,rsi
  21860a:	77 c4                	ja     2185d0 <Benchmark_reportStats+0x1e90>
    if (start == range.end - 1 and lessThan(items[start], value)) {
  21860c:	48 39 d6             	cmp    rsi,rdx
  21860f:	4c 8b 74 24 18       	mov    r14,QWORD PTR [rsp+0x18]
  218614:	75 3a                	jne    218650 <Benchmark_reportStats+0x1f10>
  218616:	48 c1 e2 04          	shl    rdx,0x4
  21861a:	49 8b 04 13          	mov    rax,QWORD PTR [r11+rdx*1]
  21861e:	31 d2                	xor    edx,edx
  218620:	49 3b 02             	cmp    rax,QWORD PTR [r10]
  218623:	0f 92 c2             	setb   dl
  218626:	eb 2a                	jmp    218652 <Benchmark_reportStats+0x1f12>
  218628:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  21862f:	00 
  218630:	4c 89 ca             	mov    rdx,r9
    if (range.start >= range.end) return range.end;
  218633:	48 85 c0             	test   rax,rax
  218636:	0f 85 7d ff ff ff    	jne    2185b9 <Benchmark_reportStats+0x1e79>
  21863c:	4c 8b 74 24 18       	mov    r14,QWORD PTR [rsp+0x18]
                    if (index == B.start) break;
  218641:	4c 39 fa             	cmp    rdx,r15
  218644:	75 18                	jne    21865e <Benchmark_reportStats+0x1f1e>
  218646:	e9 15 fb ff ff       	jmp    218160 <Benchmark_reportStats+0x1a20>
  21864b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  218650:	31 d2                	xor    edx,edx
    if (start == range.end - 1 and lessThan(items[start], value)) {
  218652:	48 01 f2             	add    rdx,rsi
                    if (index == B.start) break;
  218655:	4c 39 fa             	cmp    rdx,r15
  218658:	0f 84 02 fb ff ff    	je     218160 <Benchmark_reportStats+0x1a20>
                    count += 1;
  21865e:	49 83 c0 01          	add    r8,0x1
  218662:	48 83 c2 ff          	add    rdx,0xffffffffffffffff
  218666:	49 89 d1             	mov    r9,rdx
                while (count < find) : ({
  218669:	4d 39 c6             	cmp    r14,r8
  21866c:	0f 87 ae fe ff ff    	ja     218520 <Benchmark_reportStats+0x1de0>
  218672:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  218679:	1f 84 00 00 00 00 00 
  218680:	48 8b 7c 24 20       	mov    rdi,QWORD PTR [rsp+0x20]
                if (count >= buffer_size) {
  218685:	49 39 f8             	cmp    r8,rdi
  218688:	0f 86 96 00 00 00    	jbe    218724 <Benchmark_reportStats+0x1fe4>
                    pull[pull_index] = Pull{
  21868e:	48 8b 44 24 38       	mov    rax,QWORD PTR [rsp+0x38]
  218693:	48 8d 04 80          	lea    rax,[rax+rax*4]
  218697:	48 89 94 c4 80 00 00 	mov    QWORD PTR [rsp+rax*8+0x80],rdx
  21869e:	00 
  21869f:	48 8b 4c 24 50       	mov    rcx,QWORD PTR [rsp+0x50]
  2186a4:	48 89 8c c4 88 00 00 	mov    QWORD PTR [rsp+rax*8+0x88],rcx
  2186ab:	00 
  2186ac:	4c 89 84 c4 90 00 00 	mov    QWORD PTR [rsp+rax*8+0x90],r8
  2186b3:	00 
  2186b4:	48 8b 54 24 60       	mov    rdx,QWORD PTR [rsp+0x60]
  2186b9:	48 89 94 c4 98 00 00 	mov    QWORD PTR [rsp+rax*8+0x98],rdx
  2186c0:	00 
  2186c1:	48 89 8c c4 a0 00 00 	mov    QWORD PTR [rsp+rax*8+0xa0],rcx
  2186c8:	00 
  2186c9:	48 8b 54 24 58       	mov    rdx,QWORD PTR [rsp+0x58]
                    if (count == buffer_size + buffer_size) {
  2186ce:	49 39 d0             	cmp    r8,rdx
  2186d1:	4c 8b 8c 24 e0 00 00 	mov    r9,QWORD PTR [rsp+0xe0]
  2186d8:	00 
  2186d9:	0f 84 fe 00 00 00    	je     2187dd <Benchmark_reportStats+0x209d>
                    } else if (find == buffer_size + buffer_size) {
  2186df:	49 39 d6             	cmp    r14,rdx
  2186e2:	0f 85 98 fa ff ff    	jne    218180 <Benchmark_reportStats+0x1a40>
                        buffer1 = Range.init(B.end - count, B.end);
  2186e8:	48 89 c8             	mov    rax,rcx
  2186eb:	4c 29 c0             	sub    rax,r8
  2186ee:	48 89 44 24 70       	mov    QWORD PTR [rsp+0x70],rax
  2186f3:	49 89 cd             	mov    r13,rcx
  2186f6:	b8 01 00 00 00       	mov    eax,0x1
  2186fb:	48 89 44 24 38       	mov    QWORD PTR [rsp+0x38],rax
  218700:	4c 8b 74 24 78       	mov    r14,QWORD PTR [rsp+0x78]
  218705:	e9 89 00 00 00       	jmp    218793 <Benchmark_reportStats+0x2053>
  21870a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  218710:	41 b8 01 00 00 00    	mov    r8d,0x1
  218716:	48 8b 7c 24 20       	mov    rdi,QWORD PTR [rsp+0x20]
                if (count >= buffer_size) {
  21871b:	49 39 f8             	cmp    r8,rdi
  21871e:	0f 87 6a ff ff ff    	ja     21868e <Benchmark_reportStats+0x1f4e>
                } else if (pull_index == 0 and count > buffer1.length()) {
  218724:	48 83 7c 24 38 00    	cmp    QWORD PTR [rsp+0x38],0x0
  21872a:	4c 8b 8c 24 e0 00 00 	mov    r9,QWORD PTR [rsp+0xe0]
  218731:	00 
  218732:	0f 85 ad fa ff ff    	jne    2181e5 <Benchmark_reportStats+0x1aa5>
        return self.end - self.start;
  218738:	4c 89 e8             	mov    rax,r13
  21873b:	48 2b 44 24 70       	sub    rax,QWORD PTR [rsp+0x70]
                } else if (pull_index == 0 and count > buffer1.length()) {
  218740:	49 39 c0             	cmp    r8,rax
  218743:	0f 86 95 fa ff ff    	jbe    2181de <Benchmark_reportStats+0x1a9e>
  218749:	48 8b 44 24 50       	mov    rax,QWORD PTR [rsp+0x50]
                    buffer1 = Range.init(B.end - count, B.end);
  21874e:	48 89 c6             	mov    rsi,rax
                    pull[pull_index] = Pull{
  218751:	48 89 94 24 80 00 00 	mov    QWORD PTR [rsp+0x80],rdx
  218758:	00 
  218759:	48 89 c1             	mov    rcx,rax
  21875c:	48 89 8c 24 88 00 00 	mov    QWORD PTR [rsp+0x88],rcx
  218763:	00 
  218764:	4c 89 84 24 90 00 00 	mov    QWORD PTR [rsp+0x90],r8
  21876b:	00 
  21876c:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
  218771:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  218778:	00 
                    buffer1 = Range.init(B.end - count, B.end);
  218779:	4c 29 c6             	sub    rsi,r8
  21877c:	48 89 74 24 70       	mov    QWORD PTR [rsp+0x70],rsi
                    pull[pull_index] = Pull{
  218781:	48 89 8c 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rcx
  218788:	00 
  218789:	49 89 cd             	mov    r13,rcx
  21878c:	31 c0                	xor    eax,eax
  21878e:	48 89 44 24 38       	mov    QWORD PTR [rsp+0x38],rax
  218793:	48 8b 84 24 f0 00 00 	mov    rax,QWORD PTR [rsp+0xf0]
  21879a:	00 
  21879b:	48 8b 5c 24 30       	mov    rbx,QWORD PTR [rsp+0x30]
  2187a0:	48 2b 5c 24 28       	sub    rbx,QWORD PTR [rsp+0x28]
        return self.decimal >= self.size;
  2187a5:	48 39 c1             	cmp    rcx,rax
            while (!iterator.finished()) {
  2187a8:	0f 82 82 fa ff ff    	jb     218230 <Benchmark_reportStats+0x1af0>
  2187ae:	4c 89 ac 24 d0 00 00 	mov    QWORD PTR [rsp+0xd0],r13
  2187b5:	00 
  2187b6:	eb 64                	jmp    21881c <Benchmark_reportStats+0x20dc>
  2187b8:	48 8b 4c 24 78       	mov    rcx,QWORD PTR [rsp+0x78]
                        buffer1 = Range.init(A.start, A.start + buffer_size);
  2187bd:	48 01 c1             	add    rcx,rax
                        buffer2 = Range.init(A.start + buffer_size, A.start + count);
  2187c0:	48 01 c6             	add    rsi,rax
  2187c3:	48 89 8c 24 d0 00 00 	mov    QWORD PTR [rsp+0xd0],rcx
  2187ca:	00 
  2187cb:	48 89 44 24 70       	mov    QWORD PTR [rsp+0x70],rax
  2187d0:	48 89 f0             	mov    rax,rsi
  2187d3:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
  2187d8:	48 89 c8             	mov    rax,rcx
  2187db:	eb 48                	jmp    218825 <Benchmark_reportStats+0x20e5>
                        buffer1 = Range.init(B.end - count, B.end - buffer_size);
  2187dd:	48 89 c8             	mov    rax,rcx
  2187e0:	48 29 d0             	sub    rax,rdx
  2187e3:	48 89 44 24 70       	mov    QWORD PTR [rsp+0x70],rax
  2187e8:	48 2b 4c 24 78       	sub    rcx,QWORD PTR [rsp+0x78]
  2187ed:	48 89 8c 24 d0 00 00 	mov    QWORD PTR [rsp+0xd0],rcx
  2187f4:	00 
  2187f5:	48 89 c8             	mov    rax,rcx
  2187f8:	eb 2b                	jmp    218825 <Benchmark_reportStats+0x20e5>
  2187fa:	4c 89 ac 24 d0 00 00 	mov    QWORD PTR [rsp+0xd0],r13
  218801:	00 
  218802:	48 89 44 24 70       	mov    QWORD PTR [rsp+0x70],rax
  218807:	eb 13                	jmp    21881c <Benchmark_reportStats+0x20dc>
                        buffer1 = Range.init(B.end - count, B.end);
  218809:	48 89 c8             	mov    rax,rcx
  21880c:	4c 29 c0             	sub    rax,r8
  21880f:	48 89 44 24 70       	mov    QWORD PTR [rsp+0x70],rax
  218814:	48 89 8c 24 d0 00 00 	mov    QWORD PTR [rsp+0xd0],rcx
  21881b:	00 
  21881c:	31 c0                	xor    eax,eax
  21881e:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
  218823:	31 c0                	xor    eax,eax
  218825:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  21882a:	31 c0                	xor    eax,eax
  21882c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  218830:	48 89 44 24 58       	mov    QWORD PTR [rsp+0x58],rax
                const length = pull[pull_index].count;
  218835:	48 8d 04 80          	lea    rax,[rax+rax*4]
  218839:	48 8d 0c c4          	lea    rcx,[rsp+rax*8]
  21883d:	48 81 c1 80 00 00 00 	add    rcx,0x80
  218844:	48 89 4c 24 20       	mov    QWORD PTR [rsp+0x20],rcx
  218849:	48 8b 94 c4 90 00 00 	mov    rdx,QWORD PTR [rsp+rax*8+0x90]
  218850:	00 
                if (pull[pull_index].to < pull[pull_index].from) {
  218851:	4c 8b a4 c4 80 00 00 	mov    r12,QWORD PTR [rsp+rax*8+0x80]
  218858:	00 
  218859:	48 8b 8c c4 88 00 00 	mov    rcx,QWORD PTR [rsp+rax*8+0x88]
  218860:	00 
  218861:	4c 39 e1             	cmp    rcx,r12
  218864:	48 89 54 24 10       	mov    QWORD PTR [rsp+0x10],rdx
  218869:	0f 83 21 06 00 00    	jae    218e90 <Benchmark_reportStats+0x2750>
                    while (count < length) : (count += 1) {
  21886f:	48 83 fa 02          	cmp    rdx,0x2
  218873:	0f 82 14 0b 00 00    	jb     21938d <Benchmark_reportStats+0x2c4d>
  218879:	49 c7 c2 ff ff ff ff 	mov    r10,0xffffffffffffffff
  218880:	49 c7 c1 fe ff ff ff 	mov    r9,0xfffffffffffffffe
  218887:	31 c0                	xor    eax,eax
  218889:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  21888e:	4d 89 e6             	mov    r14,r12
  218891:	41 bb 01 00 00 00    	mov    r11d,0x1
  218897:	eb 13                	jmp    2188ac <Benchmark_reportStats+0x216c>
  218899:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
                        index = findFirstBackward(T, items, items[index - 1], Range.init(pull[pull_index].to, pull[pull_index].from - (count - 1)), lessThan, length - count);
  2188a0:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
                    while (count < length) : (count += 1) {
  2188a4:	49 83 c2 ff          	add    r10,0xffffffffffffffff
  2188a8:	49 83 c1 ff          	add    r9,0xffffffffffffffff
                        index = findFirstBackward(T, items, items[index - 1], Range.init(pull[pull_index].to, pull[pull_index].from - (count - 1)), lessThan, length - count);
  2188ac:	4c 8b 6c 24 40       	mov    r13,QWORD PTR [rsp+0x40]
  2188b1:	bf 01 00 00 00       	mov    edi,0x1
  2188b6:	4c 29 df             	sub    rdi,r11
  2188b9:	4c 01 e7             	add    rdi,r12
    if (range.length() == 0) return range.start;
  2188bc:	48 89 f8             	mov    rax,rdi
  2188bf:	48 29 c8             	sub    rax,rcx
  2188c2:	74 2c                	je     2188f0 <Benchmark_reportStats+0x21b0>
  2188c4:	49 c1 e6 04          	shl    r14,0x4
                        index = findFirstBackward(T, items, items[index - 1], Range.init(pull[pull_index].to, pull[pull_index].from - (count - 1)), lessThan, length - count);
  2188c8:	48 89 d6             	mov    rsi,rdx
  2188cb:	4c 29 de             	sub    rsi,r11
  2188ce:	48 89 c2             	mov    rdx,rax
  2188d1:	48 09 f2             	or     rdx,rsi
  2188d4:	48 c1 ea 20          	shr    rdx,0x20
  2188d8:	74 26                	je     218900 <Benchmark_reportStats+0x21c0>
  2188da:	31 d2                	xor    edx,edx
  2188dc:	48 f7 f6             	div    rsi
  2188df:	eb 23                	jmp    218904 <Benchmark_reportStats+0x21c4>
  2188e1:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  2188e8:	0f 1f 84 00 00 00 00 
  2188ef:	00 
  2188f0:	49 89 ce             	mov    r14,rcx
  2188f3:	e9 48 01 00 00       	jmp    218a40 <Benchmark_reportStats+0x2300>
  2188f8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  2188ff:	00 
  218900:	31 d2                	xor    edx,edx
  218902:	f7 f6                	div    esi
  218904:	48 83 f8 01          	cmp    rax,0x1
  218908:	ba 01 00 00 00       	mov    edx,0x1
  21890d:	48 0f 46 c2          	cmovbe rax,rdx
  218911:	4f 8d 3c 2e          	lea    r15,[r14+r13*1]
  218915:	49 83 c7 f0          	add    r15,0xfffffffffffffff0
  218919:	48 89 fe             	mov    rsi,rdi
  21891c:	48 29 c6             	sub    rsi,rax
    while (index > range.start and !lessThan(items[index - 1], value)) : (index -= skip) {
  21891f:	48 39 ce             	cmp    rsi,rcx
  218922:	76 3c                	jbe    218960 <Benchmark_reportStats+0x2220>
  218924:	4d 8b 07             	mov    r8,QWORD PTR [r15]
  218927:	4c 8d 34 08          	lea    r14,[rax+rcx*1]
  21892b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  218930:	48 89 f2             	mov    rdx,rsi
  218933:	48 8d 5a ff          	lea    rbx,[rdx-0x1]
  218937:	48 89 de             	mov    rsi,rbx
  21893a:	48 c1 e6 04          	shl    rsi,0x4
  21893e:	4d 39 44 35 00       	cmp    QWORD PTR [r13+rsi*1+0x0],r8
  218943:	0f 82 95 00 00 00    	jb     2189de <Benchmark_reportStats+0x229e>
        if (index < range.start + skip) {
  218949:	4c 39 f2             	cmp    rdx,r14
  21894c:	0f 82 9d 00 00 00    	jb     2189ef <Benchmark_reportStats+0x22af>
  218952:	48 89 d6             	mov    rsi,rdx
  218955:	48 29 c6             	sub    rsi,rax
  218958:	48 89 d7             	mov    rdi,rdx
    while (index > range.start and !lessThan(items[index - 1], value)) : (index -= skip) {
  21895b:	48 39 ce             	cmp    rsi,rcx
  21895e:	77 d0                	ja     218930 <Benchmark_reportStats+0x21f0>
    if (range.start >= range.end) return range.end;
  218960:	48 85 c0             	test   rax,rax
  218963:	0f 84 81 00 00 00    	je     2189ea <Benchmark_reportStats+0x22aa>
    var end = range.end - 1;
  218969:	48 83 c7 ff          	add    rdi,0xffffffffffffffff
    while (start < end) {
  21896d:	48 39 f7             	cmp    rdi,rsi
  218970:	76 4a                	jbe    2189bc <Benchmark_reportStats+0x227c>
  218972:	4d 8b 07             	mov    r8,QWORD PTR [r15]
  218975:	48 89 f9             	mov    rcx,rdi
  218978:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  21897f:	00 
        const mid = start + (end - start) / 2;
  218980:	48 89 ca             	mov    rdx,rcx
  218983:	48 29 f2             	sub    rdx,rsi
  218986:	48 d1 ea             	shr    rdx,1
  218989:	48 8d 04 32          	lea    rax,[rdx+rsi*1]
  21898d:	48 89 c3             	mov    rbx,rax
  218990:	48 c1 e3 04          	shl    rbx,0x4
  218994:	4d 39 44 1d 00       	cmp    QWORD PTR [r13+rbx*1+0x0],r8
        if (lessThan(items[mid], value)) {
  218999:	72 15                	jb     2189b0 <Benchmark_reportStats+0x2270>
  21899b:	48 89 c1             	mov    rcx,rax
    while (start < end) {
  21899e:	48 39 f1             	cmp    rcx,rsi
  2189a1:	77 dd                	ja     218980 <Benchmark_reportStats+0x2240>
  2189a3:	eb 17                	jmp    2189bc <Benchmark_reportStats+0x227c>
  2189a5:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  2189ac:	00 00 00 00 
  2189b0:	48 01 d6             	add    rsi,rdx
  2189b3:	48 83 c6 01          	add    rsi,0x1
  2189b7:	48 39 f1             	cmp    rcx,rsi
  2189ba:	77 c4                	ja     218980 <Benchmark_reportStats+0x2240>
    if (start == range.end - 1 and lessThan(items[start], value)) {
  2189bc:	48 39 fe             	cmp    rsi,rdi
  2189bf:	75 15                	jne    2189d6 <Benchmark_reportStats+0x2296>
  2189c1:	48 c1 e7 04          	shl    rdi,0x4
  2189c5:	49 8b 44 3d 00       	mov    rax,QWORD PTR [r13+rdi*1+0x0]
  2189ca:	45 31 f6             	xor    r14d,r14d
  2189cd:	49 3b 07             	cmp    rax,QWORD PTR [r15]
  2189d0:	41 0f 92 c6          	setb   r14b
  2189d4:	eb 03                	jmp    2189d9 <Benchmark_reportStats+0x2299>
  2189d6:	45 31 f6             	xor    r14d,r14d
  2189d9:	49 01 f6             	add    r14,rsi
  2189dc:	eb 62                	jmp    218a40 <Benchmark_reportStats+0x2300>
  2189de:	48 89 d6             	mov    rsi,rdx
    if (range.start >= range.end) return range.end;
  2189e1:	48 85 c0             	test   rax,rax
  2189e4:	0f 85 7f ff ff ff    	jne    218969 <Benchmark_reportStats+0x2229>
  2189ea:	49 89 fe             	mov    r14,rdi
  2189ed:	eb 51                	jmp    218a40 <Benchmark_reportStats+0x2300>
  2189ef:	49 89 ce             	mov    r14,rcx
    while (start < end) {
  2189f2:	48 39 cb             	cmp    rbx,rcx
  2189f5:	76 49                	jbe    218a40 <Benchmark_reportStats+0x2300>
  2189f7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  2189fe:	00 00 
        const mid = start + (end - start) / 2;
  218a00:	48 89 d8             	mov    rax,rbx
  218a03:	4c 29 f0             	sub    rax,r14
  218a06:	48 d1 e8             	shr    rax,1
  218a09:	4a 8d 0c 30          	lea    rcx,[rax+r14*1]
  218a0d:	48 89 ca             	mov    rdx,rcx
  218a10:	48 c1 e2 04          	shl    rdx,0x4
  218a14:	4d 39 44 15 00       	cmp    QWORD PTR [r13+rdx*1+0x0],r8
        if (lessThan(items[mid], value)) {
  218a19:	72 15                	jb     218a30 <Benchmark_reportStats+0x22f0>
  218a1b:	48 89 cb             	mov    rbx,rcx
    while (start < end) {
  218a1e:	4c 39 f3             	cmp    rbx,r14
  218a21:	77 dd                	ja     218a00 <Benchmark_reportStats+0x22c0>
  218a23:	eb 1b                	jmp    218a40 <Benchmark_reportStats+0x2300>
  218a25:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  218a2c:	00 00 00 00 
  218a30:	49 01 c6             	add    r14,rax
  218a33:	49 83 c6 01          	add    r14,0x1
  218a37:	4c 39 f3             	cmp    rbx,r14
  218a3a:	77 c4                	ja     218a00 <Benchmark_reportStats+0x22c0>
  218a3c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
                        const range = Range.init(index + 1, pull[pull_index].from + 1);
  218a40:	4d 89 f7             	mov    r15,r14
  218a43:	49 c1 e7 04          	shl    r15,0x4
  218a47:	4c 89 f0             	mov    rax,r14
  218a4a:	48 f7 d0             	not    rax
                        mem.rotate(T, items[range.start..range.end], range.length() - count);
  218a4d:	4d 8d 04 04          	lea    r8,[r12+rax*1]
  218a51:	49 83 c0 01          	add    r8,0x1
  218a55:	4c 89 c2             	mov    rdx,r8
  218a58:	4c 29 da             	sub    rdx,r11
}

/// In-place order reversal of a slice
pub fn reverse(comptime T: type, items: []T) void {
    var i: usize = 0;
    const end = items.len / 2;
  218a5b:	48 d1 ea             	shr    rdx,1
    while (i < end) : (i += 1) {
  218a5e:	0f 84 44 01 00 00    	je     218ba8 <Benchmark_reportStats+0x2468>
        swap(T, &items[i], &items[items.len - i - 1]);
  218a64:	48 8d 42 ff          	lea    rax,[rdx-0x1]
  218a68:	48 83 f8 03          	cmp    rax,0x3
  218a6c:	73 12                	jae    218a80 <Benchmark_reportStats+0x2340>
  218a6e:	31 f6                	xor    esi,esi
    while (i < end) : (i += 1) {
  218a70:	f6 c2 03             	test   dl,0x3
  218a73:	0f 85 c5 00 00 00    	jne    218b3e <Benchmark_reportStats+0x23fe>
  218a79:	e9 2a 01 00 00       	jmp    218ba8 <Benchmark_reportStats+0x2468>
  218a7e:	66 90                	xchg   ax,ax
        swap(T, &items[i], &items[items.len - i - 1]);
  218a80:	4b 8d 0c 2f          	lea    rcx,[r15+r13*1]
  218a84:	48 83 c1 40          	add    rcx,0x40
  218a88:	4b 8d 3c 14          	lea    rdi,[r12+r10*1]
  218a8c:	4c 29 f7             	sub    rdi,r14
  218a8f:	48 d1 ef             	shr    rdi,1
  218a92:	89 f8                	mov    eax,edi
  218a94:	83 e0 03             	and    eax,0x3
  218a97:	48 29 c7             	sub    rdi,rax
  218a9a:	4b 8d 04 0c          	lea    rax,[r12+r9*1]
  218a9e:	48 c1 e0 04          	shl    rax,0x4
  218aa2:	4c 01 e8             	add    rax,r13
  218aa5:	48 83 c0 10          	add    rax,0x10
  218aa9:	31 f6                	xor    esi,esi
  218aab:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
    const tmp = a.*;
  218ab0:	c5 f8 10 41 d0       	vmovups xmm0,XMMWORD PTR [rcx-0x30]
  218ab5:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  218aba:	c5 f8 10 00          	vmovups xmm0,XMMWORD PTR [rax]
  218abe:	c5 f8 11 41 d0       	vmovups XMMWORD PTR [rcx-0x30],xmm0
    b.* = tmp;
  218ac3:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  218ac8:	c5 f8 11 00          	vmovups XMMWORD PTR [rax],xmm0
    const tmp = a.*;
  218acc:	c5 f8 10 41 e0       	vmovups xmm0,XMMWORD PTR [rcx-0x20]
  218ad1:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  218ad6:	c5 f8 10 40 f0       	vmovups xmm0,XMMWORD PTR [rax-0x10]
  218adb:	c5 f8 11 41 e0       	vmovups XMMWORD PTR [rcx-0x20],xmm0
    b.* = tmp;
  218ae0:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  218ae5:	c5 f8 11 40 f0       	vmovups XMMWORD PTR [rax-0x10],xmm0
    const tmp = a.*;
  218aea:	c5 f8 10 41 f0       	vmovups xmm0,XMMWORD PTR [rcx-0x10]
  218aef:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  218af4:	c5 f8 10 40 e0       	vmovups xmm0,XMMWORD PTR [rax-0x20]
  218af9:	c5 f8 11 41 f0       	vmovups XMMWORD PTR [rcx-0x10],xmm0
    b.* = tmp;
  218afe:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  218b03:	c5 f8 11 40 e0       	vmovups XMMWORD PTR [rax-0x20],xmm0
    const tmp = a.*;
  218b08:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  218b0c:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  218b11:	c5 f8 10 40 d0       	vmovups xmm0,XMMWORD PTR [rax-0x30]
  218b16:	c5 f8 11 01          	vmovups XMMWORD PTR [rcx],xmm0
    b.* = tmp;
  218b1a:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  218b1f:	c5 fa 7f 40 d0       	vmovdqu XMMWORD PTR [rax-0x30],xmm0
    while (i < end) : (i += 1) {
  218b24:	48 83 c6 04          	add    rsi,0x4
  218b28:	48 83 c1 40          	add    rcx,0x40
  218b2c:	48 83 c0 c0          	add    rax,0xffffffffffffffc0
  218b30:	48 39 f7             	cmp    rdi,rsi
  218b33:	0f 85 77 ff ff ff    	jne    218ab0 <Benchmark_reportStats+0x2370>
  218b39:	f6 c2 03             	test   dl,0x3
  218b3c:	74 6a                	je     218ba8 <Benchmark_reportStats+0x2468>
  218b3e:	4b 8d 04 0c          	lea    rax,[r12+r9*1]
  218b42:	48 29 f0             	sub    rax,rsi
  218b45:	48 c1 e0 04          	shl    rax,0x4
  218b49:	4c 01 e8             	add    rax,r13
  218b4c:	48 83 c0 10          	add    rax,0x10
  218b50:	4c 01 f6             	add    rsi,r14
  218b53:	48 c1 e6 04          	shl    rsi,0x4
  218b57:	4a 8d 0c 2e          	lea    rcx,[rsi+r13*1]
  218b5b:	48 83 c1 10          	add    rcx,0x10
  218b5f:	43 8d 14 14          	lea    edx,[r12+r10*1]
  218b63:	44 29 f2             	sub    edx,r14d
  218b66:	be 01 02 00 00       	mov    esi,0x201
  218b6b:	c4 e2 48 f7 d2       	bextr  edx,edx,esi
  218b70:	48 f7 da             	neg    rdx
  218b73:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  218b7a:	84 00 00 00 00 00 
    const tmp = a.*;
  218b80:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  218b84:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  218b89:	c5 f8 10 00          	vmovups xmm0,XMMWORD PTR [rax]
  218b8d:	c5 f8 11 01          	vmovups XMMWORD PTR [rcx],xmm0
    b.* = tmp;
  218b91:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  218b96:	c5 fa 7f 00          	vmovdqu XMMWORD PTR [rax],xmm0
    while (i < end) : (i += 1) {
  218b9a:	48 83 c0 f0          	add    rax,0xfffffffffffffff0
  218b9e:	48 83 c1 10          	add    rcx,0x10
  218ba2:	48 83 c2 01          	add    rdx,0x1
  218ba6:	75 d8                	jne    218b80 <Benchmark_reportStats+0x2440>
  218ba8:	48 83 44 24 18 01    	add    QWORD PTR [rsp+0x18],0x1
  218bae:	49 83 fb 02          	cmp    r11,0x2
  218bb2:	0f 82 40 01 00 00    	jb     218cf8 <Benchmark_reportStats+0x25b8>
  218bb8:	4c 89 d9             	mov    rcx,r11
  218bbb:	48 d1 e9             	shr    rcx,1
  218bbe:	89 ca                	mov    edx,ecx
  218bc0:	83 e2 03             	and    edx,0x3
  218bc3:	48 8b 5c 24 18       	mov    rbx,QWORD PTR [rsp+0x18]
  218bc8:	48 d1 eb             	shr    rbx,1
  218bcb:	48 8d 43 ff          	lea    rax,[rbx-0x1]
        swap(T, &items[i], &items[items.len - i - 1]);
  218bcf:	48 83 f8 03          	cmp    rax,0x3
  218bd3:	73 1b                	jae    218bf0 <Benchmark_reportStats+0x24b0>
  218bd5:	31 ff                	xor    edi,edi
    while (i < end) : (i += 1) {
  218bd7:	f6 c3 03             	test   bl,0x3
  218bda:	0f 85 ce 00 00 00    	jne    218cae <Benchmark_reportStats+0x256e>
  218be0:	e9 13 01 00 00       	jmp    218cf8 <Benchmark_reportStats+0x25b8>
  218be5:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  218bec:	00 00 00 00 
  218bf0:	48 29 d1             	sub    rcx,rdx
        swap(T, &items[i], &items[items.len - i - 1]);
  218bf3:	4b 8d 04 14          	lea    rax,[r12+r10*1]
  218bf7:	48 c1 e0 04          	shl    rax,0x4
  218bfb:	4a 8d 34 28          	lea    rsi,[rax+r13*1]
  218bff:	48 83 c6 40          	add    rsi,0x40
  218c03:	4c 89 e0             	mov    rax,r12
  218c06:	48 c1 e0 04          	shl    rax,0x4
  218c0a:	4c 01 e8             	add    rax,r13
  218c0d:	48 83 c0 f0          	add    rax,0xfffffffffffffff0
  218c11:	31 ff                	xor    edi,edi
  218c13:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  218c1a:	84 00 00 00 00 00 
    const tmp = a.*;
  218c20:	c5 f8 10 46 d0       	vmovups xmm0,XMMWORD PTR [rsi-0x30]
  218c25:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  218c2a:	c5 f8 10 40 10       	vmovups xmm0,XMMWORD PTR [rax+0x10]
  218c2f:	c5 f8 11 46 d0       	vmovups XMMWORD PTR [rsi-0x30],xmm0
    b.* = tmp;
  218c34:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  218c39:	c5 f8 11 40 10       	vmovups XMMWORD PTR [rax+0x10],xmm0
    const tmp = a.*;
  218c3e:	c5 f8 10 46 e0       	vmovups xmm0,XMMWORD PTR [rsi-0x20]
  218c43:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  218c48:	c5 f8 10 00          	vmovups xmm0,XMMWORD PTR [rax]
  218c4c:	c5 f8 11 46 e0       	vmovups XMMWORD PTR [rsi-0x20],xmm0
    b.* = tmp;
  218c51:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  218c56:	c5 f8 11 00          	vmovups XMMWORD PTR [rax],xmm0
    const tmp = a.*;
  218c5a:	c5 f8 10 46 f0       	vmovups xmm0,XMMWORD PTR [rsi-0x10]
  218c5f:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  218c64:	c5 f8 10 40 f0       	vmovups xmm0,XMMWORD PTR [rax-0x10]
  218c69:	c5 f8 11 46 f0       	vmovups XMMWORD PTR [rsi-0x10],xmm0
    b.* = tmp;
  218c6e:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  218c73:	c5 f8 11 40 f0       	vmovups XMMWORD PTR [rax-0x10],xmm0
    const tmp = a.*;
  218c78:	c5 f8 10 06          	vmovups xmm0,XMMWORD PTR [rsi]
  218c7c:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  218c81:	c5 f8 10 40 e0       	vmovups xmm0,XMMWORD PTR [rax-0x20]
  218c86:	c5 f8 11 06          	vmovups XMMWORD PTR [rsi],xmm0
    b.* = tmp;
  218c8a:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  218c8f:	c5 fa 7f 40 e0       	vmovdqu XMMWORD PTR [rax-0x20],xmm0
    while (i < end) : (i += 1) {
  218c94:	48 83 c7 04          	add    rdi,0x4
  218c98:	48 83 c6 40          	add    rsi,0x40
  218c9c:	48 83 c0 c0          	add    rax,0xffffffffffffffc0
  218ca0:	48 39 f9             	cmp    rcx,rdi
  218ca3:	0f 85 77 ff ff ff    	jne    218c20 <Benchmark_reportStats+0x24e0>
  218ca9:	f6 c3 03             	test   bl,0x3
  218cac:	74 4a                	je     218cf8 <Benchmark_reportStats+0x25b8>
  218cae:	48 f7 da             	neg    rdx
  218cb1:	4c 89 e0             	mov    rax,r12
  218cb4:	48 29 f8             	sub    rax,rdi
  218cb7:	48 c1 e0 04          	shl    rax,0x4
  218cbb:	4c 01 e8             	add    rax,r13
  218cbe:	4c 01 e7             	add    rdi,r12
  218cc1:	4c 01 d7             	add    rdi,r10
  218cc4:	48 c1 e7 04          	shl    rdi,0x4
  218cc8:	4a 8d 0c 2f          	lea    rcx,[rdi+r13*1]
  218ccc:	48 83 c1 10          	add    rcx,0x10
    const tmp = a.*;
  218cd0:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  218cd4:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  218cd9:	c5 f8 10 00          	vmovups xmm0,XMMWORD PTR [rax]
  218cdd:	c5 f8 11 01          	vmovups XMMWORD PTR [rcx],xmm0
    b.* = tmp;
  218ce1:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  218ce6:	c5 fa 7f 00          	vmovdqu XMMWORD PTR [rax],xmm0
    while (i < end) : (i += 1) {
  218cea:	48 83 c0 f0          	add    rax,0xfffffffffffffff0
  218cee:	48 83 c1 10          	add    rcx,0x10
  218cf2:	48 83 c2 01          	add    rdx,0x1
  218cf6:	75 d8                	jne    218cd0 <Benchmark_reportStats+0x2590>
    const end = items.len / 2;
  218cf8:	49 d1 e8             	shr    r8,1
    while (i < end) : (i += 1) {
  218cfb:	0f 84 5f 01 00 00    	je     218e60 <Benchmark_reportStats+0x2720>
  218d01:	4b 8d 0c 2f          	lea    rcx,[r15+r13*1]
  218d05:	48 83 c1 10          	add    rcx,0x10
        swap(T, &items[i], &items[items.len - i - 1]);
  218d09:	4c 89 e0             	mov    rax,r12
    const tmp = a.*;
  218d0c:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  218d10:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  218d15:	48 c1 e0 04          	shl    rax,0x4
    a.* = b.*;
  218d19:	c4 c1 78 10 44 05 00 	vmovups xmm0,XMMWORD PTR [r13+rax*1+0x0]
  218d20:	c5 f8 11 01          	vmovups XMMWORD PTR [rcx],xmm0
    b.* = tmp;
  218d24:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  218d29:	c4 c1 7a 7f 44 05 00 	vmovdqu XMMWORD PTR [r13+rax*1+0x0],xmm0
    while (i < end) : (i += 1) {
  218d30:	49 83 f8 01          	cmp    r8,0x1
  218d34:	0f 84 26 01 00 00    	je     218e60 <Benchmark_reportStats+0x2720>
        swap(T, &items[i], &items[items.len - i - 1]);
  218d3a:	41 8d 50 ff          	lea    edx,[r8-0x1]
  218d3e:	49 8d 48 fe          	lea    rcx,[r8-0x2]
  218d42:	83 e2 03             	and    edx,0x3
  218d45:	48 83 f9 03          	cmp    rcx,0x3
  218d49:	73 13                	jae    218d5e <Benchmark_reportStats+0x261e>
  218d4b:	b9 01 00 00 00       	mov    ecx,0x1
    while (i < end) : (i += 1) {
  218d50:	48 85 d2             	test   rdx,rdx
  218d53:	0f 85 b5 00 00 00    	jne    218e0e <Benchmark_reportStats+0x26ce>
  218d59:	e9 02 01 00 00       	jmp    218e60 <Benchmark_reportStats+0x2720>
        swap(T, &items[i], &items[items.len - i - 1]);
  218d5e:	4a 8d 34 28          	lea    rsi,[rax+r13*1]
  218d62:	48 83 c6 f0          	add    rsi,0xfffffffffffffff0
  218d66:	4b 8d 3c 2f          	lea    rdi,[r15+r13*1]
  218d6a:	48 83 c7 50          	add    rdi,0x50
  218d6e:	49 29 d0             	sub    r8,rdx
  218d71:	b9 01 00 00 00       	mov    ecx,0x1
  218d76:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  218d7d:	00 00 00 
    const tmp = a.*;
  218d80:	c5 f8 10 47 d0       	vmovups xmm0,XMMWORD PTR [rdi-0x30]
  218d85:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  218d8a:	c5 f8 10 06          	vmovups xmm0,XMMWORD PTR [rsi]
  218d8e:	c5 f8 11 47 d0       	vmovups XMMWORD PTR [rdi-0x30],xmm0
    b.* = tmp;
  218d93:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  218d98:	c5 f8 11 06          	vmovups XMMWORD PTR [rsi],xmm0
    const tmp = a.*;
  218d9c:	c5 f8 10 47 e0       	vmovups xmm0,XMMWORD PTR [rdi-0x20]
  218da1:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  218da6:	c5 f8 10 46 f0       	vmovups xmm0,XMMWORD PTR [rsi-0x10]
  218dab:	c5 f8 11 47 e0       	vmovups XMMWORD PTR [rdi-0x20],xmm0
    b.* = tmp;
  218db0:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  218db5:	c5 f8 11 46 f0       	vmovups XMMWORD PTR [rsi-0x10],xmm0
    const tmp = a.*;
  218dba:	c5 f8 10 47 f0       	vmovups xmm0,XMMWORD PTR [rdi-0x10]
  218dbf:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  218dc4:	c5 f8 10 46 e0       	vmovups xmm0,XMMWORD PTR [rsi-0x20]
  218dc9:	c5 f8 11 47 f0       	vmovups XMMWORD PTR [rdi-0x10],xmm0
    b.* = tmp;
  218dce:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  218dd3:	c5 f8 11 46 e0       	vmovups XMMWORD PTR [rsi-0x20],xmm0
    const tmp = a.*;
  218dd8:	c5 f8 10 07          	vmovups xmm0,XMMWORD PTR [rdi]
  218ddc:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  218de1:	c5 f8 10 46 d0       	vmovups xmm0,XMMWORD PTR [rsi-0x30]
  218de6:	c5 f8 11 07          	vmovups XMMWORD PTR [rdi],xmm0
    b.* = tmp;
  218dea:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  218def:	c5 fa 7f 46 d0       	vmovdqu XMMWORD PTR [rsi-0x30],xmm0
    while (i < end) : (i += 1) {
  218df4:	48 83 c1 04          	add    rcx,0x4
  218df8:	48 83 c6 c0          	add    rsi,0xffffffffffffffc0
  218dfc:	48 83 c7 40          	add    rdi,0x40
  218e00:	49 39 c8             	cmp    r8,rcx
  218e03:	0f 85 77 ff ff ff    	jne    218d80 <Benchmark_reportStats+0x2640>
  218e09:	48 85 d2             	test   rdx,rdx
  218e0c:	74 52                	je     218e60 <Benchmark_reportStats+0x2720>
  218e0e:	49 29 cc             	sub    r12,rcx
  218e11:	49 c1 e4 04          	shl    r12,0x4
  218e15:	4d 01 ec             	add    r12,r13
  218e18:	4c 01 f1             	add    rcx,r14
  218e1b:	48 c1 e1 04          	shl    rcx,0x4
  218e1f:	4a 8d 04 29          	lea    rax,[rcx+r13*1]
  218e23:	48 83 c0 10          	add    rax,0x10
  218e27:	48 f7 da             	neg    rdx
  218e2a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
    const tmp = a.*;
  218e30:	c5 f8 10 00          	vmovups xmm0,XMMWORD PTR [rax]
  218e34:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  218e39:	c4 c1 78 10 04 24    	vmovups xmm0,XMMWORD PTR [r12]
  218e3f:	c5 f8 11 00          	vmovups XMMWORD PTR [rax],xmm0
    b.* = tmp;
  218e43:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  218e48:	c4 c1 7a 7f 04 24    	vmovdqu XMMWORD PTR [r12],xmm0
    while (i < end) : (i += 1) {
  218e4e:	49 83 c4 f0          	add    r12,0xfffffffffffffff0
  218e52:	48 83 c0 10          	add    rax,0x10
  218e56:	48 83 c2 01          	add    rdx,0x1
  218e5a:	75 d4                	jne    218e30 <Benchmark_reportStats+0x26f0>
  218e5c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
                        pull[pull_index].from = index + count;
  218e60:	4f 8d 24 1e          	lea    r12,[r14+r11*1]
  218e64:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
  218e69:	4c 89 20             	mov    QWORD PTR [rax],r12
                    while (count < length) : (count += 1) {
  218e6c:	49 83 c3 01          	add    r11,0x1
  218e70:	48 8b 54 24 10       	mov    rdx,QWORD PTR [rsp+0x10]
  218e75:	49 39 d3             	cmp    r11,rdx
  218e78:	0f 85 22 fa ff ff    	jne    2188a0 <Benchmark_reportStats+0x2160>
  218e7e:	e9 0a 05 00 00       	jmp    21938d <Benchmark_reportStats+0x2c4d>
  218e83:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  218e8a:	84 00 00 00 00 00 
                    while (count < length) : (count += 1) {
  218e90:	48 83 fa 02          	cmp    rdx,0x2
                } else if (pull[pull_index].to > pull[pull_index].from) {
  218e94:	0f 82 f3 04 00 00    	jb     21938d <Benchmark_reportStats+0x2c4d>
  218e9a:	4c 39 e1             	cmp    rcx,r12
  218e9d:	0f 86 ea 04 00 00    	jbe    21938d <Benchmark_reportStats+0x2c4d>
                    index = pull[pull_index].from + 1;
  218ea3:	49 8d 44 24 01       	lea    rax,[r12+0x1]
  218ea8:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  218ead:	49 c7 c6 ff ff ff ff 	mov    r14,0xffffffffffffffff
  218eb4:	48 c7 44 24 30 fe ff 	mov    QWORD PTR [rsp+0x30],0xfffffffffffffffe
  218ebb:	ff ff 
  218ebd:	b8 02 00 00 00       	mov    eax,0x2
  218ec2:	48 89 44 24 28       	mov    QWORD PTR [rsp+0x28],rax
  218ec7:	45 31 ff             	xor    r15d,r15d
  218eca:	41 bd 01 00 00 00    	mov    r13d,0x1
  218ed0:	eb 30                	jmp    218f02 <Benchmark_reportStats+0x27c2>
  218ed2:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  218ed9:	1f 84 00 00 00 00 00 
                        index = findLastForward(T, items, items[index], Range.init(index, pull[pull_index].to), lessThan, length - count);
  218ee0:	48 8b 49 08          	mov    rcx,QWORD PTR [rcx+0x8]
                    while (count < length) : (count += 1) {
  218ee4:	49 83 c6 01          	add    r14,0x1
  218ee8:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  218eec:	48 89 44 24 30       	mov    QWORD PTR [rsp+0x30],rax
  218ef1:	49 83 c7 01          	add    r15,0x1
  218ef5:	4c 89 7c 24 28       	mov    QWORD PTR [rsp+0x28],r15
  218efa:	4c 8b 7c 24 38       	mov    r15,QWORD PTR [rsp+0x38]
                        const range = Range.init(pull[pull_index].from, index - 1);
  218eff:	4d 89 cc             	mov    r12,r9
                        index = findLastForward(T, items, items[index], Range.init(index, pull[pull_index].to), lessThan, length - count);
  218f02:	49 8d 47 01          	lea    rax,[r15+0x1]
  218f06:	48 89 44 24 38       	mov    QWORD PTR [rsp+0x38],rax
  218f0b:	48 8b 5c 24 40       	mov    rbx,QWORD PTR [rsp+0x40]
  218f10:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  218f15:	48 89 c6             	mov    rsi,rax
  218f18:	48 c1 e6 04          	shl    rsi,0x4
  218f1c:	48 01 de             	add    rsi,rbx
  218f1f:	49 89 d0             	mov    r8,rdx
  218f22:	4d 29 e8             	sub    r8,r13
  218f25:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  218f2a:	48 89 c2             	mov    rdx,rax
  218f2d:	c5 f8 77             	vzeroupper 
  218f30:	e8 8b 63 00 00       	call   21f2c0 <findLastForward>
  218f35:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
                        const range = Range.init(pull[pull_index].from, index - 1);
  218f3a:	4c 8d 48 ff          	lea    r9,[rax-0x1]
                        mem.rotate(T, items[range.start..range.end], count);
  218f3e:	4d 89 e0             	mov    r8,r12
  218f41:	49 c1 e0 04          	shl    r8,0x4
  218f45:	4d 89 ca             	mov    r10,r9
  218f48:	4d 29 e2             	sub    r10,r12
  218f4b:	49 83 fd 02          	cmp    r13,0x2
  218f4f:	0f 82 45 01 00 00    	jb     21909a <Benchmark_reportStats+0x295a>
                        index = findLastForward(T, items, items[index], Range.init(index, pull[pull_index].to), lessThan, length - count);
  218f55:	4c 89 ee             	mov    rsi,r13
  218f58:	48 d1 ee             	shr    rsi,1
  218f5b:	89 f7                	mov    edi,esi
  218f5d:	83 e7 03             	and    edi,0x3
  218f60:	4c 8b 5c 24 38       	mov    r11,QWORD PTR [rsp+0x38]
  218f65:	49 d1 eb             	shr    r11,1
  218f68:	49 8d 4b ff          	lea    rcx,[r11-0x1]
        swap(T, &items[i], &items[items.len - i - 1]);
  218f6c:	48 83 f9 03          	cmp    rcx,0x3
  218f70:	73 1e                	jae    218f90 <Benchmark_reportStats+0x2850>
  218f72:	4c 89 f0             	mov    rax,r14
  218f75:	31 c9                	xor    ecx,ecx
    while (i < end) : (i += 1) {
  218f77:	41 f6 c3 03          	test   r11b,0x3
  218f7b:	49 89 c6             	mov    r14,rax
  218f7e:	0f 85 c6 00 00 00    	jne    21904a <Benchmark_reportStats+0x290a>
  218f84:	e9 11 01 00 00       	jmp    21909a <Benchmark_reportStats+0x295a>
  218f89:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  218f90:	48 29 fe             	sub    rsi,rdi
        swap(T, &items[i], &items[items.len - i - 1]);
  218f93:	4a 8d 14 03          	lea    rdx,[rbx+r8*1]
  218f97:	48 83 c2 30          	add    rdx,0x30
  218f9b:	4c 89 f0             	mov    rax,r14
  218f9e:	4f 8d 34 34          	lea    r14,[r12+r14*1]
  218fa2:	49 c1 e6 04          	shl    r14,0x4
  218fa6:	49 01 de             	add    r14,rbx
  218fa9:	31 c9                	xor    ecx,ecx
  218fab:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
    const tmp = a.*;
  218fb0:	c5 f8 10 42 d0       	vmovups xmm0,XMMWORD PTR [rdx-0x30]
  218fb5:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  218fba:	c4 c1 78 10 46 10    	vmovups xmm0,XMMWORD PTR [r14+0x10]
  218fc0:	c5 f8 11 42 d0       	vmovups XMMWORD PTR [rdx-0x30],xmm0
    b.* = tmp;
  218fc5:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  218fca:	c4 c1 78 11 46 10    	vmovups XMMWORD PTR [r14+0x10],xmm0
    const tmp = a.*;
  218fd0:	c5 f8 10 42 e0       	vmovups xmm0,XMMWORD PTR [rdx-0x20]
  218fd5:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  218fda:	c4 c1 78 10 06       	vmovups xmm0,XMMWORD PTR [r14]
  218fdf:	c5 f8 11 42 e0       	vmovups XMMWORD PTR [rdx-0x20],xmm0
    b.* = tmp;
  218fe4:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  218fe9:	c4 c1 78 11 06       	vmovups XMMWORD PTR [r14],xmm0
    const tmp = a.*;
  218fee:	c5 f8 10 42 f0       	vmovups xmm0,XMMWORD PTR [rdx-0x10]
  218ff3:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  218ff8:	c4 c1 78 10 46 f0    	vmovups xmm0,XMMWORD PTR [r14-0x10]
  218ffe:	c5 f8 11 42 f0       	vmovups XMMWORD PTR [rdx-0x10],xmm0
    b.* = tmp;
  219003:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  219008:	c4 c1 78 11 46 f0    	vmovups XMMWORD PTR [r14-0x10],xmm0
    const tmp = a.*;
  21900e:	c5 f8 10 02          	vmovups xmm0,XMMWORD PTR [rdx]
  219012:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  219017:	c4 c1 78 10 46 e0    	vmovups xmm0,XMMWORD PTR [r14-0x20]
  21901d:	c5 f8 11 02          	vmovups XMMWORD PTR [rdx],xmm0
    b.* = tmp;
  219021:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  219026:	c4 c1 7a 7f 46 e0    	vmovdqu XMMWORD PTR [r14-0x20],xmm0
    while (i < end) : (i += 1) {
  21902c:	48 83 c1 04          	add    rcx,0x4
  219030:	48 83 c2 40          	add    rdx,0x40
  219034:	49 83 c6 c0          	add    r14,0xffffffffffffffc0
  219038:	48 39 ce             	cmp    rsi,rcx
  21903b:	0f 85 6f ff ff ff    	jne    218fb0 <Benchmark_reportStats+0x2870>
  219041:	41 f6 c3 03          	test   r11b,0x3
  219045:	49 89 c6             	mov    r14,rax
  219048:	74 50                	je     21909a <Benchmark_reportStats+0x295a>
  21904a:	48 f7 df             	neg    rdi
  21904d:	4d 01 e7             	add    r15,r12
  219050:	49 29 cf             	sub    r15,rcx
  219053:	49 c1 e7 04          	shl    r15,0x4
  219057:	49 01 df             	add    r15,rbx
  21905a:	4c 01 e1             	add    rcx,r12
  21905d:	48 c1 e1 04          	shl    rcx,0x4
  219061:	48 01 d9             	add    rcx,rbx
  219064:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21906b:	00 00 00 00 00 
    const tmp = a.*;
  219070:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  219074:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  219079:	c4 c1 78 10 07       	vmovups xmm0,XMMWORD PTR [r15]
  21907e:	c5 f8 11 01          	vmovups XMMWORD PTR [rcx],xmm0
    b.* = tmp;
  219082:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  219087:	c4 c1 7a 7f 07       	vmovdqu XMMWORD PTR [r15],xmm0
    while (i < end) : (i += 1) {
  21908c:	49 83 c7 f0          	add    r15,0xfffffffffffffff0
  219090:	48 83 c1 10          	add    rcx,0x10
  219094:	48 83 c7 01          	add    rdi,0x1
  219098:	75 d6                	jne    219070 <Benchmark_reportStats+0x2930>

/// In-place rotation of the values in an array ([0 1 2 3] becomes [1 2 3 0] if we rotate by 1)
/// Assumes 0 <= amount <= items.len
pub fn rotate(comptime T: type, items: []T, amount: usize) void {
    reverse(T, items[0..amount]);
    reverse(T, items[amount..]);
  21909a:	4d 89 d3             	mov    r11,r10
  21909d:	4d 29 eb             	sub    r11,r13
    const end = items.len / 2;
  2190a0:	49 d1 eb             	shr    r11,1
  2190a3:	48 8b 44 24 30       	mov    rax,QWORD PTR [rsp+0x30]
  2190a8:	4c 8b 7c 24 28       	mov    r15,QWORD PTR [rsp+0x28]
    while (i < end) : (i += 1) {
  2190ad:	0f 84 55 01 00 00    	je     219208 <Benchmark_reportStats+0x2ac8>
        swap(T, &items[i], &items[items.len - i - 1]);
  2190b3:	49 8d 4b ff          	lea    rcx,[r11-0x1]
  2190b7:	48 83 f9 03          	cmp    rcx,0x3
  2190bb:	73 13                	jae    2190d0 <Benchmark_reportStats+0x2990>
  2190bd:	31 ff                	xor    edi,edi
    while (i < end) : (i += 1) {
  2190bf:	41 f6 c3 03          	test   r11b,0x3
  2190c3:	0f 85 d6 00 00 00    	jne    21919f <Benchmark_reportStats+0x2a5f>
  2190c9:	e9 3a 01 00 00       	jmp    219208 <Benchmark_reportStats+0x2ac8>
  2190ce:	66 90                	xchg   ax,ax
  2190d0:	48 8b 74 24 18       	mov    rsi,QWORD PTR [rsp+0x18]
        swap(T, &items[i], &items[items.len - i - 1]);
  2190d5:	48 8d 14 06          	lea    rdx,[rsi+rax*1]
  2190d9:	4c 29 e2             	sub    rdx,r12
  2190dc:	48 d1 ea             	shr    rdx,1
  2190df:	89 d1                	mov    ecx,edx
  2190e1:	83 e1 03             	and    ecx,0x3
  2190e4:	48 29 ca             	sub    rdx,rcx
  2190e7:	48 89 f1             	mov    rcx,rsi
  2190ea:	48 c1 e1 04          	shl    rcx,0x4
  2190ee:	48 8d 34 0b          	lea    rsi,[rbx+rcx*1]
  2190f2:	48 83 c6 b0          	add    rsi,0xffffffffffffffb0
  2190f6:	4b 8d 0c 3c          	lea    rcx,[r12+r15*1]
  2190fa:	48 c1 e1 04          	shl    rcx,0x4
  2190fe:	48 01 d9             	add    rcx,rbx
  219101:	31 ff                	xor    edi,edi
  219103:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21910a:	84 00 00 00 00 00 
    const tmp = a.*;
  219110:	c5 f8 10 41 f0       	vmovups xmm0,XMMWORD PTR [rcx-0x10]
  219115:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21911a:	c5 f8 10 46 30       	vmovups xmm0,XMMWORD PTR [rsi+0x30]
  21911f:	c5 f8 11 41 f0       	vmovups XMMWORD PTR [rcx-0x10],xmm0
    b.* = tmp;
  219124:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  219129:	c5 f8 11 46 30       	vmovups XMMWORD PTR [rsi+0x30],xmm0
    const tmp = a.*;
  21912e:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  219132:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  219137:	c5 f8 10 46 20       	vmovups xmm0,XMMWORD PTR [rsi+0x20]
  21913c:	c5 f8 11 01          	vmovups XMMWORD PTR [rcx],xmm0
    b.* = tmp;
  219140:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  219145:	c5 f8 11 46 20       	vmovups XMMWORD PTR [rsi+0x20],xmm0
    const tmp = a.*;
  21914a:	c5 f8 10 41 10       	vmovups xmm0,XMMWORD PTR [rcx+0x10]
  21914f:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  219154:	c5 f8 10 46 10       	vmovups xmm0,XMMWORD PTR [rsi+0x10]
  219159:	c5 f8 11 41 10       	vmovups XMMWORD PTR [rcx+0x10],xmm0
    b.* = tmp;
  21915e:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  219163:	c5 f8 11 46 10       	vmovups XMMWORD PTR [rsi+0x10],xmm0
    const tmp = a.*;
  219168:	c5 f8 10 41 20       	vmovups xmm0,XMMWORD PTR [rcx+0x20]
  21916d:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  219172:	c5 f8 10 06          	vmovups xmm0,XMMWORD PTR [rsi]
  219176:	c5 f8 11 41 20       	vmovups XMMWORD PTR [rcx+0x20],xmm0
    b.* = tmp;
  21917b:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  219180:	c5 fa 7f 06          	vmovdqu XMMWORD PTR [rsi],xmm0
    while (i < end) : (i += 1) {
  219184:	48 83 c7 04          	add    rdi,0x4
  219188:	48 83 c6 c0          	add    rsi,0xffffffffffffffc0
  21918c:	48 83 c1 40          	add    rcx,0x40
  219190:	48 39 fa             	cmp    rdx,rdi
  219193:	0f 85 77 ff ff ff    	jne    219110 <Benchmark_reportStats+0x29d0>
  219199:	41 f6 c3 03          	test   r11b,0x3
  21919d:	74 69                	je     219208 <Benchmark_reportStats+0x2ac8>
  21919f:	48 8b 54 24 18       	mov    rdx,QWORD PTR [rsp+0x18]
  2191a4:	48 8d 4a fe          	lea    rcx,[rdx-0x2]
  2191a8:	48 29 f9             	sub    rcx,rdi
  2191ab:	48 c1 e1 04          	shl    rcx,0x4
  2191af:	48 01 d9             	add    rcx,rbx
  2191b2:	4c 01 e7             	add    rdi,r12
  2191b5:	4c 01 ef             	add    rdi,r13
  2191b8:	48 c1 e7 04          	shl    rdi,0x4
  2191bc:	48 01 df             	add    rdi,rbx
  2191bf:	8d 14 02             	lea    edx,[rdx+rax*1]
  2191c2:	44 29 e2             	sub    edx,r12d
  2191c5:	be 01 02 00 00       	mov    esi,0x201
  2191ca:	c4 e2 48 f7 d2       	bextr  edx,edx,esi
  2191cf:	48 f7 da             	neg    rdx
  2191d2:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  2191d9:	1f 84 00 00 00 00 00 
    const tmp = a.*;
  2191e0:	c5 f8 10 07          	vmovups xmm0,XMMWORD PTR [rdi]
  2191e4:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  2191e9:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  2191ed:	c5 f8 11 07          	vmovups XMMWORD PTR [rdi],xmm0
    b.* = tmp;
  2191f1:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  2191f6:	c5 fa 7f 01          	vmovdqu XMMWORD PTR [rcx],xmm0
    while (i < end) : (i += 1) {
  2191fa:	48 83 c1 f0          	add    rcx,0xfffffffffffffff0
  2191fe:	48 83 c7 10          	add    rdi,0x10
  219202:	48 83 c2 01          	add    rdx,0x1
  219206:	75 d8                	jne    2191e0 <Benchmark_reportStats+0x2aa0>
    const end = items.len / 2;
  219208:	4d 89 d3             	mov    r11,r10
  21920b:	49 d1 eb             	shr    r11,1
    while (i < end) : (i += 1) {
  21920e:	0f 84 5c 01 00 00    	je     219370 <Benchmark_reportStats+0x2c30>
  219214:	4a 8d 0c 03          	lea    rcx,[rbx+r8*1]
    const tmp = a.*;
  219218:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  21921c:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  219221:	49 c1 e2 04          	shl    r10,0x4
    a.* = b.*;
  219225:	c4 a1 78 10 44 11 f0 	vmovups xmm0,XMMWORD PTR [rcx+r10*1-0x10]
  21922c:	c5 f8 11 01          	vmovups XMMWORD PTR [rcx],xmm0
    b.* = tmp;
  219230:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  219235:	c4 a1 7a 7f 44 11 f0 	vmovdqu XMMWORD PTR [rcx+r10*1-0x10],xmm0
    while (i < end) : (i += 1) {
  21923c:	49 83 fb 01          	cmp    r11,0x1
  219240:	0f 84 2a 01 00 00    	je     219370 <Benchmark_reportStats+0x2c30>
        swap(T, &items[i], &items[items.len - i - 1]);
  219246:	41 8d 73 ff          	lea    esi,[r11-0x1]
  21924a:	49 8d 4b fe          	lea    rcx,[r11-0x2]
  21924e:	83 e6 03             	and    esi,0x3
  219251:	48 83 f9 03          	cmp    rcx,0x3
  219255:	73 13                	jae    21926a <Benchmark_reportStats+0x2b2a>
  219257:	ba 01 00 00 00       	mov    edx,0x1
    while (i < end) : (i += 1) {
  21925c:	48 85 f6             	test   rsi,rsi
  21925f:	0f 85 b9 00 00 00    	jne    21931e <Benchmark_reportStats+0x2bde>
  219265:	e9 06 01 00 00       	jmp    219370 <Benchmark_reportStats+0x2c30>
        swap(T, &items[i], &items[items.len - i - 1]);
  21926a:	48 8b 4c 24 18       	mov    rcx,QWORD PTR [rsp+0x18]
  21926f:	48 c1 e1 04          	shl    rcx,0x4
  219273:	48 8d 3c 0b          	lea    rdi,[rbx+rcx*1]
  219277:	48 83 c7 d0          	add    rdi,0xffffffffffffffd0
  21927b:	4a 8d 0c 03          	lea    rcx,[rbx+r8*1]
  21927f:	48 83 c1 40          	add    rcx,0x40
  219283:	49 29 f3             	sub    r11,rsi
  219286:	ba 01 00 00 00       	mov    edx,0x1
  21928b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
    const tmp = a.*;
  219290:	c5 f8 10 41 d0       	vmovups xmm0,XMMWORD PTR [rcx-0x30]
  219295:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21929a:	c5 f8 10 07          	vmovups xmm0,XMMWORD PTR [rdi]
  21929e:	c5 f8 11 41 d0       	vmovups XMMWORD PTR [rcx-0x30],xmm0
    b.* = tmp;
  2192a3:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  2192a8:	c5 f8 11 07          	vmovups XMMWORD PTR [rdi],xmm0
    const tmp = a.*;
  2192ac:	c5 f8 10 41 e0       	vmovups xmm0,XMMWORD PTR [rcx-0x20]
  2192b1:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  2192b6:	c5 f8 10 47 f0       	vmovups xmm0,XMMWORD PTR [rdi-0x10]
  2192bb:	c5 f8 11 41 e0       	vmovups XMMWORD PTR [rcx-0x20],xmm0
    b.* = tmp;
  2192c0:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  2192c5:	c5 f8 11 47 f0       	vmovups XMMWORD PTR [rdi-0x10],xmm0
    const tmp = a.*;
  2192ca:	c5 f8 10 41 f0       	vmovups xmm0,XMMWORD PTR [rcx-0x10]
  2192cf:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  2192d4:	c5 f8 10 47 e0       	vmovups xmm0,XMMWORD PTR [rdi-0x20]
  2192d9:	c5 f8 11 41 f0       	vmovups XMMWORD PTR [rcx-0x10],xmm0
    b.* = tmp;
  2192de:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  2192e3:	c5 f8 11 47 e0       	vmovups XMMWORD PTR [rdi-0x20],xmm0
    const tmp = a.*;
  2192e8:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  2192ec:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  2192f1:	c5 f8 10 47 d0       	vmovups xmm0,XMMWORD PTR [rdi-0x30]
  2192f6:	c5 f8 11 01          	vmovups XMMWORD PTR [rcx],xmm0
    b.* = tmp;
  2192fa:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  2192ff:	c5 fa 7f 47 d0       	vmovdqu XMMWORD PTR [rdi-0x30],xmm0
    while (i < end) : (i += 1) {
  219304:	48 83 c2 04          	add    rdx,0x4
  219308:	48 83 c7 c0          	add    rdi,0xffffffffffffffc0
  21930c:	48 83 c1 40          	add    rcx,0x40
  219310:	49 39 d3             	cmp    r11,rdx
  219313:	0f 85 77 ff ff ff    	jne    219290 <Benchmark_reportStats+0x2b50>
  219319:	48 85 f6             	test   rsi,rsi
  21931c:	74 52                	je     219370 <Benchmark_reportStats+0x2c30>
  21931e:	48 8b 4c 24 18       	mov    rcx,QWORD PTR [rsp+0x18]
  219323:	48 29 d1             	sub    rcx,rdx
  219326:	48 c1 e1 04          	shl    rcx,0x4
  21932a:	48 01 d9             	add    rcx,rbx
  21932d:	48 83 c1 e0          	add    rcx,0xffffffffffffffe0
  219331:	49 01 d4             	add    r12,rdx
  219334:	49 c1 e4 04          	shl    r12,0x4
  219338:	49 01 dc             	add    r12,rbx
  21933b:	48 f7 de             	neg    rsi
  21933e:	66 90                	xchg   ax,ax
    const tmp = a.*;
  219340:	c4 c1 78 10 04 24    	vmovups xmm0,XMMWORD PTR [r12]
  219346:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21934b:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  21934f:	c4 c1 78 11 04 24    	vmovups XMMWORD PTR [r12],xmm0
    b.* = tmp;
  219355:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  21935a:	c5 fa 7f 01          	vmovdqu XMMWORD PTR [rcx],xmm0
    while (i < end) : (i += 1) {
  21935e:	48 83 c1 f0          	add    rcx,0xfffffffffffffff0
  219362:	49 83 c4 10          	add    r12,0x10
  219366:	48 83 c6 01          	add    rsi,0x1
  21936a:	75 d4                	jne    219340 <Benchmark_reportStats+0x2c00>
  21936c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
                        pull[pull_index].from = index - 1 - count;
  219370:	4d 29 e9             	sub    r9,r13
  219373:	48 8b 4c 24 20       	mov    rcx,QWORD PTR [rsp+0x20]
  219378:	4c 89 09             	mov    QWORD PTR [rcx],r9
                    while (count < length) : (count += 1) {
  21937b:	49 83 c5 01          	add    r13,0x1
  21937f:	48 8b 54 24 10       	mov    rdx,QWORD PTR [rsp+0x10]
  219384:	49 39 d5             	cmp    r13,rdx
  219387:	0f 85 53 fb ff ff    	jne    218ee0 <Benchmark_reportStats+0x27a0>
  21938d:	48 8b 44 24 58       	mov    rax,QWORD PTR [rsp+0x58]
            while (pull_index < 2) : (pull_index += 1) {
  219392:	48 83 c0 01          	add    rax,0x1
  219396:	48 83 f8 02          	cmp    rax,0x2
  21939a:	0f 85 90 f4 ff ff    	jne    218830 <Benchmark_reportStats+0x20f0>
  2193a0:	48 8b 8c 24 d0 00 00 	mov    rcx,QWORD PTR [rsp+0xd0]
  2193a7:	00 
        return self.end - self.start;
  2193a8:	48 2b 4c 24 70       	sub    rcx,QWORD PTR [rsp+0x70]
  2193ad:	48 8b b4 24 d8 00 00 	mov    rsi,QWORD PTR [rsp+0xd8]
  2193b4:	00 
  2193b5:	48 89 f0             	mov    rax,rsi
  2193b8:	48 09 c8             	or     rax,rcx
  2193bb:	48 c1 e8 20          	shr    rax,0x20
  2193bf:	74 0a                	je     2193cb <Benchmark_reportStats+0x2c8b>
  2193c1:	31 d2                	xor    edx,edx
  2193c3:	48 89 f0             	mov    rax,rsi
  2193c6:	48 f7 f1             	div    rcx
  2193c9:	eb 06                	jmp    2193d1 <Benchmark_reportStats+0x2c91>
  2193cb:	31 d2                	xor    edx,edx
  2193cd:	89 f0                	mov    eax,esi
  2193cf:	f7 f1                	div    ecx
  2193d1:	48 8b 94 24 e0 00 00 	mov    rdx,QWORD PTR [rsp+0xe0]
  2193d8:	00 
  2193d9:	48 89 44 24 58       	mov    QWORD PTR [rsp+0x58],rax
            block_size = iterator.length() / buffer_size + 1;
  2193de:	48 8d 58 01          	lea    rbx,[rax+0x1]
  2193e2:	48 8b 44 24 50       	mov    rax,QWORD PTR [rsp+0x50]
  2193e7:	48 89 c7             	mov    rdi,rax
  2193ea:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
  2193ef:	49 89 c0             	mov    r8,rax
  2193f2:	4c 29 c7             	sub    rdi,r8
  2193f5:	48 89 bc 24 c0 01 00 	mov    QWORD PTR [rsp+0x1c0],rdi
  2193fc:	00 
  2193fd:	0f 95 c0             	setne  al
  219400:	48 81 fb 01 02 00 00 	cmp    rbx,0x201
  219407:	0f 92 c1             	setb   cl
  21940a:	08 c1                	or     cl,al
  21940c:	88 4c 24 78          	mov    BYTE PTR [rsp+0x78],cl
        mem.swap(T, &items[start1 + index], &items[start2 + index]);
  219410:	48 8d 46 ff          	lea    rax,[rsi-0x1]
            while (!iterator.finished()) {
  219414:	48 89 84 24 98 01 00 	mov    QWORD PTR [rsp+0x198],rax
  21941b:	00 
  21941c:	48 89 d8             	mov    rax,rbx
  21941f:	48 d1 e8             	shr    rax,1
  219422:	89 d9                	mov    ecx,ebx
  219424:	83 e1 03             	and    ecx,0x3
  219427:	48 89 df             	mov    rdi,rbx
  21942a:	48 89 4c 24 10       	mov    QWORD PTR [rsp+0x10],rcx
  21942f:	48 29 cf             	sub    rdi,rcx
  219432:	48 89 bc 24 10 01 00 	mov    QWORD PTR [rsp+0x110],rdi
  219439:	00 
  21943a:	89 d9                	mov    ecx,ebx
  21943c:	83 e1 07             	and    ecx,0x7
  21943f:	48 89 5c 24 28       	mov    QWORD PTR [rsp+0x28],rbx
  219444:	48 89 8c 24 20 01 00 	mov    QWORD PTR [rsp+0x120],rcx
  21944b:	00 
  21944c:	48 29 cb             	sub    rbx,rcx
  21944f:	48 89 9c 24 60 01 00 	mov    QWORD PTR [rsp+0x160],rbx
  219456:	00 
  219457:	89 c1                	mov    ecx,eax
  219459:	83 e1 03             	and    ecx,0x3
  21945c:	48 8d 78 ff          	lea    rdi,[rax-0x1]
  219460:	48 89 bc 24 70 01 00 	mov    QWORD PTR [rsp+0x170],rdi
  219467:	00 
  219468:	48 89 8c 24 40 01 00 	mov    QWORD PTR [rsp+0x140],rcx
  21946f:	00 
  219470:	48 29 c8             	sub    rax,rcx
  219473:	48 89 84 24 68 01 00 	mov    QWORD PTR [rsp+0x168],rax
  21947a:	00 
  21947b:	48 8b 44 24 70       	mov    rax,QWORD PTR [rsp+0x70]
  219480:	48 c1 e0 04          	shl    rax,0x4
  219484:	48 89 84 24 d8 01 00 	mov    QWORD PTR [rsp+0x1d8],rax
  21948b:	00 
  21948c:	48 8d 40 10          	lea    rax,[rax+0x10]
  219490:	48 89 84 24 c8 01 00 	mov    QWORD PTR [rsp+0x1c8],rax
  219497:	00 
  219498:	49 c1 e0 04          	shl    r8,0x4
  21949c:	4c 89 84 24 18 01 00 	mov    QWORD PTR [rsp+0x118],r8
  2194a3:	00 
  2194a4:	49 8d 40 20          	lea    rax,[r8+0x20]
  2194a8:	48 89 84 24 58 01 00 	mov    QWORD PTR [rsp+0x158],rax
  2194af:	00 
  2194b0:	31 c0                	xor    eax,eax
  2194b2:	31 db                	xor    ebx,ebx
  2194b4:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  2194bb:	00 00 00 00 00 
  2194c0:	49 89 c7             	mov    r15,rax
        self.decimal += self.decimal_step;
  2194c3:	4d 8d 2c 37          	lea    r13,[r15+rsi*1]
        self.numerator += self.numerator_step;
  2194c7:	48 01 d3             	add    rbx,rdx
        if (self.numerator >= self.denominator) {
  2194ca:	45 31 c9             	xor    r9d,r9d
  2194cd:	48 8b 8c 24 00 01 00 	mov    rcx,QWORD PTR [rsp+0x100]
  2194d4:	00 
  2194d5:	48 39 cb             	cmp    rbx,rcx
  2194d8:	41 0f 93 c1          	setae  r9b
  2194dc:	48 89 c8             	mov    rax,rcx
  2194df:	bf 00 00 00 00       	mov    edi,0x0
  2194e4:	48 0f 42 c7          	cmovb  rax,rdi
  2194e8:	48 29 c3             	sub    rbx,rax
  2194eb:	4f 8d 04 29          	lea    r8,[r9+r13*1]
        self.decimal += self.decimal_step;
  2194ef:	49 8d 04 30          	lea    rax,[r8+rsi*1]
        self.numerator += self.numerator_step;
  2194f3:	48 01 d3             	add    rbx,rdx
        if (self.numerator >= self.denominator) {
  2194f6:	31 d2                	xor    edx,edx
  2194f8:	48 89 9c 24 38 01 00 	mov    QWORD PTR [rsp+0x138],rbx
  2194ff:	00 
  219500:	48 39 cb             	cmp    rbx,rcx
  219503:	48 0f 42 cf          	cmovb  rcx,rdi
  219507:	48 89 8c 24 30 01 00 	mov    QWORD PTR [rsp+0x130],rcx
  21950e:	00 
  21950f:	0f 93 c2             	setae  dl
  219512:	48 01 c2             	add    rdx,rax
  219515:	4d 89 fc             	mov    r12,r15
  219518:	48 89 94 24 08 01 00 	mov    QWORD PTR [rsp+0x108],rdx
  21951f:	00 
                if (start == pull[0].range.start) {
  219520:	4c 3b bc 24 98 00 00 	cmp    r15,QWORD PTR [rsp+0x98]
  219527:	00 
  219528:	75 66                	jne    219590 <Benchmark_reportStats+0x2e50>
                    if (pull[0].from > pull[0].to) {
  21952a:	48 8b 84 24 88 00 00 	mov    rax,QWORD PTR [rsp+0x88]
  219531:	00 
  219532:	48 39 84 24 80 00 00 	cmp    QWORD PTR [rsp+0x80],rax
  219539:	00 
  21953a:	76 24                	jbe    219560 <Benchmark_reportStats+0x2e20>
  21953c:	4c 8b a4 24 90 00 00 	mov    r12,QWORD PTR [rsp+0x90]
  219543:	00 
                        A.start += pull[0].count;
  219544:	4d 01 fc             	add    r12,r15
  219547:	48 8b 94 24 08 01 00 	mov    rdx,QWORD PTR [rsp+0x108]
  21954e:	00 
                        if (A.length() == 0) continue;
  21954f:	4d 39 e0             	cmp    r8,r12
  219552:	75 3c                	jne    219590 <Benchmark_reportStats+0x2e50>
  219554:	e9 97 25 00 00       	jmp    21baf0 <Benchmark_reportStats+0x53b0>
  219559:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  219560:	4d 89 fc             	mov    r12,r15
  219563:	48 8b 94 24 08 01 00 	mov    rdx,QWORD PTR [rsp+0x108]
  21956a:	00 
                    } else if (pull[0].from < pull[0].to) {
  21956b:	73 23                	jae    219590 <Benchmark_reportStats+0x2e50>
                        B.end -= pull[0].count;
  21956d:	48 8b 94 24 08 01 00 	mov    rdx,QWORD PTR [rsp+0x108]
  219574:	00 
  219575:	48 2b 94 24 90 00 00 	sub    rdx,QWORD PTR [rsp+0x90]
  21957c:	00 
  21957d:	4d 89 fc             	mov    r12,r15
                        if (B.length() == 0) continue;
  219580:	4c 39 c2             	cmp    rdx,r8
  219583:	0f 84 67 25 00 00    	je     21baf0 <Benchmark_reportStats+0x53b0>
  219589:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
                if (start == pull[1].range.start) {
  219590:	4c 3b bc 24 c0 00 00 	cmp    r15,QWORD PTR [rsp+0xc0]
  219597:	00 
  219598:	75 46                	jne    2195e0 <Benchmark_reportStats+0x2ea0>
                    if (pull[1].from > pull[1].to) {
  21959a:	48 8b 84 24 b0 00 00 	mov    rax,QWORD PTR [rsp+0xb0]
  2195a1:	00 
  2195a2:	48 39 84 24 a8 00 00 	cmp    QWORD PTR [rsp+0xa8],rax
  2195a9:	00 
  2195aa:	76 14                	jbe    2195c0 <Benchmark_reportStats+0x2e80>
                        A.start += pull[1].count;
  2195ac:	4c 03 a4 24 b8 00 00 	add    r12,QWORD PTR [rsp+0xb8]
  2195b3:	00 
                        if (A.length() == 0) continue;
  2195b4:	4d 39 e0             	cmp    r8,r12
  2195b7:	75 27                	jne    2195e0 <Benchmark_reportStats+0x2ea0>
  2195b9:	e9 32 25 00 00       	jmp    21baf0 <Benchmark_reportStats+0x53b0>
  2195be:	66 90                	xchg   ax,ax
                    } else if (pull[1].from < pull[1].to) {
  2195c0:	73 1e                	jae    2195e0 <Benchmark_reportStats+0x2ea0>
                        B.end -= pull[1].count;
  2195c2:	48 2b 94 24 b8 00 00 	sub    rdx,QWORD PTR [rsp+0xb8]
  2195c9:	00 
                        if (B.length() == 0) continue;
  2195ca:	4c 39 c2             	cmp    rdx,r8
  2195cd:	0f 84 1d 25 00 00    	je     21baf0 <Benchmark_reportStats+0x53b0>
  2195d3:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  2195da:	84 00 00 00 00 00 
  2195e0:	4c 89 44 24 30       	mov    QWORD PTR [rsp+0x30],r8
                if (lessThan(items[B.end - 1], items[A.start])) {
  2195e5:	49 89 d3             	mov    r11,rdx
  2195e8:	49 c1 e3 04          	shl    r11,0x4
  2195ec:	4c 8b 54 24 40       	mov    r10,QWORD PTR [rsp+0x40]
  2195f1:	4d 89 e0             	mov    r8,r12
  2195f4:	49 c1 e0 04          	shl    r8,0x4
  2195f8:	4b 8b 44 1a f0       	mov    rax,QWORD PTR [r10+r11*1-0x10]
  2195fd:	4b 3b 04 02          	cmp    rax,QWORD PTR [r10+r8*1]
  219601:	73 4d                	jae    219650 <Benchmark_reportStats+0x2f10>
  219603:	48 89 94 24 e8 00 00 	mov    QWORD PTR [rsp+0xe8],rdx
  21960a:	00 
                    mem.rotate(T, items[A.start..B.end], A.length());
  21960b:	48 89 d7             	mov    rdi,rdx
  21960e:	4c 29 e7             	sub    rdi,r12
        return self.end - self.start;
  219611:	4c 8b 74 24 30       	mov    r14,QWORD PTR [rsp+0x30]
  219616:	4d 29 e6             	sub    r14,r12
    const end = items.len / 2;
  219619:	4c 89 f3             	mov    rbx,r14
  21961c:	48 d1 eb             	shr    rbx,1
    while (i < end) : (i += 1) {
  21961f:	0f 84 73 01 00 00    	je     219798 <Benchmark_reportStats+0x3058>
        swap(T, &items[i], &items[items.len - i - 1]);
  219625:	48 8d 43 ff          	lea    rax,[rbx-0x1]
  219629:	89 da                	mov    edx,ebx
  21962b:	83 e2 03             	and    edx,0x3
  21962e:	48 83 f8 03          	cmp    rax,0x3
  219632:	73 67                	jae    21969b <Benchmark_reportStats+0x2f5b>
  219634:	31 c0                	xor    eax,eax
    while (i < end) : (i += 1) {
  219636:	48 85 d2             	test   rdx,rdx
  219639:	0f 85 0f 01 00 00    	jne    21974e <Benchmark_reportStats+0x300e>
  21963f:	e9 54 01 00 00       	jmp    219798 <Benchmark_reportStats+0x3058>
  219644:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21964b:	00 00 00 00 00 
  219650:	4c 8b 6c 24 30       	mov    r13,QWORD PTR [rsp+0x30]
                } else if (lessThan(items[A.end], items[A.end - 1])) {
  219655:	4c 89 e8             	mov    rax,r13
  219658:	48 c1 e0 04          	shl    rax,0x4
  21965c:	49 8b 0c 02          	mov    rcx,QWORD PTR [r10+rax*1]
  219660:	49 3b 4c 02 f0       	cmp    rcx,QWORD PTR [r10+rax*1-0x10]
  219665:	0f 83 85 24 00 00    	jae    21baf0 <Benchmark_reportStats+0x53b0>
  21966b:	48 89 94 24 e8 00 00 	mov    QWORD PTR [rsp+0xe8],rdx
  219672:	00 
        return self.end - self.start;
  219673:	4d 29 e5             	sub    r13,r12
  219676:	4d 89 eb             	mov    r11,r13
  219679:	4c 8b 74 24 28       	mov    r14,QWORD PTR [rsp+0x28]
  21967e:	4d 09 f3             	or     r11,r14
  219681:	49 c1 eb 20          	shr    r11,0x20
  219685:	0f 84 b0 02 00 00    	je     21993b <Benchmark_reportStats+0x31fb>
  21968b:	31 d2                	xor    edx,edx
  21968d:	4c 89 e8             	mov    rax,r13
  219690:	49 f7 f6             	div    r14
  219693:	48 89 d6             	mov    rsi,rdx
  219696:	e9 aa 02 00 00       	jmp    219945 <Benchmark_reportStats+0x3205>
        swap(T, &items[i], &items[items.len - i - 1]);
  21969b:	48 29 d3             	sub    rbx,rdx
  21969e:	4b 8d 0c 02          	lea    rcx,[r10+r8*1]
  2196a2:	48 83 c1 30          	add    rcx,0x30
  2196a6:	48 8b 44 24 30       	mov    rax,QWORD PTR [rsp+0x30]
  2196ab:	48 c1 e0 04          	shl    rax,0x4
  2196af:	49 8d 34 02          	lea    rsi,[r10+rax*1]
  2196b3:	48 83 c6 f0          	add    rsi,0xfffffffffffffff0
  2196b7:	31 c0                	xor    eax,eax
  2196b9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
    const tmp = a.*;
  2196c0:	c5 f8 10 41 d0       	vmovups xmm0,XMMWORD PTR [rcx-0x30]
  2196c5:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  2196ca:	c5 f8 10 06          	vmovups xmm0,XMMWORD PTR [rsi]
  2196ce:	c5 f8 11 41 d0       	vmovups XMMWORD PTR [rcx-0x30],xmm0
    b.* = tmp;
  2196d3:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  2196d8:	c5 f8 11 06          	vmovups XMMWORD PTR [rsi],xmm0
    const tmp = a.*;
  2196dc:	c5 f8 10 41 e0       	vmovups xmm0,XMMWORD PTR [rcx-0x20]
  2196e1:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  2196e6:	c5 f8 10 46 f0       	vmovups xmm0,XMMWORD PTR [rsi-0x10]
  2196eb:	c5 f8 11 41 e0       	vmovups XMMWORD PTR [rcx-0x20],xmm0
    b.* = tmp;
  2196f0:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  2196f5:	c5 f8 11 46 f0       	vmovups XMMWORD PTR [rsi-0x10],xmm0
    const tmp = a.*;
  2196fa:	c5 f8 10 41 f0       	vmovups xmm0,XMMWORD PTR [rcx-0x10]
  2196ff:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  219704:	c5 f8 10 46 e0       	vmovups xmm0,XMMWORD PTR [rsi-0x20]
  219709:	c5 f8 11 41 f0       	vmovups XMMWORD PTR [rcx-0x10],xmm0
    b.* = tmp;
  21970e:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  219713:	c5 f8 11 46 e0       	vmovups XMMWORD PTR [rsi-0x20],xmm0
    const tmp = a.*;
  219718:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  21971c:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  219721:	c5 f8 10 46 d0       	vmovups xmm0,XMMWORD PTR [rsi-0x30]
  219726:	c5 f8 11 01          	vmovups XMMWORD PTR [rcx],xmm0
    b.* = tmp;
  21972a:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  21972f:	c5 fa 7f 46 d0       	vmovdqu XMMWORD PTR [rsi-0x30],xmm0
    while (i < end) : (i += 1) {
  219734:	48 83 c0 04          	add    rax,0x4
  219738:	48 83 c1 40          	add    rcx,0x40
  21973c:	48 83 c6 c0          	add    rsi,0xffffffffffffffc0
  219740:	48 39 c3             	cmp    rbx,rax
  219743:	0f 85 77 ff ff ff    	jne    2196c0 <Benchmark_reportStats+0x2f80>
  219749:	48 85 d2             	test   rdx,rdx
  21974c:	74 4a                	je     219798 <Benchmark_reportStats+0x3058>
  21974e:	4d 01 cd             	add    r13,r9
  219751:	49 29 c5             	sub    r13,rax
  219754:	49 c1 e5 04          	shl    r13,0x4
  219758:	4b 8d 0c 2a          	lea    rcx,[r10+r13*1]
  21975c:	48 83 c1 f0          	add    rcx,0xfffffffffffffff0
  219760:	4c 01 e0             	add    rax,r12
  219763:	48 c1 e0 04          	shl    rax,0x4
  219767:	4c 01 d0             	add    rax,r10
  21976a:	48 f7 da             	neg    rdx
  21976d:	0f 1f 00             	nop    DWORD PTR [rax]
    const tmp = a.*;
  219770:	c5 f8 10 00          	vmovups xmm0,XMMWORD PTR [rax]
  219774:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  219779:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  21977d:	c5 f8 11 00          	vmovups XMMWORD PTR [rax],xmm0
    b.* = tmp;
  219781:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  219786:	c5 fa 7f 01          	vmovdqu XMMWORD PTR [rcx],xmm0
    while (i < end) : (i += 1) {
  21978a:	48 83 c1 f0          	add    rcx,0xfffffffffffffff0
  21978e:	48 83 c0 10          	add    rax,0x10
  219792:	48 83 c2 01          	add    rdx,0x1
  219796:	75 d8                	jne    219770 <Benchmark_reportStats+0x3030>
    reverse(T, items[amount..]);
  219798:	48 89 f8             	mov    rax,rdi
  21979b:	4c 29 f0             	sub    rax,r14
    const end = items.len / 2;
  21979e:	48 d1 e8             	shr    rax,1
  2197a1:	4c 8b b4 24 e8 00 00 	mov    r14,QWORD PTR [rsp+0xe8]
  2197a8:	00 
    while (i < end) : (i += 1) {
  2197a9:	0f 84 29 01 00 00    	je     2198d8 <Benchmark_reportStats+0x3198>
        swap(T, &items[i], &items[items.len - i - 1]);
  2197af:	48 8d 48 ff          	lea    rcx,[rax-0x1]
  2197b3:	89 c6                	mov    esi,eax
  2197b5:	83 e6 03             	and    esi,0x3
  2197b8:	48 83 f9 03          	cmp    rcx,0x3
  2197bc:	73 10                	jae    2197ce <Benchmark_reportStats+0x308e>
  2197be:	31 d2                	xor    edx,edx
    while (i < end) : (i += 1) {
  2197c0:	48 85 f6             	test   rsi,rsi
  2197c3:	0f 85 b5 00 00 00    	jne    21987e <Benchmark_reportStats+0x313e>
  2197c9:	e9 0a 01 00 00       	jmp    2198d8 <Benchmark_reportStats+0x3198>
        swap(T, &items[i], &items[items.len - i - 1]);
  2197ce:	48 29 f0             	sub    rax,rsi
  2197d1:	48 8b 4c 24 30       	mov    rcx,QWORD PTR [rsp+0x30]
  2197d6:	48 c1 e1 04          	shl    rcx,0x4
  2197da:	4c 01 d1             	add    rcx,r10
  2197dd:	48 83 c1 30          	add    rcx,0x30
  2197e1:	4b 8d 1c 1a          	lea    rbx,[r10+r11*1]
  2197e5:	48 83 c3 f0          	add    rbx,0xfffffffffffffff0
  2197e9:	31 d2                	xor    edx,edx
  2197eb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
    const tmp = a.*;
  2197f0:	c5 f8 10 41 d0       	vmovups xmm0,XMMWORD PTR [rcx-0x30]
  2197f5:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  2197fa:	c5 f8 10 03          	vmovups xmm0,XMMWORD PTR [rbx]
  2197fe:	c5 f8 11 41 d0       	vmovups XMMWORD PTR [rcx-0x30],xmm0
    b.* = tmp;
  219803:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  219808:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
    const tmp = a.*;
  21980c:	c5 f8 10 41 e0       	vmovups xmm0,XMMWORD PTR [rcx-0x20]
  219811:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  219816:	c5 f8 10 43 f0       	vmovups xmm0,XMMWORD PTR [rbx-0x10]
  21981b:	c5 f8 11 41 e0       	vmovups XMMWORD PTR [rcx-0x20],xmm0
    b.* = tmp;
  219820:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  219825:	c5 f8 11 43 f0       	vmovups XMMWORD PTR [rbx-0x10],xmm0
    const tmp = a.*;
  21982a:	c5 f8 10 41 f0       	vmovups xmm0,XMMWORD PTR [rcx-0x10]
  21982f:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  219834:	c5 f8 10 43 e0       	vmovups xmm0,XMMWORD PTR [rbx-0x20]
  219839:	c5 f8 11 41 f0       	vmovups XMMWORD PTR [rcx-0x10],xmm0
    b.* = tmp;
  21983e:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  219843:	c5 f8 11 43 e0       	vmovups XMMWORD PTR [rbx-0x20],xmm0
    const tmp = a.*;
  219848:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  21984c:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  219851:	c5 f8 10 43 d0       	vmovups xmm0,XMMWORD PTR [rbx-0x30]
  219856:	c5 f8 11 01          	vmovups XMMWORD PTR [rcx],xmm0
    b.* = tmp;
  21985a:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  21985f:	c5 fa 7f 43 d0       	vmovdqu XMMWORD PTR [rbx-0x30],xmm0
    while (i < end) : (i += 1) {
  219864:	48 83 c2 04          	add    rdx,0x4
  219868:	48 83 c1 40          	add    rcx,0x40
  21986c:	48 83 c3 c0          	add    rbx,0xffffffffffffffc0
  219870:	48 39 d0             	cmp    rax,rdx
  219873:	0f 85 77 ff ff ff    	jne    2197f0 <Benchmark_reportStats+0x30b0>
  219879:	48 85 f6             	test   rsi,rsi
  21987c:	74 5a                	je     2198d8 <Benchmark_reportStats+0x3198>
  21987e:	4c 89 f0             	mov    rax,r14
  219881:	48 29 d0             	sub    rax,rdx
  219884:	48 c1 e0 04          	shl    rax,0x4
  219888:	4c 01 d0             	add    rax,r10
  21988b:	48 83 c0 f0          	add    rax,0xfffffffffffffff0
  21988f:	48 03 94 24 d8 00 00 	add    rdx,QWORD PTR [rsp+0xd8]
  219896:	00 
  219897:	4c 01 fa             	add    rdx,r15
  21989a:	4c 01 ca             	add    rdx,r9
  21989d:	48 c1 e2 04          	shl    rdx,0x4
  2198a1:	4c 01 d2             	add    rdx,r10
  2198a4:	48 f7 de             	neg    rsi
  2198a7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  2198ae:	00 00 
    const tmp = a.*;
  2198b0:	c5 f8 10 02          	vmovups xmm0,XMMWORD PTR [rdx]
  2198b4:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  2198b9:	c5 f8 10 00          	vmovups xmm0,XMMWORD PTR [rax]
  2198bd:	c5 f8 11 02          	vmovups XMMWORD PTR [rdx],xmm0
    b.* = tmp;
  2198c1:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  2198c6:	c5 fa 7f 00          	vmovdqu XMMWORD PTR [rax],xmm0
    while (i < end) : (i += 1) {
  2198ca:	48 83 c0 f0          	add    rax,0xfffffffffffffff0
  2198ce:	48 83 c2 10          	add    rdx,0x10
  2198d2:	48 83 c6 01          	add    rsi,0x1
  2198d6:	75 d8                	jne    2198b0 <Benchmark_reportStats+0x3170>
    const end = items.len / 2;
  2198d8:	48 89 f8             	mov    rax,rdi
  2198db:	48 d1 e8             	shr    rax,1
    while (i < end) : (i += 1) {
  2198de:	0f 84 0c 22 00 00    	je     21baf0 <Benchmark_reportStats+0x53b0>
  2198e4:	4b 8d 0c 02          	lea    rcx,[r10+r8*1]
    const tmp = a.*;
  2198e8:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  2198ec:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  2198f1:	48 c1 e7 04          	shl    rdi,0x4
    a.* = b.*;
  2198f5:	c5 f8 10 44 39 f0    	vmovups xmm0,XMMWORD PTR [rcx+rdi*1-0x10]
  2198fb:	c5 f8 11 01          	vmovups XMMWORD PTR [rcx],xmm0
    b.* = tmp;
  2198ff:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  219904:	c5 fa 7f 44 39 f0    	vmovdqu XMMWORD PTR [rcx+rdi*1-0x10],xmm0
    while (i < end) : (i += 1) {
  21990a:	48 83 f8 01          	cmp    rax,0x1
  21990e:	0f 84 dc 21 00 00    	je     21baf0 <Benchmark_reportStats+0x53b0>
        swap(T, &items[i], &items[items.len - i - 1]);
  219914:	8d 48 ff             	lea    ecx,[rax-0x1]
  219917:	48 8d 50 fe          	lea    rdx,[rax-0x2]
  21991b:	83 e1 03             	and    ecx,0x3
  21991e:	48 83 fa 03          	cmp    rdx,0x3
  219922:	0f 83 4e 01 00 00    	jae    219a76 <Benchmark_reportStats+0x3336>
  219928:	ba 01 00 00 00       	mov    edx,0x1
    while (i < end) : (i += 1) {
  21992d:	48 85 c9             	test   rcx,rcx
  219930:	0f 85 ec 01 00 00    	jne    219b22 <Benchmark_reportStats+0x33e2>
  219936:	e9 b5 21 00 00       	jmp    21baf0 <Benchmark_reportStats+0x53b0>
  21993b:	31 d2                	xor    edx,edx
  21993d:	44 89 e8             	mov    eax,r13d
  219940:	41 f7 f6             	div    r14d
  219943:	89 d6                	mov    esi,edx
                    var firstA = Range.init(A.start, A.start + blockA.length() % block_size);
  219945:	4a 8d 04 26          	lea    rax,[rsi+r12*1]
  219949:	48 8b 7c 24 30       	mov    rdi,QWORD PTR [rsp+0x30]
  21994e:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
                    while (index < blockA.end) : ({
  219953:	48 39 f8             	cmp    rax,rdi
  219956:	0f 83 8a 00 00 00    	jae    2199e6 <Benchmark_reportStats+0x32a6>
  21995c:	48 8b 54 24 18       	mov    rdx,QWORD PTR [rsp+0x18]
                        mem.swap(T, &items[indexA], &items[index]);
  219961:	48 89 d0             	mov    rax,rdx
  219964:	48 c1 e0 04          	shl    rax,0x4
  219968:	48 8b 8c 24 d8 01 00 	mov    rcx,QWORD PTR [rsp+0x1d8]
  21996f:	00 
    const tmp = a.*;
  219970:	c4 c1 78 10 04 0a    	vmovups xmm0,XMMWORD PTR [r10+rcx*1]
  219976:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21997b:	c4 c1 78 10 04 02    	vmovups xmm0,XMMWORD PTR [r10+rax*1]
  219981:	c4 c1 78 11 04 0a    	vmovups XMMWORD PTR [r10+rcx*1],xmm0
    b.* = tmp;
  219987:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  21998c:	c4 c1 7a 7f 04 02    	vmovdqu XMMWORD PTR [r10+rax*1],xmm0
                        index += block_size;
  219992:	4a 8d 1c 32          	lea    rbx,[rdx+r14*1]
                    while (index < blockA.end) : ({
  219996:	48 39 fb             	cmp    rbx,rdi
  219999:	73 4b                	jae    2199e6 <Benchmark_reportStats+0x32a6>
  21999b:	48 8b 8c 24 c8 01 00 	mov    rcx,QWORD PTR [rsp+0x1c8]
  2199a2:	00 
  2199a3:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  2199aa:	84 00 00 00 00 00 
                        mem.swap(T, &items[indexA], &items[index]);
  2199b0:	48 8b 54 24 40       	mov    rdx,QWORD PTR [rsp+0x40]
  2199b5:	48 89 d8             	mov    rax,rbx
    const tmp = a.*;
  2199b8:	c5 f8 10 04 0a       	vmovups xmm0,XMMWORD PTR [rdx+rcx*1]
  2199bd:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
  2199c2:	48 c1 e0 04          	shl    rax,0x4
    a.* = b.*;
  2199c6:	c5 f8 10 04 02       	vmovups xmm0,XMMWORD PTR [rdx+rax*1]
  2199cb:	c5 f8 11 04 0a       	vmovups XMMWORD PTR [rdx+rcx*1],xmm0
    b.* = tmp;
  2199d0:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  2199d5:	c5 fa 7f 04 02       	vmovdqu XMMWORD PTR [rdx+rax*1],xmm0
                        index += block_size;
  2199da:	4c 01 f3             	add    rbx,r14
                    while (index < blockA.end) : ({
  2199dd:	48 83 c1 10          	add    rcx,0x10
  2199e1:	48 39 fb             	cmp    rbx,rdi
  2199e4:	72 ca                	jb     2199b0 <Benchmark_reportStats+0x3270>
                    var lastA = firstA;
  2199e6:	4c 89 a4 24 78 01 00 	mov    QWORD PTR [rsp+0x178],r12
  2199ed:	00 
  2199ee:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  2199f3:	48 89 84 24 80 01 00 	mov    QWORD PTR [rsp+0x180],rax
  2199fa:	00 
        return self.end - self.start;
  2199fb:	4c 8b 94 24 e8 00 00 	mov    r10,QWORD PTR [rsp+0xe8]
  219a02:	00 
  219a03:	49 29 fa             	sub    r10,rdi
    return if (x < y) x else y;
  219a06:	4d 39 d6             	cmp    r14,r10
  219a09:	4d 0f 42 d6          	cmovb  r10,r14
                    if (lastA.length() <= cache.len) {
  219a0d:	48 81 fe 00 02 00 00 	cmp    rsi,0x200
  219a14:	77 2f                	ja     219a45 <Benchmark_reportStats+0x3305>
    for (source) |s, i|
  219a16:	48 85 f6             	test   rsi,rsi
  219a19:	0f 84 a2 03 00 00    	je     219dc1 <Benchmark_reportStats+0x3681>
  219a1f:	4c 03 44 24 40       	add    r8,QWORD PTR [rsp+0x40]
  219a24:	4c 03 bc 24 98 01 00 	add    r15,QWORD PTR [rsp+0x198]
  219a2b:	00 
  219a2c:	4d 01 cf             	add    r15,r9
  219a2f:	4d 85 db             	test   r11,r11
  219a32:	0f 84 39 01 00 00    	je     219b71 <Benchmark_reportStats+0x3431>
  219a38:	31 d2                	xor    edx,edx
  219a3a:	4c 89 e8             	mov    rax,r13
  219a3d:	49 f7 f6             	div    r14
  219a40:	e9 34 01 00 00       	jmp    219b79 <Benchmark_reportStats+0x3439>
  219a45:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
  219a4a:	48 39 44 24 50       	cmp    QWORD PTR [rsp+0x50],rax
                    } else if (buffer2.length() > 0) {
  219a4f:	0f 84 6c 03 00 00    	je     219dc1 <Benchmark_reportStats+0x3681>
        mem.swap(T, &items[start1 + index], &items[start2 + index]);
  219a55:	4c 03 bc 24 98 01 00 	add    r15,QWORD PTR [rsp+0x198]
  219a5c:	00 
  219a5d:	4d 01 cf             	add    r15,r9
  219a60:	4d 85 db             	test   r11,r11
  219a63:	0f 84 05 02 00 00    	je     219c6e <Benchmark_reportStats+0x352e>
  219a69:	31 d2                	xor    edx,edx
  219a6b:	4c 89 e8             	mov    rax,r13
  219a6e:	49 f7 f6             	div    r14
  219a71:	e9 00 02 00 00       	jmp    219c76 <Benchmark_reportStats+0x3536>
        swap(T, &items[i], &items[items.len - i - 1]);
  219a76:	4b 8d 34 1a          	lea    rsi,[r10+r11*1]
  219a7a:	48 83 c6 e0          	add    rsi,0xffffffffffffffe0
  219a7e:	4b 8d 3c 02          	lea    rdi,[r10+r8*1]
  219a82:	48 83 c7 40          	add    rdi,0x40
  219a86:	48 29 c8             	sub    rax,rcx
  219a89:	ba 01 00 00 00       	mov    edx,0x1
  219a8e:	66 90                	xchg   ax,ax
    const tmp = a.*;
  219a90:	c5 f8 10 47 d0       	vmovups xmm0,XMMWORD PTR [rdi-0x30]
  219a95:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  219a9a:	c5 f8 10 06          	vmovups xmm0,XMMWORD PTR [rsi]
  219a9e:	c5 f8 11 47 d0       	vmovups XMMWORD PTR [rdi-0x30],xmm0
    b.* = tmp;
  219aa3:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  219aa8:	c5 f8 11 06          	vmovups XMMWORD PTR [rsi],xmm0
    const tmp = a.*;
  219aac:	c5 f8 10 47 e0       	vmovups xmm0,XMMWORD PTR [rdi-0x20]
  219ab1:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  219ab6:	c5 f8 10 46 f0       	vmovups xmm0,XMMWORD PTR [rsi-0x10]
  219abb:	c5 f8 11 47 e0       	vmovups XMMWORD PTR [rdi-0x20],xmm0
    b.* = tmp;
  219ac0:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  219ac5:	c5 f8 11 46 f0       	vmovups XMMWORD PTR [rsi-0x10],xmm0
    const tmp = a.*;
  219aca:	c5 f8 10 47 f0       	vmovups xmm0,XMMWORD PTR [rdi-0x10]
  219acf:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  219ad4:	c5 f8 10 46 e0       	vmovups xmm0,XMMWORD PTR [rsi-0x20]
  219ad9:	c5 f8 11 47 f0       	vmovups XMMWORD PTR [rdi-0x10],xmm0
    b.* = tmp;
  219ade:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  219ae3:	c5 f8 11 46 e0       	vmovups XMMWORD PTR [rsi-0x20],xmm0
    const tmp = a.*;
  219ae8:	c5 f8 10 07          	vmovups xmm0,XMMWORD PTR [rdi]
  219aec:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  219af1:	c5 f8 10 46 d0       	vmovups xmm0,XMMWORD PTR [rsi-0x30]
  219af6:	c5 f8 11 07          	vmovups XMMWORD PTR [rdi],xmm0
    b.* = tmp;
  219afa:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  219aff:	c5 fa 7f 46 d0       	vmovdqu XMMWORD PTR [rsi-0x30],xmm0
    while (i < end) : (i += 1) {
  219b04:	48 83 c2 04          	add    rdx,0x4
  219b08:	48 83 c6 c0          	add    rsi,0xffffffffffffffc0
  219b0c:	48 83 c7 40          	add    rdi,0x40
  219b10:	48 39 d0             	cmp    rax,rdx
  219b13:	0f 85 77 ff ff ff    	jne    219a90 <Benchmark_reportStats+0x3350>
  219b19:	48 85 c9             	test   rcx,rcx
  219b1c:	0f 84 ce 1f 00 00    	je     21baf0 <Benchmark_reportStats+0x53b0>
  219b22:	49 29 d6             	sub    r14,rdx
  219b25:	49 c1 e6 04          	shl    r14,0x4
  219b29:	4b 8d 04 32          	lea    rax,[r10+r14*1]
  219b2d:	48 83 c0 f0          	add    rax,0xfffffffffffffff0
  219b31:	49 01 d4             	add    r12,rdx
  219b34:	49 c1 e4 04          	shl    r12,0x4
  219b38:	4d 01 d4             	add    r12,r10
  219b3b:	48 f7 d9             	neg    rcx
  219b3e:	66 90                	xchg   ax,ax
    const tmp = a.*;
  219b40:	c4 c1 78 10 04 24    	vmovups xmm0,XMMWORD PTR [r12]
  219b46:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  219b4b:	c5 f8 10 00          	vmovups xmm0,XMMWORD PTR [rax]
  219b4f:	c4 c1 78 11 04 24    	vmovups XMMWORD PTR [r12],xmm0
    b.* = tmp;
  219b55:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  219b5a:	c5 fa 7f 00          	vmovdqu XMMWORD PTR [rax],xmm0
    while (i < end) : (i += 1) {
  219b5e:	48 83 c0 f0          	add    rax,0xfffffffffffffff0
  219b62:	49 83 c4 10          	add    r12,0x10
  219b66:	48 83 c1 01          	add    rcx,0x1
  219b6a:	75 d4                	jne    219b40 <Benchmark_reportStats+0x3400>
  219b6c:	e9 7f 1f 00 00       	jmp    21baf0 <Benchmark_reportStats+0x53b0>
  219b71:	31 d2                	xor    edx,edx
  219b73:	44 89 e8             	mov    eax,r13d
  219b76:	41 f7 f6             	div    r14d
    for (source) |s, i|
  219b79:	4c 29 ea             	sub    rdx,r13
  219b7c:	49 01 d7             	add    r15,rdx
  219b7f:	4d 29 e7             	sub    r15,r12
  219b82:	89 f0                	mov    eax,esi
  219b84:	83 e0 07             	and    eax,0x7
  219b87:	49 83 ff 07          	cmp    r15,0x7
  219b8b:	73 10                	jae    219b9d <Benchmark_reportStats+0x345d>
  219b8d:	31 c9                	xor    ecx,ecx
  219b8f:	48 85 c0             	test   rax,rax
  219b92:	0f 85 b2 00 00 00    	jne    219c4a <Benchmark_reportStats+0x350a>
  219b98:	e9 24 02 00 00       	jmp    219dc1 <Benchmark_reportStats+0x3681>
  219b9d:	48 29 c6             	sub    rsi,rax
  219ba0:	ba 70 00 00 00       	mov    edx,0x70
  219ba5:	31 c9                	xor    ecx,ecx
  219ba7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  219bae:	00 00 
        dest[i] = s;
  219bb0:	c4 c1 78 10 44 10 90 	vmovups xmm0,XMMWORD PTR [r8+rdx*1-0x70]
  219bb7:	c5 f8 11 84 14 b8 01 	vmovups XMMWORD PTR [rsp+rdx*1+0x1b8],xmm0
  219bbe:	00 00 
  219bc0:	c4 c1 78 10 44 10 a0 	vmovups xmm0,XMMWORD PTR [r8+rdx*1-0x60]
  219bc7:	c5 f8 11 84 14 c8 01 	vmovups XMMWORD PTR [rsp+rdx*1+0x1c8],xmm0
  219bce:	00 00 
  219bd0:	c4 c1 78 10 44 10 b0 	vmovups xmm0,XMMWORD PTR [r8+rdx*1-0x50]
  219bd7:	c5 f8 11 84 14 d8 01 	vmovups XMMWORD PTR [rsp+rdx*1+0x1d8],xmm0
  219bde:	00 00 
  219be0:	c4 c1 78 10 44 10 c0 	vmovups xmm0,XMMWORD PTR [r8+rdx*1-0x40]
  219be7:	c5 f8 11 84 14 e8 01 	vmovups XMMWORD PTR [rsp+rdx*1+0x1e8],xmm0
  219bee:	00 00 
  219bf0:	c4 c1 78 10 44 10 d0 	vmovups xmm0,XMMWORD PTR [r8+rdx*1-0x30]
  219bf7:	c5 f8 11 84 14 f8 01 	vmovups XMMWORD PTR [rsp+rdx*1+0x1f8],xmm0
  219bfe:	00 00 
  219c00:	c4 c1 78 10 44 10 e0 	vmovups xmm0,XMMWORD PTR [r8+rdx*1-0x20]
  219c07:	c5 f8 11 84 14 08 02 	vmovups XMMWORD PTR [rsp+rdx*1+0x208],xmm0
  219c0e:	00 00 
  219c10:	c4 c1 78 10 44 10 f0 	vmovups xmm0,XMMWORD PTR [r8+rdx*1-0x10]
  219c17:	c5 f8 11 84 14 18 02 	vmovups XMMWORD PTR [rsp+rdx*1+0x218],xmm0
  219c1e:	00 00 
  219c20:	c4 c1 7a 6f 04 10    	vmovdqu xmm0,XMMWORD PTR [r8+rdx*1]
  219c26:	c5 fa 7f 84 14 28 02 	vmovdqu XMMWORD PTR [rsp+rdx*1+0x228],xmm0
  219c2d:	00 00 
    for (source) |s, i|
  219c2f:	48 83 c1 08          	add    rcx,0x8
  219c33:	48 83 ea 80          	sub    rdx,0xffffffffffffff80
  219c37:	48 83 c6 f8          	add    rsi,0xfffffffffffffff8
  219c3b:	0f 85 6f ff ff ff    	jne    219bb0 <Benchmark_reportStats+0x3470>
  219c41:	48 85 c0             	test   rax,rax
  219c44:	0f 84 77 01 00 00    	je     219dc1 <Benchmark_reportStats+0x3681>
  219c4a:	48 c1 e1 04          	shl    rcx,0x4
  219c4e:	66 90                	xchg   ax,ax
        dest[i] = s;
  219c50:	c4 c1 7a 6f 04 08    	vmovdqu xmm0,XMMWORD PTR [r8+rcx*1]
  219c56:	c5 fa 7f 84 0c 28 02 	vmovdqu XMMWORD PTR [rsp+rcx*1+0x228],xmm0
  219c5d:	00 00 
    for (source) |s, i|
  219c5f:	48 83 c1 10          	add    rcx,0x10
  219c63:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  219c67:	75 e7                	jne    219c50 <Benchmark_reportStats+0x3510>
  219c69:	e9 53 01 00 00       	jmp    219dc1 <Benchmark_reportStats+0x3681>
  219c6e:	31 d2                	xor    edx,edx
  219c70:	44 89 e8             	mov    eax,r13d
  219c73:	41 f7 f6             	div    r14d
  219c76:	4c 29 ea             	sub    rdx,r13
  219c79:	49 01 d7             	add    r15,rdx
  219c7c:	4d 29 e7             	sub    r15,r12
  219c7f:	89 f0                	mov    eax,esi
  219c81:	83 e0 03             	and    eax,0x3
  219c84:	49 83 ff 03          	cmp    r15,0x3
  219c88:	4c 8b 8c 24 18 01 00 	mov    r9,QWORD PTR [rsp+0x118]
  219c8f:	00 
  219c90:	73 10                	jae    219ca2 <Benchmark_reportStats+0x3562>
  219c92:	31 c9                	xor    ecx,ecx
    while (index < block_size) : (index += 1) {
  219c94:	48 85 c0             	test   rax,rax
  219c97:	0f 85 db 00 00 00    	jne    219d78 <Benchmark_reportStats+0x3638>
  219c9d:	e9 1f 01 00 00       	jmp    219dc1 <Benchmark_reportStats+0x3681>
        mem.swap(T, &items[start1 + index], &items[start2 + index]);
  219ca2:	48 29 c6             	sub    rsi,rax
  219ca5:	31 d2                	xor    edx,edx
  219ca7:	31 c9                	xor    ecx,ecx
  219ca9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  219cb0:	48 8b 5c 24 40       	mov    rbx,QWORD PTR [rsp+0x40]
    const tmp = a.*;
  219cb5:	4a 8d 3c 03          	lea    rdi,[rbx+r8*1]
  219cb9:	c5 f8 10 04 3a       	vmovups xmm0,XMMWORD PTR [rdx+rdi*1]
  219cbe:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  219cc3:	4c 01 cb             	add    rbx,r9
  219cc6:	c5 f8 10 04 1a       	vmovups xmm0,XMMWORD PTR [rdx+rbx*1]
  219ccb:	c5 f8 11 04 3a       	vmovups XMMWORD PTR [rdx+rdi*1],xmm0
    b.* = tmp;
  219cd0:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  219cd5:	c5 f8 11 04 1a       	vmovups XMMWORD PTR [rdx+rbx*1],xmm0
  219cda:	48 8b 7c 24 40       	mov    rdi,QWORD PTR [rsp+0x40]
    const tmp = a.*;
  219cdf:	4a 8d 5c 07 10       	lea    rbx,[rdi+r8*1+0x10]
  219ce4:	c5 f8 10 04 1a       	vmovups xmm0,XMMWORD PTR [rdx+rbx*1]
  219ce9:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  219cee:	4a 8d 7c 0f 10       	lea    rdi,[rdi+r9*1+0x10]
  219cf3:	c5 f8 10 04 3a       	vmovups xmm0,XMMWORD PTR [rdx+rdi*1]
  219cf8:	c5 f8 11 04 1a       	vmovups XMMWORD PTR [rdx+rbx*1],xmm0
    b.* = tmp;
  219cfd:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  219d02:	c5 f8 11 04 3a       	vmovups XMMWORD PTR [rdx+rdi*1],xmm0
  219d07:	48 8b 7c 24 40       	mov    rdi,QWORD PTR [rsp+0x40]
    const tmp = a.*;
  219d0c:	4a 8d 5c 07 20       	lea    rbx,[rdi+r8*1+0x20]
  219d11:	c5 f8 10 04 1a       	vmovups xmm0,XMMWORD PTR [rdx+rbx*1]
  219d16:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  219d1b:	4a 8d 7c 0f 20       	lea    rdi,[rdi+r9*1+0x20]
  219d20:	c5 f8 10 04 3a       	vmovups xmm0,XMMWORD PTR [rdx+rdi*1]
  219d25:	c5 f8 11 04 1a       	vmovups XMMWORD PTR [rdx+rbx*1],xmm0
    b.* = tmp;
  219d2a:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  219d2f:	c5 f8 11 04 3a       	vmovups XMMWORD PTR [rdx+rdi*1],xmm0
  219d34:	48 8b 7c 24 40       	mov    rdi,QWORD PTR [rsp+0x40]
    const tmp = a.*;
  219d39:	4a 8d 5c 07 30       	lea    rbx,[rdi+r8*1+0x30]
  219d3e:	c5 f8 10 04 1a       	vmovups xmm0,XMMWORD PTR [rdx+rbx*1]
  219d43:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  219d48:	4a 8d 7c 0f 30       	lea    rdi,[rdi+r9*1+0x30]
  219d4d:	c5 f8 10 04 3a       	vmovups xmm0,XMMWORD PTR [rdx+rdi*1]
  219d52:	c5 f8 11 04 1a       	vmovups XMMWORD PTR [rdx+rbx*1],xmm0
    b.* = tmp;
  219d57:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  219d5c:	c5 fa 7f 04 3a       	vmovdqu XMMWORD PTR [rdx+rdi*1],xmm0
    while (index < block_size) : (index += 1) {
  219d61:	48 83 c1 04          	add    rcx,0x4
  219d65:	48 83 c2 40          	add    rdx,0x40
  219d69:	48 83 c6 fc          	add    rsi,0xfffffffffffffffc
  219d6d:	0f 85 3d ff ff ff    	jne    219cb0 <Benchmark_reportStats+0x3570>
  219d73:	48 85 c0             	test   rax,rax
  219d76:	74 49                	je     219dc1 <Benchmark_reportStats+0x3681>
  219d78:	48 8b 54 24 60       	mov    rdx,QWORD PTR [rsp+0x60]
  219d7d:	48 8d 14 0a          	lea    rdx,[rdx+rcx*1]
  219d81:	48 c1 e2 04          	shl    rdx,0x4
  219d85:	4c 01 e1             	add    rcx,r12
  219d88:	48 c1 e1 04          	shl    rcx,0x4
  219d8c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
        mem.swap(T, &items[start1 + index], &items[start2 + index]);
  219d90:	48 8b 74 24 40       	mov    rsi,QWORD PTR [rsp+0x40]
    const tmp = a.*;
  219d95:	c5 f8 10 04 0e       	vmovups xmm0,XMMWORD PTR [rsi+rcx*1]
  219d9a:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  219d9f:	c5 f8 10 04 16       	vmovups xmm0,XMMWORD PTR [rsi+rdx*1]
  219da4:	c5 f8 11 04 0e       	vmovups XMMWORD PTR [rsi+rcx*1],xmm0
    b.* = tmp;
  219da9:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  219dae:	c5 fa 7f 04 16       	vmovdqu XMMWORD PTR [rsi+rdx*1],xmm0
    while (index < block_size) : (index += 1) {
  219db3:	48 83 c2 10          	add    rdx,0x10
  219db7:	48 83 c1 10          	add    rcx,0x10
  219dbb:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  219dbf:	75 cf                	jne    219d90 <Benchmark_reportStats+0x3650>
  219dc1:	4c 8b 5c 24 30       	mov    r11,QWORD PTR [rsp+0x30]
                    if (blockA.length() > 0) {
  219dc6:	4c 3b 5c 24 18       	cmp    r11,QWORD PTR [rsp+0x18]
  219dcb:	0f 85 d6 00 00 00    	jne    219ea7 <Benchmark_reportStats+0x3767>
  219dd1:	4d 89 df             	mov    r15,r11
  219dd4:	48 8b 44 24 50       	mov    rax,QWORD PTR [rsp+0x50]
                    if (lastA.length() <= cache.len) {
  219dd9:	49 81 fd 00 02 00 00 	cmp    r13,0x200
  219de0:	4c 8b 84 24 e8 00 00 	mov    r8,QWORD PTR [rsp+0xe8]
  219de7:	00 
  219de8:	0f 87 51 1a 00 00    	ja     21b83f <Benchmark_reportStats+0x50ff>
    if (B.length() > 0 and A.length() > 0) {
  219dee:	4d 85 ed             	test   r13,r13
  219df1:	0f 84 e3 00 00 00    	je     219eda <Benchmark_reportStats+0x379a>
  219df7:	4d 39 f8             	cmp    r8,r15
  219dfa:	0f 84 da 00 00 00    	je     219eda <Benchmark_reportStats+0x379a>
            if (!lessThan(items[B_index], cache[A_index])) {
  219e00:	4d 89 ea             	mov    r10,r13
  219e03:	49 f7 da             	neg    r10
  219e06:	31 d2                	xor    edx,edx
  219e08:	49 89 d1             	mov    r9,rdx
  219e0b:	4c 89 e3             	mov    rbx,r12
  219e0e:	48 c1 e3 04          	shl    rbx,0x4
  219e12:	4f 8d 1c 0a          	lea    r11,[r10+r9*1]
  219e16:	4c 89 c8             	mov    rax,r9
  219e19:	48 c1 e0 04          	shl    rax,0x4
  219e1d:	48 8d 0c 04          	lea    rcx,[rsp+rax*1]
  219e21:	48 81 c1 28 02 00 00 	add    rcx,0x228
  219e28:	31 f6                	xor    esi,esi
  219e2a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  219e30:	48 8b 54 24 40       	mov    rdx,QWORD PTR [rsp+0x40]
  219e35:	4c 89 f8             	mov    rax,r15
  219e38:	48 c1 e0 04          	shl    rax,0x4
  219e3c:	48 8b 3c 02          	mov    rdi,QWORD PTR [rdx+rax*1]
  219e40:	48 3b 39             	cmp    rdi,QWORD PTR [rcx]
  219e43:	72 2b                	jb     219e70 <Benchmark_reportStats+0x3730>
                items[insert_index] = cache[A_index];
  219e45:	c5 fa 6f 01          	vmovdqu xmm0,XMMWORD PTR [rcx]
  219e49:	c5 fa 7f 04 1a       	vmovdqu XMMWORD PTR [rdx+rbx*1],xmm0
                if (A_index == A_last) break;
  219e4e:	48 83 c6 ff          	add    rsi,0xffffffffffffffff
  219e52:	48 83 c3 10          	add    rbx,0x10
  219e56:	48 83 c1 10          	add    rcx,0x10
  219e5a:	49 39 f3             	cmp    r11,rsi
  219e5d:	75 d1                	jne    219e30 <Benchmark_reportStats+0x36f0>
  219e5f:	eb 7e                	jmp    219edf <Benchmark_reportStats+0x379f>
  219e61:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  219e68:	0f 1f 84 00 00 00 00 
  219e6f:	00 
  219e70:	48 01 d0             	add    rax,rdx
                items[insert_index] = items[B_index];
  219e73:	c5 fa 6f 00          	vmovdqu xmm0,XMMWORD PTR [rax]
  219e77:	c5 fa 7f 04 1a       	vmovdqu XMMWORD PTR [rdx+rbx*1],xmm0
                B_index += 1;
  219e7c:	49 83 c7 01          	add    r15,0x1
                if (B_index == B_last) break;
  219e80:	4c 89 e1             	mov    rcx,r12
  219e83:	48 83 c1 01          	add    rcx,0x1
  219e87:	49 89 cc             	mov    r12,rcx
  219e8a:	49 29 f4             	sub    r12,rsi
  219e8d:	4c 89 ca             	mov    rdx,r9
  219e90:	48 29 f2             	sub    rdx,rsi
  219e93:	4d 39 c7             	cmp    r15,r8
  219e96:	0f 85 6c ff ff ff    	jne    219e08 <Benchmark_reportStats+0x36c8>
    mem.copy(T, items[insert_index..], cache[A_index..A_last]);
  219e9c:	48 29 f1             	sub    rcx,rsi
  219e9f:	49 29 f1             	sub    r9,rsi
  219ea2:	49 89 cc             	mov    r12,rcx
  219ea5:	eb 3e                	jmp    219ee5 <Benchmark_reportStats+0x37a5>
  219ea7:	4d 89 d0             	mov    r8,r10
  219eaa:	4d 01 d8             	add    r8,r11
  219ead:	48 8b 84 24 e8 00 00 	mov    rax,QWORD PTR [rsp+0xe8]
  219eb4:	00 
  219eb5:	4c 29 f0             	sub    rax,r14
  219eb8:	48 89 84 24 d0 01 00 	mov    QWORD PTR [rsp+0x1d0],rax
  219ebf:	00 
  219ec0:	31 db                	xor    ebx,ebx
  219ec2:	45 31 e4             	xor    r12d,r12d
  219ec5:	4c 89 df             	mov    rdi,r11
  219ec8:	48 8b 44 24 70       	mov    rax,QWORD PTR [rsp+0x70]
  219ecd:	48 89 c6             	mov    rsi,rax
  219ed0:	4c 8b 54 24 18       	mov    r10,QWORD PTR [rsp+0x18]
  219ed5:	e9 66 01 00 00       	jmp    21a040 <Benchmark_reportStats+0x3900>
  219eda:	45 31 c9             	xor    r9d,r9d
  219edd:	eb 06                	jmp    219ee5 <Benchmark_reportStats+0x37a5>
  219edf:	49 29 f4             	sub    r12,rsi
  219ee2:	4d 89 e9             	mov    r9,r13
  219ee5:	48 8b 44 24 48       	mov    rax,QWORD PTR [rsp+0x48]
  219eea:	4c 29 e0             	sub    rax,r12
  219eed:	4c 89 ee             	mov    rsi,r13
  219ef0:	4c 29 ce             	sub    rsi,r9
    assert(dest.len >= source.len);
  219ef3:	48 39 f0             	cmp    rax,rsi
  219ef6:	0f 82 b0 53 00 00    	jb     21f2ac <Benchmark_reportStats+0x8b6c>
    for (source) |s, i|
  219efc:	48 85 f6             	test   rsi,rsi
  219eff:	0f 84 eb 1b 00 00    	je     21baf0 <Benchmark_reportStats+0x53b0>
  219f05:	4c 8b 54 24 40       	mov    r10,QWORD PTR [rsp+0x40]
  219f0a:	49 83 c5 ff          	add    r13,0xffffffffffffffff
  219f0e:	4d 29 cd             	sub    r13,r9
  219f11:	89 f2                	mov    edx,esi
  219f13:	83 e2 07             	and    edx,0x7
  219f16:	49 83 fd 07          	cmp    r13,0x7
  219f1a:	73 10                	jae    219f2c <Benchmark_reportStats+0x37ec>
  219f1c:	31 ff                	xor    edi,edi
  219f1e:	48 85 d2             	test   rdx,rdx
  219f21:	0f 85 ad 00 00 00    	jne    219fd4 <Benchmark_reportStats+0x3894>
  219f27:	e9 c4 1b 00 00       	jmp    21baf0 <Benchmark_reportStats+0x53b0>
  219f2c:	4c 89 e3             	mov    rbx,r12
  219f2f:	48 c1 e3 04          	shl    rbx,0x4
  219f33:	4c 01 d3             	add    rbx,r10
  219f36:	48 29 d6             	sub    rsi,rdx
  219f39:	4c 89 c8             	mov    rax,r9
  219f3c:	48 c1 e0 04          	shl    rax,0x4
  219f40:	48 8d 0c 04          	lea    rcx,[rsp+rax*1]
  219f44:	48 81 c1 28 02 00 00 	add    rcx,0x228
  219f4b:	b8 70 00 00 00       	mov    eax,0x70
  219f50:	31 ff                	xor    edi,edi
  219f52:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  219f59:	1f 84 00 00 00 00 00 
        dest[i] = s;
  219f60:	c5 f8 10 44 01 90    	vmovups xmm0,XMMWORD PTR [rcx+rax*1-0x70]
  219f66:	c5 f8 11 44 03 90    	vmovups XMMWORD PTR [rbx+rax*1-0x70],xmm0
  219f6c:	c5 f8 10 44 01 a0    	vmovups xmm0,XMMWORD PTR [rcx+rax*1-0x60]
  219f72:	c5 f8 11 44 03 a0    	vmovups XMMWORD PTR [rbx+rax*1-0x60],xmm0
  219f78:	c5 f8 10 44 01 b0    	vmovups xmm0,XMMWORD PTR [rcx+rax*1-0x50]
  219f7e:	c5 f8 11 44 03 b0    	vmovups XMMWORD PTR [rbx+rax*1-0x50],xmm0
  219f84:	c5 f8 10 44 01 c0    	vmovups xmm0,XMMWORD PTR [rcx+rax*1-0x40]
  219f8a:	c5 f8 11 44 03 c0    	vmovups XMMWORD PTR [rbx+rax*1-0x40],xmm0
  219f90:	c5 f8 10 44 01 d0    	vmovups xmm0,XMMWORD PTR [rcx+rax*1-0x30]
  219f96:	c5 f8 11 44 03 d0    	vmovups XMMWORD PTR [rbx+rax*1-0x30],xmm0
  219f9c:	c5 f8 10 44 01 e0    	vmovups xmm0,XMMWORD PTR [rcx+rax*1-0x20]
  219fa2:	c5 f8 11 44 03 e0    	vmovups XMMWORD PTR [rbx+rax*1-0x20],xmm0
  219fa8:	c5 f8 10 44 01 f0    	vmovups xmm0,XMMWORD PTR [rcx+rax*1-0x10]
  219fae:	c5 f8 11 44 03 f0    	vmovups XMMWORD PTR [rbx+rax*1-0x10],xmm0
  219fb4:	c5 fa 6f 04 01       	vmovdqu xmm0,XMMWORD PTR [rcx+rax*1]
  219fb9:	c5 fa 7f 04 03       	vmovdqu XMMWORD PTR [rbx+rax*1],xmm0
    for (source) |s, i|
  219fbe:	48 83 c7 08          	add    rdi,0x8
  219fc2:	48 83 e8 80          	sub    rax,0xffffffffffffff80
  219fc6:	48 39 fe             	cmp    rsi,rdi
  219fc9:	75 95                	jne    219f60 <Benchmark_reportStats+0x3820>
  219fcb:	48 85 d2             	test   rdx,rdx
  219fce:	0f 84 1c 1b 00 00    	je     21baf0 <Benchmark_reportStats+0x53b0>
  219fd4:	49 01 fc             	add    r12,rdi
  219fd7:	49 c1 e4 04          	shl    r12,0x4
  219fdb:	4d 01 e2             	add    r10,r12
  219fde:	49 01 f9             	add    r9,rdi
  219fe1:	49 c1 e1 04          	shl    r9,0x4
  219fe5:	4a 8d 04 0c          	lea    rax,[rsp+r9*1]
  219fe9:	48 05 28 02 00 00    	add    rax,0x228
  219fef:	48 f7 da             	neg    rdx
  219ff2:	31 c9                	xor    ecx,ecx
  219ff4:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  219ffb:	00 00 00 00 00 
        dest[i] = s;
  21a000:	c5 fa 6f 04 08       	vmovdqu xmm0,XMMWORD PTR [rax+rcx*1]
  21a005:	c4 c1 7a 7f 04 0a    	vmovdqu XMMWORD PTR [r10+rcx*1],xmm0
    for (source) |s, i|
  21a00b:	48 83 c1 10          	add    rcx,0x10
  21a00f:	48 83 c2 01          	add    rdx,0x1
  21a013:	75 eb                	jne    21a000 <Benchmark_reportStats+0x38c0>
  21a015:	e9 d6 1a 00 00       	jmp    21baf0 <Benchmark_reportStats+0x53b0>
                                lastB = Range.init(blockA.start, blockA.start + block_size);
  21a01a:	4f 8d 14 34          	lea    r10,[r12+r14*1]
                                blockA.end += block_size;
  21a01e:	4d 01 f3             	add    r11,r14
                                blockB.start += block_size;
  21a021:	4c 01 f7             	add    rdi,r14
                                if (blockB.end > B.end - block_size) {
  21a024:	4c 3b 84 24 d0 01 00 	cmp    r8,QWORD PTR [rsp+0x1d0]
  21a02b:	00 
                                    blockB.end += block_size;
  21a02c:	4f 8d 04 30          	lea    r8,[r8+r14*1]
                                if (blockB.end > B.end - block_size) {
  21a030:	4c 0f 47 84 24 e8 00 	cmova  r8,QWORD PTR [rsp+0xe8]
  21a037:	00 00 
  21a039:	4c 89 d3             	mov    rbx,r10
  21a03c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  21a040:	48 89 bc 24 d0 00 00 	mov    QWORD PTR [rsp+0xd0],rdi
  21a047:	00 
  21a048:	eb 20                	jmp    21a06a <Benchmark_reportStats+0x392a>
  21a04a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
                                blockA.end += blockB.length();
  21a050:	4d 01 d3             	add    r11,r10
                                lastB = Range.init(blockA.start, blockA.start + blockB.length());
  21a053:	4f 8d 14 22          	lea    r10,[r10+r12*1]
  21a057:	4c 89 d3             	mov    rbx,r10
  21a05a:	48 8b bc 24 d0 00 00 	mov    rdi,QWORD PTR [rsp+0xd0]
  21a061:	00 
  21a062:	49 89 f8             	mov    r8,rdi
  21a065:	48 8b 74 24 20       	mov    rsi,QWORD PTR [rsp+0x20]
  21a06a:	4d 89 e7             	mov    r15,r12
  21a06d:	4c 89 5c 24 30       	mov    QWORD PTR [rsp+0x30],r11
  21a072:	4c 89 84 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],r8
  21a079:	00 
  21a07a:	eb 14                	jmp    21a090 <Benchmark_reportStats+0x3950>
  21a07c:	45 31 d2             	xor    r10d,r10d
  21a07f:	31 ff                	xor    edi,edi
    while (index < block_size) : (index += 1) {
  21a081:	4d 29 d1             	sub    r9,r10
  21a084:	0f 85 65 06 00 00    	jne    21a6ef <Benchmark_reportStats+0x3faf>
  21a08a:	e9 e1 07 00 00       	jmp    21a870 <Benchmark_reportStats+0x4130>
  21a08f:	90                   	nop
  21a090:	4d 89 d4             	mov    r12,r10
                            if ((lastB.length() > 0 and !lessThan(items[lastB.end - 1], items[indexA])) or blockB.length() == 0) {
  21a093:	4c 39 fb             	cmp    rbx,r15
  21a096:	48 89 74 24 20       	mov    QWORD PTR [rsp+0x20],rsi
  21a09b:	75 13                	jne    21a0b0 <Benchmark_reportStats+0x3970>
  21a09d:	49 39 f8             	cmp    r8,rdi
  21a0a0:	0f 85 3a 11 00 00    	jne    21b1e0 <Benchmark_reportStats+0x4aa0>
                                const B_split = binaryFirst(T, items, items[indexA], lastB, lessThan);
  21a0a6:	48 8b 54 24 40       	mov    rdx,QWORD PTR [rsp+0x40]
  21a0ab:	eb 2a                	jmp    21a0d7 <Benchmark_reportStats+0x3997>
  21a0ad:	0f 1f 00             	nop    DWORD PTR [rax]
                            if ((lastB.length() > 0 and !lessThan(items[lastB.end - 1], items[indexA])) or blockB.length() == 0) {
  21a0b0:	48 8b 54 24 40       	mov    rdx,QWORD PTR [rsp+0x40]
  21a0b5:	49 39 f8             	cmp    r8,rdi
  21a0b8:	74 1d                	je     21a0d7 <Benchmark_reportStats+0x3997>
  21a0ba:	48 89 d8             	mov    rax,rbx
  21a0bd:	48 c1 e0 04          	shl    rax,0x4
  21a0c1:	48 89 f1             	mov    rcx,rsi
  21a0c4:	48 c1 e1 04          	shl    rcx,0x4
  21a0c8:	48 8b 0c 0a          	mov    rcx,QWORD PTR [rdx+rcx*1]
  21a0cc:	48 39 4c 02 f0       	cmp    QWORD PTR [rdx+rax*1-0x10],rcx
  21a0d1:	0f 82 09 11 00 00    	jb     21b1e0 <Benchmark_reportStats+0x4aa0>
                                const B_split = binaryFirst(T, items, items[indexA], lastB, lessThan);
  21a0d7:	49 89 f1             	mov    r9,rsi
  21a0da:	49 c1 e1 04          	shl    r9,0x4
  21a0de:	49 89 dd             	mov    r13,rbx
  21a0e1:	48 89 5c 24 38       	mov    QWORD PTR [rsp+0x38],rbx
    if (range.start >= range.end) return range.end;
  21a0e6:	49 39 df             	cmp    r15,rbx
  21a0e9:	0f 83 87 00 00 00    	jae    21a176 <Benchmark_reportStats+0x3a36>
  21a0ef:	4e 8d 04 0a          	lea    r8,[rdx+r9*1]
    var end = range.end - 1;
  21a0f3:	48 8b 44 24 38       	mov    rax,QWORD PTR [rsp+0x38]
  21a0f8:	4c 8d 50 ff          	lea    r10,[rax-0x1]
    while (start < end) {
  21a0fc:	4d 39 fa             	cmp    r10,r15
  21a0ff:	76 4b                	jbe    21a14c <Benchmark_reportStats+0x3a0c>
  21a101:	49 8b 18             	mov    rbx,QWORD PTR [r8]
  21a104:	4c 89 d1             	mov    rcx,r10
  21a107:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  21a10e:	00 00 
        const mid = start + (end - start) / 2;
  21a110:	48 89 ce             	mov    rsi,rcx
  21a113:	4c 29 fe             	sub    rsi,r15
  21a116:	48 d1 ee             	shr    rsi,1
  21a119:	4a 8d 3c 3e          	lea    rdi,[rsi+r15*1]
  21a11d:	48 89 f8             	mov    rax,rdi
  21a120:	48 c1 e0 04          	shl    rax,0x4
  21a124:	48 39 1c 02          	cmp    QWORD PTR [rdx+rax*1],rbx
        if (lessThan(items[mid], value)) {
  21a128:	72 16                	jb     21a140 <Benchmark_reportStats+0x3a00>
  21a12a:	48 89 f9             	mov    rcx,rdi
    while (start < end) {
  21a12d:	4c 39 f9             	cmp    rcx,r15
  21a130:	77 de                	ja     21a110 <Benchmark_reportStats+0x39d0>
  21a132:	eb 18                	jmp    21a14c <Benchmark_reportStats+0x3a0c>
  21a134:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21a13b:	00 00 00 00 00 
  21a140:	49 01 f7             	add    r15,rsi
  21a143:	49 83 c7 01          	add    r15,0x1
  21a147:	4c 39 f9             	cmp    rcx,r15
  21a14a:	77 c4                	ja     21a110 <Benchmark_reportStats+0x39d0>
    if (start == range.end - 1 and lessThan(items[start], value)) {
  21a14c:	4d 39 d7             	cmp    r15,r10
  21a14f:	75 1f                	jne    21a170 <Benchmark_reportStats+0x3a30>
  21a151:	49 c1 e2 04          	shl    r10,0x4
  21a155:	4a 8b 04 12          	mov    rax,QWORD PTR [rdx+r10*1]
  21a159:	45 31 ed             	xor    r13d,r13d
  21a15c:	49 3b 00             	cmp    rax,QWORD PTR [r8]
  21a15f:	41 0f 92 c5          	setb   r13b
  21a163:	eb 0e                	jmp    21a173 <Benchmark_reportStats+0x3a33>
  21a165:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21a16c:	00 00 00 00 
  21a170:	45 31 ed             	xor    r13d,r13d
  21a173:	4d 01 fd             	add    r13,r15
  21a176:	4f 8d 04 34          	lea    r8,[r12+r14*1]
  21a17a:	4c 89 e0             	mov    rax,r12
                                while (findA < blockA.end) : (findA += block_size) {
  21a17d:	4d 39 d8             	cmp    r8,r11
  21a180:	73 37                	jae    21a1b9 <Benchmark_reportStats+0x3a79>
  21a182:	4c 89 c6             	mov    rsi,r8
  21a185:	4c 89 e3             	mov    rbx,r12
  21a188:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  21a18f:	00 
  21a190:	48 89 f0             	mov    rax,rsi
  21a193:	48 c1 e0 04          	shl    rax,0x4
  21a197:	48 8b 0c 02          	mov    rcx,QWORD PTR [rdx+rax*1]
  21a19b:	48 89 df             	mov    rdi,rbx
  21a19e:	48 c1 e7 04          	shl    rdi,0x4
                                    if (lessThan(items[findA], items[minA])) {
  21a1a2:	48 89 f0             	mov    rax,rsi
  21a1a5:	48 3b 0c 3a          	cmp    rcx,QWORD PTR [rdx+rdi*1]
  21a1a9:	72 03                	jb     21a1ae <Benchmark_reportStats+0x3a6e>
  21a1ab:	48 89 d8             	mov    rax,rbx
  21a1ae:	4c 01 f6             	add    rsi,r14
  21a1b1:	48 89 c3             	mov    rbx,rax
                                while (findA < blockA.end) : (findA += block_size) {
  21a1b4:	4c 39 de             	cmp    rsi,r11
  21a1b7:	72 d7                	jb     21a190 <Benchmark_reportStats+0x3a50>
  21a1b9:	48 83 7c 24 58 03    	cmp    QWORD PTR [rsp+0x58],0x3
    while (index < block_size) : (index += 1) {
  21a1bf:	73 1f                	jae    21a1e0 <Benchmark_reportStats+0x3aa0>
  21a1c1:	31 f6                	xor    esi,esi
  21a1c3:	48 83 7c 24 10 00    	cmp    QWORD PTR [rsp+0x10],0x0
  21a1c9:	0f 85 0f 01 00 00    	jne    21a2de <Benchmark_reportStats+0x3b9e>
  21a1cf:	e9 55 01 00 00       	jmp    21a329 <Benchmark_reportStats+0x3be9>
  21a1d4:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21a1db:	00 00 00 00 00 
  21a1e0:	48 89 c7             	mov    rdi,rax
  21a1e3:	48 c1 e7 04          	shl    rdi,0x4
  21a1e7:	48 83 c7 20          	add    rdi,0x20
  21a1eb:	31 f6                	xor    esi,esi
  21a1ed:	48 8b 9c 24 10 01 00 	mov    rbx,QWORD PTR [rsp+0x110]
  21a1f4:	00 
  21a1f5:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21a1fc:	00 00 00 00 
        mem.swap(T, &items[start1 + index], &items[start2 + index]);
  21a200:	4a 8d 0c 26          	lea    rcx,[rsi+r12*1]
  21a204:	48 c1 e1 04          	shl    rcx,0x4
    const tmp = a.*;
  21a208:	c5 f8 10 04 0a       	vmovups xmm0,XMMWORD PTR [rdx+rcx*1]
  21a20d:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21a212:	c5 f8 10 44 3a e0    	vmovups xmm0,XMMWORD PTR [rdx+rdi*1-0x20]
  21a218:	c5 f8 11 04 0a       	vmovups XMMWORD PTR [rdx+rcx*1],xmm0
    b.* = tmp;
  21a21d:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  21a222:	c5 f8 11 44 3a e0    	vmovups XMMWORD PTR [rdx+rdi*1-0x20],xmm0
    while (index < block_size) : (index += 1) {
  21a228:	48 89 f1             	mov    rcx,rsi
  21a22b:	48 83 c9 01          	or     rcx,0x1
  21a22f:	48 8b 54 24 40       	mov    rdx,QWORD PTR [rsp+0x40]
        mem.swap(T, &items[start1 + index], &items[start2 + index]);
  21a234:	4c 01 e1             	add    rcx,r12
  21a237:	48 c1 e1 04          	shl    rcx,0x4
    const tmp = a.*;
  21a23b:	c5 f8 10 04 0a       	vmovups xmm0,XMMWORD PTR [rdx+rcx*1]
  21a240:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21a245:	c5 f8 10 44 3a f0    	vmovups xmm0,XMMWORD PTR [rdx+rdi*1-0x10]
  21a24b:	c5 f8 11 04 0a       	vmovups XMMWORD PTR [rdx+rcx*1],xmm0
    b.* = tmp;
  21a250:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  21a255:	c5 f8 11 44 3a f0    	vmovups XMMWORD PTR [rdx+rdi*1-0x10],xmm0
    while (index < block_size) : (index += 1) {
  21a25b:	48 89 f1             	mov    rcx,rsi
  21a25e:	48 83 c9 02          	or     rcx,0x2
  21a262:	48 8b 54 24 40       	mov    rdx,QWORD PTR [rsp+0x40]
        mem.swap(T, &items[start1 + index], &items[start2 + index]);
  21a267:	4c 01 e1             	add    rcx,r12
  21a26a:	48 c1 e1 04          	shl    rcx,0x4
    const tmp = a.*;
  21a26e:	c5 f8 10 04 0a       	vmovups xmm0,XMMWORD PTR [rdx+rcx*1]
  21a273:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21a278:	c5 f8 10 04 3a       	vmovups xmm0,XMMWORD PTR [rdx+rdi*1]
  21a27d:	c5 f8 11 04 0a       	vmovups XMMWORD PTR [rdx+rcx*1],xmm0
    b.* = tmp;
  21a282:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  21a287:	c5 f8 11 04 3a       	vmovups XMMWORD PTR [rdx+rdi*1],xmm0
    while (index < block_size) : (index += 1) {
  21a28c:	48 89 f1             	mov    rcx,rsi
  21a28f:	48 83 c9 03          	or     rcx,0x3
  21a293:	48 8b 54 24 40       	mov    rdx,QWORD PTR [rsp+0x40]
        mem.swap(T, &items[start1 + index], &items[start2 + index]);
  21a298:	4c 01 e1             	add    rcx,r12
  21a29b:	48 c1 e1 04          	shl    rcx,0x4
    const tmp = a.*;
  21a29f:	c5 f8 10 04 0a       	vmovups xmm0,XMMWORD PTR [rdx+rcx*1]
  21a2a4:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21a2a9:	c5 f8 10 44 3a 10    	vmovups xmm0,XMMWORD PTR [rdx+rdi*1+0x10]
  21a2af:	c5 f8 11 04 0a       	vmovups XMMWORD PTR [rdx+rcx*1],xmm0
    b.* = tmp;
  21a2b4:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  21a2b9:	c5 fa 7f 44 3a 10    	vmovdqu XMMWORD PTR [rdx+rdi*1+0x10],xmm0
    while (index < block_size) : (index += 1) {
  21a2bf:	48 83 c6 04          	add    rsi,0x4
  21a2c3:	48 8b 54 24 40       	mov    rdx,QWORD PTR [rsp+0x40]
  21a2c8:	48 83 c7 40          	add    rdi,0x40
  21a2cc:	48 83 c3 fc          	add    rbx,0xfffffffffffffffc
  21a2d0:	0f 85 2a ff ff ff    	jne    21a200 <Benchmark_reportStats+0x3ac0>
  21a2d6:	48 83 7c 24 10 00    	cmp    QWORD PTR [rsp+0x10],0x0
  21a2dc:	74 4b                	je     21a329 <Benchmark_reportStats+0x3be9>
  21a2de:	48 01 f0             	add    rax,rsi
  21a2e1:	48 c1 e0 04          	shl    rax,0x4
  21a2e5:	48 8b 7c 24 10       	mov    rdi,QWORD PTR [rsp+0x10]
  21a2ea:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
        mem.swap(T, &items[start1 + index], &items[start2 + index]);
  21a2f0:	4a 8d 0c 26          	lea    rcx,[rsi+r12*1]
  21a2f4:	48 c1 e1 04          	shl    rcx,0x4
    const tmp = a.*;
  21a2f8:	c5 f8 10 04 0a       	vmovups xmm0,XMMWORD PTR [rdx+rcx*1]
  21a2fd:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21a302:	c5 f8 10 04 02       	vmovups xmm0,XMMWORD PTR [rdx+rax*1]
  21a307:	c5 f8 11 04 0a       	vmovups XMMWORD PTR [rdx+rcx*1],xmm0
    b.* = tmp;
  21a30c:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  21a311:	c5 fa 7f 04 02       	vmovdqu XMMWORD PTR [rdx+rax*1],xmm0
    while (index < block_size) : (index += 1) {
  21a316:	48 83 c6 01          	add    rsi,0x1
  21a31a:	48 8b 54 24 40       	mov    rdx,QWORD PTR [rsp+0x40]
  21a31f:	48 83 c0 10          	add    rax,0x10
  21a323:	48 83 c7 ff          	add    rdi,0xffffffffffffffff
  21a327:	75 c7                	jne    21a2f0 <Benchmark_reportStats+0x3bb0>
                                mem.swap(T, &items[blockA.start], &items[indexA]);
  21a329:	4d 89 e6             	mov    r14,r12
  21a32c:	49 c1 e6 04          	shl    r14,0x4
    const tmp = a.*;
  21a330:	c4 a1 78 10 04 32    	vmovups xmm0,XMMWORD PTR [rdx+r14*1]
  21a336:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21a33b:	c4 a1 78 10 04 0a    	vmovups xmm0,XMMWORD PTR [rdx+r9*1]
  21a341:	c4 a1 78 11 04 32    	vmovups XMMWORD PTR [rdx+r14*1],xmm0
    b.* = tmp;
  21a347:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  21a34c:	c4 a1 7a 7f 04 0a    	vmovdqu XMMWORD PTR [rdx+r9*1],xmm0
  21a352:	4c 8b 9c 24 78 01 00 	mov    r11,QWORD PTR [rsp+0x178]
  21a359:	00 
  21a35a:	48 8b b4 24 80 01 00 	mov    rsi,QWORD PTR [rsp+0x180]
  21a361:	00 
        return self.end - self.start;
  21a362:	49 89 f1             	mov    r9,rsi
  21a365:	4d 29 d9             	sub    r9,r11
                                if (lastA.length() <= cache.len) {
  21a368:	49 81 f9 00 02 00 00 	cmp    r9,0x200
  21a36f:	4c 89 44 24 18       	mov    QWORD PTR [rsp+0x18],r8
  21a374:	0f 87 f6 00 00 00    	ja     21a470 <Benchmark_reportStats+0x3d30>
  21a37a:	4d 89 d8             	mov    r8,r11
    if (B.length() > 0 and A.length() > 0) {
  21a37d:	49 39 f5             	cmp    r13,rsi
  21a380:	0f 84 27 02 00 00    	je     21a5ad <Benchmark_reportStats+0x3e6d>
  21a386:	41 bf 00 00 00 00    	mov    r15d,0x0
  21a38c:	4d 85 c9             	test   r9,r9
  21a38f:	0f 84 1b 02 00 00    	je     21a5b0 <Benchmark_reportStats+0x3e70>
            if (!lessThan(items[B_index], cache[A_index])) {
  21a395:	4c 89 d9             	mov    rcx,r11
  21a398:	48 29 f1             	sub    rcx,rsi
  21a39b:	4d 89 d8             	mov    r8,r11
  21a39e:	48 89 74 24 68       	mov    QWORD PTR [rsp+0x68],rsi
  21a3a3:	49 89 f2             	mov    r10,rsi
  21a3a6:	31 f6                	xor    esi,esi
  21a3a8:	48 89 8c 24 28 01 00 	mov    QWORD PTR [rsp+0x128],rcx
  21a3af:	00 
  21a3b0:	4c 89 c7             	mov    rdi,r8
  21a3b3:	48 c1 e7 04          	shl    rdi,0x4
  21a3b7:	48 8d 04 31          	lea    rax,[rcx+rsi*1]
  21a3bb:	48 89 b4 24 50 01 00 	mov    QWORD PTR [rsp+0x150],rsi
  21a3c2:	00 
  21a3c3:	48 89 f1             	mov    rcx,rsi
  21a3c6:	48 c1 e1 04          	shl    rcx,0x4
  21a3ca:	48 8d 34 0c          	lea    rsi,[rsp+rcx*1]
  21a3ce:	48 81 c6 28 02 00 00 	add    rsi,0x228
  21a3d5:	31 d2                	xor    edx,edx
  21a3d7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  21a3de:	00 00 
  21a3e0:	48 8b 5c 24 40       	mov    rbx,QWORD PTR [rsp+0x40]
  21a3e5:	4c 89 d1             	mov    rcx,r10
  21a3e8:	48 c1 e1 04          	shl    rcx,0x4
  21a3ec:	4c 8b 3c 0b          	mov    r15,QWORD PTR [rbx+rcx*1]
  21a3f0:	4c 3b 3e             	cmp    r15,QWORD PTR [rsi]
  21a3f3:	72 2b                	jb     21a420 <Benchmark_reportStats+0x3ce0>
                items[insert_index] = cache[A_index];
  21a3f5:	c5 fa 6f 06          	vmovdqu xmm0,XMMWORD PTR [rsi]
  21a3f9:	c5 fa 7f 04 3b       	vmovdqu XMMWORD PTR [rbx+rdi*1],xmm0
                if (A_index == A_last) break;
  21a3fe:	48 83 c2 ff          	add    rdx,0xffffffffffffffff
  21a402:	48 83 c7 10          	add    rdi,0x10
  21a406:	48 83 c6 10          	add    rsi,0x10
  21a40a:	48 39 d0             	cmp    rax,rdx
  21a40d:	75 d1                	jne    21a3e0 <Benchmark_reportStats+0x3ca0>
  21a40f:	e9 8c 01 00 00       	jmp    21a5a0 <Benchmark_reportStats+0x3e60>
  21a414:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21a41b:	00 00 00 00 00 
  21a420:	48 01 d9             	add    rcx,rbx
                items[insert_index] = items[B_index];
  21a423:	c5 fa 6f 01          	vmovdqu xmm0,XMMWORD PTR [rcx]
  21a427:	c5 fa 7f 04 3b       	vmovdqu XMMWORD PTR [rbx+rdi*1],xmm0
                B_index += 1;
  21a42c:	49 83 c2 01          	add    r10,0x1
                if (B_index == B_last) break;
  21a430:	4c 89 c0             	mov    rax,r8
  21a433:	48 83 c0 01          	add    rax,0x1
  21a437:	49 89 c0             	mov    r8,rax
  21a43a:	49 29 d0             	sub    r8,rdx
  21a43d:	4c 8b bc 24 50 01 00 	mov    r15,QWORD PTR [rsp+0x150]
  21a444:	00 
  21a445:	4c 89 fe             	mov    rsi,r15
  21a448:	48 29 d6             	sub    rsi,rdx
  21a44b:	4d 39 ea             	cmp    r10,r13
  21a44e:	48 8b 8c 24 28 01 00 	mov    rcx,QWORD PTR [rsp+0x128]
  21a455:	00 
  21a456:	0f 85 54 ff ff ff    	jne    21a3b0 <Benchmark_reportStats+0x3c70>
    mem.copy(T, items[insert_index..], cache[A_index..A_last]);
  21a45c:	48 29 d0             	sub    rax,rdx
  21a45f:	49 29 d7             	sub    r15,rdx
  21a462:	49 89 c0             	mov    r8,rax
  21a465:	e9 3c 01 00 00       	jmp    21a5a6 <Benchmark_reportStats+0x3e66>
  21a46a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  21a470:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
  21a475:	48 39 44 24 50       	cmp    QWORD PTR [rsp+0x50],rax
                                } else if (buffer2.length() > 0) {
  21a47a:	75 34                	jne    21a4b0 <Benchmark_reportStats+0x3d70>
        return Range{
  21a47c:	48 89 b4 24 18 02 00 	mov    QWORD PTR [rsp+0x218],rsi
  21a483:	00 
  21a484:	4c 89 ac 24 20 02 00 	mov    QWORD PTR [rsp+0x220],r13
  21a48b:	00 
                                    mergeInPlace(T, items, lastA, Range.init(lastA.end, B_split), lessThan);
  21a48c:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  21a491:	48 8d b4 24 78 01 00 	lea    rsi,[rsp+0x178]
  21a498:	00 
  21a499:	48 8d 94 24 18 02 00 	lea    rdx,[rsp+0x218]
  21a4a0:	00 
  21a4a1:	c5 f8 77             	vzeroupper 
  21a4a4:	e8 97 4f 00 00       	call   21f440 <mergeInPlace>
  21a4a9:	e9 c2 03 00 00       	jmp    21a870 <Benchmark_reportStats+0x4130>
  21a4ae:	66 90                	xchg   ax,ax
    if (B.length() > 0 and A.length() > 0) {
  21a4b0:	4d 89 ef             	mov    r15,r13
  21a4b3:	49 29 f7             	sub    r15,rsi
  21a4b6:	0f 84 c0 fb ff ff    	je     21a07c <Benchmark_reportStats+0x393c>
  21a4bc:	41 ba 00 00 00 00    	mov    r10d,0x0
  21a4c2:	bf 00 00 00 00       	mov    edi,0x0
  21a4c7:	4c 39 de             	cmp    rsi,r11
  21a4ca:	0f 84 16 02 00 00    	je     21a6e6 <Benchmark_reportStats+0x3fa6>
  21a4d0:	45 31 d2             	xor    r10d,r10d
  21a4d3:	31 c9                	xor    ecx,ecx
  21a4d5:	31 c0                	xor    eax,eax
  21a4d7:	4c 89 9c 24 48 01 00 	mov    QWORD PTR [rsp+0x148],r11
  21a4de:	00 
  21a4df:	48 89 74 24 68       	mov    QWORD PTR [rsp+0x68],rsi
  21a4e4:	48 8b 54 24 60       	mov    rdx,QWORD PTR [rsp+0x60]
  21a4e9:	4d 8d 04 12          	lea    r8,[r10+rdx*1]
            if (!lessThan(items[B.start + B_count], items[buffer.start + A_count])) {
  21a4ed:	48 8d 1c 0e          	lea    rbx,[rsi+rcx*1]
  21a4f1:	48 c1 e3 04          	shl    rbx,0x4
  21a4f5:	49 8d 14 03          	lea    rdx,[r11+rax*1]
  21a4f9:	48 c1 e2 04          	shl    rdx,0x4
  21a4fd:	48 89 c7             	mov    rdi,rax
  21a500:	48 8b 44 24 40       	mov    rax,QWORD PTR [rsp+0x40]
  21a505:	4c 89 c6             	mov    rsi,r8
  21a508:	48 c1 e6 04          	shl    rsi,0x4
  21a50c:	4c 8b 1c 18          	mov    r11,QWORD PTR [rax+rbx*1]
  21a510:	4c 3b 1c 30          	cmp    r11,QWORD PTR [rax+rsi*1]
  21a514:	73 3a                	jae    21a550 <Benchmark_reportStats+0x3e10>
    const tmp = a.*;
  21a516:	c5 f8 10 04 10       	vmovups xmm0,XMMWORD PTR [rax+rdx*1]
  21a51b:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21a520:	c5 f8 10 04 18       	vmovups xmm0,XMMWORD PTR [rax+rbx*1]
  21a525:	c5 f8 11 04 10       	vmovups XMMWORD PTR [rax+rdx*1],xmm0
    b.* = tmp;
  21a52a:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  21a52f:	c5 fa 7f 04 18       	vmovdqu XMMWORD PTR [rax+rbx*1],xmm0
                B_count += 1;
  21a534:	48 83 c1 01          	add    rcx,0x1
                insert += 1;
  21a538:	48 83 c7 01          	add    rdi,0x1
                if (B_count >= B.length()) break;
  21a53c:	48 83 c3 10          	add    rbx,0x10
  21a540:	48 83 c2 10          	add    rdx,0x10
  21a544:	4c 39 f9             	cmp    rcx,r15
  21a547:	72 b7                	jb     21a500 <Benchmark_reportStats+0x3dc0>
  21a549:	e9 8b 01 00 00       	jmp    21a6d9 <Benchmark_reportStats+0x3f99>
  21a54e:	66 90                	xchg   ax,ax
    const tmp = a.*;
  21a550:	c5 f8 10 04 10       	vmovups xmm0,XMMWORD PTR [rax+rdx*1]
  21a555:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
  21a55a:	48 01 c6             	add    rsi,rax
    a.* = b.*;
  21a55d:	c5 f8 10 06          	vmovups xmm0,XMMWORD PTR [rsi]
  21a561:	c5 f8 11 04 10       	vmovups XMMWORD PTR [rax+rdx*1],xmm0
    b.* = tmp;
  21a566:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  21a56b:	c5 fa 7f 06          	vmovdqu XMMWORD PTR [rsi],xmm0
                A_count += 1;
  21a56f:	49 83 c2 01          	add    r10,0x1
                if (A_count >= A.length()) break;
  21a573:	48 8d 47 01          	lea    rax,[rdi+0x1]
  21a577:	4d 39 ca             	cmp    r10,r9
  21a57a:	4c 8b 9c 24 48 01 00 	mov    r11,QWORD PTR [rsp+0x148]
  21a581:	00 
  21a582:	48 8b 74 24 68       	mov    rsi,QWORD PTR [rsp+0x68]
  21a587:	0f 82 57 ff ff ff    	jb     21a4e4 <Benchmark_reportStats+0x3da4>
    blockSwap(T, items, buffer.start + A_count, A.start + insert, A.length() - A_count);
  21a58d:	48 83 c7 01          	add    rdi,0x1
    while (index < block_size) : (index += 1) {
  21a591:	4d 29 d1             	sub    r9,r10
  21a594:	0f 85 55 01 00 00    	jne    21a6ef <Benchmark_reportStats+0x3faf>
  21a59a:	e9 d1 02 00 00       	jmp    21a870 <Benchmark_reportStats+0x4130>
  21a59f:	90                   	nop
    mem.copy(T, items[insert_index..], cache[A_index..A_last]);
  21a5a0:	49 29 d0             	sub    r8,rdx
  21a5a3:	4d 89 cf             	mov    r15,r9
  21a5a6:	48 8b 74 24 68       	mov    rsi,QWORD PTR [rsp+0x68]
  21a5ab:	eb 03                	jmp    21a5b0 <Benchmark_reportStats+0x3e70>
  21a5ad:	45 31 ff             	xor    r15d,r15d
  21a5b0:	48 8b 44 24 48       	mov    rax,QWORD PTR [rsp+0x48]
  21a5b5:	4c 29 c0             	sub    rax,r8
  21a5b8:	4d 29 f9             	sub    r9,r15
    assert(dest.len >= source.len);
  21a5bb:	4c 39 c8             	cmp    rax,r9
  21a5be:	0f 82 e8 4c 00 00    	jb     21f2ac <Benchmark_reportStats+0x8b6c>
    for (source) |s, i|
  21a5c4:	4d 85 c9             	test   r9,r9
  21a5c7:	0f 84 a3 02 00 00    	je     21a870 <Benchmark_reportStats+0x4130>
  21a5cd:	48 8b 44 24 40       	mov    rax,QWORD PTR [rsp+0x40]
  21a5d2:	48 83 c6 ff          	add    rsi,0xffffffffffffffff
  21a5d6:	4c 29 fe             	sub    rsi,r15
  21a5d9:	4c 29 de             	sub    rsi,r11
  21a5dc:	44 89 c9             	mov    ecx,r9d
  21a5df:	83 e1 07             	and    ecx,0x7
  21a5e2:	48 83 fe 07          	cmp    rsi,0x7
  21a5e6:	73 10                	jae    21a5f8 <Benchmark_reportStats+0x3eb8>
  21a5e8:	31 d2                	xor    edx,edx
  21a5ea:	48 85 c9             	test   rcx,rcx
  21a5ed:	0f 85 a1 00 00 00    	jne    21a694 <Benchmark_reportStats+0x3f54>
  21a5f3:	e9 78 02 00 00       	jmp    21a870 <Benchmark_reportStats+0x4130>
  21a5f8:	4c 89 c7             	mov    rdi,r8
  21a5fb:	48 c1 e7 04          	shl    rdi,0x4
  21a5ff:	48 01 c7             	add    rdi,rax
  21a602:	49 29 c9             	sub    r9,rcx
  21a605:	4c 89 fa             	mov    rdx,r15
  21a608:	48 c1 e2 04          	shl    rdx,0x4
  21a60c:	48 8d 34 14          	lea    rsi,[rsp+rdx*1]
  21a610:	48 81 c6 28 02 00 00 	add    rsi,0x228
  21a617:	bb 70 00 00 00       	mov    ebx,0x70
  21a61c:	31 d2                	xor    edx,edx
  21a61e:	66 90                	xchg   ax,ax
        dest[i] = s;
  21a620:	c5 f8 10 44 1e 90    	vmovups xmm0,XMMWORD PTR [rsi+rbx*1-0x70]
  21a626:	c5 f8 11 44 1f 90    	vmovups XMMWORD PTR [rdi+rbx*1-0x70],xmm0
  21a62c:	c5 f8 10 44 1e a0    	vmovups xmm0,XMMWORD PTR [rsi+rbx*1-0x60]
  21a632:	c5 f8 11 44 1f a0    	vmovups XMMWORD PTR [rdi+rbx*1-0x60],xmm0
  21a638:	c5 f8 10 44 1e b0    	vmovups xmm0,XMMWORD PTR [rsi+rbx*1-0x50]
  21a63e:	c5 f8 11 44 1f b0    	vmovups XMMWORD PTR [rdi+rbx*1-0x50],xmm0
  21a644:	c5 f8 10 44 1e c0    	vmovups xmm0,XMMWORD PTR [rsi+rbx*1-0x40]
  21a64a:	c5 f8 11 44 1f c0    	vmovups XMMWORD PTR [rdi+rbx*1-0x40],xmm0
  21a650:	c5 f8 10 44 1e d0    	vmovups xmm0,XMMWORD PTR [rsi+rbx*1-0x30]
  21a656:	c5 f8 11 44 1f d0    	vmovups XMMWORD PTR [rdi+rbx*1-0x30],xmm0
  21a65c:	c5 f8 10 44 1e e0    	vmovups xmm0,XMMWORD PTR [rsi+rbx*1-0x20]
  21a662:	c5 f8 11 44 1f e0    	vmovups XMMWORD PTR [rdi+rbx*1-0x20],xmm0
  21a668:	c5 f8 10 44 1e f0    	vmovups xmm0,XMMWORD PTR [rsi+rbx*1-0x10]
  21a66e:	c5 f8 11 44 1f f0    	vmovups XMMWORD PTR [rdi+rbx*1-0x10],xmm0
  21a674:	c5 fa 6f 04 1e       	vmovdqu xmm0,XMMWORD PTR [rsi+rbx*1]
  21a679:	c5 fa 7f 04 1f       	vmovdqu XMMWORD PTR [rdi+rbx*1],xmm0
    for (source) |s, i|
  21a67e:	48 83 c2 08          	add    rdx,0x8
  21a682:	48 83 eb 80          	sub    rbx,0xffffffffffffff80
  21a686:	49 39 d1             	cmp    r9,rdx
  21a689:	75 95                	jne    21a620 <Benchmark_reportStats+0x3ee0>
  21a68b:	48 85 c9             	test   rcx,rcx
  21a68e:	0f 84 dc 01 00 00    	je     21a870 <Benchmark_reportStats+0x4130>
  21a694:	49 01 d0             	add    r8,rdx
  21a697:	49 c1 e0 04          	shl    r8,0x4
  21a69b:	4c 01 c0             	add    rax,r8
  21a69e:	49 01 d7             	add    r15,rdx
  21a6a1:	49 c1 e7 04          	shl    r15,0x4
  21a6a5:	4a 8d 14 3c          	lea    rdx,[rsp+r15*1]
  21a6a9:	48 81 c2 28 02 00 00 	add    rdx,0x228
  21a6b0:	48 f7 d9             	neg    rcx
  21a6b3:	31 f6                	xor    esi,esi
  21a6b5:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21a6bc:	00 00 00 00 
        dest[i] = s;
  21a6c0:	c5 fa 6f 04 32       	vmovdqu xmm0,XMMWORD PTR [rdx+rsi*1]
  21a6c5:	c5 fa 7f 04 30       	vmovdqu XMMWORD PTR [rax+rsi*1],xmm0
    for (source) |s, i|
  21a6ca:	48 83 c6 10          	add    rsi,0x10
  21a6ce:	48 83 c1 01          	add    rcx,0x1
  21a6d2:	75 ec                	jne    21a6c0 <Benchmark_reportStats+0x3f80>
  21a6d4:	e9 97 01 00 00       	jmp    21a870 <Benchmark_reportStats+0x4130>
  21a6d9:	4c 8b 9c 24 48 01 00 	mov    r11,QWORD PTR [rsp+0x148]
  21a6e0:	00 
  21a6e1:	48 8b 74 24 68       	mov    rsi,QWORD PTR [rsp+0x68]
    while (index < block_size) : (index += 1) {
  21a6e6:	4d 29 d1             	sub    r9,r10
  21a6e9:	0f 84 81 01 00 00    	je     21a870 <Benchmark_reportStats+0x4130>
        mem.swap(T, &items[start1 + index], &items[start2 + index]);
  21a6ef:	48 83 c6 ff          	add    rsi,0xffffffffffffffff
  21a6f3:	4c 29 d6             	sub    rsi,r10
  21a6f6:	4c 29 de             	sub    rsi,r11
  21a6f9:	44 89 c8             	mov    eax,r9d
  21a6fc:	83 e0 03             	and    eax,0x3
  21a6ff:	48 83 fe 03          	cmp    rsi,0x3
  21a703:	73 13                	jae    21a718 <Benchmark_reportStats+0x3fd8>
  21a705:	4d 89 df             	mov    r15,r11
  21a708:	31 db                	xor    ebx,ebx
    while (index < block_size) : (index += 1) {
  21a70a:	48 85 c0             	test   rax,rax
  21a70d:	0f 85 f7 00 00 00    	jne    21a80a <Benchmark_reportStats+0x40ca>
  21a713:	e9 58 01 00 00       	jmp    21a870 <Benchmark_reportStats+0x4130>
        mem.swap(T, &items[start1 + index], &items[start2 + index]);
  21a718:	49 29 c1             	sub    r9,rax
  21a71b:	4d 89 d0             	mov    r8,r10
  21a71e:	49 c1 e0 04          	shl    r8,0x4
  21a722:	4c 03 84 24 18 01 00 	add    r8,QWORD PTR [rsp+0x118]
  21a729:	00 
  21a72a:	48 89 fe             	mov    rsi,rdi
  21a72d:	48 c1 e6 04          	shl    rsi,0x4
  21a731:	4d 89 df             	mov    r15,r11
  21a734:	49 c1 e3 04          	shl    r11,0x4
  21a738:	49 01 f3             	add    r11,rsi
  21a73b:	31 f6                	xor    esi,esi
  21a73d:	31 db                	xor    ebx,ebx
  21a73f:	90                   	nop
  21a740:	48 8b 4c 24 40       	mov    rcx,QWORD PTR [rsp+0x40]
    const tmp = a.*;
  21a745:	4a 8d 14 01          	lea    rdx,[rcx+r8*1]
  21a749:	c5 f8 10 04 16       	vmovups xmm0,XMMWORD PTR [rsi+rdx*1]
  21a74e:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21a753:	4c 01 d9             	add    rcx,r11
  21a756:	c5 f8 10 04 0e       	vmovups xmm0,XMMWORD PTR [rsi+rcx*1]
  21a75b:	c5 f8 11 04 16       	vmovups XMMWORD PTR [rsi+rdx*1],xmm0
    b.* = tmp;
  21a760:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  21a765:	c5 f8 11 04 0e       	vmovups XMMWORD PTR [rsi+rcx*1],xmm0
  21a76a:	48 8b 4c 24 40       	mov    rcx,QWORD PTR [rsp+0x40]
    const tmp = a.*;
  21a76f:	4a 8d 14 01          	lea    rdx,[rcx+r8*1]
  21a773:	c5 f8 10 44 16 10    	vmovups xmm0,XMMWORD PTR [rsi+rdx*1+0x10]
  21a779:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21a77e:	4c 01 d9             	add    rcx,r11
  21a781:	c5 f8 10 44 0e 10    	vmovups xmm0,XMMWORD PTR [rsi+rcx*1+0x10]
  21a787:	c5 f8 11 44 16 10    	vmovups XMMWORD PTR [rsi+rdx*1+0x10],xmm0
    b.* = tmp;
  21a78d:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  21a792:	c5 f8 11 44 0e 10    	vmovups XMMWORD PTR [rsi+rcx*1+0x10],xmm0
  21a798:	48 8b 4c 24 40       	mov    rcx,QWORD PTR [rsp+0x40]
    const tmp = a.*;
  21a79d:	4a 8d 14 01          	lea    rdx,[rcx+r8*1]
  21a7a1:	c5 f8 10 44 16 20    	vmovups xmm0,XMMWORD PTR [rsi+rdx*1+0x20]
  21a7a7:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21a7ac:	4c 01 d9             	add    rcx,r11
  21a7af:	c5 f8 10 44 0e 20    	vmovups xmm0,XMMWORD PTR [rsi+rcx*1+0x20]
  21a7b5:	c5 f8 11 44 16 20    	vmovups XMMWORD PTR [rsi+rdx*1+0x20],xmm0
    b.* = tmp;
  21a7bb:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  21a7c0:	c5 f8 11 44 0e 20    	vmovups XMMWORD PTR [rsi+rcx*1+0x20],xmm0
  21a7c6:	48 8b 4c 24 40       	mov    rcx,QWORD PTR [rsp+0x40]
    const tmp = a.*;
  21a7cb:	4a 8d 14 01          	lea    rdx,[rcx+r8*1]
  21a7cf:	c5 f8 10 44 16 30    	vmovups xmm0,XMMWORD PTR [rsi+rdx*1+0x30]
  21a7d5:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21a7da:	4c 01 d9             	add    rcx,r11
  21a7dd:	c5 f8 10 44 0e 30    	vmovups xmm0,XMMWORD PTR [rsi+rcx*1+0x30]
  21a7e3:	c5 f8 11 44 16 30    	vmovups XMMWORD PTR [rsi+rdx*1+0x30],xmm0
    b.* = tmp;
  21a7e9:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  21a7ee:	c5 fa 7f 44 0e 30    	vmovdqu XMMWORD PTR [rsi+rcx*1+0x30],xmm0
    while (index < block_size) : (index += 1) {
  21a7f4:	48 83 c3 04          	add    rbx,0x4
  21a7f8:	48 83 c6 40          	add    rsi,0x40
  21a7fc:	49 39 d9             	cmp    r9,rbx
  21a7ff:	0f 85 3b ff ff ff    	jne    21a740 <Benchmark_reportStats+0x4000>
  21a805:	48 85 c0             	test   rax,rax
  21a808:	74 66                	je     21a870 <Benchmark_reportStats+0x4130>
  21a80a:	48 01 df             	add    rdi,rbx
  21a80d:	4c 01 ff             	add    rdi,r15
  21a810:	48 c1 e7 04          	shl    rdi,0x4
  21a814:	4c 03 54 24 60       	add    r10,QWORD PTR [rsp+0x60]
  21a819:	49 01 da             	add    r10,rbx
  21a81c:	49 c1 e2 04          	shl    r10,0x4
  21a820:	48 f7 d8             	neg    rax
  21a823:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21a82a:	84 00 00 00 00 00 
        mem.swap(T, &items[start1 + index], &items[start2 + index]);
  21a830:	48 8b 4c 24 40       	mov    rcx,QWORD PTR [rsp+0x40]
    const tmp = a.*;
  21a835:	c4 a1 78 10 04 11    	vmovups xmm0,XMMWORD PTR [rcx+r10*1]
  21a83b:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21a840:	c5 f8 10 04 39       	vmovups xmm0,XMMWORD PTR [rcx+rdi*1]
  21a845:	c4 a1 78 11 04 11    	vmovups XMMWORD PTR [rcx+r10*1],xmm0
    b.* = tmp;
  21a84b:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  21a850:	c5 fa 7f 04 39       	vmovdqu XMMWORD PTR [rcx+rdi*1],xmm0
    while (index < block_size) : (index += 1) {
  21a855:	48 83 c7 10          	add    rdi,0x10
  21a859:	49 83 c2 10          	add    r10,0x10
  21a85d:	48 83 c0 01          	add    rax,0x1
  21a861:	75 cd                	jne    21a830 <Benchmark_reportStats+0x40f0>
  21a863:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21a86a:	84 00 00 00 00 00 
  21a870:	48 8b 5c 24 38       	mov    rbx,QWORD PTR [rsp+0x38]
  21a875:	49 89 df             	mov    r15,rbx
  21a878:	4d 29 ef             	sub    r15,r13
                                if (buffer2.length() > 0 or block_size <= cache.len) {
  21a87b:	80 7c 24 78 00       	cmp    BYTE PTR [rsp+0x78],0x0
  21a880:	74 3e                	je     21a8c0 <Benchmark_reportStats+0x4180>
  21a882:	48 81 7c 24 28 01 02 	cmp    QWORD PTR [rsp+0x28],0x201
  21a889:	00 00 
  21a88b:	4c 8b 54 24 18       	mov    r10,QWORD PTR [rsp+0x18]
                                    if (block_size <= cache.len) {
  21a890:	0f 83 8a 00 00 00    	jae    21a920 <Benchmark_reportStats+0x41e0>
                                        mem.copy(T, cache[0..], items[blockA.start .. blockA.start + block_size]);
  21a896:	4c 03 74 24 40       	add    r14,QWORD PTR [rsp+0x40]
  21a89b:	48 83 7c 24 58 07    	cmp    QWORD PTR [rsp+0x58],0x7
    for (source) |s, i|
  21a8a1:	0f 83 04 02 00 00    	jae    21aaab <Benchmark_reportStats+0x436b>
  21a8a7:	31 c0                	xor    eax,eax
  21a8a9:	48 83 bc 24 20 01 00 	cmp    QWORD PTR [rsp+0x120],0x0
  21a8b0:	00 00 
  21a8b2:	0f 85 b5 02 00 00    	jne    21ab6d <Benchmark_reportStats+0x442d>
  21a8b8:	e9 3c 04 00 00       	jmp    21acf9 <Benchmark_reportStats+0x45b9>
  21a8bd:	0f 1f 00             	nop    DWORD PTR [rax]
  21a8c0:	4c 89 7c 24 38       	mov    QWORD PTR [rsp+0x38],r15
                                    mem.rotate(T, items[B_split .. blockA.start + block_size], blockA.start - B_split);
  21a8c5:	4c 8b 5c 24 40       	mov    r11,QWORD PTR [rsp+0x40]
  21a8ca:	4c 89 ea             	mov    rdx,r13
  21a8cd:	48 c1 e2 04          	shl    rdx,0x4
  21a8d1:	4d 8d 0c 13          	lea    r9,[r11+rdx*1]
  21a8d5:	4c 8b 54 24 18       	mov    r10,QWORD PTR [rsp+0x18]
  21a8da:	4d 89 d0             	mov    r8,r10
  21a8dd:	4d 29 e8             	sub    r8,r13
  21a8e0:	4d 89 e7             	mov    r15,r12
  21a8e3:	4d 29 ef             	sub    r15,r13
    const end = items.len / 2;
  21a8e6:	4c 89 fb             	mov    rbx,r15
  21a8e9:	48 d1 eb             	shr    rbx,1
    while (i < end) : (i += 1) {
  21a8ec:	0f 84 77 01 00 00    	je     21aa69 <Benchmark_reportStats+0x4329>
        swap(T, &items[i], &items[items.len - i - 1]);
  21a8f2:	48 8d 4b ff          	lea    rcx,[rbx-0x1]
  21a8f6:	89 d8                	mov    eax,ebx
  21a8f8:	83 e0 03             	and    eax,0x3
  21a8fb:	48 83 f9 03          	cmp    rcx,0x3
  21a8ff:	73 3e                	jae    21a93f <Benchmark_reportStats+0x41ff>
  21a901:	31 f6                	xor    esi,esi
    while (i < end) : (i += 1) {
  21a903:	48 85 c0             	test   rax,rax
  21a906:	0f 85 19 01 00 00    	jne    21aa25 <Benchmark_reportStats+0x42e5>
  21a90c:	e9 58 01 00 00       	jmp    21aa69 <Benchmark_reportStats+0x4329>
  21a911:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21a918:	0f 1f 84 00 00 00 00 
  21a91f:	00 
  21a920:	48 83 7c 24 58 03    	cmp    QWORD PTR [rsp+0x58],0x3
        mem.swap(T, &items[start1 + index], &items[start2 + index]);
  21a926:	0f 83 88 02 00 00    	jae    21abb4 <Benchmark_reportStats+0x4474>
  21a92c:	31 c0                	xor    eax,eax
  21a92e:	48 83 7c 24 10 00    	cmp    QWORD PTR [rsp+0x10],0x0
    while (index < block_size) : (index += 1) {
  21a934:	0f 85 74 03 00 00    	jne    21acae <Benchmark_reportStats+0x456e>
  21a93a:	e9 ba 03 00 00       	jmp    21acf9 <Benchmark_reportStats+0x45b9>
        swap(T, &items[i], &items[items.len - i - 1]);
  21a93f:	48 29 c3             	sub    rbx,rax
  21a942:	49 8d 0c 13          	lea    rcx,[r11+rdx*1]
  21a946:	48 83 c1 30          	add    rcx,0x30
  21a94a:	31 f6                	xor    esi,esi
  21a94c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  21a950:	48 89 f7             	mov    rdi,rsi
  21a953:	48 f7 d7             	not    rdi
  21a956:	4c 01 ff             	add    rdi,r15
  21a959:	48 c1 e7 04          	shl    rdi,0x4
    const tmp = a.*;
  21a95d:	c5 f8 10 41 d0       	vmovups xmm0,XMMWORD PTR [rcx-0x30]
  21a962:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21a967:	c4 c1 78 10 04 39    	vmovups xmm0,XMMWORD PTR [r9+rdi*1]
  21a96d:	c5 f8 11 41 d0       	vmovups XMMWORD PTR [rcx-0x30],xmm0
    b.* = tmp;
  21a972:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  21a977:	c4 c1 78 11 04 39    	vmovups XMMWORD PTR [r9+rdi*1],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  21a97d:	48 c7 c7 fe ff ff ff 	mov    rdi,0xfffffffffffffffe
  21a984:	48 29 f7             	sub    rdi,rsi
  21a987:	4c 01 ff             	add    rdi,r15
    const tmp = a.*;
  21a98a:	c5 f8 10 41 e0       	vmovups xmm0,XMMWORD PTR [rcx-0x20]
  21a98f:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  21a994:	48 c1 e7 04          	shl    rdi,0x4
    a.* = b.*;
  21a998:	c4 c1 78 10 04 39    	vmovups xmm0,XMMWORD PTR [r9+rdi*1]
  21a99e:	c5 f8 11 41 e0       	vmovups XMMWORD PTR [rcx-0x20],xmm0
    b.* = tmp;
  21a9a3:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  21a9a8:	c4 c1 78 11 04 39    	vmovups XMMWORD PTR [r9+rdi*1],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  21a9ae:	48 c7 c7 fd ff ff ff 	mov    rdi,0xfffffffffffffffd
  21a9b5:	48 29 f7             	sub    rdi,rsi
  21a9b8:	4c 01 ff             	add    rdi,r15
  21a9bb:	48 c1 e7 04          	shl    rdi,0x4
    const tmp = a.*;
  21a9bf:	c5 f8 10 41 f0       	vmovups xmm0,XMMWORD PTR [rcx-0x10]
  21a9c4:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21a9c9:	c4 c1 78 10 04 39    	vmovups xmm0,XMMWORD PTR [r9+rdi*1]
  21a9cf:	c5 f8 11 41 f0       	vmovups XMMWORD PTR [rcx-0x10],xmm0
    b.* = tmp;
  21a9d4:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  21a9d9:	c4 c1 78 11 04 39    	vmovups XMMWORD PTR [r9+rdi*1],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  21a9df:	48 c7 c7 fc ff ff ff 	mov    rdi,0xfffffffffffffffc
  21a9e6:	48 29 f7             	sub    rdi,rsi
  21a9e9:	4c 01 ff             	add    rdi,r15
    const tmp = a.*;
  21a9ec:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  21a9f0:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  21a9f5:	48 c1 e7 04          	shl    rdi,0x4
    a.* = b.*;
  21a9f9:	c4 c1 78 10 04 39    	vmovups xmm0,XMMWORD PTR [r9+rdi*1]
  21a9ff:	c5 f8 11 01          	vmovups XMMWORD PTR [rcx],xmm0
    b.* = tmp;
  21aa03:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  21aa08:	c4 c1 7a 7f 04 39    	vmovdqu XMMWORD PTR [r9+rdi*1],xmm0
    while (i < end) : (i += 1) {
  21aa0e:	48 83 c6 04          	add    rsi,0x4
  21aa12:	48 83 c1 40          	add    rcx,0x40
  21aa16:	48 83 c3 fc          	add    rbx,0xfffffffffffffffc
  21aa1a:	0f 85 30 ff ff ff    	jne    21a950 <Benchmark_reportStats+0x4210>
  21aa20:	48 85 c0             	test   rax,rax
  21aa23:	74 44                	je     21aa69 <Benchmark_reportStats+0x4329>
  21aa25:	4a 8d 0c 2e          	lea    rcx,[rsi+r13*1]
  21aa29:	48 c1 e1 04          	shl    rcx,0x4
  21aa2d:	4c 01 d9             	add    rcx,r11
        swap(T, &items[i], &items[items.len - i - 1]);
  21aa30:	48 89 f7             	mov    rdi,rsi
  21aa33:	48 f7 d7             	not    rdi
  21aa36:	4c 01 ff             	add    rdi,r15
    const tmp = a.*;
  21aa39:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  21aa3d:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  21aa42:	48 c1 e7 04          	shl    rdi,0x4
    a.* = b.*;
  21aa46:	c4 c1 78 10 04 39    	vmovups xmm0,XMMWORD PTR [r9+rdi*1]
  21aa4c:	c5 f8 11 01          	vmovups XMMWORD PTR [rcx],xmm0
    b.* = tmp;
  21aa50:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  21aa55:	c4 c1 7a 7f 04 39    	vmovdqu XMMWORD PTR [r9+rdi*1],xmm0
    while (i < end) : (i += 1) {
  21aa5b:	48 83 c6 01          	add    rsi,0x1
  21aa5f:	48 83 c1 10          	add    rcx,0x10
  21aa63:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  21aa67:	75 c7                	jne    21aa30 <Benchmark_reportStats+0x42f0>
  21aa69:	48 89 54 24 68       	mov    QWORD PTR [rsp+0x68],rdx
    reverse(T, items[amount..]);
  21aa6e:	4d 89 c2             	mov    r10,r8
  21aa71:	4d 29 fa             	sub    r10,r15
    while (i < end) : (i += 1) {
  21aa74:	49 83 fa 02          	cmp    r10,0x2
  21aa78:	4c 8b 7c 24 38       	mov    r15,QWORD PTR [rsp+0x38]
  21aa7d:	0f 82 5d 05 00 00    	jb     21afe0 <Benchmark_reportStats+0x48a0>
  21aa83:	4d 01 de             	add    r14,r11
  21aa86:	48 83 bc 24 70 01 00 	cmp    QWORD PTR [rsp+0x170],0x3
  21aa8d:	00 03 
        swap(T, &items[i], &items[items.len - i - 1]);
  21aa8f:	0f 83 eb 03 00 00    	jae    21ae80 <Benchmark_reportStats+0x4740>
  21aa95:	31 ff                	xor    edi,edi
  21aa97:	48 83 bc 24 40 01 00 	cmp    QWORD PTR [rsp+0x140],0x0
  21aa9e:	00 00 
    while (i < end) : (i += 1) {
  21aaa0:	0f 85 e4 04 00 00    	jne    21af8a <Benchmark_reportStats+0x484a>
  21aaa6:	e9 35 05 00 00       	jmp    21afe0 <Benchmark_reportStats+0x48a0>
  21aaab:	48 8d 8c 24 98 02 00 	lea    rcx,[rsp+0x298]
  21aab2:	00 
  21aab3:	31 c0                	xor    eax,eax
  21aab5:	48 8b 94 24 60 01 00 	mov    rdx,QWORD PTR [rsp+0x160]
  21aabc:	00 
  21aabd:	0f 1f 00             	nop    DWORD PTR [rax]
    for (source) |s, i|
  21aac0:	48 89 c6             	mov    rsi,rax
  21aac3:	48 c1 e6 04          	shl    rsi,0x4
        dest[i] = s;
  21aac7:	c4 c1 78 10 04 36    	vmovups xmm0,XMMWORD PTR [r14+rsi*1]
  21aacd:	c5 f8 11 41 90       	vmovups XMMWORD PTR [rcx-0x70],xmm0
    for (source) |s, i|
  21aad2:	48 89 f7             	mov    rdi,rsi
  21aad5:	48 83 cf 10          	or     rdi,0x10
        dest[i] = s;
  21aad9:	c4 c1 78 10 04 3e    	vmovups xmm0,XMMWORD PTR [r14+rdi*1]
  21aadf:	c5 f8 11 41 a0       	vmovups XMMWORD PTR [rcx-0x60],xmm0
    for (source) |s, i|
  21aae4:	48 89 f7             	mov    rdi,rsi
  21aae7:	48 83 cf 20          	or     rdi,0x20
        dest[i] = s;
  21aaeb:	c4 c1 78 10 04 3e    	vmovups xmm0,XMMWORD PTR [r14+rdi*1]
  21aaf1:	c5 f8 11 41 b0       	vmovups XMMWORD PTR [rcx-0x50],xmm0
    for (source) |s, i|
  21aaf6:	48 89 f7             	mov    rdi,rsi
  21aaf9:	48 83 cf 30          	or     rdi,0x30
        dest[i] = s;
  21aafd:	c4 c1 78 10 04 3e    	vmovups xmm0,XMMWORD PTR [r14+rdi*1]
  21ab03:	c5 f8 11 41 c0       	vmovups XMMWORD PTR [rcx-0x40],xmm0
    for (source) |s, i|
  21ab08:	48 89 f7             	mov    rdi,rsi
  21ab0b:	48 83 cf 40          	or     rdi,0x40
        dest[i] = s;
  21ab0f:	c4 c1 78 10 04 3e    	vmovups xmm0,XMMWORD PTR [r14+rdi*1]
  21ab15:	c5 f8 11 41 d0       	vmovups XMMWORD PTR [rcx-0x30],xmm0
    for (source) |s, i|
  21ab1a:	48 89 f7             	mov    rdi,rsi
  21ab1d:	48 83 cf 50          	or     rdi,0x50
        dest[i] = s;
  21ab21:	c4 c1 78 10 04 3e    	vmovups xmm0,XMMWORD PTR [r14+rdi*1]
  21ab27:	c5 f8 11 41 e0       	vmovups XMMWORD PTR [rcx-0x20],xmm0
    for (source) |s, i|
  21ab2c:	48 89 f7             	mov    rdi,rsi
  21ab2f:	48 83 cf 60          	or     rdi,0x60
        dest[i] = s;
  21ab33:	c4 c1 78 10 04 3e    	vmovups xmm0,XMMWORD PTR [r14+rdi*1]
  21ab39:	c5 f8 11 41 f0       	vmovups XMMWORD PTR [rcx-0x10],xmm0
    for (source) |s, i|
  21ab3e:	48 83 ce 70          	or     rsi,0x70
        dest[i] = s;
  21ab42:	c4 c1 7a 6f 04 36    	vmovdqu xmm0,XMMWORD PTR [r14+rsi*1]
  21ab48:	c5 fa 7f 01          	vmovdqu XMMWORD PTR [rcx],xmm0
    for (source) |s, i|
  21ab4c:	48 83 c0 08          	add    rax,0x8
  21ab50:	48 83 e9 80          	sub    rcx,0xffffffffffffff80
  21ab54:	48 83 c2 f8          	add    rdx,0xfffffffffffffff8
  21ab58:	0f 85 62 ff ff ff    	jne    21aac0 <Benchmark_reportStats+0x4380>
  21ab5e:	48 83 bc 24 20 01 00 	cmp    QWORD PTR [rsp+0x120],0x0
  21ab65:	00 00 
  21ab67:	0f 84 8c 01 00 00    	je     21acf9 <Benchmark_reportStats+0x45b9>
  21ab6d:	48 89 c1             	mov    rcx,rax
  21ab70:	48 c1 e1 04          	shl    rcx,0x4
  21ab74:	48 01 e1             	add    rcx,rsp
  21ab77:	48 81 c1 28 02 00 00 	add    rcx,0x228
  21ab7e:	48 8b 94 24 20 01 00 	mov    rdx,QWORD PTR [rsp+0x120]
  21ab85:	00 
  21ab86:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  21ab8d:	00 00 00 
  21ab90:	48 89 c6             	mov    rsi,rax
  21ab93:	48 c1 e6 04          	shl    rsi,0x4
        dest[i] = s;
  21ab97:	c4 c1 7a 6f 04 36    	vmovdqu xmm0,XMMWORD PTR [r14+rsi*1]
  21ab9d:	c5 fa 7f 01          	vmovdqu XMMWORD PTR [rcx],xmm0
    for (source) |s, i|
  21aba1:	48 83 c0 01          	add    rax,0x1
  21aba5:	48 83 c1 10          	add    rcx,0x10
  21aba9:	48 83 c2 ff          	add    rdx,0xffffffffffffffff
  21abad:	75 e1                	jne    21ab90 <Benchmark_reportStats+0x4450>
  21abaf:	e9 45 01 00 00       	jmp    21acf9 <Benchmark_reportStats+0x45b9>
  21abb4:	48 8b 8c 24 58 01 00 	mov    rcx,QWORD PTR [rsp+0x158]
  21abbb:	00 
  21abbc:	31 c0                	xor    eax,eax
  21abbe:	48 8b 94 24 10 01 00 	mov    rdx,QWORD PTR [rsp+0x110]
  21abc5:	00 
  21abc6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  21abcd:	00 00 00 
        mem.swap(T, &items[start1 + index], &items[start2 + index]);
  21abd0:	4a 8d 34 20          	lea    rsi,[rax+r12*1]
  21abd4:	48 8b 7c 24 40       	mov    rdi,QWORD PTR [rsp+0x40]
  21abd9:	48 c1 e6 04          	shl    rsi,0x4
    const tmp = a.*;
  21abdd:	c5 f8 10 04 37       	vmovups xmm0,XMMWORD PTR [rdi+rsi*1]
  21abe2:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21abe7:	c5 f8 10 44 0f e0    	vmovups xmm0,XMMWORD PTR [rdi+rcx*1-0x20]
  21abed:	c5 f8 11 04 37       	vmovups XMMWORD PTR [rdi+rsi*1],xmm0
    b.* = tmp;
  21abf2:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  21abf7:	c5 f8 11 44 0f e0    	vmovups XMMWORD PTR [rdi+rcx*1-0x20],xmm0
    while (index < block_size) : (index += 1) {
  21abfd:	48 89 c6             	mov    rsi,rax
  21ac00:	48 83 ce 01          	or     rsi,0x1
        mem.swap(T, &items[start1 + index], &items[start2 + index]);
  21ac04:	4c 01 e6             	add    rsi,r12
  21ac07:	48 8b 7c 24 40       	mov    rdi,QWORD PTR [rsp+0x40]
  21ac0c:	48 c1 e6 04          	shl    rsi,0x4
    const tmp = a.*;
  21ac10:	c5 f8 10 04 37       	vmovups xmm0,XMMWORD PTR [rdi+rsi*1]
  21ac15:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21ac1a:	c5 f8 10 44 0f f0    	vmovups xmm0,XMMWORD PTR [rdi+rcx*1-0x10]
  21ac20:	c5 f8 11 04 37       	vmovups XMMWORD PTR [rdi+rsi*1],xmm0
    b.* = tmp;
  21ac25:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  21ac2a:	c5 f8 11 44 0f f0    	vmovups XMMWORD PTR [rdi+rcx*1-0x10],xmm0
    while (index < block_size) : (index += 1) {
  21ac30:	48 89 c6             	mov    rsi,rax
  21ac33:	48 83 ce 02          	or     rsi,0x2
        mem.swap(T, &items[start1 + index], &items[start2 + index]);
  21ac37:	4c 01 e6             	add    rsi,r12
  21ac3a:	48 8b 7c 24 40       	mov    rdi,QWORD PTR [rsp+0x40]
  21ac3f:	48 c1 e6 04          	shl    rsi,0x4
    const tmp = a.*;
  21ac43:	c5 f8 10 04 37       	vmovups xmm0,XMMWORD PTR [rdi+rsi*1]
  21ac48:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21ac4d:	c5 f8 10 04 0f       	vmovups xmm0,XMMWORD PTR [rdi+rcx*1]
  21ac52:	c5 f8 11 04 37       	vmovups XMMWORD PTR [rdi+rsi*1],xmm0
    b.* = tmp;
  21ac57:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  21ac5c:	c5 f8 11 04 0f       	vmovups XMMWORD PTR [rdi+rcx*1],xmm0
    while (index < block_size) : (index += 1) {
  21ac61:	48 89 c6             	mov    rsi,rax
  21ac64:	48 83 ce 03          	or     rsi,0x3
        mem.swap(T, &items[start1 + index], &items[start2 + index]);
  21ac68:	4c 01 e6             	add    rsi,r12
  21ac6b:	48 8b 7c 24 40       	mov    rdi,QWORD PTR [rsp+0x40]
  21ac70:	48 c1 e6 04          	shl    rsi,0x4
    const tmp = a.*;
  21ac74:	c5 f8 10 04 37       	vmovups xmm0,XMMWORD PTR [rdi+rsi*1]
  21ac79:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21ac7e:	c5 f8 10 44 0f 10    	vmovups xmm0,XMMWORD PTR [rdi+rcx*1+0x10]
  21ac84:	c5 f8 11 04 37       	vmovups XMMWORD PTR [rdi+rsi*1],xmm0
    b.* = tmp;
  21ac89:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  21ac8e:	c5 fa 7f 44 0f 10    	vmovdqu XMMWORD PTR [rdi+rcx*1+0x10],xmm0
    while (index < block_size) : (index += 1) {
  21ac94:	48 83 c0 04          	add    rax,0x4
  21ac98:	48 83 c1 40          	add    rcx,0x40
  21ac9c:	48 83 c2 fc          	add    rdx,0xfffffffffffffffc
  21aca0:	0f 85 2a ff ff ff    	jne    21abd0 <Benchmark_reportStats+0x4490>
  21aca6:	48 83 7c 24 10 00    	cmp    QWORD PTR [rsp+0x10],0x0
  21acac:	74 4b                	je     21acf9 <Benchmark_reportStats+0x45b9>
  21acae:	48 8b 4c 24 60       	mov    rcx,QWORD PTR [rsp+0x60]
  21acb3:	48 8d 0c 01          	lea    rcx,[rcx+rax*1]
  21acb7:	48 c1 e1 04          	shl    rcx,0x4
  21acbb:	48 8b 54 24 10       	mov    rdx,QWORD PTR [rsp+0x10]
        mem.swap(T, &items[start1 + index], &items[start2 + index]);
  21acc0:	4a 8d 34 20          	lea    rsi,[rax+r12*1]
  21acc4:	48 8b 7c 24 40       	mov    rdi,QWORD PTR [rsp+0x40]
  21acc9:	48 c1 e6 04          	shl    rsi,0x4
    const tmp = a.*;
  21accd:	c5 f8 10 04 37       	vmovups xmm0,XMMWORD PTR [rdi+rsi*1]
  21acd2:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21acd7:	c5 f8 10 04 0f       	vmovups xmm0,XMMWORD PTR [rdi+rcx*1]
  21acdc:	c5 f8 11 04 37       	vmovups XMMWORD PTR [rdi+rsi*1],xmm0
    b.* = tmp;
  21ace1:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  21ace6:	c5 fa 7f 04 0f       	vmovdqu XMMWORD PTR [rdi+rcx*1],xmm0
    while (index < block_size) : (index += 1) {
  21aceb:	48 83 c0 01          	add    rax,0x1
  21acef:	48 83 c1 10          	add    rcx,0x10
  21acf3:	48 83 c2 ff          	add    rdx,0xffffffffffffffff
  21acf7:	75 c7                	jne    21acc0 <Benchmark_reportStats+0x4580>
  21acf9:	4d 85 ff             	test   r15,r15
  21acfc:	4c 8b 74 24 28       	mov    r14,QWORD PTR [rsp+0x28]
  21ad01:	0f 84 89 04 00 00    	je     21b190 <Benchmark_reportStats+0x4a50>
  21ad07:	4c 89 d1             	mov    rcx,r10
  21ad0a:	4c 29 f9             	sub    rcx,r15
        mem.swap(T, &items[start1 + index], &items[start2 + index]);
  21ad0d:	48 83 c3 ff          	add    rbx,0xffffffffffffffff
  21ad11:	4c 29 eb             	sub    rbx,r13
  21ad14:	44 89 f8             	mov    eax,r15d
  21ad17:	83 e0 03             	and    eax,0x3
  21ad1a:	48 83 fb 03          	cmp    rbx,0x3
  21ad1e:	73 10                	jae    21ad30 <Benchmark_reportStats+0x45f0>
  21ad20:	31 d2                	xor    edx,edx
    while (index < block_size) : (index += 1) {
  21ad22:	48 85 c0             	test   rax,rax
  21ad25:	0f 85 03 01 00 00    	jne    21ae2e <Benchmark_reportStats+0x46ee>
  21ad2b:	e9 60 04 00 00       	jmp    21b190 <Benchmark_reportStats+0x4a50>
        mem.swap(T, &items[start1 + index], &items[start2 + index]);
  21ad30:	4d 89 f9             	mov    r9,r15
  21ad33:	49 29 c1             	sub    r9,rax
  21ad36:	4c 89 ef             	mov    rdi,r13
  21ad39:	48 c1 e7 04          	shl    rdi,0x4
  21ad3d:	48 83 c7 20          	add    rdi,0x20
  21ad41:	31 d2                	xor    edx,edx
  21ad43:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21ad4a:	84 00 00 00 00 00 
  21ad50:	48 8b 5c 24 40       	mov    rbx,QWORD PTR [rsp+0x40]
  21ad55:	48 8d 34 11          	lea    rsi,[rcx+rdx*1]
  21ad59:	48 c1 e6 04          	shl    rsi,0x4
    const tmp = a.*;
  21ad5d:	c5 f8 10 44 3b e0    	vmovups xmm0,XMMWORD PTR [rbx+rdi*1-0x20]
  21ad63:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21ad68:	c5 f8 10 04 33       	vmovups xmm0,XMMWORD PTR [rbx+rsi*1]
  21ad6d:	c5 f8 11 44 3b e0    	vmovups XMMWORD PTR [rbx+rdi*1-0x20],xmm0
    b.* = tmp;
  21ad73:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  21ad78:	c5 f8 11 04 33       	vmovups XMMWORD PTR [rbx+rsi*1],xmm0
    while (index < block_size) : (index += 1) {
  21ad7d:	48 89 d6             	mov    rsi,rdx
  21ad80:	48 83 ce 01          	or     rsi,0x1
        mem.swap(T, &items[start1 + index], &items[start2 + index]);
  21ad84:	48 8b 5c 24 40       	mov    rbx,QWORD PTR [rsp+0x40]
  21ad89:	48 01 ce             	add    rsi,rcx
    const tmp = a.*;
  21ad8c:	c5 f8 10 44 3b f0    	vmovups xmm0,XMMWORD PTR [rbx+rdi*1-0x10]
  21ad92:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
  21ad97:	48 c1 e6 04          	shl    rsi,0x4
    a.* = b.*;
  21ad9b:	c5 f8 10 04 33       	vmovups xmm0,XMMWORD PTR [rbx+rsi*1]
  21ada0:	c5 f8 11 44 3b f0    	vmovups XMMWORD PTR [rbx+rdi*1-0x10],xmm0
    b.* = tmp;
  21ada6:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  21adab:	c5 f8 11 04 33       	vmovups XMMWORD PTR [rbx+rsi*1],xmm0
    while (index < block_size) : (index += 1) {
  21adb0:	48 89 d6             	mov    rsi,rdx
  21adb3:	48 83 ce 02          	or     rsi,0x2
        mem.swap(T, &items[start1 + index], &items[start2 + index]);
  21adb7:	48 8b 5c 24 40       	mov    rbx,QWORD PTR [rsp+0x40]
  21adbc:	48 01 ce             	add    rsi,rcx
  21adbf:	48 c1 e6 04          	shl    rsi,0x4
    const tmp = a.*;
  21adc3:	c5 f8 10 04 3b       	vmovups xmm0,XMMWORD PTR [rbx+rdi*1]
  21adc8:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21adcd:	c5 f8 10 04 33       	vmovups xmm0,XMMWORD PTR [rbx+rsi*1]
  21add2:	c5 f8 11 04 3b       	vmovups XMMWORD PTR [rbx+rdi*1],xmm0
    b.* = tmp;
  21add7:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  21addc:	c5 f8 11 04 33       	vmovups XMMWORD PTR [rbx+rsi*1],xmm0
    while (index < block_size) : (index += 1) {
  21ade1:	48 89 d6             	mov    rsi,rdx
  21ade4:	48 83 ce 03          	or     rsi,0x3
        mem.swap(T, &items[start1 + index], &items[start2 + index]);
  21ade8:	48 8b 5c 24 40       	mov    rbx,QWORD PTR [rsp+0x40]
  21aded:	48 01 ce             	add    rsi,rcx
    const tmp = a.*;
  21adf0:	c5 f8 10 44 3b 10    	vmovups xmm0,XMMWORD PTR [rbx+rdi*1+0x10]
  21adf6:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
  21adfb:	48 c1 e6 04          	shl    rsi,0x4
    a.* = b.*;
  21adff:	c5 f8 10 04 33       	vmovups xmm0,XMMWORD PTR [rbx+rsi*1]
  21ae04:	c5 f8 11 44 3b 10    	vmovups XMMWORD PTR [rbx+rdi*1+0x10],xmm0
    b.* = tmp;
  21ae0a:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  21ae0f:	c5 fa 7f 04 33       	vmovdqu XMMWORD PTR [rbx+rsi*1],xmm0
    while (index < block_size) : (index += 1) {
  21ae14:	48 83 c2 04          	add    rdx,0x4
  21ae18:	48 83 c7 40          	add    rdi,0x40
  21ae1c:	49 39 d1             	cmp    r9,rdx
  21ae1f:	0f 85 2b ff ff ff    	jne    21ad50 <Benchmark_reportStats+0x4610>
  21ae25:	48 85 c0             	test   rax,rax
  21ae28:	0f 84 62 03 00 00    	je     21b190 <Benchmark_reportStats+0x4a50>
  21ae2e:	49 01 d5             	add    r13,rdx
  21ae31:	49 c1 e5 04          	shl    r13,0x4
  21ae35:	48 f7 d8             	neg    rax
  21ae38:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  21ae3f:	00 
        mem.swap(T, &items[start1 + index], &items[start2 + index]);
  21ae40:	48 8b 74 24 40       	mov    rsi,QWORD PTR [rsp+0x40]
  21ae45:	48 8d 3c 11          	lea    rdi,[rcx+rdx*1]
    const tmp = a.*;
  21ae49:	c4 a1 78 10 04 2e    	vmovups xmm0,XMMWORD PTR [rsi+r13*1]
  21ae4f:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
  21ae54:	48 c1 e7 04          	shl    rdi,0x4
    a.* = b.*;
  21ae58:	c5 f8 10 04 3e       	vmovups xmm0,XMMWORD PTR [rsi+rdi*1]
  21ae5d:	c4 a1 78 11 04 2e    	vmovups XMMWORD PTR [rsi+r13*1],xmm0
    b.* = tmp;
  21ae63:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  21ae68:	c5 fa 7f 04 3e       	vmovdqu XMMWORD PTR [rsi+rdi*1],xmm0
    while (index < block_size) : (index += 1) {
  21ae6d:	48 83 c2 01          	add    rdx,0x1
  21ae71:	49 83 c5 10          	add    r13,0x10
  21ae75:	48 83 c0 01          	add    rax,0x1
  21ae79:	75 c5                	jne    21ae40 <Benchmark_reportStats+0x4700>
  21ae7b:	e9 10 03 00 00       	jmp    21b190 <Benchmark_reportStats+0x4a50>
  21ae80:	31 ff                	xor    edi,edi
  21ae82:	48 8b 8c 24 68 01 00 	mov    rcx,QWORD PTR [rsp+0x168]
  21ae89:	00 
  21ae8a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
        swap(T, &items[i], &items[items.len - i - 1]);
  21ae90:	48 89 fe             	mov    rsi,rdi
  21ae93:	48 c1 e6 04          	shl    rsi,0x4
  21ae97:	48 89 fb             	mov    rbx,rdi
  21ae9a:	48 f7 d3             	not    rbx
  21ae9d:	4c 01 d3             	add    rbx,r10
    const tmp = a.*;
  21aea0:	c4 c1 78 10 04 36    	vmovups xmm0,XMMWORD PTR [r14+rsi*1]
  21aea6:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  21aeab:	48 c1 e3 04          	shl    rbx,0x4
    a.* = b.*;
  21aeaf:	c4 c1 78 10 04 1e    	vmovups xmm0,XMMWORD PTR [r14+rbx*1]
  21aeb5:	c4 c1 78 11 04 36    	vmovups XMMWORD PTR [r14+rsi*1],xmm0
    b.* = tmp;
  21aebb:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
        swap(T, &items[i], &items[items.len - i - 1]);
  21aec0:	48 89 f0             	mov    rax,rsi
  21aec3:	48 83 c8 10          	or     rax,0x10
  21aec7:	48 c7 c2 fe ff ff ff 	mov    rdx,0xfffffffffffffffe
  21aece:	48 29 fa             	sub    rdx,rdi
  21aed1:	4c 01 d2             	add    rdx,r10
  21aed4:	48 c1 e2 04          	shl    rdx,0x4
    b.* = tmp;
  21aed8:	c4 c1 78 11 04 1e    	vmovups XMMWORD PTR [r14+rbx*1],xmm0
    const tmp = a.*;
  21aede:	c4 c1 78 10 04 06    	vmovups xmm0,XMMWORD PTR [r14+rax*1]
  21aee4:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21aee9:	c4 c1 78 10 04 16    	vmovups xmm0,XMMWORD PTR [r14+rdx*1]
  21aeef:	c4 c1 78 11 04 06    	vmovups XMMWORD PTR [r14+rax*1],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  21aef5:	48 89 f0             	mov    rax,rsi
  21aef8:	48 83 c8 20          	or     rax,0x20
    b.* = tmp;
  21aefc:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
        swap(T, &items[i], &items[items.len - i - 1]);
  21af01:	48 c7 c3 fd ff ff ff 	mov    rbx,0xfffffffffffffffd
  21af08:	48 29 fb             	sub    rbx,rdi
    b.* = tmp;
  21af0b:	c4 c1 78 11 04 16    	vmovups XMMWORD PTR [r14+rdx*1],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  21af11:	4c 01 d3             	add    rbx,r10
    const tmp = a.*;
  21af14:	c4 c1 78 10 04 06    	vmovups xmm0,XMMWORD PTR [r14+rax*1]
  21af1a:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  21af1f:	48 c1 e3 04          	shl    rbx,0x4
    a.* = b.*;
  21af23:	c4 c1 78 10 04 1e    	vmovups xmm0,XMMWORD PTR [r14+rbx*1]
  21af29:	c4 c1 78 11 04 06    	vmovups XMMWORD PTR [r14+rax*1],xmm0
    b.* = tmp;
  21af2f:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
        swap(T, &items[i], &items[items.len - i - 1]);
  21af34:	48 83 ce 30          	or     rsi,0x30
  21af38:	48 c7 c0 fc ff ff ff 	mov    rax,0xfffffffffffffffc
  21af3f:	48 29 f8             	sub    rax,rdi
  21af42:	4c 01 d0             	add    rax,r10
    b.* = tmp;
  21af45:	c4 c1 78 11 04 1e    	vmovups XMMWORD PTR [r14+rbx*1],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  21af4b:	48 c1 e0 04          	shl    rax,0x4
    const tmp = a.*;
  21af4f:	c4 c1 78 10 04 36    	vmovups xmm0,XMMWORD PTR [r14+rsi*1]
  21af55:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21af5a:	c4 c1 78 10 04 06    	vmovups xmm0,XMMWORD PTR [r14+rax*1]
  21af60:	c4 c1 78 11 04 36    	vmovups XMMWORD PTR [r14+rsi*1],xmm0
    b.* = tmp;
  21af66:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
    while (i < end) : (i += 1) {
  21af6b:	48 83 c7 04          	add    rdi,0x4
  21af6f:	48 83 c1 fc          	add    rcx,0xfffffffffffffffc
    b.* = tmp;
  21af73:	c4 c1 7a 7f 04 06    	vmovdqu XMMWORD PTR [r14+rax*1],xmm0
    while (i < end) : (i += 1) {
  21af79:	0f 85 11 ff ff ff    	jne    21ae90 <Benchmark_reportStats+0x4750>
  21af7f:	48 83 bc 24 40 01 00 	cmp    QWORD PTR [rsp+0x140],0x0
  21af86:	00 00 
  21af88:	74 56                	je     21afe0 <Benchmark_reportStats+0x48a0>
  21af8a:	48 8b 8c 24 40 01 00 	mov    rcx,QWORD PTR [rsp+0x140]
  21af91:	00 
  21af92:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21af99:	1f 84 00 00 00 00 00 
        swap(T, &items[i], &items[items.len - i - 1]);
  21afa0:	48 89 f8             	mov    rax,rdi
  21afa3:	48 c1 e0 04          	shl    rax,0x4
  21afa7:	48 89 fa             	mov    rdx,rdi
  21afaa:	48 f7 d2             	not    rdx
  21afad:	4c 01 d2             	add    rdx,r10
  21afb0:	48 c1 e2 04          	shl    rdx,0x4
    const tmp = a.*;
  21afb4:	c4 c1 78 10 04 06    	vmovups xmm0,XMMWORD PTR [r14+rax*1]
  21afba:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21afbf:	c4 c1 78 10 04 16    	vmovups xmm0,XMMWORD PTR [r14+rdx*1]
  21afc5:	c4 c1 78 11 04 06    	vmovups XMMWORD PTR [r14+rax*1],xmm0
    b.* = tmp;
  21afcb:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  21afd0:	c4 c1 7a 7f 04 16    	vmovdqu XMMWORD PTR [r14+rdx*1],xmm0
    while (i < end) : (i += 1) {
  21afd6:	48 83 c7 01          	add    rdi,0x1
  21afda:	48 83 c1 ff          	add    rcx,0xffffffffffffffff
  21afde:	75 c0                	jne    21afa0 <Benchmark_reportStats+0x4860>
    const end = items.len / 2;
  21afe0:	4c 89 c0             	mov    rax,r8
  21afe3:	48 d1 e8             	shr    rax,1
  21afe6:	4c 8b 74 24 28       	mov    r14,QWORD PTR [rsp+0x28]
  21afeb:	4c 8b 54 24 18       	mov    r10,QWORD PTR [rsp+0x18]
    while (i < end) : (i += 1) {
  21aff0:	0f 84 9a 01 00 00    	je     21b190 <Benchmark_reportStats+0x4a50>
        swap(T, &items[i], &items[items.len - i - 1]);
  21aff6:	4c 89 c1             	mov    rcx,r8
    const tmp = a.*;
  21aff9:	c4 c1 78 10 01       	vmovups xmm0,XMMWORD PTR [r9]
  21affe:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  21b003:	48 c1 e1 04          	shl    rcx,0x4
    a.* = b.*;
  21b007:	c4 c1 78 10 44 09 f0 	vmovups xmm0,XMMWORD PTR [r9+rcx*1-0x10]
  21b00e:	c4 c1 78 11 01       	vmovups XMMWORD PTR [r9],xmm0
    b.* = tmp;
  21b013:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  21b018:	c4 c1 7a 7f 44 09 f0 	vmovdqu XMMWORD PTR [r9+rcx*1-0x10],xmm0
    while (i < end) : (i += 1) {
  21b01f:	48 83 f8 01          	cmp    rax,0x1
  21b023:	0f 84 67 01 00 00    	je     21b190 <Benchmark_reportStats+0x4a50>
        swap(T, &items[i], &items[items.len - i - 1]);
  21b029:	48 8d 70 ff          	lea    rsi,[rax-0x1]
  21b02d:	48 83 c0 fe          	add    rax,0xfffffffffffffffe
  21b031:	89 f3                	mov    ebx,esi
  21b033:	83 e3 03             	and    ebx,0x3
  21b036:	48 83 f8 03          	cmp    rax,0x3
  21b03a:	73 13                	jae    21b04f <Benchmark_reportStats+0x490f>
  21b03c:	b8 01 00 00 00       	mov    eax,0x1
    while (i < end) : (i += 1) {
  21b041:	48 85 db             	test   rbx,rbx
  21b044:	0f 85 fb 00 00 00    	jne    21b145 <Benchmark_reportStats+0x4a05>
  21b04a:	e9 41 01 00 00       	jmp    21b190 <Benchmark_reportStats+0x4a50>
        swap(T, &items[i], &items[items.len - i - 1]);
  21b04f:	48 29 de             	sub    rsi,rbx
  21b052:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  21b057:	49 8d 0c 03          	lea    rcx,[r11+rax*1]
  21b05b:	48 83 c1 40          	add    rcx,0x40
  21b05f:	b8 01 00 00 00       	mov    eax,0x1
  21b064:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21b06b:	00 00 00 00 00 
  21b070:	48 89 c2             	mov    rdx,rax
  21b073:	48 f7 d2             	not    rdx
  21b076:	4c 01 c2             	add    rdx,r8
  21b079:	48 c1 e2 04          	shl    rdx,0x4
    const tmp = a.*;
  21b07d:	c5 f8 10 41 d0       	vmovups xmm0,XMMWORD PTR [rcx-0x30]
  21b082:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21b087:	c4 c1 78 10 04 11    	vmovups xmm0,XMMWORD PTR [r9+rdx*1]
  21b08d:	c5 f8 11 41 d0       	vmovups XMMWORD PTR [rcx-0x30],xmm0
    b.* = tmp;
  21b092:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  21b097:	c4 c1 78 11 04 11    	vmovups XMMWORD PTR [r9+rdx*1],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  21b09d:	48 c7 c2 fe ff ff ff 	mov    rdx,0xfffffffffffffffe
  21b0a4:	48 29 c2             	sub    rdx,rax
  21b0a7:	4c 01 c2             	add    rdx,r8
    const tmp = a.*;
  21b0aa:	c5 f8 10 41 e0       	vmovups xmm0,XMMWORD PTR [rcx-0x20]
  21b0af:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  21b0b4:	48 c1 e2 04          	shl    rdx,0x4
    a.* = b.*;
  21b0b8:	c4 c1 78 10 04 11    	vmovups xmm0,XMMWORD PTR [r9+rdx*1]
  21b0be:	c5 f8 11 41 e0       	vmovups XMMWORD PTR [rcx-0x20],xmm0
    b.* = tmp;
  21b0c3:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  21b0c8:	c4 c1 78 11 04 11    	vmovups XMMWORD PTR [r9+rdx*1],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  21b0ce:	48 c7 c2 fd ff ff ff 	mov    rdx,0xfffffffffffffffd
  21b0d5:	48 29 c2             	sub    rdx,rax
  21b0d8:	4c 01 c2             	add    rdx,r8
  21b0db:	48 c1 e2 04          	shl    rdx,0x4
    const tmp = a.*;
  21b0df:	c5 f8 10 41 f0       	vmovups xmm0,XMMWORD PTR [rcx-0x10]
  21b0e4:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21b0e9:	c4 c1 78 10 04 11    	vmovups xmm0,XMMWORD PTR [r9+rdx*1]
  21b0ef:	c5 f8 11 41 f0       	vmovups XMMWORD PTR [rcx-0x10],xmm0
    b.* = tmp;
  21b0f4:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  21b0f9:	c4 c1 78 11 04 11    	vmovups XMMWORD PTR [r9+rdx*1],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  21b0ff:	48 c7 c2 fc ff ff ff 	mov    rdx,0xfffffffffffffffc
  21b106:	48 29 c2             	sub    rdx,rax
  21b109:	4c 01 c2             	add    rdx,r8
    const tmp = a.*;
  21b10c:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  21b110:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  21b115:	48 c1 e2 04          	shl    rdx,0x4
    a.* = b.*;
  21b119:	c4 c1 78 10 04 11    	vmovups xmm0,XMMWORD PTR [r9+rdx*1]
  21b11f:	c5 f8 11 01          	vmovups XMMWORD PTR [rcx],xmm0
    b.* = tmp;
  21b123:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  21b128:	c4 c1 7a 7f 04 11    	vmovdqu XMMWORD PTR [r9+rdx*1],xmm0
    while (i < end) : (i += 1) {
  21b12e:	48 83 c0 04          	add    rax,0x4
  21b132:	48 83 c1 40          	add    rcx,0x40
  21b136:	48 83 c6 fc          	add    rsi,0xfffffffffffffffc
  21b13a:	0f 85 30 ff ff ff    	jne    21b070 <Benchmark_reportStats+0x4930>
  21b140:	48 85 db             	test   rbx,rbx
  21b143:	74 4b                	je     21b190 <Benchmark_reportStats+0x4a50>
  21b145:	49 01 c5             	add    r13,rax
  21b148:	49 c1 e5 04          	shl    r13,0x4
  21b14c:	4d 01 eb             	add    r11,r13
  21b14f:	90                   	nop
        swap(T, &items[i], &items[items.len - i - 1]);
  21b150:	48 89 c1             	mov    rcx,rax
  21b153:	48 f7 d1             	not    rcx
  21b156:	4c 01 c1             	add    rcx,r8
    const tmp = a.*;
  21b159:	c4 c1 78 10 03       	vmovups xmm0,XMMWORD PTR [r11]
  21b15e:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  21b163:	48 c1 e1 04          	shl    rcx,0x4
    a.* = b.*;
  21b167:	c4 c1 78 10 04 09    	vmovups xmm0,XMMWORD PTR [r9+rcx*1]
  21b16d:	c4 c1 78 11 03       	vmovups XMMWORD PTR [r11],xmm0
    b.* = tmp;
  21b172:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  21b177:	c4 c1 7a 7f 04 09    	vmovdqu XMMWORD PTR [r9+rcx*1],xmm0
    while (i < end) : (i += 1) {
  21b17d:	48 83 c0 01          	add    rax,0x1
  21b181:	49 83 c3 10          	add    r11,0x10
  21b185:	48 83 c3 ff          	add    rbx,0xffffffffffffffff
  21b189:	75 c5                	jne    21b150 <Benchmark_reportStats+0x4a10>
  21b18b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  21b190:	48 8b 74 24 20       	mov    rsi,QWORD PTR [rsp+0x20]
  21b195:	48 83 c6 01          	add    rsi,0x1
                                lastA = Range.init(blockA.start - B_remaining, blockA.start - B_remaining + block_size);
  21b199:	4d 29 fc             	sub    r12,r15
  21b19c:	4c 89 a4 24 78 01 00 	mov    QWORD PTR [rsp+0x178],r12
  21b1a3:	00 
  21b1a4:	4f 8d 3c 34          	lea    r15,[r12+r14*1]
  21b1a8:	4c 89 bc 24 80 01 00 	mov    QWORD PTR [rsp+0x180],r15
  21b1af:	00 
  21b1b0:	4c 89 d3             	mov    rbx,r10
  21b1b3:	4c 8b 5c 24 30       	mov    r11,QWORD PTR [rsp+0x30]
                                if (blockA.length() == 0) break;
  21b1b8:	4d 39 d3             	cmp    r11,r10
  21b1bb:	4c 8b 84 24 f8 00 00 	mov    r8,QWORD PTR [rsp+0xf8]
  21b1c2:	00 
  21b1c3:	48 8b bc 24 d0 00 00 	mov    rdi,QWORD PTR [rsp+0xd0]
  21b1ca:	00 
  21b1cb:	0f 85 bf ee ff ff    	jne    21a090 <Benchmark_reportStats+0x3950>
  21b1d1:	e9 4c 06 00 00       	jmp    21b822 <Benchmark_reportStats+0x50e2>
  21b1d6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  21b1dd:	00 00 00 
        return self.end - self.start;
  21b1e0:	4d 89 c2             	mov    r10,r8
  21b1e3:	49 29 fa             	sub    r10,rdi
                            } else if (blockB.length() < block_size) {
  21b1e6:	4c 3b 54 24 58       	cmp    r10,QWORD PTR [rsp+0x58]
  21b1eb:	0f 87 b9 04 00 00    	ja     21b6aa <Benchmark_reportStats+0x4f6a>
                                mem.rotate(T, items[blockA.start..blockB.end], blockB.start - blockA.start);
  21b1f1:	48 8b 44 24 40       	mov    rax,QWORD PTR [rsp+0x40]
  21b1f6:	4d 89 e5             	mov    r13,r12
  21b1f9:	49 c1 e5 04          	shl    r13,0x4
  21b1fd:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  21b202:	49 01 c5             	add    r13,rax
  21b205:	4d 29 e0             	sub    r8,r12
  21b208:	49 89 fe             	mov    r14,rdi
  21b20b:	4d 29 e6             	sub    r14,r12
    const end = items.len / 2;
  21b20e:	4d 89 f7             	mov    r15,r14
  21b211:	49 d1 ef             	shr    r15,1
    while (i < end) : (i += 1) {
  21b214:	0f 84 7a 01 00 00    	je     21b394 <Benchmark_reportStats+0x4c54>
        swap(T, &items[i], &items[items.len - i - 1]);
  21b21a:	49 8d 57 ff          	lea    rdx,[r15-0x1]
  21b21e:	45 89 fb             	mov    r11d,r15d
  21b221:	41 83 e3 03          	and    r11d,0x3
  21b225:	48 83 fa 03          	cmp    rdx,0x3
  21b229:	73 10                	jae    21b23b <Benchmark_reportStats+0x4afb>
  21b22b:	31 db                	xor    ebx,ebx
    while (i < end) : (i += 1) {
  21b22d:	4d 85 db             	test   r11,r11
  21b230:	0f 85 1a 01 00 00    	jne    21b350 <Benchmark_reportStats+0x4c10>
  21b236:	e9 59 01 00 00       	jmp    21b394 <Benchmark_reportStats+0x4c54>
        swap(T, &items[i], &items[items.len - i - 1]);
  21b23b:	4d 29 df             	sub    r15,r11
  21b23e:	31 db                	xor    ebx,ebx
  21b240:	48 89 de             	mov    rsi,rbx
  21b243:	48 c1 e6 04          	shl    rsi,0x4
  21b247:	48 89 da             	mov    rdx,rbx
  21b24a:	48 f7 d2             	not    rdx
  21b24d:	4c 01 f2             	add    rdx,r14
    const tmp = a.*;
  21b250:	c4 c1 78 10 44 35 00 	vmovups xmm0,XMMWORD PTR [r13+rsi*1+0x0]
  21b257:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  21b25c:	48 c1 e2 04          	shl    rdx,0x4
    a.* = b.*;
  21b260:	c4 c1 78 10 44 15 00 	vmovups xmm0,XMMWORD PTR [r13+rdx*1+0x0]
  21b267:	c4 c1 78 11 44 35 00 	vmovups XMMWORD PTR [r13+rsi*1+0x0],xmm0
    b.* = tmp;
  21b26e:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
        swap(T, &items[i], &items[items.len - i - 1]);
  21b273:	48 89 f7             	mov    rdi,rsi
  21b276:	48 83 cf 10          	or     rdi,0x10
  21b27a:	48 c7 c0 fe ff ff ff 	mov    rax,0xfffffffffffffffe
  21b281:	48 29 d8             	sub    rax,rbx
  21b284:	4c 01 f0             	add    rax,r14
  21b287:	48 c1 e0 04          	shl    rax,0x4
    b.* = tmp;
  21b28b:	c4 c1 78 11 44 15 00 	vmovups XMMWORD PTR [r13+rdx*1+0x0],xmm0
    const tmp = a.*;
  21b292:	c4 c1 78 10 44 3d 00 	vmovups xmm0,XMMWORD PTR [r13+rdi*1+0x0]
  21b299:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21b29e:	c4 c1 78 10 44 05 00 	vmovups xmm0,XMMWORD PTR [r13+rax*1+0x0]
  21b2a5:	c4 c1 78 11 44 3d 00 	vmovups XMMWORD PTR [r13+rdi*1+0x0],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  21b2ac:	48 89 f2             	mov    rdx,rsi
  21b2af:	48 83 ca 20          	or     rdx,0x20
    b.* = tmp;
  21b2b3:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
        swap(T, &items[i], &items[items.len - i - 1]);
  21b2b8:	48 c7 c7 fd ff ff ff 	mov    rdi,0xfffffffffffffffd
  21b2bf:	48 29 df             	sub    rdi,rbx
    b.* = tmp;
  21b2c2:	c4 c1 78 11 44 05 00 	vmovups XMMWORD PTR [r13+rax*1+0x0],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  21b2c9:	4c 01 f7             	add    rdi,r14
    const tmp = a.*;
  21b2cc:	c4 c1 78 10 44 15 00 	vmovups xmm0,XMMWORD PTR [r13+rdx*1+0x0]
  21b2d3:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  21b2d8:	48 c1 e7 04          	shl    rdi,0x4
    a.* = b.*;
  21b2dc:	c4 c1 78 10 44 3d 00 	vmovups xmm0,XMMWORD PTR [r13+rdi*1+0x0]
  21b2e3:	c4 c1 78 11 44 15 00 	vmovups XMMWORD PTR [r13+rdx*1+0x0],xmm0
    b.* = tmp;
  21b2ea:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
        swap(T, &items[i], &items[items.len - i - 1]);
  21b2ef:	48 83 ce 30          	or     rsi,0x30
  21b2f3:	48 c7 c0 fc ff ff ff 	mov    rax,0xfffffffffffffffc
  21b2fa:	48 29 d8             	sub    rax,rbx
  21b2fd:	4c 01 f0             	add    rax,r14
    b.* = tmp;
  21b300:	c4 c1 78 11 44 3d 00 	vmovups XMMWORD PTR [r13+rdi*1+0x0],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  21b307:	48 c1 e0 04          	shl    rax,0x4
    const tmp = a.*;
  21b30b:	c4 c1 78 10 44 35 00 	vmovups xmm0,XMMWORD PTR [r13+rsi*1+0x0]
  21b312:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21b317:	c4 c1 78 10 44 05 00 	vmovups xmm0,XMMWORD PTR [r13+rax*1+0x0]
  21b31e:	c4 c1 78 11 44 35 00 	vmovups XMMWORD PTR [r13+rsi*1+0x0],xmm0
    b.* = tmp;
  21b325:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
    while (i < end) : (i += 1) {
  21b32a:	48 83 c3 04          	add    rbx,0x4
  21b32e:	49 83 c7 fc          	add    r15,0xfffffffffffffffc
    b.* = tmp;
  21b332:	c4 c1 7a 7f 44 05 00 	vmovdqu XMMWORD PTR [r13+rax*1+0x0],xmm0
    while (i < end) : (i += 1) {
  21b339:	0f 85 01 ff ff ff    	jne    21b240 <Benchmark_reportStats+0x4b00>
  21b33f:	4d 85 db             	test   r11,r11
  21b342:	74 50                	je     21b394 <Benchmark_reportStats+0x4c54>
  21b344:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21b34b:	00 00 00 00 00 
        swap(T, &items[i], &items[items.len - i - 1]);
  21b350:	48 89 d8             	mov    rax,rbx
  21b353:	48 c1 e0 04          	shl    rax,0x4
  21b357:	48 89 da             	mov    rdx,rbx
  21b35a:	48 f7 d2             	not    rdx
  21b35d:	4c 01 f2             	add    rdx,r14
  21b360:	48 c1 e2 04          	shl    rdx,0x4
    const tmp = a.*;
  21b364:	c4 c1 78 10 44 05 00 	vmovups xmm0,XMMWORD PTR [r13+rax*1+0x0]
  21b36b:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21b370:	c4 c1 78 10 44 15 00 	vmovups xmm0,XMMWORD PTR [r13+rdx*1+0x0]
  21b377:	c4 c1 78 11 44 05 00 	vmovups XMMWORD PTR [r13+rax*1+0x0],xmm0
    b.* = tmp;
  21b37e:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  21b383:	c4 c1 7a 7f 44 15 00 	vmovdqu XMMWORD PTR [r13+rdx*1+0x0],xmm0
    while (i < end) : (i += 1) {
  21b38a:	48 83 c3 01          	add    rbx,0x1
  21b38e:	49 83 c3 ff          	add    r11,0xffffffffffffffff
  21b392:	75 bc                	jne    21b350 <Benchmark_reportStats+0x4c10>
    reverse(T, items[amount..]);
  21b394:	4d 89 c3             	mov    r11,r8
  21b397:	4d 29 f3             	sub    r11,r14
    const end = items.len / 2;
  21b39a:	4d 89 df             	mov    r15,r11
  21b39d:	49 d1 ef             	shr    r15,1
    while (i < end) : (i += 1) {
  21b3a0:	0f 84 66 01 00 00    	je     21b50c <Benchmark_reportStats+0x4dcc>
  21b3a6:	48 8b 9c 24 d0 00 00 	mov    rbx,QWORD PTR [rsp+0xd0]
  21b3ad:	00 
  21b3ae:	48 c1 e3 04          	shl    rbx,0x4
  21b3b2:	48 03 5c 24 18       	add    rbx,QWORD PTR [rsp+0x18]
        swap(T, &items[i], &items[items.len - i - 1]);
  21b3b7:	49 8d 47 ff          	lea    rax,[r15-0x1]
  21b3bb:	45 89 fe             	mov    r14d,r15d
  21b3be:	41 83 e6 03          	and    r14d,0x3
  21b3c2:	48 83 f8 03          	cmp    rax,0x3
  21b3c6:	73 10                	jae    21b3d8 <Benchmark_reportStats+0x4c98>
  21b3c8:	31 d2                	xor    edx,edx
    while (i < end) : (i += 1) {
  21b3ca:	4d 85 f6             	test   r14,r14
  21b3cd:	0f 85 fd 00 00 00    	jne    21b4d0 <Benchmark_reportStats+0x4d90>
  21b3d3:	e9 34 01 00 00       	jmp    21b50c <Benchmark_reportStats+0x4dcc>
        swap(T, &items[i], &items[items.len - i - 1]);
  21b3d8:	4d 29 f7             	sub    r15,r14
  21b3db:	31 d2                	xor    edx,edx
  21b3dd:	0f 1f 00             	nop    DWORD PTR [rax]
  21b3e0:	48 89 d0             	mov    rax,rdx
  21b3e3:	48 c1 e0 04          	shl    rax,0x4
  21b3e7:	48 89 d6             	mov    rsi,rdx
  21b3ea:	48 f7 d6             	not    rsi
  21b3ed:	4c 01 de             	add    rsi,r11
    const tmp = a.*;
  21b3f0:	c5 f8 10 04 03       	vmovups xmm0,XMMWORD PTR [rbx+rax*1]
  21b3f5:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  21b3fa:	48 c1 e6 04          	shl    rsi,0x4
    a.* = b.*;
  21b3fe:	c5 f8 10 04 33       	vmovups xmm0,XMMWORD PTR [rbx+rsi*1]
  21b403:	c5 f8 11 04 03       	vmovups XMMWORD PTR [rbx+rax*1],xmm0
    b.* = tmp;
  21b408:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
        swap(T, &items[i], &items[items.len - i - 1]);
  21b40d:	48 89 c7             	mov    rdi,rax
  21b410:	48 83 cf 10          	or     rdi,0x10
  21b414:	48 c7 c1 fe ff ff ff 	mov    rcx,0xfffffffffffffffe
  21b41b:	48 29 d1             	sub    rcx,rdx
  21b41e:	4c 01 d9             	add    rcx,r11
  21b421:	48 c1 e1 04          	shl    rcx,0x4
    b.* = tmp;
  21b425:	c5 f8 11 04 33       	vmovups XMMWORD PTR [rbx+rsi*1],xmm0
    const tmp = a.*;
  21b42a:	c5 f8 10 04 3b       	vmovups xmm0,XMMWORD PTR [rbx+rdi*1]
  21b42f:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21b434:	c5 f8 10 04 0b       	vmovups xmm0,XMMWORD PTR [rbx+rcx*1]
  21b439:	c5 f8 11 04 3b       	vmovups XMMWORD PTR [rbx+rdi*1],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  21b43e:	48 89 c6             	mov    rsi,rax
  21b441:	48 83 ce 20          	or     rsi,0x20
    b.* = tmp;
  21b445:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
        swap(T, &items[i], &items[items.len - i - 1]);
  21b44a:	48 c7 c7 fd ff ff ff 	mov    rdi,0xfffffffffffffffd
  21b451:	48 29 d7             	sub    rdi,rdx
    b.* = tmp;
  21b454:	c5 f8 11 04 0b       	vmovups XMMWORD PTR [rbx+rcx*1],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  21b459:	4c 01 df             	add    rdi,r11
    const tmp = a.*;
  21b45c:	c5 f8 10 04 33       	vmovups xmm0,XMMWORD PTR [rbx+rsi*1]
  21b461:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  21b466:	48 c1 e7 04          	shl    rdi,0x4
    a.* = b.*;
  21b46a:	c5 f8 10 04 3b       	vmovups xmm0,XMMWORD PTR [rbx+rdi*1]
  21b46f:	c5 f8 11 04 33       	vmovups XMMWORD PTR [rbx+rsi*1],xmm0
    b.* = tmp;
  21b474:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
        swap(T, &items[i], &items[items.len - i - 1]);
  21b479:	48 83 c8 30          	or     rax,0x30
  21b47d:	48 c7 c1 fc ff ff ff 	mov    rcx,0xfffffffffffffffc
  21b484:	48 29 d1             	sub    rcx,rdx
  21b487:	4c 01 d9             	add    rcx,r11
    b.* = tmp;
  21b48a:	c5 f8 11 04 3b       	vmovups XMMWORD PTR [rbx+rdi*1],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  21b48f:	48 c1 e1 04          	shl    rcx,0x4
    const tmp = a.*;
  21b493:	c5 f8 10 04 03       	vmovups xmm0,XMMWORD PTR [rbx+rax*1]
  21b498:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21b49d:	c5 f8 10 04 0b       	vmovups xmm0,XMMWORD PTR [rbx+rcx*1]
  21b4a2:	c5 f8 11 04 03       	vmovups XMMWORD PTR [rbx+rax*1],xmm0
    b.* = tmp;
  21b4a7:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
    while (i < end) : (i += 1) {
  21b4ac:	48 83 c2 04          	add    rdx,0x4
  21b4b0:	49 83 c7 fc          	add    r15,0xfffffffffffffffc
    b.* = tmp;
  21b4b4:	c5 fa 7f 04 0b       	vmovdqu XMMWORD PTR [rbx+rcx*1],xmm0
    while (i < end) : (i += 1) {
  21b4b9:	0f 85 21 ff ff ff    	jne    21b3e0 <Benchmark_reportStats+0x4ca0>
  21b4bf:	4d 85 f6             	test   r14,r14
  21b4c2:	74 48                	je     21b50c <Benchmark_reportStats+0x4dcc>
  21b4c4:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21b4cb:	00 00 00 00 00 
        swap(T, &items[i], &items[items.len - i - 1]);
  21b4d0:	48 89 d0             	mov    rax,rdx
  21b4d3:	48 c1 e0 04          	shl    rax,0x4
  21b4d7:	48 89 d1             	mov    rcx,rdx
  21b4da:	48 f7 d1             	not    rcx
  21b4dd:	4c 01 d9             	add    rcx,r11
  21b4e0:	48 c1 e1 04          	shl    rcx,0x4
    const tmp = a.*;
  21b4e4:	c5 f8 10 04 03       	vmovups xmm0,XMMWORD PTR [rbx+rax*1]
  21b4e9:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21b4ee:	c5 f8 10 04 0b       	vmovups xmm0,XMMWORD PTR [rbx+rcx*1]
  21b4f3:	c5 f8 11 04 03       	vmovups XMMWORD PTR [rbx+rax*1],xmm0
    b.* = tmp;
  21b4f8:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  21b4fd:	c5 fa 7f 04 0b       	vmovdqu XMMWORD PTR [rbx+rcx*1],xmm0
    while (i < end) : (i += 1) {
  21b502:	48 83 c2 01          	add    rdx,0x1
  21b506:	49 83 c6 ff          	add    r14,0xffffffffffffffff
  21b50a:	75 c4                	jne    21b4d0 <Benchmark_reportStats+0x4d90>
    const end = items.len / 2;
  21b50c:	4c 89 c0             	mov    rax,r8
  21b50f:	48 d1 e8             	shr    rax,1
  21b512:	4c 8b 74 24 28       	mov    r14,QWORD PTR [rsp+0x28]
  21b517:	4c 8b 5c 24 30       	mov    r11,QWORD PTR [rsp+0x30]
    while (i < end) : (i += 1) {
  21b51c:	0f 84 2e eb ff ff    	je     21a050 <Benchmark_reportStats+0x3910>
    const tmp = a.*;
  21b522:	c4 c1 78 10 45 00    	vmovups xmm0,XMMWORD PTR [r13+0x0]
  21b528:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  21b52d:	49 c1 e0 04          	shl    r8,0x4
    a.* = b.*;
  21b531:	c4 81 78 10 44 05 f0 	vmovups xmm0,XMMWORD PTR [r13+r8*1-0x10]
  21b538:	c4 c1 78 11 45 00    	vmovups XMMWORD PTR [r13+0x0],xmm0
    b.* = tmp;
  21b53e:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  21b543:	c4 81 7a 7f 44 05 f0 	vmovdqu XMMWORD PTR [r13+r8*1-0x10],xmm0
    while (i < end) : (i += 1) {
  21b54a:	48 83 f8 01          	cmp    rax,0x1
  21b54e:	0f 84 fc ea ff ff    	je     21a050 <Benchmark_reportStats+0x3910>
        swap(T, &items[i], &items[items.len - i - 1]);
  21b554:	48 8d 70 ff          	lea    rsi,[rax-0x1]
  21b558:	48 83 c0 fe          	add    rax,0xfffffffffffffffe
  21b55c:	89 f2                	mov    edx,esi
  21b55e:	83 e2 03             	and    edx,0x3
  21b561:	48 83 f8 03          	cmp    rax,0x3
  21b565:	73 13                	jae    21b57a <Benchmark_reportStats+0x4e3a>
  21b567:	b8 01 00 00 00       	mov    eax,0x1
    while (i < end) : (i += 1) {
  21b56c:	48 85 d2             	test   rdx,rdx
  21b56f:	0f 85 d3 00 00 00    	jne    21b648 <Benchmark_reportStats+0x4f08>
  21b575:	e9 d6 ea ff ff       	jmp    21a050 <Benchmark_reportStats+0x3910>
        swap(T, &items[i], &items[items.len - i - 1]);
  21b57a:	48 29 d6             	sub    rsi,rdx
  21b57d:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  21b584:	00 
  21b585:	48 c1 e0 04          	shl    rax,0x4
  21b589:	48 8b 4c 24 18       	mov    rcx,QWORD PTR [rsp+0x18]
  21b58e:	48 8d 3c 01          	lea    rdi,[rcx+rax*1]
  21b592:	48 83 c7 e0          	add    rdi,0xffffffffffffffe0
  21b596:	b8 01 00 00 00       	mov    eax,0x1
  21b59b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  21b5a0:	48 89 c1             	mov    rcx,rax
  21b5a3:	48 c1 e1 04          	shl    rcx,0x4
    const tmp = a.*;
  21b5a7:	c4 c1 78 10 44 0d 00 	vmovups xmm0,XMMWORD PTR [r13+rcx*1+0x0]
  21b5ae:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21b5b3:	c5 f8 10 07          	vmovups xmm0,XMMWORD PTR [rdi]
  21b5b7:	c4 c1 78 11 44 0d 00 	vmovups XMMWORD PTR [r13+rcx*1+0x0],xmm0
    b.* = tmp;
  21b5be:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  21b5c3:	c5 f8 11 07          	vmovups XMMWORD PTR [rdi],xmm0
    const tmp = a.*;
  21b5c7:	c4 c1 78 10 44 0d 10 	vmovups xmm0,XMMWORD PTR [r13+rcx*1+0x10]
  21b5ce:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21b5d3:	c5 f8 10 47 f0       	vmovups xmm0,XMMWORD PTR [rdi-0x10]
  21b5d8:	c4 c1 78 11 44 0d 10 	vmovups XMMWORD PTR [r13+rcx*1+0x10],xmm0
    b.* = tmp;
  21b5df:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  21b5e4:	c5 f8 11 47 f0       	vmovups XMMWORD PTR [rdi-0x10],xmm0
    const tmp = a.*;
  21b5e9:	c4 c1 78 10 44 0d 20 	vmovups xmm0,XMMWORD PTR [r13+rcx*1+0x20]
  21b5f0:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21b5f5:	c5 f8 10 47 e0       	vmovups xmm0,XMMWORD PTR [rdi-0x20]
  21b5fa:	c4 c1 78 11 44 0d 20 	vmovups XMMWORD PTR [r13+rcx*1+0x20],xmm0
    b.* = tmp;
  21b601:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  21b606:	c5 f8 11 47 e0       	vmovups XMMWORD PTR [rdi-0x20],xmm0
    const tmp = a.*;
  21b60b:	c4 c1 78 10 44 0d 30 	vmovups xmm0,XMMWORD PTR [r13+rcx*1+0x30]
  21b612:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21b617:	c5 f8 10 47 d0       	vmovups xmm0,XMMWORD PTR [rdi-0x30]
  21b61c:	c4 c1 78 11 44 0d 30 	vmovups XMMWORD PTR [r13+rcx*1+0x30],xmm0
    b.* = tmp;
  21b623:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  21b628:	c5 fa 7f 47 d0       	vmovdqu XMMWORD PTR [rdi-0x30],xmm0
    while (i < end) : (i += 1) {
  21b62d:	48 83 c0 04          	add    rax,0x4
  21b631:	48 83 c7 c0          	add    rdi,0xffffffffffffffc0
  21b635:	48 83 c6 fc          	add    rsi,0xfffffffffffffffc
  21b639:	0f 85 61 ff ff ff    	jne    21b5a0 <Benchmark_reportStats+0x4e60>
  21b63f:	48 85 d2             	test   rdx,rdx
  21b642:	0f 84 08 ea ff ff    	je     21a050 <Benchmark_reportStats+0x3910>
  21b648:	48 8b 8c 24 f8 00 00 	mov    rcx,QWORD PTR [rsp+0xf8]
  21b64f:	00 
  21b650:	48 29 c1             	sub    rcx,rax
  21b653:	48 c1 e1 04          	shl    rcx,0x4
  21b657:	48 8b 74 24 18       	mov    rsi,QWORD PTR [rsp+0x18]
  21b65c:	48 01 ce             	add    rsi,rcx
  21b65f:	48 83 c6 f0          	add    rsi,0xfffffffffffffff0
  21b663:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21b66a:	84 00 00 00 00 00 
        swap(T, &items[i], &items[items.len - i - 1]);
  21b670:	48 89 c1             	mov    rcx,rax
  21b673:	48 c1 e1 04          	shl    rcx,0x4
    const tmp = a.*;
  21b677:	c4 c1 78 10 44 0d 00 	vmovups xmm0,XMMWORD PTR [r13+rcx*1+0x0]
  21b67e:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21b683:	c5 f8 10 06          	vmovups xmm0,XMMWORD PTR [rsi]
  21b687:	c4 c1 78 11 44 0d 00 	vmovups XMMWORD PTR [r13+rcx*1+0x0],xmm0
    b.* = tmp;
  21b68e:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  21b693:	c5 fa 7f 06          	vmovdqu XMMWORD PTR [rsi],xmm0
    while (i < end) : (i += 1) {
  21b697:	48 83 c0 01          	add    rax,0x1
  21b69b:	48 83 c6 f0          	add    rsi,0xfffffffffffffff0
  21b69f:	48 83 c2 ff          	add    rdx,0xffffffffffffffff
  21b6a3:	75 cb                	jne    21b670 <Benchmark_reportStats+0x4f30>
  21b6a5:	e9 a6 e9 ff ff       	jmp    21a050 <Benchmark_reportStats+0x3910>
  21b6aa:	48 83 7c 24 58 03    	cmp    QWORD PTR [rsp+0x58],0x3
        mem.swap(T, &items[start1 + index], &items[start2 + index]);
  21b6b0:	73 14                	jae    21b6c6 <Benchmark_reportStats+0x4f86>
  21b6b2:	45 31 c9             	xor    r9d,r9d
  21b6b5:	48 83 7c 24 10 00    	cmp    QWORD PTR [rsp+0x10],0x0
  21b6bb:	0f 85 17 01 00 00    	jne    21b7d8 <Benchmark_reportStats+0x5098>
  21b6c1:	e9 54 e9 ff ff       	jmp    21a01a <Benchmark_reportStats+0x38da>
  21b6c6:	45 31 c9             	xor    r9d,r9d
  21b6c9:	48 8b 9c 24 10 01 00 	mov    rbx,QWORD PTR [rsp+0x110]
  21b6d0:	00 
  21b6d1:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21b6d8:	0f 1f 84 00 00 00 00 
  21b6df:	00 
  21b6e0:	4b 8d 14 21          	lea    rdx,[r9+r12*1]
  21b6e4:	48 8b 44 24 40       	mov    rax,QWORD PTR [rsp+0x40]
  21b6e9:	48 c1 e2 04          	shl    rdx,0x4
  21b6ed:	49 8d 0c 39          	lea    rcx,[r9+rdi*1]
    const tmp = a.*;
  21b6f1:	c5 f8 10 04 10       	vmovups xmm0,XMMWORD PTR [rax+rdx*1]
  21b6f6:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
  21b6fb:	48 c1 e1 04          	shl    rcx,0x4
    a.* = b.*;
  21b6ff:	c5 f8 10 04 08       	vmovups xmm0,XMMWORD PTR [rax+rcx*1]
  21b704:	c5 f8 11 04 10       	vmovups XMMWORD PTR [rax+rdx*1],xmm0
    b.* = tmp;
  21b709:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
    while (index < block_size) : (index += 1) {
  21b70e:	4c 89 ca             	mov    rdx,r9
  21b711:	c5 f8 11 04 08       	vmovups XMMWORD PTR [rax+rcx*1],xmm0
  21b716:	48 83 ca 01          	or     rdx,0x1
        mem.swap(T, &items[start1 + index], &items[start2 + index]);
  21b71a:	4a 8d 04 22          	lea    rax,[rdx+r12*1]
  21b71e:	48 8b 4c 24 40       	mov    rcx,QWORD PTR [rsp+0x40]
  21b723:	48 c1 e0 04          	shl    rax,0x4
  21b727:	48 01 fa             	add    rdx,rdi
    const tmp = a.*;
  21b72a:	c5 f8 10 04 01       	vmovups xmm0,XMMWORD PTR [rcx+rax*1]
  21b72f:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
  21b734:	48 c1 e2 04          	shl    rdx,0x4
    a.* = b.*;
  21b738:	c5 f8 10 04 11       	vmovups xmm0,XMMWORD PTR [rcx+rdx*1]
  21b73d:	c5 f8 11 04 01       	vmovups XMMWORD PTR [rcx+rax*1],xmm0
    b.* = tmp;
  21b742:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
    while (index < block_size) : (index += 1) {
  21b747:	4c 89 c8             	mov    rax,r9
  21b74a:	c5 f8 11 04 11       	vmovups XMMWORD PTR [rcx+rdx*1],xmm0
  21b74f:	48 83 c8 02          	or     rax,0x2
        mem.swap(T, &items[start1 + index], &items[start2 + index]);
  21b753:	4a 8d 14 20          	lea    rdx,[rax+r12*1]
  21b757:	48 8b 4c 24 40       	mov    rcx,QWORD PTR [rsp+0x40]
  21b75c:	48 c1 e2 04          	shl    rdx,0x4
  21b760:	48 01 f8             	add    rax,rdi
    const tmp = a.*;
  21b763:	c5 f8 10 04 11       	vmovups xmm0,XMMWORD PTR [rcx+rdx*1]
  21b768:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
  21b76d:	48 c1 e0 04          	shl    rax,0x4
    a.* = b.*;
  21b771:	c5 f8 10 04 01       	vmovups xmm0,XMMWORD PTR [rcx+rax*1]
  21b776:	c5 f8 11 04 11       	vmovups XMMWORD PTR [rcx+rdx*1],xmm0
    b.* = tmp;
  21b77b:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
    while (index < block_size) : (index += 1) {
  21b780:	4c 89 ca             	mov    rdx,r9
  21b783:	48 83 ca 03          	or     rdx,0x3
  21b787:	c5 f8 11 04 01       	vmovups XMMWORD PTR [rcx+rax*1],xmm0
        mem.swap(T, &items[start1 + index], &items[start2 + index]);
  21b78c:	4a 8d 04 22          	lea    rax,[rdx+r12*1]
  21b790:	48 8b 4c 24 40       	mov    rcx,QWORD PTR [rsp+0x40]
  21b795:	48 c1 e0 04          	shl    rax,0x4
  21b799:	48 01 fa             	add    rdx,rdi
  21b79c:	48 c1 e2 04          	shl    rdx,0x4
    const tmp = a.*;
  21b7a0:	c5 f8 10 04 01       	vmovups xmm0,XMMWORD PTR [rcx+rax*1]
  21b7a5:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21b7aa:	c5 f8 10 04 11       	vmovups xmm0,XMMWORD PTR [rcx+rdx*1]
  21b7af:	c5 f8 11 04 01       	vmovups XMMWORD PTR [rcx+rax*1],xmm0
    b.* = tmp;
  21b7b4:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
    while (index < block_size) : (index += 1) {
  21b7b9:	49 83 c1 04          	add    r9,0x4
  21b7bd:	48 83 c3 fc          	add    rbx,0xfffffffffffffffc
  21b7c1:	c5 fa 7f 04 11       	vmovdqu XMMWORD PTR [rcx+rdx*1],xmm0
  21b7c6:	0f 85 14 ff ff ff    	jne    21b6e0 <Benchmark_reportStats+0x4fa0>
  21b7cc:	48 83 7c 24 10 00    	cmp    QWORD PTR [rsp+0x10],0x0
  21b7d2:	0f 84 42 e8 ff ff    	je     21a01a <Benchmark_reportStats+0x38da>
  21b7d8:	48 8b 5c 24 10       	mov    rbx,QWORD PTR [rsp+0x10]
  21b7dd:	0f 1f 00             	nop    DWORD PTR [rax]
        mem.swap(T, &items[start1 + index], &items[start2 + index]);
  21b7e0:	4b 8d 14 21          	lea    rdx,[r9+r12*1]
  21b7e4:	48 8b 44 24 40       	mov    rax,QWORD PTR [rsp+0x40]
  21b7e9:	48 c1 e2 04          	shl    rdx,0x4
  21b7ed:	49 8d 0c 39          	lea    rcx,[r9+rdi*1]
  21b7f1:	48 c1 e1 04          	shl    rcx,0x4
    const tmp = a.*;
  21b7f5:	c5 f8 10 04 10       	vmovups xmm0,XMMWORD PTR [rax+rdx*1]
  21b7fa:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21b7ff:	c5 f8 10 04 08       	vmovups xmm0,XMMWORD PTR [rax+rcx*1]
  21b804:	c5 f8 11 04 10       	vmovups XMMWORD PTR [rax+rdx*1],xmm0
    b.* = tmp;
  21b809:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  21b80e:	c5 fa 7f 04 08       	vmovdqu XMMWORD PTR [rax+rcx*1],xmm0
    while (index < block_size) : (index += 1) {
  21b813:	49 83 c1 01          	add    r9,0x1
  21b817:	48 83 c3 ff          	add    rbx,0xffffffffffffffff
  21b81b:	75 c3                	jne    21b7e0 <Benchmark_reportStats+0x50a0>
  21b81d:	e9 f8 e7 ff ff       	jmp    21a01a <Benchmark_reportStats+0x38da>
        return self.end - self.start;
  21b822:	4d 89 f5             	mov    r13,r14
  21b825:	48 8b 44 24 50       	mov    rax,QWORD PTR [rsp+0x50]
                    if (lastA.length() <= cache.len) {
  21b82a:	49 81 fd 00 02 00 00 	cmp    r13,0x200
  21b831:	4c 8b 84 24 e8 00 00 	mov    r8,QWORD PTR [rsp+0xe8]
  21b838:	00 
  21b839:	0f 86 af e5 ff ff    	jbe    219dee <Benchmark_reportStats+0x36ae>
  21b83f:	48 8b 4c 24 60       	mov    rcx,QWORD PTR [rsp+0x60]
  21b844:	48 39 c8             	cmp    rax,rcx
  21b847:	48 89 c8             	mov    rax,rcx
                    } else if (buffer2.length() > 0) {
  21b84a:	75 32                	jne    21b87e <Benchmark_reportStats+0x513e>
        return Range{
  21b84c:	4c 89 bc 24 08 02 00 	mov    QWORD PTR [rsp+0x208],r15
  21b853:	00 
  21b854:	4c 89 84 24 10 02 00 	mov    QWORD PTR [rsp+0x210],r8
  21b85b:	00 
                        mergeInPlace(T, items, lastA, Range.init(lastA.end, B.end), lessThan);
  21b85c:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  21b861:	48 8d b4 24 78 01 00 	lea    rsi,[rsp+0x178]
  21b868:	00 
  21b869:	48 8d 94 24 08 02 00 	lea    rdx,[rsp+0x208]
  21b870:	00 
  21b871:	c5 f8 77             	vzeroupper 
  21b874:	e8 c7 3b 00 00       	call   21f440 <mergeInPlace>
  21b879:	e9 72 02 00 00       	jmp    21baf0 <Benchmark_reportStats+0x53b0>
    if (B.length() > 0 and A.length() > 0) {
  21b87e:	4d 29 f8             	sub    r8,r15
  21b881:	0f 84 cf 00 00 00    	je     21b956 <Benchmark_reportStats+0x5216>
  21b887:	41 ba 00 00 00 00    	mov    r10d,0x0
  21b88d:	41 be 00 00 00 00    	mov    r14d,0x0
  21b893:	4d 39 e7             	cmp    r15,r12
  21b896:	0f 84 c0 00 00 00    	je     21b95c <Benchmark_reportStats+0x521c>
  21b89c:	45 31 d2             	xor    r10d,r10d
  21b89f:	31 f6                	xor    esi,esi
  21b8a1:	45 31 c9             	xor    r9d,r9d
  21b8a4:	4d 8d 1c 02          	lea    r11,[r10+rax*1]
            if (!lessThan(items[B.start + B_count], items[buffer.start + A_count])) {
  21b8a8:	49 8d 1c 37          	lea    rbx,[r15+rsi*1]
  21b8ac:	48 c1 e3 04          	shl    rbx,0x4
  21b8b0:	4b 8d 0c 0c          	lea    rcx,[r12+r9*1]
  21b8b4:	48 c1 e1 04          	shl    rcx,0x4
  21b8b8:	4d 89 ce             	mov    r14,r9
  21b8bb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  21b8c0:	48 8b 44 24 40       	mov    rax,QWORD PTR [rsp+0x40]
  21b8c5:	4c 89 da             	mov    rdx,r11
  21b8c8:	48 c1 e2 04          	shl    rdx,0x4
  21b8cc:	48 8b 3c 18          	mov    rdi,QWORD PTR [rax+rbx*1]
  21b8d0:	48 3b 3c 10          	cmp    rdi,QWORD PTR [rax+rdx*1]
  21b8d4:	73 3a                	jae    21b910 <Benchmark_reportStats+0x51d0>
    const tmp = a.*;
  21b8d6:	c5 f8 10 04 08       	vmovups xmm0,XMMWORD PTR [rax+rcx*1]
  21b8db:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21b8e0:	c5 f8 10 04 18       	vmovups xmm0,XMMWORD PTR [rax+rbx*1]
  21b8e5:	c5 f8 11 04 08       	vmovups XMMWORD PTR [rax+rcx*1],xmm0
    b.* = tmp;
  21b8ea:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  21b8ef:	c5 fa 7f 04 18       	vmovdqu XMMWORD PTR [rax+rbx*1],xmm0
                B_count += 1;
  21b8f4:	48 83 c6 01          	add    rsi,0x1
                insert += 1;
  21b8f8:	49 83 c6 01          	add    r14,0x1
                if (B_count >= B.length()) break;
  21b8fc:	48 83 c3 10          	add    rbx,0x10
  21b900:	48 83 c1 10          	add    rcx,0x10
  21b904:	4c 39 c6             	cmp    rsi,r8
  21b907:	72 b7                	jb     21b8c0 <Benchmark_reportStats+0x5180>
  21b909:	eb 51                	jmp    21b95c <Benchmark_reportStats+0x521c>
  21b90b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
    const tmp = a.*;
  21b910:	c5 f8 10 04 08       	vmovups xmm0,XMMWORD PTR [rax+rcx*1]
  21b915:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
  21b91a:	48 01 c2             	add    rdx,rax
    a.* = b.*;
  21b91d:	c5 f8 10 02          	vmovups xmm0,XMMWORD PTR [rdx]
  21b921:	c5 f8 11 04 08       	vmovups XMMWORD PTR [rax+rcx*1],xmm0
    b.* = tmp;
  21b926:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  21b92b:	c5 fa 7f 02          	vmovdqu XMMWORD PTR [rdx],xmm0
                A_count += 1;
  21b92f:	49 83 c2 01          	add    r10,0x1
                if (A_count >= A.length()) break;
  21b933:	4d 8d 4e 01          	lea    r9,[r14+0x1]
  21b937:	4d 39 ea             	cmp    r10,r13
  21b93a:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
  21b93f:	0f 82 5f ff ff ff    	jb     21b8a4 <Benchmark_reportStats+0x5164>
    blockSwap(T, items, buffer.start + A_count, A.start + insert, A.length() - A_count);
  21b945:	49 83 c6 01          	add    r14,0x1
    while (index < block_size) : (index += 1) {
  21b949:	4d 89 e9             	mov    r9,r13
  21b94c:	4d 29 d1             	sub    r9,r10
  21b94f:	75 17                	jne    21b968 <Benchmark_reportStats+0x5228>
  21b951:	e9 9a 01 00 00       	jmp    21baf0 <Benchmark_reportStats+0x53b0>
  21b956:	45 31 d2             	xor    r10d,r10d
  21b959:	45 31 f6             	xor    r14d,r14d
  21b95c:	4d 89 e9             	mov    r9,r13
  21b95f:	4d 29 d1             	sub    r9,r10
  21b962:	0f 84 88 01 00 00    	je     21baf0 <Benchmark_reportStats+0x53b0>
        mem.swap(T, &items[start1 + index], &items[start2 + index]);
  21b968:	49 83 c5 ff          	add    r13,0xffffffffffffffff
  21b96c:	4d 29 d5             	sub    r13,r10
  21b96f:	44 89 c8             	mov    eax,r9d
  21b972:	83 e0 03             	and    eax,0x3
  21b975:	49 83 fd 03          	cmp    r13,0x3
  21b979:	73 10                	jae    21b98b <Benchmark_reportStats+0x524b>
  21b97b:	31 ff                	xor    edi,edi
    while (index < block_size) : (index += 1) {
  21b97d:	48 85 c0             	test   rax,rax
  21b980:	0f 85 04 01 00 00    	jne    21ba8a <Benchmark_reportStats+0x534a>
  21b986:	e9 65 01 00 00       	jmp    21baf0 <Benchmark_reportStats+0x53b0>
        mem.swap(T, &items[start1 + index], &items[start2 + index]);
  21b98b:	49 29 c1             	sub    r9,rax
  21b98e:	4d 89 d0             	mov    r8,r10
  21b991:	49 c1 e0 04          	shl    r8,0x4
  21b995:	4c 03 84 24 18 01 00 	add    r8,QWORD PTR [rsp+0x118]
  21b99c:	00 
  21b99d:	4c 89 f2             	mov    rdx,r14
  21b9a0:	48 c1 e2 04          	shl    rdx,0x4
  21b9a4:	4c 89 e6             	mov    rsi,r12
  21b9a7:	48 c1 e6 04          	shl    rsi,0x4
  21b9ab:	48 01 d6             	add    rsi,rdx
  21b9ae:	31 db                	xor    ebx,ebx
  21b9b0:	31 ff                	xor    edi,edi
  21b9b2:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21b9b9:	1f 84 00 00 00 00 00 
  21b9c0:	48 8b 54 24 40       	mov    rdx,QWORD PTR [rsp+0x40]
    const tmp = a.*;
  21b9c5:	4a 8d 0c 02          	lea    rcx,[rdx+r8*1]
  21b9c9:	c5 f8 10 04 0b       	vmovups xmm0,XMMWORD PTR [rbx+rcx*1]
  21b9ce:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21b9d3:	48 01 f2             	add    rdx,rsi
  21b9d6:	c5 f8 10 04 13       	vmovups xmm0,XMMWORD PTR [rbx+rdx*1]
  21b9db:	c5 f8 11 04 0b       	vmovups XMMWORD PTR [rbx+rcx*1],xmm0
    b.* = tmp;
  21b9e0:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  21b9e5:	c5 f8 11 04 13       	vmovups XMMWORD PTR [rbx+rdx*1],xmm0
  21b9ea:	48 8b 4c 24 40       	mov    rcx,QWORD PTR [rsp+0x40]
    const tmp = a.*;
  21b9ef:	4a 8d 14 01          	lea    rdx,[rcx+r8*1]
  21b9f3:	c5 f8 10 44 13 10    	vmovups xmm0,XMMWORD PTR [rbx+rdx*1+0x10]
  21b9f9:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21b9fe:	48 01 f1             	add    rcx,rsi
  21ba01:	c5 f8 10 44 0b 10    	vmovups xmm0,XMMWORD PTR [rbx+rcx*1+0x10]
  21ba07:	c5 f8 11 44 13 10    	vmovups XMMWORD PTR [rbx+rdx*1+0x10],xmm0
    b.* = tmp;
  21ba0d:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  21ba12:	c5 f8 11 44 0b 10    	vmovups XMMWORD PTR [rbx+rcx*1+0x10],xmm0
  21ba18:	48 8b 4c 24 40       	mov    rcx,QWORD PTR [rsp+0x40]
    const tmp = a.*;
  21ba1d:	4a 8d 14 01          	lea    rdx,[rcx+r8*1]
  21ba21:	c5 f8 10 44 13 20    	vmovups xmm0,XMMWORD PTR [rbx+rdx*1+0x20]
  21ba27:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21ba2c:	48 01 f1             	add    rcx,rsi
  21ba2f:	c5 f8 10 44 0b 20    	vmovups xmm0,XMMWORD PTR [rbx+rcx*1+0x20]
  21ba35:	c5 f8 11 44 13 20    	vmovups XMMWORD PTR [rbx+rdx*1+0x20],xmm0
    b.* = tmp;
  21ba3b:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  21ba40:	c5 f8 11 44 0b 20    	vmovups XMMWORD PTR [rbx+rcx*1+0x20],xmm0
  21ba46:	48 8b 4c 24 40       	mov    rcx,QWORD PTR [rsp+0x40]
    const tmp = a.*;
  21ba4b:	4a 8d 14 01          	lea    rdx,[rcx+r8*1]
  21ba4f:	c5 f8 10 44 13 30    	vmovups xmm0,XMMWORD PTR [rbx+rdx*1+0x30]
  21ba55:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21ba5a:	48 01 f1             	add    rcx,rsi
  21ba5d:	c5 f8 10 44 0b 30    	vmovups xmm0,XMMWORD PTR [rbx+rcx*1+0x30]
  21ba63:	c5 f8 11 44 13 30    	vmovups XMMWORD PTR [rbx+rdx*1+0x30],xmm0
    b.* = tmp;
  21ba69:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  21ba6e:	c5 fa 7f 44 0b 30    	vmovdqu XMMWORD PTR [rbx+rcx*1+0x30],xmm0
    while (index < block_size) : (index += 1) {
  21ba74:	48 83 c7 04          	add    rdi,0x4
  21ba78:	48 83 c3 40          	add    rbx,0x40
  21ba7c:	49 39 f9             	cmp    r9,rdi
  21ba7f:	0f 85 3b ff ff ff    	jne    21b9c0 <Benchmark_reportStats+0x5280>
  21ba85:	48 85 c0             	test   rax,rax
  21ba88:	74 66                	je     21baf0 <Benchmark_reportStats+0x53b0>
  21ba8a:	4d 01 e6             	add    r14,r12
  21ba8d:	49 01 fe             	add    r14,rdi
  21ba90:	49 c1 e6 04          	shl    r14,0x4
  21ba94:	4c 03 54 24 60       	add    r10,QWORD PTR [rsp+0x60]
  21ba99:	49 01 fa             	add    r10,rdi
  21ba9c:	49 c1 e2 04          	shl    r10,0x4
  21baa0:	48 f7 d8             	neg    rax
  21baa3:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21baaa:	84 00 00 00 00 00 
        mem.swap(T, &items[start1 + index], &items[start2 + index]);
  21bab0:	48 8b 4c 24 40       	mov    rcx,QWORD PTR [rsp+0x40]
    const tmp = a.*;
  21bab5:	c4 a1 78 10 04 11    	vmovups xmm0,XMMWORD PTR [rcx+r10*1]
  21babb:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21bac0:	c4 a1 78 10 04 31    	vmovups xmm0,XMMWORD PTR [rcx+r14*1]
  21bac6:	c4 a1 78 11 04 11    	vmovups XMMWORD PTR [rcx+r10*1],xmm0
    b.* = tmp;
  21bacc:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  21bad1:	c4 a1 7a 7f 04 31    	vmovdqu XMMWORD PTR [rcx+r14*1],xmm0
    while (index < block_size) : (index += 1) {
  21bad7:	49 83 c6 10          	add    r14,0x10
  21badb:	49 83 c2 10          	add    r10,0x10
  21badf:	48 83 c0 01          	add    rax,0x1
  21bae3:	75 cb                	jne    21bab0 <Benchmark_reportStats+0x5370>
  21bae5:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21baec:	00 00 00 00 
  21baf0:	48 8b 9c 24 38 01 00 	mov    rbx,QWORD PTR [rsp+0x138]
  21baf7:	00 
  21baf8:	48 2b 9c 24 30 01 00 	sub    rbx,QWORD PTR [rsp+0x130]
  21baff:	00 
  21bb00:	48 8b 84 24 08 01 00 	mov    rax,QWORD PTR [rsp+0x108]
  21bb07:	00 
        return self.decimal >= self.size;
  21bb08:	48 3b 84 24 f0 00 00 	cmp    rax,QWORD PTR [rsp+0xf0]
  21bb0f:	00 
  21bb10:	48 8b b4 24 d8 00 00 	mov    rsi,QWORD PTR [rsp+0xd8]
  21bb17:	00 
  21bb18:	48 8b 94 24 e0 00 00 	mov    rdx,QWORD PTR [rsp+0xe0]
  21bb1f:	00 
            while (!iterator.finished()) {
  21bb20:	0f 82 9a d9 ff ff    	jb     2194c0 <Benchmark_reportStats+0x2d80>
        while (i < items.len) : (i += 1) {
  21bb26:	48 83 bc 24 c0 01 00 	cmp    QWORD PTR [rsp+0x1c0],0x2
  21bb2d:	00 02 
  21bb2f:	0f 82 e3 01 00 00    	jb     21bd18 <Benchmark_reportStats+0x55d8>
  21bb35:	48 8b 44 24 40       	mov    rax,QWORD PTR [rsp+0x40]
  21bb3a:	48 8b b4 24 18 01 00 	mov    rsi,QWORD PTR [rsp+0x118]
  21bb41:	00 
  21bb42:	4c 8d 0c 30          	lea    r9,[rax+rsi*1]
  21bb46:	48 8b 4c 24 50       	mov    rcx,QWORD PTR [rsp+0x50]
            const x = items[i];
  21bb4b:	4c 8d 51 ff          	lea    r10,[rcx-0x1]
  21bb4f:	48 8b 54 24 60       	mov    rdx,QWORD PTR [rsp+0x60]
  21bb54:	49 29 d2             	sub    r10,rdx
  21bb57:	48 83 c1 fe          	add    rcx,0xfffffffffffffffe
  21bb5b:	45 89 d0             	mov    r8d,r10d
  21bb5e:	41 83 e0 01          	and    r8d,0x1
  21bb62:	48 39 d1             	cmp    rcx,rdx
  21bb65:	75 13                	jne    21bb7a <Benchmark_reportStats+0x543a>
  21bb67:	be 01 00 00 00       	mov    esi,0x1
            while (j > 0 and lessThan(x, items[j - 1])) : (j -= 1) {
  21bb6c:	4d 85 c0             	test   r8,r8
  21bb6f:	0f 85 19 01 00 00    	jne    21bc8e <Benchmark_reportStats+0x554e>
  21bb75:	e9 9e 01 00 00       	jmp    21bd18 <Benchmark_reportStats+0x55d8>
            const x = items[i];
  21bb7a:	4d 29 c2             	sub    r10,r8
  21bb7d:	4c 8d 3c 30          	lea    r15,[rax+rsi*1]
  21bb81:	49 83 c7 10          	add    r15,0x10
  21bb85:	4c 8d 1c 30          	lea    r11,[rax+rsi*1]
  21bb89:	49 83 c3 20          	add    r11,0x20
  21bb8d:	49 c7 c4 ff ff ff ff 	mov    r12,0xffffffffffffffff
  21bb94:	49 c7 c6 fe ff ff ff 	mov    r14,0xfffffffffffffffe
  21bb9b:	be 01 00 00 00       	mov    esi,0x1
  21bba0:	48 89 f1             	mov    rcx,rsi
  21bba3:	48 c1 e1 04          	shl    rcx,0x4
  21bba7:	c4 c1 7a 6f 04 09    	vmovdqu xmm0,XMMWORD PTR [r9+rcx*1]
  21bbad:	c4 e1 f9 7e c0       	vmovq  rax,xmm0
  21bbb2:	4c 89 e2             	mov    rdx,r12
  21bbb5:	4c 89 ff             	mov    rdi,r15
  21bbb8:	49 3b 44 09 f0       	cmp    rax,QWORD PTR [r9+rcx*1-0x10]
            while (j > 0 and lessThan(x, items[j - 1])) : (j -= 1) {
  21bbbd:	73 31                	jae    21bbf0 <Benchmark_reportStats+0x54b0>
  21bbbf:	90                   	nop
  21bbc0:	48 89 fb             	mov    rbx,rdi
                items[j] = items[j - 1];
  21bbc3:	c5 f9 10 4b f0       	vmovupd xmm1,XMMWORD PTR [rbx-0x10]
  21bbc8:	c5 f9 11 0b          	vmovupd XMMWORD PTR [rbx],xmm1
            while (j > 0 and lessThan(x, items[j - 1])) : (j -= 1) {
  21bbcc:	48 83 c2 01          	add    rdx,0x1
  21bbd0:	74 2e                	je     21bc00 <Benchmark_reportStats+0x54c0>
  21bbd2:	48 8d 7b f0          	lea    rdi,[rbx-0x10]
  21bbd6:	48 3b 43 e0          	cmp    rax,QWORD PTR [rbx-0x20]
  21bbda:	72 e4                	jb     21bbc0 <Benchmark_reportStats+0x5480>
  21bbdc:	48 83 c3 f0          	add    rbx,0xfffffffffffffff0
  21bbe0:	eb 21                	jmp    21bc03 <Benchmark_reportStats+0x54c3>
  21bbe2:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21bbe9:	1f 84 00 00 00 00 00 
  21bbf0:	49 8d 1c 09          	lea    rbx,[r9+rcx*1]
  21bbf4:	eb 0d                	jmp    21bc03 <Benchmark_reportStats+0x54c3>
  21bbf6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  21bbfd:	00 00 00 
  21bc00:	4c 89 cb             	mov    rbx,r9
            items[j] = x;
  21bc03:	c5 fa 7f 03          	vmovdqu XMMWORD PTR [rbx],xmm0
            const x = items[i];
  21bc07:	c4 c1 7a 6f 44 09 10 	vmovdqu xmm0,XMMWORD PTR [r9+rcx*1+0x10]
  21bc0e:	c4 e1 f9 7e c3       	vmovq  rbx,xmm0
  21bc13:	49 3b 1c 09          	cmp    rbx,QWORD PTR [r9+rcx*1]
            while (j > 0 and lessThan(x, items[j - 1])) : (j -= 1) {
  21bc17:	73 37                	jae    21bc50 <Benchmark_reportStats+0x5510>
  21bc19:	4c 89 f0             	mov    rax,r14
  21bc1c:	4c 89 da             	mov    rdx,r11
  21bc1f:	90                   	nop
  21bc20:	48 89 d1             	mov    rcx,rdx
                items[j] = items[j - 1];
  21bc23:	c5 f9 10 49 f0       	vmovupd xmm1,XMMWORD PTR [rcx-0x10]
  21bc28:	c5 f9 11 09          	vmovupd XMMWORD PTR [rcx],xmm1
            while (j > 0 and lessThan(x, items[j - 1])) : (j -= 1) {
  21bc2c:	48 83 c0 01          	add    rax,0x1
  21bc30:	74 2e                	je     21bc60 <Benchmark_reportStats+0x5520>
  21bc32:	48 8d 51 f0          	lea    rdx,[rcx-0x10]
  21bc36:	48 3b 59 e0          	cmp    rbx,QWORD PTR [rcx-0x20]
  21bc3a:	72 e4                	jb     21bc20 <Benchmark_reportStats+0x54e0>
  21bc3c:	48 83 c1 f0          	add    rcx,0xfffffffffffffff0
  21bc40:	eb 21                	jmp    21bc63 <Benchmark_reportStats+0x5523>
  21bc42:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21bc49:	1f 84 00 00 00 00 00 
  21bc50:	4c 01 c9             	add    rcx,r9
  21bc53:	48 83 c1 10          	add    rcx,0x10
  21bc57:	eb 0a                	jmp    21bc63 <Benchmark_reportStats+0x5523>
  21bc59:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  21bc60:	4c 89 c9             	mov    rcx,r9
            items[j] = x;
  21bc63:	c5 fa 7f 01          	vmovdqu XMMWORD PTR [rcx],xmm0
        while (i < items.len) : (i += 1) {
  21bc67:	48 83 c6 02          	add    rsi,0x2
  21bc6b:	49 83 c7 20          	add    r15,0x20
  21bc6f:	49 83 c4 fe          	add    r12,0xfffffffffffffffe
  21bc73:	49 83 c3 20          	add    r11,0x20
  21bc77:	49 83 c6 fe          	add    r14,0xfffffffffffffffe
  21bc7b:	49 83 c2 fe          	add    r10,0xfffffffffffffffe
  21bc7f:	0f 85 1b ff ff ff    	jne    21bba0 <Benchmark_reportStats+0x5460>
            while (j > 0 and lessThan(x, items[j - 1])) : (j -= 1) {
  21bc85:	4d 85 c0             	test   r8,r8
  21bc88:	0f 84 8a 00 00 00    	je     21bd18 <Benchmark_reportStats+0x55d8>
            const x = items[i];
  21bc8e:	48 89 f2             	mov    rdx,rsi
  21bc91:	48 c1 e2 04          	shl    rdx,0x4
  21bc95:	49 8d 04 11          	lea    rax,[r9+rdx*1]
  21bc99:	c4 c1 7a 6f 04 11    	vmovdqu xmm0,XMMWORD PTR [r9+rdx*1]
  21bc9f:	c4 e1 f9 7e c1       	vmovq  rcx,xmm0
  21bca4:	49 3b 4c 11 f0       	cmp    rcx,QWORD PTR [r9+rdx*1-0x10]
            while (j > 0 and lessThan(x, items[j - 1])) : (j -= 1) {
  21bca9:	73 69                	jae    21bd14 <Benchmark_reportStats+0x55d4>
  21bcab:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  21bcb0:	48 89 c2             	mov    rdx,rax
                items[j] = items[j - 1];
  21bcb3:	c5 f9 10 4a f0       	vmovupd xmm1,XMMWORD PTR [rdx-0x10]
  21bcb8:	c5 f9 11 0a          	vmovupd XMMWORD PTR [rdx],xmm1
            while (j > 0 and lessThan(x, items[j - 1])) : (j -= 1) {
  21bcbc:	48 83 c6 ff          	add    rsi,0xffffffffffffffff
  21bcc0:	74 4f                	je     21bd11 <Benchmark_reportStats+0x55d1>
  21bcc2:	48 8d 42 f0          	lea    rax,[rdx-0x10]
  21bcc6:	48 3b 4a e0          	cmp    rcx,QWORD PTR [rdx-0x20]
  21bcca:	72 e4                	jb     21bcb0 <Benchmark_reportStats+0x5570>
  21bccc:	48 83 c2 f0          	add    rdx,0xfffffffffffffff0
  21bcd0:	48 89 d0             	mov    rax,rdx
  21bcd3:	eb 3f                	jmp    21bd14 <Benchmark_reportStats+0x55d4>
  21bcd5:	4c 89 6c 24 50       	mov    QWORD PTR [rsp+0x50],r13
  21bcda:	e9 46 cb ff ff       	jmp    218825 <Benchmark_reportStats+0x20e5>
                        if (pull[0].range.start == A.start) pull[0].range.end -= pull[1].count;
  21bcdf:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
  21bce4:	48 39 84 24 98 00 00 	cmp    QWORD PTR [rsp+0x98],rax
  21bceb:	00 
  21bcec:	75 10                	jne    21bcfe <Benchmark_reportStats+0x55be>
  21bcee:	48 8b 84 24 b8 00 00 	mov    rax,QWORD PTR [rsp+0xb8]
  21bcf5:	00 
  21bcf6:	48 29 84 24 a0 00 00 	sub    QWORD PTR [rsp+0xa0],rax
  21bcfd:	00 
                        buffer2 = Range.init(B.end - count, B.end);
  21bcfe:	48 89 c8             	mov    rax,rcx
  21bd01:	4c 29 c0             	sub    rax,r8
  21bd04:	4c 89 ac 24 d0 00 00 	mov    QWORD PTR [rsp+0xd0],r13
  21bd0b:	00 
  21bd0c:	e9 14 cb ff ff       	jmp    218825 <Benchmark_reportStats+0x20e5>
  21bd11:	4c 89 c8             	mov    rax,r9
            items[j] = x;
  21bd14:	c5 fa 7f 00          	vmovdqu XMMWORD PTR [rax],xmm0
  21bd18:	31 c0                	xor    eax,eax
  21bd1a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  21bd20:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
                var unique = pull[pull_index].count * 2;
  21bd25:	48 8d 04 80          	lea    rax,[rax+rax*4]
  21bd29:	4c 8b 94 c4 90 00 00 	mov    r10,QWORD PTR [rsp+rax*8+0x90]
  21bd30:	00 
  21bd31:	4f 8d 34 12          	lea    r14,[r10+r10*1]
                if (pull[pull_index].from > pull[pull_index].to) {
  21bd35:	48 8b 8c c4 88 00 00 	mov    rcx,QWORD PTR [rsp+rax*8+0x88]
  21bd3c:	00 
  21bd3d:	48 39 8c c4 80 00 00 	cmp    QWORD PTR [rsp+rax*8+0x80],rcx
  21bd44:	00 
  21bd45:	76 29                	jbe    21bd70 <Benchmark_reportStats+0x5630>
                    while (buffer.length() > 0) {
  21bd47:	4d 85 d2             	test   r10,r10
  21bd4a:	0f 84 c2 0b 00 00    	je     21c912 <Benchmark_reportStats+0x61d2>
  21bd50:	4c 8b a4 c4 98 00 00 	mov    r12,QWORD PTR [rsp+rax*8+0x98]
  21bd57:	00 
                    var buffer = Range.init(pull[pull_index].range.start, pull[pull_index].range.start + pull[pull_index].count);
  21bd58:	4b 8d 0c 14          	lea    rcx,[r12+r10*1]
  21bd5c:	48 8d 04 c4          	lea    rax,[rsp+rax*8]
  21bd60:	48 05 a0 00 00 00    	add    rax,0xa0
  21bd66:	48 89 44 24 20       	mov    QWORD PTR [rsp+0x20],rax
  21bd6b:	e9 d0 05 00 00       	jmp    21c340 <Benchmark_reportStats+0x5c00>
                } else if (pull[pull_index].from < pull[pull_index].to) {
  21bd70:	0f 83 9c 0b 00 00    	jae    21c912 <Benchmark_reportStats+0x61d2>
                    while (buffer.length() > 0) {
  21bd76:	4d 85 d2             	test   r10,r10
  21bd79:	0f 84 93 0b 00 00    	je     21c912 <Benchmark_reportStats+0x61d2>
  21bd7f:	4c 8b 9c c4 a0 00 00 	mov    r11,QWORD PTR [rsp+rax*8+0xa0]
  21bd86:	00 
                    var buffer = Range.init(pull[pull_index].range.end - pull[pull_index].count, pull[pull_index].range.end);
  21bd87:	4d 89 df             	mov    r15,r11
  21bd8a:	4d 29 d7             	sub    r15,r10
  21bd8d:	48 8d 04 c4          	lea    rax,[rsp+rax*8]
  21bd91:	48 05 98 00 00 00    	add    rax,0x98
  21bd97:	48 89 44 24 38       	mov    QWORD PTR [rsp+0x38],rax
  21bd9c:	eb 12                	jmp    21bdb0 <Benchmark_reportStats+0x5670>
  21bd9e:	48 89 d3             	mov    rbx,rdx
    if (range.start >= range.end) return range.end;
  21bda1:	48 85 c0             	test   rax,rax
  21bda4:	0f 85 af 00 00 00    	jne    21be59 <Benchmark_reportStats+0x5719>
  21bdaa:	e9 6d 01 00 00       	jmp    21bf1c <Benchmark_reportStats+0x57dc>
  21bdaf:	90                   	nop
  21bdb0:	4c 89 fe             	mov    rsi,r15
                        index = findLastBackward(T, items, items[buffer.end - 1], Range.init(pull[pull_index].range.start, buffer.start), lessThan, unique);
  21bdb3:	49 8d 7b ff          	lea    rdi,[r11-0x1]
  21bdb7:	4c 8b 6c 24 40       	mov    r13,QWORD PTR [rsp+0x40]
  21bdbc:	48 8b 44 24 38       	mov    rax,QWORD PTR [rsp+0x38]
  21bdc1:	4c 8b 38             	mov    r15,QWORD PTR [rax]
    if (range.length() == 0) return range.start;
  21bdc4:	48 89 f0             	mov    rax,rsi
  21bdc7:	4c 29 f8             	sub    rax,r15
  21bdca:	48 89 7c 24 18       	mov    QWORD PTR [rsp+0x18],rdi
  21bdcf:	0f 84 52 01 00 00    	je     21bf27 <Benchmark_reportStats+0x57e7>
  21bdd5:	49 89 f8             	mov    r8,rdi
  21bdd8:	49 c1 e0 04          	shl    r8,0x4
  21bddc:	48 89 c1             	mov    rcx,rax
  21bddf:	4c 09 f1             	or     rcx,r14
  21bde2:	48 c1 e9 20          	shr    rcx,0x20
  21bde6:	74 08                	je     21bdf0 <Benchmark_reportStats+0x56b0>
  21bde8:	31 d2                	xor    edx,edx
  21bdea:	49 f7 f6             	div    r14
  21bded:	eb 06                	jmp    21bdf5 <Benchmark_reportStats+0x56b5>
  21bdef:	90                   	nop
  21bdf0:	31 d2                	xor    edx,edx
  21bdf2:	41 f7 f6             	div    r14d
  21bdf5:	4d 01 e8             	add    r8,r13
    return if (x > y) x else y;
  21bdf8:	48 83 f8 01          	cmp    rax,0x1
  21bdfc:	b9 01 00 00 00       	mov    ecx,0x1
  21be01:	48 0f 46 c1          	cmovbe rax,rcx
  21be05:	48 89 f3             	mov    rbx,rsi
  21be08:	48 29 c3             	sub    rbx,rax
    while (index > range.start and lessThan(value, items[index - 1])) : (index -= skip) {
  21be0b:	4c 39 fb             	cmp    rbx,r15
  21be0e:	0f 86 fc 00 00 00    	jbe    21bf10 <Benchmark_reportStats+0x57d0>
  21be14:	4d 8b 08             	mov    r9,QWORD PTR [r8]
  21be17:	4a 8d 0c 38          	lea    rcx,[rax+r15*1]
  21be1b:	49 89 f2             	mov    r10,rsi
  21be1e:	66 90                	xchg   ax,ax
  21be20:	48 89 da             	mov    rdx,rbx
  21be23:	48 8d 7a ff          	lea    rdi,[rdx-0x1]
  21be27:	48 89 fb             	mov    rbx,rdi
  21be2a:	48 c1 e3 04          	shl    rbx,0x4
  21be2e:	4d 3b 4c 1d 00       	cmp    r9,QWORD PTR [r13+rbx*1+0x0]
  21be33:	0f 83 65 ff ff ff    	jae    21bd9e <Benchmark_reportStats+0x565e>
        if (index < range.start + skip) {
  21be39:	48 39 ca             	cmp    rdx,rcx
  21be3c:	0f 82 95 00 00 00    	jb     21bed7 <Benchmark_reportStats+0x5797>
  21be42:	48 89 d3             	mov    rbx,rdx
  21be45:	48 29 c3             	sub    rbx,rax
  21be48:	49 89 d2             	mov    r10,rdx
    while (index > range.start and lessThan(value, items[index - 1])) : (index -= skip) {
  21be4b:	4c 39 fb             	cmp    rbx,r15
  21be4e:	77 d0                	ja     21be20 <Benchmark_reportStats+0x56e0>
    if (range.start >= range.end) return range.end;
  21be50:	48 85 c0             	test   rax,rax
  21be53:	0f 84 c3 00 00 00    	je     21bf1c <Benchmark_reportStats+0x57dc>
    var end = range.end - 1;
  21be59:	49 83 c2 ff          	add    r10,0xffffffffffffffff
    while (start < end) {
  21be5d:	49 39 da             	cmp    r10,rbx
  21be60:	76 46                	jbe    21bea8 <Benchmark_reportStats+0x5768>
  21be62:	4d 8b 08             	mov    r9,QWORD PTR [r8]
  21be65:	4c 89 d1             	mov    rcx,r10
  21be68:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  21be6f:	00 
        const mid = start + (end - start) / 2;
  21be70:	48 89 ca             	mov    rdx,rcx
  21be73:	48 29 da             	sub    rdx,rbx
  21be76:	48 d1 ea             	shr    rdx,1
  21be79:	48 8d 04 1a          	lea    rax,[rdx+rbx*1]
  21be7d:	48 89 c7             	mov    rdi,rax
  21be80:	48 c1 e7 04          	shl    rdi,0x4
  21be84:	4d 3b 4c 3d 00       	cmp    r9,QWORD PTR [r13+rdi*1+0x0]
        if (!lessThan(value, items[mid])) {
  21be89:	72 15                	jb     21bea0 <Benchmark_reportStats+0x5760>
  21be8b:	48 01 d3             	add    rbx,rdx
  21be8e:	48 83 c3 01          	add    rbx,0x1
    while (start < end) {
  21be92:	48 39 d9             	cmp    rcx,rbx
  21be95:	77 d9                	ja     21be70 <Benchmark_reportStats+0x5730>
  21be97:	eb 0f                	jmp    21bea8 <Benchmark_reportStats+0x5768>
  21be99:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
        if (!lessThan(value, items[mid])) {
  21bea0:	48 89 c1             	mov    rcx,rax
    while (start < end) {
  21bea3:	48 39 d9             	cmp    rcx,rbx
  21bea6:	77 c8                	ja     21be70 <Benchmark_reportStats+0x5730>
    if (start == range.end - 1 and !lessThan(value, items[start])) {
  21bea8:	4c 39 d3             	cmp    rbx,r10
  21beab:	75 74                	jne    21bf21 <Benchmark_reportStats+0x57e1>
  21bead:	49 8b 00             	mov    rax,QWORD PTR [r8]
  21beb0:	49 c1 e2 04          	shl    r10,0x4
  21beb4:	45 31 ff             	xor    r15d,r15d
  21beb7:	4b 3b 44 15 00       	cmp    rax,QWORD PTR [r13+r10*1+0x0]
  21bebc:	41 0f 93 c7          	setae  r15b
  21bec0:	eb 62                	jmp    21bf24 <Benchmark_reportStats+0x57e4>
  21bec2:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21bec9:	1f 84 00 00 00 00 00 
  21bed0:	49 01 c7             	add    r15,rax
  21bed3:	49 83 c7 01          	add    r15,0x1
    while (start < end) {
  21bed7:	4c 39 ff             	cmp    rdi,r15
  21beda:	76 4b                	jbe    21bf27 <Benchmark_reportStats+0x57e7>
        const mid = start + (end - start) / 2;
  21bedc:	48 89 f8             	mov    rax,rdi
  21bedf:	4c 29 f8             	sub    rax,r15
  21bee2:	48 d1 e8             	shr    rax,1
  21bee5:	4a 8d 0c 38          	lea    rcx,[rax+r15*1]
  21bee9:	48 89 ca             	mov    rdx,rcx
  21beec:	48 c1 e2 04          	shl    rdx,0x4
  21bef0:	4d 3b 4c 15 00       	cmp    r9,QWORD PTR [r13+rdx*1+0x0]
        if (!lessThan(value, items[mid])) {
  21bef5:	73 d9                	jae    21bed0 <Benchmark_reportStats+0x5790>
  21bef7:	48 89 cf             	mov    rdi,rcx
    while (start < end) {
  21befa:	4c 39 ff             	cmp    rdi,r15
  21befd:	77 dd                	ja     21bedc <Benchmark_reportStats+0x579c>
  21beff:	eb 26                	jmp    21bf27 <Benchmark_reportStats+0x57e7>
  21bf01:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21bf08:	0f 1f 84 00 00 00 00 
  21bf0f:	00 
  21bf10:	49 89 f2             	mov    r10,rsi
    if (range.start >= range.end) return range.end;
  21bf13:	48 85 c0             	test   rax,rax
  21bf16:	0f 85 3d ff ff ff    	jne    21be59 <Benchmark_reportStats+0x5719>
  21bf1c:	4d 89 d7             	mov    r15,r10
  21bf1f:	eb 06                	jmp    21bf27 <Benchmark_reportStats+0x57e7>
  21bf21:	45 31 ff             	xor    r15d,r15d
    if (start == range.end - 1 and !lessThan(value, items[start])) {
  21bf24:	49 01 df             	add    r15,rbx
                        const amount = buffer.start - index;
  21bf27:	49 89 f4             	mov    r12,rsi
  21bf2a:	4d 29 fc             	sub    r12,r15
                        mem.rotate(T, items[index..buffer.end], amount);
  21bf2d:	4d 89 fa             	mov    r10,r15
  21bf30:	49 c1 e2 04          	shl    r10,0x4
  21bf34:	4d 89 d8             	mov    r8,r11
  21bf37:	4d 29 f8             	sub    r8,r15
    const end = items.len / 2;
  21bf3a:	4c 89 e7             	mov    rdi,r12
  21bf3d:	48 d1 ef             	shr    rdi,1
    while (i < end) : (i += 1) {
  21bf40:	0f 84 32 01 00 00    	je     21c078 <Benchmark_reportStats+0x5938>
        swap(T, &items[i], &items[items.len - i - 1]);
  21bf46:	48 8d 47 ff          	lea    rax,[rdi-0x1]
  21bf4a:	89 fa                	mov    edx,edi
  21bf4c:	83 e2 03             	and    edx,0x3
  21bf4f:	48 83 f8 03          	cmp    rax,0x3
  21bf53:	73 1b                	jae    21bf70 <Benchmark_reportStats+0x5830>
  21bf55:	31 c0                	xor    eax,eax
    while (i < end) : (i += 1) {
  21bf57:	48 85 d2             	test   rdx,rdx
  21bf5a:	0f 85 c6 00 00 00    	jne    21c026 <Benchmark_reportStats+0x58e6>
  21bf60:	e9 13 01 00 00       	jmp    21c078 <Benchmark_reportStats+0x5938>
  21bf65:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21bf6c:	00 00 00 00 
        swap(T, &items[i], &items[items.len - i - 1]);
  21bf70:	48 29 d7             	sub    rdi,rdx
  21bf73:	4b 8d 0c 2a          	lea    rcx,[r10+r13*1]
  21bf77:	48 83 c1 30          	add    rcx,0x30
  21bf7b:	48 89 f0             	mov    rax,rsi
  21bf7e:	48 c1 e0 04          	shl    rax,0x4
  21bf82:	4e 8d 0c 28          	lea    r9,[rax+r13*1]
  21bf86:	49 83 c1 f0          	add    r9,0xfffffffffffffff0
  21bf8a:	31 c0                	xor    eax,eax
  21bf8c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
    const tmp = a.*;
  21bf90:	c5 f8 10 41 d0       	vmovups xmm0,XMMWORD PTR [rcx-0x30]
  21bf95:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21bf9a:	c4 c1 78 10 01       	vmovups xmm0,XMMWORD PTR [r9]
  21bf9f:	c5 f8 11 41 d0       	vmovups XMMWORD PTR [rcx-0x30],xmm0
    b.* = tmp;
  21bfa4:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  21bfa9:	c4 c1 78 11 01       	vmovups XMMWORD PTR [r9],xmm0
    const tmp = a.*;
  21bfae:	c5 f8 10 41 e0       	vmovups xmm0,XMMWORD PTR [rcx-0x20]
  21bfb3:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21bfb8:	c4 c1 78 10 41 f0    	vmovups xmm0,XMMWORD PTR [r9-0x10]
  21bfbe:	c5 f8 11 41 e0       	vmovups XMMWORD PTR [rcx-0x20],xmm0
    b.* = tmp;
  21bfc3:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  21bfc8:	c4 c1 78 11 41 f0    	vmovups XMMWORD PTR [r9-0x10],xmm0
    const tmp = a.*;
  21bfce:	c5 f8 10 41 f0       	vmovups xmm0,XMMWORD PTR [rcx-0x10]
  21bfd3:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21bfd8:	c4 c1 78 10 41 e0    	vmovups xmm0,XMMWORD PTR [r9-0x20]
  21bfde:	c5 f8 11 41 f0       	vmovups XMMWORD PTR [rcx-0x10],xmm0
    b.* = tmp;
  21bfe3:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  21bfe8:	c4 c1 78 11 41 e0    	vmovups XMMWORD PTR [r9-0x20],xmm0
    const tmp = a.*;
  21bfee:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  21bff2:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21bff7:	c4 c1 78 10 41 d0    	vmovups xmm0,XMMWORD PTR [r9-0x30]
  21bffd:	c5 f8 11 01          	vmovups XMMWORD PTR [rcx],xmm0
    b.* = tmp;
  21c001:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  21c006:	c4 c1 7a 7f 41 d0    	vmovdqu XMMWORD PTR [r9-0x30],xmm0
    while (i < end) : (i += 1) {
  21c00c:	48 83 c0 04          	add    rax,0x4
  21c010:	48 83 c1 40          	add    rcx,0x40
  21c014:	49 83 c1 c0          	add    r9,0xffffffffffffffc0
  21c018:	48 39 c7             	cmp    rdi,rax
  21c01b:	0f 85 6f ff ff ff    	jne    21bf90 <Benchmark_reportStats+0x5850>
  21c021:	48 85 d2             	test   rdx,rdx
  21c024:	74 52                	je     21c078 <Benchmark_reportStats+0x5938>
  21c026:	48 89 f1             	mov    rcx,rsi
  21c029:	48 29 c1             	sub    rcx,rax
  21c02c:	48 c1 e1 04          	shl    rcx,0x4
  21c030:	4c 01 e9             	add    rcx,r13
  21c033:	48 83 c1 f0          	add    rcx,0xfffffffffffffff0
  21c037:	4c 01 f8             	add    rax,r15
  21c03a:	48 c1 e0 04          	shl    rax,0x4
  21c03e:	4c 01 e8             	add    rax,r13
  21c041:	48 f7 da             	neg    rdx
  21c044:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21c04b:	00 00 00 00 00 
    const tmp = a.*;
  21c050:	c5 f8 10 00          	vmovups xmm0,XMMWORD PTR [rax]
  21c054:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21c059:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  21c05d:	c5 f8 11 00          	vmovups XMMWORD PTR [rax],xmm0
    b.* = tmp;
  21c061:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  21c066:	c5 fa 7f 01          	vmovdqu XMMWORD PTR [rcx],xmm0
    while (i < end) : (i += 1) {
  21c06a:	48 83 c1 f0          	add    rcx,0xfffffffffffffff0
  21c06e:	48 83 c0 10          	add    rax,0x10
  21c072:	48 83 c2 01          	add    rdx,0x1
  21c076:	75 d8                	jne    21c050 <Benchmark_reportStats+0x5910>
    reverse(T, items[amount..]);
  21c078:	4c 89 c0             	mov    rax,r8
  21c07b:	4c 29 e0             	sub    rax,r12
    const end = items.len / 2;
  21c07e:	48 d1 e8             	shr    rax,1
  21c081:	4c 8b 4c 24 18       	mov    r9,QWORD PTR [rsp+0x18]
    while (i < end) : (i += 1) {
  21c086:	0f 84 2c 01 00 00    	je     21c1b8 <Benchmark_reportStats+0x5a78>
        swap(T, &items[i], &items[items.len - i - 1]);
  21c08c:	48 8d 48 ff          	lea    rcx,[rax-0x1]
  21c090:	89 c2                	mov    edx,eax
  21c092:	83 e2 03             	and    edx,0x3
  21c095:	48 83 f9 03          	cmp    rcx,0x3
  21c099:	73 15                	jae    21c0b0 <Benchmark_reportStats+0x5970>
  21c09b:	31 c9                	xor    ecx,ecx
    while (i < end) : (i += 1) {
  21c09d:	48 85 d2             	test   rdx,rdx
  21c0a0:	0f 85 c8 00 00 00    	jne    21c16e <Benchmark_reportStats+0x5a2e>
  21c0a6:	e9 0d 01 00 00       	jmp    21c1b8 <Benchmark_reportStats+0x5a78>
  21c0ab:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
        swap(T, &items[i], &items[items.len - i - 1]);
  21c0b0:	48 29 d0             	sub    rax,rdx
  21c0b3:	48 89 f1             	mov    rcx,rsi
  21c0b6:	48 c1 e1 04          	shl    rcx,0x4
  21c0ba:	4a 8d 3c 29          	lea    rdi,[rcx+r13*1]
  21c0be:	48 83 c7 30          	add    rdi,0x30
  21c0c2:	4c 89 d9             	mov    rcx,r11
  21c0c5:	48 c1 e1 04          	shl    rcx,0x4
  21c0c9:	4a 8d 1c 29          	lea    rbx,[rcx+r13*1]
  21c0cd:	48 83 c3 f0          	add    rbx,0xfffffffffffffff0
  21c0d1:	31 c9                	xor    ecx,ecx
  21c0d3:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21c0da:	84 00 00 00 00 00 
    const tmp = a.*;
  21c0e0:	c5 f8 10 47 d0       	vmovups xmm0,XMMWORD PTR [rdi-0x30]
  21c0e5:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21c0ea:	c5 f8 10 03          	vmovups xmm0,XMMWORD PTR [rbx]
  21c0ee:	c5 f8 11 47 d0       	vmovups XMMWORD PTR [rdi-0x30],xmm0
    b.* = tmp;
  21c0f3:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  21c0f8:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
    const tmp = a.*;
  21c0fc:	c5 f8 10 47 e0       	vmovups xmm0,XMMWORD PTR [rdi-0x20]
  21c101:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21c106:	c5 f8 10 43 f0       	vmovups xmm0,XMMWORD PTR [rbx-0x10]
  21c10b:	c5 f8 11 47 e0       	vmovups XMMWORD PTR [rdi-0x20],xmm0
    b.* = tmp;
  21c110:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  21c115:	c5 f8 11 43 f0       	vmovups XMMWORD PTR [rbx-0x10],xmm0
    const tmp = a.*;
  21c11a:	c5 f8 10 47 f0       	vmovups xmm0,XMMWORD PTR [rdi-0x10]
  21c11f:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21c124:	c5 f8 10 43 e0       	vmovups xmm0,XMMWORD PTR [rbx-0x20]
  21c129:	c5 f8 11 47 f0       	vmovups XMMWORD PTR [rdi-0x10],xmm0
    b.* = tmp;
  21c12e:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  21c133:	c5 f8 11 43 e0       	vmovups XMMWORD PTR [rbx-0x20],xmm0
    const tmp = a.*;
  21c138:	c5 f8 10 07          	vmovups xmm0,XMMWORD PTR [rdi]
  21c13c:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21c141:	c5 f8 10 43 d0       	vmovups xmm0,XMMWORD PTR [rbx-0x30]
  21c146:	c5 f8 11 07          	vmovups XMMWORD PTR [rdi],xmm0
    b.* = tmp;
  21c14a:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  21c14f:	c5 fa 7f 43 d0       	vmovdqu XMMWORD PTR [rbx-0x30],xmm0
    while (i < end) : (i += 1) {
  21c154:	48 83 c1 04          	add    rcx,0x4
  21c158:	48 83 c7 40          	add    rdi,0x40
  21c15c:	48 83 c3 c0          	add    rbx,0xffffffffffffffc0
  21c160:	48 39 c8             	cmp    rax,rcx
  21c163:	0f 85 77 ff ff ff    	jne    21c0e0 <Benchmark_reportStats+0x59a0>
  21c169:	48 85 d2             	test   rdx,rdx
  21c16c:	74 4a                	je     21c1b8 <Benchmark_reportStats+0x5a78>
  21c16e:	4c 89 d8             	mov    rax,r11
  21c171:	48 29 c8             	sub    rax,rcx
  21c174:	48 c1 e0 04          	shl    rax,0x4
  21c178:	4c 01 e8             	add    rax,r13
  21c17b:	48 83 c0 f0          	add    rax,0xfffffffffffffff0
  21c17f:	48 01 ce             	add    rsi,rcx
  21c182:	48 c1 e6 04          	shl    rsi,0x4
  21c186:	4c 01 ee             	add    rsi,r13
  21c189:	48 f7 da             	neg    rdx
  21c18c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
    const tmp = a.*;
  21c190:	c5 f8 10 06          	vmovups xmm0,XMMWORD PTR [rsi]
  21c194:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21c199:	c5 f8 10 00          	vmovups xmm0,XMMWORD PTR [rax]
  21c19d:	c5 f8 11 06          	vmovups XMMWORD PTR [rsi],xmm0
    b.* = tmp;
  21c1a1:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  21c1a6:	c5 fa 7f 00          	vmovdqu XMMWORD PTR [rax],xmm0
    while (i < end) : (i += 1) {
  21c1aa:	48 83 c0 f0          	add    rax,0xfffffffffffffff0
  21c1ae:	48 83 c6 10          	add    rsi,0x10
  21c1b2:	48 83 c2 01          	add    rdx,0x1
  21c1b6:	75 d8                	jne    21c190 <Benchmark_reportStats+0x5a50>
    const end = items.len / 2;
  21c1b8:	4c 89 c2             	mov    rdx,r8
  21c1bb:	48 d1 ea             	shr    rdx,1
    while (i < end) : (i += 1) {
  21c1be:	0f 84 5c 01 00 00    	je     21c320 <Benchmark_reportStats+0x5be0>
  21c1c4:	4b 8d 04 2a          	lea    rax,[r10+r13*1]
    const tmp = a.*;
  21c1c8:	c5 f8 10 00          	vmovups xmm0,XMMWORD PTR [rax]
  21c1cc:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  21c1d1:	49 c1 e0 04          	shl    r8,0x4
    a.* = b.*;
  21c1d5:	c4 a1 78 10 44 00 f0 	vmovups xmm0,XMMWORD PTR [rax+r8*1-0x10]
  21c1dc:	c5 f8 11 00          	vmovups XMMWORD PTR [rax],xmm0
    b.* = tmp;
  21c1e0:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  21c1e5:	c4 a1 7a 7f 44 00 f0 	vmovdqu XMMWORD PTR [rax+r8*1-0x10],xmm0
    while (i < end) : (i += 1) {
  21c1ec:	48 83 fa 01          	cmp    rdx,0x1
  21c1f0:	0f 84 2a 01 00 00    	je     21c320 <Benchmark_reportStats+0x5be0>
        swap(T, &items[i], &items[items.len - i - 1]);
  21c1f6:	8d 72 ff             	lea    esi,[rdx-0x1]
  21c1f9:	48 8d 42 fe          	lea    rax,[rdx-0x2]
  21c1fd:	83 e6 03             	and    esi,0x3
  21c200:	48 83 f8 03          	cmp    rax,0x3
  21c204:	73 13                	jae    21c219 <Benchmark_reportStats+0x5ad9>
  21c206:	b8 01 00 00 00       	mov    eax,0x1
    while (i < end) : (i += 1) {
  21c20b:	48 85 f6             	test   rsi,rsi
  21c20e:	0f 85 ba 00 00 00    	jne    21c2ce <Benchmark_reportStats+0x5b8e>
  21c214:	e9 07 01 00 00       	jmp    21c320 <Benchmark_reportStats+0x5be0>
        swap(T, &items[i], &items[items.len - i - 1]);
  21c219:	4c 89 d8             	mov    rax,r11
  21c21c:	48 c1 e0 04          	shl    rax,0x4
  21c220:	4a 8d 0c 28          	lea    rcx,[rax+r13*1]
  21c224:	48 83 c1 e0          	add    rcx,0xffffffffffffffe0
  21c228:	4b 8d 3c 2a          	lea    rdi,[r10+r13*1]
  21c22c:	48 83 c7 40          	add    rdi,0x40
  21c230:	48 29 f2             	sub    rdx,rsi
  21c233:	b8 01 00 00 00       	mov    eax,0x1
  21c238:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  21c23f:	00 
    const tmp = a.*;
  21c240:	c5 f8 10 47 d0       	vmovups xmm0,XMMWORD PTR [rdi-0x30]
  21c245:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21c24a:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  21c24e:	c5 f8 11 47 d0       	vmovups XMMWORD PTR [rdi-0x30],xmm0
    b.* = tmp;
  21c253:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  21c258:	c5 f8 11 01          	vmovups XMMWORD PTR [rcx],xmm0
    const tmp = a.*;
  21c25c:	c5 f8 10 47 e0       	vmovups xmm0,XMMWORD PTR [rdi-0x20]
  21c261:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21c266:	c5 f8 10 41 f0       	vmovups xmm0,XMMWORD PTR [rcx-0x10]
  21c26b:	c5 f8 11 47 e0       	vmovups XMMWORD PTR [rdi-0x20],xmm0
    b.* = tmp;
  21c270:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  21c275:	c5 f8 11 41 f0       	vmovups XMMWORD PTR [rcx-0x10],xmm0
    const tmp = a.*;
  21c27a:	c5 f8 10 47 f0       	vmovups xmm0,XMMWORD PTR [rdi-0x10]
  21c27f:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21c284:	c5 f8 10 41 e0       	vmovups xmm0,XMMWORD PTR [rcx-0x20]
  21c289:	c5 f8 11 47 f0       	vmovups XMMWORD PTR [rdi-0x10],xmm0
    b.* = tmp;
  21c28e:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  21c293:	c5 f8 11 41 e0       	vmovups XMMWORD PTR [rcx-0x20],xmm0
    const tmp = a.*;
  21c298:	c5 f8 10 07          	vmovups xmm0,XMMWORD PTR [rdi]
  21c29c:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21c2a1:	c5 f8 10 41 d0       	vmovups xmm0,XMMWORD PTR [rcx-0x30]
  21c2a6:	c5 f8 11 07          	vmovups XMMWORD PTR [rdi],xmm0
    b.* = tmp;
  21c2aa:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  21c2af:	c5 fa 7f 41 d0       	vmovdqu XMMWORD PTR [rcx-0x30],xmm0
    while (i < end) : (i += 1) {
  21c2b4:	48 83 c0 04          	add    rax,0x4
  21c2b8:	48 83 c1 c0          	add    rcx,0xffffffffffffffc0
  21c2bc:	48 83 c7 40          	add    rdi,0x40
  21c2c0:	48 39 c2             	cmp    rdx,rax
  21c2c3:	0f 85 77 ff ff ff    	jne    21c240 <Benchmark_reportStats+0x5b00>
  21c2c9:	48 85 f6             	test   rsi,rsi
  21c2cc:	74 52                	je     21c320 <Benchmark_reportStats+0x5be0>
  21c2ce:	49 29 c3             	sub    r11,rax
  21c2d1:	49 c1 e3 04          	shl    r11,0x4
  21c2d5:	4b 8d 0c 2b          	lea    rcx,[r11+r13*1]
  21c2d9:	48 83 c1 f0          	add    rcx,0xfffffffffffffff0
  21c2dd:	4c 01 f8             	add    rax,r15
  21c2e0:	48 c1 e0 04          	shl    rax,0x4
  21c2e4:	4c 01 e8             	add    rax,r13
  21c2e7:	48 f7 de             	neg    rsi
  21c2ea:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
    const tmp = a.*;
  21c2f0:	c5 f8 10 00          	vmovups xmm0,XMMWORD PTR [rax]
  21c2f4:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21c2f9:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  21c2fd:	c5 f8 11 00          	vmovups XMMWORD PTR [rax],xmm0
    b.* = tmp;
  21c301:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  21c306:	c5 fa 7f 01          	vmovdqu XMMWORD PTR [rcx],xmm0
    while (i < end) : (i += 1) {
  21c30a:	48 83 c1 f0          	add    rcx,0xfffffffffffffff0
  21c30e:	48 83 c0 10          	add    rax,0x10
  21c312:	48 83 c6 01          	add    rsi,0x1
  21c316:	75 d8                	jne    21c2f0 <Benchmark_reportStats+0x5bb0>
  21c318:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  21c31f:	00 
                        buffer.end -= (amount + 1);
  21c320:	4d 29 e1             	sub    r9,r12
                        unique -= 2;
  21c323:	49 83 c6 fe          	add    r14,0xfffffffffffffffe
  21c327:	4d 89 cb             	mov    r11,r9
                    while (buffer.length() > 0) {
  21c32a:	4d 39 f9             	cmp    r9,r15
  21c32d:	0f 85 7d fa ff ff    	jne    21bdb0 <Benchmark_reportStats+0x5670>
  21c333:	e9 da 05 00 00       	jmp    21c912 <Benchmark_reportStats+0x61d2>
  21c338:	31 c9                	xor    ecx,ecx
  21c33a:	e9 1e 01 00 00       	jmp    21c45d <Benchmark_reportStats+0x5d1d>
  21c33f:	90                   	nop
  21c340:	49 89 cf             	mov    r15,rcx
                        index = findFirstForward(T, items, items[buffer.start], Range.init(buffer.end, pull[pull_index].range.end), lessThan, unique);
  21c343:	4c 8b 5c 24 40       	mov    r11,QWORD PTR [rsp+0x40]
  21c348:	4c 89 e0             	mov    rax,r12
  21c34b:	48 c1 e0 04          	shl    rax,0x4
  21c34f:	48 89 44 24 38       	mov    QWORD PTR [rsp+0x38],rax
  21c354:	49 8d 04 03          	lea    rax,[r11+rax*1]
  21c358:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  21c35d:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
  21c362:	4c 8b 28             	mov    r13,QWORD PTR [rax]
    if (range.length() == 0) return range.start;
  21c365:	4c 89 e8             	mov    rax,r13
  21c368:	4c 29 f8             	sub    rax,r15
  21c36b:	0f 84 7f 01 00 00    	je     21c4f0 <Benchmark_reportStats+0x5db0>
  21c371:	48 89 c1             	mov    rcx,rax
  21c374:	4c 09 f1             	or     rcx,r14
  21c377:	48 c1 e9 20          	shr    rcx,0x20
  21c37b:	74 13                	je     21c390 <Benchmark_reportStats+0x5c50>
  21c37d:	31 d2                	xor    edx,edx
  21c37f:	49 f7 f6             	div    r14
  21c382:	eb 11                	jmp    21c395 <Benchmark_reportStats+0x5c55>
  21c384:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21c38b:	00 00 00 00 00 
  21c390:	31 d2                	xor    edx,edx
  21c392:	41 f7 f6             	div    r14d
  21c395:	48 83 f8 01          	cmp    rax,0x1
  21c399:	b9 01 00 00 00       	mov    ecx,0x1
  21c39e:	48 0f 46 c1          	cmovbe rax,rcx
  21c3a2:	4a 8d 0c 38          	lea    rcx,[rax+r15*1]
    while (lessThan(items[index - 1], value)) : (index += skip) {
  21c3a6:	4e 8d 04 38          	lea    r8,[rax+r15*1]
  21c3aa:	49 83 c0 ff          	add    r8,0xffffffffffffffff
  21c3ae:	4c 89 c2             	mov    rdx,r8
  21c3b1:	48 c1 e2 04          	shl    rdx,0x4
  21c3b5:	4d 8b 0c 13          	mov    r9,QWORD PTR [r11+rdx*1]
  21c3b9:	48 8b 54 24 18       	mov    rdx,QWORD PTR [rsp+0x18]
  21c3be:	48 8b 3a             	mov    rdi,QWORD PTR [rdx]
  21c3c1:	49 39 f9             	cmp    r9,rdi
  21c3c4:	0f 83 a6 00 00 00    	jae    21c470 <Benchmark_reportStats+0x5d30>
  21c3ca:	4c 89 ee             	mov    rsi,r13
  21c3cd:	48 29 c6             	sub    rsi,rax
  21c3d0:	48 89 ca             	mov    rdx,rcx
        if (index >= range.end - skip) {
  21c3d3:	48 39 f2             	cmp    rdx,rsi
  21c3d6:	0f 83 9e 00 00 00    	jae    21c47a <Benchmark_reportStats+0x5d3a>
  21c3dc:	48 8d 0c 02          	lea    rcx,[rdx+rax*1]
    while (lessThan(items[index - 1], value)) : (index += skip) {
  21c3e0:	4c 8d 04 02          	lea    r8,[rdx+rax*1]
  21c3e4:	49 83 c0 ff          	add    r8,0xffffffffffffffff
  21c3e8:	4c 89 c3             	mov    rbx,r8
  21c3eb:	48 c1 e3 04          	shl    rbx,0x4
  21c3ef:	4d 8b 0c 1b          	mov    r9,QWORD PTR [r11+rbx*1]
  21c3f3:	49 39 f9             	cmp    r9,rdi
  21c3f6:	72 d8                	jb     21c3d0 <Benchmark_reportStats+0x5c90>
    if (range.start >= range.end) return range.end;
  21c3f8:	48 85 c0             	test   rax,rax
  21c3fb:	0f 84 ef 00 00 00    	je     21c4f0 <Benchmark_reportStats+0x5db0>
    while (start < end) {
  21c401:	49 39 d0             	cmp    r8,rdx
  21c404:	76 46                	jbe    21c44c <Benchmark_reportStats+0x5d0c>
  21c406:	4c 89 c0             	mov    rax,r8
  21c409:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
        const mid = start + (end - start) / 2;
  21c410:	48 89 c1             	mov    rcx,rax
  21c413:	48 29 d1             	sub    rcx,rdx
  21c416:	48 d1 e9             	shr    rcx,1
  21c419:	48 8d 34 11          	lea    rsi,[rcx+rdx*1]
  21c41d:	48 89 f3             	mov    rbx,rsi
  21c420:	48 c1 e3 04          	shl    rbx,0x4
  21c424:	49 39 3c 1b          	cmp    QWORD PTR [r11+rbx*1],rdi
        if (lessThan(items[mid], value)) {
  21c428:	72 16                	jb     21c440 <Benchmark_reportStats+0x5d00>
  21c42a:	48 89 f0             	mov    rax,rsi
    while (start < end) {
  21c42d:	48 39 d0             	cmp    rax,rdx
  21c430:	77 de                	ja     21c410 <Benchmark_reportStats+0x5cd0>
  21c432:	eb 18                	jmp    21c44c <Benchmark_reportStats+0x5d0c>
  21c434:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21c43b:	00 00 00 00 00 
  21c440:	48 01 ca             	add    rdx,rcx
  21c443:	48 83 c2 01          	add    rdx,0x1
  21c447:	48 39 d0             	cmp    rax,rdx
  21c44a:	77 c4                	ja     21c410 <Benchmark_reportStats+0x5cd0>
    if (start == range.end - 1 and lessThan(items[start], value)) {
  21c44c:	4c 39 c2             	cmp    rdx,r8
  21c44f:	0f 94 c0             	sete   al
  21c452:	49 39 f9             	cmp    r9,rdi
  21c455:	0f 92 c1             	setb   cl
  21c458:	20 c1                	and    cl,al
  21c45a:	0f b6 c9             	movzx  ecx,cl
  21c45d:	48 01 d1             	add    rcx,rdx
  21c460:	e9 8b 00 00 00       	jmp    21c4f0 <Benchmark_reportStats+0x5db0>
  21c465:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21c46c:	00 00 00 00 
  21c470:	4c 89 fa             	mov    rdx,r15
    if (range.start >= range.end) return range.end;
  21c473:	48 85 c0             	test   rax,rax
  21c476:	75 89                	jne    21c401 <Benchmark_reportStats+0x5cc1>
  21c478:	eb 76                	jmp    21c4f0 <Benchmark_reportStats+0x5db0>
  21c47a:	4c 39 ea             	cmp    rdx,r13
  21c47d:	73 68                	jae    21c4e7 <Benchmark_reportStats+0x5da7>
    var end = range.end - 1;
  21c47f:	49 83 c5 ff          	add    r13,0xffffffffffffffff
    while (start < end) {
  21c483:	49 39 d5             	cmp    r13,rdx
  21c486:	76 44                	jbe    21c4cc <Benchmark_reportStats+0x5d8c>
  21c488:	4c 89 e8             	mov    rax,r13
  21c48b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
        const mid = start + (end - start) / 2;
  21c490:	48 89 c1             	mov    rcx,rax
  21c493:	48 29 d1             	sub    rcx,rdx
  21c496:	48 d1 e9             	shr    rcx,1
  21c499:	48 8d 1c 11          	lea    rbx,[rcx+rdx*1]
  21c49d:	48 89 de             	mov    rsi,rbx
  21c4a0:	48 c1 e6 04          	shl    rsi,0x4
  21c4a4:	49 39 3c 33          	cmp    QWORD PTR [r11+rsi*1],rdi
        if (lessThan(items[mid], value)) {
  21c4a8:	72 16                	jb     21c4c0 <Benchmark_reportStats+0x5d80>
  21c4aa:	48 89 d8             	mov    rax,rbx
    while (start < end) {
  21c4ad:	48 39 d0             	cmp    rax,rdx
  21c4b0:	77 de                	ja     21c490 <Benchmark_reportStats+0x5d50>
  21c4b2:	eb 18                	jmp    21c4cc <Benchmark_reportStats+0x5d8c>
  21c4b4:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21c4bb:	00 00 00 00 00 
  21c4c0:	48 01 ca             	add    rdx,rcx
  21c4c3:	48 83 c2 01          	add    rdx,0x1
  21c4c7:	48 39 d0             	cmp    rax,rdx
  21c4ca:	77 c4                	ja     21c490 <Benchmark_reportStats+0x5d50>
    if (start == range.end - 1 and lessThan(items[start], value)) {
  21c4cc:	4c 39 ea             	cmp    rdx,r13
  21c4cf:	0f 85 63 fe ff ff    	jne    21c338 <Benchmark_reportStats+0x5bf8>
  21c4d5:	49 c1 e5 04          	shl    r13,0x4
  21c4d9:	31 c9                	xor    ecx,ecx
  21c4db:	4b 39 3c 2b          	cmp    QWORD PTR [r11+r13*1],rdi
  21c4df:	0f 92 c1             	setb   cl
  21c4e2:	e9 76 ff ff ff       	jmp    21c45d <Benchmark_reportStats+0x5d1d>
  21c4e7:	4c 89 e9             	mov    rcx,r13
  21c4ea:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
                        mem.rotate(T, items[buffer.start..index], buffer.length());
  21c4f0:	49 89 c8             	mov    r8,rcx
  21c4f3:	4d 29 e0             	sub    r8,r12
    const end = items.len / 2;
  21c4f6:	4c 89 d0             	mov    rax,r10
  21c4f9:	48 d1 e8             	shr    rax,1
    while (i < end) : (i += 1) {
  21c4fc:	0f 84 36 01 00 00    	je     21c638 <Benchmark_reportStats+0x5ef8>
        swap(T, &items[i], &items[items.len - i - 1]);
  21c502:	48 8d 70 ff          	lea    rsi,[rax-0x1]
  21c506:	89 c2                	mov    edx,eax
  21c508:	83 e2 03             	and    edx,0x3
  21c50b:	48 83 fe 03          	cmp    rsi,0x3
  21c50f:	73 1f                	jae    21c530 <Benchmark_reportStats+0x5df0>
  21c511:	31 ff                	xor    edi,edi
    while (i < end) : (i += 1) {
  21c513:	48 85 d2             	test   rdx,rdx
  21c516:	0f 85 d2 00 00 00    	jne    21c5ee <Benchmark_reportStats+0x5eae>
  21c51c:	e9 17 01 00 00       	jmp    21c638 <Benchmark_reportStats+0x5ef8>
  21c521:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21c528:	0f 1f 84 00 00 00 00 
  21c52f:	00 
        swap(T, &items[i], &items[items.len - i - 1]);
  21c530:	48 29 d0             	sub    rax,rdx
  21c533:	48 8b 74 24 38       	mov    rsi,QWORD PTR [rsp+0x38]
  21c538:	49 8d 1c 33          	lea    rbx,[r11+rsi*1]
  21c53c:	48 83 c3 30          	add    rbx,0x30
  21c540:	4b 8d 34 22          	lea    rsi,[r10+r12*1]
  21c544:	48 c1 e6 04          	shl    rsi,0x4
  21c548:	4c 01 de             	add    rsi,r11
  21c54b:	48 83 c6 f0          	add    rsi,0xfffffffffffffff0
  21c54f:	31 ff                	xor    edi,edi
  21c551:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21c558:	0f 1f 84 00 00 00 00 
  21c55f:	00 
    const tmp = a.*;
  21c560:	c5 f8 10 43 d0       	vmovups xmm0,XMMWORD PTR [rbx-0x30]
  21c565:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21c56a:	c5 f8 10 06          	vmovups xmm0,XMMWORD PTR [rsi]
  21c56e:	c5 f8 11 43 d0       	vmovups XMMWORD PTR [rbx-0x30],xmm0
    b.* = tmp;
  21c573:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  21c578:	c5 f8 11 06          	vmovups XMMWORD PTR [rsi],xmm0
    const tmp = a.*;
  21c57c:	c5 f8 10 43 e0       	vmovups xmm0,XMMWORD PTR [rbx-0x20]
  21c581:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21c586:	c5 f8 10 46 f0       	vmovups xmm0,XMMWORD PTR [rsi-0x10]
  21c58b:	c5 f8 11 43 e0       	vmovups XMMWORD PTR [rbx-0x20],xmm0
    b.* = tmp;
  21c590:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  21c595:	c5 f8 11 46 f0       	vmovups XMMWORD PTR [rsi-0x10],xmm0
    const tmp = a.*;
  21c59a:	c5 f8 10 43 f0       	vmovups xmm0,XMMWORD PTR [rbx-0x10]
  21c59f:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21c5a4:	c5 f8 10 46 e0       	vmovups xmm0,XMMWORD PTR [rsi-0x20]
  21c5a9:	c5 f8 11 43 f0       	vmovups XMMWORD PTR [rbx-0x10],xmm0
    b.* = tmp;
  21c5ae:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  21c5b3:	c5 f8 11 46 e0       	vmovups XMMWORD PTR [rsi-0x20],xmm0
    const tmp = a.*;
  21c5b8:	c5 f8 10 03          	vmovups xmm0,XMMWORD PTR [rbx]
  21c5bc:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21c5c1:	c5 f8 10 46 d0       	vmovups xmm0,XMMWORD PTR [rsi-0x30]
  21c5c6:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
    b.* = tmp;
  21c5ca:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  21c5cf:	c5 fa 7f 46 d0       	vmovdqu XMMWORD PTR [rsi-0x30],xmm0
    while (i < end) : (i += 1) {
  21c5d4:	48 83 c7 04          	add    rdi,0x4
  21c5d8:	48 83 c3 40          	add    rbx,0x40
  21c5dc:	48 83 c6 c0          	add    rsi,0xffffffffffffffc0
  21c5e0:	48 39 f8             	cmp    rax,rdi
  21c5e3:	0f 85 77 ff ff ff    	jne    21c560 <Benchmark_reportStats+0x5e20>
  21c5e9:	48 85 d2             	test   rdx,rdx
  21c5ec:	74 4a                	je     21c638 <Benchmark_reportStats+0x5ef8>
  21c5ee:	4b 8d 04 22          	lea    rax,[r10+r12*1]
  21c5f2:	48 29 f8             	sub    rax,rdi
  21c5f5:	48 c1 e0 04          	shl    rax,0x4
  21c5f9:	4c 01 d8             	add    rax,r11
  21c5fc:	48 83 c0 f0          	add    rax,0xfffffffffffffff0
  21c600:	4c 01 e7             	add    rdi,r12
  21c603:	48 c1 e7 04          	shl    rdi,0x4
  21c607:	4c 01 df             	add    rdi,r11
  21c60a:	48 f7 da             	neg    rdx
  21c60d:	0f 1f 00             	nop    DWORD PTR [rax]
    const tmp = a.*;
  21c610:	c5 f8 10 07          	vmovups xmm0,XMMWORD PTR [rdi]
  21c614:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21c619:	c5 f8 10 00          	vmovups xmm0,XMMWORD PTR [rax]
  21c61d:	c5 f8 11 07          	vmovups XMMWORD PTR [rdi],xmm0
    b.* = tmp;
  21c621:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  21c626:	c5 fa 7f 00          	vmovdqu XMMWORD PTR [rax],xmm0
    while (i < end) : (i += 1) {
  21c62a:	48 83 c0 f0          	add    rax,0xfffffffffffffff0
  21c62e:	48 83 c7 10          	add    rdi,0x10
  21c632:	48 83 c2 01          	add    rdx,0x1
  21c636:	75 d8                	jne    21c610 <Benchmark_reportStats+0x5ed0>
    reverse(T, items[amount..]);
  21c638:	4c 89 c0             	mov    rax,r8
  21c63b:	4c 29 d0             	sub    rax,r10
    const end = items.len / 2;
  21c63e:	48 d1 e8             	shr    rax,1
    while (i < end) : (i += 1) {
  21c641:	0f 84 41 01 00 00    	je     21c788 <Benchmark_reportStats+0x6048>
        swap(T, &items[i], &items[items.len - i - 1]);
  21c647:	48 8d 70 ff          	lea    rsi,[rax-0x1]
  21c64b:	89 c2                	mov    edx,eax
  21c64d:	83 e2 03             	and    edx,0x3
  21c650:	48 83 fe 03          	cmp    rsi,0x3
  21c654:	73 1a                	jae    21c670 <Benchmark_reportStats+0x5f30>
  21c656:	31 ff                	xor    edi,edi
    while (i < end) : (i += 1) {
  21c658:	48 85 d2             	test   rdx,rdx
  21c65b:	0f 85 cd 00 00 00    	jne    21c72e <Benchmark_reportStats+0x5fee>
  21c661:	e9 22 01 00 00       	jmp    21c788 <Benchmark_reportStats+0x6048>
  21c666:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  21c66d:	00 00 00 
        swap(T, &items[i], &items[items.len - i - 1]);
  21c670:	48 29 d0             	sub    rax,rdx
  21c673:	4c 89 fe             	mov    rsi,r15
  21c676:	48 c1 e6 04          	shl    rsi,0x4
  21c67a:	49 8d 1c 33          	lea    rbx,[r11+rsi*1]
  21c67e:	48 83 c3 30          	add    rbx,0x30
  21c682:	4a 8d 34 39          	lea    rsi,[rcx+r15*1]
  21c686:	4b 8d 3c 22          	lea    rdi,[r10+r12*1]
  21c68a:	48 29 fe             	sub    rsi,rdi
  21c68d:	48 c1 e6 04          	shl    rsi,0x4
  21c691:	4c 01 de             	add    rsi,r11
  21c694:	48 83 c6 f0          	add    rsi,0xfffffffffffffff0
  21c698:	31 ff                	xor    edi,edi
  21c69a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
    const tmp = a.*;
  21c6a0:	c5 f8 10 43 d0       	vmovups xmm0,XMMWORD PTR [rbx-0x30]
  21c6a5:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21c6aa:	c5 f8 10 06          	vmovups xmm0,XMMWORD PTR [rsi]
  21c6ae:	c5 f8 11 43 d0       	vmovups XMMWORD PTR [rbx-0x30],xmm0
    b.* = tmp;
  21c6b3:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  21c6b8:	c5 f8 11 06          	vmovups XMMWORD PTR [rsi],xmm0
    const tmp = a.*;
  21c6bc:	c5 f8 10 43 e0       	vmovups xmm0,XMMWORD PTR [rbx-0x20]
  21c6c1:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21c6c6:	c5 f8 10 46 f0       	vmovups xmm0,XMMWORD PTR [rsi-0x10]
  21c6cb:	c5 f8 11 43 e0       	vmovups XMMWORD PTR [rbx-0x20],xmm0
    b.* = tmp;
  21c6d0:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  21c6d5:	c5 f8 11 46 f0       	vmovups XMMWORD PTR [rsi-0x10],xmm0
    const tmp = a.*;
  21c6da:	c5 f8 10 43 f0       	vmovups xmm0,XMMWORD PTR [rbx-0x10]
  21c6df:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21c6e4:	c5 f8 10 46 e0       	vmovups xmm0,XMMWORD PTR [rsi-0x20]
  21c6e9:	c5 f8 11 43 f0       	vmovups XMMWORD PTR [rbx-0x10],xmm0
    b.* = tmp;
  21c6ee:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  21c6f3:	c5 f8 11 46 e0       	vmovups XMMWORD PTR [rsi-0x20],xmm0
    const tmp = a.*;
  21c6f8:	c5 f8 10 03          	vmovups xmm0,XMMWORD PTR [rbx]
  21c6fc:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21c701:	c5 f8 10 46 d0       	vmovups xmm0,XMMWORD PTR [rsi-0x30]
  21c706:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
    b.* = tmp;
  21c70a:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  21c70f:	c5 fa 7f 46 d0       	vmovdqu XMMWORD PTR [rsi-0x30],xmm0
    while (i < end) : (i += 1) {
  21c714:	48 83 c7 04          	add    rdi,0x4
  21c718:	48 83 c3 40          	add    rbx,0x40
  21c71c:	48 83 c6 c0          	add    rsi,0xffffffffffffffc0
  21c720:	48 39 f8             	cmp    rax,rdi
  21c723:	0f 85 77 ff ff ff    	jne    21c6a0 <Benchmark_reportStats+0x5f60>
  21c729:	48 85 d2             	test   rdx,rdx
  21c72c:	74 5a                	je     21c788 <Benchmark_reportStats+0x6048>
  21c72e:	4a 8d 04 39          	lea    rax,[rcx+r15*1]
  21c732:	4d 01 e2             	add    r10,r12
  21c735:	49 01 fa             	add    r10,rdi
  21c738:	4c 29 d0             	sub    rax,r10
  21c73b:	48 c1 e0 04          	shl    rax,0x4
  21c73f:	4c 01 d8             	add    rax,r11
  21c742:	48 83 c0 f0          	add    rax,0xfffffffffffffff0
  21c746:	4c 01 ff             	add    rdi,r15
  21c749:	48 c1 e7 04          	shl    rdi,0x4
  21c74d:	4c 01 df             	add    rdi,r11
  21c750:	48 f7 da             	neg    rdx
  21c753:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21c75a:	84 00 00 00 00 00 
    const tmp = a.*;
  21c760:	c5 f8 10 07          	vmovups xmm0,XMMWORD PTR [rdi]
  21c764:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21c769:	c5 f8 10 00          	vmovups xmm0,XMMWORD PTR [rax]
  21c76d:	c5 f8 11 07          	vmovups XMMWORD PTR [rdi],xmm0
    b.* = tmp;
  21c771:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  21c776:	c5 fa 7f 00          	vmovdqu XMMWORD PTR [rax],xmm0
    while (i < end) : (i += 1) {
  21c77a:	48 83 c0 f0          	add    rax,0xfffffffffffffff0
  21c77e:	48 83 c7 10          	add    rdi,0x10
  21c782:	48 83 c2 01          	add    rdx,0x1
  21c786:	75 d8                	jne    21c760 <Benchmark_reportStats+0x6020>
    const end = items.len / 2;
  21c788:	4c 89 c6             	mov    rsi,r8
  21c78b:	48 d1 ee             	shr    rsi,1
    while (i < end) : (i += 1) {
  21c78e:	0f 84 5c 01 00 00    	je     21c8f0 <Benchmark_reportStats+0x61b0>
  21c794:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
    const tmp = a.*;
  21c799:	c5 f8 10 00          	vmovups xmm0,XMMWORD PTR [rax]
  21c79d:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  21c7a2:	49 c1 e0 04          	shl    r8,0x4
    a.* = b.*;
  21c7a6:	c4 a1 78 10 44 00 f0 	vmovups xmm0,XMMWORD PTR [rax+r8*1-0x10]
  21c7ad:	c5 f8 11 00          	vmovups XMMWORD PTR [rax],xmm0
    b.* = tmp;
  21c7b1:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  21c7b6:	c4 a1 7a 7f 44 00 f0 	vmovdqu XMMWORD PTR [rax+r8*1-0x10],xmm0
    while (i < end) : (i += 1) {
  21c7bd:	48 83 fe 01          	cmp    rsi,0x1
  21c7c1:	0f 84 29 01 00 00    	je     21c8f0 <Benchmark_reportStats+0x61b0>
        swap(T, &items[i], &items[items.len - i - 1]);
  21c7c7:	8d 46 ff             	lea    eax,[rsi-0x1]
  21c7ca:	48 8d 56 fe          	lea    rdx,[rsi-0x2]
  21c7ce:	83 e0 03             	and    eax,0x3
  21c7d1:	48 83 fa 03          	cmp    rdx,0x3
  21c7d5:	73 13                	jae    21c7ea <Benchmark_reportStats+0x60aa>
  21c7d7:	ba 01 00 00 00       	mov    edx,0x1
    while (i < end) : (i += 1) {
  21c7dc:	48 85 c0             	test   rax,rax
  21c7df:	0f 85 b9 00 00 00    	jne    21c89e <Benchmark_reportStats+0x615e>
  21c7e5:	e9 06 01 00 00       	jmp    21c8f0 <Benchmark_reportStats+0x61b0>
        swap(T, &items[i], &items[items.len - i - 1]);
  21c7ea:	48 89 ca             	mov    rdx,rcx
  21c7ed:	48 c1 e2 04          	shl    rdx,0x4
  21c7f1:	49 8d 3c 13          	lea    rdi,[r11+rdx*1]
  21c7f5:	48 83 c7 e0          	add    rdi,0xffffffffffffffe0
  21c7f9:	48 8b 54 24 38       	mov    rdx,QWORD PTR [rsp+0x38]
  21c7fe:	49 8d 1c 13          	lea    rbx,[r11+rdx*1]
  21c802:	48 83 c3 40          	add    rbx,0x40
  21c806:	48 29 c6             	sub    rsi,rax
  21c809:	ba 01 00 00 00       	mov    edx,0x1
  21c80e:	66 90                	xchg   ax,ax
    const tmp = a.*;
  21c810:	c5 f8 10 43 d0       	vmovups xmm0,XMMWORD PTR [rbx-0x30]
  21c815:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21c81a:	c5 f8 10 07          	vmovups xmm0,XMMWORD PTR [rdi]
  21c81e:	c5 f8 11 43 d0       	vmovups XMMWORD PTR [rbx-0x30],xmm0
    b.* = tmp;
  21c823:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  21c828:	c5 f8 11 07          	vmovups XMMWORD PTR [rdi],xmm0
    const tmp = a.*;
  21c82c:	c5 f8 10 43 e0       	vmovups xmm0,XMMWORD PTR [rbx-0x20]
  21c831:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21c836:	c5 f8 10 47 f0       	vmovups xmm0,XMMWORD PTR [rdi-0x10]
  21c83b:	c5 f8 11 43 e0       	vmovups XMMWORD PTR [rbx-0x20],xmm0
    b.* = tmp;
  21c840:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  21c845:	c5 f8 11 47 f0       	vmovups XMMWORD PTR [rdi-0x10],xmm0
    const tmp = a.*;
  21c84a:	c5 f8 10 43 f0       	vmovups xmm0,XMMWORD PTR [rbx-0x10]
  21c84f:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21c854:	c5 f8 10 47 e0       	vmovups xmm0,XMMWORD PTR [rdi-0x20]
  21c859:	c5 f8 11 43 f0       	vmovups XMMWORD PTR [rbx-0x10],xmm0
    b.* = tmp;
  21c85e:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  21c863:	c5 f8 11 47 e0       	vmovups XMMWORD PTR [rdi-0x20],xmm0
    const tmp = a.*;
  21c868:	c5 f8 10 03          	vmovups xmm0,XMMWORD PTR [rbx]
  21c86c:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21c871:	c5 f8 10 47 d0       	vmovups xmm0,XMMWORD PTR [rdi-0x30]
  21c876:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
    b.* = tmp;
  21c87a:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  21c87f:	c5 fa 7f 47 d0       	vmovdqu XMMWORD PTR [rdi-0x30],xmm0
    while (i < end) : (i += 1) {
  21c884:	48 83 c2 04          	add    rdx,0x4
  21c888:	48 83 c7 c0          	add    rdi,0xffffffffffffffc0
  21c88c:	48 83 c3 40          	add    rbx,0x40
  21c890:	48 39 d6             	cmp    rsi,rdx
  21c893:	0f 85 77 ff ff ff    	jne    21c810 <Benchmark_reportStats+0x60d0>
  21c899:	48 85 c0             	test   rax,rax
  21c89c:	74 52                	je     21c8f0 <Benchmark_reportStats+0x61b0>
  21c89e:	48 89 ce             	mov    rsi,rcx
  21c8a1:	48 29 d6             	sub    rsi,rdx
  21c8a4:	48 c1 e6 04          	shl    rsi,0x4
  21c8a8:	4c 01 de             	add    rsi,r11
  21c8ab:	48 83 c6 f0          	add    rsi,0xfffffffffffffff0
  21c8af:	4c 01 e2             	add    rdx,r12
  21c8b2:	48 c1 e2 04          	shl    rdx,0x4
  21c8b6:	4c 01 da             	add    rdx,r11
  21c8b9:	48 f7 d8             	neg    rax
  21c8bc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
    const tmp = a.*;
  21c8c0:	c5 f8 10 02          	vmovups xmm0,XMMWORD PTR [rdx]
  21c8c4:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21c8c9:	c5 f8 10 06          	vmovups xmm0,XMMWORD PTR [rsi]
  21c8cd:	c5 f8 11 02          	vmovups XMMWORD PTR [rdx],xmm0
    b.* = tmp;
  21c8d1:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  21c8d6:	c5 fa 7f 06          	vmovdqu XMMWORD PTR [rsi],xmm0
    while (i < end) : (i += 1) {
  21c8da:	48 83 c6 f0          	add    rsi,0xfffffffffffffff0
  21c8de:	48 83 c2 10          	add    rdx,0x10
  21c8e2:	48 83 c0 01          	add    rax,0x1
  21c8e6:	75 d8                	jne    21c8c0 <Benchmark_reportStats+0x6180>
  21c8e8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  21c8ef:	00 
                        const amount = index - buffer.end;
  21c8f0:	b8 01 00 00 00       	mov    eax,0x1
  21c8f5:	4c 29 f8             	sub    rax,r15
                        buffer.start += (amount + 1);
  21c8f8:	4c 01 e0             	add    rax,r12
  21c8fb:	4c 8d 24 01          	lea    r12,[rcx+rax*1]
                        unique -= 2;
  21c8ff:	49 83 c6 fe          	add    r14,0xfffffffffffffffe
        return self.end - self.start;
  21c903:	49 89 c2             	mov    r10,rax
  21c906:	49 f7 da             	neg    r10
                    while (buffer.length() > 0) {
  21c909:	48 85 c0             	test   rax,rax
  21c90c:	0f 85 2e fa ff ff    	jne    21c340 <Benchmark_reportStats+0x5c00>
  21c912:	48 8b 44 24 10       	mov    rax,QWORD PTR [rsp+0x10]
            while (pull_index < 2) : (pull_index += 1) {
  21c917:	48 83 c0 01          	add    rax,0x1
  21c91b:	48 83 f8 02          	cmp    rax,0x2
  21c91f:	0f 85 fb f3 ff ff    	jne    21bd20 <Benchmark_reportStats+0x55e0>
  21c925:	48 8b 84 24 e0 00 00 	mov    rax,QWORD PTR [rsp+0xe0]
  21c92c:	00 
  21c92d:	4c 8b bc 24 00 01 00 	mov    r15,QWORD PTR [rsp+0x100]
  21c934:	00 
  21c935:	4c 8b a4 24 d8 00 00 	mov    r12,QWORD PTR [rsp+0xd8]
  21c93c:	00 
  21c93d:	e9 7e 25 00 00       	jmp    21eec0 <Benchmark_reportStats+0x8780>
  21c942:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21c949:	1f 84 00 00 00 00 00 
        if (self.numerator_step >= self.denominator) {
  21c950:	4c 39 f8             	cmp    rax,r15
  21c953:	b9 00 00 00 00       	mov    ecx,0x0
  21c958:	49 0f 43 cf          	cmovae rcx,r15
  21c95c:	48 29 c8             	sub    rax,rcx
  21c95f:	49 89 c1             	mov    r9,rax
        if (iterator.length() < cache.len) {
  21c962:	49 81 fc 00 02 00 00 	cmp    r12,0x200
  21c969:	4c 89 a4 24 d8 00 00 	mov    QWORD PTR [rsp+0xd8],r12
  21c970:	00 
  21c971:	4c 89 8c 24 e0 00 00 	mov    QWORD PTR [rsp+0xe0],r9
  21c978:	00 
  21c979:	0f 83 e1 b6 ff ff    	jae    218060 <Benchmark_reportStats+0x1920>
            if ((iterator.length() + 1) * 4 <= cache.len and iterator.length() * 4 <= items.len) {
  21c97f:	4a 8d 04 a5 04 00 00 	lea    rax,[r12*4+0x4]
  21c986:	00 
    for (source) |s, i|
  21c987:	49 8d 4c 24 ff       	lea    rcx,[r12-0x1]
  21c98c:	48 89 4c 24 50       	mov    QWORD PTR [rsp+0x50],rcx
  21c991:	48 3d 00 02 00 00    	cmp    rax,0x200
  21c997:	0f 87 fa 1c 00 00    	ja     21e697 <Benchmark_reportStats+0x7f57>
  21c99d:	4a 8d 0c a5 00 00 00 	lea    rcx,[r12*4+0x0]
  21c9a4:	00 
  21c9a5:	48 3b 4c 24 48       	cmp    rcx,QWORD PTR [rsp+0x48]
  21c9aa:	0f 87 e7 1c 00 00    	ja     21e697 <Benchmark_reportStats+0x7f57>
        self.decimal += self.decimal_step;
  21c9b0:	4b 8d 04 24          	lea    rax,[r12+r12*1]
  21c9b4:	48 89 44 24 68       	mov    QWORD PTR [rsp+0x68],rax
  21c9b9:	4b 8d 04 24          	lea    rax,[r12+r12*1]
  21c9bd:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  21c9c1:	48 89 84 24 38 01 00 	mov    QWORD PTR [rsp+0x138],rax
  21c9c8:	00 
  21c9c9:	48 89 8c 24 58 01 00 	mov    QWORD PTR [rsp+0x158],rcx
  21c9d0:	00 
  21c9d1:	48 8d 41 ff          	lea    rax,[rcx-0x1]
  21c9d5:	48 89 84 24 70 01 00 	mov    QWORD PTR [rsp+0x170],rax
  21c9dc:	00 
  21c9dd:	4b 8d 0c 64          	lea    rcx,[r12+r12*2]
  21c9e1:	4b 8d 04 64          	lea    rax,[r12+r12*2]
  21c9e5:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  21c9e9:	48 89 84 24 68 01 00 	mov    QWORD PTR [rsp+0x168],rax
  21c9f0:	00 
  21c9f1:	4c 89 e2             	mov    rdx,r12
  21c9f4:	48 c1 e2 04          	shl    rdx,0x4
  21c9f8:	48 8d 84 24 98 02 00 	lea    rax,[rsp+0x298]
  21c9ff:	00 
  21ca00:	48 8d 3c 10          	lea    rdi,[rax+rdx*1]
  21ca04:	48 89 bc 24 60 01 00 	mov    QWORD PTR [rsp+0x160],rdi
  21ca0b:	00 
  21ca0c:	48 89 94 24 20 01 00 	mov    QWORD PTR [rsp+0x120],rdx
  21ca13:	00 
  21ca14:	48 01 e2             	add    rdx,rsp
  21ca17:	48 81 c2 28 02 00 00 	add    rdx,0x228
  21ca1e:	48 89 94 24 10 01 00 	mov    QWORD PTR [rsp+0x110],rdx
  21ca25:	00 
  21ca26:	4c 89 e2             	mov    rdx,r12
  21ca29:	48 c1 e2 05          	shl    rdx,0x5
  21ca2d:	48 8d 3c 10          	lea    rdi,[rax+rdx*1]
  21ca31:	48 89 bc 24 40 01 00 	mov    QWORD PTR [rsp+0x140],rdi
  21ca38:	00 
  21ca39:	48 8d 3c 14          	lea    rdi,[rsp+rdx*1]
  21ca3d:	48 81 c7 28 02 00 00 	add    rdi,0x228
  21ca44:	48 89 bc 24 28 01 00 	mov    QWORD PTR [rsp+0x128],rdi
  21ca4b:	00 
  21ca4c:	48 89 8c 24 18 01 00 	mov    QWORD PTR [rsp+0x118],rcx
  21ca53:	00 
  21ca54:	48 89 cf             	mov    rdi,rcx
  21ca57:	48 c1 e7 04          	shl    rdi,0x4
  21ca5b:	48 8d 0c 3c          	lea    rcx,[rsp+rdi*1]
  21ca5f:	48 81 c1 28 02 00 00 	add    rcx,0x228
  21ca66:	48 89 8c 24 e8 00 00 	mov    QWORD PTR [rsp+0xe8],rcx
  21ca6d:	00 
  21ca6e:	48 8d 8c 24 38 02 00 	lea    rcx,[rsp+0x238]
  21ca75:	00 
  21ca76:	48 01 ca             	add    rdx,rcx
  21ca79:	48 89 54 24 70       	mov    QWORD PTR [rsp+0x70],rdx
  21ca7e:	48 89 bc 24 30 01 00 	mov    QWORD PTR [rsp+0x130],rdi
  21ca85:	00 
  21ca86:	48 8d 04 38          	lea    rax,[rax+rdi*1]
  21ca8a:	48 89 84 24 48 01 00 	mov    QWORD PTR [rsp+0x148],rax
  21ca91:	00 
  21ca92:	31 c0                	xor    eax,eax
  21ca94:	45 31 d2             	xor    r10d,r10d
  21ca97:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  21ca9e:	00 00 
  21caa0:	49 89 c3             	mov    r11,rax
  21caa3:	4f 8d 34 23          	lea    r14,[r11+r12*1]
        self.numerator += self.numerator_step;
  21caa7:	4d 01 ca             	add    r10,r9
        if (self.numerator >= self.denominator) {
  21caaa:	31 f6                	xor    esi,esi
  21caac:	4d 39 fa             	cmp    r10,r15
  21caaf:	4c 89 f8             	mov    rax,r15
  21cab2:	b9 00 00 00 00       	mov    ecx,0x0
  21cab7:	48 0f 42 c1          	cmovb  rax,rcx
  21cabb:	40 0f 93 c6          	setae  sil
  21cabf:	49 29 c2             	sub    r10,rax
  21cac2:	49 01 f6             	add    r14,rsi
        self.decimal += self.decimal_step;
  21cac5:	4b 8d 3c 26          	lea    rdi,[r14+r12*1]
        self.numerator += self.numerator_step;
  21cac9:	4d 01 ca             	add    r10,r9
        if (self.numerator >= self.denominator) {
  21cacc:	31 d2                	xor    edx,edx
  21cace:	4d 39 fa             	cmp    r10,r15
  21cad1:	0f 93 c2             	setae  dl
  21cad4:	4c 89 f8             	mov    rax,r15
  21cad7:	48 0f 42 c1          	cmovb  rax,rcx
  21cadb:	49 29 c2             	sub    r10,rax
  21cade:	48 89 d0             	mov    rax,rdx
  21cae1:	48 89 44 24 30       	mov    QWORD PTR [rsp+0x30],rax
  21cae6:	48 01 d7             	add    rdi,rdx
        self.decimal += self.decimal_step;
  21cae9:	4a 8d 1c 27          	lea    rbx,[rdi+r12*1]
        self.numerator += self.numerator_step;
  21caed:	4d 01 ca             	add    r10,r9
        if (self.numerator >= self.denominator) {
  21caf0:	31 d2                	xor    edx,edx
  21caf2:	4d 39 fa             	cmp    r10,r15
  21caf5:	0f 93 c2             	setae  dl
  21caf8:	4c 89 f8             	mov    rax,r15
  21cafb:	48 0f 42 c1          	cmovb  rax,rcx
  21caff:	49 29 c2             	sub    r10,rax
  21cb02:	48 89 54 24 58       	mov    QWORD PTR [rsp+0x58],rdx
  21cb07:	48 01 d3             	add    rbx,rdx
  21cb0a:	48 89 5c 24 20       	mov    QWORD PTR [rsp+0x20],rbx
        self.decimal += self.decimal_step;
  21cb0f:	4a 8d 04 23          	lea    rax,[rbx+r12*1]
        self.numerator += self.numerator_step;
  21cb13:	4d 01 ca             	add    r10,r9
        if (self.numerator >= self.denominator) {
  21cb16:	31 d2                	xor    edx,edx
  21cb18:	4d 39 fa             	cmp    r10,r15
  21cb1b:	0f 93 c2             	setae  dl
  21cb1e:	4d 89 f9             	mov    r9,r15
  21cb21:	4c 0f 42 c9          	cmovb  r9,rcx
  21cb25:	48 89 54 24 60       	mov    QWORD PTR [rsp+0x60],rdx
  21cb2a:	48 01 d0             	add    rax,rdx
                    if (lessThan(items[B1.end - 1], items[A1.start])) {
  21cb2d:	48 89 44 24 38       	mov    QWORD PTR [rsp+0x38],rax
  21cb32:	48 89 fb             	mov    rbx,rdi
  21cb35:	48 c1 e3 04          	shl    rbx,0x4
  21cb39:	4c 8b 7c 24 40       	mov    r15,QWORD PTR [rsp+0x40]
  21cb3e:	4c 89 d9             	mov    rcx,r11
  21cb41:	48 c1 e1 04          	shl    rcx,0x4
  21cb45:	49 8b 44 1f f0       	mov    rax,QWORD PTR [r15+rbx*1-0x10]
  21cb4a:	49 8b 14 0f          	mov    rdx,QWORD PTR [r15+rcx*1]
  21cb4e:	48 39 d0             	cmp    rax,rdx
  21cb51:	48 89 8c 24 08 01 00 	mov    QWORD PTR [rsp+0x108],rcx
  21cb58:	00 
  21cb59:	4d 8d 24 0f          	lea    r12,[r15+rcx*1]
  21cb5d:	4c 89 d9             	mov    rcx,r11
  21cb60:	48 89 4c 24 10       	mov    QWORD PTR [rsp+0x10],rcx
  21cb65:	48 89 74 24 28       	mov    QWORD PTR [rsp+0x28],rsi
  21cb6a:	48 89 7c 24 18       	mov    QWORD PTR [rsp+0x18],rdi
  21cb6f:	4c 89 94 24 d0 00 00 	mov    QWORD PTR [rsp+0xd0],r10
  21cb76:	00 
  21cb77:	4c 89 8c 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],r9
  21cb7e:	00 
  21cb7f:	48 89 5c 24 78       	mov    QWORD PTR [rsp+0x78],rbx
  21cb84:	73 5a                	jae    21cbe0 <Benchmark_reportStats+0x64a0>
        return self.end - self.start;
  21cb86:	4c 29 f7             	sub    rdi,r14
                        mem.copy(T, cache[B1.length()..], items[A1.start..A1.end]);
  21cb89:	b8 00 02 00 00       	mov    eax,0x200
  21cb8e:	48 29 f8             	sub    rax,rdi
  21cb91:	4c 89 f2             	mov    rdx,r14
  21cb94:	4c 29 da             	sub    rdx,r11
    assert(dest.len >= source.len);
  21cb97:	48 39 d0             	cmp    rax,rdx
  21cb9a:	0f 82 0c 27 00 00    	jb     21f2ac <Benchmark_reportStats+0x8b6c>
    for (source) |s, i|
  21cba0:	48 85 d2             	test   rdx,rdx
  21cba3:	0f 84 2b 02 00 00    	je     21cdd4 <Benchmark_reportStats+0x6694>
  21cba9:	48 8b 44 24 50       	mov    rax,QWORD PTR [rsp+0x50]
  21cbae:	48 8d 0c 30          	lea    rcx,[rax+rsi*1]
  21cbb2:	89 d0                	mov    eax,edx
  21cbb4:	83 e0 07             	and    eax,0x7
  21cbb7:	48 83 f9 07          	cmp    rcx,0x7
  21cbbb:	0f 83 35 01 00 00    	jae    21ccf6 <Benchmark_reportStats+0x65b6>
  21cbc1:	31 c9                	xor    ecx,ecx
  21cbc3:	48 85 c0             	test   rax,rax
  21cbc6:	0f 85 cc 01 00 00    	jne    21cd98 <Benchmark_reportStats+0x6658>
  21cbcc:	e9 03 02 00 00       	jmp    21cdd4 <Benchmark_reportStats+0x6694>
  21cbd1:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21cbd8:	0f 1f 84 00 00 00 00 
  21cbdf:	00 
                    } else if (lessThan(items[B1.start], items[A1.end - 1])) {
  21cbe0:	4c 89 f1             	mov    rcx,r14
  21cbe3:	48 c1 e1 04          	shl    rcx,0x4
  21cbe7:	4d 8b 04 0f          	mov    r8,QWORD PTR [r15+rcx*1]
  21cbeb:	4d 3b 44 0f f0       	cmp    r8,QWORD PTR [r15+rcx*1-0x10]
  21cbf0:	0f 83 9a 00 00 00    	jae    21cc90 <Benchmark_reportStats+0x6550>
  21cbf6:	4c 89 f0             	mov    rax,r14
  21cbf9:	4c 89 db             	mov    rbx,r11
  21cbfc:	31 ff                	xor    edi,edi
  21cbfe:	eb 0e                	jmp    21cc0e <Benchmark_reportStats+0x64ce>
  21cc00:	48 89 c1             	mov    rcx,rax
  21cc03:	48 c1 e1 04          	shl    rcx,0x4
  21cc07:	4d 8b 04 0f          	mov    r8,QWORD PTR [r15+rcx*1]
  21cc0b:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
        if (!lessThan(from[B_index], from[A_index])) {
  21cc0e:	48 89 c1             	mov    rcx,rax
  21cc11:	48 c1 e1 04          	shl    rcx,0x4
  21cc15:	4d 8d 1c 0f          	lea    r11,[r15+rcx*1]
  21cc19:	49 89 da             	mov    r10,rbx
  21cc1c:	49 c1 e2 04          	shl    r10,0x4
  21cc20:	4b 8d 34 17          	lea    rsi,[r15+r10*1]
  21cc24:	49 89 f9             	mov    r9,rdi
  21cc27:	49 c1 e1 04          	shl    r9,0x4
  21cc2b:	4e 8d 2c 0c          	lea    r13,[rsp+r9*1]
  21cc2f:	49 81 c5 28 02 00 00 	add    r13,0x228
  21cc36:	49 39 d0             	cmp    r8,rdx
  21cc39:	73 25                	jae    21cc60 <Benchmark_reportStats+0x6520>
            into[insert_index] = from[B_index];
  21cc3b:	c4 c1 7a 6f 03       	vmovdqu xmm0,XMMWORD PTR [r11]
  21cc40:	c4 c1 7a 7f 45 00    	vmovdqu XMMWORD PTR [r13+0x0],xmm0
            B_index += 1;
  21cc46:	48 83 c0 01          	add    rax,0x1
            if (B_index == B_last) {
  21cc4a:	48 3b 44 24 18       	cmp    rax,QWORD PTR [rsp+0x18]
  21cc4f:	0f 84 a9 02 00 00    	je     21cefe <Benchmark_reportStats+0x67be>
  21cc55:	48 83 c7 01          	add    rdi,0x1
  21cc59:	eb a5                	jmp    21cc00 <Benchmark_reportStats+0x64c0>
  21cc5b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
            into[insert_index] = from[A_index];
  21cc60:	c5 fa 6f 06          	vmovdqu xmm0,XMMWORD PTR [rsi]
  21cc64:	c4 c1 7a 7f 45 00    	vmovdqu XMMWORD PTR [r13+0x0],xmm0
            A_index += 1;
  21cc6a:	48 83 c3 01          	add    rbx,0x1
            if (A_index == A_last) {
  21cc6e:	4c 39 f3             	cmp    rbx,r14
  21cc71:	0f 84 da 02 00 00    	je     21cf51 <Benchmark_reportStats+0x6811>
  21cc77:	48 83 c7 01          	add    rdi,0x1
  21cc7b:	48 89 de             	mov    rsi,rbx
  21cc7e:	48 c1 e6 04          	shl    rsi,0x4
  21cc82:	4c 01 fe             	add    rsi,r15
  21cc85:	e9 76 ff ff ff       	jmp    21cc00 <Benchmark_reportStats+0x64c0>
  21cc8a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
                        if (!lessThan(items[B2.start], items[A2.end - 1]) and !lessThan(items[A2.start], items[B1.end - 1])) continue;
  21cc90:	48 8b 4c 24 20       	mov    rcx,QWORD PTR [rsp+0x20]
  21cc95:	48 c1 e1 04          	shl    rcx,0x4
  21cc99:	49 8b 14 0f          	mov    rdx,QWORD PTR [r15+rcx*1]
  21cc9d:	49 3b 54 0f f0       	cmp    rdx,QWORD PTR [r15+rcx*1-0x10]
  21cca2:	72 0a                	jb     21ccae <Benchmark_reportStats+0x656e>
  21cca4:	49 39 04 1f          	cmp    QWORD PTR [r15+rbx*1],rax
  21cca8:	0f 83 92 19 00 00    	jae    21e640 <Benchmark_reportStats+0x7f00>
                        mem.copy(T, cache[0..], items[A1.start..A1.end]);
  21ccae:	4c 89 f0             	mov    rax,r14
  21ccb1:	4c 29 d8             	sub    rax,r11
    assert(dest.len >= source.len);
  21ccb4:	48 3d 01 02 00 00    	cmp    rax,0x201
  21ccba:	0f 83 ec 25 00 00    	jae    21f2ac <Benchmark_reportStats+0x8b6c>
    for (source) |s, i|
  21ccc0:	48 85 c0             	test   rax,rax
  21ccc3:	0f 84 d0 03 00 00    	je     21d099 <Benchmark_reportStats+0x6959>
  21ccc9:	48 8b 4c 24 50       	mov    rcx,QWORD PTR [rsp+0x50]
  21ccce:	48 8d 14 31          	lea    rdx,[rcx+rsi*1]
  21ccd2:	89 c1                	mov    ecx,eax
  21ccd4:	83 e1 07             	and    ecx,0x7
  21ccd7:	48 83 fa 07          	cmp    rdx,0x7
  21ccdb:	0f 83 d6 02 00 00    	jae    21cfb7 <Benchmark_reportStats+0x6877>
  21cce1:	31 d2                	xor    edx,edx
  21cce3:	48 85 c9             	test   rcx,rcx
  21cce6:	48 8b 7c 24 18       	mov    rdi,QWORD PTR [rsp+0x18]
  21cceb:	0f 85 79 03 00 00    	jne    21d06a <Benchmark_reportStats+0x692a>
  21ccf1:	e9 a3 03 00 00       	jmp    21d099 <Benchmark_reportStats+0x6959>
  21ccf6:	48 29 c2             	sub    rdx,rax
  21ccf9:	48 8b 74 24 30       	mov    rsi,QWORD PTR [rsp+0x30]
  21ccfe:	48 c1 e6 04          	shl    rsi,0x4
  21cd02:	48 03 b4 24 10 01 00 	add    rsi,QWORD PTR [rsp+0x110]
  21cd09:	00 
  21cd0a:	bb 70 00 00 00       	mov    ebx,0x70
  21cd0f:	31 c9                	xor    ecx,ecx
  21cd11:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21cd18:	0f 1f 84 00 00 00 00 
  21cd1f:	00 
        dest[i] = s;
  21cd20:	c4 c1 78 10 44 1c 90 	vmovups xmm0,XMMWORD PTR [r12+rbx*1-0x70]
  21cd27:	c5 f8 11 44 1e 90    	vmovups XMMWORD PTR [rsi+rbx*1-0x70],xmm0
  21cd2d:	c4 c1 78 10 44 1c a0 	vmovups xmm0,XMMWORD PTR [r12+rbx*1-0x60]
  21cd34:	c5 f8 11 44 1e a0    	vmovups XMMWORD PTR [rsi+rbx*1-0x60],xmm0
  21cd3a:	c4 c1 78 10 44 1c b0 	vmovups xmm0,XMMWORD PTR [r12+rbx*1-0x50]
  21cd41:	c5 f8 11 44 1e b0    	vmovups XMMWORD PTR [rsi+rbx*1-0x50],xmm0
  21cd47:	c4 c1 78 10 44 1c c0 	vmovups xmm0,XMMWORD PTR [r12+rbx*1-0x40]
  21cd4e:	c5 f8 11 44 1e c0    	vmovups XMMWORD PTR [rsi+rbx*1-0x40],xmm0
  21cd54:	c4 c1 78 10 44 1c d0 	vmovups xmm0,XMMWORD PTR [r12+rbx*1-0x30]
  21cd5b:	c5 f8 11 44 1e d0    	vmovups XMMWORD PTR [rsi+rbx*1-0x30],xmm0
  21cd61:	c4 c1 78 10 44 1c e0 	vmovups xmm0,XMMWORD PTR [r12+rbx*1-0x20]
  21cd68:	c5 f8 11 44 1e e0    	vmovups XMMWORD PTR [rsi+rbx*1-0x20],xmm0
  21cd6e:	c4 c1 78 10 44 1c f0 	vmovups xmm0,XMMWORD PTR [r12+rbx*1-0x10]
  21cd75:	c5 f8 11 44 1e f0    	vmovups XMMWORD PTR [rsi+rbx*1-0x10],xmm0
  21cd7b:	c4 c1 7a 6f 04 1c    	vmovdqu xmm0,XMMWORD PTR [r12+rbx*1]
  21cd81:	c5 fa 7f 04 1e       	vmovdqu XMMWORD PTR [rsi+rbx*1],xmm0
    for (source) |s, i|
  21cd86:	48 83 c1 08          	add    rcx,0x8
  21cd8a:	48 83 eb 80          	sub    rbx,0xffffffffffffff80
  21cd8e:	48 39 ca             	cmp    rdx,rcx
  21cd91:	75 8d                	jne    21cd20 <Benchmark_reportStats+0x65e0>
  21cd93:	48 85 c0             	test   rax,rax
  21cd96:	74 3c                	je     21cdd4 <Benchmark_reportStats+0x6694>
  21cd98:	48 8b 54 24 30       	mov    rdx,QWORD PTR [rsp+0x30]
  21cd9d:	48 8d 14 11          	lea    rdx,[rcx+rdx*1]
  21cda1:	48 c1 e2 04          	shl    rdx,0x4
  21cda5:	48 03 94 24 10 01 00 	add    rdx,QWORD PTR [rsp+0x110]
  21cdac:	00 
  21cdad:	4c 01 d9             	add    rcx,r11
  21cdb0:	48 c1 e1 04          	shl    rcx,0x4
  21cdb4:	4c 01 f9             	add    rcx,r15
  21cdb7:	48 f7 d8             	neg    rax
  21cdba:	31 f6                	xor    esi,esi
  21cdbc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
        dest[i] = s;
  21cdc0:	c5 fa 6f 04 31       	vmovdqu xmm0,XMMWORD PTR [rcx+rsi*1]
  21cdc5:	c5 fa 7f 04 32       	vmovdqu XMMWORD PTR [rdx+rsi*1],xmm0
    for (source) |s, i|
  21cdca:	48 83 c6 10          	add    rsi,0x10
  21cdce:	48 83 c0 01          	add    rax,0x1
  21cdd2:	75 ec                	jne    21cdc0 <Benchmark_reportStats+0x6680>
    assert(dest.len >= source.len);
  21cdd4:	48 81 ff 01 02 00 00 	cmp    rdi,0x201
  21cddb:	0f 83 cb 24 00 00    	jae    21f2ac <Benchmark_reportStats+0x8b6c>
    for (source) |s, i|
  21cde1:	48 85 ff             	test   rdi,rdi
  21cde4:	0f 84 b6 05 00 00    	je     21d3a0 <Benchmark_reportStats+0x6c60>
  21cdea:	48 8b 44 24 50       	mov    rax,QWORD PTR [rsp+0x50]
  21cdef:	48 8b 4c 24 30       	mov    rcx,QWORD PTR [rsp+0x30]
  21cdf4:	48 8d 0c 08          	lea    rcx,[rax+rcx*1]
  21cdf8:	89 f8                	mov    eax,edi
  21cdfa:	83 e0 07             	and    eax,0x7
  21cdfd:	48 83 f9 07          	cmp    rcx,0x7
  21ce01:	73 10                	jae    21ce13 <Benchmark_reportStats+0x66d3>
  21ce03:	31 c9                	xor    ecx,ecx
  21ce05:	48 85 c0             	test   rax,rax
  21ce08:	0f 85 c3 00 00 00    	jne    21ced1 <Benchmark_reportStats+0x6791>
  21ce0e:	e9 8d 05 00 00       	jmp    21d3a0 <Benchmark_reportStats+0x6c60>
  21ce13:	48 29 c7             	sub    rdi,rax
  21ce16:	48 8b 8c 24 20 01 00 	mov    rcx,QWORD PTR [rsp+0x120]
  21ce1d:	00 
  21ce1e:	49 8d 0c 0f          	lea    rcx,[r15+rcx*1]
  21ce22:	48 8b 54 24 10       	mov    rdx,QWORD PTR [rsp+0x10]
  21ce27:	48 8b 74 24 28       	mov    rsi,QWORD PTR [rsp+0x28]
  21ce2c:	48 8d 14 32          	lea    rdx,[rdx+rsi*1]
  21ce30:	48 c1 e2 04          	shl    rdx,0x4
  21ce34:	48 01 ca             	add    rdx,rcx
  21ce37:	be 70 00 00 00       	mov    esi,0x70
  21ce3c:	31 c9                	xor    ecx,ecx
  21ce3e:	66 90                	xchg   ax,ax
        dest[i] = s;
  21ce40:	c5 f8 10 44 32 90    	vmovups xmm0,XMMWORD PTR [rdx+rsi*1-0x70]
  21ce46:	c5 f8 11 84 34 b8 01 	vmovups XMMWORD PTR [rsp+rsi*1+0x1b8],xmm0
  21ce4d:	00 00 
  21ce4f:	c5 f8 10 44 32 a0    	vmovups xmm0,XMMWORD PTR [rdx+rsi*1-0x60]
  21ce55:	c5 f8 11 84 34 c8 01 	vmovups XMMWORD PTR [rsp+rsi*1+0x1c8],xmm0
  21ce5c:	00 00 
  21ce5e:	c5 f8 10 44 32 b0    	vmovups xmm0,XMMWORD PTR [rdx+rsi*1-0x50]
  21ce64:	c5 f8 11 84 34 d8 01 	vmovups XMMWORD PTR [rsp+rsi*1+0x1d8],xmm0
  21ce6b:	00 00 
  21ce6d:	c5 f8 10 44 32 c0    	vmovups xmm0,XMMWORD PTR [rdx+rsi*1-0x40]
  21ce73:	c5 f8 11 84 34 e8 01 	vmovups XMMWORD PTR [rsp+rsi*1+0x1e8],xmm0
  21ce7a:	00 00 
  21ce7c:	c5 f8 10 44 32 d0    	vmovups xmm0,XMMWORD PTR [rdx+rsi*1-0x30]
  21ce82:	c5 f8 11 84 34 f8 01 	vmovups XMMWORD PTR [rsp+rsi*1+0x1f8],xmm0
  21ce89:	00 00 
  21ce8b:	c5 f8 10 44 32 e0    	vmovups xmm0,XMMWORD PTR [rdx+rsi*1-0x20]
  21ce91:	c5 f8 11 84 34 08 02 	vmovups XMMWORD PTR [rsp+rsi*1+0x208],xmm0
  21ce98:	00 00 
  21ce9a:	c5 f8 10 44 32 f0    	vmovups xmm0,XMMWORD PTR [rdx+rsi*1-0x10]
  21cea0:	c5 f8 11 84 34 18 02 	vmovups XMMWORD PTR [rsp+rsi*1+0x218],xmm0
  21cea7:	00 00 
  21cea9:	c5 fa 6f 04 32       	vmovdqu xmm0,XMMWORD PTR [rdx+rsi*1]
  21ceae:	c5 fa 7f 84 34 28 02 	vmovdqu XMMWORD PTR [rsp+rsi*1+0x228],xmm0
  21ceb5:	00 00 
    for (source) |s, i|
  21ceb7:	48 83 c1 08          	add    rcx,0x8
  21cebb:	48 83 ee 80          	sub    rsi,0xffffffffffffff80
  21cebf:	48 39 cf             	cmp    rdi,rcx
  21cec2:	0f 85 78 ff ff ff    	jne    21ce40 <Benchmark_reportStats+0x6700>
  21cec8:	48 85 c0             	test   rax,rax
  21cecb:	0f 84 cf 04 00 00    	je     21d3a0 <Benchmark_reportStats+0x6c60>
  21ced1:	49 c1 e6 04          	shl    r14,0x4
  21ced5:	4d 01 fe             	add    r14,r15
  21ced8:	48 c1 e1 04          	shl    rcx,0x4
  21cedc:	48 f7 d8             	neg    rax
  21cedf:	90                   	nop
        dest[i] = s;
  21cee0:	c4 c1 7a 6f 04 0e    	vmovdqu xmm0,XMMWORD PTR [r14+rcx*1]
  21cee6:	c5 fa 7f 84 0c 28 02 	vmovdqu XMMWORD PTR [rsp+rcx*1+0x228],xmm0
  21ceed:	00 00 
    for (source) |s, i|
  21ceef:	48 83 c1 10          	add    rcx,0x10
  21cef3:	48 83 c0 01          	add    rax,0x1
  21cef7:	75 e7                	jne    21cee0 <Benchmark_reportStats+0x67a0>
  21cef9:	e9 a2 04 00 00       	jmp    21d3a0 <Benchmark_reportStats+0x6c60>
                mem.copy(T, into[insert_index..], from[A_index..A_last]);
  21cefe:	b8 ff 01 00 00       	mov    eax,0x1ff
  21cf03:	48 29 f8             	sub    rax,rdi
  21cf06:	49 29 de             	sub    r14,rbx
    assert(dest.len >= source.len);
  21cf09:	4c 39 f0             	cmp    rax,r14
  21cf0c:	0f 82 9a 23 00 00    	jb     21f2ac <Benchmark_reportStats+0x8b6c>
    for (source) |s, i|
  21cf12:	4d 85 f6             	test   r14,r14
  21cf15:	0f 84 85 04 00 00    	je     21d3a0 <Benchmark_reportStats+0x6c60>
  21cf1b:	48 8b 44 24 50       	mov    rax,QWORD PTR [rsp+0x50]
  21cf20:	48 8b 4c 24 10       	mov    rcx,QWORD PTR [rsp+0x10]
  21cf25:	48 8d 0c 08          	lea    rcx,[rax+rcx*1]
  21cf29:	48 03 4c 24 28       	add    rcx,QWORD PTR [rsp+0x28]
  21cf2e:	48 29 d9             	sub    rcx,rbx
  21cf31:	44 89 f0             	mov    eax,r14d
  21cf34:	83 e0 07             	and    eax,0x7
  21cf37:	48 83 f9 07          	cmp    rcx,0x7
  21cf3b:	0f 83 a8 02 00 00    	jae    21d1e9 <Benchmark_reportStats+0x6aa9>
  21cf41:	31 c9                	xor    ecx,ecx
  21cf43:	48 85 c0             	test   rax,rax
  21cf46:	0f 85 31 03 00 00    	jne    21d27d <Benchmark_reportStats+0x6b3d>
  21cf4c:	e9 4f 04 00 00       	jmp    21d3a0 <Benchmark_reportStats+0x6c60>
                mem.copy(T, into[insert_index..], from[B_index..B_last]);
  21cf51:	ba ff 01 00 00       	mov    edx,0x1ff
  21cf56:	48 29 fa             	sub    rdx,rdi
  21cf59:	48 8b 74 24 18       	mov    rsi,QWORD PTR [rsp+0x18]
  21cf5e:	48 29 c6             	sub    rsi,rax
    assert(dest.len >= source.len);
  21cf61:	48 39 f2             	cmp    rdx,rsi
  21cf64:	0f 82 42 23 00 00    	jb     21f2ac <Benchmark_reportStats+0x8b6c>
    for (source) |s, i|
  21cf6a:	48 85 f6             	test   rsi,rsi
  21cf6d:	0f 84 2d 04 00 00    	je     21d3a0 <Benchmark_reportStats+0x6c60>
  21cf73:	48 8b 94 24 38 01 00 	mov    rdx,QWORD PTR [rsp+0x138]
  21cf7a:	00 
  21cf7b:	48 8b 7c 24 10       	mov    rdi,QWORD PTR [rsp+0x10]
  21cf80:	48 8d 14 3a          	lea    rdx,[rdx+rdi*1]
  21cf84:	48 8b 5c 24 28       	mov    rbx,QWORD PTR [rsp+0x28]
  21cf89:	49 89 d8             	mov    r8,rbx
  21cf8c:	4c 01 c2             	add    rdx,r8
  21cf8f:	48 8b 5c 24 30       	mov    rbx,QWORD PTR [rsp+0x30]
  21cf94:	48 01 da             	add    rdx,rbx
  21cf97:	48 29 c2             	sub    rdx,rax
  21cf9a:	83 e6 07             	and    esi,0x7
  21cf9d:	48 83 fa 07          	cmp    rdx,0x7
  21cfa1:	0f 83 12 03 00 00    	jae    21d2b9 <Benchmark_reportStats+0x6b79>
  21cfa7:	31 c0                	xor    eax,eax
  21cfa9:	48 85 f6             	test   rsi,rsi
  21cfac:	0f 85 af 03 00 00    	jne    21d361 <Benchmark_reportStats+0x6c21>
  21cfb2:	e9 e9 03 00 00       	jmp    21d3a0 <Benchmark_reportStats+0x6c60>
  21cfb7:	48 89 c6             	mov    rsi,rax
  21cfba:	48 29 ce             	sub    rsi,rcx
  21cfbd:	bf 70 00 00 00       	mov    edi,0x70
  21cfc2:	31 d2                	xor    edx,edx
  21cfc4:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21cfcb:	00 00 00 00 00 
        dest[i] = s;
  21cfd0:	c4 c1 78 10 44 3c 90 	vmovups xmm0,XMMWORD PTR [r12+rdi*1-0x70]
  21cfd7:	c5 f8 11 84 3c b8 01 	vmovups XMMWORD PTR [rsp+rdi*1+0x1b8],xmm0
  21cfde:	00 00 
  21cfe0:	c4 c1 78 10 44 3c a0 	vmovups xmm0,XMMWORD PTR [r12+rdi*1-0x60]
  21cfe7:	c5 f8 11 84 3c c8 01 	vmovups XMMWORD PTR [rsp+rdi*1+0x1c8],xmm0
  21cfee:	00 00 
  21cff0:	c4 c1 78 10 44 3c b0 	vmovups xmm0,XMMWORD PTR [r12+rdi*1-0x50]
  21cff7:	c5 f8 11 84 3c d8 01 	vmovups XMMWORD PTR [rsp+rdi*1+0x1d8],xmm0
  21cffe:	00 00 
  21d000:	c4 c1 78 10 44 3c c0 	vmovups xmm0,XMMWORD PTR [r12+rdi*1-0x40]
  21d007:	c5 f8 11 84 3c e8 01 	vmovups XMMWORD PTR [rsp+rdi*1+0x1e8],xmm0
  21d00e:	00 00 
  21d010:	c4 c1 78 10 44 3c d0 	vmovups xmm0,XMMWORD PTR [r12+rdi*1-0x30]
  21d017:	c5 f8 11 84 3c f8 01 	vmovups XMMWORD PTR [rsp+rdi*1+0x1f8],xmm0
  21d01e:	00 00 
  21d020:	c4 c1 78 10 44 3c e0 	vmovups xmm0,XMMWORD PTR [r12+rdi*1-0x20]
  21d027:	c5 f8 11 84 3c 08 02 	vmovups XMMWORD PTR [rsp+rdi*1+0x208],xmm0
  21d02e:	00 00 
  21d030:	c4 c1 78 10 44 3c f0 	vmovups xmm0,XMMWORD PTR [r12+rdi*1-0x10]
  21d037:	c5 f8 11 84 3c 18 02 	vmovups XMMWORD PTR [rsp+rdi*1+0x218],xmm0
  21d03e:	00 00 
  21d040:	c4 c1 7a 6f 04 3c    	vmovdqu xmm0,XMMWORD PTR [r12+rdi*1]
  21d046:	c5 fa 7f 84 3c 28 02 	vmovdqu XMMWORD PTR [rsp+rdi*1+0x228],xmm0
  21d04d:	00 00 
    for (source) |s, i|
  21d04f:	48 83 c2 08          	add    rdx,0x8
  21d053:	48 83 ef 80          	sub    rdi,0xffffffffffffff80
  21d057:	48 39 d6             	cmp    rsi,rdx
  21d05a:	0f 85 70 ff ff ff    	jne    21cfd0 <Benchmark_reportStats+0x6890>
  21d060:	48 85 c9             	test   rcx,rcx
  21d063:	48 8b 7c 24 18       	mov    rdi,QWORD PTR [rsp+0x18]
  21d068:	74 2f                	je     21d099 <Benchmark_reportStats+0x6959>
  21d06a:	48 c1 e2 04          	shl    rdx,0x4
  21d06e:	48 f7 d9             	neg    rcx
  21d071:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21d078:	0f 1f 84 00 00 00 00 
  21d07f:	00 
        dest[i] = s;
  21d080:	c4 c1 7a 6f 04 14    	vmovdqu xmm0,XMMWORD PTR [r12+rdx*1]
  21d086:	c5 fa 7f 84 14 28 02 	vmovdqu XMMWORD PTR [rsp+rdx*1+0x228],xmm0
  21d08d:	00 00 
    for (source) |s, i|
  21d08f:	48 83 c2 10          	add    rdx,0x10
  21d093:	48 83 c1 01          	add    rcx,0x1
  21d097:	75 e7                	jne    21d080 <Benchmark_reportStats+0x6940>
                        mem.copy(T, cache[A1.length()..], items[B1.start..B1.end]);
  21d099:	b9 00 02 00 00       	mov    ecx,0x200
  21d09e:	48 29 c1             	sub    rcx,rax
  21d0a1:	48 89 fa             	mov    rdx,rdi
  21d0a4:	4c 29 f2             	sub    rdx,r14
    assert(dest.len >= source.len);
  21d0a7:	48 39 d1             	cmp    rcx,rdx
  21d0aa:	0f 82 fc 21 00 00    	jb     21f2ac <Benchmark_reportStats+0x8b6c>
    for (source) |s, i|
  21d0b0:	48 85 d2             	test   rdx,rdx
  21d0b3:	0f 84 e7 02 00 00    	je     21d3a0 <Benchmark_reportStats+0x6c60>
  21d0b9:	48 8b 44 24 50       	mov    rax,QWORD PTR [rsp+0x50]
  21d0be:	48 8b 4c 24 30       	mov    rcx,QWORD PTR [rsp+0x30]
  21d0c3:	48 8d 0c 08          	lea    rcx,[rax+rcx*1]
  21d0c7:	89 d0                	mov    eax,edx
  21d0c9:	83 e0 07             	and    eax,0x7
  21d0cc:	48 83 f9 07          	cmp    rcx,0x7
  21d0d0:	73 10                	jae    21d0e2 <Benchmark_reportStats+0x69a2>
  21d0d2:	31 c9                	xor    ecx,ecx
  21d0d4:	48 85 c0             	test   rax,rax
  21d0d7:	0f 85 b7 00 00 00    	jne    21d194 <Benchmark_reportStats+0x6a54>
  21d0dd:	e9 be 02 00 00       	jmp    21d3a0 <Benchmark_reportStats+0x6c60>
  21d0e2:	48 29 c2             	sub    rdx,rax
  21d0e5:	48 8b 8c 24 20 01 00 	mov    rcx,QWORD PTR [rsp+0x120]
  21d0ec:	00 
  21d0ed:	49 8d 0c 0f          	lea    rcx,[r15+rcx*1]
  21d0f1:	48 8b 74 24 10       	mov    rsi,QWORD PTR [rsp+0x10]
  21d0f6:	48 8b 7c 24 28       	mov    rdi,QWORD PTR [rsp+0x28]
  21d0fb:	48 8d 34 3e          	lea    rsi,[rsi+rdi*1]
  21d0ff:	48 c1 e6 04          	shl    rsi,0x4
  21d103:	48 01 ce             	add    rsi,rcx
  21d106:	48 83 c6 70          	add    rsi,0x70
  21d10a:	48 c1 e7 04          	shl    rdi,0x4
  21d10e:	48 03 bc 24 60 01 00 	add    rdi,QWORD PTR [rsp+0x160]
  21d115:	00 
  21d116:	31 db                	xor    ebx,ebx
  21d118:	31 c9                	xor    ecx,ecx
  21d11a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
        dest[i] = s;
  21d120:	c5 f8 10 44 1e 90    	vmovups xmm0,XMMWORD PTR [rsi+rbx*1-0x70]
  21d126:	c5 f8 11 44 1f 90    	vmovups XMMWORD PTR [rdi+rbx*1-0x70],xmm0
  21d12c:	c5 f8 10 44 1e a0    	vmovups xmm0,XMMWORD PTR [rsi+rbx*1-0x60]
  21d132:	c5 f8 11 44 1f a0    	vmovups XMMWORD PTR [rdi+rbx*1-0x60],xmm0
  21d138:	c5 f8 10 44 1e b0    	vmovups xmm0,XMMWORD PTR [rsi+rbx*1-0x50]
  21d13e:	c5 f8 11 44 1f b0    	vmovups XMMWORD PTR [rdi+rbx*1-0x50],xmm0
  21d144:	c5 f8 10 44 1e c0    	vmovups xmm0,XMMWORD PTR [rsi+rbx*1-0x40]
  21d14a:	c5 f8 11 44 1f c0    	vmovups XMMWORD PTR [rdi+rbx*1-0x40],xmm0
  21d150:	c5 f8 10 44 1e d0    	vmovups xmm0,XMMWORD PTR [rsi+rbx*1-0x30]
  21d156:	c5 f8 11 44 1f d0    	vmovups XMMWORD PTR [rdi+rbx*1-0x30],xmm0
  21d15c:	c5 f8 10 44 1e e0    	vmovups xmm0,XMMWORD PTR [rsi+rbx*1-0x20]
  21d162:	c5 f8 11 44 1f e0    	vmovups XMMWORD PTR [rdi+rbx*1-0x20],xmm0
  21d168:	c5 f8 10 44 1e f0    	vmovups xmm0,XMMWORD PTR [rsi+rbx*1-0x10]
  21d16e:	c5 f8 11 44 1f f0    	vmovups XMMWORD PTR [rdi+rbx*1-0x10],xmm0
  21d174:	c5 fa 6f 04 1e       	vmovdqu xmm0,XMMWORD PTR [rsi+rbx*1]
  21d179:	c5 fa 7f 04 1f       	vmovdqu XMMWORD PTR [rdi+rbx*1],xmm0
    for (source) |s, i|
  21d17e:	48 83 c1 08          	add    rcx,0x8
  21d182:	48 83 eb 80          	sub    rbx,0xffffffffffffff80
  21d186:	48 39 ca             	cmp    rdx,rcx
  21d189:	75 95                	jne    21d120 <Benchmark_reportStats+0x69e0>
  21d18b:	48 85 c0             	test   rax,rax
  21d18e:	0f 84 0c 02 00 00    	je     21d3a0 <Benchmark_reportStats+0x6c60>
  21d194:	48 8b 7c 24 28       	mov    rdi,QWORD PTR [rsp+0x28]
  21d199:	48 8d 14 39          	lea    rdx,[rcx+rdi*1]
  21d19d:	48 c1 e2 04          	shl    rdx,0x4
  21d1a1:	48 03 94 24 10 01 00 	add    rdx,QWORD PTR [rsp+0x110]
  21d1a8:	00 
  21d1a9:	48 8b b4 24 20 01 00 	mov    rsi,QWORD PTR [rsp+0x120]
  21d1b0:	00 
  21d1b1:	49 8d 34 37          	lea    rsi,[r15+rsi*1]
  21d1b5:	48 03 4c 24 10       	add    rcx,QWORD PTR [rsp+0x10]
  21d1ba:	48 01 f9             	add    rcx,rdi
  21d1bd:	48 c1 e1 04          	shl    rcx,0x4
  21d1c1:	48 01 f1             	add    rcx,rsi
  21d1c4:	48 f7 d8             	neg    rax
  21d1c7:	31 f6                	xor    esi,esi
  21d1c9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
        dest[i] = s;
  21d1d0:	c5 fa 6f 04 31       	vmovdqu xmm0,XMMWORD PTR [rcx+rsi*1]
  21d1d5:	c5 fa 7f 04 32       	vmovdqu XMMWORD PTR [rdx+rsi*1],xmm0
    for (source) |s, i|
  21d1da:	48 83 c6 10          	add    rsi,0x10
  21d1de:	48 83 c0 01          	add    rax,0x1
  21d1e2:	75 ec                	jne    21d1d0 <Benchmark_reportStats+0x6a90>
  21d1e4:	e9 b7 01 00 00       	jmp    21d3a0 <Benchmark_reportStats+0x6c60>
  21d1e9:	49 29 c6             	sub    r14,rax
  21d1ec:	ba 70 00 00 00       	mov    edx,0x70
  21d1f1:	31 c9                	xor    ecx,ecx
  21d1f3:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21d1fa:	84 00 00 00 00 00 
        dest[i] = s;
  21d200:	c5 f8 10 44 16 90    	vmovups xmm0,XMMWORD PTR [rsi+rdx*1-0x70]
  21d206:	c4 c1 78 11 44 15 a0 	vmovups XMMWORD PTR [r13+rdx*1-0x60],xmm0
  21d20d:	c5 f8 10 44 16 a0    	vmovups xmm0,XMMWORD PTR [rsi+rdx*1-0x60]
  21d213:	c4 c1 78 11 44 15 b0 	vmovups XMMWORD PTR [r13+rdx*1-0x50],xmm0
  21d21a:	c5 f8 10 44 16 b0    	vmovups xmm0,XMMWORD PTR [rsi+rdx*1-0x50]
  21d220:	c4 c1 78 11 44 15 c0 	vmovups XMMWORD PTR [r13+rdx*1-0x40],xmm0
  21d227:	c5 f8 10 44 16 c0    	vmovups xmm0,XMMWORD PTR [rsi+rdx*1-0x40]
  21d22d:	c4 c1 78 11 44 15 d0 	vmovups XMMWORD PTR [r13+rdx*1-0x30],xmm0
  21d234:	c5 f8 10 44 16 d0    	vmovups xmm0,XMMWORD PTR [rsi+rdx*1-0x30]
  21d23a:	c4 c1 78 11 44 15 e0 	vmovups XMMWORD PTR [r13+rdx*1-0x20],xmm0
  21d241:	c5 f8 10 44 16 e0    	vmovups xmm0,XMMWORD PTR [rsi+rdx*1-0x20]
  21d247:	c4 c1 78 11 44 15 f0 	vmovups XMMWORD PTR [r13+rdx*1-0x10],xmm0
  21d24e:	c5 f8 10 44 16 f0    	vmovups xmm0,XMMWORD PTR [rsi+rdx*1-0x10]
  21d254:	c4 c1 78 11 44 15 00 	vmovups XMMWORD PTR [r13+rdx*1+0x0],xmm0
  21d25b:	c5 fa 6f 04 16       	vmovdqu xmm0,XMMWORD PTR [rsi+rdx*1]
  21d260:	c4 c1 7a 7f 44 15 10 	vmovdqu XMMWORD PTR [r13+rdx*1+0x10],xmm0
    for (source) |s, i|
  21d267:	48 83 c1 08          	add    rcx,0x8
  21d26b:	48 83 ea 80          	sub    rdx,0xffffffffffffff80
  21d26f:	49 39 ce             	cmp    r14,rcx
  21d272:	75 8c                	jne    21d200 <Benchmark_reportStats+0x6ac0>
  21d274:	48 85 c0             	test   rax,rax
  21d277:	0f 84 23 01 00 00    	je     21d3a0 <Benchmark_reportStats+0x6c60>
  21d27d:	48 c1 e1 04          	shl    rcx,0x4
  21d281:	48 8d 94 24 38 02 00 	lea    rdx,[rsp+0x238]
  21d288:	00 
  21d289:	48 8d 14 0a          	lea    rdx,[rdx+rcx*1]
  21d28d:	4c 01 ca             	add    rdx,r9
  21d290:	4c 01 f9             	add    rcx,r15
  21d293:	4c 01 d1             	add    rcx,r10
  21d296:	48 f7 d8             	neg    rax
  21d299:	31 f6                	xor    esi,esi
  21d29b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
        dest[i] = s;
  21d2a0:	c5 fa 6f 04 31       	vmovdqu xmm0,XMMWORD PTR [rcx+rsi*1]
  21d2a5:	c5 fa 7f 04 32       	vmovdqu XMMWORD PTR [rdx+rsi*1],xmm0
    for (source) |s, i|
  21d2aa:	48 83 c6 10          	add    rsi,0x10
  21d2ae:	48 83 c0 01          	add    rax,0x1
  21d2b2:	75 ec                	jne    21d2a0 <Benchmark_reportStats+0x6b60>
  21d2b4:	e9 e7 00 00 00       	jmp    21d3a0 <Benchmark_reportStats+0x6c60>
  21d2b9:	48 8b 54 24 68       	mov    rdx,QWORD PTR [rsp+0x68]
  21d2be:	48 8d 3c 3a          	lea    rdi,[rdx+rdi*1]
  21d2c2:	48 01 df             	add    rdi,rbx
  21d2c5:	4c 01 c7             	add    rdi,r8
  21d2c8:	48 29 f7             	sub    rdi,rsi
  21d2cb:	48 29 c7             	sub    rdi,rax
  21d2ce:	ba 70 00 00 00       	mov    edx,0x70
  21d2d3:	31 c0                	xor    eax,eax
  21d2d5:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21d2dc:	00 00 00 00 
        dest[i] = s;
  21d2e0:	c4 c1 78 10 44 13 90 	vmovups xmm0,XMMWORD PTR [r11+rdx*1-0x70]
  21d2e7:	c4 c1 78 11 44 15 a0 	vmovups XMMWORD PTR [r13+rdx*1-0x60],xmm0
  21d2ee:	c4 c1 78 10 44 13 a0 	vmovups xmm0,XMMWORD PTR [r11+rdx*1-0x60]
  21d2f5:	c4 c1 78 11 44 15 b0 	vmovups XMMWORD PTR [r13+rdx*1-0x50],xmm0
  21d2fc:	c4 c1 78 10 44 13 b0 	vmovups xmm0,XMMWORD PTR [r11+rdx*1-0x50]
  21d303:	c4 c1 78 11 44 15 c0 	vmovups XMMWORD PTR [r13+rdx*1-0x40],xmm0
  21d30a:	c4 c1 78 10 44 13 c0 	vmovups xmm0,XMMWORD PTR [r11+rdx*1-0x40]
  21d311:	c4 c1 78 11 44 15 d0 	vmovups XMMWORD PTR [r13+rdx*1-0x30],xmm0
  21d318:	c4 c1 78 10 44 13 d0 	vmovups xmm0,XMMWORD PTR [r11+rdx*1-0x30]
  21d31f:	c4 c1 78 11 44 15 e0 	vmovups XMMWORD PTR [r13+rdx*1-0x20],xmm0
  21d326:	c4 c1 78 10 44 13 e0 	vmovups xmm0,XMMWORD PTR [r11+rdx*1-0x20]
  21d32d:	c4 c1 78 11 44 15 f0 	vmovups XMMWORD PTR [r13+rdx*1-0x10],xmm0
  21d334:	c4 c1 78 10 44 13 f0 	vmovups xmm0,XMMWORD PTR [r11+rdx*1-0x10]
  21d33b:	c4 c1 78 11 44 15 00 	vmovups XMMWORD PTR [r13+rdx*1+0x0],xmm0
  21d342:	c4 c1 7a 6f 04 13    	vmovdqu xmm0,XMMWORD PTR [r11+rdx*1]
  21d348:	c4 c1 7a 7f 44 15 10 	vmovdqu XMMWORD PTR [r13+rdx*1+0x10],xmm0
    for (source) |s, i|
  21d34f:	48 83 c0 08          	add    rax,0x8
  21d353:	48 83 ea 80          	sub    rdx,0xffffffffffffff80
  21d357:	48 39 c7             	cmp    rdi,rax
  21d35a:	75 84                	jne    21d2e0 <Benchmark_reportStats+0x6ba0>
  21d35c:	48 85 f6             	test   rsi,rsi
  21d35f:	74 3f                	je     21d3a0 <Benchmark_reportStats+0x6c60>
  21d361:	48 c1 e0 04          	shl    rax,0x4
  21d365:	48 8d 94 24 38 02 00 	lea    rdx,[rsp+0x238]
  21d36c:	00 
  21d36d:	48 8d 14 02          	lea    rdx,[rdx+rax*1]
  21d371:	4c 01 ca             	add    rdx,r9
  21d374:	4c 01 f8             	add    rax,r15
  21d377:	48 01 c8             	add    rax,rcx
  21d37a:	48 f7 de             	neg    rsi
  21d37d:	31 c9                	xor    ecx,ecx
  21d37f:	90                   	nop
        dest[i] = s;
  21d380:	c5 fa 6f 04 08       	vmovdqu xmm0,XMMWORD PTR [rax+rcx*1]
  21d385:	c5 fa 7f 04 0a       	vmovdqu XMMWORD PTR [rdx+rcx*1],xmm0
    for (source) |s, i|
  21d38a:	48 83 c1 10          	add    rcx,0x10
  21d38e:	48 83 c6 01          	add    rsi,0x1
  21d392:	75 ec                	jne    21d380 <Benchmark_reportStats+0x6c40>
  21d394:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21d39b:	00 00 00 00 00 
  21d3a0:	4c 8b 4c 24 38       	mov    r9,QWORD PTR [rsp+0x38]
                    if (lessThan(items[B2.end - 1], items[A2.start])) {
  21d3a5:	4c 89 c8             	mov    rax,r9
  21d3a8:	48 c1 e0 04          	shl    rax,0x4
  21d3ac:	48 8b 4c 24 78       	mov    rcx,QWORD PTR [rsp+0x78]
  21d3b1:	4d 8b 14 0f          	mov    r10,QWORD PTR [r15+rcx*1]
  21d3b5:	4d 39 54 07 f0       	cmp    QWORD PTR [r15+rax*1-0x10],r10
  21d3ba:	0f 83 90 00 00 00    	jae    21d450 <Benchmark_reportStats+0x6d10>
  21d3c0:	48 8b 54 24 18       	mov    rdx,QWORD PTR [rsp+0x18]
        return self.end - self.start;
  21d3c5:	48 89 d0             	mov    rax,rdx
  21d3c8:	4c 8b 6c 24 10       	mov    r13,QWORD PTR [rsp+0x10]
  21d3cd:	4c 29 e8             	sub    rax,r13
  21d3d0:	4c 89 cf             	mov    rdi,r9
  21d3d3:	48 8b 5c 24 20       	mov    rbx,QWORD PTR [rsp+0x20]
  21d3d8:	48 29 df             	sub    rdi,rbx
  21d3db:	49 89 c2             	mov    r10,rax
                        mem.copy(T, cache[A1.length() + B2.length() ..], items[A2.start..A2.end]);
  21d3de:	48 8d 04 07          	lea    rax,[rdi+rax*1]
  21d3e2:	b9 00 02 00 00       	mov    ecx,0x200
  21d3e7:	48 29 c1             	sub    rcx,rax
  21d3ea:	48 29 d3             	sub    rbx,rdx
    assert(dest.len >= source.len);
  21d3ed:	48 39 d9             	cmp    rcx,rbx
  21d3f0:	4c 8b 5c 24 60       	mov    r11,QWORD PTR [rsp+0x60]
  21d3f5:	4c 8b 74 24 58       	mov    r14,QWORD PTR [rsp+0x58]
  21d3fa:	0f 82 ac 1e 00 00    	jb     21f2ac <Benchmark_reportStats+0x8b6c>
    for (source) |s, i|
  21d400:	48 85 db             	test   rbx,rbx
  21d403:	4c 8b 44 24 30       	mov    r8,QWORD PTR [rsp+0x30]
  21d408:	0f 84 a6 02 00 00    	je     21d6b4 <Benchmark_reportStats+0x6f74>
  21d40e:	48 8b 44 24 50       	mov    rax,QWORD PTR [rsp+0x50]
  21d413:	4a 8d 0c 30          	lea    rcx,[rax+r14*1]
  21d417:	89 d8                	mov    eax,ebx
  21d419:	83 e0 07             	and    eax,0x7
  21d41c:	48 83 f9 07          	cmp    rcx,0x7
  21d420:	0f 83 6a 01 00 00    	jae    21d590 <Benchmark_reportStats+0x6e50>
  21d426:	4d 89 d9             	mov    r9,r11
  21d429:	31 c9                	xor    ecx,ecx
  21d42b:	48 85 c0             	test   rax,rax
  21d42e:	4d 89 cb             	mov    r11,r9
  21d431:	4c 8b 4c 24 38       	mov    r9,QWORD PTR [rsp+0x38]
  21d436:	0f 85 1c 02 00 00    	jne    21d658 <Benchmark_reportStats+0x6f18>
  21d43c:	e9 73 02 00 00       	jmp    21d6b4 <Benchmark_reportStats+0x6f74>
  21d441:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21d448:	0f 1f 84 00 00 00 00 
  21d44f:	00 
  21d450:	48 8b 5c 24 20       	mov    rbx,QWORD PTR [rsp+0x20]
                    } else if (lessThan(items[B2.start], items[A2.end - 1])) {
  21d455:	48 89 d8             	mov    rax,rbx
  21d458:	48 c1 e0 04          	shl    rax,0x4
  21d45c:	4d 8b 1c 07          	mov    r11,QWORD PTR [r15+rax*1]
  21d460:	48 8b 4c 24 18       	mov    rcx,QWORD PTR [rsp+0x18]
        return self.end - self.start;
  21d465:	48 89 ca             	mov    rdx,rcx
  21d468:	4c 8b 6c 24 10       	mov    r13,QWORD PTR [rsp+0x10]
  21d46d:	4c 29 ea             	sub    rdx,r13
  21d470:	be 00 02 00 00       	mov    esi,0x200
  21d475:	48 29 d6             	sub    rsi,rdx
  21d478:	4d 3b 5c 07 f0       	cmp    r11,QWORD PTR [r15+rax*1-0x10]
                    } else if (lessThan(items[B2.start], items[A2.end - 1])) {
  21d47d:	48 89 54 24 78       	mov    QWORD PTR [rsp+0x78],rdx
  21d482:	0f 83 b8 00 00 00    	jae    21d540 <Benchmark_reportStats+0x6e00>
  21d488:	48 89 b4 24 50 01 00 	mov    QWORD PTR [rsp+0x150],rsi
  21d48f:	00 
  21d490:	48 89 d0             	mov    rax,rdx
  21d493:	48 c1 e0 04          	shl    rax,0x4
  21d497:	4c 8d 0c 04          	lea    r9,[rsp+rax*1]
  21d49b:	49 81 c1 28 02 00 00 	add    r9,0x228
  21d4a2:	48 89 ca             	mov    rdx,rcx
  21d4a5:	45 31 ed             	xor    r13d,r13d
  21d4a8:	eb 14                	jmp    21d4be <Benchmark_reportStats+0x6d7e>
  21d4aa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  21d4b0:	48 89 d9             	mov    rcx,rbx
  21d4b3:	48 c1 e1 04          	shl    rcx,0x4
  21d4b7:	4d 8b 1c 0f          	mov    r11,QWORD PTR [r15+rcx*1]
  21d4bb:	4c 8b 10             	mov    r10,QWORD PTR [rax]
        if (!lessThan(from[B_index], from[A_index])) {
  21d4be:	48 89 d9             	mov    rcx,rbx
  21d4c1:	48 c1 e1 04          	shl    rcx,0x4
  21d4c5:	4d 8d 04 0f          	lea    r8,[r15+rcx*1]
  21d4c9:	48 89 d6             	mov    rsi,rdx
  21d4cc:	48 c1 e6 04          	shl    rsi,0x4
  21d4d0:	49 8d 04 37          	lea    rax,[r15+rsi*1]
  21d4d4:	4d 89 ee             	mov    r14,r13
  21d4d7:	49 c1 e6 04          	shl    r14,0x4
  21d4db:	4b 8d 3c 31          	lea    rdi,[r9+r14*1]
  21d4df:	4d 39 d3             	cmp    r11,r10
  21d4e2:	73 2c                	jae    21d510 <Benchmark_reportStats+0x6dd0>
            into[insert_index] = from[B_index];
  21d4e4:	c4 c1 7a 6f 00       	vmovdqu xmm0,XMMWORD PTR [r8]
  21d4e9:	c5 fa 7f 07          	vmovdqu XMMWORD PTR [rdi],xmm0
            B_index += 1;
  21d4ed:	48 83 c3 01          	add    rbx,0x1
            insert_index += 1;
  21d4f1:	49 83 c5 01          	add    r13,0x1
            if (B_index == B_last) {
  21d4f5:	48 3b 5c 24 38       	cmp    rbx,QWORD PTR [rsp+0x38]
  21d4fa:	75 b4                	jne    21d4b0 <Benchmark_reportStats+0x6d70>
  21d4fc:	e9 0b 03 00 00       	jmp    21d80c <Benchmark_reportStats+0x70cc>
  21d501:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21d508:	0f 1f 84 00 00 00 00 
  21d50f:	00 
            into[insert_index] = from[A_index];
  21d510:	c5 fa 6f 00          	vmovdqu xmm0,XMMWORD PTR [rax]
  21d514:	c5 fa 7f 07          	vmovdqu XMMWORD PTR [rdi],xmm0
            A_index += 1;
  21d518:	48 83 c2 01          	add    rdx,0x1
            insert_index += 1;
  21d51c:	49 83 c5 01          	add    r13,0x1
            if (A_index == A_last) {
  21d520:	48 3b 54 24 20       	cmp    rdx,QWORD PTR [rsp+0x20]
  21d525:	0f 84 64 03 00 00    	je     21d88f <Benchmark_reportStats+0x714f>
  21d52b:	48 89 d0             	mov    rax,rdx
  21d52e:	48 c1 e0 04          	shl    rax,0x4
  21d532:	4c 01 f8             	add    rax,r15
  21d535:	e9 76 ff ff ff       	jmp    21d4b0 <Benchmark_reportStats+0x6d70>
  21d53a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
                        mem.copy(T, cache[A1.length()..], items[A2.start..A2.end]);
  21d540:	49 89 d8             	mov    r8,rbx
  21d543:	49 29 c8             	sub    r8,rcx
    assert(dest.len >= source.len);
  21d546:	4c 39 c6             	cmp    rsi,r8
  21d549:	4c 8b 74 24 58       	mov    r14,QWORD PTR [rsp+0x58]
  21d54e:	0f 82 58 1d 00 00    	jb     21f2ac <Benchmark_reportStats+0x8b6c>
    for (source) |s, i|
  21d554:	4d 85 c0             	test   r8,r8
  21d557:	4c 8b 5c 24 60       	mov    r11,QWORD PTR [rsp+0x60]
  21d55c:	0f 84 d2 04 00 00    	je     21da34 <Benchmark_reportStats+0x72f4>
  21d562:	48 8b 44 24 50       	mov    rax,QWORD PTR [rsp+0x50]
  21d567:	4a 8d 0c 30          	lea    rcx,[rax+r14*1]
  21d56b:	44 89 c0             	mov    eax,r8d
  21d56e:	83 e0 07             	and    eax,0x7
  21d571:	48 83 f9 07          	cmp    rcx,0x7
  21d575:	0f 83 95 03 00 00    	jae    21d910 <Benchmark_reportStats+0x71d0>
  21d57b:	31 d2                	xor    edx,edx
  21d57d:	48 85 c0             	test   rax,rax
  21d580:	48 8b 5c 24 20       	mov    rbx,QWORD PTR [rsp+0x20]
  21d585:	0f 85 4a 04 00 00    	jne    21d9d5 <Benchmark_reportStats+0x7295>
  21d58b:	e9 a4 04 00 00       	jmp    21da34 <Benchmark_reportStats+0x72f4>
  21d590:	48 29 c3             	sub    rbx,rax
  21d593:	48 8b 4c 24 68       	mov    rcx,QWORD PTR [rsp+0x68]
  21d598:	48 c1 e1 04          	shl    rcx,0x4
  21d59c:	4c 01 f9             	add    rcx,r15
  21d59f:	48 8b 74 24 28       	mov    rsi,QWORD PTR [rsp+0x28]
  21d5a4:	4a 8d 14 2e          	lea    rdx,[rsi+r13*1]
  21d5a8:	4c 01 c2             	add    rdx,r8
  21d5ab:	48 c1 e2 04          	shl    rdx,0x4
  21d5af:	48 01 ca             	add    rdx,rcx
  21d5b2:	48 83 c2 70          	add    rdx,0x70
  21d5b6:	49 8d 34 30          	lea    rsi,[r8+rsi*1]
  21d5ba:	4d 89 d9             	mov    r9,r11
  21d5bd:	4c 01 de             	add    rsi,r11
  21d5c0:	48 c1 e6 04          	shl    rsi,0x4
  21d5c4:	48 03 b4 24 48 01 00 	add    rsi,QWORD PTR [rsp+0x148]
  21d5cb:	00 
  21d5cc:	49 89 db             	mov    r11,rbx
  21d5cf:	31 db                	xor    ebx,ebx
  21d5d1:	31 c9                	xor    ecx,ecx
  21d5d3:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21d5da:	84 00 00 00 00 00 
        dest[i] = s;
  21d5e0:	c5 f8 10 44 1a 90    	vmovups xmm0,XMMWORD PTR [rdx+rbx*1-0x70]
  21d5e6:	c5 f8 11 44 1e 90    	vmovups XMMWORD PTR [rsi+rbx*1-0x70],xmm0
  21d5ec:	c5 f8 10 44 1a a0    	vmovups xmm0,XMMWORD PTR [rdx+rbx*1-0x60]
  21d5f2:	c5 f8 11 44 1e a0    	vmovups XMMWORD PTR [rsi+rbx*1-0x60],xmm0
  21d5f8:	c5 f8 10 44 1a b0    	vmovups xmm0,XMMWORD PTR [rdx+rbx*1-0x50]
  21d5fe:	c5 f8 11 44 1e b0    	vmovups XMMWORD PTR [rsi+rbx*1-0x50],xmm0
  21d604:	c5 f8 10 44 1a c0    	vmovups xmm0,XMMWORD PTR [rdx+rbx*1-0x40]
  21d60a:	c5 f8 11 44 1e c0    	vmovups XMMWORD PTR [rsi+rbx*1-0x40],xmm0
  21d610:	c5 f8 10 44 1a d0    	vmovups xmm0,XMMWORD PTR [rdx+rbx*1-0x30]
  21d616:	c5 f8 11 44 1e d0    	vmovups XMMWORD PTR [rsi+rbx*1-0x30],xmm0
  21d61c:	c5 f8 10 44 1a e0    	vmovups xmm0,XMMWORD PTR [rdx+rbx*1-0x20]
  21d622:	c5 f8 11 44 1e e0    	vmovups XMMWORD PTR [rsi+rbx*1-0x20],xmm0
  21d628:	c5 f8 10 44 1a f0    	vmovups xmm0,XMMWORD PTR [rdx+rbx*1-0x10]
  21d62e:	c5 f8 11 44 1e f0    	vmovups XMMWORD PTR [rsi+rbx*1-0x10],xmm0
  21d634:	c5 fa 6f 04 1a       	vmovdqu xmm0,XMMWORD PTR [rdx+rbx*1]
  21d639:	c5 fa 7f 04 1e       	vmovdqu XMMWORD PTR [rsi+rbx*1],xmm0
    for (source) |s, i|
  21d63e:	48 83 c1 08          	add    rcx,0x8
  21d642:	48 83 eb 80          	sub    rbx,0xffffffffffffff80
  21d646:	49 39 cb             	cmp    r11,rcx
  21d649:	75 95                	jne    21d5e0 <Benchmark_reportStats+0x6ea0>
  21d64b:	48 85 c0             	test   rax,rax
  21d64e:	4d 89 cb             	mov    r11,r9
  21d651:	4c 8b 4c 24 38       	mov    r9,QWORD PTR [rsp+0x38]
  21d656:	74 5c                	je     21d6b4 <Benchmark_reportStats+0x6f74>
  21d658:	4a 8d 14 01          	lea    rdx,[rcx+r8*1]
  21d65c:	48 8b 74 24 28       	mov    rsi,QWORD PTR [rsp+0x28]
  21d661:	48 89 f3             	mov    rbx,rsi
  21d664:	48 01 da             	add    rdx,rbx
  21d667:	4c 01 da             	add    rdx,r11
  21d66a:	48 c1 e2 04          	shl    rdx,0x4
  21d66e:	48 03 94 24 e8 00 00 	add    rdx,QWORD PTR [rsp+0xe8]
  21d675:	00 
  21d676:	48 8b 74 24 68       	mov    rsi,QWORD PTR [rsp+0x68]
  21d67b:	48 c1 e6 04          	shl    rsi,0x4
  21d67f:	4c 01 fe             	add    rsi,r15
  21d682:	4c 01 e9             	add    rcx,r13
  21d685:	48 01 d9             	add    rcx,rbx
  21d688:	4c 01 c1             	add    rcx,r8
  21d68b:	48 c1 e1 04          	shl    rcx,0x4
  21d68f:	48 01 f1             	add    rcx,rsi
  21d692:	48 f7 d8             	neg    rax
  21d695:	31 f6                	xor    esi,esi
  21d697:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  21d69e:	00 00 
        dest[i] = s;
  21d6a0:	c5 fa 6f 04 31       	vmovdqu xmm0,XMMWORD PTR [rcx+rsi*1]
  21d6a5:	c5 fa 7f 04 32       	vmovdqu XMMWORD PTR [rdx+rsi*1],xmm0
    for (source) |s, i|
  21d6aa:	48 83 c6 10          	add    rsi,0x10
  21d6ae:	48 83 c0 01          	add    rax,0x1
  21d6b2:	75 ec                	jne    21d6a0 <Benchmark_reportStats+0x6f60>
                        mem.copy(T, cache[A1.length()..], items[B2.start..B2.end]);
  21d6b4:	b8 00 02 00 00       	mov    eax,0x200
  21d6b9:	4c 89 d6             	mov    rsi,r10
  21d6bc:	48 29 f0             	sub    rax,rsi
    assert(dest.len >= source.len);
  21d6bf:	48 39 f8             	cmp    rax,rdi
  21d6c2:	0f 82 e4 1b 00 00    	jb     21f2ac <Benchmark_reportStats+0x8b6c>
    for (source) |s, i|
  21d6c8:	48 85 ff             	test   rdi,rdi
  21d6cb:	0f 84 dd 06 00 00    	je     21ddae <Benchmark_reportStats+0x766e>
  21d6d1:	48 8b 44 24 50       	mov    rax,QWORD PTR [rsp+0x50]
  21d6d6:	4a 8d 0c 18          	lea    rcx,[rax+r11*1]
  21d6da:	89 f8                	mov    eax,edi
  21d6dc:	83 e0 07             	and    eax,0x7
  21d6df:	48 83 f9 07          	cmp    rcx,0x7
  21d6e3:	73 10                	jae    21d6f5 <Benchmark_reportStats+0x6fb5>
  21d6e5:	31 c9                	xor    ecx,ecx
  21d6e7:	48 85 c0             	test   rax,rax
  21d6ea:	0f 85 c0 00 00 00    	jne    21d7b0 <Benchmark_reportStats+0x7070>
  21d6f0:	e9 0f 01 00 00       	jmp    21d804 <Benchmark_reportStats+0x70c4>
  21d6f5:	48 29 c7             	sub    rdi,rax
  21d6f8:	48 8b 8c 24 30 01 00 	mov    rcx,QWORD PTR [rsp+0x130]
  21d6ff:	00 
  21d700:	49 8d 0c 0f          	lea    rcx,[r15+rcx*1]
  21d704:	4b 8d 14 28          	lea    rdx,[r8+r13*1]
  21d708:	48 8b 74 24 28       	mov    rsi,QWORD PTR [rsp+0x28]
  21d70d:	48 01 f2             	add    rdx,rsi
  21d710:	4c 01 f2             	add    rdx,r14
  21d713:	48 c1 e2 04          	shl    rdx,0x4
  21d717:	48 01 ca             	add    rdx,rcx
  21d71a:	48 83 c2 70          	add    rdx,0x70
  21d71e:	4a 8d 34 06          	lea    rsi,[rsi+r8*1]
  21d722:	48 c1 e6 04          	shl    rsi,0x4
  21d726:	48 03 b4 24 40 01 00 	add    rsi,QWORD PTR [rsp+0x140]
  21d72d:	00 
  21d72e:	31 db                	xor    ebx,ebx
  21d730:	31 c9                	xor    ecx,ecx
  21d732:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21d739:	1f 84 00 00 00 00 00 
        dest[i] = s;
  21d740:	c5 f8 10 44 1a 90    	vmovups xmm0,XMMWORD PTR [rdx+rbx*1-0x70]
  21d746:	c5 f8 11 44 1e 90    	vmovups XMMWORD PTR [rsi+rbx*1-0x70],xmm0
  21d74c:	c5 f8 10 44 1a a0    	vmovups xmm0,XMMWORD PTR [rdx+rbx*1-0x60]
  21d752:	c5 f8 11 44 1e a0    	vmovups XMMWORD PTR [rsi+rbx*1-0x60],xmm0
  21d758:	c5 f8 10 44 1a b0    	vmovups xmm0,XMMWORD PTR [rdx+rbx*1-0x50]
  21d75e:	c5 f8 11 44 1e b0    	vmovups XMMWORD PTR [rsi+rbx*1-0x50],xmm0
  21d764:	c5 f8 10 44 1a c0    	vmovups xmm0,XMMWORD PTR [rdx+rbx*1-0x40]
  21d76a:	c5 f8 11 44 1e c0    	vmovups XMMWORD PTR [rsi+rbx*1-0x40],xmm0
  21d770:	c5 f8 10 44 1a d0    	vmovups xmm0,XMMWORD PTR [rdx+rbx*1-0x30]
  21d776:	c5 f8 11 44 1e d0    	vmovups XMMWORD PTR [rsi+rbx*1-0x30],xmm0
  21d77c:	c5 f8 10 44 1a e0    	vmovups xmm0,XMMWORD PTR [rdx+rbx*1-0x20]
  21d782:	c5 f8 11 44 1e e0    	vmovups XMMWORD PTR [rsi+rbx*1-0x20],xmm0
  21d788:	c5 f8 10 44 1a f0    	vmovups xmm0,XMMWORD PTR [rdx+rbx*1-0x10]
  21d78e:	c5 f8 11 44 1e f0    	vmovups XMMWORD PTR [rsi+rbx*1-0x10],xmm0
  21d794:	c5 fa 6f 04 1a       	vmovdqu xmm0,XMMWORD PTR [rdx+rbx*1]
  21d799:	c5 fa 7f 04 1e       	vmovdqu XMMWORD PTR [rsi+rbx*1],xmm0
    for (source) |s, i|
  21d79e:	48 83 c1 08          	add    rcx,0x8
  21d7a2:	48 83 eb 80          	sub    rbx,0xffffffffffffff80
  21d7a6:	48 39 cf             	cmp    rdi,rcx
  21d7a9:	75 95                	jne    21d740 <Benchmark_reportStats+0x7000>
  21d7ab:	48 85 c0             	test   rax,rax
  21d7ae:	74 54                	je     21d804 <Benchmark_reportStats+0x70c4>
  21d7b0:	48 8b 7c 24 28       	mov    rdi,QWORD PTR [rsp+0x28]
  21d7b5:	48 8d 14 39          	lea    rdx,[rcx+rdi*1]
  21d7b9:	4c 01 c2             	add    rdx,r8
  21d7bc:	48 c1 e2 04          	shl    rdx,0x4
  21d7c0:	48 03 94 24 28 01 00 	add    rdx,QWORD PTR [rsp+0x128]
  21d7c7:	00 
  21d7c8:	48 8b b4 24 30 01 00 	mov    rsi,QWORD PTR [rsp+0x130]
  21d7cf:	00 
  21d7d0:	49 8d 34 37          	lea    rsi,[r15+rsi*1]
  21d7d4:	4c 01 e9             	add    rcx,r13
  21d7d7:	4c 01 c1             	add    rcx,r8
  21d7da:	48 01 f9             	add    rcx,rdi
  21d7dd:	4c 01 f1             	add    rcx,r14
  21d7e0:	48 c1 e1 04          	shl    rcx,0x4
  21d7e4:	48 01 f1             	add    rcx,rsi
  21d7e7:	48 f7 d8             	neg    rax
  21d7ea:	31 f6                	xor    esi,esi
  21d7ec:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
        dest[i] = s;
  21d7f0:	c5 fa 6f 04 31       	vmovdqu xmm0,XMMWORD PTR [rcx+rsi*1]
  21d7f5:	c5 fa 7f 04 32       	vmovdqu XMMWORD PTR [rdx+rsi*1],xmm0
    for (source) |s, i|
  21d7fa:	48 83 c6 10          	add    rsi,0x10
  21d7fe:	48 83 c0 01          	add    rax,0x1
  21d802:	75 ec                	jne    21d7f0 <Benchmark_reportStats+0x70b0>
  21d804:	4c 89 d6             	mov    rsi,r10
  21d807:	e9 a2 05 00 00       	jmp    21ddae <Benchmark_reportStats+0x766e>
  21d80c:	48 8b 8c 24 50 01 00 	mov    rcx,QWORD PTR [rsp+0x150]
  21d813:	00 
                mem.copy(T, into[insert_index..], from[A_index..A_last]);
  21d814:	4c 29 e9             	sub    rcx,r13
  21d817:	48 8b 7c 24 20       	mov    rdi,QWORD PTR [rsp+0x20]
  21d81c:	48 29 d7             	sub    rdi,rdx
    assert(dest.len >= source.len);
  21d81f:	48 39 f9             	cmp    rcx,rdi
  21d822:	4c 8b 5c 24 60       	mov    r11,QWORD PTR [rsp+0x60]
  21d827:	0f 82 7f 1a 00 00    	jb     21f2ac <Benchmark_reportStats+0x8b6c>
    for (source) |s, i|
  21d82d:	48 85 ff             	test   rdi,rdi
  21d830:	4c 8b 4c 24 38       	mov    r9,QWORD PTR [rsp+0x38]
  21d835:	4c 8b 6c 24 10       	mov    r13,QWORD PTR [rsp+0x10]
  21d83a:	0f 84 64 05 00 00    	je     21dda4 <Benchmark_reportStats+0x7664>
  21d840:	48 8b 8c 24 68 01 00 	mov    rcx,QWORD PTR [rsp+0x168]
  21d847:	00 
  21d848:	4a 8d 0c 29          	lea    rcx,[rcx+r13*1]
  21d84c:	4c 8b 54 24 28       	mov    r10,QWORD PTR [rsp+0x28]
  21d851:	4c 01 d1             	add    rcx,r10
  21d854:	4c 8b 44 24 30       	mov    r8,QWORD PTR [rsp+0x30]
  21d859:	4c 01 c1             	add    rcx,r8
  21d85c:	48 8b 5c 24 58       	mov    rbx,QWORD PTR [rsp+0x58]
  21d861:	48 01 d9             	add    rcx,rbx
  21d864:	48 29 d1             	sub    rcx,rdx
  21d867:	83 e7 07             	and    edi,0x7
  21d86a:	48 83 f9 07          	cmp    rcx,0x7
  21d86e:	49 89 fb             	mov    r11,rdi
  21d871:	0f 83 3c 03 00 00    	jae    21dbb3 <Benchmark_reportStats+0x7473>
  21d877:	4d 89 da             	mov    r10,r11
  21d87a:	31 c9                	xor    ecx,ecx
  21d87c:	4d 85 d2             	test   r10,r10
  21d87f:	4c 8b 5c 24 60       	mov    r11,QWORD PTR [rsp+0x60]
  21d884:	0f 85 df 03 00 00    	jne    21dc69 <Benchmark_reportStats+0x7529>
  21d88a:	e9 15 05 00 00       	jmp    21dda4 <Benchmark_reportStats+0x7664>
  21d88f:	48 8b 94 24 50 01 00 	mov    rdx,QWORD PTR [rsp+0x150]
  21d896:	00 
                mem.copy(T, into[insert_index..], from[B_index..B_last]);
  21d897:	4c 29 ea             	sub    rdx,r13
  21d89a:	4c 8b 4c 24 38       	mov    r9,QWORD PTR [rsp+0x38]
  21d89f:	4c 89 c8             	mov    rax,r9
  21d8a2:	48 29 d8             	sub    rax,rbx
    assert(dest.len >= source.len);
  21d8a5:	48 39 c2             	cmp    rdx,rax
  21d8a8:	4c 8b 5c 24 60       	mov    r11,QWORD PTR [rsp+0x60]
  21d8ad:	48 8b 74 24 78       	mov    rsi,QWORD PTR [rsp+0x78]
  21d8b2:	0f 82 f4 19 00 00    	jb     21f2ac <Benchmark_reportStats+0x8b6c>
    for (source) |s, i|
  21d8b8:	48 85 c0             	test   rax,rax
  21d8bb:	4c 8b 6c 24 10       	mov    r13,QWORD PTR [rsp+0x10]
  21d8c0:	0f 84 e3 02 00 00    	je     21dba9 <Benchmark_reportStats+0x7469>
  21d8c6:	48 8b 94 24 70 01 00 	mov    rdx,QWORD PTR [rsp+0x170]
  21d8cd:	00 
  21d8ce:	4a 8d 14 2a          	lea    rdx,[rdx+r13*1]
  21d8d2:	4c 8b 54 24 28       	mov    r10,QWORD PTR [rsp+0x28]
  21d8d7:	4c 89 d6             	mov    rsi,r10
  21d8da:	48 01 f2             	add    rdx,rsi
  21d8dd:	4c 8b 54 24 30       	mov    r10,QWORD PTR [rsp+0x30]
  21d8e2:	4c 01 d2             	add    rdx,r10
  21d8e5:	48 8b 7c 24 58       	mov    rdi,QWORD PTR [rsp+0x58]
  21d8ea:	48 01 fa             	add    rdx,rdi
  21d8ed:	4c 01 da             	add    rdx,r11
  21d8f0:	48 29 da             	sub    rdx,rbx
  21d8f3:	83 e0 07             	and    eax,0x7
  21d8f6:	48 83 fa 07          	cmp    rdx,0x7
  21d8fa:	0f 83 a9 03 00 00    	jae    21dca9 <Benchmark_reportStats+0x7569>
  21d900:	31 d2                	xor    edx,edx
  21d902:	48 85 c0             	test   rax,rax
  21d905:	0f 85 5d 04 00 00    	jne    21dd68 <Benchmark_reportStats+0x7628>
  21d90b:	e9 94 04 00 00       	jmp    21dda4 <Benchmark_reportStats+0x7664>
  21d910:	4c 89 c6             	mov    rsi,r8
  21d913:	48 29 c6             	sub    rsi,rax
  21d916:	48 8b 4c 24 68       	mov    rcx,QWORD PTR [rsp+0x68]
  21d91b:	48 c1 e1 04          	shl    rcx,0x4
  21d91f:	4c 01 f9             	add    rcx,r15
  21d922:	48 8b 5c 24 28       	mov    rbx,QWORD PTR [rsp+0x28]
  21d927:	4a 8d 14 2b          	lea    rdx,[rbx+r13*1]
  21d92b:	4c 8b 54 24 30       	mov    r10,QWORD PTR [rsp+0x30]
  21d930:	4c 01 d2             	add    rdx,r10
  21d933:	48 c1 e2 04          	shl    rdx,0x4
  21d937:	48 8d 3c 0a          	lea    rdi,[rdx+rcx*1]
  21d93b:	48 83 c7 70          	add    rdi,0x70
  21d93f:	4a 8d 1c 13          	lea    rbx,[rbx+r10*1]
  21d943:	48 c1 e3 04          	shl    rbx,0x4
  21d947:	48 03 9c 24 40 01 00 	add    rbx,QWORD PTR [rsp+0x140]
  21d94e:	00 
  21d94f:	31 c9                	xor    ecx,ecx
  21d951:	31 d2                	xor    edx,edx
  21d953:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21d95a:	84 00 00 00 00 00 
        dest[i] = s;
  21d960:	c5 f8 10 44 0f 90    	vmovups xmm0,XMMWORD PTR [rdi+rcx*1-0x70]
  21d966:	c5 f8 11 44 0b 90    	vmovups XMMWORD PTR [rbx+rcx*1-0x70],xmm0
  21d96c:	c5 f8 10 44 0f a0    	vmovups xmm0,XMMWORD PTR [rdi+rcx*1-0x60]
  21d972:	c5 f8 11 44 0b a0    	vmovups XMMWORD PTR [rbx+rcx*1-0x60],xmm0
  21d978:	c5 f8 10 44 0f b0    	vmovups xmm0,XMMWORD PTR [rdi+rcx*1-0x50]
  21d97e:	c5 f8 11 44 0b b0    	vmovups XMMWORD PTR [rbx+rcx*1-0x50],xmm0
  21d984:	c5 f8 10 44 0f c0    	vmovups xmm0,XMMWORD PTR [rdi+rcx*1-0x40]
  21d98a:	c5 f8 11 44 0b c0    	vmovups XMMWORD PTR [rbx+rcx*1-0x40],xmm0
  21d990:	c5 f8 10 44 0f d0    	vmovups xmm0,XMMWORD PTR [rdi+rcx*1-0x30]
  21d996:	c5 f8 11 44 0b d0    	vmovups XMMWORD PTR [rbx+rcx*1-0x30],xmm0
  21d99c:	c5 f8 10 44 0f e0    	vmovups xmm0,XMMWORD PTR [rdi+rcx*1-0x20]
  21d9a2:	c5 f8 11 44 0b e0    	vmovups XMMWORD PTR [rbx+rcx*1-0x20],xmm0
  21d9a8:	c5 f8 10 44 0f f0    	vmovups xmm0,XMMWORD PTR [rdi+rcx*1-0x10]
  21d9ae:	c5 f8 11 44 0b f0    	vmovups XMMWORD PTR [rbx+rcx*1-0x10],xmm0
  21d9b4:	c5 fa 6f 04 0f       	vmovdqu xmm0,XMMWORD PTR [rdi+rcx*1]
  21d9b9:	c5 fa 7f 04 0b       	vmovdqu XMMWORD PTR [rbx+rcx*1],xmm0
    for (source) |s, i|
  21d9be:	48 83 c2 08          	add    rdx,0x8
  21d9c2:	48 83 e9 80          	sub    rcx,0xffffffffffffff80
  21d9c6:	48 39 d6             	cmp    rsi,rdx
  21d9c9:	75 95                	jne    21d960 <Benchmark_reportStats+0x7220>
  21d9cb:	48 85 c0             	test   rax,rax
  21d9ce:	48 8b 5c 24 20       	mov    rbx,QWORD PTR [rsp+0x20]
  21d9d3:	74 5f                	je     21da34 <Benchmark_reportStats+0x72f4>
  21d9d5:	48 8b 7c 24 28       	mov    rdi,QWORD PTR [rsp+0x28]
  21d9da:	48 8d 34 3a          	lea    rsi,[rdx+rdi*1]
  21d9de:	4c 8b 54 24 30       	mov    r10,QWORD PTR [rsp+0x30]
  21d9e3:	4c 01 d6             	add    rsi,r10
  21d9e6:	48 c1 e6 04          	shl    rsi,0x4
  21d9ea:	48 03 b4 24 28 01 00 	add    rsi,QWORD PTR [rsp+0x128]
  21d9f1:	00 
  21d9f2:	48 8b 4c 24 68       	mov    rcx,QWORD PTR [rsp+0x68]
  21d9f7:	48 c1 e1 04          	shl    rcx,0x4
  21d9fb:	4c 01 f9             	add    rcx,r15
  21d9fe:	4c 01 ea             	add    rdx,r13
  21da01:	48 01 fa             	add    rdx,rdi
  21da04:	4c 01 d2             	add    rdx,r10
  21da07:	48 c1 e2 04          	shl    rdx,0x4
  21da0b:	48 01 ca             	add    rdx,rcx
  21da0e:	48 f7 d8             	neg    rax
  21da11:	31 c9                	xor    ecx,ecx
  21da13:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21da1a:	84 00 00 00 00 00 
        dest[i] = s;
  21da20:	c5 fa 6f 04 0a       	vmovdqu xmm0,XMMWORD PTR [rdx+rcx*1]
  21da25:	c5 fa 7f 04 0e       	vmovdqu XMMWORD PTR [rsi+rcx*1],xmm0
    for (source) |s, i|
  21da2a:	48 83 c1 10          	add    rcx,0x10
  21da2e:	48 83 c0 01          	add    rax,0x1
  21da32:	75 ec                	jne    21da20 <Benchmark_reportStats+0x72e0>
  21da34:	48 8b 74 24 78       	mov    rsi,QWORD PTR [rsp+0x78]
                        mem.copy(T, cache[A1.length() + A2.length() ..], items[B2.start..B2.end]);
  21da39:	49 01 f0             	add    r8,rsi
  21da3c:	b8 00 02 00 00       	mov    eax,0x200
  21da41:	4c 29 c0             	sub    rax,r8
  21da44:	4c 89 ca             	mov    rdx,r9
  21da47:	48 29 da             	sub    rdx,rbx
    assert(dest.len >= source.len);
  21da4a:	48 39 d0             	cmp    rax,rdx
  21da4d:	0f 82 59 18 00 00    	jb     21f2ac <Benchmark_reportStats+0x8b6c>
    for (source) |s, i|
  21da53:	48 85 d2             	test   rdx,rdx
  21da56:	0f 84 52 03 00 00    	je     21ddae <Benchmark_reportStats+0x766e>
  21da5c:	48 8b 44 24 50       	mov    rax,QWORD PTR [rsp+0x50]
  21da61:	4a 8d 0c 18          	lea    rcx,[rax+r11*1]
  21da65:	89 d0                	mov    eax,edx
  21da67:	83 e0 07             	and    eax,0x7
  21da6a:	48 83 f9 07          	cmp    rcx,0x7
  21da6e:	73 10                	jae    21da80 <Benchmark_reportStats+0x7340>
  21da70:	31 c9                	xor    ecx,ecx
  21da72:	48 85 c0             	test   rax,rax
  21da75:	0f 85 c9 00 00 00    	jne    21db44 <Benchmark_reportStats+0x7404>
  21da7b:	e9 29 03 00 00       	jmp    21dda9 <Benchmark_reportStats+0x7669>
  21da80:	48 29 c2             	sub    rdx,rax
  21da83:	48 8b 8c 24 30 01 00 	mov    rcx,QWORD PTR [rsp+0x130]
  21da8a:	00 
  21da8b:	49 8d 0c 0f          	lea    rcx,[r15+rcx*1]
  21da8f:	48 8b 5c 24 30       	mov    rbx,QWORD PTR [rsp+0x30]
  21da94:	4a 8d 34 2b          	lea    rsi,[rbx+r13*1]
  21da98:	48 8b 7c 24 28       	mov    rdi,QWORD PTR [rsp+0x28]
  21da9d:	48 01 fe             	add    rsi,rdi
  21daa0:	4c 01 f6             	add    rsi,r14
  21daa3:	48 c1 e6 04          	shl    rsi,0x4
  21daa7:	48 01 ce             	add    rsi,rcx
  21daaa:	48 8d 3c 3b          	lea    rdi,[rbx+rdi*1]
  21daae:	4c 01 f7             	add    rdi,r14
  21dab1:	48 c1 e7 04          	shl    rdi,0x4
  21dab5:	48 03 bc 24 e8 00 00 	add    rdi,QWORD PTR [rsp+0xe8]
  21dabc:	00 
  21dabd:	bb 70 00 00 00       	mov    ebx,0x70
  21dac2:	31 c9                	xor    ecx,ecx
  21dac4:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21dacb:	00 00 00 00 00 
        dest[i] = s;
  21dad0:	c5 f8 10 44 1e 90    	vmovups xmm0,XMMWORD PTR [rsi+rbx*1-0x70]
  21dad6:	c5 f8 11 44 1f 90    	vmovups XMMWORD PTR [rdi+rbx*1-0x70],xmm0
  21dadc:	c5 f8 10 44 1e a0    	vmovups xmm0,XMMWORD PTR [rsi+rbx*1-0x60]
  21dae2:	c5 f8 11 44 1f a0    	vmovups XMMWORD PTR [rdi+rbx*1-0x60],xmm0
  21dae8:	c5 f8 10 44 1e b0    	vmovups xmm0,XMMWORD PTR [rsi+rbx*1-0x50]
  21daee:	c5 f8 11 44 1f b0    	vmovups XMMWORD PTR [rdi+rbx*1-0x50],xmm0
  21daf4:	c5 f8 10 44 1e c0    	vmovups xmm0,XMMWORD PTR [rsi+rbx*1-0x40]
  21dafa:	c5 f8 11 44 1f c0    	vmovups XMMWORD PTR [rdi+rbx*1-0x40],xmm0
  21db00:	c5 f8 10 44 1e d0    	vmovups xmm0,XMMWORD PTR [rsi+rbx*1-0x30]
  21db06:	c5 f8 11 44 1f d0    	vmovups XMMWORD PTR [rdi+rbx*1-0x30],xmm0
  21db0c:	c5 f8 10 44 1e e0    	vmovups xmm0,XMMWORD PTR [rsi+rbx*1-0x20]
  21db12:	c5 f8 11 44 1f e0    	vmovups XMMWORD PTR [rdi+rbx*1-0x20],xmm0
  21db18:	c5 f8 10 44 1e f0    	vmovups xmm0,XMMWORD PTR [rsi+rbx*1-0x10]
  21db1e:	c5 f8 11 44 1f f0    	vmovups XMMWORD PTR [rdi+rbx*1-0x10],xmm0
  21db24:	c5 fa 6f 04 1e       	vmovdqu xmm0,XMMWORD PTR [rsi+rbx*1]
  21db29:	c5 fa 7f 04 1f       	vmovdqu XMMWORD PTR [rdi+rbx*1],xmm0
    for (source) |s, i|
  21db2e:	48 83 c1 08          	add    rcx,0x8
  21db32:	48 83 eb 80          	sub    rbx,0xffffffffffffff80
  21db36:	48 39 ca             	cmp    rdx,rcx
  21db39:	75 95                	jne    21dad0 <Benchmark_reportStats+0x7390>
  21db3b:	48 85 c0             	test   rax,rax
  21db3e:	0f 84 65 02 00 00    	je     21dda9 <Benchmark_reportStats+0x7669>
  21db44:	48 8b 5c 24 30       	mov    rbx,QWORD PTR [rsp+0x30]
  21db49:	48 8d 14 19          	lea    rdx,[rcx+rbx*1]
  21db4d:	48 8b 74 24 28       	mov    rsi,QWORD PTR [rsp+0x28]
  21db52:	48 89 f7             	mov    rdi,rsi
  21db55:	48 01 fa             	add    rdx,rdi
  21db58:	4c 01 f2             	add    rdx,r14
  21db5b:	48 c1 e2 04          	shl    rdx,0x4
  21db5f:	48 03 94 24 e8 00 00 	add    rdx,QWORD PTR [rsp+0xe8]
  21db66:	00 
  21db67:	48 8b b4 24 30 01 00 	mov    rsi,QWORD PTR [rsp+0x130]
  21db6e:	00 
  21db6f:	49 8d 34 37          	lea    rsi,[r15+rsi*1]
  21db73:	4c 01 e9             	add    rcx,r13
  21db76:	48 01 d9             	add    rcx,rbx
  21db79:	48 01 f9             	add    rcx,rdi
  21db7c:	4c 01 f1             	add    rcx,r14
  21db7f:	48 c1 e1 04          	shl    rcx,0x4
  21db83:	48 01 f1             	add    rcx,rsi
  21db86:	48 f7 d8             	neg    rax
  21db89:	31 f6                	xor    esi,esi
  21db8b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
        dest[i] = s;
  21db90:	c5 fa 6f 04 31       	vmovdqu xmm0,XMMWORD PTR [rcx+rsi*1]
  21db95:	c5 fa 7f 04 32       	vmovdqu XMMWORD PTR [rdx+rsi*1],xmm0
    for (source) |s, i|
  21db9a:	48 83 c6 10          	add    rsi,0x10
  21db9e:	48 83 c0 01          	add    rax,0x1
  21dba2:	75 ec                	jne    21db90 <Benchmark_reportStats+0x7450>
  21dba4:	e9 00 02 00 00       	jmp    21dda9 <Benchmark_reportStats+0x7669>
  21dba9:	4c 8b 74 24 58       	mov    r14,QWORD PTR [rsp+0x58]
  21dbae:	e9 fb 01 00 00       	jmp    21ddae <Benchmark_reportStats+0x766e>
  21dbb3:	4b 8d 3c 02          	lea    rdi,[r10+r8*1]
  21dbb7:	48 c1 e7 04          	shl    rdi,0x4
  21dbbb:	48 03 bc 24 28 01 00 	add    rdi,QWORD PTR [rsp+0x128]
  21dbc2:	00 
  21dbc3:	4c 01 f7             	add    rdi,r14
  21dbc6:	48 8b 8c 24 18 01 00 	mov    rcx,QWORD PTR [rsp+0x118]
  21dbcd:	00 
  21dbce:	4a 8d 1c 29          	lea    rbx,[rcx+r13*1]
  21dbd2:	48 03 5c 24 58       	add    rbx,QWORD PTR [rsp+0x58]
  21dbd7:	4c 01 d3             	add    rbx,r10
  21dbda:	4c 01 c3             	add    rbx,r8
  21dbdd:	4d 89 da             	mov    r10,r11
  21dbe0:	4c 29 db             	sub    rbx,r11
  21dbe3:	48 29 d3             	sub    rbx,rdx
  21dbe6:	ba 70 00 00 00       	mov    edx,0x70
  21dbeb:	31 c9                	xor    ecx,ecx
  21dbed:	0f 1f 00             	nop    DWORD PTR [rax]
        dest[i] = s;
  21dbf0:	c5 f8 10 44 10 90    	vmovups xmm0,XMMWORD PTR [rax+rdx*1-0x70]
  21dbf6:	c5 f8 11 44 17 a0    	vmovups XMMWORD PTR [rdi+rdx*1-0x60],xmm0
  21dbfc:	c5 f8 10 44 10 a0    	vmovups xmm0,XMMWORD PTR [rax+rdx*1-0x60]
  21dc02:	c5 f8 11 44 17 b0    	vmovups XMMWORD PTR [rdi+rdx*1-0x50],xmm0
  21dc08:	c5 f8 10 44 10 b0    	vmovups xmm0,XMMWORD PTR [rax+rdx*1-0x50]
  21dc0e:	c5 f8 11 44 17 c0    	vmovups XMMWORD PTR [rdi+rdx*1-0x40],xmm0
  21dc14:	c5 f8 10 44 10 c0    	vmovups xmm0,XMMWORD PTR [rax+rdx*1-0x40]
  21dc1a:	c5 f8 11 44 17 d0    	vmovups XMMWORD PTR [rdi+rdx*1-0x30],xmm0
  21dc20:	c5 f8 10 44 10 d0    	vmovups xmm0,XMMWORD PTR [rax+rdx*1-0x30]
  21dc26:	c5 f8 11 44 17 e0    	vmovups XMMWORD PTR [rdi+rdx*1-0x20],xmm0
  21dc2c:	c5 f8 10 44 10 e0    	vmovups xmm0,XMMWORD PTR [rax+rdx*1-0x20]
  21dc32:	c5 f8 11 44 17 f0    	vmovups XMMWORD PTR [rdi+rdx*1-0x10],xmm0
  21dc38:	c5 f8 10 44 10 f0    	vmovups xmm0,XMMWORD PTR [rax+rdx*1-0x10]
  21dc3e:	c5 f8 11 04 17       	vmovups XMMWORD PTR [rdi+rdx*1],xmm0
  21dc43:	c5 fa 6f 04 10       	vmovdqu xmm0,XMMWORD PTR [rax+rdx*1]
  21dc48:	c5 fa 7f 44 17 10    	vmovdqu XMMWORD PTR [rdi+rdx*1+0x10],xmm0
    for (source) |s, i|
  21dc4e:	48 83 c1 08          	add    rcx,0x8
  21dc52:	48 83 ea 80          	sub    rdx,0xffffffffffffff80
  21dc56:	48 39 cb             	cmp    rbx,rcx
  21dc59:	75 95                	jne    21dbf0 <Benchmark_reportStats+0x74b0>
  21dc5b:	4d 85 d2             	test   r10,r10
  21dc5e:	4c 8b 5c 24 60       	mov    r11,QWORD PTR [rsp+0x60]
  21dc63:	0f 84 3b 01 00 00    	je     21dda4 <Benchmark_reportStats+0x7664>
  21dc69:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
  21dc6e:	48 8d 04 01          	lea    rax,[rcx+rax*1]
  21dc72:	4c 01 c0             	add    rax,r8
  21dc75:	48 c1 e0 04          	shl    rax,0x4
  21dc79:	48 03 44 24 70       	add    rax,QWORD PTR [rsp+0x70]
  21dc7e:	4c 01 f0             	add    rax,r14
  21dc81:	48 c1 e1 04          	shl    rcx,0x4
  21dc85:	4c 01 f9             	add    rcx,r15
  21dc88:	48 01 f1             	add    rcx,rsi
  21dc8b:	49 f7 da             	neg    r10
  21dc8e:	31 d2                	xor    edx,edx
        dest[i] = s;
  21dc90:	c5 fa 6f 04 11       	vmovdqu xmm0,XMMWORD PTR [rcx+rdx*1]
  21dc95:	c5 fa 7f 04 10       	vmovdqu XMMWORD PTR [rax+rdx*1],xmm0
    for (source) |s, i|
  21dc9a:	48 83 c2 10          	add    rdx,0x10
  21dc9e:	49 83 c2 01          	add    r10,0x1
  21dca2:	75 ec                	jne    21dc90 <Benchmark_reportStats+0x7550>
  21dca4:	e9 fb 00 00 00       	jmp    21dda4 <Benchmark_reportStats+0x7664>
  21dca9:	4a 8d 34 16          	lea    rsi,[rsi+r10*1]
  21dcad:	48 c1 e6 04          	shl    rsi,0x4
  21dcb1:	48 03 b4 24 28 01 00 	add    rsi,QWORD PTR [rsp+0x128]
  21dcb8:	00 
  21dcb9:	4c 01 f6             	add    rsi,r14
  21dcbc:	48 8b 94 24 58 01 00 	mov    rdx,QWORD PTR [rsp+0x158]
  21dcc3:	00 
  21dcc4:	4a 8d 3c 2a          	lea    rdi,[rdx+r13*1]
  21dcc8:	48 03 7c 24 58       	add    rdi,QWORD PTR [rsp+0x58]
  21dccd:	4c 01 df             	add    rdi,r11
  21dcd0:	48 03 7c 24 28       	add    rdi,QWORD PTR [rsp+0x28]
  21dcd5:	4c 01 d7             	add    rdi,r10
  21dcd8:	48 29 c7             	sub    rdi,rax
  21dcdb:	48 29 df             	sub    rdi,rbx
  21dcde:	bb 70 00 00 00       	mov    ebx,0x70
  21dce3:	31 d2                	xor    edx,edx
  21dce5:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21dcec:	00 00 00 00 
        dest[i] = s;
  21dcf0:	c4 c1 78 10 44 18 90 	vmovups xmm0,XMMWORD PTR [r8+rbx*1-0x70]
  21dcf7:	c5 f8 11 44 1e a0    	vmovups XMMWORD PTR [rsi+rbx*1-0x60],xmm0
  21dcfd:	c4 c1 78 10 44 18 a0 	vmovups xmm0,XMMWORD PTR [r8+rbx*1-0x60]
  21dd04:	c5 f8 11 44 1e b0    	vmovups XMMWORD PTR [rsi+rbx*1-0x50],xmm0
  21dd0a:	c4 c1 78 10 44 18 b0 	vmovups xmm0,XMMWORD PTR [r8+rbx*1-0x50]
  21dd11:	c5 f8 11 44 1e c0    	vmovups XMMWORD PTR [rsi+rbx*1-0x40],xmm0
  21dd17:	c4 c1 78 10 44 18 c0 	vmovups xmm0,XMMWORD PTR [r8+rbx*1-0x40]
  21dd1e:	c5 f8 11 44 1e d0    	vmovups XMMWORD PTR [rsi+rbx*1-0x30],xmm0
  21dd24:	c4 c1 78 10 44 18 d0 	vmovups xmm0,XMMWORD PTR [r8+rbx*1-0x30]
  21dd2b:	c5 f8 11 44 1e e0    	vmovups XMMWORD PTR [rsi+rbx*1-0x20],xmm0
  21dd31:	c4 c1 78 10 44 18 e0 	vmovups xmm0,XMMWORD PTR [r8+rbx*1-0x20]
  21dd38:	c5 f8 11 44 1e f0    	vmovups XMMWORD PTR [rsi+rbx*1-0x10],xmm0
  21dd3e:	c4 c1 78 10 44 18 f0 	vmovups xmm0,XMMWORD PTR [r8+rbx*1-0x10]
  21dd45:	c5 f8 11 04 1e       	vmovups XMMWORD PTR [rsi+rbx*1],xmm0
  21dd4a:	c4 c1 7a 6f 04 18    	vmovdqu xmm0,XMMWORD PTR [r8+rbx*1]
  21dd50:	c5 fa 7f 44 1e 10    	vmovdqu XMMWORD PTR [rsi+rbx*1+0x10],xmm0
    for (source) |s, i|
  21dd56:	48 83 c2 08          	add    rdx,0x8
  21dd5a:	48 83 eb 80          	sub    rbx,0xffffffffffffff80
  21dd5e:	48 39 d7             	cmp    rdi,rdx
  21dd61:	75 8d                	jne    21dcf0 <Benchmark_reportStats+0x75b0>
  21dd63:	48 85 c0             	test   rax,rax
  21dd66:	74 3c                	je     21dda4 <Benchmark_reportStats+0x7664>
  21dd68:	48 8b 74 24 28       	mov    rsi,QWORD PTR [rsp+0x28]
  21dd6d:	48 8d 34 32          	lea    rsi,[rdx+rsi*1]
  21dd71:	4c 01 d6             	add    rsi,r10
  21dd74:	48 c1 e6 04          	shl    rsi,0x4
  21dd78:	48 03 74 24 70       	add    rsi,QWORD PTR [rsp+0x70]
  21dd7d:	4c 01 f6             	add    rsi,r14
  21dd80:	48 c1 e2 04          	shl    rdx,0x4
  21dd84:	4c 01 fa             	add    rdx,r15
  21dd87:	48 01 ca             	add    rdx,rcx
  21dd8a:	48 f7 d8             	neg    rax
  21dd8d:	31 c9                	xor    ecx,ecx
  21dd8f:	90                   	nop
        dest[i] = s;
  21dd90:	c5 fa 6f 04 0a       	vmovdqu xmm0,XMMWORD PTR [rdx+rcx*1]
  21dd95:	c5 fa 7f 04 0e       	vmovdqu XMMWORD PTR [rsi+rcx*1],xmm0
    for (source) |s, i|
  21dd9a:	48 83 c1 10          	add    rcx,0x10
  21dd9e:	48 83 c0 01          	add    rax,0x1
  21dda2:	75 ec                	jne    21dd90 <Benchmark_reportStats+0x7650>
  21dda4:	4c 8b 74 24 58       	mov    r14,QWORD PTR [rsp+0x58]
  21dda9:	48 8b 74 24 78       	mov    rsi,QWORD PTR [rsp+0x78]
        return self.end - self.start;
  21ddae:	4c 89 cf             	mov    rdi,r9
  21ddb1:	48 2b 7c 24 18       	sub    rdi,QWORD PTR [rsp+0x18]
                    const B3 = Range.init(A1.length(), A1.length() + A2.length());
  21ddb6:	4c 8d 04 3e          	lea    r8,[rsi+rdi*1]
                    if (lessThan(cache[B3.end - 1], cache[A3.start])) {
  21ddba:	4c 89 c0             	mov    rax,r8
  21ddbd:	48 c1 e0 04          	shl    rax,0x4
  21ddc1:	48 8b 84 04 18 02 00 	mov    rax,QWORD PTR [rsp+rax*1+0x218]
  21ddc8:	00 
  21ddc9:	48 3b 84 24 28 02 00 	cmp    rax,QWORD PTR [rsp+0x228]
  21ddd0:	00 
  21ddd1:	73 4d                	jae    21de20 <Benchmark_reportStats+0x76e0>
                        mem.copy(T, items[A1.start + A2.length() ..], cache[A3.start..A3.end]);
  21ddd3:	4e 8d 04 2f          	lea    r8,[rdi+r13*1]
  21ddd7:	48 8b 44 24 48       	mov    rax,QWORD PTR [rsp+0x48]
  21dddc:	48 89 c1             	mov    rcx,rax
  21dddf:	4c 29 c1             	sub    rcx,r8
    assert(dest.len >= source.len);
  21dde2:	48 39 f1             	cmp    rcx,rsi
  21dde5:	0f 82 c1 14 00 00    	jb     21f2ac <Benchmark_reportStats+0x8b6c>
    for (source) |s, i|
  21ddeb:	48 85 f6             	test   rsi,rsi
  21ddee:	0f 84 99 01 00 00    	je     21df8d <Benchmark_reportStats+0x784d>
  21ddf4:	48 8d 46 ff          	lea    rax,[rsi-0x1]
  21ddf8:	89 f1                	mov    ecx,esi
  21ddfa:	83 e1 07             	and    ecx,0x7
  21ddfd:	48 83 f8 07          	cmp    rax,0x7
  21de01:	0f 83 d9 01 00 00    	jae    21dfe0 <Benchmark_reportStats+0x78a0>
  21de07:	49 89 f1             	mov    r9,rsi
  21de0a:	31 f6                	xor    esi,esi
  21de0c:	48 85 c9             	test   rcx,rcx
  21de0f:	0f 85 88 02 00 00    	jne    21e09d <Benchmark_reportStats+0x795d>
  21de15:	e9 af 02 00 00       	jmp    21e0c9 <Benchmark_reportStats+0x7989>
  21de1a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
                    } else if (lessThan(cache[B3.start], cache[A3.end - 1])) {
  21de20:	48 89 f1             	mov    rcx,rsi
  21de23:	48 c1 e1 04          	shl    rcx,0x4
  21de27:	48 8b 84 0c 28 02 00 	mov    rax,QWORD PTR [rsp+rcx*1+0x228]
  21de2e:	00 
  21de2f:	48 8b 5c 24 48       	mov    rbx,QWORD PTR [rsp+0x48]
  21de34:	48 89 da             	mov    rdx,rbx
  21de37:	4c 29 ea             	sub    rdx,r13
  21de3a:	48 3b 84 0c 18 02 00 	cmp    rax,QWORD PTR [rsp+rcx*1+0x218]
  21de41:	00 
  21de42:	0f 83 08 01 00 00    	jae    21df50 <Benchmark_reportStats+0x7810>
  21de48:	48 89 54 24 18       	mov    QWORD PTR [rsp+0x18],rdx
  21de4d:	49 89 f2             	mov    r10,rsi
  21de50:	48 89 f2             	mov    rdx,rsi
  21de53:	31 f6                	xor    esi,esi
  21de55:	31 c9                	xor    ecx,ecx
  21de57:	eb 16                	jmp    21de6f <Benchmark_reportStats+0x772f>
  21de59:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  21de60:	48 89 d0             	mov    rax,rdx
  21de63:	48 c1 e0 04          	shl    rax,0x4
  21de67:	48 8b 84 04 28 02 00 	mov    rax,QWORD PTR [rsp+rax*1+0x228]
  21de6e:	00 
        if (!lessThan(from[B_index], from[A_index])) {
  21de6f:	48 89 d3             	mov    rbx,rdx
  21de72:	48 c1 e3 04          	shl    rbx,0x4
  21de76:	4c 8d 0c 1c          	lea    r9,[rsp+rbx*1]
  21de7a:	49 81 c1 28 02 00 00 	add    r9,0x228
  21de81:	48 89 f7             	mov    rdi,rsi
  21de84:	48 c1 e7 04          	shl    rdi,0x4
  21de88:	4c 8d 2c 3c          	lea    r13,[rsp+rdi*1]
  21de8c:	49 81 c5 28 02 00 00 	add    r13,0x228
  21de93:	49 89 cb             	mov    r11,rcx
  21de96:	49 c1 e3 04          	shl    r11,0x4
  21de9a:	4f 8d 34 1c          	lea    r14,[r12+r11*1]
  21de9e:	48 3b 84 3c 28 02 00 	cmp    rax,QWORD PTR [rsp+rdi*1+0x228]
  21dea5:	00 
  21dea6:	73 28                	jae    21ded0 <Benchmark_reportStats+0x7790>
            into[insert_index] = from[B_index];
  21dea8:	c4 c1 7a 6f 01       	vmovdqu xmm0,XMMWORD PTR [r9]
  21dead:	c4 c1 7a 7f 06       	vmovdqu XMMWORD PTR [r14],xmm0
            B_index += 1;
  21deb2:	48 83 c2 01          	add    rdx,0x1
            insert_index += 1;
  21deb6:	48 83 c1 01          	add    rcx,0x1
            if (B_index == B_last) {
  21deba:	4c 39 c2             	cmp    rdx,r8
  21debd:	75 a1                	jne    21de60 <Benchmark_reportStats+0x7720>
  21debf:	e9 16 03 00 00       	jmp    21e1da <Benchmark_reportStats+0x7a9a>
  21dec4:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21decb:	00 00 00 00 00 
            into[insert_index] = from[A_index];
  21ded0:	c4 c1 7a 6f 45 00    	vmovdqu xmm0,XMMWORD PTR [r13+0x0]
  21ded6:	c4 c1 7a 7f 06       	vmovdqu XMMWORD PTR [r14],xmm0
            A_index += 1;
  21dedb:	48 83 c6 01          	add    rsi,0x1
            insert_index += 1;
  21dedf:	48 83 c1 01          	add    rcx,0x1
            if (A_index == A_last) {
  21dee3:	4c 39 d6             	cmp    rsi,r10
  21dee6:	0f 85 74 ff ff ff    	jne    21de60 <Benchmark_reportStats+0x7720>
  21deec:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
                mem.copy(T, into[insert_index..], from[B_index..B_last]);
  21def1:	48 29 c8             	sub    rax,rcx
  21def4:	49 29 d0             	sub    r8,rdx
    assert(dest.len >= source.len);
  21def7:	4c 39 c0             	cmp    rax,r8
  21defa:	0f 82 ac 13 00 00    	jb     21f2ac <Benchmark_reportStats+0x8b6c>
    for (source) |s, i|
  21df00:	4d 85 c0             	test   r8,r8
  21df03:	0f 84 37 07 00 00    	je     21e640 <Benchmark_reportStats+0x7f00>
  21df09:	48 8b 84 24 38 01 00 	mov    rax,QWORD PTR [rsp+0x138]
  21df10:	00 
  21df11:	4a 8d 04 10          	lea    rax,[rax+r10*1]
  21df15:	48 8b 74 24 58       	mov    rsi,QWORD PTR [rsp+0x58]
  21df1a:	48 01 f0             	add    rax,rsi
  21df1d:	48 8b 4c 24 60       	mov    rcx,QWORD PTR [rsp+0x60]
  21df22:	48 01 c8             	add    rax,rcx
  21df25:	48 29 d0             	sub    rax,rdx
  21df28:	41 83 e0 07          	and    r8d,0x7
  21df2c:	48 83 f8 07          	cmp    rax,0x7
  21df30:	0f 83 33 05 00 00    	jae    21e469 <Benchmark_reportStats+0x7d29>
  21df36:	31 c0                	xor    eax,eax
  21df38:	4d 85 c0             	test   r8,r8
  21df3b:	48 8b 4c 24 10       	mov    rcx,QWORD PTR [rsp+0x10]
  21df40:	0f 85 d3 05 00 00    	jne    21e519 <Benchmark_reportStats+0x7dd9>
  21df46:	e9 f5 06 00 00       	jmp    21e640 <Benchmark_reportStats+0x7f00>
  21df4b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
    assert(dest.len >= source.len);
  21df50:	48 39 f2             	cmp    rdx,rsi
  21df53:	0f 82 53 13 00 00    	jb     21f2ac <Benchmark_reportStats+0x8b6c>
    for (source) |s, i|
  21df59:	48 85 f6             	test   rsi,rsi
  21df5c:	4c 8b 4c 24 28       	mov    r9,QWORD PTR [rsp+0x28]
  21df61:	0f 84 9f 03 00 00    	je     21e306 <Benchmark_reportStats+0x7bc6>
  21df67:	48 8d 46 ff          	lea    rax,[rsi-0x1]
  21df6b:	89 f2                	mov    edx,esi
  21df6d:	83 e2 07             	and    edx,0x7
  21df70:	48 83 f8 07          	cmp    rax,0x7
  21df74:	0f 83 ab 02 00 00    	jae    21e225 <Benchmark_reportStats+0x7ae5>
  21df7a:	49 89 f0             	mov    r8,rsi
  21df7d:	31 f6                	xor    esi,esi
  21df7f:	48 85 d2             	test   rdx,rdx
  21df82:	0f 85 4d 03 00 00    	jne    21e2d5 <Benchmark_reportStats+0x7b95>
  21df88:	e9 6c 03 00 00       	jmp    21e2f9 <Benchmark_reportStats+0x7bb9>
  21df8d:	49 89 f1             	mov    r9,rsi
                        mem.copy(T, items[A1.start..], cache[B3.start..B3.end]);
  21df90:	4c 29 e8             	sub    rax,r13
    assert(dest.len >= source.len);
  21df93:	48 39 f8             	cmp    rax,rdi
  21df96:	0f 82 10 13 00 00    	jb     21f2ac <Benchmark_reportStats+0x8b6c>
    for (source) |s, i|
  21df9c:	48 85 ff             	test   rdi,rdi
  21df9f:	0f 84 9b 06 00 00    	je     21e640 <Benchmark_reportStats+0x7f00>
  21dfa5:	48 8b 84 24 38 01 00 	mov    rax,QWORD PTR [rsp+0x138]
  21dfac:	00 
  21dfad:	48 8b 4c 24 58       	mov    rcx,QWORD PTR [rsp+0x58]
  21dfb2:	48 8d 04 08          	lea    rax,[rax+rcx*1]
  21dfb6:	48 8b 74 24 60       	mov    rsi,QWORD PTR [rsp+0x60]
  21dfbb:	48 01 f0             	add    rax,rsi
  21dfbe:	83 e7 07             	and    edi,0x7
  21dfc1:	48 83 f8 07          	cmp    rax,0x7
  21dfc5:	0f 83 19 01 00 00    	jae    21e0e4 <Benchmark_reportStats+0x79a4>
  21dfcb:	31 c9                	xor    ecx,ecx
  21dfcd:	48 85 ff             	test   rdi,rdi
  21dfd0:	48 8b 44 24 10       	mov    rax,QWORD PTR [rsp+0x10]
  21dfd5:	0f 85 be 01 00 00    	jne    21e199 <Benchmark_reportStats+0x7a59>
  21dfdb:	e9 60 06 00 00       	jmp    21e640 <Benchmark_reportStats+0x7f00>
  21dfe0:	49 89 f1             	mov    r9,rsi
  21dfe3:	48 89 f0             	mov    rax,rsi
  21dfe6:	48 29 c8             	sub    rax,rcx
  21dfe9:	48 8b 54 24 68       	mov    rdx,QWORD PTR [rsp+0x68]
  21dfee:	48 c1 e2 04          	shl    rdx,0x4
  21dff2:	4c 01 fa             	add    rdx,r15
  21dff5:	4b 8d 1c 2e          	lea    rbx,[r14+r13*1]
  21dff9:	4c 01 db             	add    rbx,r11
  21dffc:	48 c1 e3 04          	shl    rbx,0x4
  21e000:	48 01 d3             	add    rbx,rdx
  21e003:	ba 70 00 00 00       	mov    edx,0x70
  21e008:	31 f6                	xor    esi,esi
  21e00a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
        dest[i] = s;
  21e010:	c5 f8 10 84 14 b8 01 	vmovups xmm0,XMMWORD PTR [rsp+rdx*1+0x1b8]
  21e017:	00 00 
  21e019:	c5 f8 11 44 13 90    	vmovups XMMWORD PTR [rbx+rdx*1-0x70],xmm0
  21e01f:	c5 f8 10 84 14 c8 01 	vmovups xmm0,XMMWORD PTR [rsp+rdx*1+0x1c8]
  21e026:	00 00 
  21e028:	c5 f8 11 44 13 a0    	vmovups XMMWORD PTR [rbx+rdx*1-0x60],xmm0
  21e02e:	c5 f8 10 84 14 d8 01 	vmovups xmm0,XMMWORD PTR [rsp+rdx*1+0x1d8]
  21e035:	00 00 
  21e037:	c5 f8 11 44 13 b0    	vmovups XMMWORD PTR [rbx+rdx*1-0x50],xmm0
  21e03d:	c5 f8 10 84 14 e8 01 	vmovups xmm0,XMMWORD PTR [rsp+rdx*1+0x1e8]
  21e044:	00 00 
  21e046:	c5 f8 11 44 13 c0    	vmovups XMMWORD PTR [rbx+rdx*1-0x40],xmm0
  21e04c:	c5 f8 10 84 14 f8 01 	vmovups xmm0,XMMWORD PTR [rsp+rdx*1+0x1f8]
  21e053:	00 00 
  21e055:	c5 f8 11 44 13 d0    	vmovups XMMWORD PTR [rbx+rdx*1-0x30],xmm0
  21e05b:	c5 f8 10 84 14 08 02 	vmovups xmm0,XMMWORD PTR [rsp+rdx*1+0x208]
  21e062:	00 00 
  21e064:	c5 f8 11 44 13 e0    	vmovups XMMWORD PTR [rbx+rdx*1-0x20],xmm0
  21e06a:	c5 f8 10 84 14 18 02 	vmovups xmm0,XMMWORD PTR [rsp+rdx*1+0x218]
  21e071:	00 00 
  21e073:	c5 f8 11 44 13 f0    	vmovups XMMWORD PTR [rbx+rdx*1-0x10],xmm0
  21e079:	c5 fa 6f 84 14 28 02 	vmovdqu xmm0,XMMWORD PTR [rsp+rdx*1+0x228]
  21e080:	00 00 
  21e082:	c5 fa 7f 04 13       	vmovdqu XMMWORD PTR [rbx+rdx*1],xmm0
    for (source) |s, i|
  21e087:	48 83 c6 08          	add    rsi,0x8
  21e08b:	48 83 ea 80          	sub    rdx,0xffffffffffffff80
  21e08f:	48 39 f0             	cmp    rax,rsi
  21e092:	0f 85 78 ff ff ff    	jne    21e010 <Benchmark_reportStats+0x78d0>
  21e098:	48 85 c9             	test   rcx,rcx
  21e09b:	74 2c                	je     21e0c9 <Benchmark_reportStats+0x7989>
  21e09d:	49 c1 e0 04          	shl    r8,0x4
  21e0a1:	4d 01 c7             	add    r15,r8
  21e0a4:	48 c1 e6 04          	shl    rsi,0x4
  21e0a8:	48 f7 d9             	neg    rcx
  21e0ab:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
        dest[i] = s;
  21e0b0:	c5 fa 6f 84 34 28 02 	vmovdqu xmm0,XMMWORD PTR [rsp+rsi*1+0x228]
  21e0b7:	00 00 
  21e0b9:	c4 c1 7a 7f 04 37    	vmovdqu XMMWORD PTR [r15+rsi*1],xmm0
    for (source) |s, i|
  21e0bf:	48 83 c6 10          	add    rsi,0x10
  21e0c3:	48 83 c1 01          	add    rcx,0x1
  21e0c7:	75 e7                	jne    21e0b0 <Benchmark_reportStats+0x7970>
  21e0c9:	4c 8b 7c 24 40       	mov    r15,QWORD PTR [rsp+0x40]
  21e0ce:	48 8b 44 24 48       	mov    rax,QWORD PTR [rsp+0x48]
  21e0d3:	4c 29 e8             	sub    rax,r13
    assert(dest.len >= source.len);
  21e0d6:	48 39 f8             	cmp    rax,rdi
  21e0d9:	0f 83 bd fe ff ff    	jae    21df9c <Benchmark_reportStats+0x785c>
  21e0df:	e9 c8 11 00 00       	jmp    21f2ac <Benchmark_reportStats+0x8b6c>
  21e0e4:	48 8b 9c 24 08 01 00 	mov    rbx,QWORD PTR [rsp+0x108]
  21e0eb:	00 
  21e0ec:	4c 01 fb             	add    rbx,r15
    for (source) |s, i|
  21e0ef:	4c 89 c8             	mov    rax,r9
  21e0f2:	48 c1 e0 04          	shl    rax,0x4
  21e0f6:	48 8d 14 04          	lea    rdx,[rsp+rax*1]
  21e0fa:	48 81 c2 28 02 00 00 	add    rdx,0x228
  21e101:	48 03 74 24 68       	add    rsi,QWORD PTR [rsp+0x68]
  21e106:	48 01 ce             	add    rsi,rcx
  21e109:	48 29 fe             	sub    rsi,rdi
  21e10c:	b8 70 00 00 00       	mov    eax,0x70
  21e111:	31 c9                	xor    ecx,ecx
  21e113:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21e11a:	84 00 00 00 00 00 
        dest[i] = s;
  21e120:	c5 f8 10 44 02 90    	vmovups xmm0,XMMWORD PTR [rdx+rax*1-0x70]
  21e126:	c5 f8 11 44 03 90    	vmovups XMMWORD PTR [rbx+rax*1-0x70],xmm0
  21e12c:	c5 f8 10 44 02 a0    	vmovups xmm0,XMMWORD PTR [rdx+rax*1-0x60]
  21e132:	c5 f8 11 44 03 a0    	vmovups XMMWORD PTR [rbx+rax*1-0x60],xmm0
  21e138:	c5 f8 10 44 02 b0    	vmovups xmm0,XMMWORD PTR [rdx+rax*1-0x50]
  21e13e:	c5 f8 11 44 03 b0    	vmovups XMMWORD PTR [rbx+rax*1-0x50],xmm0
  21e144:	c5 f8 10 44 02 c0    	vmovups xmm0,XMMWORD PTR [rdx+rax*1-0x40]
  21e14a:	c5 f8 11 44 03 c0    	vmovups XMMWORD PTR [rbx+rax*1-0x40],xmm0
  21e150:	c5 f8 10 44 02 d0    	vmovups xmm0,XMMWORD PTR [rdx+rax*1-0x30]
  21e156:	c5 f8 11 44 03 d0    	vmovups XMMWORD PTR [rbx+rax*1-0x30],xmm0
  21e15c:	c5 f8 10 44 02 e0    	vmovups xmm0,XMMWORD PTR [rdx+rax*1-0x20]
  21e162:	c5 f8 11 44 03 e0    	vmovups XMMWORD PTR [rbx+rax*1-0x20],xmm0
  21e168:	c5 f8 10 44 02 f0    	vmovups xmm0,XMMWORD PTR [rdx+rax*1-0x10]
  21e16e:	c5 f8 11 44 03 f0    	vmovups XMMWORD PTR [rbx+rax*1-0x10],xmm0
  21e174:	c5 fa 6f 04 02       	vmovdqu xmm0,XMMWORD PTR [rdx+rax*1]
  21e179:	c5 fa 7f 04 03       	vmovdqu XMMWORD PTR [rbx+rax*1],xmm0
    for (source) |s, i|
  21e17e:	48 83 c1 08          	add    rcx,0x8
  21e182:	48 83 e8 80          	sub    rax,0xffffffffffffff80
  21e186:	48 39 ce             	cmp    rsi,rcx
  21e189:	75 95                	jne    21e120 <Benchmark_reportStats+0x79e0>
  21e18b:	48 85 ff             	test   rdi,rdi
  21e18e:	48 8b 44 24 10       	mov    rax,QWORD PTR [rsp+0x10]
  21e193:	0f 84 a7 04 00 00    	je     21e640 <Benchmark_reportStats+0x7f00>
  21e199:	48 01 c8             	add    rax,rcx
  21e19c:	48 c1 e0 04          	shl    rax,0x4
  21e1a0:	49 01 c7             	add    r15,rax
  21e1a3:	49 01 c9             	add    r9,rcx
  21e1a6:	49 c1 e1 04          	shl    r9,0x4
  21e1aa:	4a 8d 04 0c          	lea    rax,[rsp+r9*1]
  21e1ae:	48 05 28 02 00 00    	add    rax,0x228
  21e1b4:	48 f7 df             	neg    rdi
  21e1b7:	31 c9                	xor    ecx,ecx
  21e1b9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
        dest[i] = s;
  21e1c0:	c5 fa 6f 04 08       	vmovdqu xmm0,XMMWORD PTR [rax+rcx*1]
  21e1c5:	c4 c1 7a 7f 04 0f    	vmovdqu XMMWORD PTR [r15+rcx*1],xmm0
    for (source) |s, i|
  21e1cb:	48 83 c1 10          	add    rcx,0x10
  21e1cf:	48 83 c7 01          	add    rdi,0x1
  21e1d3:	75 eb                	jne    21e1c0 <Benchmark_reportStats+0x7a80>
  21e1d5:	e9 66 04 00 00       	jmp    21e640 <Benchmark_reportStats+0x7f00>
  21e1da:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
                mem.copy(T, into[insert_index..], from[A_index..A_last]);
  21e1df:	48 29 c8             	sub    rax,rcx
  21e1e2:	4c 89 d1             	mov    rcx,r10
  21e1e5:	48 29 f1             	sub    rcx,rsi
    assert(dest.len >= source.len);
  21e1e8:	48 39 c8             	cmp    rax,rcx
  21e1eb:	0f 82 bb 10 00 00    	jb     21f2ac <Benchmark_reportStats+0x8b6c>
    for (source) |s, i|
  21e1f1:	48 85 c9             	test   rcx,rcx
  21e1f4:	0f 84 46 04 00 00    	je     21e640 <Benchmark_reportStats+0x7f00>
  21e1fa:	49 83 c2 ff          	add    r10,0xffffffffffffffff
  21e1fe:	49 29 f2             	sub    r10,rsi
  21e201:	89 ca                	mov    edx,ecx
  21e203:	83 e2 07             	and    edx,0x7
  21e206:	49 83 fa 07          	cmp    r10,0x7
  21e20a:	0f 83 49 03 00 00    	jae    21e559 <Benchmark_reportStats+0x7e19>
  21e210:	31 f6                	xor    esi,esi
  21e212:	48 85 d2             	test   rdx,rdx
  21e215:	48 8b 44 24 10       	mov    rax,QWORD PTR [rsp+0x10]
  21e21a:	0f 85 d6 03 00 00    	jne    21e5f6 <Benchmark_reportStats+0x7eb6>
  21e220:	e9 1b 04 00 00       	jmp    21e640 <Benchmark_reportStats+0x7f00>
  21e225:	49 89 f0             	mov    r8,rsi
  21e228:	48 89 f0             	mov    rax,rsi
  21e22b:	48 29 d0             	sub    rax,rdx
  21e22e:	bb 70 00 00 00       	mov    ebx,0x70
  21e233:	31 f6                	xor    esi,esi
  21e235:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21e23c:	00 00 00 00 
        dest[i] = s;
  21e240:	c5 f8 10 84 1c b8 01 	vmovups xmm0,XMMWORD PTR [rsp+rbx*1+0x1b8]
  21e247:	00 00 
  21e249:	c4 c1 78 11 44 1c 90 	vmovups XMMWORD PTR [r12+rbx*1-0x70],xmm0
  21e250:	c5 f8 10 84 1c c8 01 	vmovups xmm0,XMMWORD PTR [rsp+rbx*1+0x1c8]
  21e257:	00 00 
  21e259:	c4 c1 78 11 44 1c a0 	vmovups XMMWORD PTR [r12+rbx*1-0x60],xmm0
  21e260:	c5 f8 10 84 1c d8 01 	vmovups xmm0,XMMWORD PTR [rsp+rbx*1+0x1d8]
  21e267:	00 00 
  21e269:	c4 c1 78 11 44 1c b0 	vmovups XMMWORD PTR [r12+rbx*1-0x50],xmm0
  21e270:	c5 f8 10 84 1c e8 01 	vmovups xmm0,XMMWORD PTR [rsp+rbx*1+0x1e8]
  21e277:	00 00 
  21e279:	c4 c1 78 11 44 1c c0 	vmovups XMMWORD PTR [r12+rbx*1-0x40],xmm0
  21e280:	c5 f8 10 84 1c f8 01 	vmovups xmm0,XMMWORD PTR [rsp+rbx*1+0x1f8]
  21e287:	00 00 
  21e289:	c4 c1 78 11 44 1c d0 	vmovups XMMWORD PTR [r12+rbx*1-0x30],xmm0
  21e290:	c5 f8 10 84 1c 08 02 	vmovups xmm0,XMMWORD PTR [rsp+rbx*1+0x208]
  21e297:	00 00 
  21e299:	c4 c1 78 11 44 1c e0 	vmovups XMMWORD PTR [r12+rbx*1-0x20],xmm0
  21e2a0:	c5 f8 10 84 1c 18 02 	vmovups xmm0,XMMWORD PTR [rsp+rbx*1+0x218]
  21e2a7:	00 00 
  21e2a9:	c4 c1 78 11 44 1c f0 	vmovups XMMWORD PTR [r12+rbx*1-0x10],xmm0
  21e2b0:	c5 fa 6f 84 1c 28 02 	vmovdqu xmm0,XMMWORD PTR [rsp+rbx*1+0x228]
  21e2b7:	00 00 
  21e2b9:	c4 c1 7a 7f 04 1c    	vmovdqu XMMWORD PTR [r12+rbx*1],xmm0
    for (source) |s, i|
  21e2bf:	48 83 c6 08          	add    rsi,0x8
  21e2c3:	48 83 eb 80          	sub    rbx,0xffffffffffffff80
  21e2c7:	48 39 f0             	cmp    rax,rsi
  21e2ca:	0f 85 70 ff ff ff    	jne    21e240 <Benchmark_reportStats+0x7b00>
  21e2d0:	48 85 d2             	test   rdx,rdx
  21e2d3:	74 24                	je     21e2f9 <Benchmark_reportStats+0x7bb9>
  21e2d5:	48 c1 e6 04          	shl    rsi,0x4
  21e2d9:	48 f7 da             	neg    rdx
  21e2dc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
        dest[i] = s;
  21e2e0:	c5 fa 6f 84 34 28 02 	vmovdqu xmm0,XMMWORD PTR [rsp+rsi*1+0x228]
  21e2e7:	00 00 
  21e2e9:	c4 c1 7a 7f 04 34    	vmovdqu XMMWORD PTR [r12+rsi*1],xmm0
    for (source) |s, i|
  21e2ef:	48 83 c6 10          	add    rsi,0x10
  21e2f3:	48 83 c2 01          	add    rdx,0x1
  21e2f7:	75 e7                	jne    21e2e0 <Benchmark_reportStats+0x7ba0>
                        mem.copy(T, items[A1.start + A1.length() ..], cache[B3.start..B3.end]);
  21e2f9:	4c 8b 7c 24 40       	mov    r15,QWORD PTR [rsp+0x40]
  21e2fe:	48 8b 5c 24 48       	mov    rbx,QWORD PTR [rsp+0x48]
  21e303:	4c 89 c6             	mov    rsi,r8
  21e306:	49 89 f3             	mov    r11,rsi
  21e309:	48 2b 5c 24 18       	sub    rbx,QWORD PTR [rsp+0x18]
    assert(dest.len >= source.len);
  21e30e:	48 39 fb             	cmp    rbx,rdi
  21e311:	0f 82 95 0f 00 00    	jb     21f2ac <Benchmark_reportStats+0x8b6c>
    for (source) |s, i|
  21e317:	48 85 ff             	test   rdi,rdi
  21e31a:	0f 84 20 03 00 00    	je     21e640 <Benchmark_reportStats+0x7f00>
  21e320:	48 8b 84 24 38 01 00 	mov    rax,QWORD PTR [rsp+0x138]
  21e327:	00 
  21e328:	4c 8b 44 24 58       	mov    r8,QWORD PTR [rsp+0x58]
  21e32d:	4a 8d 04 00          	lea    rax,[rax+r8*1]
  21e331:	48 8b 5c 24 60       	mov    rbx,QWORD PTR [rsp+0x60]
  21e336:	48 01 d8             	add    rax,rbx
  21e339:	83 e7 07             	and    edi,0x7
  21e33c:	48 83 f8 07          	cmp    rax,0x7
  21e340:	73 15                	jae    21e357 <Benchmark_reportStats+0x7c17>
  21e342:	31 c9                	xor    ecx,ecx
  21e344:	48 85 ff             	test   rdi,rdi
  21e347:	48 8b 54 24 10       	mov    rdx,QWORD PTR [rsp+0x10]
  21e34c:	0f 85 c7 00 00 00    	jne    21e419 <Benchmark_reportStats+0x7cd9>
  21e352:	e9 e9 02 00 00       	jmp    21e640 <Benchmark_reportStats+0x7f00>
  21e357:	48 8d 14 0c          	lea    rdx,[rsp+rcx*1]
  21e35b:	48 81 c2 28 02 00 00 	add    rdx,0x228
  21e362:	48 8b 4c 24 68       	mov    rcx,QWORD PTR [rsp+0x68]
  21e367:	48 89 c8             	mov    rax,rcx
  21e36a:	48 c1 e0 04          	shl    rax,0x4
  21e36e:	4c 01 f8             	add    rax,r15
  21e371:	48 8b 74 24 10       	mov    rsi,QWORD PTR [rsp+0x10]
  21e376:	4a 8d 34 0e          	lea    rsi,[rsi+r9*1]
  21e37a:	48 03 74 24 30       	add    rsi,QWORD PTR [rsp+0x30]
  21e37f:	48 c1 e6 04          	shl    rsi,0x4
  21e383:	48 01 c6             	add    rsi,rax
  21e386:	48 01 cb             	add    rbx,rcx
  21e389:	4c 01 c3             	add    rbx,r8
  21e38c:	48 29 fb             	sub    rbx,rdi
  21e38f:	b8 70 00 00 00       	mov    eax,0x70
  21e394:	31 c9                	xor    ecx,ecx
  21e396:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  21e39d:	00 00 00 
        dest[i] = s;
  21e3a0:	c5 f8 10 44 02 90    	vmovups xmm0,XMMWORD PTR [rdx+rax*1-0x70]
  21e3a6:	c5 f8 11 44 06 90    	vmovups XMMWORD PTR [rsi+rax*1-0x70],xmm0
  21e3ac:	c5 f8 10 44 02 a0    	vmovups xmm0,XMMWORD PTR [rdx+rax*1-0x60]
  21e3b2:	c5 f8 11 44 06 a0    	vmovups XMMWORD PTR [rsi+rax*1-0x60],xmm0
  21e3b8:	c5 f8 10 44 02 b0    	vmovups xmm0,XMMWORD PTR [rdx+rax*1-0x50]
  21e3be:	c5 f8 11 44 06 b0    	vmovups XMMWORD PTR [rsi+rax*1-0x50],xmm0
  21e3c4:	c5 f8 10 44 02 c0    	vmovups xmm0,XMMWORD PTR [rdx+rax*1-0x40]
  21e3ca:	c5 f8 11 44 06 c0    	vmovups XMMWORD PTR [rsi+rax*1-0x40],xmm0
  21e3d0:	c5 f8 10 44 02 d0    	vmovups xmm0,XMMWORD PTR [rdx+rax*1-0x30]
  21e3d6:	c5 f8 11 44 06 d0    	vmovups XMMWORD PTR [rsi+rax*1-0x30],xmm0
  21e3dc:	c5 f8 10 44 02 e0    	vmovups xmm0,XMMWORD PTR [rdx+rax*1-0x20]
  21e3e2:	c5 f8 11 44 06 e0    	vmovups XMMWORD PTR [rsi+rax*1-0x20],xmm0
  21e3e8:	c5 f8 10 44 02 f0    	vmovups xmm0,XMMWORD PTR [rdx+rax*1-0x10]
  21e3ee:	c5 f8 11 44 06 f0    	vmovups XMMWORD PTR [rsi+rax*1-0x10],xmm0
  21e3f4:	c5 fa 6f 04 02       	vmovdqu xmm0,XMMWORD PTR [rdx+rax*1]
  21e3f9:	c5 fa 7f 04 06       	vmovdqu XMMWORD PTR [rsi+rax*1],xmm0
    for (source) |s, i|
  21e3fe:	48 83 c1 08          	add    rcx,0x8
  21e402:	48 83 e8 80          	sub    rax,0xffffffffffffff80
  21e406:	48 39 cb             	cmp    rbx,rcx
  21e409:	75 95                	jne    21e3a0 <Benchmark_reportStats+0x7c60>
  21e40b:	48 85 ff             	test   rdi,rdi
  21e40e:	48 8b 54 24 10       	mov    rdx,QWORD PTR [rsp+0x10]
  21e413:	0f 84 27 02 00 00    	je     21e640 <Benchmark_reportStats+0x7f00>
  21e419:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  21e41e:	48 c1 e0 04          	shl    rax,0x4
  21e422:	49 01 c7             	add    r15,rax
  21e425:	48 01 ca             	add    rdx,rcx
  21e428:	4c 01 ca             	add    rdx,r9
  21e42b:	48 03 54 24 30       	add    rdx,QWORD PTR [rsp+0x30]
  21e430:	48 c1 e2 04          	shl    rdx,0x4
  21e434:	4c 01 fa             	add    rdx,r15
  21e437:	49 01 cb             	add    r11,rcx
  21e43a:	49 c1 e3 04          	shl    r11,0x4
  21e43e:	4a 8d 04 1c          	lea    rax,[rsp+r11*1]
  21e442:	48 05 28 02 00 00    	add    rax,0x228
  21e448:	48 f7 df             	neg    rdi
  21e44b:	31 c9                	xor    ecx,ecx
  21e44d:	0f 1f 00             	nop    DWORD PTR [rax]
        dest[i] = s;
  21e450:	c5 fa 6f 04 08       	vmovdqu xmm0,XMMWORD PTR [rax+rcx*1]
  21e455:	c5 fa 7f 04 0a       	vmovdqu XMMWORD PTR [rdx+rcx*1],xmm0
    for (source) |s, i|
  21e45a:	48 83 c1 10          	add    rcx,0x10
  21e45e:	48 83 c7 01          	add    rdi,0x1
  21e462:	75 ec                	jne    21e450 <Benchmark_reportStats+0x7d10>
  21e464:	e9 d7 01 00 00       	jmp    21e640 <Benchmark_reportStats+0x7f00>
  21e469:	4c 03 54 24 68       	add    r10,QWORD PTR [rsp+0x68]
  21e46e:	49 01 ca             	add    r10,rcx
  21e471:	49 01 f2             	add    r10,rsi
  21e474:	4d 29 c2             	sub    r10,r8
  21e477:	49 29 d2             	sub    r10,rdx
  21e47a:	b9 70 00 00 00       	mov    ecx,0x70
  21e47f:	31 c0                	xor    eax,eax
  21e481:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21e488:	0f 1f 84 00 00 00 00 
  21e48f:	00 
        dest[i] = s;
  21e490:	c4 c1 78 10 44 09 90 	vmovups xmm0,XMMWORD PTR [r9+rcx*1-0x70]
  21e497:	c4 c1 78 11 44 0e a0 	vmovups XMMWORD PTR [r14+rcx*1-0x60],xmm0
  21e49e:	c4 c1 78 10 44 09 a0 	vmovups xmm0,XMMWORD PTR [r9+rcx*1-0x60]
  21e4a5:	c4 c1 78 11 44 0e b0 	vmovups XMMWORD PTR [r14+rcx*1-0x50],xmm0
  21e4ac:	c4 c1 78 10 44 09 b0 	vmovups xmm0,XMMWORD PTR [r9+rcx*1-0x50]
  21e4b3:	c4 c1 78 11 44 0e c0 	vmovups XMMWORD PTR [r14+rcx*1-0x40],xmm0
  21e4ba:	c4 c1 78 10 44 09 c0 	vmovups xmm0,XMMWORD PTR [r9+rcx*1-0x40]
  21e4c1:	c4 c1 78 11 44 0e d0 	vmovups XMMWORD PTR [r14+rcx*1-0x30],xmm0
  21e4c8:	c4 c1 78 10 44 09 d0 	vmovups xmm0,XMMWORD PTR [r9+rcx*1-0x30]
  21e4cf:	c4 c1 78 11 44 0e e0 	vmovups XMMWORD PTR [r14+rcx*1-0x20],xmm0
  21e4d6:	c4 c1 78 10 44 09 e0 	vmovups xmm0,XMMWORD PTR [r9+rcx*1-0x20]
  21e4dd:	c4 c1 78 11 44 0e f0 	vmovups XMMWORD PTR [r14+rcx*1-0x10],xmm0
  21e4e4:	c4 c1 78 10 44 09 f0 	vmovups xmm0,XMMWORD PTR [r9+rcx*1-0x10]
  21e4eb:	c4 c1 78 11 04 0e    	vmovups XMMWORD PTR [r14+rcx*1],xmm0
  21e4f1:	c4 c1 7a 6f 04 09    	vmovdqu xmm0,XMMWORD PTR [r9+rcx*1]
  21e4f7:	c4 c1 7a 7f 44 0e 10 	vmovdqu XMMWORD PTR [r14+rcx*1+0x10],xmm0
    for (source) |s, i|
  21e4fe:	48 83 c0 08          	add    rax,0x8
  21e502:	48 83 e9 80          	sub    rcx,0xffffffffffffff80
  21e506:	49 39 c2             	cmp    r10,rax
  21e509:	75 85                	jne    21e490 <Benchmark_reportStats+0x7d50>
  21e50b:	4d 85 c0             	test   r8,r8
  21e50e:	48 8b 4c 24 10       	mov    rcx,QWORD PTR [rsp+0x10]
  21e513:	0f 84 27 01 00 00    	je     21e640 <Benchmark_reportStats+0x7f00>
  21e519:	48 01 c1             	add    rcx,rax
  21e51c:	48 c1 e1 04          	shl    rcx,0x4
  21e520:	49 01 cf             	add    r15,rcx
  21e523:	4b 8d 0c 3b          	lea    rcx,[r11+r15*1]
  21e527:	48 83 c1 10          	add    rcx,0x10
  21e52b:	48 c1 e0 04          	shl    rax,0x4
  21e52f:	48 01 e0             	add    rax,rsp
  21e532:	48 05 28 02 00 00    	add    rax,0x228
  21e538:	48 01 d8             	add    rax,rbx
  21e53b:	49 f7 d8             	neg    r8
  21e53e:	31 d2                	xor    edx,edx
        dest[i] = s;
  21e540:	c5 fa 6f 04 10       	vmovdqu xmm0,XMMWORD PTR [rax+rdx*1]
  21e545:	c5 fa 7f 04 11       	vmovdqu XMMWORD PTR [rcx+rdx*1],xmm0
    for (source) |s, i|
  21e54a:	48 83 c2 10          	add    rdx,0x10
  21e54e:	49 83 c0 01          	add    r8,0x1
  21e552:	75 ec                	jne    21e540 <Benchmark_reportStats+0x7e00>
  21e554:	e9 e7 00 00 00       	jmp    21e640 <Benchmark_reportStats+0x7f00>
  21e559:	48 29 d1             	sub    rcx,rdx
  21e55c:	b8 70 00 00 00       	mov    eax,0x70
  21e561:	31 f6                	xor    esi,esi
  21e563:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21e56a:	84 00 00 00 00 00 
        dest[i] = s;
  21e570:	c4 c1 78 10 44 05 90 	vmovups xmm0,XMMWORD PTR [r13+rax*1-0x70]
  21e577:	c4 c1 78 11 44 06 a0 	vmovups XMMWORD PTR [r14+rax*1-0x60],xmm0
  21e57e:	c4 c1 78 10 44 05 a0 	vmovups xmm0,XMMWORD PTR [r13+rax*1-0x60]
  21e585:	c4 c1 78 11 44 06 b0 	vmovups XMMWORD PTR [r14+rax*1-0x50],xmm0
  21e58c:	c4 c1 78 10 44 05 b0 	vmovups xmm0,XMMWORD PTR [r13+rax*1-0x50]
  21e593:	c4 c1 78 11 44 06 c0 	vmovups XMMWORD PTR [r14+rax*1-0x40],xmm0
  21e59a:	c4 c1 78 10 44 05 c0 	vmovups xmm0,XMMWORD PTR [r13+rax*1-0x40]
  21e5a1:	c4 c1 78 11 44 06 d0 	vmovups XMMWORD PTR [r14+rax*1-0x30],xmm0
  21e5a8:	c4 c1 78 10 44 05 d0 	vmovups xmm0,XMMWORD PTR [r13+rax*1-0x30]
  21e5af:	c4 c1 78 11 44 06 e0 	vmovups XMMWORD PTR [r14+rax*1-0x20],xmm0
  21e5b6:	c4 c1 78 10 44 05 e0 	vmovups xmm0,XMMWORD PTR [r13+rax*1-0x20]
  21e5bd:	c4 c1 78 11 44 06 f0 	vmovups XMMWORD PTR [r14+rax*1-0x10],xmm0
  21e5c4:	c4 c1 78 10 44 05 f0 	vmovups xmm0,XMMWORD PTR [r13+rax*1-0x10]
  21e5cb:	c4 c1 78 11 04 06    	vmovups XMMWORD PTR [r14+rax*1],xmm0
  21e5d1:	c4 c1 7a 6f 44 05 00 	vmovdqu xmm0,XMMWORD PTR [r13+rax*1+0x0]
  21e5d8:	c4 c1 7a 7f 44 06 10 	vmovdqu XMMWORD PTR [r14+rax*1+0x10],xmm0
    for (source) |s, i|
  21e5df:	48 83 c6 08          	add    rsi,0x8
  21e5e3:	48 83 e8 80          	sub    rax,0xffffffffffffff80
  21e5e7:	48 39 f1             	cmp    rcx,rsi
  21e5ea:	75 84                	jne    21e570 <Benchmark_reportStats+0x7e30>
  21e5ec:	48 85 d2             	test   rdx,rdx
  21e5ef:	48 8b 44 24 10       	mov    rax,QWORD PTR [rsp+0x10]
  21e5f4:	74 4a                	je     21e640 <Benchmark_reportStats+0x7f00>
  21e5f6:	48 01 f0             	add    rax,rsi
  21e5f9:	48 c1 e0 04          	shl    rax,0x4
  21e5fd:	49 01 c7             	add    r15,rax
  21e600:	4b 8d 04 3b          	lea    rax,[r11+r15*1]
  21e604:	48 83 c0 10          	add    rax,0x10
  21e608:	48 c1 e6 04          	shl    rsi,0x4
  21e60c:	48 8d 0c 34          	lea    rcx,[rsp+rsi*1]
  21e610:	48 81 c1 28 02 00 00 	add    rcx,0x228
  21e617:	48 01 f9             	add    rcx,rdi
  21e61a:	48 f7 da             	neg    rdx
  21e61d:	31 f6                	xor    esi,esi
  21e61f:	90                   	nop
        dest[i] = s;
  21e620:	c5 fa 6f 04 31       	vmovdqu xmm0,XMMWORD PTR [rcx+rsi*1]
  21e625:	c5 fa 7f 04 30       	vmovdqu XMMWORD PTR [rax+rsi*1],xmm0
    for (source) |s, i|
  21e62a:	48 83 c6 10          	add    rsi,0x10
  21e62e:	48 83 c2 01          	add    rdx,0x1
  21e632:	75 ec                	jne    21e620 <Benchmark_reportStats+0x7ee0>
  21e634:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21e63b:	00 00 00 00 00 
  21e640:	4c 8b 94 24 d0 00 00 	mov    r10,QWORD PTR [rsp+0xd0]
  21e647:	00 
  21e648:	4c 2b 94 24 f8 00 00 	sub    r10,QWORD PTR [rsp+0xf8]
  21e64f:	00 
  21e650:	48 8b 44 24 38       	mov    rax,QWORD PTR [rsp+0x38]
        return self.decimal >= self.size;
  21e655:	48 3b 84 24 f0 00 00 	cmp    rax,QWORD PTR [rsp+0xf0]
  21e65c:	00 
  21e65d:	4c 8b bc 24 00 01 00 	mov    r15,QWORD PTR [rsp+0x100]
  21e664:	00 
  21e665:	4c 8b a4 24 d8 00 00 	mov    r12,QWORD PTR [rsp+0xd8]
  21e66c:	00 
  21e66d:	4c 8b 8c 24 e0 00 00 	mov    r9,QWORD PTR [rsp+0xe0]
  21e674:	00 
                while (!iterator.finished()) {
  21e675:	0f 82 25 e4 ff ff    	jb     21caa0 <Benchmark_reportStats+0x6360>
        self.numerator_step += self.numerator_step;
  21e67b:	4d 01 c9             	add    r9,r9
        if (self.numerator_step >= self.denominator) {
  21e67e:	4c 89 c8             	mov    rax,r9
  21e681:	4c 29 f8             	sub    rax,r15
  21e684:	0f 83 23 08 00 00    	jae    21eead <Benchmark_reportStats+0x876d>
  21e68a:	4c 8b 64 24 68       	mov    r12,QWORD PTR [rsp+0x68]
  21e68f:	4c 89 c8             	mov    rax,r9
  21e692:	e9 29 08 00 00       	jmp    21eec0 <Benchmark_reportStats+0x8780>
        self.decimal += self.decimal_step;
  21e697:	4b 8d 04 24          	lea    rax,[r12+r12*1]
  21e69b:	48 89 44 24 30       	mov    QWORD PTR [rsp+0x30],rax
  21e6a0:	45 31 c9             	xor    r9d,r9d
  21e6a3:	45 31 db             	xor    r11d,r11d
  21e6a6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  21e6ad:	00 00 00 
  21e6b0:	4d 89 ce             	mov    r14,r9
  21e6b3:	4b 8d 04 26          	lea    rax,[r14+r12*1]
  21e6b7:	48 8b 94 24 e0 00 00 	mov    rdx,QWORD PTR [rsp+0xe0]
  21e6be:	00 
        self.numerator += self.numerator_step;
  21e6bf:	49 01 d3             	add    r11,rdx
        if (self.numerator >= self.denominator) {
  21e6c2:	31 f6                	xor    esi,esi
  21e6c4:	4d 39 fb             	cmp    r11,r15
  21e6c7:	40 0f 93 c6          	setae  sil
  21e6cb:	4c 89 f9             	mov    rcx,r15
  21e6ce:	bf 00 00 00 00       	mov    edi,0x0
  21e6d3:	48 0f 42 cf          	cmovb  rcx,rdi
  21e6d7:	49 29 cb             	sub    r11,rcx
  21e6da:	48 89 74 24 18       	mov    QWORD PTR [rsp+0x18],rsi
  21e6df:	4c 8d 2c 30          	lea    r13,[rax+rsi*1]
        self.decimal += self.decimal_step;
  21e6e3:	4f 8d 0c 2c          	lea    r9,[r12+r13*1]
        self.numerator += self.numerator_step;
  21e6e7:	49 01 d3             	add    r11,rdx
        if (self.numerator >= self.denominator) {
  21e6ea:	31 f6                	xor    esi,esi
  21e6ec:	4d 39 fb             	cmp    r11,r15
  21e6ef:	40 0f 93 c6          	setae  sil
  21e6f3:	4c 89 fa             	mov    rdx,r15
  21e6f6:	48 0f 42 d7          	cmovb  rdx,rdi
  21e6fa:	49 01 f1             	add    r9,rsi
                    if (lessThan(items[B.end - 1], items[A.start])) {
  21e6fd:	4c 89 c9             	mov    rcx,r9
  21e700:	48 c1 e1 04          	shl    rcx,0x4
  21e704:	4c 8b 7c 24 40       	mov    r15,QWORD PTR [rsp+0x40]
  21e709:	4d 89 f2             	mov    r10,r14
  21e70c:	49 c1 e2 04          	shl    r10,0x4
  21e710:	49 8b 4c 0f f0       	mov    rcx,QWORD PTR [r15+rcx*1-0x10]
  21e715:	4b 3b 0c 17          	cmp    rcx,QWORD PTR [r15+r10*1]
  21e719:	4b 8d 3c 17          	lea    rdi,[r15+r10*1]
  21e71d:	48 89 54 24 38       	mov    QWORD PTR [rsp+0x38],rdx
  21e722:	73 4c                	jae    21e770 <Benchmark_reportStats+0x8030>
  21e724:	48 89 74 24 10       	mov    QWORD PTR [rsp+0x10],rsi
  21e729:	4c 89 4c 24 20       	mov    QWORD PTR [rsp+0x20],r9
                        mem.rotate(T, items[A.start..B.end], A.length());
  21e72e:	4d 89 cc             	mov    r12,r9
  21e731:	4d 29 f4             	sub    r12,r14
        return self.end - self.start;
  21e734:	4c 89 eb             	mov    rbx,r13
  21e737:	4c 29 f3             	sub    rbx,r14
    const end = items.len / 2;
  21e73a:	48 89 de             	mov    rsi,rbx
  21e73d:	48 d1 ee             	shr    rsi,1
    while (i < end) : (i += 1) {
  21e740:	0f 84 94 01 00 00    	je     21e8da <Benchmark_reportStats+0x819a>
        swap(T, &items[i], &items[items.len - i - 1]);
  21e746:	48 8d 4e ff          	lea    rcx,[rsi-0x1]
  21e74a:	41 89 f0             	mov    r8d,esi
  21e74d:	41 83 e0 03          	and    r8d,0x3
  21e751:	48 83 f9 03          	cmp    rcx,0x3
  21e755:	73 79                	jae    21e7d0 <Benchmark_reportStats+0x8090>
  21e757:	45 31 c9             	xor    r9d,r9d
    while (i < end) : (i += 1) {
  21e75a:	4d 85 c0             	test   r8,r8
  21e75d:	0f 85 1b 01 00 00    	jne    21e87e <Benchmark_reportStats+0x813e>
  21e763:	e9 72 01 00 00       	jmp    21e8da <Benchmark_reportStats+0x819a>
  21e768:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  21e76f:	00 
                    } else if (lessThan(items[B.start], items[A.end - 1])) {
  21e770:	4c 89 e8             	mov    rax,r13
  21e773:	48 c1 e0 04          	shl    rax,0x4
  21e777:	49 8b 0c 07          	mov    rcx,QWORD PTR [r15+rax*1]
  21e77b:	49 3b 4c 07 f0       	cmp    rcx,QWORD PTR [r15+rax*1-0x10]
  21e780:	0f 83 fa 06 00 00    	jae    21ee80 <Benchmark_reportStats+0x8740>
                        mem.copy(T, cache[0..], items[A.start..A.end]);
  21e786:	4d 89 ea             	mov    r10,r13
  21e789:	4d 29 f2             	sub    r10,r14
    assert(dest.len >= source.len);
  21e78c:	49 81 fa 01 02 00 00 	cmp    r10,0x201
  21e793:	0f 83 13 0b 00 00    	jae    21f2ac <Benchmark_reportStats+0x8b6c>
    for (source) |s, i|
  21e799:	4d 85 d2             	test   r10,r10
  21e79c:	0f 84 cf 03 00 00    	je     21eb71 <Benchmark_reportStats+0x8431>
  21e7a2:	48 8b 44 24 50       	mov    rax,QWORD PTR [rsp+0x50]
  21e7a7:	48 8b 4c 24 18       	mov    rcx,QWORD PTR [rsp+0x18]
  21e7ac:	48 8d 04 08          	lea    rax,[rax+rcx*1]
  21e7b0:	44 89 d6             	mov    esi,r10d
  21e7b3:	83 e6 07             	and    esi,0x7
  21e7b6:	48 83 f8 07          	cmp    rax,0x7
  21e7ba:	0f 83 de 02 00 00    	jae    21ea9e <Benchmark_reportStats+0x835e>
  21e7c0:	31 c9                	xor    ecx,ecx
  21e7c2:	48 85 f6             	test   rsi,rsi
  21e7c5:	0f 85 72 03 00 00    	jne    21eb3d <Benchmark_reportStats+0x83fd>
  21e7cb:	e9 98 03 00 00       	jmp    21eb68 <Benchmark_reportStats+0x8428>
        swap(T, &items[i], &items[items.len - i - 1]);
  21e7d0:	4c 29 c6             	sub    rsi,r8
  21e7d3:	4b 8d 0c 17          	lea    rcx,[r15+r10*1]
  21e7d7:	48 83 c1 30          	add    rcx,0x30
  21e7db:	4c 89 ea             	mov    rdx,r13
  21e7de:	48 c1 e2 04          	shl    rdx,0x4
  21e7e2:	4c 01 fa             	add    rdx,r15
  21e7e5:	48 83 c2 f0          	add    rdx,0xfffffffffffffff0
  21e7e9:	45 31 c9             	xor    r9d,r9d
  21e7ec:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
    const tmp = a.*;
  21e7f0:	c5 f8 10 41 d0       	vmovups xmm0,XMMWORD PTR [rcx-0x30]
  21e7f5:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21e7fa:	c5 f8 10 02          	vmovups xmm0,XMMWORD PTR [rdx]
  21e7fe:	c5 f8 11 41 d0       	vmovups XMMWORD PTR [rcx-0x30],xmm0
    b.* = tmp;
  21e803:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  21e808:	c5 f8 11 02          	vmovups XMMWORD PTR [rdx],xmm0
    const tmp = a.*;
  21e80c:	c5 f8 10 41 e0       	vmovups xmm0,XMMWORD PTR [rcx-0x20]
  21e811:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21e816:	c5 f8 10 42 f0       	vmovups xmm0,XMMWORD PTR [rdx-0x10]
  21e81b:	c5 f8 11 41 e0       	vmovups XMMWORD PTR [rcx-0x20],xmm0
    b.* = tmp;
  21e820:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  21e825:	c5 f8 11 42 f0       	vmovups XMMWORD PTR [rdx-0x10],xmm0
    const tmp = a.*;
  21e82a:	c5 f8 10 41 f0       	vmovups xmm0,XMMWORD PTR [rcx-0x10]
  21e82f:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21e834:	c5 f8 10 42 e0       	vmovups xmm0,XMMWORD PTR [rdx-0x20]
  21e839:	c5 f8 11 41 f0       	vmovups XMMWORD PTR [rcx-0x10],xmm0
    b.* = tmp;
  21e83e:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  21e843:	c5 f8 11 42 e0       	vmovups XMMWORD PTR [rdx-0x20],xmm0
    const tmp = a.*;
  21e848:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  21e84c:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21e851:	c5 f8 10 42 d0       	vmovups xmm0,XMMWORD PTR [rdx-0x30]
  21e856:	c5 f8 11 01          	vmovups XMMWORD PTR [rcx],xmm0
    b.* = tmp;
  21e85a:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  21e85f:	c5 fa 7f 42 d0       	vmovdqu XMMWORD PTR [rdx-0x30],xmm0
    while (i < end) : (i += 1) {
  21e864:	49 83 c1 04          	add    r9,0x4
  21e868:	48 83 c1 40          	add    rcx,0x40
  21e86c:	48 83 c2 c0          	add    rdx,0xffffffffffffffc0
  21e870:	4c 39 ce             	cmp    rsi,r9
  21e873:	0f 85 77 ff ff ff    	jne    21e7f0 <Benchmark_reportStats+0x80b0>
  21e879:	4d 85 c0             	test   r8,r8
  21e87c:	74 5c                	je     21e8da <Benchmark_reportStats+0x819a>
  21e87e:	48 8b 4c 24 18       	mov    rcx,QWORD PTR [rsp+0x18]
  21e883:	48 8d 0c 08          	lea    rcx,[rax+rcx*1]
  21e887:	4c 29 c9             	sub    rcx,r9
  21e88a:	48 c1 e1 04          	shl    rcx,0x4
  21e88e:	4c 01 f9             	add    rcx,r15
  21e891:	48 83 c1 f0          	add    rcx,0xfffffffffffffff0
  21e895:	4d 01 f1             	add    r9,r14
  21e898:	49 c1 e1 04          	shl    r9,0x4
  21e89c:	4d 01 f9             	add    r9,r15
  21e89f:	49 f7 d8             	neg    r8
  21e8a2:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21e8a9:	1f 84 00 00 00 00 00 
    const tmp = a.*;
  21e8b0:	c4 c1 78 10 01       	vmovups xmm0,XMMWORD PTR [r9]
  21e8b5:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21e8ba:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  21e8be:	c4 c1 78 11 01       	vmovups XMMWORD PTR [r9],xmm0
    b.* = tmp;
  21e8c3:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  21e8c8:	c5 fa 7f 01          	vmovdqu XMMWORD PTR [rcx],xmm0
    while (i < end) : (i += 1) {
  21e8cc:	48 83 c1 f0          	add    rcx,0xfffffffffffffff0
  21e8d0:	49 83 c1 10          	add    r9,0x10
  21e8d4:	49 83 c0 01          	add    r8,0x1
  21e8d8:	75 d6                	jne    21e8b0 <Benchmark_reportStats+0x8170>
    reverse(T, items[amount..]);
  21e8da:	4d 89 e0             	mov    r8,r12
  21e8dd:	49 29 d8             	sub    r8,rbx
    const end = items.len / 2;
  21e8e0:	49 d1 e8             	shr    r8,1
    while (i < end) : (i += 1) {
  21e8e3:	0f 84 4f 01 00 00    	je     21ea38 <Benchmark_reportStats+0x82f8>
        swap(T, &items[i], &items[items.len - i - 1]);
  21e8e9:	49 8d 48 ff          	lea    rcx,[r8-0x1]
  21e8ed:	44 89 c3             	mov    ebx,r8d
  21e8f0:	83 e3 03             	and    ebx,0x3
  21e8f3:	48 83 f9 03          	cmp    rcx,0x3
  21e8f7:	73 10                	jae    21e909 <Benchmark_reportStats+0x81c9>
  21e8f9:	31 c9                	xor    ecx,ecx
    while (i < end) : (i += 1) {
  21e8fb:	48 85 db             	test   rbx,rbx
  21e8fe:	0f 85 ca 00 00 00    	jne    21e9ce <Benchmark_reportStats+0x828e>
  21e904:	e9 2f 01 00 00       	jmp    21ea38 <Benchmark_reportStats+0x82f8>
        swap(T, &items[i], &items[items.len - i - 1]);
  21e909:	49 29 d8             	sub    r8,rbx
  21e90c:	49 c1 e5 04          	shl    r13,0x4
  21e910:	4b 8d 14 2f          	lea    rdx,[r15+r13*1]
  21e914:	48 83 c2 30          	add    rdx,0x30
  21e918:	48 8b 4c 24 30       	mov    rcx,QWORD PTR [rsp+0x30]
  21e91d:	48 c1 e1 04          	shl    rcx,0x4
  21e921:	4c 01 f9             	add    rcx,r15
  21e924:	48 8b 74 24 18       	mov    rsi,QWORD PTR [rsp+0x18]
  21e929:	49 8d 34 36          	lea    rsi,[r14+rsi*1]
  21e92d:	48 03 74 24 10       	add    rsi,QWORD PTR [rsp+0x10]
  21e932:	48 c1 e6 04          	shl    rsi,0x4
  21e936:	48 01 ce             	add    rsi,rcx
  21e939:	48 83 c6 f0          	add    rsi,0xfffffffffffffff0
  21e93d:	31 c9                	xor    ecx,ecx
  21e93f:	90                   	nop
    const tmp = a.*;
  21e940:	c5 f8 10 42 d0       	vmovups xmm0,XMMWORD PTR [rdx-0x30]
  21e945:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21e94a:	c5 f8 10 06          	vmovups xmm0,XMMWORD PTR [rsi]
  21e94e:	c5 f8 11 42 d0       	vmovups XMMWORD PTR [rdx-0x30],xmm0
    b.* = tmp;
  21e953:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  21e958:	c5 f8 11 06          	vmovups XMMWORD PTR [rsi],xmm0
    const tmp = a.*;
  21e95c:	c5 f8 10 42 e0       	vmovups xmm0,XMMWORD PTR [rdx-0x20]
  21e961:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21e966:	c5 f8 10 46 f0       	vmovups xmm0,XMMWORD PTR [rsi-0x10]
  21e96b:	c5 f8 11 42 e0       	vmovups XMMWORD PTR [rdx-0x20],xmm0
    b.* = tmp;
  21e970:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  21e975:	c5 f8 11 46 f0       	vmovups XMMWORD PTR [rsi-0x10],xmm0
    const tmp = a.*;
  21e97a:	c5 f8 10 42 f0       	vmovups xmm0,XMMWORD PTR [rdx-0x10]
  21e97f:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21e984:	c5 f8 10 46 e0       	vmovups xmm0,XMMWORD PTR [rsi-0x20]
  21e989:	c5 f8 11 42 f0       	vmovups XMMWORD PTR [rdx-0x10],xmm0
    b.* = tmp;
  21e98e:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  21e993:	c5 f8 11 46 e0       	vmovups XMMWORD PTR [rsi-0x20],xmm0
    const tmp = a.*;
  21e998:	c5 f8 10 02          	vmovups xmm0,XMMWORD PTR [rdx]
  21e99c:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21e9a1:	c5 f8 10 46 d0       	vmovups xmm0,XMMWORD PTR [rsi-0x30]
  21e9a6:	c5 f8 11 02          	vmovups XMMWORD PTR [rdx],xmm0
    b.* = tmp;
  21e9aa:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  21e9af:	c5 fa 7f 46 d0       	vmovdqu XMMWORD PTR [rsi-0x30],xmm0
    while (i < end) : (i += 1) {
  21e9b4:	48 83 c1 04          	add    rcx,0x4
  21e9b8:	48 83 c2 40          	add    rdx,0x40
  21e9bc:	48 83 c6 c0          	add    rsi,0xffffffffffffffc0
  21e9c0:	49 39 c8             	cmp    r8,rcx
  21e9c3:	0f 85 77 ff ff ff    	jne    21e940 <Benchmark_reportStats+0x8200>
  21e9c9:	48 85 db             	test   rbx,rbx
  21e9cc:	74 6a                	je     21ea38 <Benchmark_reportStats+0x82f8>
  21e9ce:	48 8b 54 24 30       	mov    rdx,QWORD PTR [rsp+0x30]
  21e9d3:	48 c1 e2 04          	shl    rdx,0x4
  21e9d7:	4c 01 fa             	add    rdx,r15
  21e9da:	4c 8b 44 24 18       	mov    r8,QWORD PTR [rsp+0x18]
  21e9df:	4b 8d 34 06          	lea    rsi,[r14+r8*1]
  21e9e3:	48 03 74 24 10       	add    rsi,QWORD PTR [rsp+0x10]
  21e9e8:	48 29 ce             	sub    rsi,rcx
  21e9eb:	48 c1 e6 04          	shl    rsi,0x4
  21e9ef:	48 01 f2             	add    rdx,rsi
  21e9f2:	48 83 c2 f0          	add    rdx,0xfffffffffffffff0
  21e9f6:	48 01 c8             	add    rax,rcx
  21e9f9:	4c 01 c0             	add    rax,r8
  21e9fc:	48 c1 e0 04          	shl    rax,0x4
  21ea00:	4c 01 f8             	add    rax,r15
  21ea03:	48 f7 db             	neg    rbx
  21ea06:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  21ea0d:	00 00 00 
    const tmp = a.*;
  21ea10:	c5 f8 10 00          	vmovups xmm0,XMMWORD PTR [rax]
  21ea14:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21ea19:	c5 f8 10 02          	vmovups xmm0,XMMWORD PTR [rdx]
  21ea1d:	c5 f8 11 00          	vmovups XMMWORD PTR [rax],xmm0
    b.* = tmp;
  21ea21:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  21ea26:	c5 fa 7f 02          	vmovdqu XMMWORD PTR [rdx],xmm0
    while (i < end) : (i += 1) {
  21ea2a:	48 83 c2 f0          	add    rdx,0xfffffffffffffff0
  21ea2e:	48 83 c0 10          	add    rax,0x10
  21ea32:	48 83 c3 01          	add    rbx,0x1
  21ea36:	75 d8                	jne    21ea10 <Benchmark_reportStats+0x82d0>
    const end = items.len / 2;
  21ea38:	4c 89 e3             	mov    rbx,r12
  21ea3b:	48 d1 eb             	shr    rbx,1
  21ea3e:	4c 8b 4c 24 20       	mov    r9,QWORD PTR [rsp+0x20]
    while (i < end) : (i += 1) {
  21ea43:	0f 84 37 04 00 00    	je     21ee80 <Benchmark_reportStats+0x8740>
    const tmp = a.*;
  21ea49:	c5 f8 10 07          	vmovups xmm0,XMMWORD PTR [rdi]
  21ea4d:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  21ea52:	49 c1 e4 04          	shl    r12,0x4
    a.* = b.*;
  21ea56:	c4 a1 78 10 44 27 f0 	vmovups xmm0,XMMWORD PTR [rdi+r12*1-0x10]
  21ea5d:	c5 f8 11 07          	vmovups XMMWORD PTR [rdi],xmm0
    b.* = tmp;
  21ea61:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  21ea66:	c4 a1 7a 7f 44 27 f0 	vmovdqu XMMWORD PTR [rdi+r12*1-0x10],xmm0
    while (i < end) : (i += 1) {
  21ea6d:	48 83 fb 01          	cmp    rbx,0x1
  21ea71:	0f 84 09 04 00 00    	je     21ee80 <Benchmark_reportStats+0x8740>
        swap(T, &items[i], &items[items.len - i - 1]);
  21ea77:	8d 43 ff             	lea    eax,[rbx-0x1]
  21ea7a:	48 8d 4b fe          	lea    rcx,[rbx-0x2]
  21ea7e:	83 e0 03             	and    eax,0x3
  21ea81:	48 83 f9 03          	cmp    rcx,0x3
  21ea85:	0f 83 ee 00 00 00    	jae    21eb79 <Benchmark_reportStats+0x8439>
  21ea8b:	be 01 00 00 00       	mov    esi,0x1
    while (i < end) : (i += 1) {
  21ea90:	48 85 c0             	test   rax,rax
  21ea93:	0f 85 a9 01 00 00    	jne    21ec42 <Benchmark_reportStats+0x8502>
  21ea99:	e9 e2 03 00 00       	jmp    21ee80 <Benchmark_reportStats+0x8740>
    for (source) |s, i|
  21ea9e:	4c 89 d2             	mov    rdx,r10
  21eaa1:	48 29 f2             	sub    rdx,rsi
  21eaa4:	bb 70 00 00 00       	mov    ebx,0x70
  21eaa9:	31 c9                	xor    ecx,ecx
  21eaab:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
        dest[i] = s;
  21eab0:	c5 f8 10 44 1f 90    	vmovups xmm0,XMMWORD PTR [rdi+rbx*1-0x70]
  21eab6:	c5 f8 11 84 1c b8 01 	vmovups XMMWORD PTR [rsp+rbx*1+0x1b8],xmm0
  21eabd:	00 00 
  21eabf:	c5 f8 10 44 1f a0    	vmovups xmm0,XMMWORD PTR [rdi+rbx*1-0x60]
  21eac5:	c5 f8 11 84 1c c8 01 	vmovups XMMWORD PTR [rsp+rbx*1+0x1c8],xmm0
  21eacc:	00 00 
  21eace:	c5 f8 10 44 1f b0    	vmovups xmm0,XMMWORD PTR [rdi+rbx*1-0x50]
  21ead4:	c5 f8 11 84 1c d8 01 	vmovups XMMWORD PTR [rsp+rbx*1+0x1d8],xmm0
  21eadb:	00 00 
  21eadd:	c5 f8 10 44 1f c0    	vmovups xmm0,XMMWORD PTR [rdi+rbx*1-0x40]
  21eae3:	c5 f8 11 84 1c e8 01 	vmovups XMMWORD PTR [rsp+rbx*1+0x1e8],xmm0
  21eaea:	00 00 
  21eaec:	c5 f8 10 44 1f d0    	vmovups xmm0,XMMWORD PTR [rdi+rbx*1-0x30]
  21eaf2:	c5 f8 11 84 1c f8 01 	vmovups XMMWORD PTR [rsp+rbx*1+0x1f8],xmm0
  21eaf9:	00 00 
  21eafb:	c5 f8 10 44 1f e0    	vmovups xmm0,XMMWORD PTR [rdi+rbx*1-0x20]
  21eb01:	c5 f8 11 84 1c 08 02 	vmovups XMMWORD PTR [rsp+rbx*1+0x208],xmm0
  21eb08:	00 00 
  21eb0a:	c5 f8 10 44 1f f0    	vmovups xmm0,XMMWORD PTR [rdi+rbx*1-0x10]
  21eb10:	c5 f8 11 84 1c 18 02 	vmovups XMMWORD PTR [rsp+rbx*1+0x218],xmm0
  21eb17:	00 00 
  21eb19:	c5 fa 6f 04 1f       	vmovdqu xmm0,XMMWORD PTR [rdi+rbx*1]
  21eb1e:	c5 fa 7f 84 1c 28 02 	vmovdqu XMMWORD PTR [rsp+rbx*1+0x228],xmm0
  21eb25:	00 00 
    for (source) |s, i|
  21eb27:	48 83 c1 08          	add    rcx,0x8
  21eb2b:	48 83 eb 80          	sub    rbx,0xffffffffffffff80
  21eb2f:	48 39 ca             	cmp    rdx,rcx
  21eb32:	0f 85 78 ff ff ff    	jne    21eab0 <Benchmark_reportStats+0x8370>
  21eb38:	48 85 f6             	test   rsi,rsi
  21eb3b:	74 2b                	je     21eb68 <Benchmark_reportStats+0x8428>
  21eb3d:	48 c1 e1 04          	shl    rcx,0x4
  21eb41:	48 f7 de             	neg    rsi
  21eb44:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21eb4b:	00 00 00 00 00 
        dest[i] = s;
  21eb50:	c5 fa 6f 04 0f       	vmovdqu xmm0,XMMWORD PTR [rdi+rcx*1]
  21eb55:	c5 fa 7f 84 0c 28 02 	vmovdqu XMMWORD PTR [rsp+rcx*1+0x228],xmm0
  21eb5c:	00 00 
    for (source) |s, i|
  21eb5e:	48 83 c1 10          	add    rcx,0x10
  21eb62:	48 83 c6 01          	add    rsi,0x1
  21eb66:	75 e8                	jne    21eb50 <Benchmark_reportStats+0x8410>
    if (B.length() > 0 and A.length() > 0) {
  21eb68:	4d 39 e9             	cmp    r9,r13
  21eb6b:	0f 85 3e 01 00 00    	jne    21ecaf <Benchmark_reportStats+0x856f>
  21eb71:	45 31 c0             	xor    r8d,r8d
  21eb74:	e9 f1 01 00 00       	jmp    21ed6a <Benchmark_reportStats+0x862a>
        swap(T, &items[i], &items[items.len - i - 1]);
  21eb79:	48 8b 4c 24 30       	mov    rcx,QWORD PTR [rsp+0x30]
  21eb7e:	48 c1 e1 04          	shl    rcx,0x4
  21eb82:	4c 01 f9             	add    rcx,r15
  21eb85:	48 8b 54 24 18       	mov    rdx,QWORD PTR [rsp+0x18]
  21eb8a:	49 8d 14 16          	lea    rdx,[r14+rdx*1]
  21eb8e:	48 03 54 24 10       	add    rdx,QWORD PTR [rsp+0x10]
  21eb93:	48 c1 e2 04          	shl    rdx,0x4
  21eb97:	48 01 d1             	add    rcx,rdx
  21eb9a:	48 83 c1 e0          	add    rcx,0xffffffffffffffe0
  21eb9e:	4b 8d 14 17          	lea    rdx,[r15+r10*1]
  21eba2:	48 83 c2 40          	add    rdx,0x40
  21eba6:	48 29 c3             	sub    rbx,rax
  21eba9:	be 01 00 00 00       	mov    esi,0x1
  21ebae:	66 90                	xchg   ax,ax
    const tmp = a.*;
  21ebb0:	c5 f8 10 42 d0       	vmovups xmm0,XMMWORD PTR [rdx-0x30]
  21ebb5:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21ebba:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  21ebbe:	c5 f8 11 42 d0       	vmovups XMMWORD PTR [rdx-0x30],xmm0
    b.* = tmp;
  21ebc3:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  21ebc8:	c5 f8 11 01          	vmovups XMMWORD PTR [rcx],xmm0
    const tmp = a.*;
  21ebcc:	c5 f8 10 42 e0       	vmovups xmm0,XMMWORD PTR [rdx-0x20]
  21ebd1:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21ebd6:	c5 f8 10 41 f0       	vmovups xmm0,XMMWORD PTR [rcx-0x10]
  21ebdb:	c5 f8 11 42 e0       	vmovups XMMWORD PTR [rdx-0x20],xmm0
    b.* = tmp;
  21ebe0:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  21ebe5:	c5 f8 11 41 f0       	vmovups XMMWORD PTR [rcx-0x10],xmm0
    const tmp = a.*;
  21ebea:	c5 f8 10 42 f0       	vmovups xmm0,XMMWORD PTR [rdx-0x10]
  21ebef:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21ebf4:	c5 f8 10 41 e0       	vmovups xmm0,XMMWORD PTR [rcx-0x20]
  21ebf9:	c5 f8 11 42 f0       	vmovups XMMWORD PTR [rdx-0x10],xmm0
    b.* = tmp;
  21ebfe:	c5 f8 28 04 24       	vmovaps xmm0,XMMWORD PTR [rsp]
  21ec03:	c5 f8 11 41 e0       	vmovups XMMWORD PTR [rcx-0x20],xmm0
    const tmp = a.*;
  21ec08:	c5 f8 10 02          	vmovups xmm0,XMMWORD PTR [rdx]
  21ec0c:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21ec11:	c5 f8 10 41 d0       	vmovups xmm0,XMMWORD PTR [rcx-0x30]
  21ec16:	c5 f8 11 02          	vmovups XMMWORD PTR [rdx],xmm0
    b.* = tmp;
  21ec1a:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  21ec1f:	c5 fa 7f 41 d0       	vmovdqu XMMWORD PTR [rcx-0x30],xmm0
    while (i < end) : (i += 1) {
  21ec24:	48 83 c6 04          	add    rsi,0x4
  21ec28:	48 83 c1 c0          	add    rcx,0xffffffffffffffc0
  21ec2c:	48 83 c2 40          	add    rdx,0x40
  21ec30:	48 39 f3             	cmp    rbx,rsi
  21ec33:	0f 85 77 ff ff ff    	jne    21ebb0 <Benchmark_reportStats+0x8470>
  21ec39:	48 85 c0             	test   rax,rax
  21ec3c:	0f 84 3e 02 00 00    	je     21ee80 <Benchmark_reportStats+0x8740>
  21ec42:	48 8b 4c 24 30       	mov    rcx,QWORD PTR [rsp+0x30]
  21ec47:	48 c1 e1 04          	shl    rcx,0x4
  21ec4b:	4c 01 f9             	add    rcx,r15
  21ec4e:	48 8b 54 24 18       	mov    rdx,QWORD PTR [rsp+0x18]
  21ec53:	4c 01 f2             	add    rdx,r14
  21ec56:	48 03 54 24 10       	add    rdx,QWORD PTR [rsp+0x10]
  21ec5b:	48 29 f2             	sub    rdx,rsi
  21ec5e:	48 c1 e2 04          	shl    rdx,0x4
  21ec62:	48 01 d1             	add    rcx,rdx
  21ec65:	48 83 c1 f0          	add    rcx,0xfffffffffffffff0
  21ec69:	49 01 f6             	add    r14,rsi
  21ec6c:	49 c1 e6 04          	shl    r14,0x4
  21ec70:	4d 01 fe             	add    r14,r15
  21ec73:	48 f7 d8             	neg    rax
  21ec76:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  21ec7d:	00 00 00 
    const tmp = a.*;
  21ec80:	c4 c1 78 10 06       	vmovups xmm0,XMMWORD PTR [r14]
  21ec85:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
    a.* = b.*;
  21ec8a:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  21ec8e:	c4 c1 78 11 06       	vmovups XMMWORD PTR [r14],xmm0
    b.* = tmp;
  21ec93:	c5 f9 6f 04 24       	vmovdqa xmm0,XMMWORD PTR [rsp]
  21ec98:	c5 fa 7f 01          	vmovdqu XMMWORD PTR [rcx],xmm0
    while (i < end) : (i += 1) {
  21ec9c:	48 83 c1 f0          	add    rcx,0xfffffffffffffff0
  21eca0:	49 83 c6 10          	add    r14,0x10
  21eca4:	48 83 c0 01          	add    rax,0x1
  21eca8:	75 d6                	jne    21ec80 <Benchmark_reportStats+0x8540>
  21ecaa:	e9 d1 01 00 00       	jmp    21ee80 <Benchmark_reportStats+0x8740>
  21ecaf:	4c 89 4c 24 20       	mov    QWORD PTR [rsp+0x20],r9
            if (!lessThan(items[B_index], cache[A_index])) {
  21ecb4:	49 f7 d9             	neg    r9
  21ecb7:	45 31 c0             	xor    r8d,r8d
  21ecba:	4c 89 c0             	mov    rax,r8
  21ecbd:	48 c1 e0 04          	shl    rax,0x4
  21ecc1:	4c 8d 24 04          	lea    r12,[rsp+rax*1]
  21ecc5:	49 81 c4 28 02 00 00 	add    r12,0x228
  21eccc:	4c 89 f7             	mov    rdi,r14
  21eccf:	48 c1 e7 04          	shl    rdi,0x4
  21ecd3:	4b 8d 1c 29          	lea    rbx,[r9+r13*1]
  21ecd7:	4c 89 e9             	mov    rcx,r13
  21ecda:	48 c1 e1 04          	shl    rcx,0x4
  21ecde:	4c 89 f8             	mov    rax,r15
  21ece1:	31 d2                	xor    edx,edx
  21ece3:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21ecea:	84 00 00 00 00 00 
  21ecf0:	48 8b 34 08          	mov    rsi,QWORD PTR [rax+rcx*1]
  21ecf4:	49 3b 34 24          	cmp    rsi,QWORD PTR [r12]
  21ecf8:	73 26                	jae    21ed20 <Benchmark_reportStats+0x85e0>
                items[insert_index] = items[B_index];
  21ecfa:	c5 fa 6f 04 01       	vmovdqu xmm0,XMMWORD PTR [rcx+rax*1]
  21ecff:	c5 fa 7f 04 07       	vmovdqu XMMWORD PTR [rdi+rax*1],xmm0
                if (B_index == B_last) break;
  21ed04:	48 83 c2 ff          	add    rdx,0xffffffffffffffff
  21ed08:	48 83 c0 10          	add    rax,0x10
  21ed0c:	48 39 d3             	cmp    rbx,rdx
  21ed0f:	75 df                	jne    21ecf0 <Benchmark_reportStats+0x85b0>
  21ed11:	eb 45                	jmp    21ed58 <Benchmark_reportStats+0x8618>
  21ed13:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21ed1a:	84 00 00 00 00 00 
                items[insert_index] = cache[A_index];
  21ed20:	c4 c1 7a 6f 04 24    	vmovdqu xmm0,XMMWORD PTR [r12]
  21ed26:	c5 fa 7f 04 07       	vmovdqu XMMWORD PTR [rdi+rax*1],xmm0
                A_index += 1;
  21ed2b:	49 83 c0 01          	add    r8,0x1
                if (A_index == A_last) break;
  21ed2f:	4c 89 f0             	mov    rax,r14
  21ed32:	48 83 c0 01          	add    rax,0x1
  21ed36:	49 89 c6             	mov    r14,rax
  21ed39:	49 29 d6             	sub    r14,rdx
  21ed3c:	4c 8b 7c 24 40       	mov    r15,QWORD PTR [rsp+0x40]
  21ed41:	49 29 d5             	sub    r13,rdx
  21ed44:	4d 39 d0             	cmp    r8,r10
  21ed47:	0f 85 6d ff ff ff    	jne    21ecba <Benchmark_reportStats+0x857a>
    mem.copy(T, items[insert_index..], cache[A_index..A_last]);
  21ed4d:	48 29 d0             	sub    rax,rdx
  21ed50:	49 89 c6             	mov    r14,rax
  21ed53:	4d 89 d0             	mov    r8,r10
  21ed56:	eb 03                	jmp    21ed5b <Benchmark_reportStats+0x861b>
  21ed58:	49 29 d6             	sub    r14,rdx
  21ed5b:	4c 89 f7             	mov    rdi,r14
  21ed5e:	48 c1 e7 04          	shl    rdi,0x4
  21ed62:	4c 01 ff             	add    rdi,r15
  21ed65:	4c 8b 4c 24 20       	mov    r9,QWORD PTR [rsp+0x20]
  21ed6a:	48 8b 44 24 48       	mov    rax,QWORD PTR [rsp+0x48]
  21ed6f:	4c 29 f0             	sub    rax,r14
  21ed72:	4d 29 c2             	sub    r10,r8
    assert(dest.len >= source.len);
  21ed75:	4c 39 d0             	cmp    rax,r10
  21ed78:	0f 82 2e 05 00 00    	jb     21f2ac <Benchmark_reportStats+0x8b6c>
    for (source) |s, i|
  21ed7e:	4d 85 d2             	test   r10,r10
  21ed81:	0f 84 f9 00 00 00    	je     21ee80 <Benchmark_reportStats+0x8740>
  21ed87:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  21ed8c:	48 03 44 24 50       	add    rax,QWORD PTR [rsp+0x50]
  21ed91:	4c 29 c0             	sub    rax,r8
  21ed94:	44 89 d2             	mov    edx,r10d
  21ed97:	83 e2 07             	and    edx,0x7
  21ed9a:	48 83 f8 07          	cmp    rax,0x7
  21ed9e:	73 10                	jae    21edb0 <Benchmark_reportStats+0x8670>
  21eda0:	31 c9                	xor    ecx,ecx
  21eda2:	48 85 d2             	test   rdx,rdx
  21eda5:	0f 85 95 00 00 00    	jne    21ee40 <Benchmark_reportStats+0x8700>
  21edab:	e9 d0 00 00 00       	jmp    21ee80 <Benchmark_reportStats+0x8740>
  21edb0:	49 29 d2             	sub    r10,rdx
  21edb3:	4c 89 c0             	mov    rax,r8
  21edb6:	48 c1 e0 04          	shl    rax,0x4
  21edba:	48 8d 1c 04          	lea    rbx,[rsp+rax*1]
  21edbe:	48 81 c3 28 02 00 00 	add    rbx,0x228
  21edc5:	be 70 00 00 00       	mov    esi,0x70
  21edca:	31 c9                	xor    ecx,ecx
  21edcc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
        dest[i] = s;
  21edd0:	c5 f8 10 44 33 90    	vmovups xmm0,XMMWORD PTR [rbx+rsi*1-0x70]
  21edd6:	c5 f8 11 44 37 90    	vmovups XMMWORD PTR [rdi+rsi*1-0x70],xmm0
  21eddc:	c5 f8 10 44 33 a0    	vmovups xmm0,XMMWORD PTR [rbx+rsi*1-0x60]
  21ede2:	c5 f8 11 44 37 a0    	vmovups XMMWORD PTR [rdi+rsi*1-0x60],xmm0
  21ede8:	c5 f8 10 44 33 b0    	vmovups xmm0,XMMWORD PTR [rbx+rsi*1-0x50]
  21edee:	c5 f8 11 44 37 b0    	vmovups XMMWORD PTR [rdi+rsi*1-0x50],xmm0
  21edf4:	c5 f8 10 44 33 c0    	vmovups xmm0,XMMWORD PTR [rbx+rsi*1-0x40]
  21edfa:	c5 f8 11 44 37 c0    	vmovups XMMWORD PTR [rdi+rsi*1-0x40],xmm0
  21ee00:	c5 f8 10 44 33 d0    	vmovups xmm0,XMMWORD PTR [rbx+rsi*1-0x30]
  21ee06:	c5 f8 11 44 37 d0    	vmovups XMMWORD PTR [rdi+rsi*1-0x30],xmm0
  21ee0c:	c5 f8 10 44 33 e0    	vmovups xmm0,XMMWORD PTR [rbx+rsi*1-0x20]
  21ee12:	c5 f8 11 44 37 e0    	vmovups XMMWORD PTR [rdi+rsi*1-0x20],xmm0
  21ee18:	c5 f8 10 44 33 f0    	vmovups xmm0,XMMWORD PTR [rbx+rsi*1-0x10]
  21ee1e:	c5 f8 11 44 37 f0    	vmovups XMMWORD PTR [rdi+rsi*1-0x10],xmm0
  21ee24:	c5 fa 6f 04 33       	vmovdqu xmm0,XMMWORD PTR [rbx+rsi*1]
  21ee29:	c5 fa 7f 04 37       	vmovdqu XMMWORD PTR [rdi+rsi*1],xmm0
    for (source) |s, i|
  21ee2e:	48 83 c1 08          	add    rcx,0x8
  21ee32:	48 83 ee 80          	sub    rsi,0xffffffffffffff80
  21ee36:	49 39 ca             	cmp    r10,rcx
  21ee39:	75 95                	jne    21edd0 <Benchmark_reportStats+0x8690>
  21ee3b:	48 85 d2             	test   rdx,rdx
  21ee3e:	74 40                	je     21ee80 <Benchmark_reportStats+0x8740>
  21ee40:	48 c1 e1 04          	shl    rcx,0x4
  21ee44:	49 c1 e0 04          	shl    r8,0x4
  21ee48:	4a 8d 04 04          	lea    rax,[rsp+r8*1]
  21ee4c:	48 05 28 02 00 00    	add    rax,0x228
  21ee52:	48 f7 da             	neg    rdx
  21ee55:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21ee5c:	00 00 00 00 
        dest[i] = s;
  21ee60:	c5 fa 6f 04 08       	vmovdqu xmm0,XMMWORD PTR [rax+rcx*1]
  21ee65:	c5 fa 7f 04 0f       	vmovdqu XMMWORD PTR [rdi+rcx*1],xmm0
    for (source) |s, i|
  21ee6a:	48 83 c1 10          	add    rcx,0x10
  21ee6e:	48 83 c2 01          	add    rdx,0x1
  21ee72:	75 ec                	jne    21ee60 <Benchmark_reportStats+0x8720>
  21ee74:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21ee7b:	00 00 00 00 00 
  21ee80:	4c 2b 5c 24 38       	sub    r11,QWORD PTR [rsp+0x38]
        return self.decimal >= self.size;
  21ee85:	4c 3b 8c 24 f0 00 00 	cmp    r9,QWORD PTR [rsp+0xf0]
  21ee8c:	00 
  21ee8d:	4c 8b bc 24 00 01 00 	mov    r15,QWORD PTR [rsp+0x100]
  21ee94:	00 
  21ee95:	4c 8b a4 24 d8 00 00 	mov    r12,QWORD PTR [rsp+0xd8]
  21ee9c:	00 
                while (!iterator.finished()) {
  21ee9d:	0f 82 0d f8 ff ff    	jb     21e6b0 <Benchmark_reportStats+0x7f70>
  21eea3:	48 8b 84 24 e0 00 00 	mov    rax,QWORD PTR [rsp+0xe0]
  21eeaa:	00 
  21eeab:	eb 13                	jmp    21eec0 <Benchmark_reportStats+0x8780>
  21eead:	4c 8b 64 24 68       	mov    r12,QWORD PTR [rsp+0x68]
            self.decimal_step += 1;
  21eeb2:	49 83 cc 01          	or     r12,0x1
  21eeb6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  21eebd:	00 00 00 
        self.numerator_step += self.numerator_step;
  21eec0:	48 01 c0             	add    rax,rax
        if (self.numerator_step >= self.denominator) {
  21eec3:	31 c9                	xor    ecx,ecx
  21eec5:	4c 39 f8             	cmp    rax,r15
  21eec8:	0f 93 c1             	setae  cl
  21eecb:	4e 8d 24 61          	lea    r12,[rcx+r12*2]
        return (self.decimal_step < self.size);
  21eecf:	4c 3b a4 24 f0 00 00 	cmp    r12,QWORD PTR [rsp+0xf0]
  21eed6:	00 
  21eed7:	0f 82 73 da ff ff    	jb     21c950 <Benchmark_reportStats+0x6210>
  21eedd:	eb 2f                	jmp    21ef0e <Benchmark_reportStats+0x87ce>
  21eedf:	48 8b 43 10          	mov    rax,QWORD PTR [rbx+0x10]
  21eee3:	48 3b 03             	cmp    rax,QWORD PTR [rbx]
            if (lessThan(items[1], items[0])) mem.swap(T, &items[0], &items[1]);
  21eee6:	73 26                	jae    21ef0e <Benchmark_reportStats+0x87ce>
    const tmp = a.*;
  21eee8:	c5 f8 10 03          	vmovups xmm0,XMMWORD PTR [rbx]
  21eeec:	c5 f8 29 84 24 80 00 	vmovaps XMMWORD PTR [rsp+0x80],xmm0
  21eef3:	00 00 
  21eef5:	48 8d 43 10          	lea    rax,[rbx+0x10]
    a.* = b.*;
  21eef9:	c5 f8 10 00          	vmovups xmm0,XMMWORD PTR [rax]
  21eefd:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
    b.* = tmp;
  21ef01:	c5 f9 6f 84 24 80 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0x80]
  21ef08:	00 00 
  21ef0a:	c5 fa 7f 00          	vmovdqu XMMWORD PTR [rax],xmm0
        var center = copy.len / 2;
  21ef0e:	48 8b 8c 24 b0 01 00 	mov    rcx,QWORD PTR [rsp+0x1b0]
  21ef15:	00 
  21ef16:	48 89 c8             	mov    rax,rcx
  21ef19:	48 d1 e8             	shr    rax,1
        if ((copy.len & 1) == 1) {
  21ef1c:	f6 c1 01             	test   cl,0x1
  21ef1f:	75 38                	jne    21ef59 <Benchmark_reportStats+0x8819>
            median = @intToFloat(f64, copy.items[center-1].run_time_ns
  21ef21:	48 8b 8c 24 a0 01 00 	mov    rcx,QWORD PTR [rsp+0x1a0]
  21ef28:	00 
  21ef29:	48 c1 e0 04          	shl    rax,0x4
                        + copy.items[center].run_time_ns) / 2;
  21ef2d:	48 8b 14 01          	mov    rdx,QWORD PTR [rcx+rax*1]
  21ef31:	48 03 54 01 f0       	add    rdx,QWORD PTR [rcx+rax*1-0x10]
            median = @intToFloat(f64, copy.items[center-1].run_time_ns
  21ef36:	c4 e1 f9 6e c2       	vmovq  xmm0,rdx
  21ef3b:	c5 f9 62 05 8d 9d fe 	vpunpckldq xmm0,xmm0,XMMWORD PTR [rip+0xfffffffffffe9d8d]        # 208cd0 <__unnamed_629+0x17>
  21ef42:	ff 
  21ef43:	c5 f9 5c 05 a5 a2 fe 	vsubpd xmm0,xmm0,XMMWORD PTR [rip+0xfffffffffffea2a5]        # 2091f0 <__unnamed_70+0x10>
  21ef4a:	ff 
  21ef4b:	c5 f9 7c c0          	vhaddpd xmm0,xmm0,xmm0
                        + copy.items[center].run_time_ns) / 2;
  21ef4f:	c5 fb 59 05 b1 13 fe 	vmulsd xmm0,xmm0,QWORD PTR [rip+0xfffffffffffe13b1]        # 200308 <__unnamed_610+0x8>
  21ef56:	ff 
  21ef57:	eb 25                	jmp    21ef7e <Benchmark_reportStats+0x883e>
            median = @intToFloat(f64, copy.items[center].run_time_ns);
  21ef59:	48 8b 8c 24 a0 01 00 	mov    rcx,QWORD PTR [rsp+0x1a0]
  21ef60:	00 
  21ef61:	48 c1 e0 04          	shl    rax,0x4
  21ef65:	c5 fb 10 04 01       	vmovsd xmm0,QWORD PTR [rcx+rax*1]
  21ef6a:	c5 f8 14 05 5e 9d fe 	vunpcklps xmm0,xmm0,XMMWORD PTR [rip+0xfffffffffffe9d5e]        # 208cd0 <__unnamed_629+0x17>
  21ef71:	ff 
  21ef72:	c5 f9 5c 05 76 a2 fe 	vsubpd xmm0,xmm0,XMMWORD PTR [rip+0xfffffffffffea276]        # 2091f0 <__unnamed_70+0x10>
  21ef79:	ff 
  21ef7a:	c5 f9 7c c0          	vhaddpd xmm0,xmm0,xmm0
  21ef7e:	48 8b 9c 24 88 01 00 	mov    rbx,QWORD PTR [rsp+0x188]
  21ef85:	00 
  21ef86:	c5 fb 10 0d ba 13 fe 	vmovsd xmm1,QWORD PTR [rip+0xfffffffffffe13ba]        # 200348 <__unnamed_609+0x8>
  21ef8d:	ff 
  21ef8e:	c5 f9 28 d1          	vmovapd xmm2,xmm1
            .run_time_ns = @floatToInt(u64, try pSelf.statsMedian(sum, results)),
  21ef92:	c5 fb 5c ca          	vsubsd xmm1,xmm0,xmm2
  21ef96:	c4 e1 fb 2c c1       	vcvttsd2si rax,xmm1
  21ef9b:	48 b9 00 00 00 00 00 	movabs rcx,0x8000000000000000
  21efa2:	00 00 80 
  21efa5:	48 31 c8             	xor    rax,rcx
  21efa8:	c4 e1 fb 2c c8       	vcvttsd2si rcx,xmm0
  21efad:	c5 f9 2e c2          	vucomisd xmm0,xmm2
  21efb1:	48 0f 43 c8          	cmovae rcx,rax
            .iterations = results.items[0].iterations}
  21efb5:	48 8b 43 48          	mov    rax,QWORD PTR [rbx+0x48]
  21efb9:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
        try pSelf.report(Result {
  21efbd:	48 89 8c 24 f8 01 00 	mov    QWORD PTR [rsp+0x1f8],rcx
  21efc4:	00 
  21efc5:	48 89 84 24 00 02 00 	mov    QWORD PTR [rsp+0x200],rax
  21efcc:	00 
  21efcd:	48 8d b4 24 f8 01 00 	lea    rsi,[rsp+0x1f8]
  21efd4:	00 
  21efd5:	48 89 df             	mov    rdi,rbx
  21efd8:	c5 f8 77             	vzeroupper 
  21efdb:	e8 80 4a ff ff       	call   213a60 <Benchmark_report>
        try pSelf.reportStatsMedian(sum, pSelf.results); warn(" median\n");
  21efe0:	66 85 c0             	test   ax,ax
  21efe3:	0f 85 b4 02 00 00    	jne    21f29d <Benchmark_reportStats+0x8b5d>
  21efe9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  21eff0:	b0 01                	mov    al,0x1
  21eff2:	86 05 18 10 03 00    	xchg   BYTE PTR [rip+0x31018],al        # 250010 <stderr_mutex>
  21eff8:	84 c0                	test   al,al
  21effa:	75 f4                	jne    21eff0 <Benchmark_reportStats+0x88b0>
    if (stderr_stream) |st| {
  21effc:	48 8b 3d 05 10 03 00 	mov    rdi,QWORD PTR [rip+0x31005]        # 250008 <stderr_stream>
  21f003:	48 85 ff             	test   rdi,rdi
  21f006:	74 09                	je     21f011 <Benchmark_reportStats+0x88d1>
  21f008:	48 8b 0d 31 c0 02 00 	mov    rcx,QWORD PTR [rip+0x2c031]        # 24b040 <stderr_file_out_stream+0x8>
  21f00f:	eb 34                	jmp    21f045 <Benchmark_reportStats+0x8905>
        stderr_file = try io.getStdErr();
  21f011:	48 8d 05 18 c0 02 00 	lea    rax,[rip+0x2c018]        # 24b030 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  21f018:	48 89 05 19 c0 02 00 	mov    QWORD PTR [rip+0x2c019],rax        # 24b038 <stderr_file_out_stream>
  21f01f:	48 8d 0d ba 09 00 00 	lea    rcx,[rip+0x9ba]        # 21f9e0 <FileOutStream_writeFn>
  21f026:	48 89 0d 13 c0 02 00 	mov    QWORD PTR [rip+0x2c013],rcx        # 24b040 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  21f02d:	c7 05 f9 bf 02 00 02 	mov    DWORD PTR [rip+0x2bff9],0x2        # 24b030 <stderr_file>
  21f034:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  21f037:	48 8d 3d 02 c0 02 00 	lea    rdi,[rip+0x2c002]        # 24b040 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  21f03e:	48 89 3d c3 0f 03 00 	mov    QWORD PTR [rip+0x30fc3],rdi        # 250008 <stderr_stream>
  21f045:	48 8d 35 3c fd 02 00 	lea    rsi,[rip+0x2fd3c]        # 24ed88 <__unnamed_52>
  21f04c:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  21f04e:	31 c0                	xor    eax,eax
  21f050:	86 05 ba 0f 03 00    	xchg   BYTE PTR [rip+0x30fba],al        # 250010 <stderr_mutex>
  21f056:	3c 01                	cmp    al,0x1
    if (!ok) {
  21f058:	0f 85 4e 02 00 00    	jne    21f2ac <Benchmark_reportStats+0x8b6c>
        if (results.len <= 1) {
  21f05e:	48 8b 7b 58          	mov    rdi,QWORD PTR [rbx+0x58]
  21f062:	48 83 ff 01          	cmp    rdi,0x1
  21f066:	c5 fb 10 8c 24 90 01 	vmovsd xmm1,QWORD PTR [rsp+0x190]
  21f06d:	00 00 
  21f06f:	77 0b                	ja     21f07c <Benchmark_reportStats+0x893c>
            .iterations = results.items[0].iterations}
  21f071:	48 8b 43 48          	mov    rax,QWORD PTR [rbx+0x48]
  21f075:	31 c9                	xor    ecx,ecx
  21f077:	e9 7d 01 00 00       	jmp    21f1f9 <Benchmark_reportStats+0x8ab9>
            return sum / @intToFloat(f64, results.len);
  21f07c:	c4 e1 f9 6e c7       	vmovq  xmm0,rdi
  21f081:	c5 f9 62 05 47 9c fe 	vpunpckldq xmm0,xmm0,XMMWORD PTR [rip+0xfffffffffffe9c47]        # 208cd0 <__unnamed_629+0x17>
  21f088:	ff 
  21f089:	c5 f9 5c 05 5f a1 fe 	vsubpd xmm0,xmm0,XMMWORD PTR [rip+0xfffffffffffea15f]        # 2091f0 <__unnamed_70+0x10>
  21f090:	ff 
  21f091:	c5 f9 7c c0          	vhaddpd xmm0,xmm0,xmm0
  21f095:	c5 f3 5e c0          	vdivsd xmm0,xmm1,xmm0
  21f099:	49 89 d8             	mov    r8,rbx
  21f09c:	48 8b 43 48          	mov    rax,QWORD PTR [rbx+0x48]
            for (results.toSlice()) |result| {
  21f0a0:	48 8d 4f ff          	lea    rcx,[rdi-0x1]
  21f0a4:	89 fa                	mov    edx,edi
  21f0a6:	83 e2 03             	and    edx,0x3
  21f0a9:	48 83 f9 03          	cmp    rcx,0x3
  21f0ad:	73 14                	jae    21f0c3 <Benchmark_reportStats+0x8983>
  21f0af:	c5 f1 57 c9          	vxorpd xmm1,xmm1,xmm1
  21f0b3:	31 f6                	xor    esi,esi
  21f0b5:	48 85 d2             	test   rdx,rdx
  21f0b8:	0f 85 a7 00 00 00    	jne    21f165 <Benchmark_reportStats+0x8a25>
  21f0be:	e9 e3 00 00 00       	jmp    21f1a6 <Benchmark_reportStats+0x8a66>
  21f0c3:	48 29 d7             	sub    rdi,rdx
  21f0c6:	48 8d 58 30          	lea    rbx,[rax+0x30]
  21f0ca:	c5 f1 57 c9          	vxorpd xmm1,xmm1,xmm1
  21f0ce:	31 f6                	xor    esi,esi
  21f0d0:	c5 f9 28 15 f8 9b fe 	vmovapd xmm2,XMMWORD PTR [rip+0xfffffffffffe9bf8]        # 208cd0 <__unnamed_629+0x17>
  21f0d7:	ff 
  21f0d8:	c5 f9 28 1d 10 a1 fe 	vmovapd xmm3,XMMWORD PTR [rip+0xfffffffffffea110]        # 2091f0 <__unnamed_70+0x10>
  21f0df:	ff 
                var diff = @intToFloat(f64, result.run_time_ns) - mean;
  21f0e0:	c5 fb 10 63 d0       	vmovsd xmm4,QWORD PTR [rbx-0x30]
  21f0e5:	c5 d8 14 e2          	vunpcklps xmm4,xmm4,xmm2
  21f0e9:	c5 d9 5c e3          	vsubpd xmm4,xmm4,xmm3
  21f0ed:	c5 d9 7c e4          	vhaddpd xmm4,xmm4,xmm4
  21f0f1:	c5 db 5c e0          	vsubsd xmm4,xmm4,xmm0
                var square = diff * diff;
  21f0f5:	c5 db 59 e4          	vmulsd xmm4,xmm4,xmm4
                sum_of_squares += square;
  21f0f9:	c5 f3 58 cc          	vaddsd xmm1,xmm1,xmm4
                var diff = @intToFloat(f64, result.run_time_ns) - mean;
  21f0fd:	c5 fb 10 63 e0       	vmovsd xmm4,QWORD PTR [rbx-0x20]
  21f102:	c5 d8 14 e2          	vunpcklps xmm4,xmm4,xmm2
  21f106:	c5 d9 5c e3          	vsubpd xmm4,xmm4,xmm3
  21f10a:	c5 d9 7c e4          	vhaddpd xmm4,xmm4,xmm4
  21f10e:	c5 db 5c e0          	vsubsd xmm4,xmm4,xmm0
                var square = diff * diff;
  21f112:	c5 db 59 e4          	vmulsd xmm4,xmm4,xmm4
                var diff = @intToFloat(f64, result.run_time_ns) - mean;
  21f116:	c5 fb 10 6b f0       	vmovsd xmm5,QWORD PTR [rbx-0x10]
  21f11b:	c5 d0 14 ea          	vunpcklps xmm5,xmm5,xmm2
  21f11f:	c5 d1 5c eb          	vsubpd xmm5,xmm5,xmm3
  21f123:	c5 d1 7c ed          	vhaddpd xmm5,xmm5,xmm5
                sum_of_squares += square;
  21f127:	c5 f3 58 cc          	vaddsd xmm1,xmm1,xmm4
                var diff = @intToFloat(f64, result.run_time_ns) - mean;
  21f12b:	c5 d3 5c e0          	vsubsd xmm4,xmm5,xmm0
  21f12f:	c5 fb 10 2b          	vmovsd xmm5,QWORD PTR [rbx]
  21f133:	c5 d0 14 ea          	vunpcklps xmm5,xmm5,xmm2
  21f137:	c5 d1 5c eb          	vsubpd xmm5,xmm5,xmm3
  21f13b:	c5 d1 7c ed          	vhaddpd xmm5,xmm5,xmm5
                var square = diff * diff;
  21f13f:	c5 db 59 e4          	vmulsd xmm4,xmm4,xmm4
                sum_of_squares += square;
  21f143:	c5 f3 58 cc          	vaddsd xmm1,xmm1,xmm4
                var diff = @intToFloat(f64, result.run_time_ns) - mean;
  21f147:	c5 d3 5c e0          	vsubsd xmm4,xmm5,xmm0
                var square = diff * diff;
  21f14b:	c5 db 59 e4          	vmulsd xmm4,xmm4,xmm4
                sum_of_squares += square;
  21f14f:	c5 f3 58 cc          	vaddsd xmm1,xmm1,xmm4
            for (results.toSlice()) |result| {
  21f153:	48 83 c6 04          	add    rsi,0x4
  21f157:	48 83 c3 40          	add    rbx,0x40
  21f15b:	48 39 f7             	cmp    rdi,rsi
  21f15e:	75 80                	jne    21f0e0 <Benchmark_reportStats+0x89a0>
  21f160:	48 85 d2             	test   rdx,rdx
  21f163:	74 41                	je     21f1a6 <Benchmark_reportStats+0x8a66>
  21f165:	48 c1 e6 04          	shl    rsi,0x4
  21f169:	48 01 c6             	add    rsi,rax
  21f16c:	48 f7 da             	neg    rdx
  21f16f:	c5 f9 28 15 59 9b fe 	vmovapd xmm2,XMMWORD PTR [rip+0xfffffffffffe9b59]        # 208cd0 <__unnamed_629+0x17>
  21f176:	ff 
  21f177:	c5 f9 28 1d 71 a0 fe 	vmovapd xmm3,XMMWORD PTR [rip+0xfffffffffffea071]        # 2091f0 <__unnamed_70+0x10>
  21f17e:	ff 
  21f17f:	90                   	nop
                var diff = @intToFloat(f64, result.run_time_ns) - mean;
  21f180:	c5 fb 10 26          	vmovsd xmm4,QWORD PTR [rsi]
  21f184:	c5 d8 14 e2          	vunpcklps xmm4,xmm4,xmm2
  21f188:	c5 d9 5c e3          	vsubpd xmm4,xmm4,xmm3
  21f18c:	c5 d9 7c e4          	vhaddpd xmm4,xmm4,xmm4
  21f190:	c5 db 5c e0          	vsubsd xmm4,xmm4,xmm0
                var square = diff * diff;
  21f194:	c5 db 59 e4          	vmulsd xmm4,xmm4,xmm4
                sum_of_squares += square;
  21f198:	c5 f3 58 cc          	vaddsd xmm1,xmm1,xmm4
            for (results.toSlice()) |result| {
  21f19c:	48 83 c6 10          	add    rsi,0x10
  21f1a0:	48 83 c2 01          	add    rdx,0x1
  21f1a4:	75 da                	jne    21f180 <Benchmark_reportStats+0x8a40>
            std_dev = @sqrt(f64, sum_of_squares / @intToFloat(f64, results.len - 1));
  21f1a6:	c4 e1 f9 6e c1       	vmovq  xmm0,rcx
  21f1ab:	c5 f9 62 05 1d 9b fe 	vpunpckldq xmm0,xmm0,XMMWORD PTR [rip+0xfffffffffffe9b1d]        # 208cd0 <__unnamed_629+0x17>
  21f1b2:	ff 
  21f1b3:	c5 f9 5c 05 35 a0 fe 	vsubpd xmm0,xmm0,XMMWORD PTR [rip+0xfffffffffffea035]        # 2091f0 <__unnamed_70+0x10>
  21f1ba:	ff 
  21f1bb:	c5 f9 7c c0          	vhaddpd xmm0,xmm0,xmm0
  21f1bf:	c5 f3 5e c0          	vdivsd xmm0,xmm1,xmm0
  21f1c3:	c5 fb 51 c0          	vsqrtsd xmm0,xmm0,xmm0
  21f1c7:	c5 fb 10 0d 79 11 fe 	vmovsd xmm1,QWORD PTR [rip+0xfffffffffffe1179]        # 200348 <__unnamed_609+0x8>
  21f1ce:	ff 
  21f1cf:	c5 f9 28 d1          	vmovapd xmm2,xmm1
        if (results.len <= 1) {
  21f1d3:	c5 fb 5c ca          	vsubsd xmm1,xmm0,xmm2
  21f1d7:	c4 e1 fb 2c d1       	vcvttsd2si rdx,xmm1
  21f1dc:	c4 e1 fb 2c c8       	vcvttsd2si rcx,xmm0
  21f1e1:	48 be 00 00 00 00 00 	movabs rsi,0x8000000000000000
  21f1e8:	00 00 80 
  21f1eb:	48 31 f2             	xor    rdx,rsi
  21f1ee:	c5 f9 2e c2          	vucomisd xmm0,xmm2
  21f1f2:	48 0f 43 ca          	cmovae rcx,rdx
  21f1f6:	4c 89 c3             	mov    rbx,r8
            .iterations = results.items[0].iterations}
  21f1f9:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
        try pSelf.report(Result {
  21f1fd:	48 89 8c 24 28 02 00 	mov    QWORD PTR [rsp+0x228],rcx
  21f204:	00 
  21f205:	48 89 84 24 30 02 00 	mov    QWORD PTR [rsp+0x230],rax
  21f20c:	00 
  21f20d:	48 8d b4 24 28 02 00 	lea    rsi,[rsp+0x228]
  21f214:	00 
  21f215:	48 89 df             	mov    rdi,rbx
  21f218:	e8 43 48 ff ff       	call   213a60 <Benchmark_report>
        try pSelf.reportStatsStdDev(sum, pSelf.results); warn(" stddev\n");
  21f21d:	66 85 c0             	test   ax,ax
  21f220:	75 7b                	jne    21f29d <Benchmark_reportStats+0x8b5d>
  21f222:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21f229:	1f 84 00 00 00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  21f230:	b0 01                	mov    al,0x1
  21f232:	86 05 d8 0d 03 00    	xchg   BYTE PTR [rip+0x30dd8],al        # 250010 <stderr_mutex>
  21f238:	84 c0                	test   al,al
  21f23a:	75 f4                	jne    21f230 <Benchmark_reportStats+0x8af0>
    if (stderr_stream) |st| {
  21f23c:	48 8b 3d c5 0d 03 00 	mov    rdi,QWORD PTR [rip+0x30dc5]        # 250008 <stderr_stream>
  21f243:	48 85 ff             	test   rdi,rdi
  21f246:	74 09                	je     21f251 <Benchmark_reportStats+0x8b11>
  21f248:	48 8b 0d f1 bd 02 00 	mov    rcx,QWORD PTR [rip+0x2bdf1]        # 24b040 <stderr_file_out_stream+0x8>
  21f24f:	eb 34                	jmp    21f285 <Benchmark_reportStats+0x8b45>
        stderr_file = try io.getStdErr();
  21f251:	48 8d 05 d8 bd 02 00 	lea    rax,[rip+0x2bdd8]        # 24b030 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  21f258:	48 89 05 d9 bd 02 00 	mov    QWORD PTR [rip+0x2bdd9],rax        # 24b038 <stderr_file_out_stream>
  21f25f:	48 8d 0d 7a 07 00 00 	lea    rcx,[rip+0x77a]        # 21f9e0 <FileOutStream_writeFn>
  21f266:	48 89 0d d3 bd 02 00 	mov    QWORD PTR [rip+0x2bdd3],rcx        # 24b040 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  21f26d:	c7 05 b9 bd 02 00 02 	mov    DWORD PTR [rip+0x2bdb9],0x2        # 24b030 <stderr_file>
  21f274:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  21f277:	48 8d 3d c2 bd 02 00 	lea    rdi,[rip+0x2bdc2]        # 24b040 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  21f27e:	48 89 3d 83 0d 03 00 	mov    QWORD PTR [rip+0x30d83],rdi        # 250008 <stderr_stream>
  21f285:	48 8d 35 0c fb 02 00 	lea    rsi,[rip+0x2fb0c]        # 24ed98 <__unnamed_53>
  21f28c:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  21f28e:	31 c9                	xor    ecx,ecx
  21f290:	86 0d 7a 0d 03 00    	xchg   BYTE PTR [rip+0x30d7a],cl        # 250010 <stderr_mutex>
  21f296:	31 c0                	xor    eax,eax
  21f298:	80 f9 01             	cmp    cl,0x1
    if (!ok) {
  21f29b:	75 0f                	jne    21f2ac <Benchmark_reportStats+0x8b6c>
        try pSelf.reportStatsMean(sum, pSelf.results); warn(" mean\n");
  21f29d:	48 8d 65 d8          	lea    rsp,[rbp-0x28]
  21f2a1:	5b                   	pop    rbx
  21f2a2:	41 5c                	pop    r12
  21f2a4:	41 5d                	pop    r13
  21f2a6:	41 5e                	pop    r14
  21f2a8:	41 5f                	pop    r15
  21f2aa:	5d                   	pop    rbp
  21f2ab:	c3                   	ret    
            @panic("assertion failure");
  21f2ac:	48 8d 3d 55 fa 02 00 	lea    rdi,[rip+0x2fa55]        # 24ed08 <__unnamed_2>
  21f2b3:	c5 f8 77             	vzeroupper 
  21f2b6:	e8 65 2d ff ff       	call   212020 <panic>
  21f2bb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

000000000021f2c0 <findLastForward>:
fn findLastForward(comptime T: type, items: []T, value: T, range: Range, lessThan: fn (T, T) bool, unique: usize) usize {
  21f2c0:	41 56                	push   r14
  21f2c2:	53                   	push   rbx
  21f2c3:	49 89 d1             	mov    r9,rdx
    if (range.length() == 0) return range.start;
  21f2c6:	48 89 c8             	mov    rax,rcx
  21f2c9:	4c 29 c8             	sub    rax,r9
  21f2cc:	0f 84 eb 00 00 00    	je     21f3bd <findLastForward+0xfd>
  21f2d2:	48 89 c2             	mov    rdx,rax
  21f2d5:	4c 09 c2             	or     rdx,r8
  21f2d8:	48 c1 ea 20          	shr    rdx,0x20
  21f2dc:	74 07                	je     21f2e5 <findLastForward+0x25>
  21f2de:	31 d2                	xor    edx,edx
  21f2e0:	49 f7 f0             	div    r8
  21f2e3:	eb 05                	jmp    21f2ea <findLastForward+0x2a>
  21f2e5:	31 d2                	xor    edx,edx
  21f2e7:	41 f7 f0             	div    r8d
  21f2ea:	48 83 f8 01          	cmp    rax,0x1
  21f2ee:	41 ba 01 00 00 00    	mov    r10d,0x1
  21f2f4:	4c 0f 47 d0          	cmova  r10,rax
  21f2f8:	4b 8d 14 0a          	lea    rdx,[r10+r9*1]
    while (!lessThan(value, items[index - 1])) : (index += skip) {
  21f2fc:	4f 8d 5c 0a ff       	lea    r11,[r10+r9*1-0x1]
  21f301:	4c 8b 37             	mov    r14,QWORD PTR [rdi]
  21f304:	4c 8b 06             	mov    r8,QWORD PTR [rsi]
  21f307:	4c 89 d8             	mov    rax,r11
  21f30a:	48 c1 e0 04          	shl    rax,0x4
  21f30e:	49 8b 34 06          	mov    rsi,QWORD PTR [r14+rax*1]
            return lhs.run_time_ns < rhs.run_time_ns;
  21f312:	49 39 f0             	cmp    r8,rsi
  21f315:	73 10                	jae    21f327 <findLastForward+0x67>
  21f317:	4c 89 c8             	mov    rax,r9
  21f31a:	49 89 d1             	mov    r9,rdx
    if (range.start >= range.end) return range.end;
  21f31d:	4d 85 d2             	test   r10,r10
  21f320:	75 3e                	jne    21f360 <findLastForward+0xa0>
  21f322:	e9 96 00 00 00       	jmp    21f3bd <findLastForward+0xfd>
  21f327:	48 89 cf             	mov    rdi,rcx
  21f32a:	4c 29 d7             	sub    rdi,r10
  21f32d:	0f 1f 00             	nop    DWORD PTR [rax]
  21f330:	48 89 d0             	mov    rax,rdx
        if (index >= range.end - skip) {
  21f333:	48 39 f8             	cmp    rax,rdi
  21f336:	0f 83 88 00 00 00    	jae    21f3c4 <findLastForward+0x104>
  21f33c:	4a 8d 14 10          	lea    rdx,[rax+r10*1]
    while (!lessThan(value, items[index - 1])) : (index += skip) {
  21f340:	4e 8d 1c 10          	lea    r11,[rax+r10*1]
  21f344:	49 83 c3 ff          	add    r11,0xffffffffffffffff
  21f348:	4c 89 de             	mov    rsi,r11
  21f34b:	48 c1 e6 04          	shl    rsi,0x4
  21f34f:	49 8b 34 36          	mov    rsi,QWORD PTR [r14+rsi*1]
  21f353:	49 39 f0             	cmp    r8,rsi
  21f356:	73 d8                	jae    21f330 <findLastForward+0x70>
  21f358:	49 89 d1             	mov    r9,rdx
    if (range.start >= range.end) return range.end;
  21f35b:	4d 85 d2             	test   r10,r10
  21f35e:	74 5d                	je     21f3bd <findLastForward+0xfd>
    while (start < end) {
  21f360:	49 39 c3             	cmp    r11,rax
  21f363:	76 43                	jbe    21f3a8 <findLastForward+0xe8>
  21f365:	4c 89 d9             	mov    rcx,r11
  21f368:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  21f36f:	00 
        const mid = start + (end - start) / 2;
  21f370:	48 89 ca             	mov    rdx,rcx
  21f373:	48 29 c2             	sub    rdx,rax
  21f376:	48 d1 ea             	shr    rdx,1
  21f379:	48 8d 1c 02          	lea    rbx,[rdx+rax*1]
  21f37d:	48 89 df             	mov    rdi,rbx
  21f380:	48 c1 e7 04          	shl    rdi,0x4
  21f384:	4d 3b 04 3e          	cmp    r8,QWORD PTR [r14+rdi*1]
        if (!lessThan(value, items[mid])) {
  21f388:	72 16                	jb     21f3a0 <findLastForward+0xe0>
  21f38a:	48 01 d0             	add    rax,rdx
  21f38d:	48 83 c0 01          	add    rax,0x1
    while (start < end) {
  21f391:	48 39 c1             	cmp    rcx,rax
  21f394:	77 da                	ja     21f370 <findLastForward+0xb0>
  21f396:	eb 10                	jmp    21f3a8 <findLastForward+0xe8>
  21f398:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  21f39f:	00 
        if (!lessThan(value, items[mid])) {
  21f3a0:	48 89 d9             	mov    rcx,rbx
    while (start < end) {
  21f3a3:	48 39 c1             	cmp    rcx,rax
  21f3a6:	77 c8                	ja     21f370 <findLastForward+0xb0>
    if (start == range.end - 1 and !lessThan(value, items[start])) {
  21f3a8:	4c 39 d8             	cmp    rax,r11
  21f3ab:	0f 94 c1             	sete   cl
  21f3ae:	49 39 f0             	cmp    r8,rsi
  21f3b1:	0f 93 c2             	setae  dl
  21f3b4:	20 ca                	and    dl,cl
  21f3b6:	44 0f b6 ca          	movzx  r9d,dl
  21f3ba:	49 01 c1             	add    r9,rax
    if (range.length() == 0) return range.start;
  21f3bd:	4c 89 c8             	mov    rax,r9
  21f3c0:	5b                   	pop    rbx
  21f3c1:	41 5e                	pop    r14
  21f3c3:	c3                   	ret    
    if (range.start >= range.end) return range.end;
  21f3c4:	48 39 c8             	cmp    rax,rcx
  21f3c7:	73 65                	jae    21f42e <findLastForward+0x16e>
    var end = range.end - 1;
  21f3c9:	48 83 c1 ff          	add    rcx,0xffffffffffffffff
    while (start < end) {
  21f3cd:	48 39 c1             	cmp    rcx,rax
  21f3d0:	76 46                	jbe    21f418 <findLastForward+0x158>
  21f3d2:	49 89 c9             	mov    r9,rcx
  21f3d5:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21f3dc:	00 00 00 00 
        const mid = start + (end - start) / 2;
  21f3e0:	4c 89 ce             	mov    rsi,r9
  21f3e3:	48 29 c6             	sub    rsi,rax
  21f3e6:	48 d1 ee             	shr    rsi,1
  21f3e9:	48 8d 14 06          	lea    rdx,[rsi+rax*1]
  21f3ed:	48 89 d7             	mov    rdi,rdx
  21f3f0:	48 c1 e7 04          	shl    rdi,0x4
  21f3f4:	4d 3b 04 3e          	cmp    r8,QWORD PTR [r14+rdi*1]
        if (!lessThan(value, items[mid])) {
  21f3f8:	72 16                	jb     21f410 <findLastForward+0x150>
  21f3fa:	48 01 f0             	add    rax,rsi
  21f3fd:	48 83 c0 01          	add    rax,0x1
    while (start < end) {
  21f401:	49 39 c1             	cmp    r9,rax
  21f404:	77 da                	ja     21f3e0 <findLastForward+0x120>
  21f406:	eb 10                	jmp    21f418 <findLastForward+0x158>
  21f408:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  21f40f:	00 
        if (!lessThan(value, items[mid])) {
  21f410:	49 89 d1             	mov    r9,rdx
    while (start < end) {
  21f413:	49 39 c1             	cmp    r9,rax
  21f416:	77 c8                	ja     21f3e0 <findLastForward+0x120>
    if (start == range.end - 1 and !lessThan(value, items[start])) {
  21f418:	48 39 c8             	cmp    rax,rcx
  21f41b:	75 1b                	jne    21f438 <findLastForward+0x178>
  21f41d:	48 c1 e1 04          	shl    rcx,0x4
  21f421:	45 31 c9             	xor    r9d,r9d
  21f424:	4d 3b 04 0e          	cmp    r8,QWORD PTR [r14+rcx*1]
  21f428:	41 0f 93 c1          	setae  r9b
  21f42c:	eb 8c                	jmp    21f3ba <findLastForward+0xfa>
  21f42e:	49 89 c9             	mov    r9,rcx
    if (range.length() == 0) return range.start;
  21f431:	4c 89 c8             	mov    rax,r9
  21f434:	5b                   	pop    rbx
  21f435:	41 5e                	pop    r14
  21f437:	c3                   	ret    
  21f438:	45 31 c9             	xor    r9d,r9d
  21f43b:	e9 7a ff ff ff       	jmp    21f3ba <findLastForward+0xfa>

000000000021f440 <mergeInPlace>:
fn mergeInPlace(comptime T: type, items: []T, A_arg: Range, B_arg: Range, lessThan: fn (T, T) bool) void {
  21f440:	55                   	push   rbp
  21f441:	41 57                	push   r15
  21f443:	41 56                	push   r14
  21f445:	41 55                	push   r13
  21f447:	41 54                	push   r12
  21f449:	53                   	push   rbx
  21f44a:	48 89 7c 24 f0       	mov    QWORD PTR [rsp-0x10],rdi
  21f44f:	4c 8b 3e             	mov    r15,QWORD PTR [rsi]
  21f452:	4c 8b 76 08          	mov    r14,QWORD PTR [rsi+0x8]
    if (A_arg.length() == 0 or B_arg.length() == 0) return;
  21f456:	4d 39 fe             	cmp    r14,r15
  21f459:	0f 84 76 05 00 00    	je     21f9d5 <mergeInPlace+0x595>
  21f45f:	48 8b 0a             	mov    rcx,QWORD PTR [rdx]
  21f462:	4c 8b 4a 08          	mov    r9,QWORD PTR [rdx+0x8]
  21f466:	49 39 c9             	cmp    r9,rcx
  21f469:	0f 84 66 05 00 00    	je     21f9d5 <mergeInPlace+0x595>
  21f46f:	49 8d 41 ff          	lea    rax,[r9-0x1]
        const mid = binaryFirst(T, items, items[A.start], B, lessThan);
  21f473:	48 89 44 24 f8       	mov    QWORD PTR [rsp-0x8],rax
  21f478:	48 8b 44 24 f0       	mov    rax,QWORD PTR [rsp-0x10]
  21f47d:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  21f480:	4d 89 fa             	mov    r10,r15
  21f483:	49 c1 e2 04          	shl    r10,0x4
  21f487:	4e 8d 1c 12          	lea    r11,[rdx+r10*1]
  21f48b:	4d 89 cc             	mov    r12,r9
    if (range.start >= range.end) return range.end;
  21f48e:	4c 39 c9             	cmp    rcx,r9
  21f491:	0f 83 7f 00 00 00    	jae    21f516 <mergeInPlace+0xd6>
  21f497:	4c 8b 44 24 f8       	mov    r8,QWORD PTR [rsp-0x8]
    while (start < end) {
  21f49c:	49 39 c8             	cmp    r8,rcx
  21f49f:	76 4b                	jbe    21f4ec <mergeInPlace+0xac>
  21f4a1:	49 8b 03             	mov    rax,QWORD PTR [r11]
  21f4a4:	4c 89 c5             	mov    rbp,r8
  21f4a7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  21f4ae:	00 00 
        const mid = start + (end - start) / 2;
  21f4b0:	48 89 ee             	mov    rsi,rbp
  21f4b3:	48 29 ce             	sub    rsi,rcx
  21f4b6:	48 d1 ee             	shr    rsi,1
  21f4b9:	48 8d 1c 0e          	lea    rbx,[rsi+rcx*1]
  21f4bd:	48 89 df             	mov    rdi,rbx
  21f4c0:	48 c1 e7 04          	shl    rdi,0x4
  21f4c4:	48 39 04 3a          	cmp    QWORD PTR [rdx+rdi*1],rax
        if (lessThan(items[mid], value)) {
  21f4c8:	72 16                	jb     21f4e0 <mergeInPlace+0xa0>
  21f4ca:	48 89 dd             	mov    rbp,rbx
    while (start < end) {
  21f4cd:	48 39 cd             	cmp    rbp,rcx
  21f4d0:	77 de                	ja     21f4b0 <mergeInPlace+0x70>
  21f4d2:	eb 18                	jmp    21f4ec <mergeInPlace+0xac>
  21f4d4:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21f4db:	00 00 00 00 00 
  21f4e0:	48 01 f1             	add    rcx,rsi
  21f4e3:	48 83 c1 01          	add    rcx,0x1
  21f4e7:	48 39 cd             	cmp    rbp,rcx
  21f4ea:	77 c4                	ja     21f4b0 <mergeInPlace+0x70>
    if (start == range.end - 1 and lessThan(items[start], value)) {
  21f4ec:	4c 39 c1             	cmp    rcx,r8
  21f4ef:	75 1f                	jne    21f510 <mergeInPlace+0xd0>
  21f4f1:	4c 89 c0             	mov    rax,r8
  21f4f4:	48 c1 e0 04          	shl    rax,0x4
  21f4f8:	48 8b 04 02          	mov    rax,QWORD PTR [rdx+rax*1]
  21f4fc:	45 31 e4             	xor    r12d,r12d
  21f4ff:	49 3b 03             	cmp    rax,QWORD PTR [r11]
  21f502:	41 0f 92 c4          	setb   r12b
  21f506:	eb 0b                	jmp    21f513 <mergeInPlace+0xd3>
  21f508:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  21f50f:	00 
  21f510:	45 31 e4             	xor    r12d,r12d
  21f513:	49 01 cc             	add    r12,rcx
        mem.rotate(T, items[A.start..mid], A.length());
  21f516:	4d 89 e5             	mov    r13,r12
  21f519:	4d 29 fd             	sub    r13,r15
        return self.end - self.start;
  21f51c:	4c 89 f3             	mov    rbx,r14
  21f51f:	4c 29 fb             	sub    rbx,r15
    const end = items.len / 2;
  21f522:	48 89 de             	mov    rsi,rbx
  21f525:	48 d1 ee             	shr    rsi,1
    while (i < end) : (i += 1) {
  21f528:	0f 84 2c 01 00 00    	je     21f65a <mergeInPlace+0x21a>
        swap(T, &items[i], &items[items.len - i - 1]);
  21f52e:	48 8d 46 ff          	lea    rax,[rsi-0x1]
  21f532:	89 f1                	mov    ecx,esi
  21f534:	83 e1 03             	and    ecx,0x3
  21f537:	48 83 f8 03          	cmp    rax,0x3
  21f53b:	73 13                	jae    21f550 <mergeInPlace+0x110>
  21f53d:	31 c0                	xor    eax,eax
    while (i < end) : (i += 1) {
  21f53f:	48 85 c9             	test   rcx,rcx
  21f542:	0f 85 c8 00 00 00    	jne    21f610 <mergeInPlace+0x1d0>
  21f548:	e9 0d 01 00 00       	jmp    21f65a <mergeInPlace+0x21a>
  21f54d:	0f 1f 00             	nop    DWORD PTR [rax]
        swap(T, &items[i], &items[items.len - i - 1]);
  21f550:	48 29 ce             	sub    rsi,rcx
  21f553:	4a 8d 2c 12          	lea    rbp,[rdx+r10*1]
  21f557:	48 83 c5 30          	add    rbp,0x30
  21f55b:	4c 89 f0             	mov    rax,r14
  21f55e:	48 c1 e0 04          	shl    rax,0x4
  21f562:	4c 8d 04 02          	lea    r8,[rdx+rax*1]
  21f566:	49 83 c0 f0          	add    r8,0xfffffffffffffff0
  21f56a:	31 c0                	xor    eax,eax
  21f56c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
    const tmp = a.*;
  21f570:	c5 f8 10 45 d0       	vmovups xmm0,XMMWORD PTR [rbp-0x30]
  21f575:	c5 f8 29 44 24 d8    	vmovaps XMMWORD PTR [rsp-0x28],xmm0
    a.* = b.*;
  21f57b:	c4 c1 78 10 00       	vmovups xmm0,XMMWORD PTR [r8]
  21f580:	c5 f8 11 45 d0       	vmovups XMMWORD PTR [rbp-0x30],xmm0
    b.* = tmp;
  21f585:	c5 f8 28 44 24 d8    	vmovaps xmm0,XMMWORD PTR [rsp-0x28]
  21f58b:	c4 c1 78 11 00       	vmovups XMMWORD PTR [r8],xmm0
    const tmp = a.*;
  21f590:	c5 f8 10 45 e0       	vmovups xmm0,XMMWORD PTR [rbp-0x20]
  21f595:	c5 f8 29 44 24 d8    	vmovaps XMMWORD PTR [rsp-0x28],xmm0
    a.* = b.*;
  21f59b:	c4 c1 78 10 40 f0    	vmovups xmm0,XMMWORD PTR [r8-0x10]
  21f5a1:	c5 f8 11 45 e0       	vmovups XMMWORD PTR [rbp-0x20],xmm0
    b.* = tmp;
  21f5a6:	c5 f8 28 44 24 d8    	vmovaps xmm0,XMMWORD PTR [rsp-0x28]
  21f5ac:	c4 c1 78 11 40 f0    	vmovups XMMWORD PTR [r8-0x10],xmm0
    const tmp = a.*;
  21f5b2:	c5 f8 10 45 f0       	vmovups xmm0,XMMWORD PTR [rbp-0x10]
  21f5b7:	c5 f8 29 44 24 d8    	vmovaps XMMWORD PTR [rsp-0x28],xmm0
    a.* = b.*;
  21f5bd:	c4 c1 78 10 40 e0    	vmovups xmm0,XMMWORD PTR [r8-0x20]
  21f5c3:	c5 f8 11 45 f0       	vmovups XMMWORD PTR [rbp-0x10],xmm0
    b.* = tmp;
  21f5c8:	c5 f8 28 44 24 d8    	vmovaps xmm0,XMMWORD PTR [rsp-0x28]
  21f5ce:	c4 c1 78 11 40 e0    	vmovups XMMWORD PTR [r8-0x20],xmm0
    const tmp = a.*;
  21f5d4:	c5 f8 10 45 00       	vmovups xmm0,XMMWORD PTR [rbp+0x0]
  21f5d9:	c5 f8 29 44 24 d8    	vmovaps XMMWORD PTR [rsp-0x28],xmm0
    a.* = b.*;
  21f5df:	c4 c1 78 10 40 d0    	vmovups xmm0,XMMWORD PTR [r8-0x30]
  21f5e5:	c5 f8 11 45 00       	vmovups XMMWORD PTR [rbp+0x0],xmm0
    b.* = tmp;
  21f5ea:	c5 f8 28 44 24 d8    	vmovaps xmm0,XMMWORD PTR [rsp-0x28]
  21f5f0:	c4 c1 78 11 40 d0    	vmovups XMMWORD PTR [r8-0x30],xmm0
    while (i < end) : (i += 1) {
  21f5f6:	48 83 c0 04          	add    rax,0x4
  21f5fa:	48 83 c5 40          	add    rbp,0x40
  21f5fe:	49 83 c0 c0          	add    r8,0xffffffffffffffc0
  21f602:	48 39 c6             	cmp    rsi,rax
  21f605:	0f 85 65 ff ff ff    	jne    21f570 <mergeInPlace+0x130>
  21f60b:	48 85 c9             	test   rcx,rcx
  21f60e:	74 4a                	je     21f65a <mergeInPlace+0x21a>
  21f610:	4c 89 f6             	mov    rsi,r14
  21f613:	48 29 c6             	sub    rsi,rax
  21f616:	48 c1 e6 04          	shl    rsi,0x4
  21f61a:	48 01 d6             	add    rsi,rdx
  21f61d:	48 83 c6 f0          	add    rsi,0xfffffffffffffff0
  21f621:	4c 01 f8             	add    rax,r15
  21f624:	48 c1 e0 04          	shl    rax,0x4
  21f628:	48 01 d0             	add    rax,rdx
  21f62b:	48 f7 d9             	neg    rcx
  21f62e:	66 90                	xchg   ax,ax
    const tmp = a.*;
  21f630:	c5 f8 10 00          	vmovups xmm0,XMMWORD PTR [rax]
  21f634:	c5 f8 29 44 24 d8    	vmovaps XMMWORD PTR [rsp-0x28],xmm0
    a.* = b.*;
  21f63a:	c5 f8 10 06          	vmovups xmm0,XMMWORD PTR [rsi]
  21f63e:	c5 f8 11 00          	vmovups XMMWORD PTR [rax],xmm0
    b.* = tmp;
  21f642:	c5 f8 28 44 24 d8    	vmovaps xmm0,XMMWORD PTR [rsp-0x28]
  21f648:	c5 f8 11 06          	vmovups XMMWORD PTR [rsi],xmm0
    while (i < end) : (i += 1) {
  21f64c:	48 83 c6 f0          	add    rsi,0xfffffffffffffff0
  21f650:	48 83 c0 10          	add    rax,0x10
  21f654:	48 83 c1 01          	add    rcx,0x1
  21f658:	75 d6                	jne    21f630 <mergeInPlace+0x1f0>
    reverse(T, items[amount..]);
  21f65a:	4c 89 e9             	mov    rcx,r13
  21f65d:	48 29 d9             	sub    rcx,rbx
    const end = items.len / 2;
  21f660:	48 d1 e9             	shr    rcx,1
    while (i < end) : (i += 1) {
  21f663:	0f 84 41 01 00 00    	je     21f7aa <mergeInPlace+0x36a>
        swap(T, &items[i], &items[items.len - i - 1]);
  21f669:	48 8d 41 ff          	lea    rax,[rcx-0x1]
  21f66d:	89 ce                	mov    esi,ecx
  21f66f:	83 e6 03             	and    esi,0x3
  21f672:	48 83 f8 03          	cmp    rax,0x3
  21f676:	73 18                	jae    21f690 <mergeInPlace+0x250>
  21f678:	31 c0                	xor    eax,eax
    while (i < end) : (i += 1) {
  21f67a:	48 85 f6             	test   rsi,rsi
  21f67d:	0f 85 d5 00 00 00    	jne    21f758 <mergeInPlace+0x318>
  21f683:	e9 22 01 00 00       	jmp    21f7aa <mergeInPlace+0x36a>
  21f688:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  21f68f:	00 
        swap(T, &items[i], &items[items.len - i - 1]);
  21f690:	48 29 f1             	sub    rcx,rsi
  21f693:	4c 89 f0             	mov    rax,r14
  21f696:	48 c1 e0 04          	shl    rax,0x4
  21f69a:	48 8d 1c 02          	lea    rbx,[rdx+rax*1]
  21f69e:	48 83 c3 30          	add    rbx,0x30
  21f6a2:	4c 89 e0             	mov    rax,r12
  21f6a5:	48 c1 e0 04          	shl    rax,0x4
  21f6a9:	48 8d 2c 02          	lea    rbp,[rdx+rax*1]
  21f6ad:	48 83 c5 f0          	add    rbp,0xfffffffffffffff0
  21f6b1:	31 c0                	xor    eax,eax
  21f6b3:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21f6ba:	84 00 00 00 00 00 
    const tmp = a.*;
  21f6c0:	c5 f8 10 43 d0       	vmovups xmm0,XMMWORD PTR [rbx-0x30]
  21f6c5:	c5 f8 29 44 24 d8    	vmovaps XMMWORD PTR [rsp-0x28],xmm0
    a.* = b.*;
  21f6cb:	c5 f8 10 45 00       	vmovups xmm0,XMMWORD PTR [rbp+0x0]
  21f6d0:	c5 f8 11 43 d0       	vmovups XMMWORD PTR [rbx-0x30],xmm0
    b.* = tmp;
  21f6d5:	c5 f8 28 44 24 d8    	vmovaps xmm0,XMMWORD PTR [rsp-0x28]
  21f6db:	c5 f8 11 45 00       	vmovups XMMWORD PTR [rbp+0x0],xmm0
    const tmp = a.*;
  21f6e0:	c5 f8 10 43 e0       	vmovups xmm0,XMMWORD PTR [rbx-0x20]
  21f6e5:	c5 f8 29 44 24 d8    	vmovaps XMMWORD PTR [rsp-0x28],xmm0
    a.* = b.*;
  21f6eb:	c5 f8 10 45 f0       	vmovups xmm0,XMMWORD PTR [rbp-0x10]
  21f6f0:	c5 f8 11 43 e0       	vmovups XMMWORD PTR [rbx-0x20],xmm0
    b.* = tmp;
  21f6f5:	c5 f8 28 44 24 d8    	vmovaps xmm0,XMMWORD PTR [rsp-0x28]
  21f6fb:	c5 f8 11 45 f0       	vmovups XMMWORD PTR [rbp-0x10],xmm0
    const tmp = a.*;
  21f700:	c5 f8 10 43 f0       	vmovups xmm0,XMMWORD PTR [rbx-0x10]
  21f705:	c5 f8 29 44 24 d8    	vmovaps XMMWORD PTR [rsp-0x28],xmm0
    a.* = b.*;
  21f70b:	c5 f8 10 45 e0       	vmovups xmm0,XMMWORD PTR [rbp-0x20]
  21f710:	c5 f8 11 43 f0       	vmovups XMMWORD PTR [rbx-0x10],xmm0
    b.* = tmp;
  21f715:	c5 f8 28 44 24 d8    	vmovaps xmm0,XMMWORD PTR [rsp-0x28]
  21f71b:	c5 f8 11 45 e0       	vmovups XMMWORD PTR [rbp-0x20],xmm0
    const tmp = a.*;
  21f720:	c5 f8 10 03          	vmovups xmm0,XMMWORD PTR [rbx]
  21f724:	c5 f8 29 44 24 d8    	vmovaps XMMWORD PTR [rsp-0x28],xmm0
    a.* = b.*;
  21f72a:	c5 f8 10 45 d0       	vmovups xmm0,XMMWORD PTR [rbp-0x30]
  21f72f:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
    b.* = tmp;
  21f733:	c5 f8 28 44 24 d8    	vmovaps xmm0,XMMWORD PTR [rsp-0x28]
  21f739:	c5 f8 11 45 d0       	vmovups XMMWORD PTR [rbp-0x30],xmm0
    while (i < end) : (i += 1) {
  21f73e:	48 83 c0 04          	add    rax,0x4
  21f742:	48 83 c3 40          	add    rbx,0x40
  21f746:	48 83 c5 c0          	add    rbp,0xffffffffffffffc0
  21f74a:	48 39 c1             	cmp    rcx,rax
  21f74d:	0f 85 6d ff ff ff    	jne    21f6c0 <mergeInPlace+0x280>
  21f753:	48 85 f6             	test   rsi,rsi
  21f756:	74 52                	je     21f7aa <mergeInPlace+0x36a>
  21f758:	4c 89 e1             	mov    rcx,r12
  21f75b:	48 29 c1             	sub    rcx,rax
  21f75e:	48 c1 e1 04          	shl    rcx,0x4
  21f762:	48 01 d1             	add    rcx,rdx
  21f765:	48 83 c1 f0          	add    rcx,0xfffffffffffffff0
  21f769:	4c 01 f0             	add    rax,r14
  21f76c:	48 c1 e0 04          	shl    rax,0x4
  21f770:	48 01 d0             	add    rax,rdx
  21f773:	48 f7 de             	neg    rsi
  21f776:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  21f77d:	00 00 00 
    const tmp = a.*;
  21f780:	c5 f8 10 00          	vmovups xmm0,XMMWORD PTR [rax]
  21f784:	c5 f8 29 44 24 d8    	vmovaps XMMWORD PTR [rsp-0x28],xmm0
    a.* = b.*;
  21f78a:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  21f78e:	c5 f8 11 00          	vmovups XMMWORD PTR [rax],xmm0
    b.* = tmp;
  21f792:	c5 f8 28 44 24 d8    	vmovaps xmm0,XMMWORD PTR [rsp-0x28]
  21f798:	c5 f8 11 01          	vmovups XMMWORD PTR [rcx],xmm0
    while (i < end) : (i += 1) {
  21f79c:	48 83 c1 f0          	add    rcx,0xfffffffffffffff0
  21f7a0:	48 83 c0 10          	add    rax,0x10
  21f7a4:	48 83 c6 01          	add    rsi,0x1
  21f7a8:	75 d6                	jne    21f780 <mergeInPlace+0x340>
    const end = items.len / 2;
  21f7aa:	4c 89 e9             	mov    rcx,r13
  21f7ad:	48 d1 e9             	shr    rcx,1
    while (i < end) : (i += 1) {
  21f7b0:	0f 84 6a 01 00 00    	je     21f920 <mergeInPlace+0x4e0>
    const tmp = a.*;
  21f7b6:	c4 c1 78 10 03       	vmovups xmm0,XMMWORD PTR [r11]
  21f7bb:	c5 f8 29 44 24 d8    	vmovaps XMMWORD PTR [rsp-0x28],xmm0
        swap(T, &items[i], &items[items.len - i - 1]);
  21f7c1:	49 c1 e5 04          	shl    r13,0x4
    a.* = b.*;
  21f7c5:	c4 81 78 10 44 2b f0 	vmovups xmm0,XMMWORD PTR [r11+r13*1-0x10]
  21f7cc:	c4 c1 78 11 03       	vmovups XMMWORD PTR [r11],xmm0
    b.* = tmp;
  21f7d1:	c5 f8 28 44 24 d8    	vmovaps xmm0,XMMWORD PTR [rsp-0x28]
  21f7d7:	c4 81 78 11 44 2b f0 	vmovups XMMWORD PTR [r11+r13*1-0x10],xmm0
    while (i < end) : (i += 1) {
  21f7de:	48 83 f9 01          	cmp    rcx,0x1
  21f7e2:	0f 84 38 01 00 00    	je     21f920 <mergeInPlace+0x4e0>
        swap(T, &items[i], &items[items.len - i - 1]);
  21f7e8:	8d 71 ff             	lea    esi,[rcx-0x1]
  21f7eb:	48 8d 41 fe          	lea    rax,[rcx-0x2]
  21f7ef:	83 e6 03             	and    esi,0x3
  21f7f2:	48 83 f8 03          	cmp    rax,0x3
  21f7f6:	73 13                	jae    21f80b <mergeInPlace+0x3cb>
  21f7f8:	b8 01 00 00 00       	mov    eax,0x1
    while (i < end) : (i += 1) {
  21f7fd:	48 85 f6             	test   rsi,rsi
  21f800:	0f 85 c2 00 00 00    	jne    21f8c8 <mergeInPlace+0x488>
  21f806:	e9 15 01 00 00       	jmp    21f920 <mergeInPlace+0x4e0>
        swap(T, &items[i], &items[items.len - i - 1]);
  21f80b:	4c 89 e0             	mov    rax,r12
  21f80e:	48 c1 e0 04          	shl    rax,0x4
  21f812:	48 8d 2c 02          	lea    rbp,[rdx+rax*1]
  21f816:	48 83 c5 e0          	add    rbp,0xffffffffffffffe0
  21f81a:	4a 8d 1c 12          	lea    rbx,[rdx+r10*1]
  21f81e:	48 83 c3 40          	add    rbx,0x40
  21f822:	48 29 f1             	sub    rcx,rsi
  21f825:	b8 01 00 00 00       	mov    eax,0x1
  21f82a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
    const tmp = a.*;
  21f830:	c5 f8 10 43 d0       	vmovups xmm0,XMMWORD PTR [rbx-0x30]
  21f835:	c5 f8 29 44 24 d8    	vmovaps XMMWORD PTR [rsp-0x28],xmm0
    a.* = b.*;
  21f83b:	c5 f8 10 45 00       	vmovups xmm0,XMMWORD PTR [rbp+0x0]
  21f840:	c5 f8 11 43 d0       	vmovups XMMWORD PTR [rbx-0x30],xmm0
    b.* = tmp;
  21f845:	c5 f8 28 44 24 d8    	vmovaps xmm0,XMMWORD PTR [rsp-0x28]
  21f84b:	c5 f8 11 45 00       	vmovups XMMWORD PTR [rbp+0x0],xmm0
    const tmp = a.*;
  21f850:	c5 f8 10 43 e0       	vmovups xmm0,XMMWORD PTR [rbx-0x20]
  21f855:	c5 f8 29 44 24 d8    	vmovaps XMMWORD PTR [rsp-0x28],xmm0
    a.* = b.*;
  21f85b:	c5 f8 10 45 f0       	vmovups xmm0,XMMWORD PTR [rbp-0x10]
  21f860:	c5 f8 11 43 e0       	vmovups XMMWORD PTR [rbx-0x20],xmm0
    b.* = tmp;
  21f865:	c5 f8 28 44 24 d8    	vmovaps xmm0,XMMWORD PTR [rsp-0x28]
  21f86b:	c5 f8 11 45 f0       	vmovups XMMWORD PTR [rbp-0x10],xmm0
    const tmp = a.*;
  21f870:	c5 f8 10 43 f0       	vmovups xmm0,XMMWORD PTR [rbx-0x10]
  21f875:	c5 f8 29 44 24 d8    	vmovaps XMMWORD PTR [rsp-0x28],xmm0
    a.* = b.*;
  21f87b:	c5 f8 10 45 e0       	vmovups xmm0,XMMWORD PTR [rbp-0x20]
  21f880:	c5 f8 11 43 f0       	vmovups XMMWORD PTR [rbx-0x10],xmm0
    b.* = tmp;
  21f885:	c5 f8 28 44 24 d8    	vmovaps xmm0,XMMWORD PTR [rsp-0x28]
  21f88b:	c5 f8 11 45 e0       	vmovups XMMWORD PTR [rbp-0x20],xmm0
    const tmp = a.*;
  21f890:	c5 f8 10 03          	vmovups xmm0,XMMWORD PTR [rbx]
  21f894:	c5 f8 29 44 24 d8    	vmovaps XMMWORD PTR [rsp-0x28],xmm0
    a.* = b.*;
  21f89a:	c5 f8 10 45 d0       	vmovups xmm0,XMMWORD PTR [rbp-0x30]
  21f89f:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
    b.* = tmp;
  21f8a3:	c5 f8 28 44 24 d8    	vmovaps xmm0,XMMWORD PTR [rsp-0x28]
  21f8a9:	c5 f8 11 45 d0       	vmovups XMMWORD PTR [rbp-0x30],xmm0
    while (i < end) : (i += 1) {
  21f8ae:	48 83 c0 04          	add    rax,0x4
  21f8b2:	48 83 c5 c0          	add    rbp,0xffffffffffffffc0
  21f8b6:	48 83 c3 40          	add    rbx,0x40
  21f8ba:	48 39 c1             	cmp    rcx,rax
  21f8bd:	0f 85 6d ff ff ff    	jne    21f830 <mergeInPlace+0x3f0>
  21f8c3:	48 85 f6             	test   rsi,rsi
  21f8c6:	74 58                	je     21f920 <mergeInPlace+0x4e0>
  21f8c8:	4c 89 e1             	mov    rcx,r12
  21f8cb:	48 29 c1             	sub    rcx,rax
  21f8ce:	48 c1 e1 04          	shl    rcx,0x4
  21f8d2:	48 01 d1             	add    rcx,rdx
  21f8d5:	48 83 c1 f0          	add    rcx,0xfffffffffffffff0
  21f8d9:	4c 01 f8             	add    rax,r15
  21f8dc:	48 c1 e0 04          	shl    rax,0x4
  21f8e0:	48 01 d0             	add    rax,rdx
  21f8e3:	48 f7 de             	neg    rsi
  21f8e6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  21f8ed:	00 00 00 
    const tmp = a.*;
  21f8f0:	c5 f8 10 00          	vmovups xmm0,XMMWORD PTR [rax]
  21f8f4:	c5 f8 29 44 24 d8    	vmovaps XMMWORD PTR [rsp-0x28],xmm0
    a.* = b.*;
  21f8fa:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  21f8fe:	c5 f8 11 00          	vmovups XMMWORD PTR [rax],xmm0
    b.* = tmp;
  21f902:	c5 f8 28 44 24 d8    	vmovaps xmm0,XMMWORD PTR [rsp-0x28]
  21f908:	c5 f8 11 01          	vmovups XMMWORD PTR [rcx],xmm0
    while (i < end) : (i += 1) {
  21f90c:	48 83 c1 f0          	add    rcx,0xfffffffffffffff0
  21f910:	48 83 c0 10          	add    rax,0x10
  21f914:	48 83 c6 01          	add    rsi,0x1
  21f918:	75 d6                	jne    21f8f0 <mergeInPlace+0x4b0>
  21f91a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
        if (B.end == mid) break;
  21f920:	4d 39 e1             	cmp    r9,r12
  21f923:	0f 84 ac 00 00 00    	je     21f9d5 <mergeInPlace+0x595>
        const amount = mid - A.end;
  21f929:	4c 89 e0             	mov    rax,r12
  21f92c:	4c 29 f0             	sub    rax,r14
        A = Range.init(A.start + amount, B.start);
  21f92f:	4c 01 f8             	add    rax,r15
        A.start = binaryLast(T, items, items[A.start], A, lessThan);
  21f932:	48 8b 4c 24 f0       	mov    rcx,QWORD PTR [rsp-0x10]
  21f937:	48 8b 11             	mov    rdx,QWORD PTR [rcx]
  21f93a:	4d 89 e7             	mov    r15,r12
    if (range.start >= range.end) return range.end;
  21f93d:	4c 39 e0             	cmp    rax,r12
  21f940:	0f 83 80 00 00 00    	jae    21f9c6 <mergeInPlace+0x586>
  21f946:	49 89 c2             	mov    r10,rax
  21f949:	49 c1 e2 04          	shl    r10,0x4
  21f94d:	49 01 d2             	add    r10,rdx
    var end = range.end - 1;
  21f950:	4d 8d 44 24 ff       	lea    r8,[r12-0x1]
    while (start < end) {
  21f955:	49 39 c0             	cmp    r8,rax
  21f958:	76 3e                	jbe    21f998 <mergeInPlace+0x558>
  21f95a:	49 8b 2a             	mov    rbp,QWORD PTR [r10]
  21f95d:	4c 89 c7             	mov    rdi,r8
        const mid = start + (end - start) / 2;
  21f960:	48 89 fb             	mov    rbx,rdi
  21f963:	48 29 c3             	sub    rbx,rax
  21f966:	48 d1 eb             	shr    rbx,1
  21f969:	48 8d 0c 03          	lea    rcx,[rbx+rax*1]
  21f96d:	48 89 ce             	mov    rsi,rcx
  21f970:	48 c1 e6 04          	shl    rsi,0x4
  21f974:	48 3b 2c 32          	cmp    rbp,QWORD PTR [rdx+rsi*1]
        if (!lessThan(value, items[mid])) {
  21f978:	72 16                	jb     21f990 <mergeInPlace+0x550>
  21f97a:	48 01 d8             	add    rax,rbx
  21f97d:	48 83 c0 01          	add    rax,0x1
    while (start < end) {
  21f981:	48 39 c7             	cmp    rdi,rax
  21f984:	77 da                	ja     21f960 <mergeInPlace+0x520>
  21f986:	eb 10                	jmp    21f998 <mergeInPlace+0x558>
  21f988:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  21f98f:	00 
        if (!lessThan(value, items[mid])) {
  21f990:	48 89 cf             	mov    rdi,rcx
    while (start < end) {
  21f993:	48 39 c7             	cmp    rdi,rax
  21f996:	77 c8                	ja     21f960 <mergeInPlace+0x520>
    if (start == range.end - 1 and !lessThan(value, items[start])) {
  21f998:	4c 39 c0             	cmp    rax,r8
  21f99b:	75 23                	jne    21f9c0 <mergeInPlace+0x580>
  21f99d:	49 8b 0a             	mov    rcx,QWORD PTR [r10]
  21f9a0:	49 c1 e0 04          	shl    r8,0x4
  21f9a4:	45 31 ff             	xor    r15d,r15d
  21f9a7:	4a 3b 0c 02          	cmp    rcx,QWORD PTR [rdx+r8*1]
  21f9ab:	41 0f 93 c7          	setae  r15b
  21f9af:	eb 12                	jmp    21f9c3 <mergeInPlace+0x583>
  21f9b1:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21f9b8:	0f 1f 84 00 00 00 00 
  21f9bf:	00 
  21f9c0:	45 31 ff             	xor    r15d,r15d
  21f9c3:	49 01 c7             	add    r15,rax
  21f9c6:	4d 89 e6             	mov    r14,r12
  21f9c9:	4c 89 e1             	mov    rcx,r12
        if (A.length() == 0) break;
  21f9cc:	4d 39 fc             	cmp    r12,r15
  21f9cf:	0f 85 ab fa ff ff    	jne    21f480 <mergeInPlace+0x40>
    if (A_arg.length() == 0 or B_arg.length() == 0) return;
  21f9d5:	5b                   	pop    rbx
  21f9d6:	41 5c                	pop    r12
  21f9d8:	41 5d                	pop    r13
  21f9da:	41 5e                	pop    r14
  21f9dc:	41 5f                	pop    r15
  21f9de:	5d                   	pop    rbp
  21f9df:	c3                   	ret    

000000000021f9e0 <FileOutStream_writeFn>:
    fn writeFn(out_stream: *Stream, bytes: []const u8) !void {
  21f9e0:	53                   	push   rbx
  21f9e1:	49 89 f0             	mov    r8,rsi
    while (index < bytes.len) {
  21f9e4:	49 8b 50 08          	mov    rdx,QWORD PTR [r8+0x8]
  21f9e8:	48 85 d2             	test   rdx,rdx
  21f9eb:	0f 84 98 00 00 00    	je     21fa89 <FileOutStream_writeFn+0xa9>
        return self.file.write(bytes);
  21f9f1:	48 8b 47 f8          	mov    rax,QWORD PTR [rdi-0x8]
  21f9f5:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  21f9f8:	45 31 c9             	xor    r9d,r9d
  21f9fb:	41 ba 00 f0 ff 7f    	mov    r10d,0x7ffff000
  21fa01:	48 8d 1d 1c 0a fe ff 	lea    rbx,[rip+0xfffffffffffe0a1c]        # 200424 <__unnamed_609+0xe4>
  21fa08:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  21fa0f:	00 
        const amt_to_write = math.min(bytes.len - index, usize(max_bytes_len));
  21fa10:	4c 29 ca             	sub    rdx,r9
    return if (x < y) x else y;
  21fa13:	48 81 fa 00 f0 ff 7f 	cmp    rdx,0x7ffff000
  21fa1a:	49 0f 43 d2          	cmovae rdx,r10
  21fa1e:	49 8b 30             	mov    rsi,QWORD PTR [r8]
        const rc = posix.write(fd, bytes.ptr + index, amt_to_write);
  21fa21:	4c 01 ce             	add    rsi,r9
  21fa24:	b8 01 00 00 00       	mov    eax,0x1
  21fa29:	0f 05                	syscall 
  21fa2b:	48 89 c1             	mov    rcx,rax
  21fa2e:	48 81 f9 00 f0 ff ff 	cmp    rcx,0xfffffffffffff000
  21fa35:	77 39                	ja     21fa70 <FileOutStream_writeFn+0x90>
  21fa37:	31 d2                	xor    edx,edx
        if (write_err > 0) {
  21fa39:	48 83 fa 04          	cmp    rdx,0x4
  21fa3d:	74 3d                	je     21fa7c <FileOutStream_writeFn+0x9c>
  21fa3f:	48 83 fa 59          	cmp    rdx,0x59
  21fa43:	77 48                	ja     21fa8d <FileOutStream_writeFn+0xad>
  21fa45:	66 b8 0f 00          	mov    ax,0xf
  21fa49:	48 63 14 93          	movsxd rdx,DWORD PTR [rbx+rdx*4]
  21fa4d:	48 01 da             	add    rdx,rbx
  21fa50:	ff e2                	jmp    rdx
        index += rc;
  21fa52:	49 01 c9             	add    r9,rcx
    while (index < bytes.len) {
  21fa55:	49 8b 50 08          	mov    rdx,QWORD PTR [r8+0x8]
  21fa59:	31 c0                	xor    eax,eax
  21fa5b:	4c 39 ca             	cmp    rdx,r9
  21fa5e:	77 b0                	ja     21fa10 <FileOutStream_writeFn+0x30>
  21fa60:	eb 25                	jmp    21fa87 <FileOutStream_writeFn+0xa7>
  21fa62:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21fa69:	1f 84 00 00 00 00 00 
  21fa70:	48 89 ca             	mov    rdx,rcx
  21fa73:	48 f7 da             	neg    rdx
        if (write_err > 0) {
  21fa76:	48 83 fa 04          	cmp    rdx,0x4
  21fa7a:	75 c3                	jne    21fa3f <FileOutStream_writeFn+0x5f>
    while (index < bytes.len) {
  21fa7c:	49 8b 50 08          	mov    rdx,QWORD PTR [r8+0x8]
  21fa80:	4c 39 ca             	cmp    rdx,r9
  21fa83:	77 8b                	ja     21fa10 <FileOutStream_writeFn+0x30>
  21fa85:	31 c0                	xor    eax,eax
  21fa87:	5b                   	pop    rbx
  21fa88:	c3                   	ret    
  21fa89:	31 c0                	xor    eax,eax
  21fa8b:	5b                   	pop    rbx
  21fa8c:	c3                   	ret    
        if (write_err > 0) {
  21fa8d:	48 83 fa 7a          	cmp    rdx,0x7a
  21fa91:	75 06                	jne    21fa99 <FileOutStream_writeFn+0xb9>
  21fa93:	66 b8 12 00          	mov    ax,0x12
  21fa97:	5b                   	pop    rbx
  21fa98:	c3                   	ret    
  21fa99:	66 b8 03 00          	mov    ax,0x3
  21fa9d:	5b                   	pop    rbx
  21fa9e:	c3                   	ret    
  21fa9f:	66 b8 16 00          	mov    ax,0x16
  21faa3:	5b                   	pop    rbx
  21faa4:	c3                   	ret    
  21faa5:	66 b8 14 00          	mov    ax,0x14
  21faa9:	5b                   	pop    rbx
  21faaa:	c3                   	ret    
  21faab:	66 b8 10 00          	mov    ax,0x10
  21faaf:	5b                   	pop    rbx
  21fab0:	c3                   	ret    
  21fab1:	66 b8 13 00          	mov    ax,0x13
  21fab5:	5b                   	pop    rbx
  21fab6:	c3                   	ret    
  21fab7:	66 b8 15 00          	mov    ax,0x15
  21fabb:	5b                   	pop    rbx
  21fabc:	c3                   	ret    
  21fabd:	66 b8 0e 00          	mov    ax,0xe
  21fac1:	5b                   	pop    rbx
  21fac2:	c3                   	ret    
  21fac3:	66 b8 11 00          	mov    ax,0x11
  21fac7:	5b                   	pop    rbx
  21fac8:	c3                   	ret    
  21fac9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

000000000021fad0 <openSelfDebugInfo>:
            return Self{
  21fad0:	55                   	push   rbp
  21fad1:	41 57                	push   r15
  21fad3:	41 56                	push   r14
  21fad5:	41 55                	push   r13
  21fad7:	41 54                	push   r12
  21fad9:	53                   	push   rbx
  21fada:	48 81 ec e8 05 00 00 	sub    rsp,0x5e8
  21fae1:	c5 f8 57 c0          	vxorps xmm0,xmm0,xmm0
  21fae5:	c5 f8 29 84 24 30 04 	vmovaps XMMWORD PTR [rsp+0x430],xmm0
  21faec:	00 00 
  21faee:	c5 f8 29 84 24 10 04 	vmovaps XMMWORD PTR [rsp+0x410],xmm0
  21faf5:	00 00 
  21faf7:	49 89 f4             	mov    r12,rsi
  21fafa:	49 89 fe             	mov    r14,rdi
            const st = try allocator.create(ElfStackTrace{
  21fafd:	c5 fc 10 05 7b 7b fe 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffe7b7b]        # 207680 <__unnamed_54>
  21fb04:	ff 
  21fb05:	c5 fc 11 84 24 70 05 	vmovups YMMWORD PTR [rsp+0x570],ymm0
  21fb0c:	00 00 
  21fb0e:	48 c7 84 24 40 04 00 	mov    QWORD PTR [rsp+0x440],0x0
  21fb15:	00 00 00 00 00 
  21fb1a:	c5 fc 10 05 7e 7b fe 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffe7b7e]        # 2076a0 <__unnamed_54+0x20>
  21fb21:	ff 
  21fb22:	c5 fc 11 84 24 90 05 	vmovups YMMWORD PTR [rsp+0x590],ymm0
  21fb29:	00 00 
  21fb2b:	48 c7 84 24 20 04 00 	mov    QWORD PTR [rsp+0x420],0x0
  21fb32:	00 00 00 00 00 
  21fb37:	c5 fe 6f 05 79 7b fe 	vmovdqu ymm0,YMMWORD PTR [rip+0xfffffffffffe7b79]        # 2076b8 <__unnamed_54+0x38>
  21fb3e:	ff 
  21fb3f:	c5 fe 7f 84 24 a8 05 	vmovdqu YMMWORD PTR [rsp+0x5a8],ymm0
  21fb46:	00 00 
  21fb48:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  21fb4f:	00 
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  21fb50:	ba c8 00 00 00       	mov    edx,0xc8
  21fb55:	b9 04 00 00 00       	mov    ecx,0x4
  21fb5a:	c5 f8 77             	vzeroupper 
  21fb5d:	41 ff 14 24          	call   QWORD PTR [r12]
  21fb61:	0f b7 84 24 f0 00 00 	movzx  eax,WORD PTR [rsp+0xf0]
  21fb68:	00 
  21fb69:	66 85 c0             	test   ax,ax
  21fb6c:	74 19                	je     21fb87 <openSelfDebugInfo+0xb7>
  21fb6e:	66 41 89 06          	mov    WORD PTR [r14],ax
  21fb72:	48 8b 84 24 12 05 00 	mov    rax,QWORD PTR [rsp+0x512]
  21fb79:	00 
  21fb7a:	48 8b 8c 24 18 05 00 	mov    rcx,QWORD PTR [rsp+0x518]
  21fb81:	00 
  21fb82:	e9 60 0c 00 00       	jmp    2207e7 <openSelfDebugInfo+0xd17>
        assert(byte_slice.len == byte_count);
  21fb87:	48 81 bc 24 00 01 00 	cmp    QWORD PTR [rsp+0x100],0xc8
  21fb8e:	00 c8 00 00 00 
    if (!ok) {
  21fb93:	0f 85 9b 3f 00 00    	jne    223b34 <openSelfDebugInfo+0x4064>
  21fb99:	48 8b ac 24 f8 00 00 	mov    rbp,QWORD PTR [rsp+0xf8]
  21fba0:	00 
        ptr.* = init;
  21fba1:	c5 fc 10 84 24 68 05 	vmovups ymm0,YMMWORD PTR [rsp+0x568]
  21fba8:	00 00 
  21fbaa:	c5 fe 6f 8c 24 88 05 	vmovdqu ymm1,YMMWORD PTR [rsp+0x588]
  21fbb1:	00 00 
  21fbb3:	c5 fe 6f 94 24 a8 05 	vmovdqu ymm2,YMMWORD PTR [rsp+0x5a8]
  21fbba:	00 00 
  21fbbc:	c5 fe 6f 9c 24 c8 05 	vmovdqu ymm3,YMMWORD PTR [rsp+0x5c8]
  21fbc3:	00 00 
  21fbc5:	c5 fe 7f 5d 60       	vmovdqu YMMWORD PTR [rbp+0x60],ymm3
  21fbca:	c5 fe 7f 55 40       	vmovdqu YMMWORD PTR [rbp+0x40],ymm2
  21fbcf:	c5 fe 7f 4d 20       	vmovdqu YMMWORD PTR [rbp+0x20],ymm1
  21fbd4:	c5 fc 11 45 00       	vmovups YMMWORD PTR [rbp+0x0],ymm0
  21fbd9:	48 c7 85 80 00 00 00 	mov    QWORD PTR [rbp+0x80],0x0
  21fbe0:	00 00 00 00 
  21fbe4:	48 8b 84 24 40 04 00 	mov    rax,QWORD PTR [rsp+0x440]
  21fbeb:	00 
  21fbec:	48 89 85 98 00 00 00 	mov    QWORD PTR [rbp+0x98],rax
  21fbf3:	c5 f8 28 84 24 30 04 	vmovaps xmm0,XMMWORD PTR [rsp+0x430]
  21fbfa:	00 00 
  21fbfc:	c5 f8 11 85 88 00 00 	vmovups XMMWORD PTR [rbp+0x88],xmm0
  21fc03:	00 
  21fc04:	4c 89 a5 a0 00 00 00 	mov    QWORD PTR [rbp+0xa0],r12
  21fc0b:	48 8b 84 24 20 04 00 	mov    rax,QWORD PTR [rsp+0x420]
  21fc12:	00 
  21fc13:	48 89 85 b8 00 00 00 	mov    QWORD PTR [rbp+0xb8],rax
  21fc1a:	c5 f9 6f 84 24 10 04 	vmovdqa xmm0,XMMWORD PTR [rsp+0x410]
  21fc21:	00 00 
  21fc23:	c5 fa 7f 85 a8 00 00 	vmovdqu XMMWORD PTR [rbp+0xa8],xmm0
  21fc2a:	00 
  21fc2b:	4c 89 a5 c0 00 00 00 	mov    QWORD PTR [rbp+0xc0],r12
    return error.Unexpected;
}

pub fn openSelfExe() !os.File {
    switch (builtin.os) {
        Os.linux => return os.File.openReadC(c"/proc/self/exe"),
  21fc32:	48 8d 35 a7 9a fe ff 	lea    rsi,[rip+0xfffffffffffe9aa7]        # 2096e0 <__unnamed_55>
  21fc39:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  21fc40:	00 
  21fc41:	c5 f8 77             	vzeroupper 
  21fc44:	e8 57 4d 00 00       	call   2249a0 <File_openReadC>
  21fc49:	48 8b 9c 24 f0 00 00 	mov    rbx,QWORD PTR [rsp+0xf0]
  21fc50:	00 
            st.self_exe_file = try os.openSelfExe();
  21fc51:	66 85 db             	test   bx,bx
  21fc54:	74 3f                	je     21fc95 <openSelfDebugInfo+0x1c5>
        self.freeFn(self, non_const_ptr[0..@sizeOf(@typeOf(ptr).Child)]);
  21fc56:	49 8b 44 24 10       	mov    rax,QWORD PTR [r12+0x10]
  21fc5b:	48 89 ac 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rbp
  21fc62:	00 
  21fc63:	48 c7 84 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],0xc8
  21fc6a:	00 c8 00 00 00 
  21fc6f:	48 8d b4 24 f0 00 00 	lea    rsi,[rsp+0xf0]
  21fc76:	00 
  21fc77:	4c 89 e7             	mov    rdi,r12
  21fc7a:	ff d0                	call   rax
  21fc7c:	66 41 89 1e          	mov    WORD PTR [r14],bx
  21fc80:	48 8b 84 24 04 05 00 	mov    rax,QWORD PTR [rsp+0x504]
  21fc87:	00 
  21fc88:	48 8b 8c 24 0a 05 00 	mov    rcx,QWORD PTR [rsp+0x50a]
  21fc8f:	00 
  21fc90:	e9 52 0b 00 00       	jmp    2207e7 <openSelfDebugInfo+0xd17>
  21fc95:	48 c1 eb 20          	shr    rbx,0x20
  21fc99:	89 5d 00             	mov    DWORD PTR [rbp+0x0],ebx
            try st.elf.openFile(allocator, &st.self_exe_file);
  21fc9c:	4c 8d 7d 08          	lea    r15,[rbp+0x8]
        elf.auto_close_stream = true;
    }

    /// Call close when done.
    pub fn openFile(elf: *Elf, allocator: *mem.Allocator, file: *os.File) !void {
        elf.allocator = allocator;
  21fca0:	4c 89 65 50          	mov    QWORD PTR [rbp+0x50],r12
        elf.in_file = file;
  21fca4:	48 89 6d 08          	mov    QWORD PTR [rbp+0x8],rbp
        elf.auto_close_stream = false;
  21fca8:	c6 45 10 00          	mov    BYTE PTR [rbp+0x10],0x0

        var file_stream = io.FileInStream.init(elf.in_file);
  21fcac:	48 89 6c 24 50       	mov    QWORD PTR [rsp+0x50],rbp
  21fcb1:	48 8d 05 18 50 00 00 	lea    rax,[rip+0x5018]        # 224cd0 <FileInStream_readFn>
  21fcb8:	48 89 44 24 58       	mov    QWORD PTR [rsp+0x58],rax
  21fcbd:	48 8d 84 24 70 02 00 	lea    rax,[rsp+0x270]
  21fcc4:	00 
        const in = &file_stream.stream;

        var magic: [4]u8 = undefined;
        try in.readNoEof(magic[0..]);
  21fcc5:	48 89 84 24 d8 03 00 	mov    QWORD PTR [rsp+0x3d8],rax
  21fccc:	00 
  21fccd:	48 c7 84 24 e0 03 00 	mov    QWORD PTR [rsp+0x3e0],0x4
  21fcd4:	00 04 00 00 00 
        return self.file.read(buffer);
  21fcd9:	48 8b 74 24 50       	mov    rsi,QWORD PTR [rsp+0x50]
  21fcde:	48 8d 9c 24 f0 00 00 	lea    rbx,[rsp+0xf0]
  21fce5:	00 
  21fce6:	48 8d 94 24 d8 03 00 	lea    rdx,[rsp+0x3d8]
  21fced:	00 
  21fcee:	48 89 df             	mov    rdi,rbx
  21fcf1:	e8 aa 4e 00 00       	call   224ba0 <File_read>
  21fcf6:	44 0f b7 ac 24 f0 00 	movzx  r13d,WORD PTR [rsp+0xf0]
  21fcfd:	00 00 
            const amt_read = try self.read(buf);
  21fcff:	66 45 85 ed          	test   r13w,r13w
  21fd03:	75 17                	jne    21fd1c <openSelfDebugInfo+0x24c>
  21fd05:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  21fd0c:	00 
  21fd0d:	66 41 bd 25 00       	mov    r13w,0x25
            if (amt_read < buf.len) return error.EndOfStream;
  21fd12:	48 3b 84 24 e0 03 00 	cmp    rax,QWORD PTR [rsp+0x3e0]
  21fd19:	00 
  21fd1a:	73 4e                	jae    21fd6a <openSelfDebugInfo+0x29a>
  21fd1c:	66 45 85 ed          	test   r13w,r13w
  21fd20:	0f 84 ec 06 00 00    	je     220412 <openSelfDebugInfo+0x942>
  21fd26:	48 63 7d 00          	movsxd rdi,DWORD PTR [rbp+0x0]
  21fd2a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
    return asm volatile ("syscall"
  21fd30:	b8 03 00 00 00       	mov    eax,0x3
  21fd35:	0f 05                	syscall 
            switch (err) {
  21fd37:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  21fd3b:	74 f3                	je     21fd30 <openSelfDebugInfo+0x260>
        /// Remove and return the first node in the list.
        ///
        /// Returns:
        ///     A pointer to the first node in the list.
        pub fn popFirst(list: *Self) ?*Node {
            const first = list.first orelse return null;
  21fd3d:	48 8b 05 e4 02 03 00 	mov    rax,QWORD PTR [rip+0x302e4]        # 250028 <emfile_promise_queue>
  21fd44:	48 85 c0             	test   rax,rax
  21fd47:	0f 84 3b 01 00 00    	je     21fe88 <openSelfDebugInfo+0x3b8>
            if (node.prev) |prev_node| {
  21fd4d:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  21fd50:	48 85 c9             	test   rcx,rcx
  21fd53:	0f 84 c4 00 00 00    	je     21fe1d <openSelfDebugInfo+0x34d>
                prev_node.next = node.next;
  21fd59:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  21fd5d:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  21fd61:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  21fd65:	e9 be 00 00 00       	jmp    21fe28 <openSelfDebugInfo+0x358>
        if (b[index] != item) return false;
  21fd6a:	80 bc 24 70 02 00 00 	cmp    BYTE PTR [rsp+0x270],0x7f
  21fd71:	7f 
  21fd72:	0f 85 8b 06 00 00    	jne    220403 <openSelfDebugInfo+0x933>
  21fd78:	80 bc 24 71 02 00 00 	cmp    BYTE PTR [rsp+0x271],0x45
  21fd7f:	45 
  21fd80:	0f 85 7d 06 00 00    	jne    220403 <openSelfDebugInfo+0x933>
  21fd86:	80 bc 24 72 02 00 00 	cmp    BYTE PTR [rsp+0x272],0x4c
  21fd8d:	4c 
  21fd8e:	0f 85 6f 06 00 00    	jne    220403 <openSelfDebugInfo+0x933>
  21fd94:	80 bc 24 73 02 00 00 	cmp    BYTE PTR [rsp+0x273],0x46
  21fd9b:	46 
  21fd9c:	0f 85 28 01 00 00    	jne    21feca <openSelfDebugInfo+0x3fa>
  21fda2:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  21fda7:	48 8d 44 24 1f       	lea    rax,[rsp+0x1f]
            try self.readNoEof(result[0..]);
  21fdac:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  21fdb3:	00 
  21fdb4:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x1
  21fdbb:	00 01 00 00 00 
  21fdc0:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  21fdc7:	00 
  21fdc8:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  21fdcf:	00 
            return self.readFn(self, buffer);
  21fdd0:	ff 54 24 58          	call   QWORD PTR [rsp+0x58]
  21fdd4:	44 0f b7 ac 24 f0 00 	movzx  r13d,WORD PTR [rsp+0xf0]
  21fddb:	00 00 
            const amt_read = try self.read(buf);
  21fddd:	66 45 85 ed          	test   r13w,r13w
  21fde1:	0f 85 35 ff ff ff    	jne    21fd1c <openSelfDebugInfo+0x24c>
  21fde7:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  21fdee:	00 
  21fdef:	66 41 bd 25 00       	mov    r13w,0x25
            if (amt_read < buf.len) return error.EndOfStream;
  21fdf4:	48 3b 84 24 a0 00 00 	cmp    rax,QWORD PTR [rsp+0xa0]
  21fdfb:	00 
  21fdfc:	0f 82 1a ff ff ff    	jb     21fd1c <openSelfDebugInfo+0x24c>
            return result[0];
  21fe02:	8a 44 24 1f          	mov    al,BYTE PTR [rsp+0x1f]
        if (!mem.eql(u8, magic, "\x7fELF")) return error.InvalidFormat;

        elf.is_64 = switch (try in.readByte()) {
  21fe06:	3c 01                	cmp    al,0x1
  21fe08:	0f 84 d0 00 00 00    	je     21fede <openSelfDebugInfo+0x40e>
  21fe0e:	3c 02                	cmp    al,0x2
  21fe10:	0f 85 ed 05 00 00    	jne    220403 <openSelfDebugInfo+0x933>
  21fe16:	b0 01                	mov    al,0x1
  21fe18:	e9 c3 00 00 00       	jmp    21fee0 <openSelfDebugInfo+0x410>
                list.first = node.next;
  21fe1d:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  21fe21:	48 89 0d 00 02 03 00 	mov    QWORD PTR [rip+0x30200],rcx        # 250028 <emfile_promise_queue>
            if (node.next) |next_node| {
  21fe28:	48 85 c9             	test   rcx,rcx
  21fe2b:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  21fe2e:	48 8d 35 fb 01 03 00 	lea    rsi,[rip+0x301fb]        # 250030 <emfile_promise_queue+0x8>
  21fe35:	48 0f 45 f1          	cmovne rsi,rcx
  21fe39:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  21fe3c:	48 83 05 f4 01 03 00 	add    QWORD PTR [rip+0x301f4],0xffffffffffffffff        # 250038 <emfile_promise_queue+0x10>
  21fe43:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  21fe44:	74 1e                	je     21fe64 <openSelfDebugInfo+0x394>
  21fe46:	48 83 3d da 01 03 00 	cmp    QWORD PTR [rip+0x301da],0x0        # 250028 <emfile_promise_queue>
  21fe4d:	00 
  21fe4e:	0f 84 e0 3c 00 00    	je     223b34 <openSelfDebugInfo+0x4064>
  21fe54:	48 8b 0d d5 01 03 00 	mov    rcx,QWORD PTR [rip+0x301d5]        # 250030 <emfile_promise_queue+0x8>
  21fe5b:	48 85 c9             	test   rcx,rcx
  21fe5e:	0f 84 d0 3c 00 00    	je     223b34 <openSelfDebugInfo+0x4064>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  21fe64:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  21fe68:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  21fe6c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  21fe70:	48 89 c1             	mov    rcx,rax
  21fe73:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  21fe77:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  21fe7d:	75 f1                	jne    21fe70 <openSelfDebugInfo+0x3a0>
  21fe7f:	a8 01                	test   al,0x1
  21fe81:	75 05                	jne    21fe88 <openSelfDebugInfo+0x3b8>
  21fe83:	c5 f8 77             	vzeroupper 
  21fe86:	ff 17                	call   QWORD PTR [rdi]
        self.freeFn(self, non_const_ptr[0..@sizeOf(@typeOf(ptr).Child)]);
  21fe88:	49 8b 44 24 10       	mov    rax,QWORD PTR [r12+0x10]
  21fe8d:	48 89 ac 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rbp
  21fe94:	00 
  21fe95:	48 c7 84 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],0xc8
  21fe9c:	00 c8 00 00 00 
  21fea1:	48 8d b4 24 f0 00 00 	lea    rsi,[rsp+0xf0]
  21fea8:	00 
  21fea9:	4c 89 e7             	mov    rdi,r12
  21feac:	c5 f8 77             	vzeroupper 
  21feaf:	ff d0                	call   rax
  21feb1:	66 45 89 2e          	mov    WORD PTR [r14],r13w
  21feb5:	48 8b 84 24 f6 04 00 	mov    rax,QWORD PTR [rsp+0x4f6]
  21febc:	00 
  21febd:	48 8b 8c 24 fc 04 00 	mov    rcx,QWORD PTR [rsp+0x4fc]
  21fec4:	00 
  21fec5:	e9 1d 09 00 00       	jmp    2207e7 <openSelfDebugInfo+0xd17>
  21feca:	66 41 bd 26 00       	mov    r13w,0x26
  21fecf:	66 45 85 ed          	test   r13w,r13w
  21fed3:	0f 85 4d fe ff ff    	jne    21fd26 <openSelfDebugInfo+0x256>
  21fed9:	e9 34 05 00 00       	jmp    220412 <openSelfDebugInfo+0x942>
  21fede:	31 c0                	xor    eax,eax
  21fee0:	88 45 11             	mov    BYTE PTR [rbp+0x11],al
            try self.readNoEof(result[0..]);
  21fee3:	48 8d 44 24 1f       	lea    rax,[rsp+0x1f]
  21fee8:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  21feef:	00 
  21fef0:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x1
  21fef7:	00 01 00 00 00 
  21fefc:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  21ff03:	00 
  21ff04:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  21ff0b:	00 
            return self.readFn(self, buffer);
  21ff0c:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  21ff11:	ff 54 24 58          	call   QWORD PTR [rsp+0x58]
  21ff15:	44 0f b7 ac 24 f0 00 	movzx  r13d,WORD PTR [rsp+0xf0]
  21ff1c:	00 00 
            const amt_read = try self.read(buf);
  21ff1e:	66 45 85 ed          	test   r13w,r13w
  21ff22:	0f 85 f4 fd ff ff    	jne    21fd1c <openSelfDebugInfo+0x24c>
  21ff28:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  21ff2f:	00 
  21ff30:	66 41 bd 25 00       	mov    r13w,0x25
            if (amt_read < buf.len) return error.EndOfStream;
  21ff35:	48 3b 84 24 a0 00 00 	cmp    rax,QWORD PTR [rsp+0xa0]
  21ff3c:	00 
  21ff3d:	0f 82 d9 fd ff ff    	jb     21fd1c <openSelfDebugInfo+0x24c>
            return result[0];
  21ff43:	8a 44 24 1f          	mov    al,BYTE PTR [rsp+0x1f]
            1 => false,
            2 => true,
            else => return error.InvalidFormat,
        };

        elf.endian = switch (try in.readByte()) {
  21ff47:	3c 01                	cmp    al,0x1
  21ff49:	74 0c                	je     21ff57 <openSelfDebugInfo+0x487>
  21ff4b:	3c 02                	cmp    al,0x2
  21ff4d:	0f 85 b0 04 00 00    	jne    220403 <openSelfDebugInfo+0x933>
  21ff53:	31 c0                	xor    eax,eax
  21ff55:	eb 02                	jmp    21ff59 <openSelfDebugInfo+0x489>
  21ff57:	b0 01                	mov    al,0x1
  21ff59:	48 8d 4d 12          	lea    rcx,[rbp+0x12]
  21ff5d:	48 89 4c 24 68       	mov    QWORD PTR [rsp+0x68],rcx
  21ff62:	88 01                	mov    BYTE PTR [rcx],al
            try self.readNoEof(result[0..]);
  21ff64:	48 8d 44 24 1f       	lea    rax,[rsp+0x1f]
  21ff69:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  21ff70:	00 
  21ff71:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x1
  21ff78:	00 01 00 00 00 
  21ff7d:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  21ff84:	00 
  21ff85:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  21ff8c:	00 
            return self.readFn(self, buffer);
  21ff8d:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  21ff92:	ff 54 24 58          	call   QWORD PTR [rsp+0x58]
  21ff96:	44 0f b7 ac 24 f0 00 	movzx  r13d,WORD PTR [rsp+0xf0]
  21ff9d:	00 00 
            const amt_read = try self.read(buf);
  21ff9f:	66 45 85 ed          	test   r13w,r13w
  21ffa3:	0f 85 73 fd ff ff    	jne    21fd1c <openSelfDebugInfo+0x24c>
  21ffa9:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  21ffb0:	00 
  21ffb1:	66 41 bd 25 00       	mov    r13w,0x25
            if (amt_read < buf.len) return error.EndOfStream;
  21ffb6:	48 3b 84 24 a0 00 00 	cmp    rax,QWORD PTR [rsp+0xa0]
  21ffbd:	00 
  21ffbe:	0f 82 58 fd ff ff    	jb     21fd1c <openSelfDebugInfo+0x24c>
            2 => builtin.Endian.Big,
            else => return error.InvalidFormat,
        };

        const version_byte = try in.readByte();
        if (version_byte != 1) return error.InvalidFormat;
  21ffc4:	80 7c 24 1f 01       	cmp    BYTE PTR [rsp+0x1f],0x1
  21ffc9:	0f 85 34 04 00 00    	jne    220403 <openSelfDebugInfo+0x933>

        // skip over padding
        try elf.in_file.seekForward(9);
  21ffcf:	49 8b 07             	mov    rax,QWORD PTR [r15]
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  21ffd2:	48 63 38             	movsxd rdi,DWORD PTR [rax]
    return asm volatile ("syscall"
  21ffd5:	b8 08 00 00 00       	mov    eax,0x8
  21ffda:	be 09 00 00 00       	mov    esi,0x9
  21ffdf:	ba 01 00 00 00       	mov    edx,0x1
  21ffe4:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  21ffe6:	48 89 c2             	mov    rdx,rax
  21ffe9:	48 f7 da             	neg    rdx
  21ffec:	31 c9                	xor    ecx,ecx
  21ffee:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  21fff4:	48 0f 47 ca          	cmova  rcx,rdx
                if (err > 0) {
  21fff8:	48 83 f9 1d          	cmp    rcx,0x1d
  21fffc:	0f 87 1e 3b 00 00    	ja     223b20 <openSelfDebugInfo+0x4050>
  220002:	48 8d 05 83 05 fe ff 	lea    rax,[rip+0xfffffffffffe0583]        # 20058c <__unnamed_609+0x24c>
  220009:	48 63 0c 88          	movsxd rcx,DWORD PTR [rax+rcx*4]
  22000d:	48 01 c1             	add    rcx,rax
  220010:	66 41 bd 03 00       	mov    r13w,0x3
  220015:	ff e1                	jmp    rcx
  220017:	66 41 bd 27 00       	mov    r13w,0x27
  22001c:	66 45 85 ed          	test   r13w,r13w
  220020:	0f 85 00 fd ff ff    	jne    21fd26 <openSelfDebugInfo+0x256>
  220026:	e9 e7 03 00 00       	jmp    220412 <openSelfDebugInfo+0x942>

        elf.file_type = switch (try in.readInt(elf.endian, u16)) {
  22002b:	8a 45 12             	mov    al,BYTE PTR [rbp+0x12]
  22002e:	88 44 24 40          	mov    BYTE PTR [rsp+0x40],al
  220032:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
            try self.readNoEof(bytes[0..]);
  220037:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  22003e:	00 
  22003f:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x2
  220046:	00 02 00 00 00 
  22004b:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  220052:	00 
  220053:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  22005a:	00 
            return self.readFn(self, buffer);
  22005b:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  220060:	ff 54 24 58          	call   QWORD PTR [rsp+0x58]
  220064:	44 0f b7 ac 24 f0 00 	movzx  r13d,WORD PTR [rsp+0xf0]
  22006b:	00 00 
            const amt_read = try self.read(buf);
  22006d:	66 45 85 ed          	test   r13w,r13w
  220071:	0f 85 a5 fc ff ff    	jne    21fd1c <openSelfDebugInfo+0x24c>
  220077:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  22007e:	00 
  22007f:	66 41 bd 25 00       	mov    r13w,0x25
            if (amt_read < buf.len) return error.EndOfStream;
  220084:	48 3b 84 24 a0 00 00 	cmp    rax,QWORD PTR [rsp+0xa0]
  22008b:	00 
  22008c:	0f 82 8a fc ff ff    	jb     21fd1c <openSelfDebugInfo+0x24c>
  220092:	0f b6 44 24 20       	movzx  eax,BYTE PTR [rsp+0x20]
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  220097:	0f b6 4c 24 21       	movzx  ecx,BYTE PTR [rsp+0x21]
  22009c:	89 ca                	mov    edx,ecx
  22009e:	c1 e2 08             	shl    edx,0x8
  2200a1:	09 c2                	or     edx,eax
                result = (result << 8) | b;
  2200a3:	c1 e0 08             	shl    eax,0x8
  2200a6:	09 c8                	or     eax,ecx
    switch (endian) {
  2200a8:	f6 44 24 40 01       	test   BYTE PTR [rsp+0x40],0x1
  2200ad:	66 0f 45 c2          	cmovne ax,dx
  2200b1:	83 c0 ff             	add    eax,0xffffffff
  2200b4:	0f b7 c8             	movzx  ecx,ax
  2200b7:	83 f9 03             	cmp    ecx,0x3
  2200ba:	0f 87 43 03 00 00    	ja     220403 <openSelfDebugInfo+0x933>
  2200c0:	24 03                	and    al,0x3
  2200c2:	88 45 13             	mov    BYTE PTR [rbp+0x13],al
            3 => FileType.Shared,
            4 => FileType.Core,
            else => return error.InvalidFormat,
        };

        elf.arch = switch (try in.readInt(elf.endian, u16)) {
  2200c5:	8a 45 12             	mov    al,BYTE PTR [rbp+0x12]
            try self.readNoEof(bytes[0..]);
  2200c8:	88 44 24 40          	mov    BYTE PTR [rsp+0x40],al
  2200cc:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  2200d1:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  2200d8:	00 
  2200d9:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x2
  2200e0:	00 02 00 00 00 
  2200e5:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  2200ec:	00 
  2200ed:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  2200f4:	00 
            return self.readFn(self, buffer);
  2200f5:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  2200fa:	ff 54 24 58          	call   QWORD PTR [rsp+0x58]
  2200fe:	44 0f b7 ac 24 f0 00 	movzx  r13d,WORD PTR [rsp+0xf0]
  220105:	00 00 
            const amt_read = try self.read(buf);
  220107:	66 45 85 ed          	test   r13w,r13w
  22010b:	0f 85 0b fc ff ff    	jne    21fd1c <openSelfDebugInfo+0x24c>
  220111:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  220118:	00 
  220119:	66 41 bd 25 00       	mov    r13w,0x25
            if (amt_read < buf.len) return error.EndOfStream;
  22011e:	48 3b 84 24 a0 00 00 	cmp    rax,QWORD PTR [rsp+0xa0]
  220125:	00 
  220126:	0f 82 f0 fb ff ff    	jb     21fd1c <openSelfDebugInfo+0x24c>
  22012c:	0f b6 44 24 20       	movzx  eax,BYTE PTR [rsp+0x20]
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  220131:	0f b6 4c 24 21       	movzx  ecx,BYTE PTR [rsp+0x21]
  220136:	89 ca                	mov    edx,ecx
  220138:	c1 e2 08             	shl    edx,0x8
  22013b:	09 c2                	or     edx,eax
                result = (result << 8) | b;
  22013d:	c1 e0 08             	shl    eax,0x8
  220140:	09 c8                	or     eax,ecx
    switch (endian) {
  220142:	f6 44 24 40 01       	test   BYTE PTR [rsp+0x40],0x1
  220147:	66 0f 45 c2          	cmovne ax,dx
  22014b:	8d 48 fe             	lea    ecx,[rax-0x2]
  22014e:	0f b7 c9             	movzx  ecx,cx
  220151:	83 f9 3c             	cmp    ecx,0x3c
  220154:	77 1b                	ja     220171 <openSelfDebugInfo+0x6a1>
  220156:	31 c0                	xor    eax,eax
  220158:	48 8d 15 a5 04 fe ff 	lea    rdx,[rip+0xfffffffffffe04a5]        # 200604 <__unnamed_609+0x2c4>
  22015f:	48 63 0c 8a          	movsxd rcx,DWORD PTR [rdx+rcx*4]
  220163:	48 01 d1             	add    rcx,rdx
  220166:	66 41 bd 26 00       	mov    r13w,0x26
  22016b:	ff e1                	jmp    rcx
  22016d:	b0 01                	mov    al,0x1
  22016f:	eb 28                	jmp    220199 <openSelfDebugInfo+0x6c9>
  220171:	0f b7 c0             	movzx  eax,ax
  220174:	3d b7 00 00 00       	cmp    eax,0xb7
  220179:	0f 85 84 02 00 00    	jne    220403 <openSelfDebugInfo+0x933>
  22017f:	b0 08                	mov    al,0x8
  220181:	eb 16                	jmp    220199 <openSelfDebugInfo+0x6c9>
  220183:	b0 07                	mov    al,0x7
  220185:	eb 12                	jmp    220199 <openSelfDebugInfo+0x6c9>
  220187:	b0 06                	mov    al,0x6
  220189:	eb 0e                	jmp    220199 <openSelfDebugInfo+0x6c9>
  22018b:	b0 02                	mov    al,0x2
  22018d:	eb 0a                	jmp    220199 <openSelfDebugInfo+0x6c9>
  22018f:	b0 04                	mov    al,0x4
  220191:	eb 06                	jmp    220199 <openSelfDebugInfo+0x6c9>
  220193:	b0 03                	mov    al,0x3
  220195:	eb 02                	jmp    220199 <openSelfDebugInfo+0x6c9>
  220197:	b0 05                	mov    al,0x5
  220199:	24 0f                	and    al,0xf
  22019b:	88 45 14             	mov    BYTE PTR [rbp+0x14],al
            0x3E => Arch.x86_64,
            0xb7 => Arch.AArch64,
            else => return error.InvalidFormat,
        };

        const elf_version = try in.readInt(elf.endian, u32);
  22019e:	8a 45 12             	mov    al,BYTE PTR [rbp+0x12]
            try self.readNoEof(bytes[0..]);
  2201a1:	88 44 24 40          	mov    BYTE PTR [rsp+0x40],al
  2201a5:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  2201aa:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  2201b1:	00 
  2201b2:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x4
  2201b9:	00 04 00 00 00 
  2201be:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  2201c5:	00 
  2201c6:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  2201cd:	00 
            return self.readFn(self, buffer);
  2201ce:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  2201d3:	ff 54 24 58          	call   QWORD PTR [rsp+0x58]
  2201d7:	44 0f b7 ac 24 f0 00 	movzx  r13d,WORD PTR [rsp+0xf0]
  2201de:	00 00 
            const amt_read = try self.read(buf);
  2201e0:	66 45 85 ed          	test   r13w,r13w
  2201e4:	0f 85 32 fb ff ff    	jne    21fd1c <openSelfDebugInfo+0x24c>
  2201ea:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  2201f1:	00 
  2201f2:	66 41 bd 25 00       	mov    r13w,0x25
            if (amt_read < buf.len) return error.EndOfStream;
  2201f7:	48 3b 84 24 a0 00 00 	cmp    rax,QWORD PTR [rsp+0xa0]
  2201fe:	00 
  2201ff:	0f 82 17 fb ff ff    	jb     21fd1c <openSelfDebugInfo+0x24c>
  220205:	0f b6 44 24 20       	movzx  eax,BYTE PTR [rsp+0x20]
  22020a:	0f b6 4c 24 21       	movzx  ecx,BYTE PTR [rsp+0x21]
  22020f:	f6 44 24 40 01       	test   BYTE PTR [rsp+0x40],0x1
  220214:	74 23                	je     220239 <openSelfDebugInfo+0x769>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  220216:	c1 e1 08             	shl    ecx,0x8
  220219:	09 c1                	or     ecx,eax
  22021b:	0f b6 54 24 22       	movzx  edx,BYTE PTR [rsp+0x22]
  220220:	c1 e2 10             	shl    edx,0x10
  220223:	09 ca                	or     edx,ecx
  220225:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  22022a:	c1 e0 18             	shl    eax,0x18
  22022d:	09 d0                	or     eax,edx
        if (elf_version != 1) return error.InvalidFormat;
  22022f:	83 f8 01             	cmp    eax,0x1
  220232:	74 27                	je     22025b <openSelfDebugInfo+0x78b>
  220234:	e9 ca 01 00 00       	jmp    220403 <openSelfDebugInfo+0x933>
                result = (result << 8) | b;
  220239:	c1 e0 08             	shl    eax,0x8
  22023c:	09 c8                	or     eax,ecx
  22023e:	c1 e0 08             	shl    eax,0x8
  220241:	0f b6 4c 24 22       	movzx  ecx,BYTE PTR [rsp+0x22]
  220246:	09 c1                	or     ecx,eax
  220248:	c1 e1 08             	shl    ecx,0x8
  22024b:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  220250:	09 c8                	or     eax,ecx
  220252:	83 f8 01             	cmp    eax,0x1
  220255:	0f 85 a8 01 00 00    	jne    220403 <openSelfDebugInfo+0x933>
  22025b:	8a 45 12             	mov    al,BYTE PTR [rbp+0x12]

        if (elf.is_64) {
  22025e:	88 44 24 40          	mov    BYTE PTR [rsp+0x40],al
  220262:	80 7d 11 01          	cmp    BYTE PTR [rbp+0x11],0x1
  220266:	0f 85 e3 2b 00 00    	jne    222e4f <openSelfDebugInfo+0x337f>
            elf.entry_addr = try in.readInt(elf.endian, u64);
  22026c:	0f b6 54 24 40       	movzx  edx,BYTE PTR [rsp+0x40]
  220271:	48 8d bc 24 68 04 00 	lea    rdi,[rsp+0x468]
  220278:	00 
  220279:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  22027e:	e8 ed 47 00 00       	call   224a70 <InStream(ReadError)_readInt.147>
  220283:	44 0f b7 ac 24 68 04 	movzx  r13d,WORD PTR [rsp+0x468]
  22028a:	00 00 
  22028c:	66 45 85 ed          	test   r13w,r13w
  220290:	0f 85 86 fa ff ff    	jne    21fd1c <openSelfDebugInfo+0x24c>
  220296:	48 8b 84 24 70 04 00 	mov    rax,QWORD PTR [rsp+0x470]
  22029d:	00 
  22029e:	48 89 45 18          	mov    QWORD PTR [rbp+0x18],rax
            elf.program_header_offset = try in.readInt(elf.endian, u64);
  2202a2:	0f b6 55 12          	movzx  edx,BYTE PTR [rbp+0x12]
  2202a6:	48 8d bc 24 c0 02 00 	lea    rdi,[rsp+0x2c0]
  2202ad:	00 
  2202ae:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  2202b3:	e8 b8 47 00 00       	call   224a70 <InStream(ReadError)_readInt.147>
  2202b8:	44 0f b7 ac 24 c0 02 	movzx  r13d,WORD PTR [rsp+0x2c0]
  2202bf:	00 00 
  2202c1:	66 45 85 ed          	test   r13w,r13w
  2202c5:	0f 85 51 fa ff ff    	jne    21fd1c <openSelfDebugInfo+0x24c>
  2202cb:	48 8b 84 24 c8 02 00 	mov    rax,QWORD PTR [rsp+0x2c8]
  2202d2:	00 
  2202d3:	48 89 45 20          	mov    QWORD PTR [rbp+0x20],rax
            elf.section_header_offset = try in.readInt(elf.endian, u64);
  2202d7:	0f b6 55 12          	movzx  edx,BYTE PTR [rbp+0x12]
  2202db:	48 8d bc 24 88 02 00 	lea    rdi,[rsp+0x288]
  2202e2:	00 
  2202e3:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  2202e8:	e8 83 47 00 00       	call   224a70 <InStream(ReadError)_readInt.147>
  2202ed:	44 0f b7 ac 24 88 02 	movzx  r13d,WORD PTR [rsp+0x288]
  2202f4:	00 00 
  2202f6:	66 45 85 ed          	test   r13w,r13w
  2202fa:	0f 85 1c fa ff ff    	jne    21fd1c <openSelfDebugInfo+0x24c>
  220300:	48 8b 84 24 90 02 00 	mov    rax,QWORD PTR [rsp+0x290]
  220307:	00 
  220308:	48 89 45 28          	mov    QWORD PTR [rbp+0x28],rax
            elf.program_header_offset = u64(try in.readInt(elf.endian, u32));
            elf.section_header_offset = u64(try in.readInt(elf.endian, u32));
        }

        // skip over flags
        try elf.in_file.seekForward(4);
  22030c:	49 8b 07             	mov    rax,QWORD PTR [r15]
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  22030f:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  220312:	b8 08 00 00 00       	mov    eax,0x8
  220317:	be 04 00 00 00       	mov    esi,0x4
  22031c:	ba 01 00 00 00       	mov    edx,0x1
  220321:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  220323:	48 89 c2             	mov    rdx,rax
  220326:	48 f7 da             	neg    rdx
  220329:	31 c9                	xor    ecx,ecx
  22032b:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  220331:	48 0f 47 ca          	cmova  rcx,rdx
  220335:	48 83 f9 1d          	cmp    rcx,0x1d
  220339:	0f 87 e1 37 00 00    	ja     223b20 <openSelfDebugInfo+0x4050>
  22033f:	48 8d 05 b2 03 fe ff 	lea    rax,[rip+0xfffffffffffe03b2]        # 2006f8 <__unnamed_609+0x3b8>
  220346:	48 63 0c 88          	movsxd rcx,DWORD PTR [rax+rcx*4]
  22034a:	48 01 c1             	add    rcx,rax
  22034d:	66 41 bd 03 00       	mov    r13w,0x3
  220352:	ff e1                	jmp    rcx

        const header_size = try in.readInt(elf.endian, u16);
  220354:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  220359:	8a 00                	mov    al,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  22035b:	88 44 24 40          	mov    BYTE PTR [rsp+0x40],al
  22035f:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  220364:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  22036b:	00 
  22036c:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x2
  220373:	00 02 00 00 00 
  220378:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  22037f:	00 
  220380:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  220387:	00 
            return self.readFn(self, buffer);
  220388:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  22038d:	ff 54 24 58          	call   QWORD PTR [rsp+0x58]
  220391:	44 0f b7 ac 24 f0 00 	movzx  r13d,WORD PTR [rsp+0xf0]
  220398:	00 00 
            const amt_read = try self.read(buf);
  22039a:	66 45 85 ed          	test   r13w,r13w
  22039e:	0f 85 78 f9 ff ff    	jne    21fd1c <openSelfDebugInfo+0x24c>
  2203a4:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  2203ab:	00 
  2203ac:	66 41 bd 25 00       	mov    r13w,0x25
            if (amt_read < buf.len) return error.EndOfStream;
  2203b1:	48 3b 84 24 a0 00 00 	cmp    rax,QWORD PTR [rsp+0xa0]
  2203b8:	00 
  2203b9:	0f 82 5d f9 ff ff    	jb     21fd1c <openSelfDebugInfo+0x24c>
  2203bf:	0f b6 44 24 20       	movzx  eax,BYTE PTR [rsp+0x20]
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  2203c4:	0f b6 4c 24 21       	movzx  ecx,BYTE PTR [rsp+0x21]
  2203c9:	89 ca                	mov    edx,ecx
  2203cb:	c1 e2 08             	shl    edx,0x8
  2203ce:	09 c2                	or     edx,eax
                result = (result << 8) | b;
  2203d0:	c1 e0 08             	shl    eax,0x8
  2203d3:	09 c8                	or     eax,ecx
    switch (endian) {
  2203d5:	f6 44 24 40 01       	test   BYTE PTR [rsp+0x40],0x1
  2203da:	66 0f 45 c2          	cmovne ax,dx
        if ((elf.is_64 and header_size != 64) or (!elf.is_64 and header_size != 52)) {
  2203de:	8a 4d 11             	mov    cl,BYTE PTR [rbp+0x11]
  2203e1:	80 f9 01             	cmp    cl,0x1
  2203e4:	75 08                	jne    2203ee <openSelfDebugInfo+0x91e>
  2203e6:	0f b7 d0             	movzx  edx,ax
  2203e9:	83 fa 40             	cmp    edx,0x40
  2203ec:	75 15                	jne    220403 <openSelfDebugInfo+0x933>
  2203ee:	0f b7 c0             	movzx  eax,ax
  2203f1:	83 f8 34             	cmp    eax,0x34
  2203f4:	0f 84 65 2c 00 00    	je     22305f <openSelfDebugInfo+0x358f>
  2203fa:	80 f1 01             	xor    cl,0x1
  2203fd:	0f 84 5c 2c 00 00    	je     22305f <openSelfDebugInfo+0x358f>
  220403:	66 41 bd 26 00       	mov    r13w,0x26
  220408:	66 45 85 ed          	test   r13w,r13w
  22040c:	0f 85 14 f9 ff ff    	jne    21fd26 <openSelfDebugInfo+0x256>
            st.debug_info = (try st.elf.findSection(".debug_info")) orelse return error.MissingDebugInfo;
  220412:	48 8d 15 8f e9 02 00 	lea    rdx,[rip+0x2e98f]        # 24eda8 <__unnamed_56>
  220419:	48 8d bc 24 40 03 00 	lea    rdi,[rsp+0x340]
  220420:	00 
  220421:	4c 89 fe             	mov    rsi,r15
  220424:	c5 f8 77             	vzeroupper 
  220427:	e8 34 43 00 00       	call   224760 <Elf_findSection>
  22042c:	66 83 bc 24 40 03 00 	cmp    WORD PTR [rsp+0x340],0x0
  220433:	00 00 
  220435:	0f 84 7f 00 00 00    	je     2204ba <openSelfDebugInfo+0x9ea>
        const bytes = @sliceToBytes(memory);
  22043b:	48 8b 45 48          	mov    rax,QWORD PTR [rbp+0x48]
  22043f:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  220443:	74 26                	je     22046b <openSelfDebugInfo+0x99b>
  220445:	48 8b 7d 50          	mov    rdi,QWORD PTR [rbp+0x50]
        const bytes = @sliceToBytes(memory);
  220449:	48 8b 4d 40          	mov    rcx,QWORD PTR [rbp+0x40]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  22044d:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  220451:	48 89 8c 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rcx
  220458:	00 
  220459:	48 89 84 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],rax
  220460:	00 
  220461:	48 8d b4 24 f0 00 00 	lea    rsi,[rsp+0xf0]
  220468:	00 
  220469:	ff d2                	call   rdx
    }

    pub fn close(elf: *Elf) void {
        elf.allocator.free(elf.section_headers);

        if (elf.auto_close_stream) elf.in_file.close();
  22046b:	80 7d 10 01          	cmp    BYTE PTR [rbp+0x10],0x1
  22046f:	0f 85 90 02 00 00    	jne    220705 <openSelfDebugInfo+0xc35>
  220475:	49 8b 07             	mov    rax,QWORD PTR [r15]
  220478:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  22047b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
    return asm volatile ("syscall"
  220480:	b8 03 00 00 00       	mov    eax,0x3
  220485:	0f 05                	syscall 
            switch (err) {
  220487:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  22048b:	74 f3                	je     220480 <openSelfDebugInfo+0x9b0>
            const first = list.first orelse return null;
  22048d:	48 8b 05 94 fb 02 00 	mov    rax,QWORD PTR [rip+0x2fb94]        # 250028 <emfile_promise_queue>
  220494:	48 85 c0             	test   rax,rax
  220497:	0f 84 68 02 00 00    	je     220705 <openSelfDebugInfo+0xc35>
            if (node.prev) |prev_node| {
  22049d:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  2204a0:	48 85 c9             	test   rcx,rcx
  2204a3:	0f 84 f5 01 00 00    	je     22069e <openSelfDebugInfo+0xbce>
                prev_node.next = node.next;
  2204a9:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  2204ad:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  2204b1:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  2204b5:	e9 ef 01 00 00       	jmp    2206a9 <openSelfDebugInfo+0xbd9>
  2204ba:	48 8b 84 24 48 03 00 	mov    rax,QWORD PTR [rsp+0x348]
  2204c1:	00 
  2204c2:	48 85 c0             	test   rax,rax
  2204c5:	0f 84 a4 00 00 00    	je     22056f <openSelfDebugInfo+0xa9f>
  2204cb:	48 89 45 60          	mov    QWORD PTR [rbp+0x60],rax
            st.debug_abbrev = (try st.elf.findSection(".debug_abbrev")) orelse return error.MissingDebugInfo;
  2204cf:	48 8d 15 e2 e8 02 00 	lea    rdx,[rip+0x2e8e2]        # 24edb8 <__unnamed_57>
  2204d6:	48 8d bc 24 30 03 00 	lea    rdi,[rsp+0x330]
  2204dd:	00 
  2204de:	4c 89 fe             	mov    rsi,r15
  2204e1:	e8 7a 42 00 00       	call   224760 <Elf_findSection>
  2204e6:	66 83 bc 24 30 03 00 	cmp    WORD PTR [rsp+0x330],0x0
  2204ed:	00 00 
  2204ef:	0f 84 f4 00 00 00    	je     2205e9 <openSelfDebugInfo+0xb19>
        const bytes = @sliceToBytes(memory);
  2204f5:	48 8b 45 48          	mov    rax,QWORD PTR [rbp+0x48]
  2204f9:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  2204fd:	74 26                	je     220525 <openSelfDebugInfo+0xa55>
  2204ff:	48 8b 7d 50          	mov    rdi,QWORD PTR [rbp+0x50]
        const bytes = @sliceToBytes(memory);
  220503:	48 8b 4d 40          	mov    rcx,QWORD PTR [rbp+0x40]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  220507:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  22050b:	48 89 8c 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rcx
  220512:	00 
  220513:	48 89 84 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],rax
  22051a:	00 
  22051b:	48 8d b4 24 f0 00 00 	lea    rsi,[rsp+0xf0]
  220522:	00 
  220523:	ff d2                	call   rdx
  220525:	80 7d 10 01          	cmp    BYTE PTR [rbp+0x10],0x1
  220529:	0f 85 68 04 00 00    	jne    220997 <openSelfDebugInfo+0xec7>
  22052f:	49 8b 07             	mov    rax,QWORD PTR [r15]
  220532:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  220535:	b8 03 00 00 00       	mov    eax,0x3
  22053a:	0f 05                	syscall 
  22053c:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  220540:	74 f3                	je     220535 <openSelfDebugInfo+0xa65>
            const first = list.first orelse return null;
  220542:	48 8b 05 df fa 02 00 	mov    rax,QWORD PTR [rip+0x2fadf]        # 250028 <emfile_promise_queue>
  220549:	48 85 c0             	test   rax,rax
  22054c:	0f 84 45 04 00 00    	je     220997 <openSelfDebugInfo+0xec7>
            if (node.prev) |prev_node| {
  220552:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  220555:	48 85 c9             	test   rcx,rcx
  220558:	0f 84 d5 03 00 00    	je     220933 <openSelfDebugInfo+0xe63>
                prev_node.next = node.next;
  22055e:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  220562:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  220566:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  22056a:	e9 cf 03 00 00       	jmp    22093e <openSelfDebugInfo+0xe6e>
        const bytes = @sliceToBytes(memory);
  22056f:	48 8b 45 48          	mov    rax,QWORD PTR [rbp+0x48]
  220573:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  220577:	74 26                	je     22059f <openSelfDebugInfo+0xacf>
  220579:	48 8b 7d 50          	mov    rdi,QWORD PTR [rbp+0x50]
        const bytes = @sliceToBytes(memory);
  22057d:	48 8b 4d 40          	mov    rcx,QWORD PTR [rbp+0x40]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  220581:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  220585:	48 89 8c 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rcx
  22058c:	00 
  22058d:	48 89 84 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],rax
  220594:	00 
  220595:	48 8d b4 24 f0 00 00 	lea    rsi,[rsp+0xf0]
  22059c:	00 
  22059d:	ff d2                	call   rdx
  22059f:	80 7d 10 01          	cmp    BYTE PTR [rbp+0x10],0x1
  2205a3:	0f 85 35 05 00 00    	jne    220ade <openSelfDebugInfo+0x100e>
  2205a9:	49 8b 07             	mov    rax,QWORD PTR [r15]
  2205ac:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  2205af:	b8 03 00 00 00       	mov    eax,0x3
  2205b4:	0f 05                	syscall 
  2205b6:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  2205ba:	74 f3                	je     2205af <openSelfDebugInfo+0xadf>
            const first = list.first orelse return null;
  2205bc:	48 8b 05 65 fa 02 00 	mov    rax,QWORD PTR [rip+0x2fa65]        # 250028 <emfile_promise_queue>
  2205c3:	48 85 c0             	test   rax,rax
  2205c6:	0f 84 12 05 00 00    	je     220ade <openSelfDebugInfo+0x100e>
            if (node.prev) |prev_node| {
  2205cc:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  2205cf:	48 85 c9             	test   rcx,rcx
  2205d2:	0f 84 a2 04 00 00    	je     220a7a <openSelfDebugInfo+0xfaa>
                prev_node.next = node.next;
  2205d8:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  2205dc:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  2205e0:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  2205e4:	e9 9c 04 00 00       	jmp    220a85 <openSelfDebugInfo+0xfb5>
  2205e9:	48 8b 84 24 38 03 00 	mov    rax,QWORD PTR [rsp+0x338]
  2205f0:	00 
  2205f1:	48 85 c0             	test   rax,rax
  2205f4:	0f 84 0a 02 00 00    	je     220804 <openSelfDebugInfo+0xd34>
  2205fa:	48 89 45 68          	mov    QWORD PTR [rbp+0x68],rax
            st.debug_str = (try st.elf.findSection(".debug_str")) orelse return error.MissingDebugInfo;
  2205fe:	48 8d 15 c3 e7 02 00 	lea    rdx,[rip+0x2e7c3]        # 24edc8 <__unnamed_58>
  220605:	48 8d bc 24 20 03 00 	lea    rdi,[rsp+0x320]
  22060c:	00 
  22060d:	4c 89 fe             	mov    rsi,r15
  220610:	e8 4b 41 00 00       	call   224760 <Elf_findSection>
  220615:	66 83 bc 24 20 03 00 	cmp    WORD PTR [rsp+0x320],0x0
  22061c:	00 00 
  22061e:	0f 84 5a 02 00 00    	je     22087e <openSelfDebugInfo+0xdae>
        const bytes = @sliceToBytes(memory);
  220624:	48 8b 45 48          	mov    rax,QWORD PTR [rbp+0x48]
  220628:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  22062c:	74 26                	je     220654 <openSelfDebugInfo+0xb84>
  22062e:	48 8b 7d 50          	mov    rdi,QWORD PTR [rbp+0x50]
        const bytes = @sliceToBytes(memory);
  220632:	48 8b 4d 40          	mov    rcx,QWORD PTR [rbp+0x40]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  220636:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  22063a:	48 89 8c 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rcx
  220641:	00 
  220642:	48 89 84 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],rax
  220649:	00 
  22064a:	48 8d b4 24 f0 00 00 	lea    rsi,[rsp+0xf0]
  220651:	00 
  220652:	ff d2                	call   rdx
  220654:	80 7d 10 01          	cmp    BYTE PTR [rbp+0x10],0x1
  220658:	0f 85 f0 06 00 00    	jne    220d4e <openSelfDebugInfo+0x127e>
  22065e:	49 8b 07             	mov    rax,QWORD PTR [r15]
  220661:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  220664:	b8 03 00 00 00       	mov    eax,0x3
  220669:	0f 05                	syscall 
  22066b:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  22066f:	74 f3                	je     220664 <openSelfDebugInfo+0xb94>
            const first = list.first orelse return null;
  220671:	48 8b 05 b0 f9 02 00 	mov    rax,QWORD PTR [rip+0x2f9b0]        # 250028 <emfile_promise_queue>
  220678:	48 85 c0             	test   rax,rax
  22067b:	0f 84 cd 06 00 00    	je     220d4e <openSelfDebugInfo+0x127e>
            if (node.prev) |prev_node| {
  220681:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  220684:	48 85 c9             	test   rcx,rcx
  220687:	0f 84 5d 06 00 00    	je     220cea <openSelfDebugInfo+0x121a>
                prev_node.next = node.next;
  22068d:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  220691:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  220695:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  220699:	e9 57 06 00 00       	jmp    220cf5 <openSelfDebugInfo+0x1225>
                list.first = node.next;
  22069e:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  2206a2:	48 89 0d 7f f9 02 00 	mov    QWORD PTR [rip+0x2f97f],rcx        # 250028 <emfile_promise_queue>
            if (node.next) |next_node| {
  2206a9:	48 85 c9             	test   rcx,rcx
  2206ac:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  2206af:	48 8d 35 7a f9 02 00 	lea    rsi,[rip+0x2f97a]        # 250030 <emfile_promise_queue+0x8>
  2206b6:	48 0f 45 f1          	cmovne rsi,rcx
  2206ba:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  2206bd:	48 83 05 73 f9 02 00 	add    QWORD PTR [rip+0x2f973],0xffffffffffffffff        # 250038 <emfile_promise_queue+0x10>
  2206c4:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  2206c5:	74 1e                	je     2206e5 <openSelfDebugInfo+0xc15>
  2206c7:	48 83 3d 59 f9 02 00 	cmp    QWORD PTR [rip+0x2f959],0x0        # 250028 <emfile_promise_queue>
  2206ce:	00 
  2206cf:	0f 84 5f 34 00 00    	je     223b34 <openSelfDebugInfo+0x4064>
  2206d5:	48 8b 0d 54 f9 02 00 	mov    rcx,QWORD PTR [rip+0x2f954]        # 250030 <emfile_promise_queue+0x8>
  2206dc:	48 85 c9             	test   rcx,rcx
  2206df:	0f 84 4f 34 00 00    	je     223b34 <openSelfDebugInfo+0x4064>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  2206e5:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  2206e9:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  2206ed:	0f 1f 00             	nop    DWORD PTR [rax]
  2206f0:	48 89 c1             	mov    rcx,rax
  2206f3:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  2206f7:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  2206fd:	75 f1                	jne    2206f0 <openSelfDebugInfo+0xc20>
  2206ff:	a8 01                	test   al,0x1
  220701:	75 02                	jne    220705 <openSelfDebugInfo+0xc35>
  220703:	ff 17                	call   QWORD PTR [rdi]
  220705:	48 63 7d 00          	movsxd rdi,DWORD PTR [rbp+0x0]
  220709:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  220710:	b8 03 00 00 00       	mov    eax,0x3
  220715:	0f 05                	syscall 
            switch (err) {
  220717:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  22071b:	74 f3                	je     220710 <openSelfDebugInfo+0xc40>
            const first = list.first orelse return null;
  22071d:	48 8b 05 04 f9 02 00 	mov    rax,QWORD PTR [rip+0x2f904]        # 250028 <emfile_promise_queue>
  220724:	48 85 c0             	test   rax,rax
  220727:	74 7c                	je     2207a5 <openSelfDebugInfo+0xcd5>
            if (node.prev) |prev_node| {
  220729:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  22072c:	48 85 c9             	test   rcx,rcx
  22072f:	74 0e                	je     22073f <openSelfDebugInfo+0xc6f>
                prev_node.next = node.next;
  220731:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  220735:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  220739:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  22073d:	eb 0b                	jmp    22074a <openSelfDebugInfo+0xc7a>
                list.first = node.next;
  22073f:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  220743:	48 89 0d de f8 02 00 	mov    QWORD PTR [rip+0x2f8de],rcx        # 250028 <emfile_promise_queue>
            if (node.next) |next_node| {
  22074a:	48 85 c9             	test   rcx,rcx
  22074d:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  220750:	48 8d 35 d9 f8 02 00 	lea    rsi,[rip+0x2f8d9]        # 250030 <emfile_promise_queue+0x8>
  220757:	48 0f 45 f1          	cmovne rsi,rcx
  22075b:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  22075e:	48 83 05 d2 f8 02 00 	add    QWORD PTR [rip+0x2f8d2],0xffffffffffffffff        # 250038 <emfile_promise_queue+0x10>
  220765:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  220766:	74 1e                	je     220786 <openSelfDebugInfo+0xcb6>
  220768:	48 83 3d b8 f8 02 00 	cmp    QWORD PTR [rip+0x2f8b8],0x0        # 250028 <emfile_promise_queue>
  22076f:	00 
  220770:	0f 84 be 33 00 00    	je     223b34 <openSelfDebugInfo+0x4064>
  220776:	48 8b 0d b3 f8 02 00 	mov    rcx,QWORD PTR [rip+0x2f8b3]        # 250030 <emfile_promise_queue+0x8>
  22077d:	48 85 c9             	test   rcx,rcx
  220780:	0f 84 ae 33 00 00    	je     223b34 <openSelfDebugInfo+0x4064>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  220786:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  22078a:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  22078e:	66 90                	xchg   ax,ax
  220790:	48 89 c1             	mov    rcx,rax
  220793:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  220797:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  22079d:	75 f1                	jne    220790 <openSelfDebugInfo+0xcc0>
  22079f:	a8 01                	test   al,0x1
  2207a1:	75 02                	jne    2207a5 <openSelfDebugInfo+0xcd5>
  2207a3:	ff 17                	call   QWORD PTR [rdi]
        self.freeFn(self, non_const_ptr[0..@sizeOf(@typeOf(ptr).Child)]);
  2207a5:	49 8b 44 24 10       	mov    rax,QWORD PTR [r12+0x10]
  2207aa:	48 89 ac 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rbp
  2207b1:	00 
  2207b2:	48 c7 84 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],0xc8
  2207b9:	00 c8 00 00 00 
  2207be:	48 8d b4 24 f0 00 00 	lea    rsi,[rsp+0xf0]
  2207c5:	00 
  2207c6:	4c 89 e7             	mov    rdi,r12
  2207c9:	ff d0                	call   rax
            st.debug_info = (try st.elf.findSection(".debug_info")) orelse return error.MissingDebugInfo;
  2207cb:	0f b7 84 24 40 03 00 	movzx  eax,WORD PTR [rsp+0x340]
  2207d2:	00 
  2207d3:	66 41 89 06          	mov    WORD PTR [r14],ax
  2207d7:	48 8b 84 24 e8 04 00 	mov    rax,QWORD PTR [rsp+0x4e8]
  2207de:	00 
  2207df:	48 8b 8c 24 ee 04 00 	mov    rcx,QWORD PTR [rsp+0x4ee]
  2207e6:	00 
  2207e7:	49 89 4e 08          	mov    QWORD PTR [r14+0x8],rcx
  2207eb:	49 89 46 02          	mov    QWORD PTR [r14+0x2],rax
  2207ef:	48 81 c4 e8 05 00 00 	add    rsp,0x5e8
  2207f6:	5b                   	pop    rbx
  2207f7:	41 5c                	pop    r12
  2207f9:	41 5d                	pop    r13
  2207fb:	41 5e                	pop    r14
  2207fd:	41 5f                	pop    r15
  2207ff:	5d                   	pop    rbp
  220800:	c5 f8 77             	vzeroupper 
  220803:	c3                   	ret    
        const bytes = @sliceToBytes(memory);
  220804:	48 8b 45 48          	mov    rax,QWORD PTR [rbp+0x48]
  220808:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  22080c:	74 26                	je     220834 <openSelfDebugInfo+0xd64>
  22080e:	48 8b 7d 50          	mov    rdi,QWORD PTR [rbp+0x50]
        const bytes = @sliceToBytes(memory);
  220812:	48 8b 4d 40          	mov    rcx,QWORD PTR [rbp+0x40]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  220816:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  22081a:	48 89 8c 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rcx
  220821:	00 
  220822:	48 89 84 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],rax
  220829:	00 
  22082a:	48 8d b4 24 f0 00 00 	lea    rsi,[rsp+0xf0]
  220831:	00 
  220832:	ff d2                	call   rdx
  220834:	80 7d 10 01          	cmp    BYTE PTR [rbp+0x10],0x1
  220838:	0f 85 52 06 00 00    	jne    220e90 <openSelfDebugInfo+0x13c0>
  22083e:	49 8b 07             	mov    rax,QWORD PTR [r15]
  220841:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  220844:	b8 03 00 00 00       	mov    eax,0x3
  220849:	0f 05                	syscall 
            switch (err) {
  22084b:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  22084f:	74 f3                	je     220844 <openSelfDebugInfo+0xd74>
            const first = list.first orelse return null;
  220851:	48 8b 05 d0 f7 02 00 	mov    rax,QWORD PTR [rip+0x2f7d0]        # 250028 <emfile_promise_queue>
  220858:	48 85 c0             	test   rax,rax
  22085b:	0f 84 2f 06 00 00    	je     220e90 <openSelfDebugInfo+0x13c0>
            if (node.prev) |prev_node| {
  220861:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  220864:	48 85 c9             	test   rcx,rcx
  220867:	0f 84 bf 05 00 00    	je     220e2c <openSelfDebugInfo+0x135c>
                prev_node.next = node.next;
  22086d:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  220871:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  220875:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  220879:	e9 b9 05 00 00       	jmp    220e37 <openSelfDebugInfo+0x1367>
            st.debug_str = (try st.elf.findSection(".debug_str")) orelse return error.MissingDebugInfo;
  22087e:	48 8b 84 24 28 03 00 	mov    rax,QWORD PTR [rsp+0x328]
  220885:	00 
  220886:	48 85 c0             	test   rax,rax
  220889:	0f 84 2c 03 00 00    	je     220bbb <openSelfDebugInfo+0x10eb>
  22088f:	48 89 45 70          	mov    QWORD PTR [rbp+0x70],rax
            st.debug_line = (try st.elf.findSection(".debug_line")) orelse return error.MissingDebugInfo;
  220893:	48 8d 15 3e e5 02 00 	lea    rdx,[rip+0x2e53e]        # 24edd8 <__unnamed_59>
  22089a:	48 8d bc 24 10 03 00 	lea    rdi,[rsp+0x310]
  2208a1:	00 
  2208a2:	4c 89 fe             	mov    rsi,r15
  2208a5:	e8 b6 3e 00 00       	call   224760 <Elf_findSection>
  2208aa:	66 83 bc 24 10 03 00 	cmp    WORD PTR [rsp+0x310],0x0
  2208b1:	00 00 
  2208b3:	0f 84 7c 03 00 00    	je     220c35 <openSelfDebugInfo+0x1165>
        const bytes = @sliceToBytes(memory);
  2208b9:	48 8b 45 48          	mov    rax,QWORD PTR [rbp+0x48]
  2208bd:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  2208c1:	74 26                	je     2208e9 <openSelfDebugInfo+0xe19>
  2208c3:	48 8b 7d 50          	mov    rdi,QWORD PTR [rbp+0x50]
        const bytes = @sliceToBytes(memory);
  2208c7:	48 8b 4d 40          	mov    rcx,QWORD PTR [rbp+0x40]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  2208cb:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  2208cf:	48 89 8c 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rcx
  2208d6:	00 
  2208d7:	48 89 84 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],rax
  2208de:	00 
  2208df:	48 8d b4 24 f0 00 00 	lea    rsi,[rsp+0xf0]
  2208e6:	00 
  2208e7:	ff d2                	call   rdx
  2208e9:	80 7d 10 01          	cmp    BYTE PTR [rbp+0x10],0x1
  2208ed:	0f 85 92 1c 00 00    	jne    222585 <openSelfDebugInfo+0x2ab5>
  2208f3:	49 8b 07             	mov    rax,QWORD PTR [r15]
  2208f6:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  2208f9:	b8 03 00 00 00       	mov    eax,0x3
  2208fe:	0f 05                	syscall 
  220900:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  220904:	74 f3                	je     2208f9 <openSelfDebugInfo+0xe29>
            const first = list.first orelse return null;
  220906:	48 8b 05 1b f7 02 00 	mov    rax,QWORD PTR [rip+0x2f71b]        # 250028 <emfile_promise_queue>
  22090d:	48 85 c0             	test   rax,rax
  220910:	0f 84 6f 1c 00 00    	je     222585 <openSelfDebugInfo+0x2ab5>
            if (node.prev) |prev_node| {
  220916:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  220919:	48 85 c9             	test   rcx,rcx
  22091c:	0f 84 ff 1b 00 00    	je     222521 <openSelfDebugInfo+0x2a51>
                prev_node.next = node.next;
  220922:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  220926:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  22092a:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  22092e:	e9 f9 1b 00 00       	jmp    22252c <openSelfDebugInfo+0x2a5c>
                list.first = node.next;
  220933:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  220937:	48 89 0d ea f6 02 00 	mov    QWORD PTR [rip+0x2f6ea],rcx        # 250028 <emfile_promise_queue>
            if (node.next) |next_node| {
  22093e:	48 85 c9             	test   rcx,rcx
  220941:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  220944:	48 8d 35 e5 f6 02 00 	lea    rsi,[rip+0x2f6e5]        # 250030 <emfile_promise_queue+0x8>
  22094b:	48 0f 45 f1          	cmovne rsi,rcx
  22094f:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  220952:	48 83 05 de f6 02 00 	add    QWORD PTR [rip+0x2f6de],0xffffffffffffffff        # 250038 <emfile_promise_queue+0x10>
  220959:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  22095a:	74 1e                	je     22097a <openSelfDebugInfo+0xeaa>
  22095c:	48 83 3d c4 f6 02 00 	cmp    QWORD PTR [rip+0x2f6c4],0x0        # 250028 <emfile_promise_queue>
  220963:	00 
  220964:	0f 84 ca 31 00 00    	je     223b34 <openSelfDebugInfo+0x4064>
  22096a:	48 8b 0d bf f6 02 00 	mov    rcx,QWORD PTR [rip+0x2f6bf]        # 250030 <emfile_promise_queue+0x8>
  220971:	48 85 c9             	test   rcx,rcx
  220974:	0f 84 ba 31 00 00    	je     223b34 <openSelfDebugInfo+0x4064>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  22097a:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  22097e:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  220982:	48 89 c1             	mov    rcx,rax
  220985:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  220989:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  22098f:	75 f1                	jne    220982 <openSelfDebugInfo+0xeb2>
  220991:	a8 01                	test   al,0x1
  220993:	75 02                	jne    220997 <openSelfDebugInfo+0xec7>
  220995:	ff 17                	call   QWORD PTR [rdi]
  220997:	48 63 7d 00          	movsxd rdi,DWORD PTR [rbp+0x0]
  22099b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  2209a0:	b8 03 00 00 00       	mov    eax,0x3
  2209a5:	0f 05                	syscall 
            switch (err) {
  2209a7:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  2209ab:	74 f3                	je     2209a0 <openSelfDebugInfo+0xed0>
            const first = list.first orelse return null;
  2209ad:	48 8b 05 74 f6 02 00 	mov    rax,QWORD PTR [rip+0x2f674]        # 250028 <emfile_promise_queue>
  2209b4:	48 85 c0             	test   rax,rax
  2209b7:	74 7a                	je     220a33 <openSelfDebugInfo+0xf63>
            if (node.prev) |prev_node| {
  2209b9:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  2209bc:	48 85 c9             	test   rcx,rcx
  2209bf:	74 0e                	je     2209cf <openSelfDebugInfo+0xeff>
                prev_node.next = node.next;
  2209c1:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  2209c5:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  2209c9:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  2209cd:	eb 0b                	jmp    2209da <openSelfDebugInfo+0xf0a>
                list.first = node.next;
  2209cf:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  2209d3:	48 89 0d 4e f6 02 00 	mov    QWORD PTR [rip+0x2f64e],rcx        # 250028 <emfile_promise_queue>
            if (node.next) |next_node| {
  2209da:	48 85 c9             	test   rcx,rcx
  2209dd:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  2209e0:	48 8d 35 49 f6 02 00 	lea    rsi,[rip+0x2f649]        # 250030 <emfile_promise_queue+0x8>
  2209e7:	48 0f 45 f1          	cmovne rsi,rcx
  2209eb:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  2209ee:	48 83 05 42 f6 02 00 	add    QWORD PTR [rip+0x2f642],0xffffffffffffffff        # 250038 <emfile_promise_queue+0x10>
  2209f5:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  2209f6:	74 1e                	je     220a16 <openSelfDebugInfo+0xf46>
  2209f8:	48 83 3d 28 f6 02 00 	cmp    QWORD PTR [rip+0x2f628],0x0        # 250028 <emfile_promise_queue>
  2209ff:	00 
  220a00:	0f 84 2e 31 00 00    	je     223b34 <openSelfDebugInfo+0x4064>
  220a06:	48 8b 0d 23 f6 02 00 	mov    rcx,QWORD PTR [rip+0x2f623]        # 250030 <emfile_promise_queue+0x8>
  220a0d:	48 85 c9             	test   rcx,rcx
  220a10:	0f 84 1e 31 00 00    	je     223b34 <openSelfDebugInfo+0x4064>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  220a16:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  220a1a:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  220a1e:	48 89 c1             	mov    rcx,rax
  220a21:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  220a25:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  220a2b:	75 f1                	jne    220a1e <openSelfDebugInfo+0xf4e>
  220a2d:	a8 01                	test   al,0x1
  220a2f:	75 02                	jne    220a33 <openSelfDebugInfo+0xf63>
  220a31:	ff 17                	call   QWORD PTR [rdi]
        self.freeFn(self, non_const_ptr[0..@sizeOf(@typeOf(ptr).Child)]);
  220a33:	49 8b 44 24 10       	mov    rax,QWORD PTR [r12+0x10]
  220a38:	48 89 ac 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rbp
  220a3f:	00 
  220a40:	48 c7 84 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],0xc8
  220a47:	00 c8 00 00 00 
  220a4c:	48 8d b4 24 f0 00 00 	lea    rsi,[rsp+0xf0]
  220a53:	00 
  220a54:	4c 89 e7             	mov    rdi,r12
  220a57:	ff d0                	call   rax
            st.debug_abbrev = (try st.elf.findSection(".debug_abbrev")) orelse return error.MissingDebugInfo;
  220a59:	0f b7 84 24 30 03 00 	movzx  eax,WORD PTR [rsp+0x330]
  220a60:	00 
  220a61:	66 41 89 06          	mov    WORD PTR [r14],ax
  220a65:	48 8b 84 24 da 04 00 	mov    rax,QWORD PTR [rsp+0x4da]
  220a6c:	00 
  220a6d:	48 8b 8c 24 e0 04 00 	mov    rcx,QWORD PTR [rsp+0x4e0]
  220a74:	00 
  220a75:	e9 6d fd ff ff       	jmp    2207e7 <openSelfDebugInfo+0xd17>
                list.first = node.next;
  220a7a:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  220a7e:	48 89 0d a3 f5 02 00 	mov    QWORD PTR [rip+0x2f5a3],rcx        # 250028 <emfile_promise_queue>
            if (node.next) |next_node| {
  220a85:	48 85 c9             	test   rcx,rcx
  220a88:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  220a8b:	48 8d 35 9e f5 02 00 	lea    rsi,[rip+0x2f59e]        # 250030 <emfile_promise_queue+0x8>
  220a92:	48 0f 45 f1          	cmovne rsi,rcx
  220a96:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  220a99:	48 83 05 97 f5 02 00 	add    QWORD PTR [rip+0x2f597],0xffffffffffffffff        # 250038 <emfile_promise_queue+0x10>
  220aa0:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  220aa1:	74 1e                	je     220ac1 <openSelfDebugInfo+0xff1>
  220aa3:	48 83 3d 7d f5 02 00 	cmp    QWORD PTR [rip+0x2f57d],0x0        # 250028 <emfile_promise_queue>
  220aaa:	00 
  220aab:	0f 84 83 30 00 00    	je     223b34 <openSelfDebugInfo+0x4064>
  220ab1:	48 8b 0d 78 f5 02 00 	mov    rcx,QWORD PTR [rip+0x2f578]        # 250030 <emfile_promise_queue+0x8>
  220ab8:	48 85 c9             	test   rcx,rcx
  220abb:	0f 84 73 30 00 00    	je     223b34 <openSelfDebugInfo+0x4064>
  220ac1:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  220ac5:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  220ac9:	48 89 c1             	mov    rcx,rax
  220acc:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  220ad0:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  220ad6:	75 f1                	jne    220ac9 <openSelfDebugInfo+0xff9>
  220ad8:	a8 01                	test   al,0x1
  220ada:	75 02                	jne    220ade <openSelfDebugInfo+0x100e>
  220adc:	ff 17                	call   QWORD PTR [rdi]
  220ade:	48 63 7d 00          	movsxd rdi,DWORD PTR [rbp+0x0]
  220ae2:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  220ae9:	1f 84 00 00 00 00 00 
  220af0:	b8 03 00 00 00       	mov    eax,0x3
  220af5:	0f 05                	syscall 
            switch (err) {
  220af7:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  220afb:	74 f3                	je     220af0 <openSelfDebugInfo+0x1020>
            const first = list.first orelse return null;
  220afd:	48 8b 05 24 f5 02 00 	mov    rax,QWORD PTR [rip+0x2f524]        # 250028 <emfile_promise_queue>
  220b04:	48 85 c0             	test   rax,rax
  220b07:	74 7a                	je     220b83 <openSelfDebugInfo+0x10b3>
            if (node.prev) |prev_node| {
  220b09:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  220b0c:	48 85 c9             	test   rcx,rcx
  220b0f:	74 0e                	je     220b1f <openSelfDebugInfo+0x104f>
                prev_node.next = node.next;
  220b11:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  220b15:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  220b19:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  220b1d:	eb 0b                	jmp    220b2a <openSelfDebugInfo+0x105a>
                list.first = node.next;
  220b1f:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  220b23:	48 89 0d fe f4 02 00 	mov    QWORD PTR [rip+0x2f4fe],rcx        # 250028 <emfile_promise_queue>
            if (node.next) |next_node| {
  220b2a:	48 85 c9             	test   rcx,rcx
  220b2d:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  220b30:	48 8d 35 f9 f4 02 00 	lea    rsi,[rip+0x2f4f9]        # 250030 <emfile_promise_queue+0x8>
  220b37:	48 0f 45 f1          	cmovne rsi,rcx
  220b3b:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  220b3e:	48 83 05 f2 f4 02 00 	add    QWORD PTR [rip+0x2f4f2],0xffffffffffffffff        # 250038 <emfile_promise_queue+0x10>
  220b45:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  220b46:	74 1e                	je     220b66 <openSelfDebugInfo+0x1096>
  220b48:	48 83 3d d8 f4 02 00 	cmp    QWORD PTR [rip+0x2f4d8],0x0        # 250028 <emfile_promise_queue>
  220b4f:	00 
  220b50:	0f 84 de 2f 00 00    	je     223b34 <openSelfDebugInfo+0x4064>
  220b56:	48 8b 0d d3 f4 02 00 	mov    rcx,QWORD PTR [rip+0x2f4d3]        # 250030 <emfile_promise_queue+0x8>
  220b5d:	48 85 c9             	test   rcx,rcx
  220b60:	0f 84 ce 2f 00 00    	je     223b34 <openSelfDebugInfo+0x4064>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  220b66:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  220b6a:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  220b6e:	48 89 c1             	mov    rcx,rax
  220b71:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  220b75:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  220b7b:	75 f1                	jne    220b6e <openSelfDebugInfo+0x109e>
  220b7d:	a8 01                	test   al,0x1
  220b7f:	75 02                	jne    220b83 <openSelfDebugInfo+0x10b3>
  220b81:	ff 17                	call   QWORD PTR [rdi]
  220b83:	49 8b 44 24 10       	mov    rax,QWORD PTR [r12+0x10]
  220b88:	48 89 ac 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rbp
  220b8f:	00 
  220b90:	48 c7 84 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],0xc8
  220b97:	00 c8 00 00 00 
  220b9c:	48 8d b4 24 f0 00 00 	lea    rsi,[rsp+0xf0]
  220ba3:	00 
  220ba4:	4c 89 e7             	mov    rdi,r12
  220ba7:	ff d0                	call   rax
  220ba9:	c5 fa 6f 05 8f 83 fe 	vmovdqu xmm0,XMMWORD PTR [rip+0xfffffffffffe838f]        # 208f40 <__unnamed_60>
  220bb0:	ff 
  220bb1:	c4 c1 7a 7f 06       	vmovdqu XMMWORD PTR [r14],xmm0
  220bb6:	e9 34 fc ff ff       	jmp    2207ef <openSelfDebugInfo+0xd1f>
        const bytes = @sliceToBytes(memory);
  220bbb:	48 8b 45 48          	mov    rax,QWORD PTR [rbp+0x48]
  220bbf:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  220bc3:	74 26                	je     220beb <openSelfDebugInfo+0x111b>
  220bc5:	48 8b 7d 50          	mov    rdi,QWORD PTR [rbp+0x50]
        const bytes = @sliceToBytes(memory);
  220bc9:	48 8b 4d 40          	mov    rcx,QWORD PTR [rbp+0x40]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  220bcd:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  220bd1:	48 89 8c 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rcx
  220bd8:	00 
  220bd9:	48 89 84 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],rax
  220be0:	00 
  220be1:	48 8d b4 24 f0 00 00 	lea    rsi,[rsp+0xf0]
  220be8:	00 
  220be9:	ff d2                	call   rdx
  220beb:	80 7d 10 01          	cmp    BYTE PTR [rbp+0x10],0x1
  220bef:	0f 85 d2 1a 00 00    	jne    2226c7 <openSelfDebugInfo+0x2bf7>
  220bf5:	49 8b 07             	mov    rax,QWORD PTR [r15]
  220bf8:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  220bfb:	b8 03 00 00 00       	mov    eax,0x3
  220c00:	0f 05                	syscall 
            switch (err) {
  220c02:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  220c06:	74 f3                	je     220bfb <openSelfDebugInfo+0x112b>
            const first = list.first orelse return null;
  220c08:	48 8b 05 19 f4 02 00 	mov    rax,QWORD PTR [rip+0x2f419]        # 250028 <emfile_promise_queue>
  220c0f:	48 85 c0             	test   rax,rax
  220c12:	0f 84 af 1a 00 00    	je     2226c7 <openSelfDebugInfo+0x2bf7>
            if (node.prev) |prev_node| {
  220c18:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  220c1b:	48 85 c9             	test   rcx,rcx
  220c1e:	0f 84 3f 1a 00 00    	je     222663 <openSelfDebugInfo+0x2b93>
                prev_node.next = node.next;
  220c24:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  220c28:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  220c2c:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  220c30:	e9 39 1a 00 00       	jmp    22266e <openSelfDebugInfo+0x2b9e>
            st.debug_line = (try st.elf.findSection(".debug_line")) orelse return error.MissingDebugInfo;
  220c35:	48 8b 84 24 18 03 00 	mov    rax,QWORD PTR [rsp+0x318]
  220c3c:	00 
  220c3d:	48 85 c0             	test   rax,rax
  220c40:	0f 84 e4 02 00 00    	je     220f2a <openSelfDebugInfo+0x145a>
  220c46:	48 89 45 78          	mov    QWORD PTR [rbp+0x78],rax
            st.debug_ranges = (try st.elf.findSection(".debug_ranges"));
  220c4a:	48 8d 15 97 e1 02 00 	lea    rdx,[rip+0x2e197]        # 24ede8 <__unnamed_61>
  220c51:	48 8d bc 24 00 03 00 	lea    rdi,[rsp+0x300]
  220c58:	00 
  220c59:	4c 89 fe             	mov    rsi,r15
  220c5c:	e8 ff 3a 00 00       	call   224760 <Elf_findSection>
  220c61:	66 83 bc 24 00 03 00 	cmp    WORD PTR [rsp+0x300],0x0
  220c68:	00 00 
  220c6a:	0f 84 34 03 00 00    	je     220fa4 <openSelfDebugInfo+0x14d4>
        const bytes = @sliceToBytes(memory);
  220c70:	48 8b 45 48          	mov    rax,QWORD PTR [rbp+0x48]
  220c74:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  220c78:	74 26                	je     220ca0 <openSelfDebugInfo+0x11d0>
  220c7a:	48 8b 7d 50          	mov    rdi,QWORD PTR [rbp+0x50]
        const bytes = @sliceToBytes(memory);
  220c7e:	48 8b 4d 40          	mov    rcx,QWORD PTR [rbp+0x40]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  220c82:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  220c86:	48 89 8c 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rcx
  220c8d:	00 
  220c8e:	48 89 84 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],rax
  220c95:	00 
  220c96:	48 8d b4 24 f0 00 00 	lea    rsi,[rsp+0xf0]
  220c9d:	00 
  220c9e:	ff d2                	call   rdx
  220ca0:	80 7d 10 01          	cmp    BYTE PTR [rbp+0x10],0x1
  220ca4:	0f 85 4f 1b 00 00    	jne    2227f9 <openSelfDebugInfo+0x2d29>
  220caa:	49 8b 07             	mov    rax,QWORD PTR [r15]
  220cad:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  220cb0:	b8 03 00 00 00       	mov    eax,0x3
  220cb5:	0f 05                	syscall 
  220cb7:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  220cbb:	74 f3                	je     220cb0 <openSelfDebugInfo+0x11e0>
            const first = list.first orelse return null;
  220cbd:	48 8b 05 64 f3 02 00 	mov    rax,QWORD PTR [rip+0x2f364]        # 250028 <emfile_promise_queue>
  220cc4:	48 85 c0             	test   rax,rax
  220cc7:	0f 84 2c 1b 00 00    	je     2227f9 <openSelfDebugInfo+0x2d29>
            if (node.prev) |prev_node| {
  220ccd:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  220cd0:	48 85 c9             	test   rcx,rcx
  220cd3:	0f 84 bc 1a 00 00    	je     222795 <openSelfDebugInfo+0x2cc5>
                prev_node.next = node.next;
  220cd9:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  220cdd:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  220ce1:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  220ce5:	e9 b6 1a 00 00       	jmp    2227a0 <openSelfDebugInfo+0x2cd0>
                list.first = node.next;
  220cea:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  220cee:	48 89 0d 33 f3 02 00 	mov    QWORD PTR [rip+0x2f333],rcx        # 250028 <emfile_promise_queue>
            if (node.next) |next_node| {
  220cf5:	48 85 c9             	test   rcx,rcx
  220cf8:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  220cfb:	48 8d 35 2e f3 02 00 	lea    rsi,[rip+0x2f32e]        # 250030 <emfile_promise_queue+0x8>
  220d02:	48 0f 45 f1          	cmovne rsi,rcx
  220d06:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  220d09:	48 83 05 27 f3 02 00 	add    QWORD PTR [rip+0x2f327],0xffffffffffffffff        # 250038 <emfile_promise_queue+0x10>
  220d10:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  220d11:	74 1e                	je     220d31 <openSelfDebugInfo+0x1261>
  220d13:	48 83 3d 0d f3 02 00 	cmp    QWORD PTR [rip+0x2f30d],0x0        # 250028 <emfile_promise_queue>
  220d1a:	00 
  220d1b:	0f 84 13 2e 00 00    	je     223b34 <openSelfDebugInfo+0x4064>
  220d21:	48 8b 0d 08 f3 02 00 	mov    rcx,QWORD PTR [rip+0x2f308]        # 250030 <emfile_promise_queue+0x8>
  220d28:	48 85 c9             	test   rcx,rcx
  220d2b:	0f 84 03 2e 00 00    	je     223b34 <openSelfDebugInfo+0x4064>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  220d31:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  220d35:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  220d39:	48 89 c1             	mov    rcx,rax
  220d3c:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  220d40:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  220d46:	75 f1                	jne    220d39 <openSelfDebugInfo+0x1269>
  220d48:	a8 01                	test   al,0x1
  220d4a:	75 02                	jne    220d4e <openSelfDebugInfo+0x127e>
  220d4c:	ff 17                	call   QWORD PTR [rdi]
  220d4e:	48 63 7d 00          	movsxd rdi,DWORD PTR [rbp+0x0]
  220d52:	b8 03 00 00 00       	mov    eax,0x3
  220d57:	0f 05                	syscall 
            switch (err) {
  220d59:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  220d5d:	74 f3                	je     220d52 <openSelfDebugInfo+0x1282>
            const first = list.first orelse return null;
  220d5f:	48 8b 05 c2 f2 02 00 	mov    rax,QWORD PTR [rip+0x2f2c2]        # 250028 <emfile_promise_queue>
  220d66:	48 85 c0             	test   rax,rax
  220d69:	74 7a                	je     220de5 <openSelfDebugInfo+0x1315>
            if (node.prev) |prev_node| {
  220d6b:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  220d6e:	48 85 c9             	test   rcx,rcx
  220d71:	74 0e                	je     220d81 <openSelfDebugInfo+0x12b1>
                prev_node.next = node.next;
  220d73:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  220d77:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  220d7b:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  220d7f:	eb 0b                	jmp    220d8c <openSelfDebugInfo+0x12bc>
                list.first = node.next;
  220d81:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  220d85:	48 89 0d 9c f2 02 00 	mov    QWORD PTR [rip+0x2f29c],rcx        # 250028 <emfile_promise_queue>
            if (node.next) |next_node| {
  220d8c:	48 85 c9             	test   rcx,rcx
  220d8f:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  220d92:	48 8d 35 97 f2 02 00 	lea    rsi,[rip+0x2f297]        # 250030 <emfile_promise_queue+0x8>
  220d99:	48 0f 45 f1          	cmovne rsi,rcx
  220d9d:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  220da0:	48 83 05 90 f2 02 00 	add    QWORD PTR [rip+0x2f290],0xffffffffffffffff        # 250038 <emfile_promise_queue+0x10>
  220da7:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  220da8:	74 1e                	je     220dc8 <openSelfDebugInfo+0x12f8>
  220daa:	48 83 3d 76 f2 02 00 	cmp    QWORD PTR [rip+0x2f276],0x0        # 250028 <emfile_promise_queue>
  220db1:	00 
  220db2:	0f 84 7c 2d 00 00    	je     223b34 <openSelfDebugInfo+0x4064>
  220db8:	48 8b 0d 71 f2 02 00 	mov    rcx,QWORD PTR [rip+0x2f271]        # 250030 <emfile_promise_queue+0x8>
  220dbf:	48 85 c9             	test   rcx,rcx
  220dc2:	0f 84 6c 2d 00 00    	je     223b34 <openSelfDebugInfo+0x4064>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  220dc8:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  220dcc:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  220dd0:	48 89 c1             	mov    rcx,rax
  220dd3:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  220dd7:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  220ddd:	75 f1                	jne    220dd0 <openSelfDebugInfo+0x1300>
  220ddf:	a8 01                	test   al,0x1
  220de1:	75 02                	jne    220de5 <openSelfDebugInfo+0x1315>
  220de3:	ff 17                	call   QWORD PTR [rdi]
        self.freeFn(self, non_const_ptr[0..@sizeOf(@typeOf(ptr).Child)]);
  220de5:	49 8b 44 24 10       	mov    rax,QWORD PTR [r12+0x10]
  220dea:	48 89 ac 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rbp
  220df1:	00 
  220df2:	48 c7 84 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],0xc8
  220df9:	00 c8 00 00 00 
  220dfe:	48 8d b4 24 f0 00 00 	lea    rsi,[rsp+0xf0]
  220e05:	00 
  220e06:	4c 89 e7             	mov    rdi,r12
  220e09:	ff d0                	call   rax
            st.debug_str = (try st.elf.findSection(".debug_str")) orelse return error.MissingDebugInfo;
  220e0b:	0f b7 84 24 20 03 00 	movzx  eax,WORD PTR [rsp+0x320]
  220e12:	00 
  220e13:	66 41 89 06          	mov    WORD PTR [r14],ax
  220e17:	48 8b 84 24 cc 04 00 	mov    rax,QWORD PTR [rsp+0x4cc]
  220e1e:	00 
  220e1f:	48 8b 8c 24 d2 04 00 	mov    rcx,QWORD PTR [rsp+0x4d2]
  220e26:	00 
  220e27:	e9 bb f9 ff ff       	jmp    2207e7 <openSelfDebugInfo+0xd17>
                list.first = node.next;
  220e2c:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  220e30:	48 89 0d f1 f1 02 00 	mov    QWORD PTR [rip+0x2f1f1],rcx        # 250028 <emfile_promise_queue>
            if (node.next) |next_node| {
  220e37:	48 85 c9             	test   rcx,rcx
  220e3a:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  220e3d:	48 8d 35 ec f1 02 00 	lea    rsi,[rip+0x2f1ec]        # 250030 <emfile_promise_queue+0x8>
  220e44:	48 0f 45 f1          	cmovne rsi,rcx
  220e48:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  220e4b:	48 83 05 e5 f1 02 00 	add    QWORD PTR [rip+0x2f1e5],0xffffffffffffffff        # 250038 <emfile_promise_queue+0x10>
  220e52:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  220e53:	74 1e                	je     220e73 <openSelfDebugInfo+0x13a3>
  220e55:	48 83 3d cb f1 02 00 	cmp    QWORD PTR [rip+0x2f1cb],0x0        # 250028 <emfile_promise_queue>
  220e5c:	00 
  220e5d:	0f 84 d1 2c 00 00    	je     223b34 <openSelfDebugInfo+0x4064>
  220e63:	48 8b 0d c6 f1 02 00 	mov    rcx,QWORD PTR [rip+0x2f1c6]        # 250030 <emfile_promise_queue+0x8>
  220e6a:	48 85 c9             	test   rcx,rcx
  220e6d:	0f 84 c1 2c 00 00    	je     223b34 <openSelfDebugInfo+0x4064>
  220e73:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  220e77:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  220e7b:	48 89 c1             	mov    rcx,rax
  220e7e:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  220e82:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  220e88:	75 f1                	jne    220e7b <openSelfDebugInfo+0x13ab>
  220e8a:	a8 01                	test   al,0x1
  220e8c:	75 02                	jne    220e90 <openSelfDebugInfo+0x13c0>
  220e8e:	ff 17                	call   QWORD PTR [rdi]
  220e90:	48 63 7d 00          	movsxd rdi,DWORD PTR [rbp+0x0]
  220e94:	b8 03 00 00 00       	mov    eax,0x3
  220e99:	0f 05                	syscall 
            switch (err) {
  220e9b:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  220e9f:	74 f3                	je     220e94 <openSelfDebugInfo+0x13c4>
            const first = list.first orelse return null;
  220ea1:	48 8b 05 80 f1 02 00 	mov    rax,QWORD PTR [rip+0x2f180]        # 250028 <emfile_promise_queue>
  220ea8:	48 85 c0             	test   rax,rax
  220eab:	0f 84 d2 fc ff ff    	je     220b83 <openSelfDebugInfo+0x10b3>
            if (node.prev) |prev_node| {
  220eb1:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  220eb4:	48 85 c9             	test   rcx,rcx
  220eb7:	74 0e                	je     220ec7 <openSelfDebugInfo+0x13f7>
                prev_node.next = node.next;
  220eb9:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  220ebd:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  220ec1:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  220ec5:	eb 0b                	jmp    220ed2 <openSelfDebugInfo+0x1402>
                list.first = node.next;
  220ec7:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  220ecb:	48 89 0d 56 f1 02 00 	mov    QWORD PTR [rip+0x2f156],rcx        # 250028 <emfile_promise_queue>
            if (node.next) |next_node| {
  220ed2:	48 85 c9             	test   rcx,rcx
  220ed5:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  220ed8:	48 8d 35 51 f1 02 00 	lea    rsi,[rip+0x2f151]        # 250030 <emfile_promise_queue+0x8>
  220edf:	48 0f 45 f1          	cmovne rsi,rcx
  220ee3:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  220ee6:	48 83 05 4a f1 02 00 	add    QWORD PTR [rip+0x2f14a],0xffffffffffffffff        # 250038 <emfile_promise_queue+0x10>
  220eed:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  220eee:	74 1e                	je     220f0e <openSelfDebugInfo+0x143e>
  220ef0:	48 83 3d 30 f1 02 00 	cmp    QWORD PTR [rip+0x2f130],0x0        # 250028 <emfile_promise_queue>
  220ef7:	00 
  220ef8:	0f 84 36 2c 00 00    	je     223b34 <openSelfDebugInfo+0x4064>
  220efe:	48 8b 0d 2b f1 02 00 	mov    rcx,QWORD PTR [rip+0x2f12b]        # 250030 <emfile_promise_queue+0x8>
  220f05:	48 85 c9             	test   rcx,rcx
  220f08:	0f 84 26 2c 00 00    	je     223b34 <openSelfDebugInfo+0x4064>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  220f0e:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  220f12:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  220f16:	48 89 c1             	mov    rcx,rax
  220f19:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  220f1d:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  220f23:	75 f1                	jne    220f16 <openSelfDebugInfo+0x1446>
  220f25:	e9 53 fc ff ff       	jmp    220b7d <openSelfDebugInfo+0x10ad>
        const bytes = @sliceToBytes(memory);
  220f2a:	48 8b 45 48          	mov    rax,QWORD PTR [rbp+0x48]
  220f2e:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  220f32:	74 26                	je     220f5a <openSelfDebugInfo+0x148a>
  220f34:	48 8b 7d 50          	mov    rdi,QWORD PTR [rbp+0x50]
        const bytes = @sliceToBytes(memory);
  220f38:	48 8b 4d 40          	mov    rcx,QWORD PTR [rbp+0x40]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  220f3c:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  220f40:	48 89 8c 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rcx
  220f47:	00 
  220f48:	48 89 84 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],rax
  220f4f:	00 
  220f50:	48 8d b4 24 f0 00 00 	lea    rsi,[rsp+0xf0]
  220f57:	00 
  220f58:	ff d2                	call   rdx
  220f5a:	80 7d 10 01          	cmp    BYTE PTR [rbp+0x10],0x1
  220f5e:	0f 85 d7 19 00 00    	jne    22293b <openSelfDebugInfo+0x2e6b>
  220f64:	49 8b 07             	mov    rax,QWORD PTR [r15]
  220f67:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  220f6a:	b8 03 00 00 00       	mov    eax,0x3
  220f6f:	0f 05                	syscall 
            switch (err) {
  220f71:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  220f75:	74 f3                	je     220f6a <openSelfDebugInfo+0x149a>
            const first = list.first orelse return null;
  220f77:	48 8b 05 aa f0 02 00 	mov    rax,QWORD PTR [rip+0x2f0aa]        # 250028 <emfile_promise_queue>
  220f7e:	48 85 c0             	test   rax,rax
  220f81:	0f 84 b4 19 00 00    	je     22293b <openSelfDebugInfo+0x2e6b>
            if (node.prev) |prev_node| {
  220f87:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  220f8a:	48 85 c9             	test   rcx,rcx
  220f8d:	0f 84 44 19 00 00    	je     2228d7 <openSelfDebugInfo+0x2e07>
                prev_node.next = node.next;
  220f93:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  220f97:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  220f9b:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  220f9f:	e9 3e 19 00 00       	jmp    2228e2 <openSelfDebugInfo+0x2e12>
            st.debug_ranges = (try st.elf.findSection(".debug_ranges"));
  220fa4:	48 8b 84 24 08 03 00 	mov    rax,QWORD PTR [rsp+0x308]
  220fab:	00 
  220fac:	48 89 85 80 00 00 00 	mov    QWORD PTR [rbp+0x80],rax
    const debug_info_end = st.debug_info.offset + st.debug_info.size;
  220fb3:	48 8b 45 60          	mov    rax,QWORD PTR [rbp+0x60]
  220fb7:	48 8b 48 18          	mov    rcx,QWORD PTR [rax+0x18]
  220fbb:	48 89 4c 24 68       	mov    QWORD PTR [rsp+0x68],rcx
  220fc0:	48 8b 48 20          	mov    rcx,QWORD PTR [rax+0x20]
    var in_file_stream = io.FileInStream.init(&st.self_exe_file);
  220fc4:	48 89 ac 24 b0 01 00 	mov    QWORD PTR [rsp+0x1b0],rbp
  220fcb:	00 
  220fcc:	48 8d 05 fd 3c 00 00 	lea    rax,[rip+0x3cfd]        # 224cd0 <FileInStream_readFn>
  220fd3:	48 89 84 24 b8 01 00 	mov    QWORD PTR [rsp+0x1b8],rax
  220fda:	00 
  220fdb:	48 89 8c 24 90 00 00 	mov    QWORD PTR [rsp+0x90],rcx
  220fe2:	00 
    while (this_unit_offset < debug_info_end) {
  220fe3:	48 85 c9             	test   rcx,rcx
  220fe6:	0f 84 75 17 00 00    	je     222761 <openSelfDebugInfo+0x2c91>
  220fec:	48 8d 85 88 00 00 00 	lea    rax,[rbp+0x88]
  220ff3:	48 89 84 24 68 02 00 	mov    QWORD PTR [rsp+0x268],rax
  220ffa:	00 
  220ffb:	48 8d 85 a8 00 00 00 	lea    rax,[rbp+0xa8]
  221002:	48 89 44 24 70       	mov    QWORD PTR [rsp+0x70],rax
  221007:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  22100c:	48 01 84 24 90 00 00 	add    QWORD PTR [rsp+0x90],rax
  221013:	00 
  221014:	c4 e2 7d 19 05 f3 f2 	vbroadcastsd ymm0,QWORD PTR [rip+0xfffffffffffdf2f3]        # 200310 <__unnamed_610+0x10>
  22101b:	fd ff 
  22101d:	c5 fc 11 84 24 40 05 	vmovups YMMWORD PTR [rsp+0x540],ymm0
  221024:	00 00 
  221026:	c4 e2 7d 59 05 59 f3 	vpbroadcastq ymm0,QWORD PTR [rip+0xfffffffffffdf359]        # 200388 <__unnamed_609+0x48>
  22102d:	fd ff 
  22102f:	c5 fe 7f 84 24 20 05 	vmovdqu YMMWORD PTR [rsp+0x520],ymm0
  221036:	00 00 
  221038:	66 c7 84 24 c8 01 00 	mov    WORD PTR [rsp+0x1c8],0x27
  22103f:	00 27 00 
  221042:	31 c0                	xor    eax,eax
  221044:	48 89 84 24 80 01 00 	mov    QWORD PTR [rsp+0x180],rax
  22104b:	00 
    if (@maxValue(@typeOf(x)) > @maxValue(T) and x > @maxValue(T)) {
  22104c:	48 83 7c 24 68 00    	cmp    QWORD PTR [rsp+0x68],0x0
  221052:	0f 88 11 1a 00 00    	js     222a69 <openSelfDebugInfo+0x2f99>
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  221058:	48 63 7d 00          	movsxd rdi,DWORD PTR [rbp+0x0]
    return asm volatile ("syscall"
  22105c:	b8 08 00 00 00       	mov    eax,0x8
  221061:	31 d2                	xor    edx,edx
  221063:	48 8b 74 24 68       	mov    rsi,QWORD PTR [rsp+0x68]
  221068:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  22106a:	48 89 c1             	mov    rcx,rax
  22106d:	48 f7 d9             	neg    rcx
  221070:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  221076:	b8 00 00 00 00       	mov    eax,0x0
  22107b:	48 0f 46 c8          	cmovbe rcx,rax
                if (err > 0) {
  22107f:	48 85 c9             	test   rcx,rcx
  221082:	0f 85 09 1a 00 00    	jne    222a91 <openSelfDebugInfo+0x2fc1>
            try self.readNoEof(bytes[0..]);
  221088:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  22108d:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  221094:	00 
  221095:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x4
  22109c:	00 04 00 00 00 
            return self.readFn(self, buffer);
  2210a1:	48 89 df             	mov    rdi,rbx
  2210a4:	48 8d b4 24 b8 01 00 	lea    rsi,[rsp+0x1b8]
  2210ab:	00 
  2210ac:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  2210b3:	00 
  2210b4:	c5 f8 77             	vzeroupper 
  2210b7:	ff 94 24 b8 01 00 00 	call   QWORD PTR [rsp+0x1b8]
  2210be:	0f b7 8c 24 f0 00 00 	movzx  ecx,WORD PTR [rsp+0xf0]
  2210c5:	00 
  2210c6:	89 c8                	mov    eax,ecx
            const amt_read = try self.read(buf);
  2210c8:	66 85 c9             	test   cx,cx
  2210cb:	0f 85 46 19 00 00    	jne    222a17 <openSelfDebugInfo+0x2f47>
  2210d1:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  2210d8:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  2210d9:	48 3b 84 24 a0 00 00 	cmp    rax,QWORD PTR [rsp+0xa0]
  2210e0:	00 
  2210e1:	0f 82 2c 19 00 00    	jb     222a13 <openSelfDebugInfo+0x2f43>
  2210e7:	0f b6 44 24 20       	movzx  eax,BYTE PTR [rsp+0x20]
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  2210ec:	0f b6 4c 24 21       	movzx  ecx,BYTE PTR [rsp+0x21]
  2210f1:	48 c1 e1 08          	shl    rcx,0x8
  2210f5:	48 09 c1             	or     rcx,rax
  2210f8:	0f b6 44 24 22       	movzx  eax,BYTE PTR [rsp+0x22]
  2210fd:	48 c1 e0 10          	shl    rax,0x10
  221101:	48 09 c8             	or     rax,rcx
  221104:	0f b6 4c 24 23       	movzx  ecx,BYTE PTR [rsp+0x23]
  221109:	48 c1 e1 18          	shl    rcx,0x18
  22110d:	48 09 c1             	or     rcx,rax
  221110:	48 89 4c 24 78       	mov    QWORD PTR [rsp+0x78],rcx
    is_64.* = (first_32_bits == 0xffffffff);
  221115:	83 f9 ff             	cmp    ecx,0xffffffff
    if (is_64.*) {
  221118:	74 27                	je     221141 <openSelfDebugInfo+0x1671>
        if (first_32_bits >= 0xfffffff0) return error.InvalidDebugInfo;
  22111a:	83 7c 24 78 ef       	cmp    DWORD PTR [rsp+0x78],0xffffffef
  22111f:	0f 87 58 19 00 00    	ja     222a7d <openSelfDebugInfo+0x2fad>
  221125:	c7 84 24 80 00 00 00 	mov    DWORD PTR [rsp+0x80],0x0
  22112c:	00 00 00 00 
        if (unit_length == 0) return;
  221130:	48 83 7c 24 78 00    	cmp    QWORD PTR [rsp+0x78],0x0
  221136:	0f 85 86 00 00 00    	jne    2211c2 <openSelfDebugInfo+0x16f2>
  22113c:	e9 20 16 00 00       	jmp    222761 <openSelfDebugInfo+0x2c91>
            try self.readNoEof(bytes[0..]);
  221141:	48 8d 84 24 d8 03 00 	lea    rax,[rsp+0x3d8]
  221148:	00 
  221149:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  221150:	00 
  221151:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x8
  221158:	00 08 00 00 00 
            return self.readFn(self, buffer);
  22115d:	48 89 df             	mov    rdi,rbx
  221160:	48 8d b4 24 b8 01 00 	lea    rsi,[rsp+0x1b8]
  221167:	00 
  221168:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  22116f:	00 
  221170:	ff 94 24 b8 01 00 00 	call   QWORD PTR [rsp+0x1b8]
  221177:	0f b7 8c 24 f0 00 00 	movzx  ecx,WORD PTR [rsp+0xf0]
  22117e:	00 
  22117f:	89 c8                	mov    eax,ecx
            const amt_read = try self.read(buf);
  221181:	66 85 c9             	test   cx,cx
  221184:	0f 85 8d 18 00 00    	jne    222a17 <openSelfDebugInfo+0x2f47>
  22118a:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  221191:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  221192:	48 3b 84 24 a0 00 00 	cmp    rax,QWORD PTR [rsp+0xa0]
  221199:	00 
  22119a:	0f 82 73 18 00 00    	jb     222a13 <openSelfDebugInfo+0x2f43>
  2211a0:	48 8b 84 24 d8 03 00 	mov    rax,QWORD PTR [rsp+0x3d8]
  2211a7:	00 
  2211a8:	48 89 44 24 78       	mov    QWORD PTR [rsp+0x78],rax
  2211ad:	b0 01                	mov    al,0x1
        const unit_length = try readInitialLength(@typeOf(in_stream.readFn).ReturnType.ErrorSet, in_stream, &is_64);
  2211af:	89 84 24 80 00 00 00 	mov    DWORD PTR [rsp+0x80],eax
        if (unit_length == 0) return;
  2211b6:	48 83 7c 24 78 00    	cmp    QWORD PTR [rsp+0x78],0x0
  2211bc:	0f 84 9f 15 00 00    	je     222761 <openSelfDebugInfo+0x2c91>
        const version = try in_stream.readInt(st.elf.endian, u16);
  2211c2:	44 8a 6d 12          	mov    r13b,BYTE PTR [rbp+0x12]
            try self.readNoEof(bytes[0..]);
  2211c6:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  2211cb:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  2211d2:	00 
  2211d3:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x2
  2211da:	00 02 00 00 00 
            return self.readFn(self, buffer);
  2211df:	48 89 df             	mov    rdi,rbx
  2211e2:	48 8d b4 24 b8 01 00 	lea    rsi,[rsp+0x1b8]
  2211e9:	00 
  2211ea:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  2211f1:	00 
  2211f2:	ff 94 24 b8 01 00 00 	call   QWORD PTR [rsp+0x1b8]
  2211f9:	0f b7 8c 24 f0 00 00 	movzx  ecx,WORD PTR [rsp+0xf0]
  221200:	00 
  221201:	89 c8                	mov    eax,ecx
            const amt_read = try self.read(buf);
  221203:	66 85 c9             	test   cx,cx
  221206:	0f 85 0b 18 00 00    	jne    222a17 <openSelfDebugInfo+0x2f47>
  22120c:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  221213:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  221214:	48 3b 84 24 a0 00 00 	cmp    rax,QWORD PTR [rsp+0xa0]
  22121b:	00 
  22121c:	0f 82 f1 17 00 00    	jb     222a13 <openSelfDebugInfo+0x2f43>
  221222:	0f b6 54 24 20       	movzx  edx,BYTE PTR [rsp+0x20]
  221227:	0f b6 44 24 21       	movzx  eax,BYTE PTR [rsp+0x21]
  22122c:	89 c1                	mov    ecx,eax
  22122e:	c1 e1 08             	shl    ecx,0x8
  221231:	09 d1                	or     ecx,edx
                result = (result << 8) | b;
  221233:	c1 e2 08             	shl    edx,0x8
  221236:	09 c2                	or     edx,eax
    switch (endian) {
  221238:	41 f6 c5 01          	test   r13b,0x1
  22123c:	66 0f 45 d1          	cmovne dx,cx
  221240:	48 89 94 24 f8 02 00 	mov    QWORD PTR [rsp+0x2f8],rdx
  221247:	00 
        if (version < 2 or version > 5) return error.InvalidDebugInfo;
  221248:	8d 42 fe             	lea    eax,[rdx-0x2]
  22124b:	0f b7 c0             	movzx  eax,ax
  22124e:	83 f8 03             	cmp    eax,0x3
  221251:	0f 87 26 18 00 00    	ja     222a7d <openSelfDebugInfo+0x2fad>
  221257:	44 8a 6d 12          	mov    r13b,BYTE PTR [rbp+0x12]
        const debug_abbrev_offset = if (is_64) try in_stream.readInt(st.elf.endian, u64) else try in_stream.readInt(st.elf.endian, u32);
  22125b:	80 bc 24 80 00 00 00 	cmp    BYTE PTR [rsp+0x80],0x0
  221262:	00 
  221263:	74 37                	je     22129c <openSelfDebugInfo+0x17cc>
  221265:	41 0f b6 d5          	movzx  edx,r13b
  221269:	48 8d bc 24 c8 03 00 	lea    rdi,[rsp+0x3c8]
  221270:	00 
  221271:	48 8d b4 24 b8 01 00 	lea    rsi,[rsp+0x1b8]
  221278:	00 
  221279:	e8 f2 37 00 00       	call   224a70 <InStream(ReadError)_readInt.147>
  22127e:	0f b7 bc 24 c8 03 00 	movzx  edi,WORD PTR [rsp+0x3c8]
  221285:	00 
  221286:	66 85 ff             	test   di,di
  221289:	0f 85 c9 18 00 00    	jne    222b58 <openSelfDebugInfo+0x3088>
  22128f:	48 8b 84 24 d0 03 00 	mov    rax,QWORD PTR [rsp+0x3d0]
  221296:	00 
  221297:	e9 a2 00 00 00       	jmp    22133e <openSelfDebugInfo+0x186e>
            try self.readNoEof(bytes[0..]);
  22129c:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  2212a1:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  2212a8:	00 
  2212a9:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x4
  2212b0:	00 04 00 00 00 
            return self.readFn(self, buffer);
  2212b5:	48 89 df             	mov    rdi,rbx
  2212b8:	48 8d b4 24 b8 01 00 	lea    rsi,[rsp+0x1b8]
  2212bf:	00 
  2212c0:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  2212c7:	00 
  2212c8:	ff 94 24 b8 01 00 00 	call   QWORD PTR [rsp+0x1b8]
  2212cf:	0f b7 8c 24 f0 00 00 	movzx  ecx,WORD PTR [rsp+0xf0]
  2212d6:	00 
  2212d7:	89 c8                	mov    eax,ecx
            const amt_read = try self.read(buf);
  2212d9:	66 85 c9             	test   cx,cx
  2212dc:	0f 85 35 17 00 00    	jne    222a17 <openSelfDebugInfo+0x2f47>
  2212e2:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  2212e9:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  2212ea:	48 3b 84 24 a0 00 00 	cmp    rax,QWORD PTR [rsp+0xa0]
  2212f1:	00 
  2212f2:	0f 82 1b 17 00 00    	jb     222a13 <openSelfDebugInfo+0x2f43>
  2212f8:	0f b6 44 24 20       	movzx  eax,BYTE PTR [rsp+0x20]
  2212fd:	0f b6 4c 24 21       	movzx  ecx,BYTE PTR [rsp+0x21]
  221302:	41 f6 c5 01          	test   r13b,0x1
  221306:	74 1b                	je     221323 <openSelfDebugInfo+0x1853>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  221308:	c1 e1 08             	shl    ecx,0x8
  22130b:	09 c1                	or     ecx,eax
  22130d:	0f b6 54 24 22       	movzx  edx,BYTE PTR [rsp+0x22]
  221312:	c1 e2 10             	shl    edx,0x10
  221315:	09 ca                	or     edx,ecx
  221317:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  22131c:	c1 e0 18             	shl    eax,0x18
  22131f:	09 d0                	or     eax,edx
  221321:	eb 19                	jmp    22133c <openSelfDebugInfo+0x186c>
                result = (result << 8) | b;
  221323:	c1 e0 08             	shl    eax,0x8
  221326:	09 c8                	or     eax,ecx
  221328:	c1 e0 08             	shl    eax,0x8
  22132b:	0f b6 4c 24 22       	movzx  ecx,BYTE PTR [rsp+0x22]
  221330:	09 c1                	or     ecx,eax
  221332:	c1 e1 08             	shl    ecx,0x8
  221335:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  22133a:	09 c8                	or     eax,ecx
  22133c:	89 c0                	mov    eax,eax
  22133e:	48 89 44 24 48       	mov    QWORD PTR [rsp+0x48],rax
            try self.readNoEof(result[0..]);
  221343:	48 8d 44 24 1f       	lea    rax,[rsp+0x1f]
  221348:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  22134f:	00 
  221350:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x1
  221357:	00 01 00 00 00 
            return self.readFn(self, buffer);
  22135c:	48 89 df             	mov    rdi,rbx
  22135f:	48 8d b4 24 b8 01 00 	lea    rsi,[rsp+0x1b8]
  221366:	00 
  221367:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  22136e:	00 
  22136f:	ff 94 24 b8 01 00 00 	call   QWORD PTR [rsp+0x1b8]
  221376:	0f b7 8c 24 f0 00 00 	movzx  ecx,WORD PTR [rsp+0xf0]
  22137d:	00 
  22137e:	89 c8                	mov    eax,ecx
            const amt_read = try self.read(buf);
  221380:	66 85 c9             	test   cx,cx
  221383:	0f 85 8e 16 00 00    	jne    222a17 <openSelfDebugInfo+0x2f47>
  221389:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  221390:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  221391:	48 3b 84 24 a0 00 00 	cmp    rax,QWORD PTR [rsp+0xa0]
  221398:	00 
  221399:	0f 82 74 16 00 00    	jb     222a13 <openSelfDebugInfo+0x2f43>
        if (address_size != @sizeOf(usize)) return error.InvalidDebugInfo;
  22139f:	80 7c 24 1f 08       	cmp    BYTE PTR [rsp+0x1f],0x8
  2213a4:	66 bf 29 00          	mov    di,0x29
  2213a8:	0f 85 aa 17 00 00    	jne    222b58 <openSelfDebugInfo+0x3088>
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  2213ae:	48 63 7d 00          	movsxd rdi,DWORD PTR [rbp+0x0]
  2213b2:	b8 08 00 00 00       	mov    eax,0x8
  2213b7:	be 00 00 00 00       	mov    esi,0x0
  2213bc:	ba 01 00 00 00       	mov    edx,0x1
  2213c1:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  2213c3:	48 89 c6             	mov    rsi,rax
  2213c6:	48 f7 de             	neg    rsi
  2213c9:	48 89 84 24 88 00 00 	mov    QWORD PTR [rsp+0x88],rax
  2213d0:	00 
  2213d1:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  2213d7:	b9 00 00 00 00       	mov    ecx,0x0
  2213dc:	48 0f 46 f1          	cmovbe rsi,rcx
    pub fn getPos(self: *File) !usize {
        switch (builtin.os) {
            Os.linux, Os.macosx, Os.ios => {
                const result = posix.lseek(self.handle, 0, posix.SEEK_CUR);
                const err = posix.getErrno(result);
                if (err > 0) {
  2213e0:	48 85 f6             	test   rsi,rsi
  2213e3:	0f 85 33 17 00 00    	jne    222b1c <openSelfDebugInfo+0x304c>
            return self.items[0..self.len];
  2213e9:	48 8b 85 98 00 00 00 	mov    rax,QWORD PTR [rbp+0x98]
    for (st.abbrev_table_list.toSlice()) |*header| {
  2213f0:	48 85 c0             	test   rax,rax
  2213f3:	48 8b 54 24 48       	mov    rdx,QWORD PTR [rsp+0x48]
  2213f8:	74 24                	je     22141e <openSelfDebugInfo+0x194e>
  2213fa:	4c 8b ad 88 00 00 00 	mov    r13,QWORD PTR [rbp+0x88]
        if (header.offset == abbrev_offset) {
  221401:	49 83 c5 08          	add    r13,0x8
  221405:	31 c9                	xor    ecx,ecx
  221407:	49 39 55 f8          	cmp    QWORD PTR [r13-0x8],rdx
  22140b:	0f 84 7d 08 00 00    	je     221c8e <openSelfDebugInfo+0x21be>
    for (st.abbrev_table_list.toSlice()) |*header| {
  221411:	48 83 c1 01          	add    rcx,0x1
  221415:	49 83 c5 28          	add    r13,0x28
  221419:	48 39 c1             	cmp    rcx,rax
  22141c:	72 e9                	jb     221407 <openSelfDebugInfo+0x1937>
    try st.self_exe_file.seekTo(st.debug_abbrev.offset + abbrev_offset);
  22141e:	48 8b 45 68          	mov    rax,QWORD PTR [rbp+0x68]
  221422:	48 8b 70 18          	mov    rsi,QWORD PTR [rax+0x18]
  221426:	48 01 d6             	add    rsi,rdx
  221429:	0f 88 3a 16 00 00    	js     222a69 <openSelfDebugInfo+0x2f99>
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  22142f:	48 63 7d 00          	movsxd rdi,DWORD PTR [rbp+0x0]
  221433:	b8 08 00 00 00       	mov    eax,0x8
  221438:	31 d2                	xor    edx,edx
  22143a:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  22143c:	48 89 c1             	mov    rcx,rax
  22143f:	48 f7 d9             	neg    rcx
  221442:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  221448:	b8 00 00 00 00       	mov    eax,0x0
  22144d:	48 0f 46 c8          	cmovbe rcx,rax
                if (err > 0) {
  221451:	48 85 c9             	test   rcx,rcx
  221454:	0f 85 be 18 00 00    	jne    222d18 <openSelfDebugInfo+0x3248>
    var in_file_stream = io.FileInStream.init(in_file);
  22145a:	48 89 ac 24 88 01 00 	mov    QWORD PTR [rsp+0x188],rbp
  221461:	00 
  221462:	48 8d 05 67 38 00 00 	lea    rax,[rip+0x3867]        # 224cd0 <FileInStream_readFn>
  221469:	48 89 84 24 90 01 00 	mov    QWORD PTR [rsp+0x190],rax
  221470:	00 
  221471:	48 8b 85 a0 00 00 00 	mov    rax,QWORD PTR [rbp+0xa0]
            return Self{
  221478:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  22147c:	c5 f9 7f 84 24 10 02 	vmovdqa XMMWORD PTR [rsp+0x210],xmm0
  221483:	00 00 
  221485:	48 c7 84 24 20 02 00 	mov    QWORD PTR [rsp+0x220],0x0
  22148c:	00 00 00 00 00 
  221491:	48 89 84 24 30 02 00 	mov    QWORD PTR [rsp+0x230],rax
  221498:	00 
    var result = AbbrevTable.init(st.allocator());
  221499:	48 89 84 24 28 02 00 	mov    QWORD PTR [rsp+0x228],rax
  2214a0:	00 
            try self.readNoEof(result[0..]);
  2214a1:	48 8d 44 24 1f       	lea    rax,[rsp+0x1f]
  2214a6:	48 89 84 24 00 02 00 	mov    QWORD PTR [rsp+0x200],rax
  2214ad:	00 
  2214ae:	48 c7 84 24 08 02 00 	mov    QWORD PTR [rsp+0x208],0x1
  2214b5:	00 01 00 00 00 
        return self.file.read(buffer);
  2214ba:	48 8b b4 24 88 01 00 	mov    rsi,QWORD PTR [rsp+0x188]
  2214c1:	00 
  2214c2:	48 8d 7c 24 50       	lea    rdi,[rsp+0x50]
  2214c7:	48 8d 94 24 00 02 00 	lea    rdx,[rsp+0x200]
  2214ce:	00 
  2214cf:	e8 cc 36 00 00       	call   224ba0 <File_read>
  2214d4:	c5 fa 6f 44 24 50    	vmovdqu xmm0,XMMWORD PTR [rsp+0x50]
  2214da:	c5 f9 7f 84 24 d0 00 	vmovdqa XMMWORD PTR [rsp+0xd0],xmm0
  2214e1:	00 00 
            return self.readFn(self, buffer);
  2214e3:	0f b7 8c 24 d0 00 00 	movzx  ecx,WORD PTR [rsp+0xd0]
  2214ea:	00 
            const amt_read = try self.read(buf);
  2214eb:	66 85 c9             	test   cx,cx
  2214ee:	0f 85 eb 14 00 00    	jne    2229df <openSelfDebugInfo+0x2f0f>
  2214f4:	48 8b 84 24 d8 00 00 	mov    rax,QWORD PTR [rsp+0xd8]
  2214fb:	00 
  2214fc:	31 c9                	xor    ecx,ecx
  2214fe:	48 89 8c 24 c0 01 00 	mov    QWORD PTR [rsp+0x1c0],rcx
  221505:	00 
  221506:	31 c9                	xor    ecx,ecx
  221508:	48 89 8c 24 a0 01 00 	mov    QWORD PTR [rsp+0x1a0],rcx
  22150f:	00 
  221510:	31 c9                	xor    ecx,ecx
  221512:	48 89 4c 24 40       	mov    QWORD PTR [rsp+0x40],rcx
  221517:	45 31 ed             	xor    r13d,r13d
            if (amt_read < buf.len) return error.EndOfStream;
  22151a:	48 3b 84 24 08 02 00 	cmp    rax,QWORD PTR [rsp+0x208]
  221521:	00 
  221522:	0f 82 ad 14 00 00    	jb     2229d5 <openSelfDebugInfo+0x2f05>
            return result[0];
  221528:	0f b6 44 24 1f       	movzx  eax,BYTE PTR [rsp+0x1f]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  22152d:	89 c2                	mov    edx,eax
  22152f:	83 e2 7f             	and    edx,0x7f
  221532:	44 89 ee             	mov    esi,r13d
  221535:	83 e6 3f             	and    esi,0x3f
  221538:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  22153d:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  221542:	48 39 d6             	cmp    rsi,rdx
  221545:	0f 85 90 14 00 00    	jne    2229db <openSelfDebugInfo+0x2f0b>
        result |= operand;
  22154b:	48 09 4c 24 40       	or     QWORD PTR [rsp+0x40],rcx
        if ((byte & 0b10000000) == 0) return result;
  221550:	84 c0                	test   al,al
  221552:	79 5a                	jns    2215ae <openSelfDebugInfo+0x1ade>
        shift += 7;
  221554:	49 83 c5 07          	add    r13,0x7
            try self.readNoEof(result[0..]);
  221558:	48 8d 44 24 1f       	lea    rax,[rsp+0x1f]
  22155d:	48 89 84 24 00 02 00 	mov    QWORD PTR [rsp+0x200],rax
  221564:	00 
  221565:	48 c7 84 24 08 02 00 	mov    QWORD PTR [rsp+0x208],0x1
  22156c:	00 01 00 00 00 
            return self.readFn(self, buffer);
  221571:	48 8d bc 24 d0 00 00 	lea    rdi,[rsp+0xd0]
  221578:	00 
  221579:	48 8d b4 24 90 01 00 	lea    rsi,[rsp+0x190]
  221580:	00 
  221581:	48 8d 94 24 00 02 00 	lea    rdx,[rsp+0x200]
  221588:	00 
  221589:	ff 94 24 90 01 00 00 	call   QWORD PTR [rsp+0x190]
  221590:	0f b7 8c 24 d0 00 00 	movzx  ecx,WORD PTR [rsp+0xd0]
  221597:	00 
  221598:	48 8b 84 24 d8 00 00 	mov    rax,QWORD PTR [rsp+0xd8]
  22159f:	00 
            const amt_read = try self.read(buf);
  2215a0:	66 85 c9             	test   cx,cx
  2215a3:	0f 84 71 ff ff ff    	je     22151a <openSelfDebugInfo+0x1a4a>
  2215a9:	e9 31 14 00 00       	jmp    2229df <openSelfDebugInfo+0x2f0f>
        if (abbrev_code == 0) return result;
  2215ae:	48 83 7c 24 40 00    	cmp    QWORD PTR [rsp+0x40],0x0
  2215b4:	0f 84 ca 05 00 00    	je     221b84 <openSelfDebugInfo+0x20b4>
            try self.readNoEof(result[0..]);
  2215ba:	48 8d 44 24 1f       	lea    rax,[rsp+0x1f]
  2215bf:	48 89 84 24 d0 00 00 	mov    QWORD PTR [rsp+0xd0],rax
  2215c6:	00 
  2215c7:	48 c7 84 24 d8 00 00 	mov    QWORD PTR [rsp+0xd8],0x1
  2215ce:	00 01 00 00 00 
            return self.readFn(self, buffer);
  2215d3:	48 8d 7c 24 50       	lea    rdi,[rsp+0x50]
  2215d8:	48 8d b4 24 90 01 00 	lea    rsi,[rsp+0x190]
  2215df:	00 
  2215e0:	48 8d 94 24 d0 00 00 	lea    rdx,[rsp+0xd0]
  2215e7:	00 
  2215e8:	ff 94 24 90 01 00 00 	call   QWORD PTR [rsp+0x190]
  2215ef:	0f b7 44 24 50       	movzx  eax,WORD PTR [rsp+0x50]
  2215f4:	89 c1                	mov    ecx,eax
            const amt_read = try self.read(buf);
  2215f6:	66 85 c0             	test   ax,ax
  2215f9:	0f 85 ff 14 00 00    	jne    222afe <openSelfDebugInfo+0x302e>
  2215ff:	48 8b 44 24 58       	mov    rax,QWORD PTR [rsp+0x58]
  221604:	31 c9                	xor    ecx,ecx
  221606:	48 89 8c 24 98 01 00 	mov    QWORD PTR [rsp+0x198],rcx
  22160d:	00 
  22160e:	45 31 ed             	xor    r13d,r13d
            if (amt_read < buf.len) return error.EndOfStream;
  221611:	48 3b 84 24 d8 00 00 	cmp    rax,QWORD PTR [rsp+0xd8]
  221618:	00 
  221619:	0f 82 d5 14 00 00    	jb     222af4 <openSelfDebugInfo+0x3024>
            return result[0];
  22161f:	0f b6 44 24 1f       	movzx  eax,BYTE PTR [rsp+0x1f]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  221624:	89 c2                	mov    edx,eax
  221626:	83 e2 7f             	and    edx,0x7f
  221629:	44 89 ee             	mov    esi,r13d
  22162c:	83 e6 3f             	and    esi,0x3f
  22162f:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  221634:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  221639:	48 39 d6             	cmp    rsi,rdx
  22163c:	0f 85 b8 14 00 00    	jne    222afa <openSelfDebugInfo+0x302a>
        result |= operand;
  221642:	48 09 8c 24 98 01 00 	or     QWORD PTR [rsp+0x198],rcx
  221649:	00 
        if ((byte & 0b10000000) == 0) return result;
  22164a:	84 c0                	test   al,al
  22164c:	79 53                	jns    2216a1 <openSelfDebugInfo+0x1bd1>
        shift += 7;
  22164e:	49 83 c5 07          	add    r13,0x7
            try self.readNoEof(result[0..]);
  221652:	48 8d 44 24 1f       	lea    rax,[rsp+0x1f]
  221657:	48 89 84 24 d0 00 00 	mov    QWORD PTR [rsp+0xd0],rax
  22165e:	00 
  22165f:	48 c7 84 24 d8 00 00 	mov    QWORD PTR [rsp+0xd8],0x1
  221666:	00 01 00 00 00 
            return self.readFn(self, buffer);
  22166b:	48 8d 7c 24 50       	lea    rdi,[rsp+0x50]
  221670:	48 8d b4 24 90 01 00 	lea    rsi,[rsp+0x190]
  221677:	00 
  221678:	48 8d 94 24 d0 00 00 	lea    rdx,[rsp+0xd0]
  22167f:	00 
  221680:	ff 94 24 90 01 00 00 	call   QWORD PTR [rsp+0x190]
  221687:	0f b7 54 24 50       	movzx  edx,WORD PTR [rsp+0x50]
  22168c:	48 8b 44 24 58       	mov    rax,QWORD PTR [rsp+0x58]
  221691:	89 d1                	mov    ecx,edx
            const amt_read = try self.read(buf);
  221693:	66 85 d2             	test   dx,dx
  221696:	0f 84 75 ff ff ff    	je     221611 <openSelfDebugInfo+0x1b41>
  22169c:	e9 5d 14 00 00       	jmp    222afe <openSelfDebugInfo+0x302e>
            try self.readNoEof(result[0..]);
  2216a1:	48 8d 44 24 1f       	lea    rax,[rsp+0x1f]
  2216a6:	48 89 84 24 d0 00 00 	mov    QWORD PTR [rsp+0xd0],rax
  2216ad:	00 
  2216ae:	48 c7 84 24 d8 00 00 	mov    QWORD PTR [rsp+0xd8],0x1
  2216b5:	00 01 00 00 00 
            return self.readFn(self, buffer);
  2216ba:	48 8d 7c 24 50       	lea    rdi,[rsp+0x50]
  2216bf:	48 8d b4 24 90 01 00 	lea    rsi,[rsp+0x190]
  2216c6:	00 
  2216c7:	48 8d 94 24 d0 00 00 	lea    rdx,[rsp+0xd0]
  2216ce:	00 
  2216cf:	ff 94 24 90 01 00 00 	call   QWORD PTR [rsp+0x190]
  2216d6:	0f b7 44 24 50       	movzx  eax,WORD PTR [rsp+0x50]
  2216db:	89 c1                	mov    ecx,eax
            const amt_read = try self.read(buf);
  2216dd:	66 85 c0             	test   ax,ax
  2216e0:	0f 85 f8 16 00 00    	jne    222dde <openSelfDebugInfo+0x330e>
  2216e6:	48 8b 44 24 58       	mov    rax,QWORD PTR [rsp+0x58]
            if (amt_read < buf.len) return error.EndOfStream;
  2216eb:	48 3b 84 24 d8 00 00 	cmp    rax,QWORD PTR [rsp+0xd8]
  2216f2:	00 
  2216f3:	0f 82 e1 16 00 00    	jb     222dda <openSelfDebugInfo+0x330a>
  2216f9:	48 8b 85 a0 00 00 00 	mov    rax,QWORD PTR [rbp+0xa0]
  221700:	48 89 84 24 a8 01 00 	mov    QWORD PTR [rsp+0x1a8],rax
  221707:	00 
  221708:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  22170c:	c5 f9 7f 44 24 20    	vmovdqa XMMWORD PTR [rsp+0x20],xmm0
            return result[0];
  221712:	8a 44 24 1f          	mov    al,BYTE PTR [rsp+0x1f]
  221716:	88 84 24 ef 00 00 00 	mov    BYTE PTR [rsp+0xef],al
  22171d:	48 c7 44 24 30 00 00 	mov    QWORD PTR [rsp+0x30],0x0
  221724:	00 00 
            var better_capacity = self.items.len;
  221726:	48 8b 8c 24 18 02 00 	mov    rcx,QWORD PTR [rsp+0x218]
  22172d:	00 
            if (better_capacity >= new_capacity) return;
  22172e:	48 3b 8c 24 a0 01 00 	cmp    rcx,QWORD PTR [rsp+0x1a0]
  221735:	00 
  221736:	77 63                	ja     22179b <openSelfDebugInfo+0x1ccb>
                better_capacity += better_capacity / 2 + 8;
  221738:	48 89 c8             	mov    rax,rcx
  22173b:	48 d1 e8             	shr    rax,1
  22173e:	48 01 c1             	add    rcx,rax
  221741:	48 83 c1 08          	add    rcx,0x8
                if (better_capacity >= new_capacity) break;
  221745:	48 3b 8c 24 a0 01 00 	cmp    rcx,QWORD PTR [rsp+0x1a0]
  22174c:	00 
  22174d:	76 e9                	jbe    221738 <openSelfDebugInfo+0x1c68>
            self.items = try self.allocator.alignedRealloc(T, A, self.items, better_capacity);
  22174f:	48 8d 7c 24 50       	lea    rdi,[rsp+0x50]
  221754:	48 8b b4 24 30 02 00 	mov    rsi,QWORD PTR [rsp+0x230]
  22175b:	00 
  22175c:	48 8d 94 24 10 02 00 	lea    rdx,[rsp+0x210]
  221763:	00 
  221764:	e8 97 35 00 00       	call   224d00 <Allocator_alignedRealloc.155>
  221769:	0f b7 44 24 50       	movzx  eax,WORD PTR [rsp+0x50]
  22176e:	89 c1                	mov    ecx,eax
  221770:	66 85 c0             	test   ax,ax
  221773:	0f 85 9a 16 00 00    	jne    222e13 <openSelfDebugInfo+0x3343>
  221779:	48 8d 44 24 58       	lea    rax,[rsp+0x58]
  22177e:	c5 fa 6f 00          	vmovdqu xmm0,XMMWORD PTR [rax]
  221782:	c5 f9 7f 84 24 10 02 	vmovdqa XMMWORD PTR [rsp+0x210],xmm0
  221789:	00 00 
            const result = &self.items[self.len];
  22178b:	48 8b 84 24 10 02 00 	mov    rax,QWORD PTR [rsp+0x210]
  221792:	00 
            try self.ensureCapacity(new_length);
  221793:	48 89 84 24 c0 01 00 	mov    QWORD PTR [rsp+0x1c0],rax
  22179a:	00 
  22179b:	48 8b 84 24 a0 01 00 	mov    rax,QWORD PTR [rsp+0x1a0]
  2217a2:	00 
  2217a3:	48 89 c1             	mov    rcx,rax
            const result = &self.items[self.len];
  2217a6:	4c 6b e9 38          	imul   r13,rcx,0x38
  2217aa:	48 83 c1 01          	add    rcx,0x1
  2217ae:	48 89 c8             	mov    rax,rcx
            self.len = new_length;
  2217b1:	48 89 84 24 a0 01 00 	mov    QWORD PTR [rsp+0x1a0],rax
  2217b8:	00 
  2217b9:	48 89 8c 24 20 02 00 	mov    QWORD PTR [rsp+0x220],rcx
  2217c0:	00 
            .has_children = (try in_stream.readByte()) == DW.CHILDREN_yes,
  2217c1:	80 bc 24 ef 00 00 00 	cmp    BYTE PTR [rsp+0xef],0x1
  2217c8:	01 
  2217c9:	48 8b 84 24 c0 01 00 	mov    rax,QWORD PTR [rsp+0x1c0]
  2217d0:	00 
  2217d1:	48 89 c1             	mov    rcx,rax
            new_item_ptr.* = item;
  2217d4:	42 0f 94 04 29       	sete   BYTE PTR [rcx+r13*1]
  2217d9:	8a 84 24 3f 02 00 00 	mov    al,BYTE PTR [rsp+0x23f]
  2217e0:	42 88 44 29 07       	mov    BYTE PTR [rcx+r13*1+0x7],al
  2217e5:	0f b7 84 24 3d 02 00 	movzx  eax,WORD PTR [rsp+0x23d]
  2217ec:	00 
  2217ed:	66 42 89 44 29 05    	mov    WORD PTR [rcx+r13*1+0x5],ax
  2217f3:	8b 84 24 39 02 00 00 	mov    eax,DWORD PTR [rsp+0x239]
  2217fa:	42 89 44 29 01       	mov    DWORD PTR [rcx+r13*1+0x1],eax
  2217ff:	48 8b 44 24 40       	mov    rax,QWORD PTR [rsp+0x40]
  221804:	4a 89 44 29 08       	mov    QWORD PTR [rcx+r13*1+0x8],rax
  221809:	48 8b 84 24 98 01 00 	mov    rax,QWORD PTR [rsp+0x198]
  221810:	00 
  221811:	4a 89 44 29 10       	mov    QWORD PTR [rcx+r13*1+0x10],rax
  221816:	48 8b 44 24 30       	mov    rax,QWORD PTR [rsp+0x30]
  22181b:	4a 89 44 29 28       	mov    QWORD PTR [rcx+r13*1+0x28],rax
  221820:	c5 f9 6f 44 24 20    	vmovdqa xmm0,XMMWORD PTR [rsp+0x20]
  221826:	c4 a1 7a 7f 44 29 18 	vmovdqu XMMWORD PTR [rcx+r13*1+0x18],xmm0
  22182d:	48 8b 84 24 a8 01 00 	mov    rax,QWORD PTR [rsp+0x1a8]
  221834:	00 
  221835:	4a 89 44 29 30       	mov    QWORD PTR [rcx+r13*1+0x30],rax
            try self.readNoEof(result[0..]);
  22183a:	48 8d 44 24 1f       	lea    rax,[rsp+0x1f]
  22183f:	48 89 84 24 d0 00 00 	mov    QWORD PTR [rsp+0xd0],rax
  221846:	00 
  221847:	48 c7 84 24 d8 00 00 	mov    QWORD PTR [rsp+0xd8],0x1
  22184e:	00 01 00 00 00 
            return self.readFn(self, buffer);
  221853:	48 8d 7c 24 50       	lea    rdi,[rsp+0x50]
  221858:	48 8d b4 24 90 01 00 	lea    rsi,[rsp+0x190]
  22185f:	00 
  221860:	48 8d 94 24 d0 00 00 	lea    rdx,[rsp+0xd0]
  221867:	00 
  221868:	ff 94 24 90 01 00 00 	call   QWORD PTR [rsp+0x190]
  22186f:	0f b7 44 24 50       	movzx  eax,WORD PTR [rsp+0x50]
  221874:	89 c1                	mov    ecx,eax
            const amt_read = try self.read(buf);
  221876:	66 85 c0             	test   ax,ax
  221879:	0f 85 3d 15 00 00    	jne    222dbc <openSelfDebugInfo+0x32ec>
  22187f:	48 8b 84 24 c0 01 00 	mov    rax,QWORD PTR [rsp+0x1c0]
  221886:	00 
  221887:	4c 01 e8             	add    rax,r13
  22188a:	48 83 c0 18          	add    rax,0x18
  22188e:	48 89 84 24 a8 01 00 	mov    QWORD PTR [rsp+0x1a8],rax
  221895:	00 
  221896:	48 8b 44 24 58       	mov    rax,QWORD PTR [rsp+0x58]
  22189b:	31 c9                	xor    ecx,ecx
  22189d:	48 89 8c 24 98 01 00 	mov    QWORD PTR [rsp+0x198],rcx
  2218a4:	00 
  2218a5:	45 31 ed             	xor    r13d,r13d
            if (amt_read < buf.len) return error.EndOfStream;
  2218a8:	48 3b 84 24 d8 00 00 	cmp    rax,QWORD PTR [rsp+0xd8]
  2218af:	00 
  2218b0:	0f 82 fc 14 00 00    	jb     222db2 <openSelfDebugInfo+0x32e2>
            return result[0];
  2218b6:	0f b6 44 24 1f       	movzx  eax,BYTE PTR [rsp+0x1f]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  2218bb:	89 c2                	mov    edx,eax
  2218bd:	83 e2 7f             	and    edx,0x7f
  2218c0:	44 89 ee             	mov    esi,r13d
  2218c3:	83 e6 3f             	and    esi,0x3f
  2218c6:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  2218cb:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  2218d0:	48 39 d6             	cmp    rsi,rdx
  2218d3:	0f 85 df 14 00 00    	jne    222db8 <openSelfDebugInfo+0x32e8>
        result |= operand;
  2218d9:	48 09 8c 24 98 01 00 	or     QWORD PTR [rsp+0x198],rcx
  2218e0:	00 
        if ((byte & 0b10000000) == 0) return result;
  2218e1:	84 c0                	test   al,al
  2218e3:	0f 88 e5 00 00 00    	js     2219ce <openSelfDebugInfo+0x1efe>
            try self.readNoEof(result[0..]);
  2218e9:	48 8d 44 24 1f       	lea    rax,[rsp+0x1f]
  2218ee:	48 89 84 24 d0 00 00 	mov    QWORD PTR [rsp+0xd0],rax
  2218f5:	00 
  2218f6:	48 c7 84 24 d8 00 00 	mov    QWORD PTR [rsp+0xd8],0x1
  2218fd:	00 01 00 00 00 
            return self.readFn(self, buffer);
  221902:	48 8d 7c 24 50       	lea    rdi,[rsp+0x50]
  221907:	48 8d b4 24 90 01 00 	lea    rsi,[rsp+0x190]
  22190e:	00 
  22190f:	48 8d 94 24 d0 00 00 	lea    rdx,[rsp+0xd0]
  221916:	00 
  221917:	ff 94 24 90 01 00 00 	call   QWORD PTR [rsp+0x190]
  22191e:	0f b7 44 24 50       	movzx  eax,WORD PTR [rsp+0x50]
  221923:	89 c1                	mov    ecx,eax
            const amt_read = try self.read(buf);
  221925:	66 85 c0             	test   ax,ax
  221928:	0f 85 66 14 00 00    	jne    222d94 <openSelfDebugInfo+0x32c4>
  22192e:	48 8b 44 24 58       	mov    rax,QWORD PTR [rsp+0x58]
  221933:	31 c9                	xor    ecx,ecx
  221935:	48 89 4c 24 40       	mov    QWORD PTR [rsp+0x40],rcx
  22193a:	45 31 ed             	xor    r13d,r13d
            if (amt_read < buf.len) return error.EndOfStream;
  22193d:	48 3b 84 24 d8 00 00 	cmp    rax,QWORD PTR [rsp+0xd8]
  221944:	00 
  221945:	0f 82 3f 14 00 00    	jb     222d8a <openSelfDebugInfo+0x32ba>
            return result[0];
  22194b:	0f b6 44 24 1f       	movzx  eax,BYTE PTR [rsp+0x1f]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  221950:	89 c2                	mov    edx,eax
  221952:	83 e2 7f             	and    edx,0x7f
  221955:	44 89 ee             	mov    esi,r13d
  221958:	83 e6 3f             	and    esi,0x3f
  22195b:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  221960:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  221965:	48 39 d6             	cmp    rsi,rdx
  221968:	0f 85 22 14 00 00    	jne    222d90 <openSelfDebugInfo+0x32c0>
        result |= operand;
  22196e:	48 09 4c 24 40       	or     QWORD PTR [rsp+0x40],rcx
        if ((byte & 0b10000000) == 0) return result;
  221973:	84 c0                	test   al,al
  221975:	0f 89 a6 00 00 00    	jns    221a21 <openSelfDebugInfo+0x1f51>
        shift += 7;
  22197b:	49 83 c5 07          	add    r13,0x7
            try self.readNoEof(result[0..]);
  22197f:	48 8d 44 24 1f       	lea    rax,[rsp+0x1f]
  221984:	48 89 84 24 d0 00 00 	mov    QWORD PTR [rsp+0xd0],rax
  22198b:	00 
  22198c:	48 c7 84 24 d8 00 00 	mov    QWORD PTR [rsp+0xd8],0x1
  221993:	00 01 00 00 00 
            return self.readFn(self, buffer);
  221998:	48 8d 7c 24 50       	lea    rdi,[rsp+0x50]
  22199d:	48 8d b4 24 90 01 00 	lea    rsi,[rsp+0x190]
  2219a4:	00 
  2219a5:	48 8d 94 24 d0 00 00 	lea    rdx,[rsp+0xd0]
  2219ac:	00 
  2219ad:	ff 94 24 90 01 00 00 	call   QWORD PTR [rsp+0x190]
  2219b4:	0f b7 54 24 50       	movzx  edx,WORD PTR [rsp+0x50]
  2219b9:	48 8b 44 24 58       	mov    rax,QWORD PTR [rsp+0x58]
  2219be:	89 d1                	mov    ecx,edx
            const amt_read = try self.read(buf);
  2219c0:	66 85 d2             	test   dx,dx
  2219c3:	0f 84 74 ff ff ff    	je     22193d <openSelfDebugInfo+0x1e6d>
  2219c9:	e9 c6 13 00 00       	jmp    222d94 <openSelfDebugInfo+0x32c4>
  2219ce:	49 83 c5 07          	add    r13,0x7
            try self.readNoEof(result[0..]);
  2219d2:	48 8d 44 24 1f       	lea    rax,[rsp+0x1f]
  2219d7:	48 89 84 24 d0 00 00 	mov    QWORD PTR [rsp+0xd0],rax
  2219de:	00 
  2219df:	48 c7 84 24 d8 00 00 	mov    QWORD PTR [rsp+0xd8],0x1
  2219e6:	00 01 00 00 00 
            return self.readFn(self, buffer);
  2219eb:	48 8d 7c 24 50       	lea    rdi,[rsp+0x50]
  2219f0:	48 8d b4 24 90 01 00 	lea    rsi,[rsp+0x190]
  2219f7:	00 
  2219f8:	48 8d 94 24 d0 00 00 	lea    rdx,[rsp+0xd0]
  2219ff:	00 
  221a00:	ff 94 24 90 01 00 00 	call   QWORD PTR [rsp+0x190]
  221a07:	0f b7 54 24 50       	movzx  edx,WORD PTR [rsp+0x50]
  221a0c:	48 8b 44 24 58       	mov    rax,QWORD PTR [rsp+0x58]
  221a11:	89 d1                	mov    ecx,edx
            const amt_read = try self.read(buf);
  221a13:	66 85 d2             	test   dx,dx
  221a16:	0f 84 8c fe ff ff    	je     2218a8 <openSelfDebugInfo+0x1dd8>
  221a1c:	e9 9b 13 00 00       	jmp    222dbc <openSelfDebugInfo+0x32ec>
            if (attr_id == 0 and form_id == 0) break;
  221a21:	48 8b 44 24 40       	mov    rax,QWORD PTR [rsp+0x40]
  221a26:	48 0b 84 24 98 01 00 	or     rax,QWORD PTR [rsp+0x198]
  221a2d:	00 
  221a2e:	0f 84 fa 00 00 00    	je     221b2e <openSelfDebugInfo+0x205e>
  221a34:	48 8b 84 24 a8 01 00 	mov    rax,QWORD PTR [rsp+0x1a8]
  221a3b:	00 
            const new_length = self.len + 1;
  221a3c:	4c 8b 68 10          	mov    r13,QWORD PTR [rax+0x10]
            var better_capacity = self.items.len;
  221a40:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
            if (better_capacity >= new_capacity) return;
  221a44:	4c 39 e9             	cmp    rcx,r13
  221a47:	76 05                	jbe    221a4e <openSelfDebugInfo+0x1f7e>
            const result = &self.items[self.len];
  221a49:	4c 89 e8             	mov    rax,r13
  221a4c:	eb 51                	jmp    221a9f <openSelfDebugInfo+0x1fcf>
                better_capacity += better_capacity / 2 + 8;
  221a4e:	48 89 c8             	mov    rax,rcx
  221a51:	48 d1 e8             	shr    rax,1
  221a54:	48 01 c1             	add    rcx,rax
  221a57:	48 83 c1 08          	add    rcx,0x8
                if (better_capacity >= new_capacity) break;
  221a5b:	4c 39 e9             	cmp    rcx,r13
  221a5e:	76 ee                	jbe    221a4e <openSelfDebugInfo+0x1f7e>
  221a60:	48 8b 94 24 a8 01 00 	mov    rdx,QWORD PTR [rsp+0x1a8]
  221a67:	00 
            self.items = try self.allocator.alignedRealloc(T, A, self.items, better_capacity);
  221a68:	48 8b 72 18          	mov    rsi,QWORD PTR [rdx+0x18]
  221a6c:	48 8d 7c 24 50       	lea    rdi,[rsp+0x50]
  221a71:	e8 2a 35 00 00       	call   224fa0 <Allocator_alignedRealloc.158>
  221a76:	0f b7 44 24 50       	movzx  eax,WORD PTR [rsp+0x50]
  221a7b:	89 c1                	mov    ecx,eax
  221a7d:	66 85 c0             	test   ax,ax
  221a80:	0f 85 ab 13 00 00    	jne    222e31 <openSelfDebugInfo+0x3361>
  221a86:	48 8d 44 24 58       	lea    rax,[rsp+0x58]
  221a8b:	c5 fa 6f 00          	vmovdqu xmm0,XMMWORD PTR [rax]
  221a8f:	48 8b 84 24 a8 01 00 	mov    rax,QWORD PTR [rsp+0x1a8]
  221a96:	00 
  221a97:	c5 fa 7f 00          	vmovdqu XMMWORD PTR [rax],xmm0
            const result = &self.items[self.len];
  221a9b:	48 8b 40 10          	mov    rax,QWORD PTR [rax+0x10]
  221a9f:	49 83 c5 01          	add    r13,0x1
  221aa3:	48 8b 94 24 a8 01 00 	mov    rdx,QWORD PTR [rsp+0x1a8]
  221aaa:	00 
  221aab:	48 8b 0a             	mov    rcx,QWORD PTR [rdx]
            self.len = new_length;
  221aae:	4c 89 6a 10          	mov    QWORD PTR [rdx+0x10],r13
            new_item_ptr.* = item;
  221ab2:	48 c1 e0 04          	shl    rax,0x4
  221ab6:	48 8b 94 24 98 01 00 	mov    rdx,QWORD PTR [rsp+0x198]
  221abd:	00 
  221abe:	48 89 14 01          	mov    QWORD PTR [rcx+rax*1],rdx
  221ac2:	48 8b 54 24 40       	mov    rdx,QWORD PTR [rsp+0x40]
  221ac7:	48 89 54 01 08       	mov    QWORD PTR [rcx+rax*1+0x8],rdx
            try self.readNoEof(result[0..]);
  221acc:	48 8d 44 24 1f       	lea    rax,[rsp+0x1f]
  221ad1:	48 89 84 24 d0 00 00 	mov    QWORD PTR [rsp+0xd0],rax
  221ad8:	00 
  221ad9:	48 c7 84 24 d8 00 00 	mov    QWORD PTR [rsp+0xd8],0x1
  221ae0:	00 01 00 00 00 
            return self.readFn(self, buffer);
  221ae5:	48 8d 7c 24 50       	lea    rdi,[rsp+0x50]
  221aea:	48 8d b4 24 90 01 00 	lea    rsi,[rsp+0x190]
  221af1:	00 
  221af2:	48 8d 94 24 d0 00 00 	lea    rdx,[rsp+0xd0]
  221af9:	00 
  221afa:	ff 94 24 90 01 00 00 	call   QWORD PTR [rsp+0x190]
  221b01:	0f b7 54 24 50       	movzx  edx,WORD PTR [rsp+0x50]
  221b06:	48 8b 44 24 58       	mov    rax,QWORD PTR [rsp+0x58]
  221b0b:	b9 00 00 00 00       	mov    ecx,0x0
  221b10:	48 89 8c 24 98 01 00 	mov    QWORD PTR [rsp+0x198],rcx
  221b17:	00 
  221b18:	41 bd 00 00 00 00    	mov    r13d,0x0
  221b1e:	89 d1                	mov    ecx,edx
            const amt_read = try self.read(buf);
  221b20:	66 85 d2             	test   dx,dx
  221b23:	0f 84 7f fd ff ff    	je     2218a8 <openSelfDebugInfo+0x1dd8>
  221b29:	e9 8e 12 00 00       	jmp    222dbc <openSelfDebugInfo+0x32ec>
            try self.readNoEof(result[0..]);
  221b2e:	48 8d 44 24 1f       	lea    rax,[rsp+0x1f]
  221b33:	48 89 84 24 00 02 00 	mov    QWORD PTR [rsp+0x200],rax
  221b3a:	00 
  221b3b:	48 c7 84 24 08 02 00 	mov    QWORD PTR [rsp+0x208],0x1
  221b42:	00 01 00 00 00 
            return self.readFn(self, buffer);
  221b47:	48 8d bc 24 d0 00 00 	lea    rdi,[rsp+0xd0]
  221b4e:	00 
  221b4f:	48 8d b4 24 90 01 00 	lea    rsi,[rsp+0x190]
  221b56:	00 
  221b57:	48 8d 94 24 00 02 00 	lea    rdx,[rsp+0x200]
  221b5e:	00 
  221b5f:	ff 94 24 90 01 00 00 	call   QWORD PTR [rsp+0x190]
  221b66:	0f b7 8c 24 d0 00 00 	movzx  ecx,WORD PTR [rsp+0xd0]
  221b6d:	00 
  221b6e:	48 8b 84 24 d8 00 00 	mov    rax,QWORD PTR [rsp+0xd8]
  221b75:	00 
            const amt_read = try self.read(buf);
  221b76:	66 85 c9             	test   cx,cx
  221b79:	0f 84 91 f9 ff ff    	je     221510 <openSelfDebugInfo+0x1a40>
  221b7f:	e9 5b 0e 00 00       	jmp    2229df <openSelfDebugInfo+0x2f0f>
        if (abbrev_code == 0) return result;
  221b84:	c5 fc 10 84 24 10 02 	vmovups ymm0,YMMWORD PTR [rsp+0x210]
  221b8b:	00 00 
  221b8d:	48 8d 84 24 9e 00 00 	lea    rax,[rsp+0x9e]
  221b94:	00 
  221b95:	c5 fc 11 00          	vmovups YMMWORD PTR [rax],ymm0
  221b99:	c5 fc 10 84 24 98 00 	vmovups ymm0,YMMWORD PTR [rsp+0x98]
  221ba0:	00 00 
  221ba2:	c5 fc 11 84 24 d0 01 	vmovups YMMWORD PTR [rsp+0x1d0],ymm0
  221ba9:	00 00 
  221bab:	48 8b 84 24 b6 00 00 	mov    rax,QWORD PTR [rsp+0xb6]
  221bb2:	00 
  221bb3:	48 89 84 24 ee 01 00 	mov    QWORD PTR [rsp+0x1ee],rax
  221bba:	00 
    try st.abbrev_table_list.append(AbbrevTableHeader{
  221bbb:	48 8d 84 24 d6 01 00 	lea    rax,[rsp+0x1d6]
  221bc2:	00 
  221bc3:	c5 fe 6f 00          	vmovdqu ymm0,YMMWORD PTR [rax]
  221bc7:	c5 fe 7f 84 24 40 02 	vmovdqu YMMWORD PTR [rsp+0x240],ymm0
  221bce:	00 00 
            const new_length = self.len + 1;
  221bd0:	4c 8b ad 98 00 00 00 	mov    r13,QWORD PTR [rbp+0x98]
            var better_capacity = self.items.len;
  221bd7:	48 8b 8d 90 00 00 00 	mov    rcx,QWORD PTR [rbp+0x90]
            if (better_capacity >= new_capacity) return;
  221bde:	4c 39 e9             	cmp    rcx,r13
  221be1:	76 05                	jbe    221be8 <openSelfDebugInfo+0x2118>
            const result = &self.items[self.len];
  221be3:	4c 89 e8             	mov    rax,r13
  221be6:	eb 5e                	jmp    221c46 <openSelfDebugInfo+0x2176>
                better_capacity += better_capacity / 2 + 8;
  221be8:	48 89 c8             	mov    rax,rcx
  221beb:	48 d1 e8             	shr    rax,1
  221bee:	48 01 c1             	add    rcx,rax
  221bf1:	48 83 c1 08          	add    rcx,0x8
                if (better_capacity >= new_capacity) break;
  221bf5:	4c 39 e9             	cmp    rcx,r13
  221bf8:	76 ee                	jbe    221be8 <openSelfDebugInfo+0x2118>
            self.items = try self.allocator.alignedRealloc(T, A, self.items, better_capacity);
  221bfa:	48 8b b5 a0 00 00 00 	mov    rsi,QWORD PTR [rbp+0xa0]
  221c01:	48 89 df             	mov    rdi,rbx
  221c04:	48 8b 94 24 68 02 00 	mov    rdx,QWORD PTR [rsp+0x268]
  221c0b:	00 
  221c0c:	c5 f8 77             	vzeroupper 
  221c0f:	e8 fc 35 00 00       	call   225210 <Allocator_alignedRealloc.161>
  221c14:	0f b7 8c 24 f0 00 00 	movzx  ecx,WORD PTR [rsp+0xf0]
  221c1b:	00 
  221c1c:	89 c8                	mov    eax,ecx
  221c1e:	66 85 c9             	test   cx,cx
  221c21:	0f 85 f0 0d 00 00    	jne    222a17 <openSelfDebugInfo+0x2f47>
  221c27:	48 8d 84 24 f8 00 00 	lea    rax,[rsp+0xf8]
  221c2e:	00 
  221c2f:	c5 fa 6f 00          	vmovdqu xmm0,XMMWORD PTR [rax]
  221c33:	48 8b 84 24 68 02 00 	mov    rax,QWORD PTR [rsp+0x268]
  221c3a:	00 
  221c3b:	c5 fa 7f 00          	vmovdqu XMMWORD PTR [rax],xmm0
            const result = &self.items[self.len];
  221c3f:	48 8b 85 98 00 00 00 	mov    rax,QWORD PTR [rbp+0x98]
  221c46:	49 83 c5 01          	add    r13,0x1
  221c4a:	48 8b 8d 88 00 00 00 	mov    rcx,QWORD PTR [rbp+0x88]
            self.len = new_length;
  221c51:	4c 89 ad 98 00 00 00 	mov    QWORD PTR [rbp+0x98],r13
            new_item_ptr.* = item;
  221c58:	48 8d 04 80          	lea    rax,[rax+rax*4]
  221c5c:	48 8b 54 24 48       	mov    rdx,QWORD PTR [rsp+0x48]
  221c61:	48 89 14 c1          	mov    QWORD PTR [rcx+rax*8],rdx
  221c65:	c5 fe 6f 84 24 40 02 	vmovdqu ymm0,YMMWORD PTR [rsp+0x240]
  221c6c:	00 00 
  221c6e:	c5 fe 7f 44 c1 08    	vmovdqu YMMWORD PTR [rcx+rax*8+0x8],ymm0
    return &st.abbrev_table_list.items[st.abbrev_table_list.len - 1].table;
  221c74:	48 8b 85 88 00 00 00 	mov    rax,QWORD PTR [rbp+0x88]
  221c7b:	48 8b 8d 98 00 00 00 	mov    rcx,QWORD PTR [rbp+0x98]
  221c82:	48 8d 0c 89          	lea    rcx,[rcx+rcx*4]
  221c86:	4c 8d 2c c8          	lea    r13,[rax+rcx*8]
  221c8a:	49 83 c5 e0          	add    r13,0xffffffffffffffe0
  221c8e:	66 bf 04 00          	mov    di,0x4
  221c92:	48 83 bc 24 88 00 00 	cmp    QWORD PTR [rsp+0x88],0x0
  221c99:	00 00 
  221c9b:	0f 88 b7 0e 00 00    	js     222b58 <openSelfDebugInfo+0x3088>
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  221ca1:	48 63 7d 00          	movsxd rdi,DWORD PTR [rbp+0x0]
  221ca5:	b8 08 00 00 00       	mov    eax,0x8
  221caa:	31 d2                	xor    edx,edx
  221cac:	48 8b b4 24 88 00 00 	mov    rsi,QWORD PTR [rsp+0x88]
  221cb3:	00 
  221cb4:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  221cb6:	48 89 c1             	mov    rcx,rax
  221cb9:	48 f7 d9             	neg    rcx
  221cbc:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  221cc2:	b8 00 00 00 00       	mov    eax,0x0
  221cc7:	48 0f 46 c8          	cmovbe rcx,rax
  221ccb:	48 85 c9             	test   rcx,rcx
  221cce:	0f 85 bd 0d 00 00    	jne    222a91 <openSelfDebugInfo+0x2fc1>
  221cd4:	48 8b 85 a0 00 00 00 	mov    rax,QWORD PTR [rbp+0xa0]
    var in_file_stream = io.FileInStream.init(in_file);
  221cdb:	48 89 84 24 c0 01 00 	mov    QWORD PTR [rsp+0x1c0],rax
  221ce2:	00 
  221ce3:	48 89 6c 24 50       	mov    QWORD PTR [rsp+0x50],rbp
  221ce8:	48 8d 05 e1 2f 00 00 	lea    rax,[rip+0x2fe1]        # 224cd0 <FileInStream_readFn>
  221cef:	48 89 44 24 58       	mov    QWORD PTR [rsp+0x58],rax
            try self.readNoEof(result[0..]);
  221cf4:	48 8d 44 24 1f       	lea    rax,[rsp+0x1f]
  221cf9:	48 89 84 24 40 02 00 	mov    QWORD PTR [rsp+0x240],rax
  221d00:	00 
  221d01:	48 c7 84 24 48 02 00 	mov    QWORD PTR [rsp+0x248],0x1
  221d08:	00 01 00 00 00 
        return self.file.read(buffer);
  221d0d:	48 8b 74 24 50       	mov    rsi,QWORD PTR [rsp+0x50]
  221d12:	48 8d bc 24 d0 01 00 	lea    rdi,[rsp+0x1d0]
  221d19:	00 
  221d1a:	48 8d 94 24 40 02 00 	lea    rdx,[rsp+0x240]
  221d21:	00 
  221d22:	c5 f8 77             	vzeroupper 
  221d25:	e8 76 2e 00 00       	call   224ba0 <File_read>
  221d2a:	c5 fa 6f 84 24 d0 01 	vmovdqu xmm0,XMMWORD PTR [rsp+0x1d0]
  221d31:	00 00 
  221d33:	c5 f9 7f 84 24 10 02 	vmovdqa XMMWORD PTR [rsp+0x210],xmm0
  221d3a:	00 00 
            return self.readFn(self, buffer);
  221d3c:	0f b7 84 24 10 02 00 	movzx  eax,WORD PTR [rsp+0x210]
  221d43:	00 
  221d44:	89 c1                	mov    ecx,eax
            const amt_read = try self.read(buf);
  221d46:	66 85 c0             	test   ax,ax
  221d49:	0f 85 e4 0c 00 00    	jne    222a33 <openSelfDebugInfo+0x2f63>
  221d4f:	0f b6 84 24 80 00 00 	movzx  eax,BYTE PTR [rsp+0x80]
  221d56:	00 
  221d57:	48 89 84 24 98 01 00 	mov    QWORD PTR [rsp+0x198],rax
  221d5e:	00 
  221d5f:	48 8d 04 c5 04 00 00 	lea    rax,[rax*8+0x4]
  221d66:	00 
  221d67:	48 89 84 24 30 02 00 	mov    QWORD PTR [rsp+0x230],rax
  221d6e:	00 
  221d6f:	48 8b 84 24 18 02 00 	mov    rax,QWORD PTR [rsp+0x218]
  221d76:	00 
  221d77:	31 c9                	xor    ecx,ecx
  221d79:	48 89 4c 24 48       	mov    QWORD PTR [rsp+0x48],rcx
  221d7e:	31 c9                	xor    ecx,ecx
            if (amt_read < buf.len) return error.EndOfStream;
  221d80:	48 89 4c 24 40       	mov    QWORD PTR [rsp+0x40],rcx
  221d85:	48 3b 84 24 48 02 00 	cmp    rax,QWORD PTR [rsp+0x248]
  221d8c:	00 
  221d8d:	0f 82 96 0c 00 00    	jb     222a29 <openSelfDebugInfo+0x2f59>
            return result[0];
  221d93:	0f b6 44 24 1f       	movzx  eax,BYTE PTR [rsp+0x1f]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  221d98:	89 c2                	mov    edx,eax
  221d9a:	83 e2 7f             	and    edx,0x7f
  221d9d:	48 8b 74 24 40       	mov    rsi,QWORD PTR [rsp+0x40]
  221da2:	83 e6 3f             	and    esi,0x3f
  221da5:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  221daa:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  221daf:	48 39 d6             	cmp    rsi,rdx
  221db2:	0f 85 77 0c 00 00    	jne    222a2f <openSelfDebugInfo+0x2f5f>
        result |= operand;
  221db8:	48 09 4c 24 48       	or     QWORD PTR [rsp+0x48],rcx
        if ((byte & 0b10000000) == 0) return result;
  221dbd:	84 c0                	test   al,al
  221dbf:	79 58                	jns    221e19 <openSelfDebugInfo+0x2349>
        shift += 7;
  221dc1:	48 83 44 24 40 07    	add    QWORD PTR [rsp+0x40],0x7
            try self.readNoEof(result[0..]);
  221dc7:	48 8d 44 24 1f       	lea    rax,[rsp+0x1f]
  221dcc:	48 89 84 24 40 02 00 	mov    QWORD PTR [rsp+0x240],rax
  221dd3:	00 
  221dd4:	48 c7 84 24 48 02 00 	mov    QWORD PTR [rsp+0x248],0x1
  221ddb:	00 01 00 00 00 
            return self.readFn(self, buffer);
  221de0:	48 8d bc 24 10 02 00 	lea    rdi,[rsp+0x210]
  221de7:	00 
  221de8:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  221ded:	48 8d 94 24 40 02 00 	lea    rdx,[rsp+0x240]
  221df4:	00 
  221df5:	ff 54 24 58          	call   QWORD PTR [rsp+0x58]
  221df9:	0f b7 94 24 10 02 00 	movzx  edx,WORD PTR [rsp+0x210]
  221e00:	00 
  221e01:	48 8b 84 24 18 02 00 	mov    rax,QWORD PTR [rsp+0x218]
  221e08:	00 
  221e09:	89 d1                	mov    ecx,edx
            const amt_read = try self.read(buf);
  221e0b:	66 85 d2             	test   dx,dx
  221e0e:	0f 84 71 ff ff ff    	je     221d85 <openSelfDebugInfo+0x22b5>
  221e14:	e9 1a 0c 00 00       	jmp    222a33 <openSelfDebugInfo+0x2f63>
            return self.items[0..self.len];
  221e19:	49 8b 45 10          	mov    rax,QWORD PTR [r13+0x10]
    for (abbrev_table.toSliceConst()) |*table_entry| {
  221e1d:	48 85 c0             	test   rax,rax
  221e20:	0f 84 9c 0c 00 00    	je     222ac2 <openSelfDebugInfo+0x2ff2>
  221e26:	4d 8b 6d 00          	mov    r13,QWORD PTR [r13+0x0]
  221e2a:	31 c9                	xor    ecx,ecx
        if (table_entry.abbrev_code == abbrev_code) return table_entry;
  221e2c:	48 8b 54 24 48       	mov    rdx,QWORD PTR [rsp+0x48]
  221e31:	49 39 55 08          	cmp    QWORD PTR [r13+0x8],rdx
  221e35:	74 12                	je     221e49 <openSelfDebugInfo+0x2379>
    for (abbrev_table.toSliceConst()) |*table_entry| {
  221e37:	48 83 c1 01          	add    rcx,0x1
  221e3b:	49 83 c5 38          	add    r13,0x38
  221e3f:	48 39 c1             	cmp    rcx,rax
  221e42:	72 e8                	jb     221e2c <openSelfDebugInfo+0x235c>
  221e44:	e9 79 0c 00 00       	jmp    222ac2 <openSelfDebugInfo+0x2ff2>
    const table_entry = getAbbrevTableEntry(abbrev_table, abbrev_code) orelse return error.InvalidDebugInfo;
  221e49:	4d 85 ed             	test   r13,r13
  221e4c:	0f 84 70 0c 00 00    	je     222ac2 <openSelfDebugInfo+0x2ff2>
        .tag_id = table_entry.tag_id,
  221e52:	49 8b 45 10          	mov    rax,QWORD PTR [r13+0x10]
        .has_children = table_entry.has_children,
  221e56:	41 8a 4d 00          	mov    cl,BYTE PTR [r13+0x0]
  221e5a:	48 8b b5 a0 00 00 00 	mov    rsi,QWORD PTR [rbp+0xa0]
  221e61:	48 8d 94 24 57 03 00 	lea    rdx,[rsp+0x357]
  221e68:	00 
    var result = Die{
  221e69:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  221e6d:	c5 fa 7f 02          	vmovdqu XMMWORD PTR [rdx],xmm0
  221e71:	48 c7 42 10 00 00 00 	mov    QWORD PTR [rdx+0x10],0x0
  221e78:	00 
  221e79:	48 89 84 24 88 02 00 	mov    QWORD PTR [rsp+0x288],rax
  221e80:	00 
  221e81:	88 8c 24 90 02 00 00 	mov    BYTE PTR [rsp+0x290],cl
  221e88:	c5 fa 6f 84 24 50 03 	vmovdqu xmm0,XMMWORD PTR [rsp+0x350]
  221e8f:	00 00 
  221e91:	c5 fa 6f 8c 24 5f 03 	vmovdqu xmm1,XMMWORD PTR [rsp+0x35f]
  221e98:	00 00 
  221e9a:	48 8d 84 24 91 02 00 	lea    rax,[rsp+0x291]
  221ea1:	00 
  221ea2:	c5 fa 7f 48 0f       	vmovdqu XMMWORD PTR [rax+0xf],xmm1
  221ea7:	c5 fa 7f 00          	vmovdqu XMMWORD PTR [rax],xmm0
  221eab:	48 89 b4 24 b0 02 00 	mov    QWORD PTR [rsp+0x2b0],rsi
  221eb2:	00 
    try result.attrs.resize(table_entry.attrs.len);
  221eb3:	49 8b 45 28          	mov    rax,QWORD PTR [r13+0x28]
            var better_capacity = self.items.len;
  221eb7:	48 8b 8c 24 a0 02 00 	mov    rcx,QWORD PTR [rsp+0x2a0]
  221ebe:	00 
  221ebf:	48 89 44 24 40       	mov    QWORD PTR [rsp+0x40],rax
            if (better_capacity >= new_capacity) return;
  221ec4:	48 39 c1             	cmp    rcx,rax
  221ec7:	73 5b                	jae    221f24 <openSelfDebugInfo+0x2454>
                better_capacity += better_capacity / 2 + 8;
  221ec9:	48 89 c8             	mov    rax,rcx
  221ecc:	48 d1 e8             	shr    rax,1
  221ecf:	48 01 c1             	add    rcx,rax
  221ed2:	48 83 c1 08          	add    rcx,0x8
                if (better_capacity >= new_capacity) break;
  221ed6:	48 3b 4c 24 40       	cmp    rcx,QWORD PTR [rsp+0x40]
  221edb:	72 ec                	jb     221ec9 <openSelfDebugInfo+0x23f9>
            self.items = try self.allocator.alignedRealloc(T, A, self.items, better_capacity);
  221edd:	48 8d bc 24 d0 01 00 	lea    rdi,[rsp+0x1d0]
  221ee4:	00 
  221ee5:	48 8d 94 24 98 02 00 	lea    rdx,[rsp+0x298]
  221eec:	00 
  221eed:	e8 be 60 00 00       	call   227fb0 <Allocator_alignedRealloc.164>
  221ef2:	0f b7 8c 24 d0 01 00 	movzx  ecx,WORD PTR [rsp+0x1d0]
  221ef9:	00 
  221efa:	89 c8                	mov    eax,ecx
  221efc:	66 85 c9             	test   cx,cx
  221eff:	0f 85 f7 0e 00 00    	jne    222dfc <openSelfDebugInfo+0x332c>
  221f05:	48 8d 84 24 d6 01 00 	lea    rax,[rsp+0x1d6]
  221f0c:	00 
  221f0d:	c5 fa 6f 40 02       	vmovdqu xmm0,XMMWORD PTR [rax+0x2]
  221f12:	48 8d 84 24 98 02 00 	lea    rax,[rsp+0x298]
  221f19:	00 
  221f1a:	c5 fa 7f 00          	vmovdqu XMMWORD PTR [rax],xmm0
            return self.items[0..self.len];
  221f1e:	49 8b 45 28          	mov    rax,QWORD PTR [r13+0x28]
  221f22:	eb 05                	jmp    221f29 <openSelfDebugInfo+0x2459>
  221f24:	48 8b 44 24 40       	mov    rax,QWORD PTR [rsp+0x40]
  221f29:	48 89 84 24 a0 01 00 	mov    QWORD PTR [rsp+0x1a0],rax
  221f30:	00 
            self.len = new_len;
  221f31:	48 8b 44 24 40       	mov    rax,QWORD PTR [rsp+0x40]
  221f36:	48 89 84 24 a8 02 00 	mov    QWORD PTR [rsp+0x2a8],rax
  221f3d:	00 
    for (table_entry.attrs.toSliceConst()) |attr, i| {
  221f3e:	48 83 bc 24 a0 01 00 	cmp    QWORD PTR [rsp+0x1a0],0x0
  221f45:	00 00 
  221f47:	0f 84 c7 00 00 00    	je     222014 <openSelfDebugInfo+0x2544>
  221f4d:	49 8b 45 18          	mov    rax,QWORD PTR [r13+0x18]
  221f51:	4c 8b ac 24 98 02 00 	mov    r13,QWORD PTR [rsp+0x298]
  221f58:	00 
  221f59:	48 83 c0 08          	add    rax,0x8
  221f5d:	48 89 44 24 40       	mov    QWORD PTR [rsp+0x40],rax
  221f62:	49 83 c5 08          	add    r13,0x8
  221f66:	31 c0                	xor    eax,eax
  221f68:	48 89 44 24 48       	mov    QWORD PTR [rsp+0x48],rax
  221f6d:	48 8b 44 24 40       	mov    rax,QWORD PTR [rsp+0x40]
  221f72:	48 8b 48 f8          	mov    rcx,QWORD PTR [rax-0x8]
  221f76:	48 89 8c 24 88 00 00 	mov    QWORD PTR [rsp+0x88],rcx
  221f7d:	00 
  221f7e:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  221f81:	48 8b b5 a0 00 00 00 	mov    rsi,QWORD PTR [rbp+0xa0]
            .value = try parseFormValue(st.allocator(), in_stream, attr.form_id, is_64),
  221f88:	48 8d bc 24 78 03 00 	lea    rdi,[rsp+0x378]
  221f8f:	00 
  221f90:	48 8d 54 24 58       	lea    rdx,[rsp+0x58]
  221f95:	4c 8b 84 24 98 01 00 	mov    r8,QWORD PTR [rsp+0x198]
  221f9c:	00 
  221f9d:	c5 f8 77             	vzeroupper 
  221fa0:	e8 0b 35 00 00       	call   2254b0 <parseFormValue>
  221fa5:	0f b7 8c 24 78 03 00 	movzx  ecx,WORD PTR [rsp+0x378]
  221fac:	00 
  221fad:	89 c8                	mov    eax,ecx
  221faf:	66 85 c9             	test   cx,cx
  221fb2:	0f 85 9c 0d 00 00    	jne    222d54 <openSelfDebugInfo+0x3284>
        result.attrs.items[i] = Die.Attr{
  221fb8:	48 8d 84 24 80 03 00 	lea    rax,[rsp+0x380]
  221fbf:	00 
  221fc0:	c5 fc 10 00          	vmovups ymm0,YMMWORD PTR [rax]
  221fc4:	c5 fc 11 84 24 a0 03 	vmovups YMMWORD PTR [rsp+0x3a0],ymm0
  221fcb:	00 00 
  221fcd:	48 8b 84 24 88 00 00 	mov    rax,QWORD PTR [rsp+0x88]
  221fd4:	00 
  221fd5:	49 89 45 f8          	mov    QWORD PTR [r13-0x8],rax
  221fd9:	c5 fe 6f 84 24 a0 03 	vmovdqu ymm0,YMMWORD PTR [rsp+0x3a0]
  221fe0:	00 00 
  221fe2:	c4 c1 7e 7f 45 00    	vmovdqu YMMWORD PTR [r13+0x0],ymm0
  221fe8:	48 8b 44 24 48       	mov    rax,QWORD PTR [rsp+0x48]
  221fed:	48 89 c1             	mov    rcx,rax
    for (table_entry.attrs.toSliceConst()) |attr, i| {
  221ff0:	48 83 c1 01          	add    rcx,0x1
  221ff4:	48 83 44 24 40 10    	add    QWORD PTR [rsp+0x40],0x10
  221ffa:	49 83 c5 28          	add    r13,0x28
  221ffe:	48 89 c8             	mov    rax,rcx
  222001:	48 89 44 24 48       	mov    QWORD PTR [rsp+0x48],rax
  222006:	48 3b 8c 24 a0 01 00 	cmp    rcx,QWORD PTR [rsp+0x1a0]
  22200d:	00 
  22200e:	0f 82 59 ff ff ff    	jb     221f6d <openSelfDebugInfo+0x249d>
    return result;
  222014:	c5 fc 10 84 24 88 02 	vmovups ymm0,YMMWORD PTR [rsp+0x288]
  22201b:	00 00 
  22201d:	c5 fc 10 8c 24 98 02 	vmovups ymm1,YMMWORD PTR [rsp+0x298]
  222024:	00 00 
  222026:	48 8d 84 24 6e 04 00 	lea    rax,[rsp+0x46e]
  22202d:	00 
  22202e:	c5 fc 11 48 10       	vmovups YMMWORD PTR [rax+0x10],ymm1
  222033:	c5 fc 11 00          	vmovups YMMWORD PTR [rax],ymm0
  222037:	c5 fc 10 84 24 68 04 	vmovups ymm0,YMMWORD PTR [rsp+0x468]
  22203e:	00 00 
  222040:	c5 fc 10 8c 24 7e 04 	vmovups ymm1,YMMWORD PTR [rsp+0x47e]
  222047:	00 00 
  222049:	c5 fc 11 84 24 c0 02 	vmovups YMMWORD PTR [rsp+0x2c0],ymm0
  222050:	00 00 
  222052:	c5 fc 11 8c 24 d6 02 	vmovups YMMWORD PTR [rsp+0x2d6],ymm1
  222059:	00 00 
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  22205b:	ba 30 00 00 00       	mov    edx,0x30
  222060:	b9 08 00 00 00       	mov    ecx,0x8
  222065:	48 89 df             	mov    rdi,rbx
  222068:	48 8b b4 24 c0 01 00 	mov    rsi,QWORD PTR [rsp+0x1c0]
  22206f:	00 
  222070:	c5 f8 77             	vzeroupper 
  222073:	ff 16                	call   QWORD PTR [rsi]
  222075:	0f b7 8c 24 f0 00 00 	movzx  ecx,WORD PTR [rsp+0xf0]
  22207c:	00 
  22207d:	89 c8                	mov    eax,ecx
  22207f:	66 85 c9             	test   cx,cx
  222082:	0f 85 8f 09 00 00    	jne    222a17 <openSelfDebugInfo+0x2f47>
        assert(byte_slice.len == byte_count);
  222088:	48 83 bc 24 00 01 00 	cmp    QWORD PTR [rsp+0x100],0x30
  22208f:	00 30 
    if (!ok) {
  222091:	0f 85 9d 1a 00 00    	jne    223b34 <openSelfDebugInfo+0x4064>
  222097:	48 8b 8c 24 f8 00 00 	mov    rcx,QWORD PTR [rsp+0xf8]
  22209e:	00 
  22209f:	48 8d 84 24 c6 02 00 	lea    rax,[rsp+0x2c6]
  2220a6:	00 
        ptr.* = init;
  2220a7:	c5 fe 6f 00          	vmovdqu ymm0,YMMWORD PTR [rax]
  2220ab:	c5 fe 6f 48 10       	vmovdqu ymm1,YMMWORD PTR [rax+0x10]
  2220b0:	c5 fe 7f 01          	vmovdqu YMMWORD PTR [rcx],ymm0
  2220b4:	c5 fe 7f 49 10       	vmovdqu YMMWORD PTR [rcx+0x10],ymm1
  2220b9:	48 89 4c 24 40       	mov    QWORD PTR [rsp+0x40],rcx
        if (compile_unit_die.tag_id != DW.TAG_compile_unit) return error.InvalidDebugInfo;
  2220be:	48 83 39 11          	cmp    QWORD PTR [rcx],0x11
  2220c2:	0f 85 b5 09 00 00    	jne    222a7d <openSelfDebugInfo+0x2fad>
  2220c8:	48 8b 44 24 40       	mov    rax,QWORD PTR [rsp+0x40]
  2220cd:	48 8b 40 20          	mov    rax,QWORD PTR [rax+0x20]
        for (self.attrs.toSliceConst()) |*attr| {
  2220d1:	48 85 c0             	test   rax,rax
  2220d4:	74 25                	je     2220fb <openSelfDebugInfo+0x262b>
  2220d6:	48 8b 4c 24 40       	mov    rcx,QWORD PTR [rsp+0x40]
  2220db:	48 8b 51 10          	mov    rdx,QWORD PTR [rcx+0x10]
  2220df:	48 89 d1             	mov    rcx,rdx
  2220e2:	31 f6                	xor    esi,esi
            if (attr.id == id) return &attr.value;
  2220e4:	48 83 39 11          	cmp    QWORD PTR [rcx],0x11
  2220e8:	0f 84 52 01 00 00    	je     222240 <openSelfDebugInfo+0x2770>
        for (self.attrs.toSliceConst()) |*attr| {
  2220ee:	48 83 c6 01          	add    rsi,0x1
  2220f2:	48 83 c1 28          	add    rcx,0x28
  2220f6:	48 39 c6             	cmp    rsi,rax
  2220f9:	72 e9                	jb     2220e4 <openSelfDebugInfo+0x2614>
        const pc_range = x: {
  2220fb:	48 8d 0d a6 56 fe ff 	lea    rcx,[rip+0xfffffffffffe56a6]        # 2077a8 <__unnamed_62>
  222102:	48 8b 41 10          	mov    rax,QWORD PTR [rcx+0x10]
  222106:	48 89 84 24 60 04 00 	mov    QWORD PTR [rsp+0x460],rax
  22210d:	00 
  22210e:	c5 fa 6f 01          	vmovdqu xmm0,XMMWORD PTR [rcx]
  222112:	c5 f9 7f 84 24 50 04 	vmovdqa XMMWORD PTR [rsp+0x450],xmm0
  222119:	00 00 
            const new_length = self.len + 1;
  22211b:	4c 8b ad b8 00 00 00 	mov    r13,QWORD PTR [rbp+0xb8]
            var better_capacity = self.items.len;
  222122:	48 8b 8d b0 00 00 00 	mov    rcx,QWORD PTR [rbp+0xb0]
            if (better_capacity >= new_capacity) return;
  222129:	4c 39 e9             	cmp    rcx,r13
  22212c:	76 05                	jbe    222133 <openSelfDebugInfo+0x2663>
            const result = &self.items[self.len];
  22212e:	4c 89 e8             	mov    rax,r13
  222131:	eb 58                	jmp    22218b <openSelfDebugInfo+0x26bb>
                better_capacity += better_capacity / 2 + 8;
  222133:	48 89 c8             	mov    rax,rcx
  222136:	48 d1 e8             	shr    rax,1
  222139:	48 01 c1             	add    rcx,rax
  22213c:	48 83 c1 08          	add    rcx,0x8
                if (better_capacity >= new_capacity) break;
  222140:	4c 39 e9             	cmp    rcx,r13
  222143:	76 ee                	jbe    222133 <openSelfDebugInfo+0x2663>
            self.items = try self.allocator.alignedRealloc(T, A, self.items, better_capacity);
  222145:	48 8b b5 c0 00 00 00 	mov    rsi,QWORD PTR [rbp+0xc0]
  22214c:	48 89 df             	mov    rdi,rbx
  22214f:	48 8b 54 24 70       	mov    rdx,QWORD PTR [rsp+0x70]
  222154:	c5 f8 77             	vzeroupper 
  222157:	e8 04 64 00 00       	call   228560 <Allocator_alignedRealloc.171>
  22215c:	0f b7 8c 24 f0 00 00 	movzx  ecx,WORD PTR [rsp+0xf0]
  222163:	00 
  222164:	89 c8                	mov    eax,ecx
  222166:	66 85 c9             	test   cx,cx
  222169:	0f 85 a8 08 00 00    	jne    222a17 <openSelfDebugInfo+0x2f47>
  22216f:	48 8d 84 24 f8 00 00 	lea    rax,[rsp+0xf8]
  222176:	00 
  222177:	c5 fa 6f 00          	vmovdqu xmm0,XMMWORD PTR [rax]
  22217b:	48 8b 44 24 70       	mov    rax,QWORD PTR [rsp+0x70]
  222180:	c5 fa 7f 00          	vmovdqu XMMWORD PTR [rax],xmm0
            const result = &self.items[self.len];
  222184:	48 8b 85 b8 00 00 00 	mov    rax,QWORD PTR [rbp+0xb8]
  22218b:	49 83 c5 01          	add    r13,0x1
  22218f:	48 8b 8d a8 00 00 00 	mov    rcx,QWORD PTR [rbp+0xa8]
  222196:	48 8d 04 40          	lea    rax,[rax+rax*2]
  22219a:	48 c1 e0 04          	shl    rax,0x4
            self.len = new_length;
  22219e:	4c 89 ad b8 00 00 00 	mov    QWORD PTR [rbp+0xb8],r13
            new_item_ptr.* = item;
  2221a5:	48 8b 94 24 f8 02 00 	mov    rdx,QWORD PTR [rsp+0x2f8]
  2221ac:	00 
  2221ad:	66 89 14 01          	mov    WORD PTR [rcx+rax*1],dx
  2221b1:	8b 94 24 80 00 00 00 	mov    edx,DWORD PTR [rsp+0x80]
  2221b8:	88 54 01 02          	mov    BYTE PTR [rcx+rax*1+0x2],dl
  2221bc:	8a 94 24 67 02 00 00 	mov    dl,BYTE PTR [rsp+0x267]
  2221c3:	88 54 01 07          	mov    BYTE PTR [rcx+rax*1+0x7],dl
  2221c7:	8b 94 24 63 02 00 00 	mov    edx,DWORD PTR [rsp+0x263]
  2221ce:	89 54 01 03          	mov    DWORD PTR [rcx+rax*1+0x3],edx
  2221d2:	48 8b 54 24 40       	mov    rdx,QWORD PTR [rsp+0x40]
  2221d7:	48 89 54 01 08       	mov    QWORD PTR [rcx+rax*1+0x8],rdx
  2221dc:	48 8b 94 24 80 01 00 	mov    rdx,QWORD PTR [rsp+0x180]
  2221e3:	00 
  2221e4:	48 89 d6             	mov    rsi,rdx
  2221e7:	48 89 74 01 10       	mov    QWORD PTR [rcx+rax*1+0x10],rsi
  2221ec:	48 8b 94 24 60 04 00 	mov    rdx,QWORD PTR [rsp+0x460]
  2221f3:	00 
  2221f4:	48 89 54 01 28       	mov    QWORD PTR [rcx+rax*1+0x28],rdx
  2221f9:	c5 f9 6f 84 24 50 04 	vmovdqa xmm0,XMMWORD PTR [rsp+0x450]
  222200:	00 00 
  222202:	c5 fa 7f 44 01 18    	vmovdqu XMMWORD PTR [rcx+rax*1+0x18],xmm0
  222208:	48 8b 44 24 78       	mov    rax,QWORD PTR [rsp+0x78]
        const next_offset = unit_length + (if (is_64) usize(12) else usize(4));
  22220d:	48 03 44 24 68       	add    rax,QWORD PTR [rsp+0x68]
        this_unit_offset += next_offset;
  222212:	48 03 84 24 30 02 00 	add    rax,QWORD PTR [rsp+0x230]
  222219:	00 
        cu_index += 1;
  22221a:	48 83 c6 01          	add    rsi,0x1
  22221e:	48 89 b4 24 80 01 00 	mov    QWORD PTR [rsp+0x180],rsi
  222225:	00 
  222226:	31 ff                	xor    edi,edi
  222228:	48 89 44 24 68       	mov    QWORD PTR [rsp+0x68],rax
    while (this_unit_offset < debug_info_end) {
  22222d:	48 3b 84 24 90 00 00 	cmp    rax,QWORD PTR [rsp+0x90]
  222234:	00 
  222235:	0f 82 11 ee ff ff    	jb     22104c <openSelfDebugInfo+0x157c>
  22223b:	e9 18 09 00 00       	jmp    222b58 <openSelfDebugInfo+0x3088>
        return switch (form_value.*) {
  222240:	40 8a 79 20          	mov    dil,BYTE PTR [rcx+0x20]
  222244:	48 8d 35 65 72 fe ff 	lea    rsi,[rip+0xfffffffffffe7265]        # 2094b0 <__unnamed_63>
  22224b:	40 84 ff             	test   dil,dil
  22224e:	75 19                	jne    222269 <openSelfDebugInfo+0x2799>
            FormValue.Address => |value| value,
  222250:	48 8b 49 08          	mov    rcx,QWORD PTR [rcx+0x8]
  222254:	66 c7 84 24 f0 00 00 	mov    WORD PTR [rsp+0xf0],0x0
  22225b:	00 00 00 
  22225e:	48 89 8c 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],rcx
  222265:	00 
  222266:	48 89 de             	mov    rsi,rbx
            if (compile_unit_die.getAttrAddr(DW.AT_low_pc)) |low_pc| {
  222269:	0f b7 3e             	movzx  edi,WORD PTR [rsi]
        const pc_range = x: {
  22226c:	48 8d 0d 35 55 fe ff 	lea    rcx,[rip+0xfffffffffffe5535]        # 2077a8 <__unnamed_62>
  222273:	41 89 f8             	mov    r8d,edi
            if (compile_unit_die.getAttrAddr(DW.AT_low_pc)) |low_pc| {
  222276:	83 ff 28             	cmp    edi,0x28
  222279:	0f 84 83 fe ff ff    	je     222102 <openSelfDebugInfo+0x2632>
  22227f:	44 89 c7             	mov    edi,r8d
  222282:	66 85 ff             	test   di,di
  222285:	0f 85 cd 08 00 00    	jne    222b58 <openSelfDebugInfo+0x3088>
  22228b:	4c 8b 4e 08          	mov    r9,QWORD PTR [rsi+0x8]
            if (attr.id == id) return &attr.value;
  22228f:	48 83 c2 20          	add    rdx,0x20
  222293:	31 c9                	xor    ecx,ecx
  222295:	48 83 7a e0 12       	cmp    QWORD PTR [rdx-0x20],0x12
  22229a:	74 12                	je     2222ae <openSelfDebugInfo+0x27de>
        for (self.attrs.toSliceConst()) |*attr| {
  22229c:	48 83 c1 01          	add    rcx,0x1
  2222a0:	48 83 c2 28          	add    rdx,0x28
  2222a4:	48 39 c1             	cmp    rcx,rax
  2222a7:	72 ec                	jb     222295 <openSelfDebugInfo+0x27c5>
  2222a9:	e9 4d fe ff ff       	jmp    2220fb <openSelfDebugInfo+0x262b>
  2222ae:	8a 02                	mov    al,BYTE PTR [rdx]
  2222b0:	3c 02                	cmp    al,0x2
                    const pc_end = switch (high_pc_value.*) {
  2222b2:	74 15                	je     2222c9 <openSelfDebugInfo+0x27f9>
  2222b4:	66 bf 29 00          	mov    di,0x29
  2222b8:	84 c0                	test   al,al
  2222ba:	0f 85 98 08 00 00    	jne    222b58 <openSelfDebugInfo+0x3088>
                        FormValue.Address => |value| value,
  2222c0:	48 8b 42 e8          	mov    rax,QWORD PTR [rdx-0x18]
  2222c4:	e9 33 02 00 00       	jmp    2224fc <openSelfDebugInfo+0x2a2c>
                        FormValue.Const => |value| b: {
  2222c9:	4c 8b 52 f0          	mov    r10,QWORD PTR [rdx-0x10]
        if (self.payload.len > @sizeOf(u64)) return error.InvalidDebugInfo;
  2222cd:	49 83 fa 08          	cmp    r10,0x8
  2222d1:	0f 87 a6 07 00 00    	ja     222a7d <openSelfDebugInfo+0x2fad>
  2222d7:	f6 42 f8 01          	test   BYTE PTR [rdx-0x8],0x1
  2222db:	66 bf 29 00          	mov    di,0x29
  2222df:	0f 85 73 08 00 00    	jne    222b58 <openSelfDebugInfo+0x3088>
  2222e5:	4d 85 d2             	test   r10,r10
            for (bytes) |b, index| {
  2222e8:	74 13                	je     2222fd <openSelfDebugInfo+0x282d>
  2222ea:	48 8b 52 e8          	mov    rdx,QWORD PTR [rdx-0x18]
  2222ee:	49 83 fa 10          	cmp    r10,0x10
  2222f2:	73 10                	jae    222304 <openSelfDebugInfo+0x2834>
  2222f4:	31 c9                	xor    ecx,ecx
  2222f6:	31 c0                	xor    eax,eax
  2222f8:	e9 d3 01 00 00       	jmp    2224d0 <openSelfDebugInfo+0x2a00>
  2222fd:	31 c0                	xor    eax,eax
  2222ff:	e9 f5 01 00 00       	jmp    2224f9 <openSelfDebugInfo+0x2a29>
  222304:	4c 89 d1             	mov    rcx,r10
  222307:	48 83 e1 f0          	and    rcx,0xfffffffffffffff0
  22230b:	48 8d 41 f0          	lea    rax,[rcx-0x10]
  22230f:	48 89 c7             	mov    rdi,rax
  222312:	48 c1 ef 04          	shr    rdi,0x4
  222316:	44 8d 47 01          	lea    r8d,[rdi+0x1]
  22231a:	41 83 e0 01          	and    r8d,0x1
  22231e:	48 85 c0             	test   rax,rax
  222321:	0f 84 01 01 00 00    	je     222428 <openSelfDebugInfo+0x2958>
  222327:	49 8d 40 ff          	lea    rax,[r8-0x1]
  22232b:	48 29 f8             	sub    rax,rdi
  22232e:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  222332:	31 ff                	xor    edi,edi
  222334:	c5 fd 6f 25 64 de fd 	vmovdqa ymm4,YMMWORD PTR [rip+0xfffffffffffdde64]        # 2001a0 <__unnamed_44-0x60>
  22233b:	ff 
  22233c:	c5 f1 ef c9          	vpxor  xmm1,xmm1,xmm1
  222340:	c5 e1 ef db          	vpxor  xmm3,xmm3,xmm3
  222344:	c5 e9 ef d2          	vpxor  xmm2,xmm2,xmm2
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  222348:	c4 e2 7d 32 2c 3a    	vpmovzxbq ymm5,DWORD PTR [rdx+rdi*1]
  22234e:	c4 e2 7d 32 74 3a 04 	vpmovzxbq ymm6,DWORD PTR [rdx+rdi*1+0x4]
  222355:	c4 e2 7d 32 7c 3a 08 	vpmovzxbq ymm7,DWORD PTR [rdx+rdi*1+0x8]
  22235c:	c4 62 7d 32 44 3a 0c 	vpmovzxbq ymm8,DWORD PTR [rdx+rdi*1+0xc]
  222363:	c5 b5 73 f4 03       	vpsllq ymm9,ymm4,0x3
  222368:	c5 7e 6f a4 24 40 05 	vmovdqu ymm12,YMMWORD PTR [rsp+0x540]
  22236f:	00 00 
  222371:	c4 41 35 d4 d4       	vpaddq ymm10,ymm9,ymm12
  222376:	c5 7e 6f ac 24 20 05 	vmovdqu ymm13,YMMWORD PTR [rsp+0x520]
  22237d:	00 00 
  22237f:	c4 41 35 db dd       	vpand  ymm11,ymm9,ymm13
  222384:	c4 41 2d db d5       	vpand  ymm10,ymm10,ymm13
  222389:	c4 c2 d5 47 eb       	vpsllvq ymm5,ymm5,ymm11
  22238e:	c5 d5 eb c0          	vpor   ymm0,ymm5,ymm0
  222392:	c4 c2 cd 47 ea       	vpsllvq ymm5,ymm6,ymm10
  222397:	c5 d5 eb c9          	vpor   ymm1,ymm5,ymm1
  22239b:	c4 c2 c5 47 eb       	vpsllvq ymm5,ymm7,ymm11
  2223a0:	c5 d5 eb db          	vpor   ymm3,ymm5,ymm3
  2223a4:	c4 c2 bd 47 ea       	vpsllvq ymm5,ymm8,ymm10
  2223a9:	c4 e2 7d 32 74 3a 10 	vpmovzxbq ymm6,DWORD PTR [rdx+rdi*1+0x10]
  2223b0:	c4 e2 7d 32 7c 3a 14 	vpmovzxbq ymm7,DWORD PTR [rdx+rdi*1+0x14]
  2223b7:	c4 62 7d 32 44 3a 18 	vpmovzxbq ymm8,DWORD PTR [rdx+rdi*1+0x18]
  2223be:	c5 d5 eb d2          	vpor   ymm2,ymm5,ymm2
  2223c2:	c4 e2 7d 32 6c 3a 1c 	vpmovzxbq ymm5,DWORD PTR [rdx+rdi*1+0x1c]
  2223c9:	c4 62 7d 59 15 a6 df 	vpbroadcastq ymm10,QWORD PTR [rip+0xfffffffffffddfa6]        # 200378 <__unnamed_609+0x38>
  2223d0:	fd ff 
  2223d2:	c4 41 35 d4 d2       	vpaddq ymm10,ymm9,ymm10
  2223d7:	c4 62 7d 59 1d c8 de 	vpbroadcastq ymm11,QWORD PTR [rip+0xfffffffffffddec8]        # 2002a8 <__unnamed_10+0x28>
  2223de:	fd ff 
  2223e0:	c4 41 35 d4 cb       	vpaddq ymm9,ymm9,ymm11
  2223e5:	c4 41 2d db d5       	vpand  ymm10,ymm10,ymm13
  2223ea:	c4 41 35 db cd       	vpand  ymm9,ymm9,ymm13
  2223ef:	c4 c2 cd 47 f2       	vpsllvq ymm6,ymm6,ymm10
  2223f4:	c5 cd eb c0          	vpor   ymm0,ymm6,ymm0
  2223f8:	c4 c2 c5 47 f1       	vpsllvq ymm6,ymm7,ymm9
  2223fd:	c5 cd eb c9          	vpor   ymm1,ymm6,ymm1
  222401:	c4 c2 bd 47 f2       	vpsllvq ymm6,ymm8,ymm10
  222406:	c5 cd eb db          	vpor   ymm3,ymm6,ymm3
  22240a:	c4 c2 d5 47 e9       	vpsllvq ymm5,ymm5,ymm9
  22240f:	c5 d5 eb d2          	vpor   ymm2,ymm5,ymm2
            for (bytes) |b, index| {
  222413:	48 83 c7 20          	add    rdi,0x20
  222417:	c4 c1 5d d4 e4       	vpaddq ymm4,ymm4,ymm12
  22241c:	48 83 c0 02          	add    rax,0x2
  222420:	0f 85 22 ff ff ff    	jne    222348 <openSelfDebugInfo+0x2878>
  222426:	eb 1a                	jmp    222442 <openSelfDebugInfo+0x2972>
  222428:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  22242c:	31 ff                	xor    edi,edi
  22242e:	c5 fd 6f 25 6a dd fd 	vmovdqa ymm4,YMMWORD PTR [rip+0xfffffffffffddd6a]        # 2001a0 <__unnamed_44-0x60>
  222435:	ff 
  222436:	c5 f1 ef c9          	vpxor  xmm1,xmm1,xmm1
  22243a:	c5 e1 ef db          	vpxor  xmm3,xmm3,xmm3
  22243e:	c5 e9 ef d2          	vpxor  xmm2,xmm2,xmm2
  222442:	4d 85 c0             	test   r8,r8
  222445:	74 60                	je     2224a7 <openSelfDebugInfo+0x29d7>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  222447:	c4 e2 7d 32 6c 3a 0c 	vpmovzxbq ymm5,DWORD PTR [rdx+rdi*1+0xc]
  22244e:	c5 dd 73 f4 03       	vpsllq ymm4,ymm4,0x3
  222453:	c5 dd d4 b4 24 40 05 	vpaddq ymm6,ymm4,YMMWORD PTR [rsp+0x540]
  22245a:	00 00 
  22245c:	c5 7e 6f 84 24 20 05 	vmovdqu ymm8,YMMWORD PTR [rsp+0x520]
  222463:	00 00 
  222465:	c4 c1 4d db f0       	vpand  ymm6,ymm6,ymm8
  22246a:	c4 e2 d5 47 ee       	vpsllvq ymm5,ymm5,ymm6
  22246f:	c4 e2 7d 32 7c 3a 08 	vpmovzxbq ymm7,DWORD PTR [rdx+rdi*1+0x8]
  222476:	c5 d5 eb d2          	vpor   ymm2,ymm5,ymm2
  22247a:	c4 c1 5d db e0       	vpand  ymm4,ymm4,ymm8
  22247f:	c4 e2 c5 47 ec       	vpsllvq ymm5,ymm7,ymm4
  222484:	c5 d5 eb db          	vpor   ymm3,ymm5,ymm3
  222488:	c4 e2 7d 32 6c 3a 04 	vpmovzxbq ymm5,DWORD PTR [rdx+rdi*1+0x4]
  22248f:	c4 e2 d5 47 ee       	vpsllvq ymm5,ymm5,ymm6
  222494:	c5 d5 eb c9          	vpor   ymm1,ymm5,ymm1
  222498:	c4 e2 7d 32 2c 3a    	vpmovzxbq ymm5,DWORD PTR [rdx+rdi*1]
  22249e:	c4 e2 d5 47 e4       	vpsllvq ymm4,ymm5,ymm4
  2224a3:	c5 dd eb c0          	vpor   ymm0,ymm4,ymm0
  2224a7:	c5 f5 eb ca          	vpor   ymm1,ymm1,ymm2
  2224ab:	c5 fd eb c3          	vpor   ymm0,ymm0,ymm3
  2224af:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  2224b3:	c4 e3 7d 39 c1 01    	vextracti128 xmm1,ymm0,0x1
  2224b9:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  2224bd:	c5 f9 70 c8 4e       	vpshufd xmm1,xmm0,0x4e
  2224c2:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  2224c6:	c4 e1 f9 7e c0       	vmovq  rax,xmm0
  2224cb:	49 39 ca             	cmp    r10,rcx
            for (bytes) |b, index| {
  2224ce:	74 29                	je     2224f9 <openSelfDebugInfo+0x2a29>
  2224d0:	49 29 ca             	sub    r10,rcx
  2224d3:	48 01 ca             	add    rdx,rcx
  2224d6:	48 c1 e1 03          	shl    rcx,0x3
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  2224da:	0f b6 3a             	movzx  edi,BYTE PTR [rdx]
  2224dd:	89 ce                	mov    esi,ecx
  2224df:	40 80 e6 38          	and    sil,0x38
  2224e3:	c4 e2 c9 f7 f7       	shlx   rsi,rdi,rsi
  2224e8:	48 09 f0             	or     rax,rsi
            for (bytes) |b, index| {
  2224eb:	48 83 c1 08          	add    rcx,0x8
  2224ef:	48 83 c2 01          	add    rdx,0x1
  2224f3:	49 83 c2 ff          	add    r10,0xffffffffffffffff
  2224f7:	75 e1                	jne    2224da <openSelfDebugInfo+0x2a0a>
                            break :b (low_pc + offset);
  2224f9:	4c 01 c8             	add    rax,r9
                    break :x PcRange{
  2224fc:	4c 89 8c 24 70 02 00 	mov    QWORD PTR [rsp+0x270],r9
  222503:	00 
  222504:	48 89 84 24 78 02 00 	mov    QWORD PTR [rsp+0x278],rax
  22250b:	00 
  22250c:	c6 84 24 80 02 00 00 	mov    BYTE PTR [rsp+0x280],0x1
  222513:	01 
        const pc_range = x: {
  222514:	48 8d 8c 24 70 02 00 	lea    rcx,[rsp+0x270]
  22251b:	00 
  22251c:	e9 e1 fb ff ff       	jmp    222102 <openSelfDebugInfo+0x2632>
                list.first = node.next;
  222521:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  222525:	48 89 0d fc da 02 00 	mov    QWORD PTR [rip+0x2dafc],rcx        # 250028 <emfile_promise_queue>
            if (node.next) |next_node| {
  22252c:	48 85 c9             	test   rcx,rcx
  22252f:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  222532:	48 8d 35 f7 da 02 00 	lea    rsi,[rip+0x2daf7]        # 250030 <emfile_promise_queue+0x8>
  222539:	48 0f 45 f1          	cmovne rsi,rcx
  22253d:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  222540:	48 83 05 f0 da 02 00 	add    QWORD PTR [rip+0x2daf0],0xffffffffffffffff        # 250038 <emfile_promise_queue+0x10>
  222547:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  222548:	74 1e                	je     222568 <openSelfDebugInfo+0x2a98>
  22254a:	48 83 3d d6 da 02 00 	cmp    QWORD PTR [rip+0x2dad6],0x0        # 250028 <emfile_promise_queue>
  222551:	00 
  222552:	0f 84 dc 15 00 00    	je     223b34 <openSelfDebugInfo+0x4064>
  222558:	48 8b 0d d1 da 02 00 	mov    rcx,QWORD PTR [rip+0x2dad1]        # 250030 <emfile_promise_queue+0x8>
  22255f:	48 85 c9             	test   rcx,rcx
  222562:	0f 84 cc 15 00 00    	je     223b34 <openSelfDebugInfo+0x4064>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  222568:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  22256c:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  222570:	48 89 c1             	mov    rcx,rax
  222573:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  222577:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  22257d:	75 f1                	jne    222570 <openSelfDebugInfo+0x2aa0>
  22257f:	a8 01                	test   al,0x1
  222581:	75 02                	jne    222585 <openSelfDebugInfo+0x2ab5>
  222583:	ff 17                	call   QWORD PTR [rdi]
  222585:	48 63 7d 00          	movsxd rdi,DWORD PTR [rbp+0x0]
    return asm volatile ("syscall"
  222589:	b8 03 00 00 00       	mov    eax,0x3
  22258e:	0f 05                	syscall 
            switch (err) {
  222590:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  222594:	74 f3                	je     222589 <openSelfDebugInfo+0x2ab9>
            const first = list.first orelse return null;
  222596:	48 8b 05 8b da 02 00 	mov    rax,QWORD PTR [rip+0x2da8b]        # 250028 <emfile_promise_queue>
  22259d:	48 85 c0             	test   rax,rax
  2225a0:	74 7a                	je     22261c <openSelfDebugInfo+0x2b4c>
            if (node.prev) |prev_node| {
  2225a2:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  2225a5:	48 85 c9             	test   rcx,rcx
  2225a8:	74 0e                	je     2225b8 <openSelfDebugInfo+0x2ae8>
                prev_node.next = node.next;
  2225aa:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  2225ae:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  2225b2:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  2225b6:	eb 0b                	jmp    2225c3 <openSelfDebugInfo+0x2af3>
                list.first = node.next;
  2225b8:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  2225bc:	48 89 0d 65 da 02 00 	mov    QWORD PTR [rip+0x2da65],rcx        # 250028 <emfile_promise_queue>
            if (node.next) |next_node| {
  2225c3:	48 85 c9             	test   rcx,rcx
  2225c6:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  2225c9:	48 8d 35 60 da 02 00 	lea    rsi,[rip+0x2da60]        # 250030 <emfile_promise_queue+0x8>
  2225d0:	48 0f 45 f1          	cmovne rsi,rcx
  2225d4:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  2225d7:	48 83 05 59 da 02 00 	add    QWORD PTR [rip+0x2da59],0xffffffffffffffff        # 250038 <emfile_promise_queue+0x10>
  2225de:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  2225df:	74 1e                	je     2225ff <openSelfDebugInfo+0x2b2f>
  2225e1:	48 83 3d 3f da 02 00 	cmp    QWORD PTR [rip+0x2da3f],0x0        # 250028 <emfile_promise_queue>
  2225e8:	00 
  2225e9:	0f 84 45 15 00 00    	je     223b34 <openSelfDebugInfo+0x4064>
  2225ef:	48 8b 0d 3a da 02 00 	mov    rcx,QWORD PTR [rip+0x2da3a]        # 250030 <emfile_promise_queue+0x8>
  2225f6:	48 85 c9             	test   rcx,rcx
  2225f9:	0f 84 35 15 00 00    	je     223b34 <openSelfDebugInfo+0x4064>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  2225ff:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  222603:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  222607:	48 89 c1             	mov    rcx,rax
  22260a:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  22260e:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  222614:	75 f1                	jne    222607 <openSelfDebugInfo+0x2b37>
  222616:	a8 01                	test   al,0x1
  222618:	75 02                	jne    22261c <openSelfDebugInfo+0x2b4c>
  22261a:	ff 17                	call   QWORD PTR [rdi]
        self.freeFn(self, non_const_ptr[0..@sizeOf(@typeOf(ptr).Child)]);
  22261c:	49 8b 44 24 10       	mov    rax,QWORD PTR [r12+0x10]
  222621:	48 89 ac 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rbp
  222628:	00 
  222629:	48 c7 84 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],0xc8
  222630:	00 c8 00 00 00 
  222635:	48 8d b4 24 f0 00 00 	lea    rsi,[rsp+0xf0]
  22263c:	00 
  22263d:	4c 89 e7             	mov    rdi,r12
  222640:	ff d0                	call   rax
            st.debug_line = (try st.elf.findSection(".debug_line")) orelse return error.MissingDebugInfo;
  222642:	0f b7 84 24 10 03 00 	movzx  eax,WORD PTR [rsp+0x310]
  222649:	00 
  22264a:	66 41 89 06          	mov    WORD PTR [r14],ax
  22264e:	48 8b 84 24 be 04 00 	mov    rax,QWORD PTR [rsp+0x4be]
  222655:	00 
  222656:	48 8b 8c 24 c4 04 00 	mov    rcx,QWORD PTR [rsp+0x4c4]
  22265d:	00 
  22265e:	e9 84 e1 ff ff       	jmp    2207e7 <openSelfDebugInfo+0xd17>
                list.first = node.next;
  222663:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  222667:	48 89 0d ba d9 02 00 	mov    QWORD PTR [rip+0x2d9ba],rcx        # 250028 <emfile_promise_queue>
            if (node.next) |next_node| {
  22266e:	48 85 c9             	test   rcx,rcx
  222671:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  222674:	48 8d 35 b5 d9 02 00 	lea    rsi,[rip+0x2d9b5]        # 250030 <emfile_promise_queue+0x8>
  22267b:	48 0f 45 f1          	cmovne rsi,rcx
  22267f:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  222682:	48 83 05 ae d9 02 00 	add    QWORD PTR [rip+0x2d9ae],0xffffffffffffffff        # 250038 <emfile_promise_queue+0x10>
  222689:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  22268a:	74 1e                	je     2226aa <openSelfDebugInfo+0x2bda>
  22268c:	48 83 3d 94 d9 02 00 	cmp    QWORD PTR [rip+0x2d994],0x0        # 250028 <emfile_promise_queue>
  222693:	00 
  222694:	0f 84 9a 14 00 00    	je     223b34 <openSelfDebugInfo+0x4064>
  22269a:	48 8b 0d 8f d9 02 00 	mov    rcx,QWORD PTR [rip+0x2d98f]        # 250030 <emfile_promise_queue+0x8>
  2226a1:	48 85 c9             	test   rcx,rcx
  2226a4:	0f 84 8a 14 00 00    	je     223b34 <openSelfDebugInfo+0x4064>
  2226aa:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  2226ae:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  2226b2:	48 89 c1             	mov    rcx,rax
  2226b5:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  2226b9:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  2226bf:	75 f1                	jne    2226b2 <openSelfDebugInfo+0x2be2>
  2226c1:	a8 01                	test   al,0x1
  2226c3:	75 02                	jne    2226c7 <openSelfDebugInfo+0x2bf7>
  2226c5:	ff 17                	call   QWORD PTR [rdi]
  2226c7:	48 63 7d 00          	movsxd rdi,DWORD PTR [rbp+0x0]
  2226cb:	b8 03 00 00 00       	mov    eax,0x3
  2226d0:	0f 05                	syscall 
            switch (err) {
  2226d2:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  2226d6:	74 f3                	je     2226cb <openSelfDebugInfo+0x2bfb>
            const first = list.first orelse return null;
  2226d8:	48 8b 05 49 d9 02 00 	mov    rax,QWORD PTR [rip+0x2d949]        # 250028 <emfile_promise_queue>
  2226df:	48 85 c0             	test   rax,rax
  2226e2:	0f 84 9b e4 ff ff    	je     220b83 <openSelfDebugInfo+0x10b3>
            if (node.prev) |prev_node| {
  2226e8:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  2226eb:	48 85 c9             	test   rcx,rcx
  2226ee:	74 0e                	je     2226fe <openSelfDebugInfo+0x2c2e>
                prev_node.next = node.next;
  2226f0:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  2226f4:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  2226f8:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  2226fc:	eb 0b                	jmp    222709 <openSelfDebugInfo+0x2c39>
                list.first = node.next;
  2226fe:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  222702:	48 89 0d 1f d9 02 00 	mov    QWORD PTR [rip+0x2d91f],rcx        # 250028 <emfile_promise_queue>
            if (node.next) |next_node| {
  222709:	48 85 c9             	test   rcx,rcx
  22270c:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  22270f:	48 8d 35 1a d9 02 00 	lea    rsi,[rip+0x2d91a]        # 250030 <emfile_promise_queue+0x8>
  222716:	48 0f 45 f1          	cmovne rsi,rcx
  22271a:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  22271d:	48 83 05 13 d9 02 00 	add    QWORD PTR [rip+0x2d913],0xffffffffffffffff        # 250038 <emfile_promise_queue+0x10>
  222724:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  222725:	74 1e                	je     222745 <openSelfDebugInfo+0x2c75>
  222727:	48 83 3d f9 d8 02 00 	cmp    QWORD PTR [rip+0x2d8f9],0x0        # 250028 <emfile_promise_queue>
  22272e:	00 
  22272f:	0f 84 ff 13 00 00    	je     223b34 <openSelfDebugInfo+0x4064>
  222735:	48 8b 0d f4 d8 02 00 	mov    rcx,QWORD PTR [rip+0x2d8f4]        # 250030 <emfile_promise_queue+0x8>
  22273c:	48 85 c9             	test   rcx,rcx
  22273f:	0f 84 ef 13 00 00    	je     223b34 <openSelfDebugInfo+0x4064>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  222745:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  222749:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  22274d:	48 89 c1             	mov    rcx,rax
  222750:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  222754:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  22275a:	75 f1                	jne    22274d <openSelfDebugInfo+0x2c7d>
  22275c:	e9 1c e4 ff ff       	jmp    220b7d <openSelfDebugInfo+0x10ad>
  222761:	31 ff                	xor    edi,edi
  222763:	89 fb                	mov    ebx,edi
            try scanAllCompileUnits(st);
  222765:	66 85 ff             	test   di,di
  222768:	0f 85 f5 03 00 00    	jne    222b63 <openSelfDebugInfo+0x3093>
            return st;
  22276e:	66 41 c7 06 00 00    	mov    WORD PTR [r14],0x0
  222774:	0f b7 84 24 be 02 00 	movzx  eax,WORD PTR [rsp+0x2be]
  22277b:	00 
  22277c:	66 41 89 46 06       	mov    WORD PTR [r14+0x6],ax
  222781:	8b 84 24 ba 02 00 00 	mov    eax,DWORD PTR [rsp+0x2ba]
  222788:	41 89 46 02          	mov    DWORD PTR [r14+0x2],eax
  22278c:	49 89 6e 08          	mov    QWORD PTR [r14+0x8],rbp
  222790:	e9 5a e0 ff ff       	jmp    2207ef <openSelfDebugInfo+0xd1f>
                list.first = node.next;
  222795:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  222799:	48 89 0d 88 d8 02 00 	mov    QWORD PTR [rip+0x2d888],rcx        # 250028 <emfile_promise_queue>
            if (node.next) |next_node| {
  2227a0:	48 85 c9             	test   rcx,rcx
  2227a3:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  2227a6:	48 8d 35 83 d8 02 00 	lea    rsi,[rip+0x2d883]        # 250030 <emfile_promise_queue+0x8>
  2227ad:	48 0f 45 f1          	cmovne rsi,rcx
  2227b1:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  2227b4:	48 83 05 7c d8 02 00 	add    QWORD PTR [rip+0x2d87c],0xffffffffffffffff        # 250038 <emfile_promise_queue+0x10>
  2227bb:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  2227bc:	74 1e                	je     2227dc <openSelfDebugInfo+0x2d0c>
  2227be:	48 83 3d 62 d8 02 00 	cmp    QWORD PTR [rip+0x2d862],0x0        # 250028 <emfile_promise_queue>
  2227c5:	00 
  2227c6:	0f 84 68 13 00 00    	je     223b34 <openSelfDebugInfo+0x4064>
  2227cc:	48 8b 0d 5d d8 02 00 	mov    rcx,QWORD PTR [rip+0x2d85d]        # 250030 <emfile_promise_queue+0x8>
  2227d3:	48 85 c9             	test   rcx,rcx
  2227d6:	0f 84 58 13 00 00    	je     223b34 <openSelfDebugInfo+0x4064>
  2227dc:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  2227e0:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  2227e4:	48 89 c1             	mov    rcx,rax
  2227e7:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  2227eb:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  2227f1:	75 f1                	jne    2227e4 <openSelfDebugInfo+0x2d14>
  2227f3:	a8 01                	test   al,0x1
  2227f5:	75 02                	jne    2227f9 <openSelfDebugInfo+0x2d29>
  2227f7:	ff 17                	call   QWORD PTR [rdi]
  2227f9:	48 63 7d 00          	movsxd rdi,DWORD PTR [rbp+0x0]
  2227fd:	b8 03 00 00 00       	mov    eax,0x3
  222802:	0f 05                	syscall 
            switch (err) {
  222804:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  222808:	74 f3                	je     2227fd <openSelfDebugInfo+0x2d2d>
            const first = list.first orelse return null;
  22280a:	48 8b 05 17 d8 02 00 	mov    rax,QWORD PTR [rip+0x2d817]        # 250028 <emfile_promise_queue>
  222811:	48 85 c0             	test   rax,rax
  222814:	74 7a                	je     222890 <openSelfDebugInfo+0x2dc0>
            if (node.prev) |prev_node| {
  222816:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  222819:	48 85 c9             	test   rcx,rcx
  22281c:	74 0e                	je     22282c <openSelfDebugInfo+0x2d5c>
                prev_node.next = node.next;
  22281e:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  222822:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  222826:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  22282a:	eb 0b                	jmp    222837 <openSelfDebugInfo+0x2d67>
                list.first = node.next;
  22282c:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  222830:	48 89 0d f1 d7 02 00 	mov    QWORD PTR [rip+0x2d7f1],rcx        # 250028 <emfile_promise_queue>
            if (node.next) |next_node| {
  222837:	48 85 c9             	test   rcx,rcx
  22283a:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  22283d:	48 8d 35 ec d7 02 00 	lea    rsi,[rip+0x2d7ec]        # 250030 <emfile_promise_queue+0x8>
  222844:	48 0f 45 f1          	cmovne rsi,rcx
  222848:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  22284b:	48 83 05 e5 d7 02 00 	add    QWORD PTR [rip+0x2d7e5],0xffffffffffffffff        # 250038 <emfile_promise_queue+0x10>
  222852:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  222853:	74 1e                	je     222873 <openSelfDebugInfo+0x2da3>
  222855:	48 83 3d cb d7 02 00 	cmp    QWORD PTR [rip+0x2d7cb],0x0        # 250028 <emfile_promise_queue>
  22285c:	00 
  22285d:	0f 84 d1 12 00 00    	je     223b34 <openSelfDebugInfo+0x4064>
  222863:	48 8b 0d c6 d7 02 00 	mov    rcx,QWORD PTR [rip+0x2d7c6]        # 250030 <emfile_promise_queue+0x8>
  22286a:	48 85 c9             	test   rcx,rcx
  22286d:	0f 84 c1 12 00 00    	je     223b34 <openSelfDebugInfo+0x4064>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  222873:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  222877:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  22287b:	48 89 c1             	mov    rcx,rax
  22287e:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  222882:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  222888:	75 f1                	jne    22287b <openSelfDebugInfo+0x2dab>
  22288a:	a8 01                	test   al,0x1
  22288c:	75 02                	jne    222890 <openSelfDebugInfo+0x2dc0>
  22288e:	ff 17                	call   QWORD PTR [rdi]
  222890:	49 8b 44 24 10       	mov    rax,QWORD PTR [r12+0x10]
  222895:	48 89 ac 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rbp
  22289c:	00 
  22289d:	48 c7 84 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],0xc8
  2228a4:	00 c8 00 00 00 
  2228a9:	48 8d b4 24 f0 00 00 	lea    rsi,[rsp+0xf0]
  2228b0:	00 
  2228b1:	4c 89 e7             	mov    rdi,r12
  2228b4:	ff d0                	call   rax
            st.debug_ranges = (try st.elf.findSection(".debug_ranges"));
  2228b6:	0f b7 84 24 00 03 00 	movzx  eax,WORD PTR [rsp+0x300]
  2228bd:	00 
  2228be:	66 41 89 06          	mov    WORD PTR [r14],ax
  2228c2:	48 8b 84 24 b0 04 00 	mov    rax,QWORD PTR [rsp+0x4b0]
  2228c9:	00 
  2228ca:	48 8b 8c 24 b6 04 00 	mov    rcx,QWORD PTR [rsp+0x4b6]
  2228d1:	00 
  2228d2:	e9 10 df ff ff       	jmp    2207e7 <openSelfDebugInfo+0xd17>
                list.first = node.next;
  2228d7:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  2228db:	48 89 0d 46 d7 02 00 	mov    QWORD PTR [rip+0x2d746],rcx        # 250028 <emfile_promise_queue>
            if (node.next) |next_node| {
  2228e2:	48 85 c9             	test   rcx,rcx
  2228e5:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  2228e8:	48 8d 35 41 d7 02 00 	lea    rsi,[rip+0x2d741]        # 250030 <emfile_promise_queue+0x8>
  2228ef:	48 0f 45 f1          	cmovne rsi,rcx
  2228f3:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  2228f6:	48 83 05 3a d7 02 00 	add    QWORD PTR [rip+0x2d73a],0xffffffffffffffff        # 250038 <emfile_promise_queue+0x10>
  2228fd:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  2228fe:	74 1e                	je     22291e <openSelfDebugInfo+0x2e4e>
  222900:	48 83 3d 20 d7 02 00 	cmp    QWORD PTR [rip+0x2d720],0x0        # 250028 <emfile_promise_queue>
  222907:	00 
  222908:	0f 84 26 12 00 00    	je     223b34 <openSelfDebugInfo+0x4064>
  22290e:	48 8b 0d 1b d7 02 00 	mov    rcx,QWORD PTR [rip+0x2d71b]        # 250030 <emfile_promise_queue+0x8>
  222915:	48 85 c9             	test   rcx,rcx
  222918:	0f 84 16 12 00 00    	je     223b34 <openSelfDebugInfo+0x4064>
  22291e:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  222922:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  222926:	48 89 c1             	mov    rcx,rax
  222929:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  22292d:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  222933:	75 f1                	jne    222926 <openSelfDebugInfo+0x2e56>
  222935:	a8 01                	test   al,0x1
  222937:	75 02                	jne    22293b <openSelfDebugInfo+0x2e6b>
  222939:	ff 17                	call   QWORD PTR [rdi]
  22293b:	48 63 7d 00          	movsxd rdi,DWORD PTR [rbp+0x0]
  22293f:	b8 03 00 00 00       	mov    eax,0x3
  222944:	0f 05                	syscall 
            switch (err) {
  222946:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  22294a:	74 f3                	je     22293f <openSelfDebugInfo+0x2e6f>
            const first = list.first orelse return null;
  22294c:	48 8b 05 d5 d6 02 00 	mov    rax,QWORD PTR [rip+0x2d6d5]        # 250028 <emfile_promise_queue>
  222953:	48 85 c0             	test   rax,rax
  222956:	0f 84 27 e2 ff ff    	je     220b83 <openSelfDebugInfo+0x10b3>
            if (node.prev) |prev_node| {
  22295c:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  22295f:	48 85 c9             	test   rcx,rcx
  222962:	74 0e                	je     222972 <openSelfDebugInfo+0x2ea2>
                prev_node.next = node.next;
  222964:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  222968:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  22296c:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  222970:	eb 0b                	jmp    22297d <openSelfDebugInfo+0x2ead>
                list.first = node.next;
  222972:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  222976:	48 89 0d ab d6 02 00 	mov    QWORD PTR [rip+0x2d6ab],rcx        # 250028 <emfile_promise_queue>
            if (node.next) |next_node| {
  22297d:	48 85 c9             	test   rcx,rcx
  222980:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  222983:	48 8d 35 a6 d6 02 00 	lea    rsi,[rip+0x2d6a6]        # 250030 <emfile_promise_queue+0x8>
  22298a:	48 0f 45 f1          	cmovne rsi,rcx
  22298e:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  222991:	48 83 05 9f d6 02 00 	add    QWORD PTR [rip+0x2d69f],0xffffffffffffffff        # 250038 <emfile_promise_queue+0x10>
  222998:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  222999:	74 1e                	je     2229b9 <openSelfDebugInfo+0x2ee9>
  22299b:	48 83 3d 85 d6 02 00 	cmp    QWORD PTR [rip+0x2d685],0x0        # 250028 <emfile_promise_queue>
  2229a2:	00 
  2229a3:	0f 84 8b 11 00 00    	je     223b34 <openSelfDebugInfo+0x4064>
  2229a9:	48 8b 0d 80 d6 02 00 	mov    rcx,QWORD PTR [rip+0x2d680]        # 250030 <emfile_promise_queue+0x8>
  2229b0:	48 85 c9             	test   rcx,rcx
  2229b3:	0f 84 7b 11 00 00    	je     223b34 <openSelfDebugInfo+0x4064>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  2229b9:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  2229bd:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  2229c1:	48 89 c1             	mov    rcx,rax
  2229c4:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  2229c8:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  2229ce:	75 f1                	jne    2229c1 <openSelfDebugInfo+0x2ef1>
  2229d0:	e9 a8 e1 ff ff       	jmp    220b7d <openSelfDebugInfo+0x10ad>
  2229d5:	66 b9 25 00          	mov    cx,0x25
  2229d9:	eb 04                	jmp    2229df <openSelfDebugInfo+0x2f0f>
  2229db:	66 b9 29 00          	mov    cx,0x29
        const abbrev_code = try readULeb128(in_stream);
  2229df:	48 8b 84 24 0e 01 00 	mov    rax,QWORD PTR [rsp+0x10e]
  2229e6:	00 
  2229e7:	48 89 84 24 ee 01 00 	mov    QWORD PTR [rsp+0x1ee],rax
  2229ee:	00 
  2229ef:	c5 fe 6f 84 24 f0 00 	vmovdqu ymm0,YMMWORD PTR [rsp+0xf0]
  2229f6:	00 00 
  2229f8:	c5 fe 7f 84 24 d0 01 	vmovdqu YMMWORD PTR [rsp+0x1d0],ymm0
  2229ff:	00 00 
  222a01:	89 cf                	mov    edi,ecx
  222a03:	89 fb                	mov    ebx,edi
            try scanAllCompileUnits(st);
  222a05:	66 85 ff             	test   di,di
  222a08:	0f 85 55 01 00 00    	jne    222b63 <openSelfDebugInfo+0x3093>
  222a0e:	e9 5b fd ff ff       	jmp    22276e <openSelfDebugInfo+0x2c9e>
  222a13:	66 b8 25 00          	mov    ax,0x25
  222a17:	89 c7                	mov    edi,eax
  222a19:	89 fb                	mov    ebx,edi
  222a1b:	66 85 ff             	test   di,di
  222a1e:	0f 85 3f 01 00 00    	jne    222b63 <openSelfDebugInfo+0x3093>
  222a24:	e9 45 fd ff ff       	jmp    22276e <openSelfDebugInfo+0x2c9e>
  222a29:	66 b9 25 00          	mov    cx,0x25
  222a2d:	eb 04                	jmp    222a33 <openSelfDebugInfo+0x2f63>
  222a2f:	66 b9 29 00          	mov    cx,0x29
    const abbrev_code = try readULeb128(in_stream);
  222a33:	c5 fe 6f 84 24 f0 00 	vmovdqu ymm0,YMMWORD PTR [rsp+0xf0]
  222a3a:	00 00 
  222a3c:	c5 fe 6f 8c 24 06 01 	vmovdqu ymm1,YMMWORD PTR [rsp+0x106]
  222a43:	00 00 
  222a45:	c5 fe 7f 8c 24 d6 02 	vmovdqu YMMWORD PTR [rsp+0x2d6],ymm1
  222a4c:	00 00 
  222a4e:	c5 fe 7f 84 24 c0 02 	vmovdqu YMMWORD PTR [rsp+0x2c0],ymm0
  222a55:	00 00 
  222a57:	89 cf                	mov    edi,ecx
  222a59:	89 fb                	mov    ebx,edi
            try scanAllCompileUnits(st);
  222a5b:	66 85 ff             	test   di,di
  222a5e:	0f 85 ff 00 00 00    	jne    222b63 <openSelfDebugInfo+0x3093>
  222a64:	e9 05 fd ff ff       	jmp    22276e <openSelfDebugInfo+0x2c9e>
  222a69:	66 bf 04 00          	mov    di,0x4
  222a6d:	89 fb                	mov    ebx,edi
  222a6f:	66 85 ff             	test   di,di
  222a72:	0f 85 eb 00 00 00    	jne    222b63 <openSelfDebugInfo+0x3093>
  222a78:	e9 f1 fc ff ff       	jmp    22276e <openSelfDebugInfo+0x2c9e>
  222a7d:	66 bf 29 00          	mov    di,0x29
  222a81:	89 fb                	mov    ebx,edi
  222a83:	66 85 ff             	test   di,di
  222a86:	0f 85 d7 00 00 00    	jne    222b63 <openSelfDebugInfo+0x3093>
  222a8c:	e9 dd fc ff ff       	jmp    22276e <openSelfDebugInfo+0x2c9e>
  222a91:	48 8d 41 ea          	lea    rax,[rcx-0x16]
  222a95:	48 83 f8 35          	cmp    rax,0x35
  222a99:	77 14                	ja     222aaf <openSelfDebugInfo+0x2fdf>
  222a9b:	48 ba 81 00 00 00 00 	movabs rdx,0x20000000000081
  222aa2:	00 20 00 
  222aa5:	48 0f a3 c2          	bt     rdx,rax
  222aa9:	0f 82 9f 00 00 00    	jb     222b4e <openSelfDebugInfo+0x307e>
  222aaf:	66 bf 03 00          	mov    di,0x3
  222ab3:	48 83 f9 06          	cmp    rcx,0x6
  222ab7:	0f 84 91 00 00 00    	je     222b4e <openSelfDebugInfo+0x307e>
  222abd:	e9 96 00 00 00       	jmp    222b58 <openSelfDebugInfo+0x3088>
    const table_entry = getAbbrevTableEntry(abbrev_table, abbrev_code) orelse return error.InvalidDebugInfo;
  222ac2:	c5 fc 10 05 9e 4d fe 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffe4d9e]        # 207868 <__unnamed_64+0x18>
  222ac9:	ff 
  222aca:	c5 fc 11 84 24 d6 02 	vmovups YMMWORD PTR [rsp+0x2d6],ymm0
  222ad1:	00 00 
  222ad3:	c5 fe 6f 05 77 4d fe 	vmovdqu ymm0,YMMWORD PTR [rip+0xfffffffffffe4d77]        # 207852 <__unnamed_64+0x2>
  222ada:	ff 
  222adb:	c5 fe 7f 84 24 c0 02 	vmovdqu YMMWORD PTR [rsp+0x2c0],ymm0
  222ae2:	00 00 
  222ae4:	66 bf 29 00          	mov    di,0x29
  222ae8:	89 fb                	mov    ebx,edi
            try scanAllCompileUnits(st);
  222aea:	66 85 ff             	test   di,di
  222aed:	75 74                	jne    222b63 <openSelfDebugInfo+0x3093>
  222aef:	e9 7a fc ff ff       	jmp    22276e <openSelfDebugInfo+0x2c9e>
  222af4:	66 b9 25 00          	mov    cx,0x25
  222af8:	eb 04                	jmp    222afe <openSelfDebugInfo+0x302e>
  222afa:	66 b9 29 00          	mov    cx,0x29
            .tag_id = try readULeb128(in_stream),
  222afe:	48 8b 84 24 f6 03 00 	mov    rax,QWORD PTR [rsp+0x3f6]
  222b05:	00 
  222b06:	48 89 84 24 ee 01 00 	mov    QWORD PTR [rsp+0x1ee],rax
  222b0d:	00 
  222b0e:	c5 fc 10 84 24 d8 03 	vmovups ymm0,YMMWORD PTR [rsp+0x3d8]
  222b15:	00 00 
  222b17:	e9 dc fe ff ff       	jmp    2229f8 <openSelfDebugInfo+0x2f28>
  222b1c:	48 8d 4e ea          	lea    rcx,[rsi-0x16]
  222b20:	48 83 f9 35          	cmp    rcx,0x35
  222b24:	77 14                	ja     222b3a <openSelfDebugInfo+0x306a>
  222b26:	48 ba 81 00 00 00 00 	movabs rdx,0x20000000000081
  222b2d:	00 20 00 
  222b30:	48 0f a3 ca          	bt     rdx,rcx
  222b34:	0f 82 06 02 00 00    	jb     222d40 <openSelfDebugInfo+0x3270>
  222b3a:	66 c7 84 24 c8 01 00 	mov    WORD PTR [rsp+0x1c8],0x3
  222b41:	00 03 00 
                if (err > 0) {
  222b44:	48 83 fe 06          	cmp    rsi,0x6
  222b48:	66 bf 27 00          	mov    di,0x27
  222b4c:	74 0a                	je     222b58 <openSelfDebugInfo+0x3088>
  222b4e:	0f b7 84 24 c8 01 00 	movzx  eax,WORD PTR [rsp+0x1c8]
  222b55:	00 
  222b56:	89 c7                	mov    edi,eax
  222b58:	89 fb                	mov    ebx,edi
            try scanAllCompileUnits(st);
  222b5a:	66 85 ff             	test   di,di
  222b5d:	0f 84 0b fc ff ff    	je     22276e <openSelfDebugInfo+0x2c9e>
        const bytes = @sliceToBytes(memory);
  222b63:	48 8b 45 48          	mov    rax,QWORD PTR [rbp+0x48]
  222b67:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  222b6b:	74 29                	je     222b96 <openSelfDebugInfo+0x30c6>
  222b6d:	48 8b 7d 50          	mov    rdi,QWORD PTR [rbp+0x50]
        const bytes = @sliceToBytes(memory);
  222b71:	48 8b 4d 40          	mov    rcx,QWORD PTR [rbp+0x40]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  222b75:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  222b79:	48 89 8c 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rcx
  222b80:	00 
  222b81:	48 89 84 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],rax
  222b88:	00 
  222b89:	48 8d b4 24 f0 00 00 	lea    rsi,[rsp+0xf0]
  222b90:	00 
  222b91:	c5 f8 77             	vzeroupper 
  222b94:	ff d2                	call   rdx
  222b96:	80 7d 10 01          	cmp    BYTE PTR [rbp+0x10],0x1
  222b9a:	0f 85 9c 00 00 00    	jne    222c3c <openSelfDebugInfo+0x316c>
  222ba0:	49 8b 07             	mov    rax,QWORD PTR [r15]
  222ba3:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  222ba6:	b8 03 00 00 00       	mov    eax,0x3
  222bab:	0f 05                	syscall 
            switch (err) {
  222bad:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  222bb1:	74 f3                	je     222ba6 <openSelfDebugInfo+0x30d6>
            const first = list.first orelse return null;
  222bb3:	48 8b 05 6e d4 02 00 	mov    rax,QWORD PTR [rip+0x2d46e]        # 250028 <emfile_promise_queue>
  222bba:	48 85 c0             	test   rax,rax
  222bbd:	74 7d                	je     222c3c <openSelfDebugInfo+0x316c>
            if (node.prev) |prev_node| {
  222bbf:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  222bc2:	48 85 c9             	test   rcx,rcx
  222bc5:	74 0e                	je     222bd5 <openSelfDebugInfo+0x3105>
                prev_node.next = node.next;
  222bc7:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  222bcb:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  222bcf:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  222bd3:	eb 0b                	jmp    222be0 <openSelfDebugInfo+0x3110>
                list.first = node.next;
  222bd5:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  222bd9:	48 89 0d 48 d4 02 00 	mov    QWORD PTR [rip+0x2d448],rcx        # 250028 <emfile_promise_queue>
            if (node.next) |next_node| {
  222be0:	48 85 c9             	test   rcx,rcx
  222be3:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  222be6:	48 8d 35 43 d4 02 00 	lea    rsi,[rip+0x2d443]        # 250030 <emfile_promise_queue+0x8>
  222bed:	48 0f 45 f1          	cmovne rsi,rcx
  222bf1:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  222bf4:	48 83 05 3c d4 02 00 	add    QWORD PTR [rip+0x2d43c],0xffffffffffffffff        # 250038 <emfile_promise_queue+0x10>
  222bfb:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  222bfc:	74 1e                	je     222c1c <openSelfDebugInfo+0x314c>
  222bfe:	48 83 3d 22 d4 02 00 	cmp    QWORD PTR [rip+0x2d422],0x0        # 250028 <emfile_promise_queue>
  222c05:	00 
  222c06:	0f 84 28 0f 00 00    	je     223b34 <openSelfDebugInfo+0x4064>
  222c0c:	48 8b 0d 1d d4 02 00 	mov    rcx,QWORD PTR [rip+0x2d41d]        # 250030 <emfile_promise_queue+0x8>
  222c13:	48 85 c9             	test   rcx,rcx
  222c16:	0f 84 18 0f 00 00    	je     223b34 <openSelfDebugInfo+0x4064>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  222c1c:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  222c20:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  222c24:	48 89 c1             	mov    rcx,rax
  222c27:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  222c2b:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  222c31:	75 f1                	jne    222c24 <openSelfDebugInfo+0x3154>
  222c33:	a8 01                	test   al,0x1
  222c35:	75 05                	jne    222c3c <openSelfDebugInfo+0x316c>
  222c37:	c5 f8 77             	vzeroupper 
  222c3a:	ff 17                	call   QWORD PTR [rdi]
  222c3c:	48 63 7d 00          	movsxd rdi,DWORD PTR [rbp+0x0]
  222c40:	b8 03 00 00 00       	mov    eax,0x3
  222c45:	0f 05                	syscall 
            switch (err) {
  222c47:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  222c4b:	74 f3                	je     222c40 <openSelfDebugInfo+0x3170>
            const first = list.first orelse return null;
  222c4d:	48 8b 05 d4 d3 02 00 	mov    rax,QWORD PTR [rip+0x2d3d4]        # 250028 <emfile_promise_queue>
  222c54:	48 85 c0             	test   rax,rax
  222c57:	74 7d                	je     222cd6 <openSelfDebugInfo+0x3206>
            if (node.prev) |prev_node| {
  222c59:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  222c5c:	48 85 c9             	test   rcx,rcx
  222c5f:	74 0e                	je     222c6f <openSelfDebugInfo+0x319f>
                prev_node.next = node.next;
  222c61:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  222c65:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  222c69:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  222c6d:	eb 0b                	jmp    222c7a <openSelfDebugInfo+0x31aa>
                list.first = node.next;
  222c6f:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  222c73:	48 89 0d ae d3 02 00 	mov    QWORD PTR [rip+0x2d3ae],rcx        # 250028 <emfile_promise_queue>
            if (node.next) |next_node| {
  222c7a:	48 85 c9             	test   rcx,rcx
  222c7d:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  222c80:	48 8d 35 a9 d3 02 00 	lea    rsi,[rip+0x2d3a9]        # 250030 <emfile_promise_queue+0x8>
  222c87:	48 0f 45 f1          	cmovne rsi,rcx
  222c8b:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  222c8e:	48 83 05 a2 d3 02 00 	add    QWORD PTR [rip+0x2d3a2],0xffffffffffffffff        # 250038 <emfile_promise_queue+0x10>
  222c95:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  222c96:	74 1e                	je     222cb6 <openSelfDebugInfo+0x31e6>
  222c98:	48 83 3d 88 d3 02 00 	cmp    QWORD PTR [rip+0x2d388],0x0        # 250028 <emfile_promise_queue>
  222c9f:	00 
  222ca0:	0f 84 8e 0e 00 00    	je     223b34 <openSelfDebugInfo+0x4064>
  222ca6:	48 8b 0d 83 d3 02 00 	mov    rcx,QWORD PTR [rip+0x2d383]        # 250030 <emfile_promise_queue+0x8>
  222cad:	48 85 c9             	test   rcx,rcx
  222cb0:	0f 84 7e 0e 00 00    	je     223b34 <openSelfDebugInfo+0x4064>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  222cb6:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  222cba:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  222cbe:	48 89 c1             	mov    rcx,rax
  222cc1:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  222cc5:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  222ccb:	75 f1                	jne    222cbe <openSelfDebugInfo+0x31ee>
  222ccd:	a8 01                	test   al,0x1
  222ccf:	75 05                	jne    222cd6 <openSelfDebugInfo+0x3206>
  222cd1:	c5 f8 77             	vzeroupper 
  222cd4:	ff 17                	call   QWORD PTR [rdi]
        self.freeFn(self, non_const_ptr[0..@sizeOf(@typeOf(ptr).Child)]);
  222cd6:	49 8b 44 24 10       	mov    rax,QWORD PTR [r12+0x10]
  222cdb:	48 89 ac 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rbp
  222ce2:	00 
  222ce3:	48 c7 84 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],0xc8
  222cea:	00 c8 00 00 00 
  222cef:	48 8d b4 24 f0 00 00 	lea    rsi,[rsp+0xf0]
  222cf6:	00 
  222cf7:	4c 89 e7             	mov    rdi,r12
  222cfa:	c5 f8 77             	vzeroupper 
  222cfd:	ff d0                	call   rax
  222cff:	66 41 89 1e          	mov    WORD PTR [r14],bx
  222d03:	48 8b 84 24 a2 04 00 	mov    rax,QWORD PTR [rsp+0x4a2]
  222d0a:	00 
  222d0b:	48 8b 8c 24 a8 04 00 	mov    rcx,QWORD PTR [rsp+0x4a8]
  222d12:	00 
  222d13:	e9 cf da ff ff       	jmp    2207e7 <openSelfDebugInfo+0xd17>
  222d18:	48 8d 41 ea          	lea    rax,[rcx-0x16]
  222d1c:	48 83 f8 35          	cmp    rax,0x35
  222d20:	77 10                	ja     222d32 <openSelfDebugInfo+0x3262>
  222d22:	48 ba 81 00 00 00 00 	movabs rdx,0x20000000000081
  222d29:	00 20 00 
  222d2c:	48 0f a3 c2          	bt     rdx,rax
  222d30:	72 0e                	jb     222d40 <openSelfDebugInfo+0x3270>
  222d32:	66 bf 03 00          	mov    di,0x3
                if (err > 0) {
  222d36:	48 83 f9 06          	cmp    rcx,0x6
  222d3a:	0f 85 18 fe ff ff    	jne    222b58 <openSelfDebugInfo+0x3088>
  222d40:	66 bf 27 00          	mov    di,0x27
  222d44:	89 fb                	mov    ebx,edi
  222d46:	66 85 ff             	test   di,di
  222d49:	0f 85 14 fe ff ff    	jne    222b63 <openSelfDebugInfo+0x3093>
  222d4f:	e9 1a fa ff ff       	jmp    22276e <openSelfDebugInfo+0x2c9e>
            .value = try parseFormValue(st.allocator(), in_stream, attr.form_id, is_64),
  222d54:	c5 fc 10 84 24 d8 03 	vmovups ymm0,YMMWORD PTR [rsp+0x3d8]
  222d5b:	00 00 
  222d5d:	c5 fc 10 8c 24 ee 03 	vmovups ymm1,YMMWORD PTR [rsp+0x3ee]
  222d64:	00 00 
  222d66:	c5 fc 11 8c 24 d6 02 	vmovups YMMWORD PTR [rsp+0x2d6],ymm1
  222d6d:	00 00 
  222d6f:	c5 fc 11 84 24 c0 02 	vmovups YMMWORD PTR [rsp+0x2c0],ymm0
  222d76:	00 00 
  222d78:	89 c7                	mov    edi,eax
  222d7a:	89 fb                	mov    ebx,edi
            try scanAllCompileUnits(st);
  222d7c:	66 85 ff             	test   di,di
  222d7f:	0f 85 de fd ff ff    	jne    222b63 <openSelfDebugInfo+0x3093>
  222d85:	e9 e4 f9 ff ff       	jmp    22276e <openSelfDebugInfo+0x2c9e>
  222d8a:	66 b9 25 00          	mov    cx,0x25
  222d8e:	eb 04                	jmp    222d94 <openSelfDebugInfo+0x32c4>
  222d90:	66 b9 29 00          	mov    cx,0x29
            const form_id = try readULeb128(in_stream);
  222d94:	48 8b 84 24 be 03 00 	mov    rax,QWORD PTR [rsp+0x3be]
  222d9b:	00 
  222d9c:	48 89 84 24 ee 01 00 	mov    QWORD PTR [rsp+0x1ee],rax
  222da3:	00 
  222da4:	c5 fc 10 84 24 a0 03 	vmovups ymm0,YMMWORD PTR [rsp+0x3a0]
  222dab:	00 00 
  222dad:	e9 46 fc ff ff       	jmp    2229f8 <openSelfDebugInfo+0x2f28>
  222db2:	66 b9 25 00          	mov    cx,0x25
  222db6:	eb 04                	jmp    222dbc <openSelfDebugInfo+0x32ec>
  222db8:	66 b9 29 00          	mov    cx,0x29
            const attr_id = try readULeb128(in_stream);
  222dbc:	48 8b 84 24 96 03 00 	mov    rax,QWORD PTR [rsp+0x396]
  222dc3:	00 
  222dc4:	48 89 84 24 ee 01 00 	mov    QWORD PTR [rsp+0x1ee],rax
  222dcb:	00 
  222dcc:	c5 fc 10 84 24 78 03 	vmovups ymm0,YMMWORD PTR [rsp+0x378]
  222dd3:	00 00 
  222dd5:	e9 1e fc ff ff       	jmp    2229f8 <openSelfDebugInfo+0x2f28>
  222dda:	66 b9 25 00          	mov    cx,0x25
            .has_children = (try in_stream.readByte()) == DW.CHILDREN_yes,
  222dde:	48 8b 84 24 86 04 00 	mov    rax,QWORD PTR [rsp+0x486]
  222de5:	00 
  222de6:	48 89 84 24 ee 01 00 	mov    QWORD PTR [rsp+0x1ee],rax
  222ded:	00 
  222dee:	c5 fc 10 84 24 68 04 	vmovups ymm0,YMMWORD PTR [rsp+0x468]
  222df5:	00 00 
  222df7:	e9 fc fb ff ff       	jmp    2229f8 <openSelfDebugInfo+0x2f28>
    try result.attrs.resize(table_entry.attrs.len);
  222dfc:	c5 fc 10 84 24 98 00 	vmovups ymm0,YMMWORD PTR [rsp+0x98]
  222e03:	00 00 
  222e05:	c5 fc 10 8c 24 ae 00 	vmovups ymm1,YMMWORD PTR [rsp+0xae]
  222e0c:	00 00 
  222e0e:	e9 53 ff ff ff       	jmp    222d66 <openSelfDebugInfo+0x3296>
        try result.append(AbbrevTableEntry{
  222e13:	48 8b 84 24 a6 02 00 	mov    rax,QWORD PTR [rsp+0x2a6]
  222e1a:	00 
  222e1b:	48 89 84 24 ee 01 00 	mov    QWORD PTR [rsp+0x1ee],rax
  222e22:	00 
  222e23:	c5 fc 10 84 24 88 02 	vmovups ymm0,YMMWORD PTR [rsp+0x288]
  222e2a:	00 00 
  222e2c:	e9 c7 fb ff ff       	jmp    2229f8 <openSelfDebugInfo+0x2f28>
            try attrs.append(AbbrevAttr{
  222e31:	48 8b 84 24 6e 03 00 	mov    rax,QWORD PTR [rsp+0x36e]
  222e38:	00 
  222e39:	48 89 84 24 ee 01 00 	mov    QWORD PTR [rsp+0x1ee],rax
  222e40:	00 
  222e41:	c5 fc 10 84 24 50 03 	vmovups ymm0,YMMWORD PTR [rsp+0x350]
  222e48:	00 00 
  222e4a:	e9 a9 fb ff ff       	jmp    2229f8 <openSelfDebugInfo+0x2f28>
            try self.readNoEof(bytes[0..]);
  222e4f:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  222e54:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  222e5b:	00 
  222e5c:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x4
  222e63:	00 04 00 00 00 
  222e68:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  222e6f:	00 
  222e70:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  222e77:	00 
            return self.readFn(self, buffer);
  222e78:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  222e7d:	ff 54 24 58          	call   QWORD PTR [rsp+0x58]
  222e81:	44 0f b7 ac 24 f0 00 	movzx  r13d,WORD PTR [rsp+0xf0]
  222e88:	00 00 
            const amt_read = try self.read(buf);
  222e8a:	66 45 85 ed          	test   r13w,r13w
  222e8e:	0f 85 88 ce ff ff    	jne    21fd1c <openSelfDebugInfo+0x24c>
  222e94:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  222e9b:	00 
  222e9c:	66 41 bd 25 00       	mov    r13w,0x25
            if (amt_read < buf.len) return error.EndOfStream;
  222ea1:	48 3b 84 24 a0 00 00 	cmp    rax,QWORD PTR [rsp+0xa0]
  222ea8:	00 
  222ea9:	0f 82 6d ce ff ff    	jb     21fd1c <openSelfDebugInfo+0x24c>
  222eaf:	0f b6 44 24 20       	movzx  eax,BYTE PTR [rsp+0x20]
  222eb4:	0f b6 4c 24 21       	movzx  ecx,BYTE PTR [rsp+0x21]
    switch (endian) {
  222eb9:	f6 44 24 40 01       	test   BYTE PTR [rsp+0x40],0x1
  222ebe:	74 1b                	je     222edb <openSelfDebugInfo+0x340b>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  222ec0:	c1 e1 08             	shl    ecx,0x8
  222ec3:	09 c1                	or     ecx,eax
  222ec5:	0f b6 54 24 22       	movzx  edx,BYTE PTR [rsp+0x22]
  222eca:	c1 e2 10             	shl    edx,0x10
  222ecd:	09 ca                	or     edx,ecx
  222ecf:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  222ed4:	c1 e0 18             	shl    eax,0x18
  222ed7:	09 d0                	or     eax,edx
  222ed9:	eb 19                	jmp    222ef4 <openSelfDebugInfo+0x3424>
                result = (result << 8) | b;
  222edb:	c1 e0 08             	shl    eax,0x8
  222ede:	09 c8                	or     eax,ecx
  222ee0:	c1 e0 08             	shl    eax,0x8
  222ee3:	0f b6 4c 24 22       	movzx  ecx,BYTE PTR [rsp+0x22]
  222ee8:	09 c1                	or     ecx,eax
  222eea:	c1 e1 08             	shl    ecx,0x8
  222eed:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  222ef2:	09 c8                	or     eax,ecx
            elf.entry_addr = u64(try in.readInt(elf.endian, u32));
  222ef4:	89 c0                	mov    eax,eax
  222ef6:	48 89 45 18          	mov    QWORD PTR [rbp+0x18],rax
            elf.program_header_offset = u64(try in.readInt(elf.endian, u32));
  222efa:	8a 45 12             	mov    al,BYTE PTR [rbp+0x12]
            try self.readNoEof(bytes[0..]);
  222efd:	88 44 24 40          	mov    BYTE PTR [rsp+0x40],al
  222f01:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  222f06:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  222f0d:	00 
  222f0e:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x4
  222f15:	00 04 00 00 00 
  222f1a:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  222f21:	00 
  222f22:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  222f29:	00 
            return self.readFn(self, buffer);
  222f2a:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  222f2f:	ff 54 24 58          	call   QWORD PTR [rsp+0x58]
  222f33:	44 0f b7 ac 24 f0 00 	movzx  r13d,WORD PTR [rsp+0xf0]
  222f3a:	00 00 
            const amt_read = try self.read(buf);
  222f3c:	66 45 85 ed          	test   r13w,r13w
  222f40:	0f 85 d6 cd ff ff    	jne    21fd1c <openSelfDebugInfo+0x24c>
  222f46:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  222f4d:	00 
  222f4e:	66 41 bd 25 00       	mov    r13w,0x25
            if (amt_read < buf.len) return error.EndOfStream;
  222f53:	48 3b 84 24 a0 00 00 	cmp    rax,QWORD PTR [rsp+0xa0]
  222f5a:	00 
  222f5b:	0f 82 bb cd ff ff    	jb     21fd1c <openSelfDebugInfo+0x24c>
  222f61:	0f b6 44 24 20       	movzx  eax,BYTE PTR [rsp+0x20]
  222f66:	0f b6 4c 24 21       	movzx  ecx,BYTE PTR [rsp+0x21]
    switch (endian) {
  222f6b:	f6 44 24 40 01       	test   BYTE PTR [rsp+0x40],0x1
  222f70:	74 1b                	je     222f8d <openSelfDebugInfo+0x34bd>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  222f72:	c1 e1 08             	shl    ecx,0x8
  222f75:	09 c1                	or     ecx,eax
  222f77:	0f b6 54 24 22       	movzx  edx,BYTE PTR [rsp+0x22]
  222f7c:	c1 e2 10             	shl    edx,0x10
  222f7f:	09 ca                	or     edx,ecx
  222f81:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  222f86:	c1 e0 18             	shl    eax,0x18
  222f89:	09 d0                	or     eax,edx
  222f8b:	eb 19                	jmp    222fa6 <openSelfDebugInfo+0x34d6>
                result = (result << 8) | b;
  222f8d:	c1 e0 08             	shl    eax,0x8
  222f90:	09 c8                	or     eax,ecx
  222f92:	c1 e0 08             	shl    eax,0x8
  222f95:	0f b6 4c 24 22       	movzx  ecx,BYTE PTR [rsp+0x22]
  222f9a:	09 c1                	or     ecx,eax
  222f9c:	c1 e1 08             	shl    ecx,0x8
  222f9f:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  222fa4:	09 c8                	or     eax,ecx
  222fa6:	89 c0                	mov    eax,eax
  222fa8:	48 89 45 20          	mov    QWORD PTR [rbp+0x20],rax
            elf.section_header_offset = u64(try in.readInt(elf.endian, u32));
  222fac:	8a 45 12             	mov    al,BYTE PTR [rbp+0x12]
            try self.readNoEof(bytes[0..]);
  222faf:	88 44 24 40          	mov    BYTE PTR [rsp+0x40],al
  222fb3:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  222fb8:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  222fbf:	00 
  222fc0:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x4
  222fc7:	00 04 00 00 00 
  222fcc:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  222fd3:	00 
  222fd4:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  222fdb:	00 
            return self.readFn(self, buffer);
  222fdc:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  222fe1:	ff 54 24 58          	call   QWORD PTR [rsp+0x58]
  222fe5:	44 0f b7 ac 24 f0 00 	movzx  r13d,WORD PTR [rsp+0xf0]
  222fec:	00 00 
            const amt_read = try self.read(buf);
  222fee:	66 45 85 ed          	test   r13w,r13w
  222ff2:	0f 85 24 cd ff ff    	jne    21fd1c <openSelfDebugInfo+0x24c>
  222ff8:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  222fff:	00 
  223000:	66 41 bd 25 00       	mov    r13w,0x25
            if (amt_read < buf.len) return error.EndOfStream;
  223005:	48 3b 84 24 a0 00 00 	cmp    rax,QWORD PTR [rsp+0xa0]
  22300c:	00 
  22300d:	0f 82 09 cd ff ff    	jb     21fd1c <openSelfDebugInfo+0x24c>
  223013:	0f b6 44 24 20       	movzx  eax,BYTE PTR [rsp+0x20]
  223018:	0f b6 4c 24 21       	movzx  ecx,BYTE PTR [rsp+0x21]
    switch (endian) {
  22301d:	f6 44 24 40 01       	test   BYTE PTR [rsp+0x40],0x1
  223022:	74 1b                	je     22303f <openSelfDebugInfo+0x356f>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  223024:	c1 e1 08             	shl    ecx,0x8
  223027:	09 c1                	or     ecx,eax
  223029:	0f b6 54 24 22       	movzx  edx,BYTE PTR [rsp+0x22]
  22302e:	c1 e2 10             	shl    edx,0x10
  223031:	09 ca                	or     edx,ecx
  223033:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  223038:	c1 e0 18             	shl    eax,0x18
  22303b:	09 d0                	or     eax,edx
  22303d:	eb 19                	jmp    223058 <openSelfDebugInfo+0x3588>
                result = (result << 8) | b;
  22303f:	c1 e0 08             	shl    eax,0x8
  223042:	09 c8                	or     eax,ecx
  223044:	c1 e0 08             	shl    eax,0x8
  223047:	0f b6 4c 24 22       	movzx  ecx,BYTE PTR [rsp+0x22]
  22304c:	09 c1                	or     ecx,eax
  22304e:	c1 e1 08             	shl    ecx,0x8
  223051:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  223056:	09 c8                	or     eax,ecx
  223058:	89 c0                	mov    eax,eax
  22305a:	e9 a9 d2 ff ff       	jmp    220308 <openSelfDebugInfo+0x838>
        const ph_entry_size = try in.readInt(elf.endian, u16);
  22305f:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  223064:	8a 00                	mov    al,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  223066:	88 44 24 40          	mov    BYTE PTR [rsp+0x40],al
  22306a:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  22306f:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  223076:	00 
  223077:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x2
  22307e:	00 02 00 00 00 
  223083:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  22308a:	00 
  22308b:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  223092:	00 
            return self.readFn(self, buffer);
  223093:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  223098:	ff 54 24 58          	call   QWORD PTR [rsp+0x58]
  22309c:	44 0f b7 ac 24 f0 00 	movzx  r13d,WORD PTR [rsp+0xf0]
  2230a3:	00 00 
            const amt_read = try self.read(buf);
  2230a5:	66 45 85 ed          	test   r13w,r13w
  2230a9:	0f 85 6d cc ff ff    	jne    21fd1c <openSelfDebugInfo+0x24c>
  2230af:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  2230b6:	00 
  2230b7:	66 41 bd 25 00       	mov    r13w,0x25
            if (amt_read < buf.len) return error.EndOfStream;
  2230bc:	48 3b 84 24 a0 00 00 	cmp    rax,QWORD PTR [rsp+0xa0]
  2230c3:	00 
  2230c4:	0f 82 52 cc ff ff    	jb     21fd1c <openSelfDebugInfo+0x24c>
  2230ca:	0f b6 54 24 20       	movzx  edx,BYTE PTR [rsp+0x20]
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  2230cf:	0f b6 44 24 21       	movzx  eax,BYTE PTR [rsp+0x21]
  2230d4:	89 c1                	mov    ecx,eax
  2230d6:	c1 e1 08             	shl    ecx,0x8
  2230d9:	09 d1                	or     ecx,edx
                result = (result << 8) | b;
  2230db:	c1 e2 08             	shl    edx,0x8
  2230de:	09 c2                	or     edx,eax
    switch (endian) {
  2230e0:	f6 44 24 40 01       	test   BYTE PTR [rsp+0x40],0x1
  2230e5:	66 0f 45 d1          	cmovne dx,cx
  2230e9:	89 54 24 78          	mov    DWORD PTR [rsp+0x78],edx
        const ph_entry_count = try in.readInt(elf.endian, u16);
  2230ed:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  2230f2:	8a 00                	mov    al,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  2230f4:	88 44 24 40          	mov    BYTE PTR [rsp+0x40],al
  2230f8:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  2230fd:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  223104:	00 
  223105:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x2
  22310c:	00 02 00 00 00 
  223111:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  223118:	00 
  223119:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  223120:	00 
            return self.readFn(self, buffer);
  223121:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  223126:	ff 54 24 58          	call   QWORD PTR [rsp+0x58]
  22312a:	44 0f b7 ac 24 f0 00 	movzx  r13d,WORD PTR [rsp+0xf0]
  223131:	00 00 
            const amt_read = try self.read(buf);
  223133:	66 45 85 ed          	test   r13w,r13w
  223137:	0f 85 df cb ff ff    	jne    21fd1c <openSelfDebugInfo+0x24c>
  22313d:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  223144:	00 
  223145:	66 41 bd 25 00       	mov    r13w,0x25
            if (amt_read < buf.len) return error.EndOfStream;
  22314a:	48 3b 84 24 a0 00 00 	cmp    rax,QWORD PTR [rsp+0xa0]
  223151:	00 
  223152:	0f 82 c4 cb ff ff    	jb     21fd1c <openSelfDebugInfo+0x24c>
  223158:	0f b6 54 24 20       	movzx  edx,BYTE PTR [rsp+0x20]
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  22315d:	0f b6 44 24 21       	movzx  eax,BYTE PTR [rsp+0x21]
  223162:	89 c1                	mov    ecx,eax
  223164:	c1 e1 08             	shl    ecx,0x8
  223167:	09 d1                	or     ecx,edx
                result = (result << 8) | b;
  223169:	c1 e2 08             	shl    edx,0x8
  22316c:	09 c2                	or     edx,eax
    switch (endian) {
  22316e:	f6 44 24 40 01       	test   BYTE PTR [rsp+0x40],0x1
  223173:	66 0f 45 d1          	cmovne dx,cx
  223177:	89 94 24 90 00 00 00 	mov    DWORD PTR [rsp+0x90],edx
        const sh_entry_size = try in.readInt(elf.endian, u16);
  22317e:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  223183:	8a 00                	mov    al,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  223185:	88 44 24 40          	mov    BYTE PTR [rsp+0x40],al
  223189:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  22318e:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  223195:	00 
  223196:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x2
  22319d:	00 02 00 00 00 
  2231a2:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  2231a9:	00 
  2231aa:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  2231b1:	00 
            return self.readFn(self, buffer);
  2231b2:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  2231b7:	ff 54 24 58          	call   QWORD PTR [rsp+0x58]
  2231bb:	44 0f b7 ac 24 f0 00 	movzx  r13d,WORD PTR [rsp+0xf0]
  2231c2:	00 00 
            const amt_read = try self.read(buf);
  2231c4:	66 45 85 ed          	test   r13w,r13w
  2231c8:	0f 85 4e cb ff ff    	jne    21fd1c <openSelfDebugInfo+0x24c>
  2231ce:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  2231d5:	00 
  2231d6:	66 41 bd 25 00       	mov    r13w,0x25
            if (amt_read < buf.len) return error.EndOfStream;
  2231db:	48 3b 84 24 a0 00 00 	cmp    rax,QWORD PTR [rsp+0xa0]
  2231e2:	00 
  2231e3:	0f 82 33 cb ff ff    	jb     21fd1c <openSelfDebugInfo+0x24c>
  2231e9:	0f b6 54 24 20       	movzx  edx,BYTE PTR [rsp+0x20]
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  2231ee:	0f b6 44 24 21       	movzx  eax,BYTE PTR [rsp+0x21]
  2231f3:	89 c1                	mov    ecx,eax
  2231f5:	c1 e1 08             	shl    ecx,0x8
  2231f8:	09 d1                	or     ecx,edx
                result = (result << 8) | b;
  2231fa:	c1 e2 08             	shl    edx,0x8
  2231fd:	09 c2                	or     edx,eax
    switch (endian) {
  2231ff:	f6 44 24 40 01       	test   BYTE PTR [rsp+0x40],0x1
  223204:	66 0f 45 d1          	cmovne dx,cx
  223208:	89 54 24 48          	mov    DWORD PTR [rsp+0x48],edx
        const sh_entry_count = try in.readInt(elf.endian, u16);
  22320c:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  223211:	8a 00                	mov    al,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  223213:	88 44 24 40          	mov    BYTE PTR [rsp+0x40],al
  223217:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  22321c:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  223223:	00 
  223224:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x2
  22322b:	00 02 00 00 00 
  223230:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  223237:	00 
  223238:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  22323f:	00 
            return self.readFn(self, buffer);
  223240:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  223245:	ff 54 24 58          	call   QWORD PTR [rsp+0x58]
  223249:	44 0f b7 ac 24 f0 00 	movzx  r13d,WORD PTR [rsp+0xf0]
  223250:	00 00 
            const amt_read = try self.read(buf);
  223252:	66 45 85 ed          	test   r13w,r13w
  223256:	0f 85 c0 ca ff ff    	jne    21fd1c <openSelfDebugInfo+0x24c>
  22325c:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  223263:	00 
  223264:	66 41 bd 25 00       	mov    r13w,0x25
            if (amt_read < buf.len) return error.EndOfStream;
  223269:	48 3b 84 24 a0 00 00 	cmp    rax,QWORD PTR [rsp+0xa0]
  223270:	00 
  223271:	0f 82 a5 ca ff ff    	jb     21fd1c <openSelfDebugInfo+0x24c>
  223277:	0f b6 54 24 20       	movzx  edx,BYTE PTR [rsp+0x20]
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  22327c:	0f b6 44 24 21       	movzx  eax,BYTE PTR [rsp+0x21]
  223281:	89 c1                	mov    ecx,eax
  223283:	c1 e1 08             	shl    ecx,0x8
  223286:	09 d1                	or     ecx,edx
                result = (result << 8) | b;
  223288:	c1 e2 08             	shl    edx,0x8
  22328b:	09 c2                	or     edx,eax
    switch (endian) {
  22328d:	f6 44 24 40 01       	test   BYTE PTR [rsp+0x40],0x1
  223292:	66 0f 45 d1          	cmovne dx,cx
  223296:	89 54 24 40          	mov    DWORD PTR [rsp+0x40],edx
        elf.string_section_index = u64(try in.readInt(elf.endian, u16));
  22329a:	8a 45 12             	mov    al,BYTE PTR [rbp+0x12]
            try self.readNoEof(bytes[0..]);
  22329d:	88 84 24 80 00 00 00 	mov    BYTE PTR [rsp+0x80],al
  2232a4:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  2232a9:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  2232b0:	00 
  2232b1:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x2
  2232b8:	00 02 00 00 00 
  2232bd:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  2232c4:	00 
  2232c5:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  2232cc:	00 
  2232cd:	48 89 bc 24 88 00 00 	mov    QWORD PTR [rsp+0x88],rdi
  2232d4:	00 
            return self.readFn(self, buffer);
  2232d5:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  2232da:	ff 54 24 58          	call   QWORD PTR [rsp+0x58]
  2232de:	44 0f b7 ac 24 f0 00 	movzx  r13d,WORD PTR [rsp+0xf0]
  2232e5:	00 00 
            const amt_read = try self.read(buf);
  2232e7:	66 45 85 ed          	test   r13w,r13w
  2232eb:	0f 85 2b ca ff ff    	jne    21fd1c <openSelfDebugInfo+0x24c>
  2232f1:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  2232f8:	00 
  2232f9:	66 41 bd 25 00       	mov    r13w,0x25
            if (amt_read < buf.len) return error.EndOfStream;
  2232fe:	48 3b 84 24 a0 00 00 	cmp    rax,QWORD PTR [rsp+0xa0]
  223305:	00 
  223306:	0f 82 10 ca ff ff    	jb     21fd1c <openSelfDebugInfo+0x24c>
  22330c:	0f b6 44 24 20       	movzx  eax,BYTE PTR [rsp+0x20]
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  223311:	0f b6 4c 24 21       	movzx  ecx,BYTE PTR [rsp+0x21]
  223316:	89 ca                	mov    edx,ecx
  223318:	c1 e2 08             	shl    edx,0x8
  22331b:	09 c2                	or     edx,eax
                result = (result << 8) | b;
  22331d:	c1 e0 08             	shl    eax,0x8
  223320:	09 c8                	or     eax,ecx
    switch (endian) {
  223322:	f6 84 24 80 00 00 00 	test   BYTE PTR [rsp+0x80],0x1
  223329:	01 
  22332a:	66 0f 45 c2          	cmovne ax,dx
  22332e:	0f b7 c0             	movzx  eax,ax
  223331:	48 89 45 30          	mov    QWORD PTR [rbp+0x30],rax
        if (elf.string_section_index >= sh_entry_count) return error.InvalidFormat;
  223335:	66 3b 44 24 40       	cmp    ax,WORD PTR [rsp+0x40]
  22333a:	0f 83 c3 d0 ff ff    	jae    220403 <openSelfDebugInfo+0x933>
  223340:	0f b7 4c 24 40       	movzx  ecx,WORD PTR [rsp+0x40]
        const sh_byte_count = u64(sh_entry_size) * u64(sh_entry_count);
  223345:	0f b7 44 24 48       	movzx  eax,WORD PTR [rsp+0x48]
  22334a:	48 89 44 24 48       	mov    QWORD PTR [rsp+0x48],rax
  22334f:	48 89 4c 24 40       	mov    QWORD PTR [rsp+0x40],rcx
  223354:	48 0f af c1          	imul   rax,rcx
    return if (@addWithOverflow(T, a, b, &answer)) error.Overflow else answer;
  223358:	48 03 45 28          	add    rax,QWORD PTR [rbp+0x28]
  22335c:	73 27                	jae    223385 <openSelfDebugInfo+0x38b5>
  22335e:	48 8d 05 1b 5c fe ff 	lea    rax,[rip+0xfffffffffffe5c1b]        # 208f80 <__unnamed_43>
  223365:	48 89 84 24 88 00 00 	mov    QWORD PTR [rsp+0x88],rax
  22336c:	00 
  22336d:	48 8b 84 24 88 00 00 	mov    rax,QWORD PTR [rsp+0x88]
  223374:	00 
  223375:	44 0f b7 28          	movzx  r13d,WORD PTR [rax]
        const end_sh = try math.add(u64, elf.section_header_offset, sh_byte_count);
  223379:	66 45 85 ed          	test   r13w,r13w
  22337d:	0f 85 99 c9 ff ff    	jne    21fd1c <openSelfDebugInfo+0x24c>
  223383:	eb 28                	jmp    2233ad <openSelfDebugInfo+0x38dd>
  223385:	66 c7 84 24 f0 00 00 	mov    WORD PTR [rsp+0xf0],0x0
  22338c:	00 00 00 
  22338f:	48 89 84 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],rax
  223396:	00 
  223397:	48 8b 84 24 88 00 00 	mov    rax,QWORD PTR [rsp+0x88]
  22339e:	00 
  22339f:	44 0f b7 28          	movzx  r13d,WORD PTR [rax]
  2233a3:	66 45 85 ed          	test   r13w,r13w
  2233a7:	0f 85 6f c9 ff ff    	jne    21fd1c <openSelfDebugInfo+0x24c>
  2233ad:	48 8b 84 24 88 00 00 	mov    rax,QWORD PTR [rsp+0x88]
  2233b4:	00 
  2233b5:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
        const ph_byte_count = u64(ph_entry_size) * u64(ph_entry_count);
  2233b9:	0f b7 44 24 78       	movzx  eax,WORD PTR [rsp+0x78]
  2233be:	0f b7 8c 24 90 00 00 	movzx  ecx,WORD PTR [rsp+0x90]
  2233c5:	00 
  2233c6:	48 0f af c8          	imul   rcx,rax
  2233ca:	48 03 4d 20          	add    rcx,QWORD PTR [rbp+0x20]
  2233ce:	73 17                	jae    2233e7 <openSelfDebugInfo+0x3917>
  2233d0:	48 8d 05 a9 5b fe ff 	lea    rax,[rip+0xfffffffffffe5ba9]        # 208f80 <__unnamed_43>
  2233d7:	44 0f b7 28          	movzx  r13d,WORD PTR [rax]
        const end_ph = try math.add(u64, elf.program_header_offset, ph_byte_count);
  2233db:	66 45 85 ed          	test   r13w,r13w
  2233df:	0f 85 37 c9 ff ff    	jne    21fd1c <openSelfDebugInfo+0x24c>
  2233e5:	eb 28                	jmp    22340f <openSelfDebugInfo+0x393f>
  2233e7:	48 8d 84 24 f0 00 00 	lea    rax,[rsp+0xf0]
  2233ee:	00 
  2233ef:	66 c7 84 24 f0 00 00 	mov    WORD PTR [rsp+0xf0],0x0
  2233f6:	00 00 00 
  2233f9:	48 89 8c 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],rcx
  223400:	00 
  223401:	44 0f b7 28          	movzx  r13d,WORD PTR [rax]
  223405:	66 45 85 ed          	test   r13w,r13w
  223409:	0f 85 0d c9 ff ff    	jne    21fd1c <openSelfDebugInfo+0x24c>
  22340f:	4c 8b 40 08          	mov    r8,QWORD PTR [rax+0x8]
        const stream_end = try elf.in_file.getEndPos();
  223413:	49 8b 07             	mov    rax,QWORD PTR [r15]
pub fn accept4(fd: i32, noalias addr: *sockaddr, noalias len: *socklen_t, flags: u32) usize {
    return syscall4(SYS_accept4, @intCast(usize, fd), @ptrToInt(addr), @ptrToInt(len), flags);
}

pub fn fstat(fd: i32, stat_buf: *Stat) usize {
    return syscall2(SYS_fstat, @intCast(usize, fd), @ptrToInt(stat_buf));
  223416:	48 63 38             	movsxd rdi,DWORD PTR [rax]
        }
    }
}

pub fn posixFStat(fd: i32) !posix.Stat {
    var stat: posix.Stat = undefined;
  223419:	c5 fc 10 05 67 43 fe 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffe4367]        # 207788 <__unnamed_65+0x70>
  223420:	ff 
  223421:	c5 fc 11 84 24 60 01 	vmovups YMMWORD PTR [rsp+0x160],ymm0
  223428:	00 00 
  22342a:	c5 fc 10 05 46 43 fe 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffe4346]        # 207778 <__unnamed_65+0x60>
  223431:	ff 
  223432:	c5 fc 11 84 24 50 01 	vmovups YMMWORD PTR [rsp+0x150],ymm0
  223439:	00 00 
  22343b:	c5 fc 10 05 15 43 fe 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffe4315]        # 207758 <__unnamed_65+0x40>
  223442:	ff 
  223443:	c5 fc 11 84 24 30 01 	vmovups YMMWORD PTR [rsp+0x130],ymm0
  22344a:	00 00 
  22344c:	c5 fc 10 05 e4 42 fe 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffe42e4]        # 207738 <__unnamed_65+0x20>
  223453:	ff 
  223454:	c5 fc 11 84 24 10 01 	vmovups YMMWORD PTR [rsp+0x110],ymm0
  22345b:	00 00 
  22345d:	c5 fe 6f 05 b3 42 fe 	vmovdqu ymm0,YMMWORD PTR [rip+0xfffffffffffe42b3]        # 207718 <__unnamed_65>
  223464:	ff 
  223465:	c5 fe 7f 84 24 f0 00 	vmovdqu YMMWORD PTR [rsp+0xf0],ymm0
  22346c:	00 00 
  22346e:	48 8d b4 24 f0 00 00 	lea    rsi,[rsp+0xf0]
  223475:	00 
    return asm volatile ("syscall"
  223476:	b8 05 00 00 00       	mov    eax,0x5
  22347b:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  22347d:	48 89 c6             	mov    rsi,rax
  223480:	48 f7 de             	neg    rsi
  223483:	31 c9                	xor    ecx,ecx
  223485:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  22348b:	48 0f 47 ce          	cmova  rcx,rsi
    const err = posix.getErrno(posix.fstat(fd, &stat));
    if (err > 0) {
  22348f:	48 85 c9             	test   rcx,rcx
  223492:	74 23                	je     2234b7 <openSelfDebugInfo+0x39e7>
  223494:	66 41 bd 0c 00       	mov    r13w,0xc
  223499:	48 83 f9 0c          	cmp    rcx,0xc
  22349d:	0f 84 79 c8 ff ff    	je     21fd1c <openSelfDebugInfo+0x24c>
  2234a3:	66 41 bd 03 00       	mov    r13w,0x3
            try st.elf.openFile(allocator, &st.self_exe_file);
  2234a8:	66 45 85 ed          	test   r13w,r13w
  2234ac:	0f 85 74 c8 ff ff    	jne    21fd26 <openSelfDebugInfo+0x256>
  2234b2:	e9 5b cf ff ff       	jmp    220412 <openSelfDebugInfo+0x942>
            posix.ENOMEM => error.SystemResources,
            else => os.unexpectedErrorPosix(err),
        };
    }

    return stat;
  2234b7:	48 8b 84 24 20 01 00 	mov    rax,QWORD PTR [rsp+0x120]
  2234be:	00 
  2234bf:	48 89 84 24 c8 01 00 	mov    QWORD PTR [rsp+0x1c8],rax
  2234c6:	00 
  2234c7:	66 41 bd 26 00       	mov    r13w,0x26
        if (stream_end < end_sh or stream_end < end_ph) {
  2234cc:	48 39 d0             	cmp    rax,rdx
  2234cf:	0f 82 47 c8 ff ff    	jb     21fd1c <openSelfDebugInfo+0x24c>
  2234d5:	4c 39 84 24 c8 01 00 	cmp    QWORD PTR [rsp+0x1c8],r8
  2234dc:	00 
  2234dd:	0f 82 39 c8 ff ff    	jb     21fd1c <openSelfDebugInfo+0x24c>
        try elf.in_file.seekTo(elf.section_header_offset);
  2234e3:	48 8b 75 28          	mov    rsi,QWORD PTR [rbp+0x28]
    if (@maxValue(@typeOf(x)) > @maxValue(T) and x > @maxValue(T)) {
  2234e7:	48 85 f6             	test   rsi,rsi
  2234ea:	0f 88 53 06 00 00    	js     223b43 <openSelfDebugInfo+0x4073>
  2234f0:	49 8b 07             	mov    rax,QWORD PTR [r15]
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  2234f3:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  2234f6:	45 31 c0             	xor    r8d,r8d
    return asm volatile ("syscall"
  2234f9:	b8 08 00 00 00       	mov    eax,0x8
  2234fe:	31 d2                	xor    edx,edx
  223500:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  223502:	48 89 c1             	mov    rcx,rax
  223505:	48 f7 d9             	neg    rcx
  223508:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  22350e:	49 0f 46 c8          	cmovbe rcx,r8
  223512:	48 83 f9 1d          	cmp    rcx,0x1d
  223516:	0f 87 04 06 00 00    	ja     223b20 <openSelfDebugInfo+0x4050>
  22351c:	48 8d 05 4d d2 fd ff 	lea    rax,[rip+0xfffffffffffdd24d]        # 200770 <__unnamed_609+0x430>
  223523:	48 63 0c 88          	movsxd rcx,DWORD PTR [rax+rcx*4]
  223527:	48 01 c1             	add    rcx,rax
  22352a:	66 41 bd 03 00       	mov    r13w,0x3
  22352f:	ff e1                	jmp    rcx
        elf.section_headers = try elf.allocator.alloc(SectionHeader, sh_entry_count);
  223531:	48 8b 75 50          	mov    rsi,QWORD PTR [rbp+0x50]
    return if (@mulWithOverflow(T, a, b, &answer)) error.Overflow else answer;
  223535:	48 8b 54 24 40       	mov    rdx,QWORD PTR [rsp+0x40]
  22353a:	48 c1 e2 06          	shl    rdx,0x6
  22353e:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  223545:	00 
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  223546:	b9 04 00 00 00       	mov    ecx,0x4
  22354b:	48 89 94 24 80 01 00 	mov    QWORD PTR [rsp+0x180],rdx
  223552:	00 
  223553:	c5 f8 77             	vzeroupper 
  223556:	ff 16                	call   QWORD PTR [rsi]
  223558:	44 0f b7 ac 24 f0 00 	movzx  r13d,WORD PTR [rsp+0xf0]
  22355f:	00 00 
  223561:	66 45 85 ed          	test   r13w,r13w
  223565:	0f 85 b1 c7 ff ff    	jne    21fd1c <openSelfDebugInfo+0x24c>
        assert(byte_slice.len == byte_count);
  22356b:	48 8b 84 24 80 01 00 	mov    rax,QWORD PTR [rsp+0x180]
  223572:	00 
  223573:	48 39 84 24 00 01 00 	cmp    QWORD PTR [rsp+0x100],rax
  22357a:	00 
    if (!ok) {
  22357b:	0f 85 b3 05 00 00    	jne    223b34 <openSelfDebugInfo+0x4064>
  223581:	48 8d 45 50          	lea    rax,[rbp+0x50]
  223585:	48 89 44 24 78       	mov    QWORD PTR [rsp+0x78],rax
  22358a:	48 8d 45 40          	lea    rax,[rbp+0x40]
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  22358e:	48 89 84 24 90 00 00 	mov    QWORD PTR [rsp+0x90],rax
  223595:	00 
  223596:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  22359d:	00 
  22359e:	48 89 84 24 80 00 00 	mov    QWORD PTR [rsp+0x80],rax
  2235a5:	00 
  2235a6:	48 89 45 40          	mov    QWORD PTR [rbp+0x40],rax
  2235aa:	48 8d 45 48          	lea    rax,[rbp+0x48]
  2235ae:	48 89 84 24 88 00 00 	mov    QWORD PTR [rsp+0x88],rax
  2235b5:	00 
  2235b6:	48 8b 44 24 40       	mov    rax,QWORD PTR [rsp+0x40]
  2235bb:	48 89 45 48          	mov    QWORD PTR [rbp+0x48],rax
        if (elf.is_64) {
  2235bf:	80 7d 11 01          	cmp    BYTE PTR [rbp+0x11],0x1
  2235c3:	0f 85 8e 05 00 00    	jne    223b57 <openSelfDebugInfo+0x4087>
            if (sh_entry_size != 64) return error.InvalidFormat;
  2235c9:	83 7c 24 48 40       	cmp    DWORD PTR [rsp+0x48],0x40
  2235ce:	0f 85 e4 0f 00 00    	jne    2245b8 <openSelfDebugInfo+0x4ae8>
                elf_section.name = try in.readInt(elf.endian, u32);
  2235d4:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  2235d9:	8a 00                	mov    al,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  2235db:	88 44 24 70          	mov    BYTE PTR [rsp+0x70],al
  2235df:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  2235e4:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  2235eb:	00 
  2235ec:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x4
  2235f3:	00 04 00 00 00 
  2235f8:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  2235ff:	00 
  223600:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  223607:	00 
            return self.readFn(self, buffer);
  223608:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  22360d:	ff 54 24 58          	call   QWORD PTR [rsp+0x58]
  223611:	44 0f b7 ac 24 f0 00 	movzx  r13d,WORD PTR [rsp+0xf0]
  223618:	00 00 
            const amt_read = try self.read(buf);
  22361a:	66 45 85 ed          	test   r13w,r13w
  22361e:	0f 85 d4 0f 00 00    	jne    2245f8 <openSelfDebugInfo+0x4b28>
  223624:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  22362b:	00 
  22362c:	31 c9                	xor    ecx,ecx
  22362e:	48 89 8c 24 80 01 00 	mov    QWORD PTR [rsp+0x180],rcx
  223635:	00 
  223636:	b9 38 00 00 00       	mov    ecx,0x38
  22363b:	48 89 4c 24 48       	mov    QWORD PTR [rsp+0x48],rcx
            if (amt_read < buf.len) return error.EndOfStream;
  223640:	48 3b 84 24 a0 00 00 	cmp    rax,QWORD PTR [rsp+0xa0]
  223647:	00 
  223648:	0f 82 a5 0f 00 00    	jb     2245f3 <openSelfDebugInfo+0x4b23>
  22364e:	0f b6 44 24 20       	movzx  eax,BYTE PTR [rsp+0x20]
  223653:	0f b6 4c 24 21       	movzx  ecx,BYTE PTR [rsp+0x21]
    switch (endian) {
  223658:	f6 44 24 70 01       	test   BYTE PTR [rsp+0x70],0x1
  22365d:	74 1b                	je     22367a <openSelfDebugInfo+0x3baa>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  22365f:	c1 e1 08             	shl    ecx,0x8
  223662:	09 c1                	or     ecx,eax
  223664:	0f b6 54 24 22       	movzx  edx,BYTE PTR [rsp+0x22]
  223669:	c1 e2 10             	shl    edx,0x10
  22366c:	09 ca                	or     edx,ecx
  22366e:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  223673:	c1 e0 18             	shl    eax,0x18
  223676:	09 d0                	or     eax,edx
  223678:	eb 19                	jmp    223693 <openSelfDebugInfo+0x3bc3>
                result = (result << 8) | b;
  22367a:	c1 e0 08             	shl    eax,0x8
  22367d:	09 c8                	or     eax,ecx
  22367f:	c1 e0 08             	shl    eax,0x8
  223682:	0f b6 4c 24 22       	movzx  ecx,BYTE PTR [rsp+0x22]
  223687:	09 c1                	or     ecx,eax
  223689:	c1 e1 08             	shl    ecx,0x8
  22368c:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  223691:	09 c8                	or     eax,ecx
  223693:	48 8b 8c 24 80 00 00 	mov    rcx,QWORD PTR [rsp+0x80]
  22369a:	00 
  22369b:	48 8b 54 24 48       	mov    rdx,QWORD PTR [rsp+0x48]
  2236a0:	89 44 11 c8          	mov    DWORD PTR [rcx+rdx*1-0x38],eax
                elf_section.sh_type = try in.readInt(elf.endian, u32);
  2236a4:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  2236a9:	0f b6 00             	movzx  eax,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  2236ac:	88 44 24 70          	mov    BYTE PTR [rsp+0x70],al
  2236b0:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  2236b5:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  2236bc:	00 
  2236bd:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x4
  2236c4:	00 04 00 00 00 
            return self.readFn(self, buffer);
  2236c9:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  2236d0:	00 
  2236d1:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  2236d6:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  2236dd:	00 
  2236de:	ff 54 24 58          	call   QWORD PTR [rsp+0x58]
  2236e2:	44 0f b7 ac 24 f0 00 	movzx  r13d,WORD PTR [rsp+0xf0]
  2236e9:	00 00 
            const amt_read = try self.read(buf);
  2236eb:	66 45 85 ed          	test   r13w,r13w
  2236ef:	0f 85 03 0f 00 00    	jne    2245f8 <openSelfDebugInfo+0x4b28>
  2236f5:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  2236fc:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  2236fd:	48 3b 84 24 a0 00 00 	cmp    rax,QWORD PTR [rsp+0xa0]
  223704:	00 
  223705:	0f 82 e8 0e 00 00    	jb     2245f3 <openSelfDebugInfo+0x4b23>
  22370b:	0f b6 44 24 20       	movzx  eax,BYTE PTR [rsp+0x20]
  223710:	0f b6 4c 24 21       	movzx  ecx,BYTE PTR [rsp+0x21]
    switch (endian) {
  223715:	f6 44 24 70 01       	test   BYTE PTR [rsp+0x70],0x1
  22371a:	74 1b                	je     223737 <openSelfDebugInfo+0x3c67>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  22371c:	c1 e1 08             	shl    ecx,0x8
  22371f:	09 c1                	or     ecx,eax
  223721:	0f b6 54 24 22       	movzx  edx,BYTE PTR [rsp+0x22]
  223726:	c1 e2 10             	shl    edx,0x10
  223729:	09 ca                	or     edx,ecx
  22372b:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  223730:	c1 e0 18             	shl    eax,0x18
  223733:	09 d0                	or     eax,edx
  223735:	eb 19                	jmp    223750 <openSelfDebugInfo+0x3c80>
                result = (result << 8) | b;
  223737:	c1 e0 08             	shl    eax,0x8
  22373a:	09 c8                	or     eax,ecx
  22373c:	c1 e0 08             	shl    eax,0x8
  22373f:	0f b6 4c 24 22       	movzx  ecx,BYTE PTR [rsp+0x22]
  223744:	09 c1                	or     ecx,eax
  223746:	c1 e1 08             	shl    ecx,0x8
  223749:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  22374e:	09 c8                	or     eax,ecx
  223750:	48 8b 8c 24 80 00 00 	mov    rcx,QWORD PTR [rsp+0x80]
  223757:	00 
  223758:	48 8b 54 24 48       	mov    rdx,QWORD PTR [rsp+0x48]
  22375d:	89 44 11 cc          	mov    DWORD PTR [rcx+rdx*1-0x34],eax
                elf_section.flags = try in.readInt(elf.endian, u64);
  223761:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  223766:	0f b6 10             	movzx  edx,BYTE PTR [rax]
  223769:	48 8d bc 24 78 03 00 	lea    rdi,[rsp+0x378]
  223770:	00 
  223771:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  223776:	e8 f5 12 00 00       	call   224a70 <InStream(ReadError)_readInt.147>
  22377b:	44 0f b7 ac 24 78 03 	movzx  r13d,WORD PTR [rsp+0x378]
  223782:	00 00 
  223784:	66 45 85 ed          	test   r13w,r13w
  223788:	0f 85 f6 0b 00 00    	jne    224384 <openSelfDebugInfo+0x48b4>
  22378e:	48 8b 84 24 80 03 00 	mov    rax,QWORD PTR [rsp+0x380]
  223795:	00 
  223796:	48 8b 8c 24 80 00 00 	mov    rcx,QWORD PTR [rsp+0x80]
  22379d:	00 
  22379e:	48 8b 54 24 48       	mov    rdx,QWORD PTR [rsp+0x48]
  2237a3:	48 89 44 11 d0       	mov    QWORD PTR [rcx+rdx*1-0x30],rax
                elf_section.addr = try in.readInt(elf.endian, u64);
  2237a8:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  2237ad:	0f b6 10             	movzx  edx,BYTE PTR [rax]
  2237b0:	48 8d bc 24 a0 03 00 	lea    rdi,[rsp+0x3a0]
  2237b7:	00 
  2237b8:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  2237bd:	e8 ae 12 00 00       	call   224a70 <InStream(ReadError)_readInt.147>
  2237c2:	44 0f b7 ac 24 a0 03 	movzx  r13d,WORD PTR [rsp+0x3a0]
  2237c9:	00 00 
  2237cb:	66 45 85 ed          	test   r13w,r13w
  2237cf:	0f 85 0d 0c 00 00    	jne    2243e2 <openSelfDebugInfo+0x4912>
  2237d5:	48 8b 84 24 a8 03 00 	mov    rax,QWORD PTR [rsp+0x3a8]
  2237dc:	00 
  2237dd:	48 8b 8c 24 80 00 00 	mov    rcx,QWORD PTR [rsp+0x80]
  2237e4:	00 
  2237e5:	48 8b 54 24 48       	mov    rdx,QWORD PTR [rsp+0x48]
  2237ea:	48 89 44 11 d8       	mov    QWORD PTR [rcx+rdx*1-0x28],rax
                elf_section.offset = try in.readInt(elf.endian, u64);
  2237ef:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  2237f4:	0f b6 10             	movzx  edx,BYTE PTR [rax]
  2237f7:	48 8d bc 24 50 03 00 	lea    rdi,[rsp+0x350]
  2237fe:	00 
  2237ff:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  223804:	e8 67 12 00 00       	call   224a70 <InStream(ReadError)_readInt.147>
  223809:	44 0f b7 ac 24 50 03 	movzx  r13d,WORD PTR [rsp+0x350]
  223810:	00 00 
  223812:	66 45 85 ed          	test   r13w,r13w
  223816:	0f 85 24 0c 00 00    	jne    224440 <openSelfDebugInfo+0x4970>
  22381c:	48 8b 84 24 58 03 00 	mov    rax,QWORD PTR [rsp+0x358]
  223823:	00 
  223824:	48 8b 8c 24 80 00 00 	mov    rcx,QWORD PTR [rsp+0x80]
  22382b:	00 
  22382c:	48 8b 54 24 48       	mov    rdx,QWORD PTR [rsp+0x48]
  223831:	48 89 44 11 e0       	mov    QWORD PTR [rcx+rdx*1-0x20],rax
                elf_section.size = try in.readInt(elf.endian, u64);
  223836:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  22383b:	0f b6 10             	movzx  edx,BYTE PTR [rax]
  22383e:	48 8d bc 24 d0 01 00 	lea    rdi,[rsp+0x1d0]
  223845:	00 
  223846:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  22384b:	e8 20 12 00 00       	call   224a70 <InStream(ReadError)_readInt.147>
  223850:	44 0f b7 ac 24 d0 01 	movzx  r13d,WORD PTR [rsp+0x1d0]
  223857:	00 00 
  223859:	66 45 85 ed          	test   r13w,r13w
  22385d:	0f 85 3b 0c 00 00    	jne    22449e <openSelfDebugInfo+0x49ce>
  223863:	48 8b 84 24 d8 01 00 	mov    rax,QWORD PTR [rsp+0x1d8]
  22386a:	00 
  22386b:	48 8b 8c 24 80 00 00 	mov    rcx,QWORD PTR [rsp+0x80]
  223872:	00 
  223873:	48 8b 54 24 48       	mov    rdx,QWORD PTR [rsp+0x48]
  223878:	48 89 44 11 e8       	mov    QWORD PTR [rcx+rdx*1-0x18],rax
                elf_section.link = try in.readInt(elf.endian, u32);
  22387d:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  223882:	0f b6 00             	movzx  eax,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  223885:	88 44 24 70          	mov    BYTE PTR [rsp+0x70],al
  223889:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  22388e:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  223895:	00 
  223896:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x4
  22389d:	00 04 00 00 00 
            return self.readFn(self, buffer);
  2238a2:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  2238a9:	00 
  2238aa:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  2238af:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  2238b6:	00 
  2238b7:	ff 54 24 58          	call   QWORD PTR [rsp+0x58]
  2238bb:	44 0f b7 ac 24 f0 00 	movzx  r13d,WORD PTR [rsp+0xf0]
  2238c2:	00 00 
            const amt_read = try self.read(buf);
  2238c4:	66 45 85 ed          	test   r13w,r13w
  2238c8:	0f 85 2a 0d 00 00    	jne    2245f8 <openSelfDebugInfo+0x4b28>
  2238ce:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  2238d5:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  2238d6:	48 3b 84 24 a0 00 00 	cmp    rax,QWORD PTR [rsp+0xa0]
  2238dd:	00 
  2238de:	0f 82 0f 0d 00 00    	jb     2245f3 <openSelfDebugInfo+0x4b23>
  2238e4:	0f b6 44 24 20       	movzx  eax,BYTE PTR [rsp+0x20]
  2238e9:	0f b6 4c 24 21       	movzx  ecx,BYTE PTR [rsp+0x21]
    switch (endian) {
  2238ee:	f6 44 24 70 01       	test   BYTE PTR [rsp+0x70],0x1
  2238f3:	74 1b                	je     223910 <openSelfDebugInfo+0x3e40>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  2238f5:	c1 e1 08             	shl    ecx,0x8
  2238f8:	09 c1                	or     ecx,eax
  2238fa:	0f b6 54 24 22       	movzx  edx,BYTE PTR [rsp+0x22]
  2238ff:	c1 e2 10             	shl    edx,0x10
  223902:	09 ca                	or     edx,ecx
  223904:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  223909:	c1 e0 18             	shl    eax,0x18
  22390c:	09 d0                	or     eax,edx
  22390e:	eb 19                	jmp    223929 <openSelfDebugInfo+0x3e59>
                result = (result << 8) | b;
  223910:	c1 e0 08             	shl    eax,0x8
  223913:	09 c8                	or     eax,ecx
  223915:	c1 e0 08             	shl    eax,0x8
  223918:	0f b6 4c 24 22       	movzx  ecx,BYTE PTR [rsp+0x22]
  22391d:	09 c1                	or     ecx,eax
  22391f:	c1 e1 08             	shl    ecx,0x8
  223922:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  223927:	09 c8                	or     eax,ecx
  223929:	48 8b 8c 24 80 00 00 	mov    rcx,QWORD PTR [rsp+0x80]
  223930:	00 
  223931:	48 8b 54 24 48       	mov    rdx,QWORD PTR [rsp+0x48]
  223936:	89 44 11 f0          	mov    DWORD PTR [rcx+rdx*1-0x10],eax
                elf_section.info = try in.readInt(elf.endian, u32);
  22393a:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  22393f:	0f b6 00             	movzx  eax,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  223942:	88 44 24 70          	mov    BYTE PTR [rsp+0x70],al
  223946:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  22394b:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  223952:	00 
  223953:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x4
  22395a:	00 04 00 00 00 
            return self.readFn(self, buffer);
  22395f:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  223966:	00 
  223967:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  22396c:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  223973:	00 
  223974:	ff 54 24 58          	call   QWORD PTR [rsp+0x58]
  223978:	44 0f b7 ac 24 f0 00 	movzx  r13d,WORD PTR [rsp+0xf0]
  22397f:	00 00 
            const amt_read = try self.read(buf);
  223981:	66 45 85 ed          	test   r13w,r13w
  223985:	0f 85 6d 0c 00 00    	jne    2245f8 <openSelfDebugInfo+0x4b28>
  22398b:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  223992:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  223993:	48 3b 84 24 a0 00 00 	cmp    rax,QWORD PTR [rsp+0xa0]
  22399a:	00 
  22399b:	0f 82 52 0c 00 00    	jb     2245f3 <openSelfDebugInfo+0x4b23>
  2239a1:	0f b6 44 24 20       	movzx  eax,BYTE PTR [rsp+0x20]
  2239a6:	0f b6 4c 24 21       	movzx  ecx,BYTE PTR [rsp+0x21]
    switch (endian) {
  2239ab:	f6 44 24 70 01       	test   BYTE PTR [rsp+0x70],0x1
  2239b0:	74 1b                	je     2239cd <openSelfDebugInfo+0x3efd>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  2239b2:	c1 e1 08             	shl    ecx,0x8
  2239b5:	09 c1                	or     ecx,eax
  2239b7:	0f b6 54 24 22       	movzx  edx,BYTE PTR [rsp+0x22]
  2239bc:	c1 e2 10             	shl    edx,0x10
  2239bf:	09 ca                	or     edx,ecx
  2239c1:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  2239c6:	c1 e0 18             	shl    eax,0x18
  2239c9:	09 d0                	or     eax,edx
  2239cb:	eb 19                	jmp    2239e6 <openSelfDebugInfo+0x3f16>
                result = (result << 8) | b;
  2239cd:	c1 e0 08             	shl    eax,0x8
  2239d0:	09 c8                	or     eax,ecx
  2239d2:	c1 e0 08             	shl    eax,0x8
  2239d5:	0f b6 4c 24 22       	movzx  ecx,BYTE PTR [rsp+0x22]
  2239da:	09 c1                	or     ecx,eax
  2239dc:	c1 e1 08             	shl    ecx,0x8
  2239df:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  2239e4:	09 c8                	or     eax,ecx
  2239e6:	48 8b 8c 24 80 00 00 	mov    rcx,QWORD PTR [rsp+0x80]
  2239ed:	00 
  2239ee:	48 8b 54 24 48       	mov    rdx,QWORD PTR [rsp+0x48]
  2239f3:	89 44 11 f4          	mov    DWORD PTR [rcx+rdx*1-0xc],eax
                elf_section.addr_align = try in.readInt(elf.endian, u64);
  2239f7:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  2239fc:	0f b6 10             	movzx  edx,BYTE PTR [rax]
  2239ff:	48 8d bc 24 10 02 00 	lea    rdi,[rsp+0x210]
  223a06:	00 
  223a07:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  223a0c:	e8 5f 10 00 00       	call   224a70 <InStream(ReadError)_readInt.147>
  223a11:	44 0f b7 ac 24 10 02 	movzx  r13d,WORD PTR [rsp+0x210]
  223a18:	00 00 
  223a1a:	66 45 85 ed          	test   r13w,r13w
  223a1e:	0f 85 d8 0a 00 00    	jne    2244fc <openSelfDebugInfo+0x4a2c>
  223a24:	48 8b 84 24 18 02 00 	mov    rax,QWORD PTR [rsp+0x218]
  223a2b:	00 
  223a2c:	48 8b 8c 24 80 00 00 	mov    rcx,QWORD PTR [rsp+0x80]
  223a33:	00 
  223a34:	48 8b 54 24 48       	mov    rdx,QWORD PTR [rsp+0x48]
  223a39:	48 89 44 11 f8       	mov    QWORD PTR [rcx+rdx*1-0x8],rax
                elf_section.ent_size = try in.readInt(elf.endian, u64);
  223a3e:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  223a43:	0f b6 10             	movzx  edx,BYTE PTR [rax]
  223a46:	48 8d bc 24 40 02 00 	lea    rdi,[rsp+0x240]
  223a4d:	00 
  223a4e:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  223a53:	e8 18 10 00 00       	call   224a70 <InStream(ReadError)_readInt.147>
  223a58:	44 0f b7 ac 24 40 02 	movzx  r13d,WORD PTR [rsp+0x240]
  223a5f:	00 00 
  223a61:	66 45 85 ed          	test   r13w,r13w
  223a65:	0f 85 ef 0a 00 00    	jne    22455a <openSelfDebugInfo+0x4a8a>
  223a6b:	48 8b 84 24 48 02 00 	mov    rax,QWORD PTR [rsp+0x248]
  223a72:	00 
  223a73:	48 8b 8c 24 80 00 00 	mov    rcx,QWORD PTR [rsp+0x80]
  223a7a:	00 
  223a7b:	48 8b 54 24 48       	mov    rdx,QWORD PTR [rsp+0x48]
  223a80:	48 89 04 11          	mov    QWORD PTR [rcx+rdx*1],rax
  223a84:	48 8b 84 24 80 01 00 	mov    rax,QWORD PTR [rsp+0x180]
  223a8b:	00 
  223a8c:	48 89 c1             	mov    rcx,rax
            for (elf.section_headers) |*elf_section| {
  223a8f:	48 83 c1 01          	add    rcx,0x1
  223a93:	48 89 c8             	mov    rax,rcx
  223a96:	48 89 84 24 80 01 00 	mov    QWORD PTR [rsp+0x180],rax
  223a9d:	00 
  223a9e:	48 3b 4c 24 40       	cmp    rcx,QWORD PTR [rsp+0x40]
  223aa3:	0f 83 9a 0b 00 00    	jae    224643 <openSelfDebugInfo+0x4b73>
  223aa9:	48 83 44 24 48 40    	add    QWORD PTR [rsp+0x48],0x40
  223aaf:	48 8b 84 24 90 00 00 	mov    rax,QWORD PTR [rsp+0x90]
  223ab6:	00 
  223ab7:	48 8b 00             	mov    rax,QWORD PTR [rax]
                elf_section.name = try in.readInt(elf.endian, u32);
  223aba:	48 89 84 24 80 00 00 	mov    QWORD PTR [rsp+0x80],rax
  223ac1:	00 
  223ac2:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  223ac7:	0f b6 00             	movzx  eax,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  223aca:	88 44 24 70          	mov    BYTE PTR [rsp+0x70],al
  223ace:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  223ad3:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  223ada:	00 
  223adb:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x4
  223ae2:	00 04 00 00 00 
            return self.readFn(self, buffer);
  223ae7:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  223aee:	00 
  223aef:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  223af4:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  223afb:	00 
  223afc:	ff 54 24 58          	call   QWORD PTR [rsp+0x58]
  223b00:	44 0f b7 ac 24 f0 00 	movzx  r13d,WORD PTR [rsp+0xf0]
  223b07:	00 00 
  223b09:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  223b10:	00 
            const amt_read = try self.read(buf);
  223b11:	66 45 85 ed          	test   r13w,r13w
  223b15:	0f 84 25 fb ff ff    	je     223640 <openSelfDebugInfo+0x3b70>
  223b1b:	e9 d8 0a 00 00       	jmp    2245f8 <openSelfDebugInfo+0x4b28>
  223b20:	66 41 bd 03 00       	mov    r13w,0x3
  223b25:	48 83 f9 4b          	cmp    rcx,0x4b
  223b29:	0f 85 ed c1 ff ff    	jne    21fd1c <openSelfDebugInfo+0x24c>
  223b2f:	e9 e3 c4 ff ff       	jmp    220017 <openSelfDebugInfo+0x547>
            @panic("assertion failure");
  223b34:	48 8d 3d cd b1 02 00 	lea    rdi,[rip+0x2b1cd]        # 24ed08 <__unnamed_2>
  223b3b:	c5 f8 77             	vzeroupper 
  223b3e:	e8 dd e4 fe ff       	call   212020 <panic>
  223b43:	66 41 bd 04 00       	mov    r13w,0x4
            try st.elf.openFile(allocator, &st.self_exe_file);
  223b48:	66 45 85 ed          	test   r13w,r13w
  223b4c:	0f 85 d4 c1 ff ff    	jne    21fd26 <openSelfDebugInfo+0x256>
  223b52:	e9 bb c8 ff ff       	jmp    220412 <openSelfDebugInfo+0x942>
            if (sh_entry_size != 40) return error.InvalidFormat;
  223b57:	83 7c 24 48 28       	cmp    DWORD PTR [rsp+0x48],0x28
  223b5c:	0f 85 56 0a 00 00    	jne    2245b8 <openSelfDebugInfo+0x4ae8>
                elf_section.name = try in.readInt(elf.endian, u32);
  223b62:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  223b67:	8a 00                	mov    al,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  223b69:	88 44 24 70          	mov    BYTE PTR [rsp+0x70],al
  223b6d:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  223b72:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  223b79:	00 
  223b7a:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x4
  223b81:	00 04 00 00 00 
  223b86:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  223b8d:	00 
  223b8e:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  223b95:	00 
            return self.readFn(self, buffer);
  223b96:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  223b9b:	ff 54 24 58          	call   QWORD PTR [rsp+0x58]
  223b9f:	44 0f b7 ac 24 f0 00 	movzx  r13d,WORD PTR [rsp+0xf0]
  223ba6:	00 00 
            const amt_read = try self.read(buf);
  223ba8:	66 45 85 ed          	test   r13w,r13w
  223bac:	0f 85 46 0a 00 00    	jne    2245f8 <openSelfDebugInfo+0x4b28>
  223bb2:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  223bb9:	00 
  223bba:	31 c9                	xor    ecx,ecx
  223bbc:	48 89 8c 24 80 01 00 	mov    QWORD PTR [rsp+0x180],rcx
  223bc3:	00 
  223bc4:	b9 38 00 00 00       	mov    ecx,0x38
  223bc9:	48 89 4c 24 48       	mov    QWORD PTR [rsp+0x48],rcx
            if (amt_read < buf.len) return error.EndOfStream;
  223bce:	48 3b 84 24 a0 00 00 	cmp    rax,QWORD PTR [rsp+0xa0]
  223bd5:	00 
  223bd6:	0f 82 17 0a 00 00    	jb     2245f3 <openSelfDebugInfo+0x4b23>
  223bdc:	0f b6 44 24 20       	movzx  eax,BYTE PTR [rsp+0x20]
  223be1:	0f b6 4c 24 21       	movzx  ecx,BYTE PTR [rsp+0x21]
    switch (endian) {
  223be6:	f6 44 24 70 01       	test   BYTE PTR [rsp+0x70],0x1
  223beb:	74 1b                	je     223c08 <openSelfDebugInfo+0x4138>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  223bed:	c1 e1 08             	shl    ecx,0x8
  223bf0:	09 c1                	or     ecx,eax
  223bf2:	0f b6 54 24 22       	movzx  edx,BYTE PTR [rsp+0x22]
  223bf7:	c1 e2 10             	shl    edx,0x10
  223bfa:	09 ca                	or     edx,ecx
  223bfc:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  223c01:	c1 e0 18             	shl    eax,0x18
  223c04:	09 d0                	or     eax,edx
  223c06:	eb 19                	jmp    223c21 <openSelfDebugInfo+0x4151>
                result = (result << 8) | b;
  223c08:	c1 e0 08             	shl    eax,0x8
  223c0b:	09 c8                	or     eax,ecx
  223c0d:	c1 e0 08             	shl    eax,0x8
  223c10:	0f b6 4c 24 22       	movzx  ecx,BYTE PTR [rsp+0x22]
  223c15:	09 c1                	or     ecx,eax
  223c17:	c1 e1 08             	shl    ecx,0x8
  223c1a:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  223c1f:	09 c8                	or     eax,ecx
  223c21:	48 8b 8c 24 80 00 00 	mov    rcx,QWORD PTR [rsp+0x80]
  223c28:	00 
  223c29:	48 8b 54 24 48       	mov    rdx,QWORD PTR [rsp+0x48]
  223c2e:	89 44 11 c8          	mov    DWORD PTR [rcx+rdx*1-0x38],eax
                elf_section.sh_type = try in.readInt(elf.endian, u32);
  223c32:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  223c37:	0f b6 00             	movzx  eax,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  223c3a:	88 44 24 70          	mov    BYTE PTR [rsp+0x70],al
  223c3e:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  223c43:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  223c4a:	00 
  223c4b:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x4
  223c52:	00 04 00 00 00 
            return self.readFn(self, buffer);
  223c57:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  223c5e:	00 
  223c5f:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  223c64:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  223c6b:	00 
  223c6c:	ff 54 24 58          	call   QWORD PTR [rsp+0x58]
  223c70:	44 0f b7 ac 24 f0 00 	movzx  r13d,WORD PTR [rsp+0xf0]
  223c77:	00 00 
            const amt_read = try self.read(buf);
  223c79:	66 45 85 ed          	test   r13w,r13w
  223c7d:	0f 85 75 09 00 00    	jne    2245f8 <openSelfDebugInfo+0x4b28>
  223c83:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  223c8a:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  223c8b:	48 3b 84 24 a0 00 00 	cmp    rax,QWORD PTR [rsp+0xa0]
  223c92:	00 
  223c93:	0f 82 5a 09 00 00    	jb     2245f3 <openSelfDebugInfo+0x4b23>
  223c99:	0f b6 44 24 20       	movzx  eax,BYTE PTR [rsp+0x20]
  223c9e:	0f b6 4c 24 21       	movzx  ecx,BYTE PTR [rsp+0x21]
    switch (endian) {
  223ca3:	f6 44 24 70 01       	test   BYTE PTR [rsp+0x70],0x1
  223ca8:	74 1b                	je     223cc5 <openSelfDebugInfo+0x41f5>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  223caa:	c1 e1 08             	shl    ecx,0x8
  223cad:	09 c1                	or     ecx,eax
  223caf:	0f b6 54 24 22       	movzx  edx,BYTE PTR [rsp+0x22]
  223cb4:	c1 e2 10             	shl    edx,0x10
  223cb7:	09 ca                	or     edx,ecx
  223cb9:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  223cbe:	c1 e0 18             	shl    eax,0x18
  223cc1:	09 d0                	or     eax,edx
  223cc3:	eb 19                	jmp    223cde <openSelfDebugInfo+0x420e>
                result = (result << 8) | b;
  223cc5:	c1 e0 08             	shl    eax,0x8
  223cc8:	09 c8                	or     eax,ecx
  223cca:	c1 e0 08             	shl    eax,0x8
  223ccd:	0f b6 4c 24 22       	movzx  ecx,BYTE PTR [rsp+0x22]
  223cd2:	09 c1                	or     ecx,eax
  223cd4:	c1 e1 08             	shl    ecx,0x8
  223cd7:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  223cdc:	09 c8                	or     eax,ecx
  223cde:	48 8b 8c 24 80 00 00 	mov    rcx,QWORD PTR [rsp+0x80]
  223ce5:	00 
  223ce6:	48 8b 54 24 48       	mov    rdx,QWORD PTR [rsp+0x48]
  223ceb:	89 44 11 cc          	mov    DWORD PTR [rcx+rdx*1-0x34],eax
                elf_section.flags = u64(try in.readInt(elf.endian, u32));
  223cef:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  223cf4:	0f b6 00             	movzx  eax,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  223cf7:	88 44 24 70          	mov    BYTE PTR [rsp+0x70],al
  223cfb:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  223d00:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  223d07:	00 
  223d08:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x4
  223d0f:	00 04 00 00 00 
            return self.readFn(self, buffer);
  223d14:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  223d1b:	00 
  223d1c:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  223d21:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  223d28:	00 
  223d29:	ff 54 24 58          	call   QWORD PTR [rsp+0x58]
  223d2d:	44 0f b7 ac 24 f0 00 	movzx  r13d,WORD PTR [rsp+0xf0]
  223d34:	00 00 
            const amt_read = try self.read(buf);
  223d36:	66 45 85 ed          	test   r13w,r13w
  223d3a:	0f 85 b8 08 00 00    	jne    2245f8 <openSelfDebugInfo+0x4b28>
  223d40:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  223d47:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  223d48:	48 3b 84 24 a0 00 00 	cmp    rax,QWORD PTR [rsp+0xa0]
  223d4f:	00 
  223d50:	0f 82 9d 08 00 00    	jb     2245f3 <openSelfDebugInfo+0x4b23>
  223d56:	0f b6 44 24 20       	movzx  eax,BYTE PTR [rsp+0x20]
  223d5b:	0f b6 4c 24 21       	movzx  ecx,BYTE PTR [rsp+0x21]
    switch (endian) {
  223d60:	f6 44 24 70 01       	test   BYTE PTR [rsp+0x70],0x1
  223d65:	74 1b                	je     223d82 <openSelfDebugInfo+0x42b2>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  223d67:	c1 e1 08             	shl    ecx,0x8
  223d6a:	09 c1                	or     ecx,eax
  223d6c:	0f b6 54 24 22       	movzx  edx,BYTE PTR [rsp+0x22]
  223d71:	c1 e2 10             	shl    edx,0x10
  223d74:	09 ca                	or     edx,ecx
  223d76:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  223d7b:	c1 e0 18             	shl    eax,0x18
  223d7e:	09 d0                	or     eax,edx
  223d80:	eb 19                	jmp    223d9b <openSelfDebugInfo+0x42cb>
                result = (result << 8) | b;
  223d82:	c1 e0 08             	shl    eax,0x8
  223d85:	09 c8                	or     eax,ecx
  223d87:	c1 e0 08             	shl    eax,0x8
  223d8a:	0f b6 4c 24 22       	movzx  ecx,BYTE PTR [rsp+0x22]
  223d8f:	09 c1                	or     ecx,eax
  223d91:	c1 e1 08             	shl    ecx,0x8
  223d94:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  223d99:	09 c8                	or     eax,ecx
  223d9b:	89 c0                	mov    eax,eax
  223d9d:	48 8b 8c 24 80 00 00 	mov    rcx,QWORD PTR [rsp+0x80]
  223da4:	00 
  223da5:	48 8b 54 24 48       	mov    rdx,QWORD PTR [rsp+0x48]
  223daa:	48 89 44 11 d0       	mov    QWORD PTR [rcx+rdx*1-0x30],rax
                elf_section.addr = u64(try in.readInt(elf.endian, u32));
  223daf:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  223db4:	0f b6 00             	movzx  eax,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  223db7:	88 44 24 70          	mov    BYTE PTR [rsp+0x70],al
  223dbb:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  223dc0:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  223dc7:	00 
  223dc8:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x4
  223dcf:	00 04 00 00 00 
            return self.readFn(self, buffer);
  223dd4:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  223ddb:	00 
  223ddc:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  223de1:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  223de8:	00 
  223de9:	ff 54 24 58          	call   QWORD PTR [rsp+0x58]
  223ded:	44 0f b7 ac 24 f0 00 	movzx  r13d,WORD PTR [rsp+0xf0]
  223df4:	00 00 
            const amt_read = try self.read(buf);
  223df6:	66 45 85 ed          	test   r13w,r13w
  223dfa:	0f 85 f8 07 00 00    	jne    2245f8 <openSelfDebugInfo+0x4b28>
  223e00:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  223e07:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  223e08:	48 3b 84 24 a0 00 00 	cmp    rax,QWORD PTR [rsp+0xa0]
  223e0f:	00 
  223e10:	0f 82 dd 07 00 00    	jb     2245f3 <openSelfDebugInfo+0x4b23>
  223e16:	0f b6 44 24 20       	movzx  eax,BYTE PTR [rsp+0x20]
  223e1b:	0f b6 4c 24 21       	movzx  ecx,BYTE PTR [rsp+0x21]
    switch (endian) {
  223e20:	f6 44 24 70 01       	test   BYTE PTR [rsp+0x70],0x1
  223e25:	74 1b                	je     223e42 <openSelfDebugInfo+0x4372>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  223e27:	c1 e1 08             	shl    ecx,0x8
  223e2a:	09 c1                	or     ecx,eax
  223e2c:	0f b6 54 24 22       	movzx  edx,BYTE PTR [rsp+0x22]
  223e31:	c1 e2 10             	shl    edx,0x10
  223e34:	09 ca                	or     edx,ecx
  223e36:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  223e3b:	c1 e0 18             	shl    eax,0x18
  223e3e:	09 d0                	or     eax,edx
  223e40:	eb 19                	jmp    223e5b <openSelfDebugInfo+0x438b>
                result = (result << 8) | b;
  223e42:	c1 e0 08             	shl    eax,0x8
  223e45:	09 c8                	or     eax,ecx
  223e47:	c1 e0 08             	shl    eax,0x8
  223e4a:	0f b6 4c 24 22       	movzx  ecx,BYTE PTR [rsp+0x22]
  223e4f:	09 c1                	or     ecx,eax
  223e51:	c1 e1 08             	shl    ecx,0x8
  223e54:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  223e59:	09 c8                	or     eax,ecx
  223e5b:	89 c0                	mov    eax,eax
  223e5d:	48 8b 8c 24 80 00 00 	mov    rcx,QWORD PTR [rsp+0x80]
  223e64:	00 
  223e65:	48 8b 54 24 48       	mov    rdx,QWORD PTR [rsp+0x48]
  223e6a:	48 89 44 11 d8       	mov    QWORD PTR [rcx+rdx*1-0x28],rax
                elf_section.offset = u64(try in.readInt(elf.endian, u32));
  223e6f:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  223e74:	0f b6 00             	movzx  eax,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  223e77:	88 44 24 70          	mov    BYTE PTR [rsp+0x70],al
  223e7b:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  223e80:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  223e87:	00 
  223e88:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x4
  223e8f:	00 04 00 00 00 
            return self.readFn(self, buffer);
  223e94:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  223e9b:	00 
  223e9c:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  223ea1:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  223ea8:	00 
  223ea9:	ff 54 24 58          	call   QWORD PTR [rsp+0x58]
  223ead:	44 0f b7 ac 24 f0 00 	movzx  r13d,WORD PTR [rsp+0xf0]
  223eb4:	00 00 
            const amt_read = try self.read(buf);
  223eb6:	66 45 85 ed          	test   r13w,r13w
  223eba:	0f 85 38 07 00 00    	jne    2245f8 <openSelfDebugInfo+0x4b28>
  223ec0:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  223ec7:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  223ec8:	48 3b 84 24 a0 00 00 	cmp    rax,QWORD PTR [rsp+0xa0]
  223ecf:	00 
  223ed0:	0f 82 1d 07 00 00    	jb     2245f3 <openSelfDebugInfo+0x4b23>
  223ed6:	0f b6 44 24 20       	movzx  eax,BYTE PTR [rsp+0x20]
  223edb:	0f b6 4c 24 21       	movzx  ecx,BYTE PTR [rsp+0x21]
    switch (endian) {
  223ee0:	f6 44 24 70 01       	test   BYTE PTR [rsp+0x70],0x1
  223ee5:	74 1b                	je     223f02 <openSelfDebugInfo+0x4432>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  223ee7:	c1 e1 08             	shl    ecx,0x8
  223eea:	09 c1                	or     ecx,eax
  223eec:	0f b6 54 24 22       	movzx  edx,BYTE PTR [rsp+0x22]
  223ef1:	c1 e2 10             	shl    edx,0x10
  223ef4:	09 ca                	or     edx,ecx
  223ef6:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  223efb:	c1 e0 18             	shl    eax,0x18
  223efe:	09 d0                	or     eax,edx
  223f00:	eb 19                	jmp    223f1b <openSelfDebugInfo+0x444b>
                result = (result << 8) | b;
  223f02:	c1 e0 08             	shl    eax,0x8
  223f05:	09 c8                	or     eax,ecx
  223f07:	c1 e0 08             	shl    eax,0x8
  223f0a:	0f b6 4c 24 22       	movzx  ecx,BYTE PTR [rsp+0x22]
  223f0f:	09 c1                	or     ecx,eax
  223f11:	c1 e1 08             	shl    ecx,0x8
  223f14:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  223f19:	09 c8                	or     eax,ecx
  223f1b:	89 c0                	mov    eax,eax
  223f1d:	48 8b 8c 24 80 00 00 	mov    rcx,QWORD PTR [rsp+0x80]
  223f24:	00 
  223f25:	48 8b 54 24 48       	mov    rdx,QWORD PTR [rsp+0x48]
  223f2a:	48 89 44 11 e0       	mov    QWORD PTR [rcx+rdx*1-0x20],rax
                elf_section.size = u64(try in.readInt(elf.endian, u32));
  223f2f:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  223f34:	0f b6 00             	movzx  eax,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  223f37:	88 44 24 70          	mov    BYTE PTR [rsp+0x70],al
  223f3b:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  223f40:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  223f47:	00 
  223f48:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x4
  223f4f:	00 04 00 00 00 
            return self.readFn(self, buffer);
  223f54:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  223f5b:	00 
  223f5c:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  223f61:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  223f68:	00 
  223f69:	ff 54 24 58          	call   QWORD PTR [rsp+0x58]
  223f6d:	44 0f b7 ac 24 f0 00 	movzx  r13d,WORD PTR [rsp+0xf0]
  223f74:	00 00 
            const amt_read = try self.read(buf);
  223f76:	66 45 85 ed          	test   r13w,r13w
  223f7a:	0f 85 78 06 00 00    	jne    2245f8 <openSelfDebugInfo+0x4b28>
  223f80:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  223f87:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  223f88:	48 3b 84 24 a0 00 00 	cmp    rax,QWORD PTR [rsp+0xa0]
  223f8f:	00 
  223f90:	0f 82 5d 06 00 00    	jb     2245f3 <openSelfDebugInfo+0x4b23>
  223f96:	0f b6 44 24 20       	movzx  eax,BYTE PTR [rsp+0x20]
  223f9b:	0f b6 4c 24 21       	movzx  ecx,BYTE PTR [rsp+0x21]
    switch (endian) {
  223fa0:	f6 44 24 70 01       	test   BYTE PTR [rsp+0x70],0x1
  223fa5:	74 1b                	je     223fc2 <openSelfDebugInfo+0x44f2>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  223fa7:	c1 e1 08             	shl    ecx,0x8
  223faa:	09 c1                	or     ecx,eax
  223fac:	0f b6 54 24 22       	movzx  edx,BYTE PTR [rsp+0x22]
  223fb1:	c1 e2 10             	shl    edx,0x10
  223fb4:	09 ca                	or     edx,ecx
  223fb6:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  223fbb:	c1 e0 18             	shl    eax,0x18
  223fbe:	09 d0                	or     eax,edx
  223fc0:	eb 19                	jmp    223fdb <openSelfDebugInfo+0x450b>
                result = (result << 8) | b;
  223fc2:	c1 e0 08             	shl    eax,0x8
  223fc5:	09 c8                	or     eax,ecx
  223fc7:	c1 e0 08             	shl    eax,0x8
  223fca:	0f b6 4c 24 22       	movzx  ecx,BYTE PTR [rsp+0x22]
  223fcf:	09 c1                	or     ecx,eax
  223fd1:	c1 e1 08             	shl    ecx,0x8
  223fd4:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  223fd9:	09 c8                	or     eax,ecx
  223fdb:	89 c0                	mov    eax,eax
  223fdd:	48 8b 8c 24 80 00 00 	mov    rcx,QWORD PTR [rsp+0x80]
  223fe4:	00 
  223fe5:	48 8b 54 24 48       	mov    rdx,QWORD PTR [rsp+0x48]
  223fea:	48 89 44 11 e8       	mov    QWORD PTR [rcx+rdx*1-0x18],rax
                elf_section.link = try in.readInt(elf.endian, u32);
  223fef:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  223ff4:	0f b6 00             	movzx  eax,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  223ff7:	88 44 24 70          	mov    BYTE PTR [rsp+0x70],al
  223ffb:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  224000:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  224007:	00 
  224008:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x4
  22400f:	00 04 00 00 00 
            return self.readFn(self, buffer);
  224014:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  22401b:	00 
  22401c:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  224021:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  224028:	00 
  224029:	ff 54 24 58          	call   QWORD PTR [rsp+0x58]
  22402d:	44 0f b7 ac 24 f0 00 	movzx  r13d,WORD PTR [rsp+0xf0]
  224034:	00 00 
            const amt_read = try self.read(buf);
  224036:	66 45 85 ed          	test   r13w,r13w
  22403a:	0f 85 b8 05 00 00    	jne    2245f8 <openSelfDebugInfo+0x4b28>
  224040:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  224047:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  224048:	48 3b 84 24 a0 00 00 	cmp    rax,QWORD PTR [rsp+0xa0]
  22404f:	00 
  224050:	0f 82 9d 05 00 00    	jb     2245f3 <openSelfDebugInfo+0x4b23>
  224056:	0f b6 44 24 20       	movzx  eax,BYTE PTR [rsp+0x20]
  22405b:	0f b6 4c 24 21       	movzx  ecx,BYTE PTR [rsp+0x21]
    switch (endian) {
  224060:	f6 44 24 70 01       	test   BYTE PTR [rsp+0x70],0x1
  224065:	74 1b                	je     224082 <openSelfDebugInfo+0x45b2>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  224067:	c1 e1 08             	shl    ecx,0x8
  22406a:	09 c1                	or     ecx,eax
  22406c:	0f b6 54 24 22       	movzx  edx,BYTE PTR [rsp+0x22]
  224071:	c1 e2 10             	shl    edx,0x10
  224074:	09 ca                	or     edx,ecx
  224076:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  22407b:	c1 e0 18             	shl    eax,0x18
  22407e:	09 d0                	or     eax,edx
  224080:	eb 19                	jmp    22409b <openSelfDebugInfo+0x45cb>
                result = (result << 8) | b;
  224082:	c1 e0 08             	shl    eax,0x8
  224085:	09 c8                	or     eax,ecx
  224087:	c1 e0 08             	shl    eax,0x8
  22408a:	0f b6 4c 24 22       	movzx  ecx,BYTE PTR [rsp+0x22]
  22408f:	09 c1                	or     ecx,eax
  224091:	c1 e1 08             	shl    ecx,0x8
  224094:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  224099:	09 c8                	or     eax,ecx
  22409b:	48 8b 8c 24 80 00 00 	mov    rcx,QWORD PTR [rsp+0x80]
  2240a2:	00 
  2240a3:	48 8b 54 24 48       	mov    rdx,QWORD PTR [rsp+0x48]
  2240a8:	89 44 11 f0          	mov    DWORD PTR [rcx+rdx*1-0x10],eax
                elf_section.info = try in.readInt(elf.endian, u32);
  2240ac:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  2240b1:	0f b6 00             	movzx  eax,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  2240b4:	88 44 24 70          	mov    BYTE PTR [rsp+0x70],al
  2240b8:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  2240bd:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  2240c4:	00 
  2240c5:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x4
  2240cc:	00 04 00 00 00 
            return self.readFn(self, buffer);
  2240d1:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  2240d8:	00 
  2240d9:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  2240de:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  2240e5:	00 
  2240e6:	ff 54 24 58          	call   QWORD PTR [rsp+0x58]
  2240ea:	44 0f b7 ac 24 f0 00 	movzx  r13d,WORD PTR [rsp+0xf0]
  2240f1:	00 00 
            const amt_read = try self.read(buf);
  2240f3:	66 45 85 ed          	test   r13w,r13w
  2240f7:	0f 85 fb 04 00 00    	jne    2245f8 <openSelfDebugInfo+0x4b28>
  2240fd:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  224104:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  224105:	48 3b 84 24 a0 00 00 	cmp    rax,QWORD PTR [rsp+0xa0]
  22410c:	00 
  22410d:	0f 82 e0 04 00 00    	jb     2245f3 <openSelfDebugInfo+0x4b23>
  224113:	0f b6 44 24 20       	movzx  eax,BYTE PTR [rsp+0x20]
  224118:	0f b6 4c 24 21       	movzx  ecx,BYTE PTR [rsp+0x21]
    switch (endian) {
  22411d:	f6 44 24 70 01       	test   BYTE PTR [rsp+0x70],0x1
  224122:	74 1b                	je     22413f <openSelfDebugInfo+0x466f>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  224124:	c1 e1 08             	shl    ecx,0x8
  224127:	09 c1                	or     ecx,eax
  224129:	0f b6 54 24 22       	movzx  edx,BYTE PTR [rsp+0x22]
  22412e:	c1 e2 10             	shl    edx,0x10
  224131:	09 ca                	or     edx,ecx
  224133:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  224138:	c1 e0 18             	shl    eax,0x18
  22413b:	09 d0                	or     eax,edx
  22413d:	eb 19                	jmp    224158 <openSelfDebugInfo+0x4688>
                result = (result << 8) | b;
  22413f:	c1 e0 08             	shl    eax,0x8
  224142:	09 c8                	or     eax,ecx
  224144:	c1 e0 08             	shl    eax,0x8
  224147:	0f b6 4c 24 22       	movzx  ecx,BYTE PTR [rsp+0x22]
  22414c:	09 c1                	or     ecx,eax
  22414e:	c1 e1 08             	shl    ecx,0x8
  224151:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  224156:	09 c8                	or     eax,ecx
  224158:	48 8b 8c 24 80 00 00 	mov    rcx,QWORD PTR [rsp+0x80]
  22415f:	00 
  224160:	48 8b 54 24 48       	mov    rdx,QWORD PTR [rsp+0x48]
  224165:	89 44 11 f4          	mov    DWORD PTR [rcx+rdx*1-0xc],eax
                elf_section.addr_align = u64(try in.readInt(elf.endian, u32));
  224169:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  22416e:	0f b6 00             	movzx  eax,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  224171:	88 44 24 70          	mov    BYTE PTR [rsp+0x70],al
  224175:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  22417a:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  224181:	00 
  224182:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x4
  224189:	00 04 00 00 00 
            return self.readFn(self, buffer);
  22418e:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  224195:	00 
  224196:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  22419b:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  2241a2:	00 
  2241a3:	ff 54 24 58          	call   QWORD PTR [rsp+0x58]
  2241a7:	44 0f b7 ac 24 f0 00 	movzx  r13d,WORD PTR [rsp+0xf0]
  2241ae:	00 00 
            const amt_read = try self.read(buf);
  2241b0:	66 45 85 ed          	test   r13w,r13w
  2241b4:	0f 85 3e 04 00 00    	jne    2245f8 <openSelfDebugInfo+0x4b28>
  2241ba:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  2241c1:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  2241c2:	48 3b 84 24 a0 00 00 	cmp    rax,QWORD PTR [rsp+0xa0]
  2241c9:	00 
  2241ca:	0f 82 23 04 00 00    	jb     2245f3 <openSelfDebugInfo+0x4b23>
  2241d0:	0f b6 44 24 20       	movzx  eax,BYTE PTR [rsp+0x20]
  2241d5:	0f b6 4c 24 21       	movzx  ecx,BYTE PTR [rsp+0x21]
    switch (endian) {
  2241da:	f6 44 24 70 01       	test   BYTE PTR [rsp+0x70],0x1
  2241df:	74 1b                	je     2241fc <openSelfDebugInfo+0x472c>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  2241e1:	c1 e1 08             	shl    ecx,0x8
  2241e4:	09 c1                	or     ecx,eax
  2241e6:	0f b6 54 24 22       	movzx  edx,BYTE PTR [rsp+0x22]
  2241eb:	c1 e2 10             	shl    edx,0x10
  2241ee:	09 ca                	or     edx,ecx
  2241f0:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  2241f5:	c1 e0 18             	shl    eax,0x18
  2241f8:	09 d0                	or     eax,edx
  2241fa:	eb 19                	jmp    224215 <openSelfDebugInfo+0x4745>
                result = (result << 8) | b;
  2241fc:	c1 e0 08             	shl    eax,0x8
  2241ff:	09 c8                	or     eax,ecx
  224201:	c1 e0 08             	shl    eax,0x8
  224204:	0f b6 4c 24 22       	movzx  ecx,BYTE PTR [rsp+0x22]
  224209:	09 c1                	or     ecx,eax
  22420b:	c1 e1 08             	shl    ecx,0x8
  22420e:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  224213:	09 c8                	or     eax,ecx
  224215:	89 c0                	mov    eax,eax
  224217:	48 8b 8c 24 80 00 00 	mov    rcx,QWORD PTR [rsp+0x80]
  22421e:	00 
  22421f:	48 8b 54 24 48       	mov    rdx,QWORD PTR [rsp+0x48]
  224224:	48 89 44 11 f8       	mov    QWORD PTR [rcx+rdx*1-0x8],rax
                elf_section.ent_size = u64(try in.readInt(elf.endian, u32));
  224229:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  22422e:	0f b6 00             	movzx  eax,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  224231:	88 44 24 70          	mov    BYTE PTR [rsp+0x70],al
  224235:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  22423a:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  224241:	00 
  224242:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x4
  224249:	00 04 00 00 00 
            return self.readFn(self, buffer);
  22424e:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  224255:	00 
  224256:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  22425b:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  224262:	00 
  224263:	ff 54 24 58          	call   QWORD PTR [rsp+0x58]
  224267:	44 0f b7 ac 24 f0 00 	movzx  r13d,WORD PTR [rsp+0xf0]
  22426e:	00 00 
            const amt_read = try self.read(buf);
  224270:	66 45 85 ed          	test   r13w,r13w
  224274:	0f 85 7e 03 00 00    	jne    2245f8 <openSelfDebugInfo+0x4b28>
  22427a:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  224281:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  224282:	48 3b 84 24 a0 00 00 	cmp    rax,QWORD PTR [rsp+0xa0]
  224289:	00 
  22428a:	0f 82 63 03 00 00    	jb     2245f3 <openSelfDebugInfo+0x4b23>
  224290:	0f b6 44 24 20       	movzx  eax,BYTE PTR [rsp+0x20]
  224295:	0f b6 4c 24 21       	movzx  ecx,BYTE PTR [rsp+0x21]
    switch (endian) {
  22429a:	f6 44 24 70 01       	test   BYTE PTR [rsp+0x70],0x1
  22429f:	74 1b                	je     2242bc <openSelfDebugInfo+0x47ec>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  2242a1:	c1 e1 08             	shl    ecx,0x8
  2242a4:	09 c1                	or     ecx,eax
  2242a6:	0f b6 54 24 22       	movzx  edx,BYTE PTR [rsp+0x22]
  2242ab:	c1 e2 10             	shl    edx,0x10
  2242ae:	09 ca                	or     edx,ecx
  2242b0:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  2242b5:	c1 e0 18             	shl    eax,0x18
  2242b8:	09 d0                	or     eax,edx
  2242ba:	eb 19                	jmp    2242d5 <openSelfDebugInfo+0x4805>
                result = (result << 8) | b;
  2242bc:	c1 e0 08             	shl    eax,0x8
  2242bf:	09 c8                	or     eax,ecx
  2242c1:	c1 e0 08             	shl    eax,0x8
  2242c4:	0f b6 4c 24 22       	movzx  ecx,BYTE PTR [rsp+0x22]
  2242c9:	09 c1                	or     ecx,eax
  2242cb:	c1 e1 08             	shl    ecx,0x8
  2242ce:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  2242d3:	09 c8                	or     eax,ecx
  2242d5:	89 c0                	mov    eax,eax
  2242d7:	48 8b 8c 24 80 00 00 	mov    rcx,QWORD PTR [rsp+0x80]
  2242de:	00 
  2242df:	48 8b 54 24 48       	mov    rdx,QWORD PTR [rsp+0x48]
  2242e4:	48 89 04 11          	mov    QWORD PTR [rcx+rdx*1],rax
  2242e8:	48 8b 84 24 80 01 00 	mov    rax,QWORD PTR [rsp+0x180]
  2242ef:	00 
  2242f0:	48 89 c1             	mov    rcx,rax
            for (elf.section_headers) |*elf_section| {
  2242f3:	48 83 c1 01          	add    rcx,0x1
  2242f7:	48 89 c8             	mov    rax,rcx
  2242fa:	48 89 84 24 80 01 00 	mov    QWORD PTR [rsp+0x180],rax
  224301:	00 
  224302:	48 3b 4c 24 40       	cmp    rcx,QWORD PTR [rsp+0x40]
  224307:	0f 83 36 03 00 00    	jae    224643 <openSelfDebugInfo+0x4b73>
  22430d:	48 83 44 24 48 40    	add    QWORD PTR [rsp+0x48],0x40
  224313:	48 8b 84 24 90 00 00 	mov    rax,QWORD PTR [rsp+0x90]
  22431a:	00 
  22431b:	48 8b 00             	mov    rax,QWORD PTR [rax]
                elf_section.name = try in.readInt(elf.endian, u32);
  22431e:	48 89 84 24 80 00 00 	mov    QWORD PTR [rsp+0x80],rax
  224325:	00 
  224326:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  22432b:	0f b6 00             	movzx  eax,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  22432e:	88 44 24 70          	mov    BYTE PTR [rsp+0x70],al
  224332:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  224337:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  22433e:	00 
  22433f:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x4
  224346:	00 04 00 00 00 
            return self.readFn(self, buffer);
  22434b:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  224352:	00 
  224353:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  224358:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  22435f:	00 
  224360:	ff 54 24 58          	call   QWORD PTR [rsp+0x58]
  224364:	44 0f b7 ac 24 f0 00 	movzx  r13d,WORD PTR [rsp+0xf0]
  22436b:	00 00 
  22436d:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  224374:	00 
            const amt_read = try self.read(buf);
  224375:	66 45 85 ed          	test   r13w,r13w
  224379:	0f 84 4f f8 ff ff    	je     223bce <openSelfDebugInfo+0x40fe>
  22437f:	e9 74 02 00 00       	jmp    2245f8 <openSelfDebugInfo+0x4b28>
        const bytes = @sliceToBytes(memory);
  224384:	48 8b 84 24 88 00 00 	mov    rax,QWORD PTR [rsp+0x88]
  22438b:	00 
  22438c:	48 8b 00             	mov    rax,QWORD PTR [rax]
  22438f:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  224393:	0f 84 83 b9 ff ff    	je     21fd1c <openSelfDebugInfo+0x24c>
  224399:	48 8b 4c 24 78       	mov    rcx,QWORD PTR [rsp+0x78]
  22439e:	48 8b 39             	mov    rdi,QWORD PTR [rcx]
        const bytes = @sliceToBytes(memory);
  2243a1:	48 8b 8c 24 90 00 00 	mov    rcx,QWORD PTR [rsp+0x90]
  2243a8:	00 
  2243a9:	48 8b 09             	mov    rcx,QWORD PTR [rcx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  2243ac:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  2243b0:	48 89 8c 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rcx
  2243b7:	00 
  2243b8:	48 89 84 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],rax
  2243bf:	00 
  2243c0:	48 8d b4 24 f0 00 00 	lea    rsi,[rsp+0xf0]
  2243c7:	00 
  2243c8:	ff d2                	call   rdx
                elf_section.flags = try in.readInt(elf.endian, u64);
  2243ca:	44 0f b7 ac 24 78 03 	movzx  r13d,WORD PTR [rsp+0x378]
  2243d1:	00 00 
  2243d3:	66 45 85 ed          	test   r13w,r13w
  2243d7:	0f 85 49 b9 ff ff    	jne    21fd26 <openSelfDebugInfo+0x256>
  2243dd:	e9 30 c0 ff ff       	jmp    220412 <openSelfDebugInfo+0x942>
        const bytes = @sliceToBytes(memory);
  2243e2:	48 8b 84 24 88 00 00 	mov    rax,QWORD PTR [rsp+0x88]
  2243e9:	00 
  2243ea:	48 8b 00             	mov    rax,QWORD PTR [rax]
  2243ed:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  2243f1:	0f 84 25 b9 ff ff    	je     21fd1c <openSelfDebugInfo+0x24c>
  2243f7:	48 8b 4c 24 78       	mov    rcx,QWORD PTR [rsp+0x78]
  2243fc:	48 8b 39             	mov    rdi,QWORD PTR [rcx]
        const bytes = @sliceToBytes(memory);
  2243ff:	48 8b 8c 24 90 00 00 	mov    rcx,QWORD PTR [rsp+0x90]
  224406:	00 
  224407:	48 8b 09             	mov    rcx,QWORD PTR [rcx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  22440a:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  22440e:	48 89 8c 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rcx
  224415:	00 
  224416:	48 89 84 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],rax
  22441d:	00 
  22441e:	48 8d b4 24 f0 00 00 	lea    rsi,[rsp+0xf0]
  224425:	00 
  224426:	ff d2                	call   rdx
                elf_section.addr = try in.readInt(elf.endian, u64);
  224428:	44 0f b7 ac 24 a0 03 	movzx  r13d,WORD PTR [rsp+0x3a0]
  22442f:	00 00 
  224431:	66 45 85 ed          	test   r13w,r13w
  224435:	0f 85 eb b8 ff ff    	jne    21fd26 <openSelfDebugInfo+0x256>
  22443b:	e9 d2 bf ff ff       	jmp    220412 <openSelfDebugInfo+0x942>
        const bytes = @sliceToBytes(memory);
  224440:	48 8b 84 24 88 00 00 	mov    rax,QWORD PTR [rsp+0x88]
  224447:	00 
  224448:	48 8b 00             	mov    rax,QWORD PTR [rax]
  22444b:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  22444f:	0f 84 c7 b8 ff ff    	je     21fd1c <openSelfDebugInfo+0x24c>
  224455:	48 8b 4c 24 78       	mov    rcx,QWORD PTR [rsp+0x78]
  22445a:	48 8b 39             	mov    rdi,QWORD PTR [rcx]
        const bytes = @sliceToBytes(memory);
  22445d:	48 8b 8c 24 90 00 00 	mov    rcx,QWORD PTR [rsp+0x90]
  224464:	00 
  224465:	48 8b 09             	mov    rcx,QWORD PTR [rcx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  224468:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  22446c:	48 89 8c 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rcx
  224473:	00 
  224474:	48 89 84 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],rax
  22447b:	00 
  22447c:	48 8d b4 24 f0 00 00 	lea    rsi,[rsp+0xf0]
  224483:	00 
  224484:	ff d2                	call   rdx
                elf_section.offset = try in.readInt(elf.endian, u64);
  224486:	44 0f b7 ac 24 50 03 	movzx  r13d,WORD PTR [rsp+0x350]
  22448d:	00 00 
  22448f:	66 45 85 ed          	test   r13w,r13w
  224493:	0f 85 8d b8 ff ff    	jne    21fd26 <openSelfDebugInfo+0x256>
  224499:	e9 74 bf ff ff       	jmp    220412 <openSelfDebugInfo+0x942>
        const bytes = @sliceToBytes(memory);
  22449e:	48 8b 84 24 88 00 00 	mov    rax,QWORD PTR [rsp+0x88]
  2244a5:	00 
  2244a6:	48 8b 00             	mov    rax,QWORD PTR [rax]
  2244a9:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  2244ad:	0f 84 69 b8 ff ff    	je     21fd1c <openSelfDebugInfo+0x24c>
  2244b3:	48 8b 4c 24 78       	mov    rcx,QWORD PTR [rsp+0x78]
  2244b8:	48 8b 39             	mov    rdi,QWORD PTR [rcx]
        const bytes = @sliceToBytes(memory);
  2244bb:	48 8b 8c 24 90 00 00 	mov    rcx,QWORD PTR [rsp+0x90]
  2244c2:	00 
  2244c3:	48 8b 09             	mov    rcx,QWORD PTR [rcx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  2244c6:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  2244ca:	48 89 8c 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rcx
  2244d1:	00 
  2244d2:	48 89 84 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],rax
  2244d9:	00 
  2244da:	48 8d b4 24 f0 00 00 	lea    rsi,[rsp+0xf0]
  2244e1:	00 
  2244e2:	ff d2                	call   rdx
                elf_section.size = try in.readInt(elf.endian, u64);
  2244e4:	44 0f b7 ac 24 d0 01 	movzx  r13d,WORD PTR [rsp+0x1d0]
  2244eb:	00 00 
  2244ed:	66 45 85 ed          	test   r13w,r13w
  2244f1:	0f 85 2f b8 ff ff    	jne    21fd26 <openSelfDebugInfo+0x256>
  2244f7:	e9 16 bf ff ff       	jmp    220412 <openSelfDebugInfo+0x942>
        const bytes = @sliceToBytes(memory);
  2244fc:	48 8b 84 24 88 00 00 	mov    rax,QWORD PTR [rsp+0x88]
  224503:	00 
  224504:	48 8b 00             	mov    rax,QWORD PTR [rax]
  224507:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  22450b:	0f 84 0b b8 ff ff    	je     21fd1c <openSelfDebugInfo+0x24c>
  224511:	48 8b 4c 24 78       	mov    rcx,QWORD PTR [rsp+0x78]
  224516:	48 8b 39             	mov    rdi,QWORD PTR [rcx]
        const bytes = @sliceToBytes(memory);
  224519:	48 8b 8c 24 90 00 00 	mov    rcx,QWORD PTR [rsp+0x90]
  224520:	00 
  224521:	48 8b 09             	mov    rcx,QWORD PTR [rcx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  224524:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  224528:	48 89 8c 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rcx
  22452f:	00 
  224530:	48 89 84 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],rax
  224537:	00 
  224538:	48 8d b4 24 f0 00 00 	lea    rsi,[rsp+0xf0]
  22453f:	00 
  224540:	ff d2                	call   rdx
                elf_section.addr_align = try in.readInt(elf.endian, u64);
  224542:	44 0f b7 ac 24 10 02 	movzx  r13d,WORD PTR [rsp+0x210]
  224549:	00 00 
  22454b:	66 45 85 ed          	test   r13w,r13w
  22454f:	0f 85 d1 b7 ff ff    	jne    21fd26 <openSelfDebugInfo+0x256>
  224555:	e9 b8 be ff ff       	jmp    220412 <openSelfDebugInfo+0x942>
        const bytes = @sliceToBytes(memory);
  22455a:	48 8b 84 24 88 00 00 	mov    rax,QWORD PTR [rsp+0x88]
  224561:	00 
  224562:	48 8b 00             	mov    rax,QWORD PTR [rax]
  224565:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  224569:	0f 84 ad b7 ff ff    	je     21fd1c <openSelfDebugInfo+0x24c>
  22456f:	48 8b 4c 24 78       	mov    rcx,QWORD PTR [rsp+0x78]
  224574:	48 8b 39             	mov    rdi,QWORD PTR [rcx]
        const bytes = @sliceToBytes(memory);
  224577:	48 8b 8c 24 90 00 00 	mov    rcx,QWORD PTR [rsp+0x90]
  22457e:	00 
  22457f:	48 8b 09             	mov    rcx,QWORD PTR [rcx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  224582:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  224586:	48 89 8c 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rcx
  22458d:	00 
  22458e:	48 89 84 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],rax
  224595:	00 
  224596:	48 8d b4 24 f0 00 00 	lea    rsi,[rsp+0xf0]
  22459d:	00 
  22459e:	ff d2                	call   rdx
                elf_section.ent_size = try in.readInt(elf.endian, u64);
  2245a0:	44 0f b7 ac 24 40 02 	movzx  r13d,WORD PTR [rsp+0x240]
  2245a7:	00 00 
  2245a9:	66 45 85 ed          	test   r13w,r13w
  2245ad:	0f 85 73 b7 ff ff    	jne    21fd26 <openSelfDebugInfo+0x256>
  2245b3:	e9 5a be ff ff       	jmp    220412 <openSelfDebugInfo+0x942>
  2245b8:	48 8b 44 24 78       	mov    rax,QWORD PTR [rsp+0x78]
  2245bd:	48 8b 38             	mov    rdi,QWORD PTR [rax]
  2245c0:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  2245c4:	48 8b 8c 24 80 00 00 	mov    rcx,QWORD PTR [rsp+0x80]
  2245cb:	00 
  2245cc:	48 89 8c 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rcx
  2245d3:	00 
  2245d4:	48 8b 8c 24 80 01 00 	mov    rcx,QWORD PTR [rsp+0x180]
  2245db:	00 
  2245dc:	48 89 8c 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],rcx
  2245e3:	00 
  2245e4:	48 8d b4 24 f0 00 00 	lea    rsi,[rsp+0xf0]
  2245eb:	00 
  2245ec:	ff d0                	call   rax
  2245ee:	e9 61 01 00 00       	jmp    224754 <openSelfDebugInfo+0x4c84>
  2245f3:	66 41 bd 25 00       	mov    r13w,0x25
        const bytes = @sliceToBytes(memory);
  2245f8:	48 8b 84 24 88 00 00 	mov    rax,QWORD PTR [rsp+0x88]
  2245ff:	00 
  224600:	48 8b 00             	mov    rax,QWORD PTR [rax]
  224603:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  224607:	0f 84 19 b7 ff ff    	je     21fd26 <openSelfDebugInfo+0x256>
  22460d:	48 8b 4c 24 78       	mov    rcx,QWORD PTR [rsp+0x78]
  224612:	48 8b 39             	mov    rdi,QWORD PTR [rcx]
        const bytes = @sliceToBytes(memory);
  224615:	48 8b 8c 24 90 00 00 	mov    rcx,QWORD PTR [rsp+0x90]
  22461c:	00 
  22461d:	48 8b 09             	mov    rcx,QWORD PTR [rcx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  224620:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  224624:	48 89 8c 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rcx
  22462b:	00 
  22462c:	48 89 84 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],rax
  224633:	00 
  224634:	48 8d b4 24 f0 00 00 	lea    rsi,[rsp+0xf0]
  22463b:	00 
  22463c:	ff d2                	call   rdx
  22463e:	e9 e3 b6 ff ff       	jmp    21fd26 <openSelfDebugInfo+0x256>
        for (elf.section_headers) |*elf_section| {
  224643:	48 8b 84 24 88 00 00 	mov    rax,QWORD PTR [rsp+0x88]
  22464a:	00 
  22464b:	48 8b 00             	mov    rax,QWORD PTR [rax]
  22464e:	48 85 c0             	test   rax,rax
  224651:	74 6b                	je     2246be <openSelfDebugInfo+0x4bee>
  224653:	48 8b 8c 24 90 00 00 	mov    rcx,QWORD PTR [rsp+0x90]
  22465a:	00 
  22465b:	4c 8b 09             	mov    r9,QWORD PTR [rcx]
  22465e:	49 8d 51 20          	lea    rdx,[r9+0x20]
  224662:	31 f6                	xor    esi,esi
  224664:	4c 8d 05 15 49 fe ff 	lea    r8,[rip+0xfffffffffffe4915]        # 208f80 <__unnamed_43>
            if (elf_section.sh_type != SHT_NOBITS) {
  22466b:	83 7a e4 08          	cmp    DWORD PTR [rdx-0x1c],0x8
  22466f:	74 3e                	je     2246af <openSelfDebugInfo+0x4bdf>
                const file_end_offset = try math.add(u64, elf_section.offset, elf_section.size);
  224671:	48 8b 4a f8          	mov    rcx,QWORD PTR [rdx-0x8]
  224675:	4c 89 c7             	mov    rdi,r8
    return if (@addWithOverflow(T, a, b, &answer)) error.Overflow else answer;
  224678:	48 03 0a             	add    rcx,QWORD PTR [rdx]
  22467b:	72 1a                	jb     224697 <openSelfDebugInfo+0x4bc7>
  22467d:	66 c7 84 24 f0 00 00 	mov    WORD PTR [rsp+0xf0],0x0
  224684:	00 00 00 
  224687:	48 89 8c 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],rcx
  22468e:	00 
  22468f:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  224696:	00 
  224697:	44 0f b7 2f          	movzx  r13d,WORD PTR [rdi]
  22469b:	66 45 85 ed          	test   r13w,r13w
  22469f:	75 52                	jne    2246f3 <openSelfDebugInfo+0x4c23>
                if (stream_end < file_end_offset) return error.InvalidFormat;
  2246a1:	48 8b 8c 24 c8 01 00 	mov    rcx,QWORD PTR [rsp+0x1c8]
  2246a8:	00 
  2246a9:	48 3b 4f 08          	cmp    rcx,QWORD PTR [rdi+0x8]
  2246ad:	72 79                	jb     224728 <openSelfDebugInfo+0x4c58>
        for (elf.section_headers) |*elf_section| {
  2246af:	48 83 c6 01          	add    rsi,0x1
  2246b3:	48 83 c2 40          	add    rdx,0x40
  2246b7:	48 39 c6             	cmp    rsi,rax
  2246ba:	72 af                	jb     22466b <openSelfDebugInfo+0x4b9b>
  2246bc:	eb 0b                	jmp    2246c9 <openSelfDebugInfo+0x4bf9>
        elf.string_section = &elf.section_headers[elf.string_section_index];
  2246be:	48 8b 8c 24 90 00 00 	mov    rcx,QWORD PTR [rsp+0x90]
  2246c5:	00 
  2246c6:	4c 8b 09             	mov    r9,QWORD PTR [rcx]
  2246c9:	48 8b 4d 30          	mov    rcx,QWORD PTR [rbp+0x30]
  2246cd:	48 c1 e1 06          	shl    rcx,0x6
  2246d1:	49 8d 14 09          	lea    rdx,[r9+rcx*1]
  2246d5:	48 89 55 38          	mov    QWORD PTR [rbp+0x38],rdx
        if (elf.string_section.sh_type != SHT_STRTAB) {
  2246d9:	41 83 7c 09 04 03    	cmp    DWORD PTR [r9+rcx*1+0x4],0x3
  2246df:	75 47                	jne    224728 <openSelfDebugInfo+0x4c58>
  2246e1:	45 31 ed             	xor    r13d,r13d
  2246e4:	66 45 85 ed          	test   r13w,r13w
  2246e8:	0f 85 38 b6 ff ff    	jne    21fd26 <openSelfDebugInfo+0x256>
  2246ee:	e9 1f bd ff ff       	jmp    220412 <openSelfDebugInfo+0x942>
        const bytes = @sliceToBytes(memory);
  2246f3:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  2246f7:	0f 84 29 b6 ff ff    	je     21fd26 <openSelfDebugInfo+0x256>
  2246fd:	48 8b 4c 24 78       	mov    rcx,QWORD PTR [rsp+0x78]
  224702:	48 8b 39             	mov    rdi,QWORD PTR [rcx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  224705:	48 8b 4f 10          	mov    rcx,QWORD PTR [rdi+0x10]
  224709:	4c 89 8c 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],r9
  224710:	00 
  224711:	48 89 84 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],rax
  224718:	00 
  224719:	48 8d b4 24 f0 00 00 	lea    rsi,[rsp+0xf0]
  224720:	00 
  224721:	ff d1                	call   rcx
  224723:	e9 fe b5 ff ff       	jmp    21fd26 <openSelfDebugInfo+0x256>
        const bytes = @sliceToBytes(memory);
  224728:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  22472c:	74 26                	je     224754 <openSelfDebugInfo+0x4c84>
  22472e:	48 8b 4c 24 78       	mov    rcx,QWORD PTR [rsp+0x78]
  224733:	48 8b 39             	mov    rdi,QWORD PTR [rcx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  224736:	48 8b 4f 10          	mov    rcx,QWORD PTR [rdi+0x10]
  22473a:	4c 89 8c 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],r9
  224741:	00 
  224742:	48 89 84 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],rax
  224749:	00 
  22474a:	48 8d b4 24 f0 00 00 	lea    rsi,[rsp+0xf0]
  224751:	00 
  224752:	ff d1                	call   rcx
  224754:	66 41 bd 26 00       	mov    r13w,0x26
  224759:	e9 c8 b5 ff ff       	jmp    21fd26 <openSelfDebugInfo+0x256>
  22475e:	66 90                	xchg   ax,ax

0000000000224760 <Elf_findSection>:
    }

    pub fn findSection(elf: *Elf, name: []const u8) !?*SectionHeader {
  224760:	55                   	push   rbp
  224761:	41 57                	push   r15
  224763:	41 56                	push   r14
  224765:	41 55                	push   r13
  224767:	41 54                	push   r12
  224769:	53                   	push   rbx
  22476a:	48 81 ec 88 00 00 00 	sub    rsp,0x88
  224771:	48 89 d3             	mov    rbx,rdx
  224774:	48 89 7c 24 08       	mov    QWORD PTR [rsp+0x8],rdi
        var file_stream = io.FileInStream.init(elf.in_file);
  224779:	48 8b 06             	mov    rax,QWORD PTR [rsi]
  22477c:	48 89 44 24 28       	mov    QWORD PTR [rsp+0x28],rax
  224781:	48 8d 05 48 05 00 00 	lea    rax,[rip+0x548]        # 224cd0 <FileInStream_readFn>
  224788:	48 89 44 24 30       	mov    QWORD PTR [rsp+0x30],rax
        const in = &file_stream.stream;

        section_loop: for (elf.section_headers) |*elf_section| {
  22478d:	48 8b 46 40          	mov    rax,QWORD PTR [rsi+0x40]
  224791:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
  224796:	48 85 c0             	test   rax,rax
  224799:	0f 84 37 01 00 00    	je     2248d6 <Elf_findSection+0x176>
  22479f:	45 31 e4             	xor    r12d,r12d
  2247a2:	48 89 74 24 20       	mov    QWORD PTR [rsp+0x20],rsi
  2247a7:	4c 8b 76 38          	mov    r14,QWORD PTR [rsi+0x38]
  2247ab:	4c 89 e0             	mov    rax,r12
  2247ae:	48 c1 e0 06          	shl    rax,0x6
            if (elf_section.sh_type == SHT_NULL) continue;
  2247b2:	41 83 7c 06 04 00    	cmp    DWORD PTR [r14+rax*1+0x4],0x0
  2247b8:	0f 84 04 01 00 00    	je     2248c2 <Elf_findSection+0x162>
  2247be:	49 01 c6             	add    r14,rax
  2247c1:	48 8b 4c 24 20       	mov    rcx,QWORD PTR [rsp+0x20]

            const name_offset = elf.string_section.offset + elf_section.name;
  2247c6:	48 8b 41 30          	mov    rax,QWORD PTR [rcx+0x30]
  2247ca:	41 8b 36             	mov    esi,DWORD PTR [r14]
    if (@maxValue(@typeOf(x)) > @maxValue(T) and x > @maxValue(T)) {
  2247cd:	48 03 70 18          	add    rsi,QWORD PTR [rax+0x18]
  2247d1:	0f 88 3e 01 00 00    	js     224915 <Elf_findSection+0x1b5>
            try elf.in_file.seekTo(name_offset);
  2247d7:	48 8b 01             	mov    rax,QWORD PTR [rcx]
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  2247da:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  2247dd:	b8 08 00 00 00       	mov    eax,0x8
  2247e2:	31 d2                	xor    edx,edx
  2247e4:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  2247e6:	48 89 c1             	mov    rcx,rax
  2247e9:	48 f7 d9             	neg    rcx
  2247ec:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  2247f2:	b8 00 00 00 00       	mov    eax,0x0
  2247f7:	48 0f 46 c8          	cmovbe rcx,rax
  2247fb:	48 85 c9             	test   rcx,rcx
  2247fe:	0f 85 17 01 00 00    	jne    22491b <Elf_findSection+0x1bb>

            for (name) |expected_c| {
  224804:	4c 8b 6b 08          	mov    r13,QWORD PTR [rbx+0x8]
  224808:	4d 85 ed             	test   r13,r13
  22480b:	74 66                	je     224873 <Elf_findSection+0x113>
  22480d:	31 ed                	xor    ebp,ebp
  22480f:	90                   	nop
  224810:	48 8b 03             	mov    rax,QWORD PTR [rbx]
  224813:	44 0f b6 3c 28       	movzx  r15d,BYTE PTR [rax+rbp*1]
            try self.readNoEof(result[0..]);
  224818:	48 8d 44 24 07       	lea    rax,[rsp+0x7]
  22481d:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  224822:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  224829:	00 00 
            return self.readFn(self, buffer);
  22482b:	48 8d 7c 24 38       	lea    rdi,[rsp+0x38]
  224830:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
  224835:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  22483a:	ff 54 24 30          	call   QWORD PTR [rsp+0x30]
  22483e:	0f b7 44 24 38       	movzx  eax,WORD PTR [rsp+0x38]
            const amt_read = try self.read(buf);
  224843:	66 85 c0             	test   ax,ax
  224846:	0f 85 9d 00 00 00    	jne    2248e9 <Elf_findSection+0x189>
  22484c:	48 8b 44 24 40       	mov    rax,QWORD PTR [rsp+0x40]
            if (amt_read < buf.len) return error.EndOfStream;
  224851:	48 3b 44 24 18       	cmp    rax,QWORD PTR [rsp+0x18]
  224856:	0f 82 89 00 00 00    	jb     2248e5 <Elf_findSection+0x185>
            return result[0];
  22485c:	0f b6 44 24 07       	movzx  eax,BYTE PTR [rsp+0x7]
                const target_c = try in.readByte();
                if (target_c == 0 or expected_c != target_c) continue :section_loop;
  224861:	84 c0                	test   al,al
  224863:	74 5d                	je     2248c2 <Elf_findSection+0x162>
  224865:	41 38 c7             	cmp    r15b,al
  224868:	75 58                	jne    2248c2 <Elf_findSection+0x162>
  22486a:	48 83 c5 01          	add    rbp,0x1
            for (name) |expected_c| {
  22486e:	4c 39 ed             	cmp    rbp,r13
  224871:	72 9d                	jb     224810 <Elf_findSection+0xb0>
            try self.readNoEof(result[0..]);
  224873:	48 8d 44 24 07       	lea    rax,[rsp+0x7]
  224878:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  22487d:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  224884:	00 00 
            return self.readFn(self, buffer);
  224886:	48 8d 7c 24 38       	lea    rdi,[rsp+0x38]
  22488b:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
  224890:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  224895:	ff 54 24 30          	call   QWORD PTR [rsp+0x30]
  224899:	0f b7 44 24 38       	movzx  eax,WORD PTR [rsp+0x38]
            const amt_read = try self.read(buf);
  22489e:	66 85 c0             	test   ax,ax
  2248a1:	0f 85 b7 00 00 00    	jne    22495e <Elf_findSection+0x1fe>
  2248a7:	48 8b 44 24 40       	mov    rax,QWORD PTR [rsp+0x40]
            if (amt_read < buf.len) return error.EndOfStream;
  2248ac:	48 3b 44 24 18       	cmp    rax,QWORD PTR [rsp+0x18]
  2248b1:	0f 82 a3 00 00 00    	jb     22495a <Elf_findSection+0x1fa>
            }

            {
                const null_byte = try in.readByte();
                if (null_byte == 0) return elf_section;
  2248b7:	80 7c 24 07 00       	cmp    BYTE PTR [rsp+0x7],0x0
  2248bc:	0f 84 b0 00 00 00    	je     224972 <Elf_findSection+0x212>
        section_loop: for (elf.section_headers) |*elf_section| {
  2248c2:	49 83 c4 01          	add    r12,0x1
  2248c6:	4c 3b 64 24 50       	cmp    r12,QWORD PTR [rsp+0x50]
  2248cb:	48 8b 74 24 20       	mov    rsi,QWORD PTR [rsp+0x20]
  2248d0:	0f 82 d1 fe ff ff    	jb     2247a7 <Elf_findSection+0x47>
            }
        }

        return null;
  2248d6:	c5 f8 57 c0          	vxorps xmm0,xmm0,xmm0
  2248da:	48 8b 44 24 08       	mov    rax,QWORD PTR [rsp+0x8]
  2248df:	c5 f8 11 00          	vmovups XMMWORD PTR [rax],xmm0
  2248e3:	eb 1e                	jmp    224903 <Elf_findSection+0x1a3>
  2248e5:	66 b8 25 00          	mov    ax,0x25
  2248e9:	48 8b 54 24 08       	mov    rdx,QWORD PTR [rsp+0x8]
                const target_c = try in.readByte();
  2248ee:	66 89 02             	mov    WORD PTR [rdx],ax
  2248f1:	48 8b 44 24 6c       	mov    rax,QWORD PTR [rsp+0x6c]
  2248f6:	48 8b 4c 24 72       	mov    rcx,QWORD PTR [rsp+0x72]
  2248fb:	48 89 4a 08          	mov    QWORD PTR [rdx+0x8],rcx
  2248ff:	48 89 42 02          	mov    QWORD PTR [rdx+0x2],rax
  224903:	48 81 c4 88 00 00 00 	add    rsp,0x88
  22490a:	5b                   	pop    rbx
  22490b:	41 5c                	pop    r12
  22490d:	41 5d                	pop    r13
  22490f:	41 5e                	pop    r14
  224911:	41 5f                	pop    r15
  224913:	5d                   	pop    rbp
  224914:	c3                   	ret    
  224915:	66 b8 04 00          	mov    ax,0x4
  224919:	eb 28                	jmp    224943 <Elf_findSection+0x1e3>
  22491b:	48 8d 41 ea          	lea    rax,[rcx-0x16]
  22491f:	48 83 f8 35          	cmp    rax,0x35
  224923:	77 10                	ja     224935 <Elf_findSection+0x1d5>
  224925:	48 ba 81 00 00 00 00 	movabs rdx,0x20000000000081
  22492c:	00 20 00 
  22492f:	48 0f a3 c2          	bt     rdx,rax
  224933:	72 0a                	jb     22493f <Elf_findSection+0x1df>
  224935:	66 b8 03 00          	mov    ax,0x3
  224939:	48 83 f9 06          	cmp    rcx,0x6
  22493d:	75 04                	jne    224943 <Elf_findSection+0x1e3>
  22493f:	66 b8 27 00          	mov    ax,0x27
  224943:	48 8b 54 24 08       	mov    rdx,QWORD PTR [rsp+0x8]
            try elf.in_file.seekTo(name_offset);
  224948:	66 89 02             	mov    WORD PTR [rdx],ax
  22494b:	48 8b 44 24 7a       	mov    rax,QWORD PTR [rsp+0x7a]
  224950:	48 8b 8c 24 80 00 00 	mov    rcx,QWORD PTR [rsp+0x80]
  224957:	00 
  224958:	eb a1                	jmp    2248fb <Elf_findSection+0x19b>
  22495a:	66 b8 25 00          	mov    ax,0x25
  22495e:	48 8b 54 24 08       	mov    rdx,QWORD PTR [rsp+0x8]
                const null_byte = try in.readByte();
  224963:	66 89 02             	mov    WORD PTR [rdx],ax
  224966:	48 8b 44 24 5e       	mov    rax,QWORD PTR [rsp+0x5e]
  22496b:	48 8b 4c 24 64       	mov    rcx,QWORD PTR [rsp+0x64]
  224970:	eb 89                	jmp    2248fb <Elf_findSection+0x19b>
  224972:	48 8b 4c 24 08       	mov    rcx,QWORD PTR [rsp+0x8]
                if (null_byte == 0) return elf_section;
  224977:	66 c7 01 00 00       	mov    WORD PTR [rcx],0x0
  22497c:	0f b7 44 24 4e       	movzx  eax,WORD PTR [rsp+0x4e]
  224981:	66 89 41 06          	mov    WORD PTR [rcx+0x6],ax
  224985:	8b 44 24 4a          	mov    eax,DWORD PTR [rsp+0x4a]
  224989:	89 41 02             	mov    DWORD PTR [rcx+0x2],eax
  22498c:	4c 89 71 08          	mov    QWORD PTR [rcx+0x8],r14
  224990:	e9 6e ff ff ff       	jmp    224903 <Elf_findSection+0x1a3>
  224995:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  22499c:	00 00 00 00 

00000000002249a0 <File_openReadC>:
    pub fn openReadC(path: [*]const u8) OpenError!File {
  2249a0:	49 89 f1             	mov    r9,rsi
  2249a3:	49 89 f8             	mov    r8,rdi
  2249a6:	45 31 d2             	xor    r10d,r10d
  2249a9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  2249b0:	b8 02 00 00 00       	mov    eax,0x2
  2249b5:	be 00 00 00 00       	mov    esi,0x0
  2249ba:	31 d2                	xor    edx,edx
  2249bc:	4c 89 cf             	mov    rdi,r9
  2249bf:	0f 05                	syscall 
  2249c1:	48 89 c1             	mov    rcx,rax
  2249c4:	48 f7 d9             	neg    rcx
  2249c7:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  2249cd:	49 0f 46 ca          	cmovbe rcx,r10
        if (err > 0) {
  2249d1:	48 83 f9 04          	cmp    rcx,0x4
  2249d5:	74 d9                	je     2249b0 <File_openReadC+0x10>
  2249d7:	48 83 f9 4b          	cmp    rcx,0x4b
  2249db:	77 2d                	ja     224a0a <File_openReadC+0x6a>
  2249dd:	48 8d 15 04 be fd ff 	lea    rdx,[rip+0xfffffffffffdbe04]        # 2007e8 <__unnamed_609+0x4a8>
  2249e4:	48 63 0c 8a          	movsxd rcx,DWORD PTR [rdx+rcx*4]
  2249e8:	48 01 d1             	add    rcx,rdx
  2249eb:	ff e1                	jmp    rcx
  2249ed:	66 b8 16 00          	mov    ax,0x16
  2249f1:	eb 57                	jmp    224a4a <File_openReadC+0xaa>
  2249f3:	66 b8 13 00          	mov    ax,0x13
  2249f7:	eb 51                	jmp    224a4a <File_openReadC+0xaa>
            return openHandle(fd);
  2249f9:	66 41 c7 00 00 00    	mov    WORD PTR [r8],0x0
  2249ff:	41 89 40 04          	mov    DWORD PTR [r8+0x4],eax
  224a03:	c3                   	ret    
  224a04:	66 b8 1a 00          	mov    ax,0x1a
  224a08:	eb 40                	jmp    224a4a <File_openReadC+0xaa>
  224a0a:	66 b8 03 00          	mov    ax,0x3
  224a0e:	eb 3a                	jmp    224a4a <File_openReadC+0xaa>
  224a10:	66 b8 0c 00          	mov    ax,0xc
  224a14:	eb 34                	jmp    224a4a <File_openReadC+0xaa>
  224a16:	66 b8 19 00          	mov    ax,0x19
  224a1a:	eb 2e                	jmp    224a4a <File_openReadC+0xaa>
  224a1c:	66 b8 23 00          	mov    ax,0x23
  224a20:	eb 28                	jmp    224a4a <File_openReadC+0xaa>
  224a22:	66 b8 24 00          	mov    ax,0x24
  224a26:	eb 22                	jmp    224a4a <File_openReadC+0xaa>
  224a28:	66 b8 1f 00          	mov    ax,0x1f
  224a2c:	eb 1c                	jmp    224a4a <File_openReadC+0xaa>
  224a2e:	66 b8 22 00          	mov    ax,0x22
  224a32:	eb 16                	jmp    224a4a <File_openReadC+0xaa>
  224a34:	66 b8 21 00          	mov    ax,0x21
  224a38:	eb 10                	jmp    224a4a <File_openReadC+0xaa>
  224a3a:	66 b8 15 00          	mov    ax,0x15
  224a3e:	eb 0a                	jmp    224a4a <File_openReadC+0xaa>
  224a40:	66 b8 1c 00          	mov    ax,0x1c
  224a44:	eb 04                	jmp    224a4a <File_openReadC+0xaa>
  224a46:	66 b8 20 00          	mov    ax,0x20
            const fd = try os.posixOpenC(path, flags, 0);
  224a4a:	66 41 89 00          	mov    WORD PTR [r8],ax
  224a4e:	0f b7 44 24 fe       	movzx  eax,WORD PTR [rsp-0x2]
  224a53:	66 41 89 40 06       	mov    WORD PTR [r8+0x6],ax
  224a58:	8b 44 24 fa          	mov    eax,DWORD PTR [rsp-0x6]
  224a5c:	41 89 40 02          	mov    DWORD PTR [r8+0x2],eax
  224a60:	c3                   	ret    
  224a61:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  224a68:	0f 1f 84 00 00 00 00 
  224a6f:	00 

0000000000224a70 <InStream(ReadError)_readInt.147>:
        pub fn readInt(self: *Self, endian: builtin.Endian, comptime T: type) !T {
  224a70:	55                   	push   rbp
  224a71:	53                   	push   rbx
  224a72:	48 83 ec 48          	sub    rsp,0x48
  224a76:	89 d5                	mov    ebp,edx
  224a78:	48 89 fb             	mov    rbx,rdi
  224a7b:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
            try self.readNoEof(bytes[0..]);
  224a80:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  224a85:	48 c7 44 24 20 08 00 	mov    QWORD PTR [rsp+0x20],0x8
  224a8c:	00 00 
  224a8e:	48 8d 7c 24 28       	lea    rdi,[rsp+0x28]
  224a93:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  224a98:	ff 16                	call   QWORD PTR [rsi]
  224a9a:	0f b7 44 24 28       	movzx  eax,WORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  224a9f:	66 85 c0             	test   ax,ax
  224aa2:	75 10                	jne    224ab4 <InStream(ReadError)_readInt.147+0x44>
  224aa4:	48 8b 4c 24 30       	mov    rcx,QWORD PTR [rsp+0x30]
  224aa9:	66 b8 25 00          	mov    ax,0x25
            if (amt_read < buf.len) return error.EndOfStream;
  224aad:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  224ab2:	73 1c                	jae    224ad0 <InStream(ReadError)_readInt.147+0x60>
            try self.readNoEof(bytes[0..]);
  224ab4:	66 89 03             	mov    WORD PTR [rbx],ax
  224ab7:	48 8b 44 24 3a       	mov    rax,QWORD PTR [rsp+0x3a]
  224abc:	48 8b 4c 24 40       	mov    rcx,QWORD PTR [rsp+0x40]
  224ac1:	48 89 4b 08          	mov    QWORD PTR [rbx+0x8],rcx
  224ac5:	48 89 43 02          	mov    QWORD PTR [rbx+0x2],rax
  224ac9:	48 83 c4 48          	add    rsp,0x48
  224acd:	5b                   	pop    rbx
  224ace:	5d                   	pop    rbp
  224acf:	c3                   	ret    
  224ad0:	0f b6 44 24 08       	movzx  eax,BYTE PTR [rsp+0x8]
  224ad5:	0f b6 4c 24 09       	movzx  ecx,BYTE PTR [rsp+0x9]
    switch (endian) {
  224ada:	40 f6 c5 01          	test   bpl,0x1
  224ade:	74 51                	je     224b31 <InStream(ReadError)_readInt.147+0xc1>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  224ae0:	48 c1 e1 08          	shl    rcx,0x8
  224ae4:	48 09 c1             	or     rcx,rax
  224ae7:	0f b6 44 24 0a       	movzx  eax,BYTE PTR [rsp+0xa]
  224aec:	48 c1 e0 10          	shl    rax,0x10
  224af0:	48 09 c8             	or     rax,rcx
  224af3:	0f b6 4c 24 0b       	movzx  ecx,BYTE PTR [rsp+0xb]
  224af8:	48 c1 e1 18          	shl    rcx,0x18
  224afc:	48 09 c1             	or     rcx,rax
  224aff:	0f b6 44 24 0c       	movzx  eax,BYTE PTR [rsp+0xc]
  224b04:	48 c1 e0 20          	shl    rax,0x20
  224b08:	48 09 c8             	or     rax,rcx
  224b0b:	0f b6 4c 24 0d       	movzx  ecx,BYTE PTR [rsp+0xd]
  224b10:	48 c1 e1 28          	shl    rcx,0x28
  224b14:	48 09 c1             	or     rcx,rax
  224b17:	0f b6 54 24 0e       	movzx  edx,BYTE PTR [rsp+0xe]
  224b1c:	48 c1 e2 30          	shl    rdx,0x30
  224b20:	0f b6 44 24 0f       	movzx  eax,BYTE PTR [rsp+0xf]
  224b25:	48 c1 e0 38          	shl    rax,0x38
  224b29:	48 09 d0             	or     rax,rdx
  224b2c:	48 09 c8             	or     rax,rcx
  224b2f:	eb 4f                	jmp    224b80 <InStream(ReadError)_readInt.147+0x110>
                result = (result << 8) | b;
  224b31:	48 c1 e0 08          	shl    rax,0x8
  224b35:	48 09 c8             	or     rax,rcx
  224b38:	48 c1 e0 08          	shl    rax,0x8
  224b3c:	0f b6 4c 24 0a       	movzx  ecx,BYTE PTR [rsp+0xa]
  224b41:	48 09 c1             	or     rcx,rax
  224b44:	48 c1 e1 08          	shl    rcx,0x8
  224b48:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  224b4d:	48 09 c8             	or     rax,rcx
  224b50:	48 c1 e0 08          	shl    rax,0x8
  224b54:	0f b6 4c 24 0c       	movzx  ecx,BYTE PTR [rsp+0xc]
  224b59:	48 09 c1             	or     rcx,rax
  224b5c:	48 c1 e1 08          	shl    rcx,0x8
  224b60:	0f b6 44 24 0d       	movzx  eax,BYTE PTR [rsp+0xd]
  224b65:	48 09 c8             	or     rax,rcx
  224b68:	48 c1 e0 08          	shl    rax,0x8
  224b6c:	0f b6 4c 24 0e       	movzx  ecx,BYTE PTR [rsp+0xe]
  224b71:	48 09 c1             	or     rcx,rax
  224b74:	48 c1 e1 08          	shl    rcx,0x8
  224b78:	0f b6 44 24 0f       	movzx  eax,BYTE PTR [rsp+0xf]
  224b7d:	48 09 c8             	or     rax,rcx
            return mem.readInt(bytes, T, endian);
  224b80:	66 c7 03 00 00       	mov    WORD PTR [rbx],0x0
  224b85:	0f b7 4c 24 16       	movzx  ecx,WORD PTR [rsp+0x16]
  224b8a:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  224b8e:	8b 4c 24 12          	mov    ecx,DWORD PTR [rsp+0x12]
  224b92:	89 4b 02             	mov    DWORD PTR [rbx+0x2],ecx
  224b95:	48 89 43 08          	mov    QWORD PTR [rbx+0x8],rax
  224b99:	48 83 c4 48          	add    rsp,0x48
  224b9d:	5b                   	pop    rbx
  224b9e:	5d                   	pop    rbp
  224b9f:	c3                   	ret    

0000000000224ba0 <File_read>:
        SystemResources,

        Unexpected,
    };

    pub fn read(self: *File, buffer: []u8) ReadError!usize {
  224ba0:	41 57                	push   r15
  224ba2:	41 56                	push   r14
  224ba4:	53                   	push   rbx
  224ba5:	49 89 d1             	mov    r9,rdx
  224ba8:	49 89 f2             	mov    r10,rsi
  224bab:	49 89 f8             	mov    r8,rdi
        if (is_posix) {
            var index: usize = 0;
            while (index < buffer.len) {
  224bae:	49 8b 51 08          	mov    rdx,QWORD PTR [r9+0x8]
  224bb2:	48 85 d2             	test   rdx,rdx
  224bb5:	74 70                	je     224c27 <File_read+0x87>
  224bb7:	45 31 f6             	xor    r14d,r14d
  224bba:	4c 8d 3d 57 bd fd ff 	lea    r15,[rip+0xfffffffffffdbd57]        # 200918 <__unnamed_609+0x5d8>
  224bc1:	31 db                	xor    ebx,ebx
  224bc3:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  224bca:	84 00 00 00 00 00 
  224bd0:	49 8b 31             	mov    rsi,QWORD PTR [r9]
                const amt_read = posix.read(self.handle, buffer.ptr + index, buffer.len - index);
  224bd3:	48 01 de             	add    rsi,rbx
  224bd6:	48 29 da             	sub    rdx,rbx
    return syscall3(SYS_read, @intCast(usize, fd), @ptrToInt(buf), count);
  224bd9:	49 63 3a             	movsxd rdi,DWORD PTR [r10]
  224bdc:	31 c0                	xor    eax,eax
  224bde:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  224be0:	48 89 c1             	mov    rcx,rax
  224be3:	48 f7 d9             	neg    rcx
  224be6:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  224bec:	49 0f 46 ce          	cmovbe rcx,r14
                const read_err = posix.getErrno(amt_read);
                if (read_err > 0) {
  224bf0:	48 83 f9 04          	cmp    rcx,0x4
  224bf4:	75 0b                	jne    224c01 <File_read+0x61>
            while (index < buffer.len) {
  224bf6:	49 8b 51 08          	mov    rdx,QWORD PTR [r9+0x8]
  224bfa:	48 39 da             	cmp    rdx,rbx
  224bfd:	77 d1                	ja     224bd0 <File_read+0x30>
  224bff:	eb 28                	jmp    224c29 <File_read+0x89>
  224c01:	48 83 f9 15          	cmp    rcx,0x15
  224c05:	77 44                	ja     224c4b <File_read+0xab>
  224c07:	49 63 0c 8f          	movsxd rcx,DWORD PTR [r15+rcx*4]
  224c0b:	4c 01 f9             	add    rcx,r15
  224c0e:	ff e1                	jmp    rcx
                        posix.ENOBUFS => return error.SystemResources,
                        posix.ENOMEM => return error.SystemResources,
                        else => return os.unexpectedErrorPosix(read_err),
                    }
                }
                if (amt_read == 0) return index;
  224c10:	48 85 c0             	test   rax,rax
  224c13:	0f 84 91 00 00 00    	je     224caa <File_read+0x10a>
  224c19:	48 01 c3             	add    rbx,rax
            while (index < buffer.len) {
  224c1c:	49 8b 51 08          	mov    rdx,QWORD PTR [r9+0x8]
  224c20:	48 39 da             	cmp    rdx,rbx
  224c23:	77 ab                	ja     224bd0 <File_read+0x30>
  224c25:	eb 02                	jmp    224c29 <File_read+0x89>
  224c27:	31 db                	xor    ebx,ebx
                index += amt_read;
            }
            return index;
  224c29:	66 41 c7 00 00 00    	mov    WORD PTR [r8],0x0
  224c2f:	0f b7 44 24 ea       	movzx  eax,WORD PTR [rsp-0x16]
  224c34:	66 41 89 40 06       	mov    WORD PTR [r8+0x6],ax
  224c39:	8b 44 24 e6          	mov    eax,DWORD PTR [rsp-0x1a]
  224c3d:	41 89 40 02          	mov    DWORD PTR [r8+0x2],eax
  224c41:	49 89 58 08          	mov    QWORD PTR [r8+0x8],rbx
  224c45:	5b                   	pop    rbx
  224c46:	41 5e                	pop    r14
  224c48:	41 5f                	pop    r15
  224c4a:	c3                   	ret    
                if (read_err > 0) {
  224c4b:	48 83 f9 69          	cmp    rcx,0x69
  224c4f:	75 0a                	jne    224c5b <File_read+0xbb>
  224c51:	c5 f8 10 05 87 49 fe 	vmovups xmm0,XMMWORD PTR [rip+0xfffffffffffe4987]        # 2095e0 <__unnamed_66>
  224c58:	ff 
  224c59:	eb 44                	jmp    224c9f <File_read+0xff>
                        else => return os.unexpectedErrorPosix(read_err),
  224c5b:	66 41 c7 00 03 00    	mov    WORD PTR [r8],0x3
  224c61:	48 8b 44 24 f2       	mov    rax,QWORD PTR [rsp-0xe]
  224c66:	48 8b 4c 24 f8       	mov    rcx,QWORD PTR [rsp-0x8]
  224c6b:	49 89 48 08          	mov    QWORD PTR [r8+0x8],rcx
  224c6f:	49 89 40 02          	mov    QWORD PTR [r8+0x2],rax
  224c73:	5b                   	pop    rbx
  224c74:	41 5e                	pop    r14
  224c76:	41 5f                	pop    r15
  224c78:	c3                   	ret    
                        posix.EIO => return error.InputOutput,
  224c79:	c5 f8 10 05 cf 49 fe 	vmovups xmm0,XMMWORD PTR [rip+0xfffffffffffe49cf]        # 209650 <__unnamed_67>
  224c80:	ff 
  224c81:	eb 1c                	jmp    224c9f <File_read+0xff>
                        posix.EBADF => return error.FileClosed,
  224c83:	c5 f8 10 05 05 44 fe 	vmovups xmm0,XMMWORD PTR [rip+0xfffffffffffe4405]        # 209090 <__unnamed_68>
  224c8a:	ff 
  224c8b:	eb 12                	jmp    224c9f <File_read+0xff>
                        posix.EAGAIN => return error.WouldBlock,
  224c8d:	c5 f8 10 05 ab 44 fe 	vmovups xmm0,XMMWORD PTR [rip+0xfffffffffffe44ab]        # 209140 <__unnamed_69>
  224c94:	ff 
  224c95:	eb 08                	jmp    224c9f <File_read+0xff>
                        posix.EISDIR => return error.IsDir,
  224c97:	c5 f8 10 05 41 45 fe 	vmovups xmm0,XMMWORD PTR [rip+0xfffffffffffe4541]        # 2091e0 <__unnamed_70>
  224c9e:	ff 
  224c9f:	c4 c1 78 11 00       	vmovups XMMWORD PTR [r8],xmm0
  224ca4:	5b                   	pop    rbx
  224ca5:	41 5e                	pop    r14
  224ca7:	41 5f                	pop    r15
  224ca9:	c3                   	ret    
                if (amt_read == 0) return index;
  224caa:	66 41 c7 00 00 00    	mov    WORD PTR [r8],0x0
  224cb0:	0f b7 44 24 f0       	movzx  eax,WORD PTR [rsp-0x10]
  224cb5:	66 41 89 40 06       	mov    WORD PTR [r8+0x6],ax
  224cba:	8b 44 24 ec          	mov    eax,DWORD PTR [rsp-0x14]
  224cbe:	e9 7a ff ff ff       	jmp    224c3d <File_read+0x9d>
  224cc3:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  224cca:	84 00 00 00 00 00 

0000000000224cd0 <FileInStream_readFn>:
    fn readFn(in_stream: *Stream, buffer: []u8) Error!usize {
  224cd0:	53                   	push   rbx
  224cd1:	48 83 ec 10          	sub    rsp,0x10
  224cd5:	48 89 fb             	mov    rbx,rdi
        return self.file.read(buffer);
  224cd8:	48 8b 76 f8          	mov    rsi,QWORD PTR [rsi-0x8]
  224cdc:	48 89 e7             	mov    rdi,rsp
  224cdf:	e8 bc fe ff ff       	call   224ba0 <File_read>
  224ce4:	c5 f8 10 04 24       	vmovups xmm0,XMMWORD PTR [rsp]
  224ce9:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  224ced:	48 89 d8             	mov    rax,rbx
  224cf0:	48 83 c4 10          	add    rsp,0x10
  224cf4:	5b                   	pop    rbx
  224cf5:	c3                   	ret    
  224cf6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  224cfd:	00 00 00 

0000000000224d00 <Allocator_alignedRealloc.155>:
    pub fn alignedRealloc(self: *Allocator, comptime T: type, comptime alignment: u29, old_mem: []align(alignment) T, n: usize) ![]align(alignment) T {
  224d00:	41 56                	push   r14
  224d02:	53                   	push   rbx
  224d03:	48 81 ec 88 00 00 00 	sub    rsp,0x88
  224d0a:	48 89 fb             	mov    rbx,rdi
        if (old_mem.len == 0) {
  224d0d:	48 8b 42 08          	mov    rax,QWORD PTR [rdx+0x8]
  224d11:	48 85 c0             	test   rax,rax
  224d14:	74 54                	je     224d6a <Allocator_alignedRealloc.155+0x6a>
        if (n == 0) {
  224d16:	48 85 c9             	test   rcx,rcx
  224d19:	0f 84 9b 00 00 00    	je     224dba <Allocator_alignedRealloc.155+0xba>
        const old_byte_slice = @sliceToBytes(old_mem);
  224d1f:	48 8b 12             	mov    rdx,QWORD PTR [rdx]
  224d22:	48 6b c0 38          	imul   rax,rax,0x38
  224d26:	48 89 54 24 38       	mov    QWORD PTR [rsp+0x38],rdx
  224d2b:	48 89 44 24 40       	mov    QWORD PTR [rsp+0x40],rax
  224d30:	ba 38 00 00 00       	mov    edx,0x38
    return if (@mulWithOverflow(T, a, b, &answer)) error.Overflow else answer;
  224d35:	48 89 c8             	mov    rax,rcx
  224d38:	48 f7 e2             	mul    rdx
  224d3b:	0f 81 c2 00 00 00    	jno    224e03 <Allocator_alignedRealloc.155+0x103>
  224d41:	48 8d 0d 38 42 fe ff 	lea    rcx,[rip+0xfffffffffffe4238]        # 208f80 <__unnamed_43>
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  224d48:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  224d4c:	0f 84 cc 00 00 00    	je     224e1e <Allocator_alignedRealloc.155+0x11e>
  224d52:	48 8b 05 8f 2a fe ff 	mov    rax,QWORD PTR [rip+0xfffffffffffe2a8f]        # 2077e8 <__unnamed_71+0x10>
  224d59:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  224d5d:	c5 f8 10 05 73 2a fe 	vmovups xmm0,XMMWORD PTR [rip+0xfffffffffffe2a73]        # 2077d8 <__unnamed_71>
  224d64:	ff 
  224d65:	e9 8a 00 00 00       	jmp    224df4 <Allocator_alignedRealloc.155+0xf4>
        if (n == 0) {
  224d6a:	48 85 c9             	test   rcx,rcx
  224d6d:	0f 84 f8 00 00 00    	je     224e6b <Allocator_alignedRealloc.155+0x16b>
  224d73:	ba 38 00 00 00       	mov    edx,0x38
  224d78:	48 89 c8             	mov    rax,rcx
  224d7b:	48 f7 e2             	mul    rdx
  224d7e:	0f 81 08 01 00 00    	jno    224e8c <Allocator_alignedRealloc.155+0x18c>
  224d84:	48 8d 0d f5 41 fe ff 	lea    rcx,[rip+0xfffffffffffe41f5]        # 208f80 <__unnamed_43>
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  224d8b:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  224d8f:	0f 84 12 01 00 00    	je     224ea7 <Allocator_alignedRealloc.155+0x1a7>
  224d95:	0f b7 05 42 2a fe ff 	movzx  eax,WORD PTR [rip+0xfffffffffffe2a42]        # 2077de <__unnamed_71+0x6>
  224d9c:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  224da1:	8b 05 33 2a fe ff    	mov    eax,DWORD PTR [rip+0xfffffffffffe2a33]        # 2077da <__unnamed_71+0x2>
  224da7:	89 04 24             	mov    DWORD PTR [rsp],eax
  224daa:	48 89 e0             	mov    rax,rsp
  224dad:	66 b9 01 00          	mov    cx,0x1
  224db1:	31 f6                	xor    esi,esi
  224db3:	31 d2                	xor    edx,edx
  224db5:	e9 a9 01 00 00       	jmp    224f63 <Allocator_alignedRealloc.155+0x263>
        const bytes = @sliceToBytes(memory);
  224dba:	48 6b c0 38          	imul   rax,rax,0x38
        if (bytes.len == 0) return;
  224dbe:	48 85 c0             	test   rax,rax
  224dc1:	74 1e                	je     224de1 <Allocator_alignedRealloc.155+0xe1>
        const bytes = @sliceToBytes(memory);
  224dc3:	48 8b 0a             	mov    rcx,QWORD PTR [rdx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  224dc6:	48 8b 56 10          	mov    rdx,QWORD PTR [rsi+0x10]
  224dca:	48 89 4c 24 08       	mov    QWORD PTR [rsp+0x8],rcx
  224dcf:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  224dd4:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  224dd9:	48 89 f7             	mov    rdi,rsi
  224ddc:	48 89 c6             	mov    rsi,rax
  224ddf:	ff d2                	call   rdx
            return ([*]align(alignment) T)(undefined)[0..0];
  224de1:	48 8b 05 e8 29 fe ff 	mov    rax,QWORD PTR [rip+0xfffffffffffe29e8]        # 2077d0 <__unnamed_72+0x10>
  224de8:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  224dec:	c5 f8 10 05 cc 29 fe 	vmovups xmm0,XMMWORD PTR [rip+0xfffffffffffe29cc]        # 2077c0 <__unnamed_72>
  224df3:	ff 
  224df4:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  224df8:	48 81 c4 88 00 00 00 	add    rsp,0x88
  224dff:	5b                   	pop    rbx
  224e00:	41 5e                	pop    r14
  224e02:	c3                   	ret    
  224e03:	48 8d 4c 24 08       	lea    rcx,[rsp+0x8]
  224e08:	66 c7 44 24 08 00 00 	mov    WORD PTR [rsp+0x8],0x0
  224e0f:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  224e14:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  224e18:	0f 85 34 ff ff ff    	jne    224d52 <Allocator_alignedRealloc.155+0x52>
  224e1e:	4c 8b 71 08          	mov    r14,QWORD PTR [rcx+0x8]
  224e22:	48 8d 7c 24 58       	lea    rdi,[rsp+0x58]
  224e27:	48 8d 54 24 38       	lea    rdx,[rsp+0x38]
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  224e2c:	41 b8 01 00 00 00    	mov    r8d,0x1
  224e32:	4c 89 f1             	mov    rcx,r14
  224e35:	ff 56 08             	call   QWORD PTR [rsi+0x8]
  224e38:	0f b7 44 24 58       	movzx  eax,WORD PTR [rsp+0x58]
  224e3d:	66 85 c0             	test   ax,ax
  224e40:	0f 84 97 00 00 00    	je     224edd <Allocator_alignedRealloc.155+0x1dd>
  224e46:	66 89 03             	mov    WORD PTR [rbx],ax
  224e49:	48 8b 84 24 80 00 00 	mov    rax,QWORD PTR [rsp+0x80]
  224e50:	00 
  224e51:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  224e55:	c5 f8 10 44 24 72    	vmovups xmm0,XMMWORD PTR [rsp+0x72]
  224e5b:	c5 f8 11 43 02       	vmovups XMMWORD PTR [rbx+0x2],xmm0
  224e60:	48 81 c4 88 00 00 00 	add    rsp,0x88
  224e67:	5b                   	pop    rbx
  224e68:	41 5e                	pop    r14
  224e6a:	c3                   	ret    
  224e6b:	48 89 e0             	mov    rax,rsp
            return ([*]align(alignment) T)(undefined)[0..0];
  224e6e:	0f b7 0d 51 29 fe ff 	movzx  ecx,WORD PTR [rip+0xfffffffffffe2951]        # 2077c6 <__unnamed_72+0x6>
  224e75:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  224e7a:	8b 0d 42 29 fe ff    	mov    ecx,DWORD PTR [rip+0xfffffffffffe2942]        # 2077c2 <__unnamed_72+0x2>
  224e80:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  224e83:	31 c9                	xor    ecx,ecx
  224e85:	31 d2                	xor    edx,edx
  224e87:	e9 d7 00 00 00       	jmp    224f63 <Allocator_alignedRealloc.155+0x263>
  224e8c:	48 8d 4c 24 48       	lea    rcx,[rsp+0x48]
  224e91:	66 c7 44 24 48 00 00 	mov    WORD PTR [rsp+0x48],0x0
  224e98:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  224e9d:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  224ea1:	0f 85 ee fe ff ff    	jne    224d95 <Allocator_alignedRealloc.155+0x95>
  224ea7:	4c 8b 71 08          	mov    r14,QWORD PTR [rcx+0x8]
  224eab:	48 8d 7c 24 08       	lea    rdi,[rsp+0x8]
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  224eb0:	b9 01 00 00 00       	mov    ecx,0x1
  224eb5:	4c 89 f2             	mov    rdx,r14
  224eb8:	ff 16                	call   QWORD PTR [rsi]
  224eba:	0f b7 4c 24 08       	movzx  ecx,WORD PTR [rsp+0x8]
  224ebf:	66 85 c9             	test   cx,cx
  224ec2:	74 67                	je     224f2b <Allocator_alignedRealloc.155+0x22b>
  224ec4:	0f b7 44 24 36       	movzx  eax,WORD PTR [rsp+0x36]
  224ec9:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  224ece:	48 89 e0             	mov    rax,rsp
  224ed1:	8b 54 24 32          	mov    edx,DWORD PTR [rsp+0x32]
  224ed5:	89 14 24             	mov    DWORD PTR [rsp],edx
  224ed8:	e9 86 00 00 00       	jmp    224f63 <Allocator_alignedRealloc.155+0x263>
        assert(byte_slice.len == byte_count);
  224edd:	4c 39 74 24 68       	cmp    QWORD PTR [rsp+0x68],r14
    if (!ok) {
  224ee2:	0f 85 9e 00 00 00    	jne    224f86 <Allocator_alignedRealloc.155+0x286>
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  224ee8:	49 c1 ee 03          	shr    r14,0x3
  224eec:	48 b8 93 24 49 92 24 	movabs rax,0x2492492492492493
  224ef3:	49 92 24 
  224ef6:	4c 89 f2             	mov    rdx,r14
  224ef9:	c4 e2 f3 f6 c0       	mulx   rax,rcx,rax
  224efe:	66 c7 03 00 00       	mov    WORD PTR [rbx],0x0
  224f03:	0f b7 4c 24 2a       	movzx  ecx,WORD PTR [rsp+0x2a]
  224f08:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  224f0c:	48 8b 4c 24 60       	mov    rcx,QWORD PTR [rsp+0x60]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  224f11:	8b 54 24 26          	mov    edx,DWORD PTR [rsp+0x26]
  224f15:	89 53 02             	mov    DWORD PTR [rbx+0x2],edx
  224f18:	48 89 4b 08          	mov    QWORD PTR [rbx+0x8],rcx
  224f1c:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  224f20:	48 81 c4 88 00 00 00 	add    rsp,0x88
  224f27:	5b                   	pop    rbx
  224f28:	41 5e                	pop    r14
  224f2a:	c3                   	ret    
        assert(byte_slice.len == byte_count);
  224f2b:	4c 39 74 24 18       	cmp    QWORD PTR [rsp+0x18],r14
  224f30:	75 54                	jne    224f86 <Allocator_alignedRealloc.155+0x286>
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  224f32:	48 8b 74 24 10       	mov    rsi,QWORD PTR [rsp+0x10]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  224f37:	49 c1 ee 03          	shr    r14,0x3
  224f3b:	48 b8 93 24 49 92 24 	movabs rax,0x2492492492492493
  224f42:	49 92 24 
  224f45:	4c 89 f2             	mov    rdx,r14
  224f48:	c4 e2 fb f6 d0       	mulx   rdx,rax,rax
  224f4d:	48 89 e0             	mov    rax,rsp
  224f50:	8b 4c 24 2c          	mov    ecx,DWORD PTR [rsp+0x2c]
  224f54:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  224f57:	0f b7 4c 24 30       	movzx  ecx,WORD PTR [rsp+0x30]
  224f5c:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  224f61:	31 c9                	xor    ecx,ecx
            return self.alignedAlloc(T, alignment, n);
  224f63:	66 89 0b             	mov    WORD PTR [rbx],cx
  224f66:	0f b7 48 04          	movzx  ecx,WORD PTR [rax+0x4]
  224f6a:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  224f6e:	8b 00                	mov    eax,DWORD PTR [rax]
  224f70:	89 43 02             	mov    DWORD PTR [rbx+0x2],eax
  224f73:	48 89 73 08          	mov    QWORD PTR [rbx+0x8],rsi
  224f77:	48 89 53 10          	mov    QWORD PTR [rbx+0x10],rdx
  224f7b:	48 81 c4 88 00 00 00 	add    rsp,0x88
  224f82:	5b                   	pop    rbx
  224f83:	41 5e                	pop    r14
  224f85:	c3                   	ret    
            @panic("assertion failure");
  224f86:	48 8d 3d 7b 9d 02 00 	lea    rdi,[rip+0x29d7b]        # 24ed08 <__unnamed_2>
  224f8d:	e8 8e d0 fe ff       	call   212020 <panic>
  224f92:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  224f99:	1f 84 00 00 00 00 00 

0000000000224fa0 <Allocator_alignedRealloc.158>:
    pub fn alignedRealloc(self: *Allocator, comptime T: type, comptime alignment: u29, old_mem: []align(alignment) T, n: usize) ![]align(alignment) T {
  224fa0:	41 56                	push   r14
  224fa2:	53                   	push   rbx
  224fa3:	48 81 ec 88 00 00 00 	sub    rsp,0x88
  224faa:	48 89 fb             	mov    rbx,rdi
        if (old_mem.len == 0) {
  224fad:	48 8b 42 08          	mov    rax,QWORD PTR [rdx+0x8]
  224fb1:	48 85 c0             	test   rax,rax
  224fb4:	74 5e                	je     225014 <Allocator_alignedRealloc.158+0x74>
        if (n == 0) {
  224fb6:	48 85 c9             	test   rcx,rcx
  224fb9:	0f 84 a6 00 00 00    	je     225065 <Allocator_alignedRealloc.158+0xc5>
        const old_byte_slice = @sliceToBytes(old_mem);
  224fbf:	48 8b 12             	mov    rdx,QWORD PTR [rdx]
  224fc2:	48 c1 e0 04          	shl    rax,0x4
  224fc6:	48 89 54 24 38       	mov    QWORD PTR [rsp+0x38],rdx
  224fcb:	48 89 44 24 40       	mov    QWORD PTR [rsp+0x40],rax
  224fd0:	ba 10 00 00 00       	mov    edx,0x10
  224fd5:	48 89 c8             	mov    rax,rcx
  224fd8:	48 f7 e2             	mul    rdx
  224fdb:	0f 81 ca 00 00 00    	jno    2250ab <Allocator_alignedRealloc.158+0x10b>
  224fe1:	48 8d 0d 98 3f fe ff 	lea    rcx,[rip+0xfffffffffffe3f98]        # 208f80 <__unnamed_43>
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  224fe8:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  224fec:	0f 84 d4 00 00 00    	je     2250c6 <Allocator_alignedRealloc.158+0x126>
  224ff2:	48 8b 05 1f 28 fe ff 	mov    rax,QWORD PTR [rip+0xfffffffffffe281f]        # 207818 <__unnamed_73+0x10>
  224ff9:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  224ffd:	c5 f8 10 05 03 28 fe 	vmovups xmm0,XMMWORD PTR [rip+0xfffffffffffe2803]        # 207808 <__unnamed_73>
  225004:	ff 
  225005:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  225009:	48 81 c4 88 00 00 00 	add    rsp,0x88
  225010:	5b                   	pop    rbx
  225011:	41 5e                	pop    r14
  225013:	c3                   	ret    
        if (n == 0) {
  225014:	48 85 c9             	test   rcx,rcx
  225017:	0f 84 f6 00 00 00    	je     225113 <Allocator_alignedRealloc.158+0x173>
  22501d:	ba 10 00 00 00       	mov    edx,0x10
  225022:	48 89 c8             	mov    rax,rcx
  225025:	48 f7 e2             	mul    rdx
  225028:	0f 81 07 01 00 00    	jno    225135 <Allocator_alignedRealloc.158+0x195>
  22502e:	48 8d 0d 4b 3f fe ff 	lea    rcx,[rip+0xfffffffffffe3f4b]        # 208f80 <__unnamed_43>
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  225035:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  225039:	0f 84 11 01 00 00    	je     225150 <Allocator_alignedRealloc.158+0x1b0>
  22503f:	0f b7 05 c8 27 fe ff 	movzx  eax,WORD PTR [rip+0xfffffffffffe27c8]        # 20780e <__unnamed_73+0x6>
  225046:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  22504b:	8b 05 b9 27 fe ff    	mov    eax,DWORD PTR [rip+0xfffffffffffe27b9]        # 20780a <__unnamed_73+0x2>
  225051:	89 04 24             	mov    DWORD PTR [rsp],eax
  225054:	48 89 e0             	mov    rax,rsp
  225057:	66 b9 01 00          	mov    cx,0x1
  22505b:	31 d2                	xor    edx,edx
  22505d:	45 31 f6             	xor    r14d,r14d
  225060:	e9 6f 01 00 00       	jmp    2251d4 <Allocator_alignedRealloc.158+0x234>
        const bytes = @sliceToBytes(memory);
  225065:	48 c1 e0 04          	shl    rax,0x4
        if (bytes.len == 0) return;
  225069:	74 1e                	je     225089 <Allocator_alignedRealloc.158+0xe9>
        const bytes = @sliceToBytes(memory);
  22506b:	48 8b 0a             	mov    rcx,QWORD PTR [rdx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  22506e:	48 8b 56 10          	mov    rdx,QWORD PTR [rsi+0x10]
  225072:	48 89 4c 24 08       	mov    QWORD PTR [rsp+0x8],rcx
  225077:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  22507c:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  225081:	48 89 f7             	mov    rdi,rsi
  225084:	48 89 c6             	mov    rsi,rax
  225087:	ff d2                	call   rdx
            return ([*]align(alignment) T)(undefined)[0..0];
  225089:	48 8b 05 70 27 fe ff 	mov    rax,QWORD PTR [rip+0xfffffffffffe2770]        # 207800 <__unnamed_74+0x10>
  225090:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  225094:	c5 f8 10 05 54 27 fe 	vmovups xmm0,XMMWORD PTR [rip+0xfffffffffffe2754]        # 2077f0 <__unnamed_74>
  22509b:	ff 
  22509c:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  2250a0:	48 81 c4 88 00 00 00 	add    rsp,0x88
  2250a7:	5b                   	pop    rbx
  2250a8:	41 5e                	pop    r14
  2250aa:	c3                   	ret    
  2250ab:	48 8d 4c 24 08       	lea    rcx,[rsp+0x8]
  2250b0:	66 c7 44 24 08 00 00 	mov    WORD PTR [rsp+0x8],0x0
  2250b7:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  2250bc:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  2250c0:	0f 85 2c ff ff ff    	jne    224ff2 <Allocator_alignedRealloc.158+0x52>
  2250c6:	4c 8b 71 08          	mov    r14,QWORD PTR [rcx+0x8]
  2250ca:	48 8d 7c 24 58       	lea    rdi,[rsp+0x58]
  2250cf:	48 8d 54 24 38       	lea    rdx,[rsp+0x38]
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  2250d4:	41 b8 08 00 00 00    	mov    r8d,0x8
  2250da:	4c 89 f1             	mov    rcx,r14
  2250dd:	ff 56 08             	call   QWORD PTR [rsi+0x8]
  2250e0:	0f b7 44 24 58       	movzx  eax,WORD PTR [rsp+0x58]
  2250e5:	66 85 c0             	test   ax,ax
  2250e8:	0f 84 95 00 00 00    	je     225183 <Allocator_alignedRealloc.158+0x1e3>
  2250ee:	66 89 03             	mov    WORD PTR [rbx],ax
  2250f1:	48 8b 84 24 80 00 00 	mov    rax,QWORD PTR [rsp+0x80]
  2250f8:	00 
  2250f9:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  2250fd:	c5 f8 10 44 24 72    	vmovups xmm0,XMMWORD PTR [rsp+0x72]
  225103:	c5 f8 11 43 02       	vmovups XMMWORD PTR [rbx+0x2],xmm0
  225108:	48 81 c4 88 00 00 00 	add    rsp,0x88
  22510f:	5b                   	pop    rbx
  225110:	41 5e                	pop    r14
  225112:	c3                   	ret    
  225113:	48 89 e0             	mov    rax,rsp
            return ([*]align(alignment) T)(undefined)[0..0];
  225116:	0f b7 0d d9 26 fe ff 	movzx  ecx,WORD PTR [rip+0xfffffffffffe26d9]        # 2077f6 <__unnamed_74+0x6>
  22511d:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  225122:	8b 0d ca 26 fe ff    	mov    ecx,DWORD PTR [rip+0xfffffffffffe26ca]        # 2077f2 <__unnamed_74+0x2>
  225128:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  22512b:	31 c9                	xor    ecx,ecx
  22512d:	45 31 f6             	xor    r14d,r14d
  225130:	e9 9f 00 00 00       	jmp    2251d4 <Allocator_alignedRealloc.158+0x234>
  225135:	48 8d 4c 24 48       	lea    rcx,[rsp+0x48]
  22513a:	66 c7 44 24 48 00 00 	mov    WORD PTR [rsp+0x48],0x0
  225141:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  225146:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  22514a:	0f 85 ef fe ff ff    	jne    22503f <Allocator_alignedRealloc.158+0x9f>
  225150:	4c 8b 71 08          	mov    r14,QWORD PTR [rcx+0x8]
  225154:	48 8d 7c 24 08       	lea    rdi,[rsp+0x8]
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  225159:	b9 08 00 00 00       	mov    ecx,0x8
  22515e:	4c 89 f2             	mov    rdx,r14
  225161:	ff 16                	call   QWORD PTR [rsi]
  225163:	0f b7 4c 24 08       	movzx  ecx,WORD PTR [rsp+0x8]
  225168:	66 85 c9             	test   cx,cx
  22516b:	74 41                	je     2251ae <Allocator_alignedRealloc.158+0x20e>
  22516d:	0f b7 44 24 36       	movzx  eax,WORD PTR [rsp+0x36]
  225172:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  225177:	48 89 e0             	mov    rax,rsp
  22517a:	8b 54 24 32          	mov    edx,DWORD PTR [rsp+0x32]
  22517e:	89 14 24             	mov    DWORD PTR [rsp],edx
  225181:	eb 51                	jmp    2251d4 <Allocator_alignedRealloc.158+0x234>
        assert(byte_slice.len == byte_count);
  225183:	4c 39 74 24 68       	cmp    QWORD PTR [rsp+0x68],r14
    if (!ok) {
  225188:	75 6d                	jne    2251f7 <Allocator_alignedRealloc.158+0x257>
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  22518a:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  22518f:	66 c7 03 00 00       	mov    WORD PTR [rbx],0x0
  225194:	0f b7 4c 24 2a       	movzx  ecx,WORD PTR [rsp+0x2a]
  225199:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  22519d:	49 c1 ee 04          	shr    r14,0x4
  2251a1:	8b 4c 24 26          	mov    ecx,DWORD PTR [rsp+0x26]
  2251a5:	89 4b 02             	mov    DWORD PTR [rbx+0x2],ecx
  2251a8:	48 89 43 08          	mov    QWORD PTR [rbx+0x8],rax
  2251ac:	eb 3a                	jmp    2251e8 <Allocator_alignedRealloc.158+0x248>
        assert(byte_slice.len == byte_count);
  2251ae:	4c 39 74 24 18       	cmp    QWORD PTR [rsp+0x18],r14
  2251b3:	75 42                	jne    2251f7 <Allocator_alignedRealloc.158+0x257>
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  2251b5:	48 8b 54 24 10       	mov    rdx,QWORD PTR [rsp+0x10]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  2251ba:	49 c1 ee 04          	shr    r14,0x4
  2251be:	48 89 e0             	mov    rax,rsp
  2251c1:	8b 4c 24 2c          	mov    ecx,DWORD PTR [rsp+0x2c]
  2251c5:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  2251c8:	0f b7 4c 24 30       	movzx  ecx,WORD PTR [rsp+0x30]
  2251cd:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  2251d2:	31 c9                	xor    ecx,ecx
            return self.alignedAlloc(T, alignment, n);
  2251d4:	66 89 0b             	mov    WORD PTR [rbx],cx
  2251d7:	0f b7 48 04          	movzx  ecx,WORD PTR [rax+0x4]
  2251db:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  2251df:	8b 00                	mov    eax,DWORD PTR [rax]
  2251e1:	89 43 02             	mov    DWORD PTR [rbx+0x2],eax
  2251e4:	48 89 53 08          	mov    QWORD PTR [rbx+0x8],rdx
  2251e8:	4c 89 73 10          	mov    QWORD PTR [rbx+0x10],r14
  2251ec:	48 81 c4 88 00 00 00 	add    rsp,0x88
  2251f3:	5b                   	pop    rbx
  2251f4:	41 5e                	pop    r14
  2251f6:	c3                   	ret    
            @panic("assertion failure");
  2251f7:	48 8d 3d 0a 9b 02 00 	lea    rdi,[rip+0x29b0a]        # 24ed08 <__unnamed_2>
  2251fe:	e8 1d ce fe ff       	call   212020 <panic>
  225203:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  22520a:	84 00 00 00 00 00 

0000000000225210 <Allocator_alignedRealloc.161>:
    pub fn alignedRealloc(self: *Allocator, comptime T: type, comptime alignment: u29, old_mem: []align(alignment) T, n: usize) ![]align(alignment) T {
  225210:	41 56                	push   r14
  225212:	53                   	push   rbx
  225213:	48 81 ec 88 00 00 00 	sub    rsp,0x88
  22521a:	48 89 fb             	mov    rbx,rdi
        if (old_mem.len == 0) {
  22521d:	48 8b 42 08          	mov    rax,QWORD PTR [rdx+0x8]
  225221:	48 85 c0             	test   rax,rax
  225224:	74 62                	je     225288 <Allocator_alignedRealloc.161+0x78>
        if (n == 0) {
  225226:	48 85 c9             	test   rcx,rcx
  225229:	0f 84 a9 00 00 00    	je     2252d8 <Allocator_alignedRealloc.161+0xc8>
        const old_byte_slice = @sliceToBytes(old_mem);
  22522f:	48 8b 12             	mov    rdx,QWORD PTR [rdx]
  225232:	48 c1 e0 03          	shl    rax,0x3
  225236:	48 8d 04 80          	lea    rax,[rax+rax*4]
  22523a:	48 89 54 24 38       	mov    QWORD PTR [rsp+0x38],rdx
  22523f:	48 89 44 24 40       	mov    QWORD PTR [rsp+0x40],rax
  225244:	ba 28 00 00 00       	mov    edx,0x28
  225249:	48 89 c8             	mov    rax,rcx
  22524c:	48 f7 e2             	mul    rdx
  22524f:	0f 81 d0 00 00 00    	jno    225325 <Allocator_alignedRealloc.161+0x115>
  225255:	48 8d 0d 24 3d fe ff 	lea    rcx,[rip+0xfffffffffffe3d24]        # 208f80 <__unnamed_43>
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  22525c:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  225260:	0f 84 da 00 00 00    	je     225340 <Allocator_alignedRealloc.161+0x130>
  225266:	48 8b 05 db 25 fe ff 	mov    rax,QWORD PTR [rip+0xfffffffffffe25db]        # 207848 <__unnamed_75+0x10>
  22526d:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  225271:	c5 f8 10 05 bf 25 fe 	vmovups xmm0,XMMWORD PTR [rip+0xfffffffffffe25bf]        # 207838 <__unnamed_75>
  225278:	ff 
  225279:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  22527d:	48 81 c4 88 00 00 00 	add    rsp,0x88
  225284:	5b                   	pop    rbx
  225285:	41 5e                	pop    r14
  225287:	c3                   	ret    
        if (n == 0) {
  225288:	48 85 c9             	test   rcx,rcx
  22528b:	0f 84 fc 00 00 00    	je     22538d <Allocator_alignedRealloc.161+0x17d>
  225291:	ba 28 00 00 00       	mov    edx,0x28
  225296:	48 89 c8             	mov    rax,rcx
  225299:	48 f7 e2             	mul    rdx
  22529c:	0f 81 0c 01 00 00    	jno    2253ae <Allocator_alignedRealloc.161+0x19e>
  2252a2:	48 8d 0d d7 3c fe ff 	lea    rcx,[rip+0xfffffffffffe3cd7]        # 208f80 <__unnamed_43>
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  2252a9:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  2252ad:	0f 84 16 01 00 00    	je     2253c9 <Allocator_alignedRealloc.161+0x1b9>
  2252b3:	0f b7 05 84 25 fe ff 	movzx  eax,WORD PTR [rip+0xfffffffffffe2584]        # 20783e <__unnamed_75+0x6>
  2252ba:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  2252bf:	8b 05 75 25 fe ff    	mov    eax,DWORD PTR [rip+0xfffffffffffe2575]        # 20783a <__unnamed_75+0x2>
  2252c5:	89 04 24             	mov    DWORD PTR [rsp],eax
  2252c8:	48 89 e0             	mov    rax,rsp
  2252cb:	66 b9 01 00          	mov    cx,0x1
  2252cf:	31 f6                	xor    esi,esi
  2252d1:	31 d2                	xor    edx,edx
  2252d3:	e9 9d 01 00 00       	jmp    225475 <Allocator_alignedRealloc.161+0x265>
        const bytes = @sliceToBytes(memory);
  2252d8:	48 c1 e0 03          	shl    rax,0x3
  2252dc:	48 8d 04 80          	lea    rax,[rax+rax*4]
        if (bytes.len == 0) return;
  2252e0:	48 85 c0             	test   rax,rax
  2252e3:	74 1e                	je     225303 <Allocator_alignedRealloc.161+0xf3>
        const bytes = @sliceToBytes(memory);
  2252e5:	48 8b 0a             	mov    rcx,QWORD PTR [rdx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  2252e8:	48 8b 56 10          	mov    rdx,QWORD PTR [rsi+0x10]
  2252ec:	48 89 4c 24 08       	mov    QWORD PTR [rsp+0x8],rcx
  2252f1:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  2252f6:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  2252fb:	48 89 f7             	mov    rdi,rsi
  2252fe:	48 89 c6             	mov    rsi,rax
  225301:	ff d2                	call   rdx
            return ([*]align(alignment) T)(undefined)[0..0];
  225303:	48 8b 05 26 25 fe ff 	mov    rax,QWORD PTR [rip+0xfffffffffffe2526]        # 207830 <__unnamed_76+0x10>
  22530a:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  22530e:	c5 f8 10 05 0a 25 fe 	vmovups xmm0,XMMWORD PTR [rip+0xfffffffffffe250a]        # 207820 <__unnamed_76>
  225315:	ff 
  225316:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  22531a:	48 81 c4 88 00 00 00 	add    rsp,0x88
  225321:	5b                   	pop    rbx
  225322:	41 5e                	pop    r14
  225324:	c3                   	ret    
  225325:	48 8d 4c 24 08       	lea    rcx,[rsp+0x8]
  22532a:	66 c7 44 24 08 00 00 	mov    WORD PTR [rsp+0x8],0x0
  225331:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  225336:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  22533a:	0f 85 26 ff ff ff    	jne    225266 <Allocator_alignedRealloc.161+0x56>
  225340:	4c 8b 71 08          	mov    r14,QWORD PTR [rcx+0x8]
  225344:	48 8d 7c 24 58       	lea    rdi,[rsp+0x58]
  225349:	48 8d 54 24 38       	lea    rdx,[rsp+0x38]
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  22534e:	41 b8 08 00 00 00    	mov    r8d,0x8
  225354:	4c 89 f1             	mov    rcx,r14
  225357:	ff 56 08             	call   QWORD PTR [rsi+0x8]
  22535a:	0f b7 44 24 58       	movzx  eax,WORD PTR [rsp+0x58]
  22535f:	66 85 c0             	test   ax,ax
  225362:	0f 84 94 00 00 00    	je     2253fc <Allocator_alignedRealloc.161+0x1ec>
  225368:	66 89 03             	mov    WORD PTR [rbx],ax
  22536b:	48 8b 84 24 80 00 00 	mov    rax,QWORD PTR [rsp+0x80]
  225372:	00 
  225373:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  225377:	c5 f8 10 44 24 72    	vmovups xmm0,XMMWORD PTR [rsp+0x72]
  22537d:	c5 f8 11 43 02       	vmovups XMMWORD PTR [rbx+0x2],xmm0
  225382:	48 81 c4 88 00 00 00 	add    rsp,0x88
  225389:	5b                   	pop    rbx
  22538a:	41 5e                	pop    r14
  22538c:	c3                   	ret    
  22538d:	48 89 e0             	mov    rax,rsp
            return ([*]align(alignment) T)(undefined)[0..0];
  225390:	0f b7 0d 8f 24 fe ff 	movzx  ecx,WORD PTR [rip+0xfffffffffffe248f]        # 207826 <__unnamed_76+0x6>
  225397:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  22539c:	8b 0d 80 24 fe ff    	mov    ecx,DWORD PTR [rip+0xfffffffffffe2480]        # 207822 <__unnamed_76+0x2>
  2253a2:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  2253a5:	31 c9                	xor    ecx,ecx
  2253a7:	31 d2                	xor    edx,edx
  2253a9:	e9 c7 00 00 00       	jmp    225475 <Allocator_alignedRealloc.161+0x265>
  2253ae:	48 8d 4c 24 48       	lea    rcx,[rsp+0x48]
  2253b3:	66 c7 44 24 48 00 00 	mov    WORD PTR [rsp+0x48],0x0
  2253ba:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  2253bf:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  2253c3:	0f 85 ea fe ff ff    	jne    2252b3 <Allocator_alignedRealloc.161+0xa3>
  2253c9:	4c 8b 71 08          	mov    r14,QWORD PTR [rcx+0x8]
  2253cd:	48 8d 7c 24 08       	lea    rdi,[rsp+0x8]
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  2253d2:	b9 08 00 00 00       	mov    ecx,0x8
  2253d7:	4c 89 f2             	mov    rdx,r14
  2253da:	ff 16                	call   QWORD PTR [rsi]
  2253dc:	0f b7 4c 24 08       	movzx  ecx,WORD PTR [rsp+0x8]
  2253e1:	66 85 c9             	test   cx,cx
  2253e4:	74 57                	je     22543d <Allocator_alignedRealloc.161+0x22d>
  2253e6:	0f b7 44 24 36       	movzx  eax,WORD PTR [rsp+0x36]
  2253eb:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  2253f0:	48 89 e0             	mov    rax,rsp
  2253f3:	8b 54 24 32          	mov    edx,DWORD PTR [rsp+0x32]
  2253f7:	89 14 24             	mov    DWORD PTR [rsp],edx
  2253fa:	eb 79                	jmp    225475 <Allocator_alignedRealloc.161+0x265>
        assert(byte_slice.len == byte_count);
  2253fc:	4c 39 74 24 68       	cmp    QWORD PTR [rsp+0x68],r14
    if (!ok) {
  225401:	0f 85 91 00 00 00    	jne    225498 <Allocator_alignedRealloc.161+0x288>
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  225407:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  22540c:	48 b9 cd cc cc cc cc 	movabs rcx,0xcccccccccccccccd
  225413:	cc cc cc 
  225416:	4c 89 f2             	mov    rdx,r14
  225419:	c4 e2 f3 f6 d1       	mulx   rdx,rcx,rcx
  22541e:	66 c7 03 00 00       	mov    WORD PTR [rbx],0x0
  225423:	0f b7 4c 24 2a       	movzx  ecx,WORD PTR [rsp+0x2a]
  225428:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  22542c:	48 c1 ea 05          	shr    rdx,0x5
  225430:	8b 4c 24 26          	mov    ecx,DWORD PTR [rsp+0x26]
  225434:	89 4b 02             	mov    DWORD PTR [rbx+0x2],ecx
  225437:	48 89 43 08          	mov    QWORD PTR [rbx+0x8],rax
  22543b:	eb 4c                	jmp    225489 <Allocator_alignedRealloc.161+0x279>
        assert(byte_slice.len == byte_count);
  22543d:	4c 39 74 24 18       	cmp    QWORD PTR [rsp+0x18],r14
  225442:	75 54                	jne    225498 <Allocator_alignedRealloc.161+0x288>
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  225444:	48 8b 74 24 10       	mov    rsi,QWORD PTR [rsp+0x10]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  225449:	48 b8 cd cc cc cc cc 	movabs rax,0xcccccccccccccccd
  225450:	cc cc cc 
  225453:	4c 89 f2             	mov    rdx,r14
  225456:	c4 e2 fb f6 d0       	mulx   rdx,rax,rax
  22545b:	48 c1 ea 05          	shr    rdx,0x5
  22545f:	48 89 e0             	mov    rax,rsp
  225462:	8b 4c 24 2c          	mov    ecx,DWORD PTR [rsp+0x2c]
  225466:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  225469:	0f b7 4c 24 30       	movzx  ecx,WORD PTR [rsp+0x30]
  22546e:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  225473:	31 c9                	xor    ecx,ecx
            return self.alignedAlloc(T, alignment, n);
  225475:	66 89 0b             	mov    WORD PTR [rbx],cx
  225478:	0f b7 48 04          	movzx  ecx,WORD PTR [rax+0x4]
  22547c:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  225480:	8b 00                	mov    eax,DWORD PTR [rax]
  225482:	89 43 02             	mov    DWORD PTR [rbx+0x2],eax
  225485:	48 89 73 08          	mov    QWORD PTR [rbx+0x8],rsi
  225489:	48 89 53 10          	mov    QWORD PTR [rbx+0x10],rdx
  22548d:	48 81 c4 88 00 00 00 	add    rsp,0x88
  225494:	5b                   	pop    rbx
  225495:	41 5e                	pop    r14
  225497:	c3                   	ret    
            @panic("assertion failure");
  225498:	48 8d 3d 69 98 02 00 	lea    rdi,[rip+0x29869]        # 24ed08 <__unnamed_2>
  22549f:	e8 7c cb fe ff       	call   212020 <panic>
  2254a4:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  2254ab:	00 00 00 00 00 

00000000002254b0 <parseFormValue>:
fn parseFormValue(allocator: *mem.Allocator, in_stream: var, form_id: u64, is_64: bool) ParseFormValueError!FormValue {
  2254b0:	55                   	push   rbp
  2254b1:	41 57                	push   r15
  2254b3:	41 56                	push   r14
  2254b5:	41 55                	push   r13
  2254b7:	41 54                	push   r12
  2254b9:	53                   	push   rbx
  2254ba:	48 81 ec 08 07 00 00 	sub    rsp,0x708
  2254c1:	44 89 c5             	mov    ebp,r8d
  2254c4:	48 89 cb             	mov    rbx,rcx
  2254c7:	49 89 d4             	mov    r12,rdx
  2254ca:	49 89 f7             	mov    r15,rsi
  2254cd:	49 89 fe             	mov    r14,rdi
  2254d0:	48 8d 05 e1 23 fe ff 	lea    rax,[rip+0xfffffffffffe23e1]        # 2078b8 <__unnamed_77>
    return switch (form_id) {
  2254d7:	48 8d 4b ff          	lea    rcx,[rbx-0x1]
  2254db:	48 83 f9 1f          	cmp    rcx,0x1f
  2254df:	0f 87 d1 19 00 00    	ja     226eb6 <parseFormValue+0x1a06>
  2254e5:	48 8d 15 84 b4 fd ff 	lea    rdx,[rip+0xfffffffffffdb484]        # 200970 <__unnamed_609+0x630>
  2254ec:	48 63 0c 8a          	movsxd rcx,DWORD PTR [rdx+rcx*4]
  2254f0:	48 01 d1             	add    rcx,rdx
  2254f3:	ff e1                	jmp    rcx
  2254f5:	4c 89 bc 24 d0 00 00 	mov    QWORD PTR [rsp+0xd0],r15
  2254fc:	00 
  2254fd:	4c 89 74 24 68       	mov    QWORD PTR [rsp+0x68],r14
  225502:	4c 8d b4 24 b0 00 00 	lea    r14,[rsp+0xb0]
  225509:	00 
            try self.readNoEof(result[0..]);
  22550a:	4c 89 74 24 18       	mov    QWORD PTR [rsp+0x18],r14
  22550f:	48 c7 44 24 20 01 00 	mov    QWORD PTR [rsp+0x20],0x1
  225516:	00 00 
  225518:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  22551d:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  225522:	4c 89 e6             	mov    rsi,r12
  225525:	41 ff 14 24          	call   QWORD PTR [r12]
  225529:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  22552e:	66 85 c0             	test   ax,ax
  225531:	0f 84 f2 0b 00 00    	je     226129 <parseFormValue+0xc79>
  225537:	48 8b 4c 24 68       	mov    rcx,QWORD PTR [rsp+0x68]
            const block_len = try readULeb128(in_stream);
  22553c:	66 89 01             	mov    WORD PTR [rcx],ax
  22553f:	48 8b 84 24 b4 06 00 	mov    rax,QWORD PTR [rsp+0x6b4]
  225546:	00 
  225547:	48 89 41 20          	mov    QWORD PTR [rcx+0x20],rax
  22554b:	c5 fc 10 84 24 96 06 	vmovups ymm0,YMMWORD PTR [rsp+0x696]
  225552:	00 00 
  225554:	c5 fc 11 41 02       	vmovups YMMWORD PTR [rcx+0x2],ymm0
  225559:	e9 69 19 00 00       	jmp    226ec7 <parseFormValue+0x1a17>
  22555e:	48 8d 44 24 78       	lea    rax,[rsp+0x78]
            try self.readNoEof(bytes[0..]);
  225563:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  225568:	48 c7 44 24 20 08 00 	mov    QWORD PTR [rsp+0x20],0x8
  22556f:	00 00 
  225571:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  225576:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  22557b:	4c 89 e6             	mov    rsi,r12
  22557e:	41 ff 14 24          	call   QWORD PTR [r12]
  225582:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  225587:	66 85 c0             	test   ax,ax
  22558a:	75 14                	jne    2255a0 <parseFormValue+0xf0>
  22558c:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  225591:	66 b8 25 00          	mov    ax,0x25
            if (amt_read < buf.len) return error.EndOfStream;
  225595:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  22559a:	0f 83 ce 12 00 00    	jae    22686e <parseFormValue+0x13be>
        DW.FORM_addr => FormValue{ .Address = try parseFormValueTargetAddrSize(in_stream) },
  2255a0:	66 41 89 06          	mov    WORD PTR [r14],ax
  2255a4:	48 8b 84 24 00 07 00 	mov    rax,QWORD PTR [rsp+0x700]
  2255ab:	00 
  2255ac:	49 89 46 20          	mov    QWORD PTR [r14+0x20],rax
  2255b0:	c5 fc 10 84 24 e2 06 	vmovups ymm0,YMMWORD PTR [rsp+0x6e2]
  2255b7:	00 00 
  2255b9:	e9 0b 0d 00 00       	jmp    2262c9 <parseFormValue+0xe19>
  2255be:	48 8d 44 24 78       	lea    rax,[rsp+0x78]
            const input_slice = input_buf[0..size];
  2255c3:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  2255c8:	48 c7 44 24 20 02 00 	mov    QWORD PTR [rsp+0x20],0x2
  2255cf:	00 00 
  2255d1:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  2255d6:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  2255db:	4c 89 e6             	mov    rsi,r12
  2255de:	41 ff 14 24          	call   QWORD PTR [r12]
  2255e2:	0f b7 4c 24 40       	movzx  ecx,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  2255e7:	66 85 c9             	test   cx,cx
  2255ea:	75 14                	jne    225600 <parseFormValue+0x150>
            if (amt_read < buf.len) return error.EndOfStream;
  2255ec:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
  2255f1:	66 b9 25 00          	mov    cx,0x25
  2255f5:	48 39 44 24 48       	cmp    QWORD PTR [rsp+0x48],rax
  2255fa:	0f 83 d8 12 00 00    	jae    2268d8 <parseFormValue+0x1428>
    const block_len = try in_stream.readVarInt(builtin.Endian.Little, usize, size);
  225600:	66 89 8c 24 90 02 00 	mov    WORD PTR [rsp+0x290],cx
  225607:	00 
  225608:	8b 44 24 3a          	mov    eax,DWORD PTR [rsp+0x3a]
  22560c:	89 84 24 92 02 00 00 	mov    DWORD PTR [rsp+0x292],eax
  225613:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  225618:	66 89 84 24 96 02 00 	mov    WORD PTR [rsp+0x296],ax
  22561f:	00 
  225620:	8b 44 24 11          	mov    eax,DWORD PTR [rsp+0x11]
  225624:	89 84 24 a9 02 00 00 	mov    DWORD PTR [rsp+0x2a9],eax
  22562b:	0f b7 44 24 15       	movzx  eax,WORD PTR [rsp+0x15]
  225630:	66 89 84 24 ad 02 00 	mov    WORD PTR [rsp+0x2ad],ax
  225637:	00 
  225638:	8a 44 24 17          	mov    al,BYTE PTR [rsp+0x17]
  22563c:	88 84 24 af 02 00 00 	mov    BYTE PTR [rsp+0x2af],al
  225643:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  225647:	89 84 24 b1 02 00 00 	mov    DWORD PTR [rsp+0x2b1],eax
  22564e:	0f b7 44 24 0e       	movzx  eax,WORD PTR [rsp+0xe]
  225653:	66 89 84 24 b5 02 00 	mov    WORD PTR [rsp+0x2b5],ax
  22565a:	00 
  22565b:	8a 44 24 10          	mov    al,BYTE PTR [rsp+0x10]
  22565f:	88 84 24 b7 02 00 00 	mov    BYTE PTR [rsp+0x2b7],al
  225666:	48 8d 84 24 90 02 00 	lea    rax,[rsp+0x290]
  22566d:	00 
  22566e:	e9 43 18 00 00       	jmp    226eb6 <parseFormValue+0x1a06>
  225673:	48 8d 44 24 78       	lea    rax,[rsp+0x78]
            const input_slice = input_buf[0..size];
  225678:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  22567d:	48 c7 44 24 20 04 00 	mov    QWORD PTR [rsp+0x20],0x4
  225684:	00 00 
  225686:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  22568b:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  225690:	4c 89 e6             	mov    rsi,r12
  225693:	41 ff 14 24          	call   QWORD PTR [r12]
  225697:	0f b7 4c 24 40       	movzx  ecx,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  22569c:	66 85 c9             	test   cx,cx
  22569f:	75 14                	jne    2256b5 <parseFormValue+0x205>
            if (amt_read < buf.len) return error.EndOfStream;
  2256a1:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
  2256a6:	66 b9 25 00          	mov    cx,0x25
  2256aa:	48 39 44 24 48       	cmp    QWORD PTR [rsp+0x48],rax
  2256af:	0f 83 44 12 00 00    	jae    2268f9 <parseFormValue+0x1449>
  2256b5:	66 89 8c 24 68 02 00 	mov    WORD PTR [rsp+0x268],cx
  2256bc:	00 
  2256bd:	8b 44 24 3a          	mov    eax,DWORD PTR [rsp+0x3a]
  2256c1:	89 84 24 6a 02 00 00 	mov    DWORD PTR [rsp+0x26a],eax
  2256c8:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  2256cd:	66 89 84 24 6e 02 00 	mov    WORD PTR [rsp+0x26e],ax
  2256d4:	00 
  2256d5:	8b 44 24 11          	mov    eax,DWORD PTR [rsp+0x11]
  2256d9:	89 84 24 81 02 00 00 	mov    DWORD PTR [rsp+0x281],eax
  2256e0:	0f b7 44 24 15       	movzx  eax,WORD PTR [rsp+0x15]
  2256e5:	66 89 84 24 85 02 00 	mov    WORD PTR [rsp+0x285],ax
  2256ec:	00 
  2256ed:	8a 44 24 17          	mov    al,BYTE PTR [rsp+0x17]
  2256f1:	88 84 24 87 02 00 00 	mov    BYTE PTR [rsp+0x287],al
  2256f8:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  2256fc:	89 84 24 89 02 00 00 	mov    DWORD PTR [rsp+0x289],eax
  225703:	0f b7 44 24 0e       	movzx  eax,WORD PTR [rsp+0xe]
  225708:	66 89 84 24 8d 02 00 	mov    WORD PTR [rsp+0x28d],ax
  22570f:	00 
  225710:	8a 44 24 10          	mov    al,BYTE PTR [rsp+0x10]
  225714:	88 84 24 8f 02 00 00 	mov    BYTE PTR [rsp+0x28f],al
  22571b:	48 8d 84 24 68 02 00 	lea    rax,[rsp+0x268]
  225722:	00 
  225723:	e9 8e 17 00 00       	jmp    226eb6 <parseFormValue+0x1a06>
  225728:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
            .payload = try readAllocBytes(allocator, in_stream, size),
  22572d:	b9 02 00 00 00       	mov    ecx,0x2
  225732:	4c 89 fe             	mov    rsi,r15
  225735:	4c 89 e2             	mov    rdx,r12
  225738:	e8 13 2b 00 00       	call   228250 <readAllocBytes>
  22573d:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
  225742:	66 85 c0             	test   ax,ax
  225745:	0f 84 89 0b 00 00    	je     2262d4 <parseFormValue+0xe24>
  22574b:	66 89 84 24 78 01 00 	mov    WORD PTR [rsp+0x178],ax
  225752:	00 
  225753:	8b 44 24 3a          	mov    eax,DWORD PTR [rsp+0x3a]
  225757:	89 84 24 7a 01 00 00 	mov    DWORD PTR [rsp+0x17a],eax
  22575e:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  225763:	66 89 84 24 7e 01 00 	mov    WORD PTR [rsp+0x17e],ax
  22576a:	00 
  22576b:	8b 44 24 11          	mov    eax,DWORD PTR [rsp+0x11]
  22576f:	89 84 24 91 01 00 00 	mov    DWORD PTR [rsp+0x191],eax
  225776:	0f b7 44 24 15       	movzx  eax,WORD PTR [rsp+0x15]
  22577b:	66 89 84 24 95 01 00 	mov    WORD PTR [rsp+0x195],ax
  225782:	00 
  225783:	8a 44 24 17          	mov    al,BYTE PTR [rsp+0x17]
  225787:	88 84 24 97 01 00 00 	mov    BYTE PTR [rsp+0x197],al
  22578e:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  225792:	89 84 24 99 01 00 00 	mov    DWORD PTR [rsp+0x199],eax
  225799:	0f b7 44 24 0e       	movzx  eax,WORD PTR [rsp+0xe]
  22579e:	66 89 84 24 9d 01 00 	mov    WORD PTR [rsp+0x19d],ax
  2257a5:	00 
  2257a6:	8a 44 24 10          	mov    al,BYTE PTR [rsp+0x10]
  2257aa:	88 84 24 9f 01 00 00 	mov    BYTE PTR [rsp+0x19f],al
  2257b1:	48 8d 84 24 78 01 00 	lea    rax,[rsp+0x178]
  2257b8:	00 
  2257b9:	e9 f8 16 00 00       	jmp    226eb6 <parseFormValue+0x1a06>
  2257be:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  2257c3:	b9 04 00 00 00       	mov    ecx,0x4
  2257c8:	4c 89 fe             	mov    rsi,r15
  2257cb:	4c 89 e2             	mov    rdx,r12
  2257ce:	e8 7d 2a 00 00       	call   228250 <readAllocBytes>
  2257d3:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
  2257d8:	66 85 c0             	test   ax,ax
  2257db:	0f 84 9d 0b 00 00    	je     22637e <parseFormValue+0xece>
  2257e1:	66 89 84 24 50 01 00 	mov    WORD PTR [rsp+0x150],ax
  2257e8:	00 
  2257e9:	8b 44 24 3a          	mov    eax,DWORD PTR [rsp+0x3a]
  2257ed:	89 84 24 52 01 00 00 	mov    DWORD PTR [rsp+0x152],eax
  2257f4:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  2257f9:	66 89 84 24 56 01 00 	mov    WORD PTR [rsp+0x156],ax
  225800:	00 
  225801:	8b 44 24 11          	mov    eax,DWORD PTR [rsp+0x11]
  225805:	89 84 24 69 01 00 00 	mov    DWORD PTR [rsp+0x169],eax
  22580c:	0f b7 44 24 15       	movzx  eax,WORD PTR [rsp+0x15]
  225811:	66 89 84 24 6d 01 00 	mov    WORD PTR [rsp+0x16d],ax
  225818:	00 
  225819:	8a 44 24 17          	mov    al,BYTE PTR [rsp+0x17]
  22581d:	88 84 24 6f 01 00 00 	mov    BYTE PTR [rsp+0x16f],al
  225824:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  225828:	89 84 24 71 01 00 00 	mov    DWORD PTR [rsp+0x171],eax
  22582f:	0f b7 44 24 0e       	movzx  eax,WORD PTR [rsp+0xe]
  225834:	66 89 84 24 75 01 00 	mov    WORD PTR [rsp+0x175],ax
  22583b:	00 
  22583c:	8a 44 24 10          	mov    al,BYTE PTR [rsp+0x10]
  225840:	88 84 24 77 01 00 00 	mov    BYTE PTR [rsp+0x177],al
  225847:	48 8d 84 24 50 01 00 	lea    rax,[rsp+0x150]
  22584e:	00 
  22584f:	e9 62 16 00 00       	jmp    226eb6 <parseFormValue+0x1a06>
  225854:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  225859:	b9 08 00 00 00       	mov    ecx,0x8
  22585e:	4c 89 fe             	mov    rsi,r15
  225861:	4c 89 e2             	mov    rdx,r12
  225864:	e8 e7 29 00 00       	call   228250 <readAllocBytes>
  225869:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
  22586e:	66 85 c0             	test   ax,ax
  225871:	0f 84 b1 0b 00 00    	je     226428 <parseFormValue+0xf78>
  225877:	66 89 84 24 28 01 00 	mov    WORD PTR [rsp+0x128],ax
  22587e:	00 
  22587f:	8b 44 24 3a          	mov    eax,DWORD PTR [rsp+0x3a]
  225883:	89 84 24 2a 01 00 00 	mov    DWORD PTR [rsp+0x12a],eax
  22588a:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  22588f:	66 89 84 24 2e 01 00 	mov    WORD PTR [rsp+0x12e],ax
  225896:	00 
  225897:	8b 44 24 11          	mov    eax,DWORD PTR [rsp+0x11]
  22589b:	89 84 24 41 01 00 00 	mov    DWORD PTR [rsp+0x141],eax
  2258a2:	0f b7 44 24 15       	movzx  eax,WORD PTR [rsp+0x15]
  2258a7:	66 89 84 24 45 01 00 	mov    WORD PTR [rsp+0x145],ax
  2258ae:	00 
  2258af:	8a 44 24 17          	mov    al,BYTE PTR [rsp+0x17]
  2258b3:	88 84 24 47 01 00 00 	mov    BYTE PTR [rsp+0x147],al
  2258ba:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  2258be:	89 84 24 49 01 00 00 	mov    DWORD PTR [rsp+0x149],eax
  2258c5:	0f b7 44 24 0e       	movzx  eax,WORD PTR [rsp+0xe]
  2258ca:	66 89 84 24 4d 01 00 	mov    WORD PTR [rsp+0x14d],ax
  2258d1:	00 
  2258d2:	8a 44 24 10          	mov    al,BYTE PTR [rsp+0x10]
  2258d6:	88 84 24 4f 01 00 00 	mov    BYTE PTR [rsp+0x14f],al
  2258dd:	48 8d 84 24 28 01 00 	lea    rax,[rsp+0x128]
  2258e4:	00 
  2258e5:	e9 cc 15 00 00       	jmp    226eb6 <parseFormValue+0x1a06>
  2258ea:	4c 89 74 24 68       	mov    QWORD PTR [rsp+0x68],r14
            return Self{
  2258ef:	c5 f8 57 c0          	vxorps xmm0,xmm0,xmm0
  2258f3:	c5 f8 29 44 24 40    	vmovaps XMMWORD PTR [rsp+0x40],xmm0
  2258f9:	48 c7 44 24 50 00 00 	mov    QWORD PTR [rsp+0x50],0x0
  225900:	00 00 
  225902:	4c 89 bc 24 d0 00 00 	mov    QWORD PTR [rsp+0xd0],r15
  225909:	00 
    var buf = ArrayList(u8).init(allocator);
  22590a:	4c 89 7c 24 58       	mov    QWORD PTR [rsp+0x58],r15
  22590f:	48 8d 84 24 b0 00 00 	lea    rax,[rsp+0xb0]
  225916:	00 
            try self.readNoEof(result[0..]);
  225917:	48 89 84 24 90 00 00 	mov    QWORD PTR [rsp+0x90],rax
  22591e:	00 
  22591f:	48 c7 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],0x1
  225926:	00 01 00 00 00 
  22592b:	48 8d 7c 24 18       	lea    rdi,[rsp+0x18]
  225930:	48 8d 94 24 90 00 00 	lea    rdx,[rsp+0x90]
  225937:	00 
            return self.readFn(self, buffer);
  225938:	4c 89 e6             	mov    rsi,r12
  22593b:	41 ff 14 24          	call   QWORD PTR [r12]
  22593f:	0f b7 44 24 18       	movzx  eax,WORD PTR [rsp+0x18]
            const amt_read = try self.read(buf);
  225944:	66 85 c0             	test   ax,ax
  225947:	0f 84 85 0b 00 00    	je     2264d2 <parseFormValue+0x1022>
  22594d:	48 8b 4c 24 68       	mov    rcx,QWORD PTR [rsp+0x68]
        DW.FORM_string => FormValue{ .String = try readStringRaw(allocator, in_stream) },
  225952:	66 89 01             	mov    WORD PTR [rcx],ax
  225955:	48 8b 84 24 84 05 00 	mov    rax,QWORD PTR [rsp+0x584]
  22595c:	00 
  22595d:	48 89 41 20          	mov    QWORD PTR [rcx+0x20],rax
  225961:	c5 fc 10 84 24 66 05 	vmovups ymm0,YMMWORD PTR [rsp+0x566]
  225968:	00 00 
  22596a:	c5 fc 11 41 02       	vmovups YMMWORD PTR [rcx+0x2],ymm0
  22596f:	e9 53 15 00 00       	jmp    226ec7 <parseFormValue+0x1a17>
  225974:	4c 89 bc 24 d0 00 00 	mov    QWORD PTR [rsp+0xd0],r15
  22597b:	00 
  22597c:	4c 89 74 24 68       	mov    QWORD PTR [rsp+0x68],r14
  225981:	4c 8d ac 24 b0 00 00 	lea    r13,[rsp+0xb0]
  225988:	00 
            try self.readNoEof(result[0..]);
  225989:	4c 89 6c 24 18       	mov    QWORD PTR [rsp+0x18],r13
  22598e:	48 c7 44 24 20 01 00 	mov    QWORD PTR [rsp+0x20],0x1
  225995:	00 00 
  225997:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  22599c:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  2259a1:	4c 89 e6             	mov    rsi,r12
  2259a4:	41 ff 14 24          	call   QWORD PTR [r12]
  2259a8:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  2259ad:	66 85 c0             	test   ax,ax
  2259b0:	0f 84 fa 0b 00 00    	je     2265b0 <parseFormValue+0x1100>
  2259b6:	48 8b 4c 24 68       	mov    rcx,QWORD PTR [rsp+0x68]
            const block_len = try readULeb128(in_stream);
  2259bb:	66 89 01             	mov    WORD PTR [rcx],ax
  2259be:	48 8b 84 24 da 06 00 	mov    rax,QWORD PTR [rsp+0x6da]
  2259c5:	00 
  2259c6:	48 89 41 20          	mov    QWORD PTR [rcx+0x20],rax
  2259ca:	c5 fc 10 84 24 bc 06 	vmovups ymm0,YMMWORD PTR [rsp+0x6bc]
  2259d1:	00 00 
  2259d3:	c5 fc 11 41 02       	vmovups YMMWORD PTR [rcx+0x2],ymm0
  2259d8:	e9 ea 14 00 00       	jmp    226ec7 <parseFormValue+0x1a17>
  2259dd:	48 8d 44 24 78       	lea    rax,[rsp+0x78]
            const input_slice = input_buf[0..size];
  2259e2:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  2259e7:	48 c7 44 24 20 01 00 	mov    QWORD PTR [rsp+0x20],0x1
  2259ee:	00 00 
  2259f0:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  2259f5:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  2259fa:	4c 89 e6             	mov    rsi,r12
  2259fd:	41 ff 14 24          	call   QWORD PTR [r12]
  225a01:	0f b7 4c 24 40       	movzx  ecx,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  225a06:	66 85 c9             	test   cx,cx
  225a09:	75 14                	jne    225a1f <parseFormValue+0x56f>
            if (amt_read < buf.len) return error.EndOfStream;
  225a0b:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
  225a10:	66 b9 25 00          	mov    cx,0x25
  225a14:	48 39 44 24 48       	cmp    QWORD PTR [rsp+0x48],rax
  225a19:	0f 83 fb 0e 00 00    	jae    22691a <parseFormValue+0x146a>
    const block_len = try in_stream.readVarInt(builtin.Endian.Little, usize, size);
  225a1f:	66 89 8c 24 b8 02 00 	mov    WORD PTR [rsp+0x2b8],cx
  225a26:	00 
  225a27:	8b 44 24 3a          	mov    eax,DWORD PTR [rsp+0x3a]
  225a2b:	89 84 24 ba 02 00 00 	mov    DWORD PTR [rsp+0x2ba],eax
  225a32:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  225a37:	66 89 84 24 be 02 00 	mov    WORD PTR [rsp+0x2be],ax
  225a3e:	00 
  225a3f:	8b 44 24 11          	mov    eax,DWORD PTR [rsp+0x11]
  225a43:	89 84 24 d1 02 00 00 	mov    DWORD PTR [rsp+0x2d1],eax
  225a4a:	0f b7 44 24 15       	movzx  eax,WORD PTR [rsp+0x15]
  225a4f:	66 89 84 24 d5 02 00 	mov    WORD PTR [rsp+0x2d5],ax
  225a56:	00 
  225a57:	8a 44 24 17          	mov    al,BYTE PTR [rsp+0x17]
  225a5b:	88 84 24 d7 02 00 00 	mov    BYTE PTR [rsp+0x2d7],al
  225a62:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  225a66:	89 84 24 d9 02 00 00 	mov    DWORD PTR [rsp+0x2d9],eax
  225a6d:	0f b7 44 24 0e       	movzx  eax,WORD PTR [rsp+0xe]
  225a72:	66 89 84 24 dd 02 00 	mov    WORD PTR [rsp+0x2dd],ax
  225a79:	00 
  225a7a:	8a 44 24 10          	mov    al,BYTE PTR [rsp+0x10]
  225a7e:	88 84 24 df 02 00 00 	mov    BYTE PTR [rsp+0x2df],al
  225a85:	48 8d 84 24 b8 02 00 	lea    rax,[rsp+0x2b8]
  225a8c:	00 
  225a8d:	e9 24 14 00 00       	jmp    226eb6 <parseFormValue+0x1a06>
  225a92:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
            .payload = try readAllocBytes(allocator, in_stream, size),
  225a97:	b9 01 00 00 00       	mov    ecx,0x1
  225a9c:	4c 89 fe             	mov    rsi,r15
  225a9f:	4c 89 e2             	mov    rdx,r12
  225aa2:	e8 a9 27 00 00       	call   228250 <readAllocBytes>
  225aa7:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
  225aac:	66 85 c0             	test   ax,ax
  225aaf:	0f 84 7c 0b 00 00    	je     226631 <parseFormValue+0x1181>
  225ab5:	66 89 84 24 a0 01 00 	mov    WORD PTR [rsp+0x1a0],ax
  225abc:	00 
  225abd:	8b 44 24 3a          	mov    eax,DWORD PTR [rsp+0x3a]
  225ac1:	89 84 24 a2 01 00 00 	mov    DWORD PTR [rsp+0x1a2],eax
  225ac8:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  225acd:	66 89 84 24 a6 01 00 	mov    WORD PTR [rsp+0x1a6],ax
  225ad4:	00 
  225ad5:	8b 44 24 11          	mov    eax,DWORD PTR [rsp+0x11]
  225ad9:	89 84 24 b9 01 00 00 	mov    DWORD PTR [rsp+0x1b9],eax
  225ae0:	0f b7 44 24 15       	movzx  eax,WORD PTR [rsp+0x15]
  225ae5:	66 89 84 24 bd 01 00 	mov    WORD PTR [rsp+0x1bd],ax
  225aec:	00 
  225aed:	8a 44 24 17          	mov    al,BYTE PTR [rsp+0x17]
  225af1:	88 84 24 bf 01 00 00 	mov    BYTE PTR [rsp+0x1bf],al
  225af8:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  225afc:	89 84 24 c1 01 00 00 	mov    DWORD PTR [rsp+0x1c1],eax
  225b03:	0f b7 44 24 0e       	movzx  eax,WORD PTR [rsp+0xe]
  225b08:	66 89 84 24 c5 01 00 	mov    WORD PTR [rsp+0x1c5],ax
  225b0f:	00 
  225b10:	8a 44 24 10          	mov    al,BYTE PTR [rsp+0x10]
  225b14:	88 84 24 c7 01 00 00 	mov    BYTE PTR [rsp+0x1c7],al
  225b1b:	48 8d 84 24 a0 01 00 	lea    rax,[rsp+0x1a0]
  225b22:	00 
  225b23:	e9 8e 13 00 00       	jmp    226eb6 <parseFormValue+0x1a06>
  225b28:	48 8d 84 24 b0 00 00 	lea    rax,[rsp+0xb0]
  225b2f:	00 
            try self.readNoEof(result[0..]);
  225b30:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  225b35:	48 c7 44 24 20 01 00 	mov    QWORD PTR [rsp+0x20],0x1
  225b3c:	00 00 
  225b3e:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  225b43:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  225b48:	4c 89 e6             	mov    rsi,r12
  225b4b:	41 ff 14 24          	call   QWORD PTR [r12]
  225b4f:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  225b54:	66 85 c0             	test   ax,ax
  225b57:	75 14                	jne    225b6d <parseFormValue+0x6bd>
  225b59:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  225b5e:	66 b8 25 00          	mov    ax,0x25
            if (amt_read < buf.len) return error.EndOfStream;
  225b62:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  225b67:	0f 83 ce 0d 00 00    	jae    22693b <parseFormValue+0x148b>
        DW.FORM_flag => FormValue{ .Flag = (try in_stream.readByte()) != 0 },
  225b6d:	66 41 89 06          	mov    WORD PTR [r14],ax
  225b71:	48 8b 84 24 42 06 00 	mov    rax,QWORD PTR [rsp+0x642]
  225b78:	00 
  225b79:	49 89 46 20          	mov    QWORD PTR [r14+0x20],rax
  225b7d:	c5 fc 10 84 24 24 06 	vmovups ymm0,YMMWORD PTR [rsp+0x624]
  225b84:	00 00 
  225b86:	e9 3e 07 00 00       	jmp    2262c9 <parseFormValue+0xe19>
    return if (is_64) try in_stream.readIntLe(u64) else u64(try in_stream.readIntLe(u32));
  225b8b:	40 f6 c5 01          	test   bpl,0x1
  225b8f:	0f 84 1c 06 00 00    	je     2261b1 <parseFormValue+0xd01>
  225b95:	48 8d 84 24 90 00 00 	lea    rax,[rsp+0x90]
  225b9c:	00 
            try self.readNoEof(bytes[0..]);
  225b9d:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  225ba2:	48 c7 44 24 20 08 00 	mov    QWORD PTR [rsp+0x20],0x8
  225ba9:	00 00 
  225bab:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  225bb0:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  225bb5:	4c 89 e6             	mov    rsi,r12
  225bb8:	41 ff 14 24          	call   QWORD PTR [r12]
  225bbc:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  225bc1:	66 85 c0             	test   ax,ax
  225bc4:	0f 85 29 06 00 00    	jne    2261f3 <parseFormValue+0xd43>
  225bca:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  225bcf:	66 b8 25 00          	mov    ax,0x25
            if (amt_read < buf.len) return error.EndOfStream;
  225bd3:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  225bd8:	0f 82 15 06 00 00    	jb     2261f3 <parseFormValue+0xd43>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  225bde:	48 8b 84 24 90 00 00 	mov    rax,QWORD PTR [rsp+0x90]
  225be5:	00 
  225be6:	e9 4f 11 00 00       	jmp    226d3a <parseFormValue+0x188a>
  225beb:	40 f6 c5 01          	test   bpl,0x1
  225bef:	0f 84 1c 06 00 00    	je     226211 <parseFormValue+0xd61>
  225bf5:	48 8d 84 24 90 00 00 	lea    rax,[rsp+0x90]
  225bfc:	00 
            try self.readNoEof(bytes[0..]);
  225bfd:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  225c02:	48 c7 44 24 20 08 00 	mov    QWORD PTR [rsp+0x20],0x8
  225c09:	00 00 
  225c0b:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  225c10:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  225c15:	4c 89 e6             	mov    rsi,r12
  225c18:	41 ff 14 24          	call   QWORD PTR [r12]
  225c1c:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  225c21:	66 85 c0             	test   ax,ax
  225c24:	0f 85 29 06 00 00    	jne    226253 <parseFormValue+0xda3>
  225c2a:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  225c2f:	66 b8 25 00          	mov    ax,0x25
            if (amt_read < buf.len) return error.EndOfStream;
  225c33:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  225c38:	0f 82 15 06 00 00    	jb     226253 <parseFormValue+0xda3>
  225c3e:	48 8b 84 24 90 00 00 	mov    rax,QWORD PTR [rsp+0x90]
  225c45:	00 
  225c46:	e9 7d 11 00 00       	jmp    226dc8 <parseFormValue+0x1918>
  225c4b:	48 8d 84 24 b0 00 00 	lea    rax,[rsp+0xb0]
  225c52:	00 
            try self.readNoEof(bytes[0..]);
  225c53:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  225c58:	48 c7 44 24 20 01 00 	mov    QWORD PTR [rsp+0x20],0x1
  225c5f:	00 00 
  225c61:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  225c66:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  225c6b:	4c 89 e6             	mov    rsi,r12
  225c6e:	41 ff 14 24          	call   QWORD PTR [r12]
  225c72:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  225c77:	66 85 c0             	test   ax,ax
  225c7a:	75 14                	jne    225c90 <parseFormValue+0x7e0>
  225c7c:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  225c81:	66 b8 25 00          	mov    ax,0x25
            if (amt_read < buf.len) return error.EndOfStream;
  225c85:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  225c8a:	0f 83 30 0d 00 00    	jae    2269c0 <parseFormValue+0x1510>
    const block_len = try in_stream.readIntLe(T);
  225c90:	66 89 84 24 40 02 00 	mov    WORD PTR [rsp+0x240],ax
  225c97:	00 
  225c98:	8b 44 24 3a          	mov    eax,DWORD PTR [rsp+0x3a]
  225c9c:	89 84 24 42 02 00 00 	mov    DWORD PTR [rsp+0x242],eax
  225ca3:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  225ca8:	66 89 84 24 46 02 00 	mov    WORD PTR [rsp+0x246],ax
  225caf:	00 
  225cb0:	8b 44 24 11          	mov    eax,DWORD PTR [rsp+0x11]
  225cb4:	89 84 24 59 02 00 00 	mov    DWORD PTR [rsp+0x259],eax
  225cbb:	0f b7 44 24 15       	movzx  eax,WORD PTR [rsp+0x15]
  225cc0:	66 89 84 24 5d 02 00 	mov    WORD PTR [rsp+0x25d],ax
  225cc7:	00 
  225cc8:	8a 44 24 17          	mov    al,BYTE PTR [rsp+0x17]
  225ccc:	88 84 24 5f 02 00 00 	mov    BYTE PTR [rsp+0x25f],al
  225cd3:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  225cd7:	89 84 24 61 02 00 00 	mov    DWORD PTR [rsp+0x261],eax
  225cde:	0f b7 44 24 0e       	movzx  eax,WORD PTR [rsp+0xe]
  225ce3:	66 89 84 24 65 02 00 	mov    WORD PTR [rsp+0x265],ax
  225cea:	00 
  225ceb:	8a 44 24 10          	mov    al,BYTE PTR [rsp+0x10]
  225cef:	88 84 24 67 02 00 00 	mov    BYTE PTR [rsp+0x267],al
  225cf6:	48 8d 84 24 40 02 00 	lea    rax,[rsp+0x240]
  225cfd:	00 
  225cfe:	e9 b3 11 00 00       	jmp    226eb6 <parseFormValue+0x1a06>
  225d03:	48 8d 44 24 78       	lea    rax,[rsp+0x78]
            try self.readNoEof(bytes[0..]);
  225d08:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  225d0d:	48 c7 44 24 20 02 00 	mov    QWORD PTR [rsp+0x20],0x2
  225d14:	00 00 
  225d16:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  225d1b:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  225d20:	4c 89 e6             	mov    rsi,r12
  225d23:	41 ff 14 24          	call   QWORD PTR [r12]
  225d27:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  225d2c:	66 85 c0             	test   ax,ax
  225d2f:	75 14                	jne    225d45 <parseFormValue+0x895>
  225d31:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  225d36:	66 b8 25 00          	mov    ax,0x25
            if (amt_read < buf.len) return error.EndOfStream;
  225d3a:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  225d3f:	0f 83 dd 0c 00 00    	jae    226a22 <parseFormValue+0x1572>
  225d45:	66 89 84 24 18 02 00 	mov    WORD PTR [rsp+0x218],ax
  225d4c:	00 
  225d4d:	8b 44 24 3a          	mov    eax,DWORD PTR [rsp+0x3a]
  225d51:	89 84 24 1a 02 00 00 	mov    DWORD PTR [rsp+0x21a],eax
  225d58:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  225d5d:	66 89 84 24 1e 02 00 	mov    WORD PTR [rsp+0x21e],ax
  225d64:	00 
  225d65:	8b 44 24 11          	mov    eax,DWORD PTR [rsp+0x11]
  225d69:	89 84 24 31 02 00 00 	mov    DWORD PTR [rsp+0x231],eax
  225d70:	0f b7 44 24 15       	movzx  eax,WORD PTR [rsp+0x15]
  225d75:	66 89 84 24 35 02 00 	mov    WORD PTR [rsp+0x235],ax
  225d7c:	00 
  225d7d:	8a 44 24 17          	mov    al,BYTE PTR [rsp+0x17]
  225d81:	88 84 24 37 02 00 00 	mov    BYTE PTR [rsp+0x237],al
  225d88:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  225d8c:	89 84 24 39 02 00 00 	mov    DWORD PTR [rsp+0x239],eax
  225d93:	0f b7 44 24 0e       	movzx  eax,WORD PTR [rsp+0xe]
  225d98:	66 89 84 24 3d 02 00 	mov    WORD PTR [rsp+0x23d],ax
  225d9f:	00 
  225da0:	8a 44 24 10          	mov    al,BYTE PTR [rsp+0x10]
  225da4:	88 84 24 3f 02 00 00 	mov    BYTE PTR [rsp+0x23f],al
  225dab:	48 8d 84 24 18 02 00 	lea    rax,[rsp+0x218]
  225db2:	00 
  225db3:	e9 fe 10 00 00       	jmp    226eb6 <parseFormValue+0x1a06>
  225db8:	48 8d 44 24 78       	lea    rax,[rsp+0x78]
            try self.readNoEof(bytes[0..]);
  225dbd:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  225dc2:	48 c7 44 24 20 04 00 	mov    QWORD PTR [rsp+0x20],0x4
  225dc9:	00 00 
  225dcb:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  225dd0:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  225dd5:	4c 89 e6             	mov    rsi,r12
  225dd8:	41 ff 14 24          	call   QWORD PTR [r12]
  225ddc:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  225de1:	66 85 c0             	test   ax,ax
  225de4:	75 14                	jne    225dfa <parseFormValue+0x94a>
  225de6:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  225deb:	66 b8 25 00          	mov    ax,0x25
            if (amt_read < buf.len) return error.EndOfStream;
  225def:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  225df4:	0f 83 93 0c 00 00    	jae    226a8d <parseFormValue+0x15dd>
  225dfa:	66 89 84 24 f0 01 00 	mov    WORD PTR [rsp+0x1f0],ax
  225e01:	00 
  225e02:	8b 44 24 3a          	mov    eax,DWORD PTR [rsp+0x3a]
  225e06:	89 84 24 f2 01 00 00 	mov    DWORD PTR [rsp+0x1f2],eax
  225e0d:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  225e12:	66 89 84 24 f6 01 00 	mov    WORD PTR [rsp+0x1f6],ax
  225e19:	00 
  225e1a:	8b 44 24 11          	mov    eax,DWORD PTR [rsp+0x11]
  225e1e:	89 84 24 09 02 00 00 	mov    DWORD PTR [rsp+0x209],eax
  225e25:	0f b7 44 24 15       	movzx  eax,WORD PTR [rsp+0x15]
  225e2a:	66 89 84 24 0d 02 00 	mov    WORD PTR [rsp+0x20d],ax
  225e31:	00 
  225e32:	8a 44 24 17          	mov    al,BYTE PTR [rsp+0x17]
  225e36:	88 84 24 0f 02 00 00 	mov    BYTE PTR [rsp+0x20f],al
  225e3d:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  225e41:	89 84 24 11 02 00 00 	mov    DWORD PTR [rsp+0x211],eax
  225e48:	0f b7 44 24 0e       	movzx  eax,WORD PTR [rsp+0xe]
  225e4d:	66 89 84 24 15 02 00 	mov    WORD PTR [rsp+0x215],ax
  225e54:	00 
  225e55:	8a 44 24 10          	mov    al,BYTE PTR [rsp+0x10]
  225e59:	88 84 24 17 02 00 00 	mov    BYTE PTR [rsp+0x217],al
  225e60:	48 8d 84 24 f0 01 00 	lea    rax,[rsp+0x1f0]
  225e67:	00 
  225e68:	e9 49 10 00 00       	jmp    226eb6 <parseFormValue+0x1a06>
  225e6d:	48 8d 44 24 78       	lea    rax,[rsp+0x78]
            try self.readNoEof(bytes[0..]);
  225e72:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  225e77:	48 c7 44 24 20 08 00 	mov    QWORD PTR [rsp+0x20],0x8
  225e7e:	00 00 
  225e80:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  225e85:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  225e8a:	4c 89 e6             	mov    rsi,r12
  225e8d:	41 ff 14 24          	call   QWORD PTR [r12]
  225e91:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  225e96:	66 85 c0             	test   ax,ax
  225e99:	75 14                	jne    225eaf <parseFormValue+0x9ff>
  225e9b:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  225ea0:	66 b8 25 00          	mov    ax,0x25
            if (amt_read < buf.len) return error.EndOfStream;
  225ea4:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  225ea9:	0f 83 61 0c 00 00    	jae    226b10 <parseFormValue+0x1660>
  225eaf:	66 89 84 24 c8 01 00 	mov    WORD PTR [rsp+0x1c8],ax
  225eb6:	00 
  225eb7:	8b 44 24 3a          	mov    eax,DWORD PTR [rsp+0x3a]
  225ebb:	89 84 24 ca 01 00 00 	mov    DWORD PTR [rsp+0x1ca],eax
  225ec2:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  225ec7:	66 89 84 24 ce 01 00 	mov    WORD PTR [rsp+0x1ce],ax
  225ece:	00 
  225ecf:	8b 44 24 11          	mov    eax,DWORD PTR [rsp+0x11]
  225ed3:	89 84 24 e1 01 00 00 	mov    DWORD PTR [rsp+0x1e1],eax
  225eda:	0f b7 44 24 15       	movzx  eax,WORD PTR [rsp+0x15]
  225edf:	66 89 84 24 e5 01 00 	mov    WORD PTR [rsp+0x1e5],ax
  225ee6:	00 
  225ee7:	8a 44 24 17          	mov    al,BYTE PTR [rsp+0x17]
  225eeb:	88 84 24 e7 01 00 00 	mov    BYTE PTR [rsp+0x1e7],al
  225ef2:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  225ef6:	89 84 24 e9 01 00 00 	mov    DWORD PTR [rsp+0x1e9],eax
  225efd:	0f b7 44 24 0e       	movzx  eax,WORD PTR [rsp+0xe]
  225f02:	66 89 84 24 ed 01 00 	mov    WORD PTR [rsp+0x1ed],ax
  225f09:	00 
  225f0a:	8a 44 24 10          	mov    al,BYTE PTR [rsp+0x10]
  225f0e:	88 84 24 ef 01 00 00 	mov    BYTE PTR [rsp+0x1ef],al
  225f15:	48 8d 84 24 c8 01 00 	lea    rax,[rsp+0x1c8]
  225f1c:	00 
  225f1d:	e9 94 0f 00 00       	jmp    226eb6 <parseFormValue+0x1a06>
  225f22:	4c 89 bc 24 d0 00 00 	mov    QWORD PTR [rsp+0xd0],r15
  225f29:	00 
  225f2a:	4c 89 74 24 68       	mov    QWORD PTR [rsp+0x68],r14
  225f2f:	4c 8d b4 24 b0 00 00 	lea    r14,[rsp+0xb0]
  225f36:	00 
            try self.readNoEof(result[0..]);
  225f37:	4c 89 74 24 18       	mov    QWORD PTR [rsp+0x18],r14
  225f3c:	48 c7 44 24 20 01 00 	mov    QWORD PTR [rsp+0x20],0x1
  225f43:	00 00 
  225f45:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  225f4a:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  225f4f:	4c 89 e6             	mov    rsi,r12
  225f52:	41 ff 14 24          	call   QWORD PTR [r12]
  225f56:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  225f5b:	66 85 c0             	test   ax,ax
  225f5e:	0f 84 77 07 00 00    	je     2266db <parseFormValue+0x122b>
  225f64:	48 8b 4c 24 68       	mov    rcx,QWORD PTR [rsp+0x68]
            const ref_len = try readULeb128(in_stream);
  225f69:	66 89 01             	mov    WORD PTR [rcx],ax
  225f6c:	48 8b 84 24 f6 05 00 	mov    rax,QWORD PTR [rsp+0x5f6]
  225f73:	00 
  225f74:	48 89 41 20          	mov    QWORD PTR [rcx+0x20],rax
  225f78:	c5 fc 10 84 24 d8 05 	vmovups ymm0,YMMWORD PTR [rsp+0x5d8]
  225f7f:	00 00 
  225f81:	c5 fc 11 41 02       	vmovups YMMWORD PTR [rcx+0x2],ymm0
  225f86:	e9 3c 0f 00 00       	jmp    226ec7 <parseFormValue+0x1a17>
  225f8b:	4c 89 bc 24 d0 00 00 	mov    QWORD PTR [rsp+0xd0],r15
  225f92:	00 
  225f93:	4c 89 74 24 68       	mov    QWORD PTR [rsp+0x68],r14
  225f98:	4c 8d bc 24 b0 00 00 	lea    r15,[rsp+0xb0]
  225f9f:	00 
            try self.readNoEof(result[0..]);
  225fa0:	4c 89 7c 24 18       	mov    QWORD PTR [rsp+0x18],r15
  225fa5:	48 c7 44 24 20 01 00 	mov    QWORD PTR [rsp+0x20],0x1
  225fac:	00 00 
  225fae:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  225fb3:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  225fb8:	4c 89 e6             	mov    rsi,r12
  225fbb:	41 ff 14 24          	call   QWORD PTR [r12]
  225fbf:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  225fc4:	66 85 c0             	test   ax,ax
  225fc7:	0f 84 8f 07 00 00    	je     22675c <parseFormValue+0x12ac>
  225fcd:	48 8b 4c 24 68       	mov    rcx,QWORD PTR [rsp+0x68]
            const child_form_id = try readULeb128(in_stream);
  225fd2:	66 89 01             	mov    WORD PTR [rcx],ax
  225fd5:	48 8b 84 24 38 05 00 	mov    rax,QWORD PTR [rsp+0x538]
  225fdc:	00 
  225fdd:	48 89 41 20          	mov    QWORD PTR [rcx+0x20],rax
  225fe1:	c5 fc 10 84 24 1a 05 	vmovups ymm0,YMMWORD PTR [rsp+0x51a]
  225fe8:	00 00 
  225fea:	c5 fc 11 41 02       	vmovups YMMWORD PTR [rcx+0x2],ymm0
  225fef:	e9 d3 0e 00 00       	jmp    226ec7 <parseFormValue+0x1a17>
    return if (is_64) try in_stream.readIntLe(u64) else u64(try in_stream.readIntLe(u32));
  225ff4:	40 f6 c5 01          	test   bpl,0x1
  225ff8:	0f 84 70 02 00 00    	je     22626e <parseFormValue+0xdbe>
  225ffe:	48 8d 84 24 90 00 00 	lea    rax,[rsp+0x90]
  226005:	00 
            try self.readNoEof(bytes[0..]);
  226006:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  22600b:	48 c7 44 24 20 08 00 	mov    QWORD PTR [rsp+0x20],0x8
  226012:	00 00 
  226014:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  226019:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  22601e:	4c 89 e6             	mov    rsi,r12
  226021:	41 ff 14 24          	call   QWORD PTR [r12]
  226025:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  22602a:	66 85 c0             	test   ax,ax
  22602d:	0f 85 7d 02 00 00    	jne    2262b0 <parseFormValue+0xe00>
  226033:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  226038:	66 b8 25 00          	mov    ax,0x25
            if (amt_read < buf.len) return error.EndOfStream;
  22603c:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  226041:	0f 82 69 02 00 00    	jb     2262b0 <parseFormValue+0xe00>
  226047:	48 8b 84 24 90 00 00 	mov    rax,QWORD PTR [rsp+0x90]
  22604e:	00 
  22604f:	e9 02 0e 00 00       	jmp    226e56 <parseFormValue+0x19a6>
  226054:	4c 89 bc 24 d0 00 00 	mov    QWORD PTR [rsp+0xd0],r15
  22605b:	00 
  22605c:	4c 89 74 24 68       	mov    QWORD PTR [rsp+0x68],r14
  226061:	4c 8d b4 24 b0 00 00 	lea    r14,[rsp+0xb0]
  226068:	00 
            try self.readNoEof(result[0..]);
  226069:	4c 89 74 24 18       	mov    QWORD PTR [rsp+0x18],r14
  22606e:	48 c7 44 24 20 01 00 	mov    QWORD PTR [rsp+0x20],0x1
  226075:	00 00 
  226077:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  22607c:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  226081:	4c 89 e6             	mov    rsi,r12
  226084:	41 ff 14 24          	call   QWORD PTR [r12]
  226088:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  22608d:	66 85 c0             	test   ax,ax
  226090:	0f 84 45 07 00 00    	je     2267db <parseFormValue+0x132b>
  226096:	48 8b 4c 24 68       	mov    rcx,QWORD PTR [rsp+0x68]
            const size = try readULeb128(in_stream);
  22609b:	66 89 01             	mov    WORD PTR [rcx],ax
  22609e:	48 8b 84 24 8e 06 00 	mov    rax,QWORD PTR [rsp+0x68e]
  2260a5:	00 
  2260a6:	48 89 41 20          	mov    QWORD PTR [rcx+0x20],rax
  2260aa:	c5 fc 10 84 24 70 06 	vmovups ymm0,YMMWORD PTR [rsp+0x670]
  2260b1:	00 00 
  2260b3:	c5 fc 11 41 02       	vmovups YMMWORD PTR [rcx+0x2],ymm0
  2260b8:	e9 0a 0e 00 00       	jmp    226ec7 <parseFormValue+0x1a17>
  2260bd:	48 8d 05 1c 18 fe ff 	lea    rax,[rip+0xfffffffffffe181c]        # 2078e0 <__unnamed_78>
  2260c4:	e9 ed 0d 00 00       	jmp    226eb6 <parseFormValue+0x1a06>
  2260c9:	48 8d 44 24 78       	lea    rax,[rsp+0x78]
            try self.readNoEof(bytes[0..]);
  2260ce:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  2260d3:	48 c7 44 24 20 08 00 	mov    QWORD PTR [rsp+0x20],0x8
  2260da:	00 00 
  2260dc:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  2260e1:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  2260e6:	4c 89 e6             	mov    rsi,r12
  2260e9:	41 ff 14 24          	call   QWORD PTR [r12]
  2260ed:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  2260f2:	66 85 c0             	test   ax,ax
  2260f5:	75 14                	jne    22610b <parseFormValue+0xc5b>
  2260f7:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  2260fc:	66 b8 25 00          	mov    ax,0x25
            if (amt_read < buf.len) return error.EndOfStream;
  226100:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  226105:	0f 83 64 0a 00 00    	jae    226b6f <parseFormValue+0x16bf>
        DW.FORM_ref_sig8 => FormValue{ .RefSig8 = try in_stream.readIntLe(u64) },
  22610b:	66 41 89 06          	mov    WORD PTR [r14],ax
  22610f:	48 8b 84 24 aa 05 00 	mov    rax,QWORD PTR [rsp+0x5aa]
  226116:	00 
  226117:	49 89 46 20          	mov    QWORD PTR [r14+0x20],rax
  22611b:	c5 fc 10 84 24 8c 05 	vmovups ymm0,YMMWORD PTR [rsp+0x58c]
  226122:	00 00 
  226124:	e9 a0 01 00 00       	jmp    2262c9 <parseFormValue+0xe19>
  226129:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  22612e:	31 ed                	xor    ebp,ebp
  226130:	4c 8d 7c 24 18       	lea    r15,[rsp+0x18]
  226135:	45 31 ed             	xor    r13d,r13d
  226138:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  22613f:	00 
  226140:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  226145:	0f 82 11 07 00 00    	jb     22685c <parseFormValue+0x13ac>
            return result[0];
  22614b:	0f b6 84 24 b0 00 00 	movzx  eax,BYTE PTR [rsp+0xb0]
  226152:	00 
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  226153:	89 c2                	mov    edx,eax
  226155:	83 e2 7f             	and    edx,0x7f
  226158:	44 89 ee             	mov    esi,r13d
  22615b:	83 e6 3f             	and    esi,0x3f
  22615e:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  226163:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  226168:	48 39 d6             	cmp    rsi,rdx
  22616b:	0f 85 f4 06 00 00    	jne    226865 <parseFormValue+0x13b5>
        result |= operand;
  226171:	48 09 cd             	or     rbp,rcx
        if ((byte & 0b10000000) == 0) return result;
  226174:	84 c0                	test   al,al
  226176:	0f 89 5d 0a 00 00    	jns    226bd9 <parseFormValue+0x1729>
        shift += 7;
  22617c:	49 83 c5 07          	add    r13,0x7
            try self.readNoEof(result[0..]);
  226180:	4c 89 74 24 18       	mov    QWORD PTR [rsp+0x18],r14
  226185:	48 c7 44 24 20 01 00 	mov    QWORD PTR [rsp+0x20],0x1
  22618c:	00 00 
            return self.readFn(self, buffer);
  22618e:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  226193:	4c 89 e6             	mov    rsi,r12
  226196:	4c 89 fa             	mov    rdx,r15
  226199:	41 ff 14 24          	call   QWORD PTR [r12]
  22619d:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
  2261a2:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
            const amt_read = try self.read(buf);
  2261a7:	66 85 c0             	test   ax,ax
  2261aa:	74 94                	je     226140 <parseFormValue+0xc90>
  2261ac:	e9 86 f3 ff ff       	jmp    225537 <parseFormValue+0x87>
  2261b1:	48 8d 44 24 78       	lea    rax,[rsp+0x78]
            try self.readNoEof(bytes[0..]);
  2261b6:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  2261bb:	48 c7 44 24 20 04 00 	mov    QWORD PTR [rsp+0x20],0x4
  2261c2:	00 00 
  2261c4:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  2261c9:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  2261ce:	4c 89 e6             	mov    rsi,r12
  2261d1:	41 ff 14 24          	call   QWORD PTR [r12]
  2261d5:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  2261da:	66 85 c0             	test   ax,ax
  2261dd:	75 14                	jne    2261f3 <parseFormValue+0xd43>
  2261df:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  2261e4:	66 b8 25 00          	mov    ax,0x25
            if (amt_read < buf.len) return error.EndOfStream;
  2261e8:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  2261ed:	0f 83 1e 0b 00 00    	jae    226d11 <parseFormValue+0x1861>
        DW.FORM_strp => FormValue{ .StrPtr = try parseFormValueDwarfOffsetSize(in_stream, is_64) },
  2261f3:	66 41 89 06          	mov    WORD PTR [r14],ax
  2261f7:	48 8b 84 24 5e 05 00 	mov    rax,QWORD PTR [rsp+0x55e]
  2261fe:	00 
  2261ff:	49 89 46 20          	mov    QWORD PTR [r14+0x20],rax
  226203:	c5 fc 10 84 24 40 05 	vmovups ymm0,YMMWORD PTR [rsp+0x540]
  22620a:	00 00 
  22620c:	e9 b8 00 00 00       	jmp    2262c9 <parseFormValue+0xe19>
  226211:	48 8d 44 24 78       	lea    rax,[rsp+0x78]
            try self.readNoEof(bytes[0..]);
  226216:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  22621b:	48 c7 44 24 20 04 00 	mov    QWORD PTR [rsp+0x20],0x4
  226222:	00 00 
  226224:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  226229:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  22622e:	4c 89 e6             	mov    rsi,r12
  226231:	41 ff 14 24          	call   QWORD PTR [r12]
  226235:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  22623a:	66 85 c0             	test   ax,ax
  22623d:	75 14                	jne    226253 <parseFormValue+0xda3>
  22623f:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  226244:	66 b8 25 00          	mov    ax,0x25
            if (amt_read < buf.len) return error.EndOfStream;
  226248:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  22624d:	0f 83 4c 0b 00 00    	jae    226d9f <parseFormValue+0x18ef>
        DW.FORM_ref_addr => FormValue{ .RefAddr = try parseFormValueDwarfOffsetSize(in_stream, is_64) },
  226253:	66 41 89 06          	mov    WORD PTR [r14],ax
  226257:	48 8b 84 24 d0 05 00 	mov    rax,QWORD PTR [rsp+0x5d0]
  22625e:	00 
  22625f:	49 89 46 20          	mov    QWORD PTR [r14+0x20],rax
  226263:	c5 fc 10 84 24 b2 05 	vmovups ymm0,YMMWORD PTR [rsp+0x5b2]
  22626a:	00 00 
  22626c:	eb 5b                	jmp    2262c9 <parseFormValue+0xe19>
  22626e:	48 8d 44 24 78       	lea    rax,[rsp+0x78]
            try self.readNoEof(bytes[0..]);
  226273:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  226278:	48 c7 44 24 20 04 00 	mov    QWORD PTR [rsp+0x20],0x4
  22627f:	00 00 
  226281:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  226286:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  22628b:	4c 89 e6             	mov    rsi,r12
  22628e:	41 ff 14 24          	call   QWORD PTR [r12]
  226292:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  226297:	66 85 c0             	test   ax,ax
  22629a:	75 14                	jne    2262b0 <parseFormValue+0xe00>
  22629c:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  2262a1:	66 b8 25 00          	mov    ax,0x25
            if (amt_read < buf.len) return error.EndOfStream;
  2262a5:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  2262aa:	0f 83 7d 0b 00 00    	jae    226e2d <parseFormValue+0x197d>
        DW.FORM_sec_offset => FormValue{ .SecOffset = try parseFormValueDwarfOffsetSize(in_stream, is_64) },
  2262b0:	66 41 89 06          	mov    WORD PTR [r14],ax
  2262b4:	48 8b 84 24 1c 06 00 	mov    rax,QWORD PTR [rsp+0x61c]
  2262bb:	00 
  2262bc:	49 89 46 20          	mov    QWORD PTR [r14+0x20],rax
  2262c0:	c5 fc 10 84 24 fe 05 	vmovups ymm0,YMMWORD PTR [rsp+0x5fe]
  2262c7:	00 00 
  2262c9:	c4 c1 7c 11 46 02    	vmovups YMMWORD PTR [r14+0x2],ymm0
  2262cf:	e9 f3 0b 00 00       	jmp    226ec7 <parseFormValue+0x1a17>
    return FormValue{
  2262d4:	c6 84 24 b0 00 00 00 	mov    BYTE PTR [rsp+0xb0],0x0
  2262db:	00 
  2262dc:	c6 44 24 60 02       	mov    BYTE PTR [rsp+0x60],0x2
  2262e1:	66 c7 84 24 78 01 00 	mov    WORD PTR [rsp+0x178],0x0
  2262e8:	00 00 00 
  2262eb:	8b 44 24 78          	mov    eax,DWORD PTR [rsp+0x78]
  2262ef:	89 84 24 7a 01 00 00 	mov    DWORD PTR [rsp+0x17a],eax
        .Const = Constant{
  2262f6:	c5 f8 10 44 24 48    	vmovups xmm0,XMMWORD PTR [rsp+0x48]
    return FormValue{
  2262fc:	0f b7 44 24 7c       	movzx  eax,WORD PTR [rsp+0x7c]
  226301:	66 89 84 24 7e 01 00 	mov    WORD PTR [rsp+0x17e],ax
  226308:	00 
  226309:	c5 f8 11 84 24 80 01 	vmovups XMMWORD PTR [rsp+0x180],xmm0
  226310:	00 00 
  226312:	c6 84 24 90 01 00 00 	mov    BYTE PTR [rsp+0x190],0x0
  226319:	00 
  22631a:	8b 84 24 90 00 00 00 	mov    eax,DWORD PTR [rsp+0x90]
  226321:	89 84 24 91 01 00 00 	mov    DWORD PTR [rsp+0x191],eax
  226328:	0f b7 84 24 94 00 00 	movzx  eax,WORD PTR [rsp+0x94]
  22632f:	00 
  226330:	66 89 84 24 95 01 00 	mov    WORD PTR [rsp+0x195],ax
  226337:	00 
  226338:	8a 84 24 96 00 00 00 	mov    al,BYTE PTR [rsp+0x96]
  22633f:	88 84 24 97 01 00 00 	mov    BYTE PTR [rsp+0x197],al
  226346:	c6 84 24 98 01 00 00 	mov    BYTE PTR [rsp+0x198],0x2
  22634d:	02 
  22634e:	8a 44 24 1e          	mov    al,BYTE PTR [rsp+0x1e]
  226352:	88 84 24 9f 01 00 00 	mov    BYTE PTR [rsp+0x19f],al
  226359:	0f b7 44 24 1c       	movzx  eax,WORD PTR [rsp+0x1c]
  22635e:	66 89 84 24 9d 01 00 	mov    WORD PTR [rsp+0x19d],ax
  226365:	00 
  226366:	8b 44 24 18          	mov    eax,DWORD PTR [rsp+0x18]
  22636a:	89 84 24 99 01 00 00 	mov    DWORD PTR [rsp+0x199],eax
  226371:	48 8d 84 24 78 01 00 	lea    rax,[rsp+0x178]
  226378:	00 
  226379:	e9 38 0b 00 00       	jmp    226eb6 <parseFormValue+0x1a06>
  22637e:	c6 84 24 b0 00 00 00 	mov    BYTE PTR [rsp+0xb0],0x0
  226385:	00 
  226386:	c6 44 24 60 02       	mov    BYTE PTR [rsp+0x60],0x2
  22638b:	66 c7 84 24 50 01 00 	mov    WORD PTR [rsp+0x150],0x0
  226392:	00 00 00 
  226395:	8b 44 24 78          	mov    eax,DWORD PTR [rsp+0x78]
  226399:	89 84 24 52 01 00 00 	mov    DWORD PTR [rsp+0x152],eax
        .Const = Constant{
  2263a0:	c5 f8 10 44 24 48    	vmovups xmm0,XMMWORD PTR [rsp+0x48]
    return FormValue{
  2263a6:	0f b7 44 24 7c       	movzx  eax,WORD PTR [rsp+0x7c]
  2263ab:	66 89 84 24 56 01 00 	mov    WORD PTR [rsp+0x156],ax
  2263b2:	00 
  2263b3:	c5 f8 11 84 24 58 01 	vmovups XMMWORD PTR [rsp+0x158],xmm0
  2263ba:	00 00 
  2263bc:	c6 84 24 68 01 00 00 	mov    BYTE PTR [rsp+0x168],0x0
  2263c3:	00 
  2263c4:	8b 84 24 90 00 00 00 	mov    eax,DWORD PTR [rsp+0x90]
  2263cb:	89 84 24 69 01 00 00 	mov    DWORD PTR [rsp+0x169],eax
  2263d2:	0f b7 84 24 94 00 00 	movzx  eax,WORD PTR [rsp+0x94]
  2263d9:	00 
  2263da:	66 89 84 24 6d 01 00 	mov    WORD PTR [rsp+0x16d],ax
  2263e1:	00 
  2263e2:	8a 84 24 96 00 00 00 	mov    al,BYTE PTR [rsp+0x96]
  2263e9:	88 84 24 6f 01 00 00 	mov    BYTE PTR [rsp+0x16f],al
  2263f0:	c6 84 24 70 01 00 00 	mov    BYTE PTR [rsp+0x170],0x2
  2263f7:	02 
  2263f8:	8a 44 24 1e          	mov    al,BYTE PTR [rsp+0x1e]
  2263fc:	88 84 24 77 01 00 00 	mov    BYTE PTR [rsp+0x177],al
  226403:	0f b7 44 24 1c       	movzx  eax,WORD PTR [rsp+0x1c]
  226408:	66 89 84 24 75 01 00 	mov    WORD PTR [rsp+0x175],ax
  22640f:	00 
  226410:	8b 44 24 18          	mov    eax,DWORD PTR [rsp+0x18]
  226414:	89 84 24 71 01 00 00 	mov    DWORD PTR [rsp+0x171],eax
  22641b:	48 8d 84 24 50 01 00 	lea    rax,[rsp+0x150]
  226422:	00 
  226423:	e9 8e 0a 00 00       	jmp    226eb6 <parseFormValue+0x1a06>
  226428:	c6 84 24 b0 00 00 00 	mov    BYTE PTR [rsp+0xb0],0x0
  22642f:	00 
  226430:	c6 44 24 60 02       	mov    BYTE PTR [rsp+0x60],0x2
  226435:	66 c7 84 24 28 01 00 	mov    WORD PTR [rsp+0x128],0x0
  22643c:	00 00 00 
  22643f:	8b 44 24 78          	mov    eax,DWORD PTR [rsp+0x78]
  226443:	89 84 24 2a 01 00 00 	mov    DWORD PTR [rsp+0x12a],eax
        .Const = Constant{
  22644a:	c5 f8 10 44 24 48    	vmovups xmm0,XMMWORD PTR [rsp+0x48]
    return FormValue{
  226450:	0f b7 44 24 7c       	movzx  eax,WORD PTR [rsp+0x7c]
  226455:	66 89 84 24 2e 01 00 	mov    WORD PTR [rsp+0x12e],ax
  22645c:	00 
  22645d:	c5 f8 11 84 24 30 01 	vmovups XMMWORD PTR [rsp+0x130],xmm0
  226464:	00 00 
  226466:	c6 84 24 40 01 00 00 	mov    BYTE PTR [rsp+0x140],0x0
  22646d:	00 
  22646e:	8b 84 24 90 00 00 00 	mov    eax,DWORD PTR [rsp+0x90]
  226475:	89 84 24 41 01 00 00 	mov    DWORD PTR [rsp+0x141],eax
  22647c:	0f b7 84 24 94 00 00 	movzx  eax,WORD PTR [rsp+0x94]
  226483:	00 
  226484:	66 89 84 24 45 01 00 	mov    WORD PTR [rsp+0x145],ax
  22648b:	00 
  22648c:	8a 84 24 96 00 00 00 	mov    al,BYTE PTR [rsp+0x96]
  226493:	88 84 24 47 01 00 00 	mov    BYTE PTR [rsp+0x147],al
  22649a:	c6 84 24 48 01 00 00 	mov    BYTE PTR [rsp+0x148],0x2
  2264a1:	02 
  2264a2:	8a 44 24 1e          	mov    al,BYTE PTR [rsp+0x1e]
  2264a6:	88 84 24 4f 01 00 00 	mov    BYTE PTR [rsp+0x14f],al
  2264ad:	0f b7 44 24 1c       	movzx  eax,WORD PTR [rsp+0x1c]
  2264b2:	66 89 84 24 4d 01 00 	mov    WORD PTR [rsp+0x14d],ax
  2264b9:	00 
  2264ba:	8b 44 24 18          	mov    eax,DWORD PTR [rsp+0x18]
  2264be:	89 84 24 49 01 00 00 	mov    DWORD PTR [rsp+0x149],eax
  2264c5:	48 8d 84 24 28 01 00 	lea    rax,[rsp+0x128]
  2264cc:	00 
  2264cd:	e9 e4 09 00 00       	jmp    226eb6 <parseFormValue+0x1a06>
  2264d2:	48 8b 4c 24 20       	mov    rcx,QWORD PTR [rsp+0x20]
  2264d7:	45 31 ed             	xor    r13d,r13d
  2264da:	48 8d 5c 24 18       	lea    rbx,[rsp+0x18]
  2264df:	31 ed                	xor    ebp,ebp
  2264e1:	48 3b 8c 24 98 00 00 	cmp    rcx,QWORD PTR [rsp+0x98]
  2264e8:	00 
  2264e9:	0f 82 90 07 00 00    	jb     226c7f <parseFormValue+0x17cf>
            return result[0];
  2264ef:	44 8a bc 24 b0 00 00 	mov    r15b,BYTE PTR [rsp+0xb0]
  2264f6:	00 
        if (byte == 0) break;
  2264f7:	45 84 ff             	test   r15b,r15b
  2264fa:	0f 84 88 07 00 00    	je     226c88 <parseFormValue+0x17d8>
            var better_capacity = self.items.len;
  226500:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
            if (better_capacity >= new_capacity) return;
  226505:	48 39 e9             	cmp    rcx,rbp
  226508:	77 4f                	ja     226559 <parseFormValue+0x10a9>
  22650a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
                better_capacity += better_capacity / 2 + 8;
  226510:	48 89 c8             	mov    rax,rcx
  226513:	48 d1 e8             	shr    rax,1
  226516:	48 01 c1             	add    rcx,rax
  226519:	48 83 c1 08          	add    rcx,0x8
                if (better_capacity >= new_capacity) break;
  22651d:	48 39 e9             	cmp    rcx,rbp
  226520:	76 ee                	jbe    226510 <parseFormValue+0x1060>
            self.items = try self.allocator.alignedRealloc(T, A, self.items, better_capacity);
  226522:	48 89 df             	mov    rdi,rbx
  226525:	48 8b b4 24 d0 00 00 	mov    rsi,QWORD PTR [rsp+0xd0]
  22652c:	00 
  22652d:	48 8d 54 24 40       	lea    rdx,[rsp+0x40]
  226532:	e8 89 47 00 00       	call   22acc0 <Allocator_alignedRealloc.188>
  226537:	0f b7 44 24 18       	movzx  eax,WORD PTR [rsp+0x18]
  22653c:	66 85 c0             	test   ax,ax
  22653f:	0f 85 08 f4 ff ff    	jne    22594d <parseFormValue+0x49d>
  226545:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  22654a:	c5 f8 10 00          	vmovups xmm0,XMMWORD PTR [rax]
  22654e:	c5 f8 29 44 24 40    	vmovaps XMMWORD PTR [rsp+0x40],xmm0
            const result = &self.items[self.len];
  226554:	4c 8b 6c 24 40       	mov    r13,QWORD PTR [rsp+0x40]
  226559:	4c 8d 75 01          	lea    r14,[rbp+0x1]
            self.len = new_length;
  22655d:	4c 89 74 24 50       	mov    QWORD PTR [rsp+0x50],r14
            new_item_ptr.* = item;
  226562:	45 88 7c 2d 00       	mov    BYTE PTR [r13+rbp*1+0x0],r15b
            try self.readNoEof(result[0..]);
  226567:	48 8d 84 24 b0 00 00 	lea    rax,[rsp+0xb0]
  22656e:	00 
  22656f:	48 89 84 24 90 00 00 	mov    QWORD PTR [rsp+0x90],rax
  226576:	00 
  226577:	48 c7 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],0x1
  22657e:	00 01 00 00 00 
            return self.readFn(self, buffer);
  226583:	48 89 df             	mov    rdi,rbx
  226586:	4c 89 e6             	mov    rsi,r12
  226589:	48 8d 94 24 90 00 00 	lea    rdx,[rsp+0x90]
  226590:	00 
  226591:	41 ff 14 24          	call   QWORD PTR [r12]
  226595:	0f b7 44 24 18       	movzx  eax,WORD PTR [rsp+0x18]
  22659a:	48 8b 4c 24 20       	mov    rcx,QWORD PTR [rsp+0x20]
  22659f:	4c 89 f5             	mov    rbp,r14
            const amt_read = try self.read(buf);
  2265a2:	66 85 c0             	test   ax,ax
  2265a5:	0f 84 36 ff ff ff    	je     2264e1 <parseFormValue+0x1031>
  2265ab:	e9 9d f3 ff ff       	jmp    22594d <parseFormValue+0x49d>
  2265b0:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  2265b5:	31 db                	xor    ebx,ebx
  2265b7:	4c 8d 7c 24 40       	lea    r15,[rsp+0x40]
  2265bc:	4c 8d 74 24 18       	lea    r14,[rsp+0x18]
  2265c1:	31 ed                	xor    ebp,ebp
            if (amt_read < buf.len) return error.EndOfStream;
  2265c3:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  2265c8:	0f 82 1f 07 00 00    	jb     226ced <parseFormValue+0x183d>
            return result[0];
  2265ce:	0f b6 84 24 b0 00 00 	movzx  eax,BYTE PTR [rsp+0xb0]
  2265d5:	00 
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  2265d6:	89 c2                	mov    edx,eax
  2265d8:	83 e2 7f             	and    edx,0x7f
  2265db:	89 ee                	mov    esi,ebp
  2265dd:	83 e6 3f             	and    esi,0x3f
  2265e0:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  2265e5:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  2265ea:	48 39 d6             	cmp    rsi,rdx
  2265ed:	0f 85 e9 08 00 00    	jne    226edc <parseFormValue+0x1a2c>
        result |= operand;
  2265f3:	48 09 cb             	or     rbx,rcx
        if ((byte & 0b10000000) == 0) return result;
  2265f6:	84 c0                	test   al,al
  2265f8:	0f 89 02 09 00 00    	jns    226f00 <parseFormValue+0x1a50>
        shift += 7;
  2265fe:	48 83 c5 07          	add    rbp,0x7
            try self.readNoEof(result[0..]);
  226602:	4c 89 6c 24 18       	mov    QWORD PTR [rsp+0x18],r13
  226607:	48 c7 44 24 20 01 00 	mov    QWORD PTR [rsp+0x20],0x1
  22660e:	00 00 
            return self.readFn(self, buffer);
  226610:	4c 89 ff             	mov    rdi,r15
  226613:	4c 89 e6             	mov    rsi,r12
  226616:	4c 89 f2             	mov    rdx,r14
  226619:	41 ff 14 24          	call   QWORD PTR [r12]
  22661d:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
  226622:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
            const amt_read = try self.read(buf);
  226627:	66 85 c0             	test   ax,ax
  22662a:	74 97                	je     2265c3 <parseFormValue+0x1113>
  22662c:	e9 85 f3 ff ff       	jmp    2259b6 <parseFormValue+0x506>
    return FormValue{
  226631:	c6 84 24 b0 00 00 00 	mov    BYTE PTR [rsp+0xb0],0x0
  226638:	00 
  226639:	c6 44 24 60 02       	mov    BYTE PTR [rsp+0x60],0x2
  22663e:	66 c7 84 24 a0 01 00 	mov    WORD PTR [rsp+0x1a0],0x0
  226645:	00 00 00 
  226648:	8b 44 24 78          	mov    eax,DWORD PTR [rsp+0x78]
  22664c:	89 84 24 a2 01 00 00 	mov    DWORD PTR [rsp+0x1a2],eax
        .Const = Constant{
  226653:	c5 f8 10 44 24 48    	vmovups xmm0,XMMWORD PTR [rsp+0x48]
    return FormValue{
  226659:	0f b7 44 24 7c       	movzx  eax,WORD PTR [rsp+0x7c]
  22665e:	66 89 84 24 a6 01 00 	mov    WORD PTR [rsp+0x1a6],ax
  226665:	00 
  226666:	c5 f8 11 84 24 a8 01 	vmovups XMMWORD PTR [rsp+0x1a8],xmm0
  22666d:	00 00 
  22666f:	c6 84 24 b8 01 00 00 	mov    BYTE PTR [rsp+0x1b8],0x0
  226676:	00 
  226677:	8b 84 24 90 00 00 00 	mov    eax,DWORD PTR [rsp+0x90]
  22667e:	89 84 24 b9 01 00 00 	mov    DWORD PTR [rsp+0x1b9],eax
  226685:	0f b7 84 24 94 00 00 	movzx  eax,WORD PTR [rsp+0x94]
  22668c:	00 
  22668d:	66 89 84 24 bd 01 00 	mov    WORD PTR [rsp+0x1bd],ax
  226694:	00 
  226695:	8a 84 24 96 00 00 00 	mov    al,BYTE PTR [rsp+0x96]
  22669c:	88 84 24 bf 01 00 00 	mov    BYTE PTR [rsp+0x1bf],al
  2266a3:	c6 84 24 c0 01 00 00 	mov    BYTE PTR [rsp+0x1c0],0x2
  2266aa:	02 
  2266ab:	8a 44 24 1e          	mov    al,BYTE PTR [rsp+0x1e]
  2266af:	88 84 24 c7 01 00 00 	mov    BYTE PTR [rsp+0x1c7],al
  2266b6:	0f b7 44 24 1c       	movzx  eax,WORD PTR [rsp+0x1c]
  2266bb:	66 89 84 24 c5 01 00 	mov    WORD PTR [rsp+0x1c5],ax
  2266c2:	00 
  2266c3:	8b 44 24 18          	mov    eax,DWORD PTR [rsp+0x18]
  2266c7:	89 84 24 c1 01 00 00 	mov    DWORD PTR [rsp+0x1c1],eax
  2266ce:	48 8d 84 24 a0 01 00 	lea    rax,[rsp+0x1a0]
  2266d5:	00 
  2266d6:	e9 db 07 00 00       	jmp    226eb6 <parseFormValue+0x1a06>
  2266db:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  2266e0:	31 db                	xor    ebx,ebx
  2266e2:	4c 8d 6c 24 40       	lea    r13,[rsp+0x40]
  2266e7:	4c 8d 7c 24 18       	lea    r15,[rsp+0x18]
  2266ec:	31 ed                	xor    ebp,ebp
            if (amt_read < buf.len) return error.EndOfStream;
  2266ee:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  2266f3:	0f 82 fd 05 00 00    	jb     226cf6 <parseFormValue+0x1846>
            return result[0];
  2266f9:	0f b6 84 24 b0 00 00 	movzx  eax,BYTE PTR [rsp+0xb0]
  226700:	00 
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  226701:	89 c2                	mov    edx,eax
  226703:	83 e2 7f             	and    edx,0x7f
  226706:	89 ee                	mov    esi,ebp
  226708:	83 e6 3f             	and    esi,0x3f
  22670b:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  226710:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  226715:	48 39 d6             	cmp    rsi,rdx
  226718:	0f 85 c7 07 00 00    	jne    226ee5 <parseFormValue+0x1a35>
        result |= operand;
  22671e:	48 09 cb             	or     rbx,rcx
        if ((byte & 0b10000000) == 0) return result;
  226721:	84 c0                	test   al,al
  226723:	0f 89 7d 08 00 00    	jns    226fa6 <parseFormValue+0x1af6>
        shift += 7;
  226729:	48 83 c5 07          	add    rbp,0x7
            try self.readNoEof(result[0..]);
  22672d:	4c 89 74 24 18       	mov    QWORD PTR [rsp+0x18],r14
  226732:	48 c7 44 24 20 01 00 	mov    QWORD PTR [rsp+0x20],0x1
  226739:	00 00 
            return self.readFn(self, buffer);
  22673b:	4c 89 ef             	mov    rdi,r13
  22673e:	4c 89 e6             	mov    rsi,r12
  226741:	4c 89 fa             	mov    rdx,r15
  226744:	41 ff 14 24          	call   QWORD PTR [r12]
  226748:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
  22674d:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
            const amt_read = try self.read(buf);
  226752:	66 85 c0             	test   ax,ax
  226755:	74 97                	je     2266ee <parseFormValue+0x123e>
  226757:	e9 08 f8 ff ff       	jmp    225f64 <parseFormValue+0xab4>
  22675c:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  226761:	45 31 f6             	xor    r14d,r14d
  226764:	4c 8d 6c 24 18       	lea    r13,[rsp+0x18]
  226769:	31 db                	xor    ebx,ebx
            if (amt_read < buf.len) return error.EndOfStream;
  22676b:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  226770:	0f 82 89 05 00 00    	jb     226cff <parseFormValue+0x184f>
            return result[0];
  226776:	0f b6 84 24 b0 00 00 	movzx  eax,BYTE PTR [rsp+0xb0]
  22677d:	00 
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  22677e:	89 c2                	mov    edx,eax
  226780:	83 e2 7f             	and    edx,0x7f
  226783:	89 de                	mov    esi,ebx
  226785:	83 e6 3f             	and    esi,0x3f
  226788:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  22678d:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  226792:	48 39 d6             	cmp    rsi,rdx
  226795:	0f 85 53 07 00 00    	jne    226eee <parseFormValue+0x1a3e>
        result |= operand;
  22679b:	49 09 ce             	or     r14,rcx
        if ((byte & 0b10000000) == 0) return result;
  22679e:	84 c0                	test   al,al
  2267a0:	0f 89 a6 08 00 00    	jns    22704c <parseFormValue+0x1b9c>
        shift += 7;
  2267a6:	48 83 c3 07          	add    rbx,0x7
            try self.readNoEof(result[0..]);
  2267aa:	4c 89 7c 24 18       	mov    QWORD PTR [rsp+0x18],r15
  2267af:	48 c7 44 24 20 01 00 	mov    QWORD PTR [rsp+0x20],0x1
  2267b6:	00 00 
            return self.readFn(self, buffer);
  2267b8:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  2267bd:	4c 89 e6             	mov    rsi,r12
  2267c0:	4c 89 ea             	mov    rdx,r13
  2267c3:	41 ff 14 24          	call   QWORD PTR [r12]
  2267c7:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
  2267cc:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
            const amt_read = try self.read(buf);
  2267d1:	66 85 c0             	test   ax,ax
  2267d4:	74 95                	je     22676b <parseFormValue+0x12bb>
  2267d6:	e9 f2 f7 ff ff       	jmp    225fcd <parseFormValue+0xb1d>
  2267db:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  2267e0:	31 db                	xor    ebx,ebx
  2267e2:	4c 8d 6c 24 40       	lea    r13,[rsp+0x40]
  2267e7:	4c 8d 7c 24 18       	lea    r15,[rsp+0x18]
  2267ec:	31 ed                	xor    ebp,ebp
            if (amt_read < buf.len) return error.EndOfStream;
  2267ee:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  2267f3:	0f 82 0f 05 00 00    	jb     226d08 <parseFormValue+0x1858>
            return result[0];
  2267f9:	0f b6 84 24 b0 00 00 	movzx  eax,BYTE PTR [rsp+0xb0]
  226800:	00 
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  226801:	89 c2                	mov    edx,eax
  226803:	83 e2 7f             	and    edx,0x7f
  226806:	89 ee                	mov    esi,ebp
  226808:	83 e6 3f             	and    esi,0x3f
  22680b:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  226810:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  226815:	48 39 d6             	cmp    rsi,rdx
  226818:	0f 85 d9 06 00 00    	jne    226ef7 <parseFormValue+0x1a47>
        result |= operand;
  22681e:	48 09 cb             	or     rbx,rcx
        if ((byte & 0b10000000) == 0) return result;
  226821:	84 c0                	test   al,al
  226823:	0f 89 65 08 00 00    	jns    22708e <parseFormValue+0x1bde>
        shift += 7;
  226829:	48 83 c5 07          	add    rbp,0x7
            try self.readNoEof(result[0..]);
  22682d:	4c 89 74 24 18       	mov    QWORD PTR [rsp+0x18],r14
  226832:	48 c7 44 24 20 01 00 	mov    QWORD PTR [rsp+0x20],0x1
  226839:	00 00 
            return self.readFn(self, buffer);
  22683b:	4c 89 ef             	mov    rdi,r13
  22683e:	4c 89 e6             	mov    rsi,r12
  226841:	4c 89 fa             	mov    rdx,r15
  226844:	41 ff 14 24          	call   QWORD PTR [r12]
  226848:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
  22684d:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
            const amt_read = try self.read(buf);
  226852:	66 85 c0             	test   ax,ax
  226855:	74 97                	je     2267ee <parseFormValue+0x133e>
  226857:	e9 3a f8 ff ff       	jmp    226096 <parseFormValue+0xbe6>
  22685c:	66 b8 25 00          	mov    ax,0x25
  226860:	e9 d2 ec ff ff       	jmp    225537 <parseFormValue+0x87>
  226865:	66 b8 29 00          	mov    ax,0x29
  226869:	e9 c9 ec ff ff       	jmp    225537 <parseFormValue+0x87>
  22686e:	48 8b 44 24 78       	mov    rax,QWORD PTR [rsp+0x78]
        DW.FORM_addr => FormValue{ .Address = try parseFormValueTargetAddrSize(in_stream) },
  226873:	66 c7 84 24 08 04 00 	mov    WORD PTR [rsp+0x408],0x0
  22687a:	00 00 00 
  22687d:	48 89 84 24 10 04 00 	mov    QWORD PTR [rsp+0x410],rax
  226884:	00 
  226885:	c5 f8 10 84 24 08 05 	vmovups xmm0,XMMWORD PTR [rsp+0x508]
  22688c:	00 00 
  22688e:	c5 f8 11 84 24 18 04 	vmovups XMMWORD PTR [rsp+0x418],xmm0
  226895:	00 00 
  226897:	c6 84 24 28 04 00 00 	mov    BYTE PTR [rsp+0x428],0x0
  22689e:	00 
  22689f:	8b 84 24 11 03 00 00 	mov    eax,DWORD PTR [rsp+0x311]
  2268a6:	89 84 24 29 04 00 00 	mov    DWORD PTR [rsp+0x429],eax
  2268ad:	0f b7 84 24 15 03 00 	movzx  eax,WORD PTR [rsp+0x315]
  2268b4:	00 
  2268b5:	66 89 84 24 2d 04 00 	mov    WORD PTR [rsp+0x42d],ax
  2268bc:	00 
  2268bd:	8a 84 24 17 03 00 00 	mov    al,BYTE PTR [rsp+0x317]
  2268c4:	88 84 24 2f 04 00 00 	mov    BYTE PTR [rsp+0x42f],al
  2268cb:	48 8d 84 24 08 04 00 	lea    rax,[rsp+0x408]
  2268d2:	00 
  2268d3:	e9 de 05 00 00       	jmp    226eb6 <parseFormValue+0x1a06>
  2268d8:	48 85 c0             	test   rax,rax
            for (bytes) |b, index| {
  2268db:	0f 84 00 08 00 00    	je     2270e1 <parseFormValue+0x1c31>
  2268e1:	48 8b 54 24 18       	mov    rdx,QWORD PTR [rsp+0x18]
  2268e6:	48 83 f8 10          	cmp    rax,0x10
  2268ea:	0f 83 cc 0b 00 00    	jae    2274bc <parseFormValue+0x200c>
  2268f0:	31 db                	xor    ebx,ebx
  2268f2:	31 c9                	xor    ecx,ecx
  2268f4:	e9 b7 11 00 00       	jmp    227ab0 <parseFormValue+0x2600>
  2268f9:	48 85 c0             	test   rax,rax
  2268fc:	0f 84 e6 07 00 00    	je     2270e8 <parseFormValue+0x1c38>
  226902:	48 8b 54 24 18       	mov    rdx,QWORD PTR [rsp+0x18]
  226907:	48 83 f8 10          	cmp    rax,0x10
  22690b:	0f 83 c9 0c 00 00    	jae    2275da <parseFormValue+0x212a>
  226911:	31 db                	xor    ebx,ebx
  226913:	31 c9                	xor    ecx,ecx
  226915:	e9 77 13 00 00       	jmp    227c91 <parseFormValue+0x27e1>
  22691a:	48 85 c0             	test   rax,rax
  22691d:	0f 84 cc 07 00 00    	je     2270ef <parseFormValue+0x1c3f>
  226923:	48 8b 54 24 18       	mov    rdx,QWORD PTR [rsp+0x18]
  226928:	48 83 f8 10          	cmp    rax,0x10
  22692c:	0f 83 c6 0d 00 00    	jae    2276f8 <parseFormValue+0x2248>
  226932:	31 db                	xor    ebx,ebx
  226934:	31 c9                	xor    ecx,ecx
  226936:	e9 37 15 00 00       	jmp    227e72 <parseFormValue+0x29c2>
        DW.FORM_flag => FormValue{ .Flag = (try in_stream.readByte()) != 0 },
  22693b:	80 bc 24 b0 00 00 00 	cmp    BYTE PTR [rsp+0xb0],0x0
  226942:	00 
  226943:	0f 95 84 24 08 01 00 	setne  BYTE PTR [rsp+0x108]
  22694a:	00 
  22694b:	66 c7 84 24 18 03 00 	mov    WORD PTR [rsp+0x318],0x0
  226952:	00 00 00 
  226955:	0f 95 84 24 20 03 00 	setne  BYTE PTR [rsp+0x320]
  22695c:	00 
  22695d:	c5 f8 10 84 24 69 04 	vmovups xmm0,XMMWORD PTR [rsp+0x469]
  226964:	00 00 
  226966:	c5 f8 11 84 24 21 03 	vmovups XMMWORD PTR [rsp+0x321],xmm0
  22696d:	00 00 
  22696f:	48 8b 84 24 78 04 00 	mov    rax,QWORD PTR [rsp+0x478]
  226976:	00 
  226977:	48 89 84 24 30 03 00 	mov    QWORD PTR [rsp+0x330],rax
  22697e:	00 
  22697f:	c6 84 24 38 03 00 00 	mov    BYTE PTR [rsp+0x338],0x4
  226986:	04 
  226987:	8b 84 24 03 03 00 00 	mov    eax,DWORD PTR [rsp+0x303]
  22698e:	89 84 24 39 03 00 00 	mov    DWORD PTR [rsp+0x339],eax
  226995:	0f b7 84 24 07 03 00 	movzx  eax,WORD PTR [rsp+0x307]
  22699c:	00 
  22699d:	66 89 84 24 3d 03 00 	mov    WORD PTR [rsp+0x33d],ax
  2269a4:	00 
  2269a5:	8a 84 24 09 03 00 00 	mov    al,BYTE PTR [rsp+0x309]
  2269ac:	88 84 24 3f 03 00 00 	mov    BYTE PTR [rsp+0x33f],al
  2269b3:	48 8d 84 24 18 03 00 	lea    rax,[rsp+0x318]
  2269ba:	00 
  2269bb:	e9 f6 04 00 00       	jmp    226eb6 <parseFormValue+0x1a06>
            return mem.readInt(bytes, T, endian);
  2269c0:	0f b6 8c 24 b0 00 00 	movzx  ecx,BYTE PTR [rsp+0xb0]
  2269c7:	00 
  2269c8:	48 8d 7c 24 78       	lea    rdi,[rsp+0x78]
    const buf = try readAllocBytes(allocator, in_stream, size);
  2269cd:	4c 89 fe             	mov    rsi,r15
  2269d0:	4c 89 e2             	mov    rdx,r12
  2269d3:	e8 78 18 00 00       	call   228250 <readAllocBytes>
  2269d8:	0f b7 44 24 78       	movzx  eax,WORD PTR [rsp+0x78]
  2269dd:	66 85 c0             	test   ax,ax
  2269e0:	0f 84 10 07 00 00    	je     2270f6 <parseFormValue+0x1c46>
  2269e6:	c5 f8 10 44 24 40    	vmovups xmm0,XMMWORD PTR [rsp+0x40]
  2269ec:	c5 fa 6f 4c 24 4e    	vmovdqu xmm1,XMMWORD PTR [rsp+0x4e]
  2269f2:	c5 fa 7f 8c 24 9e 00 	vmovdqu XMMWORD PTR [rsp+0x9e],xmm1
  2269f9:	00 00 
  2269fb:	c5 f8 29 84 24 90 00 	vmovaps XMMWORD PTR [rsp+0x90],xmm0
  226a02:	00 00 
  226a04:	8b 4c 24 60          	mov    ecx,DWORD PTR [rsp+0x60]
  226a08:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  226a0b:	0f b7 4c 24 64       	movzx  ecx,WORD PTR [rsp+0x64]
  226a10:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  226a15:	8a 4c 24 66          	mov    cl,BYTE PTR [rsp+0x66]
  226a19:	88 4c 24 06          	mov    BYTE PTR [rsp+0x6],cl
  226a1d:	e9 39 07 00 00       	jmp    22715b <parseFormValue+0x1cab>
  226a22:	0f b6 44 24 78       	movzx  eax,BYTE PTR [rsp+0x78]
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  226a27:	0f b6 4c 24 79       	movzx  ecx,BYTE PTR [rsp+0x79]
  226a2c:	48 c1 e1 08          	shl    rcx,0x8
  226a30:	48 09 c1             	or     rcx,rax
  226a33:	48 8d 7c 24 78       	lea    rdi,[rsp+0x78]
  226a38:	4c 89 fe             	mov    rsi,r15
  226a3b:	4c 89 e2             	mov    rdx,r12
  226a3e:	e8 0d 18 00 00       	call   228250 <readAllocBytes>
  226a43:	0f b7 44 24 78       	movzx  eax,WORD PTR [rsp+0x78]
  226a48:	66 85 c0             	test   ax,ax
  226a4b:	0f 84 5d 07 00 00    	je     2271ae <parseFormValue+0x1cfe>
  226a51:	c5 f8 10 44 24 40    	vmovups xmm0,XMMWORD PTR [rsp+0x40]
  226a57:	c5 fa 6f 4c 24 4e    	vmovdqu xmm1,XMMWORD PTR [rsp+0x4e]
  226a5d:	c5 fa 7f 8c 24 9e 00 	vmovdqu XMMWORD PTR [rsp+0x9e],xmm1
  226a64:	00 00 
  226a66:	c5 f8 29 84 24 90 00 	vmovaps XMMWORD PTR [rsp+0x90],xmm0
  226a6d:	00 00 
  226a6f:	8b 4c 24 60          	mov    ecx,DWORD PTR [rsp+0x60]
  226a73:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  226a76:	0f b7 4c 24 64       	movzx  ecx,WORD PTR [rsp+0x64]
  226a7b:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  226a80:	8a 4c 24 66          	mov    cl,BYTE PTR [rsp+0x66]
  226a84:	88 4c 24 06          	mov    BYTE PTR [rsp+0x6],cl
  226a88:	e9 86 07 00 00       	jmp    227213 <parseFormValue+0x1d63>
  226a8d:	0f b6 44 24 78       	movzx  eax,BYTE PTR [rsp+0x78]
  226a92:	0f b6 4c 24 79       	movzx  ecx,BYTE PTR [rsp+0x79]
  226a97:	48 c1 e1 08          	shl    rcx,0x8
  226a9b:	48 09 c1             	or     rcx,rax
  226a9e:	0f b6 44 24 7a       	movzx  eax,BYTE PTR [rsp+0x7a]
  226aa3:	48 c1 e0 10          	shl    rax,0x10
  226aa7:	48 09 c8             	or     rax,rcx
  226aaa:	0f b6 4c 24 7b       	movzx  ecx,BYTE PTR [rsp+0x7b]
  226aaf:	48 c1 e1 18          	shl    rcx,0x18
  226ab3:	48 09 c1             	or     rcx,rax
  226ab6:	48 8d 7c 24 78       	lea    rdi,[rsp+0x78]
  226abb:	4c 89 fe             	mov    rsi,r15
  226abe:	4c 89 e2             	mov    rdx,r12
  226ac1:	e8 8a 17 00 00       	call   228250 <readAllocBytes>
  226ac6:	0f b7 44 24 78       	movzx  eax,WORD PTR [rsp+0x78]
  226acb:	66 85 c0             	test   ax,ax
  226ace:	0f 84 92 07 00 00    	je     227266 <parseFormValue+0x1db6>
  226ad4:	c5 f8 10 44 24 40    	vmovups xmm0,XMMWORD PTR [rsp+0x40]
  226ada:	c5 fa 6f 4c 24 4e    	vmovdqu xmm1,XMMWORD PTR [rsp+0x4e]
  226ae0:	c5 fa 7f 8c 24 9e 00 	vmovdqu XMMWORD PTR [rsp+0x9e],xmm1
  226ae7:	00 00 
  226ae9:	c5 f8 29 84 24 90 00 	vmovaps XMMWORD PTR [rsp+0x90],xmm0
  226af0:	00 00 
  226af2:	8b 4c 24 60          	mov    ecx,DWORD PTR [rsp+0x60]
  226af6:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  226af9:	0f b7 4c 24 64       	movzx  ecx,WORD PTR [rsp+0x64]
  226afe:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  226b03:	8a 4c 24 66          	mov    cl,BYTE PTR [rsp+0x66]
  226b07:	88 4c 24 06          	mov    BYTE PTR [rsp+0x6],cl
  226b0b:	e9 bb 07 00 00       	jmp    2272cb <parseFormValue+0x1e1b>
  226b10:	48 8b 4c 24 78       	mov    rcx,QWORD PTR [rsp+0x78]
  226b15:	48 8d 7c 24 78       	lea    rdi,[rsp+0x78]
  226b1a:	4c 89 fe             	mov    rsi,r15
  226b1d:	4c 89 e2             	mov    rdx,r12
  226b20:	e8 2b 17 00 00       	call   228250 <readAllocBytes>
  226b25:	0f b7 44 24 78       	movzx  eax,WORD PTR [rsp+0x78]
  226b2a:	66 85 c0             	test   ax,ax
  226b2d:	0f 84 eb 07 00 00    	je     22731e <parseFormValue+0x1e6e>
  226b33:	c5 f8 10 44 24 40    	vmovups xmm0,XMMWORD PTR [rsp+0x40]
  226b39:	c5 fa 6f 4c 24 4e    	vmovdqu xmm1,XMMWORD PTR [rsp+0x4e]
  226b3f:	c5 fa 7f 8c 24 9e 00 	vmovdqu XMMWORD PTR [rsp+0x9e],xmm1
  226b46:	00 00 
  226b48:	c5 f8 29 84 24 90 00 	vmovaps XMMWORD PTR [rsp+0x90],xmm0
  226b4f:	00 00 
  226b51:	8b 4c 24 60          	mov    ecx,DWORD PTR [rsp+0x60]
  226b55:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  226b58:	0f b7 4c 24 64       	movzx  ecx,WORD PTR [rsp+0x64]
  226b5d:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  226b62:	8a 4c 24 66          	mov    cl,BYTE PTR [rsp+0x66]
  226b66:	88 4c 24 06          	mov    BYTE PTR [rsp+0x6],cl
  226b6a:	e9 14 08 00 00       	jmp    227383 <parseFormValue+0x1ed3>
  226b6f:	48 8b 44 24 78       	mov    rax,QWORD PTR [rsp+0x78]
        DW.FORM_ref_sig8 => FormValue{ .RefSig8 = try in_stream.readIntLe(u64) },
  226b74:	66 c7 84 24 90 03 00 	mov    WORD PTR [rsp+0x390],0x0
  226b7b:	00 00 00 
  226b7e:	48 89 84 24 98 03 00 	mov    QWORD PTR [rsp+0x398],rax
  226b85:	00 
  226b86:	c5 f8 10 84 24 d8 04 	vmovups xmm0,XMMWORD PTR [rsp+0x4d8]
  226b8d:	00 00 
  226b8f:	c5 f8 11 84 24 a0 03 	vmovups XMMWORD PTR [rsp+0x3a0],xmm0
  226b96:	00 00 
  226b98:	c6 84 24 b0 03 00 00 	mov    BYTE PTR [rsp+0x3b0],0x8
  226b9f:	08 
  226ba0:	8b 84 24 ee 02 00 00 	mov    eax,DWORD PTR [rsp+0x2ee]
  226ba7:	89 84 24 b1 03 00 00 	mov    DWORD PTR [rsp+0x3b1],eax
  226bae:	0f b7 84 24 f2 02 00 	movzx  eax,WORD PTR [rsp+0x2f2]
  226bb5:	00 
  226bb6:	66 89 84 24 b5 03 00 	mov    WORD PTR [rsp+0x3b5],ax
  226bbd:	00 
  226bbe:	8a 84 24 f4 02 00 00 	mov    al,BYTE PTR [rsp+0x2f4]
  226bc5:	88 84 24 b7 03 00 00 	mov    BYTE PTR [rsp+0x3b7],al
  226bcc:	48 8d 84 24 90 03 00 	lea    rax,[rsp+0x390]
  226bd3:	00 
  226bd4:	e9 dd 02 00 00       	jmp    226eb6 <parseFormValue+0x1a06>
  226bd9:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
            .payload = try readAllocBytes(allocator, in_stream, size),
  226bde:	48 8b b4 24 d0 00 00 	mov    rsi,QWORD PTR [rsp+0xd0]
  226be5:	00 
  226be6:	4c 89 e2             	mov    rdx,r12
  226be9:	48 89 e9             	mov    rcx,rbp
  226bec:	e8 5f 16 00 00       	call   228250 <readAllocBytes>
  226bf1:	0f b7 54 24 40       	movzx  edx,WORD PTR [rsp+0x40]
  226bf6:	66 85 d2             	test   dx,dx
  226bf9:	48 8b 6c 24 68       	mov    rbp,QWORD PTR [rsp+0x68]
  226bfe:	0f 84 d2 07 00 00    	je     2273d6 <parseFormValue+0x1f26>
  226c04:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  226c09:	66 89 84 24 1c 01 00 	mov    WORD PTR [rsp+0x11c],ax
  226c10:	00 
  226c11:	8b 44 24 3a          	mov    eax,DWORD PTR [rsp+0x3a]
  226c15:	89 84 24 18 01 00 00 	mov    DWORD PTR [rsp+0x118],eax
  226c1c:	8b 44 24 11          	mov    eax,DWORD PTR [rsp+0x11]
  226c20:	89 84 24 f0 00 00 00 	mov    DWORD PTR [rsp+0xf0],eax
  226c27:	0f b7 44 24 15       	movzx  eax,WORD PTR [rsp+0x15]
  226c2c:	66 89 84 24 f4 00 00 	mov    WORD PTR [rsp+0xf4],ax
  226c33:	00 
  226c34:	8a 44 24 17          	mov    al,BYTE PTR [rsp+0x17]
  226c38:	88 84 24 f6 00 00 00 	mov    BYTE PTR [rsp+0xf6],al
  226c3f:	48 8d b4 24 18 01 00 	lea    rsi,[rsp+0x118]
  226c46:	00 
  226c47:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  226c4b:	89 84 24 e8 00 00 00 	mov    DWORD PTR [rsp+0xe8],eax
  226c52:	48 8d 84 24 f0 00 00 	lea    rax,[rsp+0xf0]
  226c59:	00 
  226c5a:	0f b7 4c 24 0e       	movzx  ecx,WORD PTR [rsp+0xe]
  226c5f:	66 89 8c 24 ec 00 00 	mov    WORD PTR [rsp+0xec],cx
  226c66:	00 
  226c67:	48 8d 8c 24 e8 00 00 	lea    rcx,[rsp+0xe8]
  226c6e:	00 
  226c6f:	8a 5c 24 10          	mov    bl,BYTE PTR [rsp+0x10]
  226c73:	88 9c 24 ee 00 00 00 	mov    BYTE PTR [rsp+0xee],bl
  226c7a:	e9 f5 07 00 00       	jmp    227474 <parseFormValue+0x1fc4>
  226c7f:	66 b8 25 00          	mov    ax,0x25
  226c83:	e9 c5 ec ff ff       	jmp    22594d <parseFormValue+0x49d>
            return self.items[0..self.len];
  226c88:	48 8b 44 24 40       	mov    rax,QWORD PTR [rsp+0x40]
        DW.FORM_string => FormValue{ .String = try readStringRaw(allocator, in_stream) },
  226c8d:	66 c7 84 24 68 03 00 	mov    WORD PTR [rsp+0x368],0x0
  226c94:	00 00 00 
  226c97:	48 89 84 24 70 03 00 	mov    QWORD PTR [rsp+0x370],rax
  226c9e:	00 
  226c9f:	48 89 ac 24 78 03 00 	mov    QWORD PTR [rsp+0x378],rbp
  226ca6:	00 
  226ca7:	c6 84 24 88 03 00 00 	mov    BYTE PTR [rsp+0x388],0x9
  226cae:	09 
  226caf:	8b 84 24 e7 02 00 00 	mov    eax,DWORD PTR [rsp+0x2e7]
  226cb6:	89 84 24 89 03 00 00 	mov    DWORD PTR [rsp+0x389],eax
  226cbd:	0f b7 84 24 eb 02 00 	movzx  eax,WORD PTR [rsp+0x2eb]
  226cc4:	00 
  226cc5:	66 89 84 24 8d 03 00 	mov    WORD PTR [rsp+0x38d],ax
  226ccc:	00 
  226ccd:	8a 84 24 ed 02 00 00 	mov    al,BYTE PTR [rsp+0x2ed]
  226cd4:	88 84 24 8f 03 00 00 	mov    BYTE PTR [rsp+0x38f],al
  226cdb:	48 8d 84 24 68 03 00 	lea    rax,[rsp+0x368]
  226ce2:	00 
  226ce3:	4c 8b 74 24 68       	mov    r14,QWORD PTR [rsp+0x68]
  226ce8:	e9 c9 01 00 00       	jmp    226eb6 <parseFormValue+0x1a06>
  226ced:	66 b8 25 00          	mov    ax,0x25
  226cf1:	e9 c0 ec ff ff       	jmp    2259b6 <parseFormValue+0x506>
  226cf6:	66 b8 25 00          	mov    ax,0x25
  226cfa:	e9 65 f2 ff ff       	jmp    225f64 <parseFormValue+0xab4>
  226cff:	66 b8 25 00          	mov    ax,0x25
  226d03:	e9 c5 f2 ff ff       	jmp    225fcd <parseFormValue+0xb1d>
  226d08:	66 b8 25 00          	mov    ax,0x25
  226d0c:	e9 85 f3 ff ff       	jmp    226096 <parseFormValue+0xbe6>
  226d11:	0f b6 44 24 78       	movzx  eax,BYTE PTR [rsp+0x78]
  226d16:	0f b6 4c 24 79       	movzx  ecx,BYTE PTR [rsp+0x79]
  226d1b:	48 c1 e1 08          	shl    rcx,0x8
  226d1f:	48 09 c1             	or     rcx,rax
  226d22:	0f b6 54 24 7a       	movzx  edx,BYTE PTR [rsp+0x7a]
  226d27:	48 c1 e2 10          	shl    rdx,0x10
  226d2b:	48 09 ca             	or     rdx,rcx
  226d2e:	0f b6 44 24 7b       	movzx  eax,BYTE PTR [rsp+0x7b]
  226d33:	48 c1 e0 18          	shl    rax,0x18
  226d37:	48 09 d0             	or     rax,rdx
        DW.FORM_strp => FormValue{ .StrPtr = try parseFormValueDwarfOffsetSize(in_stream, is_64) },
  226d3a:	66 c7 84 24 40 03 00 	mov    WORD PTR [rsp+0x340],0x0
  226d41:	00 00 00 
  226d44:	48 89 84 24 48 03 00 	mov    QWORD PTR [rsp+0x348],rax
  226d4b:	00 
  226d4c:	c5 f8 10 84 24 c8 04 	vmovups xmm0,XMMWORD PTR [rsp+0x4c8]
  226d53:	00 00 
  226d55:	c5 f8 11 84 24 50 03 	vmovups XMMWORD PTR [rsp+0x350],xmm0
  226d5c:	00 00 
  226d5e:	c6 84 24 60 03 00 00 	mov    BYTE PTR [rsp+0x360],0xa
  226d65:	0a 
  226d66:	8b 84 24 e0 02 00 00 	mov    eax,DWORD PTR [rsp+0x2e0]
  226d6d:	89 84 24 61 03 00 00 	mov    DWORD PTR [rsp+0x361],eax
  226d74:	0f b7 84 24 e4 02 00 	movzx  eax,WORD PTR [rsp+0x2e4]
  226d7b:	00 
  226d7c:	66 89 84 24 65 03 00 	mov    WORD PTR [rsp+0x365],ax
  226d83:	00 
  226d84:	8a 84 24 e6 02 00 00 	mov    al,BYTE PTR [rsp+0x2e6]
  226d8b:	88 84 24 67 03 00 00 	mov    BYTE PTR [rsp+0x367],al
  226d92:	48 8d 84 24 40 03 00 	lea    rax,[rsp+0x340]
  226d99:	00 
  226d9a:	e9 17 01 00 00       	jmp    226eb6 <parseFormValue+0x1a06>
  226d9f:	0f b6 44 24 78       	movzx  eax,BYTE PTR [rsp+0x78]
  226da4:	0f b6 4c 24 79       	movzx  ecx,BYTE PTR [rsp+0x79]
  226da9:	48 c1 e1 08          	shl    rcx,0x8
  226dad:	48 09 c1             	or     rcx,rax
  226db0:	0f b6 54 24 7a       	movzx  edx,BYTE PTR [rsp+0x7a]
  226db5:	48 c1 e2 10          	shl    rdx,0x10
  226db9:	48 09 ca             	or     rdx,rcx
  226dbc:	0f b6 44 24 7b       	movzx  eax,BYTE PTR [rsp+0x7b]
  226dc1:	48 c1 e0 18          	shl    rax,0x18
  226dc5:	48 09 d0             	or     rax,rdx
        DW.FORM_ref_addr => FormValue{ .RefAddr = try parseFormValueDwarfOffsetSize(in_stream, is_64) },
  226dc8:	66 c7 84 24 b8 03 00 	mov    WORD PTR [rsp+0x3b8],0x0
  226dcf:	00 00 00 
  226dd2:	48 89 84 24 c0 03 00 	mov    QWORD PTR [rsp+0x3c0],rax
  226dd9:	00 
  226dda:	c5 f8 10 84 24 e8 04 	vmovups xmm0,XMMWORD PTR [rsp+0x4e8]
  226de1:	00 00 
  226de3:	c5 f8 11 84 24 c8 03 	vmovups XMMWORD PTR [rsp+0x3c8],xmm0
  226dea:	00 00 
  226dec:	c6 84 24 d8 03 00 00 	mov    BYTE PTR [rsp+0x3d8],0x7
  226df3:	07 
  226df4:	8b 84 24 f5 02 00 00 	mov    eax,DWORD PTR [rsp+0x2f5]
  226dfb:	89 84 24 d9 03 00 00 	mov    DWORD PTR [rsp+0x3d9],eax
  226e02:	0f b7 84 24 f9 02 00 	movzx  eax,WORD PTR [rsp+0x2f9]
  226e09:	00 
  226e0a:	66 89 84 24 dd 03 00 	mov    WORD PTR [rsp+0x3dd],ax
  226e11:	00 
  226e12:	8a 84 24 fb 02 00 00 	mov    al,BYTE PTR [rsp+0x2fb]
  226e19:	88 84 24 df 03 00 00 	mov    BYTE PTR [rsp+0x3df],al
  226e20:	48 8d 84 24 b8 03 00 	lea    rax,[rsp+0x3b8]
  226e27:	00 
  226e28:	e9 89 00 00 00       	jmp    226eb6 <parseFormValue+0x1a06>
  226e2d:	0f b6 44 24 78       	movzx  eax,BYTE PTR [rsp+0x78]
  226e32:	0f b6 4c 24 79       	movzx  ecx,BYTE PTR [rsp+0x79]
  226e37:	48 c1 e1 08          	shl    rcx,0x8
  226e3b:	48 09 c1             	or     rcx,rax
  226e3e:	0f b6 54 24 7a       	movzx  edx,BYTE PTR [rsp+0x7a]
  226e43:	48 c1 e2 10          	shl    rdx,0x10
  226e47:	48 09 ca             	or     rdx,rcx
  226e4a:	0f b6 44 24 7b       	movzx  eax,BYTE PTR [rsp+0x7b]
  226e4f:	48 c1 e0 18          	shl    rax,0x18
  226e53:	48 09 d0             	or     rax,rdx
        DW.FORM_sec_offset => FormValue{ .SecOffset = try parseFormValueDwarfOffsetSize(in_stream, is_64) },
  226e56:	66 c7 84 24 e0 03 00 	mov    WORD PTR [rsp+0x3e0],0x0
  226e5d:	00 00 00 
  226e60:	48 89 84 24 e8 03 00 	mov    QWORD PTR [rsp+0x3e8],rax
  226e67:	00 
  226e68:	c5 f8 10 84 24 f8 04 	vmovups xmm0,XMMWORD PTR [rsp+0x4f8]
  226e6f:	00 00 
  226e71:	c5 f8 11 84 24 f0 03 	vmovups XMMWORD PTR [rsp+0x3f0],xmm0
  226e78:	00 00 
  226e7a:	c6 84 24 00 04 00 00 	mov    BYTE PTR [rsp+0x400],0x5
  226e81:	05 
  226e82:	8b 84 24 fc 02 00 00 	mov    eax,DWORD PTR [rsp+0x2fc]
  226e89:	89 84 24 01 04 00 00 	mov    DWORD PTR [rsp+0x401],eax
  226e90:	0f b7 84 24 00 03 00 	movzx  eax,WORD PTR [rsp+0x300]
  226e97:	00 
  226e98:	66 89 84 24 05 04 00 	mov    WORD PTR [rsp+0x405],ax
  226e9f:	00 
  226ea0:	8a 84 24 02 03 00 00 	mov    al,BYTE PTR [rsp+0x302]
  226ea7:	88 84 24 07 04 00 00 	mov    BYTE PTR [rsp+0x407],al
  226eae:	48 8d 84 24 e0 03 00 	lea    rax,[rsp+0x3e0]
  226eb5:	00 
    return switch (form_id) {
  226eb6:	48 8b 48 20          	mov    rcx,QWORD PTR [rax+0x20]
  226eba:	49 89 4e 20          	mov    QWORD PTR [r14+0x20],rcx
  226ebe:	c5 fc 10 00          	vmovups ymm0,YMMWORD PTR [rax]
  226ec2:	c4 c1 7c 11 06       	vmovups YMMWORD PTR [r14],ymm0
  226ec7:	48 81 c4 08 07 00 00 	add    rsp,0x708
  226ece:	5b                   	pop    rbx
  226ecf:	41 5c                	pop    r12
  226ed1:	41 5d                	pop    r13
  226ed3:	41 5e                	pop    r14
  226ed5:	41 5f                	pop    r15
  226ed7:	5d                   	pop    rbp
  226ed8:	c5 f8 77             	vzeroupper 
  226edb:	c3                   	ret    
  226edc:	66 b8 29 00          	mov    ax,0x29
  226ee0:	e9 d1 ea ff ff       	jmp    2259b6 <parseFormValue+0x506>
  226ee5:	66 b8 29 00          	mov    ax,0x29
  226ee9:	e9 76 f0 ff ff       	jmp    225f64 <parseFormValue+0xab4>
  226eee:	66 b8 29 00          	mov    ax,0x29
  226ef2:	e9 d6 f0 ff ff       	jmp    225fcd <parseFormValue+0xb1d>
  226ef7:	66 b8 29 00          	mov    ax,0x29
  226efb:	e9 96 f1 ff ff       	jmp    226096 <parseFormValue+0xbe6>
  226f00:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
    const buf = try readAllocBytes(allocator, in_stream, size);
  226f05:	48 8b b4 24 d0 00 00 	mov    rsi,QWORD PTR [rsp+0xd0]
  226f0c:	00 
  226f0d:	4c 89 e2             	mov    rdx,r12
  226f10:	48 89 d9             	mov    rcx,rbx
  226f13:	e8 38 13 00 00       	call   228250 <readAllocBytes>
  226f18:	0f b7 4c 24 40       	movzx  ecx,WORD PTR [rsp+0x40]
  226f1d:	66 85 c9             	test   cx,cx
  226f20:	48 8b 7c 24 68       	mov    rdi,QWORD PTR [rsp+0x68]
  226f25:	0f 84 eb 08 00 00    	je     227816 <parseFormValue+0x2366>
  226f2b:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  226f30:	66 89 84 24 24 01 00 	mov    WORD PTR [rsp+0x124],ax
  226f37:	00 
  226f38:	8b 44 24 3a          	mov    eax,DWORD PTR [rsp+0x3a]
  226f3c:	89 84 24 20 01 00 00 	mov    DWORD PTR [rsp+0x120],eax
  226f43:	8b 44 24 11          	mov    eax,DWORD PTR [rsp+0x11]
  226f47:	89 84 24 00 01 00 00 	mov    DWORD PTR [rsp+0x100],eax
  226f4e:	0f b7 44 24 15       	movzx  eax,WORD PTR [rsp+0x15]
  226f53:	66 89 84 24 04 01 00 	mov    WORD PTR [rsp+0x104],ax
  226f5a:	00 
  226f5b:	8a 44 24 17          	mov    al,BYTE PTR [rsp+0x17]
  226f5f:	88 84 24 06 01 00 00 	mov    BYTE PTR [rsp+0x106],al
  226f66:	48 8d b4 24 20 01 00 	lea    rsi,[rsp+0x120]
  226f6d:	00 
  226f6e:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  226f72:	89 84 24 f8 00 00 00 	mov    DWORD PTR [rsp+0xf8],eax
  226f79:	48 8d 84 24 00 01 00 	lea    rax,[rsp+0x100]
  226f80:	00 
  226f81:	0f b7 54 24 0e       	movzx  edx,WORD PTR [rsp+0xe]
  226f86:	66 89 94 24 fc 00 00 	mov    WORD PTR [rsp+0xfc],dx
  226f8d:	00 
  226f8e:	48 8d 94 24 f8 00 00 	lea    rdx,[rsp+0xf8]
  226f95:	00 
  226f96:	8a 5c 24 10          	mov    bl,BYTE PTR [rsp+0x10]
  226f9a:	88 9c 24 fe 00 00 00 	mov    BYTE PTR [rsp+0xfe],bl
  226fa1:	e9 a1 00 00 00       	jmp    227047 <parseFormValue+0x1b97>
  226fa6:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
    const buf = try readAllocBytes(allocator, in_stream, size);
  226fab:	48 8b b4 24 d0 00 00 	mov    rsi,QWORD PTR [rsp+0xd0]
  226fb2:	00 
  226fb3:	4c 89 e2             	mov    rdx,r12
  226fb6:	48 89 d9             	mov    rcx,rbx
  226fb9:	e8 92 12 00 00       	call   228250 <readAllocBytes>
  226fbe:	0f b7 4c 24 40       	movzx  ecx,WORD PTR [rsp+0x40]
  226fc3:	66 85 c9             	test   cx,cx
  226fc6:	48 8b 7c 24 68       	mov    rdi,QWORD PTR [rsp+0x68]
  226fcb:	0f 84 d9 08 00 00    	je     2278aa <parseFormValue+0x23fa>
  226fd1:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  226fd6:	66 89 84 24 14 01 00 	mov    WORD PTR [rsp+0x114],ax
  226fdd:	00 
  226fde:	8b 44 24 3a          	mov    eax,DWORD PTR [rsp+0x3a]
  226fe2:	89 84 24 10 01 00 00 	mov    DWORD PTR [rsp+0x110],eax
  226fe9:	8b 44 24 11          	mov    eax,DWORD PTR [rsp+0x11]
  226fed:	89 84 24 e0 00 00 00 	mov    DWORD PTR [rsp+0xe0],eax
  226ff4:	0f b7 44 24 15       	movzx  eax,WORD PTR [rsp+0x15]
  226ff9:	66 89 84 24 e4 00 00 	mov    WORD PTR [rsp+0xe4],ax
  227000:	00 
  227001:	8a 44 24 17          	mov    al,BYTE PTR [rsp+0x17]
  227005:	88 84 24 e6 00 00 00 	mov    BYTE PTR [rsp+0xe6],al
  22700c:	48 8d b4 24 10 01 00 	lea    rsi,[rsp+0x110]
  227013:	00 
  227014:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  227018:	89 84 24 d8 00 00 00 	mov    DWORD PTR [rsp+0xd8],eax
  22701f:	48 8d 84 24 e0 00 00 	lea    rax,[rsp+0xe0]
  227026:	00 
  227027:	0f b7 54 24 0e       	movzx  edx,WORD PTR [rsp+0xe]
  22702c:	66 89 94 24 dc 00 00 	mov    WORD PTR [rsp+0xdc],dx
  227033:	00 
  227034:	48 8d 94 24 d8 00 00 	lea    rdx,[rsp+0xd8]
  22703b:	00 
  22703c:	8a 5c 24 10          	mov    bl,BYTE PTR [rsp+0x10]
  227040:	88 9c 24 de 00 00 00 	mov    BYTE PTR [rsp+0xde],bl
  227047:	e9 ef 08 00 00       	jmp    22793b <parseFormValue+0x248b>
            return parseFormValue(allocator, in_stream, child_form_id, is_64);
  22704c:	44 0f b6 c5          	movzx  r8d,bpl
  227050:	48 8d bc 24 a0 04 00 	lea    rdi,[rsp+0x4a0]
  227057:	00 
  227058:	48 8b b4 24 d0 00 00 	mov    rsi,QWORD PTR [rsp+0xd0]
  22705f:	00 
  227060:	4c 89 e2             	mov    rdx,r12
  227063:	4c 89 f1             	mov    rcx,r14
  227066:	e8 45 e4 ff ff       	call   2254b0 <parseFormValue>
  22706b:	48 8b 84 24 c0 04 00 	mov    rax,QWORD PTR [rsp+0x4c0]
  227072:	00 
  227073:	48 8b 4c 24 68       	mov    rcx,QWORD PTR [rsp+0x68]
  227078:	48 89 41 20          	mov    QWORD PTR [rcx+0x20],rax
  22707c:	c5 fc 10 84 24 a0 04 	vmovups ymm0,YMMWORD PTR [rsp+0x4a0]
  227083:	00 00 
  227085:	c5 fc 11 01          	vmovups YMMWORD PTR [rcx],ymm0
  227089:	e9 39 fe ff ff       	jmp    226ec7 <parseFormValue+0x1a17>
  22708e:	48 8d bc 24 50 04 00 	lea    rdi,[rsp+0x450]
  227095:	00 
            const buf = try readAllocBytes(allocator, in_stream, size);
  227096:	48 8b b4 24 d0 00 00 	mov    rsi,QWORD PTR [rsp+0xd0]
  22709d:	00 
  22709e:	4c 89 e2             	mov    rdx,r12
  2270a1:	48 89 d9             	mov    rcx,rbx
  2270a4:	e8 a7 11 00 00       	call   228250 <readAllocBytes>
  2270a9:	0f b7 84 24 50 04 00 	movzx  eax,WORD PTR [rsp+0x450]
  2270b0:	00 
  2270b1:	66 85 c0             	test   ax,ax
  2270b4:	0f 84 c4 08 00 00    	je     22797e <parseFormValue+0x24ce>
  2270ba:	48 8b 4c 24 68       	mov    rcx,QWORD PTR [rsp+0x68]
  2270bf:	66 89 01             	mov    WORD PTR [rcx],ax
  2270c2:	48 8b 84 24 68 06 00 	mov    rax,QWORD PTR [rsp+0x668]
  2270c9:	00 
  2270ca:	48 89 41 20          	mov    QWORD PTR [rcx+0x20],rax
  2270ce:	c5 fc 10 84 24 4a 06 	vmovups ymm0,YMMWORD PTR [rsp+0x64a]
  2270d5:	00 00 
  2270d7:	c5 fc 11 41 02       	vmovups YMMWORD PTR [rcx+0x2],ymm0
  2270dc:	e9 e6 fd ff ff       	jmp    226ec7 <parseFormValue+0x1a17>
  2270e1:	31 c9                	xor    ecx,ecx
  2270e3:	e9 f1 09 00 00       	jmp    227ad9 <parseFormValue+0x2629>
  2270e8:	31 c9                	xor    ecx,ecx
  2270ea:	e9 cb 0b 00 00       	jmp    227cba <parseFormValue+0x280a>
  2270ef:	31 c9                	xor    ecx,ecx
  2270f1:	e9 a5 0d 00 00       	jmp    227e9b <parseFormValue+0x29eb>
    const buf = try readAllocBytes(allocator, in_stream, size);
  2270f6:	c5 f8 10 84 24 80 00 	vmovups xmm0,XMMWORD PTR [rsp+0x80]
  2270fd:	00 00 
  2270ff:	c5 f8 29 84 24 b0 00 	vmovaps XMMWORD PTR [rsp+0xb0],xmm0
  227106:	00 00 
    return FormValue{ .Ref = buf };
  227108:	c5 f8 11 44 24 1e    	vmovups XMMWORD PTR [rsp+0x1e],xmm0
  22710e:	48 8b 84 24 c0 00 00 	mov    rax,QWORD PTR [rsp+0xc0]
  227115:	00 
  227116:	48 89 44 24 2e       	mov    QWORD PTR [rsp+0x2e],rax
  22711b:	c6 44 24 08 06       	mov    BYTE PTR [rsp+0x8],0x6
  227120:	8b 44 24 71          	mov    eax,DWORD PTR [rsp+0x71]
  227124:	89 04 24             	mov    DWORD PTR [rsp],eax
  227127:	0f b7 44 24 75       	movzx  eax,WORD PTR [rsp+0x75]
  22712c:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  227131:	8a 44 24 77          	mov    al,BYTE PTR [rsp+0x77]
  227135:	88 44 24 06          	mov    BYTE PTR [rsp+0x6],al
  227139:	c5 f8 10 44 24 18    	vmovups xmm0,XMMWORD PTR [rsp+0x18]
  22713f:	c5 f8 29 84 24 90 00 	vmovaps XMMWORD PTR [rsp+0x90],xmm0
  227146:	00 00 
  227148:	c5 f8 10 44 24 26    	vmovups xmm0,XMMWORD PTR [rsp+0x26]
  22714e:	c5 f8 11 84 24 9e 00 	vmovups XMMWORD PTR [rsp+0x9e],xmm0
  227155:	00 00 
  227157:	b1 06                	mov    cl,0x6
  227159:	31 c0                	xor    eax,eax
    return parseFormValueRefLen(allocator, in_stream, block_len);
  22715b:	66 89 84 24 40 02 00 	mov    WORD PTR [rsp+0x240],ax
  227162:	00 
  227163:	c5 f8 28 84 24 90 00 	vmovaps xmm0,XMMWORD PTR [rsp+0x90]
  22716a:	00 00 
  22716c:	c5 f8 11 84 24 42 02 	vmovups XMMWORD PTR [rsp+0x242],xmm0
  227173:	00 00 
  227175:	c5 f8 10 84 24 9e 00 	vmovups xmm0,XMMWORD PTR [rsp+0x9e]
  22717c:	00 00 
  22717e:	c5 f8 11 84 24 50 02 	vmovups XMMWORD PTR [rsp+0x250],xmm0
  227185:	00 00 
  227187:	88 8c 24 60 02 00 00 	mov    BYTE PTR [rsp+0x260],cl
  22718e:	8b 04 24             	mov    eax,DWORD PTR [rsp]
  227191:	89 84 24 61 02 00 00 	mov    DWORD PTR [rsp+0x261],eax
  227198:	0f b7 44 24 04       	movzx  eax,WORD PTR [rsp+0x4]
  22719d:	66 89 84 24 65 02 00 	mov    WORD PTR [rsp+0x265],ax
  2271a4:	00 
  2271a5:	8a 44 24 06          	mov    al,BYTE PTR [rsp+0x6]
  2271a9:	e9 41 eb ff ff       	jmp    225cef <parseFormValue+0x83f>
    const buf = try readAllocBytes(allocator, in_stream, size);
  2271ae:	c5 f8 10 84 24 80 00 	vmovups xmm0,XMMWORD PTR [rsp+0x80]
  2271b5:	00 00 
  2271b7:	c5 f8 29 84 24 b0 00 	vmovaps XMMWORD PTR [rsp+0xb0],xmm0
  2271be:	00 00 
    return FormValue{ .Ref = buf };
  2271c0:	c5 f8 11 44 24 1e    	vmovups XMMWORD PTR [rsp+0x1e],xmm0
  2271c6:	48 8b 84 24 c0 00 00 	mov    rax,QWORD PTR [rsp+0xc0]
  2271cd:	00 
  2271ce:	48 89 44 24 2e       	mov    QWORD PTR [rsp+0x2e],rax
  2271d3:	c6 44 24 08 06       	mov    BYTE PTR [rsp+0x8],0x6
  2271d8:	8b 44 24 71          	mov    eax,DWORD PTR [rsp+0x71]
  2271dc:	89 04 24             	mov    DWORD PTR [rsp],eax
  2271df:	0f b7 44 24 75       	movzx  eax,WORD PTR [rsp+0x75]
  2271e4:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  2271e9:	8a 44 24 77          	mov    al,BYTE PTR [rsp+0x77]
  2271ed:	88 44 24 06          	mov    BYTE PTR [rsp+0x6],al
  2271f1:	c5 f8 10 44 24 18    	vmovups xmm0,XMMWORD PTR [rsp+0x18]
  2271f7:	c5 f8 29 84 24 90 00 	vmovaps XMMWORD PTR [rsp+0x90],xmm0
  2271fe:	00 00 
  227200:	c5 f8 10 44 24 26    	vmovups xmm0,XMMWORD PTR [rsp+0x26]
  227206:	c5 f8 11 84 24 9e 00 	vmovups XMMWORD PTR [rsp+0x9e],xmm0
  22720d:	00 00 
  22720f:	b1 06                	mov    cl,0x6
  227211:	31 c0                	xor    eax,eax
    return parseFormValueRefLen(allocator, in_stream, block_len);
  227213:	66 89 84 24 18 02 00 	mov    WORD PTR [rsp+0x218],ax
  22721a:	00 
  22721b:	c5 f8 28 84 24 90 00 	vmovaps xmm0,XMMWORD PTR [rsp+0x90]
  227222:	00 00 
  227224:	c5 f8 11 84 24 1a 02 	vmovups XMMWORD PTR [rsp+0x21a],xmm0
  22722b:	00 00 
  22722d:	c5 f8 10 84 24 9e 00 	vmovups xmm0,XMMWORD PTR [rsp+0x9e]
  227234:	00 00 
  227236:	c5 f8 11 84 24 28 02 	vmovups XMMWORD PTR [rsp+0x228],xmm0
  22723d:	00 00 
  22723f:	88 8c 24 38 02 00 00 	mov    BYTE PTR [rsp+0x238],cl
  227246:	8b 04 24             	mov    eax,DWORD PTR [rsp]
  227249:	89 84 24 39 02 00 00 	mov    DWORD PTR [rsp+0x239],eax
  227250:	0f b7 44 24 04       	movzx  eax,WORD PTR [rsp+0x4]
  227255:	66 89 84 24 3d 02 00 	mov    WORD PTR [rsp+0x23d],ax
  22725c:	00 
  22725d:	8a 44 24 06          	mov    al,BYTE PTR [rsp+0x6]
  227261:	e9 3e eb ff ff       	jmp    225da4 <parseFormValue+0x8f4>
    const buf = try readAllocBytes(allocator, in_stream, size);
  227266:	c5 f8 10 84 24 80 00 	vmovups xmm0,XMMWORD PTR [rsp+0x80]
  22726d:	00 00 
  22726f:	c5 f8 29 84 24 b0 00 	vmovaps XMMWORD PTR [rsp+0xb0],xmm0
  227276:	00 00 
    return FormValue{ .Ref = buf };
  227278:	c5 f8 11 44 24 1e    	vmovups XMMWORD PTR [rsp+0x1e],xmm0
  22727e:	48 8b 84 24 c0 00 00 	mov    rax,QWORD PTR [rsp+0xc0]
  227285:	00 
  227286:	48 89 44 24 2e       	mov    QWORD PTR [rsp+0x2e],rax
  22728b:	c6 44 24 08 06       	mov    BYTE PTR [rsp+0x8],0x6
  227290:	8b 44 24 71          	mov    eax,DWORD PTR [rsp+0x71]
  227294:	89 04 24             	mov    DWORD PTR [rsp],eax
  227297:	0f b7 44 24 75       	movzx  eax,WORD PTR [rsp+0x75]
  22729c:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  2272a1:	8a 44 24 77          	mov    al,BYTE PTR [rsp+0x77]
  2272a5:	88 44 24 06          	mov    BYTE PTR [rsp+0x6],al
  2272a9:	c5 f8 10 44 24 18    	vmovups xmm0,XMMWORD PTR [rsp+0x18]
  2272af:	c5 f8 29 84 24 90 00 	vmovaps XMMWORD PTR [rsp+0x90],xmm0
  2272b6:	00 00 
  2272b8:	c5 f8 10 44 24 26    	vmovups xmm0,XMMWORD PTR [rsp+0x26]
  2272be:	c5 f8 11 84 24 9e 00 	vmovups XMMWORD PTR [rsp+0x9e],xmm0
  2272c5:	00 00 
  2272c7:	b1 06                	mov    cl,0x6
  2272c9:	31 c0                	xor    eax,eax
    return parseFormValueRefLen(allocator, in_stream, block_len);
  2272cb:	66 89 84 24 f0 01 00 	mov    WORD PTR [rsp+0x1f0],ax
  2272d2:	00 
  2272d3:	c5 f8 28 84 24 90 00 	vmovaps xmm0,XMMWORD PTR [rsp+0x90]
  2272da:	00 00 
  2272dc:	c5 f8 11 84 24 f2 01 	vmovups XMMWORD PTR [rsp+0x1f2],xmm0
  2272e3:	00 00 
  2272e5:	c5 f8 10 84 24 9e 00 	vmovups xmm0,XMMWORD PTR [rsp+0x9e]
  2272ec:	00 00 
  2272ee:	c5 f8 11 84 24 00 02 	vmovups XMMWORD PTR [rsp+0x200],xmm0
  2272f5:	00 00 
  2272f7:	88 8c 24 10 02 00 00 	mov    BYTE PTR [rsp+0x210],cl
  2272fe:	8b 04 24             	mov    eax,DWORD PTR [rsp]
  227301:	89 84 24 11 02 00 00 	mov    DWORD PTR [rsp+0x211],eax
  227308:	0f b7 44 24 04       	movzx  eax,WORD PTR [rsp+0x4]
  22730d:	66 89 84 24 15 02 00 	mov    WORD PTR [rsp+0x215],ax
  227314:	00 
  227315:	8a 44 24 06          	mov    al,BYTE PTR [rsp+0x6]
  227319:	e9 3b eb ff ff       	jmp    225e59 <parseFormValue+0x9a9>
    const buf = try readAllocBytes(allocator, in_stream, size);
  22731e:	c5 f8 10 84 24 80 00 	vmovups xmm0,XMMWORD PTR [rsp+0x80]
  227325:	00 00 
  227327:	c5 f8 29 84 24 b0 00 	vmovaps XMMWORD PTR [rsp+0xb0],xmm0
  22732e:	00 00 
    return FormValue{ .Ref = buf };
  227330:	c5 f8 11 44 24 1e    	vmovups XMMWORD PTR [rsp+0x1e],xmm0
  227336:	48 8b 84 24 c0 00 00 	mov    rax,QWORD PTR [rsp+0xc0]
  22733d:	00 
  22733e:	48 89 44 24 2e       	mov    QWORD PTR [rsp+0x2e],rax
  227343:	c6 44 24 08 06       	mov    BYTE PTR [rsp+0x8],0x6
  227348:	8b 44 24 71          	mov    eax,DWORD PTR [rsp+0x71]
  22734c:	89 04 24             	mov    DWORD PTR [rsp],eax
  22734f:	0f b7 44 24 75       	movzx  eax,WORD PTR [rsp+0x75]
  227354:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  227359:	8a 44 24 77          	mov    al,BYTE PTR [rsp+0x77]
  22735d:	88 44 24 06          	mov    BYTE PTR [rsp+0x6],al
  227361:	c5 f8 10 44 24 18    	vmovups xmm0,XMMWORD PTR [rsp+0x18]
  227367:	c5 f8 29 84 24 90 00 	vmovaps XMMWORD PTR [rsp+0x90],xmm0
  22736e:	00 00 
  227370:	c5 f8 10 44 24 26    	vmovups xmm0,XMMWORD PTR [rsp+0x26]
  227376:	c5 f8 11 84 24 9e 00 	vmovups XMMWORD PTR [rsp+0x9e],xmm0
  22737d:	00 00 
  22737f:	b1 06                	mov    cl,0x6
  227381:	31 c0                	xor    eax,eax
    return parseFormValueRefLen(allocator, in_stream, block_len);
  227383:	66 89 84 24 c8 01 00 	mov    WORD PTR [rsp+0x1c8],ax
  22738a:	00 
  22738b:	c5 f8 28 84 24 90 00 	vmovaps xmm0,XMMWORD PTR [rsp+0x90]
  227392:	00 00 
  227394:	c5 f8 11 84 24 ca 01 	vmovups XMMWORD PTR [rsp+0x1ca],xmm0
  22739b:	00 00 
  22739d:	c5 f8 10 84 24 9e 00 	vmovups xmm0,XMMWORD PTR [rsp+0x9e]
  2273a4:	00 00 
  2273a6:	c5 f8 11 84 24 d8 01 	vmovups XMMWORD PTR [rsp+0x1d8],xmm0
  2273ad:	00 00 
  2273af:	88 8c 24 e8 01 00 00 	mov    BYTE PTR [rsp+0x1e8],cl
  2273b6:	8b 04 24             	mov    eax,DWORD PTR [rsp]
  2273b9:	89 84 24 e9 01 00 00 	mov    DWORD PTR [rsp+0x1e9],eax
  2273c0:	0f b7 44 24 04       	movzx  eax,WORD PTR [rsp+0x4]
  2273c5:	66 89 84 24 ed 01 00 	mov    WORD PTR [rsp+0x1ed],ax
  2273cc:	00 
  2273cd:	8a 44 24 06          	mov    al,BYTE PTR [rsp+0x6]
  2273d1:	e9 38 eb ff ff       	jmp    225f0e <parseFormValue+0xa5e>
            const signed = form_id == DW.FORM_sdata;
  2273d6:	48 83 fb 0d          	cmp    rbx,0xd
    return FormValue{
  2273da:	0f 94 84 24 b0 00 00 	sete   BYTE PTR [rsp+0xb0]
  2273e1:	00 
  2273e2:	c6 44 24 60 02       	mov    BYTE PTR [rsp+0x60],0x2
  2273e7:	8b 44 24 78          	mov    eax,DWORD PTR [rsp+0x78]
  2273eb:	89 84 24 18 01 00 00 	mov    DWORD PTR [rsp+0x118],eax
            const signed = form_id == DW.FORM_sdata;
  2273f2:	40 0f 94 c7          	sete   dil
    return FormValue{
  2273f6:	0f b7 44 24 7c       	movzx  eax,WORD PTR [rsp+0x7c]
  2273fb:	66 89 84 24 1c 01 00 	mov    WORD PTR [rsp+0x11c],ax
  227402:	00 
        .Const = Constant{
  227403:	c5 f8 10 44 24 48    	vmovups xmm0,XMMWORD PTR [rsp+0x48]
    return FormValue{
  227409:	8b 84 24 90 00 00 00 	mov    eax,DWORD PTR [rsp+0x90]
  227410:	89 84 24 f0 00 00 00 	mov    DWORD PTR [rsp+0xf0],eax
  227417:	48 8d b4 24 18 01 00 	lea    rsi,[rsp+0x118]
  22741e:	00 
  22741f:	0f b7 84 24 94 00 00 	movzx  eax,WORD PTR [rsp+0x94]
  227426:	00 
  227427:	66 89 84 24 f4 00 00 	mov    WORD PTR [rsp+0xf4],ax
  22742e:	00 
  22742f:	48 8d 84 24 f0 00 00 	lea    rax,[rsp+0xf0]
  227436:	00 
  227437:	8a 8c 24 96 00 00 00 	mov    cl,BYTE PTR [rsp+0x96]
  22743e:	88 8c 24 f6 00 00 00 	mov    BYTE PTR [rsp+0xf6],cl
  227445:	b3 02                	mov    bl,0x2
  227447:	8b 4c 24 18          	mov    ecx,DWORD PTR [rsp+0x18]
  22744b:	89 8c 24 e8 00 00 00 	mov    DWORD PTR [rsp+0xe8],ecx
  227452:	48 8d 8c 24 e8 00 00 	lea    rcx,[rsp+0xe8]
  227459:	00 
  22745a:	0f b7 54 24 1c       	movzx  edx,WORD PTR [rsp+0x1c]
  22745f:	66 89 94 24 ec 00 00 	mov    WORD PTR [rsp+0xec],dx
  227466:	00 
  227467:	8a 54 24 1e          	mov    dl,BYTE PTR [rsp+0x1e]
  22746b:	88 94 24 ee 00 00 00 	mov    BYTE PTR [rsp+0xee],dl
  227472:	31 d2                	xor    edx,edx
            return parseFormValueConstant(allocator, in_stream, signed, block_len);
  227474:	66 89 55 00          	mov    WORD PTR [rbp+0x0],dx
  227478:	0f b7 56 04          	movzx  edx,WORD PTR [rsi+0x4]
  22747c:	66 89 55 06          	mov    WORD PTR [rbp+0x6],dx
  227480:	8b 16                	mov    edx,DWORD PTR [rsi]
  227482:	89 55 02             	mov    DWORD PTR [rbp+0x2],edx
  227485:	c5 f8 11 45 08       	vmovups XMMWORD PTR [rbp+0x8],xmm0
  22748a:	40 88 7d 18          	mov    BYTE PTR [rbp+0x18],dil
  22748e:	8a 50 06             	mov    dl,BYTE PTR [rax+0x6]
  227491:	88 55 1f             	mov    BYTE PTR [rbp+0x1f],dl
  227494:	0f b7 50 04          	movzx  edx,WORD PTR [rax+0x4]
  227498:	66 89 55 1d          	mov    WORD PTR [rbp+0x1d],dx
  22749c:	8b 00                	mov    eax,DWORD PTR [rax]
  22749e:	89 45 19             	mov    DWORD PTR [rbp+0x19],eax
  2274a1:	88 5d 20             	mov    BYTE PTR [rbp+0x20],bl
  2274a4:	0f b7 41 04          	movzx  eax,WORD PTR [rcx+0x4]
  2274a8:	66 89 45 25          	mov    WORD PTR [rbp+0x25],ax
  2274ac:	8b 01                	mov    eax,DWORD PTR [rcx]
  2274ae:	89 45 21             	mov    DWORD PTR [rbp+0x21],eax
  2274b1:	8a 41 06             	mov    al,BYTE PTR [rcx+0x6]
  2274b4:	88 45 27             	mov    BYTE PTR [rbp+0x27],al
  2274b7:	e9 0b fa ff ff       	jmp    226ec7 <parseFormValue+0x1a17>
            for (bytes) |b, index| {
  2274bc:	48 89 c3             	mov    rbx,rax
  2274bf:	48 83 e3 f0          	and    rbx,0xfffffffffffffff0
  2274c3:	48 8d 6b f0          	lea    rbp,[rbx-0x10]
  2274c7:	48 89 e9             	mov    rcx,rbp
  2274ca:	48 c1 e9 04          	shr    rcx,0x4
  2274ce:	8d 79 01             	lea    edi,[rcx+0x1]
  2274d1:	83 e7 01             	and    edi,0x1
  2274d4:	48 85 ed             	test   rbp,rbp
  2274d7:	0f 84 29 05 00 00    	je     227a06 <parseFormValue+0x2556>
  2274dd:	48 8d 6f ff          	lea    rbp,[rdi-0x1]
  2274e1:	48 29 cd             	sub    rbp,rcx
  2274e4:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  2274e8:	c5 fd 6f 0d b0 8c fd 	vmovdqa ymm1,YMMWORD PTR [rip+0xfffffffffffd8cb0]        # 2001a0 <__unnamed_44-0x60>
  2274ef:	ff 
  2274f0:	31 c9                	xor    ecx,ecx
  2274f2:	c4 e2 7d 59 2d 15 8e 	vpbroadcastq ymm5,QWORD PTR [rip+0xfffffffffffd8e15]        # 200310 <__unnamed_610+0x10>
  2274f9:	fd ff 
  2274fb:	c4 e2 7d 59 35 84 8e 	vpbroadcastq ymm6,QWORD PTR [rip+0xfffffffffffd8e84]        # 200388 <__unnamed_609+0x48>
  227502:	fd ff 
  227504:	c4 e2 7d 59 3d 6b 8e 	vpbroadcastq ymm7,QWORD PTR [rip+0xfffffffffffd8e6b]        # 200378 <__unnamed_609+0x38>
  22750b:	fd ff 
  22750d:	c4 62 7d 59 05 92 8d 	vpbroadcastq ymm8,QWORD PTR [rip+0xfffffffffffd8d92]        # 2002a8 <__unnamed_10+0x28>
  227514:	fd ff 
  227516:	c5 e1 ef db          	vpxor  xmm3,xmm3,xmm3
  22751a:	c5 d9 ef e4          	vpxor  xmm4,xmm4,xmm4
  22751e:	c5 e9 ef d2          	vpxor  xmm2,xmm2,xmm2
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  227522:	c4 62 7d 32 0c 0a    	vpmovzxbq ymm9,DWORD PTR [rdx+rcx*1]
  227528:	c4 62 7d 32 54 0a 04 	vpmovzxbq ymm10,DWORD PTR [rdx+rcx*1+0x4]
  22752f:	c4 62 7d 32 5c 0a 08 	vpmovzxbq ymm11,DWORD PTR [rdx+rcx*1+0x8]
  227536:	c4 62 7d 32 64 0a 0c 	vpmovzxbq ymm12,DWORD PTR [rdx+rcx*1+0xc]
  22753d:	c5 95 73 f1 03       	vpsllq ymm13,ymm1,0x3
  227542:	c5 15 d4 f5          	vpaddq ymm14,ymm13,ymm5
  227546:	c5 15 db fe          	vpand  ymm15,ymm13,ymm6
  22754a:	c5 0d db f6          	vpand  ymm14,ymm14,ymm6
  22754e:	c4 42 b5 47 cf       	vpsllvq ymm9,ymm9,ymm15
  227553:	c5 b5 eb c0          	vpor   ymm0,ymm9,ymm0
  227557:	c4 42 ad 47 ce       	vpsllvq ymm9,ymm10,ymm14
  22755c:	c5 b5 eb db          	vpor   ymm3,ymm9,ymm3
  227560:	c4 42 a5 47 cf       	vpsllvq ymm9,ymm11,ymm15
  227565:	c5 b5 eb e4          	vpor   ymm4,ymm9,ymm4
  227569:	c4 42 9d 47 ce       	vpsllvq ymm9,ymm12,ymm14
  22756e:	c4 62 7d 32 54 0a 10 	vpmovzxbq ymm10,DWORD PTR [rdx+rcx*1+0x10]
  227575:	c4 62 7d 32 5c 0a 14 	vpmovzxbq ymm11,DWORD PTR [rdx+rcx*1+0x14]
  22757c:	c4 62 7d 32 64 0a 18 	vpmovzxbq ymm12,DWORD PTR [rdx+rcx*1+0x18]
  227583:	c4 62 7d 32 74 0a 1c 	vpmovzxbq ymm14,DWORD PTR [rdx+rcx*1+0x1c]
  22758a:	c5 b5 eb d2          	vpor   ymm2,ymm9,ymm2
  22758e:	c5 15 d4 cf          	vpaddq ymm9,ymm13,ymm7
  227592:	c4 41 15 d4 e8       	vpaddq ymm13,ymm13,ymm8
  227597:	c5 35 db ce          	vpand  ymm9,ymm9,ymm6
  22759b:	c5 15 db ee          	vpand  ymm13,ymm13,ymm6
  22759f:	c4 42 ad 47 d1       	vpsllvq ymm10,ymm10,ymm9
  2275a4:	c5 ad eb c0          	vpor   ymm0,ymm10,ymm0
  2275a8:	c4 42 a5 47 d5       	vpsllvq ymm10,ymm11,ymm13
  2275ad:	c5 ad eb db          	vpor   ymm3,ymm10,ymm3
  2275b1:	c4 42 9d 47 c9       	vpsllvq ymm9,ymm12,ymm9
  2275b6:	c5 b5 eb e4          	vpor   ymm4,ymm9,ymm4
  2275ba:	c4 42 8d 47 cd       	vpsllvq ymm9,ymm14,ymm13
  2275bf:	c5 b5 eb d2          	vpor   ymm2,ymm9,ymm2
            for (bytes) |b, index| {
  2275c3:	48 83 c1 20          	add    rcx,0x20
  2275c7:	c5 f5 d4 cd          	vpaddq ymm1,ymm1,ymm5
  2275cb:	48 83 c5 02          	add    rbp,0x2
  2275cf:	0f 85 4d ff ff ff    	jne    227522 <parseFormValue+0x2072>
  2275d5:	e9 46 04 00 00       	jmp    227a20 <parseFormValue+0x2570>
  2275da:	48 89 c3             	mov    rbx,rax
  2275dd:	48 83 e3 f0          	and    rbx,0xfffffffffffffff0
  2275e1:	48 8d 6b f0          	lea    rbp,[rbx-0x10]
  2275e5:	48 89 e9             	mov    rcx,rbp
  2275e8:	48 c1 e9 04          	shr    rcx,0x4
  2275ec:	8d 79 01             	lea    edi,[rcx+0x1]
  2275ef:	83 e7 01             	and    edi,0x1
  2275f2:	48 85 ed             	test   rbp,rbp
  2275f5:	0f 84 ec 05 00 00    	je     227be7 <parseFormValue+0x2737>
  2275fb:	48 8d 6f ff          	lea    rbp,[rdi-0x1]
  2275ff:	48 29 cd             	sub    rbp,rcx
  227602:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  227606:	c5 fd 6f 0d 92 8b fd 	vmovdqa ymm1,YMMWORD PTR [rip+0xfffffffffffd8b92]        # 2001a0 <__unnamed_44-0x60>
  22760d:	ff 
  22760e:	31 c9                	xor    ecx,ecx
  227610:	c4 e2 7d 59 2d f7 8c 	vpbroadcastq ymm5,QWORD PTR [rip+0xfffffffffffd8cf7]        # 200310 <__unnamed_610+0x10>
  227617:	fd ff 
  227619:	c4 e2 7d 59 35 66 8d 	vpbroadcastq ymm6,QWORD PTR [rip+0xfffffffffffd8d66]        # 200388 <__unnamed_609+0x48>
  227620:	fd ff 
  227622:	c4 e2 7d 59 3d 4d 8d 	vpbroadcastq ymm7,QWORD PTR [rip+0xfffffffffffd8d4d]        # 200378 <__unnamed_609+0x38>
  227629:	fd ff 
  22762b:	c4 62 7d 59 05 74 8c 	vpbroadcastq ymm8,QWORD PTR [rip+0xfffffffffffd8c74]        # 2002a8 <__unnamed_10+0x28>
  227632:	fd ff 
  227634:	c5 e1 ef db          	vpxor  xmm3,xmm3,xmm3
  227638:	c5 d9 ef e4          	vpxor  xmm4,xmm4,xmm4
  22763c:	c5 e9 ef d2          	vpxor  xmm2,xmm2,xmm2
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  227640:	c4 62 7d 32 0c 0a    	vpmovzxbq ymm9,DWORD PTR [rdx+rcx*1]
  227646:	c4 62 7d 32 54 0a 04 	vpmovzxbq ymm10,DWORD PTR [rdx+rcx*1+0x4]
  22764d:	c4 62 7d 32 5c 0a 08 	vpmovzxbq ymm11,DWORD PTR [rdx+rcx*1+0x8]
  227654:	c4 62 7d 32 64 0a 0c 	vpmovzxbq ymm12,DWORD PTR [rdx+rcx*1+0xc]
  22765b:	c5 95 73 f1 03       	vpsllq ymm13,ymm1,0x3
  227660:	c5 15 d4 f5          	vpaddq ymm14,ymm13,ymm5
  227664:	c5 15 db fe          	vpand  ymm15,ymm13,ymm6
  227668:	c5 0d db f6          	vpand  ymm14,ymm14,ymm6
  22766c:	c4 42 b5 47 cf       	vpsllvq ymm9,ymm9,ymm15
  227671:	c5 b5 eb c0          	vpor   ymm0,ymm9,ymm0
  227675:	c4 42 ad 47 ce       	vpsllvq ymm9,ymm10,ymm14
  22767a:	c5 b5 eb db          	vpor   ymm3,ymm9,ymm3
  22767e:	c4 42 a5 47 cf       	vpsllvq ymm9,ymm11,ymm15
  227683:	c5 b5 eb e4          	vpor   ymm4,ymm9,ymm4
  227687:	c4 42 9d 47 ce       	vpsllvq ymm9,ymm12,ymm14
  22768c:	c4 62 7d 32 54 0a 10 	vpmovzxbq ymm10,DWORD PTR [rdx+rcx*1+0x10]
  227693:	c4 62 7d 32 5c 0a 14 	vpmovzxbq ymm11,DWORD PTR [rdx+rcx*1+0x14]
  22769a:	c4 62 7d 32 64 0a 18 	vpmovzxbq ymm12,DWORD PTR [rdx+rcx*1+0x18]
  2276a1:	c4 62 7d 32 74 0a 1c 	vpmovzxbq ymm14,DWORD PTR [rdx+rcx*1+0x1c]
  2276a8:	c5 b5 eb d2          	vpor   ymm2,ymm9,ymm2
  2276ac:	c5 15 d4 cf          	vpaddq ymm9,ymm13,ymm7
  2276b0:	c4 41 15 d4 e8       	vpaddq ymm13,ymm13,ymm8
  2276b5:	c5 35 db ce          	vpand  ymm9,ymm9,ymm6
  2276b9:	c5 15 db ee          	vpand  ymm13,ymm13,ymm6
  2276bd:	c4 42 ad 47 d1       	vpsllvq ymm10,ymm10,ymm9
  2276c2:	c5 ad eb c0          	vpor   ymm0,ymm10,ymm0
  2276c6:	c4 42 a5 47 d5       	vpsllvq ymm10,ymm11,ymm13
  2276cb:	c5 ad eb db          	vpor   ymm3,ymm10,ymm3
  2276cf:	c4 42 9d 47 c9       	vpsllvq ymm9,ymm12,ymm9
  2276d4:	c5 b5 eb e4          	vpor   ymm4,ymm9,ymm4
  2276d8:	c4 42 8d 47 cd       	vpsllvq ymm9,ymm14,ymm13
  2276dd:	c5 b5 eb d2          	vpor   ymm2,ymm9,ymm2
            for (bytes) |b, index| {
  2276e1:	48 83 c1 20          	add    rcx,0x20
  2276e5:	c5 f5 d4 cd          	vpaddq ymm1,ymm1,ymm5
  2276e9:	48 83 c5 02          	add    rbp,0x2
  2276ed:	0f 85 4d ff ff ff    	jne    227640 <parseFormValue+0x2190>
  2276f3:	e9 09 05 00 00       	jmp    227c01 <parseFormValue+0x2751>
  2276f8:	48 89 c3             	mov    rbx,rax
  2276fb:	48 83 e3 f0          	and    rbx,0xfffffffffffffff0
  2276ff:	48 8d 6b f0          	lea    rbp,[rbx-0x10]
  227703:	48 89 e9             	mov    rcx,rbp
  227706:	48 c1 e9 04          	shr    rcx,0x4
  22770a:	8d 79 01             	lea    edi,[rcx+0x1]
  22770d:	83 e7 01             	and    edi,0x1
  227710:	48 85 ed             	test   rbp,rbp
  227713:	0f 84 af 06 00 00    	je     227dc8 <parseFormValue+0x2918>
  227719:	48 8d 6f ff          	lea    rbp,[rdi-0x1]
  22771d:	48 29 cd             	sub    rbp,rcx
  227720:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  227724:	c5 fd 6f 0d 74 8a fd 	vmovdqa ymm1,YMMWORD PTR [rip+0xfffffffffffd8a74]        # 2001a0 <__unnamed_44-0x60>
  22772b:	ff 
  22772c:	31 c9                	xor    ecx,ecx
  22772e:	c4 e2 7d 59 2d d9 8b 	vpbroadcastq ymm5,QWORD PTR [rip+0xfffffffffffd8bd9]        # 200310 <__unnamed_610+0x10>
  227735:	fd ff 
  227737:	c4 e2 7d 59 35 48 8c 	vpbroadcastq ymm6,QWORD PTR [rip+0xfffffffffffd8c48]        # 200388 <__unnamed_609+0x48>
  22773e:	fd ff 
  227740:	c4 e2 7d 59 3d 2f 8c 	vpbroadcastq ymm7,QWORD PTR [rip+0xfffffffffffd8c2f]        # 200378 <__unnamed_609+0x38>
  227747:	fd ff 
  227749:	c4 62 7d 59 05 56 8b 	vpbroadcastq ymm8,QWORD PTR [rip+0xfffffffffffd8b56]        # 2002a8 <__unnamed_10+0x28>
  227750:	fd ff 
  227752:	c5 e1 ef db          	vpxor  xmm3,xmm3,xmm3
  227756:	c5 d9 ef e4          	vpxor  xmm4,xmm4,xmm4
  22775a:	c5 e9 ef d2          	vpxor  xmm2,xmm2,xmm2
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  22775e:	c4 62 7d 32 0c 0a    	vpmovzxbq ymm9,DWORD PTR [rdx+rcx*1]
  227764:	c4 62 7d 32 54 0a 04 	vpmovzxbq ymm10,DWORD PTR [rdx+rcx*1+0x4]
  22776b:	c4 62 7d 32 5c 0a 08 	vpmovzxbq ymm11,DWORD PTR [rdx+rcx*1+0x8]
  227772:	c4 62 7d 32 64 0a 0c 	vpmovzxbq ymm12,DWORD PTR [rdx+rcx*1+0xc]
  227779:	c5 95 73 f1 03       	vpsllq ymm13,ymm1,0x3
  22777e:	c5 15 d4 f5          	vpaddq ymm14,ymm13,ymm5
  227782:	c5 15 db fe          	vpand  ymm15,ymm13,ymm6
  227786:	c5 0d db f6          	vpand  ymm14,ymm14,ymm6
  22778a:	c4 42 b5 47 cf       	vpsllvq ymm9,ymm9,ymm15
  22778f:	c5 b5 eb c0          	vpor   ymm0,ymm9,ymm0
  227793:	c4 42 ad 47 ce       	vpsllvq ymm9,ymm10,ymm14
  227798:	c5 b5 eb db          	vpor   ymm3,ymm9,ymm3
  22779c:	c4 42 a5 47 cf       	vpsllvq ymm9,ymm11,ymm15
  2277a1:	c5 b5 eb e4          	vpor   ymm4,ymm9,ymm4
  2277a5:	c4 42 9d 47 ce       	vpsllvq ymm9,ymm12,ymm14
  2277aa:	c4 62 7d 32 54 0a 10 	vpmovzxbq ymm10,DWORD PTR [rdx+rcx*1+0x10]
  2277b1:	c4 62 7d 32 5c 0a 14 	vpmovzxbq ymm11,DWORD PTR [rdx+rcx*1+0x14]
  2277b8:	c4 62 7d 32 64 0a 18 	vpmovzxbq ymm12,DWORD PTR [rdx+rcx*1+0x18]
  2277bf:	c4 62 7d 32 74 0a 1c 	vpmovzxbq ymm14,DWORD PTR [rdx+rcx*1+0x1c]
  2277c6:	c5 b5 eb d2          	vpor   ymm2,ymm9,ymm2
  2277ca:	c5 15 d4 cf          	vpaddq ymm9,ymm13,ymm7
  2277ce:	c4 41 15 d4 e8       	vpaddq ymm13,ymm13,ymm8
  2277d3:	c5 35 db ce          	vpand  ymm9,ymm9,ymm6
  2277d7:	c5 15 db ee          	vpand  ymm13,ymm13,ymm6
  2277db:	c4 42 ad 47 d1       	vpsllvq ymm10,ymm10,ymm9
  2277e0:	c5 ad eb c0          	vpor   ymm0,ymm10,ymm0
  2277e4:	c4 42 a5 47 d5       	vpsllvq ymm10,ymm11,ymm13
  2277e9:	c5 ad eb db          	vpor   ymm3,ymm10,ymm3
  2277ed:	c4 42 9d 47 c9       	vpsllvq ymm9,ymm12,ymm9
  2277f2:	c5 b5 eb e4          	vpor   ymm4,ymm9,ymm4
  2277f6:	c4 42 8d 47 cd       	vpsllvq ymm9,ymm14,ymm13
  2277fb:	c5 b5 eb d2          	vpor   ymm2,ymm9,ymm2
            for (bytes) |b, index| {
  2277ff:	48 83 c1 20          	add    rcx,0x20
  227803:	c5 f5 d4 cd          	vpaddq ymm1,ymm1,ymm5
  227807:	48 83 c5 02          	add    rbp,0x2
  22780b:	0f 85 4d ff ff ff    	jne    22775e <parseFormValue+0x22ae>
  227811:	e9 cc 05 00 00       	jmp    227de2 <parseFormValue+0x2932>
    return FormValue{ .Block = buf };
  227816:	c6 84 24 b0 00 00 00 	mov    BYTE PTR [rsp+0xb0],0x1
  22781d:	01 
  22781e:	8b 44 24 78          	mov    eax,DWORD PTR [rsp+0x78]
  227822:	89 84 24 20 01 00 00 	mov    DWORD PTR [rsp+0x120],eax
  227829:	0f b7 44 24 7c       	movzx  eax,WORD PTR [rsp+0x7c]
  22782e:	66 89 84 24 24 01 00 	mov    WORD PTR [rsp+0x124],ax
  227835:	00 
    const buf = try readAllocBytes(allocator, in_stream, size);
  227836:	c5 f8 10 44 24 48    	vmovups xmm0,XMMWORD PTR [rsp+0x48]
    return FormValue{ .Block = buf };
  22783c:	8b 44 24 18          	mov    eax,DWORD PTR [rsp+0x18]
  227840:	89 84 24 00 01 00 00 	mov    DWORD PTR [rsp+0x100],eax
  227847:	48 8d b4 24 20 01 00 	lea    rsi,[rsp+0x120]
  22784e:	00 
  22784f:	0f b7 44 24 1c       	movzx  eax,WORD PTR [rsp+0x1c]
  227854:	66 89 84 24 04 01 00 	mov    WORD PTR [rsp+0x104],ax
  22785b:	00 
  22785c:	48 8d 84 24 00 01 00 	lea    rax,[rsp+0x100]
  227863:	00 
  227864:	8a 4c 24 1e          	mov    cl,BYTE PTR [rsp+0x1e]
  227868:	88 8c 24 06 01 00 00 	mov    BYTE PTR [rsp+0x106],cl
  22786f:	b3 01                	mov    bl,0x1
  227871:	8b 8c 24 90 00 00 00 	mov    ecx,DWORD PTR [rsp+0x90]
  227878:	89 8c 24 f8 00 00 00 	mov    DWORD PTR [rsp+0xf8],ecx
  22787f:	48 8d 94 24 f8 00 00 	lea    rdx,[rsp+0xf8]
  227886:	00 
  227887:	0f b7 8c 24 94 00 00 	movzx  ecx,WORD PTR [rsp+0x94]
  22788e:	00 
  22788f:	66 89 8c 24 fc 00 00 	mov    WORD PTR [rsp+0xfc],cx
  227896:	00 
  227897:	8a 8c 24 96 00 00 00 	mov    cl,BYTE PTR [rsp+0x96]
  22789e:	88 8c 24 fe 00 00 00 	mov    BYTE PTR [rsp+0xfe],cl
  2278a5:	e9 8f 00 00 00       	jmp    227939 <parseFormValue+0x2489>
    return FormValue{ .Ref = buf };
  2278aa:	c6 84 24 b0 00 00 00 	mov    BYTE PTR [rsp+0xb0],0x6
  2278b1:	06 
  2278b2:	8b 44 24 78          	mov    eax,DWORD PTR [rsp+0x78]
  2278b6:	89 84 24 10 01 00 00 	mov    DWORD PTR [rsp+0x110],eax
  2278bd:	0f b7 44 24 7c       	movzx  eax,WORD PTR [rsp+0x7c]
  2278c2:	66 89 84 24 14 01 00 	mov    WORD PTR [rsp+0x114],ax
  2278c9:	00 
    const buf = try readAllocBytes(allocator, in_stream, size);
  2278ca:	c5 f8 10 44 24 48    	vmovups xmm0,XMMWORD PTR [rsp+0x48]
    return FormValue{ .Ref = buf };
  2278d0:	8b 44 24 18          	mov    eax,DWORD PTR [rsp+0x18]
  2278d4:	89 84 24 e0 00 00 00 	mov    DWORD PTR [rsp+0xe0],eax
  2278db:	48 8d b4 24 10 01 00 	lea    rsi,[rsp+0x110]
  2278e2:	00 
  2278e3:	0f b7 44 24 1c       	movzx  eax,WORD PTR [rsp+0x1c]
  2278e8:	66 89 84 24 e4 00 00 	mov    WORD PTR [rsp+0xe4],ax
  2278ef:	00 
  2278f0:	48 8d 84 24 e0 00 00 	lea    rax,[rsp+0xe0]
  2278f7:	00 
  2278f8:	8a 4c 24 1e          	mov    cl,BYTE PTR [rsp+0x1e]
  2278fc:	88 8c 24 e6 00 00 00 	mov    BYTE PTR [rsp+0xe6],cl
  227903:	b3 06                	mov    bl,0x6
  227905:	8b 8c 24 90 00 00 00 	mov    ecx,DWORD PTR [rsp+0x90]
  22790c:	89 8c 24 d8 00 00 00 	mov    DWORD PTR [rsp+0xd8],ecx
  227913:	48 8d 94 24 d8 00 00 	lea    rdx,[rsp+0xd8]
  22791a:	00 
  22791b:	0f b7 8c 24 94 00 00 	movzx  ecx,WORD PTR [rsp+0x94]
  227922:	00 
  227923:	66 89 8c 24 dc 00 00 	mov    WORD PTR [rsp+0xdc],cx
  22792a:	00 
  22792b:	8a 8c 24 96 00 00 00 	mov    cl,BYTE PTR [rsp+0x96]
  227932:	88 8c 24 de 00 00 00 	mov    BYTE PTR [rsp+0xde],cl
  227939:	31 c9                	xor    ecx,ecx
  22793b:	66 89 0f             	mov    WORD PTR [rdi],cx
  22793e:	0f b7 4e 04          	movzx  ecx,WORD PTR [rsi+0x4]
  227942:	66 89 4f 06          	mov    WORD PTR [rdi+0x6],cx
  227946:	8b 0e                	mov    ecx,DWORD PTR [rsi]
  227948:	89 4f 02             	mov    DWORD PTR [rdi+0x2],ecx
  22794b:	c5 f8 11 47 08       	vmovups XMMWORD PTR [rdi+0x8],xmm0
  227950:	8a 48 06             	mov    cl,BYTE PTR [rax+0x6]
  227953:	88 4f 1f             	mov    BYTE PTR [rdi+0x1f],cl
  227956:	0f b7 48 04          	movzx  ecx,WORD PTR [rax+0x4]
  22795a:	66 89 4f 1d          	mov    WORD PTR [rdi+0x1d],cx
  22795e:	8b 00                	mov    eax,DWORD PTR [rax]
  227960:	89 47 19             	mov    DWORD PTR [rdi+0x19],eax
  227963:	88 5f 20             	mov    BYTE PTR [rdi+0x20],bl
  227966:	0f b7 42 04          	movzx  eax,WORD PTR [rdx+0x4]
  22796a:	66 89 47 25          	mov    WORD PTR [rdi+0x25],ax
  22796e:	8b 02                	mov    eax,DWORD PTR [rdx]
  227970:	89 47 21             	mov    DWORD PTR [rdi+0x21],eax
  227973:	8a 42 06             	mov    al,BYTE PTR [rdx+0x6]
  227976:	88 47 27             	mov    BYTE PTR [rdi+0x27],al
  227979:	e9 49 f5 ff ff       	jmp    226ec7 <parseFormValue+0x1a17>
            const buf = try readAllocBytes(allocator, in_stream, size);
  22797e:	c5 f8 10 84 24 58 04 	vmovups xmm0,XMMWORD PTR [rsp+0x458]
  227985:	00 00 
  227987:	c5 f8 29 84 24 80 04 	vmovaps XMMWORD PTR [rsp+0x480],xmm0
  22798e:	00 00 
            return FormValue{ .ExprLoc = buf };
  227990:	c5 f8 11 84 24 38 04 	vmovups XMMWORD PTR [rsp+0x438],xmm0
  227997:	00 00 
  227999:	48 8b 84 24 90 04 00 	mov    rax,QWORD PTR [rsp+0x490]
  2279a0:	00 
  2279a1:	48 89 84 24 48 04 00 	mov    QWORD PTR [rsp+0x448],rax
  2279a8:	00 
  2279a9:	c6 84 24 ae 00 00 00 	mov    BYTE PTR [rsp+0xae],0x3
  2279b0:	03 
  2279b1:	48 8b 4c 24 68       	mov    rcx,QWORD PTR [rsp+0x68]
  2279b6:	66 c7 01 00 00       	mov    WORD PTR [rcx],0x0
  2279bb:	c5 f8 10 84 24 32 04 	vmovups xmm0,XMMWORD PTR [rsp+0x432]
  2279c2:	00 00 
  2279c4:	c5 fa 6f 8c 24 40 04 	vmovdqu xmm1,XMMWORD PTR [rsp+0x440]
  2279cb:	00 00 
  2279cd:	c5 fa 7f 49 10       	vmovdqu XMMWORD PTR [rcx+0x10],xmm1
  2279d2:	c5 f8 11 41 02       	vmovups XMMWORD PTR [rcx+0x2],xmm0
  2279d7:	8a 84 24 ae 00 00 00 	mov    al,BYTE PTR [rsp+0xae]
  2279de:	88 41 20             	mov    BYTE PTR [rcx+0x20],al
  2279e1:	8a 84 24 10 03 00 00 	mov    al,BYTE PTR [rsp+0x310]
  2279e8:	88 41 27             	mov    BYTE PTR [rcx+0x27],al
  2279eb:	0f b7 84 24 0e 03 00 	movzx  eax,WORD PTR [rsp+0x30e]
  2279f2:	00 
  2279f3:	66 89 41 25          	mov    WORD PTR [rcx+0x25],ax
  2279f7:	8b 84 24 0a 03 00 00 	mov    eax,DWORD PTR [rsp+0x30a]
  2279fe:	89 41 21             	mov    DWORD PTR [rcx+0x21],eax
  227a01:	e9 c1 f4 ff ff       	jmp    226ec7 <parseFormValue+0x1a17>
  227a06:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  227a0a:	c5 fd 6f 0d 8e 87 fd 	vmovdqa ymm1,YMMWORD PTR [rip+0xfffffffffffd878e]        # 2001a0 <__unnamed_44-0x60>
  227a11:	ff 
  227a12:	31 c9                	xor    ecx,ecx
  227a14:	c5 e1 ef db          	vpxor  xmm3,xmm3,xmm3
  227a18:	c5 d9 ef e4          	vpxor  xmm4,xmm4,xmm4
  227a1c:	c5 e9 ef d2          	vpxor  xmm2,xmm2,xmm2
  227a20:	48 85 ff             	test   rdi,rdi
  227a23:	74 62                	je     227a87 <parseFormValue+0x25d7>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  227a25:	c4 e2 7d 32 6c 0a 0c 	vpmovzxbq ymm5,DWORD PTR [rdx+rcx*1+0xc]
  227a2c:	c5 f5 73 f1 03       	vpsllq ymm1,ymm1,0x3
  227a31:	c4 e2 7d 59 35 d6 88 	vpbroadcastq ymm6,QWORD PTR [rip+0xfffffffffffd88d6]        # 200310 <__unnamed_610+0x10>
  227a38:	fd ff 
  227a3a:	c5 f5 d4 f6          	vpaddq ymm6,ymm1,ymm6
  227a3e:	c4 e2 7d 59 3d 41 89 	vpbroadcastq ymm7,QWORD PTR [rip+0xfffffffffffd8941]        # 200388 <__unnamed_609+0x48>
  227a45:	fd ff 
  227a47:	c5 cd db f7          	vpand  ymm6,ymm6,ymm7
  227a4b:	c4 e2 d5 47 ee       	vpsllvq ymm5,ymm5,ymm6
  227a50:	c4 62 7d 32 44 0a 08 	vpmovzxbq ymm8,DWORD PTR [rdx+rcx*1+0x8]
  227a57:	c5 d5 eb d2          	vpor   ymm2,ymm5,ymm2
  227a5b:	c5 f5 db cf          	vpand  ymm1,ymm1,ymm7
  227a5f:	c4 e2 bd 47 e9       	vpsllvq ymm5,ymm8,ymm1
  227a64:	c5 d5 eb e4          	vpor   ymm4,ymm5,ymm4
  227a68:	c4 e2 7d 32 6c 0a 04 	vpmovzxbq ymm5,DWORD PTR [rdx+rcx*1+0x4]
  227a6f:	c4 e2 d5 47 ee       	vpsllvq ymm5,ymm5,ymm6
  227a74:	c5 d5 eb db          	vpor   ymm3,ymm5,ymm3
  227a78:	c4 e2 7d 32 2c 0a    	vpmovzxbq ymm5,DWORD PTR [rdx+rcx*1]
  227a7e:	c4 e2 d5 47 c9       	vpsllvq ymm1,ymm5,ymm1
  227a83:	c5 f5 eb c0          	vpor   ymm0,ymm1,ymm0
  227a87:	c5 e5 eb ca          	vpor   ymm1,ymm3,ymm2
  227a8b:	c5 fd eb c4          	vpor   ymm0,ymm0,ymm4
  227a8f:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  227a93:	c4 e3 7d 39 c1 01    	vextracti128 xmm1,ymm0,0x1
  227a99:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  227a9d:	c5 f9 70 c8 4e       	vpshufd xmm1,xmm0,0x4e
  227aa2:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  227aa6:	c4 e1 f9 7e c1       	vmovq  rcx,xmm0
  227aab:	48 39 d8             	cmp    rax,rbx
            for (bytes) |b, index| {
  227aae:	74 29                	je     227ad9 <parseFormValue+0x2629>
  227ab0:	48 29 d8             	sub    rax,rbx
  227ab3:	48 01 da             	add    rdx,rbx
  227ab6:	48 c1 e3 03          	shl    rbx,0x3
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  227aba:	0f b6 3a             	movzx  edi,BYTE PTR [rdx]
  227abd:	89 de                	mov    esi,ebx
  227abf:	40 80 e6 38          	and    sil,0x38
  227ac3:	c4 e2 c9 f7 f7       	shlx   rsi,rdi,rsi
  227ac8:	48 09 f1             	or     rcx,rsi
            for (bytes) |b, index| {
  227acb:	48 83 c3 08          	add    rbx,0x8
  227acf:	48 83 c2 01          	add    rdx,0x1
  227ad3:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  227ad7:	75 e1                	jne    227aba <parseFormValue+0x260a>
  227ad9:	48 8d 7c 24 78       	lea    rdi,[rsp+0x78]
    const buf = try readAllocBytes(allocator, in_stream, size);
  227ade:	4c 89 fe             	mov    rsi,r15
  227ae1:	4c 89 e2             	mov    rdx,r12
  227ae4:	c5 f8 77             	vzeroupper 
  227ae7:	e8 64 07 00 00       	call   228250 <readAllocBytes>
  227aec:	0f b7 44 24 78       	movzx  eax,WORD PTR [rsp+0x78]
  227af1:	66 85 c0             	test   ax,ax
  227af4:	74 39                	je     227b2f <parseFormValue+0x267f>
  227af6:	c5 f8 10 44 24 40    	vmovups xmm0,XMMWORD PTR [rsp+0x40]
  227afc:	c5 fa 6f 4c 24 4e    	vmovdqu xmm1,XMMWORD PTR [rsp+0x4e]
  227b02:	c5 fa 7f 8c 24 9e 00 	vmovdqu XMMWORD PTR [rsp+0x9e],xmm1
  227b09:	00 00 
  227b0b:	c5 f8 29 84 24 90 00 	vmovaps XMMWORD PTR [rsp+0x90],xmm0
  227b12:	00 00 
  227b14:	8b 4c 24 60          	mov    ecx,DWORD PTR [rsp+0x60]
  227b18:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  227b1b:	0f b7 4c 24 64       	movzx  ecx,WORD PTR [rsp+0x64]
  227b20:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  227b25:	8a 4c 24 66          	mov    cl,BYTE PTR [rsp+0x66]
  227b29:	88 4c 24 06          	mov    BYTE PTR [rsp+0x6],cl
  227b2d:	eb 65                	jmp    227b94 <parseFormValue+0x26e4>
  227b2f:	c5 f8 10 84 24 80 00 	vmovups xmm0,XMMWORD PTR [rsp+0x80]
  227b36:	00 00 
  227b38:	c5 f8 29 84 24 b0 00 	vmovaps XMMWORD PTR [rsp+0xb0],xmm0
  227b3f:	00 00 
    return FormValue{ .Block = buf };
  227b41:	c5 f8 11 44 24 1e    	vmovups XMMWORD PTR [rsp+0x1e],xmm0
  227b47:	48 8b 84 24 c0 00 00 	mov    rax,QWORD PTR [rsp+0xc0]
  227b4e:	00 
  227b4f:	48 89 44 24 2e       	mov    QWORD PTR [rsp+0x2e],rax
  227b54:	c6 44 24 08 01       	mov    BYTE PTR [rsp+0x8],0x1
  227b59:	8b 44 24 71          	mov    eax,DWORD PTR [rsp+0x71]
  227b5d:	89 04 24             	mov    DWORD PTR [rsp],eax
  227b60:	0f b7 44 24 75       	movzx  eax,WORD PTR [rsp+0x75]
  227b65:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  227b6a:	8a 44 24 77          	mov    al,BYTE PTR [rsp+0x77]
  227b6e:	88 44 24 06          	mov    BYTE PTR [rsp+0x6],al
  227b72:	c5 f8 10 44 24 18    	vmovups xmm0,XMMWORD PTR [rsp+0x18]
  227b78:	c5 f8 29 84 24 90 00 	vmovaps XMMWORD PTR [rsp+0x90],xmm0
  227b7f:	00 00 
  227b81:	c5 f8 10 44 24 26    	vmovups xmm0,XMMWORD PTR [rsp+0x26]
  227b87:	c5 f8 11 84 24 9e 00 	vmovups XMMWORD PTR [rsp+0x9e],xmm0
  227b8e:	00 00 
  227b90:	b1 01                	mov    cl,0x1
  227b92:	31 c0                	xor    eax,eax
    return parseFormValueBlockLen(allocator, in_stream, block_len);
  227b94:	66 89 84 24 90 02 00 	mov    WORD PTR [rsp+0x290],ax
  227b9b:	00 
  227b9c:	c5 f8 28 84 24 90 00 	vmovaps xmm0,XMMWORD PTR [rsp+0x90]
  227ba3:	00 00 
  227ba5:	c5 f8 11 84 24 92 02 	vmovups XMMWORD PTR [rsp+0x292],xmm0
  227bac:	00 00 
  227bae:	c5 f8 10 84 24 9e 00 	vmovups xmm0,XMMWORD PTR [rsp+0x9e]
  227bb5:	00 00 
  227bb7:	c5 f8 11 84 24 a0 02 	vmovups XMMWORD PTR [rsp+0x2a0],xmm0
  227bbe:	00 00 
  227bc0:	88 8c 24 b0 02 00 00 	mov    BYTE PTR [rsp+0x2b0],cl
  227bc7:	8b 04 24             	mov    eax,DWORD PTR [rsp]
  227bca:	89 84 24 b1 02 00 00 	mov    DWORD PTR [rsp+0x2b1],eax
  227bd1:	0f b7 44 24 04       	movzx  eax,WORD PTR [rsp+0x4]
  227bd6:	66 89 84 24 b5 02 00 	mov    WORD PTR [rsp+0x2b5],ax
  227bdd:	00 
  227bde:	8a 44 24 06          	mov    al,BYTE PTR [rsp+0x6]
  227be2:	e9 78 da ff ff       	jmp    22565f <parseFormValue+0x1af>
  227be7:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  227beb:	c5 fd 6f 0d ad 85 fd 	vmovdqa ymm1,YMMWORD PTR [rip+0xfffffffffffd85ad]        # 2001a0 <__unnamed_44-0x60>
  227bf2:	ff 
  227bf3:	31 c9                	xor    ecx,ecx
  227bf5:	c5 e1 ef db          	vpxor  xmm3,xmm3,xmm3
  227bf9:	c5 d9 ef e4          	vpxor  xmm4,xmm4,xmm4
  227bfd:	c5 e9 ef d2          	vpxor  xmm2,xmm2,xmm2
  227c01:	48 85 ff             	test   rdi,rdi
  227c04:	74 62                	je     227c68 <parseFormValue+0x27b8>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  227c06:	c4 e2 7d 32 6c 0a 0c 	vpmovzxbq ymm5,DWORD PTR [rdx+rcx*1+0xc]
  227c0d:	c5 f5 73 f1 03       	vpsllq ymm1,ymm1,0x3
  227c12:	c4 e2 7d 59 35 f5 86 	vpbroadcastq ymm6,QWORD PTR [rip+0xfffffffffffd86f5]        # 200310 <__unnamed_610+0x10>
  227c19:	fd ff 
  227c1b:	c5 f5 d4 f6          	vpaddq ymm6,ymm1,ymm6
  227c1f:	c4 e2 7d 59 3d 60 87 	vpbroadcastq ymm7,QWORD PTR [rip+0xfffffffffffd8760]        # 200388 <__unnamed_609+0x48>
  227c26:	fd ff 
  227c28:	c5 cd db f7          	vpand  ymm6,ymm6,ymm7
  227c2c:	c4 e2 d5 47 ee       	vpsllvq ymm5,ymm5,ymm6
  227c31:	c4 62 7d 32 44 0a 08 	vpmovzxbq ymm8,DWORD PTR [rdx+rcx*1+0x8]
  227c38:	c5 d5 eb d2          	vpor   ymm2,ymm5,ymm2
  227c3c:	c5 f5 db cf          	vpand  ymm1,ymm1,ymm7
  227c40:	c4 e2 bd 47 e9       	vpsllvq ymm5,ymm8,ymm1
  227c45:	c5 d5 eb e4          	vpor   ymm4,ymm5,ymm4
  227c49:	c4 e2 7d 32 6c 0a 04 	vpmovzxbq ymm5,DWORD PTR [rdx+rcx*1+0x4]
  227c50:	c4 e2 d5 47 ee       	vpsllvq ymm5,ymm5,ymm6
  227c55:	c5 d5 eb db          	vpor   ymm3,ymm5,ymm3
  227c59:	c4 e2 7d 32 2c 0a    	vpmovzxbq ymm5,DWORD PTR [rdx+rcx*1]
  227c5f:	c4 e2 d5 47 c9       	vpsllvq ymm1,ymm5,ymm1
  227c64:	c5 f5 eb c0          	vpor   ymm0,ymm1,ymm0
  227c68:	c5 e5 eb ca          	vpor   ymm1,ymm3,ymm2
  227c6c:	c5 fd eb c4          	vpor   ymm0,ymm0,ymm4
  227c70:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  227c74:	c4 e3 7d 39 c1 01    	vextracti128 xmm1,ymm0,0x1
  227c7a:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  227c7e:	c5 f9 70 c8 4e       	vpshufd xmm1,xmm0,0x4e
  227c83:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  227c87:	c4 e1 f9 7e c1       	vmovq  rcx,xmm0
  227c8c:	48 39 d8             	cmp    rax,rbx
            for (bytes) |b, index| {
  227c8f:	74 29                	je     227cba <parseFormValue+0x280a>
  227c91:	48 29 d8             	sub    rax,rbx
  227c94:	48 01 da             	add    rdx,rbx
  227c97:	48 c1 e3 03          	shl    rbx,0x3
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  227c9b:	0f b6 3a             	movzx  edi,BYTE PTR [rdx]
  227c9e:	89 de                	mov    esi,ebx
  227ca0:	40 80 e6 38          	and    sil,0x38
  227ca4:	c4 e2 c9 f7 f7       	shlx   rsi,rdi,rsi
  227ca9:	48 09 f1             	or     rcx,rsi
            for (bytes) |b, index| {
  227cac:	48 83 c3 08          	add    rbx,0x8
  227cb0:	48 83 c2 01          	add    rdx,0x1
  227cb4:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  227cb8:	75 e1                	jne    227c9b <parseFormValue+0x27eb>
  227cba:	48 8d 7c 24 78       	lea    rdi,[rsp+0x78]
    const buf = try readAllocBytes(allocator, in_stream, size);
  227cbf:	4c 89 fe             	mov    rsi,r15
  227cc2:	4c 89 e2             	mov    rdx,r12
  227cc5:	c5 f8 77             	vzeroupper 
  227cc8:	e8 83 05 00 00       	call   228250 <readAllocBytes>
  227ccd:	0f b7 44 24 78       	movzx  eax,WORD PTR [rsp+0x78]
  227cd2:	66 85 c0             	test   ax,ax
  227cd5:	74 39                	je     227d10 <parseFormValue+0x2860>
  227cd7:	c5 f8 10 44 24 40    	vmovups xmm0,XMMWORD PTR [rsp+0x40]
  227cdd:	c5 fa 6f 4c 24 4e    	vmovdqu xmm1,XMMWORD PTR [rsp+0x4e]
  227ce3:	c5 fa 7f 8c 24 9e 00 	vmovdqu XMMWORD PTR [rsp+0x9e],xmm1
  227cea:	00 00 
  227cec:	c5 f8 29 84 24 90 00 	vmovaps XMMWORD PTR [rsp+0x90],xmm0
  227cf3:	00 00 
  227cf5:	8b 4c 24 60          	mov    ecx,DWORD PTR [rsp+0x60]
  227cf9:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  227cfc:	0f b7 4c 24 64       	movzx  ecx,WORD PTR [rsp+0x64]
  227d01:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  227d06:	8a 4c 24 66          	mov    cl,BYTE PTR [rsp+0x66]
  227d0a:	88 4c 24 06          	mov    BYTE PTR [rsp+0x6],cl
  227d0e:	eb 65                	jmp    227d75 <parseFormValue+0x28c5>
  227d10:	c5 f8 10 84 24 80 00 	vmovups xmm0,XMMWORD PTR [rsp+0x80]
  227d17:	00 00 
  227d19:	c5 f8 29 84 24 b0 00 	vmovaps XMMWORD PTR [rsp+0xb0],xmm0
  227d20:	00 00 
    return FormValue{ .Block = buf };
  227d22:	c5 f8 11 44 24 1e    	vmovups XMMWORD PTR [rsp+0x1e],xmm0
  227d28:	48 8b 84 24 c0 00 00 	mov    rax,QWORD PTR [rsp+0xc0]
  227d2f:	00 
  227d30:	48 89 44 24 2e       	mov    QWORD PTR [rsp+0x2e],rax
  227d35:	c6 44 24 08 01       	mov    BYTE PTR [rsp+0x8],0x1
  227d3a:	8b 44 24 71          	mov    eax,DWORD PTR [rsp+0x71]
  227d3e:	89 04 24             	mov    DWORD PTR [rsp],eax
  227d41:	0f b7 44 24 75       	movzx  eax,WORD PTR [rsp+0x75]
  227d46:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  227d4b:	8a 44 24 77          	mov    al,BYTE PTR [rsp+0x77]
  227d4f:	88 44 24 06          	mov    BYTE PTR [rsp+0x6],al
  227d53:	c5 f8 10 44 24 18    	vmovups xmm0,XMMWORD PTR [rsp+0x18]
  227d59:	c5 f8 29 84 24 90 00 	vmovaps XMMWORD PTR [rsp+0x90],xmm0
  227d60:	00 00 
  227d62:	c5 f8 10 44 24 26    	vmovups xmm0,XMMWORD PTR [rsp+0x26]
  227d68:	c5 f8 11 84 24 9e 00 	vmovups XMMWORD PTR [rsp+0x9e],xmm0
  227d6f:	00 00 
  227d71:	b1 01                	mov    cl,0x1
  227d73:	31 c0                	xor    eax,eax
    return parseFormValueBlockLen(allocator, in_stream, block_len);
  227d75:	66 89 84 24 68 02 00 	mov    WORD PTR [rsp+0x268],ax
  227d7c:	00 
  227d7d:	c5 f8 28 84 24 90 00 	vmovaps xmm0,XMMWORD PTR [rsp+0x90]
  227d84:	00 00 
  227d86:	c5 f8 11 84 24 6a 02 	vmovups XMMWORD PTR [rsp+0x26a],xmm0
  227d8d:	00 00 
  227d8f:	c5 f8 10 84 24 9e 00 	vmovups xmm0,XMMWORD PTR [rsp+0x9e]
  227d96:	00 00 
  227d98:	c5 f8 11 84 24 78 02 	vmovups XMMWORD PTR [rsp+0x278],xmm0
  227d9f:	00 00 
  227da1:	88 8c 24 88 02 00 00 	mov    BYTE PTR [rsp+0x288],cl
  227da8:	8b 04 24             	mov    eax,DWORD PTR [rsp]
  227dab:	89 84 24 89 02 00 00 	mov    DWORD PTR [rsp+0x289],eax
  227db2:	0f b7 44 24 04       	movzx  eax,WORD PTR [rsp+0x4]
  227db7:	66 89 84 24 8d 02 00 	mov    WORD PTR [rsp+0x28d],ax
  227dbe:	00 
  227dbf:	8a 44 24 06          	mov    al,BYTE PTR [rsp+0x6]
  227dc3:	e9 4c d9 ff ff       	jmp    225714 <parseFormValue+0x264>
  227dc8:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  227dcc:	c5 fd 6f 0d cc 83 fd 	vmovdqa ymm1,YMMWORD PTR [rip+0xfffffffffffd83cc]        # 2001a0 <__unnamed_44-0x60>
  227dd3:	ff 
  227dd4:	31 c9                	xor    ecx,ecx
  227dd6:	c5 e1 ef db          	vpxor  xmm3,xmm3,xmm3
  227dda:	c5 d9 ef e4          	vpxor  xmm4,xmm4,xmm4
  227dde:	c5 e9 ef d2          	vpxor  xmm2,xmm2,xmm2
  227de2:	48 85 ff             	test   rdi,rdi
  227de5:	74 62                	je     227e49 <parseFormValue+0x2999>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  227de7:	c4 e2 7d 32 6c 0a 0c 	vpmovzxbq ymm5,DWORD PTR [rdx+rcx*1+0xc]
  227dee:	c5 f5 73 f1 03       	vpsllq ymm1,ymm1,0x3
  227df3:	c4 e2 7d 59 35 14 85 	vpbroadcastq ymm6,QWORD PTR [rip+0xfffffffffffd8514]        # 200310 <__unnamed_610+0x10>
  227dfa:	fd ff 
  227dfc:	c5 f5 d4 f6          	vpaddq ymm6,ymm1,ymm6
  227e00:	c4 e2 7d 59 3d 7f 85 	vpbroadcastq ymm7,QWORD PTR [rip+0xfffffffffffd857f]        # 200388 <__unnamed_609+0x48>
  227e07:	fd ff 
  227e09:	c5 cd db f7          	vpand  ymm6,ymm6,ymm7
  227e0d:	c4 e2 d5 47 ee       	vpsllvq ymm5,ymm5,ymm6
  227e12:	c4 62 7d 32 44 0a 08 	vpmovzxbq ymm8,DWORD PTR [rdx+rcx*1+0x8]
  227e19:	c5 d5 eb d2          	vpor   ymm2,ymm5,ymm2
  227e1d:	c5 f5 db cf          	vpand  ymm1,ymm1,ymm7
  227e21:	c4 e2 bd 47 e9       	vpsllvq ymm5,ymm8,ymm1
  227e26:	c5 d5 eb e4          	vpor   ymm4,ymm5,ymm4
  227e2a:	c4 e2 7d 32 6c 0a 04 	vpmovzxbq ymm5,DWORD PTR [rdx+rcx*1+0x4]
  227e31:	c4 e2 d5 47 ee       	vpsllvq ymm5,ymm5,ymm6
  227e36:	c5 d5 eb db          	vpor   ymm3,ymm5,ymm3
  227e3a:	c4 e2 7d 32 2c 0a    	vpmovzxbq ymm5,DWORD PTR [rdx+rcx*1]
  227e40:	c4 e2 d5 47 c9       	vpsllvq ymm1,ymm5,ymm1
  227e45:	c5 f5 eb c0          	vpor   ymm0,ymm1,ymm0
  227e49:	c5 e5 eb ca          	vpor   ymm1,ymm3,ymm2
  227e4d:	c5 fd eb c4          	vpor   ymm0,ymm0,ymm4
  227e51:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  227e55:	c4 e3 7d 39 c1 01    	vextracti128 xmm1,ymm0,0x1
  227e5b:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  227e5f:	c5 f9 70 c8 4e       	vpshufd xmm1,xmm0,0x4e
  227e64:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  227e68:	c4 e1 f9 7e c1       	vmovq  rcx,xmm0
  227e6d:	48 39 d8             	cmp    rax,rbx
            for (bytes) |b, index| {
  227e70:	74 29                	je     227e9b <parseFormValue+0x29eb>
  227e72:	48 29 d8             	sub    rax,rbx
  227e75:	48 01 da             	add    rdx,rbx
  227e78:	48 c1 e3 03          	shl    rbx,0x3
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  227e7c:	0f b6 3a             	movzx  edi,BYTE PTR [rdx]
  227e7f:	89 de                	mov    esi,ebx
  227e81:	40 80 e6 38          	and    sil,0x38
  227e85:	c4 e2 c9 f7 f7       	shlx   rsi,rdi,rsi
  227e8a:	48 09 f1             	or     rcx,rsi
            for (bytes) |b, index| {
  227e8d:	48 83 c3 08          	add    rbx,0x8
  227e91:	48 83 c2 01          	add    rdx,0x1
  227e95:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  227e99:	75 e1                	jne    227e7c <parseFormValue+0x29cc>
  227e9b:	48 8d 7c 24 78       	lea    rdi,[rsp+0x78]
    const buf = try readAllocBytes(allocator, in_stream, size);
  227ea0:	4c 89 fe             	mov    rsi,r15
  227ea3:	4c 89 e2             	mov    rdx,r12
  227ea6:	c5 f8 77             	vzeroupper 
  227ea9:	e8 a2 03 00 00       	call   228250 <readAllocBytes>
  227eae:	0f b7 44 24 78       	movzx  eax,WORD PTR [rsp+0x78]
  227eb3:	66 85 c0             	test   ax,ax
  227eb6:	74 39                	je     227ef1 <parseFormValue+0x2a41>
  227eb8:	c5 f8 10 44 24 40    	vmovups xmm0,XMMWORD PTR [rsp+0x40]
  227ebe:	c5 fa 6f 4c 24 4e    	vmovdqu xmm1,XMMWORD PTR [rsp+0x4e]
  227ec4:	c5 fa 7f 8c 24 9e 00 	vmovdqu XMMWORD PTR [rsp+0x9e],xmm1
  227ecb:	00 00 
  227ecd:	c5 f8 29 84 24 90 00 	vmovaps XMMWORD PTR [rsp+0x90],xmm0
  227ed4:	00 00 
  227ed6:	8b 4c 24 60          	mov    ecx,DWORD PTR [rsp+0x60]
  227eda:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  227edd:	0f b7 4c 24 64       	movzx  ecx,WORD PTR [rsp+0x64]
  227ee2:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  227ee7:	8a 4c 24 66          	mov    cl,BYTE PTR [rsp+0x66]
  227eeb:	88 4c 24 06          	mov    BYTE PTR [rsp+0x6],cl
  227eef:	eb 65                	jmp    227f56 <parseFormValue+0x2aa6>
  227ef1:	c5 f8 10 84 24 80 00 	vmovups xmm0,XMMWORD PTR [rsp+0x80]
  227ef8:	00 00 
  227efa:	c5 f8 29 84 24 b0 00 	vmovaps XMMWORD PTR [rsp+0xb0],xmm0
  227f01:	00 00 
    return FormValue{ .Block = buf };
  227f03:	c5 f8 11 44 24 1e    	vmovups XMMWORD PTR [rsp+0x1e],xmm0
  227f09:	48 8b 84 24 c0 00 00 	mov    rax,QWORD PTR [rsp+0xc0]
  227f10:	00 
  227f11:	48 89 44 24 2e       	mov    QWORD PTR [rsp+0x2e],rax
  227f16:	c6 44 24 08 01       	mov    BYTE PTR [rsp+0x8],0x1
  227f1b:	8b 44 24 71          	mov    eax,DWORD PTR [rsp+0x71]
  227f1f:	89 04 24             	mov    DWORD PTR [rsp],eax
  227f22:	0f b7 44 24 75       	movzx  eax,WORD PTR [rsp+0x75]
  227f27:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  227f2c:	8a 44 24 77          	mov    al,BYTE PTR [rsp+0x77]
  227f30:	88 44 24 06          	mov    BYTE PTR [rsp+0x6],al
  227f34:	c5 f8 10 44 24 18    	vmovups xmm0,XMMWORD PTR [rsp+0x18]
  227f3a:	c5 f8 29 84 24 90 00 	vmovaps XMMWORD PTR [rsp+0x90],xmm0
  227f41:	00 00 
  227f43:	c5 f8 10 44 24 26    	vmovups xmm0,XMMWORD PTR [rsp+0x26]
  227f49:	c5 f8 11 84 24 9e 00 	vmovups XMMWORD PTR [rsp+0x9e],xmm0
  227f50:	00 00 
  227f52:	b1 01                	mov    cl,0x1
  227f54:	31 c0                	xor    eax,eax
    return parseFormValueBlockLen(allocator, in_stream, block_len);
  227f56:	66 89 84 24 b8 02 00 	mov    WORD PTR [rsp+0x2b8],ax
  227f5d:	00 
  227f5e:	c5 f8 28 84 24 90 00 	vmovaps xmm0,XMMWORD PTR [rsp+0x90]
  227f65:	00 00 
  227f67:	c5 f8 11 84 24 ba 02 	vmovups XMMWORD PTR [rsp+0x2ba],xmm0
  227f6e:	00 00 
  227f70:	c5 f8 10 84 24 9e 00 	vmovups xmm0,XMMWORD PTR [rsp+0x9e]
  227f77:	00 00 
  227f79:	c5 f8 11 84 24 c8 02 	vmovups XMMWORD PTR [rsp+0x2c8],xmm0
  227f80:	00 00 
  227f82:	88 8c 24 d8 02 00 00 	mov    BYTE PTR [rsp+0x2d8],cl
  227f89:	8b 04 24             	mov    eax,DWORD PTR [rsp]
  227f8c:	89 84 24 d9 02 00 00 	mov    DWORD PTR [rsp+0x2d9],eax
  227f93:	0f b7 44 24 04       	movzx  eax,WORD PTR [rsp+0x4]
  227f98:	66 89 84 24 dd 02 00 	mov    WORD PTR [rsp+0x2dd],ax
  227f9f:	00 
  227fa0:	8a 44 24 06          	mov    al,BYTE PTR [rsp+0x6]
  227fa4:	e9 d5 da ff ff       	jmp    225a7e <parseFormValue+0x5ce>
  227fa9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

0000000000227fb0 <Allocator_alignedRealloc.164>:
    pub fn alignedRealloc(self: *Allocator, comptime T: type, comptime alignment: u29, old_mem: []align(alignment) T, n: usize) ![]align(alignment) T {
  227fb0:	41 56                	push   r14
  227fb2:	53                   	push   rbx
  227fb3:	48 81 ec 88 00 00 00 	sub    rsp,0x88
  227fba:	48 89 fb             	mov    rbx,rdi
        if (old_mem.len == 0) {
  227fbd:	48 8b 42 08          	mov    rax,QWORD PTR [rdx+0x8]
  227fc1:	48 85 c0             	test   rax,rax
  227fc4:	74 62                	je     228028 <Allocator_alignedRealloc.164+0x78>
        if (n == 0) {
  227fc6:	48 85 c9             	test   rcx,rcx
  227fc9:	0f 84 a9 00 00 00    	je     228078 <Allocator_alignedRealloc.164+0xc8>
        const old_byte_slice = @sliceToBytes(old_mem);
  227fcf:	48 8b 12             	mov    rdx,QWORD PTR [rdx]
  227fd2:	48 c1 e0 03          	shl    rax,0x3
  227fd6:	48 8d 04 80          	lea    rax,[rax+rax*4]
  227fda:	48 89 54 24 38       	mov    QWORD PTR [rsp+0x38],rdx
  227fdf:	48 89 44 24 40       	mov    QWORD PTR [rsp+0x40],rax
  227fe4:	ba 28 00 00 00       	mov    edx,0x28
  227fe9:	48 89 c8             	mov    rax,rcx
  227fec:	48 f7 e2             	mul    rdx
  227fef:	0f 81 d0 00 00 00    	jno    2280c5 <Allocator_alignedRealloc.164+0x115>
  227ff5:	48 8d 0d 84 0f fe ff 	lea    rcx,[rip+0xfffffffffffe0f84]        # 208f80 <__unnamed_43>
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  227ffc:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  228000:	0f 84 da 00 00 00    	je     2280e0 <Allocator_alignedRealloc.164+0x130>
  228006:	48 8b 05 a3 f8 fd ff 	mov    rax,QWORD PTR [rip+0xfffffffffffdf8a3]        # 2078b0 <__unnamed_79+0x10>
  22800d:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  228011:	c5 f8 10 05 87 f8 fd 	vmovups xmm0,XMMWORD PTR [rip+0xfffffffffffdf887]        # 2078a0 <__unnamed_79>
  228018:	ff 
  228019:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  22801d:	48 81 c4 88 00 00 00 	add    rsp,0x88
  228024:	5b                   	pop    rbx
  228025:	41 5e                	pop    r14
  228027:	c3                   	ret    
        if (n == 0) {
  228028:	48 85 c9             	test   rcx,rcx
  22802b:	0f 84 fc 00 00 00    	je     22812d <Allocator_alignedRealloc.164+0x17d>
  228031:	ba 28 00 00 00       	mov    edx,0x28
  228036:	48 89 c8             	mov    rax,rcx
  228039:	48 f7 e2             	mul    rdx
  22803c:	0f 81 0c 01 00 00    	jno    22814e <Allocator_alignedRealloc.164+0x19e>
  228042:	48 8d 0d 37 0f fe ff 	lea    rcx,[rip+0xfffffffffffe0f37]        # 208f80 <__unnamed_43>
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  228049:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  22804d:	0f 84 16 01 00 00    	je     228169 <Allocator_alignedRealloc.164+0x1b9>
  228053:	0f b7 05 4c f8 fd ff 	movzx  eax,WORD PTR [rip+0xfffffffffffdf84c]        # 2078a6 <__unnamed_79+0x6>
  22805a:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  22805f:	8b 05 3d f8 fd ff    	mov    eax,DWORD PTR [rip+0xfffffffffffdf83d]        # 2078a2 <__unnamed_79+0x2>
  228065:	89 04 24             	mov    DWORD PTR [rsp],eax
  228068:	48 89 e0             	mov    rax,rsp
  22806b:	66 b9 01 00          	mov    cx,0x1
  22806f:	31 f6                	xor    esi,esi
  228071:	31 d2                	xor    edx,edx
  228073:	e9 9d 01 00 00       	jmp    228215 <Allocator_alignedRealloc.164+0x265>
        const bytes = @sliceToBytes(memory);
  228078:	48 c1 e0 03          	shl    rax,0x3
  22807c:	48 8d 04 80          	lea    rax,[rax+rax*4]
        if (bytes.len == 0) return;
  228080:	48 85 c0             	test   rax,rax
  228083:	74 1e                	je     2280a3 <Allocator_alignedRealloc.164+0xf3>
        const bytes = @sliceToBytes(memory);
  228085:	48 8b 0a             	mov    rcx,QWORD PTR [rdx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  228088:	48 8b 56 10          	mov    rdx,QWORD PTR [rsi+0x10]
  22808c:	48 89 4c 24 08       	mov    QWORD PTR [rsp+0x8],rcx
  228091:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  228096:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  22809b:	48 89 f7             	mov    rdi,rsi
  22809e:	48 89 c6             	mov    rsi,rax
  2280a1:	ff d2                	call   rdx
            return ([*]align(alignment) T)(undefined)[0..0];
  2280a3:	48 8b 05 ee f7 fd ff 	mov    rax,QWORD PTR [rip+0xfffffffffffdf7ee]        # 207898 <__unnamed_80+0x10>
  2280aa:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  2280ae:	c5 f8 10 05 d2 f7 fd 	vmovups xmm0,XMMWORD PTR [rip+0xfffffffffffdf7d2]        # 207888 <__unnamed_80>
  2280b5:	ff 
  2280b6:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  2280ba:	48 81 c4 88 00 00 00 	add    rsp,0x88
  2280c1:	5b                   	pop    rbx
  2280c2:	41 5e                	pop    r14
  2280c4:	c3                   	ret    
  2280c5:	48 8d 4c 24 08       	lea    rcx,[rsp+0x8]
  2280ca:	66 c7 44 24 08 00 00 	mov    WORD PTR [rsp+0x8],0x0
  2280d1:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  2280d6:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  2280da:	0f 85 26 ff ff ff    	jne    228006 <Allocator_alignedRealloc.164+0x56>
  2280e0:	4c 8b 71 08          	mov    r14,QWORD PTR [rcx+0x8]
  2280e4:	48 8d 7c 24 58       	lea    rdi,[rsp+0x58]
  2280e9:	48 8d 54 24 38       	lea    rdx,[rsp+0x38]
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  2280ee:	41 b8 08 00 00 00    	mov    r8d,0x8
  2280f4:	4c 89 f1             	mov    rcx,r14
  2280f7:	ff 56 08             	call   QWORD PTR [rsi+0x8]
  2280fa:	0f b7 44 24 58       	movzx  eax,WORD PTR [rsp+0x58]
  2280ff:	66 85 c0             	test   ax,ax
  228102:	0f 84 94 00 00 00    	je     22819c <Allocator_alignedRealloc.164+0x1ec>
  228108:	66 89 03             	mov    WORD PTR [rbx],ax
  22810b:	48 8b 84 24 80 00 00 	mov    rax,QWORD PTR [rsp+0x80]
  228112:	00 
  228113:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  228117:	c5 f8 10 44 24 72    	vmovups xmm0,XMMWORD PTR [rsp+0x72]
  22811d:	c5 f8 11 43 02       	vmovups XMMWORD PTR [rbx+0x2],xmm0
  228122:	48 81 c4 88 00 00 00 	add    rsp,0x88
  228129:	5b                   	pop    rbx
  22812a:	41 5e                	pop    r14
  22812c:	c3                   	ret    
  22812d:	48 89 e0             	mov    rax,rsp
            return ([*]align(alignment) T)(undefined)[0..0];
  228130:	0f b7 0d 57 f7 fd ff 	movzx  ecx,WORD PTR [rip+0xfffffffffffdf757]        # 20788e <__unnamed_80+0x6>
  228137:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  22813c:	8b 0d 48 f7 fd ff    	mov    ecx,DWORD PTR [rip+0xfffffffffffdf748]        # 20788a <__unnamed_80+0x2>
  228142:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  228145:	31 c9                	xor    ecx,ecx
  228147:	31 d2                	xor    edx,edx
  228149:	e9 c7 00 00 00       	jmp    228215 <Allocator_alignedRealloc.164+0x265>
  22814e:	48 8d 4c 24 48       	lea    rcx,[rsp+0x48]
  228153:	66 c7 44 24 48 00 00 	mov    WORD PTR [rsp+0x48],0x0
  22815a:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  22815f:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  228163:	0f 85 ea fe ff ff    	jne    228053 <Allocator_alignedRealloc.164+0xa3>
  228169:	4c 8b 71 08          	mov    r14,QWORD PTR [rcx+0x8]
  22816d:	48 8d 7c 24 08       	lea    rdi,[rsp+0x8]
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  228172:	b9 08 00 00 00       	mov    ecx,0x8
  228177:	4c 89 f2             	mov    rdx,r14
  22817a:	ff 16                	call   QWORD PTR [rsi]
  22817c:	0f b7 4c 24 08       	movzx  ecx,WORD PTR [rsp+0x8]
  228181:	66 85 c9             	test   cx,cx
  228184:	74 57                	je     2281dd <Allocator_alignedRealloc.164+0x22d>
  228186:	0f b7 44 24 36       	movzx  eax,WORD PTR [rsp+0x36]
  22818b:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  228190:	48 89 e0             	mov    rax,rsp
  228193:	8b 54 24 32          	mov    edx,DWORD PTR [rsp+0x32]
  228197:	89 14 24             	mov    DWORD PTR [rsp],edx
  22819a:	eb 79                	jmp    228215 <Allocator_alignedRealloc.164+0x265>
        assert(byte_slice.len == byte_count);
  22819c:	4c 39 74 24 68       	cmp    QWORD PTR [rsp+0x68],r14
    if (!ok) {
  2281a1:	0f 85 91 00 00 00    	jne    228238 <Allocator_alignedRealloc.164+0x288>
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  2281a7:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  2281ac:	48 b9 cd cc cc cc cc 	movabs rcx,0xcccccccccccccccd
  2281b3:	cc cc cc 
  2281b6:	4c 89 f2             	mov    rdx,r14
  2281b9:	c4 e2 f3 f6 d1       	mulx   rdx,rcx,rcx
  2281be:	66 c7 03 00 00       	mov    WORD PTR [rbx],0x0
  2281c3:	0f b7 4c 24 2a       	movzx  ecx,WORD PTR [rsp+0x2a]
  2281c8:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  2281cc:	48 c1 ea 05          	shr    rdx,0x5
  2281d0:	8b 4c 24 26          	mov    ecx,DWORD PTR [rsp+0x26]
  2281d4:	89 4b 02             	mov    DWORD PTR [rbx+0x2],ecx
  2281d7:	48 89 43 08          	mov    QWORD PTR [rbx+0x8],rax
  2281db:	eb 4c                	jmp    228229 <Allocator_alignedRealloc.164+0x279>
        assert(byte_slice.len == byte_count);
  2281dd:	4c 39 74 24 18       	cmp    QWORD PTR [rsp+0x18],r14
  2281e2:	75 54                	jne    228238 <Allocator_alignedRealloc.164+0x288>
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  2281e4:	48 8b 74 24 10       	mov    rsi,QWORD PTR [rsp+0x10]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  2281e9:	48 b8 cd cc cc cc cc 	movabs rax,0xcccccccccccccccd
  2281f0:	cc cc cc 
  2281f3:	4c 89 f2             	mov    rdx,r14
  2281f6:	c4 e2 fb f6 d0       	mulx   rdx,rax,rax
  2281fb:	48 c1 ea 05          	shr    rdx,0x5
  2281ff:	48 89 e0             	mov    rax,rsp
  228202:	8b 4c 24 2c          	mov    ecx,DWORD PTR [rsp+0x2c]
  228206:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  228209:	0f b7 4c 24 30       	movzx  ecx,WORD PTR [rsp+0x30]
  22820e:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  228213:	31 c9                	xor    ecx,ecx
            return self.alignedAlloc(T, alignment, n);
  228215:	66 89 0b             	mov    WORD PTR [rbx],cx
  228218:	0f b7 48 04          	movzx  ecx,WORD PTR [rax+0x4]
  22821c:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  228220:	8b 00                	mov    eax,DWORD PTR [rax]
  228222:	89 43 02             	mov    DWORD PTR [rbx+0x2],eax
  228225:	48 89 73 08          	mov    QWORD PTR [rbx+0x8],rsi
  228229:	48 89 53 10          	mov    QWORD PTR [rbx+0x10],rdx
  22822d:	48 81 c4 88 00 00 00 	add    rsp,0x88
  228234:	5b                   	pop    rbx
  228235:	41 5e                	pop    r14
  228237:	c3                   	ret    
            @panic("assertion failure");
  228238:	48 8d 3d c9 6a 02 00 	lea    rdi,[rip+0x26ac9]        # 24ed08 <__unnamed_2>
  22823f:	e8 dc 9d fe ff       	call   212020 <panic>
  228244:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  22824b:	00 00 00 00 00 

0000000000228250 <readAllocBytes>:
fn readAllocBytes(allocator: *mem.Allocator, in_stream: var, size: usize) ![]u8 {
  228250:	55                   	push   rbp
  228251:	41 57                	push   r15
  228253:	41 56                	push   r14
  228255:	41 54                	push   r12
  228257:	53                   	push   rbx
  228258:	48 83 ec 70          	sub    rsp,0x70
  22825c:	48 89 cb             	mov    rbx,rcx
  22825f:	49 89 d4             	mov    r12,rdx
  228262:	49 89 f6             	mov    r14,rsi
  228265:	49 89 ff             	mov    r15,rdi
        if (n == 0) {
  228268:	48 85 db             	test   rbx,rbx
  22826b:	74 32                	je     22829f <readAllocBytes+0x4f>
  22826d:	48 89 e7             	mov    rdi,rsp
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  228270:	b9 01 00 00 00       	mov    ecx,0x1
  228275:	4c 89 f6             	mov    rsi,r14
  228278:	48 89 da             	mov    rdx,rbx
  22827b:	41 ff 16             	call   QWORD PTR [r14]
  22827e:	0f b7 04 24          	movzx  eax,WORD PTR [rsp]
  228282:	66 85 c0             	test   ax,ax
  228285:	74 1c                	je     2282a3 <readAllocBytes+0x53>
    const buf = try allocator.alloc(u8, size);
  228287:	66 41 89 07          	mov    WORD PTR [r15],ax
  22828b:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  228290:	49 89 47 10          	mov    QWORD PTR [r15+0x10],rax
  228294:	c5 f8 10 44 24 5a    	vmovups xmm0,XMMWORD PTR [rsp+0x5a]
  22829a:	e9 d8 00 00 00       	jmp    228377 <readAllocBytes+0x127>
  22829f:	31 c0                	xor    eax,eax
  2282a1:	eb 13                	jmp    2282b6 <readAllocBytes+0x66>
        assert(byte_slice.len == byte_count);
  2282a3:	48 39 5c 24 10       	cmp    QWORD PTR [rsp+0x10],rbx
    if (!ok) {
  2282a8:	0f 85 dc 00 00 00    	jne    22838a <readAllocBytes+0x13a>
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  2282ae:	48 8b 4c 24 08       	mov    rcx,QWORD PTR [rsp+0x8]
  2282b3:	48 89 d8             	mov    rax,rbx
    const buf = try allocator.alloc(u8, size);
  2282b6:	48 89 4c 24 18       	mov    QWORD PTR [rsp+0x18],rcx
  2282bb:	48 89 44 24 20       	mov    QWORD PTR [rsp+0x20],rax
  2282c0:	48 89 e7             	mov    rdi,rsp
  2282c3:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  2282c8:	4c 89 e6             	mov    rsi,r12
  2282cb:	41 ff 14 24          	call   QWORD PTR [r12]
  2282cf:	0f b7 2c 24          	movzx  ebp,WORD PTR [rsp]
    if ((try in_stream.read(buf)) < size) return error.EndOfFile;
  2282d3:	66 85 ed             	test   bp,bp
  2282d6:	74 39                	je     228311 <readAllocBytes+0xc1>
        const bytes = @sliceToBytes(memory);
  2282d8:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
        if (bytes.len == 0) return;
  2282dd:	48 85 c0             	test   rax,rax
  2282e0:	74 1a                	je     2282fc <readAllocBytes+0xac>
        const bytes = @sliceToBytes(memory);
  2282e2:	48 8b 4c 24 18       	mov    rcx,QWORD PTR [rsp+0x18]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  2282e7:	49 8b 56 10          	mov    rdx,QWORD PTR [r14+0x10]
  2282eb:	48 89 0c 24          	mov    QWORD PTR [rsp],rcx
  2282ef:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  2282f4:	48 89 e6             	mov    rsi,rsp
  2282f7:	4c 89 f7             	mov    rdi,r14
  2282fa:	ff d2                	call   rdx
  2282fc:	66 41 89 2f          	mov    WORD PTR [r15],bp
  228300:	48 8b 44 24 52       	mov    rax,QWORD PTR [rsp+0x52]
  228305:	49 89 47 10          	mov    QWORD PTR [r15+0x10],rax
  228309:	c5 f8 10 44 24 44    	vmovups xmm0,XMMWORD PTR [rsp+0x44]
  22830f:	eb 66                	jmp    228377 <readAllocBytes+0x127>
  228311:	48 39 5c 24 08       	cmp    QWORD PTR [rsp+0x8],rbx
  228316:	73 3e                	jae    228356 <readAllocBytes+0x106>
        const bytes = @sliceToBytes(memory);
  228318:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
        if (bytes.len == 0) return;
  22831d:	48 85 c0             	test   rax,rax
  228320:	74 1a                	je     22833c <readAllocBytes+0xec>
        const bytes = @sliceToBytes(memory);
  228322:	48 8b 4c 24 18       	mov    rcx,QWORD PTR [rsp+0x18]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  228327:	49 8b 56 10          	mov    rdx,QWORD PTR [r14+0x10]
  22832b:	48 89 0c 24          	mov    QWORD PTR [rsp],rcx
  22832f:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  228334:	48 89 e6             	mov    rsi,rsp
  228337:	4c 89 f7             	mov    rdi,r14
  22833a:	ff d2                	call   rdx
  22833c:	48 8b 05 cd f8 fd ff 	mov    rax,QWORD PTR [rip+0xfffffffffffdf8cd]        # 207c10 <__unnamed_81+0x10>
  228343:	49 89 47 10          	mov    QWORD PTR [r15+0x10],rax
  228347:	c5 f8 10 05 b1 f8 fd 	vmovups xmm0,XMMWORD PTR [rip+0xfffffffffffdf8b1]        # 207c00 <__unnamed_81>
  22834e:	ff 
  22834f:	c4 c1 78 11 07       	vmovups XMMWORD PTR [r15],xmm0
  228354:	eb 27                	jmp    22837d <readAllocBytes+0x12d>
    return buf;
  228356:	c5 f8 10 44 24 18    	vmovups xmm0,XMMWORD PTR [rsp+0x18]
  22835c:	c5 f8 11 44 24 34    	vmovups XMMWORD PTR [rsp+0x34],xmm0
  228362:	66 41 c7 07 00 00    	mov    WORD PTR [r15],0x0
  228368:	48 8b 44 24 3c       	mov    rax,QWORD PTR [rsp+0x3c]
  22836d:	49 89 47 10          	mov    QWORD PTR [r15+0x10],rax
  228371:	c5 f8 10 44 24 2e    	vmovups xmm0,XMMWORD PTR [rsp+0x2e]
  228377:	c4 c1 78 11 47 02    	vmovups XMMWORD PTR [r15+0x2],xmm0
  22837d:	48 83 c4 70          	add    rsp,0x70
  228381:	5b                   	pop    rbx
  228382:	41 5c                	pop    r12
  228384:	41 5e                	pop    r14
  228386:	41 5f                	pop    r15
  228388:	5d                   	pop    rbp
  228389:	c3                   	ret    
            @panic("assertion failure");
  22838a:	48 8d 3d 77 69 02 00 	lea    rdi,[rip+0x26977]        # 24ed08 <__unnamed_2>
  228391:	e8 8a 9c fe ff       	call   212020 <panic>
  228396:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  22839d:	00 00 00 

00000000002283a0 <readStringRaw>:
            return Self{
  2283a0:	55                   	push   rbp
  2283a1:	41 57                	push   r15
  2283a3:	41 56                	push   r14
  2283a5:	41 55                	push   r13
  2283a7:	41 54                	push   r12
  2283a9:	53                   	push   rbx
  2283aa:	48 81 ec 98 00 00 00 	sub    rsp,0x98
  2283b1:	c5 f8 57 c0          	vxorps xmm0,xmm0,xmm0
  2283b5:	c5 f8 29 44 24 40    	vmovaps XMMWORD PTR [rsp+0x40],xmm0
  2283bb:	48 89 d3             	mov    rbx,rdx
  2283be:	49 89 f7             	mov    r15,rsi
  2283c1:	48 89 7c 24 08       	mov    QWORD PTR [rsp+0x8],rdi
  2283c6:	48 c7 44 24 50 00 00 	mov    QWORD PTR [rsp+0x50],0x0
  2283cd:	00 00 
    var buf = ArrayList(u8).init(allocator);
  2283cf:	4c 89 7c 24 58       	mov    QWORD PTR [rsp+0x58],r15
  2283d4:	48 8d 44 24 07       	lea    rax,[rsp+0x7]
            try self.readNoEof(result[0..]);
  2283d9:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  2283de:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  2283e5:	00 00 
  2283e7:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  2283ec:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
            return self.readFn(self, buffer);
  2283f1:	48 89 de             	mov    rsi,rbx
  2283f4:	ff 13                	call   QWORD PTR [rbx]
  2283f6:	0f b7 4c 24 20       	movzx  ecx,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  2283fb:	66 85 c9             	test   cx,cx
  2283fe:	74 34                	je     228434 <readStringRaw+0x94>
  228400:	48 8b 54 24 08       	mov    rdx,QWORD PTR [rsp+0x8]
        const byte = try in_stream.readByte();
  228405:	66 89 0a             	mov    WORD PTR [rdx],cx
  228408:	48 8b 84 24 90 00 00 	mov    rax,QWORD PTR [rsp+0x90]
  22840f:	00 
  228410:	48 89 42 10          	mov    QWORD PTR [rdx+0x10],rax
  228414:	c5 f8 10 84 24 82 00 	vmovups xmm0,XMMWORD PTR [rsp+0x82]
  22841b:	00 00 
  22841d:	c5 f8 11 42 02       	vmovups XMMWORD PTR [rdx+0x2],xmm0
  228422:	48 81 c4 98 00 00 00 	add    rsp,0x98
  228429:	5b                   	pop    rbx
  22842a:	41 5c                	pop    r12
  22842c:	41 5d                	pop    r13
  22842e:	41 5e                	pop    r14
  228430:	41 5f                	pop    r15
  228432:	5d                   	pop    rbp
  228433:	c3                   	ret    
  228434:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
  228439:	31 ed                	xor    ebp,ebp
  22843b:	45 31 ed             	xor    r13d,r13d
  22843e:	66 90                	xchg   ax,ax
            if (amt_read < buf.len) return error.EndOfStream;
  228440:	48 3b 44 24 18       	cmp    rax,QWORD PTR [rsp+0x18]
  228445:	0f 82 b6 00 00 00    	jb     228501 <readStringRaw+0x161>
            return result[0];
  22844b:	44 8a 64 24 07       	mov    r12b,BYTE PTR [rsp+0x7]
        if (byte == 0) break;
  228450:	45 84 e4             	test   r12b,r12b
  228453:	0f 84 b1 00 00 00    	je     22850a <readStringRaw+0x16a>
            var better_capacity = self.items.len;
  228459:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
            if (better_capacity >= new_capacity) return;
  22845e:	4c 39 e9             	cmp    rcx,r13
  228461:	77 53                	ja     2284b6 <readStringRaw+0x116>
  228463:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  22846a:	84 00 00 00 00 00 
                better_capacity += better_capacity / 2 + 8;
  228470:	48 89 c8             	mov    rax,rcx
  228473:	48 d1 e8             	shr    rax,1
  228476:	48 01 c1             	add    rcx,rax
  228479:	48 83 c1 08          	add    rcx,0x8
                if (better_capacity >= new_capacity) break;
  22847d:	4c 39 e9             	cmp    rcx,r13
  228480:	76 ee                	jbe    228470 <readStringRaw+0xd0>
            self.items = try self.allocator.alignedRealloc(T, A, self.items, better_capacity);
  228482:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  228487:	4c 89 fe             	mov    rsi,r15
  22848a:	48 8d 54 24 40       	lea    rdx,[rsp+0x40]
  22848f:	e8 2c 28 00 00       	call   22acc0 <Allocator_alignedRealloc.188>
  228494:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  228499:	66 85 c0             	test   ax,ax
  22849c:	0f 85 94 00 00 00    	jne    228536 <readStringRaw+0x196>
  2284a2:	48 8d 44 24 28       	lea    rax,[rsp+0x28]
  2284a7:	c5 f8 10 00          	vmovups xmm0,XMMWORD PTR [rax]
  2284ab:	c5 f8 29 44 24 40    	vmovaps XMMWORD PTR [rsp+0x40],xmm0
            const result = &self.items[self.len];
  2284b1:	48 8b 6c 24 40       	mov    rbp,QWORD PTR [rsp+0x40]
  2284b6:	4d 8d 75 01          	lea    r14,[r13+0x1]
            self.len = new_length;
  2284ba:	4c 89 74 24 50       	mov    QWORD PTR [rsp+0x50],r14
            new_item_ptr.* = item;
  2284bf:	46 88 64 2d 00       	mov    BYTE PTR [rbp+r13*1+0x0],r12b
            try self.readNoEof(result[0..]);
  2284c4:	48 8d 44 24 07       	lea    rax,[rsp+0x7]
  2284c9:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  2284ce:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  2284d5:	00 00 
            return self.readFn(self, buffer);
  2284d7:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  2284dc:	48 89 de             	mov    rsi,rbx
  2284df:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  2284e4:	ff 13                	call   QWORD PTR [rbx]
  2284e6:	0f b7 4c 24 20       	movzx  ecx,WORD PTR [rsp+0x20]
  2284eb:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
  2284f0:	4d 89 f5             	mov    r13,r14
            const amt_read = try self.read(buf);
  2284f3:	66 85 c9             	test   cx,cx
  2284f6:	0f 84 44 ff ff ff    	je     228440 <readStringRaw+0xa0>
  2284fc:	e9 ff fe ff ff       	jmp    228400 <readStringRaw+0x60>
  228501:	66 b9 25 00          	mov    cx,0x25
  228505:	e9 f6 fe ff ff       	jmp    228400 <readStringRaw+0x60>
  22850a:	48 8b 54 24 08       	mov    rdx,QWORD PTR [rsp+0x8]
    return buf.toSlice();
  22850f:	66 c7 02 00 00       	mov    WORD PTR [rdx],0x0
  228514:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  228519:	66 89 42 06          	mov    WORD PTR [rdx+0x6],ax
            return self.items[0..self.len];
  22851d:	48 8b 44 24 40       	mov    rax,QWORD PTR [rsp+0x40]
  228522:	8b 4c 24 3a          	mov    ecx,DWORD PTR [rsp+0x3a]
  228526:	89 4a 02             	mov    DWORD PTR [rdx+0x2],ecx
  228529:	48 89 42 08          	mov    QWORD PTR [rdx+0x8],rax
  22852d:	4c 89 6a 10          	mov    QWORD PTR [rdx+0x10],r13
  228531:	e9 ec fe ff ff       	jmp    228422 <readStringRaw+0x82>
  228536:	48 8b 4c 24 08       	mov    rcx,QWORD PTR [rsp+0x8]
        try buf.append(byte);
  22853b:	66 89 01             	mov    WORD PTR [rcx],ax
  22853e:	48 8b 44 24 7a       	mov    rax,QWORD PTR [rsp+0x7a]
  228543:	48 89 41 10          	mov    QWORD PTR [rcx+0x10],rax
  228547:	c5 f8 10 44 24 6c    	vmovups xmm0,XMMWORD PTR [rsp+0x6c]
  22854d:	c5 f8 11 41 02       	vmovups XMMWORD PTR [rcx+0x2],xmm0
  228552:	e9 cb fe ff ff       	jmp    228422 <readStringRaw+0x82>
  228557:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  22855e:	00 00 

0000000000228560 <Allocator_alignedRealloc.171>:
    pub fn alignedRealloc(self: *Allocator, comptime T: type, comptime alignment: u29, old_mem: []align(alignment) T, n: usize) ![]align(alignment) T {
  228560:	41 56                	push   r14
  228562:	53                   	push   rbx
  228563:	48 81 ec 88 00 00 00 	sub    rsp,0x88
  22856a:	48 89 fb             	mov    rbx,rdi
        if (old_mem.len == 0) {
  22856d:	48 8b 42 08          	mov    rax,QWORD PTR [rdx+0x8]
  228571:	48 85 c0             	test   rax,rax
  228574:	74 62                	je     2285d8 <Allocator_alignedRealloc.171+0x78>
        if (n == 0) {
  228576:	48 85 c9             	test   rcx,rcx
  228579:	0f 84 a9 00 00 00    	je     228628 <Allocator_alignedRealloc.171+0xc8>
        const old_byte_slice = @sliceToBytes(old_mem);
  22857f:	48 8b 12             	mov    rdx,QWORD PTR [rdx]
  228582:	48 c1 e0 04          	shl    rax,0x4
  228586:	48 8d 04 40          	lea    rax,[rax+rax*2]
  22858a:	48 89 54 24 38       	mov    QWORD PTR [rsp+0x38],rdx
  22858f:	48 89 44 24 40       	mov    QWORD PTR [rsp+0x40],rax
  228594:	ba 30 00 00 00       	mov    edx,0x30
  228599:	48 89 c8             	mov    rax,rcx
  22859c:	48 f7 e2             	mul    rdx
  22859f:	0f 81 d0 00 00 00    	jno    228675 <Allocator_alignedRealloc.171+0x115>
  2285a5:	48 8d 0d d4 09 fe ff 	lea    rcx,[rip+0xfffffffffffe09d4]        # 208f80 <__unnamed_43>
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  2285ac:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  2285b0:	0f 84 da 00 00 00    	je     228690 <Allocator_alignedRealloc.171+0x130>
  2285b6:	48 8b 05 6b f3 fd ff 	mov    rax,QWORD PTR [rip+0xfffffffffffdf36b]        # 207928 <__unnamed_82+0x10>
  2285bd:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  2285c1:	c5 f8 10 05 4f f3 fd 	vmovups xmm0,XMMWORD PTR [rip+0xfffffffffffdf34f]        # 207918 <__unnamed_82>
  2285c8:	ff 
  2285c9:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  2285cd:	48 81 c4 88 00 00 00 	add    rsp,0x88
  2285d4:	5b                   	pop    rbx
  2285d5:	41 5e                	pop    r14
  2285d7:	c3                   	ret    
        if (n == 0) {
  2285d8:	48 85 c9             	test   rcx,rcx
  2285db:	0f 84 fc 00 00 00    	je     2286dd <Allocator_alignedRealloc.171+0x17d>
  2285e1:	ba 30 00 00 00       	mov    edx,0x30
  2285e6:	48 89 c8             	mov    rax,rcx
  2285e9:	48 f7 e2             	mul    rdx
  2285ec:	0f 81 0c 01 00 00    	jno    2286fe <Allocator_alignedRealloc.171+0x19e>
  2285f2:	48 8d 0d 87 09 fe ff 	lea    rcx,[rip+0xfffffffffffe0987]        # 208f80 <__unnamed_43>
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  2285f9:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  2285fd:	0f 84 16 01 00 00    	je     228719 <Allocator_alignedRealloc.171+0x1b9>
  228603:	0f b7 05 14 f3 fd ff 	movzx  eax,WORD PTR [rip+0xfffffffffffdf314]        # 20791e <__unnamed_82+0x6>
  22860a:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  22860f:	8b 05 05 f3 fd ff    	mov    eax,DWORD PTR [rip+0xfffffffffffdf305]        # 20791a <__unnamed_82+0x2>
  228615:	89 04 24             	mov    DWORD PTR [rsp],eax
  228618:	48 89 e0             	mov    rax,rsp
  22861b:	66 b9 01 00          	mov    cx,0x1
  22861f:	31 f6                	xor    esi,esi
  228621:	31 d2                	xor    edx,edx
  228623:	e9 9d 01 00 00       	jmp    2287c5 <Allocator_alignedRealloc.171+0x265>
        const bytes = @sliceToBytes(memory);
  228628:	48 c1 e0 04          	shl    rax,0x4
  22862c:	48 8d 04 40          	lea    rax,[rax+rax*2]
        if (bytes.len == 0) return;
  228630:	48 85 c0             	test   rax,rax
  228633:	74 1e                	je     228653 <Allocator_alignedRealloc.171+0xf3>
        const bytes = @sliceToBytes(memory);
  228635:	48 8b 0a             	mov    rcx,QWORD PTR [rdx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  228638:	48 8b 56 10          	mov    rdx,QWORD PTR [rsi+0x10]
  22863c:	48 89 4c 24 08       	mov    QWORD PTR [rsp+0x8],rcx
  228641:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  228646:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  22864b:	48 89 f7             	mov    rdi,rsi
  22864e:	48 89 c6             	mov    rsi,rax
  228651:	ff d2                	call   rdx
            return ([*]align(alignment) T)(undefined)[0..0];
  228653:	48 8b 05 b6 f2 fd ff 	mov    rax,QWORD PTR [rip+0xfffffffffffdf2b6]        # 207910 <__unnamed_83+0x10>
  22865a:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  22865e:	c5 f8 10 05 9a f2 fd 	vmovups xmm0,XMMWORD PTR [rip+0xfffffffffffdf29a]        # 207900 <__unnamed_83>
  228665:	ff 
  228666:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  22866a:	48 81 c4 88 00 00 00 	add    rsp,0x88
  228671:	5b                   	pop    rbx
  228672:	41 5e                	pop    r14
  228674:	c3                   	ret    
  228675:	48 8d 4c 24 08       	lea    rcx,[rsp+0x8]
  22867a:	66 c7 44 24 08 00 00 	mov    WORD PTR [rsp+0x8],0x0
  228681:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  228686:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  22868a:	0f 85 26 ff ff ff    	jne    2285b6 <Allocator_alignedRealloc.171+0x56>
  228690:	4c 8b 71 08          	mov    r14,QWORD PTR [rcx+0x8]
  228694:	48 8d 7c 24 58       	lea    rdi,[rsp+0x58]
  228699:	48 8d 54 24 38       	lea    rdx,[rsp+0x38]
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  22869e:	41 b8 02 00 00 00    	mov    r8d,0x2
  2286a4:	4c 89 f1             	mov    rcx,r14
  2286a7:	ff 56 08             	call   QWORD PTR [rsi+0x8]
  2286aa:	0f b7 44 24 58       	movzx  eax,WORD PTR [rsp+0x58]
  2286af:	66 85 c0             	test   ax,ax
  2286b2:	0f 84 94 00 00 00    	je     22874c <Allocator_alignedRealloc.171+0x1ec>
  2286b8:	66 89 03             	mov    WORD PTR [rbx],ax
  2286bb:	48 8b 84 24 80 00 00 	mov    rax,QWORD PTR [rsp+0x80]
  2286c2:	00 
  2286c3:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  2286c7:	c5 f8 10 44 24 72    	vmovups xmm0,XMMWORD PTR [rsp+0x72]
  2286cd:	c5 f8 11 43 02       	vmovups XMMWORD PTR [rbx+0x2],xmm0
  2286d2:	48 81 c4 88 00 00 00 	add    rsp,0x88
  2286d9:	5b                   	pop    rbx
  2286da:	41 5e                	pop    r14
  2286dc:	c3                   	ret    
  2286dd:	48 89 e0             	mov    rax,rsp
            return ([*]align(alignment) T)(undefined)[0..0];
  2286e0:	0f b7 0d 1f f2 fd ff 	movzx  ecx,WORD PTR [rip+0xfffffffffffdf21f]        # 207906 <__unnamed_83+0x6>
  2286e7:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  2286ec:	8b 0d 10 f2 fd ff    	mov    ecx,DWORD PTR [rip+0xfffffffffffdf210]        # 207902 <__unnamed_83+0x2>
  2286f2:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  2286f5:	31 c9                	xor    ecx,ecx
  2286f7:	31 d2                	xor    edx,edx
  2286f9:	e9 c7 00 00 00       	jmp    2287c5 <Allocator_alignedRealloc.171+0x265>
  2286fe:	48 8d 4c 24 48       	lea    rcx,[rsp+0x48]
  228703:	66 c7 44 24 48 00 00 	mov    WORD PTR [rsp+0x48],0x0
  22870a:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  22870f:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  228713:	0f 85 ea fe ff ff    	jne    228603 <Allocator_alignedRealloc.171+0xa3>
  228719:	4c 8b 71 08          	mov    r14,QWORD PTR [rcx+0x8]
  22871d:	48 8d 7c 24 08       	lea    rdi,[rsp+0x8]
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  228722:	b9 02 00 00 00       	mov    ecx,0x2
  228727:	4c 89 f2             	mov    rdx,r14
  22872a:	ff 16                	call   QWORD PTR [rsi]
  22872c:	0f b7 4c 24 08       	movzx  ecx,WORD PTR [rsp+0x8]
  228731:	66 85 c9             	test   cx,cx
  228734:	74 57                	je     22878d <Allocator_alignedRealloc.171+0x22d>
  228736:	0f b7 44 24 36       	movzx  eax,WORD PTR [rsp+0x36]
  22873b:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  228740:	48 89 e0             	mov    rax,rsp
  228743:	8b 54 24 32          	mov    edx,DWORD PTR [rsp+0x32]
  228747:	89 14 24             	mov    DWORD PTR [rsp],edx
  22874a:	eb 79                	jmp    2287c5 <Allocator_alignedRealloc.171+0x265>
        assert(byte_slice.len == byte_count);
  22874c:	4c 39 74 24 68       	cmp    QWORD PTR [rsp+0x68],r14
    if (!ok) {
  228751:	0f 85 91 00 00 00    	jne    2287e8 <Allocator_alignedRealloc.171+0x288>
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  228757:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  22875c:	48 b9 ab aa aa aa aa 	movabs rcx,0xaaaaaaaaaaaaaaab
  228763:	aa aa aa 
  228766:	4c 89 f2             	mov    rdx,r14
  228769:	c4 e2 f3 f6 d1       	mulx   rdx,rcx,rcx
  22876e:	66 c7 03 00 00       	mov    WORD PTR [rbx],0x0
  228773:	0f b7 4c 24 2a       	movzx  ecx,WORD PTR [rsp+0x2a]
  228778:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  22877c:	48 c1 ea 05          	shr    rdx,0x5
  228780:	8b 4c 24 26          	mov    ecx,DWORD PTR [rsp+0x26]
  228784:	89 4b 02             	mov    DWORD PTR [rbx+0x2],ecx
  228787:	48 89 43 08          	mov    QWORD PTR [rbx+0x8],rax
  22878b:	eb 4c                	jmp    2287d9 <Allocator_alignedRealloc.171+0x279>
        assert(byte_slice.len == byte_count);
  22878d:	4c 39 74 24 18       	cmp    QWORD PTR [rsp+0x18],r14
  228792:	75 54                	jne    2287e8 <Allocator_alignedRealloc.171+0x288>
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  228794:	48 8b 74 24 10       	mov    rsi,QWORD PTR [rsp+0x10]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  228799:	48 b8 ab aa aa aa aa 	movabs rax,0xaaaaaaaaaaaaaaab
  2287a0:	aa aa aa 
  2287a3:	4c 89 f2             	mov    rdx,r14
  2287a6:	c4 e2 fb f6 d0       	mulx   rdx,rax,rax
  2287ab:	48 c1 ea 05          	shr    rdx,0x5
  2287af:	48 89 e0             	mov    rax,rsp
  2287b2:	8b 4c 24 2c          	mov    ecx,DWORD PTR [rsp+0x2c]
  2287b6:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  2287b9:	0f b7 4c 24 30       	movzx  ecx,WORD PTR [rsp+0x30]
  2287be:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  2287c3:	31 c9                	xor    ecx,ecx
            return self.alignedAlloc(T, alignment, n);
  2287c5:	66 89 0b             	mov    WORD PTR [rbx],cx
  2287c8:	0f b7 48 04          	movzx  ecx,WORD PTR [rax+0x4]
  2287cc:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  2287d0:	8b 00                	mov    eax,DWORD PTR [rax]
  2287d2:	89 43 02             	mov    DWORD PTR [rbx+0x2],eax
  2287d5:	48 89 73 08          	mov    QWORD PTR [rbx+0x8],rsi
  2287d9:	48 89 53 10          	mov    QWORD PTR [rbx+0x10],rdx
  2287dd:	48 81 c4 88 00 00 00 	add    rsp,0x88
  2287e4:	5b                   	pop    rbx
  2287e5:	41 5e                	pop    r14
  2287e7:	c3                   	ret    
            @panic("assertion failure");
  2287e8:	48 8d 3d 19 65 02 00 	lea    rdi,[rip+0x26519]        # 24ed08 <__unnamed_2>
  2287ef:	e8 2c 98 fe ff       	call   212020 <panic>
  2287f4:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  2287fb:	00 00 00 00 00 

0000000000228800 <getLineNumberInfo>:
fn getLineNumberInfo(st: *ElfStackTrace, compile_unit: *const CompileUnit, target_address: usize) !LineInfo {
  228800:	55                   	push   rbp
  228801:	41 57                	push   r15
  228803:	41 56                	push   r14
  228805:	41 55                	push   r13
  228807:	41 54                	push   r12
  228809:	53                   	push   rbx
  22880a:	48 81 ec 18 0b 00 00 	sub    rsp,0xb18
  228811:	49 89 cc             	mov    r12,rcx
  228814:	49 89 d6             	mov    r14,rdx
  228817:	49 89 f7             	mov    r15,rsi
  22881a:	48 89 fd             	mov    rbp,rdi
    const compile_unit_cwd = try compile_unit.die.getAttrString(st, DW.AT_comp_dir);
  22881d:	49 8b 46 08          	mov    rax,QWORD PTR [r14+0x8]
            return self.items[0..self.len];
  228821:	48 8b 48 20          	mov    rcx,QWORD PTR [rax+0x20]
        for (self.attrs.toSliceConst()) |*attr| {
  228825:	48 85 c9             	test   rcx,rcx
  228828:	74 19                	je     228843 <getLineNumberInfo+0x43>
  22882a:	48 8b 40 10          	mov    rax,QWORD PTR [rax+0x10]
  22882e:	31 d2                	xor    edx,edx
            if (attr.id == id) return &attr.value;
  228830:	48 83 38 1b          	cmp    QWORD PTR [rax],0x1b
  228834:	74 36                	je     22886c <getLineNumberInfo+0x6c>
        for (self.attrs.toSliceConst()) |*attr| {
  228836:	48 83 c2 01          	add    rdx,0x1
  22883a:	48 83 c0 28          	add    rax,0x28
  22883e:	48 39 ca             	cmp    rdx,rcx
  228841:	72 ed                	jb     228830 <getLineNumberInfo+0x30>
        const form_value = self.getAttr(id) orelse return error.MissingDebugInfo;
  228843:	48 8b 05 96 f1 fd ff 	mov    rax,QWORD PTR [rip+0xfffffffffffdf196]        # 2079e0 <__unnamed_40+0x10>
  22884a:	48 89 84 24 7e 01 00 	mov    QWORD PTR [rsp+0x17e],rax
  228851:	00 
  228852:	c5 f8 10 05 78 f1 fd 	vmovups xmm0,XMMWORD PTR [rip+0xfffffffffffdf178]        # 2079d2 <__unnamed_40+0x2>
  228859:	ff 
  22885a:	c5 f8 29 84 24 70 01 	vmovaps XMMWORD PTR [rsp+0x170],xmm0
  228861:	00 00 
  228863:	66 b8 28 00          	mov    ax,0x28
  228867:	e9 c5 00 00 00       	jmp    228931 <getLineNumberInfo+0x131>
  22886c:	8a 48 20             	mov    cl,BYTE PTR [rax+0x20]
  22886f:	80 f9 0a             	cmp    cl,0xa
        return switch (form_value.*) {
  228872:	74 1e                	je     228892 <getLineNumberInfo+0x92>
  228874:	80 f9 09             	cmp    cl,0x9
  228877:	75 69                	jne    2288e2 <getLineNumberInfo+0xe2>
            FormValue.String => |value| value,
  228879:	66 c7 44 24 08 00 00 	mov    WORD PTR [rsp+0x8],0x0
  228880:	c5 f8 10 40 08       	vmovups xmm0,XMMWORD PTR [rax+0x8]
  228885:	c5 f8 11 44 24 10    	vmovups XMMWORD PTR [rsp+0x10],xmm0
  22888b:	48 8d 5c 24 08       	lea    rbx,[rsp+0x8]
  228890:	eb 7d                	jmp    22890f <getLineNumberInfo+0x10f>
            FormValue.StrPtr => |offset| getString(st, offset),
  228892:	48 8b 70 08          	mov    rsi,QWORD PTR [rax+0x8]
    const pos = st.debug_str.offset + offset;
  228896:	49 8b 47 70          	mov    rax,QWORD PTR [r15+0x70]
    if (@maxValue(@typeOf(x)) > @maxValue(T) and x > @maxValue(T)) {
  22889a:	48 03 70 18          	add    rsi,QWORD PTR [rax+0x18]
  22889e:	78 4b                	js     2288eb <getLineNumberInfo+0xeb>
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  2288a0:	49 63 3f             	movsxd rdi,DWORD PTR [r15]
  2288a3:	31 db                	xor    ebx,ebx
  2288a5:	b8 08 00 00 00       	mov    eax,0x8
  2288aa:	31 d2                	xor    edx,edx
  2288ac:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  2288ae:	48 89 c1             	mov    rcx,rax
  2288b1:	48 f7 d9             	neg    rcx
  2288b4:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  2288ba:	48 0f 46 cb          	cmovbe rcx,rbx
  2288be:	66 b8 03 00          	mov    ax,0x3
                if (err > 0) {
  2288c2:	48 83 f9 1d          	cmp    rcx,0x1d
  2288c6:	0f 87 44 02 00 00    	ja     228b10 <getLineNumberInfo+0x310>
  2288cc:	48 8d 15 1d 81 fd ff 	lea    rdx,[rip+0xfffffffffffd811d]        # 2009f0 <__unnamed_609+0x6b0>
  2288d3:	48 63 0c 8a          	movsxd rcx,DWORD PTR [rdx+rcx*4]
  2288d7:	48 01 d1             	add    rcx,rdx
  2288da:	ff e1                	jmp    rcx
  2288dc:	66 b8 27 00          	mov    ax,0x27
  2288e0:	eb 0d                	jmp    2288ef <getLineNumberInfo+0xef>
  2288e2:	48 8d 1d ff f0 fd ff 	lea    rbx,[rip+0xfffffffffffdf0ff]        # 2079e8 <__unnamed_24>
  2288e9:	eb 24                	jmp    22890f <getLineNumberInfo+0x10f>
  2288eb:	66 b8 04 00          	mov    ax,0x4
    try st.self_exe_file.seekTo(pos);
  2288ef:	66 89 44 24 20       	mov    WORD PTR [rsp+0x20],ax
  2288f4:	c5 f8 10 44 24 48    	vmovups xmm0,XMMWORD PTR [rsp+0x48]
  2288fa:	c5 f8 11 44 24 22    	vmovups XMMWORD PTR [rsp+0x22],xmm0
  228900:	48 8b 44 24 56       	mov    rax,QWORD PTR [rsp+0x56]
  228905:	48 89 44 24 30       	mov    QWORD PTR [rsp+0x30],rax
  22890a:	48 8d 5c 24 20       	lea    rbx,[rsp+0x20]
        return switch (form_value.*) {
  22890f:	0f b7 03             	movzx  eax,WORD PTR [rbx]
  228912:	48 8b 4b 10          	mov    rcx,QWORD PTR [rbx+0x10]
  228916:	48 89 8c 24 7e 01 00 	mov    QWORD PTR [rsp+0x17e],rcx
  22891d:	00 
  22891e:	c5 f8 10 43 02       	vmovups xmm0,XMMWORD PTR [rbx+0x2]
  228923:	c5 f8 29 84 24 70 01 	vmovaps XMMWORD PTR [rsp+0x170],xmm0
  22892a:	00 00 
    const compile_unit_cwd = try compile_unit.die.getAttrString(st, DW.AT_comp_dir);
  22892c:	66 85 c0             	test   ax,ax
  22892f:	74 35                	je     228966 <getLineNumberInfo+0x166>
  228931:	66 89 45 00          	mov    WORD PTR [rbp+0x0],ax
  228935:	c5 fe 6f 84 24 ca 0a 	vmovdqu ymm0,YMMWORD PTR [rsp+0xaca]
  22893c:	00 00 
  22893e:	c5 fc 10 8c 24 d8 0a 	vmovups ymm1,YMMWORD PTR [rsp+0xad8]
  228945:	00 00 
  228947:	c5 fc 11 4d 10       	vmovups YMMWORD PTR [rbp+0x10],ymm1
  22894c:	c5 fe 7f 45 02       	vmovdqu YMMWORD PTR [rbp+0x2],ymm0
  228951:	48 81 c4 18 0b 00 00 	add    rsp,0xb18
  228958:	5b                   	pop    rbx
  228959:	41 5c                	pop    r12
  22895b:	41 5d                	pop    r13
  22895d:	41 5e                	pop    r14
  22895f:	41 5f                	pop    r15
  228961:	5d                   	pop    rbp
  228962:	c5 f8 77             	vzeroupper 
  228965:	c3                   	ret    
  228966:	4c 89 a4 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],r12
  22896d:	00 
  22896e:	48 89 2c 24          	mov    QWORD PTR [rsp],rbp
  228972:	c5 fa 6f 84 24 76 01 	vmovdqu xmm0,XMMWORD PTR [rsp+0x176]
  228979:	00 00 
  22897b:	c5 f9 7f 84 24 e0 01 	vmovdqa XMMWORD PTR [rsp+0x1e0],xmm0
  228982:	00 00 
    const debug_line_end = st.debug_line.offset + st.debug_line.size;
  228984:	49 8b 47 78          	mov    rax,QWORD PTR [r15+0x78]
  228988:	48 8b 58 18          	mov    rbx,QWORD PTR [rax+0x18]
  22898c:	4c 8b 60 20          	mov    r12,QWORD PTR [rax+0x20]
    var in_file_stream = io.FileInStream.init(in_file);
  228990:	4c 89 7c 24 38       	mov    QWORD PTR [rsp+0x38],r15
  228995:	48 8d 05 34 c3 ff ff 	lea    rax,[rip+0xffffffffffffc334]        # 224cd0 <FileInStream_readFn>
  22899c:	48 89 44 24 40       	mov    QWORD PTR [rsp+0x40],rax
    while (this_offset < debug_line_end) : (this_index += 1) {
  2289a1:	4d 85 e4             	test   r12,r12
  2289a4:	0f 84 44 01 00 00    	je     228aee <getLineNumberInfo+0x2ee>
  2289aa:	49 01 dc             	add    r12,rbx
  2289ad:	49 c7 c5 ff ff ff ff 	mov    r13,0xffffffffffffffff
  2289b4:	4c 89 7c 24 60       	mov    QWORD PTR [rsp+0x60],r15
  2289b9:	48 85 db             	test   rbx,rbx
  2289bc:	0f 88 9e 01 00 00    	js     228b60 <getLineNumberInfo+0x360>
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  2289c2:	49 63 3f             	movsxd rdi,DWORD PTR [r15]
  2289c5:	b8 08 00 00 00       	mov    eax,0x8
  2289ca:	31 d2                	xor    edx,edx
  2289cc:	48 89 de             	mov    rsi,rbx
  2289cf:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  2289d1:	48 89 c1             	mov    rcx,rax
  2289d4:	48 f7 d9             	neg    rcx
  2289d7:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  2289dd:	b8 00 00 00 00       	mov    eax,0x0
  2289e2:	48 0f 46 c8          	cmovbe rcx,rax
  2289e6:	48 85 c9             	test   rcx,rcx
  2289e9:	0f 85 77 01 00 00    	jne    228b66 <getLineNumberInfo+0x366>
            try self.readNoEof(bytes[0..]);
  2289ef:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  2289f4:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  2289f9:	48 c7 44 24 10 04 00 	mov    QWORD PTR [rsp+0x10],0x4
  228a00:	00 00 
            return self.readFn(self, buffer);
  228a02:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  228a07:	48 8d 6c 24 40       	lea    rbp,[rsp+0x40]
  228a0c:	48 89 ee             	mov    rsi,rbp
  228a0f:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
  228a14:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  228a18:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  228a1d:	66 85 c0             	test   ax,ax
  228a20:	0f 85 ed 01 00 00    	jne    228c13 <getLineNumberInfo+0x413>
  228a26:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
            if (amt_read < buf.len) return error.EndOfStream;
  228a2b:	48 3b 44 24 10       	cmp    rax,QWORD PTR [rsp+0x10]
  228a30:	0f 82 e9 00 00 00    	jb     228b1f <getLineNumberInfo+0x31f>
  228a36:	0f b6 44 24 48       	movzx  eax,BYTE PTR [rsp+0x48]
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  228a3b:	0f b6 4c 24 49       	movzx  ecx,BYTE PTR [rsp+0x49]
  228a40:	48 c1 e1 08          	shl    rcx,0x8
  228a44:	48 09 c1             	or     rcx,rax
  228a47:	0f b6 54 24 4a       	movzx  edx,BYTE PTR [rsp+0x4a]
  228a4c:	48 c1 e2 10          	shl    rdx,0x10
  228a50:	48 09 ca             	or     rdx,rcx
  228a53:	0f b6 44 24 4b       	movzx  eax,BYTE PTR [rsp+0x4b]
  228a58:	48 c1 e0 18          	shl    rax,0x18
  228a5c:	48 09 d0             	or     rax,rdx
    is_64.* = (first_32_bits == 0xffffffff);
  228a5f:	83 f8 ff             	cmp    eax,0xffffffff
    if (is_64.*) {
  228a62:	74 3f                	je     228aa3 <getLineNumberInfo+0x2a3>
        if (first_32_bits >= 0xfffffff0) return error.InvalidDebugInfo;
  228a64:	83 f8 ef             	cmp    eax,0xffffffef
  228a67:	0f 87 a2 01 00 00    	ja     228c0f <getLineNumberInfo+0x40f>
  228a6d:	45 31 ff             	xor    r15d,r15d
        if (unit_length == 0) return error.MissingDebugInfo;
  228a70:	48 85 c0             	test   rax,rax
  228a73:	74 79                	je     228aee <getLineNumberInfo+0x2ee>
        if (compile_unit.index != this_index) {
  228a75:	49 83 c5 01          	add    r13,0x1
  228a79:	4d 3b 6e 10          	cmp    r13,QWORD PTR [r14+0x10]
  228a7d:	0f 84 29 01 00 00    	je     228bac <getLineNumberInfo+0x3ac>
        const next_offset = unit_length + (if (is_64) usize(12) else usize(4));
  228a83:	41 0f b6 cf          	movzx  ecx,r15b
  228a87:	48 8d 0c cb          	lea    rcx,[rbx+rcx*8]
            this_offset += next_offset;
  228a8b:	48 8d 1c 08          	lea    rbx,[rax+rcx*1]
  228a8f:	48 83 c3 04          	add    rbx,0x4
    while (this_offset < debug_line_end) : (this_index += 1) {
  228a93:	4c 39 e3             	cmp    rbx,r12
  228a96:	4c 8b 7c 24 60       	mov    r15,QWORD PTR [rsp+0x60]
  228a9b:	0f 82 18 ff ff ff    	jb     2289b9 <getLineNumberInfo+0x1b9>
  228aa1:	eb 4b                	jmp    228aee <getLineNumberInfo+0x2ee>
            try self.readNoEof(bytes[0..]);
  228aa3:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  228aa8:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  228aad:	48 c7 44 24 10 08 00 	mov    QWORD PTR [rsp+0x10],0x8
  228ab4:	00 00 
            return self.readFn(self, buffer);
  228ab6:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  228abb:	48 89 ee             	mov    rsi,rbp
  228abe:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
  228ac3:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  228ac7:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  228acc:	66 85 c0             	test   ax,ax
  228acf:	0f 85 3e 01 00 00    	jne    228c13 <getLineNumberInfo+0x413>
  228ad5:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
            if (amt_read < buf.len) return error.EndOfStream;
  228ada:	48 3b 44 24 10       	cmp    rax,QWORD PTR [rsp+0x10]
  228adf:	72 3e                	jb     228b1f <getLineNumberInfo+0x31f>
  228ae1:	48 8b 44 24 48       	mov    rax,QWORD PTR [rsp+0x48]
  228ae6:	41 b7 01             	mov    r15b,0x1
        if (unit_length == 0) return error.MissingDebugInfo;
  228ae9:	48 85 c0             	test   rax,rax
  228aec:	75 87                	jne    228a75 <getLineNumberInfo+0x275>
  228aee:	c5 fc 10 05 62 ef fd 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffdef62]        # 207a58 <__unnamed_84+0x10>
  228af5:	ff 
  228af6:	48 8b 04 24          	mov    rax,QWORD PTR [rsp]
  228afa:	c5 fc 11 40 10       	vmovups YMMWORD PTR [rax+0x10],ymm0
  228aff:	c5 fe 6f 05 41 ef fd 	vmovdqu ymm0,YMMWORD PTR [rip+0xfffffffffffdef41]        # 207a48 <__unnamed_84>
  228b06:	ff 
  228b07:	c5 fe 7f 00          	vmovdqu YMMWORD PTR [rax],ymm0
  228b0b:	e9 41 fe ff ff       	jmp    228951 <getLineNumberInfo+0x151>
  228b10:	48 83 f9 4b          	cmp    rcx,0x4b
  228b14:	0f 85 d5 fd ff ff    	jne    2288ef <getLineNumberInfo+0xef>
  228b1a:	e9 bd fd ff ff       	jmp    2288dc <getLineNumberInfo+0xdc>
  228b1f:	66 b8 25 00          	mov    ax,0x25
  228b23:	e9 eb 00 00 00       	jmp    228c13 <getLineNumberInfo+0x413>
            var in_file_stream = io.FileInStream.init(&self.self_exe_file);
  228b28:	4c 89 bc 24 a0 01 00 	mov    QWORD PTR [rsp+0x1a0],r15
  228b2f:	00 
  228b30:	48 8d 94 24 a8 01 00 	lea    rdx,[rsp+0x1a8]
  228b37:	00 
  228b38:	48 8d 05 91 c1 ff ff 	lea    rax,[rip+0xffffffffffffc191]        # 224cd0 <FileInStream_readFn>
  228b3f:	48 89 84 24 a8 01 00 	mov    QWORD PTR [rsp+0x1a8],rax
  228b46:	00 
  228b47:	49 8b b7 a0 00 00 00 	mov    rsi,QWORD PTR [r15+0xa0]
  228b4e:	48 8d 5c 24 20       	lea    rbx,[rsp+0x20]
            return readStringRaw(self.allocator(), in_stream);
  228b53:	48 89 df             	mov    rdi,rbx
  228b56:	e8 45 f8 ff ff       	call   2283a0 <readStringRaw>
  228b5b:	e9 af fd ff ff       	jmp    22890f <getLineNumberInfo+0x10f>
  228b60:	66 b8 04 00          	mov    ax,0x4
  228b64:	eb 28                	jmp    228b8e <getLineNumberInfo+0x38e>
  228b66:	48 8d 41 ea          	lea    rax,[rcx-0x16]
  228b6a:	48 83 f8 35          	cmp    rax,0x35
  228b6e:	77 10                	ja     228b80 <getLineNumberInfo+0x380>
  228b70:	48 ba 81 00 00 00 00 	movabs rdx,0x20000000000081
  228b77:	00 20 00 
  228b7a:	48 0f a3 c2          	bt     rdx,rax
  228b7e:	72 0a                	jb     228b8a <getLineNumberInfo+0x38a>
  228b80:	66 b8 03 00          	mov    ax,0x3
  228b84:	48 83 f9 06          	cmp    rcx,0x6
  228b88:	75 04                	jne    228b8e <getLineNumberInfo+0x38e>
  228b8a:	66 b8 27 00          	mov    ax,0x27
  228b8e:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
        try in_file.seekTo(this_offset);
  228b92:	66 89 01             	mov    WORD PTR [rcx],ax
  228b95:	c5 fe 6f 84 24 9c 0a 	vmovdqu ymm0,YMMWORD PTR [rsp+0xa9c]
  228b9c:	00 00 
  228b9e:	c5 fc 10 8c 24 aa 0a 	vmovups ymm1,YMMWORD PTR [rsp+0xaaa]
  228ba5:	00 00 
  228ba7:	e9 80 00 00 00       	jmp    228c2c <getLineNumberInfo+0x42c>
        const version = try in_stream.readInt(st.elf.endian, u16);
  228bac:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
  228bb1:	8a 58 12             	mov    bl,BYTE PTR [rax+0x12]
            try self.readNoEof(bytes[0..]);
  228bb4:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  228bb9:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  228bbe:	48 c7 44 24 10 02 00 	mov    QWORD PTR [rsp+0x10],0x2
  228bc5:	00 00 
  228bc7:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  228bcc:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
            return self.readFn(self, buffer);
  228bd1:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  228bd6:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  228bda:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  228bdf:	66 85 c0             	test   ax,ax
  228be2:	75 10                	jne    228bf4 <getLineNumberInfo+0x3f4>
  228be4:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  228be9:	66 b8 25 00          	mov    ax,0x25
            if (amt_read < buf.len) return error.EndOfStream;
  228bed:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  228bf2:	73 47                	jae    228c3b <getLineNumberInfo+0x43b>
  228bf4:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
  228bf8:	66 89 01             	mov    WORD PTR [rcx],ax
  228bfb:	c5 fe 6f 84 24 40 0a 	vmovdqu ymm0,YMMWORD PTR [rsp+0xa40]
  228c02:	00 00 
  228c04:	c5 fc 10 8c 24 4e 0a 	vmovups ymm1,YMMWORD PTR [rsp+0xa4e]
  228c0b:	00 00 
  228c0d:	eb 1d                	jmp    228c2c <getLineNumberInfo+0x42c>
  228c0f:	66 b8 29 00          	mov    ax,0x29
  228c13:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
        const unit_length = try readInitialLength(@typeOf(in_stream.readFn).ReturnType.ErrorSet, in_stream, &is_64);
  228c17:	66 89 01             	mov    WORD PTR [rcx],ax
  228c1a:	c5 fe 6f 84 24 6e 0a 	vmovdqu ymm0,YMMWORD PTR [rsp+0xa6e]
  228c21:	00 00 
  228c23:	c5 fc 10 8c 24 7c 0a 	vmovups ymm1,YMMWORD PTR [rsp+0xa7c]
  228c2a:	00 00 
  228c2c:	c5 fc 11 49 10       	vmovups YMMWORD PTR [rcx+0x10],ymm1
  228c31:	c5 fe 7f 41 02       	vmovdqu YMMWORD PTR [rcx+0x2],ymm0
  228c36:	e9 16 fd ff ff       	jmp    228951 <getLineNumberInfo+0x151>
  228c3b:	0f b6 44 24 48       	movzx  eax,BYTE PTR [rsp+0x48]
  228c40:	0f b6 4c 24 49       	movzx  ecx,BYTE PTR [rsp+0x49]
  228c45:	89 ca                	mov    edx,ecx
  228c47:	c1 e2 08             	shl    edx,0x8
  228c4a:	09 c2                	or     edx,eax
                result = (result << 8) | b;
  228c4c:	c1 e0 08             	shl    eax,0x8
  228c4f:	09 c8                	or     eax,ecx
    switch (endian) {
  228c51:	f6 c3 01             	test   bl,0x1
  228c54:	66 0f 45 c2          	cmovne ax,dx
        if (version != 2 and version != 4) return error.InvalidDebugInfo;
  228c58:	44 0f b7 e0          	movzx  r12d,ax
  228c5c:	41 83 fc 02          	cmp    r12d,0x2
  228c60:	48 8b 2c 24          	mov    rbp,QWORD PTR [rsp]
  228c64:	74 0a                	je     228c70 <getLineNumberInfo+0x470>
  228c66:	41 83 fc 04          	cmp    r12d,0x4
  228c6a:	0f 85 ac 00 00 00    	jne    228d1c <getLineNumberInfo+0x51c>
  228c70:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
  228c75:	8a 58 12             	mov    bl,BYTE PTR [rax+0x12]
        const prologue_length = if (is_64) try in_stream.readInt(st.elf.endian, u64) else try in_stream.readInt(st.elf.endian, u32);
  228c78:	45 84 ff             	test   r15b,r15b
  228c7b:	74 44                	je     228cc1 <getLineNumberInfo+0x4c1>
  228c7d:	0f b6 d3             	movzx  edx,bl
  228c80:	48 8d bc 24 90 01 00 	lea    rdi,[rsp+0x190]
  228c87:	00 
  228c88:	48 8d 5c 24 40       	lea    rbx,[rsp+0x40]
  228c8d:	48 89 de             	mov    rsi,rbx
  228c90:	e8 db bd ff ff       	call   224a70 <InStream(ReadError)_readInt.147>
  228c95:	0f b7 84 24 90 01 00 	movzx  eax,WORD PTR [rsp+0x190]
  228c9c:	00 
  228c9d:	66 85 c0             	test   ax,ax
  228ca0:	0f 84 95 00 00 00    	je     228d3b <getLineNumberInfo+0x53b>
  228ca6:	66 89 45 00          	mov    WORD PTR [rbp+0x0],ax
  228caa:	c5 fe 6f 84 24 12 0a 	vmovdqu ymm0,YMMWORD PTR [rsp+0xa12]
  228cb1:	00 00 
  228cb3:	c5 fc 10 8c 24 20 0a 	vmovups ymm1,YMMWORD PTR [rsp+0xa20]
  228cba:	00 00 
  228cbc:	e9 86 fc ff ff       	jmp    228947 <getLineNumberInfo+0x147>
            try self.readNoEof(bytes[0..]);
  228cc1:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  228cc6:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  228ccb:	48 c7 44 24 10 04 00 	mov    QWORD PTR [rsp+0x10],0x4
  228cd2:	00 00 
  228cd4:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  228cd9:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
            return self.readFn(self, buffer);
  228cde:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  228ce3:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  228ce7:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  228cec:	66 85 c0             	test   ax,ax
  228cef:	75 10                	jne    228d01 <getLineNumberInfo+0x501>
  228cf1:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  228cf6:	66 b8 25 00          	mov    ax,0x25
            if (amt_read < buf.len) return error.EndOfStream;
  228cfa:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  228cff:	73 44                	jae    228d45 <getLineNumberInfo+0x545>
  228d01:	66 89 45 00          	mov    WORD PTR [rbp+0x0],ax
  228d05:	c5 fe 6f 84 24 e4 09 	vmovdqu ymm0,YMMWORD PTR [rsp+0x9e4]
  228d0c:	00 00 
  228d0e:	c5 fc 10 8c 24 f2 09 	vmovups ymm1,YMMWORD PTR [rsp+0x9f2]
  228d15:	00 00 
  228d17:	e9 2b fc ff ff       	jmp    228947 <getLineNumberInfo+0x147>
        if (version != 2 and version != 4) return error.InvalidDebugInfo;
  228d1c:	c5 fc 10 05 04 ed fd 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffded04]        # 207a28 <__unnamed_85+0x10>
  228d23:	ff 
  228d24:	c5 fc 11 45 10       	vmovups YMMWORD PTR [rbp+0x10],ymm0
  228d29:	c5 fe 6f 05 e7 ec fd 	vmovdqu ymm0,YMMWORD PTR [rip+0xfffffffffffdece7]        # 207a18 <__unnamed_85>
  228d30:	ff 
  228d31:	c5 fe 7f 45 00       	vmovdqu YMMWORD PTR [rbp+0x0],ymm0
  228d36:	e9 16 fc ff ff       	jmp    228951 <getLineNumberInfo+0x151>
        const prologue_length = if (is_64) try in_stream.readInt(st.elf.endian, u64) else try in_stream.readInt(st.elf.endian, u32);
  228d3b:	4c 8b b4 24 98 01 00 	mov    r14,QWORD PTR [rsp+0x198]
  228d42:	00 
  228d43:	eb 4f                	jmp    228d94 <getLineNumberInfo+0x594>
  228d45:	0f b6 44 24 48       	movzx  eax,BYTE PTR [rsp+0x48]
  228d4a:	0f b6 4c 24 49       	movzx  ecx,BYTE PTR [rsp+0x49]
  228d4f:	f6 c3 01             	test   bl,0x1
  228d52:	74 1b                	je     228d6f <getLineNumberInfo+0x56f>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  228d54:	c1 e1 08             	shl    ecx,0x8
  228d57:	09 c1                	or     ecx,eax
  228d59:	0f b6 54 24 4a       	movzx  edx,BYTE PTR [rsp+0x4a]
  228d5e:	c1 e2 10             	shl    edx,0x10
  228d61:	09 ca                	or     edx,ecx
  228d63:	0f b6 44 24 4b       	movzx  eax,BYTE PTR [rsp+0x4b]
  228d68:	c1 e0 18             	shl    eax,0x18
  228d6b:	09 d0                	or     eax,edx
  228d6d:	eb 19                	jmp    228d88 <getLineNumberInfo+0x588>
                result = (result << 8) | b;
  228d6f:	c1 e0 08             	shl    eax,0x8
  228d72:	09 c8                	or     eax,ecx
  228d74:	c1 e0 08             	shl    eax,0x8
  228d77:	0f b6 4c 24 4a       	movzx  ecx,BYTE PTR [rsp+0x4a]
  228d7c:	09 c1                	or     ecx,eax
  228d7e:	c1 e1 08             	shl    ecx,0x8
  228d81:	0f b6 44 24 4b       	movzx  eax,BYTE PTR [rsp+0x4b]
  228d86:	09 c8                	or     eax,ecx
  228d88:	41 89 c6             	mov    r14d,eax
  228d8b:	48 8b 2c 24          	mov    rbp,QWORD PTR [rsp]
  228d8f:	48 8d 5c 24 40       	lea    rbx,[rsp+0x40]
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  228d94:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
  228d99:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  228d9c:	45 31 c0             	xor    r8d,r8d
  228d9f:	b8 08 00 00 00       	mov    eax,0x8
  228da4:	be 00 00 00 00       	mov    esi,0x0
  228da9:	ba 01 00 00 00       	mov    edx,0x1
  228dae:	0f 05                	syscall 
  228db0:	49 89 c5             	mov    r13,rax
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  228db3:	4c 89 e9             	mov    rcx,r13
  228db6:	48 f7 d9             	neg    rcx
  228db9:	49 81 fd 00 f0 ff ff 	cmp    r13,0xfffffffffffff000
  228dc0:	49 0f 46 c8          	cmovbe rcx,r8
  228dc4:	66 b8 27 00          	mov    ax,0x27
                if (err > 0) {
  228dc8:	48 83 f9 1d          	cmp    rcx,0x1d
  228dcc:	77 6c                	ja     228e3a <getLineNumberInfo+0x63a>
  228dce:	48 8d 15 93 7c fd ff 	lea    rdx,[rip+0xfffffffffffd7c93]        # 200a68 <__unnamed_609+0x728>
  228dd5:	48 63 0c 8a          	movsxd rcx,DWORD PTR [rdx+rcx*4]
  228dd9:	48 01 d1             	add    rcx,rdx
  228ddc:	ff e1                	jmp    rcx
            try self.readNoEof(result[0..]);
  228dde:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  228de3:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  228de8:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  228def:	00 00 
  228df1:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  228df6:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
            return self.readFn(self, buffer);
  228dfb:	48 89 de             	mov    rsi,rbx
  228dfe:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  228e02:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  228e07:	66 85 c0             	test   ax,ax
  228e0a:	75 10                	jne    228e1c <getLineNumberInfo+0x61c>
  228e0c:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  228e11:	66 b8 25 00          	mov    ax,0x25
            if (amt_read < buf.len) return error.EndOfStream;
  228e15:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  228e1a:	73 43                	jae    228e5f <getLineNumberInfo+0x65f>
  228e1c:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
        const minimum_instruction_length = try in_stream.readByte();
  228e20:	66 89 01             	mov    WORD PTR [rcx],ax
  228e23:	c5 fe 6f 84 24 88 09 	vmovdqu ymm0,YMMWORD PTR [rsp+0x988]
  228e2a:	00 00 
  228e2c:	c5 fc 10 8c 24 96 09 	vmovups ymm1,YMMWORD PTR [rsp+0x996]
  228e33:	00 00 
  228e35:	e9 f2 fd ff ff       	jmp    228c2c <getLineNumberInfo+0x42c>
  228e3a:	48 83 f9 4b          	cmp    rcx,0x4b
  228e3e:	74 04                	je     228e44 <getLineNumberInfo+0x644>
  228e40:	66 b8 03 00          	mov    ax,0x3
        const prog_start_offset = (try in_file.getPos()) + prologue_length;
  228e44:	66 89 45 00          	mov    WORD PTR [rbp+0x0],ax
  228e48:	c5 fe 6f 84 24 b6 09 	vmovdqu ymm0,YMMWORD PTR [rsp+0x9b6]
  228e4f:	00 00 
  228e51:	c5 fc 10 8c 24 c4 09 	vmovups ymm1,YMMWORD PTR [rsp+0x9c4]
  228e58:	00 00 
  228e5a:	e9 e8 fa ff ff       	jmp    228947 <getLineNumberInfo+0x147>
            return result[0];
  228e5f:	44 0f b6 7c 24 48    	movzx  r15d,BYTE PTR [rsp+0x48]
  228e65:	4d 85 ff             	test   r15,r15
        if (minimum_instruction_length == 0) return error.InvalidDebugInfo;
  228e68:	0f 84 59 15 00 00    	je     22a3c7 <getLineNumberInfo+0x1bc7>
        if (version >= 4) {
  228e6e:	41 83 fc 04          	cmp    r12d,0x4
  228e72:	72 5e                	jb     228ed2 <getLineNumberInfo+0x6d2>
            try self.readNoEof(result[0..]);
  228e74:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  228e79:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  228e7e:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  228e85:	00 00 
  228e87:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  228e8c:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
            return self.readFn(self, buffer);
  228e91:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  228e96:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  228e9a:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  228e9f:	66 85 c0             	test   ax,ax
  228ea2:	75 10                	jne    228eb4 <getLineNumberInfo+0x6b4>
  228ea4:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  228ea9:	66 b8 25 00          	mov    ax,0x25
            if (amt_read < buf.len) return error.EndOfStream;
  228ead:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  228eb2:	73 1e                	jae    228ed2 <getLineNumberInfo+0x6d2>
  228eb4:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
            _ = try in_stream.readByte();
  228eb8:	66 89 01             	mov    WORD PTR [rcx],ax
  228ebb:	c5 fe 6f 84 24 5a 09 	vmovdqu ymm0,YMMWORD PTR [rsp+0x95a]
  228ec2:	00 00 
  228ec4:	c5 fc 10 8c 24 68 09 	vmovups ymm1,YMMWORD PTR [rsp+0x968]
  228ecb:	00 00 
  228ecd:	e9 5a fd ff ff       	jmp    228c2c <getLineNumberInfo+0x42c>
            try self.readNoEof(result[0..]);
  228ed2:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  228ed7:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  228edc:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  228ee3:	00 00 
  228ee5:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  228eea:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
            return self.readFn(self, buffer);
  228eef:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  228ef4:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  228ef8:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  228efd:	66 85 c0             	test   ax,ax
  228f00:	75 10                	jne    228f12 <getLineNumberInfo+0x712>
  228f02:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  228f07:	66 b8 25 00          	mov    ax,0x25
            if (amt_read < buf.len) return error.EndOfStream;
  228f0b:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  228f10:	73 1e                	jae    228f30 <getLineNumberInfo+0x730>
  228f12:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
        const default_is_stmt = (try in_stream.readByte()) != 0;
  228f16:	66 89 01             	mov    WORD PTR [rcx],ax
  228f19:	c5 fe 6f 84 24 2c 09 	vmovdqu ymm0,YMMWORD PTR [rsp+0x92c]
  228f20:	00 00 
  228f22:	c5 fc 10 8c 24 3a 09 	vmovups ymm1,YMMWORD PTR [rsp+0x93a]
  228f29:	00 00 
  228f2b:	e9 fc fc ff ff       	jmp    228c2c <getLineNumberInfo+0x42c>
            return result[0];
  228f30:	40 8a 6c 24 48       	mov    bpl,BYTE PTR [rsp+0x48]
            try self.readNoEof(result[0..]);
  228f35:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  228f3a:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  228f3f:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  228f46:	00 00 
  228f48:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  228f4d:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
            return self.readFn(self, buffer);
  228f52:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  228f57:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  228f5b:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  228f60:	66 85 c0             	test   ax,ax
  228f63:	75 10                	jne    228f75 <getLineNumberInfo+0x775>
  228f65:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  228f6a:	66 b8 25 00          	mov    ax,0x25
            if (amt_read < buf.len) return error.EndOfStream;
  228f6e:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  228f73:	73 1e                	jae    228f93 <getLineNumberInfo+0x793>
  228f75:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
        const line_base = try in_stream.readByteSigned();
  228f79:	66 89 01             	mov    WORD PTR [rcx],ax
  228f7c:	c5 fe 6f 84 24 fe 08 	vmovdqu ymm0,YMMWORD PTR [rsp+0x8fe]
  228f83:	00 00 
  228f85:	c5 fc 10 8c 24 0c 09 	vmovups ymm1,YMMWORD PTR [rsp+0x90c]
  228f8c:	00 00 
  228f8e:	e9 99 fc ff ff       	jmp    228c2c <getLineNumberInfo+0x42c>
            return result[0];
  228f93:	48 0f be 44 24 48    	movsx  rax,BYTE PTR [rsp+0x48]
            try self.readNoEof(result[0..]);
  228f99:	48 89 84 24 68 01 00 	mov    QWORD PTR [rsp+0x168],rax
  228fa0:	00 
  228fa1:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  228fa6:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  228fab:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  228fb2:	00 00 
  228fb4:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  228fb9:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
            return self.readFn(self, buffer);
  228fbe:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  228fc3:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  228fc7:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  228fcc:	66 85 c0             	test   ax,ax
  228fcf:	75 10                	jne    228fe1 <getLineNumberInfo+0x7e1>
  228fd1:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  228fd6:	66 b8 25 00          	mov    ax,0x25
            if (amt_read < buf.len) return error.EndOfStream;
  228fda:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  228fdf:	73 1e                	jae    228fff <getLineNumberInfo+0x7ff>
  228fe1:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
        const line_range = try in_stream.readByte();
  228fe5:	66 89 01             	mov    WORD PTR [rcx],ax
  228fe8:	c5 fe 6f 84 24 d0 08 	vmovdqu ymm0,YMMWORD PTR [rsp+0x8d0]
  228fef:	00 00 
  228ff1:	c5 fc 10 8c 24 de 08 	vmovups ymm1,YMMWORD PTR [rsp+0x8de]
  228ff8:	00 00 
  228ffa:	e9 2d fc ff ff       	jmp    228c2c <getLineNumberInfo+0x42c>
            return result[0];
  228fff:	8a 44 24 48          	mov    al,BYTE PTR [rsp+0x48]
  229003:	88 44 24 5f          	mov    BYTE PTR [rsp+0x5f],al
        if (line_range == 0) return error.InvalidDebugInfo;
  229007:	84 c0                	test   al,al
  229009:	0f 84 b8 13 00 00    	je     22a3c7 <getLineNumberInfo+0x1bc7>
            try self.readNoEof(result[0..]);
  22900f:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  229014:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  229019:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  229020:	00 00 
  229022:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  229027:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
            return self.readFn(self, buffer);
  22902c:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  229031:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  229035:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  22903a:	66 85 c0             	test   ax,ax
  22903d:	75 10                	jne    22904f <getLineNumberInfo+0x84f>
  22903f:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  229044:	66 b8 25 00          	mov    ax,0x25
            if (amt_read < buf.len) return error.EndOfStream;
  229048:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  22904d:	73 1e                	jae    22906d <getLineNumberInfo+0x86d>
  22904f:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
        const opcode_base = try in_stream.readByte();
  229053:	66 89 01             	mov    WORD PTR [rcx],ax
  229056:	c5 fe 6f 84 24 a2 08 	vmovdqu ymm0,YMMWORD PTR [rsp+0x8a2]
  22905d:	00 00 
  22905f:	c5 fc 10 8c 24 b0 08 	vmovups ymm1,YMMWORD PTR [rsp+0x8b0]
  229066:	00 00 
  229068:	e9 bf fb ff ff       	jmp    228c2c <getLineNumberInfo+0x42c>
            return result[0];
  22906d:	8a 4c 24 48          	mov    cl,BYTE PTR [rsp+0x48]
  229071:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
  229076:	48 8b 80 a0 00 00 00 	mov    rax,QWORD PTR [rax+0xa0]
  22907d:	48 89 44 24 68       	mov    QWORD PTR [rsp+0x68],rax
  229082:	88 4c 24 5e          	mov    BYTE PTR [rsp+0x5e],cl
        const standard_opcode_lengths = try st.allocator().alloc(u8, opcode_base - 1);
  229086:	89 c8                	mov    eax,ecx
  229088:	04 ff                	add    al,0xff
        if (n == 0) {
  22908a:	74 48                	je     2290d4 <getLineNumberInfo+0x8d4>
  22908c:	0f b6 d0             	movzx  edx,al
  22908f:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  229094:	b9 01 00 00 00       	mov    ecx,0x1
  229099:	48 8b 74 24 68       	mov    rsi,QWORD PTR [rsp+0x68]
  22909e:	48 89 94 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rdx
  2290a5:	00 
  2290a6:	ff 16                	call   QWORD PTR [rsi]
  2290a8:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  2290ad:	66 85 c0             	test   ax,ax
  2290b0:	0f 84 91 00 00 00    	je     229147 <getLineNumberInfo+0x947>
  2290b6:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
  2290ba:	66 89 01             	mov    WORD PTR [rcx],ax
  2290bd:	c5 fe 6f 84 24 74 08 	vmovdqu ymm0,YMMWORD PTR [rsp+0x874]
  2290c4:	00 00 
  2290c6:	c5 fc 10 8c 24 82 08 	vmovups ymm1,YMMWORD PTR [rsp+0x882]
  2290cd:	00 00 
  2290cf:	e9 58 fb ff ff       	jmp    228c2c <getLineNumberInfo+0x42c>
  2290d4:	31 c0                	xor    eax,eax
  2290d6:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  2290dd:	00 
            return Self{
  2290de:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  2290e2:	c5 f9 7f 84 24 b0 00 	vmovdqa XMMWORD PTR [rsp+0xb0],xmm0
  2290e9:	00 00 
  2290eb:	48 c7 84 24 c0 00 00 	mov    QWORD PTR [rsp+0xc0],0x0
  2290f2:	00 00 00 00 00 
  2290f7:	48 8b 74 24 68       	mov    rsi,QWORD PTR [rsp+0x68]
        var include_directories = ArrayList([]u8).init(st.allocator());
  2290fc:	48 89 b4 24 c8 00 00 	mov    QWORD PTR [rsp+0xc8],rsi
  229103:	00 
  229104:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  229109:	48 8d 94 24 b0 00 00 	lea    rdx,[rsp+0xb0]
  229110:	00 
            self.items = try self.allocator.alignedRealloc(T, A, self.items, better_capacity);
  229111:	b9 08 00 00 00       	mov    ecx,0x8
  229116:	e8 15 1f 00 00       	call   22b030 <Allocator_alignedRealloc.193>
  22911b:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  229120:	66 85 c0             	test   ax,ax
  229123:	0f 84 bd 00 00 00    	je     2291e6 <getLineNumberInfo+0x9e6>
  229129:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
        try include_directories.append(compile_unit_cwd);
  22912d:	66 89 01             	mov    WORD PTR [rcx],ax
  229130:	c5 fe 6f 84 24 18 08 	vmovdqu ymm0,YMMWORD PTR [rsp+0x818]
  229137:	00 00 
  229139:	c5 fc 10 8c 24 26 08 	vmovups ymm1,YMMWORD PTR [rsp+0x826]
  229140:	00 00 
  229142:	e9 e5 fa ff ff       	jmp    228c2c <getLineNumberInfo+0x42c>
        assert(byte_slice.len == byte_count);
  229147:	48 8b 84 24 98 00 00 	mov    rax,QWORD PTR [rsp+0x98]
  22914e:	00 
  22914f:	48 39 44 24 30       	cmp    QWORD PTR [rsp+0x30],rax
    if (!ok) {
  229154:	0f 85 65 16 00 00    	jne    22a7bf <getLineNumberInfo+0x1fbf>
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  22915a:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
  22915f:	48 89 84 24 d8 00 00 	mov    QWORD PTR [rsp+0xd8],rax
  229166:	00 
  229167:	45 31 e4             	xor    r12d,r12d
  22916a:	48 8d 5c 24 20       	lea    rbx,[rsp+0x20]
            try self.readNoEof(result[0..]);
  22916f:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  229174:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  229179:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  229180:	00 00 
            return self.readFn(self, buffer);
  229182:	48 89 df             	mov    rdi,rbx
  229185:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  22918a:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
  22918f:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  229193:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  229198:	66 85 c0             	test   ax,ax
  22919b:	0f 85 cf 00 00 00    	jne    229270 <getLineNumberInfo+0xa70>
  2291a1:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
            if (amt_read < buf.len) return error.EndOfStream;
  2291a6:	48 3b 44 24 10       	cmp    rax,QWORD PTR [rsp+0x10]
  2291ab:	0f 82 bb 00 00 00    	jb     22926c <getLineNumberInfo+0xa6c>
            return result[0];
  2291b1:	0f b6 44 24 48       	movzx  eax,BYTE PTR [rsp+0x48]
                standard_opcode_lengths[i] = try in_stream.readByte();
  2291b6:	48 8b 8c 24 d8 00 00 	mov    rcx,QWORD PTR [rsp+0xd8]
  2291bd:	00 
  2291be:	42 88 04 21          	mov    BYTE PTR [rcx+r12*1],al
            while (i < opcode_base - 1) : (i += 1) {
  2291c2:	49 83 c4 01          	add    r12,0x1
  2291c6:	4c 3b a4 24 98 00 00 	cmp    r12,QWORD PTR [rsp+0x98]
  2291cd:	00 
  2291ce:	72 9f                	jb     22916f <getLineNumberInfo+0x96f>
  2291d0:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
  2291d5:	48 8b 80 a0 00 00 00 	mov    rax,QWORD PTR [rax+0xa0]
  2291dc:	48 89 44 24 68       	mov    QWORD PTR [rsp+0x68],rax
  2291e1:	e9 f8 fe ff ff       	jmp    2290de <getLineNumberInfo+0x8de>
  2291e6:	c5 f8 10 44 24 28    	vmovups xmm0,XMMWORD PTR [rsp+0x28]
  2291ec:	c5 f8 29 84 24 b0 00 	vmovaps XMMWORD PTR [rsp+0xb0],xmm0
  2291f3:	00 00 
            const result = &self.items[self.len];
  2291f5:	4c 8b a4 24 b0 00 00 	mov    r12,QWORD PTR [rsp+0xb0]
  2291fc:	00 
            self.len = new_length;
  2291fd:	48 c7 84 24 c0 00 00 	mov    QWORD PTR [rsp+0xc0],0x1
  229204:	00 01 00 00 00 
            new_item_ptr.* = item;
  229209:	c5 f9 6f 84 24 e0 01 	vmovdqa xmm0,XMMWORD PTR [rsp+0x1e0]
  229210:	00 00 
  229212:	c4 c1 7a 7f 04 24    	vmovdqu XMMWORD PTR [r12],xmm0
  229218:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
            var in_file_stream = io.FileInStream.init(&self.self_exe_file);
  22921d:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  229222:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  229227:	48 8d 0d a2 ba ff ff 	lea    rcx,[rip+0xffffffffffffbaa2]        # 224cd0 <FileInStream_readFn>
  22922e:	48 89 4c 24 10       	mov    QWORD PTR [rsp+0x10],rcx
  229233:	48 8b b0 a0 00 00 00 	mov    rsi,QWORD PTR [rax+0xa0]
  22923a:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
            return readStringRaw(self.allocator(), in_stream);
  22923f:	e8 5c f1 ff ff       	call   2283a0 <readStringRaw>
  229244:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const dir = try st.readString();
  229249:	66 85 c0             	test   ax,ax
  22924c:	74 40                	je     22928e <getLineNumberInfo+0xa8e>
  22924e:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
  229252:	66 89 01             	mov    WORD PTR [rcx],ax
  229255:	c5 fe 6f 84 24 ea 07 	vmovdqu ymm0,YMMWORD PTR [rsp+0x7ea]
  22925c:	00 00 
  22925e:	c5 fc 10 8c 24 f8 07 	vmovups ymm1,YMMWORD PTR [rsp+0x7f8]
  229265:	00 00 
  229267:	e9 c0 f9 ff ff       	jmp    228c2c <getLineNumberInfo+0x42c>
  22926c:	66 b8 25 00          	mov    ax,0x25
  229270:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                standard_opcode_lengths[i] = try in_stream.readByte();
  229274:	66 89 01             	mov    WORD PTR [rcx],ax
  229277:	c5 fe 6f 84 24 46 08 	vmovdqu ymm0,YMMWORD PTR [rsp+0x846]
  22927e:	00 00 
  229280:	c5 fc 10 8c 24 54 08 	vmovups ymm1,YMMWORD PTR [rsp+0x854]
  229287:	00 00 
  229289:	e9 9e f9 ff ff       	jmp    228c2c <getLineNumberInfo+0x42c>
  22928e:	4d 01 f5             	add    r13,r14
  229291:	c5 fa 6f 44 24 28    	vmovdqu xmm0,XMMWORD PTR [rsp+0x28]
  229297:	c5 f9 7f 84 24 50 01 	vmovdqa XMMWORD PTR [rsp+0x150],xmm0
  22929e:	00 00 
  2292a0:	41 be 01 00 00 00    	mov    r14d,0x1
            if (dir.len == 0) break;
  2292a6:	c5 f9 6f 84 24 50 01 	vmovdqa xmm0,XMMWORD PTR [rsp+0x150]
  2292ad:	00 00 
  2292af:	c4 e3 f9 16 c0 01    	vpextrq rax,xmm0,0x1
  2292b5:	48 85 c0             	test   rax,rax
  2292b8:	0f 84 ce 00 00 00    	je     22938c <getLineNumberInfo+0xb8c>
            var better_capacity = self.items.len;
  2292be:	48 8b 8c 24 b8 00 00 	mov    rcx,QWORD PTR [rsp+0xb8]
  2292c5:	00 
            if (better_capacity >= new_capacity) return;
  2292c6:	4c 39 f1             	cmp    rcx,r14
  2292c9:	77 51                	ja     22931c <getLineNumberInfo+0xb1c>
                better_capacity += better_capacity / 2 + 8;
  2292cb:	48 89 c8             	mov    rax,rcx
  2292ce:	48 d1 e8             	shr    rax,1
  2292d1:	48 01 c1             	add    rcx,rax
  2292d4:	48 83 c1 08          	add    rcx,0x8
                if (better_capacity >= new_capacity) break;
  2292d8:	4c 39 f1             	cmp    rcx,r14
  2292db:	76 ee                	jbe    2292cb <getLineNumberInfo+0xacb>
            self.items = try self.allocator.alignedRealloc(T, A, self.items, better_capacity);
  2292dd:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  2292e2:	48 8b 74 24 68       	mov    rsi,QWORD PTR [rsp+0x68]
  2292e7:	48 8d 94 24 b0 00 00 	lea    rdx,[rsp+0xb0]
  2292ee:	00 
  2292ef:	e8 3c 1d 00 00       	call   22b030 <Allocator_alignedRealloc.193>
  2292f4:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  2292f9:	66 85 c0             	test   ax,ax
  2292fc:	0f 85 94 01 00 00    	jne    229496 <getLineNumberInfo+0xc96>
  229302:	48 8d 44 24 28       	lea    rax,[rsp+0x28]
  229307:	c5 fa 6f 00          	vmovdqu xmm0,XMMWORD PTR [rax]
  22930b:	c5 f9 7f 84 24 b0 00 	vmovdqa XMMWORD PTR [rsp+0xb0],xmm0
  229312:	00 00 
            const result = &self.items[self.len];
  229314:	4c 8b a4 24 b0 00 00 	mov    r12,QWORD PTR [rsp+0xb0]
  22931b:	00 
  22931c:	49 8d 5e 01          	lea    rbx,[r14+0x1]
  229320:	49 c1 e6 04          	shl    r14,0x4
            self.len = new_length;
  229324:	48 89 9c 24 c0 00 00 	mov    QWORD PTR [rsp+0xc0],rbx
  22932b:	00 
            new_item_ptr.* = item;
  22932c:	c5 f8 28 84 24 50 01 	vmovaps xmm0,XMMWORD PTR [rsp+0x150]
  229333:	00 00 
  229335:	c4 81 78 11 04 34    	vmovups XMMWORD PTR [r12+r14*1],xmm0
  22933b:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
            var in_file_stream = io.FileInStream.init(&self.self_exe_file);
  229340:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  229345:	48 8d 0d 84 b9 ff ff 	lea    rcx,[rip+0xffffffffffffb984]        # 224cd0 <FileInStream_readFn>
  22934c:	48 89 4c 24 10       	mov    QWORD PTR [rsp+0x10],rcx
  229351:	48 8b b0 a0 00 00 00 	mov    rsi,QWORD PTR [rax+0xa0]
            return readStringRaw(self.allocator(), in_stream);
  229358:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  22935d:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  229362:	e8 39 f0 ff ff       	call   2283a0 <readStringRaw>
  229367:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  22936c:	c5 fa 6f 44 24 28    	vmovdqu xmm0,XMMWORD PTR [rsp+0x28]
  229372:	c5 f9 7f 84 24 50 01 	vmovdqa XMMWORD PTR [rsp+0x150],xmm0
  229379:	00 00 
  22937b:	49 89 de             	mov    r14,rbx
            const dir = try st.readString();
  22937e:	66 85 c0             	test   ax,ax
  229381:	0f 84 1f ff ff ff    	je     2292a6 <getLineNumberInfo+0xaa6>
  229387:	e9 c2 fe ff ff       	jmp    22924e <getLineNumberInfo+0xa4e>
  22938c:	48 8b 54 24 60       	mov    rdx,QWORD PTR [rsp+0x60]
  229391:	48 8b b2 a0 00 00 00 	mov    rsi,QWORD PTR [rdx+0xa0]
            return Self{
  229398:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  22939c:	c5 f9 7f 44 24 70    	vmovdqa XMMWORD PTR [rsp+0x70],xmm0
  2293a2:	48 c7 84 24 80 00 00 	mov    QWORD PTR [rsp+0x80],0x0
  2293a9:	00 00 00 00 00 
        var file_entries = ArrayList(FileEntry).init(st.allocator());
  2293ae:	48 89 b4 24 88 00 00 	mov    QWORD PTR [rsp+0x88],rsi
  2293b5:	00 
        var prog = LineNumberProgram.init(default_is_stmt, include_directories.toSliceConst(), &file_entries, target_address);
  2293b6:	c5 fc 28 05 22 6e fd 	vmovaps ymm0,YMMWORD PTR [rip+0xfffffffffffd6e22]        # 2001e0 <__unnamed_44-0x20>
  2293bd:	ff 
  2293be:	c5 fc 11 84 24 e0 00 	vmovups YMMWORD PTR [rsp+0xe0],ymm0
  2293c5:	00 00 
        const default_is_stmt = (try in_stream.readByte()) != 0;
  2293c7:	40 84 ed             	test   bpl,bpl
        var prog = LineNumberProgram.init(default_is_stmt, include_directories.toSliceConst(), &file_entries, target_address);
  2293ca:	0f 95 84 24 00 01 00 	setne  BYTE PTR [rsp+0x100]
  2293d1:	00 
  2293d2:	66 c7 84 24 01 01 00 	mov    WORD PTR [rsp+0x101],0x0
  2293d9:	00 00 00 
  2293dc:	8b 84 24 d3 00 00 00 	mov    eax,DWORD PTR [rsp+0xd3]
  2293e3:	89 84 24 03 01 00 00 	mov    DWORD PTR [rsp+0x103],eax
            return self.items[0..self.len];
  2293ea:	48 8b 84 24 b0 00 00 	mov    rax,QWORD PTR [rsp+0xb0]
  2293f1:	00 
  2293f2:	8a 8c 24 d7 00 00 00 	mov    cl,BYTE PTR [rsp+0xd7]
  2293f9:	88 8c 24 07 01 00 00 	mov    BYTE PTR [rsp+0x107],cl
  229400:	48 8b 8c 24 a0 00 00 	mov    rcx,QWORD PTR [rsp+0xa0]
  229407:	00 
  229408:	48 89 8c 24 08 01 00 	mov    QWORD PTR [rsp+0x108],rcx
  22940f:	00 
  229410:	48 89 84 24 10 01 00 	mov    QWORD PTR [rsp+0x110],rax
  229417:	00 
  229418:	4c 89 b4 24 18 01 00 	mov    QWORD PTR [rsp+0x118],r14
  22941f:	00 
  229420:	48 8d 44 24 70       	lea    rax,[rsp+0x70]
  229425:	48 89 84 24 20 01 00 	mov    QWORD PTR [rsp+0x120],rax
  22942c:	00 
  22942d:	48 c7 84 24 28 01 00 	mov    QWORD PTR [rsp+0x128],0x0
  229434:	00 00 00 00 00 
  229439:	c5 fe 6f 84 24 f8 0a 	vmovdqu ymm0,YMMWORD PTR [rsp+0xaf8]
  229440:	00 00 
  229442:	c5 fe 7f 84 24 30 01 	vmovdqu YMMWORD PTR [rsp+0x130],ymm0
  229449:	00 00 
            var in_file_stream = io.FileInStream.init(&self.self_exe_file);
  22944b:	48 89 54 24 08       	mov    QWORD PTR [rsp+0x8],rdx
  229450:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  229455:	48 8d 05 74 b8 ff ff 	lea    rax,[rip+0xffffffffffffb874]        # 224cd0 <FileInStream_readFn>
  22945c:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  229461:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
            return readStringRaw(self.allocator(), in_stream);
  229466:	c5 f8 77             	vzeroupper 
  229469:	e8 32 ef ff ff       	call   2283a0 <readStringRaw>
  22946e:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const file_name = try st.readString();
  229473:	66 85 c0             	test   ax,ax
  229476:	74 3c                	je     2294b4 <getLineNumberInfo+0xcb4>
  229478:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
  22947c:	66 89 01             	mov    WORD PTR [rcx],ax
  22947f:	c5 fe 6f 84 24 8e 07 	vmovdqu ymm0,YMMWORD PTR [rsp+0x78e]
  229486:	00 00 
  229488:	c5 fc 10 8c 24 9c 07 	vmovups ymm1,YMMWORD PTR [rsp+0x79c]
  22948f:	00 00 
  229491:	e9 96 f7 ff ff       	jmp    228c2c <getLineNumberInfo+0x42c>
  229496:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
            try include_directories.append(dir);
  22949a:	66 89 01             	mov    WORD PTR [rcx],ax
  22949d:	c5 fc 10 84 24 bc 07 	vmovups ymm0,YMMWORD PTR [rsp+0x7bc]
  2294a4:	00 00 
  2294a6:	c5 fc 10 8c 24 ca 07 	vmovups ymm1,YMMWORD PTR [rsp+0x7ca]
  2294ad:	00 00 
  2294af:	e9 78 f7 ff ff       	jmp    228c2c <getLineNumberInfo+0x42c>
  2294b4:	c5 fa 6f 44 24 28    	vmovdqu xmm0,XMMWORD PTR [rsp+0x28]
  2294ba:	c5 f9 7f 84 24 a0 00 	vmovdqa XMMWORD PTR [rsp+0xa0],xmm0
  2294c1:	00 00 
            if (file_name.len == 0) break;
  2294c3:	c5 f9 6f 84 24 a0 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0xa0]
  2294ca:	00 00 
  2294cc:	c4 e3 f9 16 c0 01    	vpextrq rax,xmm0,0x1
  2294d2:	48 85 c0             	test   rax,rax
  2294d5:	0f 84 44 03 00 00    	je     22981f <getLineNumberInfo+0x101f>
            try self.readNoEof(result[0..]);
  2294db:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  2294e0:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  2294e5:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  2294ec:	00 00 
            return self.readFn(self, buffer);
  2294ee:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  2294f3:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  2294f8:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
  2294fd:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  229501:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  229506:	66 85 c0             	test   ax,ax
  229509:	0f 85 ca 02 00 00    	jne    2297d9 <getLineNumberInfo+0xfd9>
  22950f:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  229514:	45 31 e4             	xor    r12d,r12d
  229517:	31 ed                	xor    ebp,ebp
            if (amt_read < buf.len) return error.EndOfStream;
  229519:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  22951e:	0f 82 ab 02 00 00    	jb     2297cf <getLineNumberInfo+0xfcf>
            return result[0];
  229524:	0f b6 44 24 48       	movzx  eax,BYTE PTR [rsp+0x48]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  229529:	89 c2                	mov    edx,eax
  22952b:	83 e2 7f             	and    edx,0x7f
  22952e:	89 ee                	mov    esi,ebp
  229530:	83 e6 3f             	and    esi,0x3f
  229533:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  229538:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  22953d:	48 39 d6             	cmp    rsi,rdx
  229540:	0f 85 8f 02 00 00    	jne    2297d5 <getLineNumberInfo+0xfd5>
        result |= operand;
  229546:	49 09 cc             	or     r12,rcx
        if ((byte & 0b10000000) == 0) return result;
  229549:	84 c0                	test   al,al
  22954b:	79 3e                	jns    22958b <getLineNumberInfo+0xd8b>
        shift += 7;
  22954d:	48 83 c5 07          	add    rbp,0x7
            try self.readNoEof(result[0..]);
  229551:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  229556:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  22955b:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  229562:	00 00 
            return self.readFn(self, buffer);
  229564:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  229569:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  22956e:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
  229573:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  229577:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  22957c:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  229581:	66 85 c0             	test   ax,ax
  229584:	74 93                	je     229519 <getLineNumberInfo+0xd19>
  229586:	e9 4e 02 00 00       	jmp    2297d9 <getLineNumberInfo+0xfd9>
            try self.readNoEof(result[0..]);
  22958b:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  229590:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  229595:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  22959c:	00 00 
            return self.readFn(self, buffer);
  22959e:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  2295a3:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  2295a8:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
  2295ad:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  2295b1:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  2295b6:	66 85 c0             	test   ax,ax
  2295b9:	0f 85 42 02 00 00    	jne    229801 <getLineNumberInfo+0x1001>
  2295bf:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  2295c4:	45 31 f6             	xor    r14d,r14d
  2295c7:	31 ed                	xor    ebp,ebp
            if (amt_read < buf.len) return error.EndOfStream;
  2295c9:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  2295ce:	0f 82 23 02 00 00    	jb     2297f7 <getLineNumberInfo+0xff7>
            return result[0];
  2295d4:	0f b6 44 24 48       	movzx  eax,BYTE PTR [rsp+0x48]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  2295d9:	89 c2                	mov    edx,eax
  2295db:	83 e2 7f             	and    edx,0x7f
  2295de:	89 ee                	mov    esi,ebp
  2295e0:	83 e6 3f             	and    esi,0x3f
  2295e3:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  2295e8:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  2295ed:	48 39 d6             	cmp    rsi,rdx
  2295f0:	0f 85 07 02 00 00    	jne    2297fd <getLineNumberInfo+0xffd>
        result |= operand;
  2295f6:	49 09 ce             	or     r14,rcx
        if ((byte & 0b10000000) == 0) return result;
  2295f9:	84 c0                	test   al,al
  2295fb:	79 3e                	jns    22963b <getLineNumberInfo+0xe3b>
        shift += 7;
  2295fd:	48 83 c5 07          	add    rbp,0x7
            try self.readNoEof(result[0..]);
  229601:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  229606:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  22960b:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  229612:	00 00 
            return self.readFn(self, buffer);
  229614:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  229619:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  22961e:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
  229623:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  229627:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  22962c:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  229631:	66 85 c0             	test   ax,ax
  229634:	74 93                	je     2295c9 <getLineNumberInfo+0xdc9>
  229636:	e9 c6 01 00 00       	jmp    229801 <getLineNumberInfo+0x1001>
            try self.readNoEof(result[0..]);
  22963b:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  229640:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  229645:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  22964c:	00 00 
            return self.readFn(self, buffer);
  22964e:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  229653:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  229658:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
  22965d:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  229661:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  229666:	66 85 c0             	test   ax,ax
  229669:	0f 85 05 02 00 00    	jne    229874 <getLineNumberInfo+0x1074>
  22966f:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  229674:	31 db                	xor    ebx,ebx
  229676:	31 ed                	xor    ebp,ebp
            if (amt_read < buf.len) return error.EndOfStream;
  229678:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  22967d:	0f 82 e7 01 00 00    	jb     22986a <getLineNumberInfo+0x106a>
            return result[0];
  229683:	0f b6 44 24 48       	movzx  eax,BYTE PTR [rsp+0x48]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  229688:	89 c2                	mov    edx,eax
  22968a:	83 e2 7f             	and    edx,0x7f
  22968d:	89 ee                	mov    esi,ebp
  22968f:	83 e6 3f             	and    esi,0x3f
  229692:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  229697:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  22969c:	48 39 d6             	cmp    rsi,rdx
  22969f:	0f 85 cb 01 00 00    	jne    229870 <getLineNumberInfo+0x1070>
        result |= operand;
  2296a5:	48 09 cb             	or     rbx,rcx
        if ((byte & 0b10000000) == 0) return result;
  2296a8:	84 c0                	test   al,al
  2296aa:	79 3e                	jns    2296ea <getLineNumberInfo+0xeea>
        shift += 7;
  2296ac:	48 83 c5 07          	add    rbp,0x7
            try self.readNoEof(result[0..]);
  2296b0:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  2296b5:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  2296ba:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  2296c1:	00 00 
            return self.readFn(self, buffer);
  2296c3:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  2296c8:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  2296cd:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
  2296d2:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  2296d6:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  2296db:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  2296e0:	66 85 c0             	test   ax,ax
  2296e3:	74 93                	je     229678 <getLineNumberInfo+0xe78>
  2296e5:	e9 8a 01 00 00       	jmp    229874 <getLineNumberInfo+0x1074>
            const new_length = self.len + 1;
  2296ea:	48 8b ac 24 80 00 00 	mov    rbp,QWORD PTR [rsp+0x80]
  2296f1:	00 
            var better_capacity = self.items.len;
  2296f2:	48 8b 4c 24 78       	mov    rcx,QWORD PTR [rsp+0x78]
            if (better_capacity >= new_capacity) return;
  2296f7:	48 39 e9             	cmp    rcx,rbp
  2296fa:	76 05                	jbe    229701 <getLineNumberInfo+0xf01>
            const result = &self.items[self.len];
  2296fc:	48 89 e8             	mov    rax,rbp
  2296ff:	eb 4e                	jmp    22974f <getLineNumberInfo+0xf4f>
                better_capacity += better_capacity / 2 + 8;
  229701:	48 89 c8             	mov    rax,rcx
  229704:	48 d1 e8             	shr    rax,1
  229707:	48 01 c1             	add    rcx,rax
  22970a:	48 83 c1 08          	add    rcx,0x8
                if (better_capacity >= new_capacity) break;
  22970e:	48 39 e9             	cmp    rcx,rbp
  229711:	76 ee                	jbe    229701 <getLineNumberInfo+0xf01>
            self.items = try self.allocator.alignedRealloc(T, A, self.items, better_capacity);
  229713:	48 8b b4 24 88 00 00 	mov    rsi,QWORD PTR [rsp+0x88]
  22971a:	00 
  22971b:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  229720:	48 8d 54 24 70       	lea    rdx,[rsp+0x70]
  229725:	e8 76 1b 00 00       	call   22b2a0 <Allocator_alignedRealloc.196>
  22972a:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  22972f:	66 85 c0             	test   ax,ax
  229732:	0f 85 d5 0c 00 00    	jne    22a40d <getLineNumberInfo+0x1c0d>
  229738:	48 8d 44 24 28       	lea    rax,[rsp+0x28]
  22973d:	c5 fa 6f 00          	vmovdqu xmm0,XMMWORD PTR [rax]
  229741:	c5 f9 7f 44 24 70    	vmovdqa XMMWORD PTR [rsp+0x70],xmm0
            const result = &self.items[self.len];
  229747:	48 8b 84 24 80 00 00 	mov    rax,QWORD PTR [rsp+0x80]
  22974e:	00 
  22974f:	48 83 c5 01          	add    rbp,0x1
  229753:	48 8b 4c 24 70       	mov    rcx,QWORD PTR [rsp+0x70]
  229758:	48 8d 04 80          	lea    rax,[rax+rax*4]
            self.len = new_length;
  22975c:	48 89 ac 24 80 00 00 	mov    QWORD PTR [rsp+0x80],rbp
  229763:	00 
            new_item_ptr.* = item;
  229764:	c5 f8 28 84 24 a0 00 	vmovaps xmm0,XMMWORD PTR [rsp+0xa0]
  22976b:	00 00 
  22976d:	c5 f8 11 04 c1       	vmovups XMMWORD PTR [rcx+rax*8],xmm0
  229772:	4c 89 64 c1 10       	mov    QWORD PTR [rcx+rax*8+0x10],r12
  229777:	4c 89 74 c1 18       	mov    QWORD PTR [rcx+rax*8+0x18],r14
  22977c:	48 89 5c c1 20       	mov    QWORD PTR [rcx+rax*8+0x20],rbx
  229781:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
            var in_file_stream = io.FileInStream.init(&self.self_exe_file);
  229786:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  22978b:	48 8d 0d 3e b5 ff ff 	lea    rcx,[rip+0xffffffffffffb53e]        # 224cd0 <FileInStream_readFn>
  229792:	48 89 4c 24 10       	mov    QWORD PTR [rsp+0x10],rcx
  229797:	48 8b b0 a0 00 00 00 	mov    rsi,QWORD PTR [rax+0xa0]
            return readStringRaw(self.allocator(), in_stream);
  22979e:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  2297a3:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  2297a8:	e8 f3 eb ff ff       	call   2283a0 <readStringRaw>
  2297ad:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  2297b2:	c5 fa 6f 44 24 28    	vmovdqu xmm0,XMMWORD PTR [rsp+0x28]
            const file_name = try st.readString();
  2297b8:	c5 f9 7f 84 24 a0 00 	vmovdqa XMMWORD PTR [rsp+0xa0],xmm0
  2297bf:	00 00 
  2297c1:	66 85 c0             	test   ax,ax
  2297c4:	0f 84 f9 fc ff ff    	je     2294c3 <getLineNumberInfo+0xcc3>
  2297ca:	e9 a9 fc ff ff       	jmp    229478 <getLineNumberInfo+0xc78>
  2297cf:	66 b8 25 00          	mov    ax,0x25
  2297d3:	eb 04                	jmp    2297d9 <getLineNumberInfo+0xfd9>
  2297d5:	66 b8 29 00          	mov    ax,0x29
  2297d9:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
            const dir_index = try readULeb128(in_stream);
  2297dd:	66 89 01             	mov    WORD PTR [rcx],ax
  2297e0:	c5 fe 6f 84 24 60 07 	vmovdqu ymm0,YMMWORD PTR [rsp+0x760]
  2297e7:	00 00 
  2297e9:	c5 fc 10 8c 24 6e 07 	vmovups ymm1,YMMWORD PTR [rsp+0x76e]
  2297f0:	00 00 
  2297f2:	e9 35 f4 ff ff       	jmp    228c2c <getLineNumberInfo+0x42c>
  2297f7:	66 b8 25 00          	mov    ax,0x25
  2297fb:	eb 04                	jmp    229801 <getLineNumberInfo+0x1001>
  2297fd:	66 b8 29 00          	mov    ax,0x29
  229801:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
            const mtime = try readULeb128(in_stream);
  229805:	66 89 01             	mov    WORD PTR [rcx],ax
  229808:	c5 fe 6f 84 24 32 07 	vmovdqu ymm0,YMMWORD PTR [rsp+0x732]
  22980f:	00 00 
  229811:	c5 fc 10 8c 24 40 07 	vmovups ymm1,YMMWORD PTR [rsp+0x740]
  229818:	00 00 
  22981a:	e9 0d f4 ff ff       	jmp    228c2c <getLineNumberInfo+0x42c>
  22981f:	4d 85 ed             	test   r13,r13
  229822:	78 6e                	js     229892 <getLineNumberInfo+0x1092>
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  229824:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
  229829:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  22982c:	31 ed                	xor    ebp,ebp
  22982e:	b8 08 00 00 00       	mov    eax,0x8
  229833:	31 d2                	xor    edx,edx
  229835:	4c 89 ee             	mov    rsi,r13
  229838:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  22983a:	48 89 c1             	mov    rcx,rax
  22983d:	48 f7 d9             	neg    rcx
  229840:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  229846:	48 0f 46 cd          	cmovbe rcx,rbp
  22984a:	66 b8 03 00          	mov    ax,0x3
                if (err > 0) {
  22984e:	48 83 f9 1d          	cmp    rcx,0x1d
  229852:	77 60                	ja     2298b4 <getLineNumberInfo+0x10b4>
  229854:	48 8d 15 85 72 fd ff 	lea    rdx,[rip+0xfffffffffffd7285]        # 200ae0 <__unnamed_609+0x7a0>
  22985b:	48 63 0c 8a          	movsxd rcx,DWORD PTR [rdx+rcx*4]
  22985f:	48 01 d1             	add    rcx,rdx
  229862:	ff e1                	jmp    rcx
  229864:	66 b8 27 00          	mov    ax,0x27
  229868:	eb 2c                	jmp    229896 <getLineNumberInfo+0x1096>
  22986a:	66 b8 25 00          	mov    ax,0x25
  22986e:	eb 04                	jmp    229874 <getLineNumberInfo+0x1074>
  229870:	66 b8 29 00          	mov    ax,0x29
  229874:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
            const len_bytes = try readULeb128(in_stream);
  229878:	66 89 01             	mov    WORD PTR [rcx],ax
  22987b:	c5 fe 6f 84 24 04 07 	vmovdqu ymm0,YMMWORD PTR [rsp+0x704]
  229882:	00 00 
  229884:	c5 fc 10 8c 24 12 07 	vmovups ymm1,YMMWORD PTR [rsp+0x712]
  22988b:	00 00 
  22988d:	e9 9a f3 ff ff       	jmp    228c2c <getLineNumberInfo+0x42c>
  229892:	66 b8 04 00          	mov    ax,0x4
  229896:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
        try in_file.seekTo(prog_start_offset);
  22989a:	66 89 01             	mov    WORD PTR [rcx],ax
  22989d:	c5 fe 6f 84 24 a8 06 	vmovdqu ymm0,YMMWORD PTR [rsp+0x6a8]
  2298a4:	00 00 
  2298a6:	c5 fc 10 8c 24 b6 06 	vmovups ymm1,YMMWORD PTR [rsp+0x6b6]
  2298ad:	00 00 
  2298af:	e9 78 f3 ff ff       	jmp    228c2c <getLineNumberInfo+0x42c>
  2298b4:	48 83 f9 4b          	cmp    rcx,0x4b
  2298b8:	75 dc                	jne    229896 <getLineNumberInfo+0x1096>
  2298ba:	eb a8                	jmp    229864 <getLineNumberInfo+0x1064>
            try self.readNoEof(result[0..]);
  2298bc:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  2298c1:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  2298c6:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  2298cd:	00 00 
  2298cf:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  2298d4:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
            return self.readFn(self, buffer);
  2298d9:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  2298de:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  2298e2:	0f b7 4c 24 20       	movzx  ecx,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  2298e7:	66 85 c9             	test   cx,cx
  2298ea:	74 28                	je     229914 <getLineNumberInfo+0x1114>
  2298ec:	48 8b 04 24          	mov    rax,QWORD PTR [rsp]
            const opcode = try in_stream.readByte();
  2298f0:	66 89 08             	mov    WORD PTR [rax],cx
  2298f3:	c5 fe 6f 84 24 7a 06 	vmovdqu ymm0,YMMWORD PTR [rsp+0x67a]
  2298fa:	00 00 
  2298fc:	c5 fc 10 8c 24 88 06 	vmovups ymm1,YMMWORD PTR [rsp+0x688]
  229903:	00 00 
  229905:	c5 fc 11 48 10       	vmovups YMMWORD PTR [rax+0x10],ymm1
  22990a:	c5 fe 7f 40 02       	vmovdqu YMMWORD PTR [rax+0x2],ymm0
  22990f:	e9 3d f0 ff ff       	jmp    228951 <getLineNumberInfo+0x151>
  229914:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
  229919:	8a 4c 24 5e          	mov    cl,BYTE PTR [rsp+0x5e]
  22991d:	f6 d1                	not    cl
  22991f:	88 8c 24 a0 00 00 00 	mov    BYTE PTR [rsp+0xa0],cl
  229926:	4c 8d 64 24 20       	lea    r12,[rsp+0x20]
  22992b:	4c 8d 6c 24 08       	lea    r13,[rsp+0x8]
            if (amt_read < buf.len) return error.EndOfStream;
  229930:	48 3b 44 24 10       	cmp    rax,QWORD PTR [rsp+0x10]
  229935:	0f 82 f0 0a 00 00    	jb     22a42b <getLineNumberInfo+0x1c2b>
            return result[0];
  22993b:	8a 44 24 48          	mov    al,BYTE PTR [rsp+0x48]
            if (opcode == DW.LNS_extended_op) {
  22993f:	84 c0                	test   al,al
  229941:	74 62                	je     2299a5 <getLineNumberInfo+0x11a5>
            } else if (opcode >= opcode_base) {
  229943:	89 c1                	mov    ecx,eax
  229945:	2a 4c 24 5e          	sub    cl,BYTE PTR [rsp+0x5e]
  229949:	0f 83 01 01 00 00    	jae    229a50 <getLineNumberInfo+0x1250>
                switch (opcode) {
  22994f:	04 ff                	add    al,0xff
  229951:	0f b6 c0             	movzx  eax,al
  229954:	3c 09                	cmp    al,0x9
  229956:	0f 87 3b 02 00 00    	ja     229b97 <getLineNumberInfo+0x1397>
  22995c:	48 8d 0d f5 71 fd ff 	lea    rcx,[rip+0xfffffffffffd71f5]        # 200b58 <__unnamed_609+0x818>
  229963:	48 63 04 81          	movsxd rax,DWORD PTR [rcx+rax*4]
  229967:	48 01 c8             	add    rax,rcx
  22996a:	ff e0                	jmp    rax
                        if (try prog.checkLineMatch()) |info| return info;
  22996c:	48 8d bc 24 08 02 00 	lea    rdi,[rsp+0x208]
  229973:	00 
  229974:	48 8d b4 24 e0 00 00 	lea    rsi,[rsp+0xe0]
  22997b:	00 
  22997c:	e8 cf 14 00 00       	call   22ae50 <LineNumberProgram_checkLineMatch>
  229981:	0f b7 84 24 08 02 00 	movzx  eax,WORD PTR [rsp+0x208]
  229988:	00 
  229989:	66 85 c0             	test   ax,ax
  22998c:	0f 85 ac 0c 00 00    	jne    22a63e <getLineNumberInfo+0x1e3e>
  229992:	80 bc 24 38 02 00 00 	cmp    BYTE PTR [rsp+0x238],0x1
  229999:	01 
  22999a:	0f 85 0c 01 00 00    	jne    229aac <getLineNumberInfo+0x12ac>
  2299a0:	e9 b7 0c 00 00       	jmp    22a65c <getLineNumberInfo+0x1e5c>
            try self.readNoEof(result[0..]);
  2299a5:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  2299aa:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  2299af:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  2299b6:	00 00 
            return self.readFn(self, buffer);
  2299b8:	4c 89 e7             	mov    rdi,r12
  2299bb:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  2299c0:	4c 89 ea             	mov    rdx,r13
  2299c3:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  2299c7:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  2299cc:	66 85 c0             	test   ax,ax
  2299cf:	0f 85 1a 0a 00 00    	jne    22a3ef <getLineNumberInfo+0x1bef>
  2299d5:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  2299da:	31 ed                	xor    ebp,ebp
  2299dc:	31 db                	xor    ebx,ebx
            if (amt_read < buf.len) return error.EndOfStream;
  2299de:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  2299e3:	0f 82 fc 09 00 00    	jb     22a3e5 <getLineNumberInfo+0x1be5>
            return result[0];
  2299e9:	0f b6 44 24 48       	movzx  eax,BYTE PTR [rsp+0x48]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  2299ee:	89 c2                	mov    edx,eax
  2299f0:	83 e2 7f             	and    edx,0x7f
  2299f3:	89 de                	mov    esi,ebx
  2299f5:	83 e6 3f             	and    esi,0x3f
  2299f8:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  2299fd:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  229a02:	48 39 d6             	cmp    rsi,rdx
  229a05:	0f 85 e0 09 00 00    	jne    22a3eb <getLineNumberInfo+0x1beb>
        result |= operand;
  229a0b:	48 09 cd             	or     rbp,rcx
        if ((byte & 0b10000000) == 0) return result;
  229a0e:	84 c0                	test   al,al
  229a10:	0f 89 d8 00 00 00    	jns    229aee <getLineNumberInfo+0x12ee>
        shift += 7;
  229a16:	48 83 c3 07          	add    rbx,0x7
            try self.readNoEof(result[0..]);
  229a1a:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  229a1f:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  229a24:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  229a2b:	00 00 
            return self.readFn(self, buffer);
  229a2d:	4c 89 e7             	mov    rdi,r12
  229a30:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  229a35:	4c 89 ea             	mov    rdx,r13
  229a38:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  229a3c:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  229a41:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  229a46:	66 85 c0             	test   ax,ax
  229a49:	74 93                	je     2299de <getLineNumberInfo+0x11de>
  229a4b:	e9 9f 09 00 00       	jmp    22a3ef <getLineNumberInfo+0x1bef>
                const inc_line = i32(line_base) + i32(adjusted_opcode % line_range);
  229a50:	0f b6 c1             	movzx  eax,cl
  229a53:	f6 74 24 5f          	div    BYTE PTR [rsp+0x5f]
  229a57:	0f b6 cc             	movzx  ecx,ah
  229a5a:	48 03 8c 24 68 01 00 	add    rcx,QWORD PTR [rsp+0x168]
  229a61:	00 
                prog.line += inc_line;
  229a62:	48 01 8c 24 f0 00 00 	add    QWORD PTR [rsp+0xf0],rcx
  229a69:	00 
                const inc_addr = minimum_instruction_length * (adjusted_opcode / line_range);
  229a6a:	41 f6 e7             	mul    r15b
                prog.address += inc_addr;
  229a6d:	0f b6 c0             	movzx  eax,al
  229a70:	48 01 84 24 e0 00 00 	add    QWORD PTR [rsp+0xe0],rax
  229a77:	00 
                if (try prog.checkLineMatch()) |info| return info;
  229a78:	48 8d bc 24 40 02 00 	lea    rdi,[rsp+0x240]
  229a7f:	00 
  229a80:	48 8d b4 24 e0 00 00 	lea    rsi,[rsp+0xe0]
  229a87:	00 
  229a88:	e8 c3 13 00 00       	call   22ae50 <LineNumberProgram_checkLineMatch>
  229a8d:	0f b7 84 24 40 02 00 	movzx  eax,WORD PTR [rsp+0x240]
  229a94:	00 
  229a95:	66 85 c0             	test   ax,ax
  229a98:	0f 85 96 09 00 00    	jne    22a434 <getLineNumberInfo+0x1c34>
  229a9e:	80 bc 24 70 02 00 00 	cmp    BYTE PTR [rsp+0x270],0x1
  229aa5:	01 
  229aa6:	0f 84 a6 09 00 00    	je     22a452 <getLineNumberInfo+0x1c52>
  229aac:	c6 84 24 01 01 00 00 	mov    BYTE PTR [rsp+0x101],0x0
  229ab3:	00 
            try self.readNoEof(result[0..]);
  229ab4:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  229ab9:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  229abe:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  229ac5:	00 00 
            return self.readFn(self, buffer);
  229ac7:	4c 89 e7             	mov    rdi,r12
  229aca:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  229acf:	4c 89 ea             	mov    rdx,r13
  229ad2:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  229ad6:	0f b7 4c 24 20       	movzx  ecx,WORD PTR [rsp+0x20]
  229adb:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  229ae0:	66 85 c9             	test   cx,cx
  229ae3:	0f 84 47 fe ff ff    	je     229930 <getLineNumberInfo+0x1130>
  229ae9:	e9 fe fd ff ff       	jmp    2298ec <getLineNumberInfo+0x10ec>
                if (op_size < 1) return error.InvalidDebugInfo;
  229aee:	48 85 ed             	test   rbp,rbp
  229af1:	0f 84 d0 08 00 00    	je     22a3c7 <getLineNumberInfo+0x1bc7>
            try self.readNoEof(result[0..]);
  229af7:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  229afc:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  229b01:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  229b08:	00 00 
            return self.readFn(self, buffer);
  229b0a:	4c 89 e7             	mov    rdi,r12
  229b0d:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  229b12:	4c 89 ea             	mov    rdx,r13
  229b15:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  229b19:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  229b1e:	66 85 c0             	test   ax,ax
  229b21:	0f 85 39 0a 00 00    	jne    22a560 <getLineNumberInfo+0x1d60>
  229b27:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
            if (amt_read < buf.len) return error.EndOfStream;
  229b2c:	48 3b 44 24 10       	cmp    rax,QWORD PTR [rsp+0x10]
  229b31:	0f 82 25 0a 00 00    	jb     22a55c <getLineNumberInfo+0x1d5c>
            return result[0];
  229b37:	8a 44 24 48          	mov    al,BYTE PTR [rsp+0x48]
                switch (sub_op) {
  229b3b:	3c 02                	cmp    al,0x2
  229b3d:	0f 84 03 04 00 00    	je     229f46 <getLineNumberInfo+0x1746>
  229b43:	3c 03                	cmp    al,0x3
  229b45:	0f 84 b2 04 00 00    	je     229ffd <getLineNumberInfo+0x17fd>
  229b4b:	3c 01                	cmp    al,0x1
  229b4d:	0f 84 2b 0a 00 00    	je     22a57e <getLineNumberInfo+0x1d7e>
  229b53:	48 83 c5 ff          	add    rbp,0xffffffffffffffff
  229b57:	0f 88 6a 08 00 00    	js     22a3c7 <getLineNumberInfo+0x1bc7>
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  229b5d:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
  229b62:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  229b65:	b8 08 00 00 00       	mov    eax,0x8
  229b6a:	ba 01 00 00 00       	mov    edx,0x1
  229b6f:	48 89 ee             	mov    rsi,rbp
  229b72:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  229b74:	48 89 c1             	mov    rcx,rax
  229b77:	48 f7 d9             	neg    rcx
  229b7a:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  229b80:	b8 00 00 00 00       	mov    eax,0x0
  229b85:	48 0f 46 c8          	cmovbe rcx,rax
                if (err > 0) {
  229b89:	48 85 c9             	test   rcx,rcx
  229b8c:	0f 84 22 ff ff ff    	je     229ab4 <getLineNumberInfo+0x12b4>
  229b92:	e9 8d 0b 00 00       	jmp    22a724 <getLineNumberInfo+0x1f24>
                        if (opcode - 1 >= standard_opcode_lengths.len) return error.InvalidDebugInfo;
  229b97:	48 39 84 24 98 00 00 	cmp    QWORD PTR [rsp+0x98],rax
  229b9e:	00 
  229b9f:	0f 86 22 08 00 00    	jbe    22a3c7 <getLineNumberInfo+0x1bc7>
                        try in_file.seekForward(len_bytes);
  229ba5:	48 8b 8c 24 d8 00 00 	mov    rcx,QWORD PTR [rsp+0xd8]
  229bac:	00 
  229bad:	0f b6 34 01          	movzx  esi,BYTE PTR [rcx+rax*1]
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  229bb1:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
  229bb6:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  229bb9:	b8 08 00 00 00       	mov    eax,0x8
  229bbe:	ba 01 00 00 00       	mov    edx,0x1
  229bc3:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  229bc5:	48 89 c1             	mov    rcx,rax
  229bc8:	48 f7 d9             	neg    rcx
  229bcb:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  229bd1:	b8 00 00 00 00       	mov    eax,0x0
  229bd6:	48 0f 46 c8          	cmovbe rcx,rax
  229bda:	48 85 c9             	test   rcx,rcx
  229bdd:	0f 84 d1 fe ff ff    	je     229ab4 <getLineNumberInfo+0x12b4>
  229be3:	e9 b6 0a 00 00       	jmp    22a69e <getLineNumberInfo+0x1e9e>
            try self.readNoEof(result[0..]);
  229be8:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  229bed:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  229bf2:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  229bf9:	00 00 
            return self.readFn(self, buffer);
  229bfb:	4c 89 e7             	mov    rdi,r12
  229bfe:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  229c03:	4c 89 ea             	mov    rdx,r13
  229c06:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  229c0a:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  229c0f:	66 85 c0             	test   ax,ax
  229c12:	0f 85 98 08 00 00    	jne    22a4b0 <getLineNumberInfo+0x1cb0>
  229c18:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  229c1d:	31 db                	xor    ebx,ebx
  229c1f:	31 ed                	xor    ebp,ebp
            if (amt_read < buf.len) return error.EndOfStream;
  229c21:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  229c26:	0f 82 68 08 00 00    	jb     22a494 <getLineNumberInfo+0x1c94>
            return result[0];
  229c2c:	0f b6 44 24 48       	movzx  eax,BYTE PTR [rsp+0x48]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  229c31:	89 c2                	mov    edx,eax
  229c33:	83 e2 7f             	and    edx,0x7f
  229c36:	89 ee                	mov    esi,ebp
  229c38:	83 e6 3f             	and    esi,0x3f
  229c3b:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  229c40:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  229c45:	48 39 d6             	cmp    rsi,rdx
  229c48:	0f 85 5e 08 00 00    	jne    22a4ac <getLineNumberInfo+0x1cac>
        result |= operand;
  229c4e:	48 09 cb             	or     rbx,rcx
        if ((byte & 0b10000000) == 0) return result;
  229c51:	84 c0                	test   al,al
  229c53:	0f 89 16 05 00 00    	jns    22a16f <getLineNumberInfo+0x196f>
        shift += 7;
  229c59:	48 83 c5 07          	add    rbp,0x7
            try self.readNoEof(result[0..]);
  229c5d:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  229c62:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  229c67:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  229c6e:	00 00 
            return self.readFn(self, buffer);
  229c70:	4c 89 e7             	mov    rdi,r12
  229c73:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  229c78:	4c 89 ea             	mov    rdx,r13
  229c7b:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  229c7f:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  229c84:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  229c89:	66 85 c0             	test   ax,ax
  229c8c:	74 93                	je     229c21 <getLineNumberInfo+0x1421>
  229c8e:	e9 1d 08 00 00       	jmp    22a4b0 <getLineNumberInfo+0x1cb0>
            try self.readNoEof(result[0..]);
  229c93:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  229c98:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  229c9d:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  229ca4:	00 00 
            return self.readFn(self, buffer);
  229ca6:	4c 89 e7             	mov    rdi,r12
  229ca9:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  229cae:	4c 89 ea             	mov    rdx,r13
  229cb1:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  229cb5:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  229cba:	66 85 c0             	test   ax,ax
  229cbd:	0f 85 0f 08 00 00    	jne    22a4d2 <getLineNumberInfo+0x1cd2>
  229cc3:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  229cc8:	bb 07 00 00 00       	mov    ebx,0x7
  229ccd:	31 ed                	xor    ebp,ebp
            if (amt_read < buf.len) return error.EndOfStream;
  229ccf:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  229cd4:	0f 82 c0 07 00 00    	jb     22a49a <getLineNumberInfo+0x1c9a>
  229cda:	48 8d 53 f9          	lea    rdx,[rbx-0x7]
            return result[0];
  229cde:	0f b6 44 24 48       	movzx  eax,BYTE PTR [rsp+0x48]
        if (@shlWithOverflow(i64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  229ce3:	89 c6                	mov    esi,eax
  229ce5:	83 e6 7f             	and    esi,0x7f
  229ce8:	83 e2 3f             	and    edx,0x3f
  229ceb:	c4 e2 e9 f7 ce       	shlx   rcx,rsi,rdx
  229cf0:	c4 e2 ea f7 d1       	sarx   rdx,rcx,rdx
  229cf5:	48 39 f2             	cmp    rdx,rsi
  229cf8:	0f 85 d0 07 00 00    	jne    22a4ce <getLineNumberInfo+0x1cce>
        result |= operand;
  229cfe:	48 09 cd             	or     rbp,rcx
        if ((byte & 0b10000000) == 0) {
  229d01:	84 c0                	test   al,al
  229d03:	0f 89 77 04 00 00    	jns    22a180 <getLineNumberInfo+0x1980>
            try self.readNoEof(result[0..]);
  229d09:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  229d0e:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  229d13:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  229d1a:	00 00 
            return self.readFn(self, buffer);
  229d1c:	4c 89 e7             	mov    rdi,r12
  229d1f:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  229d24:	4c 89 ea             	mov    rdx,r13
  229d27:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  229d2b:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  229d30:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  229d35:	48 83 c3 07          	add    rbx,0x7
  229d39:	66 85 c0             	test   ax,ax
  229d3c:	74 91                	je     229ccf <getLineNumberInfo+0x14cf>
  229d3e:	e9 8f 07 00 00       	jmp    22a4d2 <getLineNumberInfo+0x1cd2>
            try self.readNoEof(result[0..]);
  229d43:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  229d48:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  229d4d:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  229d54:	00 00 
            return self.readFn(self, buffer);
  229d56:	4c 89 e7             	mov    rdi,r12
  229d59:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  229d5e:	4c 89 ea             	mov    rdx,r13
  229d61:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  229d65:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  229d6a:	66 85 c0             	test   ax,ax
  229d6d:	0f 85 81 07 00 00    	jne    22a4f4 <getLineNumberInfo+0x1cf4>
  229d73:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  229d78:	31 db                	xor    ebx,ebx
  229d7a:	31 ed                	xor    ebp,ebp
            if (amt_read < buf.len) return error.EndOfStream;
  229d7c:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  229d81:	0f 82 19 07 00 00    	jb     22a4a0 <getLineNumberInfo+0x1ca0>
            return result[0];
  229d87:	0f b6 44 24 48       	movzx  eax,BYTE PTR [rsp+0x48]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  229d8c:	89 c2                	mov    edx,eax
  229d8e:	83 e2 7f             	and    edx,0x7f
  229d91:	89 ee                	mov    esi,ebp
  229d93:	83 e6 3f             	and    esi,0x3f
  229d96:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  229d9b:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  229da0:	48 39 d6             	cmp    rsi,rdx
  229da3:	0f 85 47 07 00 00    	jne    22a4f0 <getLineNumberInfo+0x1cf0>
        result |= operand;
  229da9:	48 09 cb             	or     rbx,rcx
        if ((byte & 0b10000000) == 0) return result;
  229dac:	84 c0                	test   al,al
  229dae:	0f 89 f2 03 00 00    	jns    22a1a6 <getLineNumberInfo+0x19a6>
        shift += 7;
  229db4:	48 83 c5 07          	add    rbp,0x7
            try self.readNoEof(result[0..]);
  229db8:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  229dbd:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  229dc2:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  229dc9:	00 00 
            return self.readFn(self, buffer);
  229dcb:	4c 89 e7             	mov    rdi,r12
  229dce:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  229dd3:	4c 89 ea             	mov    rdx,r13
  229dd6:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  229dda:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  229ddf:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  229de4:	66 85 c0             	test   ax,ax
  229de7:	74 93                	je     229d7c <getLineNumberInfo+0x157c>
  229de9:	e9 06 07 00 00       	jmp    22a4f4 <getLineNumberInfo+0x1cf4>
            try self.readNoEof(result[0..]);
  229dee:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  229df3:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  229df8:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  229dff:	00 00 
            return self.readFn(self, buffer);
  229e01:	4c 89 e7             	mov    rdi,r12
  229e04:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  229e09:	4c 89 ea             	mov    rdx,r13
  229e0c:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  229e10:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  229e15:	66 85 c0             	test   ax,ax
  229e18:	0f 85 f8 06 00 00    	jne    22a516 <getLineNumberInfo+0x1d16>
  229e1e:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  229e23:	31 db                	xor    ebx,ebx
  229e25:	31 ed                	xor    ebp,ebp
            if (amt_read < buf.len) return error.EndOfStream;
  229e27:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  229e2c:	0f 82 74 06 00 00    	jb     22a4a6 <getLineNumberInfo+0x1ca6>
            return result[0];
  229e32:	0f b6 44 24 48       	movzx  eax,BYTE PTR [rsp+0x48]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  229e37:	89 c2                	mov    edx,eax
  229e39:	83 e2 7f             	and    edx,0x7f
  229e3c:	89 ee                	mov    esi,ebp
  229e3e:	83 e6 3f             	and    esi,0x3f
  229e41:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  229e46:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  229e4b:	48 39 d6             	cmp    rsi,rdx
  229e4e:	0f 85 be 06 00 00    	jne    22a512 <getLineNumberInfo+0x1d12>
        result |= operand;
  229e54:	48 09 cb             	or     rbx,rcx
        if ((byte & 0b10000000) == 0) return result;
  229e57:	84 c0                	test   al,al
  229e59:	0f 89 54 03 00 00    	jns    22a1b3 <getLineNumberInfo+0x19b3>
        shift += 7;
  229e5f:	48 83 c5 07          	add    rbp,0x7
            try self.readNoEof(result[0..]);
  229e63:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  229e68:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  229e6d:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  229e74:	00 00 
            return self.readFn(self, buffer);
  229e76:	4c 89 e7             	mov    rdi,r12
  229e79:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  229e7e:	4c 89 ea             	mov    rdx,r13
  229e81:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  229e85:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  229e8a:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  229e8f:	66 85 c0             	test   ax,ax
  229e92:	74 93                	je     229e27 <getLineNumberInfo+0x1627>
  229e94:	e9 7d 06 00 00       	jmp    22a516 <getLineNumberInfo+0x1d16>
                        prog.is_stmt = !prog.is_stmt;
  229e99:	8a 84 24 00 01 00 00 	mov    al,BYTE PTR [rsp+0x100]
  229ea0:	f6 d0                	not    al
  229ea2:	24 01                	and    al,0x1
  229ea4:	88 84 24 00 01 00 00 	mov    BYTE PTR [rsp+0x100],al
  229eab:	e9 04 fc ff ff       	jmp    229ab4 <getLineNumberInfo+0x12b4>
                        prog.basic_block = true;
  229eb0:	c6 84 24 01 01 00 00 	mov    BYTE PTR [rsp+0x101],0x1
  229eb7:	01 
  229eb8:	e9 f7 fb ff ff       	jmp    229ab4 <getLineNumberInfo+0x12b4>
                        const inc_addr = minimum_instruction_length * ((255 - opcode_base) / line_range);
  229ebd:	0f b6 84 24 a0 00 00 	movzx  eax,BYTE PTR [rsp+0xa0]
  229ec4:	00 
  229ec5:	f6 74 24 5f          	div    BYTE PTR [rsp+0x5f]
  229ec9:	41 f6 e7             	mul    r15b
                        prog.address += inc_addr;
  229ecc:	0f b6 c0             	movzx  eax,al
  229ecf:	eb 68                	jmp    229f39 <getLineNumberInfo+0x1739>
                        const arg = try in_stream.readInt(st.elf.endian, u16);
  229ed1:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
  229ed6:	8a 58 12             	mov    bl,BYTE PTR [rax+0x12]
            try self.readNoEof(bytes[0..]);
  229ed9:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  229ede:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  229ee3:	48 c7 44 24 10 02 00 	mov    QWORD PTR [rsp+0x10],0x2
  229eea:	00 00 
            return self.readFn(self, buffer);
  229eec:	4c 89 e7             	mov    rdi,r12
  229eef:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  229ef4:	4c 89 ea             	mov    rdx,r13
  229ef7:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  229efb:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  229f00:	66 85 c0             	test   ax,ax
  229f03:	0f 85 df 07 00 00    	jne    22a6e8 <getLineNumberInfo+0x1ee8>
  229f09:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
            if (amt_read < buf.len) return error.EndOfStream;
  229f0e:	48 3b 44 24 10       	cmp    rax,QWORD PTR [rsp+0x10]
  229f13:	0f 82 cb 07 00 00    	jb     22a6e4 <getLineNumberInfo+0x1ee4>
  229f19:	0f b6 44 24 48       	movzx  eax,BYTE PTR [rsp+0x48]
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  229f1e:	0f b6 4c 24 49       	movzx  ecx,BYTE PTR [rsp+0x49]
  229f23:	89 ca                	mov    edx,ecx
  229f25:	c1 e2 08             	shl    edx,0x8
  229f28:	09 c2                	or     edx,eax
                result = (result << 8) | b;
  229f2a:	c1 e0 08             	shl    eax,0x8
  229f2d:	09 c8                	or     eax,ecx
    switch (endian) {
  229f2f:	f6 c3 01             	test   bl,0x1
  229f32:	66 0f 45 c2          	cmovne ax,dx
                        prog.address += arg;
  229f36:	0f b7 c0             	movzx  eax,ax
  229f39:	48 01 84 24 e0 00 00 	add    QWORD PTR [rsp+0xe0],rax
  229f40:	00 
  229f41:	e9 6e fb ff ff       	jmp    229ab4 <getLineNumberInfo+0x12b4>
                        const addr = try in_stream.readInt(st.elf.endian, usize);
  229f46:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
  229f4b:	8a 58 12             	mov    bl,BYTE PTR [rax+0x12]
            try self.readNoEof(bytes[0..]);
  229f4e:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  229f53:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  229f58:	48 c7 44 24 10 08 00 	mov    QWORD PTR [rsp+0x10],0x8
  229f5f:	00 00 
            return self.readFn(self, buffer);
  229f61:	4c 89 e7             	mov    rdi,r12
  229f64:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  229f69:	4c 89 ea             	mov    rdx,r13
  229f6c:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  229f70:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  229f75:	66 85 c0             	test   ax,ax
  229f78:	0f 85 d0 07 00 00    	jne    22a74e <getLineNumberInfo+0x1f4e>
  229f7e:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
            if (amt_read < buf.len) return error.EndOfStream;
  229f83:	48 3b 44 24 10       	cmp    rax,QWORD PTR [rsp+0x10]
  229f88:	0f 82 bc 07 00 00    	jb     22a74a <getLineNumberInfo+0x1f4a>
  229f8e:	0f b6 44 24 48       	movzx  eax,BYTE PTR [rsp+0x48]
  229f93:	0f b6 4c 24 49       	movzx  ecx,BYTE PTR [rsp+0x49]
  229f98:	f6 c3 01             	test   bl,0x1
  229f9b:	0f 84 72 01 00 00    	je     22a113 <getLineNumberInfo+0x1913>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  229fa1:	48 c1 e1 08          	shl    rcx,0x8
  229fa5:	48 09 c1             	or     rcx,rax
  229fa8:	0f b6 44 24 4a       	movzx  eax,BYTE PTR [rsp+0x4a]
  229fad:	48 c1 e0 10          	shl    rax,0x10
  229fb1:	48 09 c8             	or     rax,rcx
  229fb4:	0f b6 4c 24 4b       	movzx  ecx,BYTE PTR [rsp+0x4b]
  229fb9:	48 c1 e1 18          	shl    rcx,0x18
  229fbd:	48 09 c1             	or     rcx,rax
  229fc0:	0f b6 44 24 4c       	movzx  eax,BYTE PTR [rsp+0x4c]
  229fc5:	48 c1 e0 20          	shl    rax,0x20
  229fc9:	48 09 c8             	or     rax,rcx
  229fcc:	0f b6 4c 24 4d       	movzx  ecx,BYTE PTR [rsp+0x4d]
  229fd1:	48 c1 e1 28          	shl    rcx,0x28
  229fd5:	48 09 c1             	or     rcx,rax
  229fd8:	0f b6 54 24 4e       	movzx  edx,BYTE PTR [rsp+0x4e]
  229fdd:	48 c1 e2 30          	shl    rdx,0x30
  229fe1:	0f b6 44 24 4f       	movzx  eax,BYTE PTR [rsp+0x4f]
  229fe6:	48 c1 e0 38          	shl    rax,0x38
  229fea:	48 09 d0             	or     rax,rdx
  229fed:	48 09 c8             	or     rax,rcx
                        prog.address = addr;
  229ff0:	48 89 84 24 e0 00 00 	mov    QWORD PTR [rsp+0xe0],rax
  229ff7:	00 
  229ff8:	e9 b7 fa ff ff       	jmp    229ab4 <getLineNumberInfo+0x12b4>
  229ffd:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
            var in_file_stream = io.FileInStream.init(&self.self_exe_file);
  22a002:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  22a007:	48 8d 0d c2 ac ff ff 	lea    rcx,[rip+0xffffffffffffacc2]        # 224cd0 <FileInStream_readFn>
  22a00e:	48 89 4c 24 10       	mov    QWORD PTR [rsp+0x10],rcx
  22a013:	48 8b b0 a0 00 00 00 	mov    rsi,QWORD PTR [rax+0xa0]
            return readStringRaw(self.allocator(), in_stream);
  22a01a:	4c 89 e7             	mov    rdi,r12
  22a01d:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  22a022:	e8 79 e3 ff ff       	call   2283a0 <readStringRaw>
  22a027:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  22a02c:	48 8d 4c 24 22       	lea    rcx,[rsp+0x22]
  22a031:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  22a035:	c5 f8 29 84 24 b0 01 	vmovaps XMMWORD PTR [rsp+0x1b0],xmm0
  22a03c:	00 00 
  22a03e:	48 8b 49 0e          	mov    rcx,QWORD PTR [rcx+0xe]
  22a042:	48 89 8c 24 be 01 00 	mov    QWORD PTR [rsp+0x1be],rcx
  22a049:	00 
                        const file_name = try st.readString();
  22a04a:	66 85 c0             	test   ax,ax
  22a04d:	0f 85 b3 06 00 00    	jne    22a706 <getLineNumberInfo+0x1f06>
  22a053:	48 8d 84 24 b6 01 00 	lea    rax,[rsp+0x1b6]
  22a05a:	00 
  22a05b:	c5 fa 6f 00          	vmovdqu xmm0,XMMWORD PTR [rax]
  22a05f:	c5 f9 7f 84 24 d0 01 	vmovdqa XMMWORD PTR [rsp+0x1d0],xmm0
  22a066:	00 00 
            try self.readNoEof(result[0..]);
  22a068:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  22a06d:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  22a072:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  22a079:	00 00 
            return self.readFn(self, buffer);
  22a07b:	4c 89 e7             	mov    rdi,r12
  22a07e:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  22a083:	4c 89 ea             	mov    rdx,r13
  22a086:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  22a08a:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  22a08f:	66 85 c0             	test   ax,ax
  22a092:	0f 85 a6 04 00 00    	jne    22a53e <getLineNumberInfo+0x1d3e>
  22a098:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  22a09d:	31 ed                	xor    ebp,ebp
  22a09f:	31 db                	xor    ebx,ebx
            if (amt_read < buf.len) return error.EndOfStream;
  22a0a1:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  22a0a6:	0f 82 88 04 00 00    	jb     22a534 <getLineNumberInfo+0x1d34>
            return result[0];
  22a0ac:	0f b6 44 24 48       	movzx  eax,BYTE PTR [rsp+0x48]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  22a0b1:	89 c2                	mov    edx,eax
  22a0b3:	83 e2 7f             	and    edx,0x7f
  22a0b6:	89 de                	mov    esi,ebx
  22a0b8:	83 e6 3f             	and    esi,0x3f
  22a0bb:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  22a0c0:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  22a0c5:	48 39 d6             	cmp    rsi,rdx
  22a0c8:	0f 85 6c 04 00 00    	jne    22a53a <getLineNumberInfo+0x1d3a>
        result |= operand;
  22a0ce:	48 09 cd             	or     rbp,rcx
        if ((byte & 0b10000000) == 0) return result;
  22a0d1:	84 c0                	test   al,al
  22a0d3:	0f 89 e7 00 00 00    	jns    22a1c0 <getLineNumberInfo+0x19c0>
        shift += 7;
  22a0d9:	48 83 c3 07          	add    rbx,0x7
            try self.readNoEof(result[0..]);
  22a0dd:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  22a0e2:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  22a0e7:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  22a0ee:	00 00 
            return self.readFn(self, buffer);
  22a0f0:	4c 89 e7             	mov    rdi,r12
  22a0f3:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  22a0f8:	4c 89 ea             	mov    rdx,r13
  22a0fb:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  22a0ff:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  22a104:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  22a109:	66 85 c0             	test   ax,ax
  22a10c:	74 93                	je     22a0a1 <getLineNumberInfo+0x18a1>
  22a10e:	e9 2b 04 00 00       	jmp    22a53e <getLineNumberInfo+0x1d3e>
                result = (result << 8) | b;
  22a113:	48 c1 e0 08          	shl    rax,0x8
  22a117:	48 09 c8             	or     rax,rcx
  22a11a:	48 c1 e0 08          	shl    rax,0x8
  22a11e:	0f b6 4c 24 4a       	movzx  ecx,BYTE PTR [rsp+0x4a]
  22a123:	48 09 c1             	or     rcx,rax
  22a126:	48 c1 e1 08          	shl    rcx,0x8
  22a12a:	0f b6 44 24 4b       	movzx  eax,BYTE PTR [rsp+0x4b]
  22a12f:	48 09 c8             	or     rax,rcx
  22a132:	48 c1 e0 08          	shl    rax,0x8
  22a136:	0f b6 4c 24 4c       	movzx  ecx,BYTE PTR [rsp+0x4c]
  22a13b:	48 09 c1             	or     rcx,rax
  22a13e:	48 c1 e1 08          	shl    rcx,0x8
  22a142:	0f b6 44 24 4d       	movzx  eax,BYTE PTR [rsp+0x4d]
  22a147:	48 09 c8             	or     rax,rcx
  22a14a:	48 c1 e0 08          	shl    rax,0x8
  22a14e:	0f b6 4c 24 4e       	movzx  ecx,BYTE PTR [rsp+0x4e]
  22a153:	48 09 c1             	or     rcx,rax
  22a156:	48 c1 e1 08          	shl    rcx,0x8
  22a15a:	0f b6 44 24 4f       	movzx  eax,BYTE PTR [rsp+0x4f]
  22a15f:	48 09 c8             	or     rax,rcx
                        prog.address = addr;
  22a162:	48 89 84 24 e0 00 00 	mov    QWORD PTR [rsp+0xe0],rax
  22a169:	00 
  22a16a:	e9 45 f9 ff ff       	jmp    229ab4 <getLineNumberInfo+0x12b4>
                        prog.address += arg * minimum_instruction_length;
  22a16f:	49 0f af df          	imul   rbx,r15
  22a173:	48 01 9c 24 e0 00 00 	add    QWORD PTR [rsp+0xe0],rbx
  22a17a:	00 
  22a17b:	e9 34 f9 ff ff       	jmp    229ab4 <getLineNumberInfo+0x12b4>
            if (shift < @sizeOf(i64) * 8 and (byte & 0b01000000) != 0) result |= -(i64(1) << @intCast(u6, shift));
  22a180:	48 83 fb 3f          	cmp    rbx,0x3f
  22a184:	77 13                	ja     22a199 <getLineNumberInfo+0x1999>
  22a186:	24 40                	and    al,0x40
  22a188:	74 0f                	je     22a199 <getLineNumberInfo+0x1999>
  22a18a:	48 c7 c0 ff ff ff ff 	mov    rax,0xffffffffffffffff
  22a191:	c4 e2 e1 f7 c0       	shlx   rax,rax,rbx
  22a196:	48 09 c5             	or     rbp,rax
                        prog.line += arg;
  22a199:	48 01 ac 24 f0 00 00 	add    QWORD PTR [rsp+0xf0],rbp
  22a1a0:	00 
  22a1a1:	e9 0e f9 ff ff       	jmp    229ab4 <getLineNumberInfo+0x12b4>
                        prog.file = arg;
  22a1a6:	48 89 9c 24 e8 00 00 	mov    QWORD PTR [rsp+0xe8],rbx
  22a1ad:	00 
  22a1ae:	e9 01 f9 ff ff       	jmp    229ab4 <getLineNumberInfo+0x12b4>
                        prog.column = arg;
  22a1b3:	48 89 9c 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],rbx
  22a1ba:	00 
  22a1bb:	e9 f4 f8 ff ff       	jmp    229ab4 <getLineNumberInfo+0x12b4>
            try self.readNoEof(result[0..]);
  22a1c0:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  22a1c5:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  22a1ca:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  22a1d1:	00 00 
            return self.readFn(self, buffer);
  22a1d3:	4c 89 e7             	mov    rdi,r12
  22a1d6:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  22a1db:	4c 89 ea             	mov    rdx,r13
  22a1de:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  22a1e2:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  22a1e7:	66 85 c0             	test   ax,ax
  22a1ea:	0f 85 e0 03 00 00    	jne    22a5d0 <getLineNumberInfo+0x1dd0>
  22a1f0:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  22a1f5:	45 31 f6             	xor    r14d,r14d
  22a1f8:	31 db                	xor    ebx,ebx
            if (amt_read < buf.len) return error.EndOfStream;
  22a1fa:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  22a1ff:	0f 82 c1 03 00 00    	jb     22a5c6 <getLineNumberInfo+0x1dc6>
            return result[0];
  22a205:	0f b6 44 24 48       	movzx  eax,BYTE PTR [rsp+0x48]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  22a20a:	89 c2                	mov    edx,eax
  22a20c:	83 e2 7f             	and    edx,0x7f
  22a20f:	89 de                	mov    esi,ebx
  22a211:	83 e6 3f             	and    esi,0x3f
  22a214:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  22a219:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  22a21e:	48 39 d6             	cmp    rsi,rdx
  22a221:	0f 85 a5 03 00 00    	jne    22a5cc <getLineNumberInfo+0x1dcc>
        result |= operand;
  22a227:	49 09 ce             	or     r14,rcx
        if ((byte & 0b10000000) == 0) return result;
  22a22a:	84 c0                	test   al,al
  22a22c:	79 3a                	jns    22a268 <getLineNumberInfo+0x1a68>
        shift += 7;
  22a22e:	48 83 c3 07          	add    rbx,0x7
            try self.readNoEof(result[0..]);
  22a232:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  22a237:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  22a23c:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  22a243:	00 00 
            return self.readFn(self, buffer);
  22a245:	4c 89 e7             	mov    rdi,r12
  22a248:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  22a24d:	4c 89 ea             	mov    rdx,r13
  22a250:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  22a254:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  22a259:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  22a25e:	66 85 c0             	test   ax,ax
  22a261:	74 97                	je     22a1fa <getLineNumberInfo+0x19fa>
  22a263:	e9 68 03 00 00       	jmp    22a5d0 <getLineNumberInfo+0x1dd0>
            try self.readNoEof(result[0..]);
  22a268:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  22a26d:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  22a272:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  22a279:	00 00 
            return self.readFn(self, buffer);
  22a27b:	4c 89 e7             	mov    rdi,r12
  22a27e:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  22a283:	4c 89 ea             	mov    rdx,r13
  22a286:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  22a28a:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  22a28f:	66 85 c0             	test   ax,ax
  22a292:	0f 85 de 04 00 00    	jne    22a776 <getLineNumberInfo+0x1f76>
  22a298:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  22a29d:	31 c0                	xor    eax,eax
  22a29f:	48 89 44 24 68       	mov    QWORD PTR [rsp+0x68],rax
  22a2a4:	31 db                	xor    ebx,ebx
            if (amt_read < buf.len) return error.EndOfStream;
  22a2a6:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  22a2ab:	0f 82 bb 04 00 00    	jb     22a76c <getLineNumberInfo+0x1f6c>
            return result[0];
  22a2b1:	0f b6 44 24 48       	movzx  eax,BYTE PTR [rsp+0x48]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  22a2b6:	89 c2                	mov    edx,eax
  22a2b8:	83 e2 7f             	and    edx,0x7f
  22a2bb:	89 de                	mov    esi,ebx
  22a2bd:	83 e6 3f             	and    esi,0x3f
  22a2c0:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  22a2c5:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  22a2ca:	48 39 d6             	cmp    rsi,rdx
  22a2cd:	0f 85 9f 04 00 00    	jne    22a772 <getLineNumberInfo+0x1f72>
        result |= operand;
  22a2d3:	48 09 4c 24 68       	or     QWORD PTR [rsp+0x68],rcx
        if ((byte & 0b10000000) == 0) return result;
  22a2d8:	84 c0                	test   al,al
  22a2da:	79 3a                	jns    22a316 <getLineNumberInfo+0x1b16>
        shift += 7;
  22a2dc:	48 83 c3 07          	add    rbx,0x7
            try self.readNoEof(result[0..]);
  22a2e0:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  22a2e5:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  22a2ea:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  22a2f1:	00 00 
            return self.readFn(self, buffer);
  22a2f3:	4c 89 e7             	mov    rdi,r12
  22a2f6:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  22a2fb:	4c 89 ea             	mov    rdx,r13
  22a2fe:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  22a302:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  22a307:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  22a30c:	66 85 c0             	test   ax,ax
  22a30f:	74 95                	je     22a2a6 <getLineNumberInfo+0x1aa6>
  22a311:	e9 60 04 00 00       	jmp    22a776 <getLineNumberInfo+0x1f76>
                        try file_entries.append(FileEntry{
  22a316:	c5 f9 6f 84 24 d0 01 	vmovdqa xmm0,XMMWORD PTR [rsp+0x1d0]
  22a31d:	00 00 
  22a31f:	c5 f9 7f 84 24 f0 01 	vmovdqa XMMWORD PTR [rsp+0x1f0],xmm0
  22a326:	00 00 
            const new_length = self.len + 1;
  22a328:	48 8b 9c 24 80 00 00 	mov    rbx,QWORD PTR [rsp+0x80]
  22a32f:	00 
            var better_capacity = self.items.len;
  22a330:	48 8b 4c 24 78       	mov    rcx,QWORD PTR [rsp+0x78]
            if (better_capacity >= new_capacity) return;
  22a335:	48 39 d9             	cmp    rcx,rbx
  22a338:	76 05                	jbe    22a33f <getLineNumberInfo+0x1b3f>
            const result = &self.items[self.len];
  22a33a:	48 89 d8             	mov    rax,rbx
  22a33d:	eb 4c                	jmp    22a38b <getLineNumberInfo+0x1b8b>
                better_capacity += better_capacity / 2 + 8;
  22a33f:	48 89 c8             	mov    rax,rcx
  22a342:	48 d1 e8             	shr    rax,1
  22a345:	48 01 c1             	add    rcx,rax
  22a348:	48 83 c1 08          	add    rcx,0x8
                if (better_capacity >= new_capacity) break;
  22a34c:	48 39 d9             	cmp    rcx,rbx
  22a34f:	76 ee                	jbe    22a33f <getLineNumberInfo+0x1b3f>
            self.items = try self.allocator.alignedRealloc(T, A, self.items, better_capacity);
  22a351:	48 8b b4 24 88 00 00 	mov    rsi,QWORD PTR [rsp+0x88]
  22a358:	00 
  22a359:	4c 89 e7             	mov    rdi,r12
  22a35c:	48 8d 54 24 70       	lea    rdx,[rsp+0x70]
  22a361:	e8 3a 0f 00 00       	call   22b2a0 <Allocator_alignedRealloc.196>
  22a366:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  22a36b:	66 85 c0             	test   ax,ax
  22a36e:	0f 85 57 04 00 00    	jne    22a7cb <getLineNumberInfo+0x1fcb>
  22a374:	48 8d 44 24 28       	lea    rax,[rsp+0x28]
  22a379:	c5 fa 6f 00          	vmovdqu xmm0,XMMWORD PTR [rax]
  22a37d:	c5 f9 7f 44 24 70    	vmovdqa XMMWORD PTR [rsp+0x70],xmm0
            const result = &self.items[self.len];
  22a383:	48 8b 84 24 80 00 00 	mov    rax,QWORD PTR [rsp+0x80]
  22a38a:	00 
  22a38b:	48 83 c3 01          	add    rbx,0x1
  22a38f:	48 8b 4c 24 70       	mov    rcx,QWORD PTR [rsp+0x70]
  22a394:	48 8d 04 80          	lea    rax,[rax+rax*4]
            self.len = new_length;
  22a398:	48 89 9c 24 80 00 00 	mov    QWORD PTR [rsp+0x80],rbx
  22a39f:	00 
            new_item_ptr.* = item;
  22a3a0:	c5 f9 6f 84 24 f0 01 	vmovdqa xmm0,XMMWORD PTR [rsp+0x1f0]
  22a3a7:	00 00 
  22a3a9:	c5 fa 7f 04 c1       	vmovdqu XMMWORD PTR [rcx+rax*8],xmm0
  22a3ae:	48 89 6c c1 10       	mov    QWORD PTR [rcx+rax*8+0x10],rbp
  22a3b3:	4c 89 74 c1 18       	mov    QWORD PTR [rcx+rax*8+0x18],r14
  22a3b8:	48 8b 54 24 68       	mov    rdx,QWORD PTR [rsp+0x68]
  22a3bd:	48 89 54 c1 20       	mov    QWORD PTR [rcx+rax*8+0x20],rdx
  22a3c2:	e9 ed f6 ff ff       	jmp    229ab4 <getLineNumberInfo+0x12b4>
  22a3c7:	c5 fc 10 05 59 d6 fd 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffdd659]        # 207a28 <__unnamed_85+0x10>
  22a3ce:	ff 
  22a3cf:	48 8b 04 24          	mov    rax,QWORD PTR [rsp]
  22a3d3:	c5 fc 11 40 10       	vmovups YMMWORD PTR [rax+0x10],ymm0
  22a3d8:	c5 fe 6f 05 38 d6 fd 	vmovdqu ymm0,YMMWORD PTR [rip+0xfffffffffffdd638]        # 207a18 <__unnamed_85>
  22a3df:	ff 
  22a3e0:	e9 22 e7 ff ff       	jmp    228b07 <getLineNumberInfo+0x307>
  22a3e5:	66 b8 25 00          	mov    ax,0x25
  22a3e9:	eb 04                	jmp    22a3ef <getLineNumberInfo+0x1bef>
  22a3eb:	66 b8 29 00          	mov    ax,0x29
  22a3ef:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                const op_size = try readULeb128(in_stream);
  22a3f3:	66 89 01             	mov    WORD PTR [rcx],ax
  22a3f6:	c5 fe 6f 84 24 4c 06 	vmovdqu ymm0,YMMWORD PTR [rsp+0x64c]
  22a3fd:	00 00 
  22a3ff:	c5 fc 10 8c 24 5a 06 	vmovups ymm1,YMMWORD PTR [rsp+0x65a]
  22a406:	00 00 
  22a408:	e9 1f e8 ff ff       	jmp    228c2c <getLineNumberInfo+0x42c>
  22a40d:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
            try file_entries.append(FileEntry{
  22a411:	66 89 01             	mov    WORD PTR [rcx],ax
  22a414:	c5 fc 10 84 24 d6 06 	vmovups ymm0,YMMWORD PTR [rsp+0x6d6]
  22a41b:	00 00 
  22a41d:	c5 fc 10 8c 24 e4 06 	vmovups ymm1,YMMWORD PTR [rsp+0x6e4]
  22a424:	00 00 
  22a426:	e9 01 e8 ff ff       	jmp    228c2c <getLineNumberInfo+0x42c>
  22a42b:	66 b9 25 00          	mov    cx,0x25
  22a42f:	e9 b8 f4 ff ff       	jmp    2298ec <getLineNumberInfo+0x10ec>
  22a434:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                if (try prog.checkLineMatch()) |info| return info;
  22a438:	66 89 01             	mov    WORD PTR [rcx],ax
  22a43b:	c5 fc 10 84 24 80 04 	vmovups ymm0,YMMWORD PTR [rsp+0x480]
  22a442:	00 00 
  22a444:	c5 fc 10 8c 24 8e 04 	vmovups ymm1,YMMWORD PTR [rsp+0x48e]
  22a44b:	00 00 
  22a44d:	e9 da e7 ff ff       	jmp    228c2c <getLineNumberInfo+0x42c>
  22a452:	48 8b 84 24 68 02 00 	mov    rax,QWORD PTR [rsp+0x268]
  22a459:	00 
  22a45a:	48 89 84 24 08 03 00 	mov    QWORD PTR [rsp+0x308],rax
  22a461:	00 
  22a462:	c5 fc 10 84 24 48 02 	vmovups ymm0,YMMWORD PTR [rsp+0x248]
  22a469:	00 00 
  22a46b:	c5 fc 11 84 24 e8 02 	vmovups YMMWORD PTR [rsp+0x2e8],ymm0
  22a472:	00 00 
  22a474:	48 8b 04 24          	mov    rax,QWORD PTR [rsp]
  22a478:	66 c7 00 00 00       	mov    WORD PTR [rax],0x0
  22a47d:	c5 fc 10 84 24 e2 02 	vmovups ymm0,YMMWORD PTR [rsp+0x2e2]
  22a484:	00 00 
  22a486:	c5 fc 10 8c 24 f0 02 	vmovups ymm1,YMMWORD PTR [rsp+0x2f0]
  22a48d:	00 00 
  22a48f:	e9 71 f4 ff ff       	jmp    229905 <getLineNumberInfo+0x1105>
  22a494:	66 b8 25 00          	mov    ax,0x25
  22a498:	eb 16                	jmp    22a4b0 <getLineNumberInfo+0x1cb0>
  22a49a:	66 b8 25 00          	mov    ax,0x25
  22a49e:	eb 32                	jmp    22a4d2 <getLineNumberInfo+0x1cd2>
  22a4a0:	66 b8 25 00          	mov    ax,0x25
  22a4a4:	eb 4e                	jmp    22a4f4 <getLineNumberInfo+0x1cf4>
  22a4a6:	66 b8 25 00          	mov    ax,0x25
  22a4aa:	eb 6a                	jmp    22a516 <getLineNumberInfo+0x1d16>
  22a4ac:	66 b8 29 00          	mov    ax,0x29
  22a4b0:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                        const arg = try readULeb128(in_stream);
  22a4b4:	66 89 01             	mov    WORD PTR [rcx],ax
  22a4b7:	c5 fc 10 84 24 f6 03 	vmovups ymm0,YMMWORD PTR [rsp+0x3f6]
  22a4be:	00 00 
  22a4c0:	c5 fc 10 8c 24 04 04 	vmovups ymm1,YMMWORD PTR [rsp+0x404]
  22a4c7:	00 00 
  22a4c9:	e9 5e e7 ff ff       	jmp    228c2c <getLineNumberInfo+0x42c>
  22a4ce:	66 b8 29 00          	mov    ax,0x29
  22a4d2:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                        const arg = try readILeb128(in_stream);
  22a4d6:	66 89 01             	mov    WORD PTR [rcx],ax
  22a4d9:	c5 fc 10 84 24 c8 03 	vmovups ymm0,YMMWORD PTR [rsp+0x3c8]
  22a4e0:	00 00 
  22a4e2:	c5 fc 10 8c 24 d6 03 	vmovups ymm1,YMMWORD PTR [rsp+0x3d6]
  22a4e9:	00 00 
  22a4eb:	e9 3c e7 ff ff       	jmp    228c2c <getLineNumberInfo+0x42c>
  22a4f0:	66 b8 29 00          	mov    ax,0x29
  22a4f4:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                        const arg = try readULeb128(in_stream);
  22a4f8:	66 89 01             	mov    WORD PTR [rcx],ax
  22a4fb:	c5 fc 10 84 24 9a 03 	vmovups ymm0,YMMWORD PTR [rsp+0x39a]
  22a502:	00 00 
  22a504:	c5 fc 10 8c 24 a8 03 	vmovups ymm1,YMMWORD PTR [rsp+0x3a8]
  22a50b:	00 00 
  22a50d:	e9 1a e7 ff ff       	jmp    228c2c <getLineNumberInfo+0x42c>
  22a512:	66 b8 29 00          	mov    ax,0x29
  22a516:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                        const arg = try readULeb128(in_stream);
  22a51a:	66 89 01             	mov    WORD PTR [rcx],ax
  22a51d:	c5 fc 10 84 24 6c 03 	vmovups ymm0,YMMWORD PTR [rsp+0x36c]
  22a524:	00 00 
  22a526:	c5 fc 10 8c 24 7a 03 	vmovups ymm1,YMMWORD PTR [rsp+0x37a]
  22a52d:	00 00 
  22a52f:	e9 f8 e6 ff ff       	jmp    228c2c <getLineNumberInfo+0x42c>
  22a534:	66 b8 25 00          	mov    ax,0x25
  22a538:	eb 04                	jmp    22a53e <getLineNumberInfo+0x1d3e>
  22a53a:	66 b8 29 00          	mov    ax,0x29
  22a53e:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                        const dir_index = try readULeb128(in_stream);
  22a542:	66 89 01             	mov    WORD PTR [rcx],ax
  22a545:	c5 fc 10 84 24 38 05 	vmovups ymm0,YMMWORD PTR [rsp+0x538]
  22a54c:	00 00 
  22a54e:	c5 fc 10 8c 24 46 05 	vmovups ymm1,YMMWORD PTR [rsp+0x546]
  22a555:	00 00 
  22a557:	e9 d0 e6 ff ff       	jmp    228c2c <getLineNumberInfo+0x42c>
  22a55c:	66 b8 25 00          	mov    ax,0x25
  22a560:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                sub_op = try in_stream.readByte();
  22a564:	66 89 01             	mov    WORD PTR [rcx],ax
  22a567:	c5 fe 6f 84 24 1e 06 	vmovdqu ymm0,YMMWORD PTR [rsp+0x61e]
  22a56e:	00 00 
  22a570:	c5 fc 10 8c 24 2c 06 	vmovups ymm1,YMMWORD PTR [rsp+0x62c]
  22a577:	00 00 
  22a579:	e9 ae e6 ff ff       	jmp    228c2c <getLineNumberInfo+0x42c>
                        prog.end_sequence = true;
  22a57e:	c6 84 24 02 01 00 00 	mov    BYTE PTR [rsp+0x102],0x1
  22a585:	01 
  22a586:	48 8d bc 24 78 02 00 	lea    rdi,[rsp+0x278]
  22a58d:	00 
  22a58e:	48 8d b4 24 e0 00 00 	lea    rsi,[rsp+0xe0]
  22a595:	00 
                        if (try prog.checkLineMatch()) |info| return info;
  22a596:	e8 b5 08 00 00       	call   22ae50 <LineNumberProgram_checkLineMatch>
  22a59b:	0f b7 84 24 78 02 00 	movzx  eax,WORD PTR [rsp+0x278]
  22a5a2:	00 
  22a5a3:	66 85 c0             	test   ax,ax
  22a5a6:	74 46                	je     22a5ee <getLineNumberInfo+0x1dee>
  22a5a8:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
  22a5ac:	66 89 01             	mov    WORD PTR [rcx],ax
  22a5af:	c5 fc 10 84 24 c2 05 	vmovups ymm0,YMMWORD PTR [rsp+0x5c2]
  22a5b6:	00 00 
  22a5b8:	c5 fc 10 8c 24 d0 05 	vmovups ymm1,YMMWORD PTR [rsp+0x5d0]
  22a5bf:	00 00 
  22a5c1:	e9 66 e6 ff ff       	jmp    228c2c <getLineNumberInfo+0x42c>
  22a5c6:	66 b8 25 00          	mov    ax,0x25
  22a5ca:	eb 04                	jmp    22a5d0 <getLineNumberInfo+0x1dd0>
  22a5cc:	66 b8 29 00          	mov    ax,0x29
  22a5d0:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                        const mtime = try readULeb128(in_stream);
  22a5d4:	66 89 01             	mov    WORD PTR [rcx],ax
  22a5d7:	c5 fc 10 84 24 0a 05 	vmovups ymm0,YMMWORD PTR [rsp+0x50a]
  22a5de:	00 00 
  22a5e0:	c5 fc 10 8c 24 18 05 	vmovups ymm1,YMMWORD PTR [rsp+0x518]
  22a5e7:	00 00 
  22a5e9:	e9 3e e6 ff ff       	jmp    228c2c <getLineNumberInfo+0x42c>
                        if (try prog.checkLineMatch()) |info| return info;
  22a5ee:	80 bc 24 a8 02 00 00 	cmp    BYTE PTR [rsp+0x2a8],0x1
  22a5f5:	01 
  22a5f6:	0f 85 f2 e4 ff ff    	jne    228aee <getLineNumberInfo+0x2ee>
  22a5fc:	48 8b 84 24 a0 02 00 	mov    rax,QWORD PTR [rsp+0x2a0]
  22a603:	00 
  22a604:	48 89 84 24 36 03 00 	mov    QWORD PTR [rsp+0x336],rax
  22a60b:	00 
  22a60c:	c5 fc 10 84 24 80 02 	vmovups ymm0,YMMWORD PTR [rsp+0x280]
  22a613:	00 00 
  22a615:	c5 fc 11 84 24 16 03 	vmovups YMMWORD PTR [rsp+0x316],ymm0
  22a61c:	00 00 
  22a61e:	48 8b 04 24          	mov    rax,QWORD PTR [rsp]
  22a622:	66 c7 00 00 00       	mov    WORD PTR [rax],0x0
  22a627:	c5 fc 10 84 24 10 03 	vmovups ymm0,YMMWORD PTR [rsp+0x310]
  22a62e:	00 00 
  22a630:	c5 fc 10 8c 24 1e 03 	vmovups ymm1,YMMWORD PTR [rsp+0x31e]
  22a637:	00 00 
  22a639:	e9 c7 f2 ff ff       	jmp    229905 <getLineNumberInfo+0x1105>
  22a63e:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                        if (try prog.checkLineMatch()) |info| return info;
  22a642:	66 89 01             	mov    WORD PTR [rcx],ax
  22a645:	c5 fc 10 84 24 24 04 	vmovups ymm0,YMMWORD PTR [rsp+0x424]
  22a64c:	00 00 
  22a64e:	c5 fc 10 8c 24 32 04 	vmovups ymm1,YMMWORD PTR [rsp+0x432]
  22a655:	00 00 
  22a657:	e9 d0 e5 ff ff       	jmp    228c2c <getLineNumberInfo+0x42c>
  22a65c:	48 8b 84 24 30 02 00 	mov    rax,QWORD PTR [rsp+0x230]
  22a663:	00 
  22a664:	48 89 84 24 da 02 00 	mov    QWORD PTR [rsp+0x2da],rax
  22a66b:	00 
  22a66c:	c5 fc 10 84 24 10 02 	vmovups ymm0,YMMWORD PTR [rsp+0x210]
  22a673:	00 00 
  22a675:	c5 fc 11 84 24 ba 02 	vmovups YMMWORD PTR [rsp+0x2ba],ymm0
  22a67c:	00 00 
  22a67e:	48 8b 04 24          	mov    rax,QWORD PTR [rsp]
  22a682:	66 c7 00 00 00       	mov    WORD PTR [rax],0x0
  22a687:	c5 fc 10 84 24 b4 02 	vmovups ymm0,YMMWORD PTR [rsp+0x2b4]
  22a68e:	00 00 
  22a690:	c5 fc 10 8c 24 c2 02 	vmovups ymm1,YMMWORD PTR [rsp+0x2c2]
  22a697:	00 00 
  22a699:	e9 67 f2 ff ff       	jmp    229905 <getLineNumberInfo+0x1105>
  22a69e:	48 8d 41 ea          	lea    rax,[rcx-0x16]
  22a6a2:	48 83 f8 35          	cmp    rax,0x35
  22a6a6:	77 10                	ja     22a6b8 <getLineNumberInfo+0x1eb8>
  22a6a8:	48 ba 81 00 00 00 00 	movabs rdx,0x20000000000081
  22a6af:	00 20 00 
  22a6b2:	48 0f a3 c2          	bt     rdx,rax
  22a6b6:	72 0a                	jb     22a6c2 <getLineNumberInfo+0x1ec2>
  22a6b8:	48 83 f9 06          	cmp    rcx,0x6
  22a6bc:	0f 85 d2 00 00 00    	jne    22a794 <getLineNumberInfo+0x1f94>
  22a6c2:	66 b8 27 00          	mov    ax,0x27
  22a6c6:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                        try in_file.seekForward(len_bytes);
  22a6ca:	66 89 01             	mov    WORD PTR [rcx],ax
  22a6cd:	c5 fc 10 84 24 52 04 	vmovups ymm0,YMMWORD PTR [rsp+0x452]
  22a6d4:	00 00 
  22a6d6:	c5 fc 10 8c 24 60 04 	vmovups ymm1,YMMWORD PTR [rsp+0x460]
  22a6dd:	00 00 
  22a6df:	e9 48 e5 ff ff       	jmp    228c2c <getLineNumberInfo+0x42c>
  22a6e4:	66 b8 25 00          	mov    ax,0x25
  22a6e8:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                        const arg = try in_stream.readInt(st.elf.endian, u16);
  22a6ec:	66 89 01             	mov    WORD PTR [rcx],ax
  22a6ef:	c5 fc 10 84 24 3e 03 	vmovups ymm0,YMMWORD PTR [rsp+0x33e]
  22a6f6:	00 00 
  22a6f8:	c5 fc 10 8c 24 4c 03 	vmovups ymm1,YMMWORD PTR [rsp+0x34c]
  22a6ff:	00 00 
  22a701:	e9 26 e5 ff ff       	jmp    228c2c <getLineNumberInfo+0x42c>
  22a706:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                        const file_name = try st.readString();
  22a70a:	66 89 01             	mov    WORD PTR [rcx],ax
  22a70d:	c5 fc 10 84 24 66 05 	vmovups ymm0,YMMWORD PTR [rsp+0x566]
  22a714:	00 00 
  22a716:	c5 fc 10 8c 24 74 05 	vmovups ymm1,YMMWORD PTR [rsp+0x574]
  22a71d:	00 00 
  22a71f:	e9 08 e5 ff ff       	jmp    228c2c <getLineNumberInfo+0x42c>
  22a724:	48 8d 41 ea          	lea    rax,[rcx-0x16]
  22a728:	48 83 f8 35          	cmp    rax,0x35
  22a72c:	77 10                	ja     22a73e <getLineNumberInfo+0x1f3e>
  22a72e:	48 ba 81 00 00 00 00 	movabs rdx,0x20000000000081
  22a735:	00 20 00 
  22a738:	48 0f a3 c2          	bt     rdx,rax
  22a73c:	72 06                	jb     22a744 <getLineNumberInfo+0x1f44>
  22a73e:	48 83 f9 06          	cmp    rcx,0x6
  22a742:	75 59                	jne    22a79d <getLineNumberInfo+0x1f9d>
  22a744:	66 b8 27 00          	mov    ax,0x27
  22a748:	eb 57                	jmp    22a7a1 <getLineNumberInfo+0x1fa1>
  22a74a:	66 b8 25 00          	mov    ax,0x25
  22a74e:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                        const addr = try in_stream.readInt(st.elf.endian, usize);
  22a752:	66 89 01             	mov    WORD PTR [rcx],ax
  22a755:	c5 fe 6f 84 24 94 05 	vmovdqu ymm0,YMMWORD PTR [rsp+0x594]
  22a75c:	00 00 
  22a75e:	c5 fc 10 8c 24 a2 05 	vmovups ymm1,YMMWORD PTR [rsp+0x5a2]
  22a765:	00 00 
  22a767:	e9 c0 e4 ff ff       	jmp    228c2c <getLineNumberInfo+0x42c>
  22a76c:	66 b8 25 00          	mov    ax,0x25
  22a770:	eb 04                	jmp    22a776 <getLineNumberInfo+0x1f76>
  22a772:	66 b8 29 00          	mov    ax,0x29
  22a776:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                        const len_bytes = try readULeb128(in_stream);
  22a77a:	66 89 01             	mov    WORD PTR [rcx],ax
  22a77d:	c5 fc 10 84 24 dc 04 	vmovups ymm0,YMMWORD PTR [rsp+0x4dc]
  22a784:	00 00 
  22a786:	c5 fc 10 8c 24 ea 04 	vmovups ymm1,YMMWORD PTR [rsp+0x4ea]
  22a78d:	00 00 
  22a78f:	e9 98 e4 ff ff       	jmp    228c2c <getLineNumberInfo+0x42c>
  22a794:	66 b8 03 00          	mov    ax,0x3
  22a798:	e9 29 ff ff ff       	jmp    22a6c6 <getLineNumberInfo+0x1ec6>
  22a79d:	66 b8 03 00          	mov    ax,0x3
  22a7a1:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                        try in_file.seekForward(fwd_amt);
  22a7a5:	66 89 01             	mov    WORD PTR [rcx],ax
  22a7a8:	c5 fc 10 84 24 f0 05 	vmovups ymm0,YMMWORD PTR [rsp+0x5f0]
  22a7af:	00 00 
  22a7b1:	c5 fc 10 8c 24 fe 05 	vmovups ymm1,YMMWORD PTR [rsp+0x5fe]
  22a7b8:	00 00 
  22a7ba:	e9 6d e4 ff ff       	jmp    228c2c <getLineNumberInfo+0x42c>
            @panic("assertion failure");
  22a7bf:	48 8d 3d 42 45 02 00 	lea    rdi,[rip+0x24542]        # 24ed08 <__unnamed_2>
  22a7c6:	e8 55 78 fe ff       	call   212020 <panic>
  22a7cb:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                        try file_entries.append(FileEntry{
  22a7cf:	66 89 01             	mov    WORD PTR [rcx],ax
  22a7d2:	c5 fc 10 84 24 ae 04 	vmovups ymm0,YMMWORD PTR [rsp+0x4ae]
  22a7d9:	00 00 
  22a7db:	c5 fc 10 8c 24 bc 04 	vmovups ymm1,YMMWORD PTR [rsp+0x4bc]
  22a7e2:	00 00 
  22a7e4:	e9 43 e4 ff ff       	jmp    228c2c <getLineNumberInfo+0x42c>
  22a7e9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

000000000022a7f0 <printLineFromFile>:
fn printLineFromFile(out_stream: var, line_info: *const LineInfo) !void {
  22a7f0:	55                   	push   rbp
  22a7f1:	41 57                	push   r15
  22a7f3:	41 56                	push   r14
  22a7f5:	41 55                	push   r13
  22a7f7:	41 54                	push   r12
  22a7f9:	53                   	push   rbx
  22a7fa:	48 81 ec 48 30 00 00 	sub    rsp,0x3048
  22a801:	48 89 f5             	mov    rbp,rsi
  22a804:	48 89 7c 24 38       	mov    QWORD PTR [rsp+0x38],rdi
    var path_with_null: [posix.PATH_MAX]u8 = undefined;
  22a809:	48 8d 35 08 d4 fd ff 	lea    rsi,[rip+0xfffffffffffdd408]        # 207c18 <__unnamed_86>
  22a810:	48 8d 7c 24 48       	lea    rdi,[rsp+0x48]
  22a815:	ba 00 10 00 00       	mov    edx,0x1000
  22a81a:	e8 01 3d 00 00       	call   22e520 <memcpy>
    if (file_path.len >= posix.PATH_MAX) return error.NameTooLong;
  22a81f:	48 8b 5d 18          	mov    rbx,QWORD PTR [rbp+0x18]
  22a823:	48 81 fb ff 0f 00 00 	cmp    rbx,0xfff
  22a82a:	76 06                	jbe    22a832 <printLineFromFile+0x42>
  22a82c:	66 bd 1c 00          	mov    bp,0x1c
  22a830:	eb 53                	jmp    22a885 <printLineFromFile+0x95>
    for (source) |s, i|
  22a832:	48 85 db             	test   rbx,rbx
  22a835:	74 11                	je     22a848 <printLineFromFile+0x58>
  22a837:	48 8b 75 10          	mov    rsi,QWORD PTR [rbp+0x10]
  22a83b:	48 8d 7c 24 48       	lea    rdi,[rsp+0x48]
        dest[i] = s;
  22a840:	48 89 da             	mov    rdx,rbx
  22a843:	e8 d8 3c 00 00       	call   22e520 <memcpy>
  22a848:	48 89 6c 24 10       	mov    QWORD PTR [rsp+0x10],rbp
    path_with_null[file_path.len] = 0;
  22a84d:	c6 44 1c 48 00       	mov    BYTE PTR [rsp+rbx*1+0x48],0x0
  22a852:	48 8d 9c 24 48 10 00 	lea    rbx,[rsp+0x1048]
  22a859:	00 
  22a85a:	48 8d 74 24 48       	lea    rsi,[rsp+0x48]
    return path_with_null;
  22a85f:	ba 00 10 00 00       	mov    edx,0x1000
  22a864:	48 89 df             	mov    rdi,rbx
  22a867:	e8 b4 3c 00 00       	call   22e520 <memcpy>
  22a86c:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
            return openReadC(&path_c);
  22a871:	48 89 de             	mov    rsi,rbx
  22a874:	e8 27 a1 ff ff       	call   2249a0 <File_openReadC>
  22a879:	48 8b 5c 24 40       	mov    rbx,QWORD PTR [rsp+0x40]
  22a87e:	89 dd                	mov    ebp,ebx
    var f = try os.File.openRead(line_info.file_name);
  22a880:	66 85 db             	test   bx,bx
  22a883:	74 14                	je     22a899 <printLineFromFile+0xa9>
  22a885:	89 e8                	mov    eax,ebp
  22a887:	48 81 c4 48 30 00 00 	add    rsp,0x3048
  22a88e:	5b                   	pop    rbx
  22a88f:	41 5c                	pop    r12
  22a891:	41 5d                	pop    r13
  22a893:	41 5e                	pop    r14
  22a895:	41 5f                	pop    r15
  22a897:	5d                   	pop    rbp
  22a898:	c3                   	ret    
  22a899:	48 89 d8             	mov    rax,rbx
  22a89c:	48 c1 e8 20          	shr    rax,0x20
  22a8a0:	89 44 24 08          	mov    DWORD PTR [rsp+0x8],eax
    var buf: [os.page_size]u8 = undefined;
  22a8a4:	48 8d 35 6d d3 fd ff 	lea    rsi,[rip+0xfffffffffffdd36d]        # 207c18 <__unnamed_86>
  22a8ab:	48 8d ac 24 48 20 00 	lea    rbp,[rsp+0x2048]
  22a8b2:	00 
  22a8b3:	ba 00 10 00 00       	mov    edx,0x1000
  22a8b8:	48 89 ef             	mov    rdi,rbp
  22a8bb:	e8 60 3c 00 00       	call   22e520 <memcpy>
        const amt_read = try f.read(buf[0..]);
  22a8c0:	48 89 6c 24 28       	mov    QWORD PTR [rsp+0x28],rbp
  22a8c5:	48 c7 44 24 30 00 10 	mov    QWORD PTR [rsp+0x30],0x1000
  22a8cc:	00 00 
  22a8ce:	48 8d 7c 24 18       	lea    rdi,[rsp+0x18]
  22a8d3:	48 8d 74 24 08       	lea    rsi,[rsp+0x8]
  22a8d8:	48 8d 54 24 28       	lea    rdx,[rsp+0x28]
  22a8dd:	e8 be a2 ff ff       	call   224ba0 <File_read>
  22a8e2:	66 83 7c 24 18 00    	cmp    WORD PTR [rsp+0x18],0x0
  22a8e8:	48 8b 6c 24 10       	mov    rbp,QWORD PTR [rsp+0x10]
  22a8ed:	74 4e                	je     22a93d <printLineFromFile+0x14d>
  22a8ef:	48 c1 fb 20          	sar    rbx,0x20
  22a8f3:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  22a8fa:	84 00 00 00 00 00 
    return asm volatile ("syscall"
  22a900:	b8 03 00 00 00       	mov    eax,0x3
  22a905:	48 89 df             	mov    rdi,rbx
  22a908:	0f 05                	syscall 
            switch (err) {
  22a90a:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  22a90e:	74 f0                	je     22a900 <printLineFromFile+0x110>
            const first = list.first orelse return null;
  22a910:	48 8b 05 11 57 02 00 	mov    rax,QWORD PTR [rip+0x25711]        # 250028 <emfile_promise_queue>
  22a917:	48 85 c0             	test   rax,rax
  22a91a:	0f 84 05 02 00 00    	je     22ab25 <printLineFromFile+0x335>
            if (node.prev) |prev_node| {
  22a920:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  22a923:	48 85 c9             	test   rcx,rcx
  22a926:	0f 84 91 01 00 00    	je     22aabd <printLineFromFile+0x2cd>
                prev_node.next = node.next;
  22a92c:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  22a930:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  22a934:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  22a938:	e9 8b 01 00 00       	jmp    22aac8 <printLineFromFile+0x2d8>
  22a93d:	41 bd 01 00 00 00    	mov    r13d,0x1
  22a943:	4c 8b 64 24 20       	mov    r12,QWORD PTR [rsp+0x20]
        for (slice) |byte| {
  22a948:	4d 85 e4             	test   r12,r12
  22a94b:	0f 84 bb 02 00 00    	je     22ac0c <printLineFromFile+0x41c>
  22a951:	45 31 ff             	xor    r15d,r15d
  22a954:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  22a95b:	00 00 00 00 00 
  22a960:	46 0f b6 b4 3c 48 20 	movzx  r14d,BYTE PTR [rsp+r15*1+0x2048]
  22a967:	00 00 
            if (line == line_info.line) {
  22a969:	4c 3b 6d 00          	cmp    r13,QWORD PTR [rbp+0x0]
  22a96d:	75 51                	jne    22a9c0 <printLineFromFile+0x1d0>
  22a96f:	44 88 b4 24 48 10 00 	mov    BYTE PTR [rsp+0x1048],r14b
  22a976:	00 
            const slice = (*[1]u8)(&byte)[0..];
  22a977:	48 8d 84 24 48 10 00 	lea    rax,[rsp+0x1048]
  22a97e:	00 
  22a97f:	48 89 44 24 48       	mov    QWORD PTR [rsp+0x48],rax
  22a984:	48 c7 44 24 50 01 00 	mov    QWORD PTR [rsp+0x50],0x1
  22a98b:	00 00 
  22a98d:	48 8b 7c 24 38       	mov    rdi,QWORD PTR [rsp+0x38]
            return self.writeFn(self, slice);
  22a992:	48 8d 74 24 48       	lea    rsi,[rsp+0x48]
  22a997:	ff 17                	call   QWORD PTR [rdi]
  22a999:	89 c5                	mov    ebp,eax
                try out_stream.writeByte(byte);
  22a99b:	66 85 ed             	test   bp,bp
  22a99e:	75 7d                	jne    22aa1d <printLineFromFile+0x22d>
                if (byte == '\n') {
  22a9a0:	41 80 fe 0a          	cmp    r14b,0xa
  22a9a4:	48 8b 6c 24 10       	mov    rbp,QWORD PTR [rsp+0x10]
  22a9a9:	0f 84 be 00 00 00    	je     22aa6d <printLineFromFile+0x27d>
        for (slice) |byte| {
  22a9af:	49 83 c7 01          	add    r15,0x1
  22a9b3:	4d 39 e7             	cmp    r15,r12
  22a9b6:	72 a8                	jb     22a960 <printLineFromFile+0x170>
  22a9b8:	eb 1b                	jmp    22a9d5 <printLineFromFile+0x1e5>
  22a9ba:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
            if (byte == '\n') {
  22a9c0:	31 c0                	xor    eax,eax
  22a9c2:	41 80 fe 0a          	cmp    r14b,0xa
  22a9c6:	0f 94 c0             	sete   al
  22a9c9:	49 01 c5             	add    r13,rax
        for (slice) |byte| {
  22a9cc:	49 83 c7 01          	add    r15,0x1
  22a9d0:	4d 39 e7             	cmp    r15,r12
  22a9d3:	72 8b                	jb     22a960 <printLineFromFile+0x170>
        if (amt_read < buf.len) return error.EndOfFile;
  22a9d5:	49 81 fc ff 0f 00 00 	cmp    r12,0xfff
  22a9dc:	48 8d 84 24 48 20 00 	lea    rax,[rsp+0x2048]
  22a9e3:	00 
  22a9e4:	0f 86 22 02 00 00    	jbe    22ac0c <printLineFromFile+0x41c>
        const amt_read = try f.read(buf[0..]);
  22a9ea:	48 89 44 24 28       	mov    QWORD PTR [rsp+0x28],rax
  22a9ef:	48 c7 44 24 30 00 10 	mov    QWORD PTR [rsp+0x30],0x1000
  22a9f6:	00 00 
  22a9f8:	48 8d 7c 24 18       	lea    rdi,[rsp+0x18]
  22a9fd:	48 8d 74 24 08       	lea    rsi,[rsp+0x8]
  22aa02:	48 8d 54 24 28       	lea    rdx,[rsp+0x28]
  22aa07:	e8 94 a1 ff ff       	call   224ba0 <File_read>
  22aa0c:	66 83 7c 24 18 00    	cmp    WORD PTR [rsp+0x18],0x0
  22aa12:	0f 84 2b ff ff ff    	je     22a943 <printLineFromFile+0x153>
  22aa18:	e9 d2 fe ff ff       	jmp    22a8ef <printLineFromFile+0xff>
  22aa1d:	48 c1 fb 20          	sar    rbx,0x20
  22aa21:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  22aa28:	0f 1f 84 00 00 00 00 
  22aa2f:	00 
  22aa30:	b8 03 00 00 00       	mov    eax,0x3
  22aa35:	48 89 df             	mov    rdi,rbx
  22aa38:	0f 05                	syscall 
  22aa3a:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  22aa3e:	74 f0                	je     22aa30 <printLineFromFile+0x240>
            const first = list.first orelse return null;
  22aa40:	48 8b 05 e1 55 02 00 	mov    rax,QWORD PTR [rip+0x255e1]        # 250028 <emfile_promise_queue>
  22aa47:	48 85 c0             	test   rax,rax
  22aa4a:	0f 84 35 fe ff ff    	je     22a885 <printLineFromFile+0x95>
            if (node.prev) |prev_node| {
  22aa50:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  22aa53:	48 85 c9             	test   rcx,rcx
  22aa56:	0f 84 d3 00 00 00    	je     22ab2f <printLineFromFile+0x33f>
                prev_node.next = node.next;
  22aa5c:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  22aa60:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  22aa64:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  22aa68:	e9 cd 00 00 00       	jmp    22ab3a <printLineFromFile+0x34a>
  22aa6d:	48 c1 fb 20          	sar    rbx,0x20
  22aa71:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  22aa78:	0f 1f 84 00 00 00 00 
  22aa7f:	00 
  22aa80:	b8 03 00 00 00       	mov    eax,0x3
  22aa85:	48 89 df             	mov    rdi,rbx
  22aa88:	0f 05                	syscall 
  22aa8a:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  22aa8e:	74 f0                	je     22aa80 <printLineFromFile+0x290>
            const first = list.first orelse return null;
  22aa90:	48 8b 05 91 55 02 00 	mov    rax,QWORD PTR [rip+0x25591]        # 250028 <emfile_promise_queue>
  22aa97:	48 85 c0             	test   rax,rax
  22aa9a:	0f 84 65 01 00 00    	je     22ac05 <printLineFromFile+0x415>
            if (node.prev) |prev_node| {
  22aaa0:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  22aaa3:	48 85 c9             	test   rcx,rcx
  22aaa6:	0f 84 f2 00 00 00    	je     22ab9e <printLineFromFile+0x3ae>
                prev_node.next = node.next;
  22aaac:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  22aab0:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  22aab4:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  22aab8:	e9 ec 00 00 00       	jmp    22aba9 <printLineFromFile+0x3b9>
                list.first = node.next;
  22aabd:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  22aac1:	48 89 0d 60 55 02 00 	mov    QWORD PTR [rip+0x25560],rcx        # 250028 <emfile_promise_queue>
            if (node.next) |next_node| {
  22aac8:	48 85 c9             	test   rcx,rcx
  22aacb:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  22aace:	48 8d 35 5b 55 02 00 	lea    rsi,[rip+0x2555b]        # 250030 <emfile_promise_queue+0x8>
  22aad5:	48 0f 45 f1          	cmovne rsi,rcx
  22aad9:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  22aadc:	48 83 05 54 55 02 00 	add    QWORD PTR [rip+0x25554],0xffffffffffffffff        # 250038 <emfile_promise_queue+0x10>
  22aae3:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  22aae4:	74 1e                	je     22ab04 <printLineFromFile+0x314>
  22aae6:	48 83 3d 3a 55 02 00 	cmp    QWORD PTR [rip+0x2553a],0x0        # 250028 <emfile_promise_queue>
  22aaed:	00 
  22aaee:	0f 84 b1 01 00 00    	je     22aca5 <printLineFromFile+0x4b5>
  22aaf4:	48 8b 0d 35 55 02 00 	mov    rcx,QWORD PTR [rip+0x25535]        # 250030 <emfile_promise_queue+0x8>
  22aafb:	48 85 c9             	test   rcx,rcx
  22aafe:	0f 84 a1 01 00 00    	je     22aca5 <printLineFromFile+0x4b5>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  22ab04:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  22ab08:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  22ab0c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  22ab10:	48 89 c1             	mov    rcx,rax
  22ab13:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  22ab17:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  22ab1d:	75 f1                	jne    22ab10 <printLineFromFile+0x320>
  22ab1f:	a8 01                	test   al,0x1
  22ab21:	75 02                	jne    22ab25 <printLineFromFile+0x335>
  22ab23:	ff 17                	call   QWORD PTR [rdi]
  22ab25:	0f b7 44 24 18       	movzx  eax,WORD PTR [rsp+0x18]
  22ab2a:	e9 58 fd ff ff       	jmp    22a887 <printLineFromFile+0x97>
                list.first = node.next;
  22ab2f:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  22ab33:	48 89 0d ee 54 02 00 	mov    QWORD PTR [rip+0x254ee],rcx        # 250028 <emfile_promise_queue>
            if (node.next) |next_node| {
  22ab3a:	48 85 c9             	test   rcx,rcx
  22ab3d:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  22ab40:	48 8d 35 e9 54 02 00 	lea    rsi,[rip+0x254e9]        # 250030 <emfile_promise_queue+0x8>
  22ab47:	48 0f 45 f1          	cmovne rsi,rcx
  22ab4b:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  22ab4e:	48 83 05 e2 54 02 00 	add    QWORD PTR [rip+0x254e2],0xffffffffffffffff        # 250038 <emfile_promise_queue+0x10>
  22ab55:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  22ab56:	74 1e                	je     22ab76 <printLineFromFile+0x386>
  22ab58:	48 83 3d c8 54 02 00 	cmp    QWORD PTR [rip+0x254c8],0x0        # 250028 <emfile_promise_queue>
  22ab5f:	00 
  22ab60:	0f 84 3f 01 00 00    	je     22aca5 <printLineFromFile+0x4b5>
  22ab66:	48 8b 0d c3 54 02 00 	mov    rcx,QWORD PTR [rip+0x254c3]        # 250030 <emfile_promise_queue+0x8>
  22ab6d:	48 85 c9             	test   rcx,rcx
  22ab70:	0f 84 2f 01 00 00    	je     22aca5 <printLineFromFile+0x4b5>
  22ab76:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  22ab7a:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  22ab7e:	66 90                	xchg   ax,ax
  22ab80:	48 89 c1             	mov    rcx,rax
  22ab83:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  22ab87:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  22ab8d:	75 f1                	jne    22ab80 <printLineFromFile+0x390>
  22ab8f:	a8 01                	test   al,0x1
  22ab91:	0f 85 ee fc ff ff    	jne    22a885 <printLineFromFile+0x95>
  22ab97:	ff 17                	call   QWORD PTR [rdi]
  22ab99:	e9 e7 fc ff ff       	jmp    22a885 <printLineFromFile+0x95>
                list.first = node.next;
  22ab9e:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  22aba2:	48 89 0d 7f 54 02 00 	mov    QWORD PTR [rip+0x2547f],rcx        # 250028 <emfile_promise_queue>
            if (node.next) |next_node| {
  22aba9:	48 85 c9             	test   rcx,rcx
  22abac:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  22abaf:	48 8d 35 7a 54 02 00 	lea    rsi,[rip+0x2547a]        # 250030 <emfile_promise_queue+0x8>
  22abb6:	48 0f 45 f1          	cmovne rsi,rcx
  22abba:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  22abbd:	48 83 05 73 54 02 00 	add    QWORD PTR [rip+0x25473],0xffffffffffffffff        # 250038 <emfile_promise_queue+0x10>
  22abc4:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  22abc5:	74 1e                	je     22abe5 <printLineFromFile+0x3f5>
  22abc7:	48 83 3d 59 54 02 00 	cmp    QWORD PTR [rip+0x25459],0x0        # 250028 <emfile_promise_queue>
  22abce:	00 
  22abcf:	0f 84 d0 00 00 00    	je     22aca5 <printLineFromFile+0x4b5>
  22abd5:	48 8b 0d 54 54 02 00 	mov    rcx,QWORD PTR [rip+0x25454]        # 250030 <emfile_promise_queue+0x8>
  22abdc:	48 85 c9             	test   rcx,rcx
  22abdf:	0f 84 c0 00 00 00    	je     22aca5 <printLineFromFile+0x4b5>
  22abe5:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  22abe9:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  22abed:	0f 1f 00             	nop    DWORD PTR [rax]
  22abf0:	48 89 c1             	mov    rcx,rax
  22abf3:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  22abf7:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  22abfd:	75 f1                	jne    22abf0 <printLineFromFile+0x400>
  22abff:	a8 01                	test   al,0x1
  22ac01:	75 02                	jne    22ac05 <printLineFromFile+0x415>
  22ac03:	ff 17                	call   QWORD PTR [rdi]
  22ac05:	31 ed                	xor    ebp,ebp
  22ac07:	e9 79 fc ff ff       	jmp    22a885 <printLineFromFile+0x95>
  22ac0c:	48 c1 fb 20          	sar    rbx,0x20
  22ac10:	b8 03 00 00 00       	mov    eax,0x3
  22ac15:	48 89 df             	mov    rdi,rbx
  22ac18:	0f 05                	syscall 
            switch (err) {
  22ac1a:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  22ac1e:	74 f0                	je     22ac10 <printLineFromFile+0x420>
            const first = list.first orelse return null;
  22ac20:	48 8b 05 01 54 02 00 	mov    rax,QWORD PTR [rip+0x25401]        # 250028 <emfile_promise_queue>
  22ac27:	66 bd 2a 00          	mov    bp,0x2a
  22ac2b:	48 85 c0             	test   rax,rax
  22ac2e:	0f 84 51 fc ff ff    	je     22a885 <printLineFromFile+0x95>
            if (node.prev) |prev_node| {
  22ac34:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  22ac37:	48 85 c9             	test   rcx,rcx
  22ac3a:	74 0e                	je     22ac4a <printLineFromFile+0x45a>
                prev_node.next = node.next;
  22ac3c:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  22ac40:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  22ac44:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  22ac48:	eb 0b                	jmp    22ac55 <printLineFromFile+0x465>
                list.first = node.next;
  22ac4a:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  22ac4e:	48 89 0d d3 53 02 00 	mov    QWORD PTR [rip+0x253d3],rcx        # 250028 <emfile_promise_queue>
            if (node.next) |next_node| {
  22ac55:	48 85 c9             	test   rcx,rcx
  22ac58:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  22ac5b:	48 8d 35 ce 53 02 00 	lea    rsi,[rip+0x253ce]        # 250030 <emfile_promise_queue+0x8>
  22ac62:	48 0f 45 f1          	cmovne rsi,rcx
  22ac66:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  22ac69:	48 83 05 c7 53 02 00 	add    QWORD PTR [rip+0x253c7],0xffffffffffffffff        # 250038 <emfile_promise_queue+0x10>
  22ac70:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  22ac71:	74 16                	je     22ac89 <printLineFromFile+0x499>
  22ac73:	48 83 3d ad 53 02 00 	cmp    QWORD PTR [rip+0x253ad],0x0        # 250028 <emfile_promise_queue>
  22ac7a:	00 
  22ac7b:	74 28                	je     22aca5 <printLineFromFile+0x4b5>
  22ac7d:	48 8b 0d ac 53 02 00 	mov    rcx,QWORD PTR [rip+0x253ac]        # 250030 <emfile_promise_queue+0x8>
  22ac84:	48 85 c9             	test   rcx,rcx
  22ac87:	74 1c                	je     22aca5 <printLineFromFile+0x4b5>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  22ac89:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  22ac8d:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  22ac91:	48 89 c1             	mov    rcx,rax
  22ac94:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  22ac98:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  22ac9e:	75 f1                	jne    22ac91 <printLineFromFile+0x4a1>
  22aca0:	e9 ea fe ff ff       	jmp    22ab8f <printLineFromFile+0x39f>
            @panic("assertion failure");
  22aca5:	48 8d 3d 5c 40 02 00 	lea    rdi,[rip+0x2405c]        # 24ed08 <__unnamed_2>
  22acac:	e8 6f 73 fe ff       	call   212020 <panic>
  22acb1:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  22acb8:	0f 1f 84 00 00 00 00 
  22acbf:	00 

000000000022acc0 <Allocator_alignedRealloc.188>:
    pub fn alignedRealloc(self: *Allocator, comptime T: type, comptime alignment: u29, old_mem: []align(alignment) T, n: usize) ![]align(alignment) T {
  22acc0:	41 56                	push   r14
  22acc2:	53                   	push   rbx
  22acc3:	48 83 ec 78          	sub    rsp,0x78
  22acc7:	49 89 ce             	mov    r14,rcx
  22acca:	48 89 fb             	mov    rbx,rdi
        if (old_mem.len == 0) {
  22accd:	48 8b 42 08          	mov    rax,QWORD PTR [rdx+0x8]
  22acd1:	48 85 c0             	test   rax,rax
  22acd4:	74 59                	je     22ad2f <Allocator_alignedRealloc.188+0x6f>
        if (n == 0) {
  22acd6:	4d 85 f6             	test   r14,r14
  22acd9:	0f 84 92 00 00 00    	je     22ad71 <Allocator_alignedRealloc.188+0xb1>
        const old_byte_slice = @sliceToBytes(old_mem);
  22acdf:	48 8b 0a             	mov    rcx,QWORD PTR [rdx]
  22ace2:	48 89 4c 24 38       	mov    QWORD PTR [rsp+0x38],rcx
  22ace7:	48 89 44 24 40       	mov    QWORD PTR [rsp+0x40],rax
  22acec:	48 8d 7c 24 48       	lea    rdi,[rsp+0x48]
  22acf1:	48 8d 54 24 38       	lea    rdx,[rsp+0x38]
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  22acf6:	41 b8 01 00 00 00    	mov    r8d,0x1
  22acfc:	4c 89 f1             	mov    rcx,r14
  22acff:	ff 56 08             	call   QWORD PTR [rsi+0x8]
  22ad02:	0f b7 44 24 48       	movzx  eax,WORD PTR [rsp+0x48]
  22ad07:	66 85 c0             	test   ax,ax
  22ad0a:	0f 84 9e 00 00 00    	je     22adae <Allocator_alignedRealloc.188+0xee>
  22ad10:	66 89 03             	mov    WORD PTR [rbx],ax
  22ad13:	48 8b 44 24 70       	mov    rax,QWORD PTR [rsp+0x70]
  22ad18:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  22ad1c:	c5 f8 10 44 24 62    	vmovups xmm0,XMMWORD PTR [rsp+0x62]
  22ad22:	c5 f8 11 43 02       	vmovups XMMWORD PTR [rbx+0x2],xmm0
  22ad27:	48 83 c4 78          	add    rsp,0x78
  22ad2b:	5b                   	pop    rbx
  22ad2c:	41 5e                	pop    r14
  22ad2e:	c3                   	ret    
        if (n == 0) {
  22ad2f:	4d 85 f6             	test   r14,r14
  22ad32:	0f 84 a1 00 00 00    	je     22add9 <Allocator_alignedRealloc.188+0x119>
  22ad38:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  22ad3d:	b9 01 00 00 00       	mov    ecx,0x1
  22ad42:	4c 89 f2             	mov    rdx,r14
  22ad45:	ff 16                	call   QWORD PTR [rsi]
  22ad47:	0f b7 4c 24 20       	movzx  ecx,WORD PTR [rsp+0x20]
  22ad4c:	66 85 c9             	test   cx,cx
  22ad4f:	0f 84 a6 00 00 00    	je     22adfb <Allocator_alignedRealloc.188+0x13b>
  22ad55:	0f b7 44 24 1e       	movzx  eax,WORD PTR [rsp+0x1e]
  22ad5a:	66 89 44 24 0c       	mov    WORD PTR [rsp+0xc],ax
  22ad5f:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  22ad64:	8b 54 24 1a          	mov    edx,DWORD PTR [rsp+0x1a]
  22ad68:	89 54 24 08          	mov    DWORD PTR [rsp+0x8],edx
  22ad6c:	e9 af 00 00 00       	jmp    22ae20 <Allocator_alignedRealloc.188+0x160>
        const bytes = @sliceToBytes(memory);
  22ad71:	48 8b 0a             	mov    rcx,QWORD PTR [rdx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  22ad74:	48 8b 56 10          	mov    rdx,QWORD PTR [rsi+0x10]
  22ad78:	48 89 4c 24 20       	mov    QWORD PTR [rsp+0x20],rcx
  22ad7d:	48 89 44 24 28       	mov    QWORD PTR [rsp+0x28],rax
  22ad82:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  22ad87:	48 89 f7             	mov    rdi,rsi
  22ad8a:	48 89 c6             	mov    rsi,rax
  22ad8d:	ff d2                	call   rdx
            return ([*]align(alignment) T)(undefined)[0..0];
  22ad8f:	48 8b 05 7a cc fd ff 	mov    rax,QWORD PTR [rip+0xfffffffffffdcc7a]        # 207a10 <__unnamed_87+0x10>
  22ad96:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  22ad9a:	c5 f8 10 05 5e cc fd 	vmovups xmm0,XMMWORD PTR [rip+0xfffffffffffdcc5e]        # 207a00 <__unnamed_87>
  22ada1:	ff 
  22ada2:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  22ada6:	48 83 c4 78          	add    rsp,0x78
  22adaa:	5b                   	pop    rbx
  22adab:	41 5e                	pop    r14
  22adad:	c3                   	ret    
        assert(byte_slice.len == byte_count);
  22adae:	4c 39 74 24 58       	cmp    QWORD PTR [rsp+0x58],r14
    if (!ok) {
  22adb3:	0f 85 87 00 00 00    	jne    22ae40 <Allocator_alignedRealloc.188+0x180>
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  22adb9:	66 c7 03 00 00       	mov    WORD PTR [rbx],0x0
  22adbe:	0f b7 44 24 12       	movzx  eax,WORD PTR [rsp+0x12]
  22adc3:	66 89 43 06          	mov    WORD PTR [rbx+0x6],ax
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  22adc7:	48 8b 44 24 50       	mov    rax,QWORD PTR [rsp+0x50]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  22adcc:	8b 4c 24 0e          	mov    ecx,DWORD PTR [rsp+0xe]
  22add0:	89 4b 02             	mov    DWORD PTR [rbx+0x2],ecx
  22add3:	48 89 43 08          	mov    QWORD PTR [rbx+0x8],rax
  22add7:	eb 5b                	jmp    22ae34 <Allocator_alignedRealloc.188+0x174>
  22add9:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
            return ([*]align(alignment) T)(undefined)[0..0];
  22adde:	0f b7 0d 21 cc fd ff 	movzx  ecx,WORD PTR [rip+0xfffffffffffdcc21]        # 207a06 <__unnamed_87+0x6>
  22ade5:	66 89 4c 24 0c       	mov    WORD PTR [rsp+0xc],cx
  22adea:	8b 0d 12 cc fd ff    	mov    ecx,DWORD PTR [rip+0xfffffffffffdcc12]        # 207a02 <__unnamed_87+0x2>
  22adf0:	89 4c 24 08          	mov    DWORD PTR [rsp+0x8],ecx
  22adf4:	31 c9                	xor    ecx,ecx
  22adf6:	45 31 f6             	xor    r14d,r14d
  22adf9:	eb 25                	jmp    22ae20 <Allocator_alignedRealloc.188+0x160>
        assert(byte_slice.len == byte_count);
  22adfb:	4c 39 74 24 30       	cmp    QWORD PTR [rsp+0x30],r14
  22ae00:	75 3e                	jne    22ae40 <Allocator_alignedRealloc.188+0x180>
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  22ae02:	48 8b 54 24 28       	mov    rdx,QWORD PTR [rsp+0x28]
  22ae07:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  22ae0c:	8b 4c 24 14          	mov    ecx,DWORD PTR [rsp+0x14]
  22ae10:	89 4c 24 08          	mov    DWORD PTR [rsp+0x8],ecx
  22ae14:	0f b7 4c 24 18       	movzx  ecx,WORD PTR [rsp+0x18]
  22ae19:	66 89 4c 24 0c       	mov    WORD PTR [rsp+0xc],cx
  22ae1e:	31 c9                	xor    ecx,ecx
            return self.alignedAlloc(T, alignment, n);
  22ae20:	66 89 0b             	mov    WORD PTR [rbx],cx
  22ae23:	0f b7 48 04          	movzx  ecx,WORD PTR [rax+0x4]
  22ae27:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  22ae2b:	8b 00                	mov    eax,DWORD PTR [rax]
  22ae2d:	89 43 02             	mov    DWORD PTR [rbx+0x2],eax
  22ae30:	48 89 53 08          	mov    QWORD PTR [rbx+0x8],rdx
  22ae34:	4c 89 73 10          	mov    QWORD PTR [rbx+0x10],r14
  22ae38:	48 83 c4 78          	add    rsp,0x78
  22ae3c:	5b                   	pop    rbx
  22ae3d:	41 5e                	pop    r14
  22ae3f:	c3                   	ret    
            @panic("assertion failure");
  22ae40:	48 8d 3d c1 3e 02 00 	lea    rdi,[rip+0x23ec1]        # 24ed08 <__unnamed_2>
  22ae47:	e8 d4 71 fe ff       	call   212020 <panic>
  22ae4c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

000000000022ae50 <LineNumberProgram_checkLineMatch>:
    pub fn checkLineMatch(self: *LineNumberProgram) !?LineInfo {
  22ae50:	41 56                	push   r14
  22ae52:	53                   	push   rbx
  22ae53:	48 81 ec 98 00 00 00 	sub    rsp,0x98
  22ae5a:	48 89 f3             	mov    rbx,rsi
  22ae5d:	49 89 fe             	mov    r14,rdi
  22ae60:	48 8b 03             	mov    rax,QWORD PTR [rbx]
        if (self.target_address >= self.prev_address and self.target_address < self.address) {
  22ae63:	48 8b 4b 28          	mov    rcx,QWORD PTR [rbx+0x28]
  22ae67:	48 3b 4b 48          	cmp    rcx,QWORD PTR [rbx+0x48]
  22ae6b:	0f 82 b6 00 00 00    	jb     22af27 <LineNumberProgram_checkLineMatch+0xd7>
  22ae71:	48 39 c1             	cmp    rcx,rax
  22ae74:	0f 83 ad 00 00 00    	jae    22af27 <LineNumberProgram_checkLineMatch+0xd7>
            const file_entry = if (self.prev_file == 0) {
  22ae7a:	48 8b 4b 50          	mov    rcx,QWORD PTR [rbx+0x50]
  22ae7e:	48 85 c9             	test   rcx,rcx
  22ae81:	0f 84 f8 00 00 00    	je     22af7f <LineNumberProgram_checkLineMatch+0x12f>
            } else if (self.prev_file - 1 >= self.file_entries.len) {
  22ae87:	48 83 c1 ff          	add    rcx,0xffffffffffffffff
  22ae8b:	48 8b 43 40          	mov    rax,QWORD PTR [rbx+0x40]
  22ae8f:	48 3b 48 10          	cmp    rcx,QWORD PTR [rax+0x10]
  22ae93:	0f 83 ce 00 00 00    	jae    22af67 <LineNumberProgram_checkLineMatch+0x117>
                &self.file_entries.items[self.prev_file - 1];
  22ae99:	48 8b 10             	mov    rdx,QWORD PTR [rax]
            const dir_name = if (file_entry.dir_index >= self.include_dirs.len) {
  22ae9c:	48 8d 0c 89          	lea    rcx,[rcx+rcx*4]
  22aea0:	48 8b 74 ca 10       	mov    rsi,QWORD PTR [rdx+rcx*8+0x10]
  22aea5:	48 3b 73 38          	cmp    rsi,QWORD PTR [rbx+0x38]
  22aea9:	0f 83 b8 00 00 00    	jae    22af67 <LineNumberProgram_checkLineMatch+0x117>
                self.include_dirs[file_entry.dir_index];
  22aeaf:	48 8b 7b 30          	mov    rdi,QWORD PTR [rbx+0x30]
  22aeb3:	48 c1 e6 04          	shl    rsi,0x4
            const dir_name = if (file_entry.dir_index >= self.include_dirs.len) {
  22aeb7:	c5 f8 10 04 37       	vmovups xmm0,XMMWORD PTR [rdi+rsi*1]
  22aebc:	c5 f8 29 44 24 50    	vmovaps XMMWORD PTR [rsp+0x50],xmm0
            const file_name = try os.path.join(self.file_entries.allocator, dir_name, file_entry.file_name);
  22aec2:	48 8b 70 18          	mov    rsi,QWORD PTR [rax+0x18]
  22aec6:	48 8d 0c ca          	lea    rcx,[rdx+rcx*8]
  22aeca:	48 8d 7c 24 18       	lea    rdi,[rsp+0x18]
  22aecf:	48 8d 54 24 50       	lea    rdx,[rsp+0x50]
pub fn joinWindows(allocator: *Allocator, paths: ...) ![]u8 {
    return mem.join(allocator, sep_windows, paths);
}

pub fn joinPosix(allocator: *Allocator, paths: ...) ![]u8 {
    return mem.join(allocator, sep_posix, paths);
  22aed4:	e8 67 06 00 00       	call   22b540 <join.199>
  22aed9:	0f b7 44 24 18       	movzx  eax,WORD PTR [rsp+0x18]
  22aede:	c5 f8 10 44 24 1a    	vmovups xmm0,XMMWORD PTR [rsp+0x1a]
  22aee4:	c5 f8 29 44 24 30    	vmovaps XMMWORD PTR [rsp+0x30],xmm0
  22aeea:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  22aeef:	48 89 4c 24 3e       	mov    QWORD PTR [rsp+0x3e],rcx
  22aef4:	66 85 c0             	test   ax,ax
  22aef7:	0f 84 ab 00 00 00    	je     22afa8 <LineNumberProgram_checkLineMatch+0x158>
  22aefd:	66 41 89 06          	mov    WORD PTR [r14],ax
  22af01:	c5 fc 10 44 24 62    	vmovups ymm0,YMMWORD PTR [rsp+0x62]
  22af07:	c5 fc 10 4c 24 78    	vmovups ymm1,YMMWORD PTR [rsp+0x78]
  22af0d:	c4 c1 7c 11 4e 18    	vmovups YMMWORD PTR [r14+0x18],ymm1
  22af13:	c4 c1 7c 11 46 02    	vmovups YMMWORD PTR [r14+0x2],ymm0
  22af19:	48 81 c4 98 00 00 00 	add    rsp,0x98
  22af20:	5b                   	pop    rbx
  22af21:	41 5e                	pop    r14
  22af23:	c5 f8 77             	vzeroupper 
  22af26:	c3                   	ret    
        self.prev_address = self.address;
  22af27:	48 89 43 48          	mov    QWORD PTR [rbx+0x48],rax
        self.prev_file = self.file;
  22af2b:	c5 f8 10 43 08       	vmovups xmm0,XMMWORD PTR [rbx+0x8]
  22af30:	c5 f8 11 43 50       	vmovups XMMWORD PTR [rbx+0x50],xmm0
        self.prev_column = self.column;
  22af35:	48 8b 43 18          	mov    rax,QWORD PTR [rbx+0x18]
  22af39:	48 89 43 60          	mov    QWORD PTR [rbx+0x60],rax
        self.prev_is_stmt = self.is_stmt;
  22af3d:	8a 43 20             	mov    al,BYTE PTR [rbx+0x20]
  22af40:	88 43 68             	mov    BYTE PTR [rbx+0x68],al
        self.prev_basic_block = self.basic_block;
  22af43:	8a 43 21             	mov    al,BYTE PTR [rbx+0x21]
  22af46:	88 43 69             	mov    BYTE PTR [rbx+0x69],al
        self.prev_end_sequence = self.end_sequence;
  22af49:	8a 43 22             	mov    al,BYTE PTR [rbx+0x22]
  22af4c:	88 43 6a             	mov    BYTE PTR [rbx+0x6a],al
        return null;
  22af4f:	c5 fc 10 05 09 cc fd 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffdcc09]        # 207b60 <__unnamed_88+0x18>
  22af56:	ff 
  22af57:	c4 c1 7c 11 46 18    	vmovups YMMWORD PTR [r14+0x18],ymm0
  22af5d:	c5 fc 10 05 e3 cb fd 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffdcbe3]        # 207b48 <__unnamed_88>
  22af64:	ff 
  22af65:	eb 2e                	jmp    22af95 <LineNumberProgram_checkLineMatch+0x145>
  22af67:	c5 fc 10 05 b9 cb fd 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffdcbb9]        # 207b28 <__unnamed_89+0x18>
  22af6e:	ff 
  22af6f:	c4 c1 7c 11 46 18    	vmovups YMMWORD PTR [r14+0x18],ymm0
  22af75:	c5 fc 10 05 93 cb fd 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffdcb93]        # 207b10 <__unnamed_89>
  22af7c:	ff 
  22af7d:	eb 16                	jmp    22af95 <LineNumberProgram_checkLineMatch+0x145>
                return error.MissingDebugInfo;
  22af7f:	c5 fc 10 05 69 cb fd 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffdcb69]        # 207af0 <__unnamed_90+0x18>
  22af86:	ff 
  22af87:	c4 c1 7c 11 46 18    	vmovups YMMWORD PTR [r14+0x18],ymm0
  22af8d:	c5 fc 10 05 43 cb fd 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffdcb43]        # 207ad8 <__unnamed_90>
  22af94:	ff 
  22af95:	c4 c1 7c 11 06       	vmovups YMMWORD PTR [r14],ymm0
  22af9a:	48 81 c4 98 00 00 00 	add    rsp,0x98
  22afa1:	5b                   	pop    rbx
  22afa2:	41 5e                	pop    r14
  22afa4:	c5 f8 77             	vzeroupper 
  22afa7:	c3                   	ret    
                .allocator = self.file_entries.allocator,
  22afa8:	48 8b 43 40          	mov    rax,QWORD PTR [rbx+0x40]
                .line = if (self.prev_line >= 0) @intCast(usize, self.prev_line) else 0,
  22afac:	48 8b 4b 58          	mov    rcx,QWORD PTR [rbx+0x58]
  22afb0:	48 89 ca             	mov    rdx,rcx
  22afb3:	48 c1 fa 3f          	sar    rdx,0x3f
  22afb7:	c4 e2 e8 f2 c9       	andn   rcx,rdx,rcx
                .column = self.prev_column,
  22afbc:	48 8b 53 60          	mov    rdx,QWORD PTR [rbx+0x60]
                .allocator = self.file_entries.allocator,
  22afc0:	48 8b 40 18          	mov    rax,QWORD PTR [rax+0x18]
            return LineInfo{
  22afc4:	c6 44 24 0a 01       	mov    BYTE PTR [rsp+0xa],0x1
  22afc9:	66 41 c7 06 00 00    	mov    WORD PTR [r14],0x0
  22afcf:	0f b7 74 24 16       	movzx  esi,WORD PTR [rsp+0x16]
  22afd4:	66 41 89 76 06       	mov    WORD PTR [r14+0x6],si
  22afd9:	8b 74 24 12          	mov    esi,DWORD PTR [rsp+0x12]
  22afdd:	41 89 76 02          	mov    DWORD PTR [r14+0x2],esi
  22afe1:	49 89 4e 08          	mov    QWORD PTR [r14+0x8],rcx
  22afe5:	49 89 56 10          	mov    QWORD PTR [r14+0x10],rdx
  22afe9:	c5 f8 10 44 24 36    	vmovups xmm0,XMMWORD PTR [rsp+0x36]
  22afef:	c4 c1 78 11 46 18    	vmovups XMMWORD PTR [r14+0x18],xmm0
  22aff5:	49 89 46 28          	mov    QWORD PTR [r14+0x28],rax
  22aff9:	8a 44 24 0a          	mov    al,BYTE PTR [rsp+0xa]
  22affd:	41 88 46 30          	mov    BYTE PTR [r14+0x30],al
  22b001:	8a 44 24 11          	mov    al,BYTE PTR [rsp+0x11]
  22b005:	41 88 46 37          	mov    BYTE PTR [r14+0x37],al
  22b009:	0f b7 44 24 0f       	movzx  eax,WORD PTR [rsp+0xf]
  22b00e:	66 41 89 46 35       	mov    WORD PTR [r14+0x35],ax
  22b013:	8b 44 24 0b          	mov    eax,DWORD PTR [rsp+0xb]
  22b017:	41 89 46 31          	mov    DWORD PTR [r14+0x31],eax
  22b01b:	48 81 c4 98 00 00 00 	add    rsp,0x98
  22b022:	5b                   	pop    rbx
  22b023:	41 5e                	pop    r14
  22b025:	c3                   	ret    
  22b026:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  22b02d:	00 00 00 

000000000022b030 <Allocator_alignedRealloc.193>:
    pub fn alignedRealloc(self: *Allocator, comptime T: type, comptime alignment: u29, old_mem: []align(alignment) T, n: usize) ![]align(alignment) T {
  22b030:	41 56                	push   r14
  22b032:	53                   	push   rbx
  22b033:	48 81 ec 88 00 00 00 	sub    rsp,0x88
  22b03a:	48 89 fb             	mov    rbx,rdi
        if (old_mem.len == 0) {
  22b03d:	48 8b 42 08          	mov    rax,QWORD PTR [rdx+0x8]
  22b041:	48 85 c0             	test   rax,rax
  22b044:	74 5e                	je     22b0a4 <Allocator_alignedRealloc.193+0x74>
        if (n == 0) {
  22b046:	48 85 c9             	test   rcx,rcx
  22b049:	0f 84 a6 00 00 00    	je     22b0f5 <Allocator_alignedRealloc.193+0xc5>
        const old_byte_slice = @sliceToBytes(old_mem);
  22b04f:	48 8b 12             	mov    rdx,QWORD PTR [rdx]
  22b052:	48 c1 e0 04          	shl    rax,0x4
  22b056:	48 89 54 24 38       	mov    QWORD PTR [rsp+0x38],rdx
  22b05b:	48 89 44 24 40       	mov    QWORD PTR [rsp+0x40],rax
    return if (@mulWithOverflow(T, a, b, &answer)) error.Overflow else answer;
  22b060:	ba 10 00 00 00       	mov    edx,0x10
  22b065:	48 89 c8             	mov    rax,rcx
  22b068:	48 f7 e2             	mul    rdx
  22b06b:	0f 81 ca 00 00 00    	jno    22b13b <Allocator_alignedRealloc.193+0x10b>
  22b071:	48 8d 0d 08 df fd ff 	lea    rcx,[rip+0xfffffffffffddf08]        # 208f80 <__unnamed_43>
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  22b078:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  22b07c:	0f 84 d4 00 00 00    	je     22b156 <Allocator_alignedRealloc.193+0x126>
  22b082:	48 8b 05 17 ca fd ff 	mov    rax,QWORD PTR [rip+0xfffffffffffdca17]        # 207aa0 <__unnamed_91+0x10>
  22b089:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  22b08d:	c5 f8 10 05 fb c9 fd 	vmovups xmm0,XMMWORD PTR [rip+0xfffffffffffdc9fb]        # 207a90 <__unnamed_91>
  22b094:	ff 
  22b095:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  22b099:	48 81 c4 88 00 00 00 	add    rsp,0x88
  22b0a0:	5b                   	pop    rbx
  22b0a1:	41 5e                	pop    r14
  22b0a3:	c3                   	ret    
        if (n == 0) {
  22b0a4:	48 85 c9             	test   rcx,rcx
  22b0a7:	0f 84 f6 00 00 00    	je     22b1a3 <Allocator_alignedRealloc.193+0x173>
  22b0ad:	ba 10 00 00 00       	mov    edx,0x10
  22b0b2:	48 89 c8             	mov    rax,rcx
  22b0b5:	48 f7 e2             	mul    rdx
  22b0b8:	0f 81 07 01 00 00    	jno    22b1c5 <Allocator_alignedRealloc.193+0x195>
  22b0be:	48 8d 0d bb de fd ff 	lea    rcx,[rip+0xfffffffffffddebb]        # 208f80 <__unnamed_43>
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  22b0c5:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  22b0c9:	0f 84 11 01 00 00    	je     22b1e0 <Allocator_alignedRealloc.193+0x1b0>
  22b0cf:	0f b7 05 c0 c9 fd ff 	movzx  eax,WORD PTR [rip+0xfffffffffffdc9c0]        # 207a96 <__unnamed_91+0x6>
  22b0d6:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  22b0db:	8b 05 b1 c9 fd ff    	mov    eax,DWORD PTR [rip+0xfffffffffffdc9b1]        # 207a92 <__unnamed_91+0x2>
  22b0e1:	89 04 24             	mov    DWORD PTR [rsp],eax
  22b0e4:	48 89 e0             	mov    rax,rsp
  22b0e7:	66 b9 01 00          	mov    cx,0x1
  22b0eb:	31 d2                	xor    edx,edx
  22b0ed:	45 31 f6             	xor    r14d,r14d
  22b0f0:	e9 6f 01 00 00       	jmp    22b264 <Allocator_alignedRealloc.193+0x234>
        const bytes = @sliceToBytes(memory);
  22b0f5:	48 c1 e0 04          	shl    rax,0x4
        if (bytes.len == 0) return;
  22b0f9:	74 1e                	je     22b119 <Allocator_alignedRealloc.193+0xe9>
        const bytes = @sliceToBytes(memory);
  22b0fb:	48 8b 0a             	mov    rcx,QWORD PTR [rdx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  22b0fe:	48 8b 56 10          	mov    rdx,QWORD PTR [rsi+0x10]
  22b102:	48 89 4c 24 08       	mov    QWORD PTR [rsp+0x8],rcx
  22b107:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  22b10c:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  22b111:	48 89 f7             	mov    rdi,rsi
  22b114:	48 89 c6             	mov    rsi,rax
  22b117:	ff d2                	call   rdx
            return ([*]align(alignment) T)(undefined)[0..0];
  22b119:	48 8b 05 68 c9 fd ff 	mov    rax,QWORD PTR [rip+0xfffffffffffdc968]        # 207a88 <__unnamed_92+0x10>
  22b120:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  22b124:	c5 f8 10 05 4c c9 fd 	vmovups xmm0,XMMWORD PTR [rip+0xfffffffffffdc94c]        # 207a78 <__unnamed_92>
  22b12b:	ff 
  22b12c:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  22b130:	48 81 c4 88 00 00 00 	add    rsp,0x88
  22b137:	5b                   	pop    rbx
  22b138:	41 5e                	pop    r14
  22b13a:	c3                   	ret    
  22b13b:	48 8d 4c 24 08       	lea    rcx,[rsp+0x8]
  22b140:	66 c7 44 24 08 00 00 	mov    WORD PTR [rsp+0x8],0x0
  22b147:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  22b14c:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  22b150:	0f 85 2c ff ff ff    	jne    22b082 <Allocator_alignedRealloc.193+0x52>
  22b156:	4c 8b 71 08          	mov    r14,QWORD PTR [rcx+0x8]
  22b15a:	48 8d 7c 24 58       	lea    rdi,[rsp+0x58]
  22b15f:	48 8d 54 24 38       	lea    rdx,[rsp+0x38]
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  22b164:	41 b8 08 00 00 00    	mov    r8d,0x8
  22b16a:	4c 89 f1             	mov    rcx,r14
  22b16d:	ff 56 08             	call   QWORD PTR [rsi+0x8]
  22b170:	0f b7 44 24 58       	movzx  eax,WORD PTR [rsp+0x58]
  22b175:	66 85 c0             	test   ax,ax
  22b178:	0f 84 95 00 00 00    	je     22b213 <Allocator_alignedRealloc.193+0x1e3>
  22b17e:	66 89 03             	mov    WORD PTR [rbx],ax
  22b181:	48 8b 84 24 80 00 00 	mov    rax,QWORD PTR [rsp+0x80]
  22b188:	00 
  22b189:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  22b18d:	c5 f8 10 44 24 72    	vmovups xmm0,XMMWORD PTR [rsp+0x72]
  22b193:	c5 f8 11 43 02       	vmovups XMMWORD PTR [rbx+0x2],xmm0
  22b198:	48 81 c4 88 00 00 00 	add    rsp,0x88
  22b19f:	5b                   	pop    rbx
  22b1a0:	41 5e                	pop    r14
  22b1a2:	c3                   	ret    
  22b1a3:	48 89 e0             	mov    rax,rsp
            return ([*]align(alignment) T)(undefined)[0..0];
  22b1a6:	0f b7 0d d1 c8 fd ff 	movzx  ecx,WORD PTR [rip+0xfffffffffffdc8d1]        # 207a7e <__unnamed_92+0x6>
  22b1ad:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  22b1b2:	8b 0d c2 c8 fd ff    	mov    ecx,DWORD PTR [rip+0xfffffffffffdc8c2]        # 207a7a <__unnamed_92+0x2>
  22b1b8:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  22b1bb:	31 c9                	xor    ecx,ecx
  22b1bd:	45 31 f6             	xor    r14d,r14d
  22b1c0:	e9 9f 00 00 00       	jmp    22b264 <Allocator_alignedRealloc.193+0x234>
  22b1c5:	48 8d 4c 24 48       	lea    rcx,[rsp+0x48]
  22b1ca:	66 c7 44 24 48 00 00 	mov    WORD PTR [rsp+0x48],0x0
  22b1d1:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  22b1d6:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  22b1da:	0f 85 ef fe ff ff    	jne    22b0cf <Allocator_alignedRealloc.193+0x9f>
  22b1e0:	4c 8b 71 08          	mov    r14,QWORD PTR [rcx+0x8]
  22b1e4:	48 8d 7c 24 08       	lea    rdi,[rsp+0x8]
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  22b1e9:	b9 08 00 00 00       	mov    ecx,0x8
  22b1ee:	4c 89 f2             	mov    rdx,r14
  22b1f1:	ff 16                	call   QWORD PTR [rsi]
  22b1f3:	0f b7 4c 24 08       	movzx  ecx,WORD PTR [rsp+0x8]
  22b1f8:	66 85 c9             	test   cx,cx
  22b1fb:	74 41                	je     22b23e <Allocator_alignedRealloc.193+0x20e>
  22b1fd:	0f b7 44 24 36       	movzx  eax,WORD PTR [rsp+0x36]
  22b202:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  22b207:	48 89 e0             	mov    rax,rsp
  22b20a:	8b 54 24 32          	mov    edx,DWORD PTR [rsp+0x32]
  22b20e:	89 14 24             	mov    DWORD PTR [rsp],edx
  22b211:	eb 51                	jmp    22b264 <Allocator_alignedRealloc.193+0x234>
        assert(byte_slice.len == byte_count);
  22b213:	4c 39 74 24 68       	cmp    QWORD PTR [rsp+0x68],r14
    if (!ok) {
  22b218:	75 6d                	jne    22b287 <Allocator_alignedRealloc.193+0x257>
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  22b21a:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  22b21f:	66 c7 03 00 00       	mov    WORD PTR [rbx],0x0
  22b224:	0f b7 4c 24 2a       	movzx  ecx,WORD PTR [rsp+0x2a]
  22b229:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  22b22d:	49 c1 ee 04          	shr    r14,0x4
  22b231:	8b 4c 24 26          	mov    ecx,DWORD PTR [rsp+0x26]
  22b235:	89 4b 02             	mov    DWORD PTR [rbx+0x2],ecx
  22b238:	48 89 43 08          	mov    QWORD PTR [rbx+0x8],rax
  22b23c:	eb 3a                	jmp    22b278 <Allocator_alignedRealloc.193+0x248>
        assert(byte_slice.len == byte_count);
  22b23e:	4c 39 74 24 18       	cmp    QWORD PTR [rsp+0x18],r14
  22b243:	75 42                	jne    22b287 <Allocator_alignedRealloc.193+0x257>
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  22b245:	48 8b 54 24 10       	mov    rdx,QWORD PTR [rsp+0x10]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  22b24a:	49 c1 ee 04          	shr    r14,0x4
  22b24e:	48 89 e0             	mov    rax,rsp
  22b251:	8b 4c 24 2c          	mov    ecx,DWORD PTR [rsp+0x2c]
  22b255:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  22b258:	0f b7 4c 24 30       	movzx  ecx,WORD PTR [rsp+0x30]
  22b25d:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  22b262:	31 c9                	xor    ecx,ecx
            return self.alignedAlloc(T, alignment, n);
  22b264:	66 89 0b             	mov    WORD PTR [rbx],cx
  22b267:	0f b7 48 04          	movzx  ecx,WORD PTR [rax+0x4]
  22b26b:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  22b26f:	8b 00                	mov    eax,DWORD PTR [rax]
  22b271:	89 43 02             	mov    DWORD PTR [rbx+0x2],eax
  22b274:	48 89 53 08          	mov    QWORD PTR [rbx+0x8],rdx
  22b278:	4c 89 73 10          	mov    QWORD PTR [rbx+0x10],r14
  22b27c:	48 81 c4 88 00 00 00 	add    rsp,0x88
  22b283:	5b                   	pop    rbx
  22b284:	41 5e                	pop    r14
  22b286:	c3                   	ret    
            @panic("assertion failure");
  22b287:	48 8d 3d 7a 3a 02 00 	lea    rdi,[rip+0x23a7a]        # 24ed08 <__unnamed_2>
  22b28e:	e8 8d 6d fe ff       	call   212020 <panic>
  22b293:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  22b29a:	84 00 00 00 00 00 

000000000022b2a0 <Allocator_alignedRealloc.196>:
    pub fn alignedRealloc(self: *Allocator, comptime T: type, comptime alignment: u29, old_mem: []align(alignment) T, n: usize) ![]align(alignment) T {
  22b2a0:	41 56                	push   r14
  22b2a2:	53                   	push   rbx
  22b2a3:	48 81 ec 88 00 00 00 	sub    rsp,0x88
  22b2aa:	48 89 fb             	mov    rbx,rdi
        if (old_mem.len == 0) {
  22b2ad:	48 8b 42 08          	mov    rax,QWORD PTR [rdx+0x8]
  22b2b1:	48 85 c0             	test   rax,rax
  22b2b4:	74 62                	je     22b318 <Allocator_alignedRealloc.196+0x78>
        if (n == 0) {
  22b2b6:	48 85 c9             	test   rcx,rcx
  22b2b9:	0f 84 a9 00 00 00    	je     22b368 <Allocator_alignedRealloc.196+0xc8>
        const old_byte_slice = @sliceToBytes(old_mem);
  22b2bf:	48 8b 12             	mov    rdx,QWORD PTR [rdx]
  22b2c2:	48 c1 e0 03          	shl    rax,0x3
  22b2c6:	48 8d 04 80          	lea    rax,[rax+rax*4]
  22b2ca:	48 89 54 24 38       	mov    QWORD PTR [rsp+0x38],rdx
  22b2cf:	48 89 44 24 40       	mov    QWORD PTR [rsp+0x40],rax
  22b2d4:	ba 28 00 00 00       	mov    edx,0x28
  22b2d9:	48 89 c8             	mov    rax,rcx
  22b2dc:	48 f7 e2             	mul    rdx
  22b2df:	0f 81 d0 00 00 00    	jno    22b3b5 <Allocator_alignedRealloc.196+0x115>
  22b2e5:	48 8d 0d 94 dc fd ff 	lea    rcx,[rip+0xfffffffffffddc94]        # 208f80 <__unnamed_43>
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  22b2ec:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  22b2f0:	0f 84 da 00 00 00    	je     22b3d0 <Allocator_alignedRealloc.196+0x130>
  22b2f6:	48 8b 05 d3 c7 fd ff 	mov    rax,QWORD PTR [rip+0xfffffffffffdc7d3]        # 207ad0 <__unnamed_93+0x10>
  22b2fd:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  22b301:	c5 f8 10 05 b7 c7 fd 	vmovups xmm0,XMMWORD PTR [rip+0xfffffffffffdc7b7]        # 207ac0 <__unnamed_93>
  22b308:	ff 
  22b309:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  22b30d:	48 81 c4 88 00 00 00 	add    rsp,0x88
  22b314:	5b                   	pop    rbx
  22b315:	41 5e                	pop    r14
  22b317:	c3                   	ret    
        if (n == 0) {
  22b318:	48 85 c9             	test   rcx,rcx
  22b31b:	0f 84 fc 00 00 00    	je     22b41d <Allocator_alignedRealloc.196+0x17d>
  22b321:	ba 28 00 00 00       	mov    edx,0x28
  22b326:	48 89 c8             	mov    rax,rcx
  22b329:	48 f7 e2             	mul    rdx
  22b32c:	0f 81 0c 01 00 00    	jno    22b43e <Allocator_alignedRealloc.196+0x19e>
  22b332:	48 8d 0d 47 dc fd ff 	lea    rcx,[rip+0xfffffffffffddc47]        # 208f80 <__unnamed_43>
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  22b339:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  22b33d:	0f 84 16 01 00 00    	je     22b459 <Allocator_alignedRealloc.196+0x1b9>
  22b343:	0f b7 05 7c c7 fd ff 	movzx  eax,WORD PTR [rip+0xfffffffffffdc77c]        # 207ac6 <__unnamed_93+0x6>
  22b34a:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  22b34f:	8b 05 6d c7 fd ff    	mov    eax,DWORD PTR [rip+0xfffffffffffdc76d]        # 207ac2 <__unnamed_93+0x2>
  22b355:	89 04 24             	mov    DWORD PTR [rsp],eax
  22b358:	48 89 e0             	mov    rax,rsp
  22b35b:	66 b9 01 00          	mov    cx,0x1
  22b35f:	31 f6                	xor    esi,esi
  22b361:	31 d2                	xor    edx,edx
  22b363:	e9 9d 01 00 00       	jmp    22b505 <Allocator_alignedRealloc.196+0x265>
        const bytes = @sliceToBytes(memory);
  22b368:	48 c1 e0 03          	shl    rax,0x3
  22b36c:	48 8d 04 80          	lea    rax,[rax+rax*4]
        if (bytes.len == 0) return;
  22b370:	48 85 c0             	test   rax,rax
  22b373:	74 1e                	je     22b393 <Allocator_alignedRealloc.196+0xf3>
        const bytes = @sliceToBytes(memory);
  22b375:	48 8b 0a             	mov    rcx,QWORD PTR [rdx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  22b378:	48 8b 56 10          	mov    rdx,QWORD PTR [rsi+0x10]
  22b37c:	48 89 4c 24 08       	mov    QWORD PTR [rsp+0x8],rcx
  22b381:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  22b386:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  22b38b:	48 89 f7             	mov    rdi,rsi
  22b38e:	48 89 c6             	mov    rsi,rax
  22b391:	ff d2                	call   rdx
            return ([*]align(alignment) T)(undefined)[0..0];
  22b393:	48 8b 05 1e c7 fd ff 	mov    rax,QWORD PTR [rip+0xfffffffffffdc71e]        # 207ab8 <__unnamed_94+0x10>
  22b39a:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  22b39e:	c5 f8 10 05 02 c7 fd 	vmovups xmm0,XMMWORD PTR [rip+0xfffffffffffdc702]        # 207aa8 <__unnamed_94>
  22b3a5:	ff 
  22b3a6:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  22b3aa:	48 81 c4 88 00 00 00 	add    rsp,0x88
  22b3b1:	5b                   	pop    rbx
  22b3b2:	41 5e                	pop    r14
  22b3b4:	c3                   	ret    
  22b3b5:	48 8d 4c 24 08       	lea    rcx,[rsp+0x8]
  22b3ba:	66 c7 44 24 08 00 00 	mov    WORD PTR [rsp+0x8],0x0
  22b3c1:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  22b3c6:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  22b3ca:	0f 85 26 ff ff ff    	jne    22b2f6 <Allocator_alignedRealloc.196+0x56>
  22b3d0:	4c 8b 71 08          	mov    r14,QWORD PTR [rcx+0x8]
  22b3d4:	48 8d 7c 24 58       	lea    rdi,[rsp+0x58]
  22b3d9:	48 8d 54 24 38       	lea    rdx,[rsp+0x38]
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  22b3de:	41 b8 08 00 00 00    	mov    r8d,0x8
  22b3e4:	4c 89 f1             	mov    rcx,r14
  22b3e7:	ff 56 08             	call   QWORD PTR [rsi+0x8]
  22b3ea:	0f b7 44 24 58       	movzx  eax,WORD PTR [rsp+0x58]
  22b3ef:	66 85 c0             	test   ax,ax
  22b3f2:	0f 84 94 00 00 00    	je     22b48c <Allocator_alignedRealloc.196+0x1ec>
  22b3f8:	66 89 03             	mov    WORD PTR [rbx],ax
  22b3fb:	48 8b 84 24 80 00 00 	mov    rax,QWORD PTR [rsp+0x80]
  22b402:	00 
  22b403:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  22b407:	c5 f8 10 44 24 72    	vmovups xmm0,XMMWORD PTR [rsp+0x72]
  22b40d:	c5 f8 11 43 02       	vmovups XMMWORD PTR [rbx+0x2],xmm0
  22b412:	48 81 c4 88 00 00 00 	add    rsp,0x88
  22b419:	5b                   	pop    rbx
  22b41a:	41 5e                	pop    r14
  22b41c:	c3                   	ret    
  22b41d:	48 89 e0             	mov    rax,rsp
            return ([*]align(alignment) T)(undefined)[0..0];
  22b420:	0f b7 0d 87 c6 fd ff 	movzx  ecx,WORD PTR [rip+0xfffffffffffdc687]        # 207aae <__unnamed_94+0x6>
  22b427:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  22b42c:	8b 0d 78 c6 fd ff    	mov    ecx,DWORD PTR [rip+0xfffffffffffdc678]        # 207aaa <__unnamed_94+0x2>
  22b432:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  22b435:	31 c9                	xor    ecx,ecx
  22b437:	31 d2                	xor    edx,edx
  22b439:	e9 c7 00 00 00       	jmp    22b505 <Allocator_alignedRealloc.196+0x265>
  22b43e:	48 8d 4c 24 48       	lea    rcx,[rsp+0x48]
  22b443:	66 c7 44 24 48 00 00 	mov    WORD PTR [rsp+0x48],0x0
  22b44a:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  22b44f:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  22b453:	0f 85 ea fe ff ff    	jne    22b343 <Allocator_alignedRealloc.196+0xa3>
  22b459:	4c 8b 71 08          	mov    r14,QWORD PTR [rcx+0x8]
  22b45d:	48 8d 7c 24 08       	lea    rdi,[rsp+0x8]
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  22b462:	b9 08 00 00 00       	mov    ecx,0x8
  22b467:	4c 89 f2             	mov    rdx,r14
  22b46a:	ff 16                	call   QWORD PTR [rsi]
  22b46c:	0f b7 4c 24 08       	movzx  ecx,WORD PTR [rsp+0x8]
  22b471:	66 85 c9             	test   cx,cx
  22b474:	74 57                	je     22b4cd <Allocator_alignedRealloc.196+0x22d>
  22b476:	0f b7 44 24 36       	movzx  eax,WORD PTR [rsp+0x36]
  22b47b:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  22b480:	48 89 e0             	mov    rax,rsp
  22b483:	8b 54 24 32          	mov    edx,DWORD PTR [rsp+0x32]
  22b487:	89 14 24             	mov    DWORD PTR [rsp],edx
  22b48a:	eb 79                	jmp    22b505 <Allocator_alignedRealloc.196+0x265>
        assert(byte_slice.len == byte_count);
  22b48c:	4c 39 74 24 68       	cmp    QWORD PTR [rsp+0x68],r14
    if (!ok) {
  22b491:	0f 85 91 00 00 00    	jne    22b528 <Allocator_alignedRealloc.196+0x288>
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  22b497:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  22b49c:	48 b9 cd cc cc cc cc 	movabs rcx,0xcccccccccccccccd
  22b4a3:	cc cc cc 
  22b4a6:	4c 89 f2             	mov    rdx,r14
  22b4a9:	c4 e2 f3 f6 d1       	mulx   rdx,rcx,rcx
  22b4ae:	66 c7 03 00 00       	mov    WORD PTR [rbx],0x0
  22b4b3:	0f b7 4c 24 2a       	movzx  ecx,WORD PTR [rsp+0x2a]
  22b4b8:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  22b4bc:	48 c1 ea 05          	shr    rdx,0x5
  22b4c0:	8b 4c 24 26          	mov    ecx,DWORD PTR [rsp+0x26]
  22b4c4:	89 4b 02             	mov    DWORD PTR [rbx+0x2],ecx
  22b4c7:	48 89 43 08          	mov    QWORD PTR [rbx+0x8],rax
  22b4cb:	eb 4c                	jmp    22b519 <Allocator_alignedRealloc.196+0x279>
        assert(byte_slice.len == byte_count);
  22b4cd:	4c 39 74 24 18       	cmp    QWORD PTR [rsp+0x18],r14
  22b4d2:	75 54                	jne    22b528 <Allocator_alignedRealloc.196+0x288>
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  22b4d4:	48 8b 74 24 10       	mov    rsi,QWORD PTR [rsp+0x10]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  22b4d9:	48 b8 cd cc cc cc cc 	movabs rax,0xcccccccccccccccd
  22b4e0:	cc cc cc 
  22b4e3:	4c 89 f2             	mov    rdx,r14
  22b4e6:	c4 e2 fb f6 d0       	mulx   rdx,rax,rax
  22b4eb:	48 c1 ea 05          	shr    rdx,0x5
  22b4ef:	48 89 e0             	mov    rax,rsp
  22b4f2:	8b 4c 24 2c          	mov    ecx,DWORD PTR [rsp+0x2c]
  22b4f6:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  22b4f9:	0f b7 4c 24 30       	movzx  ecx,WORD PTR [rsp+0x30]
  22b4fe:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  22b503:	31 c9                	xor    ecx,ecx
            return self.alignedAlloc(T, alignment, n);
  22b505:	66 89 0b             	mov    WORD PTR [rbx],cx
  22b508:	0f b7 48 04          	movzx  ecx,WORD PTR [rax+0x4]
  22b50c:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  22b510:	8b 00                	mov    eax,DWORD PTR [rax]
  22b512:	89 43 02             	mov    DWORD PTR [rbx+0x2],eax
  22b515:	48 89 73 08          	mov    QWORD PTR [rbx+0x8],rsi
  22b519:	48 89 53 10          	mov    QWORD PTR [rbx+0x10],rdx
  22b51d:	48 81 c4 88 00 00 00 	add    rsp,0x88
  22b524:	5b                   	pop    rbx
  22b525:	41 5e                	pop    r14
  22b527:	c3                   	ret    
            @panic("assertion failure");
  22b528:	48 8d 3d d9 37 02 00 	lea    rdi,[rip+0x237d9]        # 24ed08 <__unnamed_2>
  22b52f:	e8 ec 6a fe ff       	call   212020 <panic>
  22b534:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  22b53b:	00 00 00 00 00 

000000000022b540 <join.199>:
pub fn join(allocator: *Allocator, sep: u8, strings: ...) ![]u8 {
  22b540:	55                   	push   rbp
  22b541:	41 57                	push   r15
  22b543:	41 56                	push   r14
  22b545:	41 55                	push   r13
  22b547:	41 54                	push   r12
  22b549:	53                   	push   rbx
  22b54a:	48 83 ec 58          	sub    rsp,0x58
  22b54e:	49 89 cc             	mov    r12,rcx
  22b551:	48 89 d3             	mov    rbx,rdx
  22b554:	49 89 f2             	mov    r10,rsi
  22b557:	49 89 ff             	mov    r15,rdi
            const arg = ([]const u8)(strings[string_i]);
  22b55a:	4c 8b 43 08          	mov    r8,QWORD PTR [rbx+0x8]
  22b55e:	4d 8b 6c 24 08       	mov    r13,QWORD PTR [r12+0x8]
            total_strings_len += arg.len;
  22b563:	4d 01 c5             	add    r13,r8
        if (n == 0) {
  22b566:	49 83 c5 02          	add    r13,0x2
  22b56a:	74 42                	je     22b5ae <join.199+0x6e>
  22b56c:	48 8d 7c 24 08       	lea    rdi,[rsp+0x8]
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  22b571:	b9 01 00 00 00       	mov    ecx,0x1
  22b576:	4c 89 d6             	mov    rsi,r10
  22b579:	4c 89 ea             	mov    rdx,r13
  22b57c:	4c 89 d5             	mov    rbp,r10
  22b57f:	ff 55 00             	call   QWORD PTR [rbp+0x0]
  22b582:	0f b7 44 24 08       	movzx  eax,WORD PTR [rsp+0x8]
  22b587:	66 85 c0             	test   ax,ax
  22b58a:	0f 84 e5 00 00 00    	je     22b675 <join.199+0x135>
    const buf = try allocator.alloc(u8, total_strings_len);
  22b590:	66 41 89 07          	mov    WORD PTR [r15],ax
  22b594:	48 8b 44 24 50       	mov    rax,QWORD PTR [rsp+0x50]
  22b599:	49 89 47 10          	mov    QWORD PTR [r15+0x10],rax
  22b59d:	c5 f8 10 44 24 42    	vmovups xmm0,XMMWORD PTR [rsp+0x42]
  22b5a3:	c4 c1 78 11 47 02    	vmovups XMMWORD PTR [r15+0x2],xmm0
  22b5a9:	e9 df 05 00 00       	jmp    22bb8d <join.199+0x64d>
  22b5ae:	45 31 ed             	xor    r13d,r13d
    assert(dest.len >= source.len);
  22b5b1:	4d 39 c5             	cmp    r13,r8
    if (!ok) {
  22b5b4:	0f 82 e5 05 00 00    	jb     22bb9f <join.199+0x65f>
    for (source) |s, i|
  22b5ba:	4d 85 c0             	test   r8,r8
  22b5bd:	0f 84 8f 02 00 00    	je     22b852 <join.199+0x312>
  22b5c3:	48 8b 0b             	mov    rcx,QWORD PTR [rbx]
  22b5c6:	49 81 f8 80 00 00 00 	cmp    r8,0x80
  22b5cd:	72 1a                	jb     22b5e9 <join.199+0xa9>
  22b5cf:	4a 8d 04 01          	lea    rax,[rcx+r8*1]
  22b5d3:	48 39 e8             	cmp    rax,rbp
  22b5d6:	0f 86 be 00 00 00    	jbe    22b69a <join.199+0x15a>
  22b5dc:	49 8d 04 28          	lea    rax,[r8+rbp*1]
  22b5e0:	48 39 c1             	cmp    rcx,rax
  22b5e3:	0f 83 b1 00 00 00    	jae    22b69a <join.199+0x15a>
  22b5e9:	31 d2                	xor    edx,edx
  22b5eb:	49 8d 40 ff          	lea    rax,[r8-0x1]
  22b5ef:	48 29 d0             	sub    rax,rdx
  22b5f2:	4c 89 c6             	mov    rsi,r8
  22b5f5:	48 83 e6 07          	and    rsi,0x7
  22b5f9:	74 17                	je     22b612 <join.199+0xd2>
  22b5fb:	48 f7 de             	neg    rsi
  22b5fe:	66 90                	xchg   ax,ax
  22b600:	0f b6 1c 11          	movzx  ebx,BYTE PTR [rcx+rdx*1]
        dest[i] = s;
  22b604:	88 5c 15 00          	mov    BYTE PTR [rbp+rdx*1+0x0],bl
    for (source) |s, i|
  22b608:	48 83 c2 01          	add    rdx,0x1
  22b60c:	48 83 c6 01          	add    rsi,0x1
  22b610:	75 ee                	jne    22b600 <join.199+0xc0>
  22b612:	48 83 f8 07          	cmp    rax,0x7
  22b616:	0f 82 36 02 00 00    	jb     22b852 <join.199+0x312>
  22b61c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  22b620:	0f b6 04 11          	movzx  eax,BYTE PTR [rcx+rdx*1]
        dest[i] = s;
  22b624:	88 44 15 00          	mov    BYTE PTR [rbp+rdx*1+0x0],al
    for (source) |s, i|
  22b628:	0f b6 44 11 01       	movzx  eax,BYTE PTR [rcx+rdx*1+0x1]
        dest[i] = s;
  22b62d:	88 44 15 01          	mov    BYTE PTR [rbp+rdx*1+0x1],al
    for (source) |s, i|
  22b631:	0f b6 44 11 02       	movzx  eax,BYTE PTR [rcx+rdx*1+0x2]
        dest[i] = s;
  22b636:	88 44 15 02          	mov    BYTE PTR [rbp+rdx*1+0x2],al
    for (source) |s, i|
  22b63a:	0f b6 44 11 03       	movzx  eax,BYTE PTR [rcx+rdx*1+0x3]
        dest[i] = s;
  22b63f:	88 44 15 03          	mov    BYTE PTR [rbp+rdx*1+0x3],al
    for (source) |s, i|
  22b643:	0f b6 44 11 04       	movzx  eax,BYTE PTR [rcx+rdx*1+0x4]
        dest[i] = s;
  22b648:	88 44 15 04          	mov    BYTE PTR [rbp+rdx*1+0x4],al
    for (source) |s, i|
  22b64c:	0f b6 44 11 05       	movzx  eax,BYTE PTR [rcx+rdx*1+0x5]
        dest[i] = s;
  22b651:	88 44 15 05          	mov    BYTE PTR [rbp+rdx*1+0x5],al
    for (source) |s, i|
  22b655:	0f b6 44 11 06       	movzx  eax,BYTE PTR [rcx+rdx*1+0x6]
        dest[i] = s;
  22b65a:	88 44 15 06          	mov    BYTE PTR [rbp+rdx*1+0x6],al
    for (source) |s, i|
  22b65e:	0f b6 44 11 07       	movzx  eax,BYTE PTR [rcx+rdx*1+0x7]
        dest[i] = s;
  22b663:	88 44 15 07          	mov    BYTE PTR [rbp+rdx*1+0x7],al
    for (source) |s, i|
  22b667:	48 83 c2 08          	add    rdx,0x8
  22b66b:	49 39 d0             	cmp    r8,rdx
  22b66e:	75 b0                	jne    22b620 <join.199+0xe0>
  22b670:	e9 dd 01 00 00       	jmp    22b852 <join.199+0x312>
  22b675:	49 89 ea             	mov    r10,rbp
        assert(byte_slice.len == byte_count);
  22b678:	4c 39 6c 24 18       	cmp    QWORD PTR [rsp+0x18],r13
  22b67d:	0f 85 1c 05 00 00    	jne    22bb9f <join.199+0x65f>
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  22b683:	48 8b 6c 24 10       	mov    rbp,QWORD PTR [rsp+0x10]
        const arg = ([]const u8)(strings[string_i]);
  22b688:	4c 8b 43 08          	mov    r8,QWORD PTR [rbx+0x8]
    assert(dest.len >= source.len);
  22b68c:	4d 39 c5             	cmp    r13,r8
  22b68f:	0f 83 25 ff ff ff    	jae    22b5ba <join.199+0x7a>
  22b695:	e9 05 05 00 00       	jmp    22bb9f <join.199+0x65f>
    for (source) |s, i|
  22b69a:	4c 89 c2             	mov    rdx,r8
  22b69d:	48 83 e2 80          	and    rdx,0xffffffffffffff80
  22b6a1:	48 8d 42 80          	lea    rax,[rdx-0x80]
  22b6a5:	48 89 c7             	mov    rdi,rax
  22b6a8:	48 c1 ef 07          	shr    rdi,0x7
  22b6ac:	8d 77 01             	lea    esi,[rdi+0x1]
  22b6af:	83 e6 03             	and    esi,0x3
  22b6b2:	48 3d 80 01 00 00    	cmp    rax,0x180
  22b6b8:	73 10                	jae    22b6ca <join.199+0x18a>
  22b6ba:	31 ff                	xor    edi,edi
  22b6bc:	48 85 f6             	test   rsi,rsi
  22b6bf:	0f 85 38 01 00 00    	jne    22b7fd <join.199+0x2bd>
  22b6c5:	e9 7f 01 00 00       	jmp    22b849 <join.199+0x309>
  22b6ca:	48 8d 46 ff          	lea    rax,[rsi-0x1]
  22b6ce:	48 29 f8             	sub    rax,rdi
  22b6d1:	31 ff                	xor    edi,edi
  22b6d3:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  22b6da:	84 00 00 00 00 00 
  22b6e0:	c5 fc 10 04 39       	vmovups ymm0,YMMWORD PTR [rcx+rdi*1]
  22b6e5:	c5 fc 10 4c 39 20    	vmovups ymm1,YMMWORD PTR [rcx+rdi*1+0x20]
  22b6eb:	c5 fc 10 54 39 40    	vmovups ymm2,YMMWORD PTR [rcx+rdi*1+0x40]
  22b6f1:	c5 fc 10 5c 39 60    	vmovups ymm3,YMMWORD PTR [rcx+rdi*1+0x60]
        dest[i] = s;
  22b6f7:	c5 fc 11 44 3d 00    	vmovups YMMWORD PTR [rbp+rdi*1+0x0],ymm0
  22b6fd:	c5 fc 11 4c 3d 20    	vmovups YMMWORD PTR [rbp+rdi*1+0x20],ymm1
  22b703:	c5 fc 11 54 3d 40    	vmovups YMMWORD PTR [rbp+rdi*1+0x40],ymm2
  22b709:	c5 fc 11 5c 3d 60    	vmovups YMMWORD PTR [rbp+rdi*1+0x60],ymm3
    for (source) |s, i|
  22b70f:	c5 fc 10 84 39 80 00 	vmovups ymm0,YMMWORD PTR [rcx+rdi*1+0x80]
  22b716:	00 00 
  22b718:	c5 fc 10 8c 39 a0 00 	vmovups ymm1,YMMWORD PTR [rcx+rdi*1+0xa0]
  22b71f:	00 00 
  22b721:	c5 fc 10 94 39 c0 00 	vmovups ymm2,YMMWORD PTR [rcx+rdi*1+0xc0]
  22b728:	00 00 
  22b72a:	c5 fc 10 9c 39 e0 00 	vmovups ymm3,YMMWORD PTR [rcx+rdi*1+0xe0]
  22b731:	00 00 
        dest[i] = s;
  22b733:	c5 fc 11 84 3d 80 00 	vmovups YMMWORD PTR [rbp+rdi*1+0x80],ymm0
  22b73a:	00 00 
  22b73c:	c5 fc 11 8c 3d a0 00 	vmovups YMMWORD PTR [rbp+rdi*1+0xa0],ymm1
  22b743:	00 00 
  22b745:	c5 fc 11 94 3d c0 00 	vmovups YMMWORD PTR [rbp+rdi*1+0xc0],ymm2
  22b74c:	00 00 
  22b74e:	c5 fc 11 9c 3d e0 00 	vmovups YMMWORD PTR [rbp+rdi*1+0xe0],ymm3
  22b755:	00 00 
    for (source) |s, i|
  22b757:	c5 fc 10 84 39 00 01 	vmovups ymm0,YMMWORD PTR [rcx+rdi*1+0x100]
  22b75e:	00 00 
  22b760:	c5 fc 10 8c 39 20 01 	vmovups ymm1,YMMWORD PTR [rcx+rdi*1+0x120]
  22b767:	00 00 
  22b769:	c5 fc 10 94 39 40 01 	vmovups ymm2,YMMWORD PTR [rcx+rdi*1+0x140]
  22b770:	00 00 
  22b772:	c5 fc 10 9c 39 60 01 	vmovups ymm3,YMMWORD PTR [rcx+rdi*1+0x160]
  22b779:	00 00 
        dest[i] = s;
  22b77b:	c5 fc 11 84 3d 00 01 	vmovups YMMWORD PTR [rbp+rdi*1+0x100],ymm0
  22b782:	00 00 
  22b784:	c5 fc 11 8c 3d 20 01 	vmovups YMMWORD PTR [rbp+rdi*1+0x120],ymm1
  22b78b:	00 00 
  22b78d:	c5 fc 11 94 3d 40 01 	vmovups YMMWORD PTR [rbp+rdi*1+0x140],ymm2
  22b794:	00 00 
  22b796:	c5 fc 11 9c 3d 60 01 	vmovups YMMWORD PTR [rbp+rdi*1+0x160],ymm3
  22b79d:	00 00 
    for (source) |s, i|
  22b79f:	c5 fc 10 84 39 80 01 	vmovups ymm0,YMMWORD PTR [rcx+rdi*1+0x180]
  22b7a6:	00 00 
  22b7a8:	c5 fc 10 8c 39 a0 01 	vmovups ymm1,YMMWORD PTR [rcx+rdi*1+0x1a0]
  22b7af:	00 00 
  22b7b1:	c5 fc 10 94 39 c0 01 	vmovups ymm2,YMMWORD PTR [rcx+rdi*1+0x1c0]
  22b7b8:	00 00 
  22b7ba:	c5 fc 10 9c 39 e0 01 	vmovups ymm3,YMMWORD PTR [rcx+rdi*1+0x1e0]
  22b7c1:	00 00 
        dest[i] = s;
  22b7c3:	c5 fc 11 84 3d 80 01 	vmovups YMMWORD PTR [rbp+rdi*1+0x180],ymm0
  22b7ca:	00 00 
  22b7cc:	c5 fc 11 8c 3d a0 01 	vmovups YMMWORD PTR [rbp+rdi*1+0x1a0],ymm1
  22b7d3:	00 00 
  22b7d5:	c5 fc 11 94 3d c0 01 	vmovups YMMWORD PTR [rbp+rdi*1+0x1c0],ymm2
  22b7dc:	00 00 
  22b7de:	c5 fc 11 9c 3d e0 01 	vmovups YMMWORD PTR [rbp+rdi*1+0x1e0],ymm3
  22b7e5:	00 00 
    for (source) |s, i|
  22b7e7:	48 81 c7 00 02 00 00 	add    rdi,0x200
  22b7ee:	48 83 c0 04          	add    rax,0x4
  22b7f2:	0f 85 e8 fe ff ff    	jne    22b6e0 <join.199+0x1a0>
  22b7f8:	48 85 f6             	test   rsi,rsi
  22b7fb:	74 4c                	je     22b849 <join.199+0x309>
  22b7fd:	48 83 c7 60          	add    rdi,0x60
  22b801:	48 f7 de             	neg    rsi
  22b804:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  22b80b:	00 00 00 00 00 
  22b810:	c5 fc 10 44 39 a0    	vmovups ymm0,YMMWORD PTR [rcx+rdi*1-0x60]
  22b816:	c5 fc 10 4c 39 c0    	vmovups ymm1,YMMWORD PTR [rcx+rdi*1-0x40]
  22b81c:	c5 fc 10 54 39 e0    	vmovups ymm2,YMMWORD PTR [rcx+rdi*1-0x20]
  22b822:	c5 fc 10 1c 39       	vmovups ymm3,YMMWORD PTR [rcx+rdi*1]
        dest[i] = s;
  22b827:	c5 fc 11 44 3d a0    	vmovups YMMWORD PTR [rbp+rdi*1-0x60],ymm0
  22b82d:	c5 fc 11 4c 3d c0    	vmovups YMMWORD PTR [rbp+rdi*1-0x40],ymm1
  22b833:	c5 fc 11 54 3d e0    	vmovups YMMWORD PTR [rbp+rdi*1-0x20],ymm2
  22b839:	c5 fc 11 5c 3d 00    	vmovups YMMWORD PTR [rbp+rdi*1+0x0],ymm3
    for (source) |s, i|
  22b83f:	48 83 ef 80          	sub    rdi,0xffffffffffffff80
  22b843:	48 83 c6 01          	add    rsi,0x1
  22b847:	75 c7                	jne    22b810 <join.199+0x2d0>
  22b849:	49 39 d0             	cmp    r8,rdx
  22b84c:	0f 85 99 fd ff ff    	jne    22b5eb <join.199+0xab>
        if (buf[buf_index - 1] != sep) {
  22b852:	42 80 7c 05 ff 2f    	cmp    BYTE PTR [rbp+r8*1-0x1],0x2f
  22b858:	74 0a                	je     22b864 <join.199+0x324>
            buf[buf_index] = sep;
  22b85a:	42 c6 44 05 00 2f    	mov    BYTE PTR [rbp+r8*1+0x0],0x2f
            buf_index += 1;
  22b860:	49 83 c0 01          	add    r8,0x1
        const arg = ([]const u8)(strings[string_i]);
  22b864:	4d 8b 74 24 08       	mov    r14,QWORD PTR [r12+0x8]
        copy(u8, buf[buf_index..], arg);
  22b869:	4c 89 e8             	mov    rax,r13
  22b86c:	4c 29 c0             	sub    rax,r8
    assert(dest.len >= source.len);
  22b86f:	4c 39 f0             	cmp    rax,r14
  22b872:	0f 82 27 03 00 00    	jb     22bb9f <join.199+0x65f>
    for (source) |s, i|
  22b878:	4d 85 f6             	test   r14,r14
  22b87b:	0f 84 84 02 00 00    	je     22bb05 <join.199+0x5c5>
  22b881:	49 8b 0c 24          	mov    rcx,QWORD PTR [r12]
  22b885:	4d 8d 0c 28          	lea    r9,[r8+rbp*1]
  22b889:	49 81 fe 80 00 00 00 	cmp    r14,0x80
  22b890:	72 1d                	jb     22b8af <join.199+0x36f>
  22b892:	4a 8d 04 31          	lea    rax,[rcx+r14*1]
  22b896:	49 39 c1             	cmp    r9,rax
  22b899:	0f 83 b5 00 00 00    	jae    22b954 <join.199+0x414>
  22b89f:	4b 8d 04 30          	lea    rax,[r8+r14*1]
  22b8a3:	48 01 e8             	add    rax,rbp
  22b8a6:	48 39 c1             	cmp    rcx,rax
  22b8a9:	0f 83 a5 00 00 00    	jae    22b954 <join.199+0x414>
  22b8af:	31 d2                	xor    edx,edx
  22b8b1:	49 8d 46 ff          	lea    rax,[r14-0x1]
  22b8b5:	48 29 d0             	sub    rax,rdx
  22b8b8:	4c 89 f6             	mov    rsi,r14
  22b8bb:	48 83 e6 07          	and    rsi,0x7
  22b8bf:	74 21                	je     22b8e2 <join.199+0x3a2>
  22b8c1:	48 f7 de             	neg    rsi
  22b8c4:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  22b8cb:	00 00 00 00 00 
  22b8d0:	0f b6 1c 11          	movzx  ebx,BYTE PTR [rcx+rdx*1]
        dest[i] = s;
  22b8d4:	41 88 1c 11          	mov    BYTE PTR [r9+rdx*1],bl
    for (source) |s, i|
  22b8d8:	48 83 c2 01          	add    rdx,0x1
  22b8dc:	48 83 c6 01          	add    rsi,0x1
  22b8e0:	75 ee                	jne    22b8d0 <join.199+0x390>
  22b8e2:	48 83 f8 07          	cmp    rax,0x7
  22b8e6:	0f 82 19 02 00 00    	jb     22bb05 <join.199+0x5c5>
  22b8ec:	49 8d 04 28          	lea    rax,[r8+rbp*1]
  22b8f0:	48 83 c0 07          	add    rax,0x7
  22b8f4:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  22b8fb:	00 00 00 00 00 
  22b900:	0f b6 1c 11          	movzx  ebx,BYTE PTR [rcx+rdx*1]
        dest[i] = s;
  22b904:	88 5c 10 f9          	mov    BYTE PTR [rax+rdx*1-0x7],bl
    for (source) |s, i|
  22b908:	0f b6 5c 11 01       	movzx  ebx,BYTE PTR [rcx+rdx*1+0x1]
        dest[i] = s;
  22b90d:	88 5c 10 fa          	mov    BYTE PTR [rax+rdx*1-0x6],bl
    for (source) |s, i|
  22b911:	0f b6 5c 11 02       	movzx  ebx,BYTE PTR [rcx+rdx*1+0x2]
        dest[i] = s;
  22b916:	88 5c 10 fb          	mov    BYTE PTR [rax+rdx*1-0x5],bl
    for (source) |s, i|
  22b91a:	0f b6 5c 11 03       	movzx  ebx,BYTE PTR [rcx+rdx*1+0x3]
        dest[i] = s;
  22b91f:	88 5c 10 fc          	mov    BYTE PTR [rax+rdx*1-0x4],bl
    for (source) |s, i|
  22b923:	0f b6 5c 11 04       	movzx  ebx,BYTE PTR [rcx+rdx*1+0x4]
        dest[i] = s;
  22b928:	88 5c 10 fd          	mov    BYTE PTR [rax+rdx*1-0x3],bl
    for (source) |s, i|
  22b92c:	0f b6 5c 11 05       	movzx  ebx,BYTE PTR [rcx+rdx*1+0x5]
        dest[i] = s;
  22b931:	88 5c 10 fe          	mov    BYTE PTR [rax+rdx*1-0x2],bl
    for (source) |s, i|
  22b935:	0f b6 5c 11 06       	movzx  ebx,BYTE PTR [rcx+rdx*1+0x6]
        dest[i] = s;
  22b93a:	88 5c 10 ff          	mov    BYTE PTR [rax+rdx*1-0x1],bl
    for (source) |s, i|
  22b93e:	0f b6 5c 11 07       	movzx  ebx,BYTE PTR [rcx+rdx*1+0x7]
        dest[i] = s;
  22b943:	88 1c 10             	mov    BYTE PTR [rax+rdx*1],bl
    for (source) |s, i|
  22b946:	48 83 c2 08          	add    rdx,0x8
  22b94a:	49 39 d6             	cmp    r14,rdx
  22b94d:	75 b1                	jne    22b900 <join.199+0x3c0>
  22b94f:	e9 b1 01 00 00       	jmp    22bb05 <join.199+0x5c5>
  22b954:	4c 89 f2             	mov    rdx,r14
  22b957:	48 83 e2 80          	and    rdx,0xffffffffffffff80
  22b95b:	48 8d 72 80          	lea    rsi,[rdx-0x80]
  22b95f:	48 89 f0             	mov    rax,rsi
  22b962:	48 c1 e8 07          	shr    rax,0x7
  22b966:	8d 78 01             	lea    edi,[rax+0x1]
  22b969:	83 e7 03             	and    edi,0x3
  22b96c:	48 81 fe 80 01 00 00 	cmp    rsi,0x180
  22b973:	73 10                	jae    22b985 <join.199+0x445>
  22b975:	31 c0                	xor    eax,eax
  22b977:	48 85 ff             	test   rdi,rdi
  22b97a:	0f 85 38 01 00 00    	jne    22bab8 <join.199+0x578>
  22b980:	e9 77 01 00 00       	jmp    22bafc <join.199+0x5bc>
  22b985:	49 8d 1c 28          	lea    rbx,[r8+rbp*1]
  22b989:	48 81 c3 e0 01 00 00 	add    rbx,0x1e0
  22b990:	48 8d 77 ff          	lea    rsi,[rdi-0x1]
  22b994:	48 29 c6             	sub    rsi,rax
  22b997:	31 c0                	xor    eax,eax
  22b999:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  22b9a0:	c5 fc 10 04 01       	vmovups ymm0,YMMWORD PTR [rcx+rax*1]
  22b9a5:	c5 fc 10 4c 01 20    	vmovups ymm1,YMMWORD PTR [rcx+rax*1+0x20]
  22b9ab:	c5 fc 10 54 01 40    	vmovups ymm2,YMMWORD PTR [rcx+rax*1+0x40]
  22b9b1:	c5 fc 10 5c 01 60    	vmovups ymm3,YMMWORD PTR [rcx+rax*1+0x60]
        dest[i] = s;
  22b9b7:	c5 fc 11 84 03 20 fe 	vmovups YMMWORD PTR [rbx+rax*1-0x1e0],ymm0
  22b9be:	ff ff 
  22b9c0:	c5 fc 11 8c 03 40 fe 	vmovups YMMWORD PTR [rbx+rax*1-0x1c0],ymm1
  22b9c7:	ff ff 
  22b9c9:	c5 fc 11 94 03 60 fe 	vmovups YMMWORD PTR [rbx+rax*1-0x1a0],ymm2
  22b9d0:	ff ff 
  22b9d2:	c5 fc 11 9c 03 80 fe 	vmovups YMMWORD PTR [rbx+rax*1-0x180],ymm3
  22b9d9:	ff ff 
    for (source) |s, i|
  22b9db:	c5 fc 10 84 01 80 00 	vmovups ymm0,YMMWORD PTR [rcx+rax*1+0x80]
  22b9e2:	00 00 
  22b9e4:	c5 fc 10 8c 01 a0 00 	vmovups ymm1,YMMWORD PTR [rcx+rax*1+0xa0]
  22b9eb:	00 00 
  22b9ed:	c5 fc 10 94 01 c0 00 	vmovups ymm2,YMMWORD PTR [rcx+rax*1+0xc0]
  22b9f4:	00 00 
  22b9f6:	c5 fc 10 9c 01 e0 00 	vmovups ymm3,YMMWORD PTR [rcx+rax*1+0xe0]
  22b9fd:	00 00 
        dest[i] = s;
  22b9ff:	c5 fc 11 84 03 a0 fe 	vmovups YMMWORD PTR [rbx+rax*1-0x160],ymm0
  22ba06:	ff ff 
  22ba08:	c5 fc 11 8c 03 c0 fe 	vmovups YMMWORD PTR [rbx+rax*1-0x140],ymm1
  22ba0f:	ff ff 
  22ba11:	c5 fc 11 94 03 e0 fe 	vmovups YMMWORD PTR [rbx+rax*1-0x120],ymm2
  22ba18:	ff ff 
  22ba1a:	c5 fc 11 9c 03 00 ff 	vmovups YMMWORD PTR [rbx+rax*1-0x100],ymm3
  22ba21:	ff ff 
    for (source) |s, i|
  22ba23:	c5 fc 10 84 01 00 01 	vmovups ymm0,YMMWORD PTR [rcx+rax*1+0x100]
  22ba2a:	00 00 
  22ba2c:	c5 fc 10 8c 01 20 01 	vmovups ymm1,YMMWORD PTR [rcx+rax*1+0x120]
  22ba33:	00 00 
  22ba35:	c5 fc 10 94 01 40 01 	vmovups ymm2,YMMWORD PTR [rcx+rax*1+0x140]
  22ba3c:	00 00 
  22ba3e:	c5 fc 10 9c 01 60 01 	vmovups ymm3,YMMWORD PTR [rcx+rax*1+0x160]
  22ba45:	00 00 
        dest[i] = s;
  22ba47:	c5 fc 11 84 03 20 ff 	vmovups YMMWORD PTR [rbx+rax*1-0xe0],ymm0
  22ba4e:	ff ff 
  22ba50:	c5 fc 11 8c 03 40 ff 	vmovups YMMWORD PTR [rbx+rax*1-0xc0],ymm1
  22ba57:	ff ff 
  22ba59:	c5 fc 11 94 03 60 ff 	vmovups YMMWORD PTR [rbx+rax*1-0xa0],ymm2
  22ba60:	ff ff 
  22ba62:	c5 fc 11 5c 03 80    	vmovups YMMWORD PTR [rbx+rax*1-0x80],ymm3
    for (source) |s, i|
  22ba68:	c5 fc 10 84 01 80 01 	vmovups ymm0,YMMWORD PTR [rcx+rax*1+0x180]
  22ba6f:	00 00 
  22ba71:	c5 fc 10 8c 01 a0 01 	vmovups ymm1,YMMWORD PTR [rcx+rax*1+0x1a0]
  22ba78:	00 00 
  22ba7a:	c5 fc 10 94 01 c0 01 	vmovups ymm2,YMMWORD PTR [rcx+rax*1+0x1c0]
  22ba81:	00 00 
  22ba83:	c5 fc 10 9c 01 e0 01 	vmovups ymm3,YMMWORD PTR [rcx+rax*1+0x1e0]
  22ba8a:	00 00 
        dest[i] = s;
  22ba8c:	c5 fc 11 44 03 a0    	vmovups YMMWORD PTR [rbx+rax*1-0x60],ymm0
  22ba92:	c5 fc 11 4c 03 c0    	vmovups YMMWORD PTR [rbx+rax*1-0x40],ymm1
  22ba98:	c5 fc 11 54 03 e0    	vmovups YMMWORD PTR [rbx+rax*1-0x20],ymm2
  22ba9e:	c5 fc 11 1c 03       	vmovups YMMWORD PTR [rbx+rax*1],ymm3
    for (source) |s, i|
  22baa3:	48 05 00 02 00 00    	add    rax,0x200
  22baa9:	48 83 c6 04          	add    rsi,0x4
  22baad:	0f 85 ed fe ff ff    	jne    22b9a0 <join.199+0x460>
  22bab3:	48 85 ff             	test   rdi,rdi
  22bab6:	74 44                	je     22bafc <join.199+0x5bc>
  22bab8:	48 83 c0 60          	add    rax,0x60
  22babc:	48 f7 df             	neg    rdi
  22babf:	90                   	nop
  22bac0:	c5 fc 10 44 01 a0    	vmovups ymm0,YMMWORD PTR [rcx+rax*1-0x60]
  22bac6:	c5 fc 10 4c 01 c0    	vmovups ymm1,YMMWORD PTR [rcx+rax*1-0x40]
  22bacc:	c5 fc 10 54 01 e0    	vmovups ymm2,YMMWORD PTR [rcx+rax*1-0x20]
  22bad2:	c5 fc 10 1c 01       	vmovups ymm3,YMMWORD PTR [rcx+rax*1]
        dest[i] = s;
  22bad7:	c4 c1 7c 11 44 01 a0 	vmovups YMMWORD PTR [r9+rax*1-0x60],ymm0
  22bade:	c4 c1 7c 11 4c 01 c0 	vmovups YMMWORD PTR [r9+rax*1-0x40],ymm1
  22bae5:	c4 c1 7c 11 54 01 e0 	vmovups YMMWORD PTR [r9+rax*1-0x20],ymm2
  22baec:	c4 c1 7c 11 1c 01    	vmovups YMMWORD PTR [r9+rax*1],ymm3
    for (source) |s, i|
  22baf2:	48 83 e8 80          	sub    rax,0xffffffffffffff80
  22baf6:	48 83 c7 01          	add    rdi,0x1
  22bafa:	75 c4                	jne    22bac0 <join.199+0x580>
  22bafc:	49 39 d6             	cmp    r14,rdx
  22baff:	0f 85 ac fd ff ff    	jne    22b8b1 <join.199+0x371>
        if (n == 0) {
  22bb05:	4d 01 c6             	add    r14,r8
  22bb08:	74 40                	je     22bb4a <join.199+0x60a>
        assert(n <= old_mem.len);
  22bb0a:	4d 39 f5             	cmp    r13,r14
  22bb0d:	0f 82 8c 00 00 00    	jb     22bb9f <join.199+0x65f>
        const byte_slice = self.reallocFn(self, @sliceToBytes(old_mem), byte_count, alignment) catch unreachable;
  22bb13:	49 8b 42 08          	mov    rax,QWORD PTR [r10+0x8]
  22bb17:	48 89 6c 24 20       	mov    QWORD PTR [rsp+0x20],rbp
  22bb1c:	4c 89 6c 24 28       	mov    QWORD PTR [rsp+0x28],r13
  22bb21:	48 8d 7c 24 08       	lea    rdi,[rsp+0x8]
  22bb26:	48 8d 54 24 20       	lea    rdx,[rsp+0x20]
  22bb2b:	41 b8 01 00 00 00    	mov    r8d,0x1
  22bb31:	4c 89 d6             	mov    rsi,r10
  22bb34:	4c 89 f1             	mov    rcx,r14
  22bb37:	c5 f8 77             	vzeroupper 
  22bb3a:	ff d0                	call   rax
        assert(byte_slice.len == byte_count);
  22bb3c:	4c 39 74 24 18       	cmp    QWORD PTR [rsp+0x18],r14
  22bb41:	75 5c                	jne    22bb9f <join.199+0x65f>
        const byte_slice = self.reallocFn(self, @sliceToBytes(old_mem), byte_count, alignment) catch unreachable;
  22bb43:	48 8b 6c 24 10       	mov    rbp,QWORD PTR [rsp+0x10]
  22bb48:	eb 23                	jmp    22bb6d <join.199+0x62d>
        if (bytes.len == 0) return;
  22bb4a:	4d 85 ed             	test   r13,r13
  22bb4d:	74 1b                	je     22bb6a <join.199+0x62a>
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  22bb4f:	49 8b 42 10          	mov    rax,QWORD PTR [r10+0x10]
  22bb53:	48 89 6c 24 30       	mov    QWORD PTR [rsp+0x30],rbp
  22bb58:	4c 89 6c 24 38       	mov    QWORD PTR [rsp+0x38],r13
  22bb5d:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
  22bb62:	4c 89 d7             	mov    rdi,r10
  22bb65:	c5 f8 77             	vzeroupper 
  22bb68:	ff d0                	call   rax
  22bb6a:	45 31 f6             	xor    r14d,r14d
    return allocator.shrink(u8, buf, buf_index);
  22bb6d:	66 41 c7 07 00 00    	mov    WORD PTR [r15],0x0
  22bb73:	0f b7 44 24 06       	movzx  eax,WORD PTR [rsp+0x6]
  22bb78:	66 41 89 47 06       	mov    WORD PTR [r15+0x6],ax
  22bb7d:	8b 44 24 02          	mov    eax,DWORD PTR [rsp+0x2]
  22bb81:	41 89 47 02          	mov    DWORD PTR [r15+0x2],eax
  22bb85:	49 89 6f 08          	mov    QWORD PTR [r15+0x8],rbp
  22bb89:	4d 89 77 10          	mov    QWORD PTR [r15+0x10],r14
  22bb8d:	48 83 c4 58          	add    rsp,0x58
  22bb91:	5b                   	pop    rbx
  22bb92:	41 5c                	pop    r12
  22bb94:	41 5d                	pop    r13
  22bb96:	41 5e                	pop    r14
  22bb98:	41 5f                	pop    r15
  22bb9a:	5d                   	pop    rbp
  22bb9b:	c5 f8 77             	vzeroupper 
  22bb9e:	c3                   	ret    
            @panic("assertion failure");
  22bb9f:	48 8d 3d 62 31 02 00 	lea    rdi,[rip+0x23162]        # 24ed08 <__unnamed_2>
  22bba6:	c5 f8 77             	vzeroupper 
  22bba9:	e8 72 64 fe ff       	call   212020 <panic>
  22bbae:	66 90                	xchg   ax,ax

000000000022bbb0 <DirectAllocator_alloc>:
    fn alloc(allocator: *Allocator, n: usize, alignment: u29) ![]u8 {
  22bbb0:	41 57                	push   r15
  22bbb2:	41 56                	push   r14
  22bbb4:	41 55                	push   r13
  22bbb6:	41 54                	push   r12
  22bbb8:	53                   	push   rbx
  22bbb9:	48 83 ec 10          	sub    rsp,0x10
  22bbbd:	41 89 cc             	mov    r12d,ecx
  22bbc0:	49 89 d6             	mov    r14,rdx
  22bbc3:	49 89 ff             	mov    r15,rdi
  22bbc6:	45 89 e5             	mov    r13d,r12d
  22bbc9:	41 81 e5 ff ff ff 1f 	and    r13d,0x1fffffff
                const alloc_size = if (alignment <= os.page_size) n else n + alignment;
  22bbd0:	31 c0                	xor    eax,eax
  22bbd2:	41 81 fd 01 10 00 00 	cmp    r13d,0x1001
  22bbd9:	4c 89 eb             	mov    rbx,r13
  22bbdc:	48 0f 42 d8          	cmovb  rbx,rax
  22bbe0:	4a 8d 34 33          	lea    rsi,[rbx+r14*1]
    arg3: usize,
    arg4: usize,
    arg5: usize,
    arg6: usize,
) usize {
    return asm volatile ("syscall"
  22bbe4:	b8 09 00 00 00       	mov    eax,0x9
  22bbe9:	bf 00 00 00 00       	mov    edi,0x0
  22bbee:	ba 03 00 00 00       	mov    edx,0x3
  22bbf3:	41 ba 22 00 00 00    	mov    r10d,0x22
  22bbf9:	49 c7 c0 ff ff ff ff 	mov    r8,0xffffffffffffffff
  22bc00:	45 31 c9             	xor    r9d,r9d
  22bc03:	0f 05                	syscall 
  22bc05:	48 89 c1             	mov    rcx,rax
                if (addr == p.MAP_FAILED) return error.OutOfMemory;
  22bc08:	48 83 f9 ff          	cmp    rcx,0xffffffffffffffff
  22bc0c:	74 55                	je     22bc63 <DirectAllocator_alloc+0xb3>
                if (alloc_size == n) return @intToPtr([*]u8, addr)[0..n];
  22bc0e:	48 85 db             	test   rbx,rbx
  22bc11:	74 6a                	je     22bc7d <DirectAllocator_alloc+0xcd>
                const aligned_addr = (addr & ~usize(alignment - 1)) + alignment;
  22bc13:	41 81 c4 ff ff ff 1f 	add    r12d,0x1fffffff
  22bc1a:	41 f7 d4             	not    r12d
  22bc1d:	49 81 cc 00 00 00 e0 	or     r12,0xffffffffe0000000
  22bc24:	49 21 cc             	and    r12,rcx
  22bc27:	4d 01 ec             	add    r12,r13
                const unused_len = aligned_addr - 1 - unused_start;
  22bc2a:	48 89 ce             	mov    rsi,rcx
  22bc2d:	48 f7 d6             	not    rsi
  22bc30:	4c 01 e6             	add    rsi,r12
    return asm volatile ("syscall"
  22bc33:	b8 0b 00 00 00       	mov    eax,0xb
  22bc38:	48 89 cf             	mov    rdi,rcx
  22bc3b:	0f 05                	syscall 
  22bc3d:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
    if (!ok) {
  22bc43:	73 69                	jae    22bcae <DirectAllocator_alloc+0xfe>
                return @intToPtr([*]u8, aligned_addr)[0..n];
  22bc45:	66 41 c7 07 00 00    	mov    WORD PTR [r15],0x0
  22bc4b:	0f b7 44 24 08       	movzx  eax,WORD PTR [rsp+0x8]
  22bc50:	66 41 89 47 06       	mov    WORD PTR [r15+0x6],ax
  22bc55:	8b 44 24 04          	mov    eax,DWORD PTR [rsp+0x4]
  22bc59:	41 89 47 02          	mov    DWORD PTR [r15+0x2],eax
  22bc5d:	4d 89 67 08          	mov    QWORD PTR [r15+0x8],r12
  22bc61:	eb 36                	jmp    22bc99 <DirectAllocator_alloc+0xe9>
                if (addr == p.MAP_FAILED) return error.OutOfMemory;
  22bc63:	48 8b 05 be cf fd ff 	mov    rax,QWORD PTR [rip+0xfffffffffffdcfbe]        # 208c28 <__unnamed_1+0x10>
  22bc6a:	49 89 47 10          	mov    QWORD PTR [r15+0x10],rax
  22bc6e:	c5 f8 10 05 a2 cf fd 	vmovups xmm0,XMMWORD PTR [rip+0xfffffffffffdcfa2]        # 208c18 <__unnamed_1>
  22bc75:	ff 
  22bc76:	c4 c1 78 11 07       	vmovups XMMWORD PTR [r15],xmm0
  22bc7b:	eb 20                	jmp    22bc9d <DirectAllocator_alloc+0xed>
                if (alloc_size == n) return @intToPtr([*]u8, addr)[0..n];
  22bc7d:	66 41 c7 07 00 00    	mov    WORD PTR [r15],0x0
  22bc83:	0f b7 44 24 0e       	movzx  eax,WORD PTR [rsp+0xe]
  22bc88:	66 41 89 47 06       	mov    WORD PTR [r15+0x6],ax
  22bc8d:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  22bc91:	41 89 47 02          	mov    DWORD PTR [r15+0x2],eax
  22bc95:	49 89 4f 08          	mov    QWORD PTR [r15+0x8],rcx
  22bc99:	4d 89 77 10          	mov    QWORD PTR [r15+0x10],r14
  22bc9d:	4c 89 f8             	mov    rax,r15
  22bca0:	48 83 c4 10          	add    rsp,0x10
  22bca4:	5b                   	pop    rbx
  22bca5:	41 5c                	pop    r12
  22bca7:	41 5d                	pop    r13
  22bca9:	41 5e                	pop    r14
  22bcab:	41 5f                	pop    r15
  22bcad:	c3                   	ret    
            @panic("assertion failure");
  22bcae:	48 8d 3d 53 30 02 00 	lea    rdi,[rip+0x23053]        # 24ed08 <__unnamed_2>
  22bcb5:	e8 66 63 fe ff       	call   212020 <panic>
  22bcba:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

000000000022bcc0 <DirectAllocator_realloc>:
    fn realloc(allocator: *Allocator, old_mem: []u8, new_size: usize, alignment: u29) ![]u8 {
  22bcc0:	55                   	push   rbp
  22bcc1:	41 57                	push   r15
  22bcc3:	41 56                	push   r14
  22bcc5:	41 55                	push   r13
  22bcc7:	41 54                	push   r12
  22bcc9:	53                   	push   rbx
  22bcca:	48 83 ec 28          	sub    rsp,0x28
  22bcce:	45 89 c4             	mov    r12d,r8d
  22bcd1:	48 89 cb             	mov    rbx,rcx
  22bcd4:	49 89 d6             	mov    r14,rdx
  22bcd7:	49 89 ff             	mov    r15,rdi
                if (new_size <= old_mem.len) {
  22bcda:	49 8b 76 08          	mov    rsi,QWORD PTR [r14+0x8]
  22bcde:	48 39 de             	cmp    rsi,rbx
  22bce1:	0f 83 c7 00 00 00    	jae    22bdae <DirectAllocator_realloc+0xee>
                const alloc_size = if (alignment <= os.page_size) n else n + alignment;
  22bce7:	45 89 e5             	mov    r13d,r12d
  22bcea:	41 81 e5 ff ff ff 1f 	and    r13d,0x1fffffff
  22bcf1:	31 c0                	xor    eax,eax
  22bcf3:	41 81 fd 01 10 00 00 	cmp    r13d,0x1001
  22bcfa:	4c 89 ed             	mov    rbp,r13
  22bcfd:	48 0f 42 e8          	cmovb  rbp,rax
  22bd01:	48 8d 74 1d 00       	lea    rsi,[rbp+rbx*1+0x0]
    return asm volatile ("syscall"
  22bd06:	b8 09 00 00 00       	mov    eax,0x9
  22bd0b:	bf 00 00 00 00       	mov    edi,0x0
  22bd10:	ba 03 00 00 00       	mov    edx,0x3
  22bd15:	41 ba 22 00 00 00    	mov    r10d,0x22
  22bd1b:	49 c7 c0 ff ff ff ff 	mov    r8,0xffffffffffffffff
  22bd22:	45 31 c9             	xor    r9d,r9d
  22bd25:	0f 05                	syscall 
  22bd27:	48 89 c1             	mov    rcx,rax
                if (addr == p.MAP_FAILED) return error.OutOfMemory;
  22bd2a:	48 83 f9 ff          	cmp    rcx,0xffffffffffffffff
  22bd2e:	0f 84 d2 00 00 00    	je     22be06 <DirectAllocator_realloc+0x146>
                if (alloc_size == n) return @intToPtr([*]u8, addr)[0..n];
  22bd34:	48 85 ed             	test   rbp,rbp
  22bd37:	74 39                	je     22bd72 <DirectAllocator_realloc+0xb2>
                const aligned_addr = (addr & ~usize(alignment - 1)) + alignment;
  22bd39:	41 81 c4 ff ff ff 1f 	add    r12d,0x1fffffff
  22bd40:	41 f7 d4             	not    r12d
  22bd43:	49 81 cc 00 00 00 e0 	or     r12,0xffffffffe0000000
  22bd4a:	49 21 cc             	and    r12,rcx
  22bd4d:	4d 01 ec             	add    r12,r13
                const unused_len = aligned_addr - 1 - unused_start;
  22bd50:	48 89 ce             	mov    rsi,rcx
  22bd53:	48 f7 d6             	not    rsi
  22bd56:	4c 01 e6             	add    rsi,r12
    return asm volatile ("syscall"
  22bd59:	b8 0b 00 00 00       	mov    eax,0xb
  22bd5e:	48 89 cf             	mov    rdi,rcx
  22bd61:	0f 05                	syscall 
  22bd63:	4c 89 e1             	mov    rcx,r12
  22bd66:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
    if (!ok) {
  22bd6c:	0f 83 74 01 00 00    	jae    22bee6 <DirectAllocator_realloc+0x226>
    assert(dest.len >= source.len);
  22bd72:	49 8b 76 08          	mov    rsi,QWORD PTR [r14+0x8]
  22bd76:	48 89 dd             	mov    rbp,rbx
  22bd79:	48 39 de             	cmp    rsi,rbx
  22bd7c:	0f 87 64 01 00 00    	ja     22bee6 <DirectAllocator_realloc+0x226>
    for (source) |s, i|
  22bd82:	48 85 f6             	test   rsi,rsi
  22bd85:	0f 84 29 01 00 00    	je     22beb4 <DirectAllocator_realloc+0x1f4>
  22bd8b:	48 8d 56 ff          	lea    rdx,[rsi-0x1]
  22bd8f:	89 f0                	mov    eax,esi
  22bd91:	83 e0 07             	and    eax,0x7
  22bd94:	48 83 fa 07          	cmp    rdx,0x7
  22bd98:	0f 83 88 00 00 00    	jae    22be26 <DirectAllocator_realloc+0x166>
  22bd9e:	31 d2                	xor    edx,edx
  22bda0:	48 85 c0             	test   rax,rax
  22bda3:	0f 85 f3 00 00 00    	jne    22be9c <DirectAllocator_realloc+0x1dc>
  22bda9:	e9 06 01 00 00       	jmp    22beb4 <DirectAllocator_realloc+0x1f4>
                    const base_addr = @ptrToInt(old_mem.ptr);
  22bdae:	49 8b 06             	mov    rax,QWORD PTR [r14]
                    const old_addr_end = base_addr + old_mem.len;
  22bdb1:	48 01 c6             	add    rsi,rax
                    const new_addr_end = base_addr + new_size;
  22bdb4:	48 8d 0c 18          	lea    rcx,[rax+rbx*1]
                    const rem = @rem(new_addr_end, os.page_size);
  22bdb8:	89 ca                	mov    edx,ecx
  22bdba:	81 e2 ff 0f 00 00    	and    edx,0xfff
                    const new_addr_end_rounded = new_addr_end + if (rem == 0) 0 else (os.page_size - rem);
  22bdc0:	bf 00 10 00 00       	mov    edi,0x1000
  22bdc5:	48 29 d7             	sub    rdi,rdx
  22bdc8:	48 85 d2             	test   rdx,rdx
  22bdcb:	48 0f 44 fa          	cmove  rdi,rdx
  22bdcf:	48 01 cf             	add    rdi,rcx
                    if (old_addr_end > new_addr_end_rounded) {
  22bdd2:	48 29 fe             	sub    rsi,rdi
  22bdd5:	76 0a                	jbe    22bde1 <DirectAllocator_realloc+0x121>
  22bdd7:	b8 0b 00 00 00       	mov    eax,0xb
  22bddc:	0f 05                	syscall 
                    return old_mem[0..new_size];
  22bdde:	49 8b 06             	mov    rax,QWORD PTR [r14]
  22bde1:	66 41 c7 07 00 00    	mov    WORD PTR [r15],0x0
  22bde7:	0f b7 4c 24 10       	movzx  ecx,WORD PTR [rsp+0x10]
  22bdec:	66 41 89 4f 06       	mov    WORD PTR [r15+0x6],cx
  22bdf1:	8b 4c 24 0c          	mov    ecx,DWORD PTR [rsp+0xc]
  22bdf5:	41 89 4f 02          	mov    DWORD PTR [r15+0x2],ecx
  22bdf9:	49 89 47 08          	mov    QWORD PTR [r15+0x8],rax
  22bdfd:	49 89 5f 10          	mov    QWORD PTR [r15+0x10],rbx
  22be01:	e9 ce 00 00 00       	jmp    22bed4 <DirectAllocator_realloc+0x214>
                const result = try alloc(allocator, new_size, alignment);
  22be06:	66 41 c7 07 01 00    	mov    WORD PTR [r15],0x1
  22be0c:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
  22be11:	49 89 47 10          	mov    QWORD PTR [r15+0x10],rax
  22be15:	c5 f8 10 44 24 12    	vmovups xmm0,XMMWORD PTR [rsp+0x12]
  22be1b:	c4 c1 78 11 47 02    	vmovups XMMWORD PTR [r15+0x2],xmm0
  22be21:	e9 ae 00 00 00       	jmp    22bed4 <DirectAllocator_realloc+0x214>
  22be26:	48 29 c6             	sub    rsi,rax
  22be29:	31 d2                	xor    edx,edx
  22be2b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  22be30:	49 8b 3e             	mov    rdi,QWORD PTR [r14]
  22be33:	0f b6 1c 17          	movzx  ebx,BYTE PTR [rdi+rdx*1]
        dest[i] = s;
  22be37:	88 1c 11             	mov    BYTE PTR [rcx+rdx*1],bl
    for (source) |s, i|
  22be3a:	49 8b 3e             	mov    rdi,QWORD PTR [r14]
  22be3d:	0f b6 5c 17 01       	movzx  ebx,BYTE PTR [rdi+rdx*1+0x1]
        dest[i] = s;
  22be42:	88 5c 11 01          	mov    BYTE PTR [rcx+rdx*1+0x1],bl
    for (source) |s, i|
  22be46:	49 8b 3e             	mov    rdi,QWORD PTR [r14]
  22be49:	0f b6 5c 17 02       	movzx  ebx,BYTE PTR [rdi+rdx*1+0x2]
        dest[i] = s;
  22be4e:	88 5c 11 02          	mov    BYTE PTR [rcx+rdx*1+0x2],bl
    for (source) |s, i|
  22be52:	49 8b 3e             	mov    rdi,QWORD PTR [r14]
  22be55:	0f b6 5c 17 03       	movzx  ebx,BYTE PTR [rdi+rdx*1+0x3]
        dest[i] = s;
  22be5a:	88 5c 11 03          	mov    BYTE PTR [rcx+rdx*1+0x3],bl
    for (source) |s, i|
  22be5e:	49 8b 3e             	mov    rdi,QWORD PTR [r14]
  22be61:	0f b6 5c 17 04       	movzx  ebx,BYTE PTR [rdi+rdx*1+0x4]
        dest[i] = s;
  22be66:	88 5c 11 04          	mov    BYTE PTR [rcx+rdx*1+0x4],bl
    for (source) |s, i|
  22be6a:	49 8b 3e             	mov    rdi,QWORD PTR [r14]
  22be6d:	0f b6 5c 17 05       	movzx  ebx,BYTE PTR [rdi+rdx*1+0x5]
        dest[i] = s;
  22be72:	88 5c 11 05          	mov    BYTE PTR [rcx+rdx*1+0x5],bl
    for (source) |s, i|
  22be76:	49 8b 3e             	mov    rdi,QWORD PTR [r14]
  22be79:	0f b6 5c 17 06       	movzx  ebx,BYTE PTR [rdi+rdx*1+0x6]
        dest[i] = s;
  22be7e:	88 5c 11 06          	mov    BYTE PTR [rcx+rdx*1+0x6],bl
    for (source) |s, i|
  22be82:	49 8b 3e             	mov    rdi,QWORD PTR [r14]
  22be85:	0f b6 5c 17 07       	movzx  ebx,BYTE PTR [rdi+rdx*1+0x7]
        dest[i] = s;
  22be8a:	88 5c 11 07          	mov    BYTE PTR [rcx+rdx*1+0x7],bl
    for (source) |s, i|
  22be8e:	48 83 c2 08          	add    rdx,0x8
  22be92:	48 39 d6             	cmp    rsi,rdx
  22be95:	75 99                	jne    22be30 <DirectAllocator_realloc+0x170>
  22be97:	48 85 c0             	test   rax,rax
  22be9a:	74 18                	je     22beb4 <DirectAllocator_realloc+0x1f4>
  22be9c:	48 f7 d8             	neg    rax
  22be9f:	90                   	nop
  22bea0:	49 8b 36             	mov    rsi,QWORD PTR [r14]
  22bea3:	0f b6 1c 16          	movzx  ebx,BYTE PTR [rsi+rdx*1]
        dest[i] = s;
  22bea7:	88 1c 11             	mov    BYTE PTR [rcx+rdx*1],bl
    for (source) |s, i|
  22beaa:	48 83 c2 01          	add    rdx,0x1
  22beae:	48 83 c0 01          	add    rax,0x1
  22beb2:	75 ec                	jne    22bea0 <DirectAllocator_realloc+0x1e0>
                return result;
  22beb4:	66 41 c7 07 00 00    	mov    WORD PTR [r15],0x0
  22beba:	0f b7 44 24 0a       	movzx  eax,WORD PTR [rsp+0xa]
  22bebf:	66 41 89 47 06       	mov    WORD PTR [r15+0x6],ax
  22bec4:	8b 44 24 06          	mov    eax,DWORD PTR [rsp+0x6]
  22bec8:	41 89 47 02          	mov    DWORD PTR [r15+0x2],eax
  22becc:	49 89 4f 08          	mov    QWORD PTR [r15+0x8],rcx
  22bed0:	49 89 6f 10          	mov    QWORD PTR [r15+0x10],rbp
  22bed4:	4c 89 f8             	mov    rax,r15
  22bed7:	48 83 c4 28          	add    rsp,0x28
  22bedb:	5b                   	pop    rbx
  22bedc:	41 5c                	pop    r12
  22bede:	41 5d                	pop    r13
  22bee0:	41 5e                	pop    r14
  22bee2:	41 5f                	pop    r15
  22bee4:	5d                   	pop    rbp
  22bee5:	c3                   	ret    
            @panic("assertion failure");
  22bee6:	48 8d 3d 1b 2e 02 00 	lea    rdi,[rip+0x22e1b]        # 24ed08 <__unnamed_2>
  22beed:	e8 2e 61 fe ff       	call   212020 <panic>
  22bef2:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  22bef9:	1f 84 00 00 00 00 00 

000000000022bf00 <DirectAllocator_free>:
                _ = os.posix.munmap(@ptrToInt(bytes.ptr), bytes.len);
  22bf00:	48 8b 3e             	mov    rdi,QWORD PTR [rsi]
  22bf03:	48 8b 76 08          	mov    rsi,QWORD PTR [rsi+0x8]
  22bf07:	b8 0b 00 00 00       	mov    eax,0xb
  22bf0c:	0f 05                	syscall 
    fn free(allocator: *Allocator, bytes: []u8) void {
  22bf0e:	c3                   	ret    
  22bf0f:	90                   	nop

000000000022bf10 <ArenaAllocator_alloc>:
    fn alloc(allocator: *Allocator, n: usize, alignment: u29) ![]u8 {
  22bf10:	55                   	push   rbp
  22bf11:	41 57                	push   r15
  22bf13:	41 56                	push   r14
  22bf15:	41 55                	push   r13
  22bf17:	41 54                	push   r12
  22bf19:	53                   	push   rbx
  22bf1a:	48 83 ec 58          	sub    rsp,0x58
  22bf1e:	89 cb                	mov    ebx,ecx
  22bf20:	49 89 d7             	mov    r15,rdx
  22bf23:	49 89 f4             	mov    r12,rsi
  22bf26:	49 89 fe             	mov    r14,rdi
        var cur_node = if (self.buffer_list.last) |last_node| last_node else try self.createNode(0, n + alignment);
  22bf29:	49 8b 44 24 28       	mov    rax,QWORD PTR [r12+0x28]
  22bf2e:	81 e3 ff ff ff 1f    	and    ebx,0x1fffffff
  22bf34:	4e 8d 2c 3b          	lea    r13,[rbx+r15*1]
  22bf38:	48 85 c0             	test   rax,rax
  22bf3b:	74 29                	je     22bf66 <ArenaAllocator_alloc+0x56>
            const cur_buf = cur_node.data[@sizeOf(BufNode)..];
  22bf3d:	48 8b 70 10          	mov    rsi,QWORD PTR [rax+0x10]
  22bf41:	48 8b 48 18          	mov    rcx,QWORD PTR [rax+0x18]
  22bf45:	48 83 c1 e0          	add    rcx,0xffffffffffffffe0
            const addr = @ptrToInt(cur_buf.ptr) + self.end_index;
  22bf49:	49 8b 7c 24 38       	mov    rdi,QWORD PTR [r12+0x38]
  22bf4e:	48 8d 04 37          	lea    rax,[rdi+rsi*1]
  22bf52:	48 83 c0 20          	add    rax,0x20
  22bf56:	48 89 c2             	mov    rdx,rax
  22bf59:	48 c1 ea 20          	shr    rdx,0x20
  22bf5d:	74 3f                	je     22bf9e <ArenaAllocator_alloc+0x8e>
  22bf5f:	31 d2                	xor    edx,edx
  22bf61:	48 f7 f3             	div    rbx
  22bf64:	eb 3c                	jmp    22bfa2 <ArenaAllocator_alloc+0x92>
  22bf66:	48 8d 7c 24 18       	lea    rdi,[rsp+0x18]
        var cur_node = if (self.buffer_list.last) |last_node| last_node else try self.createNode(0, n + alignment);
  22bf6b:	31 d2                	xor    edx,edx
  22bf6d:	4c 89 e6             	mov    rsi,r12
  22bf70:	4c 89 e9             	mov    rcx,r13
  22bf73:	e8 78 03 00 00       	call   22c2f0 <ArenaAllocator_createNode>
  22bf78:	0f b7 44 24 18       	movzx  eax,WORD PTR [rsp+0x18]
  22bf7d:	66 85 c0             	test   ax,ax
  22bf80:	0f 84 fe 00 00 00    	je     22c084 <ArenaAllocator_alloc+0x174>
  22bf86:	66 41 89 06          	mov    WORD PTR [r14],ax
  22bf8a:	48 8b 44 24 50       	mov    rax,QWORD PTR [rsp+0x50]
  22bf8f:	49 89 46 10          	mov    QWORD PTR [r14+0x10],rax
  22bf93:	c5 f8 10 44 24 42    	vmovups xmm0,XMMWORD PTR [rsp+0x42]
  22bf99:	e9 ce 00 00 00       	jmp    22c06c <ArenaAllocator_alloc+0x15c>
  22bf9e:	31 d2                	xor    edx,edx
  22bfa0:	f7 f3                	div    ebx
            const march_forward_bytes = if (rem == 0) 0 else (alignment - rem);
  22bfa2:	48 89 d8             	mov    rax,rbx
  22bfa5:	48 29 d0             	sub    rax,rdx
  22bfa8:	48 85 d2             	test   rdx,rdx
  22bfab:	48 0f 44 c2          	cmove  rax,rdx
            const adjusted_index = self.end_index + march_forward_bytes;
  22bfaf:	48 01 f8             	add    rax,rdi
            const new_end_index = adjusted_index + n;
  22bfb2:	4a 8d 14 38          	lea    rdx,[rax+r15*1]
            if (new_end_index > cur_buf.len) {
  22bfb6:	48 39 ca             	cmp    rdx,rcx
  22bfb9:	76 72                	jbe    22c02d <ArenaAllocator_alloc+0x11d>
  22bfbb:	48 8d 6c 24 08       	lea    rbp,[rsp+0x8]
                cur_node = try self.createNode(cur_buf.len, n + alignment);
  22bfc0:	48 89 ef             	mov    rdi,rbp
  22bfc3:	4c 89 e6             	mov    rsi,r12
  22bfc6:	48 89 ca             	mov    rdx,rcx
  22bfc9:	4c 89 e9             	mov    rcx,r13
  22bfcc:	e8 1f 03 00 00       	call   22c2f0 <ArenaAllocator_createNode>
  22bfd1:	0f b7 44 24 08       	movzx  eax,WORD PTR [rsp+0x8]
  22bfd6:	66 85 c0             	test   ax,ax
  22bfd9:	75 7e                	jne    22c059 <ArenaAllocator_alloc+0x149>
  22bfdb:	48 8b 44 24 10       	mov    rax,QWORD PTR [rsp+0x10]
            const cur_buf = cur_node.data[@sizeOf(BufNode)..];
  22bfe0:	48 8b 70 10          	mov    rsi,QWORD PTR [rax+0x10]
  22bfe4:	48 8b 48 18          	mov    rcx,QWORD PTR [rax+0x18]
  22bfe8:	48 83 c1 e0          	add    rcx,0xffffffffffffffe0
            const addr = @ptrToInt(cur_buf.ptr) + self.end_index;
  22bfec:	49 8b 7c 24 38       	mov    rdi,QWORD PTR [r12+0x38]
  22bff1:	48 8d 04 37          	lea    rax,[rdi+rsi*1]
  22bff5:	48 83 c0 20          	add    rax,0x20
  22bff9:	48 89 c2             	mov    rdx,rax
  22bffc:	48 c1 ea 20          	shr    rdx,0x20
  22c000:	74 0e                	je     22c010 <ArenaAllocator_alloc+0x100>
  22c002:	31 d2                	xor    edx,edx
  22c004:	48 f7 f3             	div    rbx
  22c007:	eb 0b                	jmp    22c014 <ArenaAllocator_alloc+0x104>
  22c009:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  22c010:	31 d2                	xor    edx,edx
  22c012:	f7 f3                	div    ebx
            const march_forward_bytes = if (rem == 0) 0 else (alignment - rem);
  22c014:	48 89 d8             	mov    rax,rbx
  22c017:	48 29 d0             	sub    rax,rdx
  22c01a:	48 85 d2             	test   rdx,rdx
  22c01d:	48 0f 44 c2          	cmove  rax,rdx
            const adjusted_index = self.end_index + march_forward_bytes;
  22c021:	48 01 f8             	add    rax,rdi
            const new_end_index = adjusted_index + n;
  22c024:	4a 8d 14 38          	lea    rdx,[rax+r15*1]
            if (new_end_index > cur_buf.len) {
  22c028:	48 39 ca             	cmp    rdx,rcx
  22c02b:	77 93                	ja     22bfc0 <ArenaAllocator_alloc+0xb0>
            self.end_index = new_end_index;
  22c02d:	49 89 54 24 38       	mov    QWORD PTR [r12+0x38],rdx
            return result;
  22c032:	66 41 c7 06 00 00    	mov    WORD PTR [r14],0x0
  22c038:	0f b7 4c 24 06       	movzx  ecx,WORD PTR [rsp+0x6]
  22c03d:	66 41 89 4e 06       	mov    WORD PTR [r14+0x6],cx
            const result = cur_buf[adjusted_index..new_end_index];
  22c042:	48 8d 44 06 20       	lea    rax,[rsi+rax*1+0x20]
            return result;
  22c047:	8b 4c 24 02          	mov    ecx,DWORD PTR [rsp+0x2]
  22c04b:	41 89 4e 02          	mov    DWORD PTR [r14+0x2],ecx
  22c04f:	49 89 46 08          	mov    QWORD PTR [r14+0x8],rax
  22c053:	4d 89 7e 10          	mov    QWORD PTR [r14+0x10],r15
  22c057:	eb 19                	jmp    22c072 <ArenaAllocator_alloc+0x162>
                cur_node = try self.createNode(cur_buf.len, n + alignment);
  22c059:	66 41 89 06          	mov    WORD PTR [r14],ax
  22c05d:	48 8b 44 24 3a       	mov    rax,QWORD PTR [rsp+0x3a]
  22c062:	49 89 46 10          	mov    QWORD PTR [r14+0x10],rax
  22c066:	c5 f8 10 44 24 2c    	vmovups xmm0,XMMWORD PTR [rsp+0x2c]
  22c06c:	c4 c1 78 11 46 02    	vmovups XMMWORD PTR [r14+0x2],xmm0
  22c072:	4c 89 f0             	mov    rax,r14
  22c075:	48 83 c4 58          	add    rsp,0x58
  22c079:	5b                   	pop    rbx
  22c07a:	41 5c                	pop    r12
  22c07c:	41 5d                	pop    r13
  22c07e:	41 5e                	pop    r14
  22c080:	41 5f                	pop    r15
  22c082:	5d                   	pop    rbp
  22c083:	c3                   	ret    
        var cur_node = if (self.buffer_list.last) |last_node| last_node else try self.createNode(0, n + alignment);
  22c084:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
  22c089:	e9 af fe ff ff       	jmp    22bf3d <ArenaAllocator_alloc+0x2d>
  22c08e:	66 90                	xchg   ax,ax

000000000022c090 <ArenaAllocator_realloc>:
    fn realloc(allocator: *Allocator, old_mem: []u8, new_size: usize, alignment: u29) ![]u8 {
  22c090:	55                   	push   rbp
  22c091:	41 57                	push   r15
  22c093:	41 56                	push   r14
  22c095:	41 55                	push   r13
  22c097:	41 54                	push   r12
  22c099:	53                   	push   rbx
  22c09a:	48 83 ec 58          	sub    rsp,0x58
  22c09e:	45 89 c5             	mov    r13d,r8d
  22c0a1:	49 89 cf             	mov    r15,rcx
  22c0a4:	48 89 d3             	mov    rbx,rdx
  22c0a7:	49 89 f4             	mov    r12,rsi
  22c0aa:	48 89 fd             	mov    rbp,rdi
        if (new_size <= old_mem.len) {
  22c0ad:	4c 39 7b 08          	cmp    QWORD PTR [rbx+0x8],r15
  22c0b1:	73 43                	jae    22c0f6 <ArenaAllocator_realloc+0x66>
        var cur_node = if (self.buffer_list.last) |last_node| last_node else try self.createNode(0, n + alignment);
  22c0b3:	49 8b 44 24 28       	mov    rax,QWORD PTR [r12+0x28]
  22c0b8:	41 81 e5 ff ff ff 1f 	and    r13d,0x1fffffff
  22c0bf:	4f 8d 34 2f          	lea    r14,[r15+r13*1]
  22c0c3:	48 85 c0             	test   rax,rax
  22c0c6:	74 54                	je     22c11c <ArenaAllocator_realloc+0x8c>
            const cur_buf = cur_node.data[@sizeOf(BufNode)..];
  22c0c8:	48 8b 70 10          	mov    rsi,QWORD PTR [rax+0x10]
  22c0cc:	48 8b 48 18          	mov    rcx,QWORD PTR [rax+0x18]
  22c0d0:	48 83 c1 e0          	add    rcx,0xffffffffffffffe0
            const addr = @ptrToInt(cur_buf.ptr) + self.end_index;
  22c0d4:	49 8b 7c 24 38       	mov    rdi,QWORD PTR [r12+0x38]
  22c0d9:	48 8d 04 37          	lea    rax,[rdi+rsi*1]
  22c0dd:	48 83 c0 20          	add    rax,0x20
  22c0e1:	48 89 c2             	mov    rdx,rax
  22c0e4:	48 c1 ea 20          	shr    rdx,0x20
  22c0e8:	48 89 6c 24 08       	mov    QWORD PTR [rsp+0x8],rbp
  22c0ed:	75 77                	jne    22c166 <ArenaAllocator_realloc+0xd6>
  22c0ef:	31 d2                	xor    edx,edx
  22c0f1:	41 f7 f5             	div    r13d
  22c0f4:	eb 75                	jmp    22c16b <ArenaAllocator_realloc+0xdb>
            return old_mem[0..new_size];
  22c0f6:	48 8b 03             	mov    rax,QWORD PTR [rbx]
  22c0f9:	66 c7 45 00 00 00    	mov    WORD PTR [rbp+0x0],0x0
  22c0ff:	0f b7 4c 24 1e       	movzx  ecx,WORD PTR [rsp+0x1e]
  22c104:	66 89 4d 06          	mov    WORD PTR [rbp+0x6],cx
  22c108:	8b 4c 24 1a          	mov    ecx,DWORD PTR [rsp+0x1a]
  22c10c:	89 4d 02             	mov    DWORD PTR [rbp+0x2],ecx
  22c10f:	48 89 45 08          	mov    QWORD PTR [rbp+0x8],rax
  22c113:	4c 89 7d 10          	mov    QWORD PTR [rbp+0x10],r15
  22c117:	e9 a2 00 00 00       	jmp    22c1be <ArenaAllocator_realloc+0x12e>
  22c11c:	48 8d 7c 24 30       	lea    rdi,[rsp+0x30]
        var cur_node = if (self.buffer_list.last) |last_node| last_node else try self.createNode(0, n + alignment);
  22c121:	31 d2                	xor    edx,edx
  22c123:	4c 89 e6             	mov    rsi,r12
  22c126:	4c 89 f1             	mov    rcx,r14
  22c129:	e8 c2 01 00 00       	call   22c2f0 <ArenaAllocator_createNode>
  22c12e:	0f b7 44 24 30       	movzx  eax,WORD PTR [rsp+0x30]
  22c133:	66 85 c0             	test   ax,ax
  22c136:	75 6e                	jne    22c1a6 <ArenaAllocator_realloc+0x116>
  22c138:	48 8b 44 24 38       	mov    rax,QWORD PTR [rsp+0x38]
  22c13d:	eb 89                	jmp    22c0c8 <ArenaAllocator_realloc+0x38>
                cur_node = try self.createNode(cur_buf.len, n + alignment);
  22c13f:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
            const cur_buf = cur_node.data[@sizeOf(BufNode)..];
  22c144:	48 8b 70 10          	mov    rsi,QWORD PTR [rax+0x10]
  22c148:	48 8b 48 18          	mov    rcx,QWORD PTR [rax+0x18]
  22c14c:	48 83 c1 e0          	add    rcx,0xffffffffffffffe0
            const addr = @ptrToInt(cur_buf.ptr) + self.end_index;
  22c150:	49 8b 7c 24 38       	mov    rdi,QWORD PTR [r12+0x38]
  22c155:	48 8d 04 37          	lea    rax,[rdi+rsi*1]
  22c159:	48 83 c0 20          	add    rax,0x20
  22c15d:	48 89 c2             	mov    rdx,rax
  22c160:	48 c1 ea 20          	shr    rdx,0x20
  22c164:	74 89                	je     22c0ef <ArenaAllocator_realloc+0x5f>
  22c166:	31 d2                	xor    edx,edx
  22c168:	49 f7 f5             	div    r13
            const march_forward_bytes = if (rem == 0) 0 else (alignment - rem);
  22c16b:	4c 89 ed             	mov    rbp,r13
  22c16e:	48 29 d5             	sub    rbp,rdx
  22c171:	48 85 d2             	test   rdx,rdx
  22c174:	48 0f 44 ea          	cmove  rbp,rdx
            const adjusted_index = self.end_index + march_forward_bytes;
  22c178:	48 01 fd             	add    rbp,rdi
            const new_end_index = adjusted_index + n;
  22c17b:	49 8d 04 2f          	lea    rax,[r15+rbp*1]
            if (new_end_index > cur_buf.len) {
  22c17f:	48 39 c8             	cmp    rax,rcx
  22c182:	76 42                	jbe    22c1c6 <ArenaAllocator_realloc+0x136>
                cur_node = try self.createNode(cur_buf.len, n + alignment);
  22c184:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  22c189:	4c 89 e6             	mov    rsi,r12
  22c18c:	48 89 ca             	mov    rdx,rcx
  22c18f:	4c 89 f1             	mov    rcx,r14
  22c192:	e8 59 01 00 00       	call   22c2f0 <ArenaAllocator_createNode>
  22c197:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  22c19c:	66 85 c0             	test   ax,ax
  22c19f:	74 9e                	je     22c13f <ArenaAllocator_realloc+0xaf>
  22c1a1:	48 8b 6c 24 08       	mov    rbp,QWORD PTR [rsp+0x8]
            const result = try alloc(allocator, new_size, alignment);
  22c1a6:	66 89 45 00          	mov    WORD PTR [rbp+0x0],ax
  22c1aa:	48 8b 44 24 50       	mov    rax,QWORD PTR [rsp+0x50]
  22c1af:	48 89 45 10          	mov    QWORD PTR [rbp+0x10],rax
  22c1b3:	c5 f8 10 44 24 42    	vmovups xmm0,XMMWORD PTR [rsp+0x42]
  22c1b9:	c5 f8 11 45 02       	vmovups XMMWORD PTR [rbp+0x2],xmm0
  22c1be:	48 89 e8             	mov    rax,rbp
  22c1c1:	e9 f1 00 00 00       	jmp    22c2b7 <ArenaAllocator_realloc+0x227>
            self.end_index = new_end_index;
  22c1c6:	49 89 44 24 38       	mov    QWORD PTR [r12+0x38],rax
    assert(dest.len >= source.len);
  22c1cb:	48 8b 7b 08          	mov    rdi,QWORD PTR [rbx+0x8]
  22c1cf:	4c 39 ff             	cmp    rdi,r15
    if (!ok) {
  22c1d2:	0f 87 ee 00 00 00    	ja     22c2c6 <ArenaAllocator_realloc+0x236>
  22c1d8:	4c 8d 04 2e          	lea    r8,[rsi+rbp*1]
  22c1dc:	49 83 c0 20          	add    r8,0x20
    for (source) |s, i|
  22c1e0:	48 85 ff             	test   rdi,rdi
  22c1e3:	0f 84 ac 00 00 00    	je     22c295 <ArenaAllocator_realloc+0x205>
  22c1e9:	48 8d 57 ff          	lea    rdx,[rdi-0x1]
  22c1ed:	89 f9                	mov    ecx,edi
  22c1ef:	83 e1 07             	and    ecx,0x7
  22c1f2:	48 83 fa 07          	cmp    rdx,0x7
  22c1f6:	73 0c                	jae    22c204 <ArenaAllocator_realloc+0x174>
  22c1f8:	31 d2                	xor    edx,edx
  22c1fa:	48 85 c9             	test   rcx,rcx
  22c1fd:	75 7e                	jne    22c27d <ArenaAllocator_realloc+0x1ed>
  22c1ff:	e9 91 00 00 00       	jmp    22c295 <ArenaAllocator_realloc+0x205>
  22c204:	48 29 cf             	sub    rdi,rcx
  22c207:	48 01 ee             	add    rsi,rbp
  22c20a:	48 83 c6 27          	add    rsi,0x27
  22c20e:	31 d2                	xor    edx,edx
  22c210:	48 8b 2b             	mov    rbp,QWORD PTR [rbx]
  22c213:	0f b6 44 15 00       	movzx  eax,BYTE PTR [rbp+rdx*1+0x0]
        dest[i] = s;
  22c218:	88 44 16 f9          	mov    BYTE PTR [rsi+rdx*1-0x7],al
    for (source) |s, i|
  22c21c:	48 8b 03             	mov    rax,QWORD PTR [rbx]
  22c21f:	0f b6 44 10 01       	movzx  eax,BYTE PTR [rax+rdx*1+0x1]
        dest[i] = s;
  22c224:	88 44 16 fa          	mov    BYTE PTR [rsi+rdx*1-0x6],al
    for (source) |s, i|
  22c228:	48 8b 03             	mov    rax,QWORD PTR [rbx]
  22c22b:	0f b6 44 10 02       	movzx  eax,BYTE PTR [rax+rdx*1+0x2]
        dest[i] = s;
  22c230:	88 44 16 fb          	mov    BYTE PTR [rsi+rdx*1-0x5],al
    for (source) |s, i|
  22c234:	48 8b 03             	mov    rax,QWORD PTR [rbx]
  22c237:	0f b6 44 10 03       	movzx  eax,BYTE PTR [rax+rdx*1+0x3]
        dest[i] = s;
  22c23c:	88 44 16 fc          	mov    BYTE PTR [rsi+rdx*1-0x4],al
    for (source) |s, i|
  22c240:	48 8b 03             	mov    rax,QWORD PTR [rbx]
  22c243:	0f b6 44 10 04       	movzx  eax,BYTE PTR [rax+rdx*1+0x4]
        dest[i] = s;
  22c248:	88 44 16 fd          	mov    BYTE PTR [rsi+rdx*1-0x3],al
    for (source) |s, i|
  22c24c:	48 8b 03             	mov    rax,QWORD PTR [rbx]
  22c24f:	0f b6 44 10 05       	movzx  eax,BYTE PTR [rax+rdx*1+0x5]
        dest[i] = s;
  22c254:	88 44 16 fe          	mov    BYTE PTR [rsi+rdx*1-0x2],al
    for (source) |s, i|
  22c258:	48 8b 03             	mov    rax,QWORD PTR [rbx]
  22c25b:	0f b6 44 10 06       	movzx  eax,BYTE PTR [rax+rdx*1+0x6]
        dest[i] = s;
  22c260:	88 44 16 ff          	mov    BYTE PTR [rsi+rdx*1-0x1],al
    for (source) |s, i|
  22c264:	48 8b 03             	mov    rax,QWORD PTR [rbx]
  22c267:	0f b6 44 10 07       	movzx  eax,BYTE PTR [rax+rdx*1+0x7]
        dest[i] = s;
  22c26c:	88 04 16             	mov    BYTE PTR [rsi+rdx*1],al
    for (source) |s, i|
  22c26f:	48 83 c2 08          	add    rdx,0x8
  22c273:	48 39 d7             	cmp    rdi,rdx
  22c276:	75 98                	jne    22c210 <ArenaAllocator_realloc+0x180>
  22c278:	48 85 c9             	test   rcx,rcx
  22c27b:	74 18                	je     22c295 <ArenaAllocator_realloc+0x205>
  22c27d:	48 f7 d9             	neg    rcx
  22c280:	48 8b 03             	mov    rax,QWORD PTR [rbx]
  22c283:	0f b6 04 10          	movzx  eax,BYTE PTR [rax+rdx*1]
        dest[i] = s;
  22c287:	41 88 04 10          	mov    BYTE PTR [r8+rdx*1],al
    for (source) |s, i|
  22c28b:	48 83 c2 01          	add    rdx,0x1
  22c28f:	48 83 c1 01          	add    rcx,0x1
  22c293:	75 eb                	jne    22c280 <ArenaAllocator_realloc+0x1f0>
  22c295:	48 8b 44 24 08       	mov    rax,QWORD PTR [rsp+0x8]
            return result;
  22c29a:	66 c7 00 00 00       	mov    WORD PTR [rax],0x0
  22c29f:	0f b7 4c 24 18       	movzx  ecx,WORD PTR [rsp+0x18]
  22c2a4:	66 89 48 06          	mov    WORD PTR [rax+0x6],cx
  22c2a8:	8b 4c 24 14          	mov    ecx,DWORD PTR [rsp+0x14]
  22c2ac:	89 48 02             	mov    DWORD PTR [rax+0x2],ecx
  22c2af:	4c 89 40 08          	mov    QWORD PTR [rax+0x8],r8
  22c2b3:	4c 89 78 10          	mov    QWORD PTR [rax+0x10],r15
  22c2b7:	48 83 c4 58          	add    rsp,0x58
  22c2bb:	5b                   	pop    rbx
  22c2bc:	41 5c                	pop    r12
  22c2be:	41 5d                	pop    r13
  22c2c0:	41 5e                	pop    r14
  22c2c2:	41 5f                	pop    r15
  22c2c4:	5d                   	pop    rbp
  22c2c5:	c3                   	ret    
            @panic("assertion failure");
  22c2c6:	48 8d 3d 3b 2a 02 00 	lea    rdi,[rip+0x22a3b]        # 24ed08 <__unnamed_2>
  22c2cd:	e8 4e 5d fe ff       	call   212020 <panic>
  22c2d2:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  22c2d9:	1f 84 00 00 00 00 00 

000000000022c2e0 <ArenaAllocator_free>:
    fn free(allocator: *Allocator, bytes: []u8) void {}
  22c2e0:	c3                   	ret    
  22c2e1:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  22c2e8:	0f 1f 84 00 00 00 00 
  22c2ef:	00 

000000000022c2f0 <ArenaAllocator_createNode>:
    fn createNode(self: *ArenaAllocator, prev_len: usize, minimum_size: usize) !*BufNode {
  22c2f0:	41 57                	push   r15
  22c2f2:	41 56                	push   r14
  22c2f4:	53                   	push   rbx
  22c2f5:	48 83 ec 30          	sub    rsp,0x30
  22c2f9:	48 89 d3             	mov    rbx,rdx
  22c2fc:	49 89 f6             	mov    r14,rsi
  22c2ff:	49 89 ff             	mov    r15,rdi
        const actual_min_size = minimum_size + @sizeOf(BufNode);
  22c302:	48 83 c1 20          	add    rcx,0x20
  22c306:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  22c30d:	00 00 00 
            len += len / 2;
  22c310:	48 89 d8             	mov    rax,rbx
  22c313:	48 d1 e8             	shr    rax,1
  22c316:	48 01 d8             	add    rax,rbx
            len += os.page_size - @rem(len, os.page_size);
  22c319:	89 c2                	mov    edx,eax
  22c31b:	81 e2 ff 0f 00 00    	and    edx,0xfff
  22c321:	bb 00 10 00 00       	mov    ebx,0x1000
  22c326:	48 29 d3             	sub    rbx,rdx
  22c329:	48 01 c3             	add    rbx,rax
            if (len >= actual_min_size) break;
  22c32c:	48 39 cb             	cmp    rbx,rcx
  22c32f:	72 df                	jb     22c310 <ArenaAllocator_createNode+0x20>
        if (n == 0) {
  22c331:	48 85 db             	test   rbx,rbx
  22c334:	74 38                	je     22c36e <ArenaAllocator_createNode+0x7e>
  22c336:	49 8b 76 18          	mov    rsi,QWORD PTR [r14+0x18]
  22c33a:	48 8d 7c 24 08       	lea    rdi,[rsp+0x8]
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  22c33f:	b9 08 00 00 00       	mov    ecx,0x8
  22c344:	48 89 da             	mov    rdx,rbx
  22c347:	ff 16                	call   QWORD PTR [rsi]
  22c349:	0f b7 44 24 08       	movzx  eax,WORD PTR [rsp+0x8]
  22c34e:	66 85 c0             	test   ax,ax
  22c351:	74 1f                	je     22c372 <ArenaAllocator_createNode+0x82>
        const buf = try self.child_allocator.alignedAlloc(u8, @alignOf(BufNode), len);
  22c353:	66 41 89 07          	mov    WORD PTR [r15],ax
  22c357:	48 8b 44 24 22       	mov    rax,QWORD PTR [rsp+0x22]
  22c35c:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  22c361:	49 89 4f 08          	mov    QWORD PTR [r15+0x8],rcx
  22c365:	49 89 47 02          	mov    QWORD PTR [r15+0x2],rax
  22c369:	e9 c6 00 00 00       	jmp    22c434 <ArenaAllocator_createNode+0x144>
  22c36e:	31 db                	xor    ebx,ebx
  22c370:	eb 10                	jmp    22c382 <ArenaAllocator_createNode+0x92>
        assert(byte_slice.len == byte_count);
  22c372:	48 39 5c 24 18       	cmp    QWORD PTR [rsp+0x18],rbx
    if (!ok) {
  22c377:	0f 85 c1 00 00 00    	jne    22c43e <ArenaAllocator_createNode+0x14e>
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  22c37d:	48 8b 44 24 10       	mov    rax,QWORD PTR [rsp+0x10]
        buf_node.* = BufNode{
  22c382:	c5 f8 57 c0          	vxorps xmm0,xmm0,xmm0
  22c386:	c5 f8 11 00          	vmovups XMMWORD PTR [rax],xmm0
  22c38a:	48 89 40 10          	mov    QWORD PTR [rax+0x10],rax
  22c38e:	48 89 58 18          	mov    QWORD PTR [rax+0x18],rbx
            if (list.last) |last| {
  22c392:	49 8b 4e 28          	mov    rcx,QWORD PTR [r14+0x28]
  22c396:	48 85 c9             	test   rcx,rcx
  22c399:	74 12                	je     22c3ad <ArenaAllocator_createNode+0xbd>
            new_node.prev = node;
  22c39b:	48 89 08             	mov    QWORD PTR [rax],rcx
            if (node.next) |next_node| {
  22c39e:	48 8b 51 08          	mov    rdx,QWORD PTR [rcx+0x8]
  22c3a2:	48 85 d2             	test   rdx,rdx
  22c3a5:	74 24                	je     22c3cb <ArenaAllocator_createNode+0xdb>
                new_node.next = next_node;
  22c3a7:	48 89 50 08          	mov    QWORD PTR [rax+0x8],rdx
  22c3ab:	eb 2a                	jmp    22c3d7 <ArenaAllocator_createNode+0xe7>
            if (list.first) |first| {
  22c3ad:	49 8b 4e 20          	mov    rcx,QWORD PTR [r14+0x20]
  22c3b1:	48 85 c9             	test   rcx,rcx
  22c3b4:	74 2a                	je     22c3e0 <ArenaAllocator_createNode+0xf0>
            new_node.next = node;
  22c3b6:	48 89 48 08          	mov    QWORD PTR [rax+0x8],rcx
            if (node.prev) |prev_node| {
  22c3ba:	48 8b 11             	mov    rdx,QWORD PTR [rcx]
  22c3bd:	48 85 d2             	test   rdx,rdx
  22c3c0:	74 38                	je     22c3fa <ArenaAllocator_createNode+0x10a>
                new_node.prev = prev_node;
  22c3c2:	48 89 10             	mov    QWORD PTR [rax],rdx
                prev_node.next = new_node;
  22c3c5:	48 83 c2 08          	add    rdx,0x8
  22c3c9:	eb 3a                	jmp    22c405 <ArenaAllocator_createNode+0x115>
  22c3cb:	49 8d 56 28          	lea    rdx,[r14+0x28]
                new_node.next = null;
  22c3cf:	48 c7 40 08 00 00 00 	mov    QWORD PTR [rax+0x8],0x0
  22c3d6:	00 
  22c3d7:	48 89 02             	mov    QWORD PTR [rdx],rax
            node.next = new_node;
  22c3da:	48 89 41 08          	mov    QWORD PTR [rcx+0x8],rax
  22c3de:	eb 2b                	jmp    22c40b <ArenaAllocator_createNode+0x11b>
                list.first = new_node;
  22c3e0:	49 89 46 20          	mov    QWORD PTR [r14+0x20],rax
                list.last = new_node;
  22c3e4:	49 89 46 28          	mov    QWORD PTR [r14+0x28],rax
                new_node.next = null;
  22c3e8:	c5 f8 57 c0          	vxorps xmm0,xmm0,xmm0
  22c3ec:	c5 f8 11 00          	vmovups XMMWORD PTR [rax],xmm0
                list.len = 1;
  22c3f0:	49 c7 46 30 01 00 00 	mov    QWORD PTR [r14+0x30],0x1
  22c3f7:	00 
  22c3f8:	eb 16                	jmp    22c410 <ArenaAllocator_createNode+0x120>
  22c3fa:	49 8d 56 20          	lea    rdx,[r14+0x20]
                new_node.prev = null;
  22c3fe:	48 c7 00 00 00 00 00 	mov    QWORD PTR [rax],0x0
  22c405:	48 89 02             	mov    QWORD PTR [rdx],rax
            node.prev = new_node;
  22c408:	48 89 01             	mov    QWORD PTR [rcx],rax
  22c40b:	49 83 46 30 01       	add    QWORD PTR [r14+0x30],0x1
        self.end_index = 0;
  22c410:	49 c7 46 38 00 00 00 	mov    QWORD PTR [r14+0x38],0x0
  22c417:	00 
        return buf_node;
  22c418:	66 41 c7 07 00 00    	mov    WORD PTR [r15],0x0
  22c41e:	0f b7 4c 24 06       	movzx  ecx,WORD PTR [rsp+0x6]
  22c423:	66 41 89 4f 06       	mov    WORD PTR [r15+0x6],cx
  22c428:	8b 4c 24 02          	mov    ecx,DWORD PTR [rsp+0x2]
  22c42c:	41 89 4f 02          	mov    DWORD PTR [r15+0x2],ecx
  22c430:	49 89 47 08          	mov    QWORD PTR [r15+0x8],rax
  22c434:	48 83 c4 30          	add    rsp,0x30
  22c438:	5b                   	pop    rbx
  22c439:	41 5e                	pop    r14
  22c43b:	41 5f                	pop    r15
  22c43d:	c3                   	ret    
            @panic("assertion failure");
  22c43e:	48 8d 3d c3 28 02 00 	lea    rdi,[rip+0x228c3]        # 24ed08 <__unnamed_2>
  22c445:	e8 d6 5b fe ff       	call   212020 <panic>
  22c44a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

000000000022c450 <errol3>:
        }
    }
}

/// Corrected Errol3 double to ASCII conversion.
pub fn errol3(value: f64, buffer: []u8) FloatDecimal {
  22c450:	55                   	push   rbp
  22c451:	41 57                	push   r15
  22c453:	41 56                	push   r14
  22c455:	41 55                	push   r13
  22c457:	41 54                	push   r12
  22c459:	53                   	push   rbx
  22c45a:	48 83 ec 68          	sub    rsp,0x68
  22c45e:	49 89 f7             	mov    r15,rsi
  22c461:	49 89 fe             	mov    r14,rdi
    const bits = @bitCast(u64, value);
  22c464:	c4 e1 f9 7e c5       	vmovq  rbp,xmm0
  22c469:	b8 b0 01 00 00       	mov    eax,0x1b0
  22c46e:	31 d2                	xor    edx,edx
  22c470:	48 8d 0d c1 48 fd ff 	lea    rcx,[rip+0xfffffffffffd48c1]        # 200d38 <enum3.11>
  22c477:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  22c47e:	00 00 
fn tableLowerBound(k: u64) usize {
    var i = enum3.len;
    var j: usize = 0;

    while (j < enum3.len) {
        if (enum3[j] < k) {
  22c480:	48 39 2c d1          	cmp    QWORD PTR [rcx+rdx*8],rbp
  22c484:	72 1a                	jb     22c4a0 <errol3+0x50>
  22c486:	48 89 d0             	mov    rax,rdx
  22c489:	48 01 d2             	add    rdx,rdx
  22c48c:	48 83 c2 01          	add    rdx,0x1
    while (j < enum3.len) {
  22c490:	48 81 fa b0 01 00 00 	cmp    rdx,0x1b0
  22c497:	72 e7                	jb     22c480 <errol3+0x30>
  22c499:	eb 15                	jmp    22c4b0 <errol3+0x60>
  22c49b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  22c4a0:	48 01 d2             	add    rdx,rdx
  22c4a3:	48 83 c2 02          	add    rdx,0x2
  22c4a7:	48 81 fa b0 01 00 00 	cmp    rdx,0x1b0
  22c4ae:	72 d0                	jb     22c480 <errol3+0x30>
    if (i < enum3.len and enum3[i] == bits) {
  22c4b0:	48 3d af 01 00 00    	cmp    rax,0x1af
  22c4b6:	77 4a                	ja     22c502 <errol3+0xb2>
  22c4b8:	48 39 2c c1          	cmp    QWORD PTR [rcx+rax*8],rbp
  22c4bc:	75 44                	jne    22c502 <errol3+0xb2>
        const data = enum3_data[i];
  22c4be:	48 8d 3c 40          	lea    rdi,[rax+rax*2]
  22c4c2:	4c 8d 05 17 fe 01 00 	lea    r8,[rip+0x1fe17]        # 24c2e0 <enum3_data.12>
  22c4c9:	49 8b 0c f8          	mov    rcx,QWORD PTR [r8+rdi*8]
  22c4cd:	4d 8b 4c f8 08       	mov    r9,QWORD PTR [r8+rdi*8+0x8]
        const digits = buffer[1 .. data.str.len + 1];
  22c4d2:	49 8b 37             	mov    rsi,QWORD PTR [r15]
    for (source) |s, i|
  22c4d5:	49 8d 41 ff          	lea    rax,[r9-0x1]
  22c4d9:	44 89 cd             	mov    ebp,r9d
  22c4dc:	83 e5 07             	and    ebp,0x7
  22c4df:	48 83 f8 07          	cmp    rax,0x7
  22c4e3:	0f 83 69 04 00 00    	jae    22c952 <errol3+0x502>
  22c4e9:	31 db                	xor    ebx,ebx
  22c4eb:	41 8b 44 f8 10       	mov    eax,DWORD PTR [r8+rdi*8+0x10]
  22c4f0:	48 8d 7e 01          	lea    rdi,[rsi+0x1]
  22c4f4:	48 85 ed             	test   rbp,rbp
  22c4f7:	0f 85 c1 04 00 00    	jne    22c9be <errol3+0x56e>
  22c4fd:	e9 de 04 00 00       	jmp    22c9e0 <errol3+0x590>
    if (val > 9.007199254740992e15 and val < 3.40282366920938e+38) {
  22c502:	c5 f9 2e 05 86 3e fd 	vucomisd xmm0,QWORD PTR [rip+0xfffffffffffd3e86]        # 200390 <__unnamed_609+0x50>
  22c509:	ff 
  22c50a:	c5 f9 7f 04 24       	vmovdqa XMMWORD PTR [rsp],xmm0
  22c50f:	0f 86 0f 02 00 00    	jbe    22c724 <errol3+0x2d4>
  22c515:	c5 fb 10 0d 33 3e fd 	vmovsd xmm1,QWORD PTR [rip+0xfffffffffffd3e33]        # 200350 <__unnamed_609+0x10>
  22c51c:	ff 
  22c51d:	c5 f9 2e c8          	vucomisd xmm1,xmm0
  22c521:	0f 86 fd 01 00 00    	jbe    22c724 <errol3+0x2d4>
fn errolInt(val: f64, buffer: []u8) FloatDecimal {
    const pow19 = u128(1e19);

    assert((val > 9.007199254740992e15) and val < (3.40282366920938e38));

    var mid = @floatToInt(u128, val);
  22c527:	e8 c4 4a 00 00       	call   230ff0 <__fixunsdfti>
  22c52c:	c5 f9 28 0c 24       	vmovapd xmm1,XMMWORD PTR [rsp]
        .exp = exp,
    };
}

fn fpnext(val: f64) f64 {
    return @bitCast(f64, @bitCast(u64, val) +% 1);
  22c531:	48 8d 4d 01          	lea    rcx,[rbp+0x1]
  22c535:	c4 e1 f9 6e c1       	vmovq  xmm0,rcx
    var low: u128 = mid - fpeint((fpnext(val) - val) / 2.0);
  22c53a:	c5 fb 5c c1          	vsubsd xmm0,xmm0,xmm1
  22c53e:	c5 fb 59 05 c2 3d fd 	vmulsd xmm0,xmm0,QWORD PTR [rip+0xfffffffffffd3dc2]        # 200308 <__unnamed_610+0x8>
  22c545:	ff 

    return buf_index;
}

fn fpeint(from: f64) u128 {
    const bits = @bitCast(u64, from);
  22c546:	c4 e1 f9 7e c1       	vmovq  rcx,xmm0
    assert((bits & ((1 << 52) - 1)) == 0);
  22c54b:	48 89 ce             	mov    rsi,rcx
  22c54e:	48 c1 e6 0c          	shl    rsi,0xc
    if (!ok) {
  22c552:	0f 85 1c 0e 00 00    	jne    22d374 <errol3+0xf24>
  22c558:	4c 89 74 24 20       	mov    QWORD PTR [rsp+0x20],r14
  22c55d:	48 be ff ff ff ff ff 	movabs rsi,0xfffffffffffff
  22c564:	ff 0f 00 
    return @bitCast(f64, @bitCast(u64, val) -% 1);
  22c567:	48 8d 7d ff          	lea    rdi,[rbp-0x1]
  22c56b:	c4 e1 f9 6e c7       	vmovq  xmm0,rdi
    var high: u128 = mid + fpeint((val - fpprev(val)) / 2.0);
  22c570:	c5 f3 5c c0          	vsubsd xmm0,xmm1,xmm0
  22c574:	c5 fb 59 05 8c 3d fd 	vmulsd xmm0,xmm0,QWORD PTR [rip+0xfffffffffffd3d8c]        # 200308 <__unnamed_610+0x8>
  22c57b:	ff 
    const bits = @bitCast(u64, from);
  22c57c:	c4 e1 f9 7e c3       	vmovq  rbx,xmm0
    assert((bits & ((1 << 52) - 1)) == 0);
  22c581:	48 85 f3             	test   rbx,rsi
  22c584:	0f 85 ea 0d 00 00    	jne    22d374 <errol3+0xf24>

    return u128(1) << @truncate(u7, (bits >> 52) -% 1023);
  22c58a:	48 c1 e9 34          	shr    rcx,0x34
  22c58e:	83 c1 01             	add    ecx,0x1
  22c591:	83 e1 7f             	and    ecx,0x7f
  22c594:	41 b8 01 00 00 00    	mov    r8d,0x1
  22c59a:	31 ff                	xor    edi,edi
  22c59c:	4c 0f a5 c7          	shld   rdi,r8,cl

    var i: i32 = 0;
    var a_copy = a;
    var b_copy = b;

    if (af != bf) {
  22c5a0:	45 31 c9             	xor    r9d,r9d
    return u128(1) << @truncate(u7, (bits >> 52) -% 1023);
  22c5a3:	c4 c2 f1 f7 f0       	shlx   rsi,r8,rcx
  22c5a8:	f6 c1 40             	test   cl,0x40
  22c5ab:	48 0f 45 fe          	cmovne rdi,rsi
  22c5af:	49 0f 45 f1          	cmovne rsi,r9
    if (af != bf) {
  22c5b3:	45 31 c9             	xor    r9d,r9d
    var low: u128 = mid - fpeint((fpnext(val) - val) / 2.0);
  22c5b6:	49 89 c5             	mov    r13,rax
  22c5b9:	49 29 f5             	sub    r13,rsi
  22c5bc:	48 89 d6             	mov    rsi,rdx
  22c5bf:	48 19 fe             	sbb    rsi,rdi
    return u128(1) << @truncate(u7, (bits >> 52) -% 1023);
  22c5c2:	48 c1 eb 34          	shr    rbx,0x34
  22c5c6:	83 c3 01             	add    ebx,0x1
  22c5c9:	83 e3 7f             	and    ebx,0x7f
  22c5cc:	31 ff                	xor    edi,edi
  22c5ce:	89 d9                	mov    ecx,ebx
  22c5d0:	4c 0f a5 c7          	shld   rdi,r8,cl
  22c5d4:	c4 c2 e1 f7 c8       	shlx   rcx,r8,rbx
  22c5d9:	f6 c3 40             	test   bl,0x40
  22c5dc:	48 0f 45 f9          	cmovne rdi,rcx
  22c5e0:	49 0f 45 c9          	cmovne rcx,r9
    if (@bitCast(u64, val) & 0x1 != 0) {
  22c5e4:	83 e5 01             	and    ebp,0x1
  22c5e7:	31 db                	xor    ebx,ebx
  22c5e9:	48 85 ed             	test   rbp,rbp
  22c5ec:	0f 94 c3             	sete   bl
  22c5ef:	48 89 04 24          	mov    QWORD PTR [rsp],rax
    var high: u128 = mid + fpeint((val - fpprev(val)) / 2.0);
  22c5f3:	49 89 c4             	mov    r12,rax
  22c5f6:	49 29 ec             	sub    r12,rbp
  22c5f9:	48 89 54 24 10       	mov    QWORD PTR [rsp+0x10],rdx
  22c5fe:	48 89 d5             	mov    rbp,rdx
  22c601:	48 83 dd 00          	sbb    rbp,0x0
    if (@bitCast(u64, val) & 0x1 != 0) {
  22c605:	49 01 cc             	add    r12,rcx
  22c608:	48 11 fd             	adc    rbp,rdi
  22c60b:	49 29 dd             	sub    r13,rbx
  22c60e:	48 83 de 00          	sbb    rsi,0x0
  22c612:	49 be 00 00 e8 89 04 	movabs r14,0x8ac7230489e80000
  22c619:	23 c7 8a 
    const lf = @intCast(u64, (low / pow19) % pow19);
  22c61c:	31 c9                	xor    ecx,ecx
  22c61e:	4c 89 ef             	mov    rdi,r13
  22c621:	4c 89 f2             	mov    rdx,r14
  22c624:	e8 c7 54 00 00       	call   231af0 <__udivti3>
  22c629:	48 89 c1             	mov    rcx,rax
  22c62c:	49 0f af ce          	imul   rcx,r14
  22c630:	49 29 cd             	sub    r13,rcx
  22c633:	31 c9                	xor    ecx,ecx
  22c635:	48 89 c7             	mov    rdi,rax
  22c638:	48 89 d6             	mov    rsi,rdx
  22c63b:	4c 89 f2             	mov    rdx,r14
  22c63e:	e8 cd 54 00 00       	call   231b10 <__umodti3>
  22c643:	48 89 c3             	mov    rbx,rax
    const hf = @intCast(u64, (high / pow19) % pow19);
  22c646:	31 c9                	xor    ecx,ecx
  22c648:	4c 89 e7             	mov    rdi,r12
  22c64b:	48 89 ee             	mov    rsi,rbp
  22c64e:	4c 89 f2             	mov    rdx,r14
  22c651:	e8 9a 54 00 00       	call   231af0 <__udivti3>
  22c656:	48 89 c1             	mov    rcx,rax
  22c659:	49 0f af ce          	imul   rcx,r14
  22c65d:	49 29 cc             	sub    r12,rcx
  22c660:	31 c9                	xor    ecx,ecx
  22c662:	48 89 c7             	mov    rdi,rax
  22c665:	48 89 d6             	mov    rsi,rdx
  22c668:	4c 89 f2             	mov    rdx,r14
  22c66b:	e8 a0 54 00 00       	call   231b10 <__umodti3>
  22c670:	49 89 c6             	mov    r14,rax
    if (lf != hf) {
  22c673:	4c 39 f3             	cmp    rbx,r14
  22c676:	48 89 df             	mov    rdi,rbx
  22c679:	4c 0f 45 eb          	cmovne r13,rbx
  22c67d:	4d 0f 45 e6          	cmovne r12,r14
  22c681:	48 b9 bf d5 ed bd ce 	movabs rcx,0xdbe6fecebdedd5bf
  22c688:	fe e6 db 
    const af = a / pow10;
  22c68b:	4c 89 ea             	mov    rdx,r13
  22c68e:	c4 e2 eb f6 c1       	mulx   rax,rdx,rcx
  22c693:	48 c1 e8 21          	shr    rax,0x21
    const bf = b / pow10;
  22c697:	4c 89 e2             	mov    rdx,r12
  22c69a:	c4 e2 eb f6 c9       	mulx   rcx,rdx,rcx
  22c69f:	48 c1 e9 21          	shr    rcx,0x21
    if (af != bf) {
  22c6a3:	48 39 c8             	cmp    rax,rcx
  22c6a6:	bd 0a 00 00 00       	mov    ebp,0xa
  22c6ab:	ba 00 00 00 00       	mov    edx,0x0
  22c6b0:	0f 44 ea             	cmove  ebp,edx
  22c6b3:	49 0f 44 c5          	cmove  rax,r13
  22c6b7:	49 0f 44 cc          	cmove  rcx,r12
  22c6bb:	bb 01 00 00 00       	mov    ebx,0x1
        i = 10;
        a_copy = af;
        b_copy = bf;
    }

    while (true) : (i += 1) {
  22c6c0:	29 eb                	sub    ebx,ebp
  22c6c2:	83 c5 12             	add    ebp,0x12
  22c6c5:	48 be cd cc cc cc cc 	movabs rsi,0xcccccccccccccccd
  22c6cc:	cc cc cc 
  22c6cf:	90                   	nop
        a_copy /= 10;
  22c6d0:	48 89 c2             	mov    rdx,rax
  22c6d3:	c4 e2 eb f6 c6       	mulx   rax,rdx,rsi
  22c6d8:	48 c1 e8 03          	shr    rax,0x3
        b_copy /= 10;
  22c6dc:	48 89 ca             	mov    rdx,rcx
  22c6df:	c4 e2 eb f6 ce       	mulx   rcx,rdx,rsi
  22c6e4:	48 c1 e9 03          	shr    rcx,0x3

        if (a_copy == b_copy) return i;
  22c6e8:	83 c3 ff             	add    ebx,0xffffffff
  22c6eb:	83 c5 01             	add    ebp,0x1
  22c6ee:	48 39 c8             	cmp    rax,rcx
  22c6f1:	75 dd                	jne    22c6d0 <errol3+0x280>
  22c6f3:	49 89 fd             	mov    r13,rdi
    if (lf != hf) {
  22c6f6:	4d 39 f5             	cmp    r13,r14
  22c6f9:	0f 84 0e 02 00 00    	je     22c90d <errol3+0x4bd>
        mid = mid / (pow19 / 10);
  22c6ff:	48 ba 00 00 64 a7 b3 	movabs rdx,0xde0b6b3a7640000
  22c706:	b6 e0 0d 
  22c709:	31 c9                	xor    ecx,ecx
  22c70b:	48 8b 3c 24          	mov    rdi,QWORD PTR [rsp]
  22c70f:	48 8b 74 24 10       	mov    rsi,QWORD PTR [rsp+0x10]
  22c714:	e8 d7 53 00 00       	call   231af0 <__udivti3>
  22c719:	48 89 c7             	mov    rdi,rax
  22c71c:	48 89 d6             	mov    rsi,rdx
  22c71f:	e9 f2 01 00 00       	jmp    22c916 <errol3+0x4c6>
    } else if (val >= 16.0 and val < 9.007199254740992e15) {
  22c724:	c5 f9 2e 05 b4 3b fd 	vucomisd xmm0,QWORD PTR [rip+0xfffffffffffd3bb4]        # 2002e0 <__unnamed_10+0x60>
  22c72b:	ff 
  22c72c:	0f 82 39 01 00 00    	jb     22c86b <errol3+0x41b>
  22c732:	c5 fb 10 0d 56 3c fd 	vmovsd xmm1,QWORD PTR [rip+0xfffffffffffd3c56]        # 200390 <__unnamed_609+0x50>
  22c739:	ff 
  22c73a:	c5 f9 2e c8          	vucomisd xmm1,xmm0
  22c73e:	0f 86 27 01 00 00    	jbe    22c86b <errol3+0x41b>
    const u = @floatToInt(u64, val);
  22c744:	c5 fb 10 15 fc 3b fd 	vmovsd xmm2,QWORD PTR [rip+0xfffffffffffd3bfc]        # 200348 <__unnamed_609+0x8>
  22c74b:	ff 
  22c74c:	c5 fb 5c ca          	vsubsd xmm1,xmm0,xmm2
  22c750:	c4 e1 fb 2c c1       	vcvttsd2si rax,xmm1
  22c755:	48 b9 00 00 00 00 00 	movabs rcx,0x8000000000000000
  22c75c:	00 00 80 
  22c75f:	48 31 c1             	xor    rcx,rax
  22c762:	c4 e1 fb 2c f8       	vcvttsd2si rdi,xmm0
  22c767:	c5 f9 2e c2          	vucomisd xmm0,xmm2
  22c76b:	48 0f 43 f9          	cmovae rdi,rcx
    const n = @intToFloat(f64, u);
  22c76f:	c4 e1 f9 6e cf       	vmovq  xmm1,rdi
  22c774:	c5 f1 62 0d 54 c5 fd 	vpunpckldq xmm1,xmm1,XMMWORD PTR [rip+0xfffffffffffdc554]        # 208cd0 <__unnamed_629+0x17>
  22c77b:	ff 
  22c77c:	c5 f1 5c 0d 6c ca fd 	vsubpd xmm1,xmm1,XMMWORD PTR [rip+0xfffffffffffdca6c]        # 2091f0 <__unnamed_70+0x10>
  22c783:	ff 
  22c784:	c5 f1 7c c9          	vhaddpd xmm1,xmm1,xmm1
  22c788:	c5 f9 29 4c 24 10    	vmovapd XMMWORD PTR [rsp+0x10],xmm1
    var mid = val - n;
  22c78e:	c5 fb 5c c9          	vsubsd xmm1,xmm0,xmm1
    var buf_index = u64toa(u, buffer);
  22c792:	c5 f9 29 4c 24 20    	vmovapd XMMWORD PTR [rsp+0x20],xmm1
  22c798:	4c 89 fe             	mov    rsi,r15
  22c79b:	e8 e0 0b 00 00       	call   22d380 <u64toa>
  22c7a0:	c5 f9 28 6c 24 20    	vmovapd xmm5,XMMWORD PTR [rsp+0x20]
  22c7a6:	49 89 c4             	mov    r12,rax
    buffer[j] = 0;
  22c7a9:	49 8b 07             	mov    rax,QWORD PTR [r15]
  22c7ac:	42 c6 04 20 00       	mov    BYTE PTR [rax+r12*1],0x0
    if (mid != 0.0) {
  22c7b1:	c5 f9 57 c0          	vxorpd xmm0,xmm0,xmm0
  22c7b5:	c5 f9 2e e8          	vucomisd xmm5,xmm0
  22c7b9:	0f 84 48 08 00 00    	je     22d007 <errol3+0xbb7>
    return @bitCast(f64, @bitCast(u64, val) -% 1);
  22c7bf:	c4 e2 79 59 0c 24    	vpbroadcastq xmm1,QWORD PTR [rsp]
  22c7c5:	c5 f1 d4 0d b3 cb fd 	vpaddq xmm1,xmm1,XMMWORD PTR [rip+0xfffffffffffdcbb3]        # 209380 <__unnamed_522+0x10>
  22c7cc:	ff 
    var lo = ((fpprev(val) - n) + mid) / 2.0;
  22c7cd:	c5 fb 12 54 24 10    	vmovddup xmm2,QWORD PTR [rsp+0x10]
  22c7d3:	c5 f1 5c ca          	vsubpd xmm1,xmm1,xmm2
  22c7d7:	c5 fb 12 d5          	vmovddup xmm2,xmm5
  22c7db:	c5 e9 58 c9          	vaddpd xmm1,xmm2,xmm1
  22c7df:	c5 f1 59 1d a9 c7 fd 	vmulpd xmm3,xmm1,XMMWORD PTR [rip+0xfffffffffffdc7a9]        # 208f90 <__unnamed_43+0x10>
  22c7e6:	ff 
  22c7e7:	c5 f9 28 0d e1 c5 fd 	vmovapd xmm1,XMMWORD PTR [rip+0xfffffffffffdc5e1]        # 208dd0 <__unnamed_5+0x10>
  22c7ee:	ff 
  22c7ef:	c5 fb 10 15 c1 3a fd 	vmovsd xmm2,QWORD PTR [rip+0xfffffffffffd3ac1]        # 2002b8 <__unnamed_10+0x38>
  22c7f6:	ff 
  22c7f7:	4c 89 e0             	mov    rax,r12
  22c7fa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  22c800:	48 89 c1             	mov    rcx,rax
            mid *= 10.0;
  22c803:	c5 d3 59 e2          	vmulsd xmm4,xmm5,xmm2
            const mdig = @floatToInt(i32, mid);
  22c807:	c5 fb 2c c4          	vcvttsd2si eax,xmm4
            mid -= @intToFloat(f64, mdig);
  22c80b:	c5 cb 2a e8          	vcvtsi2sd xmm5,xmm6,eax
  22c80f:	c5 db 5c ed          	vsubsd xmm5,xmm4,xmm5
            buffer[j] = @intCast(u8, mdig + '0');
  22c813:	49 8b 17             	mov    rdx,QWORD PTR [r15]
  22c816:	04 30                	add    al,0x30
  22c818:	88 04 0a             	mov    BYTE PTR [rdx+rcx*1],al
            if (hdig != ldig or j > 50) break;
  22c81b:	48 83 f9 31          	cmp    rcx,0x31
  22c81f:	77 2c                	ja     22c84d <errol3+0x3fd>
  22c821:	c5 e1 59 d9          	vmulpd xmm3,xmm3,xmm1
  22c825:	c5 fb 2c c3          	vcvttsd2si eax,xmm3
  22c829:	c4 e3 79 05 e3 01    	vpermilpd xmm4,xmm3,0x1
  22c82f:	c5 fb 2c d4          	vcvttsd2si edx,xmm4
  22c833:	39 c2                	cmp    edx,eax
  22c835:	75 16                	jne    22c84d <errol3+0x3fd>
            hi -= @intToFloat(f64, hdig);
  22c837:	c5 cb 2a e0          	vcvtsi2sd xmm4,xmm6,eax
  22c83b:	48 8d 41 01          	lea    rax,[rcx+0x1]
            lo -= @intToFloat(f64, ldig);
  22c83f:	c5 fb 12 e4          	vmovddup xmm4,xmm4
  22c843:	c5 e1 5c dc          	vsubpd xmm3,xmm3,xmm4
        while (mid != 0.0) {
  22c847:	c5 f9 2e e8          	vucomisd xmm5,xmm0
  22c84b:	75 b3                	jne    22c800 <errol3+0x3b0>
        if (mid > 0.5) {
  22c84d:	48 8d 41 01          	lea    rax,[rcx+0x1]
  22c851:	c5 f9 2e 2d af 3a fd 	vucomisd xmm5,QWORD PTR [rip+0xfffffffffffd3aaf]        # 200308 <__unnamed_610+0x8>
  22c858:	ff 
  22c859:	0f 86 f3 07 00 00    	jbe    22d052 <errol3+0xc02>
            buffer[j - 1] += 1;
  22c85f:	49 8b 17             	mov    rdx,QWORD PTR [r15]
  22c862:	80 04 0a 01          	add    BYTE PTR [rdx+rcx*1],0x1
  22c866:	e9 9b 0a 00 00       	jmp    22d306 <errol3+0xeb6>
  22c86b:	48 8d 7c 24 38       	lea    rdi,[rsp+0x38]

pub fn frexp(x: var) frexp_result(@typeOf(x)) {
    const T = @typeOf(x);
    return switch (T) {
        f32 => frexp32(x),
        f64 => frexp64(x),
  22c870:	e8 fb 11 00 00       	call   22da70 <frexp64>
    var exp = @floatToInt(i16, math.floor(307 + @intToFloat(f64, e) * 0.30103));
  22c875:	c5 eb 2a 44 24 40    	vcvtsi2sd xmm0,xmm2,DWORD PTR [rsp+0x40]
  22c87b:	c5 fb 59 05 6d 3a fd 	vmulsd xmm0,xmm0,QWORD PTR [rip+0xfffffffffffd3a6d]        # 2002f0 <__unnamed_600+0x8>
  22c882:	ff 
  22c883:	c5 fb 58 05 8d 3a fd 	vaddsd xmm0,xmm0,QWORD PTR [rip+0xfffffffffffd3a8d]        # 200318 <__unnamed_610+0x18>
  22c88a:	ff 
fn floor64(x: f64) f64 {
    const u = @bitCast(u64, x);
    const e = (u >> 52) & 0x7FF;
    var y: f64 = undefined;

    if (e >= 0x3FF + 52 or x == 0) {
  22c88b:	c5 f1 57 c9          	vxorpd xmm1,xmm1,xmm1
  22c88f:	c5 f9 2e c1          	vucomisd xmm0,xmm1
  22c893:	75 06                	jne    22c89b <errol3+0x44b>
  22c895:	0f 8b 55 01 00 00    	jnp    22c9f0 <errol3+0x5a0>
  22c89b:	c4 e1 f9 7e c0       	vmovq  rax,xmm0
  22c8a0:	b9 34 0b 00 00       	mov    ecx,0xb34
  22c8a5:	c4 e2 f0 f7 c8       	bextr  rcx,rax,rcx
  22c8aa:	48 81 f9 32 04 00 00 	cmp    rcx,0x432
  22c8b1:	0f 87 39 01 00 00    	ja     22c9f0 <errol3+0x5a0>
        return x;
    }

    if (u >> 63 != 0) {
        y = x - math.f64_toint + math.f64_toint - x;
  22c8b7:	c5 fb 10 15 19 3a fd 	vmovsd xmm2,QWORD PTR [rip+0xfffffffffffd3a19]        # 2002d8 <__unnamed_10+0x58>
  22c8be:	ff 
  22c8bf:	c5 fb 10 1d 59 3a fd 	vmovsd xmm3,QWORD PTR [rip+0xfffffffffffd3a59]        # 200320 <__unnamed_610+0x20>
  22c8c6:	ff 
    if (u >> 63 != 0) {
  22c8c7:	48 85 c0             	test   rax,rax
  22c8ca:	c5 79 28 1c 24       	vmovapd xmm11,XMMWORD PTR [rsp]
  22c8cf:	0f 88 a3 07 00 00    	js     22d078 <errol3+0xc28>
  22c8d5:	c5 fb 58 db          	vaddsd xmm3,xmm0,xmm3
  22c8d9:	c5 e3 58 d2          	vaddsd xmm2,xmm3,xmm2
    } else {
        y = x + math.f64_toint - math.f64_toint - x;
    }

    if (e <= 0x3FF - 1) {
  22c8dd:	48 81 f9 fe 03 00 00 	cmp    rcx,0x3fe
  22c8e4:	0f 86 a3 07 00 00    	jbe    22d08d <errol3+0xc3d>
  22c8ea:	c5 eb 5c d0          	vsubsd xmm2,xmm2,xmm0
        if (u >> 63 != 0) {
            return -1.0;
        } else {
            return 0.0;
        }
    } else if (y > 0) {
  22c8ee:	c5 e1 57 db          	vxorpd xmm3,xmm3,xmm3
  22c8f2:	c5 f9 2e d3          	vucomisd xmm2,xmm3
  22c8f6:	c5 fb 58 c2          	vaddsd xmm0,xmm0,xmm2
  22c8fa:	0f 86 f5 00 00 00    	jbe    22c9f5 <errol3+0x5a5>
        return x + y - 1;
  22c900:	c5 fb 58 05 f0 39 fd 	vaddsd xmm0,xmm0,QWORD PTR [rip+0xfffffffffffd39f0]        # 2002f8 <__unnamed_600+0x10>
  22c907:	ff 
  22c908:	e9 e8 00 00 00       	jmp    22c9f5 <errol3+0x5a5>
  22c90d:	48 8b 3c 24          	mov    rdi,QWORD PTR [rsp]
  22c911:	48 8b 74 24 10       	mov    rsi,QWORD PTR [rsp+0x10]
        var i: i32 = @boolToInt(lf == hf);
  22c916:	31 c0                	xor    eax,eax
  22c918:	4d 39 f5             	cmp    r13,r14
  22c91b:	0f 94 c0             	sete   al
        while (i < mi) : (i += 1) {
  22c91e:	41 89 dc             	mov    r12d,ebx
  22c921:	41 f7 dc             	neg    r12d
  22c924:	41 39 c4             	cmp    r12d,eax
  22c927:	76 1d                	jbe    22c946 <errol3+0x4f6>
  22c929:	41 89 c2             	mov    r10d,eax
  22c92c:	41 f7 da             	neg    r10d
  22c92f:	41 29 da             	sub    r10d,ebx
  22c932:	41 83 fa 10          	cmp    r10d,0x10
  22c936:	0f 83 8a 06 00 00    	jae    22cfc6 <errol3+0xb76>
  22c93c:	ba 01 00 00 00       	mov    edx,0x1
  22c941:	e9 61 09 00 00       	jmp    22d2a7 <errol3+0xe57>
  22c946:	31 c9                	xor    ecx,ecx
  22c948:	ba 01 00 00 00       	mov    edx,0x1
  22c94d:	e9 6c 09 00 00       	jmp    22d2be <errol3+0xe6e>
  22c952:	4c 89 c8             	mov    rax,r9
  22c955:	48 29 e8             	sub    rax,rbp
  22c958:	31 db                	xor    ebx,ebx
  22c95a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  22c960:	0f b6 14 19          	movzx  edx,BYTE PTR [rcx+rbx*1]
        dest[i] = s;
  22c964:	88 54 1e 01          	mov    BYTE PTR [rsi+rbx*1+0x1],dl
    for (source) |s, i|
  22c968:	0f b6 54 19 01       	movzx  edx,BYTE PTR [rcx+rbx*1+0x1]
        dest[i] = s;
  22c96d:	88 54 1e 02          	mov    BYTE PTR [rsi+rbx*1+0x2],dl
    for (source) |s, i|
  22c971:	0f b6 54 19 02       	movzx  edx,BYTE PTR [rcx+rbx*1+0x2]
        dest[i] = s;
  22c976:	88 54 1e 03          	mov    BYTE PTR [rsi+rbx*1+0x3],dl
    for (source) |s, i|
  22c97a:	0f b6 54 19 03       	movzx  edx,BYTE PTR [rcx+rbx*1+0x3]
        dest[i] = s;
  22c97f:	88 54 1e 04          	mov    BYTE PTR [rsi+rbx*1+0x4],dl
    for (source) |s, i|
  22c983:	0f b6 54 19 04       	movzx  edx,BYTE PTR [rcx+rbx*1+0x4]
        dest[i] = s;
  22c988:	88 54 1e 05          	mov    BYTE PTR [rsi+rbx*1+0x5],dl
    for (source) |s, i|
  22c98c:	0f b6 54 19 05       	movzx  edx,BYTE PTR [rcx+rbx*1+0x5]
        dest[i] = s;
  22c991:	88 54 1e 06          	mov    BYTE PTR [rsi+rbx*1+0x6],dl
    for (source) |s, i|
  22c995:	0f b6 54 19 06       	movzx  edx,BYTE PTR [rcx+rbx*1+0x6]
        dest[i] = s;
  22c99a:	88 54 1e 07          	mov    BYTE PTR [rsi+rbx*1+0x7],dl
    for (source) |s, i|
  22c99e:	0f b6 54 19 07       	movzx  edx,BYTE PTR [rcx+rbx*1+0x7]
        dest[i] = s;
  22c9a3:	88 54 1e 08          	mov    BYTE PTR [rsi+rbx*1+0x8],dl
    for (source) |s, i|
  22c9a7:	48 83 c3 08          	add    rbx,0x8
  22c9ab:	48 39 d8             	cmp    rax,rbx
  22c9ae:	75 b0                	jne    22c960 <errol3+0x510>
  22c9b0:	41 8b 44 f8 10       	mov    eax,DWORD PTR [r8+rdi*8+0x10]
  22c9b5:	48 8d 7e 01          	lea    rdi,[rsi+0x1]
  22c9b9:	48 85 ed             	test   rbp,rbp
  22c9bc:	74 22                	je     22c9e0 <errol3+0x590>
  22c9be:	48 01 de             	add    rsi,rbx
  22c9c1:	48 83 c6 01          	add    rsi,0x1
  22c9c5:	48 01 d9             	add    rcx,rbx
  22c9c8:	31 db                	xor    ebx,ebx
  22c9ca:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  22c9d0:	0f b6 14 19          	movzx  edx,BYTE PTR [rcx+rbx*1]
        dest[i] = s;
  22c9d4:	88 14 1e             	mov    BYTE PTR [rsi+rbx*1],dl
    for (source) |s, i|
  22c9d7:	48 83 c3 01          	add    rbx,0x1
  22c9db:	48 39 dd             	cmp    rbp,rbx
  22c9de:	75 f0                	jne    22c9d0 <errol3+0x580>
        return FloatDecimal{
  22c9e0:	49 89 3e             	mov    QWORD PTR [r14],rdi
  22c9e3:	4d 89 4e 08          	mov    QWORD PTR [r14+0x8],r9
  22c9e7:	41 89 46 10          	mov    DWORD PTR [r14+0x10],eax
  22c9eb:	e9 75 09 00 00       	jmp    22d365 <errol3+0xf15>
  22c9f0:	c5 79 28 1c 24       	vmovapd xmm11,XMMWORD PTR [rsp]
    var exp = @floatToInt(i16, math.floor(307 + @intToFloat(f64, e) * 0.30103));
  22c9f5:	c5 fb 2c c0          	vcvttsd2si eax,xmm0
    if (exp < 20) {
  22c9f9:	98                   	cwde   
    } else if (@intCast(usize, exp) >= lookup_table.len) {
  22c9fa:	0f b7 c8             	movzx  ecx,ax
  22c9fd:	81 f9 57 02 00 00    	cmp    ecx,0x257
  22ca03:	66 b9 57 02          	mov    cx,0x257
  22ca07:	66 0f 42 c8          	cmovb  cx,ax
    if (exp < 20) {
  22ca0b:	83 f8 14             	cmp    eax,0x14
  22ca0e:	66 b8 14 00          	mov    ax,0x14
  22ca12:	66 0f 4d c1          	cmovge ax,cx
    var mid = lookup_table[@intCast(usize, exp)];
  22ca16:	0f b7 c8             	movzx  ecx,ax
  22ca19:	48 c1 e1 04          	shl    rcx,0x4
  22ca1d:	48 8d 15 fc 63 fd ff 	lea    rdx,[rip+0xfffffffffffd63fc]        # 202e20 <lookup_table.14>
  22ca24:	48 8b 34 11          	mov    rsi,QWORD PTR [rcx+rdx*1]
  22ca28:	c4 61 f9 6e c6       	vmovq  xmm8,rsi
    const new_bits = bits & 0xFFFFFFFFF8000000;
  22ca2d:	48 81 e6 00 00 00 f8 	and    rsi,0xfffffffff8000000
    return @bitCast(f64, new_bits);
  22ca34:	c4 e1 f9 6e c6       	vmovq  xmm0,rsi
    lo.* = val - hi.*;
  22ca39:	c5 bb 5c e0          	vsubsd xmm4,xmm8,xmm0
    const new_bits = bits & 0xFFFFFFFFF8000000;
  22ca3d:	48 89 ee             	mov    rsi,rbp
  22ca40:	48 81 e6 00 00 00 f8 	and    rsi,0xfffffffff8000000
    return @bitCast(f64, new_bits);
  22ca47:	c4 e1 f9 6e ee       	vmovq  xmm5,rsi
    lo.* = val - hi.*;
  22ca4c:	c5 a3 5c f5          	vsubsd xmm6,xmm11,xmm5
    const p = in.val * val;
  22ca50:	c4 c1 3b 59 db       	vmulsd xmm3,xmm8,xmm11
    const e = ((hi * hi2 - p) + lo * hi2 + hi * lo2) + lo * lo2;
  22ca55:	c5 d3 59 f8          	vmulsd xmm7,xmm5,xmm0
  22ca59:	c5 c3 5c fb          	vsubsd xmm7,xmm7,xmm3
  22ca5d:	c5 db 59 ed          	vmulsd xmm5,xmm4,xmm5
  22ca61:	c5 d3 58 ef          	vaddsd xmm5,xmm5,xmm7
  22ca65:	c5 cb 59 c0          	vmulsd xmm0,xmm6,xmm0
  22ca69:	c5 fb 58 c5          	vaddsd xmm0,xmm0,xmm5
  22ca6d:	c5 cb 59 e4          	vmulsd xmm4,xmm6,xmm4
  22ca71:	c5 db 58 c0          	vaddsd xmm0,xmm4,xmm0
        .off = in.off * val + e,
  22ca75:	c5 a3 59 64 11 08    	vmulsd xmm4,xmm11,QWORD PTR [rcx+rdx*1+0x8]
  22ca7b:	c5 db 58 f0          	vaddsd xmm6,xmm4,xmm0
    exp -= 307;
  22ca7f:	8d 80 cd fe ff ff    	lea    eax,[rax-0x133]
    while (mid.val > 10.0 or (mid.val == 10.0 and mid.off >= 0.0)) {
  22ca85:	44 0f bf e0          	movsx  r12d,ax
  22ca89:	c5 fb 10 25 37 38 fd 	vmovsd xmm4,QWORD PTR [rip+0xfffffffffffd3837]        # 2002c8 <__unnamed_10+0x48>
  22ca90:	ff 
  22ca91:	c5 7b 10 35 1f 38 fd 	vmovsd xmm14,QWORD PTR [rip+0xfffffffffffd381f]        # 2002b8 <__unnamed_10+0x38>
  22ca98:	ff 
  22ca99:	c5 fb 10 2d cf 38 fd 	vmovsd xmm5,QWORD PTR [rip+0xfffffffffffd38cf]        # 200370 <__unnamed_609+0x30>
  22caa0:	ff 
  22caa1:	c4 c1 79 2e de       	vucomisd xmm3,xmm14
  22caa6:	76 47                	jbe    22caef <errol3+0x69f>
  22caa8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  22caaf:	00 
    hp.val /= 10.0;
  22cab0:	c4 c1 63 5e fe       	vdivsd xmm7,xmm3,xmm14
    hp.off /= 10.0;
  22cab5:	c4 c1 4b 5e f6       	vdivsd xmm6,xmm6,xmm14
    val -= hp.val * 8.0;
  22caba:	c5 c3 59 d5          	vmulsd xmm2,xmm7,xmm5
  22cabe:	c5 e3 58 d2          	vaddsd xmm2,xmm3,xmm2
    val -= hp.val * 2.0;
  22cac2:	c5 c3 58 df          	vaddsd xmm3,xmm7,xmm7
  22cac6:	c5 eb 5c d3          	vsubsd xmm2,xmm2,xmm3
    hp.off += val / 10.0;
  22caca:	c4 c1 6b 5e d6       	vdivsd xmm2,xmm2,xmm14
  22cacf:	c5 cb 58 d2          	vaddsd xmm2,xmm6,xmm2
    hp.val += hp.off;
  22cad3:	c5 c3 58 da          	vaddsd xmm3,xmm7,xmm2
    hp.off += val - hp.val;
  22cad7:	c5 c3 5c f3          	vsubsd xmm6,xmm7,xmm3
  22cadb:	c5 eb 58 f6          	vaddsd xmm6,xmm2,xmm6
        ten /= 10.0;
  22cadf:	c4 c1 5b 5e e6       	vdivsd xmm4,xmm4,xmm14
    while (mid.val > 10.0 or (mid.val == 10.0 and mid.off >= 0.0)) {
  22cae4:	41 83 c4 01          	add    r12d,0x1
  22cae8:	c4 c1 79 2e de       	vucomisd xmm3,xmm14
  22caed:	77 c1                	ja     22cab0 <errol3+0x660>
  22caef:	c5 f9 2e f1          	vucomisd xmm6,xmm1
  22caf3:	72 42                	jb     22cb37 <errol3+0x6e7>
  22caf5:	c4 c1 79 2e de       	vucomisd xmm3,xmm14
  22cafa:	75 3b                	jne    22cb37 <errol3+0x6e7>
  22cafc:	7b b2                	jnp    22cab0 <errol3+0x660>
  22cafe:	eb 37                	jmp    22cb37 <errol3+0x6e7>
    hp.val *= 10.0;
  22cb00:	c4 c1 63 59 ce       	vmulsd xmm1,xmm3,xmm14
    hp.off *= 10.0;
  22cb05:	c4 c1 4b 59 d6       	vmulsd xmm2,xmm6,xmm14
    off -= val * 8.0;
  22cb0a:	c5 e3 59 2d 5e 38 fd 	vmulsd xmm5,xmm3,QWORD PTR [rip+0xfffffffffffd385e]        # 200370 <__unnamed_609+0x30>
  22cb11:	ff 
  22cb12:	c5 f3 58 ed          	vaddsd xmm5,xmm1,xmm5
    off -= val * 2.0;
  22cb16:	c5 e3 58 db          	vaddsd xmm3,xmm3,xmm3
  22cb1a:	c5 d3 5c db          	vsubsd xmm3,xmm5,xmm3
    hp.off -= off;
  22cb1e:	c5 eb 5c d3          	vsubsd xmm2,xmm2,xmm3
    hp.val += hp.off;
  22cb22:	c5 f3 58 da          	vaddsd xmm3,xmm1,xmm2
    hp.off += val - hp.val;
  22cb26:	c5 f3 5c cb          	vsubsd xmm1,xmm1,xmm3
  22cb2a:	c5 eb 58 f1          	vaddsd xmm6,xmm2,xmm1
        ten *= 10.0;
  22cb2e:	c4 c1 5b 59 e6       	vmulsd xmm4,xmm4,xmm14
    while (mid.val < 1.0 or (mid.val == 1.0 and mid.off < 0.0)) {
  22cb33:	41 83 c4 ff          	add    r12d,0xffffffff
  22cb37:	c5 7b 10 0d 89 37 fd 	vmovsd xmm9,QWORD PTR [rip+0xfffffffffffd3789]        # 2002c8 <__unnamed_10+0x48>
  22cb3e:	ff 
  22cb3f:	c5 79 2e cb          	vucomisd xmm9,xmm3
  22cb43:	77 bb                	ja     22cb00 <errol3+0x6b0>
  22cb45:	c4 41 29 57 d2       	vxorpd xmm10,xmm10,xmm10
  22cb4a:	c5 79 2e d6          	vucomisd xmm10,xmm6
  22cb4e:	76 0c                	jbe    22cb5c <errol3+0x70c>
  22cb50:	c5 f9 2e 1d 70 37 fd 	vucomisd xmm3,QWORD PTR [rip+0xfffffffffffd3770]        # 2002c8 <__unnamed_10+0x48>
  22cb57:	ff 
  22cb58:	75 02                	jne    22cb5c <errol3+0x70c>
  22cb5a:	7b a4                	jnp    22cb00 <errol3+0x6b0>
    return @bitCast(f64, @bitCast(u64, val) +% 1);
  22cb5c:	48 8d 45 01          	lea    rax,[rbp+0x1]
  22cb60:	c4 e1 f9 6e c8       	vmovq  xmm1,rax
        .off = mid.off + (fpnext(val) - val) * lten * ten / 2.0,
  22cb65:	c4 c1 73 5c cb       	vsubsd xmm1,xmm1,xmm11
    return @bitCast(f64, @bitCast(u64, val) -% 1);
  22cb6a:	48 83 c5 ff          	add    rbp,0xffffffffffffffff
  22cb6e:	c4 e1 f9 6e d5       	vmovq  xmm2,rbp
        .off = mid.off + (fpprev(val) - val) * lten * ten / 2.0,
  22cb73:	c4 c1 6b 5c d3       	vsubsd xmm2,xmm2,xmm11
        .off = mid.off + (fpnext(val) - val) * lten * ten / 2.0,
  22cb78:	c5 f1 14 ca          	vunpcklpd xmm1,xmm1,xmm2
  22cb7c:	c4 c1 7b 12 d0       	vmovddup xmm2,xmm8
  22cb81:	c5 f1 59 ca          	vmulpd xmm1,xmm1,xmm2
  22cb85:	c5 fb 12 d4          	vmovddup xmm2,xmm4
  22cb89:	c5 f1 59 ca          	vmulpd xmm1,xmm1,xmm2
  22cb8d:	c5 f1 59 0d fb c3 fd 	vmulpd xmm1,xmm1,XMMWORD PTR [rip+0xfffffffffffdc3fb]        # 208f90 <__unnamed_43+0x10>
  22cb94:	ff 
  22cb95:	c5 fb 12 d6          	vmovddup xmm2,xmm6
  22cb99:	c5 e9 58 c9          	vaddpd xmm1,xmm2,xmm1
    hp.val += hp.off;
  22cb9d:	c5 e3 58 e1          	vaddsd xmm4,xmm3,xmm1
    hp.off += val - hp.val;
  22cba1:	c5 e3 5c d4          	vsubsd xmm2,xmm3,xmm4
  22cba5:	c5 e9 14 d3          	vunpcklpd xmm2,xmm2,xmm3
  22cba9:	c5 f1 58 d2          	vaddpd xmm2,xmm1,xmm2
  22cbad:	c4 e3 79 05 f2 01    	vpermilpd xmm6,xmm2,0x1
  22cbb3:	c5 e3 5c f6          	vsubsd xmm6,xmm3,xmm6
    while (high.val > 10.0 or (high.val == 10.0 and high.off >= 0.0)) {
  22cbb7:	c4 e3 79 05 c9 01    	vpermilpd xmm1,xmm1,0x1
  22cbbd:	c5 7b 10 1d bb 37 fd 	vmovsd xmm11,QWORD PTR [rip+0xfffffffffffd37bb]        # 200380 <__unnamed_609+0x40>
  22cbc4:	ff 
  22cbc5:	c5 79 28 05 03 c2 fd 	vmovapd xmm8,XMMWORD PTR [rip+0xfffffffffffdc203]        # 208dd0 <__unnamed_5+0x10>
  22cbcc:	ff 
    hp.off += val - hp.val;
  22cbcd:	c5 f3 58 ce          	vaddsd xmm1,xmm1,xmm6
    while (high.val > 10.0 or (high.val == 10.0 and high.off >= 0.0)) {
  22cbd1:	c4 c1 79 2e e6       	vucomisd xmm4,xmm14
  22cbd6:	0f 86 8a 00 00 00    	jbe    22cc66 <errol3+0x816>
  22cbdc:	eb 13                	jmp    22cbf1 <errol3+0x7a1>
  22cbde:	66 90                	xchg   ax,ax
  22cbe0:	c4 c1 79 2e e6       	vucomisd xmm4,xmm14
  22cbe5:	0f 85 86 00 00 00    	jne    22cc71 <errol3+0x821>
  22cbeb:	0f 8a 80 00 00 00    	jp     22cc71 <errol3+0x821>
    hp.val /= 10.0;
  22cbf1:	c4 c1 5b 5e f6       	vdivsd xmm6,xmm4,xmm14
    val -= hp.val * 8.0;
  22cbf6:	c4 c1 4b 59 eb       	vmulsd xmm5,xmm6,xmm11
    hp.val /= 10.0;
  22cbfb:	c4 e3 79 05 fa 01    	vpermilpd xmm7,xmm2,0x1
  22cc01:	c4 c1 43 5e fe       	vdivsd xmm7,xmm7,xmm14
    hp.off /= 10.0;
  22cc06:	c5 e9 14 c9          	vunpcklpd xmm1,xmm2,xmm1
  22cc0a:	c4 c1 71 5e c8       	vdivpd xmm1,xmm1,xmm8
    val -= hp.val * 8.0;
  22cc0f:	c4 c1 43 59 db       	vmulsd xmm3,xmm7,xmm11
  22cc14:	c4 e3 69 0d d4 01    	vblendpd xmm2,xmm2,xmm4,0x1
  22cc1a:	c5 d1 14 db          	vunpcklpd xmm3,xmm5,xmm3
  22cc1e:	c5 e9 5c d3          	vsubpd xmm2,xmm2,xmm3
    val -= hp.val * 2.0;
  22cc22:	c5 c9 14 df          	vunpcklpd xmm3,xmm6,xmm7
  22cc26:	c5 e1 58 db          	vaddpd xmm3,xmm3,xmm3
  22cc2a:	c5 e9 5c d3          	vsubpd xmm2,xmm2,xmm3
    hp.off += val / 10.0;
  22cc2e:	c4 c1 69 5e d0       	vdivpd xmm2,xmm2,xmm8
  22cc33:	c5 f1 58 ca          	vaddpd xmm1,xmm1,xmm2
    hp.val += hp.off;
  22cc37:	c5 cb 58 e1          	vaddsd xmm4,xmm6,xmm1
    hp.off += val - hp.val;
  22cc3b:	c5 cb 5c d4          	vsubsd xmm2,xmm6,xmm4
  22cc3f:	c5 e9 14 d7          	vunpcklpd xmm2,xmm2,xmm7
  22cc43:	c5 f1 58 d2          	vaddpd xmm2,xmm1,xmm2
  22cc47:	c4 e3 79 05 da 01    	vpermilpd xmm3,xmm2,0x1
  22cc4d:	c5 c3 5c f3          	vsubsd xmm6,xmm7,xmm3
    while (high.val > 10.0 or (high.val == 10.0 and high.off >= 0.0)) {
  22cc51:	c4 e3 79 05 c9 01    	vpermilpd xmm1,xmm1,0x1
  22cc57:	41 83 c4 01          	add    r12d,0x1
    hp.off += val - hp.val;
  22cc5b:	c5 f3 58 ce          	vaddsd xmm1,xmm1,xmm6
    while (high.val > 10.0 or (high.val == 10.0 and high.off >= 0.0)) {
  22cc5f:	c4 c1 79 2e e6       	vucomisd xmm4,xmm14
  22cc64:	77 8b                	ja     22cbf1 <errol3+0x7a1>
  22cc66:	c4 c1 79 2e d2       	vucomisd xmm2,xmm10
  22cc6b:	0f 83 6f ff ff ff    	jae    22cbe0 <errol3+0x790>
  22cc71:	c5 d9 14 e1          	vunpcklpd xmm4,xmm4,xmm1
  22cc75:	c5 79 28 25 53 c1 fd 	vmovapd xmm12,XMMWORD PTR [rip+0xfffffffffffdc153]        # 208dd0 <__unnamed_5+0x10>
  22cc7c:	ff 
  22cc7d:	c4 41 39 57 c0       	vxorpd xmm8,xmm8,xmm8
    while (high.val < 1.0 or (high.val == 1.0 and high.off < 0.0)) {
  22cc82:	c5 79 2e cc          	vucomisd xmm9,xmm4
  22cc86:	0f 86 7e 00 00 00    	jbe    22cd0a <errol3+0x8ba>
  22cc8c:	eb 0b                	jmp    22cc99 <errol3+0x849>
  22cc8e:	66 90                	xchg   ax,ax
  22cc90:	c4 c1 79 2e e1       	vucomisd xmm4,xmm9
  22cc95:	75 79                	jne    22cd10 <errol3+0x8c0>
  22cc97:	7a 77                	jp     22cd10 <errol3+0x8c0>
    hp.val *= 10.0;
  22cc99:	c4 c1 5b 59 ce       	vmulsd xmm1,xmm4,xmm14
    off -= val * 8.0;
  22cc9e:	c4 c1 5b 59 eb       	vmulsd xmm5,xmm4,xmm11
  22cca3:	c5 f3 5c ed          	vsubsd xmm5,xmm1,xmm5
    off -= val * 2.0;
  22cca7:	c5 db 58 fc          	vaddsd xmm7,xmm4,xmm4
  22ccab:	c5 d3 5c ef          	vsubsd xmm5,xmm5,xmm7
    hp.off *= 10.0;
  22ccaf:	c4 c1 69 59 fc       	vmulpd xmm7,xmm2,xmm12
  22ccb4:	c4 e3 79 05 e4 01    	vpermilpd xmm4,xmm4,0x1
  22ccba:	c4 c1 5b 59 e6       	vmulsd xmm4,xmm4,xmm14
    off -= val * 8.0;
  22ccbf:	c4 e3 79 05 d2 01    	vpermilpd xmm2,xmm2,0x1
  22ccc5:	c4 c1 6b 59 db       	vmulsd xmm3,xmm2,xmm11
  22ccca:	c4 e3 79 05 f7 01    	vpermilpd xmm6,xmm7,0x1
  22ccd0:	c5 cb 5c db          	vsubsd xmm3,xmm6,xmm3
    off -= val * 2.0;
  22ccd4:	c5 eb 58 d2          	vaddsd xmm2,xmm2,xmm2
  22ccd8:	c5 e3 5c d2          	vsubsd xmm2,xmm3,xmm2
    hp.off -= off;
  22ccdc:	c5 db 5c d2          	vsubsd xmm2,xmm4,xmm2
    hp.val += hp.off;
  22cce0:	c5 cb 58 da          	vaddsd xmm3,xmm6,xmm2
    hp.off -= off;
  22cce4:	c5 d1 14 e3          	vunpcklpd xmm4,xmm5,xmm3
  22cce8:	c5 c1 5c ec          	vsubpd xmm5,xmm7,xmm4
    hp.val += hp.off;
  22ccec:	c5 f1 14 d2          	vunpcklpd xmm2,xmm1,xmm2
  22ccf0:	c5 e9 58 e5          	vaddpd xmm4,xmm2,xmm5
    hp.off += val - hp.val;
  22ccf4:	c5 f3 5c cc          	vsubsd xmm1,xmm1,xmm4
  22ccf8:	c5 d3 58 c9          	vaddsd xmm1,xmm5,xmm1
  22ccfc:	c5 f1 14 d3          	vunpcklpd xmm2,xmm1,xmm3
    while (high.val < 1.0 or (high.val == 1.0 and high.off < 0.0)) {
  22cd00:	41 83 c4 ff          	add    r12d,0xffffffff
  22cd04:	c5 79 2e cc          	vucomisd xmm9,xmm4
  22cd08:	77 8f                	ja     22cc99 <errol3+0x849>
  22cd0a:	c5 79 2e c2          	vucomisd xmm8,xmm2
  22cd0e:	77 80                	ja     22cc90 <errol3+0x840>
    while (true) {
  22cd10:	c4 e3 79 05 ea 01    	vpermilpd xmm5,xmm2,0x1
  22cd16:	b8 01 00 00 00       	mov    eax,0x1
  22cd1b:	41 b8 34 0b 00 00    	mov    r8d,0xb34
  22cd21:	c4 41 10 57 ed       	vxorps xmm13,xmm13,xmm13
  22cd26:	c5 7b 10 0d aa 35 fd 	vmovsd xmm9,QWORD PTR [rip+0xfffffffffffd35aa]        # 2002d8 <__unnamed_10+0x58>
  22cd2d:	ff 
  22cd2e:	c5 7b 10 15 ea 35 fd 	vmovsd xmm10,QWORD PTR [rip+0xfffffffffffd35ea]        # 200320 <__unnamed_610+0x20>
  22cd35:	ff 
  22cd36:	c5 7b 10 05 ba 35 fd 	vmovsd xmm8,QWORD PTR [rip+0xfffffffffffd35ba]        # 2002f8 <__unnamed_600+0x10>
  22cd3d:	ff 
    if (e >= 0x3FF + 52 or x == 0) {
  22cd3e:	c4 c1 79 2e e5       	vucomisd xmm4,xmm13
  22cd43:	0f 85 ac 00 00 00    	jne    22cdf5 <errol3+0x9a5>
  22cd49:	0f 8a a6 00 00 00    	jp     22cdf5 <errol3+0x9a5>
  22cd4f:	e9 1c 01 00 00       	jmp    22ce70 <errol3+0xa20>
  22cd54:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  22cd5b:	00 00 00 00 00 
        buffer[buf_index] = hdig + '0';
  22cd60:	49 8b 0f             	mov    rcx,QWORD PTR [r15]
        high.val -= @intToFloat(f64, hdig);
  22cd63:	40 0f b6 d5          	movzx  edx,bpl
        buffer[buf_index] = hdig + '0';
  22cd67:	40 80 c5 30          	add    bpl,0x30
  22cd6b:	40 88 2c 01          	mov    BYTE PTR [rcx+rax*1],bpl
        buf_index += 1;
  22cd6f:	48 83 c0 01          	add    rax,0x1
        high.val -= @intToFloat(f64, hdig);
  22cd73:	c5 83 2a ca          	vcvtsi2sd xmm1,xmm15,edx
  22cd77:	c5 db 5c d9          	vsubsd xmm3,xmm4,xmm1
        low.val -= @intToFloat(f64, ldig);
  22cd7b:	c5 d3 5c c9          	vsubsd xmm1,xmm5,xmm1
    hp.val *= 10.0;
  22cd7f:	c4 c1 63 59 ee       	vmulsd xmm5,xmm3,xmm14
    off -= val * 8.0;
  22cd84:	c4 c1 63 59 e3       	vmulsd xmm4,xmm3,xmm11
  22cd89:	c5 d3 5c e4          	vsubsd xmm4,xmm5,xmm4
    off -= val * 2.0;
  22cd8d:	c5 e3 58 db          	vaddsd xmm3,xmm3,xmm3
    hp.off *= 10.0;
  22cd91:	c5 e9 14 d1          	vunpcklpd xmm2,xmm2,xmm1
  22cd95:	c4 c1 69 59 d4       	vmulpd xmm2,xmm2,xmm12
  22cd9a:	c4 c1 4b 59 f6       	vmulsd xmm6,xmm6,xmm14
    off -= val * 8.0;
  22cd9f:	c4 c1 73 59 fb       	vmulsd xmm7,xmm1,xmm11
  22cda4:	c4 e3 79 05 c2 01    	vpermilpd xmm0,xmm2,0x1
  22cdaa:	c5 fb 5c c7          	vsubsd xmm0,xmm0,xmm7
    off -= val * 2.0;
  22cdae:	c5 f3 58 c9          	vaddsd xmm1,xmm1,xmm1
  22cdb2:	c5 fb 5c c1          	vsubsd xmm0,xmm0,xmm1
    hp.off -= off;
  22cdb6:	c5 cb 5c c0          	vsubsd xmm0,xmm6,xmm0
    off -= val * 2.0;
  22cdba:	c4 e3 69 0d cc 01    	vblendpd xmm1,xmm2,xmm4,0x1
  22cdc0:	c5 e1 14 d8          	vunpcklpd xmm3,xmm3,xmm0
  22cdc4:	c5 f1 5c e3          	vsubpd xmm4,xmm1,xmm3
  22cdc8:	c5 f1 58 cb          	vaddpd xmm1,xmm1,xmm3
  22cdcc:	c4 e3 71 0d dc 01    	vblendpd xmm3,xmm1,xmm4,0x1
    hp.off -= off;
  22cdd2:	c5 e9 5c d3          	vsubpd xmm2,xmm2,xmm3
    hp.val += hp.off;
  22cdd6:	c5 d1 14 c0          	vunpcklpd xmm0,xmm5,xmm0
  22cdda:	c5 f9 58 e2          	vaddpd xmm4,xmm0,xmm2
    hp.off += val - hp.val;
  22cdde:	c5 d3 5c c4          	vsubsd xmm0,xmm5,xmm4
  22cde2:	c5 eb 58 d0          	vaddsd xmm2,xmm2,xmm0
    while (true) {
  22cde6:	c4 e3 79 05 e9 01    	vpermilpd xmm5,xmm1,0x1
  22cdec:	c4 c1 79 2e e5       	vucomisd xmm4,xmm13
  22cdf1:	75 02                	jne    22cdf5 <errol3+0x9a5>
  22cdf3:	7b 7b                	jnp    22ce70 <errol3+0xa20>
  22cdf5:	c4 e1 f9 7e e2       	vmovq  rdx,xmm4
  22cdfa:	c4 e2 b8 f7 f2       	bextr  rsi,rdx,r8
  22cdff:	c5 f9 28 cc          	vmovapd xmm1,xmm4
  22ce03:	48 81 fe 32 04 00 00 	cmp    rsi,0x432
  22ce0a:	77 68                	ja     22ce74 <errol3+0xa24>
    if (u >> 63 != 0) {
  22ce0c:	48 85 d2             	test   rdx,rdx
  22ce0f:	78 2f                	js     22ce40 <errol3+0x9f0>
  22ce11:	c4 c1 5b 58 ca       	vaddsd xmm1,xmm4,xmm10
  22ce16:	c4 c1 73 58 c9       	vaddsd xmm1,xmm1,xmm9
    if (e <= 0x3FF - 1) {
  22ce1b:	48 81 fe fe 03 00 00 	cmp    rsi,0x3fe
  22ce22:	76 2f                	jbe    22ce53 <errol3+0xa03>
  22ce24:	c5 f3 5c cc          	vsubsd xmm1,xmm1,xmm4
    } else if (y > 0) {
  22ce28:	c4 c1 79 2e cd       	vucomisd xmm1,xmm13
  22ce2d:	c5 db 58 c9          	vaddsd xmm1,xmm4,xmm1
  22ce31:	76 41                	jbe    22ce74 <errol3+0xa24>
        return x + y - 1;
  22ce33:	c4 c1 73 58 c8       	vaddsd xmm1,xmm1,xmm8
  22ce38:	eb 3a                	jmp    22ce74 <errol3+0xa24>
  22ce3a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  22ce40:	c4 c1 5b 58 c9       	vaddsd xmm1,xmm4,xmm9
  22ce45:	c4 c1 73 58 ca       	vaddsd xmm1,xmm1,xmm10
    if (e <= 0x3FF - 1) {
  22ce4a:	48 81 fe fe 03 00 00 	cmp    rsi,0x3fe
  22ce51:	77 d1                	ja     22ce24 <errol3+0x9d4>
        if (u >> 63 != 0) {
  22ce53:	c5 79 29 c1          	vmovapd xmm1,xmm8
    if (u >> 63 != 0) {
  22ce57:	48 85 d2             	test   rdx,rdx
        if (u >> 63 != 0) {
  22ce5a:	78 18                	js     22ce74 <errol3+0xa24>
  22ce5c:	c5 f1 57 c9          	vxorpd xmm1,xmm1,xmm1
  22ce60:	eb 12                	jmp    22ce74 <errol3+0xa24>
  22ce62:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  22ce69:	1f 84 00 00 00 00 00 
  22ce70:	c5 f9 28 cc          	vmovapd xmm1,xmm4
        var hdig = @floatToInt(u8, math.floor(high.val));
  22ce74:	c5 fb 2c d1          	vcvttsd2si edx,xmm1
        if ((high.val == @intToFloat(f64, hdig)) and (high.off < 0)) hdig -= 1;
  22ce78:	0f b6 ea             	movzx  ebp,dl
  22ce7b:	c5 83 2a cd          	vcvtsi2sd xmm1,xmm15,ebp
  22ce7f:	c5 f9 2e e1          	vucomisd xmm4,xmm1
  22ce83:	0f 9b c3             	setnp  bl
  22ce86:	0f 94 c1             	sete   cl
  22ce89:	20 d9                	and    cl,bl
  22ce8b:	c5 79 2e ea          	vucomisd xmm13,xmm2
  22ce8f:	0f 97 c3             	seta   bl
  22ce92:	20 cb                	and    bl,cl
  22ce94:	40 28 dd             	sub    bpl,bl
    if (e >= 0x3FF + 52 or x == 0) {
  22ce97:	c4 c1 79 2e ed       	vucomisd xmm5,xmm13
  22ce9c:	c5 f9 28 cd          	vmovapd xmm1,xmm5
  22cea0:	75 02                	jne    22cea4 <errol3+0xa54>
  22cea2:	7b 6c                	jnp    22cf10 <errol3+0xac0>
  22cea4:	c4 e1 f9 7e ee       	vmovq  rsi,xmm5
  22cea9:	c4 e2 b8 f7 fe       	bextr  rdi,rsi,r8
  22ceae:	c5 f9 28 cd          	vmovapd xmm1,xmm5
  22ceb2:	48 81 ff 32 04 00 00 	cmp    rdi,0x432
  22ceb9:	77 55                	ja     22cf10 <errol3+0xac0>
    if (u >> 63 != 0) {
  22cebb:	48 85 f6             	test   rsi,rsi
  22cebe:	78 30                	js     22cef0 <errol3+0xaa0>
  22cec0:	c4 c1 53 58 ca       	vaddsd xmm1,xmm5,xmm10
  22cec5:	c4 c1 73 58 c9       	vaddsd xmm1,xmm1,xmm9
    if (e <= 0x3FF - 1) {
  22ceca:	48 81 ff fe 03 00 00 	cmp    rdi,0x3fe
  22ced1:	76 30                	jbe    22cf03 <errol3+0xab3>
  22ced3:	c5 f3 5c cd          	vsubsd xmm1,xmm1,xmm5
    } else if (y > 0) {
  22ced7:	c4 c1 79 2e cd       	vucomisd xmm1,xmm13
  22cedc:	c5 d3 58 c9          	vaddsd xmm1,xmm5,xmm1
  22cee0:	76 2e                	jbe    22cf10 <errol3+0xac0>
        return x + y - 1;
  22cee2:	c4 c1 73 58 c8       	vaddsd xmm1,xmm1,xmm8
  22cee7:	eb 27                	jmp    22cf10 <errol3+0xac0>
  22cee9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  22cef0:	c4 c1 53 58 c9       	vaddsd xmm1,xmm5,xmm9
  22cef5:	c4 c1 73 58 ca       	vaddsd xmm1,xmm1,xmm10
    if (e <= 0x3FF - 1) {
  22cefa:	48 81 ff fe 03 00 00 	cmp    rdi,0x3fe
  22cf01:	77 d0                	ja     22ced3 <errol3+0xa83>
        if (u >> 63 != 0) {
  22cf03:	c5 79 29 c1          	vmovapd xmm1,xmm8
    if (u >> 63 != 0) {
  22cf07:	48 85 f6             	test   rsi,rsi
        if (u >> 63 != 0) {
  22cf0a:	78 04                	js     22cf10 <errol3+0xac0>
  22cf0c:	c5 f1 57 c9          	vxorpd xmm1,xmm1,xmm1
        var ldig = @floatToInt(u8, math.floor(low.val));
  22cf10:	c5 fb 2c c9          	vcvttsd2si ecx,xmm1
        if ((low.val == @intToFloat(f64, ldig)) and (low.off < 0)) ldig -= 1;
  22cf14:	0f b6 c9             	movzx  ecx,cl
  22cf17:	c5 83 2a c9          	vcvtsi2sd xmm1,xmm15,ecx
  22cf1b:	c5 f9 2e e9          	vucomisd xmm5,xmm1
  22cf1f:	40 0f 9b c6          	setnp  sil
  22cf23:	0f 94 c3             	sete   bl
  22cf26:	40 20 f3             	and    bl,sil
  22cf29:	c4 e3 79 05 f4 01    	vpermilpd xmm6,xmm4,0x1
  22cf2f:	c5 79 2e ee          	vucomisd xmm13,xmm6
  22cf33:	0f 97 c2             	seta   dl
  22cf36:	20 da                	and    dl,bl
  22cf38:	28 d1                	sub    cl,dl
        if (ldig != hdig) break;
  22cf3a:	40 38 e9             	cmp    cl,bpl
  22cf3d:	0f 84 1d fe ff ff    	je     22cd60 <errol3+0x910>
    const tmp = (high.val + low.val) / 2.0;
  22cf43:	c5 db 58 c5          	vaddsd xmm0,xmm4,xmm5
  22cf47:	c5 fb 10 0d b9 33 fd 	vmovsd xmm1,QWORD PTR [rip+0xfffffffffffd33b9]        # 200308 <__unnamed_610+0x8>
  22cf4e:	ff 
  22cf4f:	c5 fb 59 c1          	vmulsd xmm0,xmm0,xmm1
    var mdig = @floatToInt(u8, math.floor(tmp + 0.5));
  22cf53:	c5 fb 58 c9          	vaddsd xmm1,xmm0,xmm1
    if (e >= 0x3FF + 52 or x == 0) {
  22cf57:	c5 e9 57 d2          	vxorpd xmm2,xmm2,xmm2
  22cf5b:	c5 f9 2e ca          	vucomisd xmm1,xmm2
  22cf5f:	75 06                	jne    22cf67 <errol3+0xb17>
  22cf61:	0f 8b c0 03 00 00    	jnp    22d327 <errol3+0xed7>
  22cf67:	c4 e1 f9 7e c9       	vmovq  rcx,xmm1
  22cf6c:	ba 34 0b 00 00       	mov    edx,0xb34
  22cf71:	c4 e2 e8 f7 d1       	bextr  rdx,rcx,rdx
  22cf76:	48 81 fa 32 04 00 00 	cmp    rdx,0x432
  22cf7d:	0f 87 a4 03 00 00    	ja     22d327 <errol3+0xed7>
    if (u >> 63 != 0) {
  22cf83:	48 85 c9             	test   rcx,rcx
  22cf86:	0f 88 13 01 00 00    	js     22d09f <errol3+0xc4f>
  22cf8c:	c4 c1 73 58 d2       	vaddsd xmm2,xmm1,xmm10
  22cf91:	c4 c1 6b 58 d1       	vaddsd xmm2,xmm2,xmm9
    if (e <= 0x3FF - 1) {
  22cf96:	48 81 fa fe 03 00 00 	cmp    rdx,0x3fe
  22cf9d:	0f 86 13 01 00 00    	jbe    22d0b6 <errol3+0xc66>
  22cfa3:	c5 eb 5c d1          	vsubsd xmm2,xmm2,xmm1
    } else if (y > 0) {
  22cfa7:	c5 e1 57 db          	vxorpd xmm3,xmm3,xmm3
  22cfab:	c5 f9 2e d3          	vucomisd xmm2,xmm3
  22cfaf:	c5 f3 58 ca          	vaddsd xmm1,xmm1,xmm2
  22cfb3:	0f 86 6e 03 00 00    	jbe    22d327 <errol3+0xed7>
        return x + y - 1;
  22cfb9:	c5 f3 58 0d 37 33 fd 	vaddsd xmm1,xmm1,QWORD PTR [rip+0xfffffffffffd3337]        # 2002f8 <__unnamed_600+0x10>
  22cfc0:	ff 
  22cfc1:	e9 61 03 00 00       	jmp    22d327 <errol3+0xed7>
        while (i < mi) : (i += 1) {
  22cfc6:	45 89 d1             	mov    r9d,r10d
  22cfc9:	41 83 e1 f0          	and    r9d,0xfffffff0
  22cfcd:	41 8d 49 f0          	lea    ecx,[r9-0x10]
  22cfd1:	89 ca                	mov    edx,ecx
  22cfd3:	c1 ea 04             	shr    edx,0x4
  22cfd6:	44 8d 42 01          	lea    r8d,[rdx+0x1]
  22cfda:	83 f9 70             	cmp    ecx,0x70
  22cfdd:	0f 83 e5 00 00 00    	jae    22d0c8 <errol3+0xc78>
  22cfe3:	c4 e2 7d 59 0d 4c 33 	vpbroadcastq ymm1,QWORD PTR [rip+0xfffffffffffd334c]        # 200338 <app_mask+0x8>
  22cfea:	fd ff 
  22cfec:	c5 fd 6f d9          	vmovdqa ymm3,ymm1
  22cff0:	c5 fd 6f d1          	vmovdqa ymm2,ymm1
  22cff4:	c5 fd 6f c1          	vmovdqa ymm0,ymm1
  22cff8:	41 f6 c0 07          	test   r8b,0x7
  22cffc:	0f 85 61 01 00 00    	jne    22d163 <errol3+0xd13>
  22d002:	e9 d6 01 00 00       	jmp    22d1dd <errol3+0xd8d>
        while (buffer[j - 1] == '0') {
  22d007:	49 8b 07             	mov    rax,QWORD PTR [r15]
  22d00a:	42 80 7c 20 ff 30    	cmp    BYTE PTR [rax+r12*1-0x1],0x30
  22d010:	0f 85 ed 02 00 00    	jne    22d303 <errol3+0xeb3>
  22d016:	49 8d 4c 24 ff       	lea    rcx,[r12-0x1]
  22d01b:	4a 8d 14 20          	lea    rdx,[rax+r12*1]
  22d01f:	48 83 c2 ff          	add    rdx,0xffffffffffffffff
  22d023:	4c 89 e0             	mov    rax,r12
  22d026:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  22d02d:	00 00 00 
            buffer[j - 1] = 0;
  22d030:	c6 02 00             	mov    BYTE PTR [rdx],0x0
        while (buffer[j - 1] == '0') {
  22d033:	49 8b 37             	mov    rsi,QWORD PTR [r15]
  22d036:	48 8d 14 0e          	lea    rdx,[rsi+rcx*1]
  22d03a:	48 83 c2 ff          	add    rdx,0xffffffffffffffff
  22d03e:	48 83 c1 ff          	add    rcx,0xffffffffffffffff
  22d042:	80 7c 06 fe 30       	cmp    BYTE PTR [rsi+rax*1-0x2],0x30
  22d047:	48 8d 40 ff          	lea    rax,[rax-0x1]
  22d04b:	74 e3                	je     22d030 <errol3+0xbe0>
  22d04d:	e9 b4 02 00 00       	jmp    22d306 <errol3+0xeb6>
        } else if ((mid == 0.5) and (buffer[j - 1] & 0x1) != 0) {
  22d052:	0f 85 ae 02 00 00    	jne    22d306 <errol3+0xeb6>
  22d058:	0f 8a a8 02 00 00    	jp     22d306 <errol3+0xeb6>
  22d05e:	49 8b 17             	mov    rdx,QWORD PTR [r15]
  22d061:	8a 1c 0a             	mov    bl,BYTE PTR [rdx+rcx*1]
  22d064:	f6 c3 01             	test   bl,0x1
  22d067:	0f 84 99 02 00 00    	je     22d306 <errol3+0xeb6>
            buffer[j - 1] += 1;
  22d06d:	80 c3 01             	add    bl,0x1
  22d070:	88 1c 0a             	mov    BYTE PTR [rdx+rcx*1],bl
  22d073:	e9 8e 02 00 00       	jmp    22d306 <errol3+0xeb6>
  22d078:	c5 fb 58 d2          	vaddsd xmm2,xmm0,xmm2
  22d07c:	c5 eb 58 d3          	vaddsd xmm2,xmm2,xmm3
    if (e <= 0x3FF - 1) {
  22d080:	48 81 f9 fe 03 00 00 	cmp    rcx,0x3fe
  22d087:	0f 87 5d f8 ff ff    	ja     22c8ea <errol3+0x49a>
    if (u >> 63 != 0) {
  22d08d:	48 85 c0             	test   rax,rax
        if (u >> 63 != 0) {
  22d090:	0f 88 7c 02 00 00    	js     22d312 <errol3+0xec2>
  22d096:	c5 f9 57 c0          	vxorpd xmm0,xmm0,xmm0
  22d09a:	e9 56 f9 ff ff       	jmp    22c9f5 <errol3+0x5a5>
  22d09f:	c4 c1 73 58 d1       	vaddsd xmm2,xmm1,xmm9
  22d0a4:	c4 c1 6b 58 d2       	vaddsd xmm2,xmm2,xmm10
    if (e <= 0x3FF - 1) {
  22d0a9:	48 81 fa fe 03 00 00 	cmp    rdx,0x3fe
  22d0b0:	0f 87 ed fe ff ff    	ja     22cfa3 <errol3+0xb53>
    if (u >> 63 != 0) {
  22d0b6:	48 85 c9             	test   rcx,rcx
        if (u >> 63 != 0) {
  22d0b9:	0f 88 60 02 00 00    	js     22d31f <errol3+0xecf>
  22d0bf:	c5 f1 57 c9          	vxorpd xmm1,xmm1,xmm1
  22d0c3:	e9 5f 02 00 00       	jmp    22d327 <errol3+0xed7>
        while (i < mi) : (i += 1) {
  22d0c8:	44 89 c1             	mov    ecx,r8d
  22d0cb:	83 e1 07             	and    ecx,0x7
  22d0ce:	83 c1 ff             	add    ecx,0xffffffff
  22d0d1:	29 d1                	sub    ecx,edx
  22d0d3:	c4 e2 7d 59 0d 5c 32 	vpbroadcastq ymm1,QWORD PTR [rip+0xfffffffffffd325c]        # 200338 <app_mask+0x8>
  22d0da:	fd ff 
  22d0dc:	c4 e2 7d 59 25 eb 31 	vpbroadcastq ymm4,QWORD PTR [rip+0xfffffffffffd31eb]        # 2002d0 <__unnamed_10+0x50>
  22d0e3:	fd ff 
  22d0e5:	c5 fd 6f d9          	vmovdqa ymm3,ymm1
  22d0e9:	c5 fd 6f d1          	vmovdqa ymm2,ymm1
  22d0ed:	c5 fd 6f c1          	vmovdqa ymm0,ymm1
  22d0f1:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  22d0f8:	0f 1f 84 00 00 00 00 
  22d0ff:	00 
            x *= 10;
  22d100:	c5 f5 f4 ec          	vpmuludq ymm5,ymm1,ymm4
  22d104:	c5 f5 73 d1 20       	vpsrlq ymm1,ymm1,0x20
  22d109:	c5 f5 f4 cc          	vpmuludq ymm1,ymm1,ymm4
  22d10d:	c5 f5 73 f1 20       	vpsllq ymm1,ymm1,0x20
  22d112:	c5 d5 d4 c9          	vpaddq ymm1,ymm5,ymm1
  22d116:	c5 e5 f4 ec          	vpmuludq ymm5,ymm3,ymm4
  22d11a:	c5 e5 73 d3 20       	vpsrlq ymm3,ymm3,0x20
  22d11f:	c5 e5 f4 dc          	vpmuludq ymm3,ymm3,ymm4
  22d123:	c5 e5 73 f3 20       	vpsllq ymm3,ymm3,0x20
  22d128:	c5 d5 d4 db          	vpaddq ymm3,ymm5,ymm3
  22d12c:	c5 ed f4 ec          	vpmuludq ymm5,ymm2,ymm4
  22d130:	c5 ed 73 d2 20       	vpsrlq ymm2,ymm2,0x20
  22d135:	c5 ed f4 d4          	vpmuludq ymm2,ymm2,ymm4
  22d139:	c5 ed 73 f2 20       	vpsllq ymm2,ymm2,0x20
  22d13e:	c5 d5 d4 d2          	vpaddq ymm2,ymm5,ymm2
  22d142:	c5 fd f4 ec          	vpmuludq ymm5,ymm0,ymm4
  22d146:	c5 fd 73 d0 20       	vpsrlq ymm0,ymm0,0x20
  22d14b:	c5 fd f4 c4          	vpmuludq ymm0,ymm0,ymm4
  22d14f:	c5 fd 73 f0 20       	vpsllq ymm0,ymm0,0x20
  22d154:	c5 d5 d4 c0          	vpaddq ymm0,ymm5,ymm0
  22d158:	83 c1 08             	add    ecx,0x8
  22d15b:	75 a3                	jne    22d100 <errol3+0xcb0>
  22d15d:	41 f6 c0 07          	test   r8b,0x7
  22d161:	74 7a                	je     22d1dd <errol3+0xd8d>
  22d163:	44 89 d2             	mov    edx,r10d
  22d166:	83 e2 70             	and    edx,0x70
  22d169:	83 c2 f0             	add    edx,0xfffffff0
  22d16c:	c1 ea 04             	shr    edx,0x4
  22d16f:	83 c2 01             	add    edx,0x1
  22d172:	83 e2 07             	and    edx,0x7
  22d175:	f7 da                	neg    edx
  22d177:	c4 e2 7d 59 25 40 31 	vpbroadcastq ymm4,QWORD PTR [rip+0xfffffffffffd3140]        # 2002c0 <__unnamed_10+0x40>
  22d17e:	fd ff 
  22d180:	c5 f5 f4 ec          	vpmuludq ymm5,ymm1,ymm4
  22d184:	c5 f5 73 d1 20       	vpsrlq ymm1,ymm1,0x20
  22d189:	c5 f5 f4 cc          	vpmuludq ymm1,ymm1,ymm4
  22d18d:	c5 f5 73 f1 20       	vpsllq ymm1,ymm1,0x20
  22d192:	c5 d5 d4 c9          	vpaddq ymm1,ymm5,ymm1
  22d196:	c5 e5 f4 ec          	vpmuludq ymm5,ymm3,ymm4
  22d19a:	c5 e5 73 d3 20       	vpsrlq ymm3,ymm3,0x20
  22d19f:	c5 e5 f4 dc          	vpmuludq ymm3,ymm3,ymm4
  22d1a3:	c5 e5 73 f3 20       	vpsllq ymm3,ymm3,0x20
  22d1a8:	c5 d5 d4 db          	vpaddq ymm3,ymm5,ymm3
  22d1ac:	c5 ed f4 ec          	vpmuludq ymm5,ymm2,ymm4
  22d1b0:	c5 ed 73 d2 20       	vpsrlq ymm2,ymm2,0x20
  22d1b5:	c5 ed f4 d4          	vpmuludq ymm2,ymm2,ymm4
  22d1b9:	c5 ed 73 f2 20       	vpsllq ymm2,ymm2,0x20
  22d1be:	c5 d5 d4 d2          	vpaddq ymm2,ymm5,ymm2
  22d1c2:	c5 fd f4 ec          	vpmuludq ymm5,ymm0,ymm4
  22d1c6:	c5 fd 73 d0 20       	vpsrlq ymm0,ymm0,0x20
  22d1cb:	c5 fd f4 c4          	vpmuludq ymm0,ymm0,ymm4
  22d1cf:	c5 fd 73 f0 20       	vpsllq ymm0,ymm0,0x20
  22d1d4:	c5 d5 d4 c0          	vpaddq ymm0,ymm5,ymm0
  22d1d8:	83 c2 01             	add    edx,0x1
  22d1db:	75 a3                	jne    22d180 <errol3+0xd30>
  22d1dd:	c5 dd 73 d3 20       	vpsrlq ymm4,ymm3,0x20
  22d1e2:	c5 dd f4 e1          	vpmuludq ymm4,ymm4,ymm1
  22d1e6:	c5 d5 73 d1 20       	vpsrlq ymm5,ymm1,0x20
  22d1eb:	c5 e5 f4 ed          	vpmuludq ymm5,ymm3,ymm5
  22d1ef:	c5 d5 d4 e4          	vpaddq ymm4,ymm5,ymm4
  22d1f3:	c5 dd 73 f4 20       	vpsllq ymm4,ymm4,0x20
  22d1f8:	c5 e5 f4 c9          	vpmuludq ymm1,ymm3,ymm1
  22d1fc:	c5 f5 d4 cc          	vpaddq ymm1,ymm1,ymm4
  22d200:	c5 e5 73 d2 20       	vpsrlq ymm3,ymm2,0x20
  22d205:	c5 e5 f4 d9          	vpmuludq ymm3,ymm3,ymm1
  22d209:	c5 dd 73 d1 20       	vpsrlq ymm4,ymm1,0x20
  22d20e:	c5 ed f4 e4          	vpmuludq ymm4,ymm2,ymm4
  22d212:	c5 dd d4 db          	vpaddq ymm3,ymm4,ymm3
  22d216:	c5 e5 73 f3 20       	vpsllq ymm3,ymm3,0x20
  22d21b:	c5 ed f4 c9          	vpmuludq ymm1,ymm2,ymm1
  22d21f:	c5 f5 d4 cb          	vpaddq ymm1,ymm1,ymm3
  22d223:	c5 ed 73 d0 20       	vpsrlq ymm2,ymm0,0x20
  22d228:	c5 ed f4 d1          	vpmuludq ymm2,ymm2,ymm1
  22d22c:	c5 e5 73 d1 20       	vpsrlq ymm3,ymm1,0x20
  22d231:	c5 fd f4 db          	vpmuludq ymm3,ymm0,ymm3
  22d235:	c5 e5 d4 d2          	vpaddq ymm2,ymm3,ymm2
  22d239:	c5 ed 73 f2 20       	vpsllq ymm2,ymm2,0x20
  22d23e:	c5 fd f4 c1          	vpmuludq ymm0,ymm0,ymm1
  22d242:	c5 fd d4 c2          	vpaddq ymm0,ymm0,ymm2
  22d246:	c4 e3 7d 39 c1 01    	vextracti128 xmm1,ymm0,0x1
  22d24c:	c5 ed 73 d0 20       	vpsrlq ymm2,ymm0,0x20
  22d251:	c5 ed f4 d1          	vpmuludq ymm2,ymm2,ymm1
  22d255:	c5 e5 73 d1 20       	vpsrlq ymm3,ymm1,0x20
  22d25a:	c5 fd f4 db          	vpmuludq ymm3,ymm0,ymm3
  22d25e:	c5 e5 d4 d2          	vpaddq ymm2,ymm3,ymm2
  22d262:	c5 ed 73 f2 20       	vpsllq ymm2,ymm2,0x20
  22d267:	c5 fd f4 c1          	vpmuludq ymm0,ymm0,ymm1
  22d26b:	c5 fd d4 c2          	vpaddq ymm0,ymm0,ymm2
  22d26f:	c5 f9 70 c8 4e       	vpshufd xmm1,xmm0,0x4e
  22d274:	c5 ed 73 d0 20       	vpsrlq ymm2,ymm0,0x20
  22d279:	c5 ed f4 d1          	vpmuludq ymm2,ymm2,ymm1
  22d27d:	c5 e5 73 d1 20       	vpsrlq ymm3,ymm1,0x20
  22d282:	c5 fd f4 db          	vpmuludq ymm3,ymm0,ymm3
  22d286:	c5 e5 d4 d2          	vpaddq ymm2,ymm3,ymm2
  22d28a:	c5 ed 73 f2 20       	vpsllq ymm2,ymm2,0x20
  22d28f:	c5 fd f4 c1          	vpmuludq ymm0,ymm0,ymm1
  22d293:	c5 fd d4 c2          	vpaddq ymm0,ymm0,ymm2
  22d297:	c4 e1 f9 7e c2       	vmovq  rdx,xmm0
  22d29c:	45 39 ca             	cmp    r10d,r9d
        while (i < mi) : (i += 1) {
  22d29f:	74 1b                	je     22d2bc <errol3+0xe6c>
  22d2a1:	41 09 c1             	or     r9d,eax
  22d2a4:	44 89 c8             	mov    eax,r9d
            x *= 10;
  22d2a7:	f7 d8                	neg    eax
  22d2a9:	29 d8                	sub    eax,ebx
  22d2ab:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  22d2b0:	48 01 d2             	add    rdx,rdx
  22d2b3:	48 8d 14 92          	lea    rdx,[rdx+rdx*4]
        while (i < mi) : (i += 1) {
  22d2b7:	83 c0 ff             	add    eax,0xffffffff
  22d2ba:	75 f4                	jne    22d2b0 <errol3+0xe60>
    const m64 = @truncate(u64, @divTrunc(mid, x));
  22d2bc:	31 c9                	xor    ecx,ecx
  22d2be:	c5 f8 77             	vzeroupper 
  22d2c1:	e8 2a 48 00 00       	call   231af0 <__udivti3>
    if (lf != hf) {
  22d2c6:	4d 39 f5             	cmp    r13,r14
    if (lf != hf) mi += 19;
  22d2c9:	44 0f 45 e5          	cmovne r12d,ebp
    var buf_index = u64toa(m64, buffer) - 1;
  22d2cd:	48 89 c7             	mov    rdi,rax
  22d2d0:	4c 89 fe             	mov    rsi,r15
  22d2d3:	e8 a8 00 00 00       	call   22d380 <u64toa>
    if (mi != 0) {
  22d2d8:	45 85 e4             	test   r12d,r12d
  22d2db:	74 19                	je     22d2f6 <errol3+0xea6>
  22d2dd:	48 89 c1             	mov    rcx,rax
  22d2e0:	48 83 c1 ff          	add    rcx,0xffffffffffffffff
        buffer[buf_index - 1] += @boolToInt(buffer[buf_index] >= '5');
  22d2e4:	49 8b 17             	mov    rdx,QWORD PTR [r15]
  22d2e7:	80 7c 02 ff 34       	cmp    BYTE PTR [rdx+rax*1-0x1],0x34
  22d2ec:	0f 97 c3             	seta   bl
  22d2ef:	00 5c 02 fe          	add    BYTE PTR [rdx+rax*1-0x2],bl
  22d2f3:	48 89 c8             	mov    rax,rcx
  22d2f6:	4c 8b 74 24 20       	mov    r14,QWORD PTR [rsp+0x20]
        .digits = buffer[0..buf_index],
  22d2fb:	49 8b 0f             	mov    rcx,QWORD PTR [r15]
        .exp = @intCast(i32, buf_index) + mi,
  22d2fe:	41 01 c4             	add    r12d,eax
  22d301:	eb 57                	jmp    22d35a <errol3+0xf0a>
  22d303:	4c 89 e0             	mov    rax,r12
    buffer[j] = 0;
  22d306:	49 8b 0f             	mov    rcx,QWORD PTR [r15]
  22d309:	c6 04 01 00          	mov    BYTE PTR [rcx+rax*1],0x0
        .digits = buffer[0..j],
  22d30d:	49 8b 0f             	mov    rcx,QWORD PTR [r15]
  22d310:	eb 48                	jmp    22d35a <errol3+0xf0a>
  22d312:	c5 fb 10 05 de 2f fd 	vmovsd xmm0,QWORD PTR [rip+0xfffffffffffd2fde]        # 2002f8 <__unnamed_600+0x10>
  22d319:	ff 
  22d31a:	e9 d6 f6 ff ff       	jmp    22c9f5 <errol3+0x5a5>
  22d31f:	c5 fb 10 0d d1 2f fd 	vmovsd xmm1,QWORD PTR [rip+0xfffffffffffd2fd1]        # 2002f8 <__unnamed_600+0x10>
  22d326:	ff 
    var mdig = @floatToInt(u8, math.floor(tmp + 0.5));
  22d327:	c5 fb 2c c9          	vcvttsd2si ecx,xmm1
    if ((@intToFloat(f64, mdig) - tmp) == 0.5 and (mdig & 0x1) != 0) mdig -= 1;
  22d32b:	0f b6 c9             	movzx  ecx,cl
  22d32e:	c5 83 2a c9          	vcvtsi2sd xmm1,xmm15,ecx
  22d332:	c5 f3 5c c0          	vsubsd xmm0,xmm1,xmm0
  22d336:	c5 f9 2e 05 ca 2f fd 	vucomisd xmm0,QWORD PTR [rip+0xfffffffffffd2fca]        # 200308 <__unnamed_610+0x8>
  22d33d:	ff 
  22d33e:	0f 9b c2             	setnp  dl
  22d341:	0f 94 c3             	sete   bl
  22d344:	20 d3                	and    bl,dl
  22d346:	20 cb                	and    bl,cl
    buffer[buf_index] = mdig + '0';
  22d348:	49 8b 17             	mov    rdx,QWORD PTR [r15]
    if ((@intToFloat(f64, mdig) - tmp) == 0.5 and (mdig & 0x1) != 0) mdig -= 1;
  22d34b:	28 d9                	sub    cl,bl
    buffer[buf_index] = mdig + '0';
  22d34d:	80 c1 30             	add    cl,0x30
  22d350:	88 0c 02             	mov    BYTE PTR [rdx+rax*1],cl
        .digits = buffer[1..buf_index],
  22d353:	49 8b 0f             	mov    rcx,QWORD PTR [r15]
  22d356:	48 83 c1 01          	add    rcx,0x1
    return errol3u(value, buffer);
  22d35a:	49 89 0e             	mov    QWORD PTR [r14],rcx
  22d35d:	49 89 46 08          	mov    QWORD PTR [r14+0x8],rax
  22d361:	45 89 66 10          	mov    DWORD PTR [r14+0x10],r12d
  22d365:	48 83 c4 68          	add    rsp,0x68
  22d369:	5b                   	pop    rbx
  22d36a:	41 5c                	pop    r12
  22d36c:	41 5d                	pop    r13
  22d36e:	41 5e                	pop    r14
  22d370:	41 5f                	pop    r15
  22d372:	5d                   	pop    rbp
  22d373:	c3                   	ret    
            @panic("assertion failure");
  22d374:	48 8d 3d 8d 19 02 00 	lea    rdi,[rip+0x2198d]        # 24ed08 <__unnamed_2>
  22d37b:	e8 a0 4c fe ff       	call   212020 <panic>

000000000022d380 <u64toa>:
    if (value < kTen8) {
  22d380:	41 57                	push   r15
  22d382:	41 56                	push   r14
  22d384:	53                   	push   rbx
  22d385:	48 81 ff ff e0 f5 05 	cmp    rdi,0x5f5e0ff
  22d38c:	77 4b                	ja     22d3d9 <u64toa+0x59>
            const b: u32 = v / 10000;
  22d38e:	89 f8                	mov    eax,edi
        if (v < 10000) {
  22d390:	81 ff 0f 27 00 00    	cmp    edi,0x270f
  22d396:	0f 87 48 01 00 00    	ja     22d4e4 <u64toa+0x164>
            const d1: u32 = (v / 100) << 1;
  22d39c:	48 69 d0 1f 85 eb 51 	imul   rdx,rax,0x51eb851f
  22d3a3:	48 c1 ea 25          	shr    rdx,0x25
            const d2: u32 = (v % 100) << 1;
  22d3a7:	6b c2 64             	imul   eax,edx,0x64
            const d1: u32 = (v / 100) << 1;
  22d3aa:	48 01 d2             	add    rdx,rdx
            const d2: u32 = (v % 100) << 1;
  22d3ad:	89 f9                	mov    ecx,edi
  22d3af:	29 c1                	sub    ecx,eax
  22d3b1:	48 01 c9             	add    rcx,rcx
            if (v >= 1000) {
  22d3b4:	81 ff e8 03 00 00    	cmp    edi,0x3e8
  22d3ba:	0f 82 bf 01 00 00    	jb     22d57f <u64toa+0x1ff>
                buffer[buf_index] = c_digits_lut[d1];
  22d3c0:	48 8b 06             	mov    rax,QWORD PTR [rsi]
  22d3c3:	48 8d 3d d6 7f fd ff 	lea    rdi,[rip+0xfffffffffffd7fd6]        # 2053a0 <c_digits_lut>
  22d3ca:	8a 1c 3a             	mov    bl,BYTE PTR [rdx+rdi*1]
  22d3cd:	88 18                	mov    BYTE PTR [rax],bl
  22d3cf:	b8 01 00 00 00       	mov    eax,0x1
  22d3d4:	e9 b1 01 00 00       	jmp    22d58a <u64toa+0x20a>
  22d3d9:	48 b9 00 00 c1 6f f2 	movabs rcx,0x2386f26fc10000
  22d3e0:	86 23 00 
    } else if (value < kTen16) {
  22d3e3:	48 39 cf             	cmp    rdi,rcx
  22d3e6:	0f 83 71 01 00 00    	jae    22d55d <u64toa+0x1dd>
        const v0: u32 = @intCast(u32, value / kTen8);
  22d3ec:	48 b8 fd ce 61 84 11 	movabs rax,0xabcc77118461cefd
  22d3f3:	77 cc ab 
  22d3f6:	48 89 fa             	mov    rdx,rdi
  22d3f9:	c4 62 fb f6 f8       	mulx   r15,rax,rax
  22d3fe:	49 c1 ef 1a          	shr    r15,0x1a
        const v1: u32 = @intCast(u32, value % kTen8);
  22d402:	49 69 cf 00 e1 f5 05 	imul   rcx,r15,0x5f5e100
  22d409:	48 89 f8             	mov    rax,rdi
  22d40c:	48 29 c8             	sub    rax,rcx
        const b0: u32 = v0 / 10000;
  22d40f:	44 89 fb             	mov    ebx,r15d
  22d412:	41 be 59 17 b7 d1    	mov    r14d,0xd1b71759
        const d1: u32 = (b0 / 100) << 1;
  22d418:	48 69 cb 83 de 1b 43 	imul   rcx,rbx,0x431bde83
        const b0: u32 = v0 / 10000;
  22d41f:	49 0f af de          	imul   rbx,r14
  22d423:	48 c1 eb 2d          	shr    rbx,0x2d
        const c0: u32 = v0 % 10000;
  22d427:	69 d3 10 27 00 00    	imul   edx,ebx,0x2710
  22d42d:	41 29 d7             	sub    r15d,edx
        const d1: u32 = (b0 / 100) << 1;
  22d430:	48 c1 e9 31          	shr    rcx,0x31
  22d434:	81 e1 fe 3f 00 00    	and    ecx,0x3ffe
        const d2: u32 = (b0 % 100) << 1;
  22d43a:	48 69 d3 1f 85 eb 51 	imul   rdx,rbx,0x51eb851f
  22d441:	48 c1 ea 25          	shr    rdx,0x25
  22d445:	6b d2 64             	imul   edx,edx,0x64
  22d448:	29 d3                	sub    ebx,edx
  22d44a:	48 01 db             	add    rbx,rbx
        const d3: u32 = (c0 / 100) << 1;
  22d44d:	4d 69 df 1f 85 eb 51 	imul   r11,r15,0x51eb851f
  22d454:	49 c1 eb 25          	shr    r11,0x25
        const d4: u32 = (c0 % 100) << 1;
  22d458:	41 6b d3 64          	imul   edx,r11d,0x64
        const d3: u32 = (c0 / 100) << 1;
  22d45c:	4d 01 db             	add    r11,r11
        const d4: u32 = (c0 % 100) << 1;
  22d45f:	41 29 d7             	sub    r15d,edx
  22d462:	4d 01 ff             	add    r15,r15
        const b1: u32 = v1 / 10000;
  22d465:	4c 0f af f0          	imul   r14,rax
  22d469:	49 c1 ee 2d          	shr    r14,0x2d
        const c1: u32 = v1 % 10000;
  22d46d:	41 69 d6 10 27 00 00 	imul   edx,r14d,0x2710
        const d5: u32 = (b1 / 100) << 1;
  22d474:	4c 69 c8 83 de 1b 43 	imul   r9,rax,0x431bde83
        const c1: u32 = v1 % 10000;
  22d47b:	41 89 c0             	mov    r8d,eax
  22d47e:	41 29 d0             	sub    r8d,edx
        const d5: u32 = (b1 / 100) << 1;
  22d481:	49 c1 e9 31          	shr    r9,0x31
  22d485:	41 81 e1 fe 01 00 00 	and    r9d,0x1fe
        const d6: u32 = (b1 % 100) << 1;
  22d48c:	49 69 c6 1f 85 eb 51 	imul   rax,r14,0x51eb851f
  22d493:	48 c1 e8 25          	shr    rax,0x25
  22d497:	6b c0 64             	imul   eax,eax,0x64
  22d49a:	41 29 c6             	sub    r14d,eax
  22d49d:	4d 01 f6             	add    r14,r14
        const d7: u32 = (c1 / 100) << 1;
  22d4a0:	4d 69 d0 1f 85 eb 51 	imul   r10,r8,0x51eb851f
  22d4a7:	49 c1 ea 25          	shr    r10,0x25
        const d8: u32 = (c1 % 100) << 1;
  22d4ab:	41 6b c2 64          	imul   eax,r10d,0x64
        const d7: u32 = (c1 / 100) << 1;
  22d4af:	4d 01 d2             	add    r10,r10
        const d8: u32 = (c1 % 100) << 1;
  22d4b2:	41 29 c0             	sub    r8d,eax
  22d4b5:	4d 01 c0             	add    r8,r8
        if (value >= kTen15) {
  22d4b8:	48 b8 00 80 c6 a4 7e 	movabs rax,0x38d7ea4c68000
  22d4bf:	8d 03 00 
  22d4c2:	48 39 c7             	cmp    rdi,rax
  22d4c5:	0f 82 07 01 00 00    	jb     22d5d2 <u64toa+0x252>
            buffer[buf_index] = c_digits_lut[d1];
  22d4cb:	48 8b 06             	mov    rax,QWORD PTR [rsi]
  22d4ce:	48 8d 15 cb 7e fd ff 	lea    rdx,[rip+0xfffffffffffd7ecb]        # 2053a0 <c_digits_lut>
  22d4d5:	8a 14 11             	mov    dl,BYTE PTR [rcx+rdx*1]
  22d4d8:	88 10                	mov    BYTE PTR [rax],dl
  22d4da:	b8 01 00 00 00       	mov    eax,0x1
  22d4df:	e9 03 01 00 00       	jmp    22d5e7 <u64toa+0x267>
            const b: u32 = v / 10000;
  22d4e4:	ba 59 17 b7 d1       	mov    edx,0xd1b71759
  22d4e9:	48 0f af d0          	imul   rdx,rax
  22d4ed:	48 c1 ea 2d          	shr    rdx,0x2d
            const c: u32 = v % 10000;
  22d4f1:	69 da 10 27 00 00    	imul   ebx,edx,0x2710
  22d4f7:	89 f9                	mov    ecx,edi
  22d4f9:	29 d9                	sub    ecx,ebx
            const d1: u32 = (b / 100) << 1;
  22d4fb:	48 69 d8 83 de 1b 43 	imul   rbx,rax,0x431bde83
  22d502:	48 c1 eb 31          	shr    rbx,0x31
            const d2: u32 = (b % 100) << 1;
  22d506:	48 69 c2 1f 85 eb 51 	imul   rax,rdx,0x51eb851f
  22d50d:	48 c1 e8 25          	shr    rax,0x25
  22d511:	6b c0 64             	imul   eax,eax,0x64
            const d1: u32 = (b / 100) << 1;
  22d514:	81 e3 fe 3f 00 00    	and    ebx,0x3ffe
            const d2: u32 = (b % 100) << 1;
  22d51a:	29 c2                	sub    edx,eax
  22d51c:	48 01 d2             	add    rdx,rdx
            const d3: u32 = (c / 100) << 1;
  22d51f:	4c 69 c1 1f 85 eb 51 	imul   r8,rcx,0x51eb851f
  22d526:	49 c1 e8 25          	shr    r8,0x25
            const d4: u32 = (c % 100) << 1;
  22d52a:	41 6b c0 64          	imul   eax,r8d,0x64
            const d3: u32 = (c / 100) << 1;
  22d52e:	4d 01 c0             	add    r8,r8
            const d4: u32 = (c % 100) << 1;
  22d531:	29 c1                	sub    ecx,eax
  22d533:	48 01 c9             	add    rcx,rcx
            if (value >= 10000000) {
  22d536:	48 81 ff 80 96 98 00 	cmp    rdi,0x989680
  22d53d:	0f 82 b0 01 00 00    	jb     22d6f3 <u64toa+0x373>
                buffer[buf_index] = c_digits_lut[d1];
  22d543:	4c 8b 0e             	mov    r9,QWORD PTR [rsi]
  22d546:	48 8d 3d 53 7e fd ff 	lea    rdi,[rip+0xfffffffffffd7e53]        # 2053a0 <c_digits_lut>
  22d54d:	8a 04 3b             	mov    al,BYTE PTR [rbx+rdi*1]
  22d550:	41 88 01             	mov    BYTE PTR [r9],al
  22d553:	b8 01 00 00 00       	mov    eax,0x1
  22d558:	e9 a5 01 00 00       	jmp    22d702 <u64toa+0x382>
        value %= kTen16;
  22d55d:	31 d2                	xor    edx,edx
  22d55f:	48 89 f8             	mov    rax,rdi
  22d562:	48 f7 f1             	div    rcx
        if (a < 10) {
  22d565:	83 f8 09             	cmp    eax,0x9
  22d568:	0f 87 0e 02 00 00    	ja     22d77c <u64toa+0x3fc>
            buffer[buf_index] = '0' + @intCast(u8, a);
  22d56e:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  22d571:	04 30                	add    al,0x30
  22d573:	88 01                	mov    BYTE PTR [rcx],al
  22d575:	b8 01 00 00 00       	mov    eax,0x1
  22d57a:	e9 06 03 00 00       	jmp    22d885 <u64toa+0x505>
  22d57f:	31 c0                	xor    eax,eax
            if (v >= 100) {
  22d581:	83 ff 64             	cmp    edi,0x64
  22d584:	0f 82 21 02 00 00    	jb     22d7ab <u64toa+0x42b>
                buffer[buf_index] = c_digits_lut[d1 + 1];
  22d58a:	48 8b 3e             	mov    rdi,QWORD PTR [rsi]
  22d58d:	83 ca 01             	or     edx,0x1
  22d590:	48 8d 1d 09 7e fd ff 	lea    rbx,[rip+0xfffffffffffd7e09]        # 2053a0 <c_digits_lut>
  22d597:	8a 14 1a             	mov    dl,BYTE PTR [rdx+rbx*1]
  22d59a:	88 14 07             	mov    BYTE PTR [rdi+rax*1],dl
                buf_index += 1;
  22d59d:	48 83 c0 01          	add    rax,0x1
                buffer[buf_index] = c_digits_lut[d2];
  22d5a1:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  22d5a4:	48 8d 3d f5 7d fd ff 	lea    rdi,[rip+0xfffffffffffd7df5]        # 2053a0 <c_digits_lut>
  22d5ab:	8a 1c 39             	mov    bl,BYTE PTR [rcx+rdi*1]
  22d5ae:	88 1c 02             	mov    BYTE PTR [rdx+rax*1],bl
                buf_index += 1;
  22d5b1:	48 83 c0 01          	add    rax,0x1
            buffer[buf_index] = c_digits_lut[d2 + 1];
  22d5b5:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  22d5b8:	83 c9 01             	or     ecx,0x1
  22d5bb:	48 8d 35 de 7d fd ff 	lea    rsi,[rip+0xfffffffffffd7dde]        # 2053a0 <c_digits_lut>
  22d5c2:	8a 0c 31             	mov    cl,BYTE PTR [rcx+rsi*1]
  22d5c5:	88 0c 02             	mov    BYTE PTR [rdx+rax*1],cl
            buf_index += 1;
  22d5c8:	48 83 c0 01          	add    rax,0x1
    return buf_index;
  22d5cc:	5b                   	pop    rbx
  22d5cd:	41 5e                	pop    r14
  22d5cf:	41 5f                	pop    r15
  22d5d1:	c3                   	ret    
        if (value >= kTen14) {
  22d5d2:	48 b8 00 40 7a 10 f3 	movabs rax,0x5af3107a4000
  22d5d9:	5a 00 00 
  22d5dc:	48 39 c7             	cmp    rdi,rax
  22d5df:	0f 82 d4 01 00 00    	jb     22d7b9 <u64toa+0x439>
  22d5e5:	31 c0                	xor    eax,eax
            buffer[buf_index] = c_digits_lut[d1 + 1];
  22d5e7:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  22d5ea:	83 c9 01             	or     ecx,0x1
  22d5ed:	48 8d 3d ac 7d fd ff 	lea    rdi,[rip+0xfffffffffffd7dac]        # 2053a0 <c_digits_lut>
  22d5f4:	8a 0c 39             	mov    cl,BYTE PTR [rcx+rdi*1]
  22d5f7:	88 0c 02             	mov    BYTE PTR [rdx+rax*1],cl
            buf_index += 1;
  22d5fa:	48 83 c0 01          	add    rax,0x1
            buffer[buf_index] = c_digits_lut[d2];
  22d5fe:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  22d601:	48 8d 15 98 7d fd ff 	lea    rdx,[rip+0xfffffffffffd7d98]        # 2053a0 <c_digits_lut>
  22d608:	8a 14 13             	mov    dl,BYTE PTR [rbx+rdx*1]
  22d60b:	88 14 01             	mov    BYTE PTR [rcx+rax*1],dl
            buf_index += 1;
  22d60e:	48 83 c0 01          	add    rax,0x1
            buffer[buf_index] = c_digits_lut[d2 + 1];
  22d612:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  22d615:	83 cb 01             	or     ebx,0x1
  22d618:	48 8d 15 81 7d fd ff 	lea    rdx,[rip+0xfffffffffffd7d81]        # 2053a0 <c_digits_lut>
  22d61f:	8a 14 13             	mov    dl,BYTE PTR [rbx+rdx*1]
  22d622:	88 14 01             	mov    BYTE PTR [rcx+rax*1],dl
            buf_index += 1;
  22d625:	48 83 c0 01          	add    rax,0x1
            buffer[buf_index] = c_digits_lut[d3];
  22d629:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  22d62c:	48 8d 15 6d 7d fd ff 	lea    rdx,[rip+0xfffffffffffd7d6d]        # 2053a0 <c_digits_lut>
  22d633:	41 8a 14 13          	mov    dl,BYTE PTR [r11+rdx*1]
  22d637:	88 14 01             	mov    BYTE PTR [rcx+rax*1],dl
            buf_index += 1;
  22d63a:	48 83 c0 01          	add    rax,0x1
            buffer[buf_index] = c_digits_lut[d3 + 1];
  22d63e:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  22d641:	41 83 cb 01          	or     r11d,0x1
  22d645:	48 8d 15 54 7d fd ff 	lea    rdx,[rip+0xfffffffffffd7d54]        # 2053a0 <c_digits_lut>
  22d64c:	41 8a 14 13          	mov    dl,BYTE PTR [r11+rdx*1]
  22d650:	88 14 01             	mov    BYTE PTR [rcx+rax*1],dl
            buf_index += 1;
  22d653:	48 83 c0 01          	add    rax,0x1
            buffer[buf_index] = c_digits_lut[d4];
  22d657:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  22d65a:	48 8d 15 3f 7d fd ff 	lea    rdx,[rip+0xfffffffffffd7d3f]        # 2053a0 <c_digits_lut>
  22d661:	41 8a 14 17          	mov    dl,BYTE PTR [r15+rdx*1]
  22d665:	88 14 01             	mov    BYTE PTR [rcx+rax*1],dl
            buf_index += 1;
  22d668:	48 83 c0 01          	add    rax,0x1
            buffer[buf_index] = c_digits_lut[d4 + 1];
  22d66c:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  22d66f:	41 83 cf 01          	or     r15d,0x1
  22d673:	48 8d 0d 26 7d fd ff 	lea    rcx,[rip+0xfffffffffffd7d26]        # 2053a0 <c_digits_lut>
  22d67a:	41 8a 1c 0f          	mov    bl,BYTE PTR [r15+rcx*1]
  22d67e:	88 1c 02             	mov    BYTE PTR [rdx+rax*1],bl
        buffer[buf_index] = c_digits_lut[d5];
  22d681:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  22d684:	41 8a 1c 09          	mov    bl,BYTE PTR [r9+rcx*1]
  22d688:	88 5c 02 01          	mov    BYTE PTR [rdx+rax*1+0x1],bl
        buffer[buf_index] = c_digits_lut[d5 + 1];
  22d68c:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  22d68f:	41 83 c9 01          	or     r9d,0x1
  22d693:	41 8a 1c 09          	mov    bl,BYTE PTR [r9+rcx*1]
  22d697:	88 5c 02 02          	mov    BYTE PTR [rdx+rax*1+0x2],bl
        buffer[buf_index] = c_digits_lut[d6];
  22d69b:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  22d69e:	41 8a 1c 0e          	mov    bl,BYTE PTR [r14+rcx*1]
  22d6a2:	88 5c 02 03          	mov    BYTE PTR [rdx+rax*1+0x3],bl
        buffer[buf_index] = c_digits_lut[d6 + 1];
  22d6a6:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  22d6a9:	41 83 ce 01          	or     r14d,0x1
  22d6ad:	41 8a 1c 0e          	mov    bl,BYTE PTR [r14+rcx*1]
  22d6b1:	88 5c 02 04          	mov    BYTE PTR [rdx+rax*1+0x4],bl
        buffer[buf_index] = c_digits_lut[d7];
  22d6b5:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  22d6b8:	41 8a 1c 0a          	mov    bl,BYTE PTR [r10+rcx*1]
  22d6bc:	88 5c 02 05          	mov    BYTE PTR [rdx+rax*1+0x5],bl
        buffer[buf_index] = c_digits_lut[d7 + 1];
  22d6c0:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  22d6c3:	41 83 ca 01          	or     r10d,0x1
  22d6c7:	41 8a 1c 0a          	mov    bl,BYTE PTR [r10+rcx*1]
  22d6cb:	88 5c 02 06          	mov    BYTE PTR [rdx+rax*1+0x6],bl
        buffer[buf_index] = c_digits_lut[d8];
  22d6cf:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  22d6d2:	41 8a 1c 08          	mov    bl,BYTE PTR [r8+rcx*1]
  22d6d6:	88 5c 02 07          	mov    BYTE PTR [rdx+rax*1+0x7],bl
        buffer[buf_index] = c_digits_lut[d8 + 1];
  22d6da:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  22d6dd:	41 83 c8 01          	or     r8d,0x1
  22d6e1:	41 8a 0c 08          	mov    cl,BYTE PTR [r8+rcx*1]
  22d6e5:	88 4c 02 08          	mov    BYTE PTR [rdx+rax*1+0x8],cl
        buf_index += 1;
  22d6e9:	48 83 c0 09          	add    rax,0x9
    return buf_index;
  22d6ed:	5b                   	pop    rbx
  22d6ee:	41 5e                	pop    r14
  22d6f0:	41 5f                	pop    r15
  22d6f2:	c3                   	ret    
  22d6f3:	31 c0                	xor    eax,eax
            if (value >= 1000000) {
  22d6f5:	48 81 ff 40 42 0f 00 	cmp    rdi,0xf4240
  22d6fc:	0f 82 cd 00 00 00    	jb     22d7cf <u64toa+0x44f>
                buffer[buf_index] = c_digits_lut[d1 + 1];
  22d702:	4c 8b 0e             	mov    r9,QWORD PTR [rsi]
  22d705:	83 cb 01             	or     ebx,0x1
  22d708:	48 8d 3d 91 7c fd ff 	lea    rdi,[rip+0xfffffffffffd7c91]        # 2053a0 <c_digits_lut>
  22d70f:	8a 1c 3b             	mov    bl,BYTE PTR [rbx+rdi*1]
  22d712:	41 88 1c 01          	mov    BYTE PTR [r9+rax*1],bl
                buf_index += 1;
  22d716:	48 83 c0 01          	add    rax,0x1
                buffer[buf_index] = c_digits_lut[d2];
  22d71a:	48 8b 3e             	mov    rdi,QWORD PTR [rsi]
  22d71d:	48 8d 1d 7c 7c fd ff 	lea    rbx,[rip+0xfffffffffffd7c7c]        # 2053a0 <c_digits_lut>
  22d724:	8a 1c 1a             	mov    bl,BYTE PTR [rdx+rbx*1]
  22d727:	88 1c 07             	mov    BYTE PTR [rdi+rax*1],bl
                buf_index += 1;
  22d72a:	48 83 c0 01          	add    rax,0x1
            buffer[buf_index] = c_digits_lut[d2 + 1];
  22d72e:	48 8b 1e             	mov    rbx,QWORD PTR [rsi]
  22d731:	83 ca 01             	or     edx,0x1
  22d734:	48 8d 3d 65 7c fd ff 	lea    rdi,[rip+0xfffffffffffd7c65]        # 2053a0 <c_digits_lut>
  22d73b:	8a 14 3a             	mov    dl,BYTE PTR [rdx+rdi*1]
  22d73e:	88 14 03             	mov    BYTE PTR [rbx+rax*1],dl
            buffer[buf_index] = c_digits_lut[d3];
  22d741:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  22d744:	41 8a 1c 38          	mov    bl,BYTE PTR [r8+rdi*1]
  22d748:	88 5c 02 01          	mov    BYTE PTR [rdx+rax*1+0x1],bl
            buffer[buf_index] = c_digits_lut[d3 + 1];
  22d74c:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  22d74f:	41 83 c8 01          	or     r8d,0x1
  22d753:	41 8a 1c 38          	mov    bl,BYTE PTR [r8+rdi*1]
  22d757:	88 5c 02 02          	mov    BYTE PTR [rdx+rax*1+0x2],bl
            buffer[buf_index] = c_digits_lut[d4];
  22d75b:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  22d75e:	8a 1c 39             	mov    bl,BYTE PTR [rcx+rdi*1]
  22d761:	88 5c 02 03          	mov    BYTE PTR [rdx+rax*1+0x3],bl
            buffer[buf_index] = c_digits_lut[d4 + 1];
  22d765:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  22d768:	83 c9 01             	or     ecx,0x1
  22d76b:	8a 0c 39             	mov    cl,BYTE PTR [rcx+rdi*1]
  22d76e:	88 4c 02 04          	mov    BYTE PTR [rdx+rax*1+0x4],cl
            buf_index += 1;
  22d772:	48 83 c0 05          	add    rax,0x5
    return buf_index;
  22d776:	5b                   	pop    rbx
  22d777:	41 5e                	pop    r14
  22d779:	41 5f                	pop    r15
  22d77b:	c3                   	ret    
        } else if (a < 100) {
  22d77c:	83 f8 63             	cmp    eax,0x63
  22d77f:	77 60                	ja     22d7e1 <u64toa+0x461>
            buffer[buf_index] = c_digits_lut[i];
  22d781:	89 c0                	mov    eax,eax
  22d783:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  22d786:	48 8d 3d 13 7c fd ff 	lea    rdi,[rip+0xfffffffffffd7c13]        # 2053a0 <c_digits_lut>
  22d78d:	8a 1c 47             	mov    bl,BYTE PTR [rdi+rax*2]
            const i: u32 = a << 1;
  22d790:	48 01 c0             	add    rax,rax
            buffer[buf_index] = c_digits_lut[i];
  22d793:	88 19                	mov    BYTE PTR [rcx],bl
            buffer[buf_index] = c_digits_lut[i + 1];
  22d795:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  22d798:	83 c8 01             	or     eax,0x1
  22d79b:	8a 04 38             	mov    al,BYTE PTR [rax+rdi*1]
  22d79e:	88 41 01             	mov    BYTE PTR [rcx+0x1],al
  22d7a1:	b8 02 00 00 00       	mov    eax,0x2
  22d7a6:	e9 da 00 00 00       	jmp    22d885 <u64toa+0x505>
            if (v >= 10) {
  22d7ab:	83 ff 0a             	cmp    edi,0xa
  22d7ae:	0f 83 ed fd ff ff    	jae    22d5a1 <u64toa+0x221>
  22d7b4:	e9 fc fd ff ff       	jmp    22d5b5 <u64toa+0x235>
        if (value >= kTen13) {
  22d7b9:	48 89 f8             	mov    rax,rdi
  22d7bc:	48 c1 e8 0d          	shr    rax,0xd
  22d7c0:	48 3d 95 73 c2 48    	cmp    rax,0x48c27395
  22d7c6:	72 60                	jb     22d828 <u64toa+0x4a8>
  22d7c8:	31 c0                	xor    eax,eax
  22d7ca:	e9 2f fe ff ff       	jmp    22d5fe <u64toa+0x27e>
            if (value >= 100000) {
  22d7cf:	48 81 ff a0 86 01 00 	cmp    rdi,0x186a0
  22d7d6:	0f 83 3e ff ff ff    	jae    22d71a <u64toa+0x39a>
  22d7dc:	e9 4d ff ff ff       	jmp    22d72e <u64toa+0x3ae>
            const i: u32 = (a / 100) << 1;
  22d7e1:	89 c1                	mov    ecx,eax
  22d7e3:	48 69 c9 1f 85 eb 51 	imul   rcx,rcx,0x51eb851f
  22d7ea:	48 c1 e9 25          	shr    rcx,0x25
            const j: u32 = (a % 100) << 1;
  22d7ee:	6b f9 64             	imul   edi,ecx,0x64
        } else if (a < 1000) {
  22d7f1:	3d e7 03 00 00       	cmp    eax,0x3e7
  22d7f6:	77 4a                	ja     22d842 <u64toa+0x4c2>
            buffer[buf_index] = '0' + @intCast(u8, a / 100);
  22d7f8:	48 8b 1e             	mov    rbx,QWORD PTR [rsi]
  22d7fb:	80 c1 30             	add    cl,0x30
  22d7fe:	88 0b                	mov    BYTE PTR [rbx],cl
            const i: u32 = (a % 100) << 1;
  22d800:	29 f8                	sub    eax,edi
            buffer[buf_index] = c_digits_lut[i];
  22d802:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  22d805:	48 8d 3d 94 7b fd ff 	lea    rdi,[rip+0xfffffffffffd7b94]        # 2053a0 <c_digits_lut>
  22d80c:	8a 1c 47             	mov    bl,BYTE PTR [rdi+rax*2]
            const i: u32 = (a % 100) << 1;
  22d80f:	48 01 c0             	add    rax,rax
            buffer[buf_index] = c_digits_lut[i];
  22d812:	88 59 01             	mov    BYTE PTR [rcx+0x1],bl
            buffer[buf_index] = c_digits_lut[i + 1];
  22d815:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  22d818:	83 c8 01             	or     eax,0x1
  22d81b:	8a 04 38             	mov    al,BYTE PTR [rax+rdi*1]
  22d81e:	88 41 02             	mov    BYTE PTR [rcx+0x2],al
  22d821:	b8 03 00 00 00       	mov    eax,0x3
  22d826:	eb 5d                	jmp    22d885 <u64toa+0x505>
        if (value >= kTen12) {
  22d828:	48 89 f8             	mov    rax,rdi
  22d82b:	48 c1 e8 0c          	shr    rax,0xc
  22d82f:	48 3d 51 4a 8d 0e    	cmp    rax,0xe8d4a51
  22d835:	0f 82 e9 01 00 00    	jb     22da24 <u64toa+0x6a4>
  22d83b:	31 c0                	xor    eax,eax
  22d83d:	e9 d0 fd ff ff       	jmp    22d612 <u64toa+0x292>
            const j: u32 = (a % 100) << 1;
  22d842:	29 f8                	sub    eax,edi
  22d844:	48 8d 3c 00          	lea    rdi,[rax+rax*1]
            buffer[buf_index] = c_digits_lut[i];
  22d848:	4c 8b 0e             	mov    r9,QWORD PTR [rsi]
  22d84b:	4c 8d 05 4e 7b fd ff 	lea    r8,[rip+0xfffffffffffd7b4e]        # 2053a0 <c_digits_lut>
  22d852:	41 8a 1c 48          	mov    bl,BYTE PTR [r8+rcx*2]
  22d856:	41 88 19             	mov    BYTE PTR [r9],bl
            const i: u32 = (a / 100) << 1;
  22d859:	48 01 c9             	add    rcx,rcx
            buffer[buf_index] = c_digits_lut[i + 1];
  22d85c:	48 8b 1e             	mov    rbx,QWORD PTR [rsi]
  22d85f:	83 c9 01             	or     ecx,0x1
  22d862:	42 8a 0c 01          	mov    cl,BYTE PTR [rcx+r8*1]
  22d866:	88 4b 01             	mov    BYTE PTR [rbx+0x1],cl
            buffer[buf_index] = c_digits_lut[j];
  22d869:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  22d86c:	41 8a 04 40          	mov    al,BYTE PTR [r8+rax*2]
  22d870:	88 41 02             	mov    BYTE PTR [rcx+0x2],al
            buffer[buf_index] = c_digits_lut[j + 1];
  22d873:	48 8b 06             	mov    rax,QWORD PTR [rsi]
  22d876:	83 cf 01             	or     edi,0x1
  22d879:	42 8a 0c 07          	mov    cl,BYTE PTR [rdi+r8*1]
  22d87d:	88 48 03             	mov    BYTE PTR [rax+0x3],cl
  22d880:	b8 04 00 00 00       	mov    eax,0x4
        const v0 = @intCast(u32, value / kTen8);
  22d885:	48 b9 fd ce 61 84 11 	movabs rcx,0xabcc77118461cefd
  22d88c:	77 cc ab 
  22d88f:	c4 62 f3 f6 f1       	mulx   r14,rcx,rcx
  22d894:	49 c1 ee 1a          	shr    r14,0x1a
        const v1 = @intCast(u32, value % kTen8);
  22d898:	4d 69 c6 00 e1 f5 05 	imul   r8,r14,0x5f5e100
        const b0: u32 = v0 / 10000;
  22d89f:	44 89 f3             	mov    ebx,r14d
  22d8a2:	41 ba 59 17 b7 d1    	mov    r10d,0xd1b71759
        const d1: u32 = (b0 / 100) << 1;
  22d8a8:	4c 69 cb 83 de 1b 43 	imul   r9,rbx,0x431bde83
        const b0: u32 = v0 / 10000;
  22d8af:	49 0f af da          	imul   rbx,r10
  22d8b3:	48 c1 eb 2d          	shr    rbx,0x2d
        const d1: u32 = (b0 / 100) << 1;
  22d8b7:	49 c1 e9 32          	shr    r9,0x32
        buffer[buf_index] = c_digits_lut[d1];
  22d8bb:	4c 8b 1e             	mov    r11,QWORD PTR [rsi]
  22d8be:	48 8d 3d db 7a fd ff 	lea    rdi,[rip+0xfffffffffffd7adb]        # 2053a0 <c_digits_lut>
  22d8c5:	42 8a 0c 4f          	mov    cl,BYTE PTR [rdi+r9*2]
  22d8c9:	41 88 0c 03          	mov    BYTE PTR [r11+rax*1],cl
        const c0: u32 = v0 % 10000;
  22d8cd:	44 69 db 10 27 00 00 	imul   r11d,ebx,0x2710
        const d2: u32 = (b0 % 100) << 1;
  22d8d4:	48 69 cb 1f 85 eb 51 	imul   rcx,rbx,0x51eb851f
  22d8db:	48 c1 e9 25          	shr    rcx,0x25
  22d8df:	6b c9 64             	imul   ecx,ecx,0x64
        const c0: u32 = v0 % 10000;
  22d8e2:	45 29 de             	sub    r14d,r11d
        const d2: u32 = (b0 % 100) << 1;
  22d8e5:	29 cb                	sub    ebx,ecx
        const d1: u32 = (b0 / 100) << 1;
  22d8e7:	4b 8d 0c 09          	lea    rcx,[r9+r9*1]
        buffer[buf_index] = c_digits_lut[d1 + 1];
  22d8eb:	83 c9 01             	or     ecx,0x1
  22d8ee:	44 8a 0c 39          	mov    r9b,BYTE PTR [rcx+rdi*1]
  22d8f2:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  22d8f5:	44 88 4c 01 01       	mov    BYTE PTR [rcx+rax*1+0x1],r9b
        buffer[buf_index] = c_digits_lut[d2];
  22d8fa:	4c 8b 0e             	mov    r9,QWORD PTR [rsi]
  22d8fd:	8a 0c 5f             	mov    cl,BYTE PTR [rdi+rbx*2]
  22d900:	41 88 4c 01 02       	mov    BYTE PTR [r9+rax*1+0x2],cl
        const d2: u32 = (b0 % 100) << 1;
  22d905:	48 8d 0c 1b          	lea    rcx,[rbx+rbx*1]
        const d3: u32 = (c0 / 100) << 1;
  22d909:	49 69 de 1f 85 eb 51 	imul   rbx,r14,0x51eb851f
  22d910:	48 c1 eb 25          	shr    rbx,0x25
        buffer[buf_index] = c_digits_lut[d2 + 1];
  22d914:	83 c9 01             	or     ecx,0x1
  22d917:	44 8a 0c 39          	mov    r9b,BYTE PTR [rcx+rdi*1]
  22d91b:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  22d91e:	44 88 4c 01 03       	mov    BYTE PTR [rcx+rax*1+0x3],r9b
        buffer[buf_index] = c_digits_lut[d3];
  22d923:	4c 8b 0e             	mov    r9,QWORD PTR [rsi]
  22d926:	8a 0c 5f             	mov    cl,BYTE PTR [rdi+rbx*2]
  22d929:	41 88 4c 01 04       	mov    BYTE PTR [r9+rax*1+0x4],cl
        const d4: u32 = (c0 % 100) << 1;
  22d92e:	6b cb 64             	imul   ecx,ebx,0x64
        const v1 = @intCast(u32, value % kTen8);
  22d931:	4c 29 c2             	sub    rdx,r8
        const d3: u32 = (c0 / 100) << 1;
  22d934:	48 8d 1c 1b          	lea    rbx,[rbx+rbx*1]
        const d4: u32 = (c0 % 100) << 1;
  22d938:	41 29 ce             	sub    r14d,ecx
        buffer[buf_index] = c_digits_lut[d3 + 1];
  22d93b:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  22d93e:	83 cb 01             	or     ebx,0x1
  22d941:	8a 1c 3b             	mov    bl,BYTE PTR [rbx+rdi*1]
  22d944:	88 5c 01 05          	mov    BYTE PTR [rcx+rax*1+0x5],bl
        const d4: u32 = (c0 % 100) << 1;
  22d948:	4b 8d 0c 36          	lea    rcx,[r14+r14*1]
        const b1: u32 = v1 / 10000;
  22d94c:	4c 0f af d2          	imul   r10,rdx
  22d950:	49 c1 ea 2d          	shr    r10,0x2d
        buffer[buf_index] = c_digits_lut[d4];
  22d954:	4c 8b 06             	mov    r8,QWORD PTR [rsi]
  22d957:	42 8a 1c 77          	mov    bl,BYTE PTR [rdi+r14*2]
  22d95b:	41 88 5c 00 06       	mov    BYTE PTR [r8+rax*1+0x6],bl
        const d5: u32 = (b1 / 100) << 1;
  22d960:	48 69 da 83 de 1b 43 	imul   rbx,rdx,0x431bde83
  22d967:	48 c1 eb 31          	shr    rbx,0x31
  22d96b:	81 e3 fe 01 00 00    	and    ebx,0x1fe
        buffer[buf_index] = c_digits_lut[d4 + 1];
  22d971:	4c 8b 06             	mov    r8,QWORD PTR [rsi]
  22d974:	83 c9 01             	or     ecx,0x1
  22d977:	8a 0c 39             	mov    cl,BYTE PTR [rcx+rdi*1]
  22d97a:	41 88 4c 00 07       	mov    BYTE PTR [r8+rax*1+0x7],cl
        buf_index += 1;
  22d97f:	48 83 c8 08          	or     rax,0x8
        buffer[buf_index] = c_digits_lut[d5];
  22d983:	4c 8b 06             	mov    r8,QWORD PTR [rsi]
  22d986:	8a 0c 3b             	mov    cl,BYTE PTR [rbx+rdi*1]
  22d989:	41 88 0c 00          	mov    BYTE PTR [r8+rax*1],cl
        const c1: u32 = v1 % 10000;
  22d98d:	45 69 c2 10 27 00 00 	imul   r8d,r10d,0x2710
        const d6: u32 = (b1 % 100) << 1;
  22d994:	49 69 ca 1f 85 eb 51 	imul   rcx,r10,0x51eb851f
  22d99b:	48 c1 e9 25          	shr    rcx,0x25
  22d99f:	6b c9 64             	imul   ecx,ecx,0x64
        const c1: u32 = v1 % 10000;
  22d9a2:	44 29 c2             	sub    edx,r8d
        const d6: u32 = (b1 % 100) << 1;
  22d9a5:	41 29 ca             	sub    r10d,ecx
        buffer[buf_index] = c_digits_lut[d5 + 1];
  22d9a8:	8d 4b 01             	lea    ecx,[rbx+0x1]
  22d9ab:	8a 0c 39             	mov    cl,BYTE PTR [rcx+rdi*1]
  22d9ae:	48 8b 1e             	mov    rbx,QWORD PTR [rsi]
  22d9b1:	88 4c 03 01          	mov    BYTE PTR [rbx+rax*1+0x1],cl
        buffer[buf_index] = c_digits_lut[d6];
  22d9b5:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  22d9b8:	42 8a 1c 57          	mov    bl,BYTE PTR [rdi+r10*2]
  22d9bc:	88 5c 01 02          	mov    BYTE PTR [rcx+rax*1+0x2],bl
        const d6: u32 = (b1 % 100) << 1;
  22d9c0:	4b 8d 0c 12          	lea    rcx,[r10+r10*1]
        const d7: u32 = (c1 / 100) << 1;
  22d9c4:	48 69 da 1f 85 eb 51 	imul   rbx,rdx,0x51eb851f
  22d9cb:	48 c1 eb 25          	shr    rbx,0x25
        buffer[buf_index] = c_digits_lut[d6 + 1];
  22d9cf:	83 c9 01             	or     ecx,0x1
  22d9d2:	44 8a 04 39          	mov    r8b,BYTE PTR [rcx+rdi*1]
  22d9d6:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  22d9d9:	44 88 44 01 03       	mov    BYTE PTR [rcx+rax*1+0x3],r8b
        buffer[buf_index] = c_digits_lut[d7];
  22d9de:	4c 8b 06             	mov    r8,QWORD PTR [rsi]
  22d9e1:	8a 0c 5f             	mov    cl,BYTE PTR [rdi+rbx*2]
  22d9e4:	41 88 4c 00 04       	mov    BYTE PTR [r8+rax*1+0x4],cl
        const d8: u32 = (c1 % 100) << 1;
  22d9e9:	6b cb 64             	imul   ecx,ebx,0x64
  22d9ec:	29 ca                	sub    edx,ecx
        const d7: u32 = (c1 / 100) << 1;
  22d9ee:	48 8d 0c 1b          	lea    rcx,[rbx+rbx*1]
        buffer[buf_index] = c_digits_lut[d7 + 1];
  22d9f2:	83 c9 01             	or     ecx,0x1
  22d9f5:	8a 0c 39             	mov    cl,BYTE PTR [rcx+rdi*1]
  22d9f8:	48 8b 1e             	mov    rbx,QWORD PTR [rsi]
  22d9fb:	88 4c 03 05          	mov    BYTE PTR [rbx+rax*1+0x5],cl
        buffer[buf_index] = c_digits_lut[d8];
  22d9ff:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  22da02:	8a 1c 57             	mov    bl,BYTE PTR [rdi+rdx*2]
  22da05:	88 5c 01 06          	mov    BYTE PTR [rcx+rax*1+0x6],bl
        const d8: u32 = (c1 % 100) << 1;
  22da09:	48 8d 0c 12          	lea    rcx,[rdx+rdx*1]
        buffer[buf_index] = c_digits_lut[d8 + 1];
  22da0d:	83 c9 01             	or     ecx,0x1
  22da10:	8a 0c 39             	mov    cl,BYTE PTR [rcx+rdi*1]
  22da13:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  22da16:	88 4c 02 07          	mov    BYTE PTR [rdx+rax*1+0x7],cl
        buf_index += 1;
  22da1a:	48 83 c0 08          	add    rax,0x8
    return buf_index;
  22da1e:	5b                   	pop    rbx
  22da1f:	41 5e                	pop    r14
  22da21:	41 5f                	pop    r15
  22da23:	c3                   	ret    
        if (value >= kTen11) {
  22da24:	48 89 f8             	mov    rax,rdi
  22da27:	48 c1 e8 0b          	shr    rax,0xb
  22da2b:	48 3d dd 0e e9 02    	cmp    rax,0x2e90edd
  22da31:	72 07                	jb     22da3a <u64toa+0x6ba>
  22da33:	31 c0                	xor    eax,eax
  22da35:	e9 ef fb ff ff       	jmp    22d629 <u64toa+0x2a9>
        if (value >= kTen10) {
  22da3a:	48 89 f8             	mov    rax,rdi
  22da3d:	48 c1 e8 0a          	shr    rax,0xa
  22da41:	48 3d f9 02 95 00    	cmp    rax,0x9502f9
  22da47:	72 07                	jb     22da50 <u64toa+0x6d0>
  22da49:	31 c0                	xor    eax,eax
  22da4b:	e9 ee fb ff ff       	jmp    22d63e <u64toa+0x2be>
  22da50:	31 c0                	xor    eax,eax
        if (value >= kTen9) {
  22da52:	48 81 ff 00 ca 9a 3b 	cmp    rdi,0x3b9aca00
  22da59:	0f 83 f8 fb ff ff    	jae    22d657 <u64toa+0x2d7>
  22da5f:	e9 08 fc ff ff       	jmp    22d66c <u64toa+0x2ec>
  22da64:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  22da6b:	00 00 00 00 00 

000000000022da70 <frexp64>:
    y |= 0x3F000000;
    result.significand = @bitCast(f32, y);
    return result;
}

fn frexp64(x: f64) frexp64_result {
  22da70:	53                   	push   rbx
  22da71:	48 83 ec 10          	sub    rsp,0x10
  22da75:	48 89 fb             	mov    rbx,rdi
    var result: frexp64_result = undefined;

    var y = @bitCast(u64, x);
  22da78:	c4 e1 f9 7e c1       	vmovq  rcx,xmm0
    const e = @intCast(i32, y >> 52) & 0x7FF;
  22da7d:	48 89 c8             	mov    rax,rcx
  22da80:	48 c1 e8 34          	shr    rax,0x34

    if (e == 0) {
  22da84:	89 c2                	mov    edx,eax
  22da86:	81 e2 ff 07 00 00    	and    edx,0x7ff
  22da8c:	81 fa ff 07 00 00    	cmp    edx,0x7ff
  22da92:	74 31                	je     22dac5 <frexp64+0x55>
  22da94:	66 85 d2             	test   dx,dx
  22da97:	75 3d                	jne    22dad6 <frexp64+0x66>
        if (x != 0) {
  22da99:	c5 f0 57 c9          	vxorps xmm1,xmm1,xmm1
  22da9d:	c5 f9 2e c1          	vucomisd xmm0,xmm1
  22daa1:	74 63                	je     22db06 <frexp64+0x96>
            // subnormal
            result = frexp64(x * 0x1.0p64);
  22daa3:	c5 fb 59 05 b5 28 fd 	vmulsd xmm0,xmm0,QWORD PTR [rip+0xfffffffffffd28b5]        # 200360 <__unnamed_609+0x20>
  22daaa:	ff 
  22daab:	48 89 e7             	mov    rdi,rsp
  22daae:	e8 bd ff ff ff       	call   22da70 <frexp64>
  22dab3:	c5 fb 10 04 24       	vmovsd xmm0,QWORD PTR [rsp]
  22dab8:	8b 44 24 08          	mov    eax,DWORD PTR [rsp+0x8]
  22dabc:	8b 4c 24 0c          	mov    ecx,DWORD PTR [rsp+0xc]
            result.exponent -= 64;
  22dac0:	83 c0 c0             	add    eax,0xffffffc0
  22dac3:	eb 43                	jmp    22db08 <frexp64+0x98>
        // frexp(+-inf) = (+-inf, 0)
        if (math.isInf(x)) {
            result.exponent = 0;
        }

        return result;
  22dac5:	c5 fb 11 03          	vmovsd QWORD PTR [rbx],xmm0
  22dac9:	c7 43 08 00 00 00 00 	mov    DWORD PTR [rbx+0x8],0x0
  22dad0:	48 83 c4 10          	add    rsp,0x10
  22dad4:	5b                   	pop    rbx
  22dad5:	c3                   	ret    
    const e = @intCast(i32, y >> 52) & 0x7FF;
  22dad6:	25 ff 07 00 00       	and    eax,0x7ff
    }

    result.exponent = e - 0x3FE;
  22dadb:	05 02 fc ff ff       	add    eax,0xfffffc02
    y &= 0x800FFFFFFFFFFFFF;
  22dae0:	48 ba ff ff ff ff ff 	movabs rdx,0x800fffffffffffff
  22dae7:	ff 0f 80 
  22daea:	48 21 d1             	and    rcx,rdx
    y |= 0x3FE0000000000000;
  22daed:	48 ba 00 00 00 00 00 	movabs rdx,0x3fe0000000000000
  22daf4:	00 e0 3f 
  22daf7:	48 09 ca             	or     rdx,rcx
    result.significand = @bitCast(f64, y);
    return result;
  22dafa:	48 89 13             	mov    QWORD PTR [rbx],rdx
  22dafd:	89 43 08             	mov    DWORD PTR [rbx+0x8],eax
  22db00:	48 83 c4 10          	add    rsp,0x10
  22db04:	5b                   	pop    rbx
  22db05:	c3                   	ret    
  22db06:	31 c0                	xor    eax,eax
        return result;
  22db08:	c5 fb 11 03          	vmovsd QWORD PTR [rbx],xmm0
  22db0c:	89 43 08             	mov    DWORD PTR [rbx+0x8],eax
  22db0f:	89 4b 0c             	mov    DWORD PTR [rbx+0xc],ecx
  22db12:	48 83 c4 10          	add    rsp,0x10
  22db16:	5b                   	pop    rbx
  22db17:	c3                   	ret    
  22db18:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  22db1f:	00 

000000000022db20 <_start>:
}

nakedcc fn _start() noreturn {
    switch (builtin.arch) {
        builtin.Arch.x86_64 => {
            argc_ptr = asm ("lea (%%rsp), %[argc]"
  22db20:	48 8d 04 24          	lea    rax,[rsp]
  22db24:	48 89 05 95 d5 01 00 	mov    QWORD PTR [rip+0x1d595],rax        # 24b0c0 <argc_ptr>
        },
        else => @compileError("unsupported arch"),
    }
    // If LLVM inlines stack variables into _start, they will overwrite
    // the command line argument data.
    @noInlineCall(posixCallMainAndExit);
  22db2b:	e8 00 00 00 00       	call   22db30 <posixCallMainAndExit>

000000000022db30 <posixCallMainAndExit>:
    std.os.windows.ExitProcess(callMain());
}

// TODO https://github.com/ziglang/zig/issues/265
fn posixCallMainAndExit() noreturn {
    const argc = argc_ptr[0];
  22db30:	41 56                	push   r14
  22db32:	53                   	push   rbx
  22db33:	48 83 ec 18          	sub    rsp,0x18
  22db37:	48 8b 15 82 d5 01 00 	mov    rdx,QWORD PTR [rip+0x1d582]        # 24b0c0 <argc_ptr>
  22db3e:	48 8b 1a             	mov    rbx,QWORD PTR [rdx]
    const argv = @ptrCast([*][*]u8, argc_ptr + 1);

    const envp_optional = @ptrCast([*]?[*]u8, argv + argc + 1);
  22db41:	48 8d 0c da          	lea    rcx,[rdx+rbx*8]
  22db45:	48 83 c1 10          	add    rcx,0x10
    var envp_count: usize = 0;
    while (envp_optional[envp_count]) |_| : (envp_count += 1) {}
  22db49:	48 8d 04 da          	lea    rax,[rdx+rbx*8]
  22db4d:	48 83 c0 20          	add    rax,0x20
    const argv = @ptrCast([*][*]u8, argc_ptr + 1);
  22db51:	4c 8d 72 08          	lea    r14,[rdx+0x8]
  22db55:	48 c7 c2 ff ff ff ff 	mov    rdx,0xffffffffffffffff
  22db5c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
    while (envp_optional[envp_count]) |_| : (envp_count += 1) {}
  22db60:	48 83 c2 01          	add    rdx,0x1
  22db64:	48 83 78 f0 00       	cmp    QWORD PTR [rax-0x10],0x0
  22db69:	48 8d 40 08          	lea    rax,[rax+0x8]
  22db6d:	75 f1                	jne    22db60 <posixCallMainAndExit+0x30>
    const envp = @ptrCast([*][*]u8, envp_optional)[0..envp_count];
  22db6f:	48 89 4c 24 08       	mov    QWORD PTR [rsp+0x8],rcx
  22db74:	48 89 54 24 10       	mov    QWORD PTR [rsp+0x10],rdx
    if (builtin.os == builtin.Os.linux) {
        const auxv = @ptrCast([*]usize, envp.ptr + envp_count + 1);
        var i: usize = 0;
        while (auxv[i] != 0) : (i += 2) {
  22db79:	48 8b 48 f0          	mov    rcx,QWORD PTR [rax-0x10]
  22db7d:	48 85 c9             	test   rcx,rcx
  22db80:	74 28                	je     22dbaa <posixCallMainAndExit+0x7a>
  22db82:	48 8d 15 b7 24 02 00 	lea    rdx,[rip+0x224b7]        # 250040 <linux_aux_raw>
  22db89:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
            if (auxv[i] < std.os.linux_aux_raw.len) std.os.linux_aux_raw[auxv[i]] = auxv[i + 1];
  22db90:	48 83 f9 25          	cmp    rcx,0x25
  22db94:	77 08                	ja     22db9e <posixCallMainAndExit+0x6e>
  22db96:	48 8b 70 f8          	mov    rsi,QWORD PTR [rax-0x8]
  22db9a:	48 89 34 ca          	mov    QWORD PTR [rdx+rcx*8],rsi
        while (auxv[i] != 0) : (i += 2) {
  22db9e:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  22dba1:	48 83 c0 10          	add    rax,0x10
  22dba5:	48 85 c9             	test   rcx,rcx
  22dba8:	75 e6                	jne    22db90 <posixCallMainAndExit+0x60>
        }
        std.debug.assert(std.os.linux_aux_raw[std.elf.AT_PAGESZ] == std.os.page_size);
  22dbaa:	31 ff                	xor    edi,edi
  22dbac:	48 81 3d b9 24 02 00 	cmp    QWORD PTR [rip+0x224b9],0x1000        # 250070 <linux_aux_raw+0x30>
  22dbb3:	00 10 00 00 
  22dbb7:	40 0f 94 c7          	sete   dil
  22dbbb:	e8 c0 c6 fd ff       	call   20a280 <assert>
  22dbc0:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
    }

    std.os.posix.exit(callMainWithArgs(argc, argv, envp));
  22dbc5:	48 89 df             	mov    rdi,rbx
  22dbc8:	4c 89 f6             	mov    rsi,r14
  22dbcb:	e8 10 00 00 00       	call   22dbe0 <callMainWithArgs>
    _ = syscall1(SYS_exit, @bitCast(usize, isize(status)));
  22dbd0:	0f b6 f8             	movzx  edi,al
    return asm volatile ("syscall"
  22dbd3:	b8 3c 00 00 00       	mov    eax,0x3c
  22dbd8:	0f 05                	syscall 
  22dbda:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

000000000022dbe0 <callMainWithArgs>:
}

fn callMainWithArgs(argc: usize, argv: [*][*]u8, envp: [][*]u8) u8 {
    std.os.ArgIteratorPosix.raw = argv[0..argc];
  22dbe0:	55                   	push   rbp
  22dbe1:	41 57                	push   r15
  22dbe3:	41 56                	push   r14
  22dbe5:	41 55                	push   r13
  22dbe7:	41 54                	push   r12
  22dbe9:	53                   	push   rbx
  22dbea:	48 83 ec 78          	sub    rsp,0x78
  22dbee:	48 89 35 d3 d4 01 00 	mov    QWORD PTR [rip+0x1d4d3],rsi        # 24b0c8 <raw>
  22dbf5:	48 89 3d d4 d4 01 00 	mov    QWORD PTR [rip+0x1d4d4],rdi        # 24b0d0 <raw+0x8>
    std.os.posix_environ_raw = envp;
  22dbfc:	c5 f8 10 02          	vmovups xmm0,XMMWORD PTR [rdx]
  22dc00:	c5 f8 11 05 a8 d4 01 	vmovups XMMWORD PTR [rip+0x1d4a8],xmm0        # 24b0b0 <posix_environ_raw>
  22dc07:	00 
const warn = std.debug.warn;

pub fn main() !void {
    var ok_count: usize = 0;
    var skip_count: usize = 0;
    for (test_fn_list) |test_fn, i| {
  22dc08:	c5 f8 10 05 60 b0 fd 	vmovups xmm0,XMMWORD PTR [rip+0xfffffffffffdb060]        # 208c70 <__unnamed_95>
  22dc0f:	ff 
  22dc10:	c5 f8 29 44 24 60    	vmovaps XMMWORD PTR [rsp+0x60],xmm0
  22dc16:	31 c0                	xor    eax,eax
  22dc18:	48 89 44 24 58       	mov    QWORD PTR [rsp+0x58],rax
  22dc1d:	49 bd cd cc cc cc cc 	movabs r13,0xcccccccccccccccd
  22dc24:	cc cc cc 
  22dc27:	45 31 e4             	xor    r12d,r12d
  22dc2a:	31 db                	xor    ebx,ebx
  22dc2c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  22dc30:	4b 8d 04 64          	lea    rax,[r12+r12*2]
  22dc34:	48 8d 0d 25 0f 02 00 	lea    rcx,[rip+0x20f25]        # 24eb60 <__unnamed_96>
  22dc3b:	c5 f8 10 04 c1       	vmovups xmm0,XMMWORD PTR [rcx+rax*8]
  22dc40:	c5 f8 29 44 24 60    	vmovaps XMMWORD PTR [rsp+0x60],xmm0
  22dc46:	4c 8b 74 c1 10       	mov    r14,QWORD PTR [rcx+rax*8+0x10]
  22dc4b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  22dc50:	b0 01                	mov    al,0x1
  22dc52:	86 05 b8 23 02 00    	xchg   BYTE PTR [rip+0x223b8],al        # 250010 <stderr_mutex>
  22dc58:	84 c0                	test   al,al
  22dc5a:	75 f4                	jne    22dc50 <callMainWithArgs+0x70>
    if (stderr_stream) |st| {
  22dc5c:	48 8b 2d a5 23 02 00 	mov    rbp,QWORD PTR [rip+0x223a5]        # 250008 <stderr_stream>
  22dc63:	48 85 ed             	test   rbp,rbp
  22dc66:	74 18                	je     22dc80 <callMainWithArgs+0xa0>
            return std.fmt.format(self, Error, self.writeFn, format, args);
  22dc68:	4c 8b 3d d1 d3 01 00 	mov    r15,QWORD PTR [rip+0x1d3d1]        # 24b040 <stderr_file_out_stream+0x8>
  22dc6f:	eb 43                	jmp    22dcb4 <callMainWithArgs+0xd4>
  22dc71:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  22dc78:	0f 1f 84 00 00 00 00 
  22dc7f:	00 
        stderr_file = try io.getStdErr();
  22dc80:	c7 05 a6 d3 01 00 02 	mov    DWORD PTR [rip+0x1d3a6],0x2        # 24b030 <stderr_file>
  22dc87:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  22dc8a:	48 8d 05 9f d3 01 00 	lea    rax,[rip+0x1d39f]        # 24b030 <stderr_file>
  22dc91:	48 89 05 a0 d3 01 00 	mov    QWORD PTR [rip+0x1d3a0],rax        # 24b038 <stderr_file_out_stream>
  22dc98:	4c 8d 3d 41 1d ff ff 	lea    r15,[rip+0xffffffffffff1d41]        # 21f9e0 <FileOutStream_writeFn>
  22dc9f:	4c 89 3d 9a d3 01 00 	mov    QWORD PTR [rip+0x1d39a],r15        # 24b040 <stderr_file_out_stream+0x8>
  22dca6:	48 8d 2d 93 d3 01 00 	lea    rbp,[rip+0x1d393]        # 24b040 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  22dcad:	48 89 2d 54 23 02 00 	mov    QWORD PTR [rip+0x22354],rbp        # 250008 <stderr_stream>
  22dcb4:	49 83 c4 01          	add    r12,0x1
                        try output(context, fmt[start_index..i]);
  22dcb8:	48 89 ef             	mov    rdi,rbp
  22dcbb:	48 8d 35 ee 12 02 00 	lea    rsi,[rip+0x212ee]        # 24efb0 <__unnamed_97>
  22dcc2:	41 ff d7             	call   r15
  22dcc5:	66 85 c0             	test   ax,ax
  22dcc8:	0f 85 72 01 00 00    	jne    22de40 <callMainWithArgs+0x260>
    var buf: [max_int_digits - 1]u8 = undefined;
  22dcce:	c5 fc 10 05 79 af fd 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffdaf79]        # 208c4f <__unnamed_20+0x1f>
  22dcd5:	ff 
  22dcd6:	c5 fc 11 44 24 2f    	vmovups YMMWORD PTR [rsp+0x2f],ymm0
  22dcdc:	c5 fc 10 05 4c af fd 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffdaf4c]        # 208c30 <__unnamed_20>
  22dce3:	ff 
  22dce4:	c5 fc 11 44 24 10    	vmovups YMMWORD PTR [rsp+0x10],ymm0
        const digit = a % base;
  22dcea:	4c 89 e2             	mov    rdx,r12
  22dced:	c4 c2 fb f6 cd       	mulx   rcx,rax,r13
  22dcf2:	c1 e9 02             	shr    ecx,0x2
  22dcf5:	81 e1 fe ff ff 3f    	and    ecx,0x3ffffffe
  22dcfb:	8d 0c 89             	lea    ecx,[rcx+rcx*4]
  22dcfe:	44 89 e0             	mov    eax,r12d
  22dd01:	29 c8                	sub    eax,ecx
        0...9 => digit + '0',
  22dd03:	b1 30                	mov    cl,0x30
  22dd05:	3c 0a                	cmp    al,0xa
  22dd07:	72 02                	jb     22dd0b <callMainWithArgs+0x12b>
  22dd09:	b1 57                	mov    cl,0x57
  22dd0b:	00 c1                	add    cl,al
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  22dd0d:	88 4c 24 4f          	mov    BYTE PTR [rsp+0x4f],cl
        if (a == 0) break;
  22dd11:	49 83 fc 0a          	cmp    r12,0xa
  22dd15:	73 0c                	jae    22dd23 <callMainWithArgs+0x143>
  22dd17:	b9 40 00 00 00       	mov    ecx,0x40
  22dd1c:	48 8d 44 24 4f       	lea    rax,[rsp+0x4f]
  22dd21:	eb 57                	jmp    22dd7a <callMainWithArgs+0x19a>
  22dd23:	49 89 d8             	mov    r8,rbx
  22dd26:	b9 40 00 00 00       	mov    ecx,0x40
  22dd2b:	4c 89 e0             	mov    rax,r12
  22dd2e:	66 90                	xchg   ax,ax
        a /= base;
  22dd30:	48 89 c2             	mov    rdx,rax
  22dd33:	c4 c2 cb f6 d5       	mulx   rdx,rsi,r13
  22dd38:	48 c1 ea 03          	shr    rdx,0x3
        const digit = a % base;
  22dd3c:	c4 c2 cb f6 fd       	mulx   rdi,rsi,r13
  22dd41:	c1 ef 02             	shr    edi,0x2
  22dd44:	81 e7 fe ff ff 3f    	and    edi,0x3ffffffe
  22dd4a:	8d 3c bf             	lea    edi,[rdi+rdi*4]
  22dd4d:	89 d6                	mov    esi,edx
  22dd4f:	29 fe                	sub    esi,edi
        0...9 => digit + '0',
  22dd51:	b3 30                	mov    bl,0x30
  22dd53:	40 80 fe 0a          	cmp    sil,0xa
  22dd57:	72 02                	jb     22dd5b <callMainWithArgs+0x17b>
  22dd59:	b3 57                	mov    bl,0x57
  22dd5b:	40 00 f3             	add    bl,sil
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  22dd5e:	88 5c 0c 0e          	mov    BYTE PTR [rsp+rcx*1+0xe],bl
        if (a == 0) break;
  22dd62:	48 83 c1 ff          	add    rcx,0xffffffffffffffff
  22dd66:	48 83 f8 63          	cmp    rax,0x63
  22dd6a:	48 89 d0             	mov    rax,rdx
  22dd6d:	77 c1                	ja     22dd30 <callMainWithArgs+0x150>
        const padded_buf = buf[index - padding ..];
  22dd6f:	48 8d 04 0c          	lea    rax,[rsp+rcx*1]
  22dd73:	48 83 c0 0f          	add    rax,0xf
  22dd77:	4c 89 c3             	mov    rbx,r8
  22dd7a:	ba 41 00 00 00       	mov    edx,0x41
  22dd7f:	48 29 ca             	sub    rdx,rcx
  22dd82:	48 89 04 24          	mov    QWORD PTR [rsp],rax
  22dd86:	48 89 54 24 08       	mov    QWORD PTR [rsp+0x8],rdx
        return output(context, padded_buf);
  22dd8b:	48 89 ef             	mov    rdi,rbp
  22dd8e:	48 89 e6             	mov    rsi,rsp
  22dd91:	c5 f8 77             	vzeroupper 
  22dd94:	41 ff d7             	call   r15
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  22dd97:	66 85 c0             	test   ax,ax
  22dd9a:	0f 85 a0 00 00 00    	jne    22de40 <callMainWithArgs+0x260>
                        try output(context, fmt[start_index..i]);
  22dda0:	48 89 ef             	mov    rdi,rbp
  22dda3:	48 8d 35 16 12 02 00 	lea    rsi,[rip+0x21216]        # 24efc0 <__unnamed_98>
  22ddaa:	41 ff d7             	call   r15
  22ddad:	66 85 c0             	test   ax,ax
  22ddb0:	0f 85 8a 00 00 00    	jne    22de40 <callMainWithArgs+0x260>
    var buf: [max_int_digits - 1]u8 = undefined;
  22ddb6:	c5 fc 10 05 90 ae fd 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffdae90]        # 208c4e <__unnamed_20+0x1e>
  22ddbd:	ff 
  22ddbe:	c5 fc 11 44 24 2e    	vmovups YMMWORD PTR [rsp+0x2e],ymm0
  22ddc4:	c5 fc 10 05 64 ae fd 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffdae64]        # 208c30 <__unnamed_20>
  22ddcb:	ff 
  22ddcc:	c5 fc 11 44 24 10    	vmovups YMMWORD PTR [rsp+0x10],ymm0
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  22ddd2:	66 c7 44 24 4e 31 35 	mov    WORD PTR [rsp+0x4e],0x3531
        const padded_buf = buf[index - padding ..];
  22ddd9:	48 8d 44 24 4e       	lea    rax,[rsp+0x4e]
  22ddde:	48 89 04 24          	mov    QWORD PTR [rsp],rax
  22dde2:	48 c7 44 24 08 02 00 	mov    QWORD PTR [rsp+0x8],0x2
  22dde9:	00 00 
        return output(context, padded_buf);
  22ddeb:	48 89 ef             	mov    rdi,rbp
  22ddee:	48 89 e6             	mov    rsi,rsp
  22ddf1:	c5 f8 77             	vzeroupper 
  22ddf4:	41 ff d7             	call   r15
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  22ddf7:	66 85 c0             	test   ax,ax
  22ddfa:	75 44                	jne    22de40 <callMainWithArgs+0x260>
                        try output(context, fmt[start_index..i]);
  22ddfc:	48 89 ef             	mov    rdi,rbp
  22ddff:	48 8d 35 ca 11 02 00 	lea    rsi,[rip+0x211ca]        # 24efd0 <__unnamed_99>
  22de06:	41 ff d7             	call   r15
  22de09:	66 85 c0             	test   ax,ax
  22de0c:	75 32                	jne    22de40 <callMainWithArgs+0x260>
                const casted_value = ([]const u8)(value);
  22de0e:	c5 f8 28 44 24 60    	vmovaps xmm0,XMMWORD PTR [rsp+0x60]
  22de14:	c5 f8 29 44 24 10    	vmovaps XMMWORD PTR [rsp+0x10],xmm0
                return output(context, casted_value);
  22de1a:	48 89 ef             	mov    rdi,rbp
  22de1d:	48 8d 74 24 10       	lea    rsi,[rsp+0x10]
  22de22:	41 ff d7             	call   r15
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  22de25:	66 85 c0             	test   ax,ax
  22de28:	75 16                	jne    22de40 <callMainWithArgs+0x260>
        try output(context, fmt[start_index..]);
  22de2a:	48 89 ef             	mov    rdi,rbp
  22de2d:	48 8d 35 ac 11 02 00 	lea    rsi,[rip+0x211ac]        # 24efe0 <__unnamed_100>
  22de34:	41 ff d7             	call   r15
  22de37:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  22de3e:	00 00 
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  22de40:	31 c0                	xor    eax,eax
  22de42:	86 05 c8 21 02 00    	xchg   BYTE PTR [rip+0x221c8],al        # 250010 <stderr_mutex>
  22de48:	3c 01                	cmp    al,0x1
    if (!ok) {
  22de4a:	0f 85 d4 04 00 00    	jne    22e324 <callMainWithArgs+0x744>
        warn("Test {}/{} {}...", i + 1, test_fn_list.len, test_fn.name);

        if (test_fn.func()) |_| {
  22de50:	41 ff d6             	call   r14
  22de53:	89 c5                	mov    ebp,eax
  22de55:	66 85 ed             	test   bp,bp
  22de58:	74 46                	je     22dea0 <callMainWithArgs+0x2c0>
  22de5a:	0f b7 c5             	movzx  eax,bp
  22de5d:	83 f8 2d             	cmp    eax,0x2d
  22de60:	0f 85 6a 01 00 00    	jne    22dfd0 <callMainWithArgs+0x3f0>
  22de66:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  22de6d:	00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  22de70:	b0 01                	mov    al,0x1
  22de72:	86 05 98 21 02 00    	xchg   BYTE PTR [rip+0x22198],al        # 250010 <stderr_mutex>
  22de78:	84 c0                	test   al,al
  22de7a:	75 f4                	jne    22de70 <callMainWithArgs+0x290>
    if (stderr_stream) |st| {
  22de7c:	48 8b 3d 85 21 02 00 	mov    rdi,QWORD PTR [rip+0x22185]        # 250008 <stderr_stream>
  22de83:	48 85 ff             	test   rdi,rdi
  22de86:	74 3c                	je     22dec4 <callMainWithArgs+0x2e4>
  22de88:	48 8b 0d b1 d1 01 00 	mov    rcx,QWORD PTR [rip+0x1d1b1]        # 24b040 <stderr_file_out_stream+0x8>
  22de8f:	eb 70                	jmp    22df01 <callMainWithArgs+0x321>
  22de91:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  22de98:	0f 1f 84 00 00 00 00 
  22de9f:	00 
  22dea0:	b0 01                	mov    al,0x1
  22dea2:	86 05 68 21 02 00    	xchg   BYTE PTR [rip+0x22168],al        # 250010 <stderr_mutex>
  22dea8:	84 c0                	test   al,al
  22deaa:	75 f4                	jne    22dea0 <callMainWithArgs+0x2c0>
  22deac:	48 8b 3d 55 21 02 00 	mov    rdi,QWORD PTR [rip+0x22155]        # 250008 <stderr_stream>
  22deb3:	48 85 ff             	test   rdi,rdi
  22deb6:	74 72                	je     22df2a <callMainWithArgs+0x34a>
  22deb8:	48 8b 0d 81 d1 01 00 	mov    rcx,QWORD PTR [rip+0x1d181]        # 24b040 <stderr_file_out_stream+0x8>
  22debf:	e9 a3 00 00 00       	jmp    22df67 <callMainWithArgs+0x387>
        stderr_file = try io.getStdErr();
  22dec4:	c7 05 62 d1 01 00 02 	mov    DWORD PTR [rip+0x1d162],0x2        # 24b030 <stderr_file>
  22decb:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  22dece:	48 8d 05 5b d1 01 00 	lea    rax,[rip+0x1d15b]        # 24b030 <stderr_file>
  22ded5:	48 89 05 5c d1 01 00 	mov    QWORD PTR [rip+0x1d15c],rax        # 24b038 <stderr_file_out_stream>
  22dedc:	48 8d 05 fd 1a ff ff 	lea    rax,[rip+0xffffffffffff1afd]        # 21f9e0 <FileOutStream_writeFn>
  22dee3:	48 89 05 56 d1 01 00 	mov    QWORD PTR [rip+0x1d156],rax        # 24b040 <stderr_file_out_stream+0x8>
  22deea:	48 8d 0d 4f d1 01 00 	lea    rcx,[rip+0x1d14f]        # 24b040 <stderr_file_out_stream+0x8>
  22def1:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  22def4:	48 89 15 0d 21 02 00 	mov    QWORD PTR [rip+0x2210d],rdx        # 250008 <stderr_stream>
  22defb:	48 89 c1             	mov    rcx,rax
  22defe:	48 89 d7             	mov    rdi,rdx
  22df01:	48 8d 35 f8 10 02 00 	lea    rsi,[rip+0x210f8]        # 24f000 <__unnamed_101>
  22df08:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  22df0a:	31 c0                	xor    eax,eax
  22df0c:	86 05 fe 20 02 00    	xchg   BYTE PTR [rip+0x220fe],al        # 250010 <stderr_mutex>
  22df12:	3c 01                	cmp    al,0x1
    if (!ok) {
  22df14:	0f 85 0a 04 00 00    	jne    22e324 <callMainWithArgs+0x744>
  22df1a:	48 83 c3 01          	add    rbx,0x1
    for (test_fn_list) |test_fn, i| {
  22df1e:	49 83 fc 0f          	cmp    r12,0xf
  22df22:	0f 82 08 fd ff ff    	jb     22dc30 <callMainWithArgs+0x50>
  22df28:	eb 66                	jmp    22df90 <callMainWithArgs+0x3b0>
        stderr_file = try io.getStdErr();
  22df2a:	c7 05 fc d0 01 00 02 	mov    DWORD PTR [rip+0x1d0fc],0x2        # 24b030 <stderr_file>
  22df31:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  22df34:	48 8d 05 f5 d0 01 00 	lea    rax,[rip+0x1d0f5]        # 24b030 <stderr_file>
  22df3b:	48 89 05 f6 d0 01 00 	mov    QWORD PTR [rip+0x1d0f6],rax        # 24b038 <stderr_file_out_stream>
  22df42:	48 8d 05 97 1a ff ff 	lea    rax,[rip+0xffffffffffff1a97]        # 21f9e0 <FileOutStream_writeFn>
  22df49:	48 89 05 f0 d0 01 00 	mov    QWORD PTR [rip+0x1d0f0],rax        # 24b040 <stderr_file_out_stream+0x8>
  22df50:	48 8d 0d e9 d0 01 00 	lea    rcx,[rip+0x1d0e9]        # 24b040 <stderr_file_out_stream+0x8>
  22df57:	48 89 ca             	mov    rdx,rcx
        stderr_stream = st;
  22df5a:	48 89 15 a7 20 02 00 	mov    QWORD PTR [rip+0x220a7],rdx        # 250008 <stderr_stream>
  22df61:	48 89 c1             	mov    rcx,rax
  22df64:	48 89 d7             	mov    rdi,rdx
  22df67:	48 8d 35 82 10 02 00 	lea    rsi,[rip+0x21082]        # 24eff0 <__unnamed_102>
  22df6e:	ff d1                	call   rcx
  22df70:	31 c0                	xor    eax,eax
  22df72:	86 05 98 20 02 00    	xchg   BYTE PTR [rip+0x22098],al        # 250010 <stderr_mutex>
  22df78:	3c 01                	cmp    al,0x1
    if (!ok) {
  22df7a:	0f 85 a4 03 00 00    	jne    22e324 <callMainWithArgs+0x744>
  22df80:	48 83 44 24 58 01    	add    QWORD PTR [rsp+0x58],0x1
  22df86:	49 83 fc 0f          	cmp    r12,0xf
  22df8a:	0f 82 a0 fc ff ff    	jb     22dc30 <callMainWithArgs+0x50>
  22df90:	48 8b 7c 24 58       	mov    rdi,QWORD PTR [rsp+0x58]
                warn("SKIP\n");
            },
            else => return err,
        }
    }
    if (ok_count == test_fn_list.len) {
  22df95:	48 83 ff 0f          	cmp    rdi,0xf
  22df99:	75 65                	jne    22e000 <callMainWithArgs+0x420>
  22df9b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  22dfa0:	b0 01                	mov    al,0x1
  22dfa2:	86 05 68 20 02 00    	xchg   BYTE PTR [rip+0x22068],al        # 250010 <stderr_mutex>
  22dfa8:	84 c0                	test   al,al
  22dfaa:	75 f4                	jne    22dfa0 <callMainWithArgs+0x3c0>
    if (stderr_stream) |st| {
  22dfac:	48 8b 3d 55 20 02 00 	mov    rdi,QWORD PTR [rip+0x22055]        # 250008 <stderr_stream>
  22dfb3:	48 85 ff             	test   rdi,rdi
  22dfb6:	0f 84 08 01 00 00    	je     22e0c4 <callMainWithArgs+0x4e4>
  22dfbc:	48 8b 0d 7d d0 01 00 	mov    rcx,QWORD PTR [rip+0x1d07d]        # 24b040 <stderr_file_out_stream+0x8>
  22dfc3:	e9 30 01 00 00       	jmp    22e0f8 <callMainWithArgs+0x518>
  22dfc8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  22dfcf:	00 
  22dfd0:	b0 01                	mov    al,0x1
  22dfd2:	86 05 38 20 02 00    	xchg   BYTE PTR [rip+0x22038],al        # 250010 <stderr_mutex>
  22dfd8:	84 c0                	test   al,al
  22dfda:	75 f4                	jne    22dfd0 <callMainWithArgs+0x3f0>
  22dfdc:	48 8b 1d 25 20 02 00 	mov    rbx,QWORD PTR [rip+0x22025]        # 250008 <stderr_stream>
  22dfe3:	48 85 db             	test   rbx,rbx
  22dfe6:	74 45                	je     22e02d <callMainWithArgs+0x44d>
  22dfe8:	4c 8b 35 51 d0 01 00 	mov    r14,QWORD PTR [rip+0x1d051]        # 24b040 <stderr_file_out_stream+0x8>
  22dfef:	eb 70                	jmp    22e061 <callMainWithArgs+0x481>
  22dff1:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  22dff8:	0f 1f 84 00 00 00 00 
  22dfff:	00 
  22e000:	b0 01                	mov    al,0x1
  22e002:	86 05 08 20 02 00    	xchg   BYTE PTR [rip+0x22008],al        # 250010 <stderr_mutex>
  22e008:	84 c0                	test   al,al
  22e00a:	75 f4                	jne    22e000 <callMainWithArgs+0x420>
  22e00c:	48 8b 2d f5 1f 02 00 	mov    rbp,QWORD PTR [rip+0x21ff5]        # 250008 <stderr_stream>
  22e013:	48 85 ed             	test   rbp,rbp
  22e016:	4c 8d 7c 24 4f       	lea    r15,[rsp+0x4f]
  22e01b:	0f 84 f5 00 00 00    	je     22e116 <callMainWithArgs+0x536>
  22e021:	4c 8b 35 18 d0 01 00 	mov    r14,QWORD PTR [rip+0x1d018]        # 24b040 <stderr_file_out_stream+0x8>
  22e028:	e9 1d 01 00 00       	jmp    22e14a <callMainWithArgs+0x56a>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  22e02d:	48 8d 05 fc cf 01 00 	lea    rax,[rip+0x1cffc]        # 24b030 <stderr_file>
  22e034:	48 89 05 fd cf 01 00 	mov    QWORD PTR [rip+0x1cffd],rax        # 24b038 <stderr_file_out_stream>
  22e03b:	4c 8d 35 9e 19 ff ff 	lea    r14,[rip+0xffffffffffff199e]        # 21f9e0 <FileOutStream_writeFn>
  22e042:	4c 89 35 f7 cf 01 00 	mov    QWORD PTR [rip+0x1cff7],r14        # 24b040 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  22e049:	c7 05 dd cf 01 00 02 	mov    DWORD PTR [rip+0x1cfdd],0x2        # 24b030 <stderr_file>
  22e050:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  22e053:	48 8d 1d e6 cf 01 00 	lea    rbx,[rip+0x1cfe6]        # 24b040 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  22e05a:	48 89 1d a7 1f 02 00 	mov    QWORD PTR [rip+0x21fa7],rbx        # 250008 <stderr_stream>
                        try output(context, fmt[start_index..i]);
  22e061:	48 8d 35 d8 0f 02 00 	lea    rsi,[rip+0x20fd8]        # 24f040 <__unnamed_103>
  22e068:	48 89 df             	mov    rdi,rbx
  22e06b:	41 ff d6             	call   r14
  22e06e:	66 85 c0             	test   ax,ax
  22e071:	75 39                	jne    22e0ac <callMainWithArgs+0x4cc>
  22e073:	48 0f bf c5          	movsx  rax,bp
  22e077:	48 c1 e0 04          	shl    rax,0x4
  22e07b:	48 8d 0d 7e df 01 00 	lea    rcx,[rip+0x1df7e]        # 24c000 <raw+0xf38>
  22e082:	48 01 c1             	add    rcx,rax
                const casted_value = ([]const u8)(value);
  22e085:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  22e089:	c5 f8 29 44 24 10    	vmovaps XMMWORD PTR [rsp+0x10],xmm0
  22e08f:	48 8d 74 24 10       	lea    rsi,[rsp+0x10]
                return output(context, casted_value);
  22e094:	48 89 df             	mov    rdi,rbx
  22e097:	41 ff d6             	call   r14
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  22e09a:	66 85 c0             	test   ax,ax
  22e09d:	75 0d                	jne    22e0ac <callMainWithArgs+0x4cc>
        try output(context, fmt[start_index..]);
  22e09f:	48 8d 35 aa 0f 02 00 	lea    rsi,[rip+0x20faa]        # 24f050 <__unnamed_104>
  22e0a6:	48 89 df             	mov    rdi,rbx
  22e0a9:	41 ff d6             	call   r14
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  22e0ac:	31 c9                	xor    ecx,ecx
  22e0ae:	86 0d 5c 1f 02 00    	xchg   BYTE PTR [rip+0x21f5c],cl        # 250010 <stderr_mutex>
  22e0b4:	b0 01                	mov    al,0x1
  22e0b6:	80 f9 01             	cmp    cl,0x1
    if (!ok) {
  22e0b9:	0f 84 56 02 00 00    	je     22e315 <callMainWithArgs+0x735>
  22e0bf:	e9 60 02 00 00       	jmp    22e324 <callMainWithArgs+0x744>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  22e0c4:	48 8d 05 65 cf 01 00 	lea    rax,[rip+0x1cf65]        # 24b030 <stderr_file>
  22e0cb:	48 89 05 66 cf 01 00 	mov    QWORD PTR [rip+0x1cf66],rax        # 24b038 <stderr_file_out_stream>
  22e0d2:	48 8d 0d 07 19 ff ff 	lea    rcx,[rip+0xffffffffffff1907]        # 21f9e0 <FileOutStream_writeFn>
  22e0d9:	48 89 0d 60 cf 01 00 	mov    QWORD PTR [rip+0x1cf60],rcx        # 24b040 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  22e0e0:	c7 05 46 cf 01 00 02 	mov    DWORD PTR [rip+0x1cf46],0x2        # 24b030 <stderr_file>
  22e0e7:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  22e0ea:	48 8d 3d 4f cf 01 00 	lea    rdi,[rip+0x1cf4f]        # 24b040 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  22e0f1:	48 89 3d 10 1f 02 00 	mov    QWORD PTR [rip+0x21f10],rdi        # 250008 <stderr_stream>
  22e0f8:	48 8d 35 11 0f 02 00 	lea    rsi,[rip+0x20f11]        # 24f010 <__unnamed_105>
  22e0ff:	ff d1                	call   rcx
  22e101:	31 c0                	xor    eax,eax
  22e103:	86 05 07 1f 02 00    	xchg   BYTE PTR [rip+0x21f07],al        # 250010 <stderr_mutex>
  22e109:	3c 01                	cmp    al,0x1
    if (!ok) {
  22e10b:	0f 84 02 02 00 00    	je     22e313 <callMainWithArgs+0x733>
  22e111:	e9 0e 02 00 00       	jmp    22e324 <callMainWithArgs+0x744>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  22e116:	48 8d 05 13 cf 01 00 	lea    rax,[rip+0x1cf13]        # 24b030 <stderr_file>
  22e11d:	48 89 05 14 cf 01 00 	mov    QWORD PTR [rip+0x1cf14],rax        # 24b038 <stderr_file_out_stream>
  22e124:	4c 8d 35 b5 18 ff ff 	lea    r14,[rip+0xffffffffffff18b5]        # 21f9e0 <FileOutStream_writeFn>
  22e12b:	4c 89 35 0e cf 01 00 	mov    QWORD PTR [rip+0x1cf0e],r14        # 24b040 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  22e132:	c7 05 f4 ce 01 00 02 	mov    DWORD PTR [rip+0x1cef4],0x2        # 24b030 <stderr_file>
  22e139:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  22e13c:	48 8d 2d fd ce 01 00 	lea    rbp,[rip+0x1cefd]        # 24b040 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  22e143:	48 89 2d be 1e 02 00 	mov    QWORD PTR [rip+0x21ebe],rbp        # 250008 <stderr_stream>
    var buf: [max_int_digits - 1]u8 = undefined;
  22e14a:	c5 fc 10 05 fd aa fd 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffdaafd]        # 208c4f <__unnamed_20+0x1f>
  22e151:	ff 
  22e152:	c5 fc 11 44 24 2f    	vmovups YMMWORD PTR [rsp+0x2f],ymm0
  22e158:	c5 fc 10 05 d0 aa fd 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffdaad0]        # 208c30 <__unnamed_20>
  22e15f:	ff 
  22e160:	c5 fc 11 44 24 10    	vmovups YMMWORD PTR [rsp+0x10],ymm0
        const digit = a % base;
  22e166:	48 89 fa             	mov    rdx,rdi
  22e169:	c4 c2 fb f6 cd       	mulx   rcx,rax,r13
  22e16e:	c1 e9 02             	shr    ecx,0x2
  22e171:	81 e1 fe ff ff 3f    	and    ecx,0x3ffffffe
  22e177:	8d 0c 89             	lea    ecx,[rcx+rcx*4]
  22e17a:	89 f8                	mov    eax,edi
  22e17c:	29 c8                	sub    eax,ecx
        0...9 => digit + '0',
  22e17e:	b1 30                	mov    cl,0x30
  22e180:	3c 0a                	cmp    al,0xa
  22e182:	72 02                	jb     22e186 <callMainWithArgs+0x5a6>
  22e184:	b1 57                	mov    cl,0x57
  22e186:	00 c1                	add    cl,al
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  22e188:	88 4c 24 4f          	mov    BYTE PTR [rsp+0x4f],cl
        if (a == 0) break;
  22e18c:	48 83 ff 0a          	cmp    rdi,0xa
  22e190:	73 0a                	jae    22e19c <callMainWithArgs+0x5bc>
  22e192:	b8 40 00 00 00       	mov    eax,0x40
  22e197:	4c 89 f9             	mov    rcx,r15
  22e19a:	eb 5c                	jmp    22e1f8 <callMainWithArgs+0x618>
  22e19c:	49 89 d8             	mov    r8,rbx
  22e19f:	b8 40 00 00 00       	mov    eax,0x40
  22e1a4:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  22e1ab:	00 00 00 00 00 
        a /= base;
  22e1b0:	48 89 fa             	mov    rdx,rdi
  22e1b3:	c4 c2 f3 f6 d5       	mulx   rdx,rcx,r13
  22e1b8:	48 c1 ea 03          	shr    rdx,0x3
        const digit = a % base;
  22e1bc:	c4 c2 f3 f6 f5       	mulx   rsi,rcx,r13
  22e1c1:	c1 ee 02             	shr    esi,0x2
  22e1c4:	81 e6 fe ff ff 3f    	and    esi,0x3ffffffe
  22e1ca:	8d 34 b6             	lea    esi,[rsi+rsi*4]
  22e1cd:	89 d1                	mov    ecx,edx
  22e1cf:	29 f1                	sub    ecx,esi
        0...9 => digit + '0',
  22e1d1:	b3 30                	mov    bl,0x30
  22e1d3:	80 f9 0a             	cmp    cl,0xa
  22e1d6:	72 02                	jb     22e1da <callMainWithArgs+0x5fa>
  22e1d8:	b3 57                	mov    bl,0x57
  22e1da:	00 cb                	add    bl,cl
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  22e1dc:	88 5c 04 0e          	mov    BYTE PTR [rsp+rax*1+0xe],bl
        if (a == 0) break;
  22e1e0:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  22e1e4:	48 83 ff 63          	cmp    rdi,0x63
  22e1e8:	48 89 d7             	mov    rdi,rdx
  22e1eb:	77 c3                	ja     22e1b0 <callMainWithArgs+0x5d0>
        const padded_buf = buf[index - padding ..];
  22e1ed:	48 8d 0c 04          	lea    rcx,[rsp+rax*1]
  22e1f1:	48 83 c1 0f          	add    rcx,0xf
  22e1f5:	4c 89 c3             	mov    rbx,r8
  22e1f8:	ba 41 00 00 00       	mov    edx,0x41
  22e1fd:	48 29 c2             	sub    rdx,rax
  22e200:	48 89 0c 24          	mov    QWORD PTR [rsp],rcx
  22e204:	48 89 54 24 08       	mov    QWORD PTR [rsp+0x8],rdx
  22e209:	48 89 e6             	mov    rsi,rsp
        return output(context, padded_buf);
  22e20c:	48 89 ef             	mov    rdi,rbp
  22e20f:	c5 f8 77             	vzeroupper 
  22e212:	41 ff d6             	call   r14
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  22e215:	66 85 c0             	test   ax,ax
  22e218:	0f 85 e9 00 00 00    	jne    22e307 <callMainWithArgs+0x727>
                        try output(context, fmt[start_index..i]);
  22e21e:	48 8d 35 fb 0d 02 00 	lea    rsi,[rip+0x20dfb]        # 24f020 <__unnamed_106>
  22e225:	48 89 ef             	mov    rdi,rbp
  22e228:	41 ff d6             	call   r14
  22e22b:	66 85 c0             	test   ax,ax
  22e22e:	0f 85 d3 00 00 00    	jne    22e307 <callMainWithArgs+0x727>
    var buf: [max_int_digits - 1]u8 = undefined;
  22e234:	c5 fc 10 05 13 aa fd 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffdaa13]        # 208c4f <__unnamed_20+0x1f>
  22e23b:	ff 
  22e23c:	c5 fc 11 44 24 2f    	vmovups YMMWORD PTR [rsp+0x2f],ymm0
  22e242:	c5 fc 10 05 e6 a9 fd 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffda9e6]        # 208c30 <__unnamed_20>
  22e249:	ff 
  22e24a:	c5 fc 11 44 24 10    	vmovups YMMWORD PTR [rsp+0x10],ymm0
        const digit = a % base;
  22e250:	48 89 da             	mov    rdx,rbx
  22e253:	c4 c2 fb f6 cd       	mulx   rcx,rax,r13
  22e258:	c1 e9 02             	shr    ecx,0x2
  22e25b:	81 e1 fe ff ff 3f    	and    ecx,0x3ffffffe
  22e261:	8d 0c 89             	lea    ecx,[rcx+rcx*4]
  22e264:	89 d8                	mov    eax,ebx
  22e266:	29 c8                	sub    eax,ecx
        0...9 => digit + '0',
  22e268:	b1 30                	mov    cl,0x30
  22e26a:	3c 0a                	cmp    al,0xa
  22e26c:	72 02                	jb     22e270 <callMainWithArgs+0x690>
  22e26e:	b1 57                	mov    cl,0x57
  22e270:	00 c1                	add    cl,al
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  22e272:	88 4c 24 4f          	mov    BYTE PTR [rsp+0x4f],cl
  22e276:	b8 40 00 00 00       	mov    eax,0x40
        if (a == 0) break;
  22e27b:	48 83 fb 0a          	cmp    rbx,0xa
  22e27f:	72 57                	jb     22e2d8 <callMainWithArgs+0x6f8>
  22e281:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  22e288:	0f 1f 84 00 00 00 00 
  22e28f:	00 
  22e290:	48 89 df             	mov    rdi,rbx
        a /= base;
  22e293:	48 89 da             	mov    rdx,rbx
  22e296:	c4 c2 f3 f6 d5       	mulx   rdx,rcx,r13
  22e29b:	48 c1 ea 03          	shr    rdx,0x3
        const digit = a % base;
  22e29f:	c4 c2 f3 f6 f5       	mulx   rsi,rcx,r13
  22e2a4:	c1 ee 02             	shr    esi,0x2
  22e2a7:	81 e6 fe ff ff 3f    	and    esi,0x3ffffffe
  22e2ad:	8d 34 b6             	lea    esi,[rsi+rsi*4]
  22e2b0:	89 d1                	mov    ecx,edx
  22e2b2:	29 f1                	sub    ecx,esi
        0...9 => digit + '0',
  22e2b4:	b3 30                	mov    bl,0x30
  22e2b6:	80 f9 0a             	cmp    cl,0xa
  22e2b9:	72 02                	jb     22e2bd <callMainWithArgs+0x6dd>
  22e2bb:	b3 57                	mov    bl,0x57
  22e2bd:	00 cb                	add    bl,cl
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  22e2bf:	88 5c 04 0e          	mov    BYTE PTR [rsp+rax*1+0xe],bl
        if (a == 0) break;
  22e2c3:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  22e2c7:	48 83 ff 63          	cmp    rdi,0x63
  22e2cb:	48 89 d3             	mov    rbx,rdx
  22e2ce:	77 c0                	ja     22e290 <callMainWithArgs+0x6b0>
        const padded_buf = buf[index - padding ..];
  22e2d0:	4c 8d 3c 04          	lea    r15,[rsp+rax*1]
  22e2d4:	49 83 c7 0f          	add    r15,0xf
  22e2d8:	b9 41 00 00 00       	mov    ecx,0x41
  22e2dd:	48 29 c1             	sub    rcx,rax
  22e2e0:	4c 89 3c 24          	mov    QWORD PTR [rsp],r15
  22e2e4:	48 89 4c 24 08       	mov    QWORD PTR [rsp+0x8],rcx
  22e2e9:	48 89 e6             	mov    rsi,rsp
        return output(context, padded_buf);
  22e2ec:	48 89 ef             	mov    rdi,rbp
  22e2ef:	c5 f8 77             	vzeroupper 
  22e2f2:	41 ff d6             	call   r14
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  22e2f5:	66 85 c0             	test   ax,ax
  22e2f8:	75 0d                	jne    22e307 <callMainWithArgs+0x727>
        try output(context, fmt[start_index..]);
  22e2fa:	48 8d 35 2f 0d 02 00 	lea    rsi,[rip+0x20d2f]        # 24f030 <__unnamed_107>
  22e301:	48 89 ef             	mov    rdi,rbp
  22e304:	41 ff d6             	call   r14
  22e307:	31 c0                	xor    eax,eax
  22e309:	86 05 01 1d 02 00    	xchg   BYTE PTR [rip+0x21d01],al        # 250010 <stderr_mutex>
  22e30f:	3c 01                	cmp    al,0x1
    if (!ok) {
  22e311:	75 11                	jne    22e324 <callMainWithArgs+0x744>
  22e313:	31 c0                	xor    eax,eax
    return callMain();
  22e315:	48 83 c4 78          	add    rsp,0x78
  22e319:	5b                   	pop    rbx
  22e31a:	41 5c                	pop    r12
  22e31c:	41 5d                	pop    r13
  22e31e:	41 5e                	pop    r14
  22e320:	41 5f                	pop    r15
  22e322:	5d                   	pop    rbp
  22e323:	c3                   	ret    
            @panic("assertion failure");
  22e324:	48 8d 3d dd 09 02 00 	lea    rdi,[rip+0x209dd]        # 24ed08 <__unnamed_2>
  22e32b:	e8 f0 3c fe ff       	call   212020 <panic>

000000000022e330 <memset>:

export fn memset(dest: ?[*]u8, c: u8, n: usize) ?[*]u8 {
    @setRuntimeSafety(false);

    var index: usize = 0;
    while (index != n) : (index += 1)
  22e330:	48 85 d2             	test   rdx,rdx
  22e333:	0f 84 d4 01 00 00    	je     22e50d <memset+0x1dd>
  22e339:	48 81 fa 80 00 00 00 	cmp    rdx,0x80
  22e340:	73 08                	jae    22e34a <memset+0x1a>
  22e342:	45 31 c0             	xor    r8d,r8d
  22e345:	e9 a8 01 00 00       	jmp    22e4f2 <memset+0x1c2>
  22e34a:	49 89 d0             	mov    r8,rdx
  22e34d:	49 83 e0 80          	and    r8,0xffffffffffffff80
  22e351:	c5 f9 6e c6          	vmovd  xmm0,esi
  22e355:	c4 e2 7d 78 c0       	vpbroadcastb ymm0,xmm0
  22e35a:	49 8d 48 80          	lea    rcx,[r8-0x80]
  22e35e:	48 89 c8             	mov    rax,rcx
  22e361:	48 c1 e8 07          	shr    rax,0x7
  22e365:	44 8d 48 01          	lea    r9d,[rax+0x1]
  22e369:	41 83 e1 07          	and    r9d,0x7
  22e36d:	48 81 f9 80 03 00 00 	cmp    rcx,0x380
  22e374:	73 10                	jae    22e386 <memset+0x56>
  22e376:	31 c0                	xor    eax,eax
  22e378:	4d 85 c9             	test   r9,r9
  22e37b:	0f 85 44 01 00 00    	jne    22e4c5 <memset+0x195>
  22e381:	e9 67 01 00 00       	jmp    22e4ed <memset+0x1bd>
  22e386:	48 8d 8f e0 03 00 00 	lea    rcx,[rdi+0x3e0]
  22e38d:	4d 8d 51 ff          	lea    r10,[r9-0x1]
  22e391:	49 29 c2             	sub    r10,rax
  22e394:	31 c0                	xor    eax,eax
  22e396:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  22e39d:	00 00 00 
        dest.?[index] = c;
  22e3a0:	c5 fe 7f 84 01 20 fc 	vmovdqu YMMWORD PTR [rcx+rax*1-0x3e0],ymm0
  22e3a7:	ff ff 
  22e3a9:	c5 fe 7f 84 01 40 fc 	vmovdqu YMMWORD PTR [rcx+rax*1-0x3c0],ymm0
  22e3b0:	ff ff 
  22e3b2:	c5 fe 7f 84 01 60 fc 	vmovdqu YMMWORD PTR [rcx+rax*1-0x3a0],ymm0
  22e3b9:	ff ff 
  22e3bb:	c5 fe 7f 84 01 80 fc 	vmovdqu YMMWORD PTR [rcx+rax*1-0x380],ymm0
  22e3c2:	ff ff 
  22e3c4:	c5 fe 7f 84 01 a0 fc 	vmovdqu YMMWORD PTR [rcx+rax*1-0x360],ymm0
  22e3cb:	ff ff 
  22e3cd:	c5 fe 7f 84 01 c0 fc 	vmovdqu YMMWORD PTR [rcx+rax*1-0x340],ymm0
  22e3d4:	ff ff 
  22e3d6:	c5 fe 7f 84 01 e0 fc 	vmovdqu YMMWORD PTR [rcx+rax*1-0x320],ymm0
  22e3dd:	ff ff 
  22e3df:	c5 fe 7f 84 01 00 fd 	vmovdqu YMMWORD PTR [rcx+rax*1-0x300],ymm0
  22e3e6:	ff ff 
  22e3e8:	c5 fe 7f 84 01 20 fd 	vmovdqu YMMWORD PTR [rcx+rax*1-0x2e0],ymm0
  22e3ef:	ff ff 
  22e3f1:	c5 fe 7f 84 01 40 fd 	vmovdqu YMMWORD PTR [rcx+rax*1-0x2c0],ymm0
  22e3f8:	ff ff 
  22e3fa:	c5 fe 7f 84 01 60 fd 	vmovdqu YMMWORD PTR [rcx+rax*1-0x2a0],ymm0
  22e401:	ff ff 
  22e403:	c5 fe 7f 84 01 80 fd 	vmovdqu YMMWORD PTR [rcx+rax*1-0x280],ymm0
  22e40a:	ff ff 
  22e40c:	c5 fe 7f 84 01 a0 fd 	vmovdqu YMMWORD PTR [rcx+rax*1-0x260],ymm0
  22e413:	ff ff 
  22e415:	c5 fe 7f 84 01 c0 fd 	vmovdqu YMMWORD PTR [rcx+rax*1-0x240],ymm0
  22e41c:	ff ff 
  22e41e:	c5 fe 7f 84 01 e0 fd 	vmovdqu YMMWORD PTR [rcx+rax*1-0x220],ymm0
  22e425:	ff ff 
  22e427:	c5 fe 7f 84 01 00 fe 	vmovdqu YMMWORD PTR [rcx+rax*1-0x200],ymm0
  22e42e:	ff ff 
  22e430:	c5 fe 7f 84 01 20 fe 	vmovdqu YMMWORD PTR [rcx+rax*1-0x1e0],ymm0
  22e437:	ff ff 
  22e439:	c5 fe 7f 84 01 40 fe 	vmovdqu YMMWORD PTR [rcx+rax*1-0x1c0],ymm0
  22e440:	ff ff 
  22e442:	c5 fe 7f 84 01 60 fe 	vmovdqu YMMWORD PTR [rcx+rax*1-0x1a0],ymm0
  22e449:	ff ff 
  22e44b:	c5 fe 7f 84 01 80 fe 	vmovdqu YMMWORD PTR [rcx+rax*1-0x180],ymm0
  22e452:	ff ff 
  22e454:	c5 fe 7f 84 01 a0 fe 	vmovdqu YMMWORD PTR [rcx+rax*1-0x160],ymm0
  22e45b:	ff ff 
  22e45d:	c5 fe 7f 84 01 c0 fe 	vmovdqu YMMWORD PTR [rcx+rax*1-0x140],ymm0
  22e464:	ff ff 
  22e466:	c5 fe 7f 84 01 e0 fe 	vmovdqu YMMWORD PTR [rcx+rax*1-0x120],ymm0
  22e46d:	ff ff 
  22e46f:	c5 fe 7f 84 01 00 ff 	vmovdqu YMMWORD PTR [rcx+rax*1-0x100],ymm0
  22e476:	ff ff 
  22e478:	c5 fe 7f 84 01 20 ff 	vmovdqu YMMWORD PTR [rcx+rax*1-0xe0],ymm0
  22e47f:	ff ff 
  22e481:	c5 fe 7f 84 01 40 ff 	vmovdqu YMMWORD PTR [rcx+rax*1-0xc0],ymm0
  22e488:	ff ff 
  22e48a:	c5 fe 7f 84 01 60 ff 	vmovdqu YMMWORD PTR [rcx+rax*1-0xa0],ymm0
  22e491:	ff ff 
  22e493:	c5 fe 7f 44 01 80    	vmovdqu YMMWORD PTR [rcx+rax*1-0x80],ymm0
  22e499:	c5 fe 7f 44 01 a0    	vmovdqu YMMWORD PTR [rcx+rax*1-0x60],ymm0
  22e49f:	c5 fe 7f 44 01 c0    	vmovdqu YMMWORD PTR [rcx+rax*1-0x40],ymm0
  22e4a5:	c5 fe 7f 44 01 e0    	vmovdqu YMMWORD PTR [rcx+rax*1-0x20],ymm0
  22e4ab:	c5 fe 7f 04 01       	vmovdqu YMMWORD PTR [rcx+rax*1],ymm0
    while (index != n) : (index += 1)
  22e4b0:	48 05 00 04 00 00    	add    rax,0x400
  22e4b6:	49 83 c2 08          	add    r10,0x8
  22e4ba:	0f 85 e0 fe ff ff    	jne    22e3a0 <memset+0x70>
  22e4c0:	4d 85 c9             	test   r9,r9
  22e4c3:	74 28                	je     22e4ed <memset+0x1bd>
  22e4c5:	48 01 f8             	add    rax,rdi
  22e4c8:	48 83 c0 60          	add    rax,0x60
  22e4cc:	49 f7 d9             	neg    r9
  22e4cf:	90                   	nop
        dest.?[index] = c;
  22e4d0:	c5 fe 7f 40 a0       	vmovdqu YMMWORD PTR [rax-0x60],ymm0
  22e4d5:	c5 fe 7f 40 c0       	vmovdqu YMMWORD PTR [rax-0x40],ymm0
  22e4da:	c5 fe 7f 40 e0       	vmovdqu YMMWORD PTR [rax-0x20],ymm0
  22e4df:	c5 fe 7f 00          	vmovdqu YMMWORD PTR [rax],ymm0
    while (index != n) : (index += 1)
  22e4e3:	48 83 e8 80          	sub    rax,0xffffffffffffff80
  22e4e7:	49 83 c1 01          	add    r9,0x1
  22e4eb:	75 e3                	jne    22e4d0 <memset+0x1a0>
  22e4ed:	49 39 d0             	cmp    r8,rdx
  22e4f0:	74 1b                	je     22e50d <memset+0x1dd>
        dest.?[index] = c;
  22e4f2:	4a 8d 04 07          	lea    rax,[rdi+r8*1]
  22e4f6:	4c 29 c2             	sub    rdx,r8
  22e4f9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  22e500:	40 88 30             	mov    BYTE PTR [rax],sil
    while (index != n) : (index += 1)
  22e503:	48 83 c0 01          	add    rax,0x1
  22e507:	48 83 c2 ff          	add    rdx,0xffffffffffffffff
  22e50b:	75 f3                	jne    22e500 <memset+0x1d0>

    return dest;
  22e50d:	48 89 f8             	mov    rax,rdi
  22e510:	c5 f8 77             	vzeroupper 
  22e513:	c3                   	ret    
  22e514:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  22e51b:	00 00 00 00 00 

000000000022e520 <memcpy>:

export fn memcpy(noalias dest: ?[*]u8, noalias src: ?[*]const u8, n: usize) ?[*]u8 {
    @setRuntimeSafety(false);

    var index: usize = 0;
    while (index != n) : (index += 1)
  22e520:	48 85 d2             	test   rdx,rdx
  22e523:	0f 84 d7 01 00 00    	je     22e700 <memcpy+0x1e0>
  22e529:	48 81 fa 80 00 00 00 	cmp    rdx,0x80
  22e530:	73 07                	jae    22e539 <memcpy+0x19>
  22e532:	31 c0                	xor    eax,eax
  22e534:	e9 b7 01 00 00       	jmp    22e6f0 <memcpy+0x1d0>
  22e539:	48 89 d0             	mov    rax,rdx
  22e53c:	48 83 e0 80          	and    rax,0xffffffffffffff80
  22e540:	4c 8d 48 80          	lea    r9,[rax-0x80]
  22e544:	4c 89 c9             	mov    rcx,r9
  22e547:	48 c1 e9 07          	shr    rcx,0x7
  22e54b:	44 8d 41 01          	lea    r8d,[rcx+0x1]
  22e54f:	41 83 e0 03          	and    r8d,0x3
  22e553:	49 81 f9 80 01 00 00 	cmp    r9,0x180
  22e55a:	73 10                	jae    22e56c <memcpy+0x4c>
  22e55c:	31 c9                	xor    ecx,ecx
  22e55e:	4d 85 c0             	test   r8,r8
  22e561:	0f 85 35 01 00 00    	jne    22e69c <memcpy+0x17c>
  22e567:	e9 7c 01 00 00       	jmp    22e6e8 <memcpy+0x1c8>
  22e56c:	4d 8d 48 ff          	lea    r9,[r8-0x1]
  22e570:	49 29 c9             	sub    r9,rcx
  22e573:	31 c9                	xor    ecx,ecx
  22e575:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  22e57c:	00 00 00 00 
        dest.?[index] = src.?[index];
  22e580:	c5 fc 10 04 0e       	vmovups ymm0,YMMWORD PTR [rsi+rcx*1]
  22e585:	c5 fc 10 4c 0e 20    	vmovups ymm1,YMMWORD PTR [rsi+rcx*1+0x20]
  22e58b:	c5 fc 10 54 0e 40    	vmovups ymm2,YMMWORD PTR [rsi+rcx*1+0x40]
  22e591:	c5 fc 10 5c 0e 60    	vmovups ymm3,YMMWORD PTR [rsi+rcx*1+0x60]
  22e597:	c5 fc 11 04 0f       	vmovups YMMWORD PTR [rdi+rcx*1],ymm0
  22e59c:	c5 fc 11 4c 0f 20    	vmovups YMMWORD PTR [rdi+rcx*1+0x20],ymm1
  22e5a2:	c5 fc 11 54 0f 40    	vmovups YMMWORD PTR [rdi+rcx*1+0x40],ymm2
  22e5a8:	c5 fc 11 5c 0f 60    	vmovups YMMWORD PTR [rdi+rcx*1+0x60],ymm3
  22e5ae:	c5 fc 10 84 0e 80 00 	vmovups ymm0,YMMWORD PTR [rsi+rcx*1+0x80]
  22e5b5:	00 00 
  22e5b7:	c5 fc 10 8c 0e a0 00 	vmovups ymm1,YMMWORD PTR [rsi+rcx*1+0xa0]
  22e5be:	00 00 
  22e5c0:	c5 fc 10 94 0e c0 00 	vmovups ymm2,YMMWORD PTR [rsi+rcx*1+0xc0]
  22e5c7:	00 00 
  22e5c9:	c5 fc 10 9c 0e e0 00 	vmovups ymm3,YMMWORD PTR [rsi+rcx*1+0xe0]
  22e5d0:	00 00 
  22e5d2:	c5 fc 11 84 0f 80 00 	vmovups YMMWORD PTR [rdi+rcx*1+0x80],ymm0
  22e5d9:	00 00 
  22e5db:	c5 fc 11 8c 0f a0 00 	vmovups YMMWORD PTR [rdi+rcx*1+0xa0],ymm1
  22e5e2:	00 00 
  22e5e4:	c5 fc 11 94 0f c0 00 	vmovups YMMWORD PTR [rdi+rcx*1+0xc0],ymm2
  22e5eb:	00 00 
  22e5ed:	c5 fc 11 9c 0f e0 00 	vmovups YMMWORD PTR [rdi+rcx*1+0xe0],ymm3
  22e5f4:	00 00 
  22e5f6:	c5 fc 10 84 0e 00 01 	vmovups ymm0,YMMWORD PTR [rsi+rcx*1+0x100]
  22e5fd:	00 00 
  22e5ff:	c5 fc 10 8c 0e 20 01 	vmovups ymm1,YMMWORD PTR [rsi+rcx*1+0x120]
  22e606:	00 00 
  22e608:	c5 fc 10 94 0e 40 01 	vmovups ymm2,YMMWORD PTR [rsi+rcx*1+0x140]
  22e60f:	00 00 
  22e611:	c5 fc 10 9c 0e 60 01 	vmovups ymm3,YMMWORD PTR [rsi+rcx*1+0x160]
  22e618:	00 00 
  22e61a:	c5 fc 11 84 0f 00 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x100],ymm0
  22e621:	00 00 
  22e623:	c5 fc 11 8c 0f 20 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x120],ymm1
  22e62a:	00 00 
  22e62c:	c5 fc 11 94 0f 40 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x140],ymm2
  22e633:	00 00 
  22e635:	c5 fc 11 9c 0f 60 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x160],ymm3
  22e63c:	00 00 
  22e63e:	c5 fc 10 84 0e 80 01 	vmovups ymm0,YMMWORD PTR [rsi+rcx*1+0x180]
  22e645:	00 00 
  22e647:	c5 fc 10 8c 0e a0 01 	vmovups ymm1,YMMWORD PTR [rsi+rcx*1+0x1a0]
  22e64e:	00 00 
  22e650:	c5 fc 10 94 0e c0 01 	vmovups ymm2,YMMWORD PTR [rsi+rcx*1+0x1c0]
  22e657:	00 00 
  22e659:	c5 fc 10 9c 0e e0 01 	vmovups ymm3,YMMWORD PTR [rsi+rcx*1+0x1e0]
  22e660:	00 00 
  22e662:	c5 fc 11 84 0f 80 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x180],ymm0
  22e669:	00 00 
  22e66b:	c5 fc 11 8c 0f a0 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x1a0],ymm1
  22e672:	00 00 
  22e674:	c5 fc 11 94 0f c0 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x1c0],ymm2
  22e67b:	00 00 
  22e67d:	c5 fc 11 9c 0f e0 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x1e0],ymm3
  22e684:	00 00 
    while (index != n) : (index += 1)
  22e686:	48 81 c1 00 02 00 00 	add    rcx,0x200
  22e68d:	49 83 c1 04          	add    r9,0x4
  22e691:	0f 85 e9 fe ff ff    	jne    22e580 <memcpy+0x60>
  22e697:	4d 85 c0             	test   r8,r8
  22e69a:	74 4c                	je     22e6e8 <memcpy+0x1c8>
  22e69c:	48 83 c1 60          	add    rcx,0x60
  22e6a0:	49 f7 d8             	neg    r8
  22e6a3:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  22e6aa:	84 00 00 00 00 00 
        dest.?[index] = src.?[index];
  22e6b0:	c5 fc 10 44 0e a0    	vmovups ymm0,YMMWORD PTR [rsi+rcx*1-0x60]
  22e6b6:	c5 fc 10 4c 0e c0    	vmovups ymm1,YMMWORD PTR [rsi+rcx*1-0x40]
  22e6bc:	c5 fc 10 54 0e e0    	vmovups ymm2,YMMWORD PTR [rsi+rcx*1-0x20]
  22e6c2:	c5 fc 10 1c 0e       	vmovups ymm3,YMMWORD PTR [rsi+rcx*1]
  22e6c7:	c5 fc 11 44 0f a0    	vmovups YMMWORD PTR [rdi+rcx*1-0x60],ymm0
  22e6cd:	c5 fc 11 4c 0f c0    	vmovups YMMWORD PTR [rdi+rcx*1-0x40],ymm1
  22e6d3:	c5 fc 11 54 0f e0    	vmovups YMMWORD PTR [rdi+rcx*1-0x20],ymm2
  22e6d9:	c5 fc 11 1c 0f       	vmovups YMMWORD PTR [rdi+rcx*1],ymm3
    while (index != n) : (index += 1)
  22e6de:	48 83 e9 80          	sub    rcx,0xffffffffffffff80
  22e6e2:	49 83 c0 01          	add    r8,0x1
  22e6e6:	75 c8                	jne    22e6b0 <memcpy+0x190>
  22e6e8:	48 39 d0             	cmp    rax,rdx
  22e6eb:	74 13                	je     22e700 <memcpy+0x1e0>
  22e6ed:	0f 1f 00             	nop    DWORD PTR [rax]
        dest.?[index] = src.?[index];
  22e6f0:	0f b6 0c 06          	movzx  ecx,BYTE PTR [rsi+rax*1]
  22e6f4:	88 0c 07             	mov    BYTE PTR [rdi+rax*1],cl
    while (index != n) : (index += 1)
  22e6f7:	48 83 c0 01          	add    rax,0x1
  22e6fb:	48 39 c2             	cmp    rdx,rax
  22e6fe:	75 f0                	jne    22e6f0 <memcpy+0x1d0>

    return dest;
  22e700:	48 89 f8             	mov    rax,rdi
  22e703:	c5 f8 77             	vzeroupper 
  22e706:	c3                   	ret    
  22e707:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  22e70e:	00 00 

000000000022e710 <memmove>:
}

export fn memmove(dest: ?[*]u8, src: ?[*]const u8, n: usize) ?[*]u8 {
    @setRuntimeSafety(false);

    if (@ptrToInt(dest) < @ptrToInt(src)) {
  22e710:	48 39 f7             	cmp    rdi,rsi
  22e713:	0f 83 cb 00 00 00    	jae    22e7e4 <memmove+0xd4>
  22e719:	48 85 d2             	test   rdx,rdx
        var index: usize = 0;
        while (index != n) : (index += 1) {
  22e71c:	0f 84 0f 05 00 00    	je     22ec31 <memmove+0x521>
  22e722:	48 81 fa 80 00 00 00 	cmp    rdx,0x80
  22e729:	72 1a                	jb     22e745 <memmove+0x35>
  22e72b:	48 8d 04 16          	lea    rax,[rsi+rdx*1]
  22e72f:	48 39 f8             	cmp    rax,rdi
  22e732:	0f 86 0b 01 00 00    	jbe    22e843 <memmove+0x133>
  22e738:	48 8d 04 17          	lea    rax,[rdi+rdx*1]
  22e73c:	48 39 f0             	cmp    rax,rsi
  22e73f:	0f 86 fe 00 00 00    	jbe    22e843 <memmove+0x133>
  22e745:	45 31 d2             	xor    r10d,r10d
            dest.?[index] = src.?[index];
  22e748:	4c 8d 42 ff          	lea    r8,[rdx-0x1]
  22e74c:	4d 29 d0             	sub    r8,r10
  22e74f:	48 89 d1             	mov    rcx,rdx
  22e752:	48 83 e1 07          	and    rcx,0x7
  22e756:	74 1b                	je     22e773 <memmove+0x63>
  22e758:	48 f7 d9             	neg    rcx
  22e75b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  22e760:	42 0f b6 04 16       	movzx  eax,BYTE PTR [rsi+r10*1]
  22e765:	42 88 04 17          	mov    BYTE PTR [rdi+r10*1],al
        while (index != n) : (index += 1) {
  22e769:	49 83 c2 01          	add    r10,0x1
  22e76d:	48 83 c1 01          	add    rcx,0x1
  22e771:	75 ed                	jne    22e760 <memmove+0x50>
            dest.?[index] = src.?[index];
  22e773:	49 83 f8 07          	cmp    r8,0x7
  22e777:	0f 82 b4 04 00 00    	jb     22ec31 <memmove+0x521>
  22e77d:	0f 1f 00             	nop    DWORD PTR [rax]
  22e780:	42 0f b6 04 16       	movzx  eax,BYTE PTR [rsi+r10*1]
  22e785:	42 88 04 17          	mov    BYTE PTR [rdi+r10*1],al
  22e789:	42 0f b6 44 16 01    	movzx  eax,BYTE PTR [rsi+r10*1+0x1]
  22e78f:	42 88 44 17 01       	mov    BYTE PTR [rdi+r10*1+0x1],al
  22e794:	42 0f b6 44 16 02    	movzx  eax,BYTE PTR [rsi+r10*1+0x2]
  22e79a:	42 88 44 17 02       	mov    BYTE PTR [rdi+r10*1+0x2],al
  22e79f:	42 0f b6 44 16 03    	movzx  eax,BYTE PTR [rsi+r10*1+0x3]
  22e7a5:	42 88 44 17 03       	mov    BYTE PTR [rdi+r10*1+0x3],al
  22e7aa:	42 0f b6 44 16 04    	movzx  eax,BYTE PTR [rsi+r10*1+0x4]
  22e7b0:	42 88 44 17 04       	mov    BYTE PTR [rdi+r10*1+0x4],al
  22e7b5:	42 0f b6 44 16 05    	movzx  eax,BYTE PTR [rsi+r10*1+0x5]
  22e7bb:	42 88 44 17 05       	mov    BYTE PTR [rdi+r10*1+0x5],al
  22e7c0:	42 0f b6 44 16 06    	movzx  eax,BYTE PTR [rsi+r10*1+0x6]
  22e7c6:	42 88 44 17 06       	mov    BYTE PTR [rdi+r10*1+0x6],al
  22e7cb:	42 0f b6 44 16 07    	movzx  eax,BYTE PTR [rsi+r10*1+0x7]
  22e7d1:	42 88 44 17 07       	mov    BYTE PTR [rdi+r10*1+0x7],al
        while (index != n) : (index += 1) {
  22e7d6:	49 83 c2 08          	add    r10,0x8
  22e7da:	4c 39 d2             	cmp    rdx,r10
  22e7dd:	75 a1                	jne    22e780 <memmove+0x70>
  22e7df:	e9 4d 04 00 00       	jmp    22ec31 <memmove+0x521>
  22e7e4:	48 85 d2             	test   rdx,rdx
        }
    } else {
        var index = n;
        while (index != 0) {
  22e7e7:	0f 84 44 04 00 00    	je     22ec31 <memmove+0x521>
  22e7ed:	48 81 fa 80 00 00 00 	cmp    rdx,0x80
  22e7f4:	0f 82 2a 02 00 00    	jb     22ea24 <memmove+0x314>
  22e7fa:	48 8d 04 16          	lea    rax,[rsi+rdx*1]
  22e7fe:	48 39 f8             	cmp    rax,rdi
  22e801:	76 0d                	jbe    22e810 <memmove+0x100>
  22e803:	48 8d 04 17          	lea    rax,[rdi+rdx*1]
  22e807:	48 39 f0             	cmp    rax,rsi
  22e80a:	0f 87 14 02 00 00    	ja     22ea24 <memmove+0x314>
  22e810:	49 89 d0             	mov    r8,rdx
  22e813:	49 83 e0 80          	and    r8,0xffffffffffffff80
  22e817:	49 8d 48 80          	lea    rcx,[r8-0x80]
  22e81b:	48 89 c8             	mov    rax,rcx
  22e81e:	48 c1 e8 07          	shr    rax,0x7
  22e822:	44 8d 48 01          	lea    r9d,[rax+0x1]
  22e826:	41 83 e1 03          	and    r9d,0x3
  22e82a:	48 81 f9 80 01 00 00 	cmp    rcx,0x180
  22e831:	73 47                	jae    22e87a <memmove+0x16a>
  22e833:	31 c0                	xor    eax,eax
  22e835:	4d 85 c9             	test   r9,r9
  22e838:	0f 85 8a 01 00 00    	jne    22e9c8 <memmove+0x2b8>
  22e83e:	e9 d5 01 00 00       	jmp    22ea18 <memmove+0x308>
        while (index != n) : (index += 1) {
  22e843:	49 89 d2             	mov    r10,rdx
  22e846:	49 83 e2 80          	and    r10,0xffffffffffffff80
  22e84a:	4d 8d 4a 80          	lea    r9,[r10-0x80]
  22e84e:	4c 89 c9             	mov    rcx,r9
  22e851:	48 c1 e9 07          	shr    rcx,0x7
  22e855:	44 8d 41 01          	lea    r8d,[rcx+0x1]
  22e859:	41 83 e0 03          	and    r8d,0x3
  22e85d:	49 81 f9 80 01 00 00 	cmp    r9,0x180
  22e864:	0f 83 4c 02 00 00    	jae    22eab6 <memmove+0x3a6>
  22e86a:	31 c9                	xor    ecx,ecx
  22e86c:	4d 85 c0             	test   r8,r8
  22e86f:	0f 85 67 03 00 00    	jne    22ebdc <memmove+0x4cc>
  22e875:	e9 ae 03 00 00       	jmp    22ec28 <memmove+0x518>
        while (index != 0) {
  22e87a:	4c 8d 14 16          	lea    r10,[rsi+rdx*1]
  22e87e:	49 83 c2 e0          	add    r10,0xffffffffffffffe0
  22e882:	48 8d 0c 17          	lea    rcx,[rdi+rdx*1]
  22e886:	48 83 c1 e0          	add    rcx,0xffffffffffffffe0
  22e88a:	4d 8d 59 ff          	lea    r11,[r9-0x1]
  22e88e:	49 29 c3             	sub    r11,rax
  22e891:	31 c0                	xor    eax,eax
  22e893:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  22e89a:	84 00 00 00 00 00 
            index -= 1;
            dest.?[index] = src.?[index];
  22e8a0:	c4 c1 7c 10 44 02 a0 	vmovups ymm0,YMMWORD PTR [r10+rax*1-0x60]
  22e8a7:	c4 c1 7c 10 4c 02 c0 	vmovups ymm1,YMMWORD PTR [r10+rax*1-0x40]
  22e8ae:	c4 c1 7c 10 54 02 e0 	vmovups ymm2,YMMWORD PTR [r10+rax*1-0x20]
  22e8b5:	c4 c1 7c 10 1c 02    	vmovups ymm3,YMMWORD PTR [r10+rax*1]
  22e8bb:	c5 fc 11 1c 01       	vmovups YMMWORD PTR [rcx+rax*1],ymm3
  22e8c0:	c5 fc 11 54 01 e0    	vmovups YMMWORD PTR [rcx+rax*1-0x20],ymm2
  22e8c6:	c5 fc 11 4c 01 c0    	vmovups YMMWORD PTR [rcx+rax*1-0x40],ymm1
  22e8cc:	c5 fc 11 44 01 a0    	vmovups YMMWORD PTR [rcx+rax*1-0x60],ymm0
  22e8d2:	c4 c1 7c 10 84 02 20 	vmovups ymm0,YMMWORD PTR [r10+rax*1-0xe0]
  22e8d9:	ff ff ff 
  22e8dc:	c4 c1 7c 10 8c 02 40 	vmovups ymm1,YMMWORD PTR [r10+rax*1-0xc0]
  22e8e3:	ff ff ff 
  22e8e6:	c4 c1 7c 10 94 02 60 	vmovups ymm2,YMMWORD PTR [r10+rax*1-0xa0]
  22e8ed:	ff ff ff 
  22e8f0:	c4 c1 7c 10 5c 02 80 	vmovups ymm3,YMMWORD PTR [r10+rax*1-0x80]
  22e8f7:	c5 fc 11 5c 01 80    	vmovups YMMWORD PTR [rcx+rax*1-0x80],ymm3
  22e8fd:	c5 fc 11 94 01 60 ff 	vmovups YMMWORD PTR [rcx+rax*1-0xa0],ymm2
  22e904:	ff ff 
  22e906:	c5 fc 11 8c 01 40 ff 	vmovups YMMWORD PTR [rcx+rax*1-0xc0],ymm1
  22e90d:	ff ff 
  22e90f:	c5 fc 11 84 01 20 ff 	vmovups YMMWORD PTR [rcx+rax*1-0xe0],ymm0
  22e916:	ff ff 
  22e918:	c4 c1 7c 10 84 02 a0 	vmovups ymm0,YMMWORD PTR [r10+rax*1-0x160]
  22e91f:	fe ff ff 
  22e922:	c4 c1 7c 10 8c 02 c0 	vmovups ymm1,YMMWORD PTR [r10+rax*1-0x140]
  22e929:	fe ff ff 
  22e92c:	c4 c1 7c 10 94 02 e0 	vmovups ymm2,YMMWORD PTR [r10+rax*1-0x120]
  22e933:	fe ff ff 
  22e936:	c4 c1 7c 10 9c 02 00 	vmovups ymm3,YMMWORD PTR [r10+rax*1-0x100]
  22e93d:	ff ff ff 
  22e940:	c5 fc 11 9c 01 00 ff 	vmovups YMMWORD PTR [rcx+rax*1-0x100],ymm3
  22e947:	ff ff 
  22e949:	c5 fc 11 94 01 e0 fe 	vmovups YMMWORD PTR [rcx+rax*1-0x120],ymm2
  22e950:	ff ff 
  22e952:	c5 fc 11 8c 01 c0 fe 	vmovups YMMWORD PTR [rcx+rax*1-0x140],ymm1
  22e959:	ff ff 
  22e95b:	c5 fc 11 84 01 a0 fe 	vmovups YMMWORD PTR [rcx+rax*1-0x160],ymm0
  22e962:	ff ff 
  22e964:	c4 c1 7c 10 84 02 20 	vmovups ymm0,YMMWORD PTR [r10+rax*1-0x1e0]
  22e96b:	fe ff ff 
  22e96e:	c4 c1 7c 10 8c 02 40 	vmovups ymm1,YMMWORD PTR [r10+rax*1-0x1c0]
  22e975:	fe ff ff 
  22e978:	c4 c1 7c 10 94 02 60 	vmovups ymm2,YMMWORD PTR [r10+rax*1-0x1a0]
  22e97f:	fe ff ff 
  22e982:	c4 c1 7c 10 9c 02 80 	vmovups ymm3,YMMWORD PTR [r10+rax*1-0x180]
  22e989:	fe ff ff 
  22e98c:	c5 fc 11 9c 01 80 fe 	vmovups YMMWORD PTR [rcx+rax*1-0x180],ymm3
  22e993:	ff ff 
  22e995:	c5 fc 11 94 01 60 fe 	vmovups YMMWORD PTR [rcx+rax*1-0x1a0],ymm2
  22e99c:	ff ff 
  22e99e:	c5 fc 11 8c 01 40 fe 	vmovups YMMWORD PTR [rcx+rax*1-0x1c0],ymm1
  22e9a5:	ff ff 
  22e9a7:	c5 fc 11 84 01 20 fe 	vmovups YMMWORD PTR [rcx+rax*1-0x1e0],ymm0
  22e9ae:	ff ff 
  22e9b0:	48 05 00 fe ff ff    	add    rax,0xfffffffffffffe00
  22e9b6:	49 83 c3 04          	add    r11,0x4
  22e9ba:	0f 85 e0 fe ff ff    	jne    22e8a0 <memmove+0x190>
  22e9c0:	48 f7 d8             	neg    rax
  22e9c3:	4d 85 c9             	test   r9,r9
  22e9c6:	74 50                	je     22ea18 <memmove+0x308>
  22e9c8:	48 8d 4a e0          	lea    rcx,[rdx-0x20]
  22e9cc:	48 29 c1             	sub    rcx,rax
  22e9cf:	49 f7 d9             	neg    r9
  22e9d2:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  22e9d9:	1f 84 00 00 00 00 00 
  22e9e0:	c5 fc 10 44 0e a0    	vmovups ymm0,YMMWORD PTR [rsi+rcx*1-0x60]
  22e9e6:	c5 fc 10 4c 0e c0    	vmovups ymm1,YMMWORD PTR [rsi+rcx*1-0x40]
  22e9ec:	c5 fc 10 54 0e e0    	vmovups ymm2,YMMWORD PTR [rsi+rcx*1-0x20]
  22e9f2:	c5 fc 10 1c 0e       	vmovups ymm3,YMMWORD PTR [rsi+rcx*1]
  22e9f7:	c5 fc 11 1c 0f       	vmovups YMMWORD PTR [rdi+rcx*1],ymm3
  22e9fc:	c5 fc 11 54 0f e0    	vmovups YMMWORD PTR [rdi+rcx*1-0x20],ymm2
  22ea02:	c5 fc 11 4c 0f c0    	vmovups YMMWORD PTR [rdi+rcx*1-0x40],ymm1
  22ea08:	c5 fc 11 44 0f a0    	vmovups YMMWORD PTR [rdi+rcx*1-0x60],ymm0
  22ea0e:	48 83 c1 80          	add    rcx,0xffffffffffffff80
  22ea12:	49 83 c1 01          	add    r9,0x1
  22ea16:	75 c8                	jne    22e9e0 <memmove+0x2d0>
  22ea18:	49 39 d0             	cmp    r8,rdx
        while (index != 0) {
  22ea1b:	0f 84 10 02 00 00    	je     22ec31 <memmove+0x521>
  22ea21:	4c 29 c2             	sub    rdx,r8
            index -= 1;
  22ea24:	4c 8d 42 ff          	lea    r8,[rdx-0x1]
  22ea28:	48 89 d1             	mov    rcx,rdx
  22ea2b:	48 83 e1 07          	and    rcx,0x7
  22ea2f:	74 22                	je     22ea53 <memmove+0x343>
  22ea31:	48 f7 d9             	neg    rcx
  22ea34:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  22ea3b:	00 00 00 00 00 
            dest.?[index] = src.?[index];
  22ea40:	0f b6 44 16 ff       	movzx  eax,BYTE PTR [rsi+rdx*1-0x1]
  22ea45:	88 44 17 ff          	mov    BYTE PTR [rdi+rdx*1-0x1],al
            index -= 1;
  22ea49:	48 8d 52 ff          	lea    rdx,[rdx-0x1]
        while (index != 0) {
  22ea4d:	48 83 c1 01          	add    rcx,0x1
  22ea51:	75 ed                	jne    22ea40 <memmove+0x330>
            index -= 1;
  22ea53:	49 83 f8 07          	cmp    r8,0x7
  22ea57:	0f 82 d4 01 00 00    	jb     22ec31 <memmove+0x521>
        while (index != 0) {
  22ea5d:	48 89 d0             	mov    rax,rdx
            dest.?[index] = src.?[index];
  22ea60:	0f b6 4c 16 ff       	movzx  ecx,BYTE PTR [rsi+rdx*1-0x1]
  22ea65:	88 4c 17 ff          	mov    BYTE PTR [rdi+rdx*1-0x1],cl
  22ea69:	0f b6 4c 16 fe       	movzx  ecx,BYTE PTR [rsi+rdx*1-0x2]
  22ea6e:	88 4c 17 fe          	mov    BYTE PTR [rdi+rdx*1-0x2],cl
  22ea72:	0f b6 4c 16 fd       	movzx  ecx,BYTE PTR [rsi+rdx*1-0x3]
  22ea77:	88 4c 17 fd          	mov    BYTE PTR [rdi+rdx*1-0x3],cl
  22ea7b:	0f b6 4c 16 fc       	movzx  ecx,BYTE PTR [rsi+rdx*1-0x4]
  22ea80:	88 4c 17 fc          	mov    BYTE PTR [rdi+rdx*1-0x4],cl
  22ea84:	0f b6 4c 16 fb       	movzx  ecx,BYTE PTR [rsi+rdx*1-0x5]
  22ea89:	88 4c 17 fb          	mov    BYTE PTR [rdi+rdx*1-0x5],cl
  22ea8d:	0f b6 4c 16 fa       	movzx  ecx,BYTE PTR [rsi+rdx*1-0x6]
  22ea92:	88 4c 17 fa          	mov    BYTE PTR [rdi+rdx*1-0x6],cl
  22ea96:	0f b6 4c 16 f9       	movzx  ecx,BYTE PTR [rsi+rdx*1-0x7]
  22ea9b:	88 4c 17 f9          	mov    BYTE PTR [rdi+rdx*1-0x7],cl
  22ea9f:	0f b6 4c 16 f8       	movzx  ecx,BYTE PTR [rsi+rdx*1-0x8]
  22eaa4:	88 4c 17 f8          	mov    BYTE PTR [rdi+rdx*1-0x8],cl
        while (index != 0) {
  22eaa8:	48 83 c0 f8          	add    rax,0xfffffffffffffff8
  22eaac:	48 89 c2             	mov    rdx,rax
  22eaaf:	75 af                	jne    22ea60 <memmove+0x350>
  22eab1:	e9 7b 01 00 00       	jmp    22ec31 <memmove+0x521>
        while (index != n) : (index += 1) {
  22eab6:	4d 8d 48 ff          	lea    r9,[r8-0x1]
  22eaba:	49 29 c9             	sub    r9,rcx
  22eabd:	31 c9                	xor    ecx,ecx
  22eabf:	90                   	nop
            dest.?[index] = src.?[index];
  22eac0:	c5 fc 10 04 0e       	vmovups ymm0,YMMWORD PTR [rsi+rcx*1]
  22eac5:	c5 fc 10 4c 0e 20    	vmovups ymm1,YMMWORD PTR [rsi+rcx*1+0x20]
  22eacb:	c5 fc 10 54 0e 40    	vmovups ymm2,YMMWORD PTR [rsi+rcx*1+0x40]
  22ead1:	c5 fc 10 5c 0e 60    	vmovups ymm3,YMMWORD PTR [rsi+rcx*1+0x60]
  22ead7:	c5 fc 11 04 0f       	vmovups YMMWORD PTR [rdi+rcx*1],ymm0
  22eadc:	c5 fc 11 4c 0f 20    	vmovups YMMWORD PTR [rdi+rcx*1+0x20],ymm1
  22eae2:	c5 fc 11 54 0f 40    	vmovups YMMWORD PTR [rdi+rcx*1+0x40],ymm2
  22eae8:	c5 fc 11 5c 0f 60    	vmovups YMMWORD PTR [rdi+rcx*1+0x60],ymm3
  22eaee:	c5 fc 10 84 0e 80 00 	vmovups ymm0,YMMWORD PTR [rsi+rcx*1+0x80]
  22eaf5:	00 00 
  22eaf7:	c5 fc 10 8c 0e a0 00 	vmovups ymm1,YMMWORD PTR [rsi+rcx*1+0xa0]
  22eafe:	00 00 
  22eb00:	c5 fc 10 94 0e c0 00 	vmovups ymm2,YMMWORD PTR [rsi+rcx*1+0xc0]
  22eb07:	00 00 
  22eb09:	c5 fc 10 9c 0e e0 00 	vmovups ymm3,YMMWORD PTR [rsi+rcx*1+0xe0]
  22eb10:	00 00 
  22eb12:	c5 fc 11 84 0f 80 00 	vmovups YMMWORD PTR [rdi+rcx*1+0x80],ymm0
  22eb19:	00 00 
  22eb1b:	c5 fc 11 8c 0f a0 00 	vmovups YMMWORD PTR [rdi+rcx*1+0xa0],ymm1
  22eb22:	00 00 
  22eb24:	c5 fc 11 94 0f c0 00 	vmovups YMMWORD PTR [rdi+rcx*1+0xc0],ymm2
  22eb2b:	00 00 
  22eb2d:	c5 fc 11 9c 0f e0 00 	vmovups YMMWORD PTR [rdi+rcx*1+0xe0],ymm3
  22eb34:	00 00 
  22eb36:	c5 fc 10 84 0e 00 01 	vmovups ymm0,YMMWORD PTR [rsi+rcx*1+0x100]
  22eb3d:	00 00 
  22eb3f:	c5 fc 10 8c 0e 20 01 	vmovups ymm1,YMMWORD PTR [rsi+rcx*1+0x120]
  22eb46:	00 00 
  22eb48:	c5 fc 10 94 0e 40 01 	vmovups ymm2,YMMWORD PTR [rsi+rcx*1+0x140]
  22eb4f:	00 00 
  22eb51:	c5 fc 10 9c 0e 60 01 	vmovups ymm3,YMMWORD PTR [rsi+rcx*1+0x160]
  22eb58:	00 00 
  22eb5a:	c5 fc 11 84 0f 00 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x100],ymm0
  22eb61:	00 00 
  22eb63:	c5 fc 11 8c 0f 20 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x120],ymm1
  22eb6a:	00 00 
  22eb6c:	c5 fc 11 94 0f 40 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x140],ymm2
  22eb73:	00 00 
  22eb75:	c5 fc 11 9c 0f 60 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x160],ymm3
  22eb7c:	00 00 
  22eb7e:	c5 fc 10 84 0e 80 01 	vmovups ymm0,YMMWORD PTR [rsi+rcx*1+0x180]
  22eb85:	00 00 
  22eb87:	c5 fc 10 8c 0e a0 01 	vmovups ymm1,YMMWORD PTR [rsi+rcx*1+0x1a0]
  22eb8e:	00 00 
  22eb90:	c5 fc 10 94 0e c0 01 	vmovups ymm2,YMMWORD PTR [rsi+rcx*1+0x1c0]
  22eb97:	00 00 
  22eb99:	c5 fc 10 9c 0e e0 01 	vmovups ymm3,YMMWORD PTR [rsi+rcx*1+0x1e0]
  22eba0:	00 00 
  22eba2:	c5 fc 11 84 0f 80 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x180],ymm0
  22eba9:	00 00 
  22ebab:	c5 fc 11 8c 0f a0 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x1a0],ymm1
  22ebb2:	00 00 
  22ebb4:	c5 fc 11 94 0f c0 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x1c0],ymm2
  22ebbb:	00 00 
  22ebbd:	c5 fc 11 9c 0f e0 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x1e0],ymm3
  22ebc4:	00 00 
        while (index != n) : (index += 1) {
  22ebc6:	48 81 c1 00 02 00 00 	add    rcx,0x200
  22ebcd:	49 83 c1 04          	add    r9,0x4
  22ebd1:	0f 85 e9 fe ff ff    	jne    22eac0 <memmove+0x3b0>
  22ebd7:	4d 85 c0             	test   r8,r8
  22ebda:	74 4c                	je     22ec28 <memmove+0x518>
  22ebdc:	48 83 c1 60          	add    rcx,0x60
  22ebe0:	49 f7 d8             	neg    r8
  22ebe3:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  22ebea:	84 00 00 00 00 00 
            dest.?[index] = src.?[index];
  22ebf0:	c5 fc 10 44 0e a0    	vmovups ymm0,YMMWORD PTR [rsi+rcx*1-0x60]
  22ebf6:	c5 fc 10 4c 0e c0    	vmovups ymm1,YMMWORD PTR [rsi+rcx*1-0x40]
  22ebfc:	c5 fc 10 54 0e e0    	vmovups ymm2,YMMWORD PTR [rsi+rcx*1-0x20]
  22ec02:	c5 fc 10 1c 0e       	vmovups ymm3,YMMWORD PTR [rsi+rcx*1]
  22ec07:	c5 fc 11 44 0f a0    	vmovups YMMWORD PTR [rdi+rcx*1-0x60],ymm0
  22ec0d:	c5 fc 11 4c 0f c0    	vmovups YMMWORD PTR [rdi+rcx*1-0x40],ymm1
  22ec13:	c5 fc 11 54 0f e0    	vmovups YMMWORD PTR [rdi+rcx*1-0x20],ymm2
  22ec19:	c5 fc 11 1c 0f       	vmovups YMMWORD PTR [rdi+rcx*1],ymm3
        while (index != n) : (index += 1) {
  22ec1e:	48 83 e9 80          	sub    rcx,0xffffffffffffff80
  22ec22:	49 83 c0 01          	add    r8,0x1
  22ec26:	75 c8                	jne    22ebf0 <memmove+0x4e0>
  22ec28:	49 39 d2             	cmp    r10,rdx
  22ec2b:	0f 85 17 fb ff ff    	jne    22e748 <memmove+0x38>
        }
    }

    return dest;
  22ec31:	48 89 f8             	mov    rax,rdi
  22ec34:	c5 f8 77             	vzeroupper 
  22ec37:	c3                   	ret    
  22ec38:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  22ec3f:	00 

000000000022ec40 <clone>:

// TODO we should be able to put this directly in std/linux/x86_64.zig but
// it causes a segfault in release mode. this is a workaround of calling it
// across .o file boundaries. fix comptime @ptrCast of nakedcc functions.
nakedcc fn clone() void {
    asm volatile (
  22ec40:	31 c0                	xor    eax,eax
  22ec42:	b0 38                	mov    al,0x38
  22ec44:	49 89 fb             	mov    r11,rdi
  22ec47:	48 89 d7             	mov    rdi,rdx
  22ec4a:	4c 89 c2             	mov    rdx,r8
  22ec4d:	4d 89 c8             	mov    r8,r9
  22ec50:	4c 8b 54 24 08       	mov    r10,QWORD PTR [rsp+0x8]
  22ec55:	4d 89 d9             	mov    r9,r11
  22ec58:	48 83 e6 f0          	and    rsi,0xfffffffffffffff0
  22ec5c:	48 83 ee 08          	sub    rsi,0x8
  22ec60:	48 89 0e             	mov    QWORD PTR [rsi],rcx
  22ec63:	0f 05                	syscall 
  22ec65:	85 c0                	test   eax,eax
  22ec67:	75 0f                	jne    22ec78 <clone+0x38>
  22ec69:	31 ed                	xor    ebp,ebp
  22ec6b:	5f                   	pop    rdi
  22ec6c:	41 ff d1             	call   r9
  22ec6f:	89 c7                	mov    edi,eax
  22ec71:	31 c0                	xor    eax,eax
  22ec73:	b0 3c                	mov    al,0x3c
  22ec75:	0f 05                	syscall 
  22ec77:	f4                   	hlt    
  22ec78:	c3                   	ret    
nakedcc fn clone() void {
  22ec79:	c3                   	ret    
  22ec7a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

000000000022ec80 <fmodf>:
    const digits = if (T == f32) 23 else 52;
    const exp_bits = if (T == f32) 9 else 12;
    const bits_minus_1 = T.bit_count - 1;
    const mask = if (T == f32) 0xff else 0x7ff;
    var ux = @bitCast(uint, x);
    var uy = @bitCast(uint, y);
  22ec80:	c4 c1 79 7e c9       	vmovd  r9d,xmm1
    var ex = @intCast(i32, (ux >> digits) & mask);
    var ey = @intCast(i32, (uy >> digits) & mask);
    const sx = if (T == f32) @intCast(u32, ux & 0x80000000) else @intCast(i32, ux >> bits_minus_1);
    var i: uint = undefined;

    if (uy << 1 == 0 or isNan(uint, uy) or ex == mask)
  22ec85:	44 89 c8             	mov    eax,r9d
  22ec88:	01 c0                	add    eax,eax
  22ec8a:	74 5a                	je     22ece6 <fmodf+0x66>

fn isNan(comptime T: type, bits: T) bool {
    if (T == u16) {
        return (bits & 0x7fff) > 0x7c00;
    } else if (T == u32) {
        return (bits & 0x7fffffff) > 0x7f800000;
  22ec8c:	44 89 c9             	mov    ecx,r9d
  22ec8f:	81 e1 ff ff ff 7f    	and    ecx,0x7fffffff
  22ec95:	81 f9 00 00 80 7f    	cmp    ecx,0x7f800000
    if (uy << 1 == 0 or isNan(uint, uy) or ex == mask)
  22ec9b:	77 49                	ja     22ece6 <fmodf+0x66>
  22ec9d:	c4 c1 79 7e c0       	vmovd  r8d,xmm0
  22eca2:	ba 17 08 00 00       	mov    edx,0x817
  22eca7:	c4 c2 68 f7 c8       	bextr  ecx,r8d,edx
  22ecac:	81 f9 ff 00 00 00    	cmp    ecx,0xff
  22ecb2:	74 32                	je     22ece6 <fmodf+0x66>
    if (ux << 1 <= uy << 1) {
  22ecb4:	43 8d 34 00          	lea    esi,[r8+r8*1]
  22ecb8:	39 c6                	cmp    esi,eax
  22ecba:	76 33                	jbe    22ecef <fmodf+0x6f>
  22ecbc:	c4 c2 68 f7 f9       	bextr  edi,r9d,edx
        ux &= @maxValue(uint) >> exp_bits;
  22ecc1:	44 89 c0             	mov    eax,r8d
    if (ex == 0) {
  22ecc4:	85 c9                	test   ecx,ecx
  22ecc6:	74 32                	je     22ecfa <fmodf+0x7a>
        ux &= @maxValue(uint) >> exp_bits;
  22ecc8:	25 ff ff 7f 00       	and    eax,0x7fffff
        ux |= 1 << digits;
  22eccd:	0d 00 00 80 00       	or     eax,0x800000
    if (ey == 0) {
  22ecd2:	85 ff                	test   edi,edi
  22ecd4:	74 51                	je     22ed27 <fmodf+0xa7>
        uy &= @maxValue(uint) >> exp_bits;
  22ecd6:	41 81 e1 ff ff 7f 00 	and    r9d,0x7fffff
        uy |= 1 << digits;
  22ecdd:	41 81 c9 00 00 80 00 	or     r9d,0x800000
  22ece4:	eb 7f                	jmp    22ed65 <fmodf+0xe5>
        return (x * y) / (x * y);
  22ece6:	c5 fa 59 c1          	vmulss xmm0,xmm0,xmm1
  22ecea:	c5 fa 5e c0          	vdivss xmm0,xmm0,xmm0
    return generic_fmod(f32, x, y);
  22ecee:	c3                   	ret    
        if (ux << 1 == uy << 1)
  22ecef:	75 08                	jne    22ecf9 <fmodf+0x79>
  22ecf1:	c5 f1 ef c9          	vpxor  xmm1,xmm1,xmm1
  22ecf5:	c5 fa 59 c1          	vmulss xmm0,xmm0,xmm1
  22ecf9:	c3                   	ret    
  22ecfa:	31 c9                	xor    ecx,ecx
        i = ux << exp_bits;
  22ecfc:	c1 e0 09             	shl    eax,0x9
        while (i >> bits_minus_1 == 0) : (b: {
  22ecff:	78 16                	js     22ed17 <fmodf+0x97>
  22ed01:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  22ed08:	0f 1f 84 00 00 00 00 
  22ed0f:	00 
            ex -= 1;
  22ed10:	83 c1 ff             	add    ecx,0xffffffff
            i <<= 1;
  22ed13:	01 c0                	add    eax,eax
        while (i >> bits_minus_1 == 0) : (b: {
  22ed15:	79 f9                	jns    22ed10 <fmodf+0x90>
        ux <<= @intCast(log2uint, @bitCast(u32, -ex + 1));
  22ed17:	b8 01 00 00 00       	mov    eax,0x1
  22ed1c:	29 c8                	sub    eax,ecx
  22ed1e:	c4 c2 79 f7 c0       	shlx   eax,r8d,eax
    if (ey == 0) {
  22ed23:	85 ff                	test   edi,edi
  22ed25:	75 af                	jne    22ecd6 <fmodf+0x56>
        i = uy << exp_bits;
  22ed27:	44 89 ca             	mov    edx,r9d
  22ed2a:	31 ff                	xor    edi,edi
  22ed2c:	c1 e2 09             	shl    edx,0x9
        while (i >> bits_minus_1 == 0) : (b: {
  22ed2f:	78 16                	js     22ed47 <fmodf+0xc7>
  22ed31:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  22ed38:	0f 1f 84 00 00 00 00 
  22ed3f:	00 
            ey -= 1;
  22ed40:	83 c7 ff             	add    edi,0xffffffff
            i <<= 1;
  22ed43:	01 d2                	add    edx,edx
        while (i >> bits_minus_1 == 0) : (b: {
  22ed45:	79 f9                	jns    22ed40 <fmodf+0xc0>
        uy <<= @intCast(log2uint, @bitCast(u32, -ey + 1));
  22ed47:	ba 01 00 00 00       	mov    edx,0x1
  22ed4c:	29 fa                	sub    edx,edi
  22ed4e:	c4 42 69 f7 c9       	shlx   r9d,r9d,edx
  22ed53:	eb 10                	jmp    22ed65 <fmodf+0xe5>
  22ed55:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  22ed5c:	00 00 00 00 
        ux <<= 1;
  22ed60:	01 c0                	add    eax,eax
    while (ex > ey) : (ex -= 1) {
  22ed62:	83 c1 ff             	add    ecx,0xffffffff
  22ed65:	89 c6                	mov    esi,eax
  22ed67:	44 29 ce             	sub    esi,r9d
  22ed6a:	0f 99 c2             	setns  dl
  22ed6d:	39 f9                	cmp    ecx,edi
  22ed6f:	7e 0d                	jle    22ed7e <fmodf+0xfe>
        if (i >> bits_minus_1 == 0) {
  22ed71:	f6 c2 01             	test   dl,0x1
  22ed74:	74 ea                	je     22ed60 <fmodf+0xe0>
  22ed76:	89 f0                	mov    eax,esi
            if (i == 0)
  22ed78:	85 f6                	test   esi,esi
  22ed7a:	75 e4                	jne    22ed60 <fmodf+0xe0>
  22ed7c:	eb 3b                	jmp    22edb9 <fmodf+0x139>
    if (i >> bits_minus_1 == 0) {
  22ed7e:	84 d2                	test   dl,dl
  22ed80:	74 06                	je     22ed88 <fmodf+0x108>
  22ed82:	89 f0                	mov    eax,esi
        if (i == 0)
  22ed84:	85 f6                	test   esi,esi
  22ed86:	74 31                	je     22edb9 <fmodf+0x139>
    while (ux >> digits == 0) : (b: {
  22ed88:	3d ff ff 7f 00       	cmp    eax,0x7fffff
  22ed8d:	77 0d                	ja     22ed9c <fmodf+0x11c>
  22ed8f:	90                   	nop
        ux <<= 1;
  22ed90:	01 c0                	add    eax,eax
        ex -= 1;
  22ed92:	83 c1 ff             	add    ecx,0xffffffff
    while (ux >> digits == 0) : (b: {
  22ed95:	3d 00 00 80 00       	cmp    eax,0x800000
  22ed9a:	72 f4                	jb     22ed90 <fmodf+0x110>
  22ed9c:	41 81 e0 00 00 00 80 	and    r8d,0x80000000
    if (ex > 0) {
  22eda3:	85 c9                	test   ecx,ecx
  22eda5:	7e 1b                	jle    22edc2 <fmodf+0x142>
        ux -%= 1 << digits;
  22eda7:	05 00 00 80 ff       	add    eax,0xff800000
        ux |= uint(@bitCast(u32, ex)) << digits;
  22edac:	c1 e1 17             	shl    ecx,0x17
  22edaf:	09 c1                	or     ecx,eax
        ux |= sx;
  22edb1:	44 09 c1             	or     ecx,r8d
    return @bitCast(T, ux);
  22edb4:	c5 f9 6e c1          	vmovd  xmm0,ecx
    return generic_fmod(f32, x, y);
  22edb8:	c3                   	ret    
  22edb9:	c5 f1 ef c9          	vpxor  xmm1,xmm1,xmm1
  22edbd:	c5 fa 59 c1          	vmulss xmm0,xmm0,xmm1
  22edc1:	c3                   	ret    
        ux >>= @intCast(log2uint, @bitCast(u32, -ex + 1));
  22edc2:	ba 01 00 00 00       	mov    edx,0x1
  22edc7:	29 ca                	sub    edx,ecx
  22edc9:	c4 e2 6b f7 c8       	shrx   ecx,eax,edx
        ux |= sx;
  22edce:	44 09 c1             	or     ecx,r8d
    return @bitCast(T, ux);
  22edd1:	c5 f9 6e c1          	vmovd  xmm0,ecx
    return generic_fmod(f32, x, y);
  22edd5:	c3                   	ret    
  22edd6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  22eddd:	00 00 00 

000000000022ede0 <fmod>:
    var uy = @bitCast(uint, y);
  22ede0:	c4 c1 f9 7e cb       	vmovq  r11,xmm1
    if (uy << 1 == 0 or isNan(uint, uy) or ex == mask)
  22ede5:	4c 89 d8             	mov    rax,r11
  22ede8:	48 01 c0             	add    rax,rax
  22edeb:	74 7a                	je     22ee67 <fmod+0x87>
  22eded:	49 b9 ff ff ff ff ff 	movabs r9,0x7fffffffffffffff
  22edf4:	ff ff 7f 
    } else if (T == u64) {
        return (bits & (@maxValue(u64) >> 1)) > (u64(0x7ff) << 52);
  22edf7:	4c 89 d9             	mov    rcx,r11
  22edfa:	4c 21 c9             	and    rcx,r9
  22edfd:	48 ba 00 00 00 00 00 	movabs rdx,0x7ff0000000000000
  22ee04:	00 f0 7f 
  22ee07:	48 39 d1             	cmp    rcx,rdx
    if (uy << 1 == 0 or isNan(uint, uy) or ex == mask)
  22ee0a:	77 5b                	ja     22ee67 <fmod+0x87>
  22ee0c:	c4 c1 f9 7e c2       	vmovq  r10,xmm0
  22ee11:	4c 89 d1             	mov    rcx,r10
  22ee14:	48 c1 e9 34          	shr    rcx,0x34
  22ee18:	81 e1 ff 07 00 00    	and    ecx,0x7ff
  22ee1e:	81 f9 ff 07 00 00    	cmp    ecx,0x7ff
  22ee24:	74 41                	je     22ee67 <fmod+0x87>
    if (ux << 1 <= uy << 1) {
  22ee26:	4b 8d 14 12          	lea    rdx,[r10+r10*1]
  22ee2a:	48 39 c2             	cmp    rdx,rax
  22ee2d:	76 41                	jbe    22ee70 <fmod+0x90>
  22ee2f:	4c 89 df             	mov    rdi,r11
  22ee32:	48 c1 ef 34          	shr    rdi,0x34
  22ee36:	81 e7 ff 07 00 00    	and    edi,0x7ff
  22ee3c:	49 b8 00 00 00 00 00 	movabs r8,0x10000000000000
  22ee43:	00 10 00 
    if (ex == 0) {
  22ee46:	85 c9                	test   ecx,ecx
  22ee48:	74 31                	je     22ee7b <fmod+0x9b>
        ux &= @maxValue(uint) >> exp_bits;
  22ee4a:	49 8d 40 ff          	lea    rax,[r8-0x1]
  22ee4e:	4c 21 d0             	and    rax,r10
        ux |= 1 << digits;
  22ee51:	4c 09 c0             	or     rax,r8
    if (ey == 0) {
  22ee54:	85 ff                	test   edi,edi
  22ee56:	74 50                	je     22eea8 <fmod+0xc8>
        uy &= @maxValue(uint) >> exp_bits;
  22ee58:	49 8d 50 ff          	lea    rdx,[r8-0x1]
  22ee5c:	49 21 d3             	and    r11,rdx
        uy |= 1 << digits;
  22ee5f:	4d 09 c3             	or     r11,r8
  22ee62:	e9 7f 00 00 00       	jmp    22eee6 <fmod+0x106>
        return (x * y) / (x * y);
  22ee67:	c5 fb 59 c1          	vmulsd xmm0,xmm0,xmm1
  22ee6b:	c5 fb 5e c0          	vdivsd xmm0,xmm0,xmm0
    return generic_fmod(f64, x, y);
  22ee6f:	c3                   	ret    
        if (ux << 1 == uy << 1)
  22ee70:	75 08                	jne    22ee7a <fmod+0x9a>
  22ee72:	c5 f1 ef c9          	vpxor  xmm1,xmm1,xmm1
  22ee76:	c5 fb 59 c1          	vmulsd xmm0,xmm0,xmm1
  22ee7a:	c3                   	ret    
        i = ux << exp_bits;
  22ee7b:	4c 89 d0             	mov    rax,r10
  22ee7e:	31 c9                	xor    ecx,ecx
  22ee80:	48 c1 e0 0c          	shl    rax,0xc
        while (i >> bits_minus_1 == 0) : (b: {
  22ee84:	78 12                	js     22ee98 <fmod+0xb8>
  22ee86:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  22ee8d:	00 00 00 
            ex -= 1;
  22ee90:	83 c1 ff             	add    ecx,0xffffffff
            i <<= 1;
  22ee93:	48 01 c0             	add    rax,rax
        while (i >> bits_minus_1 == 0) : (b: {
  22ee96:	79 f8                	jns    22ee90 <fmod+0xb0>
        ux <<= @intCast(log2uint, @bitCast(u32, -ex + 1));
  22ee98:	b8 01 00 00 00       	mov    eax,0x1
  22ee9d:	29 c8                	sub    eax,ecx
  22ee9f:	c4 c2 f9 f7 c2       	shlx   rax,r10,rax
    if (ey == 0) {
  22eea4:	85 ff                	test   edi,edi
  22eea6:	75 b0                	jne    22ee58 <fmod+0x78>
        i = uy << exp_bits;
  22eea8:	4c 89 da             	mov    rdx,r11
  22eeab:	31 ff                	xor    edi,edi
  22eead:	48 c1 e2 0c          	shl    rdx,0xc
        while (i >> bits_minus_1 == 0) : (b: {
  22eeb1:	78 15                	js     22eec8 <fmod+0xe8>
  22eeb3:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  22eeba:	84 00 00 00 00 00 
            ey -= 1;
  22eec0:	83 c7 ff             	add    edi,0xffffffff
            i <<= 1;
  22eec3:	48 01 d2             	add    rdx,rdx
        while (i >> bits_minus_1 == 0) : (b: {
  22eec6:	79 f8                	jns    22eec0 <fmod+0xe0>
        uy <<= @intCast(log2uint, @bitCast(u32, -ey + 1));
  22eec8:	ba 01 00 00 00       	mov    edx,0x1
  22eecd:	29 fa                	sub    edx,edi
  22eecf:	c4 42 e9 f7 db       	shlx   r11,r11,rdx
  22eed4:	eb 10                	jmp    22eee6 <fmod+0x106>
  22eed6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  22eedd:	00 00 00 
        ux <<= 1;
  22eee0:	48 01 c0             	add    rax,rax
    while (ex > ey) : (ex -= 1) {
  22eee3:	83 c1 ff             	add    ecx,0xffffffff
  22eee6:	48 89 c6             	mov    rsi,rax
  22eee9:	4c 29 de             	sub    rsi,r11
  22eeec:	0f 99 c2             	setns  dl
  22eeef:	39 f9                	cmp    ecx,edi
  22eef1:	7e 0f                	jle    22ef02 <fmod+0x122>
        if (i >> bits_minus_1 == 0) {
  22eef3:	f6 c2 01             	test   dl,0x1
  22eef6:	74 e8                	je     22eee0 <fmod+0x100>
  22eef8:	48 89 f0             	mov    rax,rsi
            if (i == 0)
  22eefb:	48 85 f6             	test   rsi,rsi
  22eefe:	75 e0                	jne    22eee0 <fmod+0x100>
  22ef00:	eb 4d                	jmp    22ef4f <fmod+0x16f>
    if (i >> bits_minus_1 == 0) {
  22ef02:	84 d2                	test   dl,dl
  22ef04:	74 08                	je     22ef0e <fmod+0x12e>
  22ef06:	48 89 f0             	mov    rax,rsi
        if (i == 0)
  22ef09:	48 85 f6             	test   rsi,rsi
  22ef0c:	74 41                	je     22ef4f <fmod+0x16f>
  22ef0e:	49 83 c1 01          	add    r9,0x1
    while (ux >> digits == 0) : (b: {
  22ef12:	4c 39 c0             	cmp    rax,r8
  22ef15:	73 14                	jae    22ef2b <fmod+0x14b>
  22ef17:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  22ef1e:	00 00 
        ux <<= 1;
  22ef20:	48 01 c0             	add    rax,rax
        ex -= 1;
  22ef23:	83 c1 ff             	add    ecx,0xffffffff
    while (ux >> digits == 0) : (b: {
  22ef26:	4c 39 c0             	cmp    rax,r8
  22ef29:	72 f5                	jb     22ef20 <fmod+0x140>
  22ef2b:	4d 21 ca             	and    r10,r9
    if (ex > 0) {
  22ef2e:	85 c9                	test   ecx,ecx
  22ef30:	7e 26                	jle    22ef58 <fmod+0x178>
        ux -%= 1 << digits;
  22ef32:	48 ba 00 00 00 00 00 	movabs rdx,0xfff0000000000000
  22ef39:	00 f0 ff 
  22ef3c:	48 01 d0             	add    rax,rdx
        ux |= uint(@bitCast(u32, ex)) << digits;
  22ef3f:	48 c1 e1 34          	shl    rcx,0x34
  22ef43:	48 09 c1             	or     rcx,rax
        ux |= @intCast(uint, sx) << bits_minus_1;
  22ef46:	4c 09 d1             	or     rcx,r10
    return @bitCast(T, ux);
  22ef49:	c4 e1 f9 6e c1       	vmovq  xmm0,rcx
    return generic_fmod(f64, x, y);
  22ef4e:	c3                   	ret    
  22ef4f:	c5 f1 ef c9          	vpxor  xmm1,xmm1,xmm1
  22ef53:	c5 fb 59 c1          	vmulsd xmm0,xmm0,xmm1
  22ef57:	c3                   	ret    
        ux >>= @intCast(log2uint, @bitCast(u32, -ex + 1));
  22ef58:	ba 01 00 00 00       	mov    edx,0x1
  22ef5d:	29 ca                	sub    edx,ecx
  22ef5f:	c4 e2 eb f7 c8       	shrx   rcx,rax,rdx
        ux |= @intCast(uint, sx) << bits_minus_1;
  22ef64:	4c 09 d1             	or     rcx,r10
    return @bitCast(T, ux);
  22ef67:	c4 e1 f9 6e c1       	vmovq  xmm0,rcx
    return generic_fmod(f64, x, y);
  22ef6c:	c3                   	ret    
  22ef6d:	0f 1f 00             	nop    DWORD PTR [rax]

000000000022ef70 <floorf>:
    if (x == 0.0) {
  22ef70:	c5 f0 57 c9          	vxorps xmm1,xmm1,xmm1
  22ef74:	c5 f8 2e c1          	vucomiss xmm0,xmm1
  22ef78:	75 02                	jne    22ef7c <floorf+0xc>
  22ef7a:	7b 57                	jnp    22efd3 <floorf+0x63>
  22ef7c:	c5 f9 7e c1          	vmovd  ecx,xmm0
  22ef80:	89 c8                	mov    eax,ecx
  22ef82:	c1 e8 17             	shr    eax,0x17
  22ef85:	0f b6 d0             	movzx  edx,al
  22ef88:	81 fa 95 00 00 00    	cmp    edx,0x95
  22ef8e:	77 43                	ja     22efd3 <floorf+0x63>
    if (e >= 0) {
  22ef90:	83 fa 7f             	cmp    edx,0x7f
  22ef93:	72 2e                	jb     22efc3 <floorf+0x53>
  22ef95:	83 c0 01             	add    eax,0x1
        m = u32(0x007FFFFF) >> @intCast(u5, e);
  22ef98:	83 e0 1f             	and    eax,0x1f
  22ef9b:	ba ff ff 7f 00       	mov    edx,0x7fffff
  22efa0:	c4 e2 7b f7 d2       	shrx   edx,edx,eax
        if (u & m == 0) {
  22efa5:	85 ca                	test   edx,ecx
  22efa7:	74 2a                	je     22efd3 <floorf+0x63>
        if (u >> 31 != 0) {
  22efa9:	89 ce                	mov    esi,ecx
  22efab:	c1 fe 1f             	sar    esi,0x1f
  22efae:	21 d6                	and    esi,edx
  22efb0:	01 ce                	add    esi,ecx
        return @bitCast(f32, u & ~m);
  22efb2:	b9 00 00 80 ff       	mov    ecx,0xff800000
  22efb7:	c4 e2 7a f7 c1       	sarx   eax,ecx,eax
  22efbc:	21 f0                	and    eax,esi
  22efbe:	c5 f9 6e c0          	vmovd  xmm0,eax
    return math.floor(x);
  22efc2:	c3                   	ret    
        if (u >> 31 == 0) {
  22efc3:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  22efc7:	85 c9                	test   ecx,ecx
  22efc9:	79 08                	jns    22efd3 <floorf+0x63>
  22efcb:	c5 f9 6e 05 21 a7 fd 	vmovd  xmm0,DWORD PTR [rip+0xfffffffffffda721]        # 2096f4 <__unnamed_55+0x14>
  22efd2:	ff 
  22efd3:	c3                   	ret    
  22efd4:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  22efdb:	00 00 00 00 00 

000000000022efe0 <ceilf>:
    var u = @bitCast(u32, x);
    var e = @intCast(i32, (u >> 23) & 0xFF) - 0x7F;
    var m: u32 = undefined;

    // TODO: Shouldn't need this explicit check.
    if (x == 0.0) {
  22efe0:	c5 f0 57 c9          	vxorps xmm1,xmm1,xmm1
  22efe4:	c5 f8 2e c1          	vucomiss xmm0,xmm1
  22efe8:	75 02                	jne    22efec <ceilf+0xc>
  22efea:	7b 5a                	jnp    22f046 <ceilf+0x66>
  22efec:	c5 f9 7e c1          	vmovd  ecx,xmm0
  22eff0:	89 c8                	mov    eax,ecx
  22eff2:	c1 e8 17             	shr    eax,0x17
  22eff5:	0f b6 d0             	movzx  edx,al
  22eff8:	81 fa 95 00 00 00    	cmp    edx,0x95
  22effe:	77 46                	ja     22f046 <ceilf+0x66>
        return x;
    }

    if (e >= 23) {
        return x;
    } else if (e >= 0) {
  22f000:	83 fa 7f             	cmp    edx,0x7f
  22f003:	72 31                	jb     22f036 <ceilf+0x56>
  22f005:	83 c0 01             	add    eax,0x1
        m = u32(0x007FFFFF) >> @intCast(u5, e);
  22f008:	83 e0 1f             	and    eax,0x1f
  22f00b:	ba ff ff 7f 00       	mov    edx,0x7fffff
  22f010:	c4 e2 7b f7 d2       	shrx   edx,edx,eax
        if (u & m == 0) {
  22f015:	85 ca                	test   edx,ecx
  22f017:	74 2d                	je     22f046 <ceilf+0x66>
            return x;
        }
        math.forceEval(x + 0x1.0p120);
        if (u >> 31 == 0) {
  22f019:	89 ce                	mov    esi,ecx
  22f01b:	c1 fe 1f             	sar    esi,0x1f
  22f01e:	c4 e2 48 f2 d2       	andn   edx,esi,edx
  22f023:	01 ca                	add    edx,ecx
            u += m;
        }
        u &= ~m;
  22f025:	b9 00 00 80 ff       	mov    ecx,0xff800000
  22f02a:	c4 e2 7a f7 c1       	sarx   eax,ecx,eax
  22f02f:	21 d0                	and    eax,edx
        return @bitCast(f32, u);
  22f031:	c5 f9 6e c0          	vmovd  xmm0,eax
    return math.ceil(x);
  22f035:	c3                   	ret    
    } else {
        math.forceEval(x + 0x1.0p120);
        if (u >> 31 != 0) {
  22f036:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  22f03a:	85 c9                	test   ecx,ecx
  22f03c:	78 08                	js     22f046 <ceilf+0x66>
  22f03e:	c5 f9 6e 05 aa a6 fd 	vmovd  xmm0,DWORD PTR [rip+0xfffffffffffda6aa]        # 2096f0 <__unnamed_55+0x10>
  22f045:	ff 
  22f046:	c3                   	ret    
  22f047:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  22f04e:	00 00 

000000000022f050 <floor>:
    if (e >= 0x3FF + 52 or x == 0) {
  22f050:	c5 f1 57 c9          	vxorpd xmm1,xmm1,xmm1
  22f054:	c5 f9 2e c1          	vucomisd xmm0,xmm1
  22f058:	75 02                	jne    22f05c <floor+0xc>
  22f05a:	7b 58                	jnp    22f0b4 <floor+0x64>
  22f05c:	c4 e1 f9 7e c0       	vmovq  rax,xmm0
  22f061:	b9 34 0b 00 00       	mov    ecx,0xb34
  22f066:	c4 e2 f0 f7 c8       	bextr  rcx,rax,rcx
  22f06b:	48 81 f9 32 04 00 00 	cmp    rcx,0x432
  22f072:	77 40                	ja     22f0b4 <floor+0x64>
        y = x - math.f64_toint + math.f64_toint - x;
  22f074:	c5 fb 10 0d 5c 12 fd 	vmovsd xmm1,QWORD PTR [rip+0xfffffffffffd125c]        # 2002d8 <__unnamed_10+0x58>
  22f07b:	ff 
  22f07c:	c5 fb 10 15 9c 12 fd 	vmovsd xmm2,QWORD PTR [rip+0xfffffffffffd129c]        # 200320 <__unnamed_610+0x20>
  22f083:	ff 
    if (u >> 63 != 0) {
  22f084:	48 85 c0             	test   rax,rax
  22f087:	78 2c                	js     22f0b5 <floor+0x65>
  22f089:	c5 fb 58 d2          	vaddsd xmm2,xmm0,xmm2
  22f08d:	c5 eb 58 c9          	vaddsd xmm1,xmm2,xmm1
    if (e <= 0x3FF - 1) {
  22f091:	48 81 f9 fe 03 00 00 	cmp    rcx,0x3fe
  22f098:	76 2c                	jbe    22f0c6 <floor+0x76>
  22f09a:	c5 f3 5c c8          	vsubsd xmm1,xmm1,xmm0
    } else if (y > 0) {
  22f09e:	c5 e9 57 d2          	vxorpd xmm2,xmm2,xmm2
  22f0a2:	c5 f9 2e ca          	vucomisd xmm1,xmm2
  22f0a6:	c5 f3 58 c0          	vaddsd xmm0,xmm1,xmm0
  22f0aa:	76 08                	jbe    22f0b4 <floor+0x64>
        return x + y - 1;
  22f0ac:	c5 fb 58 05 44 12 fd 	vaddsd xmm0,xmm0,QWORD PTR [rip+0xfffffffffffd1244]        # 2002f8 <__unnamed_600+0x10>
  22f0b3:	ff 
    return math.floor(x);
  22f0b4:	c3                   	ret    
  22f0b5:	c5 fb 58 c9          	vaddsd xmm1,xmm0,xmm1
  22f0b9:	c5 f3 58 ca          	vaddsd xmm1,xmm1,xmm2
    if (e <= 0x3FF - 1) {
  22f0bd:	48 81 f9 fe 03 00 00 	cmp    rcx,0x3fe
  22f0c4:	77 d4                	ja     22f09a <floor+0x4a>
    if (u >> 63 != 0) {
  22f0c6:	48 85 c0             	test   rax,rax
        if (u >> 63 != 0) {
  22f0c9:	78 05                	js     22f0d0 <floor+0x80>
  22f0cb:	c5 f9 57 c0          	vxorpd xmm0,xmm0,xmm0
  22f0cf:	c3                   	ret    
  22f0d0:	c5 fb 10 05 20 12 fd 	vmovsd xmm0,QWORD PTR [rip+0xfffffffffffd1220]        # 2002f8 <__unnamed_600+0x10>
  22f0d7:	ff 
  22f0d8:	c3                   	ret    
  22f0d9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

000000000022f0e0 <ceil>:
fn ceil64(x: f64) f64 {
    const u = @bitCast(u64, x);
    const e = (u >> 52) & 0x7FF;
    var y: f64 = undefined;

    if (e >= 0x3FF + 52 or x == 0) {
  22f0e0:	c5 f1 57 c9          	vxorpd xmm1,xmm1,xmm1
  22f0e4:	c5 f9 2e c1          	vucomisd xmm0,xmm1
  22f0e8:	75 02                	jne    22f0ec <ceil+0xc>
  22f0ea:	7b 7d                	jnp    22f169 <ceil+0x89>
  22f0ec:	c4 e1 f9 7e c0       	vmovq  rax,xmm0
  22f0f1:	b9 34 0b 00 00       	mov    ecx,0xb34
  22f0f6:	c4 e2 f0 f7 c8       	bextr  rcx,rax,rcx
  22f0fb:	48 81 f9 32 04 00 00 	cmp    rcx,0x432
  22f102:	77 65                	ja     22f169 <ceil+0x89>
        return x;
    }

    if (u >> 63 != 0) {
        y = x - math.f64_toint + math.f64_toint - x;
  22f104:	c5 fb 10 0d cc 11 fd 	vmovsd xmm1,QWORD PTR [rip+0xfffffffffffd11cc]        # 2002d8 <__unnamed_10+0x58>
  22f10b:	ff 
  22f10c:	c5 fb 10 15 0c 12 fd 	vmovsd xmm2,QWORD PTR [rip+0xfffffffffffd120c]        # 200320 <__unnamed_610+0x20>
  22f113:	ff 
    if (u >> 63 != 0) {
  22f114:	48 85 c0             	test   rax,rax
  22f117:	78 2d                	js     22f146 <ceil+0x66>
  22f119:	c5 fb 58 d2          	vaddsd xmm2,xmm0,xmm2
  22f11d:	c5 eb 58 c9          	vaddsd xmm1,xmm2,xmm1
    } else {
        y = x + math.f64_toint - math.f64_toint - x;
    }

    if (e <= 0x3FF - 1) {
  22f121:	48 81 f9 fe 03 00 00 	cmp    rcx,0x3fe
  22f128:	76 2d                	jbe    22f157 <ceil+0x77>
  22f12a:	c5 f3 5c c8          	vsubsd xmm1,xmm1,xmm0
        if (u >> 63 != 0) {
            return -0.0;
        } else {
            return 1.0;
        }
    } else if (y < 0) {
  22f12e:	c5 e9 57 d2          	vxorpd xmm2,xmm2,xmm2
  22f132:	c5 f9 2e d1          	vucomisd xmm2,xmm1
  22f136:	c5 f3 58 c0          	vaddsd xmm0,xmm1,xmm0
  22f13a:	76 2d                	jbe    22f169 <ceil+0x89>
        return x + y + 1;
  22f13c:	c5 fb 58 05 84 11 fd 	vaddsd xmm0,xmm0,QWORD PTR [rip+0xfffffffffffd1184]        # 2002c8 <__unnamed_10+0x48>
  22f143:	ff 
  22f144:	eb 23                	jmp    22f169 <ceil+0x89>
  22f146:	c5 fb 58 c9          	vaddsd xmm1,xmm0,xmm1
  22f14a:	c5 f3 58 ca          	vaddsd xmm1,xmm1,xmm2
    if (e <= 0x3FF - 1) {
  22f14e:	48 81 f9 fe 03 00 00 	cmp    rcx,0x3fe
  22f155:	77 d3                	ja     22f12a <ceil+0x4a>
        if (u >> 63 != 0) {
  22f157:	c5 f9 57 c0          	vxorpd xmm0,xmm0,xmm0
    if (u >> 63 != 0) {
  22f15b:	48 85 c0             	test   rax,rax
        if (u >> 63 != 0) {
  22f15e:	78 09                	js     22f169 <ceil+0x89>
  22f160:	c5 fb 10 05 60 11 fd 	vmovsd xmm0,QWORD PTR [rip+0xfffffffffffd1160]        # 2002c8 <__unnamed_10+0x48>
  22f167:	ff 
    return math.ceil(x);
  22f168:	c3                   	ret    
  22f169:	c3                   	ret    
  22f16a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

000000000022f170 <sqrt>:
// behaviour. Most intermediate i32 values are changed to u32 where appropriate but there are
// potentially some edge cases remaining that are not handled in the same way.
export fn sqrt(x: f64) f64 {
    const tiny: f64 = 1.0e-300;
    const sign: u32 = 0x80000000;
    const u = @bitCast(u64, x);
  22f170:	c4 e1 f9 7e c0       	vmovq  rax,xmm0

    var ix0 = @intCast(u32, u >> 32);
  22f175:	48 89 c7             	mov    rdi,rax
  22f178:	48 c1 ef 20          	shr    rdi,0x20
    var ix1 = @intCast(u32, u & 0xFFFFFFFF);

    // sqrt(nan) = nan, sqrt(+inf) = +inf, sqrt(-inf) = nan
    if (ix0 & 0x7FF00000 == 0x7FF00000) {
  22f17c:	b9 00 00 f0 7f       	mov    ecx,0x7ff00000
  22f181:	c4 e2 40 f2 c9       	andn   ecx,edi,ecx
  22f186:	75 09                	jne    22f191 <sqrt+0x21>
        return x * x + x;
  22f188:	c5 fb 59 c8          	vmulsd xmm1,xmm0,xmm0
  22f18c:	c5 f3 58 c0          	vaddsd xmm0,xmm1,xmm0
  22f190:	c3                   	ret    
    }

    // sqrt(+-0) = +-0
    if (x == 0.0) {
  22f191:	c5 f0 57 c9          	vxorps xmm1,xmm1,xmm1
  22f195:	c5 f9 2e c1          	vucomisd xmm0,xmm1
  22f199:	75 03                	jne    22f19e <sqrt+0x2e>
  22f19b:	7a 01                	jp     22f19e <sqrt+0x2e>
        return x;
  22f19d:	c3                   	ret    
    }
    // sqrt(-ve) = snan
    if (ix0 & sign != 0) {
  22f19e:	85 ff                	test   edi,edi
  22f1a0:	0f 88 cf 00 00 00    	js     22f275 <sqrt+0x105>
        return math.snan(f64);
    }

    // normalize x
    var m = @intCast(i32, ix0 >> 20);
  22f1a6:	49 89 c0             	mov    r8,rax
  22f1a9:	49 c1 e8 34          	shr    r8,0x34
    if (m == 0) {
  22f1ad:	45 85 c0             	test   r8d,r8d
  22f1b0:	75 5b                	jne    22f20d <sqrt+0x9d>
  22f1b2:	31 d2                	xor    edx,edx
  22f1b4:	31 c9                	xor    ecx,ecx
        // subnormal
        while (ix0 == 0) {
  22f1b6:	85 ff                	test   edi,edi
  22f1b8:	75 15                	jne    22f1cf <sqrt+0x5f>
  22f1ba:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
            m -= 21;
  22f1c0:	83 c1 eb             	add    ecx,0xffffffeb
            ix0 |= ix1 >> 11;
  22f1c3:	89 c7                	mov    edi,eax
  22f1c5:	c1 ef 0b             	shr    edi,0xb
            ix1 <<= 21;
  22f1c8:	c1 e0 15             	shl    eax,0x15
        while (ix0 == 0) {
  22f1cb:	85 ff                	test   edi,edi
  22f1cd:	74 f1                	je     22f1c0 <sqrt+0x50>
  22f1cf:	31 f6                	xor    esi,esi
        }

        // subnormal
        var i: u32 = 0;
        while (ix0 & 0x00100000 == 0) : (i += 1) {
  22f1d1:	0f ba e7 14          	bt     edi,0x14
  22f1d5:	72 20                	jb     22f1f7 <sqrt+0x87>
  22f1d7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  22f1de:	00 00 
  22f1e0:	89 fa                	mov    edx,edi
            ix0 <<= 1;
  22f1e2:	8d 3c 12             	lea    edi,[rdx+rdx*1]
        while (ix0 & 0x00100000 == 0) : (i += 1) {
  22f1e5:	83 c6 ff             	add    esi,0xffffffff
  22f1e8:	f7 c2 00 00 08 00    	test   edx,0x80000
  22f1ee:	74 f0                	je     22f1e0 <sqrt+0x70>
  22f1f0:	89 f2                	mov    edx,esi
  22f1f2:	f7 da                	neg    edx
  22f1f4:	83 e2 1f             	and    edx,0x1f
        }
        m -= @intCast(i32, i) - 1;
  22f1f7:	44 8d 04 31          	lea    r8d,[rcx+rsi*1]
  22f1fb:	41 83 c0 01          	add    r8d,0x1
        ix0 |= ix1 >> @intCast(u5, 32 - i);
  22f1ff:	c4 e2 4b f7 c8       	shrx   ecx,eax,esi
  22f204:	09 f9                	or     ecx,edi
        ix1 <<= @intCast(u5, i);
  22f206:	c4 e2 69 f7 c0       	shlx   eax,eax,edx
  22f20b:	89 cf                	mov    edi,ecx
    }

    // unbias exponent
    m -= 1023;
  22f20d:	41 81 c0 01 fc ff ff 	add    r8d,0xfffffc01
    ix0 = (ix0 & 0x000FFFFF) | 0x00100000;
  22f214:	81 e7 ff ff 0f 00    	and    edi,0xfffff
  22f21a:	81 cf 00 00 10 00    	or     edi,0x100000
    if (m & 1 != 0) {
  22f220:	41 f6 c0 01          	test   r8b,0x1
  22f224:	74 06                	je     22f22c <sqrt+0xbc>
        ix0 += ix0 + (ix1 >> 31);
  22f226:	0f a4 c7 01          	shld   edi,eax,0x1
        ix1 = ix1 +% ix1;
  22f22a:	01 c0                	add    eax,eax
    }
    m >>= 1;

    // sqrt(x) bit by bit
    ix0 += ix0 + (ix1 >> 31);
  22f22c:	0f a4 c7 01          	shld   edi,eax,0x1
    var t: u32 = undefined;
    var t1: u32 = undefined;

    while (r != 0) {
        t = s0 +% r;
        if (t <= ix0) {
  22f230:	31 f6                	xor    esi,esi
  22f232:	81 ff ff ff 1f 00    	cmp    edi,0x1fffff
  22f238:	40 0f 97 c6          	seta   sil
  22f23c:	41 89 f1             	mov    r9d,esi
  22f23f:	41 c1 e1 15          	shl    r9d,0x15
  22f243:	c1 e6 16             	shl    esi,0x16
            s0 = t + r;
            ix0 -= t;
            q += r;
        }
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  22f246:	8d 0c 3f             	lea    ecx,[rdi+rdi*1]
        if (t <= ix0) {
  22f249:	81 ff 00 00 20 00    	cmp    edi,0x200000
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  22f24f:	8d bc 3f 00 00 c0 ff 	lea    edi,[rdi+rdi*1-0x400000]
  22f256:	0f 42 f9             	cmovb  edi,ecx
  22f259:	b9 1e 01 00 00       	mov    ecx,0x11e
  22f25e:	c4 e2 70 f7 d0       	bextr  edx,eax,ecx
  22f263:	09 fa                	or     edx,edi
        t = s0 +% r;
  22f265:	8d be 00 00 10 00    	lea    edi,[rsi+0x100000]
        if (t <= ix0) {
  22f26b:	89 d1                	mov    ecx,edx
  22f26d:	29 f9                	sub    ecx,edi
  22f26f:	73 0d                	jae    22f27e <sqrt+0x10e>
  22f271:	89 d1                	mov    ecx,edx
  22f273:	eb 18                	jmp    22f28d <sqrt+0x11d>
  22f275:	c5 fb 10 05 eb 10 fd 	vmovsd xmm0,QWORD PTR [rip+0xfffffffffffd10eb]        # 200368 <__unnamed_609+0x28>
  22f27c:	ff 
        return x;
  22f27d:	c3                   	ret    
            s0 = t + r;
  22f27e:	81 c7 00 00 10 00    	add    edi,0x100000
            q += r;
  22f284:	41 81 c9 00 00 10 00 	or     r9d,0x100000
  22f28b:	89 fe                	mov    esi,edi
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  22f28d:	ba 1d 01 00 00       	mov    edx,0x11d
  22f292:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  22f297:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  22f29a:	8d be 00 00 08 00    	lea    edi,[rsi+0x80000]
        if (t <= ix0) {
  22f2a0:	89 d1                	mov    ecx,edx
  22f2a2:	29 f9                	sub    ecx,edi
  22f2a4:	73 04                	jae    22f2aa <sqrt+0x13a>
  22f2a6:	89 d1                	mov    ecx,edx
  22f2a8:	eb 0d                	jmp    22f2b7 <sqrt+0x147>
            s0 = t + r;
  22f2aa:	81 c6 00 00 10 00    	add    esi,0x100000
            q += r;
  22f2b0:	41 81 c1 00 00 08 00 	add    r9d,0x80000
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  22f2b7:	ba 1c 01 00 00       	mov    edx,0x11c
  22f2bc:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  22f2c1:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  22f2c4:	8d be 00 00 04 00    	lea    edi,[rsi+0x40000]
        if (t <= ix0) {
  22f2ca:	89 d1                	mov    ecx,edx
  22f2cc:	29 f9                	sub    ecx,edi
  22f2ce:	73 04                	jae    22f2d4 <sqrt+0x164>
  22f2d0:	89 d1                	mov    ecx,edx
  22f2d2:	eb 0d                	jmp    22f2e1 <sqrt+0x171>
            s0 = t + r;
  22f2d4:	81 c6 00 00 08 00    	add    esi,0x80000
            q += r;
  22f2da:	41 81 c1 00 00 04 00 	add    r9d,0x40000
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  22f2e1:	ba 1b 01 00 00       	mov    edx,0x11b
  22f2e6:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  22f2eb:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  22f2ee:	8d be 00 00 02 00    	lea    edi,[rsi+0x20000]
        if (t <= ix0) {
  22f2f4:	89 d1                	mov    ecx,edx
  22f2f6:	29 f9                	sub    ecx,edi
  22f2f8:	73 04                	jae    22f2fe <sqrt+0x18e>
  22f2fa:	89 d1                	mov    ecx,edx
  22f2fc:	eb 0d                	jmp    22f30b <sqrt+0x19b>
            s0 = t + r;
  22f2fe:	81 c6 00 00 04 00    	add    esi,0x40000
            q += r;
  22f304:	41 81 c1 00 00 02 00 	add    r9d,0x20000
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  22f30b:	ba 1a 01 00 00       	mov    edx,0x11a
  22f310:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  22f315:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  22f318:	8d be 00 00 01 00    	lea    edi,[rsi+0x10000]
        if (t <= ix0) {
  22f31e:	89 d1                	mov    ecx,edx
  22f320:	29 f9                	sub    ecx,edi
  22f322:	73 04                	jae    22f328 <sqrt+0x1b8>
  22f324:	89 d1                	mov    ecx,edx
  22f326:	eb 0d                	jmp    22f335 <sqrt+0x1c5>
            s0 = t + r;
  22f328:	81 c6 00 00 02 00    	add    esi,0x20000
            q += r;
  22f32e:	41 81 c1 00 00 01 00 	add    r9d,0x10000
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  22f335:	ba 19 01 00 00       	mov    edx,0x119
  22f33a:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  22f33f:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  22f342:	8d be 00 80 00 00    	lea    edi,[rsi+0x8000]
        if (t <= ix0) {
  22f348:	89 d1                	mov    ecx,edx
  22f34a:	29 f9                	sub    ecx,edi
  22f34c:	73 04                	jae    22f352 <sqrt+0x1e2>
  22f34e:	89 d1                	mov    ecx,edx
  22f350:	eb 0d                	jmp    22f35f <sqrt+0x1ef>
            s0 = t + r;
  22f352:	81 c6 00 00 01 00    	add    esi,0x10000
            q += r;
  22f358:	41 81 c1 00 80 00 00 	add    r9d,0x8000
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  22f35f:	ba 18 01 00 00       	mov    edx,0x118
  22f364:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  22f369:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  22f36c:	8d be 00 40 00 00    	lea    edi,[rsi+0x4000]
        if (t <= ix0) {
  22f372:	89 d1                	mov    ecx,edx
  22f374:	29 f9                	sub    ecx,edi
  22f376:	73 04                	jae    22f37c <sqrt+0x20c>
  22f378:	89 d1                	mov    ecx,edx
  22f37a:	eb 0d                	jmp    22f389 <sqrt+0x219>
            s0 = t + r;
  22f37c:	81 c6 00 80 00 00    	add    esi,0x8000
            q += r;
  22f382:	41 81 c1 00 40 00 00 	add    r9d,0x4000
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  22f389:	ba 17 01 00 00       	mov    edx,0x117
  22f38e:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  22f393:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  22f396:	8d be 00 20 00 00    	lea    edi,[rsi+0x2000]
        if (t <= ix0) {
  22f39c:	89 d1                	mov    ecx,edx
  22f39e:	29 f9                	sub    ecx,edi
  22f3a0:	73 04                	jae    22f3a6 <sqrt+0x236>
  22f3a2:	89 d1                	mov    ecx,edx
  22f3a4:	eb 0d                	jmp    22f3b3 <sqrt+0x243>
            s0 = t + r;
  22f3a6:	81 c6 00 40 00 00    	add    esi,0x4000
            q += r;
  22f3ac:	41 81 c1 00 20 00 00 	add    r9d,0x2000
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  22f3b3:	ba 16 01 00 00       	mov    edx,0x116
  22f3b8:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  22f3bd:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  22f3c0:	8d be 00 10 00 00    	lea    edi,[rsi+0x1000]
        if (t <= ix0) {
  22f3c6:	89 d1                	mov    ecx,edx
  22f3c8:	29 f9                	sub    ecx,edi
  22f3ca:	73 04                	jae    22f3d0 <sqrt+0x260>
  22f3cc:	89 d1                	mov    ecx,edx
  22f3ce:	eb 0d                	jmp    22f3dd <sqrt+0x26d>
            s0 = t + r;
  22f3d0:	81 c6 00 20 00 00    	add    esi,0x2000
            q += r;
  22f3d6:	41 81 c1 00 10 00 00 	add    r9d,0x1000
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  22f3dd:	ba 15 01 00 00       	mov    edx,0x115
  22f3e2:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  22f3e7:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  22f3ea:	8d be 00 08 00 00    	lea    edi,[rsi+0x800]
        if (t <= ix0) {
  22f3f0:	89 d1                	mov    ecx,edx
  22f3f2:	29 f9                	sub    ecx,edi
  22f3f4:	73 04                	jae    22f3fa <sqrt+0x28a>
  22f3f6:	89 d1                	mov    ecx,edx
  22f3f8:	eb 0d                	jmp    22f407 <sqrt+0x297>
            s0 = t + r;
  22f3fa:	81 c6 00 10 00 00    	add    esi,0x1000
            q += r;
  22f400:	41 81 c1 00 08 00 00 	add    r9d,0x800
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  22f407:	ba 14 01 00 00       	mov    edx,0x114
  22f40c:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  22f411:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  22f414:	8d be 00 04 00 00    	lea    edi,[rsi+0x400]
        if (t <= ix0) {
  22f41a:	89 d1                	mov    ecx,edx
  22f41c:	29 f9                	sub    ecx,edi
  22f41e:	73 04                	jae    22f424 <sqrt+0x2b4>
  22f420:	89 d1                	mov    ecx,edx
  22f422:	eb 0d                	jmp    22f431 <sqrt+0x2c1>
            s0 = t + r;
  22f424:	81 c6 00 08 00 00    	add    esi,0x800
            q += r;
  22f42a:	41 81 c1 00 04 00 00 	add    r9d,0x400
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  22f431:	ba 13 01 00 00       	mov    edx,0x113
  22f436:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  22f43b:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  22f43e:	8d be 00 02 00 00    	lea    edi,[rsi+0x200]
        if (t <= ix0) {
  22f444:	89 d1                	mov    ecx,edx
  22f446:	29 f9                	sub    ecx,edi
  22f448:	73 04                	jae    22f44e <sqrt+0x2de>
  22f44a:	89 d1                	mov    ecx,edx
  22f44c:	eb 0d                	jmp    22f45b <sqrt+0x2eb>
            s0 = t + r;
  22f44e:	81 c6 00 04 00 00    	add    esi,0x400
            q += r;
  22f454:	41 81 c1 00 02 00 00 	add    r9d,0x200
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  22f45b:	ba 12 01 00 00       	mov    edx,0x112
  22f460:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  22f465:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  22f468:	8d be 00 01 00 00    	lea    edi,[rsi+0x100]
        if (t <= ix0) {
  22f46e:	89 d1                	mov    ecx,edx
  22f470:	29 f9                	sub    ecx,edi
  22f472:	73 04                	jae    22f478 <sqrt+0x308>
  22f474:	89 d1                	mov    ecx,edx
  22f476:	eb 0d                	jmp    22f485 <sqrt+0x315>
            s0 = t + r;
  22f478:	81 c6 00 02 00 00    	add    esi,0x200
            q += r;
  22f47e:	41 81 c1 00 01 00 00 	add    r9d,0x100
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  22f485:	ba 11 01 00 00       	mov    edx,0x111
  22f48a:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  22f48f:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  22f492:	89 f7                	mov    edi,esi
  22f494:	83 ef 80             	sub    edi,0xffffff80
        if (t <= ix0) {
  22f497:	89 d1                	mov    ecx,edx
  22f499:	29 f9                	sub    ecx,edi
  22f49b:	73 04                	jae    22f4a1 <sqrt+0x331>
  22f49d:	89 d1                	mov    ecx,edx
  22f49f:	eb 0a                	jmp    22f4ab <sqrt+0x33b>
            s0 = t + r;
  22f4a1:	81 c6 00 01 00 00    	add    esi,0x100
            q += r;
  22f4a7:	41 83 e9 80          	sub    r9d,0xffffff80
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  22f4ab:	ba 10 01 00 00       	mov    edx,0x110
  22f4b0:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  22f4b5:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  22f4b8:	8d 7e 40             	lea    edi,[rsi+0x40]
        if (t <= ix0) {
  22f4bb:	89 d1                	mov    ecx,edx
  22f4bd:	29 f9                	sub    ecx,edi
  22f4bf:	73 04                	jae    22f4c5 <sqrt+0x355>
  22f4c1:	89 d1                	mov    ecx,edx
  22f4c3:	eb 07                	jmp    22f4cc <sqrt+0x35c>
            s0 = t + r;
  22f4c5:	83 ee 80             	sub    esi,0xffffff80
            q += r;
  22f4c8:	41 83 c1 40          	add    r9d,0x40
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  22f4cc:	ba 0f 01 00 00       	mov    edx,0x10f
  22f4d1:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  22f4d6:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  22f4d9:	8d 7e 20             	lea    edi,[rsi+0x20]
        if (t <= ix0) {
  22f4dc:	89 d1                	mov    ecx,edx
  22f4de:	29 f9                	sub    ecx,edi
  22f4e0:	73 04                	jae    22f4e6 <sqrt+0x376>
  22f4e2:	89 d1                	mov    ecx,edx
  22f4e4:	eb 07                	jmp    22f4ed <sqrt+0x37d>
            s0 = t + r;
  22f4e6:	83 c6 40             	add    esi,0x40
            q += r;
  22f4e9:	41 83 c1 20          	add    r9d,0x20
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  22f4ed:	ba 0e 01 00 00       	mov    edx,0x10e
  22f4f2:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  22f4f7:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  22f4fa:	8d 7e 10             	lea    edi,[rsi+0x10]
        if (t <= ix0) {
  22f4fd:	89 d1                	mov    ecx,edx
  22f4ff:	29 f9                	sub    ecx,edi
  22f501:	73 04                	jae    22f507 <sqrt+0x397>
  22f503:	89 d1                	mov    ecx,edx
  22f505:	eb 07                	jmp    22f50e <sqrt+0x39e>
            s0 = t + r;
  22f507:	83 c6 20             	add    esi,0x20
            q += r;
  22f50a:	41 83 c1 10          	add    r9d,0x10
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  22f50e:	ba 0d 01 00 00       	mov    edx,0x10d
  22f513:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  22f518:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  22f51b:	8d 7e 08             	lea    edi,[rsi+0x8]
        if (t <= ix0) {
  22f51e:	89 d1                	mov    ecx,edx
  22f520:	29 f9                	sub    ecx,edi
  22f522:	73 04                	jae    22f528 <sqrt+0x3b8>
  22f524:	89 d1                	mov    ecx,edx
  22f526:	eb 07                	jmp    22f52f <sqrt+0x3bf>
            s0 = t + r;
  22f528:	83 c6 10             	add    esi,0x10
            q += r;
  22f52b:	41 83 c1 08          	add    r9d,0x8
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  22f52f:	ba 0c 01 00 00       	mov    edx,0x10c
  22f534:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  22f539:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  22f53c:	8d 7e 04             	lea    edi,[rsi+0x4]
        if (t <= ix0) {
  22f53f:	89 d1                	mov    ecx,edx
  22f541:	29 f9                	sub    ecx,edi
  22f543:	73 04                	jae    22f549 <sqrt+0x3d9>
  22f545:	89 d1                	mov    ecx,edx
  22f547:	eb 07                	jmp    22f550 <sqrt+0x3e0>
            s0 = t + r;
  22f549:	83 c6 08             	add    esi,0x8
            q += r;
  22f54c:	41 83 c1 04          	add    r9d,0x4
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  22f550:	ba 0b 01 00 00       	mov    edx,0x10b
  22f555:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  22f55a:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  22f55d:	8d 7e 02             	lea    edi,[rsi+0x2]
        if (t <= ix0) {
  22f560:	89 d1                	mov    ecx,edx
  22f562:	29 f9                	sub    ecx,edi
  22f564:	73 04                	jae    22f56a <sqrt+0x3fa>
  22f566:	89 d1                	mov    ecx,edx
  22f568:	eb 07                	jmp    22f571 <sqrt+0x401>
            s0 = t + r;
  22f56a:	83 c6 04             	add    esi,0x4
            q += r;
  22f56d:	41 83 c1 02          	add    r9d,0x2
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  22f571:	ba 0a 01 00 00       	mov    edx,0x10a
  22f576:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  22f57b:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  22f57e:	8d 7e 01             	lea    edi,[rsi+0x1]
        if (t <= ix0) {
  22f581:	89 d1                	mov    ecx,edx
  22f583:	29 f9                	sub    ecx,edi
  22f585:	73 04                	jae    22f58b <sqrt+0x41b>
  22f587:	89 d1                	mov    ecx,edx
  22f589:	eb 07                	jmp    22f592 <sqrt+0x422>
            s0 = t + r;
  22f58b:	83 c6 02             	add    esi,0x2
            q += r;
  22f58e:	41 83 c1 01          	add    r9d,0x1
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  22f592:	55                   	push   rbp
  22f593:	41 56                	push   r14
  22f595:	53                   	push   rbx
  22f596:	ba 09 01 00 00       	mov    edx,0x109
  22f59b:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  22f5a0:	c1 e0 17             	shl    eax,0x17
  22f5a3:	8d 1c 4a             	lea    ebx,[rdx+rcx*2]
    m >>= 1;
  22f5a6:	41 d1 e8             	shr    r8d,1
  22f5a9:	31 d2                	xor    edx,edx
  22f5ab:	bf 00 00 00 80       	mov    edi,0x80000000
  22f5b0:	41 ba 1e 01 00 00    	mov    r10d,0x11e
  22f5b6:	41 bb 1d 01 00 00    	mov    r11d,0x11d
  22f5bc:	41 be 1c 01 00 00    	mov    r14d,0x11c
  22f5c2:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  22f5c9:	1f 84 00 00 00 00 00 

    r = sign;
    while (r != 0) {
        t = s1 +% r;
        t = s0;
        if (t < ix0 or (t == ix0 and t1 <= ix1)) {
  22f5d0:	89 fd                	mov    ebp,edi
  22f5d2:	89 f1                	mov    ecx,esi
  22f5d4:	39 f3                	cmp    ebx,esi
  22f5d6:	73 04                	jae    22f5dc <sqrt+0x46c>
  22f5d8:	31 ed                	xor    ebp,ebp
  22f5da:	31 c9                	xor    ecx,ecx
  22f5dc:	01 d5                	add    ebp,edx
  22f5de:	29 cb                	sub    ebx,ecx
                ix0 -= 1;
            }
            ix1 = ix1 -% t1;
            q1 += r;
        }
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  22f5e0:	0f a4 c3 01          	shld   ebx,eax,0x1
        if (t < ix0 or (t == ix0 and t1 <= ix1)) {
  22f5e4:	39 f3                	cmp    ebx,esi
  22f5e6:	73 08                	jae    22f5f0 <sqrt+0x480>
  22f5e8:	31 d2                	xor    edx,edx
  22f5ea:	31 c9                	xor    ecx,ecx
  22f5ec:	eb 08                	jmp    22f5f6 <sqrt+0x486>
  22f5ee:	66 90                	xchg   ax,ax
  22f5f0:	89 fa                	mov    edx,edi
  22f5f2:	d1 ea                	shr    edx,1
  22f5f4:	89 f1                	mov    ecx,esi
  22f5f6:	01 ea                	add    edx,ebp
  22f5f8:	29 cb                	sub    ebx,ecx
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  22f5fa:	c4 e2 28 f7 c8       	bextr  ecx,eax,r10d
  22f5ff:	8d 2c 59             	lea    ebp,[rcx+rbx*2]
        if (t < ix0 or (t == ix0 and t1 <= ix1)) {
  22f602:	39 f5                	cmp    ebp,esi
  22f604:	73 0a                	jae    22f610 <sqrt+0x4a0>
  22f606:	31 db                	xor    ebx,ebx
  22f608:	31 c9                	xor    ecx,ecx
  22f60a:	eb 0b                	jmp    22f617 <sqrt+0x4a7>
  22f60c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  22f610:	89 fb                	mov    ebx,edi
  22f612:	c1 eb 02             	shr    ebx,0x2
  22f615:	89 f1                	mov    ecx,esi
  22f617:	01 d3                	add    ebx,edx
  22f619:	29 cd                	sub    ebp,ecx
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  22f61b:	c4 e2 20 f7 c8       	bextr  ecx,eax,r11d
  22f620:	8d 2c 69             	lea    ebp,[rcx+rbp*2]
        if (t < ix0 or (t == ix0 and t1 <= ix1)) {
  22f623:	39 f5                	cmp    ebp,esi
  22f625:	73 09                	jae    22f630 <sqrt+0x4c0>
  22f627:	31 d2                	xor    edx,edx
  22f629:	31 c9                	xor    ecx,ecx
  22f62b:	eb 0a                	jmp    22f637 <sqrt+0x4c7>
  22f62d:	0f 1f 00             	nop    DWORD PTR [rax]
  22f630:	89 fa                	mov    edx,edi
  22f632:	c1 ea 03             	shr    edx,0x3
  22f635:	89 f1                	mov    ecx,esi
  22f637:	01 da                	add    edx,ebx
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  22f639:	c4 e2 08 f7 d8       	bextr  ebx,eax,r14d
        if (t < ix0 or (t == ix0 and t1 <= ix1)) {
  22f63e:	29 cd                	sub    ebp,ecx
  22f640:	c1 e0 04             	shl    eax,0x4
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  22f643:	8d 1c 6b             	lea    ebx,[rbx+rbp*2]
        ix1 = ix1 +% ix1;
        r >>= 1;
  22f646:	c1 ef 04             	shr    edi,0x4
    while (r != 0) {
  22f649:	75 85                	jne    22f5d0 <sqrt+0x460>
    }

    // rounding direction
    if (ix0 | ix1 != 0) {
  22f64b:	09 c3                	or     ebx,eax
  22f64d:	5b                   	pop    rbx
  22f64e:	41 5e                	pop    r14
  22f650:	5d                   	pop    rbp
  22f651:	74 16                	je     22f669 <sqrt+0x4f9>
        var z = 1.0 - tiny; // raise inexact
        if (z >= 1.0) {
            z = 1.0 + tiny;
            if (q1 == 0xFFFFFFFF) {
  22f653:	83 fa ff             	cmp    edx,0xffffffff
  22f656:	74 0b                	je     22f663 <sqrt+0x4f3>
                if (q1 == 0xFFFFFFFE) {
                    q += 1;
                }
                q1 += 2;
            } else {
                q1 += q1 & 1;
  22f658:	89 d0                	mov    eax,edx
  22f65a:	83 e0 01             	and    eax,0x1
  22f65d:	01 d0                	add    eax,edx
  22f65f:	89 c2                	mov    edx,eax
  22f661:	eb 06                	jmp    22f669 <sqrt+0x4f9>
                q += 1;
  22f663:	41 83 c1 01          	add    r9d,0x1
  22f667:	31 d2                	xor    edx,edx
            }
        }
    }

    ix0 = (q >> 1) + 0x3FE00000;
  22f669:	44 89 c8             	mov    eax,r9d
  22f66c:	d1 e8                	shr    eax,1
    ix1 = q1 >> 1;
    if (q & 1 != 0) {
  22f66e:	44 0f ac ca 01       	shrd   edx,r9d,0x1
    }

    // NOTE: musl here appears to rely on signed twos-complement wraparound. +% has the same
    // behaviour at least.
    var iix0 = @intCast(i32, ix0);
    iix0 = iix0 +% (m << 20);
  22f673:	41 c1 e0 14          	shl    r8d,0x14
  22f677:	41 8d 04 00          	lea    eax,[r8+rax*1]
  22f67b:	05 00 00 e0 3f       	add    eax,0x3fe00000

    const uz = (@intCast(u64, iix0) << 32) | ix1;
  22f680:	48 c1 e0 20          	shl    rax,0x20
  22f684:	48 09 c2             	or     rdx,rax
    return @bitCast(f64, uz);
  22f687:	c4 e1 f9 6e c2       	vmovq  xmm0,rdx
  22f68c:	c3                   	ret    
  22f68d:	0f 1f 00             	nop    DWORD PTR [rax]

000000000022f690 <sqrtf>:
}

export fn sqrtf(x: f32) f32 {
    const tiny: f32 = 1.0e-30;
    const sign: i32 = @bitCast(i32, u32(0x80000000));
    var ix: i32 = @bitCast(i32, x);
  22f690:	c5 f9 7e c1          	vmovd  ecx,xmm0

    if ((ix & 0x7F800000) == 0x7F800000) {
  22f694:	b8 00 00 80 7f       	mov    eax,0x7f800000
  22f699:	c4 e2 70 f2 c0       	andn   eax,ecx,eax
  22f69e:	75 09                	jne    22f6a9 <sqrtf+0x19>
        return x * x + x; // sqrt(nan) = nan, sqrt(+inf) = +inf, sqrt(-inf) = snan
  22f6a0:	c5 fa 59 c8          	vmulss xmm1,xmm0,xmm0
  22f6a4:	c5 f2 58 c0          	vaddss xmm0,xmm1,xmm0
  22f6a8:	c3                   	ret    
    }

    // zero
    if (ix <= 0) {
  22f6a9:	85 c9                	test   ecx,ecx
  22f6ab:	7e 15                	jle    22f6c2 <sqrtf+0x32>
  22f6ad:	41 89 c8             	mov    r8d,ecx
  22f6b0:	41 c1 e8 17          	shr    r8d,0x17
        }
    }

    // normalize
    var m = ix >> 23;
    if (m == 0) {
  22f6b4:	75 45                	jne    22f6fb <sqrtf+0x6b>
  22f6b6:	31 d2                	xor    edx,edx
        // subnormal
        var i: i32 = 0;
        while (ix & 0x00800000 == 0) : (i += 1) {
  22f6b8:	0f ba e1 17          	bt     ecx,0x17
  22f6bc:	73 18                	jae    22f6d6 <sqrtf+0x46>
  22f6be:	89 ce                	mov    esi,ecx
  22f6c0:	eb 2e                	jmp    22f6f0 <sqrtf+0x60>
        if (ix & ~sign == 0) {
  22f6c2:	f7 c1 ff ff ff 7f    	test   ecx,0x7fffffff
  22f6c8:	0f 84 26 03 00 00    	je     22f9f4 <sqrtf+0x364>
        if (ix < 0) {
  22f6ce:	85 c9                	test   ecx,ecx
  22f6d0:	0f 88 16 03 00 00    	js     22f9ec <sqrtf+0x35c>
  22f6d6:	31 d2                	xor    edx,edx
  22f6d8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  22f6df:	00 
            ix <<= 1;
  22f6e0:	8d 34 09             	lea    esi,[rcx+rcx*1]
        while (ix & 0x00800000 == 0) : (i += 1) {
  22f6e3:	83 c2 01             	add    edx,0x1
  22f6e6:	f7 c1 00 00 40 00    	test   ecx,0x400000
  22f6ec:	89 f1                	mov    ecx,esi
  22f6ee:	74 f0                	je     22f6e0 <sqrtf+0x50>
        }
        m -= i - 1;
  22f6f0:	41 b8 01 00 00 00    	mov    r8d,0x1
  22f6f6:	41 29 d0             	sub    r8d,edx
  22f6f9:	89 f1                	mov    ecx,esi
    }

    m -= 127; // unbias exponent
  22f6fb:	41 83 c0 81          	add    r8d,0xffffff81
    ix = (ix & 0x007FFFFF) | 0x00800000;
  22f6ff:	81 e1 ff ff 7f 00    	and    ecx,0x7fffff
  22f705:	81 c9 00 00 80 00    	or     ecx,0x800000

    if (m & 1 != 0) { // odd m, double x to even
  22f70b:	44 89 c0             	mov    eax,r8d
  22f70e:	24 01                	and    al,0x1
  22f710:	c4 e2 79 f7 c1       	shlx   eax,ecx,eax
  22f715:	8d 34 85 00 00 00 00 	lea    esi,[rax*4+0x0]
    var s: i32 = 0;
    var r: i32 = 0x01000000; // r = moving bit right -> left

    while (r != 0) {
        const t = s + r;
        if (t <= ix) {
  22f71c:	31 d2                	xor    edx,edx
  22f71e:	3d ff ff 7f 00       	cmp    eax,0x7fffff
  22f723:	0f 9f c2             	setg   dl
  22f726:	89 d1                	mov    ecx,edx
  22f728:	c1 e1 18             	shl    ecx,0x18
  22f72b:	c1 e2 19             	shl    edx,0x19
  22f72e:	3d 00 00 80 00       	cmp    eax,0x800000
  22f733:	8d 3c 85 00 00 00 fe 	lea    edi,[rax*4-0x2000000]
  22f73a:	0f 4c fe             	cmovl  edi,esi
        const t = s + r;
  22f73d:	8d 82 00 00 80 00    	lea    eax,[rdx+0x800000]
        if (t <= ix) {
  22f743:	89 fe                	mov    esi,edi
  22f745:	29 c6                	sub    esi,eax
  22f747:	7d 04                	jge    22f74d <sqrtf+0xbd>
  22f749:	89 fe                	mov    esi,edi
  22f74b:	eb 0d                	jmp    22f75a <sqrtf+0xca>
            s = t + r;
  22f74d:	05 00 00 80 00       	add    eax,0x800000
            ix -= t;
            q += r;
  22f752:	81 c9 00 00 80 00    	or     ecx,0x800000
  22f758:	89 c2                	mov    edx,eax
  22f75a:	01 f6                	add    esi,esi
        const t = s + r;
  22f75c:	8d 82 00 00 40 00    	lea    eax,[rdx+0x400000]
        if (t <= ix) {
  22f762:	89 f7                	mov    edi,esi
  22f764:	29 c7                	sub    edi,eax
  22f766:	7d 04                	jge    22f76c <sqrtf+0xdc>
  22f768:	89 f7                	mov    edi,esi
  22f76a:	eb 0c                	jmp    22f778 <sqrtf+0xe8>
            s = t + r;
  22f76c:	81 c2 00 00 80 00    	add    edx,0x800000
            q += r;
  22f772:	81 c1 00 00 40 00    	add    ecx,0x400000
  22f778:	01 ff                	add    edi,edi
        const t = s + r;
  22f77a:	8d 82 00 00 20 00    	lea    eax,[rdx+0x200000]
        if (t <= ix) {
  22f780:	89 fe                	mov    esi,edi
  22f782:	29 c6                	sub    esi,eax
  22f784:	7d 04                	jge    22f78a <sqrtf+0xfa>
  22f786:	89 fe                	mov    esi,edi
  22f788:	eb 0c                	jmp    22f796 <sqrtf+0x106>
            s = t + r;
  22f78a:	81 c2 00 00 40 00    	add    edx,0x400000
            q += r;
  22f790:	81 c1 00 00 20 00    	add    ecx,0x200000
  22f796:	01 f6                	add    esi,esi
        const t = s + r;
  22f798:	8d 82 00 00 10 00    	lea    eax,[rdx+0x100000]
        if (t <= ix) {
  22f79e:	89 f7                	mov    edi,esi
  22f7a0:	29 c7                	sub    edi,eax
  22f7a2:	7d 04                	jge    22f7a8 <sqrtf+0x118>
  22f7a4:	89 f7                	mov    edi,esi
  22f7a6:	eb 0c                	jmp    22f7b4 <sqrtf+0x124>
            s = t + r;
  22f7a8:	81 c2 00 00 20 00    	add    edx,0x200000
            q += r;
  22f7ae:	81 c1 00 00 10 00    	add    ecx,0x100000
  22f7b4:	01 ff                	add    edi,edi
        const t = s + r;
  22f7b6:	8d 82 00 00 08 00    	lea    eax,[rdx+0x80000]
        if (t <= ix) {
  22f7bc:	89 fe                	mov    esi,edi
  22f7be:	29 c6                	sub    esi,eax
  22f7c0:	7d 04                	jge    22f7c6 <sqrtf+0x136>
  22f7c2:	89 fe                	mov    esi,edi
  22f7c4:	eb 0c                	jmp    22f7d2 <sqrtf+0x142>
            s = t + r;
  22f7c6:	81 c2 00 00 10 00    	add    edx,0x100000
            q += r;
  22f7cc:	81 c1 00 00 08 00    	add    ecx,0x80000
  22f7d2:	01 f6                	add    esi,esi
        const t = s + r;
  22f7d4:	8d 82 00 00 04 00    	lea    eax,[rdx+0x40000]
        if (t <= ix) {
  22f7da:	89 f7                	mov    edi,esi
  22f7dc:	29 c7                	sub    edi,eax
  22f7de:	7d 04                	jge    22f7e4 <sqrtf+0x154>
  22f7e0:	89 f7                	mov    edi,esi
  22f7e2:	eb 0c                	jmp    22f7f0 <sqrtf+0x160>
            s = t + r;
  22f7e4:	81 c2 00 00 08 00    	add    edx,0x80000
            q += r;
  22f7ea:	81 c1 00 00 04 00    	add    ecx,0x40000
  22f7f0:	01 ff                	add    edi,edi
        const t = s + r;
  22f7f2:	8d 82 00 00 02 00    	lea    eax,[rdx+0x20000]
        if (t <= ix) {
  22f7f8:	89 fe                	mov    esi,edi
  22f7fa:	29 c6                	sub    esi,eax
  22f7fc:	7d 04                	jge    22f802 <sqrtf+0x172>
  22f7fe:	89 fe                	mov    esi,edi
  22f800:	eb 0c                	jmp    22f80e <sqrtf+0x17e>
            s = t + r;
  22f802:	81 c2 00 00 04 00    	add    edx,0x40000
            q += r;
  22f808:	81 c1 00 00 02 00    	add    ecx,0x20000
  22f80e:	01 f6                	add    esi,esi
        const t = s + r;
  22f810:	8d 82 00 00 01 00    	lea    eax,[rdx+0x10000]
        if (t <= ix) {
  22f816:	89 f7                	mov    edi,esi
  22f818:	29 c7                	sub    edi,eax
  22f81a:	7d 04                	jge    22f820 <sqrtf+0x190>
  22f81c:	89 f7                	mov    edi,esi
  22f81e:	eb 0c                	jmp    22f82c <sqrtf+0x19c>
            s = t + r;
  22f820:	81 c2 00 00 02 00    	add    edx,0x20000
            q += r;
  22f826:	81 c1 00 00 01 00    	add    ecx,0x10000
  22f82c:	01 ff                	add    edi,edi
        const t = s + r;
  22f82e:	8d 82 00 80 00 00    	lea    eax,[rdx+0x8000]
        if (t <= ix) {
  22f834:	89 fe                	mov    esi,edi
  22f836:	29 c6                	sub    esi,eax
  22f838:	7d 04                	jge    22f83e <sqrtf+0x1ae>
  22f83a:	89 fe                	mov    esi,edi
  22f83c:	eb 0c                	jmp    22f84a <sqrtf+0x1ba>
            s = t + r;
  22f83e:	81 c2 00 00 01 00    	add    edx,0x10000
            q += r;
  22f844:	81 c1 00 80 00 00    	add    ecx,0x8000
  22f84a:	01 f6                	add    esi,esi
        const t = s + r;
  22f84c:	8d 82 00 40 00 00    	lea    eax,[rdx+0x4000]
        if (t <= ix) {
  22f852:	89 f7                	mov    edi,esi
  22f854:	29 c7                	sub    edi,eax
  22f856:	7d 04                	jge    22f85c <sqrtf+0x1cc>
  22f858:	89 f7                	mov    edi,esi
  22f85a:	eb 0c                	jmp    22f868 <sqrtf+0x1d8>
            s = t + r;
  22f85c:	81 c2 00 80 00 00    	add    edx,0x8000
            q += r;
  22f862:	81 c1 00 40 00 00    	add    ecx,0x4000
  22f868:	01 ff                	add    edi,edi
        const t = s + r;
  22f86a:	8d 82 00 20 00 00    	lea    eax,[rdx+0x2000]
        if (t <= ix) {
  22f870:	89 fe                	mov    esi,edi
  22f872:	29 c6                	sub    esi,eax
  22f874:	7d 04                	jge    22f87a <sqrtf+0x1ea>
  22f876:	89 fe                	mov    esi,edi
  22f878:	eb 0c                	jmp    22f886 <sqrtf+0x1f6>
            s = t + r;
  22f87a:	81 c2 00 40 00 00    	add    edx,0x4000
            q += r;
  22f880:	81 c1 00 20 00 00    	add    ecx,0x2000
  22f886:	01 f6                	add    esi,esi
        const t = s + r;
  22f888:	8d 82 00 10 00 00    	lea    eax,[rdx+0x1000]
        if (t <= ix) {
  22f88e:	89 f7                	mov    edi,esi
  22f890:	29 c7                	sub    edi,eax
  22f892:	7d 04                	jge    22f898 <sqrtf+0x208>
  22f894:	89 f7                	mov    edi,esi
  22f896:	eb 0c                	jmp    22f8a4 <sqrtf+0x214>
            s = t + r;
  22f898:	81 c2 00 20 00 00    	add    edx,0x2000
            q += r;
  22f89e:	81 c1 00 10 00 00    	add    ecx,0x1000
  22f8a4:	01 ff                	add    edi,edi
        const t = s + r;
  22f8a6:	8d 82 00 08 00 00    	lea    eax,[rdx+0x800]
        if (t <= ix) {
  22f8ac:	89 fe                	mov    esi,edi
  22f8ae:	29 c6                	sub    esi,eax
  22f8b0:	7d 04                	jge    22f8b6 <sqrtf+0x226>
  22f8b2:	89 fe                	mov    esi,edi
  22f8b4:	eb 0c                	jmp    22f8c2 <sqrtf+0x232>
            s = t + r;
  22f8b6:	81 c2 00 10 00 00    	add    edx,0x1000
            q += r;
  22f8bc:	81 c1 00 08 00 00    	add    ecx,0x800
  22f8c2:	01 f6                	add    esi,esi
        const t = s + r;
  22f8c4:	8d 82 00 04 00 00    	lea    eax,[rdx+0x400]
        if (t <= ix) {
  22f8ca:	89 f7                	mov    edi,esi
  22f8cc:	29 c7                	sub    edi,eax
  22f8ce:	7d 04                	jge    22f8d4 <sqrtf+0x244>
  22f8d0:	89 f7                	mov    edi,esi
  22f8d2:	eb 0c                	jmp    22f8e0 <sqrtf+0x250>
            s = t + r;
  22f8d4:	81 c2 00 08 00 00    	add    edx,0x800
            q += r;
  22f8da:	81 c1 00 04 00 00    	add    ecx,0x400
  22f8e0:	01 ff                	add    edi,edi
        const t = s + r;
  22f8e2:	8d 82 00 02 00 00    	lea    eax,[rdx+0x200]
        if (t <= ix) {
  22f8e8:	89 fe                	mov    esi,edi
  22f8ea:	29 c6                	sub    esi,eax
  22f8ec:	7d 04                	jge    22f8f2 <sqrtf+0x262>
  22f8ee:	89 fe                	mov    esi,edi
  22f8f0:	eb 0c                	jmp    22f8fe <sqrtf+0x26e>
            s = t + r;
  22f8f2:	81 c2 00 04 00 00    	add    edx,0x400
            q += r;
  22f8f8:	81 c1 00 02 00 00    	add    ecx,0x200
  22f8fe:	01 f6                	add    esi,esi
        const t = s + r;
  22f900:	8d 82 00 01 00 00    	lea    eax,[rdx+0x100]
        if (t <= ix) {
  22f906:	89 f7                	mov    edi,esi
  22f908:	29 c7                	sub    edi,eax
  22f90a:	7d 04                	jge    22f910 <sqrtf+0x280>
  22f90c:	89 f7                	mov    edi,esi
  22f90e:	eb 0c                	jmp    22f91c <sqrtf+0x28c>
            s = t + r;
  22f910:	81 c2 00 02 00 00    	add    edx,0x200
            q += r;
  22f916:	81 c1 00 01 00 00    	add    ecx,0x100
  22f91c:	01 ff                	add    edi,edi
        const t = s + r;
  22f91e:	89 d0                	mov    eax,edx
  22f920:	83 e8 80             	sub    eax,0xffffff80
        if (t <= ix) {
  22f923:	89 fe                	mov    esi,edi
  22f925:	29 c6                	sub    esi,eax
  22f927:	7d 04                	jge    22f92d <sqrtf+0x29d>
  22f929:	89 fe                	mov    esi,edi
  22f92b:	eb 09                	jmp    22f936 <sqrtf+0x2a6>
            s = t + r;
  22f92d:	81 c2 00 01 00 00    	add    edx,0x100
            q += r;
  22f933:	83 e9 80             	sub    ecx,0xffffff80
  22f936:	01 f6                	add    esi,esi
        const t = s + r;
  22f938:	8d 42 40             	lea    eax,[rdx+0x40]
        if (t <= ix) {
  22f93b:	89 f7                	mov    edi,esi
  22f93d:	29 c7                	sub    edi,eax
  22f93f:	7d 04                	jge    22f945 <sqrtf+0x2b5>
  22f941:	89 f7                	mov    edi,esi
  22f943:	eb 06                	jmp    22f94b <sqrtf+0x2bb>
            s = t + r;
  22f945:	83 ea 80             	sub    edx,0xffffff80
            q += r;
  22f948:	83 c1 40             	add    ecx,0x40
  22f94b:	01 ff                	add    edi,edi
        const t = s + r;
  22f94d:	8d 42 20             	lea    eax,[rdx+0x20]
        if (t <= ix) {
  22f950:	89 fe                	mov    esi,edi
  22f952:	29 c6                	sub    esi,eax
  22f954:	7d 04                	jge    22f95a <sqrtf+0x2ca>
  22f956:	89 fe                	mov    esi,edi
  22f958:	eb 06                	jmp    22f960 <sqrtf+0x2d0>
            s = t + r;
  22f95a:	83 c2 40             	add    edx,0x40
            q += r;
  22f95d:	83 c1 20             	add    ecx,0x20
  22f960:	01 f6                	add    esi,esi
        const t = s + r;
  22f962:	8d 42 10             	lea    eax,[rdx+0x10]
        if (t <= ix) {
  22f965:	89 f7                	mov    edi,esi
  22f967:	29 c7                	sub    edi,eax
  22f969:	7d 04                	jge    22f96f <sqrtf+0x2df>
  22f96b:	89 f7                	mov    edi,esi
  22f96d:	eb 06                	jmp    22f975 <sqrtf+0x2e5>
            s = t + r;
  22f96f:	83 c2 20             	add    edx,0x20
            q += r;
  22f972:	83 c1 10             	add    ecx,0x10
  22f975:	01 ff                	add    edi,edi
        const t = s + r;
  22f977:	8d 42 08             	lea    eax,[rdx+0x8]
        if (t <= ix) {
  22f97a:	89 fe                	mov    esi,edi
  22f97c:	29 c6                	sub    esi,eax
  22f97e:	7d 04                	jge    22f984 <sqrtf+0x2f4>
  22f980:	89 fe                	mov    esi,edi
  22f982:	eb 06                	jmp    22f98a <sqrtf+0x2fa>
            s = t + r;
  22f984:	83 c2 10             	add    edx,0x10
            q += r;
  22f987:	83 c1 08             	add    ecx,0x8
  22f98a:	01 f6                	add    esi,esi
        const t = s + r;
  22f98c:	8d 42 04             	lea    eax,[rdx+0x4]
        if (t <= ix) {
  22f98f:	89 f7                	mov    edi,esi
  22f991:	29 c7                	sub    edi,eax
  22f993:	7d 04                	jge    22f999 <sqrtf+0x309>
  22f995:	89 f7                	mov    edi,esi
  22f997:	eb 06                	jmp    22f99f <sqrtf+0x30f>
            s = t + r;
  22f999:	83 c2 08             	add    edx,0x8
            q += r;
  22f99c:	83 c1 04             	add    ecx,0x4
  22f99f:	01 ff                	add    edi,edi
        const t = s + r;
  22f9a1:	8d 42 02             	lea    eax,[rdx+0x2]
        if (t <= ix) {
  22f9a4:	89 fe                	mov    esi,edi
  22f9a6:	29 c6                	sub    esi,eax
  22f9a8:	7d 0a                	jge    22f9b4 <sqrtf+0x324>
  22f9aa:	89 fe                	mov    esi,edi
  22f9ac:	01 f6                	add    esi,esi
  22f9ae:	39 d6                	cmp    esi,edx
  22f9b0:	7f 0e                	jg     22f9c0 <sqrtf+0x330>
  22f9b2:	eb 14                	jmp    22f9c8 <sqrtf+0x338>
            s = t + r;
  22f9b4:	83 c2 04             	add    edx,0x4
            q += r;
  22f9b7:	83 c1 02             	add    ecx,0x2
  22f9ba:	01 f6                	add    esi,esi
        if (t <= ix) {
  22f9bc:	39 d6                	cmp    esi,edx
  22f9be:	7e 08                	jle    22f9c8 <sqrtf+0x338>
        const t = s + r;
  22f9c0:	83 c2 01             	add    edx,0x1
            ix -= t;
  22f9c3:	29 d6                	sub    esi,edx
            q += r;
  22f9c5:	83 c1 01             	add    ecx,0x1
    m >>= 1; // m = [m / 2]
  22f9c8:	41 83 e0 fe          	and    r8d,0xfffffffe
  22f9cc:	41 c1 e0 16          	shl    r8d,0x16
        ix += ix;
        r >>= 1;
    }

    // floating add to find rounding direction
    if (ix != 0) {
  22f9d0:	85 f6                	test   esi,esi
  22f9d2:	0f 95 c0             	setne  al
  22f9d5:	20 c8                	and    al,cl
  22f9d7:	0f b6 c0             	movzx  eax,al
  22f9da:	01 c8                	add    eax,ecx
                }
            }
        }
    }

    ix = (q >> 1) + 0x3f000000;
  22f9dc:	d1 f8                	sar    eax,1
    ix += m << 23;
  22f9de:	41 8d 04 00          	lea    eax,[r8+rax*1]
  22f9e2:	05 00 00 00 3f       	add    eax,0x3f000000
    return @bitCast(f32, ix);
  22f9e7:	c5 f9 6e c0          	vmovd  xmm0,eax
  22f9eb:	c3                   	ret    
  22f9ec:	c5 f9 6e 05 04 9d fd 	vmovd  xmm0,DWORD PTR [rip+0xfffffffffffd9d04]        # 2096f8 <__unnamed_55+0x18>
  22f9f3:	ff 
            return x; // sqrt (+-0) = +-0
  22f9f4:	c3                   	ret    
  22f9f5:	cc                   	int3   
  22f9f6:	cc                   	int3   
  22f9f7:	cc                   	int3   
  22f9f8:	cc                   	int3   
  22f9f9:	cc                   	int3   
  22f9fa:	cc                   	int3   
  22f9fb:	cc                   	int3   
  22f9fc:	cc                   	int3   
  22f9fd:	cc                   	int3   
  22f9fe:	cc                   	int3   
  22f9ff:	cc                   	int3   

000000000022fa00 <__udivmoddi4>:
const udivmod = @import("udivmod.zig").udivmod;
const builtin = @import("builtin");

pub extern fn __udivmoddi4(a: u64, b: u64, maybe_rem: ?*u64) u64 {
  22fa00:	55                   	push   rbp
  22fa01:	41 57                	push   r15
  22fa03:	41 56                	push   r14
  22fa05:	41 54                	push   r12
  22fa07:	53                   	push   rbx
  22fa08:	49 89 d0             	mov    r8,rdx
  22fa0b:	49 89 fa             	mov    r10,rdi
  22fa0e:	4c 89 d3             	mov    rbx,r10
  22fa11:	48 c1 eb 20          	shr    rbx,0x20
  22fa15:	48 89 f1             	mov    rcx,rsi
  22fa18:	48 c1 e9 20          	shr    rcx,0x20
    const d = @ptrCast(*const [2]SingleInt, &b).*; // TODO issue #421
    var q: [2]SingleInt = undefined;
    var r: [2]SingleInt = undefined;
    var sr: c_uint = undefined;
    // special cases, X is unknown, K != 0
    if (n[high] == 0) {
  22fa1c:	85 db                	test   ebx,ebx
  22fa1e:	74 2f                	je     22fa4f <__udivmoddi4+0x4f>
            rem.* = n[low];
        }
        return 0;
    }
    // n[high] != 0
    if (d[low] == 0) {
  22fa20:	85 f6                	test   esi,esi
  22fa22:	74 46                	je     22fa6a <__udivmoddi4+0x6a>
  22fa24:	85 c9                	test   ecx,ecx
        // r.all = a >> sr;
        r[high] = n[high] >> @intCast(Log2SingleInt, sr);
        r[low] = (n[high] << @intCast(Log2SingleInt, SingleInt.bit_count - sr)) | (n[low] >> @intCast(Log2SingleInt, sr));
    } else {
        // d[low] != 0
        if (d[high] == 0) {
  22fa26:	74 78                	je     22faa0 <__udivmoddi4+0xa0>
            }
        } else {
            // K X
            // ---
            // K K
            sr = @bitCast(c_uint, c_int(@clz(d[high])) - c_int(@clz(n[high])));
  22fa28:	f3 0f bd e9          	lzcnt  ebp,ecx
  22fa2c:	f3 0f bd c3          	lzcnt  eax,ebx
  22fa30:	29 c5                	sub    ebp,eax
            // 0 <= sr <= SingleInt.bit_count - 1 or sr large
            if (sr > SingleInt.bit_count - 1) {
  22fa32:	83 fd 20             	cmp    ebp,0x20
  22fa35:	0f 82 b3 00 00 00    	jb     22faee <__udivmoddi4+0xee>
                if (maybe_rem) |rem| {
  22fa3b:	4d 85 c0             	test   r8,r8
  22fa3e:	0f 84 d5 00 00 00    	je     22fb19 <__udivmoddi4+0x119>
  22fa44:	4d 89 10             	mov    QWORD PTR [r8],r10
  22fa47:	45 31 d2             	xor    r10d,r10d
  22fa4a:	e9 06 03 00 00       	jmp    22fd55 <__udivmoddi4+0x355>
        if (d[high] == 0) {
  22fa4f:	85 c9                	test   ecx,ecx
  22fa51:	74 7d                	je     22fad0 <__udivmoddi4+0xd0>
  22fa53:	4d 85 c0             	test   r8,r8
        if (maybe_rem) |rem| {
  22fa56:	0f 84 bd 00 00 00    	je     22fb19 <__udivmoddi4+0x119>
            rem.* = n[low];
  22fa5c:	44 89 d0             	mov    eax,r10d
  22fa5f:	49 89 00             	mov    QWORD PTR [r8],rax
  22fa62:	45 31 d2             	xor    r10d,r10d
  22fa65:	e9 eb 02 00 00       	jmp    22fd55 <__udivmoddi4+0x355>
  22fa6a:	85 c9                	test   ecx,ecx
        if (d[high] == 0) {
  22fa6c:	0f 84 93 00 00 00    	je     22fb05 <__udivmoddi4+0x105>
        if (n[low] == 0) {
  22fa72:	45 85 d2             	test   r10d,r10d
  22fa75:	0f 84 d2 00 00 00    	je     22fb4d <__udivmoddi4+0x14d>
        if ((d[high] & (d[high] - 1)) == 0) {
  22fa7b:	8d 41 ff             	lea    eax,[rcx-0x1]
  22fa7e:	85 c8                	test   eax,ecx
  22fa80:	0f 84 5d 01 00 00    	je     22fbe3 <__udivmoddi4+0x1e3>
        sr = @bitCast(c_uint, c_int(@clz(d[high])) - c_int(@clz(n[high])));
  22fa86:	f3 0f bd c9          	lzcnt  ecx,ecx
  22fa8a:	f3 0f bd c3          	lzcnt  eax,ebx
  22fa8e:	29 c1                	sub    ecx,eax
        if (sr > SingleInt.bit_count - 2) {
  22fa90:	83 f9 1f             	cmp    ecx,0x1f
  22fa93:	0f 82 6c 01 00 00    	jb     22fc05 <__udivmoddi4+0x205>
            if (maybe_rem) |rem| {
  22fa99:	4d 85 c0             	test   r8,r8
  22fa9c:	75 a6                	jne    22fa44 <__udivmoddi4+0x44>
  22fa9e:	eb 79                	jmp    22fb19 <__udivmoddi4+0x119>
            if ((d[low] & (d[low] - 1)) == 0) {
  22faa0:	8d 46 ff             	lea    eax,[rsi-0x1]
  22faa3:	85 f0                	test   eax,esi
  22faa5:	0f 84 c2 00 00 00    	je     22fb6d <__udivmoddi4+0x16d>
            sr = 1 + SingleInt.bit_count + c_uint(@clz(d[low])) - c_uint(@clz(n[high]));
  22faab:	f3 0f bd ce          	lzcnt  ecx,esi
  22faaf:	83 c1 21             	add    ecx,0x21
  22fab2:	f3 0f bd c3          	lzcnt  eax,ebx
  22fab6:	29 c1                	sub    ecx,eax
  22fab8:	31 d2                	xor    edx,edx
            if (sr == SingleInt.bit_count) {
  22faba:	83 f9 20             	cmp    ecx,0x20
  22fabd:	0f 85 e7 00 00 00    	jne    22fbaa <__udivmoddi4+0x1aa>
  22fac3:	45 31 ff             	xor    r15d,r15d
  22fac6:	b9 20 00 00 00       	mov    ecx,0x20
  22facb:	e9 7c 01 00 00       	jmp    22fc4c <__udivmoddi4+0x24c>
  22fad0:	4d 85 c0             	test   r8,r8
            if (maybe_rem) |rem| {
  22fad3:	74 0a                	je     22fadf <__udivmoddi4+0xdf>
                rem.* = n[low] % d[low];
  22fad5:	31 d2                	xor    edx,edx
  22fad7:	44 89 d0             	mov    eax,r10d
  22fada:	f7 f6                	div    esi
  22fadc:	49 89 10             	mov    QWORD PTR [r8],rdx
            return n[low] / d[low];
  22fadf:	31 d2                	xor    edx,edx
  22fae1:	44 89 d0             	mov    eax,r10d
  22fae4:	f7 f6                	div    esi
  22fae6:	41 89 c2             	mov    r10d,eax
  22fae9:	e9 67 02 00 00       	jmp    22fd55 <__udivmoddi4+0x355>
                    rem.* = a;
                }
                return 0;
            }
            sr += 1;
  22faee:	8d 4d 01             	lea    ecx,[rbp+0x1]
  22faf1:	45 31 ff             	xor    r15d,r15d
            // 1 <= sr <= SingleInt.bit_count
            // q.all = a << (DoubleInt.bit_count - sr);
            // r.all = a >> sr;
            q[low] = 0;
            if (sr == SingleInt.bit_count) {
  22faf4:	83 f9 20             	cmp    ecx,0x20
  22faf7:	75 28                	jne    22fb21 <__udivmoddi4+0x121>
  22faf9:	31 d2                	xor    edx,edx
  22fafb:	b9 20 00 00 00       	mov    ecx,0x20
  22fb00:	e9 47 01 00 00       	jmp    22fc4c <__udivmoddi4+0x24c>
            if (maybe_rem) |rem| {
  22fb05:	4d 85 c0             	test   r8,r8
  22fb08:	74 0f                	je     22fb19 <__udivmoddi4+0x119>
                rem.* = n[high] % d[low];
  22fb0a:	49 c7 00 00 00 00 00 	mov    QWORD PTR [r8],0x0
  22fb11:	45 31 d2             	xor    r10d,r10d
  22fb14:	e9 3c 02 00 00       	jmp    22fd55 <__udivmoddi4+0x355>
  22fb19:	45 31 d2             	xor    r10d,r10d
  22fb1c:	e9 34 02 00 00       	jmp    22fd55 <__udivmoddi4+0x355>
                q[high] = n[low];
                r[high] = 0;
                r[low] = n[high];
            } else {
                r[high] = n[high] >> @intCast(Log2SingleInt, sr);
  22fb21:	41 89 c9             	mov    r9d,ecx
  22fb24:	41 83 e1 1f          	and    r9d,0x1f
  22fb28:	c4 e2 33 f7 d3       	shrx   edx,ebx,r9d
  22fb2d:	b8 1f 00 00 00       	mov    eax,0x1f
                r[low] = (n[high] << @intCast(Log2SingleInt, SingleInt.bit_count - sr)) | (n[low] >> @intCast(Log2SingleInt, sr));
  22fb32:	29 e8                	sub    eax,ebp
  22fb34:	83 e0 1f             	and    eax,0x1f
  22fb37:	c4 e2 79 f7 eb       	shlx   ebp,ebx,eax
  22fb3c:	c4 c2 33 f7 da       	shrx   ebx,r10d,r9d
  22fb41:	09 eb                	or     ebx,ebp
                q[high] = n[low] << @intCast(Log2SingleInt, SingleInt.bit_count - sr);
  22fb43:	c4 42 79 f7 d2       	shlx   r10d,r10d,eax
  22fb48:	e9 ff 00 00 00       	jmp    22fc4c <__udivmoddi4+0x24c>
            if (maybe_rem) |rem| {
  22fb4d:	4d 85 c0             	test   r8,r8
  22fb50:	74 0d                	je     22fb5f <__udivmoddi4+0x15f>
                r[high] = n[high] % d[high];
  22fb52:	31 d2                	xor    edx,edx
  22fb54:	89 d8                	mov    eax,ebx
  22fb56:	f7 f1                	div    ecx
                rem.* = @ptrCast(*align(@alignOf(SingleInt)) DoubleInt, &r[0]).*; // TODO issue #421
  22fb58:	48 c1 e2 20          	shl    rdx,0x20
  22fb5c:	49 89 10             	mov    QWORD PTR [r8],rdx
            return n[high] / d[high];
  22fb5f:	31 d2                	xor    edx,edx
  22fb61:	89 d8                	mov    eax,ebx
  22fb63:	f7 f1                	div    ecx
  22fb65:	41 89 c2             	mov    r10d,eax
  22fb68:	e9 e8 01 00 00       	jmp    22fd55 <__udivmoddi4+0x355>
                if (maybe_rem) |rem| {
  22fb6d:	4d 85 c0             	test   r8,r8
  22fb70:	74 06                	je     22fb78 <__udivmoddi4+0x178>
                    rem.* = n[low] & (d[low] - 1);
  22fb72:	44 21 d0             	and    eax,r10d
  22fb75:	49 89 00             	mov    QWORD PTR [r8],rax
                if (d[low] == 1) {
  22fb78:	83 fe 01             	cmp    esi,0x1
  22fb7b:	0f 84 d4 01 00 00    	je     22fd55 <__udivmoddi4+0x355>
                sr = @ctz(d[low]);
  22fb81:	f3 0f bc c6          	tzcnt  eax,esi
                q[high] = n[high] >> @intCast(Log2SingleInt, sr);
  22fb85:	89 c1                	mov    ecx,eax
  22fb87:	83 e1 1f             	and    ecx,0x1f
  22fb8a:	c4 e2 73 f7 d3       	shrx   edx,ebx,ecx
                q[low] = (n[high] << @intCast(Log2SingleInt, SingleInt.bit_count - sr)) | (n[low] >> @intCast(Log2SingleInt, sr));
  22fb8f:	f7 d8                	neg    eax
  22fb91:	c4 e2 79 f7 c3       	shlx   eax,ebx,eax
  22fb96:	c4 42 73 f7 d2       	shrx   r10d,r10d,ecx
  22fb9b:	41 09 c2             	or     r10d,eax
                return @ptrCast(*align(@alignOf(SingleInt)) DoubleInt, &q[0]).*; // TODO issue #421
  22fb9e:	48 c1 e2 20          	shl    rdx,0x20
  22fba2:	49 09 d2             	or     r10,rdx
  22fba5:	e9 ab 01 00 00       	jmp    22fd55 <__udivmoddi4+0x355>
  22fbaa:	89 cd                	mov    ebp,ecx
  22fbac:	f7 dd                	neg    ebp
  22fbae:	83 e5 1f             	and    ebp,0x1f
  22fbb1:	c4 42 51 f7 fa       	shlx   r15d,r10d,ebp
            } else if (sr < SingleInt.bit_count) {
  22fbb6:	83 f9 20             	cmp    ecx,0x20
  22fbb9:	73 7a                	jae    22fc35 <__udivmoddi4+0x235>
  22fbbb:	31 d2                	xor    edx,edx
    // q.all = a << (DoubleInt.bit_count - sr);
    // r.all = a >> sr;
    // 1 <= sr <= DoubleInt.bit_count - 1
    var carry: u32 = 0;
    var r_all: DoubleInt = undefined;
    while (sr > 0) : (sr -= 1) {
  22fbbd:	85 c9                	test   ecx,ecx
  22fbbf:	0f 84 9c 01 00 00    	je     22fd61 <__udivmoddi4+0x361>
  22fbc5:	89 c8                	mov    eax,ecx
  22fbc7:	83 e0 1f             	and    eax,0x1f
  22fbca:	c4 e2 7b f7 d3       	shrx   edx,ebx,eax
  22fbcf:	c4 e2 51 f7 eb       	shlx   ebp,ebx,ebp
  22fbd4:	c4 c2 7b f7 da       	shrx   ebx,r10d,eax
  22fbd9:	09 eb                	or     ebx,ebp
  22fbdb:	45 89 fa             	mov    r10d,r15d
  22fbde:	45 31 ff             	xor    r15d,r15d
  22fbe1:	eb 69                	jmp    22fc4c <__udivmoddi4+0x24c>
            if (maybe_rem) |rem| {
  22fbe3:	4d 85 c0             	test   r8,r8
  22fbe6:	74 0f                	je     22fbf7 <__udivmoddi4+0x1f7>
                r[high] = n[high] & (d[high] - 1);
  22fbe8:	21 d8                	and    eax,ebx
                rem.* = @ptrCast(*align(@alignOf(SingleInt)) DoubleInt, &r[0]).*; // TODO issue #421
  22fbea:	48 c1 e0 20          	shl    rax,0x20
  22fbee:	44 89 d2             	mov    edx,r10d
  22fbf1:	48 09 c2             	or     rdx,rax
  22fbf4:	49 89 10             	mov    QWORD PTR [r8],rdx
            return n[high] >> @intCast(Log2SingleInt, @ctz(d[high]));
  22fbf7:	f3 0f bc c1          	tzcnt  eax,ecx
  22fbfb:	c4 62 7b f7 d3       	shrx   r10d,ebx,eax
  22fc00:	e9 50 01 00 00       	jmp    22fd55 <__udivmoddi4+0x355>
        q[high] = n[low] << @intCast(Log2SingleInt, SingleInt.bit_count - sr);
  22fc05:	b8 1f 00 00 00       	mov    eax,0x1f
  22fc0a:	29 c8                	sub    eax,ecx
        sr += 1;
  22fc0c:	83 c1 01             	add    ecx,0x1
        q[high] = n[low] << @intCast(Log2SingleInt, SingleInt.bit_count - sr);
  22fc0f:	83 e0 1f             	and    eax,0x1f
        r[high] = n[high] >> @intCast(Log2SingleInt, sr);
  22fc12:	89 cd                	mov    ebp,ecx
  22fc14:	83 e5 1f             	and    ebp,0x1f
  22fc17:	c4 e2 53 f7 d3       	shrx   edx,ebx,ebp
        r[low] = (n[high] << @intCast(Log2SingleInt, SingleInt.bit_count - sr)) | (n[low] >> @intCast(Log2SingleInt, sr));
  22fc1c:	c4 e2 79 f7 fb       	shlx   edi,ebx,eax
  22fc21:	c4 c2 53 f7 da       	shrx   ebx,r10d,ebp
        q[high] = n[low] << @intCast(Log2SingleInt, SingleInt.bit_count - sr);
  22fc26:	c4 c2 79 f7 ea       	shlx   ebp,r10d,eax
        r[low] = (n[high] << @intCast(Log2SingleInt, SingleInt.bit_count - sr)) | (n[low] >> @intCast(Log2SingleInt, sr));
  22fc2b:	09 fb                	or     ebx,edi
  22fc2d:	45 31 ff             	xor    r15d,r15d
  22fc30:	41 89 ea             	mov    r10d,ebp
  22fc33:	eb 17                	jmp    22fc4c <__udivmoddi4+0x24c>
                q[high] = (n[high] << @intCast(Log2SingleInt, DoubleInt.bit_count - sr)) | (n[low] >> @intCast(Log2SingleInt, sr - SingleInt.bit_count));
  22fc35:	c4 e2 51 f7 eb       	shlx   ebp,ebx,ebp
  22fc3a:	89 c8                	mov    eax,ecx
  22fc3c:	83 e0 1f             	and    eax,0x1f
  22fc3f:	c4 42 7b f7 d2       	shrx   r10d,r10d,eax
  22fc44:	41 09 ea             	or     r10d,ebp
                r[low] = n[high] >> @intCast(Log2SingleInt, sr - SingleInt.bit_count);
  22fc47:	c4 e2 7b f7 db       	shrx   ebx,ebx,eax
  22fc4c:	4c 8d 4e ff          	lea    r9,[rsi-0x1]
    while (sr > 0) : (sr -= 1) {
  22fc50:	41 89 cb             	mov    r11d,ecx
  22fc53:	41 83 e3 01          	and    r11d,0x1
  22fc57:	83 f9 01             	cmp    ecx,0x1
  22fc5a:	75 10                	jne    22fc6c <__udivmoddi4+0x26c>
  22fc5c:	31 c9                	xor    ecx,ecx
  22fc5e:	45 85 db             	test   r11d,r11d
  22fc61:	0f 85 9e 00 00 00    	jne    22fd05 <__udivmoddi4+0x305>
  22fc67:	e9 c9 00 00 00       	jmp    22fd35 <__udivmoddi4+0x335>
  22fc6c:	45 89 dc             	mov    r12d,r11d
  22fc6f:	41 29 cc             	sub    r12d,ecx
  22fc72:	31 c9                	xor    ecx,ecx
  22fc74:	41 be 1e 01 00 00    	mov    r14d,0x11e
  22fc7a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
        // r:q = ((r:q)  << 1) | carry
        r[high] = (r[high] << 1) | (r[low] >> (SingleInt.bit_count - 1));
  22fc80:	0f a4 da 01          	shld   edx,ebx,0x1
        r[low] = (r[low] << 1) | (q[high] >> (SingleInt.bit_count - 1));
  22fc84:	44 0f a4 d3 01       	shld   ebx,r10d,0x1
  22fc89:	c4 c2 08 f7 ea       	bextr  ebp,r10d,r14d
        q[high] = (q[high] << 1) | (q[low] >> (SingleInt.bit_count - 1));
  22fc8e:	45 0f a4 fa 01       	shld   r10d,r15d,0x1
        q[low] = (q[low] << 1) | carry;
  22fc93:	43 8d 04 3f          	lea    eax,[r15+r15*1]
  22fc97:	09 c8                	or     eax,ecx
        // if (r.all >= b)
        // {
        //     r.all -= b;
        //      carry = 1;
        // }
        r_all = @ptrCast(*align(@alignOf(SingleInt)) DoubleInt, &r[0]).*; // TODO issue #421
  22fc99:	48 c1 e2 20          	shl    rdx,0x20
  22fc9d:	48 09 d3             	or     rbx,rdx
        const s: SignedDoubleInt = @intCast(SignedDoubleInt, b -% r_all -% 1) >> (DoubleInt.bit_count - 1);
  22fca0:	4c 89 c9             	mov    rcx,r9
  22fca3:	48 29 d9             	sub    rcx,rbx
  22fca6:	48 c1 f9 3f          	sar    rcx,0x3f
        carry = @intCast(u32, s & 1);
  22fcaa:	89 ca                	mov    edx,ecx
  22fcac:	83 e2 01             	and    edx,0x1
        r_all -= b & @bitCast(DoubleInt, s);
  22fcaf:	48 21 f1             	and    rcx,rsi
  22fcb2:	48 29 cb             	sub    rbx,rcx
        r[high] = (r[high] << 1) | (r[low] >> (SingleInt.bit_count - 1));
  22fcb5:	48 89 d9             	mov    rcx,rbx
  22fcb8:	48 c1 e9 1f          	shr    rcx,0x1f
  22fcbc:	83 e1 fe             	and    ecx,0xfffffffe
  22fcbf:	89 df                	mov    edi,ebx
  22fcc1:	c1 ef 1f             	shr    edi,0x1f
  22fcc4:	09 cf                	or     edi,ecx
        q[high] = (q[high] << 1) | (q[low] >> (SingleInt.bit_count - 1));
  22fcc6:	c4 c2 08 f7 cf       	bextr  ecx,r15d,r14d
        r[low] = (r[low] << 1) | (q[high] >> (SingleInt.bit_count - 1));
  22fccb:	8d 5c 5d 00          	lea    ebx,[rbp+rbx*2+0x0]
        q[high] = (q[high] << 1) | (q[low] >> (SingleInt.bit_count - 1));
  22fccf:	46 8d 14 51          	lea    r10d,[rcx+r10*2]
        q[low] = (q[low] << 1) | carry;
  22fcd3:	44 8d 3c 42          	lea    r15d,[rdx+rax*2]
        r_all = @ptrCast(*align(@alignOf(SingleInt)) DoubleInt, &r[0]).*; // TODO issue #421
  22fcd7:	48 c1 e7 20          	shl    rdi,0x20
  22fcdb:	48 09 fb             	or     rbx,rdi
        const s: SignedDoubleInt = @intCast(SignedDoubleInt, b -% r_all -% 1) >> (DoubleInt.bit_count - 1);
  22fcde:	4c 89 c8             	mov    rax,r9
  22fce1:	48 29 d8             	sub    rax,rbx
  22fce4:	48 c1 f8 3f          	sar    rax,0x3f
        carry = @intCast(u32, s & 1);
  22fce8:	89 c1                	mov    ecx,eax
  22fcea:	83 e1 01             	and    ecx,0x1
        r_all -= b & @bitCast(DoubleInt, s);
  22fced:	48 21 f0             	and    rax,rsi
  22fcf0:	48 29 c3             	sub    rbx,rax
        r = @ptrCast(*[2]SingleInt, &r_all).*; // TODO issue #421
  22fcf3:	48 89 da             	mov    rdx,rbx
  22fcf6:	48 c1 ea 20          	shr    rdx,0x20
    while (sr > 0) : (sr -= 1) {
  22fcfa:	41 83 c4 02          	add    r12d,0x2
  22fcfe:	75 80                	jne    22fc80 <__udivmoddi4+0x280>
  22fd00:	45 85 db             	test   r11d,r11d
  22fd03:	74 30                	je     22fd35 <__udivmoddi4+0x335>
        r[high] = (r[high] << 1) | (r[low] >> (SingleInt.bit_count - 1));
  22fd05:	0f a4 da 01          	shld   edx,ebx,0x1
        r[low] = (r[low] << 1) | (q[high] >> (SingleInt.bit_count - 1));
  22fd09:	44 0f a4 d3 01       	shld   ebx,r10d,0x1
        r_all = @ptrCast(*align(@alignOf(SingleInt)) DoubleInt, &r[0]).*; // TODO issue #421
  22fd0e:	48 c1 e2 20          	shl    rdx,0x20
  22fd12:	48 09 d3             	or     rbx,rdx
        const s: SignedDoubleInt = @intCast(SignedDoubleInt, b -% r_all -% 1) >> (DoubleInt.bit_count - 1);
  22fd15:	49 29 d9             	sub    r9,rbx
  22fd18:	49 c1 f9 3f          	sar    r9,0x3f
        r_all -= b & @bitCast(DoubleInt, s);
  22fd1c:	4c 21 ce             	and    rsi,r9
  22fd1f:	48 29 f3             	sub    rbx,rsi
        carry = @intCast(u32, s & 1);
  22fd22:	41 83 e1 01          	and    r9d,0x1
        q[high] = (q[high] << 1) | (q[low] >> (SingleInt.bit_count - 1));
  22fd26:	45 0f a4 fa 01       	shld   r10d,r15d,0x1
        q[low] = (q[low] << 1) | carry;
  22fd2b:	42 8d 04 79          	lea    eax,[rcx+r15*2]
  22fd2f:	41 89 c7             	mov    r15d,eax
  22fd32:	44 89 c9             	mov    ecx,r9d
    }
    const q_all = ((@ptrCast(*align(@alignOf(SingleInt)) DoubleInt, &q[0]).*) << 1) | carry; // TODO issue #421
  22fd35:	89 ca                	mov    edx,ecx
  22fd37:	44 89 f9             	mov    ecx,r15d
  22fd3a:	45 89 d7             	mov    r15d,r10d
  22fd3d:	49 c1 e7 20          	shl    r15,0x20
  22fd41:	49 09 cf             	or     r15,rcx
  22fd44:	4d 01 ff             	add    r15,r15
  22fd47:	4d 89 fa             	mov    r10,r15
  22fd4a:	49 09 d2             	or     r10,rdx
    if (maybe_rem) |rem| {
  22fd4d:	4d 85 c0             	test   r8,r8
  22fd50:	74 03                	je     22fd55 <__udivmoddi4+0x355>
        rem.* = r_all;
  22fd52:	49 89 18             	mov    QWORD PTR [r8],rbx
    @setRuntimeSafety(builtin.is_test);
    return udivmod(u64, a, b, maybe_rem);
  22fd55:	4c 89 d0             	mov    rax,r10
  22fd58:	5b                   	pop    rbx
  22fd59:	41 5c                	pop    r12
  22fd5b:	41 5e                	pop    r14
  22fd5d:	41 5f                	pop    r15
  22fd5f:	5d                   	pop    rbp
  22fd60:	c3                   	ret    
  22fd61:	31 c9                	xor    ecx,ecx
  22fd63:	eb d8                	jmp    22fd3d <__udivmoddi4+0x33d>
  22fd65:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  22fd6c:	00 00 00 00 

000000000022fd70 <__cmptf2>:
const is_test = builtin.is_test;

pub extern fn __letf2(a: f128, b: f128) c_int {
    @setRuntimeSafety(is_test);

    const aInt = @bitCast(rep_t, a);
  22fd70:	66 0f 7f 44 24 e8    	movdqa XMMWORD PTR [rsp-0x18],xmm0
  22fd76:	4c 8b 5c 24 e8       	mov    r11,QWORD PTR [rsp-0x18]
  22fd7b:	4c 8b 44 24 f0       	mov    r8,QWORD PTR [rsp-0x10]
    const bInt = @bitCast(rep_t, b);
  22fd80:	66 0f 7f 4c 24 d8    	movdqa XMMWORD PTR [rsp-0x28],xmm1

    const aAbs: rep_t = aInt & absMask;
  22fd86:	40 b6 3f             	mov    sil,0x3f
  22fd89:	c4 c2 c8 f5 c8       	bzhi   rcx,r8,rsi
    const bAbs: rep_t = bInt & absMask;

    // If either a or b is NaN, they are unordered.
    if (aAbs > infRep or bAbs > infRep) return LE_UNORDERED;
  22fd8e:	4c 89 d8             	mov    rax,r11
  22fd91:	48 f7 d8             	neg    rax
  22fd94:	49 ba 00 00 00 00 00 	movabs r10,0x7fff000000000000
  22fd9b:	00 ff 7f 
  22fd9e:	4c 89 d0             	mov    rax,r10
  22fda1:	48 19 c8             	sbb    rax,rcx
  22fda4:	b8 01 00 00 00       	mov    eax,0x1
  22fda9:	72 68                	jb     22fe13 <__cmptf2+0xa3>
  22fdab:	48 8b 7c 24 d8       	mov    rdi,QWORD PTR [rsp-0x28]
  22fdb0:	4c 8b 4c 24 e0       	mov    r9,QWORD PTR [rsp-0x20]
  22fdb5:	c4 c2 c8 f5 d1       	bzhi   rdx,r9,rsi
  22fdba:	48 83 ff 01          	cmp    rdi,0x1
  22fdbe:	48 89 d6             	mov    rsi,rdx
  22fdc1:	4c 19 d6             	sbb    rsi,r10
  22fdc4:	73 4d                	jae    22fe13 <__cmptf2+0xa3>

    // If a and b are both zeros, they are equal.
    if ((aAbs | bAbs) == 0) return LE_EQUAL;
  22fdc6:	48 89 f8             	mov    rax,rdi
  22fdc9:	4c 09 d8             	or     rax,r11
  22fdcc:	48 09 ca             	or     rdx,rcx
  22fdcf:	48 09 c2             	or     rdx,rax
  22fdd2:	74 40                	je     22fe14 <__cmptf2+0xa4>
  22fdd4:	b8 ff ff ff ff       	mov    eax,0xffffffff

    // If at least one of a and b is positive, we get the same result comparing
    // a and b as signed integers as we would with a floating-point compare.
    return if ((aInt & bInt) >= 0) if (aInt < bInt)
  22fdd9:	49 39 fb             	cmp    r11,rdi
  22fddc:	4c 89 c1             	mov    rcx,r8
  22fddf:	4c 19 c9             	sbb    rcx,r9
  22fde2:	72 2f                	jb     22fe13 <__cmptf2+0xa3>
        LE_LESS
    else if (aInt == bInt)
  22fde4:	c4 e1 f9 6e c7       	vmovq  xmm0,rdi
  22fde9:	c4 c1 f9 6e c9       	vmovq  xmm1,r9
  22fdee:	c5 f9 6c c1          	vpunpcklqdq xmm0,xmm0,xmm1
  22fdf2:	c4 c1 f9 6e cb       	vmovq  xmm1,r11
  22fdf7:	c4 c1 f9 6e d0       	vmovq  xmm2,r8
  22fdfc:	c5 f1 6c ca          	vpunpcklqdq xmm1,xmm1,xmm2
  22fe00:	c5 f1 74 c0          	vpcmpeqb xmm0,xmm1,xmm0
  22fe04:	c5 f9 d7 c8          	vpmovmskb ecx,xmm0
  22fe08:	31 c0                	xor    eax,eax
  22fe0a:	81 f9 ff ff 00 00    	cmp    ecx,0xffff
  22fe10:	0f 95 c0             	setne  al
    if (aAbs > infRep or bAbs > infRep) return LE_UNORDERED;
  22fe13:	c3                   	ret    
  22fe14:	31 c0                	xor    eax,eax
  22fe16:	c3                   	ret    
  22fe17:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  22fe1e:	00 00 

000000000022fe20 <__gttf2>:
const GE_UNORDERED = c_int(-1); // Note: different from LE_UNORDERED

pub extern fn __getf2(a: f128, b: f128) c_int {
    @setRuntimeSafety(is_test);

    const aInt = @bitCast(srep_t, a);
  22fe20:	53                   	push   rbx
  22fe21:	0f 29 44 24 f0       	movaps XMMWORD PTR [rsp-0x10],xmm0
  22fe26:	4c 8b 54 24 f0       	mov    r10,QWORD PTR [rsp-0x10]
  22fe2b:	4c 8b 44 24 f8       	mov    r8,QWORD PTR [rsp-0x8]
    const bInt = @bitCast(srep_t, b);
  22fe30:	0f 29 4c 24 e0       	movaps XMMWORD PTR [rsp-0x20],xmm1
    const aAbs = @bitCast(rep_t, aInt) & absMask;
  22fe35:	41 b1 3f             	mov    r9b,0x3f
  22fe38:	c4 c2 b0 f5 c8       	bzhi   rcx,r8,r9
    const bAbs = @bitCast(rep_t, bInt) & absMask;

    if (aAbs > infRep or bAbs > infRep) return GE_UNORDERED;
  22fe3d:	4c 89 d0             	mov    rax,r10
  22fe40:	48 f7 d8             	neg    rax
  22fe43:	48 bb 00 00 00 00 00 	movabs rbx,0x7fff000000000000
  22fe4a:	00 ff 7f 
  22fe4d:	48 89 d8             	mov    rax,rbx
  22fe50:	48 19 c8             	sbb    rax,rcx
  22fe53:	b8 ff ff ff ff       	mov    eax,0xffffffff
  22fe58:	72 39                	jb     22fe93 <__gttf2+0x73>
  22fe5a:	48 8b 7c 24 e0       	mov    rdi,QWORD PTR [rsp-0x20]
  22fe5f:	4c 8b 5c 24 e8       	mov    r11,QWORD PTR [rsp-0x18]
  22fe64:	c4 c2 b0 f5 f3       	bzhi   rsi,r11,r9
  22fe69:	48 83 ff 01          	cmp    rdi,0x1
  22fe6d:	48 89 f2             	mov    rdx,rsi
  22fe70:	48 19 da             	sbb    rdx,rbx
  22fe73:	73 1e                	jae    22fe93 <__gttf2+0x73>
    if ((aAbs | bAbs) == 0) return GE_EQUAL;
  22fe75:	48 89 fa             	mov    rdx,rdi
  22fe78:	4c 09 d2             	or     rdx,r10
  22fe7b:	48 09 ce             	or     rsi,rcx
  22fe7e:	48 09 d6             	or     rsi,rdx
  22fe81:	74 12                	je     22fe95 <__gttf2+0x75>
    return if ((aInt & bInt) >= 0) if (aInt < bInt)
  22fe83:	4d 85 c3             	test   r11,r8
  22fe86:	78 11                	js     22fe99 <__gttf2+0x79>
  22fe88:	49 39 fa             	cmp    r10,rdi
  22fe8b:	4c 89 c1             	mov    rcx,r8
  22fe8e:	4c 19 d9             	sbb    rcx,r11
  22fe91:	7d 11                	jge    22fea4 <__gttf2+0x84>
    if (aAbs > infRep or bAbs > infRep) return GE_UNORDERED;
  22fe93:	5b                   	pop    rbx
  22fe94:	c3                   	ret    
  22fe95:	31 c0                	xor    eax,eax
  22fe97:	5b                   	pop    rbx
  22fe98:	c3                   	ret    
        GE_LESS
    else if (aInt == bInt)
        GE_EQUAL
    else
        GE_GREATER else if (aInt > bInt)
  22fe99:	4c 39 d7             	cmp    rdi,r10
  22fe9c:	4c 89 d9             	mov    rcx,r11
  22fe9f:	4c 19 c1             	sbb    rcx,r8
  22fea2:	7c ef                	jl     22fe93 <__gttf2+0x73>
  22fea4:	c4 e1 f9 6e c7       	vmovq  xmm0,rdi
  22fea9:	c4 c1 f9 6e cb       	vmovq  xmm1,r11
  22feae:	c5 f9 6c c1          	vpunpcklqdq xmm0,xmm0,xmm1
  22feb2:	c4 c1 f9 6e ca       	vmovq  xmm1,r10
  22feb7:	c4 c1 f9 6e d0       	vmovq  xmm2,r8
  22febc:	c5 f1 6c ca          	vpunpcklqdq xmm1,xmm1,xmm2
  22fec0:	c5 f1 74 c0          	vpcmpeqb xmm0,xmm1,xmm0
  22fec4:	c5 f9 d7 c8          	vpmovmskb ecx,xmm0
  22fec8:	31 c0                	xor    eax,eax
  22feca:	81 f9 ff ff 00 00    	cmp    ecx,0xffff
  22fed0:	0f 95 c0             	setne  al
    if (aAbs > infRep or bAbs > infRep) return GE_UNORDERED;
  22fed3:	5b                   	pop    rbx
  22fed4:	c3                   	ret    
  22fed5:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  22fedc:	00 00 00 00 

000000000022fee0 <__extendhfsf2>:

    const dstMinNormal: dst_rep_t = dst_rep_t(1) << dstSigBits;

    // Break a into a sign and representation of the absolute value
    const aRep: src_rep_t = @bitCast(src_rep_t, a);
    const aAbs: src_rep_t = aRep & srcAbsMask;
  22fee0:	89 f9                	mov    ecx,edi
  22fee2:	81 e1 ff 7f 00 00    	and    ecx,0x7fff
    const sign: src_rep_t = aRep & srcSignMask;
  22fee8:	89 f8                	mov    eax,edi
  22feea:	25 00 80 00 00       	and    eax,0x8000
    var absResult: dst_rep_t = undefined;

    if (aAbs -% srcMinNormal < srcInfinity - srcMinNormal) {
  22feef:	89 ca                	mov    edx,ecx
  22fef1:	81 c2 00 fc ff ff    	add    edx,0xfffffc00
  22fef7:	0f b7 d2             	movzx  edx,dx
  22fefa:	81 fa ff 77 00 00    	cmp    edx,0x77ff
  22ff00:	77 16                	ja     22ff18 <__extendhfsf2+0x38>
        // a is a normal number.
        // Extend to the destination type by shifting the significand and
        // exponent into the proper position and rebiasing the exponent.
        absResult = dst_rep_t(aAbs) << (dstSigBits - srcSigBits);
  22ff02:	0f b7 c9             	movzx  ecx,cx
  22ff05:	c1 e1 0d             	shl    ecx,0xd
        absResult += (dstExpBias - srcExpBias) << dstSigBits;
  22ff08:	81 c1 00 00 00 38    	add    ecx,0x38000000
        // a is zero.
        absResult = 0;
    }

    // Apply the signbit to (dst_t)abs(a).
    const result: dst_rep_t align(@alignOf(dst_t)) = absResult | dst_rep_t(sign) << (dstBits - srcBits);
  22ff0e:	c1 e0 10             	shl    eax,0x10
  22ff11:	09 c8                	or     eax,ecx
    return @bitCast(dst_t, result);
  22ff13:	c5 f9 6e c0          	vmovd  xmm0,eax
    return extendXfYf2(f32, f16, @bitCast(f16, a));
  22ff17:	c3                   	ret    
    } else if (aAbs >= srcInfinity) {
  22ff18:	0f b7 d1             	movzx  edx,cx
  22ff1b:	81 fa 00 7c 00 00    	cmp    edx,0x7c00
  22ff21:	72 16                	jb     22ff39 <__extendhfsf2+0x59>
        absResult |= dst_rep_t(aAbs & srcNaNCode) << (dstSigBits - srcSigBits);
  22ff23:	0f b7 cf             	movzx  ecx,di
  22ff26:	c1 e1 0d             	shl    ecx,0xd
  22ff29:	81 c9 00 00 80 7f    	or     ecx,0x7f800000
    const result: dst_rep_t align(@alignOf(dst_t)) = absResult | dst_rep_t(sign) << (dstBits - srcBits);
  22ff2f:	c1 e0 10             	shl    eax,0x10
  22ff32:	09 c8                	or     eax,ecx
    return @bitCast(dst_t, result);
  22ff34:	c5 f9 6e c0          	vmovd  xmm0,eax
    return extendXfYf2(f32, f16, @bitCast(f16, a));
  22ff38:	c3                   	ret    
    } else if (aAbs != 0) {
  22ff39:	66 85 c9             	test   cx,cx
  22ff3c:	74 2f                	je     22ff6d <__extendhfsf2+0x8d>
        const scale: u32 = @clz(aAbs) - @clz(src_rep_t(srcMinNormal));
  22ff3e:	66 f3 0f bd c9       	lzcnt  cx,cx
  22ff43:	8d 71 1b             	lea    esi,[rcx+0x1b]
  22ff46:	83 e6 1f             	and    esi,0x1f
        absResult = dst_rep_t(aAbs) << @intCast(DstShift, dstSigBits - srcSigBits + scale);
  22ff49:	83 c1 08             	add    ecx,0x8
  22ff4c:	c4 e2 71 f7 d2       	shlx   edx,edx,ecx
        absResult ^= dstMinNormal;
  22ff51:	81 f2 00 00 80 00    	xor    edx,0x800000
        absResult |= @intCast(dst_rep_t, resultExponent) << dstSigBits;
  22ff57:	c1 e6 17             	shl    esi,0x17
  22ff5a:	b9 00 00 80 38       	mov    ecx,0x38800000
  22ff5f:	29 f1                	sub    ecx,esi
  22ff61:	09 d1                	or     ecx,edx
    const result: dst_rep_t align(@alignOf(dst_t)) = absResult | dst_rep_t(sign) << (dstBits - srcBits);
  22ff63:	c1 e0 10             	shl    eax,0x10
  22ff66:	09 c8                	or     eax,ecx
    return @bitCast(dst_t, result);
  22ff68:	c5 f9 6e c0          	vmovd  xmm0,eax
    return extendXfYf2(f32, f16, @bitCast(f16, a));
  22ff6c:	c3                   	ret    
  22ff6d:	31 c9                	xor    ecx,ecx
    const result: dst_rep_t align(@alignOf(dst_t)) = absResult | dst_rep_t(sign) << (dstBits - srcBits);
  22ff6f:	c1 e0 10             	shl    eax,0x10
  22ff72:	09 c8                	or     eax,ecx
    return @bitCast(dst_t, result);
  22ff74:	c5 f9 6e c0          	vmovd  xmm0,eax
    return extendXfYf2(f32, f16, @bitCast(f16, a));
  22ff78:	c3                   	ret    
  22ff79:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

000000000022ff80 <__truncsfhf2>:

    const dstQNaN = 1 << (dstSigBits - 1);
    const dstNaNCode = dstQNaN - 1;

    // Break a into a sign and representation of the absolute value
    const aRep: src_rep_t = @bitCast(src_rep_t, a);
  22ff80:	c5 f9 7e c2          	vmovd  edx,xmm0
    const aAbs: src_rep_t = aRep & srcAbsMask;
  22ff84:	89 d6                	mov    esi,edx
  22ff86:	81 e6 ff ff ff 7f    	and    esi,0x7fffffff
    const sign: src_rep_t = aRep & srcSignMask;
    var absResult: dst_rep_t = undefined;

    if (aAbs -% underflow < aAbs -% overflow) {
  22ff8c:	8d 86 00 00 80 c7    	lea    eax,[rsi-0x38800000]
  22ff92:	8d 8e 00 00 80 b8    	lea    ecx,[rsi-0x47800000]
  22ff98:	39 c8                	cmp    eax,ecx
  22ff9a:	73 1f                	jae    22ffbb <__truncsfhf2+0x3b>
        // The exponent of a is within the range of normal numbers in the
        // destination format.  We can convert by simply right-shifting with
        // rounding and adjusting the exponent.
        absResult = @truncate(dst_rep_t, aAbs >> (srcSigBits - dstSigBits));
  22ff9c:	89 d0                	mov    eax,edx
  22ff9e:	c1 e8 0d             	shr    eax,0xd
        absResult -%= dst_rep_t(srcExpBias - dstExpBias) << dstSigBits;

        const roundBits: src_rep_t = aAbs & roundMask;
  22ffa1:	89 d1                	mov    ecx,edx
  22ffa3:	81 e1 ff 1f 00 00    	and    ecx,0x1fff
        if (roundBits > halfway) {
  22ffa9:	81 f9 01 10 00 00    	cmp    ecx,0x1001
  22ffaf:	72 23                	jb     22ffd4 <__truncsfhf2+0x54>
            // Round to nearest
            absResult += 1;
  22ffb1:	05 01 40 00 00       	add    eax,0x4001
  22ffb6:	e9 83 00 00 00       	jmp    23003e <__truncsfhf2+0xbe>
        } else if (roundBits == halfway) {
            // Ties to even
            absResult += absResult & 1;
        }
    } else if (aAbs > srcInfinity) {
  22ffbb:	81 fe 01 00 80 7f    	cmp    esi,0x7f800001
  22ffc1:	72 29                	jb     22ffec <__truncsfhf2+0x6c>
        // a is NaN.
        // Conjure the result by beginning with infinity, setting the qNaN
        // bit and inserting the (truncated) trailing NaN field.
        absResult = @intCast(dst_rep_t, dstInfExp) << dstSigBits;
        absResult |= dstQNaN;
        absResult |= @intCast(dst_rep_t, ((aAbs & srcNaNCode) >> (srcSigBits - dstSigBits)) & dstNaNCode);
  22ffc3:	b8 0d 09 00 00       	mov    eax,0x90d
  22ffc8:	c4 e2 78 f7 c2       	bextr  eax,edx,eax
  22ffcd:	0d 00 7e 00 00       	or     eax,0x7e00
  22ffd2:	eb 6a                	jmp    23003e <__truncsfhf2+0xbe>
  22ffd4:	05 00 40 00 00       	add    eax,0x4000
        } else if (roundBits == halfway) {
  22ffd9:	81 f9 00 10 00 00    	cmp    ecx,0x1000
  22ffdf:	75 5d                	jne    23003e <__truncsfhf2+0xbe>
  22ffe1:	89 c1                	mov    ecx,eax
  22ffe3:	83 e1 01             	and    ecx,0x1
  22ffe6:	01 c1                	add    ecx,eax
  22ffe8:	89 c8                	mov    eax,ecx
  22ffea:	eb 52                	jmp    23003e <__truncsfhf2+0xbe>
  22ffec:	66 b8 00 7c          	mov    ax,0x7c00
    } else if (aAbs >= overflow) {
  22fff0:	81 fe ff ff 7f 47    	cmp    esi,0x477fffff
  22fff6:	77 46                	ja     23003e <__truncsfhf2+0xbe>
        absResult = @intCast(dst_rep_t, dstInfExp) << dstSigBits;
    } else {
        // a underflows on conversion to the destination type or is an exact
        // zero.  The result may be a denormal or zero.  Extract the exponent
        // to get the shift amount for the denormalization.
        const aExp = @intCast(u32, aAbs >> srcSigBits);
  22fff8:	c1 ee 17             	shr    esi,0x17
        const shift = @intCast(u32, srcExpBias - dstExpBias - aExp + 1);
  22fffb:	b9 70 00 00 00       	mov    ecx,0x70
  230000:	29 f1                	sub    ecx,esi

        const significand: src_rep_t = (aRep & srcSignificandMask) | srcMinNormal;

        // Right shift by the denormalization amount with sticky.
        if (shift > srcSigBits) {
  230002:	83 f9 16             	cmp    ecx,0x16
  230005:	76 04                	jbe    23000b <__truncsfhf2+0x8b>
  230007:	31 c0                	xor    eax,eax
  230009:	eb 33                	jmp    23003e <__truncsfhf2+0xbe>
  23000b:	89 d6                	mov    esi,edx
  23000d:	81 e6 ff ff 7f 00    	and    esi,0x7fffff
  230013:	81 ce 00 00 80 00    	or     esi,0x800000
        const shift = @intCast(u32, srcExpBias - dstExpBias - aExp + 1);
  230019:	83 c1 01             	add    ecx,0x1
            absResult = 0;
        } else {
            const sticky: src_rep_t = significand << @intCast(SrcShift, srcBits - shift);
            const denormalizedSignificand: src_rep_t = significand >> @intCast(SrcShift, shift) | sticky;
  23001c:	d3 ce                	ror    esi,cl
            absResult = @intCast(dst_rep_t, denormalizedSignificand >> (srcSigBits - dstSigBits));
  23001e:	89 f0                	mov    eax,esi
  230020:	c1 e8 0d             	shr    eax,0xd
            const roundBits: src_rep_t = denormalizedSignificand & roundMask;
  230023:	81 e6 ff 1f 00 00    	and    esi,0x1fff
            if (roundBits > halfway) {
  230029:	81 fe 01 10 00 00    	cmp    esi,0x1001
  23002f:	72 05                	jb     230036 <__truncsfhf2+0xb6>
                // Round to nearest
                absResult += 1;
  230031:	83 c0 01             	add    eax,0x1
  230034:	eb 08                	jmp    23003e <__truncsfhf2+0xbe>
            } else if (roundBits == halfway) {
  230036:	81 fe 00 10 00 00    	cmp    esi,0x1000
  23003c:	74 a3                	je     22ffe1 <__truncsfhf2+0x61>
                absResult += absResult & 1;
            }
        }
    }

    const result: dst_rep_t align(@alignOf(dst_t)) = absResult | @truncate(dst_rep_t, sign >> @intCast(SrcShift, srcBits - dstBits));
  23003e:	c1 ea 10             	shr    edx,0x10
  230041:	81 e2 00 80 00 00    	and    edx,0x8000
  230047:	09 d0                	or     eax,edx
    return @bitCast(u16, truncXfYf2(f16, f32, a));
  230049:	c3                   	ret    
  23004a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000230050 <__unordtf2>:
}

pub extern fn __unordtf2(a: f128, b: f128) c_int {
    @setRuntimeSafety(is_test);

    const aAbs = @bitCast(rep_t, a) & absMask;
  230050:	0f 29 44 24 e8       	movaps XMMWORD PTR [rsp-0x18],xmm0
  230055:	b0 3f                	mov    al,0x3f
  230057:	c4 e2 f8 f5 4c 24 f0 	bzhi   rcx,QWORD PTR [rsp-0x10],rax
    const bAbs = @bitCast(rep_t, b) & absMask;
  23005e:	0f 29 4c 24 d8       	movaps XMMWORD PTR [rsp-0x28],xmm1
  230063:	c4 e2 f8 f5 44 24 e0 	bzhi   rax,QWORD PTR [rsp-0x20],rax
    return @boolToInt(aAbs > infRep or bAbs > infRep);
  23006a:	31 d2                	xor    edx,edx
  23006c:	48 3b 54 24 e8       	cmp    rdx,QWORD PTR [rsp-0x18]
  230071:	48 be 00 00 00 00 00 	movabs rsi,0x7fff000000000000
  230078:	00 ff 7f 
  23007b:	48 89 f7             	mov    rdi,rsi
  23007e:	48 19 cf             	sbb    rdi,rcx
  230081:	0f 92 c1             	setb   cl
  230084:	48 3b 54 24 d8       	cmp    rdx,QWORD PTR [rsp-0x28]
  230089:	48 19 c6             	sbb    rsi,rax
  23008c:	0f 92 c0             	setb   al
  23008f:	08 c8                	or     al,cl
  230091:	0f b6 c0             	movzx  eax,al
  230094:	c3                   	ret    
  230095:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  23009c:	00 00 00 00 

00000000002300a0 <__floattitf>:
const LDBL_MANT_DIG = 113;

pub extern fn __floattitf(arg: i128) f128 {
    @setRuntimeSafety(is_test);

    if (arg == 0)
  2300a0:	48 89 f8             	mov    rax,rdi
  2300a3:	48 09 f0             	or     rax,rsi
  2300a6:	0f 84 ba 00 00 00    	je     230166 <__floattitf+0xc6>
        return 0.0;

    var ai = arg;
    const N: u32 = 128;
    const si = ai >> @intCast(u7, (N - 1));
  2300ac:	41 57                	push   r15
  2300ae:	41 56                	push   r14
  2300b0:	53                   	push   rbx
  2300b1:	48 89 f0             	mov    rax,rsi
  2300b4:	48 c1 f8 3f          	sar    rax,0x3f
    ai = ((ai ^ si) -% si);
  2300b8:	48 89 c2             	mov    rdx,rax
  2300bb:	48 31 f2             	xor    rdx,rsi
  2300be:	48 31 c7             	xor    rdi,rax
  2300c1:	48 29 c7             	sub    rdi,rax
  2300c4:	48 19 c2             	sbb    rdx,rax
    var a = @bitCast(u128, ai);

    const sd = @bitCast(i32, N - @clz(a)); // number of significant digits
  2300c7:	f3 48 0f bd c2       	lzcnt  rax,rdx
  2300cc:	f3 48 0f bd cf       	lzcnt  rcx,rdi
  2300d1:	83 c1 40             	add    ecx,0x40
  2300d4:	48 85 d2             	test   rdx,rdx
  2300d7:	0f 45 c8             	cmovne ecx,eax
  2300da:	41 b9 80 00 00 00    	mov    r9d,0x80
  2300e0:	41 29 c9             	sub    r9d,ecx
    var e: i32 = sd - 1; // exponent
  2300e3:	41 ba 7f 00 00 00    	mov    r10d,0x7f
  2300e9:	41 29 ca             	sub    r10d,ecx
    if (sd > LDBL_MANT_DIG) {
  2300ec:	41 83 f9 72          	cmp    r9d,0x72
  2300f0:	7c 7c                	jl     23016e <__floattitf+0xce>
        //                                                12345678901234567890123456
        //  1 = msb 1 bit
        //  P = bit LDBL_MANT_DIG-1 bits to the right of 1
        //  Q = bit LDBL_MANT_DIG bits to the right of 1
        //  R = "or" of all bits to the right of Q
        switch (sd) {
  2300f2:	0f 84 99 00 00 00    	je     230191 <__floattitf+0xf1>
  2300f8:	41 83 f9 73          	cmp    r9d,0x73
  2300fc:	0f 84 97 00 00 00    	je     230199 <__floattitf+0xf9>
            LDBL_MANT_DIG + 1 => {
                a <<= 1;
            },
            LDBL_MANT_DIG + 2 => {},
            else => {
                const shift1_amt = @intCast(i32, sd - (LDBL_MANT_DIG + 2));
  230102:	41 8d 49 0d          	lea    ecx,[r9+0xd]
                const shift1_amt_u7 = @intCast(u7, shift1_amt);

                const shift2_amt = @intCast(i32, N + (LDBL_MANT_DIG + 2)) - sd;
  230106:	41 b8 73 00 00 00    	mov    r8d,0x73
                const shift2_amt_u7 = @intCast(u7, shift2_amt);

                a = (a >> shift1_amt_u7) | @boolToInt((a & (@intCast(u128, @maxValue(u128)) >> shift2_amt_u7)) != 0);
  23010c:	83 e1 7f             	and    ecx,0x7f
  23010f:	49 89 ff             	mov    r15,rdi
  230112:	49 0f ad d7          	shrd   r15,rdx,cl
                const shift2_amt = @intCast(i32, N + (LDBL_MANT_DIG + 2)) - sd;
  230116:	45 29 c8             	sub    r8d,r9d
                a = (a >> shift1_amt_u7) | @boolToInt((a & (@intCast(u128, @maxValue(u128)) >> shift2_amt_u7)) != 0);
  230119:	c4 62 f3 f7 da       	shrx   r11,rdx,rcx
  23011e:	45 31 f6             	xor    r14d,r14d
  230121:	f6 c1 40             	test   cl,0x40
  230124:	4d 0f 45 fb          	cmovne r15,r11
  230128:	4d 0f 45 de          	cmovne r11,r14
  23012c:	41 83 e0 7f          	and    r8d,0x7f
  230130:	48 c7 c3 ff ff ff ff 	mov    rbx,0xffffffffffffffff
  230137:	c4 e2 bb f7 c3       	shrx   rax,rbx,r8
  23013c:	44 89 c1             	mov    ecx,r8d
  23013f:	48 0f ad db          	shrd   rbx,rbx,cl
  230143:	41 f6 c0 40          	test   r8b,0x40
  230147:	48 0f 45 d8          	cmovne rbx,rax
  23014b:	49 0f 45 c6          	cmovne rax,r14
  23014f:	48 21 fb             	and    rbx,rdi
  230152:	48 21 d0             	and    rax,rdx
  230155:	31 ff                	xor    edi,edi
  230157:	48 09 d8             	or     rax,rbx
  23015a:	40 0f 95 c7          	setne  dil
  23015e:	4c 09 ff             	or     rdi,r15
  230161:	4c 89 da             	mov    rdx,r11
  230164:	eb 33                	jmp    230199 <__floattitf+0xf9>
        return 0.0;
  230166:	0f 28 05 53 8c fd ff 	movaps xmm0,XMMWORD PTR [rip+0xfffffffffffd8c53]        # 208dc0 <__unnamed_5>
  23016d:	c3                   	ret    
            a >>= 1;
            e += 1;
        }
        // a is now rounded to LDBL_MANT_DIG bits
    } else {
        a <<= @intCast(u7, LDBL_MANT_DIG - sd);
  23016e:	b9 71 00 00 00       	mov    ecx,0x71
  230173:	44 29 c9             	sub    ecx,r9d
  230176:	83 e1 7f             	and    ecx,0x7f
  230179:	48 0f a5 fa          	shld   rdx,rdi,cl
  23017d:	c4 e2 f1 f7 ff       	shlx   rdi,rdi,rcx
  230182:	31 c0                	xor    eax,eax
  230184:	f6 c1 40             	test   cl,0x40
  230187:	48 0f 45 d7          	cmovne rdx,rdi
  23018b:	48 0f 44 c7          	cmove  rax,rdi
  23018f:	eb 3b                	jmp    2301cc <__floattitf+0x12c>
                a <<= 1;
  230191:	48 0f a4 fa 01       	shld   rdx,rdi,0x1
  230196:	48 01 ff             	add    rdi,rdi
        a |= @boolToInt((a & 4) != 0); // Or P into R
  230199:	b8 02 01 00 00       	mov    eax,0x102
  23019e:	c4 e2 78 f7 c7       	bextr  eax,edi,eax
  2301a3:	48 09 f8             	or     rax,rdi
        a += 1; // round - this step may add a significant bit
  2301a6:	48 83 c0 01          	add    rax,0x1
  2301aa:	48 83 d2 00          	adc    rdx,0x0
        if ((a & (u128(1) << LDBL_MANT_DIG)) != 0) {
  2301ae:	48 0f ba e2 33       	bt     rdx,0x33
  2301b3:	72 0b                	jb     2301c0 <__floattitf+0x120>
  2301b5:	48 0f ac d0 02       	shrd   rax,rdx,0x2
  2301ba:	48 c1 ea 02          	shr    rdx,0x2
  2301be:	eb 0c                	jmp    2301cc <__floattitf+0x12c>
            a >>= 1;
  2301c0:	48 0f ac d0 03       	shrd   rax,rdx,0x3
  2301c5:	48 c1 ea 03          	shr    rdx,0x3
  2301c9:	45 89 ca             	mov    r10d,r9d
        // a is now rounded to LDBL_MANT_DIG bits
    }

    const s = @bitCast(u128, arg) >> (128 - 64);
    const high: u128 = (@intCast(u64, s) & 0x8000000000000000) | // sign
  2301cc:	48 b9 00 00 00 00 00 	movabs rcx,0x8000000000000000
  2301d3:	00 00 80 
  2301d6:	48 21 ce             	and    rsi,rcx
        (@intCast(u64, (e + 16383)) << 48) | // exponent
  2301d9:	41 81 c2 ff 3f 00 00 	add    r10d,0x3fff
  2301e0:	49 c1 e2 30          	shl    r10,0x30
    const high: u128 = (@intCast(u64, s) & 0x8000000000000000) | // sign
  2301e4:	49 09 f2             	or     r10,rsi
        (@truncate(u64, a >> 64) & 0x0000ffffffffffff); // mantissa-high
  2301e7:	b1 30                	mov    cl,0x30
  2301e9:	c4 e2 f0 f5 ca       	bzhi   rcx,rdx,rcx
    const low = @truncate(u64, a); // mantissa-low

    return @bitCast(f128, low | (high << 64));
  2301ee:	48 89 44 24 f0       	mov    QWORD PTR [rsp-0x10],rax
        (@intCast(u64, (e + 16383)) << 48) | // exponent
  2301f3:	4c 09 d1             	or     rcx,r10
    return @bitCast(f128, low | (high << 64));
  2301f6:	48 89 4c 24 f8       	mov    QWORD PTR [rsp-0x8],rcx
  2301fb:	0f 28 44 24 f0       	movaps xmm0,XMMWORD PTR [rsp-0x10]
  230200:	5b                   	pop    rbx
  230201:	41 5e                	pop    r14
  230203:	41 5f                	pop    r15
  230205:	c3                   	ret    
  230206:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  23020d:	00 00 00 

0000000000230210 <__floattidf>:
const DBL_MANT_DIG = 53;

pub extern fn __floattidf(arg: i128) f64 {
    @setRuntimeSafety(is_test);

    if (arg == 0)
  230210:	48 89 f8             	mov    rax,rdi
  230213:	48 09 f0             	or     rax,rsi
  230216:	0f 84 b8 00 00 00    	je     2302d4 <__floattidf+0xc4>
        return 0.0;

    var ai = arg;
    const N: u32 = 128;
    const si = ai >> @intCast(u7, (N - 1));
  23021c:	41 57                	push   r15
  23021e:	41 56                	push   r14
  230220:	53                   	push   rbx
  230221:	48 89 f0             	mov    rax,rsi
  230224:	48 c1 f8 3f          	sar    rax,0x3f
    ai = ((ai ^ si) -% si);
  230228:	48 89 c2             	mov    rdx,rax
  23022b:	48 31 f2             	xor    rdx,rsi
  23022e:	48 31 c7             	xor    rdi,rax
  230231:	48 29 c7             	sub    rdi,rax
  230234:	48 19 c2             	sbb    rdx,rax
    var a = @bitCast(u128, ai);

    const sd = @bitCast(i32, N - @clz(a)); // number of significant digits
  230237:	f3 48 0f bd c2       	lzcnt  rax,rdx
  23023c:	f3 48 0f bd cf       	lzcnt  rcx,rdi
  230241:	83 c1 40             	add    ecx,0x40
  230244:	48 85 d2             	test   rdx,rdx
  230247:	0f 45 c8             	cmovne ecx,eax
  23024a:	41 b9 80 00 00 00    	mov    r9d,0x80
  230250:	41 29 c9             	sub    r9d,ecx
    var e: i32 = sd - 1; // exponent
  230253:	b8 7f 00 00 00       	mov    eax,0x7f
  230258:	29 c8                	sub    eax,ecx
    if (sd > DBL_MANT_DIG) {
  23025a:	41 83 f9 36          	cmp    r9d,0x36
  23025e:	7c 79                	jl     2302d9 <__floattidf+0xc9>
        //                                                12345678901234567890123456
        //  1 = msb 1 bit
        //  P = bit DBL_MANT_DIG-1 bits to the right of 1
        //  Q = bit DBL_MANT_DIG bits to the right of 1
        //  R = "or" of all bits to the right of Q
        switch (sd) {
  230260:	0f 84 9b 00 00 00    	je     230301 <__floattidf+0xf1>
  230266:	41 83 f9 37          	cmp    r9d,0x37
  23026a:	0f 84 99 00 00 00    	je     230309 <__floattidf+0xf9>
            DBL_MANT_DIG + 1 => {
                a <<= 1;
            },
            DBL_MANT_DIG + 2 => {},
            else => {
                const shift1_amt = @intCast(i32, sd - (DBL_MANT_DIG + 2));
  230270:	41 8d 49 49          	lea    ecx,[r9+0x49]
                const shift1_amt_u7 = @intCast(u7, shift1_amt);

                const shift2_amt = @intCast(i32, N + (DBL_MANT_DIG + 2)) - sd;
  230274:	41 b8 37 00 00 00    	mov    r8d,0x37
                const shift2_amt_u7 = @intCast(u7, shift2_amt);

                a = (a >> shift1_amt_u7) | @boolToInt((a & (@intCast(u128, @maxValue(u128)) >> shift2_amt_u7)) != 0);
  23027a:	83 e1 7f             	and    ecx,0x7f
  23027d:	49 89 fa             	mov    r10,rdi
  230280:	49 0f ad d2          	shrd   r10,rdx,cl
                const shift2_amt = @intCast(i32, N + (DBL_MANT_DIG + 2)) - sd;
  230284:	45 29 c8             	sub    r8d,r9d
                a = (a >> shift1_amt_u7) | @boolToInt((a & (@intCast(u128, @maxValue(u128)) >> shift2_amt_u7)) != 0);
  230287:	c4 62 f3 f7 da       	shrx   r11,rdx,rcx
  23028c:	45 31 f6             	xor    r14d,r14d
  23028f:	f6 c1 40             	test   cl,0x40
  230292:	4d 0f 45 d3          	cmovne r10,r11
  230296:	4d 0f 45 de          	cmovne r11,r14
  23029a:	41 83 e0 7f          	and    r8d,0x7f
  23029e:	48 c7 c3 ff ff ff ff 	mov    rbx,0xffffffffffffffff
  2302a5:	c4 62 bb f7 fb       	shrx   r15,rbx,r8
  2302aa:	44 89 c1             	mov    ecx,r8d
  2302ad:	48 0f ad db          	shrd   rbx,rbx,cl
  2302b1:	41 f6 c0 40          	test   r8b,0x40
  2302b5:	49 0f 45 df          	cmovne rbx,r15
  2302b9:	4d 0f 45 fe          	cmovne r15,r14
  2302bd:	48 21 fb             	and    rbx,rdi
  2302c0:	49 21 d7             	and    r15,rdx
  2302c3:	31 ff                	xor    edi,edi
  2302c5:	49 09 df             	or     r15,rbx
  2302c8:	40 0f 95 c7          	setne  dil
  2302cc:	4c 09 d7             	or     rdi,r10
  2302cf:	4c 89 da             	mov    rdx,r11
  2302d2:	eb 35                	jmp    230309 <__floattidf+0xf9>
        return 0.0;
  2302d4:	c5 f8 57 c0          	vxorps xmm0,xmm0,xmm0
  2302d8:	c3                   	ret    
            a >>= 1;
            e += 1;
        }
        // a is now rounded to DBL_MANT_DIG bits
    } else {
        a <<= @intCast(u7, DBL_MANT_DIG - sd);
  2302d9:	b9 35 00 00 00       	mov    ecx,0x35
  2302de:	44 29 c9             	sub    ecx,r9d
  2302e1:	83 e1 7f             	and    ecx,0x7f
  2302e4:	48 0f a5 fa          	shld   rdx,rdi,cl
  2302e8:	c4 e2 f1 f7 df       	shlx   rbx,rdi,rcx
  2302ed:	31 ff                	xor    edi,edi
  2302ef:	f6 c1 40             	test   cl,0x40
  2302f2:	48 0f 45 d3          	cmovne rdx,rbx
  2302f6:	48 0f 44 fb          	cmove  rdi,rbx
    if (sd > DBL_MANT_DIG) {
  2302fa:	48 0f a4 fa 20       	shld   rdx,rdi,0x20
  2302ff:	eb 40                	jmp    230341 <__floattidf+0x131>
                a <<= 1;
  230301:	48 0f a4 fa 01       	shld   rdx,rdi,0x1
  230306:	48 01 ff             	add    rdi,rdi
        a |= @boolToInt((a & 4) != 0); // Or P into R
  230309:	b9 02 01 00 00       	mov    ecx,0x102
  23030e:	c4 e2 70 f7 cf       	bextr  ecx,edi,ecx
  230313:	48 09 f9             	or     rcx,rdi
        a += 1; // round - this step may add a significant bit
  230316:	48 83 c1 01          	add    rcx,0x1
  23031a:	48 83 d2 00          	adc    rdx,0x0
            a >>= 1;
  23031e:	48 89 d7             	mov    rdi,rdx
        if ((a & (u128(1) << DBL_MANT_DIG)) != 0) {
  230321:	48 0f ba e1 37       	bt     rcx,0x37
  230326:	72 0c                	jb     230334 <__floattidf+0x124>
  230328:	48 0f a4 cf 3e       	shld   rdi,rcx,0x3e
  23032d:	48 0f a4 ca 1e       	shld   rdx,rcx,0x1e
  230332:	eb 0d                	jmp    230341 <__floattidf+0x131>
            a >>= 1;
  230334:	48 0f a4 cf 3d       	shld   rdi,rcx,0x3d
        if ((a & (u128(1) << DBL_MANT_DIG)) != 0) {
  230339:	48 0f a4 ca 1d       	shld   rdx,rcx,0x1d
  23033e:	44 89 c8             	mov    eax,r9d
        // a is now rounded to DBL_MANT_DIG bits
    }

    const s = @bitCast(u128, arg) >> (128 - 32);
  230341:	48 c1 ee 20          	shr    rsi,0x20
    const high: u64 = (@intCast(u64, s) & 0x80000000) | // sign
  230345:	81 e6 00 00 00 80    	and    esi,0x80000000
        (@intCast(u32, (e + 1023)) << 20) | // exponent
  23034b:	c1 e0 14             	shl    eax,0x14
  23034e:	05 00 00 f0 3f       	add    eax,0x3ff00000
    const high: u64 = (@intCast(u64, s) & 0x80000000) | // sign
  230353:	09 f0                	or     eax,esi
        (@truncate(u32, a >> 32) & 0x000fffff); // mantissa-high
  230355:	81 e2 ff ff 0f 00    	and    edx,0xfffff
        (@intCast(u32, (e + 1023)) << 20) | // exponent
  23035b:	09 c2                	or     edx,eax
    const low: u64 = @truncate(u32, a); // mantissa-low
  23035d:	89 f8                	mov    eax,edi

    return @bitCast(f64, low | (high << 32));
  23035f:	48 c1 e2 20          	shl    rdx,0x20
  230363:	48 09 c2             	or     rdx,rax
  230366:	c4 e1 f9 6e c2       	vmovq  xmm0,rdx
  23036b:	5b                   	pop    rbx
  23036c:	41 5e                	pop    r14
  23036e:	41 5f                	pop    r15
  230370:	c3                   	ret    
  230371:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  230378:	0f 1f 84 00 00 00 00 
  23037f:	00 

0000000000230380 <__floattisf>:
const FLT_MANT_DIG = 24;

pub extern fn __floattisf(arg: i128) f32 {
    @setRuntimeSafety(is_test);

    if (arg == 0)
  230380:	48 89 f8             	mov    rax,rdi
  230383:	48 09 f0             	or     rax,rsi
  230386:	0f 84 b2 00 00 00    	je     23043e <__floattisf+0xbe>
        return 0.0;

    var ai = arg;
    const N: u32 = 128;
    const si = ai >> @intCast(u7, (N - 1));
  23038c:	48 89 f1             	mov    rcx,rsi
  23038f:	48 c1 f9 3f          	sar    rcx,0x3f
    ai = ((ai ^ si) -% si);
  230393:	48 89 c8             	mov    rax,rcx
  230396:	48 31 f0             	xor    rax,rsi
  230399:	48 31 cf             	xor    rdi,rcx
  23039c:	48 29 cf             	sub    rdi,rcx
  23039f:	48 19 c8             	sbb    rax,rcx
    var a = @bitCast(u128, ai);

    const sd = @bitCast(i32, N - @clz(a)); // number of significant digits
  2303a2:	f3 48 0f bd d0       	lzcnt  rdx,rax
  2303a7:	f3 48 0f bd cf       	lzcnt  rcx,rdi
  2303ac:	83 c1 40             	add    ecx,0x40
  2303af:	48 85 c0             	test   rax,rax
  2303b2:	0f 45 ca             	cmovne ecx,edx
  2303b5:	41 b9 80 00 00 00    	mov    r9d,0x80
  2303bb:	41 29 c9             	sub    r9d,ecx
    var e: i32 = sd - 1; // exponent
  2303be:	ba 7f 00 00 00       	mov    edx,0x7f
  2303c3:	29 ca                	sub    edx,ecx

    if (sd > FLT_MANT_DIG) {
  2303c5:	41 83 f9 19          	cmp    r9d,0x19
  2303c9:	7c 78                	jl     230443 <__floattisf+0xc3>
        //                                                12345678901234567890123456
        //  1 = msb 1 bit
        //  P = bit FLT_MANT_DIG-1 bits to the right of 1
        //  Q = bit FLT_MANT_DIG bits to the right of 1
        //  R = "or" of all bits to the right of Q
        switch (sd) {
  2303cb:	0f 84 8d 00 00 00    	je     23045e <__floattisf+0xde>
  2303d1:	41 83 f9 1a          	cmp    r9d,0x1a
  2303d5:	0f 84 86 00 00 00    	je     230461 <__floattisf+0xe1>
            FLT_MANT_DIG + 1 => {
                a <<= 1;
            },
            FLT_MANT_DIG + 2 => {},
            else => {
                const shift1_amt = @intCast(i32, sd - (FLT_MANT_DIG + 2));
  2303db:	41 56                	push   r14
  2303dd:	53                   	push   rbx
  2303de:	41 8d 49 66          	lea    ecx,[r9+0x66]
                const shift1_amt_u7 = @intCast(u7, shift1_amt);

                const shift2_amt = @intCast(i32, N + (FLT_MANT_DIG + 2)) - sd;
                const shift2_amt_u7 = @intCast(u7, shift2_amt);

                a = (a >> shift1_amt_u7) | @boolToInt((a & (@intCast(u128, @maxValue(u128)) >> shift2_amt_u7)) != 0);
  2303e2:	83 e1 7f             	and    ecx,0x7f
  2303e5:	49 89 fa             	mov    r10,rdi
  2303e8:	49 0f ad c2          	shrd   r10,rax,cl
                const shift2_amt = @intCast(i32, N + (FLT_MANT_DIG + 2)) - sd;
  2303ec:	41 b8 1a 00 00 00    	mov    r8d,0x1a
  2303f2:	45 29 c8             	sub    r8d,r9d
                a = (a >> shift1_amt_u7) | @boolToInt((a & (@intCast(u128, @maxValue(u128)) >> shift2_amt_u7)) != 0);
  2303f5:	c4 62 f3 f7 d8       	shrx   r11,rax,rcx
  2303fa:	45 31 f6             	xor    r14d,r14d
  2303fd:	f6 c1 40             	test   cl,0x40
  230400:	4d 0f 44 da          	cmove  r11,r10
  230404:	41 83 e0 7f          	and    r8d,0x7f
  230408:	48 c7 c3 ff ff ff ff 	mov    rbx,0xffffffffffffffff
  23040f:	c4 62 bb f7 d3       	shrx   r10,rbx,r8
  230414:	44 89 c1             	mov    ecx,r8d
  230417:	48 0f ad db          	shrd   rbx,rbx,cl
  23041b:	41 f6 c0 40          	test   r8b,0x40
  23041f:	49 0f 45 da          	cmovne rbx,r10
  230423:	4d 0f 44 f2          	cmove  r14,r10
  230427:	48 21 fb             	and    rbx,rdi
  23042a:	49 21 c6             	and    r14,rax
  23042d:	31 ff                	xor    edi,edi
  23042f:	49 09 de             	or     r14,rbx
  230432:	40 0f 95 c7          	setne  dil
  230436:	4c 09 df             	or     rdi,r11
        switch (sd) {
  230439:	5b                   	pop    rbx
  23043a:	41 5e                	pop    r14
  23043c:	eb 23                	jmp    230461 <__floattisf+0xe1>
        return 0.0;
  23043e:	c5 f8 57 c0          	vxorps xmm0,xmm0,xmm0
  230442:	c3                   	ret    
            a >>= 1;
            e += 1;
        }
        // a is now rounded to FLT_MANT_DIG bits
    } else {
        a <<= @intCast(u7, FLT_MANT_DIG - sd);
  230443:	b9 18 00 00 00       	mov    ecx,0x18
  230448:	44 29 c9             	sub    ecx,r9d
  23044b:	83 e1 7f             	and    ecx,0x7f
  23044e:	c4 e2 f1 f7 ff       	shlx   rdi,rdi,rcx
  230453:	31 c0                	xor    eax,eax
  230455:	f6 c1 40             	test   cl,0x40
  230458:	48 0f 44 c7          	cmove  rax,rdi
  23045c:	eb 28                	jmp    230486 <__floattisf+0x106>
                a <<= 1;
  23045e:	48 01 ff             	add    rdi,rdi
        a |= @boolToInt((a & 4) != 0); // Or P into R
  230461:	b8 02 01 00 00       	mov    eax,0x102
  230466:	c4 e2 78 f7 c7       	bextr  eax,edi,eax
  23046b:	48 09 f8             	or     rax,rdi
        a += 1; // round - this step may add a significant bit
  23046e:	48 83 c0 01          	add    rax,0x1
        if ((a & (u128(1) << FLT_MANT_DIG)) != 0) {
  230472:	a9 00 00 00 04       	test   eax,0x4000000
  230477:	75 06                	jne    23047f <__floattisf+0xff>
  230479:	48 c1 e8 02          	shr    rax,0x2
  23047d:	eb 07                	jmp    230486 <__floattisf+0x106>
            a >>= 1;
  23047f:	48 c1 e8 03          	shr    rax,0x3
  230483:	44 89 ca             	mov    edx,r9d
        // a is now rounded to FLT_MANT_DIG bits
    }

    const s = @bitCast(u128, arg) >> (128 - 32);
  230486:	48 c1 ee 20          	shr    rsi,0x20
    const r = (@intCast(u32, s) & 0x80000000) | // sign
  23048a:	81 e6 00 00 00 80    	and    esi,0x80000000
        (@intCast(u32, (e + 127)) << 23) | // exponent
  230490:	c1 e2 17             	shl    edx,0x17
  230493:	81 c2 00 00 80 3f    	add    edx,0x3f800000
    const r = (@intCast(u32, s) & 0x80000000) | // sign
  230499:	09 f2                	or     edx,esi
        (@truncate(u32, a) & 0x007fffff); // mantissa-high
  23049b:	25 ff ff 7f 00       	and    eax,0x7fffff
        (@intCast(u32, (e + 127)) << 23) | // exponent
  2304a0:	09 d0                	or     eax,edx

    return @bitCast(f32, r);
  2304a2:	c5 f9 6e c0          	vmovd  xmm0,eax
  2304a6:	c3                   	ret    
  2304a7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  2304ae:	00 00 

00000000002304b0 <__floatunditf>:
const std = @import("std");

pub extern fn __floatunditf(a: u128) f128 {
    @setRuntimeSafety(is_test);

    if (a == 0) {
  2304b0:	48 89 f8             	mov    rax,rdi
  2304b3:	48 09 f0             	or     rax,rsi
  2304b6:	74 0f                	je     2304c7 <__floatunditf+0x17>
    const mantissa_bits = std.math.floatMantissaBits(f128);
    const exponent_bits = std.math.floatExponentBits(f128);
    const exponent_bias = (1 << (exponent_bits - 1)) - 1;
    const implicit_bit = 1 << mantissa_bits;

    const exp = (u128.bit_count - 1) - @clz(a);
  2304b8:	48 85 f6             	test   rsi,rsi
  2304bb:	75 12                	jne    2304cf <__floatunditf+0x1f>
  2304bd:	f3 48 0f bd c7       	lzcnt  rax,rdi
  2304c2:	83 c0 40             	add    eax,0x40
  2304c5:	eb 0d                	jmp    2304d4 <__floatunditf+0x24>
        return 0;
  2304c7:	0f 28 05 f2 88 fd ff 	movaps xmm0,XMMWORD PTR [rip+0xfffffffffffd88f2]        # 208dc0 <__unnamed_5>
  2304ce:	c3                   	ret    
  2304cf:	f3 48 0f bd c6       	lzcnt  rax,rsi
  2304d4:	b2 7f                	mov    dl,0x7f
    const exp = (u128.bit_count - 1) - @clz(a);
  2304d6:	28 c2                	sub    dl,al
  2304d8:	b1 70                	mov    cl,0x70
    const shift = mantissa_bits - @intCast(u7, exp);
  2304da:	28 d1                	sub    cl,dl

    var result: u128 align(16) = (a << shift) ^ implicit_bit;
  2304dc:	48 0f a5 fe          	shld   rsi,rdi,cl
  2304e0:	c4 e2 f1 f7 c7       	shlx   rax,rdi,rcx
  2304e5:	31 ff                	xor    edi,edi
  2304e7:	f6 c1 40             	test   cl,0x40
  2304ea:	48 0f 45 f0          	cmovne rsi,rax
  2304ee:	48 0f 44 f8          	cmove  rdi,rax
  2304f2:	48 b8 00 00 00 00 00 	movabs rax,0x1000000000000
  2304f9:	00 01 00 
  2304fc:	48 31 f0             	xor    rax,rsi
    result += (@intCast(u128, exp) + exponent_bias) << mantissa_bits;
  2304ff:	0f b6 ca             	movzx  ecx,dl
  230502:	48 c1 e1 30          	shl    rcx,0x30
  230506:	48 01 c1             	add    rcx,rax
  230509:	48 89 7c 24 e8       	mov    QWORD PTR [rsp-0x18],rdi
  23050e:	48 b8 00 00 00 00 00 	movabs rax,0x3fff000000000000
  230515:	00 ff 3f 
  230518:	48 01 c8             	add    rax,rcx
  23051b:	48 89 44 24 f0       	mov    QWORD PTR [rsp-0x10],rax
  230520:	0f 28 44 24 e8       	movaps xmm0,XMMWORD PTR [rsp-0x18]

    return @bitCast(f128, result);
  230525:	c3                   	ret    
  230526:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  23052d:	00 00 00 

0000000000230530 <__floatunsitf>:
const std = @import("std");

pub extern fn __floatunsitf(a: u64) f128 {
    @setRuntimeSafety(is_test);

    if (a == 0) {
  230530:	48 85 ff             	test   rdi,rdi
  230533:	74 5c                	je     230591 <__floatunsitf+0x61>
    const mantissa_bits = std.math.floatMantissaBits(f128);
    const exponent_bits = std.math.floatExponentBits(f128);
    const exponent_bias = (1 << (exponent_bits - 1)) - 1;
    const implicit_bit = 1 << mantissa_bits;

    const exp = (u64.bit_count - 1) - @clz(a);
  230535:	f3 48 0f bd c7       	lzcnt  rax,rdi
  23053a:	b2 3f                	mov    dl,0x3f
  23053c:	28 c2                	sub    dl,al
  23053e:	b1 70                	mov    cl,0x70
    const shift = mantissa_bits - @intCast(u7, exp);
  230540:	28 d1                	sub    cl,dl
  230542:	31 c0                	xor    eax,eax

    // TODO(#1148): @bitCast alignment error
    var result align(16) = (@intCast(u128, a) << shift) ^ implicit_bit;
  230544:	31 f6                	xor    esi,esi
  230546:	48 0f a5 fe          	shld   rsi,rdi,cl
  23054a:	c4 e2 f1 f7 ff       	shlx   rdi,rdi,rcx
  23054f:	f6 c1 40             	test   cl,0x40
  230552:	48 0f 45 f7          	cmovne rsi,rdi
  230556:	48 0f 45 f8          	cmovne rdi,rax
  23055a:	48 b8 00 00 00 00 00 	movabs rax,0x1000000000000
  230561:	00 01 00 
  230564:	48 31 f0             	xor    rax,rsi
    result += (@intCast(u128, exp) + exponent_bias) << mantissa_bits;
  230567:	0f b6 ca             	movzx  ecx,dl
  23056a:	83 e1 7f             	and    ecx,0x7f
  23056d:	48 c1 e1 30          	shl    rcx,0x30
  230571:	48 01 c1             	add    rcx,rax
  230574:	48 89 7c 24 e8       	mov    QWORD PTR [rsp-0x18],rdi
  230579:	48 b8 00 00 00 00 00 	movabs rax,0x3fff000000000000
  230580:	00 ff 3f 
  230583:	48 01 c8             	add    rax,rcx
  230586:	48 89 44 24 f0       	mov    QWORD PTR [rsp-0x10],rax
  23058b:	0f 28 44 24 e8       	movaps xmm0,XMMWORD PTR [rsp-0x18]

    return @bitCast(f128, result);
  230590:	c3                   	ret    
        return 0;
  230591:	0f 28 05 28 88 fd ff 	movaps xmm0,XMMWORD PTR [rip+0xfffffffffffd8828]        # 208dc0 <__unnamed_5>
  230598:	c3                   	ret    
  230599:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

00000000002305a0 <__floatuntitf>:
const LDBL_MANT_DIG = 113;

pub extern fn __floatuntitf(arg: u128) f128 {
    @setRuntimeSafety(is_test);

    if (arg == 0)
  2305a0:	48 89 f8             	mov    rax,rdi
  2305a3:	48 09 f0             	or     rax,rsi
  2305a6:	0f 84 a0 00 00 00    	je     23064c <__floatuntitf+0xac>
        return 0.0;

    var a = arg;
    const N: u32 = @sizeOf(u128) * 8;
    const sd = @bitCast(i32, N - @clz(a)); // number of significant digits
  2305ac:	41 56                	push   r14
  2305ae:	53                   	push   rbx
  2305af:	f3 48 0f bd c6       	lzcnt  rax,rsi
  2305b4:	f3 48 0f bd cf       	lzcnt  rcx,rdi
  2305b9:	83 c1 40             	add    ecx,0x40
  2305bc:	48 85 f6             	test   rsi,rsi
  2305bf:	0f 45 c8             	cmovne ecx,eax
  2305c2:	41 b9 80 00 00 00    	mov    r9d,0x80
  2305c8:	41 29 c9             	sub    r9d,ecx
    var e: i32 = sd - 1; // exponent
  2305cb:	ba 7f 00 00 00       	mov    edx,0x7f
  2305d0:	29 ca                	sub    edx,ecx
    if (sd > LDBL_MANT_DIG) {
  2305d2:	41 83 f9 72          	cmp    r9d,0x72
  2305d6:	7c 7c                	jl     230654 <__floatuntitf+0xb4>
        //                                                12345678901234567890123456
        //  1 = msb 1 bit
        //  P = bit LDBL_MANT_DIG-1 bits to the right of 1
        //  Q = bit LDBL_MANT_DIG bits to the right of 1
        //  R = "or" of all bits to the right of Q
        switch (sd) {
  2305d8:	0f 84 99 00 00 00    	je     230677 <__floatuntitf+0xd7>
  2305de:	41 83 f9 73          	cmp    r9d,0x73
  2305e2:	0f 84 97 00 00 00    	je     23067f <__floatuntitf+0xdf>
            LDBL_MANT_DIG + 1 => {
                a <<= 1;
            },
            LDBL_MANT_DIG + 2 => {},
            else => {
                const shift_amt = @bitCast(i32, N + (LDBL_MANT_DIG + 2)) - sd;
  2305e8:	41 b8 73 00 00 00    	mov    r8d,0x73
                const shift_amt_u7 = @intCast(u7, shift_amt);
                a = (a >> @intCast(u7, sd - (LDBL_MANT_DIG + 2))) |
  2305ee:	41 8d 49 0d          	lea    ecx,[r9+0xd]
  2305f2:	83 e1 7f             	and    ecx,0x7f
  2305f5:	49 89 fe             	mov    r14,rdi
  2305f8:	49 0f ad f6          	shrd   r14,rsi,cl
                const shift_amt = @bitCast(i32, N + (LDBL_MANT_DIG + 2)) - sd;
  2305fc:	45 29 c8             	sub    r8d,r9d
                a = (a >> @intCast(u7, sd - (LDBL_MANT_DIG + 2))) |
  2305ff:	c4 62 f3 f7 d6       	shrx   r10,rsi,rcx
  230604:	45 31 db             	xor    r11d,r11d
  230607:	f6 c1 40             	test   cl,0x40
  23060a:	4d 0f 45 f2          	cmovne r14,r10
  23060e:	4d 0f 45 d3          	cmovne r10,r11
                    @boolToInt((a & (u128(@maxValue(u128)) >> shift_amt_u7)) != 0);
  230612:	41 83 e0 7f          	and    r8d,0x7f
  230616:	48 c7 c3 ff ff ff ff 	mov    rbx,0xffffffffffffffff
  23061d:	c4 e2 bb f7 c3       	shrx   rax,rbx,r8
  230622:	44 89 c1             	mov    ecx,r8d
  230625:	48 0f ad db          	shrd   rbx,rbx,cl
  230629:	41 f6 c0 40          	test   r8b,0x40
  23062d:	48 0f 45 d8          	cmovne rbx,rax
  230631:	49 0f 45 c3          	cmovne rax,r11
  230635:	48 21 fb             	and    rbx,rdi
  230638:	48 21 f0             	and    rax,rsi
  23063b:	31 ff                	xor    edi,edi
  23063d:	48 09 d8             	or     rax,rbx
  230640:	40 0f 95 c7          	setne  dil
                a = (a >> @intCast(u7, sd - (LDBL_MANT_DIG + 2))) |
  230644:	4c 09 f7             	or     rdi,r14
  230647:	4c 89 d6             	mov    rsi,r10
  23064a:	eb 33                	jmp    23067f <__floatuntitf+0xdf>
        return 0.0;
  23064c:	0f 28 05 6d 87 fd ff 	movaps xmm0,XMMWORD PTR [rip+0xfffffffffffd876d]        # 208dc0 <__unnamed_5>
  230653:	c3                   	ret    
            a >>= 1;
            e += 1;
        }
        // a is now rounded to LDBL_MANT_DIG bits
    } else {
        a <<= @intCast(u7, LDBL_MANT_DIG - sd);
  230654:	b9 71 00 00 00       	mov    ecx,0x71
  230659:	44 29 c9             	sub    ecx,r9d
  23065c:	83 e1 7f             	and    ecx,0x7f
  23065f:	48 0f a5 fe          	shld   rsi,rdi,cl
  230663:	c4 e2 f1 f7 ff       	shlx   rdi,rdi,rcx
  230668:	31 c0                	xor    eax,eax
  23066a:	f6 c1 40             	test   cl,0x40
  23066d:	48 0f 45 f7          	cmovne rsi,rdi
  230671:	48 0f 44 c7          	cmove  rax,rdi
  230675:	eb 3b                	jmp    2306b2 <__floatuntitf+0x112>
                a <<= 1;
  230677:	48 0f a4 fe 01       	shld   rsi,rdi,0x1
  23067c:	48 01 ff             	add    rdi,rdi
        a |= @boolToInt((a & 4) != 0); // Or P into R
  23067f:	b8 02 01 00 00       	mov    eax,0x102
  230684:	c4 e2 78 f7 c7       	bextr  eax,edi,eax
  230689:	48 09 f8             	or     rax,rdi
        a += 1; // round - this step may add a significant bit
  23068c:	48 83 c0 01          	add    rax,0x1
  230690:	48 83 d6 00          	adc    rsi,0x0
        if ((a & (u128(1) << LDBL_MANT_DIG)) != 0) {
  230694:	48 0f ba e6 33       	bt     rsi,0x33
  230699:	72 0b                	jb     2306a6 <__floatuntitf+0x106>
  23069b:	48 0f ac f0 02       	shrd   rax,rsi,0x2
  2306a0:	48 c1 ee 02          	shr    rsi,0x2
  2306a4:	eb 0c                	jmp    2306b2 <__floatuntitf+0x112>
            a >>= 1;
  2306a6:	48 0f ac f0 03       	shrd   rax,rsi,0x3
  2306ab:	48 c1 ee 03          	shr    rsi,0x3
  2306af:	44 89 ca             	mov    edx,r9d
        // a is now rounded to LDBL_MANT_DIG bits
    }

    const high: u128 = (@intCast(u64, (e + 16383)) << 48) | // exponent
  2306b2:	81 c2 ff 3f 00 00    	add    edx,0x3fff
  2306b8:	48 c1 e2 30          	shl    rdx,0x30
        (@truncate(u64, a >> 64) & 0x0000ffffffffffff); // mantissa-high
  2306bc:	b1 30                	mov    cl,0x30
  2306be:	c4 e2 f0 f5 ce       	bzhi   rcx,rsi,rcx
    const low = @truncate(u64, a); // mantissa-low

    return @bitCast(f128, low | (high << 64));
  2306c3:	48 89 44 24 e8       	mov    QWORD PTR [rsp-0x18],rax
    const high: u128 = (@intCast(u64, (e + 16383)) << 48) | // exponent
  2306c8:	48 09 d1             	or     rcx,rdx
    return @bitCast(f128, low | (high << 64));
  2306cb:	48 89 4c 24 f0       	mov    QWORD PTR [rsp-0x10],rcx
  2306d0:	0f 28 44 24 e8       	movaps xmm0,XMMWORD PTR [rsp-0x18]
  2306d5:	5b                   	pop    rbx
  2306d6:	41 5e                	pop    r14
  2306d8:	c3                   	ret    
  2306d9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

00000000002306e0 <__floatuntidf>:
const DBL_MANT_DIG = 53;

pub extern fn __floatuntidf(arg: u128) f64 {
    @setRuntimeSafety(is_test);

    if (arg == 0)
  2306e0:	48 89 f8             	mov    rax,rdi
  2306e3:	48 09 f0             	or     rax,rsi
  2306e6:	0f 84 a0 00 00 00    	je     23078c <__floatuntidf+0xac>
        return 0.0;

    var a = arg;
    const N: u32 = @sizeOf(u128) * 8;
    const sd = @bitCast(i32, N - @clz(a)); // number of significant digits
  2306ec:	f3 48 0f bd c6       	lzcnt  rax,rsi
  2306f1:	f3 48 0f bd cf       	lzcnt  rcx,rdi
  2306f6:	83 c1 40             	add    ecx,0x40
  2306f9:	48 85 f6             	test   rsi,rsi
  2306fc:	0f 45 c8             	cmovne ecx,eax
  2306ff:	ba 80 00 00 00       	mov    edx,0x80
  230704:	29 ca                	sub    edx,ecx
    var e: i32 = sd - 1; // exponent
  230706:	41 bb 7f 00 00 00    	mov    r11d,0x7f
  23070c:	41 29 cb             	sub    r11d,ecx
    if (sd > DBL_MANT_DIG) {
  23070f:	83 fa 36             	cmp    edx,0x36
  230712:	7c 7d                	jl     230791 <__floatuntidf+0xb1>
        //                                                12345678901234567890123456
        //  1 = msb 1 bit
        //  P = bit DBL_MANT_DIG-1 bits to the right of 1
        //  Q = bit DBL_MANT_DIG bits to the right of 1
        //  R = "or" of all bits to the right of Q
        switch (sd) {
  230714:	0f 84 97 00 00 00    	je     2307b1 <__floatuntidf+0xd1>
  23071a:	83 fa 37             	cmp    edx,0x37
  23071d:	0f 84 96 00 00 00    	je     2307b9 <__floatuntidf+0xd9>
            DBL_MANT_DIG + 1 => {
                a <<= 1;
            },
            DBL_MANT_DIG + 2 => {},
            else => {
                const shift_amt = @bitCast(i32, N + (DBL_MANT_DIG + 2)) - sd;
  230723:	41 56                	push   r14
  230725:	53                   	push   rbx
  230726:	41 b8 37 00 00 00    	mov    r8d,0x37
                const shift_amt_u7 = @intCast(u7, shift_amt);
                a = (a >> @intCast(u7, sd - (DBL_MANT_DIG + 2))) |
  23072c:	8d 4a 49             	lea    ecx,[rdx+0x49]
  23072f:	83 e1 7f             	and    ecx,0x7f
  230732:	49 89 f9             	mov    r9,rdi
  230735:	49 0f ad f1          	shrd   r9,rsi,cl
                const shift_amt = @bitCast(i32, N + (DBL_MANT_DIG + 2)) - sd;
  230739:	41 29 d0             	sub    r8d,edx
                a = (a >> @intCast(u7, sd - (DBL_MANT_DIG + 2))) |
  23073c:	c4 62 f3 f7 d6       	shrx   r10,rsi,rcx
  230741:	45 31 f6             	xor    r14d,r14d
  230744:	f6 c1 40             	test   cl,0x40
  230747:	4d 0f 45 ca          	cmovne r9,r10
  23074b:	4d 0f 45 d6          	cmovne r10,r14
                    @boolToInt((a & (u128(@maxValue(u128)) >> shift_amt_u7)) != 0);
  23074f:	41 83 e0 7f          	and    r8d,0x7f
  230753:	48 c7 c3 ff ff ff ff 	mov    rbx,0xffffffffffffffff
  23075a:	c4 e2 bb f7 c3       	shrx   rax,rbx,r8
  23075f:	44 89 c1             	mov    ecx,r8d
  230762:	48 0f ad db          	shrd   rbx,rbx,cl
  230766:	41 f6 c0 40          	test   r8b,0x40
  23076a:	48 0f 45 d8          	cmovne rbx,rax
  23076e:	49 0f 45 c6          	cmovne rax,r14
  230772:	48 21 fb             	and    rbx,rdi
  230775:	48 21 f0             	and    rax,rsi
  230778:	31 ff                	xor    edi,edi
  23077a:	48 09 d8             	or     rax,rbx
  23077d:	40 0f 95 c7          	setne  dil
                a = (a >> @intCast(u7, sd - (DBL_MANT_DIG + 2))) |
  230781:	4c 09 cf             	or     rdi,r9
  230784:	4c 89 d6             	mov    rsi,r10
        switch (sd) {
  230787:	5b                   	pop    rbx
  230788:	41 5e                	pop    r14
  23078a:	eb 2d                	jmp    2307b9 <__floatuntidf+0xd9>
        return 0.0;
  23078c:	c5 f8 57 c0          	vxorps xmm0,xmm0,xmm0
  230790:	c3                   	ret    
            a >>= 1;
            e += 1;
        }
        // a is now rounded to DBL_MANT_DIG bits
    } else {
        a <<= @intCast(u7, DBL_MANT_DIG - sd);
  230791:	b8 35 00 00 00       	mov    eax,0x35
  230796:	29 d0                	sub    eax,edx
  230798:	83 e0 7f             	and    eax,0x7f
  23079b:	c4 e2 f9 f7 d7       	shlx   rdx,rdi,rax
  2307a0:	31 c9                	xor    ecx,ecx
  2307a2:	a8 40                	test   al,0x40
  2307a4:	48 0f 44 ca          	cmove  rcx,rdx
    if (sd > DBL_MANT_DIG) {
  2307a8:	48 89 ce             	mov    rsi,rcx
  2307ab:	48 c1 ee 20          	shr    rsi,0x20
  2307af:	eb 48                	jmp    2307f9 <__floatuntidf+0x119>
                a <<= 1;
  2307b1:	48 0f a4 fe 01       	shld   rsi,rdi,0x1
  2307b6:	48 01 ff             	add    rdi,rdi
        a |= @boolToInt((a & 4) != 0); // Or P into R
  2307b9:	b8 02 01 00 00       	mov    eax,0x102
  2307be:	c4 e2 78 f7 c7       	bextr  eax,edi,eax
  2307c3:	48 09 f8             	or     rax,rdi
        a += 1; // round - this step may add a significant bit
  2307c6:	48 83 c0 01          	add    rax,0x1
  2307ca:	48 83 d6 00          	adc    rsi,0x0
            a >>= 1;
  2307ce:	48 89 f1             	mov    rcx,rsi
        if ((a & (u128(1) << DBL_MANT_DIG)) != 0) {
  2307d1:	48 0f ba e0 37       	bt     rax,0x37
  2307d6:	72 10                	jb     2307e8 <__floatuntidf+0x108>
  2307d8:	48 0f a4 c1 3e       	shld   rcx,rax,0x3e
  2307dd:	48 c1 e8 22          	shr    rax,0x22
  2307e1:	c1 e6 1e             	shl    esi,0x1e
  2307e4:	09 c6                	or     esi,eax
  2307e6:	eb 11                	jmp    2307f9 <__floatuntidf+0x119>
            a >>= 1;
  2307e8:	48 0f a4 c1 3d       	shld   rcx,rax,0x3d
        if ((a & (u128(1) << DBL_MANT_DIG)) != 0) {
  2307ed:	48 c1 e8 23          	shr    rax,0x23
  2307f1:	c1 e6 1d             	shl    esi,0x1d
  2307f4:	09 c6                	or     esi,eax
  2307f6:	41 89 d3             	mov    r11d,edx
        // a is now rounded to DBL_MANT_DIG bits
    }

    const high: u64 = @bitCast(u32, (e + 1023) << 20) | // exponent
  2307f9:	41 c1 e3 14          	shl    r11d,0x14
        (@truncate(u32, a >> 32) & 0x000FFFFF); // mantissa-high
  2307fd:	81 e6 ff ff 0f 00    	and    esi,0xfffff
    const high: u64 = @bitCast(u32, (e + 1023) << 20) | // exponent
  230803:	42 8d 04 1e          	lea    eax,[rsi+r11*1]
  230807:	05 00 00 f0 3f       	add    eax,0x3ff00000
    const low = @truncate(u32, a); // mantissa-low

    return @bitCast(f64, low | (high << 32));
  23080c:	48 c1 e0 20          	shl    rax,0x20
  230810:	89 c9                	mov    ecx,ecx
  230812:	48 09 c1             	or     rcx,rax
  230815:	c4 e1 f9 6e c1       	vmovq  xmm0,rcx
  23081a:	c3                   	ret    
  23081b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000230820 <__floatuntisf>:
const FLT_MANT_DIG = 24;

pub extern fn __floatuntisf(arg: u128) f32 {
    @setRuntimeSafety(is_test);

    if (arg == 0)
  230820:	48 89 f8             	mov    rax,rdi
  230823:	48 09 f0             	or     rax,rsi
  230826:	0f 84 93 00 00 00    	je     2308bf <__floatuntisf+0x9f>
        return 0.0;

    var a = arg;
    const N: u32 = @sizeOf(u128) * 8;
    const sd = @bitCast(i32, N - @clz(a)); // number of significant digits
  23082c:	f3 48 0f bd c6       	lzcnt  rax,rsi
  230831:	f3 48 0f bd cf       	lzcnt  rcx,rdi
  230836:	83 c1 40             	add    ecx,0x40
  230839:	48 85 f6             	test   rsi,rsi
  23083c:	0f 45 c8             	cmovne ecx,eax
  23083f:	ba 80 00 00 00       	mov    edx,0x80
  230844:	29 ca                	sub    edx,ecx
    var e: i32 = sd - 1; // exponent
  230846:	b8 7f 00 00 00       	mov    eax,0x7f
  23084b:	29 c8                	sub    eax,ecx
    if (sd > FLT_MANT_DIG) {
  23084d:	83 fa 19             	cmp    edx,0x19
  230850:	7c 72                	jl     2308c4 <__floatuntisf+0xa4>
        //                                                12345678901234567890123456
        //  1 = msb 1 bit
        //  P = bit FLT_MANT_DIG-1 bits to the right of 1
        //  Q = bit FLT_MANT_DIG bits to the right of 1
        //  R = "or" of all bits to the right of Q
        switch (sd) {
  230852:	0f 84 87 00 00 00    	je     2308df <__floatuntisf+0xbf>
  230858:	83 fa 1a             	cmp    edx,0x1a
  23085b:	0f 84 81 00 00 00    	je     2308e2 <__floatuntisf+0xc2>
            },
            FLT_MANT_DIG + 2 => {},
            else => {
                const shift_amt = @bitCast(i32, N + (FLT_MANT_DIG + 2)) - sd;
                const shift_amt_u7 = @intCast(u7, shift_amt);
                a = (a >> @intCast(u7, sd - (FLT_MANT_DIG + 2))) |
  230861:	53                   	push   rbx
  230862:	8d 4a 66             	lea    ecx,[rdx+0x66]
  230865:	83 e1 7f             	and    ecx,0x7f
  230868:	49 89 f9             	mov    r9,rdi
  23086b:	49 0f ad f1          	shrd   r9,rsi,cl
                const shift_amt = @bitCast(i32, N + (FLT_MANT_DIG + 2)) - sd;
  23086f:	41 b8 1a 00 00 00    	mov    r8d,0x1a
  230875:	41 29 d0             	sub    r8d,edx
                a = (a >> @intCast(u7, sd - (FLT_MANT_DIG + 2))) |
  230878:	c4 62 f3 f7 d6       	shrx   r10,rsi,rcx
  23087d:	45 31 db             	xor    r11d,r11d
  230880:	f6 c1 40             	test   cl,0x40
  230883:	4d 0f 44 d1          	cmove  r10,r9
                    @boolToInt((a & (u128(@maxValue(u128)) >> shift_amt_u7)) != 0);
  230887:	41 83 e0 7f          	and    r8d,0x7f
  23088b:	49 c7 c1 ff ff ff ff 	mov    r9,0xffffffffffffffff
  230892:	c4 c2 bb f7 d9       	shrx   rbx,r9,r8
  230897:	44 89 c1             	mov    ecx,r8d
  23089a:	4d 0f ad c9          	shrd   r9,r9,cl
  23089e:	41 f6 c0 40          	test   r8b,0x40
  2308a2:	4c 0f 45 cb          	cmovne r9,rbx
  2308a6:	4c 0f 44 db          	cmove  r11,rbx
  2308aa:	49 21 f9             	and    r9,rdi
  2308ad:	49 21 f3             	and    r11,rsi
  2308b0:	31 ff                	xor    edi,edi
  2308b2:	4d 09 cb             	or     r11,r9
  2308b5:	40 0f 95 c7          	setne  dil
                a = (a >> @intCast(u7, sd - (FLT_MANT_DIG + 2))) |
  2308b9:	4c 09 d7             	or     rdi,r10
        switch (sd) {
  2308bc:	5b                   	pop    rbx
  2308bd:	eb 23                	jmp    2308e2 <__floatuntisf+0xc2>
        return 0.0;
  2308bf:	c5 f8 57 c0          	vxorps xmm0,xmm0,xmm0
  2308c3:	c3                   	ret    
            a >>= 1;
            e += 1;
        }
        // a is now rounded to FLT_MANT_DIG bits
    } else {
        a <<= @intCast(u7, FLT_MANT_DIG - sd);
  2308c4:	be 18 00 00 00       	mov    esi,0x18
  2308c9:	29 d6                	sub    esi,edx
  2308cb:	83 e6 7f             	and    esi,0x7f
  2308ce:	c4 e2 c9 f7 d7       	shlx   rdx,rdi,rsi
  2308d3:	31 c9                	xor    ecx,ecx
  2308d5:	40 f6 c6 40          	test   sil,0x40
  2308d9:	48 0f 44 ca          	cmove  rcx,rdx
  2308dd:	eb 28                	jmp    230907 <__floatuntisf+0xe7>
                a <<= 1;
  2308df:	48 01 ff             	add    rdi,rdi
        a |= @boolToInt((a & 4) != 0); // Or P into R
  2308e2:	b9 02 01 00 00       	mov    ecx,0x102
  2308e7:	c4 e2 70 f7 cf       	bextr  ecx,edi,ecx
  2308ec:	48 09 f9             	or     rcx,rdi
        a += 1; // round - this step may add a significant bit
  2308ef:	48 83 c1 01          	add    rcx,0x1
        if ((a & (u128(1) << FLT_MANT_DIG)) != 0) {
  2308f3:	f7 c1 00 00 00 04    	test   ecx,0x4000000
  2308f9:	75 06                	jne    230901 <__floatuntisf+0xe1>
  2308fb:	48 c1 e9 02          	shr    rcx,0x2
  2308ff:	eb 06                	jmp    230907 <__floatuntisf+0xe7>
            a >>= 1;
  230901:	48 c1 e9 03          	shr    rcx,0x3
  230905:	89 d0                	mov    eax,edx
        // a is now rounded to FLT_MANT_DIG bits
    }

    const high = @bitCast(u32, (e + 127) << 23); // exponent
  230907:	c1 e0 17             	shl    eax,0x17
    const low = @truncate(u32, a) & 0x007fffff; // mantissa
  23090a:	81 e1 ff ff 7f 00    	and    ecx,0x7fffff

    return @bitCast(f32, high | low);
  230910:	8d 04 08             	lea    eax,[rax+rcx*1]
  230913:	05 00 00 80 3f       	add    eax,0x3f800000
  230918:	c5 f9 6e c0          	vmovd  xmm0,eax
  23091c:	c3                   	ret    
  23091d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000230920 <__extenddftf2>:
    const aRep: src_rep_t = @bitCast(src_rep_t, a);
  230920:	c4 e1 f9 7e c1       	vmovq  rcx,xmm0
    const aAbs: src_rep_t = aRep & srcAbsMask;
  230925:	b0 3f                	mov    al,0x3f
  230927:	c4 e2 f8 f5 f1       	bzhi   rsi,rcx,rax
  23092c:	48 b8 ff ff ff ff ff 	movabs rax,0x7fffffffffffffff
  230933:	ff ff 7f 
    const sign: src_rep_t = aRep & srcSignMask;
  230936:	48 83 c0 01          	add    rax,0x1
  23093a:	48 21 c8             	and    rax,rcx
    if (aAbs -% srcMinNormal < srcInfinity - srcMinNormal) {
  23093d:	48 ba 00 00 00 00 00 	movabs rdx,0xfff0000000000000
  230944:	00 f0 ff 
  230947:	48 01 f2             	add    rdx,rsi
  23094a:	48 c1 ea 35          	shr    rdx,0x35
  23094e:	48 81 fa fe 03 00 00 	cmp    rdx,0x3fe
  230955:	77 1a                	ja     230971 <__extenddftf2+0x51>
        absResult = dst_rep_t(aAbs) << (dstSigBits - srcSigBits);
  230957:	48 89 f2             	mov    rdx,rsi
  23095a:	48 c1 e2 3c          	shl    rdx,0x3c
  23095e:	48 c1 ee 04          	shr    rsi,0x4
        absResult += (dstExpBias - srcExpBias) << dstSigBits;
  230962:	48 bf 00 00 00 00 00 	movabs rdi,0x3c00000000000000
  230969:	00 00 3c 
  23096c:	48 01 f7             	add    rdi,rsi
  23096f:	eb 7a                	jmp    2309eb <__extenddftf2+0xcb>
    } else if (aAbs >= srcInfinity) {
  230971:	48 89 f2             	mov    rdx,rsi
  230974:	48 c1 ea 34          	shr    rdx,0x34
  230978:	48 81 fa ff 07 00 00 	cmp    rdx,0x7ff
  23097f:	72 17                	jb     230998 <__extenddftf2+0x78>
        absResult |= dst_rep_t(aAbs & srcNaNCode) << (dstSigBits - srcSigBits);
  230981:	48 89 ca             	mov    rdx,rcx
  230984:	48 c1 e2 3c          	shl    rdx,0x3c
  230988:	48 c1 e9 04          	shr    rcx,0x4
  23098c:	48 bf 00 00 00 00 00 	movabs rdi,0x7fff000000000000
  230993:	00 ff 7f 
  230996:	eb 4a                	jmp    2309e2 <__extenddftf2+0xc2>
    } else if (aAbs != 0) {
  230998:	48 85 f6             	test   rsi,rsi
  23099b:	74 4a                	je     2309e7 <__extenddftf2+0xc7>
        const scale: u32 = @clz(aAbs) - @clz(src_rep_t(srcMinNormal));
  23099d:	f3 48 0f bd ce       	lzcnt  rcx,rsi
  2309a2:	44 8d 41 75          	lea    r8d,[rcx+0x75]
  2309a6:	41 83 e0 7f          	and    r8d,0x7f
        absResult = dst_rep_t(aAbs) << @intCast(DstShift, dstSigBits - srcSigBits + scale);
  2309aa:	83 c1 31             	add    ecx,0x31
  2309ad:	83 e1 7f             	and    ecx,0x7f
  2309b0:	45 31 c9             	xor    r9d,r9d
  2309b3:	31 ff                	xor    edi,edi
  2309b5:	48 0f a5 f7          	shld   rdi,rsi,cl
  2309b9:	c4 e2 f1 f7 d6       	shlx   rdx,rsi,rcx
  2309be:	f6 c1 40             	test   cl,0x40
  2309c1:	48 0f 45 fa          	cmovne rdi,rdx
  2309c5:	49 0f 45 d1          	cmovne rdx,r9
        absResult ^= dstMinNormal;
  2309c9:	48 b9 00 00 00 00 00 	movabs rcx,0x1000000000000
  2309d0:	00 01 00 
  2309d3:	48 31 f9             	xor    rcx,rdi
        const resultExponent: u32 = dstExpBias - srcExpBias - scale + 1;
  2309d6:	bf 01 3c 00 00       	mov    edi,0x3c01
  2309db:	44 29 c7             	sub    edi,r8d
        absResult |= @intCast(dst_rep_t, resultExponent) << dstSigBits;
  2309de:	48 c1 e7 30          	shl    rdi,0x30
  2309e2:	48 09 cf             	or     rdi,rcx
  2309e5:	eb 04                	jmp    2309eb <__extenddftf2+0xcb>
  2309e7:	31 d2                	xor    edx,edx
  2309e9:	31 ff                	xor    edi,edi
    const result: dst_rep_t align(@alignOf(dst_t)) = absResult | dst_rep_t(sign) << (dstBits - srcBits);
  2309eb:	48 89 54 24 e8       	mov    QWORD PTR [rsp-0x18],rdx
  2309f0:	48 09 c7             	or     rdi,rax
  2309f3:	48 89 7c 24 f0       	mov    QWORD PTR [rsp-0x10],rdi
  2309f8:	0f 28 44 24 e8       	movaps xmm0,XMMWORD PTR [rsp-0x18]
    return extendXfYf2(f128, f64, a);
  2309fd:	c3                   	ret    
  2309fe:	66 90                	xchg   ax,ax

0000000000230a00 <__extendsftf2>:
    const aRep: src_rep_t = @bitCast(src_rep_t, a);
  230a00:	c5 f9 7e c2          	vmovd  edx,xmm0
    const aAbs: src_rep_t = aRep & srcAbsMask;
  230a04:	89 d1                	mov    ecx,edx
  230a06:	81 e1 ff ff ff 7f    	and    ecx,0x7fffffff
    const sign: src_rep_t = aRep & srcSignMask;
  230a0c:	89 d0                	mov    eax,edx
  230a0e:	25 00 00 00 80       	and    eax,0x80000000
    if (aAbs -% srcMinNormal < srcInfinity - srcMinNormal) {
  230a13:	8d b1 00 00 80 ff    	lea    esi,[rcx-0x800000]
  230a19:	81 fe ff ff ff 7e    	cmp    esi,0x7effffff
  230a1f:	77 17                	ja     230a38 <__extendsftf2+0x38>
        absResult = dst_rep_t(aAbs) << (dstSigBits - srcSigBits);
  230a21:	89 ca                	mov    edx,ecx
  230a23:	48 c1 e2 19          	shl    rdx,0x19
        absResult += (dstExpBias - srcExpBias) << dstSigBits;
  230a27:	48 b9 00 00 00 00 00 	movabs rcx,0x3f80000000000000
  230a2e:	00 80 3f 
  230a31:	48 01 d1             	add    rcx,rdx
  230a34:	31 d2                	xor    edx,edx
  230a36:	eb 6f                	jmp    230aa7 <__extendsftf2+0xa7>
    } else if (aAbs >= srcInfinity) {
  230a38:	81 f9 00 00 80 7f    	cmp    ecx,0x7f800000
  230a3e:	72 17                	jb     230a57 <__extendsftf2+0x57>
        absResult |= dst_rep_t(aAbs & srcNaNCode) << (dstSigBits - srcSigBits);
  230a40:	89 d2                	mov    edx,edx
  230a42:	48 c1 e2 19          	shl    rdx,0x19
  230a46:	48 b9 00 00 00 00 00 	movabs rcx,0x7fff000000000000
  230a4d:	00 ff 7f 
  230a50:	48 09 d1             	or     rcx,rdx
  230a53:	31 d2                	xor    edx,edx
  230a55:	eb 50                	jmp    230aa7 <__extendsftf2+0xa7>
    } else if (aAbs != 0) {
  230a57:	85 c9                	test   ecx,ecx
  230a59:	74 48                	je     230aa3 <__extendsftf2+0xa3>
        const scale: u32 = @clz(aAbs) - @clz(src_rep_t(srcMinNormal));
  230a5b:	f3 0f bd f1          	lzcnt  esi,ecx
  230a5f:	83 c6 38             	add    esi,0x38
  230a62:	83 e6 3f             	and    esi,0x3f
        absResult = dst_rep_t(aAbs) << @intCast(DstShift, dstSigBits - srcSigBits + scale);
  230a65:	89 ca                	mov    edx,ecx
  230a67:	8d 4e 59             	lea    ecx,[rsi+0x59]
  230a6a:	83 e1 7f             	and    ecx,0x7f
  230a6d:	45 31 c0             	xor    r8d,r8d
  230a70:	31 ff                	xor    edi,edi
  230a72:	48 0f a5 d7          	shld   rdi,rdx,cl
  230a76:	c4 e2 f1 f7 d2       	shlx   rdx,rdx,rcx
  230a7b:	f6 c1 40             	test   cl,0x40
  230a7e:	48 0f 45 fa          	cmovne rdi,rdx
  230a82:	49 0f 45 d0          	cmovne rdx,r8
        absResult ^= dstMinNormal;
  230a86:	49 b8 00 00 00 00 00 	movabs r8,0x1000000000000
  230a8d:	00 01 00 
  230a90:	49 31 f8             	xor    r8,rdi
        const resultExponent: u32 = dstExpBias - srcExpBias - scale + 1;
  230a93:	b9 81 3f 00 00       	mov    ecx,0x3f81
  230a98:	29 f1                	sub    ecx,esi
        absResult |= @intCast(dst_rep_t, resultExponent) << dstSigBits;
  230a9a:	48 c1 e1 30          	shl    rcx,0x30
  230a9e:	4c 09 c1             	or     rcx,r8
  230aa1:	eb 04                	jmp    230aa7 <__extendsftf2+0xa7>
  230aa3:	31 d2                	xor    edx,edx
  230aa5:	31 c9                	xor    ecx,ecx
    const result: dst_rep_t align(@alignOf(dst_t)) = absResult | dst_rep_t(sign) << (dstBits - srcBits);
  230aa7:	48 c1 e0 20          	shl    rax,0x20
  230aab:	48 89 54 24 e8       	mov    QWORD PTR [rsp-0x18],rdx
  230ab0:	48 09 c8             	or     rax,rcx
  230ab3:	48 89 44 24 f0       	mov    QWORD PTR [rsp-0x10],rax
  230ab8:	0f 28 44 24 e8       	movaps xmm0,XMMWORD PTR [rsp-0x18]
    return extendXfYf2(f128, f32, a);
  230abd:	c3                   	ret    
  230abe:	66 90                	xchg   ax,ax

0000000000230ac0 <__trunctfdf2>:
    const aRep: src_rep_t = @bitCast(src_rep_t, a);
  230ac0:	66 0f 7f 44 24 e8    	movdqa XMMWORD PTR [rsp-0x18],xmm0
  230ac6:	48 8b 74 24 e8       	mov    rsi,QWORD PTR [rsp-0x18]
  230acb:	48 8b 54 24 f0       	mov    rdx,QWORD PTR [rsp-0x10]
    const aAbs: src_rep_t = aRep & srcAbsMask;
  230ad0:	b0 3f                	mov    al,0x3f
  230ad2:	c4 e2 f8 f5 ca       	bzhi   rcx,rdx,rax
    if (aAbs -% underflow < aAbs -% overflow) {
  230ad7:	48 b8 00 00 00 00 00 	movabs rax,0xc3ff000000000000
  230ade:	00 ff c3 
  230ae1:	48 01 c8             	add    rax,rcx
  230ae4:	48 bf 00 00 00 00 00 	movabs rdi,0xbc01000000000000
  230aeb:	00 01 bc 
  230aee:	48 01 cf             	add    rdi,rcx
  230af1:	48 39 f8             	cmp    rax,rdi
  230af4:	73 35                	jae    230b2b <__trunctfdf2+0x6b>
  230af6:	48 b8 00 00 00 00 00 	movabs rax,0x4000000000000000
  230afd:	00 00 40 
        absResult = @truncate(dst_rep_t, aAbs >> (srcSigBits - dstSigBits));
  230b00:	48 89 d1             	mov    rcx,rdx
  230b03:	48 0f a4 f1 04       	shld   rcx,rsi,0x4
        const roundBits: src_rep_t = aAbs & roundMask;
  230b08:	40 b7 3c             	mov    dil,0x3c
  230b0b:	c4 e2 c0 f5 f6       	bzhi   rsi,rsi,rdi
        if (roundBits > halfway) {
  230b10:	48 bf 01 00 00 00 00 	movabs rdi,0x800000000000001
  230b17:	00 00 08 
  230b1a:	48 39 fe             	cmp    rsi,rdi
  230b1d:	72 40                	jb     230b5f <__trunctfdf2+0x9f>
            absResult += 1;
  230b1f:	48 01 c1             	add    rcx,rax
  230b22:	48 83 c1 01          	add    rcx,0x1
  230b26:	e9 0f 01 00 00       	jmp    230c3a <__trunctfdf2+0x17a>
    } else if (aAbs > srcInfinity) {
  230b2b:	48 83 fe 01          	cmp    rsi,0x1
  230b2f:	48 b8 00 00 00 00 00 	movabs rax,0x7fff000000000000
  230b36:	00 ff 7f 
  230b39:	48 89 cf             	mov    rdi,rcx
  230b3c:	48 19 c7             	sbb    rdi,rax
  230b3f:	72 55                	jb     230b96 <__trunctfdf2+0xd6>
        absResult |= @intCast(dst_rep_t, ((aAbs & srcNaNCode) >> (srcSigBits - dstSigBits)) & dstNaNCode);
  230b41:	48 0f ac d6 3c       	shrd   rsi,rdx,0x3c
  230b46:	b0 33                	mov    al,0x33
  230b48:	c4 e2 f8 f5 c6       	bzhi   rax,rsi,rax
  230b4d:	48 b9 00 00 00 00 00 	movabs rcx,0x7ff8000000000000
  230b54:	00 f8 7f 
  230b57:	48 09 c1             	or     rcx,rax
  230b5a:	e9 db 00 00 00       	jmp    230c3a <__trunctfdf2+0x17a>
  230b5f:	48 01 c1             	add    rcx,rax
        } else if (roundBits == halfway) {
  230b62:	c4 e1 f9 6e c6       	vmovq  xmm0,rsi
  230b67:	48 b8 00 00 00 00 00 	movabs rax,0x800000000000000
  230b6e:	00 00 08 
  230b71:	c4 e1 f9 6e c8       	vmovq  xmm1,rax
  230b76:	c5 f9 74 c1          	vpcmpeqb xmm0,xmm0,xmm1
  230b7a:	c5 f9 d7 c0          	vpmovmskb eax,xmm0
  230b7e:	3d ff ff 00 00       	cmp    eax,0xffff
  230b83:	0f 85 b1 00 00 00    	jne    230c3a <__trunctfdf2+0x17a>
  230b89:	89 c8                	mov    eax,ecx
  230b8b:	83 e0 01             	and    eax,0x1
  230b8e:	48 01 c1             	add    rcx,rax
  230b91:	e9 a4 00 00 00       	jmp    230c3a <__trunctfdf2+0x17a>
    } else if (aAbs >= overflow) {
  230b96:	48 c1 e9 30          	shr    rcx,0x30
  230b9a:	48 81 f9 fe 43 00 00 	cmp    rcx,0x43fe
  230ba1:	76 0f                	jbe    230bb2 <__trunctfdf2+0xf2>
  230ba3:	48 b9 00 00 00 00 00 	movabs rcx,0x7ff0000000000000
  230baa:	00 f0 7f 
  230bad:	e9 88 00 00 00       	jmp    230c3a <__trunctfdf2+0x17a>
        const shift = @intCast(u32, srcExpBias - dstExpBias - aExp + 1);
  230bb2:	b8 00 3c 00 00       	mov    eax,0x3c00
  230bb7:	29 c8                	sub    eax,ecx
        if (shift > srcSigBits) {
  230bb9:	83 f8 6f             	cmp    eax,0x6f
  230bbc:	76 04                	jbe    230bc2 <__trunctfdf2+0x102>
  230bbe:	31 c9                	xor    ecx,ecx
  230bc0:	eb 78                	jmp    230c3a <__trunctfdf2+0x17a>
  230bc2:	b1 30                	mov    cl,0x30
  230bc4:	c4 e2 f0 f5 ca       	bzhi   rcx,rdx,rcx
  230bc9:	49 b8 00 00 00 00 00 	movabs r8,0x1000000000000
  230bd0:	00 01 00 
  230bd3:	49 09 c8             	or     r8,rcx
            const sticky: src_rep_t = significand << @intCast(SrcShift, srcBits - shift);
  230bd6:	b9 7f 00 00 00       	mov    ecx,0x7f
  230bdb:	29 c1                	sub    ecx,eax
  230bdd:	83 e1 7f             	and    ecx,0x7f
  230be0:	4c 89 c7             	mov    rdi,r8
  230be3:	48 0f a5 f7          	shld   rdi,rsi,cl
        const shift = @intCast(u32, srcExpBias - dstExpBias - aExp + 1);
  230be7:	83 c0 01             	add    eax,0x1
            const sticky: src_rep_t = significand << @intCast(SrcShift, srcBits - shift);
  230bea:	c4 62 f1 f7 ce       	shlx   r9,rsi,rcx
  230bef:	45 31 d2             	xor    r10d,r10d
  230bf2:	f6 c1 40             	test   cl,0x40
  230bf5:	49 0f 45 f9          	cmovne rdi,r9
  230bf9:	4d 0f 45 ca          	cmovne r9,r10
            const denormalizedSignificand: src_rep_t = significand >> @intCast(SrcShift, shift) | sticky;
  230bfd:	83 e0 7f             	and    eax,0x7f
  230c00:	89 c1                	mov    ecx,eax
  230c02:	4c 0f ad c6          	shrd   rsi,r8,cl
  230c06:	c4 c2 fb f7 c8       	shrx   rcx,r8,rax
  230c0b:	a8 40                	test   al,0x40
  230c0d:	48 0f 45 f1          	cmovne rsi,rcx
  230c11:	49 0f 45 ca          	cmovne rcx,r10
  230c15:	4c 09 ce             	or     rsi,r9
  230c18:	48 09 f9             	or     rcx,rdi
            absResult = @intCast(dst_rep_t, denormalizedSignificand >> (srcSigBits - dstSigBits));
  230c1b:	48 0f a4 f1 04       	shld   rcx,rsi,0x4
            const roundBits: src_rep_t = denormalizedSignificand & roundMask;
  230c20:	b0 3c                	mov    al,0x3c
  230c22:	c4 e2 f8 f5 c6       	bzhi   rax,rsi,rax
            if (roundBits > halfway) {
  230c27:	48 be 01 00 00 00 00 	movabs rsi,0x800000000000001
  230c2e:	00 00 08 
  230c31:	48 39 f0             	cmp    rax,rsi
  230c34:	72 1a                	jb     230c50 <__trunctfdf2+0x190>
                absResult += 1;
  230c36:	48 83 c1 01          	add    rcx,0x1
    const result: dst_rep_t align(@alignOf(dst_t)) = absResult | @truncate(dst_rep_t, sign >> @intCast(SrcShift, srcBits - dstBits));
  230c3a:	48 b8 00 00 00 00 00 	movabs rax,0x8000000000000000
  230c41:	00 00 80 
  230c44:	48 21 c2             	and    rdx,rax
  230c47:	48 09 ca             	or     rdx,rcx
    return @bitCast(dst_t, result);
  230c4a:	c4 e1 f9 6e c2       	vmovq  xmm0,rdx
    return truncXfYf2(f64, f128, a);
  230c4f:	c3                   	ret    
            } else if (roundBits == halfway) {
  230c50:	c4 e1 f9 6e c0       	vmovq  xmm0,rax
  230c55:	e9 0d ff ff ff       	jmp    230b67 <__trunctfdf2+0xa7>
  230c5a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000230c60 <__trunctfsf2>:
    const aRep: src_rep_t = @bitCast(src_rep_t, a);
  230c60:	66 0f 7f 44 24 e8    	movdqa XMMWORD PTR [rsp-0x18],xmm0
  230c66:	48 8b 74 24 e8       	mov    rsi,QWORD PTR [rsp-0x18]
  230c6b:	48 8b 54 24 f0       	mov    rdx,QWORD PTR [rsp-0x10]
    const aAbs: src_rep_t = aRep & srcAbsMask;
  230c70:	b0 3f                	mov    al,0x3f
  230c72:	c4 e2 f8 f5 fa       	bzhi   rdi,rdx,rax
    if (aAbs -% underflow < aAbs -% overflow) {
  230c77:	48 b8 00 00 00 00 00 	movabs rax,0xc07f000000000000
  230c7e:	00 7f c0 
  230c81:	48 01 f8             	add    rax,rdi
  230c84:	48 b9 00 00 00 00 00 	movabs rcx,0xbf81000000000000
  230c8b:	00 81 bf 
  230c8e:	48 01 f9             	add    rcx,rdi
  230c91:	48 39 c8             	cmp    rax,rcx
  230c94:	73 29                	jae    230cbf <__trunctfsf2+0x5f>
        absResult = @truncate(dst_rep_t, aAbs >> (srcSigBits - dstSigBits));
  230c96:	48 89 d1             	mov    rcx,rdx
  230c99:	48 c1 e9 19          	shr    rcx,0x19
        const roundBits: src_rep_t = aAbs & roundMask;
  230c9d:	89 d0                	mov    eax,edx
  230c9f:	25 ff ff ff 01       	and    eax,0x1ffffff
        if (roundBits > halfway) {
  230ca4:	48 83 fe 01          	cmp    rsi,0x1
  230ca8:	48 89 c7             	mov    rdi,rax
  230cab:	48 81 df 00 00 00 01 	sbb    rdi,0x1000000
  230cb2:	72 39                	jb     230ced <__trunctfsf2+0x8d>
            absResult += 1;
  230cb4:	81 c1 01 00 00 40    	add    ecx,0x40000001
  230cba:	e9 0e 01 00 00       	jmp    230dcd <__trunctfsf2+0x16d>
    } else if (aAbs > srcInfinity) {
  230cbf:	48 83 fe 01          	cmp    rsi,0x1
  230cc3:	48 b8 00 00 00 00 00 	movabs rax,0x7fff000000000000
  230cca:	00 ff 7f 
  230ccd:	48 89 f9             	mov    rcx,rdi
  230cd0:	48 19 c1             	sbb    rcx,rax
  230cd3:	72 5c                	jb     230d31 <__trunctfsf2+0xd1>
        absResult |= @intCast(dst_rep_t, ((aAbs & srcNaNCode) >> (srcSigBits - dstSigBits)) & dstNaNCode);
  230cd5:	48 89 d1             	mov    rcx,rdx
  230cd8:	48 c1 e9 19          	shr    rcx,0x19
  230cdc:	81 e1 ff ff 3f 00    	and    ecx,0x3fffff
  230ce2:	81 c9 00 00 c0 7f    	or     ecx,0x7fc00000
  230ce8:	e9 e0 00 00 00       	jmp    230dcd <__trunctfsf2+0x16d>
  230ced:	81 c1 00 00 00 40    	add    ecx,0x40000000
        } else if (roundBits == halfway) {
  230cf3:	c4 e1 f9 6e c6       	vmovq  xmm0,rsi
  230cf8:	c4 e1 f9 6e c8       	vmovq  xmm1,rax
  230cfd:	c5 f9 6c c1          	vpunpcklqdq xmm0,xmm0,xmm1
  230d01:	b8 00 00 00 01       	mov    eax,0x1000000
  230d06:	c4 e1 f9 6e c8       	vmovq  xmm1,rax
  230d0b:	c5 f1 73 f9 08       	vpslldq xmm1,xmm1,0x8
  230d10:	c5 f9 74 c1          	vpcmpeqb xmm0,xmm0,xmm1
  230d14:	c5 f9 d7 c0          	vpmovmskb eax,xmm0
  230d18:	3d ff ff 00 00       	cmp    eax,0xffff
  230d1d:	0f 85 aa 00 00 00    	jne    230dcd <__trunctfsf2+0x16d>
  230d23:	89 c8                	mov    eax,ecx
  230d25:	83 e0 01             	and    eax,0x1
  230d28:	01 c8                	add    eax,ecx
  230d2a:	89 c1                	mov    ecx,eax
  230d2c:	e9 9c 00 00 00       	jmp    230dcd <__trunctfsf2+0x16d>
    } else if (aAbs >= overflow) {
  230d31:	48 c1 ef 30          	shr    rdi,0x30
  230d35:	b9 00 00 80 7f       	mov    ecx,0x7f800000
  230d3a:	48 81 ff 7e 40 00 00 	cmp    rdi,0x407e
  230d41:	0f 87 86 00 00 00    	ja     230dcd <__trunctfsf2+0x16d>
        const shift = @intCast(u32, srcExpBias - dstExpBias - aExp + 1);
  230d47:	b8 80 3f 00 00       	mov    eax,0x3f80
  230d4c:	29 f8                	sub    eax,edi
  230d4e:	31 c9                	xor    ecx,ecx
        if (shift > srcSigBits) {
  230d50:	83 f8 6f             	cmp    eax,0x6f
  230d53:	77 78                	ja     230dcd <__trunctfsf2+0x16d>
  230d55:	b1 30                	mov    cl,0x30
  230d57:	c4 e2 f0 f5 ca       	bzhi   rcx,rdx,rcx
  230d5c:	48 bf 00 00 00 00 00 	movabs rdi,0x1000000000000
  230d63:	00 01 00 
  230d66:	48 09 cf             	or     rdi,rcx
            const sticky: src_rep_t = significand << @intCast(SrcShift, srcBits - shift);
  230d69:	b9 7f 00 00 00       	mov    ecx,0x7f
  230d6e:	29 c1                	sub    ecx,eax
  230d70:	83 e1 7f             	and    ecx,0x7f
  230d73:	49 89 f8             	mov    r8,rdi
  230d76:	49 0f a5 f0          	shld   r8,rsi,cl
        const shift = @intCast(u32, srcExpBias - dstExpBias - aExp + 1);
  230d7a:	83 c0 01             	add    eax,0x1
            const sticky: src_rep_t = significand << @intCast(SrcShift, srcBits - shift);
  230d7d:	c4 62 f1 f7 ce       	shlx   r9,rsi,rcx
  230d82:	45 31 d2             	xor    r10d,r10d
  230d85:	f6 c1 40             	test   cl,0x40
  230d88:	4d 0f 45 c1          	cmovne r8,r9
  230d8c:	4d 0f 45 ca          	cmovne r9,r10
            const denormalizedSignificand: src_rep_t = significand >> @intCast(SrcShift, shift) | sticky;
  230d90:	83 e0 7f             	and    eax,0x7f
  230d93:	89 c1                	mov    ecx,eax
  230d95:	48 0f ad fe          	shrd   rsi,rdi,cl
  230d99:	c4 e2 fb f7 ff       	shrx   rdi,rdi,rax
  230d9e:	a8 40                	test   al,0x40
  230da0:	48 0f 45 f7          	cmovne rsi,rdi
  230da4:	49 0f 45 fa          	cmovne rdi,r10
  230da8:	4c 09 ce             	or     rsi,r9
  230dab:	4c 09 c7             	or     rdi,r8
            absResult = @intCast(dst_rep_t, denormalizedSignificand >> (srcSigBits - dstSigBits));
  230dae:	48 89 f9             	mov    rcx,rdi
  230db1:	48 c1 e9 19          	shr    rcx,0x19
            const roundBits: src_rep_t = denormalizedSignificand & roundMask;
  230db5:	81 e7 ff ff ff 01    	and    edi,0x1ffffff
            if (roundBits > halfway) {
  230dbb:	48 83 fe 01          	cmp    rsi,0x1
  230dbf:	48 89 f8             	mov    rax,rdi
  230dc2:	48 1d 00 00 00 01    	sbb    rax,0x1000000
  230dc8:	72 14                	jb     230dde <__trunctfsf2+0x17e>
                absResult += 1;
  230dca:	83 c1 01             	add    ecx,0x1
    const result: dst_rep_t align(@alignOf(dst_t)) = absResult | @truncate(dst_rep_t, sign >> @intCast(SrcShift, srcBits - dstBits));
  230dcd:	48 c1 ea 20          	shr    rdx,0x20
  230dd1:	81 e2 00 00 00 80    	and    edx,0x80000000
  230dd7:	09 ca                	or     edx,ecx
    return @bitCast(dst_t, result);
  230dd9:	c5 f9 6e c2          	vmovd  xmm0,edx
    return truncXfYf2(f32, f128, a);
  230ddd:	c3                   	ret    
            } else if (roundBits == halfway) {
  230dde:	c4 e1 f9 6e c6       	vmovq  xmm0,rsi
  230de3:	c4 e1 f9 6e cf       	vmovq  xmm1,rdi
  230de8:	e9 10 ff ff ff       	jmp    230cfd <__trunctfsf2+0x9d>
  230ded:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000230df0 <__fixunssfsi>:

    const implicitBit = (rep_t(1) << significandBits);
    const significandMask = (implicitBit - 1);

    // Break a into sign, exponent, significand
    const aRep: rep_t = @bitCast(rep_t, a);
  230df0:	c5 f9 7e c1          	vmovd  ecx,xmm0
  230df4:	31 c0                	xor    eax,eax
    const absMask = signBit - 1;
    const aAbs: rep_t = aRep & absMask;

    const sign = if ((aRep & signBit) != 0) i32(-1) else i32(1);
  230df6:	85 c9                	test   ecx,ecx
    const exponent = @intCast(i32, aAbs >> significandBits) - exponentBias;
    const significand: rep_t = (aAbs & significandMask) | implicitBit;

    // If either the value or the exponent is negative, the result is zero.
    if (sign == -1 or exponent < 0) return 0;
  230df8:	78 43                	js     230e3d <__fixunssfsi+0x4d>
  230dfa:	89 ca                	mov    edx,ecx
  230dfc:	c1 ea 17             	shr    edx,0x17
  230dff:	0f b6 f2             	movzx  esi,dl
  230e02:	83 fe 7f             	cmp    esi,0x7f
  230e05:	72 36                	jb     230e3d <__fixunssfsi+0x4d>
    const exponent = @intCast(i32, aAbs >> significandBits) - exponentBias;
  230e07:	8d 7e 81             	lea    edi,[rsi-0x7f]
  230e0a:	b8 ff ff ff ff       	mov    eax,0xffffffff

    // If the value is too large for the integer type, saturate.
    if (@intCast(c_uint, exponent) >= fixuint_t.bit_count) return ~fixuint_t(0);
  230e0f:	83 ff 1f             	cmp    edi,0x1f
  230e12:	77 29                	ja     230e3d <__fixunssfsi+0x4d>
  230e14:	81 e1 ff ff 7f 00    	and    ecx,0x7fffff
  230e1a:	81 c9 00 00 80 00    	or     ecx,0x800000

    // If 0 <= exponent < significandBits, right shift to get the result.
    // Otherwise, shift left.
    if (exponent < significandBits) {
  230e20:	81 fe 95 00 00 00    	cmp    esi,0x95
  230e26:	77 0d                	ja     230e35 <__fixunssfsi+0x45>
        return @intCast(fixuint_t, significand >> @intCast(Log2Int(rep_t), significandBits - exponent));
  230e28:	b8 16 00 00 00       	mov    eax,0x16
  230e2d:	29 d0                	sub    eax,edx
  230e2f:	c4 e2 7b f7 c1       	shrx   eax,ecx,eax
const fixuint = @import("fixuint.zig").fixuint;
const builtin = @import("builtin");

pub extern fn __fixunssfsi(a: f32) u32 {
    @setRuntimeSafety(builtin.is_test);
    return fixuint(f32, u32, a);
  230e34:	c3                   	ret    
    } else {
        return @intCast(fixuint_t, significand) << @intCast(Log2Int(fixuint_t), exponent - significandBits);
  230e35:	83 c2 0a             	add    edx,0xa
  230e38:	c4 e2 69 f7 c1       	shlx   eax,ecx,edx
  230e3d:	c3                   	ret    
  230e3e:	66 90                	xchg   ax,ax

0000000000230e40 <__fixunssfdi>:
    const aRep: rep_t = @bitCast(rep_t, a);
  230e40:	c5 f9 7e c1          	vmovd  ecx,xmm0
  230e44:	31 c0                	xor    eax,eax
    const sign = if ((aRep & signBit) != 0) i32(-1) else i32(1);
  230e46:	85 c9                	test   ecx,ecx
    if (sign == -1 or exponent < 0) return 0;
  230e48:	78 47                	js     230e91 <__fixunssfdi+0x51>
  230e4a:	89 ca                	mov    edx,ecx
  230e4c:	c1 ea 17             	shr    edx,0x17
  230e4f:	0f b6 f2             	movzx  esi,dl
  230e52:	83 fe 7f             	cmp    esi,0x7f
  230e55:	72 3a                	jb     230e91 <__fixunssfdi+0x51>
    const exponent = @intCast(i32, aAbs >> significandBits) - exponentBias;
  230e57:	8d 7e 81             	lea    edi,[rsi-0x7f]
  230e5a:	48 c7 c0 ff ff ff ff 	mov    rax,0xffffffffffffffff
    if (@intCast(c_uint, exponent) >= fixuint_t.bit_count) return ~fixuint_t(0);
  230e61:	83 ff 3f             	cmp    edi,0x3f
  230e64:	77 2b                	ja     230e91 <__fixunssfdi+0x51>
  230e66:	81 e1 ff ff 7f 00    	and    ecx,0x7fffff
  230e6c:	81 c9 00 00 80 00    	or     ecx,0x800000
    if (exponent < significandBits) {
  230e72:	81 fe 95 00 00 00    	cmp    esi,0x95
  230e78:	77 0d                	ja     230e87 <__fixunssfdi+0x47>
        return @intCast(fixuint_t, significand >> @intCast(Log2Int(rep_t), significandBits - exponent));
  230e7a:	b8 16 00 00 00       	mov    eax,0x16
  230e7f:	29 d0                	sub    eax,edx
  230e81:	c4 e2 7b f7 c1       	shrx   eax,ecx,eax
const fixuint = @import("fixuint.zig").fixuint;
const builtin = @import("builtin");

pub extern fn __fixunssfdi(a: f32) u64 {
    @setRuntimeSafety(builtin.is_test);
    return fixuint(f32, u64, a);
  230e86:	c3                   	ret    
        return @intCast(fixuint_t, significand) << @intCast(Log2Int(fixuint_t), exponent - significandBits);
  230e87:	89 c8                	mov    eax,ecx
  230e89:	83 c2 2a             	add    edx,0x2a
  230e8c:	c4 e2 e9 f7 c0       	shlx   rax,rax,rdx
  230e91:	c3                   	ret    
  230e92:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  230e99:	1f 84 00 00 00 00 00 

0000000000230ea0 <__fixunssfti>:
    const aRep: rep_t = @bitCast(rep_t, a);
  230ea0:	c5 f9 7e c6          	vmovd  esi,xmm0
  230ea4:	31 d2                	xor    edx,edx
  230ea6:	b8 00 00 00 00       	mov    eax,0x0
    const sign = if ((aRep & signBit) != 0) i32(-1) else i32(1);
  230eab:	85 f6                	test   esi,esi
    if (sign == -1 or exponent < 0) return 0;
  230ead:	78 68                	js     230f17 <__fixunssfti+0x77>
  230eaf:	89 f1                	mov    ecx,esi
  230eb1:	c1 e9 17             	shr    ecx,0x17
  230eb4:	0f b6 f9             	movzx  edi,cl
  230eb7:	83 ff 7f             	cmp    edi,0x7f
  230eba:	72 5b                	jb     230f17 <__fixunssfti+0x77>
    const exponent = @intCast(i32, aAbs >> significandBits) - exponentBias;
  230ebc:	44 8d 47 81          	lea    r8d,[rdi-0x7f]
  230ec0:	48 c7 c0 ff ff ff ff 	mov    rax,0xffffffffffffffff
  230ec7:	48 c7 c2 ff ff ff ff 	mov    rdx,0xffffffffffffffff
    if (@intCast(c_uint, exponent) >= fixuint_t.bit_count) return ~fixuint_t(0);
  230ece:	41 83 f8 7f          	cmp    r8d,0x7f
  230ed2:	77 43                	ja     230f17 <__fixunssfti+0x77>
  230ed4:	81 e6 ff ff 7f 00    	and    esi,0x7fffff
  230eda:	81 ce 00 00 80 00    	or     esi,0x800000
    if (exponent < significandBits) {
  230ee0:	81 ff 95 00 00 00    	cmp    edi,0x95
  230ee6:	77 0f                	ja     230ef7 <__fixunssfti+0x57>
        return @intCast(fixuint_t, significand >> @intCast(Log2Int(rep_t), significandBits - exponent));
  230ee8:	b8 16 00 00 00       	mov    eax,0x16
  230eed:	29 c8                	sub    eax,ecx
  230eef:	c4 e2 7b f7 c6       	shrx   eax,esi,eax
  230ef4:	31 d2                	xor    edx,edx
const fixuint = @import("fixuint.zig").fixuint;
const builtin = @import("builtin");

pub extern fn __fixunssfti(a: f32) u128 {
    @setRuntimeSafety(builtin.is_test);
    return fixuint(f32, u128, a);
  230ef6:	c3                   	ret    
        return @intCast(fixuint_t, significand) << @intCast(Log2Int(fixuint_t), exponent - significandBits);
  230ef7:	89 f0                	mov    eax,esi
  230ef9:	83 c1 6a             	add    ecx,0x6a
  230efc:	83 e1 7f             	and    ecx,0x7f
  230eff:	31 d2                	xor    edx,edx
  230f01:	48 0f a5 c2          	shld   rdx,rax,cl
  230f05:	31 f6                	xor    esi,esi
  230f07:	c4 e2 f1 f7 c0       	shlx   rax,rax,rcx
  230f0c:	f6 c1 40             	test   cl,0x40
  230f0f:	48 0f 45 d0          	cmovne rdx,rax
  230f13:	48 0f 45 c6          	cmovne rax,rsi
  230f17:	c3                   	ret    
  230f18:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  230f1f:	00 

0000000000230f20 <__fixunsdfsi>:
    const aRep: rep_t = @bitCast(rep_t, a);
  230f20:	c4 e1 f9 7e c2       	vmovq  rdx,xmm0
  230f25:	31 c0                	xor    eax,eax
    const sign = if ((aRep & signBit) != 0) i32(-1) else i32(1);
  230f27:	48 85 d2             	test   rdx,rdx
    if (sign == -1 or exponent < 0) return 0;
  230f2a:	78 4b                	js     230f77 <__fixunsdfsi+0x57>
  230f2c:	48 89 d1             	mov    rcx,rdx
  230f2f:	48 c1 e9 34          	shr    rcx,0x34
  230f33:	89 ce                	mov    esi,ecx
  230f35:	81 e6 ff 07 00 00    	and    esi,0x7ff
  230f3b:	81 fe ff 03 00 00    	cmp    esi,0x3ff
  230f41:	72 34                	jb     230f77 <__fixunsdfsi+0x57>
    const exponent = @intCast(i32, aAbs >> significandBits) - exponentBias;
  230f43:	81 c6 01 fc ff ff    	add    esi,0xfffffc01
  230f49:	b8 ff ff ff ff       	mov    eax,0xffffffff
    if (@intCast(c_uint, exponent) >= fixuint_t.bit_count) return ~fixuint_t(0);
  230f4e:	83 fe 1f             	cmp    esi,0x1f
  230f51:	77 24                	ja     230f77 <__fixunsdfsi+0x57>
  230f53:	b0 34                	mov    al,0x34
  230f55:	c4 e2 f8 f5 c2       	bzhi   rax,rdx,rax
  230f5a:	48 ba ff ff ff ff ff 	movabs rdx,0xfffffffffffff
  230f61:	ff 0f 00 
  230f64:	48 83 c2 01          	add    rdx,0x1
  230f68:	48 09 c2             	or     rdx,rax
        return @intCast(fixuint_t, significand >> @intCast(Log2Int(rep_t), significandBits - exponent));
  230f6b:	b8 33 00 00 00       	mov    eax,0x33
  230f70:	29 c8                	sub    eax,ecx
  230f72:	c4 e2 fb f7 c2       	shrx   rax,rdx,rax
const fixuint = @import("fixuint.zig").fixuint;
const builtin = @import("builtin");

pub extern fn __fixunsdfsi(a: f64) u32 {
    @setRuntimeSafety(builtin.is_test);
    return fixuint(f64, u32, a);
  230f77:	c3                   	ret    
  230f78:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  230f7f:	00 

0000000000230f80 <__fixunsdfdi>:
    const aRep: rep_t = @bitCast(rep_t, a);
  230f80:	c4 e1 f9 7e c2       	vmovq  rdx,xmm0
  230f85:	31 c0                	xor    eax,eax
    const sign = if ((aRep & signBit) != 0) i32(-1) else i32(1);
  230f87:	48 85 d2             	test   rdx,rdx
    if (sign == -1 or exponent < 0) return 0;
  230f8a:	78 5e                	js     230fea <__fixunsdfdi+0x6a>
  230f8c:	48 89 d1             	mov    rcx,rdx
  230f8f:	48 c1 e9 34          	shr    rcx,0x34
  230f93:	89 ce                	mov    esi,ecx
  230f95:	81 e6 ff 07 00 00    	and    esi,0x7ff
  230f9b:	81 fe ff 03 00 00    	cmp    esi,0x3ff
  230fa1:	72 47                	jb     230fea <__fixunsdfdi+0x6a>
    const exponent = @intCast(i32, aAbs >> significandBits) - exponentBias;
  230fa3:	8d be 01 fc ff ff    	lea    edi,[rsi-0x3ff]
  230fa9:	48 c7 c0 ff ff ff ff 	mov    rax,0xffffffffffffffff
    if (@intCast(c_uint, exponent) >= fixuint_t.bit_count) return ~fixuint_t(0);
  230fb0:	83 ff 3f             	cmp    edi,0x3f
  230fb3:	77 35                	ja     230fea <__fixunsdfdi+0x6a>
  230fb5:	b0 34                	mov    al,0x34
  230fb7:	c4 e2 f8 f5 d2       	bzhi   rdx,rdx,rax
  230fbc:	48 b8 ff ff ff ff ff 	movabs rax,0xfffffffffffff
  230fc3:	ff 0f 00 
  230fc6:	48 83 c0 01          	add    rax,0x1
  230fca:	48 09 d0             	or     rax,rdx
    if (exponent < significandBits) {
  230fcd:	81 fe 32 04 00 00    	cmp    esi,0x432
  230fd3:	77 0d                	ja     230fe2 <__fixunsdfdi+0x62>
        return @intCast(fixuint_t, significand >> @intCast(Log2Int(rep_t), significandBits - exponent));
  230fd5:	ba 33 00 00 00       	mov    edx,0x33
  230fda:	29 ca                	sub    edx,ecx
  230fdc:	c4 e2 eb f7 c0       	shrx   rax,rax,rdx
const fixuint = @import("fixuint.zig").fixuint;
const builtin = @import("builtin");

pub extern fn __fixunsdfdi(a: f64) u64 {
    @setRuntimeSafety(builtin.is_test);
    return fixuint(f64, u64, a);
  230fe1:	c3                   	ret    
        return @intCast(fixuint_t, significand) << @intCast(Log2Int(fixuint_t), exponent - significandBits);
  230fe2:	83 c1 0d             	add    ecx,0xd
  230fe5:	c4 e2 f1 f7 c0       	shlx   rax,rax,rcx
  230fea:	c3                   	ret    
  230feb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000230ff0 <__fixunsdfti>:
    const aRep: rep_t = @bitCast(rep_t, a);
  230ff0:	c4 e1 f9 7e c6       	vmovq  rsi,xmm0
  230ff5:	31 d2                	xor    edx,edx
  230ff7:	b8 00 00 00 00       	mov    eax,0x0
    const sign = if ((aRep & signBit) != 0) i32(-1) else i32(1);
  230ffc:	48 85 f6             	test   rsi,rsi
    if (sign == -1 or exponent < 0) return 0;
  230fff:	78 7f                	js     231080 <__fixunsdfti+0x90>
  231001:	48 89 f1             	mov    rcx,rsi
  231004:	48 c1 e9 34          	shr    rcx,0x34
  231008:	89 cf                	mov    edi,ecx
  23100a:	81 e7 ff 07 00 00    	and    edi,0x7ff
  231010:	81 ff ff 03 00 00    	cmp    edi,0x3ff
  231016:	72 68                	jb     231080 <__fixunsdfti+0x90>
    const exponent = @intCast(i32, aAbs >> significandBits) - exponentBias;
  231018:	44 8d 87 01 fc ff ff 	lea    r8d,[rdi-0x3ff]
  23101f:	48 c7 c0 ff ff ff ff 	mov    rax,0xffffffffffffffff
  231026:	48 c7 c2 ff ff ff ff 	mov    rdx,0xffffffffffffffff
    if (@intCast(c_uint, exponent) >= fixuint_t.bit_count) return ~fixuint_t(0);
  23102d:	41 83 f8 7f          	cmp    r8d,0x7f
  231031:	77 4d                	ja     231080 <__fixunsdfti+0x90>
  231033:	b0 34                	mov    al,0x34
  231035:	c4 e2 f8 f5 d6       	bzhi   rdx,rsi,rax
  23103a:	48 b8 ff ff ff ff ff 	movabs rax,0xfffffffffffff
  231041:	ff 0f 00 
  231044:	48 83 c0 01          	add    rax,0x1
  231048:	48 09 d0             	or     rax,rdx
    if (exponent < significandBits) {
  23104b:	81 ff 32 04 00 00    	cmp    edi,0x432
  231051:	77 0f                	ja     231062 <__fixunsdfti+0x72>
        return @intCast(fixuint_t, significand >> @intCast(Log2Int(rep_t), significandBits - exponent));
  231053:	ba 33 00 00 00       	mov    edx,0x33
  231058:	29 ca                	sub    edx,ecx
  23105a:	c4 e2 eb f7 c0       	shrx   rax,rax,rdx
  23105f:	31 d2                	xor    edx,edx
const fixuint = @import("fixuint.zig").fixuint;
const builtin = @import("builtin");

pub extern fn __fixunsdfti(a: f64) u128 {
    @setRuntimeSafety(builtin.is_test);
    return fixuint(f64, u128, a);
  231061:	c3                   	ret    
        return @intCast(fixuint_t, significand) << @intCast(Log2Int(fixuint_t), exponent - significandBits);
  231062:	8d 49 4d             	lea    ecx,[rcx+0x4d]
  231065:	83 e1 7f             	and    ecx,0x7f
  231068:	31 d2                	xor    edx,edx
  23106a:	48 0f a5 c2          	shld   rdx,rax,cl
  23106e:	31 f6                	xor    esi,esi
  231070:	c4 e2 f1 f7 c0       	shlx   rax,rax,rcx
  231075:	f6 c1 40             	test   cl,0x40
  231078:	48 0f 45 d0          	cmovne rdx,rax
  23107c:	48 0f 45 c6          	cmovne rax,rsi
  231080:	c3                   	ret    
  231081:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  231088:	0f 1f 84 00 00 00 00 
  23108f:	00 

0000000000231090 <__fixunstfsi>:
    const aRep: rep_t = @bitCast(rep_t, a);
  231090:	0f 29 44 24 e8       	movaps XMMWORD PTR [rsp-0x18],xmm0
  231095:	48 8b 4c 24 f0       	mov    rcx,QWORD PTR [rsp-0x10]
  23109a:	31 c0                	xor    eax,eax
    const sign = if ((aRep & signBit) != 0) i32(-1) else i32(1);
  23109c:	48 85 c9             	test   rcx,rcx
    if (sign == -1 or exponent < 0) return 0;
  23109f:	78 5a                	js     2310fb <__fixunstfsi+0x6b>
  2310a1:	48 89 ca             	mov    rdx,rcx
  2310a4:	48 c1 ea 30          	shr    rdx,0x30
  2310a8:	89 d6                	mov    esi,edx
  2310aa:	81 e6 ff 7f 00 00    	and    esi,0x7fff
  2310b0:	81 fe ff 3f 00 00    	cmp    esi,0x3fff
  2310b6:	72 43                	jb     2310fb <__fixunstfsi+0x6b>
    const exponent = @intCast(i32, aAbs >> significandBits) - exponentBias;
  2310b8:	81 c6 01 c0 ff ff    	add    esi,0xffffc001
  2310be:	b8 ff ff ff ff       	mov    eax,0xffffffff
    if (@intCast(c_uint, exponent) >= fixuint_t.bit_count) return ~fixuint_t(0);
  2310c3:	83 fe 1f             	cmp    esi,0x1f
  2310c6:	77 33                	ja     2310fb <__fixunstfsi+0x6b>
  2310c8:	48 8b 74 24 e8       	mov    rsi,QWORD PTR [rsp-0x18]
  2310cd:	b0 30                	mov    al,0x30
  2310cf:	c4 e2 f8 f5 c1       	bzhi   rax,rcx,rax
  2310d4:	48 bf 00 00 00 00 00 	movabs rdi,0x1000000000000
  2310db:	00 01 00 
  2310de:	48 09 c7             	or     rdi,rax
        return @intCast(fixuint_t, significand >> @intCast(Log2Int(rep_t), significandBits - exponent));
  2310e1:	b9 6f 00 00 00       	mov    ecx,0x6f
  2310e6:	29 d1                	sub    ecx,edx
  2310e8:	83 e1 7f             	and    ecx,0x7f
  2310eb:	48 0f ad fe          	shrd   rsi,rdi,cl
  2310ef:	c4 e2 f3 f7 c7       	shrx   rax,rdi,rcx
  2310f4:	f6 c1 40             	test   cl,0x40
  2310f7:	48 0f 44 c6          	cmove  rax,rsi
const fixuint = @import("fixuint.zig").fixuint;
const builtin = @import("builtin");

pub extern fn __fixunstfsi(a: f128) u32 {
    @setRuntimeSafety(builtin.is_test);
    return fixuint(f128, u32, a);
  2310fb:	c3                   	ret    
  2310fc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

0000000000231100 <__fixunstfdi>:
    const aRep: rep_t = @bitCast(rep_t, a);
  231100:	0f 29 44 24 e8       	movaps XMMWORD PTR [rsp-0x18],xmm0
  231105:	48 8b 4c 24 f0       	mov    rcx,QWORD PTR [rsp-0x10]
  23110a:	31 c0                	xor    eax,eax
    const sign = if ((aRep & signBit) != 0) i32(-1) else i32(1);
  23110c:	48 85 c9             	test   rcx,rcx
    if (sign == -1 or exponent < 0) return 0;
  23110f:	78 5c                	js     23116d <__fixunstfdi+0x6d>
  231111:	48 89 ca             	mov    rdx,rcx
  231114:	48 c1 ea 30          	shr    rdx,0x30
  231118:	89 d6                	mov    esi,edx
  23111a:	81 e6 ff 7f 00 00    	and    esi,0x7fff
  231120:	81 fe ff 3f 00 00    	cmp    esi,0x3fff
  231126:	72 45                	jb     23116d <__fixunstfdi+0x6d>
    const exponent = @intCast(i32, aAbs >> significandBits) - exponentBias;
  231128:	81 c6 01 c0 ff ff    	add    esi,0xffffc001
  23112e:	48 c7 c0 ff ff ff ff 	mov    rax,0xffffffffffffffff
    if (@intCast(c_uint, exponent) >= fixuint_t.bit_count) return ~fixuint_t(0);
  231135:	83 fe 3f             	cmp    esi,0x3f
  231138:	77 33                	ja     23116d <__fixunstfdi+0x6d>
  23113a:	48 8b 74 24 e8       	mov    rsi,QWORD PTR [rsp-0x18]
  23113f:	b0 30                	mov    al,0x30
  231141:	c4 e2 f8 f5 c1       	bzhi   rax,rcx,rax
  231146:	48 bf 00 00 00 00 00 	movabs rdi,0x1000000000000
  23114d:	00 01 00 
  231150:	48 09 c7             	or     rdi,rax
        return @intCast(fixuint_t, significand >> @intCast(Log2Int(rep_t), significandBits - exponent));
  231153:	b9 6f 00 00 00       	mov    ecx,0x6f
  231158:	29 d1                	sub    ecx,edx
  23115a:	83 e1 7f             	and    ecx,0x7f
  23115d:	48 0f ad fe          	shrd   rsi,rdi,cl
  231161:	c4 e2 f3 f7 c7       	shrx   rax,rdi,rcx
  231166:	f6 c1 40             	test   cl,0x40
  231169:	48 0f 44 c6          	cmove  rax,rsi
const fixuint = @import("fixuint.zig").fixuint;
const builtin = @import("builtin");

pub extern fn __fixunstfdi(a: f128) u64 {
    @setRuntimeSafety(builtin.is_test);
    return fixuint(f128, u64, a);
  23116d:	c3                   	ret    
  23116e:	66 90                	xchg   ax,ax

0000000000231170 <__fixunstfti>:
    const aRep: rep_t = @bitCast(rep_t, a);
  231170:	0f 29 44 24 e8       	movaps XMMWORD PTR [rsp-0x18],xmm0
  231175:	48 8b 74 24 f0       	mov    rsi,QWORD PTR [rsp-0x10]
  23117a:	31 d2                	xor    edx,edx
  23117c:	b8 00 00 00 00       	mov    eax,0x0
    const sign = if ((aRep & signBit) != 0) i32(-1) else i32(1);
  231181:	48 85 f6             	test   rsi,rsi
    if (sign == -1 or exponent < 0) return 0;
  231184:	0f 88 93 00 00 00    	js     23121d <__fixunstfti+0xad>
  23118a:	48 89 f1             	mov    rcx,rsi
  23118d:	48 c1 e9 30          	shr    rcx,0x30
  231191:	89 cf                	mov    edi,ecx
  231193:	81 e7 ff 7f 00 00    	and    edi,0x7fff
  231199:	81 ff ff 3f 00 00    	cmp    edi,0x3fff
  23119f:	72 7c                	jb     23121d <__fixunstfti+0xad>
    const exponent = @intCast(i32, aAbs >> significandBits) - exponentBias;
  2311a1:	44 8d 87 01 c0 ff ff 	lea    r8d,[rdi-0x3fff]
  2311a8:	48 c7 c0 ff ff ff ff 	mov    rax,0xffffffffffffffff
  2311af:	48 c7 c2 ff ff ff ff 	mov    rdx,0xffffffffffffffff
    if (@intCast(c_uint, exponent) >= fixuint_t.bit_count) return ~fixuint_t(0);
  2311b6:	41 83 f8 7f          	cmp    r8d,0x7f
  2311ba:	77 61                	ja     23121d <__fixunstfti+0xad>
  2311bc:	48 8b 44 24 e8       	mov    rax,QWORD PTR [rsp-0x18]
  2311c1:	b2 30                	mov    dl,0x30
  2311c3:	c4 e2 e8 f5 f6       	bzhi   rsi,rsi,rdx
  2311c8:	48 ba 00 00 00 00 00 	movabs rdx,0x1000000000000
  2311cf:	00 01 00 
  2311d2:	48 09 f2             	or     rdx,rsi
    if (exponent < significandBits) {
  2311d5:	81 ff 6e 40 00 00    	cmp    edi,0x406e
  2311db:	77 24                	ja     231201 <__fixunstfti+0x91>
        return @intCast(fixuint_t, significand >> @intCast(Log2Int(rep_t), significandBits - exponent));
  2311dd:	be 6f 00 00 00       	mov    esi,0x6f
  2311e2:	29 ce                	sub    esi,ecx
  2311e4:	83 e6 7f             	and    esi,0x7f
  2311e7:	89 f1                	mov    ecx,esi
  2311e9:	48 0f ad d0          	shrd   rax,rdx,cl
  2311ed:	c4 e2 cb f7 ca       	shrx   rcx,rdx,rsi
  2311f2:	31 d2                	xor    edx,edx
  2311f4:	40 f6 c6 40          	test   sil,0x40
  2311f8:	48 0f 45 c1          	cmovne rax,rcx
  2311fc:	48 0f 44 d1          	cmove  rdx,rcx
const fixuint = @import("fixuint.zig").fixuint;
const builtin = @import("builtin");

pub extern fn __fixunstfti(a: f128) u128 {
    @setRuntimeSafety(builtin.is_test);
    return fixuint(f128, u128, a);
  231200:	c3                   	ret    
        return @intCast(fixuint_t, significand) << @intCast(Log2Int(fixuint_t), exponent - significandBits);
  231201:	83 c1 11             	add    ecx,0x11
  231204:	83 e1 7f             	and    ecx,0x7f
  231207:	48 0f a5 c2          	shld   rdx,rax,cl
  23120b:	c4 e2 f1 f7 f0       	shlx   rsi,rax,rcx
  231210:	31 c0                	xor    eax,eax
  231212:	f6 c1 40             	test   cl,0x40
  231215:	48 0f 45 d6          	cmovne rdx,rsi
  231219:	48 0f 44 c6          	cmove  rax,rsi
  23121d:	c3                   	ret    
  23121e:	66 90                	xchg   ax,ax

0000000000231220 <__udivsi3>:
    const d = __udivsi3(a, b);
    rem.* = @bitCast(u32, @bitCast(i32, a) -% (@bitCast(i32, d) * @bitCast(i32, b)));
    return d;
}

extern fn __udivsi3(n: u32, d: u32) u32 {
  231220:	55                   	push   rbp
  231221:	41 56                	push   r14
  231223:	53                   	push   rbx
  231224:	31 c0                	xor    eax,eax
    @setRuntimeSafety(is_test);

    const n_uword_bits: c_uint = u32.bit_count;
    // special cases
    if (d == 0) return 0; // ?!
    if (n == 0) return 0;
  231226:	85 ff                	test   edi,edi
    if (d == 0) return 0; // ?!
  231228:	74 19                	je     231243 <__udivsi3+0x23>
  23122a:	85 f6                	test   esi,esi
  23122c:	74 15                	je     231243 <__udivsi3+0x23>
    var sr = @bitCast(c_uint, c_int(@clz(d)) - c_int(@clz(n)));
  23122e:	f3 0f bd ce          	lzcnt  ecx,esi
  231232:	f3 0f bd d7          	lzcnt  edx,edi
  231236:	89 cb                	mov    ebx,ecx
  231238:	29 d3                	sub    ebx,edx
    // 0 <= sr <= n_uword_bits - 1 or sr large
    if (sr > n_uword_bits - 1) {
  23123a:	83 fb 1f             	cmp    ebx,0x1f
  23123d:	77 04                	ja     231243 <__udivsi3+0x23>
        // d > r
        return 0;
    }
    if (sr == n_uword_bits - 1) {
  23123f:	75 07                	jne    231248 <__udivsi3+0x28>
  231241:	89 f8                	mov    eax,edi
  231243:	5b                   	pop    rbx
  231244:	41 5e                	pop    r14
  231246:	5d                   	pop    rbp
  231247:	c3                   	ret    
        // d == 1
        return n;
    }
    sr += 1;
  231248:	44 8d 4b 01          	lea    r9d,[rbx+0x1]
    // 1 <= sr <= n_uword_bits - 1
    // Not a special case
    var q: u32 = n << @intCast(u5, n_uword_bits - sr);
  23124c:	b8 1f 00 00 00       	mov    eax,0x1f
  231251:	29 d8                	sub    eax,ebx
  231253:	c4 e2 79 f7 c7       	shlx   eax,edi,eax
    var r: u32 = n >> @intCast(u5, sr);
  231258:	c4 e2 33 f7 ff       	shrx   edi,edi,r9d
  23125d:	44 8d 46 ff          	lea    r8d,[rsi-0x1]
    var carry: u32 = 0;
    while (sr > 0) : (sr -= 1) {
  231261:	41 83 e1 03          	and    r9d,0x3
  231265:	83 fb 03             	cmp    ebx,0x3
  231268:	73 10                	jae    23127a <__udivsi3+0x5a>
  23126a:	31 c9                	xor    ecx,ecx
  23126c:	45 85 c9             	test   r9d,r9d
  23126f:	0f 85 a6 00 00 00    	jne    23131b <__udivsi3+0xfb>
  231275:	e9 c5 00 00 00       	jmp    23133f <__udivsi3+0x11f>
  23127a:	42 8d 14 0a          	lea    edx,[rdx+r9*1]
  23127e:	83 c2 ff             	add    edx,0xffffffff
  231281:	29 ca                	sub    edx,ecx
  231283:	31 c9                	xor    ecx,ecx
  231285:	41 ba 1e 01 00 00    	mov    r10d,0x11e
  23128b:	41 bb 1d 01 00 00    	mov    r11d,0x11d
  231291:	41 be 1c 01 00 00    	mov    r14d,0x11c
  231297:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  23129e:	00 00 
        // r:q = ((r:q)  << 1) | carry
        r = (r << 1) | (q >> @intCast(u5, n_uword_bits - 1));
  2312a0:	0f a4 c7 01          	shld   edi,eax,0x1
        q = (q << 1) | carry;
  2312a4:	8d 1c 00             	lea    ebx,[rax+rax*1]
  2312a7:	09 cb                	or     ebx,ecx
        // if (r.all >= d.all)
        // {
        //      r.all -= d.all;
        //      carry = 1;
        // }
        const s = @intCast(i32, d -% r -% 1) >> @intCast(u5, n_uword_bits - 1);
  2312a9:	44 89 c1             	mov    ecx,r8d
  2312ac:	29 f9                	sub    ecx,edi
  2312ae:	c1 f9 1f             	sar    ecx,0x1f
        carry = @intCast(u32, s & 1);
  2312b1:	89 cd                	mov    ebp,ecx
  2312b3:	83 e5 01             	and    ebp,0x1
        r -= d & @bitCast(u32, s);
  2312b6:	21 f1                	and    ecx,esi
  2312b8:	29 cf                	sub    edi,ecx
        r = (r << 1) | (q >> @intCast(u5, n_uword_bits - 1));
  2312ba:	c4 e2 28 f7 c8       	bextr  ecx,eax,r10d
  2312bf:	8d 0c 79             	lea    ecx,[rcx+rdi*2]
        q = (q << 1) | carry;
  2312c2:	8d 7c 5d 00          	lea    edi,[rbp+rbx*2+0x0]
        const s = @intCast(i32, d -% r -% 1) >> @intCast(u5, n_uword_bits - 1);
  2312c6:	44 89 c3             	mov    ebx,r8d
  2312c9:	29 cb                	sub    ebx,ecx
  2312cb:	c1 fb 1f             	sar    ebx,0x1f
        carry = @intCast(u32, s & 1);
  2312ce:	89 dd                	mov    ebp,ebx
  2312d0:	83 e5 01             	and    ebp,0x1
        r -= d & @bitCast(u32, s);
  2312d3:	21 f3                	and    ebx,esi
  2312d5:	29 d9                	sub    ecx,ebx
        r = (r << 1) | (q >> @intCast(u5, n_uword_bits - 1));
  2312d7:	c4 e2 20 f7 d8       	bextr  ebx,eax,r11d
  2312dc:	8d 0c 4b             	lea    ecx,[rbx+rcx*2]
        q = (q << 1) | carry;
  2312df:	8d 5c 7d 00          	lea    ebx,[rbp+rdi*2+0x0]
        const s = @intCast(i32, d -% r -% 1) >> @intCast(u5, n_uword_bits - 1);
  2312e3:	44 89 c7             	mov    edi,r8d
  2312e6:	29 cf                	sub    edi,ecx
  2312e8:	c1 ff 1f             	sar    edi,0x1f
        carry = @intCast(u32, s & 1);
  2312eb:	89 fd                	mov    ebp,edi
  2312ed:	83 e5 01             	and    ebp,0x1
        r -= d & @bitCast(u32, s);
  2312f0:	21 f7                	and    edi,esi
  2312f2:	29 f9                	sub    ecx,edi
        r = (r << 1) | (q >> @intCast(u5, n_uword_bits - 1));
  2312f4:	c4 e2 08 f7 c0       	bextr  eax,eax,r14d
  2312f9:	8d 3c 48             	lea    edi,[rax+rcx*2]
        q = (q << 1) | carry;
  2312fc:	8d 44 5d 00          	lea    eax,[rbp+rbx*2+0x0]
        const s = @intCast(i32, d -% r -% 1) >> @intCast(u5, n_uword_bits - 1);
  231300:	44 89 c3             	mov    ebx,r8d
  231303:	29 fb                	sub    ebx,edi
  231305:	c1 fb 1f             	sar    ebx,0x1f
        carry = @intCast(u32, s & 1);
  231308:	89 d9                	mov    ecx,ebx
  23130a:	83 e1 01             	and    ecx,0x1
        r -= d & @bitCast(u32, s);
  23130d:	21 f3                	and    ebx,esi
  23130f:	29 df                	sub    edi,ebx
    while (sr > 0) : (sr -= 1) {
  231311:	83 c2 04             	add    edx,0x4
  231314:	75 8a                	jne    2312a0 <__udivsi3+0x80>
  231316:	45 85 c9             	test   r9d,r9d
  231319:	74 24                	je     23133f <__udivsi3+0x11f>
  23131b:	41 f7 d9             	neg    r9d
  23131e:	66 90                	xchg   ax,ax
        r = (r << 1) | (q >> @intCast(u5, n_uword_bits - 1));
  231320:	0f a4 c7 01          	shld   edi,eax,0x1
        q = (q << 1) | carry;
  231324:	01 c0                	add    eax,eax
  231326:	09 c8                	or     eax,ecx
        const s = @intCast(i32, d -% r -% 1) >> @intCast(u5, n_uword_bits - 1);
  231328:	44 89 c2             	mov    edx,r8d
  23132b:	29 fa                	sub    edx,edi
  23132d:	c1 fa 1f             	sar    edx,0x1f
        carry = @intCast(u32, s & 1);
  231330:	89 d1                	mov    ecx,edx
  231332:	83 e1 01             	and    ecx,0x1
        r -= d & @bitCast(u32, s);
  231335:	21 f2                	and    edx,esi
  231337:	29 d7                	sub    edi,edx
    while (sr > 0) : (sr -= 1) {
  231339:	41 83 c1 01          	add    r9d,0x1
  23133d:	75 e1                	jne    231320 <__udivsi3+0x100>
    }
    q = (q << 1) | carry;
  23133f:	01 c0                	add    eax,eax
  231341:	09 c8                	or     eax,ecx
  231343:	5b                   	pop    rbx
  231344:	41 5e                	pop    r14
  231346:	5d                   	pop    rbp
  231347:	c3                   	ret    
  231348:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  23134f:	00 

0000000000231350 <__udivdi3>:
    return __udivmoddi4(a, b, null);
  231350:	31 d2                	xor    edx,edx
  231352:	e9 a9 e6 ff ff       	jmp    22fa00 <__udivmoddi4>
  231357:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  23135e:	00 00 

0000000000231360 <__umoddi3>:
extern fn __umoddi3(a: u64, b: u64) u64 {
  231360:	50                   	push   rax
  231361:	48 89 e2             	mov    rdx,rsp
    _ = __udivmoddi4(a, b, &r);
  231364:	e8 97 e6 ff ff       	call   22fa00 <__udivmoddi4>
    return r;
  231369:	48 8b 04 24          	mov    rax,QWORD PTR [rsp]
  23136d:	59                   	pop    rcx
  23136e:	c3                   	ret    
  23136f:	90                   	nop

0000000000231370 <__udivmodsi4>:
extern fn __udivmodsi4(a: u32, b: u32, rem: *u32) u32 {
  231370:	55                   	push   rbp
  231371:	41 57                	push   r15
  231373:	41 56                	push   r14
  231375:	41 55                	push   r13
  231377:	41 54                	push   r12
  231379:	53                   	push   rbx
  23137a:	31 c0                	xor    eax,eax
    if (n == 0) return 0;
  23137c:	85 ff                	test   edi,edi
    if (d == 0) return 0; // ?!
  23137e:	0f 84 33 01 00 00    	je     2314b7 <__udivmodsi4+0x147>
  231384:	85 f6                	test   esi,esi
  231386:	0f 84 2b 01 00 00    	je     2314b7 <__udivmodsi4+0x147>
    var sr = @bitCast(c_uint, c_int(@clz(d)) - c_int(@clz(n)));
  23138c:	f3 44 0f bd de       	lzcnt  r11d,esi
  231391:	f3 0f bd df          	lzcnt  ebx,edi
  231395:	44 89 dd             	mov    ebp,r11d
  231398:	29 dd                	sub    ebp,ebx
    if (sr > n_uword_bits - 1) {
  23139a:	83 fd 1f             	cmp    ebp,0x1f
  23139d:	0f 87 14 01 00 00    	ja     2314b7 <__udivmodsi4+0x147>
  2313a3:	89 f8                	mov    eax,edi
    if (sr == n_uword_bits - 1) {
  2313a5:	0f 84 0c 01 00 00    	je     2314b7 <__udivmodsi4+0x147>
    sr += 1;
  2313ab:	44 8d 4d 01          	lea    r9d,[rbp+0x1]
    var q: u32 = n << @intCast(u5, n_uword_bits - sr);
  2313af:	b8 1f 00 00 00       	mov    eax,0x1f
  2313b4:	29 e8                	sub    eax,ebp
  2313b6:	c4 e2 79 f7 c7       	shlx   eax,edi,eax
    var r: u32 = n >> @intCast(u5, sr);
  2313bb:	c4 e2 33 f7 cf       	shrx   ecx,edi,r9d
  2313c0:	44 8d 46 ff          	lea    r8d,[rsi-0x1]
    while (sr > 0) : (sr -= 1) {
  2313c4:	41 83 e1 03          	and    r9d,0x3
  2313c8:	83 fd 03             	cmp    ebp,0x3
  2313cb:	73 11                	jae    2313de <__udivmodsi4+0x6e>
  2313cd:	45 31 db             	xor    r11d,r11d
  2313d0:	45 85 c9             	test   r9d,r9d
  2313d3:	0f 85 aa 00 00 00    	jne    231483 <__udivmodsi4+0x113>
  2313d9:	e9 d4 00 00 00       	jmp    2314b2 <__udivmodsi4+0x142>
  2313de:	46 8d 14 0b          	lea    r10d,[rbx+r9*1]
  2313e2:	41 83 c2 ff          	add    r10d,0xffffffff
  2313e6:	45 29 da             	sub    r10d,r11d
  2313e9:	45 31 db             	xor    r11d,r11d
  2313ec:	41 be 1e 01 00 00    	mov    r14d,0x11e
  2313f2:	41 bf 1d 01 00 00    	mov    r15d,0x11d
  2313f8:	41 bc 1c 01 00 00    	mov    r12d,0x11c
  2313fe:	66 90                	xchg   ax,ax
        r = (r << 1) | (q >> @intCast(u5, n_uword_bits - 1));
  231400:	0f a4 c1 01          	shld   ecx,eax,0x1
        q = (q << 1) | carry;
  231404:	44 8d 2c 00          	lea    r13d,[rax+rax*1]
  231408:	45 09 dd             	or     r13d,r11d
        const s = @intCast(i32, d -% r -% 1) >> @intCast(u5, n_uword_bits - 1);
  23140b:	44 89 c3             	mov    ebx,r8d
  23140e:	29 cb                	sub    ebx,ecx
  231410:	c1 fb 1f             	sar    ebx,0x1f
        carry = @intCast(u32, s & 1);
  231413:	89 dd                	mov    ebp,ebx
  231415:	83 e5 01             	and    ebp,0x1
        r -= d & @bitCast(u32, s);
  231418:	21 f3                	and    ebx,esi
  23141a:	29 d9                	sub    ecx,ebx
        r = (r << 1) | (q >> @intCast(u5, n_uword_bits - 1));
  23141c:	c4 e2 08 f7 d8       	bextr  ebx,eax,r14d
  231421:	8d 0c 4b             	lea    ecx,[rbx+rcx*2]
        q = (q << 1) | carry;
  231424:	46 8d 5c 6d 00       	lea    r11d,[rbp+r13*2+0x0]
        const s = @intCast(i32, d -% r -% 1) >> @intCast(u5, n_uword_bits - 1);
  231429:	44 89 c3             	mov    ebx,r8d
  23142c:	29 cb                	sub    ebx,ecx
  23142e:	c1 fb 1f             	sar    ebx,0x1f
        carry = @intCast(u32, s & 1);
  231431:	89 dd                	mov    ebp,ebx
  231433:	83 e5 01             	and    ebp,0x1
        r -= d & @bitCast(u32, s);
  231436:	21 f3                	and    ebx,esi
  231438:	29 d9                	sub    ecx,ebx
        r = (r << 1) | (q >> @intCast(u5, n_uword_bits - 1));
  23143a:	c4 e2 00 f7 d8       	bextr  ebx,eax,r15d
  23143f:	8d 0c 4b             	lea    ecx,[rbx+rcx*2]
        q = (q << 1) | carry;
  231442:	46 8d 5c 5d 00       	lea    r11d,[rbp+r11*2+0x0]
        const s = @intCast(i32, d -% r -% 1) >> @intCast(u5, n_uword_bits - 1);
  231447:	44 89 c3             	mov    ebx,r8d
  23144a:	29 cb                	sub    ebx,ecx
  23144c:	c1 fb 1f             	sar    ebx,0x1f
        carry = @intCast(u32, s & 1);
  23144f:	89 dd                	mov    ebp,ebx
  231451:	83 e5 01             	and    ebp,0x1
        r -= d & @bitCast(u32, s);
  231454:	21 f3                	and    ebx,esi
  231456:	29 d9                	sub    ecx,ebx
        r = (r << 1) | (q >> @intCast(u5, n_uword_bits - 1));
  231458:	c4 e2 18 f7 c0       	bextr  eax,eax,r12d
  23145d:	8d 0c 48             	lea    ecx,[rax+rcx*2]
        q = (q << 1) | carry;
  231460:	42 8d 44 5d 00       	lea    eax,[rbp+r11*2+0x0]
        const s = @intCast(i32, d -% r -% 1) >> @intCast(u5, n_uword_bits - 1);
  231465:	44 89 c3             	mov    ebx,r8d
  231468:	29 cb                	sub    ebx,ecx
  23146a:	c1 fb 1f             	sar    ebx,0x1f
        carry = @intCast(u32, s & 1);
  23146d:	41 89 db             	mov    r11d,ebx
  231470:	41 83 e3 01          	and    r11d,0x1
        r -= d & @bitCast(u32, s);
  231474:	21 f3                	and    ebx,esi
  231476:	29 d9                	sub    ecx,ebx
    while (sr > 0) : (sr -= 1) {
  231478:	41 83 c2 04          	add    r10d,0x4
  23147c:	75 82                	jne    231400 <__udivmodsi4+0x90>
  23147e:	45 85 c9             	test   r9d,r9d
  231481:	74 2f                	je     2314b2 <__udivmodsi4+0x142>
  231483:	41 f7 d9             	neg    r9d
  231486:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  23148d:	00 00 00 
        r = (r << 1) | (q >> @intCast(u5, n_uword_bits - 1));
  231490:	0f a4 c1 01          	shld   ecx,eax,0x1
        q = (q << 1) | carry;
  231494:	01 c0                	add    eax,eax
  231496:	44 09 d8             	or     eax,r11d
        const s = @intCast(i32, d -% r -% 1) >> @intCast(u5, n_uword_bits - 1);
  231499:	44 89 c5             	mov    ebp,r8d
  23149c:	29 cd                	sub    ebp,ecx
  23149e:	c1 fd 1f             	sar    ebp,0x1f
        carry = @intCast(u32, s & 1);
  2314a1:	41 89 eb             	mov    r11d,ebp
  2314a4:	41 83 e3 01          	and    r11d,0x1
        r -= d & @bitCast(u32, s);
  2314a8:	21 f5                	and    ebp,esi
  2314aa:	29 e9                	sub    ecx,ebp
    while (sr > 0) : (sr -= 1) {
  2314ac:	41 83 c1 01          	add    r9d,0x1
  2314b0:	75 de                	jne    231490 <__udivmodsi4+0x120>
    q = (q << 1) | carry;
  2314b2:	01 c0                	add    eax,eax
  2314b4:	44 09 d8             	or     eax,r11d
    rem.* = @bitCast(u32, @bitCast(i32, a) -% (@bitCast(i32, d) * @bitCast(i32, b)));
  2314b7:	0f af f0             	imul   esi,eax
  2314ba:	29 f7                	sub    edi,esi
  2314bc:	89 3a                	mov    DWORD PTR [rdx],edi
    return d;
  2314be:	5b                   	pop    rbx
  2314bf:	41 5c                	pop    r12
  2314c1:	41 5d                	pop    r13
  2314c3:	41 5e                	pop    r14
  2314c5:	41 5f                	pop    r15
  2314c7:	5d                   	pop    rbp
  2314c8:	c3                   	ret    
  2314c9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

00000000002314d0 <__divti3>:
const compiler_rt = @import("index.zig");

pub extern fn __divti3(a: i128, b: i128) i128 {
    @setRuntimeSafety(builtin.is_test);

    const s_a = a >> (i128.bit_count - 1);
  2314d0:	41 56                	push   r14
  2314d2:	53                   	push   rbx
  2314d3:	50                   	push   rax
  2314d4:	48 89 f0             	mov    rax,rsi
  2314d7:	48 c1 f8 3f          	sar    rax,0x3f
    const s_b = b >> (i128.bit_count - 1);
  2314db:	49 89 ce             	mov    r14,rcx
  2314de:	49 31 f6             	xor    r14,rsi
  2314e1:	48 89 cb             	mov    rbx,rcx
  2314e4:	48 c1 fb 3f          	sar    rbx,0x3f

    const an = (a ^ s_a) -% s_a;
  2314e8:	48 31 c6             	xor    rsi,rax
  2314eb:	48 31 c7             	xor    rdi,rax
  2314ee:	48 29 c7             	sub    rdi,rax
  2314f1:	48 19 c6             	sbb    rsi,rax
    const bn = (b ^ s_b) -% s_b;
  2314f4:	48 31 d9             	xor    rcx,rbx
  2314f7:	48 31 da             	xor    rdx,rbx
  2314fa:	48 29 da             	sub    rdx,rbx
  2314fd:	48 19 d9             	sbb    rcx,rbx

    const r = udivmod(u128, @bitCast(u128, an), @bitCast(u128, bn), null);
  231500:	45 31 c0             	xor    r8d,r8d
  231503:	e8 18 00 00 00       	call   231520 <udivmod.14>
    const s = s_a ^ s_b;
  231508:	49 c1 fe 3f          	sar    r14,0x3f
    return (@bitCast(i128, r) ^ s) -% s;
  23150c:	4c 31 f2             	xor    rdx,r14
  23150f:	4c 31 f0             	xor    rax,r14
  231512:	4c 29 f0             	sub    rax,r14
  231515:	4c 19 f2             	sbb    rdx,r14
  231518:	48 83 c4 08          	add    rsp,0x8
  23151c:	5b                   	pop    rbx
  23151d:	41 5e                	pop    r14
  23151f:	c3                   	ret    

0000000000231520 <udivmod.14>:
pub fn udivmod(comptime DoubleInt: type, a: DoubleInt, b: DoubleInt, maybe_rem: ?*DoubleInt) DoubleInt {
  231520:	55                   	push   rbp
  231521:	41 57                	push   r15
  231523:	41 56                	push   r14
  231525:	41 55                	push   r13
  231527:	41 54                	push   r12
  231529:	53                   	push   rbx
  23152a:	49 89 d1             	mov    r9,rdx
    if (n[high] == 0) {
  23152d:	48 85 f6             	test   rsi,rsi
  231530:	74 38                	je     23156a <udivmod.14+0x4a>
    if (d[low] == 0) {
  231532:	4d 85 c9             	test   r9,r9
  231535:	74 55                	je     23158c <udivmod.14+0x6c>
  231537:	48 85 c9             	test   rcx,rcx
        if (d[high] == 0) {
  23153a:	0f 84 af 00 00 00    	je     2315ef <udivmod.14+0xcf>
            sr = @bitCast(c_uint, c_int(@clz(d[high])) - c_int(@clz(n[high])));
  231540:	f3 48 0f bd c1       	lzcnt  rax,rcx
  231545:	f3 48 0f bd d6       	lzcnt  rdx,rsi
  23154a:	29 d0                	sub    eax,edx
            if (sr > SingleInt.bit_count - 1) {
  23154c:	83 f8 40             	cmp    eax,0x40
  23154f:	0f 82 23 01 00 00    	jb     231678 <udivmod.14+0x158>
  231555:	4d 85 c0             	test   r8,r8
  231558:	0f 84 3f 01 00 00    	je     23169d <udivmod.14+0x17d>
  23155e:	49 89 38             	mov    QWORD PTR [r8],rdi
  231561:	49 89 70 08          	mov    QWORD PTR [r8+0x8],rsi
  231565:	e9 33 01 00 00       	jmp    23169d <udivmod.14+0x17d>
        if (d[high] == 0) {
  23156a:	48 85 c9             	test   rcx,rcx
  23156d:	0f 84 df 00 00 00    	je     231652 <udivmod.14+0x132>
  231573:	4d 85 c0             	test   r8,r8
        if (maybe_rem) |rem| {
  231576:	0f 84 21 01 00 00    	je     23169d <udivmod.14+0x17d>
            rem.* = n[low];
  23157c:	49 89 38             	mov    QWORD PTR [r8],rdi
  23157f:	49 c7 40 08 00 00 00 	mov    QWORD PTR [r8+0x8],0x0
  231586:	00 
  231587:	e9 11 01 00 00       	jmp    23169d <udivmod.14+0x17d>
  23158c:	48 85 c9             	test   rcx,rcx
        if (d[high] == 0) {
  23158f:	0f 84 fa 00 00 00    	je     23168f <udivmod.14+0x16f>
        if (n[low] == 0) {
  231595:	48 85 ff             	test   rdi,rdi
  231598:	0f 84 6e 02 00 00    	je     23180c <udivmod.14+0x2ec>
        if ((d[high] & (d[high] - 1)) == 0) {
  23159e:	48 8d 41 ff          	lea    rax,[rcx-0x1]
  2315a2:	48 85 c8             	test   rax,rcx
  2315a5:	0f 84 c3 02 00 00    	je     23186e <udivmod.14+0x34e>
        sr = @bitCast(c_uint, c_int(@clz(d[high])) - c_int(@clz(n[high])));
  2315ab:	f3 4c 0f bd d1       	lzcnt  r10,rcx
  2315b0:	f3 48 0f bd c6       	lzcnt  rax,rsi
  2315b5:	41 29 c2             	sub    r10d,eax
        if (sr > SingleInt.bit_count - 2) {
  2315b8:	41 83 fa 3f          	cmp    r10d,0x3f
  2315bc:	73 97                	jae    231555 <udivmod.14+0x35>
        q[high] = n[low] << @intCast(Log2SingleInt, SingleInt.bit_count - sr);
  2315be:	b8 3f 00 00 00       	mov    eax,0x3f
  2315c3:	44 29 d0             	sub    eax,r10d
        sr += 1;
  2315c6:	41 83 c2 01          	add    r10d,0x1
        q[high] = n[low] << @intCast(Log2SingleInt, SingleInt.bit_count - sr);
  2315ca:	83 e0 3f             	and    eax,0x3f
        r[high] = n[high] >> @intCast(Log2SingleInt, sr);
  2315cd:	44 89 d5             	mov    ebp,r10d
  2315d0:	83 e5 3f             	and    ebp,0x3f
  2315d3:	c4 e2 d3 f7 d6       	shrx   rdx,rsi,rbp
        r[low] = (n[high] << @intCast(Log2SingleInt, SingleInt.bit_count - sr)) | (n[low] >> @intCast(Log2SingleInt, sr));
  2315d8:	c4 e2 f9 f7 de       	shlx   rbx,rsi,rax
  2315dd:	c4 e2 d3 f7 f7       	shrx   rsi,rdi,rbp
        q[high] = n[low] << @intCast(Log2SingleInt, SingleInt.bit_count - sr);
  2315e2:	c4 e2 f9 f7 ff       	shlx   rdi,rdi,rax
        r[low] = (n[high] << @intCast(Log2SingleInt, SingleInt.bit_count - sr)) | (n[low] >> @intCast(Log2SingleInt, sr));
  2315e7:	48 09 de             	or     rsi,rbx
  2315ea:	e9 de 00 00 00       	jmp    2316cd <udivmod.14+0x1ad>
            if ((d[low] & (d[low] - 1)) == 0) {
  2315ef:	49 8d 41 ff          	lea    rax,[r9-0x1]
  2315f3:	4c 85 c8             	test   rax,r9
  2315f6:	0f 84 36 02 00 00    	je     231832 <udivmod.14+0x312>
            sr = 1 + SingleInt.bit_count + c_uint(@clz(d[low])) - c_uint(@clz(n[high]));
  2315fc:	f3 4d 0f bd d1       	lzcnt  r10,r9
  231601:	41 83 c2 41          	add    r10d,0x41
  231605:	f3 48 0f bd c6       	lzcnt  rax,rsi
  23160a:	41 29 c2             	sub    r10d,eax
            if (sr == SingleInt.bit_count) {
  23160d:	41 83 fa 40          	cmp    r10d,0x40
  231611:	74 6f                	je     231682 <udivmod.14+0x162>
  231613:	44 89 d3             	mov    ebx,r10d
  231616:	f7 db                	neg    ebx
  231618:	83 e3 3f             	and    ebx,0x3f
  23161b:	c4 62 e1 f7 e7       	shlx   r12,rdi,rbx
            } else if (sr < SingleInt.bit_count) {
  231620:	41 83 fa 40          	cmp    r10d,0x40
  231624:	0f 83 90 02 00 00    	jae    2318ba <udivmod.14+0x39a>
  23162a:	31 ed                	xor    ebp,ebp
    while (sr > 0) : (sr -= 1) {
  23162c:	45 85 d2             	test   r10d,r10d
  23162f:	0f 84 de 02 00 00    	je     231913 <udivmod.14+0x3f3>
  231635:	44 89 d5             	mov    ebp,r10d
  231638:	83 e5 3f             	and    ebp,0x3f
  23163b:	c4 e2 d3 f7 d6       	shrx   rdx,rsi,rbp
  231640:	c4 e2 e1 f7 de       	shlx   rbx,rsi,rbx
  231645:	c4 e2 d3 f7 f7       	shrx   rsi,rdi,rbp
  23164a:	48 09 de             	or     rsi,rbx
  23164d:	4c 89 e7             	mov    rdi,r12
  231650:	eb 7b                	jmp    2316cd <udivmod.14+0x1ad>
  231652:	4d 85 c0             	test   r8,r8
            if (maybe_rem) |rem| {
  231655:	0f 84 40 02 00 00    	je     23189b <udivmod.14+0x37b>
  23165b:	48 89 f8             	mov    rax,rdi
  23165e:	4c 09 c8             	or     rax,r9
  231661:	48 c1 e8 20          	shr    rax,0x20
  231665:	0f 84 1e 02 00 00    	je     231889 <udivmod.14+0x369>
  23166b:	31 d2                	xor    edx,edx
  23166d:	48 89 f8             	mov    rax,rdi
  231670:	49 f7 f1             	div    r9
  231673:	e9 18 02 00 00       	jmp    231890 <udivmod.14+0x370>
            sr += 1;
  231678:	44 8d 50 01          	lea    r10d,[rax+0x1]
            if (sr == SingleInt.bit_count) {
  23167c:	41 83 fa 40          	cmp    r10d,0x40
  231680:	75 24                	jne    2316a6 <udivmod.14+0x186>
  231682:	41 ba 40 00 00 00    	mov    r10d,0x40
  231688:	45 31 e4             	xor    r12d,r12d
  23168b:	31 d2                	xor    edx,edx
  23168d:	eb 41                	jmp    2316d0 <udivmod.14+0x1b0>
            if (maybe_rem) |rem| {
  23168f:	4d 85 c0             	test   r8,r8
  231692:	74 09                	je     23169d <udivmod.14+0x17d>
                rem.* = n[high] % d[low];
  231694:	c5 f8 57 c0          	vxorps xmm0,xmm0,xmm0
  231698:	c4 c1 78 11 00       	vmovups XMMWORD PTR [r8],xmm0
  23169d:	31 ff                	xor    edi,edi
  23169f:	31 f6                	xor    esi,esi
  2316a1:	e9 5b 01 00 00       	jmp    231801 <udivmod.14+0x2e1>
                r[high] = n[high] >> @intCast(Log2SingleInt, sr);
  2316a6:	44 89 d5             	mov    ebp,r10d
  2316a9:	83 e5 3f             	and    ebp,0x3f
  2316ac:	c4 e2 d3 f7 d6       	shrx   rdx,rsi,rbp
  2316b1:	bb 3f 00 00 00       	mov    ebx,0x3f
                r[low] = (n[high] << @intCast(Log2SingleInt, SingleInt.bit_count - sr)) | (n[low] >> @intCast(Log2SingleInt, sr));
  2316b6:	29 c3                	sub    ebx,eax
  2316b8:	83 e3 3f             	and    ebx,0x3f
  2316bb:	c4 e2 e1 f7 c6       	shlx   rax,rsi,rbx
  2316c0:	c4 e2 d3 f7 f7       	shrx   rsi,rdi,rbp
  2316c5:	48 09 c6             	or     rsi,rax
                q[high] = n[low] << @intCast(Log2SingleInt, SingleInt.bit_count - sr);
  2316c8:	c4 e2 e1 f7 ff       	shlx   rdi,rdi,rbx
  2316cd:	45 31 e4             	xor    r12d,r12d
  2316d0:	4d 89 cf             	mov    r15,r9
  2316d3:	49 83 c7 ff          	add    r15,0xffffffffffffffff
  2316d7:	49 89 cb             	mov    r11,rcx
  2316da:	49 83 d3 ff          	adc    r11,0xffffffffffffffff
    while (sr > 0) : (sr -= 1) {
  2316de:	44 89 d0             	mov    eax,r10d
  2316e1:	83 e0 01             	and    eax,0x1
  2316e4:	31 ed                	xor    ebp,ebp
  2316e6:	41 83 fa 01          	cmp    r10d,0x1
  2316ea:	75 0f                	jne    2316fb <udivmod.14+0x1db>
  2316ec:	31 db                	xor    ebx,ebx
  2316ee:	85 c0                	test   eax,eax
  2316f0:	0f 85 ac 00 00 00    	jne    2317a2 <udivmod.14+0x282>
  2316f6:	e9 da 00 00 00       	jmp    2317d5 <udivmod.14+0x2b5>
  2316fb:	4c 89 44 24 f8       	mov    QWORD PTR [rsp-0x8],r8
  231700:	89 44 24 f4          	mov    DWORD PTR [rsp-0xc],eax
  231704:	41 89 c5             	mov    r13d,eax
  231707:	45 29 d5             	sub    r13d,r10d
  23170a:	41 ba 3e 01 00 00    	mov    r10d,0x13e
        r[high] = (r[high] << 1) | (r[low] >> (SingleInt.bit_count - 1));
  231710:	48 0f a4 f2 01       	shld   rdx,rsi,0x1
        r[low] = (r[low] << 1) | (q[high] >> (SingleInt.bit_count - 1));
  231715:	48 0f a4 fe 01       	shld   rsi,rdi,0x1
        q[high] = (q[high] << 1) | (q[low] >> (SingleInt.bit_count - 1));
  23171a:	48 89 f8             	mov    rax,rdi
  23171d:	4c 0f a4 e0 01       	shld   rax,r12,0x1
        q[low] = (q[low] << 1) | carry;
  231722:	4b 8d 1c 24          	lea    rbx,[r12+r12*1]
  231726:	89 ed                	mov    ebp,ebp
  231728:	48 09 dd             	or     rbp,rbx
        const s: SignedDoubleInt = @intCast(SignedDoubleInt, b -% r_all -% 1) >> (DoubleInt.bit_count - 1);
  23172b:	49 39 f7             	cmp    r15,rsi
  23172e:	4c 89 db             	mov    rbx,r11
  231731:	48 19 d3             	sbb    rbx,rdx
  231734:	48 c1 fb 3f          	sar    rbx,0x3f
        carry = @intCast(u32, s & 1);
  231738:	41 89 de             	mov    r14d,ebx
  23173b:	41 83 e6 01          	and    r14d,0x1
        r_all -= b & @bitCast(DoubleInt, s);
  23173f:	49 89 d8             	mov    r8,rbx
  231742:	49 21 c8             	and    r8,rcx
  231745:	4c 21 cb             	and    rbx,r9
  231748:	48 29 de             	sub    rsi,rbx
  23174b:	4c 19 c2             	sbb    rdx,r8
        r[high] = (r[high] << 1) | (r[low] >> (SingleInt.bit_count - 1));
  23174e:	48 0f a4 f2 01       	shld   rdx,rsi,0x1
        r[low] = (r[low] << 1) | (q[high] >> (SingleInt.bit_count - 1));
  231753:	c4 e2 a8 f7 ff       	bextr  rdi,rdi,r10
  231758:	48 8d 34 77          	lea    rsi,[rdi+rsi*2]
        q[high] = (q[high] << 1) | (q[low] >> (SingleInt.bit_count - 1));
  23175c:	c4 c2 a8 f7 fc       	bextr  rdi,r12,r10
  231761:	48 8d 3c 47          	lea    rdi,[rdi+rax*2]
        q[low] = (q[low] << 1) | carry;
  231765:	4d 8d 24 6e          	lea    r12,[r14+rbp*2]
        const s: SignedDoubleInt = @intCast(SignedDoubleInt, b -% r_all -% 1) >> (DoubleInt.bit_count - 1);
  231769:	49 39 f7             	cmp    r15,rsi
  23176c:	4c 89 d8             	mov    rax,r11
  23176f:	48 19 d0             	sbb    rax,rdx
  231772:	48 c1 f8 3f          	sar    rax,0x3f
        carry = @intCast(u32, s & 1);
  231776:	89 c5                	mov    ebp,eax
  231778:	83 e5 01             	and    ebp,0x1
        r_all -= b & @bitCast(DoubleInt, s);
  23177b:	48 89 c3             	mov    rbx,rax
  23177e:	48 21 cb             	and    rbx,rcx
  231781:	4c 21 c8             	and    rax,r9
  231784:	48 29 c6             	sub    rsi,rax
  231787:	48 19 da             	sbb    rdx,rbx
    while (sr > 0) : (sr -= 1) {
  23178a:	41 83 c5 02          	add    r13d,0x2
  23178e:	75 80                	jne    231710 <udivmod.14+0x1f0>
  231790:	89 eb                	mov    ebx,ebp
  231792:	49 89 f2             	mov    r10,rsi
  231795:	4c 8b 44 24 f8       	mov    r8,QWORD PTR [rsp-0x8]
  23179a:	8b 44 24 f4          	mov    eax,DWORD PTR [rsp-0xc]
  23179e:	85 c0                	test   eax,eax
  2317a0:	74 33                	je     2317d5 <udivmod.14+0x2b5>
        r[high] = (r[high] << 1) | (r[low] >> (SingleInt.bit_count - 1));
  2317a2:	48 0f a4 f2 01       	shld   rdx,rsi,0x1
        r[low] = (r[low] << 1) | (q[high] >> (SingleInt.bit_count - 1));
  2317a7:	48 0f a4 fe 01       	shld   rsi,rdi,0x1
        const s: SignedDoubleInt = @intCast(SignedDoubleInt, b -% r_all -% 1) >> (DoubleInt.bit_count - 1);
  2317ac:	49 39 f7             	cmp    r15,rsi
  2317af:	49 19 d3             	sbb    r11,rdx
  2317b2:	49 c1 fb 3f          	sar    r11,0x3f
        r_all -= b & @bitCast(DoubleInt, s);
  2317b6:	4c 21 d9             	and    rcx,r11
  2317b9:	4d 21 d9             	and    r9,r11
  2317bc:	4c 29 ce             	sub    rsi,r9
  2317bf:	48 19 ca             	sbb    rdx,rcx
        carry = @intCast(u32, s & 1);
  2317c2:	41 83 e3 01          	and    r11d,0x1
        q[high] = (q[high] << 1) | (q[low] >> (SingleInt.bit_count - 1));
  2317c6:	4c 0f a4 e7 01       	shld   rdi,r12,0x1
        q[low] = (q[low] << 1) | carry;
  2317cb:	4e 8d 24 63          	lea    r12,[rbx+r12*2]
  2317cf:	44 89 dd             	mov    ebp,r11d
  2317d2:	49 89 f2             	mov    r10,rsi
  2317d5:	48 89 f8             	mov    rax,rdi
    const q_all = ((@ptrCast(*align(@alignOf(SingleInt)) DoubleInt, &q[0]).*) << 1) | carry; // TODO issue #421
  2317d8:	89 ed                	mov    ebp,ebp
  2317da:	31 c9                	xor    ecx,ecx
  2317dc:	4c 89 e7             	mov    rdi,r12
  2317df:	31 f6                	xor    esi,esi
  2317e1:	49 89 c4             	mov    r12,rax
  2317e4:	4c 09 e6             	or     rsi,r12
  2317e7:	48 0f a4 fe 01       	shld   rsi,rdi,0x1
  2317ec:	48 09 ce             	or     rsi,rcx
  2317ef:	48 01 ff             	add    rdi,rdi
  2317f2:	48 09 ef             	or     rdi,rbp
    if (maybe_rem) |rem| {
  2317f5:	4d 85 c0             	test   r8,r8
  2317f8:	74 07                	je     231801 <udivmod.14+0x2e1>
        rem.* = r_all;
  2317fa:	4d 89 10             	mov    QWORD PTR [r8],r10
  2317fd:	49 89 50 08          	mov    QWORD PTR [r8+0x8],rdx
        return 0;
  231801:	48 89 f8             	mov    rax,rdi
  231804:	48 89 f2             	mov    rdx,rsi
  231807:	e9 fc 00 00 00       	jmp    231908 <udivmod.14+0x3e8>
            if (maybe_rem) |rem| {
  23180c:	4d 85 c0             	test   r8,r8
  23180f:	0f 84 d5 00 00 00    	je     2318ea <udivmod.14+0x3ca>
  231815:	48 89 f0             	mov    rax,rsi
  231818:	48 09 c8             	or     rax,rcx
  23181b:	48 c1 e8 20          	shr    rax,0x20
  23181f:	0f 84 b4 00 00 00    	je     2318d9 <udivmod.14+0x3b9>
  231825:	31 d2                	xor    edx,edx
  231827:	48 89 f0             	mov    rax,rsi
  23182a:	48 f7 f1             	div    rcx
  23182d:	e9 ad 00 00 00       	jmp    2318df <udivmod.14+0x3bf>
                if (maybe_rem) |rem| {
  231832:	4d 85 c0             	test   r8,r8
  231835:	74 0e                	je     231845 <udivmod.14+0x325>
                    rem.* = n[low] & (d[low] - 1);
  231837:	48 21 f8             	and    rax,rdi
  23183a:	49 89 00             	mov    QWORD PTR [r8],rax
  23183d:	49 c7 40 08 00 00 00 	mov    QWORD PTR [r8+0x8],0x0
  231844:	00 
                if (d[low] == 1) {
  231845:	49 83 f9 01          	cmp    r9,0x1
  231849:	74 b6                	je     231801 <udivmod.14+0x2e1>
                sr = @ctz(d[low]);
  23184b:	f3 49 0f bc c1       	tzcnt  rax,r9
                q[high] = n[high] >> @intCast(Log2SingleInt, sr);
  231850:	89 c1                	mov    ecx,eax
  231852:	83 e1 3f             	and    ecx,0x3f
  231855:	c4 e2 f3 f7 d6       	shrx   rdx,rsi,rcx
                q[low] = (n[high] << @intCast(Log2SingleInt, SingleInt.bit_count - sr)) | (n[low] >> @intCast(Log2SingleInt, sr));
  23185a:	f7 d8                	neg    eax
  23185c:	c4 e2 f9 f7 f6       	shlx   rsi,rsi,rax
  231861:	c4 e2 f3 f7 c7       	shrx   rax,rdi,rcx
  231866:	48 09 f0             	or     rax,rsi
  231869:	e9 9a 00 00 00       	jmp    231908 <udivmod.14+0x3e8>
            if (maybe_rem) |rem| {
  23186e:	4d 85 c0             	test   r8,r8
  231871:	74 0a                	je     23187d <udivmod.14+0x35d>
                r[high] = n[high] & (d[high] - 1);
  231873:	48 21 f0             	and    rax,rsi
                rem.* = @ptrCast(*align(@alignOf(SingleInt)) DoubleInt, &r[0]).*; // TODO issue #421
  231876:	49 89 38             	mov    QWORD PTR [r8],rdi
  231879:	49 89 40 08          	mov    QWORD PTR [r8+0x8],rax
            return n[high] >> @intCast(Log2SingleInt, @ctz(d[high]));
  23187d:	f3 48 0f bc c1       	tzcnt  rax,rcx
  231882:	c4 e2 fb f7 c6       	shrx   rax,rsi,rax
  231887:	eb 7d                	jmp    231906 <udivmod.14+0x3e6>
  231889:	31 d2                	xor    edx,edx
  23188b:	89 f8                	mov    eax,edi
  23188d:	41 f7 f1             	div    r9d
                rem.* = n[low] % d[low];
  231890:	49 89 10             	mov    QWORD PTR [r8],rdx
  231893:	49 c7 40 08 00 00 00 	mov    QWORD PTR [r8+0x8],0x0
  23189a:	00 
  23189b:	48 89 f8             	mov    rax,rdi
  23189e:	4c 09 c8             	or     rax,r9
  2318a1:	48 c1 e8 20          	shr    rax,0x20
  2318a5:	74 0a                	je     2318b1 <udivmod.14+0x391>
  2318a7:	31 d2                	xor    edx,edx
  2318a9:	48 89 f8             	mov    rax,rdi
  2318ac:	49 f7 f1             	div    r9
  2318af:	eb 55                	jmp    231906 <udivmod.14+0x3e6>
  2318b1:	31 d2                	xor    edx,edx
  2318b3:	89 f8                	mov    eax,edi
  2318b5:	41 f7 f1             	div    r9d
  2318b8:	eb 4c                	jmp    231906 <udivmod.14+0x3e6>
                q[high] = (n[high] << @intCast(Log2SingleInt, DoubleInt.bit_count - sr)) | (n[low] >> @intCast(Log2SingleInt, sr - SingleInt.bit_count));
  2318ba:	c4 e2 e1 f7 d6       	shlx   rdx,rsi,rbx
  2318bf:	44 89 d5             	mov    ebp,r10d
  2318c2:	83 e5 3f             	and    ebp,0x3f
  2318c5:	c4 e2 d3 f7 ff       	shrx   rdi,rdi,rbp
  2318ca:	48 09 d7             	or     rdi,rdx
                r[low] = n[high] >> @intCast(Log2SingleInt, sr - SingleInt.bit_count);
  2318cd:	c4 e2 d3 f7 f6       	shrx   rsi,rsi,rbp
  2318d2:	31 d2                	xor    edx,edx
  2318d4:	e9 f7 fd ff ff       	jmp    2316d0 <udivmod.14+0x1b0>
  2318d9:	31 d2                	xor    edx,edx
  2318db:	89 f0                	mov    eax,esi
  2318dd:	f7 f1                	div    ecx
                rem.* = @ptrCast(*align(@alignOf(SingleInt)) DoubleInt, &r[0]).*; // TODO issue #421
  2318df:	49 89 50 08          	mov    QWORD PTR [r8+0x8],rdx
  2318e3:	49 c7 00 00 00 00 00 	mov    QWORD PTR [r8],0x0
  2318ea:	48 89 f0             	mov    rax,rsi
  2318ed:	48 09 c8             	or     rax,rcx
  2318f0:	48 c1 e8 20          	shr    rax,0x20
  2318f4:	74 0a                	je     231900 <udivmod.14+0x3e0>
  2318f6:	31 d2                	xor    edx,edx
  2318f8:	48 89 f0             	mov    rax,rsi
  2318fb:	48 f7 f1             	div    rcx
  2318fe:	eb 06                	jmp    231906 <udivmod.14+0x3e6>
  231900:	31 d2                	xor    edx,edx
  231902:	89 f0                	mov    eax,esi
  231904:	f7 f1                	div    ecx
  231906:	31 d2                	xor    edx,edx
  231908:	5b                   	pop    rbx
  231909:	41 5c                	pop    r12
  23190b:	41 5d                	pop    r13
  23190d:	41 5e                	pop    r14
  23190f:	41 5f                	pop    r15
  231911:	5d                   	pop    rbp
  231912:	c3                   	ret    
  231913:	31 c9                	xor    ecx,ecx
  231915:	31 ff                	xor    edi,edi
  231917:	31 f6                	xor    esi,esi
  231919:	e9 c6 fe ff ff       	jmp    2317e4 <udivmod.14+0x2c4>
  23191e:	66 90                	xchg   ax,ax

0000000000231920 <__muloti4>:
const udivmod = @import("udivmod.zig").udivmod;
const builtin = @import("builtin");
const compiler_rt = @import("index.zig");

pub extern fn __muloti4(a: i128, b: i128, overflow: *c_int) i128 {
  231920:	55                   	push   rbp
  231921:	41 57                	push   r15
  231923:	41 56                	push   r14
  231925:	41 55                	push   r13
  231927:	41 54                	push   r12
  231929:	53                   	push   rbx
  23192a:	48 83 ec 28          	sub    rsp,0x28
  23192e:	4d 89 c7             	mov    r15,r8
  231931:	48 89 d5             	mov    rbp,rdx
  231934:	49 89 f4             	mov    r12,rsi
  231937:	48 89 fb             	mov    rbx,rdi
  23193a:	c4 c1 f9 6e c4       	vmovq  xmm0,r12
  23193f:	c4 e1 f9 6e cb       	vmovq  xmm1,rbx
  231944:	c5 f1 6c c0          	vpunpcklqdq xmm0,xmm1,xmm0
    @setRuntimeSafety(builtin.is_test);

    const min = @bitCast(i128, u128(1 << (i128.bit_count - 1)));
    const max = ~min;
    overflow.* = 0;
  231948:	41 c7 07 00 00 00 00 	mov    DWORD PTR [r15],0x0

    const r = a *% b;
  23194f:	48 89 e8             	mov    rax,rbp
  231952:	49 0f af c4          	imul   rax,r12
  231956:	c4 e2 8b f6 d3       	mulx   rdx,r14,rbx
  23195b:	48 01 c2             	add    rdx,rax
  23195e:	49 89 cd             	mov    r13,rcx
  231961:	4c 0f af eb          	imul   r13,rbx
  231965:	49 01 d5             	add    r13,rdx
    if (a == min) {
  231968:	48 be 00 00 00 00 00 	movabs rsi,0x8000000000000000
  23196f:	00 00 80 
  231972:	c4 e1 f9 6e ce       	vmovq  xmm1,rsi
  231977:	c5 e9 73 f9 08       	vpslldq xmm2,xmm1,0x8
  23197c:	c5 f9 74 c2          	vpcmpeqb xmm0,xmm0,xmm2
  231980:	c5 f9 d7 c0          	vpmovmskb eax,xmm0
  231984:	3d ff ff 00 00       	cmp    eax,0xffff
  231989:	75 13                	jne    23199e <__muloti4+0x7e>
        if (b != 0 and b != 1) {
  23198b:	48 83 fd 02          	cmp    rbp,0x2
  23198f:	48 83 d9 00          	sbb    rcx,0x0
  231993:	0f 83 b7 00 00 00    	jae    231a50 <__muloti4+0x130>
  231999:	e9 b9 00 00 00       	jmp    231a57 <__muloti4+0x137>
            overflow.* = 1;
        }
        return r;
    }
    if (b == min) {
  23199e:	c4 e1 f9 6e c5       	vmovq  xmm0,rbp
  2319a3:	c4 e1 f9 6e c9       	vmovq  xmm1,rcx
  2319a8:	c5 f9 6c c1          	vpunpcklqdq xmm0,xmm0,xmm1
  2319ac:	c5 f9 74 c2          	vpcmpeqb xmm0,xmm0,xmm2
  2319b0:	c5 f9 d7 c0          	vpmovmskb eax,xmm0
  2319b4:	3d ff ff 00 00       	cmp    eax,0xffff
  2319b9:	75 13                	jne    2319ce <__muloti4+0xae>
        if (a != 0 and a != 1) {
  2319bb:	48 83 fb 02          	cmp    rbx,0x2
  2319bf:	49 83 dc 00          	sbb    r12,0x0
  2319c3:	0f 83 87 00 00 00    	jae    231a50 <__muloti4+0x130>
  2319c9:	e9 89 00 00 00       	jmp    231a57 <__muloti4+0x137>
            overflow.* = 1;
        }
        return r;
    }

    const sa = a >> (i128.bit_count - 1);
  2319ce:	4c 89 e0             	mov    rax,r12
  2319d1:	48 c1 f8 3f          	sar    rax,0x3f
    const abs_a = (a ^ sa) -% sa;
  2319d5:	49 31 c4             	xor    r12,rax
  2319d8:	48 31 c3             	xor    rbx,rax
  2319db:	48 29 c3             	sub    rbx,rax
  2319de:	49 19 c4             	sbb    r12,rax
    const sb = b >> (i128.bit_count - 1);
  2319e1:	48 89 ca             	mov    rdx,rcx
  2319e4:	48 c1 fa 3f          	sar    rdx,0x3f
    const abs_b = (b ^ sb) -% sb;
  2319e8:	48 31 d1             	xor    rcx,rdx
  2319eb:	48 31 d5             	xor    rbp,rdx
  2319ee:	48 29 d5             	sub    rbp,rdx
  2319f1:	48 19 d1             	sbb    rcx,rdx

    if (abs_a < 2 or abs_b < 2) {
  2319f4:	48 83 fb 02          	cmp    rbx,0x2
  2319f8:	4c 89 e7             	mov    rdi,r12
  2319fb:	48 83 df 00          	sbb    rdi,0x0
  2319ff:	7c 56                	jl     231a57 <__muloti4+0x137>
  231a01:	48 83 fd 02          	cmp    rbp,0x2
  231a05:	48 89 cf             	mov    rdi,rcx
  231a08:	48 83 df 00          	sbb    rdi,0x0
  231a0c:	7c 49                	jl     231a57 <__muloti4+0x137>
        return r;
    }

    if (sa == sb) {
  231a0e:	c4 e1 f9 6e c2       	vmovq  xmm0,rdx
  231a13:	c5 f9 6c c0          	vpunpcklqdq xmm0,xmm0,xmm0
  231a17:	c4 e1 f9 6e c8       	vmovq  xmm1,rax
  231a1c:	c5 f1 6c c9          	vpunpcklqdq xmm1,xmm1,xmm1
  231a20:	c5 f1 74 c0          	vpcmpeqb xmm0,xmm1,xmm0
  231a24:	c5 f9 d7 c0          	vpmovmskb eax,xmm0
  231a28:	3d ff ff 00 00       	cmp    eax,0xffff
  231a2d:	75 3d                	jne    231a6c <__muloti4+0x14c>
  231a2f:	48 be ff ff ff ff ff 	movabs rsi,0x7fffffffffffffff
  231a36:	ff ff 7f 
  231a39:	48 c7 c7 ff ff ff ff 	mov    rdi,0xffffffffffffffff
  231a40:	48 89 ea             	mov    rdx,rbp
  231a43:	e8 a8 00 00 00       	call   231af0 <__udivti3>
        if (abs_a > @divFloor(max, abs_b)) {
  231a48:	48 39 d8             	cmp    rax,rbx
  231a4b:	4c 19 e2             	sbb    rdx,r12
  231a4e:	7d 07                	jge    231a57 <__muloti4+0x137>
  231a50:	41 c7 07 01 00 00 00 	mov    DWORD PTR [r15],0x1
        return r;
  231a57:	4c 89 f0             	mov    rax,r14
  231a5a:	4c 89 ea             	mov    rdx,r13
  231a5d:	48 83 c4 28          	add    rsp,0x28
  231a61:	5b                   	pop    rbx
  231a62:	41 5c                	pop    r12
  231a64:	41 5d                	pop    r13
  231a66:	41 5e                	pop    r14
  231a68:	41 5f                	pop    r15
  231a6a:	5d                   	pop    rbp
  231a6b:	c3                   	ret    
  231a6c:	31 c0                	xor    eax,eax
            overflow.* = 1;
        }
    } else {
        if (abs_a > @divFloor(min, -abs_b)) {
  231a6e:	48 f7 dd             	neg    rbp
  231a71:	48 19 c8             	sbb    rax,rcx
  231a74:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  231a79:	31 ff                	xor    edi,edi
  231a7b:	48 89 ea             	mov    rdx,rbp
  231a7e:	48 89 c1             	mov    rcx,rax
  231a81:	c5 f9 7f 54 24 10    	vmovdqa XMMWORD PTR [rsp+0x10],xmm2
  231a87:	e8 44 fa ff ff       	call   2314d0 <__divti3>
  231a8c:	48 89 d1             	mov    rcx,rdx
  231a8f:	48 85 c9             	test   rcx,rcx
  231a92:	41 0f 98 c0          	sets   r8b
  231a96:	48 89 c2             	mov    rdx,rax
  231a99:	c4 e2 eb f6 fd       	mulx   rdi,rdx,rbp
  231a9e:	48 8b 74 24 08       	mov    rsi,QWORD PTR [rsp+0x8]
  231aa3:	48 0f af f0          	imul   rsi,rax
  231aa7:	48 01 f7             	add    rdi,rsi
  231aaa:	48 0f af e9          	imul   rbp,rcx
  231aae:	48 01 fd             	add    rbp,rdi
  231ab1:	c4 e1 f9 6e c5       	vmovq  xmm0,rbp
  231ab6:	c4 e1 f9 6e ca       	vmovq  xmm1,rdx
  231abb:	c5 f1 6c c0          	vpunpcklqdq xmm0,xmm1,xmm0
  231abf:	c5 f9 74 44 24 10    	vpcmpeqb xmm0,xmm0,XMMWORD PTR [rsp+0x10]
  231ac5:	c5 f9 d7 d0          	vpmovmskb edx,xmm0
  231ac9:	81 fa ff ff 00 00    	cmp    edx,0xffff
  231acf:	0f 95 c2             	setne  dl
  231ad2:	44 20 c2             	and    dl,r8b
  231ad5:	0f b6 d2             	movzx  edx,dl
  231ad8:	48 29 d0             	sub    rax,rdx
  231adb:	48 83 d9 00          	sbb    rcx,0x0
  231adf:	48 39 d8             	cmp    rax,rbx
  231ae2:	4c 19 e1             	sbb    rcx,r12
  231ae5:	0f 8c 65 ff ff ff    	jl     231a50 <__muloti4+0x130>
  231aeb:	e9 67 ff ff ff       	jmp    231a57 <__muloti4+0x137>

0000000000231af0 <__udivti3>:
const builtin = @import("builtin");
const compiler_rt = @import("index.zig");

pub extern fn __udivmodti4(a: u128, b: u128, maybe_rem: ?*u128) u128 {
    @setRuntimeSafety(builtin.is_test);
    return udivmod(u128, a, b, maybe_rem);
  231af0:	45 31 c0             	xor    r8d,r8d
  231af3:	e9 28 fa ff ff       	jmp    231520 <udivmod.14>
  231af8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  231aff:	00 

0000000000231b00 <__udivmodti4>:
  231b00:	e9 1b fa ff ff       	jmp    231520 <udivmod.14>
  231b05:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  231b0c:	00 00 00 00 

0000000000231b10 <__umodti3>:
const udivmodti4 = @import("udivmodti4.zig");
const builtin = @import("builtin");
const compiler_rt = @import("index.zig");

pub extern fn __umodti3(a: u128, b: u128) u128 {
  231b10:	48 83 ec 18          	sub    rsp,0x18
  231b14:	4c 8d 44 24 08       	lea    r8,[rsp+0x8]
  231b19:	e8 02 fa ff ff       	call   231520 <udivmod.14>
    @setRuntimeSafety(builtin.is_test);
    var r: u128 = undefined;
    _ = udivmodti4.__udivmodti4(a, b, &r);
    return r;
  231b1e:	48 8b 44 24 08       	mov    rax,QWORD PTR [rsp+0x8]
  231b23:	48 8b 54 24 10       	mov    rdx,QWORD PTR [rsp+0x10]
  231b28:	48 83 c4 18          	add    rsp,0x18
  231b2c:	c3                   	ret    
