
./zig-cache/test:     file format elf64-x86-64


Disassembly of section .text:

0000000000208000 <assert>:
/// In Debug and ReleaseSafe modes, calls to this function are always
/// generated, and the `unreachable` statement triggers a panic.
/// In ReleaseFast and ReleaseSmall modes, calls to this function can be
/// optimized away.
pub fn assert(ok: bool) void {
    if (!ok) {
  208000:	40 f6 c7 01          	test   dil,0x1
  208004:	74 01                	je     208007 <assert+0x7>
pub fn assert(ok: bool) void {
  208006:	c3                   	ret    
        // In ReleaseFast test mode, we still want assert(false) to crash, so
        // we insert an explicit call to @panic instead of unreachable.
        // TODO we should use `assertOrPanic` in tests and remove this logic.
        if (builtin.is_test) {
            @panic("assertion failure");
  208007:	50                   	push   rax
  208008:	e8 13 0d 00 00       	call   208d20 <panic>
  20800d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000208010 <init_vdso_clock_gettime>:
const linux = std.os.linux;
const cstr = std.cstr;
const mem = std.mem;

pub fn lookup(vername: []const u8, name: []const u8) usize {
    const vdso_addr = std.os.linux_aux_raw[std.elf.AT_SYSINFO_EHDR];
  208010:	55                   	push   rbp
  208011:	41 57                	push   r15
  208013:	41 56                	push   r14
  208015:	41 55                	push   r13
  208017:	41 54                	push   r12
  208019:	53                   	push   rbx
  20801a:	4c 8b 0d 27 91 01 00 	mov    r9,QWORD PTR [rip+0x19127]        # 221148 <linux_aux_raw+0x108>
    if (vdso_addr == 0) return 0;
  208021:	4d 85 c9             	test   r9,r9
  208024:	0f 84 53 05 00 00    	je     20857d <init_vdso_clock_gettime+0x56d>

    var maybe_dynv: ?[*]usize = null;
    var base: usize = @maxValue(usize);
    {
        var i: usize = 0;
        while (i < eh.e_phnum) : ({
  20802a:	41 0f b7 51 38       	movzx  edx,WORD PTR [r9+0x38]
  20802f:	48 85 d2             	test   rdx,rdx
  208032:	0f 84 45 05 00 00    	je     20857d <init_vdso_clock_gettime+0x56d>
  208038:	49 8b 59 20          	mov    rbx,QWORD PTR [r9+0x20]
    var ph_addr: usize = vdso_addr + eh.e_phoff;
  20803c:	4c 01 cb             	add    rbx,r9
  20803f:	41 0f b7 49 36       	movzx  ecx,WORD PTR [r9+0x36]
        while (i < eh.e_phnum) : ({
  208044:	48 8d 42 ff          	lea    rax,[rdx-0x1]
  208048:	89 d5                	mov    ebp,edx
  20804a:	83 e5 03             	and    ebp,0x3
  20804d:	48 83 f8 03          	cmp    rax,0x3
  208051:	73 18                	jae    20806b <init_vdso_clock_gettime+0x5b>
  208053:	49 c7 c0 ff ff ff ff 	mov    r8,0xffffffffffffffff
  20805a:	45 31 f6             	xor    r14d,r14d
            i += 1;
            ph_addr += eh.e_phentsize;
        }) {
            const this_ph = @intToPtr(*elf.Phdr, ph_addr);
            switch (this_ph.p_type) {
  20805d:	48 85 ed             	test   rbp,rbp
  208060:	0f 85 ec 00 00 00    	jne    208152 <init_vdso_clock_gettime+0x142>
  208066:	e9 29 01 00 00       	jmp    208194 <init_vdso_clock_gettime+0x184>
        while (i < eh.e_phnum) : ({
  20806b:	48 89 e8             	mov    rax,rbp
  20806e:	48 29 d0             	sub    rax,rdx
  208071:	49 c7 c0 ff ff ff ff 	mov    r8,0xffffffffffffffff
  208078:	45 31 f6             	xor    r14d,r14d
  20807b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  208080:	48 89 da             	mov    rdx,rbx
            switch (this_ph.p_type) {
  208083:	8b 1a                	mov    ebx,DWORD PTR [rdx]
  208085:	83 fb 02             	cmp    ebx,0x2
  208088:	74 66                	je     2080f0 <init_vdso_clock_gettime+0xe0>
  20808a:	83 fb 01             	cmp    ebx,0x1
  20808d:	75 0b                	jne    20809a <init_vdso_clock_gettime+0x8a>
  20808f:	4c 8b 42 08          	mov    r8,QWORD PTR [rdx+0x8]
                elf.PT_LOAD => base = vdso_addr + this_ph.p_offset - this_ph.p_vaddr,
  208093:	4d 01 c8             	add    r8,r9
  208096:	4c 2b 42 10          	sub    r8,QWORD PTR [rdx+0x10]
            switch (this_ph.p_type) {
  20809a:	8b 1c 0a             	mov    ebx,DWORD PTR [rdx+rcx*1]
            ph_addr += eh.e_phentsize;
  20809d:	48 01 ca             	add    rdx,rcx
            switch (this_ph.p_type) {
  2080a0:	83 fb 01             	cmp    ebx,0x1
  2080a3:	74 5d                	je     208102 <init_vdso_clock_gettime+0xf2>
  2080a5:	83 fb 02             	cmp    ebx,0x2
  2080a8:	75 07                	jne    2080b1 <init_vdso_clock_gettime+0xa1>
  2080aa:	4c 8b 72 08          	mov    r14,QWORD PTR [rdx+0x8]
                elf.PT_DYNAMIC => maybe_dynv = @intToPtr([*]usize, vdso_addr + this_ph.p_offset),
  2080ae:	4d 01 ce             	add    r14,r9
            switch (this_ph.p_type) {
  2080b1:	8b 1c 11             	mov    ebx,DWORD PTR [rcx+rdx*1]
            ph_addr += eh.e_phentsize;
  2080b4:	48 01 ca             	add    rdx,rcx
            switch (this_ph.p_type) {
  2080b7:	83 fb 01             	cmp    ebx,0x1
  2080ba:	74 5c                	je     208118 <init_vdso_clock_gettime+0x108>
  2080bc:	83 fb 02             	cmp    ebx,0x2
  2080bf:	75 07                	jne    2080c8 <init_vdso_clock_gettime+0xb8>
  2080c1:	4c 8b 72 08          	mov    r14,QWORD PTR [rdx+0x8]
                elf.PT_DYNAMIC => maybe_dynv = @intToPtr([*]usize, vdso_addr + this_ph.p_offset),
  2080c5:	4d 01 ce             	add    r14,r9
            switch (this_ph.p_type) {
  2080c8:	8b 1c 11             	mov    ebx,DWORD PTR [rcx+rdx*1]
            ph_addr += eh.e_phentsize;
  2080cb:	48 01 ca             	add    rdx,rcx
            switch (this_ph.p_type) {
  2080ce:	83 fb 01             	cmp    ebx,0x1
  2080d1:	74 5b                	je     20812e <init_vdso_clock_gettime+0x11e>
  2080d3:	83 fb 02             	cmp    ebx,0x2
  2080d6:	75 07                	jne    2080df <init_vdso_clock_gettime+0xcf>
  2080d8:	4c 8b 72 08          	mov    r14,QWORD PTR [rdx+0x8]
                elf.PT_DYNAMIC => maybe_dynv = @intToPtr([*]usize, vdso_addr + this_ph.p_offset),
  2080dc:	4d 01 ce             	add    r14,r9
        while (i < eh.e_phnum) : ({
  2080df:	48 8d 1c 0a          	lea    rbx,[rdx+rcx*1]
  2080e3:	48 83 c0 04          	add    rax,0x4
  2080e7:	75 97                	jne    208080 <init_vdso_clock_gettime+0x70>
  2080e9:	eb 5c                	jmp    208147 <init_vdso_clock_gettime+0x137>
  2080eb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  2080f0:	4c 8b 72 08          	mov    r14,QWORD PTR [rdx+0x8]
                elf.PT_DYNAMIC => maybe_dynv = @intToPtr([*]usize, vdso_addr + this_ph.p_offset),
  2080f4:	4d 01 ce             	add    r14,r9
            switch (this_ph.p_type) {
  2080f7:	8b 1c 0a             	mov    ebx,DWORD PTR [rdx+rcx*1]
            ph_addr += eh.e_phentsize;
  2080fa:	48 01 ca             	add    rdx,rcx
            switch (this_ph.p_type) {
  2080fd:	83 fb 01             	cmp    ebx,0x1
  208100:	75 a3                	jne    2080a5 <init_vdso_clock_gettime+0x95>
  208102:	4c 8b 42 08          	mov    r8,QWORD PTR [rdx+0x8]
                elf.PT_LOAD => base = vdso_addr + this_ph.p_offset - this_ph.p_vaddr,
  208106:	4d 01 c8             	add    r8,r9
  208109:	4c 2b 42 10          	sub    r8,QWORD PTR [rdx+0x10]
            switch (this_ph.p_type) {
  20810d:	8b 1c 11             	mov    ebx,DWORD PTR [rcx+rdx*1]
            ph_addr += eh.e_phentsize;
  208110:	48 01 ca             	add    rdx,rcx
            switch (this_ph.p_type) {
  208113:	83 fb 01             	cmp    ebx,0x1
  208116:	75 a4                	jne    2080bc <init_vdso_clock_gettime+0xac>
  208118:	4c 8b 42 08          	mov    r8,QWORD PTR [rdx+0x8]
                elf.PT_LOAD => base = vdso_addr + this_ph.p_offset - this_ph.p_vaddr,
  20811c:	4d 01 c8             	add    r8,r9
  20811f:	4c 2b 42 10          	sub    r8,QWORD PTR [rdx+0x10]
            switch (this_ph.p_type) {
  208123:	8b 1c 11             	mov    ebx,DWORD PTR [rcx+rdx*1]
            ph_addr += eh.e_phentsize;
  208126:	48 01 ca             	add    rdx,rcx
            switch (this_ph.p_type) {
  208129:	83 fb 01             	cmp    ebx,0x1
  20812c:	75 a5                	jne    2080d3 <init_vdso_clock_gettime+0xc3>
  20812e:	4c 8b 42 08          	mov    r8,QWORD PTR [rdx+0x8]
                elf.PT_LOAD => base = vdso_addr + this_ph.p_offset - this_ph.p_vaddr,
  208132:	4d 01 c8             	add    r8,r9
  208135:	4c 2b 42 10          	sub    r8,QWORD PTR [rdx+0x10]
        while (i < eh.e_phnum) : ({
  208139:	48 8d 1c 0a          	lea    rbx,[rdx+rcx*1]
  20813d:	48 83 c0 04          	add    rax,0x4
  208141:	0f 85 39 ff ff ff    	jne    208080 <init_vdso_clock_gettime+0x70>
  208147:	48 01 ca             	add    rdx,rcx
  20814a:	48 89 d3             	mov    rbx,rdx
            switch (this_ph.p_type) {
  20814d:	48 85 ed             	test   rbp,rbp
  208150:	74 42                	je     208194 <init_vdso_clock_gettime+0x184>
  208152:	48 f7 dd             	neg    rbp
  208155:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20815c:	00 00 00 00 
  208160:	8b 03                	mov    eax,DWORD PTR [rbx]
  208162:	83 f8 01             	cmp    eax,0x1
  208165:	74 19                	je     208180 <init_vdso_clock_gettime+0x170>
  208167:	83 f8 02             	cmp    eax,0x2
  20816a:	75 07                	jne    208173 <init_vdso_clock_gettime+0x163>
  20816c:	4c 8b 73 08          	mov    r14,QWORD PTR [rbx+0x8]
                elf.PT_DYNAMIC => maybe_dynv = @intToPtr([*]usize, vdso_addr + this_ph.p_offset),
  208170:	4d 01 ce             	add    r14,r9
            ph_addr += eh.e_phentsize;
  208173:	48 01 cb             	add    rbx,rcx
        while (i < eh.e_phnum) : ({
  208176:	48 83 c5 01          	add    rbp,0x1
  20817a:	75 e4                	jne    208160 <init_vdso_clock_gettime+0x150>
  20817c:	eb 16                	jmp    208194 <init_vdso_clock_gettime+0x184>
  20817e:	66 90                	xchg   ax,ax
  208180:	4c 8b 43 08          	mov    r8,QWORD PTR [rbx+0x8]
                elf.PT_LOAD => base = vdso_addr + this_ph.p_offset - this_ph.p_vaddr,
  208184:	4d 01 c8             	add    r8,r9
  208187:	4c 2b 43 10          	sub    r8,QWORD PTR [rbx+0x10]
            ph_addr += eh.e_phentsize;
  20818b:	48 01 cb             	add    rbx,rcx
        while (i < eh.e_phnum) : ({
  20818e:	48 83 c5 01          	add    rbp,0x1
  208192:	75 cc                	jne    208160 <init_vdso_clock_gettime+0x150>
                else => {},
            }
        }
    }
    const dynv = maybe_dynv orelse return 0;
    if (base == @maxValue(usize)) return 0;
  208194:	49 83 f8 ff          	cmp    r8,0xffffffffffffffff
    const dynv = maybe_dynv orelse return 0;
  208198:	0f 84 df 03 00 00    	je     20857d <init_vdso_clock_gettime+0x56d>
  20819e:	4d 85 f6             	test   r14,r14
  2081a1:	0f 84 d6 03 00 00    	je     20857d <init_vdso_clock_gettime+0x56d>
    var maybe_versym: ?[*]u16 = null;
    var maybe_verdef: ?*elf.Verdef = null;

    {
        var i: usize = 0;
        while (dynv[i] != 0) : (i += 2) {
  2081a7:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  2081aa:	48 85 d2             	test   rdx,rdx
  2081ad:	0f 84 ca 03 00 00    	je     20857d <init_vdso_clock_gettime+0x56d>
            const p = base + dynv[i + 1];
  2081b3:	49 83 c6 10          	add    r14,0x10
  2081b7:	45 31 ff             	xor    r15d,r15d
  2081ba:	45 31 db             	xor    r11d,r11d
  2081bd:	45 31 d2             	xor    r10d,r10d
  2081c0:	31 ed                	xor    ebp,ebp
  2081c2:	45 31 ed             	xor    r13d,r13d
  2081c5:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  2081cc:	00 00 00 00 
  2081d0:	49 8b 4e f8          	mov    rcx,QWORD PTR [r14-0x8]
  2081d4:	4c 01 c1             	add    rcx,r8
            switch (dynv[i]) {
  2081d7:	48 83 fa 05          	cmp    rdx,0x5
  2081db:	7e 33                	jle    208210 <init_vdso_clock_gettime+0x200>
  2081dd:	48 83 fa 06          	cmp    rdx,0x6
  2081e1:	74 4b                	je     20822e <init_vdso_clock_gettime+0x21e>
  2081e3:	48 81 fa f0 ff ff 6f 	cmp    rdx,0x6ffffff0
  2081ea:	74 53                	je     20823f <init_vdso_clock_gettime+0x22f>
  2081ec:	48 81 fa fc ff ff 6f 	cmp    rdx,0x6ffffffc
  2081f3:	75 2b                	jne    208220 <init_vdso_clock_gettime+0x210>
  2081f5:	49 89 cb             	mov    r11,rcx
        while (dynv[i] != 0) : (i += 2) {
  2081f8:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  2081fb:	49 83 c6 10          	add    r14,0x10
  2081ff:	48 85 d2             	test   rdx,rdx
  208202:	75 cc                	jne    2081d0 <init_vdso_clock_gettime+0x1c0>
  208204:	eb 5d                	jmp    208263 <init_vdso_clock_gettime+0x253>
  208206:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  20820d:	00 00 00 
            switch (dynv[i]) {
  208210:	48 83 fa 04          	cmp    rdx,0x4
  208214:	74 3a                	je     208250 <init_vdso_clock_gettime+0x240>
  208216:	48 83 fa 05          	cmp    rdx,0x5
  20821a:	75 04                	jne    208220 <init_vdso_clock_gettime+0x210>
  20821c:	49 89 cf             	mov    r15,rcx
  20821f:	90                   	nop
        while (dynv[i] != 0) : (i += 2) {
  208220:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  208223:	49 83 c6 10          	add    r14,0x10
  208227:	48 85 d2             	test   rdx,rdx
  20822a:	75 a4                	jne    2081d0 <init_vdso_clock_gettime+0x1c0>
  20822c:	eb 35                	jmp    208263 <init_vdso_clock_gettime+0x253>
  20822e:	49 89 cd             	mov    r13,rcx
  208231:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  208234:	49 83 c6 10          	add    r14,0x10
  208238:	48 85 d2             	test   rdx,rdx
  20823b:	75 93                	jne    2081d0 <init_vdso_clock_gettime+0x1c0>
  20823d:	eb 24                	jmp    208263 <init_vdso_clock_gettime+0x253>
  20823f:	49 89 ca             	mov    r10,rcx
  208242:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  208245:	49 83 c6 10          	add    r14,0x10
  208249:	48 85 d2             	test   rdx,rdx
  20824c:	75 82                	jne    2081d0 <init_vdso_clock_gettime+0x1c0>
  20824e:	eb 13                	jmp    208263 <init_vdso_clock_gettime+0x253>
  208250:	48 89 cd             	mov    rbp,rcx
  208253:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  208256:	49 83 c6 10          	add    r14,0x10
  20825a:	48 85 d2             	test   rdx,rdx
  20825d:	0f 85 6d ff ff ff    	jne    2081d0 <init_vdso_clock_gettime+0x1c0>
        }
    }

    const strings = maybe_strings orelse return 0;
    const syms = maybe_syms orelse return 0;
    const hashtab = maybe_hashtab orelse return 0;
  208263:	48 85 ed             	test   rbp,rbp
    const strings = maybe_strings orelse return 0;
  208266:	0f 84 11 03 00 00    	je     20857d <init_vdso_clock_gettime+0x56d>
  20826c:	4d 85 ed             	test   r13,r13
  20826f:	0f 84 08 03 00 00    	je     20857d <init_vdso_clock_gettime+0x56d>
  208275:	4d 85 ff             	test   r15,r15
  208278:	0f 84 ff 02 00 00    	je     20857d <init_vdso_clock_gettime+0x56d>
    if (maybe_verdef == null) maybe_versym = null;
  20827e:	4d 85 db             	test   r11,r11
  208281:	4d 0f 44 d3          	cmove  r10,r11

    const OK_TYPES = (1 << elf.STT_NOTYPE | 1 << elf.STT_OBJECT | 1 << elf.STT_FUNC | 1 << elf.STT_COMMON);
    const OK_BINDS = (1 << elf.STB_GLOBAL | 1 << elf.STB_WEAK | 1 << elf.STB_GNU_UNIQUE);

    var i: usize = 0;
    while (i < hashtab[1]) : (i += 1) {
  208285:	44 8b 4d 04          	mov    r9d,DWORD PTR [rbp+0x4]
  208289:	4d 85 c9             	test   r9,r9
  20828c:	0f 84 eb 02 00 00    	je     20857d <init_vdso_clock_gettime+0x56d>
  208292:	31 d2                	xor    edx,edx
  208294:	4d 85 d2             	test   r10,r10
  208297:	0f 84 e5 01 00 00    	je     208482 <init_vdso_clock_gettime+0x472>
  20829d:	41 bc 27 00 00 00    	mov    r12d,0x27
  2082a3:	41 be 06 04 00 00    	mov    r14d,0x406
  2082a9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
        if (0 == (u32(1) << @intCast(u5, syms[i].st_info & 0xf) & OK_TYPES)) continue;
  2082b0:	48 8d 0c 52          	lea    rcx,[rdx+rdx*2]
  2082b4:	41 8a 5c cd 04       	mov    bl,BYTE PTR [r13+rcx*8+0x4]
  2082b9:	89 d8                	mov    eax,ebx
  2082bb:	24 0f                	and    al,0xf
  2082bd:	0f b6 c0             	movzx  eax,al
  2082c0:	41 0f a3 c4          	bt     r12d,eax
  2082c4:	0f 83 a6 01 00 00    	jae    208470 <init_vdso_clock_gettime+0x460>
        if (0 == (u32(1) << @intCast(u5, syms[i].st_info >> 4) & OK_BINDS)) continue;
  2082ca:	c0 eb 04             	shr    bl,0x4
  2082cd:	0f b6 c3             	movzx  eax,bl
  2082d0:	41 0f a3 c6          	bt     r14d,eax
  2082d4:	0f 83 96 01 00 00    	jae    208470 <init_vdso_clock_gettime+0x460>
        if (0 == syms[i].st_shndx) continue;
  2082da:	66 41 83 7c cd 06 00 	cmp    WORD PTR [r13+rcx*8+0x6],0x0
  2082e1:	0f 84 89 01 00 00    	je     208470 <init_vdso_clock_gettime+0x460>
        if (!mem.eql(u8, name, cstr.toSliceConst(strings + syms[i].st_name))) continue;
  2082e7:	41 8b 6c cd 00       	mov    ebp,DWORD PTR [r13+rcx*8+0x0]
  2082ec:	4c 01 fd             	add    rbp,r15
  2082ef:	48 c7 c1 eb ff ff ff 	mov    rcx,0xffffffffffffffeb
  2082f6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  2082fd:	00 00 00 
    return true;
}

pub fn len(comptime T: type, ptr: [*]const T) usize {
    var count: usize = 0;
    while (ptr[count] != 0) : (count += 1) {}
  208300:	80 7c 0d 15 00       	cmp    BYTE PTR [rbp+rcx*1+0x15],0x0
  208305:	48 8d 49 01          	lea    rcx,[rcx+0x1]
  208309:	75 f5                	jne    208300 <init_vdso_clock_gettime+0x2f0>
    if (a.len != b.len) return false;
  20830b:	48 85 c9             	test   rcx,rcx
  20830e:	0f 85 5c 01 00 00    	jne    208470 <init_vdso_clock_gettime+0x460>
        if (b[index] != item) return false;
  208314:	80 7d 00 5f          	cmp    BYTE PTR [rbp+0x0],0x5f
  208318:	0f 85 52 01 00 00    	jne    208470 <init_vdso_clock_gettime+0x460>
  20831e:	80 7d 01 5f          	cmp    BYTE PTR [rbp+0x1],0x5f
  208322:	0f 85 48 01 00 00    	jne    208470 <init_vdso_clock_gettime+0x460>
  208328:	80 7d 02 76          	cmp    BYTE PTR [rbp+0x2],0x76
  20832c:	0f 85 3e 01 00 00    	jne    208470 <init_vdso_clock_gettime+0x460>
  208332:	80 7d 03 64          	cmp    BYTE PTR [rbp+0x3],0x64
  208336:	0f 85 34 01 00 00    	jne    208470 <init_vdso_clock_gettime+0x460>
  20833c:	80 7d 04 73          	cmp    BYTE PTR [rbp+0x4],0x73
  208340:	0f 85 2a 01 00 00    	jne    208470 <init_vdso_clock_gettime+0x460>
  208346:	80 7d 05 6f          	cmp    BYTE PTR [rbp+0x5],0x6f
  20834a:	0f 85 20 01 00 00    	jne    208470 <init_vdso_clock_gettime+0x460>
  208350:	80 7d 06 5f          	cmp    BYTE PTR [rbp+0x6],0x5f
  208354:	0f 85 16 01 00 00    	jne    208470 <init_vdso_clock_gettime+0x460>
  20835a:	80 7d 07 63          	cmp    BYTE PTR [rbp+0x7],0x63
  20835e:	0f 85 0c 01 00 00    	jne    208470 <init_vdso_clock_gettime+0x460>
  208364:	80 7d 08 6c          	cmp    BYTE PTR [rbp+0x8],0x6c
  208368:	0f 85 02 01 00 00    	jne    208470 <init_vdso_clock_gettime+0x460>
  20836e:	80 7d 09 6f          	cmp    BYTE PTR [rbp+0x9],0x6f
  208372:	0f 85 f8 00 00 00    	jne    208470 <init_vdso_clock_gettime+0x460>
  208378:	80 7d 0a 63          	cmp    BYTE PTR [rbp+0xa],0x63
  20837c:	0f 85 ee 00 00 00    	jne    208470 <init_vdso_clock_gettime+0x460>
  208382:	80 7d 0b 6b          	cmp    BYTE PTR [rbp+0xb],0x6b
  208386:	0f 85 e4 00 00 00    	jne    208470 <init_vdso_clock_gettime+0x460>
  20838c:	80 7d 0c 5f          	cmp    BYTE PTR [rbp+0xc],0x5f
  208390:	0f 85 da 00 00 00    	jne    208470 <init_vdso_clock_gettime+0x460>
  208396:	80 7d 0d 67          	cmp    BYTE PTR [rbp+0xd],0x67
  20839a:	0f 85 d0 00 00 00    	jne    208470 <init_vdso_clock_gettime+0x460>
  2083a0:	80 7d 0e 65          	cmp    BYTE PTR [rbp+0xe],0x65
  2083a4:	0f 85 c6 00 00 00    	jne    208470 <init_vdso_clock_gettime+0x460>
  2083aa:	80 7d 0f 74          	cmp    BYTE PTR [rbp+0xf],0x74
  2083ae:	0f 85 bc 00 00 00    	jne    208470 <init_vdso_clock_gettime+0x460>
  2083b4:	80 7d 10 74          	cmp    BYTE PTR [rbp+0x10],0x74
  2083b8:	0f 85 b2 00 00 00    	jne    208470 <init_vdso_clock_gettime+0x460>
  2083be:	80 7d 11 69          	cmp    BYTE PTR [rbp+0x11],0x69
  2083c2:	0f 85 a8 00 00 00    	jne    208470 <init_vdso_clock_gettime+0x460>
  2083c8:	80 7d 12 6d          	cmp    BYTE PTR [rbp+0x12],0x6d
  2083cc:	0f 85 9e 00 00 00    	jne    208470 <init_vdso_clock_gettime+0x460>
  2083d2:	80 7d 13 65          	cmp    BYTE PTR [rbp+0x13],0x65
  2083d6:	0f 85 94 00 00 00    	jne    208470 <init_vdso_clock_gettime+0x460>
        if (maybe_versym) |versym| {
            if (!checkver(maybe_verdef.?, versym[i], vername, strings))
  2083dc:	41 0f b7 2c 52       	movzx  ebp,WORD PTR [r10+rdx*2]
  2083e1:	4c 89 d9             	mov    rcx,r11

fn checkver(def_arg: *elf.Verdef, vsym_arg: i32, vername: []const u8, strings: [*]u8) bool {
    var def = def_arg;
    const vsym = @bitCast(u32, vsym_arg) & 0x7fff;
    while (true) {
        if (0 == (def.vd_flags & elf.VER_FLG_BASE) and (def.vd_ndx & 0x7fff) == vsym)
  2083e4:	f6 41 02 01          	test   BYTE PTR [rcx+0x2],0x1
  2083e8:	75 1c                	jne    208406 <init_vdso_clock_gettime+0x3f6>
  2083ea:	eb 09                	jmp    2083f5 <init_vdso_clock_gettime+0x3e5>
            break;
        if (def.vd_next == 0)
            return false;
        def = @intToPtr(*elf.Verdef, @ptrToInt(def) + def.vd_next);
  2083ec:	48 01 d9             	add    rcx,rbx
        if (0 == (def.vd_flags & elf.VER_FLG_BASE) and (def.vd_ndx & 0x7fff) == vsym)
  2083ef:	f6 41 02 01          	test   BYTE PTR [rcx+0x2],0x1
  2083f3:	75 11                	jne    208406 <init_vdso_clock_gettime+0x3f6>
  2083f5:	0f b7 41 04          	movzx  eax,WORD PTR [rcx+0x4]
  2083f9:	66 31 e8             	xor    ax,bp
  2083fc:	25 ff 7f 00 00       	and    eax,0x7fff
  208401:	66 85 c0             	test   ax,ax
  208404:	74 0a                	je     208410 <init_vdso_clock_gettime+0x400>
        if (def.vd_next == 0)
  208406:	8b 59 10             	mov    ebx,DWORD PTR [rcx+0x10]
  208409:	48 85 db             	test   rbx,rbx
  20840c:	75 de                	jne    2083ec <init_vdso_clock_gettime+0x3dc>
  20840e:	eb 60                	jmp    208470 <init_vdso_clock_gettime+0x460>
    }
    const aux = @intToPtr(*elf.Verdaux, @ptrToInt(def) + def.vd_aux);
  208410:	8b 41 0c             	mov    eax,DWORD PTR [rcx+0xc]
    return mem.eql(u8, vername, cstr.toSliceConst(strings + aux.vda_name));
  208413:	8b 2c 08             	mov    ebp,DWORD PTR [rax+rcx*1]
  208416:	4c 01 fd             	add    rbp,r15
  208419:	48 c7 c1 f6 ff ff ff 	mov    rcx,0xfffffffffffffff6
    while (ptr[count] != 0) : (count += 1) {}
  208420:	80 7c 0d 0a 00       	cmp    BYTE PTR [rbp+rcx*1+0xa],0x0
  208425:	48 8d 49 01          	lea    rcx,[rcx+0x1]
  208429:	75 f5                	jne    208420 <init_vdso_clock_gettime+0x410>
    if (a.len != b.len) return false;
  20842b:	48 85 c9             	test   rcx,rcx
  20842e:	75 40                	jne    208470 <init_vdso_clock_gettime+0x460>
        if (b[index] != item) return false;
  208430:	80 7d 00 4c          	cmp    BYTE PTR [rbp+0x0],0x4c
  208434:	75 3a                	jne    208470 <init_vdso_clock_gettime+0x460>
  208436:	80 7d 01 49          	cmp    BYTE PTR [rbp+0x1],0x49
  20843a:	75 34                	jne    208470 <init_vdso_clock_gettime+0x460>
  20843c:	80 7d 02 4e          	cmp    BYTE PTR [rbp+0x2],0x4e
  208440:	75 2e                	jne    208470 <init_vdso_clock_gettime+0x460>
  208442:	80 7d 03 55          	cmp    BYTE PTR [rbp+0x3],0x55
  208446:	75 28                	jne    208470 <init_vdso_clock_gettime+0x460>
  208448:	80 7d 04 58          	cmp    BYTE PTR [rbp+0x4],0x58
  20844c:	75 22                	jne    208470 <init_vdso_clock_gettime+0x460>
  20844e:	80 7d 05 5f          	cmp    BYTE PTR [rbp+0x5],0x5f
  208452:	75 1c                	jne    208470 <init_vdso_clock_gettime+0x460>
  208454:	80 7d 06 32          	cmp    BYTE PTR [rbp+0x6],0x32
  208458:	75 16                	jne    208470 <init_vdso_clock_gettime+0x460>
  20845a:	80 7d 07 2e          	cmp    BYTE PTR [rbp+0x7],0x2e
  20845e:	75 10                	jne    208470 <init_vdso_clock_gettime+0x460>
  208460:	80 7d 08 36          	cmp    BYTE PTR [rbp+0x8],0x36
            if (!checkver(maybe_verdef.?, versym[i], vername, strings))
  208464:	0f 84 37 01 00 00    	je     2085a1 <init_vdso_clock_gettime+0x591>
  20846a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
    while (i < hashtab[1]) : (i += 1) {
  208470:	48 83 c2 01          	add    rdx,0x1
  208474:	4c 39 ca             	cmp    rdx,r9
  208477:	0f 82 33 fe ff ff    	jb     2082b0 <init_vdso_clock_gettime+0x2a0>
  20847d:	e9 fb 00 00 00       	jmp    20857d <init_vdso_clock_gettime+0x56d>
  208482:	bd 27 00 00 00       	mov    ebp,0x27
  208487:	41 ba 06 04 00 00    	mov    r10d,0x406
  20848d:	0f 1f 00             	nop    DWORD PTR [rax]
        if (0 == (u32(1) << @intCast(u5, syms[i].st_info & 0xf) & OK_TYPES)) continue;
  208490:	48 8d 0c 52          	lea    rcx,[rdx+rdx*2]
  208494:	41 8a 44 cd 04       	mov    al,BYTE PTR [r13+rcx*8+0x4]
  208499:	89 c3                	mov    ebx,eax
  20849b:	80 e3 0f             	and    bl,0xf
  20849e:	0f b6 db             	movzx  ebx,bl
  2084a1:	0f a3 dd             	bt     ebp,ebx
  2084a4:	0f 83 c6 00 00 00    	jae    208570 <init_vdso_clock_gettime+0x560>
        if (0 == (u32(1) << @intCast(u5, syms[i].st_info >> 4) & OK_BINDS)) continue;
  2084aa:	c0 e8 04             	shr    al,0x4
  2084ad:	0f b6 c0             	movzx  eax,al
  2084b0:	41 0f a3 c2          	bt     r10d,eax
  2084b4:	0f 83 b6 00 00 00    	jae    208570 <init_vdso_clock_gettime+0x560>
        if (0 == syms[i].st_shndx) continue;
  2084ba:	66 41 83 7c cd 06 00 	cmp    WORD PTR [r13+rcx*8+0x6],0x0
  2084c1:	0f 84 a9 00 00 00    	je     208570 <init_vdso_clock_gettime+0x560>
        if (!mem.eql(u8, name, cstr.toSliceConst(strings + syms[i].st_name))) continue;
  2084c7:	41 8b 5c cd 00       	mov    ebx,DWORD PTR [r13+rcx*8+0x0]
  2084cc:	4c 01 fb             	add    rbx,r15
  2084cf:	48 c7 c1 eb ff ff ff 	mov    rcx,0xffffffffffffffeb
  2084d6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  2084dd:	00 00 00 
    while (ptr[count] != 0) : (count += 1) {}
  2084e0:	80 7c 0b 15 00       	cmp    BYTE PTR [rbx+rcx*1+0x15],0x0
  2084e5:	48 8d 49 01          	lea    rcx,[rcx+0x1]
  2084e9:	75 f5                	jne    2084e0 <init_vdso_clock_gettime+0x4d0>
    if (a.len != b.len) return false;
  2084eb:	48 85 c9             	test   rcx,rcx
  2084ee:	0f 85 7c 00 00 00    	jne    208570 <init_vdso_clock_gettime+0x560>
        if (b[index] != item) return false;
  2084f4:	80 3b 5f             	cmp    BYTE PTR [rbx],0x5f
  2084f7:	75 77                	jne    208570 <init_vdso_clock_gettime+0x560>
  2084f9:	80 7b 01 5f          	cmp    BYTE PTR [rbx+0x1],0x5f
  2084fd:	75 71                	jne    208570 <init_vdso_clock_gettime+0x560>
  2084ff:	80 7b 02 76          	cmp    BYTE PTR [rbx+0x2],0x76
  208503:	75 6b                	jne    208570 <init_vdso_clock_gettime+0x560>
  208505:	80 7b 03 64          	cmp    BYTE PTR [rbx+0x3],0x64
  208509:	75 65                	jne    208570 <init_vdso_clock_gettime+0x560>
  20850b:	80 7b 04 73          	cmp    BYTE PTR [rbx+0x4],0x73
  20850f:	75 5f                	jne    208570 <init_vdso_clock_gettime+0x560>
  208511:	80 7b 05 6f          	cmp    BYTE PTR [rbx+0x5],0x6f
  208515:	75 59                	jne    208570 <init_vdso_clock_gettime+0x560>
  208517:	80 7b 06 5f          	cmp    BYTE PTR [rbx+0x6],0x5f
  20851b:	75 53                	jne    208570 <init_vdso_clock_gettime+0x560>
  20851d:	80 7b 07 63          	cmp    BYTE PTR [rbx+0x7],0x63
  208521:	75 4d                	jne    208570 <init_vdso_clock_gettime+0x560>
  208523:	80 7b 08 6c          	cmp    BYTE PTR [rbx+0x8],0x6c
  208527:	75 47                	jne    208570 <init_vdso_clock_gettime+0x560>
  208529:	80 7b 09 6f          	cmp    BYTE PTR [rbx+0x9],0x6f
  20852d:	75 41                	jne    208570 <init_vdso_clock_gettime+0x560>
  20852f:	80 7b 0a 63          	cmp    BYTE PTR [rbx+0xa],0x63
  208533:	75 3b                	jne    208570 <init_vdso_clock_gettime+0x560>
  208535:	80 7b 0b 6b          	cmp    BYTE PTR [rbx+0xb],0x6b
  208539:	75 35                	jne    208570 <init_vdso_clock_gettime+0x560>
  20853b:	80 7b 0c 5f          	cmp    BYTE PTR [rbx+0xc],0x5f
  20853f:	75 2f                	jne    208570 <init_vdso_clock_gettime+0x560>
  208541:	80 7b 0d 67          	cmp    BYTE PTR [rbx+0xd],0x67
  208545:	75 29                	jne    208570 <init_vdso_clock_gettime+0x560>
  208547:	80 7b 0e 65          	cmp    BYTE PTR [rbx+0xe],0x65
  20854b:	75 23                	jne    208570 <init_vdso_clock_gettime+0x560>
  20854d:	80 7b 0f 74          	cmp    BYTE PTR [rbx+0xf],0x74
  208551:	75 1d                	jne    208570 <init_vdso_clock_gettime+0x560>
  208553:	80 7b 10 74          	cmp    BYTE PTR [rbx+0x10],0x74
  208557:	75 17                	jne    208570 <init_vdso_clock_gettime+0x560>
  208559:	80 7b 11 69          	cmp    BYTE PTR [rbx+0x11],0x69
  20855d:	75 11                	jne    208570 <init_vdso_clock_gettime+0x560>
  20855f:	80 7b 12 6d          	cmp    BYTE PTR [rbx+0x12],0x6d
  208563:	75 0b                	jne    208570 <init_vdso_clock_gettime+0x560>
  208565:	80 7b 13 65          	cmp    BYTE PTR [rbx+0x13],0x65
  208569:	74 36                	je     2085a1 <init_vdso_clock_gettime+0x591>
  20856b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
    while (i < hashtab[1]) : (i += 1) {
  208570:	48 83 c2 01          	add    rdx,0x1
  208574:	4c 39 ca             	cmp    rdx,r9
  208577:	0f 82 13 ff ff ff    	jb     208490 <init_vdso_clock_gettime+0x480>
}
var vdso_clock_gettime = init_vdso_clock_gettime;
extern fn init_vdso_clock_gettime(clk: i32, ts: *timespec) usize {
    const addr = vdso.lookup(VDSO_CGT_VER, VDSO_CGT_SYM);
    var f = @intToPtr(@typeOf(init_vdso_clock_gettime), addr);
    _ = @cmpxchgStrong(@typeOf(init_vdso_clock_gettime), &vdso_clock_gettime, init_vdso_clock_gettime, f, builtin.AtomicOrder.Monotonic, builtin.AtomicOrder.Monotonic);
  20857d:	48 8d 05 8c fa ff ff 	lea    rax,[rip+0xfffffffffffffa8c]        # 208010 <init_vdso_clock_gettime>
  208584:	31 c9                	xor    ecx,ecx
  208586:	f0 48 0f b1 0d 89 4a 	lock cmpxchg QWORD PTR [rip+0x14a89],rcx        # 21d018 <vdso_clock_gettime>
  20858d:	01 00 
    if (@ptrToInt(f) == 0) return @bitCast(usize, isize(-ENOSYS));
  20858f:	48 c7 c0 da ff ff ff 	mov    rax,0xffffffffffffffda
  208596:	5b                   	pop    rbx
  208597:	41 5c                	pop    r12
  208599:	41 5d                	pop    r13
  20859b:	41 5e                	pop    r14
  20859d:	41 5f                	pop    r15
  20859f:	5d                   	pop    rbp
  2085a0:	c3                   	ret    
        return base + syms[i].st_value;
  2085a1:	48 8d 04 52          	lea    rax,[rdx+rdx*2]
  2085a5:	4d 03 44 c5 08       	add    r8,QWORD PTR [r13+rax*8+0x8]
    _ = @cmpxchgStrong(@typeOf(init_vdso_clock_gettime), &vdso_clock_gettime, init_vdso_clock_gettime, f, builtin.AtomicOrder.Monotonic, builtin.AtomicOrder.Monotonic);
  2085aa:	48 8d 05 5f fa ff ff 	lea    rax,[rip+0xfffffffffffffa5f]        # 208010 <init_vdso_clock_gettime>
  2085b1:	f0 4c 0f b1 05 5e 4a 	lock cmpxchg QWORD PTR [rip+0x14a5e],r8        # 21d018 <vdso_clock_gettime>
  2085b8:	01 00 
    if (@ptrToInt(f) == 0) return @bitCast(usize, isize(-ENOSYS));
  2085ba:	4d 85 c0             	test   r8,r8
  2085bd:	74 d0                	je     20858f <init_vdso_clock_gettime+0x57f>
    return f(clk, ts);
  2085bf:	5b                   	pop    rbx
  2085c0:	41 5c                	pop    r12
  2085c2:	41 5d                	pop    r13
  2085c4:	41 5e                	pop    r14
  2085c6:	41 5f                	pop    r15
  2085c8:	5d                   	pop    rbp
  2085c9:	41 ff e0             	jmp    r8
  2085cc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

00000000002085d0 <benchmark.add>:
            @intToFloat(f64, run_time_ns)/@intToFloat(f64, iterations),
        );
    }
};

test "benchmark.add" {
  2085d0:	41 57                	push   r15
  2085d2:	41 56                	push   r14
  2085d4:	41 55                	push   r13
  2085d6:	41 54                	push   r12
  2085d8:	53                   	push   rbx
  2085d9:	48 81 ec 80 00 00 00 	sub    rsp,0x80
    pub fn init() Mutex {
        return Mutex{ .lock = 0 };
    }

    pub fn acquire(self: *Mutex) Held {
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  2085e0:	b0 01                	mov    al,0x1
  2085e2:	86 05 28 8a 01 00    	xchg   BYTE PTR [rip+0x18a28],al        # 221010 <stderr_mutex>
  2085e8:	84 c0                	test   al,al
  2085ea:	75 f4                	jne    2085e0 <benchmark.add+0x10>
    if (stderr_stream) |st| {
  2085ec:	48 8b 3d 15 8a 01 00 	mov    rdi,QWORD PTR [rip+0x18a15]        # 221008 <stderr_stream>
  2085f3:	48 85 ff             	test   rdi,rdi
  2085f6:	74 09                	je     208601 <benchmark.add+0x31>
        pub const Error = WriteError;

        writeFn: fn (self: *Self, bytes: []const u8) Error!void,

        pub fn print(self: *Self, comptime format: []const u8, args: ...) !void {
            return std.fmt.format(self, Error, self.writeFn, format, args);
  2085f8:	48 8b 05 11 4a 01 00 	mov    rax,QWORD PTR [rip+0x14a11]        # 21d010 <stderr_file_out_stream+0x8>
  2085ff:	eb 34                	jmp    208635 <benchmark.add+0x65>
        stderr_file = try io.getStdErr();
  208601:	48 8d 05 f8 49 01 00 	lea    rax,[rip+0x149f8]        # 21d000 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  208608:	48 89 05 f9 49 01 00 	mov    QWORD PTR [rip+0x149f9],rax        # 21d008 <stderr_file_out_stream>
  20860f:	48 8d 05 ea 21 00 00 	lea    rax,[rip+0x21ea]        # 20a800 <FileOutStream_writeFn>
  208616:	48 89 05 f3 49 01 00 	mov    QWORD PTR [rip+0x149f3],rax        # 21d010 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  20861d:	c7 05 d9 49 01 00 02 	mov    DWORD PTR [rip+0x149d9],0x2        # 21d000 <stderr_file>
  208624:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  208627:	48 8d 3d e2 49 01 00 	lea    rdi,[rip+0x149e2]        # 21d010 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  20862e:	48 89 3d d3 89 01 00 	mov    QWORD PTR [rip+0x189d3],rdi        # 221008 <stderr_stream>
        if (state != State.Start) {
            @compileError("Incomplete format string: " ++ fmt);
        }
    }
    if (start_index < fmt.len) {
        try output(context, fmt[start_index..]);
  208635:	48 8d 35 ac 85 01 00 	lea    rsi,[rip+0x185ac]        # 220be8 <__unnamed_1>
  20863c:	ff d0                	call   rax
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20863e:	31 c0                	xor    eax,eax
  208640:	86 05 ca 89 01 00    	xchg   BYTE PTR [rip+0x189ca],al        # 221010 <stderr_mutex>
  208646:	3c 01                	cmp    al,0x1
    if (!ok) {
  208648:	0f 85 cc 06 00 00    	jne    208d1a <benchmark.add+0x74a>
  20864e:	66 90                	xchg   ax,ax
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  208650:	b0 01                	mov    al,0x1
  208652:	86 05 b8 89 01 00    	xchg   BYTE PTR [rip+0x189b8],al        # 221010 <stderr_mutex>
  208658:	84 c0                	test   al,al
  20865a:	75 f4                	jne    208650 <benchmark.add+0x80>
    if (stderr_stream) |st| {
  20865c:	48 8b 1d a5 89 01 00 	mov    rbx,QWORD PTR [rip+0x189a5]        # 221008 <stderr_stream>
  208663:	48 85 db             	test   rbx,rbx
  208666:	74 09                	je     208671 <benchmark.add+0xa1>
  208668:	4c 8b 35 a1 49 01 00 	mov    r14,QWORD PTR [rip+0x149a1]        # 21d010 <stderr_file_out_stream+0x8>
  20866f:	eb 34                	jmp    2086a5 <benchmark.add+0xd5>
        stderr_file = try io.getStdErr();
  208671:	48 8d 05 88 49 01 00 	lea    rax,[rip+0x14988]        # 21d000 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  208678:	48 89 05 89 49 01 00 	mov    QWORD PTR [rip+0x14989],rax        # 21d008 <stderr_file_out_stream>
  20867f:	4c 8d 35 7a 21 00 00 	lea    r14,[rip+0x217a]        # 20a800 <FileOutStream_writeFn>
  208686:	4c 89 35 83 49 01 00 	mov    QWORD PTR [rip+0x14983],r14        # 21d010 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  20868d:	c7 05 69 49 01 00 02 	mov    DWORD PTR [rip+0x14969],0x2        # 21d000 <stderr_file>
  208694:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  208697:	48 8d 1d 72 49 01 00 	lea    rbx,[rip+0x14972]        # 21d010 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  20869e:	48 89 1d 63 89 01 00 	mov    QWORD PTR [rip+0x18963],rbx        # 221008 <stderr_stream>
                        try output(context, fmt[start_index..i]);
  2086a5:	48 8d 35 7c 84 01 00 	lea    rsi,[rip+0x1847c]        # 220b28 <__unnamed_2>
  2086ac:	48 89 df             	mov    rdi,rbx
  2086af:	41 ff d6             	call   r14
  2086b2:	66 85 c0             	test   ax,ax
  2086b5:	0f 85 2e 01 00 00    	jne    2087e9 <benchmark.add+0x219>
    comptime Errors: type,
    output: fn (@typeOf(context), []const u8) Errors!void,
) Errors!void {
    // max_int_digits accounts for the minus sign. when printing an unsigned
    // number we don't need to do that.
    var buf: [max_int_digits - 1]u8 = undefined;
  2086bb:	c5 fc 10 05 6c e3 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffffe36c]        # 206a2f <__unnamed_3+0x1f>
  2086c2:	ff 
  2086c3:	c5 fc 11 44 24 4f    	vmovups YMMWORD PTR [rsp+0x4f],ymm0
  2086c9:	c5 fe 6f 05 3f e3 ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffffe33f]        # 206a10 <__unnamed_3>
  2086d0:	ff 
  2086d1:	c5 fe 7f 44 24 30    	vmovdqu YMMWORD PTR [rsp+0x30],ymm0
    var index: usize = buf.len;

    while (true) {
        const digit = a % base;
        index -= 1;
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  2086d7:	c6 44 24 6f 31       	mov    BYTE PTR [rsp+0x6f],0x31
  2086dc:	48 8d 44 24 6f       	lea    rax,[rsp+0x6f]
            if (leftover_padding == 0) break;
        }
        mem.set(u8, buf[0..index], '0');
        return output(context, buf);
    } else {
        const padded_buf = buf[index - padding ..];
  2086e1:	48 89 44 24 20       	mov    QWORD PTR [rsp+0x20],rax
  2086e6:	48 c7 44 24 28 01 00 	mov    QWORD PTR [rsp+0x28],0x1
  2086ed:	00 00 
  2086ef:	48 8d 74 24 20       	lea    rsi,[rsp+0x20]
        mem.set(u8, padded_buf[0..padding], '0');
        return output(context, padded_buf);
  2086f4:	48 89 df             	mov    rdi,rbx
  2086f7:	c5 f8 77             	vzeroupper 
  2086fa:	41 ff d6             	call   r14
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  2086fd:	66 85 c0             	test   ax,ax
  208700:	0f 85 e3 00 00 00    	jne    2087e9 <benchmark.add+0x219>
                        try output(context, fmt[start_index..i]);
  208706:	48 8d 35 2b 84 01 00 	lea    rsi,[rip+0x1842b]        # 220b38 <__unnamed_4>
  20870d:	48 89 df             	mov    rdi,rbx
  208710:	41 ff d6             	call   r14
  208713:	66 85 c0             	test   ax,ax
  208716:	0f 85 cd 00 00 00    	jne    2087e9 <benchmark.add+0x219>
    var buf: [max_int_digits - 1]u8 = undefined;
  20871c:	c5 fc 10 05 03 e3 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffffe303]        # 206a27 <__unnamed_3+0x17>
  208723:	ff 
  208724:	c5 fc 11 44 24 47    	vmovups YMMWORD PTR [rsp+0x47],ymm0
  20872a:	c5 fe 6f 05 de e2 ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffffe2de]        # 206a10 <__unnamed_3>
  208731:	ff 
  208732:	c5 fe 7f 44 24 30    	vmovdqu YMMWORD PTR [rsp+0x30],ymm0
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  208738:	49 bf 30 30 30 30 30 	movabs r15,0x3030303030303030
  20873f:	30 30 30 
  208742:	4c 89 7c 24 68       	mov    QWORD PTR [rsp+0x68],r15
  208747:	c6 44 24 67 35       	mov    BYTE PTR [rsp+0x67],0x35
  20874c:	48 8d 44 24 67       	lea    rax,[rsp+0x67]
        const padded_buf = buf[index - padding ..];
  208751:	48 89 44 24 20       	mov    QWORD PTR [rsp+0x20],rax
  208756:	48 c7 44 24 28 09 00 	mov    QWORD PTR [rsp+0x28],0x9
  20875d:	00 00 
  20875f:	48 8d 74 24 20       	lea    rsi,[rsp+0x20]
        return output(context, padded_buf);
  208764:	48 89 df             	mov    rdi,rbx
  208767:	c5 f8 77             	vzeroupper 
  20876a:	41 ff d6             	call   r14
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  20876d:	66 85 c0             	test   ax,ax
  208770:	75 77                	jne    2087e9 <benchmark.add+0x219>
                        try output(context, fmt[start_index..i]);
  208772:	48 8d 35 cf 83 01 00 	lea    rsi,[rip+0x183cf]        # 220b48 <__unnamed_5>
  208779:	48 89 df             	mov    rdi,rbx
  20877c:	41 ff d6             	call   r14
  20877f:	66 85 c0             	test   ax,ax
  208782:	75 65                	jne    2087e9 <benchmark.add+0x219>
    var buf: [max_int_digits - 1]u8 = undefined;
  208784:	c5 fc 10 05 98 e2 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffffe298]        # 206a24 <__unnamed_3+0x14>
  20878b:	ff 
  20878c:	c5 fc 11 44 24 44    	vmovups YMMWORD PTR [rsp+0x44],ymm0
  208792:	c5 fe 6f 05 76 e2 ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffffe276]        # 206a10 <__unnamed_3>
  208799:	ff 
  20879a:	c5 fe 7f 44 24 30    	vmovdqu YMMWORD PTR [rsp+0x30],ymm0
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  2087a0:	4c 89 7c 24 65       	mov    QWORD PTR [rsp+0x65],r15
  2087a5:	c6 44 24 6f 30       	mov    BYTE PTR [rsp+0x6f],0x30
  2087aa:	66 c7 44 24 6d 30 30 	mov    WORD PTR [rsp+0x6d],0x3030
  2087b1:	c6 44 24 64 31       	mov    BYTE PTR [rsp+0x64],0x31
  2087b6:	48 8d 44 24 64       	lea    rax,[rsp+0x64]
        const padded_buf = buf[index - padding ..];
  2087bb:	48 89 44 24 20       	mov    QWORD PTR [rsp+0x20],rax
  2087c0:	48 c7 44 24 28 0c 00 	mov    QWORD PTR [rsp+0x28],0xc
  2087c7:	00 00 
  2087c9:	48 8d 74 24 20       	lea    rsi,[rsp+0x20]
        return output(context, padded_buf);
  2087ce:	48 89 df             	mov    rdi,rbx
  2087d1:	c5 f8 77             	vzeroupper 
  2087d4:	41 ff d6             	call   r14
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  2087d7:	66 85 c0             	test   ax,ax
  2087da:	75 0d                	jne    2087e9 <benchmark.add+0x219>
        try output(context, fmt[start_index..]);
  2087dc:	48 8d 35 75 83 01 00 	lea    rsi,[rip+0x18375]        # 220b58 <__unnamed_6>
  2087e3:	48 89 df             	mov    rdi,rbx
  2087e6:	41 ff d6             	call   r14
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  2087e9:	31 c0                	xor    eax,eax
  2087eb:	86 05 1f 88 01 00    	xchg   BYTE PTR [rip+0x1881f],al        # 221010 <stderr_mutex>
  2087f1:	3c 01                	cmp    al,0x1
    if (!ok) {
  2087f3:	0f 85 21 05 00 00    	jne    208d1a <benchmark.add+0x74a>
                //On Linux, seccomp can do arbitrary things to our ability to call
                //  syscalls, including return any errno value it wants and
                //  inconsistently throwing errors. Since we can't account for
                //  abuses of seccomp in a reasonable way, we'll assume that if
                //  seccomp is going to block us it will at least do so consistently
                var ts: posix.timespec = undefined;
  2087f9:	c5 fa 6f 05 8f e3 ff 	vmovdqu xmm0,XMMWORD PTR [rip+0xffffffffffffe38f]        # 206b90 <__unnamed_7>
  208800:	ff 
  208801:	c5 f9 7f 44 24 30    	vmovdqa XMMWORD PTR [rsp+0x30],xmm0
  208807:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
        : "rcx", "r11"
    );
}

pub fn syscall2(number: usize, arg1: usize, arg2: usize) usize {
    return asm volatile ("syscall"
  20880c:	b8 e5 00 00 00       	mov    eax,0xe5
  208811:	bf 01 00 00 00       	mov    edi,0x1
  208816:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  208818:	48 89 c2             	mov    rdx,rax
  20881b:	48 f7 da             	neg    rdx
  20881e:	31 c9                	xor    ecx,ecx
  208820:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  208826:	48 0f 47 ca          	cmova  rcx,rdx
                var result = posix.clock_getres(monotonic_clock_id, &ts);
                var errno = posix.getErrno(result);
                switch (errno) {
  20882a:	48 85 c9             	test   rcx,rcx
  20882d:	74 13                	je     208842 <benchmark.add+0x272>
  20882f:	48 83 f9 16          	cmp    rcx,0x16
  208833:	0f 85 85 04 00 00    	jne    208cbe <benchmark.add+0x6ee>
  208839:	66 b8 01 00          	mov    ax,0x1
  20883d:	e9 80 04 00 00       	jmp    208cc2 <benchmark.add+0x6f2>
        const f = @atomicLoad(@typeOf(init_vdso_clock_gettime), &vdso_clock_gettime, builtin.AtomicOrder.Unordered);
  208842:	48 8b 05 cf 47 01 00 	mov    rax,QWORD PTR [rip+0x147cf]        # 21d018 <vdso_clock_gettime>
        if (@ptrToInt(f) != 0) {
  208849:	48 85 c0             	test   rax,rax
  20884c:	74 23                	je     208871 <benchmark.add+0x2a1>
  20884e:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
            const rc = f(clk_id, tp);
  208853:	bf 01 00 00 00       	mov    edi,0x1
  208858:	ff d0                	call   rax
            switch (rc) {
  20885a:	48 83 f8 ea          	cmp    rax,0xffffffffffffffea
  20885e:	0f 84 46 04 00 00    	je     208caa <benchmark.add+0x6da>
  208864:	48 85 c0             	test   rax,rax
  208867:	c5 fa 6f 05 21 e3 ff 	vmovdqu xmm0,XMMWORD PTR [rip+0xffffffffffffe321]        # 206b90 <__unnamed_7>
  20886e:	ff 
  20886f:	74 11                	je     208882 <benchmark.add+0x2b2>
  208871:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
  208876:	b8 e4 00 00 00       	mov    eax,0xe4
  20887b:	bf 01 00 00 00       	mov    edi,0x1
  208880:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  208882:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
                }
                self.resolution = @intCast(u64, ts.tv_sec) * u64(ns_per_s) + @intCast(u64, ts.tv_nsec);

                result = posix.clock_gettime(monotonic_clock_id, &ts);
                errno = posix.getErrno(result);
                if (errno != 0) return std.os.unexpectedErrorPosix(errno);
  208888:	0f 83 30 04 00 00    	jae    208cbe <benchmark.add+0x6ee>
                self.start_time = @intCast(u64, ts.tv_sec) * u64(ns_per_s) + @intCast(u64, ts.tv_nsec);
  20888e:	48 8b 5c 24 30       	mov    rbx,QWORD PTR [rsp+0x30]
  208893:	4c 8b 74 24 38       	mov    r14,QWORD PTR [rsp+0x38]
    fn clockDarwin() u64 {
        return darwin.mach_absolute_time();
    }

    fn clockLinux() u64 {
        var ts: posix.timespec = undefined;
  208898:	c5 f9 7f 44 24 30    	vmovdqa XMMWORD PTR [rsp+0x30],xmm0
        const f = @atomicLoad(@typeOf(init_vdso_clock_gettime), &vdso_clock_gettime, builtin.AtomicOrder.Unordered);
  20889e:	48 8b 05 73 47 01 00 	mov    rax,QWORD PTR [rip+0x14773]        # 21d018 <vdso_clock_gettime>
        if (@ptrToInt(f) != 0) {
  2088a5:	48 85 c0             	test   rax,rax
  2088a8:	74 23                	je     2088cd <benchmark.add+0x2fd>
  2088aa:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
            const rc = f(clk_id, tp);
  2088af:	bf 01 00 00 00       	mov    edi,0x1
  2088b4:	ff d0                	call   rax
            switch (rc) {
  2088b6:	48 83 f8 ea          	cmp    rax,0xffffffffffffffea
  2088ba:	0f 84 46 04 00 00    	je     208d06 <benchmark.add+0x736>
  2088c0:	48 85 c0             	test   rax,rax
  2088c3:	c5 fa 6f 05 c5 e2 ff 	vmovdqu xmm0,XMMWORD PTR [rip+0xffffffffffffe2c5]        # 206b90 <__unnamed_7>
  2088ca:	ff 
  2088cb:	74 11                	je     2088de <benchmark.add+0x30e>
  2088cd:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
  2088d2:	b8 e4 00 00 00       	mov    eax,0xe4
  2088d7:	bf 01 00 00 00       	mov    edi,0x1
  2088dc:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  2088de:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
  2088e4:	0f 83 30 04 00 00    	jae    208d1a <benchmark.add+0x74a>
        var result = posix.clock_gettime(monotonic_clock_id, &ts);
        debug.assert(posix.getErrno(result) == 0);
        return @intCast(u64, ts.tv_sec) * u64(ns_per_s) + @intCast(u64, ts.tv_nsec);
  2088ea:	48 8b 44 24 30       	mov    rax,QWORD PTR [rsp+0x30]
  2088ef:	48 29 d8             	sub    rax,rbx
  2088f2:	48 8b 4c 24 38       	mov    rcx,QWORD PTR [rsp+0x38]
  2088f7:	4c 29 f1             	sub    rcx,r14
  2088fa:	48 69 c0 00 ca 9a 3b 	imul   rax,rax,0x3b9aca00
        var clock = clockNative() - self.start_time;
  208901:	48 01 c8             	add    rax,rcx
    pub fn init(seed: u64) SplitMix64 {
        return SplitMix64{ .s = seed };
    }

    pub fn next(self: *SplitMix64) u64 {
        self.s +%= 0x9e3779b97f4a7c15;
  208904:	48 b9 15 7c 4a 7f b9 	movabs rcx,0x9e3779b97f4a7c15
  20890b:	79 37 9e 
  20890e:	48 01 c1             	add    rcx,rax

        var z = self.s;
        z = (z ^ (z >> 30)) *% 0xbf58476d1ce4e5b9;
  208911:	48 89 ca             	mov    rdx,rcx
  208914:	48 c1 ea 1e          	shr    rdx,0x1e
  208918:	48 31 ca             	xor    rdx,rcx
  20891b:	48 b9 b9 e5 e4 1c 6d 	movabs rcx,0xbf58476d1ce4e5b9
  208922:	47 58 bf 
  208925:	48 0f af d1          	imul   rdx,rcx
        z = (z ^ (z >> 27)) *% 0x94d049bb133111eb;
  208929:	48 89 d6             	mov    rsi,rdx
  20892c:	48 c1 ee 1b          	shr    rsi,0x1b
  208930:	48 31 d6             	xor    rsi,rdx
  208933:	48 ba eb 11 31 13 bb 	movabs rdx,0x94d049bb133111eb
  20893a:	49 d0 94 
  20893d:	48 0f af f2          	imul   rsi,rdx
        return z ^ (z >> 31);
  208941:	48 89 f7             	mov    rdi,rsi
  208944:	48 c1 ef 1f          	shr    rdi,0x1f
  208948:	48 31 f7             	xor    rdi,rsi
        self.s +%= 0x9e3779b97f4a7c15;
  20894b:	48 be 2a f8 94 fe 72 	movabs rsi,0x3c6ef372fe94f82a
  208952:	f3 6e 3c 
  208955:	48 01 c6             	add    rsi,rax
        z = (z ^ (z >> 30)) *% 0xbf58476d1ce4e5b9;
  208958:	48 89 f0             	mov    rax,rsi
  20895b:	48 c1 e8 1e          	shr    rax,0x1e
  20895f:	48 31 f0             	xor    rax,rsi
  208962:	48 0f af c1          	imul   rax,rcx
        z = (z ^ (z >> 27)) *% 0x94d049bb133111eb;
  208966:	48 89 c1             	mov    rcx,rax
  208969:	48 c1 e9 1b          	shr    rcx,0x1b
  20896d:	48 31 c1             	xor    rcx,rax
  208970:	48 0f af ca          	imul   rcx,rdx
        return z ^ (z >> 31);
  208974:	48 89 c8             	mov    rax,rcx
  208977:	48 c1 e8 1f          	shr    rax,0x1f
  20897b:	48 31 c8             	xor    rax,rcx
    }

    fn next(self: *Xoroshiro128) u64 {
        const s0 = self.s[0];
        var s1 = self.s[1];
        const r = s0 +% s1;
  20897e:	48 8d 0c 38          	lea    rcx,[rax+rdi*1]

        s1 ^= s0;
  208982:	48 31 f8             	xor    rax,rdi
pub fn rotl(comptime T: type, x: T, r: var) T {
    if (T.is_signed) {
        @compileError("cannot rotate signed integer");
    } else {
        const ar = @mod(r, T.bit_count);
        return shl(T, x, ar) | shr(T, x, T.bit_count - ar);
  208985:	c4 e3 fb f0 d7 09    	rorx   rdx,rdi,0x9
        self.s[0] = math.rotl(u64, s0, u8(55)) ^ s1 ^ (s1 << 14);
  20898b:	48 31 c2             	xor    rdx,rax
  20898e:	c4 e3 fb f0 f0 1c    	rorx   rsi,rax,0x1c
  208994:	48 c1 e0 0e          	shl    rax,0xe
  208998:	48 31 d0             	xor    rax,rdx
        const r = s0 +% s1;
  20899b:	48 01 f0             	add    rax,rsi
        // Setup prior to the first call to Self.benchmark, may return void or !void
        fn setup(pSelf: *Self) !void {
            var timer = try Timer.start();
            const DefaultPrng = std.rand.DefaultPrng;
            var prng = DefaultPrng.init(timer.read());
            pSelf.a = prng.random.scalar(u64);
  20899e:	48 89 4c 24 08       	mov    QWORD PTR [rsp+0x8],rcx
            pSelf.b = prng.random.scalar(u64);
  2089a3:	48 89 04 24          	mov    QWORD PTR [rsp],rax
  2089a7:	49 bc 00 e8 76 48 17 	movabs r12,0x174876e800
  2089ae:	00 00 00 
  2089b1:	41 bf 01 00 00 00    	mov    r15d,0x1
  2089b7:	4c 8d 74 24 30       	lea    r14,[rsp+0x30]
  2089bc:	45 31 ed             	xor    r13d,r13d
  2089bf:	eb 16                	jmp    2089d7 <benchmark.add+0x407>
  2089c1:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  2089c8:	0f 1f 84 00 00 00 00 
  2089cf:	00 
                if (iterations > pSelf.max_iterations) {
  2089d0:	4d 39 e7             	cmp    r15,r12
  2089d3:	4d 0f 43 fc          	cmovae r15,r12
                var ts: posix.timespec = undefined;
  2089d7:	c5 f9 7f 44 24 30    	vmovdqa XMMWORD PTR [rsp+0x30],xmm0
  2089dd:	b8 e5 00 00 00       	mov    eax,0xe5
  2089e2:	bf 01 00 00 00       	mov    edi,0x1
  2089e7:	4c 89 f6             	mov    rsi,r14
  2089ea:	0f 05                	syscall 
  2089ec:	48 89 c1             	mov    rcx,rax
  2089ef:	48 f7 d9             	neg    rcx
  2089f2:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  2089f8:	49 0f 46 cd          	cmovbe rcx,r13
                switch (errno) {
  2089fc:	48 85 c9             	test   rcx,rcx
  2089ff:	0f 85 2a fe ff ff    	jne    20882f <benchmark.add+0x25f>
        const f = @atomicLoad(@typeOf(init_vdso_clock_gettime), &vdso_clock_gettime, builtin.AtomicOrder.Unordered);
  208a05:	48 8b 05 0c 46 01 00 	mov    rax,QWORD PTR [rip+0x1460c]        # 21d018 <vdso_clock_gettime>
        if (@ptrToInt(f) != 0) {
  208a0c:	48 85 c0             	test   rax,rax
  208a0f:	74 21                	je     208a32 <benchmark.add+0x462>
            const rc = f(clk_id, tp);
  208a11:	bf 01 00 00 00       	mov    edi,0x1
  208a16:	4c 89 f6             	mov    rsi,r14
  208a19:	ff d0                	call   rax
            switch (rc) {
  208a1b:	48 83 f8 ea          	cmp    rax,0xffffffffffffffea
  208a1f:	0f 84 5b 02 00 00    	je     208c80 <benchmark.add+0x6b0>
  208a25:	48 85 c0             	test   rax,rax
  208a28:	c5 fa 6f 05 60 e1 ff 	vmovdqu xmm0,XMMWORD PTR [rip+0xffffffffffffe160]        # 206b90 <__unnamed_7>
  208a2f:	ff 
  208a30:	74 0f                	je     208a41 <benchmark.add+0x471>
  208a32:	b8 e4 00 00 00       	mov    eax,0xe4
  208a37:	bf 01 00 00 00       	mov    edi,0x1
  208a3c:	4c 89 f6             	mov    rsi,r14
  208a3f:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  208a41:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
                if (errno != 0) return std.os.unexpectedErrorPosix(errno);
  208a47:	0f 83 71 02 00 00    	jae    208cbe <benchmark.add+0x6ee>
                self.start_time = @intCast(u64, ts.tv_sec) * u64(ns_per_s) + @intCast(u64, ts.tv_nsec);
  208a4d:	c5 f9 6f 4c 24 30    	vmovdqa xmm1,XMMWORD PTR [rsp+0x30]
        while (iter > 0) : (iter -= 1) {
  208a53:	4d 85 ff             	test   r15,r15
  208a56:	0f 84 1e 01 00 00    	je     208b7a <benchmark.add+0x5aa>
            //lfence();
            //@fence(AtomicOrder.Acquire); // Generates no type of fence, expected lfence
            var pA: *volatile u64 = &pSelf.a;
            var pB: *volatile u64 = &pSelf.b;
            var pR: *volatile u128 = &pSelf.r;
            pR.* = u128(pA.*) + u128(pB.*);
  208a5c:	49 8d 4f ff          	lea    rcx,[r15-0x1]
  208a60:	4c 89 fa             	mov    rdx,r15
  208a63:	4c 89 f8             	mov    rax,r15
  208a66:	48 83 e2 07          	and    rdx,0x7
  208a6a:	74 37                	je     208aa3 <benchmark.add+0x4d3>
  208a6c:	48 f7 da             	neg    rdx
  208a6f:	4c 89 f8             	mov    rax,r15
  208a72:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  208a79:	1f 84 00 00 00 00 00 
  208a80:	48 8b 74 24 08       	mov    rsi,QWORD PTR [rsp+0x8]
  208a85:	31 ff                	xor    edi,edi
  208a87:	48 03 34 24          	add    rsi,QWORD PTR [rsp]
  208a8b:	40 0f 92 c7          	setb   dil
  208a8f:	48 89 74 24 10       	mov    QWORD PTR [rsp+0x10],rsi
  208a94:	48 89 7c 24 18       	mov    QWORD PTR [rsp+0x18],rdi
        while (iter > 0) : (iter -= 1) {
  208a99:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  208a9d:	48 83 c2 01          	add    rdx,0x1
  208aa1:	75 dd                	jne    208a80 <benchmark.add+0x4b0>
            pR.* = u128(pA.*) + u128(pB.*);
  208aa3:	48 83 f9 07          	cmp    rcx,0x7
  208aa7:	0f 82 cd 00 00 00    	jb     208b7a <benchmark.add+0x5aa>
  208aad:	0f 1f 00             	nop    DWORD PTR [rax]
  208ab0:	48 8b 4c 24 08       	mov    rcx,QWORD PTR [rsp+0x8]
  208ab5:	31 d2                	xor    edx,edx
  208ab7:	48 03 0c 24          	add    rcx,QWORD PTR [rsp]
  208abb:	0f 92 c2             	setb   dl
  208abe:	48 89 4c 24 10       	mov    QWORD PTR [rsp+0x10],rcx
  208ac3:	48 89 54 24 18       	mov    QWORD PTR [rsp+0x18],rdx
  208ac8:	31 c9                	xor    ecx,ecx
  208aca:	48 8b 54 24 08       	mov    rdx,QWORD PTR [rsp+0x8]
  208acf:	48 03 14 24          	add    rdx,QWORD PTR [rsp]
  208ad3:	48 89 54 24 10       	mov    QWORD PTR [rsp+0x10],rdx
  208ad8:	0f 92 c1             	setb   cl
  208adb:	48 89 4c 24 18       	mov    QWORD PTR [rsp+0x18],rcx
  208ae0:	48 8b 4c 24 08       	mov    rcx,QWORD PTR [rsp+0x8]
  208ae5:	31 d2                	xor    edx,edx
  208ae7:	48 03 0c 24          	add    rcx,QWORD PTR [rsp]
  208aeb:	0f 92 c2             	setb   dl
  208aee:	48 89 4c 24 10       	mov    QWORD PTR [rsp+0x10],rcx
  208af3:	48 89 54 24 18       	mov    QWORD PTR [rsp+0x18],rdx
  208af8:	48 8b 4c 24 08       	mov    rcx,QWORD PTR [rsp+0x8]
  208afd:	31 d2                	xor    edx,edx
  208aff:	48 03 0c 24          	add    rcx,QWORD PTR [rsp]
  208b03:	0f 92 c2             	setb   dl
  208b06:	48 89 4c 24 10       	mov    QWORD PTR [rsp+0x10],rcx
  208b0b:	48 89 54 24 18       	mov    QWORD PTR [rsp+0x18],rdx
  208b10:	31 c9                	xor    ecx,ecx
  208b12:	48 8b 54 24 08       	mov    rdx,QWORD PTR [rsp+0x8]
  208b17:	48 03 14 24          	add    rdx,QWORD PTR [rsp]
  208b1b:	48 89 54 24 10       	mov    QWORD PTR [rsp+0x10],rdx
  208b20:	0f 92 c1             	setb   cl
  208b23:	48 89 4c 24 18       	mov    QWORD PTR [rsp+0x18],rcx
  208b28:	48 8b 4c 24 08       	mov    rcx,QWORD PTR [rsp+0x8]
  208b2d:	31 d2                	xor    edx,edx
  208b2f:	48 03 0c 24          	add    rcx,QWORD PTR [rsp]
  208b33:	0f 92 c2             	setb   dl
  208b36:	48 89 4c 24 10       	mov    QWORD PTR [rsp+0x10],rcx
  208b3b:	48 89 54 24 18       	mov    QWORD PTR [rsp+0x18],rdx
  208b40:	48 8b 4c 24 08       	mov    rcx,QWORD PTR [rsp+0x8]
  208b45:	31 d2                	xor    edx,edx
  208b47:	48 03 0c 24          	add    rcx,QWORD PTR [rsp]
  208b4b:	0f 92 c2             	setb   dl
  208b4e:	48 89 4c 24 10       	mov    QWORD PTR [rsp+0x10],rcx
  208b53:	48 89 54 24 18       	mov    QWORD PTR [rsp+0x18],rdx
  208b58:	31 c9                	xor    ecx,ecx
  208b5a:	48 8b 54 24 08       	mov    rdx,QWORD PTR [rsp+0x8]
  208b5f:	48 03 14 24          	add    rdx,QWORD PTR [rsp]
  208b63:	48 89 54 24 10       	mov    QWORD PTR [rsp+0x10],rdx
  208b68:	0f 92 c1             	setb   cl
        while (iter > 0) : (iter -= 1) {
  208b6b:	48 83 c0 f8          	add    rax,0xfffffffffffffff8
            pR.* = u128(pA.*) + u128(pB.*);
  208b6f:	48 89 4c 24 18       	mov    QWORD PTR [rsp+0x18],rcx
        while (iter > 0) : (iter -= 1) {
  208b74:	0f 85 36 ff ff ff    	jne    208ab0 <benchmark.add+0x4e0>
        var ts: posix.timespec = undefined;
  208b7a:	c5 f9 7f 44 24 30    	vmovdqa XMMWORD PTR [rsp+0x30],xmm0
        const f = @atomicLoad(@typeOf(init_vdso_clock_gettime), &vdso_clock_gettime, builtin.AtomicOrder.Unordered);
  208b80:	48 8b 05 91 44 01 00 	mov    rax,QWORD PTR [rip+0x14491]        # 21d018 <vdso_clock_gettime>
        if (@ptrToInt(f) != 0) {
  208b87:	48 85 c0             	test   rax,rax
  208b8a:	74 25                	je     208bb1 <benchmark.add+0x5e1>
  208b8c:	c5 f9 7f 4c 24 70    	vmovdqa XMMWORD PTR [rsp+0x70],xmm1
            const rc = f(clk_id, tp);
  208b92:	bf 01 00 00 00       	mov    edi,0x1
  208b97:	4c 89 f6             	mov    rsi,r14
  208b9a:	ff d0                	call   rax
            switch (rc) {
  208b9c:	48 83 f8 ea          	cmp    rax,0xffffffffffffffea
  208ba0:	0f 84 f0 00 00 00    	je     208c96 <benchmark.add+0x6c6>
  208ba6:	48 85 c0             	test   rax,rax
  208ba9:	c5 f9 6f 4c 24 70    	vmovdqa xmm1,XMMWORD PTR [rsp+0x70]
  208baf:	74 0f                	je     208bc0 <benchmark.add+0x5f0>
  208bb1:	b8 e4 00 00 00       	mov    eax,0xe4
  208bb6:	bf 01 00 00 00       	mov    edi,0x1
  208bbb:	4c 89 f6             	mov    rsi,r14
  208bbe:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  208bc0:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
  208bc6:	0f 83 4e 01 00 00    	jae    208d1a <benchmark.add+0x74a>
        return @intCast(u64, ts.tv_sec) * u64(ns_per_s) + @intCast(u64, ts.tv_nsec);
  208bcc:	c5 f9 6f 44 24 30    	vmovdqa xmm0,XMMWORD PTR [rsp+0x30]
  208bd2:	c5 f9 fb c1          	vpsubq xmm0,xmm0,xmm1
  208bd6:	c4 e1 f9 7e c0       	vmovq  rax,xmm0
  208bdb:	48 69 c0 00 ca 9a 3b 	imul   rax,rax,0x3b9aca00
        var clock = clockNative() - self.start_time;
  208be2:	c4 e3 f9 16 c3 01    	vpextrq rbx,xmm0,0x1
  208be8:	48 01 c3             	add    rbx,rax
            if (pSelf.logl >= 1) pSelf.report(run_time, iterations);
  208beb:	48 89 df             	mov    rdi,rbx
  208bee:	4c 89 fe             	mov    rsi,r15
  208bf1:	e8 ea 19 00 00       	call   20a5e0 <BenchmarkFramework_report>
            if ((run_time >= pSelf.min_runtime_ns) or (iterations >= pSelf.max_iterations)) {
  208bf6:	4d 39 e7             	cmp    r15,r12
  208bf9:	0f 83 d4 00 00 00    	jae    208cd3 <benchmark.add+0x703>
  208bff:	48 81 fb ff 64 cd 1d 	cmp    rbx,0x1dcd64ff
  208c06:	0f 87 c7 00 00 00    	ja     208cd3 <benchmark.add+0x703>
                if (run_time < 1000) {
  208c0c:	48 81 fb e8 03 00 00 	cmp    rbx,0x3e8
  208c13:	73 1b                	jae    208c30 <benchmark.add+0x660>
  208c15:	b9 01 00 00 00       	mov    ecx,0x1
  208c1a:	b8 e8 03 00 00       	mov    eax,0x3e8
  208c1f:	eb 2b                	jmp    208c4c <benchmark.add+0x67c>
  208c21:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  208c28:	0f 1f 84 00 00 00 00 
  208c2f:	00 
                } else if (run_time < (pSelf.min_runtime_ns / 10)) {
  208c30:	31 c0                	xor    eax,eax
  208c32:	48 81 fb 7f f0 fa 02 	cmp    rbx,0x2faf07f
  208c39:	0f 97 c0             	seta   al
  208c3c:	48 8d 0c c0          	lea    rcx,[rax+rax*8]
  208c40:	48 83 c1 01          	add    rcx,0x1
  208c44:	48 8d 04 85 0a 00 00 	lea    rax,[rax*4+0xa]
  208c4b:	00 
  208c4c:	c5 fa 6f 05 3c df ff 	vmovdqu xmm0,XMMWORD PTR [rip+0xffffffffffffdf3c]        # 206b90 <__unnamed_7>
  208c53:	ff 
                iterations = (iterations * numer) / denom;
  208c54:	49 0f af c7          	imul   rax,r15
  208c58:	48 89 c2             	mov    rdx,rax
  208c5b:	48 c1 ea 20          	shr    rdx,0x20
  208c5f:	74 0f                	je     208c70 <benchmark.add+0x6a0>
  208c61:	31 d2                	xor    edx,edx
  208c63:	48 f7 f1             	div    rcx
  208c66:	49 89 c7             	mov    r15,rax
  208c69:	e9 62 fd ff ff       	jmp    2089d0 <benchmark.add+0x400>
  208c6e:	66 90                	xchg   ax,ax
  208c70:	31 d2                	xor    edx,edx
  208c72:	f7 f1                	div    ecx
  208c74:	41 89 c7             	mov    r15d,eax
  208c77:	e9 54 fd ff ff       	jmp    2089d0 <benchmark.add+0x400>
  208c7c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  208c80:	c5 fa 6f 05 08 df ff 	vmovdqu xmm0,XMMWORD PTR [rip+0xffffffffffffdf08]        # 206b90 <__unnamed_7>
  208c87:	ff 
  208c88:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
                if (errno != 0) return std.os.unexpectedErrorPosix(errno);
  208c8e:	0f 82 b9 fd ff ff    	jb     208a4d <benchmark.add+0x47d>
  208c94:	eb 28                	jmp    208cbe <benchmark.add+0x6ee>
  208c96:	c5 f9 6f 4c 24 70    	vmovdqa xmm1,XMMWORD PTR [rsp+0x70]
  208c9c:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
  208ca2:	0f 82 24 ff ff ff    	jb     208bcc <benchmark.add+0x5fc>
  208ca8:	eb 70                	jmp    208d1a <benchmark.add+0x74a>
  208caa:	c5 fa 6f 05 de de ff 	vmovdqu xmm0,XMMWORD PTR [rip+0xffffffffffffdede]        # 206b90 <__unnamed_7>
  208cb1:	ff 
  208cb2:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
  208cb8:	0f 82 d0 fb ff ff    	jb     20888e <benchmark.add+0x2be>
  208cbe:	66 b8 02 00          	mov    ax,0x2

    // Since this is a test print a \n before we run
    warn("\n");

    // Run the benchmark
    try bf.run(BmAdd);
  208cc2:	48 81 c4 80 00 00 00 	add    rsp,0x80
  208cc9:	5b                   	pop    rbx
  208cca:	41 5c                	pop    r12
  208ccc:	41 5d                	pop    r13
  208cce:	41 5e                	pop    r14
  208cd0:	41 5f                	pop    r15
  208cd2:	c3                   	ret    
  208cd3:	48 8b 04 24          	mov    rax,QWORD PTR [rsp]
            if (pSelf.r != pSelf.a + pSelf.b) return error.Failed;
  208cd7:	48 03 44 24 08       	add    rax,QWORD PTR [rsp+0x8]
  208cdc:	c4 e1 f9 6e c0       	vmovq  xmm0,rax
  208ce1:	c5 f9 74 44 24 10    	vpcmpeqb xmm0,xmm0,XMMWORD PTR [rsp+0x10]
  208ce7:	c5 f9 d7 c8          	vpmovmskb ecx,xmm0
  208ceb:	66 b8 03 00          	mov    ax,0x3
  208cef:	81 f9 ff ff 00 00    	cmp    ecx,0xffff
            try bm.tearDown();
  208cf5:	75 cb                	jne    208cc2 <benchmark.add+0x6f2>
        pSelf.report(run_time, iterations);
  208cf7:	48 89 df             	mov    rdi,rbx
  208cfa:	4c 89 fe             	mov    rsi,r15
  208cfd:	e8 de 18 00 00       	call   20a5e0 <BenchmarkFramework_report>
  208d02:	31 c0                	xor    eax,eax
  208d04:	eb bc                	jmp    208cc2 <benchmark.add+0x6f2>
  208d06:	c5 fa 6f 05 82 de ff 	vmovdqu xmm0,XMMWORD PTR [rip+0xffffffffffffde82]        # 206b90 <__unnamed_7>
  208d0d:	ff 
  208d0e:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
  208d14:	0f 82 d0 fb ff ff    	jb     2088ea <benchmark.add+0x31a>
            @panic("assertion failure");
  208d1a:	e8 01 00 00 00       	call   208d20 <panic>
  208d1f:	90                   	nop

0000000000208d20 <panic>:
        // TODO: fix panic in zen.
        builtin.Os.freestanding, builtin.Os.zen => {
            while (true) {}
        },
        else => {
            const first_trace_addr = @ptrToInt(@returnAddress());
  208d20:	48 83 ec 18          	sub    rsp,0x18
  208d24:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
            std.debug.panicExtra(error_return_trace, first_trace_addr, "{}", msg);
  208d29:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  208d2e:	c6 44 24 10 01       	mov    BYTE PTR [rsp+0x10],0x1
  208d33:	48 8d 7c 24 08       	lea    rdi,[rsp+0x8]
  208d38:	e8 03 00 00 00       	call   208d40 <panicExtra>
  208d3d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000208d40 <panicExtra>:
    panicExtra(null, first_trace_addr, format, args);
}

var panicking: u8 = 0; // TODO make this a bool

pub fn panicExtra(trace: ?*const builtin.StackTrace, first_trace_addr: ?usize, comptime format: []const u8, args: ...) noreturn {
  208d40:	41 57                	push   r15
  208d42:	41 56                	push   r14
  208d44:	53                   	push   rbx
  208d45:	48 83 ec 10          	sub    rsp,0x10
  208d49:	b0 01                	mov    al,0x1
    @setCold(true);

    if (@atomicRmw(u8, &panicking, builtin.AtomicRmwOp.Xchg, 1, builtin.AtomicOrder.SeqCst) == 1) {
  208d4b:	86 05 af 82 01 00    	xchg   BYTE PTR [rip+0x182af],al        # 221000 <panicking>
  208d51:	49 89 fe             	mov    r14,rdi
  208d54:	3c 01                	cmp    al,0x1
  208d56:	74 7e                	je     208dd6 <panicExtra+0x96>
    if (stderr_stream) |st| {
  208d58:	48 8b 1d a9 82 01 00 	mov    rbx,QWORD PTR [rip+0x182a9]        # 221008 <stderr_stream>
  208d5f:	48 85 db             	test   rbx,rbx
  208d62:	75 36                	jne    208d9a <panicExtra+0x5a>
        stderr_file = try io.getStdErr();
  208d64:	48 8d 05 95 42 01 00 	lea    rax,[rip+0x14295]        # 21d000 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  208d6b:	48 89 05 96 42 01 00 	mov    QWORD PTR [rip+0x14296],rax        # 21d008 <stderr_file_out_stream>
  208d72:	4c 8d 3d 87 1a 00 00 	lea    r15,[rip+0x1a87]        # 20a800 <FileOutStream_writeFn>
  208d79:	4c 89 3d 90 42 01 00 	mov    QWORD PTR [rip+0x14290],r15        # 21d010 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  208d80:	c7 05 76 42 01 00 02 	mov    DWORD PTR [rip+0x14276],0x2        # 21d000 <stderr_file>
  208d87:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  208d8a:	48 8d 1d 7f 42 01 00 	lea    rbx,[rip+0x1427f]        # 21d010 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  208d91:	48 89 1d 70 82 01 00 	mov    QWORD PTR [rip+0x18270],rbx        # 221008 <stderr_stream>
  208d98:	eb 07                	jmp    208da1 <panicExtra+0x61>
  208d9a:	4c 8b 3d 6f 42 01 00 	mov    r15,QWORD PTR [rip+0x1426f]        # 21d010 <stderr_file_out_stream+0x8>
                const casted_value = ([]const u8)(value);
  208da1:	c5 f8 10 05 0f 7e 01 	vmovups xmm0,XMMWORD PTR [rip+0x17e0f]        # 220bb8 <__unnamed_8>
  208da8:	00 
  208da9:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
  208dae:	48 89 e6             	mov    rsi,rsp
                return output(context, casted_value);
  208db1:	48 89 df             	mov    rdi,rbx
  208db4:	41 ff d7             	call   r15
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  208db7:	66 85 c0             	test   ax,ax
  208dba:	75 1a                	jne    208dd6 <panicExtra+0x96>
        try output(context, fmt[start_index..]);
  208dbc:	48 8d 35 55 7d 01 00 	lea    rsi,[rip+0x17d55]        # 220b18 <__unnamed_9>
  208dc3:	48 89 df             	mov    rdi,rbx
  208dc6:	41 ff d7             	call   r15
        // we would want to return here instead of calling abort, so that the thread
        // which first called panic can finish printing a stack trace.
        os.abort();
    }
    const stderr = getStderrStream() catch os.abort();
    stderr.print(format ++ "\n", args) catch os.abort();
  208dc9:	66 85 c0             	test   ax,ax
  208dcc:	75 08                	jne    208dd6 <panicExtra+0x96>
    if (trace) |t| {
        dumpStackTrace(t);
    }
    dumpCurrentStackTrace(first_trace_addr);
  208dce:	4c 89 f7             	mov    rdi,r14
  208dd1:	e8 0a 01 00 00       	call   208ee0 <dumpCurrentStackTrace>
  208dd6:	e8 05 00 00 00       	call   208de0 <abort>
  208ddb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000208de0 <abort>:
pub const SIG_DFL = @intToPtr(extern fn (i32) void, 0);
pub const SIG_IGN = @intToPtr(extern fn (i32) void, 1);
pub const empty_sigset = []usize{0} ** sigset_t.len;

pub fn raise(sig: i32) usize {
    var set: sigset_t = undefined;
  208de0:	50                   	push   rax
  208de1:	c5 fc 10 05 17 c6 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffffc617]        # 205400 <__unnamed_10+0x60>
  208de8:	ff 
  208de9:	c5 fc 11 44 24 e0    	vmovups YMMWORD PTR [rsp-0x20],ymm0
  208def:	c5 fc 10 0d e9 c5 ff 	vmovups ymm1,YMMWORD PTR [rip+0xffffffffffffc5e9]        # 2053e0 <__unnamed_10+0x40>
  208df6:	ff 
  208df7:	c5 fc 11 4c 24 c0    	vmovups YMMWORD PTR [rsp-0x40],ymm1
  208dfd:	c5 fc 10 15 bb c5 ff 	vmovups ymm2,YMMWORD PTR [rip+0xffffffffffffc5bb]        # 2053c0 <__unnamed_10+0x20>
  208e04:	ff 
  208e05:	c5 fc 11 54 24 a0    	vmovups YMMWORD PTR [rsp-0x60],ymm2
  208e0b:	c5 fc 10 1d 8d c5 ff 	vmovups ymm3,YMMWORD PTR [rip+0xffffffffffffc58d]        # 2053a0 <__unnamed_10>
  208e12:	ff 
  208e13:	c5 fc 11 5c 24 80    	vmovups YMMWORD PTR [rsp-0x80],ymm3
        : "rcx", "r11"
    );
}

pub fn syscall4(number: usize, arg1: usize, arg2: usize, arg3: usize, arg4: usize) usize {
    return asm volatile ("syscall"
  208e19:	4c 8d 0d 60 74 ff ff 	lea    r9,[rip+0xffffffffffff7460]        # 200280 <app_mask>
  208e20:	4c 8d 44 24 80       	lea    r8,[rsp-0x80]
  208e25:	b8 0e 00 00 00       	mov    eax,0xe
  208e2a:	bf 00 00 00 00       	mov    edi,0x0
  208e2f:	41 ba 08 00 00 00    	mov    r10d,0x8
  208e35:	4c 89 ce             	mov    rsi,r9
  208e38:	4c 89 c2             	mov    rdx,r8
  208e3b:	0f 05                	syscall 
    return asm volatile ("syscall"
  208e3d:	b8 ba 00 00 00       	mov    eax,0xba
  208e42:	0f 05                	syscall 
    blockAppSignals(&set);
    const tid = @intCast(i32, syscall0(SYS_gettid));
    const ret = syscall2(SYS_tkill, @intCast(usize, tid), @intCast(usize, sig));
  208e44:	48 63 f8             	movsxd rdi,eax
    return asm volatile ("syscall"
  208e47:	b8 c8 00 00 00       	mov    eax,0xc8
  208e4c:	be 06 00 00 00       	mov    esi,0x6
  208e51:	0f 05                	syscall 
    return asm volatile ("syscall"
  208e53:	b8 0e 00 00 00       	mov    eax,0xe
  208e58:	bf 02 00 00 00       	mov    edi,0x2
  208e5d:	ba 00 00 00 00       	mov    edx,0x0
  208e62:	41 ba 08 00 00 00    	mov    r10d,0x8
  208e68:	4c 89 c6             	mov    rsi,r8
  208e6b:	0f 05                	syscall 
    var set: sigset_t = undefined;
  208e6d:	c5 fc 11 44 24 e0    	vmovups YMMWORD PTR [rsp-0x20],ymm0
  208e73:	c5 fc 11 4c 24 c0    	vmovups YMMWORD PTR [rsp-0x40],ymm1
  208e79:	c5 fc 11 54 24 a0    	vmovups YMMWORD PTR [rsp-0x60],ymm2
  208e7f:	c5 fc 11 5c 24 80    	vmovups YMMWORD PTR [rsp-0x80],ymm3
  208e85:	b8 0e 00 00 00       	mov    eax,0xe
  208e8a:	bf 00 00 00 00       	mov    edi,0x0
  208e8f:	41 ba 08 00 00 00    	mov    r10d,0x8
  208e95:	4c 89 ce             	mov    rsi,r9
  208e98:	4c 89 c2             	mov    rdx,r8
  208e9b:	0f 05                	syscall 
    return asm volatile ("syscall"
  208e9d:	b8 ba 00 00 00       	mov    eax,0xba
  208ea2:	0f 05                	syscall 
    const ret = syscall2(SYS_tkill, @intCast(usize, tid), @intCast(usize, sig));
  208ea4:	48 63 f8             	movsxd rdi,eax
    return asm volatile ("syscall"
  208ea7:	b8 c8 00 00 00       	mov    eax,0xc8
  208eac:	be 09 00 00 00       	mov    esi,0x9
  208eb1:	0f 05                	syscall 
    return asm volatile ("syscall"
  208eb3:	b8 0e 00 00 00       	mov    eax,0xe
  208eb8:	bf 02 00 00 00       	mov    edi,0x2
  208ebd:	31 d2                	xor    edx,edx
  208ebf:	41 ba 08 00 00 00    	mov    r10d,0x8
  208ec5:	4c 89 c6             	mov    rsi,r8
  208ec8:	0f 05                	syscall 
  208eca:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
    }
    switch (builtin.os) {
        Os.linux, Os.macosx, Os.ios => {
            _ = posix.raise(posix.SIGABRT);
            _ = posix.raise(posix.SIGKILL);
            while (true) {}
  208ed0:	eb fe                	jmp    208ed0 <abort+0xf0>
  208ed2:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  208ed9:	1f 84 00 00 00 00 00 

0000000000208ee0 <dumpCurrentStackTrace>:
pub fn dumpCurrentStackTrace(start_addr: ?usize) void {
  208ee0:	55                   	push   rbp
  208ee1:	48 89 e5             	mov    rbp,rsp
  208ee4:	41 57                	push   r15
  208ee6:	41 56                	push   r14
  208ee8:	41 55                	push   r13
  208eea:	41 54                	push   r12
  208eec:	53                   	push   rbx
  208eed:	48 83 e4 e0          	and    rsp,0xffffffffffffffe0
  208ef1:	48 81 ec a0 01 00 00 	sub    rsp,0x1a0
  208ef8:	49 89 fe             	mov    r14,rdi
    if (stderr_stream) |st| {
  208efb:	48 8b 1d 06 81 01 00 	mov    rbx,QWORD PTR [rip+0x18106]        # 221008 <stderr_stream>
  208f02:	48 85 db             	test   rbx,rbx
  208f05:	74 39                	je     208f40 <dumpCurrentStackTrace+0x60>
    if (self_debug_info) |info| {
  208f07:	48 8b 05 0a 81 01 00 	mov    rax,QWORD PTR [rip+0x1810a]        # 221018 <self_debug_info>
  208f0e:	48 89 44 24 68       	mov    QWORD PTR [rsp+0x68],rax
  208f13:	48 85 c0             	test   rax,rax
  208f16:	74 6d                	je     208f85 <dumpCurrentStackTrace+0xa5>
// TODO make thread safe
var debug_info_allocator: ?*mem.Allocator = null;
var debug_info_direct_allocator: std.heap.DirectAllocator = undefined;
var debug_info_arena_allocator: std.heap.ArenaAllocator = undefined;
fn getDebugInfoAllocator() *mem.Allocator {
    if (debug_info_allocator) |a| return a;
  208f18:	48 83 3d 00 81 01 00 	cmp    QWORD PTR [rip+0x18100],0x0        # 221020 <debug_info_allocator>
  208f1f:	00 
  208f20:	0f 84 4e 01 00 00    	je     209074 <dumpCurrentStackTrace+0x194>
    }
}

/// TODO make this go through libc when we have it
pub fn getEnvPosix(key: []const u8) ?[]const u8 {
    for (posix_environ_raw) |ptr| {
  208f26:	48 8b 05 5b 41 01 00 	mov    rax,QWORD PTR [rip+0x1415b]        # 21d088 <posix_environ_raw+0x8>
  208f2d:	48 85 c0             	test   rax,rax
  208f30:	48 89 5c 24 70       	mov    QWORD PTR [rsp+0x70],rbx
  208f35:	0f 85 a4 01 00 00    	jne    2090df <dumpCurrentStackTrace+0x1ff>
  208f3b:	e9 5d 02 00 00       	jmp    20919d <dumpCurrentStackTrace+0x2bd>
        stderr_file = try io.getStdErr();
  208f40:	48 8d 05 b9 40 01 00 	lea    rax,[rip+0x140b9]        # 21d000 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  208f47:	48 89 05 ba 40 01 00 	mov    QWORD PTR [rip+0x140ba],rax        # 21d008 <stderr_file_out_stream>
  208f4e:	48 8d 05 ab 18 00 00 	lea    rax,[rip+0x18ab]        # 20a800 <FileOutStream_writeFn>
  208f55:	48 89 05 b4 40 01 00 	mov    QWORD PTR [rip+0x140b4],rax        # 21d010 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  208f5c:	c7 05 9a 40 01 00 02 	mov    DWORD PTR [rip+0x1409a],0x2        # 21d000 <stderr_file>
  208f63:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  208f66:	48 8d 1d a3 40 01 00 	lea    rbx,[rip+0x140a3]        # 21d010 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  208f6d:	48 89 1d 94 80 01 00 	mov    QWORD PTR [rip+0x18094],rbx        # 221008 <stderr_stream>
    if (self_debug_info) |info| {
  208f74:	48 8b 05 9d 80 01 00 	mov    rax,QWORD PTR [rip+0x1809d]        # 221018 <self_debug_info>
  208f7b:	48 89 44 24 68       	mov    QWORD PTR [rsp+0x68],rax
  208f80:	48 85 c0             	test   rax,rax
  208f83:	75 93                	jne    208f18 <dumpCurrentStackTrace+0x38>
    if (debug_info_allocator) |a| return a;
  208f85:	48 8b 35 94 80 01 00 	mov    rsi,QWORD PTR [rip+0x18094]        # 221020 <debug_info_allocator>
  208f8c:	48 85 f6             	test   rsi,rsi
  208f8f:	75 56                	jne    208fe7 <dumpCurrentStackTrace+0x107>

    debug_info_direct_allocator = std.heap.DirectAllocator.init();
  208f91:	c5 fc 10 05 ef 7d 01 	vmovups ymm0,YMMWORD PTR [rip+0x17def]        # 220d88 <__unnamed_11>
  208f98:	00 
  208f99:	c5 fc 11 05 7f 40 01 	vmovups YMMWORD PTR [rip+0x1407f],ymm0        # 21d020 <debug_info_direct_allocator>
  208fa0:	00 
    debug_info_arena_allocator = std.heap.ArenaAllocator.init(&debug_info_direct_allocator.allocator);
  208fa1:	c5 fa 6f 05 ff 7d 01 	vmovdqu xmm0,XMMWORD PTR [rip+0x17dff]        # 220da8 <__unnamed_12>
  208fa8:	00 
  208fa9:	c5 fa 7f 05 8f 40 01 	vmovdqu XMMWORD PTR [rip+0x1408f],xmm0        # 21d040 <debug_info_arena_allocator>
  208fb0:	00 
    debug_info_direct_allocator = std.heap.DirectAllocator.init();
  208fb1:	48 8d 05 68 40 01 00 	lea    rax,[rip+0x14068]        # 21d020 <debug_info_direct_allocator>
    debug_info_arena_allocator = std.heap.ArenaAllocator.init(&debug_info_direct_allocator.allocator);
  208fb8:	48 8b 0d f9 7d 01 00 	mov    rcx,QWORD PTR [rip+0x17df9]        # 220db8 <__unnamed_12+0x10>
  208fbf:	48 89 0d 8a 40 01 00 	mov    QWORD PTR [rip+0x1408a],rcx        # 21d050 <debug_info_arena_allocator+0x10>
  208fc6:	48 8d 35 73 40 01 00 	lea    rsi,[rip+0x14073]        # 21d040 <debug_info_arena_allocator>
  208fcd:	48 89 05 84 40 01 00 	mov    QWORD PTR [rip+0x14084],rax        # 21d058 <debug_info_arena_allocator+0x18>
  208fd4:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  208fd8:	c5 fe 7f 05 80 40 01 	vmovdqu YMMWORD PTR [rip+0x14080],ymm0        # 21d060 <debug_info_arena_allocator+0x20>
  208fdf:	00 
    debug_info_allocator = &debug_info_arena_allocator.allocator;
  208fe0:	48 89 35 39 80 01 00 	mov    QWORD PTR [rip+0x18039],rsi        # 221020 <debug_info_allocator>
  208fe7:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
        const info = try openSelfDebugInfo(getDebugInfoAllocator());
  208fec:	c5 f8 77             	vzeroupper 
  208fef:	e8 fc 18 00 00       	call   20a8f0 <openSelfDebugInfo>
  208ff4:	4c 0f bf 7c 24 20    	movsx  r15,WORD PTR [rsp+0x20]
  208ffa:	4d 85 ff             	test   r15,r15
  208ffd:	74 56                	je     209055 <dumpCurrentStackTrace+0x175>
  208fff:	4c 8b 33             	mov    r14,QWORD PTR [rbx]
                        try output(context, fmt[start_index..i]);
  209002:	48 8d 35 bf 7b 01 00 	lea    rsi,[rip+0x17bbf]        # 220bc8 <__unnamed_13>
  209009:	48 89 df             	mov    rdi,rbx
  20900c:	41 ff d6             	call   r14
  20900f:	66 85 c0             	test   ax,ax
  209012:	0f 85 dd 14 00 00    	jne    20a4f5 <dumpCurrentStackTrace+0x1615>
        stderr.print("Unable to dump stack trace: Unable to open debug info: {}\n", @errorName(err)) catch return;
  209018:	49 c1 e7 04          	shl    r15,0x4
  20901c:	48 8d 05 dd 4f 01 00 	lea    rax,[rip+0x14fdd]        # 21e000 <raw+0xf68>
                const casted_value = ([]const u8)(value);
  209023:	c4 c1 7a 6f 04 07    	vmovdqu xmm0,XMMWORD PTR [r15+rax*1]
  209029:	c5 f9 7f 44 24 20    	vmovdqa XMMWORD PTR [rsp+0x20],xmm0
  20902f:	48 8d 74 24 20       	lea    rsi,[rsp+0x20]
                return output(context, casted_value);
  209034:	48 89 df             	mov    rdi,rbx
  209037:	41 ff d6             	call   r14
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  20903a:	66 85 c0             	test   ax,ax
  20903d:	0f 85 b2 14 00 00    	jne    20a4f5 <dumpCurrentStackTrace+0x1615>
        try output(context, fmt[start_index..]);
  209043:	48 8d 35 8e 7b 01 00 	lea    rsi,[rip+0x17b8e]        # 220bd8 <__unnamed_14>
  20904a:	48 89 df             	mov    rdi,rbx
  20904d:	41 ff d6             	call   r14
  209050:	e9 a0 14 00 00       	jmp    20a4f5 <dumpCurrentStackTrace+0x1615>
        const info = try openSelfDebugInfo(getDebugInfoAllocator());
  209055:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
  20905a:	48 89 44 24 68       	mov    QWORD PTR [rsp+0x68],rax
        self_debug_info = info;
  20905f:	48 89 05 b2 7f 01 00 	mov    QWORD PTR [rip+0x17fb2],rax        # 221018 <self_debug_info>
    if (debug_info_allocator) |a| return a;
  209066:	48 83 3d b2 7f 01 00 	cmp    QWORD PTR [rip+0x17fb2],0x0        # 221020 <debug_info_allocator>
  20906d:	00 
  20906e:	0f 85 b2 fe ff ff    	jne    208f26 <dumpCurrentStackTrace+0x46>
    debug_info_direct_allocator = std.heap.DirectAllocator.init();
  209074:	c5 fc 10 05 0c 7d 01 	vmovups ymm0,YMMWORD PTR [rip+0x17d0c]        # 220d88 <__unnamed_11>
  20907b:	00 
  20907c:	c5 fc 11 05 9c 3f 01 	vmovups YMMWORD PTR [rip+0x13f9c],ymm0        # 21d020 <debug_info_direct_allocator>
  209083:	00 
    debug_info_arena_allocator = std.heap.ArenaAllocator.init(&debug_info_direct_allocator.allocator);
  209084:	c5 fa 6f 05 1c 7d 01 	vmovdqu xmm0,XMMWORD PTR [rip+0x17d1c]        # 220da8 <__unnamed_12>
  20908b:	00 
  20908c:	c5 fa 7f 05 ac 3f 01 	vmovdqu XMMWORD PTR [rip+0x13fac],xmm0        # 21d040 <debug_info_arena_allocator>
  209093:	00 
    debug_info_direct_allocator = std.heap.DirectAllocator.init();
  209094:	48 8d 05 85 3f 01 00 	lea    rax,[rip+0x13f85]        # 21d020 <debug_info_direct_allocator>
    debug_info_arena_allocator = std.heap.ArenaAllocator.init(&debug_info_direct_allocator.allocator);
  20909b:	48 8b 0d 16 7d 01 00 	mov    rcx,QWORD PTR [rip+0x17d16]        # 220db8 <__unnamed_12+0x10>
  2090a2:	48 89 0d a7 3f 01 00 	mov    QWORD PTR [rip+0x13fa7],rcx        # 21d050 <debug_info_arena_allocator+0x10>
  2090a9:	48 8d 0d 90 3f 01 00 	lea    rcx,[rip+0x13f90]        # 21d040 <debug_info_arena_allocator>
  2090b0:	48 89 05 a1 3f 01 00 	mov    QWORD PTR [rip+0x13fa1],rax        # 21d058 <debug_info_arena_allocator+0x18>
  2090b7:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  2090bb:	c5 fe 7f 05 9d 3f 01 	vmovdqu YMMWORD PTR [rip+0x13f9d],ymm0        # 21d060 <debug_info_arena_allocator+0x20>
  2090c2:	00 
    debug_info_allocator = &debug_info_arena_allocator.allocator;
  2090c3:	48 89 0d 56 7f 01 00 	mov    QWORD PTR [rip+0x17f56],rcx        # 221020 <debug_info_allocator>
  2090ca:	48 8b 05 b7 3f 01 00 	mov    rax,QWORD PTR [rip+0x13fb7]        # 21d088 <posix_environ_raw+0x8>
  2090d1:	48 85 c0             	test   rax,rax
  2090d4:	48 89 5c 24 70       	mov    QWORD PTR [rsp+0x70],rbx
  2090d9:	0f 84 be 00 00 00    	je     20919d <dumpCurrentStackTrace+0x2bd>
  2090df:	48 8b 0d 9a 3f 01 00 	mov    rcx,QWORD PTR [rip+0x13f9a]        # 21d080 <posix_environ_raw>
  2090e6:	31 d2                	xor    edx,edx
  2090e8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  2090ef:	00 
  2090f0:	48 8b 34 d1          	mov    rsi,QWORD PTR [rcx+rdx*8]
  2090f4:	48 c7 c7 f1 ff ff ff 	mov    rdi,0xfffffffffffffff1
        var line_i: usize = 0;
        while (ptr[line_i] != 0 and ptr[line_i] != '=') : (line_i += 1) {}
  2090fb:	8a 5c 3e 0f          	mov    bl,BYTE PTR [rsi+rdi*1+0xf]
  2090ff:	84 db                	test   bl,bl
  209101:	74 1f                	je     209122 <dumpCurrentStackTrace+0x242>
  209103:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20910a:	84 00 00 00 00 00 
  209110:	80 fb 3d             	cmp    bl,0x3d
  209113:	74 0d                	je     209122 <dumpCurrentStackTrace+0x242>
  209115:	48 83 c7 01          	add    rdi,0x1
  209119:	0f b6 5c 3e 0f       	movzx  ebx,BYTE PTR [rsi+rdi*1+0xf]
  20911e:	84 db                	test   bl,bl
  209120:	75 ee                	jne    209110 <dumpCurrentStackTrace+0x230>
    if (a.len != b.len) return false;
  209122:	48 85 ff             	test   rdi,rdi
  209125:	75 69                	jne    209190 <dumpCurrentStackTrace+0x2b0>
        if (b[index] != item) return false;
  209127:	80 3e 5a             	cmp    BYTE PTR [rsi],0x5a
  20912a:	75 64                	jne    209190 <dumpCurrentStackTrace+0x2b0>
  20912c:	80 7e 01 49          	cmp    BYTE PTR [rsi+0x1],0x49
  209130:	75 5e                	jne    209190 <dumpCurrentStackTrace+0x2b0>
  209132:	80 7e 02 47          	cmp    BYTE PTR [rsi+0x2],0x47
  209136:	75 58                	jne    209190 <dumpCurrentStackTrace+0x2b0>
  209138:	80 7e 03 5f          	cmp    BYTE PTR [rsi+0x3],0x5f
  20913c:	75 52                	jne    209190 <dumpCurrentStackTrace+0x2b0>
  20913e:	80 7e 04 44          	cmp    BYTE PTR [rsi+0x4],0x44
  209142:	75 4c                	jne    209190 <dumpCurrentStackTrace+0x2b0>
  209144:	80 7e 05 45          	cmp    BYTE PTR [rsi+0x5],0x45
  209148:	75 46                	jne    209190 <dumpCurrentStackTrace+0x2b0>
  20914a:	80 7e 06 42          	cmp    BYTE PTR [rsi+0x6],0x42
  20914e:	75 40                	jne    209190 <dumpCurrentStackTrace+0x2b0>
  209150:	80 7e 07 55          	cmp    BYTE PTR [rsi+0x7],0x55
  209154:	75 3a                	jne    209190 <dumpCurrentStackTrace+0x2b0>
  209156:	80 7e 08 47          	cmp    BYTE PTR [rsi+0x8],0x47
  20915a:	75 34                	jne    209190 <dumpCurrentStackTrace+0x2b0>
  20915c:	80 7e 09 5f          	cmp    BYTE PTR [rsi+0x9],0x5f
  209160:	75 2e                	jne    209190 <dumpCurrentStackTrace+0x2b0>
  209162:	80 7e 0a 43          	cmp    BYTE PTR [rsi+0xa],0x43
  209166:	75 28                	jne    209190 <dumpCurrentStackTrace+0x2b0>
  209168:	80 7e 0b 4f          	cmp    BYTE PTR [rsi+0xb],0x4f
  20916c:	75 22                	jne    209190 <dumpCurrentStackTrace+0x2b0>
  20916e:	80 7e 0c 4c          	cmp    BYTE PTR [rsi+0xc],0x4c
  209172:	75 1c                	jne    209190 <dumpCurrentStackTrace+0x2b0>
  209174:	80 7e 0d 4f          	cmp    BYTE PTR [rsi+0xd],0x4f
  209178:	75 16                	jne    209190 <dumpCurrentStackTrace+0x2b0>
  20917a:	80 7e 0e 52          	cmp    BYTE PTR [rsi+0xe],0x52
  20917e:	0f 84 28 14 00 00    	je     20a5ac <dumpCurrentStackTrace+0x16cc>
  209184:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20918b:	00 00 00 00 00 
    for (posix_environ_raw) |ptr| {
  209190:	48 83 c2 01          	add    rdx,0x1
  209194:	48 39 c2             	cmp    rdx,rax
  209197:	0f 82 53 ff ff ff    	jb     2090f0 <dumpCurrentStackTrace+0x210>
    return syscall3(SYS_ioctl, @intCast(usize, fd), TIOCGWINSZ, @ptrToInt(&wsz)) == 0;
  20919d:	48 63 3d 5c 3e 01 00 	movsxd rdi,DWORD PTR [rip+0x13e5c]        # 21d000 <stderr_file>
  2091a4:	48 8d 54 24 20       	lea    rdx,[rsp+0x20]
    return asm volatile ("syscall"
  2091a9:	b8 10 00 00 00       	mov    eax,0x10
  2091ae:	be 13 54 00 00       	mov    esi,0x5413
  2091b3:	0f 05                	syscall 
  2091b5:	48 85 c0             	test   rax,rax
  2091b8:	0f 94 44 24 07       	sete   BYTE PTR [rsp+0x7]
    if (start_addr) |addr| {
  2091bd:	41 80 7e 08 01       	cmp    BYTE PTR [r14+0x8],0x1
  2091c2:	48 8b 74 24 68       	mov    rsi,QWORD PTR [rsp+0x68]
  2091c7:	75 0f                	jne    2091d8 <dumpCurrentStackTrace+0x2f8>
  2091c9:	49 8b 0e             	mov    rcx,QWORD PTR [r14]
  2091cc:	b0 01                	mov    al,0x1
    while (fp != 0) : (fp = @intToPtr(*const usize, fp).*) {
  2091ce:	48 85 ed             	test   rbp,rbp
  2091d1:	75 10                	jne    2091e3 <dumpCurrentStackTrace+0x303>
  2091d3:	e9 1d 13 00 00       	jmp    20a4f5 <dumpCurrentStackTrace+0x1615>
  2091d8:	31 c0                	xor    eax,eax
  2091da:	48 85 ed             	test   rbp,rbp
  2091dd:	0f 84 12 13 00 00    	je     20a4f5 <dumpCurrentStackTrace+0x1615>
  2091e3:	48 89 ea             	mov    rdx,rbp
  2091e6:	c4 62 7d 59 25 71 70 	vpbroadcastq ymm12,QWORD PTR [rip+0xffffffffffff7071]        # 200260 <__unnamed_90+0x80>
  2091ed:	ff ff 
  2091ef:	c4 62 7d 59 2d d8 70 	vpbroadcastq ymm13,QWORD PTR [rip+0xffffffffffff70d8]        # 2002d0 <app_mask+0x50>
  2091f6:	ff ff 
  2091f8:	c5 7d 7f a4 24 00 01 	vmovdqa YMMWORD PTR [rsp+0x100],ymm12
  2091ff:	00 00 
  209201:	c5 7d 7f ac 24 e0 00 	vmovdqa YMMWORD PTR [rsp+0xe0],ymm13
  209208:	00 00 
  20920a:	48 89 8c 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],rcx
  209211:	00 
  209212:	48 89 74 24 68       	mov    QWORD PTR [rsp+0x68],rsi
  209217:	e9 44 12 00 00       	jmp    20a460 <dumpCurrentStackTrace+0x1580>
  20921c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  209220:	48 89 94 24 b0 00 00 	mov    QWORD PTR [rsp+0xb0],rdx
  209227:	00 
    var in_file_stream = io.FileInStream.init(&st.self_exe_file);
  209228:	48 89 b4 24 c8 00 00 	mov    QWORD PTR [rsp+0xc8],rsi
  20922f:	00 
  209230:	48 8d 05 b9 68 00 00 	lea    rax,[rip+0x68b9]        # 20faf0 <FileInStream_readFn>
  209237:	48 89 84 24 d0 00 00 	mov    QWORD PTR [rsp+0xd0],rax
  20923e:	00 
        pub fn deinit(self: Self) void {
            self.allocator.free(self.items);
        }

        pub fn toSlice(self: Self) []align(A) T {
            return self.items[0..self.len];
  20923f:	48 8b 86 b8 00 00 00 	mov    rax,QWORD PTR [rsi+0xb8]
  209246:	48 89 44 24 78       	mov    QWORD PTR [rsp+0x78],rax
    for (st.compile_unit_list.toSlice()) |*compile_unit| {
  20924b:	48 85 c0             	test   rax,rax
  20924e:	0f 84 6c 04 00 00    	je     2096c0 <dumpCurrentStackTrace+0x7e0>
  209254:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  209259:	4c 8b 88 a8 00 00 00 	mov    r9,QWORD PTR [rax+0xa8]
  209260:	45 31 e4             	xor    r12d,r12d
  209263:	e9 08 02 00 00       	jmp    209470 <dumpCurrentStackTrace+0x590>
                result = (result << 8) | b;
            }
        },
        builtin.Endian.Little => {
            const ShiftType = math.Log2Int(T);
            for (bytes) |b, index| {
  209268:	48 89 c3             	mov    rbx,rax
  20926b:	48 83 e3 f0          	and    rbx,0xfffffffffffffff0
  20926f:	48 8d 73 f0          	lea    rsi,[rbx-0x10]
  209273:	48 89 f7             	mov    rdi,rsi
  209276:	48 c1 ef 04          	shr    rdi,0x4
  20927a:	44 8d 47 01          	lea    r8d,[rdi+0x1]
  20927e:	41 83 e0 01          	and    r8d,0x1
  209282:	48 85 f6             	test   rsi,rsi
  209285:	0f 84 bd 01 00 00    	je     209448 <dumpCurrentStackTrace+0x568>
  20928b:	49 8d 70 ff          	lea    rsi,[r8-0x1]
  20928f:	48 29 fe             	sub    rsi,rdi
  209292:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  209296:	31 ff                	xor    edi,edi
  209298:	c5 fd 6f 25 00 6f ff 	vmovdqa ymm4,YMMWORD PTR [rip+0xffffffffffff6f00]        # 2001a0 <__unnamed_90-0x40>
  20929f:	ff 
  2092a0:	c5 f1 ef c9          	vpxor  xmm1,xmm1,xmm1
  2092a4:	c5 e1 ef db          	vpxor  xmm3,xmm3,xmm3
  2092a8:	c5 e9 ef d2          	vpxor  xmm2,xmm2,xmm2
  2092ac:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  2092b0:	c4 e2 7d 32 2c 39    	vpmovzxbq ymm5,DWORD PTR [rcx+rdi*1]
  2092b6:	c4 e2 7d 32 74 39 04 	vpmovzxbq ymm6,DWORD PTR [rcx+rdi*1+0x4]
  2092bd:	c4 e2 7d 32 7c 39 08 	vpmovzxbq ymm7,DWORD PTR [rcx+rdi*1+0x8]
  2092c4:	c4 62 7d 32 44 39 0c 	vpmovzxbq ymm8,DWORD PTR [rcx+rdi*1+0xc]
  2092cb:	c5 b5 73 f4 03       	vpsllq ymm9,ymm4,0x3
  2092d0:	c4 41 35 d4 d4       	vpaddq ymm10,ymm9,ymm12
  2092d5:	c4 41 35 db dd       	vpand  ymm11,ymm9,ymm13
  2092da:	c4 41 2d db d5       	vpand  ymm10,ymm10,ymm13
  2092df:	c4 c2 d5 47 eb       	vpsllvq ymm5,ymm5,ymm11
  2092e4:	c5 d5 eb c0          	vpor   ymm0,ymm5,ymm0
  2092e8:	c4 c2 cd 47 ea       	vpsllvq ymm5,ymm6,ymm10
  2092ed:	c5 d5 eb c9          	vpor   ymm1,ymm5,ymm1
  2092f1:	c4 c2 c5 47 eb       	vpsllvq ymm5,ymm7,ymm11
  2092f6:	c5 d5 eb db          	vpor   ymm3,ymm5,ymm3
  2092fa:	c4 c2 bd 47 ea       	vpsllvq ymm5,ymm8,ymm10
  2092ff:	c4 e2 7d 32 74 39 10 	vpmovzxbq ymm6,DWORD PTR [rcx+rdi*1+0x10]
  209306:	c4 e2 7d 32 7c 39 14 	vpmovzxbq ymm7,DWORD PTR [rcx+rdi*1+0x14]
  20930d:	c4 62 7d 32 44 39 18 	vpmovzxbq ymm8,DWORD PTR [rcx+rdi*1+0x18]
  209314:	c5 d5 eb d2          	vpor   ymm2,ymm5,ymm2
  209318:	c4 e2 7d 32 6c 39 1c 	vpmovzxbq ymm5,DWORD PTR [rcx+rdi*1+0x1c]
  20931f:	c4 62 7d 59 15 98 6f 	vpbroadcastq ymm10,QWORD PTR [rip+0xffffffffffff6f98]        # 2002c0 <app_mask+0x40>
  209326:	ff ff 
  209328:	c4 41 35 d4 d2       	vpaddq ymm10,ymm9,ymm10
  20932d:	c4 62 7d 59 1d d2 6e 	vpbroadcastq ymm11,QWORD PTR [rip+0xffffffffffff6ed2]        # 200208 <__unnamed_90+0x28>
  209334:	ff ff 
  209336:	c4 41 35 d4 cb       	vpaddq ymm9,ymm9,ymm11
  20933b:	c4 41 2d db d5       	vpand  ymm10,ymm10,ymm13
  209340:	c4 41 35 db cd       	vpand  ymm9,ymm9,ymm13
  209345:	c4 c2 cd 47 f2       	vpsllvq ymm6,ymm6,ymm10
  20934a:	c5 cd eb c0          	vpor   ymm0,ymm6,ymm0
  20934e:	c4 c2 c5 47 f1       	vpsllvq ymm6,ymm7,ymm9
  209353:	c5 cd eb c9          	vpor   ymm1,ymm6,ymm1
  209357:	c4 c2 bd 47 f2       	vpsllvq ymm6,ymm8,ymm10
  20935c:	c5 cd eb db          	vpor   ymm3,ymm6,ymm3
  209360:	c4 c2 d5 47 e9       	vpsllvq ymm5,ymm5,ymm9
  209365:	c5 d5 eb d2          	vpor   ymm2,ymm5,ymm2
            for (bytes) |b, index| {
  209369:	48 83 c7 20          	add    rdi,0x20
  20936d:	c4 c1 5d d4 e4       	vpaddq ymm4,ymm4,ymm12
  209372:	48 83 c6 02          	add    rsi,0x2
  209376:	0f 85 34 ff ff ff    	jne    2092b0 <dumpCurrentStackTrace+0x3d0>
  20937c:	4d 85 c0             	test   r8,r8
  20937f:	74 53                	je     2093d4 <dumpCurrentStackTrace+0x4f4>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  209381:	c4 e2 7d 32 6c 39 0c 	vpmovzxbq ymm5,DWORD PTR [rcx+rdi*1+0xc]
  209388:	c5 dd 73 f4 03       	vpsllq ymm4,ymm4,0x3
  20938d:	c4 c1 5d d4 f4       	vpaddq ymm6,ymm4,ymm12
  209392:	c4 c1 4d db f5       	vpand  ymm6,ymm6,ymm13
  209397:	c4 e2 d5 47 ee       	vpsllvq ymm5,ymm5,ymm6
  20939c:	c4 e2 7d 32 7c 39 08 	vpmovzxbq ymm7,DWORD PTR [rcx+rdi*1+0x8]
  2093a3:	c5 d5 eb d2          	vpor   ymm2,ymm5,ymm2
  2093a7:	c4 c1 5d db e5       	vpand  ymm4,ymm4,ymm13
  2093ac:	c4 e2 c5 47 ec       	vpsllvq ymm5,ymm7,ymm4
  2093b1:	c5 d5 eb db          	vpor   ymm3,ymm5,ymm3
  2093b5:	c4 e2 7d 32 6c 39 04 	vpmovzxbq ymm5,DWORD PTR [rcx+rdi*1+0x4]
  2093bc:	c4 e2 d5 47 ee       	vpsllvq ymm5,ymm5,ymm6
  2093c1:	c5 d5 eb c9          	vpor   ymm1,ymm5,ymm1
  2093c5:	c4 e2 7d 32 2c 39    	vpmovzxbq ymm5,DWORD PTR [rcx+rdi*1]
  2093cb:	c4 e2 d5 47 e4       	vpsllvq ymm4,ymm5,ymm4
  2093d0:	c5 dd eb c0          	vpor   ymm0,ymm4,ymm0
  2093d4:	c5 f5 eb ca          	vpor   ymm1,ymm1,ymm2
  2093d8:	c5 fd eb c3          	vpor   ymm0,ymm0,ymm3
  2093dc:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  2093e0:	c4 e3 7d 39 c1 01    	vextracti128 xmm1,ymm0,0x1
  2093e6:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  2093ea:	c5 f9 70 c8 4e       	vpshufd xmm1,xmm0,0x4e
  2093ef:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  2093f3:	c4 e1 f9 7e c6       	vmovq  rsi,xmm0
  2093f8:	48 39 d8             	cmp    rax,rbx
            for (bytes) |b, index| {
  2093fb:	74 31                	je     20942e <dumpCurrentStackTrace+0x54e>
  2093fd:	48 29 d8             	sub    rax,rbx
  209400:	48 01 d9             	add    rcx,rbx
  209403:	48 c1 e3 03          	shl    rbx,0x3
  209407:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  20940e:	00 00 
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  209410:	0f b6 39             	movzx  edi,BYTE PTR [rcx]
  209413:	89 da                	mov    edx,ebx
  209415:	80 e2 38             	and    dl,0x38
  209418:	c4 e2 e9 f7 d7       	shlx   rdx,rdi,rdx
  20941d:	48 09 d6             	or     rsi,rdx
            for (bytes) |b, index| {
  209420:	48 83 c3 08          	add    rbx,0x8
  209424:	48 83 c1 01          	add    rcx,0x1
  209428:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  20942c:	75 e2                	jne    209410 <dumpCurrentStackTrace+0x530>
            if (st.debug_ranges) |debug_ranges| {
  20942e:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  209433:	48 8b 80 80 00 00 00 	mov    rax,QWORD PTR [rax+0x80]
  20943a:	48 85 c0             	test   rax,rax
  20943d:	0f 85 fd 00 00 00    	jne    209540 <dumpCurrentStackTrace+0x660>
  209443:	e9 68 02 00 00       	jmp    2096b0 <dumpCurrentStackTrace+0x7d0>
  209448:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  20944c:	31 ff                	xor    edi,edi
  20944e:	c5 fd 6f 25 4a 6d ff 	vmovdqa ymm4,YMMWORD PTR [rip+0xffffffffffff6d4a]        # 2001a0 <__unnamed_90-0x40>
  209455:	ff 
  209456:	c5 f1 ef c9          	vpxor  xmm1,xmm1,xmm1
  20945a:	c5 e1 ef db          	vpxor  xmm3,xmm3,xmm3
  20945e:	c5 e9 ef d2          	vpxor  xmm2,xmm2,xmm2
  209462:	4d 85 c0             	test   r8,r8
  209465:	0f 85 16 ff ff ff    	jne    209381 <dumpCurrentStackTrace+0x4a1>
  20946b:	e9 64 ff ff ff       	jmp    2093d4 <dumpCurrentStackTrace+0x4f4>
        if (compile_unit.pc_range) |range| {
  209470:	4f 8d 34 64          	lea    r14,[r12+r12*2]
  209474:	49 c1 e6 04          	shl    r14,0x4
  209478:	43 80 7c 31 28 01    	cmp    BYTE PTR [r9+r14*1+0x28],0x1
  20947e:	75 12                	jne    209492 <dumpCurrentStackTrace+0x5b2>
            if (target_address >= range.start and target_address < range.end) return compile_unit;
  209480:	4f 39 6c 31 18       	cmp    QWORD PTR [r9+r14*1+0x18],r13
  209485:	77 0b                	ja     209492 <dumpCurrentStackTrace+0x5b2>
  209487:	4f 39 6c 31 20       	cmp    QWORD PTR [r9+r14*1+0x20],r13
  20948c:	0f 87 4c 04 00 00    	ja     2098de <dumpCurrentStackTrace+0x9fe>
        if (compile_unit.die.getAttrSecOffset(DW.AT_ranges)) |ranges_offset| {
  209492:	4b 8b 4c 31 08       	mov    rcx,QWORD PTR [r9+r14*1+0x8]
  209497:	48 8b 41 20          	mov    rax,QWORD PTR [rcx+0x20]
        for (self.attrs.toSliceConst()) |*attr| {
  20949b:	48 85 c0             	test   rax,rax
  20949e:	0f 84 0c 02 00 00    	je     2096b0 <dumpCurrentStackTrace+0x7d0>
  2094a4:	4b 8d 14 31          	lea    rdx,[r9+r14*1]
  2094a8:	48 83 c2 08          	add    rdx,0x8
  2094ac:	48 89 94 24 38 01 00 	mov    QWORD PTR [rsp+0x138],rdx
  2094b3:	00 
  2094b4:	48 8b 49 10          	mov    rcx,QWORD PTR [rcx+0x10]
            if (attr.id == id) return &attr.value;
  2094b8:	48 83 c1 20          	add    rcx,0x20
  2094bc:	31 d2                	xor    edx,edx
  2094be:	66 90                	xchg   ax,ax
  2094c0:	48 83 79 e0 55       	cmp    QWORD PTR [rcx-0x20],0x55
  2094c5:	74 19                	je     2094e0 <dumpCurrentStackTrace+0x600>
        for (self.attrs.toSliceConst()) |*attr| {
  2094c7:	48 83 c2 01          	add    rdx,0x1
  2094cb:	48 83 c1 28          	add    rcx,0x28
  2094cf:	48 39 c2             	cmp    rdx,rax
  2094d2:	72 ec                	jb     2094c0 <dumpCurrentStackTrace+0x5e0>
  2094d4:	e9 d7 01 00 00       	jmp    2096b0 <dumpCurrentStackTrace+0x7d0>
  2094d9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  2094e0:	8a 01                	mov    al,BYTE PTR [rcx]
  2094e2:	3c 05                	cmp    al,0x5
        return switch (form_value.*) {
  2094e4:	74 41                	je     209527 <dumpCurrentStackTrace+0x647>
  2094e6:	3c 02                	cmp    al,0x2
  2094e8:	0f 85 d2 01 00 00    	jne    2096c0 <dumpCurrentStackTrace+0x7e0>
            FormValue.Const => |value| value.asUnsignedLe(),
  2094ee:	48 8b 41 f0          	mov    rax,QWORD PTR [rcx-0x10]
        if (self.payload.len > @sizeOf(u64)) return error.InvalidDebugInfo;
  2094f2:	48 83 f8 08          	cmp    rax,0x8
  2094f6:	0f 87 c4 01 00 00    	ja     2096c0 <dumpCurrentStackTrace+0x7e0>
            FormValue.Const => |value| value.asUnsignedLe(),
  2094fc:	8a 51 f8             	mov    dl,BYTE PTR [rcx-0x8]
        if (self.signed) return error.InvalidDebugInfo;
  2094ff:	84 d2                	test   dl,dl
  209501:	0f 85 b9 01 00 00    	jne    2096c0 <dumpCurrentStackTrace+0x7e0>
  209507:	48 85 c0             	test   rax,rax
  20950a:	0f 84 7c 01 00 00    	je     20968c <dumpCurrentStackTrace+0x7ac>
  209510:	48 8b 49 e8          	mov    rcx,QWORD PTR [rcx-0x18]
  209514:	48 83 f8 10          	cmp    rax,0x10
  209518:	0f 83 4a fd ff ff    	jae    209268 <dumpCurrentStackTrace+0x388>
  20951e:	31 db                	xor    ebx,ebx
  209520:	31 f6                	xor    esi,esi
  209522:	e9 d6 fe ff ff       	jmp    2093fd <dumpCurrentStackTrace+0x51d>
            FormValue.SecOffset => |value| value,
  209527:	48 8b 71 e8          	mov    rsi,QWORD PTR [rcx-0x18]
            if (st.debug_ranges) |debug_ranges| {
  20952b:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  209530:	48 8b 80 80 00 00 00 	mov    rax,QWORD PTR [rax+0x80]
  209537:	48 85 c0             	test   rax,rax
  20953a:	0f 84 70 01 00 00    	je     2096b0 <dumpCurrentStackTrace+0x7d0>
/// Cast an integer to a different integer type. If the value doesn't fit,
/// return an error.
pub fn cast(comptime T: type, x: var) (error{Overflow}!T) {
    comptime assert(@typeId(T) == builtin.TypeId.Int); // must pass an integer
    comptime assert(@typeId(@typeOf(x)) == builtin.TypeId.Int); // must pass an integer
    if (@maxValue(@typeOf(x)) > @maxValue(T) and x > @maxValue(T)) {
  209540:	48 03 70 18          	add    rsi,QWORD PTR [rax+0x18]
  209544:	0f 88 76 01 00 00    	js     2096c0 <dumpCurrentStackTrace+0x7e0>
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  20954a:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  20954f:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  209552:	b8 08 00 00 00       	mov    eax,0x8
  209557:	31 d2                	xor    edx,edx
  209559:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  20955b:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
        switch (builtin.os) {
            Os.linux, Os.macosx, Os.ios => {
                const ipos = try math.cast(isize, pos);
                const result = posix.lseek(self.handle, ipos, posix.SEEK_SET);
                const err = posix.getErrno(result);
                if (err > 0) {
  209561:	0f 83 59 01 00 00    	jae    2096c0 <dumpCurrentStackTrace+0x7e0>
  209567:	4c 89 cb             	mov    rbx,r9
            try self.readNoEof(bytes[0..]);
  20956a:	48 8d 84 24 b8 00 00 	lea    rax,[rsp+0xb8]
  209571:	00 
  209572:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  209577:	48 c7 44 24 10 08 00 	mov    QWORD PTR [rsp+0x10],0x8
  20957e:	00 00 
            return self.readFn(self, buffer);
  209580:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  209585:	48 8d b4 24 d0 00 00 	lea    rsi,[rsp+0xd0]
  20958c:	00 
  20958d:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
  209592:	c5 f8 77             	vzeroupper 
  209595:	ff 94 24 d0 00 00 00 	call   QWORD PTR [rsp+0xd0]
            const amt_read = try self.read(buf);
  20959c:	66 83 7c 24 20 00    	cmp    WORD PTR [rsp+0x20],0x0
  2095a2:	0f 85 18 01 00 00    	jne    2096c0 <dumpCurrentStackTrace+0x7e0>
  2095a8:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
  2095ad:	0f 1f 00             	nop    DWORD PTR [rax]
            if (amt_read < buf.len) return error.EndOfStream;
  2095b0:	48 3b 44 24 10       	cmp    rax,QWORD PTR [rsp+0x10]
  2095b5:	0f 82 05 01 00 00    	jb     2096c0 <dumpCurrentStackTrace+0x7e0>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  2095bb:	4c 8b bc 24 b8 00 00 	mov    r15,QWORD PTR [rsp+0xb8]
  2095c2:	00 
            try self.readNoEof(bytes[0..]);
  2095c3:	48 8d 84 24 b8 00 00 	lea    rax,[rsp+0xb8]
  2095ca:	00 
  2095cb:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  2095d0:	48 c7 44 24 10 08 00 	mov    QWORD PTR [rsp+0x10],0x8
  2095d7:	00 00 
            return self.readFn(self, buffer);
  2095d9:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  2095de:	48 8d b4 24 d0 00 00 	lea    rsi,[rsp+0xd0]
  2095e5:	00 
  2095e6:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
  2095eb:	ff 94 24 d0 00 00 00 	call   QWORD PTR [rsp+0xd0]
            const amt_read = try self.read(buf);
  2095f2:	66 83 7c 24 20 00    	cmp    WORD PTR [rsp+0x20],0x0
  2095f8:	0f 85 c2 00 00 00    	jne    2096c0 <dumpCurrentStackTrace+0x7e0>
  2095fe:	48 8b 44 24 10       	mov    rax,QWORD PTR [rsp+0x10]
  209603:	48 39 44 24 28       	cmp    QWORD PTR [rsp+0x28],rax
  209608:	0f 82 b2 00 00 00    	jb     2096c0 <dumpCurrentStackTrace+0x7e0>
  20960e:	48 8b 84 24 b8 00 00 	mov    rax,QWORD PTR [rsp+0xb8]
  209615:	00 
                    if (begin_addr == 0 and end_addr == 0) {
  209616:	48 89 c1             	mov    rcx,rax
  209619:	4c 09 f9             	or     rcx,r15
  20961c:	c5 7d 6f a4 24 00 01 	vmovdqa ymm12,YMMWORD PTR [rsp+0x100]
  209623:	00 00 
  209625:	c5 7d 6f ac 24 e0 00 	vmovdqa ymm13,YMMWORD PTR [rsp+0xe0]
  20962c:	00 00 
  20962e:	49 89 d9             	mov    r9,rbx
  209631:	74 7d                	je     2096b0 <dumpCurrentStackTrace+0x7d0>
                    if (begin_addr == @maxValue(usize)) {
  209633:	49 83 ff ff          	cmp    r15,0xffffffffffffffff
  209637:	74 0e                	je     209647 <dumpCurrentStackTrace+0x767>
                    if (target_address >= begin_addr and target_address < end_addr) {
  209639:	4d 39 ef             	cmp    r15,r13
  20963c:	77 09                	ja     209647 <dumpCurrentStackTrace+0x767>
  20963e:	4c 39 e8             	cmp    rax,r13
  209641:	0f 87 8d 02 00 00    	ja     2098d4 <dumpCurrentStackTrace+0x9f4>
            try self.readNoEof(bytes[0..]);
  209647:	48 8d 84 24 b8 00 00 	lea    rax,[rsp+0xb8]
  20964e:	00 
  20964f:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  209654:	48 c7 44 24 10 08 00 	mov    QWORD PTR [rsp+0x10],0x8
  20965b:	00 00 
            return self.readFn(self, buffer);
  20965d:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  209662:	48 8d b4 24 d0 00 00 	lea    rsi,[rsp+0xd0]
  209669:	00 
  20966a:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
  20966f:	c5 f8 77             	vzeroupper 
  209672:	ff 94 24 d0 00 00 00 	call   QWORD PTR [rsp+0xd0]
  209679:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  20967e:	66 83 7c 24 20 00    	cmp    WORD PTR [rsp+0x20],0x0
  209684:	0f 84 26 ff ff ff    	je     2095b0 <dumpCurrentStackTrace+0x6d0>
  20968a:	eb 34                	jmp    2096c0 <dumpCurrentStackTrace+0x7e0>
        return switch (form_value.*) {
  20968c:	31 f6                	xor    esi,esi
            if (st.debug_ranges) |debug_ranges| {
  20968e:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  209693:	48 8b 80 80 00 00 00 	mov    rax,QWORD PTR [rax+0x80]
  20969a:	48 85 c0             	test   rax,rax
  20969d:	0f 85 9d fe ff ff    	jne    209540 <dumpCurrentStackTrace+0x660>
  2096a3:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  2096aa:	84 00 00 00 00 00 
    for (st.compile_unit_list.toSlice()) |*compile_unit| {
  2096b0:	49 83 c4 01          	add    r12,0x1
  2096b4:	4c 3b 64 24 78       	cmp    r12,QWORD PTR [rsp+0x78]
  2096b9:	0f 82 b1 fd ff ff    	jb     209470 <dumpCurrentStackTrace+0x590>
  2096bf:	90                   	nop
  2096c0:	4c 8b 64 24 70       	mov    r12,QWORD PTR [rsp+0x70]
            return std.fmt.format(self, Error, self.writeFn, format, args);
  2096c5:	4d 8b 34 24          	mov    r14,QWORD PTR [r12]
                if (tty_color) {
  2096c9:	80 7c 24 07 00       	cmp    BYTE PTR [rsp+0x7],0x0
  2096ce:	74 70                	je     209740 <dumpCurrentStackTrace+0x860>
                        try output(context, fmt[start_index..i]);
  2096d0:	4c 89 e7             	mov    rdi,r12
  2096d3:	48 8d 35 2e 75 01 00 	lea    rsi,[rip+0x1752e]        # 220c08 <__unnamed_15>
  2096da:	c5 f8 77             	vzeroupper 
  2096dd:	41 ff d6             	call   r14
  2096e0:	41 89 c7             	mov    r15d,eax
  2096e3:	66 45 85 ff          	test   r15w,r15w
  2096e7:	0f 85 a3 01 00 00    	jne    209890 <dumpCurrentStackTrace+0x9b0>
    var buf: [max_int_digits - 1]u8 = undefined;
  2096ed:	c5 fc 10 05 3a d3 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffffd33a]        # 206a2f <__unnamed_3+0x1f>
  2096f4:	ff 
  2096f5:	c5 fc 11 44 24 3f    	vmovups YMMWORD PTR [rsp+0x3f],ymm0
  2096fb:	c5 fe 6f 05 0d d3 ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffffd30d]        # 206a10 <__unnamed_3>
  209702:	ff 
  209703:	c5 fe 7f 44 24 20    	vmovdqu YMMWORD PTR [rsp+0x20],ymm0
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  209709:	44 89 e8             	mov    eax,r13d
  20970c:	24 0f                	and    al,0xf
    return value;
}

fn digitToChar(digit: u8, uppercase: bool) u8 {
    return switch (digit) {
        0...9 => digit + '0',
  20970e:	b1 30                	mov    cl,0x30
  209710:	3c 0a                	cmp    al,0xa
  209712:	72 02                	jb     209716 <dumpCurrentStackTrace+0x836>
  209714:	b1 57                	mov    cl,0x57
  209716:	00 c1                	add    cl,al
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  209718:	88 4c 24 5f          	mov    BYTE PTR [rsp+0x5f],cl
  20971c:	b8 40 00 00 00       	mov    eax,0x40
        if (a == 0) break;
  209721:	49 83 fd 10          	cmp    r13,0x10
  209725:	73 7e                	jae    2097a5 <dumpCurrentStackTrace+0x8c5>
  209727:	48 8d 4c 24 5f       	lea    rcx,[rsp+0x5f]
  20972c:	e9 af 00 00 00       	jmp    2097e0 <dumpCurrentStackTrace+0x900>
  209731:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  209738:	0f 1f 84 00 00 00 00 
  20973f:	00 
                        try output(context, fmt[start_index..i]);
  209740:	4c 89 e7             	mov    rdi,r12
  209743:	48 8d 35 de 74 01 00 	lea    rsi,[rip+0x174de]        # 220c28 <__unnamed_16>
  20974a:	c5 f8 77             	vzeroupper 
  20974d:	41 ff d6             	call   r14
  209750:	41 89 c7             	mov    r15d,eax
  209753:	66 45 85 ff          	test   r15w,r15w
  209757:	0f 85 33 01 00 00    	jne    209890 <dumpCurrentStackTrace+0x9b0>
    var buf: [max_int_digits - 1]u8 = undefined;
  20975d:	c5 fc 10 05 ca d2 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffffd2ca]        # 206a2f <__unnamed_3+0x1f>
  209764:	ff 
  209765:	c5 fc 11 44 24 3f    	vmovups YMMWORD PTR [rsp+0x3f],ymm0
  20976b:	c5 fe 6f 05 9d d2 ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffffd29d]        # 206a10 <__unnamed_3>
  209772:	ff 
  209773:	c5 fe 7f 44 24 20    	vmovdqu YMMWORD PTR [rsp+0x20],ymm0
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  209779:	44 89 e8             	mov    eax,r13d
  20977c:	24 0f                	and    al,0xf
        0...9 => digit + '0',
  20977e:	b1 30                	mov    cl,0x30
  209780:	3c 0a                	cmp    al,0xa
  209782:	72 02                	jb     209786 <dumpCurrentStackTrace+0x8a6>
  209784:	b1 57                	mov    cl,0x57
  209786:	00 c1                	add    cl,al
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  209788:	88 4c 24 5f          	mov    BYTE PTR [rsp+0x5f],cl
  20978c:	b8 40 00 00 00       	mov    eax,0x40
        if (a == 0) break;
  209791:	49 83 fd 10          	cmp    r13,0x10
  209795:	0f 83 7e 00 00 00    	jae    209819 <dumpCurrentStackTrace+0x939>
  20979b:	48 8d 4c 24 5f       	lea    rcx,[rsp+0x5f]
  2097a0:	e9 ab 00 00 00       	jmp    209850 <dumpCurrentStackTrace+0x970>
        a /= base;
  2097a5:	4c 89 e9             	mov    rcx,r13
  2097a8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  2097af:	00 
  2097b0:	48 c1 e9 04          	shr    rcx,0x4
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  2097b4:	89 ca                	mov    edx,ecx
  2097b6:	80 e2 0f             	and    dl,0xf
        0...9 => digit + '0',
  2097b9:	b3 30                	mov    bl,0x30
  2097bb:	80 fa 0a             	cmp    dl,0xa
  2097be:	72 02                	jb     2097c2 <dumpCurrentStackTrace+0x8e2>
  2097c0:	b3 57                	mov    bl,0x57
  2097c2:	00 d3                	add    bl,dl
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  2097c4:	88 5c 04 1e          	mov    BYTE PTR [rsp+rax*1+0x1e],bl
        if (a == 0) break;
  2097c8:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  2097cc:	49 81 fd ff 00 00 00 	cmp    r13,0xff
  2097d3:	49 89 cd             	mov    r13,rcx
  2097d6:	77 d8                	ja     2097b0 <dumpCurrentStackTrace+0x8d0>
        const padded_buf = buf[index - padding ..];
  2097d8:	48 8d 0c 04          	lea    rcx,[rsp+rax*1]
  2097dc:	48 83 c1 1f          	add    rcx,0x1f
  2097e0:	ba 41 00 00 00       	mov    edx,0x41
  2097e5:	48 29 c2             	sub    rdx,rax
  2097e8:	48 89 4c 24 08       	mov    QWORD PTR [rsp+0x8],rcx
  2097ed:	48 89 54 24 10       	mov    QWORD PTR [rsp+0x10],rdx
        return output(context, padded_buf);
  2097f2:	4c 89 e7             	mov    rdi,r12
  2097f5:	48 8d 74 24 08       	lea    rsi,[rsp+0x8]
  2097fa:	c5 f8 77             	vzeroupper 
  2097fd:	41 ff d6             	call   r14
  209800:	41 89 c7             	mov    r15d,eax
                    try formatType(args[next_arg], fmt[s..i], context, Errors, output);
  209803:	66 45 85 ff          	test   r15w,r15w
  209807:	0f 85 83 00 00 00    	jne    209890 <dumpCurrentStackTrace+0x9b0>
        try output(context, fmt[start_index..]);
  20980d:	4c 89 e7             	mov    rdi,r12
  209810:	48 8d 35 01 74 01 00 	lea    rsi,[rip+0x17401]        # 220c18 <__unnamed_17>
  209817:	eb 6a                	jmp    209883 <dumpCurrentStackTrace+0x9a3>
        a /= base;
  209819:	4c 89 e9             	mov    rcx,r13
  20981c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  209820:	48 c1 e9 04          	shr    rcx,0x4
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  209824:	89 ca                	mov    edx,ecx
  209826:	80 e2 0f             	and    dl,0xf
        0...9 => digit + '0',
  209829:	b3 30                	mov    bl,0x30
  20982b:	80 fa 0a             	cmp    dl,0xa
  20982e:	72 02                	jb     209832 <dumpCurrentStackTrace+0x952>
  209830:	b3 57                	mov    bl,0x57
  209832:	00 d3                	add    bl,dl
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  209834:	88 5c 04 1e          	mov    BYTE PTR [rsp+rax*1+0x1e],bl
        if (a == 0) break;
  209838:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  20983c:	49 81 fd ff 00 00 00 	cmp    r13,0xff
  209843:	49 89 cd             	mov    r13,rcx
  209846:	77 d8                	ja     209820 <dumpCurrentStackTrace+0x940>
        const padded_buf = buf[index - padding ..];
  209848:	48 8d 0c 04          	lea    rcx,[rsp+rax*1]
  20984c:	48 83 c1 1f          	add    rcx,0x1f
  209850:	ba 41 00 00 00       	mov    edx,0x41
  209855:	48 29 c2             	sub    rdx,rax
  209858:	48 89 4c 24 08       	mov    QWORD PTR [rsp+0x8],rcx
  20985d:	48 89 54 24 10       	mov    QWORD PTR [rsp+0x10],rdx
        return output(context, padded_buf);
  209862:	4c 89 e7             	mov    rdi,r12
  209865:	48 8d 74 24 08       	lea    rsi,[rsp+0x8]
  20986a:	c5 f8 77             	vzeroupper 
  20986d:	41 ff d6             	call   r14
  209870:	41 89 c7             	mov    r15d,eax
                    try formatType(args[next_arg], fmt[s..i], context, Errors, output);
  209873:	66 45 85 ff          	test   r15w,r15w
  209877:	75 17                	jne    209890 <dumpCurrentStackTrace+0x9b0>
        try output(context, fmt[start_index..]);
  209879:	4c 89 e7             	mov    rdi,r12
  20987c:	48 8d 35 b5 73 01 00 	lea    rsi,[rip+0x173b5]        # 220c38 <__unnamed_18>
  209883:	41 ff d6             	call   r14
  209886:	41 89 c7             	mov    r15d,eax
  209889:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  209890:	c5 7d 6f a4 24 00 01 	vmovdqa ymm12,YMMWORD PTR [rsp+0x100]
  209897:	00 00 
  209899:	c5 7d 6f ac 24 e0 00 	vmovdqa ymm13,YMMWORD PTR [rsp+0xe0]
  2098a0:	00 00 
        try printSourceAtAddress(debug_info, out_stream, return_address, tty_color);
  2098a2:	66 45 85 ff          	test   r15w,r15w
  2098a6:	0f 85 fc 0b 00 00    	jne    20a4a8 <dumpCurrentStackTrace+0x15c8>
  2098ac:	31 c0                	xor    eax,eax
  2098ae:	48 8b 8c 24 a8 00 00 	mov    rcx,QWORD PTR [rsp+0xa8]
  2098b5:	00 
  2098b6:	48 8b 94 24 b0 00 00 	mov    rdx,QWORD PTR [rsp+0xb0]
  2098bd:	00 
  2098be:	48 8b 74 24 68       	mov    rsi,QWORD PTR [rsp+0x68]
    while (fp != 0) : (fp = @intToPtr(*const usize, fp).*) {
  2098c3:	48 8b 12             	mov    rdx,QWORD PTR [rdx]
  2098c6:	48 85 d2             	test   rdx,rdx
  2098c9:	0f 85 91 0b 00 00    	jne    20a460 <dumpCurrentStackTrace+0x1580>
  2098cf:	e9 21 0c 00 00       	jmp    20a4f5 <dumpCurrentStackTrace+0x1615>
  2098d4:	48 8b 84 24 38 01 00 	mov    rax,QWORD PTR [rsp+0x138]
  2098db:	00 
  2098dc:	eb 08                	jmp    2098e6 <dumpCurrentStackTrace+0xa06>
            const compile_unit_name = try compile_unit.die.getAttrString(debug_info, DW.AT_name);
  2098de:	4b 8d 04 31          	lea    rax,[r9+r14*1]
  2098e2:	48 83 c0 08          	add    rax,0x8
  2098e6:	48 8b 00             	mov    rax,QWORD PTR [rax]
        }

        pub fn toSliceConst(self: Self) []align(A) const T {
            return self.items[0..self.len];
  2098e9:	48 8b 48 20          	mov    rcx,QWORD PTR [rax+0x20]
        for (self.attrs.toSliceConst()) |*attr| {
  2098ed:	48 85 c9             	test   rcx,rcx
  2098f0:	4c 8b 64 24 70       	mov    r12,QWORD PTR [rsp+0x70]
  2098f5:	0f 84 88 0b 00 00    	je     20a483 <dumpCurrentStackTrace+0x15a3>
  2098fb:	4d 01 f1             	add    r9,r14
  2098fe:	48 8b 40 10          	mov    rax,QWORD PTR [rax+0x10]
  209902:	31 d2                	xor    edx,edx
  209904:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20990b:	00 00 00 00 00 
            if (attr.id == id) return &attr.value;
  209910:	48 83 38 03          	cmp    QWORD PTR [rax],0x3
  209914:	74 12                	je     209928 <dumpCurrentStackTrace+0xa48>
        for (self.attrs.toSliceConst()) |*attr| {
  209916:	48 83 c2 01          	add    rdx,0x1
  20991a:	48 83 c0 28          	add    rax,0x28
  20991e:	48 39 ca             	cmp    rdx,rcx
  209921:	72 ed                	jb     209910 <dumpCurrentStackTrace+0xa30>
  209923:	e9 5b 0b 00 00       	jmp    20a483 <dumpCurrentStackTrace+0x15a3>
  209928:	8a 50 20             	mov    dl,BYTE PTR [rax+0x20]
  20992b:	80 fa 0a             	cmp    dl,0xa
        return switch (form_value.*) {
  20992e:	74 2f                	je     20995f <dumpCurrentStackTrace+0xa7f>
  209930:	48 8d 0d 69 be ff ff 	lea    rcx,[rip+0xffffffffffffbe69]        # 2057a0 <__unnamed_19>
  209937:	80 fa 09             	cmp    dl,0x9
  20993a:	0f 85 a4 00 00 00    	jne    2099e4 <dumpCurrentStackTrace+0xb04>
            FormValue.String => |value| value,
  209940:	66 c7 44 24 08 00 00 	mov    WORD PTR [rsp+0x8],0x0
  209947:	c5 fa 6f 40 08       	vmovdqu xmm0,XMMWORD PTR [rax+0x8]
  20994c:	48 8d 44 24 10       	lea    rax,[rsp+0x10]
  209951:	c5 fa 7f 00          	vmovdqu XMMWORD PTR [rax],xmm0
        return switch (form_value.*) {
  209955:	48 8d 4c 24 08       	lea    rcx,[rsp+0x8]
  20995a:	e9 85 00 00 00       	jmp    2099e4 <dumpCurrentStackTrace+0xb04>
            FormValue.StrPtr => |offset| getString(st, offset),
  20995f:	48 8b 70 08          	mov    rsi,QWORD PTR [rax+0x8]
  209963:	48 8b 4c 24 68       	mov    rcx,QWORD PTR [rsp+0x68]
    const pos = st.debug_str.offset + offset;
  209968:	48 8b 41 70          	mov    rax,QWORD PTR [rcx+0x70]
  20996c:	48 03 70 18          	add    rsi,QWORD PTR [rax+0x18]
  209970:	78 45                	js     2099b7 <dumpCurrentStackTrace+0xad7>
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  209972:	48 63 39             	movsxd rdi,DWORD PTR [rcx]
  209975:	b8 08 00 00 00       	mov    eax,0x8
  20997a:	31 d2                	xor    edx,edx
  20997c:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  20997e:	48 89 c1             	mov    rcx,rax
  209981:	48 f7 d9             	neg    rcx
  209984:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  20998a:	b8 00 00 00 00       	mov    eax,0x0
  20998f:	48 0f 46 c8          	cmovbe rcx,rax
  209993:	66 b8 02 00          	mov    ax,0x2
  209997:	48 83 f9 1d          	cmp    rcx,0x1d
  20999b:	0f 87 96 09 00 00    	ja     20a337 <dumpCurrentStackTrace+0x1457>
  2099a1:	48 8d 15 38 69 ff ff 	lea    rdx,[rip+0xffffffffffff6938]        # 2002e0 <app_mask+0x60>
  2099a8:	48 63 0c 8a          	movsxd rcx,DWORD PTR [rdx+rcx*4]
  2099ac:	48 01 d1             	add    rcx,rdx
  2099af:	ff e1                	jmp    rcx
  2099b1:	66 b8 20 00          	mov    ax,0x20
  2099b5:	eb 04                	jmp    2099bb <dumpCurrentStackTrace+0xadb>
  2099b7:	66 b8 21 00          	mov    ax,0x21
    try st.self_exe_file.seekTo(pos);
  2099bb:	66 89 44 24 20       	mov    WORD PTR [rsp+0x20],ax
  2099c0:	48 8b 84 24 d6 00 00 	mov    rax,QWORD PTR [rsp+0xd6]
  2099c7:	00 
  2099c8:	48 8d 4c 24 5f       	lea    rcx,[rsp+0x5f]
  2099cd:	48 89 41 d1          	mov    QWORD PTR [rcx-0x2f],rax
  2099d1:	c5 fa 6f 84 24 c8 00 	vmovdqu xmm0,XMMWORD PTR [rsp+0xc8]
  2099d8:	00 00 
  2099da:	c5 fa 7f 41 c3       	vmovdqu XMMWORD PTR [rcx-0x3d],xmm0
        return switch (form_value.*) {
  2099df:	48 8d 4c 24 20       	lea    rcx,[rsp+0x20]
  2099e4:	44 0f b7 39          	movzx  r15d,WORD PTR [rcx]
  2099e8:	48 8b 41 10          	mov    rax,QWORD PTR [rcx+0x10]
  2099ec:	48 89 84 24 4e 01 00 	mov    QWORD PTR [rsp+0x14e],rax
  2099f3:	00 
  2099f4:	c5 fa 6f 41 02       	vmovdqu xmm0,XMMWORD PTR [rcx+0x2]
  2099f9:	c5 f9 7f 84 24 40 01 	vmovdqa XMMWORD PTR [rsp+0x140],xmm0
  209a00:	00 00 
            const compile_unit_name = try compile_unit.die.getAttrString(debug_info, DW.AT_name);
  209a02:	66 45 85 ff          	test   r15w,r15w
  209a06:	0f 85 9c 0a 00 00    	jne    20a4a8 <dumpCurrentStackTrace+0x15c8>
  209a0c:	48 8d 84 24 46 01 00 	lea    rax,[rsp+0x146]
  209a13:	00 
  209a14:	c5 fa 6f 00          	vmovdqu xmm0,XMMWORD PTR [rax]
  209a18:	c5 f9 7f 84 24 20 01 	vmovdqa XMMWORD PTR [rsp+0x120],xmm0
  209a1f:	00 00 
            if (getLineNumberInfo(debug_info, compile_unit, address - 1)) |line_info| {
  209a21:	49 8d 4d ff          	lea    rcx,[r13-0x1]
  209a25:	48 8d bc 24 58 01 00 	lea    rdi,[rsp+0x158]
  209a2c:	00 
  209a2d:	48 8b 74 24 68       	mov    rsi,QWORD PTR [rsp+0x68]
  209a32:	4c 89 ca             	mov    rdx,r9
  209a35:	c5 f8 77             	vzeroupper 
  209a38:	e8 83 9b 00 00       	call   2135c0 <getLineNumberInfo>
  209a3d:	44 0f b7 bc 24 58 01 	movzx  r15d,WORD PTR [rsp+0x158]
  209a44:	00 00 
  209a46:	66 45 85 ff          	test   r15w,r15w
  209a4a:	74 77                	je     209ac3 <dumpCurrentStackTrace+0xbe3>
            } else |err| switch (err) {
  209a4c:	44 89 f8             	mov    eax,r15d
  209a4f:	25 fe ff 00 00       	and    eax,0xfffe
  209a54:	83 f8 22             	cmp    eax,0x22
  209a57:	0f 85 4b 0a 00 00    	jne    20a4a8 <dumpCurrentStackTrace+0x15c8>
  209a5d:	4d 8b 34 24          	mov    r14,QWORD PTR [r12]
                        try output(context, fmt[start_index..i]);
  209a61:	4c 89 e7             	mov    rdi,r12
  209a64:	48 8d 35 8d 72 01 00 	lea    rsi,[rip+0x1728d]        # 220cf8 <__unnamed_20>
  209a6b:	41 ff d6             	call   r14
  209a6e:	41 89 c7             	mov    r15d,eax
  209a71:	66 45 85 ff          	test   r15w,r15w
  209a75:	0f 85 15 fe ff ff    	jne    209890 <dumpCurrentStackTrace+0x9b0>
    var buf: [max_int_digits - 1]u8 = undefined;
  209a7b:	c5 fc 10 05 ac cf ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffffcfac]        # 206a2f <__unnamed_3+0x1f>
  209a82:	ff 
  209a83:	c5 fc 11 44 24 3f    	vmovups YMMWORD PTR [rsp+0x3f],ymm0
  209a89:	c5 fe 6f 05 7f cf ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffffcf7f]        # 206a10 <__unnamed_3>
  209a90:	ff 
  209a91:	c5 fe 7f 44 24 20    	vmovdqu YMMWORD PTR [rsp+0x20],ymm0
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  209a97:	44 89 e8             	mov    eax,r13d
  209a9a:	24 0f                	and    al,0xf
        0...9 => digit + '0',
  209a9c:	b1 30                	mov    cl,0x30
  209a9e:	3c 0a                	cmp    al,0xa
  209aa0:	72 02                	jb     209aa4 <dumpCurrentStackTrace+0xbc4>
  209aa2:	b1 57                	mov    cl,0x57
  209aa4:	00 c1                	add    cl,al
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  209aa6:	88 4c 24 5f          	mov    BYTE PTR [rsp+0x5f],cl
  209aaa:	b8 40 00 00 00       	mov    eax,0x40
        if (a == 0) break;
  209aaf:	49 83 fd 10          	cmp    r13,0x10
  209ab3:	0f 83 b8 04 00 00    	jae    209f71 <dumpCurrentStackTrace+0x1091>
  209ab9:	48 8d 4c 24 5f       	lea    rcx,[rsp+0x5f]
  209abe:	e9 ed 04 00 00       	jmp    209fb0 <dumpCurrentStackTrace+0x10d0>
  209ac3:	48 8d 84 24 60 01 00 	lea    rax,[rsp+0x160]
  209aca:	00 
            if (getLineNumberInfo(debug_info, compile_unit, address - 1)) |line_info| {
  209acb:	c5 fe 6f 00          	vmovdqu ymm0,YMMWORD PTR [rax]
  209acf:	c5 fe 7f 84 24 80 00 	vmovdqu YMMWORD PTR [rsp+0x80],ymm0
  209ad6:	00 00 
  209ad8:	48 8b 40 20          	mov    rax,QWORD PTR [rax+0x20]
  209adc:	48 89 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rax
  209ae3:	00 
  209ae4:	4c 89 e3             	mov    rbx,r12
  209ae7:	4c 8b a4 24 80 00 00 	mov    r12,QWORD PTR [rsp+0x80]
  209aee:	00 
  209aef:	48 8b 84 24 88 00 00 	mov    rax,QWORD PTR [rsp+0x88]
  209af6:	00 
  209af7:	48 89 44 24 78       	mov    QWORD PTR [rsp+0x78],rax
  209afc:	4c 8b 33             	mov    r14,QWORD PTR [rbx]
                if (tty_color) {
  209aff:	80 7c 24 07 00       	cmp    BYTE PTR [rsp+0x7],0x0
  209b04:	0f 84 cb 01 00 00    	je     209cd5 <dumpCurrentStackTrace+0xdf5>
                        try output(context, fmt[start_index..i]);
  209b0a:	48 89 df             	mov    rdi,rbx
  209b0d:	48 8d 35 34 71 01 00 	lea    rsi,[rip+0x17134]        # 220c48 <__unnamed_21>
  209b14:	c5 f8 77             	vzeroupper 
  209b17:	41 ff d6             	call   r14
  209b1a:	41 89 c7             	mov    r15d,eax
  209b1d:	66 45 85 ff          	test   r15w,r15w
  209b21:	0f 85 e0 09 00 00    	jne    20a507 <dumpCurrentStackTrace+0x1627>
                const casted_value = ([]const u8)(value);
  209b27:	48 8d 84 24 90 00 00 	lea    rax,[rsp+0x90]
  209b2e:	00 
  209b2f:	c5 fa 6f 00          	vmovdqu xmm0,XMMWORD PTR [rax]
  209b33:	c5 f9 7f 44 24 20    	vmovdqa XMMWORD PTR [rsp+0x20],xmm0
                return output(context, casted_value);
  209b39:	48 89 df             	mov    rdi,rbx
  209b3c:	48 8d 74 24 20       	lea    rsi,[rsp+0x20]
  209b41:	41 ff d6             	call   r14
  209b44:	41 89 c7             	mov    r15d,eax
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  209b47:	66 45 85 ff          	test   r15w,r15w
  209b4b:	0f 85 b6 09 00 00    	jne    20a507 <dumpCurrentStackTrace+0x1627>
                        try output(context, fmt[start_index..i]);
  209b51:	48 89 df             	mov    rdi,rbx
  209b54:	48 8d 35 fd 70 01 00 	lea    rsi,[rip+0x170fd]        # 220c58 <__unnamed_22>
  209b5b:	41 ff d6             	call   r14
  209b5e:	41 89 c7             	mov    r15d,eax
  209b61:	66 45 85 ff          	test   r15w,r15w
  209b65:	0f 85 c5 09 00 00    	jne    20a530 <dumpCurrentStackTrace+0x1650>
    var buf: [max_int_digits - 1]u8 = undefined;
  209b6b:	c5 fc 10 05 bc ce ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffffcebc]        # 206a2f <__unnamed_3+0x1f>
  209b72:	ff 
  209b73:	c5 fc 11 44 24 3f    	vmovups YMMWORD PTR [rsp+0x3f],ymm0
  209b79:	c5 fe 6f 05 8f ce ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffffce8f]        # 206a10 <__unnamed_3>
  209b80:	ff 
  209b81:	c5 fe 7f 44 24 20    	vmovdqu YMMWORD PTR [rsp+0x20],ymm0
        const digit = a % base;
  209b87:	4c 89 e2             	mov    rdx,r12
  209b8a:	48 b8 cd cc cc cc cc 	movabs rax,0xcccccccccccccccd
  209b91:	cc cc cc 
  209b94:	c4 e2 fb f6 c8       	mulx   rcx,rax,rax
  209b99:	c1 e9 02             	shr    ecx,0x2
  209b9c:	81 e1 fe ff ff 3f    	and    ecx,0x3ffffffe
  209ba2:	8d 0c 89             	lea    ecx,[rcx+rcx*4]
  209ba5:	44 89 e0             	mov    eax,r12d
  209ba8:	29 c8                	sub    eax,ecx
        0...9 => digit + '0',
  209baa:	b1 30                	mov    cl,0x30
  209bac:	3c 0a                	cmp    al,0xa
  209bae:	72 02                	jb     209bb2 <dumpCurrentStackTrace+0xcd2>
  209bb0:	b1 57                	mov    cl,0x57
  209bb2:	00 c1                	add    cl,al
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  209bb4:	88 4c 24 5f          	mov    BYTE PTR [rsp+0x5f],cl
  209bb8:	b8 40 00 00 00       	mov    eax,0x40
        if (a == 0) break;
  209bbd:	49 83 fc 0a          	cmp    r12,0xa
  209bc1:	73 0d                	jae    209bd0 <dumpCurrentStackTrace+0xcf0>
  209bc3:	48 8d 4c 24 5f       	lea    rcx,[rsp+0x5f]
  209bc8:	eb 58                	jmp    209c22 <dumpCurrentStackTrace+0xd42>
  209bca:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
        a /= base;
  209bd0:	4c 89 e2             	mov    rdx,r12
  209bd3:	48 b9 cd cc cc cc cc 	movabs rcx,0xcccccccccccccccd
  209bda:	cc cc cc 
  209bdd:	48 89 ce             	mov    rsi,rcx
  209be0:	c4 e2 f3 f6 d6       	mulx   rdx,rcx,rsi
  209be5:	48 c1 ea 03          	shr    rdx,0x3
        const digit = a % base;
  209be9:	c4 e2 f3 f6 f6       	mulx   rsi,rcx,rsi
  209bee:	c1 ee 02             	shr    esi,0x2
  209bf1:	81 e6 fe ff ff 3f    	and    esi,0x3ffffffe
  209bf7:	8d 34 b6             	lea    esi,[rsi+rsi*4]
  209bfa:	89 d1                	mov    ecx,edx
  209bfc:	29 f1                	sub    ecx,esi
        0...9 => digit + '0',
  209bfe:	b3 30                	mov    bl,0x30
  209c00:	80 f9 0a             	cmp    cl,0xa
  209c03:	72 02                	jb     209c07 <dumpCurrentStackTrace+0xd27>
  209c05:	b3 57                	mov    bl,0x57
  209c07:	00 cb                	add    bl,cl
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  209c09:	88 5c 04 1e          	mov    BYTE PTR [rsp+rax*1+0x1e],bl
        if (a == 0) break;
  209c0d:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  209c11:	49 83 fc 63          	cmp    r12,0x63
  209c15:	49 89 d4             	mov    r12,rdx
  209c18:	77 b6                	ja     209bd0 <dumpCurrentStackTrace+0xcf0>
        const padded_buf = buf[index - padding ..];
  209c1a:	48 8d 0c 04          	lea    rcx,[rsp+rax*1]
  209c1e:	48 83 c1 1f          	add    rcx,0x1f
  209c22:	ba 41 00 00 00       	mov    edx,0x41
  209c27:	48 29 c2             	sub    rdx,rax
  209c2a:	48 89 4c 24 08       	mov    QWORD PTR [rsp+0x8],rcx
  209c2f:	48 89 54 24 10       	mov    QWORD PTR [rsp+0x10],rdx
  209c34:	4c 8b 64 24 70       	mov    r12,QWORD PTR [rsp+0x70]
        return output(context, padded_buf);
  209c39:	4c 89 e7             	mov    rdi,r12
  209c3c:	48 8d 74 24 08       	lea    rsi,[rsp+0x8]
  209c41:	c5 f8 77             	vzeroupper 
  209c44:	41 ff d6             	call   r14
  209c47:	41 89 c7             	mov    r15d,eax
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  209c4a:	66 45 85 ff          	test   r15w,r15w
  209c4e:	0f 85 e1 08 00 00    	jne    20a535 <dumpCurrentStackTrace+0x1655>
                        try output(context, fmt[start_index..i]);
  209c54:	4c 89 e7             	mov    rdi,r12
  209c57:	48 8d 35 0a 70 01 00 	lea    rsi,[rip+0x1700a]        # 220c68 <__unnamed_23>
  209c5e:	41 ff d6             	call   r14
  209c61:	41 89 c7             	mov    r15d,eax
  209c64:	66 45 85 ff          	test   r15w,r15w
  209c68:	0f 85 c7 08 00 00    	jne    20a535 <dumpCurrentStackTrace+0x1655>
    var buf: [max_int_digits - 1]u8 = undefined;
  209c6e:	c5 fc 10 05 b9 cd ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffffcdb9]        # 206a2f <__unnamed_3+0x1f>
  209c75:	ff 
  209c76:	c5 fc 11 44 24 3f    	vmovups YMMWORD PTR [rsp+0x3f],ymm0
  209c7c:	c5 fe 6f 05 8c cd ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffffcd8c]        # 206a10 <__unnamed_3>
  209c83:	ff 
  209c84:	c5 fe 7f 44 24 20    	vmovdqu YMMWORD PTR [rsp+0x20],ymm0
  209c8a:	48 8b 54 24 78       	mov    rdx,QWORD PTR [rsp+0x78]
        const digit = a % base;
  209c8f:	48 b8 cd cc cc cc cc 	movabs rax,0xcccccccccccccccd
  209c96:	cc cc cc 
  209c99:	c4 e2 fb f6 c8       	mulx   rcx,rax,rax
  209c9e:	c1 e9 02             	shr    ecx,0x2
  209ca1:	81 e1 fe ff ff 3f    	and    ecx,0x3ffffffe
  209ca7:	8d 0c 89             	lea    ecx,[rcx+rcx*4]
  209caa:	89 d0                	mov    eax,edx
  209cac:	29 c8                	sub    eax,ecx
        0...9 => digit + '0',
  209cae:	b1 30                	mov    cl,0x30
  209cb0:	3c 0a                	cmp    al,0xa
  209cb2:	72 02                	jb     209cb6 <dumpCurrentStackTrace+0xdd6>
  209cb4:	b1 57                	mov    cl,0x57
  209cb6:	00 c1                	add    cl,al
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  209cb8:	88 4c 24 5f          	mov    BYTE PTR [rsp+0x5f],cl
  209cbc:	b9 40 00 00 00       	mov    ecx,0x40
        if (a == 0) break;
  209cc1:	48 83 fa 0a          	cmp    rdx,0xa
  209cc5:	0f 83 62 03 00 00    	jae    20a02d <dumpCurrentStackTrace+0x114d>
  209ccb:	48 8d 44 24 5f       	lea    rax,[rsp+0x5f]
  209cd0:	e9 af 03 00 00       	jmp    20a084 <dumpCurrentStackTrace+0x11a4>
                const casted_value = ([]const u8)(value);
  209cd5:	48 8d 84 24 90 00 00 	lea    rax,[rsp+0x90]
  209cdc:	00 
  209cdd:	c5 fa 6f 00          	vmovdqu xmm0,XMMWORD PTR [rax]
  209ce1:	c5 f9 7f 44 24 20    	vmovdqa XMMWORD PTR [rsp+0x20],xmm0
                return output(context, casted_value);
  209ce7:	48 89 df             	mov    rdi,rbx
  209cea:	48 8d 74 24 20       	lea    rsi,[rsp+0x20]
  209cef:	c5 f8 77             	vzeroupper 
  209cf2:	41 ff d6             	call   r14
  209cf5:	41 89 c7             	mov    r15d,eax
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  209cf8:	66 45 85 ff          	test   r15w,r15w
  209cfc:	0f 85 05 08 00 00    	jne    20a507 <dumpCurrentStackTrace+0x1627>
                        try output(context, fmt[start_index..i]);
  209d02:	48 89 df             	mov    rdi,rbx
  209d05:	48 8d 35 9c 6f 01 00 	lea    rsi,[rip+0x16f9c]        # 220ca8 <__unnamed_24>
  209d0c:	41 ff d6             	call   r14
  209d0f:	41 89 c7             	mov    r15d,eax
  209d12:	66 45 85 ff          	test   r15w,r15w
  209d16:	0f 85 fd 07 00 00    	jne    20a519 <dumpCurrentStackTrace+0x1639>
    var buf: [max_int_digits - 1]u8 = undefined;
  209d1c:	c5 fc 10 05 0b cd ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffffcd0b]        # 206a2f <__unnamed_3+0x1f>
  209d23:	ff 
  209d24:	c5 fc 11 44 24 3f    	vmovups YMMWORD PTR [rsp+0x3f],ymm0
  209d2a:	c5 fe 6f 05 de cc ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffffccde]        # 206a10 <__unnamed_3>
  209d31:	ff 
  209d32:	c5 fe 7f 44 24 20    	vmovdqu YMMWORD PTR [rsp+0x20],ymm0
        const digit = a % base;
  209d38:	4c 89 e2             	mov    rdx,r12
  209d3b:	48 b8 cd cc cc cc cc 	movabs rax,0xcccccccccccccccd
  209d42:	cc cc cc 
  209d45:	c4 e2 fb f6 c8       	mulx   rcx,rax,rax
  209d4a:	c1 e9 02             	shr    ecx,0x2
  209d4d:	81 e1 fe ff ff 3f    	and    ecx,0x3ffffffe
  209d53:	8d 0c 89             	lea    ecx,[rcx+rcx*4]
  209d56:	44 89 e0             	mov    eax,r12d
  209d59:	29 c8                	sub    eax,ecx
        0...9 => digit + '0',
  209d5b:	b1 30                	mov    cl,0x30
  209d5d:	3c 0a                	cmp    al,0xa
  209d5f:	72 02                	jb     209d63 <dumpCurrentStackTrace+0xe83>
  209d61:	b1 57                	mov    cl,0x57
  209d63:	00 c1                	add    cl,al
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  209d65:	88 4c 24 5f          	mov    BYTE PTR [rsp+0x5f],cl
  209d69:	b8 40 00 00 00       	mov    eax,0x40
        if (a == 0) break;
  209d6e:	49 83 fc 0a          	cmp    r12,0xa
  209d72:	73 0c                	jae    209d80 <dumpCurrentStackTrace+0xea0>
  209d74:	48 8d 4c 24 5f       	lea    rcx,[rsp+0x5f]
  209d79:	eb 57                	jmp    209dd2 <dumpCurrentStackTrace+0xef2>
  209d7b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
        a /= base;
  209d80:	4c 89 e2             	mov    rdx,r12
  209d83:	48 b9 cd cc cc cc cc 	movabs rcx,0xcccccccccccccccd
  209d8a:	cc cc cc 
  209d8d:	48 89 ce             	mov    rsi,rcx
  209d90:	c4 e2 f3 f6 d6       	mulx   rdx,rcx,rsi
  209d95:	48 c1 ea 03          	shr    rdx,0x3
        const digit = a % base;
  209d99:	c4 e2 f3 f6 f6       	mulx   rsi,rcx,rsi
  209d9e:	c1 ee 02             	shr    esi,0x2
  209da1:	81 e6 fe ff ff 3f    	and    esi,0x3ffffffe
  209da7:	8d 34 b6             	lea    esi,[rsi+rsi*4]
  209daa:	89 d1                	mov    ecx,edx
  209dac:	29 f1                	sub    ecx,esi
        0...9 => digit + '0',
  209dae:	b3 30                	mov    bl,0x30
  209db0:	80 f9 0a             	cmp    cl,0xa
  209db3:	72 02                	jb     209db7 <dumpCurrentStackTrace+0xed7>
  209db5:	b3 57                	mov    bl,0x57
  209db7:	00 cb                	add    bl,cl
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  209db9:	88 5c 04 1e          	mov    BYTE PTR [rsp+rax*1+0x1e],bl
        if (a == 0) break;
  209dbd:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  209dc1:	49 83 fc 63          	cmp    r12,0x63
  209dc5:	49 89 d4             	mov    r12,rdx
  209dc8:	77 b6                	ja     209d80 <dumpCurrentStackTrace+0xea0>
        const padded_buf = buf[index - padding ..];
  209dca:	48 8d 0c 04          	lea    rcx,[rsp+rax*1]
  209dce:	48 83 c1 1f          	add    rcx,0x1f
  209dd2:	ba 41 00 00 00       	mov    edx,0x41
  209dd7:	48 29 c2             	sub    rdx,rax
  209dda:	48 89 4c 24 08       	mov    QWORD PTR [rsp+0x8],rcx
  209ddf:	48 89 54 24 10       	mov    QWORD PTR [rsp+0x10],rdx
  209de4:	4c 8b 64 24 70       	mov    r12,QWORD PTR [rsp+0x70]
        return output(context, padded_buf);
  209de9:	4c 89 e7             	mov    rdi,r12
  209dec:	48 8d 74 24 08       	lea    rsi,[rsp+0x8]
  209df1:	c5 f8 77             	vzeroupper 
  209df4:	41 ff d6             	call   r14
  209df7:	41 89 c7             	mov    r15d,eax
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  209dfa:	66 45 85 ff          	test   r15w,r15w
  209dfe:	0f 85 31 07 00 00    	jne    20a535 <dumpCurrentStackTrace+0x1655>
                        try output(context, fmt[start_index..i]);
  209e04:	4c 89 e7             	mov    rdi,r12
  209e07:	48 8d 35 aa 6e 01 00 	lea    rsi,[rip+0x16eaa]        # 220cb8 <__unnamed_25>
  209e0e:	41 ff d6             	call   r14
  209e11:	41 89 c7             	mov    r15d,eax
  209e14:	66 45 85 ff          	test   r15w,r15w
  209e18:	0f 85 17 07 00 00    	jne    20a535 <dumpCurrentStackTrace+0x1655>
    var buf: [max_int_digits - 1]u8 = undefined;
  209e1e:	c5 fc 10 05 09 cc ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffffcc09]        # 206a2f <__unnamed_3+0x1f>
  209e25:	ff 
  209e26:	c5 fc 11 44 24 3f    	vmovups YMMWORD PTR [rsp+0x3f],ymm0
  209e2c:	c5 fe 6f 05 dc cb ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffffcbdc]        # 206a10 <__unnamed_3>
  209e33:	ff 
  209e34:	c5 fe 7f 44 24 20    	vmovdqu YMMWORD PTR [rsp+0x20],ymm0
  209e3a:	48 8b 7c 24 78       	mov    rdi,QWORD PTR [rsp+0x78]
        const digit = a % base;
  209e3f:	48 89 fa             	mov    rdx,rdi
  209e42:	48 b8 cd cc cc cc cc 	movabs rax,0xcccccccccccccccd
  209e49:	cc cc cc 
  209e4c:	c4 e2 fb f6 c8       	mulx   rcx,rax,rax
  209e51:	c1 e9 02             	shr    ecx,0x2
  209e54:	81 e1 fe ff ff 3f    	and    ecx,0x3ffffffe
  209e5a:	8d 0c 89             	lea    ecx,[rcx+rcx*4]
  209e5d:	89 f8                	mov    eax,edi
  209e5f:	29 c8                	sub    eax,ecx
        0...9 => digit + '0',
  209e61:	b1 30                	mov    cl,0x30
  209e63:	3c 0a                	cmp    al,0xa
  209e65:	72 02                	jb     209e69 <dumpCurrentStackTrace+0xf89>
  209e67:	b1 57                	mov    cl,0x57
  209e69:	00 c1                	add    cl,al
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  209e6b:	88 4c 24 5f          	mov    BYTE PTR [rsp+0x5f],cl
  209e6f:	b8 40 00 00 00       	mov    eax,0x40
        if (a == 0) break;
  209e74:	48 83 ff 0a          	cmp    rdi,0xa
  209e78:	73 16                	jae    209e90 <dumpCurrentStackTrace+0xfb0>
  209e7a:	48 8d 4c 24 5f       	lea    rcx,[rsp+0x5f]
  209e7f:	eb 61                	jmp    209ee2 <dumpCurrentStackTrace+0x1002>
  209e81:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  209e88:	0f 1f 84 00 00 00 00 
  209e8f:	00 
        a /= base;
  209e90:	48 89 fa             	mov    rdx,rdi
  209e93:	48 b9 cd cc cc cc cc 	movabs rcx,0xcccccccccccccccd
  209e9a:	cc cc cc 
  209e9d:	48 89 ce             	mov    rsi,rcx
  209ea0:	c4 e2 f3 f6 d6       	mulx   rdx,rcx,rsi
  209ea5:	48 c1 ea 03          	shr    rdx,0x3
        const digit = a % base;
  209ea9:	c4 e2 f3 f6 f6       	mulx   rsi,rcx,rsi
  209eae:	c1 ee 02             	shr    esi,0x2
  209eb1:	81 e6 fe ff ff 3f    	and    esi,0x3ffffffe
  209eb7:	8d 34 b6             	lea    esi,[rsi+rsi*4]
  209eba:	89 d1                	mov    ecx,edx
  209ebc:	29 f1                	sub    ecx,esi
        0...9 => digit + '0',
  209ebe:	b3 30                	mov    bl,0x30
  209ec0:	80 f9 0a             	cmp    cl,0xa
  209ec3:	72 02                	jb     209ec7 <dumpCurrentStackTrace+0xfe7>
  209ec5:	b3 57                	mov    bl,0x57
  209ec7:	00 cb                	add    bl,cl
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  209ec9:	88 5c 04 1e          	mov    BYTE PTR [rsp+rax*1+0x1e],bl
        if (a == 0) break;
  209ecd:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  209ed1:	48 83 ff 63          	cmp    rdi,0x63
  209ed5:	48 89 d7             	mov    rdi,rdx
  209ed8:	77 b6                	ja     209e90 <dumpCurrentStackTrace+0xfb0>
        const padded_buf = buf[index - padding ..];
  209eda:	48 8d 0c 04          	lea    rcx,[rsp+rax*1]
  209ede:	48 83 c1 1f          	add    rcx,0x1f
  209ee2:	ba 41 00 00 00       	mov    edx,0x41
  209ee7:	48 29 c2             	sub    rdx,rax
  209eea:	48 89 4c 24 08       	mov    QWORD PTR [rsp+0x8],rcx
  209eef:	48 89 54 24 10       	mov    QWORD PTR [rsp+0x10],rdx
        return output(context, padded_buf);
  209ef4:	4c 89 e7             	mov    rdi,r12
  209ef7:	48 8d 74 24 08       	lea    rsi,[rsp+0x8]
  209efc:	c5 f8 77             	vzeroupper 
  209eff:	41 ff d6             	call   r14
  209f02:	41 89 c7             	mov    r15d,eax
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  209f05:	66 45 85 ff          	test   r15w,r15w
  209f09:	0f 85 26 06 00 00    	jne    20a535 <dumpCurrentStackTrace+0x1655>
                        try output(context, fmt[start_index..i]);
  209f0f:	4c 89 e7             	mov    rdi,r12
  209f12:	48 8d 35 af 6d 01 00 	lea    rsi,[rip+0x16daf]        # 220cc8 <__unnamed_26>
  209f19:	41 ff d6             	call   r14
  209f1c:	41 89 c7             	mov    r15d,eax
  209f1f:	66 45 85 ff          	test   r15w,r15w
  209f23:	0f 85 0c 06 00 00    	jne    20a535 <dumpCurrentStackTrace+0x1655>
    var buf: [max_int_digits - 1]u8 = undefined;
  209f29:	c5 fc 10 05 fe ca ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffffcafe]        # 206a2f <__unnamed_3+0x1f>
  209f30:	ff 
  209f31:	c5 fc 11 44 24 3f    	vmovups YMMWORD PTR [rsp+0x3f],ymm0
  209f37:	c5 fe 6f 05 d1 ca ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffffcad1]        # 206a10 <__unnamed_3>
  209f3e:	ff 
  209f3f:	c5 fe 7f 44 24 20    	vmovdqu YMMWORD PTR [rsp+0x20],ymm0
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  209f45:	44 89 e8             	mov    eax,r13d
  209f48:	24 0f                	and    al,0xf
        0...9 => digit + '0',
  209f4a:	b1 30                	mov    cl,0x30
  209f4c:	3c 0a                	cmp    al,0xa
  209f4e:	72 02                	jb     209f52 <dumpCurrentStackTrace+0x1072>
  209f50:	b1 57                	mov    cl,0x57
  209f52:	00 c1                	add    cl,al
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  209f54:	88 4c 24 5f          	mov    BYTE PTR [rsp+0x5f],cl
  209f58:	b8 40 00 00 00       	mov    eax,0x40
        if (a == 0) break;
  209f5d:	49 83 fd 10          	cmp    r13,0x10
  209f61:	0f 83 ac 01 00 00    	jae    20a113 <dumpCurrentStackTrace+0x1233>
  209f67:	48 8d 4c 24 5f       	lea    rcx,[rsp+0x5f]
  209f6c:	e9 df 01 00 00       	jmp    20a150 <dumpCurrentStackTrace+0x1270>
        a /= base;
  209f71:	4c 89 e9             	mov    rcx,r13
  209f74:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  209f7b:	00 00 00 00 00 
  209f80:	48 c1 e9 04          	shr    rcx,0x4
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  209f84:	89 ca                	mov    edx,ecx
  209f86:	80 e2 0f             	and    dl,0xf
        0...9 => digit + '0',
  209f89:	b3 30                	mov    bl,0x30
  209f8b:	80 fa 0a             	cmp    dl,0xa
  209f8e:	72 02                	jb     209f92 <dumpCurrentStackTrace+0x10b2>
  209f90:	b3 57                	mov    bl,0x57
  209f92:	00 d3                	add    bl,dl
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  209f94:	88 5c 04 1e          	mov    BYTE PTR [rsp+rax*1+0x1e],bl
        if (a == 0) break;
  209f98:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  209f9c:	49 81 fd ff 00 00 00 	cmp    r13,0xff
  209fa3:	49 89 cd             	mov    r13,rcx
  209fa6:	77 d8                	ja     209f80 <dumpCurrentStackTrace+0x10a0>
        const padded_buf = buf[index - padding ..];
  209fa8:	48 8d 0c 04          	lea    rcx,[rsp+rax*1]
  209fac:	48 83 c1 1f          	add    rcx,0x1f
  209fb0:	ba 41 00 00 00       	mov    edx,0x41
  209fb5:	48 29 c2             	sub    rdx,rax
  209fb8:	48 89 4c 24 08       	mov    QWORD PTR [rsp+0x8],rcx
  209fbd:	48 89 54 24 10       	mov    QWORD PTR [rsp+0x10],rdx
        return output(context, padded_buf);
  209fc2:	4c 89 e7             	mov    rdi,r12
  209fc5:	48 8d 74 24 08       	lea    rsi,[rsp+0x8]
  209fca:	c5 f8 77             	vzeroupper 
  209fcd:	41 ff d6             	call   r14
  209fd0:	41 89 c7             	mov    r15d,eax
                    try formatType(args[next_arg], fmt[s..i], context, Errors, output);
  209fd3:	66 45 85 ff          	test   r15w,r15w
  209fd7:	0f 85 b3 f8 ff ff    	jne    209890 <dumpCurrentStackTrace+0x9b0>
                        try output(context, fmt[start_index..i]);
  209fdd:	4c 89 e7             	mov    rdi,r12
  209fe0:	48 8d 35 21 6d 01 00 	lea    rsi,[rip+0x16d21]        # 220d08 <__unnamed_27>
  209fe7:	41 ff d6             	call   r14
  209fea:	41 89 c7             	mov    r15d,eax
  209fed:	66 45 85 ff          	test   r15w,r15w
  209ff1:	0f 85 99 f8 ff ff    	jne    209890 <dumpCurrentStackTrace+0x9b0>
                const casted_value = ([]const u8)(value);
  209ff7:	c5 f9 6f 84 24 20 01 	vmovdqa xmm0,XMMWORD PTR [rsp+0x120]
  209ffe:	00 00 
  20a000:	c5 f9 7f 44 24 20    	vmovdqa XMMWORD PTR [rsp+0x20],xmm0
                return output(context, casted_value);
  20a006:	4c 89 e7             	mov    rdi,r12
  20a009:	48 8d 74 24 20       	lea    rsi,[rsp+0x20]
  20a00e:	41 ff d6             	call   r14
  20a011:	41 89 c7             	mov    r15d,eax
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  20a014:	66 45 85 ff          	test   r15w,r15w
  20a018:	0f 85 72 f8 ff ff    	jne    209890 <dumpCurrentStackTrace+0x9b0>
        try output(context, fmt[start_index..]);
  20a01e:	4c 89 e7             	mov    rdi,r12
  20a021:	48 8d 35 f0 6c 01 00 	lea    rsi,[rip+0x16cf0]        # 220d18 <__unnamed_28>
  20a028:	e9 56 f8 ff ff       	jmp    209883 <dumpCurrentStackTrace+0x9a3>
  20a02d:	48 89 d0             	mov    rax,rdx
        a /= base;
  20a030:	48 89 c2             	mov    rdx,rax
  20a033:	48 be cd cc cc cc cc 	movabs rsi,0xcccccccccccccccd
  20a03a:	cc cc cc 
  20a03d:	48 89 f7             	mov    rdi,rsi
  20a040:	c4 e2 cb f6 d7       	mulx   rdx,rsi,rdi
  20a045:	48 c1 ea 03          	shr    rdx,0x3
        const digit = a % base;
  20a049:	c4 e2 cb f6 ff       	mulx   rdi,rsi,rdi
  20a04e:	c1 ef 02             	shr    edi,0x2
  20a051:	81 e7 fe ff ff 3f    	and    edi,0x3ffffffe
  20a057:	8d 3c bf             	lea    edi,[rdi+rdi*4]
  20a05a:	89 d6                	mov    esi,edx
  20a05c:	29 fe                	sub    esi,edi
        0...9 => digit + '0',
  20a05e:	b3 30                	mov    bl,0x30
  20a060:	40 80 fe 0a          	cmp    sil,0xa
  20a064:	72 02                	jb     20a068 <dumpCurrentStackTrace+0x1188>
  20a066:	b3 57                	mov    bl,0x57
  20a068:	40 00 f3             	add    bl,sil
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  20a06b:	88 5c 0c 1e          	mov    BYTE PTR [rsp+rcx*1+0x1e],bl
        if (a == 0) break;
  20a06f:	48 83 c1 ff          	add    rcx,0xffffffffffffffff
  20a073:	48 83 f8 63          	cmp    rax,0x63
  20a077:	48 89 d0             	mov    rax,rdx
  20a07a:	77 b4                	ja     20a030 <dumpCurrentStackTrace+0x1150>
        const padded_buf = buf[index - padding ..];
  20a07c:	48 8d 04 0c          	lea    rax,[rsp+rcx*1]
  20a080:	48 83 c0 1f          	add    rax,0x1f
  20a084:	ba 41 00 00 00       	mov    edx,0x41
  20a089:	48 29 ca             	sub    rdx,rcx
  20a08c:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  20a091:	48 89 54 24 10       	mov    QWORD PTR [rsp+0x10],rdx
        return output(context, padded_buf);
  20a096:	4c 89 e7             	mov    rdi,r12
  20a099:	48 8d 74 24 08       	lea    rsi,[rsp+0x8]
  20a09e:	c5 f8 77             	vzeroupper 
  20a0a1:	41 ff d6             	call   r14
  20a0a4:	41 89 c7             	mov    r15d,eax
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  20a0a7:	66 45 85 ff          	test   r15w,r15w
  20a0ab:	0f 85 84 04 00 00    	jne    20a535 <dumpCurrentStackTrace+0x1655>
                        try output(context, fmt[start_index..i]);
  20a0b1:	4c 89 e7             	mov    rdi,r12
  20a0b4:	48 8d 35 bd 6b 01 00 	lea    rsi,[rip+0x16bbd]        # 220c78 <__unnamed_29>
  20a0bb:	41 ff d6             	call   r14
  20a0be:	41 89 c7             	mov    r15d,eax
  20a0c1:	66 45 85 ff          	test   r15w,r15w
  20a0c5:	0f 85 6a 04 00 00    	jne    20a535 <dumpCurrentStackTrace+0x1655>
    var buf: [max_int_digits - 1]u8 = undefined;
  20a0cb:	c5 fc 10 05 5c c9 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffffc95c]        # 206a2f <__unnamed_3+0x1f>
  20a0d2:	ff 
  20a0d3:	c5 fc 11 44 24 3f    	vmovups YMMWORD PTR [rsp+0x3f],ymm0
  20a0d9:	c5 fe 6f 05 2f c9 ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffffc92f]        # 206a10 <__unnamed_3>
  20a0e0:	ff 
  20a0e1:	c5 fe 7f 44 24 20    	vmovdqu YMMWORD PTR [rsp+0x20],ymm0
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  20a0e7:	44 89 e8             	mov    eax,r13d
  20a0ea:	24 0f                	and    al,0xf
        0...9 => digit + '0',
  20a0ec:	b1 30                	mov    cl,0x30
  20a0ee:	3c 0a                	cmp    al,0xa
  20a0f0:	72 02                	jb     20a0f4 <dumpCurrentStackTrace+0x1214>
  20a0f2:	b1 57                	mov    cl,0x57
  20a0f4:	00 c1                	add    cl,al
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  20a0f6:	88 4c 24 5f          	mov    BYTE PTR [rsp+0x5f],cl
  20a0fa:	b8 40 00 00 00       	mov    eax,0x40
        if (a == 0) break;
  20a0ff:	49 83 fd 10          	cmp    r13,0x10
  20a103:	0f 83 d4 00 00 00    	jae    20a1dd <dumpCurrentStackTrace+0x12fd>
  20a109:	48 8d 4c 24 5f       	lea    rcx,[rsp+0x5f]
  20a10e:	e9 fd 00 00 00       	jmp    20a210 <dumpCurrentStackTrace+0x1330>
        a /= base;
  20a113:	4c 89 e9             	mov    rcx,r13
  20a116:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  20a11d:	00 00 00 
  20a120:	48 c1 e9 04          	shr    rcx,0x4
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  20a124:	89 ca                	mov    edx,ecx
  20a126:	80 e2 0f             	and    dl,0xf
        0...9 => digit + '0',
  20a129:	b3 30                	mov    bl,0x30
  20a12b:	80 fa 0a             	cmp    dl,0xa
  20a12e:	72 02                	jb     20a132 <dumpCurrentStackTrace+0x1252>
  20a130:	b3 57                	mov    bl,0x57
  20a132:	00 d3                	add    bl,dl
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  20a134:	88 5c 04 1e          	mov    BYTE PTR [rsp+rax*1+0x1e],bl
        if (a == 0) break;
  20a138:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  20a13c:	49 81 fd ff 00 00 00 	cmp    r13,0xff
  20a143:	49 89 cd             	mov    r13,rcx
  20a146:	77 d8                	ja     20a120 <dumpCurrentStackTrace+0x1240>
        const padded_buf = buf[index - padding ..];
  20a148:	48 8d 0c 04          	lea    rcx,[rsp+rax*1]
  20a14c:	48 83 c1 1f          	add    rcx,0x1f
  20a150:	ba 41 00 00 00       	mov    edx,0x41
  20a155:	48 29 c2             	sub    rdx,rax
  20a158:	48 89 4c 24 08       	mov    QWORD PTR [rsp+0x8],rcx
  20a15d:	48 89 54 24 10       	mov    QWORD PTR [rsp+0x10],rdx
        return output(context, padded_buf);
  20a162:	4c 89 e7             	mov    rdi,r12
  20a165:	48 8d 74 24 08       	lea    rsi,[rsp+0x8]
  20a16a:	c5 f8 77             	vzeroupper 
  20a16d:	41 ff d6             	call   r14
  20a170:	41 89 c7             	mov    r15d,eax
                    try formatType(args[next_arg], fmt[s..i], context, Errors, output);
  20a173:	66 45 85 ff          	test   r15w,r15w
  20a177:	0f 85 b8 03 00 00    	jne    20a535 <dumpCurrentStackTrace+0x1655>
                        try output(context, fmt[start_index..i]);
  20a17d:	4c 89 e7             	mov    rdi,r12
  20a180:	48 8d 35 51 6b 01 00 	lea    rsi,[rip+0x16b51]        # 220cd8 <__unnamed_30>
  20a187:	41 ff d6             	call   r14
  20a18a:	41 89 c7             	mov    r15d,eax
  20a18d:	66 45 85 ff          	test   r15w,r15w
  20a191:	0f 85 9e 03 00 00    	jne    20a535 <dumpCurrentStackTrace+0x1655>
                const casted_value = ([]const u8)(value);
  20a197:	c5 f9 6f 84 24 20 01 	vmovdqa xmm0,XMMWORD PTR [rsp+0x120]
  20a19e:	00 00 
  20a1a0:	c5 f9 7f 44 24 20    	vmovdqa XMMWORD PTR [rsp+0x20],xmm0
                return output(context, casted_value);
  20a1a6:	4c 89 e7             	mov    rdi,r12
  20a1a9:	48 8d 74 24 20       	lea    rsi,[rsp+0x20]
  20a1ae:	41 ff d6             	call   r14
  20a1b1:	41 89 c7             	mov    r15d,eax
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  20a1b4:	66 45 85 ff          	test   r15w,r15w
  20a1b8:	0f 85 77 03 00 00    	jne    20a535 <dumpCurrentStackTrace+0x1655>
        try output(context, fmt[start_index..]);
  20a1be:	4c 89 e7             	mov    rdi,r12
  20a1c1:	48 8d 35 20 6b 01 00 	lea    rsi,[rip+0x16b20]        # 220ce8 <__unnamed_31>
  20a1c8:	41 ff d6             	call   r14
  20a1cb:	41 89 c7             	mov    r15d,eax
                    try out_stream.print(
  20a1ce:	66 45 85 ff          	test   r15w,r15w
  20a1d2:	0f 84 29 02 00 00    	je     20a401 <dumpCurrentStackTrace+0x1521>
  20a1d8:	e9 58 03 00 00       	jmp    20a535 <dumpCurrentStackTrace+0x1655>
        a /= base;
  20a1dd:	4c 89 e9             	mov    rcx,r13
  20a1e0:	48 c1 e9 04          	shr    rcx,0x4
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  20a1e4:	89 ca                	mov    edx,ecx
  20a1e6:	80 e2 0f             	and    dl,0xf
        0...9 => digit + '0',
  20a1e9:	b3 30                	mov    bl,0x30
  20a1eb:	80 fa 0a             	cmp    dl,0xa
  20a1ee:	72 02                	jb     20a1f2 <dumpCurrentStackTrace+0x1312>
  20a1f0:	b3 57                	mov    bl,0x57
  20a1f2:	00 d3                	add    bl,dl
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  20a1f4:	88 5c 04 1e          	mov    BYTE PTR [rsp+rax*1+0x1e],bl
        if (a == 0) break;
  20a1f8:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  20a1fc:	49 81 fd ff 00 00 00 	cmp    r13,0xff
  20a203:	49 89 cd             	mov    r13,rcx
  20a206:	77 d8                	ja     20a1e0 <dumpCurrentStackTrace+0x1300>
        const padded_buf = buf[index - padding ..];
  20a208:	48 8d 0c 04          	lea    rcx,[rsp+rax*1]
  20a20c:	48 83 c1 1f          	add    rcx,0x1f
  20a210:	ba 41 00 00 00       	mov    edx,0x41
  20a215:	48 29 c2             	sub    rdx,rax
  20a218:	48 89 4c 24 08       	mov    QWORD PTR [rsp+0x8],rcx
  20a21d:	48 89 54 24 10       	mov    QWORD PTR [rsp+0x10],rdx
        return output(context, padded_buf);
  20a222:	4c 89 e7             	mov    rdi,r12
  20a225:	48 8d 74 24 08       	lea    rsi,[rsp+0x8]
  20a22a:	c5 f8 77             	vzeroupper 
  20a22d:	41 ff d6             	call   r14
  20a230:	41 89 c7             	mov    r15d,eax
                    try formatType(args[next_arg], fmt[s..i], context, Errors, output);
  20a233:	66 45 85 ff          	test   r15w,r15w
  20a237:	0f 85 f8 02 00 00    	jne    20a535 <dumpCurrentStackTrace+0x1655>
                        try output(context, fmt[start_index..i]);
  20a23d:	4c 89 e7             	mov    rdi,r12
  20a240:	48 8d 35 41 6a 01 00 	lea    rsi,[rip+0x16a41]        # 220c88 <__unnamed_32>
  20a247:	41 ff d6             	call   r14
  20a24a:	41 89 c7             	mov    r15d,eax
  20a24d:	66 45 85 ff          	test   r15w,r15w
  20a251:	0f 85 de 02 00 00    	jne    20a535 <dumpCurrentStackTrace+0x1655>
                const casted_value = ([]const u8)(value);
  20a257:	c5 f9 6f 84 24 20 01 	vmovdqa xmm0,XMMWORD PTR [rsp+0x120]
  20a25e:	00 00 
  20a260:	c5 f9 7f 44 24 20    	vmovdqa XMMWORD PTR [rsp+0x20],xmm0
                return output(context, casted_value);
  20a266:	4c 89 e7             	mov    rdi,r12
  20a269:	48 8d 74 24 20       	lea    rsi,[rsp+0x20]
  20a26e:	41 ff d6             	call   r14
  20a271:	41 89 c7             	mov    r15d,eax
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  20a274:	66 45 85 ff          	test   r15w,r15w
  20a278:	0f 85 b7 02 00 00    	jne    20a535 <dumpCurrentStackTrace+0x1655>
        try output(context, fmt[start_index..]);
  20a27e:	4c 89 e7             	mov    rdi,r12
  20a281:	48 8d 35 10 6a 01 00 	lea    rsi,[rip+0x16a10]        # 220c98 <__unnamed_33>
  20a288:	41 ff d6             	call   r14
  20a28b:	41 89 c7             	mov    r15d,eax
                    try out_stream.print(
  20a28e:	66 45 85 ff          	test   r15w,r15w
  20a292:	0f 85 9d 02 00 00    	jne    20a535 <dumpCurrentStackTrace+0x1655>
                    if (printLineFromFile(out_stream, line_info)) {
  20a298:	4c 89 e7             	mov    rdi,r12
  20a29b:	48 8d b4 24 80 00 00 	lea    rsi,[rsp+0x80]
  20a2a2:	00 
  20a2a3:	e8 08 b3 00 00       	call   2155b0 <printLineFromFile>
  20a2a8:	41 89 c7             	mov    r15d,eax
  20a2ab:	41 0f b7 c7          	movzx  eax,r15w
  20a2af:	83 f8 24             	cmp    eax,0x24
  20a2b2:	0f 84 49 01 00 00    	je     20a401 <dumpCurrentStackTrace+0x1521>
  20a2b8:	66 45 85 ff          	test   r15w,r15w
  20a2bc:	0f 85 84 00 00 00    	jne    20a346 <dumpCurrentStackTrace+0x1466>
  20a2c2:	48 8b 44 24 78       	mov    rax,QWORD PTR [rsp+0x78]
                        if (line_info.column == 0) {
  20a2c7:	48 85 c0             	test   rax,rax
  20a2ca:	0f 84 16 01 00 00    	je     20a3e6 <dumpCurrentStackTrace+0x1506>
  20a2d0:	48 83 f8 01          	cmp    rax,0x1
  20a2d4:	74 41                	je     20a317 <dumpCurrentStackTrace+0x1437>
  20a2d6:	bb 01 00 00 00       	mov    ebx,0x1
  20a2db:	c6 44 24 08 20       	mov    BYTE PTR [rsp+0x8],0x20
        pub fn write(self: *Self, bytes: []const u8) !void {
            return self.writeFn(self, bytes);
        }

        pub fn writeByte(self: *Self, byte: u8) !void {
            const slice = (*[1]u8)(&byte)[0..];
  20a2e0:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  20a2e5:	48 89 44 24 20       	mov    QWORD PTR [rsp+0x20],rax
  20a2ea:	48 c7 44 24 28 01 00 	mov    QWORD PTR [rsp+0x28],0x1
  20a2f1:	00 00 
            return self.writeFn(self, slice);
  20a2f3:	4c 89 e7             	mov    rdi,r12
  20a2f6:	48 8d 74 24 20       	lea    rsi,[rsp+0x20]
  20a2fb:	41 ff 14 24          	call   QWORD PTR [r12]
  20a2ff:	41 89 c7             	mov    r15d,eax
                                    try out_stream.writeByte(' ');
  20a302:	66 45 85 ff          	test   r15w,r15w
  20a306:	0f 85 29 02 00 00    	jne    20a535 <dumpCurrentStackTrace+0x1655>
  20a30c:	48 83 c3 01          	add    rbx,0x1
                                while (col_i < line_info.column) : (col_i += 1) {
  20a310:	48 3b 5c 24 78       	cmp    rbx,QWORD PTR [rsp+0x78]
  20a315:	72 c4                	jb     20a2db <dumpCurrentStackTrace+0x13fb>
            return self.writeFn(self, bytes);
  20a317:	4c 89 e7             	mov    rdi,r12
  20a31a:	48 8d 35 d7 68 01 00 	lea    rsi,[rip+0x168d7]        # 220bf8 <__unnamed_34>
  20a321:	41 ff 14 24          	call   QWORD PTR [r12]
  20a325:	41 89 c7             	mov    r15d,eax
  20a328:	66 45 85 ff          	test   r15w,r15w
  20a32c:	0f 84 cf 00 00 00    	je     20a401 <dumpCurrentStackTrace+0x1521>
  20a332:	e9 39 02 00 00       	jmp    20a570 <dumpCurrentStackTrace+0x1690>
  20a337:	48 83 f9 4b          	cmp    rcx,0x4b
  20a33b:	0f 85 7a f6 ff ff    	jne    2099bb <dumpCurrentStackTrace+0xadb>
  20a341:	e9 6b f6 ff ff       	jmp    2099b1 <dumpCurrentStackTrace+0xad1>
        const bytes = @sliceToBytes(memory);
  20a346:	48 8b 84 24 98 00 00 	mov    rax,QWORD PTR [rsp+0x98]
  20a34d:	00 
        if (bytes.len == 0) return;
  20a34e:	48 85 c0             	test   rax,rax
  20a351:	0f 84 39 f5 ff ff    	je     209890 <dumpCurrentStackTrace+0x9b0>
  20a357:	48 8b bc 24 a0 00 00 	mov    rdi,QWORD PTR [rsp+0xa0]
  20a35e:	00 
        const bytes = @sliceToBytes(memory);
  20a35f:	48 8b 8c 24 90 00 00 	mov    rcx,QWORD PTR [rsp+0x90]
  20a366:	00 
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  20a367:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  20a36b:	48 89 4c 24 20       	mov    QWORD PTR [rsp+0x20],rcx
  20a370:	48 89 44 24 28       	mov    QWORD PTR [rsp+0x28],rax
  20a375:	48 8d 74 24 20       	lea    rsi,[rsp+0x20]
  20a37a:	ff d2                	call   rdx
  20a37c:	c5 7d 6f a4 24 00 01 	vmovdqa ymm12,YMMWORD PTR [rsp+0x100]
  20a383:	00 00 
  20a385:	c5 7d 6f ac 24 e0 00 	vmovdqa ymm13,YMMWORD PTR [rsp+0xe0]
  20a38c:	00 00 
        try printSourceAtAddress(debug_info, out_stream, return_address, tty_color);
  20a38e:	66 45 85 ff          	test   r15w,r15w
  20a392:	0f 84 14 f5 ff ff    	je     2098ac <dumpCurrentStackTrace+0x9cc>
  20a398:	e9 0b 01 00 00       	jmp    20a4a8 <dumpCurrentStackTrace+0x15c8>
  20a39d:	48 8b 4c 24 68       	mov    rcx,QWORD PTR [rsp+0x68]
            var in_file_stream = io.FileInStream.init(&self.self_exe_file);
  20a3a2:	48 89 8c 24 b8 00 00 	mov    QWORD PTR [rsp+0xb8],rcx
  20a3a9:	00 
  20a3aa:	48 8d 05 3f 57 00 00 	lea    rax,[rip+0x573f]        # 20faf0 <FileInStream_readFn>
  20a3b1:	48 89 84 24 c0 00 00 	mov    QWORD PTR [rsp+0xc0],rax
  20a3b8:	00 
  20a3b9:	48 8b b1 a0 00 00 00 	mov    rsi,QWORD PTR [rcx+0xa0]
  20a3c0:	4c 8d 74 24 20       	lea    r14,[rsp+0x20]
            return readStringRaw(self.allocator(), in_stream);
  20a3c5:	4c 89 f7             	mov    rdi,r14
  20a3c8:	48 8d 94 24 c0 00 00 	lea    rdx,[rsp+0xc0]
  20a3cf:	00 
  20a3d0:	4c 89 cb             	mov    rbx,r9
  20a3d3:	c5 f8 77             	vzeroupper 
  20a3d6:	e8 95 8d 00 00       	call   213170 <readStringRaw>
  20a3db:	49 89 d9             	mov    r9,rbx
        return switch (form_value.*) {
  20a3de:	4c 89 f1             	mov    rcx,r14
  20a3e1:	e9 fe f5 ff ff       	jmp    2099e4 <dumpCurrentStackTrace+0xb04>
  20a3e6:	4c 89 e7             	mov    rdi,r12
  20a3e9:	48 8d 35 f8 67 01 00 	lea    rsi,[rip+0x167f8]        # 220be8 <__unnamed_1>
  20a3f0:	41 ff 14 24          	call   QWORD PTR [r12]
  20a3f4:	41 89 c7             	mov    r15d,eax
  20a3f7:	66 45 85 ff          	test   r15w,r15w
  20a3fb:	0f 85 6f 01 00 00    	jne    20a570 <dumpCurrentStackTrace+0x1690>
        const bytes = @sliceToBytes(memory);
  20a401:	48 8b 84 24 98 00 00 	mov    rax,QWORD PTR [rsp+0x98]
  20a408:	00 
        if (bytes.len == 0) return;
  20a409:	48 85 c0             	test   rax,rax
  20a40c:	74 25                	je     20a433 <dumpCurrentStackTrace+0x1553>
  20a40e:	48 8b bc 24 a0 00 00 	mov    rdi,QWORD PTR [rsp+0xa0]
  20a415:	00 
        const bytes = @sliceToBytes(memory);
  20a416:	48 8b 8c 24 90 00 00 	mov    rcx,QWORD PTR [rsp+0x90]
  20a41d:	00 
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  20a41e:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  20a422:	48 89 4c 24 20       	mov    QWORD PTR [rsp+0x20],rcx
  20a427:	48 89 44 24 28       	mov    QWORD PTR [rsp+0x28],rax
  20a42c:	48 8d 74 24 20       	lea    rsi,[rsp+0x20]
  20a431:	ff d2                	call   rdx
  20a433:	48 8b 8c 24 a8 00 00 	mov    rcx,QWORD PTR [rsp+0xa8]
  20a43a:	00 
  20a43b:	48 8b 94 24 b0 00 00 	mov    rdx,QWORD PTR [rsp+0xb0]
  20a442:	00 
  20a443:	c5 7d 6f a4 24 00 01 	vmovdqa ymm12,YMMWORD PTR [rsp+0x100]
  20a44a:	00 00 
  20a44c:	c5 7d 6f ac 24 e0 00 	vmovdqa ymm13,YMMWORD PTR [rsp+0xe0]
  20a453:	00 00 
  20a455:	31 c0                	xor    eax,eax
  20a457:	e9 62 f4 ff ff       	jmp    2098be <dumpCurrentStackTrace+0x9de>
  20a45c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
        const return_address = @intToPtr(*const usize, fp + @sizeOf(usize)).*;
  20a460:	4c 8b 6a 08          	mov    r13,QWORD PTR [rdx+0x8]
                if (return_address == addr) {
  20a464:	49 39 cd             	cmp    r13,rcx
        switch (addr_state) {
  20a467:	0f 84 b3 ed ff ff    	je     209220 <dumpCurrentStackTrace+0x340>
  20a46d:	f6 d0                	not    al
  20a46f:	a8 01                	test   al,0x1
  20a471:	b0 01                	mov    al,0x1
  20a473:	0f 85 a7 ed ff ff    	jne    209220 <dumpCurrentStackTrace+0x340>
    while (fp != 0) : (fp = @intToPtr(*const usize, fp).*) {
  20a479:	48 8b 12             	mov    rdx,QWORD PTR [rdx]
  20a47c:	48 85 d2             	test   rdx,rdx
  20a47f:	75 df                	jne    20a460 <dumpCurrentStackTrace+0x1580>
  20a481:	eb 72                	jmp    20a4f5 <dumpCurrentStackTrace+0x1615>
        const form_value = self.getAttr(id) orelse return error.MissingDebugInfo;
  20a483:	48 8b 05 0e b3 ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffffb30e]        # 205798 <__unnamed_35+0x10>
  20a48a:	48 89 84 24 4e 01 00 	mov    QWORD PTR [rsp+0x14e],rax
  20a491:	00 
  20a492:	c5 fa 6f 05 f0 b2 ff 	vmovdqu xmm0,XMMWORD PTR [rip+0xffffffffffffb2f0]        # 20578a <__unnamed_35+0x2>
  20a499:	ff 
  20a49a:	c5 f9 7f 84 24 40 01 	vmovdqa XMMWORD PTR [rsp+0x140],xmm0
  20a4a1:	00 00 
  20a4a3:	66 41 bf 22 00       	mov    r15w,0x22
            return std.fmt.format(self, Error, self.writeFn, format, args);
  20a4a8:	49 8b 1c 24          	mov    rbx,QWORD PTR [r12]
                        try output(context, fmt[start_index..i]);
  20a4ac:	48 8d 35 75 68 01 00 	lea    rsi,[rip+0x16875]        # 220d28 <__unnamed_36>
  20a4b3:	4c 89 e7             	mov    rdi,r12
  20a4b6:	c5 f8 77             	vzeroupper 
  20a4b9:	ff d3                	call   rbx
  20a4bb:	66 85 c0             	test   ax,ax
  20a4be:	75 35                	jne    20a4f5 <dumpCurrentStackTrace+0x1615>
        stderr.print("Unable to dump stack trace: {}\n", @errorName(err)) catch return;
  20a4c0:	49 0f bf c7          	movsx  rax,r15w
  20a4c4:	48 c1 e0 04          	shl    rax,0x4
  20a4c8:	48 8d 0d 31 3b 01 00 	lea    rcx,[rip+0x13b31]        # 21e000 <raw+0xf68>
                const casted_value = ([]const u8)(value);
  20a4cf:	c5 f8 10 04 08       	vmovups xmm0,XMMWORD PTR [rax+rcx*1]
  20a4d4:	c5 f8 29 44 24 20    	vmovaps XMMWORD PTR [rsp+0x20],xmm0
  20a4da:	48 8d 74 24 20       	lea    rsi,[rsp+0x20]
                return output(context, casted_value);
  20a4df:	4c 89 e7             	mov    rdi,r12
  20a4e2:	ff d3                	call   rbx
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  20a4e4:	66 85 c0             	test   ax,ax
  20a4e7:	75 0c                	jne    20a4f5 <dumpCurrentStackTrace+0x1615>
        try output(context, fmt[start_index..]);
  20a4e9:	48 8d 35 48 68 01 00 	lea    rsi,[rip+0x16848]        # 220d38 <__unnamed_37>
  20a4f0:	4c 89 e7             	mov    rdi,r12
  20a4f3:	ff d3                	call   rbx
    const stderr = getStderrStream() catch return;
  20a4f5:	48 8d 65 d8          	lea    rsp,[rbp-0x28]
  20a4f9:	5b                   	pop    rbx
  20a4fa:	41 5c                	pop    r12
  20a4fc:	41 5d                	pop    r13
  20a4fe:	41 5e                	pop    r14
  20a500:	41 5f                	pop    r15
  20a502:	5d                   	pop    rbp
  20a503:	c5 f8 77             	vzeroupper 
  20a506:	c3                   	ret    
  20a507:	49 89 dc             	mov    r12,rbx
        const bytes = @sliceToBytes(memory);
  20a50a:	48 8b 84 24 98 00 00 	mov    rax,QWORD PTR [rsp+0x98]
  20a511:	00 
        if (bytes.len == 0) return;
  20a512:	48 85 c0             	test   rax,rax
  20a515:	75 2f                	jne    20a546 <dumpCurrentStackTrace+0x1666>
  20a517:	eb 8f                	jmp    20a4a8 <dumpCurrentStackTrace+0x15c8>
  20a519:	4c 8b 64 24 70       	mov    r12,QWORD PTR [rsp+0x70]
        const bytes = @sliceToBytes(memory);
  20a51e:	48 8b 84 24 98 00 00 	mov    rax,QWORD PTR [rsp+0x98]
  20a525:	00 
        if (bytes.len == 0) return;
  20a526:	48 85 c0             	test   rax,rax
  20a529:	75 1b                	jne    20a546 <dumpCurrentStackTrace+0x1666>
  20a52b:	e9 78 ff ff ff       	jmp    20a4a8 <dumpCurrentStackTrace+0x15c8>
  20a530:	4c 8b 64 24 70       	mov    r12,QWORD PTR [rsp+0x70]
        const bytes = @sliceToBytes(memory);
  20a535:	48 8b 84 24 98 00 00 	mov    rax,QWORD PTR [rsp+0x98]
  20a53c:	00 
        if (bytes.len == 0) return;
  20a53d:	48 85 c0             	test   rax,rax
  20a540:	0f 84 62 ff ff ff    	je     20a4a8 <dumpCurrentStackTrace+0x15c8>
  20a546:	48 8b bc 24 a0 00 00 	mov    rdi,QWORD PTR [rsp+0xa0]
  20a54d:	00 
        const bytes = @sliceToBytes(memory);
  20a54e:	48 8b 8c 24 90 00 00 	mov    rcx,QWORD PTR [rsp+0x90]
  20a555:	00 
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  20a556:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  20a55a:	48 89 4c 24 20       	mov    QWORD PTR [rsp+0x20],rcx
  20a55f:	48 89 44 24 28       	mov    QWORD PTR [rsp+0x28],rax
  20a564:	48 8d 74 24 20       	lea    rsi,[rsp+0x20]
  20a569:	ff d2                	call   rdx
  20a56b:	e9 38 ff ff ff       	jmp    20a4a8 <dumpCurrentStackTrace+0x15c8>
        const bytes = @sliceToBytes(memory);
  20a570:	48 8b 84 24 98 00 00 	mov    rax,QWORD PTR [rsp+0x98]
  20a577:	00 
        if (bytes.len == 0) return;
  20a578:	48 85 c0             	test   rax,rax
  20a57b:	74 25                	je     20a5a2 <dumpCurrentStackTrace+0x16c2>
  20a57d:	48 8b bc 24 a0 00 00 	mov    rdi,QWORD PTR [rsp+0xa0]
  20a584:	00 
        const bytes = @sliceToBytes(memory);
  20a585:	48 8b 8c 24 90 00 00 	mov    rcx,QWORD PTR [rsp+0x90]
  20a58c:	00 
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  20a58d:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  20a591:	48 89 4c 24 20       	mov    QWORD PTR [rsp+0x20],rcx
  20a596:	48 89 44 24 28       	mov    QWORD PTR [rsp+0x28],rax
  20a59b:	48 8d 74 24 20       	lea    rsi,[rsp+0x20]
  20a5a0:	ff d2                	call   rdx
  20a5a2:	4c 8b 64 24 70       	mov    r12,QWORD PTR [rsp+0x70]
  20a5a7:	e9 fc fe ff ff       	jmp    20a4a8 <dumpCurrentStackTrace+0x15c8>
  20a5ac:	48 c7 c0 fe ff ff ff 	mov    rax,0xfffffffffffffffe
        const this_key = ptr[0..line_i];
        if (!mem.eql(u8, key, this_key)) continue;

        var end_i: usize = line_i;
        while (ptr[end_i] != 0) : (end_i += 1) {}
  20a5b3:	80 7c 06 11 00       	cmp    BYTE PTR [rsi+rax*1+0x11],0x0
  20a5b8:	48 8d 40 01          	lea    rax,[rax+0x1]
  20a5bc:	75 f5                	jne    20a5b3 <dumpCurrentStackTrace+0x16d3>
  20a5be:	c6 44 24 07 01       	mov    BYTE PTR [rsp+0x7],0x1
        const addr = @ptrToInt(self.buffer.ptr) + self.end_index;
        const rem = @rem(addr, alignment);
        const march_forward_bytes = if (rem == 0) 0 else (alignment - rem);
        const adjusted_index = self.end_index + march_forward_bytes;
        const new_end_index = adjusted_index + n;
        if (new_end_index > self.buffer.len) {
  20a5c3:	48 3d 81 00 00 00    	cmp    rax,0x81
        if (n == 0) {
  20a5c9:	0f 83 ce eb ff ff    	jae    20919d <dumpCurrentStackTrace+0x2bd>
  20a5cf:	e9 e9 eb ff ff       	jmp    2091bd <dumpCurrentStackTrace+0x2dd>
  20a5d4:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20a5db:	00 00 00 00 00 

000000000020a5e0 <BenchmarkFramework_report>:
            @intToFloat(f64, run_time_ns)/@intToFloat(f64, ns_per_s),
  20a5e0:	41 57                	push   r15
  20a5e2:	41 56                	push   r14
  20a5e4:	53                   	push   rbx
  20a5e5:	48 83 ec 70          	sub    rsp,0x70
  20a5e9:	c4 e1 f9 6e c7       	vmovq  xmm0,rdi
  20a5ee:	c5 f9 6f 0d aa c4 ff 	vmovdqa xmm1,XMMWORD PTR [rip+0xffffffffffffc4aa]        # 206aa0 <__unnamed_606+0x14>
  20a5f5:	ff 
  20a5f6:	c5 f9 62 c1          	vpunpckldq xmm0,xmm0,xmm1
  20a5fa:	c5 f9 28 15 9e c9 ff 	vmovapd xmm2,XMMWORD PTR [rip+0xffffffffffffc99e]        # 206fa0 <__unnamed_573+0x10>
  20a601:	ff 
  20a602:	c5 f9 5c c2          	vsubpd xmm0,xmm0,xmm2
  20a606:	c5 f9 7c c0          	vhaddpd xmm0,xmm0,xmm0
  20a60a:	c5 f9 29 04 24       	vmovapd XMMWORD PTR [rsp],xmm0
  20a60f:	48 89 f3             	mov    rbx,rsi
            @intToFloat(f64, run_time_ns)/@intToFloat(f64, iterations),
  20a612:	c4 e1 f9 6e c3       	vmovq  xmm0,rbx
  20a617:	c5 f9 62 c1          	vpunpckldq xmm0,xmm0,xmm1
  20a61b:	c5 f9 5c c2          	vsubpd xmm0,xmm0,xmm2
  20a61f:	c5 f9 7c c0          	vhaddpd xmm0,xmm0,xmm0
  20a623:	c5 f9 29 44 24 20    	vmovapd XMMWORD PTR [rsp+0x20],xmm0
  20a629:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  20a630:	b0 01                	mov    al,0x1
  20a632:	86 05 d8 69 01 00    	xchg   BYTE PTR [rip+0x169d8],al        # 221010 <stderr_mutex>
  20a638:	84 c0                	test   al,al
  20a63a:	75 f4                	jne    20a630 <BenchmarkFramework_report+0x50>
    if (stderr_stream) |st| {
  20a63c:	4c 8b 3d c5 69 01 00 	mov    r15,QWORD PTR [rip+0x169c5]        # 221008 <stderr_stream>
  20a643:	4d 85 ff             	test   r15,r15
  20a646:	74 09                	je     20a651 <BenchmarkFramework_report+0x71>
  20a648:	4c 8b 35 c1 29 01 00 	mov    r14,QWORD PTR [rip+0x129c1]        # 21d010 <stderr_file_out_stream+0x8>
  20a64f:	eb 34                	jmp    20a685 <BenchmarkFramework_report+0xa5>
        stderr_file = try io.getStdErr();
  20a651:	48 8d 05 a8 29 01 00 	lea    rax,[rip+0x129a8]        # 21d000 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20a658:	48 89 05 a9 29 01 00 	mov    QWORD PTR [rip+0x129a9],rax        # 21d008 <stderr_file_out_stream>
  20a65f:	4c 8d 35 9a 01 00 00 	lea    r14,[rip+0x19a]        # 20a800 <FileOutStream_writeFn>
  20a666:	4c 89 35 a3 29 01 00 	mov    QWORD PTR [rip+0x129a3],r14        # 21d010 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  20a66d:	c7 05 89 29 01 00 02 	mov    DWORD PTR [rip+0x12989],0x2        # 21d000 <stderr_file>
  20a674:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20a677:	4c 8d 3d 92 29 01 00 	lea    r15,[rip+0x12992]        # 21d010 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  20a67e:	4c 89 3d 83 69 01 00 	mov    QWORD PTR [rip+0x16983],r15        # 221008 <stderr_stream>
                        try output(context, fmt[start_index..i]);
  20a685:	48 8d 35 bc 66 01 00 	lea    rsi,[rip+0x166bc]        # 220d48 <__unnamed_38>
  20a68c:	4c 89 ff             	mov    rdi,r15
  20a68f:	41 ff d6             	call   r14
  20a692:	66 85 c0             	test   ax,ax
  20a695:	0f 85 48 01 00 00    	jne    20a7e3 <BenchmarkFramework_report+0x203>
    var buf: [max_int_digits - 1]u8 = undefined;
  20a69b:	c5 fc 10 05 8c c3 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffffc38c]        # 206a2f <__unnamed_3+0x1f>
  20a6a2:	ff 
  20a6a3:	c5 fc 11 44 24 4f    	vmovups YMMWORD PTR [rsp+0x4f],ymm0
  20a6a9:	c5 fd 10 05 5f c3 ff 	vmovupd ymm0,YMMWORD PTR [rip+0xffffffffffffc35f]        # 206a10 <__unnamed_3>
  20a6b0:	ff 
  20a6b1:	c5 fd 11 44 24 30    	vmovupd YMMWORD PTR [rsp+0x30],ymm0
        const digit = a % base;
  20a6b7:	48 bf cd cc cc cc cc 	movabs rdi,0xcccccccccccccccd
  20a6be:	cc cc cc 
  20a6c1:	48 89 da             	mov    rdx,rbx
  20a6c4:	c4 e2 fb f6 cf       	mulx   rcx,rax,rdi
  20a6c9:	c1 e9 02             	shr    ecx,0x2
  20a6cc:	81 e1 fe ff ff 3f    	and    ecx,0x3ffffffe
  20a6d2:	8d 04 89             	lea    eax,[rcx+rcx*4]
  20a6d5:	89 d9                	mov    ecx,ebx
  20a6d7:	29 c1                	sub    ecx,eax
        0...9 => digit + '0',
  20a6d9:	b2 30                	mov    dl,0x30
  20a6db:	80 f9 0a             	cmp    cl,0xa
  20a6de:	72 02                	jb     20a6e2 <BenchmarkFramework_report+0x102>
  20a6e0:	b2 57                	mov    dl,0x57
  20a6e2:	00 ca                	add    dl,cl
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  20a6e4:	88 54 24 6f          	mov    BYTE PTR [rsp+0x6f],dl
        if (a == 0) break;
  20a6e8:	48 83 fb 0a          	cmp    rbx,0xa
  20a6ec:	73 0c                	jae    20a6fa <BenchmarkFramework_report+0x11a>
  20a6ee:	48 8d 44 24 6f       	lea    rax,[rsp+0x6f]
  20a6f3:	b9 40 00 00 00       	mov    ecx,0x40
  20a6f8:	eb 4d                	jmp    20a747 <BenchmarkFramework_report+0x167>
  20a6fa:	b9 40 00 00 00       	mov    ecx,0x40
  20a6ff:	90                   	nop
        a /= base;
  20a700:	48 89 da             	mov    rdx,rbx
  20a703:	c4 e2 fb f6 d7       	mulx   rdx,rax,rdi
  20a708:	48 c1 ea 03          	shr    rdx,0x3
        const digit = a % base;
  20a70c:	c4 e2 fb f6 f7       	mulx   rsi,rax,rdi
  20a711:	c1 ee 02             	shr    esi,0x2
  20a714:	81 e6 fe ff ff 3f    	and    esi,0x3ffffffe
  20a71a:	8d 04 b6             	lea    eax,[rsi+rsi*4]
  20a71d:	89 d6                	mov    esi,edx
  20a71f:	29 c6                	sub    esi,eax
        0...9 => digit + '0',
  20a721:	b0 30                	mov    al,0x30
  20a723:	40 80 fe 0a          	cmp    sil,0xa
  20a727:	72 02                	jb     20a72b <BenchmarkFramework_report+0x14b>
  20a729:	b0 57                	mov    al,0x57
  20a72b:	40 00 f0             	add    al,sil
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  20a72e:	88 44 0c 2e          	mov    BYTE PTR [rsp+rcx*1+0x2e],al
        if (a == 0) break;
  20a732:	48 83 c1 ff          	add    rcx,0xffffffffffffffff
  20a736:	48 83 fb 63          	cmp    rbx,0x63
  20a73a:	48 89 d3             	mov    rbx,rdx
  20a73d:	77 c1                	ja     20a700 <BenchmarkFramework_report+0x120>
        const padded_buf = buf[index - padding ..];
  20a73f:	48 8d 04 0c          	lea    rax,[rsp+rcx*1]
  20a743:	48 83 c0 2f          	add    rax,0x2f
  20a747:	ba 41 00 00 00       	mov    edx,0x41
  20a74c:	48 29 ca             	sub    rdx,rcx
  20a74f:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  20a754:	48 89 54 24 18       	mov    QWORD PTR [rsp+0x18],rdx
  20a759:	48 8d 74 24 10       	lea    rsi,[rsp+0x10]
        return output(context, padded_buf);
  20a75e:	4c 89 ff             	mov    rdi,r15
  20a761:	c5 f8 77             	vzeroupper 
  20a764:	41 ff d6             	call   r14
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  20a767:	66 85 c0             	test   ax,ax
  20a76a:	75 77                	jne    20a7e3 <BenchmarkFramework_report+0x203>
                        try output(context, fmt[start_index..i]);
  20a76c:	48 8d 35 e5 65 01 00 	lea    rsi,[rip+0x165e5]        # 220d58 <__unnamed_39>
  20a773:	4c 89 ff             	mov    rdi,r15
  20a776:	41 ff d6             	call   r14
  20a779:	66 85 c0             	test   ax,ax
  20a77c:	75 65                	jne    20a7e3 <BenchmarkFramework_report+0x203>
  20a77e:	c5 f9 28 04 24       	vmovapd xmm0,XMMWORD PTR [rsp]
  20a783:	c5 fb 5e 05 85 5a ff 	vdivsd xmm0,xmm0,QWORD PTR [rip+0xffffffffffff5a85]        # 200210 <__unnamed_90+0x30>
  20a78a:	ff 
        '.' => try formatFloatDecimal(value, width, context, Errors, output),
  20a78b:	48 8d 3d 9e ca ff ff 	lea    rdi,[rip+0xffffffffffffca9e]        # 207230 <__unnamed_40>
  20a792:	4c 89 fe             	mov    rsi,r15
  20a795:	4c 89 f2             	mov    rdx,r14
  20a798:	e8 23 ca 00 00       	call   2171c0 <formatFloatDecimal>
                    try formatType(args[next_arg], fmt[s..i], context, Errors, output);
  20a79d:	66 85 c0             	test   ax,ax
  20a7a0:	75 41                	jne    20a7e3 <BenchmarkFramework_report+0x203>
                        try output(context, fmt[start_index..i]);
  20a7a2:	48 8d 35 bf 65 01 00 	lea    rsi,[rip+0x165bf]        # 220d68 <__unnamed_41>
  20a7a9:	4c 89 ff             	mov    rdi,r15
  20a7ac:	41 ff d6             	call   r14
  20a7af:	66 85 c0             	test   ax,ax
  20a7b2:	75 2f                	jne    20a7e3 <BenchmarkFramework_report+0x203>
  20a7b4:	c5 f9 28 04 24       	vmovapd xmm0,XMMWORD PTR [rsp]
  20a7b9:	c5 fb 5e 44 24 20    	vdivsd xmm0,xmm0,QWORD PTR [rsp+0x20]
        '.' => try formatFloatDecimal(value, width, context, Errors, output),
  20a7bf:	48 8d 3d 6a ca ff ff 	lea    rdi,[rip+0xffffffffffffca6a]        # 207230 <__unnamed_40>
  20a7c6:	4c 89 fe             	mov    rsi,r15
  20a7c9:	4c 89 f2             	mov    rdx,r14
  20a7cc:	e8 ef c9 00 00       	call   2171c0 <formatFloatDecimal>
                    try formatType(args[next_arg], fmt[s..i], context, Errors, output);
  20a7d1:	66 85 c0             	test   ax,ax
  20a7d4:	75 0d                	jne    20a7e3 <BenchmarkFramework_report+0x203>
        try output(context, fmt[start_index..]);
  20a7d6:	48 8d 35 9b 65 01 00 	lea    rsi,[rip+0x1659b]        # 220d78 <__unnamed_42>
  20a7dd:	4c 89 ff             	mov    rdi,r15
  20a7e0:	41 ff d6             	call   r14
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  20a7e3:	31 c0                	xor    eax,eax
  20a7e5:	86 05 25 68 01 00    	xchg   BYTE PTR [rip+0x16825],al        # 221010 <stderr_mutex>
  20a7eb:	3c 01                	cmp    al,0x1
    if (!ok) {
  20a7ed:	75 0a                	jne    20a7f9 <BenchmarkFramework_report+0x219>
    fn report(pSelf: *Self, run_time_ns: u64, iterations: u64) void {
  20a7ef:	48 83 c4 70          	add    rsp,0x70
  20a7f3:	5b                   	pop    rbx
  20a7f4:	41 5e                	pop    r14
  20a7f6:	41 5f                	pop    r15
  20a7f8:	c3                   	ret    
            @panic("assertion failure");
  20a7f9:	e8 22 e5 ff ff       	call   208d20 <panic>
  20a7fe:	66 90                	xchg   ax,ax

000000000020a800 <FileOutStream_writeFn>:
    fn writeFn(out_stream: *Stream, bytes: []const u8) !void {
  20a800:	53                   	push   rbx
  20a801:	49 89 f0             	mov    r8,rsi
    while (index < bytes.len) {
  20a804:	49 8b 50 08          	mov    rdx,QWORD PTR [r8+0x8]
  20a808:	48 85 d2             	test   rdx,rdx
  20a80b:	0f 84 98 00 00 00    	je     20a8a9 <FileOutStream_writeFn+0xa9>
        return self.file.write(bytes);
  20a811:	48 8b 47 f8          	mov    rax,QWORD PTR [rdi-0x8]
  20a815:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  20a818:	45 31 c9             	xor    r9d,r9d
  20a81b:	41 ba 00 f0 ff 7f    	mov    r10d,0x7ffff000
  20a821:	48 8d 1d 30 5b ff ff 	lea    rbx,[rip+0xffffffffffff5b30]        # 200358 <app_mask+0xd8>
  20a828:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  20a82f:	00 
        const amt_to_write = math.min(bytes.len - index, usize(max_bytes_len));
  20a830:	4c 29 ca             	sub    rdx,r9
    return if (x < y) x else y;
  20a833:	48 81 fa 00 f0 ff 7f 	cmp    rdx,0x7ffff000
  20a83a:	49 0f 43 d2          	cmovae rdx,r10
  20a83e:	49 8b 30             	mov    rsi,QWORD PTR [r8]
        const rc = posix.write(fd, bytes.ptr + index, amt_to_write);
  20a841:	4c 01 ce             	add    rsi,r9
  20a844:	b8 01 00 00 00       	mov    eax,0x1
  20a849:	0f 05                	syscall 
  20a84b:	48 89 c1             	mov    rcx,rax
  20a84e:	48 81 f9 00 f0 ff ff 	cmp    rcx,0xfffffffffffff000
  20a855:	77 39                	ja     20a890 <FileOutStream_writeFn+0x90>
  20a857:	31 d2                	xor    edx,edx
        if (write_err > 0) {
  20a859:	48 83 fa 04          	cmp    rdx,0x4
  20a85d:	74 3d                	je     20a89c <FileOutStream_writeFn+0x9c>
  20a85f:	48 83 fa 59          	cmp    rdx,0x59
  20a863:	77 48                	ja     20a8ad <FileOutStream_writeFn+0xad>
  20a865:	66 b8 07 00          	mov    ax,0x7
  20a869:	48 63 14 93          	movsxd rdx,DWORD PTR [rbx+rdx*4]
  20a86d:	48 01 da             	add    rdx,rbx
  20a870:	ff e2                	jmp    rdx
        index += rc;
  20a872:	49 01 c9             	add    r9,rcx
    while (index < bytes.len) {
  20a875:	49 8b 50 08          	mov    rdx,QWORD PTR [r8+0x8]
  20a879:	31 c0                	xor    eax,eax
  20a87b:	4c 39 ca             	cmp    rdx,r9
  20a87e:	77 b0                	ja     20a830 <FileOutStream_writeFn+0x30>
  20a880:	eb 25                	jmp    20a8a7 <FileOutStream_writeFn+0xa7>
  20a882:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20a889:	1f 84 00 00 00 00 00 
  20a890:	48 89 ca             	mov    rdx,rcx
  20a893:	48 f7 da             	neg    rdx
        if (write_err > 0) {
  20a896:	48 83 fa 04          	cmp    rdx,0x4
  20a89a:	75 c3                	jne    20a85f <FileOutStream_writeFn+0x5f>
    while (index < bytes.len) {
  20a89c:	49 8b 50 08          	mov    rdx,QWORD PTR [r8+0x8]
  20a8a0:	4c 39 ca             	cmp    rdx,r9
  20a8a3:	77 8b                	ja     20a830 <FileOutStream_writeFn+0x30>
  20a8a5:	31 c0                	xor    eax,eax
  20a8a7:	5b                   	pop    rbx
  20a8a8:	c3                   	ret    
  20a8a9:	31 c0                	xor    eax,eax
  20a8ab:	5b                   	pop    rbx
  20a8ac:	c3                   	ret    
        if (write_err > 0) {
  20a8ad:	48 83 fa 7a          	cmp    rdx,0x7a
  20a8b1:	75 06                	jne    20a8b9 <FileOutStream_writeFn+0xb9>
  20a8b3:	66 b8 0a 00          	mov    ax,0xa
  20a8b7:	5b                   	pop    rbx
  20a8b8:	c3                   	ret    
  20a8b9:	66 b8 02 00          	mov    ax,0x2
  20a8bd:	5b                   	pop    rbx
  20a8be:	c3                   	ret    
  20a8bf:	66 b8 0e 00          	mov    ax,0xe
  20a8c3:	5b                   	pop    rbx
  20a8c4:	c3                   	ret    
  20a8c5:	66 b8 0c 00          	mov    ax,0xc
  20a8c9:	5b                   	pop    rbx
  20a8ca:	c3                   	ret    
  20a8cb:	66 b8 08 00          	mov    ax,0x8
  20a8cf:	5b                   	pop    rbx
  20a8d0:	c3                   	ret    
  20a8d1:	66 b8 0b 00          	mov    ax,0xb
  20a8d5:	5b                   	pop    rbx
  20a8d6:	c3                   	ret    
  20a8d7:	66 b8 0d 00          	mov    ax,0xd
  20a8db:	5b                   	pop    rbx
  20a8dc:	c3                   	ret    
  20a8dd:	66 b8 06 00          	mov    ax,0x6
  20a8e1:	5b                   	pop    rbx
  20a8e2:	c3                   	ret    
  20a8e3:	66 b8 09 00          	mov    ax,0x9
  20a8e7:	5b                   	pop    rbx
  20a8e8:	c3                   	ret    
  20a8e9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

000000000020a8f0 <openSelfDebugInfo>:
            return Self{
  20a8f0:	55                   	push   rbp
  20a8f1:	41 57                	push   r15
  20a8f3:	41 56                	push   r14
  20a8f5:	41 55                	push   r13
  20a8f7:	41 54                	push   r12
  20a8f9:	53                   	push   rbx
  20a8fa:	48 81 ec e8 05 00 00 	sub    rsp,0x5e8
  20a901:	c5 f8 57 c0          	vxorps xmm0,xmm0,xmm0
  20a905:	c5 f8 29 84 24 30 04 	vmovaps XMMWORD PTR [rsp+0x430],xmm0
  20a90c:	00 00 
  20a90e:	c5 f8 29 84 24 10 04 	vmovaps XMMWORD PTR [rsp+0x410],xmm0
  20a915:	00 00 
  20a917:	49 89 f4             	mov    r12,rsi
  20a91a:	49 89 fe             	mov    r14,rdi
            const st = try allocator.create(ElfStackTrace{
  20a91d:	c5 fc 10 05 fb aa ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffffaafb]        # 205420 <__unnamed_43>
  20a924:	ff 
  20a925:	c5 fc 11 84 24 70 05 	vmovups YMMWORD PTR [rsp+0x570],ymm0
  20a92c:	00 00 
  20a92e:	48 c7 84 24 40 04 00 	mov    QWORD PTR [rsp+0x440],0x0
  20a935:	00 00 00 00 00 
  20a93a:	c5 fc 10 05 fe aa ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffffaafe]        # 205440 <__unnamed_43+0x20>
  20a941:	ff 
  20a942:	c5 fc 11 84 24 90 05 	vmovups YMMWORD PTR [rsp+0x590],ymm0
  20a949:	00 00 
  20a94b:	48 c7 84 24 20 04 00 	mov    QWORD PTR [rsp+0x420],0x0
  20a952:	00 00 00 00 00 
  20a957:	c5 fe 6f 05 f9 aa ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffffaaf9]        # 205458 <__unnamed_43+0x38>
  20a95e:	ff 
  20a95f:	c5 fe 7f 84 24 a8 05 	vmovdqu YMMWORD PTR [rsp+0x5a8],ymm0
  20a966:	00 00 
  20a968:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  20a96f:	00 
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  20a970:	ba c8 00 00 00       	mov    edx,0xc8
  20a975:	b9 04 00 00 00       	mov    ecx,0x4
  20a97a:	c5 f8 77             	vzeroupper 
  20a97d:	41 ff 14 24          	call   QWORD PTR [r12]
  20a981:	0f b7 84 24 f0 00 00 	movzx  eax,WORD PTR [rsp+0xf0]
  20a988:	00 
  20a989:	66 85 c0             	test   ax,ax
  20a98c:	74 19                	je     20a9a7 <openSelfDebugInfo+0xb7>
  20a98e:	66 41 89 06          	mov    WORD PTR [r14],ax
  20a992:	48 8b 84 24 12 05 00 	mov    rax,QWORD PTR [rsp+0x512]
  20a999:	00 
  20a99a:	48 8b 8c 24 18 05 00 	mov    rcx,QWORD PTR [rsp+0x518]
  20a9a1:	00 
  20a9a2:	e9 60 0c 00 00       	jmp    20b607 <openSelfDebugInfo+0xd17>
        assert(byte_slice.len == byte_count);
  20a9a7:	48 81 bc 24 00 01 00 	cmp    QWORD PTR [rsp+0x100],0xc8
  20a9ae:	00 c8 00 00 00 
    if (!ok) {
  20a9b3:	0f 85 9b 3f 00 00    	jne    20e954 <openSelfDebugInfo+0x4064>
  20a9b9:	48 8b ac 24 f8 00 00 	mov    rbp,QWORD PTR [rsp+0xf8]
  20a9c0:	00 
        ptr.* = init;
  20a9c1:	c5 fc 10 84 24 68 05 	vmovups ymm0,YMMWORD PTR [rsp+0x568]
  20a9c8:	00 00 
  20a9ca:	c5 fe 6f 8c 24 88 05 	vmovdqu ymm1,YMMWORD PTR [rsp+0x588]
  20a9d1:	00 00 
  20a9d3:	c5 fe 6f 94 24 a8 05 	vmovdqu ymm2,YMMWORD PTR [rsp+0x5a8]
  20a9da:	00 00 
  20a9dc:	c5 fe 6f 9c 24 c8 05 	vmovdqu ymm3,YMMWORD PTR [rsp+0x5c8]
  20a9e3:	00 00 
  20a9e5:	c5 fe 7f 5d 60       	vmovdqu YMMWORD PTR [rbp+0x60],ymm3
  20a9ea:	c5 fe 7f 55 40       	vmovdqu YMMWORD PTR [rbp+0x40],ymm2
  20a9ef:	c5 fe 7f 4d 20       	vmovdqu YMMWORD PTR [rbp+0x20],ymm1
  20a9f4:	c5 fc 11 45 00       	vmovups YMMWORD PTR [rbp+0x0],ymm0
  20a9f9:	48 c7 85 80 00 00 00 	mov    QWORD PTR [rbp+0x80],0x0
  20aa00:	00 00 00 00 
  20aa04:	48 8b 84 24 40 04 00 	mov    rax,QWORD PTR [rsp+0x440]
  20aa0b:	00 
  20aa0c:	48 89 85 98 00 00 00 	mov    QWORD PTR [rbp+0x98],rax
  20aa13:	c5 f8 28 84 24 30 04 	vmovaps xmm0,XMMWORD PTR [rsp+0x430]
  20aa1a:	00 00 
  20aa1c:	c5 f8 11 85 88 00 00 	vmovups XMMWORD PTR [rbp+0x88],xmm0
  20aa23:	00 
  20aa24:	4c 89 a5 a0 00 00 00 	mov    QWORD PTR [rbp+0xa0],r12
  20aa2b:	48 8b 84 24 20 04 00 	mov    rax,QWORD PTR [rsp+0x420]
  20aa32:	00 
  20aa33:	48 89 85 b8 00 00 00 	mov    QWORD PTR [rbp+0xb8],rax
  20aa3a:	c5 f9 6f 84 24 10 04 	vmovdqa xmm0,XMMWORD PTR [rsp+0x410]
  20aa41:	00 00 
  20aa43:	c5 fa 7f 85 a8 00 00 	vmovdqu XMMWORD PTR [rbp+0xa8],xmm0
  20aa4a:	00 
  20aa4b:	4c 89 a5 c0 00 00 00 	mov    QWORD PTR [rbp+0xc0],r12
    return error.Unexpected;
}

pub fn openSelfExe() !os.File {
    switch (builtin.os) {
        Os.linux => return os.File.openReadC(c"/proc/self/exe"),
  20aa52:	48 8d 35 57 ca ff ff 	lea    rsi,[rip+0xffffffffffffca57]        # 2074b0 <__unnamed_44>
  20aa59:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  20aa60:	00 
  20aa61:	c5 f8 77             	vzeroupper 
  20aa64:	e8 57 4d 00 00       	call   20f7c0 <File_openReadC>
  20aa69:	48 8b 9c 24 f0 00 00 	mov    rbx,QWORD PTR [rsp+0xf0]
  20aa70:	00 
            st.self_exe_file = try os.openSelfExe();
  20aa71:	66 85 db             	test   bx,bx
  20aa74:	74 3f                	je     20aab5 <openSelfDebugInfo+0x1c5>
        self.freeFn(self, non_const_ptr[0..@sizeOf(@typeOf(ptr).Child)]);
  20aa76:	49 8b 44 24 10       	mov    rax,QWORD PTR [r12+0x10]
  20aa7b:	48 89 ac 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rbp
  20aa82:	00 
  20aa83:	48 c7 84 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],0xc8
  20aa8a:	00 c8 00 00 00 
  20aa8f:	48 8d b4 24 f0 00 00 	lea    rsi,[rsp+0xf0]
  20aa96:	00 
  20aa97:	4c 89 e7             	mov    rdi,r12
  20aa9a:	ff d0                	call   rax
  20aa9c:	66 41 89 1e          	mov    WORD PTR [r14],bx
  20aaa0:	48 8b 84 24 04 05 00 	mov    rax,QWORD PTR [rsp+0x504]
  20aaa7:	00 
  20aaa8:	48 8b 8c 24 0a 05 00 	mov    rcx,QWORD PTR [rsp+0x50a]
  20aaaf:	00 
  20aab0:	e9 52 0b 00 00       	jmp    20b607 <openSelfDebugInfo+0xd17>
  20aab5:	48 c1 eb 20          	shr    rbx,0x20
  20aab9:	89 5d 00             	mov    DWORD PTR [rbp+0x0],ebx
            try st.elf.openFile(allocator, &st.self_exe_file);
  20aabc:	4c 8d 7d 08          	lea    r15,[rbp+0x8]
        elf.auto_close_stream = true;
    }

    /// Call close when done.
    pub fn openFile(elf: *Elf, allocator: *mem.Allocator, file: *os.File) !void {
        elf.allocator = allocator;
  20aac0:	4c 89 65 50          	mov    QWORD PTR [rbp+0x50],r12
        elf.in_file = file;
  20aac4:	48 89 6d 08          	mov    QWORD PTR [rbp+0x8],rbp
        elf.auto_close_stream = false;
  20aac8:	c6 45 10 00          	mov    BYTE PTR [rbp+0x10],0x0

        var file_stream = io.FileInStream.init(elf.in_file);
  20aacc:	48 89 6c 24 50       	mov    QWORD PTR [rsp+0x50],rbp
  20aad1:	48 8d 05 18 50 00 00 	lea    rax,[rip+0x5018]        # 20faf0 <FileInStream_readFn>
  20aad8:	48 89 44 24 58       	mov    QWORD PTR [rsp+0x58],rax
  20aadd:	48 8d 84 24 70 02 00 	lea    rax,[rsp+0x270]
  20aae4:	00 
        const in = &file_stream.stream;

        var magic: [4]u8 = undefined;
        try in.readNoEof(magic[0..]);
  20aae5:	48 89 84 24 d8 03 00 	mov    QWORD PTR [rsp+0x3d8],rax
  20aaec:	00 
  20aaed:	48 c7 84 24 e0 03 00 	mov    QWORD PTR [rsp+0x3e0],0x4
  20aaf4:	00 04 00 00 00 
        return self.file.read(buffer);
  20aaf9:	48 8b 74 24 50       	mov    rsi,QWORD PTR [rsp+0x50]
  20aafe:	48 8d 9c 24 f0 00 00 	lea    rbx,[rsp+0xf0]
  20ab05:	00 
  20ab06:	48 8d 94 24 d8 03 00 	lea    rdx,[rsp+0x3d8]
  20ab0d:	00 
  20ab0e:	48 89 df             	mov    rdi,rbx
  20ab11:	e8 aa 4e 00 00       	call   20f9c0 <File_read>
  20ab16:	44 0f b7 ac 24 f0 00 	movzx  r13d,WORD PTR [rsp+0xf0]
  20ab1d:	00 00 
            const amt_read = try self.read(buf);
  20ab1f:	66 45 85 ed          	test   r13w,r13w
  20ab23:	75 17                	jne    20ab3c <openSelfDebugInfo+0x24c>
  20ab25:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  20ab2c:	00 
  20ab2d:	66 41 bd 1e 00       	mov    r13w,0x1e
            if (amt_read < buf.len) return error.EndOfStream;
  20ab32:	48 3b 84 24 e0 03 00 	cmp    rax,QWORD PTR [rsp+0x3e0]
  20ab39:	00 
  20ab3a:	73 4e                	jae    20ab8a <openSelfDebugInfo+0x29a>
  20ab3c:	66 45 85 ed          	test   r13w,r13w
  20ab40:	0f 84 ec 06 00 00    	je     20b232 <openSelfDebugInfo+0x942>
  20ab46:	48 63 7d 00          	movsxd rdi,DWORD PTR [rbp+0x0]
  20ab4a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
    return asm volatile ("syscall"
  20ab50:	b8 03 00 00 00       	mov    eax,0x3
  20ab55:	0f 05                	syscall 
            switch (err) {
  20ab57:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  20ab5b:	74 f3                	je     20ab50 <openSelfDebugInfo+0x260>
        /// Remove and return the first node in the list.
        ///
        /// Returns:
        ///     A pointer to the first node in the list.
        pub fn popFirst(list: *Self) ?*Node {
            const first = list.first orelse return null;
  20ab5d:	48 8b 05 c4 64 01 00 	mov    rax,QWORD PTR [rip+0x164c4]        # 221028 <emfile_promise_queue>
  20ab64:	48 85 c0             	test   rax,rax
  20ab67:	0f 84 3b 01 00 00    	je     20aca8 <openSelfDebugInfo+0x3b8>
            if (node.prev) |prev_node| {
  20ab6d:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  20ab70:	48 85 c9             	test   rcx,rcx
  20ab73:	0f 84 c4 00 00 00    	je     20ac3d <openSelfDebugInfo+0x34d>
                prev_node.next = node.next;
  20ab79:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  20ab7d:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  20ab81:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20ab85:	e9 be 00 00 00       	jmp    20ac48 <openSelfDebugInfo+0x358>
        if (b[index] != item) return false;
  20ab8a:	80 bc 24 70 02 00 00 	cmp    BYTE PTR [rsp+0x270],0x7f
  20ab91:	7f 
  20ab92:	0f 85 8b 06 00 00    	jne    20b223 <openSelfDebugInfo+0x933>
  20ab98:	80 bc 24 71 02 00 00 	cmp    BYTE PTR [rsp+0x271],0x45
  20ab9f:	45 
  20aba0:	0f 85 7d 06 00 00    	jne    20b223 <openSelfDebugInfo+0x933>
  20aba6:	80 bc 24 72 02 00 00 	cmp    BYTE PTR [rsp+0x272],0x4c
  20abad:	4c 
  20abae:	0f 85 6f 06 00 00    	jne    20b223 <openSelfDebugInfo+0x933>
  20abb4:	80 bc 24 73 02 00 00 	cmp    BYTE PTR [rsp+0x273],0x46
  20abbb:	46 
  20abbc:	0f 85 28 01 00 00    	jne    20acea <openSelfDebugInfo+0x3fa>
  20abc2:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  20abc7:	48 8d 44 24 1f       	lea    rax,[rsp+0x1f]
            try self.readNoEof(result[0..]);
  20abcc:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  20abd3:	00 
  20abd4:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x1
  20abdb:	00 01 00 00 00 
  20abe0:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  20abe7:	00 
  20abe8:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  20abef:	00 
            return self.readFn(self, buffer);
  20abf0:	ff 54 24 58          	call   QWORD PTR [rsp+0x58]
  20abf4:	44 0f b7 ac 24 f0 00 	movzx  r13d,WORD PTR [rsp+0xf0]
  20abfb:	00 00 
            const amt_read = try self.read(buf);
  20abfd:	66 45 85 ed          	test   r13w,r13w
  20ac01:	0f 85 35 ff ff ff    	jne    20ab3c <openSelfDebugInfo+0x24c>
  20ac07:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  20ac0e:	00 
  20ac0f:	66 41 bd 1e 00       	mov    r13w,0x1e
            if (amt_read < buf.len) return error.EndOfStream;
  20ac14:	48 3b 84 24 a0 00 00 	cmp    rax,QWORD PTR [rsp+0xa0]
  20ac1b:	00 
  20ac1c:	0f 82 1a ff ff ff    	jb     20ab3c <openSelfDebugInfo+0x24c>
            return result[0];
  20ac22:	8a 44 24 1f          	mov    al,BYTE PTR [rsp+0x1f]
        if (!mem.eql(u8, magic, "\x7fELF")) return error.InvalidFormat;

        elf.is_64 = switch (try in.readByte()) {
  20ac26:	3c 01                	cmp    al,0x1
  20ac28:	0f 84 d0 00 00 00    	je     20acfe <openSelfDebugInfo+0x40e>
  20ac2e:	3c 02                	cmp    al,0x2
  20ac30:	0f 85 ed 05 00 00    	jne    20b223 <openSelfDebugInfo+0x933>
  20ac36:	b0 01                	mov    al,0x1
  20ac38:	e9 c3 00 00 00       	jmp    20ad00 <openSelfDebugInfo+0x410>
                list.first = node.next;
  20ac3d:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20ac41:	48 89 0d e0 63 01 00 	mov    QWORD PTR [rip+0x163e0],rcx        # 221028 <emfile_promise_queue>
            if (node.next) |next_node| {
  20ac48:	48 85 c9             	test   rcx,rcx
  20ac4b:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  20ac4e:	48 8d 35 db 63 01 00 	lea    rsi,[rip+0x163db]        # 221030 <emfile_promise_queue+0x8>
  20ac55:	48 0f 45 f1          	cmovne rsi,rcx
  20ac59:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  20ac5c:	48 83 05 d4 63 01 00 	add    QWORD PTR [rip+0x163d4],0xffffffffffffffff        # 221038 <emfile_promise_queue+0x10>
  20ac63:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  20ac64:	74 1e                	je     20ac84 <openSelfDebugInfo+0x394>
  20ac66:	48 83 3d ba 63 01 00 	cmp    QWORD PTR [rip+0x163ba],0x0        # 221028 <emfile_promise_queue>
  20ac6d:	00 
  20ac6e:	0f 84 e0 3c 00 00    	je     20e954 <openSelfDebugInfo+0x4064>
  20ac74:	48 8b 0d b5 63 01 00 	mov    rcx,QWORD PTR [rip+0x163b5]        # 221030 <emfile_promise_queue+0x8>
  20ac7b:	48 85 c9             	test   rcx,rcx
  20ac7e:	0f 84 d0 3c 00 00    	je     20e954 <openSelfDebugInfo+0x4064>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  20ac84:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  20ac88:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  20ac8c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  20ac90:	48 89 c1             	mov    rcx,rax
  20ac93:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  20ac97:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  20ac9d:	75 f1                	jne    20ac90 <openSelfDebugInfo+0x3a0>
  20ac9f:	a8 01                	test   al,0x1
  20aca1:	75 05                	jne    20aca8 <openSelfDebugInfo+0x3b8>
  20aca3:	c5 f8 77             	vzeroupper 
  20aca6:	ff 17                	call   QWORD PTR [rdi]
        self.freeFn(self, non_const_ptr[0..@sizeOf(@typeOf(ptr).Child)]);
  20aca8:	49 8b 44 24 10       	mov    rax,QWORD PTR [r12+0x10]
  20acad:	48 89 ac 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rbp
  20acb4:	00 
  20acb5:	48 c7 84 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],0xc8
  20acbc:	00 c8 00 00 00 
  20acc1:	48 8d b4 24 f0 00 00 	lea    rsi,[rsp+0xf0]
  20acc8:	00 
  20acc9:	4c 89 e7             	mov    rdi,r12
  20accc:	c5 f8 77             	vzeroupper 
  20accf:	ff d0                	call   rax
  20acd1:	66 45 89 2e          	mov    WORD PTR [r14],r13w
  20acd5:	48 8b 84 24 f6 04 00 	mov    rax,QWORD PTR [rsp+0x4f6]
  20acdc:	00 
  20acdd:	48 8b 8c 24 fc 04 00 	mov    rcx,QWORD PTR [rsp+0x4fc]
  20ace4:	00 
  20ace5:	e9 1d 09 00 00       	jmp    20b607 <openSelfDebugInfo+0xd17>
  20acea:	66 41 bd 1f 00       	mov    r13w,0x1f
  20acef:	66 45 85 ed          	test   r13w,r13w
  20acf3:	0f 85 4d fe ff ff    	jne    20ab46 <openSelfDebugInfo+0x256>
  20acf9:	e9 34 05 00 00       	jmp    20b232 <openSelfDebugInfo+0x942>
  20acfe:	31 c0                	xor    eax,eax
  20ad00:	88 45 11             	mov    BYTE PTR [rbp+0x11],al
            try self.readNoEof(result[0..]);
  20ad03:	48 8d 44 24 1f       	lea    rax,[rsp+0x1f]
  20ad08:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  20ad0f:	00 
  20ad10:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x1
  20ad17:	00 01 00 00 00 
  20ad1c:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  20ad23:	00 
  20ad24:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  20ad2b:	00 
            return self.readFn(self, buffer);
  20ad2c:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  20ad31:	ff 54 24 58          	call   QWORD PTR [rsp+0x58]
  20ad35:	44 0f b7 ac 24 f0 00 	movzx  r13d,WORD PTR [rsp+0xf0]
  20ad3c:	00 00 
            const amt_read = try self.read(buf);
  20ad3e:	66 45 85 ed          	test   r13w,r13w
  20ad42:	0f 85 f4 fd ff ff    	jne    20ab3c <openSelfDebugInfo+0x24c>
  20ad48:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  20ad4f:	00 
  20ad50:	66 41 bd 1e 00       	mov    r13w,0x1e
            if (amt_read < buf.len) return error.EndOfStream;
  20ad55:	48 3b 84 24 a0 00 00 	cmp    rax,QWORD PTR [rsp+0xa0]
  20ad5c:	00 
  20ad5d:	0f 82 d9 fd ff ff    	jb     20ab3c <openSelfDebugInfo+0x24c>
            return result[0];
  20ad63:	8a 44 24 1f          	mov    al,BYTE PTR [rsp+0x1f]
            1 => false,
            2 => true,
            else => return error.InvalidFormat,
        };

        elf.endian = switch (try in.readByte()) {
  20ad67:	3c 01                	cmp    al,0x1
  20ad69:	74 0c                	je     20ad77 <openSelfDebugInfo+0x487>
  20ad6b:	3c 02                	cmp    al,0x2
  20ad6d:	0f 85 b0 04 00 00    	jne    20b223 <openSelfDebugInfo+0x933>
  20ad73:	31 c0                	xor    eax,eax
  20ad75:	eb 02                	jmp    20ad79 <openSelfDebugInfo+0x489>
  20ad77:	b0 01                	mov    al,0x1
  20ad79:	48 8d 4d 12          	lea    rcx,[rbp+0x12]
  20ad7d:	48 89 4c 24 68       	mov    QWORD PTR [rsp+0x68],rcx
  20ad82:	88 01                	mov    BYTE PTR [rcx],al
            try self.readNoEof(result[0..]);
  20ad84:	48 8d 44 24 1f       	lea    rax,[rsp+0x1f]
  20ad89:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  20ad90:	00 
  20ad91:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x1
  20ad98:	00 01 00 00 00 
  20ad9d:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  20ada4:	00 
  20ada5:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  20adac:	00 
            return self.readFn(self, buffer);
  20adad:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  20adb2:	ff 54 24 58          	call   QWORD PTR [rsp+0x58]
  20adb6:	44 0f b7 ac 24 f0 00 	movzx  r13d,WORD PTR [rsp+0xf0]
  20adbd:	00 00 
            const amt_read = try self.read(buf);
  20adbf:	66 45 85 ed          	test   r13w,r13w
  20adc3:	0f 85 73 fd ff ff    	jne    20ab3c <openSelfDebugInfo+0x24c>
  20adc9:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  20add0:	00 
  20add1:	66 41 bd 1e 00       	mov    r13w,0x1e
            if (amt_read < buf.len) return error.EndOfStream;
  20add6:	48 3b 84 24 a0 00 00 	cmp    rax,QWORD PTR [rsp+0xa0]
  20addd:	00 
  20adde:	0f 82 58 fd ff ff    	jb     20ab3c <openSelfDebugInfo+0x24c>
            2 => builtin.Endian.Big,
            else => return error.InvalidFormat,
        };

        const version_byte = try in.readByte();
        if (version_byte != 1) return error.InvalidFormat;
  20ade4:	80 7c 24 1f 01       	cmp    BYTE PTR [rsp+0x1f],0x1
  20ade9:	0f 85 34 04 00 00    	jne    20b223 <openSelfDebugInfo+0x933>

        // skip over padding
        try elf.in_file.seekForward(9);
  20adef:	49 8b 07             	mov    rax,QWORD PTR [r15]
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  20adf2:	48 63 38             	movsxd rdi,DWORD PTR [rax]
    return asm volatile ("syscall"
  20adf5:	b8 08 00 00 00       	mov    eax,0x8
  20adfa:	be 09 00 00 00       	mov    esi,0x9
  20adff:	ba 01 00 00 00       	mov    edx,0x1
  20ae04:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  20ae06:	48 89 c2             	mov    rdx,rax
  20ae09:	48 f7 da             	neg    rdx
  20ae0c:	31 c9                	xor    ecx,ecx
  20ae0e:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  20ae14:	48 0f 47 ca          	cmova  rcx,rdx
                if (err > 0) {
  20ae18:	48 83 f9 1d          	cmp    rcx,0x1d
  20ae1c:	0f 87 1e 3b 00 00    	ja     20e940 <openSelfDebugInfo+0x4050>
  20ae22:	48 8d 05 97 56 ff ff 	lea    rax,[rip+0xffffffffffff5697]        # 2004c0 <app_mask+0x240>
  20ae29:	48 63 0c 88          	movsxd rcx,DWORD PTR [rax+rcx*4]
  20ae2d:	48 01 c1             	add    rcx,rax
  20ae30:	66 41 bd 02 00       	mov    r13w,0x2
  20ae35:	ff e1                	jmp    rcx
  20ae37:	66 41 bd 20 00       	mov    r13w,0x20
  20ae3c:	66 45 85 ed          	test   r13w,r13w
  20ae40:	0f 85 00 fd ff ff    	jne    20ab46 <openSelfDebugInfo+0x256>
  20ae46:	e9 e7 03 00 00       	jmp    20b232 <openSelfDebugInfo+0x942>

        elf.file_type = switch (try in.readInt(elf.endian, u16)) {
  20ae4b:	8a 45 12             	mov    al,BYTE PTR [rbp+0x12]
  20ae4e:	88 44 24 40          	mov    BYTE PTR [rsp+0x40],al
  20ae52:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
            try self.readNoEof(bytes[0..]);
  20ae57:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  20ae5e:	00 
  20ae5f:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x2
  20ae66:	00 02 00 00 00 
  20ae6b:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  20ae72:	00 
  20ae73:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  20ae7a:	00 
            return self.readFn(self, buffer);
  20ae7b:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  20ae80:	ff 54 24 58          	call   QWORD PTR [rsp+0x58]
  20ae84:	44 0f b7 ac 24 f0 00 	movzx  r13d,WORD PTR [rsp+0xf0]
  20ae8b:	00 00 
            const amt_read = try self.read(buf);
  20ae8d:	66 45 85 ed          	test   r13w,r13w
  20ae91:	0f 85 a5 fc ff ff    	jne    20ab3c <openSelfDebugInfo+0x24c>
  20ae97:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  20ae9e:	00 
  20ae9f:	66 41 bd 1e 00       	mov    r13w,0x1e
            if (amt_read < buf.len) return error.EndOfStream;
  20aea4:	48 3b 84 24 a0 00 00 	cmp    rax,QWORD PTR [rsp+0xa0]
  20aeab:	00 
  20aeac:	0f 82 8a fc ff ff    	jb     20ab3c <openSelfDebugInfo+0x24c>
  20aeb2:	0f b6 44 24 20       	movzx  eax,BYTE PTR [rsp+0x20]
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20aeb7:	0f b6 4c 24 21       	movzx  ecx,BYTE PTR [rsp+0x21]
  20aebc:	89 ca                	mov    edx,ecx
  20aebe:	c1 e2 08             	shl    edx,0x8
  20aec1:	09 c2                	or     edx,eax
                result = (result << 8) | b;
  20aec3:	c1 e0 08             	shl    eax,0x8
  20aec6:	09 c8                	or     eax,ecx
    switch (endian) {
  20aec8:	f6 44 24 40 01       	test   BYTE PTR [rsp+0x40],0x1
  20aecd:	66 0f 45 c2          	cmovne ax,dx
  20aed1:	83 c0 ff             	add    eax,0xffffffff
  20aed4:	0f b7 c8             	movzx  ecx,ax
  20aed7:	83 f9 03             	cmp    ecx,0x3
  20aeda:	0f 87 43 03 00 00    	ja     20b223 <openSelfDebugInfo+0x933>
  20aee0:	24 03                	and    al,0x3
  20aee2:	88 45 13             	mov    BYTE PTR [rbp+0x13],al
            3 => FileType.Shared,
            4 => FileType.Core,
            else => return error.InvalidFormat,
        };

        elf.arch = switch (try in.readInt(elf.endian, u16)) {
  20aee5:	8a 45 12             	mov    al,BYTE PTR [rbp+0x12]
            try self.readNoEof(bytes[0..]);
  20aee8:	88 44 24 40          	mov    BYTE PTR [rsp+0x40],al
  20aeec:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  20aef1:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  20aef8:	00 
  20aef9:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x2
  20af00:	00 02 00 00 00 
  20af05:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  20af0c:	00 
  20af0d:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  20af14:	00 
            return self.readFn(self, buffer);
  20af15:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  20af1a:	ff 54 24 58          	call   QWORD PTR [rsp+0x58]
  20af1e:	44 0f b7 ac 24 f0 00 	movzx  r13d,WORD PTR [rsp+0xf0]
  20af25:	00 00 
            const amt_read = try self.read(buf);
  20af27:	66 45 85 ed          	test   r13w,r13w
  20af2b:	0f 85 0b fc ff ff    	jne    20ab3c <openSelfDebugInfo+0x24c>
  20af31:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  20af38:	00 
  20af39:	66 41 bd 1e 00       	mov    r13w,0x1e
            if (amt_read < buf.len) return error.EndOfStream;
  20af3e:	48 3b 84 24 a0 00 00 	cmp    rax,QWORD PTR [rsp+0xa0]
  20af45:	00 
  20af46:	0f 82 f0 fb ff ff    	jb     20ab3c <openSelfDebugInfo+0x24c>
  20af4c:	0f b6 44 24 20       	movzx  eax,BYTE PTR [rsp+0x20]
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20af51:	0f b6 4c 24 21       	movzx  ecx,BYTE PTR [rsp+0x21]
  20af56:	89 ca                	mov    edx,ecx
  20af58:	c1 e2 08             	shl    edx,0x8
  20af5b:	09 c2                	or     edx,eax
                result = (result << 8) | b;
  20af5d:	c1 e0 08             	shl    eax,0x8
  20af60:	09 c8                	or     eax,ecx
    switch (endian) {
  20af62:	f6 44 24 40 01       	test   BYTE PTR [rsp+0x40],0x1
  20af67:	66 0f 45 c2          	cmovne ax,dx
  20af6b:	8d 48 fe             	lea    ecx,[rax-0x2]
  20af6e:	0f b7 c9             	movzx  ecx,cx
  20af71:	83 f9 3c             	cmp    ecx,0x3c
  20af74:	77 1b                	ja     20af91 <openSelfDebugInfo+0x6a1>
  20af76:	31 c0                	xor    eax,eax
  20af78:	48 8d 15 b9 55 ff ff 	lea    rdx,[rip+0xffffffffffff55b9]        # 200538 <app_mask+0x2b8>
  20af7f:	48 63 0c 8a          	movsxd rcx,DWORD PTR [rdx+rcx*4]
  20af83:	48 01 d1             	add    rcx,rdx
  20af86:	66 41 bd 1f 00       	mov    r13w,0x1f
  20af8b:	ff e1                	jmp    rcx
  20af8d:	b0 01                	mov    al,0x1
  20af8f:	eb 28                	jmp    20afb9 <openSelfDebugInfo+0x6c9>
  20af91:	0f b7 c0             	movzx  eax,ax
  20af94:	3d b7 00 00 00       	cmp    eax,0xb7
  20af99:	0f 85 84 02 00 00    	jne    20b223 <openSelfDebugInfo+0x933>
  20af9f:	b0 08                	mov    al,0x8
  20afa1:	eb 16                	jmp    20afb9 <openSelfDebugInfo+0x6c9>
  20afa3:	b0 07                	mov    al,0x7
  20afa5:	eb 12                	jmp    20afb9 <openSelfDebugInfo+0x6c9>
  20afa7:	b0 06                	mov    al,0x6
  20afa9:	eb 0e                	jmp    20afb9 <openSelfDebugInfo+0x6c9>
  20afab:	b0 02                	mov    al,0x2
  20afad:	eb 0a                	jmp    20afb9 <openSelfDebugInfo+0x6c9>
  20afaf:	b0 04                	mov    al,0x4
  20afb1:	eb 06                	jmp    20afb9 <openSelfDebugInfo+0x6c9>
  20afb3:	b0 03                	mov    al,0x3
  20afb5:	eb 02                	jmp    20afb9 <openSelfDebugInfo+0x6c9>
  20afb7:	b0 05                	mov    al,0x5
  20afb9:	24 0f                	and    al,0xf
  20afbb:	88 45 14             	mov    BYTE PTR [rbp+0x14],al
            0x3E => Arch.x86_64,
            0xb7 => Arch.AArch64,
            else => return error.InvalidFormat,
        };

        const elf_version = try in.readInt(elf.endian, u32);
  20afbe:	8a 45 12             	mov    al,BYTE PTR [rbp+0x12]
            try self.readNoEof(bytes[0..]);
  20afc1:	88 44 24 40          	mov    BYTE PTR [rsp+0x40],al
  20afc5:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  20afca:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  20afd1:	00 
  20afd2:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x4
  20afd9:	00 04 00 00 00 
  20afde:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  20afe5:	00 
  20afe6:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  20afed:	00 
            return self.readFn(self, buffer);
  20afee:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  20aff3:	ff 54 24 58          	call   QWORD PTR [rsp+0x58]
  20aff7:	44 0f b7 ac 24 f0 00 	movzx  r13d,WORD PTR [rsp+0xf0]
  20affe:	00 00 
            const amt_read = try self.read(buf);
  20b000:	66 45 85 ed          	test   r13w,r13w
  20b004:	0f 85 32 fb ff ff    	jne    20ab3c <openSelfDebugInfo+0x24c>
  20b00a:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  20b011:	00 
  20b012:	66 41 bd 1e 00       	mov    r13w,0x1e
            if (amt_read < buf.len) return error.EndOfStream;
  20b017:	48 3b 84 24 a0 00 00 	cmp    rax,QWORD PTR [rsp+0xa0]
  20b01e:	00 
  20b01f:	0f 82 17 fb ff ff    	jb     20ab3c <openSelfDebugInfo+0x24c>
  20b025:	0f b6 44 24 20       	movzx  eax,BYTE PTR [rsp+0x20]
  20b02a:	0f b6 4c 24 21       	movzx  ecx,BYTE PTR [rsp+0x21]
  20b02f:	f6 44 24 40 01       	test   BYTE PTR [rsp+0x40],0x1
  20b034:	74 23                	je     20b059 <openSelfDebugInfo+0x769>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20b036:	c1 e1 08             	shl    ecx,0x8
  20b039:	09 c1                	or     ecx,eax
  20b03b:	0f b6 54 24 22       	movzx  edx,BYTE PTR [rsp+0x22]
  20b040:	c1 e2 10             	shl    edx,0x10
  20b043:	09 ca                	or     edx,ecx
  20b045:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  20b04a:	c1 e0 18             	shl    eax,0x18
  20b04d:	09 d0                	or     eax,edx
        if (elf_version != 1) return error.InvalidFormat;
  20b04f:	83 f8 01             	cmp    eax,0x1
  20b052:	74 27                	je     20b07b <openSelfDebugInfo+0x78b>
  20b054:	e9 ca 01 00 00       	jmp    20b223 <openSelfDebugInfo+0x933>
                result = (result << 8) | b;
  20b059:	c1 e0 08             	shl    eax,0x8
  20b05c:	09 c8                	or     eax,ecx
  20b05e:	c1 e0 08             	shl    eax,0x8
  20b061:	0f b6 4c 24 22       	movzx  ecx,BYTE PTR [rsp+0x22]
  20b066:	09 c1                	or     ecx,eax
  20b068:	c1 e1 08             	shl    ecx,0x8
  20b06b:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  20b070:	09 c8                	or     eax,ecx
  20b072:	83 f8 01             	cmp    eax,0x1
  20b075:	0f 85 a8 01 00 00    	jne    20b223 <openSelfDebugInfo+0x933>
  20b07b:	8a 45 12             	mov    al,BYTE PTR [rbp+0x12]

        if (elf.is_64) {
  20b07e:	88 44 24 40          	mov    BYTE PTR [rsp+0x40],al
  20b082:	80 7d 11 01          	cmp    BYTE PTR [rbp+0x11],0x1
  20b086:	0f 85 e3 2b 00 00    	jne    20dc6f <openSelfDebugInfo+0x337f>
            elf.entry_addr = try in.readInt(elf.endian, u64);
  20b08c:	0f b6 54 24 40       	movzx  edx,BYTE PTR [rsp+0x40]
  20b091:	48 8d bc 24 68 04 00 	lea    rdi,[rsp+0x468]
  20b098:	00 
  20b099:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  20b09e:	e8 ed 47 00 00       	call   20f890 <InStream(ReadError)_readInt.30>
  20b0a3:	44 0f b7 ac 24 68 04 	movzx  r13d,WORD PTR [rsp+0x468]
  20b0aa:	00 00 
  20b0ac:	66 45 85 ed          	test   r13w,r13w
  20b0b0:	0f 85 86 fa ff ff    	jne    20ab3c <openSelfDebugInfo+0x24c>
  20b0b6:	48 8b 84 24 70 04 00 	mov    rax,QWORD PTR [rsp+0x470]
  20b0bd:	00 
  20b0be:	48 89 45 18          	mov    QWORD PTR [rbp+0x18],rax
            elf.program_header_offset = try in.readInt(elf.endian, u64);
  20b0c2:	0f b6 55 12          	movzx  edx,BYTE PTR [rbp+0x12]
  20b0c6:	48 8d bc 24 c0 02 00 	lea    rdi,[rsp+0x2c0]
  20b0cd:	00 
  20b0ce:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  20b0d3:	e8 b8 47 00 00       	call   20f890 <InStream(ReadError)_readInt.30>
  20b0d8:	44 0f b7 ac 24 c0 02 	movzx  r13d,WORD PTR [rsp+0x2c0]
  20b0df:	00 00 
  20b0e1:	66 45 85 ed          	test   r13w,r13w
  20b0e5:	0f 85 51 fa ff ff    	jne    20ab3c <openSelfDebugInfo+0x24c>
  20b0eb:	48 8b 84 24 c8 02 00 	mov    rax,QWORD PTR [rsp+0x2c8]
  20b0f2:	00 
  20b0f3:	48 89 45 20          	mov    QWORD PTR [rbp+0x20],rax
            elf.section_header_offset = try in.readInt(elf.endian, u64);
  20b0f7:	0f b6 55 12          	movzx  edx,BYTE PTR [rbp+0x12]
  20b0fb:	48 8d bc 24 88 02 00 	lea    rdi,[rsp+0x288]
  20b102:	00 
  20b103:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  20b108:	e8 83 47 00 00       	call   20f890 <InStream(ReadError)_readInt.30>
  20b10d:	44 0f b7 ac 24 88 02 	movzx  r13d,WORD PTR [rsp+0x288]
  20b114:	00 00 
  20b116:	66 45 85 ed          	test   r13w,r13w
  20b11a:	0f 85 1c fa ff ff    	jne    20ab3c <openSelfDebugInfo+0x24c>
  20b120:	48 8b 84 24 90 02 00 	mov    rax,QWORD PTR [rsp+0x290]
  20b127:	00 
  20b128:	48 89 45 28          	mov    QWORD PTR [rbp+0x28],rax
            elf.program_header_offset = u64(try in.readInt(elf.endian, u32));
            elf.section_header_offset = u64(try in.readInt(elf.endian, u32));
        }

        // skip over flags
        try elf.in_file.seekForward(4);
  20b12c:	49 8b 07             	mov    rax,QWORD PTR [r15]
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  20b12f:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  20b132:	b8 08 00 00 00       	mov    eax,0x8
  20b137:	be 04 00 00 00       	mov    esi,0x4
  20b13c:	ba 01 00 00 00       	mov    edx,0x1
  20b141:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  20b143:	48 89 c2             	mov    rdx,rax
  20b146:	48 f7 da             	neg    rdx
  20b149:	31 c9                	xor    ecx,ecx
  20b14b:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  20b151:	48 0f 47 ca          	cmova  rcx,rdx
  20b155:	48 83 f9 1d          	cmp    rcx,0x1d
  20b159:	0f 87 e1 37 00 00    	ja     20e940 <openSelfDebugInfo+0x4050>
  20b15f:	48 8d 05 c6 54 ff ff 	lea    rax,[rip+0xffffffffffff54c6]        # 20062c <app_mask+0x3ac>
  20b166:	48 63 0c 88          	movsxd rcx,DWORD PTR [rax+rcx*4]
  20b16a:	48 01 c1             	add    rcx,rax
  20b16d:	66 41 bd 02 00       	mov    r13w,0x2
  20b172:	ff e1                	jmp    rcx

        const header_size = try in.readInt(elf.endian, u16);
  20b174:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  20b179:	8a 00                	mov    al,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  20b17b:	88 44 24 40          	mov    BYTE PTR [rsp+0x40],al
  20b17f:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  20b184:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  20b18b:	00 
  20b18c:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x2
  20b193:	00 02 00 00 00 
  20b198:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  20b19f:	00 
  20b1a0:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  20b1a7:	00 
            return self.readFn(self, buffer);
  20b1a8:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  20b1ad:	ff 54 24 58          	call   QWORD PTR [rsp+0x58]
  20b1b1:	44 0f b7 ac 24 f0 00 	movzx  r13d,WORD PTR [rsp+0xf0]
  20b1b8:	00 00 
            const amt_read = try self.read(buf);
  20b1ba:	66 45 85 ed          	test   r13w,r13w
  20b1be:	0f 85 78 f9 ff ff    	jne    20ab3c <openSelfDebugInfo+0x24c>
  20b1c4:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  20b1cb:	00 
  20b1cc:	66 41 bd 1e 00       	mov    r13w,0x1e
            if (amt_read < buf.len) return error.EndOfStream;
  20b1d1:	48 3b 84 24 a0 00 00 	cmp    rax,QWORD PTR [rsp+0xa0]
  20b1d8:	00 
  20b1d9:	0f 82 5d f9 ff ff    	jb     20ab3c <openSelfDebugInfo+0x24c>
  20b1df:	0f b6 44 24 20       	movzx  eax,BYTE PTR [rsp+0x20]
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20b1e4:	0f b6 4c 24 21       	movzx  ecx,BYTE PTR [rsp+0x21]
  20b1e9:	89 ca                	mov    edx,ecx
  20b1eb:	c1 e2 08             	shl    edx,0x8
  20b1ee:	09 c2                	or     edx,eax
                result = (result << 8) | b;
  20b1f0:	c1 e0 08             	shl    eax,0x8
  20b1f3:	09 c8                	or     eax,ecx
    switch (endian) {
  20b1f5:	f6 44 24 40 01       	test   BYTE PTR [rsp+0x40],0x1
  20b1fa:	66 0f 45 c2          	cmovne ax,dx
        if ((elf.is_64 and header_size != 64) or (!elf.is_64 and header_size != 52)) {
  20b1fe:	8a 4d 11             	mov    cl,BYTE PTR [rbp+0x11]
  20b201:	80 f9 01             	cmp    cl,0x1
  20b204:	75 08                	jne    20b20e <openSelfDebugInfo+0x91e>
  20b206:	0f b7 d0             	movzx  edx,ax
  20b209:	83 fa 40             	cmp    edx,0x40
  20b20c:	75 15                	jne    20b223 <openSelfDebugInfo+0x933>
  20b20e:	0f b7 c0             	movzx  eax,ax
  20b211:	83 f8 34             	cmp    eax,0x34
  20b214:	0f 84 65 2c 00 00    	je     20de7f <openSelfDebugInfo+0x358f>
  20b21a:	80 f1 01             	xor    cl,0x1
  20b21d:	0f 84 5c 2c 00 00    	je     20de7f <openSelfDebugInfo+0x358f>
  20b223:	66 41 bd 1f 00       	mov    r13w,0x1f
  20b228:	66 45 85 ed          	test   r13w,r13w
  20b22c:	0f 85 14 f9 ff ff    	jne    20ab46 <openSelfDebugInfo+0x256>
            st.debug_info = (try st.elf.findSection(".debug_info")) orelse return error.MissingDebugInfo;
  20b232:	48 8d 15 2f 59 01 00 	lea    rdx,[rip+0x1592f]        # 220b68 <__unnamed_45>
  20b239:	48 8d bc 24 40 03 00 	lea    rdi,[rsp+0x340]
  20b240:	00 
  20b241:	4c 89 fe             	mov    rsi,r15
  20b244:	c5 f8 77             	vzeroupper 
  20b247:	e8 34 43 00 00       	call   20f580 <Elf_findSection>
  20b24c:	66 83 bc 24 40 03 00 	cmp    WORD PTR [rsp+0x340],0x0
  20b253:	00 00 
  20b255:	0f 84 7f 00 00 00    	je     20b2da <openSelfDebugInfo+0x9ea>
        const bytes = @sliceToBytes(memory);
  20b25b:	48 8b 45 48          	mov    rax,QWORD PTR [rbp+0x48]
  20b25f:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  20b263:	74 26                	je     20b28b <openSelfDebugInfo+0x99b>
  20b265:	48 8b 7d 50          	mov    rdi,QWORD PTR [rbp+0x50]
        const bytes = @sliceToBytes(memory);
  20b269:	48 8b 4d 40          	mov    rcx,QWORD PTR [rbp+0x40]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  20b26d:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  20b271:	48 89 8c 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rcx
  20b278:	00 
  20b279:	48 89 84 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],rax
  20b280:	00 
  20b281:	48 8d b4 24 f0 00 00 	lea    rsi,[rsp+0xf0]
  20b288:	00 
  20b289:	ff d2                	call   rdx
    }

    pub fn close(elf: *Elf) void {
        elf.allocator.free(elf.section_headers);

        if (elf.auto_close_stream) elf.in_file.close();
  20b28b:	80 7d 10 01          	cmp    BYTE PTR [rbp+0x10],0x1
  20b28f:	0f 85 90 02 00 00    	jne    20b525 <openSelfDebugInfo+0xc35>
  20b295:	49 8b 07             	mov    rax,QWORD PTR [r15]
  20b298:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  20b29b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
    return asm volatile ("syscall"
  20b2a0:	b8 03 00 00 00       	mov    eax,0x3
  20b2a5:	0f 05                	syscall 
            switch (err) {
  20b2a7:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  20b2ab:	74 f3                	je     20b2a0 <openSelfDebugInfo+0x9b0>
            const first = list.first orelse return null;
  20b2ad:	48 8b 05 74 5d 01 00 	mov    rax,QWORD PTR [rip+0x15d74]        # 221028 <emfile_promise_queue>
  20b2b4:	48 85 c0             	test   rax,rax
  20b2b7:	0f 84 68 02 00 00    	je     20b525 <openSelfDebugInfo+0xc35>
            if (node.prev) |prev_node| {
  20b2bd:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  20b2c0:	48 85 c9             	test   rcx,rcx
  20b2c3:	0f 84 f5 01 00 00    	je     20b4be <openSelfDebugInfo+0xbce>
                prev_node.next = node.next;
  20b2c9:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  20b2cd:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  20b2d1:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20b2d5:	e9 ef 01 00 00       	jmp    20b4c9 <openSelfDebugInfo+0xbd9>
  20b2da:	48 8b 84 24 48 03 00 	mov    rax,QWORD PTR [rsp+0x348]
  20b2e1:	00 
  20b2e2:	48 85 c0             	test   rax,rax
  20b2e5:	0f 84 a4 00 00 00    	je     20b38f <openSelfDebugInfo+0xa9f>
  20b2eb:	48 89 45 60          	mov    QWORD PTR [rbp+0x60],rax
            st.debug_abbrev = (try st.elf.findSection(".debug_abbrev")) orelse return error.MissingDebugInfo;
  20b2ef:	48 8d 15 82 58 01 00 	lea    rdx,[rip+0x15882]        # 220b78 <__unnamed_46>
  20b2f6:	48 8d bc 24 30 03 00 	lea    rdi,[rsp+0x330]
  20b2fd:	00 
  20b2fe:	4c 89 fe             	mov    rsi,r15
  20b301:	e8 7a 42 00 00       	call   20f580 <Elf_findSection>
  20b306:	66 83 bc 24 30 03 00 	cmp    WORD PTR [rsp+0x330],0x0
  20b30d:	00 00 
  20b30f:	0f 84 f4 00 00 00    	je     20b409 <openSelfDebugInfo+0xb19>
        const bytes = @sliceToBytes(memory);
  20b315:	48 8b 45 48          	mov    rax,QWORD PTR [rbp+0x48]
  20b319:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  20b31d:	74 26                	je     20b345 <openSelfDebugInfo+0xa55>
  20b31f:	48 8b 7d 50          	mov    rdi,QWORD PTR [rbp+0x50]
        const bytes = @sliceToBytes(memory);
  20b323:	48 8b 4d 40          	mov    rcx,QWORD PTR [rbp+0x40]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  20b327:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  20b32b:	48 89 8c 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rcx
  20b332:	00 
  20b333:	48 89 84 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],rax
  20b33a:	00 
  20b33b:	48 8d b4 24 f0 00 00 	lea    rsi,[rsp+0xf0]
  20b342:	00 
  20b343:	ff d2                	call   rdx
  20b345:	80 7d 10 01          	cmp    BYTE PTR [rbp+0x10],0x1
  20b349:	0f 85 68 04 00 00    	jne    20b7b7 <openSelfDebugInfo+0xec7>
  20b34f:	49 8b 07             	mov    rax,QWORD PTR [r15]
  20b352:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  20b355:	b8 03 00 00 00       	mov    eax,0x3
  20b35a:	0f 05                	syscall 
  20b35c:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  20b360:	74 f3                	je     20b355 <openSelfDebugInfo+0xa65>
            const first = list.first orelse return null;
  20b362:	48 8b 05 bf 5c 01 00 	mov    rax,QWORD PTR [rip+0x15cbf]        # 221028 <emfile_promise_queue>
  20b369:	48 85 c0             	test   rax,rax
  20b36c:	0f 84 45 04 00 00    	je     20b7b7 <openSelfDebugInfo+0xec7>
            if (node.prev) |prev_node| {
  20b372:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  20b375:	48 85 c9             	test   rcx,rcx
  20b378:	0f 84 d5 03 00 00    	je     20b753 <openSelfDebugInfo+0xe63>
                prev_node.next = node.next;
  20b37e:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  20b382:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  20b386:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20b38a:	e9 cf 03 00 00       	jmp    20b75e <openSelfDebugInfo+0xe6e>
        const bytes = @sliceToBytes(memory);
  20b38f:	48 8b 45 48          	mov    rax,QWORD PTR [rbp+0x48]
  20b393:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  20b397:	74 26                	je     20b3bf <openSelfDebugInfo+0xacf>
  20b399:	48 8b 7d 50          	mov    rdi,QWORD PTR [rbp+0x50]
        const bytes = @sliceToBytes(memory);
  20b39d:	48 8b 4d 40          	mov    rcx,QWORD PTR [rbp+0x40]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  20b3a1:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  20b3a5:	48 89 8c 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rcx
  20b3ac:	00 
  20b3ad:	48 89 84 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],rax
  20b3b4:	00 
  20b3b5:	48 8d b4 24 f0 00 00 	lea    rsi,[rsp+0xf0]
  20b3bc:	00 
  20b3bd:	ff d2                	call   rdx
  20b3bf:	80 7d 10 01          	cmp    BYTE PTR [rbp+0x10],0x1
  20b3c3:	0f 85 35 05 00 00    	jne    20b8fe <openSelfDebugInfo+0x100e>
  20b3c9:	49 8b 07             	mov    rax,QWORD PTR [r15]
  20b3cc:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  20b3cf:	b8 03 00 00 00       	mov    eax,0x3
  20b3d4:	0f 05                	syscall 
  20b3d6:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  20b3da:	74 f3                	je     20b3cf <openSelfDebugInfo+0xadf>
            const first = list.first orelse return null;
  20b3dc:	48 8b 05 45 5c 01 00 	mov    rax,QWORD PTR [rip+0x15c45]        # 221028 <emfile_promise_queue>
  20b3e3:	48 85 c0             	test   rax,rax
  20b3e6:	0f 84 12 05 00 00    	je     20b8fe <openSelfDebugInfo+0x100e>
            if (node.prev) |prev_node| {
  20b3ec:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  20b3ef:	48 85 c9             	test   rcx,rcx
  20b3f2:	0f 84 a2 04 00 00    	je     20b89a <openSelfDebugInfo+0xfaa>
                prev_node.next = node.next;
  20b3f8:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  20b3fc:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  20b400:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20b404:	e9 9c 04 00 00       	jmp    20b8a5 <openSelfDebugInfo+0xfb5>
  20b409:	48 8b 84 24 38 03 00 	mov    rax,QWORD PTR [rsp+0x338]
  20b410:	00 
  20b411:	48 85 c0             	test   rax,rax
  20b414:	0f 84 0a 02 00 00    	je     20b624 <openSelfDebugInfo+0xd34>
  20b41a:	48 89 45 68          	mov    QWORD PTR [rbp+0x68],rax
            st.debug_str = (try st.elf.findSection(".debug_str")) orelse return error.MissingDebugInfo;
  20b41e:	48 8d 15 63 57 01 00 	lea    rdx,[rip+0x15763]        # 220b88 <__unnamed_47>
  20b425:	48 8d bc 24 20 03 00 	lea    rdi,[rsp+0x320]
  20b42c:	00 
  20b42d:	4c 89 fe             	mov    rsi,r15
  20b430:	e8 4b 41 00 00       	call   20f580 <Elf_findSection>
  20b435:	66 83 bc 24 20 03 00 	cmp    WORD PTR [rsp+0x320],0x0
  20b43c:	00 00 
  20b43e:	0f 84 5a 02 00 00    	je     20b69e <openSelfDebugInfo+0xdae>
        const bytes = @sliceToBytes(memory);
  20b444:	48 8b 45 48          	mov    rax,QWORD PTR [rbp+0x48]
  20b448:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  20b44c:	74 26                	je     20b474 <openSelfDebugInfo+0xb84>
  20b44e:	48 8b 7d 50          	mov    rdi,QWORD PTR [rbp+0x50]
        const bytes = @sliceToBytes(memory);
  20b452:	48 8b 4d 40          	mov    rcx,QWORD PTR [rbp+0x40]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  20b456:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  20b45a:	48 89 8c 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rcx
  20b461:	00 
  20b462:	48 89 84 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],rax
  20b469:	00 
  20b46a:	48 8d b4 24 f0 00 00 	lea    rsi,[rsp+0xf0]
  20b471:	00 
  20b472:	ff d2                	call   rdx
  20b474:	80 7d 10 01          	cmp    BYTE PTR [rbp+0x10],0x1
  20b478:	0f 85 f0 06 00 00    	jne    20bb6e <openSelfDebugInfo+0x127e>
  20b47e:	49 8b 07             	mov    rax,QWORD PTR [r15]
  20b481:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  20b484:	b8 03 00 00 00       	mov    eax,0x3
  20b489:	0f 05                	syscall 
  20b48b:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  20b48f:	74 f3                	je     20b484 <openSelfDebugInfo+0xb94>
            const first = list.first orelse return null;
  20b491:	48 8b 05 90 5b 01 00 	mov    rax,QWORD PTR [rip+0x15b90]        # 221028 <emfile_promise_queue>
  20b498:	48 85 c0             	test   rax,rax
  20b49b:	0f 84 cd 06 00 00    	je     20bb6e <openSelfDebugInfo+0x127e>
            if (node.prev) |prev_node| {
  20b4a1:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  20b4a4:	48 85 c9             	test   rcx,rcx
  20b4a7:	0f 84 5d 06 00 00    	je     20bb0a <openSelfDebugInfo+0x121a>
                prev_node.next = node.next;
  20b4ad:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  20b4b1:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  20b4b5:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20b4b9:	e9 57 06 00 00       	jmp    20bb15 <openSelfDebugInfo+0x1225>
                list.first = node.next;
  20b4be:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20b4c2:	48 89 0d 5f 5b 01 00 	mov    QWORD PTR [rip+0x15b5f],rcx        # 221028 <emfile_promise_queue>
            if (node.next) |next_node| {
  20b4c9:	48 85 c9             	test   rcx,rcx
  20b4cc:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  20b4cf:	48 8d 35 5a 5b 01 00 	lea    rsi,[rip+0x15b5a]        # 221030 <emfile_promise_queue+0x8>
  20b4d6:	48 0f 45 f1          	cmovne rsi,rcx
  20b4da:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  20b4dd:	48 83 05 53 5b 01 00 	add    QWORD PTR [rip+0x15b53],0xffffffffffffffff        # 221038 <emfile_promise_queue+0x10>
  20b4e4:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  20b4e5:	74 1e                	je     20b505 <openSelfDebugInfo+0xc15>
  20b4e7:	48 83 3d 39 5b 01 00 	cmp    QWORD PTR [rip+0x15b39],0x0        # 221028 <emfile_promise_queue>
  20b4ee:	00 
  20b4ef:	0f 84 5f 34 00 00    	je     20e954 <openSelfDebugInfo+0x4064>
  20b4f5:	48 8b 0d 34 5b 01 00 	mov    rcx,QWORD PTR [rip+0x15b34]        # 221030 <emfile_promise_queue+0x8>
  20b4fc:	48 85 c9             	test   rcx,rcx
  20b4ff:	0f 84 4f 34 00 00    	je     20e954 <openSelfDebugInfo+0x4064>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  20b505:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  20b509:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  20b50d:	0f 1f 00             	nop    DWORD PTR [rax]
  20b510:	48 89 c1             	mov    rcx,rax
  20b513:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  20b517:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  20b51d:	75 f1                	jne    20b510 <openSelfDebugInfo+0xc20>
  20b51f:	a8 01                	test   al,0x1
  20b521:	75 02                	jne    20b525 <openSelfDebugInfo+0xc35>
  20b523:	ff 17                	call   QWORD PTR [rdi]
  20b525:	48 63 7d 00          	movsxd rdi,DWORD PTR [rbp+0x0]
  20b529:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  20b530:	b8 03 00 00 00       	mov    eax,0x3
  20b535:	0f 05                	syscall 
            switch (err) {
  20b537:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  20b53b:	74 f3                	je     20b530 <openSelfDebugInfo+0xc40>
            const first = list.first orelse return null;
  20b53d:	48 8b 05 e4 5a 01 00 	mov    rax,QWORD PTR [rip+0x15ae4]        # 221028 <emfile_promise_queue>
  20b544:	48 85 c0             	test   rax,rax
  20b547:	74 7c                	je     20b5c5 <openSelfDebugInfo+0xcd5>
            if (node.prev) |prev_node| {
  20b549:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  20b54c:	48 85 c9             	test   rcx,rcx
  20b54f:	74 0e                	je     20b55f <openSelfDebugInfo+0xc6f>
                prev_node.next = node.next;
  20b551:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  20b555:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  20b559:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20b55d:	eb 0b                	jmp    20b56a <openSelfDebugInfo+0xc7a>
                list.first = node.next;
  20b55f:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20b563:	48 89 0d be 5a 01 00 	mov    QWORD PTR [rip+0x15abe],rcx        # 221028 <emfile_promise_queue>
            if (node.next) |next_node| {
  20b56a:	48 85 c9             	test   rcx,rcx
  20b56d:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  20b570:	48 8d 35 b9 5a 01 00 	lea    rsi,[rip+0x15ab9]        # 221030 <emfile_promise_queue+0x8>
  20b577:	48 0f 45 f1          	cmovne rsi,rcx
  20b57b:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  20b57e:	48 83 05 b2 5a 01 00 	add    QWORD PTR [rip+0x15ab2],0xffffffffffffffff        # 221038 <emfile_promise_queue+0x10>
  20b585:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  20b586:	74 1e                	je     20b5a6 <openSelfDebugInfo+0xcb6>
  20b588:	48 83 3d 98 5a 01 00 	cmp    QWORD PTR [rip+0x15a98],0x0        # 221028 <emfile_promise_queue>
  20b58f:	00 
  20b590:	0f 84 be 33 00 00    	je     20e954 <openSelfDebugInfo+0x4064>
  20b596:	48 8b 0d 93 5a 01 00 	mov    rcx,QWORD PTR [rip+0x15a93]        # 221030 <emfile_promise_queue+0x8>
  20b59d:	48 85 c9             	test   rcx,rcx
  20b5a0:	0f 84 ae 33 00 00    	je     20e954 <openSelfDebugInfo+0x4064>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  20b5a6:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  20b5aa:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  20b5ae:	66 90                	xchg   ax,ax
  20b5b0:	48 89 c1             	mov    rcx,rax
  20b5b3:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  20b5b7:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  20b5bd:	75 f1                	jne    20b5b0 <openSelfDebugInfo+0xcc0>
  20b5bf:	a8 01                	test   al,0x1
  20b5c1:	75 02                	jne    20b5c5 <openSelfDebugInfo+0xcd5>
  20b5c3:	ff 17                	call   QWORD PTR [rdi]
        self.freeFn(self, non_const_ptr[0..@sizeOf(@typeOf(ptr).Child)]);
  20b5c5:	49 8b 44 24 10       	mov    rax,QWORD PTR [r12+0x10]
  20b5ca:	48 89 ac 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rbp
  20b5d1:	00 
  20b5d2:	48 c7 84 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],0xc8
  20b5d9:	00 c8 00 00 00 
  20b5de:	48 8d b4 24 f0 00 00 	lea    rsi,[rsp+0xf0]
  20b5e5:	00 
  20b5e6:	4c 89 e7             	mov    rdi,r12
  20b5e9:	ff d0                	call   rax
            st.debug_info = (try st.elf.findSection(".debug_info")) orelse return error.MissingDebugInfo;
  20b5eb:	0f b7 84 24 40 03 00 	movzx  eax,WORD PTR [rsp+0x340]
  20b5f2:	00 
  20b5f3:	66 41 89 06          	mov    WORD PTR [r14],ax
  20b5f7:	48 8b 84 24 e8 04 00 	mov    rax,QWORD PTR [rsp+0x4e8]
  20b5fe:	00 
  20b5ff:	48 8b 8c 24 ee 04 00 	mov    rcx,QWORD PTR [rsp+0x4ee]
  20b606:	00 
  20b607:	49 89 4e 08          	mov    QWORD PTR [r14+0x8],rcx
  20b60b:	49 89 46 02          	mov    QWORD PTR [r14+0x2],rax
  20b60f:	48 81 c4 e8 05 00 00 	add    rsp,0x5e8
  20b616:	5b                   	pop    rbx
  20b617:	41 5c                	pop    r12
  20b619:	41 5d                	pop    r13
  20b61b:	41 5e                	pop    r14
  20b61d:	41 5f                	pop    r15
  20b61f:	5d                   	pop    rbp
  20b620:	c5 f8 77             	vzeroupper 
  20b623:	c3                   	ret    
        const bytes = @sliceToBytes(memory);
  20b624:	48 8b 45 48          	mov    rax,QWORD PTR [rbp+0x48]
  20b628:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  20b62c:	74 26                	je     20b654 <openSelfDebugInfo+0xd64>
  20b62e:	48 8b 7d 50          	mov    rdi,QWORD PTR [rbp+0x50]
        const bytes = @sliceToBytes(memory);
  20b632:	48 8b 4d 40          	mov    rcx,QWORD PTR [rbp+0x40]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  20b636:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  20b63a:	48 89 8c 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rcx
  20b641:	00 
  20b642:	48 89 84 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],rax
  20b649:	00 
  20b64a:	48 8d b4 24 f0 00 00 	lea    rsi,[rsp+0xf0]
  20b651:	00 
  20b652:	ff d2                	call   rdx
  20b654:	80 7d 10 01          	cmp    BYTE PTR [rbp+0x10],0x1
  20b658:	0f 85 52 06 00 00    	jne    20bcb0 <openSelfDebugInfo+0x13c0>
  20b65e:	49 8b 07             	mov    rax,QWORD PTR [r15]
  20b661:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  20b664:	b8 03 00 00 00       	mov    eax,0x3
  20b669:	0f 05                	syscall 
            switch (err) {
  20b66b:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  20b66f:	74 f3                	je     20b664 <openSelfDebugInfo+0xd74>
            const first = list.first orelse return null;
  20b671:	48 8b 05 b0 59 01 00 	mov    rax,QWORD PTR [rip+0x159b0]        # 221028 <emfile_promise_queue>
  20b678:	48 85 c0             	test   rax,rax
  20b67b:	0f 84 2f 06 00 00    	je     20bcb0 <openSelfDebugInfo+0x13c0>
            if (node.prev) |prev_node| {
  20b681:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  20b684:	48 85 c9             	test   rcx,rcx
  20b687:	0f 84 bf 05 00 00    	je     20bc4c <openSelfDebugInfo+0x135c>
                prev_node.next = node.next;
  20b68d:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  20b691:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  20b695:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20b699:	e9 b9 05 00 00       	jmp    20bc57 <openSelfDebugInfo+0x1367>
            st.debug_str = (try st.elf.findSection(".debug_str")) orelse return error.MissingDebugInfo;
  20b69e:	48 8b 84 24 28 03 00 	mov    rax,QWORD PTR [rsp+0x328]
  20b6a5:	00 
  20b6a6:	48 85 c0             	test   rax,rax
  20b6a9:	0f 84 2c 03 00 00    	je     20b9db <openSelfDebugInfo+0x10eb>
  20b6af:	48 89 45 70          	mov    QWORD PTR [rbp+0x70],rax
            st.debug_line = (try st.elf.findSection(".debug_line")) orelse return error.MissingDebugInfo;
  20b6b3:	48 8d 15 de 54 01 00 	lea    rdx,[rip+0x154de]        # 220b98 <__unnamed_48>
  20b6ba:	48 8d bc 24 10 03 00 	lea    rdi,[rsp+0x310]
  20b6c1:	00 
  20b6c2:	4c 89 fe             	mov    rsi,r15
  20b6c5:	e8 b6 3e 00 00       	call   20f580 <Elf_findSection>
  20b6ca:	66 83 bc 24 10 03 00 	cmp    WORD PTR [rsp+0x310],0x0
  20b6d1:	00 00 
  20b6d3:	0f 84 7c 03 00 00    	je     20ba55 <openSelfDebugInfo+0x1165>
        const bytes = @sliceToBytes(memory);
  20b6d9:	48 8b 45 48          	mov    rax,QWORD PTR [rbp+0x48]
  20b6dd:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  20b6e1:	74 26                	je     20b709 <openSelfDebugInfo+0xe19>
  20b6e3:	48 8b 7d 50          	mov    rdi,QWORD PTR [rbp+0x50]
        const bytes = @sliceToBytes(memory);
  20b6e7:	48 8b 4d 40          	mov    rcx,QWORD PTR [rbp+0x40]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  20b6eb:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  20b6ef:	48 89 8c 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rcx
  20b6f6:	00 
  20b6f7:	48 89 84 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],rax
  20b6fe:	00 
  20b6ff:	48 8d b4 24 f0 00 00 	lea    rsi,[rsp+0xf0]
  20b706:	00 
  20b707:	ff d2                	call   rdx
  20b709:	80 7d 10 01          	cmp    BYTE PTR [rbp+0x10],0x1
  20b70d:	0f 85 92 1c 00 00    	jne    20d3a5 <openSelfDebugInfo+0x2ab5>
  20b713:	49 8b 07             	mov    rax,QWORD PTR [r15]
  20b716:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  20b719:	b8 03 00 00 00       	mov    eax,0x3
  20b71e:	0f 05                	syscall 
  20b720:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  20b724:	74 f3                	je     20b719 <openSelfDebugInfo+0xe29>
            const first = list.first orelse return null;
  20b726:	48 8b 05 fb 58 01 00 	mov    rax,QWORD PTR [rip+0x158fb]        # 221028 <emfile_promise_queue>
  20b72d:	48 85 c0             	test   rax,rax
  20b730:	0f 84 6f 1c 00 00    	je     20d3a5 <openSelfDebugInfo+0x2ab5>
            if (node.prev) |prev_node| {
  20b736:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  20b739:	48 85 c9             	test   rcx,rcx
  20b73c:	0f 84 ff 1b 00 00    	je     20d341 <openSelfDebugInfo+0x2a51>
                prev_node.next = node.next;
  20b742:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  20b746:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  20b74a:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20b74e:	e9 f9 1b 00 00       	jmp    20d34c <openSelfDebugInfo+0x2a5c>
                list.first = node.next;
  20b753:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20b757:	48 89 0d ca 58 01 00 	mov    QWORD PTR [rip+0x158ca],rcx        # 221028 <emfile_promise_queue>
            if (node.next) |next_node| {
  20b75e:	48 85 c9             	test   rcx,rcx
  20b761:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  20b764:	48 8d 35 c5 58 01 00 	lea    rsi,[rip+0x158c5]        # 221030 <emfile_promise_queue+0x8>
  20b76b:	48 0f 45 f1          	cmovne rsi,rcx
  20b76f:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  20b772:	48 83 05 be 58 01 00 	add    QWORD PTR [rip+0x158be],0xffffffffffffffff        # 221038 <emfile_promise_queue+0x10>
  20b779:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  20b77a:	74 1e                	je     20b79a <openSelfDebugInfo+0xeaa>
  20b77c:	48 83 3d a4 58 01 00 	cmp    QWORD PTR [rip+0x158a4],0x0        # 221028 <emfile_promise_queue>
  20b783:	00 
  20b784:	0f 84 ca 31 00 00    	je     20e954 <openSelfDebugInfo+0x4064>
  20b78a:	48 8b 0d 9f 58 01 00 	mov    rcx,QWORD PTR [rip+0x1589f]        # 221030 <emfile_promise_queue+0x8>
  20b791:	48 85 c9             	test   rcx,rcx
  20b794:	0f 84 ba 31 00 00    	je     20e954 <openSelfDebugInfo+0x4064>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  20b79a:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  20b79e:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  20b7a2:	48 89 c1             	mov    rcx,rax
  20b7a5:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  20b7a9:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  20b7af:	75 f1                	jne    20b7a2 <openSelfDebugInfo+0xeb2>
  20b7b1:	a8 01                	test   al,0x1
  20b7b3:	75 02                	jne    20b7b7 <openSelfDebugInfo+0xec7>
  20b7b5:	ff 17                	call   QWORD PTR [rdi]
  20b7b7:	48 63 7d 00          	movsxd rdi,DWORD PTR [rbp+0x0]
  20b7bb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  20b7c0:	b8 03 00 00 00       	mov    eax,0x3
  20b7c5:	0f 05                	syscall 
            switch (err) {
  20b7c7:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  20b7cb:	74 f3                	je     20b7c0 <openSelfDebugInfo+0xed0>
            const first = list.first orelse return null;
  20b7cd:	48 8b 05 54 58 01 00 	mov    rax,QWORD PTR [rip+0x15854]        # 221028 <emfile_promise_queue>
  20b7d4:	48 85 c0             	test   rax,rax
  20b7d7:	74 7a                	je     20b853 <openSelfDebugInfo+0xf63>
            if (node.prev) |prev_node| {
  20b7d9:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  20b7dc:	48 85 c9             	test   rcx,rcx
  20b7df:	74 0e                	je     20b7ef <openSelfDebugInfo+0xeff>
                prev_node.next = node.next;
  20b7e1:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  20b7e5:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  20b7e9:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20b7ed:	eb 0b                	jmp    20b7fa <openSelfDebugInfo+0xf0a>
                list.first = node.next;
  20b7ef:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20b7f3:	48 89 0d 2e 58 01 00 	mov    QWORD PTR [rip+0x1582e],rcx        # 221028 <emfile_promise_queue>
            if (node.next) |next_node| {
  20b7fa:	48 85 c9             	test   rcx,rcx
  20b7fd:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  20b800:	48 8d 35 29 58 01 00 	lea    rsi,[rip+0x15829]        # 221030 <emfile_promise_queue+0x8>
  20b807:	48 0f 45 f1          	cmovne rsi,rcx
  20b80b:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  20b80e:	48 83 05 22 58 01 00 	add    QWORD PTR [rip+0x15822],0xffffffffffffffff        # 221038 <emfile_promise_queue+0x10>
  20b815:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  20b816:	74 1e                	je     20b836 <openSelfDebugInfo+0xf46>
  20b818:	48 83 3d 08 58 01 00 	cmp    QWORD PTR [rip+0x15808],0x0        # 221028 <emfile_promise_queue>
  20b81f:	00 
  20b820:	0f 84 2e 31 00 00    	je     20e954 <openSelfDebugInfo+0x4064>
  20b826:	48 8b 0d 03 58 01 00 	mov    rcx,QWORD PTR [rip+0x15803]        # 221030 <emfile_promise_queue+0x8>
  20b82d:	48 85 c9             	test   rcx,rcx
  20b830:	0f 84 1e 31 00 00    	je     20e954 <openSelfDebugInfo+0x4064>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  20b836:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  20b83a:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  20b83e:	48 89 c1             	mov    rcx,rax
  20b841:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  20b845:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  20b84b:	75 f1                	jne    20b83e <openSelfDebugInfo+0xf4e>
  20b84d:	a8 01                	test   al,0x1
  20b84f:	75 02                	jne    20b853 <openSelfDebugInfo+0xf63>
  20b851:	ff 17                	call   QWORD PTR [rdi]
        self.freeFn(self, non_const_ptr[0..@sizeOf(@typeOf(ptr).Child)]);
  20b853:	49 8b 44 24 10       	mov    rax,QWORD PTR [r12+0x10]
  20b858:	48 89 ac 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rbp
  20b85f:	00 
  20b860:	48 c7 84 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],0xc8
  20b867:	00 c8 00 00 00 
  20b86c:	48 8d b4 24 f0 00 00 	lea    rsi,[rsp+0xf0]
  20b873:	00 
  20b874:	4c 89 e7             	mov    rdi,r12
  20b877:	ff d0                	call   rax
            st.debug_abbrev = (try st.elf.findSection(".debug_abbrev")) orelse return error.MissingDebugInfo;
  20b879:	0f b7 84 24 30 03 00 	movzx  eax,WORD PTR [rsp+0x330]
  20b880:	00 
  20b881:	66 41 89 06          	mov    WORD PTR [r14],ax
  20b885:	48 8b 84 24 da 04 00 	mov    rax,QWORD PTR [rsp+0x4da]
  20b88c:	00 
  20b88d:	48 8b 8c 24 e0 04 00 	mov    rcx,QWORD PTR [rsp+0x4e0]
  20b894:	00 
  20b895:	e9 6d fd ff ff       	jmp    20b607 <openSelfDebugInfo+0xd17>
                list.first = node.next;
  20b89a:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20b89e:	48 89 0d 83 57 01 00 	mov    QWORD PTR [rip+0x15783],rcx        # 221028 <emfile_promise_queue>
            if (node.next) |next_node| {
  20b8a5:	48 85 c9             	test   rcx,rcx
  20b8a8:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  20b8ab:	48 8d 35 7e 57 01 00 	lea    rsi,[rip+0x1577e]        # 221030 <emfile_promise_queue+0x8>
  20b8b2:	48 0f 45 f1          	cmovne rsi,rcx
  20b8b6:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  20b8b9:	48 83 05 77 57 01 00 	add    QWORD PTR [rip+0x15777],0xffffffffffffffff        # 221038 <emfile_promise_queue+0x10>
  20b8c0:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  20b8c1:	74 1e                	je     20b8e1 <openSelfDebugInfo+0xff1>
  20b8c3:	48 83 3d 5d 57 01 00 	cmp    QWORD PTR [rip+0x1575d],0x0        # 221028 <emfile_promise_queue>
  20b8ca:	00 
  20b8cb:	0f 84 83 30 00 00    	je     20e954 <openSelfDebugInfo+0x4064>
  20b8d1:	48 8b 0d 58 57 01 00 	mov    rcx,QWORD PTR [rip+0x15758]        # 221030 <emfile_promise_queue+0x8>
  20b8d8:	48 85 c9             	test   rcx,rcx
  20b8db:	0f 84 73 30 00 00    	je     20e954 <openSelfDebugInfo+0x4064>
  20b8e1:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  20b8e5:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  20b8e9:	48 89 c1             	mov    rcx,rax
  20b8ec:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  20b8f0:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  20b8f6:	75 f1                	jne    20b8e9 <openSelfDebugInfo+0xff9>
  20b8f8:	a8 01                	test   al,0x1
  20b8fa:	75 02                	jne    20b8fe <openSelfDebugInfo+0x100e>
  20b8fc:	ff 17                	call   QWORD PTR [rdi]
  20b8fe:	48 63 7d 00          	movsxd rdi,DWORD PTR [rbp+0x0]
  20b902:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20b909:	1f 84 00 00 00 00 00 
  20b910:	b8 03 00 00 00       	mov    eax,0x3
  20b915:	0f 05                	syscall 
            switch (err) {
  20b917:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  20b91b:	74 f3                	je     20b910 <openSelfDebugInfo+0x1020>
            const first = list.first orelse return null;
  20b91d:	48 8b 05 04 57 01 00 	mov    rax,QWORD PTR [rip+0x15704]        # 221028 <emfile_promise_queue>
  20b924:	48 85 c0             	test   rax,rax
  20b927:	74 7a                	je     20b9a3 <openSelfDebugInfo+0x10b3>
            if (node.prev) |prev_node| {
  20b929:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  20b92c:	48 85 c9             	test   rcx,rcx
  20b92f:	74 0e                	je     20b93f <openSelfDebugInfo+0x104f>
                prev_node.next = node.next;
  20b931:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  20b935:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  20b939:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20b93d:	eb 0b                	jmp    20b94a <openSelfDebugInfo+0x105a>
                list.first = node.next;
  20b93f:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20b943:	48 89 0d de 56 01 00 	mov    QWORD PTR [rip+0x156de],rcx        # 221028 <emfile_promise_queue>
            if (node.next) |next_node| {
  20b94a:	48 85 c9             	test   rcx,rcx
  20b94d:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  20b950:	48 8d 35 d9 56 01 00 	lea    rsi,[rip+0x156d9]        # 221030 <emfile_promise_queue+0x8>
  20b957:	48 0f 45 f1          	cmovne rsi,rcx
  20b95b:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  20b95e:	48 83 05 d2 56 01 00 	add    QWORD PTR [rip+0x156d2],0xffffffffffffffff        # 221038 <emfile_promise_queue+0x10>
  20b965:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  20b966:	74 1e                	je     20b986 <openSelfDebugInfo+0x1096>
  20b968:	48 83 3d b8 56 01 00 	cmp    QWORD PTR [rip+0x156b8],0x0        # 221028 <emfile_promise_queue>
  20b96f:	00 
  20b970:	0f 84 de 2f 00 00    	je     20e954 <openSelfDebugInfo+0x4064>
  20b976:	48 8b 0d b3 56 01 00 	mov    rcx,QWORD PTR [rip+0x156b3]        # 221030 <emfile_promise_queue+0x8>
  20b97d:	48 85 c9             	test   rcx,rcx
  20b980:	0f 84 ce 2f 00 00    	je     20e954 <openSelfDebugInfo+0x4064>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  20b986:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  20b98a:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  20b98e:	48 89 c1             	mov    rcx,rax
  20b991:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  20b995:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  20b99b:	75 f1                	jne    20b98e <openSelfDebugInfo+0x109e>
  20b99d:	a8 01                	test   al,0x1
  20b99f:	75 02                	jne    20b9a3 <openSelfDebugInfo+0x10b3>
  20b9a1:	ff 17                	call   QWORD PTR [rdi]
  20b9a3:	49 8b 44 24 10       	mov    rax,QWORD PTR [r12+0x10]
  20b9a8:	48 89 ac 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rbp
  20b9af:	00 
  20b9b0:	48 c7 84 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],0xc8
  20b9b7:	00 c8 00 00 00 
  20b9bc:	48 8d b4 24 f0 00 00 	lea    rsi,[rsp+0xf0]
  20b9c3:	00 
  20b9c4:	4c 89 e7             	mov    rdi,r12
  20b9c7:	ff d0                	call   rax
  20b9c9:	c5 fa 6f 05 4f b6 ff 	vmovdqu xmm0,XMMWORD PTR [rip+0xffffffffffffb64f]        # 207020 <__unnamed_49>
  20b9d0:	ff 
  20b9d1:	c4 c1 7a 7f 06       	vmovdqu XMMWORD PTR [r14],xmm0
  20b9d6:	e9 34 fc ff ff       	jmp    20b60f <openSelfDebugInfo+0xd1f>
        const bytes = @sliceToBytes(memory);
  20b9db:	48 8b 45 48          	mov    rax,QWORD PTR [rbp+0x48]
  20b9df:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  20b9e3:	74 26                	je     20ba0b <openSelfDebugInfo+0x111b>
  20b9e5:	48 8b 7d 50          	mov    rdi,QWORD PTR [rbp+0x50]
        const bytes = @sliceToBytes(memory);
  20b9e9:	48 8b 4d 40          	mov    rcx,QWORD PTR [rbp+0x40]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  20b9ed:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  20b9f1:	48 89 8c 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rcx
  20b9f8:	00 
  20b9f9:	48 89 84 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],rax
  20ba00:	00 
  20ba01:	48 8d b4 24 f0 00 00 	lea    rsi,[rsp+0xf0]
  20ba08:	00 
  20ba09:	ff d2                	call   rdx
  20ba0b:	80 7d 10 01          	cmp    BYTE PTR [rbp+0x10],0x1
  20ba0f:	0f 85 d2 1a 00 00    	jne    20d4e7 <openSelfDebugInfo+0x2bf7>
  20ba15:	49 8b 07             	mov    rax,QWORD PTR [r15]
  20ba18:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  20ba1b:	b8 03 00 00 00       	mov    eax,0x3
  20ba20:	0f 05                	syscall 
            switch (err) {
  20ba22:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  20ba26:	74 f3                	je     20ba1b <openSelfDebugInfo+0x112b>
            const first = list.first orelse return null;
  20ba28:	48 8b 05 f9 55 01 00 	mov    rax,QWORD PTR [rip+0x155f9]        # 221028 <emfile_promise_queue>
  20ba2f:	48 85 c0             	test   rax,rax
  20ba32:	0f 84 af 1a 00 00    	je     20d4e7 <openSelfDebugInfo+0x2bf7>
            if (node.prev) |prev_node| {
  20ba38:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  20ba3b:	48 85 c9             	test   rcx,rcx
  20ba3e:	0f 84 3f 1a 00 00    	je     20d483 <openSelfDebugInfo+0x2b93>
                prev_node.next = node.next;
  20ba44:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  20ba48:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  20ba4c:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20ba50:	e9 39 1a 00 00       	jmp    20d48e <openSelfDebugInfo+0x2b9e>
            st.debug_line = (try st.elf.findSection(".debug_line")) orelse return error.MissingDebugInfo;
  20ba55:	48 8b 84 24 18 03 00 	mov    rax,QWORD PTR [rsp+0x318]
  20ba5c:	00 
  20ba5d:	48 85 c0             	test   rax,rax
  20ba60:	0f 84 e4 02 00 00    	je     20bd4a <openSelfDebugInfo+0x145a>
  20ba66:	48 89 45 78          	mov    QWORD PTR [rbp+0x78],rax
            st.debug_ranges = (try st.elf.findSection(".debug_ranges"));
  20ba6a:	48 8d 15 37 51 01 00 	lea    rdx,[rip+0x15137]        # 220ba8 <__unnamed_50>
  20ba71:	48 8d bc 24 00 03 00 	lea    rdi,[rsp+0x300]
  20ba78:	00 
  20ba79:	4c 89 fe             	mov    rsi,r15
  20ba7c:	e8 ff 3a 00 00       	call   20f580 <Elf_findSection>
  20ba81:	66 83 bc 24 00 03 00 	cmp    WORD PTR [rsp+0x300],0x0
  20ba88:	00 00 
  20ba8a:	0f 84 34 03 00 00    	je     20bdc4 <openSelfDebugInfo+0x14d4>
        const bytes = @sliceToBytes(memory);
  20ba90:	48 8b 45 48          	mov    rax,QWORD PTR [rbp+0x48]
  20ba94:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  20ba98:	74 26                	je     20bac0 <openSelfDebugInfo+0x11d0>
  20ba9a:	48 8b 7d 50          	mov    rdi,QWORD PTR [rbp+0x50]
        const bytes = @sliceToBytes(memory);
  20ba9e:	48 8b 4d 40          	mov    rcx,QWORD PTR [rbp+0x40]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  20baa2:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  20baa6:	48 89 8c 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rcx
  20baad:	00 
  20baae:	48 89 84 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],rax
  20bab5:	00 
  20bab6:	48 8d b4 24 f0 00 00 	lea    rsi,[rsp+0xf0]
  20babd:	00 
  20babe:	ff d2                	call   rdx
  20bac0:	80 7d 10 01          	cmp    BYTE PTR [rbp+0x10],0x1
  20bac4:	0f 85 4f 1b 00 00    	jne    20d619 <openSelfDebugInfo+0x2d29>
  20baca:	49 8b 07             	mov    rax,QWORD PTR [r15]
  20bacd:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  20bad0:	b8 03 00 00 00       	mov    eax,0x3
  20bad5:	0f 05                	syscall 
  20bad7:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  20badb:	74 f3                	je     20bad0 <openSelfDebugInfo+0x11e0>
            const first = list.first orelse return null;
  20badd:	48 8b 05 44 55 01 00 	mov    rax,QWORD PTR [rip+0x15544]        # 221028 <emfile_promise_queue>
  20bae4:	48 85 c0             	test   rax,rax
  20bae7:	0f 84 2c 1b 00 00    	je     20d619 <openSelfDebugInfo+0x2d29>
            if (node.prev) |prev_node| {
  20baed:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  20baf0:	48 85 c9             	test   rcx,rcx
  20baf3:	0f 84 bc 1a 00 00    	je     20d5b5 <openSelfDebugInfo+0x2cc5>
                prev_node.next = node.next;
  20baf9:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  20bafd:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  20bb01:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20bb05:	e9 b6 1a 00 00       	jmp    20d5c0 <openSelfDebugInfo+0x2cd0>
                list.first = node.next;
  20bb0a:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20bb0e:	48 89 0d 13 55 01 00 	mov    QWORD PTR [rip+0x15513],rcx        # 221028 <emfile_promise_queue>
            if (node.next) |next_node| {
  20bb15:	48 85 c9             	test   rcx,rcx
  20bb18:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  20bb1b:	48 8d 35 0e 55 01 00 	lea    rsi,[rip+0x1550e]        # 221030 <emfile_promise_queue+0x8>
  20bb22:	48 0f 45 f1          	cmovne rsi,rcx
  20bb26:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  20bb29:	48 83 05 07 55 01 00 	add    QWORD PTR [rip+0x15507],0xffffffffffffffff        # 221038 <emfile_promise_queue+0x10>
  20bb30:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  20bb31:	74 1e                	je     20bb51 <openSelfDebugInfo+0x1261>
  20bb33:	48 83 3d ed 54 01 00 	cmp    QWORD PTR [rip+0x154ed],0x0        # 221028 <emfile_promise_queue>
  20bb3a:	00 
  20bb3b:	0f 84 13 2e 00 00    	je     20e954 <openSelfDebugInfo+0x4064>
  20bb41:	48 8b 0d e8 54 01 00 	mov    rcx,QWORD PTR [rip+0x154e8]        # 221030 <emfile_promise_queue+0x8>
  20bb48:	48 85 c9             	test   rcx,rcx
  20bb4b:	0f 84 03 2e 00 00    	je     20e954 <openSelfDebugInfo+0x4064>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  20bb51:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  20bb55:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  20bb59:	48 89 c1             	mov    rcx,rax
  20bb5c:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  20bb60:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  20bb66:	75 f1                	jne    20bb59 <openSelfDebugInfo+0x1269>
  20bb68:	a8 01                	test   al,0x1
  20bb6a:	75 02                	jne    20bb6e <openSelfDebugInfo+0x127e>
  20bb6c:	ff 17                	call   QWORD PTR [rdi]
  20bb6e:	48 63 7d 00          	movsxd rdi,DWORD PTR [rbp+0x0]
  20bb72:	b8 03 00 00 00       	mov    eax,0x3
  20bb77:	0f 05                	syscall 
            switch (err) {
  20bb79:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  20bb7d:	74 f3                	je     20bb72 <openSelfDebugInfo+0x1282>
            const first = list.first orelse return null;
  20bb7f:	48 8b 05 a2 54 01 00 	mov    rax,QWORD PTR [rip+0x154a2]        # 221028 <emfile_promise_queue>
  20bb86:	48 85 c0             	test   rax,rax
  20bb89:	74 7a                	je     20bc05 <openSelfDebugInfo+0x1315>
            if (node.prev) |prev_node| {
  20bb8b:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  20bb8e:	48 85 c9             	test   rcx,rcx
  20bb91:	74 0e                	je     20bba1 <openSelfDebugInfo+0x12b1>
                prev_node.next = node.next;
  20bb93:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  20bb97:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  20bb9b:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20bb9f:	eb 0b                	jmp    20bbac <openSelfDebugInfo+0x12bc>
                list.first = node.next;
  20bba1:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20bba5:	48 89 0d 7c 54 01 00 	mov    QWORD PTR [rip+0x1547c],rcx        # 221028 <emfile_promise_queue>
            if (node.next) |next_node| {
  20bbac:	48 85 c9             	test   rcx,rcx
  20bbaf:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  20bbb2:	48 8d 35 77 54 01 00 	lea    rsi,[rip+0x15477]        # 221030 <emfile_promise_queue+0x8>
  20bbb9:	48 0f 45 f1          	cmovne rsi,rcx
  20bbbd:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  20bbc0:	48 83 05 70 54 01 00 	add    QWORD PTR [rip+0x15470],0xffffffffffffffff        # 221038 <emfile_promise_queue+0x10>
  20bbc7:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  20bbc8:	74 1e                	je     20bbe8 <openSelfDebugInfo+0x12f8>
  20bbca:	48 83 3d 56 54 01 00 	cmp    QWORD PTR [rip+0x15456],0x0        # 221028 <emfile_promise_queue>
  20bbd1:	00 
  20bbd2:	0f 84 7c 2d 00 00    	je     20e954 <openSelfDebugInfo+0x4064>
  20bbd8:	48 8b 0d 51 54 01 00 	mov    rcx,QWORD PTR [rip+0x15451]        # 221030 <emfile_promise_queue+0x8>
  20bbdf:	48 85 c9             	test   rcx,rcx
  20bbe2:	0f 84 6c 2d 00 00    	je     20e954 <openSelfDebugInfo+0x4064>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  20bbe8:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  20bbec:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  20bbf0:	48 89 c1             	mov    rcx,rax
  20bbf3:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  20bbf7:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  20bbfd:	75 f1                	jne    20bbf0 <openSelfDebugInfo+0x1300>
  20bbff:	a8 01                	test   al,0x1
  20bc01:	75 02                	jne    20bc05 <openSelfDebugInfo+0x1315>
  20bc03:	ff 17                	call   QWORD PTR [rdi]
        self.freeFn(self, non_const_ptr[0..@sizeOf(@typeOf(ptr).Child)]);
  20bc05:	49 8b 44 24 10       	mov    rax,QWORD PTR [r12+0x10]
  20bc0a:	48 89 ac 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rbp
  20bc11:	00 
  20bc12:	48 c7 84 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],0xc8
  20bc19:	00 c8 00 00 00 
  20bc1e:	48 8d b4 24 f0 00 00 	lea    rsi,[rsp+0xf0]
  20bc25:	00 
  20bc26:	4c 89 e7             	mov    rdi,r12
  20bc29:	ff d0                	call   rax
            st.debug_str = (try st.elf.findSection(".debug_str")) orelse return error.MissingDebugInfo;
  20bc2b:	0f b7 84 24 20 03 00 	movzx  eax,WORD PTR [rsp+0x320]
  20bc32:	00 
  20bc33:	66 41 89 06          	mov    WORD PTR [r14],ax
  20bc37:	48 8b 84 24 cc 04 00 	mov    rax,QWORD PTR [rsp+0x4cc]
  20bc3e:	00 
  20bc3f:	48 8b 8c 24 d2 04 00 	mov    rcx,QWORD PTR [rsp+0x4d2]
  20bc46:	00 
  20bc47:	e9 bb f9 ff ff       	jmp    20b607 <openSelfDebugInfo+0xd17>
                list.first = node.next;
  20bc4c:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20bc50:	48 89 0d d1 53 01 00 	mov    QWORD PTR [rip+0x153d1],rcx        # 221028 <emfile_promise_queue>
            if (node.next) |next_node| {
  20bc57:	48 85 c9             	test   rcx,rcx
  20bc5a:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  20bc5d:	48 8d 35 cc 53 01 00 	lea    rsi,[rip+0x153cc]        # 221030 <emfile_promise_queue+0x8>
  20bc64:	48 0f 45 f1          	cmovne rsi,rcx
  20bc68:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  20bc6b:	48 83 05 c5 53 01 00 	add    QWORD PTR [rip+0x153c5],0xffffffffffffffff        # 221038 <emfile_promise_queue+0x10>
  20bc72:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  20bc73:	74 1e                	je     20bc93 <openSelfDebugInfo+0x13a3>
  20bc75:	48 83 3d ab 53 01 00 	cmp    QWORD PTR [rip+0x153ab],0x0        # 221028 <emfile_promise_queue>
  20bc7c:	00 
  20bc7d:	0f 84 d1 2c 00 00    	je     20e954 <openSelfDebugInfo+0x4064>
  20bc83:	48 8b 0d a6 53 01 00 	mov    rcx,QWORD PTR [rip+0x153a6]        # 221030 <emfile_promise_queue+0x8>
  20bc8a:	48 85 c9             	test   rcx,rcx
  20bc8d:	0f 84 c1 2c 00 00    	je     20e954 <openSelfDebugInfo+0x4064>
  20bc93:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  20bc97:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  20bc9b:	48 89 c1             	mov    rcx,rax
  20bc9e:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  20bca2:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  20bca8:	75 f1                	jne    20bc9b <openSelfDebugInfo+0x13ab>
  20bcaa:	a8 01                	test   al,0x1
  20bcac:	75 02                	jne    20bcb0 <openSelfDebugInfo+0x13c0>
  20bcae:	ff 17                	call   QWORD PTR [rdi]
  20bcb0:	48 63 7d 00          	movsxd rdi,DWORD PTR [rbp+0x0]
  20bcb4:	b8 03 00 00 00       	mov    eax,0x3
  20bcb9:	0f 05                	syscall 
            switch (err) {
  20bcbb:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  20bcbf:	74 f3                	je     20bcb4 <openSelfDebugInfo+0x13c4>
            const first = list.first orelse return null;
  20bcc1:	48 8b 05 60 53 01 00 	mov    rax,QWORD PTR [rip+0x15360]        # 221028 <emfile_promise_queue>
  20bcc8:	48 85 c0             	test   rax,rax
  20bccb:	0f 84 d2 fc ff ff    	je     20b9a3 <openSelfDebugInfo+0x10b3>
            if (node.prev) |prev_node| {
  20bcd1:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  20bcd4:	48 85 c9             	test   rcx,rcx
  20bcd7:	74 0e                	je     20bce7 <openSelfDebugInfo+0x13f7>
                prev_node.next = node.next;
  20bcd9:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  20bcdd:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  20bce1:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20bce5:	eb 0b                	jmp    20bcf2 <openSelfDebugInfo+0x1402>
                list.first = node.next;
  20bce7:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20bceb:	48 89 0d 36 53 01 00 	mov    QWORD PTR [rip+0x15336],rcx        # 221028 <emfile_promise_queue>
            if (node.next) |next_node| {
  20bcf2:	48 85 c9             	test   rcx,rcx
  20bcf5:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  20bcf8:	48 8d 35 31 53 01 00 	lea    rsi,[rip+0x15331]        # 221030 <emfile_promise_queue+0x8>
  20bcff:	48 0f 45 f1          	cmovne rsi,rcx
  20bd03:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  20bd06:	48 83 05 2a 53 01 00 	add    QWORD PTR [rip+0x1532a],0xffffffffffffffff        # 221038 <emfile_promise_queue+0x10>
  20bd0d:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  20bd0e:	74 1e                	je     20bd2e <openSelfDebugInfo+0x143e>
  20bd10:	48 83 3d 10 53 01 00 	cmp    QWORD PTR [rip+0x15310],0x0        # 221028 <emfile_promise_queue>
  20bd17:	00 
  20bd18:	0f 84 36 2c 00 00    	je     20e954 <openSelfDebugInfo+0x4064>
  20bd1e:	48 8b 0d 0b 53 01 00 	mov    rcx,QWORD PTR [rip+0x1530b]        # 221030 <emfile_promise_queue+0x8>
  20bd25:	48 85 c9             	test   rcx,rcx
  20bd28:	0f 84 26 2c 00 00    	je     20e954 <openSelfDebugInfo+0x4064>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  20bd2e:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  20bd32:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  20bd36:	48 89 c1             	mov    rcx,rax
  20bd39:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  20bd3d:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  20bd43:	75 f1                	jne    20bd36 <openSelfDebugInfo+0x1446>
  20bd45:	e9 53 fc ff ff       	jmp    20b99d <openSelfDebugInfo+0x10ad>
        const bytes = @sliceToBytes(memory);
  20bd4a:	48 8b 45 48          	mov    rax,QWORD PTR [rbp+0x48]
  20bd4e:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  20bd52:	74 26                	je     20bd7a <openSelfDebugInfo+0x148a>
  20bd54:	48 8b 7d 50          	mov    rdi,QWORD PTR [rbp+0x50]
        const bytes = @sliceToBytes(memory);
  20bd58:	48 8b 4d 40          	mov    rcx,QWORD PTR [rbp+0x40]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  20bd5c:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  20bd60:	48 89 8c 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rcx
  20bd67:	00 
  20bd68:	48 89 84 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],rax
  20bd6f:	00 
  20bd70:	48 8d b4 24 f0 00 00 	lea    rsi,[rsp+0xf0]
  20bd77:	00 
  20bd78:	ff d2                	call   rdx
  20bd7a:	80 7d 10 01          	cmp    BYTE PTR [rbp+0x10],0x1
  20bd7e:	0f 85 d7 19 00 00    	jne    20d75b <openSelfDebugInfo+0x2e6b>
  20bd84:	49 8b 07             	mov    rax,QWORD PTR [r15]
  20bd87:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  20bd8a:	b8 03 00 00 00       	mov    eax,0x3
  20bd8f:	0f 05                	syscall 
            switch (err) {
  20bd91:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  20bd95:	74 f3                	je     20bd8a <openSelfDebugInfo+0x149a>
            const first = list.first orelse return null;
  20bd97:	48 8b 05 8a 52 01 00 	mov    rax,QWORD PTR [rip+0x1528a]        # 221028 <emfile_promise_queue>
  20bd9e:	48 85 c0             	test   rax,rax
  20bda1:	0f 84 b4 19 00 00    	je     20d75b <openSelfDebugInfo+0x2e6b>
            if (node.prev) |prev_node| {
  20bda7:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  20bdaa:	48 85 c9             	test   rcx,rcx
  20bdad:	0f 84 44 19 00 00    	je     20d6f7 <openSelfDebugInfo+0x2e07>
                prev_node.next = node.next;
  20bdb3:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  20bdb7:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  20bdbb:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20bdbf:	e9 3e 19 00 00       	jmp    20d702 <openSelfDebugInfo+0x2e12>
            st.debug_ranges = (try st.elf.findSection(".debug_ranges"));
  20bdc4:	48 8b 84 24 08 03 00 	mov    rax,QWORD PTR [rsp+0x308]
  20bdcb:	00 
  20bdcc:	48 89 85 80 00 00 00 	mov    QWORD PTR [rbp+0x80],rax
    const debug_info_end = st.debug_info.offset + st.debug_info.size;
  20bdd3:	48 8b 45 60          	mov    rax,QWORD PTR [rbp+0x60]
  20bdd7:	48 8b 48 18          	mov    rcx,QWORD PTR [rax+0x18]
  20bddb:	48 89 4c 24 68       	mov    QWORD PTR [rsp+0x68],rcx
  20bde0:	48 8b 48 20          	mov    rcx,QWORD PTR [rax+0x20]
    var in_file_stream = io.FileInStream.init(&st.self_exe_file);
  20bde4:	48 89 ac 24 b0 01 00 	mov    QWORD PTR [rsp+0x1b0],rbp
  20bdeb:	00 
  20bdec:	48 8d 05 fd 3c 00 00 	lea    rax,[rip+0x3cfd]        # 20faf0 <FileInStream_readFn>
  20bdf3:	48 89 84 24 b8 01 00 	mov    QWORD PTR [rsp+0x1b8],rax
  20bdfa:	00 
  20bdfb:	48 89 8c 24 90 00 00 	mov    QWORD PTR [rsp+0x90],rcx
  20be02:	00 
    while (this_unit_offset < debug_info_end) {
  20be03:	48 85 c9             	test   rcx,rcx
  20be06:	0f 84 75 17 00 00    	je     20d581 <openSelfDebugInfo+0x2c91>
  20be0c:	48 8d 85 88 00 00 00 	lea    rax,[rbp+0x88]
  20be13:	48 89 84 24 68 02 00 	mov    QWORD PTR [rsp+0x268],rax
  20be1a:	00 
  20be1b:	48 8d 85 a8 00 00 00 	lea    rax,[rbp+0xa8]
  20be22:	48 89 44 24 70       	mov    QWORD PTR [rsp+0x70],rax
  20be27:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  20be2c:	48 01 84 24 90 00 00 	add    QWORD PTR [rsp+0x90],rax
  20be33:	00 
  20be34:	c4 e2 7d 19 05 23 44 	vbroadcastsd ymm0,QWORD PTR [rip+0xffffffffffff4423]        # 200260 <__unnamed_90+0x80>
  20be3b:	ff ff 
  20be3d:	c5 fc 11 84 24 40 05 	vmovups YMMWORD PTR [rsp+0x540],ymm0
  20be44:	00 00 
  20be46:	c4 e2 7d 59 05 81 44 	vpbroadcastq ymm0,QWORD PTR [rip+0xffffffffffff4481]        # 2002d0 <app_mask+0x50>
  20be4d:	ff ff 
  20be4f:	c5 fe 7f 84 24 20 05 	vmovdqu YMMWORD PTR [rsp+0x520],ymm0
  20be56:	00 00 
  20be58:	66 c7 84 24 c8 01 00 	mov    WORD PTR [rsp+0x1c8],0x20
  20be5f:	00 20 00 
  20be62:	31 c0                	xor    eax,eax
  20be64:	48 89 84 24 80 01 00 	mov    QWORD PTR [rsp+0x180],rax
  20be6b:	00 
    if (@maxValue(@typeOf(x)) > @maxValue(T) and x > @maxValue(T)) {
  20be6c:	48 83 7c 24 68 00    	cmp    QWORD PTR [rsp+0x68],0x0
  20be72:	0f 88 11 1a 00 00    	js     20d889 <openSelfDebugInfo+0x2f99>
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  20be78:	48 63 7d 00          	movsxd rdi,DWORD PTR [rbp+0x0]
    return asm volatile ("syscall"
  20be7c:	b8 08 00 00 00       	mov    eax,0x8
  20be81:	31 d2                	xor    edx,edx
  20be83:	48 8b 74 24 68       	mov    rsi,QWORD PTR [rsp+0x68]
  20be88:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  20be8a:	48 89 c1             	mov    rcx,rax
  20be8d:	48 f7 d9             	neg    rcx
  20be90:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  20be96:	b8 00 00 00 00       	mov    eax,0x0
  20be9b:	48 0f 46 c8          	cmovbe rcx,rax
                if (err > 0) {
  20be9f:	48 85 c9             	test   rcx,rcx
  20bea2:	0f 85 09 1a 00 00    	jne    20d8b1 <openSelfDebugInfo+0x2fc1>
            try self.readNoEof(bytes[0..]);
  20bea8:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  20bead:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  20beb4:	00 
  20beb5:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x4
  20bebc:	00 04 00 00 00 
            return self.readFn(self, buffer);
  20bec1:	48 89 df             	mov    rdi,rbx
  20bec4:	48 8d b4 24 b8 01 00 	lea    rsi,[rsp+0x1b8]
  20becb:	00 
  20becc:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  20bed3:	00 
  20bed4:	c5 f8 77             	vzeroupper 
  20bed7:	ff 94 24 b8 01 00 00 	call   QWORD PTR [rsp+0x1b8]
  20bede:	0f b7 8c 24 f0 00 00 	movzx  ecx,WORD PTR [rsp+0xf0]
  20bee5:	00 
  20bee6:	89 c8                	mov    eax,ecx
            const amt_read = try self.read(buf);
  20bee8:	66 85 c9             	test   cx,cx
  20beeb:	0f 85 46 19 00 00    	jne    20d837 <openSelfDebugInfo+0x2f47>
  20bef1:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  20bef8:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  20bef9:	48 3b 84 24 a0 00 00 	cmp    rax,QWORD PTR [rsp+0xa0]
  20bf00:	00 
  20bf01:	0f 82 2c 19 00 00    	jb     20d833 <openSelfDebugInfo+0x2f43>
  20bf07:	0f b6 44 24 20       	movzx  eax,BYTE PTR [rsp+0x20]
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20bf0c:	0f b6 4c 24 21       	movzx  ecx,BYTE PTR [rsp+0x21]
  20bf11:	48 c1 e1 08          	shl    rcx,0x8
  20bf15:	48 09 c1             	or     rcx,rax
  20bf18:	0f b6 44 24 22       	movzx  eax,BYTE PTR [rsp+0x22]
  20bf1d:	48 c1 e0 10          	shl    rax,0x10
  20bf21:	48 09 c8             	or     rax,rcx
  20bf24:	0f b6 4c 24 23       	movzx  ecx,BYTE PTR [rsp+0x23]
  20bf29:	48 c1 e1 18          	shl    rcx,0x18
  20bf2d:	48 09 c1             	or     rcx,rax
  20bf30:	48 89 4c 24 78       	mov    QWORD PTR [rsp+0x78],rcx
    is_64.* = (first_32_bits == 0xffffffff);
  20bf35:	83 f9 ff             	cmp    ecx,0xffffffff
    if (is_64.*) {
  20bf38:	74 27                	je     20bf61 <openSelfDebugInfo+0x1671>
        if (first_32_bits >= 0xfffffff0) return error.InvalidDebugInfo;
  20bf3a:	83 7c 24 78 ef       	cmp    DWORD PTR [rsp+0x78],0xffffffef
  20bf3f:	0f 87 58 19 00 00    	ja     20d89d <openSelfDebugInfo+0x2fad>
  20bf45:	c7 84 24 80 00 00 00 	mov    DWORD PTR [rsp+0x80],0x0
  20bf4c:	00 00 00 00 
        if (unit_length == 0) return;
  20bf50:	48 83 7c 24 78 00    	cmp    QWORD PTR [rsp+0x78],0x0
  20bf56:	0f 85 86 00 00 00    	jne    20bfe2 <openSelfDebugInfo+0x16f2>
  20bf5c:	e9 20 16 00 00       	jmp    20d581 <openSelfDebugInfo+0x2c91>
            try self.readNoEof(bytes[0..]);
  20bf61:	48 8d 84 24 d8 03 00 	lea    rax,[rsp+0x3d8]
  20bf68:	00 
  20bf69:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  20bf70:	00 
  20bf71:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x8
  20bf78:	00 08 00 00 00 
            return self.readFn(self, buffer);
  20bf7d:	48 89 df             	mov    rdi,rbx
  20bf80:	48 8d b4 24 b8 01 00 	lea    rsi,[rsp+0x1b8]
  20bf87:	00 
  20bf88:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  20bf8f:	00 
  20bf90:	ff 94 24 b8 01 00 00 	call   QWORD PTR [rsp+0x1b8]
  20bf97:	0f b7 8c 24 f0 00 00 	movzx  ecx,WORD PTR [rsp+0xf0]
  20bf9e:	00 
  20bf9f:	89 c8                	mov    eax,ecx
            const amt_read = try self.read(buf);
  20bfa1:	66 85 c9             	test   cx,cx
  20bfa4:	0f 85 8d 18 00 00    	jne    20d837 <openSelfDebugInfo+0x2f47>
  20bfaa:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  20bfb1:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  20bfb2:	48 3b 84 24 a0 00 00 	cmp    rax,QWORD PTR [rsp+0xa0]
  20bfb9:	00 
  20bfba:	0f 82 73 18 00 00    	jb     20d833 <openSelfDebugInfo+0x2f43>
  20bfc0:	48 8b 84 24 d8 03 00 	mov    rax,QWORD PTR [rsp+0x3d8]
  20bfc7:	00 
  20bfc8:	48 89 44 24 78       	mov    QWORD PTR [rsp+0x78],rax
  20bfcd:	b0 01                	mov    al,0x1
        const unit_length = try readInitialLength(@typeOf(in_stream.readFn).ReturnType.ErrorSet, in_stream, &is_64);
  20bfcf:	89 84 24 80 00 00 00 	mov    DWORD PTR [rsp+0x80],eax
        if (unit_length == 0) return;
  20bfd6:	48 83 7c 24 78 00    	cmp    QWORD PTR [rsp+0x78],0x0
  20bfdc:	0f 84 9f 15 00 00    	je     20d581 <openSelfDebugInfo+0x2c91>
        const version = try in_stream.readInt(st.elf.endian, u16);
  20bfe2:	44 8a 6d 12          	mov    r13b,BYTE PTR [rbp+0x12]
            try self.readNoEof(bytes[0..]);
  20bfe6:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  20bfeb:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  20bff2:	00 
  20bff3:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x2
  20bffa:	00 02 00 00 00 
            return self.readFn(self, buffer);
  20bfff:	48 89 df             	mov    rdi,rbx
  20c002:	48 8d b4 24 b8 01 00 	lea    rsi,[rsp+0x1b8]
  20c009:	00 
  20c00a:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  20c011:	00 
  20c012:	ff 94 24 b8 01 00 00 	call   QWORD PTR [rsp+0x1b8]
  20c019:	0f b7 8c 24 f0 00 00 	movzx  ecx,WORD PTR [rsp+0xf0]
  20c020:	00 
  20c021:	89 c8                	mov    eax,ecx
            const amt_read = try self.read(buf);
  20c023:	66 85 c9             	test   cx,cx
  20c026:	0f 85 0b 18 00 00    	jne    20d837 <openSelfDebugInfo+0x2f47>
  20c02c:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  20c033:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  20c034:	48 3b 84 24 a0 00 00 	cmp    rax,QWORD PTR [rsp+0xa0]
  20c03b:	00 
  20c03c:	0f 82 f1 17 00 00    	jb     20d833 <openSelfDebugInfo+0x2f43>
  20c042:	0f b6 54 24 20       	movzx  edx,BYTE PTR [rsp+0x20]
  20c047:	0f b6 44 24 21       	movzx  eax,BYTE PTR [rsp+0x21]
  20c04c:	89 c1                	mov    ecx,eax
  20c04e:	c1 e1 08             	shl    ecx,0x8
  20c051:	09 d1                	or     ecx,edx
                result = (result << 8) | b;
  20c053:	c1 e2 08             	shl    edx,0x8
  20c056:	09 c2                	or     edx,eax
    switch (endian) {
  20c058:	41 f6 c5 01          	test   r13b,0x1
  20c05c:	66 0f 45 d1          	cmovne dx,cx
  20c060:	48 89 94 24 f8 02 00 	mov    QWORD PTR [rsp+0x2f8],rdx
  20c067:	00 
        if (version < 2 or version > 5) return error.InvalidDebugInfo;
  20c068:	8d 42 fe             	lea    eax,[rdx-0x2]
  20c06b:	0f b7 c0             	movzx  eax,ax
  20c06e:	83 f8 03             	cmp    eax,0x3
  20c071:	0f 87 26 18 00 00    	ja     20d89d <openSelfDebugInfo+0x2fad>
  20c077:	44 8a 6d 12          	mov    r13b,BYTE PTR [rbp+0x12]
        const debug_abbrev_offset = if (is_64) try in_stream.readInt(st.elf.endian, u64) else try in_stream.readInt(st.elf.endian, u32);
  20c07b:	80 bc 24 80 00 00 00 	cmp    BYTE PTR [rsp+0x80],0x0
  20c082:	00 
  20c083:	74 37                	je     20c0bc <openSelfDebugInfo+0x17cc>
  20c085:	41 0f b6 d5          	movzx  edx,r13b
  20c089:	48 8d bc 24 c8 03 00 	lea    rdi,[rsp+0x3c8]
  20c090:	00 
  20c091:	48 8d b4 24 b8 01 00 	lea    rsi,[rsp+0x1b8]
  20c098:	00 
  20c099:	e8 f2 37 00 00       	call   20f890 <InStream(ReadError)_readInt.30>
  20c09e:	0f b7 bc 24 c8 03 00 	movzx  edi,WORD PTR [rsp+0x3c8]
  20c0a5:	00 
  20c0a6:	66 85 ff             	test   di,di
  20c0a9:	0f 85 c9 18 00 00    	jne    20d978 <openSelfDebugInfo+0x3088>
  20c0af:	48 8b 84 24 d0 03 00 	mov    rax,QWORD PTR [rsp+0x3d0]
  20c0b6:	00 
  20c0b7:	e9 a2 00 00 00       	jmp    20c15e <openSelfDebugInfo+0x186e>
            try self.readNoEof(bytes[0..]);
  20c0bc:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  20c0c1:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  20c0c8:	00 
  20c0c9:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x4
  20c0d0:	00 04 00 00 00 
            return self.readFn(self, buffer);
  20c0d5:	48 89 df             	mov    rdi,rbx
  20c0d8:	48 8d b4 24 b8 01 00 	lea    rsi,[rsp+0x1b8]
  20c0df:	00 
  20c0e0:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  20c0e7:	00 
  20c0e8:	ff 94 24 b8 01 00 00 	call   QWORD PTR [rsp+0x1b8]
  20c0ef:	0f b7 8c 24 f0 00 00 	movzx  ecx,WORD PTR [rsp+0xf0]
  20c0f6:	00 
  20c0f7:	89 c8                	mov    eax,ecx
            const amt_read = try self.read(buf);
  20c0f9:	66 85 c9             	test   cx,cx
  20c0fc:	0f 85 35 17 00 00    	jne    20d837 <openSelfDebugInfo+0x2f47>
  20c102:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  20c109:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  20c10a:	48 3b 84 24 a0 00 00 	cmp    rax,QWORD PTR [rsp+0xa0]
  20c111:	00 
  20c112:	0f 82 1b 17 00 00    	jb     20d833 <openSelfDebugInfo+0x2f43>
  20c118:	0f b6 44 24 20       	movzx  eax,BYTE PTR [rsp+0x20]
  20c11d:	0f b6 4c 24 21       	movzx  ecx,BYTE PTR [rsp+0x21]
  20c122:	41 f6 c5 01          	test   r13b,0x1
  20c126:	74 1b                	je     20c143 <openSelfDebugInfo+0x1853>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20c128:	c1 e1 08             	shl    ecx,0x8
  20c12b:	09 c1                	or     ecx,eax
  20c12d:	0f b6 54 24 22       	movzx  edx,BYTE PTR [rsp+0x22]
  20c132:	c1 e2 10             	shl    edx,0x10
  20c135:	09 ca                	or     edx,ecx
  20c137:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  20c13c:	c1 e0 18             	shl    eax,0x18
  20c13f:	09 d0                	or     eax,edx
  20c141:	eb 19                	jmp    20c15c <openSelfDebugInfo+0x186c>
                result = (result << 8) | b;
  20c143:	c1 e0 08             	shl    eax,0x8
  20c146:	09 c8                	or     eax,ecx
  20c148:	c1 e0 08             	shl    eax,0x8
  20c14b:	0f b6 4c 24 22       	movzx  ecx,BYTE PTR [rsp+0x22]
  20c150:	09 c1                	or     ecx,eax
  20c152:	c1 e1 08             	shl    ecx,0x8
  20c155:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  20c15a:	09 c8                	or     eax,ecx
  20c15c:	89 c0                	mov    eax,eax
  20c15e:	48 89 44 24 48       	mov    QWORD PTR [rsp+0x48],rax
            try self.readNoEof(result[0..]);
  20c163:	48 8d 44 24 1f       	lea    rax,[rsp+0x1f]
  20c168:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  20c16f:	00 
  20c170:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x1
  20c177:	00 01 00 00 00 
            return self.readFn(self, buffer);
  20c17c:	48 89 df             	mov    rdi,rbx
  20c17f:	48 8d b4 24 b8 01 00 	lea    rsi,[rsp+0x1b8]
  20c186:	00 
  20c187:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  20c18e:	00 
  20c18f:	ff 94 24 b8 01 00 00 	call   QWORD PTR [rsp+0x1b8]
  20c196:	0f b7 8c 24 f0 00 00 	movzx  ecx,WORD PTR [rsp+0xf0]
  20c19d:	00 
  20c19e:	89 c8                	mov    eax,ecx
            const amt_read = try self.read(buf);
  20c1a0:	66 85 c9             	test   cx,cx
  20c1a3:	0f 85 8e 16 00 00    	jne    20d837 <openSelfDebugInfo+0x2f47>
  20c1a9:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  20c1b0:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  20c1b1:	48 3b 84 24 a0 00 00 	cmp    rax,QWORD PTR [rsp+0xa0]
  20c1b8:	00 
  20c1b9:	0f 82 74 16 00 00    	jb     20d833 <openSelfDebugInfo+0x2f43>
        if (address_size != @sizeOf(usize)) return error.InvalidDebugInfo;
  20c1bf:	80 7c 24 1f 08       	cmp    BYTE PTR [rsp+0x1f],0x8
  20c1c4:	66 bf 23 00          	mov    di,0x23
  20c1c8:	0f 85 aa 17 00 00    	jne    20d978 <openSelfDebugInfo+0x3088>
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  20c1ce:	48 63 7d 00          	movsxd rdi,DWORD PTR [rbp+0x0]
  20c1d2:	b8 08 00 00 00       	mov    eax,0x8
  20c1d7:	be 00 00 00 00       	mov    esi,0x0
  20c1dc:	ba 01 00 00 00       	mov    edx,0x1
  20c1e1:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  20c1e3:	48 89 c6             	mov    rsi,rax
  20c1e6:	48 f7 de             	neg    rsi
  20c1e9:	48 89 84 24 88 00 00 	mov    QWORD PTR [rsp+0x88],rax
  20c1f0:	00 
  20c1f1:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  20c1f7:	b9 00 00 00 00       	mov    ecx,0x0
  20c1fc:	48 0f 46 f1          	cmovbe rsi,rcx
    pub fn getPos(self: *File) !usize {
        switch (builtin.os) {
            Os.linux, Os.macosx, Os.ios => {
                const result = posix.lseek(self.handle, 0, posix.SEEK_CUR);
                const err = posix.getErrno(result);
                if (err > 0) {
  20c200:	48 85 f6             	test   rsi,rsi
  20c203:	0f 85 33 17 00 00    	jne    20d93c <openSelfDebugInfo+0x304c>
            return self.items[0..self.len];
  20c209:	48 8b 85 98 00 00 00 	mov    rax,QWORD PTR [rbp+0x98]
    for (st.abbrev_table_list.toSlice()) |*header| {
  20c210:	48 85 c0             	test   rax,rax
  20c213:	48 8b 54 24 48       	mov    rdx,QWORD PTR [rsp+0x48]
  20c218:	74 24                	je     20c23e <openSelfDebugInfo+0x194e>
  20c21a:	4c 8b ad 88 00 00 00 	mov    r13,QWORD PTR [rbp+0x88]
        if (header.offset == abbrev_offset) {
  20c221:	49 83 c5 08          	add    r13,0x8
  20c225:	31 c9                	xor    ecx,ecx
  20c227:	49 39 55 f8          	cmp    QWORD PTR [r13-0x8],rdx
  20c22b:	0f 84 7d 08 00 00    	je     20caae <openSelfDebugInfo+0x21be>
    for (st.abbrev_table_list.toSlice()) |*header| {
  20c231:	48 83 c1 01          	add    rcx,0x1
  20c235:	49 83 c5 28          	add    r13,0x28
  20c239:	48 39 c1             	cmp    rcx,rax
  20c23c:	72 e9                	jb     20c227 <openSelfDebugInfo+0x1937>
    try st.self_exe_file.seekTo(st.debug_abbrev.offset + abbrev_offset);
  20c23e:	48 8b 45 68          	mov    rax,QWORD PTR [rbp+0x68]
  20c242:	48 8b 70 18          	mov    rsi,QWORD PTR [rax+0x18]
  20c246:	48 01 d6             	add    rsi,rdx
  20c249:	0f 88 3a 16 00 00    	js     20d889 <openSelfDebugInfo+0x2f99>
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  20c24f:	48 63 7d 00          	movsxd rdi,DWORD PTR [rbp+0x0]
  20c253:	b8 08 00 00 00       	mov    eax,0x8
  20c258:	31 d2                	xor    edx,edx
  20c25a:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  20c25c:	48 89 c1             	mov    rcx,rax
  20c25f:	48 f7 d9             	neg    rcx
  20c262:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  20c268:	b8 00 00 00 00       	mov    eax,0x0
  20c26d:	48 0f 46 c8          	cmovbe rcx,rax
                if (err > 0) {
  20c271:	48 85 c9             	test   rcx,rcx
  20c274:	0f 85 be 18 00 00    	jne    20db38 <openSelfDebugInfo+0x3248>
    var in_file_stream = io.FileInStream.init(in_file);
  20c27a:	48 89 ac 24 88 01 00 	mov    QWORD PTR [rsp+0x188],rbp
  20c281:	00 
  20c282:	48 8d 05 67 38 00 00 	lea    rax,[rip+0x3867]        # 20faf0 <FileInStream_readFn>
  20c289:	48 89 84 24 90 01 00 	mov    QWORD PTR [rsp+0x190],rax
  20c290:	00 
  20c291:	48 8b 85 a0 00 00 00 	mov    rax,QWORD PTR [rbp+0xa0]
            return Self{
  20c298:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  20c29c:	c5 f9 7f 84 24 10 02 	vmovdqa XMMWORD PTR [rsp+0x210],xmm0
  20c2a3:	00 00 
  20c2a5:	48 c7 84 24 20 02 00 	mov    QWORD PTR [rsp+0x220],0x0
  20c2ac:	00 00 00 00 00 
  20c2b1:	48 89 84 24 30 02 00 	mov    QWORD PTR [rsp+0x230],rax
  20c2b8:	00 
    var result = AbbrevTable.init(st.allocator());
  20c2b9:	48 89 84 24 28 02 00 	mov    QWORD PTR [rsp+0x228],rax
  20c2c0:	00 
            try self.readNoEof(result[0..]);
  20c2c1:	48 8d 44 24 1f       	lea    rax,[rsp+0x1f]
  20c2c6:	48 89 84 24 00 02 00 	mov    QWORD PTR [rsp+0x200],rax
  20c2cd:	00 
  20c2ce:	48 c7 84 24 08 02 00 	mov    QWORD PTR [rsp+0x208],0x1
  20c2d5:	00 01 00 00 00 
        return self.file.read(buffer);
  20c2da:	48 8b b4 24 88 01 00 	mov    rsi,QWORD PTR [rsp+0x188]
  20c2e1:	00 
  20c2e2:	48 8d 7c 24 50       	lea    rdi,[rsp+0x50]
  20c2e7:	48 8d 94 24 00 02 00 	lea    rdx,[rsp+0x200]
  20c2ee:	00 
  20c2ef:	e8 cc 36 00 00       	call   20f9c0 <File_read>
  20c2f4:	c5 fa 6f 44 24 50    	vmovdqu xmm0,XMMWORD PTR [rsp+0x50]
  20c2fa:	c5 f9 7f 84 24 d0 00 	vmovdqa XMMWORD PTR [rsp+0xd0],xmm0
  20c301:	00 00 
            return self.readFn(self, buffer);
  20c303:	0f b7 8c 24 d0 00 00 	movzx  ecx,WORD PTR [rsp+0xd0]
  20c30a:	00 
            const amt_read = try self.read(buf);
  20c30b:	66 85 c9             	test   cx,cx
  20c30e:	0f 85 eb 14 00 00    	jne    20d7ff <openSelfDebugInfo+0x2f0f>
  20c314:	48 8b 84 24 d8 00 00 	mov    rax,QWORD PTR [rsp+0xd8]
  20c31b:	00 
  20c31c:	31 c9                	xor    ecx,ecx
  20c31e:	48 89 8c 24 c0 01 00 	mov    QWORD PTR [rsp+0x1c0],rcx
  20c325:	00 
  20c326:	31 c9                	xor    ecx,ecx
  20c328:	48 89 8c 24 a0 01 00 	mov    QWORD PTR [rsp+0x1a0],rcx
  20c32f:	00 
  20c330:	31 c9                	xor    ecx,ecx
  20c332:	48 89 4c 24 40       	mov    QWORD PTR [rsp+0x40],rcx
  20c337:	45 31 ed             	xor    r13d,r13d
            if (amt_read < buf.len) return error.EndOfStream;
  20c33a:	48 3b 84 24 08 02 00 	cmp    rax,QWORD PTR [rsp+0x208]
  20c341:	00 
  20c342:	0f 82 ad 14 00 00    	jb     20d7f5 <openSelfDebugInfo+0x2f05>
            return result[0];
  20c348:	0f b6 44 24 1f       	movzx  eax,BYTE PTR [rsp+0x1f]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  20c34d:	89 c2                	mov    edx,eax
  20c34f:	83 e2 7f             	and    edx,0x7f
  20c352:	44 89 ee             	mov    esi,r13d
  20c355:	83 e6 3f             	and    esi,0x3f
  20c358:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  20c35d:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  20c362:	48 39 d6             	cmp    rsi,rdx
  20c365:	0f 85 90 14 00 00    	jne    20d7fb <openSelfDebugInfo+0x2f0b>
        result |= operand;
  20c36b:	48 09 4c 24 40       	or     QWORD PTR [rsp+0x40],rcx
        if ((byte & 0b10000000) == 0) return result;
  20c370:	84 c0                	test   al,al
  20c372:	79 5a                	jns    20c3ce <openSelfDebugInfo+0x1ade>
        shift += 7;
  20c374:	49 83 c5 07          	add    r13,0x7
            try self.readNoEof(result[0..]);
  20c378:	48 8d 44 24 1f       	lea    rax,[rsp+0x1f]
  20c37d:	48 89 84 24 00 02 00 	mov    QWORD PTR [rsp+0x200],rax
  20c384:	00 
  20c385:	48 c7 84 24 08 02 00 	mov    QWORD PTR [rsp+0x208],0x1
  20c38c:	00 01 00 00 00 
            return self.readFn(self, buffer);
  20c391:	48 8d bc 24 d0 00 00 	lea    rdi,[rsp+0xd0]
  20c398:	00 
  20c399:	48 8d b4 24 90 01 00 	lea    rsi,[rsp+0x190]
  20c3a0:	00 
  20c3a1:	48 8d 94 24 00 02 00 	lea    rdx,[rsp+0x200]
  20c3a8:	00 
  20c3a9:	ff 94 24 90 01 00 00 	call   QWORD PTR [rsp+0x190]
  20c3b0:	0f b7 8c 24 d0 00 00 	movzx  ecx,WORD PTR [rsp+0xd0]
  20c3b7:	00 
  20c3b8:	48 8b 84 24 d8 00 00 	mov    rax,QWORD PTR [rsp+0xd8]
  20c3bf:	00 
            const amt_read = try self.read(buf);
  20c3c0:	66 85 c9             	test   cx,cx
  20c3c3:	0f 84 71 ff ff ff    	je     20c33a <openSelfDebugInfo+0x1a4a>
  20c3c9:	e9 31 14 00 00       	jmp    20d7ff <openSelfDebugInfo+0x2f0f>
        if (abbrev_code == 0) return result;
  20c3ce:	48 83 7c 24 40 00    	cmp    QWORD PTR [rsp+0x40],0x0
  20c3d4:	0f 84 ca 05 00 00    	je     20c9a4 <openSelfDebugInfo+0x20b4>
            try self.readNoEof(result[0..]);
  20c3da:	48 8d 44 24 1f       	lea    rax,[rsp+0x1f]
  20c3df:	48 89 84 24 d0 00 00 	mov    QWORD PTR [rsp+0xd0],rax
  20c3e6:	00 
  20c3e7:	48 c7 84 24 d8 00 00 	mov    QWORD PTR [rsp+0xd8],0x1
  20c3ee:	00 01 00 00 00 
            return self.readFn(self, buffer);
  20c3f3:	48 8d 7c 24 50       	lea    rdi,[rsp+0x50]
  20c3f8:	48 8d b4 24 90 01 00 	lea    rsi,[rsp+0x190]
  20c3ff:	00 
  20c400:	48 8d 94 24 d0 00 00 	lea    rdx,[rsp+0xd0]
  20c407:	00 
  20c408:	ff 94 24 90 01 00 00 	call   QWORD PTR [rsp+0x190]
  20c40f:	0f b7 44 24 50       	movzx  eax,WORD PTR [rsp+0x50]
  20c414:	89 c1                	mov    ecx,eax
            const amt_read = try self.read(buf);
  20c416:	66 85 c0             	test   ax,ax
  20c419:	0f 85 ff 14 00 00    	jne    20d91e <openSelfDebugInfo+0x302e>
  20c41f:	48 8b 44 24 58       	mov    rax,QWORD PTR [rsp+0x58]
  20c424:	31 c9                	xor    ecx,ecx
  20c426:	48 89 8c 24 98 01 00 	mov    QWORD PTR [rsp+0x198],rcx
  20c42d:	00 
  20c42e:	45 31 ed             	xor    r13d,r13d
            if (amt_read < buf.len) return error.EndOfStream;
  20c431:	48 3b 84 24 d8 00 00 	cmp    rax,QWORD PTR [rsp+0xd8]
  20c438:	00 
  20c439:	0f 82 d5 14 00 00    	jb     20d914 <openSelfDebugInfo+0x3024>
            return result[0];
  20c43f:	0f b6 44 24 1f       	movzx  eax,BYTE PTR [rsp+0x1f]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  20c444:	89 c2                	mov    edx,eax
  20c446:	83 e2 7f             	and    edx,0x7f
  20c449:	44 89 ee             	mov    esi,r13d
  20c44c:	83 e6 3f             	and    esi,0x3f
  20c44f:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  20c454:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  20c459:	48 39 d6             	cmp    rsi,rdx
  20c45c:	0f 85 b8 14 00 00    	jne    20d91a <openSelfDebugInfo+0x302a>
        result |= operand;
  20c462:	48 09 8c 24 98 01 00 	or     QWORD PTR [rsp+0x198],rcx
  20c469:	00 
        if ((byte & 0b10000000) == 0) return result;
  20c46a:	84 c0                	test   al,al
  20c46c:	79 53                	jns    20c4c1 <openSelfDebugInfo+0x1bd1>
        shift += 7;
  20c46e:	49 83 c5 07          	add    r13,0x7
            try self.readNoEof(result[0..]);
  20c472:	48 8d 44 24 1f       	lea    rax,[rsp+0x1f]
  20c477:	48 89 84 24 d0 00 00 	mov    QWORD PTR [rsp+0xd0],rax
  20c47e:	00 
  20c47f:	48 c7 84 24 d8 00 00 	mov    QWORD PTR [rsp+0xd8],0x1
  20c486:	00 01 00 00 00 
            return self.readFn(self, buffer);
  20c48b:	48 8d 7c 24 50       	lea    rdi,[rsp+0x50]
  20c490:	48 8d b4 24 90 01 00 	lea    rsi,[rsp+0x190]
  20c497:	00 
  20c498:	48 8d 94 24 d0 00 00 	lea    rdx,[rsp+0xd0]
  20c49f:	00 
  20c4a0:	ff 94 24 90 01 00 00 	call   QWORD PTR [rsp+0x190]
  20c4a7:	0f b7 54 24 50       	movzx  edx,WORD PTR [rsp+0x50]
  20c4ac:	48 8b 44 24 58       	mov    rax,QWORD PTR [rsp+0x58]
  20c4b1:	89 d1                	mov    ecx,edx
            const amt_read = try self.read(buf);
  20c4b3:	66 85 d2             	test   dx,dx
  20c4b6:	0f 84 75 ff ff ff    	je     20c431 <openSelfDebugInfo+0x1b41>
  20c4bc:	e9 5d 14 00 00       	jmp    20d91e <openSelfDebugInfo+0x302e>
            try self.readNoEof(result[0..]);
  20c4c1:	48 8d 44 24 1f       	lea    rax,[rsp+0x1f]
  20c4c6:	48 89 84 24 d0 00 00 	mov    QWORD PTR [rsp+0xd0],rax
  20c4cd:	00 
  20c4ce:	48 c7 84 24 d8 00 00 	mov    QWORD PTR [rsp+0xd8],0x1
  20c4d5:	00 01 00 00 00 
            return self.readFn(self, buffer);
  20c4da:	48 8d 7c 24 50       	lea    rdi,[rsp+0x50]
  20c4df:	48 8d b4 24 90 01 00 	lea    rsi,[rsp+0x190]
  20c4e6:	00 
  20c4e7:	48 8d 94 24 d0 00 00 	lea    rdx,[rsp+0xd0]
  20c4ee:	00 
  20c4ef:	ff 94 24 90 01 00 00 	call   QWORD PTR [rsp+0x190]
  20c4f6:	0f b7 44 24 50       	movzx  eax,WORD PTR [rsp+0x50]
  20c4fb:	89 c1                	mov    ecx,eax
            const amt_read = try self.read(buf);
  20c4fd:	66 85 c0             	test   ax,ax
  20c500:	0f 85 f8 16 00 00    	jne    20dbfe <openSelfDebugInfo+0x330e>
  20c506:	48 8b 44 24 58       	mov    rax,QWORD PTR [rsp+0x58]
            if (amt_read < buf.len) return error.EndOfStream;
  20c50b:	48 3b 84 24 d8 00 00 	cmp    rax,QWORD PTR [rsp+0xd8]
  20c512:	00 
  20c513:	0f 82 e1 16 00 00    	jb     20dbfa <openSelfDebugInfo+0x330a>
  20c519:	48 8b 85 a0 00 00 00 	mov    rax,QWORD PTR [rbp+0xa0]
  20c520:	48 89 84 24 a8 01 00 	mov    QWORD PTR [rsp+0x1a8],rax
  20c527:	00 
  20c528:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  20c52c:	c5 f9 7f 44 24 20    	vmovdqa XMMWORD PTR [rsp+0x20],xmm0
            return result[0];
  20c532:	8a 44 24 1f          	mov    al,BYTE PTR [rsp+0x1f]
  20c536:	88 84 24 ef 00 00 00 	mov    BYTE PTR [rsp+0xef],al
  20c53d:	48 c7 44 24 30 00 00 	mov    QWORD PTR [rsp+0x30],0x0
  20c544:	00 00 
            assert(new_len <= self.len);
            self.len = new_len;
        }

        pub fn ensureCapacity(self: *Self, new_capacity: usize) !void {
            var better_capacity = self.items.len;
  20c546:	48 8b 8c 24 18 02 00 	mov    rcx,QWORD PTR [rsp+0x218]
  20c54d:	00 
            if (better_capacity >= new_capacity) return;
  20c54e:	48 3b 8c 24 a0 01 00 	cmp    rcx,QWORD PTR [rsp+0x1a0]
  20c555:	00 
  20c556:	77 63                	ja     20c5bb <openSelfDebugInfo+0x1ccb>
            while (true) {
                better_capacity += better_capacity / 2 + 8;
  20c558:	48 89 c8             	mov    rax,rcx
  20c55b:	48 d1 e8             	shr    rax,1
  20c55e:	48 01 c1             	add    rcx,rax
  20c561:	48 83 c1 08          	add    rcx,0x8
                if (better_capacity >= new_capacity) break;
  20c565:	48 3b 8c 24 a0 01 00 	cmp    rcx,QWORD PTR [rsp+0x1a0]
  20c56c:	00 
  20c56d:	76 e9                	jbe    20c558 <openSelfDebugInfo+0x1c68>
            }
            self.items = try self.allocator.alignedRealloc(T, A, self.items, better_capacity);
  20c56f:	48 8d 7c 24 50       	lea    rdi,[rsp+0x50]
  20c574:	48 8b b4 24 30 02 00 	mov    rsi,QWORD PTR [rsp+0x230]
  20c57b:	00 
  20c57c:	48 8d 94 24 10 02 00 	lea    rdx,[rsp+0x210]
  20c583:	00 
  20c584:	e8 97 35 00 00       	call   20fb20 <Allocator_alignedRealloc>
  20c589:	0f b7 44 24 50       	movzx  eax,WORD PTR [rsp+0x50]
  20c58e:	89 c1                	mov    ecx,eax
  20c590:	66 85 c0             	test   ax,ax
  20c593:	0f 85 9a 16 00 00    	jne    20dc33 <openSelfDebugInfo+0x3343>
  20c599:	48 8d 44 24 58       	lea    rax,[rsp+0x58]
  20c59e:	c5 fa 6f 00          	vmovdqu xmm0,XMMWORD PTR [rax]
  20c5a2:	c5 f9 7f 84 24 10 02 	vmovdqa XMMWORD PTR [rsp+0x210],xmm0
  20c5a9:	00 00 
        }

        pub fn addOne(self: *Self) !*T {
            const new_length = self.len + 1;
            try self.ensureCapacity(new_length);
            const result = &self.items[self.len];
  20c5ab:	48 8b 84 24 10 02 00 	mov    rax,QWORD PTR [rsp+0x210]
  20c5b2:	00 
            try self.ensureCapacity(new_length);
  20c5b3:	48 89 84 24 c0 01 00 	mov    QWORD PTR [rsp+0x1c0],rax
  20c5ba:	00 
  20c5bb:	48 8b 84 24 a0 01 00 	mov    rax,QWORD PTR [rsp+0x1a0]
  20c5c2:	00 
  20c5c3:	48 89 c1             	mov    rcx,rax
            const result = &self.items[self.len];
  20c5c6:	4c 6b e9 38          	imul   r13,rcx,0x38
  20c5ca:	48 83 c1 01          	add    rcx,0x1
  20c5ce:	48 89 c8             	mov    rax,rcx
            self.len = new_length;
  20c5d1:	48 89 84 24 a0 01 00 	mov    QWORD PTR [rsp+0x1a0],rax
  20c5d8:	00 
  20c5d9:	48 89 8c 24 20 02 00 	mov    QWORD PTR [rsp+0x220],rcx
  20c5e0:	00 
            .has_children = (try in_stream.readByte()) == DW.CHILDREN_yes,
  20c5e1:	80 bc 24 ef 00 00 00 	cmp    BYTE PTR [rsp+0xef],0x1
  20c5e8:	01 
  20c5e9:	48 8b 84 24 c0 01 00 	mov    rax,QWORD PTR [rsp+0x1c0]
  20c5f0:	00 
  20c5f1:	48 89 c1             	mov    rcx,rax
            new_item_ptr.* = item;
  20c5f4:	42 0f 94 04 29       	sete   BYTE PTR [rcx+r13*1]
  20c5f9:	8a 84 24 3f 02 00 00 	mov    al,BYTE PTR [rsp+0x23f]
  20c600:	42 88 44 29 07       	mov    BYTE PTR [rcx+r13*1+0x7],al
  20c605:	0f b7 84 24 3d 02 00 	movzx  eax,WORD PTR [rsp+0x23d]
  20c60c:	00 
  20c60d:	66 42 89 44 29 05    	mov    WORD PTR [rcx+r13*1+0x5],ax
  20c613:	8b 84 24 39 02 00 00 	mov    eax,DWORD PTR [rsp+0x239]
  20c61a:	42 89 44 29 01       	mov    DWORD PTR [rcx+r13*1+0x1],eax
  20c61f:	48 8b 44 24 40       	mov    rax,QWORD PTR [rsp+0x40]
  20c624:	4a 89 44 29 08       	mov    QWORD PTR [rcx+r13*1+0x8],rax
  20c629:	48 8b 84 24 98 01 00 	mov    rax,QWORD PTR [rsp+0x198]
  20c630:	00 
  20c631:	4a 89 44 29 10       	mov    QWORD PTR [rcx+r13*1+0x10],rax
  20c636:	48 8b 44 24 30       	mov    rax,QWORD PTR [rsp+0x30]
  20c63b:	4a 89 44 29 28       	mov    QWORD PTR [rcx+r13*1+0x28],rax
  20c640:	c5 f9 6f 44 24 20    	vmovdqa xmm0,XMMWORD PTR [rsp+0x20]
  20c646:	c4 a1 7a 7f 44 29 18 	vmovdqu XMMWORD PTR [rcx+r13*1+0x18],xmm0
  20c64d:	48 8b 84 24 a8 01 00 	mov    rax,QWORD PTR [rsp+0x1a8]
  20c654:	00 
  20c655:	4a 89 44 29 30       	mov    QWORD PTR [rcx+r13*1+0x30],rax
            try self.readNoEof(result[0..]);
  20c65a:	48 8d 44 24 1f       	lea    rax,[rsp+0x1f]
  20c65f:	48 89 84 24 d0 00 00 	mov    QWORD PTR [rsp+0xd0],rax
  20c666:	00 
  20c667:	48 c7 84 24 d8 00 00 	mov    QWORD PTR [rsp+0xd8],0x1
  20c66e:	00 01 00 00 00 
            return self.readFn(self, buffer);
  20c673:	48 8d 7c 24 50       	lea    rdi,[rsp+0x50]
  20c678:	48 8d b4 24 90 01 00 	lea    rsi,[rsp+0x190]
  20c67f:	00 
  20c680:	48 8d 94 24 d0 00 00 	lea    rdx,[rsp+0xd0]
  20c687:	00 
  20c688:	ff 94 24 90 01 00 00 	call   QWORD PTR [rsp+0x190]
  20c68f:	0f b7 44 24 50       	movzx  eax,WORD PTR [rsp+0x50]
  20c694:	89 c1                	mov    ecx,eax
            const amt_read = try self.read(buf);
  20c696:	66 85 c0             	test   ax,ax
  20c699:	0f 85 3d 15 00 00    	jne    20dbdc <openSelfDebugInfo+0x32ec>
  20c69f:	48 8b 84 24 c0 01 00 	mov    rax,QWORD PTR [rsp+0x1c0]
  20c6a6:	00 
  20c6a7:	4c 01 e8             	add    rax,r13
  20c6aa:	48 83 c0 18          	add    rax,0x18
  20c6ae:	48 89 84 24 a8 01 00 	mov    QWORD PTR [rsp+0x1a8],rax
  20c6b5:	00 
  20c6b6:	48 8b 44 24 58       	mov    rax,QWORD PTR [rsp+0x58]
  20c6bb:	31 c9                	xor    ecx,ecx
  20c6bd:	48 89 8c 24 98 01 00 	mov    QWORD PTR [rsp+0x198],rcx
  20c6c4:	00 
  20c6c5:	45 31 ed             	xor    r13d,r13d
            if (amt_read < buf.len) return error.EndOfStream;
  20c6c8:	48 3b 84 24 d8 00 00 	cmp    rax,QWORD PTR [rsp+0xd8]
  20c6cf:	00 
  20c6d0:	0f 82 fc 14 00 00    	jb     20dbd2 <openSelfDebugInfo+0x32e2>
            return result[0];
  20c6d6:	0f b6 44 24 1f       	movzx  eax,BYTE PTR [rsp+0x1f]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  20c6db:	89 c2                	mov    edx,eax
  20c6dd:	83 e2 7f             	and    edx,0x7f
  20c6e0:	44 89 ee             	mov    esi,r13d
  20c6e3:	83 e6 3f             	and    esi,0x3f
  20c6e6:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  20c6eb:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  20c6f0:	48 39 d6             	cmp    rsi,rdx
  20c6f3:	0f 85 df 14 00 00    	jne    20dbd8 <openSelfDebugInfo+0x32e8>
        result |= operand;
  20c6f9:	48 09 8c 24 98 01 00 	or     QWORD PTR [rsp+0x198],rcx
  20c700:	00 
        if ((byte & 0b10000000) == 0) return result;
  20c701:	84 c0                	test   al,al
  20c703:	0f 88 e5 00 00 00    	js     20c7ee <openSelfDebugInfo+0x1efe>
            try self.readNoEof(result[0..]);
  20c709:	48 8d 44 24 1f       	lea    rax,[rsp+0x1f]
  20c70e:	48 89 84 24 d0 00 00 	mov    QWORD PTR [rsp+0xd0],rax
  20c715:	00 
  20c716:	48 c7 84 24 d8 00 00 	mov    QWORD PTR [rsp+0xd8],0x1
  20c71d:	00 01 00 00 00 
            return self.readFn(self, buffer);
  20c722:	48 8d 7c 24 50       	lea    rdi,[rsp+0x50]
  20c727:	48 8d b4 24 90 01 00 	lea    rsi,[rsp+0x190]
  20c72e:	00 
  20c72f:	48 8d 94 24 d0 00 00 	lea    rdx,[rsp+0xd0]
  20c736:	00 
  20c737:	ff 94 24 90 01 00 00 	call   QWORD PTR [rsp+0x190]
  20c73e:	0f b7 44 24 50       	movzx  eax,WORD PTR [rsp+0x50]
  20c743:	89 c1                	mov    ecx,eax
            const amt_read = try self.read(buf);
  20c745:	66 85 c0             	test   ax,ax
  20c748:	0f 85 66 14 00 00    	jne    20dbb4 <openSelfDebugInfo+0x32c4>
  20c74e:	48 8b 44 24 58       	mov    rax,QWORD PTR [rsp+0x58]
  20c753:	31 c9                	xor    ecx,ecx
  20c755:	48 89 4c 24 40       	mov    QWORD PTR [rsp+0x40],rcx
  20c75a:	45 31 ed             	xor    r13d,r13d
            if (amt_read < buf.len) return error.EndOfStream;
  20c75d:	48 3b 84 24 d8 00 00 	cmp    rax,QWORD PTR [rsp+0xd8]
  20c764:	00 
  20c765:	0f 82 3f 14 00 00    	jb     20dbaa <openSelfDebugInfo+0x32ba>
            return result[0];
  20c76b:	0f b6 44 24 1f       	movzx  eax,BYTE PTR [rsp+0x1f]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  20c770:	89 c2                	mov    edx,eax
  20c772:	83 e2 7f             	and    edx,0x7f
  20c775:	44 89 ee             	mov    esi,r13d
  20c778:	83 e6 3f             	and    esi,0x3f
  20c77b:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  20c780:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  20c785:	48 39 d6             	cmp    rsi,rdx
  20c788:	0f 85 22 14 00 00    	jne    20dbb0 <openSelfDebugInfo+0x32c0>
        result |= operand;
  20c78e:	48 09 4c 24 40       	or     QWORD PTR [rsp+0x40],rcx
        if ((byte & 0b10000000) == 0) return result;
  20c793:	84 c0                	test   al,al
  20c795:	0f 89 a6 00 00 00    	jns    20c841 <openSelfDebugInfo+0x1f51>
        shift += 7;
  20c79b:	49 83 c5 07          	add    r13,0x7
            try self.readNoEof(result[0..]);
  20c79f:	48 8d 44 24 1f       	lea    rax,[rsp+0x1f]
  20c7a4:	48 89 84 24 d0 00 00 	mov    QWORD PTR [rsp+0xd0],rax
  20c7ab:	00 
  20c7ac:	48 c7 84 24 d8 00 00 	mov    QWORD PTR [rsp+0xd8],0x1
  20c7b3:	00 01 00 00 00 
            return self.readFn(self, buffer);
  20c7b8:	48 8d 7c 24 50       	lea    rdi,[rsp+0x50]
  20c7bd:	48 8d b4 24 90 01 00 	lea    rsi,[rsp+0x190]
  20c7c4:	00 
  20c7c5:	48 8d 94 24 d0 00 00 	lea    rdx,[rsp+0xd0]
  20c7cc:	00 
  20c7cd:	ff 94 24 90 01 00 00 	call   QWORD PTR [rsp+0x190]
  20c7d4:	0f b7 54 24 50       	movzx  edx,WORD PTR [rsp+0x50]
  20c7d9:	48 8b 44 24 58       	mov    rax,QWORD PTR [rsp+0x58]
  20c7de:	89 d1                	mov    ecx,edx
            const amt_read = try self.read(buf);
  20c7e0:	66 85 d2             	test   dx,dx
  20c7e3:	0f 84 74 ff ff ff    	je     20c75d <openSelfDebugInfo+0x1e6d>
  20c7e9:	e9 c6 13 00 00       	jmp    20dbb4 <openSelfDebugInfo+0x32c4>
  20c7ee:	49 83 c5 07          	add    r13,0x7
            try self.readNoEof(result[0..]);
  20c7f2:	48 8d 44 24 1f       	lea    rax,[rsp+0x1f]
  20c7f7:	48 89 84 24 d0 00 00 	mov    QWORD PTR [rsp+0xd0],rax
  20c7fe:	00 
  20c7ff:	48 c7 84 24 d8 00 00 	mov    QWORD PTR [rsp+0xd8],0x1
  20c806:	00 01 00 00 00 
            return self.readFn(self, buffer);
  20c80b:	48 8d 7c 24 50       	lea    rdi,[rsp+0x50]
  20c810:	48 8d b4 24 90 01 00 	lea    rsi,[rsp+0x190]
  20c817:	00 
  20c818:	48 8d 94 24 d0 00 00 	lea    rdx,[rsp+0xd0]
  20c81f:	00 
  20c820:	ff 94 24 90 01 00 00 	call   QWORD PTR [rsp+0x190]
  20c827:	0f b7 54 24 50       	movzx  edx,WORD PTR [rsp+0x50]
  20c82c:	48 8b 44 24 58       	mov    rax,QWORD PTR [rsp+0x58]
  20c831:	89 d1                	mov    ecx,edx
            const amt_read = try self.read(buf);
  20c833:	66 85 d2             	test   dx,dx
  20c836:	0f 84 8c fe ff ff    	je     20c6c8 <openSelfDebugInfo+0x1dd8>
  20c83c:	e9 9b 13 00 00       	jmp    20dbdc <openSelfDebugInfo+0x32ec>
            if (attr_id == 0 and form_id == 0) break;
  20c841:	48 8b 44 24 40       	mov    rax,QWORD PTR [rsp+0x40]
  20c846:	48 0b 84 24 98 01 00 	or     rax,QWORD PTR [rsp+0x198]
  20c84d:	00 
  20c84e:	0f 84 fa 00 00 00    	je     20c94e <openSelfDebugInfo+0x205e>
  20c854:	48 8b 84 24 a8 01 00 	mov    rax,QWORD PTR [rsp+0x1a8]
  20c85b:	00 
            const new_length = self.len + 1;
  20c85c:	4c 8b 68 10          	mov    r13,QWORD PTR [rax+0x10]
            var better_capacity = self.items.len;
  20c860:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
            if (better_capacity >= new_capacity) return;
  20c864:	4c 39 e9             	cmp    rcx,r13
  20c867:	76 05                	jbe    20c86e <openSelfDebugInfo+0x1f7e>
            const result = &self.items[self.len];
  20c869:	4c 89 e8             	mov    rax,r13
  20c86c:	eb 51                	jmp    20c8bf <openSelfDebugInfo+0x1fcf>
                better_capacity += better_capacity / 2 + 8;
  20c86e:	48 89 c8             	mov    rax,rcx
  20c871:	48 d1 e8             	shr    rax,1
  20c874:	48 01 c1             	add    rcx,rax
  20c877:	48 83 c1 08          	add    rcx,0x8
                if (better_capacity >= new_capacity) break;
  20c87b:	4c 39 e9             	cmp    rcx,r13
  20c87e:	76 ee                	jbe    20c86e <openSelfDebugInfo+0x1f7e>
  20c880:	48 8b 94 24 a8 01 00 	mov    rdx,QWORD PTR [rsp+0x1a8]
  20c887:	00 
            self.items = try self.allocator.alignedRealloc(T, A, self.items, better_capacity);
  20c888:	48 8b 72 18          	mov    rsi,QWORD PTR [rdx+0x18]
  20c88c:	48 8d 7c 24 50       	lea    rdi,[rsp+0x50]
  20c891:	e8 1a 35 00 00       	call   20fdb0 <Allocator_alignedRealloc.38>
  20c896:	0f b7 44 24 50       	movzx  eax,WORD PTR [rsp+0x50]
  20c89b:	89 c1                	mov    ecx,eax
  20c89d:	66 85 c0             	test   ax,ax
  20c8a0:	0f 85 ab 13 00 00    	jne    20dc51 <openSelfDebugInfo+0x3361>
  20c8a6:	48 8d 44 24 58       	lea    rax,[rsp+0x58]
  20c8ab:	c5 fa 6f 00          	vmovdqu xmm0,XMMWORD PTR [rax]
  20c8af:	48 8b 84 24 a8 01 00 	mov    rax,QWORD PTR [rsp+0x1a8]
  20c8b6:	00 
  20c8b7:	c5 fa 7f 00          	vmovdqu XMMWORD PTR [rax],xmm0
            const result = &self.items[self.len];
  20c8bb:	48 8b 40 10          	mov    rax,QWORD PTR [rax+0x10]
  20c8bf:	49 83 c5 01          	add    r13,0x1
  20c8c3:	48 8b 94 24 a8 01 00 	mov    rdx,QWORD PTR [rsp+0x1a8]
  20c8ca:	00 
  20c8cb:	48 8b 0a             	mov    rcx,QWORD PTR [rdx]
            self.len = new_length;
  20c8ce:	4c 89 6a 10          	mov    QWORD PTR [rdx+0x10],r13
            new_item_ptr.* = item;
  20c8d2:	48 c1 e0 04          	shl    rax,0x4
  20c8d6:	48 8b 94 24 98 01 00 	mov    rdx,QWORD PTR [rsp+0x198]
  20c8dd:	00 
  20c8de:	48 89 14 01          	mov    QWORD PTR [rcx+rax*1],rdx
  20c8e2:	48 8b 54 24 40       	mov    rdx,QWORD PTR [rsp+0x40]
  20c8e7:	48 89 54 01 08       	mov    QWORD PTR [rcx+rax*1+0x8],rdx
            try self.readNoEof(result[0..]);
  20c8ec:	48 8d 44 24 1f       	lea    rax,[rsp+0x1f]
  20c8f1:	48 89 84 24 d0 00 00 	mov    QWORD PTR [rsp+0xd0],rax
  20c8f8:	00 
  20c8f9:	48 c7 84 24 d8 00 00 	mov    QWORD PTR [rsp+0xd8],0x1
  20c900:	00 01 00 00 00 
            return self.readFn(self, buffer);
  20c905:	48 8d 7c 24 50       	lea    rdi,[rsp+0x50]
  20c90a:	48 8d b4 24 90 01 00 	lea    rsi,[rsp+0x190]
  20c911:	00 
  20c912:	48 8d 94 24 d0 00 00 	lea    rdx,[rsp+0xd0]
  20c919:	00 
  20c91a:	ff 94 24 90 01 00 00 	call   QWORD PTR [rsp+0x190]
  20c921:	0f b7 54 24 50       	movzx  edx,WORD PTR [rsp+0x50]
  20c926:	48 8b 44 24 58       	mov    rax,QWORD PTR [rsp+0x58]
  20c92b:	b9 00 00 00 00       	mov    ecx,0x0
  20c930:	48 89 8c 24 98 01 00 	mov    QWORD PTR [rsp+0x198],rcx
  20c937:	00 
  20c938:	41 bd 00 00 00 00    	mov    r13d,0x0
  20c93e:	89 d1                	mov    ecx,edx
            const amt_read = try self.read(buf);
  20c940:	66 85 d2             	test   dx,dx
  20c943:	0f 84 7f fd ff ff    	je     20c6c8 <openSelfDebugInfo+0x1dd8>
  20c949:	e9 8e 12 00 00       	jmp    20dbdc <openSelfDebugInfo+0x32ec>
            try self.readNoEof(result[0..]);
  20c94e:	48 8d 44 24 1f       	lea    rax,[rsp+0x1f]
  20c953:	48 89 84 24 00 02 00 	mov    QWORD PTR [rsp+0x200],rax
  20c95a:	00 
  20c95b:	48 c7 84 24 08 02 00 	mov    QWORD PTR [rsp+0x208],0x1
  20c962:	00 01 00 00 00 
            return self.readFn(self, buffer);
  20c967:	48 8d bc 24 d0 00 00 	lea    rdi,[rsp+0xd0]
  20c96e:	00 
  20c96f:	48 8d b4 24 90 01 00 	lea    rsi,[rsp+0x190]
  20c976:	00 
  20c977:	48 8d 94 24 00 02 00 	lea    rdx,[rsp+0x200]
  20c97e:	00 
  20c97f:	ff 94 24 90 01 00 00 	call   QWORD PTR [rsp+0x190]
  20c986:	0f b7 8c 24 d0 00 00 	movzx  ecx,WORD PTR [rsp+0xd0]
  20c98d:	00 
  20c98e:	48 8b 84 24 d8 00 00 	mov    rax,QWORD PTR [rsp+0xd8]
  20c995:	00 
            const amt_read = try self.read(buf);
  20c996:	66 85 c9             	test   cx,cx
  20c999:	0f 84 91 f9 ff ff    	je     20c330 <openSelfDebugInfo+0x1a40>
  20c99f:	e9 5b 0e 00 00       	jmp    20d7ff <openSelfDebugInfo+0x2f0f>
        if (abbrev_code == 0) return result;
  20c9a4:	c5 fc 10 84 24 10 02 	vmovups ymm0,YMMWORD PTR [rsp+0x210]
  20c9ab:	00 00 
  20c9ad:	48 8d 84 24 9e 00 00 	lea    rax,[rsp+0x9e]
  20c9b4:	00 
  20c9b5:	c5 fc 11 00          	vmovups YMMWORD PTR [rax],ymm0
  20c9b9:	c5 fc 10 84 24 98 00 	vmovups ymm0,YMMWORD PTR [rsp+0x98]
  20c9c0:	00 00 
  20c9c2:	c5 fc 11 84 24 d0 01 	vmovups YMMWORD PTR [rsp+0x1d0],ymm0
  20c9c9:	00 00 
  20c9cb:	48 8b 84 24 b6 00 00 	mov    rax,QWORD PTR [rsp+0xb6]
  20c9d2:	00 
  20c9d3:	48 89 84 24 ee 01 00 	mov    QWORD PTR [rsp+0x1ee],rax
  20c9da:	00 
    try st.abbrev_table_list.append(AbbrevTableHeader{
  20c9db:	48 8d 84 24 d6 01 00 	lea    rax,[rsp+0x1d6]
  20c9e2:	00 
  20c9e3:	c5 fe 6f 00          	vmovdqu ymm0,YMMWORD PTR [rax]
  20c9e7:	c5 fe 7f 84 24 40 02 	vmovdqu YMMWORD PTR [rsp+0x240],ymm0
  20c9ee:	00 00 
            const new_length = self.len + 1;
  20c9f0:	4c 8b ad 98 00 00 00 	mov    r13,QWORD PTR [rbp+0x98]
            var better_capacity = self.items.len;
  20c9f7:	48 8b 8d 90 00 00 00 	mov    rcx,QWORD PTR [rbp+0x90]
            if (better_capacity >= new_capacity) return;
  20c9fe:	4c 39 e9             	cmp    rcx,r13
  20ca01:	76 05                	jbe    20ca08 <openSelfDebugInfo+0x2118>
            const result = &self.items[self.len];
  20ca03:	4c 89 e8             	mov    rax,r13
  20ca06:	eb 5e                	jmp    20ca66 <openSelfDebugInfo+0x2176>
                better_capacity += better_capacity / 2 + 8;
  20ca08:	48 89 c8             	mov    rax,rcx
  20ca0b:	48 d1 e8             	shr    rax,1
  20ca0e:	48 01 c1             	add    rcx,rax
  20ca11:	48 83 c1 08          	add    rcx,0x8
                if (better_capacity >= new_capacity) break;
  20ca15:	4c 39 e9             	cmp    rcx,r13
  20ca18:	76 ee                	jbe    20ca08 <openSelfDebugInfo+0x2118>
            self.items = try self.allocator.alignedRealloc(T, A, self.items, better_capacity);
  20ca1a:	48 8b b5 a0 00 00 00 	mov    rsi,QWORD PTR [rbp+0xa0]
  20ca21:	48 89 df             	mov    rdi,rbx
  20ca24:	48 8b 94 24 68 02 00 	mov    rdx,QWORD PTR [rsp+0x268]
  20ca2b:	00 
  20ca2c:	c5 f8 77             	vzeroupper 
  20ca2f:	e8 dc 35 00 00       	call   210010 <Allocator_alignedRealloc.41>
  20ca34:	0f b7 8c 24 f0 00 00 	movzx  ecx,WORD PTR [rsp+0xf0]
  20ca3b:	00 
  20ca3c:	89 c8                	mov    eax,ecx
  20ca3e:	66 85 c9             	test   cx,cx
  20ca41:	0f 85 f0 0d 00 00    	jne    20d837 <openSelfDebugInfo+0x2f47>
  20ca47:	48 8d 84 24 f8 00 00 	lea    rax,[rsp+0xf8]
  20ca4e:	00 
  20ca4f:	c5 fa 6f 00          	vmovdqu xmm0,XMMWORD PTR [rax]
  20ca53:	48 8b 84 24 68 02 00 	mov    rax,QWORD PTR [rsp+0x268]
  20ca5a:	00 
  20ca5b:	c5 fa 7f 00          	vmovdqu XMMWORD PTR [rax],xmm0
            const result = &self.items[self.len];
  20ca5f:	48 8b 85 98 00 00 00 	mov    rax,QWORD PTR [rbp+0x98]
  20ca66:	49 83 c5 01          	add    r13,0x1
  20ca6a:	48 8b 8d 88 00 00 00 	mov    rcx,QWORD PTR [rbp+0x88]
            self.len = new_length;
  20ca71:	4c 89 ad 98 00 00 00 	mov    QWORD PTR [rbp+0x98],r13
            new_item_ptr.* = item;
  20ca78:	48 8d 04 80          	lea    rax,[rax+rax*4]
  20ca7c:	48 8b 54 24 48       	mov    rdx,QWORD PTR [rsp+0x48]
  20ca81:	48 89 14 c1          	mov    QWORD PTR [rcx+rax*8],rdx
  20ca85:	c5 fe 6f 84 24 40 02 	vmovdqu ymm0,YMMWORD PTR [rsp+0x240]
  20ca8c:	00 00 
  20ca8e:	c5 fe 7f 44 c1 08    	vmovdqu YMMWORD PTR [rcx+rax*8+0x8],ymm0
    return &st.abbrev_table_list.items[st.abbrev_table_list.len - 1].table;
  20ca94:	48 8b 85 88 00 00 00 	mov    rax,QWORD PTR [rbp+0x88]
  20ca9b:	48 8b 8d 98 00 00 00 	mov    rcx,QWORD PTR [rbp+0x98]
  20caa2:	48 8d 0c 89          	lea    rcx,[rcx+rcx*4]
  20caa6:	4c 8d 2c c8          	lea    r13,[rax+rcx*8]
  20caaa:	49 83 c5 e0          	add    r13,0xffffffffffffffe0
  20caae:	66 bf 21 00          	mov    di,0x21
  20cab2:	48 83 bc 24 88 00 00 	cmp    QWORD PTR [rsp+0x88],0x0
  20cab9:	00 00 
  20cabb:	0f 88 b7 0e 00 00    	js     20d978 <openSelfDebugInfo+0x3088>
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  20cac1:	48 63 7d 00          	movsxd rdi,DWORD PTR [rbp+0x0]
  20cac5:	b8 08 00 00 00       	mov    eax,0x8
  20caca:	31 d2                	xor    edx,edx
  20cacc:	48 8b b4 24 88 00 00 	mov    rsi,QWORD PTR [rsp+0x88]
  20cad3:	00 
  20cad4:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  20cad6:	48 89 c1             	mov    rcx,rax
  20cad9:	48 f7 d9             	neg    rcx
  20cadc:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  20cae2:	b8 00 00 00 00       	mov    eax,0x0
  20cae7:	48 0f 46 c8          	cmovbe rcx,rax
  20caeb:	48 85 c9             	test   rcx,rcx
  20caee:	0f 85 bd 0d 00 00    	jne    20d8b1 <openSelfDebugInfo+0x2fc1>
  20caf4:	48 8b 85 a0 00 00 00 	mov    rax,QWORD PTR [rbp+0xa0]
    var in_file_stream = io.FileInStream.init(in_file);
  20cafb:	48 89 84 24 c0 01 00 	mov    QWORD PTR [rsp+0x1c0],rax
  20cb02:	00 
  20cb03:	48 89 6c 24 50       	mov    QWORD PTR [rsp+0x50],rbp
  20cb08:	48 8d 05 e1 2f 00 00 	lea    rax,[rip+0x2fe1]        # 20faf0 <FileInStream_readFn>
  20cb0f:	48 89 44 24 58       	mov    QWORD PTR [rsp+0x58],rax
            try self.readNoEof(result[0..]);
  20cb14:	48 8d 44 24 1f       	lea    rax,[rsp+0x1f]
  20cb19:	48 89 84 24 40 02 00 	mov    QWORD PTR [rsp+0x240],rax
  20cb20:	00 
  20cb21:	48 c7 84 24 48 02 00 	mov    QWORD PTR [rsp+0x248],0x1
  20cb28:	00 01 00 00 00 
        return self.file.read(buffer);
  20cb2d:	48 8b 74 24 50       	mov    rsi,QWORD PTR [rsp+0x50]
  20cb32:	48 8d bc 24 d0 01 00 	lea    rdi,[rsp+0x1d0]
  20cb39:	00 
  20cb3a:	48 8d 94 24 40 02 00 	lea    rdx,[rsp+0x240]
  20cb41:	00 
  20cb42:	c5 f8 77             	vzeroupper 
  20cb45:	e8 76 2e 00 00       	call   20f9c0 <File_read>
  20cb4a:	c5 fa 6f 84 24 d0 01 	vmovdqu xmm0,XMMWORD PTR [rsp+0x1d0]
  20cb51:	00 00 
  20cb53:	c5 f9 7f 84 24 10 02 	vmovdqa XMMWORD PTR [rsp+0x210],xmm0
  20cb5a:	00 00 
            return self.readFn(self, buffer);
  20cb5c:	0f b7 84 24 10 02 00 	movzx  eax,WORD PTR [rsp+0x210]
  20cb63:	00 
  20cb64:	89 c1                	mov    ecx,eax
            const amt_read = try self.read(buf);
  20cb66:	66 85 c0             	test   ax,ax
  20cb69:	0f 85 e4 0c 00 00    	jne    20d853 <openSelfDebugInfo+0x2f63>
  20cb6f:	0f b6 84 24 80 00 00 	movzx  eax,BYTE PTR [rsp+0x80]
  20cb76:	00 
  20cb77:	48 89 84 24 98 01 00 	mov    QWORD PTR [rsp+0x198],rax
  20cb7e:	00 
  20cb7f:	48 8d 04 c5 04 00 00 	lea    rax,[rax*8+0x4]
  20cb86:	00 
  20cb87:	48 89 84 24 30 02 00 	mov    QWORD PTR [rsp+0x230],rax
  20cb8e:	00 
  20cb8f:	48 8b 84 24 18 02 00 	mov    rax,QWORD PTR [rsp+0x218]
  20cb96:	00 
  20cb97:	31 c9                	xor    ecx,ecx
  20cb99:	48 89 4c 24 48       	mov    QWORD PTR [rsp+0x48],rcx
  20cb9e:	31 c9                	xor    ecx,ecx
            if (amt_read < buf.len) return error.EndOfStream;
  20cba0:	48 89 4c 24 40       	mov    QWORD PTR [rsp+0x40],rcx
  20cba5:	48 3b 84 24 48 02 00 	cmp    rax,QWORD PTR [rsp+0x248]
  20cbac:	00 
  20cbad:	0f 82 96 0c 00 00    	jb     20d849 <openSelfDebugInfo+0x2f59>
            return result[0];
  20cbb3:	0f b6 44 24 1f       	movzx  eax,BYTE PTR [rsp+0x1f]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  20cbb8:	89 c2                	mov    edx,eax
  20cbba:	83 e2 7f             	and    edx,0x7f
  20cbbd:	48 8b 74 24 40       	mov    rsi,QWORD PTR [rsp+0x40]
  20cbc2:	83 e6 3f             	and    esi,0x3f
  20cbc5:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  20cbca:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  20cbcf:	48 39 d6             	cmp    rsi,rdx
  20cbd2:	0f 85 77 0c 00 00    	jne    20d84f <openSelfDebugInfo+0x2f5f>
        result |= operand;
  20cbd8:	48 09 4c 24 48       	or     QWORD PTR [rsp+0x48],rcx
        if ((byte & 0b10000000) == 0) return result;
  20cbdd:	84 c0                	test   al,al
  20cbdf:	79 58                	jns    20cc39 <openSelfDebugInfo+0x2349>
        shift += 7;
  20cbe1:	48 83 44 24 40 07    	add    QWORD PTR [rsp+0x40],0x7
            try self.readNoEof(result[0..]);
  20cbe7:	48 8d 44 24 1f       	lea    rax,[rsp+0x1f]
  20cbec:	48 89 84 24 40 02 00 	mov    QWORD PTR [rsp+0x240],rax
  20cbf3:	00 
  20cbf4:	48 c7 84 24 48 02 00 	mov    QWORD PTR [rsp+0x248],0x1
  20cbfb:	00 01 00 00 00 
            return self.readFn(self, buffer);
  20cc00:	48 8d bc 24 10 02 00 	lea    rdi,[rsp+0x210]
  20cc07:	00 
  20cc08:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  20cc0d:	48 8d 94 24 40 02 00 	lea    rdx,[rsp+0x240]
  20cc14:	00 
  20cc15:	ff 54 24 58          	call   QWORD PTR [rsp+0x58]
  20cc19:	0f b7 94 24 10 02 00 	movzx  edx,WORD PTR [rsp+0x210]
  20cc20:	00 
  20cc21:	48 8b 84 24 18 02 00 	mov    rax,QWORD PTR [rsp+0x218]
  20cc28:	00 
  20cc29:	89 d1                	mov    ecx,edx
            const amt_read = try self.read(buf);
  20cc2b:	66 85 d2             	test   dx,dx
  20cc2e:	0f 84 71 ff ff ff    	je     20cba5 <openSelfDebugInfo+0x22b5>
  20cc34:	e9 1a 0c 00 00       	jmp    20d853 <openSelfDebugInfo+0x2f63>
            return self.items[0..self.len];
  20cc39:	49 8b 45 10          	mov    rax,QWORD PTR [r13+0x10]
    for (abbrev_table.toSliceConst()) |*table_entry| {
  20cc3d:	48 85 c0             	test   rax,rax
  20cc40:	0f 84 9c 0c 00 00    	je     20d8e2 <openSelfDebugInfo+0x2ff2>
  20cc46:	4d 8b 6d 00          	mov    r13,QWORD PTR [r13+0x0]
  20cc4a:	31 c9                	xor    ecx,ecx
        if (table_entry.abbrev_code == abbrev_code) return table_entry;
  20cc4c:	48 8b 54 24 48       	mov    rdx,QWORD PTR [rsp+0x48]
  20cc51:	49 39 55 08          	cmp    QWORD PTR [r13+0x8],rdx
  20cc55:	74 12                	je     20cc69 <openSelfDebugInfo+0x2379>
    for (abbrev_table.toSliceConst()) |*table_entry| {
  20cc57:	48 83 c1 01          	add    rcx,0x1
  20cc5b:	49 83 c5 38          	add    r13,0x38
  20cc5f:	48 39 c1             	cmp    rcx,rax
  20cc62:	72 e8                	jb     20cc4c <openSelfDebugInfo+0x235c>
  20cc64:	e9 79 0c 00 00       	jmp    20d8e2 <openSelfDebugInfo+0x2ff2>
    const table_entry = getAbbrevTableEntry(abbrev_table, abbrev_code) orelse return error.InvalidDebugInfo;
  20cc69:	4d 85 ed             	test   r13,r13
  20cc6c:	0f 84 70 0c 00 00    	je     20d8e2 <openSelfDebugInfo+0x2ff2>
        .tag_id = table_entry.tag_id,
  20cc72:	49 8b 45 10          	mov    rax,QWORD PTR [r13+0x10]
        .has_children = table_entry.has_children,
  20cc76:	41 8a 4d 00          	mov    cl,BYTE PTR [r13+0x0]
  20cc7a:	48 8b b5 a0 00 00 00 	mov    rsi,QWORD PTR [rbp+0xa0]
  20cc81:	48 8d 94 24 57 03 00 	lea    rdx,[rsp+0x357]
  20cc88:	00 
    var result = Die{
  20cc89:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  20cc8d:	c5 fa 7f 02          	vmovdqu XMMWORD PTR [rdx],xmm0
  20cc91:	48 c7 42 10 00 00 00 	mov    QWORD PTR [rdx+0x10],0x0
  20cc98:	00 
  20cc99:	48 89 84 24 88 02 00 	mov    QWORD PTR [rsp+0x288],rax
  20cca0:	00 
  20cca1:	88 8c 24 90 02 00 00 	mov    BYTE PTR [rsp+0x290],cl
  20cca8:	c5 fa 6f 84 24 50 03 	vmovdqu xmm0,XMMWORD PTR [rsp+0x350]
  20ccaf:	00 00 
  20ccb1:	c5 fa 6f 8c 24 5f 03 	vmovdqu xmm1,XMMWORD PTR [rsp+0x35f]
  20ccb8:	00 00 
  20ccba:	48 8d 84 24 91 02 00 	lea    rax,[rsp+0x291]
  20ccc1:	00 
  20ccc2:	c5 fa 7f 48 0f       	vmovdqu XMMWORD PTR [rax+0xf],xmm1
  20ccc7:	c5 fa 7f 00          	vmovdqu XMMWORD PTR [rax],xmm0
  20cccb:	48 89 b4 24 b0 02 00 	mov    QWORD PTR [rsp+0x2b0],rsi
  20ccd2:	00 
    try result.attrs.resize(table_entry.attrs.len);
  20ccd3:	49 8b 45 28          	mov    rax,QWORD PTR [r13+0x28]
            var better_capacity = self.items.len;
  20ccd7:	48 8b 8c 24 a0 02 00 	mov    rcx,QWORD PTR [rsp+0x2a0]
  20ccde:	00 
  20ccdf:	48 89 44 24 40       	mov    QWORD PTR [rsp+0x40],rax
            if (better_capacity >= new_capacity) return;
  20cce4:	48 39 c1             	cmp    rcx,rax
  20cce7:	73 5b                	jae    20cd44 <openSelfDebugInfo+0x2454>
                better_capacity += better_capacity / 2 + 8;
  20cce9:	48 89 c8             	mov    rax,rcx
  20ccec:	48 d1 e8             	shr    rax,1
  20ccef:	48 01 c1             	add    rcx,rax
  20ccf2:	48 83 c1 08          	add    rcx,0x8
                if (better_capacity >= new_capacity) break;
  20ccf6:	48 3b 4c 24 40       	cmp    rcx,QWORD PTR [rsp+0x40]
  20ccfb:	72 ec                	jb     20cce9 <openSelfDebugInfo+0x23f9>
            self.items = try self.allocator.alignedRealloc(T, A, self.items, better_capacity);
  20ccfd:	48 8d bc 24 d0 01 00 	lea    rdi,[rsp+0x1d0]
  20cd04:	00 
  20cd05:	48 8d 94 24 98 02 00 	lea    rdx,[rsp+0x298]
  20cd0c:	00 
  20cd0d:	e8 8e 60 00 00       	call   212da0 <Allocator_alignedRealloc.44>
  20cd12:	0f b7 8c 24 d0 01 00 	movzx  ecx,WORD PTR [rsp+0x1d0]
  20cd19:	00 
  20cd1a:	89 c8                	mov    eax,ecx
  20cd1c:	66 85 c9             	test   cx,cx
  20cd1f:	0f 85 f7 0e 00 00    	jne    20dc1c <openSelfDebugInfo+0x332c>
  20cd25:	48 8d 84 24 d6 01 00 	lea    rax,[rsp+0x1d6]
  20cd2c:	00 
  20cd2d:	c5 fa 6f 40 02       	vmovdqu xmm0,XMMWORD PTR [rax+0x2]
  20cd32:	48 8d 84 24 98 02 00 	lea    rax,[rsp+0x298]
  20cd39:	00 
  20cd3a:	c5 fa 7f 00          	vmovdqu XMMWORD PTR [rax],xmm0
            return self.items[0..self.len];
  20cd3e:	49 8b 45 28          	mov    rax,QWORD PTR [r13+0x28]
  20cd42:	eb 05                	jmp    20cd49 <openSelfDebugInfo+0x2459>
  20cd44:	48 8b 44 24 40       	mov    rax,QWORD PTR [rsp+0x40]
  20cd49:	48 89 84 24 a0 01 00 	mov    QWORD PTR [rsp+0x1a0],rax
  20cd50:	00 
            self.len = new_len;
  20cd51:	48 8b 44 24 40       	mov    rax,QWORD PTR [rsp+0x40]
  20cd56:	48 89 84 24 a8 02 00 	mov    QWORD PTR [rsp+0x2a8],rax
  20cd5d:	00 
    for (table_entry.attrs.toSliceConst()) |attr, i| {
  20cd5e:	48 83 bc 24 a0 01 00 	cmp    QWORD PTR [rsp+0x1a0],0x0
  20cd65:	00 00 
  20cd67:	0f 84 c7 00 00 00    	je     20ce34 <openSelfDebugInfo+0x2544>
  20cd6d:	49 8b 45 18          	mov    rax,QWORD PTR [r13+0x18]
  20cd71:	4c 8b ac 24 98 02 00 	mov    r13,QWORD PTR [rsp+0x298]
  20cd78:	00 
  20cd79:	48 83 c0 08          	add    rax,0x8
  20cd7d:	48 89 44 24 40       	mov    QWORD PTR [rsp+0x40],rax
  20cd82:	49 83 c5 08          	add    r13,0x8
  20cd86:	31 c0                	xor    eax,eax
  20cd88:	48 89 44 24 48       	mov    QWORD PTR [rsp+0x48],rax
  20cd8d:	48 8b 44 24 40       	mov    rax,QWORD PTR [rsp+0x40]
  20cd92:	48 8b 48 f8          	mov    rcx,QWORD PTR [rax-0x8]
  20cd96:	48 89 8c 24 88 00 00 	mov    QWORD PTR [rsp+0x88],rcx
  20cd9d:	00 
  20cd9e:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  20cda1:	48 8b b5 a0 00 00 00 	mov    rsi,QWORD PTR [rbp+0xa0]
            .value = try parseFormValue(st.allocator(), in_stream, attr.form_id, is_64),
  20cda8:	48 8d bc 24 78 03 00 	lea    rdi,[rsp+0x378]
  20cdaf:	00 
  20cdb0:	48 8d 54 24 58       	lea    rdx,[rsp+0x58]
  20cdb5:	4c 8b 84 24 98 01 00 	mov    r8,QWORD PTR [rsp+0x198]
  20cdbc:	00 
  20cdbd:	c5 f8 77             	vzeroupper 
  20cdc0:	e8 db 34 00 00       	call   2102a0 <parseFormValue>
  20cdc5:	0f b7 8c 24 78 03 00 	movzx  ecx,WORD PTR [rsp+0x378]
  20cdcc:	00 
  20cdcd:	89 c8                	mov    eax,ecx
  20cdcf:	66 85 c9             	test   cx,cx
  20cdd2:	0f 85 9c 0d 00 00    	jne    20db74 <openSelfDebugInfo+0x3284>
        result.attrs.items[i] = Die.Attr{
  20cdd8:	48 8d 84 24 80 03 00 	lea    rax,[rsp+0x380]
  20cddf:	00 
  20cde0:	c5 fc 10 00          	vmovups ymm0,YMMWORD PTR [rax]
  20cde4:	c5 fc 11 84 24 a0 03 	vmovups YMMWORD PTR [rsp+0x3a0],ymm0
  20cdeb:	00 00 
  20cded:	48 8b 84 24 88 00 00 	mov    rax,QWORD PTR [rsp+0x88]
  20cdf4:	00 
  20cdf5:	49 89 45 f8          	mov    QWORD PTR [r13-0x8],rax
  20cdf9:	c5 fe 6f 84 24 a0 03 	vmovdqu ymm0,YMMWORD PTR [rsp+0x3a0]
  20ce00:	00 00 
  20ce02:	c4 c1 7e 7f 45 00    	vmovdqu YMMWORD PTR [r13+0x0],ymm0
  20ce08:	48 8b 44 24 48       	mov    rax,QWORD PTR [rsp+0x48]
  20ce0d:	48 89 c1             	mov    rcx,rax
    for (table_entry.attrs.toSliceConst()) |attr, i| {
  20ce10:	48 83 c1 01          	add    rcx,0x1
  20ce14:	48 83 44 24 40 10    	add    QWORD PTR [rsp+0x40],0x10
  20ce1a:	49 83 c5 28          	add    r13,0x28
  20ce1e:	48 89 c8             	mov    rax,rcx
  20ce21:	48 89 44 24 48       	mov    QWORD PTR [rsp+0x48],rax
  20ce26:	48 3b 8c 24 a0 01 00 	cmp    rcx,QWORD PTR [rsp+0x1a0]
  20ce2d:	00 
  20ce2e:	0f 82 59 ff ff ff    	jb     20cd8d <openSelfDebugInfo+0x249d>
    return result;
  20ce34:	c5 fc 10 84 24 88 02 	vmovups ymm0,YMMWORD PTR [rsp+0x288]
  20ce3b:	00 00 
  20ce3d:	c5 fc 10 8c 24 98 02 	vmovups ymm1,YMMWORD PTR [rsp+0x298]
  20ce44:	00 00 
  20ce46:	48 8d 84 24 6e 04 00 	lea    rax,[rsp+0x46e]
  20ce4d:	00 
  20ce4e:	c5 fc 11 48 10       	vmovups YMMWORD PTR [rax+0x10],ymm1
  20ce53:	c5 fc 11 00          	vmovups YMMWORD PTR [rax],ymm0
  20ce57:	c5 fc 10 84 24 68 04 	vmovups ymm0,YMMWORD PTR [rsp+0x468]
  20ce5e:	00 00 
  20ce60:	c5 fc 10 8c 24 7e 04 	vmovups ymm1,YMMWORD PTR [rsp+0x47e]
  20ce67:	00 00 
  20ce69:	c5 fc 11 84 24 c0 02 	vmovups YMMWORD PTR [rsp+0x2c0],ymm0
  20ce70:	00 00 
  20ce72:	c5 fc 11 8c 24 d6 02 	vmovups YMMWORD PTR [rsp+0x2d6],ymm1
  20ce79:	00 00 
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  20ce7b:	ba 30 00 00 00       	mov    edx,0x30
  20ce80:	b9 08 00 00 00       	mov    ecx,0x8
  20ce85:	48 89 df             	mov    rdi,rbx
  20ce88:	48 8b b4 24 c0 01 00 	mov    rsi,QWORD PTR [rsp+0x1c0]
  20ce8f:	00 
  20ce90:	c5 f8 77             	vzeroupper 
  20ce93:	ff 16                	call   QWORD PTR [rsi]
  20ce95:	0f b7 8c 24 f0 00 00 	movzx  ecx,WORD PTR [rsp+0xf0]
  20ce9c:	00 
  20ce9d:	89 c8                	mov    eax,ecx
  20ce9f:	66 85 c9             	test   cx,cx
  20cea2:	0f 85 8f 09 00 00    	jne    20d837 <openSelfDebugInfo+0x2f47>
        assert(byte_slice.len == byte_count);
  20cea8:	48 83 bc 24 00 01 00 	cmp    QWORD PTR [rsp+0x100],0x30
  20ceaf:	00 30 
    if (!ok) {
  20ceb1:	0f 85 9d 1a 00 00    	jne    20e954 <openSelfDebugInfo+0x4064>
  20ceb7:	48 8b 8c 24 f8 00 00 	mov    rcx,QWORD PTR [rsp+0xf8]
  20cebe:	00 
  20cebf:	48 8d 84 24 c6 02 00 	lea    rax,[rsp+0x2c6]
  20cec6:	00 
        ptr.* = init;
  20cec7:	c5 fe 6f 00          	vmovdqu ymm0,YMMWORD PTR [rax]
  20cecb:	c5 fe 6f 48 10       	vmovdqu ymm1,YMMWORD PTR [rax+0x10]
  20ced0:	c5 fe 7f 01          	vmovdqu YMMWORD PTR [rcx],ymm0
  20ced4:	c5 fe 7f 49 10       	vmovdqu YMMWORD PTR [rcx+0x10],ymm1
  20ced9:	48 89 4c 24 40       	mov    QWORD PTR [rsp+0x40],rcx
        if (compile_unit_die.tag_id != DW.TAG_compile_unit) return error.InvalidDebugInfo;
  20cede:	48 83 39 11          	cmp    QWORD PTR [rcx],0x11
  20cee2:	0f 85 b5 09 00 00    	jne    20d89d <openSelfDebugInfo+0x2fad>
  20cee8:	48 8b 44 24 40       	mov    rax,QWORD PTR [rsp+0x40]
  20ceed:	48 8b 40 20          	mov    rax,QWORD PTR [rax+0x20]
        for (self.attrs.toSliceConst()) |*attr| {
  20cef1:	48 85 c0             	test   rax,rax
  20cef4:	74 25                	je     20cf1b <openSelfDebugInfo+0x262b>
  20cef6:	48 8b 4c 24 40       	mov    rcx,QWORD PTR [rsp+0x40]
  20cefb:	48 8b 51 10          	mov    rdx,QWORD PTR [rcx+0x10]
  20ceff:	48 89 d1             	mov    rcx,rdx
  20cf02:	31 f6                	xor    esi,esi
            if (attr.id == id) return &attr.value;
  20cf04:	48 83 39 11          	cmp    QWORD PTR [rcx],0x11
  20cf08:	0f 84 52 01 00 00    	je     20d060 <openSelfDebugInfo+0x2770>
        for (self.attrs.toSliceConst()) |*attr| {
  20cf0e:	48 83 c6 01          	add    rsi,0x1
  20cf12:	48 83 c1 28          	add    rcx,0x28
  20cf16:	48 39 c6             	cmp    rsi,rax
  20cf19:	72 e9                	jb     20cf04 <openSelfDebugInfo+0x2614>
        const pc_range = x: {
  20cf1b:	48 8d 0d 3e 86 ff ff 	lea    rcx,[rip+0xffffffffffff863e]        # 205560 <__unnamed_51>
  20cf22:	48 8b 41 10          	mov    rax,QWORD PTR [rcx+0x10]
  20cf26:	48 89 84 24 60 04 00 	mov    QWORD PTR [rsp+0x460],rax
  20cf2d:	00 
  20cf2e:	c5 fa 6f 01          	vmovdqu xmm0,XMMWORD PTR [rcx]
  20cf32:	c5 f9 7f 84 24 50 04 	vmovdqa XMMWORD PTR [rsp+0x450],xmm0
  20cf39:	00 00 
            const new_length = self.len + 1;
  20cf3b:	4c 8b ad b8 00 00 00 	mov    r13,QWORD PTR [rbp+0xb8]
            var better_capacity = self.items.len;
  20cf42:	48 8b 8d b0 00 00 00 	mov    rcx,QWORD PTR [rbp+0xb0]
            if (better_capacity >= new_capacity) return;
  20cf49:	4c 39 e9             	cmp    rcx,r13
  20cf4c:	76 05                	jbe    20cf53 <openSelfDebugInfo+0x2663>
            const result = &self.items[self.len];
  20cf4e:	4c 89 e8             	mov    rax,r13
  20cf51:	eb 58                	jmp    20cfab <openSelfDebugInfo+0x26bb>
                better_capacity += better_capacity / 2 + 8;
  20cf53:	48 89 c8             	mov    rax,rcx
  20cf56:	48 d1 e8             	shr    rax,1
  20cf59:	48 01 c1             	add    rcx,rax
  20cf5c:	48 83 c1 08          	add    rcx,0x8
                if (better_capacity >= new_capacity) break;
  20cf60:	4c 39 e9             	cmp    rcx,r13
  20cf63:	76 ee                	jbe    20cf53 <openSelfDebugInfo+0x2663>
            self.items = try self.allocator.alignedRealloc(T, A, self.items, better_capacity);
  20cf65:	48 8b b5 c0 00 00 00 	mov    rsi,QWORD PTR [rbp+0xc0]
  20cf6c:	48 89 df             	mov    rdi,rbx
  20cf6f:	48 8b 54 24 70       	mov    rdx,QWORD PTR [rsp+0x70]
  20cf74:	c5 f8 77             	vzeroupper 
  20cf77:	e8 b4 63 00 00       	call   213330 <Allocator_alignedRealloc.51>
  20cf7c:	0f b7 8c 24 f0 00 00 	movzx  ecx,WORD PTR [rsp+0xf0]
  20cf83:	00 
  20cf84:	89 c8                	mov    eax,ecx
  20cf86:	66 85 c9             	test   cx,cx
  20cf89:	0f 85 a8 08 00 00    	jne    20d837 <openSelfDebugInfo+0x2f47>
  20cf8f:	48 8d 84 24 f8 00 00 	lea    rax,[rsp+0xf8]
  20cf96:	00 
  20cf97:	c5 fa 6f 00          	vmovdqu xmm0,XMMWORD PTR [rax]
  20cf9b:	48 8b 44 24 70       	mov    rax,QWORD PTR [rsp+0x70]
  20cfa0:	c5 fa 7f 00          	vmovdqu XMMWORD PTR [rax],xmm0
            const result = &self.items[self.len];
  20cfa4:	48 8b 85 b8 00 00 00 	mov    rax,QWORD PTR [rbp+0xb8]
  20cfab:	49 83 c5 01          	add    r13,0x1
  20cfaf:	48 8b 8d a8 00 00 00 	mov    rcx,QWORD PTR [rbp+0xa8]
  20cfb6:	48 8d 04 40          	lea    rax,[rax+rax*2]
  20cfba:	48 c1 e0 04          	shl    rax,0x4
            self.len = new_length;
  20cfbe:	4c 89 ad b8 00 00 00 	mov    QWORD PTR [rbp+0xb8],r13
            new_item_ptr.* = item;
  20cfc5:	48 8b 94 24 f8 02 00 	mov    rdx,QWORD PTR [rsp+0x2f8]
  20cfcc:	00 
  20cfcd:	66 89 14 01          	mov    WORD PTR [rcx+rax*1],dx
  20cfd1:	8b 94 24 80 00 00 00 	mov    edx,DWORD PTR [rsp+0x80]
  20cfd8:	88 54 01 02          	mov    BYTE PTR [rcx+rax*1+0x2],dl
  20cfdc:	8a 94 24 67 02 00 00 	mov    dl,BYTE PTR [rsp+0x267]
  20cfe3:	88 54 01 07          	mov    BYTE PTR [rcx+rax*1+0x7],dl
  20cfe7:	8b 94 24 63 02 00 00 	mov    edx,DWORD PTR [rsp+0x263]
  20cfee:	89 54 01 03          	mov    DWORD PTR [rcx+rax*1+0x3],edx
  20cff2:	48 8b 54 24 40       	mov    rdx,QWORD PTR [rsp+0x40]
  20cff7:	48 89 54 01 08       	mov    QWORD PTR [rcx+rax*1+0x8],rdx
  20cffc:	48 8b 94 24 80 01 00 	mov    rdx,QWORD PTR [rsp+0x180]
  20d003:	00 
  20d004:	48 89 d6             	mov    rsi,rdx
  20d007:	48 89 74 01 10       	mov    QWORD PTR [rcx+rax*1+0x10],rsi
  20d00c:	48 8b 94 24 60 04 00 	mov    rdx,QWORD PTR [rsp+0x460]
  20d013:	00 
  20d014:	48 89 54 01 28       	mov    QWORD PTR [rcx+rax*1+0x28],rdx
  20d019:	c5 f9 6f 84 24 50 04 	vmovdqa xmm0,XMMWORD PTR [rsp+0x450]
  20d020:	00 00 
  20d022:	c5 fa 7f 44 01 18    	vmovdqu XMMWORD PTR [rcx+rax*1+0x18],xmm0
  20d028:	48 8b 44 24 78       	mov    rax,QWORD PTR [rsp+0x78]
        const next_offset = unit_length + (if (is_64) usize(12) else usize(4));
  20d02d:	48 03 44 24 68       	add    rax,QWORD PTR [rsp+0x68]
        this_unit_offset += next_offset;
  20d032:	48 03 84 24 30 02 00 	add    rax,QWORD PTR [rsp+0x230]
  20d039:	00 
        cu_index += 1;
  20d03a:	48 83 c6 01          	add    rsi,0x1
  20d03e:	48 89 b4 24 80 01 00 	mov    QWORD PTR [rsp+0x180],rsi
  20d045:	00 
  20d046:	31 ff                	xor    edi,edi
  20d048:	48 89 44 24 68       	mov    QWORD PTR [rsp+0x68],rax
    while (this_unit_offset < debug_info_end) {
  20d04d:	48 3b 84 24 90 00 00 	cmp    rax,QWORD PTR [rsp+0x90]
  20d054:	00 
  20d055:	0f 82 11 ee ff ff    	jb     20be6c <openSelfDebugInfo+0x157c>
  20d05b:	e9 18 09 00 00       	jmp    20d978 <openSelfDebugInfo+0x3088>
        return switch (form_value.*) {
  20d060:	40 8a 79 20          	mov    dil,BYTE PTR [rcx+0x20]
  20d064:	48 8d 35 55 a0 ff ff 	lea    rsi,[rip+0xffffffffffffa055]        # 2070c0 <__unnamed_52>
  20d06b:	40 84 ff             	test   dil,dil
  20d06e:	75 19                	jne    20d089 <openSelfDebugInfo+0x2799>
            FormValue.Address => |value| value,
  20d070:	48 8b 49 08          	mov    rcx,QWORD PTR [rcx+0x8]
  20d074:	66 c7 84 24 f0 00 00 	mov    WORD PTR [rsp+0xf0],0x0
  20d07b:	00 00 00 
  20d07e:	48 89 8c 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],rcx
  20d085:	00 
  20d086:	48 89 de             	mov    rsi,rbx
            if (compile_unit_die.getAttrAddr(DW.AT_low_pc)) |low_pc| {
  20d089:	0f b7 3e             	movzx  edi,WORD PTR [rsi]
        const pc_range = x: {
  20d08c:	48 8d 0d cd 84 ff ff 	lea    rcx,[rip+0xffffffffffff84cd]        # 205560 <__unnamed_51>
  20d093:	41 89 f8             	mov    r8d,edi
            if (compile_unit_die.getAttrAddr(DW.AT_low_pc)) |low_pc| {
  20d096:	83 ff 22             	cmp    edi,0x22
  20d099:	0f 84 83 fe ff ff    	je     20cf22 <openSelfDebugInfo+0x2632>
  20d09f:	44 89 c7             	mov    edi,r8d
  20d0a2:	66 85 ff             	test   di,di
  20d0a5:	0f 85 cd 08 00 00    	jne    20d978 <openSelfDebugInfo+0x3088>
  20d0ab:	4c 8b 4e 08          	mov    r9,QWORD PTR [rsi+0x8]
            if (attr.id == id) return &attr.value;
  20d0af:	48 83 c2 20          	add    rdx,0x20
  20d0b3:	31 c9                	xor    ecx,ecx
  20d0b5:	48 83 7a e0 12       	cmp    QWORD PTR [rdx-0x20],0x12
  20d0ba:	74 12                	je     20d0ce <openSelfDebugInfo+0x27de>
        for (self.attrs.toSliceConst()) |*attr| {
  20d0bc:	48 83 c1 01          	add    rcx,0x1
  20d0c0:	48 83 c2 28          	add    rdx,0x28
  20d0c4:	48 39 c1             	cmp    rcx,rax
  20d0c7:	72 ec                	jb     20d0b5 <openSelfDebugInfo+0x27c5>
  20d0c9:	e9 4d fe ff ff       	jmp    20cf1b <openSelfDebugInfo+0x262b>
  20d0ce:	8a 02                	mov    al,BYTE PTR [rdx]
  20d0d0:	3c 02                	cmp    al,0x2
                    const pc_end = switch (high_pc_value.*) {
  20d0d2:	74 15                	je     20d0e9 <openSelfDebugInfo+0x27f9>
  20d0d4:	66 bf 23 00          	mov    di,0x23
  20d0d8:	84 c0                	test   al,al
  20d0da:	0f 85 98 08 00 00    	jne    20d978 <openSelfDebugInfo+0x3088>
                        FormValue.Address => |value| value,
  20d0e0:	48 8b 42 e8          	mov    rax,QWORD PTR [rdx-0x18]
  20d0e4:	e9 33 02 00 00       	jmp    20d31c <openSelfDebugInfo+0x2a2c>
                        FormValue.Const => |value| b: {
  20d0e9:	4c 8b 52 f0          	mov    r10,QWORD PTR [rdx-0x10]
        if (self.payload.len > @sizeOf(u64)) return error.InvalidDebugInfo;
  20d0ed:	49 83 fa 08          	cmp    r10,0x8
  20d0f1:	0f 87 a6 07 00 00    	ja     20d89d <openSelfDebugInfo+0x2fad>
  20d0f7:	f6 42 f8 01          	test   BYTE PTR [rdx-0x8],0x1
  20d0fb:	66 bf 23 00          	mov    di,0x23
  20d0ff:	0f 85 73 08 00 00    	jne    20d978 <openSelfDebugInfo+0x3088>
  20d105:	4d 85 d2             	test   r10,r10
            for (bytes) |b, index| {
  20d108:	74 13                	je     20d11d <openSelfDebugInfo+0x282d>
  20d10a:	48 8b 52 e8          	mov    rdx,QWORD PTR [rdx-0x18]
  20d10e:	49 83 fa 10          	cmp    r10,0x10
  20d112:	73 10                	jae    20d124 <openSelfDebugInfo+0x2834>
  20d114:	31 c9                	xor    ecx,ecx
  20d116:	31 c0                	xor    eax,eax
  20d118:	e9 d3 01 00 00       	jmp    20d2f0 <openSelfDebugInfo+0x2a00>
  20d11d:	31 c0                	xor    eax,eax
  20d11f:	e9 f5 01 00 00       	jmp    20d319 <openSelfDebugInfo+0x2a29>
  20d124:	4c 89 d1             	mov    rcx,r10
  20d127:	48 83 e1 f0          	and    rcx,0xfffffffffffffff0
  20d12b:	48 8d 41 f0          	lea    rax,[rcx-0x10]
  20d12f:	48 89 c7             	mov    rdi,rax
  20d132:	48 c1 ef 04          	shr    rdi,0x4
  20d136:	44 8d 47 01          	lea    r8d,[rdi+0x1]
  20d13a:	41 83 e0 01          	and    r8d,0x1
  20d13e:	48 85 c0             	test   rax,rax
  20d141:	0f 84 01 01 00 00    	je     20d248 <openSelfDebugInfo+0x2958>
  20d147:	49 8d 40 ff          	lea    rax,[r8-0x1]
  20d14b:	48 29 f8             	sub    rax,rdi
  20d14e:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  20d152:	31 ff                	xor    edi,edi
  20d154:	c5 fd 6f 25 44 30 ff 	vmovdqa ymm4,YMMWORD PTR [rip+0xffffffffffff3044]        # 2001a0 <__unnamed_90-0x40>
  20d15b:	ff 
  20d15c:	c5 f1 ef c9          	vpxor  xmm1,xmm1,xmm1
  20d160:	c5 e1 ef db          	vpxor  xmm3,xmm3,xmm3
  20d164:	c5 e9 ef d2          	vpxor  xmm2,xmm2,xmm2
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20d168:	c4 e2 7d 32 2c 3a    	vpmovzxbq ymm5,DWORD PTR [rdx+rdi*1]
  20d16e:	c4 e2 7d 32 74 3a 04 	vpmovzxbq ymm6,DWORD PTR [rdx+rdi*1+0x4]
  20d175:	c4 e2 7d 32 7c 3a 08 	vpmovzxbq ymm7,DWORD PTR [rdx+rdi*1+0x8]
  20d17c:	c4 62 7d 32 44 3a 0c 	vpmovzxbq ymm8,DWORD PTR [rdx+rdi*1+0xc]
  20d183:	c5 b5 73 f4 03       	vpsllq ymm9,ymm4,0x3
  20d188:	c5 7e 6f a4 24 40 05 	vmovdqu ymm12,YMMWORD PTR [rsp+0x540]
  20d18f:	00 00 
  20d191:	c4 41 35 d4 d4       	vpaddq ymm10,ymm9,ymm12
  20d196:	c5 7e 6f ac 24 20 05 	vmovdqu ymm13,YMMWORD PTR [rsp+0x520]
  20d19d:	00 00 
  20d19f:	c4 41 35 db dd       	vpand  ymm11,ymm9,ymm13
  20d1a4:	c4 41 2d db d5       	vpand  ymm10,ymm10,ymm13
  20d1a9:	c4 c2 d5 47 eb       	vpsllvq ymm5,ymm5,ymm11
  20d1ae:	c5 d5 eb c0          	vpor   ymm0,ymm5,ymm0
  20d1b2:	c4 c2 cd 47 ea       	vpsllvq ymm5,ymm6,ymm10
  20d1b7:	c5 d5 eb c9          	vpor   ymm1,ymm5,ymm1
  20d1bb:	c4 c2 c5 47 eb       	vpsllvq ymm5,ymm7,ymm11
  20d1c0:	c5 d5 eb db          	vpor   ymm3,ymm5,ymm3
  20d1c4:	c4 c2 bd 47 ea       	vpsllvq ymm5,ymm8,ymm10
  20d1c9:	c4 e2 7d 32 74 3a 10 	vpmovzxbq ymm6,DWORD PTR [rdx+rdi*1+0x10]
  20d1d0:	c4 e2 7d 32 7c 3a 14 	vpmovzxbq ymm7,DWORD PTR [rdx+rdi*1+0x14]
  20d1d7:	c4 62 7d 32 44 3a 18 	vpmovzxbq ymm8,DWORD PTR [rdx+rdi*1+0x18]
  20d1de:	c5 d5 eb d2          	vpor   ymm2,ymm5,ymm2
  20d1e2:	c4 e2 7d 32 6c 3a 1c 	vpmovzxbq ymm5,DWORD PTR [rdx+rdi*1+0x1c]
  20d1e9:	c4 62 7d 59 15 ce 30 	vpbroadcastq ymm10,QWORD PTR [rip+0xffffffffffff30ce]        # 2002c0 <app_mask+0x40>
  20d1f0:	ff ff 
  20d1f2:	c4 41 35 d4 d2       	vpaddq ymm10,ymm9,ymm10
  20d1f7:	c4 62 7d 59 1d 08 30 	vpbroadcastq ymm11,QWORD PTR [rip+0xffffffffffff3008]        # 200208 <__unnamed_90+0x28>
  20d1fe:	ff ff 
  20d200:	c4 41 35 d4 cb       	vpaddq ymm9,ymm9,ymm11
  20d205:	c4 41 2d db d5       	vpand  ymm10,ymm10,ymm13
  20d20a:	c4 41 35 db cd       	vpand  ymm9,ymm9,ymm13
  20d20f:	c4 c2 cd 47 f2       	vpsllvq ymm6,ymm6,ymm10
  20d214:	c5 cd eb c0          	vpor   ymm0,ymm6,ymm0
  20d218:	c4 c2 c5 47 f1       	vpsllvq ymm6,ymm7,ymm9
  20d21d:	c5 cd eb c9          	vpor   ymm1,ymm6,ymm1
  20d221:	c4 c2 bd 47 f2       	vpsllvq ymm6,ymm8,ymm10
  20d226:	c5 cd eb db          	vpor   ymm3,ymm6,ymm3
  20d22a:	c4 c2 d5 47 e9       	vpsllvq ymm5,ymm5,ymm9
  20d22f:	c5 d5 eb d2          	vpor   ymm2,ymm5,ymm2
            for (bytes) |b, index| {
  20d233:	48 83 c7 20          	add    rdi,0x20
  20d237:	c4 c1 5d d4 e4       	vpaddq ymm4,ymm4,ymm12
  20d23c:	48 83 c0 02          	add    rax,0x2
  20d240:	0f 85 22 ff ff ff    	jne    20d168 <openSelfDebugInfo+0x2878>
  20d246:	eb 1a                	jmp    20d262 <openSelfDebugInfo+0x2972>
  20d248:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  20d24c:	31 ff                	xor    edi,edi
  20d24e:	c5 fd 6f 25 4a 2f ff 	vmovdqa ymm4,YMMWORD PTR [rip+0xffffffffffff2f4a]        # 2001a0 <__unnamed_90-0x40>
  20d255:	ff 
  20d256:	c5 f1 ef c9          	vpxor  xmm1,xmm1,xmm1
  20d25a:	c5 e1 ef db          	vpxor  xmm3,xmm3,xmm3
  20d25e:	c5 e9 ef d2          	vpxor  xmm2,xmm2,xmm2
  20d262:	4d 85 c0             	test   r8,r8
  20d265:	74 60                	je     20d2c7 <openSelfDebugInfo+0x29d7>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20d267:	c4 e2 7d 32 6c 3a 0c 	vpmovzxbq ymm5,DWORD PTR [rdx+rdi*1+0xc]
  20d26e:	c5 dd 73 f4 03       	vpsllq ymm4,ymm4,0x3
  20d273:	c5 dd d4 b4 24 40 05 	vpaddq ymm6,ymm4,YMMWORD PTR [rsp+0x540]
  20d27a:	00 00 
  20d27c:	c5 7e 6f 84 24 20 05 	vmovdqu ymm8,YMMWORD PTR [rsp+0x520]
  20d283:	00 00 
  20d285:	c4 c1 4d db f0       	vpand  ymm6,ymm6,ymm8
  20d28a:	c4 e2 d5 47 ee       	vpsllvq ymm5,ymm5,ymm6
  20d28f:	c4 e2 7d 32 7c 3a 08 	vpmovzxbq ymm7,DWORD PTR [rdx+rdi*1+0x8]
  20d296:	c5 d5 eb d2          	vpor   ymm2,ymm5,ymm2
  20d29a:	c4 c1 5d db e0       	vpand  ymm4,ymm4,ymm8
  20d29f:	c4 e2 c5 47 ec       	vpsllvq ymm5,ymm7,ymm4
  20d2a4:	c5 d5 eb db          	vpor   ymm3,ymm5,ymm3
  20d2a8:	c4 e2 7d 32 6c 3a 04 	vpmovzxbq ymm5,DWORD PTR [rdx+rdi*1+0x4]
  20d2af:	c4 e2 d5 47 ee       	vpsllvq ymm5,ymm5,ymm6
  20d2b4:	c5 d5 eb c9          	vpor   ymm1,ymm5,ymm1
  20d2b8:	c4 e2 7d 32 2c 3a    	vpmovzxbq ymm5,DWORD PTR [rdx+rdi*1]
  20d2be:	c4 e2 d5 47 e4       	vpsllvq ymm4,ymm5,ymm4
  20d2c3:	c5 dd eb c0          	vpor   ymm0,ymm4,ymm0
  20d2c7:	c5 f5 eb ca          	vpor   ymm1,ymm1,ymm2
  20d2cb:	c5 fd eb c3          	vpor   ymm0,ymm0,ymm3
  20d2cf:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  20d2d3:	c4 e3 7d 39 c1 01    	vextracti128 xmm1,ymm0,0x1
  20d2d9:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  20d2dd:	c5 f9 70 c8 4e       	vpshufd xmm1,xmm0,0x4e
  20d2e2:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  20d2e6:	c4 e1 f9 7e c0       	vmovq  rax,xmm0
  20d2eb:	49 39 ca             	cmp    r10,rcx
            for (bytes) |b, index| {
  20d2ee:	74 29                	je     20d319 <openSelfDebugInfo+0x2a29>
  20d2f0:	49 29 ca             	sub    r10,rcx
  20d2f3:	48 01 ca             	add    rdx,rcx
  20d2f6:	48 c1 e1 03          	shl    rcx,0x3
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20d2fa:	0f b6 3a             	movzx  edi,BYTE PTR [rdx]
  20d2fd:	89 ce                	mov    esi,ecx
  20d2ff:	40 80 e6 38          	and    sil,0x38
  20d303:	c4 e2 c9 f7 f7       	shlx   rsi,rdi,rsi
  20d308:	48 09 f0             	or     rax,rsi
            for (bytes) |b, index| {
  20d30b:	48 83 c1 08          	add    rcx,0x8
  20d30f:	48 83 c2 01          	add    rdx,0x1
  20d313:	49 83 c2 ff          	add    r10,0xffffffffffffffff
  20d317:	75 e1                	jne    20d2fa <openSelfDebugInfo+0x2a0a>
                            break :b (low_pc + offset);
  20d319:	4c 01 c8             	add    rax,r9
                    break :x PcRange{
  20d31c:	4c 89 8c 24 70 02 00 	mov    QWORD PTR [rsp+0x270],r9
  20d323:	00 
  20d324:	48 89 84 24 78 02 00 	mov    QWORD PTR [rsp+0x278],rax
  20d32b:	00 
  20d32c:	c6 84 24 80 02 00 00 	mov    BYTE PTR [rsp+0x280],0x1
  20d333:	01 
        const pc_range = x: {
  20d334:	48 8d 8c 24 70 02 00 	lea    rcx,[rsp+0x270]
  20d33b:	00 
  20d33c:	e9 e1 fb ff ff       	jmp    20cf22 <openSelfDebugInfo+0x2632>
                list.first = node.next;
  20d341:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20d345:	48 89 0d dc 3c 01 00 	mov    QWORD PTR [rip+0x13cdc],rcx        # 221028 <emfile_promise_queue>
            if (node.next) |next_node| {
  20d34c:	48 85 c9             	test   rcx,rcx
  20d34f:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  20d352:	48 8d 35 d7 3c 01 00 	lea    rsi,[rip+0x13cd7]        # 221030 <emfile_promise_queue+0x8>
  20d359:	48 0f 45 f1          	cmovne rsi,rcx
  20d35d:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  20d360:	48 83 05 d0 3c 01 00 	add    QWORD PTR [rip+0x13cd0],0xffffffffffffffff        # 221038 <emfile_promise_queue+0x10>
  20d367:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  20d368:	74 1e                	je     20d388 <openSelfDebugInfo+0x2a98>
  20d36a:	48 83 3d b6 3c 01 00 	cmp    QWORD PTR [rip+0x13cb6],0x0        # 221028 <emfile_promise_queue>
  20d371:	00 
  20d372:	0f 84 dc 15 00 00    	je     20e954 <openSelfDebugInfo+0x4064>
  20d378:	48 8b 0d b1 3c 01 00 	mov    rcx,QWORD PTR [rip+0x13cb1]        # 221030 <emfile_promise_queue+0x8>
  20d37f:	48 85 c9             	test   rcx,rcx
  20d382:	0f 84 cc 15 00 00    	je     20e954 <openSelfDebugInfo+0x4064>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  20d388:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  20d38c:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  20d390:	48 89 c1             	mov    rcx,rax
  20d393:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  20d397:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  20d39d:	75 f1                	jne    20d390 <openSelfDebugInfo+0x2aa0>
  20d39f:	a8 01                	test   al,0x1
  20d3a1:	75 02                	jne    20d3a5 <openSelfDebugInfo+0x2ab5>
  20d3a3:	ff 17                	call   QWORD PTR [rdi]
  20d3a5:	48 63 7d 00          	movsxd rdi,DWORD PTR [rbp+0x0]
    return asm volatile ("syscall"
  20d3a9:	b8 03 00 00 00       	mov    eax,0x3
  20d3ae:	0f 05                	syscall 
            switch (err) {
  20d3b0:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  20d3b4:	74 f3                	je     20d3a9 <openSelfDebugInfo+0x2ab9>
            const first = list.first orelse return null;
  20d3b6:	48 8b 05 6b 3c 01 00 	mov    rax,QWORD PTR [rip+0x13c6b]        # 221028 <emfile_promise_queue>
  20d3bd:	48 85 c0             	test   rax,rax
  20d3c0:	74 7a                	je     20d43c <openSelfDebugInfo+0x2b4c>
            if (node.prev) |prev_node| {
  20d3c2:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  20d3c5:	48 85 c9             	test   rcx,rcx
  20d3c8:	74 0e                	je     20d3d8 <openSelfDebugInfo+0x2ae8>
                prev_node.next = node.next;
  20d3ca:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  20d3ce:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  20d3d2:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20d3d6:	eb 0b                	jmp    20d3e3 <openSelfDebugInfo+0x2af3>
                list.first = node.next;
  20d3d8:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20d3dc:	48 89 0d 45 3c 01 00 	mov    QWORD PTR [rip+0x13c45],rcx        # 221028 <emfile_promise_queue>
            if (node.next) |next_node| {
  20d3e3:	48 85 c9             	test   rcx,rcx
  20d3e6:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  20d3e9:	48 8d 35 40 3c 01 00 	lea    rsi,[rip+0x13c40]        # 221030 <emfile_promise_queue+0x8>
  20d3f0:	48 0f 45 f1          	cmovne rsi,rcx
  20d3f4:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  20d3f7:	48 83 05 39 3c 01 00 	add    QWORD PTR [rip+0x13c39],0xffffffffffffffff        # 221038 <emfile_promise_queue+0x10>
  20d3fe:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  20d3ff:	74 1e                	je     20d41f <openSelfDebugInfo+0x2b2f>
  20d401:	48 83 3d 1f 3c 01 00 	cmp    QWORD PTR [rip+0x13c1f],0x0        # 221028 <emfile_promise_queue>
  20d408:	00 
  20d409:	0f 84 45 15 00 00    	je     20e954 <openSelfDebugInfo+0x4064>
  20d40f:	48 8b 0d 1a 3c 01 00 	mov    rcx,QWORD PTR [rip+0x13c1a]        # 221030 <emfile_promise_queue+0x8>
  20d416:	48 85 c9             	test   rcx,rcx
  20d419:	0f 84 35 15 00 00    	je     20e954 <openSelfDebugInfo+0x4064>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  20d41f:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  20d423:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  20d427:	48 89 c1             	mov    rcx,rax
  20d42a:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  20d42e:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  20d434:	75 f1                	jne    20d427 <openSelfDebugInfo+0x2b37>
  20d436:	a8 01                	test   al,0x1
  20d438:	75 02                	jne    20d43c <openSelfDebugInfo+0x2b4c>
  20d43a:	ff 17                	call   QWORD PTR [rdi]
        self.freeFn(self, non_const_ptr[0..@sizeOf(@typeOf(ptr).Child)]);
  20d43c:	49 8b 44 24 10       	mov    rax,QWORD PTR [r12+0x10]
  20d441:	48 89 ac 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rbp
  20d448:	00 
  20d449:	48 c7 84 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],0xc8
  20d450:	00 c8 00 00 00 
  20d455:	48 8d b4 24 f0 00 00 	lea    rsi,[rsp+0xf0]
  20d45c:	00 
  20d45d:	4c 89 e7             	mov    rdi,r12
  20d460:	ff d0                	call   rax
            st.debug_line = (try st.elf.findSection(".debug_line")) orelse return error.MissingDebugInfo;
  20d462:	0f b7 84 24 10 03 00 	movzx  eax,WORD PTR [rsp+0x310]
  20d469:	00 
  20d46a:	66 41 89 06          	mov    WORD PTR [r14],ax
  20d46e:	48 8b 84 24 be 04 00 	mov    rax,QWORD PTR [rsp+0x4be]
  20d475:	00 
  20d476:	48 8b 8c 24 c4 04 00 	mov    rcx,QWORD PTR [rsp+0x4c4]
  20d47d:	00 
  20d47e:	e9 84 e1 ff ff       	jmp    20b607 <openSelfDebugInfo+0xd17>
                list.first = node.next;
  20d483:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20d487:	48 89 0d 9a 3b 01 00 	mov    QWORD PTR [rip+0x13b9a],rcx        # 221028 <emfile_promise_queue>
            if (node.next) |next_node| {
  20d48e:	48 85 c9             	test   rcx,rcx
  20d491:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  20d494:	48 8d 35 95 3b 01 00 	lea    rsi,[rip+0x13b95]        # 221030 <emfile_promise_queue+0x8>
  20d49b:	48 0f 45 f1          	cmovne rsi,rcx
  20d49f:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  20d4a2:	48 83 05 8e 3b 01 00 	add    QWORD PTR [rip+0x13b8e],0xffffffffffffffff        # 221038 <emfile_promise_queue+0x10>
  20d4a9:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  20d4aa:	74 1e                	je     20d4ca <openSelfDebugInfo+0x2bda>
  20d4ac:	48 83 3d 74 3b 01 00 	cmp    QWORD PTR [rip+0x13b74],0x0        # 221028 <emfile_promise_queue>
  20d4b3:	00 
  20d4b4:	0f 84 9a 14 00 00    	je     20e954 <openSelfDebugInfo+0x4064>
  20d4ba:	48 8b 0d 6f 3b 01 00 	mov    rcx,QWORD PTR [rip+0x13b6f]        # 221030 <emfile_promise_queue+0x8>
  20d4c1:	48 85 c9             	test   rcx,rcx
  20d4c4:	0f 84 8a 14 00 00    	je     20e954 <openSelfDebugInfo+0x4064>
  20d4ca:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  20d4ce:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  20d4d2:	48 89 c1             	mov    rcx,rax
  20d4d5:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  20d4d9:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  20d4df:	75 f1                	jne    20d4d2 <openSelfDebugInfo+0x2be2>
  20d4e1:	a8 01                	test   al,0x1
  20d4e3:	75 02                	jne    20d4e7 <openSelfDebugInfo+0x2bf7>
  20d4e5:	ff 17                	call   QWORD PTR [rdi]
  20d4e7:	48 63 7d 00          	movsxd rdi,DWORD PTR [rbp+0x0]
  20d4eb:	b8 03 00 00 00       	mov    eax,0x3
  20d4f0:	0f 05                	syscall 
            switch (err) {
  20d4f2:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  20d4f6:	74 f3                	je     20d4eb <openSelfDebugInfo+0x2bfb>
            const first = list.first orelse return null;
  20d4f8:	48 8b 05 29 3b 01 00 	mov    rax,QWORD PTR [rip+0x13b29]        # 221028 <emfile_promise_queue>
  20d4ff:	48 85 c0             	test   rax,rax
  20d502:	0f 84 9b e4 ff ff    	je     20b9a3 <openSelfDebugInfo+0x10b3>
            if (node.prev) |prev_node| {
  20d508:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  20d50b:	48 85 c9             	test   rcx,rcx
  20d50e:	74 0e                	je     20d51e <openSelfDebugInfo+0x2c2e>
                prev_node.next = node.next;
  20d510:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  20d514:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  20d518:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20d51c:	eb 0b                	jmp    20d529 <openSelfDebugInfo+0x2c39>
                list.first = node.next;
  20d51e:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20d522:	48 89 0d ff 3a 01 00 	mov    QWORD PTR [rip+0x13aff],rcx        # 221028 <emfile_promise_queue>
            if (node.next) |next_node| {
  20d529:	48 85 c9             	test   rcx,rcx
  20d52c:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  20d52f:	48 8d 35 fa 3a 01 00 	lea    rsi,[rip+0x13afa]        # 221030 <emfile_promise_queue+0x8>
  20d536:	48 0f 45 f1          	cmovne rsi,rcx
  20d53a:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  20d53d:	48 83 05 f3 3a 01 00 	add    QWORD PTR [rip+0x13af3],0xffffffffffffffff        # 221038 <emfile_promise_queue+0x10>
  20d544:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  20d545:	74 1e                	je     20d565 <openSelfDebugInfo+0x2c75>
  20d547:	48 83 3d d9 3a 01 00 	cmp    QWORD PTR [rip+0x13ad9],0x0        # 221028 <emfile_promise_queue>
  20d54e:	00 
  20d54f:	0f 84 ff 13 00 00    	je     20e954 <openSelfDebugInfo+0x4064>
  20d555:	48 8b 0d d4 3a 01 00 	mov    rcx,QWORD PTR [rip+0x13ad4]        # 221030 <emfile_promise_queue+0x8>
  20d55c:	48 85 c9             	test   rcx,rcx
  20d55f:	0f 84 ef 13 00 00    	je     20e954 <openSelfDebugInfo+0x4064>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  20d565:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  20d569:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  20d56d:	48 89 c1             	mov    rcx,rax
  20d570:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  20d574:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  20d57a:	75 f1                	jne    20d56d <openSelfDebugInfo+0x2c7d>
  20d57c:	e9 1c e4 ff ff       	jmp    20b99d <openSelfDebugInfo+0x10ad>
  20d581:	31 ff                	xor    edi,edi
  20d583:	89 fb                	mov    ebx,edi
            try scanAllCompileUnits(st);
  20d585:	66 85 ff             	test   di,di
  20d588:	0f 85 f5 03 00 00    	jne    20d983 <openSelfDebugInfo+0x3093>
            return st;
  20d58e:	66 41 c7 06 00 00    	mov    WORD PTR [r14],0x0
  20d594:	0f b7 84 24 be 02 00 	movzx  eax,WORD PTR [rsp+0x2be]
  20d59b:	00 
  20d59c:	66 41 89 46 06       	mov    WORD PTR [r14+0x6],ax
  20d5a1:	8b 84 24 ba 02 00 00 	mov    eax,DWORD PTR [rsp+0x2ba]
  20d5a8:	41 89 46 02          	mov    DWORD PTR [r14+0x2],eax
  20d5ac:	49 89 6e 08          	mov    QWORD PTR [r14+0x8],rbp
  20d5b0:	e9 5a e0 ff ff       	jmp    20b60f <openSelfDebugInfo+0xd1f>
                list.first = node.next;
  20d5b5:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20d5b9:	48 89 0d 68 3a 01 00 	mov    QWORD PTR [rip+0x13a68],rcx        # 221028 <emfile_promise_queue>
            if (node.next) |next_node| {
  20d5c0:	48 85 c9             	test   rcx,rcx
  20d5c3:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  20d5c6:	48 8d 35 63 3a 01 00 	lea    rsi,[rip+0x13a63]        # 221030 <emfile_promise_queue+0x8>
  20d5cd:	48 0f 45 f1          	cmovne rsi,rcx
  20d5d1:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  20d5d4:	48 83 05 5c 3a 01 00 	add    QWORD PTR [rip+0x13a5c],0xffffffffffffffff        # 221038 <emfile_promise_queue+0x10>
  20d5db:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  20d5dc:	74 1e                	je     20d5fc <openSelfDebugInfo+0x2d0c>
  20d5de:	48 83 3d 42 3a 01 00 	cmp    QWORD PTR [rip+0x13a42],0x0        # 221028 <emfile_promise_queue>
  20d5e5:	00 
  20d5e6:	0f 84 68 13 00 00    	je     20e954 <openSelfDebugInfo+0x4064>
  20d5ec:	48 8b 0d 3d 3a 01 00 	mov    rcx,QWORD PTR [rip+0x13a3d]        # 221030 <emfile_promise_queue+0x8>
  20d5f3:	48 85 c9             	test   rcx,rcx
  20d5f6:	0f 84 58 13 00 00    	je     20e954 <openSelfDebugInfo+0x4064>
  20d5fc:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  20d600:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  20d604:	48 89 c1             	mov    rcx,rax
  20d607:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  20d60b:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  20d611:	75 f1                	jne    20d604 <openSelfDebugInfo+0x2d14>
  20d613:	a8 01                	test   al,0x1
  20d615:	75 02                	jne    20d619 <openSelfDebugInfo+0x2d29>
  20d617:	ff 17                	call   QWORD PTR [rdi]
  20d619:	48 63 7d 00          	movsxd rdi,DWORD PTR [rbp+0x0]
  20d61d:	b8 03 00 00 00       	mov    eax,0x3
  20d622:	0f 05                	syscall 
            switch (err) {
  20d624:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  20d628:	74 f3                	je     20d61d <openSelfDebugInfo+0x2d2d>
            const first = list.first orelse return null;
  20d62a:	48 8b 05 f7 39 01 00 	mov    rax,QWORD PTR [rip+0x139f7]        # 221028 <emfile_promise_queue>
  20d631:	48 85 c0             	test   rax,rax
  20d634:	74 7a                	je     20d6b0 <openSelfDebugInfo+0x2dc0>
            if (node.prev) |prev_node| {
  20d636:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  20d639:	48 85 c9             	test   rcx,rcx
  20d63c:	74 0e                	je     20d64c <openSelfDebugInfo+0x2d5c>
                prev_node.next = node.next;
  20d63e:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  20d642:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  20d646:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20d64a:	eb 0b                	jmp    20d657 <openSelfDebugInfo+0x2d67>
                list.first = node.next;
  20d64c:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20d650:	48 89 0d d1 39 01 00 	mov    QWORD PTR [rip+0x139d1],rcx        # 221028 <emfile_promise_queue>
            if (node.next) |next_node| {
  20d657:	48 85 c9             	test   rcx,rcx
  20d65a:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  20d65d:	48 8d 35 cc 39 01 00 	lea    rsi,[rip+0x139cc]        # 221030 <emfile_promise_queue+0x8>
  20d664:	48 0f 45 f1          	cmovne rsi,rcx
  20d668:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  20d66b:	48 83 05 c5 39 01 00 	add    QWORD PTR [rip+0x139c5],0xffffffffffffffff        # 221038 <emfile_promise_queue+0x10>
  20d672:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  20d673:	74 1e                	je     20d693 <openSelfDebugInfo+0x2da3>
  20d675:	48 83 3d ab 39 01 00 	cmp    QWORD PTR [rip+0x139ab],0x0        # 221028 <emfile_promise_queue>
  20d67c:	00 
  20d67d:	0f 84 d1 12 00 00    	je     20e954 <openSelfDebugInfo+0x4064>
  20d683:	48 8b 0d a6 39 01 00 	mov    rcx,QWORD PTR [rip+0x139a6]        # 221030 <emfile_promise_queue+0x8>
  20d68a:	48 85 c9             	test   rcx,rcx
  20d68d:	0f 84 c1 12 00 00    	je     20e954 <openSelfDebugInfo+0x4064>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  20d693:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  20d697:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  20d69b:	48 89 c1             	mov    rcx,rax
  20d69e:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  20d6a2:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  20d6a8:	75 f1                	jne    20d69b <openSelfDebugInfo+0x2dab>
  20d6aa:	a8 01                	test   al,0x1
  20d6ac:	75 02                	jne    20d6b0 <openSelfDebugInfo+0x2dc0>
  20d6ae:	ff 17                	call   QWORD PTR [rdi]
  20d6b0:	49 8b 44 24 10       	mov    rax,QWORD PTR [r12+0x10]
  20d6b5:	48 89 ac 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rbp
  20d6bc:	00 
  20d6bd:	48 c7 84 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],0xc8
  20d6c4:	00 c8 00 00 00 
  20d6c9:	48 8d b4 24 f0 00 00 	lea    rsi,[rsp+0xf0]
  20d6d0:	00 
  20d6d1:	4c 89 e7             	mov    rdi,r12
  20d6d4:	ff d0                	call   rax
            st.debug_ranges = (try st.elf.findSection(".debug_ranges"));
  20d6d6:	0f b7 84 24 00 03 00 	movzx  eax,WORD PTR [rsp+0x300]
  20d6dd:	00 
  20d6de:	66 41 89 06          	mov    WORD PTR [r14],ax
  20d6e2:	48 8b 84 24 b0 04 00 	mov    rax,QWORD PTR [rsp+0x4b0]
  20d6e9:	00 
  20d6ea:	48 8b 8c 24 b6 04 00 	mov    rcx,QWORD PTR [rsp+0x4b6]
  20d6f1:	00 
  20d6f2:	e9 10 df ff ff       	jmp    20b607 <openSelfDebugInfo+0xd17>
                list.first = node.next;
  20d6f7:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20d6fb:	48 89 0d 26 39 01 00 	mov    QWORD PTR [rip+0x13926],rcx        # 221028 <emfile_promise_queue>
            if (node.next) |next_node| {
  20d702:	48 85 c9             	test   rcx,rcx
  20d705:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  20d708:	48 8d 35 21 39 01 00 	lea    rsi,[rip+0x13921]        # 221030 <emfile_promise_queue+0x8>
  20d70f:	48 0f 45 f1          	cmovne rsi,rcx
  20d713:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  20d716:	48 83 05 1a 39 01 00 	add    QWORD PTR [rip+0x1391a],0xffffffffffffffff        # 221038 <emfile_promise_queue+0x10>
  20d71d:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  20d71e:	74 1e                	je     20d73e <openSelfDebugInfo+0x2e4e>
  20d720:	48 83 3d 00 39 01 00 	cmp    QWORD PTR [rip+0x13900],0x0        # 221028 <emfile_promise_queue>
  20d727:	00 
  20d728:	0f 84 26 12 00 00    	je     20e954 <openSelfDebugInfo+0x4064>
  20d72e:	48 8b 0d fb 38 01 00 	mov    rcx,QWORD PTR [rip+0x138fb]        # 221030 <emfile_promise_queue+0x8>
  20d735:	48 85 c9             	test   rcx,rcx
  20d738:	0f 84 16 12 00 00    	je     20e954 <openSelfDebugInfo+0x4064>
  20d73e:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  20d742:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  20d746:	48 89 c1             	mov    rcx,rax
  20d749:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  20d74d:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  20d753:	75 f1                	jne    20d746 <openSelfDebugInfo+0x2e56>
  20d755:	a8 01                	test   al,0x1
  20d757:	75 02                	jne    20d75b <openSelfDebugInfo+0x2e6b>
  20d759:	ff 17                	call   QWORD PTR [rdi]
  20d75b:	48 63 7d 00          	movsxd rdi,DWORD PTR [rbp+0x0]
  20d75f:	b8 03 00 00 00       	mov    eax,0x3
  20d764:	0f 05                	syscall 
            switch (err) {
  20d766:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  20d76a:	74 f3                	je     20d75f <openSelfDebugInfo+0x2e6f>
            const first = list.first orelse return null;
  20d76c:	48 8b 05 b5 38 01 00 	mov    rax,QWORD PTR [rip+0x138b5]        # 221028 <emfile_promise_queue>
  20d773:	48 85 c0             	test   rax,rax
  20d776:	0f 84 27 e2 ff ff    	je     20b9a3 <openSelfDebugInfo+0x10b3>
            if (node.prev) |prev_node| {
  20d77c:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  20d77f:	48 85 c9             	test   rcx,rcx
  20d782:	74 0e                	je     20d792 <openSelfDebugInfo+0x2ea2>
                prev_node.next = node.next;
  20d784:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  20d788:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  20d78c:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20d790:	eb 0b                	jmp    20d79d <openSelfDebugInfo+0x2ead>
                list.first = node.next;
  20d792:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20d796:	48 89 0d 8b 38 01 00 	mov    QWORD PTR [rip+0x1388b],rcx        # 221028 <emfile_promise_queue>
            if (node.next) |next_node| {
  20d79d:	48 85 c9             	test   rcx,rcx
  20d7a0:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  20d7a3:	48 8d 35 86 38 01 00 	lea    rsi,[rip+0x13886]        # 221030 <emfile_promise_queue+0x8>
  20d7aa:	48 0f 45 f1          	cmovne rsi,rcx
  20d7ae:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  20d7b1:	48 83 05 7f 38 01 00 	add    QWORD PTR [rip+0x1387f],0xffffffffffffffff        # 221038 <emfile_promise_queue+0x10>
  20d7b8:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  20d7b9:	74 1e                	je     20d7d9 <openSelfDebugInfo+0x2ee9>
  20d7bb:	48 83 3d 65 38 01 00 	cmp    QWORD PTR [rip+0x13865],0x0        # 221028 <emfile_promise_queue>
  20d7c2:	00 
  20d7c3:	0f 84 8b 11 00 00    	je     20e954 <openSelfDebugInfo+0x4064>
  20d7c9:	48 8b 0d 60 38 01 00 	mov    rcx,QWORD PTR [rip+0x13860]        # 221030 <emfile_promise_queue+0x8>
  20d7d0:	48 85 c9             	test   rcx,rcx
  20d7d3:	0f 84 7b 11 00 00    	je     20e954 <openSelfDebugInfo+0x4064>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  20d7d9:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  20d7dd:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  20d7e1:	48 89 c1             	mov    rcx,rax
  20d7e4:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  20d7e8:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  20d7ee:	75 f1                	jne    20d7e1 <openSelfDebugInfo+0x2ef1>
  20d7f0:	e9 a8 e1 ff ff       	jmp    20b99d <openSelfDebugInfo+0x10ad>
  20d7f5:	66 b9 1e 00          	mov    cx,0x1e
  20d7f9:	eb 04                	jmp    20d7ff <openSelfDebugInfo+0x2f0f>
  20d7fb:	66 b9 23 00          	mov    cx,0x23
        const abbrev_code = try readULeb128(in_stream);
  20d7ff:	48 8b 84 24 0e 01 00 	mov    rax,QWORD PTR [rsp+0x10e]
  20d806:	00 
  20d807:	48 89 84 24 ee 01 00 	mov    QWORD PTR [rsp+0x1ee],rax
  20d80e:	00 
  20d80f:	c5 fe 6f 84 24 f0 00 	vmovdqu ymm0,YMMWORD PTR [rsp+0xf0]
  20d816:	00 00 
  20d818:	c5 fe 7f 84 24 d0 01 	vmovdqu YMMWORD PTR [rsp+0x1d0],ymm0
  20d81f:	00 00 
  20d821:	89 cf                	mov    edi,ecx
  20d823:	89 fb                	mov    ebx,edi
            try scanAllCompileUnits(st);
  20d825:	66 85 ff             	test   di,di
  20d828:	0f 85 55 01 00 00    	jne    20d983 <openSelfDebugInfo+0x3093>
  20d82e:	e9 5b fd ff ff       	jmp    20d58e <openSelfDebugInfo+0x2c9e>
  20d833:	66 b8 1e 00          	mov    ax,0x1e
  20d837:	89 c7                	mov    edi,eax
  20d839:	89 fb                	mov    ebx,edi
  20d83b:	66 85 ff             	test   di,di
  20d83e:	0f 85 3f 01 00 00    	jne    20d983 <openSelfDebugInfo+0x3093>
  20d844:	e9 45 fd ff ff       	jmp    20d58e <openSelfDebugInfo+0x2c9e>
  20d849:	66 b9 1e 00          	mov    cx,0x1e
  20d84d:	eb 04                	jmp    20d853 <openSelfDebugInfo+0x2f63>
  20d84f:	66 b9 23 00          	mov    cx,0x23
    const abbrev_code = try readULeb128(in_stream);
  20d853:	c5 fe 6f 84 24 f0 00 	vmovdqu ymm0,YMMWORD PTR [rsp+0xf0]
  20d85a:	00 00 
  20d85c:	c5 fe 6f 8c 24 06 01 	vmovdqu ymm1,YMMWORD PTR [rsp+0x106]
  20d863:	00 00 
  20d865:	c5 fe 7f 8c 24 d6 02 	vmovdqu YMMWORD PTR [rsp+0x2d6],ymm1
  20d86c:	00 00 
  20d86e:	c5 fe 7f 84 24 c0 02 	vmovdqu YMMWORD PTR [rsp+0x2c0],ymm0
  20d875:	00 00 
  20d877:	89 cf                	mov    edi,ecx
  20d879:	89 fb                	mov    ebx,edi
            try scanAllCompileUnits(st);
  20d87b:	66 85 ff             	test   di,di
  20d87e:	0f 85 ff 00 00 00    	jne    20d983 <openSelfDebugInfo+0x3093>
  20d884:	e9 05 fd ff ff       	jmp    20d58e <openSelfDebugInfo+0x2c9e>
  20d889:	66 bf 21 00          	mov    di,0x21
  20d88d:	89 fb                	mov    ebx,edi
  20d88f:	66 85 ff             	test   di,di
  20d892:	0f 85 eb 00 00 00    	jne    20d983 <openSelfDebugInfo+0x3093>
  20d898:	e9 f1 fc ff ff       	jmp    20d58e <openSelfDebugInfo+0x2c9e>
  20d89d:	66 bf 23 00          	mov    di,0x23
  20d8a1:	89 fb                	mov    ebx,edi
  20d8a3:	66 85 ff             	test   di,di
  20d8a6:	0f 85 d7 00 00 00    	jne    20d983 <openSelfDebugInfo+0x3093>
  20d8ac:	e9 dd fc ff ff       	jmp    20d58e <openSelfDebugInfo+0x2c9e>
  20d8b1:	48 8d 41 ea          	lea    rax,[rcx-0x16]
  20d8b5:	48 83 f8 35          	cmp    rax,0x35
  20d8b9:	77 14                	ja     20d8cf <openSelfDebugInfo+0x2fdf>
  20d8bb:	48 ba 81 00 00 00 00 	movabs rdx,0x20000000000081
  20d8c2:	00 20 00 
  20d8c5:	48 0f a3 c2          	bt     rdx,rax
  20d8c9:	0f 82 9f 00 00 00    	jb     20d96e <openSelfDebugInfo+0x307e>
  20d8cf:	66 bf 02 00          	mov    di,0x2
  20d8d3:	48 83 f9 06          	cmp    rcx,0x6
  20d8d7:	0f 84 91 00 00 00    	je     20d96e <openSelfDebugInfo+0x307e>
  20d8dd:	e9 96 00 00 00       	jmp    20d978 <openSelfDebugInfo+0x3088>
    const table_entry = getAbbrevTableEntry(abbrev_table, abbrev_code) orelse return error.InvalidDebugInfo;
  20d8e2:	c5 fc 10 05 36 7d ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffff7d36]        # 205620 <__unnamed_53+0x18>
  20d8e9:	ff 
  20d8ea:	c5 fc 11 84 24 d6 02 	vmovups YMMWORD PTR [rsp+0x2d6],ymm0
  20d8f1:	00 00 
  20d8f3:	c5 fe 6f 05 0f 7d ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffff7d0f]        # 20560a <__unnamed_53+0x2>
  20d8fa:	ff 
  20d8fb:	c5 fe 7f 84 24 c0 02 	vmovdqu YMMWORD PTR [rsp+0x2c0],ymm0
  20d902:	00 00 
  20d904:	66 bf 23 00          	mov    di,0x23
  20d908:	89 fb                	mov    ebx,edi
            try scanAllCompileUnits(st);
  20d90a:	66 85 ff             	test   di,di
  20d90d:	75 74                	jne    20d983 <openSelfDebugInfo+0x3093>
  20d90f:	e9 7a fc ff ff       	jmp    20d58e <openSelfDebugInfo+0x2c9e>
  20d914:	66 b9 1e 00          	mov    cx,0x1e
  20d918:	eb 04                	jmp    20d91e <openSelfDebugInfo+0x302e>
  20d91a:	66 b9 23 00          	mov    cx,0x23
            .tag_id = try readULeb128(in_stream),
  20d91e:	48 8b 84 24 f6 03 00 	mov    rax,QWORD PTR [rsp+0x3f6]
  20d925:	00 
  20d926:	48 89 84 24 ee 01 00 	mov    QWORD PTR [rsp+0x1ee],rax
  20d92d:	00 
  20d92e:	c5 fc 10 84 24 d8 03 	vmovups ymm0,YMMWORD PTR [rsp+0x3d8]
  20d935:	00 00 
  20d937:	e9 dc fe ff ff       	jmp    20d818 <openSelfDebugInfo+0x2f28>
  20d93c:	48 8d 4e ea          	lea    rcx,[rsi-0x16]
  20d940:	48 83 f9 35          	cmp    rcx,0x35
  20d944:	77 14                	ja     20d95a <openSelfDebugInfo+0x306a>
  20d946:	48 ba 81 00 00 00 00 	movabs rdx,0x20000000000081
  20d94d:	00 20 00 
  20d950:	48 0f a3 ca          	bt     rdx,rcx
  20d954:	0f 82 06 02 00 00    	jb     20db60 <openSelfDebugInfo+0x3270>
  20d95a:	66 c7 84 24 c8 01 00 	mov    WORD PTR [rsp+0x1c8],0x2
  20d961:	00 02 00 
                if (err > 0) {
  20d964:	48 83 fe 06          	cmp    rsi,0x6
  20d968:	66 bf 20 00          	mov    di,0x20
  20d96c:	74 0a                	je     20d978 <openSelfDebugInfo+0x3088>
  20d96e:	0f b7 84 24 c8 01 00 	movzx  eax,WORD PTR [rsp+0x1c8]
  20d975:	00 
  20d976:	89 c7                	mov    edi,eax
  20d978:	89 fb                	mov    ebx,edi
            try scanAllCompileUnits(st);
  20d97a:	66 85 ff             	test   di,di
  20d97d:	0f 84 0b fc ff ff    	je     20d58e <openSelfDebugInfo+0x2c9e>
        const bytes = @sliceToBytes(memory);
  20d983:	48 8b 45 48          	mov    rax,QWORD PTR [rbp+0x48]
  20d987:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  20d98b:	74 29                	je     20d9b6 <openSelfDebugInfo+0x30c6>
  20d98d:	48 8b 7d 50          	mov    rdi,QWORD PTR [rbp+0x50]
        const bytes = @sliceToBytes(memory);
  20d991:	48 8b 4d 40          	mov    rcx,QWORD PTR [rbp+0x40]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  20d995:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  20d999:	48 89 8c 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rcx
  20d9a0:	00 
  20d9a1:	48 89 84 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],rax
  20d9a8:	00 
  20d9a9:	48 8d b4 24 f0 00 00 	lea    rsi,[rsp+0xf0]
  20d9b0:	00 
  20d9b1:	c5 f8 77             	vzeroupper 
  20d9b4:	ff d2                	call   rdx
  20d9b6:	80 7d 10 01          	cmp    BYTE PTR [rbp+0x10],0x1
  20d9ba:	0f 85 9c 00 00 00    	jne    20da5c <openSelfDebugInfo+0x316c>
  20d9c0:	49 8b 07             	mov    rax,QWORD PTR [r15]
  20d9c3:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  20d9c6:	b8 03 00 00 00       	mov    eax,0x3
  20d9cb:	0f 05                	syscall 
            switch (err) {
  20d9cd:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  20d9d1:	74 f3                	je     20d9c6 <openSelfDebugInfo+0x30d6>
            const first = list.first orelse return null;
  20d9d3:	48 8b 05 4e 36 01 00 	mov    rax,QWORD PTR [rip+0x1364e]        # 221028 <emfile_promise_queue>
  20d9da:	48 85 c0             	test   rax,rax
  20d9dd:	74 7d                	je     20da5c <openSelfDebugInfo+0x316c>
            if (node.prev) |prev_node| {
  20d9df:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  20d9e2:	48 85 c9             	test   rcx,rcx
  20d9e5:	74 0e                	je     20d9f5 <openSelfDebugInfo+0x3105>
                prev_node.next = node.next;
  20d9e7:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  20d9eb:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  20d9ef:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20d9f3:	eb 0b                	jmp    20da00 <openSelfDebugInfo+0x3110>
                list.first = node.next;
  20d9f5:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20d9f9:	48 89 0d 28 36 01 00 	mov    QWORD PTR [rip+0x13628],rcx        # 221028 <emfile_promise_queue>
            if (node.next) |next_node| {
  20da00:	48 85 c9             	test   rcx,rcx
  20da03:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  20da06:	48 8d 35 23 36 01 00 	lea    rsi,[rip+0x13623]        # 221030 <emfile_promise_queue+0x8>
  20da0d:	48 0f 45 f1          	cmovne rsi,rcx
  20da11:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  20da14:	48 83 05 1c 36 01 00 	add    QWORD PTR [rip+0x1361c],0xffffffffffffffff        # 221038 <emfile_promise_queue+0x10>
  20da1b:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  20da1c:	74 1e                	je     20da3c <openSelfDebugInfo+0x314c>
  20da1e:	48 83 3d 02 36 01 00 	cmp    QWORD PTR [rip+0x13602],0x0        # 221028 <emfile_promise_queue>
  20da25:	00 
  20da26:	0f 84 28 0f 00 00    	je     20e954 <openSelfDebugInfo+0x4064>
  20da2c:	48 8b 0d fd 35 01 00 	mov    rcx,QWORD PTR [rip+0x135fd]        # 221030 <emfile_promise_queue+0x8>
  20da33:	48 85 c9             	test   rcx,rcx
  20da36:	0f 84 18 0f 00 00    	je     20e954 <openSelfDebugInfo+0x4064>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  20da3c:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  20da40:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  20da44:	48 89 c1             	mov    rcx,rax
  20da47:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  20da4b:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  20da51:	75 f1                	jne    20da44 <openSelfDebugInfo+0x3154>
  20da53:	a8 01                	test   al,0x1
  20da55:	75 05                	jne    20da5c <openSelfDebugInfo+0x316c>
  20da57:	c5 f8 77             	vzeroupper 
  20da5a:	ff 17                	call   QWORD PTR [rdi]
  20da5c:	48 63 7d 00          	movsxd rdi,DWORD PTR [rbp+0x0]
  20da60:	b8 03 00 00 00       	mov    eax,0x3
  20da65:	0f 05                	syscall 
            switch (err) {
  20da67:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  20da6b:	74 f3                	je     20da60 <openSelfDebugInfo+0x3170>
            const first = list.first orelse return null;
  20da6d:	48 8b 05 b4 35 01 00 	mov    rax,QWORD PTR [rip+0x135b4]        # 221028 <emfile_promise_queue>
  20da74:	48 85 c0             	test   rax,rax
  20da77:	74 7d                	je     20daf6 <openSelfDebugInfo+0x3206>
            if (node.prev) |prev_node| {
  20da79:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  20da7c:	48 85 c9             	test   rcx,rcx
  20da7f:	74 0e                	je     20da8f <openSelfDebugInfo+0x319f>
                prev_node.next = node.next;
  20da81:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  20da85:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  20da89:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20da8d:	eb 0b                	jmp    20da9a <openSelfDebugInfo+0x31aa>
                list.first = node.next;
  20da8f:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20da93:	48 89 0d 8e 35 01 00 	mov    QWORD PTR [rip+0x1358e],rcx        # 221028 <emfile_promise_queue>
            if (node.next) |next_node| {
  20da9a:	48 85 c9             	test   rcx,rcx
  20da9d:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  20daa0:	48 8d 35 89 35 01 00 	lea    rsi,[rip+0x13589]        # 221030 <emfile_promise_queue+0x8>
  20daa7:	48 0f 45 f1          	cmovne rsi,rcx
  20daab:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  20daae:	48 83 05 82 35 01 00 	add    QWORD PTR [rip+0x13582],0xffffffffffffffff        # 221038 <emfile_promise_queue+0x10>
  20dab5:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  20dab6:	74 1e                	je     20dad6 <openSelfDebugInfo+0x31e6>
  20dab8:	48 83 3d 68 35 01 00 	cmp    QWORD PTR [rip+0x13568],0x0        # 221028 <emfile_promise_queue>
  20dabf:	00 
  20dac0:	0f 84 8e 0e 00 00    	je     20e954 <openSelfDebugInfo+0x4064>
  20dac6:	48 8b 0d 63 35 01 00 	mov    rcx,QWORD PTR [rip+0x13563]        # 221030 <emfile_promise_queue+0x8>
  20dacd:	48 85 c9             	test   rcx,rcx
  20dad0:	0f 84 7e 0e 00 00    	je     20e954 <openSelfDebugInfo+0x4064>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  20dad6:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  20dada:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  20dade:	48 89 c1             	mov    rcx,rax
  20dae1:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  20dae5:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  20daeb:	75 f1                	jne    20dade <openSelfDebugInfo+0x31ee>
  20daed:	a8 01                	test   al,0x1
  20daef:	75 05                	jne    20daf6 <openSelfDebugInfo+0x3206>
  20daf1:	c5 f8 77             	vzeroupper 
  20daf4:	ff 17                	call   QWORD PTR [rdi]
        self.freeFn(self, non_const_ptr[0..@sizeOf(@typeOf(ptr).Child)]);
  20daf6:	49 8b 44 24 10       	mov    rax,QWORD PTR [r12+0x10]
  20dafb:	48 89 ac 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rbp
  20db02:	00 
  20db03:	48 c7 84 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],0xc8
  20db0a:	00 c8 00 00 00 
  20db0f:	48 8d b4 24 f0 00 00 	lea    rsi,[rsp+0xf0]
  20db16:	00 
  20db17:	4c 89 e7             	mov    rdi,r12
  20db1a:	c5 f8 77             	vzeroupper 
  20db1d:	ff d0                	call   rax
  20db1f:	66 41 89 1e          	mov    WORD PTR [r14],bx
  20db23:	48 8b 84 24 a2 04 00 	mov    rax,QWORD PTR [rsp+0x4a2]
  20db2a:	00 
  20db2b:	48 8b 8c 24 a8 04 00 	mov    rcx,QWORD PTR [rsp+0x4a8]
  20db32:	00 
  20db33:	e9 cf da ff ff       	jmp    20b607 <openSelfDebugInfo+0xd17>
  20db38:	48 8d 41 ea          	lea    rax,[rcx-0x16]
  20db3c:	48 83 f8 35          	cmp    rax,0x35
  20db40:	77 10                	ja     20db52 <openSelfDebugInfo+0x3262>
  20db42:	48 ba 81 00 00 00 00 	movabs rdx,0x20000000000081
  20db49:	00 20 00 
  20db4c:	48 0f a3 c2          	bt     rdx,rax
  20db50:	72 0e                	jb     20db60 <openSelfDebugInfo+0x3270>
  20db52:	66 bf 02 00          	mov    di,0x2
                if (err > 0) {
  20db56:	48 83 f9 06          	cmp    rcx,0x6
  20db5a:	0f 85 18 fe ff ff    	jne    20d978 <openSelfDebugInfo+0x3088>
  20db60:	66 bf 20 00          	mov    di,0x20
  20db64:	89 fb                	mov    ebx,edi
  20db66:	66 85 ff             	test   di,di
  20db69:	0f 85 14 fe ff ff    	jne    20d983 <openSelfDebugInfo+0x3093>
  20db6f:	e9 1a fa ff ff       	jmp    20d58e <openSelfDebugInfo+0x2c9e>
            .value = try parseFormValue(st.allocator(), in_stream, attr.form_id, is_64),
  20db74:	c5 fc 10 84 24 d8 03 	vmovups ymm0,YMMWORD PTR [rsp+0x3d8]
  20db7b:	00 00 
  20db7d:	c5 fc 10 8c 24 ee 03 	vmovups ymm1,YMMWORD PTR [rsp+0x3ee]
  20db84:	00 00 
  20db86:	c5 fc 11 8c 24 d6 02 	vmovups YMMWORD PTR [rsp+0x2d6],ymm1
  20db8d:	00 00 
  20db8f:	c5 fc 11 84 24 c0 02 	vmovups YMMWORD PTR [rsp+0x2c0],ymm0
  20db96:	00 00 
  20db98:	89 c7                	mov    edi,eax
  20db9a:	89 fb                	mov    ebx,edi
            try scanAllCompileUnits(st);
  20db9c:	66 85 ff             	test   di,di
  20db9f:	0f 85 de fd ff ff    	jne    20d983 <openSelfDebugInfo+0x3093>
  20dba5:	e9 e4 f9 ff ff       	jmp    20d58e <openSelfDebugInfo+0x2c9e>
  20dbaa:	66 b9 1e 00          	mov    cx,0x1e
  20dbae:	eb 04                	jmp    20dbb4 <openSelfDebugInfo+0x32c4>
  20dbb0:	66 b9 23 00          	mov    cx,0x23
            const form_id = try readULeb128(in_stream);
  20dbb4:	48 8b 84 24 be 03 00 	mov    rax,QWORD PTR [rsp+0x3be]
  20dbbb:	00 
  20dbbc:	48 89 84 24 ee 01 00 	mov    QWORD PTR [rsp+0x1ee],rax
  20dbc3:	00 
  20dbc4:	c5 fc 10 84 24 a0 03 	vmovups ymm0,YMMWORD PTR [rsp+0x3a0]
  20dbcb:	00 00 
  20dbcd:	e9 46 fc ff ff       	jmp    20d818 <openSelfDebugInfo+0x2f28>
  20dbd2:	66 b9 1e 00          	mov    cx,0x1e
  20dbd6:	eb 04                	jmp    20dbdc <openSelfDebugInfo+0x32ec>
  20dbd8:	66 b9 23 00          	mov    cx,0x23
            const attr_id = try readULeb128(in_stream);
  20dbdc:	48 8b 84 24 96 03 00 	mov    rax,QWORD PTR [rsp+0x396]
  20dbe3:	00 
  20dbe4:	48 89 84 24 ee 01 00 	mov    QWORD PTR [rsp+0x1ee],rax
  20dbeb:	00 
  20dbec:	c5 fc 10 84 24 78 03 	vmovups ymm0,YMMWORD PTR [rsp+0x378]
  20dbf3:	00 00 
  20dbf5:	e9 1e fc ff ff       	jmp    20d818 <openSelfDebugInfo+0x2f28>
  20dbfa:	66 b9 1e 00          	mov    cx,0x1e
            .has_children = (try in_stream.readByte()) == DW.CHILDREN_yes,
  20dbfe:	48 8b 84 24 86 04 00 	mov    rax,QWORD PTR [rsp+0x486]
  20dc05:	00 
  20dc06:	48 89 84 24 ee 01 00 	mov    QWORD PTR [rsp+0x1ee],rax
  20dc0d:	00 
  20dc0e:	c5 fc 10 84 24 68 04 	vmovups ymm0,YMMWORD PTR [rsp+0x468]
  20dc15:	00 00 
  20dc17:	e9 fc fb ff ff       	jmp    20d818 <openSelfDebugInfo+0x2f28>
    try result.attrs.resize(table_entry.attrs.len);
  20dc1c:	c5 fc 10 84 24 98 00 	vmovups ymm0,YMMWORD PTR [rsp+0x98]
  20dc23:	00 00 
  20dc25:	c5 fc 10 8c 24 ae 00 	vmovups ymm1,YMMWORD PTR [rsp+0xae]
  20dc2c:	00 00 
  20dc2e:	e9 53 ff ff ff       	jmp    20db86 <openSelfDebugInfo+0x3296>
        try result.append(AbbrevTableEntry{
  20dc33:	48 8b 84 24 a6 02 00 	mov    rax,QWORD PTR [rsp+0x2a6]
  20dc3a:	00 
  20dc3b:	48 89 84 24 ee 01 00 	mov    QWORD PTR [rsp+0x1ee],rax
  20dc42:	00 
  20dc43:	c5 fc 10 84 24 88 02 	vmovups ymm0,YMMWORD PTR [rsp+0x288]
  20dc4a:	00 00 
  20dc4c:	e9 c7 fb ff ff       	jmp    20d818 <openSelfDebugInfo+0x2f28>
            try attrs.append(AbbrevAttr{
  20dc51:	48 8b 84 24 6e 03 00 	mov    rax,QWORD PTR [rsp+0x36e]
  20dc58:	00 
  20dc59:	48 89 84 24 ee 01 00 	mov    QWORD PTR [rsp+0x1ee],rax
  20dc60:	00 
  20dc61:	c5 fc 10 84 24 50 03 	vmovups ymm0,YMMWORD PTR [rsp+0x350]
  20dc68:	00 00 
  20dc6a:	e9 a9 fb ff ff       	jmp    20d818 <openSelfDebugInfo+0x2f28>
            try self.readNoEof(bytes[0..]);
  20dc6f:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  20dc74:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  20dc7b:	00 
  20dc7c:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x4
  20dc83:	00 04 00 00 00 
  20dc88:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  20dc8f:	00 
  20dc90:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  20dc97:	00 
            return self.readFn(self, buffer);
  20dc98:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  20dc9d:	ff 54 24 58          	call   QWORD PTR [rsp+0x58]
  20dca1:	44 0f b7 ac 24 f0 00 	movzx  r13d,WORD PTR [rsp+0xf0]
  20dca8:	00 00 
            const amt_read = try self.read(buf);
  20dcaa:	66 45 85 ed          	test   r13w,r13w
  20dcae:	0f 85 88 ce ff ff    	jne    20ab3c <openSelfDebugInfo+0x24c>
  20dcb4:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  20dcbb:	00 
  20dcbc:	66 41 bd 1e 00       	mov    r13w,0x1e
            if (amt_read < buf.len) return error.EndOfStream;
  20dcc1:	48 3b 84 24 a0 00 00 	cmp    rax,QWORD PTR [rsp+0xa0]
  20dcc8:	00 
  20dcc9:	0f 82 6d ce ff ff    	jb     20ab3c <openSelfDebugInfo+0x24c>
  20dccf:	0f b6 44 24 20       	movzx  eax,BYTE PTR [rsp+0x20]
  20dcd4:	0f b6 4c 24 21       	movzx  ecx,BYTE PTR [rsp+0x21]
    switch (endian) {
  20dcd9:	f6 44 24 40 01       	test   BYTE PTR [rsp+0x40],0x1
  20dcde:	74 1b                	je     20dcfb <openSelfDebugInfo+0x340b>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20dce0:	c1 e1 08             	shl    ecx,0x8
  20dce3:	09 c1                	or     ecx,eax
  20dce5:	0f b6 54 24 22       	movzx  edx,BYTE PTR [rsp+0x22]
  20dcea:	c1 e2 10             	shl    edx,0x10
  20dced:	09 ca                	or     edx,ecx
  20dcef:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  20dcf4:	c1 e0 18             	shl    eax,0x18
  20dcf7:	09 d0                	or     eax,edx
  20dcf9:	eb 19                	jmp    20dd14 <openSelfDebugInfo+0x3424>
                result = (result << 8) | b;
  20dcfb:	c1 e0 08             	shl    eax,0x8
  20dcfe:	09 c8                	or     eax,ecx
  20dd00:	c1 e0 08             	shl    eax,0x8
  20dd03:	0f b6 4c 24 22       	movzx  ecx,BYTE PTR [rsp+0x22]
  20dd08:	09 c1                	or     ecx,eax
  20dd0a:	c1 e1 08             	shl    ecx,0x8
  20dd0d:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  20dd12:	09 c8                	or     eax,ecx
            elf.entry_addr = u64(try in.readInt(elf.endian, u32));
  20dd14:	89 c0                	mov    eax,eax
  20dd16:	48 89 45 18          	mov    QWORD PTR [rbp+0x18],rax
            elf.program_header_offset = u64(try in.readInt(elf.endian, u32));
  20dd1a:	8a 45 12             	mov    al,BYTE PTR [rbp+0x12]
            try self.readNoEof(bytes[0..]);
  20dd1d:	88 44 24 40          	mov    BYTE PTR [rsp+0x40],al
  20dd21:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  20dd26:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  20dd2d:	00 
  20dd2e:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x4
  20dd35:	00 04 00 00 00 
  20dd3a:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  20dd41:	00 
  20dd42:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  20dd49:	00 
            return self.readFn(self, buffer);
  20dd4a:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  20dd4f:	ff 54 24 58          	call   QWORD PTR [rsp+0x58]
  20dd53:	44 0f b7 ac 24 f0 00 	movzx  r13d,WORD PTR [rsp+0xf0]
  20dd5a:	00 00 
            const amt_read = try self.read(buf);
  20dd5c:	66 45 85 ed          	test   r13w,r13w
  20dd60:	0f 85 d6 cd ff ff    	jne    20ab3c <openSelfDebugInfo+0x24c>
  20dd66:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  20dd6d:	00 
  20dd6e:	66 41 bd 1e 00       	mov    r13w,0x1e
            if (amt_read < buf.len) return error.EndOfStream;
  20dd73:	48 3b 84 24 a0 00 00 	cmp    rax,QWORD PTR [rsp+0xa0]
  20dd7a:	00 
  20dd7b:	0f 82 bb cd ff ff    	jb     20ab3c <openSelfDebugInfo+0x24c>
  20dd81:	0f b6 44 24 20       	movzx  eax,BYTE PTR [rsp+0x20]
  20dd86:	0f b6 4c 24 21       	movzx  ecx,BYTE PTR [rsp+0x21]
    switch (endian) {
  20dd8b:	f6 44 24 40 01       	test   BYTE PTR [rsp+0x40],0x1
  20dd90:	74 1b                	je     20ddad <openSelfDebugInfo+0x34bd>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20dd92:	c1 e1 08             	shl    ecx,0x8
  20dd95:	09 c1                	or     ecx,eax
  20dd97:	0f b6 54 24 22       	movzx  edx,BYTE PTR [rsp+0x22]
  20dd9c:	c1 e2 10             	shl    edx,0x10
  20dd9f:	09 ca                	or     edx,ecx
  20dda1:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  20dda6:	c1 e0 18             	shl    eax,0x18
  20dda9:	09 d0                	or     eax,edx
  20ddab:	eb 19                	jmp    20ddc6 <openSelfDebugInfo+0x34d6>
                result = (result << 8) | b;
  20ddad:	c1 e0 08             	shl    eax,0x8
  20ddb0:	09 c8                	or     eax,ecx
  20ddb2:	c1 e0 08             	shl    eax,0x8
  20ddb5:	0f b6 4c 24 22       	movzx  ecx,BYTE PTR [rsp+0x22]
  20ddba:	09 c1                	or     ecx,eax
  20ddbc:	c1 e1 08             	shl    ecx,0x8
  20ddbf:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  20ddc4:	09 c8                	or     eax,ecx
  20ddc6:	89 c0                	mov    eax,eax
  20ddc8:	48 89 45 20          	mov    QWORD PTR [rbp+0x20],rax
            elf.section_header_offset = u64(try in.readInt(elf.endian, u32));
  20ddcc:	8a 45 12             	mov    al,BYTE PTR [rbp+0x12]
            try self.readNoEof(bytes[0..]);
  20ddcf:	88 44 24 40          	mov    BYTE PTR [rsp+0x40],al
  20ddd3:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  20ddd8:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  20dddf:	00 
  20dde0:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x4
  20dde7:	00 04 00 00 00 
  20ddec:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  20ddf3:	00 
  20ddf4:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  20ddfb:	00 
            return self.readFn(self, buffer);
  20ddfc:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  20de01:	ff 54 24 58          	call   QWORD PTR [rsp+0x58]
  20de05:	44 0f b7 ac 24 f0 00 	movzx  r13d,WORD PTR [rsp+0xf0]
  20de0c:	00 00 
            const amt_read = try self.read(buf);
  20de0e:	66 45 85 ed          	test   r13w,r13w
  20de12:	0f 85 24 cd ff ff    	jne    20ab3c <openSelfDebugInfo+0x24c>
  20de18:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  20de1f:	00 
  20de20:	66 41 bd 1e 00       	mov    r13w,0x1e
            if (amt_read < buf.len) return error.EndOfStream;
  20de25:	48 3b 84 24 a0 00 00 	cmp    rax,QWORD PTR [rsp+0xa0]
  20de2c:	00 
  20de2d:	0f 82 09 cd ff ff    	jb     20ab3c <openSelfDebugInfo+0x24c>
  20de33:	0f b6 44 24 20       	movzx  eax,BYTE PTR [rsp+0x20]
  20de38:	0f b6 4c 24 21       	movzx  ecx,BYTE PTR [rsp+0x21]
    switch (endian) {
  20de3d:	f6 44 24 40 01       	test   BYTE PTR [rsp+0x40],0x1
  20de42:	74 1b                	je     20de5f <openSelfDebugInfo+0x356f>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20de44:	c1 e1 08             	shl    ecx,0x8
  20de47:	09 c1                	or     ecx,eax
  20de49:	0f b6 54 24 22       	movzx  edx,BYTE PTR [rsp+0x22]
  20de4e:	c1 e2 10             	shl    edx,0x10
  20de51:	09 ca                	or     edx,ecx
  20de53:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  20de58:	c1 e0 18             	shl    eax,0x18
  20de5b:	09 d0                	or     eax,edx
  20de5d:	eb 19                	jmp    20de78 <openSelfDebugInfo+0x3588>
                result = (result << 8) | b;
  20de5f:	c1 e0 08             	shl    eax,0x8
  20de62:	09 c8                	or     eax,ecx
  20de64:	c1 e0 08             	shl    eax,0x8
  20de67:	0f b6 4c 24 22       	movzx  ecx,BYTE PTR [rsp+0x22]
  20de6c:	09 c1                	or     ecx,eax
  20de6e:	c1 e1 08             	shl    ecx,0x8
  20de71:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  20de76:	09 c8                	or     eax,ecx
  20de78:	89 c0                	mov    eax,eax
  20de7a:	e9 a9 d2 ff ff       	jmp    20b128 <openSelfDebugInfo+0x838>
        const ph_entry_size = try in.readInt(elf.endian, u16);
  20de7f:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  20de84:	8a 00                	mov    al,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  20de86:	88 44 24 40          	mov    BYTE PTR [rsp+0x40],al
  20de8a:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  20de8f:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  20de96:	00 
  20de97:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x2
  20de9e:	00 02 00 00 00 
  20dea3:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  20deaa:	00 
  20deab:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  20deb2:	00 
            return self.readFn(self, buffer);
  20deb3:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  20deb8:	ff 54 24 58          	call   QWORD PTR [rsp+0x58]
  20debc:	44 0f b7 ac 24 f0 00 	movzx  r13d,WORD PTR [rsp+0xf0]
  20dec3:	00 00 
            const amt_read = try self.read(buf);
  20dec5:	66 45 85 ed          	test   r13w,r13w
  20dec9:	0f 85 6d cc ff ff    	jne    20ab3c <openSelfDebugInfo+0x24c>
  20decf:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  20ded6:	00 
  20ded7:	66 41 bd 1e 00       	mov    r13w,0x1e
            if (amt_read < buf.len) return error.EndOfStream;
  20dedc:	48 3b 84 24 a0 00 00 	cmp    rax,QWORD PTR [rsp+0xa0]
  20dee3:	00 
  20dee4:	0f 82 52 cc ff ff    	jb     20ab3c <openSelfDebugInfo+0x24c>
  20deea:	0f b6 54 24 20       	movzx  edx,BYTE PTR [rsp+0x20]
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20deef:	0f b6 44 24 21       	movzx  eax,BYTE PTR [rsp+0x21]
  20def4:	89 c1                	mov    ecx,eax
  20def6:	c1 e1 08             	shl    ecx,0x8
  20def9:	09 d1                	or     ecx,edx
                result = (result << 8) | b;
  20defb:	c1 e2 08             	shl    edx,0x8
  20defe:	09 c2                	or     edx,eax
    switch (endian) {
  20df00:	f6 44 24 40 01       	test   BYTE PTR [rsp+0x40],0x1
  20df05:	66 0f 45 d1          	cmovne dx,cx
  20df09:	89 54 24 78          	mov    DWORD PTR [rsp+0x78],edx
        const ph_entry_count = try in.readInt(elf.endian, u16);
  20df0d:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  20df12:	8a 00                	mov    al,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  20df14:	88 44 24 40          	mov    BYTE PTR [rsp+0x40],al
  20df18:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  20df1d:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  20df24:	00 
  20df25:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x2
  20df2c:	00 02 00 00 00 
  20df31:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  20df38:	00 
  20df39:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  20df40:	00 
            return self.readFn(self, buffer);
  20df41:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  20df46:	ff 54 24 58          	call   QWORD PTR [rsp+0x58]
  20df4a:	44 0f b7 ac 24 f0 00 	movzx  r13d,WORD PTR [rsp+0xf0]
  20df51:	00 00 
            const amt_read = try self.read(buf);
  20df53:	66 45 85 ed          	test   r13w,r13w
  20df57:	0f 85 df cb ff ff    	jne    20ab3c <openSelfDebugInfo+0x24c>
  20df5d:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  20df64:	00 
  20df65:	66 41 bd 1e 00       	mov    r13w,0x1e
            if (amt_read < buf.len) return error.EndOfStream;
  20df6a:	48 3b 84 24 a0 00 00 	cmp    rax,QWORD PTR [rsp+0xa0]
  20df71:	00 
  20df72:	0f 82 c4 cb ff ff    	jb     20ab3c <openSelfDebugInfo+0x24c>
  20df78:	0f b6 54 24 20       	movzx  edx,BYTE PTR [rsp+0x20]
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20df7d:	0f b6 44 24 21       	movzx  eax,BYTE PTR [rsp+0x21]
  20df82:	89 c1                	mov    ecx,eax
  20df84:	c1 e1 08             	shl    ecx,0x8
  20df87:	09 d1                	or     ecx,edx
                result = (result << 8) | b;
  20df89:	c1 e2 08             	shl    edx,0x8
  20df8c:	09 c2                	or     edx,eax
    switch (endian) {
  20df8e:	f6 44 24 40 01       	test   BYTE PTR [rsp+0x40],0x1
  20df93:	66 0f 45 d1          	cmovne dx,cx
  20df97:	89 94 24 90 00 00 00 	mov    DWORD PTR [rsp+0x90],edx
        const sh_entry_size = try in.readInt(elf.endian, u16);
  20df9e:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  20dfa3:	8a 00                	mov    al,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  20dfa5:	88 44 24 40          	mov    BYTE PTR [rsp+0x40],al
  20dfa9:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  20dfae:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  20dfb5:	00 
  20dfb6:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x2
  20dfbd:	00 02 00 00 00 
  20dfc2:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  20dfc9:	00 
  20dfca:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  20dfd1:	00 
            return self.readFn(self, buffer);
  20dfd2:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  20dfd7:	ff 54 24 58          	call   QWORD PTR [rsp+0x58]
  20dfdb:	44 0f b7 ac 24 f0 00 	movzx  r13d,WORD PTR [rsp+0xf0]
  20dfe2:	00 00 
            const amt_read = try self.read(buf);
  20dfe4:	66 45 85 ed          	test   r13w,r13w
  20dfe8:	0f 85 4e cb ff ff    	jne    20ab3c <openSelfDebugInfo+0x24c>
  20dfee:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  20dff5:	00 
  20dff6:	66 41 bd 1e 00       	mov    r13w,0x1e
            if (amt_read < buf.len) return error.EndOfStream;
  20dffb:	48 3b 84 24 a0 00 00 	cmp    rax,QWORD PTR [rsp+0xa0]
  20e002:	00 
  20e003:	0f 82 33 cb ff ff    	jb     20ab3c <openSelfDebugInfo+0x24c>
  20e009:	0f b6 54 24 20       	movzx  edx,BYTE PTR [rsp+0x20]
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20e00e:	0f b6 44 24 21       	movzx  eax,BYTE PTR [rsp+0x21]
  20e013:	89 c1                	mov    ecx,eax
  20e015:	c1 e1 08             	shl    ecx,0x8
  20e018:	09 d1                	or     ecx,edx
                result = (result << 8) | b;
  20e01a:	c1 e2 08             	shl    edx,0x8
  20e01d:	09 c2                	or     edx,eax
    switch (endian) {
  20e01f:	f6 44 24 40 01       	test   BYTE PTR [rsp+0x40],0x1
  20e024:	66 0f 45 d1          	cmovne dx,cx
  20e028:	89 54 24 48          	mov    DWORD PTR [rsp+0x48],edx
        const sh_entry_count = try in.readInt(elf.endian, u16);
  20e02c:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  20e031:	8a 00                	mov    al,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  20e033:	88 44 24 40          	mov    BYTE PTR [rsp+0x40],al
  20e037:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  20e03c:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  20e043:	00 
  20e044:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x2
  20e04b:	00 02 00 00 00 
  20e050:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  20e057:	00 
  20e058:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  20e05f:	00 
            return self.readFn(self, buffer);
  20e060:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  20e065:	ff 54 24 58          	call   QWORD PTR [rsp+0x58]
  20e069:	44 0f b7 ac 24 f0 00 	movzx  r13d,WORD PTR [rsp+0xf0]
  20e070:	00 00 
            const amt_read = try self.read(buf);
  20e072:	66 45 85 ed          	test   r13w,r13w
  20e076:	0f 85 c0 ca ff ff    	jne    20ab3c <openSelfDebugInfo+0x24c>
  20e07c:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  20e083:	00 
  20e084:	66 41 bd 1e 00       	mov    r13w,0x1e
            if (amt_read < buf.len) return error.EndOfStream;
  20e089:	48 3b 84 24 a0 00 00 	cmp    rax,QWORD PTR [rsp+0xa0]
  20e090:	00 
  20e091:	0f 82 a5 ca ff ff    	jb     20ab3c <openSelfDebugInfo+0x24c>
  20e097:	0f b6 54 24 20       	movzx  edx,BYTE PTR [rsp+0x20]
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20e09c:	0f b6 44 24 21       	movzx  eax,BYTE PTR [rsp+0x21]
  20e0a1:	89 c1                	mov    ecx,eax
  20e0a3:	c1 e1 08             	shl    ecx,0x8
  20e0a6:	09 d1                	or     ecx,edx
                result = (result << 8) | b;
  20e0a8:	c1 e2 08             	shl    edx,0x8
  20e0ab:	09 c2                	or     edx,eax
    switch (endian) {
  20e0ad:	f6 44 24 40 01       	test   BYTE PTR [rsp+0x40],0x1
  20e0b2:	66 0f 45 d1          	cmovne dx,cx
  20e0b6:	89 54 24 40          	mov    DWORD PTR [rsp+0x40],edx
        elf.string_section_index = u64(try in.readInt(elf.endian, u16));
  20e0ba:	8a 45 12             	mov    al,BYTE PTR [rbp+0x12]
            try self.readNoEof(bytes[0..]);
  20e0bd:	88 84 24 80 00 00 00 	mov    BYTE PTR [rsp+0x80],al
  20e0c4:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  20e0c9:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  20e0d0:	00 
  20e0d1:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x2
  20e0d8:	00 02 00 00 00 
  20e0dd:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  20e0e4:	00 
  20e0e5:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  20e0ec:	00 
  20e0ed:	48 89 bc 24 88 00 00 	mov    QWORD PTR [rsp+0x88],rdi
  20e0f4:	00 
            return self.readFn(self, buffer);
  20e0f5:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  20e0fa:	ff 54 24 58          	call   QWORD PTR [rsp+0x58]
  20e0fe:	44 0f b7 ac 24 f0 00 	movzx  r13d,WORD PTR [rsp+0xf0]
  20e105:	00 00 
            const amt_read = try self.read(buf);
  20e107:	66 45 85 ed          	test   r13w,r13w
  20e10b:	0f 85 2b ca ff ff    	jne    20ab3c <openSelfDebugInfo+0x24c>
  20e111:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  20e118:	00 
  20e119:	66 41 bd 1e 00       	mov    r13w,0x1e
            if (amt_read < buf.len) return error.EndOfStream;
  20e11e:	48 3b 84 24 a0 00 00 	cmp    rax,QWORD PTR [rsp+0xa0]
  20e125:	00 
  20e126:	0f 82 10 ca ff ff    	jb     20ab3c <openSelfDebugInfo+0x24c>
  20e12c:	0f b6 44 24 20       	movzx  eax,BYTE PTR [rsp+0x20]
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20e131:	0f b6 4c 24 21       	movzx  ecx,BYTE PTR [rsp+0x21]
  20e136:	89 ca                	mov    edx,ecx
  20e138:	c1 e2 08             	shl    edx,0x8
  20e13b:	09 c2                	or     edx,eax
                result = (result << 8) | b;
  20e13d:	c1 e0 08             	shl    eax,0x8
  20e140:	09 c8                	or     eax,ecx
    switch (endian) {
  20e142:	f6 84 24 80 00 00 00 	test   BYTE PTR [rsp+0x80],0x1
  20e149:	01 
  20e14a:	66 0f 45 c2          	cmovne ax,dx
  20e14e:	0f b7 c0             	movzx  eax,ax
  20e151:	48 89 45 30          	mov    QWORD PTR [rbp+0x30],rax
        if (elf.string_section_index >= sh_entry_count) return error.InvalidFormat;
  20e155:	66 3b 44 24 40       	cmp    ax,WORD PTR [rsp+0x40]
  20e15a:	0f 83 c3 d0 ff ff    	jae    20b223 <openSelfDebugInfo+0x933>
  20e160:	0f b7 4c 24 40       	movzx  ecx,WORD PTR [rsp+0x40]
        const sh_byte_count = u64(sh_entry_size) * u64(sh_entry_count);
  20e165:	0f b7 44 24 48       	movzx  eax,WORD PTR [rsp+0x48]
  20e16a:	48 89 44 24 48       	mov    QWORD PTR [rsp+0x48],rax
  20e16f:	48 89 4c 24 40       	mov    QWORD PTR [rsp+0x40],rcx
  20e174:	48 0f af c1          	imul   rax,rcx
    return if (@addWithOverflow(T, a, b, &answer)) error.Overflow else answer;
  20e178:	48 03 45 28          	add    rax,QWORD PTR [rbp+0x28]
  20e17c:	73 27                	jae    20e1a5 <openSelfDebugInfo+0x38b5>
  20e17e:	48 8d 05 ab 8e ff ff 	lea    rax,[rip+0xffffffffffff8eab]        # 207030 <__unnamed_54>
  20e185:	48 89 84 24 88 00 00 	mov    QWORD PTR [rsp+0x88],rax
  20e18c:	00 
  20e18d:	48 8b 84 24 88 00 00 	mov    rax,QWORD PTR [rsp+0x88]
  20e194:	00 
  20e195:	44 0f b7 28          	movzx  r13d,WORD PTR [rax]
        const end_sh = try math.add(u64, elf.section_header_offset, sh_byte_count);
  20e199:	66 45 85 ed          	test   r13w,r13w
  20e19d:	0f 85 99 c9 ff ff    	jne    20ab3c <openSelfDebugInfo+0x24c>
  20e1a3:	eb 28                	jmp    20e1cd <openSelfDebugInfo+0x38dd>
  20e1a5:	66 c7 84 24 f0 00 00 	mov    WORD PTR [rsp+0xf0],0x0
  20e1ac:	00 00 00 
  20e1af:	48 89 84 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],rax
  20e1b6:	00 
  20e1b7:	48 8b 84 24 88 00 00 	mov    rax,QWORD PTR [rsp+0x88]
  20e1be:	00 
  20e1bf:	44 0f b7 28          	movzx  r13d,WORD PTR [rax]
  20e1c3:	66 45 85 ed          	test   r13w,r13w
  20e1c7:	0f 85 6f c9 ff ff    	jne    20ab3c <openSelfDebugInfo+0x24c>
  20e1cd:	48 8b 84 24 88 00 00 	mov    rax,QWORD PTR [rsp+0x88]
  20e1d4:	00 
  20e1d5:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
        const ph_byte_count = u64(ph_entry_size) * u64(ph_entry_count);
  20e1d9:	0f b7 44 24 78       	movzx  eax,WORD PTR [rsp+0x78]
  20e1de:	0f b7 8c 24 90 00 00 	movzx  ecx,WORD PTR [rsp+0x90]
  20e1e5:	00 
  20e1e6:	48 0f af c8          	imul   rcx,rax
  20e1ea:	48 03 4d 20          	add    rcx,QWORD PTR [rbp+0x20]
  20e1ee:	73 17                	jae    20e207 <openSelfDebugInfo+0x3917>
  20e1f0:	48 8d 05 39 8e ff ff 	lea    rax,[rip+0xffffffffffff8e39]        # 207030 <__unnamed_54>
  20e1f7:	44 0f b7 28          	movzx  r13d,WORD PTR [rax]
        const end_ph = try math.add(u64, elf.program_header_offset, ph_byte_count);
  20e1fb:	66 45 85 ed          	test   r13w,r13w
  20e1ff:	0f 85 37 c9 ff ff    	jne    20ab3c <openSelfDebugInfo+0x24c>
  20e205:	eb 28                	jmp    20e22f <openSelfDebugInfo+0x393f>
  20e207:	48 8d 84 24 f0 00 00 	lea    rax,[rsp+0xf0]
  20e20e:	00 
  20e20f:	66 c7 84 24 f0 00 00 	mov    WORD PTR [rsp+0xf0],0x0
  20e216:	00 00 00 
  20e219:	48 89 8c 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],rcx
  20e220:	00 
  20e221:	44 0f b7 28          	movzx  r13d,WORD PTR [rax]
  20e225:	66 45 85 ed          	test   r13w,r13w
  20e229:	0f 85 0d c9 ff ff    	jne    20ab3c <openSelfDebugInfo+0x24c>
  20e22f:	4c 8b 40 08          	mov    r8,QWORD PTR [rax+0x8]
        const stream_end = try elf.in_file.getEndPos();
  20e233:	49 8b 07             	mov    rax,QWORD PTR [r15]
pub fn accept4(fd: i32, noalias addr: *sockaddr, noalias len: *socklen_t, flags: u32) usize {
    return syscall4(SYS_accept4, @intCast(usize, fd), @ptrToInt(addr), @ptrToInt(len), flags);
}

pub fn fstat(fd: i32, stat_buf: *Stat) usize {
    return syscall2(SYS_fstat, @intCast(usize, fd), @ptrToInt(stat_buf));
  20e236:	48 63 38             	movsxd rdi,DWORD PTR [rax]
        }
    }
}

pub fn posixFStat(fd: i32) !posix.Stat {
    var stat: posix.Stat = undefined;
  20e239:	c5 fc 10 05 e7 72 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffff72e7]        # 205528 <__unnamed_55+0x70>
  20e240:	ff 
  20e241:	c5 fc 11 84 24 60 01 	vmovups YMMWORD PTR [rsp+0x160],ymm0
  20e248:	00 00 
  20e24a:	c5 fc 10 05 c6 72 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffff72c6]        # 205518 <__unnamed_55+0x60>
  20e251:	ff 
  20e252:	c5 fc 11 84 24 50 01 	vmovups YMMWORD PTR [rsp+0x150],ymm0
  20e259:	00 00 
  20e25b:	c5 fc 10 05 95 72 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffff7295]        # 2054f8 <__unnamed_55+0x40>
  20e262:	ff 
  20e263:	c5 fc 11 84 24 30 01 	vmovups YMMWORD PTR [rsp+0x130],ymm0
  20e26a:	00 00 
  20e26c:	c5 fc 10 05 64 72 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffff7264]        # 2054d8 <__unnamed_55+0x20>
  20e273:	ff 
  20e274:	c5 fc 11 84 24 10 01 	vmovups YMMWORD PTR [rsp+0x110],ymm0
  20e27b:	00 00 
  20e27d:	c5 fe 6f 05 33 72 ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffff7233]        # 2054b8 <__unnamed_55>
  20e284:	ff 
  20e285:	c5 fe 7f 84 24 f0 00 	vmovdqu YMMWORD PTR [rsp+0xf0],ymm0
  20e28c:	00 00 
  20e28e:	48 8d b4 24 f0 00 00 	lea    rsi,[rsp+0xf0]
  20e295:	00 
    return asm volatile ("syscall"
  20e296:	b8 05 00 00 00       	mov    eax,0x5
  20e29b:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  20e29d:	48 89 c6             	mov    rsi,rax
  20e2a0:	48 f7 de             	neg    rsi
  20e2a3:	31 c9                	xor    ecx,ecx
  20e2a5:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  20e2ab:	48 0f 47 ce          	cmova  rcx,rsi
    const err = posix.getErrno(posix.fstat(fd, &stat));
    if (err > 0) {
  20e2af:	48 85 c9             	test   rcx,rcx
  20e2b2:	74 23                	je     20e2d7 <openSelfDebugInfo+0x39e7>
  20e2b4:	66 41 bd 04 00       	mov    r13w,0x4
  20e2b9:	48 83 f9 0c          	cmp    rcx,0xc
  20e2bd:	0f 84 79 c8 ff ff    	je     20ab3c <openSelfDebugInfo+0x24c>
  20e2c3:	66 41 bd 02 00       	mov    r13w,0x2
            try st.elf.openFile(allocator, &st.self_exe_file);
  20e2c8:	66 45 85 ed          	test   r13w,r13w
  20e2cc:	0f 85 74 c8 ff ff    	jne    20ab46 <openSelfDebugInfo+0x256>
  20e2d2:	e9 5b cf ff ff       	jmp    20b232 <openSelfDebugInfo+0x942>
            posix.ENOMEM => error.SystemResources,
            else => os.unexpectedErrorPosix(err),
        };
    }

    return stat;
  20e2d7:	48 8b 84 24 20 01 00 	mov    rax,QWORD PTR [rsp+0x120]
  20e2de:	00 
  20e2df:	48 89 84 24 c8 01 00 	mov    QWORD PTR [rsp+0x1c8],rax
  20e2e6:	00 
  20e2e7:	66 41 bd 1f 00       	mov    r13w,0x1f
        if (stream_end < end_sh or stream_end < end_ph) {
  20e2ec:	48 39 d0             	cmp    rax,rdx
  20e2ef:	0f 82 47 c8 ff ff    	jb     20ab3c <openSelfDebugInfo+0x24c>
  20e2f5:	4c 39 84 24 c8 01 00 	cmp    QWORD PTR [rsp+0x1c8],r8
  20e2fc:	00 
  20e2fd:	0f 82 39 c8 ff ff    	jb     20ab3c <openSelfDebugInfo+0x24c>
        try elf.in_file.seekTo(elf.section_header_offset);
  20e303:	48 8b 75 28          	mov    rsi,QWORD PTR [rbp+0x28]
    if (@maxValue(@typeOf(x)) > @maxValue(T) and x > @maxValue(T)) {
  20e307:	48 85 f6             	test   rsi,rsi
  20e30a:	0f 88 4c 06 00 00    	js     20e95c <openSelfDebugInfo+0x406c>
  20e310:	49 8b 07             	mov    rax,QWORD PTR [r15]
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  20e313:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  20e316:	45 31 c0             	xor    r8d,r8d
    return asm volatile ("syscall"
  20e319:	b8 08 00 00 00       	mov    eax,0x8
  20e31e:	31 d2                	xor    edx,edx
  20e320:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  20e322:	48 89 c1             	mov    rcx,rax
  20e325:	48 f7 d9             	neg    rcx
  20e328:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  20e32e:	49 0f 46 c8          	cmovbe rcx,r8
  20e332:	48 83 f9 1d          	cmp    rcx,0x1d
  20e336:	0f 87 04 06 00 00    	ja     20e940 <openSelfDebugInfo+0x4050>
  20e33c:	48 8d 05 61 23 ff ff 	lea    rax,[rip+0xffffffffffff2361]        # 2006a4 <app_mask+0x424>
  20e343:	48 63 0c 88          	movsxd rcx,DWORD PTR [rax+rcx*4]
  20e347:	48 01 c1             	add    rcx,rax
  20e34a:	66 41 bd 02 00       	mov    r13w,0x2
  20e34f:	ff e1                	jmp    rcx
        elf.section_headers = try elf.allocator.alloc(SectionHeader, sh_entry_count);
  20e351:	48 8b 75 50          	mov    rsi,QWORD PTR [rbp+0x50]
    return if (@mulWithOverflow(T, a, b, &answer)) error.Overflow else answer;
  20e355:	48 8b 54 24 40       	mov    rdx,QWORD PTR [rsp+0x40]
  20e35a:	48 c1 e2 06          	shl    rdx,0x6
  20e35e:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  20e365:	00 
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  20e366:	b9 04 00 00 00       	mov    ecx,0x4
  20e36b:	48 89 94 24 80 01 00 	mov    QWORD PTR [rsp+0x180],rdx
  20e372:	00 
  20e373:	c5 f8 77             	vzeroupper 
  20e376:	ff 16                	call   QWORD PTR [rsi]
  20e378:	44 0f b7 ac 24 f0 00 	movzx  r13d,WORD PTR [rsp+0xf0]
  20e37f:	00 00 
  20e381:	66 45 85 ed          	test   r13w,r13w
  20e385:	0f 85 b1 c7 ff ff    	jne    20ab3c <openSelfDebugInfo+0x24c>
        assert(byte_slice.len == byte_count);
  20e38b:	48 8b 84 24 80 01 00 	mov    rax,QWORD PTR [rsp+0x180]
  20e392:	00 
  20e393:	48 39 84 24 00 01 00 	cmp    QWORD PTR [rsp+0x100],rax
  20e39a:	00 
    if (!ok) {
  20e39b:	0f 85 b3 05 00 00    	jne    20e954 <openSelfDebugInfo+0x4064>
  20e3a1:	48 8d 45 50          	lea    rax,[rbp+0x50]
  20e3a5:	48 89 44 24 78       	mov    QWORD PTR [rsp+0x78],rax
  20e3aa:	48 8d 45 40          	lea    rax,[rbp+0x40]
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  20e3ae:	48 89 84 24 90 00 00 	mov    QWORD PTR [rsp+0x90],rax
  20e3b5:	00 
  20e3b6:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  20e3bd:	00 
  20e3be:	48 89 84 24 80 00 00 	mov    QWORD PTR [rsp+0x80],rax
  20e3c5:	00 
  20e3c6:	48 89 45 40          	mov    QWORD PTR [rbp+0x40],rax
  20e3ca:	48 8d 45 48          	lea    rax,[rbp+0x48]
  20e3ce:	48 89 84 24 88 00 00 	mov    QWORD PTR [rsp+0x88],rax
  20e3d5:	00 
  20e3d6:	48 8b 44 24 40       	mov    rax,QWORD PTR [rsp+0x40]
  20e3db:	48 89 45 48          	mov    QWORD PTR [rbp+0x48],rax
        if (elf.is_64) {
  20e3df:	80 7d 11 01          	cmp    BYTE PTR [rbp+0x11],0x1
  20e3e3:	0f 85 87 05 00 00    	jne    20e970 <openSelfDebugInfo+0x4080>
            if (sh_entry_size != 64) return error.InvalidFormat;
  20e3e9:	83 7c 24 48 40       	cmp    DWORD PTR [rsp+0x48],0x40
  20e3ee:	0f 85 dd 0f 00 00    	jne    20f3d1 <openSelfDebugInfo+0x4ae1>
                elf_section.name = try in.readInt(elf.endian, u32);
  20e3f4:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  20e3f9:	8a 00                	mov    al,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  20e3fb:	88 44 24 70          	mov    BYTE PTR [rsp+0x70],al
  20e3ff:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  20e404:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  20e40b:	00 
  20e40c:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x4
  20e413:	00 04 00 00 00 
  20e418:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  20e41f:	00 
  20e420:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  20e427:	00 
            return self.readFn(self, buffer);
  20e428:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  20e42d:	ff 54 24 58          	call   QWORD PTR [rsp+0x58]
  20e431:	44 0f b7 ac 24 f0 00 	movzx  r13d,WORD PTR [rsp+0xf0]
  20e438:	00 00 
            const amt_read = try self.read(buf);
  20e43a:	66 45 85 ed          	test   r13w,r13w
  20e43e:	0f 85 cd 0f 00 00    	jne    20f411 <openSelfDebugInfo+0x4b21>
  20e444:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  20e44b:	00 
  20e44c:	31 c9                	xor    ecx,ecx
  20e44e:	48 89 8c 24 80 01 00 	mov    QWORD PTR [rsp+0x180],rcx
  20e455:	00 
  20e456:	b9 38 00 00 00       	mov    ecx,0x38
  20e45b:	48 89 4c 24 48       	mov    QWORD PTR [rsp+0x48],rcx
            if (amt_read < buf.len) return error.EndOfStream;
  20e460:	48 3b 84 24 a0 00 00 	cmp    rax,QWORD PTR [rsp+0xa0]
  20e467:	00 
  20e468:	0f 82 9e 0f 00 00    	jb     20f40c <openSelfDebugInfo+0x4b1c>
  20e46e:	0f b6 44 24 20       	movzx  eax,BYTE PTR [rsp+0x20]
  20e473:	0f b6 4c 24 21       	movzx  ecx,BYTE PTR [rsp+0x21]
    switch (endian) {
  20e478:	f6 44 24 70 01       	test   BYTE PTR [rsp+0x70],0x1
  20e47d:	74 1b                	je     20e49a <openSelfDebugInfo+0x3baa>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20e47f:	c1 e1 08             	shl    ecx,0x8
  20e482:	09 c1                	or     ecx,eax
  20e484:	0f b6 54 24 22       	movzx  edx,BYTE PTR [rsp+0x22]
  20e489:	c1 e2 10             	shl    edx,0x10
  20e48c:	09 ca                	or     edx,ecx
  20e48e:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  20e493:	c1 e0 18             	shl    eax,0x18
  20e496:	09 d0                	or     eax,edx
  20e498:	eb 19                	jmp    20e4b3 <openSelfDebugInfo+0x3bc3>
                result = (result << 8) | b;
  20e49a:	c1 e0 08             	shl    eax,0x8
  20e49d:	09 c8                	or     eax,ecx
  20e49f:	c1 e0 08             	shl    eax,0x8
  20e4a2:	0f b6 4c 24 22       	movzx  ecx,BYTE PTR [rsp+0x22]
  20e4a7:	09 c1                	or     ecx,eax
  20e4a9:	c1 e1 08             	shl    ecx,0x8
  20e4ac:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  20e4b1:	09 c8                	or     eax,ecx
  20e4b3:	48 8b 8c 24 80 00 00 	mov    rcx,QWORD PTR [rsp+0x80]
  20e4ba:	00 
  20e4bb:	48 8b 54 24 48       	mov    rdx,QWORD PTR [rsp+0x48]
  20e4c0:	89 44 11 c8          	mov    DWORD PTR [rcx+rdx*1-0x38],eax
                elf_section.sh_type = try in.readInt(elf.endian, u32);
  20e4c4:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  20e4c9:	0f b6 00             	movzx  eax,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  20e4cc:	88 44 24 70          	mov    BYTE PTR [rsp+0x70],al
  20e4d0:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  20e4d5:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  20e4dc:	00 
  20e4dd:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x4
  20e4e4:	00 04 00 00 00 
            return self.readFn(self, buffer);
  20e4e9:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  20e4f0:	00 
  20e4f1:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  20e4f6:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  20e4fd:	00 
  20e4fe:	ff 54 24 58          	call   QWORD PTR [rsp+0x58]
  20e502:	44 0f b7 ac 24 f0 00 	movzx  r13d,WORD PTR [rsp+0xf0]
  20e509:	00 00 
            const amt_read = try self.read(buf);
  20e50b:	66 45 85 ed          	test   r13w,r13w
  20e50f:	0f 85 fc 0e 00 00    	jne    20f411 <openSelfDebugInfo+0x4b21>
  20e515:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  20e51c:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  20e51d:	48 3b 84 24 a0 00 00 	cmp    rax,QWORD PTR [rsp+0xa0]
  20e524:	00 
  20e525:	0f 82 e1 0e 00 00    	jb     20f40c <openSelfDebugInfo+0x4b1c>
  20e52b:	0f b6 44 24 20       	movzx  eax,BYTE PTR [rsp+0x20]
  20e530:	0f b6 4c 24 21       	movzx  ecx,BYTE PTR [rsp+0x21]
    switch (endian) {
  20e535:	f6 44 24 70 01       	test   BYTE PTR [rsp+0x70],0x1
  20e53a:	74 1b                	je     20e557 <openSelfDebugInfo+0x3c67>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20e53c:	c1 e1 08             	shl    ecx,0x8
  20e53f:	09 c1                	or     ecx,eax
  20e541:	0f b6 54 24 22       	movzx  edx,BYTE PTR [rsp+0x22]
  20e546:	c1 e2 10             	shl    edx,0x10
  20e549:	09 ca                	or     edx,ecx
  20e54b:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  20e550:	c1 e0 18             	shl    eax,0x18
  20e553:	09 d0                	or     eax,edx
  20e555:	eb 19                	jmp    20e570 <openSelfDebugInfo+0x3c80>
                result = (result << 8) | b;
  20e557:	c1 e0 08             	shl    eax,0x8
  20e55a:	09 c8                	or     eax,ecx
  20e55c:	c1 e0 08             	shl    eax,0x8
  20e55f:	0f b6 4c 24 22       	movzx  ecx,BYTE PTR [rsp+0x22]
  20e564:	09 c1                	or     ecx,eax
  20e566:	c1 e1 08             	shl    ecx,0x8
  20e569:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  20e56e:	09 c8                	or     eax,ecx
  20e570:	48 8b 8c 24 80 00 00 	mov    rcx,QWORD PTR [rsp+0x80]
  20e577:	00 
  20e578:	48 8b 54 24 48       	mov    rdx,QWORD PTR [rsp+0x48]
  20e57d:	89 44 11 cc          	mov    DWORD PTR [rcx+rdx*1-0x34],eax
                elf_section.flags = try in.readInt(elf.endian, u64);
  20e581:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  20e586:	0f b6 10             	movzx  edx,BYTE PTR [rax]
  20e589:	48 8d bc 24 78 03 00 	lea    rdi,[rsp+0x378]
  20e590:	00 
  20e591:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  20e596:	e8 f5 12 00 00       	call   20f890 <InStream(ReadError)_readInt.30>
  20e59b:	44 0f b7 ac 24 78 03 	movzx  r13d,WORD PTR [rsp+0x378]
  20e5a2:	00 00 
  20e5a4:	66 45 85 ed          	test   r13w,r13w
  20e5a8:	0f 85 ef 0b 00 00    	jne    20f19d <openSelfDebugInfo+0x48ad>
  20e5ae:	48 8b 84 24 80 03 00 	mov    rax,QWORD PTR [rsp+0x380]
  20e5b5:	00 
  20e5b6:	48 8b 8c 24 80 00 00 	mov    rcx,QWORD PTR [rsp+0x80]
  20e5bd:	00 
  20e5be:	48 8b 54 24 48       	mov    rdx,QWORD PTR [rsp+0x48]
  20e5c3:	48 89 44 11 d0       	mov    QWORD PTR [rcx+rdx*1-0x30],rax
                elf_section.addr = try in.readInt(elf.endian, u64);
  20e5c8:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  20e5cd:	0f b6 10             	movzx  edx,BYTE PTR [rax]
  20e5d0:	48 8d bc 24 a0 03 00 	lea    rdi,[rsp+0x3a0]
  20e5d7:	00 
  20e5d8:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  20e5dd:	e8 ae 12 00 00       	call   20f890 <InStream(ReadError)_readInt.30>
  20e5e2:	44 0f b7 ac 24 a0 03 	movzx  r13d,WORD PTR [rsp+0x3a0]
  20e5e9:	00 00 
  20e5eb:	66 45 85 ed          	test   r13w,r13w
  20e5ef:	0f 85 06 0c 00 00    	jne    20f1fb <openSelfDebugInfo+0x490b>
  20e5f5:	48 8b 84 24 a8 03 00 	mov    rax,QWORD PTR [rsp+0x3a8]
  20e5fc:	00 
  20e5fd:	48 8b 8c 24 80 00 00 	mov    rcx,QWORD PTR [rsp+0x80]
  20e604:	00 
  20e605:	48 8b 54 24 48       	mov    rdx,QWORD PTR [rsp+0x48]
  20e60a:	48 89 44 11 d8       	mov    QWORD PTR [rcx+rdx*1-0x28],rax
                elf_section.offset = try in.readInt(elf.endian, u64);
  20e60f:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  20e614:	0f b6 10             	movzx  edx,BYTE PTR [rax]
  20e617:	48 8d bc 24 50 03 00 	lea    rdi,[rsp+0x350]
  20e61e:	00 
  20e61f:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  20e624:	e8 67 12 00 00       	call   20f890 <InStream(ReadError)_readInt.30>
  20e629:	44 0f b7 ac 24 50 03 	movzx  r13d,WORD PTR [rsp+0x350]
  20e630:	00 00 
  20e632:	66 45 85 ed          	test   r13w,r13w
  20e636:	0f 85 1d 0c 00 00    	jne    20f259 <openSelfDebugInfo+0x4969>
  20e63c:	48 8b 84 24 58 03 00 	mov    rax,QWORD PTR [rsp+0x358]
  20e643:	00 
  20e644:	48 8b 8c 24 80 00 00 	mov    rcx,QWORD PTR [rsp+0x80]
  20e64b:	00 
  20e64c:	48 8b 54 24 48       	mov    rdx,QWORD PTR [rsp+0x48]
  20e651:	48 89 44 11 e0       	mov    QWORD PTR [rcx+rdx*1-0x20],rax
                elf_section.size = try in.readInt(elf.endian, u64);
  20e656:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  20e65b:	0f b6 10             	movzx  edx,BYTE PTR [rax]
  20e65e:	48 8d bc 24 d0 01 00 	lea    rdi,[rsp+0x1d0]
  20e665:	00 
  20e666:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  20e66b:	e8 20 12 00 00       	call   20f890 <InStream(ReadError)_readInt.30>
  20e670:	44 0f b7 ac 24 d0 01 	movzx  r13d,WORD PTR [rsp+0x1d0]
  20e677:	00 00 
  20e679:	66 45 85 ed          	test   r13w,r13w
  20e67d:	0f 85 34 0c 00 00    	jne    20f2b7 <openSelfDebugInfo+0x49c7>
  20e683:	48 8b 84 24 d8 01 00 	mov    rax,QWORD PTR [rsp+0x1d8]
  20e68a:	00 
  20e68b:	48 8b 8c 24 80 00 00 	mov    rcx,QWORD PTR [rsp+0x80]
  20e692:	00 
  20e693:	48 8b 54 24 48       	mov    rdx,QWORD PTR [rsp+0x48]
  20e698:	48 89 44 11 e8       	mov    QWORD PTR [rcx+rdx*1-0x18],rax
                elf_section.link = try in.readInt(elf.endian, u32);
  20e69d:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  20e6a2:	0f b6 00             	movzx  eax,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  20e6a5:	88 44 24 70          	mov    BYTE PTR [rsp+0x70],al
  20e6a9:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  20e6ae:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  20e6b5:	00 
  20e6b6:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x4
  20e6bd:	00 04 00 00 00 
            return self.readFn(self, buffer);
  20e6c2:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  20e6c9:	00 
  20e6ca:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  20e6cf:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  20e6d6:	00 
  20e6d7:	ff 54 24 58          	call   QWORD PTR [rsp+0x58]
  20e6db:	44 0f b7 ac 24 f0 00 	movzx  r13d,WORD PTR [rsp+0xf0]
  20e6e2:	00 00 
            const amt_read = try self.read(buf);
  20e6e4:	66 45 85 ed          	test   r13w,r13w
  20e6e8:	0f 85 23 0d 00 00    	jne    20f411 <openSelfDebugInfo+0x4b21>
  20e6ee:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  20e6f5:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  20e6f6:	48 3b 84 24 a0 00 00 	cmp    rax,QWORD PTR [rsp+0xa0]
  20e6fd:	00 
  20e6fe:	0f 82 08 0d 00 00    	jb     20f40c <openSelfDebugInfo+0x4b1c>
  20e704:	0f b6 44 24 20       	movzx  eax,BYTE PTR [rsp+0x20]
  20e709:	0f b6 4c 24 21       	movzx  ecx,BYTE PTR [rsp+0x21]
    switch (endian) {
  20e70e:	f6 44 24 70 01       	test   BYTE PTR [rsp+0x70],0x1
  20e713:	74 1b                	je     20e730 <openSelfDebugInfo+0x3e40>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20e715:	c1 e1 08             	shl    ecx,0x8
  20e718:	09 c1                	or     ecx,eax
  20e71a:	0f b6 54 24 22       	movzx  edx,BYTE PTR [rsp+0x22]
  20e71f:	c1 e2 10             	shl    edx,0x10
  20e722:	09 ca                	or     edx,ecx
  20e724:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  20e729:	c1 e0 18             	shl    eax,0x18
  20e72c:	09 d0                	or     eax,edx
  20e72e:	eb 19                	jmp    20e749 <openSelfDebugInfo+0x3e59>
                result = (result << 8) | b;
  20e730:	c1 e0 08             	shl    eax,0x8
  20e733:	09 c8                	or     eax,ecx
  20e735:	c1 e0 08             	shl    eax,0x8
  20e738:	0f b6 4c 24 22       	movzx  ecx,BYTE PTR [rsp+0x22]
  20e73d:	09 c1                	or     ecx,eax
  20e73f:	c1 e1 08             	shl    ecx,0x8
  20e742:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  20e747:	09 c8                	or     eax,ecx
  20e749:	48 8b 8c 24 80 00 00 	mov    rcx,QWORD PTR [rsp+0x80]
  20e750:	00 
  20e751:	48 8b 54 24 48       	mov    rdx,QWORD PTR [rsp+0x48]
  20e756:	89 44 11 f0          	mov    DWORD PTR [rcx+rdx*1-0x10],eax
                elf_section.info = try in.readInt(elf.endian, u32);
  20e75a:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  20e75f:	0f b6 00             	movzx  eax,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  20e762:	88 44 24 70          	mov    BYTE PTR [rsp+0x70],al
  20e766:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  20e76b:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  20e772:	00 
  20e773:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x4
  20e77a:	00 04 00 00 00 
            return self.readFn(self, buffer);
  20e77f:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  20e786:	00 
  20e787:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  20e78c:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  20e793:	00 
  20e794:	ff 54 24 58          	call   QWORD PTR [rsp+0x58]
  20e798:	44 0f b7 ac 24 f0 00 	movzx  r13d,WORD PTR [rsp+0xf0]
  20e79f:	00 00 
            const amt_read = try self.read(buf);
  20e7a1:	66 45 85 ed          	test   r13w,r13w
  20e7a5:	0f 85 66 0c 00 00    	jne    20f411 <openSelfDebugInfo+0x4b21>
  20e7ab:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  20e7b2:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  20e7b3:	48 3b 84 24 a0 00 00 	cmp    rax,QWORD PTR [rsp+0xa0]
  20e7ba:	00 
  20e7bb:	0f 82 4b 0c 00 00    	jb     20f40c <openSelfDebugInfo+0x4b1c>
  20e7c1:	0f b6 44 24 20       	movzx  eax,BYTE PTR [rsp+0x20]
  20e7c6:	0f b6 4c 24 21       	movzx  ecx,BYTE PTR [rsp+0x21]
    switch (endian) {
  20e7cb:	f6 44 24 70 01       	test   BYTE PTR [rsp+0x70],0x1
  20e7d0:	74 1b                	je     20e7ed <openSelfDebugInfo+0x3efd>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20e7d2:	c1 e1 08             	shl    ecx,0x8
  20e7d5:	09 c1                	or     ecx,eax
  20e7d7:	0f b6 54 24 22       	movzx  edx,BYTE PTR [rsp+0x22]
  20e7dc:	c1 e2 10             	shl    edx,0x10
  20e7df:	09 ca                	or     edx,ecx
  20e7e1:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  20e7e6:	c1 e0 18             	shl    eax,0x18
  20e7e9:	09 d0                	or     eax,edx
  20e7eb:	eb 19                	jmp    20e806 <openSelfDebugInfo+0x3f16>
                result = (result << 8) | b;
  20e7ed:	c1 e0 08             	shl    eax,0x8
  20e7f0:	09 c8                	or     eax,ecx
  20e7f2:	c1 e0 08             	shl    eax,0x8
  20e7f5:	0f b6 4c 24 22       	movzx  ecx,BYTE PTR [rsp+0x22]
  20e7fa:	09 c1                	or     ecx,eax
  20e7fc:	c1 e1 08             	shl    ecx,0x8
  20e7ff:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  20e804:	09 c8                	or     eax,ecx
  20e806:	48 8b 8c 24 80 00 00 	mov    rcx,QWORD PTR [rsp+0x80]
  20e80d:	00 
  20e80e:	48 8b 54 24 48       	mov    rdx,QWORD PTR [rsp+0x48]
  20e813:	89 44 11 f4          	mov    DWORD PTR [rcx+rdx*1-0xc],eax
                elf_section.addr_align = try in.readInt(elf.endian, u64);
  20e817:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  20e81c:	0f b6 10             	movzx  edx,BYTE PTR [rax]
  20e81f:	48 8d bc 24 10 02 00 	lea    rdi,[rsp+0x210]
  20e826:	00 
  20e827:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  20e82c:	e8 5f 10 00 00       	call   20f890 <InStream(ReadError)_readInt.30>
  20e831:	44 0f b7 ac 24 10 02 	movzx  r13d,WORD PTR [rsp+0x210]
  20e838:	00 00 
  20e83a:	66 45 85 ed          	test   r13w,r13w
  20e83e:	0f 85 d1 0a 00 00    	jne    20f315 <openSelfDebugInfo+0x4a25>
  20e844:	48 8b 84 24 18 02 00 	mov    rax,QWORD PTR [rsp+0x218]
  20e84b:	00 
  20e84c:	48 8b 8c 24 80 00 00 	mov    rcx,QWORD PTR [rsp+0x80]
  20e853:	00 
  20e854:	48 8b 54 24 48       	mov    rdx,QWORD PTR [rsp+0x48]
  20e859:	48 89 44 11 f8       	mov    QWORD PTR [rcx+rdx*1-0x8],rax
                elf_section.ent_size = try in.readInt(elf.endian, u64);
  20e85e:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  20e863:	0f b6 10             	movzx  edx,BYTE PTR [rax]
  20e866:	48 8d bc 24 40 02 00 	lea    rdi,[rsp+0x240]
  20e86d:	00 
  20e86e:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  20e873:	e8 18 10 00 00       	call   20f890 <InStream(ReadError)_readInt.30>
  20e878:	44 0f b7 ac 24 40 02 	movzx  r13d,WORD PTR [rsp+0x240]
  20e87f:	00 00 
  20e881:	66 45 85 ed          	test   r13w,r13w
  20e885:	0f 85 e8 0a 00 00    	jne    20f373 <openSelfDebugInfo+0x4a83>
  20e88b:	48 8b 84 24 48 02 00 	mov    rax,QWORD PTR [rsp+0x248]
  20e892:	00 
  20e893:	48 8b 8c 24 80 00 00 	mov    rcx,QWORD PTR [rsp+0x80]
  20e89a:	00 
  20e89b:	48 8b 54 24 48       	mov    rdx,QWORD PTR [rsp+0x48]
  20e8a0:	48 89 04 11          	mov    QWORD PTR [rcx+rdx*1],rax
  20e8a4:	48 8b 84 24 80 01 00 	mov    rax,QWORD PTR [rsp+0x180]
  20e8ab:	00 
  20e8ac:	48 89 c1             	mov    rcx,rax
            for (elf.section_headers) |*elf_section| {
  20e8af:	48 83 c1 01          	add    rcx,0x1
  20e8b3:	48 89 c8             	mov    rax,rcx
  20e8b6:	48 89 84 24 80 01 00 	mov    QWORD PTR [rsp+0x180],rax
  20e8bd:	00 
  20e8be:	48 3b 4c 24 40       	cmp    rcx,QWORD PTR [rsp+0x40]
  20e8c3:	0f 83 93 0b 00 00    	jae    20f45c <openSelfDebugInfo+0x4b6c>
  20e8c9:	48 83 44 24 48 40    	add    QWORD PTR [rsp+0x48],0x40
  20e8cf:	48 8b 84 24 90 00 00 	mov    rax,QWORD PTR [rsp+0x90]
  20e8d6:	00 
  20e8d7:	48 8b 00             	mov    rax,QWORD PTR [rax]
                elf_section.name = try in.readInt(elf.endian, u32);
  20e8da:	48 89 84 24 80 00 00 	mov    QWORD PTR [rsp+0x80],rax
  20e8e1:	00 
  20e8e2:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  20e8e7:	0f b6 00             	movzx  eax,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  20e8ea:	88 44 24 70          	mov    BYTE PTR [rsp+0x70],al
  20e8ee:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  20e8f3:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  20e8fa:	00 
  20e8fb:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x4
  20e902:	00 04 00 00 00 
            return self.readFn(self, buffer);
  20e907:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  20e90e:	00 
  20e90f:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  20e914:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  20e91b:	00 
  20e91c:	ff 54 24 58          	call   QWORD PTR [rsp+0x58]
  20e920:	44 0f b7 ac 24 f0 00 	movzx  r13d,WORD PTR [rsp+0xf0]
  20e927:	00 00 
  20e929:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  20e930:	00 
            const amt_read = try self.read(buf);
  20e931:	66 45 85 ed          	test   r13w,r13w
  20e935:	0f 84 25 fb ff ff    	je     20e460 <openSelfDebugInfo+0x3b70>
  20e93b:	e9 d1 0a 00 00       	jmp    20f411 <openSelfDebugInfo+0x4b21>
  20e940:	66 41 bd 02 00       	mov    r13w,0x2
  20e945:	48 83 f9 4b          	cmp    rcx,0x4b
  20e949:	0f 85 ed c1 ff ff    	jne    20ab3c <openSelfDebugInfo+0x24c>
  20e94f:	e9 e3 c4 ff ff       	jmp    20ae37 <openSelfDebugInfo+0x547>
            @panic("assertion failure");
  20e954:	c5 f8 77             	vzeroupper 
  20e957:	e8 c4 a3 ff ff       	call   208d20 <panic>
  20e95c:	66 41 bd 21 00       	mov    r13w,0x21
            try st.elf.openFile(allocator, &st.self_exe_file);
  20e961:	66 45 85 ed          	test   r13w,r13w
  20e965:	0f 85 db c1 ff ff    	jne    20ab46 <openSelfDebugInfo+0x256>
  20e96b:	e9 c2 c8 ff ff       	jmp    20b232 <openSelfDebugInfo+0x942>
            if (sh_entry_size != 40) return error.InvalidFormat;
  20e970:	83 7c 24 48 28       	cmp    DWORD PTR [rsp+0x48],0x28
  20e975:	0f 85 56 0a 00 00    	jne    20f3d1 <openSelfDebugInfo+0x4ae1>
                elf_section.name = try in.readInt(elf.endian, u32);
  20e97b:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  20e980:	8a 00                	mov    al,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  20e982:	88 44 24 70          	mov    BYTE PTR [rsp+0x70],al
  20e986:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  20e98b:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  20e992:	00 
  20e993:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x4
  20e99a:	00 04 00 00 00 
  20e99f:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  20e9a6:	00 
  20e9a7:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  20e9ae:	00 
            return self.readFn(self, buffer);
  20e9af:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  20e9b4:	ff 54 24 58          	call   QWORD PTR [rsp+0x58]
  20e9b8:	44 0f b7 ac 24 f0 00 	movzx  r13d,WORD PTR [rsp+0xf0]
  20e9bf:	00 00 
            const amt_read = try self.read(buf);
  20e9c1:	66 45 85 ed          	test   r13w,r13w
  20e9c5:	0f 85 46 0a 00 00    	jne    20f411 <openSelfDebugInfo+0x4b21>
  20e9cb:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  20e9d2:	00 
  20e9d3:	31 c9                	xor    ecx,ecx
  20e9d5:	48 89 8c 24 80 01 00 	mov    QWORD PTR [rsp+0x180],rcx
  20e9dc:	00 
  20e9dd:	b9 38 00 00 00       	mov    ecx,0x38
  20e9e2:	48 89 4c 24 48       	mov    QWORD PTR [rsp+0x48],rcx
            if (amt_read < buf.len) return error.EndOfStream;
  20e9e7:	48 3b 84 24 a0 00 00 	cmp    rax,QWORD PTR [rsp+0xa0]
  20e9ee:	00 
  20e9ef:	0f 82 17 0a 00 00    	jb     20f40c <openSelfDebugInfo+0x4b1c>
  20e9f5:	0f b6 44 24 20       	movzx  eax,BYTE PTR [rsp+0x20]
  20e9fa:	0f b6 4c 24 21       	movzx  ecx,BYTE PTR [rsp+0x21]
    switch (endian) {
  20e9ff:	f6 44 24 70 01       	test   BYTE PTR [rsp+0x70],0x1
  20ea04:	74 1b                	je     20ea21 <openSelfDebugInfo+0x4131>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20ea06:	c1 e1 08             	shl    ecx,0x8
  20ea09:	09 c1                	or     ecx,eax
  20ea0b:	0f b6 54 24 22       	movzx  edx,BYTE PTR [rsp+0x22]
  20ea10:	c1 e2 10             	shl    edx,0x10
  20ea13:	09 ca                	or     edx,ecx
  20ea15:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  20ea1a:	c1 e0 18             	shl    eax,0x18
  20ea1d:	09 d0                	or     eax,edx
  20ea1f:	eb 19                	jmp    20ea3a <openSelfDebugInfo+0x414a>
                result = (result << 8) | b;
  20ea21:	c1 e0 08             	shl    eax,0x8
  20ea24:	09 c8                	or     eax,ecx
  20ea26:	c1 e0 08             	shl    eax,0x8
  20ea29:	0f b6 4c 24 22       	movzx  ecx,BYTE PTR [rsp+0x22]
  20ea2e:	09 c1                	or     ecx,eax
  20ea30:	c1 e1 08             	shl    ecx,0x8
  20ea33:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  20ea38:	09 c8                	or     eax,ecx
  20ea3a:	48 8b 8c 24 80 00 00 	mov    rcx,QWORD PTR [rsp+0x80]
  20ea41:	00 
  20ea42:	48 8b 54 24 48       	mov    rdx,QWORD PTR [rsp+0x48]
  20ea47:	89 44 11 c8          	mov    DWORD PTR [rcx+rdx*1-0x38],eax
                elf_section.sh_type = try in.readInt(elf.endian, u32);
  20ea4b:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  20ea50:	0f b6 00             	movzx  eax,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  20ea53:	88 44 24 70          	mov    BYTE PTR [rsp+0x70],al
  20ea57:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  20ea5c:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  20ea63:	00 
  20ea64:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x4
  20ea6b:	00 04 00 00 00 
            return self.readFn(self, buffer);
  20ea70:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  20ea77:	00 
  20ea78:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  20ea7d:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  20ea84:	00 
  20ea85:	ff 54 24 58          	call   QWORD PTR [rsp+0x58]
  20ea89:	44 0f b7 ac 24 f0 00 	movzx  r13d,WORD PTR [rsp+0xf0]
  20ea90:	00 00 
            const amt_read = try self.read(buf);
  20ea92:	66 45 85 ed          	test   r13w,r13w
  20ea96:	0f 85 75 09 00 00    	jne    20f411 <openSelfDebugInfo+0x4b21>
  20ea9c:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  20eaa3:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  20eaa4:	48 3b 84 24 a0 00 00 	cmp    rax,QWORD PTR [rsp+0xa0]
  20eaab:	00 
  20eaac:	0f 82 5a 09 00 00    	jb     20f40c <openSelfDebugInfo+0x4b1c>
  20eab2:	0f b6 44 24 20       	movzx  eax,BYTE PTR [rsp+0x20]
  20eab7:	0f b6 4c 24 21       	movzx  ecx,BYTE PTR [rsp+0x21]
    switch (endian) {
  20eabc:	f6 44 24 70 01       	test   BYTE PTR [rsp+0x70],0x1
  20eac1:	74 1b                	je     20eade <openSelfDebugInfo+0x41ee>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20eac3:	c1 e1 08             	shl    ecx,0x8
  20eac6:	09 c1                	or     ecx,eax
  20eac8:	0f b6 54 24 22       	movzx  edx,BYTE PTR [rsp+0x22]
  20eacd:	c1 e2 10             	shl    edx,0x10
  20ead0:	09 ca                	or     edx,ecx
  20ead2:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  20ead7:	c1 e0 18             	shl    eax,0x18
  20eada:	09 d0                	or     eax,edx
  20eadc:	eb 19                	jmp    20eaf7 <openSelfDebugInfo+0x4207>
                result = (result << 8) | b;
  20eade:	c1 e0 08             	shl    eax,0x8
  20eae1:	09 c8                	or     eax,ecx
  20eae3:	c1 e0 08             	shl    eax,0x8
  20eae6:	0f b6 4c 24 22       	movzx  ecx,BYTE PTR [rsp+0x22]
  20eaeb:	09 c1                	or     ecx,eax
  20eaed:	c1 e1 08             	shl    ecx,0x8
  20eaf0:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  20eaf5:	09 c8                	or     eax,ecx
  20eaf7:	48 8b 8c 24 80 00 00 	mov    rcx,QWORD PTR [rsp+0x80]
  20eafe:	00 
  20eaff:	48 8b 54 24 48       	mov    rdx,QWORD PTR [rsp+0x48]
  20eb04:	89 44 11 cc          	mov    DWORD PTR [rcx+rdx*1-0x34],eax
                elf_section.flags = u64(try in.readInt(elf.endian, u32));
  20eb08:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  20eb0d:	0f b6 00             	movzx  eax,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  20eb10:	88 44 24 70          	mov    BYTE PTR [rsp+0x70],al
  20eb14:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  20eb19:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  20eb20:	00 
  20eb21:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x4
  20eb28:	00 04 00 00 00 
            return self.readFn(self, buffer);
  20eb2d:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  20eb34:	00 
  20eb35:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  20eb3a:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  20eb41:	00 
  20eb42:	ff 54 24 58          	call   QWORD PTR [rsp+0x58]
  20eb46:	44 0f b7 ac 24 f0 00 	movzx  r13d,WORD PTR [rsp+0xf0]
  20eb4d:	00 00 
            const amt_read = try self.read(buf);
  20eb4f:	66 45 85 ed          	test   r13w,r13w
  20eb53:	0f 85 b8 08 00 00    	jne    20f411 <openSelfDebugInfo+0x4b21>
  20eb59:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  20eb60:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  20eb61:	48 3b 84 24 a0 00 00 	cmp    rax,QWORD PTR [rsp+0xa0]
  20eb68:	00 
  20eb69:	0f 82 9d 08 00 00    	jb     20f40c <openSelfDebugInfo+0x4b1c>
  20eb6f:	0f b6 44 24 20       	movzx  eax,BYTE PTR [rsp+0x20]
  20eb74:	0f b6 4c 24 21       	movzx  ecx,BYTE PTR [rsp+0x21]
    switch (endian) {
  20eb79:	f6 44 24 70 01       	test   BYTE PTR [rsp+0x70],0x1
  20eb7e:	74 1b                	je     20eb9b <openSelfDebugInfo+0x42ab>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20eb80:	c1 e1 08             	shl    ecx,0x8
  20eb83:	09 c1                	or     ecx,eax
  20eb85:	0f b6 54 24 22       	movzx  edx,BYTE PTR [rsp+0x22]
  20eb8a:	c1 e2 10             	shl    edx,0x10
  20eb8d:	09 ca                	or     edx,ecx
  20eb8f:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  20eb94:	c1 e0 18             	shl    eax,0x18
  20eb97:	09 d0                	or     eax,edx
  20eb99:	eb 19                	jmp    20ebb4 <openSelfDebugInfo+0x42c4>
                result = (result << 8) | b;
  20eb9b:	c1 e0 08             	shl    eax,0x8
  20eb9e:	09 c8                	or     eax,ecx
  20eba0:	c1 e0 08             	shl    eax,0x8
  20eba3:	0f b6 4c 24 22       	movzx  ecx,BYTE PTR [rsp+0x22]
  20eba8:	09 c1                	or     ecx,eax
  20ebaa:	c1 e1 08             	shl    ecx,0x8
  20ebad:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  20ebb2:	09 c8                	or     eax,ecx
  20ebb4:	89 c0                	mov    eax,eax
  20ebb6:	48 8b 8c 24 80 00 00 	mov    rcx,QWORD PTR [rsp+0x80]
  20ebbd:	00 
  20ebbe:	48 8b 54 24 48       	mov    rdx,QWORD PTR [rsp+0x48]
  20ebc3:	48 89 44 11 d0       	mov    QWORD PTR [rcx+rdx*1-0x30],rax
                elf_section.addr = u64(try in.readInt(elf.endian, u32));
  20ebc8:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  20ebcd:	0f b6 00             	movzx  eax,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  20ebd0:	88 44 24 70          	mov    BYTE PTR [rsp+0x70],al
  20ebd4:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  20ebd9:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  20ebe0:	00 
  20ebe1:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x4
  20ebe8:	00 04 00 00 00 
            return self.readFn(self, buffer);
  20ebed:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  20ebf4:	00 
  20ebf5:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  20ebfa:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  20ec01:	00 
  20ec02:	ff 54 24 58          	call   QWORD PTR [rsp+0x58]
  20ec06:	44 0f b7 ac 24 f0 00 	movzx  r13d,WORD PTR [rsp+0xf0]
  20ec0d:	00 00 
            const amt_read = try self.read(buf);
  20ec0f:	66 45 85 ed          	test   r13w,r13w
  20ec13:	0f 85 f8 07 00 00    	jne    20f411 <openSelfDebugInfo+0x4b21>
  20ec19:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  20ec20:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  20ec21:	48 3b 84 24 a0 00 00 	cmp    rax,QWORD PTR [rsp+0xa0]
  20ec28:	00 
  20ec29:	0f 82 dd 07 00 00    	jb     20f40c <openSelfDebugInfo+0x4b1c>
  20ec2f:	0f b6 44 24 20       	movzx  eax,BYTE PTR [rsp+0x20]
  20ec34:	0f b6 4c 24 21       	movzx  ecx,BYTE PTR [rsp+0x21]
    switch (endian) {
  20ec39:	f6 44 24 70 01       	test   BYTE PTR [rsp+0x70],0x1
  20ec3e:	74 1b                	je     20ec5b <openSelfDebugInfo+0x436b>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20ec40:	c1 e1 08             	shl    ecx,0x8
  20ec43:	09 c1                	or     ecx,eax
  20ec45:	0f b6 54 24 22       	movzx  edx,BYTE PTR [rsp+0x22]
  20ec4a:	c1 e2 10             	shl    edx,0x10
  20ec4d:	09 ca                	or     edx,ecx
  20ec4f:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  20ec54:	c1 e0 18             	shl    eax,0x18
  20ec57:	09 d0                	or     eax,edx
  20ec59:	eb 19                	jmp    20ec74 <openSelfDebugInfo+0x4384>
                result = (result << 8) | b;
  20ec5b:	c1 e0 08             	shl    eax,0x8
  20ec5e:	09 c8                	or     eax,ecx
  20ec60:	c1 e0 08             	shl    eax,0x8
  20ec63:	0f b6 4c 24 22       	movzx  ecx,BYTE PTR [rsp+0x22]
  20ec68:	09 c1                	or     ecx,eax
  20ec6a:	c1 e1 08             	shl    ecx,0x8
  20ec6d:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  20ec72:	09 c8                	or     eax,ecx
  20ec74:	89 c0                	mov    eax,eax
  20ec76:	48 8b 8c 24 80 00 00 	mov    rcx,QWORD PTR [rsp+0x80]
  20ec7d:	00 
  20ec7e:	48 8b 54 24 48       	mov    rdx,QWORD PTR [rsp+0x48]
  20ec83:	48 89 44 11 d8       	mov    QWORD PTR [rcx+rdx*1-0x28],rax
                elf_section.offset = u64(try in.readInt(elf.endian, u32));
  20ec88:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  20ec8d:	0f b6 00             	movzx  eax,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  20ec90:	88 44 24 70          	mov    BYTE PTR [rsp+0x70],al
  20ec94:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  20ec99:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  20eca0:	00 
  20eca1:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x4
  20eca8:	00 04 00 00 00 
            return self.readFn(self, buffer);
  20ecad:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  20ecb4:	00 
  20ecb5:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  20ecba:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  20ecc1:	00 
  20ecc2:	ff 54 24 58          	call   QWORD PTR [rsp+0x58]
  20ecc6:	44 0f b7 ac 24 f0 00 	movzx  r13d,WORD PTR [rsp+0xf0]
  20eccd:	00 00 
            const amt_read = try self.read(buf);
  20eccf:	66 45 85 ed          	test   r13w,r13w
  20ecd3:	0f 85 38 07 00 00    	jne    20f411 <openSelfDebugInfo+0x4b21>
  20ecd9:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  20ece0:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  20ece1:	48 3b 84 24 a0 00 00 	cmp    rax,QWORD PTR [rsp+0xa0]
  20ece8:	00 
  20ece9:	0f 82 1d 07 00 00    	jb     20f40c <openSelfDebugInfo+0x4b1c>
  20ecef:	0f b6 44 24 20       	movzx  eax,BYTE PTR [rsp+0x20]
  20ecf4:	0f b6 4c 24 21       	movzx  ecx,BYTE PTR [rsp+0x21]
    switch (endian) {
  20ecf9:	f6 44 24 70 01       	test   BYTE PTR [rsp+0x70],0x1
  20ecfe:	74 1b                	je     20ed1b <openSelfDebugInfo+0x442b>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20ed00:	c1 e1 08             	shl    ecx,0x8
  20ed03:	09 c1                	or     ecx,eax
  20ed05:	0f b6 54 24 22       	movzx  edx,BYTE PTR [rsp+0x22]
  20ed0a:	c1 e2 10             	shl    edx,0x10
  20ed0d:	09 ca                	or     edx,ecx
  20ed0f:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  20ed14:	c1 e0 18             	shl    eax,0x18
  20ed17:	09 d0                	or     eax,edx
  20ed19:	eb 19                	jmp    20ed34 <openSelfDebugInfo+0x4444>
                result = (result << 8) | b;
  20ed1b:	c1 e0 08             	shl    eax,0x8
  20ed1e:	09 c8                	or     eax,ecx
  20ed20:	c1 e0 08             	shl    eax,0x8
  20ed23:	0f b6 4c 24 22       	movzx  ecx,BYTE PTR [rsp+0x22]
  20ed28:	09 c1                	or     ecx,eax
  20ed2a:	c1 e1 08             	shl    ecx,0x8
  20ed2d:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  20ed32:	09 c8                	or     eax,ecx
  20ed34:	89 c0                	mov    eax,eax
  20ed36:	48 8b 8c 24 80 00 00 	mov    rcx,QWORD PTR [rsp+0x80]
  20ed3d:	00 
  20ed3e:	48 8b 54 24 48       	mov    rdx,QWORD PTR [rsp+0x48]
  20ed43:	48 89 44 11 e0       	mov    QWORD PTR [rcx+rdx*1-0x20],rax
                elf_section.size = u64(try in.readInt(elf.endian, u32));
  20ed48:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  20ed4d:	0f b6 00             	movzx  eax,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  20ed50:	88 44 24 70          	mov    BYTE PTR [rsp+0x70],al
  20ed54:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  20ed59:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  20ed60:	00 
  20ed61:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x4
  20ed68:	00 04 00 00 00 
            return self.readFn(self, buffer);
  20ed6d:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  20ed74:	00 
  20ed75:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  20ed7a:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  20ed81:	00 
  20ed82:	ff 54 24 58          	call   QWORD PTR [rsp+0x58]
  20ed86:	44 0f b7 ac 24 f0 00 	movzx  r13d,WORD PTR [rsp+0xf0]
  20ed8d:	00 00 
            const amt_read = try self.read(buf);
  20ed8f:	66 45 85 ed          	test   r13w,r13w
  20ed93:	0f 85 78 06 00 00    	jne    20f411 <openSelfDebugInfo+0x4b21>
  20ed99:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  20eda0:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  20eda1:	48 3b 84 24 a0 00 00 	cmp    rax,QWORD PTR [rsp+0xa0]
  20eda8:	00 
  20eda9:	0f 82 5d 06 00 00    	jb     20f40c <openSelfDebugInfo+0x4b1c>
  20edaf:	0f b6 44 24 20       	movzx  eax,BYTE PTR [rsp+0x20]
  20edb4:	0f b6 4c 24 21       	movzx  ecx,BYTE PTR [rsp+0x21]
    switch (endian) {
  20edb9:	f6 44 24 70 01       	test   BYTE PTR [rsp+0x70],0x1
  20edbe:	74 1b                	je     20eddb <openSelfDebugInfo+0x44eb>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20edc0:	c1 e1 08             	shl    ecx,0x8
  20edc3:	09 c1                	or     ecx,eax
  20edc5:	0f b6 54 24 22       	movzx  edx,BYTE PTR [rsp+0x22]
  20edca:	c1 e2 10             	shl    edx,0x10
  20edcd:	09 ca                	or     edx,ecx
  20edcf:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  20edd4:	c1 e0 18             	shl    eax,0x18
  20edd7:	09 d0                	or     eax,edx
  20edd9:	eb 19                	jmp    20edf4 <openSelfDebugInfo+0x4504>
                result = (result << 8) | b;
  20eddb:	c1 e0 08             	shl    eax,0x8
  20edde:	09 c8                	or     eax,ecx
  20ede0:	c1 e0 08             	shl    eax,0x8
  20ede3:	0f b6 4c 24 22       	movzx  ecx,BYTE PTR [rsp+0x22]
  20ede8:	09 c1                	or     ecx,eax
  20edea:	c1 e1 08             	shl    ecx,0x8
  20eded:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  20edf2:	09 c8                	or     eax,ecx
  20edf4:	89 c0                	mov    eax,eax
  20edf6:	48 8b 8c 24 80 00 00 	mov    rcx,QWORD PTR [rsp+0x80]
  20edfd:	00 
  20edfe:	48 8b 54 24 48       	mov    rdx,QWORD PTR [rsp+0x48]
  20ee03:	48 89 44 11 e8       	mov    QWORD PTR [rcx+rdx*1-0x18],rax
                elf_section.link = try in.readInt(elf.endian, u32);
  20ee08:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  20ee0d:	0f b6 00             	movzx  eax,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  20ee10:	88 44 24 70          	mov    BYTE PTR [rsp+0x70],al
  20ee14:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  20ee19:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  20ee20:	00 
  20ee21:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x4
  20ee28:	00 04 00 00 00 
            return self.readFn(self, buffer);
  20ee2d:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  20ee34:	00 
  20ee35:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  20ee3a:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  20ee41:	00 
  20ee42:	ff 54 24 58          	call   QWORD PTR [rsp+0x58]
  20ee46:	44 0f b7 ac 24 f0 00 	movzx  r13d,WORD PTR [rsp+0xf0]
  20ee4d:	00 00 
            const amt_read = try self.read(buf);
  20ee4f:	66 45 85 ed          	test   r13w,r13w
  20ee53:	0f 85 b8 05 00 00    	jne    20f411 <openSelfDebugInfo+0x4b21>
  20ee59:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  20ee60:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  20ee61:	48 3b 84 24 a0 00 00 	cmp    rax,QWORD PTR [rsp+0xa0]
  20ee68:	00 
  20ee69:	0f 82 9d 05 00 00    	jb     20f40c <openSelfDebugInfo+0x4b1c>
  20ee6f:	0f b6 44 24 20       	movzx  eax,BYTE PTR [rsp+0x20]
  20ee74:	0f b6 4c 24 21       	movzx  ecx,BYTE PTR [rsp+0x21]
    switch (endian) {
  20ee79:	f6 44 24 70 01       	test   BYTE PTR [rsp+0x70],0x1
  20ee7e:	74 1b                	je     20ee9b <openSelfDebugInfo+0x45ab>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20ee80:	c1 e1 08             	shl    ecx,0x8
  20ee83:	09 c1                	or     ecx,eax
  20ee85:	0f b6 54 24 22       	movzx  edx,BYTE PTR [rsp+0x22]
  20ee8a:	c1 e2 10             	shl    edx,0x10
  20ee8d:	09 ca                	or     edx,ecx
  20ee8f:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  20ee94:	c1 e0 18             	shl    eax,0x18
  20ee97:	09 d0                	or     eax,edx
  20ee99:	eb 19                	jmp    20eeb4 <openSelfDebugInfo+0x45c4>
                result = (result << 8) | b;
  20ee9b:	c1 e0 08             	shl    eax,0x8
  20ee9e:	09 c8                	or     eax,ecx
  20eea0:	c1 e0 08             	shl    eax,0x8
  20eea3:	0f b6 4c 24 22       	movzx  ecx,BYTE PTR [rsp+0x22]
  20eea8:	09 c1                	or     ecx,eax
  20eeaa:	c1 e1 08             	shl    ecx,0x8
  20eead:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  20eeb2:	09 c8                	or     eax,ecx
  20eeb4:	48 8b 8c 24 80 00 00 	mov    rcx,QWORD PTR [rsp+0x80]
  20eebb:	00 
  20eebc:	48 8b 54 24 48       	mov    rdx,QWORD PTR [rsp+0x48]
  20eec1:	89 44 11 f0          	mov    DWORD PTR [rcx+rdx*1-0x10],eax
                elf_section.info = try in.readInt(elf.endian, u32);
  20eec5:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  20eeca:	0f b6 00             	movzx  eax,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  20eecd:	88 44 24 70          	mov    BYTE PTR [rsp+0x70],al
  20eed1:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  20eed6:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  20eedd:	00 
  20eede:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x4
  20eee5:	00 04 00 00 00 
            return self.readFn(self, buffer);
  20eeea:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  20eef1:	00 
  20eef2:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  20eef7:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  20eefe:	00 
  20eeff:	ff 54 24 58          	call   QWORD PTR [rsp+0x58]
  20ef03:	44 0f b7 ac 24 f0 00 	movzx  r13d,WORD PTR [rsp+0xf0]
  20ef0a:	00 00 
            const amt_read = try self.read(buf);
  20ef0c:	66 45 85 ed          	test   r13w,r13w
  20ef10:	0f 85 fb 04 00 00    	jne    20f411 <openSelfDebugInfo+0x4b21>
  20ef16:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  20ef1d:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  20ef1e:	48 3b 84 24 a0 00 00 	cmp    rax,QWORD PTR [rsp+0xa0]
  20ef25:	00 
  20ef26:	0f 82 e0 04 00 00    	jb     20f40c <openSelfDebugInfo+0x4b1c>
  20ef2c:	0f b6 44 24 20       	movzx  eax,BYTE PTR [rsp+0x20]
  20ef31:	0f b6 4c 24 21       	movzx  ecx,BYTE PTR [rsp+0x21]
    switch (endian) {
  20ef36:	f6 44 24 70 01       	test   BYTE PTR [rsp+0x70],0x1
  20ef3b:	74 1b                	je     20ef58 <openSelfDebugInfo+0x4668>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20ef3d:	c1 e1 08             	shl    ecx,0x8
  20ef40:	09 c1                	or     ecx,eax
  20ef42:	0f b6 54 24 22       	movzx  edx,BYTE PTR [rsp+0x22]
  20ef47:	c1 e2 10             	shl    edx,0x10
  20ef4a:	09 ca                	or     edx,ecx
  20ef4c:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  20ef51:	c1 e0 18             	shl    eax,0x18
  20ef54:	09 d0                	or     eax,edx
  20ef56:	eb 19                	jmp    20ef71 <openSelfDebugInfo+0x4681>
                result = (result << 8) | b;
  20ef58:	c1 e0 08             	shl    eax,0x8
  20ef5b:	09 c8                	or     eax,ecx
  20ef5d:	c1 e0 08             	shl    eax,0x8
  20ef60:	0f b6 4c 24 22       	movzx  ecx,BYTE PTR [rsp+0x22]
  20ef65:	09 c1                	or     ecx,eax
  20ef67:	c1 e1 08             	shl    ecx,0x8
  20ef6a:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  20ef6f:	09 c8                	or     eax,ecx
  20ef71:	48 8b 8c 24 80 00 00 	mov    rcx,QWORD PTR [rsp+0x80]
  20ef78:	00 
  20ef79:	48 8b 54 24 48       	mov    rdx,QWORD PTR [rsp+0x48]
  20ef7e:	89 44 11 f4          	mov    DWORD PTR [rcx+rdx*1-0xc],eax
                elf_section.addr_align = u64(try in.readInt(elf.endian, u32));
  20ef82:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  20ef87:	0f b6 00             	movzx  eax,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  20ef8a:	88 44 24 70          	mov    BYTE PTR [rsp+0x70],al
  20ef8e:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  20ef93:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  20ef9a:	00 
  20ef9b:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x4
  20efa2:	00 04 00 00 00 
            return self.readFn(self, buffer);
  20efa7:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  20efae:	00 
  20efaf:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  20efb4:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  20efbb:	00 
  20efbc:	ff 54 24 58          	call   QWORD PTR [rsp+0x58]
  20efc0:	44 0f b7 ac 24 f0 00 	movzx  r13d,WORD PTR [rsp+0xf0]
  20efc7:	00 00 
            const amt_read = try self.read(buf);
  20efc9:	66 45 85 ed          	test   r13w,r13w
  20efcd:	0f 85 3e 04 00 00    	jne    20f411 <openSelfDebugInfo+0x4b21>
  20efd3:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  20efda:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  20efdb:	48 3b 84 24 a0 00 00 	cmp    rax,QWORD PTR [rsp+0xa0]
  20efe2:	00 
  20efe3:	0f 82 23 04 00 00    	jb     20f40c <openSelfDebugInfo+0x4b1c>
  20efe9:	0f b6 44 24 20       	movzx  eax,BYTE PTR [rsp+0x20]
  20efee:	0f b6 4c 24 21       	movzx  ecx,BYTE PTR [rsp+0x21]
    switch (endian) {
  20eff3:	f6 44 24 70 01       	test   BYTE PTR [rsp+0x70],0x1
  20eff8:	74 1b                	je     20f015 <openSelfDebugInfo+0x4725>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20effa:	c1 e1 08             	shl    ecx,0x8
  20effd:	09 c1                	or     ecx,eax
  20efff:	0f b6 54 24 22       	movzx  edx,BYTE PTR [rsp+0x22]
  20f004:	c1 e2 10             	shl    edx,0x10
  20f007:	09 ca                	or     edx,ecx
  20f009:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  20f00e:	c1 e0 18             	shl    eax,0x18
  20f011:	09 d0                	or     eax,edx
  20f013:	eb 19                	jmp    20f02e <openSelfDebugInfo+0x473e>
                result = (result << 8) | b;
  20f015:	c1 e0 08             	shl    eax,0x8
  20f018:	09 c8                	or     eax,ecx
  20f01a:	c1 e0 08             	shl    eax,0x8
  20f01d:	0f b6 4c 24 22       	movzx  ecx,BYTE PTR [rsp+0x22]
  20f022:	09 c1                	or     ecx,eax
  20f024:	c1 e1 08             	shl    ecx,0x8
  20f027:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  20f02c:	09 c8                	or     eax,ecx
  20f02e:	89 c0                	mov    eax,eax
  20f030:	48 8b 8c 24 80 00 00 	mov    rcx,QWORD PTR [rsp+0x80]
  20f037:	00 
  20f038:	48 8b 54 24 48       	mov    rdx,QWORD PTR [rsp+0x48]
  20f03d:	48 89 44 11 f8       	mov    QWORD PTR [rcx+rdx*1-0x8],rax
                elf_section.ent_size = u64(try in.readInt(elf.endian, u32));
  20f042:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  20f047:	0f b6 00             	movzx  eax,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  20f04a:	88 44 24 70          	mov    BYTE PTR [rsp+0x70],al
  20f04e:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  20f053:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  20f05a:	00 
  20f05b:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x4
  20f062:	00 04 00 00 00 
            return self.readFn(self, buffer);
  20f067:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  20f06e:	00 
  20f06f:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  20f074:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  20f07b:	00 
  20f07c:	ff 54 24 58          	call   QWORD PTR [rsp+0x58]
  20f080:	44 0f b7 ac 24 f0 00 	movzx  r13d,WORD PTR [rsp+0xf0]
  20f087:	00 00 
            const amt_read = try self.read(buf);
  20f089:	66 45 85 ed          	test   r13w,r13w
  20f08d:	0f 85 7e 03 00 00    	jne    20f411 <openSelfDebugInfo+0x4b21>
  20f093:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  20f09a:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  20f09b:	48 3b 84 24 a0 00 00 	cmp    rax,QWORD PTR [rsp+0xa0]
  20f0a2:	00 
  20f0a3:	0f 82 63 03 00 00    	jb     20f40c <openSelfDebugInfo+0x4b1c>
  20f0a9:	0f b6 44 24 20       	movzx  eax,BYTE PTR [rsp+0x20]
  20f0ae:	0f b6 4c 24 21       	movzx  ecx,BYTE PTR [rsp+0x21]
    switch (endian) {
  20f0b3:	f6 44 24 70 01       	test   BYTE PTR [rsp+0x70],0x1
  20f0b8:	74 1b                	je     20f0d5 <openSelfDebugInfo+0x47e5>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20f0ba:	c1 e1 08             	shl    ecx,0x8
  20f0bd:	09 c1                	or     ecx,eax
  20f0bf:	0f b6 54 24 22       	movzx  edx,BYTE PTR [rsp+0x22]
  20f0c4:	c1 e2 10             	shl    edx,0x10
  20f0c7:	09 ca                	or     edx,ecx
  20f0c9:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  20f0ce:	c1 e0 18             	shl    eax,0x18
  20f0d1:	09 d0                	or     eax,edx
  20f0d3:	eb 19                	jmp    20f0ee <openSelfDebugInfo+0x47fe>
                result = (result << 8) | b;
  20f0d5:	c1 e0 08             	shl    eax,0x8
  20f0d8:	09 c8                	or     eax,ecx
  20f0da:	c1 e0 08             	shl    eax,0x8
  20f0dd:	0f b6 4c 24 22       	movzx  ecx,BYTE PTR [rsp+0x22]
  20f0e2:	09 c1                	or     ecx,eax
  20f0e4:	c1 e1 08             	shl    ecx,0x8
  20f0e7:	0f b6 44 24 23       	movzx  eax,BYTE PTR [rsp+0x23]
  20f0ec:	09 c8                	or     eax,ecx
  20f0ee:	89 c0                	mov    eax,eax
  20f0f0:	48 8b 8c 24 80 00 00 	mov    rcx,QWORD PTR [rsp+0x80]
  20f0f7:	00 
  20f0f8:	48 8b 54 24 48       	mov    rdx,QWORD PTR [rsp+0x48]
  20f0fd:	48 89 04 11          	mov    QWORD PTR [rcx+rdx*1],rax
  20f101:	48 8b 84 24 80 01 00 	mov    rax,QWORD PTR [rsp+0x180]
  20f108:	00 
  20f109:	48 89 c1             	mov    rcx,rax
            for (elf.section_headers) |*elf_section| {
  20f10c:	48 83 c1 01          	add    rcx,0x1
  20f110:	48 89 c8             	mov    rax,rcx
  20f113:	48 89 84 24 80 01 00 	mov    QWORD PTR [rsp+0x180],rax
  20f11a:	00 
  20f11b:	48 3b 4c 24 40       	cmp    rcx,QWORD PTR [rsp+0x40]
  20f120:	0f 83 36 03 00 00    	jae    20f45c <openSelfDebugInfo+0x4b6c>
  20f126:	48 83 44 24 48 40    	add    QWORD PTR [rsp+0x48],0x40
  20f12c:	48 8b 84 24 90 00 00 	mov    rax,QWORD PTR [rsp+0x90]
  20f133:	00 
  20f134:	48 8b 00             	mov    rax,QWORD PTR [rax]
                elf_section.name = try in.readInt(elf.endian, u32);
  20f137:	48 89 84 24 80 00 00 	mov    QWORD PTR [rsp+0x80],rax
  20f13e:	00 
  20f13f:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  20f144:	0f b6 00             	movzx  eax,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  20f147:	88 44 24 70          	mov    BYTE PTR [rsp+0x70],al
  20f14b:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  20f150:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  20f157:	00 
  20f158:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x4
  20f15f:	00 04 00 00 00 
            return self.readFn(self, buffer);
  20f164:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  20f16b:	00 
  20f16c:	48 8d 74 24 58       	lea    rsi,[rsp+0x58]
  20f171:	48 8d 94 24 98 00 00 	lea    rdx,[rsp+0x98]
  20f178:	00 
  20f179:	ff 54 24 58          	call   QWORD PTR [rsp+0x58]
  20f17d:	44 0f b7 ac 24 f0 00 	movzx  r13d,WORD PTR [rsp+0xf0]
  20f184:	00 00 
  20f186:	48 8b 84 24 f8 00 00 	mov    rax,QWORD PTR [rsp+0xf8]
  20f18d:	00 
            const amt_read = try self.read(buf);
  20f18e:	66 45 85 ed          	test   r13w,r13w
  20f192:	0f 84 4f f8 ff ff    	je     20e9e7 <openSelfDebugInfo+0x40f7>
  20f198:	e9 74 02 00 00       	jmp    20f411 <openSelfDebugInfo+0x4b21>
        const bytes = @sliceToBytes(memory);
  20f19d:	48 8b 84 24 88 00 00 	mov    rax,QWORD PTR [rsp+0x88]
  20f1a4:	00 
  20f1a5:	48 8b 00             	mov    rax,QWORD PTR [rax]
  20f1a8:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  20f1ac:	0f 84 8a b9 ff ff    	je     20ab3c <openSelfDebugInfo+0x24c>
  20f1b2:	48 8b 4c 24 78       	mov    rcx,QWORD PTR [rsp+0x78]
  20f1b7:	48 8b 39             	mov    rdi,QWORD PTR [rcx]
        const bytes = @sliceToBytes(memory);
  20f1ba:	48 8b 8c 24 90 00 00 	mov    rcx,QWORD PTR [rsp+0x90]
  20f1c1:	00 
  20f1c2:	48 8b 09             	mov    rcx,QWORD PTR [rcx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  20f1c5:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  20f1c9:	48 89 8c 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rcx
  20f1d0:	00 
  20f1d1:	48 89 84 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],rax
  20f1d8:	00 
  20f1d9:	48 8d b4 24 f0 00 00 	lea    rsi,[rsp+0xf0]
  20f1e0:	00 
  20f1e1:	ff d2                	call   rdx
                elf_section.flags = try in.readInt(elf.endian, u64);
  20f1e3:	44 0f b7 ac 24 78 03 	movzx  r13d,WORD PTR [rsp+0x378]
  20f1ea:	00 00 
  20f1ec:	66 45 85 ed          	test   r13w,r13w
  20f1f0:	0f 85 50 b9 ff ff    	jne    20ab46 <openSelfDebugInfo+0x256>
  20f1f6:	e9 37 c0 ff ff       	jmp    20b232 <openSelfDebugInfo+0x942>
        const bytes = @sliceToBytes(memory);
  20f1fb:	48 8b 84 24 88 00 00 	mov    rax,QWORD PTR [rsp+0x88]
  20f202:	00 
  20f203:	48 8b 00             	mov    rax,QWORD PTR [rax]
  20f206:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  20f20a:	0f 84 2c b9 ff ff    	je     20ab3c <openSelfDebugInfo+0x24c>
  20f210:	48 8b 4c 24 78       	mov    rcx,QWORD PTR [rsp+0x78]
  20f215:	48 8b 39             	mov    rdi,QWORD PTR [rcx]
        const bytes = @sliceToBytes(memory);
  20f218:	48 8b 8c 24 90 00 00 	mov    rcx,QWORD PTR [rsp+0x90]
  20f21f:	00 
  20f220:	48 8b 09             	mov    rcx,QWORD PTR [rcx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  20f223:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  20f227:	48 89 8c 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rcx
  20f22e:	00 
  20f22f:	48 89 84 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],rax
  20f236:	00 
  20f237:	48 8d b4 24 f0 00 00 	lea    rsi,[rsp+0xf0]
  20f23e:	00 
  20f23f:	ff d2                	call   rdx
                elf_section.addr = try in.readInt(elf.endian, u64);
  20f241:	44 0f b7 ac 24 a0 03 	movzx  r13d,WORD PTR [rsp+0x3a0]
  20f248:	00 00 
  20f24a:	66 45 85 ed          	test   r13w,r13w
  20f24e:	0f 85 f2 b8 ff ff    	jne    20ab46 <openSelfDebugInfo+0x256>
  20f254:	e9 d9 bf ff ff       	jmp    20b232 <openSelfDebugInfo+0x942>
        const bytes = @sliceToBytes(memory);
  20f259:	48 8b 84 24 88 00 00 	mov    rax,QWORD PTR [rsp+0x88]
  20f260:	00 
  20f261:	48 8b 00             	mov    rax,QWORD PTR [rax]
  20f264:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  20f268:	0f 84 ce b8 ff ff    	je     20ab3c <openSelfDebugInfo+0x24c>
  20f26e:	48 8b 4c 24 78       	mov    rcx,QWORD PTR [rsp+0x78]
  20f273:	48 8b 39             	mov    rdi,QWORD PTR [rcx]
        const bytes = @sliceToBytes(memory);
  20f276:	48 8b 8c 24 90 00 00 	mov    rcx,QWORD PTR [rsp+0x90]
  20f27d:	00 
  20f27e:	48 8b 09             	mov    rcx,QWORD PTR [rcx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  20f281:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  20f285:	48 89 8c 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rcx
  20f28c:	00 
  20f28d:	48 89 84 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],rax
  20f294:	00 
  20f295:	48 8d b4 24 f0 00 00 	lea    rsi,[rsp+0xf0]
  20f29c:	00 
  20f29d:	ff d2                	call   rdx
                elf_section.offset = try in.readInt(elf.endian, u64);
  20f29f:	44 0f b7 ac 24 50 03 	movzx  r13d,WORD PTR [rsp+0x350]
  20f2a6:	00 00 
  20f2a8:	66 45 85 ed          	test   r13w,r13w
  20f2ac:	0f 85 94 b8 ff ff    	jne    20ab46 <openSelfDebugInfo+0x256>
  20f2b2:	e9 7b bf ff ff       	jmp    20b232 <openSelfDebugInfo+0x942>
        const bytes = @sliceToBytes(memory);
  20f2b7:	48 8b 84 24 88 00 00 	mov    rax,QWORD PTR [rsp+0x88]
  20f2be:	00 
  20f2bf:	48 8b 00             	mov    rax,QWORD PTR [rax]
  20f2c2:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  20f2c6:	0f 84 70 b8 ff ff    	je     20ab3c <openSelfDebugInfo+0x24c>
  20f2cc:	48 8b 4c 24 78       	mov    rcx,QWORD PTR [rsp+0x78]
  20f2d1:	48 8b 39             	mov    rdi,QWORD PTR [rcx]
        const bytes = @sliceToBytes(memory);
  20f2d4:	48 8b 8c 24 90 00 00 	mov    rcx,QWORD PTR [rsp+0x90]
  20f2db:	00 
  20f2dc:	48 8b 09             	mov    rcx,QWORD PTR [rcx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  20f2df:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  20f2e3:	48 89 8c 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rcx
  20f2ea:	00 
  20f2eb:	48 89 84 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],rax
  20f2f2:	00 
  20f2f3:	48 8d b4 24 f0 00 00 	lea    rsi,[rsp+0xf0]
  20f2fa:	00 
  20f2fb:	ff d2                	call   rdx
                elf_section.size = try in.readInt(elf.endian, u64);
  20f2fd:	44 0f b7 ac 24 d0 01 	movzx  r13d,WORD PTR [rsp+0x1d0]
  20f304:	00 00 
  20f306:	66 45 85 ed          	test   r13w,r13w
  20f30a:	0f 85 36 b8 ff ff    	jne    20ab46 <openSelfDebugInfo+0x256>
  20f310:	e9 1d bf ff ff       	jmp    20b232 <openSelfDebugInfo+0x942>
        const bytes = @sliceToBytes(memory);
  20f315:	48 8b 84 24 88 00 00 	mov    rax,QWORD PTR [rsp+0x88]
  20f31c:	00 
  20f31d:	48 8b 00             	mov    rax,QWORD PTR [rax]
  20f320:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  20f324:	0f 84 12 b8 ff ff    	je     20ab3c <openSelfDebugInfo+0x24c>
  20f32a:	48 8b 4c 24 78       	mov    rcx,QWORD PTR [rsp+0x78]
  20f32f:	48 8b 39             	mov    rdi,QWORD PTR [rcx]
        const bytes = @sliceToBytes(memory);
  20f332:	48 8b 8c 24 90 00 00 	mov    rcx,QWORD PTR [rsp+0x90]
  20f339:	00 
  20f33a:	48 8b 09             	mov    rcx,QWORD PTR [rcx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  20f33d:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  20f341:	48 89 8c 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rcx
  20f348:	00 
  20f349:	48 89 84 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],rax
  20f350:	00 
  20f351:	48 8d b4 24 f0 00 00 	lea    rsi,[rsp+0xf0]
  20f358:	00 
  20f359:	ff d2                	call   rdx
                elf_section.addr_align = try in.readInt(elf.endian, u64);
  20f35b:	44 0f b7 ac 24 10 02 	movzx  r13d,WORD PTR [rsp+0x210]
  20f362:	00 00 
  20f364:	66 45 85 ed          	test   r13w,r13w
  20f368:	0f 85 d8 b7 ff ff    	jne    20ab46 <openSelfDebugInfo+0x256>
  20f36e:	e9 bf be ff ff       	jmp    20b232 <openSelfDebugInfo+0x942>
        const bytes = @sliceToBytes(memory);
  20f373:	48 8b 84 24 88 00 00 	mov    rax,QWORD PTR [rsp+0x88]
  20f37a:	00 
  20f37b:	48 8b 00             	mov    rax,QWORD PTR [rax]
  20f37e:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  20f382:	0f 84 b4 b7 ff ff    	je     20ab3c <openSelfDebugInfo+0x24c>
  20f388:	48 8b 4c 24 78       	mov    rcx,QWORD PTR [rsp+0x78]
  20f38d:	48 8b 39             	mov    rdi,QWORD PTR [rcx]
        const bytes = @sliceToBytes(memory);
  20f390:	48 8b 8c 24 90 00 00 	mov    rcx,QWORD PTR [rsp+0x90]
  20f397:	00 
  20f398:	48 8b 09             	mov    rcx,QWORD PTR [rcx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  20f39b:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  20f39f:	48 89 8c 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rcx
  20f3a6:	00 
  20f3a7:	48 89 84 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],rax
  20f3ae:	00 
  20f3af:	48 8d b4 24 f0 00 00 	lea    rsi,[rsp+0xf0]
  20f3b6:	00 
  20f3b7:	ff d2                	call   rdx
                elf_section.ent_size = try in.readInt(elf.endian, u64);
  20f3b9:	44 0f b7 ac 24 40 02 	movzx  r13d,WORD PTR [rsp+0x240]
  20f3c0:	00 00 
  20f3c2:	66 45 85 ed          	test   r13w,r13w
  20f3c6:	0f 85 7a b7 ff ff    	jne    20ab46 <openSelfDebugInfo+0x256>
  20f3cc:	e9 61 be ff ff       	jmp    20b232 <openSelfDebugInfo+0x942>
  20f3d1:	48 8b 44 24 78       	mov    rax,QWORD PTR [rsp+0x78]
  20f3d6:	48 8b 38             	mov    rdi,QWORD PTR [rax]
  20f3d9:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  20f3dd:	48 8b 8c 24 80 00 00 	mov    rcx,QWORD PTR [rsp+0x80]
  20f3e4:	00 
  20f3e5:	48 89 8c 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rcx
  20f3ec:	00 
  20f3ed:	48 8b 8c 24 80 01 00 	mov    rcx,QWORD PTR [rsp+0x180]
  20f3f4:	00 
  20f3f5:	48 89 8c 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],rcx
  20f3fc:	00 
  20f3fd:	48 8d b4 24 f0 00 00 	lea    rsi,[rsp+0xf0]
  20f404:	00 
  20f405:	ff d0                	call   rax
  20f407:	e9 61 01 00 00       	jmp    20f56d <openSelfDebugInfo+0x4c7d>
  20f40c:	66 41 bd 1e 00       	mov    r13w,0x1e
        const bytes = @sliceToBytes(memory);
  20f411:	48 8b 84 24 88 00 00 	mov    rax,QWORD PTR [rsp+0x88]
  20f418:	00 
  20f419:	48 8b 00             	mov    rax,QWORD PTR [rax]
  20f41c:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  20f420:	0f 84 20 b7 ff ff    	je     20ab46 <openSelfDebugInfo+0x256>
  20f426:	48 8b 4c 24 78       	mov    rcx,QWORD PTR [rsp+0x78]
  20f42b:	48 8b 39             	mov    rdi,QWORD PTR [rcx]
        const bytes = @sliceToBytes(memory);
  20f42e:	48 8b 8c 24 90 00 00 	mov    rcx,QWORD PTR [rsp+0x90]
  20f435:	00 
  20f436:	48 8b 09             	mov    rcx,QWORD PTR [rcx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  20f439:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  20f43d:	48 89 8c 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],rcx
  20f444:	00 
  20f445:	48 89 84 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],rax
  20f44c:	00 
  20f44d:	48 8d b4 24 f0 00 00 	lea    rsi,[rsp+0xf0]
  20f454:	00 
  20f455:	ff d2                	call   rdx
  20f457:	e9 ea b6 ff ff       	jmp    20ab46 <openSelfDebugInfo+0x256>
        for (elf.section_headers) |*elf_section| {
  20f45c:	48 8b 84 24 88 00 00 	mov    rax,QWORD PTR [rsp+0x88]
  20f463:	00 
  20f464:	48 8b 00             	mov    rax,QWORD PTR [rax]
  20f467:	48 85 c0             	test   rax,rax
  20f46a:	74 6b                	je     20f4d7 <openSelfDebugInfo+0x4be7>
  20f46c:	48 8b 8c 24 90 00 00 	mov    rcx,QWORD PTR [rsp+0x90]
  20f473:	00 
  20f474:	4c 8b 09             	mov    r9,QWORD PTR [rcx]
  20f477:	49 8d 51 20          	lea    rdx,[r9+0x20]
  20f47b:	31 f6                	xor    esi,esi
  20f47d:	4c 8d 05 ac 7b ff ff 	lea    r8,[rip+0xffffffffffff7bac]        # 207030 <__unnamed_54>
            if (elf_section.sh_type != SHT_NOBITS) {
  20f484:	83 7a e4 08          	cmp    DWORD PTR [rdx-0x1c],0x8
  20f488:	74 3e                	je     20f4c8 <openSelfDebugInfo+0x4bd8>
                const file_end_offset = try math.add(u64, elf_section.offset, elf_section.size);
  20f48a:	48 8b 4a f8          	mov    rcx,QWORD PTR [rdx-0x8]
  20f48e:	4c 89 c7             	mov    rdi,r8
    return if (@addWithOverflow(T, a, b, &answer)) error.Overflow else answer;
  20f491:	48 03 0a             	add    rcx,QWORD PTR [rdx]
  20f494:	72 1a                	jb     20f4b0 <openSelfDebugInfo+0x4bc0>
  20f496:	66 c7 84 24 f0 00 00 	mov    WORD PTR [rsp+0xf0],0x0
  20f49d:	00 00 00 
  20f4a0:	48 89 8c 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],rcx
  20f4a7:	00 
  20f4a8:	48 8d bc 24 f0 00 00 	lea    rdi,[rsp+0xf0]
  20f4af:	00 
  20f4b0:	44 0f b7 2f          	movzx  r13d,WORD PTR [rdi]
  20f4b4:	66 45 85 ed          	test   r13w,r13w
  20f4b8:	75 52                	jne    20f50c <openSelfDebugInfo+0x4c1c>
                if (stream_end < file_end_offset) return error.InvalidFormat;
  20f4ba:	48 8b 8c 24 c8 01 00 	mov    rcx,QWORD PTR [rsp+0x1c8]
  20f4c1:	00 
  20f4c2:	48 3b 4f 08          	cmp    rcx,QWORD PTR [rdi+0x8]
  20f4c6:	72 79                	jb     20f541 <openSelfDebugInfo+0x4c51>
        for (elf.section_headers) |*elf_section| {
  20f4c8:	48 83 c6 01          	add    rsi,0x1
  20f4cc:	48 83 c2 40          	add    rdx,0x40
  20f4d0:	48 39 c6             	cmp    rsi,rax
  20f4d3:	72 af                	jb     20f484 <openSelfDebugInfo+0x4b94>
  20f4d5:	eb 0b                	jmp    20f4e2 <openSelfDebugInfo+0x4bf2>
        elf.string_section = &elf.section_headers[elf.string_section_index];
  20f4d7:	48 8b 8c 24 90 00 00 	mov    rcx,QWORD PTR [rsp+0x90]
  20f4de:	00 
  20f4df:	4c 8b 09             	mov    r9,QWORD PTR [rcx]
  20f4e2:	48 8b 4d 30          	mov    rcx,QWORD PTR [rbp+0x30]
  20f4e6:	48 c1 e1 06          	shl    rcx,0x6
  20f4ea:	49 8d 14 09          	lea    rdx,[r9+rcx*1]
  20f4ee:	48 89 55 38          	mov    QWORD PTR [rbp+0x38],rdx
        if (elf.string_section.sh_type != SHT_STRTAB) {
  20f4f2:	41 83 7c 09 04 03    	cmp    DWORD PTR [r9+rcx*1+0x4],0x3
  20f4f8:	75 47                	jne    20f541 <openSelfDebugInfo+0x4c51>
  20f4fa:	45 31 ed             	xor    r13d,r13d
  20f4fd:	66 45 85 ed          	test   r13w,r13w
  20f501:	0f 85 3f b6 ff ff    	jne    20ab46 <openSelfDebugInfo+0x256>
  20f507:	e9 26 bd ff ff       	jmp    20b232 <openSelfDebugInfo+0x942>
        const bytes = @sliceToBytes(memory);
  20f50c:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  20f510:	0f 84 30 b6 ff ff    	je     20ab46 <openSelfDebugInfo+0x256>
  20f516:	48 8b 4c 24 78       	mov    rcx,QWORD PTR [rsp+0x78]
  20f51b:	48 8b 39             	mov    rdi,QWORD PTR [rcx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  20f51e:	48 8b 4f 10          	mov    rcx,QWORD PTR [rdi+0x10]
  20f522:	4c 89 8c 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],r9
  20f529:	00 
  20f52a:	48 89 84 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],rax
  20f531:	00 
  20f532:	48 8d b4 24 f0 00 00 	lea    rsi,[rsp+0xf0]
  20f539:	00 
  20f53a:	ff d1                	call   rcx
  20f53c:	e9 05 b6 ff ff       	jmp    20ab46 <openSelfDebugInfo+0x256>
        const bytes = @sliceToBytes(memory);
  20f541:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  20f545:	74 26                	je     20f56d <openSelfDebugInfo+0x4c7d>
  20f547:	48 8b 4c 24 78       	mov    rcx,QWORD PTR [rsp+0x78]
  20f54c:	48 8b 39             	mov    rdi,QWORD PTR [rcx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  20f54f:	48 8b 4f 10          	mov    rcx,QWORD PTR [rdi+0x10]
  20f553:	4c 89 8c 24 f0 00 00 	mov    QWORD PTR [rsp+0xf0],r9
  20f55a:	00 
  20f55b:	48 89 84 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],rax
  20f562:	00 
  20f563:	48 8d b4 24 f0 00 00 	lea    rsi,[rsp+0xf0]
  20f56a:	00 
  20f56b:	ff d1                	call   rcx
  20f56d:	66 41 bd 1f 00       	mov    r13w,0x1f
  20f572:	e9 cf b5 ff ff       	jmp    20ab46 <openSelfDebugInfo+0x256>
  20f577:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  20f57e:	00 00 

000000000020f580 <Elf_findSection>:
    }

    pub fn findSection(elf: *Elf, name: []const u8) !?*SectionHeader {
  20f580:	55                   	push   rbp
  20f581:	41 57                	push   r15
  20f583:	41 56                	push   r14
  20f585:	41 55                	push   r13
  20f587:	41 54                	push   r12
  20f589:	53                   	push   rbx
  20f58a:	48 81 ec 88 00 00 00 	sub    rsp,0x88
  20f591:	48 89 d3             	mov    rbx,rdx
  20f594:	48 89 7c 24 08       	mov    QWORD PTR [rsp+0x8],rdi
        var file_stream = io.FileInStream.init(elf.in_file);
  20f599:	48 8b 06             	mov    rax,QWORD PTR [rsi]
  20f59c:	48 89 44 24 28       	mov    QWORD PTR [rsp+0x28],rax
  20f5a1:	48 8d 05 48 05 00 00 	lea    rax,[rip+0x548]        # 20faf0 <FileInStream_readFn>
  20f5a8:	48 89 44 24 30       	mov    QWORD PTR [rsp+0x30],rax
        const in = &file_stream.stream;

        section_loop: for (elf.section_headers) |*elf_section| {
  20f5ad:	48 8b 46 40          	mov    rax,QWORD PTR [rsi+0x40]
  20f5b1:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
  20f5b6:	48 85 c0             	test   rax,rax
  20f5b9:	0f 84 37 01 00 00    	je     20f6f6 <Elf_findSection+0x176>
  20f5bf:	45 31 e4             	xor    r12d,r12d
  20f5c2:	48 89 74 24 20       	mov    QWORD PTR [rsp+0x20],rsi
  20f5c7:	4c 8b 76 38          	mov    r14,QWORD PTR [rsi+0x38]
  20f5cb:	4c 89 e0             	mov    rax,r12
  20f5ce:	48 c1 e0 06          	shl    rax,0x6
            if (elf_section.sh_type == SHT_NULL) continue;
  20f5d2:	41 83 7c 06 04 00    	cmp    DWORD PTR [r14+rax*1+0x4],0x0
  20f5d8:	0f 84 04 01 00 00    	je     20f6e2 <Elf_findSection+0x162>
  20f5de:	49 01 c6             	add    r14,rax
  20f5e1:	48 8b 4c 24 20       	mov    rcx,QWORD PTR [rsp+0x20]

            const name_offset = elf.string_section.offset + elf_section.name;
  20f5e6:	48 8b 41 30          	mov    rax,QWORD PTR [rcx+0x30]
  20f5ea:	41 8b 36             	mov    esi,DWORD PTR [r14]
    if (@maxValue(@typeOf(x)) > @maxValue(T) and x > @maxValue(T)) {
  20f5ed:	48 03 70 18          	add    rsi,QWORD PTR [rax+0x18]
  20f5f1:	0f 88 3e 01 00 00    	js     20f735 <Elf_findSection+0x1b5>
            try elf.in_file.seekTo(name_offset);
  20f5f7:	48 8b 01             	mov    rax,QWORD PTR [rcx]
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  20f5fa:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  20f5fd:	b8 08 00 00 00       	mov    eax,0x8
  20f602:	31 d2                	xor    edx,edx
  20f604:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  20f606:	48 89 c1             	mov    rcx,rax
  20f609:	48 f7 d9             	neg    rcx
  20f60c:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  20f612:	b8 00 00 00 00       	mov    eax,0x0
  20f617:	48 0f 46 c8          	cmovbe rcx,rax
  20f61b:	48 85 c9             	test   rcx,rcx
  20f61e:	0f 85 17 01 00 00    	jne    20f73b <Elf_findSection+0x1bb>

            for (name) |expected_c| {
  20f624:	4c 8b 6b 08          	mov    r13,QWORD PTR [rbx+0x8]
  20f628:	4d 85 ed             	test   r13,r13
  20f62b:	74 66                	je     20f693 <Elf_findSection+0x113>
  20f62d:	31 ed                	xor    ebp,ebp
  20f62f:	90                   	nop
  20f630:	48 8b 03             	mov    rax,QWORD PTR [rbx]
  20f633:	44 0f b6 3c 28       	movzx  r15d,BYTE PTR [rax+rbp*1]
            try self.readNoEof(result[0..]);
  20f638:	48 8d 44 24 07       	lea    rax,[rsp+0x7]
  20f63d:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  20f642:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  20f649:	00 00 
            return self.readFn(self, buffer);
  20f64b:	48 8d 7c 24 38       	lea    rdi,[rsp+0x38]
  20f650:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
  20f655:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  20f65a:	ff 54 24 30          	call   QWORD PTR [rsp+0x30]
  20f65e:	0f b7 44 24 38       	movzx  eax,WORD PTR [rsp+0x38]
            const amt_read = try self.read(buf);
  20f663:	66 85 c0             	test   ax,ax
  20f666:	0f 85 9d 00 00 00    	jne    20f709 <Elf_findSection+0x189>
  20f66c:	48 8b 44 24 40       	mov    rax,QWORD PTR [rsp+0x40]
            if (amt_read < buf.len) return error.EndOfStream;
  20f671:	48 3b 44 24 18       	cmp    rax,QWORD PTR [rsp+0x18]
  20f676:	0f 82 89 00 00 00    	jb     20f705 <Elf_findSection+0x185>
            return result[0];
  20f67c:	0f b6 44 24 07       	movzx  eax,BYTE PTR [rsp+0x7]
                const target_c = try in.readByte();
                if (target_c == 0 or expected_c != target_c) continue :section_loop;
  20f681:	84 c0                	test   al,al
  20f683:	74 5d                	je     20f6e2 <Elf_findSection+0x162>
  20f685:	41 38 c7             	cmp    r15b,al
  20f688:	75 58                	jne    20f6e2 <Elf_findSection+0x162>
  20f68a:	48 83 c5 01          	add    rbp,0x1
            for (name) |expected_c| {
  20f68e:	4c 39 ed             	cmp    rbp,r13
  20f691:	72 9d                	jb     20f630 <Elf_findSection+0xb0>
            try self.readNoEof(result[0..]);
  20f693:	48 8d 44 24 07       	lea    rax,[rsp+0x7]
  20f698:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  20f69d:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  20f6a4:	00 00 
            return self.readFn(self, buffer);
  20f6a6:	48 8d 7c 24 38       	lea    rdi,[rsp+0x38]
  20f6ab:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
  20f6b0:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  20f6b5:	ff 54 24 30          	call   QWORD PTR [rsp+0x30]
  20f6b9:	0f b7 44 24 38       	movzx  eax,WORD PTR [rsp+0x38]
            const amt_read = try self.read(buf);
  20f6be:	66 85 c0             	test   ax,ax
  20f6c1:	0f 85 b7 00 00 00    	jne    20f77e <Elf_findSection+0x1fe>
  20f6c7:	48 8b 44 24 40       	mov    rax,QWORD PTR [rsp+0x40]
            if (amt_read < buf.len) return error.EndOfStream;
  20f6cc:	48 3b 44 24 18       	cmp    rax,QWORD PTR [rsp+0x18]
  20f6d1:	0f 82 a3 00 00 00    	jb     20f77a <Elf_findSection+0x1fa>
            }

            {
                const null_byte = try in.readByte();
                if (null_byte == 0) return elf_section;
  20f6d7:	80 7c 24 07 00       	cmp    BYTE PTR [rsp+0x7],0x0
  20f6dc:	0f 84 b0 00 00 00    	je     20f792 <Elf_findSection+0x212>
        section_loop: for (elf.section_headers) |*elf_section| {
  20f6e2:	49 83 c4 01          	add    r12,0x1
  20f6e6:	4c 3b 64 24 50       	cmp    r12,QWORD PTR [rsp+0x50]
  20f6eb:	48 8b 74 24 20       	mov    rsi,QWORD PTR [rsp+0x20]
  20f6f0:	0f 82 d1 fe ff ff    	jb     20f5c7 <Elf_findSection+0x47>
            }
        }

        return null;
  20f6f6:	c5 f8 57 c0          	vxorps xmm0,xmm0,xmm0
  20f6fa:	48 8b 44 24 08       	mov    rax,QWORD PTR [rsp+0x8]
  20f6ff:	c5 f8 11 00          	vmovups XMMWORD PTR [rax],xmm0
  20f703:	eb 1e                	jmp    20f723 <Elf_findSection+0x1a3>
  20f705:	66 b8 1e 00          	mov    ax,0x1e
  20f709:	48 8b 54 24 08       	mov    rdx,QWORD PTR [rsp+0x8]
                const target_c = try in.readByte();
  20f70e:	66 89 02             	mov    WORD PTR [rdx],ax
  20f711:	48 8b 44 24 6c       	mov    rax,QWORD PTR [rsp+0x6c]
  20f716:	48 8b 4c 24 72       	mov    rcx,QWORD PTR [rsp+0x72]
  20f71b:	48 89 4a 08          	mov    QWORD PTR [rdx+0x8],rcx
  20f71f:	48 89 42 02          	mov    QWORD PTR [rdx+0x2],rax
  20f723:	48 81 c4 88 00 00 00 	add    rsp,0x88
  20f72a:	5b                   	pop    rbx
  20f72b:	41 5c                	pop    r12
  20f72d:	41 5d                	pop    r13
  20f72f:	41 5e                	pop    r14
  20f731:	41 5f                	pop    r15
  20f733:	5d                   	pop    rbp
  20f734:	c3                   	ret    
  20f735:	66 b8 21 00          	mov    ax,0x21
  20f739:	eb 28                	jmp    20f763 <Elf_findSection+0x1e3>
  20f73b:	48 8d 41 ea          	lea    rax,[rcx-0x16]
  20f73f:	48 83 f8 35          	cmp    rax,0x35
  20f743:	77 10                	ja     20f755 <Elf_findSection+0x1d5>
  20f745:	48 ba 81 00 00 00 00 	movabs rdx,0x20000000000081
  20f74c:	00 20 00 
  20f74f:	48 0f a3 c2          	bt     rdx,rax
  20f753:	72 0a                	jb     20f75f <Elf_findSection+0x1df>
  20f755:	66 b8 02 00          	mov    ax,0x2
  20f759:	48 83 f9 06          	cmp    rcx,0x6
  20f75d:	75 04                	jne    20f763 <Elf_findSection+0x1e3>
  20f75f:	66 b8 20 00          	mov    ax,0x20
  20f763:	48 8b 54 24 08       	mov    rdx,QWORD PTR [rsp+0x8]
            try elf.in_file.seekTo(name_offset);
  20f768:	66 89 02             	mov    WORD PTR [rdx],ax
  20f76b:	48 8b 44 24 7a       	mov    rax,QWORD PTR [rsp+0x7a]
  20f770:	48 8b 8c 24 80 00 00 	mov    rcx,QWORD PTR [rsp+0x80]
  20f777:	00 
  20f778:	eb a1                	jmp    20f71b <Elf_findSection+0x19b>
  20f77a:	66 b8 1e 00          	mov    ax,0x1e
  20f77e:	48 8b 54 24 08       	mov    rdx,QWORD PTR [rsp+0x8]
                const null_byte = try in.readByte();
  20f783:	66 89 02             	mov    WORD PTR [rdx],ax
  20f786:	48 8b 44 24 5e       	mov    rax,QWORD PTR [rsp+0x5e]
  20f78b:	48 8b 4c 24 64       	mov    rcx,QWORD PTR [rsp+0x64]
  20f790:	eb 89                	jmp    20f71b <Elf_findSection+0x19b>
  20f792:	48 8b 4c 24 08       	mov    rcx,QWORD PTR [rsp+0x8]
                if (null_byte == 0) return elf_section;
  20f797:	66 c7 01 00 00       	mov    WORD PTR [rcx],0x0
  20f79c:	0f b7 44 24 4e       	movzx  eax,WORD PTR [rsp+0x4e]
  20f7a1:	66 89 41 06          	mov    WORD PTR [rcx+0x6],ax
  20f7a5:	8b 44 24 4a          	mov    eax,DWORD PTR [rsp+0x4a]
  20f7a9:	89 41 02             	mov    DWORD PTR [rcx+0x2],eax
  20f7ac:	4c 89 71 08          	mov    QWORD PTR [rcx+0x8],r14
  20f7b0:	e9 6e ff ff ff       	jmp    20f723 <Elf_findSection+0x1a3>
  20f7b5:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20f7bc:	00 00 00 00 

000000000020f7c0 <File_openReadC>:
    pub fn openReadC(path: [*]const u8) OpenError!File {
  20f7c0:	49 89 f1             	mov    r9,rsi
  20f7c3:	49 89 f8             	mov    r8,rdi
  20f7c6:	45 31 d2             	xor    r10d,r10d
  20f7c9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  20f7d0:	b8 02 00 00 00       	mov    eax,0x2
  20f7d5:	be 00 00 00 00       	mov    esi,0x0
  20f7da:	31 d2                	xor    edx,edx
  20f7dc:	4c 89 cf             	mov    rdi,r9
  20f7df:	0f 05                	syscall 
  20f7e1:	48 89 c1             	mov    rcx,rax
  20f7e4:	48 f7 d9             	neg    rcx
  20f7e7:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  20f7ed:	49 0f 46 ca          	cmovbe rcx,r10
        if (err > 0) {
  20f7f1:	48 83 f9 04          	cmp    rcx,0x4
  20f7f5:	74 d9                	je     20f7d0 <File_openReadC+0x10>
  20f7f7:	48 83 f9 4b          	cmp    rcx,0x4b
  20f7fb:	77 2d                	ja     20f82a <File_openReadC+0x6a>
  20f7fd:	48 8d 15 18 0f ff ff 	lea    rdx,[rip+0xffffffffffff0f18]        # 20071c <app_mask+0x49c>
  20f804:	48 63 0c 8a          	movsxd rcx,DWORD PTR [rdx+rcx*4]
  20f808:	48 01 d1             	add    rcx,rdx
  20f80b:	ff e1                	jmp    rcx
  20f80d:	66 b8 0e 00          	mov    ax,0xe
  20f811:	eb 57                	jmp    20f86a <File_openReadC+0xaa>
  20f813:	66 b8 0b 00          	mov    ax,0xb
  20f817:	eb 51                	jmp    20f86a <File_openReadC+0xaa>
            return openHandle(fd);
  20f819:	66 41 c7 00 00 00    	mov    WORD PTR [r8],0x0
  20f81f:	41 89 40 04          	mov    DWORD PTR [r8+0x4],eax
  20f823:	c3                   	ret    
  20f824:	66 b8 13 00          	mov    ax,0x13
  20f828:	eb 40                	jmp    20f86a <File_openReadC+0xaa>
  20f82a:	66 b8 02 00          	mov    ax,0x2
  20f82e:	eb 3a                	jmp    20f86a <File_openReadC+0xaa>
  20f830:	66 b8 04 00          	mov    ax,0x4
  20f834:	eb 34                	jmp    20f86a <File_openReadC+0xaa>
  20f836:	66 b8 12 00          	mov    ax,0x12
  20f83a:	eb 2e                	jmp    20f86a <File_openReadC+0xaa>
  20f83c:	66 b8 1c 00          	mov    ax,0x1c
  20f840:	eb 28                	jmp    20f86a <File_openReadC+0xaa>
  20f842:	66 b8 1d 00          	mov    ax,0x1d
  20f846:	eb 22                	jmp    20f86a <File_openReadC+0xaa>
  20f848:	66 b8 18 00          	mov    ax,0x18
  20f84c:	eb 1c                	jmp    20f86a <File_openReadC+0xaa>
  20f84e:	66 b8 1b 00          	mov    ax,0x1b
  20f852:	eb 16                	jmp    20f86a <File_openReadC+0xaa>
  20f854:	66 b8 1a 00          	mov    ax,0x1a
  20f858:	eb 10                	jmp    20f86a <File_openReadC+0xaa>
  20f85a:	66 b8 0d 00          	mov    ax,0xd
  20f85e:	eb 0a                	jmp    20f86a <File_openReadC+0xaa>
  20f860:	66 b8 15 00          	mov    ax,0x15
  20f864:	eb 04                	jmp    20f86a <File_openReadC+0xaa>
  20f866:	66 b8 19 00          	mov    ax,0x19
            const fd = try os.posixOpenC(path, flags, 0);
  20f86a:	66 41 89 00          	mov    WORD PTR [r8],ax
  20f86e:	0f b7 44 24 fe       	movzx  eax,WORD PTR [rsp-0x2]
  20f873:	66 41 89 40 06       	mov    WORD PTR [r8+0x6],ax
  20f878:	8b 44 24 fa          	mov    eax,DWORD PTR [rsp-0x6]
  20f87c:	41 89 40 02          	mov    DWORD PTR [r8+0x2],eax
  20f880:	c3                   	ret    
  20f881:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20f888:	0f 1f 84 00 00 00 00 
  20f88f:	00 

000000000020f890 <InStream(ReadError)_readInt.30>:
        pub fn readInt(self: *Self, endian: builtin.Endian, comptime T: type) !T {
  20f890:	55                   	push   rbp
  20f891:	53                   	push   rbx
  20f892:	48 83 ec 48          	sub    rsp,0x48
  20f896:	89 d5                	mov    ebp,edx
  20f898:	48 89 fb             	mov    rbx,rdi
  20f89b:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
            try self.readNoEof(bytes[0..]);
  20f8a0:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  20f8a5:	48 c7 44 24 20 08 00 	mov    QWORD PTR [rsp+0x20],0x8
  20f8ac:	00 00 
  20f8ae:	48 8d 7c 24 28       	lea    rdi,[rsp+0x28]
  20f8b3:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  20f8b8:	ff 16                	call   QWORD PTR [rsi]
  20f8ba:	0f b7 44 24 28       	movzx  eax,WORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  20f8bf:	66 85 c0             	test   ax,ax
  20f8c2:	75 10                	jne    20f8d4 <InStream(ReadError)_readInt.30+0x44>
  20f8c4:	48 8b 4c 24 30       	mov    rcx,QWORD PTR [rsp+0x30]
  20f8c9:	66 b8 1e 00          	mov    ax,0x1e
            if (amt_read < buf.len) return error.EndOfStream;
  20f8cd:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  20f8d2:	73 1c                	jae    20f8f0 <InStream(ReadError)_readInt.30+0x60>
            try self.readNoEof(bytes[0..]);
  20f8d4:	66 89 03             	mov    WORD PTR [rbx],ax
  20f8d7:	48 8b 44 24 3a       	mov    rax,QWORD PTR [rsp+0x3a]
  20f8dc:	48 8b 4c 24 40       	mov    rcx,QWORD PTR [rsp+0x40]
  20f8e1:	48 89 4b 08          	mov    QWORD PTR [rbx+0x8],rcx
  20f8e5:	48 89 43 02          	mov    QWORD PTR [rbx+0x2],rax
  20f8e9:	48 83 c4 48          	add    rsp,0x48
  20f8ed:	5b                   	pop    rbx
  20f8ee:	5d                   	pop    rbp
  20f8ef:	c3                   	ret    
  20f8f0:	0f b6 44 24 08       	movzx  eax,BYTE PTR [rsp+0x8]
  20f8f5:	0f b6 4c 24 09       	movzx  ecx,BYTE PTR [rsp+0x9]
    switch (endian) {
  20f8fa:	40 f6 c5 01          	test   bpl,0x1
  20f8fe:	74 51                	je     20f951 <InStream(ReadError)_readInt.30+0xc1>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20f900:	48 c1 e1 08          	shl    rcx,0x8
  20f904:	48 09 c1             	or     rcx,rax
  20f907:	0f b6 44 24 0a       	movzx  eax,BYTE PTR [rsp+0xa]
  20f90c:	48 c1 e0 10          	shl    rax,0x10
  20f910:	48 09 c8             	or     rax,rcx
  20f913:	0f b6 4c 24 0b       	movzx  ecx,BYTE PTR [rsp+0xb]
  20f918:	48 c1 e1 18          	shl    rcx,0x18
  20f91c:	48 09 c1             	or     rcx,rax
  20f91f:	0f b6 44 24 0c       	movzx  eax,BYTE PTR [rsp+0xc]
  20f924:	48 c1 e0 20          	shl    rax,0x20
  20f928:	48 09 c8             	or     rax,rcx
  20f92b:	0f b6 4c 24 0d       	movzx  ecx,BYTE PTR [rsp+0xd]
  20f930:	48 c1 e1 28          	shl    rcx,0x28
  20f934:	48 09 c1             	or     rcx,rax
  20f937:	0f b6 54 24 0e       	movzx  edx,BYTE PTR [rsp+0xe]
  20f93c:	48 c1 e2 30          	shl    rdx,0x30
  20f940:	0f b6 44 24 0f       	movzx  eax,BYTE PTR [rsp+0xf]
  20f945:	48 c1 e0 38          	shl    rax,0x38
  20f949:	48 09 d0             	or     rax,rdx
  20f94c:	48 09 c8             	or     rax,rcx
  20f94f:	eb 4f                	jmp    20f9a0 <InStream(ReadError)_readInt.30+0x110>
                result = (result << 8) | b;
  20f951:	48 c1 e0 08          	shl    rax,0x8
  20f955:	48 09 c8             	or     rax,rcx
  20f958:	48 c1 e0 08          	shl    rax,0x8
  20f95c:	0f b6 4c 24 0a       	movzx  ecx,BYTE PTR [rsp+0xa]
  20f961:	48 09 c1             	or     rcx,rax
  20f964:	48 c1 e1 08          	shl    rcx,0x8
  20f968:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  20f96d:	48 09 c8             	or     rax,rcx
  20f970:	48 c1 e0 08          	shl    rax,0x8
  20f974:	0f b6 4c 24 0c       	movzx  ecx,BYTE PTR [rsp+0xc]
  20f979:	48 09 c1             	or     rcx,rax
  20f97c:	48 c1 e1 08          	shl    rcx,0x8
  20f980:	0f b6 44 24 0d       	movzx  eax,BYTE PTR [rsp+0xd]
  20f985:	48 09 c8             	or     rax,rcx
  20f988:	48 c1 e0 08          	shl    rax,0x8
  20f98c:	0f b6 4c 24 0e       	movzx  ecx,BYTE PTR [rsp+0xe]
  20f991:	48 09 c1             	or     rcx,rax
  20f994:	48 c1 e1 08          	shl    rcx,0x8
  20f998:	0f b6 44 24 0f       	movzx  eax,BYTE PTR [rsp+0xf]
  20f99d:	48 09 c8             	or     rax,rcx
            return mem.readInt(bytes, T, endian);
  20f9a0:	66 c7 03 00 00       	mov    WORD PTR [rbx],0x0
  20f9a5:	0f b7 4c 24 16       	movzx  ecx,WORD PTR [rsp+0x16]
  20f9aa:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  20f9ae:	8b 4c 24 12          	mov    ecx,DWORD PTR [rsp+0x12]
  20f9b2:	89 4b 02             	mov    DWORD PTR [rbx+0x2],ecx
  20f9b5:	48 89 43 08          	mov    QWORD PTR [rbx+0x8],rax
  20f9b9:	48 83 c4 48          	add    rsp,0x48
  20f9bd:	5b                   	pop    rbx
  20f9be:	5d                   	pop    rbp
  20f9bf:	c3                   	ret    

000000000020f9c0 <File_read>:
        SystemResources,

        Unexpected,
    };

    pub fn read(self: *File, buffer: []u8) ReadError!usize {
  20f9c0:	41 57                	push   r15
  20f9c2:	41 56                	push   r14
  20f9c4:	53                   	push   rbx
  20f9c5:	49 89 d1             	mov    r9,rdx
  20f9c8:	49 89 f2             	mov    r10,rsi
  20f9cb:	49 89 f8             	mov    r8,rdi
        if (is_posix) {
            var index: usize = 0;
            while (index < buffer.len) {
  20f9ce:	49 8b 51 08          	mov    rdx,QWORD PTR [r9+0x8]
  20f9d2:	48 85 d2             	test   rdx,rdx
  20f9d5:	74 70                	je     20fa47 <File_read+0x87>
  20f9d7:	45 31 f6             	xor    r14d,r14d
  20f9da:	4c 8d 3d 6b 0e ff ff 	lea    r15,[rip+0xffffffffffff0e6b]        # 20084c <app_mask+0x5cc>
  20f9e1:	31 db                	xor    ebx,ebx
  20f9e3:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20f9ea:	84 00 00 00 00 00 
  20f9f0:	49 8b 31             	mov    rsi,QWORD PTR [r9]
                const amt_read = posix.read(self.handle, buffer.ptr + index, buffer.len - index);
  20f9f3:	48 01 de             	add    rsi,rbx
  20f9f6:	48 29 da             	sub    rdx,rbx
    return syscall3(SYS_read, @intCast(usize, fd), @ptrToInt(buf), count);
  20f9f9:	49 63 3a             	movsxd rdi,DWORD PTR [r10]
  20f9fc:	31 c0                	xor    eax,eax
  20f9fe:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  20fa00:	48 89 c1             	mov    rcx,rax
  20fa03:	48 f7 d9             	neg    rcx
  20fa06:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  20fa0c:	49 0f 46 ce          	cmovbe rcx,r14
                const read_err = posix.getErrno(amt_read);
                if (read_err > 0) {
  20fa10:	48 83 f9 04          	cmp    rcx,0x4
  20fa14:	75 0b                	jne    20fa21 <File_read+0x61>
            while (index < buffer.len) {
  20fa16:	49 8b 51 08          	mov    rdx,QWORD PTR [r9+0x8]
  20fa1a:	48 39 da             	cmp    rdx,rbx
  20fa1d:	77 d1                	ja     20f9f0 <File_read+0x30>
  20fa1f:	eb 28                	jmp    20fa49 <File_read+0x89>
  20fa21:	48 83 f9 15          	cmp    rcx,0x15
  20fa25:	77 44                	ja     20fa6b <File_read+0xab>
  20fa27:	49 63 0c 8f          	movsxd rcx,DWORD PTR [r15+rcx*4]
  20fa2b:	4c 01 f9             	add    rcx,r15
  20fa2e:	ff e1                	jmp    rcx
                        posix.ENOBUFS => return error.SystemResources,
                        posix.ENOMEM => return error.SystemResources,
                        else => return os.unexpectedErrorPosix(read_err),
                    }
                }
                if (amt_read == 0) return index;
  20fa30:	48 85 c0             	test   rax,rax
  20fa33:	0f 84 91 00 00 00    	je     20faca <File_read+0x10a>
  20fa39:	48 01 c3             	add    rbx,rax
            while (index < buffer.len) {
  20fa3c:	49 8b 51 08          	mov    rdx,QWORD PTR [r9+0x8]
  20fa40:	48 39 da             	cmp    rdx,rbx
  20fa43:	77 ab                	ja     20f9f0 <File_read+0x30>
  20fa45:	eb 02                	jmp    20fa49 <File_read+0x89>
  20fa47:	31 db                	xor    ebx,ebx
                index += amt_read;
            }
            return index;
  20fa49:	66 41 c7 00 00 00    	mov    WORD PTR [r8],0x0
  20fa4f:	0f b7 44 24 ea       	movzx  eax,WORD PTR [rsp-0x16]
  20fa54:	66 41 89 40 06       	mov    WORD PTR [r8+0x6],ax
  20fa59:	8b 44 24 e6          	mov    eax,DWORD PTR [rsp-0x1a]
  20fa5d:	41 89 40 02          	mov    DWORD PTR [r8+0x2],eax
  20fa61:	49 89 58 08          	mov    QWORD PTR [r8+0x8],rbx
  20fa65:	5b                   	pop    rbx
  20fa66:	41 5e                	pop    r14
  20fa68:	41 5f                	pop    r15
  20fa6a:	c3                   	ret    
                if (read_err > 0) {
  20fa6b:	48 83 f9 69          	cmp    rcx,0x69
  20fa6f:	75 0a                	jne    20fa7b <File_read+0xbb>
  20fa71:	c5 f8 10 05 d7 72 ff 	vmovups xmm0,XMMWORD PTR [rip+0xffffffffffff72d7]        # 206d50 <__unnamed_56>
  20fa78:	ff 
  20fa79:	eb 44                	jmp    20fabf <File_read+0xff>
                        else => return os.unexpectedErrorPosix(read_err),
  20fa7b:	66 41 c7 00 02 00    	mov    WORD PTR [r8],0x2
  20fa81:	48 8b 44 24 f2       	mov    rax,QWORD PTR [rsp-0xe]
  20fa86:	48 8b 4c 24 f8       	mov    rcx,QWORD PTR [rsp-0x8]
  20fa8b:	49 89 48 08          	mov    QWORD PTR [r8+0x8],rcx
  20fa8f:	49 89 40 02          	mov    QWORD PTR [r8+0x2],rax
  20fa93:	5b                   	pop    rbx
  20fa94:	41 5e                	pop    r14
  20fa96:	41 5f                	pop    r15
  20fa98:	c3                   	ret    
                        posix.EIO => return error.InputOutput,
  20fa99:	c5 f8 10 05 2f 79 ff 	vmovups xmm0,XMMWORD PTR [rip+0xffffffffffff792f]        # 2073d0 <__unnamed_57>
  20faa0:	ff 
  20faa1:	eb 1c                	jmp    20fabf <File_read+0xff>
                        posix.EBADF => return error.FileClosed,
  20faa3:	c5 f8 10 05 35 73 ff 	vmovups xmm0,XMMWORD PTR [rip+0xffffffffffff7335]        # 206de0 <__unnamed_58>
  20faaa:	ff 
  20faab:	eb 12                	jmp    20fabf <File_read+0xff>
                        posix.EAGAIN => return error.WouldBlock,
  20faad:	c5 f8 10 05 ab 76 ff 	vmovups xmm0,XMMWORD PTR [rip+0xffffffffffff76ab]        # 207160 <__unnamed_59>
  20fab4:	ff 
  20fab5:	eb 08                	jmp    20fabf <File_read+0xff>
                        posix.EISDIR => return error.IsDir,
  20fab7:	c5 f8 10 05 e1 70 ff 	vmovups xmm0,XMMWORD PTR [rip+0xffffffffffff70e1]        # 206ba0 <__unnamed_60>
  20fabe:	ff 
  20fabf:	c4 c1 78 11 00       	vmovups XMMWORD PTR [r8],xmm0
  20fac4:	5b                   	pop    rbx
  20fac5:	41 5e                	pop    r14
  20fac7:	41 5f                	pop    r15
  20fac9:	c3                   	ret    
                if (amt_read == 0) return index;
  20faca:	66 41 c7 00 00 00    	mov    WORD PTR [r8],0x0
  20fad0:	0f b7 44 24 f0       	movzx  eax,WORD PTR [rsp-0x10]
  20fad5:	66 41 89 40 06       	mov    WORD PTR [r8+0x6],ax
  20fada:	8b 44 24 ec          	mov    eax,DWORD PTR [rsp-0x14]
  20fade:	e9 7a ff ff ff       	jmp    20fa5d <File_read+0x9d>
  20fae3:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20faea:	84 00 00 00 00 00 

000000000020faf0 <FileInStream_readFn>:
    fn readFn(in_stream: *Stream, buffer: []u8) Error!usize {
  20faf0:	53                   	push   rbx
  20faf1:	48 83 ec 10          	sub    rsp,0x10
  20faf5:	48 89 fb             	mov    rbx,rdi
        return self.file.read(buffer);
  20faf8:	48 8b 76 f8          	mov    rsi,QWORD PTR [rsi-0x8]
  20fafc:	48 89 e7             	mov    rdi,rsp
  20faff:	e8 bc fe ff ff       	call   20f9c0 <File_read>
  20fb04:	c5 f8 10 04 24       	vmovups xmm0,XMMWORD PTR [rsp]
  20fb09:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  20fb0d:	48 89 d8             	mov    rax,rbx
  20fb10:	48 83 c4 10          	add    rsp,0x10
  20fb14:	5b                   	pop    rbx
  20fb15:	c3                   	ret    
  20fb16:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  20fb1d:	00 00 00 

000000000020fb20 <Allocator_alignedRealloc>:
    pub fn alignedRealloc(self: *Allocator, comptime T: type, comptime alignment: u29, old_mem: []align(alignment) T, n: usize) ![]align(alignment) T {
  20fb20:	41 56                	push   r14
  20fb22:	53                   	push   rbx
  20fb23:	48 81 ec 88 00 00 00 	sub    rsp,0x88
  20fb2a:	48 89 fb             	mov    rbx,rdi
        if (old_mem.len == 0) {
  20fb2d:	48 8b 42 08          	mov    rax,QWORD PTR [rdx+0x8]
  20fb31:	48 85 c0             	test   rax,rax
  20fb34:	74 54                	je     20fb8a <Allocator_alignedRealloc+0x6a>
        if (n == 0) {
  20fb36:	48 85 c9             	test   rcx,rcx
  20fb39:	0f 84 9b 00 00 00    	je     20fbda <Allocator_alignedRealloc+0xba>
        const old_byte_slice = @sliceToBytes(old_mem);
  20fb3f:	48 8b 12             	mov    rdx,QWORD PTR [rdx]
  20fb42:	48 6b c0 38          	imul   rax,rax,0x38
  20fb46:	48 89 54 24 38       	mov    QWORD PTR [rsp+0x38],rdx
  20fb4b:	48 89 44 24 40       	mov    QWORD PTR [rsp+0x40],rax
  20fb50:	ba 38 00 00 00       	mov    edx,0x38
    return if (@mulWithOverflow(T, a, b, &answer)) error.Overflow else answer;
  20fb55:	48 89 c8             	mov    rax,rcx
  20fb58:	48 f7 e2             	mul    rdx
  20fb5b:	0f 81 c2 00 00 00    	jno    20fc23 <Allocator_alignedRealloc+0x103>
  20fb61:	48 8d 0d c8 74 ff ff 	lea    rcx,[rip+0xffffffffffff74c8]        # 207030 <__unnamed_54>
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  20fb68:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  20fb6c:	0f 84 cc 00 00 00    	je     20fc3e <Allocator_alignedRealloc+0x11e>
  20fb72:	48 8b 05 27 5a ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffff5a27]        # 2055a0 <__unnamed_61+0x10>
  20fb79:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  20fb7d:	c5 f8 10 05 0b 5a ff 	vmovups xmm0,XMMWORD PTR [rip+0xffffffffffff5a0b]        # 205590 <__unnamed_61>
  20fb84:	ff 
  20fb85:	e9 8a 00 00 00       	jmp    20fc14 <Allocator_alignedRealloc+0xf4>
        if (n == 0) {
  20fb8a:	48 85 c9             	test   rcx,rcx
  20fb8d:	0f 84 f8 00 00 00    	je     20fc8b <Allocator_alignedRealloc+0x16b>
  20fb93:	ba 38 00 00 00       	mov    edx,0x38
  20fb98:	48 89 c8             	mov    rax,rcx
  20fb9b:	48 f7 e2             	mul    rdx
  20fb9e:	0f 81 08 01 00 00    	jno    20fcac <Allocator_alignedRealloc+0x18c>
  20fba4:	48 8d 0d 85 74 ff ff 	lea    rcx,[rip+0xffffffffffff7485]        # 207030 <__unnamed_54>
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  20fbab:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  20fbaf:	0f 84 12 01 00 00    	je     20fcc7 <Allocator_alignedRealloc+0x1a7>
  20fbb5:	0f b7 05 da 59 ff ff 	movzx  eax,WORD PTR [rip+0xffffffffffff59da]        # 205596 <__unnamed_61+0x6>
  20fbbc:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  20fbc1:	8b 05 cb 59 ff ff    	mov    eax,DWORD PTR [rip+0xffffffffffff59cb]        # 205592 <__unnamed_61+0x2>
  20fbc7:	89 04 24             	mov    DWORD PTR [rsp],eax
  20fbca:	48 89 e0             	mov    rax,rsp
  20fbcd:	66 b9 10 00          	mov    cx,0x10
  20fbd1:	31 f6                	xor    esi,esi
  20fbd3:	31 d2                	xor    edx,edx
  20fbd5:	e9 a9 01 00 00       	jmp    20fd83 <Allocator_alignedRealloc+0x263>
        const bytes = @sliceToBytes(memory);
  20fbda:	48 6b c0 38          	imul   rax,rax,0x38
        if (bytes.len == 0) return;
  20fbde:	48 85 c0             	test   rax,rax
  20fbe1:	74 1e                	je     20fc01 <Allocator_alignedRealloc+0xe1>
        const bytes = @sliceToBytes(memory);
  20fbe3:	48 8b 0a             	mov    rcx,QWORD PTR [rdx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  20fbe6:	48 8b 56 10          	mov    rdx,QWORD PTR [rsi+0x10]
  20fbea:	48 89 4c 24 08       	mov    QWORD PTR [rsp+0x8],rcx
  20fbef:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  20fbf4:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  20fbf9:	48 89 f7             	mov    rdi,rsi
  20fbfc:	48 89 c6             	mov    rsi,rax
  20fbff:	ff d2                	call   rdx
            return ([*]align(alignment) T)(undefined)[0..0];
  20fc01:	48 8b 05 80 59 ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffff5980]        # 205588 <__unnamed_62+0x10>
  20fc08:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  20fc0c:	c5 f8 10 05 64 59 ff 	vmovups xmm0,XMMWORD PTR [rip+0xffffffffffff5964]        # 205578 <__unnamed_62>
  20fc13:	ff 
  20fc14:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  20fc18:	48 81 c4 88 00 00 00 	add    rsp,0x88
  20fc1f:	5b                   	pop    rbx
  20fc20:	41 5e                	pop    r14
  20fc22:	c3                   	ret    
  20fc23:	48 8d 4c 24 08       	lea    rcx,[rsp+0x8]
  20fc28:	66 c7 44 24 08 00 00 	mov    WORD PTR [rsp+0x8],0x0
  20fc2f:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  20fc34:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  20fc38:	0f 85 34 ff ff ff    	jne    20fb72 <Allocator_alignedRealloc+0x52>
  20fc3e:	4c 8b 71 08          	mov    r14,QWORD PTR [rcx+0x8]
  20fc42:	48 8d 7c 24 58       	lea    rdi,[rsp+0x58]
  20fc47:	48 8d 54 24 38       	lea    rdx,[rsp+0x38]
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  20fc4c:	41 b8 01 00 00 00    	mov    r8d,0x1
  20fc52:	4c 89 f1             	mov    rcx,r14
  20fc55:	ff 56 08             	call   QWORD PTR [rsi+0x8]
  20fc58:	0f b7 44 24 58       	movzx  eax,WORD PTR [rsp+0x58]
  20fc5d:	66 85 c0             	test   ax,ax
  20fc60:	0f 84 97 00 00 00    	je     20fcfd <Allocator_alignedRealloc+0x1dd>
  20fc66:	66 89 03             	mov    WORD PTR [rbx],ax
  20fc69:	48 8b 84 24 80 00 00 	mov    rax,QWORD PTR [rsp+0x80]
  20fc70:	00 
  20fc71:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  20fc75:	c5 f8 10 44 24 72    	vmovups xmm0,XMMWORD PTR [rsp+0x72]
  20fc7b:	c5 f8 11 43 02       	vmovups XMMWORD PTR [rbx+0x2],xmm0
  20fc80:	48 81 c4 88 00 00 00 	add    rsp,0x88
  20fc87:	5b                   	pop    rbx
  20fc88:	41 5e                	pop    r14
  20fc8a:	c3                   	ret    
  20fc8b:	48 89 e0             	mov    rax,rsp
            return ([*]align(alignment) T)(undefined)[0..0];
  20fc8e:	0f b7 0d e9 58 ff ff 	movzx  ecx,WORD PTR [rip+0xffffffffffff58e9]        # 20557e <__unnamed_62+0x6>
  20fc95:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  20fc9a:	8b 0d da 58 ff ff    	mov    ecx,DWORD PTR [rip+0xffffffffffff58da]        # 20557a <__unnamed_62+0x2>
  20fca0:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  20fca3:	31 c9                	xor    ecx,ecx
  20fca5:	31 d2                	xor    edx,edx
  20fca7:	e9 d7 00 00 00       	jmp    20fd83 <Allocator_alignedRealloc+0x263>
  20fcac:	48 8d 4c 24 48       	lea    rcx,[rsp+0x48]
  20fcb1:	66 c7 44 24 48 00 00 	mov    WORD PTR [rsp+0x48],0x0
  20fcb8:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  20fcbd:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  20fcc1:	0f 85 ee fe ff ff    	jne    20fbb5 <Allocator_alignedRealloc+0x95>
  20fcc7:	4c 8b 71 08          	mov    r14,QWORD PTR [rcx+0x8]
  20fccb:	48 8d 7c 24 08       	lea    rdi,[rsp+0x8]
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  20fcd0:	b9 01 00 00 00       	mov    ecx,0x1
  20fcd5:	4c 89 f2             	mov    rdx,r14
  20fcd8:	ff 16                	call   QWORD PTR [rsi]
  20fcda:	0f b7 4c 24 08       	movzx  ecx,WORD PTR [rsp+0x8]
  20fcdf:	66 85 c9             	test   cx,cx
  20fce2:	74 67                	je     20fd4b <Allocator_alignedRealloc+0x22b>
  20fce4:	0f b7 44 24 36       	movzx  eax,WORD PTR [rsp+0x36]
  20fce9:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  20fcee:	48 89 e0             	mov    rax,rsp
  20fcf1:	8b 54 24 32          	mov    edx,DWORD PTR [rsp+0x32]
  20fcf5:	89 14 24             	mov    DWORD PTR [rsp],edx
  20fcf8:	e9 86 00 00 00       	jmp    20fd83 <Allocator_alignedRealloc+0x263>
        assert(byte_slice.len == byte_count);
  20fcfd:	4c 39 74 24 68       	cmp    QWORD PTR [rsp+0x68],r14
    if (!ok) {
  20fd02:	0f 85 9e 00 00 00    	jne    20fda6 <Allocator_alignedRealloc+0x286>
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  20fd08:	49 c1 ee 03          	shr    r14,0x3
  20fd0c:	48 b8 93 24 49 92 24 	movabs rax,0x2492492492492493
  20fd13:	49 92 24 
  20fd16:	4c 89 f2             	mov    rdx,r14
  20fd19:	c4 e2 f3 f6 c0       	mulx   rax,rcx,rax
  20fd1e:	66 c7 03 00 00       	mov    WORD PTR [rbx],0x0
  20fd23:	0f b7 4c 24 2a       	movzx  ecx,WORD PTR [rsp+0x2a]
  20fd28:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  20fd2c:	48 8b 4c 24 60       	mov    rcx,QWORD PTR [rsp+0x60]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  20fd31:	8b 54 24 26          	mov    edx,DWORD PTR [rsp+0x26]
  20fd35:	89 53 02             	mov    DWORD PTR [rbx+0x2],edx
  20fd38:	48 89 4b 08          	mov    QWORD PTR [rbx+0x8],rcx
  20fd3c:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  20fd40:	48 81 c4 88 00 00 00 	add    rsp,0x88
  20fd47:	5b                   	pop    rbx
  20fd48:	41 5e                	pop    r14
  20fd4a:	c3                   	ret    
        assert(byte_slice.len == byte_count);
  20fd4b:	4c 39 74 24 18       	cmp    QWORD PTR [rsp+0x18],r14
  20fd50:	75 54                	jne    20fda6 <Allocator_alignedRealloc+0x286>
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  20fd52:	48 8b 74 24 10       	mov    rsi,QWORD PTR [rsp+0x10]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  20fd57:	49 c1 ee 03          	shr    r14,0x3
  20fd5b:	48 b8 93 24 49 92 24 	movabs rax,0x2492492492492493
  20fd62:	49 92 24 
  20fd65:	4c 89 f2             	mov    rdx,r14
  20fd68:	c4 e2 fb f6 d0       	mulx   rdx,rax,rax
  20fd6d:	48 89 e0             	mov    rax,rsp
  20fd70:	8b 4c 24 2c          	mov    ecx,DWORD PTR [rsp+0x2c]
  20fd74:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  20fd77:	0f b7 4c 24 30       	movzx  ecx,WORD PTR [rsp+0x30]
  20fd7c:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  20fd81:	31 c9                	xor    ecx,ecx
            return self.alignedAlloc(T, alignment, n);
  20fd83:	66 89 0b             	mov    WORD PTR [rbx],cx
  20fd86:	0f b7 48 04          	movzx  ecx,WORD PTR [rax+0x4]
  20fd8a:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  20fd8e:	8b 00                	mov    eax,DWORD PTR [rax]
  20fd90:	89 43 02             	mov    DWORD PTR [rbx+0x2],eax
  20fd93:	48 89 73 08          	mov    QWORD PTR [rbx+0x8],rsi
  20fd97:	48 89 53 10          	mov    QWORD PTR [rbx+0x10],rdx
  20fd9b:	48 81 c4 88 00 00 00 	add    rsp,0x88
  20fda2:	5b                   	pop    rbx
  20fda3:	41 5e                	pop    r14
  20fda5:	c3                   	ret    
            @panic("assertion failure");
  20fda6:	e8 75 8f ff ff       	call   208d20 <panic>
  20fdab:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

000000000020fdb0 <Allocator_alignedRealloc.38>:
    pub fn alignedRealloc(self: *Allocator, comptime T: type, comptime alignment: u29, old_mem: []align(alignment) T, n: usize) ![]align(alignment) T {
  20fdb0:	41 56                	push   r14
  20fdb2:	53                   	push   rbx
  20fdb3:	48 81 ec 88 00 00 00 	sub    rsp,0x88
  20fdba:	48 89 fb             	mov    rbx,rdi
        if (old_mem.len == 0) {
  20fdbd:	48 8b 42 08          	mov    rax,QWORD PTR [rdx+0x8]
  20fdc1:	48 85 c0             	test   rax,rax
  20fdc4:	74 5e                	je     20fe24 <Allocator_alignedRealloc.38+0x74>
        if (n == 0) {
  20fdc6:	48 85 c9             	test   rcx,rcx
  20fdc9:	0f 84 a6 00 00 00    	je     20fe75 <Allocator_alignedRealloc.38+0xc5>
        const old_byte_slice = @sliceToBytes(old_mem);
  20fdcf:	48 8b 12             	mov    rdx,QWORD PTR [rdx]
  20fdd2:	48 c1 e0 04          	shl    rax,0x4
  20fdd6:	48 89 54 24 38       	mov    QWORD PTR [rsp+0x38],rdx
  20fddb:	48 89 44 24 40       	mov    QWORD PTR [rsp+0x40],rax
  20fde0:	ba 10 00 00 00       	mov    edx,0x10
  20fde5:	48 89 c8             	mov    rax,rcx
  20fde8:	48 f7 e2             	mul    rdx
  20fdeb:	0f 81 ca 00 00 00    	jno    20febb <Allocator_alignedRealloc.38+0x10b>
  20fdf1:	48 8d 0d 38 72 ff ff 	lea    rcx,[rip+0xffffffffffff7238]        # 207030 <__unnamed_54>
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  20fdf8:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  20fdfc:	0f 84 d4 00 00 00    	je     20fed6 <Allocator_alignedRealloc.38+0x126>
  20fe02:	48 8b 05 c7 57 ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffff57c7]        # 2055d0 <__unnamed_63+0x10>
  20fe09:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  20fe0d:	c5 f8 10 05 ab 57 ff 	vmovups xmm0,XMMWORD PTR [rip+0xffffffffffff57ab]        # 2055c0 <__unnamed_63>
  20fe14:	ff 
  20fe15:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  20fe19:	48 81 c4 88 00 00 00 	add    rsp,0x88
  20fe20:	5b                   	pop    rbx
  20fe21:	41 5e                	pop    r14
  20fe23:	c3                   	ret    
        if (n == 0) {
  20fe24:	48 85 c9             	test   rcx,rcx
  20fe27:	0f 84 f6 00 00 00    	je     20ff23 <Allocator_alignedRealloc.38+0x173>
  20fe2d:	ba 10 00 00 00       	mov    edx,0x10
  20fe32:	48 89 c8             	mov    rax,rcx
  20fe35:	48 f7 e2             	mul    rdx
  20fe38:	0f 81 07 01 00 00    	jno    20ff45 <Allocator_alignedRealloc.38+0x195>
  20fe3e:	48 8d 0d eb 71 ff ff 	lea    rcx,[rip+0xffffffffffff71eb]        # 207030 <__unnamed_54>
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  20fe45:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  20fe49:	0f 84 11 01 00 00    	je     20ff60 <Allocator_alignedRealloc.38+0x1b0>
  20fe4f:	0f b7 05 70 57 ff ff 	movzx  eax,WORD PTR [rip+0xffffffffffff5770]        # 2055c6 <__unnamed_63+0x6>
  20fe56:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  20fe5b:	8b 05 61 57 ff ff    	mov    eax,DWORD PTR [rip+0xffffffffffff5761]        # 2055c2 <__unnamed_63+0x2>
  20fe61:	89 04 24             	mov    DWORD PTR [rsp],eax
  20fe64:	48 89 e0             	mov    rax,rsp
  20fe67:	66 b9 10 00          	mov    cx,0x10
  20fe6b:	31 d2                	xor    edx,edx
  20fe6d:	45 31 f6             	xor    r14d,r14d
  20fe70:	e9 6f 01 00 00       	jmp    20ffe4 <Allocator_alignedRealloc.38+0x234>
        const bytes = @sliceToBytes(memory);
  20fe75:	48 c1 e0 04          	shl    rax,0x4
        if (bytes.len == 0) return;
  20fe79:	74 1e                	je     20fe99 <Allocator_alignedRealloc.38+0xe9>
        const bytes = @sliceToBytes(memory);
  20fe7b:	48 8b 0a             	mov    rcx,QWORD PTR [rdx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  20fe7e:	48 8b 56 10          	mov    rdx,QWORD PTR [rsi+0x10]
  20fe82:	48 89 4c 24 08       	mov    QWORD PTR [rsp+0x8],rcx
  20fe87:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  20fe8c:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  20fe91:	48 89 f7             	mov    rdi,rsi
  20fe94:	48 89 c6             	mov    rsi,rax
  20fe97:	ff d2                	call   rdx
            return ([*]align(alignment) T)(undefined)[0..0];
  20fe99:	48 8b 05 18 57 ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffff5718]        # 2055b8 <__unnamed_64+0x10>
  20fea0:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  20fea4:	c5 f8 10 05 fc 56 ff 	vmovups xmm0,XMMWORD PTR [rip+0xffffffffffff56fc]        # 2055a8 <__unnamed_64>
  20feab:	ff 
  20feac:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  20feb0:	48 81 c4 88 00 00 00 	add    rsp,0x88
  20feb7:	5b                   	pop    rbx
  20feb8:	41 5e                	pop    r14
  20feba:	c3                   	ret    
  20febb:	48 8d 4c 24 08       	lea    rcx,[rsp+0x8]
  20fec0:	66 c7 44 24 08 00 00 	mov    WORD PTR [rsp+0x8],0x0
  20fec7:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  20fecc:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  20fed0:	0f 85 2c ff ff ff    	jne    20fe02 <Allocator_alignedRealloc.38+0x52>
  20fed6:	4c 8b 71 08          	mov    r14,QWORD PTR [rcx+0x8]
  20feda:	48 8d 7c 24 58       	lea    rdi,[rsp+0x58]
  20fedf:	48 8d 54 24 38       	lea    rdx,[rsp+0x38]
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  20fee4:	41 b8 08 00 00 00    	mov    r8d,0x8
  20feea:	4c 89 f1             	mov    rcx,r14
  20feed:	ff 56 08             	call   QWORD PTR [rsi+0x8]
  20fef0:	0f b7 44 24 58       	movzx  eax,WORD PTR [rsp+0x58]
  20fef5:	66 85 c0             	test   ax,ax
  20fef8:	0f 84 95 00 00 00    	je     20ff93 <Allocator_alignedRealloc.38+0x1e3>
  20fefe:	66 89 03             	mov    WORD PTR [rbx],ax
  20ff01:	48 8b 84 24 80 00 00 	mov    rax,QWORD PTR [rsp+0x80]
  20ff08:	00 
  20ff09:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  20ff0d:	c5 f8 10 44 24 72    	vmovups xmm0,XMMWORD PTR [rsp+0x72]
  20ff13:	c5 f8 11 43 02       	vmovups XMMWORD PTR [rbx+0x2],xmm0
  20ff18:	48 81 c4 88 00 00 00 	add    rsp,0x88
  20ff1f:	5b                   	pop    rbx
  20ff20:	41 5e                	pop    r14
  20ff22:	c3                   	ret    
  20ff23:	48 89 e0             	mov    rax,rsp
            return ([*]align(alignment) T)(undefined)[0..0];
  20ff26:	0f b7 0d 81 56 ff ff 	movzx  ecx,WORD PTR [rip+0xffffffffffff5681]        # 2055ae <__unnamed_64+0x6>
  20ff2d:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  20ff32:	8b 0d 72 56 ff ff    	mov    ecx,DWORD PTR [rip+0xffffffffffff5672]        # 2055aa <__unnamed_64+0x2>
  20ff38:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  20ff3b:	31 c9                	xor    ecx,ecx
  20ff3d:	45 31 f6             	xor    r14d,r14d
  20ff40:	e9 9f 00 00 00       	jmp    20ffe4 <Allocator_alignedRealloc.38+0x234>
  20ff45:	48 8d 4c 24 48       	lea    rcx,[rsp+0x48]
  20ff4a:	66 c7 44 24 48 00 00 	mov    WORD PTR [rsp+0x48],0x0
  20ff51:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  20ff56:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  20ff5a:	0f 85 ef fe ff ff    	jne    20fe4f <Allocator_alignedRealloc.38+0x9f>
  20ff60:	4c 8b 71 08          	mov    r14,QWORD PTR [rcx+0x8]
  20ff64:	48 8d 7c 24 08       	lea    rdi,[rsp+0x8]
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  20ff69:	b9 08 00 00 00       	mov    ecx,0x8
  20ff6e:	4c 89 f2             	mov    rdx,r14
  20ff71:	ff 16                	call   QWORD PTR [rsi]
  20ff73:	0f b7 4c 24 08       	movzx  ecx,WORD PTR [rsp+0x8]
  20ff78:	66 85 c9             	test   cx,cx
  20ff7b:	74 41                	je     20ffbe <Allocator_alignedRealloc.38+0x20e>
  20ff7d:	0f b7 44 24 36       	movzx  eax,WORD PTR [rsp+0x36]
  20ff82:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  20ff87:	48 89 e0             	mov    rax,rsp
  20ff8a:	8b 54 24 32          	mov    edx,DWORD PTR [rsp+0x32]
  20ff8e:	89 14 24             	mov    DWORD PTR [rsp],edx
  20ff91:	eb 51                	jmp    20ffe4 <Allocator_alignedRealloc.38+0x234>
        assert(byte_slice.len == byte_count);
  20ff93:	4c 39 74 24 68       	cmp    QWORD PTR [rsp+0x68],r14
    if (!ok) {
  20ff98:	75 6d                	jne    210007 <Allocator_alignedRealloc.38+0x257>
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  20ff9a:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  20ff9f:	66 c7 03 00 00       	mov    WORD PTR [rbx],0x0
  20ffa4:	0f b7 4c 24 2a       	movzx  ecx,WORD PTR [rsp+0x2a]
  20ffa9:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  20ffad:	49 c1 ee 04          	shr    r14,0x4
  20ffb1:	8b 4c 24 26          	mov    ecx,DWORD PTR [rsp+0x26]
  20ffb5:	89 4b 02             	mov    DWORD PTR [rbx+0x2],ecx
  20ffb8:	48 89 43 08          	mov    QWORD PTR [rbx+0x8],rax
  20ffbc:	eb 3a                	jmp    20fff8 <Allocator_alignedRealloc.38+0x248>
        assert(byte_slice.len == byte_count);
  20ffbe:	4c 39 74 24 18       	cmp    QWORD PTR [rsp+0x18],r14
  20ffc3:	75 42                	jne    210007 <Allocator_alignedRealloc.38+0x257>
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  20ffc5:	48 8b 54 24 10       	mov    rdx,QWORD PTR [rsp+0x10]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  20ffca:	49 c1 ee 04          	shr    r14,0x4
  20ffce:	48 89 e0             	mov    rax,rsp
  20ffd1:	8b 4c 24 2c          	mov    ecx,DWORD PTR [rsp+0x2c]
  20ffd5:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  20ffd8:	0f b7 4c 24 30       	movzx  ecx,WORD PTR [rsp+0x30]
  20ffdd:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  20ffe2:	31 c9                	xor    ecx,ecx
            return self.alignedAlloc(T, alignment, n);
  20ffe4:	66 89 0b             	mov    WORD PTR [rbx],cx
  20ffe7:	0f b7 48 04          	movzx  ecx,WORD PTR [rax+0x4]
  20ffeb:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  20ffef:	8b 00                	mov    eax,DWORD PTR [rax]
  20fff1:	89 43 02             	mov    DWORD PTR [rbx+0x2],eax
  20fff4:	48 89 53 08          	mov    QWORD PTR [rbx+0x8],rdx
  20fff8:	4c 89 73 10          	mov    QWORD PTR [rbx+0x10],r14
  20fffc:	48 81 c4 88 00 00 00 	add    rsp,0x88
  210003:	5b                   	pop    rbx
  210004:	41 5e                	pop    r14
  210006:	c3                   	ret    
            @panic("assertion failure");
  210007:	e8 14 8d ff ff       	call   208d20 <panic>
  21000c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

0000000000210010 <Allocator_alignedRealloc.41>:
    pub fn alignedRealloc(self: *Allocator, comptime T: type, comptime alignment: u29, old_mem: []align(alignment) T, n: usize) ![]align(alignment) T {
  210010:	41 56                	push   r14
  210012:	53                   	push   rbx
  210013:	48 81 ec 88 00 00 00 	sub    rsp,0x88
  21001a:	48 89 fb             	mov    rbx,rdi
        if (old_mem.len == 0) {
  21001d:	48 8b 42 08          	mov    rax,QWORD PTR [rdx+0x8]
  210021:	48 85 c0             	test   rax,rax
  210024:	74 62                	je     210088 <Allocator_alignedRealloc.41+0x78>
        if (n == 0) {
  210026:	48 85 c9             	test   rcx,rcx
  210029:	0f 84 a9 00 00 00    	je     2100d8 <Allocator_alignedRealloc.41+0xc8>
        const old_byte_slice = @sliceToBytes(old_mem);
  21002f:	48 8b 12             	mov    rdx,QWORD PTR [rdx]
  210032:	48 c1 e0 03          	shl    rax,0x3
  210036:	48 8d 04 80          	lea    rax,[rax+rax*4]
  21003a:	48 89 54 24 38       	mov    QWORD PTR [rsp+0x38],rdx
  21003f:	48 89 44 24 40       	mov    QWORD PTR [rsp+0x40],rax
  210044:	ba 28 00 00 00       	mov    edx,0x28
  210049:	48 89 c8             	mov    rax,rcx
  21004c:	48 f7 e2             	mul    rdx
  21004f:	0f 81 d0 00 00 00    	jno    210125 <Allocator_alignedRealloc.41+0x115>
  210055:	48 8d 0d d4 6f ff ff 	lea    rcx,[rip+0xffffffffffff6fd4]        # 207030 <__unnamed_54>
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  21005c:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  210060:	0f 84 da 00 00 00    	je     210140 <Allocator_alignedRealloc.41+0x130>
  210066:	48 8b 05 93 55 ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffff5593]        # 205600 <__unnamed_65+0x10>
  21006d:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  210071:	c5 f8 10 05 77 55 ff 	vmovups xmm0,XMMWORD PTR [rip+0xffffffffffff5577]        # 2055f0 <__unnamed_65>
  210078:	ff 
  210079:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  21007d:	48 81 c4 88 00 00 00 	add    rsp,0x88
  210084:	5b                   	pop    rbx
  210085:	41 5e                	pop    r14
  210087:	c3                   	ret    
        if (n == 0) {
  210088:	48 85 c9             	test   rcx,rcx
  21008b:	0f 84 fc 00 00 00    	je     21018d <Allocator_alignedRealloc.41+0x17d>
  210091:	ba 28 00 00 00       	mov    edx,0x28
  210096:	48 89 c8             	mov    rax,rcx
  210099:	48 f7 e2             	mul    rdx
  21009c:	0f 81 0c 01 00 00    	jno    2101ae <Allocator_alignedRealloc.41+0x19e>
  2100a2:	48 8d 0d 87 6f ff ff 	lea    rcx,[rip+0xffffffffffff6f87]        # 207030 <__unnamed_54>
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  2100a9:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  2100ad:	0f 84 16 01 00 00    	je     2101c9 <Allocator_alignedRealloc.41+0x1b9>
  2100b3:	0f b7 05 3c 55 ff ff 	movzx  eax,WORD PTR [rip+0xffffffffffff553c]        # 2055f6 <__unnamed_65+0x6>
  2100ba:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  2100bf:	8b 05 2d 55 ff ff    	mov    eax,DWORD PTR [rip+0xffffffffffff552d]        # 2055f2 <__unnamed_65+0x2>
  2100c5:	89 04 24             	mov    DWORD PTR [rsp],eax
  2100c8:	48 89 e0             	mov    rax,rsp
  2100cb:	66 b9 10 00          	mov    cx,0x10
  2100cf:	31 f6                	xor    esi,esi
  2100d1:	31 d2                	xor    edx,edx
  2100d3:	e9 9d 01 00 00       	jmp    210275 <Allocator_alignedRealloc.41+0x265>
        const bytes = @sliceToBytes(memory);
  2100d8:	48 c1 e0 03          	shl    rax,0x3
  2100dc:	48 8d 04 80          	lea    rax,[rax+rax*4]
        if (bytes.len == 0) return;
  2100e0:	48 85 c0             	test   rax,rax
  2100e3:	74 1e                	je     210103 <Allocator_alignedRealloc.41+0xf3>
        const bytes = @sliceToBytes(memory);
  2100e5:	48 8b 0a             	mov    rcx,QWORD PTR [rdx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  2100e8:	48 8b 56 10          	mov    rdx,QWORD PTR [rsi+0x10]
  2100ec:	48 89 4c 24 08       	mov    QWORD PTR [rsp+0x8],rcx
  2100f1:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  2100f6:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  2100fb:	48 89 f7             	mov    rdi,rsi
  2100fe:	48 89 c6             	mov    rsi,rax
  210101:	ff d2                	call   rdx
            return ([*]align(alignment) T)(undefined)[0..0];
  210103:	48 8b 05 de 54 ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffff54de]        # 2055e8 <__unnamed_66+0x10>
  21010a:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  21010e:	c5 f8 10 05 c2 54 ff 	vmovups xmm0,XMMWORD PTR [rip+0xffffffffffff54c2]        # 2055d8 <__unnamed_66>
  210115:	ff 
  210116:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  21011a:	48 81 c4 88 00 00 00 	add    rsp,0x88
  210121:	5b                   	pop    rbx
  210122:	41 5e                	pop    r14
  210124:	c3                   	ret    
  210125:	48 8d 4c 24 08       	lea    rcx,[rsp+0x8]
  21012a:	66 c7 44 24 08 00 00 	mov    WORD PTR [rsp+0x8],0x0
  210131:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  210136:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  21013a:	0f 85 26 ff ff ff    	jne    210066 <Allocator_alignedRealloc.41+0x56>
  210140:	4c 8b 71 08          	mov    r14,QWORD PTR [rcx+0x8]
  210144:	48 8d 7c 24 58       	lea    rdi,[rsp+0x58]
  210149:	48 8d 54 24 38       	lea    rdx,[rsp+0x38]
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  21014e:	41 b8 08 00 00 00    	mov    r8d,0x8
  210154:	4c 89 f1             	mov    rcx,r14
  210157:	ff 56 08             	call   QWORD PTR [rsi+0x8]
  21015a:	0f b7 44 24 58       	movzx  eax,WORD PTR [rsp+0x58]
  21015f:	66 85 c0             	test   ax,ax
  210162:	0f 84 94 00 00 00    	je     2101fc <Allocator_alignedRealloc.41+0x1ec>
  210168:	66 89 03             	mov    WORD PTR [rbx],ax
  21016b:	48 8b 84 24 80 00 00 	mov    rax,QWORD PTR [rsp+0x80]
  210172:	00 
  210173:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  210177:	c5 f8 10 44 24 72    	vmovups xmm0,XMMWORD PTR [rsp+0x72]
  21017d:	c5 f8 11 43 02       	vmovups XMMWORD PTR [rbx+0x2],xmm0
  210182:	48 81 c4 88 00 00 00 	add    rsp,0x88
  210189:	5b                   	pop    rbx
  21018a:	41 5e                	pop    r14
  21018c:	c3                   	ret    
  21018d:	48 89 e0             	mov    rax,rsp
            return ([*]align(alignment) T)(undefined)[0..0];
  210190:	0f b7 0d 47 54 ff ff 	movzx  ecx,WORD PTR [rip+0xffffffffffff5447]        # 2055de <__unnamed_66+0x6>
  210197:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  21019c:	8b 0d 38 54 ff ff    	mov    ecx,DWORD PTR [rip+0xffffffffffff5438]        # 2055da <__unnamed_66+0x2>
  2101a2:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  2101a5:	31 c9                	xor    ecx,ecx
  2101a7:	31 d2                	xor    edx,edx
  2101a9:	e9 c7 00 00 00       	jmp    210275 <Allocator_alignedRealloc.41+0x265>
  2101ae:	48 8d 4c 24 48       	lea    rcx,[rsp+0x48]
  2101b3:	66 c7 44 24 48 00 00 	mov    WORD PTR [rsp+0x48],0x0
  2101ba:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  2101bf:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  2101c3:	0f 85 ea fe ff ff    	jne    2100b3 <Allocator_alignedRealloc.41+0xa3>
  2101c9:	4c 8b 71 08          	mov    r14,QWORD PTR [rcx+0x8]
  2101cd:	48 8d 7c 24 08       	lea    rdi,[rsp+0x8]
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  2101d2:	b9 08 00 00 00       	mov    ecx,0x8
  2101d7:	4c 89 f2             	mov    rdx,r14
  2101da:	ff 16                	call   QWORD PTR [rsi]
  2101dc:	0f b7 4c 24 08       	movzx  ecx,WORD PTR [rsp+0x8]
  2101e1:	66 85 c9             	test   cx,cx
  2101e4:	74 57                	je     21023d <Allocator_alignedRealloc.41+0x22d>
  2101e6:	0f b7 44 24 36       	movzx  eax,WORD PTR [rsp+0x36]
  2101eb:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  2101f0:	48 89 e0             	mov    rax,rsp
  2101f3:	8b 54 24 32          	mov    edx,DWORD PTR [rsp+0x32]
  2101f7:	89 14 24             	mov    DWORD PTR [rsp],edx
  2101fa:	eb 79                	jmp    210275 <Allocator_alignedRealloc.41+0x265>
        assert(byte_slice.len == byte_count);
  2101fc:	4c 39 74 24 68       	cmp    QWORD PTR [rsp+0x68],r14
    if (!ok) {
  210201:	0f 85 91 00 00 00    	jne    210298 <Allocator_alignedRealloc.41+0x288>
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  210207:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  21020c:	48 b9 cd cc cc cc cc 	movabs rcx,0xcccccccccccccccd
  210213:	cc cc cc 
  210216:	4c 89 f2             	mov    rdx,r14
  210219:	c4 e2 f3 f6 d1       	mulx   rdx,rcx,rcx
  21021e:	66 c7 03 00 00       	mov    WORD PTR [rbx],0x0
  210223:	0f b7 4c 24 2a       	movzx  ecx,WORD PTR [rsp+0x2a]
  210228:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  21022c:	48 c1 ea 05          	shr    rdx,0x5
  210230:	8b 4c 24 26          	mov    ecx,DWORD PTR [rsp+0x26]
  210234:	89 4b 02             	mov    DWORD PTR [rbx+0x2],ecx
  210237:	48 89 43 08          	mov    QWORD PTR [rbx+0x8],rax
  21023b:	eb 4c                	jmp    210289 <Allocator_alignedRealloc.41+0x279>
        assert(byte_slice.len == byte_count);
  21023d:	4c 39 74 24 18       	cmp    QWORD PTR [rsp+0x18],r14
  210242:	75 54                	jne    210298 <Allocator_alignedRealloc.41+0x288>
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  210244:	48 8b 74 24 10       	mov    rsi,QWORD PTR [rsp+0x10]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  210249:	48 b8 cd cc cc cc cc 	movabs rax,0xcccccccccccccccd
  210250:	cc cc cc 
  210253:	4c 89 f2             	mov    rdx,r14
  210256:	c4 e2 fb f6 d0       	mulx   rdx,rax,rax
  21025b:	48 c1 ea 05          	shr    rdx,0x5
  21025f:	48 89 e0             	mov    rax,rsp
  210262:	8b 4c 24 2c          	mov    ecx,DWORD PTR [rsp+0x2c]
  210266:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  210269:	0f b7 4c 24 30       	movzx  ecx,WORD PTR [rsp+0x30]
  21026e:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  210273:	31 c9                	xor    ecx,ecx
            return self.alignedAlloc(T, alignment, n);
  210275:	66 89 0b             	mov    WORD PTR [rbx],cx
  210278:	0f b7 48 04          	movzx  ecx,WORD PTR [rax+0x4]
  21027c:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  210280:	8b 00                	mov    eax,DWORD PTR [rax]
  210282:	89 43 02             	mov    DWORD PTR [rbx+0x2],eax
  210285:	48 89 73 08          	mov    QWORD PTR [rbx+0x8],rsi
  210289:	48 89 53 10          	mov    QWORD PTR [rbx+0x10],rdx
  21028d:	48 81 c4 88 00 00 00 	add    rsp,0x88
  210294:	5b                   	pop    rbx
  210295:	41 5e                	pop    r14
  210297:	c3                   	ret    
            @panic("assertion failure");
  210298:	e8 83 8a ff ff       	call   208d20 <panic>
  21029d:	0f 1f 00             	nop    DWORD PTR [rax]

00000000002102a0 <parseFormValue>:
fn parseFormValue(allocator: *mem.Allocator, in_stream: var, form_id: u64, is_64: bool) ParseFormValueError!FormValue {
  2102a0:	55                   	push   rbp
  2102a1:	41 57                	push   r15
  2102a3:	41 56                	push   r14
  2102a5:	41 55                	push   r13
  2102a7:	41 54                	push   r12
  2102a9:	53                   	push   rbx
  2102aa:	48 81 ec 08 07 00 00 	sub    rsp,0x708
  2102b1:	44 89 c5             	mov    ebp,r8d
  2102b4:	48 89 cb             	mov    rbx,rcx
  2102b7:	49 89 d4             	mov    r12,rdx
  2102ba:	49 89 f7             	mov    r15,rsi
  2102bd:	49 89 fe             	mov    r14,rdi
  2102c0:	48 8d 05 a9 53 ff ff 	lea    rax,[rip+0xffffffffffff53a9]        # 205670 <__unnamed_67>
    return switch (form_id) {
  2102c7:	48 8d 4b ff          	lea    rcx,[rbx-0x1]
  2102cb:	48 83 f9 1f          	cmp    rcx,0x1f
  2102cf:	0f 87 d1 19 00 00    	ja     211ca6 <parseFormValue+0x1a06>
  2102d5:	48 8d 15 c8 05 ff ff 	lea    rdx,[rip+0xffffffffffff05c8]        # 2008a4 <app_mask+0x624>
  2102dc:	48 63 0c 8a          	movsxd rcx,DWORD PTR [rdx+rcx*4]
  2102e0:	48 01 d1             	add    rcx,rdx
  2102e3:	ff e1                	jmp    rcx
  2102e5:	4c 89 bc 24 d0 00 00 	mov    QWORD PTR [rsp+0xd0],r15
  2102ec:	00 
  2102ed:	4c 89 74 24 68       	mov    QWORD PTR [rsp+0x68],r14
  2102f2:	4c 8d b4 24 b0 00 00 	lea    r14,[rsp+0xb0]
  2102f9:	00 
            try self.readNoEof(result[0..]);
  2102fa:	4c 89 74 24 18       	mov    QWORD PTR [rsp+0x18],r14
  2102ff:	48 c7 44 24 20 01 00 	mov    QWORD PTR [rsp+0x20],0x1
  210306:	00 00 
  210308:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  21030d:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  210312:	4c 89 e6             	mov    rsi,r12
  210315:	41 ff 14 24          	call   QWORD PTR [r12]
  210319:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  21031e:	66 85 c0             	test   ax,ax
  210321:	0f 84 f2 0b 00 00    	je     210f19 <parseFormValue+0xc79>
  210327:	48 8b 4c 24 68       	mov    rcx,QWORD PTR [rsp+0x68]
            const block_len = try readULeb128(in_stream);
  21032c:	66 89 01             	mov    WORD PTR [rcx],ax
  21032f:	48 8b 84 24 b4 06 00 	mov    rax,QWORD PTR [rsp+0x6b4]
  210336:	00 
  210337:	48 89 41 20          	mov    QWORD PTR [rcx+0x20],rax
  21033b:	c5 fc 10 84 24 96 06 	vmovups ymm0,YMMWORD PTR [rsp+0x696]
  210342:	00 00 
  210344:	c5 fc 11 41 02       	vmovups YMMWORD PTR [rcx+0x2],ymm0
  210349:	e9 69 19 00 00       	jmp    211cb7 <parseFormValue+0x1a17>
  21034e:	48 8d 44 24 78       	lea    rax,[rsp+0x78]
            try self.readNoEof(bytes[0..]);
  210353:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  210358:	48 c7 44 24 20 08 00 	mov    QWORD PTR [rsp+0x20],0x8
  21035f:	00 00 
  210361:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  210366:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  21036b:	4c 89 e6             	mov    rsi,r12
  21036e:	41 ff 14 24          	call   QWORD PTR [r12]
  210372:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  210377:	66 85 c0             	test   ax,ax
  21037a:	75 14                	jne    210390 <parseFormValue+0xf0>
  21037c:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  210381:	66 b8 1e 00          	mov    ax,0x1e
            if (amt_read < buf.len) return error.EndOfStream;
  210385:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  21038a:	0f 83 ce 12 00 00    	jae    21165e <parseFormValue+0x13be>
        DW.FORM_addr => FormValue{ .Address = try parseFormValueTargetAddrSize(in_stream) },
  210390:	66 41 89 06          	mov    WORD PTR [r14],ax
  210394:	48 8b 84 24 00 07 00 	mov    rax,QWORD PTR [rsp+0x700]
  21039b:	00 
  21039c:	49 89 46 20          	mov    QWORD PTR [r14+0x20],rax
  2103a0:	c5 fc 10 84 24 e2 06 	vmovups ymm0,YMMWORD PTR [rsp+0x6e2]
  2103a7:	00 00 
  2103a9:	e9 0b 0d 00 00       	jmp    2110b9 <parseFormValue+0xe19>
  2103ae:	48 8d 44 24 78       	lea    rax,[rsp+0x78]
            const input_slice = input_buf[0..size];
  2103b3:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  2103b8:	48 c7 44 24 20 02 00 	mov    QWORD PTR [rsp+0x20],0x2
  2103bf:	00 00 
  2103c1:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  2103c6:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  2103cb:	4c 89 e6             	mov    rsi,r12
  2103ce:	41 ff 14 24          	call   QWORD PTR [r12]
  2103d2:	0f b7 4c 24 40       	movzx  ecx,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  2103d7:	66 85 c9             	test   cx,cx
  2103da:	75 14                	jne    2103f0 <parseFormValue+0x150>
            if (amt_read < buf.len) return error.EndOfStream;
  2103dc:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
  2103e1:	66 b9 1e 00          	mov    cx,0x1e
  2103e5:	48 39 44 24 48       	cmp    QWORD PTR [rsp+0x48],rax
  2103ea:	0f 83 d8 12 00 00    	jae    2116c8 <parseFormValue+0x1428>
    const block_len = try in_stream.readVarInt(builtin.Endian.Little, usize, size);
  2103f0:	66 89 8c 24 90 02 00 	mov    WORD PTR [rsp+0x290],cx
  2103f7:	00 
  2103f8:	8b 44 24 3a          	mov    eax,DWORD PTR [rsp+0x3a]
  2103fc:	89 84 24 92 02 00 00 	mov    DWORD PTR [rsp+0x292],eax
  210403:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  210408:	66 89 84 24 96 02 00 	mov    WORD PTR [rsp+0x296],ax
  21040f:	00 
  210410:	8b 44 24 11          	mov    eax,DWORD PTR [rsp+0x11]
  210414:	89 84 24 a9 02 00 00 	mov    DWORD PTR [rsp+0x2a9],eax
  21041b:	0f b7 44 24 15       	movzx  eax,WORD PTR [rsp+0x15]
  210420:	66 89 84 24 ad 02 00 	mov    WORD PTR [rsp+0x2ad],ax
  210427:	00 
  210428:	8a 44 24 17          	mov    al,BYTE PTR [rsp+0x17]
  21042c:	88 84 24 af 02 00 00 	mov    BYTE PTR [rsp+0x2af],al
  210433:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  210437:	89 84 24 b1 02 00 00 	mov    DWORD PTR [rsp+0x2b1],eax
  21043e:	0f b7 44 24 0e       	movzx  eax,WORD PTR [rsp+0xe]
  210443:	66 89 84 24 b5 02 00 	mov    WORD PTR [rsp+0x2b5],ax
  21044a:	00 
  21044b:	8a 44 24 10          	mov    al,BYTE PTR [rsp+0x10]
  21044f:	88 84 24 b7 02 00 00 	mov    BYTE PTR [rsp+0x2b7],al
  210456:	48 8d 84 24 90 02 00 	lea    rax,[rsp+0x290]
  21045d:	00 
  21045e:	e9 43 18 00 00       	jmp    211ca6 <parseFormValue+0x1a06>
  210463:	48 8d 44 24 78       	lea    rax,[rsp+0x78]
            const input_slice = input_buf[0..size];
  210468:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  21046d:	48 c7 44 24 20 04 00 	mov    QWORD PTR [rsp+0x20],0x4
  210474:	00 00 
  210476:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  21047b:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  210480:	4c 89 e6             	mov    rsi,r12
  210483:	41 ff 14 24          	call   QWORD PTR [r12]
  210487:	0f b7 4c 24 40       	movzx  ecx,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  21048c:	66 85 c9             	test   cx,cx
  21048f:	75 14                	jne    2104a5 <parseFormValue+0x205>
            if (amt_read < buf.len) return error.EndOfStream;
  210491:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
  210496:	66 b9 1e 00          	mov    cx,0x1e
  21049a:	48 39 44 24 48       	cmp    QWORD PTR [rsp+0x48],rax
  21049f:	0f 83 44 12 00 00    	jae    2116e9 <parseFormValue+0x1449>
  2104a5:	66 89 8c 24 68 02 00 	mov    WORD PTR [rsp+0x268],cx
  2104ac:	00 
  2104ad:	8b 44 24 3a          	mov    eax,DWORD PTR [rsp+0x3a]
  2104b1:	89 84 24 6a 02 00 00 	mov    DWORD PTR [rsp+0x26a],eax
  2104b8:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  2104bd:	66 89 84 24 6e 02 00 	mov    WORD PTR [rsp+0x26e],ax
  2104c4:	00 
  2104c5:	8b 44 24 11          	mov    eax,DWORD PTR [rsp+0x11]
  2104c9:	89 84 24 81 02 00 00 	mov    DWORD PTR [rsp+0x281],eax
  2104d0:	0f b7 44 24 15       	movzx  eax,WORD PTR [rsp+0x15]
  2104d5:	66 89 84 24 85 02 00 	mov    WORD PTR [rsp+0x285],ax
  2104dc:	00 
  2104dd:	8a 44 24 17          	mov    al,BYTE PTR [rsp+0x17]
  2104e1:	88 84 24 87 02 00 00 	mov    BYTE PTR [rsp+0x287],al
  2104e8:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  2104ec:	89 84 24 89 02 00 00 	mov    DWORD PTR [rsp+0x289],eax
  2104f3:	0f b7 44 24 0e       	movzx  eax,WORD PTR [rsp+0xe]
  2104f8:	66 89 84 24 8d 02 00 	mov    WORD PTR [rsp+0x28d],ax
  2104ff:	00 
  210500:	8a 44 24 10          	mov    al,BYTE PTR [rsp+0x10]
  210504:	88 84 24 8f 02 00 00 	mov    BYTE PTR [rsp+0x28f],al
  21050b:	48 8d 84 24 68 02 00 	lea    rax,[rsp+0x268]
  210512:	00 
  210513:	e9 8e 17 00 00       	jmp    211ca6 <parseFormValue+0x1a06>
  210518:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
            .payload = try readAllocBytes(allocator, in_stream, size),
  21051d:	b9 02 00 00 00       	mov    ecx,0x2
  210522:	4c 89 fe             	mov    rsi,r15
  210525:	4c 89 e2             	mov    rdx,r12
  210528:	e8 03 2b 00 00       	call   213030 <readAllocBytes>
  21052d:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
  210532:	66 85 c0             	test   ax,ax
  210535:	0f 84 89 0b 00 00    	je     2110c4 <parseFormValue+0xe24>
  21053b:	66 89 84 24 78 01 00 	mov    WORD PTR [rsp+0x178],ax
  210542:	00 
  210543:	8b 44 24 3a          	mov    eax,DWORD PTR [rsp+0x3a]
  210547:	89 84 24 7a 01 00 00 	mov    DWORD PTR [rsp+0x17a],eax
  21054e:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  210553:	66 89 84 24 7e 01 00 	mov    WORD PTR [rsp+0x17e],ax
  21055a:	00 
  21055b:	8b 44 24 11          	mov    eax,DWORD PTR [rsp+0x11]
  21055f:	89 84 24 91 01 00 00 	mov    DWORD PTR [rsp+0x191],eax
  210566:	0f b7 44 24 15       	movzx  eax,WORD PTR [rsp+0x15]
  21056b:	66 89 84 24 95 01 00 	mov    WORD PTR [rsp+0x195],ax
  210572:	00 
  210573:	8a 44 24 17          	mov    al,BYTE PTR [rsp+0x17]
  210577:	88 84 24 97 01 00 00 	mov    BYTE PTR [rsp+0x197],al
  21057e:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  210582:	89 84 24 99 01 00 00 	mov    DWORD PTR [rsp+0x199],eax
  210589:	0f b7 44 24 0e       	movzx  eax,WORD PTR [rsp+0xe]
  21058e:	66 89 84 24 9d 01 00 	mov    WORD PTR [rsp+0x19d],ax
  210595:	00 
  210596:	8a 44 24 10          	mov    al,BYTE PTR [rsp+0x10]
  21059a:	88 84 24 9f 01 00 00 	mov    BYTE PTR [rsp+0x19f],al
  2105a1:	48 8d 84 24 78 01 00 	lea    rax,[rsp+0x178]
  2105a8:	00 
  2105a9:	e9 f8 16 00 00       	jmp    211ca6 <parseFormValue+0x1a06>
  2105ae:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  2105b3:	b9 04 00 00 00       	mov    ecx,0x4
  2105b8:	4c 89 fe             	mov    rsi,r15
  2105bb:	4c 89 e2             	mov    rdx,r12
  2105be:	e8 6d 2a 00 00       	call   213030 <readAllocBytes>
  2105c3:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
  2105c8:	66 85 c0             	test   ax,ax
  2105cb:	0f 84 9d 0b 00 00    	je     21116e <parseFormValue+0xece>
  2105d1:	66 89 84 24 50 01 00 	mov    WORD PTR [rsp+0x150],ax
  2105d8:	00 
  2105d9:	8b 44 24 3a          	mov    eax,DWORD PTR [rsp+0x3a]
  2105dd:	89 84 24 52 01 00 00 	mov    DWORD PTR [rsp+0x152],eax
  2105e4:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  2105e9:	66 89 84 24 56 01 00 	mov    WORD PTR [rsp+0x156],ax
  2105f0:	00 
  2105f1:	8b 44 24 11          	mov    eax,DWORD PTR [rsp+0x11]
  2105f5:	89 84 24 69 01 00 00 	mov    DWORD PTR [rsp+0x169],eax
  2105fc:	0f b7 44 24 15       	movzx  eax,WORD PTR [rsp+0x15]
  210601:	66 89 84 24 6d 01 00 	mov    WORD PTR [rsp+0x16d],ax
  210608:	00 
  210609:	8a 44 24 17          	mov    al,BYTE PTR [rsp+0x17]
  21060d:	88 84 24 6f 01 00 00 	mov    BYTE PTR [rsp+0x16f],al
  210614:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  210618:	89 84 24 71 01 00 00 	mov    DWORD PTR [rsp+0x171],eax
  21061f:	0f b7 44 24 0e       	movzx  eax,WORD PTR [rsp+0xe]
  210624:	66 89 84 24 75 01 00 	mov    WORD PTR [rsp+0x175],ax
  21062b:	00 
  21062c:	8a 44 24 10          	mov    al,BYTE PTR [rsp+0x10]
  210630:	88 84 24 77 01 00 00 	mov    BYTE PTR [rsp+0x177],al
  210637:	48 8d 84 24 50 01 00 	lea    rax,[rsp+0x150]
  21063e:	00 
  21063f:	e9 62 16 00 00       	jmp    211ca6 <parseFormValue+0x1a06>
  210644:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  210649:	b9 08 00 00 00       	mov    ecx,0x8
  21064e:	4c 89 fe             	mov    rsi,r15
  210651:	4c 89 e2             	mov    rdx,r12
  210654:	e8 d7 29 00 00       	call   213030 <readAllocBytes>
  210659:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
  21065e:	66 85 c0             	test   ax,ax
  210661:	0f 84 b1 0b 00 00    	je     211218 <parseFormValue+0xf78>
  210667:	66 89 84 24 28 01 00 	mov    WORD PTR [rsp+0x128],ax
  21066e:	00 
  21066f:	8b 44 24 3a          	mov    eax,DWORD PTR [rsp+0x3a]
  210673:	89 84 24 2a 01 00 00 	mov    DWORD PTR [rsp+0x12a],eax
  21067a:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  21067f:	66 89 84 24 2e 01 00 	mov    WORD PTR [rsp+0x12e],ax
  210686:	00 
  210687:	8b 44 24 11          	mov    eax,DWORD PTR [rsp+0x11]
  21068b:	89 84 24 41 01 00 00 	mov    DWORD PTR [rsp+0x141],eax
  210692:	0f b7 44 24 15       	movzx  eax,WORD PTR [rsp+0x15]
  210697:	66 89 84 24 45 01 00 	mov    WORD PTR [rsp+0x145],ax
  21069e:	00 
  21069f:	8a 44 24 17          	mov    al,BYTE PTR [rsp+0x17]
  2106a3:	88 84 24 47 01 00 00 	mov    BYTE PTR [rsp+0x147],al
  2106aa:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  2106ae:	89 84 24 49 01 00 00 	mov    DWORD PTR [rsp+0x149],eax
  2106b5:	0f b7 44 24 0e       	movzx  eax,WORD PTR [rsp+0xe]
  2106ba:	66 89 84 24 4d 01 00 	mov    WORD PTR [rsp+0x14d],ax
  2106c1:	00 
  2106c2:	8a 44 24 10          	mov    al,BYTE PTR [rsp+0x10]
  2106c6:	88 84 24 4f 01 00 00 	mov    BYTE PTR [rsp+0x14f],al
  2106cd:	48 8d 84 24 28 01 00 	lea    rax,[rsp+0x128]
  2106d4:	00 
  2106d5:	e9 cc 15 00 00       	jmp    211ca6 <parseFormValue+0x1a06>
  2106da:	4c 89 74 24 68       	mov    QWORD PTR [rsp+0x68],r14
            return Self{
  2106df:	c5 f8 57 c0          	vxorps xmm0,xmm0,xmm0
  2106e3:	c5 f8 29 44 24 40    	vmovaps XMMWORD PTR [rsp+0x40],xmm0
  2106e9:	48 c7 44 24 50 00 00 	mov    QWORD PTR [rsp+0x50],0x0
  2106f0:	00 00 
  2106f2:	4c 89 bc 24 d0 00 00 	mov    QWORD PTR [rsp+0xd0],r15
  2106f9:	00 
    var buf = ArrayList(u8).init(allocator);
  2106fa:	4c 89 7c 24 58       	mov    QWORD PTR [rsp+0x58],r15
  2106ff:	48 8d 84 24 b0 00 00 	lea    rax,[rsp+0xb0]
  210706:	00 
            try self.readNoEof(result[0..]);
  210707:	48 89 84 24 90 00 00 	mov    QWORD PTR [rsp+0x90],rax
  21070e:	00 
  21070f:	48 c7 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],0x1
  210716:	00 01 00 00 00 
  21071b:	48 8d 7c 24 18       	lea    rdi,[rsp+0x18]
  210720:	48 8d 94 24 90 00 00 	lea    rdx,[rsp+0x90]
  210727:	00 
            return self.readFn(self, buffer);
  210728:	4c 89 e6             	mov    rsi,r12
  21072b:	41 ff 14 24          	call   QWORD PTR [r12]
  21072f:	0f b7 44 24 18       	movzx  eax,WORD PTR [rsp+0x18]
            const amt_read = try self.read(buf);
  210734:	66 85 c0             	test   ax,ax
  210737:	0f 84 85 0b 00 00    	je     2112c2 <parseFormValue+0x1022>
  21073d:	48 8b 4c 24 68       	mov    rcx,QWORD PTR [rsp+0x68]
        DW.FORM_string => FormValue{ .String = try readStringRaw(allocator, in_stream) },
  210742:	66 89 01             	mov    WORD PTR [rcx],ax
  210745:	48 8b 84 24 84 05 00 	mov    rax,QWORD PTR [rsp+0x584]
  21074c:	00 
  21074d:	48 89 41 20          	mov    QWORD PTR [rcx+0x20],rax
  210751:	c5 fc 10 84 24 66 05 	vmovups ymm0,YMMWORD PTR [rsp+0x566]
  210758:	00 00 
  21075a:	c5 fc 11 41 02       	vmovups YMMWORD PTR [rcx+0x2],ymm0
  21075f:	e9 53 15 00 00       	jmp    211cb7 <parseFormValue+0x1a17>
  210764:	4c 89 bc 24 d0 00 00 	mov    QWORD PTR [rsp+0xd0],r15
  21076b:	00 
  21076c:	4c 89 74 24 68       	mov    QWORD PTR [rsp+0x68],r14
  210771:	4c 8d ac 24 b0 00 00 	lea    r13,[rsp+0xb0]
  210778:	00 
            try self.readNoEof(result[0..]);
  210779:	4c 89 6c 24 18       	mov    QWORD PTR [rsp+0x18],r13
  21077e:	48 c7 44 24 20 01 00 	mov    QWORD PTR [rsp+0x20],0x1
  210785:	00 00 
  210787:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  21078c:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  210791:	4c 89 e6             	mov    rsi,r12
  210794:	41 ff 14 24          	call   QWORD PTR [r12]
  210798:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  21079d:	66 85 c0             	test   ax,ax
  2107a0:	0f 84 fa 0b 00 00    	je     2113a0 <parseFormValue+0x1100>
  2107a6:	48 8b 4c 24 68       	mov    rcx,QWORD PTR [rsp+0x68]
            const block_len = try readULeb128(in_stream);
  2107ab:	66 89 01             	mov    WORD PTR [rcx],ax
  2107ae:	48 8b 84 24 da 06 00 	mov    rax,QWORD PTR [rsp+0x6da]
  2107b5:	00 
  2107b6:	48 89 41 20          	mov    QWORD PTR [rcx+0x20],rax
  2107ba:	c5 fc 10 84 24 bc 06 	vmovups ymm0,YMMWORD PTR [rsp+0x6bc]
  2107c1:	00 00 
  2107c3:	c5 fc 11 41 02       	vmovups YMMWORD PTR [rcx+0x2],ymm0
  2107c8:	e9 ea 14 00 00       	jmp    211cb7 <parseFormValue+0x1a17>
  2107cd:	48 8d 44 24 78       	lea    rax,[rsp+0x78]
            const input_slice = input_buf[0..size];
  2107d2:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  2107d7:	48 c7 44 24 20 01 00 	mov    QWORD PTR [rsp+0x20],0x1
  2107de:	00 00 
  2107e0:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  2107e5:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  2107ea:	4c 89 e6             	mov    rsi,r12
  2107ed:	41 ff 14 24          	call   QWORD PTR [r12]
  2107f1:	0f b7 4c 24 40       	movzx  ecx,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  2107f6:	66 85 c9             	test   cx,cx
  2107f9:	75 14                	jne    21080f <parseFormValue+0x56f>
            if (amt_read < buf.len) return error.EndOfStream;
  2107fb:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
  210800:	66 b9 1e 00          	mov    cx,0x1e
  210804:	48 39 44 24 48       	cmp    QWORD PTR [rsp+0x48],rax
  210809:	0f 83 fb 0e 00 00    	jae    21170a <parseFormValue+0x146a>
    const block_len = try in_stream.readVarInt(builtin.Endian.Little, usize, size);
  21080f:	66 89 8c 24 b8 02 00 	mov    WORD PTR [rsp+0x2b8],cx
  210816:	00 
  210817:	8b 44 24 3a          	mov    eax,DWORD PTR [rsp+0x3a]
  21081b:	89 84 24 ba 02 00 00 	mov    DWORD PTR [rsp+0x2ba],eax
  210822:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  210827:	66 89 84 24 be 02 00 	mov    WORD PTR [rsp+0x2be],ax
  21082e:	00 
  21082f:	8b 44 24 11          	mov    eax,DWORD PTR [rsp+0x11]
  210833:	89 84 24 d1 02 00 00 	mov    DWORD PTR [rsp+0x2d1],eax
  21083a:	0f b7 44 24 15       	movzx  eax,WORD PTR [rsp+0x15]
  21083f:	66 89 84 24 d5 02 00 	mov    WORD PTR [rsp+0x2d5],ax
  210846:	00 
  210847:	8a 44 24 17          	mov    al,BYTE PTR [rsp+0x17]
  21084b:	88 84 24 d7 02 00 00 	mov    BYTE PTR [rsp+0x2d7],al
  210852:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  210856:	89 84 24 d9 02 00 00 	mov    DWORD PTR [rsp+0x2d9],eax
  21085d:	0f b7 44 24 0e       	movzx  eax,WORD PTR [rsp+0xe]
  210862:	66 89 84 24 dd 02 00 	mov    WORD PTR [rsp+0x2dd],ax
  210869:	00 
  21086a:	8a 44 24 10          	mov    al,BYTE PTR [rsp+0x10]
  21086e:	88 84 24 df 02 00 00 	mov    BYTE PTR [rsp+0x2df],al
  210875:	48 8d 84 24 b8 02 00 	lea    rax,[rsp+0x2b8]
  21087c:	00 
  21087d:	e9 24 14 00 00       	jmp    211ca6 <parseFormValue+0x1a06>
  210882:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
            .payload = try readAllocBytes(allocator, in_stream, size),
  210887:	b9 01 00 00 00       	mov    ecx,0x1
  21088c:	4c 89 fe             	mov    rsi,r15
  21088f:	4c 89 e2             	mov    rdx,r12
  210892:	e8 99 27 00 00       	call   213030 <readAllocBytes>
  210897:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
  21089c:	66 85 c0             	test   ax,ax
  21089f:	0f 84 7c 0b 00 00    	je     211421 <parseFormValue+0x1181>
  2108a5:	66 89 84 24 a0 01 00 	mov    WORD PTR [rsp+0x1a0],ax
  2108ac:	00 
  2108ad:	8b 44 24 3a          	mov    eax,DWORD PTR [rsp+0x3a]
  2108b1:	89 84 24 a2 01 00 00 	mov    DWORD PTR [rsp+0x1a2],eax
  2108b8:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  2108bd:	66 89 84 24 a6 01 00 	mov    WORD PTR [rsp+0x1a6],ax
  2108c4:	00 
  2108c5:	8b 44 24 11          	mov    eax,DWORD PTR [rsp+0x11]
  2108c9:	89 84 24 b9 01 00 00 	mov    DWORD PTR [rsp+0x1b9],eax
  2108d0:	0f b7 44 24 15       	movzx  eax,WORD PTR [rsp+0x15]
  2108d5:	66 89 84 24 bd 01 00 	mov    WORD PTR [rsp+0x1bd],ax
  2108dc:	00 
  2108dd:	8a 44 24 17          	mov    al,BYTE PTR [rsp+0x17]
  2108e1:	88 84 24 bf 01 00 00 	mov    BYTE PTR [rsp+0x1bf],al
  2108e8:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  2108ec:	89 84 24 c1 01 00 00 	mov    DWORD PTR [rsp+0x1c1],eax
  2108f3:	0f b7 44 24 0e       	movzx  eax,WORD PTR [rsp+0xe]
  2108f8:	66 89 84 24 c5 01 00 	mov    WORD PTR [rsp+0x1c5],ax
  2108ff:	00 
  210900:	8a 44 24 10          	mov    al,BYTE PTR [rsp+0x10]
  210904:	88 84 24 c7 01 00 00 	mov    BYTE PTR [rsp+0x1c7],al
  21090b:	48 8d 84 24 a0 01 00 	lea    rax,[rsp+0x1a0]
  210912:	00 
  210913:	e9 8e 13 00 00       	jmp    211ca6 <parseFormValue+0x1a06>
  210918:	48 8d 84 24 b0 00 00 	lea    rax,[rsp+0xb0]
  21091f:	00 
            try self.readNoEof(result[0..]);
  210920:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  210925:	48 c7 44 24 20 01 00 	mov    QWORD PTR [rsp+0x20],0x1
  21092c:	00 00 
  21092e:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  210933:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  210938:	4c 89 e6             	mov    rsi,r12
  21093b:	41 ff 14 24          	call   QWORD PTR [r12]
  21093f:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  210944:	66 85 c0             	test   ax,ax
  210947:	75 14                	jne    21095d <parseFormValue+0x6bd>
  210949:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  21094e:	66 b8 1e 00          	mov    ax,0x1e
            if (amt_read < buf.len) return error.EndOfStream;
  210952:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  210957:	0f 83 ce 0d 00 00    	jae    21172b <parseFormValue+0x148b>
        DW.FORM_flag => FormValue{ .Flag = (try in_stream.readByte()) != 0 },
  21095d:	66 41 89 06          	mov    WORD PTR [r14],ax
  210961:	48 8b 84 24 42 06 00 	mov    rax,QWORD PTR [rsp+0x642]
  210968:	00 
  210969:	49 89 46 20          	mov    QWORD PTR [r14+0x20],rax
  21096d:	c5 fc 10 84 24 24 06 	vmovups ymm0,YMMWORD PTR [rsp+0x624]
  210974:	00 00 
  210976:	e9 3e 07 00 00       	jmp    2110b9 <parseFormValue+0xe19>
    return if (is_64) try in_stream.readIntLe(u64) else u64(try in_stream.readIntLe(u32));
  21097b:	40 f6 c5 01          	test   bpl,0x1
  21097f:	0f 84 1c 06 00 00    	je     210fa1 <parseFormValue+0xd01>
  210985:	48 8d 84 24 90 00 00 	lea    rax,[rsp+0x90]
  21098c:	00 
            try self.readNoEof(bytes[0..]);
  21098d:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  210992:	48 c7 44 24 20 08 00 	mov    QWORD PTR [rsp+0x20],0x8
  210999:	00 00 
  21099b:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  2109a0:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  2109a5:	4c 89 e6             	mov    rsi,r12
  2109a8:	41 ff 14 24          	call   QWORD PTR [r12]
  2109ac:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  2109b1:	66 85 c0             	test   ax,ax
  2109b4:	0f 85 29 06 00 00    	jne    210fe3 <parseFormValue+0xd43>
  2109ba:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  2109bf:	66 b8 1e 00          	mov    ax,0x1e
            if (amt_read < buf.len) return error.EndOfStream;
  2109c3:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  2109c8:	0f 82 15 06 00 00    	jb     210fe3 <parseFormValue+0xd43>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  2109ce:	48 8b 84 24 90 00 00 	mov    rax,QWORD PTR [rsp+0x90]
  2109d5:	00 
  2109d6:	e9 4f 11 00 00       	jmp    211b2a <parseFormValue+0x188a>
  2109db:	40 f6 c5 01          	test   bpl,0x1
  2109df:	0f 84 1c 06 00 00    	je     211001 <parseFormValue+0xd61>
  2109e5:	48 8d 84 24 90 00 00 	lea    rax,[rsp+0x90]
  2109ec:	00 
            try self.readNoEof(bytes[0..]);
  2109ed:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  2109f2:	48 c7 44 24 20 08 00 	mov    QWORD PTR [rsp+0x20],0x8
  2109f9:	00 00 
  2109fb:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  210a00:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  210a05:	4c 89 e6             	mov    rsi,r12
  210a08:	41 ff 14 24          	call   QWORD PTR [r12]
  210a0c:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  210a11:	66 85 c0             	test   ax,ax
  210a14:	0f 85 29 06 00 00    	jne    211043 <parseFormValue+0xda3>
  210a1a:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  210a1f:	66 b8 1e 00          	mov    ax,0x1e
            if (amt_read < buf.len) return error.EndOfStream;
  210a23:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  210a28:	0f 82 15 06 00 00    	jb     211043 <parseFormValue+0xda3>
  210a2e:	48 8b 84 24 90 00 00 	mov    rax,QWORD PTR [rsp+0x90]
  210a35:	00 
  210a36:	e9 7d 11 00 00       	jmp    211bb8 <parseFormValue+0x1918>
  210a3b:	48 8d 84 24 b0 00 00 	lea    rax,[rsp+0xb0]
  210a42:	00 
            try self.readNoEof(bytes[0..]);
  210a43:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  210a48:	48 c7 44 24 20 01 00 	mov    QWORD PTR [rsp+0x20],0x1
  210a4f:	00 00 
  210a51:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  210a56:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  210a5b:	4c 89 e6             	mov    rsi,r12
  210a5e:	41 ff 14 24          	call   QWORD PTR [r12]
  210a62:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  210a67:	66 85 c0             	test   ax,ax
  210a6a:	75 14                	jne    210a80 <parseFormValue+0x7e0>
  210a6c:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  210a71:	66 b8 1e 00          	mov    ax,0x1e
            if (amt_read < buf.len) return error.EndOfStream;
  210a75:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  210a7a:	0f 83 30 0d 00 00    	jae    2117b0 <parseFormValue+0x1510>
    const block_len = try in_stream.readIntLe(T);
  210a80:	66 89 84 24 40 02 00 	mov    WORD PTR [rsp+0x240],ax
  210a87:	00 
  210a88:	8b 44 24 3a          	mov    eax,DWORD PTR [rsp+0x3a]
  210a8c:	89 84 24 42 02 00 00 	mov    DWORD PTR [rsp+0x242],eax
  210a93:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  210a98:	66 89 84 24 46 02 00 	mov    WORD PTR [rsp+0x246],ax
  210a9f:	00 
  210aa0:	8b 44 24 11          	mov    eax,DWORD PTR [rsp+0x11]
  210aa4:	89 84 24 59 02 00 00 	mov    DWORD PTR [rsp+0x259],eax
  210aab:	0f b7 44 24 15       	movzx  eax,WORD PTR [rsp+0x15]
  210ab0:	66 89 84 24 5d 02 00 	mov    WORD PTR [rsp+0x25d],ax
  210ab7:	00 
  210ab8:	8a 44 24 17          	mov    al,BYTE PTR [rsp+0x17]
  210abc:	88 84 24 5f 02 00 00 	mov    BYTE PTR [rsp+0x25f],al
  210ac3:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  210ac7:	89 84 24 61 02 00 00 	mov    DWORD PTR [rsp+0x261],eax
  210ace:	0f b7 44 24 0e       	movzx  eax,WORD PTR [rsp+0xe]
  210ad3:	66 89 84 24 65 02 00 	mov    WORD PTR [rsp+0x265],ax
  210ada:	00 
  210adb:	8a 44 24 10          	mov    al,BYTE PTR [rsp+0x10]
  210adf:	88 84 24 67 02 00 00 	mov    BYTE PTR [rsp+0x267],al
  210ae6:	48 8d 84 24 40 02 00 	lea    rax,[rsp+0x240]
  210aed:	00 
  210aee:	e9 b3 11 00 00       	jmp    211ca6 <parseFormValue+0x1a06>
  210af3:	48 8d 44 24 78       	lea    rax,[rsp+0x78]
            try self.readNoEof(bytes[0..]);
  210af8:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  210afd:	48 c7 44 24 20 02 00 	mov    QWORD PTR [rsp+0x20],0x2
  210b04:	00 00 
  210b06:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  210b0b:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  210b10:	4c 89 e6             	mov    rsi,r12
  210b13:	41 ff 14 24          	call   QWORD PTR [r12]
  210b17:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  210b1c:	66 85 c0             	test   ax,ax
  210b1f:	75 14                	jne    210b35 <parseFormValue+0x895>
  210b21:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  210b26:	66 b8 1e 00          	mov    ax,0x1e
            if (amt_read < buf.len) return error.EndOfStream;
  210b2a:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  210b2f:	0f 83 dd 0c 00 00    	jae    211812 <parseFormValue+0x1572>
  210b35:	66 89 84 24 18 02 00 	mov    WORD PTR [rsp+0x218],ax
  210b3c:	00 
  210b3d:	8b 44 24 3a          	mov    eax,DWORD PTR [rsp+0x3a]
  210b41:	89 84 24 1a 02 00 00 	mov    DWORD PTR [rsp+0x21a],eax
  210b48:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  210b4d:	66 89 84 24 1e 02 00 	mov    WORD PTR [rsp+0x21e],ax
  210b54:	00 
  210b55:	8b 44 24 11          	mov    eax,DWORD PTR [rsp+0x11]
  210b59:	89 84 24 31 02 00 00 	mov    DWORD PTR [rsp+0x231],eax
  210b60:	0f b7 44 24 15       	movzx  eax,WORD PTR [rsp+0x15]
  210b65:	66 89 84 24 35 02 00 	mov    WORD PTR [rsp+0x235],ax
  210b6c:	00 
  210b6d:	8a 44 24 17          	mov    al,BYTE PTR [rsp+0x17]
  210b71:	88 84 24 37 02 00 00 	mov    BYTE PTR [rsp+0x237],al
  210b78:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  210b7c:	89 84 24 39 02 00 00 	mov    DWORD PTR [rsp+0x239],eax
  210b83:	0f b7 44 24 0e       	movzx  eax,WORD PTR [rsp+0xe]
  210b88:	66 89 84 24 3d 02 00 	mov    WORD PTR [rsp+0x23d],ax
  210b8f:	00 
  210b90:	8a 44 24 10          	mov    al,BYTE PTR [rsp+0x10]
  210b94:	88 84 24 3f 02 00 00 	mov    BYTE PTR [rsp+0x23f],al
  210b9b:	48 8d 84 24 18 02 00 	lea    rax,[rsp+0x218]
  210ba2:	00 
  210ba3:	e9 fe 10 00 00       	jmp    211ca6 <parseFormValue+0x1a06>
  210ba8:	48 8d 44 24 78       	lea    rax,[rsp+0x78]
            try self.readNoEof(bytes[0..]);
  210bad:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  210bb2:	48 c7 44 24 20 04 00 	mov    QWORD PTR [rsp+0x20],0x4
  210bb9:	00 00 
  210bbb:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  210bc0:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  210bc5:	4c 89 e6             	mov    rsi,r12
  210bc8:	41 ff 14 24          	call   QWORD PTR [r12]
  210bcc:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  210bd1:	66 85 c0             	test   ax,ax
  210bd4:	75 14                	jne    210bea <parseFormValue+0x94a>
  210bd6:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  210bdb:	66 b8 1e 00          	mov    ax,0x1e
            if (amt_read < buf.len) return error.EndOfStream;
  210bdf:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  210be4:	0f 83 93 0c 00 00    	jae    21187d <parseFormValue+0x15dd>
  210bea:	66 89 84 24 f0 01 00 	mov    WORD PTR [rsp+0x1f0],ax
  210bf1:	00 
  210bf2:	8b 44 24 3a          	mov    eax,DWORD PTR [rsp+0x3a]
  210bf6:	89 84 24 f2 01 00 00 	mov    DWORD PTR [rsp+0x1f2],eax
  210bfd:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  210c02:	66 89 84 24 f6 01 00 	mov    WORD PTR [rsp+0x1f6],ax
  210c09:	00 
  210c0a:	8b 44 24 11          	mov    eax,DWORD PTR [rsp+0x11]
  210c0e:	89 84 24 09 02 00 00 	mov    DWORD PTR [rsp+0x209],eax
  210c15:	0f b7 44 24 15       	movzx  eax,WORD PTR [rsp+0x15]
  210c1a:	66 89 84 24 0d 02 00 	mov    WORD PTR [rsp+0x20d],ax
  210c21:	00 
  210c22:	8a 44 24 17          	mov    al,BYTE PTR [rsp+0x17]
  210c26:	88 84 24 0f 02 00 00 	mov    BYTE PTR [rsp+0x20f],al
  210c2d:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  210c31:	89 84 24 11 02 00 00 	mov    DWORD PTR [rsp+0x211],eax
  210c38:	0f b7 44 24 0e       	movzx  eax,WORD PTR [rsp+0xe]
  210c3d:	66 89 84 24 15 02 00 	mov    WORD PTR [rsp+0x215],ax
  210c44:	00 
  210c45:	8a 44 24 10          	mov    al,BYTE PTR [rsp+0x10]
  210c49:	88 84 24 17 02 00 00 	mov    BYTE PTR [rsp+0x217],al
  210c50:	48 8d 84 24 f0 01 00 	lea    rax,[rsp+0x1f0]
  210c57:	00 
  210c58:	e9 49 10 00 00       	jmp    211ca6 <parseFormValue+0x1a06>
  210c5d:	48 8d 44 24 78       	lea    rax,[rsp+0x78]
            try self.readNoEof(bytes[0..]);
  210c62:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  210c67:	48 c7 44 24 20 08 00 	mov    QWORD PTR [rsp+0x20],0x8
  210c6e:	00 00 
  210c70:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  210c75:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  210c7a:	4c 89 e6             	mov    rsi,r12
  210c7d:	41 ff 14 24          	call   QWORD PTR [r12]
  210c81:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  210c86:	66 85 c0             	test   ax,ax
  210c89:	75 14                	jne    210c9f <parseFormValue+0x9ff>
  210c8b:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  210c90:	66 b8 1e 00          	mov    ax,0x1e
            if (amt_read < buf.len) return error.EndOfStream;
  210c94:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  210c99:	0f 83 61 0c 00 00    	jae    211900 <parseFormValue+0x1660>
  210c9f:	66 89 84 24 c8 01 00 	mov    WORD PTR [rsp+0x1c8],ax
  210ca6:	00 
  210ca7:	8b 44 24 3a          	mov    eax,DWORD PTR [rsp+0x3a]
  210cab:	89 84 24 ca 01 00 00 	mov    DWORD PTR [rsp+0x1ca],eax
  210cb2:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  210cb7:	66 89 84 24 ce 01 00 	mov    WORD PTR [rsp+0x1ce],ax
  210cbe:	00 
  210cbf:	8b 44 24 11          	mov    eax,DWORD PTR [rsp+0x11]
  210cc3:	89 84 24 e1 01 00 00 	mov    DWORD PTR [rsp+0x1e1],eax
  210cca:	0f b7 44 24 15       	movzx  eax,WORD PTR [rsp+0x15]
  210ccf:	66 89 84 24 e5 01 00 	mov    WORD PTR [rsp+0x1e5],ax
  210cd6:	00 
  210cd7:	8a 44 24 17          	mov    al,BYTE PTR [rsp+0x17]
  210cdb:	88 84 24 e7 01 00 00 	mov    BYTE PTR [rsp+0x1e7],al
  210ce2:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  210ce6:	89 84 24 e9 01 00 00 	mov    DWORD PTR [rsp+0x1e9],eax
  210ced:	0f b7 44 24 0e       	movzx  eax,WORD PTR [rsp+0xe]
  210cf2:	66 89 84 24 ed 01 00 	mov    WORD PTR [rsp+0x1ed],ax
  210cf9:	00 
  210cfa:	8a 44 24 10          	mov    al,BYTE PTR [rsp+0x10]
  210cfe:	88 84 24 ef 01 00 00 	mov    BYTE PTR [rsp+0x1ef],al
  210d05:	48 8d 84 24 c8 01 00 	lea    rax,[rsp+0x1c8]
  210d0c:	00 
  210d0d:	e9 94 0f 00 00       	jmp    211ca6 <parseFormValue+0x1a06>
  210d12:	4c 89 bc 24 d0 00 00 	mov    QWORD PTR [rsp+0xd0],r15
  210d19:	00 
  210d1a:	4c 89 74 24 68       	mov    QWORD PTR [rsp+0x68],r14
  210d1f:	4c 8d b4 24 b0 00 00 	lea    r14,[rsp+0xb0]
  210d26:	00 
            try self.readNoEof(result[0..]);
  210d27:	4c 89 74 24 18       	mov    QWORD PTR [rsp+0x18],r14
  210d2c:	48 c7 44 24 20 01 00 	mov    QWORD PTR [rsp+0x20],0x1
  210d33:	00 00 
  210d35:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  210d3a:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  210d3f:	4c 89 e6             	mov    rsi,r12
  210d42:	41 ff 14 24          	call   QWORD PTR [r12]
  210d46:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  210d4b:	66 85 c0             	test   ax,ax
  210d4e:	0f 84 77 07 00 00    	je     2114cb <parseFormValue+0x122b>
  210d54:	48 8b 4c 24 68       	mov    rcx,QWORD PTR [rsp+0x68]
            const ref_len = try readULeb128(in_stream);
  210d59:	66 89 01             	mov    WORD PTR [rcx],ax
  210d5c:	48 8b 84 24 f6 05 00 	mov    rax,QWORD PTR [rsp+0x5f6]
  210d63:	00 
  210d64:	48 89 41 20          	mov    QWORD PTR [rcx+0x20],rax
  210d68:	c5 fc 10 84 24 d8 05 	vmovups ymm0,YMMWORD PTR [rsp+0x5d8]
  210d6f:	00 00 
  210d71:	c5 fc 11 41 02       	vmovups YMMWORD PTR [rcx+0x2],ymm0
  210d76:	e9 3c 0f 00 00       	jmp    211cb7 <parseFormValue+0x1a17>
  210d7b:	4c 89 bc 24 d0 00 00 	mov    QWORD PTR [rsp+0xd0],r15
  210d82:	00 
  210d83:	4c 89 74 24 68       	mov    QWORD PTR [rsp+0x68],r14
  210d88:	4c 8d bc 24 b0 00 00 	lea    r15,[rsp+0xb0]
  210d8f:	00 
            try self.readNoEof(result[0..]);
  210d90:	4c 89 7c 24 18       	mov    QWORD PTR [rsp+0x18],r15
  210d95:	48 c7 44 24 20 01 00 	mov    QWORD PTR [rsp+0x20],0x1
  210d9c:	00 00 
  210d9e:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  210da3:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  210da8:	4c 89 e6             	mov    rsi,r12
  210dab:	41 ff 14 24          	call   QWORD PTR [r12]
  210daf:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  210db4:	66 85 c0             	test   ax,ax
  210db7:	0f 84 8f 07 00 00    	je     21154c <parseFormValue+0x12ac>
  210dbd:	48 8b 4c 24 68       	mov    rcx,QWORD PTR [rsp+0x68]
            const child_form_id = try readULeb128(in_stream);
  210dc2:	66 89 01             	mov    WORD PTR [rcx],ax
  210dc5:	48 8b 84 24 38 05 00 	mov    rax,QWORD PTR [rsp+0x538]
  210dcc:	00 
  210dcd:	48 89 41 20          	mov    QWORD PTR [rcx+0x20],rax
  210dd1:	c5 fc 10 84 24 1a 05 	vmovups ymm0,YMMWORD PTR [rsp+0x51a]
  210dd8:	00 00 
  210dda:	c5 fc 11 41 02       	vmovups YMMWORD PTR [rcx+0x2],ymm0
  210ddf:	e9 d3 0e 00 00       	jmp    211cb7 <parseFormValue+0x1a17>
    return if (is_64) try in_stream.readIntLe(u64) else u64(try in_stream.readIntLe(u32));
  210de4:	40 f6 c5 01          	test   bpl,0x1
  210de8:	0f 84 70 02 00 00    	je     21105e <parseFormValue+0xdbe>
  210dee:	48 8d 84 24 90 00 00 	lea    rax,[rsp+0x90]
  210df5:	00 
            try self.readNoEof(bytes[0..]);
  210df6:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  210dfb:	48 c7 44 24 20 08 00 	mov    QWORD PTR [rsp+0x20],0x8
  210e02:	00 00 
  210e04:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  210e09:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  210e0e:	4c 89 e6             	mov    rsi,r12
  210e11:	41 ff 14 24          	call   QWORD PTR [r12]
  210e15:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  210e1a:	66 85 c0             	test   ax,ax
  210e1d:	0f 85 7d 02 00 00    	jne    2110a0 <parseFormValue+0xe00>
  210e23:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  210e28:	66 b8 1e 00          	mov    ax,0x1e
            if (amt_read < buf.len) return error.EndOfStream;
  210e2c:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  210e31:	0f 82 69 02 00 00    	jb     2110a0 <parseFormValue+0xe00>
  210e37:	48 8b 84 24 90 00 00 	mov    rax,QWORD PTR [rsp+0x90]
  210e3e:	00 
  210e3f:	e9 02 0e 00 00       	jmp    211c46 <parseFormValue+0x19a6>
  210e44:	4c 89 bc 24 d0 00 00 	mov    QWORD PTR [rsp+0xd0],r15
  210e4b:	00 
  210e4c:	4c 89 74 24 68       	mov    QWORD PTR [rsp+0x68],r14
  210e51:	4c 8d b4 24 b0 00 00 	lea    r14,[rsp+0xb0]
  210e58:	00 
            try self.readNoEof(result[0..]);
  210e59:	4c 89 74 24 18       	mov    QWORD PTR [rsp+0x18],r14
  210e5e:	48 c7 44 24 20 01 00 	mov    QWORD PTR [rsp+0x20],0x1
  210e65:	00 00 
  210e67:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  210e6c:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  210e71:	4c 89 e6             	mov    rsi,r12
  210e74:	41 ff 14 24          	call   QWORD PTR [r12]
  210e78:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  210e7d:	66 85 c0             	test   ax,ax
  210e80:	0f 84 45 07 00 00    	je     2115cb <parseFormValue+0x132b>
  210e86:	48 8b 4c 24 68       	mov    rcx,QWORD PTR [rsp+0x68]
            const size = try readULeb128(in_stream);
  210e8b:	66 89 01             	mov    WORD PTR [rcx],ax
  210e8e:	48 8b 84 24 8e 06 00 	mov    rax,QWORD PTR [rsp+0x68e]
  210e95:	00 
  210e96:	48 89 41 20          	mov    QWORD PTR [rcx+0x20],rax
  210e9a:	c5 fc 10 84 24 70 06 	vmovups ymm0,YMMWORD PTR [rsp+0x670]
  210ea1:	00 00 
  210ea3:	c5 fc 11 41 02       	vmovups YMMWORD PTR [rcx+0x2],ymm0
  210ea8:	e9 0a 0e 00 00       	jmp    211cb7 <parseFormValue+0x1a17>
  210ead:	48 8d 05 e4 47 ff ff 	lea    rax,[rip+0xffffffffffff47e4]        # 205698 <__unnamed_68>
  210eb4:	e9 ed 0d 00 00       	jmp    211ca6 <parseFormValue+0x1a06>
  210eb9:	48 8d 44 24 78       	lea    rax,[rsp+0x78]
            try self.readNoEof(bytes[0..]);
  210ebe:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  210ec3:	48 c7 44 24 20 08 00 	mov    QWORD PTR [rsp+0x20],0x8
  210eca:	00 00 
  210ecc:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  210ed1:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  210ed6:	4c 89 e6             	mov    rsi,r12
  210ed9:	41 ff 14 24          	call   QWORD PTR [r12]
  210edd:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  210ee2:	66 85 c0             	test   ax,ax
  210ee5:	75 14                	jne    210efb <parseFormValue+0xc5b>
  210ee7:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  210eec:	66 b8 1e 00          	mov    ax,0x1e
            if (amt_read < buf.len) return error.EndOfStream;
  210ef0:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  210ef5:	0f 83 64 0a 00 00    	jae    21195f <parseFormValue+0x16bf>
        DW.FORM_ref_sig8 => FormValue{ .RefSig8 = try in_stream.readIntLe(u64) },
  210efb:	66 41 89 06          	mov    WORD PTR [r14],ax
  210eff:	48 8b 84 24 aa 05 00 	mov    rax,QWORD PTR [rsp+0x5aa]
  210f06:	00 
  210f07:	49 89 46 20          	mov    QWORD PTR [r14+0x20],rax
  210f0b:	c5 fc 10 84 24 8c 05 	vmovups ymm0,YMMWORD PTR [rsp+0x58c]
  210f12:	00 00 
  210f14:	e9 a0 01 00 00       	jmp    2110b9 <parseFormValue+0xe19>
  210f19:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  210f1e:	31 ed                	xor    ebp,ebp
  210f20:	4c 8d 7c 24 18       	lea    r15,[rsp+0x18]
  210f25:	45 31 ed             	xor    r13d,r13d
  210f28:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  210f2f:	00 
  210f30:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  210f35:	0f 82 11 07 00 00    	jb     21164c <parseFormValue+0x13ac>
            return result[0];
  210f3b:	0f b6 84 24 b0 00 00 	movzx  eax,BYTE PTR [rsp+0xb0]
  210f42:	00 
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  210f43:	89 c2                	mov    edx,eax
  210f45:	83 e2 7f             	and    edx,0x7f
  210f48:	44 89 ee             	mov    esi,r13d
  210f4b:	83 e6 3f             	and    esi,0x3f
  210f4e:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  210f53:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  210f58:	48 39 d6             	cmp    rsi,rdx
  210f5b:	0f 85 f4 06 00 00    	jne    211655 <parseFormValue+0x13b5>
        result |= operand;
  210f61:	48 09 cd             	or     rbp,rcx
        if ((byte & 0b10000000) == 0) return result;
  210f64:	84 c0                	test   al,al
  210f66:	0f 89 5d 0a 00 00    	jns    2119c9 <parseFormValue+0x1729>
        shift += 7;
  210f6c:	49 83 c5 07          	add    r13,0x7
            try self.readNoEof(result[0..]);
  210f70:	4c 89 74 24 18       	mov    QWORD PTR [rsp+0x18],r14
  210f75:	48 c7 44 24 20 01 00 	mov    QWORD PTR [rsp+0x20],0x1
  210f7c:	00 00 
            return self.readFn(self, buffer);
  210f7e:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  210f83:	4c 89 e6             	mov    rsi,r12
  210f86:	4c 89 fa             	mov    rdx,r15
  210f89:	41 ff 14 24          	call   QWORD PTR [r12]
  210f8d:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
  210f92:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
            const amt_read = try self.read(buf);
  210f97:	66 85 c0             	test   ax,ax
  210f9a:	74 94                	je     210f30 <parseFormValue+0xc90>
  210f9c:	e9 86 f3 ff ff       	jmp    210327 <parseFormValue+0x87>
  210fa1:	48 8d 44 24 78       	lea    rax,[rsp+0x78]
            try self.readNoEof(bytes[0..]);
  210fa6:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  210fab:	48 c7 44 24 20 04 00 	mov    QWORD PTR [rsp+0x20],0x4
  210fb2:	00 00 
  210fb4:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  210fb9:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  210fbe:	4c 89 e6             	mov    rsi,r12
  210fc1:	41 ff 14 24          	call   QWORD PTR [r12]
  210fc5:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  210fca:	66 85 c0             	test   ax,ax
  210fcd:	75 14                	jne    210fe3 <parseFormValue+0xd43>
  210fcf:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  210fd4:	66 b8 1e 00          	mov    ax,0x1e
            if (amt_read < buf.len) return error.EndOfStream;
  210fd8:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  210fdd:	0f 83 1e 0b 00 00    	jae    211b01 <parseFormValue+0x1861>
        DW.FORM_strp => FormValue{ .StrPtr = try parseFormValueDwarfOffsetSize(in_stream, is_64) },
  210fe3:	66 41 89 06          	mov    WORD PTR [r14],ax
  210fe7:	48 8b 84 24 5e 05 00 	mov    rax,QWORD PTR [rsp+0x55e]
  210fee:	00 
  210fef:	49 89 46 20          	mov    QWORD PTR [r14+0x20],rax
  210ff3:	c5 fc 10 84 24 40 05 	vmovups ymm0,YMMWORD PTR [rsp+0x540]
  210ffa:	00 00 
  210ffc:	e9 b8 00 00 00       	jmp    2110b9 <parseFormValue+0xe19>
  211001:	48 8d 44 24 78       	lea    rax,[rsp+0x78]
            try self.readNoEof(bytes[0..]);
  211006:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  21100b:	48 c7 44 24 20 04 00 	mov    QWORD PTR [rsp+0x20],0x4
  211012:	00 00 
  211014:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  211019:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  21101e:	4c 89 e6             	mov    rsi,r12
  211021:	41 ff 14 24          	call   QWORD PTR [r12]
  211025:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  21102a:	66 85 c0             	test   ax,ax
  21102d:	75 14                	jne    211043 <parseFormValue+0xda3>
  21102f:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  211034:	66 b8 1e 00          	mov    ax,0x1e
            if (amt_read < buf.len) return error.EndOfStream;
  211038:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  21103d:	0f 83 4c 0b 00 00    	jae    211b8f <parseFormValue+0x18ef>
        DW.FORM_ref_addr => FormValue{ .RefAddr = try parseFormValueDwarfOffsetSize(in_stream, is_64) },
  211043:	66 41 89 06          	mov    WORD PTR [r14],ax
  211047:	48 8b 84 24 d0 05 00 	mov    rax,QWORD PTR [rsp+0x5d0]
  21104e:	00 
  21104f:	49 89 46 20          	mov    QWORD PTR [r14+0x20],rax
  211053:	c5 fc 10 84 24 b2 05 	vmovups ymm0,YMMWORD PTR [rsp+0x5b2]
  21105a:	00 00 
  21105c:	eb 5b                	jmp    2110b9 <parseFormValue+0xe19>
  21105e:	48 8d 44 24 78       	lea    rax,[rsp+0x78]
            try self.readNoEof(bytes[0..]);
  211063:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  211068:	48 c7 44 24 20 04 00 	mov    QWORD PTR [rsp+0x20],0x4
  21106f:	00 00 
  211071:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  211076:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  21107b:	4c 89 e6             	mov    rsi,r12
  21107e:	41 ff 14 24          	call   QWORD PTR [r12]
  211082:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  211087:	66 85 c0             	test   ax,ax
  21108a:	75 14                	jne    2110a0 <parseFormValue+0xe00>
  21108c:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  211091:	66 b8 1e 00          	mov    ax,0x1e
            if (amt_read < buf.len) return error.EndOfStream;
  211095:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  21109a:	0f 83 7d 0b 00 00    	jae    211c1d <parseFormValue+0x197d>
        DW.FORM_sec_offset => FormValue{ .SecOffset = try parseFormValueDwarfOffsetSize(in_stream, is_64) },
  2110a0:	66 41 89 06          	mov    WORD PTR [r14],ax
  2110a4:	48 8b 84 24 1c 06 00 	mov    rax,QWORD PTR [rsp+0x61c]
  2110ab:	00 
  2110ac:	49 89 46 20          	mov    QWORD PTR [r14+0x20],rax
  2110b0:	c5 fc 10 84 24 fe 05 	vmovups ymm0,YMMWORD PTR [rsp+0x5fe]
  2110b7:	00 00 
  2110b9:	c4 c1 7c 11 46 02    	vmovups YMMWORD PTR [r14+0x2],ymm0
  2110bf:	e9 f3 0b 00 00       	jmp    211cb7 <parseFormValue+0x1a17>
    return FormValue{
  2110c4:	c6 84 24 b0 00 00 00 	mov    BYTE PTR [rsp+0xb0],0x0
  2110cb:	00 
  2110cc:	c6 44 24 60 02       	mov    BYTE PTR [rsp+0x60],0x2
  2110d1:	66 c7 84 24 78 01 00 	mov    WORD PTR [rsp+0x178],0x0
  2110d8:	00 00 00 
  2110db:	8b 44 24 78          	mov    eax,DWORD PTR [rsp+0x78]
  2110df:	89 84 24 7a 01 00 00 	mov    DWORD PTR [rsp+0x17a],eax
        .Const = Constant{
  2110e6:	c5 f8 10 44 24 48    	vmovups xmm0,XMMWORD PTR [rsp+0x48]
    return FormValue{
  2110ec:	0f b7 44 24 7c       	movzx  eax,WORD PTR [rsp+0x7c]
  2110f1:	66 89 84 24 7e 01 00 	mov    WORD PTR [rsp+0x17e],ax
  2110f8:	00 
  2110f9:	c5 f8 11 84 24 80 01 	vmovups XMMWORD PTR [rsp+0x180],xmm0
  211100:	00 00 
  211102:	c6 84 24 90 01 00 00 	mov    BYTE PTR [rsp+0x190],0x0
  211109:	00 
  21110a:	8b 84 24 90 00 00 00 	mov    eax,DWORD PTR [rsp+0x90]
  211111:	89 84 24 91 01 00 00 	mov    DWORD PTR [rsp+0x191],eax
  211118:	0f b7 84 24 94 00 00 	movzx  eax,WORD PTR [rsp+0x94]
  21111f:	00 
  211120:	66 89 84 24 95 01 00 	mov    WORD PTR [rsp+0x195],ax
  211127:	00 
  211128:	8a 84 24 96 00 00 00 	mov    al,BYTE PTR [rsp+0x96]
  21112f:	88 84 24 97 01 00 00 	mov    BYTE PTR [rsp+0x197],al
  211136:	c6 84 24 98 01 00 00 	mov    BYTE PTR [rsp+0x198],0x2
  21113d:	02 
  21113e:	8a 44 24 1e          	mov    al,BYTE PTR [rsp+0x1e]
  211142:	88 84 24 9f 01 00 00 	mov    BYTE PTR [rsp+0x19f],al
  211149:	0f b7 44 24 1c       	movzx  eax,WORD PTR [rsp+0x1c]
  21114e:	66 89 84 24 9d 01 00 	mov    WORD PTR [rsp+0x19d],ax
  211155:	00 
  211156:	8b 44 24 18          	mov    eax,DWORD PTR [rsp+0x18]
  21115a:	89 84 24 99 01 00 00 	mov    DWORD PTR [rsp+0x199],eax
  211161:	48 8d 84 24 78 01 00 	lea    rax,[rsp+0x178]
  211168:	00 
  211169:	e9 38 0b 00 00       	jmp    211ca6 <parseFormValue+0x1a06>
  21116e:	c6 84 24 b0 00 00 00 	mov    BYTE PTR [rsp+0xb0],0x0
  211175:	00 
  211176:	c6 44 24 60 02       	mov    BYTE PTR [rsp+0x60],0x2
  21117b:	66 c7 84 24 50 01 00 	mov    WORD PTR [rsp+0x150],0x0
  211182:	00 00 00 
  211185:	8b 44 24 78          	mov    eax,DWORD PTR [rsp+0x78]
  211189:	89 84 24 52 01 00 00 	mov    DWORD PTR [rsp+0x152],eax
        .Const = Constant{
  211190:	c5 f8 10 44 24 48    	vmovups xmm0,XMMWORD PTR [rsp+0x48]
    return FormValue{
  211196:	0f b7 44 24 7c       	movzx  eax,WORD PTR [rsp+0x7c]
  21119b:	66 89 84 24 56 01 00 	mov    WORD PTR [rsp+0x156],ax
  2111a2:	00 
  2111a3:	c5 f8 11 84 24 58 01 	vmovups XMMWORD PTR [rsp+0x158],xmm0
  2111aa:	00 00 
  2111ac:	c6 84 24 68 01 00 00 	mov    BYTE PTR [rsp+0x168],0x0
  2111b3:	00 
  2111b4:	8b 84 24 90 00 00 00 	mov    eax,DWORD PTR [rsp+0x90]
  2111bb:	89 84 24 69 01 00 00 	mov    DWORD PTR [rsp+0x169],eax
  2111c2:	0f b7 84 24 94 00 00 	movzx  eax,WORD PTR [rsp+0x94]
  2111c9:	00 
  2111ca:	66 89 84 24 6d 01 00 	mov    WORD PTR [rsp+0x16d],ax
  2111d1:	00 
  2111d2:	8a 84 24 96 00 00 00 	mov    al,BYTE PTR [rsp+0x96]
  2111d9:	88 84 24 6f 01 00 00 	mov    BYTE PTR [rsp+0x16f],al
  2111e0:	c6 84 24 70 01 00 00 	mov    BYTE PTR [rsp+0x170],0x2
  2111e7:	02 
  2111e8:	8a 44 24 1e          	mov    al,BYTE PTR [rsp+0x1e]
  2111ec:	88 84 24 77 01 00 00 	mov    BYTE PTR [rsp+0x177],al
  2111f3:	0f b7 44 24 1c       	movzx  eax,WORD PTR [rsp+0x1c]
  2111f8:	66 89 84 24 75 01 00 	mov    WORD PTR [rsp+0x175],ax
  2111ff:	00 
  211200:	8b 44 24 18          	mov    eax,DWORD PTR [rsp+0x18]
  211204:	89 84 24 71 01 00 00 	mov    DWORD PTR [rsp+0x171],eax
  21120b:	48 8d 84 24 50 01 00 	lea    rax,[rsp+0x150]
  211212:	00 
  211213:	e9 8e 0a 00 00       	jmp    211ca6 <parseFormValue+0x1a06>
  211218:	c6 84 24 b0 00 00 00 	mov    BYTE PTR [rsp+0xb0],0x0
  21121f:	00 
  211220:	c6 44 24 60 02       	mov    BYTE PTR [rsp+0x60],0x2
  211225:	66 c7 84 24 28 01 00 	mov    WORD PTR [rsp+0x128],0x0
  21122c:	00 00 00 
  21122f:	8b 44 24 78          	mov    eax,DWORD PTR [rsp+0x78]
  211233:	89 84 24 2a 01 00 00 	mov    DWORD PTR [rsp+0x12a],eax
        .Const = Constant{
  21123a:	c5 f8 10 44 24 48    	vmovups xmm0,XMMWORD PTR [rsp+0x48]
    return FormValue{
  211240:	0f b7 44 24 7c       	movzx  eax,WORD PTR [rsp+0x7c]
  211245:	66 89 84 24 2e 01 00 	mov    WORD PTR [rsp+0x12e],ax
  21124c:	00 
  21124d:	c5 f8 11 84 24 30 01 	vmovups XMMWORD PTR [rsp+0x130],xmm0
  211254:	00 00 
  211256:	c6 84 24 40 01 00 00 	mov    BYTE PTR [rsp+0x140],0x0
  21125d:	00 
  21125e:	8b 84 24 90 00 00 00 	mov    eax,DWORD PTR [rsp+0x90]
  211265:	89 84 24 41 01 00 00 	mov    DWORD PTR [rsp+0x141],eax
  21126c:	0f b7 84 24 94 00 00 	movzx  eax,WORD PTR [rsp+0x94]
  211273:	00 
  211274:	66 89 84 24 45 01 00 	mov    WORD PTR [rsp+0x145],ax
  21127b:	00 
  21127c:	8a 84 24 96 00 00 00 	mov    al,BYTE PTR [rsp+0x96]
  211283:	88 84 24 47 01 00 00 	mov    BYTE PTR [rsp+0x147],al
  21128a:	c6 84 24 48 01 00 00 	mov    BYTE PTR [rsp+0x148],0x2
  211291:	02 
  211292:	8a 44 24 1e          	mov    al,BYTE PTR [rsp+0x1e]
  211296:	88 84 24 4f 01 00 00 	mov    BYTE PTR [rsp+0x14f],al
  21129d:	0f b7 44 24 1c       	movzx  eax,WORD PTR [rsp+0x1c]
  2112a2:	66 89 84 24 4d 01 00 	mov    WORD PTR [rsp+0x14d],ax
  2112a9:	00 
  2112aa:	8b 44 24 18          	mov    eax,DWORD PTR [rsp+0x18]
  2112ae:	89 84 24 49 01 00 00 	mov    DWORD PTR [rsp+0x149],eax
  2112b5:	48 8d 84 24 28 01 00 	lea    rax,[rsp+0x128]
  2112bc:	00 
  2112bd:	e9 e4 09 00 00       	jmp    211ca6 <parseFormValue+0x1a06>
  2112c2:	48 8b 4c 24 20       	mov    rcx,QWORD PTR [rsp+0x20]
  2112c7:	45 31 ed             	xor    r13d,r13d
  2112ca:	48 8d 5c 24 18       	lea    rbx,[rsp+0x18]
  2112cf:	31 ed                	xor    ebp,ebp
  2112d1:	48 3b 8c 24 98 00 00 	cmp    rcx,QWORD PTR [rsp+0x98]
  2112d8:	00 
  2112d9:	0f 82 90 07 00 00    	jb     211a6f <parseFormValue+0x17cf>
            return result[0];
  2112df:	44 8a bc 24 b0 00 00 	mov    r15b,BYTE PTR [rsp+0xb0]
  2112e6:	00 
        if (byte == 0) break;
  2112e7:	45 84 ff             	test   r15b,r15b
  2112ea:	0f 84 88 07 00 00    	je     211a78 <parseFormValue+0x17d8>
            var better_capacity = self.items.len;
  2112f0:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
            if (better_capacity >= new_capacity) return;
  2112f5:	48 39 e9             	cmp    rcx,rbp
  2112f8:	77 4f                	ja     211349 <parseFormValue+0x10a9>
  2112fa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
                better_capacity += better_capacity / 2 + 8;
  211300:	48 89 c8             	mov    rax,rcx
  211303:	48 d1 e8             	shr    rax,1
  211306:	48 01 c1             	add    rcx,rax
  211309:	48 83 c1 08          	add    rcx,0x8
                if (better_capacity >= new_capacity) break;
  21130d:	48 39 e9             	cmp    rcx,rbp
  211310:	76 ee                	jbe    211300 <parseFormValue+0x1060>
            self.items = try self.allocator.alignedRealloc(T, A, self.items, better_capacity);
  211312:	48 89 df             	mov    rdi,rbx
  211315:	48 8b b4 24 d0 00 00 	mov    rsi,QWORD PTR [rsp+0xd0]
  21131c:	00 
  21131d:	48 8d 54 24 40       	lea    rdx,[rsp+0x40]
  211322:	e8 49 47 00 00       	call   215a70 <Allocator_alignedRealloc.68>
  211327:	0f b7 44 24 18       	movzx  eax,WORD PTR [rsp+0x18]
  21132c:	66 85 c0             	test   ax,ax
  21132f:	0f 85 08 f4 ff ff    	jne    21073d <parseFormValue+0x49d>
  211335:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  21133a:	c5 f8 10 00          	vmovups xmm0,XMMWORD PTR [rax]
  21133e:	c5 f8 29 44 24 40    	vmovaps XMMWORD PTR [rsp+0x40],xmm0
            const result = &self.items[self.len];
  211344:	4c 8b 6c 24 40       	mov    r13,QWORD PTR [rsp+0x40]
  211349:	4c 8d 75 01          	lea    r14,[rbp+0x1]
            self.len = new_length;
  21134d:	4c 89 74 24 50       	mov    QWORD PTR [rsp+0x50],r14
            new_item_ptr.* = item;
  211352:	45 88 7c 2d 00       	mov    BYTE PTR [r13+rbp*1+0x0],r15b
            try self.readNoEof(result[0..]);
  211357:	48 8d 84 24 b0 00 00 	lea    rax,[rsp+0xb0]
  21135e:	00 
  21135f:	48 89 84 24 90 00 00 	mov    QWORD PTR [rsp+0x90],rax
  211366:	00 
  211367:	48 c7 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],0x1
  21136e:	00 01 00 00 00 
            return self.readFn(self, buffer);
  211373:	48 89 df             	mov    rdi,rbx
  211376:	4c 89 e6             	mov    rsi,r12
  211379:	48 8d 94 24 90 00 00 	lea    rdx,[rsp+0x90]
  211380:	00 
  211381:	41 ff 14 24          	call   QWORD PTR [r12]
  211385:	0f b7 44 24 18       	movzx  eax,WORD PTR [rsp+0x18]
  21138a:	48 8b 4c 24 20       	mov    rcx,QWORD PTR [rsp+0x20]
  21138f:	4c 89 f5             	mov    rbp,r14
            const amt_read = try self.read(buf);
  211392:	66 85 c0             	test   ax,ax
  211395:	0f 84 36 ff ff ff    	je     2112d1 <parseFormValue+0x1031>
  21139b:	e9 9d f3 ff ff       	jmp    21073d <parseFormValue+0x49d>
  2113a0:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  2113a5:	31 db                	xor    ebx,ebx
  2113a7:	4c 8d 7c 24 40       	lea    r15,[rsp+0x40]
  2113ac:	4c 8d 74 24 18       	lea    r14,[rsp+0x18]
  2113b1:	31 ed                	xor    ebp,ebp
            if (amt_read < buf.len) return error.EndOfStream;
  2113b3:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  2113b8:	0f 82 1f 07 00 00    	jb     211add <parseFormValue+0x183d>
            return result[0];
  2113be:	0f b6 84 24 b0 00 00 	movzx  eax,BYTE PTR [rsp+0xb0]
  2113c5:	00 
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  2113c6:	89 c2                	mov    edx,eax
  2113c8:	83 e2 7f             	and    edx,0x7f
  2113cb:	89 ee                	mov    esi,ebp
  2113cd:	83 e6 3f             	and    esi,0x3f
  2113d0:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  2113d5:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  2113da:	48 39 d6             	cmp    rsi,rdx
  2113dd:	0f 85 e9 08 00 00    	jne    211ccc <parseFormValue+0x1a2c>
        result |= operand;
  2113e3:	48 09 cb             	or     rbx,rcx
        if ((byte & 0b10000000) == 0) return result;
  2113e6:	84 c0                	test   al,al
  2113e8:	0f 89 02 09 00 00    	jns    211cf0 <parseFormValue+0x1a50>
        shift += 7;
  2113ee:	48 83 c5 07          	add    rbp,0x7
            try self.readNoEof(result[0..]);
  2113f2:	4c 89 6c 24 18       	mov    QWORD PTR [rsp+0x18],r13
  2113f7:	48 c7 44 24 20 01 00 	mov    QWORD PTR [rsp+0x20],0x1
  2113fe:	00 00 
            return self.readFn(self, buffer);
  211400:	4c 89 ff             	mov    rdi,r15
  211403:	4c 89 e6             	mov    rsi,r12
  211406:	4c 89 f2             	mov    rdx,r14
  211409:	41 ff 14 24          	call   QWORD PTR [r12]
  21140d:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
  211412:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
            const amt_read = try self.read(buf);
  211417:	66 85 c0             	test   ax,ax
  21141a:	74 97                	je     2113b3 <parseFormValue+0x1113>
  21141c:	e9 85 f3 ff ff       	jmp    2107a6 <parseFormValue+0x506>
    return FormValue{
  211421:	c6 84 24 b0 00 00 00 	mov    BYTE PTR [rsp+0xb0],0x0
  211428:	00 
  211429:	c6 44 24 60 02       	mov    BYTE PTR [rsp+0x60],0x2
  21142e:	66 c7 84 24 a0 01 00 	mov    WORD PTR [rsp+0x1a0],0x0
  211435:	00 00 00 
  211438:	8b 44 24 78          	mov    eax,DWORD PTR [rsp+0x78]
  21143c:	89 84 24 a2 01 00 00 	mov    DWORD PTR [rsp+0x1a2],eax
        .Const = Constant{
  211443:	c5 f8 10 44 24 48    	vmovups xmm0,XMMWORD PTR [rsp+0x48]
    return FormValue{
  211449:	0f b7 44 24 7c       	movzx  eax,WORD PTR [rsp+0x7c]
  21144e:	66 89 84 24 a6 01 00 	mov    WORD PTR [rsp+0x1a6],ax
  211455:	00 
  211456:	c5 f8 11 84 24 a8 01 	vmovups XMMWORD PTR [rsp+0x1a8],xmm0
  21145d:	00 00 
  21145f:	c6 84 24 b8 01 00 00 	mov    BYTE PTR [rsp+0x1b8],0x0
  211466:	00 
  211467:	8b 84 24 90 00 00 00 	mov    eax,DWORD PTR [rsp+0x90]
  21146e:	89 84 24 b9 01 00 00 	mov    DWORD PTR [rsp+0x1b9],eax
  211475:	0f b7 84 24 94 00 00 	movzx  eax,WORD PTR [rsp+0x94]
  21147c:	00 
  21147d:	66 89 84 24 bd 01 00 	mov    WORD PTR [rsp+0x1bd],ax
  211484:	00 
  211485:	8a 84 24 96 00 00 00 	mov    al,BYTE PTR [rsp+0x96]
  21148c:	88 84 24 bf 01 00 00 	mov    BYTE PTR [rsp+0x1bf],al
  211493:	c6 84 24 c0 01 00 00 	mov    BYTE PTR [rsp+0x1c0],0x2
  21149a:	02 
  21149b:	8a 44 24 1e          	mov    al,BYTE PTR [rsp+0x1e]
  21149f:	88 84 24 c7 01 00 00 	mov    BYTE PTR [rsp+0x1c7],al
  2114a6:	0f b7 44 24 1c       	movzx  eax,WORD PTR [rsp+0x1c]
  2114ab:	66 89 84 24 c5 01 00 	mov    WORD PTR [rsp+0x1c5],ax
  2114b2:	00 
  2114b3:	8b 44 24 18          	mov    eax,DWORD PTR [rsp+0x18]
  2114b7:	89 84 24 c1 01 00 00 	mov    DWORD PTR [rsp+0x1c1],eax
  2114be:	48 8d 84 24 a0 01 00 	lea    rax,[rsp+0x1a0]
  2114c5:	00 
  2114c6:	e9 db 07 00 00       	jmp    211ca6 <parseFormValue+0x1a06>
  2114cb:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  2114d0:	31 db                	xor    ebx,ebx
  2114d2:	4c 8d 6c 24 40       	lea    r13,[rsp+0x40]
  2114d7:	4c 8d 7c 24 18       	lea    r15,[rsp+0x18]
  2114dc:	31 ed                	xor    ebp,ebp
            if (amt_read < buf.len) return error.EndOfStream;
  2114de:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  2114e3:	0f 82 fd 05 00 00    	jb     211ae6 <parseFormValue+0x1846>
            return result[0];
  2114e9:	0f b6 84 24 b0 00 00 	movzx  eax,BYTE PTR [rsp+0xb0]
  2114f0:	00 
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  2114f1:	89 c2                	mov    edx,eax
  2114f3:	83 e2 7f             	and    edx,0x7f
  2114f6:	89 ee                	mov    esi,ebp
  2114f8:	83 e6 3f             	and    esi,0x3f
  2114fb:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  211500:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  211505:	48 39 d6             	cmp    rsi,rdx
  211508:	0f 85 c7 07 00 00    	jne    211cd5 <parseFormValue+0x1a35>
        result |= operand;
  21150e:	48 09 cb             	or     rbx,rcx
        if ((byte & 0b10000000) == 0) return result;
  211511:	84 c0                	test   al,al
  211513:	0f 89 7d 08 00 00    	jns    211d96 <parseFormValue+0x1af6>
        shift += 7;
  211519:	48 83 c5 07          	add    rbp,0x7
            try self.readNoEof(result[0..]);
  21151d:	4c 89 74 24 18       	mov    QWORD PTR [rsp+0x18],r14
  211522:	48 c7 44 24 20 01 00 	mov    QWORD PTR [rsp+0x20],0x1
  211529:	00 00 
            return self.readFn(self, buffer);
  21152b:	4c 89 ef             	mov    rdi,r13
  21152e:	4c 89 e6             	mov    rsi,r12
  211531:	4c 89 fa             	mov    rdx,r15
  211534:	41 ff 14 24          	call   QWORD PTR [r12]
  211538:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
  21153d:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
            const amt_read = try self.read(buf);
  211542:	66 85 c0             	test   ax,ax
  211545:	74 97                	je     2114de <parseFormValue+0x123e>
  211547:	e9 08 f8 ff ff       	jmp    210d54 <parseFormValue+0xab4>
  21154c:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  211551:	45 31 f6             	xor    r14d,r14d
  211554:	4c 8d 6c 24 18       	lea    r13,[rsp+0x18]
  211559:	31 db                	xor    ebx,ebx
            if (amt_read < buf.len) return error.EndOfStream;
  21155b:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  211560:	0f 82 89 05 00 00    	jb     211aef <parseFormValue+0x184f>
            return result[0];
  211566:	0f b6 84 24 b0 00 00 	movzx  eax,BYTE PTR [rsp+0xb0]
  21156d:	00 
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  21156e:	89 c2                	mov    edx,eax
  211570:	83 e2 7f             	and    edx,0x7f
  211573:	89 de                	mov    esi,ebx
  211575:	83 e6 3f             	and    esi,0x3f
  211578:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  21157d:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  211582:	48 39 d6             	cmp    rsi,rdx
  211585:	0f 85 53 07 00 00    	jne    211cde <parseFormValue+0x1a3e>
        result |= operand;
  21158b:	49 09 ce             	or     r14,rcx
        if ((byte & 0b10000000) == 0) return result;
  21158e:	84 c0                	test   al,al
  211590:	0f 89 a6 08 00 00    	jns    211e3c <parseFormValue+0x1b9c>
        shift += 7;
  211596:	48 83 c3 07          	add    rbx,0x7
            try self.readNoEof(result[0..]);
  21159a:	4c 89 7c 24 18       	mov    QWORD PTR [rsp+0x18],r15
  21159f:	48 c7 44 24 20 01 00 	mov    QWORD PTR [rsp+0x20],0x1
  2115a6:	00 00 
            return self.readFn(self, buffer);
  2115a8:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  2115ad:	4c 89 e6             	mov    rsi,r12
  2115b0:	4c 89 ea             	mov    rdx,r13
  2115b3:	41 ff 14 24          	call   QWORD PTR [r12]
  2115b7:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
  2115bc:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
            const amt_read = try self.read(buf);
  2115c1:	66 85 c0             	test   ax,ax
  2115c4:	74 95                	je     21155b <parseFormValue+0x12bb>
  2115c6:	e9 f2 f7 ff ff       	jmp    210dbd <parseFormValue+0xb1d>
  2115cb:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  2115d0:	31 db                	xor    ebx,ebx
  2115d2:	4c 8d 6c 24 40       	lea    r13,[rsp+0x40]
  2115d7:	4c 8d 7c 24 18       	lea    r15,[rsp+0x18]
  2115dc:	31 ed                	xor    ebp,ebp
            if (amt_read < buf.len) return error.EndOfStream;
  2115de:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  2115e3:	0f 82 0f 05 00 00    	jb     211af8 <parseFormValue+0x1858>
            return result[0];
  2115e9:	0f b6 84 24 b0 00 00 	movzx  eax,BYTE PTR [rsp+0xb0]
  2115f0:	00 
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  2115f1:	89 c2                	mov    edx,eax
  2115f3:	83 e2 7f             	and    edx,0x7f
  2115f6:	89 ee                	mov    esi,ebp
  2115f8:	83 e6 3f             	and    esi,0x3f
  2115fb:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  211600:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  211605:	48 39 d6             	cmp    rsi,rdx
  211608:	0f 85 d9 06 00 00    	jne    211ce7 <parseFormValue+0x1a47>
        result |= operand;
  21160e:	48 09 cb             	or     rbx,rcx
        if ((byte & 0b10000000) == 0) return result;
  211611:	84 c0                	test   al,al
  211613:	0f 89 65 08 00 00    	jns    211e7e <parseFormValue+0x1bde>
        shift += 7;
  211619:	48 83 c5 07          	add    rbp,0x7
            try self.readNoEof(result[0..]);
  21161d:	4c 89 74 24 18       	mov    QWORD PTR [rsp+0x18],r14
  211622:	48 c7 44 24 20 01 00 	mov    QWORD PTR [rsp+0x20],0x1
  211629:	00 00 
            return self.readFn(self, buffer);
  21162b:	4c 89 ef             	mov    rdi,r13
  21162e:	4c 89 e6             	mov    rsi,r12
  211631:	4c 89 fa             	mov    rdx,r15
  211634:	41 ff 14 24          	call   QWORD PTR [r12]
  211638:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
  21163d:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
            const amt_read = try self.read(buf);
  211642:	66 85 c0             	test   ax,ax
  211645:	74 97                	je     2115de <parseFormValue+0x133e>
  211647:	e9 3a f8 ff ff       	jmp    210e86 <parseFormValue+0xbe6>
  21164c:	66 b8 1e 00          	mov    ax,0x1e
  211650:	e9 d2 ec ff ff       	jmp    210327 <parseFormValue+0x87>
  211655:	66 b8 23 00          	mov    ax,0x23
  211659:	e9 c9 ec ff ff       	jmp    210327 <parseFormValue+0x87>
  21165e:	48 8b 44 24 78       	mov    rax,QWORD PTR [rsp+0x78]
        DW.FORM_addr => FormValue{ .Address = try parseFormValueTargetAddrSize(in_stream) },
  211663:	66 c7 84 24 08 04 00 	mov    WORD PTR [rsp+0x408],0x0
  21166a:	00 00 00 
  21166d:	48 89 84 24 10 04 00 	mov    QWORD PTR [rsp+0x410],rax
  211674:	00 
  211675:	c5 f8 10 84 24 08 05 	vmovups xmm0,XMMWORD PTR [rsp+0x508]
  21167c:	00 00 
  21167e:	c5 f8 11 84 24 18 04 	vmovups XMMWORD PTR [rsp+0x418],xmm0
  211685:	00 00 
  211687:	c6 84 24 28 04 00 00 	mov    BYTE PTR [rsp+0x428],0x0
  21168e:	00 
  21168f:	8b 84 24 11 03 00 00 	mov    eax,DWORD PTR [rsp+0x311]
  211696:	89 84 24 29 04 00 00 	mov    DWORD PTR [rsp+0x429],eax
  21169d:	0f b7 84 24 15 03 00 	movzx  eax,WORD PTR [rsp+0x315]
  2116a4:	00 
  2116a5:	66 89 84 24 2d 04 00 	mov    WORD PTR [rsp+0x42d],ax
  2116ac:	00 
  2116ad:	8a 84 24 17 03 00 00 	mov    al,BYTE PTR [rsp+0x317]
  2116b4:	88 84 24 2f 04 00 00 	mov    BYTE PTR [rsp+0x42f],al
  2116bb:	48 8d 84 24 08 04 00 	lea    rax,[rsp+0x408]
  2116c2:	00 
  2116c3:	e9 de 05 00 00       	jmp    211ca6 <parseFormValue+0x1a06>
  2116c8:	48 85 c0             	test   rax,rax
            for (bytes) |b, index| {
  2116cb:	0f 84 00 08 00 00    	je     211ed1 <parseFormValue+0x1c31>
  2116d1:	48 8b 54 24 18       	mov    rdx,QWORD PTR [rsp+0x18]
  2116d6:	48 83 f8 10          	cmp    rax,0x10
  2116da:	0f 83 cc 0b 00 00    	jae    2122ac <parseFormValue+0x200c>
  2116e0:	31 db                	xor    ebx,ebx
  2116e2:	31 c9                	xor    ecx,ecx
  2116e4:	e9 b7 11 00 00       	jmp    2128a0 <parseFormValue+0x2600>
  2116e9:	48 85 c0             	test   rax,rax
  2116ec:	0f 84 e6 07 00 00    	je     211ed8 <parseFormValue+0x1c38>
  2116f2:	48 8b 54 24 18       	mov    rdx,QWORD PTR [rsp+0x18]
  2116f7:	48 83 f8 10          	cmp    rax,0x10
  2116fb:	0f 83 c9 0c 00 00    	jae    2123ca <parseFormValue+0x212a>
  211701:	31 db                	xor    ebx,ebx
  211703:	31 c9                	xor    ecx,ecx
  211705:	e9 77 13 00 00       	jmp    212a81 <parseFormValue+0x27e1>
  21170a:	48 85 c0             	test   rax,rax
  21170d:	0f 84 cc 07 00 00    	je     211edf <parseFormValue+0x1c3f>
  211713:	48 8b 54 24 18       	mov    rdx,QWORD PTR [rsp+0x18]
  211718:	48 83 f8 10          	cmp    rax,0x10
  21171c:	0f 83 c6 0d 00 00    	jae    2124e8 <parseFormValue+0x2248>
  211722:	31 db                	xor    ebx,ebx
  211724:	31 c9                	xor    ecx,ecx
  211726:	e9 37 15 00 00       	jmp    212c62 <parseFormValue+0x29c2>
        DW.FORM_flag => FormValue{ .Flag = (try in_stream.readByte()) != 0 },
  21172b:	80 bc 24 b0 00 00 00 	cmp    BYTE PTR [rsp+0xb0],0x0
  211732:	00 
  211733:	0f 95 84 24 08 01 00 	setne  BYTE PTR [rsp+0x108]
  21173a:	00 
  21173b:	66 c7 84 24 18 03 00 	mov    WORD PTR [rsp+0x318],0x0
  211742:	00 00 00 
  211745:	0f 95 84 24 20 03 00 	setne  BYTE PTR [rsp+0x320]
  21174c:	00 
  21174d:	c5 f8 10 84 24 69 04 	vmovups xmm0,XMMWORD PTR [rsp+0x469]
  211754:	00 00 
  211756:	c5 f8 11 84 24 21 03 	vmovups XMMWORD PTR [rsp+0x321],xmm0
  21175d:	00 00 
  21175f:	48 8b 84 24 78 04 00 	mov    rax,QWORD PTR [rsp+0x478]
  211766:	00 
  211767:	48 89 84 24 30 03 00 	mov    QWORD PTR [rsp+0x330],rax
  21176e:	00 
  21176f:	c6 84 24 38 03 00 00 	mov    BYTE PTR [rsp+0x338],0x4
  211776:	04 
  211777:	8b 84 24 03 03 00 00 	mov    eax,DWORD PTR [rsp+0x303]
  21177e:	89 84 24 39 03 00 00 	mov    DWORD PTR [rsp+0x339],eax
  211785:	0f b7 84 24 07 03 00 	movzx  eax,WORD PTR [rsp+0x307]
  21178c:	00 
  21178d:	66 89 84 24 3d 03 00 	mov    WORD PTR [rsp+0x33d],ax
  211794:	00 
  211795:	8a 84 24 09 03 00 00 	mov    al,BYTE PTR [rsp+0x309]
  21179c:	88 84 24 3f 03 00 00 	mov    BYTE PTR [rsp+0x33f],al
  2117a3:	48 8d 84 24 18 03 00 	lea    rax,[rsp+0x318]
  2117aa:	00 
  2117ab:	e9 f6 04 00 00       	jmp    211ca6 <parseFormValue+0x1a06>
            return mem.readInt(bytes, T, endian);
  2117b0:	0f b6 8c 24 b0 00 00 	movzx  ecx,BYTE PTR [rsp+0xb0]
  2117b7:	00 
  2117b8:	48 8d 7c 24 78       	lea    rdi,[rsp+0x78]
    const buf = try readAllocBytes(allocator, in_stream, size);
  2117bd:	4c 89 fe             	mov    rsi,r15
  2117c0:	4c 89 e2             	mov    rdx,r12
  2117c3:	e8 68 18 00 00       	call   213030 <readAllocBytes>
  2117c8:	0f b7 44 24 78       	movzx  eax,WORD PTR [rsp+0x78]
  2117cd:	66 85 c0             	test   ax,ax
  2117d0:	0f 84 10 07 00 00    	je     211ee6 <parseFormValue+0x1c46>
  2117d6:	c5 f8 10 44 24 40    	vmovups xmm0,XMMWORD PTR [rsp+0x40]
  2117dc:	c5 fa 6f 4c 24 4e    	vmovdqu xmm1,XMMWORD PTR [rsp+0x4e]
  2117e2:	c5 fa 7f 8c 24 9e 00 	vmovdqu XMMWORD PTR [rsp+0x9e],xmm1
  2117e9:	00 00 
  2117eb:	c5 f8 29 84 24 90 00 	vmovaps XMMWORD PTR [rsp+0x90],xmm0
  2117f2:	00 00 
  2117f4:	8b 4c 24 60          	mov    ecx,DWORD PTR [rsp+0x60]
  2117f8:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  2117fb:	0f b7 4c 24 64       	movzx  ecx,WORD PTR [rsp+0x64]
  211800:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  211805:	8a 4c 24 66          	mov    cl,BYTE PTR [rsp+0x66]
  211809:	88 4c 24 06          	mov    BYTE PTR [rsp+0x6],cl
  21180d:	e9 39 07 00 00       	jmp    211f4b <parseFormValue+0x1cab>
  211812:	0f b6 44 24 78       	movzx  eax,BYTE PTR [rsp+0x78]
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  211817:	0f b6 4c 24 79       	movzx  ecx,BYTE PTR [rsp+0x79]
  21181c:	48 c1 e1 08          	shl    rcx,0x8
  211820:	48 09 c1             	or     rcx,rax
  211823:	48 8d 7c 24 78       	lea    rdi,[rsp+0x78]
  211828:	4c 89 fe             	mov    rsi,r15
  21182b:	4c 89 e2             	mov    rdx,r12
  21182e:	e8 fd 17 00 00       	call   213030 <readAllocBytes>
  211833:	0f b7 44 24 78       	movzx  eax,WORD PTR [rsp+0x78]
  211838:	66 85 c0             	test   ax,ax
  21183b:	0f 84 5d 07 00 00    	je     211f9e <parseFormValue+0x1cfe>
  211841:	c5 f8 10 44 24 40    	vmovups xmm0,XMMWORD PTR [rsp+0x40]
  211847:	c5 fa 6f 4c 24 4e    	vmovdqu xmm1,XMMWORD PTR [rsp+0x4e]
  21184d:	c5 fa 7f 8c 24 9e 00 	vmovdqu XMMWORD PTR [rsp+0x9e],xmm1
  211854:	00 00 
  211856:	c5 f8 29 84 24 90 00 	vmovaps XMMWORD PTR [rsp+0x90],xmm0
  21185d:	00 00 
  21185f:	8b 4c 24 60          	mov    ecx,DWORD PTR [rsp+0x60]
  211863:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  211866:	0f b7 4c 24 64       	movzx  ecx,WORD PTR [rsp+0x64]
  21186b:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  211870:	8a 4c 24 66          	mov    cl,BYTE PTR [rsp+0x66]
  211874:	88 4c 24 06          	mov    BYTE PTR [rsp+0x6],cl
  211878:	e9 86 07 00 00       	jmp    212003 <parseFormValue+0x1d63>
  21187d:	0f b6 44 24 78       	movzx  eax,BYTE PTR [rsp+0x78]
  211882:	0f b6 4c 24 79       	movzx  ecx,BYTE PTR [rsp+0x79]
  211887:	48 c1 e1 08          	shl    rcx,0x8
  21188b:	48 09 c1             	or     rcx,rax
  21188e:	0f b6 44 24 7a       	movzx  eax,BYTE PTR [rsp+0x7a]
  211893:	48 c1 e0 10          	shl    rax,0x10
  211897:	48 09 c8             	or     rax,rcx
  21189a:	0f b6 4c 24 7b       	movzx  ecx,BYTE PTR [rsp+0x7b]
  21189f:	48 c1 e1 18          	shl    rcx,0x18
  2118a3:	48 09 c1             	or     rcx,rax
  2118a6:	48 8d 7c 24 78       	lea    rdi,[rsp+0x78]
  2118ab:	4c 89 fe             	mov    rsi,r15
  2118ae:	4c 89 e2             	mov    rdx,r12
  2118b1:	e8 7a 17 00 00       	call   213030 <readAllocBytes>
  2118b6:	0f b7 44 24 78       	movzx  eax,WORD PTR [rsp+0x78]
  2118bb:	66 85 c0             	test   ax,ax
  2118be:	0f 84 92 07 00 00    	je     212056 <parseFormValue+0x1db6>
  2118c4:	c5 f8 10 44 24 40    	vmovups xmm0,XMMWORD PTR [rsp+0x40]
  2118ca:	c5 fa 6f 4c 24 4e    	vmovdqu xmm1,XMMWORD PTR [rsp+0x4e]
  2118d0:	c5 fa 7f 8c 24 9e 00 	vmovdqu XMMWORD PTR [rsp+0x9e],xmm1
  2118d7:	00 00 
  2118d9:	c5 f8 29 84 24 90 00 	vmovaps XMMWORD PTR [rsp+0x90],xmm0
  2118e0:	00 00 
  2118e2:	8b 4c 24 60          	mov    ecx,DWORD PTR [rsp+0x60]
  2118e6:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  2118e9:	0f b7 4c 24 64       	movzx  ecx,WORD PTR [rsp+0x64]
  2118ee:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  2118f3:	8a 4c 24 66          	mov    cl,BYTE PTR [rsp+0x66]
  2118f7:	88 4c 24 06          	mov    BYTE PTR [rsp+0x6],cl
  2118fb:	e9 bb 07 00 00       	jmp    2120bb <parseFormValue+0x1e1b>
  211900:	48 8b 4c 24 78       	mov    rcx,QWORD PTR [rsp+0x78]
  211905:	48 8d 7c 24 78       	lea    rdi,[rsp+0x78]
  21190a:	4c 89 fe             	mov    rsi,r15
  21190d:	4c 89 e2             	mov    rdx,r12
  211910:	e8 1b 17 00 00       	call   213030 <readAllocBytes>
  211915:	0f b7 44 24 78       	movzx  eax,WORD PTR [rsp+0x78]
  21191a:	66 85 c0             	test   ax,ax
  21191d:	0f 84 eb 07 00 00    	je     21210e <parseFormValue+0x1e6e>
  211923:	c5 f8 10 44 24 40    	vmovups xmm0,XMMWORD PTR [rsp+0x40]
  211929:	c5 fa 6f 4c 24 4e    	vmovdqu xmm1,XMMWORD PTR [rsp+0x4e]
  21192f:	c5 fa 7f 8c 24 9e 00 	vmovdqu XMMWORD PTR [rsp+0x9e],xmm1
  211936:	00 00 
  211938:	c5 f8 29 84 24 90 00 	vmovaps XMMWORD PTR [rsp+0x90],xmm0
  21193f:	00 00 
  211941:	8b 4c 24 60          	mov    ecx,DWORD PTR [rsp+0x60]
  211945:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  211948:	0f b7 4c 24 64       	movzx  ecx,WORD PTR [rsp+0x64]
  21194d:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  211952:	8a 4c 24 66          	mov    cl,BYTE PTR [rsp+0x66]
  211956:	88 4c 24 06          	mov    BYTE PTR [rsp+0x6],cl
  21195a:	e9 14 08 00 00       	jmp    212173 <parseFormValue+0x1ed3>
  21195f:	48 8b 44 24 78       	mov    rax,QWORD PTR [rsp+0x78]
        DW.FORM_ref_sig8 => FormValue{ .RefSig8 = try in_stream.readIntLe(u64) },
  211964:	66 c7 84 24 90 03 00 	mov    WORD PTR [rsp+0x390],0x0
  21196b:	00 00 00 
  21196e:	48 89 84 24 98 03 00 	mov    QWORD PTR [rsp+0x398],rax
  211975:	00 
  211976:	c5 f8 10 84 24 d8 04 	vmovups xmm0,XMMWORD PTR [rsp+0x4d8]
  21197d:	00 00 
  21197f:	c5 f8 11 84 24 a0 03 	vmovups XMMWORD PTR [rsp+0x3a0],xmm0
  211986:	00 00 
  211988:	c6 84 24 b0 03 00 00 	mov    BYTE PTR [rsp+0x3b0],0x8
  21198f:	08 
  211990:	8b 84 24 ee 02 00 00 	mov    eax,DWORD PTR [rsp+0x2ee]
  211997:	89 84 24 b1 03 00 00 	mov    DWORD PTR [rsp+0x3b1],eax
  21199e:	0f b7 84 24 f2 02 00 	movzx  eax,WORD PTR [rsp+0x2f2]
  2119a5:	00 
  2119a6:	66 89 84 24 b5 03 00 	mov    WORD PTR [rsp+0x3b5],ax
  2119ad:	00 
  2119ae:	8a 84 24 f4 02 00 00 	mov    al,BYTE PTR [rsp+0x2f4]
  2119b5:	88 84 24 b7 03 00 00 	mov    BYTE PTR [rsp+0x3b7],al
  2119bc:	48 8d 84 24 90 03 00 	lea    rax,[rsp+0x390]
  2119c3:	00 
  2119c4:	e9 dd 02 00 00       	jmp    211ca6 <parseFormValue+0x1a06>
  2119c9:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
            .payload = try readAllocBytes(allocator, in_stream, size),
  2119ce:	48 8b b4 24 d0 00 00 	mov    rsi,QWORD PTR [rsp+0xd0]
  2119d5:	00 
  2119d6:	4c 89 e2             	mov    rdx,r12
  2119d9:	48 89 e9             	mov    rcx,rbp
  2119dc:	e8 4f 16 00 00       	call   213030 <readAllocBytes>
  2119e1:	0f b7 54 24 40       	movzx  edx,WORD PTR [rsp+0x40]
  2119e6:	66 85 d2             	test   dx,dx
  2119e9:	48 8b 6c 24 68       	mov    rbp,QWORD PTR [rsp+0x68]
  2119ee:	0f 84 d2 07 00 00    	je     2121c6 <parseFormValue+0x1f26>
  2119f4:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  2119f9:	66 89 84 24 1c 01 00 	mov    WORD PTR [rsp+0x11c],ax
  211a00:	00 
  211a01:	8b 44 24 3a          	mov    eax,DWORD PTR [rsp+0x3a]
  211a05:	89 84 24 18 01 00 00 	mov    DWORD PTR [rsp+0x118],eax
  211a0c:	8b 44 24 11          	mov    eax,DWORD PTR [rsp+0x11]
  211a10:	89 84 24 f0 00 00 00 	mov    DWORD PTR [rsp+0xf0],eax
  211a17:	0f b7 44 24 15       	movzx  eax,WORD PTR [rsp+0x15]
  211a1c:	66 89 84 24 f4 00 00 	mov    WORD PTR [rsp+0xf4],ax
  211a23:	00 
  211a24:	8a 44 24 17          	mov    al,BYTE PTR [rsp+0x17]
  211a28:	88 84 24 f6 00 00 00 	mov    BYTE PTR [rsp+0xf6],al
  211a2f:	48 8d b4 24 18 01 00 	lea    rsi,[rsp+0x118]
  211a36:	00 
  211a37:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  211a3b:	89 84 24 e8 00 00 00 	mov    DWORD PTR [rsp+0xe8],eax
  211a42:	48 8d 84 24 f0 00 00 	lea    rax,[rsp+0xf0]
  211a49:	00 
  211a4a:	0f b7 4c 24 0e       	movzx  ecx,WORD PTR [rsp+0xe]
  211a4f:	66 89 8c 24 ec 00 00 	mov    WORD PTR [rsp+0xec],cx
  211a56:	00 
  211a57:	48 8d 8c 24 e8 00 00 	lea    rcx,[rsp+0xe8]
  211a5e:	00 
  211a5f:	8a 5c 24 10          	mov    bl,BYTE PTR [rsp+0x10]
  211a63:	88 9c 24 ee 00 00 00 	mov    BYTE PTR [rsp+0xee],bl
  211a6a:	e9 f5 07 00 00       	jmp    212264 <parseFormValue+0x1fc4>
  211a6f:	66 b8 1e 00          	mov    ax,0x1e
  211a73:	e9 c5 ec ff ff       	jmp    21073d <parseFormValue+0x49d>
            return self.items[0..self.len];
  211a78:	48 8b 44 24 40       	mov    rax,QWORD PTR [rsp+0x40]
        DW.FORM_string => FormValue{ .String = try readStringRaw(allocator, in_stream) },
  211a7d:	66 c7 84 24 68 03 00 	mov    WORD PTR [rsp+0x368],0x0
  211a84:	00 00 00 
  211a87:	48 89 84 24 70 03 00 	mov    QWORD PTR [rsp+0x370],rax
  211a8e:	00 
  211a8f:	48 89 ac 24 78 03 00 	mov    QWORD PTR [rsp+0x378],rbp
  211a96:	00 
  211a97:	c6 84 24 88 03 00 00 	mov    BYTE PTR [rsp+0x388],0x9
  211a9e:	09 
  211a9f:	8b 84 24 e7 02 00 00 	mov    eax,DWORD PTR [rsp+0x2e7]
  211aa6:	89 84 24 89 03 00 00 	mov    DWORD PTR [rsp+0x389],eax
  211aad:	0f b7 84 24 eb 02 00 	movzx  eax,WORD PTR [rsp+0x2eb]
  211ab4:	00 
  211ab5:	66 89 84 24 8d 03 00 	mov    WORD PTR [rsp+0x38d],ax
  211abc:	00 
  211abd:	8a 84 24 ed 02 00 00 	mov    al,BYTE PTR [rsp+0x2ed]
  211ac4:	88 84 24 8f 03 00 00 	mov    BYTE PTR [rsp+0x38f],al
  211acb:	48 8d 84 24 68 03 00 	lea    rax,[rsp+0x368]
  211ad2:	00 
  211ad3:	4c 8b 74 24 68       	mov    r14,QWORD PTR [rsp+0x68]
  211ad8:	e9 c9 01 00 00       	jmp    211ca6 <parseFormValue+0x1a06>
  211add:	66 b8 1e 00          	mov    ax,0x1e
  211ae1:	e9 c0 ec ff ff       	jmp    2107a6 <parseFormValue+0x506>
  211ae6:	66 b8 1e 00          	mov    ax,0x1e
  211aea:	e9 65 f2 ff ff       	jmp    210d54 <parseFormValue+0xab4>
  211aef:	66 b8 1e 00          	mov    ax,0x1e
  211af3:	e9 c5 f2 ff ff       	jmp    210dbd <parseFormValue+0xb1d>
  211af8:	66 b8 1e 00          	mov    ax,0x1e
  211afc:	e9 85 f3 ff ff       	jmp    210e86 <parseFormValue+0xbe6>
  211b01:	0f b6 44 24 78       	movzx  eax,BYTE PTR [rsp+0x78]
  211b06:	0f b6 4c 24 79       	movzx  ecx,BYTE PTR [rsp+0x79]
  211b0b:	48 c1 e1 08          	shl    rcx,0x8
  211b0f:	48 09 c1             	or     rcx,rax
  211b12:	0f b6 54 24 7a       	movzx  edx,BYTE PTR [rsp+0x7a]
  211b17:	48 c1 e2 10          	shl    rdx,0x10
  211b1b:	48 09 ca             	or     rdx,rcx
  211b1e:	0f b6 44 24 7b       	movzx  eax,BYTE PTR [rsp+0x7b]
  211b23:	48 c1 e0 18          	shl    rax,0x18
  211b27:	48 09 d0             	or     rax,rdx
        DW.FORM_strp => FormValue{ .StrPtr = try parseFormValueDwarfOffsetSize(in_stream, is_64) },
  211b2a:	66 c7 84 24 40 03 00 	mov    WORD PTR [rsp+0x340],0x0
  211b31:	00 00 00 
  211b34:	48 89 84 24 48 03 00 	mov    QWORD PTR [rsp+0x348],rax
  211b3b:	00 
  211b3c:	c5 f8 10 84 24 c8 04 	vmovups xmm0,XMMWORD PTR [rsp+0x4c8]
  211b43:	00 00 
  211b45:	c5 f8 11 84 24 50 03 	vmovups XMMWORD PTR [rsp+0x350],xmm0
  211b4c:	00 00 
  211b4e:	c6 84 24 60 03 00 00 	mov    BYTE PTR [rsp+0x360],0xa
  211b55:	0a 
  211b56:	8b 84 24 e0 02 00 00 	mov    eax,DWORD PTR [rsp+0x2e0]
  211b5d:	89 84 24 61 03 00 00 	mov    DWORD PTR [rsp+0x361],eax
  211b64:	0f b7 84 24 e4 02 00 	movzx  eax,WORD PTR [rsp+0x2e4]
  211b6b:	00 
  211b6c:	66 89 84 24 65 03 00 	mov    WORD PTR [rsp+0x365],ax
  211b73:	00 
  211b74:	8a 84 24 e6 02 00 00 	mov    al,BYTE PTR [rsp+0x2e6]
  211b7b:	88 84 24 67 03 00 00 	mov    BYTE PTR [rsp+0x367],al
  211b82:	48 8d 84 24 40 03 00 	lea    rax,[rsp+0x340]
  211b89:	00 
  211b8a:	e9 17 01 00 00       	jmp    211ca6 <parseFormValue+0x1a06>
  211b8f:	0f b6 44 24 78       	movzx  eax,BYTE PTR [rsp+0x78]
  211b94:	0f b6 4c 24 79       	movzx  ecx,BYTE PTR [rsp+0x79]
  211b99:	48 c1 e1 08          	shl    rcx,0x8
  211b9d:	48 09 c1             	or     rcx,rax
  211ba0:	0f b6 54 24 7a       	movzx  edx,BYTE PTR [rsp+0x7a]
  211ba5:	48 c1 e2 10          	shl    rdx,0x10
  211ba9:	48 09 ca             	or     rdx,rcx
  211bac:	0f b6 44 24 7b       	movzx  eax,BYTE PTR [rsp+0x7b]
  211bb1:	48 c1 e0 18          	shl    rax,0x18
  211bb5:	48 09 d0             	or     rax,rdx
        DW.FORM_ref_addr => FormValue{ .RefAddr = try parseFormValueDwarfOffsetSize(in_stream, is_64) },
  211bb8:	66 c7 84 24 b8 03 00 	mov    WORD PTR [rsp+0x3b8],0x0
  211bbf:	00 00 00 
  211bc2:	48 89 84 24 c0 03 00 	mov    QWORD PTR [rsp+0x3c0],rax
  211bc9:	00 
  211bca:	c5 f8 10 84 24 e8 04 	vmovups xmm0,XMMWORD PTR [rsp+0x4e8]
  211bd1:	00 00 
  211bd3:	c5 f8 11 84 24 c8 03 	vmovups XMMWORD PTR [rsp+0x3c8],xmm0
  211bda:	00 00 
  211bdc:	c6 84 24 d8 03 00 00 	mov    BYTE PTR [rsp+0x3d8],0x7
  211be3:	07 
  211be4:	8b 84 24 f5 02 00 00 	mov    eax,DWORD PTR [rsp+0x2f5]
  211beb:	89 84 24 d9 03 00 00 	mov    DWORD PTR [rsp+0x3d9],eax
  211bf2:	0f b7 84 24 f9 02 00 	movzx  eax,WORD PTR [rsp+0x2f9]
  211bf9:	00 
  211bfa:	66 89 84 24 dd 03 00 	mov    WORD PTR [rsp+0x3dd],ax
  211c01:	00 
  211c02:	8a 84 24 fb 02 00 00 	mov    al,BYTE PTR [rsp+0x2fb]
  211c09:	88 84 24 df 03 00 00 	mov    BYTE PTR [rsp+0x3df],al
  211c10:	48 8d 84 24 b8 03 00 	lea    rax,[rsp+0x3b8]
  211c17:	00 
  211c18:	e9 89 00 00 00       	jmp    211ca6 <parseFormValue+0x1a06>
  211c1d:	0f b6 44 24 78       	movzx  eax,BYTE PTR [rsp+0x78]
  211c22:	0f b6 4c 24 79       	movzx  ecx,BYTE PTR [rsp+0x79]
  211c27:	48 c1 e1 08          	shl    rcx,0x8
  211c2b:	48 09 c1             	or     rcx,rax
  211c2e:	0f b6 54 24 7a       	movzx  edx,BYTE PTR [rsp+0x7a]
  211c33:	48 c1 e2 10          	shl    rdx,0x10
  211c37:	48 09 ca             	or     rdx,rcx
  211c3a:	0f b6 44 24 7b       	movzx  eax,BYTE PTR [rsp+0x7b]
  211c3f:	48 c1 e0 18          	shl    rax,0x18
  211c43:	48 09 d0             	or     rax,rdx
        DW.FORM_sec_offset => FormValue{ .SecOffset = try parseFormValueDwarfOffsetSize(in_stream, is_64) },
  211c46:	66 c7 84 24 e0 03 00 	mov    WORD PTR [rsp+0x3e0],0x0
  211c4d:	00 00 00 
  211c50:	48 89 84 24 e8 03 00 	mov    QWORD PTR [rsp+0x3e8],rax
  211c57:	00 
  211c58:	c5 f8 10 84 24 f8 04 	vmovups xmm0,XMMWORD PTR [rsp+0x4f8]
  211c5f:	00 00 
  211c61:	c5 f8 11 84 24 f0 03 	vmovups XMMWORD PTR [rsp+0x3f0],xmm0
  211c68:	00 00 
  211c6a:	c6 84 24 00 04 00 00 	mov    BYTE PTR [rsp+0x400],0x5
  211c71:	05 
  211c72:	8b 84 24 fc 02 00 00 	mov    eax,DWORD PTR [rsp+0x2fc]
  211c79:	89 84 24 01 04 00 00 	mov    DWORD PTR [rsp+0x401],eax
  211c80:	0f b7 84 24 00 03 00 	movzx  eax,WORD PTR [rsp+0x300]
  211c87:	00 
  211c88:	66 89 84 24 05 04 00 	mov    WORD PTR [rsp+0x405],ax
  211c8f:	00 
  211c90:	8a 84 24 02 03 00 00 	mov    al,BYTE PTR [rsp+0x302]
  211c97:	88 84 24 07 04 00 00 	mov    BYTE PTR [rsp+0x407],al
  211c9e:	48 8d 84 24 e0 03 00 	lea    rax,[rsp+0x3e0]
  211ca5:	00 
    return switch (form_id) {
  211ca6:	48 8b 48 20          	mov    rcx,QWORD PTR [rax+0x20]
  211caa:	49 89 4e 20          	mov    QWORD PTR [r14+0x20],rcx
  211cae:	c5 fc 10 00          	vmovups ymm0,YMMWORD PTR [rax]
  211cb2:	c4 c1 7c 11 06       	vmovups YMMWORD PTR [r14],ymm0
  211cb7:	48 81 c4 08 07 00 00 	add    rsp,0x708
  211cbe:	5b                   	pop    rbx
  211cbf:	41 5c                	pop    r12
  211cc1:	41 5d                	pop    r13
  211cc3:	41 5e                	pop    r14
  211cc5:	41 5f                	pop    r15
  211cc7:	5d                   	pop    rbp
  211cc8:	c5 f8 77             	vzeroupper 
  211ccb:	c3                   	ret    
  211ccc:	66 b8 23 00          	mov    ax,0x23
  211cd0:	e9 d1 ea ff ff       	jmp    2107a6 <parseFormValue+0x506>
  211cd5:	66 b8 23 00          	mov    ax,0x23
  211cd9:	e9 76 f0 ff ff       	jmp    210d54 <parseFormValue+0xab4>
  211cde:	66 b8 23 00          	mov    ax,0x23
  211ce2:	e9 d6 f0 ff ff       	jmp    210dbd <parseFormValue+0xb1d>
  211ce7:	66 b8 23 00          	mov    ax,0x23
  211ceb:	e9 96 f1 ff ff       	jmp    210e86 <parseFormValue+0xbe6>
  211cf0:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
    const buf = try readAllocBytes(allocator, in_stream, size);
  211cf5:	48 8b b4 24 d0 00 00 	mov    rsi,QWORD PTR [rsp+0xd0]
  211cfc:	00 
  211cfd:	4c 89 e2             	mov    rdx,r12
  211d00:	48 89 d9             	mov    rcx,rbx
  211d03:	e8 28 13 00 00       	call   213030 <readAllocBytes>
  211d08:	0f b7 4c 24 40       	movzx  ecx,WORD PTR [rsp+0x40]
  211d0d:	66 85 c9             	test   cx,cx
  211d10:	48 8b 7c 24 68       	mov    rdi,QWORD PTR [rsp+0x68]
  211d15:	0f 84 eb 08 00 00    	je     212606 <parseFormValue+0x2366>
  211d1b:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  211d20:	66 89 84 24 24 01 00 	mov    WORD PTR [rsp+0x124],ax
  211d27:	00 
  211d28:	8b 44 24 3a          	mov    eax,DWORD PTR [rsp+0x3a]
  211d2c:	89 84 24 20 01 00 00 	mov    DWORD PTR [rsp+0x120],eax
  211d33:	8b 44 24 11          	mov    eax,DWORD PTR [rsp+0x11]
  211d37:	89 84 24 00 01 00 00 	mov    DWORD PTR [rsp+0x100],eax
  211d3e:	0f b7 44 24 15       	movzx  eax,WORD PTR [rsp+0x15]
  211d43:	66 89 84 24 04 01 00 	mov    WORD PTR [rsp+0x104],ax
  211d4a:	00 
  211d4b:	8a 44 24 17          	mov    al,BYTE PTR [rsp+0x17]
  211d4f:	88 84 24 06 01 00 00 	mov    BYTE PTR [rsp+0x106],al
  211d56:	48 8d b4 24 20 01 00 	lea    rsi,[rsp+0x120]
  211d5d:	00 
  211d5e:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  211d62:	89 84 24 f8 00 00 00 	mov    DWORD PTR [rsp+0xf8],eax
  211d69:	48 8d 84 24 00 01 00 	lea    rax,[rsp+0x100]
  211d70:	00 
  211d71:	0f b7 54 24 0e       	movzx  edx,WORD PTR [rsp+0xe]
  211d76:	66 89 94 24 fc 00 00 	mov    WORD PTR [rsp+0xfc],dx
  211d7d:	00 
  211d7e:	48 8d 94 24 f8 00 00 	lea    rdx,[rsp+0xf8]
  211d85:	00 
  211d86:	8a 5c 24 10          	mov    bl,BYTE PTR [rsp+0x10]
  211d8a:	88 9c 24 fe 00 00 00 	mov    BYTE PTR [rsp+0xfe],bl
  211d91:	e9 a1 00 00 00       	jmp    211e37 <parseFormValue+0x1b97>
  211d96:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
    const buf = try readAllocBytes(allocator, in_stream, size);
  211d9b:	48 8b b4 24 d0 00 00 	mov    rsi,QWORD PTR [rsp+0xd0]
  211da2:	00 
  211da3:	4c 89 e2             	mov    rdx,r12
  211da6:	48 89 d9             	mov    rcx,rbx
  211da9:	e8 82 12 00 00       	call   213030 <readAllocBytes>
  211dae:	0f b7 4c 24 40       	movzx  ecx,WORD PTR [rsp+0x40]
  211db3:	66 85 c9             	test   cx,cx
  211db6:	48 8b 7c 24 68       	mov    rdi,QWORD PTR [rsp+0x68]
  211dbb:	0f 84 d9 08 00 00    	je     21269a <parseFormValue+0x23fa>
  211dc1:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  211dc6:	66 89 84 24 14 01 00 	mov    WORD PTR [rsp+0x114],ax
  211dcd:	00 
  211dce:	8b 44 24 3a          	mov    eax,DWORD PTR [rsp+0x3a]
  211dd2:	89 84 24 10 01 00 00 	mov    DWORD PTR [rsp+0x110],eax
  211dd9:	8b 44 24 11          	mov    eax,DWORD PTR [rsp+0x11]
  211ddd:	89 84 24 e0 00 00 00 	mov    DWORD PTR [rsp+0xe0],eax
  211de4:	0f b7 44 24 15       	movzx  eax,WORD PTR [rsp+0x15]
  211de9:	66 89 84 24 e4 00 00 	mov    WORD PTR [rsp+0xe4],ax
  211df0:	00 
  211df1:	8a 44 24 17          	mov    al,BYTE PTR [rsp+0x17]
  211df5:	88 84 24 e6 00 00 00 	mov    BYTE PTR [rsp+0xe6],al
  211dfc:	48 8d b4 24 10 01 00 	lea    rsi,[rsp+0x110]
  211e03:	00 
  211e04:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  211e08:	89 84 24 d8 00 00 00 	mov    DWORD PTR [rsp+0xd8],eax
  211e0f:	48 8d 84 24 e0 00 00 	lea    rax,[rsp+0xe0]
  211e16:	00 
  211e17:	0f b7 54 24 0e       	movzx  edx,WORD PTR [rsp+0xe]
  211e1c:	66 89 94 24 dc 00 00 	mov    WORD PTR [rsp+0xdc],dx
  211e23:	00 
  211e24:	48 8d 94 24 d8 00 00 	lea    rdx,[rsp+0xd8]
  211e2b:	00 
  211e2c:	8a 5c 24 10          	mov    bl,BYTE PTR [rsp+0x10]
  211e30:	88 9c 24 de 00 00 00 	mov    BYTE PTR [rsp+0xde],bl
  211e37:	e9 ef 08 00 00       	jmp    21272b <parseFormValue+0x248b>
            return parseFormValue(allocator, in_stream, child_form_id, is_64);
  211e3c:	44 0f b6 c5          	movzx  r8d,bpl
  211e40:	48 8d bc 24 a0 04 00 	lea    rdi,[rsp+0x4a0]
  211e47:	00 
  211e48:	48 8b b4 24 d0 00 00 	mov    rsi,QWORD PTR [rsp+0xd0]
  211e4f:	00 
  211e50:	4c 89 e2             	mov    rdx,r12
  211e53:	4c 89 f1             	mov    rcx,r14
  211e56:	e8 45 e4 ff ff       	call   2102a0 <parseFormValue>
  211e5b:	48 8b 84 24 c0 04 00 	mov    rax,QWORD PTR [rsp+0x4c0]
  211e62:	00 
  211e63:	48 8b 4c 24 68       	mov    rcx,QWORD PTR [rsp+0x68]
  211e68:	48 89 41 20          	mov    QWORD PTR [rcx+0x20],rax
  211e6c:	c5 fc 10 84 24 a0 04 	vmovups ymm0,YMMWORD PTR [rsp+0x4a0]
  211e73:	00 00 
  211e75:	c5 fc 11 01          	vmovups YMMWORD PTR [rcx],ymm0
  211e79:	e9 39 fe ff ff       	jmp    211cb7 <parseFormValue+0x1a17>
  211e7e:	48 8d bc 24 50 04 00 	lea    rdi,[rsp+0x450]
  211e85:	00 
            const buf = try readAllocBytes(allocator, in_stream, size);
  211e86:	48 8b b4 24 d0 00 00 	mov    rsi,QWORD PTR [rsp+0xd0]
  211e8d:	00 
  211e8e:	4c 89 e2             	mov    rdx,r12
  211e91:	48 89 d9             	mov    rcx,rbx
  211e94:	e8 97 11 00 00       	call   213030 <readAllocBytes>
  211e99:	0f b7 84 24 50 04 00 	movzx  eax,WORD PTR [rsp+0x450]
  211ea0:	00 
  211ea1:	66 85 c0             	test   ax,ax
  211ea4:	0f 84 c4 08 00 00    	je     21276e <parseFormValue+0x24ce>
  211eaa:	48 8b 4c 24 68       	mov    rcx,QWORD PTR [rsp+0x68]
  211eaf:	66 89 01             	mov    WORD PTR [rcx],ax
  211eb2:	48 8b 84 24 68 06 00 	mov    rax,QWORD PTR [rsp+0x668]
  211eb9:	00 
  211eba:	48 89 41 20          	mov    QWORD PTR [rcx+0x20],rax
  211ebe:	c5 fc 10 84 24 4a 06 	vmovups ymm0,YMMWORD PTR [rsp+0x64a]
  211ec5:	00 00 
  211ec7:	c5 fc 11 41 02       	vmovups YMMWORD PTR [rcx+0x2],ymm0
  211ecc:	e9 e6 fd ff ff       	jmp    211cb7 <parseFormValue+0x1a17>
  211ed1:	31 c9                	xor    ecx,ecx
  211ed3:	e9 f1 09 00 00       	jmp    2128c9 <parseFormValue+0x2629>
  211ed8:	31 c9                	xor    ecx,ecx
  211eda:	e9 cb 0b 00 00       	jmp    212aaa <parseFormValue+0x280a>
  211edf:	31 c9                	xor    ecx,ecx
  211ee1:	e9 a5 0d 00 00       	jmp    212c8b <parseFormValue+0x29eb>
    const buf = try readAllocBytes(allocator, in_stream, size);
  211ee6:	c5 f8 10 84 24 80 00 	vmovups xmm0,XMMWORD PTR [rsp+0x80]
  211eed:	00 00 
  211eef:	c5 f8 29 84 24 b0 00 	vmovaps XMMWORD PTR [rsp+0xb0],xmm0
  211ef6:	00 00 
    return FormValue{ .Ref = buf };
  211ef8:	c5 f8 11 44 24 1e    	vmovups XMMWORD PTR [rsp+0x1e],xmm0
  211efe:	48 8b 84 24 c0 00 00 	mov    rax,QWORD PTR [rsp+0xc0]
  211f05:	00 
  211f06:	48 89 44 24 2e       	mov    QWORD PTR [rsp+0x2e],rax
  211f0b:	c6 44 24 08 06       	mov    BYTE PTR [rsp+0x8],0x6
  211f10:	8b 44 24 71          	mov    eax,DWORD PTR [rsp+0x71]
  211f14:	89 04 24             	mov    DWORD PTR [rsp],eax
  211f17:	0f b7 44 24 75       	movzx  eax,WORD PTR [rsp+0x75]
  211f1c:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  211f21:	8a 44 24 77          	mov    al,BYTE PTR [rsp+0x77]
  211f25:	88 44 24 06          	mov    BYTE PTR [rsp+0x6],al
  211f29:	c5 f8 10 44 24 18    	vmovups xmm0,XMMWORD PTR [rsp+0x18]
  211f2f:	c5 f8 29 84 24 90 00 	vmovaps XMMWORD PTR [rsp+0x90],xmm0
  211f36:	00 00 
  211f38:	c5 f8 10 44 24 26    	vmovups xmm0,XMMWORD PTR [rsp+0x26]
  211f3e:	c5 f8 11 84 24 9e 00 	vmovups XMMWORD PTR [rsp+0x9e],xmm0
  211f45:	00 00 
  211f47:	b1 06                	mov    cl,0x6
  211f49:	31 c0                	xor    eax,eax
    return parseFormValueRefLen(allocator, in_stream, block_len);
  211f4b:	66 89 84 24 40 02 00 	mov    WORD PTR [rsp+0x240],ax
  211f52:	00 
  211f53:	c5 f8 28 84 24 90 00 	vmovaps xmm0,XMMWORD PTR [rsp+0x90]
  211f5a:	00 00 
  211f5c:	c5 f8 11 84 24 42 02 	vmovups XMMWORD PTR [rsp+0x242],xmm0
  211f63:	00 00 
  211f65:	c5 f8 10 84 24 9e 00 	vmovups xmm0,XMMWORD PTR [rsp+0x9e]
  211f6c:	00 00 
  211f6e:	c5 f8 11 84 24 50 02 	vmovups XMMWORD PTR [rsp+0x250],xmm0
  211f75:	00 00 
  211f77:	88 8c 24 60 02 00 00 	mov    BYTE PTR [rsp+0x260],cl
  211f7e:	8b 04 24             	mov    eax,DWORD PTR [rsp]
  211f81:	89 84 24 61 02 00 00 	mov    DWORD PTR [rsp+0x261],eax
  211f88:	0f b7 44 24 04       	movzx  eax,WORD PTR [rsp+0x4]
  211f8d:	66 89 84 24 65 02 00 	mov    WORD PTR [rsp+0x265],ax
  211f94:	00 
  211f95:	8a 44 24 06          	mov    al,BYTE PTR [rsp+0x6]
  211f99:	e9 41 eb ff ff       	jmp    210adf <parseFormValue+0x83f>
    const buf = try readAllocBytes(allocator, in_stream, size);
  211f9e:	c5 f8 10 84 24 80 00 	vmovups xmm0,XMMWORD PTR [rsp+0x80]
  211fa5:	00 00 
  211fa7:	c5 f8 29 84 24 b0 00 	vmovaps XMMWORD PTR [rsp+0xb0],xmm0
  211fae:	00 00 
    return FormValue{ .Ref = buf };
  211fb0:	c5 f8 11 44 24 1e    	vmovups XMMWORD PTR [rsp+0x1e],xmm0
  211fb6:	48 8b 84 24 c0 00 00 	mov    rax,QWORD PTR [rsp+0xc0]
  211fbd:	00 
  211fbe:	48 89 44 24 2e       	mov    QWORD PTR [rsp+0x2e],rax
  211fc3:	c6 44 24 08 06       	mov    BYTE PTR [rsp+0x8],0x6
  211fc8:	8b 44 24 71          	mov    eax,DWORD PTR [rsp+0x71]
  211fcc:	89 04 24             	mov    DWORD PTR [rsp],eax
  211fcf:	0f b7 44 24 75       	movzx  eax,WORD PTR [rsp+0x75]
  211fd4:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  211fd9:	8a 44 24 77          	mov    al,BYTE PTR [rsp+0x77]
  211fdd:	88 44 24 06          	mov    BYTE PTR [rsp+0x6],al
  211fe1:	c5 f8 10 44 24 18    	vmovups xmm0,XMMWORD PTR [rsp+0x18]
  211fe7:	c5 f8 29 84 24 90 00 	vmovaps XMMWORD PTR [rsp+0x90],xmm0
  211fee:	00 00 
  211ff0:	c5 f8 10 44 24 26    	vmovups xmm0,XMMWORD PTR [rsp+0x26]
  211ff6:	c5 f8 11 84 24 9e 00 	vmovups XMMWORD PTR [rsp+0x9e],xmm0
  211ffd:	00 00 
  211fff:	b1 06                	mov    cl,0x6
  212001:	31 c0                	xor    eax,eax
    return parseFormValueRefLen(allocator, in_stream, block_len);
  212003:	66 89 84 24 18 02 00 	mov    WORD PTR [rsp+0x218],ax
  21200a:	00 
  21200b:	c5 f8 28 84 24 90 00 	vmovaps xmm0,XMMWORD PTR [rsp+0x90]
  212012:	00 00 
  212014:	c5 f8 11 84 24 1a 02 	vmovups XMMWORD PTR [rsp+0x21a],xmm0
  21201b:	00 00 
  21201d:	c5 f8 10 84 24 9e 00 	vmovups xmm0,XMMWORD PTR [rsp+0x9e]
  212024:	00 00 
  212026:	c5 f8 11 84 24 28 02 	vmovups XMMWORD PTR [rsp+0x228],xmm0
  21202d:	00 00 
  21202f:	88 8c 24 38 02 00 00 	mov    BYTE PTR [rsp+0x238],cl
  212036:	8b 04 24             	mov    eax,DWORD PTR [rsp]
  212039:	89 84 24 39 02 00 00 	mov    DWORD PTR [rsp+0x239],eax
  212040:	0f b7 44 24 04       	movzx  eax,WORD PTR [rsp+0x4]
  212045:	66 89 84 24 3d 02 00 	mov    WORD PTR [rsp+0x23d],ax
  21204c:	00 
  21204d:	8a 44 24 06          	mov    al,BYTE PTR [rsp+0x6]
  212051:	e9 3e eb ff ff       	jmp    210b94 <parseFormValue+0x8f4>
    const buf = try readAllocBytes(allocator, in_stream, size);
  212056:	c5 f8 10 84 24 80 00 	vmovups xmm0,XMMWORD PTR [rsp+0x80]
  21205d:	00 00 
  21205f:	c5 f8 29 84 24 b0 00 	vmovaps XMMWORD PTR [rsp+0xb0],xmm0
  212066:	00 00 
    return FormValue{ .Ref = buf };
  212068:	c5 f8 11 44 24 1e    	vmovups XMMWORD PTR [rsp+0x1e],xmm0
  21206e:	48 8b 84 24 c0 00 00 	mov    rax,QWORD PTR [rsp+0xc0]
  212075:	00 
  212076:	48 89 44 24 2e       	mov    QWORD PTR [rsp+0x2e],rax
  21207b:	c6 44 24 08 06       	mov    BYTE PTR [rsp+0x8],0x6
  212080:	8b 44 24 71          	mov    eax,DWORD PTR [rsp+0x71]
  212084:	89 04 24             	mov    DWORD PTR [rsp],eax
  212087:	0f b7 44 24 75       	movzx  eax,WORD PTR [rsp+0x75]
  21208c:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  212091:	8a 44 24 77          	mov    al,BYTE PTR [rsp+0x77]
  212095:	88 44 24 06          	mov    BYTE PTR [rsp+0x6],al
  212099:	c5 f8 10 44 24 18    	vmovups xmm0,XMMWORD PTR [rsp+0x18]
  21209f:	c5 f8 29 84 24 90 00 	vmovaps XMMWORD PTR [rsp+0x90],xmm0
  2120a6:	00 00 
  2120a8:	c5 f8 10 44 24 26    	vmovups xmm0,XMMWORD PTR [rsp+0x26]
  2120ae:	c5 f8 11 84 24 9e 00 	vmovups XMMWORD PTR [rsp+0x9e],xmm0
  2120b5:	00 00 
  2120b7:	b1 06                	mov    cl,0x6
  2120b9:	31 c0                	xor    eax,eax
    return parseFormValueRefLen(allocator, in_stream, block_len);
  2120bb:	66 89 84 24 f0 01 00 	mov    WORD PTR [rsp+0x1f0],ax
  2120c2:	00 
  2120c3:	c5 f8 28 84 24 90 00 	vmovaps xmm0,XMMWORD PTR [rsp+0x90]
  2120ca:	00 00 
  2120cc:	c5 f8 11 84 24 f2 01 	vmovups XMMWORD PTR [rsp+0x1f2],xmm0
  2120d3:	00 00 
  2120d5:	c5 f8 10 84 24 9e 00 	vmovups xmm0,XMMWORD PTR [rsp+0x9e]
  2120dc:	00 00 
  2120de:	c5 f8 11 84 24 00 02 	vmovups XMMWORD PTR [rsp+0x200],xmm0
  2120e5:	00 00 
  2120e7:	88 8c 24 10 02 00 00 	mov    BYTE PTR [rsp+0x210],cl
  2120ee:	8b 04 24             	mov    eax,DWORD PTR [rsp]
  2120f1:	89 84 24 11 02 00 00 	mov    DWORD PTR [rsp+0x211],eax
  2120f8:	0f b7 44 24 04       	movzx  eax,WORD PTR [rsp+0x4]
  2120fd:	66 89 84 24 15 02 00 	mov    WORD PTR [rsp+0x215],ax
  212104:	00 
  212105:	8a 44 24 06          	mov    al,BYTE PTR [rsp+0x6]
  212109:	e9 3b eb ff ff       	jmp    210c49 <parseFormValue+0x9a9>
    const buf = try readAllocBytes(allocator, in_stream, size);
  21210e:	c5 f8 10 84 24 80 00 	vmovups xmm0,XMMWORD PTR [rsp+0x80]
  212115:	00 00 
  212117:	c5 f8 29 84 24 b0 00 	vmovaps XMMWORD PTR [rsp+0xb0],xmm0
  21211e:	00 00 
    return FormValue{ .Ref = buf };
  212120:	c5 f8 11 44 24 1e    	vmovups XMMWORD PTR [rsp+0x1e],xmm0
  212126:	48 8b 84 24 c0 00 00 	mov    rax,QWORD PTR [rsp+0xc0]
  21212d:	00 
  21212e:	48 89 44 24 2e       	mov    QWORD PTR [rsp+0x2e],rax
  212133:	c6 44 24 08 06       	mov    BYTE PTR [rsp+0x8],0x6
  212138:	8b 44 24 71          	mov    eax,DWORD PTR [rsp+0x71]
  21213c:	89 04 24             	mov    DWORD PTR [rsp],eax
  21213f:	0f b7 44 24 75       	movzx  eax,WORD PTR [rsp+0x75]
  212144:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  212149:	8a 44 24 77          	mov    al,BYTE PTR [rsp+0x77]
  21214d:	88 44 24 06          	mov    BYTE PTR [rsp+0x6],al
  212151:	c5 f8 10 44 24 18    	vmovups xmm0,XMMWORD PTR [rsp+0x18]
  212157:	c5 f8 29 84 24 90 00 	vmovaps XMMWORD PTR [rsp+0x90],xmm0
  21215e:	00 00 
  212160:	c5 f8 10 44 24 26    	vmovups xmm0,XMMWORD PTR [rsp+0x26]
  212166:	c5 f8 11 84 24 9e 00 	vmovups XMMWORD PTR [rsp+0x9e],xmm0
  21216d:	00 00 
  21216f:	b1 06                	mov    cl,0x6
  212171:	31 c0                	xor    eax,eax
    return parseFormValueRefLen(allocator, in_stream, block_len);
  212173:	66 89 84 24 c8 01 00 	mov    WORD PTR [rsp+0x1c8],ax
  21217a:	00 
  21217b:	c5 f8 28 84 24 90 00 	vmovaps xmm0,XMMWORD PTR [rsp+0x90]
  212182:	00 00 
  212184:	c5 f8 11 84 24 ca 01 	vmovups XMMWORD PTR [rsp+0x1ca],xmm0
  21218b:	00 00 
  21218d:	c5 f8 10 84 24 9e 00 	vmovups xmm0,XMMWORD PTR [rsp+0x9e]
  212194:	00 00 
  212196:	c5 f8 11 84 24 d8 01 	vmovups XMMWORD PTR [rsp+0x1d8],xmm0
  21219d:	00 00 
  21219f:	88 8c 24 e8 01 00 00 	mov    BYTE PTR [rsp+0x1e8],cl
  2121a6:	8b 04 24             	mov    eax,DWORD PTR [rsp]
  2121a9:	89 84 24 e9 01 00 00 	mov    DWORD PTR [rsp+0x1e9],eax
  2121b0:	0f b7 44 24 04       	movzx  eax,WORD PTR [rsp+0x4]
  2121b5:	66 89 84 24 ed 01 00 	mov    WORD PTR [rsp+0x1ed],ax
  2121bc:	00 
  2121bd:	8a 44 24 06          	mov    al,BYTE PTR [rsp+0x6]
  2121c1:	e9 38 eb ff ff       	jmp    210cfe <parseFormValue+0xa5e>
            const signed = form_id == DW.FORM_sdata;
  2121c6:	48 83 fb 0d          	cmp    rbx,0xd
    return FormValue{
  2121ca:	0f 94 84 24 b0 00 00 	sete   BYTE PTR [rsp+0xb0]
  2121d1:	00 
  2121d2:	c6 44 24 60 02       	mov    BYTE PTR [rsp+0x60],0x2
  2121d7:	8b 44 24 78          	mov    eax,DWORD PTR [rsp+0x78]
  2121db:	89 84 24 18 01 00 00 	mov    DWORD PTR [rsp+0x118],eax
            const signed = form_id == DW.FORM_sdata;
  2121e2:	40 0f 94 c7          	sete   dil
    return FormValue{
  2121e6:	0f b7 44 24 7c       	movzx  eax,WORD PTR [rsp+0x7c]
  2121eb:	66 89 84 24 1c 01 00 	mov    WORD PTR [rsp+0x11c],ax
  2121f2:	00 
        .Const = Constant{
  2121f3:	c5 f8 10 44 24 48    	vmovups xmm0,XMMWORD PTR [rsp+0x48]
    return FormValue{
  2121f9:	8b 84 24 90 00 00 00 	mov    eax,DWORD PTR [rsp+0x90]
  212200:	89 84 24 f0 00 00 00 	mov    DWORD PTR [rsp+0xf0],eax
  212207:	48 8d b4 24 18 01 00 	lea    rsi,[rsp+0x118]
  21220e:	00 
  21220f:	0f b7 84 24 94 00 00 	movzx  eax,WORD PTR [rsp+0x94]
  212216:	00 
  212217:	66 89 84 24 f4 00 00 	mov    WORD PTR [rsp+0xf4],ax
  21221e:	00 
  21221f:	48 8d 84 24 f0 00 00 	lea    rax,[rsp+0xf0]
  212226:	00 
  212227:	8a 8c 24 96 00 00 00 	mov    cl,BYTE PTR [rsp+0x96]
  21222e:	88 8c 24 f6 00 00 00 	mov    BYTE PTR [rsp+0xf6],cl
  212235:	b3 02                	mov    bl,0x2
  212237:	8b 4c 24 18          	mov    ecx,DWORD PTR [rsp+0x18]
  21223b:	89 8c 24 e8 00 00 00 	mov    DWORD PTR [rsp+0xe8],ecx
  212242:	48 8d 8c 24 e8 00 00 	lea    rcx,[rsp+0xe8]
  212249:	00 
  21224a:	0f b7 54 24 1c       	movzx  edx,WORD PTR [rsp+0x1c]
  21224f:	66 89 94 24 ec 00 00 	mov    WORD PTR [rsp+0xec],dx
  212256:	00 
  212257:	8a 54 24 1e          	mov    dl,BYTE PTR [rsp+0x1e]
  21225b:	88 94 24 ee 00 00 00 	mov    BYTE PTR [rsp+0xee],dl
  212262:	31 d2                	xor    edx,edx
            return parseFormValueConstant(allocator, in_stream, signed, block_len);
  212264:	66 89 55 00          	mov    WORD PTR [rbp+0x0],dx
  212268:	0f b7 56 04          	movzx  edx,WORD PTR [rsi+0x4]
  21226c:	66 89 55 06          	mov    WORD PTR [rbp+0x6],dx
  212270:	8b 16                	mov    edx,DWORD PTR [rsi]
  212272:	89 55 02             	mov    DWORD PTR [rbp+0x2],edx
  212275:	c5 f8 11 45 08       	vmovups XMMWORD PTR [rbp+0x8],xmm0
  21227a:	40 88 7d 18          	mov    BYTE PTR [rbp+0x18],dil
  21227e:	8a 50 06             	mov    dl,BYTE PTR [rax+0x6]
  212281:	88 55 1f             	mov    BYTE PTR [rbp+0x1f],dl
  212284:	0f b7 50 04          	movzx  edx,WORD PTR [rax+0x4]
  212288:	66 89 55 1d          	mov    WORD PTR [rbp+0x1d],dx
  21228c:	8b 00                	mov    eax,DWORD PTR [rax]
  21228e:	89 45 19             	mov    DWORD PTR [rbp+0x19],eax
  212291:	88 5d 20             	mov    BYTE PTR [rbp+0x20],bl
  212294:	0f b7 41 04          	movzx  eax,WORD PTR [rcx+0x4]
  212298:	66 89 45 25          	mov    WORD PTR [rbp+0x25],ax
  21229c:	8b 01                	mov    eax,DWORD PTR [rcx]
  21229e:	89 45 21             	mov    DWORD PTR [rbp+0x21],eax
  2122a1:	8a 41 06             	mov    al,BYTE PTR [rcx+0x6]
  2122a4:	88 45 27             	mov    BYTE PTR [rbp+0x27],al
  2122a7:	e9 0b fa ff ff       	jmp    211cb7 <parseFormValue+0x1a17>
            for (bytes) |b, index| {
  2122ac:	48 89 c3             	mov    rbx,rax
  2122af:	48 83 e3 f0          	and    rbx,0xfffffffffffffff0
  2122b3:	48 8d 6b f0          	lea    rbp,[rbx-0x10]
  2122b7:	48 89 e9             	mov    rcx,rbp
  2122ba:	48 c1 e9 04          	shr    rcx,0x4
  2122be:	8d 79 01             	lea    edi,[rcx+0x1]
  2122c1:	83 e7 01             	and    edi,0x1
  2122c4:	48 85 ed             	test   rbp,rbp
  2122c7:	0f 84 29 05 00 00    	je     2127f6 <parseFormValue+0x2556>
  2122cd:	48 8d 6f ff          	lea    rbp,[rdi-0x1]
  2122d1:	48 29 cd             	sub    rbp,rcx
  2122d4:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  2122d8:	c5 fd 6f 0d c0 de fe 	vmovdqa ymm1,YMMWORD PTR [rip+0xfffffffffffedec0]        # 2001a0 <__unnamed_90-0x40>
  2122df:	ff 
  2122e0:	31 c9                	xor    ecx,ecx
  2122e2:	c4 e2 7d 59 2d 75 df 	vpbroadcastq ymm5,QWORD PTR [rip+0xfffffffffffedf75]        # 200260 <__unnamed_90+0x80>
  2122e9:	fe ff 
  2122eb:	c4 e2 7d 59 35 dc df 	vpbroadcastq ymm6,QWORD PTR [rip+0xfffffffffffedfdc]        # 2002d0 <app_mask+0x50>
  2122f2:	fe ff 
  2122f4:	c4 e2 7d 59 3d c3 df 	vpbroadcastq ymm7,QWORD PTR [rip+0xfffffffffffedfc3]        # 2002c0 <app_mask+0x40>
  2122fb:	fe ff 
  2122fd:	c4 62 7d 59 05 02 df 	vpbroadcastq ymm8,QWORD PTR [rip+0xfffffffffffedf02]        # 200208 <__unnamed_90+0x28>
  212304:	fe ff 
  212306:	c5 e1 ef db          	vpxor  xmm3,xmm3,xmm3
  21230a:	c5 d9 ef e4          	vpxor  xmm4,xmm4,xmm4
  21230e:	c5 e9 ef d2          	vpxor  xmm2,xmm2,xmm2
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  212312:	c4 62 7d 32 0c 0a    	vpmovzxbq ymm9,DWORD PTR [rdx+rcx*1]
  212318:	c4 62 7d 32 54 0a 04 	vpmovzxbq ymm10,DWORD PTR [rdx+rcx*1+0x4]
  21231f:	c4 62 7d 32 5c 0a 08 	vpmovzxbq ymm11,DWORD PTR [rdx+rcx*1+0x8]
  212326:	c4 62 7d 32 64 0a 0c 	vpmovzxbq ymm12,DWORD PTR [rdx+rcx*1+0xc]
  21232d:	c5 95 73 f1 03       	vpsllq ymm13,ymm1,0x3
  212332:	c5 15 d4 f5          	vpaddq ymm14,ymm13,ymm5
  212336:	c5 15 db fe          	vpand  ymm15,ymm13,ymm6
  21233a:	c5 0d db f6          	vpand  ymm14,ymm14,ymm6
  21233e:	c4 42 b5 47 cf       	vpsllvq ymm9,ymm9,ymm15
  212343:	c5 b5 eb c0          	vpor   ymm0,ymm9,ymm0
  212347:	c4 42 ad 47 ce       	vpsllvq ymm9,ymm10,ymm14
  21234c:	c5 b5 eb db          	vpor   ymm3,ymm9,ymm3
  212350:	c4 42 a5 47 cf       	vpsllvq ymm9,ymm11,ymm15
  212355:	c5 b5 eb e4          	vpor   ymm4,ymm9,ymm4
  212359:	c4 42 9d 47 ce       	vpsllvq ymm9,ymm12,ymm14
  21235e:	c4 62 7d 32 54 0a 10 	vpmovzxbq ymm10,DWORD PTR [rdx+rcx*1+0x10]
  212365:	c4 62 7d 32 5c 0a 14 	vpmovzxbq ymm11,DWORD PTR [rdx+rcx*1+0x14]
  21236c:	c4 62 7d 32 64 0a 18 	vpmovzxbq ymm12,DWORD PTR [rdx+rcx*1+0x18]
  212373:	c4 62 7d 32 74 0a 1c 	vpmovzxbq ymm14,DWORD PTR [rdx+rcx*1+0x1c]
  21237a:	c5 b5 eb d2          	vpor   ymm2,ymm9,ymm2
  21237e:	c5 15 d4 cf          	vpaddq ymm9,ymm13,ymm7
  212382:	c4 41 15 d4 e8       	vpaddq ymm13,ymm13,ymm8
  212387:	c5 35 db ce          	vpand  ymm9,ymm9,ymm6
  21238b:	c5 15 db ee          	vpand  ymm13,ymm13,ymm6
  21238f:	c4 42 ad 47 d1       	vpsllvq ymm10,ymm10,ymm9
  212394:	c5 ad eb c0          	vpor   ymm0,ymm10,ymm0
  212398:	c4 42 a5 47 d5       	vpsllvq ymm10,ymm11,ymm13
  21239d:	c5 ad eb db          	vpor   ymm3,ymm10,ymm3
  2123a1:	c4 42 9d 47 c9       	vpsllvq ymm9,ymm12,ymm9
  2123a6:	c5 b5 eb e4          	vpor   ymm4,ymm9,ymm4
  2123aa:	c4 42 8d 47 cd       	vpsllvq ymm9,ymm14,ymm13
  2123af:	c5 b5 eb d2          	vpor   ymm2,ymm9,ymm2
            for (bytes) |b, index| {
  2123b3:	48 83 c1 20          	add    rcx,0x20
  2123b7:	c5 f5 d4 cd          	vpaddq ymm1,ymm1,ymm5
  2123bb:	48 83 c5 02          	add    rbp,0x2
  2123bf:	0f 85 4d ff ff ff    	jne    212312 <parseFormValue+0x2072>
  2123c5:	e9 46 04 00 00       	jmp    212810 <parseFormValue+0x2570>
  2123ca:	48 89 c3             	mov    rbx,rax
  2123cd:	48 83 e3 f0          	and    rbx,0xfffffffffffffff0
  2123d1:	48 8d 6b f0          	lea    rbp,[rbx-0x10]
  2123d5:	48 89 e9             	mov    rcx,rbp
  2123d8:	48 c1 e9 04          	shr    rcx,0x4
  2123dc:	8d 79 01             	lea    edi,[rcx+0x1]
  2123df:	83 e7 01             	and    edi,0x1
  2123e2:	48 85 ed             	test   rbp,rbp
  2123e5:	0f 84 ec 05 00 00    	je     2129d7 <parseFormValue+0x2737>
  2123eb:	48 8d 6f ff          	lea    rbp,[rdi-0x1]
  2123ef:	48 29 cd             	sub    rbp,rcx
  2123f2:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  2123f6:	c5 fd 6f 0d a2 dd fe 	vmovdqa ymm1,YMMWORD PTR [rip+0xfffffffffffedda2]        # 2001a0 <__unnamed_90-0x40>
  2123fd:	ff 
  2123fe:	31 c9                	xor    ecx,ecx
  212400:	c4 e2 7d 59 2d 57 de 	vpbroadcastq ymm5,QWORD PTR [rip+0xfffffffffffede57]        # 200260 <__unnamed_90+0x80>
  212407:	fe ff 
  212409:	c4 e2 7d 59 35 be de 	vpbroadcastq ymm6,QWORD PTR [rip+0xfffffffffffedebe]        # 2002d0 <app_mask+0x50>
  212410:	fe ff 
  212412:	c4 e2 7d 59 3d a5 de 	vpbroadcastq ymm7,QWORD PTR [rip+0xfffffffffffedea5]        # 2002c0 <app_mask+0x40>
  212419:	fe ff 
  21241b:	c4 62 7d 59 05 e4 dd 	vpbroadcastq ymm8,QWORD PTR [rip+0xfffffffffffedde4]        # 200208 <__unnamed_90+0x28>
  212422:	fe ff 
  212424:	c5 e1 ef db          	vpxor  xmm3,xmm3,xmm3
  212428:	c5 d9 ef e4          	vpxor  xmm4,xmm4,xmm4
  21242c:	c5 e9 ef d2          	vpxor  xmm2,xmm2,xmm2
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  212430:	c4 62 7d 32 0c 0a    	vpmovzxbq ymm9,DWORD PTR [rdx+rcx*1]
  212436:	c4 62 7d 32 54 0a 04 	vpmovzxbq ymm10,DWORD PTR [rdx+rcx*1+0x4]
  21243d:	c4 62 7d 32 5c 0a 08 	vpmovzxbq ymm11,DWORD PTR [rdx+rcx*1+0x8]
  212444:	c4 62 7d 32 64 0a 0c 	vpmovzxbq ymm12,DWORD PTR [rdx+rcx*1+0xc]
  21244b:	c5 95 73 f1 03       	vpsllq ymm13,ymm1,0x3
  212450:	c5 15 d4 f5          	vpaddq ymm14,ymm13,ymm5
  212454:	c5 15 db fe          	vpand  ymm15,ymm13,ymm6
  212458:	c5 0d db f6          	vpand  ymm14,ymm14,ymm6
  21245c:	c4 42 b5 47 cf       	vpsllvq ymm9,ymm9,ymm15
  212461:	c5 b5 eb c0          	vpor   ymm0,ymm9,ymm0
  212465:	c4 42 ad 47 ce       	vpsllvq ymm9,ymm10,ymm14
  21246a:	c5 b5 eb db          	vpor   ymm3,ymm9,ymm3
  21246e:	c4 42 a5 47 cf       	vpsllvq ymm9,ymm11,ymm15
  212473:	c5 b5 eb e4          	vpor   ymm4,ymm9,ymm4
  212477:	c4 42 9d 47 ce       	vpsllvq ymm9,ymm12,ymm14
  21247c:	c4 62 7d 32 54 0a 10 	vpmovzxbq ymm10,DWORD PTR [rdx+rcx*1+0x10]
  212483:	c4 62 7d 32 5c 0a 14 	vpmovzxbq ymm11,DWORD PTR [rdx+rcx*1+0x14]
  21248a:	c4 62 7d 32 64 0a 18 	vpmovzxbq ymm12,DWORD PTR [rdx+rcx*1+0x18]
  212491:	c4 62 7d 32 74 0a 1c 	vpmovzxbq ymm14,DWORD PTR [rdx+rcx*1+0x1c]
  212498:	c5 b5 eb d2          	vpor   ymm2,ymm9,ymm2
  21249c:	c5 15 d4 cf          	vpaddq ymm9,ymm13,ymm7
  2124a0:	c4 41 15 d4 e8       	vpaddq ymm13,ymm13,ymm8
  2124a5:	c5 35 db ce          	vpand  ymm9,ymm9,ymm6
  2124a9:	c5 15 db ee          	vpand  ymm13,ymm13,ymm6
  2124ad:	c4 42 ad 47 d1       	vpsllvq ymm10,ymm10,ymm9
  2124b2:	c5 ad eb c0          	vpor   ymm0,ymm10,ymm0
  2124b6:	c4 42 a5 47 d5       	vpsllvq ymm10,ymm11,ymm13
  2124bb:	c5 ad eb db          	vpor   ymm3,ymm10,ymm3
  2124bf:	c4 42 9d 47 c9       	vpsllvq ymm9,ymm12,ymm9
  2124c4:	c5 b5 eb e4          	vpor   ymm4,ymm9,ymm4
  2124c8:	c4 42 8d 47 cd       	vpsllvq ymm9,ymm14,ymm13
  2124cd:	c5 b5 eb d2          	vpor   ymm2,ymm9,ymm2
            for (bytes) |b, index| {
  2124d1:	48 83 c1 20          	add    rcx,0x20
  2124d5:	c5 f5 d4 cd          	vpaddq ymm1,ymm1,ymm5
  2124d9:	48 83 c5 02          	add    rbp,0x2
  2124dd:	0f 85 4d ff ff ff    	jne    212430 <parseFormValue+0x2190>
  2124e3:	e9 09 05 00 00       	jmp    2129f1 <parseFormValue+0x2751>
  2124e8:	48 89 c3             	mov    rbx,rax
  2124eb:	48 83 e3 f0          	and    rbx,0xfffffffffffffff0
  2124ef:	48 8d 6b f0          	lea    rbp,[rbx-0x10]
  2124f3:	48 89 e9             	mov    rcx,rbp
  2124f6:	48 c1 e9 04          	shr    rcx,0x4
  2124fa:	8d 79 01             	lea    edi,[rcx+0x1]
  2124fd:	83 e7 01             	and    edi,0x1
  212500:	48 85 ed             	test   rbp,rbp
  212503:	0f 84 af 06 00 00    	je     212bb8 <parseFormValue+0x2918>
  212509:	48 8d 6f ff          	lea    rbp,[rdi-0x1]
  21250d:	48 29 cd             	sub    rbp,rcx
  212510:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  212514:	c5 fd 6f 0d 84 dc fe 	vmovdqa ymm1,YMMWORD PTR [rip+0xfffffffffffedc84]        # 2001a0 <__unnamed_90-0x40>
  21251b:	ff 
  21251c:	31 c9                	xor    ecx,ecx
  21251e:	c4 e2 7d 59 2d 39 dd 	vpbroadcastq ymm5,QWORD PTR [rip+0xfffffffffffedd39]        # 200260 <__unnamed_90+0x80>
  212525:	fe ff 
  212527:	c4 e2 7d 59 35 a0 dd 	vpbroadcastq ymm6,QWORD PTR [rip+0xfffffffffffedda0]        # 2002d0 <app_mask+0x50>
  21252e:	fe ff 
  212530:	c4 e2 7d 59 3d 87 dd 	vpbroadcastq ymm7,QWORD PTR [rip+0xfffffffffffedd87]        # 2002c0 <app_mask+0x40>
  212537:	fe ff 
  212539:	c4 62 7d 59 05 c6 dc 	vpbroadcastq ymm8,QWORD PTR [rip+0xfffffffffffedcc6]        # 200208 <__unnamed_90+0x28>
  212540:	fe ff 
  212542:	c5 e1 ef db          	vpxor  xmm3,xmm3,xmm3
  212546:	c5 d9 ef e4          	vpxor  xmm4,xmm4,xmm4
  21254a:	c5 e9 ef d2          	vpxor  xmm2,xmm2,xmm2
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  21254e:	c4 62 7d 32 0c 0a    	vpmovzxbq ymm9,DWORD PTR [rdx+rcx*1]
  212554:	c4 62 7d 32 54 0a 04 	vpmovzxbq ymm10,DWORD PTR [rdx+rcx*1+0x4]
  21255b:	c4 62 7d 32 5c 0a 08 	vpmovzxbq ymm11,DWORD PTR [rdx+rcx*1+0x8]
  212562:	c4 62 7d 32 64 0a 0c 	vpmovzxbq ymm12,DWORD PTR [rdx+rcx*1+0xc]
  212569:	c5 95 73 f1 03       	vpsllq ymm13,ymm1,0x3
  21256e:	c5 15 d4 f5          	vpaddq ymm14,ymm13,ymm5
  212572:	c5 15 db fe          	vpand  ymm15,ymm13,ymm6
  212576:	c5 0d db f6          	vpand  ymm14,ymm14,ymm6
  21257a:	c4 42 b5 47 cf       	vpsllvq ymm9,ymm9,ymm15
  21257f:	c5 b5 eb c0          	vpor   ymm0,ymm9,ymm0
  212583:	c4 42 ad 47 ce       	vpsllvq ymm9,ymm10,ymm14
  212588:	c5 b5 eb db          	vpor   ymm3,ymm9,ymm3
  21258c:	c4 42 a5 47 cf       	vpsllvq ymm9,ymm11,ymm15
  212591:	c5 b5 eb e4          	vpor   ymm4,ymm9,ymm4
  212595:	c4 42 9d 47 ce       	vpsllvq ymm9,ymm12,ymm14
  21259a:	c4 62 7d 32 54 0a 10 	vpmovzxbq ymm10,DWORD PTR [rdx+rcx*1+0x10]
  2125a1:	c4 62 7d 32 5c 0a 14 	vpmovzxbq ymm11,DWORD PTR [rdx+rcx*1+0x14]
  2125a8:	c4 62 7d 32 64 0a 18 	vpmovzxbq ymm12,DWORD PTR [rdx+rcx*1+0x18]
  2125af:	c4 62 7d 32 74 0a 1c 	vpmovzxbq ymm14,DWORD PTR [rdx+rcx*1+0x1c]
  2125b6:	c5 b5 eb d2          	vpor   ymm2,ymm9,ymm2
  2125ba:	c5 15 d4 cf          	vpaddq ymm9,ymm13,ymm7
  2125be:	c4 41 15 d4 e8       	vpaddq ymm13,ymm13,ymm8
  2125c3:	c5 35 db ce          	vpand  ymm9,ymm9,ymm6
  2125c7:	c5 15 db ee          	vpand  ymm13,ymm13,ymm6
  2125cb:	c4 42 ad 47 d1       	vpsllvq ymm10,ymm10,ymm9
  2125d0:	c5 ad eb c0          	vpor   ymm0,ymm10,ymm0
  2125d4:	c4 42 a5 47 d5       	vpsllvq ymm10,ymm11,ymm13
  2125d9:	c5 ad eb db          	vpor   ymm3,ymm10,ymm3
  2125dd:	c4 42 9d 47 c9       	vpsllvq ymm9,ymm12,ymm9
  2125e2:	c5 b5 eb e4          	vpor   ymm4,ymm9,ymm4
  2125e6:	c4 42 8d 47 cd       	vpsllvq ymm9,ymm14,ymm13
  2125eb:	c5 b5 eb d2          	vpor   ymm2,ymm9,ymm2
            for (bytes) |b, index| {
  2125ef:	48 83 c1 20          	add    rcx,0x20
  2125f3:	c5 f5 d4 cd          	vpaddq ymm1,ymm1,ymm5
  2125f7:	48 83 c5 02          	add    rbp,0x2
  2125fb:	0f 85 4d ff ff ff    	jne    21254e <parseFormValue+0x22ae>
  212601:	e9 cc 05 00 00       	jmp    212bd2 <parseFormValue+0x2932>
    return FormValue{ .Block = buf };
  212606:	c6 84 24 b0 00 00 00 	mov    BYTE PTR [rsp+0xb0],0x1
  21260d:	01 
  21260e:	8b 44 24 78          	mov    eax,DWORD PTR [rsp+0x78]
  212612:	89 84 24 20 01 00 00 	mov    DWORD PTR [rsp+0x120],eax
  212619:	0f b7 44 24 7c       	movzx  eax,WORD PTR [rsp+0x7c]
  21261e:	66 89 84 24 24 01 00 	mov    WORD PTR [rsp+0x124],ax
  212625:	00 
    const buf = try readAllocBytes(allocator, in_stream, size);
  212626:	c5 f8 10 44 24 48    	vmovups xmm0,XMMWORD PTR [rsp+0x48]
    return FormValue{ .Block = buf };
  21262c:	8b 44 24 18          	mov    eax,DWORD PTR [rsp+0x18]
  212630:	89 84 24 00 01 00 00 	mov    DWORD PTR [rsp+0x100],eax
  212637:	48 8d b4 24 20 01 00 	lea    rsi,[rsp+0x120]
  21263e:	00 
  21263f:	0f b7 44 24 1c       	movzx  eax,WORD PTR [rsp+0x1c]
  212644:	66 89 84 24 04 01 00 	mov    WORD PTR [rsp+0x104],ax
  21264b:	00 
  21264c:	48 8d 84 24 00 01 00 	lea    rax,[rsp+0x100]
  212653:	00 
  212654:	8a 4c 24 1e          	mov    cl,BYTE PTR [rsp+0x1e]
  212658:	88 8c 24 06 01 00 00 	mov    BYTE PTR [rsp+0x106],cl
  21265f:	b3 01                	mov    bl,0x1
  212661:	8b 8c 24 90 00 00 00 	mov    ecx,DWORD PTR [rsp+0x90]
  212668:	89 8c 24 f8 00 00 00 	mov    DWORD PTR [rsp+0xf8],ecx
  21266f:	48 8d 94 24 f8 00 00 	lea    rdx,[rsp+0xf8]
  212676:	00 
  212677:	0f b7 8c 24 94 00 00 	movzx  ecx,WORD PTR [rsp+0x94]
  21267e:	00 
  21267f:	66 89 8c 24 fc 00 00 	mov    WORD PTR [rsp+0xfc],cx
  212686:	00 
  212687:	8a 8c 24 96 00 00 00 	mov    cl,BYTE PTR [rsp+0x96]
  21268e:	88 8c 24 fe 00 00 00 	mov    BYTE PTR [rsp+0xfe],cl
  212695:	e9 8f 00 00 00       	jmp    212729 <parseFormValue+0x2489>
    return FormValue{ .Ref = buf };
  21269a:	c6 84 24 b0 00 00 00 	mov    BYTE PTR [rsp+0xb0],0x6
  2126a1:	06 
  2126a2:	8b 44 24 78          	mov    eax,DWORD PTR [rsp+0x78]
  2126a6:	89 84 24 10 01 00 00 	mov    DWORD PTR [rsp+0x110],eax
  2126ad:	0f b7 44 24 7c       	movzx  eax,WORD PTR [rsp+0x7c]
  2126b2:	66 89 84 24 14 01 00 	mov    WORD PTR [rsp+0x114],ax
  2126b9:	00 
    const buf = try readAllocBytes(allocator, in_stream, size);
  2126ba:	c5 f8 10 44 24 48    	vmovups xmm0,XMMWORD PTR [rsp+0x48]
    return FormValue{ .Ref = buf };
  2126c0:	8b 44 24 18          	mov    eax,DWORD PTR [rsp+0x18]
  2126c4:	89 84 24 e0 00 00 00 	mov    DWORD PTR [rsp+0xe0],eax
  2126cb:	48 8d b4 24 10 01 00 	lea    rsi,[rsp+0x110]
  2126d2:	00 
  2126d3:	0f b7 44 24 1c       	movzx  eax,WORD PTR [rsp+0x1c]
  2126d8:	66 89 84 24 e4 00 00 	mov    WORD PTR [rsp+0xe4],ax
  2126df:	00 
  2126e0:	48 8d 84 24 e0 00 00 	lea    rax,[rsp+0xe0]
  2126e7:	00 
  2126e8:	8a 4c 24 1e          	mov    cl,BYTE PTR [rsp+0x1e]
  2126ec:	88 8c 24 e6 00 00 00 	mov    BYTE PTR [rsp+0xe6],cl
  2126f3:	b3 06                	mov    bl,0x6
  2126f5:	8b 8c 24 90 00 00 00 	mov    ecx,DWORD PTR [rsp+0x90]
  2126fc:	89 8c 24 d8 00 00 00 	mov    DWORD PTR [rsp+0xd8],ecx
  212703:	48 8d 94 24 d8 00 00 	lea    rdx,[rsp+0xd8]
  21270a:	00 
  21270b:	0f b7 8c 24 94 00 00 	movzx  ecx,WORD PTR [rsp+0x94]
  212712:	00 
  212713:	66 89 8c 24 dc 00 00 	mov    WORD PTR [rsp+0xdc],cx
  21271a:	00 
  21271b:	8a 8c 24 96 00 00 00 	mov    cl,BYTE PTR [rsp+0x96]
  212722:	88 8c 24 de 00 00 00 	mov    BYTE PTR [rsp+0xde],cl
  212729:	31 c9                	xor    ecx,ecx
  21272b:	66 89 0f             	mov    WORD PTR [rdi],cx
  21272e:	0f b7 4e 04          	movzx  ecx,WORD PTR [rsi+0x4]
  212732:	66 89 4f 06          	mov    WORD PTR [rdi+0x6],cx
  212736:	8b 0e                	mov    ecx,DWORD PTR [rsi]
  212738:	89 4f 02             	mov    DWORD PTR [rdi+0x2],ecx
  21273b:	c5 f8 11 47 08       	vmovups XMMWORD PTR [rdi+0x8],xmm0
  212740:	8a 48 06             	mov    cl,BYTE PTR [rax+0x6]
  212743:	88 4f 1f             	mov    BYTE PTR [rdi+0x1f],cl
  212746:	0f b7 48 04          	movzx  ecx,WORD PTR [rax+0x4]
  21274a:	66 89 4f 1d          	mov    WORD PTR [rdi+0x1d],cx
  21274e:	8b 00                	mov    eax,DWORD PTR [rax]
  212750:	89 47 19             	mov    DWORD PTR [rdi+0x19],eax
  212753:	88 5f 20             	mov    BYTE PTR [rdi+0x20],bl
  212756:	0f b7 42 04          	movzx  eax,WORD PTR [rdx+0x4]
  21275a:	66 89 47 25          	mov    WORD PTR [rdi+0x25],ax
  21275e:	8b 02                	mov    eax,DWORD PTR [rdx]
  212760:	89 47 21             	mov    DWORD PTR [rdi+0x21],eax
  212763:	8a 42 06             	mov    al,BYTE PTR [rdx+0x6]
  212766:	88 47 27             	mov    BYTE PTR [rdi+0x27],al
  212769:	e9 49 f5 ff ff       	jmp    211cb7 <parseFormValue+0x1a17>
            const buf = try readAllocBytes(allocator, in_stream, size);
  21276e:	c5 f8 10 84 24 58 04 	vmovups xmm0,XMMWORD PTR [rsp+0x458]
  212775:	00 00 
  212777:	c5 f8 29 84 24 80 04 	vmovaps XMMWORD PTR [rsp+0x480],xmm0
  21277e:	00 00 
            return FormValue{ .ExprLoc = buf };
  212780:	c5 f8 11 84 24 38 04 	vmovups XMMWORD PTR [rsp+0x438],xmm0
  212787:	00 00 
  212789:	48 8b 84 24 90 04 00 	mov    rax,QWORD PTR [rsp+0x490]
  212790:	00 
  212791:	48 89 84 24 48 04 00 	mov    QWORD PTR [rsp+0x448],rax
  212798:	00 
  212799:	c6 84 24 ae 00 00 00 	mov    BYTE PTR [rsp+0xae],0x3
  2127a0:	03 
  2127a1:	48 8b 4c 24 68       	mov    rcx,QWORD PTR [rsp+0x68]
  2127a6:	66 c7 01 00 00       	mov    WORD PTR [rcx],0x0
  2127ab:	c5 f8 10 84 24 32 04 	vmovups xmm0,XMMWORD PTR [rsp+0x432]
  2127b2:	00 00 
  2127b4:	c5 fa 6f 8c 24 40 04 	vmovdqu xmm1,XMMWORD PTR [rsp+0x440]
  2127bb:	00 00 
  2127bd:	c5 fa 7f 49 10       	vmovdqu XMMWORD PTR [rcx+0x10],xmm1
  2127c2:	c5 f8 11 41 02       	vmovups XMMWORD PTR [rcx+0x2],xmm0
  2127c7:	8a 84 24 ae 00 00 00 	mov    al,BYTE PTR [rsp+0xae]
  2127ce:	88 41 20             	mov    BYTE PTR [rcx+0x20],al
  2127d1:	8a 84 24 10 03 00 00 	mov    al,BYTE PTR [rsp+0x310]
  2127d8:	88 41 27             	mov    BYTE PTR [rcx+0x27],al
  2127db:	0f b7 84 24 0e 03 00 	movzx  eax,WORD PTR [rsp+0x30e]
  2127e2:	00 
  2127e3:	66 89 41 25          	mov    WORD PTR [rcx+0x25],ax
  2127e7:	8b 84 24 0a 03 00 00 	mov    eax,DWORD PTR [rsp+0x30a]
  2127ee:	89 41 21             	mov    DWORD PTR [rcx+0x21],eax
  2127f1:	e9 c1 f4 ff ff       	jmp    211cb7 <parseFormValue+0x1a17>
  2127f6:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  2127fa:	c5 fd 6f 0d 9e d9 fe 	vmovdqa ymm1,YMMWORD PTR [rip+0xfffffffffffed99e]        # 2001a0 <__unnamed_90-0x40>
  212801:	ff 
  212802:	31 c9                	xor    ecx,ecx
  212804:	c5 e1 ef db          	vpxor  xmm3,xmm3,xmm3
  212808:	c5 d9 ef e4          	vpxor  xmm4,xmm4,xmm4
  21280c:	c5 e9 ef d2          	vpxor  xmm2,xmm2,xmm2
  212810:	48 85 ff             	test   rdi,rdi
  212813:	74 62                	je     212877 <parseFormValue+0x25d7>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  212815:	c4 e2 7d 32 6c 0a 0c 	vpmovzxbq ymm5,DWORD PTR [rdx+rcx*1+0xc]
  21281c:	c5 f5 73 f1 03       	vpsllq ymm1,ymm1,0x3
  212821:	c4 e2 7d 59 35 36 da 	vpbroadcastq ymm6,QWORD PTR [rip+0xfffffffffffeda36]        # 200260 <__unnamed_90+0x80>
  212828:	fe ff 
  21282a:	c5 f5 d4 f6          	vpaddq ymm6,ymm1,ymm6
  21282e:	c4 e2 7d 59 3d 99 da 	vpbroadcastq ymm7,QWORD PTR [rip+0xfffffffffffeda99]        # 2002d0 <app_mask+0x50>
  212835:	fe ff 
  212837:	c5 cd db f7          	vpand  ymm6,ymm6,ymm7
  21283b:	c4 e2 d5 47 ee       	vpsllvq ymm5,ymm5,ymm6
  212840:	c4 62 7d 32 44 0a 08 	vpmovzxbq ymm8,DWORD PTR [rdx+rcx*1+0x8]
  212847:	c5 d5 eb d2          	vpor   ymm2,ymm5,ymm2
  21284b:	c5 f5 db cf          	vpand  ymm1,ymm1,ymm7
  21284f:	c4 e2 bd 47 e9       	vpsllvq ymm5,ymm8,ymm1
  212854:	c5 d5 eb e4          	vpor   ymm4,ymm5,ymm4
  212858:	c4 e2 7d 32 6c 0a 04 	vpmovzxbq ymm5,DWORD PTR [rdx+rcx*1+0x4]
  21285f:	c4 e2 d5 47 ee       	vpsllvq ymm5,ymm5,ymm6
  212864:	c5 d5 eb db          	vpor   ymm3,ymm5,ymm3
  212868:	c4 e2 7d 32 2c 0a    	vpmovzxbq ymm5,DWORD PTR [rdx+rcx*1]
  21286e:	c4 e2 d5 47 c9       	vpsllvq ymm1,ymm5,ymm1
  212873:	c5 f5 eb c0          	vpor   ymm0,ymm1,ymm0
  212877:	c5 e5 eb ca          	vpor   ymm1,ymm3,ymm2
  21287b:	c5 fd eb c4          	vpor   ymm0,ymm0,ymm4
  21287f:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  212883:	c4 e3 7d 39 c1 01    	vextracti128 xmm1,ymm0,0x1
  212889:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  21288d:	c5 f9 70 c8 4e       	vpshufd xmm1,xmm0,0x4e
  212892:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  212896:	c4 e1 f9 7e c1       	vmovq  rcx,xmm0
  21289b:	48 39 d8             	cmp    rax,rbx
            for (bytes) |b, index| {
  21289e:	74 29                	je     2128c9 <parseFormValue+0x2629>
  2128a0:	48 29 d8             	sub    rax,rbx
  2128a3:	48 01 da             	add    rdx,rbx
  2128a6:	48 c1 e3 03          	shl    rbx,0x3
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  2128aa:	0f b6 3a             	movzx  edi,BYTE PTR [rdx]
  2128ad:	89 de                	mov    esi,ebx
  2128af:	40 80 e6 38          	and    sil,0x38
  2128b3:	c4 e2 c9 f7 f7       	shlx   rsi,rdi,rsi
  2128b8:	48 09 f1             	or     rcx,rsi
            for (bytes) |b, index| {
  2128bb:	48 83 c3 08          	add    rbx,0x8
  2128bf:	48 83 c2 01          	add    rdx,0x1
  2128c3:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  2128c7:	75 e1                	jne    2128aa <parseFormValue+0x260a>
  2128c9:	48 8d 7c 24 78       	lea    rdi,[rsp+0x78]
    const buf = try readAllocBytes(allocator, in_stream, size);
  2128ce:	4c 89 fe             	mov    rsi,r15
  2128d1:	4c 89 e2             	mov    rdx,r12
  2128d4:	c5 f8 77             	vzeroupper 
  2128d7:	e8 54 07 00 00       	call   213030 <readAllocBytes>
  2128dc:	0f b7 44 24 78       	movzx  eax,WORD PTR [rsp+0x78]
  2128e1:	66 85 c0             	test   ax,ax
  2128e4:	74 39                	je     21291f <parseFormValue+0x267f>
  2128e6:	c5 f8 10 44 24 40    	vmovups xmm0,XMMWORD PTR [rsp+0x40]
  2128ec:	c5 fa 6f 4c 24 4e    	vmovdqu xmm1,XMMWORD PTR [rsp+0x4e]
  2128f2:	c5 fa 7f 8c 24 9e 00 	vmovdqu XMMWORD PTR [rsp+0x9e],xmm1
  2128f9:	00 00 
  2128fb:	c5 f8 29 84 24 90 00 	vmovaps XMMWORD PTR [rsp+0x90],xmm0
  212902:	00 00 
  212904:	8b 4c 24 60          	mov    ecx,DWORD PTR [rsp+0x60]
  212908:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  21290b:	0f b7 4c 24 64       	movzx  ecx,WORD PTR [rsp+0x64]
  212910:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  212915:	8a 4c 24 66          	mov    cl,BYTE PTR [rsp+0x66]
  212919:	88 4c 24 06          	mov    BYTE PTR [rsp+0x6],cl
  21291d:	eb 65                	jmp    212984 <parseFormValue+0x26e4>
  21291f:	c5 f8 10 84 24 80 00 	vmovups xmm0,XMMWORD PTR [rsp+0x80]
  212926:	00 00 
  212928:	c5 f8 29 84 24 b0 00 	vmovaps XMMWORD PTR [rsp+0xb0],xmm0
  21292f:	00 00 
    return FormValue{ .Block = buf };
  212931:	c5 f8 11 44 24 1e    	vmovups XMMWORD PTR [rsp+0x1e],xmm0
  212937:	48 8b 84 24 c0 00 00 	mov    rax,QWORD PTR [rsp+0xc0]
  21293e:	00 
  21293f:	48 89 44 24 2e       	mov    QWORD PTR [rsp+0x2e],rax
  212944:	c6 44 24 08 01       	mov    BYTE PTR [rsp+0x8],0x1
  212949:	8b 44 24 71          	mov    eax,DWORD PTR [rsp+0x71]
  21294d:	89 04 24             	mov    DWORD PTR [rsp],eax
  212950:	0f b7 44 24 75       	movzx  eax,WORD PTR [rsp+0x75]
  212955:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  21295a:	8a 44 24 77          	mov    al,BYTE PTR [rsp+0x77]
  21295e:	88 44 24 06          	mov    BYTE PTR [rsp+0x6],al
  212962:	c5 f8 10 44 24 18    	vmovups xmm0,XMMWORD PTR [rsp+0x18]
  212968:	c5 f8 29 84 24 90 00 	vmovaps XMMWORD PTR [rsp+0x90],xmm0
  21296f:	00 00 
  212971:	c5 f8 10 44 24 26    	vmovups xmm0,XMMWORD PTR [rsp+0x26]
  212977:	c5 f8 11 84 24 9e 00 	vmovups XMMWORD PTR [rsp+0x9e],xmm0
  21297e:	00 00 
  212980:	b1 01                	mov    cl,0x1
  212982:	31 c0                	xor    eax,eax
    return parseFormValueBlockLen(allocator, in_stream, block_len);
  212984:	66 89 84 24 90 02 00 	mov    WORD PTR [rsp+0x290],ax
  21298b:	00 
  21298c:	c5 f8 28 84 24 90 00 	vmovaps xmm0,XMMWORD PTR [rsp+0x90]
  212993:	00 00 
  212995:	c5 f8 11 84 24 92 02 	vmovups XMMWORD PTR [rsp+0x292],xmm0
  21299c:	00 00 
  21299e:	c5 f8 10 84 24 9e 00 	vmovups xmm0,XMMWORD PTR [rsp+0x9e]
  2129a5:	00 00 
  2129a7:	c5 f8 11 84 24 a0 02 	vmovups XMMWORD PTR [rsp+0x2a0],xmm0
  2129ae:	00 00 
  2129b0:	88 8c 24 b0 02 00 00 	mov    BYTE PTR [rsp+0x2b0],cl
  2129b7:	8b 04 24             	mov    eax,DWORD PTR [rsp]
  2129ba:	89 84 24 b1 02 00 00 	mov    DWORD PTR [rsp+0x2b1],eax
  2129c1:	0f b7 44 24 04       	movzx  eax,WORD PTR [rsp+0x4]
  2129c6:	66 89 84 24 b5 02 00 	mov    WORD PTR [rsp+0x2b5],ax
  2129cd:	00 
  2129ce:	8a 44 24 06          	mov    al,BYTE PTR [rsp+0x6]
  2129d2:	e9 78 da ff ff       	jmp    21044f <parseFormValue+0x1af>
  2129d7:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  2129db:	c5 fd 6f 0d bd d7 fe 	vmovdqa ymm1,YMMWORD PTR [rip+0xfffffffffffed7bd]        # 2001a0 <__unnamed_90-0x40>
  2129e2:	ff 
  2129e3:	31 c9                	xor    ecx,ecx
  2129e5:	c5 e1 ef db          	vpxor  xmm3,xmm3,xmm3
  2129e9:	c5 d9 ef e4          	vpxor  xmm4,xmm4,xmm4
  2129ed:	c5 e9 ef d2          	vpxor  xmm2,xmm2,xmm2
  2129f1:	48 85 ff             	test   rdi,rdi
  2129f4:	74 62                	je     212a58 <parseFormValue+0x27b8>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  2129f6:	c4 e2 7d 32 6c 0a 0c 	vpmovzxbq ymm5,DWORD PTR [rdx+rcx*1+0xc]
  2129fd:	c5 f5 73 f1 03       	vpsllq ymm1,ymm1,0x3
  212a02:	c4 e2 7d 59 35 55 d8 	vpbroadcastq ymm6,QWORD PTR [rip+0xfffffffffffed855]        # 200260 <__unnamed_90+0x80>
  212a09:	fe ff 
  212a0b:	c5 f5 d4 f6          	vpaddq ymm6,ymm1,ymm6
  212a0f:	c4 e2 7d 59 3d b8 d8 	vpbroadcastq ymm7,QWORD PTR [rip+0xfffffffffffed8b8]        # 2002d0 <app_mask+0x50>
  212a16:	fe ff 
  212a18:	c5 cd db f7          	vpand  ymm6,ymm6,ymm7
  212a1c:	c4 e2 d5 47 ee       	vpsllvq ymm5,ymm5,ymm6
  212a21:	c4 62 7d 32 44 0a 08 	vpmovzxbq ymm8,DWORD PTR [rdx+rcx*1+0x8]
  212a28:	c5 d5 eb d2          	vpor   ymm2,ymm5,ymm2
  212a2c:	c5 f5 db cf          	vpand  ymm1,ymm1,ymm7
  212a30:	c4 e2 bd 47 e9       	vpsllvq ymm5,ymm8,ymm1
  212a35:	c5 d5 eb e4          	vpor   ymm4,ymm5,ymm4
  212a39:	c4 e2 7d 32 6c 0a 04 	vpmovzxbq ymm5,DWORD PTR [rdx+rcx*1+0x4]
  212a40:	c4 e2 d5 47 ee       	vpsllvq ymm5,ymm5,ymm6
  212a45:	c5 d5 eb db          	vpor   ymm3,ymm5,ymm3
  212a49:	c4 e2 7d 32 2c 0a    	vpmovzxbq ymm5,DWORD PTR [rdx+rcx*1]
  212a4f:	c4 e2 d5 47 c9       	vpsllvq ymm1,ymm5,ymm1
  212a54:	c5 f5 eb c0          	vpor   ymm0,ymm1,ymm0
  212a58:	c5 e5 eb ca          	vpor   ymm1,ymm3,ymm2
  212a5c:	c5 fd eb c4          	vpor   ymm0,ymm0,ymm4
  212a60:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  212a64:	c4 e3 7d 39 c1 01    	vextracti128 xmm1,ymm0,0x1
  212a6a:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  212a6e:	c5 f9 70 c8 4e       	vpshufd xmm1,xmm0,0x4e
  212a73:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  212a77:	c4 e1 f9 7e c1       	vmovq  rcx,xmm0
  212a7c:	48 39 d8             	cmp    rax,rbx
            for (bytes) |b, index| {
  212a7f:	74 29                	je     212aaa <parseFormValue+0x280a>
  212a81:	48 29 d8             	sub    rax,rbx
  212a84:	48 01 da             	add    rdx,rbx
  212a87:	48 c1 e3 03          	shl    rbx,0x3
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  212a8b:	0f b6 3a             	movzx  edi,BYTE PTR [rdx]
  212a8e:	89 de                	mov    esi,ebx
  212a90:	40 80 e6 38          	and    sil,0x38
  212a94:	c4 e2 c9 f7 f7       	shlx   rsi,rdi,rsi
  212a99:	48 09 f1             	or     rcx,rsi
            for (bytes) |b, index| {
  212a9c:	48 83 c3 08          	add    rbx,0x8
  212aa0:	48 83 c2 01          	add    rdx,0x1
  212aa4:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  212aa8:	75 e1                	jne    212a8b <parseFormValue+0x27eb>
  212aaa:	48 8d 7c 24 78       	lea    rdi,[rsp+0x78]
    const buf = try readAllocBytes(allocator, in_stream, size);
  212aaf:	4c 89 fe             	mov    rsi,r15
  212ab2:	4c 89 e2             	mov    rdx,r12
  212ab5:	c5 f8 77             	vzeroupper 
  212ab8:	e8 73 05 00 00       	call   213030 <readAllocBytes>
  212abd:	0f b7 44 24 78       	movzx  eax,WORD PTR [rsp+0x78]
  212ac2:	66 85 c0             	test   ax,ax
  212ac5:	74 39                	je     212b00 <parseFormValue+0x2860>
  212ac7:	c5 f8 10 44 24 40    	vmovups xmm0,XMMWORD PTR [rsp+0x40]
  212acd:	c5 fa 6f 4c 24 4e    	vmovdqu xmm1,XMMWORD PTR [rsp+0x4e]
  212ad3:	c5 fa 7f 8c 24 9e 00 	vmovdqu XMMWORD PTR [rsp+0x9e],xmm1
  212ada:	00 00 
  212adc:	c5 f8 29 84 24 90 00 	vmovaps XMMWORD PTR [rsp+0x90],xmm0
  212ae3:	00 00 
  212ae5:	8b 4c 24 60          	mov    ecx,DWORD PTR [rsp+0x60]
  212ae9:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  212aec:	0f b7 4c 24 64       	movzx  ecx,WORD PTR [rsp+0x64]
  212af1:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  212af6:	8a 4c 24 66          	mov    cl,BYTE PTR [rsp+0x66]
  212afa:	88 4c 24 06          	mov    BYTE PTR [rsp+0x6],cl
  212afe:	eb 65                	jmp    212b65 <parseFormValue+0x28c5>
  212b00:	c5 f8 10 84 24 80 00 	vmovups xmm0,XMMWORD PTR [rsp+0x80]
  212b07:	00 00 
  212b09:	c5 f8 29 84 24 b0 00 	vmovaps XMMWORD PTR [rsp+0xb0],xmm0
  212b10:	00 00 
    return FormValue{ .Block = buf };
  212b12:	c5 f8 11 44 24 1e    	vmovups XMMWORD PTR [rsp+0x1e],xmm0
  212b18:	48 8b 84 24 c0 00 00 	mov    rax,QWORD PTR [rsp+0xc0]
  212b1f:	00 
  212b20:	48 89 44 24 2e       	mov    QWORD PTR [rsp+0x2e],rax
  212b25:	c6 44 24 08 01       	mov    BYTE PTR [rsp+0x8],0x1
  212b2a:	8b 44 24 71          	mov    eax,DWORD PTR [rsp+0x71]
  212b2e:	89 04 24             	mov    DWORD PTR [rsp],eax
  212b31:	0f b7 44 24 75       	movzx  eax,WORD PTR [rsp+0x75]
  212b36:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  212b3b:	8a 44 24 77          	mov    al,BYTE PTR [rsp+0x77]
  212b3f:	88 44 24 06          	mov    BYTE PTR [rsp+0x6],al
  212b43:	c5 f8 10 44 24 18    	vmovups xmm0,XMMWORD PTR [rsp+0x18]
  212b49:	c5 f8 29 84 24 90 00 	vmovaps XMMWORD PTR [rsp+0x90],xmm0
  212b50:	00 00 
  212b52:	c5 f8 10 44 24 26    	vmovups xmm0,XMMWORD PTR [rsp+0x26]
  212b58:	c5 f8 11 84 24 9e 00 	vmovups XMMWORD PTR [rsp+0x9e],xmm0
  212b5f:	00 00 
  212b61:	b1 01                	mov    cl,0x1
  212b63:	31 c0                	xor    eax,eax
    return parseFormValueBlockLen(allocator, in_stream, block_len);
  212b65:	66 89 84 24 68 02 00 	mov    WORD PTR [rsp+0x268],ax
  212b6c:	00 
  212b6d:	c5 f8 28 84 24 90 00 	vmovaps xmm0,XMMWORD PTR [rsp+0x90]
  212b74:	00 00 
  212b76:	c5 f8 11 84 24 6a 02 	vmovups XMMWORD PTR [rsp+0x26a],xmm0
  212b7d:	00 00 
  212b7f:	c5 f8 10 84 24 9e 00 	vmovups xmm0,XMMWORD PTR [rsp+0x9e]
  212b86:	00 00 
  212b88:	c5 f8 11 84 24 78 02 	vmovups XMMWORD PTR [rsp+0x278],xmm0
  212b8f:	00 00 
  212b91:	88 8c 24 88 02 00 00 	mov    BYTE PTR [rsp+0x288],cl
  212b98:	8b 04 24             	mov    eax,DWORD PTR [rsp]
  212b9b:	89 84 24 89 02 00 00 	mov    DWORD PTR [rsp+0x289],eax
  212ba2:	0f b7 44 24 04       	movzx  eax,WORD PTR [rsp+0x4]
  212ba7:	66 89 84 24 8d 02 00 	mov    WORD PTR [rsp+0x28d],ax
  212bae:	00 
  212baf:	8a 44 24 06          	mov    al,BYTE PTR [rsp+0x6]
  212bb3:	e9 4c d9 ff ff       	jmp    210504 <parseFormValue+0x264>
  212bb8:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  212bbc:	c5 fd 6f 0d dc d5 fe 	vmovdqa ymm1,YMMWORD PTR [rip+0xfffffffffffed5dc]        # 2001a0 <__unnamed_90-0x40>
  212bc3:	ff 
  212bc4:	31 c9                	xor    ecx,ecx
  212bc6:	c5 e1 ef db          	vpxor  xmm3,xmm3,xmm3
  212bca:	c5 d9 ef e4          	vpxor  xmm4,xmm4,xmm4
  212bce:	c5 e9 ef d2          	vpxor  xmm2,xmm2,xmm2
  212bd2:	48 85 ff             	test   rdi,rdi
  212bd5:	74 62                	je     212c39 <parseFormValue+0x2999>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  212bd7:	c4 e2 7d 32 6c 0a 0c 	vpmovzxbq ymm5,DWORD PTR [rdx+rcx*1+0xc]
  212bde:	c5 f5 73 f1 03       	vpsllq ymm1,ymm1,0x3
  212be3:	c4 e2 7d 59 35 74 d6 	vpbroadcastq ymm6,QWORD PTR [rip+0xfffffffffffed674]        # 200260 <__unnamed_90+0x80>
  212bea:	fe ff 
  212bec:	c5 f5 d4 f6          	vpaddq ymm6,ymm1,ymm6
  212bf0:	c4 e2 7d 59 3d d7 d6 	vpbroadcastq ymm7,QWORD PTR [rip+0xfffffffffffed6d7]        # 2002d0 <app_mask+0x50>
  212bf7:	fe ff 
  212bf9:	c5 cd db f7          	vpand  ymm6,ymm6,ymm7
  212bfd:	c4 e2 d5 47 ee       	vpsllvq ymm5,ymm5,ymm6
  212c02:	c4 62 7d 32 44 0a 08 	vpmovzxbq ymm8,DWORD PTR [rdx+rcx*1+0x8]
  212c09:	c5 d5 eb d2          	vpor   ymm2,ymm5,ymm2
  212c0d:	c5 f5 db cf          	vpand  ymm1,ymm1,ymm7
  212c11:	c4 e2 bd 47 e9       	vpsllvq ymm5,ymm8,ymm1
  212c16:	c5 d5 eb e4          	vpor   ymm4,ymm5,ymm4
  212c1a:	c4 e2 7d 32 6c 0a 04 	vpmovzxbq ymm5,DWORD PTR [rdx+rcx*1+0x4]
  212c21:	c4 e2 d5 47 ee       	vpsllvq ymm5,ymm5,ymm6
  212c26:	c5 d5 eb db          	vpor   ymm3,ymm5,ymm3
  212c2a:	c4 e2 7d 32 2c 0a    	vpmovzxbq ymm5,DWORD PTR [rdx+rcx*1]
  212c30:	c4 e2 d5 47 c9       	vpsllvq ymm1,ymm5,ymm1
  212c35:	c5 f5 eb c0          	vpor   ymm0,ymm1,ymm0
  212c39:	c5 e5 eb ca          	vpor   ymm1,ymm3,ymm2
  212c3d:	c5 fd eb c4          	vpor   ymm0,ymm0,ymm4
  212c41:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  212c45:	c4 e3 7d 39 c1 01    	vextracti128 xmm1,ymm0,0x1
  212c4b:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  212c4f:	c5 f9 70 c8 4e       	vpshufd xmm1,xmm0,0x4e
  212c54:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  212c58:	c4 e1 f9 7e c1       	vmovq  rcx,xmm0
  212c5d:	48 39 d8             	cmp    rax,rbx
            for (bytes) |b, index| {
  212c60:	74 29                	je     212c8b <parseFormValue+0x29eb>
  212c62:	48 29 d8             	sub    rax,rbx
  212c65:	48 01 da             	add    rdx,rbx
  212c68:	48 c1 e3 03          	shl    rbx,0x3
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  212c6c:	0f b6 3a             	movzx  edi,BYTE PTR [rdx]
  212c6f:	89 de                	mov    esi,ebx
  212c71:	40 80 e6 38          	and    sil,0x38
  212c75:	c4 e2 c9 f7 f7       	shlx   rsi,rdi,rsi
  212c7a:	48 09 f1             	or     rcx,rsi
            for (bytes) |b, index| {
  212c7d:	48 83 c3 08          	add    rbx,0x8
  212c81:	48 83 c2 01          	add    rdx,0x1
  212c85:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  212c89:	75 e1                	jne    212c6c <parseFormValue+0x29cc>
  212c8b:	48 8d 7c 24 78       	lea    rdi,[rsp+0x78]
    const buf = try readAllocBytes(allocator, in_stream, size);
  212c90:	4c 89 fe             	mov    rsi,r15
  212c93:	4c 89 e2             	mov    rdx,r12
  212c96:	c5 f8 77             	vzeroupper 
  212c99:	e8 92 03 00 00       	call   213030 <readAllocBytes>
  212c9e:	0f b7 44 24 78       	movzx  eax,WORD PTR [rsp+0x78]
  212ca3:	66 85 c0             	test   ax,ax
  212ca6:	74 39                	je     212ce1 <parseFormValue+0x2a41>
  212ca8:	c5 f8 10 44 24 40    	vmovups xmm0,XMMWORD PTR [rsp+0x40]
  212cae:	c5 fa 6f 4c 24 4e    	vmovdqu xmm1,XMMWORD PTR [rsp+0x4e]
  212cb4:	c5 fa 7f 8c 24 9e 00 	vmovdqu XMMWORD PTR [rsp+0x9e],xmm1
  212cbb:	00 00 
  212cbd:	c5 f8 29 84 24 90 00 	vmovaps XMMWORD PTR [rsp+0x90],xmm0
  212cc4:	00 00 
  212cc6:	8b 4c 24 60          	mov    ecx,DWORD PTR [rsp+0x60]
  212cca:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  212ccd:	0f b7 4c 24 64       	movzx  ecx,WORD PTR [rsp+0x64]
  212cd2:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  212cd7:	8a 4c 24 66          	mov    cl,BYTE PTR [rsp+0x66]
  212cdb:	88 4c 24 06          	mov    BYTE PTR [rsp+0x6],cl
  212cdf:	eb 65                	jmp    212d46 <parseFormValue+0x2aa6>
  212ce1:	c5 f8 10 84 24 80 00 	vmovups xmm0,XMMWORD PTR [rsp+0x80]
  212ce8:	00 00 
  212cea:	c5 f8 29 84 24 b0 00 	vmovaps XMMWORD PTR [rsp+0xb0],xmm0
  212cf1:	00 00 
    return FormValue{ .Block = buf };
  212cf3:	c5 f8 11 44 24 1e    	vmovups XMMWORD PTR [rsp+0x1e],xmm0
  212cf9:	48 8b 84 24 c0 00 00 	mov    rax,QWORD PTR [rsp+0xc0]
  212d00:	00 
  212d01:	48 89 44 24 2e       	mov    QWORD PTR [rsp+0x2e],rax
  212d06:	c6 44 24 08 01       	mov    BYTE PTR [rsp+0x8],0x1
  212d0b:	8b 44 24 71          	mov    eax,DWORD PTR [rsp+0x71]
  212d0f:	89 04 24             	mov    DWORD PTR [rsp],eax
  212d12:	0f b7 44 24 75       	movzx  eax,WORD PTR [rsp+0x75]
  212d17:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  212d1c:	8a 44 24 77          	mov    al,BYTE PTR [rsp+0x77]
  212d20:	88 44 24 06          	mov    BYTE PTR [rsp+0x6],al
  212d24:	c5 f8 10 44 24 18    	vmovups xmm0,XMMWORD PTR [rsp+0x18]
  212d2a:	c5 f8 29 84 24 90 00 	vmovaps XMMWORD PTR [rsp+0x90],xmm0
  212d31:	00 00 
  212d33:	c5 f8 10 44 24 26    	vmovups xmm0,XMMWORD PTR [rsp+0x26]
  212d39:	c5 f8 11 84 24 9e 00 	vmovups XMMWORD PTR [rsp+0x9e],xmm0
  212d40:	00 00 
  212d42:	b1 01                	mov    cl,0x1
  212d44:	31 c0                	xor    eax,eax
    return parseFormValueBlockLen(allocator, in_stream, block_len);
  212d46:	66 89 84 24 b8 02 00 	mov    WORD PTR [rsp+0x2b8],ax
  212d4d:	00 
  212d4e:	c5 f8 28 84 24 90 00 	vmovaps xmm0,XMMWORD PTR [rsp+0x90]
  212d55:	00 00 
  212d57:	c5 f8 11 84 24 ba 02 	vmovups XMMWORD PTR [rsp+0x2ba],xmm0
  212d5e:	00 00 
  212d60:	c5 f8 10 84 24 9e 00 	vmovups xmm0,XMMWORD PTR [rsp+0x9e]
  212d67:	00 00 
  212d69:	c5 f8 11 84 24 c8 02 	vmovups XMMWORD PTR [rsp+0x2c8],xmm0
  212d70:	00 00 
  212d72:	88 8c 24 d8 02 00 00 	mov    BYTE PTR [rsp+0x2d8],cl
  212d79:	8b 04 24             	mov    eax,DWORD PTR [rsp]
  212d7c:	89 84 24 d9 02 00 00 	mov    DWORD PTR [rsp+0x2d9],eax
  212d83:	0f b7 44 24 04       	movzx  eax,WORD PTR [rsp+0x4]
  212d88:	66 89 84 24 dd 02 00 	mov    WORD PTR [rsp+0x2dd],ax
  212d8f:	00 
  212d90:	8a 44 24 06          	mov    al,BYTE PTR [rsp+0x6]
  212d94:	e9 d5 da ff ff       	jmp    21086e <parseFormValue+0x5ce>
  212d99:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

0000000000212da0 <Allocator_alignedRealloc.44>:
    pub fn alignedRealloc(self: *Allocator, comptime T: type, comptime alignment: u29, old_mem: []align(alignment) T, n: usize) ![]align(alignment) T {
  212da0:	41 56                	push   r14
  212da2:	53                   	push   rbx
  212da3:	48 81 ec 88 00 00 00 	sub    rsp,0x88
  212daa:	48 89 fb             	mov    rbx,rdi
        if (old_mem.len == 0) {
  212dad:	48 8b 42 08          	mov    rax,QWORD PTR [rdx+0x8]
  212db1:	48 85 c0             	test   rax,rax
  212db4:	74 62                	je     212e18 <Allocator_alignedRealloc.44+0x78>
        if (n == 0) {
  212db6:	48 85 c9             	test   rcx,rcx
  212db9:	0f 84 a9 00 00 00    	je     212e68 <Allocator_alignedRealloc.44+0xc8>
        const old_byte_slice = @sliceToBytes(old_mem);
  212dbf:	48 8b 12             	mov    rdx,QWORD PTR [rdx]
  212dc2:	48 c1 e0 03          	shl    rax,0x3
  212dc6:	48 8d 04 80          	lea    rax,[rax+rax*4]
  212dca:	48 89 54 24 38       	mov    QWORD PTR [rsp+0x38],rdx
  212dcf:	48 89 44 24 40       	mov    QWORD PTR [rsp+0x40],rax
  212dd4:	ba 28 00 00 00       	mov    edx,0x28
  212dd9:	48 89 c8             	mov    rax,rcx
  212ddc:	48 f7 e2             	mul    rdx
  212ddf:	0f 81 d0 00 00 00    	jno    212eb5 <Allocator_alignedRealloc.44+0x115>
  212de5:	48 8d 0d 44 42 ff ff 	lea    rcx,[rip+0xffffffffffff4244]        # 207030 <__unnamed_54>
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  212dec:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  212df0:	0f 84 da 00 00 00    	je     212ed0 <Allocator_alignedRealloc.44+0x130>
  212df6:	48 8b 05 6b 28 ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffff286b]        # 205668 <__unnamed_69+0x10>
  212dfd:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  212e01:	c5 f8 10 05 4f 28 ff 	vmovups xmm0,XMMWORD PTR [rip+0xffffffffffff284f]        # 205658 <__unnamed_69>
  212e08:	ff 
  212e09:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  212e0d:	48 81 c4 88 00 00 00 	add    rsp,0x88
  212e14:	5b                   	pop    rbx
  212e15:	41 5e                	pop    r14
  212e17:	c3                   	ret    
        if (n == 0) {
  212e18:	48 85 c9             	test   rcx,rcx
  212e1b:	0f 84 fc 00 00 00    	je     212f1d <Allocator_alignedRealloc.44+0x17d>
  212e21:	ba 28 00 00 00       	mov    edx,0x28
  212e26:	48 89 c8             	mov    rax,rcx
  212e29:	48 f7 e2             	mul    rdx
  212e2c:	0f 81 0c 01 00 00    	jno    212f3e <Allocator_alignedRealloc.44+0x19e>
  212e32:	48 8d 0d f7 41 ff ff 	lea    rcx,[rip+0xffffffffffff41f7]        # 207030 <__unnamed_54>
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  212e39:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  212e3d:	0f 84 16 01 00 00    	je     212f59 <Allocator_alignedRealloc.44+0x1b9>
  212e43:	0f b7 05 14 28 ff ff 	movzx  eax,WORD PTR [rip+0xffffffffffff2814]        # 20565e <__unnamed_69+0x6>
  212e4a:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  212e4f:	8b 05 05 28 ff ff    	mov    eax,DWORD PTR [rip+0xffffffffffff2805]        # 20565a <__unnamed_69+0x2>
  212e55:	89 04 24             	mov    DWORD PTR [rsp],eax
  212e58:	48 89 e0             	mov    rax,rsp
  212e5b:	66 b9 10 00          	mov    cx,0x10
  212e5f:	31 f6                	xor    esi,esi
  212e61:	31 d2                	xor    edx,edx
  212e63:	e9 9d 01 00 00       	jmp    213005 <Allocator_alignedRealloc.44+0x265>
        const bytes = @sliceToBytes(memory);
  212e68:	48 c1 e0 03          	shl    rax,0x3
  212e6c:	48 8d 04 80          	lea    rax,[rax+rax*4]
        if (bytes.len == 0) return;
  212e70:	48 85 c0             	test   rax,rax
  212e73:	74 1e                	je     212e93 <Allocator_alignedRealloc.44+0xf3>
        const bytes = @sliceToBytes(memory);
  212e75:	48 8b 0a             	mov    rcx,QWORD PTR [rdx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  212e78:	48 8b 56 10          	mov    rdx,QWORD PTR [rsi+0x10]
  212e7c:	48 89 4c 24 08       	mov    QWORD PTR [rsp+0x8],rcx
  212e81:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  212e86:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  212e8b:	48 89 f7             	mov    rdi,rsi
  212e8e:	48 89 c6             	mov    rsi,rax
  212e91:	ff d2                	call   rdx
            return ([*]align(alignment) T)(undefined)[0..0];
  212e93:	48 8b 05 b6 27 ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffff27b6]        # 205650 <__unnamed_70+0x10>
  212e9a:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  212e9e:	c5 f8 10 05 9a 27 ff 	vmovups xmm0,XMMWORD PTR [rip+0xffffffffffff279a]        # 205640 <__unnamed_70>
  212ea5:	ff 
  212ea6:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  212eaa:	48 81 c4 88 00 00 00 	add    rsp,0x88
  212eb1:	5b                   	pop    rbx
  212eb2:	41 5e                	pop    r14
  212eb4:	c3                   	ret    
  212eb5:	48 8d 4c 24 08       	lea    rcx,[rsp+0x8]
  212eba:	66 c7 44 24 08 00 00 	mov    WORD PTR [rsp+0x8],0x0
  212ec1:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  212ec6:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  212eca:	0f 85 26 ff ff ff    	jne    212df6 <Allocator_alignedRealloc.44+0x56>
  212ed0:	4c 8b 71 08          	mov    r14,QWORD PTR [rcx+0x8]
  212ed4:	48 8d 7c 24 58       	lea    rdi,[rsp+0x58]
  212ed9:	48 8d 54 24 38       	lea    rdx,[rsp+0x38]
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  212ede:	41 b8 08 00 00 00    	mov    r8d,0x8
  212ee4:	4c 89 f1             	mov    rcx,r14
  212ee7:	ff 56 08             	call   QWORD PTR [rsi+0x8]
  212eea:	0f b7 44 24 58       	movzx  eax,WORD PTR [rsp+0x58]
  212eef:	66 85 c0             	test   ax,ax
  212ef2:	0f 84 94 00 00 00    	je     212f8c <Allocator_alignedRealloc.44+0x1ec>
  212ef8:	66 89 03             	mov    WORD PTR [rbx],ax
  212efb:	48 8b 84 24 80 00 00 	mov    rax,QWORD PTR [rsp+0x80]
  212f02:	00 
  212f03:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  212f07:	c5 f8 10 44 24 72    	vmovups xmm0,XMMWORD PTR [rsp+0x72]
  212f0d:	c5 f8 11 43 02       	vmovups XMMWORD PTR [rbx+0x2],xmm0
  212f12:	48 81 c4 88 00 00 00 	add    rsp,0x88
  212f19:	5b                   	pop    rbx
  212f1a:	41 5e                	pop    r14
  212f1c:	c3                   	ret    
  212f1d:	48 89 e0             	mov    rax,rsp
            return ([*]align(alignment) T)(undefined)[0..0];
  212f20:	0f b7 0d 1f 27 ff ff 	movzx  ecx,WORD PTR [rip+0xffffffffffff271f]        # 205646 <__unnamed_70+0x6>
  212f27:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  212f2c:	8b 0d 10 27 ff ff    	mov    ecx,DWORD PTR [rip+0xffffffffffff2710]        # 205642 <__unnamed_70+0x2>
  212f32:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  212f35:	31 c9                	xor    ecx,ecx
  212f37:	31 d2                	xor    edx,edx
  212f39:	e9 c7 00 00 00       	jmp    213005 <Allocator_alignedRealloc.44+0x265>
  212f3e:	48 8d 4c 24 48       	lea    rcx,[rsp+0x48]
  212f43:	66 c7 44 24 48 00 00 	mov    WORD PTR [rsp+0x48],0x0
  212f4a:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  212f4f:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  212f53:	0f 85 ea fe ff ff    	jne    212e43 <Allocator_alignedRealloc.44+0xa3>
  212f59:	4c 8b 71 08          	mov    r14,QWORD PTR [rcx+0x8]
  212f5d:	48 8d 7c 24 08       	lea    rdi,[rsp+0x8]
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  212f62:	b9 08 00 00 00       	mov    ecx,0x8
  212f67:	4c 89 f2             	mov    rdx,r14
  212f6a:	ff 16                	call   QWORD PTR [rsi]
  212f6c:	0f b7 4c 24 08       	movzx  ecx,WORD PTR [rsp+0x8]
  212f71:	66 85 c9             	test   cx,cx
  212f74:	74 57                	je     212fcd <Allocator_alignedRealloc.44+0x22d>
  212f76:	0f b7 44 24 36       	movzx  eax,WORD PTR [rsp+0x36]
  212f7b:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  212f80:	48 89 e0             	mov    rax,rsp
  212f83:	8b 54 24 32          	mov    edx,DWORD PTR [rsp+0x32]
  212f87:	89 14 24             	mov    DWORD PTR [rsp],edx
  212f8a:	eb 79                	jmp    213005 <Allocator_alignedRealloc.44+0x265>
        assert(byte_slice.len == byte_count);
  212f8c:	4c 39 74 24 68       	cmp    QWORD PTR [rsp+0x68],r14
    if (!ok) {
  212f91:	0f 85 91 00 00 00    	jne    213028 <Allocator_alignedRealloc.44+0x288>
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  212f97:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  212f9c:	48 b9 cd cc cc cc cc 	movabs rcx,0xcccccccccccccccd
  212fa3:	cc cc cc 
  212fa6:	4c 89 f2             	mov    rdx,r14
  212fa9:	c4 e2 f3 f6 d1       	mulx   rdx,rcx,rcx
  212fae:	66 c7 03 00 00       	mov    WORD PTR [rbx],0x0
  212fb3:	0f b7 4c 24 2a       	movzx  ecx,WORD PTR [rsp+0x2a]
  212fb8:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  212fbc:	48 c1 ea 05          	shr    rdx,0x5
  212fc0:	8b 4c 24 26          	mov    ecx,DWORD PTR [rsp+0x26]
  212fc4:	89 4b 02             	mov    DWORD PTR [rbx+0x2],ecx
  212fc7:	48 89 43 08          	mov    QWORD PTR [rbx+0x8],rax
  212fcb:	eb 4c                	jmp    213019 <Allocator_alignedRealloc.44+0x279>
        assert(byte_slice.len == byte_count);
  212fcd:	4c 39 74 24 18       	cmp    QWORD PTR [rsp+0x18],r14
  212fd2:	75 54                	jne    213028 <Allocator_alignedRealloc.44+0x288>
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  212fd4:	48 8b 74 24 10       	mov    rsi,QWORD PTR [rsp+0x10]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  212fd9:	48 b8 cd cc cc cc cc 	movabs rax,0xcccccccccccccccd
  212fe0:	cc cc cc 
  212fe3:	4c 89 f2             	mov    rdx,r14
  212fe6:	c4 e2 fb f6 d0       	mulx   rdx,rax,rax
  212feb:	48 c1 ea 05          	shr    rdx,0x5
  212fef:	48 89 e0             	mov    rax,rsp
  212ff2:	8b 4c 24 2c          	mov    ecx,DWORD PTR [rsp+0x2c]
  212ff6:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  212ff9:	0f b7 4c 24 30       	movzx  ecx,WORD PTR [rsp+0x30]
  212ffe:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  213003:	31 c9                	xor    ecx,ecx
            return self.alignedAlloc(T, alignment, n);
  213005:	66 89 0b             	mov    WORD PTR [rbx],cx
  213008:	0f b7 48 04          	movzx  ecx,WORD PTR [rax+0x4]
  21300c:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  213010:	8b 00                	mov    eax,DWORD PTR [rax]
  213012:	89 43 02             	mov    DWORD PTR [rbx+0x2],eax
  213015:	48 89 73 08          	mov    QWORD PTR [rbx+0x8],rsi
  213019:	48 89 53 10          	mov    QWORD PTR [rbx+0x10],rdx
  21301d:	48 81 c4 88 00 00 00 	add    rsp,0x88
  213024:	5b                   	pop    rbx
  213025:	41 5e                	pop    r14
  213027:	c3                   	ret    
            @panic("assertion failure");
  213028:	e8 f3 5c ff ff       	call   208d20 <panic>
  21302d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000213030 <readAllocBytes>:
fn readAllocBytes(allocator: *mem.Allocator, in_stream: var, size: usize) ![]u8 {
  213030:	55                   	push   rbp
  213031:	41 57                	push   r15
  213033:	41 56                	push   r14
  213035:	41 54                	push   r12
  213037:	53                   	push   rbx
  213038:	48 83 ec 70          	sub    rsp,0x70
  21303c:	48 89 cb             	mov    rbx,rcx
  21303f:	49 89 d4             	mov    r12,rdx
  213042:	49 89 f6             	mov    r14,rsi
  213045:	49 89 ff             	mov    r15,rdi
        if (n == 0) {
  213048:	48 85 db             	test   rbx,rbx
  21304b:	74 32                	je     21307f <readAllocBytes+0x4f>
  21304d:	48 89 e7             	mov    rdi,rsp
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  213050:	b9 01 00 00 00       	mov    ecx,0x1
  213055:	4c 89 f6             	mov    rsi,r14
  213058:	48 89 da             	mov    rdx,rbx
  21305b:	41 ff 16             	call   QWORD PTR [r14]
  21305e:	0f b7 04 24          	movzx  eax,WORD PTR [rsp]
  213062:	66 85 c0             	test   ax,ax
  213065:	74 1c                	je     213083 <readAllocBytes+0x53>
    const buf = try allocator.alloc(u8, size);
  213067:	66 41 89 07          	mov    WORD PTR [r15],ax
  21306b:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  213070:	49 89 47 10          	mov    QWORD PTR [r15+0x10],rax
  213074:	c5 f8 10 44 24 5a    	vmovups xmm0,XMMWORD PTR [rsp+0x5a]
  21307a:	e9 d8 00 00 00       	jmp    213157 <readAllocBytes+0x127>
  21307f:	31 c0                	xor    eax,eax
  213081:	eb 13                	jmp    213096 <readAllocBytes+0x66>
        assert(byte_slice.len == byte_count);
  213083:	48 39 5c 24 10       	cmp    QWORD PTR [rsp+0x10],rbx
    if (!ok) {
  213088:	0f 85 dc 00 00 00    	jne    21316a <readAllocBytes+0x13a>
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  21308e:	48 8b 4c 24 08       	mov    rcx,QWORD PTR [rsp+0x8]
  213093:	48 89 d8             	mov    rax,rbx
    const buf = try allocator.alloc(u8, size);
  213096:	48 89 4c 24 18       	mov    QWORD PTR [rsp+0x18],rcx
  21309b:	48 89 44 24 20       	mov    QWORD PTR [rsp+0x20],rax
  2130a0:	48 89 e7             	mov    rdi,rsp
  2130a3:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  2130a8:	4c 89 e6             	mov    rsi,r12
  2130ab:	41 ff 14 24          	call   QWORD PTR [r12]
  2130af:	0f b7 2c 24          	movzx  ebp,WORD PTR [rsp]
    if ((try in_stream.read(buf)) < size) return error.EndOfFile;
  2130b3:	66 85 ed             	test   bp,bp
  2130b6:	74 39                	je     2130f1 <readAllocBytes+0xc1>
        const bytes = @sliceToBytes(memory);
  2130b8:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
        if (bytes.len == 0) return;
  2130bd:	48 85 c0             	test   rax,rax
  2130c0:	74 1a                	je     2130dc <readAllocBytes+0xac>
        const bytes = @sliceToBytes(memory);
  2130c2:	48 8b 4c 24 18       	mov    rcx,QWORD PTR [rsp+0x18]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  2130c7:	49 8b 56 10          	mov    rdx,QWORD PTR [r14+0x10]
  2130cb:	48 89 0c 24          	mov    QWORD PTR [rsp],rcx
  2130cf:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  2130d4:	48 89 e6             	mov    rsi,rsp
  2130d7:	4c 89 f7             	mov    rdi,r14
  2130da:	ff d2                	call   rdx
  2130dc:	66 41 89 2f          	mov    WORD PTR [r15],bp
  2130e0:	48 8b 44 24 52       	mov    rax,QWORD PTR [rsp+0x52]
  2130e5:	49 89 47 10          	mov    QWORD PTR [r15+0x10],rax
  2130e9:	c5 f8 10 44 24 44    	vmovups xmm0,XMMWORD PTR [rsp+0x44]
  2130ef:	eb 66                	jmp    213157 <readAllocBytes+0x127>
  2130f1:	48 39 5c 24 08       	cmp    QWORD PTR [rsp+0x8],rbx
  2130f6:	73 3e                	jae    213136 <readAllocBytes+0x106>
        const bytes = @sliceToBytes(memory);
  2130f8:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
        if (bytes.len == 0) return;
  2130fd:	48 85 c0             	test   rax,rax
  213100:	74 1a                	je     21311c <readAllocBytes+0xec>
        const bytes = @sliceToBytes(memory);
  213102:	48 8b 4c 24 18       	mov    rcx,QWORD PTR [rsp+0x18]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  213107:	49 8b 56 10          	mov    rdx,QWORD PTR [r14+0x10]
  21310b:	48 89 0c 24          	mov    QWORD PTR [rsp],rcx
  21310f:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  213114:	48 89 e6             	mov    rsi,rsp
  213117:	4c 89 f7             	mov    rdi,r14
  21311a:	ff d2                	call   rdx
  21311c:	48 8b 05 cd 28 ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffff28cd]        # 2059f0 <__unnamed_71+0x10>
  213123:	49 89 47 10          	mov    QWORD PTR [r15+0x10],rax
  213127:	c5 f8 10 05 b1 28 ff 	vmovups xmm0,XMMWORD PTR [rip+0xffffffffffff28b1]        # 2059e0 <__unnamed_71>
  21312e:	ff 
  21312f:	c4 c1 78 11 07       	vmovups XMMWORD PTR [r15],xmm0
  213134:	eb 27                	jmp    21315d <readAllocBytes+0x12d>
    return buf;
  213136:	c5 f8 10 44 24 18    	vmovups xmm0,XMMWORD PTR [rsp+0x18]
  21313c:	c5 f8 11 44 24 34    	vmovups XMMWORD PTR [rsp+0x34],xmm0
  213142:	66 41 c7 07 00 00    	mov    WORD PTR [r15],0x0
  213148:	48 8b 44 24 3c       	mov    rax,QWORD PTR [rsp+0x3c]
  21314d:	49 89 47 10          	mov    QWORD PTR [r15+0x10],rax
  213151:	c5 f8 10 44 24 2e    	vmovups xmm0,XMMWORD PTR [rsp+0x2e]
  213157:	c4 c1 78 11 47 02    	vmovups XMMWORD PTR [r15+0x2],xmm0
  21315d:	48 83 c4 70          	add    rsp,0x70
  213161:	5b                   	pop    rbx
  213162:	41 5c                	pop    r12
  213164:	41 5e                	pop    r14
  213166:	41 5f                	pop    r15
  213168:	5d                   	pop    rbp
  213169:	c3                   	ret    
            @panic("assertion failure");
  21316a:	e8 b1 5b ff ff       	call   208d20 <panic>
  21316f:	90                   	nop

0000000000213170 <readStringRaw>:
            return Self{
  213170:	55                   	push   rbp
  213171:	41 57                	push   r15
  213173:	41 56                	push   r14
  213175:	41 55                	push   r13
  213177:	41 54                	push   r12
  213179:	53                   	push   rbx
  21317a:	48 81 ec 98 00 00 00 	sub    rsp,0x98
  213181:	c5 f8 57 c0          	vxorps xmm0,xmm0,xmm0
  213185:	c5 f8 29 44 24 40    	vmovaps XMMWORD PTR [rsp+0x40],xmm0
  21318b:	48 89 d3             	mov    rbx,rdx
  21318e:	49 89 f7             	mov    r15,rsi
  213191:	48 89 7c 24 08       	mov    QWORD PTR [rsp+0x8],rdi
  213196:	48 c7 44 24 50 00 00 	mov    QWORD PTR [rsp+0x50],0x0
  21319d:	00 00 
    var buf = ArrayList(u8).init(allocator);
  21319f:	4c 89 7c 24 58       	mov    QWORD PTR [rsp+0x58],r15
  2131a4:	48 8d 44 24 07       	lea    rax,[rsp+0x7]
            try self.readNoEof(result[0..]);
  2131a9:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  2131ae:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  2131b5:	00 00 
  2131b7:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  2131bc:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
            return self.readFn(self, buffer);
  2131c1:	48 89 de             	mov    rsi,rbx
  2131c4:	ff 13                	call   QWORD PTR [rbx]
  2131c6:	0f b7 4c 24 20       	movzx  ecx,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  2131cb:	66 85 c9             	test   cx,cx
  2131ce:	74 34                	je     213204 <readStringRaw+0x94>
  2131d0:	48 8b 54 24 08       	mov    rdx,QWORD PTR [rsp+0x8]
        const byte = try in_stream.readByte();
  2131d5:	66 89 0a             	mov    WORD PTR [rdx],cx
  2131d8:	48 8b 84 24 90 00 00 	mov    rax,QWORD PTR [rsp+0x90]
  2131df:	00 
  2131e0:	48 89 42 10          	mov    QWORD PTR [rdx+0x10],rax
  2131e4:	c5 f8 10 84 24 82 00 	vmovups xmm0,XMMWORD PTR [rsp+0x82]
  2131eb:	00 00 
  2131ed:	c5 f8 11 42 02       	vmovups XMMWORD PTR [rdx+0x2],xmm0
  2131f2:	48 81 c4 98 00 00 00 	add    rsp,0x98
  2131f9:	5b                   	pop    rbx
  2131fa:	41 5c                	pop    r12
  2131fc:	41 5d                	pop    r13
  2131fe:	41 5e                	pop    r14
  213200:	41 5f                	pop    r15
  213202:	5d                   	pop    rbp
  213203:	c3                   	ret    
  213204:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
  213209:	31 ed                	xor    ebp,ebp
  21320b:	45 31 ed             	xor    r13d,r13d
  21320e:	66 90                	xchg   ax,ax
            if (amt_read < buf.len) return error.EndOfStream;
  213210:	48 3b 44 24 18       	cmp    rax,QWORD PTR [rsp+0x18]
  213215:	0f 82 b6 00 00 00    	jb     2132d1 <readStringRaw+0x161>
            return result[0];
  21321b:	44 8a 64 24 07       	mov    r12b,BYTE PTR [rsp+0x7]
        if (byte == 0) break;
  213220:	45 84 e4             	test   r12b,r12b
  213223:	0f 84 b1 00 00 00    	je     2132da <readStringRaw+0x16a>
            var better_capacity = self.items.len;
  213229:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
            if (better_capacity >= new_capacity) return;
  21322e:	4c 39 e9             	cmp    rcx,r13
  213231:	77 53                	ja     213286 <readStringRaw+0x116>
  213233:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21323a:	84 00 00 00 00 00 
                better_capacity += better_capacity / 2 + 8;
  213240:	48 89 c8             	mov    rax,rcx
  213243:	48 d1 e8             	shr    rax,1
  213246:	48 01 c1             	add    rcx,rax
  213249:	48 83 c1 08          	add    rcx,0x8
                if (better_capacity >= new_capacity) break;
  21324d:	4c 39 e9             	cmp    rcx,r13
  213250:	76 ee                	jbe    213240 <readStringRaw+0xd0>
            self.items = try self.allocator.alignedRealloc(T, A, self.items, better_capacity);
  213252:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  213257:	4c 89 fe             	mov    rsi,r15
  21325a:	48 8d 54 24 40       	lea    rdx,[rsp+0x40]
  21325f:	e8 0c 28 00 00       	call   215a70 <Allocator_alignedRealloc.68>
  213264:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  213269:	66 85 c0             	test   ax,ax
  21326c:	0f 85 94 00 00 00    	jne    213306 <readStringRaw+0x196>
  213272:	48 8d 44 24 28       	lea    rax,[rsp+0x28]
  213277:	c5 f8 10 00          	vmovups xmm0,XMMWORD PTR [rax]
  21327b:	c5 f8 29 44 24 40    	vmovaps XMMWORD PTR [rsp+0x40],xmm0
            const result = &self.items[self.len];
  213281:	48 8b 6c 24 40       	mov    rbp,QWORD PTR [rsp+0x40]
  213286:	4d 8d 75 01          	lea    r14,[r13+0x1]
            self.len = new_length;
  21328a:	4c 89 74 24 50       	mov    QWORD PTR [rsp+0x50],r14
            new_item_ptr.* = item;
  21328f:	46 88 64 2d 00       	mov    BYTE PTR [rbp+r13*1+0x0],r12b
            try self.readNoEof(result[0..]);
  213294:	48 8d 44 24 07       	lea    rax,[rsp+0x7]
  213299:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  21329e:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  2132a5:	00 00 
            return self.readFn(self, buffer);
  2132a7:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  2132ac:	48 89 de             	mov    rsi,rbx
  2132af:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  2132b4:	ff 13                	call   QWORD PTR [rbx]
  2132b6:	0f b7 4c 24 20       	movzx  ecx,WORD PTR [rsp+0x20]
  2132bb:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
  2132c0:	4d 89 f5             	mov    r13,r14
            const amt_read = try self.read(buf);
  2132c3:	66 85 c9             	test   cx,cx
  2132c6:	0f 84 44 ff ff ff    	je     213210 <readStringRaw+0xa0>
  2132cc:	e9 ff fe ff ff       	jmp    2131d0 <readStringRaw+0x60>
  2132d1:	66 b9 1e 00          	mov    cx,0x1e
  2132d5:	e9 f6 fe ff ff       	jmp    2131d0 <readStringRaw+0x60>
  2132da:	48 8b 54 24 08       	mov    rdx,QWORD PTR [rsp+0x8]
    return buf.toSlice();
  2132df:	66 c7 02 00 00       	mov    WORD PTR [rdx],0x0
  2132e4:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  2132e9:	66 89 42 06          	mov    WORD PTR [rdx+0x6],ax
            return self.items[0..self.len];
  2132ed:	48 8b 44 24 40       	mov    rax,QWORD PTR [rsp+0x40]
  2132f2:	8b 4c 24 3a          	mov    ecx,DWORD PTR [rsp+0x3a]
  2132f6:	89 4a 02             	mov    DWORD PTR [rdx+0x2],ecx
  2132f9:	48 89 42 08          	mov    QWORD PTR [rdx+0x8],rax
  2132fd:	4c 89 6a 10          	mov    QWORD PTR [rdx+0x10],r13
  213301:	e9 ec fe ff ff       	jmp    2131f2 <readStringRaw+0x82>
  213306:	48 8b 4c 24 08       	mov    rcx,QWORD PTR [rsp+0x8]
        try buf.append(byte);
  21330b:	66 89 01             	mov    WORD PTR [rcx],ax
  21330e:	48 8b 44 24 7a       	mov    rax,QWORD PTR [rsp+0x7a]
  213313:	48 89 41 10          	mov    QWORD PTR [rcx+0x10],rax
  213317:	c5 f8 10 44 24 6c    	vmovups xmm0,XMMWORD PTR [rsp+0x6c]
  21331d:	c5 f8 11 41 02       	vmovups XMMWORD PTR [rcx+0x2],xmm0
  213322:	e9 cb fe ff ff       	jmp    2131f2 <readStringRaw+0x82>
  213327:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  21332e:	00 00 

0000000000213330 <Allocator_alignedRealloc.51>:
    pub fn alignedRealloc(self: *Allocator, comptime T: type, comptime alignment: u29, old_mem: []align(alignment) T, n: usize) ![]align(alignment) T {
  213330:	41 56                	push   r14
  213332:	53                   	push   rbx
  213333:	48 81 ec 88 00 00 00 	sub    rsp,0x88
  21333a:	48 89 fb             	mov    rbx,rdi
        if (old_mem.len == 0) {
  21333d:	48 8b 42 08          	mov    rax,QWORD PTR [rdx+0x8]
  213341:	48 85 c0             	test   rax,rax
  213344:	74 62                	je     2133a8 <Allocator_alignedRealloc.51+0x78>
        if (n == 0) {
  213346:	48 85 c9             	test   rcx,rcx
  213349:	0f 84 a9 00 00 00    	je     2133f8 <Allocator_alignedRealloc.51+0xc8>
        const old_byte_slice = @sliceToBytes(old_mem);
  21334f:	48 8b 12             	mov    rdx,QWORD PTR [rdx]
  213352:	48 c1 e0 04          	shl    rax,0x4
  213356:	48 8d 04 40          	lea    rax,[rax+rax*2]
  21335a:	48 89 54 24 38       	mov    QWORD PTR [rsp+0x38],rdx
  21335f:	48 89 44 24 40       	mov    QWORD PTR [rsp+0x40],rax
  213364:	ba 30 00 00 00       	mov    edx,0x30
  213369:	48 89 c8             	mov    rax,rcx
  21336c:	48 f7 e2             	mul    rdx
  21336f:	0f 81 d0 00 00 00    	jno    213445 <Allocator_alignedRealloc.51+0x115>
  213375:	48 8d 0d b4 3c ff ff 	lea    rcx,[rip+0xffffffffffff3cb4]        # 207030 <__unnamed_54>
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  21337c:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  213380:	0f 84 da 00 00 00    	je     213460 <Allocator_alignedRealloc.51+0x130>
  213386:	48 8b 05 53 23 ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffff2353]        # 2056e0 <__unnamed_72+0x10>
  21338d:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  213391:	c5 f8 10 05 37 23 ff 	vmovups xmm0,XMMWORD PTR [rip+0xffffffffffff2337]        # 2056d0 <__unnamed_72>
  213398:	ff 
  213399:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  21339d:	48 81 c4 88 00 00 00 	add    rsp,0x88
  2133a4:	5b                   	pop    rbx
  2133a5:	41 5e                	pop    r14
  2133a7:	c3                   	ret    
        if (n == 0) {
  2133a8:	48 85 c9             	test   rcx,rcx
  2133ab:	0f 84 fc 00 00 00    	je     2134ad <Allocator_alignedRealloc.51+0x17d>
  2133b1:	ba 30 00 00 00       	mov    edx,0x30
  2133b6:	48 89 c8             	mov    rax,rcx
  2133b9:	48 f7 e2             	mul    rdx
  2133bc:	0f 81 0c 01 00 00    	jno    2134ce <Allocator_alignedRealloc.51+0x19e>
  2133c2:	48 8d 0d 67 3c ff ff 	lea    rcx,[rip+0xffffffffffff3c67]        # 207030 <__unnamed_54>
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  2133c9:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  2133cd:	0f 84 16 01 00 00    	je     2134e9 <Allocator_alignedRealloc.51+0x1b9>
  2133d3:	0f b7 05 fc 22 ff ff 	movzx  eax,WORD PTR [rip+0xffffffffffff22fc]        # 2056d6 <__unnamed_72+0x6>
  2133da:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  2133df:	8b 05 ed 22 ff ff    	mov    eax,DWORD PTR [rip+0xffffffffffff22ed]        # 2056d2 <__unnamed_72+0x2>
  2133e5:	89 04 24             	mov    DWORD PTR [rsp],eax
  2133e8:	48 89 e0             	mov    rax,rsp
  2133eb:	66 b9 10 00          	mov    cx,0x10
  2133ef:	31 f6                	xor    esi,esi
  2133f1:	31 d2                	xor    edx,edx
  2133f3:	e9 9d 01 00 00       	jmp    213595 <Allocator_alignedRealloc.51+0x265>
        const bytes = @sliceToBytes(memory);
  2133f8:	48 c1 e0 04          	shl    rax,0x4
  2133fc:	48 8d 04 40          	lea    rax,[rax+rax*2]
        if (bytes.len == 0) return;
  213400:	48 85 c0             	test   rax,rax
  213403:	74 1e                	je     213423 <Allocator_alignedRealloc.51+0xf3>
        const bytes = @sliceToBytes(memory);
  213405:	48 8b 0a             	mov    rcx,QWORD PTR [rdx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  213408:	48 8b 56 10          	mov    rdx,QWORD PTR [rsi+0x10]
  21340c:	48 89 4c 24 08       	mov    QWORD PTR [rsp+0x8],rcx
  213411:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  213416:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  21341b:	48 89 f7             	mov    rdi,rsi
  21341e:	48 89 c6             	mov    rsi,rax
  213421:	ff d2                	call   rdx
            return ([*]align(alignment) T)(undefined)[0..0];
  213423:	48 8b 05 9e 22 ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffff229e]        # 2056c8 <__unnamed_73+0x10>
  21342a:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  21342e:	c5 f8 10 05 82 22 ff 	vmovups xmm0,XMMWORD PTR [rip+0xffffffffffff2282]        # 2056b8 <__unnamed_73>
  213435:	ff 
  213436:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  21343a:	48 81 c4 88 00 00 00 	add    rsp,0x88
  213441:	5b                   	pop    rbx
  213442:	41 5e                	pop    r14
  213444:	c3                   	ret    
  213445:	48 8d 4c 24 08       	lea    rcx,[rsp+0x8]
  21344a:	66 c7 44 24 08 00 00 	mov    WORD PTR [rsp+0x8],0x0
  213451:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  213456:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  21345a:	0f 85 26 ff ff ff    	jne    213386 <Allocator_alignedRealloc.51+0x56>
  213460:	4c 8b 71 08          	mov    r14,QWORD PTR [rcx+0x8]
  213464:	48 8d 7c 24 58       	lea    rdi,[rsp+0x58]
  213469:	48 8d 54 24 38       	lea    rdx,[rsp+0x38]
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  21346e:	41 b8 02 00 00 00    	mov    r8d,0x2
  213474:	4c 89 f1             	mov    rcx,r14
  213477:	ff 56 08             	call   QWORD PTR [rsi+0x8]
  21347a:	0f b7 44 24 58       	movzx  eax,WORD PTR [rsp+0x58]
  21347f:	66 85 c0             	test   ax,ax
  213482:	0f 84 94 00 00 00    	je     21351c <Allocator_alignedRealloc.51+0x1ec>
  213488:	66 89 03             	mov    WORD PTR [rbx],ax
  21348b:	48 8b 84 24 80 00 00 	mov    rax,QWORD PTR [rsp+0x80]
  213492:	00 
  213493:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  213497:	c5 f8 10 44 24 72    	vmovups xmm0,XMMWORD PTR [rsp+0x72]
  21349d:	c5 f8 11 43 02       	vmovups XMMWORD PTR [rbx+0x2],xmm0
  2134a2:	48 81 c4 88 00 00 00 	add    rsp,0x88
  2134a9:	5b                   	pop    rbx
  2134aa:	41 5e                	pop    r14
  2134ac:	c3                   	ret    
  2134ad:	48 89 e0             	mov    rax,rsp
            return ([*]align(alignment) T)(undefined)[0..0];
  2134b0:	0f b7 0d 07 22 ff ff 	movzx  ecx,WORD PTR [rip+0xffffffffffff2207]        # 2056be <__unnamed_73+0x6>
  2134b7:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  2134bc:	8b 0d f8 21 ff ff    	mov    ecx,DWORD PTR [rip+0xffffffffffff21f8]        # 2056ba <__unnamed_73+0x2>
  2134c2:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  2134c5:	31 c9                	xor    ecx,ecx
  2134c7:	31 d2                	xor    edx,edx
  2134c9:	e9 c7 00 00 00       	jmp    213595 <Allocator_alignedRealloc.51+0x265>
  2134ce:	48 8d 4c 24 48       	lea    rcx,[rsp+0x48]
  2134d3:	66 c7 44 24 48 00 00 	mov    WORD PTR [rsp+0x48],0x0
  2134da:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  2134df:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  2134e3:	0f 85 ea fe ff ff    	jne    2133d3 <Allocator_alignedRealloc.51+0xa3>
  2134e9:	4c 8b 71 08          	mov    r14,QWORD PTR [rcx+0x8]
  2134ed:	48 8d 7c 24 08       	lea    rdi,[rsp+0x8]
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  2134f2:	b9 02 00 00 00       	mov    ecx,0x2
  2134f7:	4c 89 f2             	mov    rdx,r14
  2134fa:	ff 16                	call   QWORD PTR [rsi]
  2134fc:	0f b7 4c 24 08       	movzx  ecx,WORD PTR [rsp+0x8]
  213501:	66 85 c9             	test   cx,cx
  213504:	74 57                	je     21355d <Allocator_alignedRealloc.51+0x22d>
  213506:	0f b7 44 24 36       	movzx  eax,WORD PTR [rsp+0x36]
  21350b:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  213510:	48 89 e0             	mov    rax,rsp
  213513:	8b 54 24 32          	mov    edx,DWORD PTR [rsp+0x32]
  213517:	89 14 24             	mov    DWORD PTR [rsp],edx
  21351a:	eb 79                	jmp    213595 <Allocator_alignedRealloc.51+0x265>
        assert(byte_slice.len == byte_count);
  21351c:	4c 39 74 24 68       	cmp    QWORD PTR [rsp+0x68],r14
    if (!ok) {
  213521:	0f 85 91 00 00 00    	jne    2135b8 <Allocator_alignedRealloc.51+0x288>
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  213527:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  21352c:	48 b9 ab aa aa aa aa 	movabs rcx,0xaaaaaaaaaaaaaaab
  213533:	aa aa aa 
  213536:	4c 89 f2             	mov    rdx,r14
  213539:	c4 e2 f3 f6 d1       	mulx   rdx,rcx,rcx
  21353e:	66 c7 03 00 00       	mov    WORD PTR [rbx],0x0
  213543:	0f b7 4c 24 2a       	movzx  ecx,WORD PTR [rsp+0x2a]
  213548:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  21354c:	48 c1 ea 05          	shr    rdx,0x5
  213550:	8b 4c 24 26          	mov    ecx,DWORD PTR [rsp+0x26]
  213554:	89 4b 02             	mov    DWORD PTR [rbx+0x2],ecx
  213557:	48 89 43 08          	mov    QWORD PTR [rbx+0x8],rax
  21355b:	eb 4c                	jmp    2135a9 <Allocator_alignedRealloc.51+0x279>
        assert(byte_slice.len == byte_count);
  21355d:	4c 39 74 24 18       	cmp    QWORD PTR [rsp+0x18],r14
  213562:	75 54                	jne    2135b8 <Allocator_alignedRealloc.51+0x288>
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  213564:	48 8b 74 24 10       	mov    rsi,QWORD PTR [rsp+0x10]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  213569:	48 b8 ab aa aa aa aa 	movabs rax,0xaaaaaaaaaaaaaaab
  213570:	aa aa aa 
  213573:	4c 89 f2             	mov    rdx,r14
  213576:	c4 e2 fb f6 d0       	mulx   rdx,rax,rax
  21357b:	48 c1 ea 05          	shr    rdx,0x5
  21357f:	48 89 e0             	mov    rax,rsp
  213582:	8b 4c 24 2c          	mov    ecx,DWORD PTR [rsp+0x2c]
  213586:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  213589:	0f b7 4c 24 30       	movzx  ecx,WORD PTR [rsp+0x30]
  21358e:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  213593:	31 c9                	xor    ecx,ecx
            return self.alignedAlloc(T, alignment, n);
  213595:	66 89 0b             	mov    WORD PTR [rbx],cx
  213598:	0f b7 48 04          	movzx  ecx,WORD PTR [rax+0x4]
  21359c:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  2135a0:	8b 00                	mov    eax,DWORD PTR [rax]
  2135a2:	89 43 02             	mov    DWORD PTR [rbx+0x2],eax
  2135a5:	48 89 73 08          	mov    QWORD PTR [rbx+0x8],rsi
  2135a9:	48 89 53 10          	mov    QWORD PTR [rbx+0x10],rdx
  2135ad:	48 81 c4 88 00 00 00 	add    rsp,0x88
  2135b4:	5b                   	pop    rbx
  2135b5:	41 5e                	pop    r14
  2135b7:	c3                   	ret    
            @panic("assertion failure");
  2135b8:	e8 63 57 ff ff       	call   208d20 <panic>
  2135bd:	0f 1f 00             	nop    DWORD PTR [rax]

00000000002135c0 <getLineNumberInfo>:
fn getLineNumberInfo(st: *ElfStackTrace, compile_unit: *const CompileUnit, target_address: usize) !LineInfo {
  2135c0:	55                   	push   rbp
  2135c1:	41 57                	push   r15
  2135c3:	41 56                	push   r14
  2135c5:	41 55                	push   r13
  2135c7:	41 54                	push   r12
  2135c9:	53                   	push   rbx
  2135ca:	48 81 ec 18 0b 00 00 	sub    rsp,0xb18
  2135d1:	49 89 cc             	mov    r12,rcx
  2135d4:	49 89 d6             	mov    r14,rdx
  2135d7:	49 89 f7             	mov    r15,rsi
  2135da:	48 89 fd             	mov    rbp,rdi
    const compile_unit_cwd = try compile_unit.die.getAttrString(st, DW.AT_comp_dir);
  2135dd:	49 8b 46 08          	mov    rax,QWORD PTR [r14+0x8]
            return self.items[0..self.len];
  2135e1:	48 8b 48 20          	mov    rcx,QWORD PTR [rax+0x20]
        for (self.attrs.toSliceConst()) |*attr| {
  2135e5:	48 85 c9             	test   rcx,rcx
  2135e8:	74 19                	je     213603 <getLineNumberInfo+0x43>
  2135ea:	48 8b 40 10          	mov    rax,QWORD PTR [rax+0x10]
  2135ee:	31 d2                	xor    edx,edx
            if (attr.id == id) return &attr.value;
  2135f0:	48 83 38 1b          	cmp    QWORD PTR [rax],0x1b
  2135f4:	74 36                	je     21362c <getLineNumberInfo+0x6c>
        for (self.attrs.toSliceConst()) |*attr| {
  2135f6:	48 83 c2 01          	add    rdx,0x1
  2135fa:	48 83 c0 28          	add    rax,0x28
  2135fe:	48 39 ca             	cmp    rdx,rcx
  213601:	72 ed                	jb     2135f0 <getLineNumberInfo+0x30>
        const form_value = self.getAttr(id) orelse return error.MissingDebugInfo;
  213603:	48 8b 05 8e 21 ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffff218e]        # 205798 <__unnamed_35+0x10>
  21360a:	48 89 84 24 7e 01 00 	mov    QWORD PTR [rsp+0x17e],rax
  213611:	00 
  213612:	c5 f8 10 05 70 21 ff 	vmovups xmm0,XMMWORD PTR [rip+0xffffffffffff2170]        # 20578a <__unnamed_35+0x2>
  213619:	ff 
  21361a:	c5 f8 29 84 24 70 01 	vmovaps XMMWORD PTR [rsp+0x170],xmm0
  213621:	00 00 
  213623:	66 b8 22 00          	mov    ax,0x22
  213627:	e9 c5 00 00 00       	jmp    2136f1 <getLineNumberInfo+0x131>
  21362c:	8a 48 20             	mov    cl,BYTE PTR [rax+0x20]
  21362f:	80 f9 0a             	cmp    cl,0xa
        return switch (form_value.*) {
  213632:	74 1e                	je     213652 <getLineNumberInfo+0x92>
  213634:	80 f9 09             	cmp    cl,0x9
  213637:	75 69                	jne    2136a2 <getLineNumberInfo+0xe2>
            FormValue.String => |value| value,
  213639:	66 c7 44 24 08 00 00 	mov    WORD PTR [rsp+0x8],0x0
  213640:	c5 f8 10 40 08       	vmovups xmm0,XMMWORD PTR [rax+0x8]
  213645:	c5 f8 11 44 24 10    	vmovups XMMWORD PTR [rsp+0x10],xmm0
  21364b:	48 8d 5c 24 08       	lea    rbx,[rsp+0x8]
  213650:	eb 7d                	jmp    2136cf <getLineNumberInfo+0x10f>
            FormValue.StrPtr => |offset| getString(st, offset),
  213652:	48 8b 70 08          	mov    rsi,QWORD PTR [rax+0x8]
    const pos = st.debug_str.offset + offset;
  213656:	49 8b 47 70          	mov    rax,QWORD PTR [r15+0x70]
    if (@maxValue(@typeOf(x)) > @maxValue(T) and x > @maxValue(T)) {
  21365a:	48 03 70 18          	add    rsi,QWORD PTR [rax+0x18]
  21365e:	78 4b                	js     2136ab <getLineNumberInfo+0xeb>
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  213660:	49 63 3f             	movsxd rdi,DWORD PTR [r15]
  213663:	31 db                	xor    ebx,ebx
  213665:	b8 08 00 00 00       	mov    eax,0x8
  21366a:	31 d2                	xor    edx,edx
  21366c:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  21366e:	48 89 c1             	mov    rcx,rax
  213671:	48 f7 d9             	neg    rcx
  213674:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  21367a:	48 0f 46 cb          	cmovbe rcx,rbx
  21367e:	66 b8 02 00          	mov    ax,0x2
                if (err > 0) {
  213682:	48 83 f9 1d          	cmp    rcx,0x1d
  213686:	0f 87 44 02 00 00    	ja     2138d0 <getLineNumberInfo+0x310>
  21368c:	48 8d 15 91 d2 fe ff 	lea    rdx,[rip+0xfffffffffffed291]        # 200924 <app_mask+0x6a4>
  213693:	48 63 0c 8a          	movsxd rcx,DWORD PTR [rdx+rcx*4]
  213697:	48 01 d1             	add    rcx,rdx
  21369a:	ff e1                	jmp    rcx
  21369c:	66 b8 20 00          	mov    ax,0x20
  2136a0:	eb 0d                	jmp    2136af <getLineNumberInfo+0xef>
  2136a2:	48 8d 1d f7 20 ff ff 	lea    rbx,[rip+0xffffffffffff20f7]        # 2057a0 <__unnamed_19>
  2136a9:	eb 24                	jmp    2136cf <getLineNumberInfo+0x10f>
  2136ab:	66 b8 21 00          	mov    ax,0x21
    try st.self_exe_file.seekTo(pos);
  2136af:	66 89 44 24 20       	mov    WORD PTR [rsp+0x20],ax
  2136b4:	c5 f8 10 44 24 48    	vmovups xmm0,XMMWORD PTR [rsp+0x48]
  2136ba:	c5 f8 11 44 24 22    	vmovups XMMWORD PTR [rsp+0x22],xmm0
  2136c0:	48 8b 44 24 56       	mov    rax,QWORD PTR [rsp+0x56]
  2136c5:	48 89 44 24 30       	mov    QWORD PTR [rsp+0x30],rax
  2136ca:	48 8d 5c 24 20       	lea    rbx,[rsp+0x20]
        return switch (form_value.*) {
  2136cf:	0f b7 03             	movzx  eax,WORD PTR [rbx]
  2136d2:	48 8b 4b 10          	mov    rcx,QWORD PTR [rbx+0x10]
  2136d6:	48 89 8c 24 7e 01 00 	mov    QWORD PTR [rsp+0x17e],rcx
  2136dd:	00 
  2136de:	c5 f8 10 43 02       	vmovups xmm0,XMMWORD PTR [rbx+0x2]
  2136e3:	c5 f8 29 84 24 70 01 	vmovaps XMMWORD PTR [rsp+0x170],xmm0
  2136ea:	00 00 
    const compile_unit_cwd = try compile_unit.die.getAttrString(st, DW.AT_comp_dir);
  2136ec:	66 85 c0             	test   ax,ax
  2136ef:	74 35                	je     213726 <getLineNumberInfo+0x166>
  2136f1:	66 89 45 00          	mov    WORD PTR [rbp+0x0],ax
  2136f5:	c5 fe 6f 84 24 ca 0a 	vmovdqu ymm0,YMMWORD PTR [rsp+0xaca]
  2136fc:	00 00 
  2136fe:	c5 fc 10 8c 24 d8 0a 	vmovups ymm1,YMMWORD PTR [rsp+0xad8]
  213705:	00 00 
  213707:	c5 fc 11 4d 10       	vmovups YMMWORD PTR [rbp+0x10],ymm1
  21370c:	c5 fe 7f 45 02       	vmovdqu YMMWORD PTR [rbp+0x2],ymm0
  213711:	48 81 c4 18 0b 00 00 	add    rsp,0xb18
  213718:	5b                   	pop    rbx
  213719:	41 5c                	pop    r12
  21371b:	41 5d                	pop    r13
  21371d:	41 5e                	pop    r14
  21371f:	41 5f                	pop    r15
  213721:	5d                   	pop    rbp
  213722:	c5 f8 77             	vzeroupper 
  213725:	c3                   	ret    
  213726:	4c 89 a4 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],r12
  21372d:	00 
  21372e:	48 89 2c 24          	mov    QWORD PTR [rsp],rbp
  213732:	c5 fa 6f 84 24 76 01 	vmovdqu xmm0,XMMWORD PTR [rsp+0x176]
  213739:	00 00 
  21373b:	c5 f9 7f 84 24 e0 01 	vmovdqa XMMWORD PTR [rsp+0x1e0],xmm0
  213742:	00 00 
    const debug_line_end = st.debug_line.offset + st.debug_line.size;
  213744:	49 8b 47 78          	mov    rax,QWORD PTR [r15+0x78]
  213748:	48 8b 58 18          	mov    rbx,QWORD PTR [rax+0x18]
  21374c:	4c 8b 60 20          	mov    r12,QWORD PTR [rax+0x20]
    var in_file_stream = io.FileInStream.init(in_file);
  213750:	4c 89 7c 24 38       	mov    QWORD PTR [rsp+0x38],r15
  213755:	48 8d 05 94 c3 ff ff 	lea    rax,[rip+0xffffffffffffc394]        # 20faf0 <FileInStream_readFn>
  21375c:	48 89 44 24 40       	mov    QWORD PTR [rsp+0x40],rax
    while (this_offset < debug_line_end) : (this_index += 1) {
  213761:	4d 85 e4             	test   r12,r12
  213764:	0f 84 44 01 00 00    	je     2138ae <getLineNumberInfo+0x2ee>
  21376a:	49 01 dc             	add    r12,rbx
  21376d:	49 c7 c5 ff ff ff ff 	mov    r13,0xffffffffffffffff
  213774:	4c 89 7c 24 60       	mov    QWORD PTR [rsp+0x60],r15
  213779:	48 85 db             	test   rbx,rbx
  21377c:	0f 88 9e 01 00 00    	js     213920 <getLineNumberInfo+0x360>
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  213782:	49 63 3f             	movsxd rdi,DWORD PTR [r15]
  213785:	b8 08 00 00 00       	mov    eax,0x8
  21378a:	31 d2                	xor    edx,edx
  21378c:	48 89 de             	mov    rsi,rbx
  21378f:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  213791:	48 89 c1             	mov    rcx,rax
  213794:	48 f7 d9             	neg    rcx
  213797:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  21379d:	b8 00 00 00 00       	mov    eax,0x0
  2137a2:	48 0f 46 c8          	cmovbe rcx,rax
  2137a6:	48 85 c9             	test   rcx,rcx
  2137a9:	0f 85 77 01 00 00    	jne    213926 <getLineNumberInfo+0x366>
            try self.readNoEof(bytes[0..]);
  2137af:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  2137b4:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  2137b9:	48 c7 44 24 10 04 00 	mov    QWORD PTR [rsp+0x10],0x4
  2137c0:	00 00 
            return self.readFn(self, buffer);
  2137c2:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  2137c7:	48 8d 6c 24 40       	lea    rbp,[rsp+0x40]
  2137cc:	48 89 ee             	mov    rsi,rbp
  2137cf:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
  2137d4:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  2137d8:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  2137dd:	66 85 c0             	test   ax,ax
  2137e0:	0f 85 ed 01 00 00    	jne    2139d3 <getLineNumberInfo+0x413>
  2137e6:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
            if (amt_read < buf.len) return error.EndOfStream;
  2137eb:	48 3b 44 24 10       	cmp    rax,QWORD PTR [rsp+0x10]
  2137f0:	0f 82 e9 00 00 00    	jb     2138df <getLineNumberInfo+0x31f>
  2137f6:	0f b6 44 24 48       	movzx  eax,BYTE PTR [rsp+0x48]
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  2137fb:	0f b6 4c 24 49       	movzx  ecx,BYTE PTR [rsp+0x49]
  213800:	48 c1 e1 08          	shl    rcx,0x8
  213804:	48 09 c1             	or     rcx,rax
  213807:	0f b6 54 24 4a       	movzx  edx,BYTE PTR [rsp+0x4a]
  21380c:	48 c1 e2 10          	shl    rdx,0x10
  213810:	48 09 ca             	or     rdx,rcx
  213813:	0f b6 44 24 4b       	movzx  eax,BYTE PTR [rsp+0x4b]
  213818:	48 c1 e0 18          	shl    rax,0x18
  21381c:	48 09 d0             	or     rax,rdx
    is_64.* = (first_32_bits == 0xffffffff);
  21381f:	83 f8 ff             	cmp    eax,0xffffffff
    if (is_64.*) {
  213822:	74 3f                	je     213863 <getLineNumberInfo+0x2a3>
        if (first_32_bits >= 0xfffffff0) return error.InvalidDebugInfo;
  213824:	83 f8 ef             	cmp    eax,0xffffffef
  213827:	0f 87 a2 01 00 00    	ja     2139cf <getLineNumberInfo+0x40f>
  21382d:	45 31 ff             	xor    r15d,r15d
        if (unit_length == 0) return error.MissingDebugInfo;
  213830:	48 85 c0             	test   rax,rax
  213833:	74 79                	je     2138ae <getLineNumberInfo+0x2ee>
        if (compile_unit.index != this_index) {
  213835:	49 83 c5 01          	add    r13,0x1
  213839:	4d 3b 6e 10          	cmp    r13,QWORD PTR [r14+0x10]
  21383d:	0f 84 29 01 00 00    	je     21396c <getLineNumberInfo+0x3ac>
        const next_offset = unit_length + (if (is_64) usize(12) else usize(4));
  213843:	41 0f b6 cf          	movzx  ecx,r15b
  213847:	48 8d 0c cb          	lea    rcx,[rbx+rcx*8]
            this_offset += next_offset;
  21384b:	48 8d 1c 08          	lea    rbx,[rax+rcx*1]
  21384f:	48 83 c3 04          	add    rbx,0x4
    while (this_offset < debug_line_end) : (this_index += 1) {
  213853:	4c 39 e3             	cmp    rbx,r12
  213856:	4c 8b 7c 24 60       	mov    r15,QWORD PTR [rsp+0x60]
  21385b:	0f 82 18 ff ff ff    	jb     213779 <getLineNumberInfo+0x1b9>
  213861:	eb 4b                	jmp    2138ae <getLineNumberInfo+0x2ee>
            try self.readNoEof(bytes[0..]);
  213863:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  213868:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  21386d:	48 c7 44 24 10 08 00 	mov    QWORD PTR [rsp+0x10],0x8
  213874:	00 00 
            return self.readFn(self, buffer);
  213876:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  21387b:	48 89 ee             	mov    rsi,rbp
  21387e:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
  213883:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  213887:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  21388c:	66 85 c0             	test   ax,ax
  21388f:	0f 85 3e 01 00 00    	jne    2139d3 <getLineNumberInfo+0x413>
  213895:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
            if (amt_read < buf.len) return error.EndOfStream;
  21389a:	48 3b 44 24 10       	cmp    rax,QWORD PTR [rsp+0x10]
  21389f:	72 3e                	jb     2138df <getLineNumberInfo+0x31f>
  2138a1:	48 8b 44 24 48       	mov    rax,QWORD PTR [rsp+0x48]
  2138a6:	41 b7 01             	mov    r15b,0x1
        if (unit_length == 0) return error.MissingDebugInfo;
  2138a9:	48 85 c0             	test   rax,rax
  2138ac:	75 87                	jne    213835 <getLineNumberInfo+0x275>
  2138ae:	c5 fc 10 05 5a 1f ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffff1f5a]        # 205810 <__unnamed_74+0x10>
  2138b5:	ff 
  2138b6:	48 8b 04 24          	mov    rax,QWORD PTR [rsp]
  2138ba:	c5 fc 11 40 10       	vmovups YMMWORD PTR [rax+0x10],ymm0
  2138bf:	c5 fe 6f 05 39 1f ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffff1f39]        # 205800 <__unnamed_74>
  2138c6:	ff 
  2138c7:	c5 fe 7f 00          	vmovdqu YMMWORD PTR [rax],ymm0
  2138cb:	e9 41 fe ff ff       	jmp    213711 <getLineNumberInfo+0x151>
  2138d0:	48 83 f9 4b          	cmp    rcx,0x4b
  2138d4:	0f 85 d5 fd ff ff    	jne    2136af <getLineNumberInfo+0xef>
  2138da:	e9 bd fd ff ff       	jmp    21369c <getLineNumberInfo+0xdc>
  2138df:	66 b8 1e 00          	mov    ax,0x1e
  2138e3:	e9 eb 00 00 00       	jmp    2139d3 <getLineNumberInfo+0x413>
            var in_file_stream = io.FileInStream.init(&self.self_exe_file);
  2138e8:	4c 89 bc 24 a0 01 00 	mov    QWORD PTR [rsp+0x1a0],r15
  2138ef:	00 
  2138f0:	48 8d 94 24 a8 01 00 	lea    rdx,[rsp+0x1a8]
  2138f7:	00 
  2138f8:	48 8d 05 f1 c1 ff ff 	lea    rax,[rip+0xffffffffffffc1f1]        # 20faf0 <FileInStream_readFn>
  2138ff:	48 89 84 24 a8 01 00 	mov    QWORD PTR [rsp+0x1a8],rax
  213906:	00 
  213907:	49 8b b7 a0 00 00 00 	mov    rsi,QWORD PTR [r15+0xa0]
  21390e:	48 8d 5c 24 20       	lea    rbx,[rsp+0x20]
            return readStringRaw(self.allocator(), in_stream);
  213913:	48 89 df             	mov    rdi,rbx
  213916:	e8 55 f8 ff ff       	call   213170 <readStringRaw>
  21391b:	e9 af fd ff ff       	jmp    2136cf <getLineNumberInfo+0x10f>
  213920:	66 b8 21 00          	mov    ax,0x21
  213924:	eb 28                	jmp    21394e <getLineNumberInfo+0x38e>
  213926:	48 8d 41 ea          	lea    rax,[rcx-0x16]
  21392a:	48 83 f8 35          	cmp    rax,0x35
  21392e:	77 10                	ja     213940 <getLineNumberInfo+0x380>
  213930:	48 ba 81 00 00 00 00 	movabs rdx,0x20000000000081
  213937:	00 20 00 
  21393a:	48 0f a3 c2          	bt     rdx,rax
  21393e:	72 0a                	jb     21394a <getLineNumberInfo+0x38a>
  213940:	66 b8 02 00          	mov    ax,0x2
  213944:	48 83 f9 06          	cmp    rcx,0x6
  213948:	75 04                	jne    21394e <getLineNumberInfo+0x38e>
  21394a:	66 b8 20 00          	mov    ax,0x20
  21394e:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
        try in_file.seekTo(this_offset);
  213952:	66 89 01             	mov    WORD PTR [rcx],ax
  213955:	c5 fe 6f 84 24 9c 0a 	vmovdqu ymm0,YMMWORD PTR [rsp+0xa9c]
  21395c:	00 00 
  21395e:	c5 fc 10 8c 24 aa 0a 	vmovups ymm1,YMMWORD PTR [rsp+0xaaa]
  213965:	00 00 
  213967:	e9 80 00 00 00       	jmp    2139ec <getLineNumberInfo+0x42c>
        const version = try in_stream.readInt(st.elf.endian, u16);
  21396c:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
  213971:	8a 58 12             	mov    bl,BYTE PTR [rax+0x12]
            try self.readNoEof(bytes[0..]);
  213974:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  213979:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  21397e:	48 c7 44 24 10 02 00 	mov    QWORD PTR [rsp+0x10],0x2
  213985:	00 00 
  213987:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  21398c:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
            return self.readFn(self, buffer);
  213991:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  213996:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  21399a:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  21399f:	66 85 c0             	test   ax,ax
  2139a2:	75 10                	jne    2139b4 <getLineNumberInfo+0x3f4>
  2139a4:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  2139a9:	66 b8 1e 00          	mov    ax,0x1e
            if (amt_read < buf.len) return error.EndOfStream;
  2139ad:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  2139b2:	73 47                	jae    2139fb <getLineNumberInfo+0x43b>
  2139b4:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
  2139b8:	66 89 01             	mov    WORD PTR [rcx],ax
  2139bb:	c5 fe 6f 84 24 40 0a 	vmovdqu ymm0,YMMWORD PTR [rsp+0xa40]
  2139c2:	00 00 
  2139c4:	c5 fc 10 8c 24 4e 0a 	vmovups ymm1,YMMWORD PTR [rsp+0xa4e]
  2139cb:	00 00 
  2139cd:	eb 1d                	jmp    2139ec <getLineNumberInfo+0x42c>
  2139cf:	66 b8 23 00          	mov    ax,0x23
  2139d3:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
        const unit_length = try readInitialLength(@typeOf(in_stream.readFn).ReturnType.ErrorSet, in_stream, &is_64);
  2139d7:	66 89 01             	mov    WORD PTR [rcx],ax
  2139da:	c5 fe 6f 84 24 6e 0a 	vmovdqu ymm0,YMMWORD PTR [rsp+0xa6e]
  2139e1:	00 00 
  2139e3:	c5 fc 10 8c 24 7c 0a 	vmovups ymm1,YMMWORD PTR [rsp+0xa7c]
  2139ea:	00 00 
  2139ec:	c5 fc 11 49 10       	vmovups YMMWORD PTR [rcx+0x10],ymm1
  2139f1:	c5 fe 7f 41 02       	vmovdqu YMMWORD PTR [rcx+0x2],ymm0
  2139f6:	e9 16 fd ff ff       	jmp    213711 <getLineNumberInfo+0x151>
  2139fb:	0f b6 44 24 48       	movzx  eax,BYTE PTR [rsp+0x48]
  213a00:	0f b6 4c 24 49       	movzx  ecx,BYTE PTR [rsp+0x49]
  213a05:	89 ca                	mov    edx,ecx
  213a07:	c1 e2 08             	shl    edx,0x8
  213a0a:	09 c2                	or     edx,eax
                result = (result << 8) | b;
  213a0c:	c1 e0 08             	shl    eax,0x8
  213a0f:	09 c8                	or     eax,ecx
    switch (endian) {
  213a11:	f6 c3 01             	test   bl,0x1
  213a14:	66 0f 45 c2          	cmovne ax,dx
        if (version != 2 and version != 4) return error.InvalidDebugInfo;
  213a18:	44 0f b7 e0          	movzx  r12d,ax
  213a1c:	41 83 fc 02          	cmp    r12d,0x2
  213a20:	48 8b 2c 24          	mov    rbp,QWORD PTR [rsp]
  213a24:	74 0a                	je     213a30 <getLineNumberInfo+0x470>
  213a26:	41 83 fc 04          	cmp    r12d,0x4
  213a2a:	0f 85 ac 00 00 00    	jne    213adc <getLineNumberInfo+0x51c>
  213a30:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
  213a35:	8a 58 12             	mov    bl,BYTE PTR [rax+0x12]
        const prologue_length = if (is_64) try in_stream.readInt(st.elf.endian, u64) else try in_stream.readInt(st.elf.endian, u32);
  213a38:	45 84 ff             	test   r15b,r15b
  213a3b:	74 44                	je     213a81 <getLineNumberInfo+0x4c1>
  213a3d:	0f b6 d3             	movzx  edx,bl
  213a40:	48 8d bc 24 90 01 00 	lea    rdi,[rsp+0x190]
  213a47:	00 
  213a48:	48 8d 5c 24 40       	lea    rbx,[rsp+0x40]
  213a4d:	48 89 de             	mov    rsi,rbx
  213a50:	e8 3b be ff ff       	call   20f890 <InStream(ReadError)_readInt.30>
  213a55:	0f b7 84 24 90 01 00 	movzx  eax,WORD PTR [rsp+0x190]
  213a5c:	00 
  213a5d:	66 85 c0             	test   ax,ax
  213a60:	0f 84 95 00 00 00    	je     213afb <getLineNumberInfo+0x53b>
  213a66:	66 89 45 00          	mov    WORD PTR [rbp+0x0],ax
  213a6a:	c5 fe 6f 84 24 12 0a 	vmovdqu ymm0,YMMWORD PTR [rsp+0xa12]
  213a71:	00 00 
  213a73:	c5 fc 10 8c 24 20 0a 	vmovups ymm1,YMMWORD PTR [rsp+0xa20]
  213a7a:	00 00 
  213a7c:	e9 86 fc ff ff       	jmp    213707 <getLineNumberInfo+0x147>
            try self.readNoEof(bytes[0..]);
  213a81:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  213a86:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  213a8b:	48 c7 44 24 10 04 00 	mov    QWORD PTR [rsp+0x10],0x4
  213a92:	00 00 
  213a94:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  213a99:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
            return self.readFn(self, buffer);
  213a9e:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  213aa3:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  213aa7:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  213aac:	66 85 c0             	test   ax,ax
  213aaf:	75 10                	jne    213ac1 <getLineNumberInfo+0x501>
  213ab1:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  213ab6:	66 b8 1e 00          	mov    ax,0x1e
            if (amt_read < buf.len) return error.EndOfStream;
  213aba:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  213abf:	73 44                	jae    213b05 <getLineNumberInfo+0x545>
  213ac1:	66 89 45 00          	mov    WORD PTR [rbp+0x0],ax
  213ac5:	c5 fe 6f 84 24 e4 09 	vmovdqu ymm0,YMMWORD PTR [rsp+0x9e4]
  213acc:	00 00 
  213ace:	c5 fc 10 8c 24 f2 09 	vmovups ymm1,YMMWORD PTR [rsp+0x9f2]
  213ad5:	00 00 
  213ad7:	e9 2b fc ff ff       	jmp    213707 <getLineNumberInfo+0x147>
        if (version != 2 and version != 4) return error.InvalidDebugInfo;
  213adc:	c5 fc 10 05 fc 1c ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffff1cfc]        # 2057e0 <__unnamed_75+0x10>
  213ae3:	ff 
  213ae4:	c5 fc 11 45 10       	vmovups YMMWORD PTR [rbp+0x10],ymm0
  213ae9:	c5 fe 6f 05 df 1c ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffff1cdf]        # 2057d0 <__unnamed_75>
  213af0:	ff 
  213af1:	c5 fe 7f 45 00       	vmovdqu YMMWORD PTR [rbp+0x0],ymm0
  213af6:	e9 16 fc ff ff       	jmp    213711 <getLineNumberInfo+0x151>
        const prologue_length = if (is_64) try in_stream.readInt(st.elf.endian, u64) else try in_stream.readInt(st.elf.endian, u32);
  213afb:	4c 8b b4 24 98 01 00 	mov    r14,QWORD PTR [rsp+0x198]
  213b02:	00 
  213b03:	eb 4f                	jmp    213b54 <getLineNumberInfo+0x594>
  213b05:	0f b6 44 24 48       	movzx  eax,BYTE PTR [rsp+0x48]
  213b0a:	0f b6 4c 24 49       	movzx  ecx,BYTE PTR [rsp+0x49]
  213b0f:	f6 c3 01             	test   bl,0x1
  213b12:	74 1b                	je     213b2f <getLineNumberInfo+0x56f>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  213b14:	c1 e1 08             	shl    ecx,0x8
  213b17:	09 c1                	or     ecx,eax
  213b19:	0f b6 54 24 4a       	movzx  edx,BYTE PTR [rsp+0x4a]
  213b1e:	c1 e2 10             	shl    edx,0x10
  213b21:	09 ca                	or     edx,ecx
  213b23:	0f b6 44 24 4b       	movzx  eax,BYTE PTR [rsp+0x4b]
  213b28:	c1 e0 18             	shl    eax,0x18
  213b2b:	09 d0                	or     eax,edx
  213b2d:	eb 19                	jmp    213b48 <getLineNumberInfo+0x588>
                result = (result << 8) | b;
  213b2f:	c1 e0 08             	shl    eax,0x8
  213b32:	09 c8                	or     eax,ecx
  213b34:	c1 e0 08             	shl    eax,0x8
  213b37:	0f b6 4c 24 4a       	movzx  ecx,BYTE PTR [rsp+0x4a]
  213b3c:	09 c1                	or     ecx,eax
  213b3e:	c1 e1 08             	shl    ecx,0x8
  213b41:	0f b6 44 24 4b       	movzx  eax,BYTE PTR [rsp+0x4b]
  213b46:	09 c8                	or     eax,ecx
  213b48:	41 89 c6             	mov    r14d,eax
  213b4b:	48 8b 2c 24          	mov    rbp,QWORD PTR [rsp]
  213b4f:	48 8d 5c 24 40       	lea    rbx,[rsp+0x40]
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  213b54:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
  213b59:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  213b5c:	45 31 c0             	xor    r8d,r8d
  213b5f:	b8 08 00 00 00       	mov    eax,0x8
  213b64:	be 00 00 00 00       	mov    esi,0x0
  213b69:	ba 01 00 00 00       	mov    edx,0x1
  213b6e:	0f 05                	syscall 
  213b70:	49 89 c5             	mov    r13,rax
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  213b73:	4c 89 e9             	mov    rcx,r13
  213b76:	48 f7 d9             	neg    rcx
  213b79:	49 81 fd 00 f0 ff ff 	cmp    r13,0xfffffffffffff000
  213b80:	49 0f 46 c8          	cmovbe rcx,r8
  213b84:	66 b8 20 00          	mov    ax,0x20
                if (err > 0) {
  213b88:	48 83 f9 1d          	cmp    rcx,0x1d
  213b8c:	77 6c                	ja     213bfa <getLineNumberInfo+0x63a>
  213b8e:	48 8d 15 07 ce fe ff 	lea    rdx,[rip+0xfffffffffffece07]        # 20099c <app_mask+0x71c>
  213b95:	48 63 0c 8a          	movsxd rcx,DWORD PTR [rdx+rcx*4]
  213b99:	48 01 d1             	add    rcx,rdx
  213b9c:	ff e1                	jmp    rcx
            try self.readNoEof(result[0..]);
  213b9e:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  213ba3:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  213ba8:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  213baf:	00 00 
  213bb1:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  213bb6:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
            return self.readFn(self, buffer);
  213bbb:	48 89 de             	mov    rsi,rbx
  213bbe:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  213bc2:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  213bc7:	66 85 c0             	test   ax,ax
  213bca:	75 10                	jne    213bdc <getLineNumberInfo+0x61c>
  213bcc:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  213bd1:	66 b8 1e 00          	mov    ax,0x1e
            if (amt_read < buf.len) return error.EndOfStream;
  213bd5:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  213bda:	73 43                	jae    213c1f <getLineNumberInfo+0x65f>
  213bdc:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
        const minimum_instruction_length = try in_stream.readByte();
  213be0:	66 89 01             	mov    WORD PTR [rcx],ax
  213be3:	c5 fe 6f 84 24 88 09 	vmovdqu ymm0,YMMWORD PTR [rsp+0x988]
  213bea:	00 00 
  213bec:	c5 fc 10 8c 24 96 09 	vmovups ymm1,YMMWORD PTR [rsp+0x996]
  213bf3:	00 00 
  213bf5:	e9 f2 fd ff ff       	jmp    2139ec <getLineNumberInfo+0x42c>
  213bfa:	48 83 f9 4b          	cmp    rcx,0x4b
  213bfe:	74 04                	je     213c04 <getLineNumberInfo+0x644>
  213c00:	66 b8 02 00          	mov    ax,0x2
        const prog_start_offset = (try in_file.getPos()) + prologue_length;
  213c04:	66 89 45 00          	mov    WORD PTR [rbp+0x0],ax
  213c08:	c5 fe 6f 84 24 b6 09 	vmovdqu ymm0,YMMWORD PTR [rsp+0x9b6]
  213c0f:	00 00 
  213c11:	c5 fc 10 8c 24 c4 09 	vmovups ymm1,YMMWORD PTR [rsp+0x9c4]
  213c18:	00 00 
  213c1a:	e9 e8 fa ff ff       	jmp    213707 <getLineNumberInfo+0x147>
            return result[0];
  213c1f:	44 0f b6 7c 24 48    	movzx  r15d,BYTE PTR [rsp+0x48]
  213c25:	4d 85 ff             	test   r15,r15
        if (minimum_instruction_length == 0) return error.InvalidDebugInfo;
  213c28:	0f 84 59 15 00 00    	je     215187 <getLineNumberInfo+0x1bc7>
        if (version >= 4) {
  213c2e:	41 83 fc 04          	cmp    r12d,0x4
  213c32:	72 5e                	jb     213c92 <getLineNumberInfo+0x6d2>
            try self.readNoEof(result[0..]);
  213c34:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  213c39:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  213c3e:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  213c45:	00 00 
  213c47:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  213c4c:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
            return self.readFn(self, buffer);
  213c51:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  213c56:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  213c5a:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  213c5f:	66 85 c0             	test   ax,ax
  213c62:	75 10                	jne    213c74 <getLineNumberInfo+0x6b4>
  213c64:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  213c69:	66 b8 1e 00          	mov    ax,0x1e
            if (amt_read < buf.len) return error.EndOfStream;
  213c6d:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  213c72:	73 1e                	jae    213c92 <getLineNumberInfo+0x6d2>
  213c74:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
            _ = try in_stream.readByte();
  213c78:	66 89 01             	mov    WORD PTR [rcx],ax
  213c7b:	c5 fe 6f 84 24 5a 09 	vmovdqu ymm0,YMMWORD PTR [rsp+0x95a]
  213c82:	00 00 
  213c84:	c5 fc 10 8c 24 68 09 	vmovups ymm1,YMMWORD PTR [rsp+0x968]
  213c8b:	00 00 
  213c8d:	e9 5a fd ff ff       	jmp    2139ec <getLineNumberInfo+0x42c>
            try self.readNoEof(result[0..]);
  213c92:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  213c97:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  213c9c:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  213ca3:	00 00 
  213ca5:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  213caa:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
            return self.readFn(self, buffer);
  213caf:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  213cb4:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  213cb8:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  213cbd:	66 85 c0             	test   ax,ax
  213cc0:	75 10                	jne    213cd2 <getLineNumberInfo+0x712>
  213cc2:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  213cc7:	66 b8 1e 00          	mov    ax,0x1e
            if (amt_read < buf.len) return error.EndOfStream;
  213ccb:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  213cd0:	73 1e                	jae    213cf0 <getLineNumberInfo+0x730>
  213cd2:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
        const default_is_stmt = (try in_stream.readByte()) != 0;
  213cd6:	66 89 01             	mov    WORD PTR [rcx],ax
  213cd9:	c5 fe 6f 84 24 2c 09 	vmovdqu ymm0,YMMWORD PTR [rsp+0x92c]
  213ce0:	00 00 
  213ce2:	c5 fc 10 8c 24 3a 09 	vmovups ymm1,YMMWORD PTR [rsp+0x93a]
  213ce9:	00 00 
  213ceb:	e9 fc fc ff ff       	jmp    2139ec <getLineNumberInfo+0x42c>
            return result[0];
  213cf0:	40 8a 6c 24 48       	mov    bpl,BYTE PTR [rsp+0x48]
            try self.readNoEof(result[0..]);
  213cf5:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  213cfa:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  213cff:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  213d06:	00 00 
  213d08:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  213d0d:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
            return self.readFn(self, buffer);
  213d12:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  213d17:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  213d1b:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  213d20:	66 85 c0             	test   ax,ax
  213d23:	75 10                	jne    213d35 <getLineNumberInfo+0x775>
  213d25:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  213d2a:	66 b8 1e 00          	mov    ax,0x1e
            if (amt_read < buf.len) return error.EndOfStream;
  213d2e:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  213d33:	73 1e                	jae    213d53 <getLineNumberInfo+0x793>
  213d35:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
        const line_base = try in_stream.readByteSigned();
  213d39:	66 89 01             	mov    WORD PTR [rcx],ax
  213d3c:	c5 fe 6f 84 24 fe 08 	vmovdqu ymm0,YMMWORD PTR [rsp+0x8fe]
  213d43:	00 00 
  213d45:	c5 fc 10 8c 24 0c 09 	vmovups ymm1,YMMWORD PTR [rsp+0x90c]
  213d4c:	00 00 
  213d4e:	e9 99 fc ff ff       	jmp    2139ec <getLineNumberInfo+0x42c>
            return result[0];
  213d53:	48 0f be 44 24 48    	movsx  rax,BYTE PTR [rsp+0x48]
            try self.readNoEof(result[0..]);
  213d59:	48 89 84 24 68 01 00 	mov    QWORD PTR [rsp+0x168],rax
  213d60:	00 
  213d61:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  213d66:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  213d6b:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  213d72:	00 00 
  213d74:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  213d79:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
            return self.readFn(self, buffer);
  213d7e:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  213d83:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  213d87:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  213d8c:	66 85 c0             	test   ax,ax
  213d8f:	75 10                	jne    213da1 <getLineNumberInfo+0x7e1>
  213d91:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  213d96:	66 b8 1e 00          	mov    ax,0x1e
            if (amt_read < buf.len) return error.EndOfStream;
  213d9a:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  213d9f:	73 1e                	jae    213dbf <getLineNumberInfo+0x7ff>
  213da1:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
        const line_range = try in_stream.readByte();
  213da5:	66 89 01             	mov    WORD PTR [rcx],ax
  213da8:	c5 fe 6f 84 24 d0 08 	vmovdqu ymm0,YMMWORD PTR [rsp+0x8d0]
  213daf:	00 00 
  213db1:	c5 fc 10 8c 24 de 08 	vmovups ymm1,YMMWORD PTR [rsp+0x8de]
  213db8:	00 00 
  213dba:	e9 2d fc ff ff       	jmp    2139ec <getLineNumberInfo+0x42c>
            return result[0];
  213dbf:	8a 44 24 48          	mov    al,BYTE PTR [rsp+0x48]
  213dc3:	88 44 24 5f          	mov    BYTE PTR [rsp+0x5f],al
        if (line_range == 0) return error.InvalidDebugInfo;
  213dc7:	84 c0                	test   al,al
  213dc9:	0f 84 b8 13 00 00    	je     215187 <getLineNumberInfo+0x1bc7>
            try self.readNoEof(result[0..]);
  213dcf:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  213dd4:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  213dd9:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  213de0:	00 00 
  213de2:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  213de7:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
            return self.readFn(self, buffer);
  213dec:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  213df1:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  213df5:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  213dfa:	66 85 c0             	test   ax,ax
  213dfd:	75 10                	jne    213e0f <getLineNumberInfo+0x84f>
  213dff:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  213e04:	66 b8 1e 00          	mov    ax,0x1e
            if (amt_read < buf.len) return error.EndOfStream;
  213e08:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  213e0d:	73 1e                	jae    213e2d <getLineNumberInfo+0x86d>
  213e0f:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
        const opcode_base = try in_stream.readByte();
  213e13:	66 89 01             	mov    WORD PTR [rcx],ax
  213e16:	c5 fe 6f 84 24 a2 08 	vmovdqu ymm0,YMMWORD PTR [rsp+0x8a2]
  213e1d:	00 00 
  213e1f:	c5 fc 10 8c 24 b0 08 	vmovups ymm1,YMMWORD PTR [rsp+0x8b0]
  213e26:	00 00 
  213e28:	e9 bf fb ff ff       	jmp    2139ec <getLineNumberInfo+0x42c>
            return result[0];
  213e2d:	8a 4c 24 48          	mov    cl,BYTE PTR [rsp+0x48]
  213e31:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
  213e36:	48 8b 80 a0 00 00 00 	mov    rax,QWORD PTR [rax+0xa0]
  213e3d:	48 89 44 24 68       	mov    QWORD PTR [rsp+0x68],rax
  213e42:	88 4c 24 5e          	mov    BYTE PTR [rsp+0x5e],cl
        const standard_opcode_lengths = try st.allocator().alloc(u8, opcode_base - 1);
  213e46:	89 c8                	mov    eax,ecx
  213e48:	04 ff                	add    al,0xff
        if (n == 0) {
  213e4a:	74 48                	je     213e94 <getLineNumberInfo+0x8d4>
  213e4c:	0f b6 d0             	movzx  edx,al
  213e4f:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  213e54:	b9 01 00 00 00       	mov    ecx,0x1
  213e59:	48 8b 74 24 68       	mov    rsi,QWORD PTR [rsp+0x68]
  213e5e:	48 89 94 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rdx
  213e65:	00 
  213e66:	ff 16                	call   QWORD PTR [rsi]
  213e68:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  213e6d:	66 85 c0             	test   ax,ax
  213e70:	0f 84 91 00 00 00    	je     213f07 <getLineNumberInfo+0x947>
  213e76:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
  213e7a:	66 89 01             	mov    WORD PTR [rcx],ax
  213e7d:	c5 fe 6f 84 24 74 08 	vmovdqu ymm0,YMMWORD PTR [rsp+0x874]
  213e84:	00 00 
  213e86:	c5 fc 10 8c 24 82 08 	vmovups ymm1,YMMWORD PTR [rsp+0x882]
  213e8d:	00 00 
  213e8f:	e9 58 fb ff ff       	jmp    2139ec <getLineNumberInfo+0x42c>
  213e94:	31 c0                	xor    eax,eax
  213e96:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  213e9d:	00 
            return Self{
  213e9e:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  213ea2:	c5 f9 7f 84 24 b0 00 	vmovdqa XMMWORD PTR [rsp+0xb0],xmm0
  213ea9:	00 00 
  213eab:	48 c7 84 24 c0 00 00 	mov    QWORD PTR [rsp+0xc0],0x0
  213eb2:	00 00 00 00 00 
  213eb7:	48 8b 74 24 68       	mov    rsi,QWORD PTR [rsp+0x68]
        var include_directories = ArrayList([]u8).init(st.allocator());
  213ebc:	48 89 b4 24 c8 00 00 	mov    QWORD PTR [rsp+0xc8],rsi
  213ec3:	00 
  213ec4:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  213ec9:	48 8d 94 24 b0 00 00 	lea    rdx,[rsp+0xb0]
  213ed0:	00 
            self.items = try self.allocator.alignedRealloc(T, A, self.items, better_capacity);
  213ed1:	b9 08 00 00 00       	mov    ecx,0x8
  213ed6:	e8 05 1f 00 00       	call   215de0 <Allocator_alignedRealloc.73>
  213edb:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  213ee0:	66 85 c0             	test   ax,ax
  213ee3:	0f 84 bd 00 00 00    	je     213fa6 <getLineNumberInfo+0x9e6>
  213ee9:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
        try include_directories.append(compile_unit_cwd);
  213eed:	66 89 01             	mov    WORD PTR [rcx],ax
  213ef0:	c5 fe 6f 84 24 18 08 	vmovdqu ymm0,YMMWORD PTR [rsp+0x818]
  213ef7:	00 00 
  213ef9:	c5 fc 10 8c 24 26 08 	vmovups ymm1,YMMWORD PTR [rsp+0x826]
  213f00:	00 00 
  213f02:	e9 e5 fa ff ff       	jmp    2139ec <getLineNumberInfo+0x42c>
        assert(byte_slice.len == byte_count);
  213f07:	48 8b 84 24 98 00 00 	mov    rax,QWORD PTR [rsp+0x98]
  213f0e:	00 
  213f0f:	48 39 44 24 30       	cmp    QWORD PTR [rsp+0x30],rax
    if (!ok) {
  213f14:	0f 85 65 16 00 00    	jne    21557f <getLineNumberInfo+0x1fbf>
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  213f1a:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
  213f1f:	48 89 84 24 d8 00 00 	mov    QWORD PTR [rsp+0xd8],rax
  213f26:	00 
  213f27:	45 31 e4             	xor    r12d,r12d
  213f2a:	48 8d 5c 24 20       	lea    rbx,[rsp+0x20]
            try self.readNoEof(result[0..]);
  213f2f:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  213f34:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  213f39:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  213f40:	00 00 
            return self.readFn(self, buffer);
  213f42:	48 89 df             	mov    rdi,rbx
  213f45:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  213f4a:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
  213f4f:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  213f53:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  213f58:	66 85 c0             	test   ax,ax
  213f5b:	0f 85 cf 00 00 00    	jne    214030 <getLineNumberInfo+0xa70>
  213f61:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
            if (amt_read < buf.len) return error.EndOfStream;
  213f66:	48 3b 44 24 10       	cmp    rax,QWORD PTR [rsp+0x10]
  213f6b:	0f 82 bb 00 00 00    	jb     21402c <getLineNumberInfo+0xa6c>
            return result[0];
  213f71:	0f b6 44 24 48       	movzx  eax,BYTE PTR [rsp+0x48]
                standard_opcode_lengths[i] = try in_stream.readByte();
  213f76:	48 8b 8c 24 d8 00 00 	mov    rcx,QWORD PTR [rsp+0xd8]
  213f7d:	00 
  213f7e:	42 88 04 21          	mov    BYTE PTR [rcx+r12*1],al
            while (i < opcode_base - 1) : (i += 1) {
  213f82:	49 83 c4 01          	add    r12,0x1
  213f86:	4c 3b a4 24 98 00 00 	cmp    r12,QWORD PTR [rsp+0x98]
  213f8d:	00 
  213f8e:	72 9f                	jb     213f2f <getLineNumberInfo+0x96f>
  213f90:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
  213f95:	48 8b 80 a0 00 00 00 	mov    rax,QWORD PTR [rax+0xa0]
  213f9c:	48 89 44 24 68       	mov    QWORD PTR [rsp+0x68],rax
  213fa1:	e9 f8 fe ff ff       	jmp    213e9e <getLineNumberInfo+0x8de>
  213fa6:	c5 f8 10 44 24 28    	vmovups xmm0,XMMWORD PTR [rsp+0x28]
  213fac:	c5 f8 29 84 24 b0 00 	vmovaps XMMWORD PTR [rsp+0xb0],xmm0
  213fb3:	00 00 
            const result = &self.items[self.len];
  213fb5:	4c 8b a4 24 b0 00 00 	mov    r12,QWORD PTR [rsp+0xb0]
  213fbc:	00 
            self.len = new_length;
  213fbd:	48 c7 84 24 c0 00 00 	mov    QWORD PTR [rsp+0xc0],0x1
  213fc4:	00 01 00 00 00 
            new_item_ptr.* = item;
  213fc9:	c5 f9 6f 84 24 e0 01 	vmovdqa xmm0,XMMWORD PTR [rsp+0x1e0]
  213fd0:	00 00 
  213fd2:	c4 c1 7a 7f 04 24    	vmovdqu XMMWORD PTR [r12],xmm0
  213fd8:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
            var in_file_stream = io.FileInStream.init(&self.self_exe_file);
  213fdd:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  213fe2:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  213fe7:	48 8d 0d 02 bb ff ff 	lea    rcx,[rip+0xffffffffffffbb02]        # 20faf0 <FileInStream_readFn>
  213fee:	48 89 4c 24 10       	mov    QWORD PTR [rsp+0x10],rcx
  213ff3:	48 8b b0 a0 00 00 00 	mov    rsi,QWORD PTR [rax+0xa0]
  213ffa:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
            return readStringRaw(self.allocator(), in_stream);
  213fff:	e8 6c f1 ff ff       	call   213170 <readStringRaw>
  214004:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const dir = try st.readString();
  214009:	66 85 c0             	test   ax,ax
  21400c:	74 40                	je     21404e <getLineNumberInfo+0xa8e>
  21400e:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
  214012:	66 89 01             	mov    WORD PTR [rcx],ax
  214015:	c5 fe 6f 84 24 ea 07 	vmovdqu ymm0,YMMWORD PTR [rsp+0x7ea]
  21401c:	00 00 
  21401e:	c5 fc 10 8c 24 f8 07 	vmovups ymm1,YMMWORD PTR [rsp+0x7f8]
  214025:	00 00 
  214027:	e9 c0 f9 ff ff       	jmp    2139ec <getLineNumberInfo+0x42c>
  21402c:	66 b8 1e 00          	mov    ax,0x1e
  214030:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                standard_opcode_lengths[i] = try in_stream.readByte();
  214034:	66 89 01             	mov    WORD PTR [rcx],ax
  214037:	c5 fe 6f 84 24 46 08 	vmovdqu ymm0,YMMWORD PTR [rsp+0x846]
  21403e:	00 00 
  214040:	c5 fc 10 8c 24 54 08 	vmovups ymm1,YMMWORD PTR [rsp+0x854]
  214047:	00 00 
  214049:	e9 9e f9 ff ff       	jmp    2139ec <getLineNumberInfo+0x42c>
  21404e:	4d 01 f5             	add    r13,r14
  214051:	c5 fa 6f 44 24 28    	vmovdqu xmm0,XMMWORD PTR [rsp+0x28]
  214057:	c5 f9 7f 84 24 50 01 	vmovdqa XMMWORD PTR [rsp+0x150],xmm0
  21405e:	00 00 
  214060:	41 be 01 00 00 00    	mov    r14d,0x1
            if (dir.len == 0) break;
  214066:	c5 f9 6f 84 24 50 01 	vmovdqa xmm0,XMMWORD PTR [rsp+0x150]
  21406d:	00 00 
  21406f:	c4 e3 f9 16 c0 01    	vpextrq rax,xmm0,0x1
  214075:	48 85 c0             	test   rax,rax
  214078:	0f 84 ce 00 00 00    	je     21414c <getLineNumberInfo+0xb8c>
            var better_capacity = self.items.len;
  21407e:	48 8b 8c 24 b8 00 00 	mov    rcx,QWORD PTR [rsp+0xb8]
  214085:	00 
            if (better_capacity >= new_capacity) return;
  214086:	4c 39 f1             	cmp    rcx,r14
  214089:	77 51                	ja     2140dc <getLineNumberInfo+0xb1c>
                better_capacity += better_capacity / 2 + 8;
  21408b:	48 89 c8             	mov    rax,rcx
  21408e:	48 d1 e8             	shr    rax,1
  214091:	48 01 c1             	add    rcx,rax
  214094:	48 83 c1 08          	add    rcx,0x8
                if (better_capacity >= new_capacity) break;
  214098:	4c 39 f1             	cmp    rcx,r14
  21409b:	76 ee                	jbe    21408b <getLineNumberInfo+0xacb>
            self.items = try self.allocator.alignedRealloc(T, A, self.items, better_capacity);
  21409d:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  2140a2:	48 8b 74 24 68       	mov    rsi,QWORD PTR [rsp+0x68]
  2140a7:	48 8d 94 24 b0 00 00 	lea    rdx,[rsp+0xb0]
  2140ae:	00 
  2140af:	e8 2c 1d 00 00       	call   215de0 <Allocator_alignedRealloc.73>
  2140b4:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  2140b9:	66 85 c0             	test   ax,ax
  2140bc:	0f 85 94 01 00 00    	jne    214256 <getLineNumberInfo+0xc96>
  2140c2:	48 8d 44 24 28       	lea    rax,[rsp+0x28]
  2140c7:	c5 fa 6f 00          	vmovdqu xmm0,XMMWORD PTR [rax]
  2140cb:	c5 f9 7f 84 24 b0 00 	vmovdqa XMMWORD PTR [rsp+0xb0],xmm0
  2140d2:	00 00 
            const result = &self.items[self.len];
  2140d4:	4c 8b a4 24 b0 00 00 	mov    r12,QWORD PTR [rsp+0xb0]
  2140db:	00 
  2140dc:	49 8d 5e 01          	lea    rbx,[r14+0x1]
  2140e0:	49 c1 e6 04          	shl    r14,0x4
            self.len = new_length;
  2140e4:	48 89 9c 24 c0 00 00 	mov    QWORD PTR [rsp+0xc0],rbx
  2140eb:	00 
            new_item_ptr.* = item;
  2140ec:	c5 f8 28 84 24 50 01 	vmovaps xmm0,XMMWORD PTR [rsp+0x150]
  2140f3:	00 00 
  2140f5:	c4 81 78 11 04 34    	vmovups XMMWORD PTR [r12+r14*1],xmm0
  2140fb:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
            var in_file_stream = io.FileInStream.init(&self.self_exe_file);
  214100:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  214105:	48 8d 0d e4 b9 ff ff 	lea    rcx,[rip+0xffffffffffffb9e4]        # 20faf0 <FileInStream_readFn>
  21410c:	48 89 4c 24 10       	mov    QWORD PTR [rsp+0x10],rcx
  214111:	48 8b b0 a0 00 00 00 	mov    rsi,QWORD PTR [rax+0xa0]
            return readStringRaw(self.allocator(), in_stream);
  214118:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  21411d:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  214122:	e8 49 f0 ff ff       	call   213170 <readStringRaw>
  214127:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  21412c:	c5 fa 6f 44 24 28    	vmovdqu xmm0,XMMWORD PTR [rsp+0x28]
  214132:	c5 f9 7f 84 24 50 01 	vmovdqa XMMWORD PTR [rsp+0x150],xmm0
  214139:	00 00 
  21413b:	49 89 de             	mov    r14,rbx
            const dir = try st.readString();
  21413e:	66 85 c0             	test   ax,ax
  214141:	0f 84 1f ff ff ff    	je     214066 <getLineNumberInfo+0xaa6>
  214147:	e9 c2 fe ff ff       	jmp    21400e <getLineNumberInfo+0xa4e>
  21414c:	48 8b 54 24 60       	mov    rdx,QWORD PTR [rsp+0x60]
  214151:	48 8b b2 a0 00 00 00 	mov    rsi,QWORD PTR [rdx+0xa0]
            return Self{
  214158:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  21415c:	c5 f9 7f 44 24 70    	vmovdqa XMMWORD PTR [rsp+0x70],xmm0
  214162:	48 c7 84 24 80 00 00 	mov    QWORD PTR [rsp+0x80],0x0
  214169:	00 00 00 00 00 
        var file_entries = ArrayList(FileEntry).init(st.allocator());
  21416e:	48 89 b4 24 88 00 00 	mov    QWORD PTR [rsp+0x88],rsi
  214175:	00 
        var prog = LineNumberProgram.init(default_is_stmt, include_directories.toSliceConst(), &file_entries, target_address);
  214176:	c5 fc 28 05 42 c0 fe 	vmovaps ymm0,YMMWORD PTR [rip+0xfffffffffffec042]        # 2001c0 <__unnamed_90-0x20>
  21417d:	ff 
  21417e:	c5 fc 11 84 24 e0 00 	vmovups YMMWORD PTR [rsp+0xe0],ymm0
  214185:	00 00 
        const default_is_stmt = (try in_stream.readByte()) != 0;
  214187:	40 84 ed             	test   bpl,bpl
        var prog = LineNumberProgram.init(default_is_stmt, include_directories.toSliceConst(), &file_entries, target_address);
  21418a:	0f 95 84 24 00 01 00 	setne  BYTE PTR [rsp+0x100]
  214191:	00 
  214192:	66 c7 84 24 01 01 00 	mov    WORD PTR [rsp+0x101],0x0
  214199:	00 00 00 
  21419c:	8b 84 24 d3 00 00 00 	mov    eax,DWORD PTR [rsp+0xd3]
  2141a3:	89 84 24 03 01 00 00 	mov    DWORD PTR [rsp+0x103],eax
            return self.items[0..self.len];
  2141aa:	48 8b 84 24 b0 00 00 	mov    rax,QWORD PTR [rsp+0xb0]
  2141b1:	00 
  2141b2:	8a 8c 24 d7 00 00 00 	mov    cl,BYTE PTR [rsp+0xd7]
  2141b9:	88 8c 24 07 01 00 00 	mov    BYTE PTR [rsp+0x107],cl
  2141c0:	48 8b 8c 24 a0 00 00 	mov    rcx,QWORD PTR [rsp+0xa0]
  2141c7:	00 
  2141c8:	48 89 8c 24 08 01 00 	mov    QWORD PTR [rsp+0x108],rcx
  2141cf:	00 
  2141d0:	48 89 84 24 10 01 00 	mov    QWORD PTR [rsp+0x110],rax
  2141d7:	00 
  2141d8:	4c 89 b4 24 18 01 00 	mov    QWORD PTR [rsp+0x118],r14
  2141df:	00 
  2141e0:	48 8d 44 24 70       	lea    rax,[rsp+0x70]
  2141e5:	48 89 84 24 20 01 00 	mov    QWORD PTR [rsp+0x120],rax
  2141ec:	00 
  2141ed:	48 c7 84 24 28 01 00 	mov    QWORD PTR [rsp+0x128],0x0
  2141f4:	00 00 00 00 00 
  2141f9:	c5 fe 6f 84 24 f8 0a 	vmovdqu ymm0,YMMWORD PTR [rsp+0xaf8]
  214200:	00 00 
  214202:	c5 fe 7f 84 24 30 01 	vmovdqu YMMWORD PTR [rsp+0x130],ymm0
  214209:	00 00 
            var in_file_stream = io.FileInStream.init(&self.self_exe_file);
  21420b:	48 89 54 24 08       	mov    QWORD PTR [rsp+0x8],rdx
  214210:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  214215:	48 8d 05 d4 b8 ff ff 	lea    rax,[rip+0xffffffffffffb8d4]        # 20faf0 <FileInStream_readFn>
  21421c:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  214221:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
            return readStringRaw(self.allocator(), in_stream);
  214226:	c5 f8 77             	vzeroupper 
  214229:	e8 42 ef ff ff       	call   213170 <readStringRaw>
  21422e:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const file_name = try st.readString();
  214233:	66 85 c0             	test   ax,ax
  214236:	74 3c                	je     214274 <getLineNumberInfo+0xcb4>
  214238:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
  21423c:	66 89 01             	mov    WORD PTR [rcx],ax
  21423f:	c5 fe 6f 84 24 8e 07 	vmovdqu ymm0,YMMWORD PTR [rsp+0x78e]
  214246:	00 00 
  214248:	c5 fc 10 8c 24 9c 07 	vmovups ymm1,YMMWORD PTR [rsp+0x79c]
  21424f:	00 00 
  214251:	e9 96 f7 ff ff       	jmp    2139ec <getLineNumberInfo+0x42c>
  214256:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
            try include_directories.append(dir);
  21425a:	66 89 01             	mov    WORD PTR [rcx],ax
  21425d:	c5 fc 10 84 24 bc 07 	vmovups ymm0,YMMWORD PTR [rsp+0x7bc]
  214264:	00 00 
  214266:	c5 fc 10 8c 24 ca 07 	vmovups ymm1,YMMWORD PTR [rsp+0x7ca]
  21426d:	00 00 
  21426f:	e9 78 f7 ff ff       	jmp    2139ec <getLineNumberInfo+0x42c>
  214274:	c5 fa 6f 44 24 28    	vmovdqu xmm0,XMMWORD PTR [rsp+0x28]
  21427a:	c5 f9 7f 84 24 a0 00 	vmovdqa XMMWORD PTR [rsp+0xa0],xmm0
  214281:	00 00 
            if (file_name.len == 0) break;
  214283:	c5 f9 6f 84 24 a0 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0xa0]
  21428a:	00 00 
  21428c:	c4 e3 f9 16 c0 01    	vpextrq rax,xmm0,0x1
  214292:	48 85 c0             	test   rax,rax
  214295:	0f 84 44 03 00 00    	je     2145df <getLineNumberInfo+0x101f>
            try self.readNoEof(result[0..]);
  21429b:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  2142a0:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  2142a5:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  2142ac:	00 00 
            return self.readFn(self, buffer);
  2142ae:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  2142b3:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  2142b8:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
  2142bd:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  2142c1:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  2142c6:	66 85 c0             	test   ax,ax
  2142c9:	0f 85 ca 02 00 00    	jne    214599 <getLineNumberInfo+0xfd9>
  2142cf:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  2142d4:	45 31 e4             	xor    r12d,r12d
  2142d7:	31 ed                	xor    ebp,ebp
            if (amt_read < buf.len) return error.EndOfStream;
  2142d9:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  2142de:	0f 82 ab 02 00 00    	jb     21458f <getLineNumberInfo+0xfcf>
            return result[0];
  2142e4:	0f b6 44 24 48       	movzx  eax,BYTE PTR [rsp+0x48]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  2142e9:	89 c2                	mov    edx,eax
  2142eb:	83 e2 7f             	and    edx,0x7f
  2142ee:	89 ee                	mov    esi,ebp
  2142f0:	83 e6 3f             	and    esi,0x3f
  2142f3:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  2142f8:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  2142fd:	48 39 d6             	cmp    rsi,rdx
  214300:	0f 85 8f 02 00 00    	jne    214595 <getLineNumberInfo+0xfd5>
        result |= operand;
  214306:	49 09 cc             	or     r12,rcx
        if ((byte & 0b10000000) == 0) return result;
  214309:	84 c0                	test   al,al
  21430b:	79 3e                	jns    21434b <getLineNumberInfo+0xd8b>
        shift += 7;
  21430d:	48 83 c5 07          	add    rbp,0x7
            try self.readNoEof(result[0..]);
  214311:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  214316:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  21431b:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  214322:	00 00 
            return self.readFn(self, buffer);
  214324:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  214329:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  21432e:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
  214333:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  214337:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  21433c:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  214341:	66 85 c0             	test   ax,ax
  214344:	74 93                	je     2142d9 <getLineNumberInfo+0xd19>
  214346:	e9 4e 02 00 00       	jmp    214599 <getLineNumberInfo+0xfd9>
            try self.readNoEof(result[0..]);
  21434b:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  214350:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  214355:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  21435c:	00 00 
            return self.readFn(self, buffer);
  21435e:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  214363:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  214368:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
  21436d:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  214371:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  214376:	66 85 c0             	test   ax,ax
  214379:	0f 85 42 02 00 00    	jne    2145c1 <getLineNumberInfo+0x1001>
  21437f:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  214384:	45 31 f6             	xor    r14d,r14d
  214387:	31 ed                	xor    ebp,ebp
            if (amt_read < buf.len) return error.EndOfStream;
  214389:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  21438e:	0f 82 23 02 00 00    	jb     2145b7 <getLineNumberInfo+0xff7>
            return result[0];
  214394:	0f b6 44 24 48       	movzx  eax,BYTE PTR [rsp+0x48]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  214399:	89 c2                	mov    edx,eax
  21439b:	83 e2 7f             	and    edx,0x7f
  21439e:	89 ee                	mov    esi,ebp
  2143a0:	83 e6 3f             	and    esi,0x3f
  2143a3:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  2143a8:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  2143ad:	48 39 d6             	cmp    rsi,rdx
  2143b0:	0f 85 07 02 00 00    	jne    2145bd <getLineNumberInfo+0xffd>
        result |= operand;
  2143b6:	49 09 ce             	or     r14,rcx
        if ((byte & 0b10000000) == 0) return result;
  2143b9:	84 c0                	test   al,al
  2143bb:	79 3e                	jns    2143fb <getLineNumberInfo+0xe3b>
        shift += 7;
  2143bd:	48 83 c5 07          	add    rbp,0x7
            try self.readNoEof(result[0..]);
  2143c1:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  2143c6:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  2143cb:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  2143d2:	00 00 
            return self.readFn(self, buffer);
  2143d4:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  2143d9:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  2143de:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
  2143e3:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  2143e7:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  2143ec:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  2143f1:	66 85 c0             	test   ax,ax
  2143f4:	74 93                	je     214389 <getLineNumberInfo+0xdc9>
  2143f6:	e9 c6 01 00 00       	jmp    2145c1 <getLineNumberInfo+0x1001>
            try self.readNoEof(result[0..]);
  2143fb:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  214400:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  214405:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  21440c:	00 00 
            return self.readFn(self, buffer);
  21440e:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  214413:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  214418:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
  21441d:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  214421:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  214426:	66 85 c0             	test   ax,ax
  214429:	0f 85 05 02 00 00    	jne    214634 <getLineNumberInfo+0x1074>
  21442f:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  214434:	31 db                	xor    ebx,ebx
  214436:	31 ed                	xor    ebp,ebp
            if (amt_read < buf.len) return error.EndOfStream;
  214438:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  21443d:	0f 82 e7 01 00 00    	jb     21462a <getLineNumberInfo+0x106a>
            return result[0];
  214443:	0f b6 44 24 48       	movzx  eax,BYTE PTR [rsp+0x48]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  214448:	89 c2                	mov    edx,eax
  21444a:	83 e2 7f             	and    edx,0x7f
  21444d:	89 ee                	mov    esi,ebp
  21444f:	83 e6 3f             	and    esi,0x3f
  214452:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  214457:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  21445c:	48 39 d6             	cmp    rsi,rdx
  21445f:	0f 85 cb 01 00 00    	jne    214630 <getLineNumberInfo+0x1070>
        result |= operand;
  214465:	48 09 cb             	or     rbx,rcx
        if ((byte & 0b10000000) == 0) return result;
  214468:	84 c0                	test   al,al
  21446a:	79 3e                	jns    2144aa <getLineNumberInfo+0xeea>
        shift += 7;
  21446c:	48 83 c5 07          	add    rbp,0x7
            try self.readNoEof(result[0..]);
  214470:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  214475:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  21447a:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  214481:	00 00 
            return self.readFn(self, buffer);
  214483:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  214488:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  21448d:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
  214492:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  214496:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  21449b:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  2144a0:	66 85 c0             	test   ax,ax
  2144a3:	74 93                	je     214438 <getLineNumberInfo+0xe78>
  2144a5:	e9 8a 01 00 00       	jmp    214634 <getLineNumberInfo+0x1074>
            const new_length = self.len + 1;
  2144aa:	48 8b ac 24 80 00 00 	mov    rbp,QWORD PTR [rsp+0x80]
  2144b1:	00 
            var better_capacity = self.items.len;
  2144b2:	48 8b 4c 24 78       	mov    rcx,QWORD PTR [rsp+0x78]
            if (better_capacity >= new_capacity) return;
  2144b7:	48 39 e9             	cmp    rcx,rbp
  2144ba:	76 05                	jbe    2144c1 <getLineNumberInfo+0xf01>
            const result = &self.items[self.len];
  2144bc:	48 89 e8             	mov    rax,rbp
  2144bf:	eb 4e                	jmp    21450f <getLineNumberInfo+0xf4f>
                better_capacity += better_capacity / 2 + 8;
  2144c1:	48 89 c8             	mov    rax,rcx
  2144c4:	48 d1 e8             	shr    rax,1
  2144c7:	48 01 c1             	add    rcx,rax
  2144ca:	48 83 c1 08          	add    rcx,0x8
                if (better_capacity >= new_capacity) break;
  2144ce:	48 39 e9             	cmp    rcx,rbp
  2144d1:	76 ee                	jbe    2144c1 <getLineNumberInfo+0xf01>
            self.items = try self.allocator.alignedRealloc(T, A, self.items, better_capacity);
  2144d3:	48 8b b4 24 88 00 00 	mov    rsi,QWORD PTR [rsp+0x88]
  2144da:	00 
  2144db:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  2144e0:	48 8d 54 24 70       	lea    rdx,[rsp+0x70]
  2144e5:	e8 56 1b 00 00       	call   216040 <Allocator_alignedRealloc.76>
  2144ea:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  2144ef:	66 85 c0             	test   ax,ax
  2144f2:	0f 85 d5 0c 00 00    	jne    2151cd <getLineNumberInfo+0x1c0d>
  2144f8:	48 8d 44 24 28       	lea    rax,[rsp+0x28]
  2144fd:	c5 fa 6f 00          	vmovdqu xmm0,XMMWORD PTR [rax]
  214501:	c5 f9 7f 44 24 70    	vmovdqa XMMWORD PTR [rsp+0x70],xmm0
            const result = &self.items[self.len];
  214507:	48 8b 84 24 80 00 00 	mov    rax,QWORD PTR [rsp+0x80]
  21450e:	00 
  21450f:	48 83 c5 01          	add    rbp,0x1
  214513:	48 8b 4c 24 70       	mov    rcx,QWORD PTR [rsp+0x70]
  214518:	48 8d 04 80          	lea    rax,[rax+rax*4]
            self.len = new_length;
  21451c:	48 89 ac 24 80 00 00 	mov    QWORD PTR [rsp+0x80],rbp
  214523:	00 
            new_item_ptr.* = item;
  214524:	c5 f8 28 84 24 a0 00 	vmovaps xmm0,XMMWORD PTR [rsp+0xa0]
  21452b:	00 00 
  21452d:	c5 f8 11 04 c1       	vmovups XMMWORD PTR [rcx+rax*8],xmm0
  214532:	4c 89 64 c1 10       	mov    QWORD PTR [rcx+rax*8+0x10],r12
  214537:	4c 89 74 c1 18       	mov    QWORD PTR [rcx+rax*8+0x18],r14
  21453c:	48 89 5c c1 20       	mov    QWORD PTR [rcx+rax*8+0x20],rbx
  214541:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
            var in_file_stream = io.FileInStream.init(&self.self_exe_file);
  214546:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  21454b:	48 8d 0d 9e b5 ff ff 	lea    rcx,[rip+0xffffffffffffb59e]        # 20faf0 <FileInStream_readFn>
  214552:	48 89 4c 24 10       	mov    QWORD PTR [rsp+0x10],rcx
  214557:	48 8b b0 a0 00 00 00 	mov    rsi,QWORD PTR [rax+0xa0]
            return readStringRaw(self.allocator(), in_stream);
  21455e:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  214563:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  214568:	e8 03 ec ff ff       	call   213170 <readStringRaw>
  21456d:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  214572:	c5 fa 6f 44 24 28    	vmovdqu xmm0,XMMWORD PTR [rsp+0x28]
            const file_name = try st.readString();
  214578:	c5 f9 7f 84 24 a0 00 	vmovdqa XMMWORD PTR [rsp+0xa0],xmm0
  21457f:	00 00 
  214581:	66 85 c0             	test   ax,ax
  214584:	0f 84 f9 fc ff ff    	je     214283 <getLineNumberInfo+0xcc3>
  21458a:	e9 a9 fc ff ff       	jmp    214238 <getLineNumberInfo+0xc78>
  21458f:	66 b8 1e 00          	mov    ax,0x1e
  214593:	eb 04                	jmp    214599 <getLineNumberInfo+0xfd9>
  214595:	66 b8 23 00          	mov    ax,0x23
  214599:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
            const dir_index = try readULeb128(in_stream);
  21459d:	66 89 01             	mov    WORD PTR [rcx],ax
  2145a0:	c5 fe 6f 84 24 60 07 	vmovdqu ymm0,YMMWORD PTR [rsp+0x760]
  2145a7:	00 00 
  2145a9:	c5 fc 10 8c 24 6e 07 	vmovups ymm1,YMMWORD PTR [rsp+0x76e]
  2145b0:	00 00 
  2145b2:	e9 35 f4 ff ff       	jmp    2139ec <getLineNumberInfo+0x42c>
  2145b7:	66 b8 1e 00          	mov    ax,0x1e
  2145bb:	eb 04                	jmp    2145c1 <getLineNumberInfo+0x1001>
  2145bd:	66 b8 23 00          	mov    ax,0x23
  2145c1:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
            const mtime = try readULeb128(in_stream);
  2145c5:	66 89 01             	mov    WORD PTR [rcx],ax
  2145c8:	c5 fe 6f 84 24 32 07 	vmovdqu ymm0,YMMWORD PTR [rsp+0x732]
  2145cf:	00 00 
  2145d1:	c5 fc 10 8c 24 40 07 	vmovups ymm1,YMMWORD PTR [rsp+0x740]
  2145d8:	00 00 
  2145da:	e9 0d f4 ff ff       	jmp    2139ec <getLineNumberInfo+0x42c>
  2145df:	4d 85 ed             	test   r13,r13
  2145e2:	78 6e                	js     214652 <getLineNumberInfo+0x1092>
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  2145e4:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
  2145e9:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  2145ec:	31 ed                	xor    ebp,ebp
  2145ee:	b8 08 00 00 00       	mov    eax,0x8
  2145f3:	31 d2                	xor    edx,edx
  2145f5:	4c 89 ee             	mov    rsi,r13
  2145f8:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  2145fa:	48 89 c1             	mov    rcx,rax
  2145fd:	48 f7 d9             	neg    rcx
  214600:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  214606:	48 0f 46 cd          	cmovbe rcx,rbp
  21460a:	66 b8 02 00          	mov    ax,0x2
                if (err > 0) {
  21460e:	48 83 f9 1d          	cmp    rcx,0x1d
  214612:	77 60                	ja     214674 <getLineNumberInfo+0x10b4>
  214614:	48 8d 15 f9 c3 fe ff 	lea    rdx,[rip+0xfffffffffffec3f9]        # 200a14 <app_mask+0x794>
  21461b:	48 63 0c 8a          	movsxd rcx,DWORD PTR [rdx+rcx*4]
  21461f:	48 01 d1             	add    rcx,rdx
  214622:	ff e1                	jmp    rcx
  214624:	66 b8 20 00          	mov    ax,0x20
  214628:	eb 2c                	jmp    214656 <getLineNumberInfo+0x1096>
  21462a:	66 b8 1e 00          	mov    ax,0x1e
  21462e:	eb 04                	jmp    214634 <getLineNumberInfo+0x1074>
  214630:	66 b8 23 00          	mov    ax,0x23
  214634:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
            const len_bytes = try readULeb128(in_stream);
  214638:	66 89 01             	mov    WORD PTR [rcx],ax
  21463b:	c5 fe 6f 84 24 04 07 	vmovdqu ymm0,YMMWORD PTR [rsp+0x704]
  214642:	00 00 
  214644:	c5 fc 10 8c 24 12 07 	vmovups ymm1,YMMWORD PTR [rsp+0x712]
  21464b:	00 00 
  21464d:	e9 9a f3 ff ff       	jmp    2139ec <getLineNumberInfo+0x42c>
  214652:	66 b8 21 00          	mov    ax,0x21
  214656:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
        try in_file.seekTo(prog_start_offset);
  21465a:	66 89 01             	mov    WORD PTR [rcx],ax
  21465d:	c5 fe 6f 84 24 a8 06 	vmovdqu ymm0,YMMWORD PTR [rsp+0x6a8]
  214664:	00 00 
  214666:	c5 fc 10 8c 24 b6 06 	vmovups ymm1,YMMWORD PTR [rsp+0x6b6]
  21466d:	00 00 
  21466f:	e9 78 f3 ff ff       	jmp    2139ec <getLineNumberInfo+0x42c>
  214674:	48 83 f9 4b          	cmp    rcx,0x4b
  214678:	75 dc                	jne    214656 <getLineNumberInfo+0x1096>
  21467a:	eb a8                	jmp    214624 <getLineNumberInfo+0x1064>
            try self.readNoEof(result[0..]);
  21467c:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  214681:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  214686:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  21468d:	00 00 
  21468f:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  214694:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
            return self.readFn(self, buffer);
  214699:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  21469e:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  2146a2:	0f b7 4c 24 20       	movzx  ecx,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  2146a7:	66 85 c9             	test   cx,cx
  2146aa:	74 28                	je     2146d4 <getLineNumberInfo+0x1114>
  2146ac:	48 8b 04 24          	mov    rax,QWORD PTR [rsp]
            const opcode = try in_stream.readByte();
  2146b0:	66 89 08             	mov    WORD PTR [rax],cx
  2146b3:	c5 fe 6f 84 24 7a 06 	vmovdqu ymm0,YMMWORD PTR [rsp+0x67a]
  2146ba:	00 00 
  2146bc:	c5 fc 10 8c 24 88 06 	vmovups ymm1,YMMWORD PTR [rsp+0x688]
  2146c3:	00 00 
  2146c5:	c5 fc 11 48 10       	vmovups YMMWORD PTR [rax+0x10],ymm1
  2146ca:	c5 fe 7f 40 02       	vmovdqu YMMWORD PTR [rax+0x2],ymm0
  2146cf:	e9 3d f0 ff ff       	jmp    213711 <getLineNumberInfo+0x151>
  2146d4:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
  2146d9:	8a 4c 24 5e          	mov    cl,BYTE PTR [rsp+0x5e]
  2146dd:	f6 d1                	not    cl
  2146df:	88 8c 24 a0 00 00 00 	mov    BYTE PTR [rsp+0xa0],cl
  2146e6:	4c 8d 64 24 20       	lea    r12,[rsp+0x20]
  2146eb:	4c 8d 6c 24 08       	lea    r13,[rsp+0x8]
            if (amt_read < buf.len) return error.EndOfStream;
  2146f0:	48 3b 44 24 10       	cmp    rax,QWORD PTR [rsp+0x10]
  2146f5:	0f 82 f0 0a 00 00    	jb     2151eb <getLineNumberInfo+0x1c2b>
            return result[0];
  2146fb:	8a 44 24 48          	mov    al,BYTE PTR [rsp+0x48]
            if (opcode == DW.LNS_extended_op) {
  2146ff:	84 c0                	test   al,al
  214701:	74 62                	je     214765 <getLineNumberInfo+0x11a5>
            } else if (opcode >= opcode_base) {
  214703:	89 c1                	mov    ecx,eax
  214705:	2a 4c 24 5e          	sub    cl,BYTE PTR [rsp+0x5e]
  214709:	0f 83 01 01 00 00    	jae    214810 <getLineNumberInfo+0x1250>
                switch (opcode) {
  21470f:	04 ff                	add    al,0xff
  214711:	0f b6 c0             	movzx  eax,al
  214714:	3c 09                	cmp    al,0x9
  214716:	0f 87 3b 02 00 00    	ja     214957 <getLineNumberInfo+0x1397>
  21471c:	48 8d 0d 69 c3 fe ff 	lea    rcx,[rip+0xfffffffffffec369]        # 200a8c <app_mask+0x80c>
  214723:	48 63 04 81          	movsxd rax,DWORD PTR [rcx+rax*4]
  214727:	48 01 c8             	add    rax,rcx
  21472a:	ff e0                	jmp    rax
                        if (try prog.checkLineMatch()) |info| return info;
  21472c:	48 8d bc 24 08 02 00 	lea    rdi,[rsp+0x208]
  214733:	00 
  214734:	48 8d b4 24 e0 00 00 	lea    rsi,[rsp+0xe0]
  21473b:	00 
  21473c:	e8 bf 14 00 00       	call   215c00 <LineNumberProgram_checkLineMatch>
  214741:	0f b7 84 24 08 02 00 	movzx  eax,WORD PTR [rsp+0x208]
  214748:	00 
  214749:	66 85 c0             	test   ax,ax
  21474c:	0f 85 ac 0c 00 00    	jne    2153fe <getLineNumberInfo+0x1e3e>
  214752:	80 bc 24 38 02 00 00 	cmp    BYTE PTR [rsp+0x238],0x1
  214759:	01 
  21475a:	0f 85 0c 01 00 00    	jne    21486c <getLineNumberInfo+0x12ac>
  214760:	e9 b7 0c 00 00       	jmp    21541c <getLineNumberInfo+0x1e5c>
            try self.readNoEof(result[0..]);
  214765:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  21476a:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  21476f:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  214776:	00 00 
            return self.readFn(self, buffer);
  214778:	4c 89 e7             	mov    rdi,r12
  21477b:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  214780:	4c 89 ea             	mov    rdx,r13
  214783:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  214787:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  21478c:	66 85 c0             	test   ax,ax
  21478f:	0f 85 1a 0a 00 00    	jne    2151af <getLineNumberInfo+0x1bef>
  214795:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  21479a:	31 ed                	xor    ebp,ebp
  21479c:	31 db                	xor    ebx,ebx
            if (amt_read < buf.len) return error.EndOfStream;
  21479e:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  2147a3:	0f 82 fc 09 00 00    	jb     2151a5 <getLineNumberInfo+0x1be5>
            return result[0];
  2147a9:	0f b6 44 24 48       	movzx  eax,BYTE PTR [rsp+0x48]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  2147ae:	89 c2                	mov    edx,eax
  2147b0:	83 e2 7f             	and    edx,0x7f
  2147b3:	89 de                	mov    esi,ebx
  2147b5:	83 e6 3f             	and    esi,0x3f
  2147b8:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  2147bd:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  2147c2:	48 39 d6             	cmp    rsi,rdx
  2147c5:	0f 85 e0 09 00 00    	jne    2151ab <getLineNumberInfo+0x1beb>
        result |= operand;
  2147cb:	48 09 cd             	or     rbp,rcx
        if ((byte & 0b10000000) == 0) return result;
  2147ce:	84 c0                	test   al,al
  2147d0:	0f 89 d8 00 00 00    	jns    2148ae <getLineNumberInfo+0x12ee>
        shift += 7;
  2147d6:	48 83 c3 07          	add    rbx,0x7
            try self.readNoEof(result[0..]);
  2147da:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  2147df:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  2147e4:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  2147eb:	00 00 
            return self.readFn(self, buffer);
  2147ed:	4c 89 e7             	mov    rdi,r12
  2147f0:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  2147f5:	4c 89 ea             	mov    rdx,r13
  2147f8:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  2147fc:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  214801:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  214806:	66 85 c0             	test   ax,ax
  214809:	74 93                	je     21479e <getLineNumberInfo+0x11de>
  21480b:	e9 9f 09 00 00       	jmp    2151af <getLineNumberInfo+0x1bef>
                const inc_line = i32(line_base) + i32(adjusted_opcode % line_range);
  214810:	0f b6 c1             	movzx  eax,cl
  214813:	f6 74 24 5f          	div    BYTE PTR [rsp+0x5f]
  214817:	0f b6 cc             	movzx  ecx,ah
  21481a:	48 03 8c 24 68 01 00 	add    rcx,QWORD PTR [rsp+0x168]
  214821:	00 
                prog.line += inc_line;
  214822:	48 01 8c 24 f0 00 00 	add    QWORD PTR [rsp+0xf0],rcx
  214829:	00 
                const inc_addr = minimum_instruction_length * (adjusted_opcode / line_range);
  21482a:	41 f6 e7             	mul    r15b
                prog.address += inc_addr;
  21482d:	0f b6 c0             	movzx  eax,al
  214830:	48 01 84 24 e0 00 00 	add    QWORD PTR [rsp+0xe0],rax
  214837:	00 
                if (try prog.checkLineMatch()) |info| return info;
  214838:	48 8d bc 24 40 02 00 	lea    rdi,[rsp+0x240]
  21483f:	00 
  214840:	48 8d b4 24 e0 00 00 	lea    rsi,[rsp+0xe0]
  214847:	00 
  214848:	e8 b3 13 00 00       	call   215c00 <LineNumberProgram_checkLineMatch>
  21484d:	0f b7 84 24 40 02 00 	movzx  eax,WORD PTR [rsp+0x240]
  214854:	00 
  214855:	66 85 c0             	test   ax,ax
  214858:	0f 85 96 09 00 00    	jne    2151f4 <getLineNumberInfo+0x1c34>
  21485e:	80 bc 24 70 02 00 00 	cmp    BYTE PTR [rsp+0x270],0x1
  214865:	01 
  214866:	0f 84 a6 09 00 00    	je     215212 <getLineNumberInfo+0x1c52>
  21486c:	c6 84 24 01 01 00 00 	mov    BYTE PTR [rsp+0x101],0x0
  214873:	00 
            try self.readNoEof(result[0..]);
  214874:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  214879:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  21487e:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  214885:	00 00 
            return self.readFn(self, buffer);
  214887:	4c 89 e7             	mov    rdi,r12
  21488a:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  21488f:	4c 89 ea             	mov    rdx,r13
  214892:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  214896:	0f b7 4c 24 20       	movzx  ecx,WORD PTR [rsp+0x20]
  21489b:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  2148a0:	66 85 c9             	test   cx,cx
  2148a3:	0f 84 47 fe ff ff    	je     2146f0 <getLineNumberInfo+0x1130>
  2148a9:	e9 fe fd ff ff       	jmp    2146ac <getLineNumberInfo+0x10ec>
                if (op_size < 1) return error.InvalidDebugInfo;
  2148ae:	48 85 ed             	test   rbp,rbp
  2148b1:	0f 84 d0 08 00 00    	je     215187 <getLineNumberInfo+0x1bc7>
            try self.readNoEof(result[0..]);
  2148b7:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  2148bc:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  2148c1:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  2148c8:	00 00 
            return self.readFn(self, buffer);
  2148ca:	4c 89 e7             	mov    rdi,r12
  2148cd:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  2148d2:	4c 89 ea             	mov    rdx,r13
  2148d5:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  2148d9:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  2148de:	66 85 c0             	test   ax,ax
  2148e1:	0f 85 39 0a 00 00    	jne    215320 <getLineNumberInfo+0x1d60>
  2148e7:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
            if (amt_read < buf.len) return error.EndOfStream;
  2148ec:	48 3b 44 24 10       	cmp    rax,QWORD PTR [rsp+0x10]
  2148f1:	0f 82 25 0a 00 00    	jb     21531c <getLineNumberInfo+0x1d5c>
            return result[0];
  2148f7:	8a 44 24 48          	mov    al,BYTE PTR [rsp+0x48]
                switch (sub_op) {
  2148fb:	3c 02                	cmp    al,0x2
  2148fd:	0f 84 03 04 00 00    	je     214d06 <getLineNumberInfo+0x1746>
  214903:	3c 03                	cmp    al,0x3
  214905:	0f 84 b2 04 00 00    	je     214dbd <getLineNumberInfo+0x17fd>
  21490b:	3c 01                	cmp    al,0x1
  21490d:	0f 84 2b 0a 00 00    	je     21533e <getLineNumberInfo+0x1d7e>
  214913:	48 83 c5 ff          	add    rbp,0xffffffffffffffff
  214917:	0f 88 6a 08 00 00    	js     215187 <getLineNumberInfo+0x1bc7>
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  21491d:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
  214922:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  214925:	b8 08 00 00 00       	mov    eax,0x8
  21492a:	ba 01 00 00 00       	mov    edx,0x1
  21492f:	48 89 ee             	mov    rsi,rbp
  214932:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  214934:	48 89 c1             	mov    rcx,rax
  214937:	48 f7 d9             	neg    rcx
  21493a:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  214940:	b8 00 00 00 00       	mov    eax,0x0
  214945:	48 0f 46 c8          	cmovbe rcx,rax
                if (err > 0) {
  214949:	48 85 c9             	test   rcx,rcx
  21494c:	0f 84 22 ff ff ff    	je     214874 <getLineNumberInfo+0x12b4>
  214952:	e9 8d 0b 00 00       	jmp    2154e4 <getLineNumberInfo+0x1f24>
                        if (opcode - 1 >= standard_opcode_lengths.len) return error.InvalidDebugInfo;
  214957:	48 39 84 24 98 00 00 	cmp    QWORD PTR [rsp+0x98],rax
  21495e:	00 
  21495f:	0f 86 22 08 00 00    	jbe    215187 <getLineNumberInfo+0x1bc7>
                        try in_file.seekForward(len_bytes);
  214965:	48 8b 8c 24 d8 00 00 	mov    rcx,QWORD PTR [rsp+0xd8]
  21496c:	00 
  21496d:	0f b6 34 01          	movzx  esi,BYTE PTR [rcx+rax*1]
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  214971:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
  214976:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  214979:	b8 08 00 00 00       	mov    eax,0x8
  21497e:	ba 01 00 00 00       	mov    edx,0x1
  214983:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  214985:	48 89 c1             	mov    rcx,rax
  214988:	48 f7 d9             	neg    rcx
  21498b:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  214991:	b8 00 00 00 00       	mov    eax,0x0
  214996:	48 0f 46 c8          	cmovbe rcx,rax
  21499a:	48 85 c9             	test   rcx,rcx
  21499d:	0f 84 d1 fe ff ff    	je     214874 <getLineNumberInfo+0x12b4>
  2149a3:	e9 b6 0a 00 00       	jmp    21545e <getLineNumberInfo+0x1e9e>
            try self.readNoEof(result[0..]);
  2149a8:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  2149ad:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  2149b2:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  2149b9:	00 00 
            return self.readFn(self, buffer);
  2149bb:	4c 89 e7             	mov    rdi,r12
  2149be:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  2149c3:	4c 89 ea             	mov    rdx,r13
  2149c6:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  2149ca:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  2149cf:	66 85 c0             	test   ax,ax
  2149d2:	0f 85 98 08 00 00    	jne    215270 <getLineNumberInfo+0x1cb0>
  2149d8:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  2149dd:	31 db                	xor    ebx,ebx
  2149df:	31 ed                	xor    ebp,ebp
            if (amt_read < buf.len) return error.EndOfStream;
  2149e1:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  2149e6:	0f 82 68 08 00 00    	jb     215254 <getLineNumberInfo+0x1c94>
            return result[0];
  2149ec:	0f b6 44 24 48       	movzx  eax,BYTE PTR [rsp+0x48]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  2149f1:	89 c2                	mov    edx,eax
  2149f3:	83 e2 7f             	and    edx,0x7f
  2149f6:	89 ee                	mov    esi,ebp
  2149f8:	83 e6 3f             	and    esi,0x3f
  2149fb:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  214a00:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  214a05:	48 39 d6             	cmp    rsi,rdx
  214a08:	0f 85 5e 08 00 00    	jne    21526c <getLineNumberInfo+0x1cac>
        result |= operand;
  214a0e:	48 09 cb             	or     rbx,rcx
        if ((byte & 0b10000000) == 0) return result;
  214a11:	84 c0                	test   al,al
  214a13:	0f 89 16 05 00 00    	jns    214f2f <getLineNumberInfo+0x196f>
        shift += 7;
  214a19:	48 83 c5 07          	add    rbp,0x7
            try self.readNoEof(result[0..]);
  214a1d:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  214a22:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  214a27:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  214a2e:	00 00 
            return self.readFn(self, buffer);
  214a30:	4c 89 e7             	mov    rdi,r12
  214a33:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  214a38:	4c 89 ea             	mov    rdx,r13
  214a3b:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  214a3f:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  214a44:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  214a49:	66 85 c0             	test   ax,ax
  214a4c:	74 93                	je     2149e1 <getLineNumberInfo+0x1421>
  214a4e:	e9 1d 08 00 00       	jmp    215270 <getLineNumberInfo+0x1cb0>
            try self.readNoEof(result[0..]);
  214a53:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  214a58:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  214a5d:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  214a64:	00 00 
            return self.readFn(self, buffer);
  214a66:	4c 89 e7             	mov    rdi,r12
  214a69:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  214a6e:	4c 89 ea             	mov    rdx,r13
  214a71:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  214a75:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  214a7a:	66 85 c0             	test   ax,ax
  214a7d:	0f 85 0f 08 00 00    	jne    215292 <getLineNumberInfo+0x1cd2>
  214a83:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  214a88:	bb 07 00 00 00       	mov    ebx,0x7
  214a8d:	31 ed                	xor    ebp,ebp
            if (amt_read < buf.len) return error.EndOfStream;
  214a8f:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  214a94:	0f 82 c0 07 00 00    	jb     21525a <getLineNumberInfo+0x1c9a>
  214a9a:	48 8d 53 f9          	lea    rdx,[rbx-0x7]
            return result[0];
  214a9e:	0f b6 44 24 48       	movzx  eax,BYTE PTR [rsp+0x48]
        if (@shlWithOverflow(i64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  214aa3:	89 c6                	mov    esi,eax
  214aa5:	83 e6 7f             	and    esi,0x7f
  214aa8:	83 e2 3f             	and    edx,0x3f
  214aab:	c4 e2 e9 f7 ce       	shlx   rcx,rsi,rdx
  214ab0:	c4 e2 ea f7 d1       	sarx   rdx,rcx,rdx
  214ab5:	48 39 f2             	cmp    rdx,rsi
  214ab8:	0f 85 d0 07 00 00    	jne    21528e <getLineNumberInfo+0x1cce>
        result |= operand;
  214abe:	48 09 cd             	or     rbp,rcx
        if ((byte & 0b10000000) == 0) {
  214ac1:	84 c0                	test   al,al
  214ac3:	0f 89 77 04 00 00    	jns    214f40 <getLineNumberInfo+0x1980>
            try self.readNoEof(result[0..]);
  214ac9:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  214ace:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  214ad3:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  214ada:	00 00 
            return self.readFn(self, buffer);
  214adc:	4c 89 e7             	mov    rdi,r12
  214adf:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  214ae4:	4c 89 ea             	mov    rdx,r13
  214ae7:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  214aeb:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  214af0:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  214af5:	48 83 c3 07          	add    rbx,0x7
  214af9:	66 85 c0             	test   ax,ax
  214afc:	74 91                	je     214a8f <getLineNumberInfo+0x14cf>
  214afe:	e9 8f 07 00 00       	jmp    215292 <getLineNumberInfo+0x1cd2>
            try self.readNoEof(result[0..]);
  214b03:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  214b08:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  214b0d:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  214b14:	00 00 
            return self.readFn(self, buffer);
  214b16:	4c 89 e7             	mov    rdi,r12
  214b19:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  214b1e:	4c 89 ea             	mov    rdx,r13
  214b21:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  214b25:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  214b2a:	66 85 c0             	test   ax,ax
  214b2d:	0f 85 81 07 00 00    	jne    2152b4 <getLineNumberInfo+0x1cf4>
  214b33:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  214b38:	31 db                	xor    ebx,ebx
  214b3a:	31 ed                	xor    ebp,ebp
            if (amt_read < buf.len) return error.EndOfStream;
  214b3c:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  214b41:	0f 82 19 07 00 00    	jb     215260 <getLineNumberInfo+0x1ca0>
            return result[0];
  214b47:	0f b6 44 24 48       	movzx  eax,BYTE PTR [rsp+0x48]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  214b4c:	89 c2                	mov    edx,eax
  214b4e:	83 e2 7f             	and    edx,0x7f
  214b51:	89 ee                	mov    esi,ebp
  214b53:	83 e6 3f             	and    esi,0x3f
  214b56:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  214b5b:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  214b60:	48 39 d6             	cmp    rsi,rdx
  214b63:	0f 85 47 07 00 00    	jne    2152b0 <getLineNumberInfo+0x1cf0>
        result |= operand;
  214b69:	48 09 cb             	or     rbx,rcx
        if ((byte & 0b10000000) == 0) return result;
  214b6c:	84 c0                	test   al,al
  214b6e:	0f 89 f2 03 00 00    	jns    214f66 <getLineNumberInfo+0x19a6>
        shift += 7;
  214b74:	48 83 c5 07          	add    rbp,0x7
            try self.readNoEof(result[0..]);
  214b78:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  214b7d:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  214b82:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  214b89:	00 00 
            return self.readFn(self, buffer);
  214b8b:	4c 89 e7             	mov    rdi,r12
  214b8e:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  214b93:	4c 89 ea             	mov    rdx,r13
  214b96:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  214b9a:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  214b9f:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  214ba4:	66 85 c0             	test   ax,ax
  214ba7:	74 93                	je     214b3c <getLineNumberInfo+0x157c>
  214ba9:	e9 06 07 00 00       	jmp    2152b4 <getLineNumberInfo+0x1cf4>
            try self.readNoEof(result[0..]);
  214bae:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  214bb3:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  214bb8:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  214bbf:	00 00 
            return self.readFn(self, buffer);
  214bc1:	4c 89 e7             	mov    rdi,r12
  214bc4:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  214bc9:	4c 89 ea             	mov    rdx,r13
  214bcc:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  214bd0:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  214bd5:	66 85 c0             	test   ax,ax
  214bd8:	0f 85 f8 06 00 00    	jne    2152d6 <getLineNumberInfo+0x1d16>
  214bde:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  214be3:	31 db                	xor    ebx,ebx
  214be5:	31 ed                	xor    ebp,ebp
            if (amt_read < buf.len) return error.EndOfStream;
  214be7:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  214bec:	0f 82 74 06 00 00    	jb     215266 <getLineNumberInfo+0x1ca6>
            return result[0];
  214bf2:	0f b6 44 24 48       	movzx  eax,BYTE PTR [rsp+0x48]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  214bf7:	89 c2                	mov    edx,eax
  214bf9:	83 e2 7f             	and    edx,0x7f
  214bfc:	89 ee                	mov    esi,ebp
  214bfe:	83 e6 3f             	and    esi,0x3f
  214c01:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  214c06:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  214c0b:	48 39 d6             	cmp    rsi,rdx
  214c0e:	0f 85 be 06 00 00    	jne    2152d2 <getLineNumberInfo+0x1d12>
        result |= operand;
  214c14:	48 09 cb             	or     rbx,rcx
        if ((byte & 0b10000000) == 0) return result;
  214c17:	84 c0                	test   al,al
  214c19:	0f 89 54 03 00 00    	jns    214f73 <getLineNumberInfo+0x19b3>
        shift += 7;
  214c1f:	48 83 c5 07          	add    rbp,0x7
            try self.readNoEof(result[0..]);
  214c23:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  214c28:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  214c2d:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  214c34:	00 00 
            return self.readFn(self, buffer);
  214c36:	4c 89 e7             	mov    rdi,r12
  214c39:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  214c3e:	4c 89 ea             	mov    rdx,r13
  214c41:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  214c45:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  214c4a:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  214c4f:	66 85 c0             	test   ax,ax
  214c52:	74 93                	je     214be7 <getLineNumberInfo+0x1627>
  214c54:	e9 7d 06 00 00       	jmp    2152d6 <getLineNumberInfo+0x1d16>
                        prog.is_stmt = !prog.is_stmt;
  214c59:	8a 84 24 00 01 00 00 	mov    al,BYTE PTR [rsp+0x100]
  214c60:	f6 d0                	not    al
  214c62:	24 01                	and    al,0x1
  214c64:	88 84 24 00 01 00 00 	mov    BYTE PTR [rsp+0x100],al
  214c6b:	e9 04 fc ff ff       	jmp    214874 <getLineNumberInfo+0x12b4>
                        prog.basic_block = true;
  214c70:	c6 84 24 01 01 00 00 	mov    BYTE PTR [rsp+0x101],0x1
  214c77:	01 
  214c78:	e9 f7 fb ff ff       	jmp    214874 <getLineNumberInfo+0x12b4>
                        const inc_addr = minimum_instruction_length * ((255 - opcode_base) / line_range);
  214c7d:	0f b6 84 24 a0 00 00 	movzx  eax,BYTE PTR [rsp+0xa0]
  214c84:	00 
  214c85:	f6 74 24 5f          	div    BYTE PTR [rsp+0x5f]
  214c89:	41 f6 e7             	mul    r15b
                        prog.address += inc_addr;
  214c8c:	0f b6 c0             	movzx  eax,al
  214c8f:	eb 68                	jmp    214cf9 <getLineNumberInfo+0x1739>
                        const arg = try in_stream.readInt(st.elf.endian, u16);
  214c91:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
  214c96:	8a 58 12             	mov    bl,BYTE PTR [rax+0x12]
            try self.readNoEof(bytes[0..]);
  214c99:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  214c9e:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  214ca3:	48 c7 44 24 10 02 00 	mov    QWORD PTR [rsp+0x10],0x2
  214caa:	00 00 
            return self.readFn(self, buffer);
  214cac:	4c 89 e7             	mov    rdi,r12
  214caf:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  214cb4:	4c 89 ea             	mov    rdx,r13
  214cb7:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  214cbb:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  214cc0:	66 85 c0             	test   ax,ax
  214cc3:	0f 85 df 07 00 00    	jne    2154a8 <getLineNumberInfo+0x1ee8>
  214cc9:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
            if (amt_read < buf.len) return error.EndOfStream;
  214cce:	48 3b 44 24 10       	cmp    rax,QWORD PTR [rsp+0x10]
  214cd3:	0f 82 cb 07 00 00    	jb     2154a4 <getLineNumberInfo+0x1ee4>
  214cd9:	0f b6 44 24 48       	movzx  eax,BYTE PTR [rsp+0x48]
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  214cde:	0f b6 4c 24 49       	movzx  ecx,BYTE PTR [rsp+0x49]
  214ce3:	89 ca                	mov    edx,ecx
  214ce5:	c1 e2 08             	shl    edx,0x8
  214ce8:	09 c2                	or     edx,eax
                result = (result << 8) | b;
  214cea:	c1 e0 08             	shl    eax,0x8
  214ced:	09 c8                	or     eax,ecx
    switch (endian) {
  214cef:	f6 c3 01             	test   bl,0x1
  214cf2:	66 0f 45 c2          	cmovne ax,dx
                        prog.address += arg;
  214cf6:	0f b7 c0             	movzx  eax,ax
  214cf9:	48 01 84 24 e0 00 00 	add    QWORD PTR [rsp+0xe0],rax
  214d00:	00 
  214d01:	e9 6e fb ff ff       	jmp    214874 <getLineNumberInfo+0x12b4>
                        const addr = try in_stream.readInt(st.elf.endian, usize);
  214d06:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
  214d0b:	8a 58 12             	mov    bl,BYTE PTR [rax+0x12]
            try self.readNoEof(bytes[0..]);
  214d0e:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  214d13:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  214d18:	48 c7 44 24 10 08 00 	mov    QWORD PTR [rsp+0x10],0x8
  214d1f:	00 00 
            return self.readFn(self, buffer);
  214d21:	4c 89 e7             	mov    rdi,r12
  214d24:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  214d29:	4c 89 ea             	mov    rdx,r13
  214d2c:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  214d30:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  214d35:	66 85 c0             	test   ax,ax
  214d38:	0f 85 d0 07 00 00    	jne    21550e <getLineNumberInfo+0x1f4e>
  214d3e:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
            if (amt_read < buf.len) return error.EndOfStream;
  214d43:	48 3b 44 24 10       	cmp    rax,QWORD PTR [rsp+0x10]
  214d48:	0f 82 bc 07 00 00    	jb     21550a <getLineNumberInfo+0x1f4a>
  214d4e:	0f b6 44 24 48       	movzx  eax,BYTE PTR [rsp+0x48]
  214d53:	0f b6 4c 24 49       	movzx  ecx,BYTE PTR [rsp+0x49]
  214d58:	f6 c3 01             	test   bl,0x1
  214d5b:	0f 84 72 01 00 00    	je     214ed3 <getLineNumberInfo+0x1913>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  214d61:	48 c1 e1 08          	shl    rcx,0x8
  214d65:	48 09 c1             	or     rcx,rax
  214d68:	0f b6 44 24 4a       	movzx  eax,BYTE PTR [rsp+0x4a]
  214d6d:	48 c1 e0 10          	shl    rax,0x10
  214d71:	48 09 c8             	or     rax,rcx
  214d74:	0f b6 4c 24 4b       	movzx  ecx,BYTE PTR [rsp+0x4b]
  214d79:	48 c1 e1 18          	shl    rcx,0x18
  214d7d:	48 09 c1             	or     rcx,rax
  214d80:	0f b6 44 24 4c       	movzx  eax,BYTE PTR [rsp+0x4c]
  214d85:	48 c1 e0 20          	shl    rax,0x20
  214d89:	48 09 c8             	or     rax,rcx
  214d8c:	0f b6 4c 24 4d       	movzx  ecx,BYTE PTR [rsp+0x4d]
  214d91:	48 c1 e1 28          	shl    rcx,0x28
  214d95:	48 09 c1             	or     rcx,rax
  214d98:	0f b6 54 24 4e       	movzx  edx,BYTE PTR [rsp+0x4e]
  214d9d:	48 c1 e2 30          	shl    rdx,0x30
  214da1:	0f b6 44 24 4f       	movzx  eax,BYTE PTR [rsp+0x4f]
  214da6:	48 c1 e0 38          	shl    rax,0x38
  214daa:	48 09 d0             	or     rax,rdx
  214dad:	48 09 c8             	or     rax,rcx
                        prog.address = addr;
  214db0:	48 89 84 24 e0 00 00 	mov    QWORD PTR [rsp+0xe0],rax
  214db7:	00 
  214db8:	e9 b7 fa ff ff       	jmp    214874 <getLineNumberInfo+0x12b4>
  214dbd:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
            var in_file_stream = io.FileInStream.init(&self.self_exe_file);
  214dc2:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  214dc7:	48 8d 0d 22 ad ff ff 	lea    rcx,[rip+0xffffffffffffad22]        # 20faf0 <FileInStream_readFn>
  214dce:	48 89 4c 24 10       	mov    QWORD PTR [rsp+0x10],rcx
  214dd3:	48 8b b0 a0 00 00 00 	mov    rsi,QWORD PTR [rax+0xa0]
            return readStringRaw(self.allocator(), in_stream);
  214dda:	4c 89 e7             	mov    rdi,r12
  214ddd:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  214de2:	e8 89 e3 ff ff       	call   213170 <readStringRaw>
  214de7:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  214dec:	48 8d 4c 24 22       	lea    rcx,[rsp+0x22]
  214df1:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  214df5:	c5 f8 29 84 24 b0 01 	vmovaps XMMWORD PTR [rsp+0x1b0],xmm0
  214dfc:	00 00 
  214dfe:	48 8b 49 0e          	mov    rcx,QWORD PTR [rcx+0xe]
  214e02:	48 89 8c 24 be 01 00 	mov    QWORD PTR [rsp+0x1be],rcx
  214e09:	00 
                        const file_name = try st.readString();
  214e0a:	66 85 c0             	test   ax,ax
  214e0d:	0f 85 b3 06 00 00    	jne    2154c6 <getLineNumberInfo+0x1f06>
  214e13:	48 8d 84 24 b6 01 00 	lea    rax,[rsp+0x1b6]
  214e1a:	00 
  214e1b:	c5 fa 6f 00          	vmovdqu xmm0,XMMWORD PTR [rax]
  214e1f:	c5 f9 7f 84 24 d0 01 	vmovdqa XMMWORD PTR [rsp+0x1d0],xmm0
  214e26:	00 00 
            try self.readNoEof(result[0..]);
  214e28:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  214e2d:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  214e32:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  214e39:	00 00 
            return self.readFn(self, buffer);
  214e3b:	4c 89 e7             	mov    rdi,r12
  214e3e:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  214e43:	4c 89 ea             	mov    rdx,r13
  214e46:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  214e4a:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  214e4f:	66 85 c0             	test   ax,ax
  214e52:	0f 85 a6 04 00 00    	jne    2152fe <getLineNumberInfo+0x1d3e>
  214e58:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  214e5d:	31 ed                	xor    ebp,ebp
  214e5f:	31 db                	xor    ebx,ebx
            if (amt_read < buf.len) return error.EndOfStream;
  214e61:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  214e66:	0f 82 88 04 00 00    	jb     2152f4 <getLineNumberInfo+0x1d34>
            return result[0];
  214e6c:	0f b6 44 24 48       	movzx  eax,BYTE PTR [rsp+0x48]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  214e71:	89 c2                	mov    edx,eax
  214e73:	83 e2 7f             	and    edx,0x7f
  214e76:	89 de                	mov    esi,ebx
  214e78:	83 e6 3f             	and    esi,0x3f
  214e7b:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  214e80:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  214e85:	48 39 d6             	cmp    rsi,rdx
  214e88:	0f 85 6c 04 00 00    	jne    2152fa <getLineNumberInfo+0x1d3a>
        result |= operand;
  214e8e:	48 09 cd             	or     rbp,rcx
        if ((byte & 0b10000000) == 0) return result;
  214e91:	84 c0                	test   al,al
  214e93:	0f 89 e7 00 00 00    	jns    214f80 <getLineNumberInfo+0x19c0>
        shift += 7;
  214e99:	48 83 c3 07          	add    rbx,0x7
            try self.readNoEof(result[0..]);
  214e9d:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  214ea2:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  214ea7:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  214eae:	00 00 
            return self.readFn(self, buffer);
  214eb0:	4c 89 e7             	mov    rdi,r12
  214eb3:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  214eb8:	4c 89 ea             	mov    rdx,r13
  214ebb:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  214ebf:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  214ec4:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  214ec9:	66 85 c0             	test   ax,ax
  214ecc:	74 93                	je     214e61 <getLineNumberInfo+0x18a1>
  214ece:	e9 2b 04 00 00       	jmp    2152fe <getLineNumberInfo+0x1d3e>
                result = (result << 8) | b;
  214ed3:	48 c1 e0 08          	shl    rax,0x8
  214ed7:	48 09 c8             	or     rax,rcx
  214eda:	48 c1 e0 08          	shl    rax,0x8
  214ede:	0f b6 4c 24 4a       	movzx  ecx,BYTE PTR [rsp+0x4a]
  214ee3:	48 09 c1             	or     rcx,rax
  214ee6:	48 c1 e1 08          	shl    rcx,0x8
  214eea:	0f b6 44 24 4b       	movzx  eax,BYTE PTR [rsp+0x4b]
  214eef:	48 09 c8             	or     rax,rcx
  214ef2:	48 c1 e0 08          	shl    rax,0x8
  214ef6:	0f b6 4c 24 4c       	movzx  ecx,BYTE PTR [rsp+0x4c]
  214efb:	48 09 c1             	or     rcx,rax
  214efe:	48 c1 e1 08          	shl    rcx,0x8
  214f02:	0f b6 44 24 4d       	movzx  eax,BYTE PTR [rsp+0x4d]
  214f07:	48 09 c8             	or     rax,rcx
  214f0a:	48 c1 e0 08          	shl    rax,0x8
  214f0e:	0f b6 4c 24 4e       	movzx  ecx,BYTE PTR [rsp+0x4e]
  214f13:	48 09 c1             	or     rcx,rax
  214f16:	48 c1 e1 08          	shl    rcx,0x8
  214f1a:	0f b6 44 24 4f       	movzx  eax,BYTE PTR [rsp+0x4f]
  214f1f:	48 09 c8             	or     rax,rcx
                        prog.address = addr;
  214f22:	48 89 84 24 e0 00 00 	mov    QWORD PTR [rsp+0xe0],rax
  214f29:	00 
  214f2a:	e9 45 f9 ff ff       	jmp    214874 <getLineNumberInfo+0x12b4>
                        prog.address += arg * minimum_instruction_length;
  214f2f:	49 0f af df          	imul   rbx,r15
  214f33:	48 01 9c 24 e0 00 00 	add    QWORD PTR [rsp+0xe0],rbx
  214f3a:	00 
  214f3b:	e9 34 f9 ff ff       	jmp    214874 <getLineNumberInfo+0x12b4>
            if (shift < @sizeOf(i64) * 8 and (byte & 0b01000000) != 0) result |= -(i64(1) << @intCast(u6, shift));
  214f40:	48 83 fb 3f          	cmp    rbx,0x3f
  214f44:	77 13                	ja     214f59 <getLineNumberInfo+0x1999>
  214f46:	24 40                	and    al,0x40
  214f48:	74 0f                	je     214f59 <getLineNumberInfo+0x1999>
  214f4a:	48 c7 c0 ff ff ff ff 	mov    rax,0xffffffffffffffff
  214f51:	c4 e2 e1 f7 c0       	shlx   rax,rax,rbx
  214f56:	48 09 c5             	or     rbp,rax
                        prog.line += arg;
  214f59:	48 01 ac 24 f0 00 00 	add    QWORD PTR [rsp+0xf0],rbp
  214f60:	00 
  214f61:	e9 0e f9 ff ff       	jmp    214874 <getLineNumberInfo+0x12b4>
                        prog.file = arg;
  214f66:	48 89 9c 24 e8 00 00 	mov    QWORD PTR [rsp+0xe8],rbx
  214f6d:	00 
  214f6e:	e9 01 f9 ff ff       	jmp    214874 <getLineNumberInfo+0x12b4>
                        prog.column = arg;
  214f73:	48 89 9c 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],rbx
  214f7a:	00 
  214f7b:	e9 f4 f8 ff ff       	jmp    214874 <getLineNumberInfo+0x12b4>
            try self.readNoEof(result[0..]);
  214f80:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  214f85:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  214f8a:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  214f91:	00 00 
            return self.readFn(self, buffer);
  214f93:	4c 89 e7             	mov    rdi,r12
  214f96:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  214f9b:	4c 89 ea             	mov    rdx,r13
  214f9e:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  214fa2:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  214fa7:	66 85 c0             	test   ax,ax
  214faa:	0f 85 e0 03 00 00    	jne    215390 <getLineNumberInfo+0x1dd0>
  214fb0:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  214fb5:	45 31 f6             	xor    r14d,r14d
  214fb8:	31 db                	xor    ebx,ebx
            if (amt_read < buf.len) return error.EndOfStream;
  214fba:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  214fbf:	0f 82 c1 03 00 00    	jb     215386 <getLineNumberInfo+0x1dc6>
            return result[0];
  214fc5:	0f b6 44 24 48       	movzx  eax,BYTE PTR [rsp+0x48]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  214fca:	89 c2                	mov    edx,eax
  214fcc:	83 e2 7f             	and    edx,0x7f
  214fcf:	89 de                	mov    esi,ebx
  214fd1:	83 e6 3f             	and    esi,0x3f
  214fd4:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  214fd9:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  214fde:	48 39 d6             	cmp    rsi,rdx
  214fe1:	0f 85 a5 03 00 00    	jne    21538c <getLineNumberInfo+0x1dcc>
        result |= operand;
  214fe7:	49 09 ce             	or     r14,rcx
        if ((byte & 0b10000000) == 0) return result;
  214fea:	84 c0                	test   al,al
  214fec:	79 3a                	jns    215028 <getLineNumberInfo+0x1a68>
        shift += 7;
  214fee:	48 83 c3 07          	add    rbx,0x7
            try self.readNoEof(result[0..]);
  214ff2:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  214ff7:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  214ffc:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  215003:	00 00 
            return self.readFn(self, buffer);
  215005:	4c 89 e7             	mov    rdi,r12
  215008:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  21500d:	4c 89 ea             	mov    rdx,r13
  215010:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  215014:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  215019:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  21501e:	66 85 c0             	test   ax,ax
  215021:	74 97                	je     214fba <getLineNumberInfo+0x19fa>
  215023:	e9 68 03 00 00       	jmp    215390 <getLineNumberInfo+0x1dd0>
            try self.readNoEof(result[0..]);
  215028:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  21502d:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  215032:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  215039:	00 00 
            return self.readFn(self, buffer);
  21503b:	4c 89 e7             	mov    rdi,r12
  21503e:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  215043:	4c 89 ea             	mov    rdx,r13
  215046:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  21504a:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  21504f:	66 85 c0             	test   ax,ax
  215052:	0f 85 de 04 00 00    	jne    215536 <getLineNumberInfo+0x1f76>
  215058:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  21505d:	31 c0                	xor    eax,eax
  21505f:	48 89 44 24 68       	mov    QWORD PTR [rsp+0x68],rax
  215064:	31 db                	xor    ebx,ebx
            if (amt_read < buf.len) return error.EndOfStream;
  215066:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  21506b:	0f 82 bb 04 00 00    	jb     21552c <getLineNumberInfo+0x1f6c>
            return result[0];
  215071:	0f b6 44 24 48       	movzx  eax,BYTE PTR [rsp+0x48]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  215076:	89 c2                	mov    edx,eax
  215078:	83 e2 7f             	and    edx,0x7f
  21507b:	89 de                	mov    esi,ebx
  21507d:	83 e6 3f             	and    esi,0x3f
  215080:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  215085:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  21508a:	48 39 d6             	cmp    rsi,rdx
  21508d:	0f 85 9f 04 00 00    	jne    215532 <getLineNumberInfo+0x1f72>
        result |= operand;
  215093:	48 09 4c 24 68       	or     QWORD PTR [rsp+0x68],rcx
        if ((byte & 0b10000000) == 0) return result;
  215098:	84 c0                	test   al,al
  21509a:	79 3a                	jns    2150d6 <getLineNumberInfo+0x1b16>
        shift += 7;
  21509c:	48 83 c3 07          	add    rbx,0x7
            try self.readNoEof(result[0..]);
  2150a0:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  2150a5:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  2150aa:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  2150b1:	00 00 
            return self.readFn(self, buffer);
  2150b3:	4c 89 e7             	mov    rdi,r12
  2150b6:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  2150bb:	4c 89 ea             	mov    rdx,r13
  2150be:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  2150c2:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  2150c7:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  2150cc:	66 85 c0             	test   ax,ax
  2150cf:	74 95                	je     215066 <getLineNumberInfo+0x1aa6>
  2150d1:	e9 60 04 00 00       	jmp    215536 <getLineNumberInfo+0x1f76>
                        try file_entries.append(FileEntry{
  2150d6:	c5 f9 6f 84 24 d0 01 	vmovdqa xmm0,XMMWORD PTR [rsp+0x1d0]
  2150dd:	00 00 
  2150df:	c5 f9 7f 84 24 f0 01 	vmovdqa XMMWORD PTR [rsp+0x1f0],xmm0
  2150e6:	00 00 
            const new_length = self.len + 1;
  2150e8:	48 8b 9c 24 80 00 00 	mov    rbx,QWORD PTR [rsp+0x80]
  2150ef:	00 
            var better_capacity = self.items.len;
  2150f0:	48 8b 4c 24 78       	mov    rcx,QWORD PTR [rsp+0x78]
            if (better_capacity >= new_capacity) return;
  2150f5:	48 39 d9             	cmp    rcx,rbx
  2150f8:	76 05                	jbe    2150ff <getLineNumberInfo+0x1b3f>
            const result = &self.items[self.len];
  2150fa:	48 89 d8             	mov    rax,rbx
  2150fd:	eb 4c                	jmp    21514b <getLineNumberInfo+0x1b8b>
                better_capacity += better_capacity / 2 + 8;
  2150ff:	48 89 c8             	mov    rax,rcx
  215102:	48 d1 e8             	shr    rax,1
  215105:	48 01 c1             	add    rcx,rax
  215108:	48 83 c1 08          	add    rcx,0x8
                if (better_capacity >= new_capacity) break;
  21510c:	48 39 d9             	cmp    rcx,rbx
  21510f:	76 ee                	jbe    2150ff <getLineNumberInfo+0x1b3f>
            self.items = try self.allocator.alignedRealloc(T, A, self.items, better_capacity);
  215111:	48 8b b4 24 88 00 00 	mov    rsi,QWORD PTR [rsp+0x88]
  215118:	00 
  215119:	4c 89 e7             	mov    rdi,r12
  21511c:	48 8d 54 24 70       	lea    rdx,[rsp+0x70]
  215121:	e8 1a 0f 00 00       	call   216040 <Allocator_alignedRealloc.76>
  215126:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  21512b:	66 85 c0             	test   ax,ax
  21512e:	0f 85 50 04 00 00    	jne    215584 <getLineNumberInfo+0x1fc4>
  215134:	48 8d 44 24 28       	lea    rax,[rsp+0x28]
  215139:	c5 fa 6f 00          	vmovdqu xmm0,XMMWORD PTR [rax]
  21513d:	c5 f9 7f 44 24 70    	vmovdqa XMMWORD PTR [rsp+0x70],xmm0
            const result = &self.items[self.len];
  215143:	48 8b 84 24 80 00 00 	mov    rax,QWORD PTR [rsp+0x80]
  21514a:	00 
  21514b:	48 83 c3 01          	add    rbx,0x1
  21514f:	48 8b 4c 24 70       	mov    rcx,QWORD PTR [rsp+0x70]
  215154:	48 8d 04 80          	lea    rax,[rax+rax*4]
            self.len = new_length;
  215158:	48 89 9c 24 80 00 00 	mov    QWORD PTR [rsp+0x80],rbx
  21515f:	00 
            new_item_ptr.* = item;
  215160:	c5 f9 6f 84 24 f0 01 	vmovdqa xmm0,XMMWORD PTR [rsp+0x1f0]
  215167:	00 00 
  215169:	c5 fa 7f 04 c1       	vmovdqu XMMWORD PTR [rcx+rax*8],xmm0
  21516e:	48 89 6c c1 10       	mov    QWORD PTR [rcx+rax*8+0x10],rbp
  215173:	4c 89 74 c1 18       	mov    QWORD PTR [rcx+rax*8+0x18],r14
  215178:	48 8b 54 24 68       	mov    rdx,QWORD PTR [rsp+0x68]
  21517d:	48 89 54 c1 20       	mov    QWORD PTR [rcx+rax*8+0x20],rdx
  215182:	e9 ed f6 ff ff       	jmp    214874 <getLineNumberInfo+0x12b4>
  215187:	c5 fc 10 05 51 06 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffff0651]        # 2057e0 <__unnamed_75+0x10>
  21518e:	ff 
  21518f:	48 8b 04 24          	mov    rax,QWORD PTR [rsp]
  215193:	c5 fc 11 40 10       	vmovups YMMWORD PTR [rax+0x10],ymm0
  215198:	c5 fe 6f 05 30 06 ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffff0630]        # 2057d0 <__unnamed_75>
  21519f:	ff 
  2151a0:	e9 22 e7 ff ff       	jmp    2138c7 <getLineNumberInfo+0x307>
  2151a5:	66 b8 1e 00          	mov    ax,0x1e
  2151a9:	eb 04                	jmp    2151af <getLineNumberInfo+0x1bef>
  2151ab:	66 b8 23 00          	mov    ax,0x23
  2151af:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                const op_size = try readULeb128(in_stream);
  2151b3:	66 89 01             	mov    WORD PTR [rcx],ax
  2151b6:	c5 fe 6f 84 24 4c 06 	vmovdqu ymm0,YMMWORD PTR [rsp+0x64c]
  2151bd:	00 00 
  2151bf:	c5 fc 10 8c 24 5a 06 	vmovups ymm1,YMMWORD PTR [rsp+0x65a]
  2151c6:	00 00 
  2151c8:	e9 1f e8 ff ff       	jmp    2139ec <getLineNumberInfo+0x42c>
  2151cd:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
            try file_entries.append(FileEntry{
  2151d1:	66 89 01             	mov    WORD PTR [rcx],ax
  2151d4:	c5 fc 10 84 24 d6 06 	vmovups ymm0,YMMWORD PTR [rsp+0x6d6]
  2151db:	00 00 
  2151dd:	c5 fc 10 8c 24 e4 06 	vmovups ymm1,YMMWORD PTR [rsp+0x6e4]
  2151e4:	00 00 
  2151e6:	e9 01 e8 ff ff       	jmp    2139ec <getLineNumberInfo+0x42c>
  2151eb:	66 b9 1e 00          	mov    cx,0x1e
  2151ef:	e9 b8 f4 ff ff       	jmp    2146ac <getLineNumberInfo+0x10ec>
  2151f4:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                if (try prog.checkLineMatch()) |info| return info;
  2151f8:	66 89 01             	mov    WORD PTR [rcx],ax
  2151fb:	c5 fc 10 84 24 80 04 	vmovups ymm0,YMMWORD PTR [rsp+0x480]
  215202:	00 00 
  215204:	c5 fc 10 8c 24 8e 04 	vmovups ymm1,YMMWORD PTR [rsp+0x48e]
  21520b:	00 00 
  21520d:	e9 da e7 ff ff       	jmp    2139ec <getLineNumberInfo+0x42c>
  215212:	48 8b 84 24 68 02 00 	mov    rax,QWORD PTR [rsp+0x268]
  215219:	00 
  21521a:	48 89 84 24 08 03 00 	mov    QWORD PTR [rsp+0x308],rax
  215221:	00 
  215222:	c5 fc 10 84 24 48 02 	vmovups ymm0,YMMWORD PTR [rsp+0x248]
  215229:	00 00 
  21522b:	c5 fc 11 84 24 e8 02 	vmovups YMMWORD PTR [rsp+0x2e8],ymm0
  215232:	00 00 
  215234:	48 8b 04 24          	mov    rax,QWORD PTR [rsp]
  215238:	66 c7 00 00 00       	mov    WORD PTR [rax],0x0
  21523d:	c5 fc 10 84 24 e2 02 	vmovups ymm0,YMMWORD PTR [rsp+0x2e2]
  215244:	00 00 
  215246:	c5 fc 10 8c 24 f0 02 	vmovups ymm1,YMMWORD PTR [rsp+0x2f0]
  21524d:	00 00 
  21524f:	e9 71 f4 ff ff       	jmp    2146c5 <getLineNumberInfo+0x1105>
  215254:	66 b8 1e 00          	mov    ax,0x1e
  215258:	eb 16                	jmp    215270 <getLineNumberInfo+0x1cb0>
  21525a:	66 b8 1e 00          	mov    ax,0x1e
  21525e:	eb 32                	jmp    215292 <getLineNumberInfo+0x1cd2>
  215260:	66 b8 1e 00          	mov    ax,0x1e
  215264:	eb 4e                	jmp    2152b4 <getLineNumberInfo+0x1cf4>
  215266:	66 b8 1e 00          	mov    ax,0x1e
  21526a:	eb 6a                	jmp    2152d6 <getLineNumberInfo+0x1d16>
  21526c:	66 b8 23 00          	mov    ax,0x23
  215270:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                        const arg = try readULeb128(in_stream);
  215274:	66 89 01             	mov    WORD PTR [rcx],ax
  215277:	c5 fc 10 84 24 f6 03 	vmovups ymm0,YMMWORD PTR [rsp+0x3f6]
  21527e:	00 00 
  215280:	c5 fc 10 8c 24 04 04 	vmovups ymm1,YMMWORD PTR [rsp+0x404]
  215287:	00 00 
  215289:	e9 5e e7 ff ff       	jmp    2139ec <getLineNumberInfo+0x42c>
  21528e:	66 b8 23 00          	mov    ax,0x23
  215292:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                        const arg = try readILeb128(in_stream);
  215296:	66 89 01             	mov    WORD PTR [rcx],ax
  215299:	c5 fc 10 84 24 c8 03 	vmovups ymm0,YMMWORD PTR [rsp+0x3c8]
  2152a0:	00 00 
  2152a2:	c5 fc 10 8c 24 d6 03 	vmovups ymm1,YMMWORD PTR [rsp+0x3d6]
  2152a9:	00 00 
  2152ab:	e9 3c e7 ff ff       	jmp    2139ec <getLineNumberInfo+0x42c>
  2152b0:	66 b8 23 00          	mov    ax,0x23
  2152b4:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                        const arg = try readULeb128(in_stream);
  2152b8:	66 89 01             	mov    WORD PTR [rcx],ax
  2152bb:	c5 fc 10 84 24 9a 03 	vmovups ymm0,YMMWORD PTR [rsp+0x39a]
  2152c2:	00 00 
  2152c4:	c5 fc 10 8c 24 a8 03 	vmovups ymm1,YMMWORD PTR [rsp+0x3a8]
  2152cb:	00 00 
  2152cd:	e9 1a e7 ff ff       	jmp    2139ec <getLineNumberInfo+0x42c>
  2152d2:	66 b8 23 00          	mov    ax,0x23
  2152d6:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                        const arg = try readULeb128(in_stream);
  2152da:	66 89 01             	mov    WORD PTR [rcx],ax
  2152dd:	c5 fc 10 84 24 6c 03 	vmovups ymm0,YMMWORD PTR [rsp+0x36c]
  2152e4:	00 00 
  2152e6:	c5 fc 10 8c 24 7a 03 	vmovups ymm1,YMMWORD PTR [rsp+0x37a]
  2152ed:	00 00 
  2152ef:	e9 f8 e6 ff ff       	jmp    2139ec <getLineNumberInfo+0x42c>
  2152f4:	66 b8 1e 00          	mov    ax,0x1e
  2152f8:	eb 04                	jmp    2152fe <getLineNumberInfo+0x1d3e>
  2152fa:	66 b8 23 00          	mov    ax,0x23
  2152fe:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                        const dir_index = try readULeb128(in_stream);
  215302:	66 89 01             	mov    WORD PTR [rcx],ax
  215305:	c5 fc 10 84 24 38 05 	vmovups ymm0,YMMWORD PTR [rsp+0x538]
  21530c:	00 00 
  21530e:	c5 fc 10 8c 24 46 05 	vmovups ymm1,YMMWORD PTR [rsp+0x546]
  215315:	00 00 
  215317:	e9 d0 e6 ff ff       	jmp    2139ec <getLineNumberInfo+0x42c>
  21531c:	66 b8 1e 00          	mov    ax,0x1e
  215320:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                sub_op = try in_stream.readByte();
  215324:	66 89 01             	mov    WORD PTR [rcx],ax
  215327:	c5 fe 6f 84 24 1e 06 	vmovdqu ymm0,YMMWORD PTR [rsp+0x61e]
  21532e:	00 00 
  215330:	c5 fc 10 8c 24 2c 06 	vmovups ymm1,YMMWORD PTR [rsp+0x62c]
  215337:	00 00 
  215339:	e9 ae e6 ff ff       	jmp    2139ec <getLineNumberInfo+0x42c>
                        prog.end_sequence = true;
  21533e:	c6 84 24 02 01 00 00 	mov    BYTE PTR [rsp+0x102],0x1
  215345:	01 
  215346:	48 8d bc 24 78 02 00 	lea    rdi,[rsp+0x278]
  21534d:	00 
  21534e:	48 8d b4 24 e0 00 00 	lea    rsi,[rsp+0xe0]
  215355:	00 
                        if (try prog.checkLineMatch()) |info| return info;
  215356:	e8 a5 08 00 00       	call   215c00 <LineNumberProgram_checkLineMatch>
  21535b:	0f b7 84 24 78 02 00 	movzx  eax,WORD PTR [rsp+0x278]
  215362:	00 
  215363:	66 85 c0             	test   ax,ax
  215366:	74 46                	je     2153ae <getLineNumberInfo+0x1dee>
  215368:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
  21536c:	66 89 01             	mov    WORD PTR [rcx],ax
  21536f:	c5 fc 10 84 24 c2 05 	vmovups ymm0,YMMWORD PTR [rsp+0x5c2]
  215376:	00 00 
  215378:	c5 fc 10 8c 24 d0 05 	vmovups ymm1,YMMWORD PTR [rsp+0x5d0]
  21537f:	00 00 
  215381:	e9 66 e6 ff ff       	jmp    2139ec <getLineNumberInfo+0x42c>
  215386:	66 b8 1e 00          	mov    ax,0x1e
  21538a:	eb 04                	jmp    215390 <getLineNumberInfo+0x1dd0>
  21538c:	66 b8 23 00          	mov    ax,0x23
  215390:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                        const mtime = try readULeb128(in_stream);
  215394:	66 89 01             	mov    WORD PTR [rcx],ax
  215397:	c5 fc 10 84 24 0a 05 	vmovups ymm0,YMMWORD PTR [rsp+0x50a]
  21539e:	00 00 
  2153a0:	c5 fc 10 8c 24 18 05 	vmovups ymm1,YMMWORD PTR [rsp+0x518]
  2153a7:	00 00 
  2153a9:	e9 3e e6 ff ff       	jmp    2139ec <getLineNumberInfo+0x42c>
                        if (try prog.checkLineMatch()) |info| return info;
  2153ae:	80 bc 24 a8 02 00 00 	cmp    BYTE PTR [rsp+0x2a8],0x1
  2153b5:	01 
  2153b6:	0f 85 f2 e4 ff ff    	jne    2138ae <getLineNumberInfo+0x2ee>
  2153bc:	48 8b 84 24 a0 02 00 	mov    rax,QWORD PTR [rsp+0x2a0]
  2153c3:	00 
  2153c4:	48 89 84 24 36 03 00 	mov    QWORD PTR [rsp+0x336],rax
  2153cb:	00 
  2153cc:	c5 fc 10 84 24 80 02 	vmovups ymm0,YMMWORD PTR [rsp+0x280]
  2153d3:	00 00 
  2153d5:	c5 fc 11 84 24 16 03 	vmovups YMMWORD PTR [rsp+0x316],ymm0
  2153dc:	00 00 
  2153de:	48 8b 04 24          	mov    rax,QWORD PTR [rsp]
  2153e2:	66 c7 00 00 00       	mov    WORD PTR [rax],0x0
  2153e7:	c5 fc 10 84 24 10 03 	vmovups ymm0,YMMWORD PTR [rsp+0x310]
  2153ee:	00 00 
  2153f0:	c5 fc 10 8c 24 1e 03 	vmovups ymm1,YMMWORD PTR [rsp+0x31e]
  2153f7:	00 00 
  2153f9:	e9 c7 f2 ff ff       	jmp    2146c5 <getLineNumberInfo+0x1105>
  2153fe:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                        if (try prog.checkLineMatch()) |info| return info;
  215402:	66 89 01             	mov    WORD PTR [rcx],ax
  215405:	c5 fc 10 84 24 24 04 	vmovups ymm0,YMMWORD PTR [rsp+0x424]
  21540c:	00 00 
  21540e:	c5 fc 10 8c 24 32 04 	vmovups ymm1,YMMWORD PTR [rsp+0x432]
  215415:	00 00 
  215417:	e9 d0 e5 ff ff       	jmp    2139ec <getLineNumberInfo+0x42c>
  21541c:	48 8b 84 24 30 02 00 	mov    rax,QWORD PTR [rsp+0x230]
  215423:	00 
  215424:	48 89 84 24 da 02 00 	mov    QWORD PTR [rsp+0x2da],rax
  21542b:	00 
  21542c:	c5 fc 10 84 24 10 02 	vmovups ymm0,YMMWORD PTR [rsp+0x210]
  215433:	00 00 
  215435:	c5 fc 11 84 24 ba 02 	vmovups YMMWORD PTR [rsp+0x2ba],ymm0
  21543c:	00 00 
  21543e:	48 8b 04 24          	mov    rax,QWORD PTR [rsp]
  215442:	66 c7 00 00 00       	mov    WORD PTR [rax],0x0
  215447:	c5 fc 10 84 24 b4 02 	vmovups ymm0,YMMWORD PTR [rsp+0x2b4]
  21544e:	00 00 
  215450:	c5 fc 10 8c 24 c2 02 	vmovups ymm1,YMMWORD PTR [rsp+0x2c2]
  215457:	00 00 
  215459:	e9 67 f2 ff ff       	jmp    2146c5 <getLineNumberInfo+0x1105>
  21545e:	48 8d 41 ea          	lea    rax,[rcx-0x16]
  215462:	48 83 f8 35          	cmp    rax,0x35
  215466:	77 10                	ja     215478 <getLineNumberInfo+0x1eb8>
  215468:	48 ba 81 00 00 00 00 	movabs rdx,0x20000000000081
  21546f:	00 20 00 
  215472:	48 0f a3 c2          	bt     rdx,rax
  215476:	72 0a                	jb     215482 <getLineNumberInfo+0x1ec2>
  215478:	48 83 f9 06          	cmp    rcx,0x6
  21547c:	0f 85 d2 00 00 00    	jne    215554 <getLineNumberInfo+0x1f94>
  215482:	66 b8 20 00          	mov    ax,0x20
  215486:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                        try in_file.seekForward(len_bytes);
  21548a:	66 89 01             	mov    WORD PTR [rcx],ax
  21548d:	c5 fc 10 84 24 52 04 	vmovups ymm0,YMMWORD PTR [rsp+0x452]
  215494:	00 00 
  215496:	c5 fc 10 8c 24 60 04 	vmovups ymm1,YMMWORD PTR [rsp+0x460]
  21549d:	00 00 
  21549f:	e9 48 e5 ff ff       	jmp    2139ec <getLineNumberInfo+0x42c>
  2154a4:	66 b8 1e 00          	mov    ax,0x1e
  2154a8:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                        const arg = try in_stream.readInt(st.elf.endian, u16);
  2154ac:	66 89 01             	mov    WORD PTR [rcx],ax
  2154af:	c5 fc 10 84 24 3e 03 	vmovups ymm0,YMMWORD PTR [rsp+0x33e]
  2154b6:	00 00 
  2154b8:	c5 fc 10 8c 24 4c 03 	vmovups ymm1,YMMWORD PTR [rsp+0x34c]
  2154bf:	00 00 
  2154c1:	e9 26 e5 ff ff       	jmp    2139ec <getLineNumberInfo+0x42c>
  2154c6:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                        const file_name = try st.readString();
  2154ca:	66 89 01             	mov    WORD PTR [rcx],ax
  2154cd:	c5 fc 10 84 24 66 05 	vmovups ymm0,YMMWORD PTR [rsp+0x566]
  2154d4:	00 00 
  2154d6:	c5 fc 10 8c 24 74 05 	vmovups ymm1,YMMWORD PTR [rsp+0x574]
  2154dd:	00 00 
  2154df:	e9 08 e5 ff ff       	jmp    2139ec <getLineNumberInfo+0x42c>
  2154e4:	48 8d 41 ea          	lea    rax,[rcx-0x16]
  2154e8:	48 83 f8 35          	cmp    rax,0x35
  2154ec:	77 10                	ja     2154fe <getLineNumberInfo+0x1f3e>
  2154ee:	48 ba 81 00 00 00 00 	movabs rdx,0x20000000000081
  2154f5:	00 20 00 
  2154f8:	48 0f a3 c2          	bt     rdx,rax
  2154fc:	72 06                	jb     215504 <getLineNumberInfo+0x1f44>
  2154fe:	48 83 f9 06          	cmp    rcx,0x6
  215502:	75 59                	jne    21555d <getLineNumberInfo+0x1f9d>
  215504:	66 b8 20 00          	mov    ax,0x20
  215508:	eb 57                	jmp    215561 <getLineNumberInfo+0x1fa1>
  21550a:	66 b8 1e 00          	mov    ax,0x1e
  21550e:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                        const addr = try in_stream.readInt(st.elf.endian, usize);
  215512:	66 89 01             	mov    WORD PTR [rcx],ax
  215515:	c5 fe 6f 84 24 94 05 	vmovdqu ymm0,YMMWORD PTR [rsp+0x594]
  21551c:	00 00 
  21551e:	c5 fc 10 8c 24 a2 05 	vmovups ymm1,YMMWORD PTR [rsp+0x5a2]
  215525:	00 00 
  215527:	e9 c0 e4 ff ff       	jmp    2139ec <getLineNumberInfo+0x42c>
  21552c:	66 b8 1e 00          	mov    ax,0x1e
  215530:	eb 04                	jmp    215536 <getLineNumberInfo+0x1f76>
  215532:	66 b8 23 00          	mov    ax,0x23
  215536:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                        const len_bytes = try readULeb128(in_stream);
  21553a:	66 89 01             	mov    WORD PTR [rcx],ax
  21553d:	c5 fc 10 84 24 dc 04 	vmovups ymm0,YMMWORD PTR [rsp+0x4dc]
  215544:	00 00 
  215546:	c5 fc 10 8c 24 ea 04 	vmovups ymm1,YMMWORD PTR [rsp+0x4ea]
  21554d:	00 00 
  21554f:	e9 98 e4 ff ff       	jmp    2139ec <getLineNumberInfo+0x42c>
  215554:	66 b8 02 00          	mov    ax,0x2
  215558:	e9 29 ff ff ff       	jmp    215486 <getLineNumberInfo+0x1ec6>
  21555d:	66 b8 02 00          	mov    ax,0x2
  215561:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                        try in_file.seekForward(fwd_amt);
  215565:	66 89 01             	mov    WORD PTR [rcx],ax
  215568:	c5 fc 10 84 24 f0 05 	vmovups ymm0,YMMWORD PTR [rsp+0x5f0]
  21556f:	00 00 
  215571:	c5 fc 10 8c 24 fe 05 	vmovups ymm1,YMMWORD PTR [rsp+0x5fe]
  215578:	00 00 
  21557a:	e9 6d e4 ff ff       	jmp    2139ec <getLineNumberInfo+0x42c>
            @panic("assertion failure");
  21557f:	e8 9c 37 ff ff       	call   208d20 <panic>
  215584:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                        try file_entries.append(FileEntry{
  215588:	66 89 01             	mov    WORD PTR [rcx],ax
  21558b:	c5 fc 10 84 24 ae 04 	vmovups ymm0,YMMWORD PTR [rsp+0x4ae]
  215592:	00 00 
  215594:	c5 fc 10 8c 24 bc 04 	vmovups ymm1,YMMWORD PTR [rsp+0x4bc]
  21559b:	00 00 
  21559d:	e9 4a e4 ff ff       	jmp    2139ec <getLineNumberInfo+0x42c>
  2155a2:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  2155a9:	1f 84 00 00 00 00 00 

00000000002155b0 <printLineFromFile>:
fn printLineFromFile(out_stream: var, line_info: *const LineInfo) !void {
  2155b0:	55                   	push   rbp
  2155b1:	41 57                	push   r15
  2155b3:	41 56                	push   r14
  2155b5:	41 55                	push   r13
  2155b7:	41 54                	push   r12
  2155b9:	53                   	push   rbx
  2155ba:	48 81 ec 48 30 00 00 	sub    rsp,0x3048
  2155c1:	48 89 f5             	mov    rbp,rsi
  2155c4:	48 89 7c 24 38       	mov    QWORD PTR [rsp+0x38],rdi
    var path_with_null: [posix.PATH_MAX]u8 = undefined;
  2155c9:	48 8d 35 28 04 ff ff 	lea    rsi,[rip+0xffffffffffff0428]        # 2059f8 <__unnamed_76>
  2155d0:	48 8d 7c 24 48       	lea    rdi,[rsp+0x48]
  2155d5:	ba 00 10 00 00       	mov    edx,0x1000
  2155da:	e8 b1 3f 00 00       	call   219590 <memcpy>
    if (file_path.len >= posix.PATH_MAX) return error.NameTooLong;
  2155df:	48 8b 5d 18          	mov    rbx,QWORD PTR [rbp+0x18]
  2155e3:	48 81 fb ff 0f 00 00 	cmp    rbx,0xfff
  2155ea:	76 06                	jbe    2155f2 <printLineFromFile+0x42>
  2155ec:	66 bd 15 00          	mov    bp,0x15
  2155f0:	eb 53                	jmp    215645 <printLineFromFile+0x95>
    for (source) |s, i|
  2155f2:	48 85 db             	test   rbx,rbx
  2155f5:	74 11                	je     215608 <printLineFromFile+0x58>
  2155f7:	48 8b 75 10          	mov    rsi,QWORD PTR [rbp+0x10]
  2155fb:	48 8d 7c 24 48       	lea    rdi,[rsp+0x48]
        dest[i] = s;
  215600:	48 89 da             	mov    rdx,rbx
  215603:	e8 88 3f 00 00       	call   219590 <memcpy>
  215608:	48 89 6c 24 10       	mov    QWORD PTR [rsp+0x10],rbp
    path_with_null[file_path.len] = 0;
  21560d:	c6 44 1c 48 00       	mov    BYTE PTR [rsp+rbx*1+0x48],0x0
  215612:	48 8d 9c 24 48 10 00 	lea    rbx,[rsp+0x1048]
  215619:	00 
  21561a:	48 8d 74 24 48       	lea    rsi,[rsp+0x48]
    return path_with_null;
  21561f:	ba 00 10 00 00       	mov    edx,0x1000
  215624:	48 89 df             	mov    rdi,rbx
  215627:	e8 64 3f 00 00       	call   219590 <memcpy>
  21562c:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
            return openReadC(&path_c);
  215631:	48 89 de             	mov    rsi,rbx
  215634:	e8 87 a1 ff ff       	call   20f7c0 <File_openReadC>
  215639:	48 8b 5c 24 40       	mov    rbx,QWORD PTR [rsp+0x40]
  21563e:	89 dd                	mov    ebp,ebx
    var f = try os.File.openRead(line_info.file_name);
  215640:	66 85 db             	test   bx,bx
  215643:	74 14                	je     215659 <printLineFromFile+0xa9>
  215645:	89 e8                	mov    eax,ebp
  215647:	48 81 c4 48 30 00 00 	add    rsp,0x3048
  21564e:	5b                   	pop    rbx
  21564f:	41 5c                	pop    r12
  215651:	41 5d                	pop    r13
  215653:	41 5e                	pop    r14
  215655:	41 5f                	pop    r15
  215657:	5d                   	pop    rbp
  215658:	c3                   	ret    
  215659:	48 89 d8             	mov    rax,rbx
  21565c:	48 c1 e8 20          	shr    rax,0x20
  215660:	89 44 24 08          	mov    DWORD PTR [rsp+0x8],eax
    var buf: [os.page_size]u8 = undefined;
  215664:	48 8d 35 8d 03 ff ff 	lea    rsi,[rip+0xffffffffffff038d]        # 2059f8 <__unnamed_76>
  21566b:	48 8d ac 24 48 20 00 	lea    rbp,[rsp+0x2048]
  215672:	00 
  215673:	ba 00 10 00 00       	mov    edx,0x1000
  215678:	48 89 ef             	mov    rdi,rbp
  21567b:	e8 10 3f 00 00       	call   219590 <memcpy>
        const amt_read = try f.read(buf[0..]);
  215680:	48 89 6c 24 28       	mov    QWORD PTR [rsp+0x28],rbp
  215685:	48 c7 44 24 30 00 10 	mov    QWORD PTR [rsp+0x30],0x1000
  21568c:	00 00 
  21568e:	48 8d 7c 24 18       	lea    rdi,[rsp+0x18]
  215693:	48 8d 74 24 08       	lea    rsi,[rsp+0x8]
  215698:	48 8d 54 24 28       	lea    rdx,[rsp+0x28]
  21569d:	e8 1e a3 ff ff       	call   20f9c0 <File_read>
  2156a2:	66 83 7c 24 18 00    	cmp    WORD PTR [rsp+0x18],0x0
  2156a8:	48 8b 6c 24 10       	mov    rbp,QWORD PTR [rsp+0x10]
  2156ad:	74 4e                	je     2156fd <printLineFromFile+0x14d>
  2156af:	48 c1 fb 20          	sar    rbx,0x20
  2156b3:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  2156ba:	84 00 00 00 00 00 
    return asm volatile ("syscall"
  2156c0:	b8 03 00 00 00       	mov    eax,0x3
  2156c5:	48 89 df             	mov    rdi,rbx
  2156c8:	0f 05                	syscall 
            switch (err) {
  2156ca:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  2156ce:	74 f0                	je     2156c0 <printLineFromFile+0x110>
            const first = list.first orelse return null;
  2156d0:	48 8b 05 51 b9 00 00 	mov    rax,QWORD PTR [rip+0xb951]        # 221028 <emfile_promise_queue>
  2156d7:	48 85 c0             	test   rax,rax
  2156da:	0f 84 05 02 00 00    	je     2158e5 <printLineFromFile+0x335>
            if (node.prev) |prev_node| {
  2156e0:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  2156e3:	48 85 c9             	test   rcx,rcx
  2156e6:	0f 84 91 01 00 00    	je     21587d <printLineFromFile+0x2cd>
                prev_node.next = node.next;
  2156ec:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  2156f0:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  2156f4:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  2156f8:	e9 8b 01 00 00       	jmp    215888 <printLineFromFile+0x2d8>
  2156fd:	41 bd 01 00 00 00    	mov    r13d,0x1
  215703:	4c 8b 64 24 20       	mov    r12,QWORD PTR [rsp+0x20]
        for (slice) |byte| {
  215708:	4d 85 e4             	test   r12,r12
  21570b:	0f 84 bb 02 00 00    	je     2159cc <printLineFromFile+0x41c>
  215711:	45 31 ff             	xor    r15d,r15d
  215714:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21571b:	00 00 00 00 00 
  215720:	46 0f b6 b4 3c 48 20 	movzx  r14d,BYTE PTR [rsp+r15*1+0x2048]
  215727:	00 00 
            if (line == line_info.line) {
  215729:	4c 3b 6d 00          	cmp    r13,QWORD PTR [rbp+0x0]
  21572d:	75 51                	jne    215780 <printLineFromFile+0x1d0>
  21572f:	44 88 b4 24 48 10 00 	mov    BYTE PTR [rsp+0x1048],r14b
  215736:	00 
            const slice = (*[1]u8)(&byte)[0..];
  215737:	48 8d 84 24 48 10 00 	lea    rax,[rsp+0x1048]
  21573e:	00 
  21573f:	48 89 44 24 48       	mov    QWORD PTR [rsp+0x48],rax
  215744:	48 c7 44 24 50 01 00 	mov    QWORD PTR [rsp+0x50],0x1
  21574b:	00 00 
  21574d:	48 8b 7c 24 38       	mov    rdi,QWORD PTR [rsp+0x38]
            return self.writeFn(self, slice);
  215752:	48 8d 74 24 48       	lea    rsi,[rsp+0x48]
  215757:	ff 17                	call   QWORD PTR [rdi]
  215759:	89 c5                	mov    ebp,eax
                try out_stream.writeByte(byte);
  21575b:	66 85 ed             	test   bp,bp
  21575e:	75 7d                	jne    2157dd <printLineFromFile+0x22d>
                if (byte == '\n') {
  215760:	41 80 fe 0a          	cmp    r14b,0xa
  215764:	48 8b 6c 24 10       	mov    rbp,QWORD PTR [rsp+0x10]
  215769:	0f 84 be 00 00 00    	je     21582d <printLineFromFile+0x27d>
        for (slice) |byte| {
  21576f:	49 83 c7 01          	add    r15,0x1
  215773:	4d 39 e7             	cmp    r15,r12
  215776:	72 a8                	jb     215720 <printLineFromFile+0x170>
  215778:	eb 1b                	jmp    215795 <printLineFromFile+0x1e5>
  21577a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
            if (byte == '\n') {
  215780:	31 c0                	xor    eax,eax
  215782:	41 80 fe 0a          	cmp    r14b,0xa
  215786:	0f 94 c0             	sete   al
  215789:	49 01 c5             	add    r13,rax
        for (slice) |byte| {
  21578c:	49 83 c7 01          	add    r15,0x1
  215790:	4d 39 e7             	cmp    r15,r12
  215793:	72 8b                	jb     215720 <printLineFromFile+0x170>
        if (amt_read < buf.len) return error.EndOfFile;
  215795:	49 81 fc ff 0f 00 00 	cmp    r12,0xfff
  21579c:	48 8d 84 24 48 20 00 	lea    rax,[rsp+0x2048]
  2157a3:	00 
  2157a4:	0f 86 22 02 00 00    	jbe    2159cc <printLineFromFile+0x41c>
        const amt_read = try f.read(buf[0..]);
  2157aa:	48 89 44 24 28       	mov    QWORD PTR [rsp+0x28],rax
  2157af:	48 c7 44 24 30 00 10 	mov    QWORD PTR [rsp+0x30],0x1000
  2157b6:	00 00 
  2157b8:	48 8d 7c 24 18       	lea    rdi,[rsp+0x18]
  2157bd:	48 8d 74 24 08       	lea    rsi,[rsp+0x8]
  2157c2:	48 8d 54 24 28       	lea    rdx,[rsp+0x28]
  2157c7:	e8 f4 a1 ff ff       	call   20f9c0 <File_read>
  2157cc:	66 83 7c 24 18 00    	cmp    WORD PTR [rsp+0x18],0x0
  2157d2:	0f 84 2b ff ff ff    	je     215703 <printLineFromFile+0x153>
  2157d8:	e9 d2 fe ff ff       	jmp    2156af <printLineFromFile+0xff>
  2157dd:	48 c1 fb 20          	sar    rbx,0x20
  2157e1:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  2157e8:	0f 1f 84 00 00 00 00 
  2157ef:	00 
  2157f0:	b8 03 00 00 00       	mov    eax,0x3
  2157f5:	48 89 df             	mov    rdi,rbx
  2157f8:	0f 05                	syscall 
  2157fa:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  2157fe:	74 f0                	je     2157f0 <printLineFromFile+0x240>
            const first = list.first orelse return null;
  215800:	48 8b 05 21 b8 00 00 	mov    rax,QWORD PTR [rip+0xb821]        # 221028 <emfile_promise_queue>
  215807:	48 85 c0             	test   rax,rax
  21580a:	0f 84 35 fe ff ff    	je     215645 <printLineFromFile+0x95>
            if (node.prev) |prev_node| {
  215810:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  215813:	48 85 c9             	test   rcx,rcx
  215816:	0f 84 d3 00 00 00    	je     2158ef <printLineFromFile+0x33f>
                prev_node.next = node.next;
  21581c:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  215820:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  215824:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  215828:	e9 cd 00 00 00       	jmp    2158fa <printLineFromFile+0x34a>
  21582d:	48 c1 fb 20          	sar    rbx,0x20
  215831:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  215838:	0f 1f 84 00 00 00 00 
  21583f:	00 
  215840:	b8 03 00 00 00       	mov    eax,0x3
  215845:	48 89 df             	mov    rdi,rbx
  215848:	0f 05                	syscall 
  21584a:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  21584e:	74 f0                	je     215840 <printLineFromFile+0x290>
            const first = list.first orelse return null;
  215850:	48 8b 05 d1 b7 00 00 	mov    rax,QWORD PTR [rip+0xb7d1]        # 221028 <emfile_promise_queue>
  215857:	48 85 c0             	test   rax,rax
  21585a:	0f 84 65 01 00 00    	je     2159c5 <printLineFromFile+0x415>
            if (node.prev) |prev_node| {
  215860:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  215863:	48 85 c9             	test   rcx,rcx
  215866:	0f 84 f2 00 00 00    	je     21595e <printLineFromFile+0x3ae>
                prev_node.next = node.next;
  21586c:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  215870:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  215874:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  215878:	e9 ec 00 00 00       	jmp    215969 <printLineFromFile+0x3b9>
                list.first = node.next;
  21587d:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  215881:	48 89 0d a0 b7 00 00 	mov    QWORD PTR [rip+0xb7a0],rcx        # 221028 <emfile_promise_queue>
            if (node.next) |next_node| {
  215888:	48 85 c9             	test   rcx,rcx
  21588b:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  21588e:	48 8d 35 9b b7 00 00 	lea    rsi,[rip+0xb79b]        # 221030 <emfile_promise_queue+0x8>
  215895:	48 0f 45 f1          	cmovne rsi,rcx
  215899:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  21589c:	48 83 05 94 b7 00 00 	add    QWORD PTR [rip+0xb794],0xffffffffffffffff        # 221038 <emfile_promise_queue+0x10>
  2158a3:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  2158a4:	74 1e                	je     2158c4 <printLineFromFile+0x314>
  2158a6:	48 83 3d 7a b7 00 00 	cmp    QWORD PTR [rip+0xb77a],0x0        # 221028 <emfile_promise_queue>
  2158ad:	00 
  2158ae:	0f 84 b1 01 00 00    	je     215a65 <printLineFromFile+0x4b5>
  2158b4:	48 8b 0d 75 b7 00 00 	mov    rcx,QWORD PTR [rip+0xb775]        # 221030 <emfile_promise_queue+0x8>
  2158bb:	48 85 c9             	test   rcx,rcx
  2158be:	0f 84 a1 01 00 00    	je     215a65 <printLineFromFile+0x4b5>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  2158c4:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  2158c8:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  2158cc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  2158d0:	48 89 c1             	mov    rcx,rax
  2158d3:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  2158d7:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  2158dd:	75 f1                	jne    2158d0 <printLineFromFile+0x320>
  2158df:	a8 01                	test   al,0x1
  2158e1:	75 02                	jne    2158e5 <printLineFromFile+0x335>
  2158e3:	ff 17                	call   QWORD PTR [rdi]
  2158e5:	0f b7 44 24 18       	movzx  eax,WORD PTR [rsp+0x18]
  2158ea:	e9 58 fd ff ff       	jmp    215647 <printLineFromFile+0x97>
                list.first = node.next;
  2158ef:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  2158f3:	48 89 0d 2e b7 00 00 	mov    QWORD PTR [rip+0xb72e],rcx        # 221028 <emfile_promise_queue>
            if (node.next) |next_node| {
  2158fa:	48 85 c9             	test   rcx,rcx
  2158fd:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  215900:	48 8d 35 29 b7 00 00 	lea    rsi,[rip+0xb729]        # 221030 <emfile_promise_queue+0x8>
  215907:	48 0f 45 f1          	cmovne rsi,rcx
  21590b:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  21590e:	48 83 05 22 b7 00 00 	add    QWORD PTR [rip+0xb722],0xffffffffffffffff        # 221038 <emfile_promise_queue+0x10>
  215915:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  215916:	74 1e                	je     215936 <printLineFromFile+0x386>
  215918:	48 83 3d 08 b7 00 00 	cmp    QWORD PTR [rip+0xb708],0x0        # 221028 <emfile_promise_queue>
  21591f:	00 
  215920:	0f 84 3f 01 00 00    	je     215a65 <printLineFromFile+0x4b5>
  215926:	48 8b 0d 03 b7 00 00 	mov    rcx,QWORD PTR [rip+0xb703]        # 221030 <emfile_promise_queue+0x8>
  21592d:	48 85 c9             	test   rcx,rcx
  215930:	0f 84 2f 01 00 00    	je     215a65 <printLineFromFile+0x4b5>
  215936:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  21593a:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  21593e:	66 90                	xchg   ax,ax
  215940:	48 89 c1             	mov    rcx,rax
  215943:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  215947:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  21594d:	75 f1                	jne    215940 <printLineFromFile+0x390>
  21594f:	a8 01                	test   al,0x1
  215951:	0f 85 ee fc ff ff    	jne    215645 <printLineFromFile+0x95>
  215957:	ff 17                	call   QWORD PTR [rdi]
  215959:	e9 e7 fc ff ff       	jmp    215645 <printLineFromFile+0x95>
                list.first = node.next;
  21595e:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  215962:	48 89 0d bf b6 00 00 	mov    QWORD PTR [rip+0xb6bf],rcx        # 221028 <emfile_promise_queue>
            if (node.next) |next_node| {
  215969:	48 85 c9             	test   rcx,rcx
  21596c:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  21596f:	48 8d 35 ba b6 00 00 	lea    rsi,[rip+0xb6ba]        # 221030 <emfile_promise_queue+0x8>
  215976:	48 0f 45 f1          	cmovne rsi,rcx
  21597a:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  21597d:	48 83 05 b3 b6 00 00 	add    QWORD PTR [rip+0xb6b3],0xffffffffffffffff        # 221038 <emfile_promise_queue+0x10>
  215984:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  215985:	74 1e                	je     2159a5 <printLineFromFile+0x3f5>
  215987:	48 83 3d 99 b6 00 00 	cmp    QWORD PTR [rip+0xb699],0x0        # 221028 <emfile_promise_queue>
  21598e:	00 
  21598f:	0f 84 d0 00 00 00    	je     215a65 <printLineFromFile+0x4b5>
  215995:	48 8b 0d 94 b6 00 00 	mov    rcx,QWORD PTR [rip+0xb694]        # 221030 <emfile_promise_queue+0x8>
  21599c:	48 85 c9             	test   rcx,rcx
  21599f:	0f 84 c0 00 00 00    	je     215a65 <printLineFromFile+0x4b5>
  2159a5:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  2159a9:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  2159ad:	0f 1f 00             	nop    DWORD PTR [rax]
  2159b0:	48 89 c1             	mov    rcx,rax
  2159b3:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  2159b7:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  2159bd:	75 f1                	jne    2159b0 <printLineFromFile+0x400>
  2159bf:	a8 01                	test   al,0x1
  2159c1:	75 02                	jne    2159c5 <printLineFromFile+0x415>
  2159c3:	ff 17                	call   QWORD PTR [rdi]
  2159c5:	31 ed                	xor    ebp,ebp
  2159c7:	e9 79 fc ff ff       	jmp    215645 <printLineFromFile+0x95>
  2159cc:	48 c1 fb 20          	sar    rbx,0x20
  2159d0:	b8 03 00 00 00       	mov    eax,0x3
  2159d5:	48 89 df             	mov    rdi,rbx
  2159d8:	0f 05                	syscall 
            switch (err) {
  2159da:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  2159de:	74 f0                	je     2159d0 <printLineFromFile+0x420>
            const first = list.first orelse return null;
  2159e0:	48 8b 05 41 b6 00 00 	mov    rax,QWORD PTR [rip+0xb641]        # 221028 <emfile_promise_queue>
  2159e7:	66 bd 24 00          	mov    bp,0x24
  2159eb:	48 85 c0             	test   rax,rax
  2159ee:	0f 84 51 fc ff ff    	je     215645 <printLineFromFile+0x95>
            if (node.prev) |prev_node| {
  2159f4:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  2159f7:	48 85 c9             	test   rcx,rcx
  2159fa:	74 0e                	je     215a0a <printLineFromFile+0x45a>
                prev_node.next = node.next;
  2159fc:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  215a00:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  215a04:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  215a08:	eb 0b                	jmp    215a15 <printLineFromFile+0x465>
                list.first = node.next;
  215a0a:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  215a0e:	48 89 0d 13 b6 00 00 	mov    QWORD PTR [rip+0xb613],rcx        # 221028 <emfile_promise_queue>
            if (node.next) |next_node| {
  215a15:	48 85 c9             	test   rcx,rcx
  215a18:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  215a1b:	48 8d 35 0e b6 00 00 	lea    rsi,[rip+0xb60e]        # 221030 <emfile_promise_queue+0x8>
  215a22:	48 0f 45 f1          	cmovne rsi,rcx
  215a26:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  215a29:	48 83 05 07 b6 00 00 	add    QWORD PTR [rip+0xb607],0xffffffffffffffff        # 221038 <emfile_promise_queue+0x10>
  215a30:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  215a31:	74 16                	je     215a49 <printLineFromFile+0x499>
  215a33:	48 83 3d ed b5 00 00 	cmp    QWORD PTR [rip+0xb5ed],0x0        # 221028 <emfile_promise_queue>
  215a3a:	00 
  215a3b:	74 28                	je     215a65 <printLineFromFile+0x4b5>
  215a3d:	48 8b 0d ec b5 00 00 	mov    rcx,QWORD PTR [rip+0xb5ec]        # 221030 <emfile_promise_queue+0x8>
  215a44:	48 85 c9             	test   rcx,rcx
  215a47:	74 1c                	je     215a65 <printLineFromFile+0x4b5>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  215a49:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  215a4d:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  215a51:	48 89 c1             	mov    rcx,rax
  215a54:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  215a58:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  215a5e:	75 f1                	jne    215a51 <printLineFromFile+0x4a1>
  215a60:	e9 ea fe ff ff       	jmp    21594f <printLineFromFile+0x39f>
            @panic("assertion failure");
  215a65:	e8 b6 32 ff ff       	call   208d20 <panic>
  215a6a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000215a70 <Allocator_alignedRealloc.68>:
    pub fn alignedRealloc(self: *Allocator, comptime T: type, comptime alignment: u29, old_mem: []align(alignment) T, n: usize) ![]align(alignment) T {
  215a70:	41 56                	push   r14
  215a72:	53                   	push   rbx
  215a73:	48 83 ec 78          	sub    rsp,0x78
  215a77:	49 89 ce             	mov    r14,rcx
  215a7a:	48 89 fb             	mov    rbx,rdi
        if (old_mem.len == 0) {
  215a7d:	48 8b 42 08          	mov    rax,QWORD PTR [rdx+0x8]
  215a81:	48 85 c0             	test   rax,rax
  215a84:	74 59                	je     215adf <Allocator_alignedRealloc.68+0x6f>
        if (n == 0) {
  215a86:	4d 85 f6             	test   r14,r14
  215a89:	0f 84 92 00 00 00    	je     215b21 <Allocator_alignedRealloc.68+0xb1>
        const old_byte_slice = @sliceToBytes(old_mem);
  215a8f:	48 8b 0a             	mov    rcx,QWORD PTR [rdx]
  215a92:	48 89 4c 24 38       	mov    QWORD PTR [rsp+0x38],rcx
  215a97:	48 89 44 24 40       	mov    QWORD PTR [rsp+0x40],rax
  215a9c:	48 8d 7c 24 48       	lea    rdi,[rsp+0x48]
  215aa1:	48 8d 54 24 38       	lea    rdx,[rsp+0x38]
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  215aa6:	41 b8 01 00 00 00    	mov    r8d,0x1
  215aac:	4c 89 f1             	mov    rcx,r14
  215aaf:	ff 56 08             	call   QWORD PTR [rsi+0x8]
  215ab2:	0f b7 44 24 48       	movzx  eax,WORD PTR [rsp+0x48]
  215ab7:	66 85 c0             	test   ax,ax
  215aba:	0f 84 9e 00 00 00    	je     215b5e <Allocator_alignedRealloc.68+0xee>
  215ac0:	66 89 03             	mov    WORD PTR [rbx],ax
  215ac3:	48 8b 44 24 70       	mov    rax,QWORD PTR [rsp+0x70]
  215ac8:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  215acc:	c5 f8 10 44 24 62    	vmovups xmm0,XMMWORD PTR [rsp+0x62]
  215ad2:	c5 f8 11 43 02       	vmovups XMMWORD PTR [rbx+0x2],xmm0
  215ad7:	48 83 c4 78          	add    rsp,0x78
  215adb:	5b                   	pop    rbx
  215adc:	41 5e                	pop    r14
  215ade:	c3                   	ret    
        if (n == 0) {
  215adf:	4d 85 f6             	test   r14,r14
  215ae2:	0f 84 a1 00 00 00    	je     215b89 <Allocator_alignedRealloc.68+0x119>
  215ae8:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  215aed:	b9 01 00 00 00       	mov    ecx,0x1
  215af2:	4c 89 f2             	mov    rdx,r14
  215af5:	ff 16                	call   QWORD PTR [rsi]
  215af7:	0f b7 4c 24 20       	movzx  ecx,WORD PTR [rsp+0x20]
  215afc:	66 85 c9             	test   cx,cx
  215aff:	0f 84 a6 00 00 00    	je     215bab <Allocator_alignedRealloc.68+0x13b>
  215b05:	0f b7 44 24 1e       	movzx  eax,WORD PTR [rsp+0x1e]
  215b0a:	66 89 44 24 0c       	mov    WORD PTR [rsp+0xc],ax
  215b0f:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  215b14:	8b 54 24 1a          	mov    edx,DWORD PTR [rsp+0x1a]
  215b18:	89 54 24 08          	mov    DWORD PTR [rsp+0x8],edx
  215b1c:	e9 af 00 00 00       	jmp    215bd0 <Allocator_alignedRealloc.68+0x160>
        const bytes = @sliceToBytes(memory);
  215b21:	48 8b 0a             	mov    rcx,QWORD PTR [rdx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  215b24:	48 8b 56 10          	mov    rdx,QWORD PTR [rsi+0x10]
  215b28:	48 89 4c 24 20       	mov    QWORD PTR [rsp+0x20],rcx
  215b2d:	48 89 44 24 28       	mov    QWORD PTR [rsp+0x28],rax
  215b32:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  215b37:	48 89 f7             	mov    rdi,rsi
  215b3a:	48 89 c6             	mov    rsi,rax
  215b3d:	ff d2                	call   rdx
            return ([*]align(alignment) T)(undefined)[0..0];
  215b3f:	48 8b 05 82 fc fe ff 	mov    rax,QWORD PTR [rip+0xfffffffffffefc82]        # 2057c8 <__unnamed_77+0x10>
  215b46:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  215b4a:	c5 f8 10 05 66 fc fe 	vmovups xmm0,XMMWORD PTR [rip+0xfffffffffffefc66]        # 2057b8 <__unnamed_77>
  215b51:	ff 
  215b52:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  215b56:	48 83 c4 78          	add    rsp,0x78
  215b5a:	5b                   	pop    rbx
  215b5b:	41 5e                	pop    r14
  215b5d:	c3                   	ret    
        assert(byte_slice.len == byte_count);
  215b5e:	4c 39 74 24 58       	cmp    QWORD PTR [rsp+0x58],r14
    if (!ok) {
  215b63:	0f 85 87 00 00 00    	jne    215bf0 <Allocator_alignedRealloc.68+0x180>
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  215b69:	66 c7 03 00 00       	mov    WORD PTR [rbx],0x0
  215b6e:	0f b7 44 24 12       	movzx  eax,WORD PTR [rsp+0x12]
  215b73:	66 89 43 06          	mov    WORD PTR [rbx+0x6],ax
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  215b77:	48 8b 44 24 50       	mov    rax,QWORD PTR [rsp+0x50]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  215b7c:	8b 4c 24 0e          	mov    ecx,DWORD PTR [rsp+0xe]
  215b80:	89 4b 02             	mov    DWORD PTR [rbx+0x2],ecx
  215b83:	48 89 43 08          	mov    QWORD PTR [rbx+0x8],rax
  215b87:	eb 5b                	jmp    215be4 <Allocator_alignedRealloc.68+0x174>
  215b89:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
            return ([*]align(alignment) T)(undefined)[0..0];
  215b8e:	0f b7 0d 29 fc fe ff 	movzx  ecx,WORD PTR [rip+0xfffffffffffefc29]        # 2057be <__unnamed_77+0x6>
  215b95:	66 89 4c 24 0c       	mov    WORD PTR [rsp+0xc],cx
  215b9a:	8b 0d 1a fc fe ff    	mov    ecx,DWORD PTR [rip+0xfffffffffffefc1a]        # 2057ba <__unnamed_77+0x2>
  215ba0:	89 4c 24 08          	mov    DWORD PTR [rsp+0x8],ecx
  215ba4:	31 c9                	xor    ecx,ecx
  215ba6:	45 31 f6             	xor    r14d,r14d
  215ba9:	eb 25                	jmp    215bd0 <Allocator_alignedRealloc.68+0x160>
        assert(byte_slice.len == byte_count);
  215bab:	4c 39 74 24 30       	cmp    QWORD PTR [rsp+0x30],r14
  215bb0:	75 3e                	jne    215bf0 <Allocator_alignedRealloc.68+0x180>
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  215bb2:	48 8b 54 24 28       	mov    rdx,QWORD PTR [rsp+0x28]
  215bb7:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  215bbc:	8b 4c 24 14          	mov    ecx,DWORD PTR [rsp+0x14]
  215bc0:	89 4c 24 08          	mov    DWORD PTR [rsp+0x8],ecx
  215bc4:	0f b7 4c 24 18       	movzx  ecx,WORD PTR [rsp+0x18]
  215bc9:	66 89 4c 24 0c       	mov    WORD PTR [rsp+0xc],cx
  215bce:	31 c9                	xor    ecx,ecx
            return self.alignedAlloc(T, alignment, n);
  215bd0:	66 89 0b             	mov    WORD PTR [rbx],cx
  215bd3:	0f b7 48 04          	movzx  ecx,WORD PTR [rax+0x4]
  215bd7:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  215bdb:	8b 00                	mov    eax,DWORD PTR [rax]
  215bdd:	89 43 02             	mov    DWORD PTR [rbx+0x2],eax
  215be0:	48 89 53 08          	mov    QWORD PTR [rbx+0x8],rdx
  215be4:	4c 89 73 10          	mov    QWORD PTR [rbx+0x10],r14
  215be8:	48 83 c4 78          	add    rsp,0x78
  215bec:	5b                   	pop    rbx
  215bed:	41 5e                	pop    r14
  215bef:	c3                   	ret    
            @panic("assertion failure");
  215bf0:	e8 2b 31 ff ff       	call   208d20 <panic>
  215bf5:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  215bfc:	00 00 00 00 

0000000000215c00 <LineNumberProgram_checkLineMatch>:
    pub fn checkLineMatch(self: *LineNumberProgram) !?LineInfo {
  215c00:	41 56                	push   r14
  215c02:	53                   	push   rbx
  215c03:	48 81 ec 98 00 00 00 	sub    rsp,0x98
  215c0a:	48 89 f3             	mov    rbx,rsi
  215c0d:	49 89 fe             	mov    r14,rdi
  215c10:	48 8b 03             	mov    rax,QWORD PTR [rbx]
        if (self.target_address >= self.prev_address and self.target_address < self.address) {
  215c13:	48 8b 4b 28          	mov    rcx,QWORD PTR [rbx+0x28]
  215c17:	48 3b 4b 48          	cmp    rcx,QWORD PTR [rbx+0x48]
  215c1b:	0f 82 b6 00 00 00    	jb     215cd7 <LineNumberProgram_checkLineMatch+0xd7>
  215c21:	48 39 c1             	cmp    rcx,rax
  215c24:	0f 83 ad 00 00 00    	jae    215cd7 <LineNumberProgram_checkLineMatch+0xd7>
            const file_entry = if (self.prev_file == 0) {
  215c2a:	48 8b 4b 50          	mov    rcx,QWORD PTR [rbx+0x50]
  215c2e:	48 85 c9             	test   rcx,rcx
  215c31:	0f 84 f8 00 00 00    	je     215d2f <LineNumberProgram_checkLineMatch+0x12f>
            } else if (self.prev_file - 1 >= self.file_entries.len) {
  215c37:	48 83 c1 ff          	add    rcx,0xffffffffffffffff
  215c3b:	48 8b 43 40          	mov    rax,QWORD PTR [rbx+0x40]
  215c3f:	48 3b 48 10          	cmp    rcx,QWORD PTR [rax+0x10]
  215c43:	0f 83 ce 00 00 00    	jae    215d17 <LineNumberProgram_checkLineMatch+0x117>
                &self.file_entries.items[self.prev_file - 1];
  215c49:	48 8b 10             	mov    rdx,QWORD PTR [rax]
            const dir_name = if (file_entry.dir_index >= self.include_dirs.len) {
  215c4c:	48 8d 0c 89          	lea    rcx,[rcx+rcx*4]
  215c50:	48 8b 74 ca 10       	mov    rsi,QWORD PTR [rdx+rcx*8+0x10]
  215c55:	48 3b 73 38          	cmp    rsi,QWORD PTR [rbx+0x38]
  215c59:	0f 83 b8 00 00 00    	jae    215d17 <LineNumberProgram_checkLineMatch+0x117>
                self.include_dirs[file_entry.dir_index];
  215c5f:	48 8b 7b 30          	mov    rdi,QWORD PTR [rbx+0x30]
  215c63:	48 c1 e6 04          	shl    rsi,0x4
            const dir_name = if (file_entry.dir_index >= self.include_dirs.len) {
  215c67:	c5 f8 10 04 37       	vmovups xmm0,XMMWORD PTR [rdi+rsi*1]
  215c6c:	c5 f8 29 44 24 50    	vmovaps XMMWORD PTR [rsp+0x50],xmm0
            const file_name = try os.path.join(self.file_entries.allocator, dir_name, file_entry.file_name);
  215c72:	48 8b 70 18          	mov    rsi,QWORD PTR [rax+0x18]
  215c76:	48 8d 0c ca          	lea    rcx,[rdx+rcx*8]
  215c7a:	48 8d 7c 24 18       	lea    rdi,[rsp+0x18]
  215c7f:	48 8d 54 24 50       	lea    rdx,[rsp+0x50]
pub fn joinWindows(allocator: *Allocator, paths: ...) ![]u8 {
    return mem.join(allocator, sep_windows, paths);
}

pub fn joinPosix(allocator: *Allocator, paths: ...) ![]u8 {
    return mem.join(allocator, sep_posix, paths);
  215c84:	e8 47 06 00 00       	call   2162d0 <join.79>
  215c89:	0f b7 44 24 18       	movzx  eax,WORD PTR [rsp+0x18]
  215c8e:	c5 f8 10 44 24 1a    	vmovups xmm0,XMMWORD PTR [rsp+0x1a]
  215c94:	c5 f8 29 44 24 30    	vmovaps XMMWORD PTR [rsp+0x30],xmm0
  215c9a:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  215c9f:	48 89 4c 24 3e       	mov    QWORD PTR [rsp+0x3e],rcx
  215ca4:	66 85 c0             	test   ax,ax
  215ca7:	0f 84 ab 00 00 00    	je     215d58 <LineNumberProgram_checkLineMatch+0x158>
  215cad:	66 41 89 06          	mov    WORD PTR [r14],ax
  215cb1:	c5 fc 10 44 24 62    	vmovups ymm0,YMMWORD PTR [rsp+0x62]
  215cb7:	c5 fc 10 4c 24 78    	vmovups ymm1,YMMWORD PTR [rsp+0x78]
  215cbd:	c4 c1 7c 11 4e 18    	vmovups YMMWORD PTR [r14+0x18],ymm1
  215cc3:	c4 c1 7c 11 46 02    	vmovups YMMWORD PTR [r14+0x2],ymm0
  215cc9:	48 81 c4 98 00 00 00 	add    rsp,0x98
  215cd0:	5b                   	pop    rbx
  215cd1:	41 5e                	pop    r14
  215cd3:	c5 f8 77             	vzeroupper 
  215cd6:	c3                   	ret    
        self.prev_address = self.address;
  215cd7:	48 89 43 48          	mov    QWORD PTR [rbx+0x48],rax
        self.prev_file = self.file;
  215cdb:	c5 f8 10 43 08       	vmovups xmm0,XMMWORD PTR [rbx+0x8]
  215ce0:	c5 f8 11 43 50       	vmovups XMMWORD PTR [rbx+0x50],xmm0
        self.prev_column = self.column;
  215ce5:	48 8b 43 18          	mov    rax,QWORD PTR [rbx+0x18]
  215ce9:	48 89 43 60          	mov    QWORD PTR [rbx+0x60],rax
        self.prev_is_stmt = self.is_stmt;
  215ced:	8a 43 20             	mov    al,BYTE PTR [rbx+0x20]
  215cf0:	88 43 68             	mov    BYTE PTR [rbx+0x68],al
        self.prev_basic_block = self.basic_block;
  215cf3:	8a 43 21             	mov    al,BYTE PTR [rbx+0x21]
  215cf6:	88 43 69             	mov    BYTE PTR [rbx+0x69],al
        self.prev_end_sequence = self.end_sequence;
  215cf9:	8a 43 22             	mov    al,BYTE PTR [rbx+0x22]
  215cfc:	88 43 6a             	mov    BYTE PTR [rbx+0x6a],al
        return null;
  215cff:	c5 fc 10 05 11 fc fe 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffefc11]        # 205918 <__unnamed_78+0x18>
  215d06:	ff 
  215d07:	c4 c1 7c 11 46 18    	vmovups YMMWORD PTR [r14+0x18],ymm0
  215d0d:	c5 fc 10 05 eb fb fe 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffefbeb]        # 205900 <__unnamed_78>
  215d14:	ff 
  215d15:	eb 2e                	jmp    215d45 <LineNumberProgram_checkLineMatch+0x145>
  215d17:	c5 fc 10 05 c1 fb fe 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffefbc1]        # 2058e0 <__unnamed_79+0x18>
  215d1e:	ff 
  215d1f:	c4 c1 7c 11 46 18    	vmovups YMMWORD PTR [r14+0x18],ymm0
  215d25:	c5 fc 10 05 9b fb fe 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffefb9b]        # 2058c8 <__unnamed_79>
  215d2c:	ff 
  215d2d:	eb 16                	jmp    215d45 <LineNumberProgram_checkLineMatch+0x145>
                return error.MissingDebugInfo;
  215d2f:	c5 fc 10 05 71 fb fe 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffefb71]        # 2058a8 <__unnamed_80+0x18>
  215d36:	ff 
  215d37:	c4 c1 7c 11 46 18    	vmovups YMMWORD PTR [r14+0x18],ymm0
  215d3d:	c5 fc 10 05 4b fb fe 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffefb4b]        # 205890 <__unnamed_80>
  215d44:	ff 
  215d45:	c4 c1 7c 11 06       	vmovups YMMWORD PTR [r14],ymm0
  215d4a:	48 81 c4 98 00 00 00 	add    rsp,0x98
  215d51:	5b                   	pop    rbx
  215d52:	41 5e                	pop    r14
  215d54:	c5 f8 77             	vzeroupper 
  215d57:	c3                   	ret    
                .allocator = self.file_entries.allocator,
  215d58:	48 8b 43 40          	mov    rax,QWORD PTR [rbx+0x40]
                .line = if (self.prev_line >= 0) @intCast(usize, self.prev_line) else 0,
  215d5c:	48 8b 4b 58          	mov    rcx,QWORD PTR [rbx+0x58]
  215d60:	48 89 ca             	mov    rdx,rcx
  215d63:	48 c1 fa 3f          	sar    rdx,0x3f
  215d67:	c4 e2 e8 f2 c9       	andn   rcx,rdx,rcx
                .column = self.prev_column,
  215d6c:	48 8b 53 60          	mov    rdx,QWORD PTR [rbx+0x60]
                .allocator = self.file_entries.allocator,
  215d70:	48 8b 40 18          	mov    rax,QWORD PTR [rax+0x18]
            return LineInfo{
  215d74:	c6 44 24 0a 01       	mov    BYTE PTR [rsp+0xa],0x1
  215d79:	66 41 c7 06 00 00    	mov    WORD PTR [r14],0x0
  215d7f:	0f b7 74 24 16       	movzx  esi,WORD PTR [rsp+0x16]
  215d84:	66 41 89 76 06       	mov    WORD PTR [r14+0x6],si
  215d89:	8b 74 24 12          	mov    esi,DWORD PTR [rsp+0x12]
  215d8d:	41 89 76 02          	mov    DWORD PTR [r14+0x2],esi
  215d91:	49 89 4e 08          	mov    QWORD PTR [r14+0x8],rcx
  215d95:	49 89 56 10          	mov    QWORD PTR [r14+0x10],rdx
  215d99:	c5 f8 10 44 24 36    	vmovups xmm0,XMMWORD PTR [rsp+0x36]
  215d9f:	c4 c1 78 11 46 18    	vmovups XMMWORD PTR [r14+0x18],xmm0
  215da5:	49 89 46 28          	mov    QWORD PTR [r14+0x28],rax
  215da9:	8a 44 24 0a          	mov    al,BYTE PTR [rsp+0xa]
  215dad:	41 88 46 30          	mov    BYTE PTR [r14+0x30],al
  215db1:	8a 44 24 11          	mov    al,BYTE PTR [rsp+0x11]
  215db5:	41 88 46 37          	mov    BYTE PTR [r14+0x37],al
  215db9:	0f b7 44 24 0f       	movzx  eax,WORD PTR [rsp+0xf]
  215dbe:	66 41 89 46 35       	mov    WORD PTR [r14+0x35],ax
  215dc3:	8b 44 24 0b          	mov    eax,DWORD PTR [rsp+0xb]
  215dc7:	41 89 46 31          	mov    DWORD PTR [r14+0x31],eax
  215dcb:	48 81 c4 98 00 00 00 	add    rsp,0x98
  215dd2:	5b                   	pop    rbx
  215dd3:	41 5e                	pop    r14
  215dd5:	c3                   	ret    
  215dd6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  215ddd:	00 00 00 

0000000000215de0 <Allocator_alignedRealloc.73>:
    pub fn alignedRealloc(self: *Allocator, comptime T: type, comptime alignment: u29, old_mem: []align(alignment) T, n: usize) ![]align(alignment) T {
  215de0:	41 56                	push   r14
  215de2:	53                   	push   rbx
  215de3:	48 81 ec 88 00 00 00 	sub    rsp,0x88
  215dea:	48 89 fb             	mov    rbx,rdi
        if (old_mem.len == 0) {
  215ded:	48 8b 42 08          	mov    rax,QWORD PTR [rdx+0x8]
  215df1:	48 85 c0             	test   rax,rax
  215df4:	74 5e                	je     215e54 <Allocator_alignedRealloc.73+0x74>
        if (n == 0) {
  215df6:	48 85 c9             	test   rcx,rcx
  215df9:	0f 84 a6 00 00 00    	je     215ea5 <Allocator_alignedRealloc.73+0xc5>
        const old_byte_slice = @sliceToBytes(old_mem);
  215dff:	48 8b 12             	mov    rdx,QWORD PTR [rdx]
  215e02:	48 c1 e0 04          	shl    rax,0x4
  215e06:	48 89 54 24 38       	mov    QWORD PTR [rsp+0x38],rdx
  215e0b:	48 89 44 24 40       	mov    QWORD PTR [rsp+0x40],rax
    return if (@mulWithOverflow(T, a, b, &answer)) error.Overflow else answer;
  215e10:	ba 10 00 00 00       	mov    edx,0x10
  215e15:	48 89 c8             	mov    rax,rcx
  215e18:	48 f7 e2             	mul    rdx
  215e1b:	0f 81 ca 00 00 00    	jno    215eeb <Allocator_alignedRealloc.73+0x10b>
  215e21:	48 8d 0d 08 12 ff ff 	lea    rcx,[rip+0xffffffffffff1208]        # 207030 <__unnamed_54>
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  215e28:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  215e2c:	0f 84 d4 00 00 00    	je     215f06 <Allocator_alignedRealloc.73+0x126>
  215e32:	48 8b 05 1f fa fe ff 	mov    rax,QWORD PTR [rip+0xfffffffffffefa1f]        # 205858 <__unnamed_81+0x10>
  215e39:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  215e3d:	c5 f8 10 05 03 fa fe 	vmovups xmm0,XMMWORD PTR [rip+0xfffffffffffefa03]        # 205848 <__unnamed_81>
  215e44:	ff 
  215e45:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  215e49:	48 81 c4 88 00 00 00 	add    rsp,0x88
  215e50:	5b                   	pop    rbx
  215e51:	41 5e                	pop    r14
  215e53:	c3                   	ret    
        if (n == 0) {
  215e54:	48 85 c9             	test   rcx,rcx
  215e57:	0f 84 f6 00 00 00    	je     215f53 <Allocator_alignedRealloc.73+0x173>
  215e5d:	ba 10 00 00 00       	mov    edx,0x10
  215e62:	48 89 c8             	mov    rax,rcx
  215e65:	48 f7 e2             	mul    rdx
  215e68:	0f 81 07 01 00 00    	jno    215f75 <Allocator_alignedRealloc.73+0x195>
  215e6e:	48 8d 0d bb 11 ff ff 	lea    rcx,[rip+0xffffffffffff11bb]        # 207030 <__unnamed_54>
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  215e75:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  215e79:	0f 84 11 01 00 00    	je     215f90 <Allocator_alignedRealloc.73+0x1b0>
  215e7f:	0f b7 05 c8 f9 fe ff 	movzx  eax,WORD PTR [rip+0xfffffffffffef9c8]        # 20584e <__unnamed_81+0x6>
  215e86:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  215e8b:	8b 05 b9 f9 fe ff    	mov    eax,DWORD PTR [rip+0xfffffffffffef9b9]        # 20584a <__unnamed_81+0x2>
  215e91:	89 04 24             	mov    DWORD PTR [rsp],eax
  215e94:	48 89 e0             	mov    rax,rsp
  215e97:	66 b9 10 00          	mov    cx,0x10
  215e9b:	31 d2                	xor    edx,edx
  215e9d:	45 31 f6             	xor    r14d,r14d
  215ea0:	e9 6f 01 00 00       	jmp    216014 <Allocator_alignedRealloc.73+0x234>
        const bytes = @sliceToBytes(memory);
  215ea5:	48 c1 e0 04          	shl    rax,0x4
        if (bytes.len == 0) return;
  215ea9:	74 1e                	je     215ec9 <Allocator_alignedRealloc.73+0xe9>
        const bytes = @sliceToBytes(memory);
  215eab:	48 8b 0a             	mov    rcx,QWORD PTR [rdx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  215eae:	48 8b 56 10          	mov    rdx,QWORD PTR [rsi+0x10]
  215eb2:	48 89 4c 24 08       	mov    QWORD PTR [rsp+0x8],rcx
  215eb7:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  215ebc:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  215ec1:	48 89 f7             	mov    rdi,rsi
  215ec4:	48 89 c6             	mov    rsi,rax
  215ec7:	ff d2                	call   rdx
            return ([*]align(alignment) T)(undefined)[0..0];
  215ec9:	48 8b 05 70 f9 fe ff 	mov    rax,QWORD PTR [rip+0xfffffffffffef970]        # 205840 <__unnamed_82+0x10>
  215ed0:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  215ed4:	c5 f8 10 05 54 f9 fe 	vmovups xmm0,XMMWORD PTR [rip+0xfffffffffffef954]        # 205830 <__unnamed_82>
  215edb:	ff 
  215edc:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  215ee0:	48 81 c4 88 00 00 00 	add    rsp,0x88
  215ee7:	5b                   	pop    rbx
  215ee8:	41 5e                	pop    r14
  215eea:	c3                   	ret    
  215eeb:	48 8d 4c 24 08       	lea    rcx,[rsp+0x8]
  215ef0:	66 c7 44 24 08 00 00 	mov    WORD PTR [rsp+0x8],0x0
  215ef7:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  215efc:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  215f00:	0f 85 2c ff ff ff    	jne    215e32 <Allocator_alignedRealloc.73+0x52>
  215f06:	4c 8b 71 08          	mov    r14,QWORD PTR [rcx+0x8]
  215f0a:	48 8d 7c 24 58       	lea    rdi,[rsp+0x58]
  215f0f:	48 8d 54 24 38       	lea    rdx,[rsp+0x38]
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  215f14:	41 b8 08 00 00 00    	mov    r8d,0x8
  215f1a:	4c 89 f1             	mov    rcx,r14
  215f1d:	ff 56 08             	call   QWORD PTR [rsi+0x8]
  215f20:	0f b7 44 24 58       	movzx  eax,WORD PTR [rsp+0x58]
  215f25:	66 85 c0             	test   ax,ax
  215f28:	0f 84 95 00 00 00    	je     215fc3 <Allocator_alignedRealloc.73+0x1e3>
  215f2e:	66 89 03             	mov    WORD PTR [rbx],ax
  215f31:	48 8b 84 24 80 00 00 	mov    rax,QWORD PTR [rsp+0x80]
  215f38:	00 
  215f39:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  215f3d:	c5 f8 10 44 24 72    	vmovups xmm0,XMMWORD PTR [rsp+0x72]
  215f43:	c5 f8 11 43 02       	vmovups XMMWORD PTR [rbx+0x2],xmm0
  215f48:	48 81 c4 88 00 00 00 	add    rsp,0x88
  215f4f:	5b                   	pop    rbx
  215f50:	41 5e                	pop    r14
  215f52:	c3                   	ret    
  215f53:	48 89 e0             	mov    rax,rsp
            return ([*]align(alignment) T)(undefined)[0..0];
  215f56:	0f b7 0d d9 f8 fe ff 	movzx  ecx,WORD PTR [rip+0xfffffffffffef8d9]        # 205836 <__unnamed_82+0x6>
  215f5d:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  215f62:	8b 0d ca f8 fe ff    	mov    ecx,DWORD PTR [rip+0xfffffffffffef8ca]        # 205832 <__unnamed_82+0x2>
  215f68:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  215f6b:	31 c9                	xor    ecx,ecx
  215f6d:	45 31 f6             	xor    r14d,r14d
  215f70:	e9 9f 00 00 00       	jmp    216014 <Allocator_alignedRealloc.73+0x234>
  215f75:	48 8d 4c 24 48       	lea    rcx,[rsp+0x48]
  215f7a:	66 c7 44 24 48 00 00 	mov    WORD PTR [rsp+0x48],0x0
  215f81:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  215f86:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  215f8a:	0f 85 ef fe ff ff    	jne    215e7f <Allocator_alignedRealloc.73+0x9f>
  215f90:	4c 8b 71 08          	mov    r14,QWORD PTR [rcx+0x8]
  215f94:	48 8d 7c 24 08       	lea    rdi,[rsp+0x8]
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  215f99:	b9 08 00 00 00       	mov    ecx,0x8
  215f9e:	4c 89 f2             	mov    rdx,r14
  215fa1:	ff 16                	call   QWORD PTR [rsi]
  215fa3:	0f b7 4c 24 08       	movzx  ecx,WORD PTR [rsp+0x8]
  215fa8:	66 85 c9             	test   cx,cx
  215fab:	74 41                	je     215fee <Allocator_alignedRealloc.73+0x20e>
  215fad:	0f b7 44 24 36       	movzx  eax,WORD PTR [rsp+0x36]
  215fb2:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  215fb7:	48 89 e0             	mov    rax,rsp
  215fba:	8b 54 24 32          	mov    edx,DWORD PTR [rsp+0x32]
  215fbe:	89 14 24             	mov    DWORD PTR [rsp],edx
  215fc1:	eb 51                	jmp    216014 <Allocator_alignedRealloc.73+0x234>
        assert(byte_slice.len == byte_count);
  215fc3:	4c 39 74 24 68       	cmp    QWORD PTR [rsp+0x68],r14
    if (!ok) {
  215fc8:	75 6d                	jne    216037 <Allocator_alignedRealloc.73+0x257>
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  215fca:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  215fcf:	66 c7 03 00 00       	mov    WORD PTR [rbx],0x0
  215fd4:	0f b7 4c 24 2a       	movzx  ecx,WORD PTR [rsp+0x2a]
  215fd9:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  215fdd:	49 c1 ee 04          	shr    r14,0x4
  215fe1:	8b 4c 24 26          	mov    ecx,DWORD PTR [rsp+0x26]
  215fe5:	89 4b 02             	mov    DWORD PTR [rbx+0x2],ecx
  215fe8:	48 89 43 08          	mov    QWORD PTR [rbx+0x8],rax
  215fec:	eb 3a                	jmp    216028 <Allocator_alignedRealloc.73+0x248>
        assert(byte_slice.len == byte_count);
  215fee:	4c 39 74 24 18       	cmp    QWORD PTR [rsp+0x18],r14
  215ff3:	75 42                	jne    216037 <Allocator_alignedRealloc.73+0x257>
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  215ff5:	48 8b 54 24 10       	mov    rdx,QWORD PTR [rsp+0x10]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  215ffa:	49 c1 ee 04          	shr    r14,0x4
  215ffe:	48 89 e0             	mov    rax,rsp
  216001:	8b 4c 24 2c          	mov    ecx,DWORD PTR [rsp+0x2c]
  216005:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  216008:	0f b7 4c 24 30       	movzx  ecx,WORD PTR [rsp+0x30]
  21600d:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  216012:	31 c9                	xor    ecx,ecx
            return self.alignedAlloc(T, alignment, n);
  216014:	66 89 0b             	mov    WORD PTR [rbx],cx
  216017:	0f b7 48 04          	movzx  ecx,WORD PTR [rax+0x4]
  21601b:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  21601f:	8b 00                	mov    eax,DWORD PTR [rax]
  216021:	89 43 02             	mov    DWORD PTR [rbx+0x2],eax
  216024:	48 89 53 08          	mov    QWORD PTR [rbx+0x8],rdx
  216028:	4c 89 73 10          	mov    QWORD PTR [rbx+0x10],r14
  21602c:	48 81 c4 88 00 00 00 	add    rsp,0x88
  216033:	5b                   	pop    rbx
  216034:	41 5e                	pop    r14
  216036:	c3                   	ret    
            @panic("assertion failure");
  216037:	e8 e4 2c ff ff       	call   208d20 <panic>
  21603c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

0000000000216040 <Allocator_alignedRealloc.76>:
    pub fn alignedRealloc(self: *Allocator, comptime T: type, comptime alignment: u29, old_mem: []align(alignment) T, n: usize) ![]align(alignment) T {
  216040:	41 56                	push   r14
  216042:	53                   	push   rbx
  216043:	48 81 ec 88 00 00 00 	sub    rsp,0x88
  21604a:	48 89 fb             	mov    rbx,rdi
        if (old_mem.len == 0) {
  21604d:	48 8b 42 08          	mov    rax,QWORD PTR [rdx+0x8]
  216051:	48 85 c0             	test   rax,rax
  216054:	74 62                	je     2160b8 <Allocator_alignedRealloc.76+0x78>
        if (n == 0) {
  216056:	48 85 c9             	test   rcx,rcx
  216059:	0f 84 a9 00 00 00    	je     216108 <Allocator_alignedRealloc.76+0xc8>
        const old_byte_slice = @sliceToBytes(old_mem);
  21605f:	48 8b 12             	mov    rdx,QWORD PTR [rdx]
  216062:	48 c1 e0 03          	shl    rax,0x3
  216066:	48 8d 04 80          	lea    rax,[rax+rax*4]
  21606a:	48 89 54 24 38       	mov    QWORD PTR [rsp+0x38],rdx
  21606f:	48 89 44 24 40       	mov    QWORD PTR [rsp+0x40],rax
  216074:	ba 28 00 00 00       	mov    edx,0x28
  216079:	48 89 c8             	mov    rax,rcx
  21607c:	48 f7 e2             	mul    rdx
  21607f:	0f 81 d0 00 00 00    	jno    216155 <Allocator_alignedRealloc.76+0x115>
  216085:	48 8d 0d a4 0f ff ff 	lea    rcx,[rip+0xffffffffffff0fa4]        # 207030 <__unnamed_54>
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  21608c:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  216090:	0f 84 da 00 00 00    	je     216170 <Allocator_alignedRealloc.76+0x130>
  216096:	48 8b 05 eb f7 fe ff 	mov    rax,QWORD PTR [rip+0xfffffffffffef7eb]        # 205888 <__unnamed_83+0x10>
  21609d:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  2160a1:	c5 f8 10 05 cf f7 fe 	vmovups xmm0,XMMWORD PTR [rip+0xfffffffffffef7cf]        # 205878 <__unnamed_83>
  2160a8:	ff 
  2160a9:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  2160ad:	48 81 c4 88 00 00 00 	add    rsp,0x88
  2160b4:	5b                   	pop    rbx
  2160b5:	41 5e                	pop    r14
  2160b7:	c3                   	ret    
        if (n == 0) {
  2160b8:	48 85 c9             	test   rcx,rcx
  2160bb:	0f 84 fc 00 00 00    	je     2161bd <Allocator_alignedRealloc.76+0x17d>
  2160c1:	ba 28 00 00 00       	mov    edx,0x28
  2160c6:	48 89 c8             	mov    rax,rcx
  2160c9:	48 f7 e2             	mul    rdx
  2160cc:	0f 81 0c 01 00 00    	jno    2161de <Allocator_alignedRealloc.76+0x19e>
  2160d2:	48 8d 0d 57 0f ff ff 	lea    rcx,[rip+0xffffffffffff0f57]        # 207030 <__unnamed_54>
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  2160d9:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  2160dd:	0f 84 16 01 00 00    	je     2161f9 <Allocator_alignedRealloc.76+0x1b9>
  2160e3:	0f b7 05 94 f7 fe ff 	movzx  eax,WORD PTR [rip+0xfffffffffffef794]        # 20587e <__unnamed_83+0x6>
  2160ea:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  2160ef:	8b 05 85 f7 fe ff    	mov    eax,DWORD PTR [rip+0xfffffffffffef785]        # 20587a <__unnamed_83+0x2>
  2160f5:	89 04 24             	mov    DWORD PTR [rsp],eax
  2160f8:	48 89 e0             	mov    rax,rsp
  2160fb:	66 b9 10 00          	mov    cx,0x10
  2160ff:	31 f6                	xor    esi,esi
  216101:	31 d2                	xor    edx,edx
  216103:	e9 9d 01 00 00       	jmp    2162a5 <Allocator_alignedRealloc.76+0x265>
        const bytes = @sliceToBytes(memory);
  216108:	48 c1 e0 03          	shl    rax,0x3
  21610c:	48 8d 04 80          	lea    rax,[rax+rax*4]
        if (bytes.len == 0) return;
  216110:	48 85 c0             	test   rax,rax
  216113:	74 1e                	je     216133 <Allocator_alignedRealloc.76+0xf3>
        const bytes = @sliceToBytes(memory);
  216115:	48 8b 0a             	mov    rcx,QWORD PTR [rdx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  216118:	48 8b 56 10          	mov    rdx,QWORD PTR [rsi+0x10]
  21611c:	48 89 4c 24 08       	mov    QWORD PTR [rsp+0x8],rcx
  216121:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  216126:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  21612b:	48 89 f7             	mov    rdi,rsi
  21612e:	48 89 c6             	mov    rsi,rax
  216131:	ff d2                	call   rdx
            return ([*]align(alignment) T)(undefined)[0..0];
  216133:	48 8b 05 36 f7 fe ff 	mov    rax,QWORD PTR [rip+0xfffffffffffef736]        # 205870 <__unnamed_84+0x10>
  21613a:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  21613e:	c5 f8 10 05 1a f7 fe 	vmovups xmm0,XMMWORD PTR [rip+0xfffffffffffef71a]        # 205860 <__unnamed_84>
  216145:	ff 
  216146:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  21614a:	48 81 c4 88 00 00 00 	add    rsp,0x88
  216151:	5b                   	pop    rbx
  216152:	41 5e                	pop    r14
  216154:	c3                   	ret    
  216155:	48 8d 4c 24 08       	lea    rcx,[rsp+0x8]
  21615a:	66 c7 44 24 08 00 00 	mov    WORD PTR [rsp+0x8],0x0
  216161:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  216166:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  21616a:	0f 85 26 ff ff ff    	jne    216096 <Allocator_alignedRealloc.76+0x56>
  216170:	4c 8b 71 08          	mov    r14,QWORD PTR [rcx+0x8]
  216174:	48 8d 7c 24 58       	lea    rdi,[rsp+0x58]
  216179:	48 8d 54 24 38       	lea    rdx,[rsp+0x38]
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  21617e:	41 b8 08 00 00 00    	mov    r8d,0x8
  216184:	4c 89 f1             	mov    rcx,r14
  216187:	ff 56 08             	call   QWORD PTR [rsi+0x8]
  21618a:	0f b7 44 24 58       	movzx  eax,WORD PTR [rsp+0x58]
  21618f:	66 85 c0             	test   ax,ax
  216192:	0f 84 94 00 00 00    	je     21622c <Allocator_alignedRealloc.76+0x1ec>
  216198:	66 89 03             	mov    WORD PTR [rbx],ax
  21619b:	48 8b 84 24 80 00 00 	mov    rax,QWORD PTR [rsp+0x80]
  2161a2:	00 
  2161a3:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  2161a7:	c5 f8 10 44 24 72    	vmovups xmm0,XMMWORD PTR [rsp+0x72]
  2161ad:	c5 f8 11 43 02       	vmovups XMMWORD PTR [rbx+0x2],xmm0
  2161b2:	48 81 c4 88 00 00 00 	add    rsp,0x88
  2161b9:	5b                   	pop    rbx
  2161ba:	41 5e                	pop    r14
  2161bc:	c3                   	ret    
  2161bd:	48 89 e0             	mov    rax,rsp
            return ([*]align(alignment) T)(undefined)[0..0];
  2161c0:	0f b7 0d 9f f6 fe ff 	movzx  ecx,WORD PTR [rip+0xfffffffffffef69f]        # 205866 <__unnamed_84+0x6>
  2161c7:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  2161cc:	8b 0d 90 f6 fe ff    	mov    ecx,DWORD PTR [rip+0xfffffffffffef690]        # 205862 <__unnamed_84+0x2>
  2161d2:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  2161d5:	31 c9                	xor    ecx,ecx
  2161d7:	31 d2                	xor    edx,edx
  2161d9:	e9 c7 00 00 00       	jmp    2162a5 <Allocator_alignedRealloc.76+0x265>
  2161de:	48 8d 4c 24 48       	lea    rcx,[rsp+0x48]
  2161e3:	66 c7 44 24 48 00 00 	mov    WORD PTR [rsp+0x48],0x0
  2161ea:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  2161ef:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  2161f3:	0f 85 ea fe ff ff    	jne    2160e3 <Allocator_alignedRealloc.76+0xa3>
  2161f9:	4c 8b 71 08          	mov    r14,QWORD PTR [rcx+0x8]
  2161fd:	48 8d 7c 24 08       	lea    rdi,[rsp+0x8]
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  216202:	b9 08 00 00 00       	mov    ecx,0x8
  216207:	4c 89 f2             	mov    rdx,r14
  21620a:	ff 16                	call   QWORD PTR [rsi]
  21620c:	0f b7 4c 24 08       	movzx  ecx,WORD PTR [rsp+0x8]
  216211:	66 85 c9             	test   cx,cx
  216214:	74 57                	je     21626d <Allocator_alignedRealloc.76+0x22d>
  216216:	0f b7 44 24 36       	movzx  eax,WORD PTR [rsp+0x36]
  21621b:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  216220:	48 89 e0             	mov    rax,rsp
  216223:	8b 54 24 32          	mov    edx,DWORD PTR [rsp+0x32]
  216227:	89 14 24             	mov    DWORD PTR [rsp],edx
  21622a:	eb 79                	jmp    2162a5 <Allocator_alignedRealloc.76+0x265>
        assert(byte_slice.len == byte_count);
  21622c:	4c 39 74 24 68       	cmp    QWORD PTR [rsp+0x68],r14
    if (!ok) {
  216231:	0f 85 91 00 00 00    	jne    2162c8 <Allocator_alignedRealloc.76+0x288>
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  216237:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  21623c:	48 b9 cd cc cc cc cc 	movabs rcx,0xcccccccccccccccd
  216243:	cc cc cc 
  216246:	4c 89 f2             	mov    rdx,r14
  216249:	c4 e2 f3 f6 d1       	mulx   rdx,rcx,rcx
  21624e:	66 c7 03 00 00       	mov    WORD PTR [rbx],0x0
  216253:	0f b7 4c 24 2a       	movzx  ecx,WORD PTR [rsp+0x2a]
  216258:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  21625c:	48 c1 ea 05          	shr    rdx,0x5
  216260:	8b 4c 24 26          	mov    ecx,DWORD PTR [rsp+0x26]
  216264:	89 4b 02             	mov    DWORD PTR [rbx+0x2],ecx
  216267:	48 89 43 08          	mov    QWORD PTR [rbx+0x8],rax
  21626b:	eb 4c                	jmp    2162b9 <Allocator_alignedRealloc.76+0x279>
        assert(byte_slice.len == byte_count);
  21626d:	4c 39 74 24 18       	cmp    QWORD PTR [rsp+0x18],r14
  216272:	75 54                	jne    2162c8 <Allocator_alignedRealloc.76+0x288>
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  216274:	48 8b 74 24 10       	mov    rsi,QWORD PTR [rsp+0x10]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  216279:	48 b8 cd cc cc cc cc 	movabs rax,0xcccccccccccccccd
  216280:	cc cc cc 
  216283:	4c 89 f2             	mov    rdx,r14
  216286:	c4 e2 fb f6 d0       	mulx   rdx,rax,rax
  21628b:	48 c1 ea 05          	shr    rdx,0x5
  21628f:	48 89 e0             	mov    rax,rsp
  216292:	8b 4c 24 2c          	mov    ecx,DWORD PTR [rsp+0x2c]
  216296:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  216299:	0f b7 4c 24 30       	movzx  ecx,WORD PTR [rsp+0x30]
  21629e:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  2162a3:	31 c9                	xor    ecx,ecx
            return self.alignedAlloc(T, alignment, n);
  2162a5:	66 89 0b             	mov    WORD PTR [rbx],cx
  2162a8:	0f b7 48 04          	movzx  ecx,WORD PTR [rax+0x4]
  2162ac:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  2162b0:	8b 00                	mov    eax,DWORD PTR [rax]
  2162b2:	89 43 02             	mov    DWORD PTR [rbx+0x2],eax
  2162b5:	48 89 73 08          	mov    QWORD PTR [rbx+0x8],rsi
  2162b9:	48 89 53 10          	mov    QWORD PTR [rbx+0x10],rdx
  2162bd:	48 81 c4 88 00 00 00 	add    rsp,0x88
  2162c4:	5b                   	pop    rbx
  2162c5:	41 5e                	pop    r14
  2162c7:	c3                   	ret    
            @panic("assertion failure");
  2162c8:	e8 53 2a ff ff       	call   208d20 <panic>
  2162cd:	0f 1f 00             	nop    DWORD PTR [rax]

00000000002162d0 <join.79>:
    }
};

/// Naively combines a series of strings with a separator.
/// Allocates memory for the result, which must be freed by the caller.
pub fn join(allocator: *Allocator, sep: u8, strings: ...) ![]u8 {
  2162d0:	55                   	push   rbp
  2162d1:	41 57                	push   r15
  2162d3:	41 56                	push   r14
  2162d5:	41 55                	push   r13
  2162d7:	41 54                	push   r12
  2162d9:	53                   	push   rbx
  2162da:	48 83 ec 58          	sub    rsp,0x58
  2162de:	49 89 cc             	mov    r12,rcx
  2162e1:	48 89 d3             	mov    rbx,rdx
  2162e4:	49 89 f2             	mov    r10,rsi
  2162e7:	49 89 ff             	mov    r15,rdi
    comptime assert(strings.len >= 1);
    var total_strings_len: usize = strings.len; // 1 sep per string
    {
        comptime var string_i = 0;
        inline while (string_i < strings.len) : (string_i += 1) {
            const arg = ([]const u8)(strings[string_i]);
  2162ea:	4c 8b 43 08          	mov    r8,QWORD PTR [rbx+0x8]
  2162ee:	4d 8b 6c 24 08       	mov    r13,QWORD PTR [r12+0x8]
            total_strings_len += arg.len;
  2162f3:	4d 01 c5             	add    r13,r8
        if (n == 0) {
  2162f6:	49 83 c5 02          	add    r13,0x2
  2162fa:	74 42                	je     21633e <join.79+0x6e>
  2162fc:	48 8d 7c 24 08       	lea    rdi,[rsp+0x8]
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  216301:	b9 01 00 00 00       	mov    ecx,0x1
  216306:	4c 89 d6             	mov    rsi,r10
  216309:	4c 89 ea             	mov    rdx,r13
  21630c:	4c 89 d5             	mov    rbp,r10
  21630f:	ff 55 00             	call   QWORD PTR [rbp+0x0]
  216312:	0f b7 44 24 08       	movzx  eax,WORD PTR [rsp+0x8]
  216317:	66 85 c0             	test   ax,ax
  21631a:	0f 84 e5 00 00 00    	je     216405 <join.79+0x135>
        }
    }

    const buf = try allocator.alloc(u8, total_strings_len);
  216320:	66 41 89 07          	mov    WORD PTR [r15],ax
  216324:	48 8b 44 24 50       	mov    rax,QWORD PTR [rsp+0x50]
  216329:	49 89 47 10          	mov    QWORD PTR [r15+0x10],rax
  21632d:	c5 f8 10 44 24 42    	vmovups xmm0,XMMWORD PTR [rsp+0x42]
  216333:	c4 c1 78 11 47 02    	vmovups XMMWORD PTR [r15+0x2],xmm0
  216339:	e9 df 05 00 00       	jmp    21691d <join.79+0x64d>
  21633e:	45 31 ed             	xor    r13d,r13d
    assert(dest.len >= source.len);
  216341:	4d 39 c5             	cmp    r13,r8
    if (!ok) {
  216344:	0f 82 e5 05 00 00    	jb     21692f <join.79+0x65f>
    for (source) |s, i|
  21634a:	4d 85 c0             	test   r8,r8
  21634d:	0f 84 8f 02 00 00    	je     2165e2 <join.79+0x312>
  216353:	48 8b 0b             	mov    rcx,QWORD PTR [rbx]
  216356:	49 81 f8 80 00 00 00 	cmp    r8,0x80
  21635d:	72 1a                	jb     216379 <join.79+0xa9>
  21635f:	4a 8d 04 01          	lea    rax,[rcx+r8*1]
  216363:	48 39 e8             	cmp    rax,rbp
  216366:	0f 86 be 00 00 00    	jbe    21642a <join.79+0x15a>
  21636c:	49 8d 04 28          	lea    rax,[r8+rbp*1]
  216370:	48 39 c1             	cmp    rcx,rax
  216373:	0f 83 b1 00 00 00    	jae    21642a <join.79+0x15a>
  216379:	31 d2                	xor    edx,edx
  21637b:	49 8d 40 ff          	lea    rax,[r8-0x1]
  21637f:	48 29 d0             	sub    rax,rdx
  216382:	4c 89 c6             	mov    rsi,r8
  216385:	48 83 e6 07          	and    rsi,0x7
  216389:	74 17                	je     2163a2 <join.79+0xd2>
  21638b:	48 f7 de             	neg    rsi
  21638e:	66 90                	xchg   ax,ax
  216390:	0f b6 1c 11          	movzx  ebx,BYTE PTR [rcx+rdx*1]
        dest[i] = s;
  216394:	88 5c 15 00          	mov    BYTE PTR [rbp+rdx*1+0x0],bl
    for (source) |s, i|
  216398:	48 83 c2 01          	add    rdx,0x1
  21639c:	48 83 c6 01          	add    rsi,0x1
  2163a0:	75 ee                	jne    216390 <join.79+0xc0>
  2163a2:	48 83 f8 07          	cmp    rax,0x7
  2163a6:	0f 82 36 02 00 00    	jb     2165e2 <join.79+0x312>
  2163ac:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  2163b0:	0f b6 04 11          	movzx  eax,BYTE PTR [rcx+rdx*1]
        dest[i] = s;
  2163b4:	88 44 15 00          	mov    BYTE PTR [rbp+rdx*1+0x0],al
    for (source) |s, i|
  2163b8:	0f b6 44 11 01       	movzx  eax,BYTE PTR [rcx+rdx*1+0x1]
        dest[i] = s;
  2163bd:	88 44 15 01          	mov    BYTE PTR [rbp+rdx*1+0x1],al
    for (source) |s, i|
  2163c1:	0f b6 44 11 02       	movzx  eax,BYTE PTR [rcx+rdx*1+0x2]
        dest[i] = s;
  2163c6:	88 44 15 02          	mov    BYTE PTR [rbp+rdx*1+0x2],al
    for (source) |s, i|
  2163ca:	0f b6 44 11 03       	movzx  eax,BYTE PTR [rcx+rdx*1+0x3]
        dest[i] = s;
  2163cf:	88 44 15 03          	mov    BYTE PTR [rbp+rdx*1+0x3],al
    for (source) |s, i|
  2163d3:	0f b6 44 11 04       	movzx  eax,BYTE PTR [rcx+rdx*1+0x4]
        dest[i] = s;
  2163d8:	88 44 15 04          	mov    BYTE PTR [rbp+rdx*1+0x4],al
    for (source) |s, i|
  2163dc:	0f b6 44 11 05       	movzx  eax,BYTE PTR [rcx+rdx*1+0x5]
        dest[i] = s;
  2163e1:	88 44 15 05          	mov    BYTE PTR [rbp+rdx*1+0x5],al
    for (source) |s, i|
  2163e5:	0f b6 44 11 06       	movzx  eax,BYTE PTR [rcx+rdx*1+0x6]
        dest[i] = s;
  2163ea:	88 44 15 06          	mov    BYTE PTR [rbp+rdx*1+0x6],al
    for (source) |s, i|
  2163ee:	0f b6 44 11 07       	movzx  eax,BYTE PTR [rcx+rdx*1+0x7]
        dest[i] = s;
  2163f3:	88 44 15 07          	mov    BYTE PTR [rbp+rdx*1+0x7],al
    for (source) |s, i|
  2163f7:	48 83 c2 08          	add    rdx,0x8
  2163fb:	49 39 d0             	cmp    r8,rdx
  2163fe:	75 b0                	jne    2163b0 <join.79+0xe0>
  216400:	e9 dd 01 00 00       	jmp    2165e2 <join.79+0x312>
  216405:	49 89 ea             	mov    r10,rbp
        assert(byte_slice.len == byte_count);
  216408:	4c 39 6c 24 18       	cmp    QWORD PTR [rsp+0x18],r13
  21640d:	0f 85 1c 05 00 00    	jne    21692f <join.79+0x65f>
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  216413:	48 8b 6c 24 10       	mov    rbp,QWORD PTR [rsp+0x10]
    errdefer allocator.free(buf);

    var buf_index: usize = 0;
    comptime var string_i = 0;
    inline while (true) {
        const arg = ([]const u8)(strings[string_i]);
  216418:	4c 8b 43 08          	mov    r8,QWORD PTR [rbx+0x8]
    assert(dest.len >= source.len);
  21641c:	4d 39 c5             	cmp    r13,r8
  21641f:	0f 83 25 ff ff ff    	jae    21634a <join.79+0x7a>
  216425:	e9 05 05 00 00       	jmp    21692f <join.79+0x65f>
    for (source) |s, i|
  21642a:	4c 89 c2             	mov    rdx,r8
  21642d:	48 83 e2 80          	and    rdx,0xffffffffffffff80
  216431:	48 8d 42 80          	lea    rax,[rdx-0x80]
  216435:	48 89 c7             	mov    rdi,rax
  216438:	48 c1 ef 07          	shr    rdi,0x7
  21643c:	8d 77 01             	lea    esi,[rdi+0x1]
  21643f:	83 e6 03             	and    esi,0x3
  216442:	48 3d 80 01 00 00    	cmp    rax,0x180
  216448:	73 10                	jae    21645a <join.79+0x18a>
  21644a:	31 ff                	xor    edi,edi
  21644c:	48 85 f6             	test   rsi,rsi
  21644f:	0f 85 38 01 00 00    	jne    21658d <join.79+0x2bd>
  216455:	e9 7f 01 00 00       	jmp    2165d9 <join.79+0x309>
  21645a:	48 8d 46 ff          	lea    rax,[rsi-0x1]
  21645e:	48 29 f8             	sub    rax,rdi
  216461:	31 ff                	xor    edi,edi
  216463:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21646a:	84 00 00 00 00 00 
  216470:	c5 fc 10 04 39       	vmovups ymm0,YMMWORD PTR [rcx+rdi*1]
  216475:	c5 fc 10 4c 39 20    	vmovups ymm1,YMMWORD PTR [rcx+rdi*1+0x20]
  21647b:	c5 fc 10 54 39 40    	vmovups ymm2,YMMWORD PTR [rcx+rdi*1+0x40]
  216481:	c5 fc 10 5c 39 60    	vmovups ymm3,YMMWORD PTR [rcx+rdi*1+0x60]
        dest[i] = s;
  216487:	c5 fc 11 44 3d 00    	vmovups YMMWORD PTR [rbp+rdi*1+0x0],ymm0
  21648d:	c5 fc 11 4c 3d 20    	vmovups YMMWORD PTR [rbp+rdi*1+0x20],ymm1
  216493:	c5 fc 11 54 3d 40    	vmovups YMMWORD PTR [rbp+rdi*1+0x40],ymm2
  216499:	c5 fc 11 5c 3d 60    	vmovups YMMWORD PTR [rbp+rdi*1+0x60],ymm3
    for (source) |s, i|
  21649f:	c5 fc 10 84 39 80 00 	vmovups ymm0,YMMWORD PTR [rcx+rdi*1+0x80]
  2164a6:	00 00 
  2164a8:	c5 fc 10 8c 39 a0 00 	vmovups ymm1,YMMWORD PTR [rcx+rdi*1+0xa0]
  2164af:	00 00 
  2164b1:	c5 fc 10 94 39 c0 00 	vmovups ymm2,YMMWORD PTR [rcx+rdi*1+0xc0]
  2164b8:	00 00 
  2164ba:	c5 fc 10 9c 39 e0 00 	vmovups ymm3,YMMWORD PTR [rcx+rdi*1+0xe0]
  2164c1:	00 00 
        dest[i] = s;
  2164c3:	c5 fc 11 84 3d 80 00 	vmovups YMMWORD PTR [rbp+rdi*1+0x80],ymm0
  2164ca:	00 00 
  2164cc:	c5 fc 11 8c 3d a0 00 	vmovups YMMWORD PTR [rbp+rdi*1+0xa0],ymm1
  2164d3:	00 00 
  2164d5:	c5 fc 11 94 3d c0 00 	vmovups YMMWORD PTR [rbp+rdi*1+0xc0],ymm2
  2164dc:	00 00 
  2164de:	c5 fc 11 9c 3d e0 00 	vmovups YMMWORD PTR [rbp+rdi*1+0xe0],ymm3
  2164e5:	00 00 
    for (source) |s, i|
  2164e7:	c5 fc 10 84 39 00 01 	vmovups ymm0,YMMWORD PTR [rcx+rdi*1+0x100]
  2164ee:	00 00 
  2164f0:	c5 fc 10 8c 39 20 01 	vmovups ymm1,YMMWORD PTR [rcx+rdi*1+0x120]
  2164f7:	00 00 
  2164f9:	c5 fc 10 94 39 40 01 	vmovups ymm2,YMMWORD PTR [rcx+rdi*1+0x140]
  216500:	00 00 
  216502:	c5 fc 10 9c 39 60 01 	vmovups ymm3,YMMWORD PTR [rcx+rdi*1+0x160]
  216509:	00 00 
        dest[i] = s;
  21650b:	c5 fc 11 84 3d 00 01 	vmovups YMMWORD PTR [rbp+rdi*1+0x100],ymm0
  216512:	00 00 
  216514:	c5 fc 11 8c 3d 20 01 	vmovups YMMWORD PTR [rbp+rdi*1+0x120],ymm1
  21651b:	00 00 
  21651d:	c5 fc 11 94 3d 40 01 	vmovups YMMWORD PTR [rbp+rdi*1+0x140],ymm2
  216524:	00 00 
  216526:	c5 fc 11 9c 3d 60 01 	vmovups YMMWORD PTR [rbp+rdi*1+0x160],ymm3
  21652d:	00 00 
    for (source) |s, i|
  21652f:	c5 fc 10 84 39 80 01 	vmovups ymm0,YMMWORD PTR [rcx+rdi*1+0x180]
  216536:	00 00 
  216538:	c5 fc 10 8c 39 a0 01 	vmovups ymm1,YMMWORD PTR [rcx+rdi*1+0x1a0]
  21653f:	00 00 
  216541:	c5 fc 10 94 39 c0 01 	vmovups ymm2,YMMWORD PTR [rcx+rdi*1+0x1c0]
  216548:	00 00 
  21654a:	c5 fc 10 9c 39 e0 01 	vmovups ymm3,YMMWORD PTR [rcx+rdi*1+0x1e0]
  216551:	00 00 
        dest[i] = s;
  216553:	c5 fc 11 84 3d 80 01 	vmovups YMMWORD PTR [rbp+rdi*1+0x180],ymm0
  21655a:	00 00 
  21655c:	c5 fc 11 8c 3d a0 01 	vmovups YMMWORD PTR [rbp+rdi*1+0x1a0],ymm1
  216563:	00 00 
  216565:	c5 fc 11 94 3d c0 01 	vmovups YMMWORD PTR [rbp+rdi*1+0x1c0],ymm2
  21656c:	00 00 
  21656e:	c5 fc 11 9c 3d e0 01 	vmovups YMMWORD PTR [rbp+rdi*1+0x1e0],ymm3
  216575:	00 00 
    for (source) |s, i|
  216577:	48 81 c7 00 02 00 00 	add    rdi,0x200
  21657e:	48 83 c0 04          	add    rax,0x4
  216582:	0f 85 e8 fe ff ff    	jne    216470 <join.79+0x1a0>
  216588:	48 85 f6             	test   rsi,rsi
  21658b:	74 4c                	je     2165d9 <join.79+0x309>
  21658d:	48 83 c7 60          	add    rdi,0x60
  216591:	48 f7 de             	neg    rsi
  216594:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21659b:	00 00 00 00 00 
  2165a0:	c5 fc 10 44 39 a0    	vmovups ymm0,YMMWORD PTR [rcx+rdi*1-0x60]
  2165a6:	c5 fc 10 4c 39 c0    	vmovups ymm1,YMMWORD PTR [rcx+rdi*1-0x40]
  2165ac:	c5 fc 10 54 39 e0    	vmovups ymm2,YMMWORD PTR [rcx+rdi*1-0x20]
  2165b2:	c5 fc 10 1c 39       	vmovups ymm3,YMMWORD PTR [rcx+rdi*1]
        dest[i] = s;
  2165b7:	c5 fc 11 44 3d a0    	vmovups YMMWORD PTR [rbp+rdi*1-0x60],ymm0
  2165bd:	c5 fc 11 4c 3d c0    	vmovups YMMWORD PTR [rbp+rdi*1-0x40],ymm1
  2165c3:	c5 fc 11 54 3d e0    	vmovups YMMWORD PTR [rbp+rdi*1-0x20],ymm2
  2165c9:	c5 fc 11 5c 3d 00    	vmovups YMMWORD PTR [rbp+rdi*1+0x0],ymm3
    for (source) |s, i|
  2165cf:	48 83 ef 80          	sub    rdi,0xffffffffffffff80
  2165d3:	48 83 c6 01          	add    rsi,0x1
  2165d7:	75 c7                	jne    2165a0 <join.79+0x2d0>
  2165d9:	49 39 d0             	cmp    r8,rdx
  2165dc:	0f 85 99 fd ff ff    	jne    21637b <join.79+0xab>
        string_i += 1;
        copy(u8, buf[buf_index..], arg);
        buf_index += arg.len;
        if (string_i >= strings.len) break;
        if (buf[buf_index - 1] != sep) {
  2165e2:	42 80 7c 05 ff 2f    	cmp    BYTE PTR [rbp+r8*1-0x1],0x2f
  2165e8:	74 0a                	je     2165f4 <join.79+0x324>
            buf[buf_index] = sep;
  2165ea:	42 c6 44 05 00 2f    	mov    BYTE PTR [rbp+r8*1+0x0],0x2f
            buf_index += 1;
  2165f0:	49 83 c0 01          	add    r8,0x1
        const arg = ([]const u8)(strings[string_i]);
  2165f4:	4d 8b 74 24 08       	mov    r14,QWORD PTR [r12+0x8]
        copy(u8, buf[buf_index..], arg);
  2165f9:	4c 89 e8             	mov    rax,r13
  2165fc:	4c 29 c0             	sub    rax,r8
    assert(dest.len >= source.len);
  2165ff:	4c 39 f0             	cmp    rax,r14
  216602:	0f 82 27 03 00 00    	jb     21692f <join.79+0x65f>
    for (source) |s, i|
  216608:	4d 85 f6             	test   r14,r14
  21660b:	0f 84 84 02 00 00    	je     216895 <join.79+0x5c5>
  216611:	49 8b 0c 24          	mov    rcx,QWORD PTR [r12]
  216615:	4d 8d 0c 28          	lea    r9,[r8+rbp*1]
  216619:	49 81 fe 80 00 00 00 	cmp    r14,0x80
  216620:	72 1d                	jb     21663f <join.79+0x36f>
  216622:	4a 8d 04 31          	lea    rax,[rcx+r14*1]
  216626:	49 39 c1             	cmp    r9,rax
  216629:	0f 83 b5 00 00 00    	jae    2166e4 <join.79+0x414>
  21662f:	4b 8d 04 30          	lea    rax,[r8+r14*1]
  216633:	48 01 e8             	add    rax,rbp
  216636:	48 39 c1             	cmp    rcx,rax
  216639:	0f 83 a5 00 00 00    	jae    2166e4 <join.79+0x414>
  21663f:	31 d2                	xor    edx,edx
  216641:	49 8d 46 ff          	lea    rax,[r14-0x1]
  216645:	48 29 d0             	sub    rax,rdx
  216648:	4c 89 f6             	mov    rsi,r14
  21664b:	48 83 e6 07          	and    rsi,0x7
  21664f:	74 21                	je     216672 <join.79+0x3a2>
  216651:	48 f7 de             	neg    rsi
  216654:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21665b:	00 00 00 00 00 
  216660:	0f b6 1c 11          	movzx  ebx,BYTE PTR [rcx+rdx*1]
        dest[i] = s;
  216664:	41 88 1c 11          	mov    BYTE PTR [r9+rdx*1],bl
    for (source) |s, i|
  216668:	48 83 c2 01          	add    rdx,0x1
  21666c:	48 83 c6 01          	add    rsi,0x1
  216670:	75 ee                	jne    216660 <join.79+0x390>
  216672:	48 83 f8 07          	cmp    rax,0x7
  216676:	0f 82 19 02 00 00    	jb     216895 <join.79+0x5c5>
  21667c:	49 8d 04 28          	lea    rax,[r8+rbp*1]
  216680:	48 83 c0 07          	add    rax,0x7
  216684:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21668b:	00 00 00 00 00 
  216690:	0f b6 1c 11          	movzx  ebx,BYTE PTR [rcx+rdx*1]
        dest[i] = s;
  216694:	88 5c 10 f9          	mov    BYTE PTR [rax+rdx*1-0x7],bl
    for (source) |s, i|
  216698:	0f b6 5c 11 01       	movzx  ebx,BYTE PTR [rcx+rdx*1+0x1]
        dest[i] = s;
  21669d:	88 5c 10 fa          	mov    BYTE PTR [rax+rdx*1-0x6],bl
    for (source) |s, i|
  2166a1:	0f b6 5c 11 02       	movzx  ebx,BYTE PTR [rcx+rdx*1+0x2]
        dest[i] = s;
  2166a6:	88 5c 10 fb          	mov    BYTE PTR [rax+rdx*1-0x5],bl
    for (source) |s, i|
  2166aa:	0f b6 5c 11 03       	movzx  ebx,BYTE PTR [rcx+rdx*1+0x3]
        dest[i] = s;
  2166af:	88 5c 10 fc          	mov    BYTE PTR [rax+rdx*1-0x4],bl
    for (source) |s, i|
  2166b3:	0f b6 5c 11 04       	movzx  ebx,BYTE PTR [rcx+rdx*1+0x4]
        dest[i] = s;
  2166b8:	88 5c 10 fd          	mov    BYTE PTR [rax+rdx*1-0x3],bl
    for (source) |s, i|
  2166bc:	0f b6 5c 11 05       	movzx  ebx,BYTE PTR [rcx+rdx*1+0x5]
        dest[i] = s;
  2166c1:	88 5c 10 fe          	mov    BYTE PTR [rax+rdx*1-0x2],bl
    for (source) |s, i|
  2166c5:	0f b6 5c 11 06       	movzx  ebx,BYTE PTR [rcx+rdx*1+0x6]
        dest[i] = s;
  2166ca:	88 5c 10 ff          	mov    BYTE PTR [rax+rdx*1-0x1],bl
    for (source) |s, i|
  2166ce:	0f b6 5c 11 07       	movzx  ebx,BYTE PTR [rcx+rdx*1+0x7]
        dest[i] = s;
  2166d3:	88 1c 10             	mov    BYTE PTR [rax+rdx*1],bl
    for (source) |s, i|
  2166d6:	48 83 c2 08          	add    rdx,0x8
  2166da:	49 39 d6             	cmp    r14,rdx
  2166dd:	75 b1                	jne    216690 <join.79+0x3c0>
  2166df:	e9 b1 01 00 00       	jmp    216895 <join.79+0x5c5>
  2166e4:	4c 89 f2             	mov    rdx,r14
  2166e7:	48 83 e2 80          	and    rdx,0xffffffffffffff80
  2166eb:	48 8d 72 80          	lea    rsi,[rdx-0x80]
  2166ef:	48 89 f0             	mov    rax,rsi
  2166f2:	48 c1 e8 07          	shr    rax,0x7
  2166f6:	8d 78 01             	lea    edi,[rax+0x1]
  2166f9:	83 e7 03             	and    edi,0x3
  2166fc:	48 81 fe 80 01 00 00 	cmp    rsi,0x180
  216703:	73 10                	jae    216715 <join.79+0x445>
  216705:	31 c0                	xor    eax,eax
  216707:	48 85 ff             	test   rdi,rdi
  21670a:	0f 85 38 01 00 00    	jne    216848 <join.79+0x578>
  216710:	e9 77 01 00 00       	jmp    21688c <join.79+0x5bc>
  216715:	49 8d 1c 28          	lea    rbx,[r8+rbp*1]
  216719:	48 81 c3 e0 01 00 00 	add    rbx,0x1e0
  216720:	48 8d 77 ff          	lea    rsi,[rdi-0x1]
  216724:	48 29 c6             	sub    rsi,rax
  216727:	31 c0                	xor    eax,eax
  216729:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  216730:	c5 fc 10 04 01       	vmovups ymm0,YMMWORD PTR [rcx+rax*1]
  216735:	c5 fc 10 4c 01 20    	vmovups ymm1,YMMWORD PTR [rcx+rax*1+0x20]
  21673b:	c5 fc 10 54 01 40    	vmovups ymm2,YMMWORD PTR [rcx+rax*1+0x40]
  216741:	c5 fc 10 5c 01 60    	vmovups ymm3,YMMWORD PTR [rcx+rax*1+0x60]
        dest[i] = s;
  216747:	c5 fc 11 84 03 20 fe 	vmovups YMMWORD PTR [rbx+rax*1-0x1e0],ymm0
  21674e:	ff ff 
  216750:	c5 fc 11 8c 03 40 fe 	vmovups YMMWORD PTR [rbx+rax*1-0x1c0],ymm1
  216757:	ff ff 
  216759:	c5 fc 11 94 03 60 fe 	vmovups YMMWORD PTR [rbx+rax*1-0x1a0],ymm2
  216760:	ff ff 
  216762:	c5 fc 11 9c 03 80 fe 	vmovups YMMWORD PTR [rbx+rax*1-0x180],ymm3
  216769:	ff ff 
    for (source) |s, i|
  21676b:	c5 fc 10 84 01 80 00 	vmovups ymm0,YMMWORD PTR [rcx+rax*1+0x80]
  216772:	00 00 
  216774:	c5 fc 10 8c 01 a0 00 	vmovups ymm1,YMMWORD PTR [rcx+rax*1+0xa0]
  21677b:	00 00 
  21677d:	c5 fc 10 94 01 c0 00 	vmovups ymm2,YMMWORD PTR [rcx+rax*1+0xc0]
  216784:	00 00 
  216786:	c5 fc 10 9c 01 e0 00 	vmovups ymm3,YMMWORD PTR [rcx+rax*1+0xe0]
  21678d:	00 00 
        dest[i] = s;
  21678f:	c5 fc 11 84 03 a0 fe 	vmovups YMMWORD PTR [rbx+rax*1-0x160],ymm0
  216796:	ff ff 
  216798:	c5 fc 11 8c 03 c0 fe 	vmovups YMMWORD PTR [rbx+rax*1-0x140],ymm1
  21679f:	ff ff 
  2167a1:	c5 fc 11 94 03 e0 fe 	vmovups YMMWORD PTR [rbx+rax*1-0x120],ymm2
  2167a8:	ff ff 
  2167aa:	c5 fc 11 9c 03 00 ff 	vmovups YMMWORD PTR [rbx+rax*1-0x100],ymm3
  2167b1:	ff ff 
    for (source) |s, i|
  2167b3:	c5 fc 10 84 01 00 01 	vmovups ymm0,YMMWORD PTR [rcx+rax*1+0x100]
  2167ba:	00 00 
  2167bc:	c5 fc 10 8c 01 20 01 	vmovups ymm1,YMMWORD PTR [rcx+rax*1+0x120]
  2167c3:	00 00 
  2167c5:	c5 fc 10 94 01 40 01 	vmovups ymm2,YMMWORD PTR [rcx+rax*1+0x140]
  2167cc:	00 00 
  2167ce:	c5 fc 10 9c 01 60 01 	vmovups ymm3,YMMWORD PTR [rcx+rax*1+0x160]
  2167d5:	00 00 
        dest[i] = s;
  2167d7:	c5 fc 11 84 03 20 ff 	vmovups YMMWORD PTR [rbx+rax*1-0xe0],ymm0
  2167de:	ff ff 
  2167e0:	c5 fc 11 8c 03 40 ff 	vmovups YMMWORD PTR [rbx+rax*1-0xc0],ymm1
  2167e7:	ff ff 
  2167e9:	c5 fc 11 94 03 60 ff 	vmovups YMMWORD PTR [rbx+rax*1-0xa0],ymm2
  2167f0:	ff ff 
  2167f2:	c5 fc 11 5c 03 80    	vmovups YMMWORD PTR [rbx+rax*1-0x80],ymm3
    for (source) |s, i|
  2167f8:	c5 fc 10 84 01 80 01 	vmovups ymm0,YMMWORD PTR [rcx+rax*1+0x180]
  2167ff:	00 00 
  216801:	c5 fc 10 8c 01 a0 01 	vmovups ymm1,YMMWORD PTR [rcx+rax*1+0x1a0]
  216808:	00 00 
  21680a:	c5 fc 10 94 01 c0 01 	vmovups ymm2,YMMWORD PTR [rcx+rax*1+0x1c0]
  216811:	00 00 
  216813:	c5 fc 10 9c 01 e0 01 	vmovups ymm3,YMMWORD PTR [rcx+rax*1+0x1e0]
  21681a:	00 00 
        dest[i] = s;
  21681c:	c5 fc 11 44 03 a0    	vmovups YMMWORD PTR [rbx+rax*1-0x60],ymm0
  216822:	c5 fc 11 4c 03 c0    	vmovups YMMWORD PTR [rbx+rax*1-0x40],ymm1
  216828:	c5 fc 11 54 03 e0    	vmovups YMMWORD PTR [rbx+rax*1-0x20],ymm2
  21682e:	c5 fc 11 1c 03       	vmovups YMMWORD PTR [rbx+rax*1],ymm3
    for (source) |s, i|
  216833:	48 05 00 02 00 00    	add    rax,0x200
  216839:	48 83 c6 04          	add    rsi,0x4
  21683d:	0f 85 ed fe ff ff    	jne    216730 <join.79+0x460>
  216843:	48 85 ff             	test   rdi,rdi
  216846:	74 44                	je     21688c <join.79+0x5bc>
  216848:	48 83 c0 60          	add    rax,0x60
  21684c:	48 f7 df             	neg    rdi
  21684f:	90                   	nop
  216850:	c5 fc 10 44 01 a0    	vmovups ymm0,YMMWORD PTR [rcx+rax*1-0x60]
  216856:	c5 fc 10 4c 01 c0    	vmovups ymm1,YMMWORD PTR [rcx+rax*1-0x40]
  21685c:	c5 fc 10 54 01 e0    	vmovups ymm2,YMMWORD PTR [rcx+rax*1-0x20]
  216862:	c5 fc 10 1c 01       	vmovups ymm3,YMMWORD PTR [rcx+rax*1]
        dest[i] = s;
  216867:	c4 c1 7c 11 44 01 a0 	vmovups YMMWORD PTR [r9+rax*1-0x60],ymm0
  21686e:	c4 c1 7c 11 4c 01 c0 	vmovups YMMWORD PTR [r9+rax*1-0x40],ymm1
  216875:	c4 c1 7c 11 54 01 e0 	vmovups YMMWORD PTR [r9+rax*1-0x20],ymm2
  21687c:	c4 c1 7c 11 1c 01    	vmovups YMMWORD PTR [r9+rax*1],ymm3
    for (source) |s, i|
  216882:	48 83 e8 80          	sub    rax,0xffffffffffffff80
  216886:	48 83 c7 01          	add    rdi,0x1
  21688a:	75 c4                	jne    216850 <join.79+0x580>
  21688c:	49 39 d6             	cmp    r14,rdx
  21688f:	0f 85 ac fd ff ff    	jne    216641 <join.79+0x371>
        if (n == 0) {
  216895:	4d 01 c6             	add    r14,r8
  216898:	74 40                	je     2168da <join.79+0x60a>
        assert(n <= old_mem.len);
  21689a:	4d 39 f5             	cmp    r13,r14
  21689d:	0f 82 8c 00 00 00    	jb     21692f <join.79+0x65f>
        const byte_slice = self.reallocFn(self, @sliceToBytes(old_mem), byte_count, alignment) catch unreachable;
  2168a3:	49 8b 42 08          	mov    rax,QWORD PTR [r10+0x8]
  2168a7:	48 89 6c 24 20       	mov    QWORD PTR [rsp+0x20],rbp
  2168ac:	4c 89 6c 24 28       	mov    QWORD PTR [rsp+0x28],r13
  2168b1:	48 8d 7c 24 08       	lea    rdi,[rsp+0x8]
  2168b6:	48 8d 54 24 20       	lea    rdx,[rsp+0x20]
  2168bb:	41 b8 01 00 00 00    	mov    r8d,0x1
  2168c1:	4c 89 d6             	mov    rsi,r10
  2168c4:	4c 89 f1             	mov    rcx,r14
  2168c7:	c5 f8 77             	vzeroupper 
  2168ca:	ff d0                	call   rax
        assert(byte_slice.len == byte_count);
  2168cc:	4c 39 74 24 18       	cmp    QWORD PTR [rsp+0x18],r14
  2168d1:	75 5c                	jne    21692f <join.79+0x65f>
        const byte_slice = self.reallocFn(self, @sliceToBytes(old_mem), byte_count, alignment) catch unreachable;
  2168d3:	48 8b 6c 24 10       	mov    rbp,QWORD PTR [rsp+0x10]
  2168d8:	eb 23                	jmp    2168fd <join.79+0x62d>
        if (bytes.len == 0) return;
  2168da:	4d 85 ed             	test   r13,r13
  2168dd:	74 1b                	je     2168fa <join.79+0x62a>
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  2168df:	49 8b 42 10          	mov    rax,QWORD PTR [r10+0x10]
  2168e3:	48 89 6c 24 30       	mov    QWORD PTR [rsp+0x30],rbp
  2168e8:	4c 89 6c 24 38       	mov    QWORD PTR [rsp+0x38],r13
  2168ed:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
  2168f2:	4c 89 d7             	mov    rdi,r10
  2168f5:	c5 f8 77             	vzeroupper 
  2168f8:	ff d0                	call   rax
  2168fa:	45 31 f6             	xor    r14d,r14d
        }
    }

    return allocator.shrink(u8, buf, buf_index);
  2168fd:	66 41 c7 07 00 00    	mov    WORD PTR [r15],0x0
  216903:	0f b7 44 24 06       	movzx  eax,WORD PTR [rsp+0x6]
  216908:	66 41 89 47 06       	mov    WORD PTR [r15+0x6],ax
  21690d:	8b 44 24 02          	mov    eax,DWORD PTR [rsp+0x2]
  216911:	41 89 47 02          	mov    DWORD PTR [r15+0x2],eax
  216915:	49 89 6f 08          	mov    QWORD PTR [r15+0x8],rbp
  216919:	4d 89 77 10          	mov    QWORD PTR [r15+0x10],r14
  21691d:	48 83 c4 58          	add    rsp,0x58
  216921:	5b                   	pop    rbx
  216922:	41 5c                	pop    r12
  216924:	41 5d                	pop    r13
  216926:	41 5e                	pop    r14
  216928:	41 5f                	pop    r15
  21692a:	5d                   	pop    rbp
  21692b:	c5 f8 77             	vzeroupper 
  21692e:	c3                   	ret    
            @panic("assertion failure");
  21692f:	c5 f8 77             	vzeroupper 
  216932:	e8 e9 23 ff ff       	call   208d20 <panic>
  216937:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  21693e:	00 00 

0000000000216940 <DirectAllocator_alloc>:
    fn alloc(allocator: *Allocator, n: usize, alignment: u29) ![]u8 {
  216940:	41 57                	push   r15
  216942:	41 56                	push   r14
  216944:	41 55                	push   r13
  216946:	41 54                	push   r12
  216948:	53                   	push   rbx
  216949:	48 83 ec 10          	sub    rsp,0x10
  21694d:	41 89 cc             	mov    r12d,ecx
  216950:	49 89 d6             	mov    r14,rdx
  216953:	49 89 ff             	mov    r15,rdi
  216956:	45 89 e5             	mov    r13d,r12d
  216959:	41 81 e5 ff ff ff 1f 	and    r13d,0x1fffffff
                const alloc_size = if (alignment <= os.page_size) n else n + alignment;
  216960:	31 c0                	xor    eax,eax
  216962:	41 81 fd 01 10 00 00 	cmp    r13d,0x1001
  216969:	4c 89 eb             	mov    rbx,r13
  21696c:	48 0f 42 d8          	cmovb  rbx,rax
  216970:	4a 8d 34 33          	lea    rsi,[rbx+r14*1]
    arg3: usize,
    arg4: usize,
    arg5: usize,
    arg6: usize,
) usize {
    return asm volatile ("syscall"
  216974:	b8 09 00 00 00       	mov    eax,0x9
  216979:	bf 00 00 00 00       	mov    edi,0x0
  21697e:	ba 03 00 00 00       	mov    edx,0x3
  216983:	41 ba 22 00 00 00    	mov    r10d,0x22
  216989:	49 c7 c0 ff ff ff ff 	mov    r8,0xffffffffffffffff
  216990:	45 31 c9             	xor    r9d,r9d
  216993:	0f 05                	syscall 
  216995:	48 89 c1             	mov    rcx,rax
                if (addr == p.MAP_FAILED) return error.OutOfMemory;
  216998:	48 83 f9 ff          	cmp    rcx,0xffffffffffffffff
  21699c:	74 55                	je     2169f3 <DirectAllocator_alloc+0xb3>
                if (alloc_size == n) return @intToPtr([*]u8, addr)[0..n];
  21699e:	48 85 db             	test   rbx,rbx
  2169a1:	74 6a                	je     216a0d <DirectAllocator_alloc+0xcd>
                const aligned_addr = (addr & ~usize(alignment - 1)) + alignment;
  2169a3:	41 81 c4 ff ff ff 1f 	add    r12d,0x1fffffff
  2169aa:	41 f7 d4             	not    r12d
  2169ad:	49 81 cc 00 00 00 e0 	or     r12,0xffffffffe0000000
  2169b4:	49 21 cc             	and    r12,rcx
  2169b7:	4d 01 ec             	add    r12,r13
                const unused_len = aligned_addr - 1 - unused_start;
  2169ba:	48 89 ce             	mov    rsi,rcx
  2169bd:	48 f7 d6             	not    rsi
  2169c0:	4c 01 e6             	add    rsi,r12
    return asm volatile ("syscall"
  2169c3:	b8 0b 00 00 00       	mov    eax,0xb
  2169c8:	48 89 cf             	mov    rdi,rcx
  2169cb:	0f 05                	syscall 
  2169cd:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
    if (!ok) {
  2169d3:	73 69                	jae    216a3e <DirectAllocator_alloc+0xfe>
                return @intToPtr([*]u8, aligned_addr)[0..n];
  2169d5:	66 41 c7 07 00 00    	mov    WORD PTR [r15],0x0
  2169db:	0f b7 44 24 08       	movzx  eax,WORD PTR [rsp+0x8]
  2169e0:	66 41 89 47 06       	mov    WORD PTR [r15+0x6],ax
  2169e5:	8b 44 24 04          	mov    eax,DWORD PTR [rsp+0x4]
  2169e9:	41 89 47 02          	mov    DWORD PTR [r15+0x2],eax
  2169ed:	4d 89 67 08          	mov    QWORD PTR [r15+0x8],r12
  2169f1:	eb 36                	jmp    216a29 <DirectAllocator_alloc+0xe9>
                if (addr == p.MAP_FAILED) return error.OutOfMemory;
  2169f3:	48 8b 05 0e 00 ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffff000e]        # 206a08 <__unnamed_85+0x10>
  2169fa:	49 89 47 10          	mov    QWORD PTR [r15+0x10],rax
  2169fe:	c5 f8 10 05 f2 ff fe 	vmovups xmm0,XMMWORD PTR [rip+0xfffffffffffefff2]        # 2069f8 <__unnamed_85>
  216a05:	ff 
  216a06:	c4 c1 78 11 07       	vmovups XMMWORD PTR [r15],xmm0
  216a0b:	eb 20                	jmp    216a2d <DirectAllocator_alloc+0xed>
                if (alloc_size == n) return @intToPtr([*]u8, addr)[0..n];
  216a0d:	66 41 c7 07 00 00    	mov    WORD PTR [r15],0x0
  216a13:	0f b7 44 24 0e       	movzx  eax,WORD PTR [rsp+0xe]
  216a18:	66 41 89 47 06       	mov    WORD PTR [r15+0x6],ax
  216a1d:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  216a21:	41 89 47 02          	mov    DWORD PTR [r15+0x2],eax
  216a25:	49 89 4f 08          	mov    QWORD PTR [r15+0x8],rcx
  216a29:	4d 89 77 10          	mov    QWORD PTR [r15+0x10],r14
  216a2d:	4c 89 f8             	mov    rax,r15
  216a30:	48 83 c4 10          	add    rsp,0x10
  216a34:	5b                   	pop    rbx
  216a35:	41 5c                	pop    r12
  216a37:	41 5d                	pop    r13
  216a39:	41 5e                	pop    r14
  216a3b:	41 5f                	pop    r15
  216a3d:	c3                   	ret    
            @panic("assertion failure");
  216a3e:	e8 dd 22 ff ff       	call   208d20 <panic>
  216a43:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  216a4a:	84 00 00 00 00 00 

0000000000216a50 <DirectAllocator_realloc>:
    fn realloc(allocator: *Allocator, old_mem: []u8, new_size: usize, alignment: u29) ![]u8 {
  216a50:	55                   	push   rbp
  216a51:	41 57                	push   r15
  216a53:	41 56                	push   r14
  216a55:	41 55                	push   r13
  216a57:	41 54                	push   r12
  216a59:	53                   	push   rbx
  216a5a:	48 83 ec 28          	sub    rsp,0x28
  216a5e:	45 89 c4             	mov    r12d,r8d
  216a61:	48 89 cb             	mov    rbx,rcx
  216a64:	49 89 d6             	mov    r14,rdx
  216a67:	49 89 ff             	mov    r15,rdi
                if (new_size <= old_mem.len) {
  216a6a:	49 8b 76 08          	mov    rsi,QWORD PTR [r14+0x8]
  216a6e:	48 39 de             	cmp    rsi,rbx
  216a71:	0f 83 c7 00 00 00    	jae    216b3e <DirectAllocator_realloc+0xee>
                const alloc_size = if (alignment <= os.page_size) n else n + alignment;
  216a77:	45 89 e5             	mov    r13d,r12d
  216a7a:	41 81 e5 ff ff ff 1f 	and    r13d,0x1fffffff
  216a81:	31 c0                	xor    eax,eax
  216a83:	41 81 fd 01 10 00 00 	cmp    r13d,0x1001
  216a8a:	4c 89 ed             	mov    rbp,r13
  216a8d:	48 0f 42 e8          	cmovb  rbp,rax
  216a91:	48 8d 74 1d 00       	lea    rsi,[rbp+rbx*1+0x0]
    return asm volatile ("syscall"
  216a96:	b8 09 00 00 00       	mov    eax,0x9
  216a9b:	bf 00 00 00 00       	mov    edi,0x0
  216aa0:	ba 03 00 00 00       	mov    edx,0x3
  216aa5:	41 ba 22 00 00 00    	mov    r10d,0x22
  216aab:	49 c7 c0 ff ff ff ff 	mov    r8,0xffffffffffffffff
  216ab2:	45 31 c9             	xor    r9d,r9d
  216ab5:	0f 05                	syscall 
  216ab7:	48 89 c1             	mov    rcx,rax
                if (addr == p.MAP_FAILED) return error.OutOfMemory;
  216aba:	48 83 f9 ff          	cmp    rcx,0xffffffffffffffff
  216abe:	0f 84 d2 00 00 00    	je     216b96 <DirectAllocator_realloc+0x146>
                if (alloc_size == n) return @intToPtr([*]u8, addr)[0..n];
  216ac4:	48 85 ed             	test   rbp,rbp
  216ac7:	74 39                	je     216b02 <DirectAllocator_realloc+0xb2>
                const aligned_addr = (addr & ~usize(alignment - 1)) + alignment;
  216ac9:	41 81 c4 ff ff ff 1f 	add    r12d,0x1fffffff
  216ad0:	41 f7 d4             	not    r12d
  216ad3:	49 81 cc 00 00 00 e0 	or     r12,0xffffffffe0000000
  216ada:	49 21 cc             	and    r12,rcx
  216add:	4d 01 ec             	add    r12,r13
                const unused_len = aligned_addr - 1 - unused_start;
  216ae0:	48 89 ce             	mov    rsi,rcx
  216ae3:	48 f7 d6             	not    rsi
  216ae6:	4c 01 e6             	add    rsi,r12
    return asm volatile ("syscall"
  216ae9:	b8 0b 00 00 00       	mov    eax,0xb
  216aee:	48 89 cf             	mov    rdi,rcx
  216af1:	0f 05                	syscall 
  216af3:	4c 89 e1             	mov    rcx,r12
  216af6:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
    if (!ok) {
  216afc:	0f 83 74 01 00 00    	jae    216c76 <DirectAllocator_realloc+0x226>
    assert(dest.len >= source.len);
  216b02:	49 8b 76 08          	mov    rsi,QWORD PTR [r14+0x8]
  216b06:	48 89 dd             	mov    rbp,rbx
  216b09:	48 39 de             	cmp    rsi,rbx
  216b0c:	0f 87 64 01 00 00    	ja     216c76 <DirectAllocator_realloc+0x226>
    for (source) |s, i|
  216b12:	48 85 f6             	test   rsi,rsi
  216b15:	0f 84 29 01 00 00    	je     216c44 <DirectAllocator_realloc+0x1f4>
  216b1b:	48 8d 56 ff          	lea    rdx,[rsi-0x1]
  216b1f:	89 f0                	mov    eax,esi
  216b21:	83 e0 07             	and    eax,0x7
  216b24:	48 83 fa 07          	cmp    rdx,0x7
  216b28:	0f 83 88 00 00 00    	jae    216bb6 <DirectAllocator_realloc+0x166>
  216b2e:	31 d2                	xor    edx,edx
  216b30:	48 85 c0             	test   rax,rax
  216b33:	0f 85 f3 00 00 00    	jne    216c2c <DirectAllocator_realloc+0x1dc>
  216b39:	e9 06 01 00 00       	jmp    216c44 <DirectAllocator_realloc+0x1f4>
                    const base_addr = @ptrToInt(old_mem.ptr);
  216b3e:	49 8b 06             	mov    rax,QWORD PTR [r14]
                    const old_addr_end = base_addr + old_mem.len;
  216b41:	48 01 c6             	add    rsi,rax
                    const new_addr_end = base_addr + new_size;
  216b44:	48 8d 0c 18          	lea    rcx,[rax+rbx*1]
                    const rem = @rem(new_addr_end, os.page_size);
  216b48:	89 ca                	mov    edx,ecx
  216b4a:	81 e2 ff 0f 00 00    	and    edx,0xfff
                    const new_addr_end_rounded = new_addr_end + if (rem == 0) 0 else (os.page_size - rem);
  216b50:	bf 00 10 00 00       	mov    edi,0x1000
  216b55:	48 29 d7             	sub    rdi,rdx
  216b58:	48 85 d2             	test   rdx,rdx
  216b5b:	48 0f 44 fa          	cmove  rdi,rdx
  216b5f:	48 01 cf             	add    rdi,rcx
                    if (old_addr_end > new_addr_end_rounded) {
  216b62:	48 29 fe             	sub    rsi,rdi
  216b65:	76 0a                	jbe    216b71 <DirectAllocator_realloc+0x121>
  216b67:	b8 0b 00 00 00       	mov    eax,0xb
  216b6c:	0f 05                	syscall 
                    return old_mem[0..new_size];
  216b6e:	49 8b 06             	mov    rax,QWORD PTR [r14]
  216b71:	66 41 c7 07 00 00    	mov    WORD PTR [r15],0x0
  216b77:	0f b7 4c 24 10       	movzx  ecx,WORD PTR [rsp+0x10]
  216b7c:	66 41 89 4f 06       	mov    WORD PTR [r15+0x6],cx
  216b81:	8b 4c 24 0c          	mov    ecx,DWORD PTR [rsp+0xc]
  216b85:	41 89 4f 02          	mov    DWORD PTR [r15+0x2],ecx
  216b89:	49 89 47 08          	mov    QWORD PTR [r15+0x8],rax
  216b8d:	49 89 5f 10          	mov    QWORD PTR [r15+0x10],rbx
  216b91:	e9 ce 00 00 00       	jmp    216c64 <DirectAllocator_realloc+0x214>
                const result = try alloc(allocator, new_size, alignment);
  216b96:	66 41 c7 07 10 00    	mov    WORD PTR [r15],0x10
  216b9c:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
  216ba1:	49 89 47 10          	mov    QWORD PTR [r15+0x10],rax
  216ba5:	c5 f8 10 44 24 12    	vmovups xmm0,XMMWORD PTR [rsp+0x12]
  216bab:	c4 c1 78 11 47 02    	vmovups XMMWORD PTR [r15+0x2],xmm0
  216bb1:	e9 ae 00 00 00       	jmp    216c64 <DirectAllocator_realloc+0x214>
  216bb6:	48 29 c6             	sub    rsi,rax
  216bb9:	31 d2                	xor    edx,edx
  216bbb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  216bc0:	49 8b 3e             	mov    rdi,QWORD PTR [r14]
  216bc3:	0f b6 1c 17          	movzx  ebx,BYTE PTR [rdi+rdx*1]
        dest[i] = s;
  216bc7:	88 1c 11             	mov    BYTE PTR [rcx+rdx*1],bl
    for (source) |s, i|
  216bca:	49 8b 3e             	mov    rdi,QWORD PTR [r14]
  216bcd:	0f b6 5c 17 01       	movzx  ebx,BYTE PTR [rdi+rdx*1+0x1]
        dest[i] = s;
  216bd2:	88 5c 11 01          	mov    BYTE PTR [rcx+rdx*1+0x1],bl
    for (source) |s, i|
  216bd6:	49 8b 3e             	mov    rdi,QWORD PTR [r14]
  216bd9:	0f b6 5c 17 02       	movzx  ebx,BYTE PTR [rdi+rdx*1+0x2]
        dest[i] = s;
  216bde:	88 5c 11 02          	mov    BYTE PTR [rcx+rdx*1+0x2],bl
    for (source) |s, i|
  216be2:	49 8b 3e             	mov    rdi,QWORD PTR [r14]
  216be5:	0f b6 5c 17 03       	movzx  ebx,BYTE PTR [rdi+rdx*1+0x3]
        dest[i] = s;
  216bea:	88 5c 11 03          	mov    BYTE PTR [rcx+rdx*1+0x3],bl
    for (source) |s, i|
  216bee:	49 8b 3e             	mov    rdi,QWORD PTR [r14]
  216bf1:	0f b6 5c 17 04       	movzx  ebx,BYTE PTR [rdi+rdx*1+0x4]
        dest[i] = s;
  216bf6:	88 5c 11 04          	mov    BYTE PTR [rcx+rdx*1+0x4],bl
    for (source) |s, i|
  216bfa:	49 8b 3e             	mov    rdi,QWORD PTR [r14]
  216bfd:	0f b6 5c 17 05       	movzx  ebx,BYTE PTR [rdi+rdx*1+0x5]
        dest[i] = s;
  216c02:	88 5c 11 05          	mov    BYTE PTR [rcx+rdx*1+0x5],bl
    for (source) |s, i|
  216c06:	49 8b 3e             	mov    rdi,QWORD PTR [r14]
  216c09:	0f b6 5c 17 06       	movzx  ebx,BYTE PTR [rdi+rdx*1+0x6]
        dest[i] = s;
  216c0e:	88 5c 11 06          	mov    BYTE PTR [rcx+rdx*1+0x6],bl
    for (source) |s, i|
  216c12:	49 8b 3e             	mov    rdi,QWORD PTR [r14]
  216c15:	0f b6 5c 17 07       	movzx  ebx,BYTE PTR [rdi+rdx*1+0x7]
        dest[i] = s;
  216c1a:	88 5c 11 07          	mov    BYTE PTR [rcx+rdx*1+0x7],bl
    for (source) |s, i|
  216c1e:	48 83 c2 08          	add    rdx,0x8
  216c22:	48 39 d6             	cmp    rsi,rdx
  216c25:	75 99                	jne    216bc0 <DirectAllocator_realloc+0x170>
  216c27:	48 85 c0             	test   rax,rax
  216c2a:	74 18                	je     216c44 <DirectAllocator_realloc+0x1f4>
  216c2c:	48 f7 d8             	neg    rax
  216c2f:	90                   	nop
  216c30:	49 8b 36             	mov    rsi,QWORD PTR [r14]
  216c33:	0f b6 1c 16          	movzx  ebx,BYTE PTR [rsi+rdx*1]
        dest[i] = s;
  216c37:	88 1c 11             	mov    BYTE PTR [rcx+rdx*1],bl
    for (source) |s, i|
  216c3a:	48 83 c2 01          	add    rdx,0x1
  216c3e:	48 83 c0 01          	add    rax,0x1
  216c42:	75 ec                	jne    216c30 <DirectAllocator_realloc+0x1e0>
                return result;
  216c44:	66 41 c7 07 00 00    	mov    WORD PTR [r15],0x0
  216c4a:	0f b7 44 24 0a       	movzx  eax,WORD PTR [rsp+0xa]
  216c4f:	66 41 89 47 06       	mov    WORD PTR [r15+0x6],ax
  216c54:	8b 44 24 06          	mov    eax,DWORD PTR [rsp+0x6]
  216c58:	41 89 47 02          	mov    DWORD PTR [r15+0x2],eax
  216c5c:	49 89 4f 08          	mov    QWORD PTR [r15+0x8],rcx
  216c60:	49 89 6f 10          	mov    QWORD PTR [r15+0x10],rbp
  216c64:	4c 89 f8             	mov    rax,r15
  216c67:	48 83 c4 28          	add    rsp,0x28
  216c6b:	5b                   	pop    rbx
  216c6c:	41 5c                	pop    r12
  216c6e:	41 5d                	pop    r13
  216c70:	41 5e                	pop    r14
  216c72:	41 5f                	pop    r15
  216c74:	5d                   	pop    rbp
  216c75:	c3                   	ret    
            @panic("assertion failure");
  216c76:	e8 a5 20 ff ff       	call   208d20 <panic>
  216c7b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000216c80 <DirectAllocator_free>:
                _ = os.posix.munmap(@ptrToInt(bytes.ptr), bytes.len);
  216c80:	48 8b 3e             	mov    rdi,QWORD PTR [rsi]
  216c83:	48 8b 76 08          	mov    rsi,QWORD PTR [rsi+0x8]
  216c87:	b8 0b 00 00 00       	mov    eax,0xb
  216c8c:	0f 05                	syscall 
    fn free(allocator: *Allocator, bytes: []u8) void {
  216c8e:	c3                   	ret    
  216c8f:	90                   	nop

0000000000216c90 <ArenaAllocator_alloc>:
    fn alloc(allocator: *Allocator, n: usize, alignment: u29) ![]u8 {
  216c90:	55                   	push   rbp
  216c91:	41 57                	push   r15
  216c93:	41 56                	push   r14
  216c95:	41 55                	push   r13
  216c97:	41 54                	push   r12
  216c99:	53                   	push   rbx
  216c9a:	48 83 ec 58          	sub    rsp,0x58
  216c9e:	89 cb                	mov    ebx,ecx
  216ca0:	49 89 d7             	mov    r15,rdx
  216ca3:	49 89 f4             	mov    r12,rsi
  216ca6:	49 89 fe             	mov    r14,rdi
        var cur_node = if (self.buffer_list.last) |last_node| last_node else try self.createNode(0, n + alignment);
  216ca9:	49 8b 44 24 28       	mov    rax,QWORD PTR [r12+0x28]
  216cae:	81 e3 ff ff ff 1f    	and    ebx,0x1fffffff
  216cb4:	4e 8d 2c 3b          	lea    r13,[rbx+r15*1]
  216cb8:	48 85 c0             	test   rax,rax
  216cbb:	74 29                	je     216ce6 <ArenaAllocator_alloc+0x56>
            const cur_buf = cur_node.data[@sizeOf(BufNode)..];
  216cbd:	48 8b 70 10          	mov    rsi,QWORD PTR [rax+0x10]
  216cc1:	48 8b 48 18          	mov    rcx,QWORD PTR [rax+0x18]
  216cc5:	48 83 c1 e0          	add    rcx,0xffffffffffffffe0
            const addr = @ptrToInt(cur_buf.ptr) + self.end_index;
  216cc9:	49 8b 7c 24 38       	mov    rdi,QWORD PTR [r12+0x38]
  216cce:	48 8d 04 37          	lea    rax,[rdi+rsi*1]
  216cd2:	48 83 c0 20          	add    rax,0x20
  216cd6:	48 89 c2             	mov    rdx,rax
  216cd9:	48 c1 ea 20          	shr    rdx,0x20
  216cdd:	74 3f                	je     216d1e <ArenaAllocator_alloc+0x8e>
  216cdf:	31 d2                	xor    edx,edx
  216ce1:	48 f7 f3             	div    rbx
  216ce4:	eb 3c                	jmp    216d22 <ArenaAllocator_alloc+0x92>
  216ce6:	48 8d 7c 24 18       	lea    rdi,[rsp+0x18]
        var cur_node = if (self.buffer_list.last) |last_node| last_node else try self.createNode(0, n + alignment);
  216ceb:	31 d2                	xor    edx,edx
  216ced:	4c 89 e6             	mov    rsi,r12
  216cf0:	4c 89 e9             	mov    rcx,r13
  216cf3:	e8 68 03 00 00       	call   217060 <ArenaAllocator_createNode>
  216cf8:	0f b7 44 24 18       	movzx  eax,WORD PTR [rsp+0x18]
  216cfd:	66 85 c0             	test   ax,ax
  216d00:	0f 84 fe 00 00 00    	je     216e04 <ArenaAllocator_alloc+0x174>
  216d06:	66 41 89 06          	mov    WORD PTR [r14],ax
  216d0a:	48 8b 44 24 50       	mov    rax,QWORD PTR [rsp+0x50]
  216d0f:	49 89 46 10          	mov    QWORD PTR [r14+0x10],rax
  216d13:	c5 f8 10 44 24 42    	vmovups xmm0,XMMWORD PTR [rsp+0x42]
  216d19:	e9 ce 00 00 00       	jmp    216dec <ArenaAllocator_alloc+0x15c>
  216d1e:	31 d2                	xor    edx,edx
  216d20:	f7 f3                	div    ebx
            const march_forward_bytes = if (rem == 0) 0 else (alignment - rem);
  216d22:	48 89 d8             	mov    rax,rbx
  216d25:	48 29 d0             	sub    rax,rdx
  216d28:	48 85 d2             	test   rdx,rdx
  216d2b:	48 0f 44 c2          	cmove  rax,rdx
            const adjusted_index = self.end_index + march_forward_bytes;
  216d2f:	48 01 f8             	add    rax,rdi
            const new_end_index = adjusted_index + n;
  216d32:	4a 8d 14 38          	lea    rdx,[rax+r15*1]
            if (new_end_index > cur_buf.len) {
  216d36:	48 39 ca             	cmp    rdx,rcx
  216d39:	76 72                	jbe    216dad <ArenaAllocator_alloc+0x11d>
  216d3b:	48 8d 6c 24 08       	lea    rbp,[rsp+0x8]
                cur_node = try self.createNode(cur_buf.len, n + alignment);
  216d40:	48 89 ef             	mov    rdi,rbp
  216d43:	4c 89 e6             	mov    rsi,r12
  216d46:	48 89 ca             	mov    rdx,rcx
  216d49:	4c 89 e9             	mov    rcx,r13
  216d4c:	e8 0f 03 00 00       	call   217060 <ArenaAllocator_createNode>
  216d51:	0f b7 44 24 08       	movzx  eax,WORD PTR [rsp+0x8]
  216d56:	66 85 c0             	test   ax,ax
  216d59:	75 7e                	jne    216dd9 <ArenaAllocator_alloc+0x149>
  216d5b:	48 8b 44 24 10       	mov    rax,QWORD PTR [rsp+0x10]
            const cur_buf = cur_node.data[@sizeOf(BufNode)..];
  216d60:	48 8b 70 10          	mov    rsi,QWORD PTR [rax+0x10]
  216d64:	48 8b 48 18          	mov    rcx,QWORD PTR [rax+0x18]
  216d68:	48 83 c1 e0          	add    rcx,0xffffffffffffffe0
            const addr = @ptrToInt(cur_buf.ptr) + self.end_index;
  216d6c:	49 8b 7c 24 38       	mov    rdi,QWORD PTR [r12+0x38]
  216d71:	48 8d 04 37          	lea    rax,[rdi+rsi*1]
  216d75:	48 83 c0 20          	add    rax,0x20
  216d79:	48 89 c2             	mov    rdx,rax
  216d7c:	48 c1 ea 20          	shr    rdx,0x20
  216d80:	74 0e                	je     216d90 <ArenaAllocator_alloc+0x100>
  216d82:	31 d2                	xor    edx,edx
  216d84:	48 f7 f3             	div    rbx
  216d87:	eb 0b                	jmp    216d94 <ArenaAllocator_alloc+0x104>
  216d89:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  216d90:	31 d2                	xor    edx,edx
  216d92:	f7 f3                	div    ebx
            const march_forward_bytes = if (rem == 0) 0 else (alignment - rem);
  216d94:	48 89 d8             	mov    rax,rbx
  216d97:	48 29 d0             	sub    rax,rdx
  216d9a:	48 85 d2             	test   rdx,rdx
  216d9d:	48 0f 44 c2          	cmove  rax,rdx
            const adjusted_index = self.end_index + march_forward_bytes;
  216da1:	48 01 f8             	add    rax,rdi
            const new_end_index = adjusted_index + n;
  216da4:	4a 8d 14 38          	lea    rdx,[rax+r15*1]
            if (new_end_index > cur_buf.len) {
  216da8:	48 39 ca             	cmp    rdx,rcx
  216dab:	77 93                	ja     216d40 <ArenaAllocator_alloc+0xb0>
            self.end_index = new_end_index;
  216dad:	49 89 54 24 38       	mov    QWORD PTR [r12+0x38],rdx
            return result;
  216db2:	66 41 c7 06 00 00    	mov    WORD PTR [r14],0x0
  216db8:	0f b7 4c 24 06       	movzx  ecx,WORD PTR [rsp+0x6]
  216dbd:	66 41 89 4e 06       	mov    WORD PTR [r14+0x6],cx
            const result = cur_buf[adjusted_index..new_end_index];
  216dc2:	48 8d 44 06 20       	lea    rax,[rsi+rax*1+0x20]
            return result;
  216dc7:	8b 4c 24 02          	mov    ecx,DWORD PTR [rsp+0x2]
  216dcb:	41 89 4e 02          	mov    DWORD PTR [r14+0x2],ecx
  216dcf:	49 89 46 08          	mov    QWORD PTR [r14+0x8],rax
  216dd3:	4d 89 7e 10          	mov    QWORD PTR [r14+0x10],r15
  216dd7:	eb 19                	jmp    216df2 <ArenaAllocator_alloc+0x162>
                cur_node = try self.createNode(cur_buf.len, n + alignment);
  216dd9:	66 41 89 06          	mov    WORD PTR [r14],ax
  216ddd:	48 8b 44 24 3a       	mov    rax,QWORD PTR [rsp+0x3a]
  216de2:	49 89 46 10          	mov    QWORD PTR [r14+0x10],rax
  216de6:	c5 f8 10 44 24 2c    	vmovups xmm0,XMMWORD PTR [rsp+0x2c]
  216dec:	c4 c1 78 11 46 02    	vmovups XMMWORD PTR [r14+0x2],xmm0
  216df2:	4c 89 f0             	mov    rax,r14
  216df5:	48 83 c4 58          	add    rsp,0x58
  216df9:	5b                   	pop    rbx
  216dfa:	41 5c                	pop    r12
  216dfc:	41 5d                	pop    r13
  216dfe:	41 5e                	pop    r14
  216e00:	41 5f                	pop    r15
  216e02:	5d                   	pop    rbp
  216e03:	c3                   	ret    
        var cur_node = if (self.buffer_list.last) |last_node| last_node else try self.createNode(0, n + alignment);
  216e04:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
  216e09:	e9 af fe ff ff       	jmp    216cbd <ArenaAllocator_alloc+0x2d>
  216e0e:	66 90                	xchg   ax,ax

0000000000216e10 <ArenaAllocator_realloc>:
    fn realloc(allocator: *Allocator, old_mem: []u8, new_size: usize, alignment: u29) ![]u8 {
  216e10:	55                   	push   rbp
  216e11:	41 57                	push   r15
  216e13:	41 56                	push   r14
  216e15:	41 55                	push   r13
  216e17:	41 54                	push   r12
  216e19:	53                   	push   rbx
  216e1a:	48 83 ec 58          	sub    rsp,0x58
  216e1e:	45 89 c5             	mov    r13d,r8d
  216e21:	49 89 cf             	mov    r15,rcx
  216e24:	48 89 d3             	mov    rbx,rdx
  216e27:	49 89 f4             	mov    r12,rsi
  216e2a:	48 89 fd             	mov    rbp,rdi
        if (new_size <= old_mem.len) {
  216e2d:	4c 39 7b 08          	cmp    QWORD PTR [rbx+0x8],r15
  216e31:	73 43                	jae    216e76 <ArenaAllocator_realloc+0x66>
        var cur_node = if (self.buffer_list.last) |last_node| last_node else try self.createNode(0, n + alignment);
  216e33:	49 8b 44 24 28       	mov    rax,QWORD PTR [r12+0x28]
  216e38:	41 81 e5 ff ff ff 1f 	and    r13d,0x1fffffff
  216e3f:	4f 8d 34 2f          	lea    r14,[r15+r13*1]
  216e43:	48 85 c0             	test   rax,rax
  216e46:	74 54                	je     216e9c <ArenaAllocator_realloc+0x8c>
            const cur_buf = cur_node.data[@sizeOf(BufNode)..];
  216e48:	48 8b 70 10          	mov    rsi,QWORD PTR [rax+0x10]
  216e4c:	48 8b 48 18          	mov    rcx,QWORD PTR [rax+0x18]
  216e50:	48 83 c1 e0          	add    rcx,0xffffffffffffffe0
            const addr = @ptrToInt(cur_buf.ptr) + self.end_index;
  216e54:	49 8b 7c 24 38       	mov    rdi,QWORD PTR [r12+0x38]
  216e59:	48 8d 04 37          	lea    rax,[rdi+rsi*1]
  216e5d:	48 83 c0 20          	add    rax,0x20
  216e61:	48 89 c2             	mov    rdx,rax
  216e64:	48 c1 ea 20          	shr    rdx,0x20
  216e68:	48 89 6c 24 08       	mov    QWORD PTR [rsp+0x8],rbp
  216e6d:	75 77                	jne    216ee6 <ArenaAllocator_realloc+0xd6>
  216e6f:	31 d2                	xor    edx,edx
  216e71:	41 f7 f5             	div    r13d
  216e74:	eb 75                	jmp    216eeb <ArenaAllocator_realloc+0xdb>
            return old_mem[0..new_size];
  216e76:	48 8b 03             	mov    rax,QWORD PTR [rbx]
  216e79:	66 c7 45 00 00 00    	mov    WORD PTR [rbp+0x0],0x0
  216e7f:	0f b7 4c 24 1e       	movzx  ecx,WORD PTR [rsp+0x1e]
  216e84:	66 89 4d 06          	mov    WORD PTR [rbp+0x6],cx
  216e88:	8b 4c 24 1a          	mov    ecx,DWORD PTR [rsp+0x1a]
  216e8c:	89 4d 02             	mov    DWORD PTR [rbp+0x2],ecx
  216e8f:	48 89 45 08          	mov    QWORD PTR [rbp+0x8],rax
  216e93:	4c 89 7d 10          	mov    QWORD PTR [rbp+0x10],r15
  216e97:	e9 a2 00 00 00       	jmp    216f3e <ArenaAllocator_realloc+0x12e>
  216e9c:	48 8d 7c 24 30       	lea    rdi,[rsp+0x30]
        var cur_node = if (self.buffer_list.last) |last_node| last_node else try self.createNode(0, n + alignment);
  216ea1:	31 d2                	xor    edx,edx
  216ea3:	4c 89 e6             	mov    rsi,r12
  216ea6:	4c 89 f1             	mov    rcx,r14
  216ea9:	e8 b2 01 00 00       	call   217060 <ArenaAllocator_createNode>
  216eae:	0f b7 44 24 30       	movzx  eax,WORD PTR [rsp+0x30]
  216eb3:	66 85 c0             	test   ax,ax
  216eb6:	75 6e                	jne    216f26 <ArenaAllocator_realloc+0x116>
  216eb8:	48 8b 44 24 38       	mov    rax,QWORD PTR [rsp+0x38]
  216ebd:	eb 89                	jmp    216e48 <ArenaAllocator_realloc+0x38>
                cur_node = try self.createNode(cur_buf.len, n + alignment);
  216ebf:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
            const cur_buf = cur_node.data[@sizeOf(BufNode)..];
  216ec4:	48 8b 70 10          	mov    rsi,QWORD PTR [rax+0x10]
  216ec8:	48 8b 48 18          	mov    rcx,QWORD PTR [rax+0x18]
  216ecc:	48 83 c1 e0          	add    rcx,0xffffffffffffffe0
            const addr = @ptrToInt(cur_buf.ptr) + self.end_index;
  216ed0:	49 8b 7c 24 38       	mov    rdi,QWORD PTR [r12+0x38]
  216ed5:	48 8d 04 37          	lea    rax,[rdi+rsi*1]
  216ed9:	48 83 c0 20          	add    rax,0x20
  216edd:	48 89 c2             	mov    rdx,rax
  216ee0:	48 c1 ea 20          	shr    rdx,0x20
  216ee4:	74 89                	je     216e6f <ArenaAllocator_realloc+0x5f>
  216ee6:	31 d2                	xor    edx,edx
  216ee8:	49 f7 f5             	div    r13
            const march_forward_bytes = if (rem == 0) 0 else (alignment - rem);
  216eeb:	4c 89 ed             	mov    rbp,r13
  216eee:	48 29 d5             	sub    rbp,rdx
  216ef1:	48 85 d2             	test   rdx,rdx
  216ef4:	48 0f 44 ea          	cmove  rbp,rdx
            const adjusted_index = self.end_index + march_forward_bytes;
  216ef8:	48 01 fd             	add    rbp,rdi
            const new_end_index = adjusted_index + n;
  216efb:	49 8d 04 2f          	lea    rax,[r15+rbp*1]
            if (new_end_index > cur_buf.len) {
  216eff:	48 39 c8             	cmp    rax,rcx
  216f02:	76 42                	jbe    216f46 <ArenaAllocator_realloc+0x136>
                cur_node = try self.createNode(cur_buf.len, n + alignment);
  216f04:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  216f09:	4c 89 e6             	mov    rsi,r12
  216f0c:	48 89 ca             	mov    rdx,rcx
  216f0f:	4c 89 f1             	mov    rcx,r14
  216f12:	e8 49 01 00 00       	call   217060 <ArenaAllocator_createNode>
  216f17:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  216f1c:	66 85 c0             	test   ax,ax
  216f1f:	74 9e                	je     216ebf <ArenaAllocator_realloc+0xaf>
  216f21:	48 8b 6c 24 08       	mov    rbp,QWORD PTR [rsp+0x8]
            const result = try alloc(allocator, new_size, alignment);
  216f26:	66 89 45 00          	mov    WORD PTR [rbp+0x0],ax
  216f2a:	48 8b 44 24 50       	mov    rax,QWORD PTR [rsp+0x50]
  216f2f:	48 89 45 10          	mov    QWORD PTR [rbp+0x10],rax
  216f33:	c5 f8 10 44 24 42    	vmovups xmm0,XMMWORD PTR [rsp+0x42]
  216f39:	c5 f8 11 45 02       	vmovups XMMWORD PTR [rbp+0x2],xmm0
  216f3e:	48 89 e8             	mov    rax,rbp
  216f41:	e9 f1 00 00 00       	jmp    217037 <ArenaAllocator_realloc+0x227>
            self.end_index = new_end_index;
  216f46:	49 89 44 24 38       	mov    QWORD PTR [r12+0x38],rax
    assert(dest.len >= source.len);
  216f4b:	48 8b 7b 08          	mov    rdi,QWORD PTR [rbx+0x8]
  216f4f:	4c 39 ff             	cmp    rdi,r15
    if (!ok) {
  216f52:	0f 87 ee 00 00 00    	ja     217046 <ArenaAllocator_realloc+0x236>
  216f58:	4c 8d 04 2e          	lea    r8,[rsi+rbp*1]
  216f5c:	49 83 c0 20          	add    r8,0x20
    for (source) |s, i|
  216f60:	48 85 ff             	test   rdi,rdi
  216f63:	0f 84 ac 00 00 00    	je     217015 <ArenaAllocator_realloc+0x205>
  216f69:	48 8d 57 ff          	lea    rdx,[rdi-0x1]
  216f6d:	89 f9                	mov    ecx,edi
  216f6f:	83 e1 07             	and    ecx,0x7
  216f72:	48 83 fa 07          	cmp    rdx,0x7
  216f76:	73 0c                	jae    216f84 <ArenaAllocator_realloc+0x174>
  216f78:	31 d2                	xor    edx,edx
  216f7a:	48 85 c9             	test   rcx,rcx
  216f7d:	75 7e                	jne    216ffd <ArenaAllocator_realloc+0x1ed>
  216f7f:	e9 91 00 00 00       	jmp    217015 <ArenaAllocator_realloc+0x205>
  216f84:	48 29 cf             	sub    rdi,rcx
  216f87:	48 01 ee             	add    rsi,rbp
  216f8a:	48 83 c6 27          	add    rsi,0x27
  216f8e:	31 d2                	xor    edx,edx
  216f90:	48 8b 2b             	mov    rbp,QWORD PTR [rbx]
  216f93:	0f b6 44 15 00       	movzx  eax,BYTE PTR [rbp+rdx*1+0x0]
        dest[i] = s;
  216f98:	88 44 16 f9          	mov    BYTE PTR [rsi+rdx*1-0x7],al
    for (source) |s, i|
  216f9c:	48 8b 03             	mov    rax,QWORD PTR [rbx]
  216f9f:	0f b6 44 10 01       	movzx  eax,BYTE PTR [rax+rdx*1+0x1]
        dest[i] = s;
  216fa4:	88 44 16 fa          	mov    BYTE PTR [rsi+rdx*1-0x6],al
    for (source) |s, i|
  216fa8:	48 8b 03             	mov    rax,QWORD PTR [rbx]
  216fab:	0f b6 44 10 02       	movzx  eax,BYTE PTR [rax+rdx*1+0x2]
        dest[i] = s;
  216fb0:	88 44 16 fb          	mov    BYTE PTR [rsi+rdx*1-0x5],al
    for (source) |s, i|
  216fb4:	48 8b 03             	mov    rax,QWORD PTR [rbx]
  216fb7:	0f b6 44 10 03       	movzx  eax,BYTE PTR [rax+rdx*1+0x3]
        dest[i] = s;
  216fbc:	88 44 16 fc          	mov    BYTE PTR [rsi+rdx*1-0x4],al
    for (source) |s, i|
  216fc0:	48 8b 03             	mov    rax,QWORD PTR [rbx]
  216fc3:	0f b6 44 10 04       	movzx  eax,BYTE PTR [rax+rdx*1+0x4]
        dest[i] = s;
  216fc8:	88 44 16 fd          	mov    BYTE PTR [rsi+rdx*1-0x3],al
    for (source) |s, i|
  216fcc:	48 8b 03             	mov    rax,QWORD PTR [rbx]
  216fcf:	0f b6 44 10 05       	movzx  eax,BYTE PTR [rax+rdx*1+0x5]
        dest[i] = s;
  216fd4:	88 44 16 fe          	mov    BYTE PTR [rsi+rdx*1-0x2],al
    for (source) |s, i|
  216fd8:	48 8b 03             	mov    rax,QWORD PTR [rbx]
  216fdb:	0f b6 44 10 06       	movzx  eax,BYTE PTR [rax+rdx*1+0x6]
        dest[i] = s;
  216fe0:	88 44 16 ff          	mov    BYTE PTR [rsi+rdx*1-0x1],al
    for (source) |s, i|
  216fe4:	48 8b 03             	mov    rax,QWORD PTR [rbx]
  216fe7:	0f b6 44 10 07       	movzx  eax,BYTE PTR [rax+rdx*1+0x7]
        dest[i] = s;
  216fec:	88 04 16             	mov    BYTE PTR [rsi+rdx*1],al
    for (source) |s, i|
  216fef:	48 83 c2 08          	add    rdx,0x8
  216ff3:	48 39 d7             	cmp    rdi,rdx
  216ff6:	75 98                	jne    216f90 <ArenaAllocator_realloc+0x180>
  216ff8:	48 85 c9             	test   rcx,rcx
  216ffb:	74 18                	je     217015 <ArenaAllocator_realloc+0x205>
  216ffd:	48 f7 d9             	neg    rcx
  217000:	48 8b 03             	mov    rax,QWORD PTR [rbx]
  217003:	0f b6 04 10          	movzx  eax,BYTE PTR [rax+rdx*1]
        dest[i] = s;
  217007:	41 88 04 10          	mov    BYTE PTR [r8+rdx*1],al
    for (source) |s, i|
  21700b:	48 83 c2 01          	add    rdx,0x1
  21700f:	48 83 c1 01          	add    rcx,0x1
  217013:	75 eb                	jne    217000 <ArenaAllocator_realloc+0x1f0>
  217015:	48 8b 44 24 08       	mov    rax,QWORD PTR [rsp+0x8]
            return result;
  21701a:	66 c7 00 00 00       	mov    WORD PTR [rax],0x0
  21701f:	0f b7 4c 24 18       	movzx  ecx,WORD PTR [rsp+0x18]
  217024:	66 89 48 06          	mov    WORD PTR [rax+0x6],cx
  217028:	8b 4c 24 14          	mov    ecx,DWORD PTR [rsp+0x14]
  21702c:	89 48 02             	mov    DWORD PTR [rax+0x2],ecx
  21702f:	4c 89 40 08          	mov    QWORD PTR [rax+0x8],r8
  217033:	4c 89 78 10          	mov    QWORD PTR [rax+0x10],r15
  217037:	48 83 c4 58          	add    rsp,0x58
  21703b:	5b                   	pop    rbx
  21703c:	41 5c                	pop    r12
  21703e:	41 5d                	pop    r13
  217040:	41 5e                	pop    r14
  217042:	41 5f                	pop    r15
  217044:	5d                   	pop    rbp
  217045:	c3                   	ret    
            @panic("assertion failure");
  217046:	e8 d5 1c ff ff       	call   208d20 <panic>
  21704b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000217050 <ArenaAllocator_free>:
    fn free(allocator: *Allocator, bytes: []u8) void {}
  217050:	c3                   	ret    
  217051:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  217058:	0f 1f 84 00 00 00 00 
  21705f:	00 

0000000000217060 <ArenaAllocator_createNode>:
    fn createNode(self: *ArenaAllocator, prev_len: usize, minimum_size: usize) !*BufNode {
  217060:	41 57                	push   r15
  217062:	41 56                	push   r14
  217064:	53                   	push   rbx
  217065:	48 83 ec 30          	sub    rsp,0x30
  217069:	48 89 d3             	mov    rbx,rdx
  21706c:	49 89 f6             	mov    r14,rsi
  21706f:	49 89 ff             	mov    r15,rdi
        const actual_min_size = minimum_size + @sizeOf(BufNode);
  217072:	48 83 c1 20          	add    rcx,0x20
  217076:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  21707d:	00 00 00 
            len += len / 2;
  217080:	48 89 d8             	mov    rax,rbx
  217083:	48 d1 e8             	shr    rax,1
  217086:	48 01 d8             	add    rax,rbx
            len += os.page_size - @rem(len, os.page_size);
  217089:	89 c2                	mov    edx,eax
  21708b:	81 e2 ff 0f 00 00    	and    edx,0xfff
  217091:	bb 00 10 00 00       	mov    ebx,0x1000
  217096:	48 29 d3             	sub    rbx,rdx
  217099:	48 01 c3             	add    rbx,rax
            if (len >= actual_min_size) break;
  21709c:	48 39 cb             	cmp    rbx,rcx
  21709f:	72 df                	jb     217080 <ArenaAllocator_createNode+0x20>
        if (n == 0) {
  2170a1:	48 85 db             	test   rbx,rbx
  2170a4:	74 38                	je     2170de <ArenaAllocator_createNode+0x7e>
  2170a6:	49 8b 76 18          	mov    rsi,QWORD PTR [r14+0x18]
  2170aa:	48 8d 7c 24 08       	lea    rdi,[rsp+0x8]
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  2170af:	b9 08 00 00 00       	mov    ecx,0x8
  2170b4:	48 89 da             	mov    rdx,rbx
  2170b7:	ff 16                	call   QWORD PTR [rsi]
  2170b9:	0f b7 44 24 08       	movzx  eax,WORD PTR [rsp+0x8]
  2170be:	66 85 c0             	test   ax,ax
  2170c1:	74 1f                	je     2170e2 <ArenaAllocator_createNode+0x82>
        const buf = try self.child_allocator.alignedAlloc(u8, @alignOf(BufNode), len);
  2170c3:	66 41 89 07          	mov    WORD PTR [r15],ax
  2170c7:	48 8b 44 24 22       	mov    rax,QWORD PTR [rsp+0x22]
  2170cc:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  2170d1:	49 89 4f 08          	mov    QWORD PTR [r15+0x8],rcx
  2170d5:	49 89 47 02          	mov    QWORD PTR [r15+0x2],rax
  2170d9:	e9 c6 00 00 00       	jmp    2171a4 <ArenaAllocator_createNode+0x144>
  2170de:	31 db                	xor    ebx,ebx
  2170e0:	eb 10                	jmp    2170f2 <ArenaAllocator_createNode+0x92>
        assert(byte_slice.len == byte_count);
  2170e2:	48 39 5c 24 18       	cmp    QWORD PTR [rsp+0x18],rbx
    if (!ok) {
  2170e7:	0f 85 c1 00 00 00    	jne    2171ae <ArenaAllocator_createNode+0x14e>
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  2170ed:	48 8b 44 24 10       	mov    rax,QWORD PTR [rsp+0x10]
        buf_node.* = BufNode{
  2170f2:	c5 f8 57 c0          	vxorps xmm0,xmm0,xmm0
  2170f6:	c5 f8 11 00          	vmovups XMMWORD PTR [rax],xmm0
  2170fa:	48 89 40 10          	mov    QWORD PTR [rax+0x10],rax
  2170fe:	48 89 58 18          	mov    QWORD PTR [rax+0x18],rbx
            if (list.last) |last| {
  217102:	49 8b 4e 28          	mov    rcx,QWORD PTR [r14+0x28]
  217106:	48 85 c9             	test   rcx,rcx
  217109:	74 12                	je     21711d <ArenaAllocator_createNode+0xbd>
            new_node.prev = node;
  21710b:	48 89 08             	mov    QWORD PTR [rax],rcx
            if (node.next) |next_node| {
  21710e:	48 8b 51 08          	mov    rdx,QWORD PTR [rcx+0x8]
  217112:	48 85 d2             	test   rdx,rdx
  217115:	74 24                	je     21713b <ArenaAllocator_createNode+0xdb>
                new_node.next = next_node;
  217117:	48 89 50 08          	mov    QWORD PTR [rax+0x8],rdx
  21711b:	eb 2a                	jmp    217147 <ArenaAllocator_createNode+0xe7>
            if (list.first) |first| {
  21711d:	49 8b 4e 20          	mov    rcx,QWORD PTR [r14+0x20]
  217121:	48 85 c9             	test   rcx,rcx
  217124:	74 2a                	je     217150 <ArenaAllocator_createNode+0xf0>
            new_node.next = node;
  217126:	48 89 48 08          	mov    QWORD PTR [rax+0x8],rcx
            if (node.prev) |prev_node| {
  21712a:	48 8b 11             	mov    rdx,QWORD PTR [rcx]
  21712d:	48 85 d2             	test   rdx,rdx
  217130:	74 38                	je     21716a <ArenaAllocator_createNode+0x10a>
                new_node.prev = prev_node;
  217132:	48 89 10             	mov    QWORD PTR [rax],rdx
                prev_node.next = new_node;
  217135:	48 83 c2 08          	add    rdx,0x8
  217139:	eb 3a                	jmp    217175 <ArenaAllocator_createNode+0x115>
  21713b:	49 8d 56 28          	lea    rdx,[r14+0x28]
                new_node.next = null;
  21713f:	48 c7 40 08 00 00 00 	mov    QWORD PTR [rax+0x8],0x0
  217146:	00 
  217147:	48 89 02             	mov    QWORD PTR [rdx],rax
            node.next = new_node;
  21714a:	48 89 41 08          	mov    QWORD PTR [rcx+0x8],rax
  21714e:	eb 2b                	jmp    21717b <ArenaAllocator_createNode+0x11b>
                list.first = new_node;
  217150:	49 89 46 20          	mov    QWORD PTR [r14+0x20],rax
                list.last = new_node;
  217154:	49 89 46 28          	mov    QWORD PTR [r14+0x28],rax
                new_node.next = null;
  217158:	c5 f8 57 c0          	vxorps xmm0,xmm0,xmm0
  21715c:	c5 f8 11 00          	vmovups XMMWORD PTR [rax],xmm0
                list.len = 1;
  217160:	49 c7 46 30 01 00 00 	mov    QWORD PTR [r14+0x30],0x1
  217167:	00 
  217168:	eb 16                	jmp    217180 <ArenaAllocator_createNode+0x120>
  21716a:	49 8d 56 20          	lea    rdx,[r14+0x20]
                new_node.prev = null;
  21716e:	48 c7 00 00 00 00 00 	mov    QWORD PTR [rax],0x0
  217175:	48 89 02             	mov    QWORD PTR [rdx],rax
            node.prev = new_node;
  217178:	48 89 01             	mov    QWORD PTR [rcx],rax
  21717b:	49 83 46 30 01       	add    QWORD PTR [r14+0x30],0x1
        self.end_index = 0;
  217180:	49 c7 46 38 00 00 00 	mov    QWORD PTR [r14+0x38],0x0
  217187:	00 
        return buf_node;
  217188:	66 41 c7 07 00 00    	mov    WORD PTR [r15],0x0
  21718e:	0f b7 4c 24 06       	movzx  ecx,WORD PTR [rsp+0x6]
  217193:	66 41 89 4f 06       	mov    WORD PTR [r15+0x6],cx
  217198:	8b 4c 24 02          	mov    ecx,DWORD PTR [rsp+0x2]
  21719c:	41 89 4f 02          	mov    DWORD PTR [r15+0x2],ecx
  2171a0:	49 89 47 08          	mov    QWORD PTR [r15+0x8],rax
  2171a4:	48 83 c4 30          	add    rsp,0x30
  2171a8:	5b                   	pop    rbx
  2171a9:	41 5e                	pop    r14
  2171ab:	41 5f                	pop    r15
  2171ad:	c3                   	ret    
            @panic("assertion failure");
  2171ae:	e8 6d 1b ff ff       	call   208d20 <panic>
  2171b3:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  2171ba:	84 00 00 00 00 00 

00000000002171c0 <formatFloatDecimal>:
pub fn formatFloatDecimal(
  2171c0:	55                   	push   rbp
  2171c1:	41 57                	push   r15
  2171c3:	41 56                	push   r14
  2171c5:	41 55                	push   r13
  2171c7:	41 54                	push   r12
  2171c9:	53                   	push   rbx
  2171ca:	48 81 ec f8 00 00 00 	sub    rsp,0xf8
  2171d1:	49 89 d0             	mov    r8,rdx
  2171d4:	49 89 f7             	mov    r15,rsi
  2171d7:	49 89 fe             	mov    r14,rdi
    const bits = @bitCast(u32, x);
    return bits >> 31 != 0;
}

fn signbit64(x: f64) bool {
    const bits = @bitCast(u64, x);
  2171da:	c4 e1 f9 7e c0       	vmovq  rax,xmm0
    return bits >> 63 != 0;
  2171df:	48 85 c0             	test   rax,rax
    if (math.signbit(x)) {
  2171e2:	78 47                	js     21722b <formatFloatDecimal+0x6b>
  2171e4:	48 b8 00 00 00 00 00 	movabs rax,0x7ff0000000000000
  2171eb:	00 f0 7f 
        f32 => {
            const bits = @bitCast(u32, x);
            return bits & 0x7FFFFFFF > 0x7F800000;
        },
        f64 => {
            const bits = @bitCast(u64, x);
  2171ee:	c4 e1 f9 7e c5       	vmovq  rbp,xmm0
            return (bits & (@maxValue(u64) >> 1)) > (u64(0x7FF) << 52);
  2171f3:	b1 3f                	mov    cl,0x3f
  2171f5:	c4 e2 f0 f5 cd       	bzhi   rcx,rbp,rcx
  2171fa:	48 39 c1             	cmp    rcx,rax
    if (math.isNan(x)) {
  2171fd:	76 09                	jbe    217208 <formatFloatDecimal+0x48>
        return output(context, "nan");
  2171ff:	48 8d 35 ca 9b 00 00 	lea    rsi,[rip+0x9bca]        # 220dd0 <__unnamed_86>
  217206:	eb 0c                	jmp    217214 <formatFloatDecimal+0x54>
        },
        f32 => {
            return @bitCast(u32, x) == 0x7F800000;
        },
        f64 => {
            return @bitCast(u64, x) == 0x7FF << 52;
  217208:	48 39 c5             	cmp    rbp,rax
    if (math.isPositiveInf(x)) {
  21720b:	75 4c                	jne    217259 <formatFloatDecimal+0x99>
        return output(context, "inf");
  21720d:	48 8d 35 cc 9b 00 00 	lea    rsi,[rip+0x9bcc]        # 220de0 <__unnamed_87>
  217214:	4c 89 ff             	mov    rdi,r15
  217217:	48 81 c4 f8 00 00 00 	add    rsp,0xf8
  21721e:	5b                   	pop    rbx
  21721f:	41 5c                	pop    r12
  217221:	41 5d                	pop    r13
  217223:	41 5e                	pop    r14
  217225:	41 5f                	pop    r15
  217227:	5d                   	pop    rbp
  217228:	41 ff e0             	jmp    r8
  21722b:	c5 f9 7f 44 24 10    	vmovdqa XMMWORD PTR [rsp+0x10],xmm0
        try output(context, "-");
  217231:	48 8d 35 88 9b 00 00 	lea    rsi,[rip+0x9b88]        # 220dc0 <__unnamed_88>
  217238:	4c 89 ff             	mov    rdi,r15
  21723b:	4c 89 c3             	mov    rbx,r8
  21723e:	41 ff d0             	call   r8
  217241:	66 85 c0             	test   ax,ax
  217244:	75 38                	jne    21727e <formatFloatDecimal+0xbe>
  217246:	c5 f9 6f 44 24 10    	vmovdqa xmm0,XMMWORD PTR [rsp+0x10]
        x = -x;
  21724c:	c5 f9 ef 05 6c fd fe 	vpxor  xmm0,xmm0,XMMWORD PTR [rip+0xfffffffffffefd6c]        # 206fc0 <__unnamed_542+0x10>
  217253:	ff 
  217254:	49 89 d8             	mov    r8,rbx
  217257:	eb 8b                	jmp    2171e4 <formatFloatDecimal+0x24>
    if (x == 0.0) {
  217259:	c5 f1 57 c9          	vxorpd xmm1,xmm1,xmm1
  21725d:	c5 f9 2e c1          	vucomisd xmm0,xmm1
  217261:	75 2d                	jne    217290 <formatFloatDecimal+0xd0>
  217263:	7a 2b                	jp     217290 <formatFloatDecimal+0xd0>
        try output(context, "0");
  217265:	48 8d 35 a4 9b 00 00 	lea    rsi,[rip+0x9ba4]        # 220e10 <__unnamed_89>
  21726c:	4c 89 ff             	mov    rdi,r15
  21726f:	4c 89 c5             	mov    rbp,r8
  217272:	41 ff d0             	call   r8
  217275:	66 85 c0             	test   ax,ax
  217278:	0f 84 fb 02 00 00    	je     217579 <formatFloatDecimal+0x3b9>
  21727e:	48 81 c4 f8 00 00 00 	add    rsp,0xf8
  217285:	5b                   	pop    rbx
  217286:	41 5c                	pop    r12
  217288:	41 5d                	pop    r13
  21728a:	41 5e                	pop    r14
  21728c:	41 5f                	pop    r15
  21728e:	5d                   	pop    rbp
  21728f:	c3                   	ret    
    var buffer: [32]u8 = undefined;
  217290:	c5 fd 10 0d 48 8f fe 	vmovupd ymm1,YMMWORD PTR [rip+0xfffffffffffe8f48]        # 2001e0 <__unnamed_90>
  217297:	ff 
  217298:	c5 fd 11 4c 24 50    	vmovupd YMMWORD PTR [rsp+0x50],ymm1
  21729e:	48 8d 44 24 50       	lea    rax,[rsp+0x50]
    var float_decimal = errol.errol3(x, buffer[0..]);
  2172a3:	48 89 04 24          	mov    QWORD PTR [rsp],rax
  2172a7:	48 c7 44 24 08 20 00 	mov    QWORD PTR [rsp+0x8],0x20
  2172ae:	00 00 
  2172b0:	b8 b0 01 00 00       	mov    eax,0x1b0
  2172b5:	31 d2                	xor    edx,edx
  2172b7:	48 8d 0d 6a 99 fe ff 	lea    rcx,[rip+0xfffffffffffe996a]        # 200c28 <enum3.10>
  2172be:	66 90                	xchg   ax,ax
fn tableLowerBound(k: u64) usize {
    var i = enum3.len;
    var j: usize = 0;

    while (j < enum3.len) {
        if (enum3[j] < k) {
  2172c0:	48 39 2c d1          	cmp    QWORD PTR [rcx+rdx*8],rbp
  2172c4:	72 1a                	jb     2172e0 <formatFloatDecimal+0x120>
  2172c6:	48 89 d0             	mov    rax,rdx
  2172c9:	48 01 d2             	add    rdx,rdx
  2172cc:	48 83 c2 01          	add    rdx,0x1
    while (j < enum3.len) {
  2172d0:	48 81 fa b0 01 00 00 	cmp    rdx,0x1b0
  2172d7:	72 e7                	jb     2172c0 <formatFloatDecimal+0x100>
  2172d9:	eb 15                	jmp    2172f0 <formatFloatDecimal+0x130>
  2172db:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  2172e0:	48 01 d2             	add    rdx,rdx
  2172e3:	48 83 c2 02          	add    rdx,0x2
  2172e7:	48 81 fa b0 01 00 00 	cmp    rdx,0x1b0
  2172ee:	72 d0                	jb     2172c0 <formatFloatDecimal+0x100>
    if (i < enum3.len and enum3[i] == bits) {
  2172f0:	48 3d af 01 00 00    	cmp    rax,0x1af
  2172f6:	77 44                	ja     21733c <formatFloatDecimal+0x17c>
  2172f8:	48 39 2c c1          	cmp    QWORD PTR [rcx+rax*8],rbp
  2172fc:	75 3e                	jne    21733c <formatFloatDecimal+0x17c>
        const data = enum3_data[i];
  2172fe:	48 8d 04 40          	lea    rax,[rax+rax*2]
  217302:	48 8d 0d 77 6f 00 00 	lea    rcx,[rip+0x6f77]        # 21e280 <enum3_data.11>
  217309:	48 8b 14 c1          	mov    rdx,QWORD PTR [rcx+rax*8]
  21730d:	4c 8b 64 c1 08       	mov    r12,QWORD PTR [rcx+rax*8+0x8]
    for (source) |s, i|
  217312:	49 8d 7c 24 ff       	lea    rdi,[r12-0x1]
  217317:	44 89 e6             	mov    esi,r12d
  21731a:	83 e6 07             	and    esi,0x7
  21731d:	48 83 ff 07          	cmp    rdi,0x7
  217321:	0f 83 f5 04 00 00    	jae    21781c <formatFloatDecimal+0x65c>
  217327:	31 ff                	xor    edi,edi
  217329:	4c 8d 4c 24 51       	lea    r9,[rsp+0x51]
  21732e:	48 85 f6             	test   rsi,rsi
  217331:	0f 85 53 05 00 00    	jne    21788a <formatFloatDecimal+0x6ca>
  217337:	e9 75 05 00 00       	jmp    2178b1 <formatFloatDecimal+0x6f1>
    if (val > 9.007199254740992e15 and val < 3.40282366920938e+38) {
  21733c:	c5 f9 2e 05 94 8f fe 	vucomisd xmm0,QWORD PTR [rip+0xfffffffffffe8f94]        # 2002d8 <app_mask+0x58>
  217343:	ff 
  217344:	c5 f9 7f 44 24 10    	vmovdqa XMMWORD PTR [rsp+0x10],xmm0
  21734a:	0f 86 85 02 00 00    	jbe    2175d5 <formatFloatDecimal+0x415>
  217350:	c5 fb 10 0d 38 8f fe 	vmovsd xmm1,QWORD PTR [rip+0xfffffffffffe8f38]        # 200290 <app_mask+0x10>
  217357:	ff 
  217358:	c5 f9 2e c8          	vucomisd xmm1,xmm0
  21735c:	0f 86 73 02 00 00    	jbe    2175d5 <formatFloatDecimal+0x415>
  217362:	4c 89 44 24 20       	mov    QWORD PTR [rsp+0x20],r8
fn errolInt(val: f64, buffer: []u8) FloatDecimal {
    const pow19 = u128(1e19);

    assert((val > 9.007199254740992e15) and val < (3.40282366920938e38));

    var mid = @floatToInt(u128, val);
  217367:	c5 f8 77             	vzeroupper 
  21736a:	e8 f1 4c 00 00       	call   21c060 <__fixunsdfti>
  21736f:	c5 f9 28 4c 24 10    	vmovapd xmm1,XMMWORD PTR [rsp+0x10]
        .exp = exp,
    };
}

fn fpnext(val: f64) f64 {
    return @bitCast(f64, @bitCast(u64, val) +% 1);
  217375:	48 8d 4d 01          	lea    rcx,[rbp+0x1]
  217379:	c4 e1 f9 6e c1       	vmovq  xmm0,rcx
    var low: u128 = mid - fpeint((fpnext(val) - val) / 2.0);
  21737e:	c5 fb 5c c1          	vsubsd xmm0,xmm0,xmm1
  217382:	c5 fb 59 05 ce 8e fe 	vmulsd xmm0,xmm0,QWORD PTR [rip+0xfffffffffffe8ece]        # 200258 <__unnamed_90+0x78>
  217389:	ff 

    return buf_index;
}

fn fpeint(from: f64) u128 {
    const bits = @bitCast(u64, from);
  21738a:	c4 e1 f9 7e c1       	vmovq  rcx,xmm0
    assert((bits & ((1 << 52) - 1)) == 0);
  21738f:	48 89 ce             	mov    rsi,rcx
  217392:	48 c1 e6 0c          	shl    rsi,0xc
    if (!ok) {
  217396:	0f 85 99 12 00 00    	jne    218635 <formatFloatDecimal+0x1475>
  21739c:	4c 89 74 24 70       	mov    QWORD PTR [rsp+0x70],r14
  2173a1:	48 be ff ff ff ff ff 	movabs rsi,0xfffffffffffff
  2173a8:	ff 0f 00 
    return @bitCast(f64, @bitCast(u64, val) -% 1);
  2173ab:	48 8d 7d ff          	lea    rdi,[rbp-0x1]
  2173af:	c4 e1 f9 6e c7       	vmovq  xmm0,rdi
    var high: u128 = mid + fpeint((val - fpprev(val)) / 2.0);
  2173b4:	c5 f3 5c c0          	vsubsd xmm0,xmm1,xmm0
  2173b8:	c5 fb 59 05 98 8e fe 	vmulsd xmm0,xmm0,QWORD PTR [rip+0xfffffffffffe8e98]        # 200258 <__unnamed_90+0x78>
  2173bf:	ff 
    const bits = @bitCast(u64, from);
  2173c0:	c4 e1 f9 7e c3       	vmovq  rbx,xmm0
    assert((bits & ((1 << 52) - 1)) == 0);
  2173c5:	48 85 f3             	test   rbx,rsi
  2173c8:	0f 85 67 12 00 00    	jne    218635 <formatFloatDecimal+0x1475>

    return u128(1) << @truncate(u7, (bits >> 52) -% 1023);
  2173ce:	48 c1 e9 34          	shr    rcx,0x34
  2173d2:	83 c1 01             	add    ecx,0x1
  2173d5:	83 e1 7f             	and    ecx,0x7f
  2173d8:	41 b8 01 00 00 00    	mov    r8d,0x1
  2173de:	31 ff                	xor    edi,edi
  2173e0:	4c 0f a5 c7          	shld   rdi,r8,cl

    var i: i32 = 0;
    var a_copy = a;
    var b_copy = b;

    if (af != bf) {
  2173e4:	45 31 c9             	xor    r9d,r9d
    return u128(1) << @truncate(u7, (bits >> 52) -% 1023);
  2173e7:	c4 c2 f1 f7 f0       	shlx   rsi,r8,rcx
  2173ec:	f6 c1 40             	test   cl,0x40
  2173ef:	48 0f 45 fe          	cmovne rdi,rsi
  2173f3:	49 0f 45 f1          	cmovne rsi,r9
    if (af != bf) {
  2173f7:	45 31 c9             	xor    r9d,r9d
    var low: u128 = mid - fpeint((fpnext(val) - val) / 2.0);
  2173fa:	49 89 c6             	mov    r14,rax
  2173fd:	49 29 f6             	sub    r14,rsi
  217400:	48 89 d6             	mov    rsi,rdx
  217403:	48 19 fe             	sbb    rsi,rdi
    return u128(1) << @truncate(u7, (bits >> 52) -% 1023);
  217406:	48 c1 eb 34          	shr    rbx,0x34
  21740a:	83 c3 01             	add    ebx,0x1
  21740d:	83 e3 7f             	and    ebx,0x7f
  217410:	31 ff                	xor    edi,edi
  217412:	89 d9                	mov    ecx,ebx
  217414:	4c 0f a5 c7          	shld   rdi,r8,cl
  217418:	c4 c2 e1 f7 c8       	shlx   rcx,r8,rbx
  21741d:	f6 c3 40             	test   bl,0x40
  217420:	48 0f 45 f9          	cmovne rdi,rcx
  217424:	49 0f 45 c9          	cmovne rcx,r9
    if (@bitCast(u64, val) & 0x1 != 0) {
  217428:	83 e5 01             	and    ebp,0x1
  21742b:	31 db                	xor    ebx,ebx
  21742d:	48 85 ed             	test   rbp,rbp
  217430:	0f 94 c3             	sete   bl
  217433:	48 89 44 24 30       	mov    QWORD PTR [rsp+0x30],rax
    var high: u128 = mid + fpeint((val - fpprev(val)) / 2.0);
  217438:	49 89 c5             	mov    r13,rax
  21743b:	49 29 ed             	sub    r13,rbp
  21743e:	48 89 54 24 48       	mov    QWORD PTR [rsp+0x48],rdx
  217443:	48 89 d5             	mov    rbp,rdx
  217446:	48 83 dd 00          	sbb    rbp,0x0
    if (@bitCast(u64, val) & 0x1 != 0) {
  21744a:	49 01 cd             	add    r13,rcx
  21744d:	48 11 fd             	adc    rbp,rdi
  217450:	49 29 de             	sub    r14,rbx
  217453:	48 83 de 00          	sbb    rsi,0x0
  217457:	49 bc 00 00 e8 89 04 	movabs r12,0x8ac7230489e80000
  21745e:	23 c7 8a 
    const lf = @intCast(u64, (low / pow19) % pow19);
  217461:	31 c9                	xor    ecx,ecx
  217463:	4c 89 f7             	mov    rdi,r14
  217466:	4c 89 e2             	mov    rdx,r12
  217469:	e8 f2 56 00 00       	call   21cb60 <__udivti3>
  21746e:	48 89 c1             	mov    rcx,rax
  217471:	49 0f af cc          	imul   rcx,r12
  217475:	49 29 ce             	sub    r14,rcx
  217478:	31 c9                	xor    ecx,ecx
  21747a:	48 89 c7             	mov    rdi,rax
  21747d:	48 89 d6             	mov    rsi,rdx
  217480:	4c 89 e2             	mov    rdx,r12
  217483:	e8 f8 56 00 00       	call   21cb80 <__umodti3>
  217488:	48 89 c3             	mov    rbx,rax
    const hf = @intCast(u64, (high / pow19) % pow19);
  21748b:	31 c9                	xor    ecx,ecx
  21748d:	4c 89 ef             	mov    rdi,r13
  217490:	48 89 ee             	mov    rsi,rbp
  217493:	4c 89 e2             	mov    rdx,r12
  217496:	e8 c5 56 00 00       	call   21cb60 <__udivti3>
  21749b:	48 89 c1             	mov    rcx,rax
  21749e:	49 0f af cc          	imul   rcx,r12
  2174a2:	49 29 cd             	sub    r13,rcx
  2174a5:	31 c9                	xor    ecx,ecx
  2174a7:	48 89 c7             	mov    rdi,rax
  2174aa:	48 89 d6             	mov    rsi,rdx
  2174ad:	4c 89 e2             	mov    rdx,r12
  2174b0:	e8 cb 56 00 00       	call   21cb80 <__umodti3>
  2174b5:	49 89 c4             	mov    r12,rax
    if (lf != hf) {
  2174b8:	4c 39 e3             	cmp    rbx,r12
  2174bb:	48 89 5c 24 10       	mov    QWORD PTR [rsp+0x10],rbx
  2174c0:	4c 0f 45 f3          	cmovne r14,rbx
  2174c4:	4d 0f 45 ec          	cmovne r13,r12
  2174c8:	48 b9 bf d5 ed bd ce 	movabs rcx,0xdbe6fecebdedd5bf
  2174cf:	fe e6 db 
    const af = a / pow10;
  2174d2:	4c 89 f2             	mov    rdx,r14
  2174d5:	c4 e2 eb f6 c1       	mulx   rax,rdx,rcx
  2174da:	48 c1 e8 21          	shr    rax,0x21
    const bf = b / pow10;
  2174de:	4c 89 ea             	mov    rdx,r13
  2174e1:	c4 e2 eb f6 c9       	mulx   rcx,rdx,rcx
  2174e6:	48 c1 e9 21          	shr    rcx,0x21
    if (af != bf) {
  2174ea:	48 39 c8             	cmp    rax,rcx
  2174ed:	bd 0a 00 00 00       	mov    ebp,0xa
  2174f2:	ba 00 00 00 00       	mov    edx,0x0
  2174f7:	0f 44 ea             	cmove  ebp,edx
  2174fa:	49 0f 44 c6          	cmove  rax,r14
  2174fe:	49 0f 44 cd          	cmove  rcx,r13
  217502:	bb 01 00 00 00       	mov    ebx,0x1
        i = 10;
        a_copy = af;
        b_copy = bf;
    }

    while (true) : (i += 1) {
  217507:	29 eb                	sub    ebx,ebp
  217509:	83 c5 12             	add    ebp,0x12
  21750c:	48 be cd cc cc cc cc 	movabs rsi,0xcccccccccccccccd
  217513:	cc cc cc 
  217516:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  21751d:	00 00 00 
        a_copy /= 10;
  217520:	48 89 c2             	mov    rdx,rax
  217523:	c4 e2 eb f6 c6       	mulx   rax,rdx,rsi
  217528:	48 c1 e8 03          	shr    rax,0x3
        b_copy /= 10;
  21752c:	48 89 ca             	mov    rdx,rcx
  21752f:	c4 e2 eb f6 ce       	mulx   rcx,rdx,rsi
  217534:	48 c1 e9 03          	shr    rcx,0x3

        if (a_copy == b_copy) return i;
  217538:	83 c3 ff             	add    ebx,0xffffffff
  21753b:	83 c5 01             	add    ebp,0x1
  21753e:	48 39 c8             	cmp    rax,rcx
  217541:	75 dd                	jne    217520 <formatFloatDecimal+0x360>
    if (lf != hf) {
  217543:	4c 39 64 24 10       	cmp    QWORD PTR [rsp+0x10],r12
  217548:	4c 8b 74 24 70       	mov    r14,QWORD PTR [rsp+0x70]
  21754d:	0f 84 81 02 00 00    	je     2177d4 <formatFloatDecimal+0x614>
        mid = mid / (pow19 / 10);
  217553:	48 ba 00 00 64 a7 b3 	movabs rdx,0xde0b6b3a7640000
  21755a:	b6 e0 0d 
  21755d:	31 c9                	xor    ecx,ecx
  21755f:	48 8b 7c 24 30       	mov    rdi,QWORD PTR [rsp+0x30]
  217564:	48 8b 74 24 48       	mov    rsi,QWORD PTR [rsp+0x48]
  217569:	e8 f2 55 00 00       	call   21cb60 <__udivti3>
  21756e:	48 89 c7             	mov    rdi,rax
  217571:	48 89 d6             	mov    rsi,rdx
  217574:	e9 65 02 00 00       	jmp    2177de <formatFloatDecimal+0x61e>
        if (maybe_precision) |precision| {
  217579:	41 80 7e 08 01       	cmp    BYTE PTR [r14+0x8],0x1
  21757e:	0f 85 a0 01 00 00    	jne    217724 <formatFloatDecimal+0x564>
  217584:	4d 8b 26             	mov    r12,QWORD PTR [r14]
            if (precision != 0) {
  217587:	4d 85 e4             	test   r12,r12
  21758a:	48 89 e8             	mov    rax,rbp
  21758d:	0f 84 4d 04 00 00    	je     2179e0 <formatFloatDecimal+0x820>
                try output(context, ".");
  217593:	48 8d 35 66 98 00 00 	lea    rsi,[rip+0x9866]        # 220e00 <__unnamed_91>
  21759a:	4c 89 ff             	mov    rdi,r15
  21759d:	ff d0                	call   rax
  21759f:	66 85 c0             	test   ax,ax
  2175a2:	0f 85 d6 fc ff ff    	jne    21727e <formatFloatDecimal+0xbe>
  2175a8:	31 db                	xor    ebx,ebx
  2175aa:	4c 8d 35 5f 98 00 00 	lea    r14,[rip+0x985f]        # 220e10 <__unnamed_89>
                    try output(context, "0");
  2175b1:	4c 89 ff             	mov    rdi,r15
  2175b4:	4c 89 f6             	mov    rsi,r14
  2175b7:	48 89 e8             	mov    rax,rbp
  2175ba:	ff d0                	call   rax
  2175bc:	66 85 c0             	test   ax,ax
  2175bf:	0f 85 b9 fc ff ff    	jne    21727e <formatFloatDecimal+0xbe>
  2175c5:	48 83 c3 01          	add    rbx,0x1
  2175c9:	31 c0                	xor    eax,eax
                while (i < precision) : (i += 1) {
  2175cb:	4c 39 e3             	cmp    rbx,r12
  2175ce:	72 e1                	jb     2175b1 <formatFloatDecimal+0x3f1>
  2175d0:	e9 a9 fc ff ff       	jmp    21727e <formatFloatDecimal+0xbe>
  2175d5:	4c 89 c3             	mov    rbx,r8
    } else if (val >= 16.0 and val < 9.007199254740992e15) {
  2175d8:	c5 f9 2e 05 60 8c fe 	vucomisd xmm0,QWORD PTR [rip+0xfffffffffffe8c60]        # 200240 <__unnamed_90+0x60>
  2175df:	ff 
  2175e0:	0f 82 50 01 00 00    	jb     217736 <formatFloatDecimal+0x576>
  2175e6:	c5 fb 10 0d ea 8c fe 	vmovsd xmm1,QWORD PTR [rip+0xfffffffffffe8cea]        # 2002d8 <app_mask+0x58>
  2175ed:	ff 
  2175ee:	c5 f9 2e c8          	vucomisd xmm1,xmm0
  2175f2:	0f 86 3e 01 00 00    	jbe    217736 <formatFloatDecimal+0x576>
    const u = @floatToInt(u64, val);
  2175f8:	c5 fb 10 15 98 8c fe 	vmovsd xmm2,QWORD PTR [rip+0xfffffffffffe8c98]        # 200298 <app_mask+0x18>
  2175ff:	ff 
  217600:	c5 fb 5c ca          	vsubsd xmm1,xmm0,xmm2
  217604:	c4 e1 fb 2c c1       	vcvttsd2si rax,xmm1
  217609:	48 b9 00 00 00 00 00 	movabs rcx,0x8000000000000000
  217610:	00 00 80 
  217613:	48 31 c1             	xor    rcx,rax
  217616:	c4 e1 fb 2c f8       	vcvttsd2si rdi,xmm0
  21761b:	c5 f9 2e c2          	vucomisd xmm0,xmm2
  21761f:	48 0f 43 f9          	cmovae rdi,rcx
    const n = @intToFloat(f64, u);
  217623:	c4 e1 f9 6e cf       	vmovq  xmm1,rdi
  217628:	c5 f1 62 0d 70 f4 fe 	vpunpckldq xmm1,xmm1,XMMWORD PTR [rip+0xfffffffffffef470]        # 206aa0 <__unnamed_606+0x14>
  21762f:	ff 
  217630:	c5 f1 5c 0d 68 f9 fe 	vsubpd xmm1,xmm1,XMMWORD PTR [rip+0xfffffffffffef968]        # 206fa0 <__unnamed_573+0x10>
  217637:	ff 
  217638:	c5 f1 7c c9          	vhaddpd xmm1,xmm1,xmm1
  21763c:	c5 f9 29 4c 24 30    	vmovapd XMMWORD PTR [rsp+0x30],xmm1
    var mid = val - n;
  217642:	c5 fb 5c c9          	vsubsd xmm1,xmm0,xmm1
    var buf_index = u64toa(u, buffer);
  217646:	c5 f9 29 4c 24 20    	vmovapd XMMWORD PTR [rsp+0x20],xmm1
  21764c:	48 89 e6             	mov    rsi,rsp
  21764f:	c5 f8 77             	vzeroupper 
  217652:	e8 e9 0f 00 00       	call   218640 <u64toa>
  217657:	c5 f9 28 6c 24 20    	vmovapd xmm5,XMMWORD PTR [rsp+0x20]
  21765d:	49 89 c5             	mov    r13,rax
    buffer[j] = 0;
  217660:	48 8b 04 24          	mov    rax,QWORD PTR [rsp]
  217664:	42 c6 04 28 00       	mov    BYTE PTR [rax+r13*1],0x0
    if (mid != 0.0) {
  217669:	c5 f9 57 c0          	vxorpd xmm0,xmm0,xmm0
  21766d:	c5 f9 2e e8          	vucomisd xmm5,xmm0
  217671:	0f 84 7c 09 00 00    	je     217ff3 <formatFloatDecimal+0xe33>
    return @bitCast(f64, @bitCast(u64, val) -% 1);
  217677:	c4 e2 79 59 4c 24 10 	vpbroadcastq xmm1,QWORD PTR [rsp+0x10]
  21767e:	c5 f1 d4 0d ea fa fe 	vpaddq xmm1,xmm1,XMMWORD PTR [rip+0xfffffffffffefaea]        # 207170 <__unnamed_59+0x10>
  217685:	ff 
    var lo = ((fpprev(val) - n) + mid) / 2.0;
  217686:	c5 fb 12 54 24 30    	vmovddup xmm2,QWORD PTR [rsp+0x30]
  21768c:	c5 f1 5c ca          	vsubpd xmm1,xmm1,xmm2
  217690:	c5 fb 12 d5          	vmovddup xmm2,xmm5
  217694:	c5 e9 58 c9          	vaddpd xmm1,xmm2,xmm1
  217698:	c5 f1 59 1d c0 f6 fe 	vmulpd xmm3,xmm1,XMMWORD PTR [rip+0xfffffffffffef6c0]        # 206d60 <__unnamed_56+0x10>
  21769f:	ff 
  2176a0:	c5 f9 28 0d 08 f5 fe 	vmovapd xmm1,XMMWORD PTR [rip+0xfffffffffffef508]        # 206bb0 <__unnamed_60+0x10>
  2176a7:	ff 
  2176a8:	c5 fb 10 15 68 8b fe 	vmovsd xmm2,QWORD PTR [rip+0xfffffffffffe8b68]        # 200218 <__unnamed_90+0x38>
  2176af:	ff 
  2176b0:	4c 89 e9             	mov    rcx,r13
  2176b3:	48 89 c8             	mov    rax,rcx
            mid *= 10.0;
  2176b6:	c5 d3 59 e2          	vmulsd xmm4,xmm5,xmm2
            const mdig = @floatToInt(i32, mid);
  2176ba:	c5 fb 2c cc          	vcvttsd2si ecx,xmm4
            mid -= @intToFloat(f64, mdig);
  2176be:	c5 cb 2a e9          	vcvtsi2sd xmm5,xmm6,ecx
  2176c2:	c5 db 5c ed          	vsubsd xmm5,xmm4,xmm5
            buffer[j] = @intCast(u8, mdig + '0');
  2176c6:	48 8b 14 24          	mov    rdx,QWORD PTR [rsp]
  2176ca:	80 c1 30             	add    cl,0x30
  2176cd:	88 0c 02             	mov    BYTE PTR [rdx+rax*1],cl
            if (hdig != ldig or j > 50) break;
  2176d0:	48 83 f8 31          	cmp    rax,0x31
  2176d4:	77 2c                	ja     217702 <formatFloatDecimal+0x542>
  2176d6:	c5 e1 59 d9          	vmulpd xmm3,xmm3,xmm1
  2176da:	c5 fb 2c cb          	vcvttsd2si ecx,xmm3
  2176de:	c4 e3 79 05 e3 01    	vpermilpd xmm4,xmm3,0x1
  2176e4:	c5 fb 2c d4          	vcvttsd2si edx,xmm4
  2176e8:	39 ca                	cmp    edx,ecx
  2176ea:	75 16                	jne    217702 <formatFloatDecimal+0x542>
            hi -= @intToFloat(f64, hdig);
  2176ec:	c5 cb 2a e1          	vcvtsi2sd xmm4,xmm6,ecx
  2176f0:	48 8d 48 01          	lea    rcx,[rax+0x1]
            lo -= @intToFloat(f64, ldig);
  2176f4:	c5 fb 12 e4          	vmovddup xmm4,xmm4
  2176f8:	c5 e1 5c dc          	vsubpd xmm3,xmm3,xmm4
        while (mid != 0.0) {
  2176fc:	c5 f9 2e e8          	vucomisd xmm5,xmm0
  217700:	75 b1                	jne    2176b3 <formatFloatDecimal+0x4f3>
        if (mid > 0.5) {
  217702:	4c 8d 60 01          	lea    r12,[rax+0x1]
  217706:	c5 f9 2e 2d 4a 8b fe 	vucomisd xmm5,QWORD PTR [rip+0xfffffffffffe8b4a]        # 200258 <__unnamed_90+0x78>
  21770d:	ff 
  21770e:	49 89 d8             	mov    r8,rbx
  217711:	0f 86 22 09 00 00    	jbe    218039 <formatFloatDecimal+0xe79>
            buffer[j - 1] += 1;
  217717:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
  21771b:	80 04 01 01          	add    BYTE PTR [rcx+rax*1],0x1
  21771f:	e9 d7 0d 00 00       	jmp    2184fb <formatFloatDecimal+0x133b>
            try output(context, "0");
  217724:	48 8d 35 e5 96 00 00 	lea    rsi,[rip+0x96e5]        # 220e10 <__unnamed_89>
  21772b:	4c 89 ff             	mov    rdi,r15
  21772e:	48 89 e8             	mov    rax,rbp
  217731:	e9 b4 02 00 00       	jmp    2179ea <formatFloatDecimal+0x82a>
  217736:	48 8d bc 24 c8 00 00 	lea    rdi,[rsp+0xc8]
  21773d:	00 

pub fn frexp(x: var) frexp_result(@typeOf(x)) {
    const T = @typeOf(x);
    return switch (T) {
        f32 => frexp32(x),
        f64 => frexp64(x),
  21773e:	c5 f8 77             	vzeroupper 
  217741:	e8 ea 15 00 00       	call   218d30 <frexp64>
    var exp = @floatToInt(i16, math.floor(307 + @intToFloat(f64, e) * 0.30103));
  217746:	c5 eb 2a 84 24 d0 00 	vcvtsi2sd xmm0,xmm2,DWORD PTR [rsp+0xd0]
  21774d:	00 00 
  21774f:	c5 fb 59 05 f1 8a fe 	vmulsd xmm0,xmm0,QWORD PTR [rip+0xfffffffffffe8af1]        # 200248 <__unnamed_90+0x68>
  217756:	ff 
  217757:	c5 fb 58 05 09 8b fe 	vaddsd xmm0,xmm0,QWORD PTR [rip+0xfffffffffffe8b09]        # 200268 <__unnamed_90+0x88>
  21775e:	ff 
fn floor64(x: f64) f64 {
    const u = @bitCast(u64, x);
    const e = (u >> 52) & 0x7FF;
    var y: f64 = undefined;

    if (e >= 0x3FF + 52 or x == 0) {
  21775f:	c5 f1 57 c9          	vxorpd xmm1,xmm1,xmm1
  217763:	c5 f9 2e c1          	vucomisd xmm0,xmm1
  217767:	75 06                	jne    21776f <formatFloatDecimal+0x5af>
  217769:	0f 8b 8e 02 00 00    	jnp    2179fd <formatFloatDecimal+0x83d>
  21776f:	c4 e1 f9 7e c0       	vmovq  rax,xmm0
  217774:	b9 34 0b 00 00       	mov    ecx,0xb34
  217779:	c4 e2 f0 f7 c8       	bextr  rcx,rax,rcx
  21777e:	48 81 f9 32 04 00 00 	cmp    rcx,0x432
  217785:	0f 87 72 02 00 00    	ja     2179fd <formatFloatDecimal+0x83d>
        return x;
    }

    if (u >> 63 != 0) {
        y = x - math.f64_toint + math.f64_toint - x;
  21778b:	c5 fb 10 15 a5 8a fe 	vmovsd xmm2,QWORD PTR [rip+0xfffffffffffe8aa5]        # 200238 <__unnamed_90+0x58>
  217792:	ff 
  217793:	c5 fb 10 1d d5 8a fe 	vmovsd xmm3,QWORD PTR [rip+0xfffffffffffe8ad5]        # 200270 <__unnamed_90+0x90>
  21779a:	ff 
    if (u >> 63 != 0) {
  21779b:	48 85 c0             	test   rax,rax
  21779e:	49 89 d8             	mov    r8,rbx
  2177a1:	c5 79 28 5c 24 10    	vmovapd xmm11,XMMWORD PTR [rsp+0x10]
  2177a7:	0f 88 b3 08 00 00    	js     218060 <formatFloatDecimal+0xea0>
  2177ad:	c5 fb 58 db          	vaddsd xmm3,xmm0,xmm3
  2177b1:	c5 e3 58 d2          	vaddsd xmm2,xmm3,xmm2
    } else {
        y = x + math.f64_toint - math.f64_toint - x;
    }

    if (e <= 0x3FF - 1) {
  2177b5:	48 81 f9 fe 03 00 00 	cmp    rcx,0x3fe
  2177bc:	0f 87 b3 08 00 00    	ja     218075 <formatFloatDecimal+0xeb5>
    if (u >> 63 != 0) {
  2177c2:	48 85 c0             	test   rax,rax
        math.forceEval(y);
        if (u >> 63 != 0) {
  2177c5:	0f 88 4d 0d 00 00    	js     218518 <formatFloatDecimal+0x1358>
  2177cb:	c5 f9 57 c0          	vxorpd xmm0,xmm0,xmm0
  2177cf:	e9 32 02 00 00       	jmp    217a06 <formatFloatDecimal+0x846>
  2177d4:	48 8b 7c 24 30       	mov    rdi,QWORD PTR [rsp+0x30]
  2177d9:	48 8b 74 24 48       	mov    rsi,QWORD PTR [rsp+0x48]
        var i: i32 = @boolToInt(lf == hf);
  2177de:	31 c0                	xor    eax,eax
  2177e0:	4c 39 64 24 10       	cmp    QWORD PTR [rsp+0x10],r12
  2177e5:	0f 94 c0             	sete   al
        while (i < mi) : (i += 1) {
  2177e8:	41 89 dd             	mov    r13d,ebx
  2177eb:	41 f7 dd             	neg    r13d
  2177ee:	41 39 c5             	cmp    r13d,eax
  2177f1:	76 1d                	jbe    217810 <formatFloatDecimal+0x650>
  2177f3:	41 89 c2             	mov    r10d,eax
  2177f6:	41 f7 da             	neg    r10d
  2177f9:	41 29 da             	sub    r10d,ebx
  2177fc:	41 83 fa 10          	cmp    r10d,0x10
  217800:	0f 83 ac 07 00 00    	jae    217fb2 <formatFloatDecimal+0xdf2>
  217806:	ba 01 00 00 00       	mov    edx,0x1
  21780b:	e9 92 0a 00 00       	jmp    2182a2 <formatFloatDecimal+0x10e2>
  217810:	31 c9                	xor    ecx,ecx
  217812:	ba 01 00 00 00       	mov    edx,0x1
  217817:	e9 a2 0a 00 00       	jmp    2182be <formatFloatDecimal+0x10fe>
  21781c:	4c 89 e5             	mov    rbp,r12
  21781f:	48 29 f5             	sub    rbp,rsi
  217822:	31 ff                	xor    edi,edi
  217824:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21782b:	00 00 00 00 00 
  217830:	0f b6 1c 3a          	movzx  ebx,BYTE PTR [rdx+rdi*1]
        dest[i] = s;
  217834:	88 5c 3c 51          	mov    BYTE PTR [rsp+rdi*1+0x51],bl
    for (source) |s, i|
  217838:	0f b6 5c 3a 01       	movzx  ebx,BYTE PTR [rdx+rdi*1+0x1]
        dest[i] = s;
  21783d:	88 5c 3c 52          	mov    BYTE PTR [rsp+rdi*1+0x52],bl
    for (source) |s, i|
  217841:	0f b6 5c 3a 02       	movzx  ebx,BYTE PTR [rdx+rdi*1+0x2]
        dest[i] = s;
  217846:	88 5c 3c 53          	mov    BYTE PTR [rsp+rdi*1+0x53],bl
    for (source) |s, i|
  21784a:	0f b6 5c 3a 03       	movzx  ebx,BYTE PTR [rdx+rdi*1+0x3]
        dest[i] = s;
  21784f:	88 5c 3c 54          	mov    BYTE PTR [rsp+rdi*1+0x54],bl
    for (source) |s, i|
  217853:	0f b6 5c 3a 04       	movzx  ebx,BYTE PTR [rdx+rdi*1+0x4]
        dest[i] = s;
  217858:	88 5c 3c 55          	mov    BYTE PTR [rsp+rdi*1+0x55],bl
    for (source) |s, i|
  21785c:	0f b6 5c 3a 05       	movzx  ebx,BYTE PTR [rdx+rdi*1+0x5]
        dest[i] = s;
  217861:	88 5c 3c 56          	mov    BYTE PTR [rsp+rdi*1+0x56],bl
    for (source) |s, i|
  217865:	0f b6 5c 3a 06       	movzx  ebx,BYTE PTR [rdx+rdi*1+0x6]
        dest[i] = s;
  21786a:	88 5c 3c 57          	mov    BYTE PTR [rsp+rdi*1+0x57],bl
    for (source) |s, i|
  21786e:	0f b6 5c 3a 07       	movzx  ebx,BYTE PTR [rdx+rdi*1+0x7]
        dest[i] = s;
  217873:	88 5c 3c 58          	mov    BYTE PTR [rsp+rdi*1+0x58],bl
    for (source) |s, i|
  217877:	48 83 c7 08          	add    rdi,0x8
  21787b:	48 39 fd             	cmp    rbp,rdi
  21787e:	75 b0                	jne    217830 <formatFloatDecimal+0x670>
  217880:	4c 8d 4c 24 51       	lea    r9,[rsp+0x51]
  217885:	48 85 f6             	test   rsi,rsi
  217888:	74 27                	je     2178b1 <formatFloatDecimal+0x6f1>
  21788a:	48 8d 2c 3c          	lea    rbp,[rsp+rdi*1]
  21788e:	48 83 c5 51          	add    rbp,0x51
  217892:	48 01 fa             	add    rdx,rdi
  217895:	31 ff                	xor    edi,edi
  217897:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  21789e:	00 00 
  2178a0:	0f b6 1c 3a          	movzx  ebx,BYTE PTR [rdx+rdi*1]
        dest[i] = s;
  2178a4:	88 5c 3d 00          	mov    BYTE PTR [rbp+rdi*1+0x0],bl
    for (source) |s, i|
  2178a8:	48 83 c7 01          	add    rdi,0x1
  2178ac:	48 39 fe             	cmp    rsi,rdi
  2178af:	75 ef                	jne    2178a0 <formatFloatDecimal+0x6e0>
  2178b1:	44 8b 6c c1 10       	mov    r13d,DWORD PTR [rcx+rax*8+0x10]
    if (maybe_precision) |precision| {
  2178b6:	41 80 7e 08 01       	cmp    BYTE PTR [r14+0x8],0x1
  2178bb:	0f 84 54 0a 00 00    	je     218315 <formatFloatDecimal+0x1155>
        var num_digits_whole = if (float_decimal.exp > 0) @intCast(usize, float_decimal.exp) else 0;
  2178c1:	31 ed                	xor    ebp,ebp
  2178c3:	45 85 ed             	test   r13d,r13d
  2178c6:	44 89 e8             	mov    eax,r13d
  2178c9:	48 0f 4f e8          	cmovg  rbp,rax
    return if (x < y) x else y;
  2178cd:	4c 39 e5             	cmp    rbp,r12
  2178d0:	4c 89 e0             	mov    rax,r12
  2178d3:	48 0f 42 c5          	cmovb  rax,rbp
  2178d7:	45 85 ed             	test   r13d,r13d
        if (num_digits_whole > 0) {
  2178da:	4c 89 4c 24 10       	mov    QWORD PTR [rsp+0x10],r9
  2178df:	48 89 44 24 20       	mov    QWORD PTR [rsp+0x20],rax
  2178e4:	7e 5a                	jle    217940 <formatFloatDecimal+0x780>
            try output(context, float_decimal.digits[0..num_digits_whole_no_pad]);
  2178e6:	4c 89 8c 24 88 00 00 	mov    QWORD PTR [rsp+0x88],r9
  2178ed:	00 
  2178ee:	48 89 84 24 90 00 00 	mov    QWORD PTR [rsp+0x90],rax
  2178f5:	00 
  2178f6:	48 8d b4 24 88 00 00 	lea    rsi,[rsp+0x88]
  2178fd:	00 
  2178fe:	4c 89 ff             	mov    rdi,r15
  217901:	4d 89 c6             	mov    r14,r8
  217904:	c5 f8 77             	vzeroupper 
  217907:	41 ff d0             	call   r8
  21790a:	66 85 c0             	test   ax,ax
  21790d:	0f 85 6b f9 ff ff    	jne    21727e <formatFloatDecimal+0xbe>
            while (i < num_digits_whole) : (i += 1) {
  217913:	4c 39 e5             	cmp    rbp,r12
  217916:	76 44                	jbe    21795c <formatFloatDecimal+0x79c>
  217918:	48 8b 5c 24 20       	mov    rbx,QWORD PTR [rsp+0x20]
                try output(context, "0");
  21791d:	4c 89 ff             	mov    rdi,r15
  217920:	48 8d 35 e9 94 00 00 	lea    rsi,[rip+0x94e9]        # 220e10 <__unnamed_89>
  217927:	4c 89 f0             	mov    rax,r14
  21792a:	ff d0                	call   rax
  21792c:	66 85 c0             	test   ax,ax
  21792f:	0f 85 49 f9 ff ff    	jne    21727e <formatFloatDecimal+0xbe>
  217935:	48 83 c3 01          	add    rbx,0x1
            while (i < num_digits_whole) : (i += 1) {
  217939:	48 39 eb             	cmp    rbx,rbp
  21793c:	72 df                	jb     21791d <formatFloatDecimal+0x75d>
  21793e:	eb 1c                	jmp    21795c <formatFloatDecimal+0x79c>
            try output(context, "0");
  217940:	48 8d 35 c9 94 00 00 	lea    rsi,[rip+0x94c9]        # 220e10 <__unnamed_89>
  217947:	4c 89 ff             	mov    rdi,r15
  21794a:	4d 89 c6             	mov    r14,r8
  21794d:	c5 f8 77             	vzeroupper 
  217950:	41 ff d0             	call   r8
  217953:	66 85 c0             	test   ax,ax
  217956:	0f 85 22 f9 ff ff    	jne    21727e <formatFloatDecimal+0xbe>
        if (float_decimal.exp >= 0 and num_digits_whole_no_pad == float_decimal.digits.len) {
  21795c:	45 85 ed             	test   r13d,r13d
  21795f:	78 09                	js     21796a <formatFloatDecimal+0x7aa>
  217961:	49 39 ec             	cmp    r12,rbp
  217964:	0f 86 c4 0c 00 00    	jbe    21862e <formatFloatDecimal+0x146e>
        try output(context, ".");
  21796a:	48 8d 35 8f 94 00 00 	lea    rsi,[rip+0x948f]        # 220e00 <__unnamed_91>
  217971:	4c 89 ff             	mov    rdi,r15
  217974:	4c 89 f3             	mov    rbx,r14
  217977:	41 ff d6             	call   r14
  21797a:	66 85 c0             	test   ax,ax
  21797d:	0f 85 fb f8 ff ff    	jne    21727e <formatFloatDecimal+0xbe>
        if (float_decimal.exp < 0) {
  217983:	45 85 ed             	test   r13d,r13d
  217986:	79 2c                	jns    2179b4 <formatFloatDecimal+0x7f4>
            const zero_digit_count = @intCast(usize, -float_decimal.exp);
  217988:	41 f7 dd             	neg    r13d
  21798b:	4d 63 ed             	movsxd r13,r13d
  21798e:	31 ed                	xor    ebp,ebp
  217990:	4c 8d 35 79 94 00 00 	lea    r14,[rip+0x9479]        # 220e10 <__unnamed_89>
                try output(context, "0");
  217997:	4c 89 ff             	mov    rdi,r15
  21799a:	4c 89 f6             	mov    rsi,r14
  21799d:	48 89 d8             	mov    rax,rbx
  2179a0:	ff d0                	call   rax
  2179a2:	66 85 c0             	test   ax,ax
  2179a5:	0f 85 d3 f8 ff ff    	jne    21727e <formatFloatDecimal+0xbe>
  2179ab:	48 83 c5 01          	add    rbp,0x1
            while (i < zero_digit_count) : (i += 1) {
  2179af:	4c 39 ed             	cmp    rbp,r13
  2179b2:	72 e3                	jb     217997 <formatFloatDecimal+0x7d7>
  2179b4:	48 8b 44 24 10       	mov    rax,QWORD PTR [rsp+0x10]
  2179b9:	48 8b 4c 24 20       	mov    rcx,QWORD PTR [rsp+0x20]
        try output(context, float_decimal.digits[num_digits_whole_no_pad..]);
  2179be:	48 01 c8             	add    rax,rcx
  2179c1:	48 89 44 24 78       	mov    QWORD PTR [rsp+0x78],rax
  2179c6:	49 29 cc             	sub    r12,rcx
  2179c9:	4c 89 a4 24 80 00 00 	mov    QWORD PTR [rsp+0x80],r12
  2179d0:	00 
  2179d1:	48 8d 74 24 78       	lea    rsi,[rsp+0x78]
  2179d6:	4c 89 ff             	mov    rdi,r15
  2179d9:	ff d3                	call   rbx
  2179db:	e9 9e f8 ff ff       	jmp    21727e <formatFloatDecimal+0xbe>
                try output(context, ".0");
  2179e0:	48 8d 35 09 94 00 00 	lea    rsi,[rip+0x9409]        # 220df0 <__unnamed_92>
  2179e7:	4c 89 ff             	mov    rdi,r15
  2179ea:	48 81 c4 f8 00 00 00 	add    rsp,0xf8
  2179f1:	5b                   	pop    rbx
  2179f2:	41 5c                	pop    r12
  2179f4:	41 5d                	pop    r13
  2179f6:	41 5e                	pop    r14
  2179f8:	41 5f                	pop    r15
  2179fa:	5d                   	pop    rbp
  2179fb:	ff e0                	jmp    rax
  2179fd:	49 89 d8             	mov    r8,rbx
  217a00:	c5 79 28 5c 24 10    	vmovapd xmm11,XMMWORD PTR [rsp+0x10]
    var exp = @floatToInt(i16, math.floor(307 + @intToFloat(f64, e) * 0.30103));
  217a06:	c5 fb 2c c0          	vcvttsd2si eax,xmm0
    if (exp < 20) {
  217a0a:	98                   	cwde   
    } else if (@intCast(usize, exp) >= lookup_table.len) {
  217a0b:	0f b7 c8             	movzx  ecx,ax
  217a0e:	81 f9 57 02 00 00    	cmp    ecx,0x257
  217a14:	66 b9 57 02          	mov    cx,0x257
  217a18:	66 0f 42 c8          	cmovb  cx,ax
    if (exp < 20) {
  217a1c:	83 f8 14             	cmp    eax,0x14
  217a1f:	66 b8 14 00          	mov    ax,0x14
  217a23:	66 0f 4d c1          	cmovge ax,cx
    var mid = lookup_table[@intCast(usize, exp)];
  217a27:	0f b7 c8             	movzx  ecx,ax
  217a2a:	48 c1 e1 04          	shl    rcx,0x4
  217a2e:	48 8d 15 db b2 fe ff 	lea    rdx,[rip+0xfffffffffffeb2db]        # 202d10 <lookup_table.13>
  217a35:	48 8b 34 11          	mov    rsi,QWORD PTR [rcx+rdx*1]
  217a39:	c4 61 f9 6e c6       	vmovq  xmm8,rsi
    const new_bits = bits & 0xFFFFFFFFF8000000;
  217a3e:	48 81 e6 00 00 00 f8 	and    rsi,0xfffffffff8000000
    return @bitCast(f64, new_bits);
  217a45:	c4 e1 f9 6e c6       	vmovq  xmm0,rsi
    lo.* = val - hi.*;
  217a4a:	c5 bb 5c e0          	vsubsd xmm4,xmm8,xmm0
    const new_bits = bits & 0xFFFFFFFFF8000000;
  217a4e:	48 89 ee             	mov    rsi,rbp
  217a51:	48 81 e6 00 00 00 f8 	and    rsi,0xfffffffff8000000
    return @bitCast(f64, new_bits);
  217a58:	c4 e1 f9 6e ee       	vmovq  xmm5,rsi
    lo.* = val - hi.*;
  217a5d:	c5 a3 5c f5          	vsubsd xmm6,xmm11,xmm5
    const p = in.val * val;
  217a61:	c4 c1 23 59 d8       	vmulsd xmm3,xmm11,xmm8
    const e = ((hi * hi2 - p) + lo * hi2 + hi * lo2) + lo * lo2;
  217a66:	c5 d3 59 f8          	vmulsd xmm7,xmm5,xmm0
  217a6a:	c5 c3 5c fb          	vsubsd xmm7,xmm7,xmm3
  217a6e:	c5 db 59 ed          	vmulsd xmm5,xmm4,xmm5
  217a72:	c5 d3 58 ef          	vaddsd xmm5,xmm5,xmm7
  217a76:	c5 cb 59 c0          	vmulsd xmm0,xmm6,xmm0
  217a7a:	c5 fb 58 c5          	vaddsd xmm0,xmm0,xmm5
  217a7e:	c5 cb 59 e4          	vmulsd xmm4,xmm6,xmm4
  217a82:	c5 db 58 c0          	vaddsd xmm0,xmm4,xmm0
        .off = in.off * val + e,
  217a86:	c5 a3 59 64 11 08    	vmulsd xmm4,xmm11,QWORD PTR [rcx+rdx*1+0x8]
  217a8c:	c5 db 58 f0          	vaddsd xmm6,xmm4,xmm0
    exp -= 307;
  217a90:	8d 80 cd fe ff ff    	lea    eax,[rax-0x133]
    while (mid.val > 10.0 or (mid.val == 10.0 and mid.off >= 0.0)) {
  217a96:	44 0f bf e8          	movsx  r13d,ax
  217a9a:	c5 fb 10 25 86 87 fe 	vmovsd xmm4,QWORD PTR [rip+0xfffffffffffe8786]        # 200228 <__unnamed_90+0x48>
  217aa1:	ff 
  217aa2:	c5 7b 10 35 6e 87 fe 	vmovsd xmm14,QWORD PTR [rip+0xfffffffffffe876e]        # 200218 <__unnamed_90+0x38>
  217aa9:	ff 
  217aaa:	c5 fb 10 2d 06 88 fe 	vmovsd xmm5,QWORD PTR [rip+0xfffffffffffe8806]        # 2002b8 <app_mask+0x38>
  217ab1:	ff 
  217ab2:	c4 c1 79 2e de       	vucomisd xmm3,xmm14
  217ab7:	76 46                	jbe    217aff <formatFloatDecimal+0x93f>
  217ab9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
    hp.val /= 10.0;
  217ac0:	c4 c1 63 5e fe       	vdivsd xmm7,xmm3,xmm14
    hp.off /= 10.0;
  217ac5:	c4 c1 4b 5e f6       	vdivsd xmm6,xmm6,xmm14
    val -= hp.val * 8.0;
  217aca:	c5 c3 59 d5          	vmulsd xmm2,xmm7,xmm5
  217ace:	c5 e3 58 d2          	vaddsd xmm2,xmm3,xmm2
    val -= hp.val * 2.0;
  217ad2:	c5 c3 58 df          	vaddsd xmm3,xmm7,xmm7
  217ad6:	c5 eb 5c d3          	vsubsd xmm2,xmm2,xmm3
    hp.off += val / 10.0;
  217ada:	c4 c1 6b 5e d6       	vdivsd xmm2,xmm2,xmm14
  217adf:	c5 cb 58 d2          	vaddsd xmm2,xmm6,xmm2
    hp.val += hp.off;
  217ae3:	c5 c3 58 da          	vaddsd xmm3,xmm7,xmm2
    hp.off += val - hp.val;
  217ae7:	c5 c3 5c f3          	vsubsd xmm6,xmm7,xmm3
  217aeb:	c5 eb 58 f6          	vaddsd xmm6,xmm2,xmm6
        ten /= 10.0;
  217aef:	c4 c1 5b 5e e6       	vdivsd xmm4,xmm4,xmm14
    while (mid.val > 10.0 or (mid.val == 10.0 and mid.off >= 0.0)) {
  217af4:	41 83 c5 01          	add    r13d,0x1
  217af8:	c4 c1 79 2e de       	vucomisd xmm3,xmm14
  217afd:	77 c1                	ja     217ac0 <formatFloatDecimal+0x900>
  217aff:	c5 f9 2e f1          	vucomisd xmm6,xmm1
  217b03:	72 42                	jb     217b47 <formatFloatDecimal+0x987>
  217b05:	c4 c1 79 2e de       	vucomisd xmm3,xmm14
  217b0a:	75 3b                	jne    217b47 <formatFloatDecimal+0x987>
  217b0c:	7b b2                	jnp    217ac0 <formatFloatDecimal+0x900>
  217b0e:	eb 37                	jmp    217b47 <formatFloatDecimal+0x987>
    hp.val *= 10.0;
  217b10:	c4 c1 63 59 ce       	vmulsd xmm1,xmm3,xmm14
    hp.off *= 10.0;
  217b15:	c4 c1 4b 59 d6       	vmulsd xmm2,xmm6,xmm14
    off -= val * 8.0;
  217b1a:	c5 e3 59 2d 96 87 fe 	vmulsd xmm5,xmm3,QWORD PTR [rip+0xfffffffffffe8796]        # 2002b8 <app_mask+0x38>
  217b21:	ff 
  217b22:	c5 f3 58 ed          	vaddsd xmm5,xmm1,xmm5
    off -= val * 2.0;
  217b26:	c5 e3 58 db          	vaddsd xmm3,xmm3,xmm3
  217b2a:	c5 d3 5c db          	vsubsd xmm3,xmm5,xmm3
    hp.off -= off;
  217b2e:	c5 eb 5c d3          	vsubsd xmm2,xmm2,xmm3
    hp.val += hp.off;
  217b32:	c5 f3 58 da          	vaddsd xmm3,xmm1,xmm2
    hp.off += val - hp.val;
  217b36:	c5 f3 5c cb          	vsubsd xmm1,xmm1,xmm3
  217b3a:	c5 eb 58 f1          	vaddsd xmm6,xmm2,xmm1
        ten *= 10.0;
  217b3e:	c4 c1 5b 59 e6       	vmulsd xmm4,xmm4,xmm14
    while (mid.val < 1.0 or (mid.val == 1.0 and mid.off < 0.0)) {
  217b43:	41 83 c5 ff          	add    r13d,0xffffffff
  217b47:	c5 7b 10 0d d9 86 fe 	vmovsd xmm9,QWORD PTR [rip+0xfffffffffffe86d9]        # 200228 <__unnamed_90+0x48>
  217b4e:	ff 
  217b4f:	c5 79 2e cb          	vucomisd xmm9,xmm3
  217b53:	77 bb                	ja     217b10 <formatFloatDecimal+0x950>
  217b55:	c4 41 29 57 d2       	vxorpd xmm10,xmm10,xmm10
  217b5a:	c5 79 2e d6          	vucomisd xmm10,xmm6
  217b5e:	76 0c                	jbe    217b6c <formatFloatDecimal+0x9ac>
  217b60:	c5 f9 2e 1d c0 86 fe 	vucomisd xmm3,QWORD PTR [rip+0xfffffffffffe86c0]        # 200228 <__unnamed_90+0x48>
  217b67:	ff 
  217b68:	75 02                	jne    217b6c <formatFloatDecimal+0x9ac>
  217b6a:	7b a4                	jnp    217b10 <formatFloatDecimal+0x950>
    return @bitCast(f64, @bitCast(u64, val) +% 1);
  217b6c:	48 8d 45 01          	lea    rax,[rbp+0x1]
  217b70:	c4 e1 f9 6e c8       	vmovq  xmm1,rax
        .off = mid.off + (fpnext(val) - val) * lten * ten / 2.0,
  217b75:	c4 c1 73 5c cb       	vsubsd xmm1,xmm1,xmm11
    return @bitCast(f64, @bitCast(u64, val) -% 1);
  217b7a:	48 83 c5 ff          	add    rbp,0xffffffffffffffff
  217b7e:	c4 e1 f9 6e d5       	vmovq  xmm2,rbp
        .off = mid.off + (fpprev(val) - val) * lten * ten / 2.0,
  217b83:	c4 c1 6b 5c d3       	vsubsd xmm2,xmm2,xmm11
        .off = mid.off + (fpnext(val) - val) * lten * ten / 2.0,
  217b88:	c5 f1 14 ca          	vunpcklpd xmm1,xmm1,xmm2
  217b8c:	c4 c1 7b 12 d0       	vmovddup xmm2,xmm8
  217b91:	c5 f1 59 ca          	vmulpd xmm1,xmm1,xmm2
  217b95:	c5 fb 12 d4          	vmovddup xmm2,xmm4
  217b99:	c5 f1 59 ca          	vmulpd xmm1,xmm1,xmm2
  217b9d:	c5 f1 59 0d bb f1 fe 	vmulpd xmm1,xmm1,XMMWORD PTR [rip+0xfffffffffffef1bb]        # 206d60 <__unnamed_56+0x10>
  217ba4:	ff 
  217ba5:	c5 fb 12 d6          	vmovddup xmm2,xmm6
  217ba9:	c5 e9 58 c9          	vaddpd xmm1,xmm2,xmm1
    hp.val += hp.off;
  217bad:	c5 e3 58 e1          	vaddsd xmm4,xmm3,xmm1
    hp.off += val - hp.val;
  217bb1:	c5 e3 5c d4          	vsubsd xmm2,xmm3,xmm4
  217bb5:	c5 e9 14 d3          	vunpcklpd xmm2,xmm2,xmm3
  217bb9:	c5 f1 58 d2          	vaddpd xmm2,xmm1,xmm2
  217bbd:	c4 e3 79 05 f2 01    	vpermilpd xmm6,xmm2,0x1
  217bc3:	c5 e3 5c f6          	vsubsd xmm6,xmm3,xmm6
    while (high.val > 10.0 or (high.val == 10.0 and high.off >= 0.0)) {
  217bc7:	c4 e3 79 05 c9 01    	vpermilpd xmm1,xmm1,0x1
  217bcd:	c5 7b 10 1d f3 86 fe 	vmovsd xmm11,QWORD PTR [rip+0xfffffffffffe86f3]        # 2002c8 <app_mask+0x48>
  217bd4:	ff 
  217bd5:	c5 79 28 05 d3 ef fe 	vmovapd xmm8,XMMWORD PTR [rip+0xfffffffffffeefd3]        # 206bb0 <__unnamed_60+0x10>
  217bdc:	ff 
    hp.off += val - hp.val;
  217bdd:	c5 f3 58 ce          	vaddsd xmm1,xmm1,xmm6
    while (high.val > 10.0 or (high.val == 10.0 and high.off >= 0.0)) {
  217be1:	c4 c1 79 2e e6       	vucomisd xmm4,xmm14
  217be6:	0f 86 8a 00 00 00    	jbe    217c76 <formatFloatDecimal+0xab6>
  217bec:	eb 13                	jmp    217c01 <formatFloatDecimal+0xa41>
  217bee:	66 90                	xchg   ax,ax
  217bf0:	c4 c1 79 2e e6       	vucomisd xmm4,xmm14
  217bf5:	0f 85 86 00 00 00    	jne    217c81 <formatFloatDecimal+0xac1>
  217bfb:	0f 8a 80 00 00 00    	jp     217c81 <formatFloatDecimal+0xac1>
    hp.val /= 10.0;
  217c01:	c4 c1 5b 5e f6       	vdivsd xmm6,xmm4,xmm14
    val -= hp.val * 8.0;
  217c06:	c4 c1 4b 59 eb       	vmulsd xmm5,xmm6,xmm11
    hp.val /= 10.0;
  217c0b:	c4 e3 79 05 fa 01    	vpermilpd xmm7,xmm2,0x1
  217c11:	c4 c1 43 5e fe       	vdivsd xmm7,xmm7,xmm14
    hp.off /= 10.0;
  217c16:	c5 e9 14 c9          	vunpcklpd xmm1,xmm2,xmm1
  217c1a:	c4 c1 71 5e c8       	vdivpd xmm1,xmm1,xmm8
    val -= hp.val * 8.0;
  217c1f:	c4 c1 43 59 db       	vmulsd xmm3,xmm7,xmm11
  217c24:	c4 e3 69 0d d4 01    	vblendpd xmm2,xmm2,xmm4,0x1
  217c2a:	c5 d1 14 db          	vunpcklpd xmm3,xmm5,xmm3
  217c2e:	c5 e9 5c d3          	vsubpd xmm2,xmm2,xmm3
    val -= hp.val * 2.0;
  217c32:	c5 c9 14 df          	vunpcklpd xmm3,xmm6,xmm7
  217c36:	c5 e1 58 db          	vaddpd xmm3,xmm3,xmm3
  217c3a:	c5 e9 5c d3          	vsubpd xmm2,xmm2,xmm3
    hp.off += val / 10.0;
  217c3e:	c4 c1 69 5e d0       	vdivpd xmm2,xmm2,xmm8
  217c43:	c5 f1 58 ca          	vaddpd xmm1,xmm1,xmm2
    hp.val += hp.off;
  217c47:	c5 cb 58 e1          	vaddsd xmm4,xmm6,xmm1
    hp.off += val - hp.val;
  217c4b:	c5 cb 5c d4          	vsubsd xmm2,xmm6,xmm4
  217c4f:	c5 e9 14 d7          	vunpcklpd xmm2,xmm2,xmm7
  217c53:	c5 f1 58 d2          	vaddpd xmm2,xmm1,xmm2
  217c57:	c4 e3 79 05 da 01    	vpermilpd xmm3,xmm2,0x1
  217c5d:	c5 c3 5c f3          	vsubsd xmm6,xmm7,xmm3
    while (high.val > 10.0 or (high.val == 10.0 and high.off >= 0.0)) {
  217c61:	c4 e3 79 05 c9 01    	vpermilpd xmm1,xmm1,0x1
  217c67:	41 83 c5 01          	add    r13d,0x1
    hp.off += val - hp.val;
  217c6b:	c5 f3 58 ce          	vaddsd xmm1,xmm1,xmm6
    while (high.val > 10.0 or (high.val == 10.0 and high.off >= 0.0)) {
  217c6f:	c4 c1 79 2e e6       	vucomisd xmm4,xmm14
  217c74:	77 8b                	ja     217c01 <formatFloatDecimal+0xa41>
  217c76:	c4 c1 79 2e d2       	vucomisd xmm2,xmm10
  217c7b:	0f 83 6f ff ff ff    	jae    217bf0 <formatFloatDecimal+0xa30>
  217c81:	c5 d9 14 e1          	vunpcklpd xmm4,xmm4,xmm1
  217c85:	c5 79 28 25 23 ef fe 	vmovapd xmm12,XMMWORD PTR [rip+0xfffffffffffeef23]        # 206bb0 <__unnamed_60+0x10>
  217c8c:	ff 
  217c8d:	c4 41 39 57 c0       	vxorpd xmm8,xmm8,xmm8
    while (high.val < 1.0 or (high.val == 1.0 and high.off < 0.0)) {
  217c92:	c5 79 2e cc          	vucomisd xmm9,xmm4
  217c96:	0f 86 7e 00 00 00    	jbe    217d1a <formatFloatDecimal+0xb5a>
  217c9c:	eb 0b                	jmp    217ca9 <formatFloatDecimal+0xae9>
  217c9e:	66 90                	xchg   ax,ax
  217ca0:	c4 c1 79 2e e1       	vucomisd xmm4,xmm9
  217ca5:	75 79                	jne    217d20 <formatFloatDecimal+0xb60>
  217ca7:	7a 77                	jp     217d20 <formatFloatDecimal+0xb60>
    hp.val *= 10.0;
  217ca9:	c4 c1 5b 59 ce       	vmulsd xmm1,xmm4,xmm14
    off -= val * 8.0;
  217cae:	c4 c1 5b 59 eb       	vmulsd xmm5,xmm4,xmm11
  217cb3:	c5 f3 5c ed          	vsubsd xmm5,xmm1,xmm5
    off -= val * 2.0;
  217cb7:	c5 db 58 fc          	vaddsd xmm7,xmm4,xmm4
  217cbb:	c5 d3 5c ef          	vsubsd xmm5,xmm5,xmm7
    hp.off *= 10.0;
  217cbf:	c4 c1 69 59 fc       	vmulpd xmm7,xmm2,xmm12
  217cc4:	c4 e3 79 05 e4 01    	vpermilpd xmm4,xmm4,0x1
  217cca:	c4 c1 5b 59 e6       	vmulsd xmm4,xmm4,xmm14
    off -= val * 8.0;
  217ccf:	c4 e3 79 05 d2 01    	vpermilpd xmm2,xmm2,0x1
  217cd5:	c4 c1 6b 59 db       	vmulsd xmm3,xmm2,xmm11
  217cda:	c4 e3 79 05 f7 01    	vpermilpd xmm6,xmm7,0x1
  217ce0:	c5 cb 5c db          	vsubsd xmm3,xmm6,xmm3
    off -= val * 2.0;
  217ce4:	c5 eb 58 d2          	vaddsd xmm2,xmm2,xmm2
  217ce8:	c5 e3 5c d2          	vsubsd xmm2,xmm3,xmm2
    hp.off -= off;
  217cec:	c5 db 5c d2          	vsubsd xmm2,xmm4,xmm2
    hp.val += hp.off;
  217cf0:	c5 cb 58 da          	vaddsd xmm3,xmm6,xmm2
    hp.off -= off;
  217cf4:	c5 d1 14 e3          	vunpcklpd xmm4,xmm5,xmm3
  217cf8:	c5 c1 5c ec          	vsubpd xmm5,xmm7,xmm4
    hp.val += hp.off;
  217cfc:	c5 f1 14 d2          	vunpcklpd xmm2,xmm1,xmm2
  217d00:	c5 e9 58 e5          	vaddpd xmm4,xmm2,xmm5
    hp.off += val - hp.val;
  217d04:	c5 f3 5c cc          	vsubsd xmm1,xmm1,xmm4
  217d08:	c5 d3 58 c9          	vaddsd xmm1,xmm5,xmm1
  217d0c:	c5 f1 14 d3          	vunpcklpd xmm2,xmm1,xmm3
    while (high.val < 1.0 or (high.val == 1.0 and high.off < 0.0)) {
  217d10:	41 83 c5 ff          	add    r13d,0xffffffff
  217d14:	c5 79 2e cc          	vucomisd xmm9,xmm4
  217d18:	77 8f                	ja     217ca9 <formatFloatDecimal+0xae9>
  217d1a:	c5 79 2e c2          	vucomisd xmm8,xmm2
  217d1e:	77 80                	ja     217ca0 <formatFloatDecimal+0xae0>
    while (true) {
  217d20:	c4 e3 79 05 ea 01    	vpermilpd xmm5,xmm2,0x1
  217d26:	41 bc 01 00 00 00    	mov    r12d,0x1
  217d2c:	bf 34 0b 00 00       	mov    edi,0xb34
  217d31:	c4 41 10 57 ed       	vxorps xmm13,xmm13,xmm13
  217d36:	c5 7b 10 0d fa 84 fe 	vmovsd xmm9,QWORD PTR [rip+0xfffffffffffe84fa]        # 200238 <__unnamed_90+0x58>
  217d3d:	ff 
  217d3e:	c5 7b 10 15 2a 85 fe 	vmovsd xmm10,QWORD PTR [rip+0xfffffffffffe852a]        # 200270 <__unnamed_90+0x90>
  217d45:	ff 
  217d46:	c5 7b 10 05 02 85 fe 	vmovsd xmm8,QWORD PTR [rip+0xfffffffffffe8502]        # 200250 <__unnamed_90+0x70>
  217d4d:	ff 
    if (e >= 0x3FF + 52 or x == 0) {
  217d4e:	c4 c1 79 2e e5       	vucomisd xmm4,xmm13
  217d53:	0f 85 ab 00 00 00    	jne    217e04 <formatFloatDecimal+0xc44>
  217d59:	0f 8a a5 00 00 00    	jp     217e04 <formatFloatDecimal+0xc44>
  217d5f:	e9 07 01 00 00       	jmp    217e6b <formatFloatDecimal+0xcab>
  217d64:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  217d6b:	00 00 00 00 00 
        buffer[buf_index] = hdig + '0';
  217d70:	48 8b 04 24          	mov    rax,QWORD PTR [rsp]
        high.val -= @intToFloat(f64, hdig);
  217d74:	0f b6 d1             	movzx  edx,cl
        buffer[buf_index] = hdig + '0';
  217d77:	80 c1 30             	add    cl,0x30
  217d7a:	42 88 0c 20          	mov    BYTE PTR [rax+r12*1],cl
        buf_index += 1;
  217d7e:	49 83 c4 01          	add    r12,0x1
        high.val -= @intToFloat(f64, hdig);
  217d82:	c5 83 2a ca          	vcvtsi2sd xmm1,xmm15,edx
  217d86:	c5 db 5c d9          	vsubsd xmm3,xmm4,xmm1
        low.val -= @intToFloat(f64, ldig);
  217d8a:	c5 d3 5c c9          	vsubsd xmm1,xmm5,xmm1
    hp.val *= 10.0;
  217d8e:	c4 c1 63 59 ee       	vmulsd xmm5,xmm3,xmm14
    off -= val * 8.0;
  217d93:	c4 c1 63 59 e3       	vmulsd xmm4,xmm3,xmm11
  217d98:	c5 d3 5c e4          	vsubsd xmm4,xmm5,xmm4
    off -= val * 2.0;
  217d9c:	c5 e3 58 db          	vaddsd xmm3,xmm3,xmm3
    hp.off *= 10.0;
  217da0:	c5 e9 14 d1          	vunpcklpd xmm2,xmm2,xmm1
  217da4:	c4 c1 69 59 d4       	vmulpd xmm2,xmm2,xmm12
  217da9:	c4 c1 4b 59 f6       	vmulsd xmm6,xmm6,xmm14
    off -= val * 8.0;
  217dae:	c4 c1 73 59 fb       	vmulsd xmm7,xmm1,xmm11
  217db3:	c4 e3 79 05 c2 01    	vpermilpd xmm0,xmm2,0x1
  217db9:	c5 fb 5c c7          	vsubsd xmm0,xmm0,xmm7
    off -= val * 2.0;
  217dbd:	c5 f3 58 c9          	vaddsd xmm1,xmm1,xmm1
  217dc1:	c5 fb 5c c1          	vsubsd xmm0,xmm0,xmm1
    hp.off -= off;
  217dc5:	c5 cb 5c c0          	vsubsd xmm0,xmm6,xmm0
    off -= val * 2.0;
  217dc9:	c4 e3 69 0d cc 01    	vblendpd xmm1,xmm2,xmm4,0x1
  217dcf:	c5 e1 14 d8          	vunpcklpd xmm3,xmm3,xmm0
  217dd3:	c5 f1 5c e3          	vsubpd xmm4,xmm1,xmm3
  217dd7:	c5 f1 58 cb          	vaddpd xmm1,xmm1,xmm3
  217ddb:	c4 e3 71 0d dc 01    	vblendpd xmm3,xmm1,xmm4,0x1
    hp.off -= off;
  217de1:	c5 e9 5c d3          	vsubpd xmm2,xmm2,xmm3
    hp.val += hp.off;
  217de5:	c5 d1 14 c0          	vunpcklpd xmm0,xmm5,xmm0
  217de9:	c5 f9 58 e2          	vaddpd xmm4,xmm0,xmm2
    hp.off += val - hp.val;
  217ded:	c5 d3 5c c4          	vsubsd xmm0,xmm5,xmm4
  217df1:	c5 eb 58 d0          	vaddsd xmm2,xmm2,xmm0
    while (true) {
  217df5:	c4 e3 79 05 e9 01    	vpermilpd xmm5,xmm1,0x1
  217dfb:	c4 c1 79 2e e5       	vucomisd xmm4,xmm13
  217e00:	75 02                	jne    217e04 <formatFloatDecimal+0xc44>
  217e02:	7b 67                	jnp    217e6b <formatFloatDecimal+0xcab>
  217e04:	c4 e1 f9 7e e1       	vmovq  rcx,xmm4
  217e09:	c4 e2 c0 f7 d1       	bextr  rdx,rcx,rdi
  217e0e:	c5 f9 28 cc          	vmovapd xmm1,xmm4
  217e12:	48 81 fa 32 04 00 00 	cmp    rdx,0x432
  217e19:	77 54                	ja     217e6f <formatFloatDecimal+0xcaf>
    if (u >> 63 != 0) {
  217e1b:	48 85 c9             	test   rcx,rcx
  217e1e:	78 29                	js     217e49 <formatFloatDecimal+0xc89>
  217e20:	c4 c1 5b 58 ca       	vaddsd xmm1,xmm4,xmm10
  217e25:	c4 c1 73 58 c9       	vaddsd xmm1,xmm1,xmm9
    if (e <= 0x3FF - 1) {
  217e2a:	48 81 fa fe 03 00 00 	cmp    rdx,0x3fe
  217e31:	76 29                	jbe    217e5c <formatFloatDecimal+0xc9c>
  217e33:	c5 f3 5c cc          	vsubsd xmm1,xmm1,xmm4
            return -1.0;
        } else {
            return 0.0;
        }
    } else if (y > 0) {
  217e37:	c4 c1 79 2e cd       	vucomisd xmm1,xmm13
  217e3c:	c5 db 58 c9          	vaddsd xmm1,xmm4,xmm1
  217e40:	76 2d                	jbe    217e6f <formatFloatDecimal+0xcaf>
        return x + y - 1;
  217e42:	c4 c1 73 58 c8       	vaddsd xmm1,xmm1,xmm8
  217e47:	eb 26                	jmp    217e6f <formatFloatDecimal+0xcaf>
  217e49:	c4 c1 5b 58 c9       	vaddsd xmm1,xmm4,xmm9
  217e4e:	c4 c1 73 58 ca       	vaddsd xmm1,xmm1,xmm10
    if (e <= 0x3FF - 1) {
  217e53:	48 81 fa fe 03 00 00 	cmp    rdx,0x3fe
  217e5a:	77 d7                	ja     217e33 <formatFloatDecimal+0xc73>
        if (u >> 63 != 0) {
  217e5c:	c5 79 29 c1          	vmovapd xmm1,xmm8
    if (u >> 63 != 0) {
  217e60:	48 85 c9             	test   rcx,rcx
        if (u >> 63 != 0) {
  217e63:	78 0a                	js     217e6f <formatFloatDecimal+0xcaf>
  217e65:	c5 f1 57 c9          	vxorpd xmm1,xmm1,xmm1
  217e69:	eb 04                	jmp    217e6f <formatFloatDecimal+0xcaf>
  217e6b:	c5 f9 28 cc          	vmovapd xmm1,xmm4
        var hdig = @floatToInt(u8, math.floor(high.val));
  217e6f:	c5 fb 2c c9          	vcvttsd2si ecx,xmm1
        if ((high.val == @intToFloat(f64, hdig)) and (high.off < 0)) hdig -= 1;
  217e73:	0f b6 c9             	movzx  ecx,cl
  217e76:	c5 83 2a c9          	vcvtsi2sd xmm1,xmm15,ecx
  217e7a:	c5 f9 2e e1          	vucomisd xmm4,xmm1
  217e7e:	0f 9b c2             	setnp  dl
  217e81:	0f 94 c3             	sete   bl
  217e84:	20 d3                	and    bl,dl
  217e86:	c5 79 2e ea          	vucomisd xmm13,xmm2
  217e8a:	0f 97 c2             	seta   dl
  217e8d:	20 da                	and    dl,bl
  217e8f:	28 d1                	sub    cl,dl
    if (e >= 0x3FF + 52 or x == 0) {
  217e91:	c4 c1 79 2e ed       	vucomisd xmm5,xmm13
  217e96:	c5 f9 28 cd          	vmovapd xmm1,xmm5
  217e9a:	75 02                	jne    217e9e <formatFloatDecimal+0xcde>
  217e9c:	7b 72                	jnp    217f10 <formatFloatDecimal+0xd50>
  217e9e:	c4 e1 f9 7e ea       	vmovq  rdx,xmm5
  217ea3:	c4 e2 c0 f7 f2       	bextr  rsi,rdx,rdi
  217ea8:	c5 f9 28 cd          	vmovapd xmm1,xmm5
  217eac:	48 81 fe 32 04 00 00 	cmp    rsi,0x432
  217eb3:	77 5b                	ja     217f10 <formatFloatDecimal+0xd50>
    if (u >> 63 != 0) {
  217eb5:	48 85 d2             	test   rdx,rdx
  217eb8:	78 29                	js     217ee3 <formatFloatDecimal+0xd23>
  217eba:	c4 c1 53 58 ca       	vaddsd xmm1,xmm5,xmm10
  217ebf:	c4 c1 73 58 c9       	vaddsd xmm1,xmm1,xmm9
    if (e <= 0x3FF - 1) {
  217ec4:	48 81 fe fe 03 00 00 	cmp    rsi,0x3fe
  217ecb:	76 29                	jbe    217ef6 <formatFloatDecimal+0xd36>
  217ecd:	c5 f3 5c cd          	vsubsd xmm1,xmm1,xmm5
    } else if (y > 0) {
  217ed1:	c4 c1 79 2e cd       	vucomisd xmm1,xmm13
  217ed6:	c5 d3 58 c9          	vaddsd xmm1,xmm5,xmm1
  217eda:	76 34                	jbe    217f10 <formatFloatDecimal+0xd50>
        return x + y - 1;
  217edc:	c4 c1 73 58 c8       	vaddsd xmm1,xmm1,xmm8
  217ee1:	eb 2d                	jmp    217f10 <formatFloatDecimal+0xd50>
  217ee3:	c4 c1 53 58 c9       	vaddsd xmm1,xmm5,xmm9
  217ee8:	c4 c1 73 58 ca       	vaddsd xmm1,xmm1,xmm10
    if (e <= 0x3FF - 1) {
  217eed:	48 81 fe fe 03 00 00 	cmp    rsi,0x3fe
  217ef4:	77 d7                	ja     217ecd <formatFloatDecimal+0xd0d>
        if (u >> 63 != 0) {
  217ef6:	c5 79 29 c1          	vmovapd xmm1,xmm8
    if (u >> 63 != 0) {
  217efa:	48 85 d2             	test   rdx,rdx
        if (u >> 63 != 0) {
  217efd:	78 11                	js     217f10 <formatFloatDecimal+0xd50>
  217eff:	c5 f1 57 c9          	vxorpd xmm1,xmm1,xmm1
  217f03:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  217f0a:	84 00 00 00 00 00 
        var ldig = @floatToInt(u8, math.floor(low.val));
  217f10:	c5 fb 2c d1          	vcvttsd2si edx,xmm1
        if ((low.val == @intToFloat(f64, ldig)) and (low.off < 0)) ldig -= 1;
  217f14:	0f b6 d2             	movzx  edx,dl
  217f17:	c5 83 2a ca          	vcvtsi2sd xmm1,xmm15,edx
  217f1b:	c5 f9 2e e9          	vucomisd xmm5,xmm1
  217f1f:	0f 9b c3             	setnp  bl
  217f22:	0f 94 c0             	sete   al
  217f25:	20 d8                	and    al,bl
  217f27:	c4 e3 79 05 f4 01    	vpermilpd xmm6,xmm4,0x1
  217f2d:	c5 79 2e ee          	vucomisd xmm13,xmm6
  217f31:	0f 97 c3             	seta   bl
  217f34:	20 c3                	and    bl,al
  217f36:	28 da                	sub    dl,bl
        if (ldig != hdig) break;
  217f38:	38 ca                	cmp    dl,cl
  217f3a:	0f 84 30 fe ff ff    	je     217d70 <formatFloatDecimal+0xbb0>
    const tmp = (high.val + low.val) / 2.0;
  217f40:	c5 db 58 c5          	vaddsd xmm0,xmm4,xmm5
  217f44:	c5 fb 10 0d 0c 83 fe 	vmovsd xmm1,QWORD PTR [rip+0xfffffffffffe830c]        # 200258 <__unnamed_90+0x78>
  217f4b:	ff 
  217f4c:	c5 fb 59 c1          	vmulsd xmm0,xmm0,xmm1
    var mdig = @floatToInt(u8, math.floor(tmp + 0.5));
  217f50:	c5 fb 58 c9          	vaddsd xmm1,xmm0,xmm1
    if (e >= 0x3FF + 52 or x == 0) {
  217f54:	c5 e9 57 d2          	vxorpd xmm2,xmm2,xmm2
  217f58:	c5 f9 2e ca          	vucomisd xmm1,xmm2
  217f5c:	75 06                	jne    217f64 <formatFloatDecimal+0xda4>
  217f5e:	0f 8b c9 05 00 00    	jnp    21852d <formatFloatDecimal+0x136d>
  217f64:	c4 e1 f9 7e c8       	vmovq  rax,xmm1
  217f69:	b9 34 0b 00 00       	mov    ecx,0xb34
  217f6e:	c4 e2 f0 f7 c8       	bextr  rcx,rax,rcx
  217f73:	48 81 f9 32 04 00 00 	cmp    rcx,0x432
  217f7a:	0f 87 ad 05 00 00    	ja     21852d <formatFloatDecimal+0x136d>
    if (u >> 63 != 0) {
  217f80:	48 85 c0             	test   rax,rax
  217f83:	0f 88 0f 01 00 00    	js     218098 <formatFloatDecimal+0xed8>
  217f89:	c4 c1 73 58 d2       	vaddsd xmm2,xmm1,xmm10
  217f8e:	c4 c1 6b 58 d1       	vaddsd xmm2,xmm2,xmm9
    if (e <= 0x3FF - 1) {
  217f93:	48 81 f9 fe 03 00 00 	cmp    rcx,0x3fe
  217f9a:	0f 87 0f 01 00 00    	ja     2180af <formatFloatDecimal+0xeef>
    if (u >> 63 != 0) {
  217fa0:	48 85 c0             	test   rax,rax
        if (u >> 63 != 0) {
  217fa3:	0f 88 7c 05 00 00    	js     218525 <formatFloatDecimal+0x1365>
  217fa9:	c5 f1 57 c9          	vxorpd xmm1,xmm1,xmm1
  217fad:	e9 7b 05 00 00       	jmp    21852d <formatFloatDecimal+0x136d>
        while (i < mi) : (i += 1) {
  217fb2:	45 89 d1             	mov    r9d,r10d
  217fb5:	41 83 e1 f0          	and    r9d,0xfffffff0
  217fb9:	41 8d 49 f0          	lea    ecx,[r9-0x10]
  217fbd:	89 ca                	mov    edx,ecx
  217fbf:	c1 ea 04             	shr    edx,0x4
  217fc2:	44 8d 42 01          	lea    r8d,[rdx+0x1]
  217fc6:	83 f9 70             	cmp    ecx,0x70
  217fc9:	0f 83 03 01 00 00    	jae    2180d2 <formatFloatDecimal+0xf12>
  217fcf:	c4 e2 7d 59 0d b0 82 	vpbroadcastq ymm1,QWORD PTR [rip+0xfffffffffffe82b0]        # 200288 <app_mask+0x8>
  217fd6:	fe ff 
  217fd8:	c5 fd 6f d9          	vmovdqa ymm3,ymm1
  217fdc:	c5 fd 6f d1          	vmovdqa ymm2,ymm1
  217fe0:	c5 fd 6f c1          	vmovdqa ymm0,ymm1
  217fe4:	41 f6 c0 07          	test   r8b,0x7
  217fe8:	0f 85 70 01 00 00    	jne    21815e <formatFloatDecimal+0xf9e>
  217fee:	e9 e5 01 00 00       	jmp    2181d8 <formatFloatDecimal+0x1018>
        while (buffer[j - 1] == '0') {
  217ff3:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
  217ff7:	42 80 7c 29 ff 30    	cmp    BYTE PTR [rcx+r13*1-0x1],0x30
  217ffd:	49 89 d8             	mov    r8,rbx
  218000:	0f 85 f2 04 00 00    	jne    2184f8 <formatFloatDecimal+0x1338>
  218006:	49 8d 45 ff          	lea    rax,[r13-0x1]
  21800a:	4c 01 e9             	add    rcx,r13
  21800d:	48 83 c1 ff          	add    rcx,0xffffffffffffffff
  218011:	4d 89 ec             	mov    r12,r13
            buffer[j - 1] = 0;
  218014:	c6 01 00             	mov    BYTE PTR [rcx],0x0
        while (buffer[j - 1] == '0') {
  218017:	48 8b 14 24          	mov    rdx,QWORD PTR [rsp]
  21801b:	48 8d 0c 02          	lea    rcx,[rdx+rax*1]
  21801f:	48 83 c1 ff          	add    rcx,0xffffffffffffffff
  218023:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  218027:	42 80 7c 22 fe 30    	cmp    BYTE PTR [rdx+r12*1-0x2],0x30
  21802d:	4d 8d 64 24 ff       	lea    r12,[r12-0x1]
  218032:	74 e0                	je     218014 <formatFloatDecimal+0xe54>
  218034:	e9 c2 04 00 00       	jmp    2184fb <formatFloatDecimal+0x133b>
        } else if ((mid == 0.5) and (buffer[j - 1] & 0x1) != 0) {
  218039:	0f 85 bc 04 00 00    	jne    2184fb <formatFloatDecimal+0x133b>
  21803f:	0f 8a b6 04 00 00    	jp     2184fb <formatFloatDecimal+0x133b>
  218045:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
  218049:	8a 14 01             	mov    dl,BYTE PTR [rcx+rax*1]
  21804c:	f6 c2 01             	test   dl,0x1
  21804f:	0f 84 a6 04 00 00    	je     2184fb <formatFloatDecimal+0x133b>
            buffer[j - 1] += 1;
  218055:	80 c2 01             	add    dl,0x1
  218058:	88 14 01             	mov    BYTE PTR [rcx+rax*1],dl
  21805b:	e9 9b 04 00 00       	jmp    2184fb <formatFloatDecimal+0x133b>
  218060:	c5 fb 58 d2          	vaddsd xmm2,xmm0,xmm2
  218064:	c5 eb 58 d3          	vaddsd xmm2,xmm2,xmm3
    if (e <= 0x3FF - 1) {
  218068:	48 81 f9 fe 03 00 00 	cmp    rcx,0x3fe
  21806f:	0f 86 4d f7 ff ff    	jbe    2177c2 <formatFloatDecimal+0x602>
  218075:	c5 eb 5c d0          	vsubsd xmm2,xmm2,xmm0
    } else if (y > 0) {
  218079:	c5 e1 57 db          	vxorpd xmm3,xmm3,xmm3
  21807d:	c5 f9 2e d3          	vucomisd xmm2,xmm3
  218081:	c5 fb 58 c2          	vaddsd xmm0,xmm0,xmm2
  218085:	0f 86 7b f9 ff ff    	jbe    217a06 <formatFloatDecimal+0x846>
        return x + y - 1;
  21808b:	c5 fb 58 05 bd 81 fe 	vaddsd xmm0,xmm0,QWORD PTR [rip+0xfffffffffffe81bd]        # 200250 <__unnamed_90+0x70>
  218092:	ff 
  218093:	e9 6e f9 ff ff       	jmp    217a06 <formatFloatDecimal+0x846>
  218098:	c4 c1 73 58 d1       	vaddsd xmm2,xmm1,xmm9
  21809d:	c4 c1 6b 58 d2       	vaddsd xmm2,xmm2,xmm10
    if (e <= 0x3FF - 1) {
  2180a2:	48 81 f9 fe 03 00 00 	cmp    rcx,0x3fe
  2180a9:	0f 86 f1 fe ff ff    	jbe    217fa0 <formatFloatDecimal+0xde0>
  2180af:	c5 eb 5c d1          	vsubsd xmm2,xmm2,xmm1
    } else if (y > 0) {
  2180b3:	c5 e1 57 db          	vxorpd xmm3,xmm3,xmm3
  2180b7:	c5 f9 2e d3          	vucomisd xmm2,xmm3
  2180bb:	c5 f3 58 ca          	vaddsd xmm1,xmm1,xmm2
  2180bf:	0f 86 68 04 00 00    	jbe    21852d <formatFloatDecimal+0x136d>
        return x + y - 1;
  2180c5:	c5 f3 58 0d 83 81 fe 	vaddsd xmm1,xmm1,QWORD PTR [rip+0xfffffffffffe8183]        # 200250 <__unnamed_90+0x70>
  2180cc:	ff 
  2180cd:	e9 5b 04 00 00       	jmp    21852d <formatFloatDecimal+0x136d>
        while (i < mi) : (i += 1) {
  2180d2:	44 89 c1             	mov    ecx,r8d
  2180d5:	83 e1 07             	and    ecx,0x7
  2180d8:	83 c1 ff             	add    ecx,0xffffffff
  2180db:	29 d1                	sub    ecx,edx
  2180dd:	c4 e2 7d 59 0d a2 81 	vpbroadcastq ymm1,QWORD PTR [rip+0xfffffffffffe81a2]        # 200288 <app_mask+0x8>
  2180e4:	fe ff 
  2180e6:	c4 e2 7d 59 25 41 81 	vpbroadcastq ymm4,QWORD PTR [rip+0xfffffffffffe8141]        # 200230 <__unnamed_90+0x50>
  2180ed:	fe ff 
  2180ef:	c5 fd 6f d9          	vmovdqa ymm3,ymm1
  2180f3:	c5 fd 6f d1          	vmovdqa ymm2,ymm1
  2180f7:	c5 fd 6f c1          	vmovdqa ymm0,ymm1
            x *= 10;
  2180fb:	c5 f5 f4 ec          	vpmuludq ymm5,ymm1,ymm4
  2180ff:	c5 f5 73 d1 20       	vpsrlq ymm1,ymm1,0x20
  218104:	c5 f5 f4 cc          	vpmuludq ymm1,ymm1,ymm4
  218108:	c5 f5 73 f1 20       	vpsllq ymm1,ymm1,0x20
  21810d:	c5 d5 d4 c9          	vpaddq ymm1,ymm5,ymm1
  218111:	c5 e5 f4 ec          	vpmuludq ymm5,ymm3,ymm4
  218115:	c5 e5 73 d3 20       	vpsrlq ymm3,ymm3,0x20
  21811a:	c5 e5 f4 dc          	vpmuludq ymm3,ymm3,ymm4
  21811e:	c5 e5 73 f3 20       	vpsllq ymm3,ymm3,0x20
  218123:	c5 d5 d4 db          	vpaddq ymm3,ymm5,ymm3
  218127:	c5 ed f4 ec          	vpmuludq ymm5,ymm2,ymm4
  21812b:	c5 ed 73 d2 20       	vpsrlq ymm2,ymm2,0x20
  218130:	c5 ed f4 d4          	vpmuludq ymm2,ymm2,ymm4
  218134:	c5 ed 73 f2 20       	vpsllq ymm2,ymm2,0x20
  218139:	c5 d5 d4 d2          	vpaddq ymm2,ymm5,ymm2
  21813d:	c5 fd f4 ec          	vpmuludq ymm5,ymm0,ymm4
  218141:	c5 fd 73 d0 20       	vpsrlq ymm0,ymm0,0x20
  218146:	c5 fd f4 c4          	vpmuludq ymm0,ymm0,ymm4
  21814a:	c5 fd 73 f0 20       	vpsllq ymm0,ymm0,0x20
  21814f:	c5 d5 d4 c0          	vpaddq ymm0,ymm5,ymm0
  218153:	83 c1 08             	add    ecx,0x8
  218156:	75 a3                	jne    2180fb <formatFloatDecimal+0xf3b>
  218158:	41 f6 c0 07          	test   r8b,0x7
  21815c:	74 7a                	je     2181d8 <formatFloatDecimal+0x1018>
  21815e:	44 89 d2             	mov    edx,r10d
  218161:	83 e2 70             	and    edx,0x70
  218164:	83 c2 f0             	add    edx,0xfffffff0
  218167:	c1 ea 04             	shr    edx,0x4
  21816a:	83 c2 01             	add    edx,0x1
  21816d:	83 e2 07             	and    edx,0x7
  218170:	f7 da                	neg    edx
  218172:	c4 e2 7d 59 25 a5 80 	vpbroadcastq ymm4,QWORD PTR [rip+0xfffffffffffe80a5]        # 200220 <__unnamed_90+0x40>
  218179:	fe ff 
  21817b:	c5 f5 f4 ec          	vpmuludq ymm5,ymm1,ymm4
  21817f:	c5 f5 73 d1 20       	vpsrlq ymm1,ymm1,0x20
  218184:	c5 f5 f4 cc          	vpmuludq ymm1,ymm1,ymm4
  218188:	c5 f5 73 f1 20       	vpsllq ymm1,ymm1,0x20
  21818d:	c5 d5 d4 c9          	vpaddq ymm1,ymm5,ymm1
  218191:	c5 e5 f4 ec          	vpmuludq ymm5,ymm3,ymm4
  218195:	c5 e5 73 d3 20       	vpsrlq ymm3,ymm3,0x20
  21819a:	c5 e5 f4 dc          	vpmuludq ymm3,ymm3,ymm4
  21819e:	c5 e5 73 f3 20       	vpsllq ymm3,ymm3,0x20
  2181a3:	c5 d5 d4 db          	vpaddq ymm3,ymm5,ymm3
  2181a7:	c5 ed f4 ec          	vpmuludq ymm5,ymm2,ymm4
  2181ab:	c5 ed 73 d2 20       	vpsrlq ymm2,ymm2,0x20
  2181b0:	c5 ed f4 d4          	vpmuludq ymm2,ymm2,ymm4
  2181b4:	c5 ed 73 f2 20       	vpsllq ymm2,ymm2,0x20
  2181b9:	c5 d5 d4 d2          	vpaddq ymm2,ymm5,ymm2
  2181bd:	c5 fd f4 ec          	vpmuludq ymm5,ymm0,ymm4
  2181c1:	c5 fd 73 d0 20       	vpsrlq ymm0,ymm0,0x20
  2181c6:	c5 fd f4 c4          	vpmuludq ymm0,ymm0,ymm4
  2181ca:	c5 fd 73 f0 20       	vpsllq ymm0,ymm0,0x20
  2181cf:	c5 d5 d4 c0          	vpaddq ymm0,ymm5,ymm0
  2181d3:	83 c2 01             	add    edx,0x1
  2181d6:	75 a3                	jne    21817b <formatFloatDecimal+0xfbb>
  2181d8:	c5 dd 73 d3 20       	vpsrlq ymm4,ymm3,0x20
  2181dd:	c5 dd f4 e1          	vpmuludq ymm4,ymm4,ymm1
  2181e1:	c5 d5 73 d1 20       	vpsrlq ymm5,ymm1,0x20
  2181e6:	c5 e5 f4 ed          	vpmuludq ymm5,ymm3,ymm5
  2181ea:	c5 d5 d4 e4          	vpaddq ymm4,ymm5,ymm4
  2181ee:	c5 dd 73 f4 20       	vpsllq ymm4,ymm4,0x20
  2181f3:	c5 e5 f4 c9          	vpmuludq ymm1,ymm3,ymm1
  2181f7:	c5 f5 d4 cc          	vpaddq ymm1,ymm1,ymm4
  2181fb:	c5 e5 73 d2 20       	vpsrlq ymm3,ymm2,0x20
  218200:	c5 e5 f4 d9          	vpmuludq ymm3,ymm3,ymm1
  218204:	c5 dd 73 d1 20       	vpsrlq ymm4,ymm1,0x20
  218209:	c5 ed f4 e4          	vpmuludq ymm4,ymm2,ymm4
  21820d:	c5 dd d4 db          	vpaddq ymm3,ymm4,ymm3
  218211:	c5 e5 73 f3 20       	vpsllq ymm3,ymm3,0x20
  218216:	c5 ed f4 c9          	vpmuludq ymm1,ymm2,ymm1
  21821a:	c5 f5 d4 cb          	vpaddq ymm1,ymm1,ymm3
  21821e:	c5 ed 73 d0 20       	vpsrlq ymm2,ymm0,0x20
  218223:	c5 ed f4 d1          	vpmuludq ymm2,ymm2,ymm1
  218227:	c5 e5 73 d1 20       	vpsrlq ymm3,ymm1,0x20
  21822c:	c5 fd f4 db          	vpmuludq ymm3,ymm0,ymm3
  218230:	c5 e5 d4 d2          	vpaddq ymm2,ymm3,ymm2
  218234:	c5 ed 73 f2 20       	vpsllq ymm2,ymm2,0x20
  218239:	c5 fd f4 c1          	vpmuludq ymm0,ymm0,ymm1
  21823d:	c5 fd d4 c2          	vpaddq ymm0,ymm0,ymm2
  218241:	c4 e3 7d 39 c1 01    	vextracti128 xmm1,ymm0,0x1
  218247:	c5 ed 73 d0 20       	vpsrlq ymm2,ymm0,0x20
  21824c:	c5 ed f4 d1          	vpmuludq ymm2,ymm2,ymm1
  218250:	c5 e5 73 d1 20       	vpsrlq ymm3,ymm1,0x20
  218255:	c5 fd f4 db          	vpmuludq ymm3,ymm0,ymm3
  218259:	c5 e5 d4 d2          	vpaddq ymm2,ymm3,ymm2
  21825d:	c5 ed 73 f2 20       	vpsllq ymm2,ymm2,0x20
  218262:	c5 fd f4 c1          	vpmuludq ymm0,ymm0,ymm1
  218266:	c5 fd d4 c2          	vpaddq ymm0,ymm0,ymm2
  21826a:	c5 f9 70 c8 4e       	vpshufd xmm1,xmm0,0x4e
  21826f:	c5 ed 73 d0 20       	vpsrlq ymm2,ymm0,0x20
  218274:	c5 ed f4 d1          	vpmuludq ymm2,ymm2,ymm1
  218278:	c5 e5 73 d1 20       	vpsrlq ymm3,ymm1,0x20
  21827d:	c5 fd f4 db          	vpmuludq ymm3,ymm0,ymm3
  218281:	c5 e5 d4 d2          	vpaddq ymm2,ymm3,ymm2
  218285:	c5 ed 73 f2 20       	vpsllq ymm2,ymm2,0x20
  21828a:	c5 fd f4 c1          	vpmuludq ymm0,ymm0,ymm1
  21828e:	c5 fd d4 c2          	vpaddq ymm0,ymm0,ymm2
  218292:	c4 e1 f9 7e c2       	vmovq  rdx,xmm0
  218297:	45 39 ca             	cmp    r10d,r9d
        while (i < mi) : (i += 1) {
  21829a:	74 20                	je     2182bc <formatFloatDecimal+0x10fc>
  21829c:	41 09 c1             	or     r9d,eax
  21829f:	44 89 c8             	mov    eax,r9d
            x *= 10;
  2182a2:	f7 d8                	neg    eax
  2182a4:	29 d8                	sub    eax,ebx
  2182a6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  2182ad:	00 00 00 
  2182b0:	48 01 d2             	add    rdx,rdx
  2182b3:	48 8d 14 92          	lea    rdx,[rdx+rdx*4]
        while (i < mi) : (i += 1) {
  2182b7:	83 c0 ff             	add    eax,0xffffffff
  2182ba:	75 f4                	jne    2182b0 <formatFloatDecimal+0x10f0>
    const m64 = @truncate(u64, @divTrunc(mid, x));
  2182bc:	31 c9                	xor    ecx,ecx
  2182be:	c5 f8 77             	vzeroupper 
  2182c1:	e8 9a 48 00 00       	call   21cb60 <__udivti3>
    if (lf != hf) {
  2182c6:	4c 39 64 24 10       	cmp    QWORD PTR [rsp+0x10],r12
    if (lf != hf) mi += 19;
  2182cb:	44 0f 45 ed          	cmovne r13d,ebp
  2182cf:	48 89 e6             	mov    rsi,rsp
    var buf_index = u64toa(m64, buffer) - 1;
  2182d2:	48 89 c7             	mov    rdi,rax
  2182d5:	e8 66 03 00 00       	call   218640 <u64toa>
  2182da:	49 89 c4             	mov    r12,rax
    if (mi != 0) {
  2182dd:	45 85 ed             	test   r13d,r13d
  2182e0:	74 1c                	je     2182fe <formatFloatDecimal+0x113e>
  2182e2:	4c 89 e0             	mov    rax,r12
  2182e5:	48 83 c0 ff          	add    rax,0xffffffffffffffff
        buffer[buf_index - 1] += @boolToInt(buffer[buf_index] >= '5');
  2182e9:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
  2182ed:	42 80 7c 21 ff 34    	cmp    BYTE PTR [rcx+r12*1-0x1],0x34
  2182f3:	0f 97 c2             	seta   dl
  2182f6:	42 00 54 21 fe       	add    BYTE PTR [rcx+r12*1-0x2],dl
  2182fb:	49 89 c4             	mov    r12,rax
  2182fe:	4c 8b 44 24 20       	mov    r8,QWORD PTR [rsp+0x20]
        .digits = buffer[0..buf_index],
  218303:	4c 8b 0c 24          	mov    r9,QWORD PTR [rsp]
        .exp = @intCast(i32, buf_index) + mi,
  218307:	45 01 e5             	add    r13d,r12d
    if (maybe_precision) |precision| {
  21830a:	41 80 7e 08 01       	cmp    BYTE PTR [r14+0x8],0x1
  21830f:	0f 85 ac f5 ff ff    	jne    2178c1 <formatFloatDecimal+0x701>
  218315:	49 8b 36             	mov    rsi,QWORD PTR [r14]
            if (float_decimal.exp >= 0) {
  218318:	45 85 ed             	test   r13d,r13d
  21831b:	78 15                	js     218332 <formatFloatDecimal+0x1172>
                round_digit = precision + @intCast(usize, float_decimal.exp);
  21831d:	49 63 cd             	movsxd rcx,r13d
  218320:	48 01 f1             	add    rcx,rsi
    if (round_digit < float_decimal.digits.len and float_decimal.digits[round_digit] - '0' >= 5) {
  218323:	4c 39 e1             	cmp    rcx,r12
  218326:	48 89 74 24 30       	mov    QWORD PTR [rsp+0x30],rsi
  21832b:	72 26                	jb     218353 <formatFloatDecimal+0x1193>
  21832d:	e9 a5 00 00 00       	jmp    2183d7 <formatFloatDecimal+0x1217>
                const min_exp_required = @intCast(usize, -float_decimal.exp);
  218332:	44 89 e8             	mov    eax,r13d
  218335:	f7 d8                	neg    eax
  218337:	48 98                	cdqe   
                if (precision > min_exp_required) {
  218339:	31 c9                	xor    ecx,ecx
  21833b:	48 89 f2             	mov    rdx,rsi
  21833e:	48 29 c2             	sub    rdx,rax
  218341:	48 0f 47 ca          	cmova  rcx,rdx
    if (round_digit < float_decimal.digits.len and float_decimal.digits[round_digit] - '0' >= 5) {
  218345:	4c 39 e1             	cmp    rcx,r12
  218348:	48 89 74 24 30       	mov    QWORD PTR [rsp+0x30],rsi
  21834d:	0f 83 84 00 00 00    	jae    2183d7 <formatFloatDecimal+0x1217>
  218353:	41 8a 04 09          	mov    al,BYTE PTR [r9+rcx*1]
  218357:	04 d0                	add    al,0xd0
  218359:	3c 05                	cmp    al,0x5
  21835b:	72 7a                	jb     2183d7 <formatFloatDecimal+0x1217>
            if (i == 0) {
  21835d:	48 85 c9             	test   rcx,rcx
  218360:	74 64                	je     2183c6 <formatFloatDecimal+0x1206>
            const new_value = (float_decimal.digits[i] - '0' + 1) % 10;
  218362:	41 8a 44 09 ff       	mov    al,BYTE PTR [r9+rcx*1-0x1]
  218367:	04 d1                	add    al,0xd1
  218369:	0f b6 f0             	movzx  esi,al
  21836c:	69 c6 cd 00 00 00    	imul   eax,esi,0xcd
  218372:	ba 0b 05 00 00       	mov    edx,0x50b
  218377:	c4 e2 68 f7 c0       	bextr  eax,eax,edx
  21837c:	b3 0a                	mov    bl,0xa
  21837e:	f6 e3                	mul    bl
  218380:	40 28 c6             	sub    sil,al
            float_decimal.digits[i] = new_value + '0';
  218383:	89 f0                	mov    eax,esi
  218385:	0c 30                	or     al,0x30
  218387:	41 88 44 09 ff       	mov    BYTE PTR [r9+rcx*1-0x1],al
            if (new_value != 0) {
  21838c:	40 84 f6             	test   sil,sil
  21838f:	75 46                	jne    2183d7 <formatFloatDecimal+0x1217>
            if (i == 0) {
  218391:	48 83 f9 01          	cmp    rcx,0x1
  218395:	74 2f                	je     2183c6 <formatFloatDecimal+0x1206>
            const new_value = (float_decimal.digits[i] - '0' + 1) % 10;
  218397:	41 0f b6 44 09 fe    	movzx  eax,BYTE PTR [r9+rcx*1-0x2]
  21839d:	04 d1                	add    al,0xd1
  21839f:	0f b6 f0             	movzx  esi,al
  2183a2:	69 c6 cd 00 00 00    	imul   eax,esi,0xcd
  2183a8:	c4 e2 68 f7 c0       	bextr  eax,eax,edx
  2183ad:	f6 e3                	mul    bl
  2183af:	40 28 c6             	sub    sil,al
            float_decimal.digits[i] = new_value + '0';
  2183b2:	89 f0                	mov    eax,esi
  2183b4:	0c 30                	or     al,0x30
  2183b6:	41 88 44 09 fe       	mov    BYTE PTR [r9+rcx*1-0x2],al
            if (new_value != 0) {
  2183bb:	48 83 c1 ff          	add    rcx,0xffffffffffffffff
  2183bf:	40 84 f6             	test   sil,sil
  2183c2:	74 cd                	je     218391 <formatFloatDecimal+0x11d1>
  2183c4:	eb 11                	jmp    2183d7 <formatFloatDecimal+0x1217>
                float_decimal.exp += 1;
  2183c6:	41 83 c5 01          	add    r13d,0x1
                float_decimal.digits = one_before[0 .. float_decimal.digits.len + 1];
  2183ca:	49 83 c4 01          	add    r12,0x1
                float_decimal.digits[0] = '1';
  2183ce:	41 c6 41 ff 31       	mov    BYTE PTR [r9-0x1],0x31
                const one_before = @intToPtr([*]u8, @ptrToInt(&float_decimal.digits[0]) - 1);
  2183d3:	49 83 c1 ff          	add    r9,0xffffffffffffffff
        var num_digits_whole = if (float_decimal.exp > 0) @intCast(usize, float_decimal.exp) else 0;
  2183d7:	31 db                	xor    ebx,ebx
  2183d9:	45 85 ed             	test   r13d,r13d
  2183dc:	44 89 e8             	mov    eax,r13d
  2183df:	48 0f 4f d8          	cmovg  rbx,rax
  2183e3:	4c 39 e3             	cmp    rbx,r12
  2183e6:	4c 89 e0             	mov    rax,r12
  2183e9:	48 0f 42 c3          	cmovb  rax,rbx
  2183ed:	45 85 ed             	test   r13d,r13d
        if (num_digits_whole > 0) {
  2183f0:	4c 89 4c 24 10       	mov    QWORD PTR [rsp+0x10],r9
  2183f5:	48 89 44 24 48       	mov    QWORD PTR [rsp+0x48],rax
  2183fa:	7e 5a                	jle    218456 <formatFloatDecimal+0x1296>
            try output(context, float_decimal.digits[0..num_digits_whole_no_pad]);
  2183fc:	4c 89 8c 24 b8 00 00 	mov    QWORD PTR [rsp+0xb8],r9
  218403:	00 
  218404:	48 89 84 24 c0 00 00 	mov    QWORD PTR [rsp+0xc0],rax
  21840b:	00 
  21840c:	48 8d b4 24 b8 00 00 	lea    rsi,[rsp+0xb8]
  218413:	00 
  218414:	4c 89 ff             	mov    rdi,r15
  218417:	4c 89 c5             	mov    rbp,r8
  21841a:	c5 f8 77             	vzeroupper 
  21841d:	41 ff d0             	call   r8
  218420:	66 85 c0             	test   ax,ax
  218423:	0f 85 55 ee ff ff    	jne    21727e <formatFloatDecimal+0xbe>
            while (i < num_digits_whole) : (i += 1) {
  218429:	4c 39 e3             	cmp    rbx,r12
  21842c:	76 44                	jbe    218472 <formatFloatDecimal+0x12b2>
  21842e:	4c 8b 74 24 48       	mov    r14,QWORD PTR [rsp+0x48]
                try output(context, "0");
  218433:	4c 89 ff             	mov    rdi,r15
  218436:	48 8d 35 d3 89 00 00 	lea    rsi,[rip+0x89d3]        # 220e10 <__unnamed_89>
  21843d:	48 89 e8             	mov    rax,rbp
  218440:	ff d0                	call   rax
  218442:	66 85 c0             	test   ax,ax
  218445:	0f 85 33 ee ff ff    	jne    21727e <formatFloatDecimal+0xbe>
  21844b:	49 83 c6 01          	add    r14,0x1
            while (i < num_digits_whole) : (i += 1) {
  21844f:	49 39 de             	cmp    r14,rbx
  218452:	72 df                	jb     218433 <formatFloatDecimal+0x1273>
  218454:	eb 1c                	jmp    218472 <formatFloatDecimal+0x12b2>
            try output(context, "0");
  218456:	48 8d 35 b3 89 00 00 	lea    rsi,[rip+0x89b3]        # 220e10 <__unnamed_89>
  21845d:	4c 89 ff             	mov    rdi,r15
  218460:	4c 89 c5             	mov    rbp,r8
  218463:	c5 f8 77             	vzeroupper 
  218466:	41 ff d0             	call   r8
  218469:	66 85 c0             	test   ax,ax
  21846c:	0f 85 0c ee ff ff    	jne    21727e <formatFloatDecimal+0xbe>
        if (precision == 0) {
  218472:	48 83 7c 24 30 00    	cmp    QWORD PTR [rsp+0x30],0x0
  218478:	0f 84 b0 01 00 00    	je     21862e <formatFloatDecimal+0x146e>
        try output(context, ".");
  21847e:	48 8d 35 7b 89 00 00 	lea    rsi,[rip+0x897b]        # 220e00 <__unnamed_91>
  218485:	4c 89 ff             	mov    rdi,r15
  218488:	48 89 6c 24 20       	mov    QWORD PTR [rsp+0x20],rbp
  21848d:	ff d5                	call   rbp
  21848f:	66 85 c0             	test   ax,ax
  218492:	0f 85 e6 ed ff ff    	jne    21727e <formatFloatDecimal+0xbe>
        if (float_decimal.exp <= 0) {
  218498:	45 85 ed             	test   r13d,r13d
  21849b:	0f 8e 37 01 00 00    	jle    2185d8 <formatFloatDecimal+0x1418>
  2184a1:	31 db                	xor    ebx,ebx
  2184a3:	48 8b 4c 24 20       	mov    rcx,QWORD PTR [rsp+0x20]
  2184a8:	48 8b 44 24 30       	mov    rax,QWORD PTR [rsp+0x30]
        debug.assert(precision >= printed);
  2184ad:	48 39 d8             	cmp    rax,rbx
  2184b0:	0f 82 7f 01 00 00    	jb     218635 <formatFloatDecimal+0x1475>
  2184b6:	48 8b 74 24 48       	mov    rsi,QWORD PTR [rsp+0x48]
        if (num_digits_whole_no_pad + precision - printed < float_decimal.digits.len) {
  2184bb:	48 8d 04 06          	lea    rax,[rsi+rax*1]
  2184bf:	48 29 d8             	sub    rax,rbx
  2184c2:	4c 39 e0             	cmp    rax,r12
  2184c5:	48 8b 54 24 10       	mov    rdx,QWORD PTR [rsp+0x10]
  2184ca:	0f 83 a2 00 00 00    	jae    218572 <formatFloatDecimal+0x13b2>
            try output(context, float_decimal.digits[num_digits_whole_no_pad .. num_digits_whole_no_pad + precision - printed]);
  2184d0:	48 01 f2             	add    rdx,rsi
  2184d3:	48 89 94 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],rdx
  2184da:	00 
  2184db:	48 29 f0             	sub    rax,rsi
  2184de:	48 89 84 24 b0 00 00 	mov    QWORD PTR [rsp+0xb0],rax
  2184e5:	00 
  2184e6:	48 8d b4 24 a8 00 00 	lea    rsi,[rsp+0xa8]
  2184ed:	00 
  2184ee:	4c 89 ff             	mov    rdi,r15
  2184f1:	ff d1                	call   rcx
  2184f3:	e9 86 ed ff ff       	jmp    21727e <formatFloatDecimal+0xbe>
  2184f8:	4d 89 ec             	mov    r12,r13
    buffer[j] = 0;
  2184fb:	48 8b 04 24          	mov    rax,QWORD PTR [rsp]
  2184ff:	42 c6 04 20 00       	mov    BYTE PTR [rax+r12*1],0x0
        .digits = buffer[0..j],
  218504:	4c 8b 0c 24          	mov    r9,QWORD PTR [rsp]
    if (maybe_precision) |precision| {
  218508:	41 80 7e 08 01       	cmp    BYTE PTR [r14+0x8],0x1
  21850d:	0f 84 02 fe ff ff    	je     218315 <formatFloatDecimal+0x1155>
  218513:	e9 a9 f3 ff ff       	jmp    2178c1 <formatFloatDecimal+0x701>
  218518:	c5 fb 10 05 30 7d fe 	vmovsd xmm0,QWORD PTR [rip+0xfffffffffffe7d30]        # 200250 <__unnamed_90+0x70>
  21851f:	ff 
  218520:	e9 e1 f4 ff ff       	jmp    217a06 <formatFloatDecimal+0x846>
  218525:	c5 fb 10 0d 23 7d fe 	vmovsd xmm1,QWORD PTR [rip+0xfffffffffffe7d23]        # 200250 <__unnamed_90+0x70>
  21852c:	ff 
    var mdig = @floatToInt(u8, math.floor(tmp + 0.5));
  21852d:	c5 fb 2c c1          	vcvttsd2si eax,xmm1
    if ((@intToFloat(f64, mdig) - tmp) == 0.5 and (mdig & 0x1) != 0) mdig -= 1;
  218531:	0f b6 c0             	movzx  eax,al
  218534:	c5 83 2a c8          	vcvtsi2sd xmm1,xmm15,eax
  218538:	c5 f3 5c c0          	vsubsd xmm0,xmm1,xmm0
  21853c:	c5 f9 2e 05 14 7d fe 	vucomisd xmm0,QWORD PTR [rip+0xfffffffffffe7d14]        # 200258 <__unnamed_90+0x78>
  218543:	ff 
  218544:	0f 9b c1             	setnp  cl
  218547:	0f 94 c2             	sete   dl
  21854a:	20 ca                	and    dl,cl
  21854c:	20 c2                	and    dl,al
    buffer[buf_index] = mdig + '0';
  21854e:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
    if ((@intToFloat(f64, mdig) - tmp) == 0.5 and (mdig & 0x1) != 0) mdig -= 1;
  218552:	28 d0                	sub    al,dl
    buffer[buf_index] = mdig + '0';
  218554:	04 30                	add    al,0x30
  218556:	42 88 04 21          	mov    BYTE PTR [rcx+r12*1],al
        .digits = buffer[1..buf_index],
  21855a:	4c 8b 0c 24          	mov    r9,QWORD PTR [rsp]
  21855e:	49 83 c1 01          	add    r9,0x1
  218562:	41 80 7e 08 01       	cmp    BYTE PTR [r14+0x8],0x1
  218567:	0f 84 a8 fd ff ff    	je     218315 <formatFloatDecimal+0x1155>
  21856d:	e9 4f f3 ff ff       	jmp    2178c1 <formatFloatDecimal+0x701>
            try output(context, float_decimal.digits[num_digits_whole_no_pad..]);
  218572:	48 01 f2             	add    rdx,rsi
  218575:	48 89 94 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rdx
  21857c:	00 
  21857d:	49 29 f4             	sub    r12,rsi
  218580:	4c 89 a4 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],r12
  218587:	00 
  218588:	48 8d b4 24 98 00 00 	lea    rsi,[rsp+0x98]
  21858f:	00 
  218590:	4c 89 ff             	mov    rdi,r15
  218593:	ff d1                	call   rcx
  218595:	66 85 c0             	test   ax,ax
  218598:	0f 85 e0 ec ff ff    	jne    21727e <formatFloatDecimal+0xbe>
            printed += float_decimal.digits.len - num_digits_whole_no_pad;
  21859e:	4c 01 e3             	add    rbx,r12
            while (printed < precision) : (printed += 1) {
  2185a1:	48 3b 5c 24 30       	cmp    rbx,QWORD PTR [rsp+0x30]
  2185a6:	0f 83 82 00 00 00    	jae    21862e <formatFloatDecimal+0x146e>
  2185ac:	48 8d 2d 5d 88 00 00 	lea    rbp,[rip+0x885d]        # 220e10 <__unnamed_89>
                try output(context, "0");
  2185b3:	4c 89 ff             	mov    rdi,r15
  2185b6:	48 89 ee             	mov    rsi,rbp
  2185b9:	ff 54 24 20          	call   QWORD PTR [rsp+0x20]
  2185bd:	66 85 c0             	test   ax,ax
  2185c0:	0f 85 b8 ec ff ff    	jne    21727e <formatFloatDecimal+0xbe>
  2185c6:	48 83 c3 01          	add    rbx,0x1
  2185ca:	31 c0                	xor    eax,eax
            while (printed < precision) : (printed += 1) {
  2185cc:	48 3b 5c 24 30       	cmp    rbx,QWORD PTR [rsp+0x30]
  2185d1:	72 e0                	jb     2185b3 <formatFloatDecimal+0x13f3>
  2185d3:	e9 a6 ec ff ff       	jmp    21727e <formatFloatDecimal+0xbe>
            const zero_digit_count = @intCast(usize, -float_decimal.exp);
  2185d8:	41 f7 dd             	neg    r13d
  2185db:	4d 63 f5             	movsxd r14,r13d
  2185de:	48 8b 44 24 30       	mov    rax,QWORD PTR [rsp+0x30]
  2185e3:	4c 39 f0             	cmp    rax,r14
  2185e6:	4c 0f 46 f0          	cmovbe r14,rax
            while (i < zeros_to_print) : (i += 1) {
  2185ea:	4d 85 f6             	test   r14,r14
  2185ed:	48 8b 4c 24 20       	mov    rcx,QWORD PTR [rsp+0x20]
  2185f2:	74 2a                	je     21861e <formatFloatDecimal+0x145e>
  2185f4:	31 db                	xor    ebx,ebx
  2185f6:	4c 8d 2d 13 88 00 00 	lea    r13,[rip+0x8813]        # 220e10 <__unnamed_89>
                try output(context, "0");
  2185fd:	4c 89 ff             	mov    rdi,r15
  218600:	4c 89 ee             	mov    rsi,r13
  218603:	ff d1                	call   rcx
  218605:	66 85 c0             	test   ax,ax
  218608:	0f 85 70 ec ff ff    	jne    21727e <formatFloatDecimal+0xbe>
            while (i < zeros_to_print) : (i += 1) {
  21860e:	48 83 c3 01          	add    rbx,0x1
  218612:	4c 39 f3             	cmp    rbx,r14
  218615:	48 8b 4c 24 20       	mov    rcx,QWORD PTR [rsp+0x20]
  21861a:	72 e1                	jb     2185fd <formatFloatDecimal+0x143d>
  21861c:	eb 02                	jmp    218620 <formatFloatDecimal+0x1460>
  21861e:	31 db                	xor    ebx,ebx
  218620:	48 8b 44 24 30       	mov    rax,QWORD PTR [rsp+0x30]
            if (printed >= precision) {
  218625:	48 39 c3             	cmp    rbx,rax
  218628:	0f 82 7f fe ff ff    	jb     2184ad <formatFloatDecimal+0x12ed>
  21862e:	31 c0                	xor    eax,eax
  218630:	e9 49 ec ff ff       	jmp    21727e <formatFloatDecimal+0xbe>
            @panic("assertion failure");
  218635:	e8 e6 06 ff ff       	call   208d20 <panic>
  21863a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000218640 <u64toa>:
    if (value < kTen8) {
  218640:	41 57                	push   r15
  218642:	41 56                	push   r14
  218644:	53                   	push   rbx
  218645:	48 81 ff ff e0 f5 05 	cmp    rdi,0x5f5e0ff
  21864c:	77 4b                	ja     218699 <u64toa+0x59>
            const b: u32 = v / 10000;
  21864e:	89 f8                	mov    eax,edi
        if (v < 10000) {
  218650:	81 ff 0f 27 00 00    	cmp    edi,0x270f
  218656:	0f 87 48 01 00 00    	ja     2187a4 <u64toa+0x164>
            const d1: u32 = (v / 100) << 1;
  21865c:	48 69 d0 1f 85 eb 51 	imul   rdx,rax,0x51eb851f
  218663:	48 c1 ea 25          	shr    rdx,0x25
            const d2: u32 = (v % 100) << 1;
  218667:	6b c2 64             	imul   eax,edx,0x64
            const d1: u32 = (v / 100) << 1;
  21866a:	48 01 d2             	add    rdx,rdx
            const d2: u32 = (v % 100) << 1;
  21866d:	89 f9                	mov    ecx,edi
  21866f:	29 c1                	sub    ecx,eax
  218671:	48 01 c9             	add    rcx,rcx
            if (v >= 1000) {
  218674:	81 ff e8 03 00 00    	cmp    edi,0x3e8
  21867a:	0f 82 bf 01 00 00    	jb     21883f <u64toa+0x1ff>
                buffer[buf_index] = c_digits_lut[d1];
  218680:	48 8b 06             	mov    rax,QWORD PTR [rsi]
  218683:	48 8d 3d 06 cc fe ff 	lea    rdi,[rip+0xfffffffffffecc06]        # 205290 <c_digits_lut>
  21868a:	8a 1c 3a             	mov    bl,BYTE PTR [rdx+rdi*1]
  21868d:	88 18                	mov    BYTE PTR [rax],bl
  21868f:	b8 01 00 00 00       	mov    eax,0x1
  218694:	e9 b1 01 00 00       	jmp    21884a <u64toa+0x20a>
  218699:	48 b9 00 00 c1 6f f2 	movabs rcx,0x2386f26fc10000
  2186a0:	86 23 00 
    } else if (value < kTen16) {
  2186a3:	48 39 cf             	cmp    rdi,rcx
  2186a6:	0f 83 71 01 00 00    	jae    21881d <u64toa+0x1dd>
        const v0: u32 = @intCast(u32, value / kTen8);
  2186ac:	48 b8 fd ce 61 84 11 	movabs rax,0xabcc77118461cefd
  2186b3:	77 cc ab 
  2186b6:	48 89 fa             	mov    rdx,rdi
  2186b9:	c4 62 fb f6 f8       	mulx   r15,rax,rax
  2186be:	49 c1 ef 1a          	shr    r15,0x1a
        const v1: u32 = @intCast(u32, value % kTen8);
  2186c2:	49 69 cf 00 e1 f5 05 	imul   rcx,r15,0x5f5e100
  2186c9:	48 89 f8             	mov    rax,rdi
  2186cc:	48 29 c8             	sub    rax,rcx
        const b0: u32 = v0 / 10000;
  2186cf:	44 89 fb             	mov    ebx,r15d
  2186d2:	41 be 59 17 b7 d1    	mov    r14d,0xd1b71759
        const d1: u32 = (b0 / 100) << 1;
  2186d8:	48 69 cb 83 de 1b 43 	imul   rcx,rbx,0x431bde83
        const b0: u32 = v0 / 10000;
  2186df:	49 0f af de          	imul   rbx,r14
  2186e3:	48 c1 eb 2d          	shr    rbx,0x2d
        const c0: u32 = v0 % 10000;
  2186e7:	69 d3 10 27 00 00    	imul   edx,ebx,0x2710
  2186ed:	41 29 d7             	sub    r15d,edx
        const d1: u32 = (b0 / 100) << 1;
  2186f0:	48 c1 e9 31          	shr    rcx,0x31
  2186f4:	81 e1 fe 3f 00 00    	and    ecx,0x3ffe
        const d2: u32 = (b0 % 100) << 1;
  2186fa:	48 69 d3 1f 85 eb 51 	imul   rdx,rbx,0x51eb851f
  218701:	48 c1 ea 25          	shr    rdx,0x25
  218705:	6b d2 64             	imul   edx,edx,0x64
  218708:	29 d3                	sub    ebx,edx
  21870a:	48 01 db             	add    rbx,rbx
        const d3: u32 = (c0 / 100) << 1;
  21870d:	4d 69 df 1f 85 eb 51 	imul   r11,r15,0x51eb851f
  218714:	49 c1 eb 25          	shr    r11,0x25
        const d4: u32 = (c0 % 100) << 1;
  218718:	41 6b d3 64          	imul   edx,r11d,0x64
        const d3: u32 = (c0 / 100) << 1;
  21871c:	4d 01 db             	add    r11,r11
        const d4: u32 = (c0 % 100) << 1;
  21871f:	41 29 d7             	sub    r15d,edx
  218722:	4d 01 ff             	add    r15,r15
        const b1: u32 = v1 / 10000;
  218725:	4c 0f af f0          	imul   r14,rax
  218729:	49 c1 ee 2d          	shr    r14,0x2d
        const c1: u32 = v1 % 10000;
  21872d:	41 69 d6 10 27 00 00 	imul   edx,r14d,0x2710
        const d5: u32 = (b1 / 100) << 1;
  218734:	4c 69 c8 83 de 1b 43 	imul   r9,rax,0x431bde83
        const c1: u32 = v1 % 10000;
  21873b:	41 89 c0             	mov    r8d,eax
  21873e:	41 29 d0             	sub    r8d,edx
        const d5: u32 = (b1 / 100) << 1;
  218741:	49 c1 e9 31          	shr    r9,0x31
  218745:	41 81 e1 fe 01 00 00 	and    r9d,0x1fe
        const d6: u32 = (b1 % 100) << 1;
  21874c:	49 69 c6 1f 85 eb 51 	imul   rax,r14,0x51eb851f
  218753:	48 c1 e8 25          	shr    rax,0x25
  218757:	6b c0 64             	imul   eax,eax,0x64
  21875a:	41 29 c6             	sub    r14d,eax
  21875d:	4d 01 f6             	add    r14,r14
        const d7: u32 = (c1 / 100) << 1;
  218760:	4d 69 d0 1f 85 eb 51 	imul   r10,r8,0x51eb851f
  218767:	49 c1 ea 25          	shr    r10,0x25
        const d8: u32 = (c1 % 100) << 1;
  21876b:	41 6b c2 64          	imul   eax,r10d,0x64
        const d7: u32 = (c1 / 100) << 1;
  21876f:	4d 01 d2             	add    r10,r10
        const d8: u32 = (c1 % 100) << 1;
  218772:	41 29 c0             	sub    r8d,eax
  218775:	4d 01 c0             	add    r8,r8
        if (value >= kTen15) {
  218778:	48 b8 00 80 c6 a4 7e 	movabs rax,0x38d7ea4c68000
  21877f:	8d 03 00 
  218782:	48 39 c7             	cmp    rdi,rax
  218785:	0f 82 07 01 00 00    	jb     218892 <u64toa+0x252>
            buffer[buf_index] = c_digits_lut[d1];
  21878b:	48 8b 06             	mov    rax,QWORD PTR [rsi]
  21878e:	48 8d 15 fb ca fe ff 	lea    rdx,[rip+0xfffffffffffecafb]        # 205290 <c_digits_lut>
  218795:	8a 14 11             	mov    dl,BYTE PTR [rcx+rdx*1]
  218798:	88 10                	mov    BYTE PTR [rax],dl
  21879a:	b8 01 00 00 00       	mov    eax,0x1
  21879f:	e9 03 01 00 00       	jmp    2188a7 <u64toa+0x267>
            const b: u32 = v / 10000;
  2187a4:	ba 59 17 b7 d1       	mov    edx,0xd1b71759
  2187a9:	48 0f af d0          	imul   rdx,rax
  2187ad:	48 c1 ea 2d          	shr    rdx,0x2d
            const c: u32 = v % 10000;
  2187b1:	69 da 10 27 00 00    	imul   ebx,edx,0x2710
  2187b7:	89 f9                	mov    ecx,edi
  2187b9:	29 d9                	sub    ecx,ebx
            const d1: u32 = (b / 100) << 1;
  2187bb:	48 69 d8 83 de 1b 43 	imul   rbx,rax,0x431bde83
  2187c2:	48 c1 eb 31          	shr    rbx,0x31
            const d2: u32 = (b % 100) << 1;
  2187c6:	48 69 c2 1f 85 eb 51 	imul   rax,rdx,0x51eb851f
  2187cd:	48 c1 e8 25          	shr    rax,0x25
  2187d1:	6b c0 64             	imul   eax,eax,0x64
            const d1: u32 = (b / 100) << 1;
  2187d4:	81 e3 fe 3f 00 00    	and    ebx,0x3ffe
            const d2: u32 = (b % 100) << 1;
  2187da:	29 c2                	sub    edx,eax
  2187dc:	48 01 d2             	add    rdx,rdx
            const d3: u32 = (c / 100) << 1;
  2187df:	4c 69 c1 1f 85 eb 51 	imul   r8,rcx,0x51eb851f
  2187e6:	49 c1 e8 25          	shr    r8,0x25
            const d4: u32 = (c % 100) << 1;
  2187ea:	41 6b c0 64          	imul   eax,r8d,0x64
            const d3: u32 = (c / 100) << 1;
  2187ee:	4d 01 c0             	add    r8,r8
            const d4: u32 = (c % 100) << 1;
  2187f1:	29 c1                	sub    ecx,eax
  2187f3:	48 01 c9             	add    rcx,rcx
            if (value >= 10000000) {
  2187f6:	48 81 ff 80 96 98 00 	cmp    rdi,0x989680
  2187fd:	0f 82 b0 01 00 00    	jb     2189b3 <u64toa+0x373>
                buffer[buf_index] = c_digits_lut[d1];
  218803:	4c 8b 0e             	mov    r9,QWORD PTR [rsi]
  218806:	48 8d 3d 83 ca fe ff 	lea    rdi,[rip+0xfffffffffffeca83]        # 205290 <c_digits_lut>
  21880d:	8a 04 3b             	mov    al,BYTE PTR [rbx+rdi*1]
  218810:	41 88 01             	mov    BYTE PTR [r9],al
  218813:	b8 01 00 00 00       	mov    eax,0x1
  218818:	e9 a5 01 00 00       	jmp    2189c2 <u64toa+0x382>
        value %= kTen16;
  21881d:	31 d2                	xor    edx,edx
  21881f:	48 89 f8             	mov    rax,rdi
  218822:	48 f7 f1             	div    rcx
        if (a < 10) {
  218825:	83 f8 09             	cmp    eax,0x9
  218828:	0f 87 0e 02 00 00    	ja     218a3c <u64toa+0x3fc>
            buffer[buf_index] = '0' + @intCast(u8, a);
  21882e:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  218831:	04 30                	add    al,0x30
  218833:	88 01                	mov    BYTE PTR [rcx],al
  218835:	b8 01 00 00 00       	mov    eax,0x1
  21883a:	e9 06 03 00 00       	jmp    218b45 <u64toa+0x505>
  21883f:	31 c0                	xor    eax,eax
            if (v >= 100) {
  218841:	83 ff 64             	cmp    edi,0x64
  218844:	0f 82 21 02 00 00    	jb     218a6b <u64toa+0x42b>
                buffer[buf_index] = c_digits_lut[d1 + 1];
  21884a:	48 8b 3e             	mov    rdi,QWORD PTR [rsi]
  21884d:	83 ca 01             	or     edx,0x1
  218850:	48 8d 1d 39 ca fe ff 	lea    rbx,[rip+0xfffffffffffeca39]        # 205290 <c_digits_lut>
  218857:	8a 14 1a             	mov    dl,BYTE PTR [rdx+rbx*1]
  21885a:	88 14 07             	mov    BYTE PTR [rdi+rax*1],dl
                buf_index += 1;
  21885d:	48 83 c0 01          	add    rax,0x1
                buffer[buf_index] = c_digits_lut[d2];
  218861:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  218864:	48 8d 3d 25 ca fe ff 	lea    rdi,[rip+0xfffffffffffeca25]        # 205290 <c_digits_lut>
  21886b:	8a 1c 39             	mov    bl,BYTE PTR [rcx+rdi*1]
  21886e:	88 1c 02             	mov    BYTE PTR [rdx+rax*1],bl
                buf_index += 1;
  218871:	48 83 c0 01          	add    rax,0x1
            buffer[buf_index] = c_digits_lut[d2 + 1];
  218875:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  218878:	83 c9 01             	or     ecx,0x1
  21887b:	48 8d 35 0e ca fe ff 	lea    rsi,[rip+0xfffffffffffeca0e]        # 205290 <c_digits_lut>
  218882:	8a 0c 31             	mov    cl,BYTE PTR [rcx+rsi*1]
  218885:	88 0c 02             	mov    BYTE PTR [rdx+rax*1],cl
            buf_index += 1;
  218888:	48 83 c0 01          	add    rax,0x1
    return buf_index;
  21888c:	5b                   	pop    rbx
  21888d:	41 5e                	pop    r14
  21888f:	41 5f                	pop    r15
  218891:	c3                   	ret    
        if (value >= kTen14) {
  218892:	48 b8 00 40 7a 10 f3 	movabs rax,0x5af3107a4000
  218899:	5a 00 00 
  21889c:	48 39 c7             	cmp    rdi,rax
  21889f:	0f 82 d4 01 00 00    	jb     218a79 <u64toa+0x439>
  2188a5:	31 c0                	xor    eax,eax
            buffer[buf_index] = c_digits_lut[d1 + 1];
  2188a7:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  2188aa:	83 c9 01             	or     ecx,0x1
  2188ad:	48 8d 3d dc c9 fe ff 	lea    rdi,[rip+0xfffffffffffec9dc]        # 205290 <c_digits_lut>
  2188b4:	8a 0c 39             	mov    cl,BYTE PTR [rcx+rdi*1]
  2188b7:	88 0c 02             	mov    BYTE PTR [rdx+rax*1],cl
            buf_index += 1;
  2188ba:	48 83 c0 01          	add    rax,0x1
            buffer[buf_index] = c_digits_lut[d2];
  2188be:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  2188c1:	48 8d 15 c8 c9 fe ff 	lea    rdx,[rip+0xfffffffffffec9c8]        # 205290 <c_digits_lut>
  2188c8:	8a 14 13             	mov    dl,BYTE PTR [rbx+rdx*1]
  2188cb:	88 14 01             	mov    BYTE PTR [rcx+rax*1],dl
            buf_index += 1;
  2188ce:	48 83 c0 01          	add    rax,0x1
            buffer[buf_index] = c_digits_lut[d2 + 1];
  2188d2:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  2188d5:	83 cb 01             	or     ebx,0x1
  2188d8:	48 8d 15 b1 c9 fe ff 	lea    rdx,[rip+0xfffffffffffec9b1]        # 205290 <c_digits_lut>
  2188df:	8a 14 13             	mov    dl,BYTE PTR [rbx+rdx*1]
  2188e2:	88 14 01             	mov    BYTE PTR [rcx+rax*1],dl
            buf_index += 1;
  2188e5:	48 83 c0 01          	add    rax,0x1
            buffer[buf_index] = c_digits_lut[d3];
  2188e9:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  2188ec:	48 8d 15 9d c9 fe ff 	lea    rdx,[rip+0xfffffffffffec99d]        # 205290 <c_digits_lut>
  2188f3:	41 8a 14 13          	mov    dl,BYTE PTR [r11+rdx*1]
  2188f7:	88 14 01             	mov    BYTE PTR [rcx+rax*1],dl
            buf_index += 1;
  2188fa:	48 83 c0 01          	add    rax,0x1
            buffer[buf_index] = c_digits_lut[d3 + 1];
  2188fe:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  218901:	41 83 cb 01          	or     r11d,0x1
  218905:	48 8d 15 84 c9 fe ff 	lea    rdx,[rip+0xfffffffffffec984]        # 205290 <c_digits_lut>
  21890c:	41 8a 14 13          	mov    dl,BYTE PTR [r11+rdx*1]
  218910:	88 14 01             	mov    BYTE PTR [rcx+rax*1],dl
            buf_index += 1;
  218913:	48 83 c0 01          	add    rax,0x1
            buffer[buf_index] = c_digits_lut[d4];
  218917:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  21891a:	48 8d 15 6f c9 fe ff 	lea    rdx,[rip+0xfffffffffffec96f]        # 205290 <c_digits_lut>
  218921:	41 8a 14 17          	mov    dl,BYTE PTR [r15+rdx*1]
  218925:	88 14 01             	mov    BYTE PTR [rcx+rax*1],dl
            buf_index += 1;
  218928:	48 83 c0 01          	add    rax,0x1
            buffer[buf_index] = c_digits_lut[d4 + 1];
  21892c:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  21892f:	41 83 cf 01          	or     r15d,0x1
  218933:	48 8d 0d 56 c9 fe ff 	lea    rcx,[rip+0xfffffffffffec956]        # 205290 <c_digits_lut>
  21893a:	41 8a 1c 0f          	mov    bl,BYTE PTR [r15+rcx*1]
  21893e:	88 1c 02             	mov    BYTE PTR [rdx+rax*1],bl
        buffer[buf_index] = c_digits_lut[d5];
  218941:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  218944:	41 8a 1c 09          	mov    bl,BYTE PTR [r9+rcx*1]
  218948:	88 5c 02 01          	mov    BYTE PTR [rdx+rax*1+0x1],bl
        buffer[buf_index] = c_digits_lut[d5 + 1];
  21894c:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  21894f:	41 83 c9 01          	or     r9d,0x1
  218953:	41 8a 1c 09          	mov    bl,BYTE PTR [r9+rcx*1]
  218957:	88 5c 02 02          	mov    BYTE PTR [rdx+rax*1+0x2],bl
        buffer[buf_index] = c_digits_lut[d6];
  21895b:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  21895e:	41 8a 1c 0e          	mov    bl,BYTE PTR [r14+rcx*1]
  218962:	88 5c 02 03          	mov    BYTE PTR [rdx+rax*1+0x3],bl
        buffer[buf_index] = c_digits_lut[d6 + 1];
  218966:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  218969:	41 83 ce 01          	or     r14d,0x1
  21896d:	41 8a 1c 0e          	mov    bl,BYTE PTR [r14+rcx*1]
  218971:	88 5c 02 04          	mov    BYTE PTR [rdx+rax*1+0x4],bl
        buffer[buf_index] = c_digits_lut[d7];
  218975:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  218978:	41 8a 1c 0a          	mov    bl,BYTE PTR [r10+rcx*1]
  21897c:	88 5c 02 05          	mov    BYTE PTR [rdx+rax*1+0x5],bl
        buffer[buf_index] = c_digits_lut[d7 + 1];
  218980:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  218983:	41 83 ca 01          	or     r10d,0x1
  218987:	41 8a 1c 0a          	mov    bl,BYTE PTR [r10+rcx*1]
  21898b:	88 5c 02 06          	mov    BYTE PTR [rdx+rax*1+0x6],bl
        buffer[buf_index] = c_digits_lut[d8];
  21898f:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  218992:	41 8a 1c 08          	mov    bl,BYTE PTR [r8+rcx*1]
  218996:	88 5c 02 07          	mov    BYTE PTR [rdx+rax*1+0x7],bl
        buffer[buf_index] = c_digits_lut[d8 + 1];
  21899a:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  21899d:	41 83 c8 01          	or     r8d,0x1
  2189a1:	41 8a 0c 08          	mov    cl,BYTE PTR [r8+rcx*1]
  2189a5:	88 4c 02 08          	mov    BYTE PTR [rdx+rax*1+0x8],cl
        buf_index += 1;
  2189a9:	48 83 c0 09          	add    rax,0x9
    return buf_index;
  2189ad:	5b                   	pop    rbx
  2189ae:	41 5e                	pop    r14
  2189b0:	41 5f                	pop    r15
  2189b2:	c3                   	ret    
  2189b3:	31 c0                	xor    eax,eax
            if (value >= 1000000) {
  2189b5:	48 81 ff 40 42 0f 00 	cmp    rdi,0xf4240
  2189bc:	0f 82 cd 00 00 00    	jb     218a8f <u64toa+0x44f>
                buffer[buf_index] = c_digits_lut[d1 + 1];
  2189c2:	4c 8b 0e             	mov    r9,QWORD PTR [rsi]
  2189c5:	83 cb 01             	or     ebx,0x1
  2189c8:	48 8d 3d c1 c8 fe ff 	lea    rdi,[rip+0xfffffffffffec8c1]        # 205290 <c_digits_lut>
  2189cf:	8a 1c 3b             	mov    bl,BYTE PTR [rbx+rdi*1]
  2189d2:	41 88 1c 01          	mov    BYTE PTR [r9+rax*1],bl
                buf_index += 1;
  2189d6:	48 83 c0 01          	add    rax,0x1
                buffer[buf_index] = c_digits_lut[d2];
  2189da:	48 8b 3e             	mov    rdi,QWORD PTR [rsi]
  2189dd:	48 8d 1d ac c8 fe ff 	lea    rbx,[rip+0xfffffffffffec8ac]        # 205290 <c_digits_lut>
  2189e4:	8a 1c 1a             	mov    bl,BYTE PTR [rdx+rbx*1]
  2189e7:	88 1c 07             	mov    BYTE PTR [rdi+rax*1],bl
                buf_index += 1;
  2189ea:	48 83 c0 01          	add    rax,0x1
            buffer[buf_index] = c_digits_lut[d2 + 1];
  2189ee:	48 8b 1e             	mov    rbx,QWORD PTR [rsi]
  2189f1:	83 ca 01             	or     edx,0x1
  2189f4:	48 8d 3d 95 c8 fe ff 	lea    rdi,[rip+0xfffffffffffec895]        # 205290 <c_digits_lut>
  2189fb:	8a 14 3a             	mov    dl,BYTE PTR [rdx+rdi*1]
  2189fe:	88 14 03             	mov    BYTE PTR [rbx+rax*1],dl
            buffer[buf_index] = c_digits_lut[d3];
  218a01:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  218a04:	41 8a 1c 38          	mov    bl,BYTE PTR [r8+rdi*1]
  218a08:	88 5c 02 01          	mov    BYTE PTR [rdx+rax*1+0x1],bl
            buffer[buf_index] = c_digits_lut[d3 + 1];
  218a0c:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  218a0f:	41 83 c8 01          	or     r8d,0x1
  218a13:	41 8a 1c 38          	mov    bl,BYTE PTR [r8+rdi*1]
  218a17:	88 5c 02 02          	mov    BYTE PTR [rdx+rax*1+0x2],bl
            buffer[buf_index] = c_digits_lut[d4];
  218a1b:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  218a1e:	8a 1c 39             	mov    bl,BYTE PTR [rcx+rdi*1]
  218a21:	88 5c 02 03          	mov    BYTE PTR [rdx+rax*1+0x3],bl
            buffer[buf_index] = c_digits_lut[d4 + 1];
  218a25:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  218a28:	83 c9 01             	or     ecx,0x1
  218a2b:	8a 0c 39             	mov    cl,BYTE PTR [rcx+rdi*1]
  218a2e:	88 4c 02 04          	mov    BYTE PTR [rdx+rax*1+0x4],cl
            buf_index += 1;
  218a32:	48 83 c0 05          	add    rax,0x5
    return buf_index;
  218a36:	5b                   	pop    rbx
  218a37:	41 5e                	pop    r14
  218a39:	41 5f                	pop    r15
  218a3b:	c3                   	ret    
        } else if (a < 100) {
  218a3c:	83 f8 63             	cmp    eax,0x63
  218a3f:	77 60                	ja     218aa1 <u64toa+0x461>
            buffer[buf_index] = c_digits_lut[i];
  218a41:	89 c0                	mov    eax,eax
  218a43:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  218a46:	48 8d 3d 43 c8 fe ff 	lea    rdi,[rip+0xfffffffffffec843]        # 205290 <c_digits_lut>
  218a4d:	8a 1c 47             	mov    bl,BYTE PTR [rdi+rax*2]
            const i: u32 = a << 1;
  218a50:	48 01 c0             	add    rax,rax
            buffer[buf_index] = c_digits_lut[i];
  218a53:	88 19                	mov    BYTE PTR [rcx],bl
            buffer[buf_index] = c_digits_lut[i + 1];
  218a55:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  218a58:	83 c8 01             	or     eax,0x1
  218a5b:	8a 04 38             	mov    al,BYTE PTR [rax+rdi*1]
  218a5e:	88 41 01             	mov    BYTE PTR [rcx+0x1],al
  218a61:	b8 02 00 00 00       	mov    eax,0x2
  218a66:	e9 da 00 00 00       	jmp    218b45 <u64toa+0x505>
            if (v >= 10) {
  218a6b:	83 ff 0a             	cmp    edi,0xa
  218a6e:	0f 83 ed fd ff ff    	jae    218861 <u64toa+0x221>
  218a74:	e9 fc fd ff ff       	jmp    218875 <u64toa+0x235>
        if (value >= kTen13) {
  218a79:	48 89 f8             	mov    rax,rdi
  218a7c:	48 c1 e8 0d          	shr    rax,0xd
  218a80:	48 3d 95 73 c2 48    	cmp    rax,0x48c27395
  218a86:	72 60                	jb     218ae8 <u64toa+0x4a8>
  218a88:	31 c0                	xor    eax,eax
  218a8a:	e9 2f fe ff ff       	jmp    2188be <u64toa+0x27e>
            if (value >= 100000) {
  218a8f:	48 81 ff a0 86 01 00 	cmp    rdi,0x186a0
  218a96:	0f 83 3e ff ff ff    	jae    2189da <u64toa+0x39a>
  218a9c:	e9 4d ff ff ff       	jmp    2189ee <u64toa+0x3ae>
            const i: u32 = (a / 100) << 1;
  218aa1:	89 c1                	mov    ecx,eax
  218aa3:	48 69 c9 1f 85 eb 51 	imul   rcx,rcx,0x51eb851f
  218aaa:	48 c1 e9 25          	shr    rcx,0x25
            const j: u32 = (a % 100) << 1;
  218aae:	6b f9 64             	imul   edi,ecx,0x64
        } else if (a < 1000) {
  218ab1:	3d e7 03 00 00       	cmp    eax,0x3e7
  218ab6:	77 4a                	ja     218b02 <u64toa+0x4c2>
            buffer[buf_index] = '0' + @intCast(u8, a / 100);
  218ab8:	48 8b 1e             	mov    rbx,QWORD PTR [rsi]
  218abb:	80 c1 30             	add    cl,0x30
  218abe:	88 0b                	mov    BYTE PTR [rbx],cl
            const i: u32 = (a % 100) << 1;
  218ac0:	29 f8                	sub    eax,edi
            buffer[buf_index] = c_digits_lut[i];
  218ac2:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  218ac5:	48 8d 3d c4 c7 fe ff 	lea    rdi,[rip+0xfffffffffffec7c4]        # 205290 <c_digits_lut>
  218acc:	8a 1c 47             	mov    bl,BYTE PTR [rdi+rax*2]
            const i: u32 = (a % 100) << 1;
  218acf:	48 01 c0             	add    rax,rax
            buffer[buf_index] = c_digits_lut[i];
  218ad2:	88 59 01             	mov    BYTE PTR [rcx+0x1],bl
            buffer[buf_index] = c_digits_lut[i + 1];
  218ad5:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  218ad8:	83 c8 01             	or     eax,0x1
  218adb:	8a 04 38             	mov    al,BYTE PTR [rax+rdi*1]
  218ade:	88 41 02             	mov    BYTE PTR [rcx+0x2],al
  218ae1:	b8 03 00 00 00       	mov    eax,0x3
  218ae6:	eb 5d                	jmp    218b45 <u64toa+0x505>
        if (value >= kTen12) {
  218ae8:	48 89 f8             	mov    rax,rdi
  218aeb:	48 c1 e8 0c          	shr    rax,0xc
  218aef:	48 3d 51 4a 8d 0e    	cmp    rax,0xe8d4a51
  218af5:	0f 82 e9 01 00 00    	jb     218ce4 <u64toa+0x6a4>
  218afb:	31 c0                	xor    eax,eax
  218afd:	e9 d0 fd ff ff       	jmp    2188d2 <u64toa+0x292>
            const j: u32 = (a % 100) << 1;
  218b02:	29 f8                	sub    eax,edi
  218b04:	48 8d 3c 00          	lea    rdi,[rax+rax*1]
            buffer[buf_index] = c_digits_lut[i];
  218b08:	4c 8b 0e             	mov    r9,QWORD PTR [rsi]
  218b0b:	4c 8d 05 7e c7 fe ff 	lea    r8,[rip+0xfffffffffffec77e]        # 205290 <c_digits_lut>
  218b12:	41 8a 1c 48          	mov    bl,BYTE PTR [r8+rcx*2]
  218b16:	41 88 19             	mov    BYTE PTR [r9],bl
            const i: u32 = (a / 100) << 1;
  218b19:	48 01 c9             	add    rcx,rcx
            buffer[buf_index] = c_digits_lut[i + 1];
  218b1c:	48 8b 1e             	mov    rbx,QWORD PTR [rsi]
  218b1f:	83 c9 01             	or     ecx,0x1
  218b22:	42 8a 0c 01          	mov    cl,BYTE PTR [rcx+r8*1]
  218b26:	88 4b 01             	mov    BYTE PTR [rbx+0x1],cl
            buffer[buf_index] = c_digits_lut[j];
  218b29:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  218b2c:	41 8a 04 40          	mov    al,BYTE PTR [r8+rax*2]
  218b30:	88 41 02             	mov    BYTE PTR [rcx+0x2],al
            buffer[buf_index] = c_digits_lut[j + 1];
  218b33:	48 8b 06             	mov    rax,QWORD PTR [rsi]
  218b36:	83 cf 01             	or     edi,0x1
  218b39:	42 8a 0c 07          	mov    cl,BYTE PTR [rdi+r8*1]
  218b3d:	88 48 03             	mov    BYTE PTR [rax+0x3],cl
  218b40:	b8 04 00 00 00       	mov    eax,0x4
        const v0 = @intCast(u32, value / kTen8);
  218b45:	48 b9 fd ce 61 84 11 	movabs rcx,0xabcc77118461cefd
  218b4c:	77 cc ab 
  218b4f:	c4 62 f3 f6 f1       	mulx   r14,rcx,rcx
  218b54:	49 c1 ee 1a          	shr    r14,0x1a
        const v1 = @intCast(u32, value % kTen8);
  218b58:	4d 69 c6 00 e1 f5 05 	imul   r8,r14,0x5f5e100
        const b0: u32 = v0 / 10000;
  218b5f:	44 89 f3             	mov    ebx,r14d
  218b62:	41 ba 59 17 b7 d1    	mov    r10d,0xd1b71759
        const d1: u32 = (b0 / 100) << 1;
  218b68:	4c 69 cb 83 de 1b 43 	imul   r9,rbx,0x431bde83
        const b0: u32 = v0 / 10000;
  218b6f:	49 0f af da          	imul   rbx,r10
  218b73:	48 c1 eb 2d          	shr    rbx,0x2d
        const d1: u32 = (b0 / 100) << 1;
  218b77:	49 c1 e9 32          	shr    r9,0x32
        buffer[buf_index] = c_digits_lut[d1];
  218b7b:	4c 8b 1e             	mov    r11,QWORD PTR [rsi]
  218b7e:	48 8d 3d 0b c7 fe ff 	lea    rdi,[rip+0xfffffffffffec70b]        # 205290 <c_digits_lut>
  218b85:	42 8a 0c 4f          	mov    cl,BYTE PTR [rdi+r9*2]
  218b89:	41 88 0c 03          	mov    BYTE PTR [r11+rax*1],cl
        const c0: u32 = v0 % 10000;
  218b8d:	44 69 db 10 27 00 00 	imul   r11d,ebx,0x2710
        const d2: u32 = (b0 % 100) << 1;
  218b94:	48 69 cb 1f 85 eb 51 	imul   rcx,rbx,0x51eb851f
  218b9b:	48 c1 e9 25          	shr    rcx,0x25
  218b9f:	6b c9 64             	imul   ecx,ecx,0x64
        const c0: u32 = v0 % 10000;
  218ba2:	45 29 de             	sub    r14d,r11d
        const d2: u32 = (b0 % 100) << 1;
  218ba5:	29 cb                	sub    ebx,ecx
        const d1: u32 = (b0 / 100) << 1;
  218ba7:	4b 8d 0c 09          	lea    rcx,[r9+r9*1]
        buffer[buf_index] = c_digits_lut[d1 + 1];
  218bab:	83 c9 01             	or     ecx,0x1
  218bae:	44 8a 0c 39          	mov    r9b,BYTE PTR [rcx+rdi*1]
  218bb2:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  218bb5:	44 88 4c 01 01       	mov    BYTE PTR [rcx+rax*1+0x1],r9b
        buffer[buf_index] = c_digits_lut[d2];
  218bba:	4c 8b 0e             	mov    r9,QWORD PTR [rsi]
  218bbd:	8a 0c 5f             	mov    cl,BYTE PTR [rdi+rbx*2]
  218bc0:	41 88 4c 01 02       	mov    BYTE PTR [r9+rax*1+0x2],cl
        const d2: u32 = (b0 % 100) << 1;
  218bc5:	48 8d 0c 1b          	lea    rcx,[rbx+rbx*1]
        const d3: u32 = (c0 / 100) << 1;
  218bc9:	49 69 de 1f 85 eb 51 	imul   rbx,r14,0x51eb851f
  218bd0:	48 c1 eb 25          	shr    rbx,0x25
        buffer[buf_index] = c_digits_lut[d2 + 1];
  218bd4:	83 c9 01             	or     ecx,0x1
  218bd7:	44 8a 0c 39          	mov    r9b,BYTE PTR [rcx+rdi*1]
  218bdb:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  218bde:	44 88 4c 01 03       	mov    BYTE PTR [rcx+rax*1+0x3],r9b
        buffer[buf_index] = c_digits_lut[d3];
  218be3:	4c 8b 0e             	mov    r9,QWORD PTR [rsi]
  218be6:	8a 0c 5f             	mov    cl,BYTE PTR [rdi+rbx*2]
  218be9:	41 88 4c 01 04       	mov    BYTE PTR [r9+rax*1+0x4],cl
        const d4: u32 = (c0 % 100) << 1;
  218bee:	6b cb 64             	imul   ecx,ebx,0x64
        const v1 = @intCast(u32, value % kTen8);
  218bf1:	4c 29 c2             	sub    rdx,r8
        const d3: u32 = (c0 / 100) << 1;
  218bf4:	48 8d 1c 1b          	lea    rbx,[rbx+rbx*1]
        const d4: u32 = (c0 % 100) << 1;
  218bf8:	41 29 ce             	sub    r14d,ecx
        buffer[buf_index] = c_digits_lut[d3 + 1];
  218bfb:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  218bfe:	83 cb 01             	or     ebx,0x1
  218c01:	8a 1c 3b             	mov    bl,BYTE PTR [rbx+rdi*1]
  218c04:	88 5c 01 05          	mov    BYTE PTR [rcx+rax*1+0x5],bl
        const d4: u32 = (c0 % 100) << 1;
  218c08:	4b 8d 0c 36          	lea    rcx,[r14+r14*1]
        const b1: u32 = v1 / 10000;
  218c0c:	4c 0f af d2          	imul   r10,rdx
  218c10:	49 c1 ea 2d          	shr    r10,0x2d
        buffer[buf_index] = c_digits_lut[d4];
  218c14:	4c 8b 06             	mov    r8,QWORD PTR [rsi]
  218c17:	42 8a 1c 77          	mov    bl,BYTE PTR [rdi+r14*2]
  218c1b:	41 88 5c 00 06       	mov    BYTE PTR [r8+rax*1+0x6],bl
        const d5: u32 = (b1 / 100) << 1;
  218c20:	48 69 da 83 de 1b 43 	imul   rbx,rdx,0x431bde83
  218c27:	48 c1 eb 31          	shr    rbx,0x31
  218c2b:	81 e3 fe 01 00 00    	and    ebx,0x1fe
        buffer[buf_index] = c_digits_lut[d4 + 1];
  218c31:	4c 8b 06             	mov    r8,QWORD PTR [rsi]
  218c34:	83 c9 01             	or     ecx,0x1
  218c37:	8a 0c 39             	mov    cl,BYTE PTR [rcx+rdi*1]
  218c3a:	41 88 4c 00 07       	mov    BYTE PTR [r8+rax*1+0x7],cl
        buf_index += 1;
  218c3f:	48 83 c8 08          	or     rax,0x8
        buffer[buf_index] = c_digits_lut[d5];
  218c43:	4c 8b 06             	mov    r8,QWORD PTR [rsi]
  218c46:	8a 0c 3b             	mov    cl,BYTE PTR [rbx+rdi*1]
  218c49:	41 88 0c 00          	mov    BYTE PTR [r8+rax*1],cl
        const c1: u32 = v1 % 10000;
  218c4d:	45 69 c2 10 27 00 00 	imul   r8d,r10d,0x2710
        const d6: u32 = (b1 % 100) << 1;
  218c54:	49 69 ca 1f 85 eb 51 	imul   rcx,r10,0x51eb851f
  218c5b:	48 c1 e9 25          	shr    rcx,0x25
  218c5f:	6b c9 64             	imul   ecx,ecx,0x64
        const c1: u32 = v1 % 10000;
  218c62:	44 29 c2             	sub    edx,r8d
        const d6: u32 = (b1 % 100) << 1;
  218c65:	41 29 ca             	sub    r10d,ecx
        buffer[buf_index] = c_digits_lut[d5 + 1];
  218c68:	8d 4b 01             	lea    ecx,[rbx+0x1]
  218c6b:	8a 0c 39             	mov    cl,BYTE PTR [rcx+rdi*1]
  218c6e:	48 8b 1e             	mov    rbx,QWORD PTR [rsi]
  218c71:	88 4c 03 01          	mov    BYTE PTR [rbx+rax*1+0x1],cl
        buffer[buf_index] = c_digits_lut[d6];
  218c75:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  218c78:	42 8a 1c 57          	mov    bl,BYTE PTR [rdi+r10*2]
  218c7c:	88 5c 01 02          	mov    BYTE PTR [rcx+rax*1+0x2],bl
        const d6: u32 = (b1 % 100) << 1;
  218c80:	4b 8d 0c 12          	lea    rcx,[r10+r10*1]
        const d7: u32 = (c1 / 100) << 1;
  218c84:	48 69 da 1f 85 eb 51 	imul   rbx,rdx,0x51eb851f
  218c8b:	48 c1 eb 25          	shr    rbx,0x25
        buffer[buf_index] = c_digits_lut[d6 + 1];
  218c8f:	83 c9 01             	or     ecx,0x1
  218c92:	44 8a 04 39          	mov    r8b,BYTE PTR [rcx+rdi*1]
  218c96:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  218c99:	44 88 44 01 03       	mov    BYTE PTR [rcx+rax*1+0x3],r8b
        buffer[buf_index] = c_digits_lut[d7];
  218c9e:	4c 8b 06             	mov    r8,QWORD PTR [rsi]
  218ca1:	8a 0c 5f             	mov    cl,BYTE PTR [rdi+rbx*2]
  218ca4:	41 88 4c 00 04       	mov    BYTE PTR [r8+rax*1+0x4],cl
        const d8: u32 = (c1 % 100) << 1;
  218ca9:	6b cb 64             	imul   ecx,ebx,0x64
  218cac:	29 ca                	sub    edx,ecx
        const d7: u32 = (c1 / 100) << 1;
  218cae:	48 8d 0c 1b          	lea    rcx,[rbx+rbx*1]
        buffer[buf_index] = c_digits_lut[d7 + 1];
  218cb2:	83 c9 01             	or     ecx,0x1
  218cb5:	8a 0c 39             	mov    cl,BYTE PTR [rcx+rdi*1]
  218cb8:	48 8b 1e             	mov    rbx,QWORD PTR [rsi]
  218cbb:	88 4c 03 05          	mov    BYTE PTR [rbx+rax*1+0x5],cl
        buffer[buf_index] = c_digits_lut[d8];
  218cbf:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  218cc2:	8a 1c 57             	mov    bl,BYTE PTR [rdi+rdx*2]
  218cc5:	88 5c 01 06          	mov    BYTE PTR [rcx+rax*1+0x6],bl
        const d8: u32 = (c1 % 100) << 1;
  218cc9:	48 8d 0c 12          	lea    rcx,[rdx+rdx*1]
        buffer[buf_index] = c_digits_lut[d8 + 1];
  218ccd:	83 c9 01             	or     ecx,0x1
  218cd0:	8a 0c 39             	mov    cl,BYTE PTR [rcx+rdi*1]
  218cd3:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  218cd6:	88 4c 02 07          	mov    BYTE PTR [rdx+rax*1+0x7],cl
        buf_index += 1;
  218cda:	48 83 c0 08          	add    rax,0x8
    return buf_index;
  218cde:	5b                   	pop    rbx
  218cdf:	41 5e                	pop    r14
  218ce1:	41 5f                	pop    r15
  218ce3:	c3                   	ret    
        if (value >= kTen11) {
  218ce4:	48 89 f8             	mov    rax,rdi
  218ce7:	48 c1 e8 0b          	shr    rax,0xb
  218ceb:	48 3d dd 0e e9 02    	cmp    rax,0x2e90edd
  218cf1:	72 07                	jb     218cfa <u64toa+0x6ba>
  218cf3:	31 c0                	xor    eax,eax
  218cf5:	e9 ef fb ff ff       	jmp    2188e9 <u64toa+0x2a9>
        if (value >= kTen10) {
  218cfa:	48 89 f8             	mov    rax,rdi
  218cfd:	48 c1 e8 0a          	shr    rax,0xa
  218d01:	48 3d f9 02 95 00    	cmp    rax,0x9502f9
  218d07:	72 07                	jb     218d10 <u64toa+0x6d0>
  218d09:	31 c0                	xor    eax,eax
  218d0b:	e9 ee fb ff ff       	jmp    2188fe <u64toa+0x2be>
  218d10:	31 c0                	xor    eax,eax
        if (value >= kTen9) {
  218d12:	48 81 ff 00 ca 9a 3b 	cmp    rdi,0x3b9aca00
  218d19:	0f 83 f8 fb ff ff    	jae    218917 <u64toa+0x2d7>
  218d1f:	e9 08 fc ff ff       	jmp    21892c <u64toa+0x2ec>
  218d24:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  218d2b:	00 00 00 00 00 

0000000000218d30 <frexp64>:
    y |= 0x3F000000;
    result.significand = @bitCast(f32, y);
    return result;
}

fn frexp64(x: f64) frexp64_result {
  218d30:	53                   	push   rbx
  218d31:	48 83 ec 10          	sub    rsp,0x10
  218d35:	48 89 fb             	mov    rbx,rdi
    var result: frexp64_result = undefined;

    var y = @bitCast(u64, x);
  218d38:	c4 e1 f9 7e c1       	vmovq  rcx,xmm0
    const e = @intCast(i32, y >> 52) & 0x7FF;
  218d3d:	48 89 c8             	mov    rax,rcx
  218d40:	48 c1 e8 34          	shr    rax,0x34

    if (e == 0) {
  218d44:	89 c2                	mov    edx,eax
  218d46:	81 e2 ff 07 00 00    	and    edx,0x7ff
  218d4c:	81 fa ff 07 00 00    	cmp    edx,0x7ff
  218d52:	74 31                	je     218d85 <frexp64+0x55>
  218d54:	66 85 d2             	test   dx,dx
  218d57:	75 3d                	jne    218d96 <frexp64+0x66>
        if (x != 0) {
  218d59:	c5 f0 57 c9          	vxorps xmm1,xmm1,xmm1
  218d5d:	c5 f9 2e c1          	vucomisd xmm0,xmm1
  218d61:	74 63                	je     218dc6 <frexp64+0x96>
            // subnormal
            result = frexp64(x * 0x1.0p64);
  218d63:	c5 fb 59 05 3d 75 fe 	vmulsd xmm0,xmm0,QWORD PTR [rip+0xfffffffffffe753d]        # 2002a8 <app_mask+0x28>
  218d6a:	ff 
  218d6b:	48 89 e7             	mov    rdi,rsp
  218d6e:	e8 bd ff ff ff       	call   218d30 <frexp64>
  218d73:	c5 fb 10 04 24       	vmovsd xmm0,QWORD PTR [rsp]
  218d78:	8b 44 24 08          	mov    eax,DWORD PTR [rsp+0x8]
  218d7c:	8b 4c 24 0c          	mov    ecx,DWORD PTR [rsp+0xc]
            result.exponent -= 64;
  218d80:	83 c0 c0             	add    eax,0xffffffc0
  218d83:	eb 43                	jmp    218dc8 <frexp64+0x98>
        // frexp(+-inf) = (+-inf, 0)
        if (math.isInf(x)) {
            result.exponent = 0;
        }

        return result;
  218d85:	c5 fb 11 03          	vmovsd QWORD PTR [rbx],xmm0
  218d89:	c7 43 08 00 00 00 00 	mov    DWORD PTR [rbx+0x8],0x0
  218d90:	48 83 c4 10          	add    rsp,0x10
  218d94:	5b                   	pop    rbx
  218d95:	c3                   	ret    
    const e = @intCast(i32, y >> 52) & 0x7FF;
  218d96:	25 ff 07 00 00       	and    eax,0x7ff
    }

    result.exponent = e - 0x3FE;
  218d9b:	05 02 fc ff ff       	add    eax,0xfffffc02
    y &= 0x800FFFFFFFFFFFFF;
  218da0:	48 ba ff ff ff ff ff 	movabs rdx,0x800fffffffffffff
  218da7:	ff 0f 80 
  218daa:	48 21 d1             	and    rcx,rdx
    y |= 0x3FE0000000000000;
  218dad:	48 ba 00 00 00 00 00 	movabs rdx,0x3fe0000000000000
  218db4:	00 e0 3f 
  218db7:	48 09 ca             	or     rdx,rcx
    result.significand = @bitCast(f64, y);
    return result;
  218dba:	48 89 13             	mov    QWORD PTR [rbx],rdx
  218dbd:	89 43 08             	mov    DWORD PTR [rbx+0x8],eax
  218dc0:	48 83 c4 10          	add    rsp,0x10
  218dc4:	5b                   	pop    rbx
  218dc5:	c3                   	ret    
  218dc6:	31 c0                	xor    eax,eax
        return result;
  218dc8:	c5 fb 11 03          	vmovsd QWORD PTR [rbx],xmm0
  218dcc:	89 43 08             	mov    DWORD PTR [rbx+0x8],eax
  218dcf:	89 4b 0c             	mov    DWORD PTR [rbx+0xc],ecx
  218dd2:	48 83 c4 10          	add    rsp,0x10
  218dd6:	5b                   	pop    rbx
  218dd7:	c3                   	ret    
  218dd8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  218ddf:	00 

0000000000218de0 <_start>:
}

nakedcc fn _start() noreturn {
    switch (builtin.arch) {
        builtin.Arch.x86_64 => {
            argc_ptr = asm ("lea (%%rsp), %[argc]"
  218de0:	48 8d 04 24          	lea    rax,[rsp]
  218de4:	48 89 05 a5 42 00 00 	mov    QWORD PTR [rip+0x42a5],rax        # 21d090 <argc_ptr>
        },
        else => @compileError("unsupported arch"),
    }
    // If LLVM inlines stack variables into _start, they will overwrite
    // the command line argument data.
    @noInlineCall(posixCallMainAndExit);
  218deb:	e8 00 00 00 00       	call   218df0 <posixCallMainAndExit>

0000000000218df0 <posixCallMainAndExit>:
    std.os.windows.ExitProcess(callMain());
}

// TODO https://github.com/ziglang/zig/issues/265
fn posixCallMainAndExit() noreturn {
    const argc = argc_ptr[0];
  218df0:	41 56                	push   r14
  218df2:	53                   	push   rbx
  218df3:	48 83 ec 18          	sub    rsp,0x18
  218df7:	48 8b 15 92 42 00 00 	mov    rdx,QWORD PTR [rip+0x4292]        # 21d090 <argc_ptr>
  218dfe:	48 8b 1a             	mov    rbx,QWORD PTR [rdx]
    const argv = @ptrCast([*][*]u8, argc_ptr + 1);

    const envp_optional = @ptrCast([*]?[*]u8, argv + argc + 1);
  218e01:	48 8d 0c da          	lea    rcx,[rdx+rbx*8]
  218e05:	48 83 c1 10          	add    rcx,0x10
    var envp_count: usize = 0;
    while (envp_optional[envp_count]) |_| : (envp_count += 1) {}
  218e09:	48 8d 04 da          	lea    rax,[rdx+rbx*8]
  218e0d:	48 83 c0 20          	add    rax,0x20
    const argv = @ptrCast([*][*]u8, argc_ptr + 1);
  218e11:	4c 8d 72 08          	lea    r14,[rdx+0x8]
  218e15:	48 c7 c2 ff ff ff ff 	mov    rdx,0xffffffffffffffff
  218e1c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
    while (envp_optional[envp_count]) |_| : (envp_count += 1) {}
  218e20:	48 83 c2 01          	add    rdx,0x1
  218e24:	48 83 78 f0 00       	cmp    QWORD PTR [rax-0x10],0x0
  218e29:	48 8d 40 08          	lea    rax,[rax+0x8]
  218e2d:	75 f1                	jne    218e20 <posixCallMainAndExit+0x30>
    const envp = @ptrCast([*][*]u8, envp_optional)[0..envp_count];
  218e2f:	48 89 4c 24 08       	mov    QWORD PTR [rsp+0x8],rcx
  218e34:	48 89 54 24 10       	mov    QWORD PTR [rsp+0x10],rdx
    if (builtin.os == builtin.Os.linux) {
        const auxv = @ptrCast([*]usize, envp.ptr + envp_count + 1);
        var i: usize = 0;
        while (auxv[i] != 0) : (i += 2) {
  218e39:	48 8b 48 f0          	mov    rcx,QWORD PTR [rax-0x10]
  218e3d:	48 85 c9             	test   rcx,rcx
  218e40:	74 28                	je     218e6a <posixCallMainAndExit+0x7a>
  218e42:	48 8d 15 f7 81 00 00 	lea    rdx,[rip+0x81f7]        # 221040 <linux_aux_raw>
  218e49:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
            if (auxv[i] < std.os.linux_aux_raw.len) std.os.linux_aux_raw[auxv[i]] = auxv[i + 1];
  218e50:	48 83 f9 25          	cmp    rcx,0x25
  218e54:	77 08                	ja     218e5e <posixCallMainAndExit+0x6e>
  218e56:	48 8b 70 f8          	mov    rsi,QWORD PTR [rax-0x8]
  218e5a:	48 89 34 ca          	mov    QWORD PTR [rdx+rcx*8],rsi
        while (auxv[i] != 0) : (i += 2) {
  218e5e:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  218e61:	48 83 c0 10          	add    rax,0x10
  218e65:	48 85 c9             	test   rcx,rcx
  218e68:	75 e6                	jne    218e50 <posixCallMainAndExit+0x60>
        }
        std.debug.assert(std.os.linux_aux_raw[std.elf.AT_PAGESZ] == std.os.page_size);
  218e6a:	31 ff                	xor    edi,edi
  218e6c:	48 81 3d f9 81 00 00 	cmp    QWORD PTR [rip+0x81f9],0x1000        # 221070 <linux_aux_raw+0x30>
  218e73:	00 10 00 00 
  218e77:	40 0f 94 c7          	sete   dil
  218e7b:	e8 80 f1 fe ff       	call   208000 <assert>
  218e80:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
    }

    std.os.posix.exit(callMainWithArgs(argc, argv, envp));
  218e85:	48 89 df             	mov    rdi,rbx
  218e88:	4c 89 f6             	mov    rsi,r14
  218e8b:	e8 10 00 00 00       	call   218ea0 <callMainWithArgs>
    _ = syscall1(SYS_exit, @bitCast(usize, isize(status)));
  218e90:	0f b6 f8             	movzx  edi,al
    return asm volatile ("syscall"
  218e93:	b8 3c 00 00 00       	mov    eax,0x3c
  218e98:	0f 05                	syscall 
  218e9a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000218ea0 <callMainWithArgs>:
}

fn callMainWithArgs(argc: usize, argv: [*][*]u8, envp: [][*]u8) u8 {
    std.os.ArgIteratorPosix.raw = argv[0..argc];
  218ea0:	41 57                	push   r15
  218ea2:	41 56                	push   r14
  218ea4:	53                   	push   rbx
  218ea5:	48 83 ec 50          	sub    rsp,0x50
  218ea9:	48 89 35 e8 41 00 00 	mov    QWORD PTR [rip+0x41e8],rsi        # 21d098 <raw>
  218eb0:	48 89 3d e9 41 00 00 	mov    QWORD PTR [rip+0x41e9],rdi        # 21d0a0 <raw+0x8>
    std.os.posix_environ_raw = envp;
  218eb7:	c5 f8 10 02          	vmovups xmm0,XMMWORD PTR [rdx]
  218ebb:	c5 f8 11 05 bd 41 00 	vmovups XMMWORD PTR [rip+0x41bd],xmm0        # 21d080 <posix_environ_raw>
  218ec2:	00 
  218ec3:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  218eca:	84 00 00 00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  218ed0:	b0 01                	mov    al,0x1
  218ed2:	86 05 38 81 00 00    	xchg   BYTE PTR [rip+0x8138],al        # 221010 <stderr_mutex>
  218ed8:	84 c0                	test   al,al
  218eda:	75 f4                	jne    218ed0 <callMainWithArgs+0x30>
    if (stderr_stream) |st| {
  218edc:	48 8b 1d 25 81 00 00 	mov    rbx,QWORD PTR [rip+0x8125]        # 221008 <stderr_stream>
  218ee3:	48 85 db             	test   rbx,rbx
  218ee6:	74 09                	je     218ef1 <callMainWithArgs+0x51>
            return std.fmt.format(self, Error, self.writeFn, format, args);
  218ee8:	4c 8b 3d 21 41 00 00 	mov    r15,QWORD PTR [rip+0x4121]        # 21d010 <stderr_file_out_stream+0x8>
  218eef:	eb 34                	jmp    218f25 <callMainWithArgs+0x85>
        stderr_file = try io.getStdErr();
  218ef1:	48 8d 05 08 41 00 00 	lea    rax,[rip+0x4108]        # 21d000 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  218ef8:	48 89 05 09 41 00 00 	mov    QWORD PTR [rip+0x4109],rax        # 21d008 <stderr_file_out_stream>
  218eff:	4c 8d 3d fa 18 ff ff 	lea    r15,[rip+0xffffffffffff18fa]        # 20a800 <FileOutStream_writeFn>
  218f06:	4c 89 3d 03 41 00 00 	mov    QWORD PTR [rip+0x4103],r15        # 21d010 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  218f0d:	c7 05 e9 40 00 00 02 	mov    DWORD PTR [rip+0x40e9],0x2        # 21d000 <stderr_file>
  218f14:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  218f17:	48 8d 1d f2 40 00 00 	lea    rbx,[rip+0x40f2]        # 21d010 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  218f1e:	48 89 1d e3 80 00 00 	mov    QWORD PTR [rip+0x80e3],rbx        # 221008 <stderr_stream>
  218f25:	4c 8d 74 24 4f       	lea    r14,[rsp+0x4f]
                        try output(context, fmt[start_index..i]);
  218f2a:	48 8d 35 ef 7e 00 00 	lea    rsi,[rip+0x7eef]        # 220e20 <__unnamed_93>
  218f31:	48 89 df             	mov    rdi,rbx
  218f34:	41 ff d7             	call   r15
  218f37:	66 85 c0             	test   ax,ax
  218f3a:	0f 85 d1 00 00 00    	jne    219011 <callMainWithArgs+0x171>
    var buf: [max_int_digits - 1]u8 = undefined;
  218f40:	c5 fc 10 05 e7 da fe 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffedae7]        # 206a2f <__unnamed_3+0x1f>
  218f47:	ff 
  218f48:	c5 fc 11 44 24 2f    	vmovups YMMWORD PTR [rsp+0x2f],ymm0
  218f4e:	c5 fc 10 05 ba da fe 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffedaba]        # 206a10 <__unnamed_3>
  218f55:	ff 
  218f56:	c5 fc 11 44 24 10    	vmovups YMMWORD PTR [rsp+0x10],ymm0
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  218f5c:	c6 44 24 4f 31       	mov    BYTE PTR [rsp+0x4f],0x31
        const padded_buf = buf[index - padding ..];
  218f61:	4c 89 34 24          	mov    QWORD PTR [rsp],r14
  218f65:	48 c7 44 24 08 01 00 	mov    QWORD PTR [rsp+0x8],0x1
  218f6c:	00 00 
  218f6e:	48 89 e6             	mov    rsi,rsp
        return output(context, padded_buf);
  218f71:	48 89 df             	mov    rdi,rbx
  218f74:	c5 f8 77             	vzeroupper 
  218f77:	41 ff d7             	call   r15
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  218f7a:	66 85 c0             	test   ax,ax
  218f7d:	0f 85 8e 00 00 00    	jne    219011 <callMainWithArgs+0x171>
                        try output(context, fmt[start_index..i]);
  218f83:	48 8d 35 a6 7e 00 00 	lea    rsi,[rip+0x7ea6]        # 220e30 <__unnamed_94>
  218f8a:	48 89 df             	mov    rdi,rbx
  218f8d:	41 ff d7             	call   r15
  218f90:	66 85 c0             	test   ax,ax
  218f93:	75 7c                	jne    219011 <callMainWithArgs+0x171>
    var buf: [max_int_digits - 1]u8 = undefined;
  218f95:	c5 fc 10 05 92 da fe 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffeda92]        # 206a2f <__unnamed_3+0x1f>
  218f9c:	ff 
  218f9d:	c5 fc 11 44 24 2f    	vmovups YMMWORD PTR [rsp+0x2f],ymm0
  218fa3:	c5 fc 10 05 65 da fe 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffeda65]        # 206a10 <__unnamed_3>
  218faa:	ff 
  218fab:	c5 fc 11 44 24 10    	vmovups YMMWORD PTR [rsp+0x10],ymm0
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  218fb1:	c6 44 24 4f 31       	mov    BYTE PTR [rsp+0x4f],0x31
        const padded_buf = buf[index - padding ..];
  218fb6:	4c 89 34 24          	mov    QWORD PTR [rsp],r14
  218fba:	48 c7 44 24 08 01 00 	mov    QWORD PTR [rsp+0x8],0x1
  218fc1:	00 00 
  218fc3:	48 89 e6             	mov    rsi,rsp
        return output(context, padded_buf);
  218fc6:	48 89 df             	mov    rdi,rbx
  218fc9:	c5 f8 77             	vzeroupper 
  218fcc:	41 ff d7             	call   r15
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  218fcf:	66 85 c0             	test   ax,ax
  218fd2:	75 3d                	jne    219011 <callMainWithArgs+0x171>
                        try output(context, fmt[start_index..i]);
  218fd4:	48 8d 35 65 7e 00 00 	lea    rsi,[rip+0x7e65]        # 220e40 <__unnamed_95>
  218fdb:	48 89 df             	mov    rdi,rbx
  218fde:	41 ff d7             	call   r15
  218fe1:	66 85 c0             	test   ax,ax
  218fe4:	75 2b                	jne    219011 <callMainWithArgs+0x171>
                const casted_value = ([]const u8)(value);
  218fe6:	c5 f8 10 05 12 7b 00 	vmovups xmm0,XMMWORD PTR [rip+0x7b12]        # 220b00 <__unnamed_96>
  218fed:	00 
  218fee:	c5 f8 29 44 24 10    	vmovaps XMMWORD PTR [rsp+0x10],xmm0
  218ff4:	48 8d 74 24 10       	lea    rsi,[rsp+0x10]
                return output(context, casted_value);
  218ff9:	48 89 df             	mov    rdi,rbx
  218ffc:	41 ff d7             	call   r15
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  218fff:	66 85 c0             	test   ax,ax
  219002:	75 0d                	jne    219011 <callMainWithArgs+0x171>
        try output(context, fmt[start_index..]);
  219004:	48 8d 35 45 7e 00 00 	lea    rsi,[rip+0x7e45]        # 220e50 <__unnamed_97>
  21900b:	48 89 df             	mov    rdi,rbx
  21900e:	41 ff d7             	call   r15
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  219011:	31 c0                	xor    eax,eax
  219013:	86 05 f7 7f 00 00    	xchg   BYTE PTR [rip+0x7ff7],al        # 221010 <stderr_mutex>
  219019:	3c 01                	cmp    al,0x1
    if (!ok) {
  21901b:	0f 85 6e 03 00 00    	jne    21938f <callMainWithArgs+0x4ef>
    var ok_count: usize = 0;
    var skip_count: usize = 0;
    for (test_fn_list) |test_fn, i| {
        warn("Test {}/{} {}...", i + 1, test_fn_list.len, test_fn.name);

        if (test_fn.func()) |_| {
  219021:	e8 aa f5 fe ff       	call   2085d0 <benchmark.add>
  219026:	89 c3                	mov    ebx,eax
  219028:	66 85 db             	test   bx,bx
  21902b:	74 43                	je     219070 <callMainWithArgs+0x1d0>
  21902d:	0f b7 c3             	movzx  eax,bx
  219030:	83 f8 27             	cmp    eax,0x27
  219033:	75 6b                	jne    2190a0 <callMainWithArgs+0x200>
  219035:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21903c:	00 00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  219040:	b0 01                	mov    al,0x1
  219042:	86 05 c8 7f 00 00    	xchg   BYTE PTR [rip+0x7fc8],al        # 221010 <stderr_mutex>
  219048:	84 c0                	test   al,al
  21904a:	75 f4                	jne    219040 <callMainWithArgs+0x1a0>
    if (stderr_stream) |st| {
  21904c:	48 8b 3d b5 7f 00 00 	mov    rdi,QWORD PTR [rip+0x7fb5]        # 221008 <stderr_stream>
  219053:	48 85 ff             	test   rdi,rdi
  219056:	74 70                	je     2190c8 <callMainWithArgs+0x228>
  219058:	48 8b 0d b1 3f 00 00 	mov    rcx,QWORD PTR [rip+0x3fb1]        # 21d010 <stderr_file_out_stream+0x8>
  21905f:	e9 98 00 00 00       	jmp    2190fc <callMainWithArgs+0x25c>
  219064:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21906b:	00 00 00 00 00 
  219070:	b0 01                	mov    al,0x1
  219072:	86 05 98 7f 00 00    	xchg   BYTE PTR [rip+0x7f98],al        # 221010 <stderr_mutex>
  219078:	84 c0                	test   al,al
  21907a:	75 f4                	jne    219070 <callMainWithArgs+0x1d0>
  21907c:	48 8b 3d 85 7f 00 00 	mov    rdi,QWORD PTR [rip+0x7f85]        # 221008 <stderr_stream>
  219083:	48 85 ff             	test   rdi,rdi
  219086:	0f 84 bc 00 00 00    	je     219148 <callMainWithArgs+0x2a8>
  21908c:	48 8b 0d 7d 3f 00 00 	mov    rcx,QWORD PTR [rip+0x3f7d]        # 21d010 <stderr_file_out_stream+0x8>
  219093:	e9 e4 00 00 00       	jmp    21917c <callMainWithArgs+0x2dc>
  219098:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  21909f:	00 
  2190a0:	b0 01                	mov    al,0x1
  2190a2:	86 05 68 7f 00 00    	xchg   BYTE PTR [rip+0x7f68],al        # 221010 <stderr_mutex>
  2190a8:	84 c0                	test   al,al
  2190aa:	75 f4                	jne    2190a0 <callMainWithArgs+0x200>
  2190ac:	4c 8b 35 55 7f 00 00 	mov    r14,QWORD PTR [rip+0x7f55]        # 221008 <stderr_stream>
  2190b3:	4d 85 f6             	test   r14,r14
  2190b6:	0f 84 41 02 00 00    	je     2192fd <callMainWithArgs+0x45d>
  2190bc:	4c 8b 3d 4d 3f 00 00 	mov    r15,QWORD PTR [rip+0x3f4d]        # 21d010 <stderr_file_out_stream+0x8>
  2190c3:	e9 69 02 00 00       	jmp    219331 <callMainWithArgs+0x491>
        stderr_file = try io.getStdErr();
  2190c8:	48 8d 05 31 3f 00 00 	lea    rax,[rip+0x3f31]        # 21d000 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  2190cf:	48 89 05 32 3f 00 00 	mov    QWORD PTR [rip+0x3f32],rax        # 21d008 <stderr_file_out_stream>
  2190d6:	48 8d 0d 23 17 ff ff 	lea    rcx,[rip+0xffffffffffff1723]        # 20a800 <FileOutStream_writeFn>
  2190dd:	48 89 0d 2c 3f 00 00 	mov    QWORD PTR [rip+0x3f2c],rcx        # 21d010 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  2190e4:	c7 05 12 3f 00 00 02 	mov    DWORD PTR [rip+0x3f12],0x2        # 21d000 <stderr_file>
  2190eb:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  2190ee:	48 8d 3d 1b 3f 00 00 	lea    rdi,[rip+0x3f1b]        # 21d010 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  2190f5:	48 89 3d 0c 7f 00 00 	mov    QWORD PTR [rip+0x7f0c],rdi        # 221008 <stderr_stream>
  2190fc:	48 8d 35 6d 7d 00 00 	lea    rsi,[rip+0x7d6d]        # 220e70 <__unnamed_98>
  219103:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  219105:	31 c0                	xor    eax,eax
  219107:	86 05 03 7f 00 00    	xchg   BYTE PTR [rip+0x7f03],al        # 221010 <stderr_mutex>
  21910d:	3c 01                	cmp    al,0x1
    if (!ok) {
  21910f:	0f 85 7a 02 00 00    	jne    21938f <callMainWithArgs+0x4ef>
  219115:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21911c:	00 00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  219120:	b0 01                	mov    al,0x1
  219122:	86 05 e8 7e 00 00    	xchg   BYTE PTR [rip+0x7ee8],al        # 221010 <stderr_mutex>
  219128:	84 c0                	test   al,al
  21912a:	75 f4                	jne    219120 <callMainWithArgs+0x280>
    if (stderr_stream) |st| {
  21912c:	48 8b 1d d5 7e 00 00 	mov    rbx,QWORD PTR [rip+0x7ed5]        # 221008 <stderr_stream>
  219133:	48 85 db             	test   rbx,rbx
  219136:	0f 84 8c 00 00 00    	je     2191c8 <callMainWithArgs+0x328>
  21913c:	4c 8b 3d cd 3e 00 00 	mov    r15,QWORD PTR [rip+0x3ecd]        # 21d010 <stderr_file_out_stream+0x8>
  219143:	e9 b4 00 00 00       	jmp    2191fc <callMainWithArgs+0x35c>
        stderr_file = try io.getStdErr();
  219148:	48 8d 05 b1 3e 00 00 	lea    rax,[rip+0x3eb1]        # 21d000 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  21914f:	48 89 05 b2 3e 00 00 	mov    QWORD PTR [rip+0x3eb2],rax        # 21d008 <stderr_file_out_stream>
  219156:	48 8d 0d a3 16 ff ff 	lea    rcx,[rip+0xffffffffffff16a3]        # 20a800 <FileOutStream_writeFn>
  21915d:	48 89 0d ac 3e 00 00 	mov    QWORD PTR [rip+0x3eac],rcx        # 21d010 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  219164:	c7 05 92 3e 00 00 02 	mov    DWORD PTR [rip+0x3e92],0x2        # 21d000 <stderr_file>
  21916b:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  21916e:	48 8d 3d 9b 3e 00 00 	lea    rdi,[rip+0x3e9b]        # 21d010 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  219175:	48 89 3d 8c 7e 00 00 	mov    QWORD PTR [rip+0x7e8c],rdi        # 221008 <stderr_stream>
  21917c:	48 8d 35 dd 7c 00 00 	lea    rsi,[rip+0x7cdd]        # 220e60 <__unnamed_99>
  219183:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  219185:	31 c0                	xor    eax,eax
  219187:	86 05 83 7e 00 00    	xchg   BYTE PTR [rip+0x7e83],al        # 221010 <stderr_mutex>
  21918d:	3c 01                	cmp    al,0x1
    if (!ok) {
  21918f:	0f 85 fa 01 00 00    	jne    21938f <callMainWithArgs+0x4ef>
  219195:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21919c:	00 00 00 00 
        while (@atomicRmw(u8, &self.lock, builtin.AtomicRmwOp.Xchg, 1, AtomicOrder.SeqCst) != 0) {}
  2191a0:	b0 01                	mov    al,0x1
  2191a2:	86 05 68 7e 00 00    	xchg   BYTE PTR [rip+0x7e68],al        # 221010 <stderr_mutex>
  2191a8:	84 c0                	test   al,al
  2191aa:	75 f4                	jne    2191a0 <callMainWithArgs+0x300>
    if (stderr_stream) |st| {
  2191ac:	48 8b 3d 55 7e 00 00 	mov    rdi,QWORD PTR [rip+0x7e55]        # 221008 <stderr_stream>
  2191b3:	48 85 ff             	test   rdi,rdi
  2191b6:	0f 84 e7 00 00 00    	je     2192a3 <callMainWithArgs+0x403>
  2191bc:	48 8b 0d 4d 3e 00 00 	mov    rcx,QWORD PTR [rip+0x3e4d]        # 21d010 <stderr_file_out_stream+0x8>
  2191c3:	e9 0f 01 00 00       	jmp    2192d7 <callMainWithArgs+0x437>
        stderr_file = try io.getStdErr();
  2191c8:	48 8d 05 31 3e 00 00 	lea    rax,[rip+0x3e31]        # 21d000 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  2191cf:	48 89 05 32 3e 00 00 	mov    QWORD PTR [rip+0x3e32],rax        # 21d008 <stderr_file_out_stream>
  2191d6:	4c 8d 3d 23 16 ff ff 	lea    r15,[rip+0xffffffffffff1623]        # 20a800 <FileOutStream_writeFn>
  2191dd:	4c 89 3d 2c 3e 00 00 	mov    QWORD PTR [rip+0x3e2c],r15        # 21d010 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  2191e4:	c7 05 12 3e 00 00 02 	mov    DWORD PTR [rip+0x3e12],0x2        # 21d000 <stderr_file>
  2191eb:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  2191ee:	48 8d 1d 1b 3e 00 00 	lea    rbx,[rip+0x3e1b]        # 21d010 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  2191f5:	48 89 1d 0c 7e 00 00 	mov    QWORD PTR [rip+0x7e0c],rbx        # 221008 <stderr_stream>
    var buf: [max_int_digits - 1]u8 = undefined;
  2191fc:	c5 fc 10 05 2b d8 fe 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffed82b]        # 206a2f <__unnamed_3+0x1f>
  219203:	ff 
  219204:	c5 fc 11 44 24 2f    	vmovups YMMWORD PTR [rsp+0x2f],ymm0
  21920a:	c5 fc 10 05 fe d7 fe 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffed7fe]        # 206a10 <__unnamed_3>
  219211:	ff 
  219212:	c5 fc 11 44 24 10    	vmovups YMMWORD PTR [rsp+0x10],ymm0
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  219218:	c6 44 24 4f 30       	mov    BYTE PTR [rsp+0x4f],0x30
        const padded_buf = buf[index - padding ..];
  21921d:	4c 89 34 24          	mov    QWORD PTR [rsp],r14
  219221:	48 c7 44 24 08 01 00 	mov    QWORD PTR [rsp+0x8],0x1
  219228:	00 00 
  21922a:	48 89 e6             	mov    rsi,rsp
        return output(context, padded_buf);
  21922d:	48 89 df             	mov    rdi,rbx
  219230:	c5 f8 77             	vzeroupper 
  219233:	41 ff d7             	call   r15
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  219236:	66 85 c0             	test   ax,ax
  219239:	0f 85 a1 00 00 00    	jne    2192e0 <callMainWithArgs+0x440>
                        try output(context, fmt[start_index..i]);
  21923f:	48 8d 35 4a 7c 00 00 	lea    rsi,[rip+0x7c4a]        # 220e90 <__unnamed_100>
  219246:	48 89 df             	mov    rdi,rbx
  219249:	41 ff d7             	call   r15
  21924c:	66 85 c0             	test   ax,ax
  21924f:	0f 85 8b 00 00 00    	jne    2192e0 <callMainWithArgs+0x440>
    var buf: [max_int_digits - 1]u8 = undefined;
  219255:	c5 fc 10 05 d2 d7 fe 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffed7d2]        # 206a2f <__unnamed_3+0x1f>
  21925c:	ff 
  21925d:	c5 fc 11 44 24 2f    	vmovups YMMWORD PTR [rsp+0x2f],ymm0
  219263:	c5 fc 10 05 a5 d7 fe 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffed7a5]        # 206a10 <__unnamed_3>
  21926a:	ff 
  21926b:	c5 fc 11 44 24 10    	vmovups YMMWORD PTR [rsp+0x10],ymm0
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  219271:	c6 44 24 4f 31       	mov    BYTE PTR [rsp+0x4f],0x31
        const padded_buf = buf[index - padding ..];
  219276:	4c 89 34 24          	mov    QWORD PTR [rsp],r14
  21927a:	48 c7 44 24 08 01 00 	mov    QWORD PTR [rsp+0x8],0x1
  219281:	00 00 
  219283:	48 89 e6             	mov    rsi,rsp
        return output(context, padded_buf);
  219286:	48 89 df             	mov    rdi,rbx
  219289:	c5 f8 77             	vzeroupper 
  21928c:	41 ff d7             	call   r15
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  21928f:	66 85 c0             	test   ax,ax
  219292:	75 4c                	jne    2192e0 <callMainWithArgs+0x440>
        try output(context, fmt[start_index..]);
  219294:	48 8d 35 05 7c 00 00 	lea    rsi,[rip+0x7c05]        # 220ea0 <__unnamed_101>
  21929b:	48 89 df             	mov    rdi,rbx
  21929e:	41 ff d7             	call   r15
  2192a1:	eb 3d                	jmp    2192e0 <callMainWithArgs+0x440>
        stderr_file = try io.getStdErr();
  2192a3:	48 8d 05 56 3d 00 00 	lea    rax,[rip+0x3d56]        # 21d000 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  2192aa:	48 89 05 57 3d 00 00 	mov    QWORD PTR [rip+0x3d57],rax        # 21d008 <stderr_file_out_stream>
  2192b1:	48 8d 0d 48 15 ff ff 	lea    rcx,[rip+0xffffffffffff1548]        # 20a800 <FileOutStream_writeFn>
  2192b8:	48 89 0d 51 3d 00 00 	mov    QWORD PTR [rip+0x3d51],rcx        # 21d010 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  2192bf:	c7 05 37 3d 00 00 02 	mov    DWORD PTR [rip+0x3d37],0x2        # 21d000 <stderr_file>
  2192c6:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  2192c9:	48 8d 3d 40 3d 00 00 	lea    rdi,[rip+0x3d40]        # 21d010 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  2192d0:	48 89 3d 31 7d 00 00 	mov    QWORD PTR [rip+0x7d31],rdi        # 221008 <stderr_stream>
  2192d7:	48 8d 35 a2 7b 00 00 	lea    rsi,[rip+0x7ba2]        # 220e80 <__unnamed_102>
  2192de:	ff d1                	call   rcx
            assert(@atomicRmw(u8, &self.mutex.lock, builtin.AtomicRmwOp.Xchg, 0, AtomicOrder.SeqCst) == 1);
  2192e0:	31 c9                	xor    ecx,ecx
  2192e2:	86 0d 28 7d 00 00    	xchg   BYTE PTR [rip+0x7d28],cl        # 221010 <stderr_mutex>
  2192e8:	31 c0                	xor    eax,eax
  2192ea:	80 f9 01             	cmp    cl,0x1
    if (!ok) {
  2192ed:	0f 85 9c 00 00 00    	jne    21938f <callMainWithArgs+0x4ef>
    return callMain();
  2192f3:	48 83 c4 50          	add    rsp,0x50
  2192f7:	5b                   	pop    rbx
  2192f8:	41 5e                	pop    r14
  2192fa:	41 5f                	pop    r15
  2192fc:	c3                   	ret    
        stderr_file = try io.getStdErr();
  2192fd:	48 8d 05 fc 3c 00 00 	lea    rax,[rip+0x3cfc]        # 21d000 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  219304:	48 89 05 fd 3c 00 00 	mov    QWORD PTR [rip+0x3cfd],rax        # 21d008 <stderr_file_out_stream>
  21930b:	4c 8d 3d ee 14 ff ff 	lea    r15,[rip+0xffffffffffff14ee]        # 20a800 <FileOutStream_writeFn>
  219312:	4c 89 3d f7 3c 00 00 	mov    QWORD PTR [rip+0x3cf7],r15        # 21d010 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  219319:	c7 05 dd 3c 00 00 02 	mov    DWORD PTR [rip+0x3cdd],0x2        # 21d000 <stderr_file>
  219320:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  219323:	4c 8d 35 e6 3c 00 00 	lea    r14,[rip+0x3ce6]        # 21d010 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  21932a:	4c 89 35 d7 7c 00 00 	mov    QWORD PTR [rip+0x7cd7],r14        # 221008 <stderr_stream>
                        try output(context, fmt[start_index..i]);
  219331:	48 8d 35 78 7b 00 00 	lea    rsi,[rip+0x7b78]        # 220eb0 <__unnamed_103>
  219338:	4c 89 f7             	mov    rdi,r14
  21933b:	41 ff d7             	call   r15
  21933e:	66 85 c0             	test   ax,ax
  219341:	75 39                	jne    21937c <callMainWithArgs+0x4dc>
  219343:	48 0f bf c3          	movsx  rax,bx
  219347:	48 c1 e0 04          	shl    rax,0x4
  21934b:	48 8d 0d ae 4c 00 00 	lea    rcx,[rip+0x4cae]        # 21e000 <raw+0xf68>
  219352:	48 01 c1             	add    rcx,rax
                const casted_value = ([]const u8)(value);
  219355:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  219359:	c5 f8 29 44 24 10    	vmovaps XMMWORD PTR [rsp+0x10],xmm0
  21935f:	48 8d 74 24 10       	lea    rsi,[rsp+0x10]
                return output(context, casted_value);
  219364:	4c 89 f7             	mov    rdi,r14
  219367:	41 ff d7             	call   r15
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  21936a:	66 85 c0             	test   ax,ax
  21936d:	75 0d                	jne    21937c <callMainWithArgs+0x4dc>
        try output(context, fmt[start_index..]);
  21936f:	48 8d 35 4a 7b 00 00 	lea    rsi,[rip+0x7b4a]        # 220ec0 <__unnamed_104>
  219376:	4c 89 f7             	mov    rdi,r14
  219379:	41 ff d7             	call   r15
  21937c:	31 c9                	xor    ecx,ecx
  21937e:	86 0d 8c 7c 00 00    	xchg   BYTE PTR [rip+0x7c8c],cl        # 221010 <stderr_mutex>
  219384:	b0 01                	mov    al,0x1
  219386:	80 f9 01             	cmp    cl,0x1
    if (!ok) {
  219389:	0f 84 64 ff ff ff    	je     2192f3 <callMainWithArgs+0x453>
            @panic("assertion failure");
  21938f:	e8 8c f9 fe ff       	call   208d20 <panic>
  219394:	cc                   	int3   
  219395:	cc                   	int3   
  219396:	cc                   	int3   
  219397:	cc                   	int3   
  219398:	cc                   	int3   
  219399:	cc                   	int3   
  21939a:	cc                   	int3   
  21939b:	cc                   	int3   
  21939c:	cc                   	int3   
  21939d:	cc                   	int3   
  21939e:	cc                   	int3   
  21939f:	cc                   	int3   

00000000002193a0 <memset>:

export fn memset(dest: ?[*]u8, c: u8, n: usize) ?[*]u8 {
    @setRuntimeSafety(false);

    var index: usize = 0;
    while (index != n) : (index += 1)
  2193a0:	48 85 d2             	test   rdx,rdx
  2193a3:	0f 84 d4 01 00 00    	je     21957d <memset+0x1dd>
  2193a9:	48 81 fa 80 00 00 00 	cmp    rdx,0x80
  2193b0:	73 08                	jae    2193ba <memset+0x1a>
  2193b2:	45 31 c0             	xor    r8d,r8d
  2193b5:	e9 a8 01 00 00       	jmp    219562 <memset+0x1c2>
  2193ba:	49 89 d0             	mov    r8,rdx
  2193bd:	49 83 e0 80          	and    r8,0xffffffffffffff80
  2193c1:	c5 f9 6e c6          	vmovd  xmm0,esi
  2193c5:	c4 e2 7d 78 c0       	vpbroadcastb ymm0,xmm0
  2193ca:	49 8d 48 80          	lea    rcx,[r8-0x80]
  2193ce:	48 89 c8             	mov    rax,rcx
  2193d1:	48 c1 e8 07          	shr    rax,0x7
  2193d5:	44 8d 48 01          	lea    r9d,[rax+0x1]
  2193d9:	41 83 e1 07          	and    r9d,0x7
  2193dd:	48 81 f9 80 03 00 00 	cmp    rcx,0x380
  2193e4:	73 10                	jae    2193f6 <memset+0x56>
  2193e6:	31 c0                	xor    eax,eax
  2193e8:	4d 85 c9             	test   r9,r9
  2193eb:	0f 85 44 01 00 00    	jne    219535 <memset+0x195>
  2193f1:	e9 67 01 00 00       	jmp    21955d <memset+0x1bd>
  2193f6:	48 8d 8f e0 03 00 00 	lea    rcx,[rdi+0x3e0]
  2193fd:	4d 8d 51 ff          	lea    r10,[r9-0x1]
  219401:	49 29 c2             	sub    r10,rax
  219404:	31 c0                	xor    eax,eax
  219406:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  21940d:	00 00 00 
        dest.?[index] = c;
  219410:	c5 fe 7f 84 01 20 fc 	vmovdqu YMMWORD PTR [rcx+rax*1-0x3e0],ymm0
  219417:	ff ff 
  219419:	c5 fe 7f 84 01 40 fc 	vmovdqu YMMWORD PTR [rcx+rax*1-0x3c0],ymm0
  219420:	ff ff 
  219422:	c5 fe 7f 84 01 60 fc 	vmovdqu YMMWORD PTR [rcx+rax*1-0x3a0],ymm0
  219429:	ff ff 
  21942b:	c5 fe 7f 84 01 80 fc 	vmovdqu YMMWORD PTR [rcx+rax*1-0x380],ymm0
  219432:	ff ff 
  219434:	c5 fe 7f 84 01 a0 fc 	vmovdqu YMMWORD PTR [rcx+rax*1-0x360],ymm0
  21943b:	ff ff 
  21943d:	c5 fe 7f 84 01 c0 fc 	vmovdqu YMMWORD PTR [rcx+rax*1-0x340],ymm0
  219444:	ff ff 
  219446:	c5 fe 7f 84 01 e0 fc 	vmovdqu YMMWORD PTR [rcx+rax*1-0x320],ymm0
  21944d:	ff ff 
  21944f:	c5 fe 7f 84 01 00 fd 	vmovdqu YMMWORD PTR [rcx+rax*1-0x300],ymm0
  219456:	ff ff 
  219458:	c5 fe 7f 84 01 20 fd 	vmovdqu YMMWORD PTR [rcx+rax*1-0x2e0],ymm0
  21945f:	ff ff 
  219461:	c5 fe 7f 84 01 40 fd 	vmovdqu YMMWORD PTR [rcx+rax*1-0x2c0],ymm0
  219468:	ff ff 
  21946a:	c5 fe 7f 84 01 60 fd 	vmovdqu YMMWORD PTR [rcx+rax*1-0x2a0],ymm0
  219471:	ff ff 
  219473:	c5 fe 7f 84 01 80 fd 	vmovdqu YMMWORD PTR [rcx+rax*1-0x280],ymm0
  21947a:	ff ff 
  21947c:	c5 fe 7f 84 01 a0 fd 	vmovdqu YMMWORD PTR [rcx+rax*1-0x260],ymm0
  219483:	ff ff 
  219485:	c5 fe 7f 84 01 c0 fd 	vmovdqu YMMWORD PTR [rcx+rax*1-0x240],ymm0
  21948c:	ff ff 
  21948e:	c5 fe 7f 84 01 e0 fd 	vmovdqu YMMWORD PTR [rcx+rax*1-0x220],ymm0
  219495:	ff ff 
  219497:	c5 fe 7f 84 01 00 fe 	vmovdqu YMMWORD PTR [rcx+rax*1-0x200],ymm0
  21949e:	ff ff 
  2194a0:	c5 fe 7f 84 01 20 fe 	vmovdqu YMMWORD PTR [rcx+rax*1-0x1e0],ymm0
  2194a7:	ff ff 
  2194a9:	c5 fe 7f 84 01 40 fe 	vmovdqu YMMWORD PTR [rcx+rax*1-0x1c0],ymm0
  2194b0:	ff ff 
  2194b2:	c5 fe 7f 84 01 60 fe 	vmovdqu YMMWORD PTR [rcx+rax*1-0x1a0],ymm0
  2194b9:	ff ff 
  2194bb:	c5 fe 7f 84 01 80 fe 	vmovdqu YMMWORD PTR [rcx+rax*1-0x180],ymm0
  2194c2:	ff ff 
  2194c4:	c5 fe 7f 84 01 a0 fe 	vmovdqu YMMWORD PTR [rcx+rax*1-0x160],ymm0
  2194cb:	ff ff 
  2194cd:	c5 fe 7f 84 01 c0 fe 	vmovdqu YMMWORD PTR [rcx+rax*1-0x140],ymm0
  2194d4:	ff ff 
  2194d6:	c5 fe 7f 84 01 e0 fe 	vmovdqu YMMWORD PTR [rcx+rax*1-0x120],ymm0
  2194dd:	ff ff 
  2194df:	c5 fe 7f 84 01 00 ff 	vmovdqu YMMWORD PTR [rcx+rax*1-0x100],ymm0
  2194e6:	ff ff 
  2194e8:	c5 fe 7f 84 01 20 ff 	vmovdqu YMMWORD PTR [rcx+rax*1-0xe0],ymm0
  2194ef:	ff ff 
  2194f1:	c5 fe 7f 84 01 40 ff 	vmovdqu YMMWORD PTR [rcx+rax*1-0xc0],ymm0
  2194f8:	ff ff 
  2194fa:	c5 fe 7f 84 01 60 ff 	vmovdqu YMMWORD PTR [rcx+rax*1-0xa0],ymm0
  219501:	ff ff 
  219503:	c5 fe 7f 44 01 80    	vmovdqu YMMWORD PTR [rcx+rax*1-0x80],ymm0
  219509:	c5 fe 7f 44 01 a0    	vmovdqu YMMWORD PTR [rcx+rax*1-0x60],ymm0
  21950f:	c5 fe 7f 44 01 c0    	vmovdqu YMMWORD PTR [rcx+rax*1-0x40],ymm0
  219515:	c5 fe 7f 44 01 e0    	vmovdqu YMMWORD PTR [rcx+rax*1-0x20],ymm0
  21951b:	c5 fe 7f 04 01       	vmovdqu YMMWORD PTR [rcx+rax*1],ymm0
    while (index != n) : (index += 1)
  219520:	48 05 00 04 00 00    	add    rax,0x400
  219526:	49 83 c2 08          	add    r10,0x8
  21952a:	0f 85 e0 fe ff ff    	jne    219410 <memset+0x70>
  219530:	4d 85 c9             	test   r9,r9
  219533:	74 28                	je     21955d <memset+0x1bd>
  219535:	48 01 f8             	add    rax,rdi
  219538:	48 83 c0 60          	add    rax,0x60
  21953c:	49 f7 d9             	neg    r9
  21953f:	90                   	nop
        dest.?[index] = c;
  219540:	c5 fe 7f 40 a0       	vmovdqu YMMWORD PTR [rax-0x60],ymm0
  219545:	c5 fe 7f 40 c0       	vmovdqu YMMWORD PTR [rax-0x40],ymm0
  21954a:	c5 fe 7f 40 e0       	vmovdqu YMMWORD PTR [rax-0x20],ymm0
  21954f:	c5 fe 7f 00          	vmovdqu YMMWORD PTR [rax],ymm0
    while (index != n) : (index += 1)
  219553:	48 83 e8 80          	sub    rax,0xffffffffffffff80
  219557:	49 83 c1 01          	add    r9,0x1
  21955b:	75 e3                	jne    219540 <memset+0x1a0>
  21955d:	49 39 d0             	cmp    r8,rdx
  219560:	74 1b                	je     21957d <memset+0x1dd>
        dest.?[index] = c;
  219562:	4a 8d 04 07          	lea    rax,[rdi+r8*1]
  219566:	4c 29 c2             	sub    rdx,r8
  219569:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  219570:	40 88 30             	mov    BYTE PTR [rax],sil
    while (index != n) : (index += 1)
  219573:	48 83 c0 01          	add    rax,0x1
  219577:	48 83 c2 ff          	add    rdx,0xffffffffffffffff
  21957b:	75 f3                	jne    219570 <memset+0x1d0>

    return dest;
  21957d:	48 89 f8             	mov    rax,rdi
  219580:	c5 f8 77             	vzeroupper 
  219583:	c3                   	ret    
  219584:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21958b:	00 00 00 00 00 

0000000000219590 <memcpy>:

export fn memcpy(noalias dest: ?[*]u8, noalias src: ?[*]const u8, n: usize) ?[*]u8 {
    @setRuntimeSafety(false);

    var index: usize = 0;
    while (index != n) : (index += 1)
  219590:	48 85 d2             	test   rdx,rdx
  219593:	0f 84 d7 01 00 00    	je     219770 <memcpy+0x1e0>
  219599:	48 81 fa 80 00 00 00 	cmp    rdx,0x80
  2195a0:	73 07                	jae    2195a9 <memcpy+0x19>
  2195a2:	31 c0                	xor    eax,eax
  2195a4:	e9 b7 01 00 00       	jmp    219760 <memcpy+0x1d0>
  2195a9:	48 89 d0             	mov    rax,rdx
  2195ac:	48 83 e0 80          	and    rax,0xffffffffffffff80
  2195b0:	4c 8d 48 80          	lea    r9,[rax-0x80]
  2195b4:	4c 89 c9             	mov    rcx,r9
  2195b7:	48 c1 e9 07          	shr    rcx,0x7
  2195bb:	44 8d 41 01          	lea    r8d,[rcx+0x1]
  2195bf:	41 83 e0 03          	and    r8d,0x3
  2195c3:	49 81 f9 80 01 00 00 	cmp    r9,0x180
  2195ca:	73 10                	jae    2195dc <memcpy+0x4c>
  2195cc:	31 c9                	xor    ecx,ecx
  2195ce:	4d 85 c0             	test   r8,r8
  2195d1:	0f 85 35 01 00 00    	jne    21970c <memcpy+0x17c>
  2195d7:	e9 7c 01 00 00       	jmp    219758 <memcpy+0x1c8>
  2195dc:	4d 8d 48 ff          	lea    r9,[r8-0x1]
  2195e0:	49 29 c9             	sub    r9,rcx
  2195e3:	31 c9                	xor    ecx,ecx
  2195e5:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  2195ec:	00 00 00 00 
        dest.?[index] = src.?[index];
  2195f0:	c5 fc 10 04 0e       	vmovups ymm0,YMMWORD PTR [rsi+rcx*1]
  2195f5:	c5 fc 10 4c 0e 20    	vmovups ymm1,YMMWORD PTR [rsi+rcx*1+0x20]
  2195fb:	c5 fc 10 54 0e 40    	vmovups ymm2,YMMWORD PTR [rsi+rcx*1+0x40]
  219601:	c5 fc 10 5c 0e 60    	vmovups ymm3,YMMWORD PTR [rsi+rcx*1+0x60]
  219607:	c5 fc 11 04 0f       	vmovups YMMWORD PTR [rdi+rcx*1],ymm0
  21960c:	c5 fc 11 4c 0f 20    	vmovups YMMWORD PTR [rdi+rcx*1+0x20],ymm1
  219612:	c5 fc 11 54 0f 40    	vmovups YMMWORD PTR [rdi+rcx*1+0x40],ymm2
  219618:	c5 fc 11 5c 0f 60    	vmovups YMMWORD PTR [rdi+rcx*1+0x60],ymm3
  21961e:	c5 fc 10 84 0e 80 00 	vmovups ymm0,YMMWORD PTR [rsi+rcx*1+0x80]
  219625:	00 00 
  219627:	c5 fc 10 8c 0e a0 00 	vmovups ymm1,YMMWORD PTR [rsi+rcx*1+0xa0]
  21962e:	00 00 
  219630:	c5 fc 10 94 0e c0 00 	vmovups ymm2,YMMWORD PTR [rsi+rcx*1+0xc0]
  219637:	00 00 
  219639:	c5 fc 10 9c 0e e0 00 	vmovups ymm3,YMMWORD PTR [rsi+rcx*1+0xe0]
  219640:	00 00 
  219642:	c5 fc 11 84 0f 80 00 	vmovups YMMWORD PTR [rdi+rcx*1+0x80],ymm0
  219649:	00 00 
  21964b:	c5 fc 11 8c 0f a0 00 	vmovups YMMWORD PTR [rdi+rcx*1+0xa0],ymm1
  219652:	00 00 
  219654:	c5 fc 11 94 0f c0 00 	vmovups YMMWORD PTR [rdi+rcx*1+0xc0],ymm2
  21965b:	00 00 
  21965d:	c5 fc 11 9c 0f e0 00 	vmovups YMMWORD PTR [rdi+rcx*1+0xe0],ymm3
  219664:	00 00 
  219666:	c5 fc 10 84 0e 00 01 	vmovups ymm0,YMMWORD PTR [rsi+rcx*1+0x100]
  21966d:	00 00 
  21966f:	c5 fc 10 8c 0e 20 01 	vmovups ymm1,YMMWORD PTR [rsi+rcx*1+0x120]
  219676:	00 00 
  219678:	c5 fc 10 94 0e 40 01 	vmovups ymm2,YMMWORD PTR [rsi+rcx*1+0x140]
  21967f:	00 00 
  219681:	c5 fc 10 9c 0e 60 01 	vmovups ymm3,YMMWORD PTR [rsi+rcx*1+0x160]
  219688:	00 00 
  21968a:	c5 fc 11 84 0f 00 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x100],ymm0
  219691:	00 00 
  219693:	c5 fc 11 8c 0f 20 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x120],ymm1
  21969a:	00 00 
  21969c:	c5 fc 11 94 0f 40 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x140],ymm2
  2196a3:	00 00 
  2196a5:	c5 fc 11 9c 0f 60 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x160],ymm3
  2196ac:	00 00 
  2196ae:	c5 fc 10 84 0e 80 01 	vmovups ymm0,YMMWORD PTR [rsi+rcx*1+0x180]
  2196b5:	00 00 
  2196b7:	c5 fc 10 8c 0e a0 01 	vmovups ymm1,YMMWORD PTR [rsi+rcx*1+0x1a0]
  2196be:	00 00 
  2196c0:	c5 fc 10 94 0e c0 01 	vmovups ymm2,YMMWORD PTR [rsi+rcx*1+0x1c0]
  2196c7:	00 00 
  2196c9:	c5 fc 10 9c 0e e0 01 	vmovups ymm3,YMMWORD PTR [rsi+rcx*1+0x1e0]
  2196d0:	00 00 
  2196d2:	c5 fc 11 84 0f 80 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x180],ymm0
  2196d9:	00 00 
  2196db:	c5 fc 11 8c 0f a0 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x1a0],ymm1
  2196e2:	00 00 
  2196e4:	c5 fc 11 94 0f c0 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x1c0],ymm2
  2196eb:	00 00 
  2196ed:	c5 fc 11 9c 0f e0 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x1e0],ymm3
  2196f4:	00 00 
    while (index != n) : (index += 1)
  2196f6:	48 81 c1 00 02 00 00 	add    rcx,0x200
  2196fd:	49 83 c1 04          	add    r9,0x4
  219701:	0f 85 e9 fe ff ff    	jne    2195f0 <memcpy+0x60>
  219707:	4d 85 c0             	test   r8,r8
  21970a:	74 4c                	je     219758 <memcpy+0x1c8>
  21970c:	48 83 c1 60          	add    rcx,0x60
  219710:	49 f7 d8             	neg    r8
  219713:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21971a:	84 00 00 00 00 00 
        dest.?[index] = src.?[index];
  219720:	c5 fc 10 44 0e a0    	vmovups ymm0,YMMWORD PTR [rsi+rcx*1-0x60]
  219726:	c5 fc 10 4c 0e c0    	vmovups ymm1,YMMWORD PTR [rsi+rcx*1-0x40]
  21972c:	c5 fc 10 54 0e e0    	vmovups ymm2,YMMWORD PTR [rsi+rcx*1-0x20]
  219732:	c5 fc 10 1c 0e       	vmovups ymm3,YMMWORD PTR [rsi+rcx*1]
  219737:	c5 fc 11 44 0f a0    	vmovups YMMWORD PTR [rdi+rcx*1-0x60],ymm0
  21973d:	c5 fc 11 4c 0f c0    	vmovups YMMWORD PTR [rdi+rcx*1-0x40],ymm1
  219743:	c5 fc 11 54 0f e0    	vmovups YMMWORD PTR [rdi+rcx*1-0x20],ymm2
  219749:	c5 fc 11 1c 0f       	vmovups YMMWORD PTR [rdi+rcx*1],ymm3
    while (index != n) : (index += 1)
  21974e:	48 83 e9 80          	sub    rcx,0xffffffffffffff80
  219752:	49 83 c0 01          	add    r8,0x1
  219756:	75 c8                	jne    219720 <memcpy+0x190>
  219758:	48 39 d0             	cmp    rax,rdx
  21975b:	74 13                	je     219770 <memcpy+0x1e0>
  21975d:	0f 1f 00             	nop    DWORD PTR [rax]
        dest.?[index] = src.?[index];
  219760:	0f b6 0c 06          	movzx  ecx,BYTE PTR [rsi+rax*1]
  219764:	88 0c 07             	mov    BYTE PTR [rdi+rax*1],cl
    while (index != n) : (index += 1)
  219767:	48 83 c0 01          	add    rax,0x1
  21976b:	48 39 c2             	cmp    rdx,rax
  21976e:	75 f0                	jne    219760 <memcpy+0x1d0>

    return dest;
  219770:	48 89 f8             	mov    rax,rdi
  219773:	c5 f8 77             	vzeroupper 
  219776:	c3                   	ret    
  219777:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  21977e:	00 00 

0000000000219780 <memmove>:
}

export fn memmove(dest: ?[*]u8, src: ?[*]const u8, n: usize) ?[*]u8 {
    @setRuntimeSafety(false);

    if (@ptrToInt(dest) < @ptrToInt(src)) {
  219780:	48 39 f7             	cmp    rdi,rsi
  219783:	0f 83 cb 00 00 00    	jae    219854 <memmove+0xd4>
  219789:	48 85 d2             	test   rdx,rdx
        var index: usize = 0;
        while (index != n) : (index += 1) {
  21978c:	0f 84 0f 05 00 00    	je     219ca1 <memmove+0x521>
  219792:	48 81 fa 80 00 00 00 	cmp    rdx,0x80
  219799:	72 1a                	jb     2197b5 <memmove+0x35>
  21979b:	48 8d 04 16          	lea    rax,[rsi+rdx*1]
  21979f:	48 39 f8             	cmp    rax,rdi
  2197a2:	0f 86 0b 01 00 00    	jbe    2198b3 <memmove+0x133>
  2197a8:	48 8d 04 17          	lea    rax,[rdi+rdx*1]
  2197ac:	48 39 f0             	cmp    rax,rsi
  2197af:	0f 86 fe 00 00 00    	jbe    2198b3 <memmove+0x133>
  2197b5:	45 31 d2             	xor    r10d,r10d
            dest.?[index] = src.?[index];
  2197b8:	4c 8d 42 ff          	lea    r8,[rdx-0x1]
  2197bc:	4d 29 d0             	sub    r8,r10
  2197bf:	48 89 d1             	mov    rcx,rdx
  2197c2:	48 83 e1 07          	and    rcx,0x7
  2197c6:	74 1b                	je     2197e3 <memmove+0x63>
  2197c8:	48 f7 d9             	neg    rcx
  2197cb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  2197d0:	42 0f b6 04 16       	movzx  eax,BYTE PTR [rsi+r10*1]
  2197d5:	42 88 04 17          	mov    BYTE PTR [rdi+r10*1],al
        while (index != n) : (index += 1) {
  2197d9:	49 83 c2 01          	add    r10,0x1
  2197dd:	48 83 c1 01          	add    rcx,0x1
  2197e1:	75 ed                	jne    2197d0 <memmove+0x50>
            dest.?[index] = src.?[index];
  2197e3:	49 83 f8 07          	cmp    r8,0x7
  2197e7:	0f 82 b4 04 00 00    	jb     219ca1 <memmove+0x521>
  2197ed:	0f 1f 00             	nop    DWORD PTR [rax]
  2197f0:	42 0f b6 04 16       	movzx  eax,BYTE PTR [rsi+r10*1]
  2197f5:	42 88 04 17          	mov    BYTE PTR [rdi+r10*1],al
  2197f9:	42 0f b6 44 16 01    	movzx  eax,BYTE PTR [rsi+r10*1+0x1]
  2197ff:	42 88 44 17 01       	mov    BYTE PTR [rdi+r10*1+0x1],al
  219804:	42 0f b6 44 16 02    	movzx  eax,BYTE PTR [rsi+r10*1+0x2]
  21980a:	42 88 44 17 02       	mov    BYTE PTR [rdi+r10*1+0x2],al
  21980f:	42 0f b6 44 16 03    	movzx  eax,BYTE PTR [rsi+r10*1+0x3]
  219815:	42 88 44 17 03       	mov    BYTE PTR [rdi+r10*1+0x3],al
  21981a:	42 0f b6 44 16 04    	movzx  eax,BYTE PTR [rsi+r10*1+0x4]
  219820:	42 88 44 17 04       	mov    BYTE PTR [rdi+r10*1+0x4],al
  219825:	42 0f b6 44 16 05    	movzx  eax,BYTE PTR [rsi+r10*1+0x5]
  21982b:	42 88 44 17 05       	mov    BYTE PTR [rdi+r10*1+0x5],al
  219830:	42 0f b6 44 16 06    	movzx  eax,BYTE PTR [rsi+r10*1+0x6]
  219836:	42 88 44 17 06       	mov    BYTE PTR [rdi+r10*1+0x6],al
  21983b:	42 0f b6 44 16 07    	movzx  eax,BYTE PTR [rsi+r10*1+0x7]
  219841:	42 88 44 17 07       	mov    BYTE PTR [rdi+r10*1+0x7],al
        while (index != n) : (index += 1) {
  219846:	49 83 c2 08          	add    r10,0x8
  21984a:	4c 39 d2             	cmp    rdx,r10
  21984d:	75 a1                	jne    2197f0 <memmove+0x70>
  21984f:	e9 4d 04 00 00       	jmp    219ca1 <memmove+0x521>
  219854:	48 85 d2             	test   rdx,rdx
        }
    } else {
        var index = n;
        while (index != 0) {
  219857:	0f 84 44 04 00 00    	je     219ca1 <memmove+0x521>
  21985d:	48 81 fa 80 00 00 00 	cmp    rdx,0x80
  219864:	0f 82 2a 02 00 00    	jb     219a94 <memmove+0x314>
  21986a:	48 8d 04 16          	lea    rax,[rsi+rdx*1]
  21986e:	48 39 f8             	cmp    rax,rdi
  219871:	76 0d                	jbe    219880 <memmove+0x100>
  219873:	48 8d 04 17          	lea    rax,[rdi+rdx*1]
  219877:	48 39 f0             	cmp    rax,rsi
  21987a:	0f 87 14 02 00 00    	ja     219a94 <memmove+0x314>
  219880:	49 89 d0             	mov    r8,rdx
  219883:	49 83 e0 80          	and    r8,0xffffffffffffff80
  219887:	49 8d 48 80          	lea    rcx,[r8-0x80]
  21988b:	48 89 c8             	mov    rax,rcx
  21988e:	48 c1 e8 07          	shr    rax,0x7
  219892:	44 8d 48 01          	lea    r9d,[rax+0x1]
  219896:	41 83 e1 03          	and    r9d,0x3
  21989a:	48 81 f9 80 01 00 00 	cmp    rcx,0x180
  2198a1:	73 47                	jae    2198ea <memmove+0x16a>
  2198a3:	31 c0                	xor    eax,eax
  2198a5:	4d 85 c9             	test   r9,r9
  2198a8:	0f 85 8a 01 00 00    	jne    219a38 <memmove+0x2b8>
  2198ae:	e9 d5 01 00 00       	jmp    219a88 <memmove+0x308>
        while (index != n) : (index += 1) {
  2198b3:	49 89 d2             	mov    r10,rdx
  2198b6:	49 83 e2 80          	and    r10,0xffffffffffffff80
  2198ba:	4d 8d 4a 80          	lea    r9,[r10-0x80]
  2198be:	4c 89 c9             	mov    rcx,r9
  2198c1:	48 c1 e9 07          	shr    rcx,0x7
  2198c5:	44 8d 41 01          	lea    r8d,[rcx+0x1]
  2198c9:	41 83 e0 03          	and    r8d,0x3
  2198cd:	49 81 f9 80 01 00 00 	cmp    r9,0x180
  2198d4:	0f 83 4c 02 00 00    	jae    219b26 <memmove+0x3a6>
  2198da:	31 c9                	xor    ecx,ecx
  2198dc:	4d 85 c0             	test   r8,r8
  2198df:	0f 85 67 03 00 00    	jne    219c4c <memmove+0x4cc>
  2198e5:	e9 ae 03 00 00       	jmp    219c98 <memmove+0x518>
        while (index != 0) {
  2198ea:	4c 8d 14 16          	lea    r10,[rsi+rdx*1]
  2198ee:	49 83 c2 e0          	add    r10,0xffffffffffffffe0
  2198f2:	48 8d 0c 17          	lea    rcx,[rdi+rdx*1]
  2198f6:	48 83 c1 e0          	add    rcx,0xffffffffffffffe0
  2198fa:	4d 8d 59 ff          	lea    r11,[r9-0x1]
  2198fe:	49 29 c3             	sub    r11,rax
  219901:	31 c0                	xor    eax,eax
  219903:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21990a:	84 00 00 00 00 00 
            index -= 1;
            dest.?[index] = src.?[index];
  219910:	c4 c1 7c 10 44 02 a0 	vmovups ymm0,YMMWORD PTR [r10+rax*1-0x60]
  219917:	c4 c1 7c 10 4c 02 c0 	vmovups ymm1,YMMWORD PTR [r10+rax*1-0x40]
  21991e:	c4 c1 7c 10 54 02 e0 	vmovups ymm2,YMMWORD PTR [r10+rax*1-0x20]
  219925:	c4 c1 7c 10 1c 02    	vmovups ymm3,YMMWORD PTR [r10+rax*1]
  21992b:	c5 fc 11 1c 01       	vmovups YMMWORD PTR [rcx+rax*1],ymm3
  219930:	c5 fc 11 54 01 e0    	vmovups YMMWORD PTR [rcx+rax*1-0x20],ymm2
  219936:	c5 fc 11 4c 01 c0    	vmovups YMMWORD PTR [rcx+rax*1-0x40],ymm1
  21993c:	c5 fc 11 44 01 a0    	vmovups YMMWORD PTR [rcx+rax*1-0x60],ymm0
  219942:	c4 c1 7c 10 84 02 20 	vmovups ymm0,YMMWORD PTR [r10+rax*1-0xe0]
  219949:	ff ff ff 
  21994c:	c4 c1 7c 10 8c 02 40 	vmovups ymm1,YMMWORD PTR [r10+rax*1-0xc0]
  219953:	ff ff ff 
  219956:	c4 c1 7c 10 94 02 60 	vmovups ymm2,YMMWORD PTR [r10+rax*1-0xa0]
  21995d:	ff ff ff 
  219960:	c4 c1 7c 10 5c 02 80 	vmovups ymm3,YMMWORD PTR [r10+rax*1-0x80]
  219967:	c5 fc 11 5c 01 80    	vmovups YMMWORD PTR [rcx+rax*1-0x80],ymm3
  21996d:	c5 fc 11 94 01 60 ff 	vmovups YMMWORD PTR [rcx+rax*1-0xa0],ymm2
  219974:	ff ff 
  219976:	c5 fc 11 8c 01 40 ff 	vmovups YMMWORD PTR [rcx+rax*1-0xc0],ymm1
  21997d:	ff ff 
  21997f:	c5 fc 11 84 01 20 ff 	vmovups YMMWORD PTR [rcx+rax*1-0xe0],ymm0
  219986:	ff ff 
  219988:	c4 c1 7c 10 84 02 a0 	vmovups ymm0,YMMWORD PTR [r10+rax*1-0x160]
  21998f:	fe ff ff 
  219992:	c4 c1 7c 10 8c 02 c0 	vmovups ymm1,YMMWORD PTR [r10+rax*1-0x140]
  219999:	fe ff ff 
  21999c:	c4 c1 7c 10 94 02 e0 	vmovups ymm2,YMMWORD PTR [r10+rax*1-0x120]
  2199a3:	fe ff ff 
  2199a6:	c4 c1 7c 10 9c 02 00 	vmovups ymm3,YMMWORD PTR [r10+rax*1-0x100]
  2199ad:	ff ff ff 
  2199b0:	c5 fc 11 9c 01 00 ff 	vmovups YMMWORD PTR [rcx+rax*1-0x100],ymm3
  2199b7:	ff ff 
  2199b9:	c5 fc 11 94 01 e0 fe 	vmovups YMMWORD PTR [rcx+rax*1-0x120],ymm2
  2199c0:	ff ff 
  2199c2:	c5 fc 11 8c 01 c0 fe 	vmovups YMMWORD PTR [rcx+rax*1-0x140],ymm1
  2199c9:	ff ff 
  2199cb:	c5 fc 11 84 01 a0 fe 	vmovups YMMWORD PTR [rcx+rax*1-0x160],ymm0
  2199d2:	ff ff 
  2199d4:	c4 c1 7c 10 84 02 20 	vmovups ymm0,YMMWORD PTR [r10+rax*1-0x1e0]
  2199db:	fe ff ff 
  2199de:	c4 c1 7c 10 8c 02 40 	vmovups ymm1,YMMWORD PTR [r10+rax*1-0x1c0]
  2199e5:	fe ff ff 
  2199e8:	c4 c1 7c 10 94 02 60 	vmovups ymm2,YMMWORD PTR [r10+rax*1-0x1a0]
  2199ef:	fe ff ff 
  2199f2:	c4 c1 7c 10 9c 02 80 	vmovups ymm3,YMMWORD PTR [r10+rax*1-0x180]
  2199f9:	fe ff ff 
  2199fc:	c5 fc 11 9c 01 80 fe 	vmovups YMMWORD PTR [rcx+rax*1-0x180],ymm3
  219a03:	ff ff 
  219a05:	c5 fc 11 94 01 60 fe 	vmovups YMMWORD PTR [rcx+rax*1-0x1a0],ymm2
  219a0c:	ff ff 
  219a0e:	c5 fc 11 8c 01 40 fe 	vmovups YMMWORD PTR [rcx+rax*1-0x1c0],ymm1
  219a15:	ff ff 
  219a17:	c5 fc 11 84 01 20 fe 	vmovups YMMWORD PTR [rcx+rax*1-0x1e0],ymm0
  219a1e:	ff ff 
  219a20:	48 05 00 fe ff ff    	add    rax,0xfffffffffffffe00
  219a26:	49 83 c3 04          	add    r11,0x4
  219a2a:	0f 85 e0 fe ff ff    	jne    219910 <memmove+0x190>
  219a30:	48 f7 d8             	neg    rax
  219a33:	4d 85 c9             	test   r9,r9
  219a36:	74 50                	je     219a88 <memmove+0x308>
  219a38:	48 8d 4a e0          	lea    rcx,[rdx-0x20]
  219a3c:	48 29 c1             	sub    rcx,rax
  219a3f:	49 f7 d9             	neg    r9
  219a42:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  219a49:	1f 84 00 00 00 00 00 
  219a50:	c5 fc 10 44 0e a0    	vmovups ymm0,YMMWORD PTR [rsi+rcx*1-0x60]
  219a56:	c5 fc 10 4c 0e c0    	vmovups ymm1,YMMWORD PTR [rsi+rcx*1-0x40]
  219a5c:	c5 fc 10 54 0e e0    	vmovups ymm2,YMMWORD PTR [rsi+rcx*1-0x20]
  219a62:	c5 fc 10 1c 0e       	vmovups ymm3,YMMWORD PTR [rsi+rcx*1]
  219a67:	c5 fc 11 1c 0f       	vmovups YMMWORD PTR [rdi+rcx*1],ymm3
  219a6c:	c5 fc 11 54 0f e0    	vmovups YMMWORD PTR [rdi+rcx*1-0x20],ymm2
  219a72:	c5 fc 11 4c 0f c0    	vmovups YMMWORD PTR [rdi+rcx*1-0x40],ymm1
  219a78:	c5 fc 11 44 0f a0    	vmovups YMMWORD PTR [rdi+rcx*1-0x60],ymm0
  219a7e:	48 83 c1 80          	add    rcx,0xffffffffffffff80
  219a82:	49 83 c1 01          	add    r9,0x1
  219a86:	75 c8                	jne    219a50 <memmove+0x2d0>
  219a88:	49 39 d0             	cmp    r8,rdx
        while (index != 0) {
  219a8b:	0f 84 10 02 00 00    	je     219ca1 <memmove+0x521>
  219a91:	4c 29 c2             	sub    rdx,r8
            index -= 1;
  219a94:	4c 8d 42 ff          	lea    r8,[rdx-0x1]
  219a98:	48 89 d1             	mov    rcx,rdx
  219a9b:	48 83 e1 07          	and    rcx,0x7
  219a9f:	74 22                	je     219ac3 <memmove+0x343>
  219aa1:	48 f7 d9             	neg    rcx
  219aa4:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  219aab:	00 00 00 00 00 
            dest.?[index] = src.?[index];
  219ab0:	0f b6 44 16 ff       	movzx  eax,BYTE PTR [rsi+rdx*1-0x1]
  219ab5:	88 44 17 ff          	mov    BYTE PTR [rdi+rdx*1-0x1],al
            index -= 1;
  219ab9:	48 8d 52 ff          	lea    rdx,[rdx-0x1]
        while (index != 0) {
  219abd:	48 83 c1 01          	add    rcx,0x1
  219ac1:	75 ed                	jne    219ab0 <memmove+0x330>
            index -= 1;
  219ac3:	49 83 f8 07          	cmp    r8,0x7
  219ac7:	0f 82 d4 01 00 00    	jb     219ca1 <memmove+0x521>
        while (index != 0) {
  219acd:	48 89 d0             	mov    rax,rdx
            dest.?[index] = src.?[index];
  219ad0:	0f b6 4c 16 ff       	movzx  ecx,BYTE PTR [rsi+rdx*1-0x1]
  219ad5:	88 4c 17 ff          	mov    BYTE PTR [rdi+rdx*1-0x1],cl
  219ad9:	0f b6 4c 16 fe       	movzx  ecx,BYTE PTR [rsi+rdx*1-0x2]
  219ade:	88 4c 17 fe          	mov    BYTE PTR [rdi+rdx*1-0x2],cl
  219ae2:	0f b6 4c 16 fd       	movzx  ecx,BYTE PTR [rsi+rdx*1-0x3]
  219ae7:	88 4c 17 fd          	mov    BYTE PTR [rdi+rdx*1-0x3],cl
  219aeb:	0f b6 4c 16 fc       	movzx  ecx,BYTE PTR [rsi+rdx*1-0x4]
  219af0:	88 4c 17 fc          	mov    BYTE PTR [rdi+rdx*1-0x4],cl
  219af4:	0f b6 4c 16 fb       	movzx  ecx,BYTE PTR [rsi+rdx*1-0x5]
  219af9:	88 4c 17 fb          	mov    BYTE PTR [rdi+rdx*1-0x5],cl
  219afd:	0f b6 4c 16 fa       	movzx  ecx,BYTE PTR [rsi+rdx*1-0x6]
  219b02:	88 4c 17 fa          	mov    BYTE PTR [rdi+rdx*1-0x6],cl
  219b06:	0f b6 4c 16 f9       	movzx  ecx,BYTE PTR [rsi+rdx*1-0x7]
  219b0b:	88 4c 17 f9          	mov    BYTE PTR [rdi+rdx*1-0x7],cl
  219b0f:	0f b6 4c 16 f8       	movzx  ecx,BYTE PTR [rsi+rdx*1-0x8]
  219b14:	88 4c 17 f8          	mov    BYTE PTR [rdi+rdx*1-0x8],cl
        while (index != 0) {
  219b18:	48 83 c0 f8          	add    rax,0xfffffffffffffff8
  219b1c:	48 89 c2             	mov    rdx,rax
  219b1f:	75 af                	jne    219ad0 <memmove+0x350>
  219b21:	e9 7b 01 00 00       	jmp    219ca1 <memmove+0x521>
        while (index != n) : (index += 1) {
  219b26:	4d 8d 48 ff          	lea    r9,[r8-0x1]
  219b2a:	49 29 c9             	sub    r9,rcx
  219b2d:	31 c9                	xor    ecx,ecx
  219b2f:	90                   	nop
            dest.?[index] = src.?[index];
  219b30:	c5 fc 10 04 0e       	vmovups ymm0,YMMWORD PTR [rsi+rcx*1]
  219b35:	c5 fc 10 4c 0e 20    	vmovups ymm1,YMMWORD PTR [rsi+rcx*1+0x20]
  219b3b:	c5 fc 10 54 0e 40    	vmovups ymm2,YMMWORD PTR [rsi+rcx*1+0x40]
  219b41:	c5 fc 10 5c 0e 60    	vmovups ymm3,YMMWORD PTR [rsi+rcx*1+0x60]
  219b47:	c5 fc 11 04 0f       	vmovups YMMWORD PTR [rdi+rcx*1],ymm0
  219b4c:	c5 fc 11 4c 0f 20    	vmovups YMMWORD PTR [rdi+rcx*1+0x20],ymm1
  219b52:	c5 fc 11 54 0f 40    	vmovups YMMWORD PTR [rdi+rcx*1+0x40],ymm2
  219b58:	c5 fc 11 5c 0f 60    	vmovups YMMWORD PTR [rdi+rcx*1+0x60],ymm3
  219b5e:	c5 fc 10 84 0e 80 00 	vmovups ymm0,YMMWORD PTR [rsi+rcx*1+0x80]
  219b65:	00 00 
  219b67:	c5 fc 10 8c 0e a0 00 	vmovups ymm1,YMMWORD PTR [rsi+rcx*1+0xa0]
  219b6e:	00 00 
  219b70:	c5 fc 10 94 0e c0 00 	vmovups ymm2,YMMWORD PTR [rsi+rcx*1+0xc0]
  219b77:	00 00 
  219b79:	c5 fc 10 9c 0e e0 00 	vmovups ymm3,YMMWORD PTR [rsi+rcx*1+0xe0]
  219b80:	00 00 
  219b82:	c5 fc 11 84 0f 80 00 	vmovups YMMWORD PTR [rdi+rcx*1+0x80],ymm0
  219b89:	00 00 
  219b8b:	c5 fc 11 8c 0f a0 00 	vmovups YMMWORD PTR [rdi+rcx*1+0xa0],ymm1
  219b92:	00 00 
  219b94:	c5 fc 11 94 0f c0 00 	vmovups YMMWORD PTR [rdi+rcx*1+0xc0],ymm2
  219b9b:	00 00 
  219b9d:	c5 fc 11 9c 0f e0 00 	vmovups YMMWORD PTR [rdi+rcx*1+0xe0],ymm3
  219ba4:	00 00 
  219ba6:	c5 fc 10 84 0e 00 01 	vmovups ymm0,YMMWORD PTR [rsi+rcx*1+0x100]
  219bad:	00 00 
  219baf:	c5 fc 10 8c 0e 20 01 	vmovups ymm1,YMMWORD PTR [rsi+rcx*1+0x120]
  219bb6:	00 00 
  219bb8:	c5 fc 10 94 0e 40 01 	vmovups ymm2,YMMWORD PTR [rsi+rcx*1+0x140]
  219bbf:	00 00 
  219bc1:	c5 fc 10 9c 0e 60 01 	vmovups ymm3,YMMWORD PTR [rsi+rcx*1+0x160]
  219bc8:	00 00 
  219bca:	c5 fc 11 84 0f 00 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x100],ymm0
  219bd1:	00 00 
  219bd3:	c5 fc 11 8c 0f 20 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x120],ymm1
  219bda:	00 00 
  219bdc:	c5 fc 11 94 0f 40 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x140],ymm2
  219be3:	00 00 
  219be5:	c5 fc 11 9c 0f 60 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x160],ymm3
  219bec:	00 00 
  219bee:	c5 fc 10 84 0e 80 01 	vmovups ymm0,YMMWORD PTR [rsi+rcx*1+0x180]
  219bf5:	00 00 
  219bf7:	c5 fc 10 8c 0e a0 01 	vmovups ymm1,YMMWORD PTR [rsi+rcx*1+0x1a0]
  219bfe:	00 00 
  219c00:	c5 fc 10 94 0e c0 01 	vmovups ymm2,YMMWORD PTR [rsi+rcx*1+0x1c0]
  219c07:	00 00 
  219c09:	c5 fc 10 9c 0e e0 01 	vmovups ymm3,YMMWORD PTR [rsi+rcx*1+0x1e0]
  219c10:	00 00 
  219c12:	c5 fc 11 84 0f 80 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x180],ymm0
  219c19:	00 00 
  219c1b:	c5 fc 11 8c 0f a0 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x1a0],ymm1
  219c22:	00 00 
  219c24:	c5 fc 11 94 0f c0 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x1c0],ymm2
  219c2b:	00 00 
  219c2d:	c5 fc 11 9c 0f e0 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x1e0],ymm3
  219c34:	00 00 
        while (index != n) : (index += 1) {
  219c36:	48 81 c1 00 02 00 00 	add    rcx,0x200
  219c3d:	49 83 c1 04          	add    r9,0x4
  219c41:	0f 85 e9 fe ff ff    	jne    219b30 <memmove+0x3b0>
  219c47:	4d 85 c0             	test   r8,r8
  219c4a:	74 4c                	je     219c98 <memmove+0x518>
  219c4c:	48 83 c1 60          	add    rcx,0x60
  219c50:	49 f7 d8             	neg    r8
  219c53:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  219c5a:	84 00 00 00 00 00 
            dest.?[index] = src.?[index];
  219c60:	c5 fc 10 44 0e a0    	vmovups ymm0,YMMWORD PTR [rsi+rcx*1-0x60]
  219c66:	c5 fc 10 4c 0e c0    	vmovups ymm1,YMMWORD PTR [rsi+rcx*1-0x40]
  219c6c:	c5 fc 10 54 0e e0    	vmovups ymm2,YMMWORD PTR [rsi+rcx*1-0x20]
  219c72:	c5 fc 10 1c 0e       	vmovups ymm3,YMMWORD PTR [rsi+rcx*1]
  219c77:	c5 fc 11 44 0f a0    	vmovups YMMWORD PTR [rdi+rcx*1-0x60],ymm0
  219c7d:	c5 fc 11 4c 0f c0    	vmovups YMMWORD PTR [rdi+rcx*1-0x40],ymm1
  219c83:	c5 fc 11 54 0f e0    	vmovups YMMWORD PTR [rdi+rcx*1-0x20],ymm2
  219c89:	c5 fc 11 1c 0f       	vmovups YMMWORD PTR [rdi+rcx*1],ymm3
        while (index != n) : (index += 1) {
  219c8e:	48 83 e9 80          	sub    rcx,0xffffffffffffff80
  219c92:	49 83 c0 01          	add    r8,0x1
  219c96:	75 c8                	jne    219c60 <memmove+0x4e0>
  219c98:	49 39 d2             	cmp    r10,rdx
  219c9b:	0f 85 17 fb ff ff    	jne    2197b8 <memmove+0x38>
        }
    }

    return dest;
  219ca1:	48 89 f8             	mov    rax,rdi
  219ca4:	c5 f8 77             	vzeroupper 
  219ca7:	c3                   	ret    
  219ca8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  219caf:	00 

0000000000219cb0 <clone>:

// TODO we should be able to put this directly in std/linux/x86_64.zig but
// it causes a segfault in release mode. this is a workaround of calling it
// across .o file boundaries. fix comptime @ptrCast of nakedcc functions.
nakedcc fn clone() void {
    asm volatile (
  219cb0:	31 c0                	xor    eax,eax
  219cb2:	b0 38                	mov    al,0x38
  219cb4:	49 89 fb             	mov    r11,rdi
  219cb7:	48 89 d7             	mov    rdi,rdx
  219cba:	4c 89 c2             	mov    rdx,r8
  219cbd:	4d 89 c8             	mov    r8,r9
  219cc0:	4c 8b 54 24 08       	mov    r10,QWORD PTR [rsp+0x8]
  219cc5:	4d 89 d9             	mov    r9,r11
  219cc8:	48 83 e6 f0          	and    rsi,0xfffffffffffffff0
  219ccc:	48 83 ee 08          	sub    rsi,0x8
  219cd0:	48 89 0e             	mov    QWORD PTR [rsi],rcx
  219cd3:	0f 05                	syscall 
  219cd5:	85 c0                	test   eax,eax
  219cd7:	75 0f                	jne    219ce8 <clone+0x38>
  219cd9:	31 ed                	xor    ebp,ebp
  219cdb:	5f                   	pop    rdi
  219cdc:	41 ff d1             	call   r9
  219cdf:	89 c7                	mov    edi,eax
  219ce1:	31 c0                	xor    eax,eax
  219ce3:	b0 3c                	mov    al,0x3c
  219ce5:	0f 05                	syscall 
  219ce7:	f4                   	hlt    
  219ce8:	c3                   	ret    
nakedcc fn clone() void {
  219ce9:	c3                   	ret    
  219cea:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000219cf0 <fmodf>:
    const digits = if (T == f32) 23 else 52;
    const exp_bits = if (T == f32) 9 else 12;
    const bits_minus_1 = T.bit_count - 1;
    const mask = if (T == f32) 0xff else 0x7ff;
    var ux = @bitCast(uint, x);
    var uy = @bitCast(uint, y);
  219cf0:	c4 c1 79 7e c9       	vmovd  r9d,xmm1
    var ex = @intCast(i32, (ux >> digits) & mask);
    var ey = @intCast(i32, (uy >> digits) & mask);
    const sx = if (T == f32) @intCast(u32, ux & 0x80000000) else @intCast(i32, ux >> bits_minus_1);
    var i: uint = undefined;

    if (uy << 1 == 0 or isNan(uint, uy) or ex == mask)
  219cf5:	44 89 c8             	mov    eax,r9d
  219cf8:	01 c0                	add    eax,eax
  219cfa:	74 5a                	je     219d56 <fmodf+0x66>

fn isNan(comptime T: type, bits: T) bool {
    if (T == u16) {
        return (bits & 0x7fff) > 0x7c00;
    } else if (T == u32) {
        return (bits & 0x7fffffff) > 0x7f800000;
  219cfc:	44 89 c9             	mov    ecx,r9d
  219cff:	81 e1 ff ff ff 7f    	and    ecx,0x7fffffff
  219d05:	81 f9 00 00 80 7f    	cmp    ecx,0x7f800000
    if (uy << 1 == 0 or isNan(uint, uy) or ex == mask)
  219d0b:	77 49                	ja     219d56 <fmodf+0x66>
  219d0d:	c4 c1 79 7e c0       	vmovd  r8d,xmm0
  219d12:	ba 17 08 00 00       	mov    edx,0x817
  219d17:	c4 c2 68 f7 c8       	bextr  ecx,r8d,edx
  219d1c:	81 f9 ff 00 00 00    	cmp    ecx,0xff
  219d22:	74 32                	je     219d56 <fmodf+0x66>
    if (ux << 1 <= uy << 1) {
  219d24:	43 8d 34 00          	lea    esi,[r8+r8*1]
  219d28:	39 c6                	cmp    esi,eax
  219d2a:	76 33                	jbe    219d5f <fmodf+0x6f>
  219d2c:	c4 c2 68 f7 f9       	bextr  edi,r9d,edx
        ux &= @maxValue(uint) >> exp_bits;
  219d31:	44 89 c0             	mov    eax,r8d
    if (ex == 0) {
  219d34:	85 c9                	test   ecx,ecx
  219d36:	74 32                	je     219d6a <fmodf+0x7a>
        ux &= @maxValue(uint) >> exp_bits;
  219d38:	25 ff ff 7f 00       	and    eax,0x7fffff
        ux |= 1 << digits;
  219d3d:	0d 00 00 80 00       	or     eax,0x800000
    if (ey == 0) {
  219d42:	85 ff                	test   edi,edi
  219d44:	74 51                	je     219d97 <fmodf+0xa7>
        uy &= @maxValue(uint) >> exp_bits;
  219d46:	41 81 e1 ff ff 7f 00 	and    r9d,0x7fffff
        uy |= 1 << digits;
  219d4d:	41 81 c9 00 00 80 00 	or     r9d,0x800000
  219d54:	eb 7f                	jmp    219dd5 <fmodf+0xe5>
        return (x * y) / (x * y);
  219d56:	c5 fa 59 c1          	vmulss xmm0,xmm0,xmm1
  219d5a:	c5 fa 5e c0          	vdivss xmm0,xmm0,xmm0
    return generic_fmod(f32, x, y);
  219d5e:	c3                   	ret    
        if (ux << 1 == uy << 1)
  219d5f:	75 08                	jne    219d69 <fmodf+0x79>
  219d61:	c5 f1 ef c9          	vpxor  xmm1,xmm1,xmm1
  219d65:	c5 fa 59 c1          	vmulss xmm0,xmm0,xmm1
  219d69:	c3                   	ret    
  219d6a:	31 c9                	xor    ecx,ecx
        i = ux << exp_bits;
  219d6c:	c1 e0 09             	shl    eax,0x9
        while (i >> bits_minus_1 == 0) : (b: {
  219d6f:	78 16                	js     219d87 <fmodf+0x97>
  219d71:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  219d78:	0f 1f 84 00 00 00 00 
  219d7f:	00 
            ex -= 1;
  219d80:	83 c1 ff             	add    ecx,0xffffffff
            i <<= 1;
  219d83:	01 c0                	add    eax,eax
        while (i >> bits_minus_1 == 0) : (b: {
  219d85:	79 f9                	jns    219d80 <fmodf+0x90>
        ux <<= @intCast(log2uint, @bitCast(u32, -ex + 1));
  219d87:	b8 01 00 00 00       	mov    eax,0x1
  219d8c:	29 c8                	sub    eax,ecx
  219d8e:	c4 c2 79 f7 c0       	shlx   eax,r8d,eax
    if (ey == 0) {
  219d93:	85 ff                	test   edi,edi
  219d95:	75 af                	jne    219d46 <fmodf+0x56>
        i = uy << exp_bits;
  219d97:	44 89 ca             	mov    edx,r9d
  219d9a:	31 ff                	xor    edi,edi
  219d9c:	c1 e2 09             	shl    edx,0x9
        while (i >> bits_minus_1 == 0) : (b: {
  219d9f:	78 16                	js     219db7 <fmodf+0xc7>
  219da1:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  219da8:	0f 1f 84 00 00 00 00 
  219daf:	00 
            ey -= 1;
  219db0:	83 c7 ff             	add    edi,0xffffffff
            i <<= 1;
  219db3:	01 d2                	add    edx,edx
        while (i >> bits_minus_1 == 0) : (b: {
  219db5:	79 f9                	jns    219db0 <fmodf+0xc0>
        uy <<= @intCast(log2uint, @bitCast(u32, -ey + 1));
  219db7:	ba 01 00 00 00       	mov    edx,0x1
  219dbc:	29 fa                	sub    edx,edi
  219dbe:	c4 42 69 f7 c9       	shlx   r9d,r9d,edx
  219dc3:	eb 10                	jmp    219dd5 <fmodf+0xe5>
  219dc5:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  219dcc:	00 00 00 00 
        ux <<= 1;
  219dd0:	01 c0                	add    eax,eax
    while (ex > ey) : (ex -= 1) {
  219dd2:	83 c1 ff             	add    ecx,0xffffffff
  219dd5:	89 c6                	mov    esi,eax
  219dd7:	44 29 ce             	sub    esi,r9d
  219dda:	0f 99 c2             	setns  dl
  219ddd:	39 f9                	cmp    ecx,edi
  219ddf:	7e 0d                	jle    219dee <fmodf+0xfe>
        if (i >> bits_minus_1 == 0) {
  219de1:	f6 c2 01             	test   dl,0x1
  219de4:	74 ea                	je     219dd0 <fmodf+0xe0>
  219de6:	89 f0                	mov    eax,esi
            if (i == 0)
  219de8:	85 f6                	test   esi,esi
  219dea:	75 e4                	jne    219dd0 <fmodf+0xe0>
  219dec:	eb 3b                	jmp    219e29 <fmodf+0x139>
    if (i >> bits_minus_1 == 0) {
  219dee:	84 d2                	test   dl,dl
  219df0:	74 06                	je     219df8 <fmodf+0x108>
  219df2:	89 f0                	mov    eax,esi
        if (i == 0)
  219df4:	85 f6                	test   esi,esi
  219df6:	74 31                	je     219e29 <fmodf+0x139>
    while (ux >> digits == 0) : (b: {
  219df8:	3d ff ff 7f 00       	cmp    eax,0x7fffff
  219dfd:	77 0d                	ja     219e0c <fmodf+0x11c>
  219dff:	90                   	nop
        ux <<= 1;
  219e00:	01 c0                	add    eax,eax
        ex -= 1;
  219e02:	83 c1 ff             	add    ecx,0xffffffff
    while (ux >> digits == 0) : (b: {
  219e05:	3d 00 00 80 00       	cmp    eax,0x800000
  219e0a:	72 f4                	jb     219e00 <fmodf+0x110>
  219e0c:	41 81 e0 00 00 00 80 	and    r8d,0x80000000
    if (ex > 0) {
  219e13:	85 c9                	test   ecx,ecx
  219e15:	7e 1b                	jle    219e32 <fmodf+0x142>
        ux -%= 1 << digits;
  219e17:	05 00 00 80 ff       	add    eax,0xff800000
        ux |= uint(@bitCast(u32, ex)) << digits;
  219e1c:	c1 e1 17             	shl    ecx,0x17
  219e1f:	09 c1                	or     ecx,eax
        ux |= sx;
  219e21:	44 09 c1             	or     ecx,r8d
    return @bitCast(T, ux);
  219e24:	c5 f9 6e c1          	vmovd  xmm0,ecx
    return generic_fmod(f32, x, y);
  219e28:	c3                   	ret    
  219e29:	c5 f1 ef c9          	vpxor  xmm1,xmm1,xmm1
  219e2d:	c5 fa 59 c1          	vmulss xmm0,xmm0,xmm1
  219e31:	c3                   	ret    
        ux >>= @intCast(log2uint, @bitCast(u32, -ex + 1));
  219e32:	ba 01 00 00 00       	mov    edx,0x1
  219e37:	29 ca                	sub    edx,ecx
  219e39:	c4 e2 6b f7 c8       	shrx   ecx,eax,edx
        ux |= sx;
  219e3e:	44 09 c1             	or     ecx,r8d
    return @bitCast(T, ux);
  219e41:	c5 f9 6e c1          	vmovd  xmm0,ecx
    return generic_fmod(f32, x, y);
  219e45:	c3                   	ret    
  219e46:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  219e4d:	00 00 00 

0000000000219e50 <fmod>:
    var uy = @bitCast(uint, y);
  219e50:	c4 c1 f9 7e cb       	vmovq  r11,xmm1
    if (uy << 1 == 0 or isNan(uint, uy) or ex == mask)
  219e55:	4c 89 d8             	mov    rax,r11
  219e58:	48 01 c0             	add    rax,rax
  219e5b:	74 7a                	je     219ed7 <fmod+0x87>
  219e5d:	49 b9 ff ff ff ff ff 	movabs r9,0x7fffffffffffffff
  219e64:	ff ff 7f 
    } else if (T == u64) {
        return (bits & (@maxValue(u64) >> 1)) > (u64(0x7ff) << 52);
  219e67:	4c 89 d9             	mov    rcx,r11
  219e6a:	4c 21 c9             	and    rcx,r9
  219e6d:	48 ba 00 00 00 00 00 	movabs rdx,0x7ff0000000000000
  219e74:	00 f0 7f 
  219e77:	48 39 d1             	cmp    rcx,rdx
    if (uy << 1 == 0 or isNan(uint, uy) or ex == mask)
  219e7a:	77 5b                	ja     219ed7 <fmod+0x87>
  219e7c:	c4 c1 f9 7e c2       	vmovq  r10,xmm0
  219e81:	4c 89 d1             	mov    rcx,r10
  219e84:	48 c1 e9 34          	shr    rcx,0x34
  219e88:	81 e1 ff 07 00 00    	and    ecx,0x7ff
  219e8e:	81 f9 ff 07 00 00    	cmp    ecx,0x7ff
  219e94:	74 41                	je     219ed7 <fmod+0x87>
    if (ux << 1 <= uy << 1) {
  219e96:	4b 8d 14 12          	lea    rdx,[r10+r10*1]
  219e9a:	48 39 c2             	cmp    rdx,rax
  219e9d:	76 41                	jbe    219ee0 <fmod+0x90>
  219e9f:	4c 89 df             	mov    rdi,r11
  219ea2:	48 c1 ef 34          	shr    rdi,0x34
  219ea6:	81 e7 ff 07 00 00    	and    edi,0x7ff
  219eac:	49 b8 00 00 00 00 00 	movabs r8,0x10000000000000
  219eb3:	00 10 00 
    if (ex == 0) {
  219eb6:	85 c9                	test   ecx,ecx
  219eb8:	74 31                	je     219eeb <fmod+0x9b>
        ux &= @maxValue(uint) >> exp_bits;
  219eba:	49 8d 40 ff          	lea    rax,[r8-0x1]
  219ebe:	4c 21 d0             	and    rax,r10
        ux |= 1 << digits;
  219ec1:	4c 09 c0             	or     rax,r8
    if (ey == 0) {
  219ec4:	85 ff                	test   edi,edi
  219ec6:	74 50                	je     219f18 <fmod+0xc8>
        uy &= @maxValue(uint) >> exp_bits;
  219ec8:	49 8d 50 ff          	lea    rdx,[r8-0x1]
  219ecc:	49 21 d3             	and    r11,rdx
        uy |= 1 << digits;
  219ecf:	4d 09 c3             	or     r11,r8
  219ed2:	e9 7f 00 00 00       	jmp    219f56 <fmod+0x106>
        return (x * y) / (x * y);
  219ed7:	c5 fb 59 c1          	vmulsd xmm0,xmm0,xmm1
  219edb:	c5 fb 5e c0          	vdivsd xmm0,xmm0,xmm0
    return generic_fmod(f64, x, y);
  219edf:	c3                   	ret    
        if (ux << 1 == uy << 1)
  219ee0:	75 08                	jne    219eea <fmod+0x9a>
  219ee2:	c5 f1 ef c9          	vpxor  xmm1,xmm1,xmm1
  219ee6:	c5 fb 59 c1          	vmulsd xmm0,xmm0,xmm1
  219eea:	c3                   	ret    
        i = ux << exp_bits;
  219eeb:	4c 89 d0             	mov    rax,r10
  219eee:	31 c9                	xor    ecx,ecx
  219ef0:	48 c1 e0 0c          	shl    rax,0xc
        while (i >> bits_minus_1 == 0) : (b: {
  219ef4:	78 12                	js     219f08 <fmod+0xb8>
  219ef6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  219efd:	00 00 00 
            ex -= 1;
  219f00:	83 c1 ff             	add    ecx,0xffffffff
            i <<= 1;
  219f03:	48 01 c0             	add    rax,rax
        while (i >> bits_minus_1 == 0) : (b: {
  219f06:	79 f8                	jns    219f00 <fmod+0xb0>
        ux <<= @intCast(log2uint, @bitCast(u32, -ex + 1));
  219f08:	b8 01 00 00 00       	mov    eax,0x1
  219f0d:	29 c8                	sub    eax,ecx
  219f0f:	c4 c2 f9 f7 c2       	shlx   rax,r10,rax
    if (ey == 0) {
  219f14:	85 ff                	test   edi,edi
  219f16:	75 b0                	jne    219ec8 <fmod+0x78>
        i = uy << exp_bits;
  219f18:	4c 89 da             	mov    rdx,r11
  219f1b:	31 ff                	xor    edi,edi
  219f1d:	48 c1 e2 0c          	shl    rdx,0xc
        while (i >> bits_minus_1 == 0) : (b: {
  219f21:	78 15                	js     219f38 <fmod+0xe8>
  219f23:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  219f2a:	84 00 00 00 00 00 
            ey -= 1;
  219f30:	83 c7 ff             	add    edi,0xffffffff
            i <<= 1;
  219f33:	48 01 d2             	add    rdx,rdx
        while (i >> bits_minus_1 == 0) : (b: {
  219f36:	79 f8                	jns    219f30 <fmod+0xe0>
        uy <<= @intCast(log2uint, @bitCast(u32, -ey + 1));
  219f38:	ba 01 00 00 00       	mov    edx,0x1
  219f3d:	29 fa                	sub    edx,edi
  219f3f:	c4 42 e9 f7 db       	shlx   r11,r11,rdx
  219f44:	eb 10                	jmp    219f56 <fmod+0x106>
  219f46:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  219f4d:	00 00 00 
        ux <<= 1;
  219f50:	48 01 c0             	add    rax,rax
    while (ex > ey) : (ex -= 1) {
  219f53:	83 c1 ff             	add    ecx,0xffffffff
  219f56:	48 89 c6             	mov    rsi,rax
  219f59:	4c 29 de             	sub    rsi,r11
  219f5c:	0f 99 c2             	setns  dl
  219f5f:	39 f9                	cmp    ecx,edi
  219f61:	7e 0f                	jle    219f72 <fmod+0x122>
        if (i >> bits_minus_1 == 0) {
  219f63:	f6 c2 01             	test   dl,0x1
  219f66:	74 e8                	je     219f50 <fmod+0x100>
  219f68:	48 89 f0             	mov    rax,rsi
            if (i == 0)
  219f6b:	48 85 f6             	test   rsi,rsi
  219f6e:	75 e0                	jne    219f50 <fmod+0x100>
  219f70:	eb 4d                	jmp    219fbf <fmod+0x16f>
    if (i >> bits_minus_1 == 0) {
  219f72:	84 d2                	test   dl,dl
  219f74:	74 08                	je     219f7e <fmod+0x12e>
  219f76:	48 89 f0             	mov    rax,rsi
        if (i == 0)
  219f79:	48 85 f6             	test   rsi,rsi
  219f7c:	74 41                	je     219fbf <fmod+0x16f>
  219f7e:	49 83 c1 01          	add    r9,0x1
    while (ux >> digits == 0) : (b: {
  219f82:	4c 39 c0             	cmp    rax,r8
  219f85:	73 14                	jae    219f9b <fmod+0x14b>
  219f87:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  219f8e:	00 00 
        ux <<= 1;
  219f90:	48 01 c0             	add    rax,rax
        ex -= 1;
  219f93:	83 c1 ff             	add    ecx,0xffffffff
    while (ux >> digits == 0) : (b: {
  219f96:	4c 39 c0             	cmp    rax,r8
  219f99:	72 f5                	jb     219f90 <fmod+0x140>
  219f9b:	4d 21 ca             	and    r10,r9
    if (ex > 0) {
  219f9e:	85 c9                	test   ecx,ecx
  219fa0:	7e 26                	jle    219fc8 <fmod+0x178>
        ux -%= 1 << digits;
  219fa2:	48 ba 00 00 00 00 00 	movabs rdx,0xfff0000000000000
  219fa9:	00 f0 ff 
  219fac:	48 01 d0             	add    rax,rdx
        ux |= uint(@bitCast(u32, ex)) << digits;
  219faf:	48 c1 e1 34          	shl    rcx,0x34
  219fb3:	48 09 c1             	or     rcx,rax
        ux |= @intCast(uint, sx) << bits_minus_1;
  219fb6:	4c 09 d1             	or     rcx,r10
    return @bitCast(T, ux);
  219fb9:	c4 e1 f9 6e c1       	vmovq  xmm0,rcx
    return generic_fmod(f64, x, y);
  219fbe:	c3                   	ret    
  219fbf:	c5 f1 ef c9          	vpxor  xmm1,xmm1,xmm1
  219fc3:	c5 fb 59 c1          	vmulsd xmm0,xmm0,xmm1
  219fc7:	c3                   	ret    
        ux >>= @intCast(log2uint, @bitCast(u32, -ex + 1));
  219fc8:	ba 01 00 00 00       	mov    edx,0x1
  219fcd:	29 ca                	sub    edx,ecx
  219fcf:	c4 e2 eb f7 c8       	shrx   rcx,rax,rdx
        ux |= @intCast(uint, sx) << bits_minus_1;
  219fd4:	4c 09 d1             	or     rcx,r10
    return @bitCast(T, ux);
  219fd7:	c4 e1 f9 6e c1       	vmovq  xmm0,rcx
    return generic_fmod(f64, x, y);
  219fdc:	c3                   	ret    
  219fdd:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000219fe0 <floorf>:
    if (x == 0.0) {
  219fe0:	c5 f0 57 c9          	vxorps xmm1,xmm1,xmm1
  219fe4:	c5 f8 2e c1          	vucomiss xmm0,xmm1
  219fe8:	75 02                	jne    219fec <floorf+0xc>
  219fea:	7b 57                	jnp    21a043 <floorf+0x63>
  219fec:	c5 f9 7e c1          	vmovd  ecx,xmm0
  219ff0:	89 c8                	mov    eax,ecx
  219ff2:	c1 e8 17             	shr    eax,0x17
  219ff5:	0f b6 d0             	movzx  edx,al
  219ff8:	81 fa 95 00 00 00    	cmp    edx,0x95
  219ffe:	77 43                	ja     21a043 <floorf+0x63>
    if (e >= 0) {
  21a000:	83 fa 7f             	cmp    edx,0x7f
  21a003:	72 2e                	jb     21a033 <floorf+0x53>
  21a005:	83 c0 01             	add    eax,0x1
        m = u32(0x007FFFFF) >> @intCast(u5, e);
  21a008:	83 e0 1f             	and    eax,0x1f
  21a00b:	ba ff ff 7f 00       	mov    edx,0x7fffff
  21a010:	c4 e2 7b f7 d2       	shrx   edx,edx,eax
        if (u & m == 0) {
  21a015:	85 ca                	test   edx,ecx
  21a017:	74 2a                	je     21a043 <floorf+0x63>
        if (u >> 31 != 0) {
  21a019:	89 ce                	mov    esi,ecx
  21a01b:	c1 fe 1f             	sar    esi,0x1f
  21a01e:	21 d6                	and    esi,edx
  21a020:	01 ce                	add    esi,ecx
        return @bitCast(f32, u & ~m);
  21a022:	b9 00 00 80 ff       	mov    ecx,0xff800000
  21a027:	c4 e2 7a f7 c1       	sarx   eax,ecx,eax
  21a02c:	21 f0                	and    eax,esi
  21a02e:	c5 f9 6e c0          	vmovd  xmm0,eax
    return math.floor(x);
  21a032:	c3                   	ret    
        if (u >> 31 == 0) {
  21a033:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  21a037:	85 c9                	test   ecx,ecx
  21a039:	79 08                	jns    21a043 <floorf+0x63>
  21a03b:	c5 f9 6e 05 81 d4 fe 	vmovd  xmm0,DWORD PTR [rip+0xfffffffffffed481]        # 2074c4 <__unnamed_44+0x14>
  21a042:	ff 
  21a043:	c3                   	ret    
  21a044:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21a04b:	00 00 00 00 00 

000000000021a050 <ceilf>:
    var u = @bitCast(u32, x);
    var e = @intCast(i32, (u >> 23) & 0xFF) - 0x7F;
    var m: u32 = undefined;

    // TODO: Shouldn't need this explicit check.
    if (x == 0.0) {
  21a050:	c5 f0 57 c9          	vxorps xmm1,xmm1,xmm1
  21a054:	c5 f8 2e c1          	vucomiss xmm0,xmm1
  21a058:	75 02                	jne    21a05c <ceilf+0xc>
  21a05a:	7b 5a                	jnp    21a0b6 <ceilf+0x66>
  21a05c:	c5 f9 7e c1          	vmovd  ecx,xmm0
  21a060:	89 c8                	mov    eax,ecx
  21a062:	c1 e8 17             	shr    eax,0x17
  21a065:	0f b6 d0             	movzx  edx,al
  21a068:	81 fa 95 00 00 00    	cmp    edx,0x95
  21a06e:	77 46                	ja     21a0b6 <ceilf+0x66>
        return x;
    }

    if (e >= 23) {
        return x;
    } else if (e >= 0) {
  21a070:	83 fa 7f             	cmp    edx,0x7f
  21a073:	72 31                	jb     21a0a6 <ceilf+0x56>
  21a075:	83 c0 01             	add    eax,0x1
        m = u32(0x007FFFFF) >> @intCast(u5, e);
  21a078:	83 e0 1f             	and    eax,0x1f
  21a07b:	ba ff ff 7f 00       	mov    edx,0x7fffff
  21a080:	c4 e2 7b f7 d2       	shrx   edx,edx,eax
        if (u & m == 0) {
  21a085:	85 ca                	test   edx,ecx
  21a087:	74 2d                	je     21a0b6 <ceilf+0x66>
            return x;
        }
        math.forceEval(x + 0x1.0p120);
        if (u >> 31 == 0) {
  21a089:	89 ce                	mov    esi,ecx
  21a08b:	c1 fe 1f             	sar    esi,0x1f
  21a08e:	c4 e2 48 f2 d2       	andn   edx,esi,edx
  21a093:	01 ca                	add    edx,ecx
            u += m;
        }
        u &= ~m;
  21a095:	b9 00 00 80 ff       	mov    ecx,0xff800000
  21a09a:	c4 e2 7a f7 c1       	sarx   eax,ecx,eax
  21a09f:	21 d0                	and    eax,edx
        return @bitCast(f32, u);
  21a0a1:	c5 f9 6e c0          	vmovd  xmm0,eax
    return math.ceil(x);
  21a0a5:	c3                   	ret    
    } else {
        math.forceEval(x + 0x1.0p120);
        if (u >> 31 != 0) {
  21a0a6:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  21a0aa:	85 c9                	test   ecx,ecx
  21a0ac:	78 08                	js     21a0b6 <ceilf+0x66>
  21a0ae:	c5 f9 6e 05 0a d4 fe 	vmovd  xmm0,DWORD PTR [rip+0xfffffffffffed40a]        # 2074c0 <__unnamed_44+0x10>
  21a0b5:	ff 
  21a0b6:	c3                   	ret    
  21a0b7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  21a0be:	00 00 

000000000021a0c0 <floor>:
    if (e >= 0x3FF + 52 or x == 0) {
  21a0c0:	c5 f1 57 c9          	vxorpd xmm1,xmm1,xmm1
  21a0c4:	c5 f9 2e c1          	vucomisd xmm0,xmm1
  21a0c8:	75 02                	jne    21a0cc <floor+0xc>
  21a0ca:	7b 58                	jnp    21a124 <floor+0x64>
  21a0cc:	c4 e1 f9 7e c0       	vmovq  rax,xmm0
  21a0d1:	b9 34 0b 00 00       	mov    ecx,0xb34
  21a0d6:	c4 e2 f0 f7 c8       	bextr  rcx,rax,rcx
  21a0db:	48 81 f9 32 04 00 00 	cmp    rcx,0x432
  21a0e2:	77 40                	ja     21a124 <floor+0x64>
        y = x - math.f64_toint + math.f64_toint - x;
  21a0e4:	c5 fb 10 0d 4c 61 fe 	vmovsd xmm1,QWORD PTR [rip+0xfffffffffffe614c]        # 200238 <__unnamed_90+0x58>
  21a0eb:	ff 
  21a0ec:	c5 fb 10 15 7c 61 fe 	vmovsd xmm2,QWORD PTR [rip+0xfffffffffffe617c]        # 200270 <__unnamed_90+0x90>
  21a0f3:	ff 
    if (u >> 63 != 0) {
  21a0f4:	48 85 c0             	test   rax,rax
  21a0f7:	78 2c                	js     21a125 <floor+0x65>
  21a0f9:	c5 fb 58 d2          	vaddsd xmm2,xmm0,xmm2
  21a0fd:	c5 eb 58 c9          	vaddsd xmm1,xmm2,xmm1
    if (e <= 0x3FF - 1) {
  21a101:	48 81 f9 fe 03 00 00 	cmp    rcx,0x3fe
  21a108:	76 2c                	jbe    21a136 <floor+0x76>
  21a10a:	c5 f3 5c c8          	vsubsd xmm1,xmm1,xmm0
    } else if (y > 0) {
  21a10e:	c5 e9 57 d2          	vxorpd xmm2,xmm2,xmm2
  21a112:	c5 f9 2e ca          	vucomisd xmm1,xmm2
  21a116:	c5 f3 58 c0          	vaddsd xmm0,xmm1,xmm0
  21a11a:	76 08                	jbe    21a124 <floor+0x64>
        return x + y - 1;
  21a11c:	c5 fb 58 05 2c 61 fe 	vaddsd xmm0,xmm0,QWORD PTR [rip+0xfffffffffffe612c]        # 200250 <__unnamed_90+0x70>
  21a123:	ff 
    return math.floor(x);
  21a124:	c3                   	ret    
  21a125:	c5 fb 58 c9          	vaddsd xmm1,xmm0,xmm1
  21a129:	c5 f3 58 ca          	vaddsd xmm1,xmm1,xmm2
    if (e <= 0x3FF - 1) {
  21a12d:	48 81 f9 fe 03 00 00 	cmp    rcx,0x3fe
  21a134:	77 d4                	ja     21a10a <floor+0x4a>
    if (u >> 63 != 0) {
  21a136:	48 85 c0             	test   rax,rax
        if (u >> 63 != 0) {
  21a139:	78 05                	js     21a140 <floor+0x80>
  21a13b:	c5 f9 57 c0          	vxorpd xmm0,xmm0,xmm0
  21a13f:	c3                   	ret    
  21a140:	c5 fb 10 05 08 61 fe 	vmovsd xmm0,QWORD PTR [rip+0xfffffffffffe6108]        # 200250 <__unnamed_90+0x70>
  21a147:	ff 
  21a148:	c3                   	ret    
  21a149:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

000000000021a150 <ceil>:
fn ceil64(x: f64) f64 {
    const u = @bitCast(u64, x);
    const e = (u >> 52) & 0x7FF;
    var y: f64 = undefined;

    if (e >= 0x3FF + 52 or x == 0) {
  21a150:	c5 f1 57 c9          	vxorpd xmm1,xmm1,xmm1
  21a154:	c5 f9 2e c1          	vucomisd xmm0,xmm1
  21a158:	75 02                	jne    21a15c <ceil+0xc>
  21a15a:	7b 7d                	jnp    21a1d9 <ceil+0x89>
  21a15c:	c4 e1 f9 7e c0       	vmovq  rax,xmm0
  21a161:	b9 34 0b 00 00       	mov    ecx,0xb34
  21a166:	c4 e2 f0 f7 c8       	bextr  rcx,rax,rcx
  21a16b:	48 81 f9 32 04 00 00 	cmp    rcx,0x432
  21a172:	77 65                	ja     21a1d9 <ceil+0x89>
        return x;
    }

    if (u >> 63 != 0) {
        y = x - math.f64_toint + math.f64_toint - x;
  21a174:	c5 fb 10 0d bc 60 fe 	vmovsd xmm1,QWORD PTR [rip+0xfffffffffffe60bc]        # 200238 <__unnamed_90+0x58>
  21a17b:	ff 
  21a17c:	c5 fb 10 15 ec 60 fe 	vmovsd xmm2,QWORD PTR [rip+0xfffffffffffe60ec]        # 200270 <__unnamed_90+0x90>
  21a183:	ff 
    if (u >> 63 != 0) {
  21a184:	48 85 c0             	test   rax,rax
  21a187:	78 2d                	js     21a1b6 <ceil+0x66>
  21a189:	c5 fb 58 d2          	vaddsd xmm2,xmm0,xmm2
  21a18d:	c5 eb 58 c9          	vaddsd xmm1,xmm2,xmm1
    } else {
        y = x + math.f64_toint - math.f64_toint - x;
    }

    if (e <= 0x3FF - 1) {
  21a191:	48 81 f9 fe 03 00 00 	cmp    rcx,0x3fe
  21a198:	76 2d                	jbe    21a1c7 <ceil+0x77>
  21a19a:	c5 f3 5c c8          	vsubsd xmm1,xmm1,xmm0
        if (u >> 63 != 0) {
            return -0.0;
        } else {
            return 1.0;
        }
    } else if (y < 0) {
  21a19e:	c5 e9 57 d2          	vxorpd xmm2,xmm2,xmm2
  21a1a2:	c5 f9 2e d1          	vucomisd xmm2,xmm1
  21a1a6:	c5 f3 58 c0          	vaddsd xmm0,xmm1,xmm0
  21a1aa:	76 2d                	jbe    21a1d9 <ceil+0x89>
        return x + y + 1;
  21a1ac:	c5 fb 58 05 74 60 fe 	vaddsd xmm0,xmm0,QWORD PTR [rip+0xfffffffffffe6074]        # 200228 <__unnamed_90+0x48>
  21a1b3:	ff 
  21a1b4:	eb 23                	jmp    21a1d9 <ceil+0x89>
  21a1b6:	c5 fb 58 c9          	vaddsd xmm1,xmm0,xmm1
  21a1ba:	c5 f3 58 ca          	vaddsd xmm1,xmm1,xmm2
    if (e <= 0x3FF - 1) {
  21a1be:	48 81 f9 fe 03 00 00 	cmp    rcx,0x3fe
  21a1c5:	77 d3                	ja     21a19a <ceil+0x4a>
        if (u >> 63 != 0) {
  21a1c7:	c5 f9 57 c0          	vxorpd xmm0,xmm0,xmm0
    if (u >> 63 != 0) {
  21a1cb:	48 85 c0             	test   rax,rax
        if (u >> 63 != 0) {
  21a1ce:	78 09                	js     21a1d9 <ceil+0x89>
  21a1d0:	c5 fb 10 05 50 60 fe 	vmovsd xmm0,QWORD PTR [rip+0xfffffffffffe6050]        # 200228 <__unnamed_90+0x48>
  21a1d7:	ff 
    return math.ceil(x);
  21a1d8:	c3                   	ret    
  21a1d9:	c3                   	ret    
  21a1da:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

000000000021a1e0 <sqrt>:
// behaviour. Most intermediate i32 values are changed to u32 where appropriate but there are
// potentially some edge cases remaining that are not handled in the same way.
export fn sqrt(x: f64) f64 {
    const tiny: f64 = 1.0e-300;
    const sign: u32 = 0x80000000;
    const u = @bitCast(u64, x);
  21a1e0:	c4 e1 f9 7e c0       	vmovq  rax,xmm0

    var ix0 = @intCast(u32, u >> 32);
  21a1e5:	48 89 c7             	mov    rdi,rax
  21a1e8:	48 c1 ef 20          	shr    rdi,0x20
    var ix1 = @intCast(u32, u & 0xFFFFFFFF);

    // sqrt(nan) = nan, sqrt(+inf) = +inf, sqrt(-inf) = nan
    if (ix0 & 0x7FF00000 == 0x7FF00000) {
  21a1ec:	b9 00 00 f0 7f       	mov    ecx,0x7ff00000
  21a1f1:	c4 e2 40 f2 c9       	andn   ecx,edi,ecx
  21a1f6:	75 09                	jne    21a201 <sqrt+0x21>
        return x * x + x;
  21a1f8:	c5 fb 59 c8          	vmulsd xmm1,xmm0,xmm0
  21a1fc:	c5 f3 58 c0          	vaddsd xmm0,xmm1,xmm0
  21a200:	c3                   	ret    
    }

    // sqrt(+-0) = +-0
    if (x == 0.0) {
  21a201:	c5 f0 57 c9          	vxorps xmm1,xmm1,xmm1
  21a205:	c5 f9 2e c1          	vucomisd xmm0,xmm1
  21a209:	75 03                	jne    21a20e <sqrt+0x2e>
  21a20b:	7a 01                	jp     21a20e <sqrt+0x2e>
        return x;
  21a20d:	c3                   	ret    
    }
    // sqrt(-ve) = snan
    if (ix0 & sign != 0) {
  21a20e:	85 ff                	test   edi,edi
  21a210:	0f 88 cf 00 00 00    	js     21a2e5 <sqrt+0x105>
        return math.snan(f64);
    }

    // normalize x
    var m = @intCast(i32, ix0 >> 20);
  21a216:	49 89 c0             	mov    r8,rax
  21a219:	49 c1 e8 34          	shr    r8,0x34
    if (m == 0) {
  21a21d:	45 85 c0             	test   r8d,r8d
  21a220:	75 5b                	jne    21a27d <sqrt+0x9d>
  21a222:	31 d2                	xor    edx,edx
  21a224:	31 c9                	xor    ecx,ecx
        // subnormal
        while (ix0 == 0) {
  21a226:	85 ff                	test   edi,edi
  21a228:	75 15                	jne    21a23f <sqrt+0x5f>
  21a22a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
            m -= 21;
  21a230:	83 c1 eb             	add    ecx,0xffffffeb
            ix0 |= ix1 >> 11;
  21a233:	89 c7                	mov    edi,eax
  21a235:	c1 ef 0b             	shr    edi,0xb
            ix1 <<= 21;
  21a238:	c1 e0 15             	shl    eax,0x15
        while (ix0 == 0) {
  21a23b:	85 ff                	test   edi,edi
  21a23d:	74 f1                	je     21a230 <sqrt+0x50>
  21a23f:	31 f6                	xor    esi,esi
        }

        // subnormal
        var i: u32 = 0;
        while (ix0 & 0x00100000 == 0) : (i += 1) {
  21a241:	0f ba e7 14          	bt     edi,0x14
  21a245:	72 20                	jb     21a267 <sqrt+0x87>
  21a247:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  21a24e:	00 00 
  21a250:	89 fa                	mov    edx,edi
            ix0 <<= 1;
  21a252:	8d 3c 12             	lea    edi,[rdx+rdx*1]
        while (ix0 & 0x00100000 == 0) : (i += 1) {
  21a255:	83 c6 ff             	add    esi,0xffffffff
  21a258:	f7 c2 00 00 08 00    	test   edx,0x80000
  21a25e:	74 f0                	je     21a250 <sqrt+0x70>
  21a260:	89 f2                	mov    edx,esi
  21a262:	f7 da                	neg    edx
  21a264:	83 e2 1f             	and    edx,0x1f
        }
        m -= @intCast(i32, i) - 1;
  21a267:	44 8d 04 31          	lea    r8d,[rcx+rsi*1]
  21a26b:	41 83 c0 01          	add    r8d,0x1
        ix0 |= ix1 >> @intCast(u5, 32 - i);
  21a26f:	c4 e2 4b f7 c8       	shrx   ecx,eax,esi
  21a274:	09 f9                	or     ecx,edi
        ix1 <<= @intCast(u5, i);
  21a276:	c4 e2 69 f7 c0       	shlx   eax,eax,edx
  21a27b:	89 cf                	mov    edi,ecx
    }

    // unbias exponent
    m -= 1023;
  21a27d:	41 81 c0 01 fc ff ff 	add    r8d,0xfffffc01
    ix0 = (ix0 & 0x000FFFFF) | 0x00100000;
  21a284:	81 e7 ff ff 0f 00    	and    edi,0xfffff
  21a28a:	81 cf 00 00 10 00    	or     edi,0x100000
    if (m & 1 != 0) {
  21a290:	41 f6 c0 01          	test   r8b,0x1
  21a294:	74 06                	je     21a29c <sqrt+0xbc>
        ix0 += ix0 + (ix1 >> 31);
  21a296:	0f a4 c7 01          	shld   edi,eax,0x1
        ix1 = ix1 +% ix1;
  21a29a:	01 c0                	add    eax,eax
    }
    m >>= 1;

    // sqrt(x) bit by bit
    ix0 += ix0 + (ix1 >> 31);
  21a29c:	0f a4 c7 01          	shld   edi,eax,0x1
    var t: u32 = undefined;
    var t1: u32 = undefined;

    while (r != 0) {
        t = s0 +% r;
        if (t <= ix0) {
  21a2a0:	31 f6                	xor    esi,esi
  21a2a2:	81 ff ff ff 1f 00    	cmp    edi,0x1fffff
  21a2a8:	40 0f 97 c6          	seta   sil
  21a2ac:	41 89 f1             	mov    r9d,esi
  21a2af:	41 c1 e1 15          	shl    r9d,0x15
  21a2b3:	c1 e6 16             	shl    esi,0x16
            s0 = t + r;
            ix0 -= t;
            q += r;
        }
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  21a2b6:	8d 0c 3f             	lea    ecx,[rdi+rdi*1]
        if (t <= ix0) {
  21a2b9:	81 ff 00 00 20 00    	cmp    edi,0x200000
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  21a2bf:	8d bc 3f 00 00 c0 ff 	lea    edi,[rdi+rdi*1-0x400000]
  21a2c6:	0f 42 f9             	cmovb  edi,ecx
  21a2c9:	b9 1e 01 00 00       	mov    ecx,0x11e
  21a2ce:	c4 e2 70 f7 d0       	bextr  edx,eax,ecx
  21a2d3:	09 fa                	or     edx,edi
        t = s0 +% r;
  21a2d5:	8d be 00 00 10 00    	lea    edi,[rsi+0x100000]
        if (t <= ix0) {
  21a2db:	89 d1                	mov    ecx,edx
  21a2dd:	29 f9                	sub    ecx,edi
  21a2df:	73 0d                	jae    21a2ee <sqrt+0x10e>
  21a2e1:	89 d1                	mov    ecx,edx
  21a2e3:	eb 18                	jmp    21a2fd <sqrt+0x11d>
  21a2e5:	c5 fb 10 05 c3 5f fe 	vmovsd xmm0,QWORD PTR [rip+0xfffffffffffe5fc3]        # 2002b0 <app_mask+0x30>
  21a2ec:	ff 
        return x;
  21a2ed:	c3                   	ret    
            s0 = t + r;
  21a2ee:	81 c7 00 00 10 00    	add    edi,0x100000
            q += r;
  21a2f4:	41 81 c9 00 00 10 00 	or     r9d,0x100000
  21a2fb:	89 fe                	mov    esi,edi
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  21a2fd:	ba 1d 01 00 00       	mov    edx,0x11d
  21a302:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  21a307:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  21a30a:	8d be 00 00 08 00    	lea    edi,[rsi+0x80000]
        if (t <= ix0) {
  21a310:	89 d1                	mov    ecx,edx
  21a312:	29 f9                	sub    ecx,edi
  21a314:	73 04                	jae    21a31a <sqrt+0x13a>
  21a316:	89 d1                	mov    ecx,edx
  21a318:	eb 0d                	jmp    21a327 <sqrt+0x147>
            s0 = t + r;
  21a31a:	81 c6 00 00 10 00    	add    esi,0x100000
            q += r;
  21a320:	41 81 c1 00 00 08 00 	add    r9d,0x80000
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  21a327:	ba 1c 01 00 00       	mov    edx,0x11c
  21a32c:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  21a331:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  21a334:	8d be 00 00 04 00    	lea    edi,[rsi+0x40000]
        if (t <= ix0) {
  21a33a:	89 d1                	mov    ecx,edx
  21a33c:	29 f9                	sub    ecx,edi
  21a33e:	73 04                	jae    21a344 <sqrt+0x164>
  21a340:	89 d1                	mov    ecx,edx
  21a342:	eb 0d                	jmp    21a351 <sqrt+0x171>
            s0 = t + r;
  21a344:	81 c6 00 00 08 00    	add    esi,0x80000
            q += r;
  21a34a:	41 81 c1 00 00 04 00 	add    r9d,0x40000
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  21a351:	ba 1b 01 00 00       	mov    edx,0x11b
  21a356:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  21a35b:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  21a35e:	8d be 00 00 02 00    	lea    edi,[rsi+0x20000]
        if (t <= ix0) {
  21a364:	89 d1                	mov    ecx,edx
  21a366:	29 f9                	sub    ecx,edi
  21a368:	73 04                	jae    21a36e <sqrt+0x18e>
  21a36a:	89 d1                	mov    ecx,edx
  21a36c:	eb 0d                	jmp    21a37b <sqrt+0x19b>
            s0 = t + r;
  21a36e:	81 c6 00 00 04 00    	add    esi,0x40000
            q += r;
  21a374:	41 81 c1 00 00 02 00 	add    r9d,0x20000
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  21a37b:	ba 1a 01 00 00       	mov    edx,0x11a
  21a380:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  21a385:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  21a388:	8d be 00 00 01 00    	lea    edi,[rsi+0x10000]
        if (t <= ix0) {
  21a38e:	89 d1                	mov    ecx,edx
  21a390:	29 f9                	sub    ecx,edi
  21a392:	73 04                	jae    21a398 <sqrt+0x1b8>
  21a394:	89 d1                	mov    ecx,edx
  21a396:	eb 0d                	jmp    21a3a5 <sqrt+0x1c5>
            s0 = t + r;
  21a398:	81 c6 00 00 02 00    	add    esi,0x20000
            q += r;
  21a39e:	41 81 c1 00 00 01 00 	add    r9d,0x10000
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  21a3a5:	ba 19 01 00 00       	mov    edx,0x119
  21a3aa:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  21a3af:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  21a3b2:	8d be 00 80 00 00    	lea    edi,[rsi+0x8000]
        if (t <= ix0) {
  21a3b8:	89 d1                	mov    ecx,edx
  21a3ba:	29 f9                	sub    ecx,edi
  21a3bc:	73 04                	jae    21a3c2 <sqrt+0x1e2>
  21a3be:	89 d1                	mov    ecx,edx
  21a3c0:	eb 0d                	jmp    21a3cf <sqrt+0x1ef>
            s0 = t + r;
  21a3c2:	81 c6 00 00 01 00    	add    esi,0x10000
            q += r;
  21a3c8:	41 81 c1 00 80 00 00 	add    r9d,0x8000
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  21a3cf:	ba 18 01 00 00       	mov    edx,0x118
  21a3d4:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  21a3d9:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  21a3dc:	8d be 00 40 00 00    	lea    edi,[rsi+0x4000]
        if (t <= ix0) {
  21a3e2:	89 d1                	mov    ecx,edx
  21a3e4:	29 f9                	sub    ecx,edi
  21a3e6:	73 04                	jae    21a3ec <sqrt+0x20c>
  21a3e8:	89 d1                	mov    ecx,edx
  21a3ea:	eb 0d                	jmp    21a3f9 <sqrt+0x219>
            s0 = t + r;
  21a3ec:	81 c6 00 80 00 00    	add    esi,0x8000
            q += r;
  21a3f2:	41 81 c1 00 40 00 00 	add    r9d,0x4000
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  21a3f9:	ba 17 01 00 00       	mov    edx,0x117
  21a3fe:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  21a403:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  21a406:	8d be 00 20 00 00    	lea    edi,[rsi+0x2000]
        if (t <= ix0) {
  21a40c:	89 d1                	mov    ecx,edx
  21a40e:	29 f9                	sub    ecx,edi
  21a410:	73 04                	jae    21a416 <sqrt+0x236>
  21a412:	89 d1                	mov    ecx,edx
  21a414:	eb 0d                	jmp    21a423 <sqrt+0x243>
            s0 = t + r;
  21a416:	81 c6 00 40 00 00    	add    esi,0x4000
            q += r;
  21a41c:	41 81 c1 00 20 00 00 	add    r9d,0x2000
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  21a423:	ba 16 01 00 00       	mov    edx,0x116
  21a428:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  21a42d:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  21a430:	8d be 00 10 00 00    	lea    edi,[rsi+0x1000]
        if (t <= ix0) {
  21a436:	89 d1                	mov    ecx,edx
  21a438:	29 f9                	sub    ecx,edi
  21a43a:	73 04                	jae    21a440 <sqrt+0x260>
  21a43c:	89 d1                	mov    ecx,edx
  21a43e:	eb 0d                	jmp    21a44d <sqrt+0x26d>
            s0 = t + r;
  21a440:	81 c6 00 20 00 00    	add    esi,0x2000
            q += r;
  21a446:	41 81 c1 00 10 00 00 	add    r9d,0x1000
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  21a44d:	ba 15 01 00 00       	mov    edx,0x115
  21a452:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  21a457:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  21a45a:	8d be 00 08 00 00    	lea    edi,[rsi+0x800]
        if (t <= ix0) {
  21a460:	89 d1                	mov    ecx,edx
  21a462:	29 f9                	sub    ecx,edi
  21a464:	73 04                	jae    21a46a <sqrt+0x28a>
  21a466:	89 d1                	mov    ecx,edx
  21a468:	eb 0d                	jmp    21a477 <sqrt+0x297>
            s0 = t + r;
  21a46a:	81 c6 00 10 00 00    	add    esi,0x1000
            q += r;
  21a470:	41 81 c1 00 08 00 00 	add    r9d,0x800
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  21a477:	ba 14 01 00 00       	mov    edx,0x114
  21a47c:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  21a481:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  21a484:	8d be 00 04 00 00    	lea    edi,[rsi+0x400]
        if (t <= ix0) {
  21a48a:	89 d1                	mov    ecx,edx
  21a48c:	29 f9                	sub    ecx,edi
  21a48e:	73 04                	jae    21a494 <sqrt+0x2b4>
  21a490:	89 d1                	mov    ecx,edx
  21a492:	eb 0d                	jmp    21a4a1 <sqrt+0x2c1>
            s0 = t + r;
  21a494:	81 c6 00 08 00 00    	add    esi,0x800
            q += r;
  21a49a:	41 81 c1 00 04 00 00 	add    r9d,0x400
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  21a4a1:	ba 13 01 00 00       	mov    edx,0x113
  21a4a6:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  21a4ab:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  21a4ae:	8d be 00 02 00 00    	lea    edi,[rsi+0x200]
        if (t <= ix0) {
  21a4b4:	89 d1                	mov    ecx,edx
  21a4b6:	29 f9                	sub    ecx,edi
  21a4b8:	73 04                	jae    21a4be <sqrt+0x2de>
  21a4ba:	89 d1                	mov    ecx,edx
  21a4bc:	eb 0d                	jmp    21a4cb <sqrt+0x2eb>
            s0 = t + r;
  21a4be:	81 c6 00 04 00 00    	add    esi,0x400
            q += r;
  21a4c4:	41 81 c1 00 02 00 00 	add    r9d,0x200
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  21a4cb:	ba 12 01 00 00       	mov    edx,0x112
  21a4d0:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  21a4d5:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  21a4d8:	8d be 00 01 00 00    	lea    edi,[rsi+0x100]
        if (t <= ix0) {
  21a4de:	89 d1                	mov    ecx,edx
  21a4e0:	29 f9                	sub    ecx,edi
  21a4e2:	73 04                	jae    21a4e8 <sqrt+0x308>
  21a4e4:	89 d1                	mov    ecx,edx
  21a4e6:	eb 0d                	jmp    21a4f5 <sqrt+0x315>
            s0 = t + r;
  21a4e8:	81 c6 00 02 00 00    	add    esi,0x200
            q += r;
  21a4ee:	41 81 c1 00 01 00 00 	add    r9d,0x100
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  21a4f5:	ba 11 01 00 00       	mov    edx,0x111
  21a4fa:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  21a4ff:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  21a502:	89 f7                	mov    edi,esi
  21a504:	83 ef 80             	sub    edi,0xffffff80
        if (t <= ix0) {
  21a507:	89 d1                	mov    ecx,edx
  21a509:	29 f9                	sub    ecx,edi
  21a50b:	73 04                	jae    21a511 <sqrt+0x331>
  21a50d:	89 d1                	mov    ecx,edx
  21a50f:	eb 0a                	jmp    21a51b <sqrt+0x33b>
            s0 = t + r;
  21a511:	81 c6 00 01 00 00    	add    esi,0x100
            q += r;
  21a517:	41 83 e9 80          	sub    r9d,0xffffff80
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  21a51b:	ba 10 01 00 00       	mov    edx,0x110
  21a520:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  21a525:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  21a528:	8d 7e 40             	lea    edi,[rsi+0x40]
        if (t <= ix0) {
  21a52b:	89 d1                	mov    ecx,edx
  21a52d:	29 f9                	sub    ecx,edi
  21a52f:	73 04                	jae    21a535 <sqrt+0x355>
  21a531:	89 d1                	mov    ecx,edx
  21a533:	eb 07                	jmp    21a53c <sqrt+0x35c>
            s0 = t + r;
  21a535:	83 ee 80             	sub    esi,0xffffff80
            q += r;
  21a538:	41 83 c1 40          	add    r9d,0x40
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  21a53c:	ba 0f 01 00 00       	mov    edx,0x10f
  21a541:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  21a546:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  21a549:	8d 7e 20             	lea    edi,[rsi+0x20]
        if (t <= ix0) {
  21a54c:	89 d1                	mov    ecx,edx
  21a54e:	29 f9                	sub    ecx,edi
  21a550:	73 04                	jae    21a556 <sqrt+0x376>
  21a552:	89 d1                	mov    ecx,edx
  21a554:	eb 07                	jmp    21a55d <sqrt+0x37d>
            s0 = t + r;
  21a556:	83 c6 40             	add    esi,0x40
            q += r;
  21a559:	41 83 c1 20          	add    r9d,0x20
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  21a55d:	ba 0e 01 00 00       	mov    edx,0x10e
  21a562:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  21a567:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  21a56a:	8d 7e 10             	lea    edi,[rsi+0x10]
        if (t <= ix0) {
  21a56d:	89 d1                	mov    ecx,edx
  21a56f:	29 f9                	sub    ecx,edi
  21a571:	73 04                	jae    21a577 <sqrt+0x397>
  21a573:	89 d1                	mov    ecx,edx
  21a575:	eb 07                	jmp    21a57e <sqrt+0x39e>
            s0 = t + r;
  21a577:	83 c6 20             	add    esi,0x20
            q += r;
  21a57a:	41 83 c1 10          	add    r9d,0x10
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  21a57e:	ba 0d 01 00 00       	mov    edx,0x10d
  21a583:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  21a588:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  21a58b:	8d 7e 08             	lea    edi,[rsi+0x8]
        if (t <= ix0) {
  21a58e:	89 d1                	mov    ecx,edx
  21a590:	29 f9                	sub    ecx,edi
  21a592:	73 04                	jae    21a598 <sqrt+0x3b8>
  21a594:	89 d1                	mov    ecx,edx
  21a596:	eb 07                	jmp    21a59f <sqrt+0x3bf>
            s0 = t + r;
  21a598:	83 c6 10             	add    esi,0x10
            q += r;
  21a59b:	41 83 c1 08          	add    r9d,0x8
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  21a59f:	ba 0c 01 00 00       	mov    edx,0x10c
  21a5a4:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  21a5a9:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  21a5ac:	8d 7e 04             	lea    edi,[rsi+0x4]
        if (t <= ix0) {
  21a5af:	89 d1                	mov    ecx,edx
  21a5b1:	29 f9                	sub    ecx,edi
  21a5b3:	73 04                	jae    21a5b9 <sqrt+0x3d9>
  21a5b5:	89 d1                	mov    ecx,edx
  21a5b7:	eb 07                	jmp    21a5c0 <sqrt+0x3e0>
            s0 = t + r;
  21a5b9:	83 c6 08             	add    esi,0x8
            q += r;
  21a5bc:	41 83 c1 04          	add    r9d,0x4
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  21a5c0:	ba 0b 01 00 00       	mov    edx,0x10b
  21a5c5:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  21a5ca:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  21a5cd:	8d 7e 02             	lea    edi,[rsi+0x2]
        if (t <= ix0) {
  21a5d0:	89 d1                	mov    ecx,edx
  21a5d2:	29 f9                	sub    ecx,edi
  21a5d4:	73 04                	jae    21a5da <sqrt+0x3fa>
  21a5d6:	89 d1                	mov    ecx,edx
  21a5d8:	eb 07                	jmp    21a5e1 <sqrt+0x401>
            s0 = t + r;
  21a5da:	83 c6 04             	add    esi,0x4
            q += r;
  21a5dd:	41 83 c1 02          	add    r9d,0x2
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  21a5e1:	ba 0a 01 00 00       	mov    edx,0x10a
  21a5e6:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  21a5eb:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  21a5ee:	8d 7e 01             	lea    edi,[rsi+0x1]
        if (t <= ix0) {
  21a5f1:	89 d1                	mov    ecx,edx
  21a5f3:	29 f9                	sub    ecx,edi
  21a5f5:	73 04                	jae    21a5fb <sqrt+0x41b>
  21a5f7:	89 d1                	mov    ecx,edx
  21a5f9:	eb 07                	jmp    21a602 <sqrt+0x422>
            s0 = t + r;
  21a5fb:	83 c6 02             	add    esi,0x2
            q += r;
  21a5fe:	41 83 c1 01          	add    r9d,0x1
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  21a602:	55                   	push   rbp
  21a603:	41 56                	push   r14
  21a605:	53                   	push   rbx
  21a606:	ba 09 01 00 00       	mov    edx,0x109
  21a60b:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  21a610:	c1 e0 17             	shl    eax,0x17
  21a613:	8d 1c 4a             	lea    ebx,[rdx+rcx*2]
    m >>= 1;
  21a616:	41 d1 e8             	shr    r8d,1
  21a619:	31 d2                	xor    edx,edx
  21a61b:	bf 00 00 00 80       	mov    edi,0x80000000
  21a620:	41 ba 1e 01 00 00    	mov    r10d,0x11e
  21a626:	41 bb 1d 01 00 00    	mov    r11d,0x11d
  21a62c:	41 be 1c 01 00 00    	mov    r14d,0x11c
  21a632:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21a639:	1f 84 00 00 00 00 00 

    r = sign;
    while (r != 0) {
        t = s1 +% r;
        t = s0;
        if (t < ix0 or (t == ix0 and t1 <= ix1)) {
  21a640:	89 fd                	mov    ebp,edi
  21a642:	89 f1                	mov    ecx,esi
  21a644:	39 f3                	cmp    ebx,esi
  21a646:	73 04                	jae    21a64c <sqrt+0x46c>
  21a648:	31 ed                	xor    ebp,ebp
  21a64a:	31 c9                	xor    ecx,ecx
  21a64c:	01 d5                	add    ebp,edx
  21a64e:	29 cb                	sub    ebx,ecx
                ix0 -= 1;
            }
            ix1 = ix1 -% t1;
            q1 += r;
        }
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  21a650:	0f a4 c3 01          	shld   ebx,eax,0x1
        if (t < ix0 or (t == ix0 and t1 <= ix1)) {
  21a654:	39 f3                	cmp    ebx,esi
  21a656:	73 08                	jae    21a660 <sqrt+0x480>
  21a658:	31 d2                	xor    edx,edx
  21a65a:	31 c9                	xor    ecx,ecx
  21a65c:	eb 08                	jmp    21a666 <sqrt+0x486>
  21a65e:	66 90                	xchg   ax,ax
  21a660:	89 fa                	mov    edx,edi
  21a662:	d1 ea                	shr    edx,1
  21a664:	89 f1                	mov    ecx,esi
  21a666:	01 ea                	add    edx,ebp
  21a668:	29 cb                	sub    ebx,ecx
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  21a66a:	c4 e2 28 f7 c8       	bextr  ecx,eax,r10d
  21a66f:	8d 2c 59             	lea    ebp,[rcx+rbx*2]
        if (t < ix0 or (t == ix0 and t1 <= ix1)) {
  21a672:	39 f5                	cmp    ebp,esi
  21a674:	73 0a                	jae    21a680 <sqrt+0x4a0>
  21a676:	31 db                	xor    ebx,ebx
  21a678:	31 c9                	xor    ecx,ecx
  21a67a:	eb 0b                	jmp    21a687 <sqrt+0x4a7>
  21a67c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  21a680:	89 fb                	mov    ebx,edi
  21a682:	c1 eb 02             	shr    ebx,0x2
  21a685:	89 f1                	mov    ecx,esi
  21a687:	01 d3                	add    ebx,edx
  21a689:	29 cd                	sub    ebp,ecx
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  21a68b:	c4 e2 20 f7 c8       	bextr  ecx,eax,r11d
  21a690:	8d 2c 69             	lea    ebp,[rcx+rbp*2]
        if (t < ix0 or (t == ix0 and t1 <= ix1)) {
  21a693:	39 f5                	cmp    ebp,esi
  21a695:	73 09                	jae    21a6a0 <sqrt+0x4c0>
  21a697:	31 d2                	xor    edx,edx
  21a699:	31 c9                	xor    ecx,ecx
  21a69b:	eb 0a                	jmp    21a6a7 <sqrt+0x4c7>
  21a69d:	0f 1f 00             	nop    DWORD PTR [rax]
  21a6a0:	89 fa                	mov    edx,edi
  21a6a2:	c1 ea 03             	shr    edx,0x3
  21a6a5:	89 f1                	mov    ecx,esi
  21a6a7:	01 da                	add    edx,ebx
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  21a6a9:	c4 e2 08 f7 d8       	bextr  ebx,eax,r14d
        if (t < ix0 or (t == ix0 and t1 <= ix1)) {
  21a6ae:	29 cd                	sub    ebp,ecx
  21a6b0:	c1 e0 04             	shl    eax,0x4
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  21a6b3:	8d 1c 6b             	lea    ebx,[rbx+rbp*2]
        ix1 = ix1 +% ix1;
        r >>= 1;
  21a6b6:	c1 ef 04             	shr    edi,0x4
    while (r != 0) {
  21a6b9:	75 85                	jne    21a640 <sqrt+0x460>
    }

    // rounding direction
    if (ix0 | ix1 != 0) {
  21a6bb:	09 c3                	or     ebx,eax
  21a6bd:	5b                   	pop    rbx
  21a6be:	41 5e                	pop    r14
  21a6c0:	5d                   	pop    rbp
  21a6c1:	74 16                	je     21a6d9 <sqrt+0x4f9>
        var z = 1.0 - tiny; // raise inexact
        if (z >= 1.0) {
            z = 1.0 + tiny;
            if (q1 == 0xFFFFFFFF) {
  21a6c3:	83 fa ff             	cmp    edx,0xffffffff
  21a6c6:	74 0b                	je     21a6d3 <sqrt+0x4f3>
                if (q1 == 0xFFFFFFFE) {
                    q += 1;
                }
                q1 += 2;
            } else {
                q1 += q1 & 1;
  21a6c8:	89 d0                	mov    eax,edx
  21a6ca:	83 e0 01             	and    eax,0x1
  21a6cd:	01 d0                	add    eax,edx
  21a6cf:	89 c2                	mov    edx,eax
  21a6d1:	eb 06                	jmp    21a6d9 <sqrt+0x4f9>
                q += 1;
  21a6d3:	41 83 c1 01          	add    r9d,0x1
  21a6d7:	31 d2                	xor    edx,edx
            }
        }
    }

    ix0 = (q >> 1) + 0x3FE00000;
  21a6d9:	44 89 c8             	mov    eax,r9d
  21a6dc:	d1 e8                	shr    eax,1
    ix1 = q1 >> 1;
    if (q & 1 != 0) {
  21a6de:	44 0f ac ca 01       	shrd   edx,r9d,0x1
    }

    // NOTE: musl here appears to rely on signed twos-complement wraparound. +% has the same
    // behaviour at least.
    var iix0 = @intCast(i32, ix0);
    iix0 = iix0 +% (m << 20);
  21a6e3:	41 c1 e0 14          	shl    r8d,0x14
  21a6e7:	41 8d 04 00          	lea    eax,[r8+rax*1]
  21a6eb:	05 00 00 e0 3f       	add    eax,0x3fe00000

    const uz = (@intCast(u64, iix0) << 32) | ix1;
  21a6f0:	48 c1 e0 20          	shl    rax,0x20
  21a6f4:	48 09 c2             	or     rdx,rax
    return @bitCast(f64, uz);
  21a6f7:	c4 e1 f9 6e c2       	vmovq  xmm0,rdx
  21a6fc:	c3                   	ret    
  21a6fd:	0f 1f 00             	nop    DWORD PTR [rax]

000000000021a700 <sqrtf>:
}

export fn sqrtf(x: f32) f32 {
    const tiny: f32 = 1.0e-30;
    const sign: i32 = @bitCast(i32, u32(0x80000000));
    var ix: i32 = @bitCast(i32, x);
  21a700:	c5 f9 7e c1          	vmovd  ecx,xmm0

    if ((ix & 0x7F800000) == 0x7F800000) {
  21a704:	b8 00 00 80 7f       	mov    eax,0x7f800000
  21a709:	c4 e2 70 f2 c0       	andn   eax,ecx,eax
  21a70e:	75 09                	jne    21a719 <sqrtf+0x19>
        return x * x + x; // sqrt(nan) = nan, sqrt(+inf) = +inf, sqrt(-inf) = snan
  21a710:	c5 fa 59 c8          	vmulss xmm1,xmm0,xmm0
  21a714:	c5 f2 58 c0          	vaddss xmm0,xmm1,xmm0
  21a718:	c3                   	ret    
    }

    // zero
    if (ix <= 0) {
  21a719:	85 c9                	test   ecx,ecx
  21a71b:	7e 15                	jle    21a732 <sqrtf+0x32>
  21a71d:	41 89 c8             	mov    r8d,ecx
  21a720:	41 c1 e8 17          	shr    r8d,0x17
        }
    }

    // normalize
    var m = ix >> 23;
    if (m == 0) {
  21a724:	75 45                	jne    21a76b <sqrtf+0x6b>
  21a726:	31 d2                	xor    edx,edx
        // subnormal
        var i: i32 = 0;
        while (ix & 0x00800000 == 0) : (i += 1) {
  21a728:	0f ba e1 17          	bt     ecx,0x17
  21a72c:	73 18                	jae    21a746 <sqrtf+0x46>
  21a72e:	89 ce                	mov    esi,ecx
  21a730:	eb 2e                	jmp    21a760 <sqrtf+0x60>
        if (ix & ~sign == 0) {
  21a732:	f7 c1 ff ff ff 7f    	test   ecx,0x7fffffff
  21a738:	0f 84 26 03 00 00    	je     21aa64 <sqrtf+0x364>
        if (ix < 0) {
  21a73e:	85 c9                	test   ecx,ecx
  21a740:	0f 88 16 03 00 00    	js     21aa5c <sqrtf+0x35c>
  21a746:	31 d2                	xor    edx,edx
  21a748:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  21a74f:	00 
            ix <<= 1;
  21a750:	8d 34 09             	lea    esi,[rcx+rcx*1]
        while (ix & 0x00800000 == 0) : (i += 1) {
  21a753:	83 c2 01             	add    edx,0x1
  21a756:	f7 c1 00 00 40 00    	test   ecx,0x400000
  21a75c:	89 f1                	mov    ecx,esi
  21a75e:	74 f0                	je     21a750 <sqrtf+0x50>
        }
        m -= i - 1;
  21a760:	41 b8 01 00 00 00    	mov    r8d,0x1
  21a766:	41 29 d0             	sub    r8d,edx
  21a769:	89 f1                	mov    ecx,esi
    }

    m -= 127; // unbias exponent
  21a76b:	41 83 c0 81          	add    r8d,0xffffff81
    ix = (ix & 0x007FFFFF) | 0x00800000;
  21a76f:	81 e1 ff ff 7f 00    	and    ecx,0x7fffff
  21a775:	81 c9 00 00 80 00    	or     ecx,0x800000

    if (m & 1 != 0) { // odd m, double x to even
  21a77b:	44 89 c0             	mov    eax,r8d
  21a77e:	24 01                	and    al,0x1
  21a780:	c4 e2 79 f7 c1       	shlx   eax,ecx,eax
  21a785:	8d 34 85 00 00 00 00 	lea    esi,[rax*4+0x0]
    var s: i32 = 0;
    var r: i32 = 0x01000000; // r = moving bit right -> left

    while (r != 0) {
        const t = s + r;
        if (t <= ix) {
  21a78c:	31 d2                	xor    edx,edx
  21a78e:	3d ff ff 7f 00       	cmp    eax,0x7fffff
  21a793:	0f 9f c2             	setg   dl
  21a796:	89 d1                	mov    ecx,edx
  21a798:	c1 e1 18             	shl    ecx,0x18
  21a79b:	c1 e2 19             	shl    edx,0x19
  21a79e:	3d 00 00 80 00       	cmp    eax,0x800000
  21a7a3:	8d 3c 85 00 00 00 fe 	lea    edi,[rax*4-0x2000000]
  21a7aa:	0f 4c fe             	cmovl  edi,esi
        const t = s + r;
  21a7ad:	8d 82 00 00 80 00    	lea    eax,[rdx+0x800000]
        if (t <= ix) {
  21a7b3:	89 fe                	mov    esi,edi
  21a7b5:	29 c6                	sub    esi,eax
  21a7b7:	7d 04                	jge    21a7bd <sqrtf+0xbd>
  21a7b9:	89 fe                	mov    esi,edi
  21a7bb:	eb 0d                	jmp    21a7ca <sqrtf+0xca>
            s = t + r;
  21a7bd:	05 00 00 80 00       	add    eax,0x800000
            ix -= t;
            q += r;
  21a7c2:	81 c9 00 00 80 00    	or     ecx,0x800000
  21a7c8:	89 c2                	mov    edx,eax
  21a7ca:	01 f6                	add    esi,esi
        const t = s + r;
  21a7cc:	8d 82 00 00 40 00    	lea    eax,[rdx+0x400000]
        if (t <= ix) {
  21a7d2:	89 f7                	mov    edi,esi
  21a7d4:	29 c7                	sub    edi,eax
  21a7d6:	7d 04                	jge    21a7dc <sqrtf+0xdc>
  21a7d8:	89 f7                	mov    edi,esi
  21a7da:	eb 0c                	jmp    21a7e8 <sqrtf+0xe8>
            s = t + r;
  21a7dc:	81 c2 00 00 80 00    	add    edx,0x800000
            q += r;
  21a7e2:	81 c1 00 00 40 00    	add    ecx,0x400000
  21a7e8:	01 ff                	add    edi,edi
        const t = s + r;
  21a7ea:	8d 82 00 00 20 00    	lea    eax,[rdx+0x200000]
        if (t <= ix) {
  21a7f0:	89 fe                	mov    esi,edi
  21a7f2:	29 c6                	sub    esi,eax
  21a7f4:	7d 04                	jge    21a7fa <sqrtf+0xfa>
  21a7f6:	89 fe                	mov    esi,edi
  21a7f8:	eb 0c                	jmp    21a806 <sqrtf+0x106>
            s = t + r;
  21a7fa:	81 c2 00 00 40 00    	add    edx,0x400000
            q += r;
  21a800:	81 c1 00 00 20 00    	add    ecx,0x200000
  21a806:	01 f6                	add    esi,esi
        const t = s + r;
  21a808:	8d 82 00 00 10 00    	lea    eax,[rdx+0x100000]
        if (t <= ix) {
  21a80e:	89 f7                	mov    edi,esi
  21a810:	29 c7                	sub    edi,eax
  21a812:	7d 04                	jge    21a818 <sqrtf+0x118>
  21a814:	89 f7                	mov    edi,esi
  21a816:	eb 0c                	jmp    21a824 <sqrtf+0x124>
            s = t + r;
  21a818:	81 c2 00 00 20 00    	add    edx,0x200000
            q += r;
  21a81e:	81 c1 00 00 10 00    	add    ecx,0x100000
  21a824:	01 ff                	add    edi,edi
        const t = s + r;
  21a826:	8d 82 00 00 08 00    	lea    eax,[rdx+0x80000]
        if (t <= ix) {
  21a82c:	89 fe                	mov    esi,edi
  21a82e:	29 c6                	sub    esi,eax
  21a830:	7d 04                	jge    21a836 <sqrtf+0x136>
  21a832:	89 fe                	mov    esi,edi
  21a834:	eb 0c                	jmp    21a842 <sqrtf+0x142>
            s = t + r;
  21a836:	81 c2 00 00 10 00    	add    edx,0x100000
            q += r;
  21a83c:	81 c1 00 00 08 00    	add    ecx,0x80000
  21a842:	01 f6                	add    esi,esi
        const t = s + r;
  21a844:	8d 82 00 00 04 00    	lea    eax,[rdx+0x40000]
        if (t <= ix) {
  21a84a:	89 f7                	mov    edi,esi
  21a84c:	29 c7                	sub    edi,eax
  21a84e:	7d 04                	jge    21a854 <sqrtf+0x154>
  21a850:	89 f7                	mov    edi,esi
  21a852:	eb 0c                	jmp    21a860 <sqrtf+0x160>
            s = t + r;
  21a854:	81 c2 00 00 08 00    	add    edx,0x80000
            q += r;
  21a85a:	81 c1 00 00 04 00    	add    ecx,0x40000
  21a860:	01 ff                	add    edi,edi
        const t = s + r;
  21a862:	8d 82 00 00 02 00    	lea    eax,[rdx+0x20000]
        if (t <= ix) {
  21a868:	89 fe                	mov    esi,edi
  21a86a:	29 c6                	sub    esi,eax
  21a86c:	7d 04                	jge    21a872 <sqrtf+0x172>
  21a86e:	89 fe                	mov    esi,edi
  21a870:	eb 0c                	jmp    21a87e <sqrtf+0x17e>
            s = t + r;
  21a872:	81 c2 00 00 04 00    	add    edx,0x40000
            q += r;
  21a878:	81 c1 00 00 02 00    	add    ecx,0x20000
  21a87e:	01 f6                	add    esi,esi
        const t = s + r;
  21a880:	8d 82 00 00 01 00    	lea    eax,[rdx+0x10000]
        if (t <= ix) {
  21a886:	89 f7                	mov    edi,esi
  21a888:	29 c7                	sub    edi,eax
  21a88a:	7d 04                	jge    21a890 <sqrtf+0x190>
  21a88c:	89 f7                	mov    edi,esi
  21a88e:	eb 0c                	jmp    21a89c <sqrtf+0x19c>
            s = t + r;
  21a890:	81 c2 00 00 02 00    	add    edx,0x20000
            q += r;
  21a896:	81 c1 00 00 01 00    	add    ecx,0x10000
  21a89c:	01 ff                	add    edi,edi
        const t = s + r;
  21a89e:	8d 82 00 80 00 00    	lea    eax,[rdx+0x8000]
        if (t <= ix) {
  21a8a4:	89 fe                	mov    esi,edi
  21a8a6:	29 c6                	sub    esi,eax
  21a8a8:	7d 04                	jge    21a8ae <sqrtf+0x1ae>
  21a8aa:	89 fe                	mov    esi,edi
  21a8ac:	eb 0c                	jmp    21a8ba <sqrtf+0x1ba>
            s = t + r;
  21a8ae:	81 c2 00 00 01 00    	add    edx,0x10000
            q += r;
  21a8b4:	81 c1 00 80 00 00    	add    ecx,0x8000
  21a8ba:	01 f6                	add    esi,esi
        const t = s + r;
  21a8bc:	8d 82 00 40 00 00    	lea    eax,[rdx+0x4000]
        if (t <= ix) {
  21a8c2:	89 f7                	mov    edi,esi
  21a8c4:	29 c7                	sub    edi,eax
  21a8c6:	7d 04                	jge    21a8cc <sqrtf+0x1cc>
  21a8c8:	89 f7                	mov    edi,esi
  21a8ca:	eb 0c                	jmp    21a8d8 <sqrtf+0x1d8>
            s = t + r;
  21a8cc:	81 c2 00 80 00 00    	add    edx,0x8000
            q += r;
  21a8d2:	81 c1 00 40 00 00    	add    ecx,0x4000
  21a8d8:	01 ff                	add    edi,edi
        const t = s + r;
  21a8da:	8d 82 00 20 00 00    	lea    eax,[rdx+0x2000]
        if (t <= ix) {
  21a8e0:	89 fe                	mov    esi,edi
  21a8e2:	29 c6                	sub    esi,eax
  21a8e4:	7d 04                	jge    21a8ea <sqrtf+0x1ea>
  21a8e6:	89 fe                	mov    esi,edi
  21a8e8:	eb 0c                	jmp    21a8f6 <sqrtf+0x1f6>
            s = t + r;
  21a8ea:	81 c2 00 40 00 00    	add    edx,0x4000
            q += r;
  21a8f0:	81 c1 00 20 00 00    	add    ecx,0x2000
  21a8f6:	01 f6                	add    esi,esi
        const t = s + r;
  21a8f8:	8d 82 00 10 00 00    	lea    eax,[rdx+0x1000]
        if (t <= ix) {
  21a8fe:	89 f7                	mov    edi,esi
  21a900:	29 c7                	sub    edi,eax
  21a902:	7d 04                	jge    21a908 <sqrtf+0x208>
  21a904:	89 f7                	mov    edi,esi
  21a906:	eb 0c                	jmp    21a914 <sqrtf+0x214>
            s = t + r;
  21a908:	81 c2 00 20 00 00    	add    edx,0x2000
            q += r;
  21a90e:	81 c1 00 10 00 00    	add    ecx,0x1000
  21a914:	01 ff                	add    edi,edi
        const t = s + r;
  21a916:	8d 82 00 08 00 00    	lea    eax,[rdx+0x800]
        if (t <= ix) {
  21a91c:	89 fe                	mov    esi,edi
  21a91e:	29 c6                	sub    esi,eax
  21a920:	7d 04                	jge    21a926 <sqrtf+0x226>
  21a922:	89 fe                	mov    esi,edi
  21a924:	eb 0c                	jmp    21a932 <sqrtf+0x232>
            s = t + r;
  21a926:	81 c2 00 10 00 00    	add    edx,0x1000
            q += r;
  21a92c:	81 c1 00 08 00 00    	add    ecx,0x800
  21a932:	01 f6                	add    esi,esi
        const t = s + r;
  21a934:	8d 82 00 04 00 00    	lea    eax,[rdx+0x400]
        if (t <= ix) {
  21a93a:	89 f7                	mov    edi,esi
  21a93c:	29 c7                	sub    edi,eax
  21a93e:	7d 04                	jge    21a944 <sqrtf+0x244>
  21a940:	89 f7                	mov    edi,esi
  21a942:	eb 0c                	jmp    21a950 <sqrtf+0x250>
            s = t + r;
  21a944:	81 c2 00 08 00 00    	add    edx,0x800
            q += r;
  21a94a:	81 c1 00 04 00 00    	add    ecx,0x400
  21a950:	01 ff                	add    edi,edi
        const t = s + r;
  21a952:	8d 82 00 02 00 00    	lea    eax,[rdx+0x200]
        if (t <= ix) {
  21a958:	89 fe                	mov    esi,edi
  21a95a:	29 c6                	sub    esi,eax
  21a95c:	7d 04                	jge    21a962 <sqrtf+0x262>
  21a95e:	89 fe                	mov    esi,edi
  21a960:	eb 0c                	jmp    21a96e <sqrtf+0x26e>
            s = t + r;
  21a962:	81 c2 00 04 00 00    	add    edx,0x400
            q += r;
  21a968:	81 c1 00 02 00 00    	add    ecx,0x200
  21a96e:	01 f6                	add    esi,esi
        const t = s + r;
  21a970:	8d 82 00 01 00 00    	lea    eax,[rdx+0x100]
        if (t <= ix) {
  21a976:	89 f7                	mov    edi,esi
  21a978:	29 c7                	sub    edi,eax
  21a97a:	7d 04                	jge    21a980 <sqrtf+0x280>
  21a97c:	89 f7                	mov    edi,esi
  21a97e:	eb 0c                	jmp    21a98c <sqrtf+0x28c>
            s = t + r;
  21a980:	81 c2 00 02 00 00    	add    edx,0x200
            q += r;
  21a986:	81 c1 00 01 00 00    	add    ecx,0x100
  21a98c:	01 ff                	add    edi,edi
        const t = s + r;
  21a98e:	89 d0                	mov    eax,edx
  21a990:	83 e8 80             	sub    eax,0xffffff80
        if (t <= ix) {
  21a993:	89 fe                	mov    esi,edi
  21a995:	29 c6                	sub    esi,eax
  21a997:	7d 04                	jge    21a99d <sqrtf+0x29d>
  21a999:	89 fe                	mov    esi,edi
  21a99b:	eb 09                	jmp    21a9a6 <sqrtf+0x2a6>
            s = t + r;
  21a99d:	81 c2 00 01 00 00    	add    edx,0x100
            q += r;
  21a9a3:	83 e9 80             	sub    ecx,0xffffff80
  21a9a6:	01 f6                	add    esi,esi
        const t = s + r;
  21a9a8:	8d 42 40             	lea    eax,[rdx+0x40]
        if (t <= ix) {
  21a9ab:	89 f7                	mov    edi,esi
  21a9ad:	29 c7                	sub    edi,eax
  21a9af:	7d 04                	jge    21a9b5 <sqrtf+0x2b5>
  21a9b1:	89 f7                	mov    edi,esi
  21a9b3:	eb 06                	jmp    21a9bb <sqrtf+0x2bb>
            s = t + r;
  21a9b5:	83 ea 80             	sub    edx,0xffffff80
            q += r;
  21a9b8:	83 c1 40             	add    ecx,0x40
  21a9bb:	01 ff                	add    edi,edi
        const t = s + r;
  21a9bd:	8d 42 20             	lea    eax,[rdx+0x20]
        if (t <= ix) {
  21a9c0:	89 fe                	mov    esi,edi
  21a9c2:	29 c6                	sub    esi,eax
  21a9c4:	7d 04                	jge    21a9ca <sqrtf+0x2ca>
  21a9c6:	89 fe                	mov    esi,edi
  21a9c8:	eb 06                	jmp    21a9d0 <sqrtf+0x2d0>
            s = t + r;
  21a9ca:	83 c2 40             	add    edx,0x40
            q += r;
  21a9cd:	83 c1 20             	add    ecx,0x20
  21a9d0:	01 f6                	add    esi,esi
        const t = s + r;
  21a9d2:	8d 42 10             	lea    eax,[rdx+0x10]
        if (t <= ix) {
  21a9d5:	89 f7                	mov    edi,esi
  21a9d7:	29 c7                	sub    edi,eax
  21a9d9:	7d 04                	jge    21a9df <sqrtf+0x2df>
  21a9db:	89 f7                	mov    edi,esi
  21a9dd:	eb 06                	jmp    21a9e5 <sqrtf+0x2e5>
            s = t + r;
  21a9df:	83 c2 20             	add    edx,0x20
            q += r;
  21a9e2:	83 c1 10             	add    ecx,0x10
  21a9e5:	01 ff                	add    edi,edi
        const t = s + r;
  21a9e7:	8d 42 08             	lea    eax,[rdx+0x8]
        if (t <= ix) {
  21a9ea:	89 fe                	mov    esi,edi
  21a9ec:	29 c6                	sub    esi,eax
  21a9ee:	7d 04                	jge    21a9f4 <sqrtf+0x2f4>
  21a9f0:	89 fe                	mov    esi,edi
  21a9f2:	eb 06                	jmp    21a9fa <sqrtf+0x2fa>
            s = t + r;
  21a9f4:	83 c2 10             	add    edx,0x10
            q += r;
  21a9f7:	83 c1 08             	add    ecx,0x8
  21a9fa:	01 f6                	add    esi,esi
        const t = s + r;
  21a9fc:	8d 42 04             	lea    eax,[rdx+0x4]
        if (t <= ix) {
  21a9ff:	89 f7                	mov    edi,esi
  21aa01:	29 c7                	sub    edi,eax
  21aa03:	7d 04                	jge    21aa09 <sqrtf+0x309>
  21aa05:	89 f7                	mov    edi,esi
  21aa07:	eb 06                	jmp    21aa0f <sqrtf+0x30f>
            s = t + r;
  21aa09:	83 c2 08             	add    edx,0x8
            q += r;
  21aa0c:	83 c1 04             	add    ecx,0x4
  21aa0f:	01 ff                	add    edi,edi
        const t = s + r;
  21aa11:	8d 42 02             	lea    eax,[rdx+0x2]
        if (t <= ix) {
  21aa14:	89 fe                	mov    esi,edi
  21aa16:	29 c6                	sub    esi,eax
  21aa18:	7d 0a                	jge    21aa24 <sqrtf+0x324>
  21aa1a:	89 fe                	mov    esi,edi
  21aa1c:	01 f6                	add    esi,esi
  21aa1e:	39 d6                	cmp    esi,edx
  21aa20:	7f 0e                	jg     21aa30 <sqrtf+0x330>
  21aa22:	eb 14                	jmp    21aa38 <sqrtf+0x338>
            s = t + r;
  21aa24:	83 c2 04             	add    edx,0x4
            q += r;
  21aa27:	83 c1 02             	add    ecx,0x2
  21aa2a:	01 f6                	add    esi,esi
        if (t <= ix) {
  21aa2c:	39 d6                	cmp    esi,edx
  21aa2e:	7e 08                	jle    21aa38 <sqrtf+0x338>
        const t = s + r;
  21aa30:	83 c2 01             	add    edx,0x1
            ix -= t;
  21aa33:	29 d6                	sub    esi,edx
            q += r;
  21aa35:	83 c1 01             	add    ecx,0x1
    m >>= 1; // m = [m / 2]
  21aa38:	41 83 e0 fe          	and    r8d,0xfffffffe
  21aa3c:	41 c1 e0 16          	shl    r8d,0x16
        ix += ix;
        r >>= 1;
    }

    // floating add to find rounding direction
    if (ix != 0) {
  21aa40:	85 f6                	test   esi,esi
  21aa42:	0f 95 c0             	setne  al
  21aa45:	20 c8                	and    al,cl
  21aa47:	0f b6 c0             	movzx  eax,al
  21aa4a:	01 c8                	add    eax,ecx
                }
            }
        }
    }

    ix = (q >> 1) + 0x3f000000;
  21aa4c:	d1 f8                	sar    eax,1
    ix += m << 23;
  21aa4e:	41 8d 04 00          	lea    eax,[r8+rax*1]
  21aa52:	05 00 00 00 3f       	add    eax,0x3f000000
    return @bitCast(f32, ix);
  21aa57:	c5 f9 6e c0          	vmovd  xmm0,eax
  21aa5b:	c3                   	ret    
  21aa5c:	c5 f9 6e 05 64 ca fe 	vmovd  xmm0,DWORD PTR [rip+0xfffffffffffeca64]        # 2074c8 <__unnamed_44+0x18>
  21aa63:	ff 
            return x; // sqrt (+-0) = +-0
  21aa64:	c3                   	ret    
  21aa65:	cc                   	int3   
  21aa66:	cc                   	int3   
  21aa67:	cc                   	int3   
  21aa68:	cc                   	int3   
  21aa69:	cc                   	int3   
  21aa6a:	cc                   	int3   
  21aa6b:	cc                   	int3   
  21aa6c:	cc                   	int3   
  21aa6d:	cc                   	int3   
  21aa6e:	cc                   	int3   
  21aa6f:	cc                   	int3   

000000000021aa70 <__udivmoddi4>:
const udivmod = @import("udivmod.zig").udivmod;
const builtin = @import("builtin");

pub extern fn __udivmoddi4(a: u64, b: u64, maybe_rem: ?*u64) u64 {
  21aa70:	55                   	push   rbp
  21aa71:	41 57                	push   r15
  21aa73:	41 56                	push   r14
  21aa75:	41 54                	push   r12
  21aa77:	53                   	push   rbx
  21aa78:	49 89 d0             	mov    r8,rdx
  21aa7b:	49 89 fa             	mov    r10,rdi
  21aa7e:	4c 89 d3             	mov    rbx,r10
  21aa81:	48 c1 eb 20          	shr    rbx,0x20
  21aa85:	48 89 f1             	mov    rcx,rsi
  21aa88:	48 c1 e9 20          	shr    rcx,0x20
    const d = @ptrCast(*const [2]SingleInt, &b).*; // TODO issue #421
    var q: [2]SingleInt = undefined;
    var r: [2]SingleInt = undefined;
    var sr: c_uint = undefined;
    // special cases, X is unknown, K != 0
    if (n[high] == 0) {
  21aa8c:	85 db                	test   ebx,ebx
  21aa8e:	74 2f                	je     21aabf <__udivmoddi4+0x4f>
            rem.* = n[low];
        }
        return 0;
    }
    // n[high] != 0
    if (d[low] == 0) {
  21aa90:	85 f6                	test   esi,esi
  21aa92:	74 46                	je     21aada <__udivmoddi4+0x6a>
  21aa94:	85 c9                	test   ecx,ecx
        // r.all = a >> sr;
        r[high] = n[high] >> @intCast(Log2SingleInt, sr);
        r[low] = (n[high] << @intCast(Log2SingleInt, SingleInt.bit_count - sr)) | (n[low] >> @intCast(Log2SingleInt, sr));
    } else {
        // d[low] != 0
        if (d[high] == 0) {
  21aa96:	74 78                	je     21ab10 <__udivmoddi4+0xa0>
            }
        } else {
            // K X
            // ---
            // K K
            sr = @bitCast(c_uint, c_int(@clz(d[high])) - c_int(@clz(n[high])));
  21aa98:	f3 0f bd e9          	lzcnt  ebp,ecx
  21aa9c:	f3 0f bd c3          	lzcnt  eax,ebx
  21aaa0:	29 c5                	sub    ebp,eax
            // 0 <= sr <= SingleInt.bit_count - 1 or sr large
            if (sr > SingleInt.bit_count - 1) {
  21aaa2:	83 fd 20             	cmp    ebp,0x20
  21aaa5:	0f 82 b3 00 00 00    	jb     21ab5e <__udivmoddi4+0xee>
                if (maybe_rem) |rem| {
  21aaab:	4d 85 c0             	test   r8,r8
  21aaae:	0f 84 d5 00 00 00    	je     21ab89 <__udivmoddi4+0x119>
  21aab4:	4d 89 10             	mov    QWORD PTR [r8],r10
  21aab7:	45 31 d2             	xor    r10d,r10d
  21aaba:	e9 06 03 00 00       	jmp    21adc5 <__udivmoddi4+0x355>
        if (d[high] == 0) {
  21aabf:	85 c9                	test   ecx,ecx
  21aac1:	74 7d                	je     21ab40 <__udivmoddi4+0xd0>
  21aac3:	4d 85 c0             	test   r8,r8
        if (maybe_rem) |rem| {
  21aac6:	0f 84 bd 00 00 00    	je     21ab89 <__udivmoddi4+0x119>
            rem.* = n[low];
  21aacc:	44 89 d0             	mov    eax,r10d
  21aacf:	49 89 00             	mov    QWORD PTR [r8],rax
  21aad2:	45 31 d2             	xor    r10d,r10d
  21aad5:	e9 eb 02 00 00       	jmp    21adc5 <__udivmoddi4+0x355>
  21aada:	85 c9                	test   ecx,ecx
        if (d[high] == 0) {
  21aadc:	0f 84 93 00 00 00    	je     21ab75 <__udivmoddi4+0x105>
        if (n[low] == 0) {
  21aae2:	45 85 d2             	test   r10d,r10d
  21aae5:	0f 84 d2 00 00 00    	je     21abbd <__udivmoddi4+0x14d>
        if ((d[high] & (d[high] - 1)) == 0) {
  21aaeb:	8d 41 ff             	lea    eax,[rcx-0x1]
  21aaee:	85 c8                	test   eax,ecx
  21aaf0:	0f 84 5d 01 00 00    	je     21ac53 <__udivmoddi4+0x1e3>
        sr = @bitCast(c_uint, c_int(@clz(d[high])) - c_int(@clz(n[high])));
  21aaf6:	f3 0f bd c9          	lzcnt  ecx,ecx
  21aafa:	f3 0f bd c3          	lzcnt  eax,ebx
  21aafe:	29 c1                	sub    ecx,eax
        if (sr > SingleInt.bit_count - 2) {
  21ab00:	83 f9 1f             	cmp    ecx,0x1f
  21ab03:	0f 82 6c 01 00 00    	jb     21ac75 <__udivmoddi4+0x205>
            if (maybe_rem) |rem| {
  21ab09:	4d 85 c0             	test   r8,r8
  21ab0c:	75 a6                	jne    21aab4 <__udivmoddi4+0x44>
  21ab0e:	eb 79                	jmp    21ab89 <__udivmoddi4+0x119>
            if ((d[low] & (d[low] - 1)) == 0) {
  21ab10:	8d 46 ff             	lea    eax,[rsi-0x1]
  21ab13:	85 f0                	test   eax,esi
  21ab15:	0f 84 c2 00 00 00    	je     21abdd <__udivmoddi4+0x16d>
            sr = 1 + SingleInt.bit_count + c_uint(@clz(d[low])) - c_uint(@clz(n[high]));
  21ab1b:	f3 0f bd ce          	lzcnt  ecx,esi
  21ab1f:	83 c1 21             	add    ecx,0x21
  21ab22:	f3 0f bd c3          	lzcnt  eax,ebx
  21ab26:	29 c1                	sub    ecx,eax
  21ab28:	31 d2                	xor    edx,edx
            if (sr == SingleInt.bit_count) {
  21ab2a:	83 f9 20             	cmp    ecx,0x20
  21ab2d:	0f 85 e7 00 00 00    	jne    21ac1a <__udivmoddi4+0x1aa>
  21ab33:	45 31 ff             	xor    r15d,r15d
  21ab36:	b9 20 00 00 00       	mov    ecx,0x20
  21ab3b:	e9 7c 01 00 00       	jmp    21acbc <__udivmoddi4+0x24c>
  21ab40:	4d 85 c0             	test   r8,r8
            if (maybe_rem) |rem| {
  21ab43:	74 0a                	je     21ab4f <__udivmoddi4+0xdf>
                rem.* = n[low] % d[low];
  21ab45:	31 d2                	xor    edx,edx
  21ab47:	44 89 d0             	mov    eax,r10d
  21ab4a:	f7 f6                	div    esi
  21ab4c:	49 89 10             	mov    QWORD PTR [r8],rdx
            return n[low] / d[low];
  21ab4f:	31 d2                	xor    edx,edx
  21ab51:	44 89 d0             	mov    eax,r10d
  21ab54:	f7 f6                	div    esi
  21ab56:	41 89 c2             	mov    r10d,eax
  21ab59:	e9 67 02 00 00       	jmp    21adc5 <__udivmoddi4+0x355>
                    rem.* = a;
                }
                return 0;
            }
            sr += 1;
  21ab5e:	8d 4d 01             	lea    ecx,[rbp+0x1]
  21ab61:	45 31 ff             	xor    r15d,r15d
            // 1 <= sr <= SingleInt.bit_count
            // q.all = a << (DoubleInt.bit_count - sr);
            // r.all = a >> sr;
            q[low] = 0;
            if (sr == SingleInt.bit_count) {
  21ab64:	83 f9 20             	cmp    ecx,0x20
  21ab67:	75 28                	jne    21ab91 <__udivmoddi4+0x121>
  21ab69:	31 d2                	xor    edx,edx
  21ab6b:	b9 20 00 00 00       	mov    ecx,0x20
  21ab70:	e9 47 01 00 00       	jmp    21acbc <__udivmoddi4+0x24c>
            if (maybe_rem) |rem| {
  21ab75:	4d 85 c0             	test   r8,r8
  21ab78:	74 0f                	je     21ab89 <__udivmoddi4+0x119>
                rem.* = n[high] % d[low];
  21ab7a:	49 c7 00 00 00 00 00 	mov    QWORD PTR [r8],0x0
  21ab81:	45 31 d2             	xor    r10d,r10d
  21ab84:	e9 3c 02 00 00       	jmp    21adc5 <__udivmoddi4+0x355>
  21ab89:	45 31 d2             	xor    r10d,r10d
  21ab8c:	e9 34 02 00 00       	jmp    21adc5 <__udivmoddi4+0x355>
                q[high] = n[low];
                r[high] = 0;
                r[low] = n[high];
            } else {
                r[high] = n[high] >> @intCast(Log2SingleInt, sr);
  21ab91:	41 89 c9             	mov    r9d,ecx
  21ab94:	41 83 e1 1f          	and    r9d,0x1f
  21ab98:	c4 e2 33 f7 d3       	shrx   edx,ebx,r9d
  21ab9d:	b8 1f 00 00 00       	mov    eax,0x1f
                r[low] = (n[high] << @intCast(Log2SingleInt, SingleInt.bit_count - sr)) | (n[low] >> @intCast(Log2SingleInt, sr));
  21aba2:	29 e8                	sub    eax,ebp
  21aba4:	83 e0 1f             	and    eax,0x1f
  21aba7:	c4 e2 79 f7 eb       	shlx   ebp,ebx,eax
  21abac:	c4 c2 33 f7 da       	shrx   ebx,r10d,r9d
  21abb1:	09 eb                	or     ebx,ebp
                q[high] = n[low] << @intCast(Log2SingleInt, SingleInt.bit_count - sr);
  21abb3:	c4 42 79 f7 d2       	shlx   r10d,r10d,eax
  21abb8:	e9 ff 00 00 00       	jmp    21acbc <__udivmoddi4+0x24c>
            if (maybe_rem) |rem| {
  21abbd:	4d 85 c0             	test   r8,r8
  21abc0:	74 0d                	je     21abcf <__udivmoddi4+0x15f>
                r[high] = n[high] % d[high];
  21abc2:	31 d2                	xor    edx,edx
  21abc4:	89 d8                	mov    eax,ebx
  21abc6:	f7 f1                	div    ecx
                rem.* = @ptrCast(*align(@alignOf(SingleInt)) DoubleInt, &r[0]).*; // TODO issue #421
  21abc8:	48 c1 e2 20          	shl    rdx,0x20
  21abcc:	49 89 10             	mov    QWORD PTR [r8],rdx
            return n[high] / d[high];
  21abcf:	31 d2                	xor    edx,edx
  21abd1:	89 d8                	mov    eax,ebx
  21abd3:	f7 f1                	div    ecx
  21abd5:	41 89 c2             	mov    r10d,eax
  21abd8:	e9 e8 01 00 00       	jmp    21adc5 <__udivmoddi4+0x355>
                if (maybe_rem) |rem| {
  21abdd:	4d 85 c0             	test   r8,r8
  21abe0:	74 06                	je     21abe8 <__udivmoddi4+0x178>
                    rem.* = n[low] & (d[low] - 1);
  21abe2:	44 21 d0             	and    eax,r10d
  21abe5:	49 89 00             	mov    QWORD PTR [r8],rax
                if (d[low] == 1) {
  21abe8:	83 fe 01             	cmp    esi,0x1
  21abeb:	0f 84 d4 01 00 00    	je     21adc5 <__udivmoddi4+0x355>
                sr = @ctz(d[low]);
  21abf1:	f3 0f bc c6          	tzcnt  eax,esi
                q[high] = n[high] >> @intCast(Log2SingleInt, sr);
  21abf5:	89 c1                	mov    ecx,eax
  21abf7:	83 e1 1f             	and    ecx,0x1f
  21abfa:	c4 e2 73 f7 d3       	shrx   edx,ebx,ecx
                q[low] = (n[high] << @intCast(Log2SingleInt, SingleInt.bit_count - sr)) | (n[low] >> @intCast(Log2SingleInt, sr));
  21abff:	f7 d8                	neg    eax
  21ac01:	c4 e2 79 f7 c3       	shlx   eax,ebx,eax
  21ac06:	c4 42 73 f7 d2       	shrx   r10d,r10d,ecx
  21ac0b:	41 09 c2             	or     r10d,eax
                return @ptrCast(*align(@alignOf(SingleInt)) DoubleInt, &q[0]).*; // TODO issue #421
  21ac0e:	48 c1 e2 20          	shl    rdx,0x20
  21ac12:	49 09 d2             	or     r10,rdx
  21ac15:	e9 ab 01 00 00       	jmp    21adc5 <__udivmoddi4+0x355>
  21ac1a:	89 cd                	mov    ebp,ecx
  21ac1c:	f7 dd                	neg    ebp
  21ac1e:	83 e5 1f             	and    ebp,0x1f
  21ac21:	c4 42 51 f7 fa       	shlx   r15d,r10d,ebp
            } else if (sr < SingleInt.bit_count) {
  21ac26:	83 f9 20             	cmp    ecx,0x20
  21ac29:	73 7a                	jae    21aca5 <__udivmoddi4+0x235>
  21ac2b:	31 d2                	xor    edx,edx
    // q.all = a << (DoubleInt.bit_count - sr);
    // r.all = a >> sr;
    // 1 <= sr <= DoubleInt.bit_count - 1
    var carry: u32 = 0;
    var r_all: DoubleInt = undefined;
    while (sr > 0) : (sr -= 1) {
  21ac2d:	85 c9                	test   ecx,ecx
  21ac2f:	0f 84 9c 01 00 00    	je     21add1 <__udivmoddi4+0x361>
  21ac35:	89 c8                	mov    eax,ecx
  21ac37:	83 e0 1f             	and    eax,0x1f
  21ac3a:	c4 e2 7b f7 d3       	shrx   edx,ebx,eax
  21ac3f:	c4 e2 51 f7 eb       	shlx   ebp,ebx,ebp
  21ac44:	c4 c2 7b f7 da       	shrx   ebx,r10d,eax
  21ac49:	09 eb                	or     ebx,ebp
  21ac4b:	45 89 fa             	mov    r10d,r15d
  21ac4e:	45 31 ff             	xor    r15d,r15d
  21ac51:	eb 69                	jmp    21acbc <__udivmoddi4+0x24c>
            if (maybe_rem) |rem| {
  21ac53:	4d 85 c0             	test   r8,r8
  21ac56:	74 0f                	je     21ac67 <__udivmoddi4+0x1f7>
                r[high] = n[high] & (d[high] - 1);
  21ac58:	21 d8                	and    eax,ebx
                rem.* = @ptrCast(*align(@alignOf(SingleInt)) DoubleInt, &r[0]).*; // TODO issue #421
  21ac5a:	48 c1 e0 20          	shl    rax,0x20
  21ac5e:	44 89 d2             	mov    edx,r10d
  21ac61:	48 09 c2             	or     rdx,rax
  21ac64:	49 89 10             	mov    QWORD PTR [r8],rdx
            return n[high] >> @intCast(Log2SingleInt, @ctz(d[high]));
  21ac67:	f3 0f bc c1          	tzcnt  eax,ecx
  21ac6b:	c4 62 7b f7 d3       	shrx   r10d,ebx,eax
  21ac70:	e9 50 01 00 00       	jmp    21adc5 <__udivmoddi4+0x355>
        q[high] = n[low] << @intCast(Log2SingleInt, SingleInt.bit_count - sr);
  21ac75:	b8 1f 00 00 00       	mov    eax,0x1f
  21ac7a:	29 c8                	sub    eax,ecx
        sr += 1;
  21ac7c:	83 c1 01             	add    ecx,0x1
        q[high] = n[low] << @intCast(Log2SingleInt, SingleInt.bit_count - sr);
  21ac7f:	83 e0 1f             	and    eax,0x1f
        r[high] = n[high] >> @intCast(Log2SingleInt, sr);
  21ac82:	89 cd                	mov    ebp,ecx
  21ac84:	83 e5 1f             	and    ebp,0x1f
  21ac87:	c4 e2 53 f7 d3       	shrx   edx,ebx,ebp
        r[low] = (n[high] << @intCast(Log2SingleInt, SingleInt.bit_count - sr)) | (n[low] >> @intCast(Log2SingleInt, sr));
  21ac8c:	c4 e2 79 f7 fb       	shlx   edi,ebx,eax
  21ac91:	c4 c2 53 f7 da       	shrx   ebx,r10d,ebp
        q[high] = n[low] << @intCast(Log2SingleInt, SingleInt.bit_count - sr);
  21ac96:	c4 c2 79 f7 ea       	shlx   ebp,r10d,eax
        r[low] = (n[high] << @intCast(Log2SingleInt, SingleInt.bit_count - sr)) | (n[low] >> @intCast(Log2SingleInt, sr));
  21ac9b:	09 fb                	or     ebx,edi
  21ac9d:	45 31 ff             	xor    r15d,r15d
  21aca0:	41 89 ea             	mov    r10d,ebp
  21aca3:	eb 17                	jmp    21acbc <__udivmoddi4+0x24c>
                q[high] = (n[high] << @intCast(Log2SingleInt, DoubleInt.bit_count - sr)) | (n[low] >> @intCast(Log2SingleInt, sr - SingleInt.bit_count));
  21aca5:	c4 e2 51 f7 eb       	shlx   ebp,ebx,ebp
  21acaa:	89 c8                	mov    eax,ecx
  21acac:	83 e0 1f             	and    eax,0x1f
  21acaf:	c4 42 7b f7 d2       	shrx   r10d,r10d,eax
  21acb4:	41 09 ea             	or     r10d,ebp
                r[low] = n[high] >> @intCast(Log2SingleInt, sr - SingleInt.bit_count);
  21acb7:	c4 e2 7b f7 db       	shrx   ebx,ebx,eax
  21acbc:	4c 8d 4e ff          	lea    r9,[rsi-0x1]
    while (sr > 0) : (sr -= 1) {
  21acc0:	41 89 cb             	mov    r11d,ecx
  21acc3:	41 83 e3 01          	and    r11d,0x1
  21acc7:	83 f9 01             	cmp    ecx,0x1
  21acca:	75 10                	jne    21acdc <__udivmoddi4+0x26c>
  21accc:	31 c9                	xor    ecx,ecx
  21acce:	45 85 db             	test   r11d,r11d
  21acd1:	0f 85 9e 00 00 00    	jne    21ad75 <__udivmoddi4+0x305>
  21acd7:	e9 c9 00 00 00       	jmp    21ada5 <__udivmoddi4+0x335>
  21acdc:	45 89 dc             	mov    r12d,r11d
  21acdf:	41 29 cc             	sub    r12d,ecx
  21ace2:	31 c9                	xor    ecx,ecx
  21ace4:	41 be 1e 01 00 00    	mov    r14d,0x11e
  21acea:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
        // r:q = ((r:q)  << 1) | carry
        r[high] = (r[high] << 1) | (r[low] >> (SingleInt.bit_count - 1));
  21acf0:	0f a4 da 01          	shld   edx,ebx,0x1
        r[low] = (r[low] << 1) | (q[high] >> (SingleInt.bit_count - 1));
  21acf4:	44 0f a4 d3 01       	shld   ebx,r10d,0x1
  21acf9:	c4 c2 08 f7 ea       	bextr  ebp,r10d,r14d
        q[high] = (q[high] << 1) | (q[low] >> (SingleInt.bit_count - 1));
  21acfe:	45 0f a4 fa 01       	shld   r10d,r15d,0x1
        q[low] = (q[low] << 1) | carry;
  21ad03:	43 8d 04 3f          	lea    eax,[r15+r15*1]
  21ad07:	09 c8                	or     eax,ecx
        // if (r.all >= b)
        // {
        //     r.all -= b;
        //      carry = 1;
        // }
        r_all = @ptrCast(*align(@alignOf(SingleInt)) DoubleInt, &r[0]).*; // TODO issue #421
  21ad09:	48 c1 e2 20          	shl    rdx,0x20
  21ad0d:	48 09 d3             	or     rbx,rdx
        const s: SignedDoubleInt = @intCast(SignedDoubleInt, b -% r_all -% 1) >> (DoubleInt.bit_count - 1);
  21ad10:	4c 89 c9             	mov    rcx,r9
  21ad13:	48 29 d9             	sub    rcx,rbx
  21ad16:	48 c1 f9 3f          	sar    rcx,0x3f
        carry = @intCast(u32, s & 1);
  21ad1a:	89 ca                	mov    edx,ecx
  21ad1c:	83 e2 01             	and    edx,0x1
        r_all -= b & @bitCast(DoubleInt, s);
  21ad1f:	48 21 f1             	and    rcx,rsi
  21ad22:	48 29 cb             	sub    rbx,rcx
        r[high] = (r[high] << 1) | (r[low] >> (SingleInt.bit_count - 1));
  21ad25:	48 89 d9             	mov    rcx,rbx
  21ad28:	48 c1 e9 1f          	shr    rcx,0x1f
  21ad2c:	83 e1 fe             	and    ecx,0xfffffffe
  21ad2f:	89 df                	mov    edi,ebx
  21ad31:	c1 ef 1f             	shr    edi,0x1f
  21ad34:	09 cf                	or     edi,ecx
        q[high] = (q[high] << 1) | (q[low] >> (SingleInt.bit_count - 1));
  21ad36:	c4 c2 08 f7 cf       	bextr  ecx,r15d,r14d
        r[low] = (r[low] << 1) | (q[high] >> (SingleInt.bit_count - 1));
  21ad3b:	8d 5c 5d 00          	lea    ebx,[rbp+rbx*2+0x0]
        q[high] = (q[high] << 1) | (q[low] >> (SingleInt.bit_count - 1));
  21ad3f:	46 8d 14 51          	lea    r10d,[rcx+r10*2]
        q[low] = (q[low] << 1) | carry;
  21ad43:	44 8d 3c 42          	lea    r15d,[rdx+rax*2]
        r_all = @ptrCast(*align(@alignOf(SingleInt)) DoubleInt, &r[0]).*; // TODO issue #421
  21ad47:	48 c1 e7 20          	shl    rdi,0x20
  21ad4b:	48 09 fb             	or     rbx,rdi
        const s: SignedDoubleInt = @intCast(SignedDoubleInt, b -% r_all -% 1) >> (DoubleInt.bit_count - 1);
  21ad4e:	4c 89 c8             	mov    rax,r9
  21ad51:	48 29 d8             	sub    rax,rbx
  21ad54:	48 c1 f8 3f          	sar    rax,0x3f
        carry = @intCast(u32, s & 1);
  21ad58:	89 c1                	mov    ecx,eax
  21ad5a:	83 e1 01             	and    ecx,0x1
        r_all -= b & @bitCast(DoubleInt, s);
  21ad5d:	48 21 f0             	and    rax,rsi
  21ad60:	48 29 c3             	sub    rbx,rax
        r = @ptrCast(*[2]SingleInt, &r_all).*; // TODO issue #421
  21ad63:	48 89 da             	mov    rdx,rbx
  21ad66:	48 c1 ea 20          	shr    rdx,0x20
    while (sr > 0) : (sr -= 1) {
  21ad6a:	41 83 c4 02          	add    r12d,0x2
  21ad6e:	75 80                	jne    21acf0 <__udivmoddi4+0x280>
  21ad70:	45 85 db             	test   r11d,r11d
  21ad73:	74 30                	je     21ada5 <__udivmoddi4+0x335>
        r[high] = (r[high] << 1) | (r[low] >> (SingleInt.bit_count - 1));
  21ad75:	0f a4 da 01          	shld   edx,ebx,0x1
        r[low] = (r[low] << 1) | (q[high] >> (SingleInt.bit_count - 1));
  21ad79:	44 0f a4 d3 01       	shld   ebx,r10d,0x1
        r_all = @ptrCast(*align(@alignOf(SingleInt)) DoubleInt, &r[0]).*; // TODO issue #421
  21ad7e:	48 c1 e2 20          	shl    rdx,0x20
  21ad82:	48 09 d3             	or     rbx,rdx
        const s: SignedDoubleInt = @intCast(SignedDoubleInt, b -% r_all -% 1) >> (DoubleInt.bit_count - 1);
  21ad85:	49 29 d9             	sub    r9,rbx
  21ad88:	49 c1 f9 3f          	sar    r9,0x3f
        r_all -= b & @bitCast(DoubleInt, s);
  21ad8c:	4c 21 ce             	and    rsi,r9
  21ad8f:	48 29 f3             	sub    rbx,rsi
        carry = @intCast(u32, s & 1);
  21ad92:	41 83 e1 01          	and    r9d,0x1
        q[high] = (q[high] << 1) | (q[low] >> (SingleInt.bit_count - 1));
  21ad96:	45 0f a4 fa 01       	shld   r10d,r15d,0x1
        q[low] = (q[low] << 1) | carry;
  21ad9b:	42 8d 04 79          	lea    eax,[rcx+r15*2]
  21ad9f:	41 89 c7             	mov    r15d,eax
  21ada2:	44 89 c9             	mov    ecx,r9d
    }
    const q_all = ((@ptrCast(*align(@alignOf(SingleInt)) DoubleInt, &q[0]).*) << 1) | carry; // TODO issue #421
  21ada5:	89 ca                	mov    edx,ecx
  21ada7:	44 89 f9             	mov    ecx,r15d
  21adaa:	45 89 d7             	mov    r15d,r10d
  21adad:	49 c1 e7 20          	shl    r15,0x20
  21adb1:	49 09 cf             	or     r15,rcx
  21adb4:	4d 01 ff             	add    r15,r15
  21adb7:	4d 89 fa             	mov    r10,r15
  21adba:	49 09 d2             	or     r10,rdx
    if (maybe_rem) |rem| {
  21adbd:	4d 85 c0             	test   r8,r8
  21adc0:	74 03                	je     21adc5 <__udivmoddi4+0x355>
        rem.* = r_all;
  21adc2:	49 89 18             	mov    QWORD PTR [r8],rbx
    @setRuntimeSafety(builtin.is_test);
    return udivmod(u64, a, b, maybe_rem);
  21adc5:	4c 89 d0             	mov    rax,r10
  21adc8:	5b                   	pop    rbx
  21adc9:	41 5c                	pop    r12
  21adcb:	41 5e                	pop    r14
  21adcd:	41 5f                	pop    r15
  21adcf:	5d                   	pop    rbp
  21add0:	c3                   	ret    
  21add1:	31 c9                	xor    ecx,ecx
  21add3:	eb d8                	jmp    21adad <__udivmoddi4+0x33d>
  21add5:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21addc:	00 00 00 00 

000000000021ade0 <__cmptf2>:
const is_test = builtin.is_test;

pub extern fn __letf2(a: f128, b: f128) c_int {
    @setRuntimeSafety(is_test);

    const aInt = @bitCast(rep_t, a);
  21ade0:	66 0f 7f 44 24 e8    	movdqa XMMWORD PTR [rsp-0x18],xmm0
  21ade6:	4c 8b 5c 24 e8       	mov    r11,QWORD PTR [rsp-0x18]
  21adeb:	4c 8b 44 24 f0       	mov    r8,QWORD PTR [rsp-0x10]
    const bInt = @bitCast(rep_t, b);
  21adf0:	66 0f 7f 4c 24 d8    	movdqa XMMWORD PTR [rsp-0x28],xmm1

    const aAbs: rep_t = aInt & absMask;
  21adf6:	40 b6 3f             	mov    sil,0x3f
  21adf9:	c4 c2 c8 f5 c8       	bzhi   rcx,r8,rsi
    const bAbs: rep_t = bInt & absMask;

    // If either a or b is NaN, they are unordered.
    if (aAbs > infRep or bAbs > infRep) return LE_UNORDERED;
  21adfe:	4c 89 d8             	mov    rax,r11
  21ae01:	48 f7 d8             	neg    rax
  21ae04:	49 ba 00 00 00 00 00 	movabs r10,0x7fff000000000000
  21ae0b:	00 ff 7f 
  21ae0e:	4c 89 d0             	mov    rax,r10
  21ae11:	48 19 c8             	sbb    rax,rcx
  21ae14:	b8 01 00 00 00       	mov    eax,0x1
  21ae19:	72 68                	jb     21ae83 <__cmptf2+0xa3>
  21ae1b:	48 8b 7c 24 d8       	mov    rdi,QWORD PTR [rsp-0x28]
  21ae20:	4c 8b 4c 24 e0       	mov    r9,QWORD PTR [rsp-0x20]
  21ae25:	c4 c2 c8 f5 d1       	bzhi   rdx,r9,rsi
  21ae2a:	48 83 ff 01          	cmp    rdi,0x1
  21ae2e:	48 89 d6             	mov    rsi,rdx
  21ae31:	4c 19 d6             	sbb    rsi,r10
  21ae34:	73 4d                	jae    21ae83 <__cmptf2+0xa3>

    // If a and b are both zeros, they are equal.
    if ((aAbs | bAbs) == 0) return LE_EQUAL;
  21ae36:	48 89 f8             	mov    rax,rdi
  21ae39:	4c 09 d8             	or     rax,r11
  21ae3c:	48 09 ca             	or     rdx,rcx
  21ae3f:	48 09 c2             	or     rdx,rax
  21ae42:	74 40                	je     21ae84 <__cmptf2+0xa4>
  21ae44:	b8 ff ff ff ff       	mov    eax,0xffffffff

    // If at least one of a and b is positive, we get the same result comparing
    // a and b as signed integers as we would with a floating-point compare.
    return if ((aInt & bInt) >= 0) if (aInt < bInt)
  21ae49:	49 39 fb             	cmp    r11,rdi
  21ae4c:	4c 89 c1             	mov    rcx,r8
  21ae4f:	4c 19 c9             	sbb    rcx,r9
  21ae52:	72 2f                	jb     21ae83 <__cmptf2+0xa3>
        LE_LESS
    else if (aInt == bInt)
  21ae54:	c4 e1 f9 6e c7       	vmovq  xmm0,rdi
  21ae59:	c4 c1 f9 6e c9       	vmovq  xmm1,r9
  21ae5e:	c5 f9 6c c1          	vpunpcklqdq xmm0,xmm0,xmm1
  21ae62:	c4 c1 f9 6e cb       	vmovq  xmm1,r11
  21ae67:	c4 c1 f9 6e d0       	vmovq  xmm2,r8
  21ae6c:	c5 f1 6c ca          	vpunpcklqdq xmm1,xmm1,xmm2
  21ae70:	c5 f1 74 c0          	vpcmpeqb xmm0,xmm1,xmm0
  21ae74:	c5 f9 d7 c8          	vpmovmskb ecx,xmm0
  21ae78:	31 c0                	xor    eax,eax
  21ae7a:	81 f9 ff ff 00 00    	cmp    ecx,0xffff
  21ae80:	0f 95 c0             	setne  al
    if (aAbs > infRep or bAbs > infRep) return LE_UNORDERED;
  21ae83:	c3                   	ret    
  21ae84:	31 c0                	xor    eax,eax
  21ae86:	c3                   	ret    
  21ae87:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  21ae8e:	00 00 

000000000021ae90 <__gttf2>:
const GE_UNORDERED = c_int(-1); // Note: different from LE_UNORDERED

pub extern fn __getf2(a: f128, b: f128) c_int {
    @setRuntimeSafety(is_test);

    const aInt = @bitCast(srep_t, a);
  21ae90:	53                   	push   rbx
  21ae91:	0f 29 44 24 f0       	movaps XMMWORD PTR [rsp-0x10],xmm0
  21ae96:	4c 8b 54 24 f0       	mov    r10,QWORD PTR [rsp-0x10]
  21ae9b:	4c 8b 44 24 f8       	mov    r8,QWORD PTR [rsp-0x8]
    const bInt = @bitCast(srep_t, b);
  21aea0:	0f 29 4c 24 e0       	movaps XMMWORD PTR [rsp-0x20],xmm1
    const aAbs = @bitCast(rep_t, aInt) & absMask;
  21aea5:	41 b1 3f             	mov    r9b,0x3f
  21aea8:	c4 c2 b0 f5 c8       	bzhi   rcx,r8,r9
    const bAbs = @bitCast(rep_t, bInt) & absMask;

    if (aAbs > infRep or bAbs > infRep) return GE_UNORDERED;
  21aead:	4c 89 d0             	mov    rax,r10
  21aeb0:	48 f7 d8             	neg    rax
  21aeb3:	48 bb 00 00 00 00 00 	movabs rbx,0x7fff000000000000
  21aeba:	00 ff 7f 
  21aebd:	48 89 d8             	mov    rax,rbx
  21aec0:	48 19 c8             	sbb    rax,rcx
  21aec3:	b8 ff ff ff ff       	mov    eax,0xffffffff
  21aec8:	72 39                	jb     21af03 <__gttf2+0x73>
  21aeca:	48 8b 7c 24 e0       	mov    rdi,QWORD PTR [rsp-0x20]
  21aecf:	4c 8b 5c 24 e8       	mov    r11,QWORD PTR [rsp-0x18]
  21aed4:	c4 c2 b0 f5 f3       	bzhi   rsi,r11,r9
  21aed9:	48 83 ff 01          	cmp    rdi,0x1
  21aedd:	48 89 f2             	mov    rdx,rsi
  21aee0:	48 19 da             	sbb    rdx,rbx
  21aee3:	73 1e                	jae    21af03 <__gttf2+0x73>
    if ((aAbs | bAbs) == 0) return GE_EQUAL;
  21aee5:	48 89 fa             	mov    rdx,rdi
  21aee8:	4c 09 d2             	or     rdx,r10
  21aeeb:	48 09 ce             	or     rsi,rcx
  21aeee:	48 09 d6             	or     rsi,rdx
  21aef1:	74 12                	je     21af05 <__gttf2+0x75>
    return if ((aInt & bInt) >= 0) if (aInt < bInt)
  21aef3:	4d 85 c3             	test   r11,r8
  21aef6:	78 11                	js     21af09 <__gttf2+0x79>
  21aef8:	49 39 fa             	cmp    r10,rdi
  21aefb:	4c 89 c1             	mov    rcx,r8
  21aefe:	4c 19 d9             	sbb    rcx,r11
  21af01:	7d 11                	jge    21af14 <__gttf2+0x84>
    if (aAbs > infRep or bAbs > infRep) return GE_UNORDERED;
  21af03:	5b                   	pop    rbx
  21af04:	c3                   	ret    
  21af05:	31 c0                	xor    eax,eax
  21af07:	5b                   	pop    rbx
  21af08:	c3                   	ret    
        GE_LESS
    else if (aInt == bInt)
        GE_EQUAL
    else
        GE_GREATER else if (aInt > bInt)
  21af09:	4c 39 d7             	cmp    rdi,r10
  21af0c:	4c 89 d9             	mov    rcx,r11
  21af0f:	4c 19 c1             	sbb    rcx,r8
  21af12:	7c ef                	jl     21af03 <__gttf2+0x73>
  21af14:	c4 e1 f9 6e c7       	vmovq  xmm0,rdi
  21af19:	c4 c1 f9 6e cb       	vmovq  xmm1,r11
  21af1e:	c5 f9 6c c1          	vpunpcklqdq xmm0,xmm0,xmm1
  21af22:	c4 c1 f9 6e ca       	vmovq  xmm1,r10
  21af27:	c4 c1 f9 6e d0       	vmovq  xmm2,r8
  21af2c:	c5 f1 6c ca          	vpunpcklqdq xmm1,xmm1,xmm2
  21af30:	c5 f1 74 c0          	vpcmpeqb xmm0,xmm1,xmm0
  21af34:	c5 f9 d7 c8          	vpmovmskb ecx,xmm0
  21af38:	31 c0                	xor    eax,eax
  21af3a:	81 f9 ff ff 00 00    	cmp    ecx,0xffff
  21af40:	0f 95 c0             	setne  al
    if (aAbs > infRep or bAbs > infRep) return GE_UNORDERED;
  21af43:	5b                   	pop    rbx
  21af44:	c3                   	ret    
  21af45:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21af4c:	00 00 00 00 

000000000021af50 <__extendhfsf2>:

    const dstMinNormal: dst_rep_t = dst_rep_t(1) << dstSigBits;

    // Break a into a sign and representation of the absolute value
    const aRep: src_rep_t = @bitCast(src_rep_t, a);
    const aAbs: src_rep_t = aRep & srcAbsMask;
  21af50:	89 f9                	mov    ecx,edi
  21af52:	81 e1 ff 7f 00 00    	and    ecx,0x7fff
    const sign: src_rep_t = aRep & srcSignMask;
  21af58:	89 f8                	mov    eax,edi
  21af5a:	25 00 80 00 00       	and    eax,0x8000
    var absResult: dst_rep_t = undefined;

    if (aAbs -% srcMinNormal < srcInfinity - srcMinNormal) {
  21af5f:	89 ca                	mov    edx,ecx
  21af61:	81 c2 00 fc ff ff    	add    edx,0xfffffc00
  21af67:	0f b7 d2             	movzx  edx,dx
  21af6a:	81 fa ff 77 00 00    	cmp    edx,0x77ff
  21af70:	77 16                	ja     21af88 <__extendhfsf2+0x38>
        // a is a normal number.
        // Extend to the destination type by shifting the significand and
        // exponent into the proper position and rebiasing the exponent.
        absResult = dst_rep_t(aAbs) << (dstSigBits - srcSigBits);
  21af72:	0f b7 c9             	movzx  ecx,cx
  21af75:	c1 e1 0d             	shl    ecx,0xd
        absResult += (dstExpBias - srcExpBias) << dstSigBits;
  21af78:	81 c1 00 00 00 38    	add    ecx,0x38000000
        // a is zero.
        absResult = 0;
    }

    // Apply the signbit to (dst_t)abs(a).
    const result: dst_rep_t align(@alignOf(dst_t)) = absResult | dst_rep_t(sign) << (dstBits - srcBits);
  21af7e:	c1 e0 10             	shl    eax,0x10
  21af81:	09 c8                	or     eax,ecx
    return @bitCast(dst_t, result);
  21af83:	c5 f9 6e c0          	vmovd  xmm0,eax
    return extendXfYf2(f32, f16, @bitCast(f16, a));
  21af87:	c3                   	ret    
    } else if (aAbs >= srcInfinity) {
  21af88:	0f b7 d1             	movzx  edx,cx
  21af8b:	81 fa 00 7c 00 00    	cmp    edx,0x7c00
  21af91:	72 16                	jb     21afa9 <__extendhfsf2+0x59>
        absResult |= dst_rep_t(aAbs & srcNaNCode) << (dstSigBits - srcSigBits);
  21af93:	0f b7 cf             	movzx  ecx,di
  21af96:	c1 e1 0d             	shl    ecx,0xd
  21af99:	81 c9 00 00 80 7f    	or     ecx,0x7f800000
    const result: dst_rep_t align(@alignOf(dst_t)) = absResult | dst_rep_t(sign) << (dstBits - srcBits);
  21af9f:	c1 e0 10             	shl    eax,0x10
  21afa2:	09 c8                	or     eax,ecx
    return @bitCast(dst_t, result);
  21afa4:	c5 f9 6e c0          	vmovd  xmm0,eax
    return extendXfYf2(f32, f16, @bitCast(f16, a));
  21afa8:	c3                   	ret    
    } else if (aAbs != 0) {
  21afa9:	66 85 c9             	test   cx,cx
  21afac:	74 2f                	je     21afdd <__extendhfsf2+0x8d>
        const scale: u32 = @clz(aAbs) - @clz(src_rep_t(srcMinNormal));
  21afae:	66 f3 0f bd c9       	lzcnt  cx,cx
  21afb3:	8d 71 1b             	lea    esi,[rcx+0x1b]
  21afb6:	83 e6 1f             	and    esi,0x1f
        absResult = dst_rep_t(aAbs) << @intCast(DstShift, dstSigBits - srcSigBits + scale);
  21afb9:	83 c1 08             	add    ecx,0x8
  21afbc:	c4 e2 71 f7 d2       	shlx   edx,edx,ecx
        absResult ^= dstMinNormal;
  21afc1:	81 f2 00 00 80 00    	xor    edx,0x800000
        absResult |= @intCast(dst_rep_t, resultExponent) << dstSigBits;
  21afc7:	c1 e6 17             	shl    esi,0x17
  21afca:	b9 00 00 80 38       	mov    ecx,0x38800000
  21afcf:	29 f1                	sub    ecx,esi
  21afd1:	09 d1                	or     ecx,edx
    const result: dst_rep_t align(@alignOf(dst_t)) = absResult | dst_rep_t(sign) << (dstBits - srcBits);
  21afd3:	c1 e0 10             	shl    eax,0x10
  21afd6:	09 c8                	or     eax,ecx
    return @bitCast(dst_t, result);
  21afd8:	c5 f9 6e c0          	vmovd  xmm0,eax
    return extendXfYf2(f32, f16, @bitCast(f16, a));
  21afdc:	c3                   	ret    
  21afdd:	31 c9                	xor    ecx,ecx
    const result: dst_rep_t align(@alignOf(dst_t)) = absResult | dst_rep_t(sign) << (dstBits - srcBits);
  21afdf:	c1 e0 10             	shl    eax,0x10
  21afe2:	09 c8                	or     eax,ecx
    return @bitCast(dst_t, result);
  21afe4:	c5 f9 6e c0          	vmovd  xmm0,eax
    return extendXfYf2(f32, f16, @bitCast(f16, a));
  21afe8:	c3                   	ret    
  21afe9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

000000000021aff0 <__truncsfhf2>:

    const dstQNaN = 1 << (dstSigBits - 1);
    const dstNaNCode = dstQNaN - 1;

    // Break a into a sign and representation of the absolute value
    const aRep: src_rep_t = @bitCast(src_rep_t, a);
  21aff0:	c5 f9 7e c2          	vmovd  edx,xmm0
    const aAbs: src_rep_t = aRep & srcAbsMask;
  21aff4:	89 d6                	mov    esi,edx
  21aff6:	81 e6 ff ff ff 7f    	and    esi,0x7fffffff
    const sign: src_rep_t = aRep & srcSignMask;
    var absResult: dst_rep_t = undefined;

    if (aAbs -% underflow < aAbs -% overflow) {
  21affc:	8d 86 00 00 80 c7    	lea    eax,[rsi-0x38800000]
  21b002:	8d 8e 00 00 80 b8    	lea    ecx,[rsi-0x47800000]
  21b008:	39 c8                	cmp    eax,ecx
  21b00a:	73 1f                	jae    21b02b <__truncsfhf2+0x3b>
        // The exponent of a is within the range of normal numbers in the
        // destination format.  We can convert by simply right-shifting with
        // rounding and adjusting the exponent.
        absResult = @truncate(dst_rep_t, aAbs >> (srcSigBits - dstSigBits));
  21b00c:	89 d0                	mov    eax,edx
  21b00e:	c1 e8 0d             	shr    eax,0xd
        absResult -%= dst_rep_t(srcExpBias - dstExpBias) << dstSigBits;

        const roundBits: src_rep_t = aAbs & roundMask;
  21b011:	89 d1                	mov    ecx,edx
  21b013:	81 e1 ff 1f 00 00    	and    ecx,0x1fff
        if (roundBits > halfway) {
  21b019:	81 f9 01 10 00 00    	cmp    ecx,0x1001
  21b01f:	72 23                	jb     21b044 <__truncsfhf2+0x54>
            // Round to nearest
            absResult += 1;
  21b021:	05 01 40 00 00       	add    eax,0x4001
  21b026:	e9 83 00 00 00       	jmp    21b0ae <__truncsfhf2+0xbe>
        } else if (roundBits == halfway) {
            // Ties to even
            absResult += absResult & 1;
        }
    } else if (aAbs > srcInfinity) {
  21b02b:	81 fe 01 00 80 7f    	cmp    esi,0x7f800001
  21b031:	72 29                	jb     21b05c <__truncsfhf2+0x6c>
        // a is NaN.
        // Conjure the result by beginning with infinity, setting the qNaN
        // bit and inserting the (truncated) trailing NaN field.
        absResult = @intCast(dst_rep_t, dstInfExp) << dstSigBits;
        absResult |= dstQNaN;
        absResult |= @intCast(dst_rep_t, ((aAbs & srcNaNCode) >> (srcSigBits - dstSigBits)) & dstNaNCode);
  21b033:	b8 0d 09 00 00       	mov    eax,0x90d
  21b038:	c4 e2 78 f7 c2       	bextr  eax,edx,eax
  21b03d:	0d 00 7e 00 00       	or     eax,0x7e00
  21b042:	eb 6a                	jmp    21b0ae <__truncsfhf2+0xbe>
  21b044:	05 00 40 00 00       	add    eax,0x4000
        } else if (roundBits == halfway) {
  21b049:	81 f9 00 10 00 00    	cmp    ecx,0x1000
  21b04f:	75 5d                	jne    21b0ae <__truncsfhf2+0xbe>
  21b051:	89 c1                	mov    ecx,eax
  21b053:	83 e1 01             	and    ecx,0x1
  21b056:	01 c1                	add    ecx,eax
  21b058:	89 c8                	mov    eax,ecx
  21b05a:	eb 52                	jmp    21b0ae <__truncsfhf2+0xbe>
  21b05c:	66 b8 00 7c          	mov    ax,0x7c00
    } else if (aAbs >= overflow) {
  21b060:	81 fe ff ff 7f 47    	cmp    esi,0x477fffff
  21b066:	77 46                	ja     21b0ae <__truncsfhf2+0xbe>
        absResult = @intCast(dst_rep_t, dstInfExp) << dstSigBits;
    } else {
        // a underflows on conversion to the destination type or is an exact
        // zero.  The result may be a denormal or zero.  Extract the exponent
        // to get the shift amount for the denormalization.
        const aExp = @intCast(u32, aAbs >> srcSigBits);
  21b068:	c1 ee 17             	shr    esi,0x17
        const shift = @intCast(u32, srcExpBias - dstExpBias - aExp + 1);
  21b06b:	b9 70 00 00 00       	mov    ecx,0x70
  21b070:	29 f1                	sub    ecx,esi

        const significand: src_rep_t = (aRep & srcSignificandMask) | srcMinNormal;

        // Right shift by the denormalization amount with sticky.
        if (shift > srcSigBits) {
  21b072:	83 f9 16             	cmp    ecx,0x16
  21b075:	76 04                	jbe    21b07b <__truncsfhf2+0x8b>
  21b077:	31 c0                	xor    eax,eax
  21b079:	eb 33                	jmp    21b0ae <__truncsfhf2+0xbe>
  21b07b:	89 d6                	mov    esi,edx
  21b07d:	81 e6 ff ff 7f 00    	and    esi,0x7fffff
  21b083:	81 ce 00 00 80 00    	or     esi,0x800000
        const shift = @intCast(u32, srcExpBias - dstExpBias - aExp + 1);
  21b089:	83 c1 01             	add    ecx,0x1
            absResult = 0;
        } else {
            const sticky: src_rep_t = significand << @intCast(SrcShift, srcBits - shift);
            const denormalizedSignificand: src_rep_t = significand >> @intCast(SrcShift, shift) | sticky;
  21b08c:	d3 ce                	ror    esi,cl
            absResult = @intCast(dst_rep_t, denormalizedSignificand >> (srcSigBits - dstSigBits));
  21b08e:	89 f0                	mov    eax,esi
  21b090:	c1 e8 0d             	shr    eax,0xd
            const roundBits: src_rep_t = denormalizedSignificand & roundMask;
  21b093:	81 e6 ff 1f 00 00    	and    esi,0x1fff
            if (roundBits > halfway) {
  21b099:	81 fe 01 10 00 00    	cmp    esi,0x1001
  21b09f:	72 05                	jb     21b0a6 <__truncsfhf2+0xb6>
                // Round to nearest
                absResult += 1;
  21b0a1:	83 c0 01             	add    eax,0x1
  21b0a4:	eb 08                	jmp    21b0ae <__truncsfhf2+0xbe>
            } else if (roundBits == halfway) {
  21b0a6:	81 fe 00 10 00 00    	cmp    esi,0x1000
  21b0ac:	74 a3                	je     21b051 <__truncsfhf2+0x61>
                absResult += absResult & 1;
            }
        }
    }

    const result: dst_rep_t align(@alignOf(dst_t)) = absResult | @truncate(dst_rep_t, sign >> @intCast(SrcShift, srcBits - dstBits));
  21b0ae:	c1 ea 10             	shr    edx,0x10
  21b0b1:	81 e2 00 80 00 00    	and    edx,0x8000
  21b0b7:	09 d0                	or     eax,edx
    return @bitCast(u16, truncXfYf2(f16, f32, a));
  21b0b9:	c3                   	ret    
  21b0ba:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

000000000021b0c0 <__unordtf2>:
}

pub extern fn __unordtf2(a: f128, b: f128) c_int {
    @setRuntimeSafety(is_test);

    const aAbs = @bitCast(rep_t, a) & absMask;
  21b0c0:	0f 29 44 24 e8       	movaps XMMWORD PTR [rsp-0x18],xmm0
  21b0c5:	b0 3f                	mov    al,0x3f
  21b0c7:	c4 e2 f8 f5 4c 24 f0 	bzhi   rcx,QWORD PTR [rsp-0x10],rax
    const bAbs = @bitCast(rep_t, b) & absMask;
  21b0ce:	0f 29 4c 24 d8       	movaps XMMWORD PTR [rsp-0x28],xmm1
  21b0d3:	c4 e2 f8 f5 44 24 e0 	bzhi   rax,QWORD PTR [rsp-0x20],rax
    return @boolToInt(aAbs > infRep or bAbs > infRep);
  21b0da:	31 d2                	xor    edx,edx
  21b0dc:	48 3b 54 24 e8       	cmp    rdx,QWORD PTR [rsp-0x18]
  21b0e1:	48 be 00 00 00 00 00 	movabs rsi,0x7fff000000000000
  21b0e8:	00 ff 7f 
  21b0eb:	48 89 f7             	mov    rdi,rsi
  21b0ee:	48 19 cf             	sbb    rdi,rcx
  21b0f1:	0f 92 c1             	setb   cl
  21b0f4:	48 3b 54 24 d8       	cmp    rdx,QWORD PTR [rsp-0x28]
  21b0f9:	48 19 c6             	sbb    rsi,rax
  21b0fc:	0f 92 c0             	setb   al
  21b0ff:	08 c8                	or     al,cl
  21b101:	0f b6 c0             	movzx  eax,al
  21b104:	c3                   	ret    
  21b105:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21b10c:	00 00 00 00 

000000000021b110 <__floattitf>:
const LDBL_MANT_DIG = 113;

pub extern fn __floattitf(arg: i128) f128 {
    @setRuntimeSafety(is_test);

    if (arg == 0)
  21b110:	48 89 f8             	mov    rax,rdi
  21b113:	48 09 f0             	or     rax,rsi
  21b116:	0f 84 ba 00 00 00    	je     21b1d6 <__floattitf+0xc6>
        return 0.0;

    var ai = arg;
    const N: u32 = 128;
    const si = ai >> @intCast(u7, (N - 1));
  21b11c:	41 57                	push   r15
  21b11e:	41 56                	push   r14
  21b120:	53                   	push   rbx
  21b121:	48 89 f0             	mov    rax,rsi
  21b124:	48 c1 f8 3f          	sar    rax,0x3f
    ai = ((ai ^ si) -% si);
  21b128:	48 89 c2             	mov    rdx,rax
  21b12b:	48 31 f2             	xor    rdx,rsi
  21b12e:	48 31 c7             	xor    rdi,rax
  21b131:	48 29 c7             	sub    rdi,rax
  21b134:	48 19 c2             	sbb    rdx,rax
    var a = @bitCast(u128, ai);

    const sd = @bitCast(i32, N - @clz(a)); // number of significant digits
  21b137:	f3 48 0f bd c2       	lzcnt  rax,rdx
  21b13c:	f3 48 0f bd cf       	lzcnt  rcx,rdi
  21b141:	83 c1 40             	add    ecx,0x40
  21b144:	48 85 d2             	test   rdx,rdx
  21b147:	0f 45 c8             	cmovne ecx,eax
  21b14a:	41 b9 80 00 00 00    	mov    r9d,0x80
  21b150:	41 29 c9             	sub    r9d,ecx
    var e: i32 = sd - 1; // exponent
  21b153:	41 ba 7f 00 00 00    	mov    r10d,0x7f
  21b159:	41 29 ca             	sub    r10d,ecx
    if (sd > LDBL_MANT_DIG) {
  21b15c:	41 83 f9 72          	cmp    r9d,0x72
  21b160:	7c 7c                	jl     21b1de <__floattitf+0xce>
        //                                                12345678901234567890123456
        //  1 = msb 1 bit
        //  P = bit LDBL_MANT_DIG-1 bits to the right of 1
        //  Q = bit LDBL_MANT_DIG bits to the right of 1
        //  R = "or" of all bits to the right of Q
        switch (sd) {
  21b162:	0f 84 99 00 00 00    	je     21b201 <__floattitf+0xf1>
  21b168:	41 83 f9 73          	cmp    r9d,0x73
  21b16c:	0f 84 97 00 00 00    	je     21b209 <__floattitf+0xf9>
            LDBL_MANT_DIG + 1 => {
                a <<= 1;
            },
            LDBL_MANT_DIG + 2 => {},
            else => {
                const shift1_amt = @intCast(i32, sd - (LDBL_MANT_DIG + 2));
  21b172:	41 8d 49 0d          	lea    ecx,[r9+0xd]
                const shift1_amt_u7 = @intCast(u7, shift1_amt);

                const shift2_amt = @intCast(i32, N + (LDBL_MANT_DIG + 2)) - sd;
  21b176:	41 b8 73 00 00 00    	mov    r8d,0x73
                const shift2_amt_u7 = @intCast(u7, shift2_amt);

                a = (a >> shift1_amt_u7) | @boolToInt((a & (@intCast(u128, @maxValue(u128)) >> shift2_amt_u7)) != 0);
  21b17c:	83 e1 7f             	and    ecx,0x7f
  21b17f:	49 89 ff             	mov    r15,rdi
  21b182:	49 0f ad d7          	shrd   r15,rdx,cl
                const shift2_amt = @intCast(i32, N + (LDBL_MANT_DIG + 2)) - sd;
  21b186:	45 29 c8             	sub    r8d,r9d
                a = (a >> shift1_amt_u7) | @boolToInt((a & (@intCast(u128, @maxValue(u128)) >> shift2_amt_u7)) != 0);
  21b189:	c4 62 f3 f7 da       	shrx   r11,rdx,rcx
  21b18e:	45 31 f6             	xor    r14d,r14d
  21b191:	f6 c1 40             	test   cl,0x40
  21b194:	4d 0f 45 fb          	cmovne r15,r11
  21b198:	4d 0f 45 de          	cmovne r11,r14
  21b19c:	41 83 e0 7f          	and    r8d,0x7f
  21b1a0:	48 c7 c3 ff ff ff ff 	mov    rbx,0xffffffffffffffff
  21b1a7:	c4 e2 bb f7 c3       	shrx   rax,rbx,r8
  21b1ac:	44 89 c1             	mov    ecx,r8d
  21b1af:	48 0f ad db          	shrd   rbx,rbx,cl
  21b1b3:	41 f6 c0 40          	test   r8b,0x40
  21b1b7:	48 0f 45 d8          	cmovne rbx,rax
  21b1bb:	49 0f 45 c6          	cmovne rax,r14
  21b1bf:	48 21 fb             	and    rbx,rdi
  21b1c2:	48 21 d0             	and    rax,rdx
  21b1c5:	31 ff                	xor    edi,edi
  21b1c7:	48 09 d8             	or     rax,rbx
  21b1ca:	40 0f 95 c7          	setne  dil
  21b1ce:	4c 09 ff             	or     rdi,r15
  21b1d1:	4c 89 da             	mov    rdx,r11
  21b1d4:	eb 33                	jmp    21b209 <__floattitf+0xf9>
        return 0.0;
  21b1d6:	0f 28 05 b3 b9 fe ff 	movaps xmm0,XMMWORD PTR [rip+0xfffffffffffeb9b3]        # 206b90 <__unnamed_7>
  21b1dd:	c3                   	ret    
            a >>= 1;
            e += 1;
        }
        // a is now rounded to LDBL_MANT_DIG bits
    } else {
        a <<= @intCast(u7, LDBL_MANT_DIG - sd);
  21b1de:	b9 71 00 00 00       	mov    ecx,0x71
  21b1e3:	44 29 c9             	sub    ecx,r9d
  21b1e6:	83 e1 7f             	and    ecx,0x7f
  21b1e9:	48 0f a5 fa          	shld   rdx,rdi,cl
  21b1ed:	c4 e2 f1 f7 ff       	shlx   rdi,rdi,rcx
  21b1f2:	31 c0                	xor    eax,eax
  21b1f4:	f6 c1 40             	test   cl,0x40
  21b1f7:	48 0f 45 d7          	cmovne rdx,rdi
  21b1fb:	48 0f 44 c7          	cmove  rax,rdi
  21b1ff:	eb 3b                	jmp    21b23c <__floattitf+0x12c>
                a <<= 1;
  21b201:	48 0f a4 fa 01       	shld   rdx,rdi,0x1
  21b206:	48 01 ff             	add    rdi,rdi
        a |= @boolToInt((a & 4) != 0); // Or P into R
  21b209:	b8 02 01 00 00       	mov    eax,0x102
  21b20e:	c4 e2 78 f7 c7       	bextr  eax,edi,eax
  21b213:	48 09 f8             	or     rax,rdi
        a += 1; // round - this step may add a significant bit
  21b216:	48 83 c0 01          	add    rax,0x1
  21b21a:	48 83 d2 00          	adc    rdx,0x0
        if ((a & (u128(1) << LDBL_MANT_DIG)) != 0) {
  21b21e:	48 0f ba e2 33       	bt     rdx,0x33
  21b223:	72 0b                	jb     21b230 <__floattitf+0x120>
  21b225:	48 0f ac d0 02       	shrd   rax,rdx,0x2
  21b22a:	48 c1 ea 02          	shr    rdx,0x2
  21b22e:	eb 0c                	jmp    21b23c <__floattitf+0x12c>
            a >>= 1;
  21b230:	48 0f ac d0 03       	shrd   rax,rdx,0x3
  21b235:	48 c1 ea 03          	shr    rdx,0x3
  21b239:	45 89 ca             	mov    r10d,r9d
        // a is now rounded to LDBL_MANT_DIG bits
    }

    const s = @bitCast(u128, arg) >> (128 - 64);
    const high: u128 = (@intCast(u64, s) & 0x8000000000000000) | // sign
  21b23c:	48 b9 00 00 00 00 00 	movabs rcx,0x8000000000000000
  21b243:	00 00 80 
  21b246:	48 21 ce             	and    rsi,rcx
        (@intCast(u64, (e + 16383)) << 48) | // exponent
  21b249:	41 81 c2 ff 3f 00 00 	add    r10d,0x3fff
  21b250:	49 c1 e2 30          	shl    r10,0x30
    const high: u128 = (@intCast(u64, s) & 0x8000000000000000) | // sign
  21b254:	49 09 f2             	or     r10,rsi
        (@truncate(u64, a >> 64) & 0x0000ffffffffffff); // mantissa-high
  21b257:	b1 30                	mov    cl,0x30
  21b259:	c4 e2 f0 f5 ca       	bzhi   rcx,rdx,rcx
    const low = @truncate(u64, a); // mantissa-low

    return @bitCast(f128, low | (high << 64));
  21b25e:	48 89 44 24 f0       	mov    QWORD PTR [rsp-0x10],rax
        (@intCast(u64, (e + 16383)) << 48) | // exponent
  21b263:	4c 09 d1             	or     rcx,r10
    return @bitCast(f128, low | (high << 64));
  21b266:	48 89 4c 24 f8       	mov    QWORD PTR [rsp-0x8],rcx
  21b26b:	0f 28 44 24 f0       	movaps xmm0,XMMWORD PTR [rsp-0x10]
  21b270:	5b                   	pop    rbx
  21b271:	41 5e                	pop    r14
  21b273:	41 5f                	pop    r15
  21b275:	c3                   	ret    
  21b276:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  21b27d:	00 00 00 

000000000021b280 <__floattidf>:
const DBL_MANT_DIG = 53;

pub extern fn __floattidf(arg: i128) f64 {
    @setRuntimeSafety(is_test);

    if (arg == 0)
  21b280:	48 89 f8             	mov    rax,rdi
  21b283:	48 09 f0             	or     rax,rsi
  21b286:	0f 84 b8 00 00 00    	je     21b344 <__floattidf+0xc4>
        return 0.0;

    var ai = arg;
    const N: u32 = 128;
    const si = ai >> @intCast(u7, (N - 1));
  21b28c:	41 57                	push   r15
  21b28e:	41 56                	push   r14
  21b290:	53                   	push   rbx
  21b291:	48 89 f0             	mov    rax,rsi
  21b294:	48 c1 f8 3f          	sar    rax,0x3f
    ai = ((ai ^ si) -% si);
  21b298:	48 89 c2             	mov    rdx,rax
  21b29b:	48 31 f2             	xor    rdx,rsi
  21b29e:	48 31 c7             	xor    rdi,rax
  21b2a1:	48 29 c7             	sub    rdi,rax
  21b2a4:	48 19 c2             	sbb    rdx,rax
    var a = @bitCast(u128, ai);

    const sd = @bitCast(i32, N - @clz(a)); // number of significant digits
  21b2a7:	f3 48 0f bd c2       	lzcnt  rax,rdx
  21b2ac:	f3 48 0f bd cf       	lzcnt  rcx,rdi
  21b2b1:	83 c1 40             	add    ecx,0x40
  21b2b4:	48 85 d2             	test   rdx,rdx
  21b2b7:	0f 45 c8             	cmovne ecx,eax
  21b2ba:	41 b9 80 00 00 00    	mov    r9d,0x80
  21b2c0:	41 29 c9             	sub    r9d,ecx
    var e: i32 = sd - 1; // exponent
  21b2c3:	b8 7f 00 00 00       	mov    eax,0x7f
  21b2c8:	29 c8                	sub    eax,ecx
    if (sd > DBL_MANT_DIG) {
  21b2ca:	41 83 f9 36          	cmp    r9d,0x36
  21b2ce:	7c 79                	jl     21b349 <__floattidf+0xc9>
        //                                                12345678901234567890123456
        //  1 = msb 1 bit
        //  P = bit DBL_MANT_DIG-1 bits to the right of 1
        //  Q = bit DBL_MANT_DIG bits to the right of 1
        //  R = "or" of all bits to the right of Q
        switch (sd) {
  21b2d0:	0f 84 9b 00 00 00    	je     21b371 <__floattidf+0xf1>
  21b2d6:	41 83 f9 37          	cmp    r9d,0x37
  21b2da:	0f 84 99 00 00 00    	je     21b379 <__floattidf+0xf9>
            DBL_MANT_DIG + 1 => {
                a <<= 1;
            },
            DBL_MANT_DIG + 2 => {},
            else => {
                const shift1_amt = @intCast(i32, sd - (DBL_MANT_DIG + 2));
  21b2e0:	41 8d 49 49          	lea    ecx,[r9+0x49]
                const shift1_amt_u7 = @intCast(u7, shift1_amt);

                const shift2_amt = @intCast(i32, N + (DBL_MANT_DIG + 2)) - sd;
  21b2e4:	41 b8 37 00 00 00    	mov    r8d,0x37
                const shift2_amt_u7 = @intCast(u7, shift2_amt);

                a = (a >> shift1_amt_u7) | @boolToInt((a & (@intCast(u128, @maxValue(u128)) >> shift2_amt_u7)) != 0);
  21b2ea:	83 e1 7f             	and    ecx,0x7f
  21b2ed:	49 89 fa             	mov    r10,rdi
  21b2f0:	49 0f ad d2          	shrd   r10,rdx,cl
                const shift2_amt = @intCast(i32, N + (DBL_MANT_DIG + 2)) - sd;
  21b2f4:	45 29 c8             	sub    r8d,r9d
                a = (a >> shift1_amt_u7) | @boolToInt((a & (@intCast(u128, @maxValue(u128)) >> shift2_amt_u7)) != 0);
  21b2f7:	c4 62 f3 f7 da       	shrx   r11,rdx,rcx
  21b2fc:	45 31 f6             	xor    r14d,r14d
  21b2ff:	f6 c1 40             	test   cl,0x40
  21b302:	4d 0f 45 d3          	cmovne r10,r11
  21b306:	4d 0f 45 de          	cmovne r11,r14
  21b30a:	41 83 e0 7f          	and    r8d,0x7f
  21b30e:	48 c7 c3 ff ff ff ff 	mov    rbx,0xffffffffffffffff
  21b315:	c4 62 bb f7 fb       	shrx   r15,rbx,r8
  21b31a:	44 89 c1             	mov    ecx,r8d
  21b31d:	48 0f ad db          	shrd   rbx,rbx,cl
  21b321:	41 f6 c0 40          	test   r8b,0x40
  21b325:	49 0f 45 df          	cmovne rbx,r15
  21b329:	4d 0f 45 fe          	cmovne r15,r14
  21b32d:	48 21 fb             	and    rbx,rdi
  21b330:	49 21 d7             	and    r15,rdx
  21b333:	31 ff                	xor    edi,edi
  21b335:	49 09 df             	or     r15,rbx
  21b338:	40 0f 95 c7          	setne  dil
  21b33c:	4c 09 d7             	or     rdi,r10
  21b33f:	4c 89 da             	mov    rdx,r11
  21b342:	eb 35                	jmp    21b379 <__floattidf+0xf9>
        return 0.0;
  21b344:	c5 f8 57 c0          	vxorps xmm0,xmm0,xmm0
  21b348:	c3                   	ret    
            a >>= 1;
            e += 1;
        }
        // a is now rounded to DBL_MANT_DIG bits
    } else {
        a <<= @intCast(u7, DBL_MANT_DIG - sd);
  21b349:	b9 35 00 00 00       	mov    ecx,0x35
  21b34e:	44 29 c9             	sub    ecx,r9d
  21b351:	83 e1 7f             	and    ecx,0x7f
  21b354:	48 0f a5 fa          	shld   rdx,rdi,cl
  21b358:	c4 e2 f1 f7 df       	shlx   rbx,rdi,rcx
  21b35d:	31 ff                	xor    edi,edi
  21b35f:	f6 c1 40             	test   cl,0x40
  21b362:	48 0f 45 d3          	cmovne rdx,rbx
  21b366:	48 0f 44 fb          	cmove  rdi,rbx
    if (sd > DBL_MANT_DIG) {
  21b36a:	48 0f a4 fa 20       	shld   rdx,rdi,0x20
  21b36f:	eb 40                	jmp    21b3b1 <__floattidf+0x131>
                a <<= 1;
  21b371:	48 0f a4 fa 01       	shld   rdx,rdi,0x1
  21b376:	48 01 ff             	add    rdi,rdi
        a |= @boolToInt((a & 4) != 0); // Or P into R
  21b379:	b9 02 01 00 00       	mov    ecx,0x102
  21b37e:	c4 e2 70 f7 cf       	bextr  ecx,edi,ecx
  21b383:	48 09 f9             	or     rcx,rdi
        a += 1; // round - this step may add a significant bit
  21b386:	48 83 c1 01          	add    rcx,0x1
  21b38a:	48 83 d2 00          	adc    rdx,0x0
            a >>= 1;
  21b38e:	48 89 d7             	mov    rdi,rdx
        if ((a & (u128(1) << DBL_MANT_DIG)) != 0) {
  21b391:	48 0f ba e1 37       	bt     rcx,0x37
  21b396:	72 0c                	jb     21b3a4 <__floattidf+0x124>
  21b398:	48 0f a4 cf 3e       	shld   rdi,rcx,0x3e
  21b39d:	48 0f a4 ca 1e       	shld   rdx,rcx,0x1e
  21b3a2:	eb 0d                	jmp    21b3b1 <__floattidf+0x131>
            a >>= 1;
  21b3a4:	48 0f a4 cf 3d       	shld   rdi,rcx,0x3d
        if ((a & (u128(1) << DBL_MANT_DIG)) != 0) {
  21b3a9:	48 0f a4 ca 1d       	shld   rdx,rcx,0x1d
  21b3ae:	44 89 c8             	mov    eax,r9d
        // a is now rounded to DBL_MANT_DIG bits
    }

    const s = @bitCast(u128, arg) >> (128 - 32);
  21b3b1:	48 c1 ee 20          	shr    rsi,0x20
    const high: u64 = (@intCast(u64, s) & 0x80000000) | // sign
  21b3b5:	81 e6 00 00 00 80    	and    esi,0x80000000
        (@intCast(u32, (e + 1023)) << 20) | // exponent
  21b3bb:	c1 e0 14             	shl    eax,0x14
  21b3be:	05 00 00 f0 3f       	add    eax,0x3ff00000
    const high: u64 = (@intCast(u64, s) & 0x80000000) | // sign
  21b3c3:	09 f0                	or     eax,esi
        (@truncate(u32, a >> 32) & 0x000fffff); // mantissa-high
  21b3c5:	81 e2 ff ff 0f 00    	and    edx,0xfffff
        (@intCast(u32, (e + 1023)) << 20) | // exponent
  21b3cb:	09 c2                	or     edx,eax
    const low: u64 = @truncate(u32, a); // mantissa-low
  21b3cd:	89 f8                	mov    eax,edi

    return @bitCast(f64, low | (high << 32));
  21b3cf:	48 c1 e2 20          	shl    rdx,0x20
  21b3d3:	48 09 c2             	or     rdx,rax
  21b3d6:	c4 e1 f9 6e c2       	vmovq  xmm0,rdx
  21b3db:	5b                   	pop    rbx
  21b3dc:	41 5e                	pop    r14
  21b3de:	41 5f                	pop    r15
  21b3e0:	c3                   	ret    
  21b3e1:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21b3e8:	0f 1f 84 00 00 00 00 
  21b3ef:	00 

000000000021b3f0 <__floattisf>:
const FLT_MANT_DIG = 24;

pub extern fn __floattisf(arg: i128) f32 {
    @setRuntimeSafety(is_test);

    if (arg == 0)
  21b3f0:	48 89 f8             	mov    rax,rdi
  21b3f3:	48 09 f0             	or     rax,rsi
  21b3f6:	0f 84 b2 00 00 00    	je     21b4ae <__floattisf+0xbe>
        return 0.0;

    var ai = arg;
    const N: u32 = 128;
    const si = ai >> @intCast(u7, (N - 1));
  21b3fc:	48 89 f1             	mov    rcx,rsi
  21b3ff:	48 c1 f9 3f          	sar    rcx,0x3f
    ai = ((ai ^ si) -% si);
  21b403:	48 89 c8             	mov    rax,rcx
  21b406:	48 31 f0             	xor    rax,rsi
  21b409:	48 31 cf             	xor    rdi,rcx
  21b40c:	48 29 cf             	sub    rdi,rcx
  21b40f:	48 19 c8             	sbb    rax,rcx
    var a = @bitCast(u128, ai);

    const sd = @bitCast(i32, N - @clz(a)); // number of significant digits
  21b412:	f3 48 0f bd d0       	lzcnt  rdx,rax
  21b417:	f3 48 0f bd cf       	lzcnt  rcx,rdi
  21b41c:	83 c1 40             	add    ecx,0x40
  21b41f:	48 85 c0             	test   rax,rax
  21b422:	0f 45 ca             	cmovne ecx,edx
  21b425:	41 b9 80 00 00 00    	mov    r9d,0x80
  21b42b:	41 29 c9             	sub    r9d,ecx
    var e: i32 = sd - 1; // exponent
  21b42e:	ba 7f 00 00 00       	mov    edx,0x7f
  21b433:	29 ca                	sub    edx,ecx

    if (sd > FLT_MANT_DIG) {
  21b435:	41 83 f9 19          	cmp    r9d,0x19
  21b439:	7c 78                	jl     21b4b3 <__floattisf+0xc3>
        //                                                12345678901234567890123456
        //  1 = msb 1 bit
        //  P = bit FLT_MANT_DIG-1 bits to the right of 1
        //  Q = bit FLT_MANT_DIG bits to the right of 1
        //  R = "or" of all bits to the right of Q
        switch (sd) {
  21b43b:	0f 84 8d 00 00 00    	je     21b4ce <__floattisf+0xde>
  21b441:	41 83 f9 1a          	cmp    r9d,0x1a
  21b445:	0f 84 86 00 00 00    	je     21b4d1 <__floattisf+0xe1>
            FLT_MANT_DIG + 1 => {
                a <<= 1;
            },
            FLT_MANT_DIG + 2 => {},
            else => {
                const shift1_amt = @intCast(i32, sd - (FLT_MANT_DIG + 2));
  21b44b:	41 56                	push   r14
  21b44d:	53                   	push   rbx
  21b44e:	41 8d 49 66          	lea    ecx,[r9+0x66]
                const shift1_amt_u7 = @intCast(u7, shift1_amt);

                const shift2_amt = @intCast(i32, N + (FLT_MANT_DIG + 2)) - sd;
                const shift2_amt_u7 = @intCast(u7, shift2_amt);

                a = (a >> shift1_amt_u7) | @boolToInt((a & (@intCast(u128, @maxValue(u128)) >> shift2_amt_u7)) != 0);
  21b452:	83 e1 7f             	and    ecx,0x7f
  21b455:	49 89 fa             	mov    r10,rdi
  21b458:	49 0f ad c2          	shrd   r10,rax,cl
                const shift2_amt = @intCast(i32, N + (FLT_MANT_DIG + 2)) - sd;
  21b45c:	41 b8 1a 00 00 00    	mov    r8d,0x1a
  21b462:	45 29 c8             	sub    r8d,r9d
                a = (a >> shift1_amt_u7) | @boolToInt((a & (@intCast(u128, @maxValue(u128)) >> shift2_amt_u7)) != 0);
  21b465:	c4 62 f3 f7 d8       	shrx   r11,rax,rcx
  21b46a:	45 31 f6             	xor    r14d,r14d
  21b46d:	f6 c1 40             	test   cl,0x40
  21b470:	4d 0f 44 da          	cmove  r11,r10
  21b474:	41 83 e0 7f          	and    r8d,0x7f
  21b478:	48 c7 c3 ff ff ff ff 	mov    rbx,0xffffffffffffffff
  21b47f:	c4 62 bb f7 d3       	shrx   r10,rbx,r8
  21b484:	44 89 c1             	mov    ecx,r8d
  21b487:	48 0f ad db          	shrd   rbx,rbx,cl
  21b48b:	41 f6 c0 40          	test   r8b,0x40
  21b48f:	49 0f 45 da          	cmovne rbx,r10
  21b493:	4d 0f 44 f2          	cmove  r14,r10
  21b497:	48 21 fb             	and    rbx,rdi
  21b49a:	49 21 c6             	and    r14,rax
  21b49d:	31 ff                	xor    edi,edi
  21b49f:	49 09 de             	or     r14,rbx
  21b4a2:	40 0f 95 c7          	setne  dil
  21b4a6:	4c 09 df             	or     rdi,r11
        switch (sd) {
  21b4a9:	5b                   	pop    rbx
  21b4aa:	41 5e                	pop    r14
  21b4ac:	eb 23                	jmp    21b4d1 <__floattisf+0xe1>
        return 0.0;
  21b4ae:	c5 f8 57 c0          	vxorps xmm0,xmm0,xmm0
  21b4b2:	c3                   	ret    
            a >>= 1;
            e += 1;
        }
        // a is now rounded to FLT_MANT_DIG bits
    } else {
        a <<= @intCast(u7, FLT_MANT_DIG - sd);
  21b4b3:	b9 18 00 00 00       	mov    ecx,0x18
  21b4b8:	44 29 c9             	sub    ecx,r9d
  21b4bb:	83 e1 7f             	and    ecx,0x7f
  21b4be:	c4 e2 f1 f7 ff       	shlx   rdi,rdi,rcx
  21b4c3:	31 c0                	xor    eax,eax
  21b4c5:	f6 c1 40             	test   cl,0x40
  21b4c8:	48 0f 44 c7          	cmove  rax,rdi
  21b4cc:	eb 28                	jmp    21b4f6 <__floattisf+0x106>
                a <<= 1;
  21b4ce:	48 01 ff             	add    rdi,rdi
        a |= @boolToInt((a & 4) != 0); // Or P into R
  21b4d1:	b8 02 01 00 00       	mov    eax,0x102
  21b4d6:	c4 e2 78 f7 c7       	bextr  eax,edi,eax
  21b4db:	48 09 f8             	or     rax,rdi
        a += 1; // round - this step may add a significant bit
  21b4de:	48 83 c0 01          	add    rax,0x1
        if ((a & (u128(1) << FLT_MANT_DIG)) != 0) {
  21b4e2:	a9 00 00 00 04       	test   eax,0x4000000
  21b4e7:	75 06                	jne    21b4ef <__floattisf+0xff>
  21b4e9:	48 c1 e8 02          	shr    rax,0x2
  21b4ed:	eb 07                	jmp    21b4f6 <__floattisf+0x106>
            a >>= 1;
  21b4ef:	48 c1 e8 03          	shr    rax,0x3
  21b4f3:	44 89 ca             	mov    edx,r9d
        // a is now rounded to FLT_MANT_DIG bits
    }

    const s = @bitCast(u128, arg) >> (128 - 32);
  21b4f6:	48 c1 ee 20          	shr    rsi,0x20
    const r = (@intCast(u32, s) & 0x80000000) | // sign
  21b4fa:	81 e6 00 00 00 80    	and    esi,0x80000000
        (@intCast(u32, (e + 127)) << 23) | // exponent
  21b500:	c1 e2 17             	shl    edx,0x17
  21b503:	81 c2 00 00 80 3f    	add    edx,0x3f800000
    const r = (@intCast(u32, s) & 0x80000000) | // sign
  21b509:	09 f2                	or     edx,esi
        (@truncate(u32, a) & 0x007fffff); // mantissa-high
  21b50b:	25 ff ff 7f 00       	and    eax,0x7fffff
        (@intCast(u32, (e + 127)) << 23) | // exponent
  21b510:	09 d0                	or     eax,edx

    return @bitCast(f32, r);
  21b512:	c5 f9 6e c0          	vmovd  xmm0,eax
  21b516:	c3                   	ret    
  21b517:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  21b51e:	00 00 

000000000021b520 <__floatunditf>:
const std = @import("std");

pub extern fn __floatunditf(a: u128) f128 {
    @setRuntimeSafety(is_test);

    if (a == 0) {
  21b520:	48 89 f8             	mov    rax,rdi
  21b523:	48 09 f0             	or     rax,rsi
  21b526:	74 0f                	je     21b537 <__floatunditf+0x17>
    const mantissa_bits = std.math.floatMantissaBits(f128);
    const exponent_bits = std.math.floatExponentBits(f128);
    const exponent_bias = (1 << (exponent_bits - 1)) - 1;
    const implicit_bit = 1 << mantissa_bits;

    const exp = (u128.bit_count - 1) - @clz(a);
  21b528:	48 85 f6             	test   rsi,rsi
  21b52b:	75 12                	jne    21b53f <__floatunditf+0x1f>
  21b52d:	f3 48 0f bd c7       	lzcnt  rax,rdi
  21b532:	83 c0 40             	add    eax,0x40
  21b535:	eb 0d                	jmp    21b544 <__floatunditf+0x24>
        return 0;
  21b537:	0f 28 05 52 b6 fe ff 	movaps xmm0,XMMWORD PTR [rip+0xfffffffffffeb652]        # 206b90 <__unnamed_7>
  21b53e:	c3                   	ret    
  21b53f:	f3 48 0f bd c6       	lzcnt  rax,rsi
  21b544:	b2 7f                	mov    dl,0x7f
    const exp = (u128.bit_count - 1) - @clz(a);
  21b546:	28 c2                	sub    dl,al
  21b548:	b1 70                	mov    cl,0x70
    const shift = mantissa_bits - @intCast(u7, exp);
  21b54a:	28 d1                	sub    cl,dl

    var result: u128 align(16) = (a << shift) ^ implicit_bit;
  21b54c:	48 0f a5 fe          	shld   rsi,rdi,cl
  21b550:	c4 e2 f1 f7 c7       	shlx   rax,rdi,rcx
  21b555:	31 ff                	xor    edi,edi
  21b557:	f6 c1 40             	test   cl,0x40
  21b55a:	48 0f 45 f0          	cmovne rsi,rax
  21b55e:	48 0f 44 f8          	cmove  rdi,rax
  21b562:	48 b8 00 00 00 00 00 	movabs rax,0x1000000000000
  21b569:	00 01 00 
  21b56c:	48 31 f0             	xor    rax,rsi
    result += (@intCast(u128, exp) + exponent_bias) << mantissa_bits;
  21b56f:	0f b6 ca             	movzx  ecx,dl
  21b572:	48 c1 e1 30          	shl    rcx,0x30
  21b576:	48 01 c1             	add    rcx,rax
  21b579:	48 89 7c 24 e8       	mov    QWORD PTR [rsp-0x18],rdi
  21b57e:	48 b8 00 00 00 00 00 	movabs rax,0x3fff000000000000
  21b585:	00 ff 3f 
  21b588:	48 01 c8             	add    rax,rcx
  21b58b:	48 89 44 24 f0       	mov    QWORD PTR [rsp-0x10],rax
  21b590:	0f 28 44 24 e8       	movaps xmm0,XMMWORD PTR [rsp-0x18]

    return @bitCast(f128, result);
  21b595:	c3                   	ret    
  21b596:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  21b59d:	00 00 00 

000000000021b5a0 <__floatunsitf>:
const std = @import("std");

pub extern fn __floatunsitf(a: u64) f128 {
    @setRuntimeSafety(is_test);

    if (a == 0) {
  21b5a0:	48 85 ff             	test   rdi,rdi
  21b5a3:	74 5c                	je     21b601 <__floatunsitf+0x61>
    const mantissa_bits = std.math.floatMantissaBits(f128);
    const exponent_bits = std.math.floatExponentBits(f128);
    const exponent_bias = (1 << (exponent_bits - 1)) - 1;
    const implicit_bit = 1 << mantissa_bits;

    const exp = (u64.bit_count - 1) - @clz(a);
  21b5a5:	f3 48 0f bd c7       	lzcnt  rax,rdi
  21b5aa:	b2 3f                	mov    dl,0x3f
  21b5ac:	28 c2                	sub    dl,al
  21b5ae:	b1 70                	mov    cl,0x70
    const shift = mantissa_bits - @intCast(u7, exp);
  21b5b0:	28 d1                	sub    cl,dl
  21b5b2:	31 c0                	xor    eax,eax

    // TODO(#1148): @bitCast alignment error
    var result align(16) = (@intCast(u128, a) << shift) ^ implicit_bit;
  21b5b4:	31 f6                	xor    esi,esi
  21b5b6:	48 0f a5 fe          	shld   rsi,rdi,cl
  21b5ba:	c4 e2 f1 f7 ff       	shlx   rdi,rdi,rcx
  21b5bf:	f6 c1 40             	test   cl,0x40
  21b5c2:	48 0f 45 f7          	cmovne rsi,rdi
  21b5c6:	48 0f 45 f8          	cmovne rdi,rax
  21b5ca:	48 b8 00 00 00 00 00 	movabs rax,0x1000000000000
  21b5d1:	00 01 00 
  21b5d4:	48 31 f0             	xor    rax,rsi
    result += (@intCast(u128, exp) + exponent_bias) << mantissa_bits;
  21b5d7:	0f b6 ca             	movzx  ecx,dl
  21b5da:	83 e1 7f             	and    ecx,0x7f
  21b5dd:	48 c1 e1 30          	shl    rcx,0x30
  21b5e1:	48 01 c1             	add    rcx,rax
  21b5e4:	48 89 7c 24 e8       	mov    QWORD PTR [rsp-0x18],rdi
  21b5e9:	48 b8 00 00 00 00 00 	movabs rax,0x3fff000000000000
  21b5f0:	00 ff 3f 
  21b5f3:	48 01 c8             	add    rax,rcx
  21b5f6:	48 89 44 24 f0       	mov    QWORD PTR [rsp-0x10],rax
  21b5fb:	0f 28 44 24 e8       	movaps xmm0,XMMWORD PTR [rsp-0x18]

    return @bitCast(f128, result);
  21b600:	c3                   	ret    
        return 0;
  21b601:	0f 28 05 88 b5 fe ff 	movaps xmm0,XMMWORD PTR [rip+0xfffffffffffeb588]        # 206b90 <__unnamed_7>
  21b608:	c3                   	ret    
  21b609:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

000000000021b610 <__floatuntitf>:
const LDBL_MANT_DIG = 113;

pub extern fn __floatuntitf(arg: u128) f128 {
    @setRuntimeSafety(is_test);

    if (arg == 0)
  21b610:	48 89 f8             	mov    rax,rdi
  21b613:	48 09 f0             	or     rax,rsi
  21b616:	0f 84 a0 00 00 00    	je     21b6bc <__floatuntitf+0xac>
        return 0.0;

    var a = arg;
    const N: u32 = @sizeOf(u128) * 8;
    const sd = @bitCast(i32, N - @clz(a)); // number of significant digits
  21b61c:	41 56                	push   r14
  21b61e:	53                   	push   rbx
  21b61f:	f3 48 0f bd c6       	lzcnt  rax,rsi
  21b624:	f3 48 0f bd cf       	lzcnt  rcx,rdi
  21b629:	83 c1 40             	add    ecx,0x40
  21b62c:	48 85 f6             	test   rsi,rsi
  21b62f:	0f 45 c8             	cmovne ecx,eax
  21b632:	41 b9 80 00 00 00    	mov    r9d,0x80
  21b638:	41 29 c9             	sub    r9d,ecx
    var e: i32 = sd - 1; // exponent
  21b63b:	ba 7f 00 00 00       	mov    edx,0x7f
  21b640:	29 ca                	sub    edx,ecx
    if (sd > LDBL_MANT_DIG) {
  21b642:	41 83 f9 72          	cmp    r9d,0x72
  21b646:	7c 7c                	jl     21b6c4 <__floatuntitf+0xb4>
        //                                                12345678901234567890123456
        //  1 = msb 1 bit
        //  P = bit LDBL_MANT_DIG-1 bits to the right of 1
        //  Q = bit LDBL_MANT_DIG bits to the right of 1
        //  R = "or" of all bits to the right of Q
        switch (sd) {
  21b648:	0f 84 99 00 00 00    	je     21b6e7 <__floatuntitf+0xd7>
  21b64e:	41 83 f9 73          	cmp    r9d,0x73
  21b652:	0f 84 97 00 00 00    	je     21b6ef <__floatuntitf+0xdf>
            LDBL_MANT_DIG + 1 => {
                a <<= 1;
            },
            LDBL_MANT_DIG + 2 => {},
            else => {
                const shift_amt = @bitCast(i32, N + (LDBL_MANT_DIG + 2)) - sd;
  21b658:	41 b8 73 00 00 00    	mov    r8d,0x73
                const shift_amt_u7 = @intCast(u7, shift_amt);
                a = (a >> @intCast(u7, sd - (LDBL_MANT_DIG + 2))) |
  21b65e:	41 8d 49 0d          	lea    ecx,[r9+0xd]
  21b662:	83 e1 7f             	and    ecx,0x7f
  21b665:	49 89 fe             	mov    r14,rdi
  21b668:	49 0f ad f6          	shrd   r14,rsi,cl
                const shift_amt = @bitCast(i32, N + (LDBL_MANT_DIG + 2)) - sd;
  21b66c:	45 29 c8             	sub    r8d,r9d
                a = (a >> @intCast(u7, sd - (LDBL_MANT_DIG + 2))) |
  21b66f:	c4 62 f3 f7 d6       	shrx   r10,rsi,rcx
  21b674:	45 31 db             	xor    r11d,r11d
  21b677:	f6 c1 40             	test   cl,0x40
  21b67a:	4d 0f 45 f2          	cmovne r14,r10
  21b67e:	4d 0f 45 d3          	cmovne r10,r11
                    @boolToInt((a & (u128(@maxValue(u128)) >> shift_amt_u7)) != 0);
  21b682:	41 83 e0 7f          	and    r8d,0x7f
  21b686:	48 c7 c3 ff ff ff ff 	mov    rbx,0xffffffffffffffff
  21b68d:	c4 e2 bb f7 c3       	shrx   rax,rbx,r8
  21b692:	44 89 c1             	mov    ecx,r8d
  21b695:	48 0f ad db          	shrd   rbx,rbx,cl
  21b699:	41 f6 c0 40          	test   r8b,0x40
  21b69d:	48 0f 45 d8          	cmovne rbx,rax
  21b6a1:	49 0f 45 c3          	cmovne rax,r11
  21b6a5:	48 21 fb             	and    rbx,rdi
  21b6a8:	48 21 f0             	and    rax,rsi
  21b6ab:	31 ff                	xor    edi,edi
  21b6ad:	48 09 d8             	or     rax,rbx
  21b6b0:	40 0f 95 c7          	setne  dil
                a = (a >> @intCast(u7, sd - (LDBL_MANT_DIG + 2))) |
  21b6b4:	4c 09 f7             	or     rdi,r14
  21b6b7:	4c 89 d6             	mov    rsi,r10
  21b6ba:	eb 33                	jmp    21b6ef <__floatuntitf+0xdf>
        return 0.0;
  21b6bc:	0f 28 05 cd b4 fe ff 	movaps xmm0,XMMWORD PTR [rip+0xfffffffffffeb4cd]        # 206b90 <__unnamed_7>
  21b6c3:	c3                   	ret    
            a >>= 1;
            e += 1;
        }
        // a is now rounded to LDBL_MANT_DIG bits
    } else {
        a <<= @intCast(u7, LDBL_MANT_DIG - sd);
  21b6c4:	b9 71 00 00 00       	mov    ecx,0x71
  21b6c9:	44 29 c9             	sub    ecx,r9d
  21b6cc:	83 e1 7f             	and    ecx,0x7f
  21b6cf:	48 0f a5 fe          	shld   rsi,rdi,cl
  21b6d3:	c4 e2 f1 f7 ff       	shlx   rdi,rdi,rcx
  21b6d8:	31 c0                	xor    eax,eax
  21b6da:	f6 c1 40             	test   cl,0x40
  21b6dd:	48 0f 45 f7          	cmovne rsi,rdi
  21b6e1:	48 0f 44 c7          	cmove  rax,rdi
  21b6e5:	eb 3b                	jmp    21b722 <__floatuntitf+0x112>
                a <<= 1;
  21b6e7:	48 0f a4 fe 01       	shld   rsi,rdi,0x1
  21b6ec:	48 01 ff             	add    rdi,rdi
        a |= @boolToInt((a & 4) != 0); // Or P into R
  21b6ef:	b8 02 01 00 00       	mov    eax,0x102
  21b6f4:	c4 e2 78 f7 c7       	bextr  eax,edi,eax
  21b6f9:	48 09 f8             	or     rax,rdi
        a += 1; // round - this step may add a significant bit
  21b6fc:	48 83 c0 01          	add    rax,0x1
  21b700:	48 83 d6 00          	adc    rsi,0x0
        if ((a & (u128(1) << LDBL_MANT_DIG)) != 0) {
  21b704:	48 0f ba e6 33       	bt     rsi,0x33
  21b709:	72 0b                	jb     21b716 <__floatuntitf+0x106>
  21b70b:	48 0f ac f0 02       	shrd   rax,rsi,0x2
  21b710:	48 c1 ee 02          	shr    rsi,0x2
  21b714:	eb 0c                	jmp    21b722 <__floatuntitf+0x112>
            a >>= 1;
  21b716:	48 0f ac f0 03       	shrd   rax,rsi,0x3
  21b71b:	48 c1 ee 03          	shr    rsi,0x3
  21b71f:	44 89 ca             	mov    edx,r9d
        // a is now rounded to LDBL_MANT_DIG bits
    }

    const high: u128 = (@intCast(u64, (e + 16383)) << 48) | // exponent
  21b722:	81 c2 ff 3f 00 00    	add    edx,0x3fff
  21b728:	48 c1 e2 30          	shl    rdx,0x30
        (@truncate(u64, a >> 64) & 0x0000ffffffffffff); // mantissa-high
  21b72c:	b1 30                	mov    cl,0x30
  21b72e:	c4 e2 f0 f5 ce       	bzhi   rcx,rsi,rcx
    const low = @truncate(u64, a); // mantissa-low

    return @bitCast(f128, low | (high << 64));
  21b733:	48 89 44 24 e8       	mov    QWORD PTR [rsp-0x18],rax
    const high: u128 = (@intCast(u64, (e + 16383)) << 48) | // exponent
  21b738:	48 09 d1             	or     rcx,rdx
    return @bitCast(f128, low | (high << 64));
  21b73b:	48 89 4c 24 f0       	mov    QWORD PTR [rsp-0x10],rcx
  21b740:	0f 28 44 24 e8       	movaps xmm0,XMMWORD PTR [rsp-0x18]
  21b745:	5b                   	pop    rbx
  21b746:	41 5e                	pop    r14
  21b748:	c3                   	ret    
  21b749:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

000000000021b750 <__floatuntidf>:
const DBL_MANT_DIG = 53;

pub extern fn __floatuntidf(arg: u128) f64 {
    @setRuntimeSafety(is_test);

    if (arg == 0)
  21b750:	48 89 f8             	mov    rax,rdi
  21b753:	48 09 f0             	or     rax,rsi
  21b756:	0f 84 a0 00 00 00    	je     21b7fc <__floatuntidf+0xac>
        return 0.0;

    var a = arg;
    const N: u32 = @sizeOf(u128) * 8;
    const sd = @bitCast(i32, N - @clz(a)); // number of significant digits
  21b75c:	f3 48 0f bd c6       	lzcnt  rax,rsi
  21b761:	f3 48 0f bd cf       	lzcnt  rcx,rdi
  21b766:	83 c1 40             	add    ecx,0x40
  21b769:	48 85 f6             	test   rsi,rsi
  21b76c:	0f 45 c8             	cmovne ecx,eax
  21b76f:	ba 80 00 00 00       	mov    edx,0x80
  21b774:	29 ca                	sub    edx,ecx
    var e: i32 = sd - 1; // exponent
  21b776:	41 bb 7f 00 00 00    	mov    r11d,0x7f
  21b77c:	41 29 cb             	sub    r11d,ecx
    if (sd > DBL_MANT_DIG) {
  21b77f:	83 fa 36             	cmp    edx,0x36
  21b782:	7c 7d                	jl     21b801 <__floatuntidf+0xb1>
        //                                                12345678901234567890123456
        //  1 = msb 1 bit
        //  P = bit DBL_MANT_DIG-1 bits to the right of 1
        //  Q = bit DBL_MANT_DIG bits to the right of 1
        //  R = "or" of all bits to the right of Q
        switch (sd) {
  21b784:	0f 84 97 00 00 00    	je     21b821 <__floatuntidf+0xd1>
  21b78a:	83 fa 37             	cmp    edx,0x37
  21b78d:	0f 84 96 00 00 00    	je     21b829 <__floatuntidf+0xd9>
            DBL_MANT_DIG + 1 => {
                a <<= 1;
            },
            DBL_MANT_DIG + 2 => {},
            else => {
                const shift_amt = @bitCast(i32, N + (DBL_MANT_DIG + 2)) - sd;
  21b793:	41 56                	push   r14
  21b795:	53                   	push   rbx
  21b796:	41 b8 37 00 00 00    	mov    r8d,0x37
                const shift_amt_u7 = @intCast(u7, shift_amt);
                a = (a >> @intCast(u7, sd - (DBL_MANT_DIG + 2))) |
  21b79c:	8d 4a 49             	lea    ecx,[rdx+0x49]
  21b79f:	83 e1 7f             	and    ecx,0x7f
  21b7a2:	49 89 f9             	mov    r9,rdi
  21b7a5:	49 0f ad f1          	shrd   r9,rsi,cl
                const shift_amt = @bitCast(i32, N + (DBL_MANT_DIG + 2)) - sd;
  21b7a9:	41 29 d0             	sub    r8d,edx
                a = (a >> @intCast(u7, sd - (DBL_MANT_DIG + 2))) |
  21b7ac:	c4 62 f3 f7 d6       	shrx   r10,rsi,rcx
  21b7b1:	45 31 f6             	xor    r14d,r14d
  21b7b4:	f6 c1 40             	test   cl,0x40
  21b7b7:	4d 0f 45 ca          	cmovne r9,r10
  21b7bb:	4d 0f 45 d6          	cmovne r10,r14
                    @boolToInt((a & (u128(@maxValue(u128)) >> shift_amt_u7)) != 0);
  21b7bf:	41 83 e0 7f          	and    r8d,0x7f
  21b7c3:	48 c7 c3 ff ff ff ff 	mov    rbx,0xffffffffffffffff
  21b7ca:	c4 e2 bb f7 c3       	shrx   rax,rbx,r8
  21b7cf:	44 89 c1             	mov    ecx,r8d
  21b7d2:	48 0f ad db          	shrd   rbx,rbx,cl
  21b7d6:	41 f6 c0 40          	test   r8b,0x40
  21b7da:	48 0f 45 d8          	cmovne rbx,rax
  21b7de:	49 0f 45 c6          	cmovne rax,r14
  21b7e2:	48 21 fb             	and    rbx,rdi
  21b7e5:	48 21 f0             	and    rax,rsi
  21b7e8:	31 ff                	xor    edi,edi
  21b7ea:	48 09 d8             	or     rax,rbx
  21b7ed:	40 0f 95 c7          	setne  dil
                a = (a >> @intCast(u7, sd - (DBL_MANT_DIG + 2))) |
  21b7f1:	4c 09 cf             	or     rdi,r9
  21b7f4:	4c 89 d6             	mov    rsi,r10
        switch (sd) {
  21b7f7:	5b                   	pop    rbx
  21b7f8:	41 5e                	pop    r14
  21b7fa:	eb 2d                	jmp    21b829 <__floatuntidf+0xd9>
        return 0.0;
  21b7fc:	c5 f8 57 c0          	vxorps xmm0,xmm0,xmm0
  21b800:	c3                   	ret    
            a >>= 1;
            e += 1;
        }
        // a is now rounded to DBL_MANT_DIG bits
    } else {
        a <<= @intCast(u7, DBL_MANT_DIG - sd);
  21b801:	b8 35 00 00 00       	mov    eax,0x35
  21b806:	29 d0                	sub    eax,edx
  21b808:	83 e0 7f             	and    eax,0x7f
  21b80b:	c4 e2 f9 f7 d7       	shlx   rdx,rdi,rax
  21b810:	31 c9                	xor    ecx,ecx
  21b812:	a8 40                	test   al,0x40
  21b814:	48 0f 44 ca          	cmove  rcx,rdx
    if (sd > DBL_MANT_DIG) {
  21b818:	48 89 ce             	mov    rsi,rcx
  21b81b:	48 c1 ee 20          	shr    rsi,0x20
  21b81f:	eb 48                	jmp    21b869 <__floatuntidf+0x119>
                a <<= 1;
  21b821:	48 0f a4 fe 01       	shld   rsi,rdi,0x1
  21b826:	48 01 ff             	add    rdi,rdi
        a |= @boolToInt((a & 4) != 0); // Or P into R
  21b829:	b8 02 01 00 00       	mov    eax,0x102
  21b82e:	c4 e2 78 f7 c7       	bextr  eax,edi,eax
  21b833:	48 09 f8             	or     rax,rdi
        a += 1; // round - this step may add a significant bit
  21b836:	48 83 c0 01          	add    rax,0x1
  21b83a:	48 83 d6 00          	adc    rsi,0x0
            a >>= 1;
  21b83e:	48 89 f1             	mov    rcx,rsi
        if ((a & (u128(1) << DBL_MANT_DIG)) != 0) {
  21b841:	48 0f ba e0 37       	bt     rax,0x37
  21b846:	72 10                	jb     21b858 <__floatuntidf+0x108>
  21b848:	48 0f a4 c1 3e       	shld   rcx,rax,0x3e
  21b84d:	48 c1 e8 22          	shr    rax,0x22
  21b851:	c1 e6 1e             	shl    esi,0x1e
  21b854:	09 c6                	or     esi,eax
  21b856:	eb 11                	jmp    21b869 <__floatuntidf+0x119>
            a >>= 1;
  21b858:	48 0f a4 c1 3d       	shld   rcx,rax,0x3d
        if ((a & (u128(1) << DBL_MANT_DIG)) != 0) {
  21b85d:	48 c1 e8 23          	shr    rax,0x23
  21b861:	c1 e6 1d             	shl    esi,0x1d
  21b864:	09 c6                	or     esi,eax
  21b866:	41 89 d3             	mov    r11d,edx
        // a is now rounded to DBL_MANT_DIG bits
    }

    const high: u64 = @bitCast(u32, (e + 1023) << 20) | // exponent
  21b869:	41 c1 e3 14          	shl    r11d,0x14
        (@truncate(u32, a >> 32) & 0x000FFFFF); // mantissa-high
  21b86d:	81 e6 ff ff 0f 00    	and    esi,0xfffff
    const high: u64 = @bitCast(u32, (e + 1023) << 20) | // exponent
  21b873:	42 8d 04 1e          	lea    eax,[rsi+r11*1]
  21b877:	05 00 00 f0 3f       	add    eax,0x3ff00000
    const low = @truncate(u32, a); // mantissa-low

    return @bitCast(f64, low | (high << 32));
  21b87c:	48 c1 e0 20          	shl    rax,0x20
  21b880:	89 c9                	mov    ecx,ecx
  21b882:	48 09 c1             	or     rcx,rax
  21b885:	c4 e1 f9 6e c1       	vmovq  xmm0,rcx
  21b88a:	c3                   	ret    
  21b88b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

000000000021b890 <__floatuntisf>:
const FLT_MANT_DIG = 24;

pub extern fn __floatuntisf(arg: u128) f32 {
    @setRuntimeSafety(is_test);

    if (arg == 0)
  21b890:	48 89 f8             	mov    rax,rdi
  21b893:	48 09 f0             	or     rax,rsi
  21b896:	0f 84 93 00 00 00    	je     21b92f <__floatuntisf+0x9f>
        return 0.0;

    var a = arg;
    const N: u32 = @sizeOf(u128) * 8;
    const sd = @bitCast(i32, N - @clz(a)); // number of significant digits
  21b89c:	f3 48 0f bd c6       	lzcnt  rax,rsi
  21b8a1:	f3 48 0f bd cf       	lzcnt  rcx,rdi
  21b8a6:	83 c1 40             	add    ecx,0x40
  21b8a9:	48 85 f6             	test   rsi,rsi
  21b8ac:	0f 45 c8             	cmovne ecx,eax
  21b8af:	ba 80 00 00 00       	mov    edx,0x80
  21b8b4:	29 ca                	sub    edx,ecx
    var e: i32 = sd - 1; // exponent
  21b8b6:	b8 7f 00 00 00       	mov    eax,0x7f
  21b8bb:	29 c8                	sub    eax,ecx
    if (sd > FLT_MANT_DIG) {
  21b8bd:	83 fa 19             	cmp    edx,0x19
  21b8c0:	7c 72                	jl     21b934 <__floatuntisf+0xa4>
        //                                                12345678901234567890123456
        //  1 = msb 1 bit
        //  P = bit FLT_MANT_DIG-1 bits to the right of 1
        //  Q = bit FLT_MANT_DIG bits to the right of 1
        //  R = "or" of all bits to the right of Q
        switch (sd) {
  21b8c2:	0f 84 87 00 00 00    	je     21b94f <__floatuntisf+0xbf>
  21b8c8:	83 fa 1a             	cmp    edx,0x1a
  21b8cb:	0f 84 81 00 00 00    	je     21b952 <__floatuntisf+0xc2>
            },
            FLT_MANT_DIG + 2 => {},
            else => {
                const shift_amt = @bitCast(i32, N + (FLT_MANT_DIG + 2)) - sd;
                const shift_amt_u7 = @intCast(u7, shift_amt);
                a = (a >> @intCast(u7, sd - (FLT_MANT_DIG + 2))) |
  21b8d1:	53                   	push   rbx
  21b8d2:	8d 4a 66             	lea    ecx,[rdx+0x66]
  21b8d5:	83 e1 7f             	and    ecx,0x7f
  21b8d8:	49 89 f9             	mov    r9,rdi
  21b8db:	49 0f ad f1          	shrd   r9,rsi,cl
                const shift_amt = @bitCast(i32, N + (FLT_MANT_DIG + 2)) - sd;
  21b8df:	41 b8 1a 00 00 00    	mov    r8d,0x1a
  21b8e5:	41 29 d0             	sub    r8d,edx
                a = (a >> @intCast(u7, sd - (FLT_MANT_DIG + 2))) |
  21b8e8:	c4 62 f3 f7 d6       	shrx   r10,rsi,rcx
  21b8ed:	45 31 db             	xor    r11d,r11d
  21b8f0:	f6 c1 40             	test   cl,0x40
  21b8f3:	4d 0f 44 d1          	cmove  r10,r9
                    @boolToInt((a & (u128(@maxValue(u128)) >> shift_amt_u7)) != 0);
  21b8f7:	41 83 e0 7f          	and    r8d,0x7f
  21b8fb:	49 c7 c1 ff ff ff ff 	mov    r9,0xffffffffffffffff
  21b902:	c4 c2 bb f7 d9       	shrx   rbx,r9,r8
  21b907:	44 89 c1             	mov    ecx,r8d
  21b90a:	4d 0f ad c9          	shrd   r9,r9,cl
  21b90e:	41 f6 c0 40          	test   r8b,0x40
  21b912:	4c 0f 45 cb          	cmovne r9,rbx
  21b916:	4c 0f 44 db          	cmove  r11,rbx
  21b91a:	49 21 f9             	and    r9,rdi
  21b91d:	49 21 f3             	and    r11,rsi
  21b920:	31 ff                	xor    edi,edi
  21b922:	4d 09 cb             	or     r11,r9
  21b925:	40 0f 95 c7          	setne  dil
                a = (a >> @intCast(u7, sd - (FLT_MANT_DIG + 2))) |
  21b929:	4c 09 d7             	or     rdi,r10
        switch (sd) {
  21b92c:	5b                   	pop    rbx
  21b92d:	eb 23                	jmp    21b952 <__floatuntisf+0xc2>
        return 0.0;
  21b92f:	c5 f8 57 c0          	vxorps xmm0,xmm0,xmm0
  21b933:	c3                   	ret    
            a >>= 1;
            e += 1;
        }
        // a is now rounded to FLT_MANT_DIG bits
    } else {
        a <<= @intCast(u7, FLT_MANT_DIG - sd);
  21b934:	be 18 00 00 00       	mov    esi,0x18
  21b939:	29 d6                	sub    esi,edx
  21b93b:	83 e6 7f             	and    esi,0x7f
  21b93e:	c4 e2 c9 f7 d7       	shlx   rdx,rdi,rsi
  21b943:	31 c9                	xor    ecx,ecx
  21b945:	40 f6 c6 40          	test   sil,0x40
  21b949:	48 0f 44 ca          	cmove  rcx,rdx
  21b94d:	eb 28                	jmp    21b977 <__floatuntisf+0xe7>
                a <<= 1;
  21b94f:	48 01 ff             	add    rdi,rdi
        a |= @boolToInt((a & 4) != 0); // Or P into R
  21b952:	b9 02 01 00 00       	mov    ecx,0x102
  21b957:	c4 e2 70 f7 cf       	bextr  ecx,edi,ecx
  21b95c:	48 09 f9             	or     rcx,rdi
        a += 1; // round - this step may add a significant bit
  21b95f:	48 83 c1 01          	add    rcx,0x1
        if ((a & (u128(1) << FLT_MANT_DIG)) != 0) {
  21b963:	f7 c1 00 00 00 04    	test   ecx,0x4000000
  21b969:	75 06                	jne    21b971 <__floatuntisf+0xe1>
  21b96b:	48 c1 e9 02          	shr    rcx,0x2
  21b96f:	eb 06                	jmp    21b977 <__floatuntisf+0xe7>
            a >>= 1;
  21b971:	48 c1 e9 03          	shr    rcx,0x3
  21b975:	89 d0                	mov    eax,edx
        // a is now rounded to FLT_MANT_DIG bits
    }

    const high = @bitCast(u32, (e + 127) << 23); // exponent
  21b977:	c1 e0 17             	shl    eax,0x17
    const low = @truncate(u32, a) & 0x007fffff; // mantissa
  21b97a:	81 e1 ff ff 7f 00    	and    ecx,0x7fffff

    return @bitCast(f32, high | low);
  21b980:	8d 04 08             	lea    eax,[rax+rcx*1]
  21b983:	05 00 00 80 3f       	add    eax,0x3f800000
  21b988:	c5 f9 6e c0          	vmovd  xmm0,eax
  21b98c:	c3                   	ret    
  21b98d:	0f 1f 00             	nop    DWORD PTR [rax]

000000000021b990 <__extenddftf2>:
    const aRep: src_rep_t = @bitCast(src_rep_t, a);
  21b990:	c4 e1 f9 7e c1       	vmovq  rcx,xmm0
    const aAbs: src_rep_t = aRep & srcAbsMask;
  21b995:	b0 3f                	mov    al,0x3f
  21b997:	c4 e2 f8 f5 f1       	bzhi   rsi,rcx,rax
  21b99c:	48 b8 ff ff ff ff ff 	movabs rax,0x7fffffffffffffff
  21b9a3:	ff ff 7f 
    const sign: src_rep_t = aRep & srcSignMask;
  21b9a6:	48 83 c0 01          	add    rax,0x1
  21b9aa:	48 21 c8             	and    rax,rcx
    if (aAbs -% srcMinNormal < srcInfinity - srcMinNormal) {
  21b9ad:	48 ba 00 00 00 00 00 	movabs rdx,0xfff0000000000000
  21b9b4:	00 f0 ff 
  21b9b7:	48 01 f2             	add    rdx,rsi
  21b9ba:	48 c1 ea 35          	shr    rdx,0x35
  21b9be:	48 81 fa fe 03 00 00 	cmp    rdx,0x3fe
  21b9c5:	77 1a                	ja     21b9e1 <__extenddftf2+0x51>
        absResult = dst_rep_t(aAbs) << (dstSigBits - srcSigBits);
  21b9c7:	48 89 f2             	mov    rdx,rsi
  21b9ca:	48 c1 e2 3c          	shl    rdx,0x3c
  21b9ce:	48 c1 ee 04          	shr    rsi,0x4
        absResult += (dstExpBias - srcExpBias) << dstSigBits;
  21b9d2:	48 bf 00 00 00 00 00 	movabs rdi,0x3c00000000000000
  21b9d9:	00 00 3c 
  21b9dc:	48 01 f7             	add    rdi,rsi
  21b9df:	eb 7a                	jmp    21ba5b <__extenddftf2+0xcb>
    } else if (aAbs >= srcInfinity) {
  21b9e1:	48 89 f2             	mov    rdx,rsi
  21b9e4:	48 c1 ea 34          	shr    rdx,0x34
  21b9e8:	48 81 fa ff 07 00 00 	cmp    rdx,0x7ff
  21b9ef:	72 17                	jb     21ba08 <__extenddftf2+0x78>
        absResult |= dst_rep_t(aAbs & srcNaNCode) << (dstSigBits - srcSigBits);
  21b9f1:	48 89 ca             	mov    rdx,rcx
  21b9f4:	48 c1 e2 3c          	shl    rdx,0x3c
  21b9f8:	48 c1 e9 04          	shr    rcx,0x4
  21b9fc:	48 bf 00 00 00 00 00 	movabs rdi,0x7fff000000000000
  21ba03:	00 ff 7f 
  21ba06:	eb 4a                	jmp    21ba52 <__extenddftf2+0xc2>
    } else if (aAbs != 0) {
  21ba08:	48 85 f6             	test   rsi,rsi
  21ba0b:	74 4a                	je     21ba57 <__extenddftf2+0xc7>
        const scale: u32 = @clz(aAbs) - @clz(src_rep_t(srcMinNormal));
  21ba0d:	f3 48 0f bd ce       	lzcnt  rcx,rsi
  21ba12:	44 8d 41 75          	lea    r8d,[rcx+0x75]
  21ba16:	41 83 e0 7f          	and    r8d,0x7f
        absResult = dst_rep_t(aAbs) << @intCast(DstShift, dstSigBits - srcSigBits + scale);
  21ba1a:	83 c1 31             	add    ecx,0x31
  21ba1d:	83 e1 7f             	and    ecx,0x7f
  21ba20:	45 31 c9             	xor    r9d,r9d
  21ba23:	31 ff                	xor    edi,edi
  21ba25:	48 0f a5 f7          	shld   rdi,rsi,cl
  21ba29:	c4 e2 f1 f7 d6       	shlx   rdx,rsi,rcx
  21ba2e:	f6 c1 40             	test   cl,0x40
  21ba31:	48 0f 45 fa          	cmovne rdi,rdx
  21ba35:	49 0f 45 d1          	cmovne rdx,r9
        absResult ^= dstMinNormal;
  21ba39:	48 b9 00 00 00 00 00 	movabs rcx,0x1000000000000
  21ba40:	00 01 00 
  21ba43:	48 31 f9             	xor    rcx,rdi
        const resultExponent: u32 = dstExpBias - srcExpBias - scale + 1;
  21ba46:	bf 01 3c 00 00       	mov    edi,0x3c01
  21ba4b:	44 29 c7             	sub    edi,r8d
        absResult |= @intCast(dst_rep_t, resultExponent) << dstSigBits;
  21ba4e:	48 c1 e7 30          	shl    rdi,0x30
  21ba52:	48 09 cf             	or     rdi,rcx
  21ba55:	eb 04                	jmp    21ba5b <__extenddftf2+0xcb>
  21ba57:	31 d2                	xor    edx,edx
  21ba59:	31 ff                	xor    edi,edi
    const result: dst_rep_t align(@alignOf(dst_t)) = absResult | dst_rep_t(sign) << (dstBits - srcBits);
  21ba5b:	48 89 54 24 e8       	mov    QWORD PTR [rsp-0x18],rdx
  21ba60:	48 09 c7             	or     rdi,rax
  21ba63:	48 89 7c 24 f0       	mov    QWORD PTR [rsp-0x10],rdi
  21ba68:	0f 28 44 24 e8       	movaps xmm0,XMMWORD PTR [rsp-0x18]
    return extendXfYf2(f128, f64, a);
  21ba6d:	c3                   	ret    
  21ba6e:	66 90                	xchg   ax,ax

000000000021ba70 <__extendsftf2>:
    const aRep: src_rep_t = @bitCast(src_rep_t, a);
  21ba70:	c5 f9 7e c2          	vmovd  edx,xmm0
    const aAbs: src_rep_t = aRep & srcAbsMask;
  21ba74:	89 d1                	mov    ecx,edx
  21ba76:	81 e1 ff ff ff 7f    	and    ecx,0x7fffffff
    const sign: src_rep_t = aRep & srcSignMask;
  21ba7c:	89 d0                	mov    eax,edx
  21ba7e:	25 00 00 00 80       	and    eax,0x80000000
    if (aAbs -% srcMinNormal < srcInfinity - srcMinNormal) {
  21ba83:	8d b1 00 00 80 ff    	lea    esi,[rcx-0x800000]
  21ba89:	81 fe ff ff ff 7e    	cmp    esi,0x7effffff
  21ba8f:	77 17                	ja     21baa8 <__extendsftf2+0x38>
        absResult = dst_rep_t(aAbs) << (dstSigBits - srcSigBits);
  21ba91:	89 ca                	mov    edx,ecx
  21ba93:	48 c1 e2 19          	shl    rdx,0x19
        absResult += (dstExpBias - srcExpBias) << dstSigBits;
  21ba97:	48 b9 00 00 00 00 00 	movabs rcx,0x3f80000000000000
  21ba9e:	00 80 3f 
  21baa1:	48 01 d1             	add    rcx,rdx
  21baa4:	31 d2                	xor    edx,edx
  21baa6:	eb 6f                	jmp    21bb17 <__extendsftf2+0xa7>
    } else if (aAbs >= srcInfinity) {
  21baa8:	81 f9 00 00 80 7f    	cmp    ecx,0x7f800000
  21baae:	72 17                	jb     21bac7 <__extendsftf2+0x57>
        absResult |= dst_rep_t(aAbs & srcNaNCode) << (dstSigBits - srcSigBits);
  21bab0:	89 d2                	mov    edx,edx
  21bab2:	48 c1 e2 19          	shl    rdx,0x19
  21bab6:	48 b9 00 00 00 00 00 	movabs rcx,0x7fff000000000000
  21babd:	00 ff 7f 
  21bac0:	48 09 d1             	or     rcx,rdx
  21bac3:	31 d2                	xor    edx,edx
  21bac5:	eb 50                	jmp    21bb17 <__extendsftf2+0xa7>
    } else if (aAbs != 0) {
  21bac7:	85 c9                	test   ecx,ecx
  21bac9:	74 48                	je     21bb13 <__extendsftf2+0xa3>
        const scale: u32 = @clz(aAbs) - @clz(src_rep_t(srcMinNormal));
  21bacb:	f3 0f bd f1          	lzcnt  esi,ecx
  21bacf:	83 c6 38             	add    esi,0x38
  21bad2:	83 e6 3f             	and    esi,0x3f
        absResult = dst_rep_t(aAbs) << @intCast(DstShift, dstSigBits - srcSigBits + scale);
  21bad5:	89 ca                	mov    edx,ecx
  21bad7:	8d 4e 59             	lea    ecx,[rsi+0x59]
  21bada:	83 e1 7f             	and    ecx,0x7f
  21badd:	45 31 c0             	xor    r8d,r8d
  21bae0:	31 ff                	xor    edi,edi
  21bae2:	48 0f a5 d7          	shld   rdi,rdx,cl
  21bae6:	c4 e2 f1 f7 d2       	shlx   rdx,rdx,rcx
  21baeb:	f6 c1 40             	test   cl,0x40
  21baee:	48 0f 45 fa          	cmovne rdi,rdx
  21baf2:	49 0f 45 d0          	cmovne rdx,r8
        absResult ^= dstMinNormal;
  21baf6:	49 b8 00 00 00 00 00 	movabs r8,0x1000000000000
  21bafd:	00 01 00 
  21bb00:	49 31 f8             	xor    r8,rdi
        const resultExponent: u32 = dstExpBias - srcExpBias - scale + 1;
  21bb03:	b9 81 3f 00 00       	mov    ecx,0x3f81
  21bb08:	29 f1                	sub    ecx,esi
        absResult |= @intCast(dst_rep_t, resultExponent) << dstSigBits;
  21bb0a:	48 c1 e1 30          	shl    rcx,0x30
  21bb0e:	4c 09 c1             	or     rcx,r8
  21bb11:	eb 04                	jmp    21bb17 <__extendsftf2+0xa7>
  21bb13:	31 d2                	xor    edx,edx
  21bb15:	31 c9                	xor    ecx,ecx
    const result: dst_rep_t align(@alignOf(dst_t)) = absResult | dst_rep_t(sign) << (dstBits - srcBits);
  21bb17:	48 c1 e0 20          	shl    rax,0x20
  21bb1b:	48 89 54 24 e8       	mov    QWORD PTR [rsp-0x18],rdx
  21bb20:	48 09 c8             	or     rax,rcx
  21bb23:	48 89 44 24 f0       	mov    QWORD PTR [rsp-0x10],rax
  21bb28:	0f 28 44 24 e8       	movaps xmm0,XMMWORD PTR [rsp-0x18]
    return extendXfYf2(f128, f32, a);
  21bb2d:	c3                   	ret    
  21bb2e:	66 90                	xchg   ax,ax

000000000021bb30 <__trunctfdf2>:
    const aRep: src_rep_t = @bitCast(src_rep_t, a);
  21bb30:	66 0f 7f 44 24 e8    	movdqa XMMWORD PTR [rsp-0x18],xmm0
  21bb36:	48 8b 74 24 e8       	mov    rsi,QWORD PTR [rsp-0x18]
  21bb3b:	48 8b 54 24 f0       	mov    rdx,QWORD PTR [rsp-0x10]
    const aAbs: src_rep_t = aRep & srcAbsMask;
  21bb40:	b0 3f                	mov    al,0x3f
  21bb42:	c4 e2 f8 f5 ca       	bzhi   rcx,rdx,rax
    if (aAbs -% underflow < aAbs -% overflow) {
  21bb47:	48 b8 00 00 00 00 00 	movabs rax,0xc3ff000000000000
  21bb4e:	00 ff c3 
  21bb51:	48 01 c8             	add    rax,rcx
  21bb54:	48 bf 00 00 00 00 00 	movabs rdi,0xbc01000000000000
  21bb5b:	00 01 bc 
  21bb5e:	48 01 cf             	add    rdi,rcx
  21bb61:	48 39 f8             	cmp    rax,rdi
  21bb64:	73 35                	jae    21bb9b <__trunctfdf2+0x6b>
  21bb66:	48 b8 00 00 00 00 00 	movabs rax,0x4000000000000000
  21bb6d:	00 00 40 
        absResult = @truncate(dst_rep_t, aAbs >> (srcSigBits - dstSigBits));
  21bb70:	48 89 d1             	mov    rcx,rdx
  21bb73:	48 0f a4 f1 04       	shld   rcx,rsi,0x4
        const roundBits: src_rep_t = aAbs & roundMask;
  21bb78:	40 b7 3c             	mov    dil,0x3c
  21bb7b:	c4 e2 c0 f5 f6       	bzhi   rsi,rsi,rdi
        if (roundBits > halfway) {
  21bb80:	48 bf 01 00 00 00 00 	movabs rdi,0x800000000000001
  21bb87:	00 00 08 
  21bb8a:	48 39 fe             	cmp    rsi,rdi
  21bb8d:	72 40                	jb     21bbcf <__trunctfdf2+0x9f>
            absResult += 1;
  21bb8f:	48 01 c1             	add    rcx,rax
  21bb92:	48 83 c1 01          	add    rcx,0x1
  21bb96:	e9 0f 01 00 00       	jmp    21bcaa <__trunctfdf2+0x17a>
    } else if (aAbs > srcInfinity) {
  21bb9b:	48 83 fe 01          	cmp    rsi,0x1
  21bb9f:	48 b8 00 00 00 00 00 	movabs rax,0x7fff000000000000
  21bba6:	00 ff 7f 
  21bba9:	48 89 cf             	mov    rdi,rcx
  21bbac:	48 19 c7             	sbb    rdi,rax
  21bbaf:	72 55                	jb     21bc06 <__trunctfdf2+0xd6>
        absResult |= @intCast(dst_rep_t, ((aAbs & srcNaNCode) >> (srcSigBits - dstSigBits)) & dstNaNCode);
  21bbb1:	48 0f ac d6 3c       	shrd   rsi,rdx,0x3c
  21bbb6:	b0 33                	mov    al,0x33
  21bbb8:	c4 e2 f8 f5 c6       	bzhi   rax,rsi,rax
  21bbbd:	48 b9 00 00 00 00 00 	movabs rcx,0x7ff8000000000000
  21bbc4:	00 f8 7f 
  21bbc7:	48 09 c1             	or     rcx,rax
  21bbca:	e9 db 00 00 00       	jmp    21bcaa <__trunctfdf2+0x17a>
  21bbcf:	48 01 c1             	add    rcx,rax
        } else if (roundBits == halfway) {
  21bbd2:	c4 e1 f9 6e c6       	vmovq  xmm0,rsi
  21bbd7:	48 b8 00 00 00 00 00 	movabs rax,0x800000000000000
  21bbde:	00 00 08 
  21bbe1:	c4 e1 f9 6e c8       	vmovq  xmm1,rax
  21bbe6:	c5 f9 74 c1          	vpcmpeqb xmm0,xmm0,xmm1
  21bbea:	c5 f9 d7 c0          	vpmovmskb eax,xmm0
  21bbee:	3d ff ff 00 00       	cmp    eax,0xffff
  21bbf3:	0f 85 b1 00 00 00    	jne    21bcaa <__trunctfdf2+0x17a>
  21bbf9:	89 c8                	mov    eax,ecx
  21bbfb:	83 e0 01             	and    eax,0x1
  21bbfe:	48 01 c1             	add    rcx,rax
  21bc01:	e9 a4 00 00 00       	jmp    21bcaa <__trunctfdf2+0x17a>
    } else if (aAbs >= overflow) {
  21bc06:	48 c1 e9 30          	shr    rcx,0x30
  21bc0a:	48 81 f9 fe 43 00 00 	cmp    rcx,0x43fe
  21bc11:	76 0f                	jbe    21bc22 <__trunctfdf2+0xf2>
  21bc13:	48 b9 00 00 00 00 00 	movabs rcx,0x7ff0000000000000
  21bc1a:	00 f0 7f 
  21bc1d:	e9 88 00 00 00       	jmp    21bcaa <__trunctfdf2+0x17a>
        const shift = @intCast(u32, srcExpBias - dstExpBias - aExp + 1);
  21bc22:	b8 00 3c 00 00       	mov    eax,0x3c00
  21bc27:	29 c8                	sub    eax,ecx
        if (shift > srcSigBits) {
  21bc29:	83 f8 6f             	cmp    eax,0x6f
  21bc2c:	76 04                	jbe    21bc32 <__trunctfdf2+0x102>
  21bc2e:	31 c9                	xor    ecx,ecx
  21bc30:	eb 78                	jmp    21bcaa <__trunctfdf2+0x17a>
  21bc32:	b1 30                	mov    cl,0x30
  21bc34:	c4 e2 f0 f5 ca       	bzhi   rcx,rdx,rcx
  21bc39:	49 b8 00 00 00 00 00 	movabs r8,0x1000000000000
  21bc40:	00 01 00 
  21bc43:	49 09 c8             	or     r8,rcx
            const sticky: src_rep_t = significand << @intCast(SrcShift, srcBits - shift);
  21bc46:	b9 7f 00 00 00       	mov    ecx,0x7f
  21bc4b:	29 c1                	sub    ecx,eax
  21bc4d:	83 e1 7f             	and    ecx,0x7f
  21bc50:	4c 89 c7             	mov    rdi,r8
  21bc53:	48 0f a5 f7          	shld   rdi,rsi,cl
        const shift = @intCast(u32, srcExpBias - dstExpBias - aExp + 1);
  21bc57:	83 c0 01             	add    eax,0x1
            const sticky: src_rep_t = significand << @intCast(SrcShift, srcBits - shift);
  21bc5a:	c4 62 f1 f7 ce       	shlx   r9,rsi,rcx
  21bc5f:	45 31 d2             	xor    r10d,r10d
  21bc62:	f6 c1 40             	test   cl,0x40
  21bc65:	49 0f 45 f9          	cmovne rdi,r9
  21bc69:	4d 0f 45 ca          	cmovne r9,r10
            const denormalizedSignificand: src_rep_t = significand >> @intCast(SrcShift, shift) | sticky;
  21bc6d:	83 e0 7f             	and    eax,0x7f
  21bc70:	89 c1                	mov    ecx,eax
  21bc72:	4c 0f ad c6          	shrd   rsi,r8,cl
  21bc76:	c4 c2 fb f7 c8       	shrx   rcx,r8,rax
  21bc7b:	a8 40                	test   al,0x40
  21bc7d:	48 0f 45 f1          	cmovne rsi,rcx
  21bc81:	49 0f 45 ca          	cmovne rcx,r10
  21bc85:	4c 09 ce             	or     rsi,r9
  21bc88:	48 09 f9             	or     rcx,rdi
            absResult = @intCast(dst_rep_t, denormalizedSignificand >> (srcSigBits - dstSigBits));
  21bc8b:	48 0f a4 f1 04       	shld   rcx,rsi,0x4
            const roundBits: src_rep_t = denormalizedSignificand & roundMask;
  21bc90:	b0 3c                	mov    al,0x3c
  21bc92:	c4 e2 f8 f5 c6       	bzhi   rax,rsi,rax
            if (roundBits > halfway) {
  21bc97:	48 be 01 00 00 00 00 	movabs rsi,0x800000000000001
  21bc9e:	00 00 08 
  21bca1:	48 39 f0             	cmp    rax,rsi
  21bca4:	72 1a                	jb     21bcc0 <__trunctfdf2+0x190>
                absResult += 1;
  21bca6:	48 83 c1 01          	add    rcx,0x1
    const result: dst_rep_t align(@alignOf(dst_t)) = absResult | @truncate(dst_rep_t, sign >> @intCast(SrcShift, srcBits - dstBits));
  21bcaa:	48 b8 00 00 00 00 00 	movabs rax,0x8000000000000000
  21bcb1:	00 00 80 
  21bcb4:	48 21 c2             	and    rdx,rax
  21bcb7:	48 09 ca             	or     rdx,rcx
    return @bitCast(dst_t, result);
  21bcba:	c4 e1 f9 6e c2       	vmovq  xmm0,rdx
    return truncXfYf2(f64, f128, a);
  21bcbf:	c3                   	ret    
            } else if (roundBits == halfway) {
  21bcc0:	c4 e1 f9 6e c0       	vmovq  xmm0,rax
  21bcc5:	e9 0d ff ff ff       	jmp    21bbd7 <__trunctfdf2+0xa7>
  21bcca:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

000000000021bcd0 <__trunctfsf2>:
    const aRep: src_rep_t = @bitCast(src_rep_t, a);
  21bcd0:	66 0f 7f 44 24 e8    	movdqa XMMWORD PTR [rsp-0x18],xmm0
  21bcd6:	48 8b 74 24 e8       	mov    rsi,QWORD PTR [rsp-0x18]
  21bcdb:	48 8b 54 24 f0       	mov    rdx,QWORD PTR [rsp-0x10]
    const aAbs: src_rep_t = aRep & srcAbsMask;
  21bce0:	b0 3f                	mov    al,0x3f
  21bce2:	c4 e2 f8 f5 fa       	bzhi   rdi,rdx,rax
    if (aAbs -% underflow < aAbs -% overflow) {
  21bce7:	48 b8 00 00 00 00 00 	movabs rax,0xc07f000000000000
  21bcee:	00 7f c0 
  21bcf1:	48 01 f8             	add    rax,rdi
  21bcf4:	48 b9 00 00 00 00 00 	movabs rcx,0xbf81000000000000
  21bcfb:	00 81 bf 
  21bcfe:	48 01 f9             	add    rcx,rdi
  21bd01:	48 39 c8             	cmp    rax,rcx
  21bd04:	73 29                	jae    21bd2f <__trunctfsf2+0x5f>
        absResult = @truncate(dst_rep_t, aAbs >> (srcSigBits - dstSigBits));
  21bd06:	48 89 d1             	mov    rcx,rdx
  21bd09:	48 c1 e9 19          	shr    rcx,0x19
        const roundBits: src_rep_t = aAbs & roundMask;
  21bd0d:	89 d0                	mov    eax,edx
  21bd0f:	25 ff ff ff 01       	and    eax,0x1ffffff
        if (roundBits > halfway) {
  21bd14:	48 83 fe 01          	cmp    rsi,0x1
  21bd18:	48 89 c7             	mov    rdi,rax
  21bd1b:	48 81 df 00 00 00 01 	sbb    rdi,0x1000000
  21bd22:	72 39                	jb     21bd5d <__trunctfsf2+0x8d>
            absResult += 1;
  21bd24:	81 c1 01 00 00 40    	add    ecx,0x40000001
  21bd2a:	e9 0e 01 00 00       	jmp    21be3d <__trunctfsf2+0x16d>
    } else if (aAbs > srcInfinity) {
  21bd2f:	48 83 fe 01          	cmp    rsi,0x1
  21bd33:	48 b8 00 00 00 00 00 	movabs rax,0x7fff000000000000
  21bd3a:	00 ff 7f 
  21bd3d:	48 89 f9             	mov    rcx,rdi
  21bd40:	48 19 c1             	sbb    rcx,rax
  21bd43:	72 5c                	jb     21bda1 <__trunctfsf2+0xd1>
        absResult |= @intCast(dst_rep_t, ((aAbs & srcNaNCode) >> (srcSigBits - dstSigBits)) & dstNaNCode);
  21bd45:	48 89 d1             	mov    rcx,rdx
  21bd48:	48 c1 e9 19          	shr    rcx,0x19
  21bd4c:	81 e1 ff ff 3f 00    	and    ecx,0x3fffff
  21bd52:	81 c9 00 00 c0 7f    	or     ecx,0x7fc00000
  21bd58:	e9 e0 00 00 00       	jmp    21be3d <__trunctfsf2+0x16d>
  21bd5d:	81 c1 00 00 00 40    	add    ecx,0x40000000
        } else if (roundBits == halfway) {
  21bd63:	c4 e1 f9 6e c6       	vmovq  xmm0,rsi
  21bd68:	c4 e1 f9 6e c8       	vmovq  xmm1,rax
  21bd6d:	c5 f9 6c c1          	vpunpcklqdq xmm0,xmm0,xmm1
  21bd71:	b8 00 00 00 01       	mov    eax,0x1000000
  21bd76:	c4 e1 f9 6e c8       	vmovq  xmm1,rax
  21bd7b:	c5 f1 73 f9 08       	vpslldq xmm1,xmm1,0x8
  21bd80:	c5 f9 74 c1          	vpcmpeqb xmm0,xmm0,xmm1
  21bd84:	c5 f9 d7 c0          	vpmovmskb eax,xmm0
  21bd88:	3d ff ff 00 00       	cmp    eax,0xffff
  21bd8d:	0f 85 aa 00 00 00    	jne    21be3d <__trunctfsf2+0x16d>
  21bd93:	89 c8                	mov    eax,ecx
  21bd95:	83 e0 01             	and    eax,0x1
  21bd98:	01 c8                	add    eax,ecx
  21bd9a:	89 c1                	mov    ecx,eax
  21bd9c:	e9 9c 00 00 00       	jmp    21be3d <__trunctfsf2+0x16d>
    } else if (aAbs >= overflow) {
  21bda1:	48 c1 ef 30          	shr    rdi,0x30
  21bda5:	b9 00 00 80 7f       	mov    ecx,0x7f800000
  21bdaa:	48 81 ff 7e 40 00 00 	cmp    rdi,0x407e
  21bdb1:	0f 87 86 00 00 00    	ja     21be3d <__trunctfsf2+0x16d>
        const shift = @intCast(u32, srcExpBias - dstExpBias - aExp + 1);
  21bdb7:	b8 80 3f 00 00       	mov    eax,0x3f80
  21bdbc:	29 f8                	sub    eax,edi
  21bdbe:	31 c9                	xor    ecx,ecx
        if (shift > srcSigBits) {
  21bdc0:	83 f8 6f             	cmp    eax,0x6f
  21bdc3:	77 78                	ja     21be3d <__trunctfsf2+0x16d>
  21bdc5:	b1 30                	mov    cl,0x30
  21bdc7:	c4 e2 f0 f5 ca       	bzhi   rcx,rdx,rcx
  21bdcc:	48 bf 00 00 00 00 00 	movabs rdi,0x1000000000000
  21bdd3:	00 01 00 
  21bdd6:	48 09 cf             	or     rdi,rcx
            const sticky: src_rep_t = significand << @intCast(SrcShift, srcBits - shift);
  21bdd9:	b9 7f 00 00 00       	mov    ecx,0x7f
  21bdde:	29 c1                	sub    ecx,eax
  21bde0:	83 e1 7f             	and    ecx,0x7f
  21bde3:	49 89 f8             	mov    r8,rdi
  21bde6:	49 0f a5 f0          	shld   r8,rsi,cl
        const shift = @intCast(u32, srcExpBias - dstExpBias - aExp + 1);
  21bdea:	83 c0 01             	add    eax,0x1
            const sticky: src_rep_t = significand << @intCast(SrcShift, srcBits - shift);
  21bded:	c4 62 f1 f7 ce       	shlx   r9,rsi,rcx
  21bdf2:	45 31 d2             	xor    r10d,r10d
  21bdf5:	f6 c1 40             	test   cl,0x40
  21bdf8:	4d 0f 45 c1          	cmovne r8,r9
  21bdfc:	4d 0f 45 ca          	cmovne r9,r10
            const denormalizedSignificand: src_rep_t = significand >> @intCast(SrcShift, shift) | sticky;
  21be00:	83 e0 7f             	and    eax,0x7f
  21be03:	89 c1                	mov    ecx,eax
  21be05:	48 0f ad fe          	shrd   rsi,rdi,cl
  21be09:	c4 e2 fb f7 ff       	shrx   rdi,rdi,rax
  21be0e:	a8 40                	test   al,0x40
  21be10:	48 0f 45 f7          	cmovne rsi,rdi
  21be14:	49 0f 45 fa          	cmovne rdi,r10
  21be18:	4c 09 ce             	or     rsi,r9
  21be1b:	4c 09 c7             	or     rdi,r8
            absResult = @intCast(dst_rep_t, denormalizedSignificand >> (srcSigBits - dstSigBits));
  21be1e:	48 89 f9             	mov    rcx,rdi
  21be21:	48 c1 e9 19          	shr    rcx,0x19
            const roundBits: src_rep_t = denormalizedSignificand & roundMask;
  21be25:	81 e7 ff ff ff 01    	and    edi,0x1ffffff
            if (roundBits > halfway) {
  21be2b:	48 83 fe 01          	cmp    rsi,0x1
  21be2f:	48 89 f8             	mov    rax,rdi
  21be32:	48 1d 00 00 00 01    	sbb    rax,0x1000000
  21be38:	72 14                	jb     21be4e <__trunctfsf2+0x17e>
                absResult += 1;
  21be3a:	83 c1 01             	add    ecx,0x1
    const result: dst_rep_t align(@alignOf(dst_t)) = absResult | @truncate(dst_rep_t, sign >> @intCast(SrcShift, srcBits - dstBits));
  21be3d:	48 c1 ea 20          	shr    rdx,0x20
  21be41:	81 e2 00 00 00 80    	and    edx,0x80000000
  21be47:	09 ca                	or     edx,ecx
    return @bitCast(dst_t, result);
  21be49:	c5 f9 6e c2          	vmovd  xmm0,edx
    return truncXfYf2(f32, f128, a);
  21be4d:	c3                   	ret    
            } else if (roundBits == halfway) {
  21be4e:	c4 e1 f9 6e c6       	vmovq  xmm0,rsi
  21be53:	c4 e1 f9 6e cf       	vmovq  xmm1,rdi
  21be58:	e9 10 ff ff ff       	jmp    21bd6d <__trunctfsf2+0x9d>
  21be5d:	0f 1f 00             	nop    DWORD PTR [rax]

000000000021be60 <__fixunssfsi>:

    const implicitBit = (rep_t(1) << significandBits);
    const significandMask = (implicitBit - 1);

    // Break a into sign, exponent, significand
    const aRep: rep_t = @bitCast(rep_t, a);
  21be60:	c5 f9 7e c1          	vmovd  ecx,xmm0
  21be64:	31 c0                	xor    eax,eax
    const absMask = signBit - 1;
    const aAbs: rep_t = aRep & absMask;

    const sign = if ((aRep & signBit) != 0) i32(-1) else i32(1);
  21be66:	85 c9                	test   ecx,ecx
    const exponent = @intCast(i32, aAbs >> significandBits) - exponentBias;
    const significand: rep_t = (aAbs & significandMask) | implicitBit;

    // If either the value or the exponent is negative, the result is zero.
    if (sign == -1 or exponent < 0) return 0;
  21be68:	78 43                	js     21bead <__fixunssfsi+0x4d>
  21be6a:	89 ca                	mov    edx,ecx
  21be6c:	c1 ea 17             	shr    edx,0x17
  21be6f:	0f b6 f2             	movzx  esi,dl
  21be72:	83 fe 7f             	cmp    esi,0x7f
  21be75:	72 36                	jb     21bead <__fixunssfsi+0x4d>
    const exponent = @intCast(i32, aAbs >> significandBits) - exponentBias;
  21be77:	8d 7e 81             	lea    edi,[rsi-0x7f]
  21be7a:	b8 ff ff ff ff       	mov    eax,0xffffffff

    // If the value is too large for the integer type, saturate.
    if (@intCast(c_uint, exponent) >= fixuint_t.bit_count) return ~fixuint_t(0);
  21be7f:	83 ff 1f             	cmp    edi,0x1f
  21be82:	77 29                	ja     21bead <__fixunssfsi+0x4d>
  21be84:	81 e1 ff ff 7f 00    	and    ecx,0x7fffff
  21be8a:	81 c9 00 00 80 00    	or     ecx,0x800000

    // If 0 <= exponent < significandBits, right shift to get the result.
    // Otherwise, shift left.
    if (exponent < significandBits) {
  21be90:	81 fe 95 00 00 00    	cmp    esi,0x95
  21be96:	77 0d                	ja     21bea5 <__fixunssfsi+0x45>
        return @intCast(fixuint_t, significand >> @intCast(Log2Int(rep_t), significandBits - exponent));
  21be98:	b8 16 00 00 00       	mov    eax,0x16
  21be9d:	29 d0                	sub    eax,edx
  21be9f:	c4 e2 7b f7 c1       	shrx   eax,ecx,eax
const fixuint = @import("fixuint.zig").fixuint;
const builtin = @import("builtin");

pub extern fn __fixunssfsi(a: f32) u32 {
    @setRuntimeSafety(builtin.is_test);
    return fixuint(f32, u32, a);
  21bea4:	c3                   	ret    
    } else {
        return @intCast(fixuint_t, significand) << @intCast(Log2Int(fixuint_t), exponent - significandBits);
  21bea5:	83 c2 0a             	add    edx,0xa
  21bea8:	c4 e2 69 f7 c1       	shlx   eax,ecx,edx
  21bead:	c3                   	ret    
  21beae:	66 90                	xchg   ax,ax

000000000021beb0 <__fixunssfdi>:
    const aRep: rep_t = @bitCast(rep_t, a);
  21beb0:	c5 f9 7e c1          	vmovd  ecx,xmm0
  21beb4:	31 c0                	xor    eax,eax
    const sign = if ((aRep & signBit) != 0) i32(-1) else i32(1);
  21beb6:	85 c9                	test   ecx,ecx
    if (sign == -1 or exponent < 0) return 0;
  21beb8:	78 47                	js     21bf01 <__fixunssfdi+0x51>
  21beba:	89 ca                	mov    edx,ecx
  21bebc:	c1 ea 17             	shr    edx,0x17
  21bebf:	0f b6 f2             	movzx  esi,dl
  21bec2:	83 fe 7f             	cmp    esi,0x7f
  21bec5:	72 3a                	jb     21bf01 <__fixunssfdi+0x51>
    const exponent = @intCast(i32, aAbs >> significandBits) - exponentBias;
  21bec7:	8d 7e 81             	lea    edi,[rsi-0x7f]
  21beca:	48 c7 c0 ff ff ff ff 	mov    rax,0xffffffffffffffff
    if (@intCast(c_uint, exponent) >= fixuint_t.bit_count) return ~fixuint_t(0);
  21bed1:	83 ff 3f             	cmp    edi,0x3f
  21bed4:	77 2b                	ja     21bf01 <__fixunssfdi+0x51>
  21bed6:	81 e1 ff ff 7f 00    	and    ecx,0x7fffff
  21bedc:	81 c9 00 00 80 00    	or     ecx,0x800000
    if (exponent < significandBits) {
  21bee2:	81 fe 95 00 00 00    	cmp    esi,0x95
  21bee8:	77 0d                	ja     21bef7 <__fixunssfdi+0x47>
        return @intCast(fixuint_t, significand >> @intCast(Log2Int(rep_t), significandBits - exponent));
  21beea:	b8 16 00 00 00       	mov    eax,0x16
  21beef:	29 d0                	sub    eax,edx
  21bef1:	c4 e2 7b f7 c1       	shrx   eax,ecx,eax
const fixuint = @import("fixuint.zig").fixuint;
const builtin = @import("builtin");

pub extern fn __fixunssfdi(a: f32) u64 {
    @setRuntimeSafety(builtin.is_test);
    return fixuint(f32, u64, a);
  21bef6:	c3                   	ret    
        return @intCast(fixuint_t, significand) << @intCast(Log2Int(fixuint_t), exponent - significandBits);
  21bef7:	89 c8                	mov    eax,ecx
  21bef9:	83 c2 2a             	add    edx,0x2a
  21befc:	c4 e2 e9 f7 c0       	shlx   rax,rax,rdx
  21bf01:	c3                   	ret    
  21bf02:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21bf09:	1f 84 00 00 00 00 00 

000000000021bf10 <__fixunssfti>:
    const aRep: rep_t = @bitCast(rep_t, a);
  21bf10:	c5 f9 7e c6          	vmovd  esi,xmm0
  21bf14:	31 d2                	xor    edx,edx
  21bf16:	b8 00 00 00 00       	mov    eax,0x0
    const sign = if ((aRep & signBit) != 0) i32(-1) else i32(1);
  21bf1b:	85 f6                	test   esi,esi
    if (sign == -1 or exponent < 0) return 0;
  21bf1d:	78 68                	js     21bf87 <__fixunssfti+0x77>
  21bf1f:	89 f1                	mov    ecx,esi
  21bf21:	c1 e9 17             	shr    ecx,0x17
  21bf24:	0f b6 f9             	movzx  edi,cl
  21bf27:	83 ff 7f             	cmp    edi,0x7f
  21bf2a:	72 5b                	jb     21bf87 <__fixunssfti+0x77>
    const exponent = @intCast(i32, aAbs >> significandBits) - exponentBias;
  21bf2c:	44 8d 47 81          	lea    r8d,[rdi-0x7f]
  21bf30:	48 c7 c0 ff ff ff ff 	mov    rax,0xffffffffffffffff
  21bf37:	48 c7 c2 ff ff ff ff 	mov    rdx,0xffffffffffffffff
    if (@intCast(c_uint, exponent) >= fixuint_t.bit_count) return ~fixuint_t(0);
  21bf3e:	41 83 f8 7f          	cmp    r8d,0x7f
  21bf42:	77 43                	ja     21bf87 <__fixunssfti+0x77>
  21bf44:	81 e6 ff ff 7f 00    	and    esi,0x7fffff
  21bf4a:	81 ce 00 00 80 00    	or     esi,0x800000
    if (exponent < significandBits) {
  21bf50:	81 ff 95 00 00 00    	cmp    edi,0x95
  21bf56:	77 0f                	ja     21bf67 <__fixunssfti+0x57>
        return @intCast(fixuint_t, significand >> @intCast(Log2Int(rep_t), significandBits - exponent));
  21bf58:	b8 16 00 00 00       	mov    eax,0x16
  21bf5d:	29 c8                	sub    eax,ecx
  21bf5f:	c4 e2 7b f7 c6       	shrx   eax,esi,eax
  21bf64:	31 d2                	xor    edx,edx
const fixuint = @import("fixuint.zig").fixuint;
const builtin = @import("builtin");

pub extern fn __fixunssfti(a: f32) u128 {
    @setRuntimeSafety(builtin.is_test);
    return fixuint(f32, u128, a);
  21bf66:	c3                   	ret    
        return @intCast(fixuint_t, significand) << @intCast(Log2Int(fixuint_t), exponent - significandBits);
  21bf67:	89 f0                	mov    eax,esi
  21bf69:	83 c1 6a             	add    ecx,0x6a
  21bf6c:	83 e1 7f             	and    ecx,0x7f
  21bf6f:	31 d2                	xor    edx,edx
  21bf71:	48 0f a5 c2          	shld   rdx,rax,cl
  21bf75:	31 f6                	xor    esi,esi
  21bf77:	c4 e2 f1 f7 c0       	shlx   rax,rax,rcx
  21bf7c:	f6 c1 40             	test   cl,0x40
  21bf7f:	48 0f 45 d0          	cmovne rdx,rax
  21bf83:	48 0f 45 c6          	cmovne rax,rsi
  21bf87:	c3                   	ret    
  21bf88:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  21bf8f:	00 

000000000021bf90 <__fixunsdfsi>:
    const aRep: rep_t = @bitCast(rep_t, a);
  21bf90:	c4 e1 f9 7e c2       	vmovq  rdx,xmm0
  21bf95:	31 c0                	xor    eax,eax
    const sign = if ((aRep & signBit) != 0) i32(-1) else i32(1);
  21bf97:	48 85 d2             	test   rdx,rdx
    if (sign == -1 or exponent < 0) return 0;
  21bf9a:	78 4b                	js     21bfe7 <__fixunsdfsi+0x57>
  21bf9c:	48 89 d1             	mov    rcx,rdx
  21bf9f:	48 c1 e9 34          	shr    rcx,0x34
  21bfa3:	89 ce                	mov    esi,ecx
  21bfa5:	81 e6 ff 07 00 00    	and    esi,0x7ff
  21bfab:	81 fe ff 03 00 00    	cmp    esi,0x3ff
  21bfb1:	72 34                	jb     21bfe7 <__fixunsdfsi+0x57>
    const exponent = @intCast(i32, aAbs >> significandBits) - exponentBias;
  21bfb3:	81 c6 01 fc ff ff    	add    esi,0xfffffc01
  21bfb9:	b8 ff ff ff ff       	mov    eax,0xffffffff
    if (@intCast(c_uint, exponent) >= fixuint_t.bit_count) return ~fixuint_t(0);
  21bfbe:	83 fe 1f             	cmp    esi,0x1f
  21bfc1:	77 24                	ja     21bfe7 <__fixunsdfsi+0x57>
  21bfc3:	b0 34                	mov    al,0x34
  21bfc5:	c4 e2 f8 f5 c2       	bzhi   rax,rdx,rax
  21bfca:	48 ba ff ff ff ff ff 	movabs rdx,0xfffffffffffff
  21bfd1:	ff 0f 00 
  21bfd4:	48 83 c2 01          	add    rdx,0x1
  21bfd8:	48 09 c2             	or     rdx,rax
        return @intCast(fixuint_t, significand >> @intCast(Log2Int(rep_t), significandBits - exponent));
  21bfdb:	b8 33 00 00 00       	mov    eax,0x33
  21bfe0:	29 c8                	sub    eax,ecx
  21bfe2:	c4 e2 fb f7 c2       	shrx   rax,rdx,rax
const fixuint = @import("fixuint.zig").fixuint;
const builtin = @import("builtin");

pub extern fn __fixunsdfsi(a: f64) u32 {
    @setRuntimeSafety(builtin.is_test);
    return fixuint(f64, u32, a);
  21bfe7:	c3                   	ret    
  21bfe8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  21bfef:	00 

000000000021bff0 <__fixunsdfdi>:
    const aRep: rep_t = @bitCast(rep_t, a);
  21bff0:	c4 e1 f9 7e c2       	vmovq  rdx,xmm0
  21bff5:	31 c0                	xor    eax,eax
    const sign = if ((aRep & signBit) != 0) i32(-1) else i32(1);
  21bff7:	48 85 d2             	test   rdx,rdx
    if (sign == -1 or exponent < 0) return 0;
  21bffa:	78 5e                	js     21c05a <__fixunsdfdi+0x6a>
  21bffc:	48 89 d1             	mov    rcx,rdx
  21bfff:	48 c1 e9 34          	shr    rcx,0x34
  21c003:	89 ce                	mov    esi,ecx
  21c005:	81 e6 ff 07 00 00    	and    esi,0x7ff
  21c00b:	81 fe ff 03 00 00    	cmp    esi,0x3ff
  21c011:	72 47                	jb     21c05a <__fixunsdfdi+0x6a>
    const exponent = @intCast(i32, aAbs >> significandBits) - exponentBias;
  21c013:	8d be 01 fc ff ff    	lea    edi,[rsi-0x3ff]
  21c019:	48 c7 c0 ff ff ff ff 	mov    rax,0xffffffffffffffff
    if (@intCast(c_uint, exponent) >= fixuint_t.bit_count) return ~fixuint_t(0);
  21c020:	83 ff 3f             	cmp    edi,0x3f
  21c023:	77 35                	ja     21c05a <__fixunsdfdi+0x6a>
  21c025:	b0 34                	mov    al,0x34
  21c027:	c4 e2 f8 f5 d2       	bzhi   rdx,rdx,rax
  21c02c:	48 b8 ff ff ff ff ff 	movabs rax,0xfffffffffffff
  21c033:	ff 0f 00 
  21c036:	48 83 c0 01          	add    rax,0x1
  21c03a:	48 09 d0             	or     rax,rdx
    if (exponent < significandBits) {
  21c03d:	81 fe 32 04 00 00    	cmp    esi,0x432
  21c043:	77 0d                	ja     21c052 <__fixunsdfdi+0x62>
        return @intCast(fixuint_t, significand >> @intCast(Log2Int(rep_t), significandBits - exponent));
  21c045:	ba 33 00 00 00       	mov    edx,0x33
  21c04a:	29 ca                	sub    edx,ecx
  21c04c:	c4 e2 eb f7 c0       	shrx   rax,rax,rdx
const fixuint = @import("fixuint.zig").fixuint;
const builtin = @import("builtin");

pub extern fn __fixunsdfdi(a: f64) u64 {
    @setRuntimeSafety(builtin.is_test);
    return fixuint(f64, u64, a);
  21c051:	c3                   	ret    
        return @intCast(fixuint_t, significand) << @intCast(Log2Int(fixuint_t), exponent - significandBits);
  21c052:	83 c1 0d             	add    ecx,0xd
  21c055:	c4 e2 f1 f7 c0       	shlx   rax,rax,rcx
  21c05a:	c3                   	ret    
  21c05b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

000000000021c060 <__fixunsdfti>:
    const aRep: rep_t = @bitCast(rep_t, a);
  21c060:	c4 e1 f9 7e c6       	vmovq  rsi,xmm0
  21c065:	31 d2                	xor    edx,edx
  21c067:	b8 00 00 00 00       	mov    eax,0x0
    const sign = if ((aRep & signBit) != 0) i32(-1) else i32(1);
  21c06c:	48 85 f6             	test   rsi,rsi
    if (sign == -1 or exponent < 0) return 0;
  21c06f:	78 7f                	js     21c0f0 <__fixunsdfti+0x90>
  21c071:	48 89 f1             	mov    rcx,rsi
  21c074:	48 c1 e9 34          	shr    rcx,0x34
  21c078:	89 cf                	mov    edi,ecx
  21c07a:	81 e7 ff 07 00 00    	and    edi,0x7ff
  21c080:	81 ff ff 03 00 00    	cmp    edi,0x3ff
  21c086:	72 68                	jb     21c0f0 <__fixunsdfti+0x90>
    const exponent = @intCast(i32, aAbs >> significandBits) - exponentBias;
  21c088:	44 8d 87 01 fc ff ff 	lea    r8d,[rdi-0x3ff]
  21c08f:	48 c7 c0 ff ff ff ff 	mov    rax,0xffffffffffffffff
  21c096:	48 c7 c2 ff ff ff ff 	mov    rdx,0xffffffffffffffff
    if (@intCast(c_uint, exponent) >= fixuint_t.bit_count) return ~fixuint_t(0);
  21c09d:	41 83 f8 7f          	cmp    r8d,0x7f
  21c0a1:	77 4d                	ja     21c0f0 <__fixunsdfti+0x90>
  21c0a3:	b0 34                	mov    al,0x34
  21c0a5:	c4 e2 f8 f5 d6       	bzhi   rdx,rsi,rax
  21c0aa:	48 b8 ff ff ff ff ff 	movabs rax,0xfffffffffffff
  21c0b1:	ff 0f 00 
  21c0b4:	48 83 c0 01          	add    rax,0x1
  21c0b8:	48 09 d0             	or     rax,rdx
    if (exponent < significandBits) {
  21c0bb:	81 ff 32 04 00 00    	cmp    edi,0x432
  21c0c1:	77 0f                	ja     21c0d2 <__fixunsdfti+0x72>
        return @intCast(fixuint_t, significand >> @intCast(Log2Int(rep_t), significandBits - exponent));
  21c0c3:	ba 33 00 00 00       	mov    edx,0x33
  21c0c8:	29 ca                	sub    edx,ecx
  21c0ca:	c4 e2 eb f7 c0       	shrx   rax,rax,rdx
  21c0cf:	31 d2                	xor    edx,edx
const fixuint = @import("fixuint.zig").fixuint;
const builtin = @import("builtin");

pub extern fn __fixunsdfti(a: f64) u128 {
    @setRuntimeSafety(builtin.is_test);
    return fixuint(f64, u128, a);
  21c0d1:	c3                   	ret    
        return @intCast(fixuint_t, significand) << @intCast(Log2Int(fixuint_t), exponent - significandBits);
  21c0d2:	8d 49 4d             	lea    ecx,[rcx+0x4d]
  21c0d5:	83 e1 7f             	and    ecx,0x7f
  21c0d8:	31 d2                	xor    edx,edx
  21c0da:	48 0f a5 c2          	shld   rdx,rax,cl
  21c0de:	31 f6                	xor    esi,esi
  21c0e0:	c4 e2 f1 f7 c0       	shlx   rax,rax,rcx
  21c0e5:	f6 c1 40             	test   cl,0x40
  21c0e8:	48 0f 45 d0          	cmovne rdx,rax
  21c0ec:	48 0f 45 c6          	cmovne rax,rsi
  21c0f0:	c3                   	ret    
  21c0f1:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21c0f8:	0f 1f 84 00 00 00 00 
  21c0ff:	00 

000000000021c100 <__fixunstfsi>:
    const aRep: rep_t = @bitCast(rep_t, a);
  21c100:	0f 29 44 24 e8       	movaps XMMWORD PTR [rsp-0x18],xmm0
  21c105:	48 8b 4c 24 f0       	mov    rcx,QWORD PTR [rsp-0x10]
  21c10a:	31 c0                	xor    eax,eax
    const sign = if ((aRep & signBit) != 0) i32(-1) else i32(1);
  21c10c:	48 85 c9             	test   rcx,rcx
    if (sign == -1 or exponent < 0) return 0;
  21c10f:	78 5a                	js     21c16b <__fixunstfsi+0x6b>
  21c111:	48 89 ca             	mov    rdx,rcx
  21c114:	48 c1 ea 30          	shr    rdx,0x30
  21c118:	89 d6                	mov    esi,edx
  21c11a:	81 e6 ff 7f 00 00    	and    esi,0x7fff
  21c120:	81 fe ff 3f 00 00    	cmp    esi,0x3fff
  21c126:	72 43                	jb     21c16b <__fixunstfsi+0x6b>
    const exponent = @intCast(i32, aAbs >> significandBits) - exponentBias;
  21c128:	81 c6 01 c0 ff ff    	add    esi,0xffffc001
  21c12e:	b8 ff ff ff ff       	mov    eax,0xffffffff
    if (@intCast(c_uint, exponent) >= fixuint_t.bit_count) return ~fixuint_t(0);
  21c133:	83 fe 1f             	cmp    esi,0x1f
  21c136:	77 33                	ja     21c16b <__fixunstfsi+0x6b>
  21c138:	48 8b 74 24 e8       	mov    rsi,QWORD PTR [rsp-0x18]
  21c13d:	b0 30                	mov    al,0x30
  21c13f:	c4 e2 f8 f5 c1       	bzhi   rax,rcx,rax
  21c144:	48 bf 00 00 00 00 00 	movabs rdi,0x1000000000000
  21c14b:	00 01 00 
  21c14e:	48 09 c7             	or     rdi,rax
        return @intCast(fixuint_t, significand >> @intCast(Log2Int(rep_t), significandBits - exponent));
  21c151:	b9 6f 00 00 00       	mov    ecx,0x6f
  21c156:	29 d1                	sub    ecx,edx
  21c158:	83 e1 7f             	and    ecx,0x7f
  21c15b:	48 0f ad fe          	shrd   rsi,rdi,cl
  21c15f:	c4 e2 f3 f7 c7       	shrx   rax,rdi,rcx
  21c164:	f6 c1 40             	test   cl,0x40
  21c167:	48 0f 44 c6          	cmove  rax,rsi
const fixuint = @import("fixuint.zig").fixuint;
const builtin = @import("builtin");

pub extern fn __fixunstfsi(a: f128) u32 {
    @setRuntimeSafety(builtin.is_test);
    return fixuint(f128, u32, a);
  21c16b:	c3                   	ret    
  21c16c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

000000000021c170 <__fixunstfdi>:
    const aRep: rep_t = @bitCast(rep_t, a);
  21c170:	0f 29 44 24 e8       	movaps XMMWORD PTR [rsp-0x18],xmm0
  21c175:	48 8b 4c 24 f0       	mov    rcx,QWORD PTR [rsp-0x10]
  21c17a:	31 c0                	xor    eax,eax
    const sign = if ((aRep & signBit) != 0) i32(-1) else i32(1);
  21c17c:	48 85 c9             	test   rcx,rcx
    if (sign == -1 or exponent < 0) return 0;
  21c17f:	78 5c                	js     21c1dd <__fixunstfdi+0x6d>
  21c181:	48 89 ca             	mov    rdx,rcx
  21c184:	48 c1 ea 30          	shr    rdx,0x30
  21c188:	89 d6                	mov    esi,edx
  21c18a:	81 e6 ff 7f 00 00    	and    esi,0x7fff
  21c190:	81 fe ff 3f 00 00    	cmp    esi,0x3fff
  21c196:	72 45                	jb     21c1dd <__fixunstfdi+0x6d>
    const exponent = @intCast(i32, aAbs >> significandBits) - exponentBias;
  21c198:	81 c6 01 c0 ff ff    	add    esi,0xffffc001
  21c19e:	48 c7 c0 ff ff ff ff 	mov    rax,0xffffffffffffffff
    if (@intCast(c_uint, exponent) >= fixuint_t.bit_count) return ~fixuint_t(0);
  21c1a5:	83 fe 3f             	cmp    esi,0x3f
  21c1a8:	77 33                	ja     21c1dd <__fixunstfdi+0x6d>
  21c1aa:	48 8b 74 24 e8       	mov    rsi,QWORD PTR [rsp-0x18]
  21c1af:	b0 30                	mov    al,0x30
  21c1b1:	c4 e2 f8 f5 c1       	bzhi   rax,rcx,rax
  21c1b6:	48 bf 00 00 00 00 00 	movabs rdi,0x1000000000000
  21c1bd:	00 01 00 
  21c1c0:	48 09 c7             	or     rdi,rax
        return @intCast(fixuint_t, significand >> @intCast(Log2Int(rep_t), significandBits - exponent));
  21c1c3:	b9 6f 00 00 00       	mov    ecx,0x6f
  21c1c8:	29 d1                	sub    ecx,edx
  21c1ca:	83 e1 7f             	and    ecx,0x7f
  21c1cd:	48 0f ad fe          	shrd   rsi,rdi,cl
  21c1d1:	c4 e2 f3 f7 c7       	shrx   rax,rdi,rcx
  21c1d6:	f6 c1 40             	test   cl,0x40
  21c1d9:	48 0f 44 c6          	cmove  rax,rsi
const fixuint = @import("fixuint.zig").fixuint;
const builtin = @import("builtin");

pub extern fn __fixunstfdi(a: f128) u64 {
    @setRuntimeSafety(builtin.is_test);
    return fixuint(f128, u64, a);
  21c1dd:	c3                   	ret    
  21c1de:	66 90                	xchg   ax,ax

000000000021c1e0 <__fixunstfti>:
    const aRep: rep_t = @bitCast(rep_t, a);
  21c1e0:	0f 29 44 24 e8       	movaps XMMWORD PTR [rsp-0x18],xmm0
  21c1e5:	48 8b 74 24 f0       	mov    rsi,QWORD PTR [rsp-0x10]
  21c1ea:	31 d2                	xor    edx,edx
  21c1ec:	b8 00 00 00 00       	mov    eax,0x0
    const sign = if ((aRep & signBit) != 0) i32(-1) else i32(1);
  21c1f1:	48 85 f6             	test   rsi,rsi
    if (sign == -1 or exponent < 0) return 0;
  21c1f4:	0f 88 93 00 00 00    	js     21c28d <__fixunstfti+0xad>
  21c1fa:	48 89 f1             	mov    rcx,rsi
  21c1fd:	48 c1 e9 30          	shr    rcx,0x30
  21c201:	89 cf                	mov    edi,ecx
  21c203:	81 e7 ff 7f 00 00    	and    edi,0x7fff
  21c209:	81 ff ff 3f 00 00    	cmp    edi,0x3fff
  21c20f:	72 7c                	jb     21c28d <__fixunstfti+0xad>
    const exponent = @intCast(i32, aAbs >> significandBits) - exponentBias;
  21c211:	44 8d 87 01 c0 ff ff 	lea    r8d,[rdi-0x3fff]
  21c218:	48 c7 c0 ff ff ff ff 	mov    rax,0xffffffffffffffff
  21c21f:	48 c7 c2 ff ff ff ff 	mov    rdx,0xffffffffffffffff
    if (@intCast(c_uint, exponent) >= fixuint_t.bit_count) return ~fixuint_t(0);
  21c226:	41 83 f8 7f          	cmp    r8d,0x7f
  21c22a:	77 61                	ja     21c28d <__fixunstfti+0xad>
  21c22c:	48 8b 44 24 e8       	mov    rax,QWORD PTR [rsp-0x18]
  21c231:	b2 30                	mov    dl,0x30
  21c233:	c4 e2 e8 f5 f6       	bzhi   rsi,rsi,rdx
  21c238:	48 ba 00 00 00 00 00 	movabs rdx,0x1000000000000
  21c23f:	00 01 00 
  21c242:	48 09 f2             	or     rdx,rsi
    if (exponent < significandBits) {
  21c245:	81 ff 6e 40 00 00    	cmp    edi,0x406e
  21c24b:	77 24                	ja     21c271 <__fixunstfti+0x91>
        return @intCast(fixuint_t, significand >> @intCast(Log2Int(rep_t), significandBits - exponent));
  21c24d:	be 6f 00 00 00       	mov    esi,0x6f
  21c252:	29 ce                	sub    esi,ecx
  21c254:	83 e6 7f             	and    esi,0x7f
  21c257:	89 f1                	mov    ecx,esi
  21c259:	48 0f ad d0          	shrd   rax,rdx,cl
  21c25d:	c4 e2 cb f7 ca       	shrx   rcx,rdx,rsi
  21c262:	31 d2                	xor    edx,edx
  21c264:	40 f6 c6 40          	test   sil,0x40
  21c268:	48 0f 45 c1          	cmovne rax,rcx
  21c26c:	48 0f 44 d1          	cmove  rdx,rcx
const fixuint = @import("fixuint.zig").fixuint;
const builtin = @import("builtin");

pub extern fn __fixunstfti(a: f128) u128 {
    @setRuntimeSafety(builtin.is_test);
    return fixuint(f128, u128, a);
  21c270:	c3                   	ret    
        return @intCast(fixuint_t, significand) << @intCast(Log2Int(fixuint_t), exponent - significandBits);
  21c271:	83 c1 11             	add    ecx,0x11
  21c274:	83 e1 7f             	and    ecx,0x7f
  21c277:	48 0f a5 c2          	shld   rdx,rax,cl
  21c27b:	c4 e2 f1 f7 f0       	shlx   rsi,rax,rcx
  21c280:	31 c0                	xor    eax,eax
  21c282:	f6 c1 40             	test   cl,0x40
  21c285:	48 0f 45 d6          	cmovne rdx,rsi
  21c289:	48 0f 44 c6          	cmove  rax,rsi
  21c28d:	c3                   	ret    
  21c28e:	66 90                	xchg   ax,ax

000000000021c290 <__udivsi3>:
    const d = __udivsi3(a, b);
    rem.* = @bitCast(u32, @bitCast(i32, a) -% (@bitCast(i32, d) * @bitCast(i32, b)));
    return d;
}

extern fn __udivsi3(n: u32, d: u32) u32 {
  21c290:	55                   	push   rbp
  21c291:	41 56                	push   r14
  21c293:	53                   	push   rbx
  21c294:	31 c0                	xor    eax,eax
    @setRuntimeSafety(is_test);

    const n_uword_bits: c_uint = u32.bit_count;
    // special cases
    if (d == 0) return 0; // ?!
    if (n == 0) return 0;
  21c296:	85 ff                	test   edi,edi
    if (d == 0) return 0; // ?!
  21c298:	74 19                	je     21c2b3 <__udivsi3+0x23>
  21c29a:	85 f6                	test   esi,esi
  21c29c:	74 15                	je     21c2b3 <__udivsi3+0x23>
    var sr = @bitCast(c_uint, c_int(@clz(d)) - c_int(@clz(n)));
  21c29e:	f3 0f bd ce          	lzcnt  ecx,esi
  21c2a2:	f3 0f bd d7          	lzcnt  edx,edi
  21c2a6:	89 cb                	mov    ebx,ecx
  21c2a8:	29 d3                	sub    ebx,edx
    // 0 <= sr <= n_uword_bits - 1 or sr large
    if (sr > n_uword_bits - 1) {
  21c2aa:	83 fb 1f             	cmp    ebx,0x1f
  21c2ad:	77 04                	ja     21c2b3 <__udivsi3+0x23>
        // d > r
        return 0;
    }
    if (sr == n_uword_bits - 1) {
  21c2af:	75 07                	jne    21c2b8 <__udivsi3+0x28>
  21c2b1:	89 f8                	mov    eax,edi
  21c2b3:	5b                   	pop    rbx
  21c2b4:	41 5e                	pop    r14
  21c2b6:	5d                   	pop    rbp
  21c2b7:	c3                   	ret    
        // d == 1
        return n;
    }
    sr += 1;
  21c2b8:	44 8d 4b 01          	lea    r9d,[rbx+0x1]
    // 1 <= sr <= n_uword_bits - 1
    // Not a special case
    var q: u32 = n << @intCast(u5, n_uword_bits - sr);
  21c2bc:	b8 1f 00 00 00       	mov    eax,0x1f
  21c2c1:	29 d8                	sub    eax,ebx
  21c2c3:	c4 e2 79 f7 c7       	shlx   eax,edi,eax
    var r: u32 = n >> @intCast(u5, sr);
  21c2c8:	c4 e2 33 f7 ff       	shrx   edi,edi,r9d
  21c2cd:	44 8d 46 ff          	lea    r8d,[rsi-0x1]
    var carry: u32 = 0;
    while (sr > 0) : (sr -= 1) {
  21c2d1:	41 83 e1 03          	and    r9d,0x3
  21c2d5:	83 fb 03             	cmp    ebx,0x3
  21c2d8:	73 10                	jae    21c2ea <__udivsi3+0x5a>
  21c2da:	31 c9                	xor    ecx,ecx
  21c2dc:	45 85 c9             	test   r9d,r9d
  21c2df:	0f 85 a6 00 00 00    	jne    21c38b <__udivsi3+0xfb>
  21c2e5:	e9 c5 00 00 00       	jmp    21c3af <__udivsi3+0x11f>
  21c2ea:	42 8d 14 0a          	lea    edx,[rdx+r9*1]
  21c2ee:	83 c2 ff             	add    edx,0xffffffff
  21c2f1:	29 ca                	sub    edx,ecx
  21c2f3:	31 c9                	xor    ecx,ecx
  21c2f5:	41 ba 1e 01 00 00    	mov    r10d,0x11e
  21c2fb:	41 bb 1d 01 00 00    	mov    r11d,0x11d
  21c301:	41 be 1c 01 00 00    	mov    r14d,0x11c
  21c307:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  21c30e:	00 00 
        // r:q = ((r:q)  << 1) | carry
        r = (r << 1) | (q >> @intCast(u5, n_uword_bits - 1));
  21c310:	0f a4 c7 01          	shld   edi,eax,0x1
        q = (q << 1) | carry;
  21c314:	8d 1c 00             	lea    ebx,[rax+rax*1]
  21c317:	09 cb                	or     ebx,ecx
        // if (r.all >= d.all)
        // {
        //      r.all -= d.all;
        //      carry = 1;
        // }
        const s = @intCast(i32, d -% r -% 1) >> @intCast(u5, n_uword_bits - 1);
  21c319:	44 89 c1             	mov    ecx,r8d
  21c31c:	29 f9                	sub    ecx,edi
  21c31e:	c1 f9 1f             	sar    ecx,0x1f
        carry = @intCast(u32, s & 1);
  21c321:	89 cd                	mov    ebp,ecx
  21c323:	83 e5 01             	and    ebp,0x1
        r -= d & @bitCast(u32, s);
  21c326:	21 f1                	and    ecx,esi
  21c328:	29 cf                	sub    edi,ecx
        r = (r << 1) | (q >> @intCast(u5, n_uword_bits - 1));
  21c32a:	c4 e2 28 f7 c8       	bextr  ecx,eax,r10d
  21c32f:	8d 0c 79             	lea    ecx,[rcx+rdi*2]
        q = (q << 1) | carry;
  21c332:	8d 7c 5d 00          	lea    edi,[rbp+rbx*2+0x0]
        const s = @intCast(i32, d -% r -% 1) >> @intCast(u5, n_uword_bits - 1);
  21c336:	44 89 c3             	mov    ebx,r8d
  21c339:	29 cb                	sub    ebx,ecx
  21c33b:	c1 fb 1f             	sar    ebx,0x1f
        carry = @intCast(u32, s & 1);
  21c33e:	89 dd                	mov    ebp,ebx
  21c340:	83 e5 01             	and    ebp,0x1
        r -= d & @bitCast(u32, s);
  21c343:	21 f3                	and    ebx,esi
  21c345:	29 d9                	sub    ecx,ebx
        r = (r << 1) | (q >> @intCast(u5, n_uword_bits - 1));
  21c347:	c4 e2 20 f7 d8       	bextr  ebx,eax,r11d
  21c34c:	8d 0c 4b             	lea    ecx,[rbx+rcx*2]
        q = (q << 1) | carry;
  21c34f:	8d 5c 7d 00          	lea    ebx,[rbp+rdi*2+0x0]
        const s = @intCast(i32, d -% r -% 1) >> @intCast(u5, n_uword_bits - 1);
  21c353:	44 89 c7             	mov    edi,r8d
  21c356:	29 cf                	sub    edi,ecx
  21c358:	c1 ff 1f             	sar    edi,0x1f
        carry = @intCast(u32, s & 1);
  21c35b:	89 fd                	mov    ebp,edi
  21c35d:	83 e5 01             	and    ebp,0x1
        r -= d & @bitCast(u32, s);
  21c360:	21 f7                	and    edi,esi
  21c362:	29 f9                	sub    ecx,edi
        r = (r << 1) | (q >> @intCast(u5, n_uword_bits - 1));
  21c364:	c4 e2 08 f7 c0       	bextr  eax,eax,r14d
  21c369:	8d 3c 48             	lea    edi,[rax+rcx*2]
        q = (q << 1) | carry;
  21c36c:	8d 44 5d 00          	lea    eax,[rbp+rbx*2+0x0]
        const s = @intCast(i32, d -% r -% 1) >> @intCast(u5, n_uword_bits - 1);
  21c370:	44 89 c3             	mov    ebx,r8d
  21c373:	29 fb                	sub    ebx,edi
  21c375:	c1 fb 1f             	sar    ebx,0x1f
        carry = @intCast(u32, s & 1);
  21c378:	89 d9                	mov    ecx,ebx
  21c37a:	83 e1 01             	and    ecx,0x1
        r -= d & @bitCast(u32, s);
  21c37d:	21 f3                	and    ebx,esi
  21c37f:	29 df                	sub    edi,ebx
    while (sr > 0) : (sr -= 1) {
  21c381:	83 c2 04             	add    edx,0x4
  21c384:	75 8a                	jne    21c310 <__udivsi3+0x80>
  21c386:	45 85 c9             	test   r9d,r9d
  21c389:	74 24                	je     21c3af <__udivsi3+0x11f>
  21c38b:	41 f7 d9             	neg    r9d
  21c38e:	66 90                	xchg   ax,ax
        r = (r << 1) | (q >> @intCast(u5, n_uword_bits - 1));
  21c390:	0f a4 c7 01          	shld   edi,eax,0x1
        q = (q << 1) | carry;
  21c394:	01 c0                	add    eax,eax
  21c396:	09 c8                	or     eax,ecx
        const s = @intCast(i32, d -% r -% 1) >> @intCast(u5, n_uword_bits - 1);
  21c398:	44 89 c2             	mov    edx,r8d
  21c39b:	29 fa                	sub    edx,edi
  21c39d:	c1 fa 1f             	sar    edx,0x1f
        carry = @intCast(u32, s & 1);
  21c3a0:	89 d1                	mov    ecx,edx
  21c3a2:	83 e1 01             	and    ecx,0x1
        r -= d & @bitCast(u32, s);
  21c3a5:	21 f2                	and    edx,esi
  21c3a7:	29 d7                	sub    edi,edx
    while (sr > 0) : (sr -= 1) {
  21c3a9:	41 83 c1 01          	add    r9d,0x1
  21c3ad:	75 e1                	jne    21c390 <__udivsi3+0x100>
    }
    q = (q << 1) | carry;
  21c3af:	01 c0                	add    eax,eax
  21c3b1:	09 c8                	or     eax,ecx
  21c3b3:	5b                   	pop    rbx
  21c3b4:	41 5e                	pop    r14
  21c3b6:	5d                   	pop    rbp
  21c3b7:	c3                   	ret    
  21c3b8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  21c3bf:	00 

000000000021c3c0 <__udivdi3>:
    return __udivmoddi4(a, b, null);
  21c3c0:	31 d2                	xor    edx,edx
  21c3c2:	e9 a9 e6 ff ff       	jmp    21aa70 <__udivmoddi4>
  21c3c7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  21c3ce:	00 00 

000000000021c3d0 <__umoddi3>:
extern fn __umoddi3(a: u64, b: u64) u64 {
  21c3d0:	50                   	push   rax
  21c3d1:	48 89 e2             	mov    rdx,rsp
    _ = __udivmoddi4(a, b, &r);
  21c3d4:	e8 97 e6 ff ff       	call   21aa70 <__udivmoddi4>
    return r;
  21c3d9:	48 8b 04 24          	mov    rax,QWORD PTR [rsp]
  21c3dd:	59                   	pop    rcx
  21c3de:	c3                   	ret    
  21c3df:	90                   	nop

000000000021c3e0 <__udivmodsi4>:
extern fn __udivmodsi4(a: u32, b: u32, rem: *u32) u32 {
  21c3e0:	55                   	push   rbp
  21c3e1:	41 57                	push   r15
  21c3e3:	41 56                	push   r14
  21c3e5:	41 55                	push   r13
  21c3e7:	41 54                	push   r12
  21c3e9:	53                   	push   rbx
  21c3ea:	31 c0                	xor    eax,eax
    if (n == 0) return 0;
  21c3ec:	85 ff                	test   edi,edi
    if (d == 0) return 0; // ?!
  21c3ee:	0f 84 33 01 00 00    	je     21c527 <__udivmodsi4+0x147>
  21c3f4:	85 f6                	test   esi,esi
  21c3f6:	0f 84 2b 01 00 00    	je     21c527 <__udivmodsi4+0x147>
    var sr = @bitCast(c_uint, c_int(@clz(d)) - c_int(@clz(n)));
  21c3fc:	f3 44 0f bd de       	lzcnt  r11d,esi
  21c401:	f3 0f bd df          	lzcnt  ebx,edi
  21c405:	44 89 dd             	mov    ebp,r11d
  21c408:	29 dd                	sub    ebp,ebx
    if (sr > n_uword_bits - 1) {
  21c40a:	83 fd 1f             	cmp    ebp,0x1f
  21c40d:	0f 87 14 01 00 00    	ja     21c527 <__udivmodsi4+0x147>
  21c413:	89 f8                	mov    eax,edi
    if (sr == n_uword_bits - 1) {
  21c415:	0f 84 0c 01 00 00    	je     21c527 <__udivmodsi4+0x147>
    sr += 1;
  21c41b:	44 8d 4d 01          	lea    r9d,[rbp+0x1]
    var q: u32 = n << @intCast(u5, n_uword_bits - sr);
  21c41f:	b8 1f 00 00 00       	mov    eax,0x1f
  21c424:	29 e8                	sub    eax,ebp
  21c426:	c4 e2 79 f7 c7       	shlx   eax,edi,eax
    var r: u32 = n >> @intCast(u5, sr);
  21c42b:	c4 e2 33 f7 cf       	shrx   ecx,edi,r9d
  21c430:	44 8d 46 ff          	lea    r8d,[rsi-0x1]
    while (sr > 0) : (sr -= 1) {
  21c434:	41 83 e1 03          	and    r9d,0x3
  21c438:	83 fd 03             	cmp    ebp,0x3
  21c43b:	73 11                	jae    21c44e <__udivmodsi4+0x6e>
  21c43d:	45 31 db             	xor    r11d,r11d
  21c440:	45 85 c9             	test   r9d,r9d
  21c443:	0f 85 aa 00 00 00    	jne    21c4f3 <__udivmodsi4+0x113>
  21c449:	e9 d4 00 00 00       	jmp    21c522 <__udivmodsi4+0x142>
  21c44e:	46 8d 14 0b          	lea    r10d,[rbx+r9*1]
  21c452:	41 83 c2 ff          	add    r10d,0xffffffff
  21c456:	45 29 da             	sub    r10d,r11d
  21c459:	45 31 db             	xor    r11d,r11d
  21c45c:	41 be 1e 01 00 00    	mov    r14d,0x11e
  21c462:	41 bf 1d 01 00 00    	mov    r15d,0x11d
  21c468:	41 bc 1c 01 00 00    	mov    r12d,0x11c
  21c46e:	66 90                	xchg   ax,ax
        r = (r << 1) | (q >> @intCast(u5, n_uword_bits - 1));
  21c470:	0f a4 c1 01          	shld   ecx,eax,0x1
        q = (q << 1) | carry;
  21c474:	44 8d 2c 00          	lea    r13d,[rax+rax*1]
  21c478:	45 09 dd             	or     r13d,r11d
        const s = @intCast(i32, d -% r -% 1) >> @intCast(u5, n_uword_bits - 1);
  21c47b:	44 89 c3             	mov    ebx,r8d
  21c47e:	29 cb                	sub    ebx,ecx
  21c480:	c1 fb 1f             	sar    ebx,0x1f
        carry = @intCast(u32, s & 1);
  21c483:	89 dd                	mov    ebp,ebx
  21c485:	83 e5 01             	and    ebp,0x1
        r -= d & @bitCast(u32, s);
  21c488:	21 f3                	and    ebx,esi
  21c48a:	29 d9                	sub    ecx,ebx
        r = (r << 1) | (q >> @intCast(u5, n_uword_bits - 1));
  21c48c:	c4 e2 08 f7 d8       	bextr  ebx,eax,r14d
  21c491:	8d 0c 4b             	lea    ecx,[rbx+rcx*2]
        q = (q << 1) | carry;
  21c494:	46 8d 5c 6d 00       	lea    r11d,[rbp+r13*2+0x0]
        const s = @intCast(i32, d -% r -% 1) >> @intCast(u5, n_uword_bits - 1);
  21c499:	44 89 c3             	mov    ebx,r8d
  21c49c:	29 cb                	sub    ebx,ecx
  21c49e:	c1 fb 1f             	sar    ebx,0x1f
        carry = @intCast(u32, s & 1);
  21c4a1:	89 dd                	mov    ebp,ebx
  21c4a3:	83 e5 01             	and    ebp,0x1
        r -= d & @bitCast(u32, s);
  21c4a6:	21 f3                	and    ebx,esi
  21c4a8:	29 d9                	sub    ecx,ebx
        r = (r << 1) | (q >> @intCast(u5, n_uword_bits - 1));
  21c4aa:	c4 e2 00 f7 d8       	bextr  ebx,eax,r15d
  21c4af:	8d 0c 4b             	lea    ecx,[rbx+rcx*2]
        q = (q << 1) | carry;
  21c4b2:	46 8d 5c 5d 00       	lea    r11d,[rbp+r11*2+0x0]
        const s = @intCast(i32, d -% r -% 1) >> @intCast(u5, n_uword_bits - 1);
  21c4b7:	44 89 c3             	mov    ebx,r8d
  21c4ba:	29 cb                	sub    ebx,ecx
  21c4bc:	c1 fb 1f             	sar    ebx,0x1f
        carry = @intCast(u32, s & 1);
  21c4bf:	89 dd                	mov    ebp,ebx
  21c4c1:	83 e5 01             	and    ebp,0x1
        r -= d & @bitCast(u32, s);
  21c4c4:	21 f3                	and    ebx,esi
  21c4c6:	29 d9                	sub    ecx,ebx
        r = (r << 1) | (q >> @intCast(u5, n_uword_bits - 1));
  21c4c8:	c4 e2 18 f7 c0       	bextr  eax,eax,r12d
  21c4cd:	8d 0c 48             	lea    ecx,[rax+rcx*2]
        q = (q << 1) | carry;
  21c4d0:	42 8d 44 5d 00       	lea    eax,[rbp+r11*2+0x0]
        const s = @intCast(i32, d -% r -% 1) >> @intCast(u5, n_uword_bits - 1);
  21c4d5:	44 89 c3             	mov    ebx,r8d
  21c4d8:	29 cb                	sub    ebx,ecx
  21c4da:	c1 fb 1f             	sar    ebx,0x1f
        carry = @intCast(u32, s & 1);
  21c4dd:	41 89 db             	mov    r11d,ebx
  21c4e0:	41 83 e3 01          	and    r11d,0x1
        r -= d & @bitCast(u32, s);
  21c4e4:	21 f3                	and    ebx,esi
  21c4e6:	29 d9                	sub    ecx,ebx
    while (sr > 0) : (sr -= 1) {
  21c4e8:	41 83 c2 04          	add    r10d,0x4
  21c4ec:	75 82                	jne    21c470 <__udivmodsi4+0x90>
  21c4ee:	45 85 c9             	test   r9d,r9d
  21c4f1:	74 2f                	je     21c522 <__udivmodsi4+0x142>
  21c4f3:	41 f7 d9             	neg    r9d
  21c4f6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  21c4fd:	00 00 00 
        r = (r << 1) | (q >> @intCast(u5, n_uword_bits - 1));
  21c500:	0f a4 c1 01          	shld   ecx,eax,0x1
        q = (q << 1) | carry;
  21c504:	01 c0                	add    eax,eax
  21c506:	44 09 d8             	or     eax,r11d
        const s = @intCast(i32, d -% r -% 1) >> @intCast(u5, n_uword_bits - 1);
  21c509:	44 89 c5             	mov    ebp,r8d
  21c50c:	29 cd                	sub    ebp,ecx
  21c50e:	c1 fd 1f             	sar    ebp,0x1f
        carry = @intCast(u32, s & 1);
  21c511:	41 89 eb             	mov    r11d,ebp
  21c514:	41 83 e3 01          	and    r11d,0x1
        r -= d & @bitCast(u32, s);
  21c518:	21 f5                	and    ebp,esi
  21c51a:	29 e9                	sub    ecx,ebp
    while (sr > 0) : (sr -= 1) {
  21c51c:	41 83 c1 01          	add    r9d,0x1
  21c520:	75 de                	jne    21c500 <__udivmodsi4+0x120>
    q = (q << 1) | carry;
  21c522:	01 c0                	add    eax,eax
  21c524:	44 09 d8             	or     eax,r11d
    rem.* = @bitCast(u32, @bitCast(i32, a) -% (@bitCast(i32, d) * @bitCast(i32, b)));
  21c527:	0f af f0             	imul   esi,eax
  21c52a:	29 f7                	sub    edi,esi
  21c52c:	89 3a                	mov    DWORD PTR [rdx],edi
    return d;
  21c52e:	5b                   	pop    rbx
  21c52f:	41 5c                	pop    r12
  21c531:	41 5d                	pop    r13
  21c533:	41 5e                	pop    r14
  21c535:	41 5f                	pop    r15
  21c537:	5d                   	pop    rbp
  21c538:	c3                   	ret    
  21c539:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

000000000021c540 <__divti3>:
const compiler_rt = @import("index.zig");

pub extern fn __divti3(a: i128, b: i128) i128 {
    @setRuntimeSafety(builtin.is_test);

    const s_a = a >> (i128.bit_count - 1);
  21c540:	41 56                	push   r14
  21c542:	53                   	push   rbx
  21c543:	50                   	push   rax
  21c544:	48 89 f0             	mov    rax,rsi
  21c547:	48 c1 f8 3f          	sar    rax,0x3f
    const s_b = b >> (i128.bit_count - 1);
  21c54b:	49 89 ce             	mov    r14,rcx
  21c54e:	49 31 f6             	xor    r14,rsi
  21c551:	48 89 cb             	mov    rbx,rcx
  21c554:	48 c1 fb 3f          	sar    rbx,0x3f

    const an = (a ^ s_a) -% s_a;
  21c558:	48 31 c6             	xor    rsi,rax
  21c55b:	48 31 c7             	xor    rdi,rax
  21c55e:	48 29 c7             	sub    rdi,rax
  21c561:	48 19 c6             	sbb    rsi,rax
    const bn = (b ^ s_b) -% s_b;
  21c564:	48 31 d9             	xor    rcx,rbx
  21c567:	48 31 da             	xor    rdx,rbx
  21c56a:	48 29 da             	sub    rdx,rbx
  21c56d:	48 19 d9             	sbb    rcx,rbx

    const r = udivmod(u128, @bitCast(u128, an), @bitCast(u128, bn), null);
  21c570:	45 31 c0             	xor    r8d,r8d
  21c573:	e8 18 00 00 00       	call   21c590 <udivmod.14>
    const s = s_a ^ s_b;
  21c578:	49 c1 fe 3f          	sar    r14,0x3f
    return (@bitCast(i128, r) ^ s) -% s;
  21c57c:	4c 31 f2             	xor    rdx,r14
  21c57f:	4c 31 f0             	xor    rax,r14
  21c582:	4c 29 f0             	sub    rax,r14
  21c585:	4c 19 f2             	sbb    rdx,r14
  21c588:	48 83 c4 08          	add    rsp,0x8
  21c58c:	5b                   	pop    rbx
  21c58d:	41 5e                	pop    r14
  21c58f:	c3                   	ret    

000000000021c590 <udivmod.14>:
pub fn udivmod(comptime DoubleInt: type, a: DoubleInt, b: DoubleInt, maybe_rem: ?*DoubleInt) DoubleInt {
  21c590:	55                   	push   rbp
  21c591:	41 57                	push   r15
  21c593:	41 56                	push   r14
  21c595:	41 55                	push   r13
  21c597:	41 54                	push   r12
  21c599:	53                   	push   rbx
  21c59a:	49 89 d1             	mov    r9,rdx
    if (n[high] == 0) {
  21c59d:	48 85 f6             	test   rsi,rsi
  21c5a0:	74 38                	je     21c5da <udivmod.14+0x4a>
    if (d[low] == 0) {
  21c5a2:	4d 85 c9             	test   r9,r9
  21c5a5:	74 55                	je     21c5fc <udivmod.14+0x6c>
  21c5a7:	48 85 c9             	test   rcx,rcx
        if (d[high] == 0) {
  21c5aa:	0f 84 af 00 00 00    	je     21c65f <udivmod.14+0xcf>
            sr = @bitCast(c_uint, c_int(@clz(d[high])) - c_int(@clz(n[high])));
  21c5b0:	f3 48 0f bd c1       	lzcnt  rax,rcx
  21c5b5:	f3 48 0f bd d6       	lzcnt  rdx,rsi
  21c5ba:	29 d0                	sub    eax,edx
            if (sr > SingleInt.bit_count - 1) {
  21c5bc:	83 f8 40             	cmp    eax,0x40
  21c5bf:	0f 82 23 01 00 00    	jb     21c6e8 <udivmod.14+0x158>
  21c5c5:	4d 85 c0             	test   r8,r8
  21c5c8:	0f 84 3f 01 00 00    	je     21c70d <udivmod.14+0x17d>
  21c5ce:	49 89 38             	mov    QWORD PTR [r8],rdi
  21c5d1:	49 89 70 08          	mov    QWORD PTR [r8+0x8],rsi
  21c5d5:	e9 33 01 00 00       	jmp    21c70d <udivmod.14+0x17d>
        if (d[high] == 0) {
  21c5da:	48 85 c9             	test   rcx,rcx
  21c5dd:	0f 84 df 00 00 00    	je     21c6c2 <udivmod.14+0x132>
  21c5e3:	4d 85 c0             	test   r8,r8
        if (maybe_rem) |rem| {
  21c5e6:	0f 84 21 01 00 00    	je     21c70d <udivmod.14+0x17d>
            rem.* = n[low];
  21c5ec:	49 89 38             	mov    QWORD PTR [r8],rdi
  21c5ef:	49 c7 40 08 00 00 00 	mov    QWORD PTR [r8+0x8],0x0
  21c5f6:	00 
  21c5f7:	e9 11 01 00 00       	jmp    21c70d <udivmod.14+0x17d>
  21c5fc:	48 85 c9             	test   rcx,rcx
        if (d[high] == 0) {
  21c5ff:	0f 84 fa 00 00 00    	je     21c6ff <udivmod.14+0x16f>
        if (n[low] == 0) {
  21c605:	48 85 ff             	test   rdi,rdi
  21c608:	0f 84 6e 02 00 00    	je     21c87c <udivmod.14+0x2ec>
        if ((d[high] & (d[high] - 1)) == 0) {
  21c60e:	48 8d 41 ff          	lea    rax,[rcx-0x1]
  21c612:	48 85 c8             	test   rax,rcx
  21c615:	0f 84 c3 02 00 00    	je     21c8de <udivmod.14+0x34e>
        sr = @bitCast(c_uint, c_int(@clz(d[high])) - c_int(@clz(n[high])));
  21c61b:	f3 4c 0f bd d1       	lzcnt  r10,rcx
  21c620:	f3 48 0f bd c6       	lzcnt  rax,rsi
  21c625:	41 29 c2             	sub    r10d,eax
        if (sr > SingleInt.bit_count - 2) {
  21c628:	41 83 fa 3f          	cmp    r10d,0x3f
  21c62c:	73 97                	jae    21c5c5 <udivmod.14+0x35>
        q[high] = n[low] << @intCast(Log2SingleInt, SingleInt.bit_count - sr);
  21c62e:	b8 3f 00 00 00       	mov    eax,0x3f
  21c633:	44 29 d0             	sub    eax,r10d
        sr += 1;
  21c636:	41 83 c2 01          	add    r10d,0x1
        q[high] = n[low] << @intCast(Log2SingleInt, SingleInt.bit_count - sr);
  21c63a:	83 e0 3f             	and    eax,0x3f
        r[high] = n[high] >> @intCast(Log2SingleInt, sr);
  21c63d:	44 89 d5             	mov    ebp,r10d
  21c640:	83 e5 3f             	and    ebp,0x3f
  21c643:	c4 e2 d3 f7 d6       	shrx   rdx,rsi,rbp
        r[low] = (n[high] << @intCast(Log2SingleInt, SingleInt.bit_count - sr)) | (n[low] >> @intCast(Log2SingleInt, sr));
  21c648:	c4 e2 f9 f7 de       	shlx   rbx,rsi,rax
  21c64d:	c4 e2 d3 f7 f7       	shrx   rsi,rdi,rbp
        q[high] = n[low] << @intCast(Log2SingleInt, SingleInt.bit_count - sr);
  21c652:	c4 e2 f9 f7 ff       	shlx   rdi,rdi,rax
        r[low] = (n[high] << @intCast(Log2SingleInt, SingleInt.bit_count - sr)) | (n[low] >> @intCast(Log2SingleInt, sr));
  21c657:	48 09 de             	or     rsi,rbx
  21c65a:	e9 de 00 00 00       	jmp    21c73d <udivmod.14+0x1ad>
            if ((d[low] & (d[low] - 1)) == 0) {
  21c65f:	49 8d 41 ff          	lea    rax,[r9-0x1]
  21c663:	4c 85 c8             	test   rax,r9
  21c666:	0f 84 36 02 00 00    	je     21c8a2 <udivmod.14+0x312>
            sr = 1 + SingleInt.bit_count + c_uint(@clz(d[low])) - c_uint(@clz(n[high]));
  21c66c:	f3 4d 0f bd d1       	lzcnt  r10,r9
  21c671:	41 83 c2 41          	add    r10d,0x41
  21c675:	f3 48 0f bd c6       	lzcnt  rax,rsi
  21c67a:	41 29 c2             	sub    r10d,eax
            if (sr == SingleInt.bit_count) {
  21c67d:	41 83 fa 40          	cmp    r10d,0x40
  21c681:	74 6f                	je     21c6f2 <udivmod.14+0x162>
  21c683:	44 89 d3             	mov    ebx,r10d
  21c686:	f7 db                	neg    ebx
  21c688:	83 e3 3f             	and    ebx,0x3f
  21c68b:	c4 62 e1 f7 e7       	shlx   r12,rdi,rbx
            } else if (sr < SingleInt.bit_count) {
  21c690:	41 83 fa 40          	cmp    r10d,0x40
  21c694:	0f 83 90 02 00 00    	jae    21c92a <udivmod.14+0x39a>
  21c69a:	31 ed                	xor    ebp,ebp
    while (sr > 0) : (sr -= 1) {
  21c69c:	45 85 d2             	test   r10d,r10d
  21c69f:	0f 84 de 02 00 00    	je     21c983 <udivmod.14+0x3f3>
  21c6a5:	44 89 d5             	mov    ebp,r10d
  21c6a8:	83 e5 3f             	and    ebp,0x3f
  21c6ab:	c4 e2 d3 f7 d6       	shrx   rdx,rsi,rbp
  21c6b0:	c4 e2 e1 f7 de       	shlx   rbx,rsi,rbx
  21c6b5:	c4 e2 d3 f7 f7       	shrx   rsi,rdi,rbp
  21c6ba:	48 09 de             	or     rsi,rbx
  21c6bd:	4c 89 e7             	mov    rdi,r12
  21c6c0:	eb 7b                	jmp    21c73d <udivmod.14+0x1ad>
  21c6c2:	4d 85 c0             	test   r8,r8
            if (maybe_rem) |rem| {
  21c6c5:	0f 84 40 02 00 00    	je     21c90b <udivmod.14+0x37b>
  21c6cb:	48 89 f8             	mov    rax,rdi
  21c6ce:	4c 09 c8             	or     rax,r9
  21c6d1:	48 c1 e8 20          	shr    rax,0x20
  21c6d5:	0f 84 1e 02 00 00    	je     21c8f9 <udivmod.14+0x369>
  21c6db:	31 d2                	xor    edx,edx
  21c6dd:	48 89 f8             	mov    rax,rdi
  21c6e0:	49 f7 f1             	div    r9
  21c6e3:	e9 18 02 00 00       	jmp    21c900 <udivmod.14+0x370>
            sr += 1;
  21c6e8:	44 8d 50 01          	lea    r10d,[rax+0x1]
            if (sr == SingleInt.bit_count) {
  21c6ec:	41 83 fa 40          	cmp    r10d,0x40
  21c6f0:	75 24                	jne    21c716 <udivmod.14+0x186>
  21c6f2:	41 ba 40 00 00 00    	mov    r10d,0x40
  21c6f8:	45 31 e4             	xor    r12d,r12d
  21c6fb:	31 d2                	xor    edx,edx
  21c6fd:	eb 41                	jmp    21c740 <udivmod.14+0x1b0>
            if (maybe_rem) |rem| {
  21c6ff:	4d 85 c0             	test   r8,r8
  21c702:	74 09                	je     21c70d <udivmod.14+0x17d>
                rem.* = n[high] % d[low];
  21c704:	c5 f8 57 c0          	vxorps xmm0,xmm0,xmm0
  21c708:	c4 c1 78 11 00       	vmovups XMMWORD PTR [r8],xmm0
  21c70d:	31 ff                	xor    edi,edi
  21c70f:	31 f6                	xor    esi,esi
  21c711:	e9 5b 01 00 00       	jmp    21c871 <udivmod.14+0x2e1>
                r[high] = n[high] >> @intCast(Log2SingleInt, sr);
  21c716:	44 89 d5             	mov    ebp,r10d
  21c719:	83 e5 3f             	and    ebp,0x3f
  21c71c:	c4 e2 d3 f7 d6       	shrx   rdx,rsi,rbp
  21c721:	bb 3f 00 00 00       	mov    ebx,0x3f
                r[low] = (n[high] << @intCast(Log2SingleInt, SingleInt.bit_count - sr)) | (n[low] >> @intCast(Log2SingleInt, sr));
  21c726:	29 c3                	sub    ebx,eax
  21c728:	83 e3 3f             	and    ebx,0x3f
  21c72b:	c4 e2 e1 f7 c6       	shlx   rax,rsi,rbx
  21c730:	c4 e2 d3 f7 f7       	shrx   rsi,rdi,rbp
  21c735:	48 09 c6             	or     rsi,rax
                q[high] = n[low] << @intCast(Log2SingleInt, SingleInt.bit_count - sr);
  21c738:	c4 e2 e1 f7 ff       	shlx   rdi,rdi,rbx
  21c73d:	45 31 e4             	xor    r12d,r12d
  21c740:	4d 89 cf             	mov    r15,r9
  21c743:	49 83 c7 ff          	add    r15,0xffffffffffffffff
  21c747:	49 89 cb             	mov    r11,rcx
  21c74a:	49 83 d3 ff          	adc    r11,0xffffffffffffffff
    while (sr > 0) : (sr -= 1) {
  21c74e:	44 89 d0             	mov    eax,r10d
  21c751:	83 e0 01             	and    eax,0x1
  21c754:	31 ed                	xor    ebp,ebp
  21c756:	41 83 fa 01          	cmp    r10d,0x1
  21c75a:	75 0f                	jne    21c76b <udivmod.14+0x1db>
  21c75c:	31 db                	xor    ebx,ebx
  21c75e:	85 c0                	test   eax,eax
  21c760:	0f 85 ac 00 00 00    	jne    21c812 <udivmod.14+0x282>
  21c766:	e9 da 00 00 00       	jmp    21c845 <udivmod.14+0x2b5>
  21c76b:	4c 89 44 24 f8       	mov    QWORD PTR [rsp-0x8],r8
  21c770:	89 44 24 f4          	mov    DWORD PTR [rsp-0xc],eax
  21c774:	41 89 c5             	mov    r13d,eax
  21c777:	45 29 d5             	sub    r13d,r10d
  21c77a:	41 ba 3e 01 00 00    	mov    r10d,0x13e
        r[high] = (r[high] << 1) | (r[low] >> (SingleInt.bit_count - 1));
  21c780:	48 0f a4 f2 01       	shld   rdx,rsi,0x1
        r[low] = (r[low] << 1) | (q[high] >> (SingleInt.bit_count - 1));
  21c785:	48 0f a4 fe 01       	shld   rsi,rdi,0x1
        q[high] = (q[high] << 1) | (q[low] >> (SingleInt.bit_count - 1));
  21c78a:	48 89 f8             	mov    rax,rdi
  21c78d:	4c 0f a4 e0 01       	shld   rax,r12,0x1
        q[low] = (q[low] << 1) | carry;
  21c792:	4b 8d 1c 24          	lea    rbx,[r12+r12*1]
  21c796:	89 ed                	mov    ebp,ebp
  21c798:	48 09 dd             	or     rbp,rbx
        const s: SignedDoubleInt = @intCast(SignedDoubleInt, b -% r_all -% 1) >> (DoubleInt.bit_count - 1);
  21c79b:	49 39 f7             	cmp    r15,rsi
  21c79e:	4c 89 db             	mov    rbx,r11
  21c7a1:	48 19 d3             	sbb    rbx,rdx
  21c7a4:	48 c1 fb 3f          	sar    rbx,0x3f
        carry = @intCast(u32, s & 1);
  21c7a8:	41 89 de             	mov    r14d,ebx
  21c7ab:	41 83 e6 01          	and    r14d,0x1
        r_all -= b & @bitCast(DoubleInt, s);
  21c7af:	49 89 d8             	mov    r8,rbx
  21c7b2:	49 21 c8             	and    r8,rcx
  21c7b5:	4c 21 cb             	and    rbx,r9
  21c7b8:	48 29 de             	sub    rsi,rbx
  21c7bb:	4c 19 c2             	sbb    rdx,r8
        r[high] = (r[high] << 1) | (r[low] >> (SingleInt.bit_count - 1));
  21c7be:	48 0f a4 f2 01       	shld   rdx,rsi,0x1
        r[low] = (r[low] << 1) | (q[high] >> (SingleInt.bit_count - 1));
  21c7c3:	c4 e2 a8 f7 ff       	bextr  rdi,rdi,r10
  21c7c8:	48 8d 34 77          	lea    rsi,[rdi+rsi*2]
        q[high] = (q[high] << 1) | (q[low] >> (SingleInt.bit_count - 1));
  21c7cc:	c4 c2 a8 f7 fc       	bextr  rdi,r12,r10
  21c7d1:	48 8d 3c 47          	lea    rdi,[rdi+rax*2]
        q[low] = (q[low] << 1) | carry;
  21c7d5:	4d 8d 24 6e          	lea    r12,[r14+rbp*2]
        const s: SignedDoubleInt = @intCast(SignedDoubleInt, b -% r_all -% 1) >> (DoubleInt.bit_count - 1);
  21c7d9:	49 39 f7             	cmp    r15,rsi
  21c7dc:	4c 89 d8             	mov    rax,r11
  21c7df:	48 19 d0             	sbb    rax,rdx
  21c7e2:	48 c1 f8 3f          	sar    rax,0x3f
        carry = @intCast(u32, s & 1);
  21c7e6:	89 c5                	mov    ebp,eax
  21c7e8:	83 e5 01             	and    ebp,0x1
        r_all -= b & @bitCast(DoubleInt, s);
  21c7eb:	48 89 c3             	mov    rbx,rax
  21c7ee:	48 21 cb             	and    rbx,rcx
  21c7f1:	4c 21 c8             	and    rax,r9
  21c7f4:	48 29 c6             	sub    rsi,rax
  21c7f7:	48 19 da             	sbb    rdx,rbx
    while (sr > 0) : (sr -= 1) {
  21c7fa:	41 83 c5 02          	add    r13d,0x2
  21c7fe:	75 80                	jne    21c780 <udivmod.14+0x1f0>
  21c800:	89 eb                	mov    ebx,ebp
  21c802:	49 89 f2             	mov    r10,rsi
  21c805:	4c 8b 44 24 f8       	mov    r8,QWORD PTR [rsp-0x8]
  21c80a:	8b 44 24 f4          	mov    eax,DWORD PTR [rsp-0xc]
  21c80e:	85 c0                	test   eax,eax
  21c810:	74 33                	je     21c845 <udivmod.14+0x2b5>
        r[high] = (r[high] << 1) | (r[low] >> (SingleInt.bit_count - 1));
  21c812:	48 0f a4 f2 01       	shld   rdx,rsi,0x1
        r[low] = (r[low] << 1) | (q[high] >> (SingleInt.bit_count - 1));
  21c817:	48 0f a4 fe 01       	shld   rsi,rdi,0x1
        const s: SignedDoubleInt = @intCast(SignedDoubleInt, b -% r_all -% 1) >> (DoubleInt.bit_count - 1);
  21c81c:	49 39 f7             	cmp    r15,rsi
  21c81f:	49 19 d3             	sbb    r11,rdx
  21c822:	49 c1 fb 3f          	sar    r11,0x3f
        r_all -= b & @bitCast(DoubleInt, s);
  21c826:	4c 21 d9             	and    rcx,r11
  21c829:	4d 21 d9             	and    r9,r11
  21c82c:	4c 29 ce             	sub    rsi,r9
  21c82f:	48 19 ca             	sbb    rdx,rcx
        carry = @intCast(u32, s & 1);
  21c832:	41 83 e3 01          	and    r11d,0x1
        q[high] = (q[high] << 1) | (q[low] >> (SingleInt.bit_count - 1));
  21c836:	4c 0f a4 e7 01       	shld   rdi,r12,0x1
        q[low] = (q[low] << 1) | carry;
  21c83b:	4e 8d 24 63          	lea    r12,[rbx+r12*2]
  21c83f:	44 89 dd             	mov    ebp,r11d
  21c842:	49 89 f2             	mov    r10,rsi
  21c845:	48 89 f8             	mov    rax,rdi
    const q_all = ((@ptrCast(*align(@alignOf(SingleInt)) DoubleInt, &q[0]).*) << 1) | carry; // TODO issue #421
  21c848:	89 ed                	mov    ebp,ebp
  21c84a:	31 c9                	xor    ecx,ecx
  21c84c:	4c 89 e7             	mov    rdi,r12
  21c84f:	31 f6                	xor    esi,esi
  21c851:	49 89 c4             	mov    r12,rax
  21c854:	4c 09 e6             	or     rsi,r12
  21c857:	48 0f a4 fe 01       	shld   rsi,rdi,0x1
  21c85c:	48 09 ce             	or     rsi,rcx
  21c85f:	48 01 ff             	add    rdi,rdi
  21c862:	48 09 ef             	or     rdi,rbp
    if (maybe_rem) |rem| {
  21c865:	4d 85 c0             	test   r8,r8
  21c868:	74 07                	je     21c871 <udivmod.14+0x2e1>
        rem.* = r_all;
  21c86a:	4d 89 10             	mov    QWORD PTR [r8],r10
  21c86d:	49 89 50 08          	mov    QWORD PTR [r8+0x8],rdx
        return 0;
  21c871:	48 89 f8             	mov    rax,rdi
  21c874:	48 89 f2             	mov    rdx,rsi
  21c877:	e9 fc 00 00 00       	jmp    21c978 <udivmod.14+0x3e8>
            if (maybe_rem) |rem| {
  21c87c:	4d 85 c0             	test   r8,r8
  21c87f:	0f 84 d5 00 00 00    	je     21c95a <udivmod.14+0x3ca>
  21c885:	48 89 f0             	mov    rax,rsi
  21c888:	48 09 c8             	or     rax,rcx
  21c88b:	48 c1 e8 20          	shr    rax,0x20
  21c88f:	0f 84 b4 00 00 00    	je     21c949 <udivmod.14+0x3b9>
  21c895:	31 d2                	xor    edx,edx
  21c897:	48 89 f0             	mov    rax,rsi
  21c89a:	48 f7 f1             	div    rcx
  21c89d:	e9 ad 00 00 00       	jmp    21c94f <udivmod.14+0x3bf>
                if (maybe_rem) |rem| {
  21c8a2:	4d 85 c0             	test   r8,r8
  21c8a5:	74 0e                	je     21c8b5 <udivmod.14+0x325>
                    rem.* = n[low] & (d[low] - 1);
  21c8a7:	48 21 f8             	and    rax,rdi
  21c8aa:	49 89 00             	mov    QWORD PTR [r8],rax
  21c8ad:	49 c7 40 08 00 00 00 	mov    QWORD PTR [r8+0x8],0x0
  21c8b4:	00 
                if (d[low] == 1) {
  21c8b5:	49 83 f9 01          	cmp    r9,0x1
  21c8b9:	74 b6                	je     21c871 <udivmod.14+0x2e1>
                sr = @ctz(d[low]);
  21c8bb:	f3 49 0f bc c1       	tzcnt  rax,r9
                q[high] = n[high] >> @intCast(Log2SingleInt, sr);
  21c8c0:	89 c1                	mov    ecx,eax
  21c8c2:	83 e1 3f             	and    ecx,0x3f
  21c8c5:	c4 e2 f3 f7 d6       	shrx   rdx,rsi,rcx
                q[low] = (n[high] << @intCast(Log2SingleInt, SingleInt.bit_count - sr)) | (n[low] >> @intCast(Log2SingleInt, sr));
  21c8ca:	f7 d8                	neg    eax
  21c8cc:	c4 e2 f9 f7 f6       	shlx   rsi,rsi,rax
  21c8d1:	c4 e2 f3 f7 c7       	shrx   rax,rdi,rcx
  21c8d6:	48 09 f0             	or     rax,rsi
  21c8d9:	e9 9a 00 00 00       	jmp    21c978 <udivmod.14+0x3e8>
            if (maybe_rem) |rem| {
  21c8de:	4d 85 c0             	test   r8,r8
  21c8e1:	74 0a                	je     21c8ed <udivmod.14+0x35d>
                r[high] = n[high] & (d[high] - 1);
  21c8e3:	48 21 f0             	and    rax,rsi
                rem.* = @ptrCast(*align(@alignOf(SingleInt)) DoubleInt, &r[0]).*; // TODO issue #421
  21c8e6:	49 89 38             	mov    QWORD PTR [r8],rdi
  21c8e9:	49 89 40 08          	mov    QWORD PTR [r8+0x8],rax
            return n[high] >> @intCast(Log2SingleInt, @ctz(d[high]));
  21c8ed:	f3 48 0f bc c1       	tzcnt  rax,rcx
  21c8f2:	c4 e2 fb f7 c6       	shrx   rax,rsi,rax
  21c8f7:	eb 7d                	jmp    21c976 <udivmod.14+0x3e6>
  21c8f9:	31 d2                	xor    edx,edx
  21c8fb:	89 f8                	mov    eax,edi
  21c8fd:	41 f7 f1             	div    r9d
                rem.* = n[low] % d[low];
  21c900:	49 89 10             	mov    QWORD PTR [r8],rdx
  21c903:	49 c7 40 08 00 00 00 	mov    QWORD PTR [r8+0x8],0x0
  21c90a:	00 
  21c90b:	48 89 f8             	mov    rax,rdi
  21c90e:	4c 09 c8             	or     rax,r9
  21c911:	48 c1 e8 20          	shr    rax,0x20
  21c915:	74 0a                	je     21c921 <udivmod.14+0x391>
  21c917:	31 d2                	xor    edx,edx
  21c919:	48 89 f8             	mov    rax,rdi
  21c91c:	49 f7 f1             	div    r9
  21c91f:	eb 55                	jmp    21c976 <udivmod.14+0x3e6>
  21c921:	31 d2                	xor    edx,edx
  21c923:	89 f8                	mov    eax,edi
  21c925:	41 f7 f1             	div    r9d
  21c928:	eb 4c                	jmp    21c976 <udivmod.14+0x3e6>
                q[high] = (n[high] << @intCast(Log2SingleInt, DoubleInt.bit_count - sr)) | (n[low] >> @intCast(Log2SingleInt, sr - SingleInt.bit_count));
  21c92a:	c4 e2 e1 f7 d6       	shlx   rdx,rsi,rbx
  21c92f:	44 89 d5             	mov    ebp,r10d
  21c932:	83 e5 3f             	and    ebp,0x3f
  21c935:	c4 e2 d3 f7 ff       	shrx   rdi,rdi,rbp
  21c93a:	48 09 d7             	or     rdi,rdx
                r[low] = n[high] >> @intCast(Log2SingleInt, sr - SingleInt.bit_count);
  21c93d:	c4 e2 d3 f7 f6       	shrx   rsi,rsi,rbp
  21c942:	31 d2                	xor    edx,edx
  21c944:	e9 f7 fd ff ff       	jmp    21c740 <udivmod.14+0x1b0>
  21c949:	31 d2                	xor    edx,edx
  21c94b:	89 f0                	mov    eax,esi
  21c94d:	f7 f1                	div    ecx
                rem.* = @ptrCast(*align(@alignOf(SingleInt)) DoubleInt, &r[0]).*; // TODO issue #421
  21c94f:	49 89 50 08          	mov    QWORD PTR [r8+0x8],rdx
  21c953:	49 c7 00 00 00 00 00 	mov    QWORD PTR [r8],0x0
  21c95a:	48 89 f0             	mov    rax,rsi
  21c95d:	48 09 c8             	or     rax,rcx
  21c960:	48 c1 e8 20          	shr    rax,0x20
  21c964:	74 0a                	je     21c970 <udivmod.14+0x3e0>
  21c966:	31 d2                	xor    edx,edx
  21c968:	48 89 f0             	mov    rax,rsi
  21c96b:	48 f7 f1             	div    rcx
  21c96e:	eb 06                	jmp    21c976 <udivmod.14+0x3e6>
  21c970:	31 d2                	xor    edx,edx
  21c972:	89 f0                	mov    eax,esi
  21c974:	f7 f1                	div    ecx
  21c976:	31 d2                	xor    edx,edx
  21c978:	5b                   	pop    rbx
  21c979:	41 5c                	pop    r12
  21c97b:	41 5d                	pop    r13
  21c97d:	41 5e                	pop    r14
  21c97f:	41 5f                	pop    r15
  21c981:	5d                   	pop    rbp
  21c982:	c3                   	ret    
  21c983:	31 c9                	xor    ecx,ecx
  21c985:	31 ff                	xor    edi,edi
  21c987:	31 f6                	xor    esi,esi
  21c989:	e9 c6 fe ff ff       	jmp    21c854 <udivmod.14+0x2c4>
  21c98e:	66 90                	xchg   ax,ax

000000000021c990 <__muloti4>:
const udivmod = @import("udivmod.zig").udivmod;
const builtin = @import("builtin");
const compiler_rt = @import("index.zig");

pub extern fn __muloti4(a: i128, b: i128, overflow: *c_int) i128 {
  21c990:	55                   	push   rbp
  21c991:	41 57                	push   r15
  21c993:	41 56                	push   r14
  21c995:	41 55                	push   r13
  21c997:	41 54                	push   r12
  21c999:	53                   	push   rbx
  21c99a:	48 83 ec 28          	sub    rsp,0x28
  21c99e:	4d 89 c7             	mov    r15,r8
  21c9a1:	48 89 d5             	mov    rbp,rdx
  21c9a4:	49 89 f4             	mov    r12,rsi
  21c9a7:	48 89 fb             	mov    rbx,rdi
  21c9aa:	c4 c1 f9 6e c4       	vmovq  xmm0,r12
  21c9af:	c4 e1 f9 6e cb       	vmovq  xmm1,rbx
  21c9b4:	c5 f1 6c c0          	vpunpcklqdq xmm0,xmm1,xmm0
    @setRuntimeSafety(builtin.is_test);

    const min = @bitCast(i128, u128(1 << (i128.bit_count - 1)));
    const max = ~min;
    overflow.* = 0;
  21c9b8:	41 c7 07 00 00 00 00 	mov    DWORD PTR [r15],0x0

    const r = a *% b;
  21c9bf:	48 89 e8             	mov    rax,rbp
  21c9c2:	49 0f af c4          	imul   rax,r12
  21c9c6:	c4 e2 8b f6 d3       	mulx   rdx,r14,rbx
  21c9cb:	48 01 c2             	add    rdx,rax
  21c9ce:	49 89 cd             	mov    r13,rcx
  21c9d1:	4c 0f af eb          	imul   r13,rbx
  21c9d5:	49 01 d5             	add    r13,rdx
    if (a == min) {
  21c9d8:	48 be 00 00 00 00 00 	movabs rsi,0x8000000000000000
  21c9df:	00 00 80 
  21c9e2:	c4 e1 f9 6e ce       	vmovq  xmm1,rsi
  21c9e7:	c5 e9 73 f9 08       	vpslldq xmm2,xmm1,0x8
  21c9ec:	c5 f9 74 c2          	vpcmpeqb xmm0,xmm0,xmm2
  21c9f0:	c5 f9 d7 c0          	vpmovmskb eax,xmm0
  21c9f4:	3d ff ff 00 00       	cmp    eax,0xffff
  21c9f9:	75 13                	jne    21ca0e <__muloti4+0x7e>
        if (b != 0 and b != 1) {
  21c9fb:	48 83 fd 02          	cmp    rbp,0x2
  21c9ff:	48 83 d9 00          	sbb    rcx,0x0
  21ca03:	0f 83 b7 00 00 00    	jae    21cac0 <__muloti4+0x130>
  21ca09:	e9 b9 00 00 00       	jmp    21cac7 <__muloti4+0x137>
            overflow.* = 1;
        }
        return r;
    }
    if (b == min) {
  21ca0e:	c4 e1 f9 6e c5       	vmovq  xmm0,rbp
  21ca13:	c4 e1 f9 6e c9       	vmovq  xmm1,rcx
  21ca18:	c5 f9 6c c1          	vpunpcklqdq xmm0,xmm0,xmm1
  21ca1c:	c5 f9 74 c2          	vpcmpeqb xmm0,xmm0,xmm2
  21ca20:	c5 f9 d7 c0          	vpmovmskb eax,xmm0
  21ca24:	3d ff ff 00 00       	cmp    eax,0xffff
  21ca29:	75 13                	jne    21ca3e <__muloti4+0xae>
        if (a != 0 and a != 1) {
  21ca2b:	48 83 fb 02          	cmp    rbx,0x2
  21ca2f:	49 83 dc 00          	sbb    r12,0x0
  21ca33:	0f 83 87 00 00 00    	jae    21cac0 <__muloti4+0x130>
  21ca39:	e9 89 00 00 00       	jmp    21cac7 <__muloti4+0x137>
            overflow.* = 1;
        }
        return r;
    }

    const sa = a >> (i128.bit_count - 1);
  21ca3e:	4c 89 e0             	mov    rax,r12
  21ca41:	48 c1 f8 3f          	sar    rax,0x3f
    const abs_a = (a ^ sa) -% sa;
  21ca45:	49 31 c4             	xor    r12,rax
  21ca48:	48 31 c3             	xor    rbx,rax
  21ca4b:	48 29 c3             	sub    rbx,rax
  21ca4e:	49 19 c4             	sbb    r12,rax
    const sb = b >> (i128.bit_count - 1);
  21ca51:	48 89 ca             	mov    rdx,rcx
  21ca54:	48 c1 fa 3f          	sar    rdx,0x3f
    const abs_b = (b ^ sb) -% sb;
  21ca58:	48 31 d1             	xor    rcx,rdx
  21ca5b:	48 31 d5             	xor    rbp,rdx
  21ca5e:	48 29 d5             	sub    rbp,rdx
  21ca61:	48 19 d1             	sbb    rcx,rdx

    if (abs_a < 2 or abs_b < 2) {
  21ca64:	48 83 fb 02          	cmp    rbx,0x2
  21ca68:	4c 89 e7             	mov    rdi,r12
  21ca6b:	48 83 df 00          	sbb    rdi,0x0
  21ca6f:	7c 56                	jl     21cac7 <__muloti4+0x137>
  21ca71:	48 83 fd 02          	cmp    rbp,0x2
  21ca75:	48 89 cf             	mov    rdi,rcx
  21ca78:	48 83 df 00          	sbb    rdi,0x0
  21ca7c:	7c 49                	jl     21cac7 <__muloti4+0x137>
        return r;
    }

    if (sa == sb) {
  21ca7e:	c4 e1 f9 6e c2       	vmovq  xmm0,rdx
  21ca83:	c5 f9 6c c0          	vpunpcklqdq xmm0,xmm0,xmm0
  21ca87:	c4 e1 f9 6e c8       	vmovq  xmm1,rax
  21ca8c:	c5 f1 6c c9          	vpunpcklqdq xmm1,xmm1,xmm1
  21ca90:	c5 f1 74 c0          	vpcmpeqb xmm0,xmm1,xmm0
  21ca94:	c5 f9 d7 c0          	vpmovmskb eax,xmm0
  21ca98:	3d ff ff 00 00       	cmp    eax,0xffff
  21ca9d:	75 3d                	jne    21cadc <__muloti4+0x14c>
  21ca9f:	48 be ff ff ff ff ff 	movabs rsi,0x7fffffffffffffff
  21caa6:	ff ff 7f 
  21caa9:	48 c7 c7 ff ff ff ff 	mov    rdi,0xffffffffffffffff
  21cab0:	48 89 ea             	mov    rdx,rbp
  21cab3:	e8 a8 00 00 00       	call   21cb60 <__udivti3>
        if (abs_a > @divFloor(max, abs_b)) {
  21cab8:	48 39 d8             	cmp    rax,rbx
  21cabb:	4c 19 e2             	sbb    rdx,r12
  21cabe:	7d 07                	jge    21cac7 <__muloti4+0x137>
  21cac0:	41 c7 07 01 00 00 00 	mov    DWORD PTR [r15],0x1
        return r;
  21cac7:	4c 89 f0             	mov    rax,r14
  21caca:	4c 89 ea             	mov    rdx,r13
  21cacd:	48 83 c4 28          	add    rsp,0x28
  21cad1:	5b                   	pop    rbx
  21cad2:	41 5c                	pop    r12
  21cad4:	41 5d                	pop    r13
  21cad6:	41 5e                	pop    r14
  21cad8:	41 5f                	pop    r15
  21cada:	5d                   	pop    rbp
  21cadb:	c3                   	ret    
  21cadc:	31 c0                	xor    eax,eax
            overflow.* = 1;
        }
    } else {
        if (abs_a > @divFloor(min, -abs_b)) {
  21cade:	48 f7 dd             	neg    rbp
  21cae1:	48 19 c8             	sbb    rax,rcx
  21cae4:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  21cae9:	31 ff                	xor    edi,edi
  21caeb:	48 89 ea             	mov    rdx,rbp
  21caee:	48 89 c1             	mov    rcx,rax
  21caf1:	c5 f9 7f 54 24 10    	vmovdqa XMMWORD PTR [rsp+0x10],xmm2
  21caf7:	e8 44 fa ff ff       	call   21c540 <__divti3>
  21cafc:	48 89 d1             	mov    rcx,rdx
  21caff:	48 85 c9             	test   rcx,rcx
  21cb02:	41 0f 98 c0          	sets   r8b
  21cb06:	48 89 c2             	mov    rdx,rax
  21cb09:	c4 e2 eb f6 fd       	mulx   rdi,rdx,rbp
  21cb0e:	48 8b 74 24 08       	mov    rsi,QWORD PTR [rsp+0x8]
  21cb13:	48 0f af f0          	imul   rsi,rax
  21cb17:	48 01 f7             	add    rdi,rsi
  21cb1a:	48 0f af e9          	imul   rbp,rcx
  21cb1e:	48 01 fd             	add    rbp,rdi
  21cb21:	c4 e1 f9 6e c5       	vmovq  xmm0,rbp
  21cb26:	c4 e1 f9 6e ca       	vmovq  xmm1,rdx
  21cb2b:	c5 f1 6c c0          	vpunpcklqdq xmm0,xmm1,xmm0
  21cb2f:	c5 f9 74 44 24 10    	vpcmpeqb xmm0,xmm0,XMMWORD PTR [rsp+0x10]
  21cb35:	c5 f9 d7 d0          	vpmovmskb edx,xmm0
  21cb39:	81 fa ff ff 00 00    	cmp    edx,0xffff
  21cb3f:	0f 95 c2             	setne  dl
  21cb42:	44 20 c2             	and    dl,r8b
  21cb45:	0f b6 d2             	movzx  edx,dl
  21cb48:	48 29 d0             	sub    rax,rdx
  21cb4b:	48 83 d9 00          	sbb    rcx,0x0
  21cb4f:	48 39 d8             	cmp    rax,rbx
  21cb52:	4c 19 e1             	sbb    rcx,r12
  21cb55:	0f 8c 65 ff ff ff    	jl     21cac0 <__muloti4+0x130>
  21cb5b:	e9 67 ff ff ff       	jmp    21cac7 <__muloti4+0x137>

000000000021cb60 <__udivti3>:
const builtin = @import("builtin");
const compiler_rt = @import("index.zig");

pub extern fn __udivmodti4(a: u128, b: u128, maybe_rem: ?*u128) u128 {
    @setRuntimeSafety(builtin.is_test);
    return udivmod(u128, a, b, maybe_rem);
  21cb60:	45 31 c0             	xor    r8d,r8d
  21cb63:	e9 28 fa ff ff       	jmp    21c590 <udivmod.14>
  21cb68:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  21cb6f:	00 

000000000021cb70 <__udivmodti4>:
  21cb70:	e9 1b fa ff ff       	jmp    21c590 <udivmod.14>
  21cb75:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21cb7c:	00 00 00 00 

000000000021cb80 <__umodti3>:
const udivmodti4 = @import("udivmodti4.zig");
const builtin = @import("builtin");
const compiler_rt = @import("index.zig");

pub extern fn __umodti3(a: u128, b: u128) u128 {
  21cb80:	48 83 ec 18          	sub    rsp,0x18
  21cb84:	4c 8d 44 24 08       	lea    r8,[rsp+0x8]
  21cb89:	e8 02 fa ff ff       	call   21c590 <udivmod.14>
    @setRuntimeSafety(builtin.is_test);
    var r: u128 = undefined;
    _ = udivmodti4.__udivmodti4(a, b, &r);
    return r;
  21cb8e:	48 8b 44 24 08       	mov    rax,QWORD PTR [rsp+0x8]
  21cb93:	48 8b 54 24 10       	mov    rdx,QWORD PTR [rsp+0x10]
  21cb98:	48 83 c4 18          	add    rsp,0x18
  21cb9c:	c3                   	ret    
